{
  "module_name": "br_private.h",
  "hash_id": "8ac7ef91f8548560b4f5875ae08e84b885ad9c124386c916635de5075588f449",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_private.h",
  "human_readable_source": " \n \n\n#ifndef _BR_PRIVATE_H\n#define _BR_PRIVATE_H\n\n#include <linux/netdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/netpoll.h>\n#include <linux/u64_stats_sync.h>\n#include <net/route.h>\n#include <net/ip6_fib.h>\n#include <net/pkt_cls.h>\n#include <linux/if_vlan.h>\n#include <linux/rhashtable.h>\n#include <linux/refcount.h>\n\n#define BR_HASH_BITS 8\n#define BR_HASH_SIZE (1 << BR_HASH_BITS)\n\n#define BR_HOLD_TIME (1*HZ)\n\n#define BR_PORT_BITS\t10\n#define BR_MAX_PORTS\t(1<<BR_PORT_BITS)\n\n#define BR_MULTICAST_DEFAULT_HASH_MAX 4096\n#define BR_MULTICAST_QUERY_INTVL_MIN msecs_to_jiffies(1000)\n#define BR_MULTICAST_STARTUP_QUERY_INTVL_MIN BR_MULTICAST_QUERY_INTVL_MIN\n\n#define BR_HWDOM_MAX BITS_PER_LONG\n\n#define BR_VERSION\t\"2.3\"\n\n \n#define BR_GROUPFWD_DEFAULT\t0\n \nenum {\n\tBR_GROUPFWD_STP\t\t= BIT(0),\n\tBR_GROUPFWD_MACPAUSE\t= BIT(1),\n\tBR_GROUPFWD_LACP\t= BIT(2),\n};\n\n#define BR_GROUPFWD_RESTRICTED (BR_GROUPFWD_STP | BR_GROUPFWD_MACPAUSE | \\\n\t\t\t\tBR_GROUPFWD_LACP)\n \n#define BR_GROUPFWD_8021AD\t0xB801u\n\n \n#define BR_STP_PROG\t\"/sbin/bridge-stp\"\n\n#define BR_FDB_NOTIFY_SETTABLE_BITS (FDB_NOTIFY_BIT | FDB_NOTIFY_INACTIVE_BIT)\n\ntypedef struct bridge_id bridge_id;\ntypedef struct mac_addr mac_addr;\ntypedef __u16 port_id;\n\nstruct bridge_id {\n\tunsigned char\tprio[2];\n\tunsigned char\taddr[ETH_ALEN];\n};\n\nstruct mac_addr {\n\tunsigned char\taddr[ETH_ALEN];\n};\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n \nstruct bridge_mcast_own_query {\n\tstruct timer_list\ttimer;\n\tu32\t\t\tstartup_sent;\n};\n\n \nstruct bridge_mcast_other_query {\n\tstruct timer_list\t\ttimer;\n\tunsigned long\t\t\tdelay_time;\n};\n\n \nstruct bridge_mcast_querier {\n\tstruct br_ip addr;\n\tint port_ifidx;\n\tseqcount_spinlock_t seq;\n};\n\n \nstruct bridge_mcast_stats {\n\tstruct br_mcast_stats mstats;\n\tstruct u64_stats_sync syncp;\n};\n\nstruct br_mdb_src_entry {\n\tstruct br_ip\t\t\taddr;\n};\n\nstruct br_mdb_config {\n\tstruct net_bridge\t\t*br;\n\tstruct net_bridge_port\t\t*p;\n\tstruct br_mdb_entry\t\t*entry;\n\tstruct br_ip\t\t\tgroup;\n\tbool\t\t\t\tsrc_entry;\n\tu8\t\t\t\tfilter_mode;\n\tu16\t\t\t\tnlflags;\n\tstruct br_mdb_src_entry\t\t*src_entries;\n\tint\t\t\t\tnum_src_entries;\n\tu8\t\t\t\trt_protocol;\n};\n#endif\n\n \nstruct net_bridge_mcast_port {\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tstruct net_bridge_port\t\t*port;\n\tstruct net_bridge_vlan\t\t*vlan;\n\n\tstruct bridge_mcast_own_query\tip4_own_query;\n\tstruct timer_list\t\tip4_mc_router_timer;\n\tstruct hlist_node\t\tip4_rlist;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct bridge_mcast_own_query\tip6_own_query;\n\tstruct timer_list\t\tip6_mc_router_timer;\n\tstruct hlist_node\t\tip6_rlist;\n#endif  \n\tunsigned char\t\t\tmulticast_router;\n\tu32\t\t\t\tmdb_n_entries;\n\tu32\t\t\t\tmdb_max_entries;\n#endif  \n};\n\n \nstruct net_bridge_mcast {\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tstruct net_bridge\t\t*br;\n\tstruct net_bridge_vlan\t\t*vlan;\n\n\tu32\t\t\t\tmulticast_last_member_count;\n\tu32\t\t\t\tmulticast_startup_query_count;\n\n\tu8\t\t\t\tmulticast_querier;\n\tu8\t\t\t\tmulticast_igmp_version;\n\tu8\t\t\t\tmulticast_router;\n#if IS_ENABLED(CONFIG_IPV6)\n\tu8\t\t\t\tmulticast_mld_version;\n#endif\n\tunsigned long\t\t\tmulticast_last_member_interval;\n\tunsigned long\t\t\tmulticast_membership_interval;\n\tunsigned long\t\t\tmulticast_querier_interval;\n\tunsigned long\t\t\tmulticast_query_interval;\n\tunsigned long\t\t\tmulticast_query_response_interval;\n\tunsigned long\t\t\tmulticast_startup_query_interval;\n\tstruct hlist_head\t\tip4_mc_router_list;\n\tstruct timer_list\t\tip4_mc_router_timer;\n\tstruct bridge_mcast_other_query\tip4_other_query;\n\tstruct bridge_mcast_own_query\tip4_own_query;\n\tstruct bridge_mcast_querier\tip4_querier;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct hlist_head\t\tip6_mc_router_list;\n\tstruct timer_list\t\tip6_mc_router_timer;\n\tstruct bridge_mcast_other_query\tip6_other_query;\n\tstruct bridge_mcast_own_query\tip6_own_query;\n\tstruct bridge_mcast_querier\tip6_querier;\n#endif  \n#endif  \n};\n\nstruct br_tunnel_info {\n\t__be64\t\t\t\ttunnel_id;\n\tstruct metadata_dst __rcu\t*tunnel_dst;\n};\n\n \nenum {\n\tBR_VLFLAG_PER_PORT_STATS = BIT(0),\n\tBR_VLFLAG_ADDED_BY_SWITCHDEV = BIT(1),\n\tBR_VLFLAG_MCAST_ENABLED = BIT(2),\n\tBR_VLFLAG_GLOBAL_MCAST_ENABLED = BIT(3),\n\tBR_VLFLAG_NEIGH_SUPPRESS_ENABLED = BIT(4),\n};\n\n \nstruct net_bridge_vlan {\n\tstruct rhash_head\t\tvnode;\n\tstruct rhash_head\t\ttnode;\n\tu16\t\t\t\tvid;\n\tu16\t\t\t\tflags;\n\tu16\t\t\t\tpriv_flags;\n\tu8\t\t\t\tstate;\n\tstruct pcpu_sw_netstats __percpu *stats;\n\tunion {\n\t\tstruct net_bridge\t*br;\n\t\tstruct net_bridge_port\t*port;\n\t};\n\tunion {\n\t\trefcount_t\t\trefcnt;\n\t\tstruct net_bridge_vlan\t*brvlan;\n\t};\n\n\tstruct br_tunnel_info\t\ttinfo;\n\n\tunion {\n\t\tstruct net_bridge_mcast\t\tbr_mcast_ctx;\n\t\tstruct net_bridge_mcast_port\tport_mcast_ctx;\n\t};\n\n\tu16\t\t\t\tmsti;\n\n\tstruct list_head\t\tvlist;\n\n\tstruct rcu_head\t\t\trcu;\n};\n\n \nstruct net_bridge_vlan_group {\n\tstruct rhashtable\t\tvlan_hash;\n\tstruct rhashtable\t\ttunnel_hash;\n\tstruct list_head\t\tvlan_list;\n\tu16\t\t\t\tnum_vlans;\n\tu16\t\t\t\tpvid;\n\tu8\t\t\t\tpvid_state;\n};\n\n \nenum {\n\tBR_FDB_LOCAL,\n\tBR_FDB_STATIC,\n\tBR_FDB_STICKY,\n\tBR_FDB_ADDED_BY_USER,\n\tBR_FDB_ADDED_BY_EXT_LEARN,\n\tBR_FDB_OFFLOADED,\n\tBR_FDB_NOTIFY,\n\tBR_FDB_NOTIFY_INACTIVE,\n\tBR_FDB_LOCKED,\n};\n\nstruct net_bridge_fdb_key {\n\tmac_addr addr;\n\tu16 vlan_id;\n};\n\nstruct net_bridge_fdb_entry {\n\tstruct rhash_head\t\trhnode;\n\tstruct net_bridge_port\t\t*dst;\n\n\tstruct net_bridge_fdb_key\tkey;\n\tstruct hlist_node\t\tfdb_node;\n\tunsigned long\t\t\tflags;\n\n\t \n\tunsigned long\t\t\tupdated ____cacheline_aligned_in_smp;\n\tunsigned long\t\t\tused;\n\n\tstruct rcu_head\t\t\trcu;\n};\n\nstruct net_bridge_fdb_flush_desc {\n\tunsigned long\t\t\tflags;\n\tunsigned long\t\t\tflags_mask;\n\tint\t\t\t\tport_ifindex;\n\tu16\t\t\t\tvlan_id;\n};\n\n#define MDB_PG_FLAGS_PERMANENT\tBIT(0)\n#define MDB_PG_FLAGS_OFFLOAD\tBIT(1)\n#define MDB_PG_FLAGS_FAST_LEAVE\tBIT(2)\n#define MDB_PG_FLAGS_STAR_EXCL\tBIT(3)\n#define MDB_PG_FLAGS_BLOCKED\tBIT(4)\n\n#define PG_SRC_ENT_LIMIT\t32\n\n#define BR_SGRP_F_DELETE\tBIT(0)\n#define BR_SGRP_F_SEND\t\tBIT(1)\n#define BR_SGRP_F_INSTALLED\tBIT(2)\n#define BR_SGRP_F_USER_ADDED\tBIT(3)\n\nstruct net_bridge_mcast_gc {\n\tstruct hlist_node\t\tgc_node;\n\tvoid\t\t\t\t(*destroy)(struct net_bridge_mcast_gc *gc);\n};\n\nstruct net_bridge_group_src {\n\tstruct hlist_node\t\tnode;\n\n\tstruct br_ip\t\t\taddr;\n\tstruct net_bridge_port_group\t*pg;\n\tu8\t\t\t\tflags;\n\tu8\t\t\t\tsrc_query_rexmit_cnt;\n\tstruct timer_list\t\ttimer;\n\n\tstruct net_bridge\t\t*br;\n\tstruct net_bridge_mcast_gc\tmcast_gc;\n\tstruct rcu_head\t\t\trcu;\n};\n\nstruct net_bridge_port_group_sg_key {\n\tstruct net_bridge_port\t\t*port;\n\tstruct br_ip\t\t\taddr;\n};\n\nstruct net_bridge_port_group {\n\tstruct net_bridge_port_group __rcu *next;\n\tstruct net_bridge_port_group_sg_key key;\n\tunsigned char\t\t\teth_addr[ETH_ALEN] __aligned(2);\n\tunsigned char\t\t\tflags;\n\tunsigned char\t\t\tfilter_mode;\n\tunsigned char\t\t\tgrp_query_rexmit_cnt;\n\tunsigned char\t\t\trt_protocol;\n\n\tstruct hlist_head\t\tsrc_list;\n\tunsigned int\t\t\tsrc_ents;\n\tstruct timer_list\t\ttimer;\n\tstruct timer_list\t\trexmit_timer;\n\tstruct hlist_node\t\tmglist;\n\tstruct rb_root\t\t\teht_set_tree;\n\tstruct rb_root\t\t\teht_host_tree;\n\n\tstruct rhash_head\t\trhnode;\n\tstruct net_bridge_mcast_gc\tmcast_gc;\n\tstruct rcu_head\t\t\trcu;\n};\n\nstruct net_bridge_mdb_entry {\n\tstruct rhash_head\t\trhnode;\n\tstruct net_bridge\t\t*br;\n\tstruct net_bridge_port_group __rcu *ports;\n\tstruct br_ip\t\t\taddr;\n\tbool\t\t\t\thost_joined;\n\n\tstruct timer_list\t\ttimer;\n\tstruct hlist_node\t\tmdb_node;\n\n\tstruct net_bridge_mcast_gc\tmcast_gc;\n\tstruct rcu_head\t\t\trcu;\n};\n\nstruct net_bridge_port {\n\tstruct net_bridge\t\t*br;\n\tstruct net_device\t\t*dev;\n\tnetdevice_tracker\t\tdev_tracker;\n\tstruct list_head\t\tlist;\n\n\tunsigned long\t\t\tflags;\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\n\tstruct net_bridge_vlan_group\t__rcu *vlgrp;\n#endif\n\tstruct net_bridge_port\t\t__rcu *backup_port;\n\tu32\t\t\t\tbackup_nhid;\n\n\t \n\tu8\t\t\t\tpriority;\n\tu8\t\t\t\tstate;\n\tu16\t\t\t\tport_no;\n\tunsigned char\t\t\ttopology_change_ack;\n\tunsigned char\t\t\tconfig_pending;\n\tport_id\t\t\t\tport_id;\n\tport_id\t\t\t\tdesignated_port;\n\tbridge_id\t\t\tdesignated_root;\n\tbridge_id\t\t\tdesignated_bridge;\n\tu32\t\t\t\tpath_cost;\n\tu32\t\t\t\tdesignated_cost;\n\tunsigned long\t\t\tdesignated_age;\n\n\tstruct timer_list\t\tforward_delay_timer;\n\tstruct timer_list\t\thold_timer;\n\tstruct timer_list\t\tmessage_age_timer;\n\tstruct kobject\t\t\tkobj;\n\tstruct rcu_head\t\t\trcu;\n\n\tstruct net_bridge_mcast_port\tmulticast_ctx;\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tstruct bridge_mcast_stats\t__percpu *mcast_stats;\n\n\tu32\t\t\t\tmulticast_eht_hosts_limit;\n\tu32\t\t\t\tmulticast_eht_hosts_cnt;\n\tstruct hlist_head\t\tmglist;\n#endif\n\n#ifdef CONFIG_SYSFS\n\tchar\t\t\t\tsysfs_name[IFNAMSIZ];\n#endif\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\tstruct netpoll\t\t\t*np;\n#endif\n#ifdef CONFIG_NET_SWITCHDEV\n\t \n\tint\t\t\t\thwdom;\n\tint\t\t\t\toffload_count;\n\tstruct netdev_phys_item_id\tppid;\n#endif\n\tu16\t\t\t\tgroup_fwd_mask;\n\tu16\t\t\t\tbackup_redirected_cnt;\n\n\tstruct bridge_stp_xstats\tstp_xstats;\n};\n\n#define kobj_to_brport(obj)\tcontainer_of(obj, struct net_bridge_port, kobj)\n\n#define br_auto_port(p) ((p)->flags & BR_AUTO_MASK)\n#define br_promisc_port(p) ((p)->flags & BR_PROMISC)\n\nstatic inline struct net_bridge_port *br_port_get_rcu(const struct net_device *dev)\n{\n\treturn rcu_dereference(dev->rx_handler_data);\n}\n\nstatic inline struct net_bridge_port *br_port_get_rtnl(const struct net_device *dev)\n{\n\treturn netif_is_bridge_port(dev) ?\n\t\trtnl_dereference(dev->rx_handler_data) : NULL;\n}\n\nstatic inline struct net_bridge_port *br_port_get_rtnl_rcu(const struct net_device *dev)\n{\n\treturn netif_is_bridge_port(dev) ?\n\t\trcu_dereference_rtnl(dev->rx_handler_data) : NULL;\n}\n\nenum net_bridge_opts {\n\tBROPT_VLAN_ENABLED,\n\tBROPT_VLAN_STATS_ENABLED,\n\tBROPT_NF_CALL_IPTABLES,\n\tBROPT_NF_CALL_IP6TABLES,\n\tBROPT_NF_CALL_ARPTABLES,\n\tBROPT_GROUP_ADDR_SET,\n\tBROPT_MULTICAST_ENABLED,\n\tBROPT_MULTICAST_QUERY_USE_IFADDR,\n\tBROPT_MULTICAST_STATS_ENABLED,\n\tBROPT_HAS_IPV6_ADDR,\n\tBROPT_NEIGH_SUPPRESS_ENABLED,\n\tBROPT_MTU_SET_BY_USER,\n\tBROPT_VLAN_STATS_PER_PORT,\n\tBROPT_NO_LL_LEARN,\n\tBROPT_VLAN_BRIDGE_BINDING,\n\tBROPT_MCAST_VLAN_SNOOPING_ENABLED,\n\tBROPT_MST_ENABLED,\n};\n\nstruct net_bridge {\n\tspinlock_t\t\t\tlock;\n\tspinlock_t\t\t\thash_lock;\n\tstruct hlist_head\t\tframe_type_list;\n\tstruct net_device\t\t*dev;\n\tunsigned long\t\t\toptions;\n\t \n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\n\t__be16\t\t\t\tvlan_proto;\n\tu16\t\t\t\tdefault_pvid;\n\tstruct net_bridge_vlan_group\t__rcu *vlgrp;\n#endif\n\n\tstruct rhashtable\t\tfdb_hash_tbl;\n\tstruct list_head\t\tport_list;\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tunion {\n\t\tstruct rtable\t\tfake_rtable;\n\t\tstruct rt6_info\t\tfake_rt6_info;\n\t};\n#endif\n\tu16\t\t\t\tgroup_fwd_mask;\n\tu16\t\t\t\tgroup_fwd_mask_required;\n\n\t \n\tbridge_id\t\t\tdesignated_root;\n\tbridge_id\t\t\tbridge_id;\n\tunsigned char\t\t\ttopology_change;\n\tunsigned char\t\t\ttopology_change_detected;\n\tu16\t\t\t\troot_port;\n\tunsigned long\t\t\tmax_age;\n\tunsigned long\t\t\thello_time;\n\tunsigned long\t\t\tforward_delay;\n\tunsigned long\t\t\tageing_time;\n\tunsigned long\t\t\tbridge_max_age;\n\tunsigned long\t\t\tbridge_hello_time;\n\tunsigned long\t\t\tbridge_forward_delay;\n\tunsigned long\t\t\tbridge_ageing_time;\n\tu32\t\t\t\troot_path_cost;\n\n\tu8\t\t\t\tgroup_addr[ETH_ALEN];\n\n\tenum {\n\t\tBR_NO_STP, \t\t \n\t\tBR_KERNEL_STP,\t\t \n\t\tBR_USER_STP,\t\t \n\t} stp_enabled;\n\n\tstruct net_bridge_mcast\t\tmulticast_ctx;\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tstruct bridge_mcast_stats\t__percpu *mcast_stats;\n\n\tu32\t\t\t\thash_max;\n\n\tspinlock_t\t\t\tmulticast_lock;\n\n\tstruct rhashtable\t\tmdb_hash_tbl;\n\tstruct rhashtable\t\tsg_port_tbl;\n\n\tstruct hlist_head\t\tmcast_gc_list;\n\tstruct hlist_head\t\tmdb_list;\n\n\tstruct work_struct\t\tmcast_gc_work;\n#endif\n\n\tstruct timer_list\t\thello_timer;\n\tstruct timer_list\t\ttcn_timer;\n\tstruct timer_list\t\ttopology_change_timer;\n\tstruct delayed_work\t\tgc_work;\n\tstruct kobject\t\t\t*ifobj;\n\tu32\t\t\t\tauto_cnt;\n\n#ifdef CONFIG_NET_SWITCHDEV\n\t \n\tint\t\t\t\tlast_hwdom;\n\t \n\tunsigned long\t\t\tbusy_hwdoms;\n#endif\n\tstruct hlist_head\t\tfdb_list;\n\n#if IS_ENABLED(CONFIG_BRIDGE_MRP)\n\tstruct hlist_head\t\tmrp_list;\n#endif\n#if IS_ENABLED(CONFIG_BRIDGE_CFM)\n\tstruct hlist_head\t\tmep_list;\n#endif\n};\n\nstruct br_input_skb_cb {\n\tstruct net_device *brdev;\n\n\tu16 frag_max_size;\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tu8 igmp;\n\tu8 mrouters_only:1;\n#endif\n\tu8 proxyarp_replied:1;\n\tu8 src_port_isolated:1;\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\n\tu8 vlan_filtered:1;\n#endif\n#ifdef CONFIG_NETFILTER_FAMILY_BRIDGE\n\tu8 br_netfilter_broute:1;\n#endif\n\n#ifdef CONFIG_NET_SWITCHDEV\n\t \n\tu8 tx_fwd_offload:1;\n\t \n\tint src_hwdom;\n\t \n\tunsigned long fwd_hwdoms;\n#endif\n\n\tu32 backup_nhid;\n};\n\n#define BR_INPUT_SKB_CB(__skb)\t((struct br_input_skb_cb *)(__skb)->cb)\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n# define BR_INPUT_SKB_CB_MROUTERS_ONLY(__skb)\t(BR_INPUT_SKB_CB(__skb)->mrouters_only)\n#else\n# define BR_INPUT_SKB_CB_MROUTERS_ONLY(__skb)\t(0)\n#endif\n\n#define br_printk(level, br, format, args...)\t\\\n\tprintk(level \"%s: \" format, (br)->dev->name, ##args)\n\n#define br_err(__br, format, args...)\t\t\t\\\n\tbr_printk(KERN_ERR, __br, format, ##args)\n#define br_warn(__br, format, args...)\t\t\t\\\n\tbr_printk(KERN_WARNING, __br, format, ##args)\n#define br_notice(__br, format, args...)\t\t\\\n\tbr_printk(KERN_NOTICE, __br, format, ##args)\n#define br_info(__br, format, args...)\t\t\t\\\n\tbr_printk(KERN_INFO, __br, format, ##args)\n\n#define br_debug(br, format, args...)\t\t\t\\\n\tpr_debug(\"%s: \" format,  (br)->dev->name, ##args)\n\n \nstatic inline int br_is_root_bridge(const struct net_bridge *br)\n{\n\treturn !memcmp(&br->bridge_id, &br->designated_root, 8);\n}\n\n \nstatic inline bool br_vlan_is_master(const struct net_bridge_vlan *v)\n{\n\treturn v->flags & BRIDGE_VLAN_INFO_MASTER;\n}\n\n \nstatic inline bool br_vlan_is_brentry(const struct net_bridge_vlan *v)\n{\n\treturn v->flags & BRIDGE_VLAN_INFO_BRENTRY;\n}\n\n \nstatic inline bool br_vlan_should_use(const struct net_bridge_vlan *v)\n{\n\tif (br_vlan_is_master(v)) {\n\t\tif (br_vlan_is_brentry(v))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline bool nbp_state_should_learn(const struct net_bridge_port *p)\n{\n\treturn p->state == BR_STATE_LEARNING || p->state == BR_STATE_FORWARDING;\n}\n\nstatic inline bool br_vlan_valid_id(u16 vid, struct netlink_ext_ack *extack)\n{\n\tbool ret = vid > 0 && vid < VLAN_VID_MASK;\n\n\tif (!ret)\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Vlan id is invalid\");\n\n\treturn ret;\n}\n\nstatic inline bool br_vlan_valid_range(const struct bridge_vlan_info *cur,\n\t\t\t\t       const struct bridge_vlan_info *last,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\t \n\tif (cur->flags & BRIDGE_VLAN_INFO_PVID) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Pvid isn't allowed in a range\");\n\t\treturn false;\n\t}\n\n\t \n\tif (last) {\n\t\tif (cur->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Found a new vlan range start while processing one\");\n\t\t\treturn false;\n\t\t} else if (!(cur->flags & BRIDGE_VLAN_INFO_RANGE_END)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Vlan range end flag is missing\");\n\t\t\treturn false;\n\t\t} else if (cur->vid <= last->vid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"End vlan id is less than or equal to start vlan id\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tif (!(cur->flags & (BRIDGE_VLAN_INFO_RANGE_BEGIN |\n\t\t\t    BRIDGE_VLAN_INFO_RANGE_END))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Both vlan range flags are missing\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline u8 br_vlan_multicast_router(const struct net_bridge_vlan *v)\n{\n\tu8 mcast_router = MDB_RTR_TYPE_DISABLED;\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tif (!br_vlan_is_master(v))\n\t\tmcast_router = v->port_mcast_ctx.multicast_router;\n\telse\n\t\tmcast_router = v->br_mcast_ctx.multicast_router;\n#endif\n\n\treturn mcast_router;\n}\n\nstatic inline int br_afspec_cmd_to_rtm(int cmd)\n{\n\tswitch (cmd) {\n\tcase RTM_SETLINK:\n\t\treturn RTM_NEWVLAN;\n\tcase RTM_DELLINK:\n\t\treturn RTM_DELVLAN;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int br_opt_get(const struct net_bridge *br,\n\t\t\t     enum net_bridge_opts opt)\n{\n\treturn test_bit(opt, &br->options);\n}\n\nint br_boolopt_toggle(struct net_bridge *br, enum br_boolopt_id opt, bool on,\n\t\t      struct netlink_ext_ack *extack);\nint br_boolopt_get(const struct net_bridge *br, enum br_boolopt_id opt);\nint br_boolopt_multi_toggle(struct net_bridge *br,\n\t\t\t    struct br_boolopt_multi *bm,\n\t\t\t    struct netlink_ext_ack *extack);\nvoid br_boolopt_multi_get(const struct net_bridge *br,\n\t\t\t  struct br_boolopt_multi *bm);\nvoid br_opt_toggle(struct net_bridge *br, enum net_bridge_opts opt, bool on);\n\n#if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)\nstatic inline void br_tc_skb_miss_set(struct sk_buff *skb, bool miss)\n{\n\tstruct tc_skb_ext *ext;\n\n\tif (!tc_skb_ext_tc_enabled())\n\t\treturn;\n\n\text = skb_ext_find(skb, TC_SKB_EXT);\n\tif (ext) {\n\t\text->l2_miss = miss;\n\t\treturn;\n\t}\n\tif (!miss)\n\t\treturn;\n\text = tc_skb_ext_alloc(skb);\n\tif (!ext)\n\t\treturn;\n\text->l2_miss = true;\n}\n#else\nstatic inline void br_tc_skb_miss_set(struct sk_buff *skb, bool miss)\n{\n}\n#endif\n\n \nvoid br_dev_setup(struct net_device *dev);\nvoid br_dev_delete(struct net_device *dev, struct list_head *list);\nnetdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev);\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic inline void br_netpoll_send_skb(const struct net_bridge_port *p,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tnetpoll_send_skb(p->np, skb);\n}\n\nint br_netpoll_enable(struct net_bridge_port *p);\nvoid br_netpoll_disable(struct net_bridge_port *p);\n#else\nstatic inline void br_netpoll_send_skb(const struct net_bridge_port *p,\n\t\t\t\t       struct sk_buff *skb)\n{\n}\n\nstatic inline int br_netpoll_enable(struct net_bridge_port *p)\n{\n\treturn 0;\n}\n\nstatic inline void br_netpoll_disable(struct net_bridge_port *p)\n{\n}\n#endif\n\n \n#define FDB_FLUSH_IGNORED_NDM_FLAGS (NTF_MASTER | NTF_SELF)\n#define FDB_FLUSH_ALLOWED_NDM_STATES (NUD_PERMANENT | NUD_NOARP)\n#define FDB_FLUSH_ALLOWED_NDM_FLAGS (NTF_USE | NTF_EXT_LEARNED | \\\n\t\t\t\t     NTF_STICKY | NTF_OFFLOADED)\n\nint br_fdb_init(void);\nvoid br_fdb_fini(void);\nint br_fdb_hash_init(struct net_bridge *br);\nvoid br_fdb_hash_fini(struct net_bridge *br);\nvoid br_fdb_flush(struct net_bridge *br,\n\t\t  const struct net_bridge_fdb_flush_desc *desc);\nvoid br_fdb_find_delete_local(struct net_bridge *br,\n\t\t\t      const struct net_bridge_port *p,\n\t\t\t      const unsigned char *addr, u16 vid);\nvoid br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr);\nvoid br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);\nvoid br_fdb_cleanup(struct work_struct *work);\nvoid br_fdb_delete_by_port(struct net_bridge *br,\n\t\t\t   const struct net_bridge_port *p, u16 vid, int do_all);\nstruct net_bridge_fdb_entry *br_fdb_find_rcu(struct net_bridge *br,\n\t\t\t\t\t     const unsigned char *addr,\n\t\t\t\t\t     __u16 vid);\nint br_fdb_test_addr(struct net_device *dev, unsigned char *addr);\nint br_fdb_fillbuf(struct net_bridge *br, void *buf, unsigned long count,\n\t\t   unsigned long off);\nint br_fdb_add_local(struct net_bridge *br, struct net_bridge_port *source,\n\t\t     const unsigned char *addr, u16 vid);\nvoid br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,\n\t\t   const unsigned char *addr, u16 vid, unsigned long flags);\n\nint br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t  struct net_device *dev, const unsigned char *addr, u16 vid,\n\t\t  struct netlink_ext_ack *extack);\nint br_fdb_delete_bulk(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t       struct net_device *dev, u16 vid,\n\t\t       struct netlink_ext_ack *extack);\nint br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,\n\t       const unsigned char *addr, u16 vid, u16 nlh_flags,\n\t       struct netlink_ext_ack *extack);\nint br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\tstruct net_device *dev, struct net_device *fdev, int *idx);\nint br_fdb_get(struct sk_buff *skb, struct nlattr *tb[], struct net_device *dev,\n\t       const unsigned char *addr, u16 vid, u32 portid, u32 seq,\n\t       struct netlink_ext_ack *extack);\nint br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p);\nvoid br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p);\nint br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,\n\t\t\t      const unsigned char *addr, u16 vid,\n\t\t\t      bool locked, bool swdev_notify);\nint br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,\n\t\t\t      const unsigned char *addr, u16 vid,\n\t\t\t      bool swdev_notify);\nvoid br_fdb_offloaded_set(struct net_bridge *br, struct net_bridge_port *p,\n\t\t\t  const unsigned char *addr, u16 vid, bool offloaded);\n\n \nenum br_pkt_type {\n\tBR_PKT_UNICAST,\n\tBR_PKT_MULTICAST,\n\tBR_PKT_BROADCAST\n};\nint br_dev_queue_push_xmit(struct net *net, struct sock *sk, struct sk_buff *skb);\nvoid br_forward(const struct net_bridge_port *to, struct sk_buff *skb,\n\t\tbool local_rcv, bool local_orig);\nint br_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb);\nvoid br_flood(struct net_bridge *br, struct sk_buff *skb,\n\t      enum br_pkt_type pkt_type, bool local_rcv, bool local_orig,\n\t      u16 vid);\n\n \nstatic inline bool br_skb_isolated(const struct net_bridge_port *to,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn BR_INPUT_SKB_CB(skb)->src_port_isolated &&\n\t       (to->flags & BR_ISOLATED);\n}\n\n \nvoid br_port_carrier_check(struct net_bridge_port *p, bool *notified);\nint br_add_bridge(struct net *net, const char *name);\nint br_del_bridge(struct net *net, const char *name);\nint br_add_if(struct net_bridge *br, struct net_device *dev,\n\t      struct netlink_ext_ack *extack);\nint br_del_if(struct net_bridge *br, struct net_device *dev);\nvoid br_mtu_auto_adjust(struct net_bridge *br);\nnetdev_features_t br_features_recompute(struct net_bridge *br,\n\t\t\t\t\tnetdev_features_t features);\nvoid br_port_flags_change(struct net_bridge_port *port, unsigned long mask);\nvoid br_manage_promisc(struct net_bridge *br);\nint nbp_backup_change(struct net_bridge_port *p, struct net_device *backup_dev);\n\n \nint br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb);\nrx_handler_func_t *br_get_rx_handler(const struct net_device *dev);\n\nstruct br_frame_type {\n\t__be16\t\t\ttype;\n\tint\t\t\t(*frame_handler)(struct net_bridge_port *port,\n\t\t\t\t\t\t struct sk_buff *skb);\n\tstruct hlist_node\tlist;\n};\n\nvoid br_add_frame(struct net_bridge *br, struct br_frame_type *ft);\nvoid br_del_frame(struct net_bridge *br, struct br_frame_type *ft);\n\nstatic inline bool br_rx_handler_check_rcu(const struct net_device *dev)\n{\n\treturn rcu_dereference(dev->rx_handler) == br_get_rx_handler(dev);\n}\n\nstatic inline bool br_rx_handler_check_rtnl(const struct net_device *dev)\n{\n\treturn rcu_dereference_rtnl(dev->rx_handler) == br_get_rx_handler(dev);\n}\n\nstatic inline struct net_bridge_port *br_port_get_check_rcu(const struct net_device *dev)\n{\n\treturn br_rx_handler_check_rcu(dev) ? br_port_get_rcu(dev) : NULL;\n}\n\nstatic inline struct net_bridge_port *\nbr_port_get_check_rtnl(const struct net_device *dev)\n{\n\treturn br_rx_handler_check_rtnl(dev) ? br_port_get_rtnl_rcu(dev) : NULL;\n}\n\n \nint br_dev_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\t  void __user *data, int cmd);\nint br_ioctl_stub(struct net *net, struct net_bridge *br, unsigned int cmd,\n\t\t  struct ifreq *ifr, void __user *uarg);\n\n \n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\nint br_multicast_rcv(struct net_bridge_mcast **brmctx,\n\t\t     struct net_bridge_mcast_port **pmctx,\n\t\t     struct net_bridge_vlan *vlan,\n\t\t     struct sk_buff *skb, u16 vid);\nstruct net_bridge_mdb_entry *br_mdb_get(struct net_bridge_mcast *brmctx,\n\t\t\t\t\tstruct sk_buff *skb, u16 vid);\nint br_multicast_add_port(struct net_bridge_port *port);\nvoid br_multicast_del_port(struct net_bridge_port *port);\nvoid br_multicast_enable_port(struct net_bridge_port *port);\nvoid br_multicast_disable_port(struct net_bridge_port *port);\nvoid br_multicast_init(struct net_bridge *br);\nvoid br_multicast_join_snoopers(struct net_bridge *br);\nvoid br_multicast_leave_snoopers(struct net_bridge *br);\nvoid br_multicast_open(struct net_bridge *br);\nvoid br_multicast_stop(struct net_bridge *br);\nvoid br_multicast_dev_del(struct net_bridge *br);\nvoid br_multicast_flood(struct net_bridge_mdb_entry *mdst, struct sk_buff *skb,\n\t\t\tstruct net_bridge_mcast *brmctx,\n\t\t\tbool local_rcv, bool local_orig);\nint br_multicast_set_router(struct net_bridge_mcast *brmctx, unsigned long val);\nint br_multicast_set_port_router(struct net_bridge_mcast_port *pmctx,\n\t\t\t\t unsigned long val);\nint br_multicast_set_vlan_router(struct net_bridge_vlan *v, u8 mcast_router);\nint br_multicast_toggle(struct net_bridge *br, unsigned long val,\n\t\t\tstruct netlink_ext_ack *extack);\nint br_multicast_set_querier(struct net_bridge_mcast *brmctx, unsigned long val);\nint br_multicast_set_igmp_version(struct net_bridge_mcast *brmctx,\n\t\t\t\t  unsigned long val);\n#if IS_ENABLED(CONFIG_IPV6)\nint br_multicast_set_mld_version(struct net_bridge_mcast *brmctx,\n\t\t\t\t unsigned long val);\n#endif\nstruct net_bridge_mdb_entry *\nbr_mdb_ip_get(struct net_bridge *br, struct br_ip *dst);\nstruct net_bridge_mdb_entry *\nbr_multicast_new_group(struct net_bridge *br, struct br_ip *group);\nstruct net_bridge_port_group *\nbr_multicast_new_port_group(struct net_bridge_port *port,\n\t\t\t    const struct br_ip *group,\n\t\t\t    struct net_bridge_port_group __rcu *next,\n\t\t\t    unsigned char flags, const unsigned char *src,\n\t\t\t    u8 filter_mode, u8 rt_protocol,\n\t\t\t    struct netlink_ext_ack *extack);\nvoid br_multicast_del_port_group(struct net_bridge_port_group *p);\nint br_mdb_hash_init(struct net_bridge *br);\nvoid br_mdb_hash_fini(struct net_bridge *br);\nvoid br_mdb_notify(struct net_device *dev, struct net_bridge_mdb_entry *mp,\n\t\t   struct net_bridge_port_group *pg, int type);\nvoid br_rtr_notify(struct net_device *dev, struct net_bridge_mcast_port *pmctx,\n\t\t   int type);\nvoid br_multicast_del_pg(struct net_bridge_mdb_entry *mp,\n\t\t\t struct net_bridge_port_group *pg,\n\t\t\t struct net_bridge_port_group __rcu **pp);\nvoid br_multicast_count(struct net_bridge *br,\n\t\t\tconst struct net_bridge_port *p,\n\t\t\tconst struct sk_buff *skb, u8 type, u8 dir);\nint br_multicast_init_stats(struct net_bridge *br);\nvoid br_multicast_uninit_stats(struct net_bridge *br);\nvoid br_multicast_get_stats(const struct net_bridge *br,\n\t\t\t    const struct net_bridge_port *p,\n\t\t\t    struct br_mcast_stats *dest);\nu32 br_multicast_ngroups_get(const struct net_bridge_mcast_port *pmctx);\nvoid br_multicast_ngroups_set_max(struct net_bridge_mcast_port *pmctx, u32 max);\nu32 br_multicast_ngroups_get_max(const struct net_bridge_mcast_port *pmctx);\nint br_mdb_add(struct net_device *dev, struct nlattr *tb[], u16 nlmsg_flags,\n\t       struct netlink_ext_ack *extack);\nint br_mdb_del(struct net_device *dev, struct nlattr *tb[],\n\t       struct netlink_ext_ack *extack);\nint br_mdb_dump(struct net_device *dev, struct sk_buff *skb,\n\t\tstruct netlink_callback *cb);\nvoid br_multicast_host_join(const struct net_bridge_mcast *brmctx,\n\t\t\t    struct net_bridge_mdb_entry *mp, bool notify);\nvoid br_multicast_host_leave(struct net_bridge_mdb_entry *mp, bool notify);\nvoid br_multicast_star_g_handle_mode(struct net_bridge_port_group *pg,\n\t\t\t\t     u8 filter_mode);\nvoid br_multicast_sg_add_exclude_ports(struct net_bridge_mdb_entry *star_mp,\n\t\t\t\t       struct net_bridge_port_group *sg);\nstruct net_bridge_group_src *\nbr_multicast_find_group_src(struct net_bridge_port_group *pg, struct br_ip *ip);\nstruct net_bridge_group_src *\nbr_multicast_new_group_src(struct net_bridge_port_group *pg,\n\t\t\t   struct br_ip *src_ip);\nvoid __br_multicast_del_group_src(struct net_bridge_group_src *src);\nvoid br_multicast_del_group_src(struct net_bridge_group_src *src,\n\t\t\t\tbool fastleave);\nvoid br_multicast_ctx_init(struct net_bridge *br,\n\t\t\t   struct net_bridge_vlan *vlan,\n\t\t\t   struct net_bridge_mcast *brmctx);\nvoid br_multicast_ctx_deinit(struct net_bridge_mcast *brmctx);\nvoid br_multicast_port_ctx_init(struct net_bridge_port *port,\n\t\t\t\tstruct net_bridge_vlan *vlan,\n\t\t\t\tstruct net_bridge_mcast_port *pmctx);\nvoid br_multicast_port_ctx_deinit(struct net_bridge_mcast_port *pmctx);\nvoid br_multicast_toggle_one_vlan(struct net_bridge_vlan *vlan, bool on);\nint br_multicast_toggle_vlan_snooping(struct net_bridge *br, bool on,\n\t\t\t\t      struct netlink_ext_ack *extack);\nbool br_multicast_toggle_global_vlan(struct net_bridge_vlan *vlan, bool on);\n\nint br_rports_fill_info(struct sk_buff *skb,\n\t\t\tconst struct net_bridge_mcast *brmctx);\nint br_multicast_dump_querier_state(struct sk_buff *skb,\n\t\t\t\t    const struct net_bridge_mcast *brmctx,\n\t\t\t\t    int nest_attr);\nsize_t br_multicast_querier_state_size(void);\nsize_t br_rports_size(const struct net_bridge_mcast *brmctx);\nvoid br_multicast_set_query_intvl(struct net_bridge_mcast *brmctx,\n\t\t\t\t  unsigned long val);\nvoid br_multicast_set_startup_query_intvl(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t  unsigned long val);\n\nstatic inline bool br_group_is_l2(const struct br_ip *group)\n{\n\treturn group->proto == 0;\n}\n\n#define mlock_dereference(X, br) \\\n\trcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))\n\nstatic inline struct hlist_node *\nbr_multicast_get_first_rport_node(struct net_bridge_mcast *brmctx,\n\t\t\t\t  struct sk_buff *skb)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (skb->protocol == htons(ETH_P_IPV6))\n\t\treturn rcu_dereference(hlist_first_rcu(&brmctx->ip6_mc_router_list));\n#endif\n\treturn rcu_dereference(hlist_first_rcu(&brmctx->ip4_mc_router_list));\n}\n\nstatic inline struct net_bridge_port *\nbr_multicast_rport_from_node_skb(struct hlist_node *rp, struct sk_buff *skb)\n{\n\tstruct net_bridge_mcast_port *mctx;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (skb->protocol == htons(ETH_P_IPV6))\n\t\tmctx = hlist_entry_safe(rp, struct net_bridge_mcast_port,\n\t\t\t\t\tip6_rlist);\n\telse\n#endif\n\t\tmctx = hlist_entry_safe(rp, struct net_bridge_mcast_port,\n\t\t\t\t\tip4_rlist);\n\n\tif (mctx)\n\t\treturn mctx->port;\n\telse\n\t\treturn NULL;\n}\n\nstatic inline bool br_ip4_multicast_is_router(struct net_bridge_mcast *brmctx)\n{\n\treturn timer_pending(&brmctx->ip4_mc_router_timer);\n}\n\nstatic inline bool br_ip6_multicast_is_router(struct net_bridge_mcast *brmctx)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\treturn timer_pending(&brmctx->ip6_mc_router_timer);\n#else\n\treturn false;\n#endif\n}\n\nstatic inline bool\nbr_multicast_is_router(struct net_bridge_mcast *brmctx, struct sk_buff *skb)\n{\n\tswitch (brmctx->multicast_router) {\n\tcase MDB_RTR_TYPE_PERM:\n\t\treturn true;\n\tcase MDB_RTR_TYPE_TEMP_QUERY:\n\t\tif (skb) {\n\t\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\t\treturn br_ip4_multicast_is_router(brmctx);\n\t\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\t\treturn br_ip6_multicast_is_router(brmctx);\n\t\t} else {\n\t\t\treturn br_ip4_multicast_is_router(brmctx) ||\n\t\t\t       br_ip6_multicast_is_router(brmctx);\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline bool\n__br_multicast_querier_exists(struct net_bridge_mcast *brmctx,\n\t\t\t      struct bridge_mcast_other_query *querier,\n\t\t\t      const bool is_ipv6)\n{\n\tbool own_querier_enabled;\n\n\tif (brmctx->multicast_querier) {\n\t\tif (is_ipv6 && !br_opt_get(brmctx->br, BROPT_HAS_IPV6_ADDR))\n\t\t\town_querier_enabled = false;\n\t\telse\n\t\t\town_querier_enabled = true;\n\t} else {\n\t\town_querier_enabled = false;\n\t}\n\n\treturn time_is_before_jiffies(querier->delay_time) &&\n\t       (own_querier_enabled || timer_pending(&querier->timer));\n}\n\nstatic inline bool br_multicast_querier_exists(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t       struct ethhdr *eth,\n\t\t\t\t\t       const struct net_bridge_mdb_entry *mdb)\n{\n\tswitch (eth->h_proto) {\n\tcase (htons(ETH_P_IP)):\n\t\treturn __br_multicast_querier_exists(brmctx,\n\t\t\t&brmctx->ip4_other_query, false);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase (htons(ETH_P_IPV6)):\n\t\treturn __br_multicast_querier_exists(brmctx,\n\t\t\t&brmctx->ip6_other_query, true);\n#endif\n\tdefault:\n\t\treturn !!mdb && br_group_is_l2(&mdb->addr);\n\t}\n}\n\nstatic inline bool br_multicast_is_star_g(const struct br_ip *ip)\n{\n\tswitch (ip->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn ipv4_is_zeronet(ip->src.ip4);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn ipv6_addr_any(&ip->src.ip6);\n#endif\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline bool\nbr_multicast_should_handle_mode(const struct net_bridge_mcast *brmctx,\n\t\t\t\t__be16 proto)\n{\n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn !!(brmctx->multicast_igmp_version == 3);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn !!(brmctx->multicast_mld_version == 2);\n#endif\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline int br_multicast_igmp_type(const struct sk_buff *skb)\n{\n\treturn BR_INPUT_SKB_CB(skb)->igmp;\n}\n\nstatic inline unsigned long br_multicast_lmqt(const struct net_bridge_mcast *brmctx)\n{\n\treturn brmctx->multicast_last_member_interval *\n\t       brmctx->multicast_last_member_count;\n}\n\nstatic inline unsigned long br_multicast_gmi(const struct net_bridge_mcast *brmctx)\n{\n\treturn brmctx->multicast_membership_interval;\n}\n\nstatic inline bool\nbr_multicast_ctx_is_vlan(const struct net_bridge_mcast *brmctx)\n{\n\treturn !!brmctx->vlan;\n}\n\nstatic inline bool\nbr_multicast_port_ctx_is_vlan(const struct net_bridge_mcast_port *pmctx)\n{\n\treturn !!pmctx->vlan;\n}\n\nstatic inline struct net_bridge_mcast *\nbr_multicast_port_ctx_get_global(const struct net_bridge_mcast_port *pmctx)\n{\n\tif (!br_multicast_port_ctx_is_vlan(pmctx))\n\t\treturn &pmctx->port->br->multicast_ctx;\n\telse\n\t\treturn &pmctx->vlan->brvlan->br_mcast_ctx;\n}\n\nstatic inline bool\nbr_multicast_ctx_vlan_global_disabled(const struct net_bridge_mcast *brmctx)\n{\n\treturn br_multicast_ctx_is_vlan(brmctx) &&\n\t       (!br_opt_get(brmctx->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) ||\n\t\t!(brmctx->vlan->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED));\n}\n\nstatic inline bool\nbr_multicast_ctx_vlan_disabled(const struct net_bridge_mcast *brmctx)\n{\n\treturn br_multicast_ctx_is_vlan(brmctx) &&\n\t       !(brmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);\n}\n\nstatic inline bool\nbr_multicast_port_ctx_vlan_disabled(const struct net_bridge_mcast_port *pmctx)\n{\n\treturn br_multicast_port_ctx_is_vlan(pmctx) &&\n\t       !(pmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);\n}\n\nstatic inline bool\nbr_multicast_port_ctx_state_disabled(const struct net_bridge_mcast_port *pmctx)\n{\n\treturn pmctx->port->state == BR_STATE_DISABLED ||\n\t       (br_multicast_port_ctx_is_vlan(pmctx) &&\n\t\t(br_multicast_port_ctx_vlan_disabled(pmctx) ||\n\t\t pmctx->vlan->state == BR_STATE_DISABLED));\n}\n\nstatic inline bool\nbr_multicast_port_ctx_state_stopped(const struct net_bridge_mcast_port *pmctx)\n{\n\treturn br_multicast_port_ctx_state_disabled(pmctx) ||\n\t       pmctx->port->state == BR_STATE_BLOCKING ||\n\t       (br_multicast_port_ctx_is_vlan(pmctx) &&\n\t\tpmctx->vlan->state == BR_STATE_BLOCKING);\n}\n\nstatic inline bool\nbr_rports_have_mc_router(const struct net_bridge_mcast *brmctx)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\treturn !hlist_empty(&brmctx->ip4_mc_router_list) ||\n\t       !hlist_empty(&brmctx->ip6_mc_router_list);\n#else\n\treturn !hlist_empty(&brmctx->ip4_mc_router_list);\n#endif\n}\n\nstatic inline bool\nbr_multicast_ctx_options_equal(const struct net_bridge_mcast *brmctx1,\n\t\t\t       const struct net_bridge_mcast *brmctx2)\n{\n\treturn brmctx1->multicast_igmp_version ==\n\t       brmctx2->multicast_igmp_version &&\n\t       brmctx1->multicast_last_member_count ==\n\t       brmctx2->multicast_last_member_count &&\n\t       brmctx1->multicast_startup_query_count ==\n\t       brmctx2->multicast_startup_query_count &&\n\t       brmctx1->multicast_last_member_interval ==\n\t       brmctx2->multicast_last_member_interval &&\n\t       brmctx1->multicast_membership_interval ==\n\t       brmctx2->multicast_membership_interval &&\n\t       brmctx1->multicast_querier_interval ==\n\t       brmctx2->multicast_querier_interval &&\n\t       brmctx1->multicast_query_interval ==\n\t       brmctx2->multicast_query_interval &&\n\t       brmctx1->multicast_query_response_interval ==\n\t       brmctx2->multicast_query_response_interval &&\n\t       brmctx1->multicast_startup_query_interval ==\n\t       brmctx2->multicast_startup_query_interval &&\n\t       brmctx1->multicast_querier == brmctx2->multicast_querier &&\n\t       brmctx1->multicast_router == brmctx2->multicast_router &&\n\t       !br_rports_have_mc_router(brmctx1) &&\n\t       !br_rports_have_mc_router(brmctx2) &&\n#if IS_ENABLED(CONFIG_IPV6)\n\t       brmctx1->multicast_mld_version ==\n\t       brmctx2->multicast_mld_version &&\n#endif\n\t       true;\n}\n\nstatic inline bool\nbr_multicast_ctx_matches_vlan_snooping(const struct net_bridge_mcast *brmctx)\n{\n\tbool vlan_snooping_enabled;\n\n\tvlan_snooping_enabled = !!br_opt_get(brmctx->br,\n\t\t\t\t\t     BROPT_MCAST_VLAN_SNOOPING_ENABLED);\n\n\treturn !!(vlan_snooping_enabled == br_multicast_ctx_is_vlan(brmctx));\n}\n#else\nstatic inline int br_multicast_rcv(struct net_bridge_mcast **brmctx,\n\t\t\t\t   struct net_bridge_mcast_port **pmctx,\n\t\t\t\t   struct net_bridge_vlan *vlan,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   u16 vid)\n{\n\treturn 0;\n}\n\nstatic inline struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t\t      struct sk_buff *skb, u16 vid)\n{\n\treturn NULL;\n}\n\nstatic inline int br_multicast_add_port(struct net_bridge_port *port)\n{\n\treturn 0;\n}\n\nstatic inline void br_multicast_del_port(struct net_bridge_port *port)\n{\n}\n\nstatic inline void br_multicast_enable_port(struct net_bridge_port *port)\n{\n}\n\nstatic inline void br_multicast_disable_port(struct net_bridge_port *port)\n{\n}\n\nstatic inline void br_multicast_init(struct net_bridge *br)\n{\n}\n\nstatic inline void br_multicast_join_snoopers(struct net_bridge *br)\n{\n}\n\nstatic inline void br_multicast_leave_snoopers(struct net_bridge *br)\n{\n}\n\nstatic inline void br_multicast_open(struct net_bridge *br)\n{\n}\n\nstatic inline void br_multicast_stop(struct net_bridge *br)\n{\n}\n\nstatic inline void br_multicast_dev_del(struct net_bridge *br)\n{\n}\n\nstatic inline void br_multicast_flood(struct net_bridge_mdb_entry *mdst,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct net_bridge_mcast *brmctx,\n\t\t\t\t      bool local_rcv, bool local_orig)\n{\n}\n\nstatic inline bool br_multicast_is_router(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\treturn false;\n}\n\nstatic inline bool br_multicast_querier_exists(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t       struct ethhdr *eth,\n\t\t\t\t\t       const struct net_bridge_mdb_entry *mdb)\n{\n\treturn false;\n}\n\nstatic inline int br_mdb_add(struct net_device *dev, struct nlattr *tb[],\n\t\t\t     u16 nlmsg_flags, struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int br_mdb_del(struct net_device *dev, struct nlattr *tb[],\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int br_mdb_dump(struct net_device *dev, struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\treturn 0;\n}\n\nstatic inline int br_mdb_hash_init(struct net_bridge *br)\n{\n\treturn 0;\n}\n\nstatic inline void br_mdb_hash_fini(struct net_bridge *br)\n{\n}\n\nstatic inline void br_multicast_count(struct net_bridge *br,\n\t\t\t\t      const struct net_bridge_port *p,\n\t\t\t\t      const struct sk_buff *skb,\n\t\t\t\t      u8 type, u8 dir)\n{\n}\n\nstatic inline int br_multicast_init_stats(struct net_bridge *br)\n{\n\treturn 0;\n}\n\nstatic inline void br_multicast_uninit_stats(struct net_bridge *br)\n{\n}\n\nstatic inline int br_multicast_igmp_type(const struct sk_buff *skb)\n{\n\treturn 0;\n}\n\nstatic inline void br_multicast_ctx_init(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_vlan *vlan,\n\t\t\t\t\t struct net_bridge_mcast *brmctx)\n{\n}\n\nstatic inline void br_multicast_ctx_deinit(struct net_bridge_mcast *brmctx)\n{\n}\n\nstatic inline void br_multicast_port_ctx_init(struct net_bridge_port *port,\n\t\t\t\t\t      struct net_bridge_vlan *vlan,\n\t\t\t\t\t      struct net_bridge_mcast_port *pmctx)\n{\n}\n\nstatic inline void br_multicast_port_ctx_deinit(struct net_bridge_mcast_port *pmctx)\n{\n}\n\nstatic inline void br_multicast_toggle_one_vlan(struct net_bridge_vlan *vlan,\n\t\t\t\t\t\tbool on)\n{\n}\n\nstatic inline int br_multicast_toggle_vlan_snooping(struct net_bridge *br,\n\t\t\t\t\t\t    bool on,\n\t\t\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline bool br_multicast_toggle_global_vlan(struct net_bridge_vlan *vlan,\n\t\t\t\t\t\t   bool on)\n{\n\treturn false;\n}\n\nstatic inline bool\nbr_multicast_ctx_options_equal(const struct net_bridge_mcast *brmctx1,\n\t\t\t       const struct net_bridge_mcast *brmctx2)\n{\n\treturn true;\n}\n#endif\n\n \n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\nbool br_allowed_ingress(const struct net_bridge *br,\n\t\t\tstruct net_bridge_vlan_group *vg, struct sk_buff *skb,\n\t\t\tu16 *vid, u8 *state,\n\t\t\tstruct net_bridge_vlan **vlan);\nbool br_allowed_egress(struct net_bridge_vlan_group *vg,\n\t\t       const struct sk_buff *skb);\nbool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid);\nstruct sk_buff *br_handle_vlan(struct net_bridge *br,\n\t\t\t       const struct net_bridge_port *port,\n\t\t\t       struct net_bridge_vlan_group *vg,\n\t\t\t       struct sk_buff *skb);\nint br_vlan_add(struct net_bridge *br, u16 vid, u16 flags,\n\t\tbool *changed, struct netlink_ext_ack *extack);\nint br_vlan_delete(struct net_bridge *br, u16 vid);\nvoid br_vlan_flush(struct net_bridge *br);\nstruct net_bridge_vlan *br_vlan_find(struct net_bridge_vlan_group *vg, u16 vid);\nvoid br_recalculate_fwd_mask(struct net_bridge *br);\nint br_vlan_filter_toggle(struct net_bridge *br, unsigned long val,\n\t\t\t  struct netlink_ext_ack *extack);\nint __br_vlan_set_proto(struct net_bridge *br, __be16 proto,\n\t\t\tstruct netlink_ext_ack *extack);\nint br_vlan_set_proto(struct net_bridge *br, unsigned long val,\n\t\t      struct netlink_ext_ack *extack);\nint br_vlan_set_stats(struct net_bridge *br, unsigned long val);\nint br_vlan_set_stats_per_port(struct net_bridge *br, unsigned long val);\nint br_vlan_init(struct net_bridge *br);\nint br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val,\n\t\t\t     struct netlink_ext_ack *extack);\nint __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid,\n\t\t\t       struct netlink_ext_ack *extack);\nint nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags,\n\t\t bool *changed, struct netlink_ext_ack *extack);\nint nbp_vlan_delete(struct net_bridge_port *port, u16 vid);\nvoid nbp_vlan_flush(struct net_bridge_port *port);\nint nbp_vlan_init(struct net_bridge_port *port, struct netlink_ext_ack *extack);\nint nbp_get_num_vlan_infos(struct net_bridge_port *p, u32 filter_mask);\nvoid br_vlan_get_stats(const struct net_bridge_vlan *v,\n\t\t       struct pcpu_sw_netstats *stats);\nvoid br_vlan_port_event(struct net_bridge_port *p, unsigned long event);\nint br_vlan_bridge_event(struct net_device *dev, unsigned long event,\n\t\t\t void *ptr);\nvoid br_vlan_rtnl_init(void);\nvoid br_vlan_rtnl_uninit(void);\nvoid br_vlan_notify(const struct net_bridge *br,\n\t\t    const struct net_bridge_port *p,\n\t\t    u16 vid, u16 vid_range,\n\t\t    int cmd);\nbool br_vlan_can_enter_range(const struct net_bridge_vlan *v_curr,\n\t\t\t     const struct net_bridge_vlan *range_end);\n\nvoid br_vlan_fill_forward_path_pvid(struct net_bridge *br,\n\t\t\t\t    struct net_device_path_ctx *ctx,\n\t\t\t\t    struct net_device_path *path);\nint br_vlan_fill_forward_path_mode(struct net_bridge *br,\n\t\t\t\t   struct net_bridge_port *dst,\n\t\t\t\t   struct net_device_path *path);\n\nstatic inline struct net_bridge_vlan_group *br_vlan_group(\n\t\t\t\t\tconst struct net_bridge *br)\n{\n\treturn rtnl_dereference(br->vlgrp);\n}\n\nstatic inline struct net_bridge_vlan_group *nbp_vlan_group(\n\t\t\t\t\tconst struct net_bridge_port *p)\n{\n\treturn rtnl_dereference(p->vlgrp);\n}\n\nstatic inline struct net_bridge_vlan_group *br_vlan_group_rcu(\n\t\t\t\t\tconst struct net_bridge *br)\n{\n\treturn rcu_dereference(br->vlgrp);\n}\n\nstatic inline struct net_bridge_vlan_group *nbp_vlan_group_rcu(\n\t\t\t\t\tconst struct net_bridge_port *p)\n{\n\treturn rcu_dereference(p->vlgrp);\n}\n\n \nstatic inline int br_vlan_get_tag(const struct sk_buff *skb, u16 *vid)\n{\n\tint err = 0;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\t*vid = skb_vlan_tag_get_id(skb);\n\t} else {\n\t\t*vid = 0;\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic inline u16 br_get_pvid(const struct net_bridge_vlan_group *vg)\n{\n\tif (!vg)\n\t\treturn 0;\n\n\tsmp_rmb();\n\treturn vg->pvid;\n}\n\nstatic inline u16 br_vlan_flags(const struct net_bridge_vlan *v, u16 pvid)\n{\n\treturn v->vid == pvid ? v->flags | BRIDGE_VLAN_INFO_PVID : v->flags;\n}\n#else\nstatic inline bool br_allowed_ingress(const struct net_bridge *br,\n\t\t\t\t      struct net_bridge_vlan_group *vg,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      u16 *vid, u8 *state,\n\t\t\t\t      struct net_bridge_vlan **vlan)\n\n{\n\t*vlan = NULL;\n\treturn true;\n}\n\nstatic inline bool br_allowed_egress(struct net_bridge_vlan_group *vg,\n\t\t\t\t     const struct sk_buff *skb)\n{\n\treturn true;\n}\n\nstatic inline bool br_should_learn(struct net_bridge_port *p,\n\t\t\t\t   struct sk_buff *skb, u16 *vid)\n{\n\treturn true;\n}\n\nstatic inline struct sk_buff *br_handle_vlan(struct net_bridge *br,\n\t\t\t\t\t     const struct net_bridge_port *port,\n\t\t\t\t\t     struct net_bridge_vlan_group *vg,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\treturn skb;\n}\n\nstatic inline int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags,\n\t\t\t      bool *changed, struct netlink_ext_ack *extack)\n{\n\t*changed = false;\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int br_vlan_delete(struct net_bridge *br, u16 vid)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void br_vlan_flush(struct net_bridge *br)\n{\n}\n\nstatic inline void br_recalculate_fwd_mask(struct net_bridge *br)\n{\n}\n\nstatic inline int br_vlan_init(struct net_bridge *br)\n{\n\treturn 0;\n}\n\nstatic inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags,\n\t\t\t       bool *changed, struct netlink_ext_ack *extack)\n{\n\t*changed = false;\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int nbp_vlan_delete(struct net_bridge_port *port, u16 vid)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void nbp_vlan_flush(struct net_bridge_port *port)\n{\n}\n\nstatic inline struct net_bridge_vlan *br_vlan_find(struct net_bridge_vlan_group *vg,\n\t\t\t\t\t\t   u16 vid)\n{\n\treturn NULL;\n}\n\nstatic inline int nbp_vlan_init(struct net_bridge_port *port,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\n\nstatic inline u16 br_vlan_get_tag(const struct sk_buff *skb, u16 *tag)\n{\n\treturn 0;\n}\n\nstatic inline u16 br_get_pvid(const struct net_bridge_vlan_group *vg)\n{\n\treturn 0;\n}\n\nstatic inline int br_vlan_filter_toggle(struct net_bridge *br,\n\t\t\t\t\tunsigned long val,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int nbp_get_num_vlan_infos(struct net_bridge_port *p,\n\t\t\t\t\t u32 filter_mask)\n{\n\treturn 0;\n}\n\nstatic inline void br_vlan_fill_forward_path_pvid(struct net_bridge *br,\n\t\t\t\t\t\t  struct net_device_path_ctx *ctx,\n\t\t\t\t\t\t  struct net_device_path *path)\n{\n}\n\nstatic inline int br_vlan_fill_forward_path_mode(struct net_bridge *br,\n\t\t\t\t\t\t struct net_bridge_port *dst,\n\t\t\t\t\t\t struct net_device_path *path)\n{\n\treturn 0;\n}\n\nstatic inline struct net_bridge_vlan_group *br_vlan_group(\n\t\t\t\t\tconst struct net_bridge *br)\n{\n\treturn NULL;\n}\n\nstatic inline struct net_bridge_vlan_group *nbp_vlan_group(\n\t\t\t\t\tconst struct net_bridge_port *p)\n{\n\treturn NULL;\n}\n\nstatic inline struct net_bridge_vlan_group *br_vlan_group_rcu(\n\t\t\t\t\tconst struct net_bridge *br)\n{\n\treturn NULL;\n}\n\nstatic inline struct net_bridge_vlan_group *nbp_vlan_group_rcu(\n\t\t\t\t\tconst struct net_bridge_port *p)\n{\n\treturn NULL;\n}\n\nstatic inline void br_vlan_get_stats(const struct net_bridge_vlan *v,\n\t\t\t\t     struct pcpu_sw_netstats *stats)\n{\n}\n\nstatic inline void br_vlan_port_event(struct net_bridge_port *p,\n\t\t\t\t      unsigned long event)\n{\n}\n\nstatic inline int br_vlan_bridge_event(struct net_device *dev,\n\t\t\t\t       unsigned long event, void *ptr)\n{\n\treturn 0;\n}\n\nstatic inline void br_vlan_rtnl_init(void)\n{\n}\n\nstatic inline void br_vlan_rtnl_uninit(void)\n{\n}\n\nstatic inline void br_vlan_notify(const struct net_bridge *br,\n\t\t\t\t  const struct net_bridge_port *p,\n\t\t\t\t  u16 vid, u16 vid_range,\n\t\t\t\t  int cmd)\n{\n}\n\nstatic inline bool br_vlan_can_enter_range(const struct net_bridge_vlan *v_curr,\n\t\t\t\t\t   const struct net_bridge_vlan *range_end)\n{\n\treturn true;\n}\n\nstatic inline u16 br_vlan_flags(const struct net_bridge_vlan *v, u16 pvid)\n{\n\treturn 0;\n}\n\n#endif\n\n \n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\nbool br_vlan_opts_eq_range(const struct net_bridge_vlan *v_curr,\n\t\t\t   const struct net_bridge_vlan *range_end);\nbool br_vlan_opts_fill(struct sk_buff *skb, const struct net_bridge_vlan *v,\n\t\t       const struct net_bridge_port *p);\nsize_t br_vlan_opts_nl_size(void);\nint br_vlan_process_options(const struct net_bridge *br,\n\t\t\t    const struct net_bridge_port *p,\n\t\t\t    struct net_bridge_vlan *range_start,\n\t\t\t    struct net_bridge_vlan *range_end,\n\t\t\t    struct nlattr **tb,\n\t\t\t    struct netlink_ext_ack *extack);\nint br_vlan_rtm_process_global_options(struct net_device *dev,\n\t\t\t\t       const struct nlattr *attr,\n\t\t\t\t       int cmd,\n\t\t\t\t       struct netlink_ext_ack *extack);\nbool br_vlan_global_opts_can_enter_range(const struct net_bridge_vlan *v_curr,\n\t\t\t\t\t const struct net_bridge_vlan *r_end);\nbool br_vlan_global_opts_fill(struct sk_buff *skb, u16 vid, u16 vid_range,\n\t\t\t      const struct net_bridge_vlan *v_opts);\n\n \nstatic inline u8 br_vlan_get_state(const struct net_bridge_vlan *v)\n{\n\treturn READ_ONCE(v->state);\n}\n\nstatic inline void br_vlan_set_state(struct net_bridge_vlan *v, u8 state)\n{\n\tWRITE_ONCE(v->state, state);\n}\n\nstatic inline u8 br_vlan_get_pvid_state(const struct net_bridge_vlan_group *vg)\n{\n\treturn READ_ONCE(vg->pvid_state);\n}\n\nstatic inline void br_vlan_set_pvid_state(struct net_bridge_vlan_group *vg,\n\t\t\t\t\t  u8 state)\n{\n\tWRITE_ONCE(vg->pvid_state, state);\n}\n\n \nstatic inline bool br_vlan_state_allowed(u8 state, bool learn_allow)\n{\n\tswitch (state) {\n\tcase BR_STATE_LEARNING:\n\t\treturn learn_allow;\n\tcase BR_STATE_FORWARDING:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n#endif\n\n \n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\nDECLARE_STATIC_KEY_FALSE(br_mst_used);\nstatic inline bool br_mst_is_enabled(struct net_bridge *br)\n{\n\treturn static_branch_unlikely(&br_mst_used) &&\n\t\tbr_opt_get(br, BROPT_MST_ENABLED);\n}\n\nint br_mst_set_state(struct net_bridge_port *p, u16 msti, u8 state,\n\t\t     struct netlink_ext_ack *extack);\nint br_mst_vlan_set_msti(struct net_bridge_vlan *v, u16 msti);\nvoid br_mst_vlan_init_state(struct net_bridge_vlan *v);\nint br_mst_set_enabled(struct net_bridge *br, bool on,\n\t\t       struct netlink_ext_ack *extack);\nsize_t br_mst_info_size(const struct net_bridge_vlan_group *vg);\nint br_mst_fill_info(struct sk_buff *skb,\n\t\t     const struct net_bridge_vlan_group *vg);\nint br_mst_process(struct net_bridge_port *p, const struct nlattr *mst_attr,\n\t\t   struct netlink_ext_ack *extack);\n#else\nstatic inline bool br_mst_is_enabled(struct net_bridge *br)\n{\n\treturn false;\n}\n\nstatic inline int br_mst_set_state(struct net_bridge_port *p, u16 msti,\n\t\t\t\t   u8 state, struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int br_mst_set_enabled(struct net_bridge *br, bool on,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline size_t br_mst_info_size(const struct net_bridge_vlan_group *vg)\n{\n\treturn 0;\n}\n\nstatic inline int br_mst_fill_info(struct sk_buff *skb,\n\t\t\t\t   const struct net_bridge_vlan_group *vg)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int br_mst_process(struct net_bridge_port *p,\n\t\t\t\t const struct nlattr *mst_attr,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstruct nf_br_ops {\n\tint (*br_dev_xmit_hook)(struct sk_buff *skb);\n};\nextern const struct nf_br_ops __rcu *nf_br_ops;\n\n \n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\nint br_nf_core_init(void);\nvoid br_nf_core_fini(void);\nvoid br_netfilter_rtable_init(struct net_bridge *);\n#else\nstatic inline int br_nf_core_init(void) { return 0; }\nstatic inline void br_nf_core_fini(void) {}\n#define br_netfilter_rtable_init(x)\n#endif\n\n \nvoid br_set_state(struct net_bridge_port *p, unsigned int state);\nstruct net_bridge_port *br_get_port(struct net_bridge *br, u16 port_no);\nvoid br_init_port(struct net_bridge_port *p);\nvoid br_become_designated_port(struct net_bridge_port *p);\n\nvoid __br_set_forward_delay(struct net_bridge *br, unsigned long t);\nint br_set_forward_delay(struct net_bridge *br, unsigned long x);\nint br_set_hello_time(struct net_bridge *br, unsigned long x);\nint br_set_max_age(struct net_bridge *br, unsigned long x);\nint __set_ageing_time(struct net_device *dev, unsigned long t);\nint br_set_ageing_time(struct net_bridge *br, clock_t ageing_time);\n\n\n \nvoid br_stp_enable_bridge(struct net_bridge *br);\nvoid br_stp_disable_bridge(struct net_bridge *br);\nint br_stp_set_enabled(struct net_bridge *br, unsigned long val,\n\t\t       struct netlink_ext_ack *extack);\nvoid br_stp_enable_port(struct net_bridge_port *p);\nvoid br_stp_disable_port(struct net_bridge_port *p);\nbool br_stp_recalculate_bridge_id(struct net_bridge *br);\nvoid br_stp_change_bridge_id(struct net_bridge *br, const unsigned char *a);\nvoid br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio);\nint br_stp_set_port_priority(struct net_bridge_port *p, unsigned long newprio);\nint br_stp_set_path_cost(struct net_bridge_port *p, unsigned long path_cost);\nssize_t br_show_bridge_id(char *buf, const struct bridge_id *id);\n\n \nstruct stp_proto;\nvoid br_stp_rcv(const struct stp_proto *proto, struct sk_buff *skb,\n\t\tstruct net_device *dev);\n\n \nvoid br_stp_timer_init(struct net_bridge *br);\nvoid br_stp_port_timer_init(struct net_bridge_port *p);\nunsigned long br_timer_value(const struct timer_list *timer);\n\n \n#if IS_ENABLED(CONFIG_ATM_LANE)\nextern int (*br_fdb_test_addr_hook)(struct net_device *dev, unsigned char *addr);\n#endif\n\n \n#if IS_ENABLED(CONFIG_BRIDGE_MRP)\nint br_mrp_parse(struct net_bridge *br, struct net_bridge_port *p,\n\t\t struct nlattr *attr, int cmd, struct netlink_ext_ack *extack);\nbool br_mrp_enabled(struct net_bridge *br);\nvoid br_mrp_port_del(struct net_bridge *br, struct net_bridge_port *p);\nint br_mrp_fill_info(struct sk_buff *skb, struct net_bridge *br);\n#else\nstatic inline int br_mrp_parse(struct net_bridge *br, struct net_bridge_port *p,\n\t\t\t       struct nlattr *attr, int cmd,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline bool br_mrp_enabled(struct net_bridge *br)\n{\n\treturn false;\n}\n\nstatic inline void br_mrp_port_del(struct net_bridge *br,\n\t\t\t\t   struct net_bridge_port *p)\n{\n}\n\nstatic inline int br_mrp_fill_info(struct sk_buff *skb, struct net_bridge *br)\n{\n\treturn 0;\n}\n\n#endif\n\n \n#if IS_ENABLED(CONFIG_BRIDGE_CFM)\nint br_cfm_parse(struct net_bridge *br, struct net_bridge_port *p,\n\t\t struct nlattr *attr, int cmd, struct netlink_ext_ack *extack);\nbool br_cfm_created(struct net_bridge *br);\nvoid br_cfm_port_del(struct net_bridge *br, struct net_bridge_port *p);\nint br_cfm_config_fill_info(struct sk_buff *skb, struct net_bridge *br);\nint br_cfm_status_fill_info(struct sk_buff *skb,\n\t\t\t    struct net_bridge *br,\n\t\t\t    bool getlink);\nint br_cfm_mep_count(struct net_bridge *br, u32 *count);\nint br_cfm_peer_mep_count(struct net_bridge *br, u32 *count);\n#else\nstatic inline int br_cfm_parse(struct net_bridge *br, struct net_bridge_port *p,\n\t\t\t       struct nlattr *attr, int cmd,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline bool br_cfm_created(struct net_bridge *br)\n{\n\treturn false;\n}\n\nstatic inline void br_cfm_port_del(struct net_bridge *br,\n\t\t\t\t   struct net_bridge_port *p)\n{\n}\n\nstatic inline int br_cfm_config_fill_info(struct sk_buff *skb, struct net_bridge *br)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int br_cfm_status_fill_info(struct sk_buff *skb,\n\t\t\t\t\t  struct net_bridge *br,\n\t\t\t\t\t  bool getlink)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int br_cfm_mep_count(struct net_bridge *br, u32 *count)\n{\n\t*count = 0;\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int br_cfm_peer_mep_count(struct net_bridge *br, u32 *count)\n{\n\t*count = 0;\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n \nextern struct rtnl_link_ops br_link_ops;\nint br_netlink_init(void);\nvoid br_netlink_fini(void);\nvoid br_ifinfo_notify(int event, const struct net_bridge *br,\n\t\t      const struct net_bridge_port *port);\nvoid br_info_notify(int event, const struct net_bridge *br,\n\t\t    const struct net_bridge_port *port, u32 filter);\nint br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags,\n\t       struct netlink_ext_ack *extack);\nint br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags);\nint br_getlink(struct sk_buff *skb, u32 pid, u32 seq, struct net_device *dev,\n\t       u32 filter_mask, int nlflags);\nint br_process_vlan_info(struct net_bridge *br,\n\t\t\t struct net_bridge_port *p, int cmd,\n\t\t\t struct bridge_vlan_info *vinfo_curr,\n\t\t\t struct bridge_vlan_info **vinfo_last,\n\t\t\t bool *changed,\n\t\t\t struct netlink_ext_ack *extack);\n\n#ifdef CONFIG_SYSFS\n \nextern const struct sysfs_ops brport_sysfs_ops;\nint br_sysfs_addif(struct net_bridge_port *p);\nint br_sysfs_renameif(struct net_bridge_port *p);\n\n \nint br_sysfs_addbr(struct net_device *dev);\nvoid br_sysfs_delbr(struct net_device *dev);\n\n#else\n\nstatic inline int br_sysfs_addif(struct net_bridge_port *p) { return 0; }\nstatic inline int br_sysfs_renameif(struct net_bridge_port *p) { return 0; }\nstatic inline int br_sysfs_addbr(struct net_device *dev) { return 0; }\nstatic inline void br_sysfs_delbr(struct net_device *dev) { return; }\n#endif  \n\n \n#ifdef CONFIG_NET_SWITCHDEV\nint br_switchdev_port_offload(struct net_bridge_port *p,\n\t\t\t      struct net_device *dev, const void *ctx,\n\t\t\t      struct notifier_block *atomic_nb,\n\t\t\t      struct notifier_block *blocking_nb,\n\t\t\t      bool tx_fwd_offload,\n\t\t\t      struct netlink_ext_ack *extack);\n\nvoid br_switchdev_port_unoffload(struct net_bridge_port *p, const void *ctx,\n\t\t\t\t struct notifier_block *atomic_nb,\n\t\t\t\t struct notifier_block *blocking_nb);\n\nint br_switchdev_port_replay(struct net_bridge_port *p,\n\t\t\t     struct net_device *dev, const void *ctx,\n\t\t\t     struct notifier_block *atomic_nb,\n\t\t\t     struct notifier_block *blocking_nb,\n\t\t\t     struct netlink_ext_ack *extack);\n\nbool br_switchdev_frame_uses_tx_fwd_offload(struct sk_buff *skb);\n\nvoid br_switchdev_frame_set_offload_fwd_mark(struct sk_buff *skb);\n\nvoid nbp_switchdev_frame_mark_tx_fwd_offload(const struct net_bridge_port *p,\n\t\t\t\t\t     struct sk_buff *skb);\nvoid nbp_switchdev_frame_mark_tx_fwd_to_hwdom(const struct net_bridge_port *p,\n\t\t\t\t\t      struct sk_buff *skb);\nvoid nbp_switchdev_frame_mark(const struct net_bridge_port *p,\n\t\t\t      struct sk_buff *skb);\nbool nbp_switchdev_allowed_egress(const struct net_bridge_port *p,\n\t\t\t\t  const struct sk_buff *skb);\nint br_switchdev_set_port_flag(struct net_bridge_port *p,\n\t\t\t       unsigned long flags,\n\t\t\t       unsigned long mask,\n\t\t\t       struct netlink_ext_ack *extack);\nvoid br_switchdev_fdb_notify(struct net_bridge *br,\n\t\t\t     const struct net_bridge_fdb_entry *fdb, int type);\nvoid br_switchdev_mdb_notify(struct net_device *dev,\n\t\t\t     struct net_bridge_mdb_entry *mp,\n\t\t\t     struct net_bridge_port_group *pg,\n\t\t\t     int type);\nint br_switchdev_port_vlan_add(struct net_device *dev, u16 vid, u16 flags,\n\t\t\t       bool changed, struct netlink_ext_ack *extack);\nint br_switchdev_port_vlan_del(struct net_device *dev, u16 vid);\nvoid br_switchdev_init(struct net_bridge *br);\n\nstatic inline void br_switchdev_frame_unmark(struct sk_buff *skb)\n{\n\tskb->offload_fwd_mark = 0;\n}\n#else\nstatic inline int\nbr_switchdev_port_offload(struct net_bridge_port *p,\n\t\t\t  struct net_device *dev, const void *ctx,\n\t\t\t  struct notifier_block *atomic_nb,\n\t\t\t  struct notifier_block *blocking_nb,\n\t\t\t  bool tx_fwd_offload,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void\nbr_switchdev_port_unoffload(struct net_bridge_port *p, const void *ctx,\n\t\t\t    struct notifier_block *atomic_nb,\n\t\t\t    struct notifier_block *blocking_nb)\n{\n}\n\nstatic inline int\nbr_switchdev_port_replay(struct net_bridge_port *p,\n\t\t\t struct net_device *dev, const void *ctx,\n\t\t\t struct notifier_block *atomic_nb,\n\t\t\t struct notifier_block *blocking_nb,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline bool br_switchdev_frame_uses_tx_fwd_offload(struct sk_buff *skb)\n{\n\treturn false;\n}\n\nstatic inline void br_switchdev_frame_set_offload_fwd_mark(struct sk_buff *skb)\n{\n}\n\nstatic inline void\nnbp_switchdev_frame_mark_tx_fwd_offload(const struct net_bridge_port *p,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n}\n\nstatic inline void\nnbp_switchdev_frame_mark_tx_fwd_to_hwdom(const struct net_bridge_port *p,\n\t\t\t\t\t struct sk_buff *skb)\n{\n}\n\nstatic inline void nbp_switchdev_frame_mark(const struct net_bridge_port *p,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n}\n\nstatic inline bool nbp_switchdev_allowed_egress(const struct net_bridge_port *p,\n\t\t\t\t\t\tconst struct sk_buff *skb)\n{\n\treturn true;\n}\n\nstatic inline int br_switchdev_set_port_flag(struct net_bridge_port *p,\n\t\t\t\t\t     unsigned long flags,\n\t\t\t\t\t     unsigned long mask,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\n\nstatic inline int br_switchdev_port_vlan_add(struct net_device *dev, u16 vid,\n\t\t\t\t\t     u16 flags, bool changed,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int br_switchdev_port_vlan_del(struct net_device *dev, u16 vid)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void\nbr_switchdev_fdb_notify(struct net_bridge *br,\n\t\t\tconst struct net_bridge_fdb_entry *fdb, int type)\n{\n}\n\nstatic inline void br_switchdev_mdb_notify(struct net_device *dev,\n\t\t\t\t\t   struct net_bridge_mdb_entry *mp,\n\t\t\t\t\t   struct net_bridge_port_group *pg,\n\t\t\t\t\t   int type)\n{\n}\n\nstatic inline void br_switchdev_frame_unmark(struct sk_buff *skb)\n{\n}\n\nstatic inline void br_switchdev_init(struct net_bridge *br)\n{\n}\n\n#endif  \n\n \nvoid br_recalculate_neigh_suppress_enabled(struct net_bridge *br);\nvoid br_do_proxy_suppress_arp(struct sk_buff *skb, struct net_bridge *br,\n\t\t\t      u16 vid, struct net_bridge_port *p);\nvoid br_do_suppress_nd(struct sk_buff *skb, struct net_bridge *br,\n\t\t       u16 vid, struct net_bridge_port *p, struct nd_msg *msg);\nstruct nd_msg *br_is_nd_neigh_msg(struct sk_buff *skb, struct nd_msg *m);\nbool br_is_neigh_suppress_enabled(const struct net_bridge_port *p, u16 vid);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}