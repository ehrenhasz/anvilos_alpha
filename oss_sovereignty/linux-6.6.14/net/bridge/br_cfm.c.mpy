{
  "module_name": "br_cfm.c",
  "hash_id": "f12f2def979d38d75619472f1d83e313ef2cda12a06818b25b1d9c88d58684fc",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_cfm.c",
  "human_readable_source": "\n\n#include <linux/cfm_bridge.h>\n#include <uapi/linux/cfm_bridge.h>\n#include \"br_private_cfm.h\"\n\nstatic struct br_cfm_mep *br_mep_find(struct net_bridge *br, u32 instance)\n{\n\tstruct br_cfm_mep *mep;\n\n\thlist_for_each_entry(mep, &br->mep_list, head)\n\t\tif (mep->instance == instance)\n\t\t\treturn mep;\n\n\treturn NULL;\n}\n\nstatic struct br_cfm_mep *br_mep_find_ifindex(struct net_bridge *br,\n\t\t\t\t\t      u32 ifindex)\n{\n\tstruct br_cfm_mep *mep;\n\n\thlist_for_each_entry_rcu(mep, &br->mep_list, head,\n\t\t\t\t lockdep_rtnl_is_held())\n\t\tif (mep->create.ifindex == ifindex)\n\t\t\treturn mep;\n\n\treturn NULL;\n}\n\nstatic struct br_cfm_peer_mep *br_peer_mep_find(struct br_cfm_mep *mep,\n\t\t\t\t\t\tu32 mepid)\n{\n\tstruct br_cfm_peer_mep *peer_mep;\n\n\thlist_for_each_entry_rcu(peer_mep, &mep->peer_mep_list, head,\n\t\t\t\t lockdep_rtnl_is_held())\n\t\tif (peer_mep->mepid == mepid)\n\t\t\treturn peer_mep;\n\n\treturn NULL;\n}\n\nstatic struct net_bridge_port *br_mep_get_port(struct net_bridge *br,\n\t\t\t\t\t       u32 ifindex)\n{\n\tstruct net_bridge_port *port;\n\n\tlist_for_each_entry(port, &br->port_list, list)\n\t\tif (port->dev->ifindex == ifindex)\n\t\t\treturn port;\n\n\treturn NULL;\n}\n\n \nstatic u32 interval_to_us(enum br_cfm_ccm_interval interval)\n{\n\tswitch (interval) {\n\tcase BR_CFM_CCM_INTERVAL_NONE:\n\t\treturn 0;\n\tcase BR_CFM_CCM_INTERVAL_3_3_MS:\n\t\treturn 3300;\n\tcase BR_CFM_CCM_INTERVAL_10_MS:\n\t\treturn 10 * 1000;\n\tcase BR_CFM_CCM_INTERVAL_100_MS:\n\t\treturn 100 * 1000;\n\tcase BR_CFM_CCM_INTERVAL_1_SEC:\n\t\treturn 1000 * 1000;\n\tcase BR_CFM_CCM_INTERVAL_10_SEC:\n\t\treturn 10 * 1000 * 1000;\n\tcase BR_CFM_CCM_INTERVAL_1_MIN:\n\t\treturn 60 * 1000 * 1000;\n\tcase BR_CFM_CCM_INTERVAL_10_MIN:\n\t\treturn 10 * 60 * 1000 * 1000;\n\t}\n\treturn 0;\n}\n\n \nstatic u32 interval_to_pdu(enum br_cfm_ccm_interval interval)\n{\n\tswitch (interval) {\n\tcase BR_CFM_CCM_INTERVAL_NONE:\n\t\treturn 0;\n\tcase BR_CFM_CCM_INTERVAL_3_3_MS:\n\t\treturn 1;\n\tcase BR_CFM_CCM_INTERVAL_10_MS:\n\t\treturn 2;\n\tcase BR_CFM_CCM_INTERVAL_100_MS:\n\t\treturn 3;\n\tcase BR_CFM_CCM_INTERVAL_1_SEC:\n\t\treturn 4;\n\tcase BR_CFM_CCM_INTERVAL_10_SEC:\n\t\treturn 5;\n\tcase BR_CFM_CCM_INTERVAL_1_MIN:\n\t\treturn 6;\n\tcase BR_CFM_CCM_INTERVAL_10_MIN:\n\t\treturn 7;\n\t}\n\treturn 0;\n}\n\n \nstatic u32 pdu_to_interval(u32 value)\n{\n\tswitch (value) {\n\tcase 0:\n\t\treturn BR_CFM_CCM_INTERVAL_NONE;\n\tcase 1:\n\t\treturn BR_CFM_CCM_INTERVAL_3_3_MS;\n\tcase 2:\n\t\treturn BR_CFM_CCM_INTERVAL_10_MS;\n\tcase 3:\n\t\treturn BR_CFM_CCM_INTERVAL_100_MS;\n\tcase 4:\n\t\treturn BR_CFM_CCM_INTERVAL_1_SEC;\n\tcase 5:\n\t\treturn BR_CFM_CCM_INTERVAL_10_SEC;\n\tcase 6:\n\t\treturn BR_CFM_CCM_INTERVAL_1_MIN;\n\tcase 7:\n\t\treturn BR_CFM_CCM_INTERVAL_10_MIN;\n\t}\n\treturn BR_CFM_CCM_INTERVAL_NONE;\n}\n\nstatic void ccm_rx_timer_start(struct br_cfm_peer_mep *peer_mep)\n{\n\tu32 interval_us;\n\n\tinterval_us = interval_to_us(peer_mep->mep->cc_config.exp_interval);\n\t \n\tqueue_delayed_work(system_wq, &peer_mep->ccm_rx_dwork,\n\t\t\t   usecs_to_jiffies(interval_us / 4));\n}\n\nstatic void br_cfm_notify(int event, const struct net_bridge_port *port)\n{\n\tu32 filter = RTEXT_FILTER_CFM_STATUS;\n\n\tbr_info_notify(event, port->br, NULL, filter);\n}\n\nstatic void cc_peer_enable(struct br_cfm_peer_mep *peer_mep)\n{\n\tmemset(&peer_mep->cc_status, 0, sizeof(peer_mep->cc_status));\n\tpeer_mep->ccm_rx_count_miss = 0;\n\n\tccm_rx_timer_start(peer_mep);\n}\n\nstatic void cc_peer_disable(struct br_cfm_peer_mep *peer_mep)\n{\n\tcancel_delayed_work_sync(&peer_mep->ccm_rx_dwork);\n}\n\nstatic struct sk_buff *ccm_frame_build(struct br_cfm_mep *mep,\n\t\t\t\t       const struct br_cfm_cc_ccm_tx_info *const tx_info)\n\n{\n\tstruct br_cfm_common_hdr *common_hdr;\n\tstruct net_bridge_port *b_port;\n\tstruct br_cfm_maid *maid;\n\tu8 *itu_reserved, *e_tlv;\n\tstruct ethhdr *eth_hdr;\n\tstruct sk_buff *skb;\n\t__be32 *status_tlv;\n\t__be32 *snumber;\n\t__be16 *mepid;\n\n\tskb = dev_alloc_skb(CFM_CCM_MAX_FRAME_LENGTH);\n\tif (!skb)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tb_port = rcu_dereference(mep->b_port);\n\tif (!b_port) {\n\t\tkfree_skb(skb);\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tskb->dev = b_port->dev;\n\trcu_read_unlock();\n\t \n\n\tskb->protocol = htons(ETH_P_CFM);\n\tskb->priority = CFM_FRAME_PRIO;\n\n\t \n\teth_hdr = skb_put(skb, sizeof(*eth_hdr));\n\tether_addr_copy(eth_hdr->h_dest, tx_info->dmac.addr);\n\tether_addr_copy(eth_hdr->h_source, mep->config.unicast_mac.addr);\n\teth_hdr->h_proto = htons(ETH_P_CFM);\n\n\t \n\tcommon_hdr = skb_put(skb, sizeof(*common_hdr));\n\tcommon_hdr->mdlevel_version = mep->config.mdlevel << 5;\n\tcommon_hdr->opcode = BR_CFM_OPCODE_CCM;\n\tcommon_hdr->flags = (mep->rdi << 7) |\n\t\t\t    interval_to_pdu(mep->cc_config.exp_interval);\n\tcommon_hdr->tlv_offset = CFM_CCM_TLV_OFFSET;\n\n\t \n\tsnumber = skb_put(skb, sizeof(*snumber));\n\tif (tx_info->seq_no_update) {\n\t\t*snumber = cpu_to_be32(mep->ccm_tx_snumber);\n\t\tmep->ccm_tx_snumber += 1;\n\t} else {\n\t\t*snumber = 0;\n\t}\n\n\tmepid = skb_put(skb, sizeof(*mepid));\n\t*mepid = cpu_to_be16((u16)mep->config.mepid);\n\n\tmaid = skb_put(skb, sizeof(*maid));\n\tmemcpy(maid->data, mep->cc_config.exp_maid.data, sizeof(maid->data));\n\n\t \n\titu_reserved = skb_put(skb, CFM_CCM_ITU_RESERVED_SIZE);\n\tmemset(itu_reserved, 0, CFM_CCM_ITU_RESERVED_SIZE);\n\n\t \n\n\t \n\tif (tx_info->port_tlv) {\n\t\tstatus_tlv = skb_put(skb, sizeof(*status_tlv));\n\t\t*status_tlv = cpu_to_be32((CFM_PORT_STATUS_TLV_TYPE << 24) |\n\t\t\t\t\t  (1 << 8) |\t \n\t\t\t\t\t  (tx_info->port_tlv_value & 0xFF));\n\t}\n\n\t \n\tif (tx_info->if_tlv) {\n\t\tstatus_tlv = skb_put(skb, sizeof(*status_tlv));\n\t\t*status_tlv = cpu_to_be32((CFM_IF_STATUS_TLV_TYPE << 24) |\n\t\t\t\t\t  (1 << 8) |\t \n\t\t\t\t\t  (tx_info->if_tlv_value & 0xFF));\n\t}\n\n\t \n\te_tlv = skb_put(skb, sizeof(*e_tlv));\n\t*e_tlv = CFM_ENDE_TLV_TYPE;\n\n\treturn skb;\n}\n\nstatic void ccm_frame_tx(struct sk_buff *skb)\n{\n\tskb_reset_network_header(skb);\n\tdev_queue_xmit(skb);\n}\n\n \nstatic void ccm_tx_work_expired(struct work_struct *work)\n{\n\tstruct delayed_work *del_work;\n\tstruct br_cfm_mep *mep;\n\tstruct sk_buff *skb;\n\tu32 interval_us;\n\n\tdel_work = to_delayed_work(work);\n\tmep = container_of(del_work, struct br_cfm_mep, ccm_tx_dwork);\n\n\tif (time_before_eq(mep->ccm_tx_end, jiffies)) {\n\t\t \n\t\tmep->cc_ccm_tx_info.period = 0;\n\t\treturn;\n\t}\n\n\tskb = ccm_frame_build(mep, &mep->cc_ccm_tx_info);\n\tif (skb)\n\t\tccm_frame_tx(skb);\n\n\tinterval_us = interval_to_us(mep->cc_config.exp_interval);\n\tqueue_delayed_work(system_wq, &mep->ccm_tx_dwork,\n\t\t\t   usecs_to_jiffies(interval_us));\n}\n\n \nstatic void ccm_rx_work_expired(struct work_struct *work)\n{\n\tstruct br_cfm_peer_mep *peer_mep;\n\tstruct net_bridge_port *b_port;\n\tstruct delayed_work *del_work;\n\n\tdel_work = to_delayed_work(work);\n\tpeer_mep = container_of(del_work, struct br_cfm_peer_mep, ccm_rx_dwork);\n\n\t \n\tif (peer_mep->ccm_rx_count_miss < 13) {\n\t\t \n\t\tpeer_mep->ccm_rx_count_miss++;\n\n\t\t \n\t\tccm_rx_timer_start(peer_mep);\n\t} else {\n\t\t \n\t\tpeer_mep->cc_status.ccm_defect = true;\n\n\t\t \n\t\trcu_read_lock();\n\t\tb_port = rcu_dereference(peer_mep->mep->b_port);\n\t\tif (b_port)\n\t\t\tbr_cfm_notify(RTM_NEWLINK, b_port);\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic u32 ccm_tlv_extract(struct sk_buff *skb, u32 index,\n\t\t\t   struct br_cfm_peer_mep *peer_mep)\n{\n\t__be32 *s_tlv;\n\t__be32 _s_tlv;\n\tu32 h_s_tlv;\n\tu8 *e_tlv;\n\tu8 _e_tlv;\n\n\te_tlv = skb_header_pointer(skb, index, sizeof(_e_tlv), &_e_tlv);\n\tif (!e_tlv)\n\t\treturn 0;\n\n\t \n\ts_tlv = skb_header_pointer(skb,\n\t\t\t\t   index,\n\t\t\t\t   sizeof(_s_tlv), &_s_tlv);\n\tif (!s_tlv)\n\t\treturn 0;\n\n\th_s_tlv = ntohl(*s_tlv);\n\tif ((h_s_tlv >> 24) == CFM_IF_STATUS_TLV_TYPE) {\n\t\t \n\t\tpeer_mep->cc_status.tlv_seen = true;\n\t\tpeer_mep->cc_status.if_tlv_value = (h_s_tlv & 0xFF);\n\t}\n\n\tif ((h_s_tlv >> 24) == CFM_PORT_STATUS_TLV_TYPE) {\n\t\t \n\t\tpeer_mep->cc_status.tlv_seen = true;\n\t\tpeer_mep->cc_status.port_tlv_value = (h_s_tlv & 0xFF);\n\t}\n\n\t \n\t \n\n\t \n\treturn ((h_s_tlv >> 8) & 0xFFFF) + 3;\n}\n\n \nstatic int br_cfm_frame_rx(struct net_bridge_port *port, struct sk_buff *skb)\n{\n\tu32 mdlevel, interval, size, index, max;\n\tconst struct br_cfm_common_hdr *hdr;\n\tstruct br_cfm_peer_mep *peer_mep;\n\tconst struct br_cfm_maid *maid;\n\tstruct br_cfm_common_hdr _hdr;\n\tstruct br_cfm_maid _maid;\n\tstruct br_cfm_mep *mep;\n\tstruct net_bridge *br;\n\t__be32 *snumber;\n\t__be32 _snumber;\n\t__be16 *mepid;\n\t__be16 _mepid;\n\n\tif (port->state == BR_STATE_DISABLED)\n\t\treturn 0;\n\n\thdr = skb_header_pointer(skb, 0, sizeof(_hdr), &_hdr);\n\tif (!hdr)\n\t\treturn 1;\n\n\tbr = port->br;\n\tmep = br_mep_find_ifindex(br, port->dev->ifindex);\n\tif (unlikely(!mep))\n\t\t \n\t\treturn 0;\n\n\tmdlevel = hdr->mdlevel_version >> 5;\n\tif (mdlevel > mep->config.mdlevel)\n\t\t \n\t\treturn 0;\n\n\tif ((hdr->mdlevel_version & 0x1F) != 0) {\n\t\t \n\t\tmep->status.version_unexp_seen = true;\n\t\treturn 1;\n\t}\n\n\tif (mdlevel < mep->config.mdlevel) {\n\t\t \n\t\tmep->status.rx_level_low_seen = true;\n\t\treturn 1;\n\t}\n\n\tif (hdr->opcode == BR_CFM_OPCODE_CCM) {\n\t\t \n\t\t \n\t\tmaid = skb_header_pointer(skb,\n\t\t\t\t\t  CFM_CCM_PDU_MAID_OFFSET,\n\t\t\t\t\t  sizeof(_maid), &_maid);\n\t\tif (!maid)\n\t\t\treturn 1;\n\t\tif (memcmp(maid->data, mep->cc_config.exp_maid.data,\n\t\t\t   sizeof(maid->data)))\n\t\t\t \n\t\t\treturn 1;\n\n\t\t \n\t\tmepid = skb_header_pointer(skb,\n\t\t\t\t\t   CFM_CCM_PDU_MEPID_OFFSET,\n\t\t\t\t\t   sizeof(_mepid), &_mepid);\n\t\tif (!mepid)\n\t\t\treturn 1;\n\t\tpeer_mep = br_peer_mep_find(mep, (u32)ntohs(*mepid));\n\t\tif (!peer_mep)\n\t\t\treturn 1;\n\n\t\t \n\t\tinterval = hdr->flags & 0x07;\n\t\tif (mep->cc_config.exp_interval != pdu_to_interval(interval))\n\t\t\t \n\t\t\treturn 1;\n\n\t\t \n\t\tif (peer_mep->cc_status.ccm_defect) {\n\t\t\tpeer_mep->cc_status.ccm_defect = false;\n\n\t\t\t \n\t\t\tbr_cfm_notify(RTM_NEWLINK, port);\n\n\t\t\t \n\t\t\tccm_rx_timer_start(peer_mep);\n\t\t}\n\n\t\tpeer_mep->cc_status.seen = true;\n\t\tpeer_mep->ccm_rx_count_miss = 0;\n\n\t\t \n\t\tpeer_mep->cc_status.rdi = (hdr->flags & 0x80) ? true : false;\n\n\t\t \n\t\tsnumber = skb_header_pointer(skb,\n\t\t\t\t\t     CFM_CCM_PDU_SEQNR_OFFSET,\n\t\t\t\t\t     sizeof(_snumber), &_snumber);\n\t\tif (!snumber)\n\t\t\treturn 1;\n\t\tif (ntohl(*snumber) != (mep->ccm_rx_snumber + 1))\n\t\t\t \n\t\t\tpeer_mep->cc_status.seq_unexp_seen = true;\n\n\t\tmep->ccm_rx_snumber = ntohl(*snumber);\n\n\t\t \n\t\tindex = CFM_CCM_PDU_TLV_OFFSET;\n\t\tmax = 0;\n\t\tdo {  \n\t\t\tsize = ccm_tlv_extract(skb, index, peer_mep);\n\t\t\tindex += size;\n\t\t\tmax += 1;\n\t\t} while (size != 0 && max < 4);  \n\n\t\treturn 1;\n\t}\n\n\tmep->status.opcode_unexp_seen = true;\n\n\treturn 1;\n}\n\nstatic struct br_frame_type cfm_frame_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_CFM),\n\t.frame_handler = br_cfm_frame_rx,\n};\n\nint br_cfm_mep_create(struct net_bridge *br,\n\t\t      const u32 instance,\n\t\t      struct br_cfm_mep_create *const create,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_port *p;\n\tstruct br_cfm_mep *mep;\n\n\tASSERT_RTNL();\n\n\tif (create->domain == BR_CFM_VLAN) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"VLAN domain not supported\");\n\t\treturn -EINVAL;\n\t}\n\tif (create->domain != BR_CFM_PORT) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid domain value\");\n\t\treturn -EINVAL;\n\t}\n\tif (create->direction == BR_CFM_MEP_DIRECTION_UP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Up-MEP not supported\");\n\t\treturn -EINVAL;\n\t}\n\tif (create->direction != BR_CFM_MEP_DIRECTION_DOWN) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid direction value\");\n\t\treturn -EINVAL;\n\t}\n\tp = br_mep_get_port(br, create->ifindex);\n\tif (!p) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Port is not related to bridge\");\n\t\treturn -EINVAL;\n\t}\n\tmep = br_mep_find(br, instance);\n\tif (mep) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"MEP instance already exists\");\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tif (create->domain == BR_CFM_PORT) {\n\t\tmep = br_mep_find_ifindex(br, create->ifindex);\n\t\tif (mep) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Only one Port MEP on a port allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmep = kzalloc(sizeof(*mep), GFP_KERNEL);\n\tif (!mep)\n\t\treturn -ENOMEM;\n\n\tmep->create = *create;\n\tmep->instance = instance;\n\trcu_assign_pointer(mep->b_port, p);\n\n\tINIT_HLIST_HEAD(&mep->peer_mep_list);\n\tINIT_DELAYED_WORK(&mep->ccm_tx_dwork, ccm_tx_work_expired);\n\n\tif (hlist_empty(&br->mep_list))\n\t\tbr_add_frame(br, &cfm_frame_type);\n\n\thlist_add_tail_rcu(&mep->head, &br->mep_list);\n\n\treturn 0;\n}\n\nstatic void mep_delete_implementation(struct net_bridge *br,\n\t\t\t\t      struct br_cfm_mep *mep)\n{\n\tstruct br_cfm_peer_mep *peer_mep;\n\tstruct hlist_node *n_store;\n\n\tASSERT_RTNL();\n\n\t \n\thlist_for_each_entry_safe(peer_mep, n_store, &mep->peer_mep_list, head) {\n\t\tcancel_delayed_work_sync(&peer_mep->ccm_rx_dwork);\n\t\thlist_del_rcu(&peer_mep->head);\n\t\tkfree_rcu(peer_mep, rcu);\n\t}\n\n\tcancel_delayed_work_sync(&mep->ccm_tx_dwork);\n\n\tRCU_INIT_POINTER(mep->b_port, NULL);\n\thlist_del_rcu(&mep->head);\n\tkfree_rcu(mep, rcu);\n\n\tif (hlist_empty(&br->mep_list))\n\t\tbr_del_frame(br, &cfm_frame_type);\n}\n\nint br_cfm_mep_delete(struct net_bridge *br,\n\t\t      const u32 instance,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct br_cfm_mep *mep;\n\n\tASSERT_RTNL();\n\n\tmep = br_mep_find(br, instance);\n\tif (!mep) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"MEP instance does not exists\");\n\t\treturn -ENOENT;\n\t}\n\n\tmep_delete_implementation(br, mep);\n\n\treturn 0;\n}\n\nint br_cfm_mep_config_set(struct net_bridge *br,\n\t\t\t  const u32 instance,\n\t\t\t  const struct br_cfm_mep_config *const config,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct br_cfm_mep *mep;\n\n\tASSERT_RTNL();\n\n\tmep = br_mep_find(br, instance);\n\tif (!mep) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"MEP instance does not exists\");\n\t\treturn -ENOENT;\n\t}\n\n\tmep->config = *config;\n\n\treturn 0;\n}\n\nint br_cfm_cc_config_set(struct net_bridge *br,\n\t\t\t const u32 instance,\n\t\t\t const struct br_cfm_cc_config *const config,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct br_cfm_peer_mep *peer_mep;\n\tstruct br_cfm_mep *mep;\n\n\tASSERT_RTNL();\n\n\tmep = br_mep_find(br, instance);\n\tif (!mep) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"MEP instance does not exists\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (memcmp(config, &mep->cc_config, sizeof(*config)) == 0)\n\t\treturn 0;\n\n\tif (config->enable && !mep->cc_config.enable)\n\t\t \n\t\thlist_for_each_entry(peer_mep, &mep->peer_mep_list, head)\n\t\t\tcc_peer_enable(peer_mep);\n\n\tif (!config->enable && mep->cc_config.enable)\n\t\t \n\t\thlist_for_each_entry(peer_mep, &mep->peer_mep_list, head)\n\t\t\tcc_peer_disable(peer_mep);\n\n\tmep->cc_config = *config;\n\tmep->ccm_rx_snumber = 0;\n\tmep->ccm_tx_snumber = 1;\n\n\treturn 0;\n}\n\nint br_cfm_cc_peer_mep_add(struct net_bridge *br, const u32 instance,\n\t\t\t   u32 mepid,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct br_cfm_peer_mep *peer_mep;\n\tstruct br_cfm_mep *mep;\n\n\tASSERT_RTNL();\n\n\tmep = br_mep_find(br, instance);\n\tif (!mep) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"MEP instance does not exists\");\n\t\treturn -ENOENT;\n\t}\n\n\tpeer_mep = br_peer_mep_find(mep, mepid);\n\tif (peer_mep) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Peer MEP-ID already exists\");\n\t\treturn -EEXIST;\n\t}\n\n\tpeer_mep = kzalloc(sizeof(*peer_mep), GFP_KERNEL);\n\tif (!peer_mep)\n\t\treturn -ENOMEM;\n\n\tpeer_mep->mepid = mepid;\n\tpeer_mep->mep = mep;\n\tINIT_DELAYED_WORK(&peer_mep->ccm_rx_dwork, ccm_rx_work_expired);\n\n\tif (mep->cc_config.enable)\n\t\tcc_peer_enable(peer_mep);\n\n\thlist_add_tail_rcu(&peer_mep->head, &mep->peer_mep_list);\n\n\treturn 0;\n}\n\nint br_cfm_cc_peer_mep_remove(struct net_bridge *br, const u32 instance,\n\t\t\t      u32 mepid,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct br_cfm_peer_mep *peer_mep;\n\tstruct br_cfm_mep *mep;\n\n\tASSERT_RTNL();\n\n\tmep = br_mep_find(br, instance);\n\tif (!mep) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"MEP instance does not exists\");\n\t\treturn -ENOENT;\n\t}\n\n\tpeer_mep = br_peer_mep_find(mep, mepid);\n\tif (!peer_mep) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Peer MEP-ID does not exists\");\n\t\treturn -ENOENT;\n\t}\n\n\tcc_peer_disable(peer_mep);\n\n\thlist_del_rcu(&peer_mep->head);\n\tkfree_rcu(peer_mep, rcu);\n\n\treturn 0;\n}\n\nint br_cfm_cc_rdi_set(struct net_bridge *br, const u32 instance,\n\t\t      const bool rdi, struct netlink_ext_ack *extack)\n{\n\tstruct br_cfm_mep *mep;\n\n\tASSERT_RTNL();\n\n\tmep = br_mep_find(br, instance);\n\tif (!mep) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"MEP instance does not exists\");\n\t\treturn -ENOENT;\n\t}\n\n\tmep->rdi = rdi;\n\n\treturn 0;\n}\n\nint br_cfm_cc_ccm_tx(struct net_bridge *br, const u32 instance,\n\t\t     const struct br_cfm_cc_ccm_tx_info *const tx_info,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct br_cfm_mep *mep;\n\n\tASSERT_RTNL();\n\n\tmep = br_mep_find(br, instance);\n\tif (!mep) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"MEP instance does not exists\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (memcmp(tx_info, &mep->cc_ccm_tx_info, sizeof(*tx_info)) == 0) {\n\t\t \n\t\tif (mep->cc_ccm_tx_info.period == 0)\n\t\t\t \n\t\t\treturn 0;\n\n\t\t \n\t\tmep->ccm_tx_end = jiffies +\n\t\t\t\t  usecs_to_jiffies(tx_info->period * 1000000);\n\t\treturn 0;\n\t}\n\n\tif (tx_info->period == 0 && mep->cc_ccm_tx_info.period == 0)\n\t\t \n\t\tgoto save;\n\n\tif (tx_info->period != 0 && mep->cc_ccm_tx_info.period != 0) {\n\t\t \n\t\tmep->ccm_tx_end = jiffies +\n\t\t\t\t  usecs_to_jiffies(tx_info->period * 1000000);\n\n\t\tgoto save;\n\t}\n\n\tif (tx_info->period == 0 && mep->cc_ccm_tx_info.period != 0) {\n\t\tcancel_delayed_work_sync(&mep->ccm_tx_dwork);\n\t\tgoto save;\n\t}\n\n\t \n\tmep->ccm_tx_end = jiffies + usecs_to_jiffies(tx_info->period * 1000000);\n\tqueue_delayed_work(system_wq, &mep->ccm_tx_dwork, 0);\n\nsave:\n\tmep->cc_ccm_tx_info = *tx_info;\n\n\treturn 0;\n}\n\nint br_cfm_mep_count(struct net_bridge *br, u32 *count)\n{\n\tstruct br_cfm_mep *mep;\n\n\t*count = 0;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(mep, &br->mep_list, head)\n\t\t*count += 1;\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nint br_cfm_peer_mep_count(struct net_bridge *br, u32 *count)\n{\n\tstruct br_cfm_peer_mep *peer_mep;\n\tstruct br_cfm_mep *mep;\n\n\t*count = 0;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(mep, &br->mep_list, head)\n\t\thlist_for_each_entry_rcu(peer_mep, &mep->peer_mep_list, head)\n\t\t\t*count += 1;\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nbool br_cfm_created(struct net_bridge *br)\n{\n\treturn !hlist_empty(&br->mep_list);\n}\n\n \nvoid br_cfm_port_del(struct net_bridge *br, struct net_bridge_port *port)\n{\n\tstruct hlist_node *n_store;\n\tstruct br_cfm_mep *mep;\n\n\tASSERT_RTNL();\n\n\thlist_for_each_entry_safe(mep, n_store, &br->mep_list, head)\n\t\tif (mep->create.ifindex == port->dev->ifindex)\n\t\t\tmep_delete_implementation(br, mep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}