{
  "module_name": "br_fdb.c",
  "hash_id": "2ac7d593a083d407c36a9e38cf3c4ad275c29d1942c897b36a346d3d59140cd8",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_fdb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/rculist.h>\n#include <linux/spinlock.h>\n#include <linux/times.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <asm/unaligned.h>\n#include <linux/if_vlan.h>\n#include <net/switchdev.h>\n#include <trace/events/bridge.h>\n#include \"br_private.h\"\n\nstatic const struct rhashtable_params br_fdb_rht_params = {\n\t.head_offset = offsetof(struct net_bridge_fdb_entry, rhnode),\n\t.key_offset = offsetof(struct net_bridge_fdb_entry, key),\n\t.key_len = sizeof(struct net_bridge_fdb_key),\n\t.automatic_shrinking = true,\n};\n\nstatic struct kmem_cache *br_fdb_cache __read_mostly;\n\nint __init br_fdb_init(void)\n{\n\tbr_fdb_cache = kmem_cache_create(\"bridge_fdb_cache\",\n\t\t\t\t\t sizeof(struct net_bridge_fdb_entry),\n\t\t\t\t\t 0,\n\t\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\tif (!br_fdb_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid br_fdb_fini(void)\n{\n\tkmem_cache_destroy(br_fdb_cache);\n}\n\nint br_fdb_hash_init(struct net_bridge *br)\n{\n\treturn rhashtable_init(&br->fdb_hash_tbl, &br_fdb_rht_params);\n}\n\nvoid br_fdb_hash_fini(struct net_bridge *br)\n{\n\trhashtable_destroy(&br->fdb_hash_tbl);\n}\n\n \nstatic inline unsigned long hold_time(const struct net_bridge *br)\n{\n\treturn br->topology_change ? br->forward_delay : br->ageing_time;\n}\n\nstatic inline int has_expired(const struct net_bridge *br,\n\t\t\t\t  const struct net_bridge_fdb_entry *fdb)\n{\n\treturn !test_bit(BR_FDB_STATIC, &fdb->flags) &&\n\t       !test_bit(BR_FDB_ADDED_BY_EXT_LEARN, &fdb->flags) &&\n\t       time_before_eq(fdb->updated + hold_time(br), jiffies);\n}\n\nstatic void fdb_rcu_free(struct rcu_head *head)\n{\n\tstruct net_bridge_fdb_entry *ent\n\t\t= container_of(head, struct net_bridge_fdb_entry, rcu);\n\tkmem_cache_free(br_fdb_cache, ent);\n}\n\nstatic int fdb_to_nud(const struct net_bridge *br,\n\t\t      const struct net_bridge_fdb_entry *fdb)\n{\n\tif (test_bit(BR_FDB_LOCAL, &fdb->flags))\n\t\treturn NUD_PERMANENT;\n\telse if (test_bit(BR_FDB_STATIC, &fdb->flags))\n\t\treturn NUD_NOARP;\n\telse if (has_expired(br, fdb))\n\t\treturn NUD_STALE;\n\telse\n\t\treturn NUD_REACHABLE;\n}\n\nstatic int fdb_fill_info(struct sk_buff *skb, const struct net_bridge *br,\n\t\t\t const struct net_bridge_fdb_entry *fdb,\n\t\t\t u32 portid, u32 seq, int type, unsigned int flags)\n{\n\tconst struct net_bridge_port *dst = READ_ONCE(fdb->dst);\n\tunsigned long now = jiffies;\n\tstruct nda_cacheinfo ci;\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *ndm;\n\tu32 ext_flags = 0;\n\n\tnlh = nlmsg_put(skb, portid, seq, type, sizeof(*ndm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tndm = nlmsg_data(nlh);\n\tndm->ndm_family\t = AF_BRIDGE;\n\tndm->ndm_pad1    = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags\t = 0;\n\tndm->ndm_type\t = 0;\n\tndm->ndm_ifindex = dst ? dst->dev->ifindex : br->dev->ifindex;\n\tndm->ndm_state   = fdb_to_nud(br, fdb);\n\n\tif (test_bit(BR_FDB_OFFLOADED, &fdb->flags))\n\t\tndm->ndm_flags |= NTF_OFFLOADED;\n\tif (test_bit(BR_FDB_ADDED_BY_EXT_LEARN, &fdb->flags))\n\t\tndm->ndm_flags |= NTF_EXT_LEARNED;\n\tif (test_bit(BR_FDB_STICKY, &fdb->flags))\n\t\tndm->ndm_flags |= NTF_STICKY;\n\tif (test_bit(BR_FDB_LOCKED, &fdb->flags))\n\t\text_flags |= NTF_EXT_LOCKED;\n\n\tif (nla_put(skb, NDA_LLADDR, ETH_ALEN, &fdb->key.addr))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, NDA_MASTER, br->dev->ifindex))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, NDA_FLAGS_EXT, ext_flags))\n\t\tgoto nla_put_failure;\n\n\tci.ndm_used\t = jiffies_to_clock_t(now - fdb->used);\n\tci.ndm_confirmed = 0;\n\tci.ndm_updated\t = jiffies_to_clock_t(now - fdb->updated);\n\tci.ndm_refcnt\t = 0;\n\tif (nla_put(skb, NDA_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\n\tif (fdb->key.vlan_id && nla_put(skb, NDA_VLAN, sizeof(u16),\n\t\t\t\t\t&fdb->key.vlan_id))\n\t\tgoto nla_put_failure;\n\n\tif (test_bit(BR_FDB_NOTIFY, &fdb->flags)) {\n\t\tstruct nlattr *nest = nla_nest_start(skb, NDA_FDB_EXT_ATTRS);\n\t\tu8 notify_bits = FDB_NOTIFY_BIT;\n\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\t\tif (test_bit(BR_FDB_NOTIFY_INACTIVE, &fdb->flags))\n\t\t\tnotify_bits |= FDB_NOTIFY_INACTIVE_BIT;\n\n\t\tif (nla_put_u8(skb, NFEA_ACTIVITY_NOTIFY, notify_bits)) {\n\t\t\tnla_nest_cancel(skb, nest);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t fdb_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ndmsg))\n\t\t+ nla_total_size(ETH_ALEN)  \n\t\t+ nla_total_size(sizeof(u32))  \n\t\t+ nla_total_size(sizeof(u32))  \n\t\t+ nla_total_size(sizeof(u16))  \n\t\t+ nla_total_size(sizeof(struct nda_cacheinfo))\n\t\t+ nla_total_size(0)  \n\t\t+ nla_total_size(sizeof(u8));  \n}\n\nstatic void fdb_notify(struct net_bridge *br,\n\t\t       const struct net_bridge_fdb_entry *fdb, int type,\n\t\t       bool swdev_notify)\n{\n\tstruct net *net = dev_net(br->dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tif (swdev_notify)\n\t\tbr_switchdev_fdb_notify(br, fdb, type);\n\n\tskb = nlmsg_new(fdb_nlmsg_size(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = fdb_fill_info(skb, br, fdb, 0, 0, type, 0);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_NEIGH, err);\n}\n\nstatic struct net_bridge_fdb_entry *fdb_find_rcu(struct rhashtable *tbl,\n\t\t\t\t\t\t const unsigned char *addr,\n\t\t\t\t\t\t __u16 vid)\n{\n\tstruct net_bridge_fdb_key key;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey.vlan_id = vid;\n\tmemcpy(key.addr.addr, addr, sizeof(key.addr.addr));\n\n\treturn rhashtable_lookup(tbl, &key, br_fdb_rht_params);\n}\n\n \nstatic struct net_bridge_fdb_entry *br_fdb_find(struct net_bridge *br,\n\t\t\t\t\t\tconst unsigned char *addr,\n\t\t\t\t\t\t__u16 vid)\n{\n\tstruct net_bridge_fdb_entry *fdb;\n\n\tlockdep_assert_held_once(&br->hash_lock);\n\n\trcu_read_lock();\n\tfdb = fdb_find_rcu(&br->fdb_hash_tbl, addr, vid);\n\trcu_read_unlock();\n\n\treturn fdb;\n}\n\nstruct net_device *br_fdb_find_port(const struct net_device *br_dev,\n\t\t\t\t    const unsigned char *addr,\n\t\t\t\t    __u16 vid)\n{\n\tstruct net_bridge_fdb_entry *f;\n\tstruct net_device *dev = NULL;\n\tstruct net_bridge *br;\n\n\tASSERT_RTNL();\n\n\tif (!netif_is_bridge_master(br_dev))\n\t\treturn NULL;\n\n\tbr = netdev_priv(br_dev);\n\trcu_read_lock();\n\tf = br_fdb_find_rcu(br, addr, vid);\n\tif (f && f->dst)\n\t\tdev = f->dst->dev;\n\trcu_read_unlock();\n\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(br_fdb_find_port);\n\nstruct net_bridge_fdb_entry *br_fdb_find_rcu(struct net_bridge *br,\n\t\t\t\t\t     const unsigned char *addr,\n\t\t\t\t\t     __u16 vid)\n{\n\treturn fdb_find_rcu(&br->fdb_hash_tbl, addr, vid);\n}\n\n \nstatic void fdb_add_hw_addr(struct net_bridge *br, const unsigned char *addr)\n{\n\tint err;\n\tstruct net_bridge_port *p;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (!br_promisc_port(p)) {\n\t\t\terr = dev_uc_add(p->dev, addr);\n\t\t\tif (err)\n\t\t\t\tgoto undo;\n\t\t}\n\t}\n\n\treturn;\nundo:\n\tlist_for_each_entry_continue_reverse(p, &br->port_list, list) {\n\t\tif (!br_promisc_port(p))\n\t\t\tdev_uc_del(p->dev, addr);\n\t}\n}\n\n \nstatic void fdb_del_hw_addr(struct net_bridge *br, const unsigned char *addr)\n{\n\tstruct net_bridge_port *p;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (!br_promisc_port(p))\n\t\t\tdev_uc_del(p->dev, addr);\n\t}\n}\n\nstatic void fdb_delete(struct net_bridge *br, struct net_bridge_fdb_entry *f,\n\t\t       bool swdev_notify)\n{\n\ttrace_fdb_delete(br, f);\n\n\tif (test_bit(BR_FDB_STATIC, &f->flags))\n\t\tfdb_del_hw_addr(br, f->key.addr.addr);\n\n\thlist_del_init_rcu(&f->fdb_node);\n\trhashtable_remove_fast(&br->fdb_hash_tbl, &f->rhnode,\n\t\t\t       br_fdb_rht_params);\n\tfdb_notify(br, f, RTM_DELNEIGH, swdev_notify);\n\tcall_rcu(&f->rcu, fdb_rcu_free);\n}\n\n \nstatic void fdb_delete_local(struct net_bridge *br,\n\t\t\t     const struct net_bridge_port *p,\n\t\t\t     struct net_bridge_fdb_entry *f)\n{\n\tconst unsigned char *addr = f->key.addr.addr;\n\tstruct net_bridge_vlan_group *vg;\n\tconst struct net_bridge_vlan *v;\n\tstruct net_bridge_port *op;\n\tu16 vid = f->key.vlan_id;\n\n\t \n\tlist_for_each_entry(op, &br->port_list, list) {\n\t\tvg = nbp_vlan_group(op);\n\t\tif (op != p && ether_addr_equal(op->dev->dev_addr, addr) &&\n\t\t    (!vid || br_vlan_find(vg, vid))) {\n\t\t\tf->dst = op;\n\t\t\tclear_bit(BR_FDB_ADDED_BY_USER, &f->flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvg = br_vlan_group(br);\n\tv = br_vlan_find(vg, vid);\n\t \n\tif (p && ether_addr_equal(br->dev->dev_addr, addr) &&\n\t    (!vid || (v && br_vlan_should_use(v)))) {\n\t\tf->dst = NULL;\n\t\tclear_bit(BR_FDB_ADDED_BY_USER, &f->flags);\n\t\treturn;\n\t}\n\n\tfdb_delete(br, f, true);\n}\n\nvoid br_fdb_find_delete_local(struct net_bridge *br,\n\t\t\t      const struct net_bridge_port *p,\n\t\t\t      const unsigned char *addr, u16 vid)\n{\n\tstruct net_bridge_fdb_entry *f;\n\n\tspin_lock_bh(&br->hash_lock);\n\tf = br_fdb_find(br, addr, vid);\n\tif (f && test_bit(BR_FDB_LOCAL, &f->flags) &&\n\t    !test_bit(BR_FDB_ADDED_BY_USER, &f->flags) && f->dst == p)\n\t\tfdb_delete_local(br, p, f);\n\tspin_unlock_bh(&br->hash_lock);\n}\n\nstatic struct net_bridge_fdb_entry *fdb_create(struct net_bridge *br,\n\t\t\t\t\t       struct net_bridge_port *source,\n\t\t\t\t\t       const unsigned char *addr,\n\t\t\t\t\t       __u16 vid,\n\t\t\t\t\t       unsigned long flags)\n{\n\tstruct net_bridge_fdb_entry *fdb;\n\tint err;\n\n\tfdb = kmem_cache_alloc(br_fdb_cache, GFP_ATOMIC);\n\tif (!fdb)\n\t\treturn NULL;\n\n\tmemcpy(fdb->key.addr.addr, addr, ETH_ALEN);\n\tWRITE_ONCE(fdb->dst, source);\n\tfdb->key.vlan_id = vid;\n\tfdb->flags = flags;\n\tfdb->updated = fdb->used = jiffies;\n\terr = rhashtable_lookup_insert_fast(&br->fdb_hash_tbl, &fdb->rhnode,\n\t\t\t\t\t    br_fdb_rht_params);\n\tif (err) {\n\t\tkmem_cache_free(br_fdb_cache, fdb);\n\t\treturn NULL;\n\t}\n\n\thlist_add_head_rcu(&fdb->fdb_node, &br->fdb_list);\n\n\treturn fdb;\n}\n\nstatic int fdb_add_local(struct net_bridge *br, struct net_bridge_port *source,\n\t\t\t const unsigned char *addr, u16 vid)\n{\n\tstruct net_bridge_fdb_entry *fdb;\n\n\tif (!is_valid_ether_addr(addr))\n\t\treturn -EINVAL;\n\n\tfdb = br_fdb_find(br, addr, vid);\n\tif (fdb) {\n\t\t \n\t\tif (test_bit(BR_FDB_LOCAL, &fdb->flags))\n\t\t\treturn 0;\n\t\tbr_warn(br, \"adding interface %s with same address as a received packet (addr:%pM, vlan:%u)\\n\",\n\t\t\tsource ? source->dev->name : br->dev->name, addr, vid);\n\t\tfdb_delete(br, fdb, true);\n\t}\n\n\tfdb = fdb_create(br, source, addr, vid,\n\t\t\t BIT(BR_FDB_LOCAL) | BIT(BR_FDB_STATIC));\n\tif (!fdb)\n\t\treturn -ENOMEM;\n\n\tfdb_add_hw_addr(br, addr);\n\tfdb_notify(br, fdb, RTM_NEWNEIGH, true);\n\treturn 0;\n}\n\nvoid br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_fdb_entry *f;\n\tstruct net_bridge *br = p->br;\n\tstruct net_bridge_vlan *v;\n\n\tspin_lock_bh(&br->hash_lock);\n\tvg = nbp_vlan_group(p);\n\thlist_for_each_entry(f, &br->fdb_list, fdb_node) {\n\t\tif (f->dst == p && test_bit(BR_FDB_LOCAL, &f->flags) &&\n\t\t    !test_bit(BR_FDB_ADDED_BY_USER, &f->flags)) {\n\t\t\t \n\t\t\tfdb_delete_local(br, p, f);\n\n\t\t\t \n\t\t\tif (!vg || !vg->num_vlans)\n\t\t\t\tgoto insert;\n\t\t}\n\t}\n\ninsert:\n\t \n\tfdb_add_local(br, p, newaddr, 0);\n\n\tif (!vg || !vg->num_vlans)\n\t\tgoto done;\n\n\t \n\tlist_for_each_entry(v, &vg->vlan_list, vlist)\n\t\tfdb_add_local(br, p, newaddr, v->vid);\n\ndone:\n\tspin_unlock_bh(&br->hash_lock);\n}\n\nvoid br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_fdb_entry *f;\n\tstruct net_bridge_vlan *v;\n\n\tspin_lock_bh(&br->hash_lock);\n\n\t \n\tf = br_fdb_find(br, br->dev->dev_addr, 0);\n\tif (f && test_bit(BR_FDB_LOCAL, &f->flags) &&\n\t    !f->dst && !test_bit(BR_FDB_ADDED_BY_USER, &f->flags))\n\t\tfdb_delete_local(br, NULL, f);\n\n\tfdb_add_local(br, NULL, newaddr, 0);\n\tvg = br_vlan_group(br);\n\tif (!vg || !vg->num_vlans)\n\t\tgoto out;\n\t \n\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\tif (!br_vlan_should_use(v))\n\t\t\tcontinue;\n\t\tf = br_fdb_find(br, br->dev->dev_addr, v->vid);\n\t\tif (f && test_bit(BR_FDB_LOCAL, &f->flags) &&\n\t\t    !f->dst && !test_bit(BR_FDB_ADDED_BY_USER, &f->flags))\n\t\t\tfdb_delete_local(br, NULL, f);\n\t\tfdb_add_local(br, NULL, newaddr, v->vid);\n\t}\nout:\n\tspin_unlock_bh(&br->hash_lock);\n}\n\nvoid br_fdb_cleanup(struct work_struct *work)\n{\n\tstruct net_bridge *br = container_of(work, struct net_bridge,\n\t\t\t\t\t     gc_work.work);\n\tstruct net_bridge_fdb_entry *f = NULL;\n\tunsigned long delay = hold_time(br);\n\tunsigned long work_delay = delay;\n\tunsigned long now = jiffies;\n\n\t \n\trcu_read_lock();\n\thlist_for_each_entry_rcu(f, &br->fdb_list, fdb_node) {\n\t\tunsigned long this_timer = f->updated + delay;\n\n\t\tif (test_bit(BR_FDB_STATIC, &f->flags) ||\n\t\t    test_bit(BR_FDB_ADDED_BY_EXT_LEARN, &f->flags)) {\n\t\t\tif (test_bit(BR_FDB_NOTIFY, &f->flags)) {\n\t\t\t\tif (time_after(this_timer, now))\n\t\t\t\t\twork_delay = min(work_delay,\n\t\t\t\t\t\t\t this_timer - now);\n\t\t\t\telse if (!test_and_set_bit(BR_FDB_NOTIFY_INACTIVE,\n\t\t\t\t\t\t\t   &f->flags))\n\t\t\t\t\tfdb_notify(br, f, RTM_NEWNEIGH, false);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (time_after(this_timer, now)) {\n\t\t\twork_delay = min(work_delay, this_timer - now);\n\t\t} else {\n\t\t\tspin_lock_bh(&br->hash_lock);\n\t\t\tif (!hlist_unhashed(&f->fdb_node))\n\t\t\t\tfdb_delete(br, f, true);\n\t\t\tspin_unlock_bh(&br->hash_lock);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t \n\twork_delay = max_t(unsigned long, work_delay, msecs_to_jiffies(10));\n\tmod_delayed_work(system_long_wq, &br->gc_work, work_delay);\n}\n\nstatic bool __fdb_flush_matches(const struct net_bridge *br,\n\t\t\t\tconst struct net_bridge_fdb_entry *f,\n\t\t\t\tconst struct net_bridge_fdb_flush_desc *desc)\n{\n\tconst struct net_bridge_port *dst = READ_ONCE(f->dst);\n\tint port_ifidx = dst ? dst->dev->ifindex : br->dev->ifindex;\n\n\tif (desc->vlan_id && desc->vlan_id != f->key.vlan_id)\n\t\treturn false;\n\tif (desc->port_ifindex && desc->port_ifindex != port_ifidx)\n\t\treturn false;\n\tif (desc->flags_mask && (f->flags & desc->flags_mask) != desc->flags)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nvoid br_fdb_flush(struct net_bridge *br,\n\t\t  const struct net_bridge_fdb_flush_desc *desc)\n{\n\tstruct net_bridge_fdb_entry *f;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(f, &br->fdb_list, fdb_node) {\n\t\tif (!__fdb_flush_matches(br, f, desc))\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&br->hash_lock);\n\t\tif (!hlist_unhashed(&f->fdb_node))\n\t\t\tfdb_delete(br, f, true);\n\t\tspin_unlock_bh(&br->hash_lock);\n\t}\n\trcu_read_unlock();\n}\n\nstatic unsigned long __ndm_state_to_fdb_flags(u16 ndm_state)\n{\n\tunsigned long flags = 0;\n\n\tif (ndm_state & NUD_PERMANENT)\n\t\t__set_bit(BR_FDB_LOCAL, &flags);\n\tif (ndm_state & NUD_NOARP)\n\t\t__set_bit(BR_FDB_STATIC, &flags);\n\n\treturn flags;\n}\n\nstatic unsigned long __ndm_flags_to_fdb_flags(u8 ndm_flags)\n{\n\tunsigned long flags = 0;\n\n\tif (ndm_flags & NTF_USE)\n\t\t__set_bit(BR_FDB_ADDED_BY_USER, &flags);\n\tif (ndm_flags & NTF_EXT_LEARNED)\n\t\t__set_bit(BR_FDB_ADDED_BY_EXT_LEARN, &flags);\n\tif (ndm_flags & NTF_OFFLOADED)\n\t\t__set_bit(BR_FDB_OFFLOADED, &flags);\n\tif (ndm_flags & NTF_STICKY)\n\t\t__set_bit(BR_FDB_STICKY, &flags);\n\n\treturn flags;\n}\n\nstatic int __fdb_flush_validate_ifindex(const struct net_bridge *br,\n\t\t\t\t\tint ifindex,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst struct net_device *dev;\n\n\tdev = __dev_get_by_index(dev_net(br->dev), ifindex);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown flush device ifindex\");\n\t\treturn -ENODEV;\n\t}\n\tif (!netif_is_bridge_master(dev) && !netif_is_bridge_port(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Flush device is not a bridge or bridge port\");\n\t\treturn -EINVAL;\n\t}\n\tif (netif_is_bridge_master(dev) && dev != br->dev) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Flush bridge device does not match target bridge device\");\n\t\treturn -EINVAL;\n\t}\n\tif (netif_is_bridge_port(dev)) {\n\t\tstruct net_bridge_port *p = br_port_get_rtnl(dev);\n\n\t\tif (p->br != br) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Port belongs to a different bridge device\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint br_fdb_delete_bulk(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t       struct net_device *dev, u16 vid,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tu8 ndm_flags = ndm->ndm_flags & ~FDB_FLUSH_IGNORED_NDM_FLAGS;\n\tstruct net_bridge_fdb_flush_desc desc = { .vlan_id = vid };\n\tstruct net_bridge_port *p = NULL;\n\tstruct net_bridge *br;\n\n\tif (netif_is_bridge_master(dev)) {\n\t\tbr = netdev_priv(dev);\n\t} else {\n\t\tp = br_port_get_rtnl(dev);\n\t\tif (!p) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Device is not a bridge port\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbr = p->br;\n\t}\n\n\tif (ndm_flags & ~FDB_FLUSH_ALLOWED_NDM_FLAGS) {\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported fdb flush ndm flag bits set\");\n\t\treturn -EINVAL;\n\t}\n\tif (ndm->ndm_state & ~FDB_FLUSH_ALLOWED_NDM_STATES) {\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported fdb flush ndm state bits set\");\n\t\treturn -EINVAL;\n\t}\n\n\tdesc.flags |= __ndm_state_to_fdb_flags(ndm->ndm_state);\n\tdesc.flags |= __ndm_flags_to_fdb_flags(ndm_flags);\n\tif (tb[NDA_NDM_STATE_MASK]) {\n\t\tu16 ndm_state_mask = nla_get_u16(tb[NDA_NDM_STATE_MASK]);\n\n\t\tdesc.flags_mask |= __ndm_state_to_fdb_flags(ndm_state_mask);\n\t}\n\tif (tb[NDA_NDM_FLAGS_MASK]) {\n\t\tu8 ndm_flags_mask = nla_get_u8(tb[NDA_NDM_FLAGS_MASK]);\n\n\t\tdesc.flags_mask |= __ndm_flags_to_fdb_flags(ndm_flags_mask);\n\t}\n\tif (tb[NDA_IFINDEX]) {\n\t\tint err, ifidx = nla_get_s32(tb[NDA_IFINDEX]);\n\n\t\terr = __fdb_flush_validate_ifindex(br, ifidx, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdesc.port_ifindex = ifidx;\n\t} else if (p) {\n\t\t \n\t\tdesc.port_ifindex = p->dev->ifindex;\n\t}\n\n\tbr_debug(br, \"flushing port ifindex: %d vlan id: %u flags: 0x%lx flags mask: 0x%lx\\n\",\n\t\t desc.port_ifindex, desc.vlan_id, desc.flags, desc.flags_mask);\n\n\tbr_fdb_flush(br, &desc);\n\n\treturn 0;\n}\n\n \nvoid br_fdb_delete_by_port(struct net_bridge *br,\n\t\t\t   const struct net_bridge_port *p,\n\t\t\t   u16 vid,\n\t\t\t   int do_all)\n{\n\tstruct net_bridge_fdb_entry *f;\n\tstruct hlist_node *tmp;\n\n\tspin_lock_bh(&br->hash_lock);\n\thlist_for_each_entry_safe(f, tmp, &br->fdb_list, fdb_node) {\n\t\tif (f->dst != p)\n\t\t\tcontinue;\n\n\t\tif (!do_all)\n\t\t\tif (test_bit(BR_FDB_STATIC, &f->flags) ||\n\t\t\t    (test_bit(BR_FDB_ADDED_BY_EXT_LEARN, &f->flags) &&\n\t\t\t     !test_bit(BR_FDB_OFFLOADED, &f->flags)) ||\n\t\t\t    (vid && f->key.vlan_id != vid))\n\t\t\t\tcontinue;\n\n\t\tif (test_bit(BR_FDB_LOCAL, &f->flags))\n\t\t\tfdb_delete_local(br, p, f);\n\t\telse\n\t\t\tfdb_delete(br, f, true);\n\t}\n\tspin_unlock_bh(&br->hash_lock);\n}\n\n#if IS_ENABLED(CONFIG_ATM_LANE)\n \nint br_fdb_test_addr(struct net_device *dev, unsigned char *addr)\n{\n\tstruct net_bridge_fdb_entry *fdb;\n\tstruct net_bridge_port *port;\n\tint ret;\n\n\trcu_read_lock();\n\tport = br_port_get_rcu(dev);\n\tif (!port)\n\t\tret = 0;\n\telse {\n\t\tconst struct net_bridge_port *dst = NULL;\n\n\t\tfdb = br_fdb_find_rcu(port->br, addr, 0);\n\t\tif (fdb)\n\t\t\tdst = READ_ONCE(fdb->dst);\n\n\t\tret = dst && dst->dev != dev &&\n\t\t      dst->state == BR_STATE_FORWARDING;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n#endif  \n\n \nint br_fdb_fillbuf(struct net_bridge *br, void *buf,\n\t\t   unsigned long maxnum, unsigned long skip)\n{\n\tstruct net_bridge_fdb_entry *f;\n\tstruct __fdb_entry *fe = buf;\n\tint num = 0;\n\n\tmemset(buf, 0, maxnum*sizeof(struct __fdb_entry));\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(f, &br->fdb_list, fdb_node) {\n\t\tif (num >= maxnum)\n\t\t\tbreak;\n\n\t\tif (has_expired(br, f))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!f->dst)\n\t\t\tcontinue;\n\n\t\tif (skip) {\n\t\t\t--skip;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmemcpy(fe->mac_addr, f->key.addr.addr, ETH_ALEN);\n\n\t\t \n\t\tfe->port_no = f->dst->port_no;\n\t\tfe->port_hi = f->dst->port_no >> 8;\n\n\t\tfe->is_local = test_bit(BR_FDB_LOCAL, &f->flags);\n\t\tif (!test_bit(BR_FDB_STATIC, &f->flags))\n\t\t\tfe->ageing_timer_value = jiffies_delta_to_clock_t(jiffies - f->updated);\n\t\t++fe;\n\t\t++num;\n\t}\n\trcu_read_unlock();\n\n\treturn num;\n}\n\n \nint br_fdb_add_local(struct net_bridge *br, struct net_bridge_port *source,\n\t\t     const unsigned char *addr, u16 vid)\n{\n\tint ret;\n\n\tspin_lock_bh(&br->hash_lock);\n\tret = fdb_add_local(br, source, addr, vid);\n\tspin_unlock_bh(&br->hash_lock);\n\treturn ret;\n}\n\n \nstatic bool __fdb_mark_active(struct net_bridge_fdb_entry *fdb)\n{\n\treturn !!(test_bit(BR_FDB_NOTIFY_INACTIVE, &fdb->flags) &&\n\t\t  test_and_clear_bit(BR_FDB_NOTIFY_INACTIVE, &fdb->flags));\n}\n\nvoid br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,\n\t\t   const unsigned char *addr, u16 vid, unsigned long flags)\n{\n\tstruct net_bridge_fdb_entry *fdb;\n\n\t \n\tif (hold_time(br) == 0)\n\t\treturn;\n\n\tfdb = fdb_find_rcu(&br->fdb_hash_tbl, addr, vid);\n\tif (likely(fdb)) {\n\t\t \n\t\tif (unlikely(test_bit(BR_FDB_LOCAL, &fdb->flags))) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tbr_warn(br, \"received packet on %s with own address as source address (addr:%pM, vlan:%u)\\n\",\n\t\t\t\t\tsource->dev->name, addr, vid);\n\t\t} else {\n\t\t\tunsigned long now = jiffies;\n\t\t\tbool fdb_modified = false;\n\n\t\t\tif (now != fdb->updated) {\n\t\t\t\tfdb->updated = now;\n\t\t\t\tfdb_modified = __fdb_mark_active(fdb);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (unlikely(source != READ_ONCE(fdb->dst) &&\n\t\t\t\t     !test_bit(BR_FDB_STICKY, &fdb->flags))) {\n\t\t\t\tbr_switchdev_fdb_notify(br, fdb, RTM_DELNEIGH);\n\t\t\t\tWRITE_ONCE(fdb->dst, source);\n\t\t\t\tfdb_modified = true;\n\t\t\t\t \n\t\t\t\tif (unlikely(test_bit(BR_FDB_ADDED_BY_EXT_LEARN,\n\t\t\t\t\t\t      &fdb->flags)))\n\t\t\t\t\tclear_bit(BR_FDB_ADDED_BY_EXT_LEARN,\n\t\t\t\t\t\t  &fdb->flags);\n\t\t\t\t \n\t\t\t\tif (unlikely(test_bit(BR_FDB_LOCKED, &fdb->flags)))\n\t\t\t\t\tclear_bit(BR_FDB_LOCKED, &fdb->flags);\n\t\t\t}\n\n\t\t\tif (unlikely(test_bit(BR_FDB_ADDED_BY_USER, &flags)))\n\t\t\t\tset_bit(BR_FDB_ADDED_BY_USER, &fdb->flags);\n\t\t\tif (unlikely(fdb_modified)) {\n\t\t\t\ttrace_br_fdb_update(br, source, addr, vid, flags);\n\t\t\t\tfdb_notify(br, fdb, RTM_NEWNEIGH, true);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tspin_lock(&br->hash_lock);\n\t\tfdb = fdb_create(br, source, addr, vid, flags);\n\t\tif (fdb) {\n\t\t\ttrace_br_fdb_update(br, source, addr, vid, flags);\n\t\t\tfdb_notify(br, fdb, RTM_NEWNEIGH, true);\n\t\t}\n\t\t \n\t\tspin_unlock(&br->hash_lock);\n\t}\n}\n\n \nint br_fdb_dump(struct sk_buff *skb,\n\t\tstruct netlink_callback *cb,\n\t\tstruct net_device *dev,\n\t\tstruct net_device *filter_dev,\n\t\tint *idx)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_fdb_entry *f;\n\tint err = 0;\n\n\tif (!netif_is_bridge_master(dev))\n\t\treturn err;\n\n\tif (!filter_dev) {\n\t\terr = ndo_dflt_fdb_dump(skb, cb, dev, NULL, idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(f, &br->fdb_list, fdb_node) {\n\t\tif (*idx < cb->args[2])\n\t\t\tgoto skip;\n\t\tif (filter_dev && (!f->dst || f->dst->dev != filter_dev)) {\n\t\t\tif (filter_dev != dev)\n\t\t\t\tgoto skip;\n\t\t\t \n\t\t\tif (f->dst)\n\t\t\t\tgoto skip;\n\t\t}\n\t\tif (!filter_dev && f->dst)\n\t\t\tgoto skip;\n\n\t\terr = fdb_fill_info(skb, br, f,\n\t\t\t\t    NETLINK_CB(cb->skb).portid,\n\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t    RTM_NEWNEIGH,\n\t\t\t\t    NLM_F_MULTI);\n\t\tif (err < 0)\n\t\t\tbreak;\nskip:\n\t\t*idx += 1;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nint br_fdb_get(struct sk_buff *skb,\n\t       struct nlattr *tb[],\n\t       struct net_device *dev,\n\t       const unsigned char *addr,\n\t       u16 vid, u32 portid, u32 seq,\n\t       struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_fdb_entry *f;\n\tint err = 0;\n\n\trcu_read_lock();\n\tf = br_fdb_find_rcu(br, addr, vid);\n\tif (!f) {\n\t\tNL_SET_ERR_MSG(extack, \"Fdb entry not found\");\n\t\terr = -ENOENT;\n\t\tgoto errout;\n\t}\n\n\terr = fdb_fill_info(skb, br, f, portid, seq,\n\t\t\t    RTM_NEWNEIGH, 0);\nerrout:\n\trcu_read_unlock();\n\treturn err;\n}\n\n \nstatic bool fdb_handle_notify(struct net_bridge_fdb_entry *fdb, u8 notify)\n{\n\tbool modified = false;\n\n\t \n\tif ((notify & FDB_NOTIFY_INACTIVE_BIT) &&\n\t    !test_and_set_bit(BR_FDB_NOTIFY_INACTIVE, &fdb->flags))\n\t\tmodified = true;\n\n\tif ((notify & FDB_NOTIFY_BIT) &&\n\t    !test_and_set_bit(BR_FDB_NOTIFY, &fdb->flags)) {\n\t\t \n\t\tmodified = true;\n\t} else if (!(notify & FDB_NOTIFY_BIT) &&\n\t\t   test_and_clear_bit(BR_FDB_NOTIFY, &fdb->flags)) {\n\t\t \n\t\tclear_bit(BR_FDB_NOTIFY_INACTIVE, &fdb->flags);\n\t\tmodified = true;\n\t}\n\n\treturn modified;\n}\n\n \nstatic int fdb_add_entry(struct net_bridge *br, struct net_bridge_port *source,\n\t\t\t const u8 *addr, struct ndmsg *ndm, u16 flags, u16 vid,\n\t\t\t struct nlattr *nfea_tb[])\n{\n\tbool is_sticky = !!(ndm->ndm_flags & NTF_STICKY);\n\tbool refresh = !nfea_tb[NFEA_DONT_REFRESH];\n\tstruct net_bridge_fdb_entry *fdb;\n\tu16 state = ndm->ndm_state;\n\tbool modified = false;\n\tu8 notify = 0;\n\n\t \n\tif (source && !(state & NUD_PERMANENT) && !(state & NUD_NOARP) &&\n\t    !(source->state == BR_STATE_LEARNING ||\n\t      source->state == BR_STATE_FORWARDING))\n\t\treturn -EPERM;\n\n\tif (!source && !(state & NUD_PERMANENT)) {\n\t\tpr_info(\"bridge: RTM_NEWNEIGH %s without NUD_PERMANENT\\n\",\n\t\t\tbr->dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_sticky && (state & NUD_PERMANENT))\n\t\treturn -EINVAL;\n\n\tif (nfea_tb[NFEA_ACTIVITY_NOTIFY]) {\n\t\tnotify = nla_get_u8(nfea_tb[NFEA_ACTIVITY_NOTIFY]);\n\t\tif ((notify & ~BR_FDB_NOTIFY_SETTABLE_BITS) ||\n\t\t    (notify & BR_FDB_NOTIFY_SETTABLE_BITS) == FDB_NOTIFY_INACTIVE_BIT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfdb = br_fdb_find(br, addr, vid);\n\tif (fdb == NULL) {\n\t\tif (!(flags & NLM_F_CREATE))\n\t\t\treturn -ENOENT;\n\n\t\tfdb = fdb_create(br, source, addr, vid, 0);\n\t\tif (!fdb)\n\t\t\treturn -ENOMEM;\n\n\t\tmodified = true;\n\t} else {\n\t\tif (flags & NLM_F_EXCL)\n\t\t\treturn -EEXIST;\n\n\t\tif (READ_ONCE(fdb->dst) != source) {\n\t\t\tWRITE_ONCE(fdb->dst, source);\n\t\t\tmodified = true;\n\t\t}\n\t}\n\n\tif (fdb_to_nud(br, fdb) != state) {\n\t\tif (state & NUD_PERMANENT) {\n\t\t\tset_bit(BR_FDB_LOCAL, &fdb->flags);\n\t\t\tif (!test_and_set_bit(BR_FDB_STATIC, &fdb->flags))\n\t\t\t\tfdb_add_hw_addr(br, addr);\n\t\t} else if (state & NUD_NOARP) {\n\t\t\tclear_bit(BR_FDB_LOCAL, &fdb->flags);\n\t\t\tif (!test_and_set_bit(BR_FDB_STATIC, &fdb->flags))\n\t\t\t\tfdb_add_hw_addr(br, addr);\n\t\t} else {\n\t\t\tclear_bit(BR_FDB_LOCAL, &fdb->flags);\n\t\t\tif (test_and_clear_bit(BR_FDB_STATIC, &fdb->flags))\n\t\t\t\tfdb_del_hw_addr(br, addr);\n\t\t}\n\n\t\tmodified = true;\n\t}\n\n\tif (is_sticky != test_bit(BR_FDB_STICKY, &fdb->flags)) {\n\t\tchange_bit(BR_FDB_STICKY, &fdb->flags);\n\t\tmodified = true;\n\t}\n\n\tif (test_and_clear_bit(BR_FDB_LOCKED, &fdb->flags))\n\t\tmodified = true;\n\n\tif (fdb_handle_notify(fdb, notify))\n\t\tmodified = true;\n\n\tset_bit(BR_FDB_ADDED_BY_USER, &fdb->flags);\n\n\tfdb->used = jiffies;\n\tif (modified) {\n\t\tif (refresh)\n\t\t\tfdb->updated = jiffies;\n\t\tfdb_notify(br, fdb, RTM_NEWNEIGH, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int __br_fdb_add(struct ndmsg *ndm, struct net_bridge *br,\n\t\t\tstruct net_bridge_port *p, const unsigned char *addr,\n\t\t\tu16 nlh_flags, u16 vid, struct nlattr *nfea_tb[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint err = 0;\n\n\tif (ndm->ndm_flags & NTF_USE) {\n\t\tif (!p) {\n\t\t\tpr_info(\"bridge: RTM_NEWNEIGH %s with NTF_USE is not supported\\n\",\n\t\t\t\tbr->dev->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!nbp_state_should_learn(p))\n\t\t\treturn 0;\n\n\t\tlocal_bh_disable();\n\t\trcu_read_lock();\n\t\tbr_fdb_update(br, p, addr, vid, BIT(BR_FDB_ADDED_BY_USER));\n\t\trcu_read_unlock();\n\t\tlocal_bh_enable();\n\t} else if (ndm->ndm_flags & NTF_EXT_LEARNED) {\n\t\tif (!p && !(ndm->ndm_state & NUD_PERMANENT)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"FDB entry towards bridge must be permanent\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = br_fdb_external_learn_add(br, p, addr, vid, false, true);\n\t} else {\n\t\tspin_lock_bh(&br->hash_lock);\n\t\terr = fdb_add_entry(br, p, addr, ndm, nlh_flags, vid, nfea_tb);\n\t\tspin_unlock_bh(&br->hash_lock);\n\t}\n\n\treturn err;\n}\n\nstatic const struct nla_policy br_nda_fdb_pol[NFEA_MAX + 1] = {\n\t[NFEA_ACTIVITY_NOTIFY]\t= { .type = NLA_U8 },\n\t[NFEA_DONT_REFRESH]\t= { .type = NLA_FLAG },\n};\n\n \nint br_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\n\t       struct net_device *dev,\n\t       const unsigned char *addr, u16 vid, u16 nlh_flags,\n\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *nfea_tb[NFEA_MAX + 1], *attr;\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_port *p = NULL;\n\tstruct net_bridge_vlan *v;\n\tstruct net_bridge *br = NULL;\n\tu32 ext_flags = 0;\n\tint err = 0;\n\n\ttrace_br_fdb_add(ndm, dev, addr, vid, nlh_flags);\n\n\tif (!(ndm->ndm_state & (NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE))) {\n\t\tpr_info(\"bridge: RTM_NEWNEIGH with invalid state %#x\\n\", ndm->ndm_state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_zero_ether_addr(addr)) {\n\t\tpr_info(\"bridge: RTM_NEWNEIGH with invalid ether address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (netif_is_bridge_master(dev)) {\n\t\tbr = netdev_priv(dev);\n\t\tvg = br_vlan_group(br);\n\t} else {\n\t\tp = br_port_get_rtnl(dev);\n\t\tif (!p) {\n\t\t\tpr_info(\"bridge: RTM_NEWNEIGH %s not a bridge port\\n\",\n\t\t\t\tdev->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbr = p->br;\n\t\tvg = nbp_vlan_group(p);\n\t}\n\n\tif (tb[NDA_FLAGS_EXT])\n\t\text_flags = nla_get_u32(tb[NDA_FLAGS_EXT]);\n\n\tif (ext_flags & NTF_EXT_LOCKED) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot add FDB entry with \\\"locked\\\" flag set\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NDA_FDB_EXT_ATTRS]) {\n\t\tattr = tb[NDA_FDB_EXT_ATTRS];\n\t\terr = nla_parse_nested(nfea_tb, NFEA_MAX, attr,\n\t\t\t\t       br_nda_fdb_pol, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tmemset(nfea_tb, 0, sizeof(struct nlattr *) * (NFEA_MAX + 1));\n\t}\n\n\tif (vid) {\n\t\tv = br_vlan_find(vg, vid);\n\t\tif (!v || !br_vlan_should_use(v)) {\n\t\t\tpr_info(\"bridge: RTM_NEWNEIGH with unconfigured vlan %d on %s\\n\", vid, dev->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\terr = __br_fdb_add(ndm, br, p, addr, nlh_flags, vid, nfea_tb,\n\t\t\t\t   extack);\n\t} else {\n\t\terr = __br_fdb_add(ndm, br, p, addr, nlh_flags, 0, nfea_tb,\n\t\t\t\t   extack);\n\t\tif (err || !vg || !vg->num_vlans)\n\t\t\tgoto out;\n\n\t\t \n\t\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\t\tif (!br_vlan_should_use(v))\n\t\t\t\tcontinue;\n\t\t\terr = __br_fdb_add(ndm, br, p, addr, nlh_flags, v->vid,\n\t\t\t\t\t   nfea_tb, extack);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int fdb_delete_by_addr_and_port(struct net_bridge *br,\n\t\t\t\t       const struct net_bridge_port *p,\n\t\t\t\t       const u8 *addr, u16 vlan)\n{\n\tstruct net_bridge_fdb_entry *fdb;\n\n\tfdb = br_fdb_find(br, addr, vlan);\n\tif (!fdb || READ_ONCE(fdb->dst) != p)\n\t\treturn -ENOENT;\n\n\tfdb_delete(br, fdb, true);\n\n\treturn 0;\n}\n\nstatic int __br_fdb_delete(struct net_bridge *br,\n\t\t\t   const struct net_bridge_port *p,\n\t\t\t   const unsigned char *addr, u16 vid)\n{\n\tint err;\n\n\tspin_lock_bh(&br->hash_lock);\n\terr = fdb_delete_by_addr_and_port(br, p, addr, vid);\n\tspin_unlock_bh(&br->hash_lock);\n\n\treturn err;\n}\n\n \nint br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t  struct net_device *dev,\n\t\t  const unsigned char *addr, u16 vid,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_port *p = NULL;\n\tstruct net_bridge_vlan *v;\n\tstruct net_bridge *br;\n\tint err;\n\n\tif (netif_is_bridge_master(dev)) {\n\t\tbr = netdev_priv(dev);\n\t\tvg = br_vlan_group(br);\n\t} else {\n\t\tp = br_port_get_rtnl(dev);\n\t\tif (!p) {\n\t\t\tpr_info(\"bridge: RTM_DELNEIGH %s not a bridge port\\n\",\n\t\t\t\tdev->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvg = nbp_vlan_group(p);\n\t\tbr = p->br;\n\t}\n\n\tif (vid) {\n\t\tv = br_vlan_find(vg, vid);\n\t\tif (!v) {\n\t\t\tpr_info(\"bridge: RTM_DELNEIGH with unconfigured vlan %d on %s\\n\", vid, dev->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = __br_fdb_delete(br, p, addr, vid);\n\t} else {\n\t\terr = -ENOENT;\n\t\terr &= __br_fdb_delete(br, p, addr, 0);\n\t\tif (!vg || !vg->num_vlans)\n\t\t\treturn err;\n\n\t\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\t\tif (!br_vlan_should_use(v))\n\t\t\t\tcontinue;\n\t\t\terr &= __br_fdb_delete(br, p, addr, v->vid);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p)\n{\n\tstruct net_bridge_fdb_entry *f, *tmp;\n\tint err = 0;\n\n\tASSERT_RTNL();\n\n\t \n\trcu_read_lock();\n\thlist_for_each_entry_rcu(f, &br->fdb_list, fdb_node) {\n\t\t \n\t\tif (!test_bit(BR_FDB_STATIC, &f->flags))\n\t\t\tcontinue;\n\t\terr = dev_uc_add(p->dev, f->key.addr.addr);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\ndone:\n\trcu_read_unlock();\n\n\treturn err;\n\nrollback:\n\thlist_for_each_entry_rcu(tmp, &br->fdb_list, fdb_node) {\n\t\t \n\t\tif (!test_bit(BR_FDB_STATIC, &tmp->flags))\n\t\t\tcontinue;\n\t\tif (tmp == f)\n\t\t\tbreak;\n\t\tdev_uc_del(p->dev, tmp->key.addr.addr);\n\t}\n\n\tgoto done;\n}\n\nvoid br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p)\n{\n\tstruct net_bridge_fdb_entry *f;\n\n\tASSERT_RTNL();\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(f, &br->fdb_list, fdb_node) {\n\t\t \n\t\tif (!test_bit(BR_FDB_STATIC, &f->flags))\n\t\t\tcontinue;\n\n\t\tdev_uc_del(p->dev, f->key.addr.addr);\n\t}\n\trcu_read_unlock();\n}\n\nint br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,\n\t\t\t      const unsigned char *addr, u16 vid, bool locked,\n\t\t\t      bool swdev_notify)\n{\n\tstruct net_bridge_fdb_entry *fdb;\n\tbool modified = false;\n\tint err = 0;\n\n\ttrace_br_fdb_external_learn_add(br, p, addr, vid);\n\n\tif (locked && (!p || !(p->flags & BR_PORT_MAB)))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&br->hash_lock);\n\n\tfdb = br_fdb_find(br, addr, vid);\n\tif (!fdb) {\n\t\tunsigned long flags = BIT(BR_FDB_ADDED_BY_EXT_LEARN);\n\n\t\tif (swdev_notify)\n\t\t\tflags |= BIT(BR_FDB_ADDED_BY_USER);\n\n\t\tif (!p)\n\t\t\tflags |= BIT(BR_FDB_LOCAL);\n\n\t\tif (locked)\n\t\t\tflags |= BIT(BR_FDB_LOCKED);\n\n\t\tfdb = fdb_create(br, p, addr, vid, flags);\n\t\tif (!fdb) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tfdb_notify(br, fdb, RTM_NEWNEIGH, swdev_notify);\n\t} else {\n\t\tif (locked &&\n\t\t    (!test_bit(BR_FDB_LOCKED, &fdb->flags) ||\n\t\t     READ_ONCE(fdb->dst) != p)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tfdb->updated = jiffies;\n\n\t\tif (READ_ONCE(fdb->dst) != p) {\n\t\t\tWRITE_ONCE(fdb->dst, p);\n\t\t\tmodified = true;\n\t\t}\n\n\t\tif (test_bit(BR_FDB_ADDED_BY_EXT_LEARN, &fdb->flags)) {\n\t\t\t \n\t\t\tfdb->used = jiffies;\n\t\t} else if (!test_bit(BR_FDB_ADDED_BY_USER, &fdb->flags)) {\n\t\t\t \n\t\t\tset_bit(BR_FDB_ADDED_BY_EXT_LEARN, &fdb->flags);\n\t\t\tmodified = true;\n\t\t}\n\n\t\tif (locked != test_bit(BR_FDB_LOCKED, &fdb->flags)) {\n\t\t\tchange_bit(BR_FDB_LOCKED, &fdb->flags);\n\t\t\tmodified = true;\n\t\t}\n\n\t\tif (swdev_notify)\n\t\t\tset_bit(BR_FDB_ADDED_BY_USER, &fdb->flags);\n\n\t\tif (!p)\n\t\t\tset_bit(BR_FDB_LOCAL, &fdb->flags);\n\n\t\tif (modified)\n\t\t\tfdb_notify(br, fdb, RTM_NEWNEIGH, swdev_notify);\n\t}\n\nerr_unlock:\n\tspin_unlock_bh(&br->hash_lock);\n\n\treturn err;\n}\n\nint br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,\n\t\t\t      const unsigned char *addr, u16 vid,\n\t\t\t      bool swdev_notify)\n{\n\tstruct net_bridge_fdb_entry *fdb;\n\tint err = 0;\n\n\tspin_lock_bh(&br->hash_lock);\n\n\tfdb = br_fdb_find(br, addr, vid);\n\tif (fdb && test_bit(BR_FDB_ADDED_BY_EXT_LEARN, &fdb->flags))\n\t\tfdb_delete(br, fdb, swdev_notify);\n\telse\n\t\terr = -ENOENT;\n\n\tspin_unlock_bh(&br->hash_lock);\n\n\treturn err;\n}\n\nvoid br_fdb_offloaded_set(struct net_bridge *br, struct net_bridge_port *p,\n\t\t\t  const unsigned char *addr, u16 vid, bool offloaded)\n{\n\tstruct net_bridge_fdb_entry *fdb;\n\n\tspin_lock_bh(&br->hash_lock);\n\n\tfdb = br_fdb_find(br, addr, vid);\n\tif (fdb && offloaded != test_bit(BR_FDB_OFFLOADED, &fdb->flags))\n\t\tchange_bit(BR_FDB_OFFLOADED, &fdb->flags);\n\n\tspin_unlock_bh(&br->hash_lock);\n}\n\nvoid br_fdb_clear_offload(const struct net_device *dev, u16 vid)\n{\n\tstruct net_bridge_fdb_entry *f;\n\tstruct net_bridge_port *p;\n\n\tASSERT_RTNL();\n\n\tp = br_port_get_rtnl(dev);\n\tif (!p)\n\t\treturn;\n\n\tspin_lock_bh(&p->br->hash_lock);\n\thlist_for_each_entry(f, &p->br->fdb_list, fdb_node) {\n\t\tif (f->dst == p && f->key.vlan_id == vid)\n\t\t\tclear_bit(BR_FDB_OFFLOADED, &f->flags);\n\t}\n\tspin_unlock_bh(&p->br->hash_lock);\n}\nEXPORT_SYMBOL_GPL(br_fdb_clear_offload);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}