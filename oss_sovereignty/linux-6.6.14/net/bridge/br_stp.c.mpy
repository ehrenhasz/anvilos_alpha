{
  "module_name": "br_stp.c",
  "hash_id": "ce4e73ce2ca043a64609a83cc6d93bcb39f9fbd68c0a9b76098e1f954857333e",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_stp.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <net/switchdev.h>\n\n#include \"br_private.h\"\n#include \"br_private_stp.h\"\n\n \n#define MESSAGE_AGE_INCR\t((HZ / 256) + 1)\n\nstatic const char *const br_port_state_names[] = {\n\t[BR_STATE_DISABLED] = \"disabled\",\n\t[BR_STATE_LISTENING] = \"listening\",\n\t[BR_STATE_LEARNING] = \"learning\",\n\t[BR_STATE_FORWARDING] = \"forwarding\",\n\t[BR_STATE_BLOCKING] = \"blocking\",\n};\n\nvoid br_set_state(struct net_bridge_port *p, unsigned int state)\n{\n\tstruct switchdev_attr attr = {\n\t\t.orig_dev = p->dev,\n\t\t.id = SWITCHDEV_ATTR_ID_PORT_STP_STATE,\n\t\t.flags = SWITCHDEV_F_DEFER,\n\t\t.u.stp_state = state,\n\t};\n\tint err;\n\n\t \n\tif (p->flags & BR_MRP_AWARE)\n\t\treturn;\n\n\tp->state = state;\n\tif (br_opt_get(p->br, BROPT_MST_ENABLED)) {\n\t\terr = br_mst_set_state(p, 0, state, NULL);\n\t\tif (err)\n\t\t\tbr_warn(p->br, \"error setting MST state on port %u(%s)\\n\",\n\t\t\t\tp->port_no, netdev_name(p->dev));\n\t}\n\terr = switchdev_port_attr_set(p->dev, &attr, NULL);\n\tif (err && err != -EOPNOTSUPP)\n\t\tbr_warn(p->br, \"error setting offload STP state on port %u(%s)\\n\",\n\t\t\t\t(unsigned int) p->port_no, p->dev->name);\n\telse\n\t\tbr_info(p->br, \"port %u(%s) entered %s state\\n\",\n\t\t\t\t(unsigned int) p->port_no, p->dev->name,\n\t\t\t\tbr_port_state_names[p->state]);\n\n\tif (p->br->stp_enabled == BR_KERNEL_STP) {\n\t\tswitch (p->state) {\n\t\tcase BR_STATE_BLOCKING:\n\t\t\tp->stp_xstats.transition_blk++;\n\t\t\tbreak;\n\t\tcase BR_STATE_FORWARDING:\n\t\t\tp->stp_xstats.transition_fwd++;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nu8 br_port_get_stp_state(const struct net_device *dev)\n{\n\tstruct net_bridge_port *p;\n\n\tASSERT_RTNL();\n\n\tp = br_port_get_rtnl(dev);\n\tif (!p)\n\t\treturn BR_STATE_DISABLED;\n\n\treturn p->state;\n}\nEXPORT_SYMBOL_GPL(br_port_get_stp_state);\n\n \nstruct net_bridge_port *br_get_port(struct net_bridge *br, u16 port_no)\n{\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry_rcu(p, &br->port_list, list,\n\t\t\t\tlockdep_is_held(&br->lock)) {\n\t\tif (p->port_no == port_no)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int br_should_become_root_port(const struct net_bridge_port *p,\n\t\t\t\t      u16 root_port)\n{\n\tstruct net_bridge *br;\n\tstruct net_bridge_port *rp;\n\tint t;\n\n\tbr = p->br;\n\tif (p->state == BR_STATE_DISABLED ||\n\t    br_is_designated_port(p))\n\t\treturn 0;\n\n\tif (memcmp(&br->bridge_id, &p->designated_root, 8) <= 0)\n\t\treturn 0;\n\n\tif (!root_port)\n\t\treturn 1;\n\n\trp = br_get_port(br, root_port);\n\n\tt = memcmp(&p->designated_root, &rp->designated_root, 8);\n\tif (t < 0)\n\t\treturn 1;\n\telse if (t > 0)\n\t\treturn 0;\n\n\tif (p->designated_cost + p->path_cost <\n\t    rp->designated_cost + rp->path_cost)\n\t\treturn 1;\n\telse if (p->designated_cost + p->path_cost >\n\t\t rp->designated_cost + rp->path_cost)\n\t\treturn 0;\n\n\tt = memcmp(&p->designated_bridge, &rp->designated_bridge, 8);\n\tif (t < 0)\n\t\treturn 1;\n\telse if (t > 0)\n\t\treturn 0;\n\n\tif (p->designated_port < rp->designated_port)\n\t\treturn 1;\n\telse if (p->designated_port > rp->designated_port)\n\t\treturn 0;\n\n\tif (p->port_id < rp->port_id)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void br_root_port_block(const struct net_bridge *br,\n\t\t\t       struct net_bridge_port *p)\n{\n\n\tbr_notice(br, \"port %u(%s) tried to become root port (blocked)\",\n\t\t  (unsigned int) p->port_no, p->dev->name);\n\n\tbr_set_state(p, BR_STATE_LISTENING);\n\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\n\tif (br->forward_delay > 0)\n\t\tmod_timer(&p->forward_delay_timer, jiffies + br->forward_delay);\n}\n\n \nstatic void br_root_selection(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\tu16 root_port = 0;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (!br_should_become_root_port(p, root_port))\n\t\t\tcontinue;\n\n\t\tif (p->flags & BR_ROOT_BLOCK)\n\t\t\tbr_root_port_block(br, p);\n\t\telse\n\t\t\troot_port = p->port_no;\n\t}\n\n\tbr->root_port = root_port;\n\n\tif (!root_port) {\n\t\tbr->designated_root = br->bridge_id;\n\t\tbr->root_path_cost = 0;\n\t} else {\n\t\tp = br_get_port(br, root_port);\n\t\tbr->designated_root = p->designated_root;\n\t\tbr->root_path_cost = p->designated_cost + p->path_cost;\n\t}\n}\n\n \nvoid br_become_root_bridge(struct net_bridge *br)\n{\n\tbr->max_age = br->bridge_max_age;\n\tbr->hello_time = br->bridge_hello_time;\n\tbr->forward_delay = br->bridge_forward_delay;\n\tbr_topology_change_detection(br);\n\tdel_timer(&br->tcn_timer);\n\n\tif (br->dev->flags & IFF_UP) {\n\t\tbr_config_bpdu_generation(br);\n\t\tmod_timer(&br->hello_timer, jiffies + br->hello_time);\n\t}\n}\n\n \nvoid br_transmit_config(struct net_bridge_port *p)\n{\n\tstruct br_config_bpdu bpdu;\n\tstruct net_bridge *br;\n\n\tif (timer_pending(&p->hold_timer)) {\n\t\tp->config_pending = 1;\n\t\treturn;\n\t}\n\n\tbr = p->br;\n\n\tbpdu.topology_change = br->topology_change;\n\tbpdu.topology_change_ack = p->topology_change_ack;\n\tbpdu.root = br->designated_root;\n\tbpdu.root_path_cost = br->root_path_cost;\n\tbpdu.bridge_id = br->bridge_id;\n\tbpdu.port_id = p->port_id;\n\tif (br_is_root_bridge(br))\n\t\tbpdu.message_age = 0;\n\telse {\n\t\tstruct net_bridge_port *root\n\t\t\t= br_get_port(br, br->root_port);\n\t\tbpdu.message_age = (jiffies - root->designated_age)\n\t\t\t+ MESSAGE_AGE_INCR;\n\t}\n\tbpdu.max_age = br->max_age;\n\tbpdu.hello_time = br->hello_time;\n\tbpdu.forward_delay = br->forward_delay;\n\n\tif (bpdu.message_age < br->max_age) {\n\t\tbr_send_config_bpdu(p, &bpdu);\n\t\tp->topology_change_ack = 0;\n\t\tp->config_pending = 0;\n\t\tif (p->br->stp_enabled == BR_KERNEL_STP)\n\t\t\tmod_timer(&p->hold_timer,\n\t\t\t\t  round_jiffies(jiffies + BR_HOLD_TIME));\n\t}\n}\n\n \nstatic void br_record_config_information(struct net_bridge_port *p,\n\t\t\t\t\t const struct br_config_bpdu *bpdu)\n{\n\tp->designated_root = bpdu->root;\n\tp->designated_cost = bpdu->root_path_cost;\n\tp->designated_bridge = bpdu->bridge_id;\n\tp->designated_port = bpdu->port_id;\n\tp->designated_age = jiffies - bpdu->message_age;\n\n\tmod_timer(&p->message_age_timer, jiffies\n\t\t  + (bpdu->max_age - bpdu->message_age));\n}\n\n \nstatic void br_record_config_timeout_values(struct net_bridge *br,\n\t\t\t\t\t    const struct br_config_bpdu *bpdu)\n{\n\tbr->max_age = bpdu->max_age;\n\tbr->hello_time = bpdu->hello_time;\n\tbr->forward_delay = bpdu->forward_delay;\n\t__br_set_topology_change(br, bpdu->topology_change);\n}\n\n \nvoid br_transmit_tcn(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\n\tp = br_get_port(br, br->root_port);\n\tif (p)\n\t\tbr_send_tcn_bpdu(p);\n\telse\n\t\tbr_notice(br, \"root port %u not found for topology notice\\n\",\n\t\t\t  br->root_port);\n}\n\n \nstatic int br_should_become_designated_port(const struct net_bridge_port *p)\n{\n\tstruct net_bridge *br;\n\tint t;\n\n\tbr = p->br;\n\tif (br_is_designated_port(p))\n\t\treturn 1;\n\n\tif (memcmp(&p->designated_root, &br->designated_root, 8))\n\t\treturn 1;\n\n\tif (br->root_path_cost < p->designated_cost)\n\t\treturn 1;\n\telse if (br->root_path_cost > p->designated_cost)\n\t\treturn 0;\n\n\tt = memcmp(&br->bridge_id, &p->designated_bridge, 8);\n\tif (t < 0)\n\t\treturn 1;\n\telse if (t > 0)\n\t\treturn 0;\n\n\tif (p->port_id < p->designated_port)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void br_designated_port_selection(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->state != BR_STATE_DISABLED &&\n\t\t    br_should_become_designated_port(p))\n\t\t\tbr_become_designated_port(p);\n\n\t}\n}\n\n \nstatic int br_supersedes_port_info(const struct net_bridge_port *p,\n\t\t\t\t   const struct br_config_bpdu *bpdu)\n{\n\tint t;\n\n\tt = memcmp(&bpdu->root, &p->designated_root, 8);\n\tif (t < 0)\n\t\treturn 1;\n\telse if (t > 0)\n\t\treturn 0;\n\n\tif (bpdu->root_path_cost < p->designated_cost)\n\t\treturn 1;\n\telse if (bpdu->root_path_cost > p->designated_cost)\n\t\treturn 0;\n\n\tt = memcmp(&bpdu->bridge_id, &p->designated_bridge, 8);\n\tif (t < 0)\n\t\treturn 1;\n\telse if (t > 0)\n\t\treturn 0;\n\n\tif (memcmp(&bpdu->bridge_id, &p->br->bridge_id, 8))\n\t\treturn 1;\n\n\tif (bpdu->port_id <= p->designated_port)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void br_topology_change_acknowledged(struct net_bridge *br)\n{\n\tbr->topology_change_detected = 0;\n\tdel_timer(&br->tcn_timer);\n}\n\n \nvoid br_topology_change_detection(struct net_bridge *br)\n{\n\tint isroot = br_is_root_bridge(br);\n\n\tif (br->stp_enabled != BR_KERNEL_STP)\n\t\treturn;\n\n\tbr_info(br, \"topology change detected, %s\\n\",\n\t\tisroot ? \"propagating\" : \"sending tcn bpdu\");\n\n\tif (isroot) {\n\t\t__br_set_topology_change(br, 1);\n\t\tmod_timer(&br->topology_change_timer, jiffies\n\t\t\t  + br->bridge_forward_delay + br->bridge_max_age);\n\t} else if (!br->topology_change_detected) {\n\t\tbr_transmit_tcn(br);\n\t\tmod_timer(&br->tcn_timer, jiffies + br->bridge_hello_time);\n\t}\n\n\tbr->topology_change_detected = 1;\n}\n\n \nvoid br_config_bpdu_generation(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->state != BR_STATE_DISABLED &&\n\t\t    br_is_designated_port(p))\n\t\t\tbr_transmit_config(p);\n\t}\n}\n\n \nstatic void br_reply(struct net_bridge_port *p)\n{\n\tbr_transmit_config(p);\n}\n\n \nvoid br_configuration_update(struct net_bridge *br)\n{\n\tbr_root_selection(br);\n\tbr_designated_port_selection(br);\n}\n\n \nvoid br_become_designated_port(struct net_bridge_port *p)\n{\n\tstruct net_bridge *br;\n\n\tbr = p->br;\n\tp->designated_root = br->designated_root;\n\tp->designated_cost = br->root_path_cost;\n\tp->designated_bridge = br->bridge_id;\n\tp->designated_port = p->port_id;\n}\n\n\n \nstatic void br_make_blocking(struct net_bridge_port *p)\n{\n\tif (p->state != BR_STATE_DISABLED &&\n\t    p->state != BR_STATE_BLOCKING) {\n\t\tif (p->state == BR_STATE_FORWARDING ||\n\t\t    p->state == BR_STATE_LEARNING)\n\t\t\tbr_topology_change_detection(p->br);\n\n\t\tbr_set_state(p, BR_STATE_BLOCKING);\n\t\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\n\t\tdel_timer(&p->forward_delay_timer);\n\t}\n}\n\n \nstatic void br_make_forwarding(struct net_bridge_port *p)\n{\n\tstruct net_bridge *br = p->br;\n\n\tif (p->state != BR_STATE_BLOCKING)\n\t\treturn;\n\n\tif (br->stp_enabled == BR_NO_STP || br->forward_delay == 0) {\n\t\tbr_set_state(p, BR_STATE_FORWARDING);\n\t\tbr_topology_change_detection(br);\n\t\tdel_timer(&p->forward_delay_timer);\n\t} else if (br->stp_enabled == BR_KERNEL_STP)\n\t\tbr_set_state(p, BR_STATE_LISTENING);\n\telse\n\t\tbr_set_state(p, BR_STATE_LEARNING);\n\n\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\n\tif (br->forward_delay != 0)\n\t\tmod_timer(&p->forward_delay_timer, jiffies + br->forward_delay);\n}\n\n \nvoid br_port_state_selection(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\tunsigned int liveports = 0;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->state == BR_STATE_DISABLED)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (br->stp_enabled != BR_USER_STP) {\n\t\t\tif (p->port_no == br->root_port) {\n\t\t\t\tp->config_pending = 0;\n\t\t\t\tp->topology_change_ack = 0;\n\t\t\t\tbr_make_forwarding(p);\n\t\t\t} else if (br_is_designated_port(p)) {\n\t\t\t\tdel_timer(&p->message_age_timer);\n\t\t\t\tbr_make_forwarding(p);\n\t\t\t} else {\n\t\t\t\tp->config_pending = 0;\n\t\t\t\tp->topology_change_ack = 0;\n\t\t\t\tbr_make_blocking(p);\n\t\t\t}\n\t\t}\n\n\t\tif (p->state != BR_STATE_BLOCKING)\n\t\t\tbr_multicast_enable_port(p);\n\t\t \n\t\tif (p->state == BR_STATE_FORWARDING)\n\t\t\t++liveports;\n\t}\n\n\tif (liveports == 0)\n\t\tnetif_carrier_off(br->dev);\n\telse\n\t\tnetif_carrier_on(br->dev);\n}\n\n \nstatic void br_topology_change_acknowledge(struct net_bridge_port *p)\n{\n\tp->topology_change_ack = 1;\n\tbr_transmit_config(p);\n}\n\n \nvoid br_received_config_bpdu(struct net_bridge_port *p,\n\t\t\t     const struct br_config_bpdu *bpdu)\n{\n\tstruct net_bridge *br;\n\tint was_root;\n\n\tp->stp_xstats.rx_bpdu++;\n\n\tbr = p->br;\n\twas_root = br_is_root_bridge(br);\n\n\tif (br_supersedes_port_info(p, bpdu)) {\n\t\tbr_record_config_information(p, bpdu);\n\t\tbr_configuration_update(br);\n\t\tbr_port_state_selection(br);\n\n\t\tif (!br_is_root_bridge(br) && was_root) {\n\t\t\tdel_timer(&br->hello_timer);\n\t\t\tif (br->topology_change_detected) {\n\t\t\t\tdel_timer(&br->topology_change_timer);\n\t\t\t\tbr_transmit_tcn(br);\n\n\t\t\t\tmod_timer(&br->tcn_timer,\n\t\t\t\t\t  jiffies + br->bridge_hello_time);\n\t\t\t}\n\t\t}\n\n\t\tif (p->port_no == br->root_port) {\n\t\t\tbr_record_config_timeout_values(br, bpdu);\n\t\t\tbr_config_bpdu_generation(br);\n\t\t\tif (bpdu->topology_change_ack)\n\t\t\t\tbr_topology_change_acknowledged(br);\n\t\t}\n\t} else if (br_is_designated_port(p)) {\n\t\tbr_reply(p);\n\t}\n}\n\n \nvoid br_received_tcn_bpdu(struct net_bridge_port *p)\n{\n\tp->stp_xstats.rx_tcn++;\n\n\tif (br_is_designated_port(p)) {\n\t\tbr_info(p->br, \"port %u(%s) received tcn bpdu\\n\",\n\t\t\t(unsigned int) p->port_no, p->dev->name);\n\n\t\tbr_topology_change_detection(p->br);\n\t\tbr_topology_change_acknowledge(p);\n\t}\n}\n\n \nint br_set_hello_time(struct net_bridge *br, unsigned long val)\n{\n\tunsigned long t = clock_t_to_jiffies(val);\n\n\tif (t < BR_MIN_HELLO_TIME || t > BR_MAX_HELLO_TIME)\n\t\treturn -ERANGE;\n\n\tspin_lock_bh(&br->lock);\n\tbr->bridge_hello_time = t;\n\tif (br_is_root_bridge(br))\n\t\tbr->hello_time = br->bridge_hello_time;\n\tspin_unlock_bh(&br->lock);\n\treturn 0;\n}\n\nint br_set_max_age(struct net_bridge *br, unsigned long val)\n{\n\tunsigned long t = clock_t_to_jiffies(val);\n\n\tif (t < BR_MIN_MAX_AGE || t > BR_MAX_MAX_AGE)\n\t\treturn -ERANGE;\n\n\tspin_lock_bh(&br->lock);\n\tbr->bridge_max_age = t;\n\tif (br_is_root_bridge(br))\n\t\tbr->max_age = br->bridge_max_age;\n\tspin_unlock_bh(&br->lock);\n\treturn 0;\n\n}\n\n \nint __set_ageing_time(struct net_device *dev, unsigned long t)\n{\n\tstruct switchdev_attr attr = {\n\t\t.orig_dev = dev,\n\t\t.id = SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME,\n\t\t.flags = SWITCHDEV_F_SKIP_EOPNOTSUPP | SWITCHDEV_F_DEFER,\n\t\t.u.ageing_time = jiffies_to_clock_t(t),\n\t};\n\tint err;\n\n\terr = switchdev_port_attr_set(dev, &attr, NULL);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nint br_set_ageing_time(struct net_bridge *br, clock_t ageing_time)\n{\n\tunsigned long t = clock_t_to_jiffies(ageing_time);\n\tint err;\n\n\terr = __set_ageing_time(br->dev, t);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_bh(&br->lock);\n\tbr->bridge_ageing_time = t;\n\tbr->ageing_time = t;\n\tspin_unlock_bh(&br->lock);\n\n\tmod_delayed_work(system_long_wq, &br->gc_work, 0);\n\n\treturn 0;\n}\n\nclock_t br_get_ageing_time(const struct net_device *br_dev)\n{\n\tconst struct net_bridge *br;\n\n\tif (!netif_is_bridge_master(br_dev))\n\t\treturn 0;\n\n\tbr = netdev_priv(br_dev);\n\n\treturn jiffies_to_clock_t(br->ageing_time);\n}\nEXPORT_SYMBOL_GPL(br_get_ageing_time);\n\n \nvoid __br_set_topology_change(struct net_bridge *br, unsigned char val)\n{\n\tunsigned long t;\n\tint err;\n\n\tif (br->stp_enabled == BR_KERNEL_STP && br->topology_change != val) {\n\t\t \n\n\t\tif (val) {\n\t\t\tt = 2 * br->forward_delay;\n\t\t\tbr_debug(br, \"decreasing ageing time to %lu\\n\", t);\n\t\t} else {\n\t\t\tt = br->bridge_ageing_time;\n\t\t\tbr_debug(br, \"restoring ageing time to %lu\\n\", t);\n\t\t}\n\n\t\terr = __set_ageing_time(br->dev, t);\n\t\tif (err)\n\t\t\tbr_warn(br, \"error offloading ageing time\\n\");\n\t\telse\n\t\t\tbr->ageing_time = t;\n\t}\n\n\tbr->topology_change = val;\n}\n\nvoid __br_set_forward_delay(struct net_bridge *br, unsigned long t)\n{\n\tbr->bridge_forward_delay = t;\n\tif (br_is_root_bridge(br))\n\t\tbr->forward_delay = br->bridge_forward_delay;\n}\n\nint br_set_forward_delay(struct net_bridge *br, unsigned long val)\n{\n\tunsigned long t = clock_t_to_jiffies(val);\n\tint err = -ERANGE;\n\n\tspin_lock_bh(&br->lock);\n\tif (br->stp_enabled != BR_NO_STP &&\n\t    (t < BR_MIN_FORWARD_DELAY || t > BR_MAX_FORWARD_DELAY))\n\t\tgoto unlock;\n\n\t__br_set_forward_delay(br, t);\n\terr = 0;\n\nunlock:\n\tspin_unlock_bh(&br->lock);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}