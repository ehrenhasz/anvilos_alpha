{
  "module_name": "br_input.c",
  "hash_id": "32ef61155120b5d990beaf836c1538757e55aea1216aa4cc0a3e13f44d375be6",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_input.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/netfilter_bridge.h>\n#ifdef CONFIG_NETFILTER_FAMILY_BRIDGE\n#include <net/netfilter/nf_queue.h>\n#endif\n#include <linux/neighbour.h>\n#include <net/arp.h>\n#include <net/dsa.h>\n#include <linux/export.h>\n#include <linux/rculist.h>\n#include \"br_private.h\"\n#include \"br_private_tunnel.h\"\n\nstatic int\nbr_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tbr_drop_fake_rtable(skb);\n\treturn netif_receive_skb(skb);\n}\n\nstatic int br_pass_frame_up(struct sk_buff *skb)\n{\n\tstruct net_device *indev, *brdev = BR_INPUT_SKB_CB(skb)->brdev;\n\tstruct net_bridge *br = netdev_priv(brdev);\n\tstruct net_bridge_vlan_group *vg;\n\n\tdev_sw_netstats_rx_add(brdev, skb->len);\n\n\tvg = br_vlan_group_rcu(br);\n\n\t \n\tbr_switchdev_frame_unmark(skb);\n\n\t \n\tif (!(brdev->flags & IFF_PROMISC) &&\n\t    !br_allowed_egress(vg, skb)) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tindev = skb->dev;\n\tskb->dev = brdev;\n\tskb = br_handle_vlan(br, NULL, vg, skb);\n\tif (!skb)\n\t\treturn NET_RX_DROP;\n\t \n\tbr_multicast_count(br, NULL, skb, br_multicast_igmp_type(skb),\n\t\t\t   BR_MCAST_DIR_TX);\n\n\treturn NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,\n\t\t       dev_net(indev), NULL, skb, indev, NULL,\n\t\t       br_netif_receive_skb);\n}\n\n \nint br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\n\tenum br_pkt_type pkt_type = BR_PKT_UNICAST;\n\tstruct net_bridge_fdb_entry *dst = NULL;\n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_mdb_entry *mdst;\n\tbool local_rcv, mcast_hit = false;\n\tstruct net_bridge_mcast *brmctx;\n\tstruct net_bridge_vlan *vlan;\n\tstruct net_bridge *br;\n\tu16 vid = 0;\n\tu8 state;\n\n\tif (!p)\n\t\tgoto drop;\n\n\tbr = p->br;\n\n\tif (br_mst_is_enabled(br)) {\n\t\tstate = BR_STATE_FORWARDING;\n\t} else {\n\t\tif (p->state == BR_STATE_DISABLED)\n\t\t\tgoto drop;\n\n\t\tstate = p->state;\n\t}\n\n\tbrmctx = &p->br->multicast_ctx;\n\tpmctx = &p->multicast_ctx;\n\tif (!br_allowed_ingress(p->br, nbp_vlan_group_rcu(p), skb, &vid,\n\t\t\t\t&state, &vlan))\n\t\tgoto out;\n\n\tif (p->flags & BR_PORT_LOCKED) {\n\t\tstruct net_bridge_fdb_entry *fdb_src =\n\t\t\tbr_fdb_find_rcu(br, eth_hdr(skb)->h_source, vid);\n\n\t\tif (!fdb_src) {\n\t\t\t \n\t\t\tif (p->flags & BR_PORT_MAB)\n\t\t\t\tbr_fdb_update(br, p, eth_hdr(skb)->h_source,\n\t\t\t\t\t      vid, BIT(BR_FDB_LOCKED));\n\t\t\tgoto drop;\n\t\t} else if (READ_ONCE(fdb_src->dst) != p ||\n\t\t\t   test_bit(BR_FDB_LOCAL, &fdb_src->flags)) {\n\t\t\t \n\t\t\tgoto drop;\n\t\t} else if (test_bit(BR_FDB_LOCKED, &fdb_src->flags)) {\n\t\t\t \n\t\t\tbr_fdb_update(br, p, eth_hdr(skb)->h_source, vid,\n\t\t\t\t      BIT(BR_FDB_LOCKED));\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tnbp_switchdev_frame_mark(p, skb);\n\n\t \n\tif (p->flags & BR_LEARNING)\n\t\tbr_fdb_update(br, p, eth_hdr(skb)->h_source, vid, 0);\n\n\tlocal_rcv = !!(br->dev->flags & IFF_PROMISC);\n\tif (is_multicast_ether_addr(eth_hdr(skb)->h_dest)) {\n\t\t \n\t\tif (is_broadcast_ether_addr(eth_hdr(skb)->h_dest)) {\n\t\t\tpkt_type = BR_PKT_BROADCAST;\n\t\t\tlocal_rcv = true;\n\t\t} else {\n\t\t\tpkt_type = BR_PKT_MULTICAST;\n\t\t\tif (br_multicast_rcv(&brmctx, &pmctx, vlan, skb, vid))\n\t\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (state == BR_STATE_LEARNING)\n\t\tgoto drop;\n\n\tBR_INPUT_SKB_CB(skb)->brdev = br->dev;\n\tBR_INPUT_SKB_CB(skb)->src_port_isolated = !!(p->flags & BR_ISOLATED);\n\n\tif (IS_ENABLED(CONFIG_INET) &&\n\t    (skb->protocol == htons(ETH_P_ARP) ||\n\t     skb->protocol == htons(ETH_P_RARP))) {\n\t\tbr_do_proxy_suppress_arp(skb, br, vid, p);\n\t} else if (IS_ENABLED(CONFIG_IPV6) &&\n\t\t   skb->protocol == htons(ETH_P_IPV6) &&\n\t\t   br_opt_get(br, BROPT_NEIGH_SUPPRESS_ENABLED) &&\n\t\t   pskb_may_pull(skb, sizeof(struct ipv6hdr) +\n\t\t\t\t sizeof(struct nd_msg)) &&\n\t\t   ipv6_hdr(skb)->nexthdr == IPPROTO_ICMPV6) {\n\t\t\tstruct nd_msg *msg, _msg;\n\n\t\t\tmsg = br_is_nd_neigh_msg(skb, &_msg);\n\t\t\tif (msg)\n\t\t\t\tbr_do_suppress_nd(skb, br, vid, p, msg);\n\t}\n\n\tswitch (pkt_type) {\n\tcase BR_PKT_MULTICAST:\n\t\tmdst = br_mdb_get(brmctx, skb, vid);\n\t\tif ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &&\n\t\t    br_multicast_querier_exists(brmctx, eth_hdr(skb), mdst)) {\n\t\t\tif ((mdst && mdst->host_joined) ||\n\t\t\t    br_multicast_is_router(brmctx, skb)) {\n\t\t\t\tlocal_rcv = true;\n\t\t\t\tDEV_STATS_INC(br->dev, multicast);\n\t\t\t}\n\t\t\tmcast_hit = true;\n\t\t} else {\n\t\t\tlocal_rcv = true;\n\t\t\tDEV_STATS_INC(br->dev, multicast);\n\t\t}\n\t\tbreak;\n\tcase BR_PKT_UNICAST:\n\t\tdst = br_fdb_find_rcu(br, eth_hdr(skb)->h_dest, vid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (dst) {\n\t\tunsigned long now = jiffies;\n\n\t\tif (test_bit(BR_FDB_LOCAL, &dst->flags))\n\t\t\treturn br_pass_frame_up(skb);\n\n\t\tif (now != dst->used)\n\t\t\tdst->used = now;\n\t\tbr_forward(dst->dst, skb, local_rcv, false);\n\t} else {\n\t\tif (!mcast_hit)\n\t\t\tbr_flood(br, skb, pkt_type, local_rcv, false, vid);\n\t\telse\n\t\t\tbr_multicast_flood(mdst, skb, brmctx, local_rcv, false);\n\t}\n\n\tif (local_rcv)\n\t\treturn br_pass_frame_up(skb);\n\nout:\n\treturn 0;\ndrop:\n\tkfree_skb(skb);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(br_handle_frame_finish);\n\nstatic void __br_handle_local_finish(struct sk_buff *skb)\n{\n\tstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\n\tu16 vid = 0;\n\n\t \n\tif ((p->flags & BR_LEARNING) &&\n\t    nbp_state_should_learn(p) &&\n\t    !br_opt_get(p->br, BROPT_NO_LL_LEARN) &&\n\t    br_should_learn(p, skb, &vid))\n\t\tbr_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, 0);\n}\n\n \nstatic int br_handle_local_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\t__br_handle_local_finish(skb);\n\n\t \n\treturn 1;\n}\n\nstatic int nf_hook_bridge_pre(struct sk_buff *skb, struct sk_buff **pskb)\n{\n#ifdef CONFIG_NETFILTER_FAMILY_BRIDGE\n\tstruct nf_hook_entries *e = NULL;\n\tstruct nf_hook_state state;\n\tunsigned int verdict, i;\n\tstruct net *net;\n\tint ret;\n\n\tnet = dev_net(skb->dev);\n#ifdef HAVE_JUMP_LABEL\n\tif (!static_key_false(&nf_hooks_needed[NFPROTO_BRIDGE][NF_BR_PRE_ROUTING]))\n\t\tgoto frame_finish;\n#endif\n\n\te = rcu_dereference(net->nf.hooks_bridge[NF_BR_PRE_ROUTING]);\n\tif (!e)\n\t\tgoto frame_finish;\n\n\tnf_hook_state_init(&state, NF_BR_PRE_ROUTING,\n\t\t\t   NFPROTO_BRIDGE, skb->dev, NULL, NULL,\n\t\t\t   net, br_handle_frame_finish);\n\n\tfor (i = 0; i < e->num_hook_entries; i++) {\n\t\tverdict = nf_hook_entry_hookfn(&e->hooks[i], skb, &state);\n\t\tswitch (verdict & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\t\tif (BR_INPUT_SKB_CB(skb)->br_netfilter_broute) {\n\t\t\t\t*pskb = skb;\n\t\t\t\treturn RX_HANDLER_PASS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NF_DROP:\n\t\t\tkfree_skb(skb);\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\tcase NF_QUEUE:\n\t\t\tret = nf_queue(skb, &state, i, verdict);\n\t\t\tif (ret == 1)\n\t\t\t\tcontinue;\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\tdefault:  \n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\t}\n\t}\nframe_finish:\n\tnet = dev_net(skb->dev);\n\tbr_handle_frame_finish(net, NULL, skb);\n#else\n\tbr_handle_frame_finish(dev_net(skb->dev), NULL, skb);\n#endif\n\treturn RX_HANDLER_CONSUMED;\n}\n\n \nstatic int br_process_frame_type(struct net_bridge_port *p,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct br_frame_type *tmp;\n\n\thlist_for_each_entry_rcu(tmp, &p->br->frame_type_list, list)\n\t\tif (unlikely(tmp->type == skb->protocol))\n\t\t\treturn tmp->frame_handler(p, skb);\n\n\treturn 0;\n}\n\n \nstatic rx_handler_result_t br_handle_frame(struct sk_buff **pskb)\n{\n\tstruct net_bridge_port *p;\n\tstruct sk_buff *skb = *pskb;\n\tconst unsigned char *dest = eth_hdr(skb)->h_dest;\n\n\tif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\n\t\treturn RX_HANDLER_PASS;\n\n\tif (!is_valid_ether_addr(eth_hdr(skb)->h_source))\n\t\tgoto drop;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn RX_HANDLER_CONSUMED;\n\n\tmemset(skb->cb, 0, sizeof(struct br_input_skb_cb));\n\tbr_tc_skb_miss_set(skb, false);\n\n\tp = br_port_get_rcu(skb->dev);\n\tif (p->flags & BR_VLAN_TUNNEL)\n\t\tbr_handle_ingress_vlan_tunnel(skb, p, nbp_vlan_group_rcu(p));\n\n\tif (unlikely(is_link_local_ether_addr(dest))) {\n\t\tu16 fwd_mask = p->br->group_fwd_mask_required;\n\n\t\t \n\t\tfwd_mask |= p->group_fwd_mask;\n\t\tswitch (dest[5]) {\n\t\tcase 0x00:\t \n\t\t\t \n\t\t\tif (p->br->stp_enabled == BR_NO_STP ||\n\t\t\t    fwd_mask & (1u << dest[5]))\n\t\t\t\tgoto forward;\n\t\t\t*pskb = skb;\n\t\t\t__br_handle_local_finish(skb);\n\t\t\treturn RX_HANDLER_PASS;\n\n\t\tcase 0x01:\t \n\t\t\tgoto drop;\n\n\t\tcase 0x0E:\t \n\t\t\tfwd_mask |= p->br->group_fwd_mask;\n\t\t\tif (fwd_mask & (1u << dest[5]))\n\t\t\t\tgoto forward;\n\t\t\t*pskb = skb;\n\t\t\t__br_handle_local_finish(skb);\n\t\t\treturn RX_HANDLER_PASS;\n\n\t\tdefault:\n\t\t\t \n\t\t\tfwd_mask |= p->br->group_fwd_mask;\n\t\t\tif (fwd_mask & (1u << dest[5]))\n\t\t\t\tgoto forward;\n\t\t}\n\n\t\t \n\t\tif (NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,\n\t\t\t    dev_net(skb->dev), NULL, skb, skb->dev, NULL,\n\t\t\t    br_handle_local_finish) == 1) {\n\t\t\treturn RX_HANDLER_PASS;\n\t\t} else {\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\t}\n\t}\n\n\tif (unlikely(br_process_frame_type(p, skb)))\n\t\treturn RX_HANDLER_PASS;\n\nforward:\n\tif (br_mst_is_enabled(p->br))\n\t\tgoto defer_stp_filtering;\n\n\tswitch (p->state) {\n\tcase BR_STATE_FORWARDING:\n\tcase BR_STATE_LEARNING:\ndefer_stp_filtering:\n\t\tif (ether_addr_equal(p->br->dev->dev_addr, dest))\n\t\t\tskb->pkt_type = PACKET_HOST;\n\n\t\treturn nf_hook_bridge_pre(skb, pskb);\n\tdefault:\ndrop:\n\t\tkfree_skb(skb);\n\t}\n\treturn RX_HANDLER_CONSUMED;\n}\n\n \nstatic rx_handler_result_t br_handle_frame_dummy(struct sk_buff **pskb)\n{\n\treturn RX_HANDLER_PASS;\n}\n\nrx_handler_func_t *br_get_rx_handler(const struct net_device *dev)\n{\n\tif (netdev_uses_dsa(dev))\n\t\treturn br_handle_frame_dummy;\n\n\treturn br_handle_frame;\n}\n\nvoid br_add_frame(struct net_bridge *br, struct br_frame_type *ft)\n{\n\thlist_add_head_rcu(&ft->list, &br->frame_type_list);\n}\n\nvoid br_del_frame(struct net_bridge *br, struct br_frame_type *ft)\n{\n\tstruct br_frame_type *tmp;\n\n\thlist_for_each_entry(tmp, &br->frame_type_list, list)\n\t\tif (ft == tmp) {\n\t\t\thlist_del_rcu(&ft->list);\n\t\t\treturn;\n\t\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}