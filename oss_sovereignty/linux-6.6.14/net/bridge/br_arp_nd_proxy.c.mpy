{
  "module_name": "br_arp_nd_proxy.c",
  "hash_id": "afee83860d788ad54541f9d0f73e02d3124d66a5671f2e12e0b81fcb4a4155fa",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_arp_nd_proxy.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/neighbour.h>\n#include <net/arp.h>\n#include <linux/if_vlan.h>\n#include <linux/inetdevice.h>\n#include <net/addrconf.h>\n#include <net/ipv6_stubs.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ip6_checksum.h>\n#endif\n\n#include \"br_private.h\"\n\nvoid br_recalculate_neigh_suppress_enabled(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\tbool neigh_suppress = false;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->flags & (BR_NEIGH_SUPPRESS | BR_NEIGH_VLAN_SUPPRESS)) {\n\t\t\tneigh_suppress = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbr_opt_toggle(br, BROPT_NEIGH_SUPPRESS_ENABLED, neigh_suppress);\n}\n\n#if IS_ENABLED(CONFIG_INET)\nstatic void br_arp_send(struct net_bridge *br, struct net_bridge_port *p,\n\t\t\tstruct net_device *dev, __be32 dest_ip, __be32 src_ip,\n\t\t\tconst unsigned char *dest_hw,\n\t\t\tconst unsigned char *src_hw,\n\t\t\tconst unsigned char *target_hw,\n\t\t\t__be16 vlan_proto, u16 vlan_tci)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct sk_buff *skb;\n\tu16 pvid;\n\n\tnetdev_dbg(dev, \"arp send dev %s dst %pI4 dst_hw %pM src %pI4 src_hw %pM\\n\",\n\t\t   dev->name, &dest_ip, dest_hw, &src_ip, src_hw);\n\n\tif (!vlan_tci) {\n\t\tarp_send(ARPOP_REPLY, ETH_P_ARP, dest_ip, dev, src_ip,\n\t\t\t dest_hw, src_hw, target_hw);\n\t\treturn;\n\t}\n\n\tskb = arp_create(ARPOP_REPLY, ETH_P_ARP, dest_ip, dev, src_ip,\n\t\t\t dest_hw, src_hw, target_hw);\n\tif (!skb)\n\t\treturn;\n\n\tif (p)\n\t\tvg = nbp_vlan_group_rcu(p);\n\telse\n\t\tvg = br_vlan_group_rcu(br);\n\tpvid = br_get_pvid(vg);\n\tif (pvid == (vlan_tci & VLAN_VID_MASK))\n\t\tvlan_tci = 0;\n\n\tif (vlan_tci)\n\t\t__vlan_hwaccel_put_tag(skb, vlan_proto, vlan_tci);\n\n\tif (p) {\n\t\tarp_xmit(skb);\n\t} else {\n\t\tskb_reset_mac_header(skb);\n\t\t__skb_pull(skb, skb_network_offset(skb));\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic int br_chk_addr_ip(struct net_device *dev,\n\t\t\t  struct netdev_nested_priv *priv)\n{\n\t__be32 ip = *(__be32 *)priv->data;\n\tstruct in_device *in_dev;\n\t__be32 addr = 0;\n\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (in_dev)\n\t\taddr = inet_confirm_addr(dev_net(dev), in_dev, 0, ip,\n\t\t\t\t\t RT_SCOPE_HOST);\n\n\tif (addr == ip)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool br_is_local_ip(struct net_device *dev, __be32 ip)\n{\n\tstruct netdev_nested_priv priv = {\n\t\t.data = (void *)&ip,\n\t};\n\n\tif (br_chk_addr_ip(dev, &priv))\n\t\treturn true;\n\n\t \n\tif (netdev_walk_all_upper_dev_rcu(dev, br_chk_addr_ip, &priv))\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid br_do_proxy_suppress_arp(struct sk_buff *skb, struct net_bridge *br,\n\t\t\t      u16 vid, struct net_bridge_port *p)\n{\n\tstruct net_device *dev = br->dev;\n\tstruct net_device *vlandev = dev;\n\tstruct neighbour *n;\n\tstruct arphdr *parp;\n\tu8 *arpptr, *sha;\n\t__be32 sip, tip;\n\n\tBR_INPUT_SKB_CB(skb)->proxyarp_replied = 0;\n\n\tif ((dev->flags & IFF_NOARP) ||\n\t    !pskb_may_pull(skb, arp_hdr_len(dev)))\n\t\treturn;\n\n\tparp = arp_hdr(skb);\n\n\tif (parp->ar_pro != htons(ETH_P_IP) ||\n\t    parp->ar_hln != dev->addr_len ||\n\t    parp->ar_pln != 4)\n\t\treturn;\n\n\tarpptr = (u8 *)parp + sizeof(struct arphdr);\n\tsha = arpptr;\n\tarpptr += dev->addr_len;\t \n\tmemcpy(&sip, arpptr, sizeof(sip));\n\tarpptr += sizeof(sip);\n\tarpptr += dev->addr_len;\t \n\tmemcpy(&tip, arpptr, sizeof(tip));\n\n\tif (ipv4_is_loopback(tip) ||\n\t    ipv4_is_multicast(tip))\n\t\treturn;\n\n\tif (br_opt_get(br, BROPT_NEIGH_SUPPRESS_ENABLED)) {\n\t\tif (br_is_neigh_suppress_enabled(p, vid))\n\t\t\treturn;\n\t\tif (parp->ar_op != htons(ARPOP_RREQUEST) &&\n\t\t    parp->ar_op != htons(ARPOP_RREPLY) &&\n\t\t    (ipv4_is_zeronet(sip) || sip == tip)) {\n\t\t\t \n\t\t\tBR_INPUT_SKB_CB(skb)->proxyarp_replied = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (parp->ar_op != htons(ARPOP_REQUEST))\n\t\treturn;\n\n\tif (vid != 0) {\n\t\tvlandev = __vlan_find_dev_deep_rcu(br->dev, skb->vlan_proto,\n\t\t\t\t\t\t   vid);\n\t\tif (!vlandev)\n\t\t\treturn;\n\t}\n\n\tif (br_opt_get(br, BROPT_NEIGH_SUPPRESS_ENABLED) &&\n\t    br_is_local_ip(vlandev, tip)) {\n\t\t \n\t\tBR_INPUT_SKB_CB(skb)->proxyarp_replied = 1;\n\t\treturn;\n\t}\n\n\tn = neigh_lookup(&arp_tbl, &tip, vlandev);\n\tif (n) {\n\t\tstruct net_bridge_fdb_entry *f;\n\n\t\tif (!(READ_ONCE(n->nud_state) & NUD_VALID)) {\n\t\t\tneigh_release(n);\n\t\t\treturn;\n\t\t}\n\n\t\tf = br_fdb_find_rcu(br, n->ha, vid);\n\t\tif (f) {\n\t\t\tbool replied = false;\n\n\t\t\tif ((p && (p->flags & BR_PROXYARP)) ||\n\t\t\t    (f->dst && (f->dst->flags & BR_PROXYARP_WIFI)) ||\n\t\t\t    br_is_neigh_suppress_enabled(f->dst, vid)) {\n\t\t\t\tif (!vid)\n\t\t\t\t\tbr_arp_send(br, p, skb->dev, sip, tip,\n\t\t\t\t\t\t    sha, n->ha, sha, 0, 0);\n\t\t\t\telse\n\t\t\t\t\tbr_arp_send(br, p, skb->dev, sip, tip,\n\t\t\t\t\t\t    sha, n->ha, sha,\n\t\t\t\t\t\t    skb->vlan_proto,\n\t\t\t\t\t\t    skb_vlan_tag_get(skb));\n\t\t\t\treplied = true;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (replied ||\n\t\t\t    br_opt_get(br, BROPT_NEIGH_SUPPRESS_ENABLED))\n\t\t\t\tBR_INPUT_SKB_CB(skb)->proxyarp_replied = 1;\n\t\t}\n\n\t\tneigh_release(n);\n\t}\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstruct nd_msg *br_is_nd_neigh_msg(struct sk_buff *skb, struct nd_msg *msg)\n{\n\tstruct nd_msg *m;\n\n\tm = skb_header_pointer(skb, skb_network_offset(skb) +\n\t\t\t       sizeof(struct ipv6hdr), sizeof(*msg), msg);\n\tif (!m)\n\t\treturn NULL;\n\n\tif (m->icmph.icmp6_code != 0 ||\n\t    (m->icmph.icmp6_type != NDISC_NEIGHBOUR_SOLICITATION &&\n\t     m->icmph.icmp6_type != NDISC_NEIGHBOUR_ADVERTISEMENT))\n\t\treturn NULL;\n\n\treturn m;\n}\n\nstatic void br_nd_send(struct net_bridge *br, struct net_bridge_port *p,\n\t\t       struct sk_buff *request, struct neighbour *n,\n\t\t       __be16 vlan_proto, u16 vlan_tci, struct nd_msg *ns)\n{\n\tstruct net_device *dev = request->dev;\n\tstruct net_bridge_vlan_group *vg;\n\tstruct sk_buff *reply;\n\tstruct nd_msg *na;\n\tstruct ipv6hdr *pip6;\n\tint na_olen = 8;  \n\tint ns_olen;\n\tint i, len;\n\tu8 *daddr;\n\tu16 pvid;\n\n\tif (!dev)\n\t\treturn;\n\n\tlen = LL_RESERVED_SPACE(dev) + sizeof(struct ipv6hdr) +\n\t\tsizeof(*na) + na_olen + dev->needed_tailroom;\n\n\treply = alloc_skb(len, GFP_ATOMIC);\n\tif (!reply)\n\t\treturn;\n\n\treply->protocol = htons(ETH_P_IPV6);\n\treply->dev = dev;\n\tskb_reserve(reply, LL_RESERVED_SPACE(dev));\n\tskb_push(reply, sizeof(struct ethhdr));\n\tskb_set_mac_header(reply, 0);\n\n\tdaddr = eth_hdr(request)->h_source;\n\n\t \n\tns_olen = request->len - (skb_network_offset(request) +\n\t\t\t\t  sizeof(struct ipv6hdr)) - sizeof(*ns);\n\tfor (i = 0; i < ns_olen - 1; i += (ns->opt[i + 1] << 3)) {\n\t\tif (!ns->opt[i + 1]) {\n\t\t\tkfree_skb(reply);\n\t\t\treturn;\n\t\t}\n\t\tif (ns->opt[i] == ND_OPT_SOURCE_LL_ADDR) {\n\t\t\tdaddr = ns->opt + i + sizeof(struct nd_opt_hdr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tether_addr_copy(eth_hdr(reply)->h_dest, daddr);\n\tether_addr_copy(eth_hdr(reply)->h_source, n->ha);\n\teth_hdr(reply)->h_proto = htons(ETH_P_IPV6);\n\treply->protocol = htons(ETH_P_IPV6);\n\n\tskb_pull(reply, sizeof(struct ethhdr));\n\tskb_set_network_header(reply, 0);\n\tskb_put(reply, sizeof(struct ipv6hdr));\n\n\t \n\tpip6 = ipv6_hdr(reply);\n\tmemset(pip6, 0, sizeof(struct ipv6hdr));\n\tpip6->version = 6;\n\tpip6->priority = ipv6_hdr(request)->priority;\n\tpip6->nexthdr = IPPROTO_ICMPV6;\n\tpip6->hop_limit = 255;\n\tpip6->daddr = ipv6_hdr(request)->saddr;\n\tpip6->saddr = *(struct in6_addr *)n->primary_key;\n\n\tskb_pull(reply, sizeof(struct ipv6hdr));\n\tskb_set_transport_header(reply, 0);\n\n\tna = (struct nd_msg *)skb_put(reply, sizeof(*na) + na_olen);\n\n\t \n\tmemset(na, 0, sizeof(*na) + na_olen);\n\tna->icmph.icmp6_type = NDISC_NEIGHBOUR_ADVERTISEMENT;\n\tna->icmph.icmp6_router = (n->flags & NTF_ROUTER) ? 1 : 0;\n\tna->icmph.icmp6_override = 1;\n\tna->icmph.icmp6_solicited = 1;\n\tna->target = ns->target;\n\tether_addr_copy(&na->opt[2], n->ha);\n\tna->opt[0] = ND_OPT_TARGET_LL_ADDR;\n\tna->opt[1] = na_olen >> 3;\n\n\tna->icmph.icmp6_cksum = csum_ipv6_magic(&pip6->saddr,\n\t\t\t\t\t\t&pip6->daddr,\n\t\t\t\t\t\tsizeof(*na) + na_olen,\n\t\t\t\t\t\tIPPROTO_ICMPV6,\n\t\t\t\t\t\tcsum_partial(na, sizeof(*na) + na_olen, 0));\n\n\tpip6->payload_len = htons(sizeof(*na) + na_olen);\n\n\tskb_push(reply, sizeof(struct ipv6hdr));\n\tskb_push(reply, sizeof(struct ethhdr));\n\n\treply->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (p)\n\t\tvg = nbp_vlan_group_rcu(p);\n\telse\n\t\tvg = br_vlan_group_rcu(br);\n\tpvid = br_get_pvid(vg);\n\tif (pvid == (vlan_tci & VLAN_VID_MASK))\n\t\tvlan_tci = 0;\n\n\tif (vlan_tci)\n\t\t__vlan_hwaccel_put_tag(reply, vlan_proto, vlan_tci);\n\n\tnetdev_dbg(dev, \"nd send dev %s dst %pI6 dst_hw %pM src %pI6 src_hw %pM\\n\",\n\t\t   dev->name, &pip6->daddr, daddr, &pip6->saddr, n->ha);\n\n\tif (p) {\n\t\tdev_queue_xmit(reply);\n\t} else {\n\t\tskb_reset_mac_header(reply);\n\t\t__skb_pull(reply, skb_network_offset(reply));\n\t\treply->ip_summed = CHECKSUM_UNNECESSARY;\n\t\treply->pkt_type = PACKET_HOST;\n\n\t\tnetif_rx(reply);\n\t}\n}\n\nstatic int br_chk_addr_ip6(struct net_device *dev,\n\t\t\t   struct netdev_nested_priv *priv)\n{\n\tstruct in6_addr *addr = (struct in6_addr *)priv->data;\n\n\tif (ipv6_chk_addr(dev_net(dev), addr, dev, 0))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool br_is_local_ip6(struct net_device *dev, struct in6_addr *addr)\n\n{\n\tstruct netdev_nested_priv priv = {\n\t\t.data = (void *)addr,\n\t};\n\n\tif (br_chk_addr_ip6(dev, &priv))\n\t\treturn true;\n\n\t \n\tif (netdev_walk_all_upper_dev_rcu(dev, br_chk_addr_ip6, &priv))\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid br_do_suppress_nd(struct sk_buff *skb, struct net_bridge *br,\n\t\t       u16 vid, struct net_bridge_port *p, struct nd_msg *msg)\n{\n\tstruct net_device *dev = br->dev;\n\tstruct net_device *vlandev = NULL;\n\tstruct in6_addr *saddr, *daddr;\n\tstruct ipv6hdr *iphdr;\n\tstruct neighbour *n;\n\n\tBR_INPUT_SKB_CB(skb)->proxyarp_replied = 0;\n\n\tif (br_is_neigh_suppress_enabled(p, vid))\n\t\treturn;\n\n\tif (msg->icmph.icmp6_type == NDISC_NEIGHBOUR_ADVERTISEMENT &&\n\t    !msg->icmph.icmp6_solicited) {\n\t\t \n\t\tBR_INPUT_SKB_CB(skb)->proxyarp_replied = 1;\n\t\treturn;\n\t}\n\n\tif (msg->icmph.icmp6_type != NDISC_NEIGHBOUR_SOLICITATION)\n\t\treturn;\n\n\tiphdr = ipv6_hdr(skb);\n\tsaddr = &iphdr->saddr;\n\tdaddr = &iphdr->daddr;\n\n\tif (ipv6_addr_any(saddr) || !ipv6_addr_cmp(saddr, daddr)) {\n\t\t \n\t\tBR_INPUT_SKB_CB(skb)->proxyarp_replied = 1;\n\t\treturn;\n\t}\n\n\tif (vid != 0) {\n\t\t \n\t\tvlandev = __vlan_find_dev_deep_rcu(br->dev, skb->vlan_proto,\n\t\t\t\t\t\t   vid);\n\t\tif (!vlandev)\n\t\t\treturn;\n\t} else {\n\t\tvlandev = dev;\n\t}\n\n\tif (br_is_local_ip6(vlandev, &msg->target)) {\n\t\t \n\t\tBR_INPUT_SKB_CB(skb)->proxyarp_replied = 1;\n\t\treturn;\n\t}\n\n\tn = neigh_lookup(ipv6_stub->nd_tbl, &msg->target, vlandev);\n\tif (n) {\n\t\tstruct net_bridge_fdb_entry *f;\n\n\t\tif (!(READ_ONCE(n->nud_state) & NUD_VALID)) {\n\t\t\tneigh_release(n);\n\t\t\treturn;\n\t\t}\n\n\t\tf = br_fdb_find_rcu(br, n->ha, vid);\n\t\tif (f) {\n\t\t\tbool replied = false;\n\n\t\t\tif (br_is_neigh_suppress_enabled(f->dst, vid)) {\n\t\t\t\tif (vid != 0)\n\t\t\t\t\tbr_nd_send(br, p, skb, n,\n\t\t\t\t\t\t   skb->vlan_proto,\n\t\t\t\t\t\t   skb_vlan_tag_get(skb), msg);\n\t\t\t\telse\n\t\t\t\t\tbr_nd_send(br, p, skb, n, 0, 0, msg);\n\t\t\t\treplied = true;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (replied ||\n\t\t\t    br_opt_get(br, BROPT_NEIGH_SUPPRESS_ENABLED))\n\t\t\t\tBR_INPUT_SKB_CB(skb)->proxyarp_replied = 1;\n\t\t}\n\t\tneigh_release(n);\n\t}\n}\n#endif\n\nbool br_is_neigh_suppress_enabled(const struct net_bridge_port *p, u16 vid)\n{\n\tif (!p)\n\t\treturn false;\n\n\tif (!vid)\n\t\treturn !!(p->flags & BR_NEIGH_SUPPRESS);\n\n\tif (p->flags & BR_NEIGH_VLAN_SUPPRESS) {\n\t\tstruct net_bridge_vlan_group *vg = nbp_vlan_group_rcu(p);\n\t\tstruct net_bridge_vlan *v;\n\n\t\tv = br_vlan_find(vg, vid);\n\t\tif (!v)\n\t\t\treturn false;\n\t\treturn !!(v->priv_flags & BR_VLFLAG_NEIGH_SUPPRESS_ENABLED);\n\t} else {\n\t\treturn !!(p->flags & BR_NEIGH_SUPPRESS);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}