{
  "module_name": "br_vlan_tunnel.c",
  "hash_id": "412bc06b3599411ace360c05c6a552ec0b607375d3ecd79932fe797e94c69217",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_vlan_tunnel.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <net/switchdev.h>\n#include <net/dst_metadata.h>\n\n#include \"br_private.h\"\n#include \"br_private_tunnel.h\"\n\nstatic inline int br_vlan_tunid_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t\t    const void *ptr)\n{\n\tconst struct net_bridge_vlan *vle = ptr;\n\t__be64 tunid = *(__be64 *)arg->key;\n\n\treturn vle->tinfo.tunnel_id != tunid;\n}\n\nstatic const struct rhashtable_params br_vlan_tunnel_rht_params = {\n\t.head_offset = offsetof(struct net_bridge_vlan, tnode),\n\t.key_offset = offsetof(struct net_bridge_vlan, tinfo.tunnel_id),\n\t.key_len = sizeof(__be64),\n\t.nelem_hint = 3,\n\t.obj_cmpfn = br_vlan_tunid_cmp,\n\t.automatic_shrinking = true,\n};\n\nstatic struct net_bridge_vlan *br_vlan_tunnel_lookup(struct rhashtable *tbl,\n\t\t\t\t\t\t     __be64 tunnel_id)\n{\n\treturn rhashtable_lookup_fast(tbl, &tunnel_id,\n\t\t\t\t      br_vlan_tunnel_rht_params);\n}\n\nstatic void vlan_tunnel_info_release(struct net_bridge_vlan *vlan)\n{\n\tstruct metadata_dst *tdst = rtnl_dereference(vlan->tinfo.tunnel_dst);\n\n\tWRITE_ONCE(vlan->tinfo.tunnel_id, 0);\n\tRCU_INIT_POINTER(vlan->tinfo.tunnel_dst, NULL);\n\tdst_release(&tdst->dst);\n}\n\nvoid vlan_tunnel_info_del(struct net_bridge_vlan_group *vg,\n\t\t\t  struct net_bridge_vlan *vlan)\n{\n\tif (!rcu_access_pointer(vlan->tinfo.tunnel_dst))\n\t\treturn;\n\trhashtable_remove_fast(&vg->tunnel_hash, &vlan->tnode,\n\t\t\t       br_vlan_tunnel_rht_params);\n\tvlan_tunnel_info_release(vlan);\n}\n\nstatic int __vlan_tunnel_info_add(struct net_bridge_vlan_group *vg,\n\t\t\t\t  struct net_bridge_vlan *vlan, u32 tun_id)\n{\n\tstruct metadata_dst *metadata = rtnl_dereference(vlan->tinfo.tunnel_dst);\n\t__be64 key = key32_to_tunnel_id(cpu_to_be32(tun_id));\n\tint err;\n\n\tif (metadata)\n\t\treturn -EEXIST;\n\n\tmetadata = __ip_tun_set_dst(0, 0, 0, 0, 0, TUNNEL_KEY,\n\t\t\t\t    key, 0);\n\tif (!metadata)\n\t\treturn -EINVAL;\n\n\tmetadata->u.tun_info.mode |= IP_TUNNEL_INFO_TX | IP_TUNNEL_INFO_BRIDGE;\n\trcu_assign_pointer(vlan->tinfo.tunnel_dst, metadata);\n\tWRITE_ONCE(vlan->tinfo.tunnel_id, key);\n\n\terr = rhashtable_lookup_insert_fast(&vg->tunnel_hash, &vlan->tnode,\n\t\t\t\t\t    br_vlan_tunnel_rht_params);\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tvlan_tunnel_info_release(vlan);\n\n\treturn err;\n}\n\n \nint nbp_vlan_tunnel_info_add(const struct net_bridge_port *port, u16 vid,\n\t\t\t     u32 tun_id)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *vlan;\n\n\tASSERT_RTNL();\n\n\tvg = nbp_vlan_group(port);\n\tvlan = br_vlan_find(vg, vid);\n\tif (!vlan)\n\t\treturn -EINVAL;\n\n\treturn __vlan_tunnel_info_add(vg, vlan, tun_id);\n}\n\n \nint nbp_vlan_tunnel_info_delete(const struct net_bridge_port *port, u16 vid)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\n\tASSERT_RTNL();\n\n\tvg = nbp_vlan_group(port);\n\tv = br_vlan_find(vg, vid);\n\tif (!v)\n\t\treturn -ENOENT;\n\n\tvlan_tunnel_info_del(vg, v);\n\n\treturn 0;\n}\n\nstatic void __vlan_tunnel_info_flush(struct net_bridge_vlan_group *vg)\n{\n\tstruct net_bridge_vlan *vlan, *tmp;\n\n\tlist_for_each_entry_safe(vlan, tmp, &vg->vlan_list, vlist)\n\t\tvlan_tunnel_info_del(vg, vlan);\n}\n\nvoid nbp_vlan_tunnel_info_flush(struct net_bridge_port *port)\n{\n\tstruct net_bridge_vlan_group *vg;\n\n\tASSERT_RTNL();\n\n\tvg = nbp_vlan_group(port);\n\t__vlan_tunnel_info_flush(vg);\n}\n\nint vlan_tunnel_init(struct net_bridge_vlan_group *vg)\n{\n\treturn rhashtable_init(&vg->tunnel_hash, &br_vlan_tunnel_rht_params);\n}\n\nvoid vlan_tunnel_deinit(struct net_bridge_vlan_group *vg)\n{\n\trhashtable_destroy(&vg->tunnel_hash);\n}\n\nvoid br_handle_ingress_vlan_tunnel(struct sk_buff *skb,\n\t\t\t\t   struct net_bridge_port *p,\n\t\t\t\t   struct net_bridge_vlan_group *vg)\n{\n\tstruct ip_tunnel_info *tinfo = skb_tunnel_info(skb);\n\tstruct net_bridge_vlan *vlan;\n\n\tif (!vg || !tinfo)\n\t\treturn;\n\n\t \n\tif (skb_vlan_tagged(skb))\n\t\treturn;\n\n\t \n\tvlan = br_vlan_tunnel_lookup(&vg->tunnel_hash, tinfo->key.tun_id);\n\tif (!vlan)\n\t\treturn;\n\n\tskb_dst_drop(skb);\n\n\t__vlan_hwaccel_put_tag(skb, p->br->vlan_proto, vlan->vid);\n}\n\nint br_handle_egress_vlan_tunnel(struct sk_buff *skb,\n\t\t\t\t struct net_bridge_vlan *vlan)\n{\n\tstruct metadata_dst *tunnel_dst;\n\t__be64 tunnel_id;\n\tint err;\n\n\tif (!vlan)\n\t\treturn 0;\n\n\ttunnel_id = READ_ONCE(vlan->tinfo.tunnel_id);\n\tif (!tunnel_id || unlikely(!skb_vlan_tag_present(skb)))\n\t\treturn 0;\n\n\tskb_dst_drop(skb);\n\terr = skb_vlan_pop(skb);\n\tif (err)\n\t\treturn err;\n\n\tif (BR_INPUT_SKB_CB(skb)->backup_nhid) {\n\t\ttunnel_dst = __ip_tun_set_dst(0, 0, 0, 0, 0, TUNNEL_KEY,\n\t\t\t\t\t      tunnel_id, 0);\n\t\tif (!tunnel_dst)\n\t\t\treturn -ENOMEM;\n\n\t\ttunnel_dst->u.tun_info.mode |= IP_TUNNEL_INFO_TX |\n\t\t\t\t\t       IP_TUNNEL_INFO_BRIDGE;\n\t\ttunnel_dst->u.tun_info.key.nhid =\n\t\t\tBR_INPUT_SKB_CB(skb)->backup_nhid;\n\t\tskb_dst_set(skb, &tunnel_dst->dst);\n\n\t\treturn 0;\n\t}\n\n\ttunnel_dst = rcu_dereference(vlan->tinfo.tunnel_dst);\n\tif (tunnel_dst && dst_hold_safe(&tunnel_dst->dst))\n\t\tskb_dst_set(skb, &tunnel_dst->dst);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}