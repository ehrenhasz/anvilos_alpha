{
  "module_name": "br_stp_bpdu.c",
  "hash_id": "fec1512fe02f65fdb28a71490d79bcccc18381c749b64ba08c5e1e27f438ec78",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_stp_bpdu.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/etherdevice.h>\n#include <linux/llc.h>\n#include <linux/slab.h>\n#include <linux/pkt_sched.h>\n#include <net/net_namespace.h>\n#include <net/llc.h>\n#include <net/llc_pdu.h>\n#include <net/stp.h>\n#include <asm/unaligned.h>\n\n#include \"br_private.h\"\n#include \"br_private_stp.h\"\n\n#define STP_HZ\t\t256\n\n#define LLC_RESERVE sizeof(struct llc_pdu_un)\n\nstatic int br_send_bpdu_finish(struct net *net, struct sock *sk,\n\t\t\t       struct sk_buff *skb)\n{\n\treturn dev_queue_xmit(skb);\n}\n\nstatic void br_send_bpdu(struct net_bridge_port *p,\n\t\t\t const unsigned char *data, int length)\n{\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(length+LLC_RESERVE);\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = p->dev;\n\tskb->protocol = htons(ETH_P_802_2);\n\tskb->priority = TC_PRIO_CONTROL;\n\n\tskb_reserve(skb, LLC_RESERVE);\n\t__skb_put_data(skb, data, length);\n\n\tllc_pdu_header_init(skb, LLC_PDU_TYPE_U, LLC_SAP_BSPAN,\n\t\t\t    LLC_SAP_BSPAN, LLC_PDU_CMD);\n\tllc_pdu_init_as_ui_cmd(skb);\n\n\tllc_mac_hdr_init(skb, p->dev->dev_addr, p->br->group_addr);\n\n\tskb_reset_mac_header(skb);\n\n\tNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT,\n\t\tdev_net(p->dev), NULL, skb, NULL, skb->dev,\n\t\tbr_send_bpdu_finish);\n}\n\nstatic inline void br_set_ticks(unsigned char *dest, int j)\n{\n\tunsigned long ticks = (STP_HZ * j)/ HZ;\n\n\tput_unaligned_be16(ticks, dest);\n}\n\nstatic inline int br_get_ticks(const unsigned char *src)\n{\n\tunsigned long ticks = get_unaligned_be16(src);\n\n\treturn DIV_ROUND_UP(ticks * HZ, STP_HZ);\n}\n\n \nvoid br_send_config_bpdu(struct net_bridge_port *p, struct br_config_bpdu *bpdu)\n{\n\tunsigned char buf[35];\n\n\tif (p->br->stp_enabled != BR_KERNEL_STP)\n\t\treturn;\n\n\tbuf[0] = 0;\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tbuf[3] = BPDU_TYPE_CONFIG;\n\tbuf[4] = (bpdu->topology_change ? 0x01 : 0) |\n\t\t(bpdu->topology_change_ack ? 0x80 : 0);\n\tbuf[5] = bpdu->root.prio[0];\n\tbuf[6] = bpdu->root.prio[1];\n\tbuf[7] = bpdu->root.addr[0];\n\tbuf[8] = bpdu->root.addr[1];\n\tbuf[9] = bpdu->root.addr[2];\n\tbuf[10] = bpdu->root.addr[3];\n\tbuf[11] = bpdu->root.addr[4];\n\tbuf[12] = bpdu->root.addr[5];\n\tbuf[13] = (bpdu->root_path_cost >> 24) & 0xFF;\n\tbuf[14] = (bpdu->root_path_cost >> 16) & 0xFF;\n\tbuf[15] = (bpdu->root_path_cost >> 8) & 0xFF;\n\tbuf[16] = bpdu->root_path_cost & 0xFF;\n\tbuf[17] = bpdu->bridge_id.prio[0];\n\tbuf[18] = bpdu->bridge_id.prio[1];\n\tbuf[19] = bpdu->bridge_id.addr[0];\n\tbuf[20] = bpdu->bridge_id.addr[1];\n\tbuf[21] = bpdu->bridge_id.addr[2];\n\tbuf[22] = bpdu->bridge_id.addr[3];\n\tbuf[23] = bpdu->bridge_id.addr[4];\n\tbuf[24] = bpdu->bridge_id.addr[5];\n\tbuf[25] = (bpdu->port_id >> 8) & 0xFF;\n\tbuf[26] = bpdu->port_id & 0xFF;\n\n\tbr_set_ticks(buf+27, bpdu->message_age);\n\tbr_set_ticks(buf+29, bpdu->max_age);\n\tbr_set_ticks(buf+31, bpdu->hello_time);\n\tbr_set_ticks(buf+33, bpdu->forward_delay);\n\n\tbr_send_bpdu(p, buf, 35);\n\n\tp->stp_xstats.tx_bpdu++;\n}\n\n \nvoid br_send_tcn_bpdu(struct net_bridge_port *p)\n{\n\tunsigned char buf[4];\n\n\tif (p->br->stp_enabled != BR_KERNEL_STP)\n\t\treturn;\n\n\tbuf[0] = 0;\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tbuf[3] = BPDU_TYPE_TCN;\n\tbr_send_bpdu(p, buf, 4);\n\n\tp->stp_xstats.tx_tcn++;\n}\n\n \nvoid br_stp_rcv(const struct stp_proto *proto, struct sk_buff *skb,\n\t\tstruct net_device *dev)\n{\n\tstruct net_bridge_port *p;\n\tstruct net_bridge *br;\n\tconst unsigned char *buf;\n\n\tif (!pskb_may_pull(skb, 4))\n\t\tgoto err;\n\n\t \n\tbuf = skb->data;\n\tif (buf[0] != 0 || buf[1] != 0 || buf[2] != 0)\n\t\tgoto err;\n\n\tp = br_port_get_check_rcu(dev);\n\tif (!p)\n\t\tgoto err;\n\n\tbr = p->br;\n\tspin_lock(&br->lock);\n\n\tif (br->stp_enabled != BR_KERNEL_STP)\n\t\tgoto out;\n\n\tif (!(br->dev->flags & IFF_UP))\n\t\tgoto out;\n\n\tif (p->state == BR_STATE_DISABLED)\n\t\tgoto out;\n\n\tif (!ether_addr_equal(eth_hdr(skb)->h_dest, br->group_addr))\n\t\tgoto out;\n\n\tif (p->flags & BR_BPDU_GUARD) {\n\t\tbr_notice(br, \"BPDU received on blocked port %u(%s)\\n\",\n\t\t\t  (unsigned int) p->port_no, p->dev->name);\n\t\tbr_stp_disable_port(p);\n\t\tgoto out;\n\t}\n\n\tbuf = skb_pull(skb, 3);\n\n\tif (buf[0] == BPDU_TYPE_CONFIG) {\n\t\tstruct br_config_bpdu bpdu;\n\n\t\tif (!pskb_may_pull(skb, 32))\n\t\t\tgoto out;\n\n\t\tbuf = skb->data;\n\t\tbpdu.topology_change = (buf[1] & 0x01) ? 1 : 0;\n\t\tbpdu.topology_change_ack = (buf[1] & 0x80) ? 1 : 0;\n\n\t\tbpdu.root.prio[0] = buf[2];\n\t\tbpdu.root.prio[1] = buf[3];\n\t\tbpdu.root.addr[0] = buf[4];\n\t\tbpdu.root.addr[1] = buf[5];\n\t\tbpdu.root.addr[2] = buf[6];\n\t\tbpdu.root.addr[3] = buf[7];\n\t\tbpdu.root.addr[4] = buf[8];\n\t\tbpdu.root.addr[5] = buf[9];\n\t\tbpdu.root_path_cost =\n\t\t\t(buf[10] << 24) |\n\t\t\t(buf[11] << 16) |\n\t\t\t(buf[12] << 8) |\n\t\t\tbuf[13];\n\t\tbpdu.bridge_id.prio[0] = buf[14];\n\t\tbpdu.bridge_id.prio[1] = buf[15];\n\t\tbpdu.bridge_id.addr[0] = buf[16];\n\t\tbpdu.bridge_id.addr[1] = buf[17];\n\t\tbpdu.bridge_id.addr[2] = buf[18];\n\t\tbpdu.bridge_id.addr[3] = buf[19];\n\t\tbpdu.bridge_id.addr[4] = buf[20];\n\t\tbpdu.bridge_id.addr[5] = buf[21];\n\t\tbpdu.port_id = (buf[22] << 8) | buf[23];\n\n\t\tbpdu.message_age = br_get_ticks(buf+24);\n\t\tbpdu.max_age = br_get_ticks(buf+26);\n\t\tbpdu.hello_time = br_get_ticks(buf+28);\n\t\tbpdu.forward_delay = br_get_ticks(buf+30);\n\n\t\tif (bpdu.message_age > bpdu.max_age) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tbr_notice(p->br,\n\t\t\t\t\t  \"port %u config from %pM\"\n\t\t\t\t\t  \" (message_age %ul > max_age %ul)\\n\",\n\t\t\t\t\t  p->port_no,\n\t\t\t\t\t  eth_hdr(skb)->h_source,\n\t\t\t\t\t  bpdu.message_age, bpdu.max_age);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbr_received_config_bpdu(p, &bpdu);\n\t} else if (buf[0] == BPDU_TYPE_TCN) {\n\t\tbr_received_tcn_bpdu(p);\n\t}\n out:\n\tspin_unlock(&br->lock);\n err:\n\tkfree_skb(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}