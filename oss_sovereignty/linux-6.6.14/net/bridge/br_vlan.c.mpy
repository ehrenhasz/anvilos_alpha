{
  "module_name": "br_vlan.c",
  "hash_id": "a121c62e02167c9d21bce2dac3de0ebc0b8cb8069c711caf4d557685d1cd427c",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_vlan.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <net/switchdev.h>\n\n#include \"br_private.h\"\n#include \"br_private_tunnel.h\"\n\nstatic void nbp_vlan_set_vlan_dev_state(struct net_bridge_port *p, u16 vid);\n\nstatic inline int br_vlan_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t      const void *ptr)\n{\n\tconst struct net_bridge_vlan *vle = ptr;\n\tu16 vid = *(u16 *)arg->key;\n\n\treturn vle->vid != vid;\n}\n\nstatic const struct rhashtable_params br_vlan_rht_params = {\n\t.head_offset = offsetof(struct net_bridge_vlan, vnode),\n\t.key_offset = offsetof(struct net_bridge_vlan, vid),\n\t.key_len = sizeof(u16),\n\t.nelem_hint = 3,\n\t.max_size = VLAN_N_VID,\n\t.obj_cmpfn = br_vlan_cmp,\n\t.automatic_shrinking = true,\n};\n\nstatic struct net_bridge_vlan *br_vlan_lookup(struct rhashtable *tbl, u16 vid)\n{\n\treturn rhashtable_lookup_fast(tbl, &vid, br_vlan_rht_params);\n}\n\nstatic void __vlan_add_pvid(struct net_bridge_vlan_group *vg,\n\t\t\t    const struct net_bridge_vlan *v)\n{\n\tif (vg->pvid == v->vid)\n\t\treturn;\n\n\tsmp_wmb();\n\tbr_vlan_set_pvid_state(vg, v->state);\n\tvg->pvid = v->vid;\n}\n\nstatic void __vlan_delete_pvid(struct net_bridge_vlan_group *vg, u16 vid)\n{\n\tif (vg->pvid != vid)\n\t\treturn;\n\n\tsmp_wmb();\n\tvg->pvid = 0;\n}\n\n \nstatic bool __vlan_flags_update(struct net_bridge_vlan *v, u16 flags,\n\t\t\t\tbool commit)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tbool change;\n\n\tif (br_vlan_is_master(v))\n\t\tvg = br_vlan_group(v->br);\n\telse\n\t\tvg = nbp_vlan_group(v->port);\n\n\t \n\tchange = !!(flags & BRIDGE_VLAN_INFO_PVID) == !!(vg->pvid != v->vid) ||\n\t\t ((flags ^ v->flags) & BRIDGE_VLAN_INFO_UNTAGGED);\n\n\tif (!commit)\n\t\tgoto out;\n\n\tif (flags & BRIDGE_VLAN_INFO_PVID)\n\t\t__vlan_add_pvid(vg, v);\n\telse\n\t\t__vlan_delete_pvid(vg, v->vid);\n\n\tif (flags & BRIDGE_VLAN_INFO_UNTAGGED)\n\t\tv->flags |= BRIDGE_VLAN_INFO_UNTAGGED;\n\telse\n\t\tv->flags &= ~BRIDGE_VLAN_INFO_UNTAGGED;\n\nout:\n\treturn change;\n}\n\nstatic bool __vlan_flags_would_change(struct net_bridge_vlan *v, u16 flags)\n{\n\treturn __vlan_flags_update(v, flags, false);\n}\n\nstatic void __vlan_flags_commit(struct net_bridge_vlan *v, u16 flags)\n{\n\t__vlan_flags_update(v, flags, true);\n}\n\nstatic int __vlan_vid_add(struct net_device *dev, struct net_bridge *br,\n\t\t\t  struct net_bridge_vlan *v, u16 flags,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\t \n\terr = br_switchdev_port_vlan_add(dev, v->vid, flags, false, extack);\n\tif (err == -EOPNOTSUPP)\n\t\treturn vlan_vid_add(dev, br->vlan_proto, v->vid);\n\tv->priv_flags |= BR_VLFLAG_ADDED_BY_SWITCHDEV;\n\treturn err;\n}\n\nstatic void __vlan_add_list(struct net_bridge_vlan *v)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct list_head *headp, *hpos;\n\tstruct net_bridge_vlan *vent;\n\n\tif (br_vlan_is_master(v))\n\t\tvg = br_vlan_group(v->br);\n\telse\n\t\tvg = nbp_vlan_group(v->port);\n\n\theadp = &vg->vlan_list;\n\tlist_for_each_prev(hpos, headp) {\n\t\tvent = list_entry(hpos, struct net_bridge_vlan, vlist);\n\t\tif (v->vid >= vent->vid)\n\t\t\tbreak;\n\t}\n\tlist_add_rcu(&v->vlist, hpos);\n}\n\nstatic void __vlan_del_list(struct net_bridge_vlan *v)\n{\n\tlist_del_rcu(&v->vlist);\n}\n\nstatic int __vlan_vid_del(struct net_device *dev, struct net_bridge *br,\n\t\t\t  const struct net_bridge_vlan *v)\n{\n\tint err;\n\n\t \n\terr = br_switchdev_port_vlan_del(dev, v->vid);\n\tif (!(v->priv_flags & BR_VLFLAG_ADDED_BY_SWITCHDEV))\n\t\tvlan_vid_del(dev, br->vlan_proto, v->vid);\n\treturn err == -EOPNOTSUPP ? 0 : err;\n}\n\n \nstatic struct net_bridge_vlan *\nbr_vlan_get_master(struct net_bridge *br, u16 vid,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *masterv;\n\n\tvg = br_vlan_group(br);\n\tmasterv = br_vlan_find(vg, vid);\n\tif (!masterv) {\n\t\tbool changed;\n\n\t\t \n\t\tif (br_vlan_add(br, vid, 0, &changed, extack))\n\t\t\treturn NULL;\n\t\tmasterv = br_vlan_find(vg, vid);\n\t\tif (WARN_ON(!masterv))\n\t\t\treturn NULL;\n\t\trefcount_set(&masterv->refcnt, 1);\n\t\treturn masterv;\n\t}\n\trefcount_inc(&masterv->refcnt);\n\n\treturn masterv;\n}\n\nstatic void br_master_vlan_rcu_free(struct rcu_head *rcu)\n{\n\tstruct net_bridge_vlan *v;\n\n\tv = container_of(rcu, struct net_bridge_vlan, rcu);\n\tWARN_ON(!br_vlan_is_master(v));\n\tfree_percpu(v->stats);\n\tv->stats = NULL;\n\tkfree(v);\n}\n\nstatic void br_vlan_put_master(struct net_bridge_vlan *masterv)\n{\n\tstruct net_bridge_vlan_group *vg;\n\n\tif (!br_vlan_is_master(masterv))\n\t\treturn;\n\n\tvg = br_vlan_group(masterv->br);\n\tif (refcount_dec_and_test(&masterv->refcnt)) {\n\t\trhashtable_remove_fast(&vg->vlan_hash,\n\t\t\t\t       &masterv->vnode, br_vlan_rht_params);\n\t\t__vlan_del_list(masterv);\n\t\tbr_multicast_toggle_one_vlan(masterv, false);\n\t\tbr_multicast_ctx_deinit(&masterv->br_mcast_ctx);\n\t\tcall_rcu(&masterv->rcu, br_master_vlan_rcu_free);\n\t}\n}\n\nstatic void nbp_vlan_rcu_free(struct rcu_head *rcu)\n{\n\tstruct net_bridge_vlan *v;\n\n\tv = container_of(rcu, struct net_bridge_vlan, rcu);\n\tWARN_ON(br_vlan_is_master(v));\n\t \n\tif (v->priv_flags & BR_VLFLAG_PER_PORT_STATS)\n\t\tfree_percpu(v->stats);\n\tv->stats = NULL;\n\tkfree(v);\n}\n\nstatic void br_vlan_init_state(struct net_bridge_vlan *v)\n{\n\tstruct net_bridge *br;\n\n\tif (br_vlan_is_master(v))\n\t\tbr = v->br;\n\telse\n\t\tbr = v->port->br;\n\n\tif (br_opt_get(br, BROPT_MST_ENABLED)) {\n\t\tbr_mst_vlan_init_state(v);\n\t\treturn;\n\t}\n\n\tv->state = BR_STATE_FORWARDING;\n\tv->msti = 0;\n}\n\n \nstatic int __vlan_add(struct net_bridge_vlan *v, u16 flags,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan *masterv = NULL;\n\tstruct net_bridge_port *p = NULL;\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_device *dev;\n\tstruct net_bridge *br;\n\tint err;\n\n\tif (br_vlan_is_master(v)) {\n\t\tbr = v->br;\n\t\tdev = br->dev;\n\t\tvg = br_vlan_group(br);\n\t} else {\n\t\tp = v->port;\n\t\tbr = p->br;\n\t\tdev = p->dev;\n\t\tvg = nbp_vlan_group(p);\n\t}\n\n\tif (p) {\n\t\t \n\t\terr = __vlan_vid_add(dev, br, v, flags, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (flags & BRIDGE_VLAN_INFO_MASTER) {\n\t\t\tbool changed;\n\n\t\t\terr = br_vlan_add(br, v->vid,\n\t\t\t\t\t  flags | BRIDGE_VLAN_INFO_BRENTRY,\n\t\t\t\t\t  &changed, extack);\n\t\t\tif (err)\n\t\t\t\tgoto out_filt;\n\n\t\t\tif (changed)\n\t\t\t\tbr_vlan_notify(br, NULL, v->vid, 0,\n\t\t\t\t\t       RTM_NEWVLAN);\n\t\t}\n\n\t\tmasterv = br_vlan_get_master(br, v->vid, extack);\n\t\tif (!masterv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_filt;\n\t\t}\n\t\tv->brvlan = masterv;\n\t\tif (br_opt_get(br, BROPT_VLAN_STATS_PER_PORT)) {\n\t\t\tv->stats =\n\t\t\t     netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\t\t\tif (!v->stats) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_filt;\n\t\t\t}\n\t\t\tv->priv_flags |= BR_VLFLAG_PER_PORT_STATS;\n\t\t} else {\n\t\t\tv->stats = masterv->stats;\n\t\t}\n\t\tbr_multicast_port_ctx_init(p, v, &v->port_mcast_ctx);\n\t} else {\n\t\tif (br_vlan_should_use(v)) {\n\t\t\terr = br_switchdev_port_vlan_add(dev, v->vid, flags,\n\t\t\t\t\t\t\t false, extack);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbr_multicast_ctx_init(br, v, &v->br_mcast_ctx);\n\t\tv->priv_flags |= BR_VLFLAG_GLOBAL_MCAST_ENABLED;\n\t}\n\n\t \n\tif (br_vlan_should_use(v)) {\n\t\terr = br_fdb_add_local(br, p, dev->dev_addr, v->vid);\n\t\tif (err) {\n\t\t\tbr_err(br, \"failed insert local address into bridge forwarding table\\n\");\n\t\t\tgoto out_filt;\n\t\t}\n\t\tvg->num_vlans++;\n\t}\n\n\t \n\tbr_vlan_init_state(v);\n\n\terr = rhashtable_lookup_insert_fast(&vg->vlan_hash, &v->vnode,\n\t\t\t\t\t    br_vlan_rht_params);\n\tif (err)\n\t\tgoto out_fdb_insert;\n\n\t__vlan_add_list(v);\n\t__vlan_flags_commit(v, flags);\n\tbr_multicast_toggle_one_vlan(v, true);\n\n\tif (p)\n\t\tnbp_vlan_set_vlan_dev_state(p, v->vid);\nout:\n\treturn err;\n\nout_fdb_insert:\n\tif (br_vlan_should_use(v)) {\n\t\tbr_fdb_find_delete_local(br, p, dev->dev_addr, v->vid);\n\t\tvg->num_vlans--;\n\t}\n\nout_filt:\n\tif (p) {\n\t\t__vlan_vid_del(dev, br, v);\n\t\tif (masterv) {\n\t\t\tif (v->stats && masterv->stats != v->stats)\n\t\t\t\tfree_percpu(v->stats);\n\t\t\tv->stats = NULL;\n\n\t\t\tbr_vlan_put_master(masterv);\n\t\t\tv->brvlan = NULL;\n\t\t}\n\t} else {\n\t\tbr_switchdev_port_vlan_del(dev, v->vid);\n\t}\n\n\tgoto out;\n}\n\nstatic int __vlan_del(struct net_bridge_vlan *v)\n{\n\tstruct net_bridge_vlan *masterv = v;\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_port *p = NULL;\n\tint err = 0;\n\n\tif (br_vlan_is_master(v)) {\n\t\tvg = br_vlan_group(v->br);\n\t} else {\n\t\tp = v->port;\n\t\tvg = nbp_vlan_group(v->port);\n\t\tmasterv = v->brvlan;\n\t}\n\n\t__vlan_delete_pvid(vg, v->vid);\n\tif (p) {\n\t\terr = __vlan_vid_del(p->dev, p->br, v);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\terr = br_switchdev_port_vlan_del(v->br->dev, v->vid);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\tgoto out;\n\t\terr = 0;\n\t}\n\n\tif (br_vlan_should_use(v)) {\n\t\tv->flags &= ~BRIDGE_VLAN_INFO_BRENTRY;\n\t\tvg->num_vlans--;\n\t}\n\n\tif (masterv != v) {\n\t\tvlan_tunnel_info_del(vg, v);\n\t\trhashtable_remove_fast(&vg->vlan_hash, &v->vnode,\n\t\t\t\t       br_vlan_rht_params);\n\t\t__vlan_del_list(v);\n\t\tnbp_vlan_set_vlan_dev_state(p, v->vid);\n\t\tbr_multicast_toggle_one_vlan(v, false);\n\t\tbr_multicast_port_ctx_deinit(&v->port_mcast_ctx);\n\t\tcall_rcu(&v->rcu, nbp_vlan_rcu_free);\n\t}\n\n\tbr_vlan_put_master(masterv);\nout:\n\treturn err;\n}\n\nstatic void __vlan_group_free(struct net_bridge_vlan_group *vg)\n{\n\tWARN_ON(!list_empty(&vg->vlan_list));\n\trhashtable_destroy(&vg->vlan_hash);\n\tvlan_tunnel_deinit(vg);\n\tkfree(vg);\n}\n\nstatic void __vlan_flush(const struct net_bridge *br,\n\t\t\t const struct net_bridge_port *p,\n\t\t\t struct net_bridge_vlan_group *vg)\n{\n\tstruct net_bridge_vlan *vlan, *tmp;\n\tu16 v_start = 0, v_end = 0;\n\tint err;\n\n\t__vlan_delete_pvid(vg, vg->pvid);\n\tlist_for_each_entry_safe(vlan, tmp, &vg->vlan_list, vlist) {\n\t\t \n\t\tif (!v_start) {\n\t\t\tv_start = vlan->vid;\n\t\t} else if (vlan->vid - v_end != 1) {\n\t\t\t \n\t\t\tbr_vlan_notify(br, p, v_start, v_end, RTM_DELVLAN);\n\t\t\tv_start = vlan->vid;\n\t\t}\n\t\tv_end = vlan->vid;\n\n\t\terr = __vlan_del(vlan);\n\t\tif (err) {\n\t\t\tbr_err(br,\n\t\t\t       \"port %u(%s) failed to delete vlan %d: %pe\\n\",\n\t\t\t       (unsigned int) p->port_no, p->dev->name,\n\t\t\t       vlan->vid, ERR_PTR(err));\n\t\t}\n\t}\n\n\t \n\tif (v_start)\n\t\tbr_vlan_notify(br, p, v_start, v_end, RTM_DELVLAN);\n}\n\nstruct sk_buff *br_handle_vlan(struct net_bridge *br,\n\t\t\t       const struct net_bridge_port *p,\n\t\t\t       struct net_bridge_vlan_group *vg,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct pcpu_sw_netstats *stats;\n\tstruct net_bridge_vlan *v;\n\tu16 vid;\n\n\t \n\tif (!BR_INPUT_SKB_CB(skb)->vlan_filtered)\n\t\tgoto out;\n\n\t \n\tbr_vlan_get_tag(skb, &vid);\n\tv = br_vlan_find(vg, vid);\n\t \n\tif (!v || !br_vlan_should_use(v)) {\n\t\tif ((br->dev->flags & IFF_PROMISC) && skb->dev == br->dev) {\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (br_opt_get(br, BROPT_VLAN_STATS_ENABLED)) {\n\t\tstats = this_cpu_ptr(v->stats);\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tu64_stats_add(&stats->tx_bytes, skb->len);\n\t\tu64_stats_inc(&stats->tx_packets);\n\t\tu64_stats_update_end(&stats->syncp);\n\t}\n\n\t \n\tif (v->flags & BRIDGE_VLAN_INFO_UNTAGGED &&\n\t    !br_switchdev_frame_uses_tx_fwd_offload(skb))\n\t\t__vlan_hwaccel_clear_tag(skb);\n\n\tif (p && (p->flags & BR_VLAN_TUNNEL) &&\n\t    br_handle_egress_vlan_tunnel(skb, v)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\nout:\n\treturn skb;\n}\n\n \nstatic bool __allowed_ingress(const struct net_bridge *br,\n\t\t\t      struct net_bridge_vlan_group *vg,\n\t\t\t      struct sk_buff *skb, u16 *vid,\n\t\t\t      u8 *state,\n\t\t\t      struct net_bridge_vlan **vlan)\n{\n\tstruct pcpu_sw_netstats *stats;\n\tstruct net_bridge_vlan *v;\n\tbool tagged;\n\n\tBR_INPUT_SKB_CB(skb)->vlan_filtered = true;\n\t \n\tif (unlikely(!skb_vlan_tag_present(skb) &&\n\t\t     skb->protocol == br->vlan_proto)) {\n\t\tskb = skb_vlan_untag(skb);\n\t\tif (unlikely(!skb))\n\t\t\treturn false;\n\t}\n\n\tif (!br_vlan_get_tag(skb, vid)) {\n\t\t \n\t\tif (skb->vlan_proto != br->vlan_proto) {\n\t\t\t \n\t\t\tskb_push(skb, ETH_HLEN);\n\t\t\tskb = vlan_insert_tag_set_proto(skb, skb->vlan_proto,\n\t\t\t\t\t\t\tskb_vlan_tag_get(skb));\n\t\t\tif (unlikely(!skb))\n\t\t\t\treturn false;\n\n\t\t\tskb_pull(skb, ETH_HLEN);\n\t\t\tskb_reset_mac_len(skb);\n\t\t\t*vid = 0;\n\t\t\ttagged = false;\n\t\t} else {\n\t\t\ttagged = true;\n\t\t}\n\t} else {\n\t\t \n\t\ttagged = false;\n\t}\n\n\tif (!*vid) {\n\t\tu16 pvid = br_get_pvid(vg);\n\n\t\t \n\t\tif (!pvid)\n\t\t\tgoto drop;\n\n\t\t \n\t\t*vid = pvid;\n\t\tif (likely(!tagged))\n\t\t\t \n\t\t\t__vlan_hwaccel_put_tag(skb, br->vlan_proto, pvid);\n\t\telse\n\t\t\t \n\t\t\tskb->vlan_tci |= pvid;\n\n\t\t \n\t\tif (!br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) &&\n\t\t    !br_opt_get(br, BROPT_VLAN_STATS_ENABLED)) {\n\t\t\tif (*state == BR_STATE_FORWARDING) {\n\t\t\t\t*state = br_vlan_get_pvid_state(vg);\n\t\t\t\tif (!br_vlan_state_allowed(*state, true))\n\t\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tv = br_vlan_find(vg, *vid);\n\tif (!v || !br_vlan_should_use(v))\n\t\tgoto drop;\n\n\tif (*state == BR_STATE_FORWARDING) {\n\t\t*state = br_vlan_get_state(v);\n\t\tif (!br_vlan_state_allowed(*state, true))\n\t\t\tgoto drop;\n\t}\n\n\tif (br_opt_get(br, BROPT_VLAN_STATS_ENABLED)) {\n\t\tstats = this_cpu_ptr(v->stats);\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tu64_stats_add(&stats->rx_bytes, skb->len);\n\t\tu64_stats_inc(&stats->rx_packets);\n\t\tu64_stats_update_end(&stats->syncp);\n\t}\n\n\t*vlan = v;\n\n\treturn true;\n\ndrop:\n\tkfree_skb(skb);\n\treturn false;\n}\n\nbool br_allowed_ingress(const struct net_bridge *br,\n\t\t\tstruct net_bridge_vlan_group *vg, struct sk_buff *skb,\n\t\t\tu16 *vid, u8 *state,\n\t\t\tstruct net_bridge_vlan **vlan)\n{\n\t \n\t*vlan = NULL;\n\tif (!br_opt_get(br, BROPT_VLAN_ENABLED)) {\n\t\tBR_INPUT_SKB_CB(skb)->vlan_filtered = false;\n\t\treturn true;\n\t}\n\n\treturn __allowed_ingress(br, vg, skb, vid, state, vlan);\n}\n\n \nbool br_allowed_egress(struct net_bridge_vlan_group *vg,\n\t\t       const struct sk_buff *skb)\n{\n\tconst struct net_bridge_vlan *v;\n\tu16 vid;\n\n\t \n\tif (!BR_INPUT_SKB_CB(skb)->vlan_filtered)\n\t\treturn true;\n\n\tbr_vlan_get_tag(skb, &vid);\n\tv = br_vlan_find(vg, vid);\n\tif (v && br_vlan_should_use(v) &&\n\t    br_vlan_state_allowed(br_vlan_get_state(v), false))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nbool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge *br = p->br;\n\tstruct net_bridge_vlan *v;\n\n\t \n\tif (!br_opt_get(br, BROPT_VLAN_ENABLED))\n\t\treturn true;\n\n\tvg = nbp_vlan_group_rcu(p);\n\tif (!vg || !vg->num_vlans)\n\t\treturn false;\n\n\tif (!br_vlan_get_tag(skb, vid) && skb->vlan_proto != br->vlan_proto)\n\t\t*vid = 0;\n\n\tif (!*vid) {\n\t\t*vid = br_get_pvid(vg);\n\t\tif (!*vid ||\n\t\t    !br_vlan_state_allowed(br_vlan_get_pvid_state(vg), true))\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tv = br_vlan_find(vg, *vid);\n\tif (v && br_vlan_state_allowed(br_vlan_get_state(v), true))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int br_vlan_add_existing(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_vlan_group *vg,\n\t\t\t\tstruct net_bridge_vlan *vlan,\n\t\t\t\tu16 flags, bool *changed,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbool would_change = __vlan_flags_would_change(vlan, flags);\n\tbool becomes_brentry = false;\n\tint err;\n\n\tif (!br_vlan_is_brentry(vlan)) {\n\t\t \n\t\tif (!(flags & BRIDGE_VLAN_INFO_BRENTRY))\n\t\t\treturn -EINVAL;\n\n\t\tbecomes_brentry = true;\n\t}\n\n\t \n\tif (becomes_brentry || would_change) {\n\t\terr = br_switchdev_port_vlan_add(br->dev, vlan->vid, flags,\n\t\t\t\t\t\t would_change, extack);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\tif (becomes_brentry) {\n\t\t \n\t\terr = br_fdb_add_local(br, NULL, br->dev->dev_addr, vlan->vid);\n\t\tif (err) {\n\t\t\tbr_err(br, \"failed to insert local address into bridge forwarding table\\n\");\n\t\t\tgoto err_fdb_insert;\n\t\t}\n\n\t\trefcount_inc(&vlan->refcnt);\n\t\tvlan->flags |= BRIDGE_VLAN_INFO_BRENTRY;\n\t\tvg->num_vlans++;\n\t\t*changed = true;\n\t\tbr_multicast_toggle_one_vlan(vlan, true);\n\t}\n\n\t__vlan_flags_commit(vlan, flags);\n\tif (would_change)\n\t\t*changed = true;\n\n\treturn 0;\n\nerr_fdb_insert:\n\tbr_switchdev_port_vlan_del(br->dev, vlan->vid);\n\treturn err;\n}\n\n \nint br_vlan_add(struct net_bridge *br, u16 vid, u16 flags, bool *changed,\n\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *vlan;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\t*changed = false;\n\tvg = br_vlan_group(br);\n\tvlan = br_vlan_find(vg, vid);\n\tif (vlan)\n\t\treturn br_vlan_add_existing(br, vg, vlan, flags, changed,\n\t\t\t\t\t    extack);\n\n\tvlan = kzalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\n\tvlan->stats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!vlan->stats) {\n\t\tkfree(vlan);\n\t\treturn -ENOMEM;\n\t}\n\tvlan->vid = vid;\n\tvlan->flags = flags | BRIDGE_VLAN_INFO_MASTER;\n\tvlan->flags &= ~BRIDGE_VLAN_INFO_PVID;\n\tvlan->br = br;\n\tif (flags & BRIDGE_VLAN_INFO_BRENTRY)\n\t\trefcount_set(&vlan->refcnt, 1);\n\tret = __vlan_add(vlan, flags, extack);\n\tif (ret) {\n\t\tfree_percpu(vlan->stats);\n\t\tkfree(vlan);\n\t} else {\n\t\t*changed = true;\n\t}\n\n\treturn ret;\n}\n\n \nint br_vlan_delete(struct net_bridge *br, u16 vid)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\n\tASSERT_RTNL();\n\n\tvg = br_vlan_group(br);\n\tv = br_vlan_find(vg, vid);\n\tif (!v || !br_vlan_is_brentry(v))\n\t\treturn -ENOENT;\n\n\tbr_fdb_find_delete_local(br, NULL, br->dev->dev_addr, vid);\n\tbr_fdb_delete_by_port(br, NULL, vid, 0);\n\n\tvlan_tunnel_info_del(vg, v);\n\n\treturn __vlan_del(v);\n}\n\nvoid br_vlan_flush(struct net_bridge *br)\n{\n\tstruct net_bridge_vlan_group *vg;\n\n\tASSERT_RTNL();\n\n\tvg = br_vlan_group(br);\n\t__vlan_flush(br, NULL, vg);\n\tRCU_INIT_POINTER(br->vlgrp, NULL);\n\tsynchronize_rcu();\n\t__vlan_group_free(vg);\n}\n\nstruct net_bridge_vlan *br_vlan_find(struct net_bridge_vlan_group *vg, u16 vid)\n{\n\tif (!vg)\n\t\treturn NULL;\n\n\treturn br_vlan_lookup(&vg->vlan_hash, vid);\n}\n\n \nstatic void recalculate_group_addr(struct net_bridge *br)\n{\n\tif (br_opt_get(br, BROPT_GROUP_ADDR_SET))\n\t\treturn;\n\n\tspin_lock_bh(&br->lock);\n\tif (!br_opt_get(br, BROPT_VLAN_ENABLED) ||\n\t    br->vlan_proto == htons(ETH_P_8021Q)) {\n\t\t \n\t\tbr->group_addr[5] = 0x00;\n\t} else {  \n\t\t \n\t\tbr->group_addr[5] = 0x08;\n\t}\n\tspin_unlock_bh(&br->lock);\n}\n\n \nvoid br_recalculate_fwd_mask(struct net_bridge *br)\n{\n\tif (!br_opt_get(br, BROPT_VLAN_ENABLED) ||\n\t    br->vlan_proto == htons(ETH_P_8021Q))\n\t\tbr->group_fwd_mask_required = BR_GROUPFWD_DEFAULT;\n\telse  \n\t\tbr->group_fwd_mask_required = BR_GROUPFWD_8021AD &\n\t\t\t\t\t      ~(1u << br->group_addr[5]);\n}\n\nint br_vlan_filter_toggle(struct net_bridge *br, unsigned long val,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_attr attr = {\n\t\t.orig_dev = br->dev,\n\t\t.id = SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING,\n\t\t.flags = SWITCHDEV_F_SKIP_EOPNOTSUPP,\n\t\t.u.vlan_filtering = val,\n\t};\n\tint err;\n\n\tif (br_opt_get(br, BROPT_VLAN_ENABLED) == !!val)\n\t\treturn 0;\n\n\tbr_opt_toggle(br, BROPT_VLAN_ENABLED, !!val);\n\n\terr = switchdev_port_attr_set(br->dev, &attr, extack);\n\tif (err && err != -EOPNOTSUPP) {\n\t\tbr_opt_toggle(br, BROPT_VLAN_ENABLED, !val);\n\t\treturn err;\n\t}\n\n\tbr_manage_promisc(br);\n\trecalculate_group_addr(br);\n\tbr_recalculate_fwd_mask(br);\n\tif (!val && br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED)) {\n\t\tbr_info(br, \"vlan filtering disabled, automatically disabling multicast vlan snooping\\n\");\n\t\tbr_multicast_toggle_vlan_snooping(br, false, NULL);\n\t}\n\n\treturn 0;\n}\n\nbool br_vlan_enabled(const struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\treturn br_opt_get(br, BROPT_VLAN_ENABLED);\n}\nEXPORT_SYMBOL_GPL(br_vlan_enabled);\n\nint br_vlan_get_proto(const struct net_device *dev, u16 *p_proto)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\t*p_proto = ntohs(br->vlan_proto);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(br_vlan_get_proto);\n\nint __br_vlan_set_proto(struct net_bridge *br, __be16 proto,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct switchdev_attr attr = {\n\t\t.orig_dev = br->dev,\n\t\t.id = SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL,\n\t\t.flags = SWITCHDEV_F_SKIP_EOPNOTSUPP,\n\t\t.u.vlan_protocol = ntohs(proto),\n\t};\n\tint err = 0;\n\tstruct net_bridge_port *p;\n\tstruct net_bridge_vlan *vlan;\n\tstruct net_bridge_vlan_group *vg;\n\t__be16 oldproto = br->vlan_proto;\n\n\tif (br->vlan_proto == proto)\n\t\treturn 0;\n\n\terr = switchdev_port_attr_set(br->dev, &attr, extack);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\t \n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tvg = nbp_vlan_group(p);\n\t\tlist_for_each_entry(vlan, &vg->vlan_list, vlist) {\n\t\t\tif (vlan->priv_flags & BR_VLFLAG_ADDED_BY_SWITCHDEV)\n\t\t\t\tcontinue;\n\t\t\terr = vlan_vid_add(p->dev, proto, vlan->vid);\n\t\t\tif (err)\n\t\t\t\tgoto err_filt;\n\t\t}\n\t}\n\n\tbr->vlan_proto = proto;\n\n\trecalculate_group_addr(br);\n\tbr_recalculate_fwd_mask(br);\n\n\t \n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tvg = nbp_vlan_group(p);\n\t\tlist_for_each_entry(vlan, &vg->vlan_list, vlist) {\n\t\t\tif (vlan->priv_flags & BR_VLFLAG_ADDED_BY_SWITCHDEV)\n\t\t\t\tcontinue;\n\t\t\tvlan_vid_del(p->dev, oldproto, vlan->vid);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_filt:\n\tattr.u.vlan_protocol = ntohs(oldproto);\n\tswitchdev_port_attr_set(br->dev, &attr, NULL);\n\n\tlist_for_each_entry_continue_reverse(vlan, &vg->vlan_list, vlist) {\n\t\tif (vlan->priv_flags & BR_VLFLAG_ADDED_BY_SWITCHDEV)\n\t\t\tcontinue;\n\t\tvlan_vid_del(p->dev, proto, vlan->vid);\n\t}\n\n\tlist_for_each_entry_continue_reverse(p, &br->port_list, list) {\n\t\tvg = nbp_vlan_group(p);\n\t\tlist_for_each_entry(vlan, &vg->vlan_list, vlist) {\n\t\t\tif (vlan->priv_flags & BR_VLFLAG_ADDED_BY_SWITCHDEV)\n\t\t\t\tcontinue;\n\t\t\tvlan_vid_del(p->dev, proto, vlan->vid);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint br_vlan_set_proto(struct net_bridge *br, unsigned long val,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tif (!eth_type_vlan(htons(val)))\n\t\treturn -EPROTONOSUPPORT;\n\n\treturn __br_vlan_set_proto(br, htons(val), extack);\n}\n\nint br_vlan_set_stats(struct net_bridge *br, unsigned long val)\n{\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\tbr_opt_toggle(br, BROPT_VLAN_STATS_ENABLED, !!val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint br_vlan_set_stats_per_port(struct net_bridge *br, unsigned long val)\n{\n\tstruct net_bridge_port *p;\n\n\t \n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tstruct net_bridge_vlan_group *vg = nbp_vlan_group(p);\n\n\t\tif (vg->num_vlans)\n\t\t\treturn -EBUSY;\n\t}\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\tbr_opt_toggle(br, BROPT_VLAN_STATS_PER_PORT, !!val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool vlan_default_pvid(struct net_bridge_vlan_group *vg, u16 vid)\n{\n\tstruct net_bridge_vlan *v;\n\n\tif (vid != vg->pvid)\n\t\treturn false;\n\n\tv = br_vlan_lookup(&vg->vlan_hash, vid);\n\tif (v && br_vlan_should_use(v) &&\n\t    (v->flags & BRIDGE_VLAN_INFO_UNTAGGED))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void br_vlan_disable_default_pvid(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\tu16 pvid = br->default_pvid;\n\n\t \n\tif (vlan_default_pvid(br_vlan_group(br), pvid)) {\n\t\tif (!br_vlan_delete(br, pvid))\n\t\t\tbr_vlan_notify(br, NULL, pvid, 0, RTM_DELVLAN);\n\t}\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (vlan_default_pvid(nbp_vlan_group(p), pvid) &&\n\t\t    !nbp_vlan_delete(p, pvid))\n\t\t\tbr_vlan_notify(br, p, pvid, 0, RTM_DELVLAN);\n\t}\n\n\tbr->default_pvid = 0;\n}\n\nint __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tconst struct net_bridge_vlan *pvent;\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_port *p;\n\tunsigned long *changed;\n\tbool vlchange;\n\tu16 old_pvid;\n\tint err = 0;\n\n\tif (!pvid) {\n\t\tbr_vlan_disable_default_pvid(br);\n\t\treturn 0;\n\t}\n\n\tchanged = bitmap_zalloc(BR_MAX_PORTS, GFP_KERNEL);\n\tif (!changed)\n\t\treturn -ENOMEM;\n\n\told_pvid = br->default_pvid;\n\n\t \n\tvg = br_vlan_group(br);\n\tpvent = br_vlan_find(vg, pvid);\n\tif ((!old_pvid || vlan_default_pvid(vg, old_pvid)) &&\n\t    (!pvent || !br_vlan_should_use(pvent))) {\n\t\terr = br_vlan_add(br, pvid,\n\t\t\t\t  BRIDGE_VLAN_INFO_PVID |\n\t\t\t\t  BRIDGE_VLAN_INFO_UNTAGGED |\n\t\t\t\t  BRIDGE_VLAN_INFO_BRENTRY,\n\t\t\t\t  &vlchange, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (br_vlan_delete(br, old_pvid))\n\t\t\tbr_vlan_notify(br, NULL, old_pvid, 0, RTM_DELVLAN);\n\t\tbr_vlan_notify(br, NULL, pvid, 0, RTM_NEWVLAN);\n\t\t__set_bit(0, changed);\n\t}\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\t \n\t\tvg = nbp_vlan_group(p);\n\t\tif ((old_pvid &&\n\t\t     !vlan_default_pvid(vg, old_pvid)) ||\n\t\t    br_vlan_find(vg, pvid))\n\t\t\tcontinue;\n\n\t\terr = nbp_vlan_add(p, pvid,\n\t\t\t\t   BRIDGE_VLAN_INFO_PVID |\n\t\t\t\t   BRIDGE_VLAN_INFO_UNTAGGED,\n\t\t\t\t   &vlchange, extack);\n\t\tif (err)\n\t\t\tgoto err_port;\n\t\tif (nbp_vlan_delete(p, old_pvid))\n\t\t\tbr_vlan_notify(br, p, old_pvid, 0, RTM_DELVLAN);\n\t\tbr_vlan_notify(p->br, p, pvid, 0, RTM_NEWVLAN);\n\t\t__set_bit(p->port_no, changed);\n\t}\n\n\tbr->default_pvid = pvid;\n\nout:\n\tbitmap_free(changed);\n\treturn err;\n\nerr_port:\n\tlist_for_each_entry_continue_reverse(p, &br->port_list, list) {\n\t\tif (!test_bit(p->port_no, changed))\n\t\t\tcontinue;\n\n\t\tif (old_pvid) {\n\t\t\tnbp_vlan_add(p, old_pvid,\n\t\t\t\t     BRIDGE_VLAN_INFO_PVID |\n\t\t\t\t     BRIDGE_VLAN_INFO_UNTAGGED,\n\t\t\t\t     &vlchange, NULL);\n\t\t\tbr_vlan_notify(p->br, p, old_pvid, 0, RTM_NEWVLAN);\n\t\t}\n\t\tnbp_vlan_delete(p, pvid);\n\t\tbr_vlan_notify(br, p, pvid, 0, RTM_DELVLAN);\n\t}\n\n\tif (test_bit(0, changed)) {\n\t\tif (old_pvid) {\n\t\t\tbr_vlan_add(br, old_pvid,\n\t\t\t\t    BRIDGE_VLAN_INFO_PVID |\n\t\t\t\t    BRIDGE_VLAN_INFO_UNTAGGED |\n\t\t\t\t    BRIDGE_VLAN_INFO_BRENTRY,\n\t\t\t\t    &vlchange, NULL);\n\t\t\tbr_vlan_notify(br, NULL, old_pvid, 0, RTM_NEWVLAN);\n\t\t}\n\t\tbr_vlan_delete(br, pvid);\n\t\tbr_vlan_notify(br, NULL, pvid, 0, RTM_DELVLAN);\n\t}\n\tgoto out;\n}\n\nint br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu16 pvid = val;\n\tint err = 0;\n\n\tif (val >= VLAN_VID_MASK)\n\t\treturn -EINVAL;\n\n\tif (pvid == br->default_pvid)\n\t\tgoto out;\n\n\t \n\tif (br_opt_get(br, BROPT_VLAN_ENABLED)) {\n\t\tpr_info_once(\"Please disable vlan filtering to change default_pvid\\n\");\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\terr = __br_vlan_set_default_pvid(br, pvid, extack);\nout:\n\treturn err;\n}\n\nint br_vlan_init(struct net_bridge *br)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tint ret = -ENOMEM;\n\n\tvg = kzalloc(sizeof(*vg), GFP_KERNEL);\n\tif (!vg)\n\t\tgoto out;\n\tret = rhashtable_init(&vg->vlan_hash, &br_vlan_rht_params);\n\tif (ret)\n\t\tgoto err_rhtbl;\n\tret = vlan_tunnel_init(vg);\n\tif (ret)\n\t\tgoto err_tunnel_init;\n\tINIT_LIST_HEAD(&vg->vlan_list);\n\tbr->vlan_proto = htons(ETH_P_8021Q);\n\tbr->default_pvid = 1;\n\trcu_assign_pointer(br->vlgrp, vg);\n\nout:\n\treturn ret;\n\nerr_tunnel_init:\n\trhashtable_destroy(&vg->vlan_hash);\nerr_rhtbl:\n\tkfree(vg);\n\n\tgoto out;\n}\n\nint nbp_vlan_init(struct net_bridge_port *p, struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_attr attr = {\n\t\t.orig_dev = p->br->dev,\n\t\t.id = SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING,\n\t\t.flags = SWITCHDEV_F_SKIP_EOPNOTSUPP,\n\t\t.u.vlan_filtering = br_opt_get(p->br, BROPT_VLAN_ENABLED),\n\t};\n\tstruct net_bridge_vlan_group *vg;\n\tint ret = -ENOMEM;\n\n\tvg = kzalloc(sizeof(struct net_bridge_vlan_group), GFP_KERNEL);\n\tif (!vg)\n\t\tgoto out;\n\n\tret = switchdev_port_attr_set(p->dev, &attr, extack);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\tgoto err_vlan_enabled;\n\n\tret = rhashtable_init(&vg->vlan_hash, &br_vlan_rht_params);\n\tif (ret)\n\t\tgoto err_rhtbl;\n\tret = vlan_tunnel_init(vg);\n\tif (ret)\n\t\tgoto err_tunnel_init;\n\tINIT_LIST_HEAD(&vg->vlan_list);\n\trcu_assign_pointer(p->vlgrp, vg);\n\tif (p->br->default_pvid) {\n\t\tbool changed;\n\n\t\tret = nbp_vlan_add(p, p->br->default_pvid,\n\t\t\t\t   BRIDGE_VLAN_INFO_PVID |\n\t\t\t\t   BRIDGE_VLAN_INFO_UNTAGGED,\n\t\t\t\t   &changed, extack);\n\t\tif (ret)\n\t\t\tgoto err_vlan_add;\n\t\tbr_vlan_notify(p->br, p, p->br->default_pvid, 0, RTM_NEWVLAN);\n\t}\nout:\n\treturn ret;\n\nerr_vlan_add:\n\tRCU_INIT_POINTER(p->vlgrp, NULL);\n\tsynchronize_rcu();\n\tvlan_tunnel_deinit(vg);\nerr_tunnel_init:\n\trhashtable_destroy(&vg->vlan_hash);\nerr_rhtbl:\nerr_vlan_enabled:\n\tkfree(vg);\n\n\tgoto out;\n}\n\n \nint nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags,\n\t\t bool *changed, struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan *vlan;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\t*changed = false;\n\tvlan = br_vlan_find(nbp_vlan_group(port), vid);\n\tif (vlan) {\n\t\tbool would_change = __vlan_flags_would_change(vlan, flags);\n\n\t\tif (would_change) {\n\t\t\t \n\t\t\tret = br_switchdev_port_vlan_add(port->dev, vid, flags,\n\t\t\t\t\t\t\t true, extack);\n\t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t__vlan_flags_commit(vlan, flags);\n\t\t*changed = would_change;\n\n\t\treturn 0;\n\t}\n\n\tvlan = kzalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\n\tvlan->vid = vid;\n\tvlan->port = port;\n\tret = __vlan_add(vlan, flags, extack);\n\tif (ret)\n\t\tkfree(vlan);\n\telse\n\t\t*changed = true;\n\n\treturn ret;\n}\n\n \nint nbp_vlan_delete(struct net_bridge_port *port, u16 vid)\n{\n\tstruct net_bridge_vlan *v;\n\n\tASSERT_RTNL();\n\n\tv = br_vlan_find(nbp_vlan_group(port), vid);\n\tif (!v)\n\t\treturn -ENOENT;\n\tbr_fdb_find_delete_local(port->br, port, port->dev->dev_addr, vid);\n\tbr_fdb_delete_by_port(port->br, port, vid, 0);\n\n\treturn __vlan_del(v);\n}\n\nvoid nbp_vlan_flush(struct net_bridge_port *port)\n{\n\tstruct net_bridge_vlan_group *vg;\n\n\tASSERT_RTNL();\n\n\tvg = nbp_vlan_group(port);\n\t__vlan_flush(port->br, port, vg);\n\tRCU_INIT_POINTER(port->vlgrp, NULL);\n\tsynchronize_rcu();\n\t__vlan_group_free(vg);\n}\n\nvoid br_vlan_get_stats(const struct net_bridge_vlan *v,\n\t\t       struct pcpu_sw_netstats *stats)\n{\n\tint i;\n\n\tmemset(stats, 0, sizeof(*stats));\n\tfor_each_possible_cpu(i) {\n\t\tu64 rxpackets, rxbytes, txpackets, txbytes;\n\t\tstruct pcpu_sw_netstats *cpu_stats;\n\t\tunsigned int start;\n\n\t\tcpu_stats = per_cpu_ptr(v->stats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&cpu_stats->syncp);\n\t\t\trxpackets = u64_stats_read(&cpu_stats->rx_packets);\n\t\t\trxbytes = u64_stats_read(&cpu_stats->rx_bytes);\n\t\t\ttxbytes = u64_stats_read(&cpu_stats->tx_bytes);\n\t\t\ttxpackets = u64_stats_read(&cpu_stats->tx_packets);\n\t\t} while (u64_stats_fetch_retry(&cpu_stats->syncp, start));\n\n\t\tu64_stats_add(&stats->rx_packets, rxpackets);\n\t\tu64_stats_add(&stats->rx_bytes, rxbytes);\n\t\tu64_stats_add(&stats->tx_bytes, txbytes);\n\t\tu64_stats_add(&stats->tx_packets, txpackets);\n\t}\n}\n\nint br_vlan_get_pvid(const struct net_device *dev, u16 *p_pvid)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_port *p;\n\n\tASSERT_RTNL();\n\tp = br_port_get_check_rtnl(dev);\n\tif (p)\n\t\tvg = nbp_vlan_group(p);\n\telse if (netif_is_bridge_master(dev))\n\t\tvg = br_vlan_group(netdev_priv(dev));\n\telse\n\t\treturn -EINVAL;\n\n\t*p_pvid = br_get_pvid(vg);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(br_vlan_get_pvid);\n\nint br_vlan_get_pvid_rcu(const struct net_device *dev, u16 *p_pvid)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_port *p;\n\n\tp = br_port_get_check_rcu(dev);\n\tif (p)\n\t\tvg = nbp_vlan_group_rcu(p);\n\telse if (netif_is_bridge_master(dev))\n\t\tvg = br_vlan_group_rcu(netdev_priv(dev));\n\telse\n\t\treturn -EINVAL;\n\n\t*p_pvid = br_get_pvid(vg);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(br_vlan_get_pvid_rcu);\n\nvoid br_vlan_fill_forward_path_pvid(struct net_bridge *br,\n\t\t\t\t    struct net_device_path_ctx *ctx,\n\t\t\t\t    struct net_device_path *path)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tint idx = ctx->num_vlans - 1;\n\tu16 vid;\n\n\tpath->bridge.vlan_mode = DEV_PATH_BR_VLAN_KEEP;\n\n\tif (!br_opt_get(br, BROPT_VLAN_ENABLED))\n\t\treturn;\n\n\tvg = br_vlan_group(br);\n\n\tif (idx >= 0 &&\n\t    ctx->vlan[idx].proto == br->vlan_proto) {\n\t\tvid = ctx->vlan[idx].id;\n\t} else {\n\t\tpath->bridge.vlan_mode = DEV_PATH_BR_VLAN_TAG;\n\t\tvid = br_get_pvid(vg);\n\t}\n\n\tpath->bridge.vlan_id = vid;\n\tpath->bridge.vlan_proto = br->vlan_proto;\n}\n\nint br_vlan_fill_forward_path_mode(struct net_bridge *br,\n\t\t\t\t   struct net_bridge_port *dst,\n\t\t\t\t   struct net_device_path *path)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\n\tif (!br_opt_get(br, BROPT_VLAN_ENABLED))\n\t\treturn 0;\n\n\tvg = nbp_vlan_group_rcu(dst);\n\tv = br_vlan_find(vg, path->bridge.vlan_id);\n\tif (!v || !br_vlan_should_use(v))\n\t\treturn -EINVAL;\n\n\tif (!(v->flags & BRIDGE_VLAN_INFO_UNTAGGED))\n\t\treturn 0;\n\n\tif (path->bridge.vlan_mode == DEV_PATH_BR_VLAN_TAG)\n\t\tpath->bridge.vlan_mode = DEV_PATH_BR_VLAN_KEEP;\n\telse if (v->priv_flags & BR_VLFLAG_ADDED_BY_SWITCHDEV)\n\t\tpath->bridge.vlan_mode = DEV_PATH_BR_VLAN_UNTAG_HW;\n\telse\n\t\tpath->bridge.vlan_mode = DEV_PATH_BR_VLAN_UNTAG;\n\n\treturn 0;\n}\n\nint br_vlan_get_info(const struct net_device *dev, u16 vid,\n\t\t     struct bridge_vlan_info *p_vinfo)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\tstruct net_bridge_port *p;\n\n\tASSERT_RTNL();\n\tp = br_port_get_check_rtnl(dev);\n\tif (p)\n\t\tvg = nbp_vlan_group(p);\n\telse if (netif_is_bridge_master(dev))\n\t\tvg = br_vlan_group(netdev_priv(dev));\n\telse\n\t\treturn -EINVAL;\n\n\tv = br_vlan_find(vg, vid);\n\tif (!v)\n\t\treturn -ENOENT;\n\n\tp_vinfo->vid = vid;\n\tp_vinfo->flags = v->flags;\n\tif (vid == br_get_pvid(vg))\n\t\tp_vinfo->flags |= BRIDGE_VLAN_INFO_PVID;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(br_vlan_get_info);\n\nint br_vlan_get_info_rcu(const struct net_device *dev, u16 vid,\n\t\t\t struct bridge_vlan_info *p_vinfo)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\tstruct net_bridge_port *p;\n\n\tp = br_port_get_check_rcu(dev);\n\tif (p)\n\t\tvg = nbp_vlan_group_rcu(p);\n\telse if (netif_is_bridge_master(dev))\n\t\tvg = br_vlan_group_rcu(netdev_priv(dev));\n\telse\n\t\treturn -EINVAL;\n\n\tv = br_vlan_find(vg, vid);\n\tif (!v)\n\t\treturn -ENOENT;\n\n\tp_vinfo->vid = vid;\n\tp_vinfo->flags = v->flags;\n\tif (vid == br_get_pvid(vg))\n\t\tp_vinfo->flags |= BRIDGE_VLAN_INFO_PVID;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(br_vlan_get_info_rcu);\n\nstatic int br_vlan_is_bind_vlan_dev(const struct net_device *dev)\n{\n\treturn is_vlan_dev(dev) &&\n\t\t!!(vlan_dev_priv(dev)->flags & VLAN_FLAG_BRIDGE_BINDING);\n}\n\nstatic int br_vlan_is_bind_vlan_dev_fn(struct net_device *dev,\n\t\t\t       __always_unused struct netdev_nested_priv *priv)\n{\n\treturn br_vlan_is_bind_vlan_dev(dev);\n}\n\nstatic bool br_vlan_has_upper_bind_vlan_dev(struct net_device *dev)\n{\n\tint found;\n\n\trcu_read_lock();\n\tfound = netdev_walk_all_upper_dev_rcu(dev, br_vlan_is_bind_vlan_dev_fn,\n\t\t\t\t\t      NULL);\n\trcu_read_unlock();\n\n\treturn !!found;\n}\n\nstruct br_vlan_bind_walk_data {\n\tu16 vid;\n\tstruct net_device *result;\n};\n\nstatic int br_vlan_match_bind_vlan_dev_fn(struct net_device *dev,\n\t\t\t\t\t  struct netdev_nested_priv *priv)\n{\n\tstruct br_vlan_bind_walk_data *data = priv->data;\n\tint found = 0;\n\n\tif (br_vlan_is_bind_vlan_dev(dev) &&\n\t    vlan_dev_priv(dev)->vlan_id == data->vid) {\n\t\tdata->result = dev;\n\t\tfound = 1;\n\t}\n\n\treturn found;\n}\n\nstatic struct net_device *\nbr_vlan_get_upper_bind_vlan_dev(struct net_device *dev, u16 vid)\n{\n\tstruct br_vlan_bind_walk_data data = {\n\t\t.vid = vid,\n\t};\n\tstruct netdev_nested_priv priv = {\n\t\t.data = (void *)&data,\n\t};\n\n\trcu_read_lock();\n\tnetdev_walk_all_upper_dev_rcu(dev, br_vlan_match_bind_vlan_dev_fn,\n\t\t\t\t      &priv);\n\trcu_read_unlock();\n\n\treturn data.result;\n}\n\nstatic bool br_vlan_is_dev_up(const struct net_device *dev)\n{\n\treturn  !!(dev->flags & IFF_UP) && netif_oper_up(dev);\n}\n\nstatic void br_vlan_set_vlan_dev_state(const struct net_bridge *br,\n\t\t\t\t       struct net_device *vlan_dev)\n{\n\tu16 vid = vlan_dev_priv(vlan_dev)->vlan_id;\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_port *p;\n\tbool has_carrier = false;\n\n\tif (!netif_carrier_ok(br->dev)) {\n\t\tnetif_carrier_off(vlan_dev);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tvg = nbp_vlan_group(p);\n\t\tif (br_vlan_find(vg, vid) && br_vlan_is_dev_up(p->dev)) {\n\t\t\thas_carrier = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_carrier)\n\t\tnetif_carrier_on(vlan_dev);\n\telse\n\t\tnetif_carrier_off(vlan_dev);\n}\n\nstatic void br_vlan_set_all_vlan_dev_state(struct net_bridge_port *p)\n{\n\tstruct net_bridge_vlan_group *vg = nbp_vlan_group(p);\n\tstruct net_bridge_vlan *vlan;\n\tstruct net_device *vlan_dev;\n\n\tlist_for_each_entry(vlan, &vg->vlan_list, vlist) {\n\t\tvlan_dev = br_vlan_get_upper_bind_vlan_dev(p->br->dev,\n\t\t\t\t\t\t\t   vlan->vid);\n\t\tif (vlan_dev) {\n\t\t\tif (br_vlan_is_dev_up(p->dev)) {\n\t\t\t\tif (netif_carrier_ok(p->br->dev))\n\t\t\t\t\tnetif_carrier_on(vlan_dev);\n\t\t\t} else {\n\t\t\t\tbr_vlan_set_vlan_dev_state(p->br, vlan_dev);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void br_vlan_upper_change(struct net_device *dev,\n\t\t\t\t struct net_device *upper_dev,\n\t\t\t\t bool linking)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\tif (!br_vlan_is_bind_vlan_dev(upper_dev))\n\t\treturn;\n\n\tif (linking) {\n\t\tbr_vlan_set_vlan_dev_state(br, upper_dev);\n\t\tbr_opt_toggle(br, BROPT_VLAN_BRIDGE_BINDING, true);\n\t} else {\n\t\tbr_opt_toggle(br, BROPT_VLAN_BRIDGE_BINDING,\n\t\t\t      br_vlan_has_upper_bind_vlan_dev(dev));\n\t}\n}\n\nstruct br_vlan_link_state_walk_data {\n\tstruct net_bridge *br;\n};\n\nstatic int br_vlan_link_state_change_fn(struct net_device *vlan_dev,\n\t\t\t\t\tstruct netdev_nested_priv *priv)\n{\n\tstruct br_vlan_link_state_walk_data *data = priv->data;\n\n\tif (br_vlan_is_bind_vlan_dev(vlan_dev))\n\t\tbr_vlan_set_vlan_dev_state(data->br, vlan_dev);\n\n\treturn 0;\n}\n\nstatic void br_vlan_link_state_change(struct net_device *dev,\n\t\t\t\t      struct net_bridge *br)\n{\n\tstruct br_vlan_link_state_walk_data data = {\n\t\t.br = br\n\t};\n\tstruct netdev_nested_priv priv = {\n\t\t.data = (void *)&data,\n\t};\n\n\trcu_read_lock();\n\tnetdev_walk_all_upper_dev_rcu(dev, br_vlan_link_state_change_fn,\n\t\t\t\t      &priv);\n\trcu_read_unlock();\n}\n\n \nstatic void nbp_vlan_set_vlan_dev_state(struct net_bridge_port *p, u16 vid)\n{\n\tstruct net_device *vlan_dev;\n\n\tif (!br_opt_get(p->br, BROPT_VLAN_BRIDGE_BINDING))\n\t\treturn;\n\n\tvlan_dev = br_vlan_get_upper_bind_vlan_dev(p->br->dev, vid);\n\tif (vlan_dev)\n\t\tbr_vlan_set_vlan_dev_state(p->br, vlan_dev);\n}\n\n \nint br_vlan_bridge_event(struct net_device *dev, unsigned long event, void *ptr)\n{\n\tstruct netdev_notifier_changeupper_info *info;\n\tstruct net_bridge *br = netdev_priv(dev);\n\tint vlcmd = 0, ret = 0;\n\tbool changed = false;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\tret = br_vlan_add(br, br->default_pvid,\n\t\t\t\t  BRIDGE_VLAN_INFO_PVID |\n\t\t\t\t  BRIDGE_VLAN_INFO_UNTAGGED |\n\t\t\t\t  BRIDGE_VLAN_INFO_BRENTRY, &changed, NULL);\n\t\tvlcmd = RTM_NEWVLAN;\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tchanged = !br_vlan_delete(br, br->default_pvid);\n\t\tvlcmd = RTM_DELVLAN;\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tinfo = ptr;\n\t\tbr_vlan_upper_change(dev, info->upper_dev, info->linking);\n\t\tbreak;\n\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_UP:\n\t\tif (!br_opt_get(br, BROPT_VLAN_BRIDGE_BINDING))\n\t\t\tbreak;\n\t\tbr_vlan_link_state_change(dev, br);\n\t\tbreak;\n\t}\n\tif (changed)\n\t\tbr_vlan_notify(br, NULL, br->default_pvid, 0, vlcmd);\n\n\treturn ret;\n}\n\n \nvoid br_vlan_port_event(struct net_bridge_port *p, unsigned long event)\n{\n\tif (!br_opt_get(p->br, BROPT_VLAN_BRIDGE_BINDING))\n\t\treturn;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_DOWN:\n\tcase NETDEV_UP:\n\t\tbr_vlan_set_all_vlan_dev_state(p);\n\t\tbreak;\n\t}\n}\n\nstatic bool br_vlan_stats_fill(struct sk_buff *skb,\n\t\t\t       const struct net_bridge_vlan *v)\n{\n\tstruct pcpu_sw_netstats stats;\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start(skb, BRIDGE_VLANDB_ENTRY_STATS);\n\tif (!nest)\n\t\treturn false;\n\n\tbr_vlan_get_stats(v, &stats);\n\tif (nla_put_u64_64bit(skb, BRIDGE_VLANDB_STATS_RX_BYTES,\n\t\t\t      u64_stats_read(&stats.rx_bytes),\n\t\t\t      BRIDGE_VLANDB_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, BRIDGE_VLANDB_STATS_RX_PACKETS,\n\t\t\t      u64_stats_read(&stats.rx_packets),\n\t\t\t      BRIDGE_VLANDB_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, BRIDGE_VLANDB_STATS_TX_BYTES,\n\t\t\t      u64_stats_read(&stats.tx_bytes),\n\t\t\t      BRIDGE_VLANDB_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, BRIDGE_VLANDB_STATS_TX_PACKETS,\n\t\t\t      u64_stats_read(&stats.tx_packets),\n\t\t\t      BRIDGE_VLANDB_STATS_PAD))\n\t\tgoto out_err;\n\n\tnla_nest_end(skb, nest);\n\n\treturn true;\n\nout_err:\n\tnla_nest_cancel(skb, nest);\n\treturn false;\n}\n\n \nstatic bool br_vlan_fill_vids(struct sk_buff *skb, u16 vid, u16 vid_range,\n\t\t\t      const struct net_bridge_vlan *v_opts,\n\t\t\t      const struct net_bridge_port *p,\n\t\t\t      u16 flags,\n\t\t\t      bool dump_stats)\n{\n\tstruct bridge_vlan_info info;\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start(skb, BRIDGE_VLANDB_ENTRY);\n\tif (!nest)\n\t\treturn false;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.vid = vid;\n\tif (flags & BRIDGE_VLAN_INFO_UNTAGGED)\n\t\tinfo.flags |= BRIDGE_VLAN_INFO_UNTAGGED;\n\tif (flags & BRIDGE_VLAN_INFO_PVID)\n\t\tinfo.flags |= BRIDGE_VLAN_INFO_PVID;\n\n\tif (nla_put(skb, BRIDGE_VLANDB_ENTRY_INFO, sizeof(info), &info))\n\t\tgoto out_err;\n\n\tif (vid_range && vid < vid_range &&\n\t    !(flags & BRIDGE_VLAN_INFO_PVID) &&\n\t    nla_put_u16(skb, BRIDGE_VLANDB_ENTRY_RANGE, vid_range))\n\t\tgoto out_err;\n\n\tif (v_opts) {\n\t\tif (!br_vlan_opts_fill(skb, v_opts, p))\n\t\t\tgoto out_err;\n\n\t\tif (dump_stats && !br_vlan_stats_fill(skb, v_opts))\n\t\t\tgoto out_err;\n\t}\n\n\tnla_nest_end(skb, nest);\n\n\treturn true;\n\nout_err:\n\tnla_nest_cancel(skb, nest);\n\treturn false;\n}\n\nstatic size_t rtnl_vlan_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct br_vlan_msg))\n\t\t+ nla_total_size(0)  \n\t\t+ nla_total_size(sizeof(u16))  \n\t\t+ nla_total_size(sizeof(struct bridge_vlan_info))  \n\t\t+ br_vlan_opts_nl_size();  \n}\n\nvoid br_vlan_notify(const struct net_bridge *br,\n\t\t    const struct net_bridge_port *p,\n\t\t    u16 vid, u16 vid_range,\n\t\t    int cmd)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v = NULL;\n\tstruct br_vlan_msg *bvm;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\tstruct net *net;\n\tu16 flags = 0;\n\tint ifindex;\n\n\t \n\tASSERT_RTNL();\n\n\tif (p) {\n\t\tifindex = p->dev->ifindex;\n\t\tvg = nbp_vlan_group(p);\n\t\tnet = dev_net(p->dev);\n\t} else {\n\t\tifindex = br->dev->ifindex;\n\t\tvg = br_vlan_group(br);\n\t\tnet = dev_net(br->dev);\n\t}\n\n\tskb = nlmsg_new(rtnl_vlan_nlmsg_size(), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto out_err;\n\n\terr = -EMSGSIZE;\n\tnlh = nlmsg_put(skb, 0, 0, cmd, sizeof(*bvm), 0);\n\tif (!nlh)\n\t\tgoto out_err;\n\tbvm = nlmsg_data(nlh);\n\tmemset(bvm, 0, sizeof(*bvm));\n\tbvm->family = AF_BRIDGE;\n\tbvm->ifindex = ifindex;\n\n\tswitch (cmd) {\n\tcase RTM_NEWVLAN:\n\t\t \n\t\tv = br_vlan_find(vg, vid);\n\t\tif (!v || !br_vlan_should_use(v))\n\t\t\tgoto out_kfree;\n\n\t\tflags = v->flags;\n\t\tif (br_get_pvid(vg) == v->vid)\n\t\t\tflags |= BRIDGE_VLAN_INFO_PVID;\n\t\tbreak;\n\tcase RTM_DELVLAN:\n\t\tbreak;\n\tdefault:\n\t\tgoto out_kfree;\n\t}\n\n\tif (!br_vlan_fill_vids(skb, vid, vid_range, v, p, flags, false))\n\t\tgoto out_err;\n\n\tnlmsg_end(skb, nlh);\n\trtnl_notify(skb, net, 0, RTNLGRP_BRVLAN, NULL, GFP_KERNEL);\n\treturn;\n\nout_err:\n\trtnl_set_sk_err(net, RTNLGRP_BRVLAN, err);\nout_kfree:\n\tkfree_skb(skb);\n}\n\n \nbool br_vlan_can_enter_range(const struct net_bridge_vlan *v_curr,\n\t\t\t     const struct net_bridge_vlan *range_end)\n{\n\treturn v_curr->vid - range_end->vid == 1 &&\n\t       range_end->flags == v_curr->flags &&\n\t       br_vlan_opts_eq_range(v_curr, range_end);\n}\n\nstatic int br_vlan_dump_dev(const struct net_device *dev,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct netlink_callback *cb,\n\t\t\t    u32 dump_flags)\n{\n\tstruct net_bridge_vlan *v, *range_start = NULL, *range_end = NULL;\n\tbool dump_global = !!(dump_flags & BRIDGE_VLANDB_DUMPF_GLOBAL);\n\tbool dump_stats = !!(dump_flags & BRIDGE_VLANDB_DUMPF_STATS);\n\tstruct net_bridge_vlan_group *vg;\n\tint idx = 0, s_idx = cb->args[1];\n\tstruct nlmsghdr *nlh = NULL;\n\tstruct net_bridge_port *p;\n\tstruct br_vlan_msg *bvm;\n\tstruct net_bridge *br;\n\tint err = 0;\n\tu16 pvid;\n\n\tif (!netif_is_bridge_master(dev) && !netif_is_bridge_port(dev))\n\t\treturn -EINVAL;\n\n\tif (netif_is_bridge_master(dev)) {\n\t\tbr = netdev_priv(dev);\n\t\tvg = br_vlan_group_rcu(br);\n\t\tp = NULL;\n\t} else {\n\t\t \n\t\tif (dump_global)\n\t\t\treturn 0;\n\n\t\tp = br_port_get_rcu(dev);\n\t\tif (WARN_ON(!p))\n\t\t\treturn -EINVAL;\n\t\tvg = nbp_vlan_group_rcu(p);\n\t\tbr = p->br;\n\t}\n\n\tif (!vg)\n\t\treturn 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\tRTM_NEWVLAN, sizeof(*bvm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\tbvm = nlmsg_data(nlh);\n\tmemset(bvm, 0, sizeof(*bvm));\n\tbvm->family = PF_BRIDGE;\n\tbvm->ifindex = dev->ifindex;\n\tpvid = br_get_pvid(vg);\n\n\t \n\tlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\n\t\tif (!dump_global && !br_vlan_should_use(v))\n\t\t\tcontinue;\n\t\tif (idx < s_idx) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!range_start) {\n\t\t\trange_start = v;\n\t\t\trange_end = v;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dump_global) {\n\t\t\tif (br_vlan_global_opts_can_enter_range(v, range_end))\n\t\t\t\tgoto update_end;\n\t\t\tif (!br_vlan_global_opts_fill(skb, range_start->vid,\n\t\t\t\t\t\t      range_end->vid,\n\t\t\t\t\t\t      range_start)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tidx += range_end->vid - range_start->vid + 1;\n\n\t\t\trange_start = v;\n\t\t} else if (dump_stats || v->vid == pvid ||\n\t\t\t   !br_vlan_can_enter_range(v, range_end)) {\n\t\t\tu16 vlan_flags = br_vlan_flags(range_start, pvid);\n\n\t\t\tif (!br_vlan_fill_vids(skb, range_start->vid,\n\t\t\t\t\t       range_end->vid, range_start,\n\t\t\t\t\t       p, vlan_flags, dump_stats)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tidx += range_end->vid - range_start->vid + 1;\n\n\t\t\trange_start = v;\n\t\t}\nupdate_end:\n\t\trange_end = v;\n\t}\n\n\t \n\tif (!err && range_start) {\n\t\tif (dump_global &&\n\t\t    !br_vlan_global_opts_fill(skb, range_start->vid,\n\t\t\t\t\t      range_end->vid, range_start))\n\t\t\terr = -EMSGSIZE;\n\t\telse if (!dump_global &&\n\t\t\t !br_vlan_fill_vids(skb, range_start->vid,\n\t\t\t\t\t    range_end->vid, range_start,\n\t\t\t\t\t    p, br_vlan_flags(range_start, pvid),\n\t\t\t\t\t    dump_stats))\n\t\t\terr = -EMSGSIZE;\n\t}\n\n\tcb->args[1] = err ? idx : 0;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn err;\n}\n\nstatic const struct nla_policy br_vlan_db_dump_pol[BRIDGE_VLANDB_DUMP_MAX + 1] = {\n\t[BRIDGE_VLANDB_DUMP_FLAGS] = { .type = NLA_U32 },\n};\n\nstatic int br_vlan_rtm_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlattr *dtb[BRIDGE_VLANDB_DUMP_MAX + 1];\n\tint idx = 0, err = 0, s_idx = cb->args[0];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_vlan_msg *bvm;\n\tstruct net_device *dev;\n\tu32 dump_flags = 0;\n\n\terr = nlmsg_parse(cb->nlh, sizeof(*bvm), dtb, BRIDGE_VLANDB_DUMP_MAX,\n\t\t\t  br_vlan_db_dump_pol, cb->extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tbvm = nlmsg_data(cb->nlh);\n\tif (dtb[BRIDGE_VLANDB_DUMP_FLAGS])\n\t\tdump_flags = nla_get_u32(dtb[BRIDGE_VLANDB_DUMP_FLAGS]);\n\n\trcu_read_lock();\n\tif (bvm->ifindex) {\n\t\tdev = dev_get_by_index_rcu(net, bvm->ifindex);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = br_vlan_dump_dev(dev, skb, cb, dump_flags);\n\t\t \n\t\tif (err != -EMSGSIZE)\n\t\t\tgoto out_err;\n\t} else {\n\t\tfor_each_netdev_rcu(net, dev) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\terr = br_vlan_dump_dev(dev, skb, cb, dump_flags);\n\t\t\tif (err == -EMSGSIZE)\n\t\t\t\tbreak;\nskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\tcb->args[0] = idx;\n\trcu_read_unlock();\n\n\treturn skb->len;\n\nout_err:\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic const struct nla_policy br_vlan_db_policy[BRIDGE_VLANDB_ENTRY_MAX + 1] = {\n\t[BRIDGE_VLANDB_ENTRY_INFO]\t=\n\t\tNLA_POLICY_EXACT_LEN(sizeof(struct bridge_vlan_info)),\n\t[BRIDGE_VLANDB_ENTRY_RANGE]\t= { .type = NLA_U16 },\n\t[BRIDGE_VLANDB_ENTRY_STATE]\t= { .type = NLA_U8 },\n\t[BRIDGE_VLANDB_ENTRY_TUNNEL_INFO] = { .type = NLA_NESTED },\n\t[BRIDGE_VLANDB_ENTRY_MCAST_ROUTER]\t= { .type = NLA_U8 },\n\t[BRIDGE_VLANDB_ENTRY_MCAST_N_GROUPS]\t= { .type = NLA_REJECT },\n\t[BRIDGE_VLANDB_ENTRY_MCAST_MAX_GROUPS]\t= { .type = NLA_U32 },\n\t[BRIDGE_VLANDB_ENTRY_NEIGH_SUPPRESS]\t= NLA_POLICY_MAX(NLA_U8, 1),\n};\n\nstatic int br_vlan_rtm_process_one(struct net_device *dev,\n\t\t\t\t   const struct nlattr *attr,\n\t\t\t\t   int cmd, struct netlink_ext_ack *extack)\n{\n\tstruct bridge_vlan_info *vinfo, vrange_end, *vinfo_last = NULL;\n\tstruct nlattr *tb[BRIDGE_VLANDB_ENTRY_MAX + 1];\n\tbool changed = false, skip_processing = false;\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_port *p = NULL;\n\tint err = 0, cmdmap = 0;\n\tstruct net_bridge *br;\n\n\tif (netif_is_bridge_master(dev)) {\n\t\tbr = netdev_priv(dev);\n\t\tvg = br_vlan_group(br);\n\t} else {\n\t\tp = br_port_get_rtnl(dev);\n\t\tif (WARN_ON(!p))\n\t\t\treturn -ENODEV;\n\t\tbr = p->br;\n\t\tvg = nbp_vlan_group(p);\n\t}\n\n\tif (WARN_ON(!vg))\n\t\treturn -ENODEV;\n\n\terr = nla_parse_nested(tb, BRIDGE_VLANDB_ENTRY_MAX, attr,\n\t\t\t       br_vlan_db_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[BRIDGE_VLANDB_ENTRY_INFO]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing vlan entry info\");\n\t\treturn -EINVAL;\n\t}\n\tmemset(&vrange_end, 0, sizeof(vrange_end));\n\n\tvinfo = nla_data(tb[BRIDGE_VLANDB_ENTRY_INFO]);\n\tif (vinfo->flags & (BRIDGE_VLAN_INFO_RANGE_BEGIN |\n\t\t\t    BRIDGE_VLAN_INFO_RANGE_END)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Old-style vlan ranges are not allowed when using RTM vlan calls\");\n\t\treturn -EINVAL;\n\t}\n\tif (!br_vlan_valid_id(vinfo->vid, extack))\n\t\treturn -EINVAL;\n\n\tif (tb[BRIDGE_VLANDB_ENTRY_RANGE]) {\n\t\tvrange_end.vid = nla_get_u16(tb[BRIDGE_VLANDB_ENTRY_RANGE]);\n\t\t \n\t\tvrange_end.flags = BRIDGE_VLAN_INFO_RANGE_END | vinfo->flags;\n\t\tvinfo->flags |= BRIDGE_VLAN_INFO_RANGE_BEGIN;\n\n\t\t \n\t\tvinfo_last = vinfo;\n\t\tvinfo = &vrange_end;\n\n\t\tif (!br_vlan_valid_id(vinfo->vid, extack) ||\n\t\t    !br_vlan_valid_range(vinfo, vinfo_last, extack))\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase RTM_NEWVLAN:\n\t\tcmdmap = RTM_SETLINK;\n\t\tskip_processing = !!(vinfo->flags & BRIDGE_VLAN_INFO_ONLY_OPTS);\n\t\tbreak;\n\tcase RTM_DELVLAN:\n\t\tcmdmap = RTM_DELLINK;\n\t\tbreak;\n\t}\n\n\tif (!skip_processing) {\n\t\tstruct bridge_vlan_info *tmp_last = vinfo_last;\n\n\t\t \n\t\terr = br_process_vlan_info(br, p, cmdmap, vinfo, &tmp_last,\n\t\t\t\t\t   &changed, extack);\n\n\t\t \n\t\tif (changed)\n\t\t\tbr_ifinfo_notify(cmdmap, br, p);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (cmd == RTM_NEWVLAN) {\n\t\tstruct net_bridge_vlan *range_start, *range_end;\n\n\t\tif (vinfo_last) {\n\t\t\trange_start = br_vlan_find(vg, vinfo_last->vid);\n\t\t\trange_end = br_vlan_find(vg, vinfo->vid);\n\t\t} else {\n\t\t\trange_start = br_vlan_find(vg, vinfo->vid);\n\t\t\trange_end = range_start;\n\t\t}\n\n\t\terr = br_vlan_process_options(br, p, range_start, range_end,\n\t\t\t\t\t      tb, extack);\n\t}\n\n\treturn err;\n}\n\nstatic int br_vlan_rtm_process(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_vlan_msg *bvm;\n\tstruct net_device *dev;\n\tstruct nlattr *attr;\n\tint err, vlans = 0;\n\tint rem;\n\n\t \n\terr = nlmsg_parse(nlh, sizeof(*bvm), NULL, BRIDGE_VLANDB_MAX, NULL,\n\t\t\t  extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tbvm = nlmsg_data(nlh);\n\tdev = __dev_get_by_index(net, bvm->ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!netif_is_bridge_master(dev) && !netif_is_bridge_port(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"The device is not a valid bridge or bridge port\");\n\t\treturn -EINVAL;\n\t}\n\n\tnlmsg_for_each_attr(attr, nlh, sizeof(*bvm), rem) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase BRIDGE_VLANDB_ENTRY:\n\t\t\terr = br_vlan_rtm_process_one(dev, attr,\n\t\t\t\t\t\t      nlh->nlmsg_type,\n\t\t\t\t\t\t      extack);\n\t\t\tbreak;\n\t\tcase BRIDGE_VLANDB_GLOBAL_OPTIONS:\n\t\t\terr = br_vlan_rtm_process_global_options(dev, attr,\n\t\t\t\t\t\t\t\t nlh->nlmsg_type,\n\t\t\t\t\t\t\t\t extack);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tvlans++;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (!vlans) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No vlans found to process\");\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nvoid br_vlan_rtnl_init(void)\n{\n\trtnl_register_module(THIS_MODULE, PF_BRIDGE, RTM_GETVLAN, NULL,\n\t\t\t     br_vlan_rtm_dump, 0);\n\trtnl_register_module(THIS_MODULE, PF_BRIDGE, RTM_NEWVLAN,\n\t\t\t     br_vlan_rtm_process, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_BRIDGE, RTM_DELVLAN,\n\t\t\t     br_vlan_rtm_process, NULL, 0);\n}\n\nvoid br_vlan_rtnl_uninit(void)\n{\n\trtnl_unregister(PF_BRIDGE, RTM_GETVLAN);\n\trtnl_unregister(PF_BRIDGE, RTM_NEWVLAN);\n\trtnl_unregister(PF_BRIDGE, RTM_DELVLAN);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}