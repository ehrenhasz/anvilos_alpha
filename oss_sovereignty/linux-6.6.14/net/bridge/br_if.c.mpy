{
  "module_name": "br_if.c",
  "hash_id": "7c0ce23fa2602c6ad9abec51bbe51c761a8758c78880537ea4b4dd53f66925ba",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_if.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/netpoll.h>\n#include <linux/ethtool.h>\n#include <linux/if_arp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_ether.h>\n#include <linux/slab.h>\n#include <net/dsa.h>\n#include <net/sock.h>\n#include <linux/if_vlan.h>\n#include <net/switchdev.h>\n#include <net/net_namespace.h>\n\n#include \"br_private.h\"\n\n \nstatic int port_cost(struct net_device *dev)\n{\n\tstruct ethtool_link_ksettings ecmd;\n\n\tif (!__ethtool_get_link_ksettings(dev, &ecmd)) {\n\t\tswitch (ecmd.base.speed) {\n\t\tcase SPEED_10000:\n\t\t\treturn 2;\n\t\tcase SPEED_5000:\n\t\t\treturn 3;\n\t\tcase SPEED_2500:\n\t\t\treturn 4;\n\t\tcase SPEED_1000:\n\t\t\treturn 5;\n\t\tcase SPEED_100:\n\t\t\treturn 19;\n\t\tcase SPEED_10:\n\t\t\treturn 100;\n\t\tcase SPEED_UNKNOWN:\n\t\t\treturn 100;\n\t\tdefault:\n\t\t\tif (ecmd.base.speed > SPEED_10000)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tif (!strncmp(dev->name, \"lec\", 3))\n\t\treturn 7;\n\n\tif (!strncmp(dev->name, \"plip\", 4))\n\t\treturn 2500;\n\n\treturn 100;\t \n}\n\n\n \nvoid br_port_carrier_check(struct net_bridge_port *p, bool *notified)\n{\n\tstruct net_device *dev = p->dev;\n\tstruct net_bridge *br = p->br;\n\n\tif (!(p->flags & BR_ADMIN_COST) &&\n\t    netif_running(dev) && netif_oper_up(dev))\n\t\tp->path_cost = port_cost(dev);\n\n\t*notified = false;\n\tif (!netif_running(br->dev))\n\t\treturn;\n\n\tspin_lock_bh(&br->lock);\n\tif (netif_running(dev) && netif_oper_up(dev)) {\n\t\tif (p->state == BR_STATE_DISABLED) {\n\t\t\tbr_stp_enable_port(p);\n\t\t\t*notified = true;\n\t\t}\n\t} else {\n\t\tif (p->state != BR_STATE_DISABLED) {\n\t\t\tbr_stp_disable_port(p);\n\t\t\t*notified = true;\n\t\t}\n\t}\n\tspin_unlock_bh(&br->lock);\n}\n\nstatic void br_port_set_promisc(struct net_bridge_port *p)\n{\n\tint err = 0;\n\n\tif (br_promisc_port(p))\n\t\treturn;\n\n\terr = dev_set_promiscuity(p->dev, 1);\n\tif (err)\n\t\treturn;\n\n\tbr_fdb_unsync_static(p->br, p);\n\tp->flags |= BR_PROMISC;\n}\n\nstatic void br_port_clear_promisc(struct net_bridge_port *p)\n{\n\tint err;\n\n\t \n\tif (!br_promisc_port(p) || !(p->dev->priv_flags & IFF_UNICAST_FLT))\n\t\treturn;\n\n\t \n\terr = br_fdb_sync_static(p->br, p);\n\tif (err)\n\t\treturn;\n\n\tdev_set_promiscuity(p->dev, -1);\n\tp->flags &= ~BR_PROMISC;\n}\n\n \nvoid br_manage_promisc(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\tbool set_all = false;\n\n\t \n\tif ((br->dev->flags & IFF_PROMISC) || !br_vlan_enabled(br->dev))\n\t\tset_all = true;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (set_all) {\n\t\t\tbr_port_set_promisc(p);\n\t\t} else {\n\t\t\t \n\t\t\tif ((p->dev->priv_flags & IFF_UNICAST_FLT) &&\n\t\t\t    (br->auto_cnt == 0 ||\n\t\t\t     (br->auto_cnt == 1 && br_auto_port(p))))\n\t\t\t\tbr_port_clear_promisc(p);\n\t\t\telse\n\t\t\t\tbr_port_set_promisc(p);\n\t\t}\n\t}\n}\n\nint nbp_backup_change(struct net_bridge_port *p,\n\t\t      struct net_device *backup_dev)\n{\n\tstruct net_bridge_port *old_backup = rtnl_dereference(p->backup_port);\n\tstruct net_bridge_port *backup_p = NULL;\n\n\tASSERT_RTNL();\n\n\tif (backup_dev) {\n\t\tif (!netif_is_bridge_port(backup_dev))\n\t\t\treturn -ENOENT;\n\n\t\tbackup_p = br_port_get_rtnl(backup_dev);\n\t\tif (backup_p->br != p->br)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (p == backup_p)\n\t\treturn -EINVAL;\n\n\tif (old_backup == backup_p)\n\t\treturn 0;\n\n\t \n\tif (old_backup)\n\t\told_backup->backup_redirected_cnt--;\n\n\tif (backup_p)\n\t\tbackup_p->backup_redirected_cnt++;\n\trcu_assign_pointer(p->backup_port, backup_p);\n\n\treturn 0;\n}\n\nstatic void nbp_backup_clear(struct net_bridge_port *p)\n{\n\tnbp_backup_change(p, NULL);\n\tif (p->backup_redirected_cnt) {\n\t\tstruct net_bridge_port *cur_p;\n\n\t\tlist_for_each_entry(cur_p, &p->br->port_list, list) {\n\t\t\tstruct net_bridge_port *backup_p;\n\n\t\t\tbackup_p = rtnl_dereference(cur_p->backup_port);\n\t\t\tif (backup_p == p)\n\t\t\t\tnbp_backup_change(cur_p, NULL);\n\t\t}\n\t}\n\n\tWARN_ON(rcu_access_pointer(p->backup_port) || p->backup_redirected_cnt);\n}\n\nstatic void nbp_update_port_count(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\tu32 cnt = 0;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (br_auto_port(p))\n\t\t\tcnt++;\n\t}\n\tif (br->auto_cnt != cnt) {\n\t\tbr->auto_cnt = cnt;\n\t\tbr_manage_promisc(br);\n\t}\n}\n\nstatic void nbp_delete_promisc(struct net_bridge_port *p)\n{\n\t \n\tdev_set_allmulti(p->dev, -1);\n\tif (br_promisc_port(p))\n\t\tdev_set_promiscuity(p->dev, -1);\n\telse\n\t\tbr_fdb_unsync_static(p->br, p);\n}\n\nstatic void release_nbp(struct kobject *kobj)\n{\n\tstruct net_bridge_port *p\n\t\t= container_of(kobj, struct net_bridge_port, kobj);\n\tkfree(p);\n}\n\nstatic void brport_get_ownership(const struct kobject *kobj, kuid_t *uid, kgid_t *gid)\n{\n\tstruct net_bridge_port *p = kobj_to_brport(kobj);\n\n\tnet_ns_get_ownership(dev_net(p->dev), uid, gid);\n}\n\nstatic const struct kobj_type brport_ktype = {\n#ifdef CONFIG_SYSFS\n\t.sysfs_ops = &brport_sysfs_ops,\n#endif\n\t.release = release_nbp,\n\t.get_ownership = brport_get_ownership,\n};\n\nstatic void destroy_nbp(struct net_bridge_port *p)\n{\n\tstruct net_device *dev = p->dev;\n\n\tp->br = NULL;\n\tp->dev = NULL;\n\tnetdev_put(dev, &p->dev_tracker);\n\n\tkobject_put(&p->kobj);\n}\n\nstatic void destroy_nbp_rcu(struct rcu_head *head)\n{\n\tstruct net_bridge_port *p =\n\t\t\tcontainer_of(head, struct net_bridge_port, rcu);\n\tdestroy_nbp(p);\n}\n\nstatic unsigned get_max_headroom(struct net_bridge *br)\n{\n\tunsigned max_headroom = 0;\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tunsigned dev_headroom = netdev_get_fwd_headroom(p->dev);\n\n\t\tif (dev_headroom > max_headroom)\n\t\t\tmax_headroom = dev_headroom;\n\t}\n\n\treturn max_headroom;\n}\n\nstatic void update_headroom(struct net_bridge *br, int new_hr)\n{\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry(p, &br->port_list, list)\n\t\tnetdev_set_rx_headroom(p->dev, new_hr);\n\n\tbr->dev->needed_headroom = new_hr;\n}\n\n \nstatic void del_nbp(struct net_bridge_port *p)\n{\n\tstruct net_bridge *br = p->br;\n\tstruct net_device *dev = p->dev;\n\n\tsysfs_remove_link(br->ifobj, p->dev->name);\n\n\tnbp_delete_promisc(p);\n\n\tspin_lock_bh(&br->lock);\n\tbr_stp_disable_port(p);\n\tspin_unlock_bh(&br->lock);\n\n\tbr_mrp_port_del(br, p);\n\tbr_cfm_port_del(br, p);\n\n\tbr_ifinfo_notify(RTM_DELLINK, NULL, p);\n\n\tlist_del_rcu(&p->list);\n\tif (netdev_get_fwd_headroom(dev) == br->dev->needed_headroom)\n\t\tupdate_headroom(br, get_max_headroom(br));\n\tnetdev_reset_rx_headroom(dev);\n\n\tnbp_vlan_flush(p);\n\tbr_fdb_delete_by_port(br, p, 0, 1);\n\tswitchdev_deferred_process();\n\tnbp_backup_clear(p);\n\n\tnbp_update_port_count(br);\n\n\tnetdev_upper_dev_unlink(dev, br->dev);\n\n\tdev->priv_flags &= ~IFF_BRIDGE_PORT;\n\n\tnetdev_rx_handler_unregister(dev);\n\n\tbr_multicast_del_port(p);\n\n\tkobject_uevent(&p->kobj, KOBJ_REMOVE);\n\tkobject_del(&p->kobj);\n\n\tbr_netpoll_disable(p);\n\n\tcall_rcu(&p->rcu, destroy_nbp_rcu);\n}\n\n \nvoid br_dev_delete(struct net_device *dev, struct list_head *head)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_port *p, *n;\n\n\tlist_for_each_entry_safe(p, n, &br->port_list, list) {\n\t\tdel_nbp(p);\n\t}\n\n\tbr_recalculate_neigh_suppress_enabled(br);\n\n\tbr_fdb_delete_by_port(br, NULL, 0, 1);\n\n\tcancel_delayed_work_sync(&br->gc_work);\n\n\tbr_sysfs_delbr(br->dev);\n\tunregister_netdevice_queue(br->dev, head);\n}\n\n \nstatic int find_portno(struct net_bridge *br)\n{\n\tint index;\n\tstruct net_bridge_port *p;\n\tunsigned long *inuse;\n\n\tinuse = bitmap_zalloc(BR_MAX_PORTS, GFP_KERNEL);\n\tif (!inuse)\n\t\treturn -ENOMEM;\n\n\t__set_bit(0, inuse);\t \n\tlist_for_each_entry(p, &br->port_list, list)\n\t\t__set_bit(p->port_no, inuse);\n\n\tindex = find_first_zero_bit(inuse, BR_MAX_PORTS);\n\tbitmap_free(inuse);\n\n\treturn (index >= BR_MAX_PORTS) ? -EXFULL : index;\n}\n\n \nstatic struct net_bridge_port *new_nbp(struct net_bridge *br,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct net_bridge_port *p;\n\tint index, err;\n\n\tindex = find_portno(br);\n\tif (index < 0)\n\t\treturn ERR_PTR(index);\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tp->br = br;\n\tnetdev_hold(dev, &p->dev_tracker, GFP_KERNEL);\n\tp->dev = dev;\n\tp->path_cost = port_cost(dev);\n\tp->priority = 0x8000 >> BR_PORT_BITS;\n\tp->port_no = index;\n\tp->flags = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD;\n\tbr_init_port(p);\n\tbr_set_state(p, BR_STATE_DISABLED);\n\tbr_stp_port_timer_init(p);\n\terr = br_multicast_add_port(p);\n\tif (err) {\n\t\tnetdev_put(dev, &p->dev_tracker);\n\t\tkfree(p);\n\t\tp = ERR_PTR(err);\n\t}\n\n\treturn p;\n}\n\nint br_add_bridge(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\tint res;\n\n\tdev = alloc_netdev(sizeof(struct net_bridge), name, NET_NAME_UNKNOWN,\n\t\t\t   br_dev_setup);\n\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev_net_set(dev, net);\n\tdev->rtnl_link_ops = &br_link_ops;\n\n\tres = register_netdevice(dev);\n\tif (res)\n\t\tfree_netdev(dev);\n\treturn res;\n}\n\nint br_del_bridge(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\tint ret = 0;\n\n\tdev = __dev_get_by_name(net, name);\n\tif (dev == NULL)\n\t\tret =  -ENXIO; \t \n\n\telse if (!netif_is_bridge_master(dev)) {\n\t\t \n\t\tret = -EPERM;\n\t}\n\n\telse if (dev->flags & IFF_UP) {\n\t\t \n\t\tret = -EBUSY;\n\t}\n\n\telse\n\t\tbr_dev_delete(dev, NULL);\n\n\treturn ret;\n}\n\n \nstatic int br_mtu_min(const struct net_bridge *br)\n{\n\tconst struct net_bridge_port *p;\n\tint ret_mtu = 0;\n\n\tlist_for_each_entry(p, &br->port_list, list)\n\t\tif (!ret_mtu || ret_mtu > p->dev->mtu)\n\t\t\tret_mtu = p->dev->mtu;\n\n\treturn ret_mtu ? ret_mtu : ETH_DATA_LEN;\n}\n\nvoid br_mtu_auto_adjust(struct net_bridge *br)\n{\n\tASSERT_RTNL();\n\n\t \n\tif (br_opt_get(br, BROPT_MTU_SET_BY_USER))\n\t\treturn;\n\n\t \n\tdev_set_mtu(br->dev, br_mtu_min(br));\n\tbr_opt_toggle(br, BROPT_MTU_SET_BY_USER, false);\n}\n\nstatic void br_set_gso_limits(struct net_bridge *br)\n{\n\tunsigned int tso_max_size = TSO_MAX_SIZE;\n\tconst struct net_bridge_port *p;\n\tu16 tso_max_segs = TSO_MAX_SEGS;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\ttso_max_size = min(tso_max_size, p->dev->tso_max_size);\n\t\ttso_max_segs = min(tso_max_segs, p->dev->tso_max_segs);\n\t}\n\tnetif_set_tso_max_size(br->dev, tso_max_size);\n\tnetif_set_tso_max_segs(br->dev, tso_max_segs);\n}\n\n \nnetdev_features_t br_features_recompute(struct net_bridge *br,\n\tnetdev_features_t features)\n{\n\tstruct net_bridge_port *p;\n\tnetdev_features_t mask;\n\n\tif (list_empty(&br->port_list))\n\t\treturn features;\n\n\tmask = features;\n\tfeatures &= ~NETIF_F_ONE_FOR_ALL;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tfeatures = netdev_increment_features(features,\n\t\t\t\t\t\t     p->dev->features, mask);\n\t}\n\tfeatures = netdev_add_tso_features(features, mask);\n\n\treturn features;\n}\n\n \nint br_add_if(struct net_bridge *br, struct net_device *dev,\n\t      struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_port *p;\n\tint err = 0;\n\tunsigned br_hr, dev_hr;\n\tbool changed_addr, fdb_synced = false;\n\n\t \n\tif ((dev->flags & IFF_LOOPBACK) ||\n\t    dev->type != ARPHRD_ETHER || dev->addr_len != ETH_ALEN ||\n\t    !is_valid_ether_addr(dev->dev_addr))\n\t\treturn -EINVAL;\n\n\t \n\tif (dev->netdev_ops->ndo_start_xmit == br_dev_xmit) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Can not enslave a bridge to a bridge\");\n\t\treturn -ELOOP;\n\t}\n\n\t \n\tif (netdev_master_upper_dev_get(dev))\n\t\treturn -EBUSY;\n\n\t \n\tif (dev->priv_flags & IFF_DONT_BRIDGE) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Device does not allow enslaving to a bridge\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tp = new_nbp(br, dev);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tcall_netdevice_notifiers(NETDEV_JOIN, dev);\n\n\terr = dev_set_allmulti(dev, 1);\n\tif (err) {\n\t\tbr_multicast_del_port(p);\n\t\tnetdev_put(dev, &p->dev_tracker);\n\t\tkfree(p);\t \n\t\tgoto err1;\n\t}\n\n\terr = kobject_init_and_add(&p->kobj, &brport_ktype, &(dev->dev.kobj),\n\t\t\t\t   SYSFS_BRIDGE_PORT_ATTR);\n\tif (err)\n\t\tgoto err2;\n\n\terr = br_sysfs_addif(p);\n\tif (err)\n\t\tgoto err2;\n\n\terr = br_netpoll_enable(p);\n\tif (err)\n\t\tgoto err3;\n\n\terr = netdev_rx_handler_register(dev, br_get_rx_handler(dev), p);\n\tif (err)\n\t\tgoto err4;\n\n\tdev->priv_flags |= IFF_BRIDGE_PORT;\n\n\terr = netdev_master_upper_dev_link(dev, br->dev, NULL, NULL, extack);\n\tif (err)\n\t\tgoto err5;\n\n\tdev_disable_lro(dev);\n\n\tlist_add_rcu(&p->list, &br->port_list);\n\n\tnbp_update_port_count(br);\n\tif (!br_promisc_port(p) && (p->dev->priv_flags & IFF_UNICAST_FLT)) {\n\t\t \n\t\tfdb_synced = br_fdb_sync_static(br, p) == 0;\n\t\tif (!fdb_synced)\n\t\t\tnetdev_err(dev, \"failed to sync bridge static fdb addresses to this port\\n\");\n\t}\n\n\tnetdev_update_features(br->dev);\n\n\tbr_hr = br->dev->needed_headroom;\n\tdev_hr = netdev_get_fwd_headroom(dev);\n\tif (br_hr < dev_hr)\n\t\tupdate_headroom(br, dev_hr);\n\telse\n\t\tnetdev_set_rx_headroom(dev, br_hr);\n\n\tif (br_fdb_add_local(br, p, dev->dev_addr, 0))\n\t\tnetdev_err(dev, \"failed insert local address bridge forwarding table\\n\");\n\n\tif (br->dev->addr_assign_type != NET_ADDR_SET) {\n\t\t \n\t\terr = dev_pre_changeaddr_notify(br->dev, dev->dev_addr, extack);\n\t\tif (err)\n\t\t\tgoto err6;\n\t}\n\n\terr = nbp_vlan_init(p, extack);\n\tif (err) {\n\t\tnetdev_err(dev, \"failed to initialize vlan filtering on this port\\n\");\n\t\tgoto err6;\n\t}\n\n\tspin_lock_bh(&br->lock);\n\tchanged_addr = br_stp_recalculate_bridge_id(br);\n\n\tif (netif_running(dev) && netif_oper_up(dev) &&\n\t    (br->dev->flags & IFF_UP))\n\t\tbr_stp_enable_port(p);\n\tspin_unlock_bh(&br->lock);\n\n\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\n\tif (changed_addr)\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, br->dev);\n\n\tbr_mtu_auto_adjust(br);\n\tbr_set_gso_limits(br);\n\n\tkobject_uevent(&p->kobj, KOBJ_ADD);\n\n\treturn 0;\n\nerr6:\n\tif (fdb_synced)\n\t\tbr_fdb_unsync_static(br, p);\n\tlist_del_rcu(&p->list);\n\tbr_fdb_delete_by_port(br, p, 0, 1);\n\tnbp_update_port_count(br);\n\tnetdev_upper_dev_unlink(dev, br->dev);\nerr5:\n\tdev->priv_flags &= ~IFF_BRIDGE_PORT;\n\tnetdev_rx_handler_unregister(dev);\nerr4:\n\tbr_netpoll_disable(p);\nerr3:\n\tsysfs_remove_link(br->ifobj, p->dev->name);\nerr2:\n\tbr_multicast_del_port(p);\n\tnetdev_put(dev, &p->dev_tracker);\n\tkobject_put(&p->kobj);\n\tdev_set_allmulti(dev, -1);\nerr1:\n\treturn err;\n}\n\n \nint br_del_if(struct net_bridge *br, struct net_device *dev)\n{\n\tstruct net_bridge_port *p;\n\tbool changed_addr;\n\n\tp = br_port_get_rtnl(dev);\n\tif (!p || p->br != br)\n\t\treturn -EINVAL;\n\n\t \n\tdel_nbp(p);\n\n\tbr_mtu_auto_adjust(br);\n\tbr_set_gso_limits(br);\n\n\tspin_lock_bh(&br->lock);\n\tchanged_addr = br_stp_recalculate_bridge_id(br);\n\tspin_unlock_bh(&br->lock);\n\n\tif (changed_addr)\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, br->dev);\n\n\tnetdev_update_features(br->dev);\n\n\treturn 0;\n}\n\nvoid br_port_flags_change(struct net_bridge_port *p, unsigned long mask)\n{\n\tstruct net_bridge *br = p->br;\n\n\tif (mask & BR_AUTO_MASK)\n\t\tnbp_update_port_count(br);\n\n\tif (mask & (BR_NEIGH_SUPPRESS | BR_NEIGH_VLAN_SUPPRESS))\n\t\tbr_recalculate_neigh_suppress_enabled(br);\n}\n\nbool br_port_flag_is_set(const struct net_device *dev, unsigned long flag)\n{\n\tstruct net_bridge_port *p;\n\n\tp = br_port_get_rtnl_rcu(dev);\n\tif (!p)\n\t\treturn false;\n\n\treturn p->flags & flag;\n}\nEXPORT_SYMBOL_GPL(br_port_flag_is_set);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}