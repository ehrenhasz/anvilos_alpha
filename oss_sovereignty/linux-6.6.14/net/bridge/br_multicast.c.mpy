{
  "module_name": "br_multicast.c",
  "hash_id": "dc43ecca09497bac8c2457643f732640e93d1b4365ef3cc662119e333da01344",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_multicast.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/if_ether.h>\n#include <linux/igmp.h>\n#include <linux/in.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/inetdevice.h>\n#include <linux/mroute.h>\n#include <net/ip.h>\n#include <net/switchdev.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/icmpv6.h>\n#include <net/ipv6.h>\n#include <net/mld.h>\n#include <net/ip6_checksum.h>\n#include <net/addrconf.h>\n#endif\n#include <trace/events/bridge.h>\n\n#include \"br_private.h\"\n#include \"br_private_mcast_eht.h\"\n\nstatic const struct rhashtable_params br_mdb_rht_params = {\n\t.head_offset = offsetof(struct net_bridge_mdb_entry, rhnode),\n\t.key_offset = offsetof(struct net_bridge_mdb_entry, addr),\n\t.key_len = sizeof(struct br_ip),\n\t.automatic_shrinking = true,\n};\n\nstatic const struct rhashtable_params br_sg_port_rht_params = {\n\t.head_offset = offsetof(struct net_bridge_port_group, rhnode),\n\t.key_offset = offsetof(struct net_bridge_port_group, key),\n\t.key_len = sizeof(struct net_bridge_port_group_sg_key),\n\t.automatic_shrinking = true,\n};\n\nstatic void br_multicast_start_querier(struct net_bridge_mcast *brmctx,\n\t\t\t\t       struct bridge_mcast_own_query *query);\nstatic void br_ip4_multicast_add_router(struct net_bridge_mcast *brmctx,\n\t\t\t\t\tstruct net_bridge_mcast_port *pmctx);\nstatic void br_ip4_multicast_leave_group(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t __be32 group,\n\t\t\t\t\t __u16 vid,\n\t\t\t\t\t const unsigned char *src);\nstatic void br_multicast_port_group_rexmit(struct timer_list *t);\n\nstatic void\nbr_multicast_rport_del_notify(struct net_bridge_mcast_port *pmctx, bool deleted);\nstatic void br_ip6_multicast_add_router(struct net_bridge_mcast *brmctx,\n\t\t\t\t\tstruct net_bridge_mcast_port *pmctx);\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_leave_group(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t const struct in6_addr *group,\n\t\t\t\t\t __u16 vid, const unsigned char *src);\n#endif\nstatic struct net_bridge_port_group *\n__br_multicast_add_group(struct net_bridge_mcast *brmctx,\n\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t struct br_ip *group,\n\t\t\t const unsigned char *src,\n\t\t\t u8 filter_mode,\n\t\t\t bool igmpv2_mldv1,\n\t\t\t bool blocked);\nstatic void br_multicast_find_del_pg(struct net_bridge *br,\n\t\t\t\t     struct net_bridge_port_group *pg);\nstatic void __br_multicast_stop(struct net_bridge_mcast *brmctx);\n\nstatic int br_mc_disabled_update(struct net_device *dev, bool value,\n\t\t\t\t struct netlink_ext_ack *extack);\n\nstatic struct net_bridge_port_group *\nbr_sg_port_find(struct net_bridge *br,\n\t\tstruct net_bridge_port_group_sg_key *sg_p)\n{\n\tlockdep_assert_held_once(&br->multicast_lock);\n\n\treturn rhashtable_lookup_fast(&br->sg_port_tbl, sg_p,\n\t\t\t\t      br_sg_port_rht_params);\n}\n\nstatic struct net_bridge_mdb_entry *br_mdb_ip_get_rcu(struct net_bridge *br,\n\t\t\t\t\t\t      struct br_ip *dst)\n{\n\treturn rhashtable_lookup(&br->mdb_hash_tbl, dst, br_mdb_rht_params);\n}\n\nstruct net_bridge_mdb_entry *br_mdb_ip_get(struct net_bridge *br,\n\t\t\t\t\t   struct br_ip *dst)\n{\n\tstruct net_bridge_mdb_entry *ent;\n\n\tlockdep_assert_held_once(&br->multicast_lock);\n\n\trcu_read_lock();\n\tent = rhashtable_lookup(&br->mdb_hash_tbl, dst, br_mdb_rht_params);\n\trcu_read_unlock();\n\n\treturn ent;\n}\n\nstatic struct net_bridge_mdb_entry *br_mdb_ip4_get(struct net_bridge *br,\n\t\t\t\t\t\t   __be32 dst, __u16 vid)\n{\n\tstruct br_ip br_dst;\n\n\tmemset(&br_dst, 0, sizeof(br_dst));\n\tbr_dst.dst.ip4 = dst;\n\tbr_dst.proto = htons(ETH_P_IP);\n\tbr_dst.vid = vid;\n\n\treturn br_mdb_ip_get(br, &br_dst);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct net_bridge_mdb_entry *br_mdb_ip6_get(struct net_bridge *br,\n\t\t\t\t\t\t   const struct in6_addr *dst,\n\t\t\t\t\t\t   __u16 vid)\n{\n\tstruct br_ip br_dst;\n\n\tmemset(&br_dst, 0, sizeof(br_dst));\n\tbr_dst.dst.ip6 = *dst;\n\tbr_dst.proto = htons(ETH_P_IPV6);\n\tbr_dst.vid = vid;\n\n\treturn br_mdb_ip_get(br, &br_dst);\n}\n#endif\n\nstruct net_bridge_mdb_entry *br_mdb_get(struct net_bridge_mcast *brmctx,\n\t\t\t\t\tstruct sk_buff *skb, u16 vid)\n{\n\tstruct net_bridge *br = brmctx->br;\n\tstruct br_ip ip;\n\n\tif (!br_opt_get(br, BROPT_MULTICAST_ENABLED) ||\n\t    br_multicast_ctx_vlan_global_disabled(brmctx))\n\t\treturn NULL;\n\n\tif (BR_INPUT_SKB_CB(skb)->igmp)\n\t\treturn NULL;\n\n\tmemset(&ip, 0, sizeof(ip));\n\tip.proto = skb->protocol;\n\tip.vid = vid;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tip.dst.ip4 = ip_hdr(skb)->daddr;\n\t\tif (brmctx->multicast_igmp_version == 3) {\n\t\t\tstruct net_bridge_mdb_entry *mdb;\n\n\t\t\tip.src.ip4 = ip_hdr(skb)->saddr;\n\t\t\tmdb = br_mdb_ip_get_rcu(br, &ip);\n\t\t\tif (mdb)\n\t\t\t\treturn mdb;\n\t\t\tip.src.ip4 = 0;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tip.dst.ip6 = ipv6_hdr(skb)->daddr;\n\t\tif (brmctx->multicast_mld_version == 2) {\n\t\t\tstruct net_bridge_mdb_entry *mdb;\n\n\t\t\tip.src.ip6 = ipv6_hdr(skb)->saddr;\n\t\t\tmdb = br_mdb_ip_get_rcu(br, &ip);\n\t\t\tif (mdb)\n\t\t\t\treturn mdb;\n\t\t\tmemset(&ip.src.ip6, 0, sizeof(ip.src.ip6));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tip.proto = 0;\n\t\tether_addr_copy(ip.dst.mac_addr, eth_hdr(skb)->h_dest);\n\t}\n\n\treturn br_mdb_ip_get_rcu(br, &ip);\n}\n\n \nstatic struct net_bridge_mcast_port *\nbr_multicast_pg_to_port_ctx(const struct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mcast_port *pmctx = &pg->key.port->multicast_ctx;\n\tstruct net_bridge_vlan *vlan;\n\n\tlockdep_assert_held_once(&pg->key.port->br->multicast_lock);\n\n\t \n\tif (!pg->key.addr.vid ||\n\t    !br_opt_get(pg->key.port->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED))\n\t\tgoto out;\n\n\t \n\trcu_read_lock();\n\tvlan = br_vlan_find(nbp_vlan_group_rcu(pg->key.port), pg->key.addr.vid);\n\tif (vlan && !br_multicast_port_ctx_vlan_disabled(&vlan->port_mcast_ctx))\n\t\tpmctx = &vlan->port_mcast_ctx;\n\telse\n\t\tpmctx = NULL;\n\trcu_read_unlock();\nout:\n\treturn pmctx;\n}\n\nstatic struct net_bridge_mcast_port *\nbr_multicast_port_vid_to_port_ctx(struct net_bridge_port *port, u16 vid)\n{\n\tstruct net_bridge_mcast_port *pmctx = NULL;\n\tstruct net_bridge_vlan *vlan;\n\n\tlockdep_assert_held_once(&port->br->multicast_lock);\n\n\tif (!br_opt_get(port->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED))\n\t\treturn NULL;\n\n\t \n\trcu_read_lock();\n\n\tvlan = br_vlan_find(nbp_vlan_group_rcu(port), vid);\n\tif (vlan && !br_multicast_port_ctx_vlan_disabled(&vlan->port_mcast_ctx))\n\t\tpmctx = &vlan->port_mcast_ctx;\n\n\trcu_read_unlock();\n\n\treturn pmctx;\n}\n\n \nstatic bool\nbr_multicast_ctx_should_use(const struct net_bridge_mcast *brmctx,\n\t\t\t    const struct net_bridge_mcast_port *pmctx)\n{\n\tif (!netif_running(brmctx->br->dev))\n\t\treturn false;\n\n\tif (pmctx)\n\t\treturn !br_multicast_port_ctx_state_disabled(pmctx);\n\telse\n\t\treturn !br_multicast_ctx_vlan_disabled(brmctx);\n}\n\nstatic bool br_port_group_equal(struct net_bridge_port_group *p,\n\t\t\t\tstruct net_bridge_port *port,\n\t\t\t\tconst unsigned char *src)\n{\n\tif (p->key.port != port)\n\t\treturn false;\n\n\tif (!(port->flags & BR_MULTICAST_TO_UNICAST))\n\t\treturn true;\n\n\treturn ether_addr_equal(src, p->eth_addr);\n}\n\nstatic void __fwd_add_star_excl(struct net_bridge_mcast_port *pmctx,\n\t\t\t\tstruct net_bridge_port_group *pg,\n\t\t\t\tstruct br_ip *sg_ip)\n{\n\tstruct net_bridge_port_group_sg_key sg_key;\n\tstruct net_bridge_port_group *src_pg;\n\tstruct net_bridge_mcast *brmctx;\n\n\tmemset(&sg_key, 0, sizeof(sg_key));\n\tbrmctx = br_multicast_port_ctx_get_global(pmctx);\n\tsg_key.port = pg->key.port;\n\tsg_key.addr = *sg_ip;\n\tif (br_sg_port_find(brmctx->br, &sg_key))\n\t\treturn;\n\n\tsrc_pg = __br_multicast_add_group(brmctx, pmctx,\n\t\t\t\t\t  sg_ip, pg->eth_addr,\n\t\t\t\t\t  MCAST_INCLUDE, false, false);\n\tif (IS_ERR_OR_NULL(src_pg) ||\n\t    src_pg->rt_protocol != RTPROT_KERNEL)\n\t\treturn;\n\n\tsrc_pg->flags |= MDB_PG_FLAGS_STAR_EXCL;\n}\n\nstatic void __fwd_del_star_excl(struct net_bridge_port_group *pg,\n\t\t\t\tstruct br_ip *sg_ip)\n{\n\tstruct net_bridge_port_group_sg_key sg_key;\n\tstruct net_bridge *br = pg->key.port->br;\n\tstruct net_bridge_port_group *src_pg;\n\n\tmemset(&sg_key, 0, sizeof(sg_key));\n\tsg_key.port = pg->key.port;\n\tsg_key.addr = *sg_ip;\n\tsrc_pg = br_sg_port_find(br, &sg_key);\n\tif (!src_pg || !(src_pg->flags & MDB_PG_FLAGS_STAR_EXCL) ||\n\t    src_pg->rt_protocol != RTPROT_KERNEL)\n\t\treturn;\n\n\tbr_multicast_find_del_pg(br, src_pg);\n}\n\n \nvoid br_multicast_star_g_handle_mode(struct net_bridge_port_group *pg,\n\t\t\t\t     u8 filter_mode)\n{\n\tstruct net_bridge *br = pg->key.port->br;\n\tstruct net_bridge_port_group *pg_lst;\n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct br_ip sg_ip;\n\n\tif (WARN_ON(!br_multicast_is_star_g(&pg->key.addr)))\n\t\treturn;\n\n\tmp = br_mdb_ip_get(br, &pg->key.addr);\n\tif (!mp)\n\t\treturn;\n\tpmctx = br_multicast_pg_to_port_ctx(pg);\n\tif (!pmctx)\n\t\treturn;\n\n\tmemset(&sg_ip, 0, sizeof(sg_ip));\n\tsg_ip = pg->key.addr;\n\n\tfor (pg_lst = mlock_dereference(mp->ports, br);\n\t     pg_lst;\n\t     pg_lst = mlock_dereference(pg_lst->next, br)) {\n\t\tstruct net_bridge_group_src *src_ent;\n\n\t\tif (pg_lst == pg)\n\t\t\tcontinue;\n\t\thlist_for_each_entry(src_ent, &pg_lst->src_list, node) {\n\t\t\tif (!(src_ent->flags & BR_SGRP_F_INSTALLED))\n\t\t\t\tcontinue;\n\t\t\tsg_ip.src = src_ent->addr.src;\n\t\t\tswitch (filter_mode) {\n\t\t\tcase MCAST_INCLUDE:\n\t\t\t\t__fwd_del_star_excl(pg, &sg_ip);\n\t\t\t\tbreak;\n\t\t\tcase MCAST_EXCLUDE:\n\t\t\t\t__fwd_add_star_excl(pmctx, pg, &sg_ip);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void br_multicast_sg_host_state(struct net_bridge_mdb_entry *star_mp,\n\t\t\t\t       struct net_bridge_port_group *sg)\n{\n\tstruct net_bridge_mdb_entry *sg_mp;\n\n\tif (WARN_ON(!br_multicast_is_star_g(&star_mp->addr)))\n\t\treturn;\n\tif (!star_mp->host_joined)\n\t\treturn;\n\n\tsg_mp = br_mdb_ip_get(star_mp->br, &sg->key.addr);\n\tif (!sg_mp)\n\t\treturn;\n\tsg_mp->host_joined = true;\n}\n\n \nstatic void br_multicast_star_g_host_state(struct net_bridge_mdb_entry *star_mp)\n{\n\tstruct net_bridge *br = star_mp->br;\n\tstruct net_bridge_mdb_entry *sg_mp;\n\tstruct net_bridge_port_group *pg;\n\tstruct br_ip sg_ip;\n\n\tif (WARN_ON(!br_multicast_is_star_g(&star_mp->addr)))\n\t\treturn;\n\n\tmemset(&sg_ip, 0, sizeof(sg_ip));\n\tsg_ip = star_mp->addr;\n\tfor (pg = mlock_dereference(star_mp->ports, br);\n\t     pg;\n\t     pg = mlock_dereference(pg->next, br)) {\n\t\tstruct net_bridge_group_src *src_ent;\n\n\t\thlist_for_each_entry(src_ent, &pg->src_list, node) {\n\t\t\tif (!(src_ent->flags & BR_SGRP_F_INSTALLED))\n\t\t\t\tcontinue;\n\t\t\tsg_ip.src = src_ent->addr.src;\n\t\t\tsg_mp = br_mdb_ip_get(br, &sg_ip);\n\t\t\tif (!sg_mp)\n\t\t\t\tcontinue;\n\t\t\tsg_mp->host_joined = star_mp->host_joined;\n\t\t}\n\t}\n}\n\nstatic void br_multicast_sg_del_exclude_ports(struct net_bridge_mdb_entry *sgmp)\n{\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_port_group *p;\n\n\t \n\tif (WARN_ON(br_multicast_is_star_g(&sgmp->addr)))\n\t\treturn;\n\n\t \n\tfor (pp = &sgmp->ports;\n\t     (p = mlock_dereference(*pp, sgmp->br)) != NULL;\n\t     pp = &p->next)\n\t\tif (!(p->flags & (MDB_PG_FLAGS_STAR_EXCL |\n\t\t\t\t  MDB_PG_FLAGS_PERMANENT)))\n\t\t\treturn;\n\n\t \n\tsgmp->host_joined = false;\n\n\tfor (pp = &sgmp->ports;\n\t     (p = mlock_dereference(*pp, sgmp->br)) != NULL;) {\n\t\tif (!(p->flags & MDB_PG_FLAGS_PERMANENT))\n\t\t\tbr_multicast_del_pg(sgmp, p, pp);\n\t\telse\n\t\t\tpp = &p->next;\n\t}\n}\n\nvoid br_multicast_sg_add_exclude_ports(struct net_bridge_mdb_entry *star_mp,\n\t\t\t\t       struct net_bridge_port_group *sg)\n{\n\tstruct net_bridge_port_group_sg_key sg_key;\n\tstruct net_bridge *br = star_mp->br;\n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_port_group *pg;\n\tstruct net_bridge_mcast *brmctx;\n\n\tif (WARN_ON(br_multicast_is_star_g(&sg->key.addr)))\n\t\treturn;\n\tif (WARN_ON(!br_multicast_is_star_g(&star_mp->addr)))\n\t\treturn;\n\n\tbr_multicast_sg_host_state(star_mp, sg);\n\tmemset(&sg_key, 0, sizeof(sg_key));\n\tsg_key.addr = sg->key.addr;\n\t \n\tfor (pg = mlock_dereference(star_mp->ports, br);\n\t     pg;\n\t     pg = mlock_dereference(pg->next, br)) {\n\t\tstruct net_bridge_port_group *src_pg;\n\n\t\tif (pg == sg || pg->filter_mode == MCAST_INCLUDE)\n\t\t\tcontinue;\n\n\t\tsg_key.port = pg->key.port;\n\t\tif (br_sg_port_find(br, &sg_key))\n\t\t\tcontinue;\n\n\t\tpmctx = br_multicast_pg_to_port_ctx(pg);\n\t\tif (!pmctx)\n\t\t\tcontinue;\n\t\tbrmctx = br_multicast_port_ctx_get_global(pmctx);\n\n\t\tsrc_pg = __br_multicast_add_group(brmctx, pmctx,\n\t\t\t\t\t\t  &sg->key.addr,\n\t\t\t\t\t\t  sg->eth_addr,\n\t\t\t\t\t\t  MCAST_INCLUDE, false, false);\n\t\tif (IS_ERR_OR_NULL(src_pg) ||\n\t\t    src_pg->rt_protocol != RTPROT_KERNEL)\n\t\t\tcontinue;\n\t\tsrc_pg->flags |= MDB_PG_FLAGS_STAR_EXCL;\n\t}\n}\n\nstatic void br_multicast_fwd_src_add(struct net_bridge_group_src *src)\n{\n\tstruct net_bridge_mdb_entry *star_mp;\n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_port_group *sg;\n\tstruct net_bridge_mcast *brmctx;\n\tstruct br_ip sg_ip;\n\n\tif (src->flags & BR_SGRP_F_INSTALLED)\n\t\treturn;\n\n\tmemset(&sg_ip, 0, sizeof(sg_ip));\n\tpmctx = br_multicast_pg_to_port_ctx(src->pg);\n\tif (!pmctx)\n\t\treturn;\n\tbrmctx = br_multicast_port_ctx_get_global(pmctx);\n\tsg_ip = src->pg->key.addr;\n\tsg_ip.src = src->addr.src;\n\n\tsg = __br_multicast_add_group(brmctx, pmctx, &sg_ip,\n\t\t\t\t      src->pg->eth_addr, MCAST_INCLUDE, false,\n\t\t\t\t      !timer_pending(&src->timer));\n\tif (IS_ERR_OR_NULL(sg))\n\t\treturn;\n\tsrc->flags |= BR_SGRP_F_INSTALLED;\n\tsg->flags &= ~MDB_PG_FLAGS_STAR_EXCL;\n\n\t \n\tif (sg->rt_protocol != RTPROT_KERNEL &&\n\t    (sg->flags & MDB_PG_FLAGS_PERMANENT))\n\t\treturn;\n\n\t \n\tdel_timer(&sg->timer);\n\tstar_mp = br_mdb_ip_get(src->br, &src->pg->key.addr);\n\tif (!star_mp)\n\t\treturn;\n\n\tbr_multicast_sg_add_exclude_ports(star_mp, sg);\n}\n\nstatic void br_multicast_fwd_src_remove(struct net_bridge_group_src *src,\n\t\t\t\t\tbool fastleave)\n{\n\tstruct net_bridge_port_group *p, *pg = src->pg;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct br_ip sg_ip;\n\n\tmemset(&sg_ip, 0, sizeof(sg_ip));\n\tsg_ip = pg->key.addr;\n\tsg_ip.src = src->addr.src;\n\n\tmp = br_mdb_ip_get(src->br, &sg_ip);\n\tif (!mp)\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, src->br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!br_port_group_equal(p, pg->key.port, pg->eth_addr))\n\t\t\tcontinue;\n\n\t\tif (p->rt_protocol != RTPROT_KERNEL &&\n\t\t    (p->flags & MDB_PG_FLAGS_PERMANENT) &&\n\t\t    !(src->flags & BR_SGRP_F_USER_ADDED))\n\t\t\tbreak;\n\n\t\tif (fastleave)\n\t\t\tp->flags |= MDB_PG_FLAGS_FAST_LEAVE;\n\t\tbr_multicast_del_pg(mp, p, pp);\n\t\tbreak;\n\t}\n\tsrc->flags &= ~BR_SGRP_F_INSTALLED;\n}\n\n \nstatic void br_multicast_fwd_src_handle(struct net_bridge_group_src *src)\n{\n\tstruct net_bridge_port_group_sg_key sg_key;\n\tstruct net_bridge_port_group *sg;\n\tu8 old_flags;\n\n\tbr_multicast_fwd_src_add(src);\n\n\tmemset(&sg_key, 0, sizeof(sg_key));\n\tsg_key.addr = src->pg->key.addr;\n\tsg_key.addr.src = src->addr.src;\n\tsg_key.port = src->pg->key.port;\n\n\tsg = br_sg_port_find(src->br, &sg_key);\n\tif (!sg || (sg->flags & MDB_PG_FLAGS_PERMANENT))\n\t\treturn;\n\n\told_flags = sg->flags;\n\tif (timer_pending(&src->timer))\n\t\tsg->flags &= ~MDB_PG_FLAGS_BLOCKED;\n\telse\n\t\tsg->flags |= MDB_PG_FLAGS_BLOCKED;\n\n\tif (old_flags != sg->flags) {\n\t\tstruct net_bridge_mdb_entry *sg_mp;\n\n\t\tsg_mp = br_mdb_ip_get(src->br, &sg_key.addr);\n\t\tif (!sg_mp)\n\t\t\treturn;\n\t\tbr_mdb_notify(src->br->dev, sg_mp, sg, RTM_NEWMDB);\n\t}\n}\n\nstatic void br_multicast_destroy_mdb_entry(struct net_bridge_mcast_gc *gc)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\n\tmp = container_of(gc, struct net_bridge_mdb_entry, mcast_gc);\n\tWARN_ON(!hlist_unhashed(&mp->mdb_node));\n\tWARN_ON(mp->ports);\n\n\ttimer_shutdown_sync(&mp->timer);\n\tkfree_rcu(mp, rcu);\n}\n\nstatic void br_multicast_del_mdb_entry(struct net_bridge_mdb_entry *mp)\n{\n\tstruct net_bridge *br = mp->br;\n\n\trhashtable_remove_fast(&br->mdb_hash_tbl, &mp->rhnode,\n\t\t\t       br_mdb_rht_params);\n\thlist_del_init_rcu(&mp->mdb_node);\n\thlist_add_head(&mp->mcast_gc.gc_node, &br->mcast_gc_list);\n\tqueue_work(system_long_wq, &br->mcast_gc_work);\n}\n\nstatic void br_multicast_group_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mdb_entry *mp = from_timer(mp, t, timer);\n\tstruct net_bridge *br = mp->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (hlist_unhashed(&mp->mdb_node) || !netif_running(br->dev) ||\n\t    timer_pending(&mp->timer))\n\t\tgoto out;\n\n\tbr_multicast_host_leave(mp, true);\n\n\tif (mp->ports)\n\t\tgoto out;\n\tbr_multicast_del_mdb_entry(mp);\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_destroy_group_src(struct net_bridge_mcast_gc *gc)\n{\n\tstruct net_bridge_group_src *src;\n\n\tsrc = container_of(gc, struct net_bridge_group_src, mcast_gc);\n\tWARN_ON(!hlist_unhashed(&src->node));\n\n\ttimer_shutdown_sync(&src->timer);\n\tkfree_rcu(src, rcu);\n}\n\nvoid __br_multicast_del_group_src(struct net_bridge_group_src *src)\n{\n\tstruct net_bridge *br = src->pg->key.port->br;\n\n\thlist_del_init_rcu(&src->node);\n\tsrc->pg->src_ents--;\n\thlist_add_head(&src->mcast_gc.gc_node, &br->mcast_gc_list);\n\tqueue_work(system_long_wq, &br->mcast_gc_work);\n}\n\nvoid br_multicast_del_group_src(struct net_bridge_group_src *src,\n\t\t\t\tbool fastleave)\n{\n\tbr_multicast_fwd_src_remove(src, fastleave);\n\t__br_multicast_del_group_src(src);\n}\n\nstatic int\nbr_multicast_port_ngroups_inc_one(struct net_bridge_mcast_port *pmctx,\n\t\t\t\t  struct netlink_ext_ack *extack,\n\t\t\t\t  const char *what)\n{\n\tu32 max = READ_ONCE(pmctx->mdb_max_entries);\n\tu32 n = READ_ONCE(pmctx->mdb_n_entries);\n\n\tif (max && n >= max) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"%s is already in %u groups, and mcast_max_groups=%u\",\n\t\t\t\t       what, n, max);\n\t\treturn -E2BIG;\n\t}\n\n\tWRITE_ONCE(pmctx->mdb_n_entries, n + 1);\n\treturn 0;\n}\n\nstatic void br_multicast_port_ngroups_dec_one(struct net_bridge_mcast_port *pmctx)\n{\n\tu32 n = READ_ONCE(pmctx->mdb_n_entries);\n\n\tWARN_ON_ONCE(n == 0);\n\tWRITE_ONCE(pmctx->mdb_n_entries, n - 1);\n}\n\nstatic int br_multicast_port_ngroups_inc(struct net_bridge_port *port,\n\t\t\t\t\t const struct br_ip *group,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_mcast_port *pmctx;\n\tint err;\n\n\tlockdep_assert_held_once(&port->br->multicast_lock);\n\n\t \n\terr = br_multicast_port_ngroups_inc_one(&port->multicast_ctx, extack,\n\t\t\t\t\t\t\"Port\");\n\tif (err) {\n\t\ttrace_br_mdb_full(port->dev, group);\n\t\treturn err;\n\t}\n\n\t \n\tif (!group->vid)\n\t\treturn 0;\n\n\tpmctx = br_multicast_port_vid_to_port_ctx(port, group->vid);\n\tif (!pmctx)\n\t\treturn 0;\n\n\terr = br_multicast_port_ngroups_inc_one(pmctx, extack, \"Port-VLAN\");\n\tif (err) {\n\t\ttrace_br_mdb_full(port->dev, group);\n\t\tgoto dec_one_out;\n\t}\n\n\treturn 0;\n\ndec_one_out:\n\tbr_multicast_port_ngroups_dec_one(&port->multicast_ctx);\n\treturn err;\n}\n\nstatic void br_multicast_port_ngroups_dec(struct net_bridge_port *port, u16 vid)\n{\n\tstruct net_bridge_mcast_port *pmctx;\n\n\tlockdep_assert_held_once(&port->br->multicast_lock);\n\n\tif (vid) {\n\t\tpmctx = br_multicast_port_vid_to_port_ctx(port, vid);\n\t\tif (pmctx)\n\t\t\tbr_multicast_port_ngroups_dec_one(pmctx);\n\t}\n\tbr_multicast_port_ngroups_dec_one(&port->multicast_ctx);\n}\n\nu32 br_multicast_ngroups_get(const struct net_bridge_mcast_port *pmctx)\n{\n\treturn READ_ONCE(pmctx->mdb_n_entries);\n}\n\nvoid br_multicast_ngroups_set_max(struct net_bridge_mcast_port *pmctx, u32 max)\n{\n\tWRITE_ONCE(pmctx->mdb_max_entries, max);\n}\n\nu32 br_multicast_ngroups_get_max(const struct net_bridge_mcast_port *pmctx)\n{\n\treturn READ_ONCE(pmctx->mdb_max_entries);\n}\n\nstatic void br_multicast_destroy_port_group(struct net_bridge_mcast_gc *gc)\n{\n\tstruct net_bridge_port_group *pg;\n\n\tpg = container_of(gc, struct net_bridge_port_group, mcast_gc);\n\tWARN_ON(!hlist_unhashed(&pg->mglist));\n\tWARN_ON(!hlist_empty(&pg->src_list));\n\n\ttimer_shutdown_sync(&pg->rexmit_timer);\n\ttimer_shutdown_sync(&pg->timer);\n\tkfree_rcu(pg, rcu);\n}\n\nvoid br_multicast_del_pg(struct net_bridge_mdb_entry *mp,\n\t\t\t struct net_bridge_port_group *pg,\n\t\t\t struct net_bridge_port_group __rcu **pp)\n{\n\tstruct net_bridge *br = pg->key.port->br;\n\tstruct net_bridge_group_src *ent;\n\tstruct hlist_node *tmp;\n\n\trcu_assign_pointer(*pp, pg->next);\n\thlist_del_init(&pg->mglist);\n\tbr_multicast_eht_clean_sets(pg);\n\thlist_for_each_entry_safe(ent, tmp, &pg->src_list, node)\n\t\tbr_multicast_del_group_src(ent, false);\n\tbr_mdb_notify(br->dev, mp, pg, RTM_DELMDB);\n\tif (!br_multicast_is_star_g(&mp->addr)) {\n\t\trhashtable_remove_fast(&br->sg_port_tbl, &pg->rhnode,\n\t\t\t\t       br_sg_port_rht_params);\n\t\tbr_multicast_sg_del_exclude_ports(mp);\n\t} else {\n\t\tbr_multicast_star_g_handle_mode(pg, MCAST_INCLUDE);\n\t}\n\tbr_multicast_port_ngroups_dec(pg->key.port, pg->key.addr.vid);\n\thlist_add_head(&pg->mcast_gc.gc_node, &br->mcast_gc_list);\n\tqueue_work(system_long_wq, &br->mcast_gc_work);\n\n\tif (!mp->ports && !mp->host_joined && netif_running(br->dev))\n\t\tmod_timer(&mp->timer, jiffies);\n}\n\nstatic void br_multicast_find_del_pg(struct net_bridge *br,\n\t\t\t\t     struct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\n\tmp = br_mdb_ip_get(br, &pg->key.addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\tbr_multicast_del_pg(mp, pg, pp);\n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}\n\nstatic void br_multicast_port_group_expired(struct timer_list *t)\n{\n\tstruct net_bridge_port_group *pg = from_timer(pg, t, timer);\n\tstruct net_bridge_group_src *src_ent;\n\tstruct net_bridge *br = pg->key.port->br;\n\tstruct hlist_node *tmp;\n\tbool changed;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&pg->timer) ||\n\t    hlist_unhashed(&pg->mglist) || pg->flags & MDB_PG_FLAGS_PERMANENT)\n\t\tgoto out;\n\n\tchanged = !!(pg->filter_mode == MCAST_EXCLUDE);\n\tpg->filter_mode = MCAST_INCLUDE;\n\thlist_for_each_entry_safe(src_ent, tmp, &pg->src_list, node) {\n\t\tif (!timer_pending(&src_ent->timer)) {\n\t\t\tbr_multicast_del_group_src(src_ent, false);\n\t\t\tchanged = true;\n\t\t}\n\t}\n\n\tif (hlist_empty(&pg->src_list)) {\n\t\tbr_multicast_find_del_pg(br, pg);\n\t} else if (changed) {\n\t\tstruct net_bridge_mdb_entry *mp = br_mdb_ip_get(br, &pg->key.addr);\n\n\t\tif (changed && br_multicast_is_star_g(&pg->key.addr))\n\t\t\tbr_multicast_star_g_handle_mode(pg, MCAST_INCLUDE);\n\n\t\tif (WARN_ON(!mp))\n\t\t\tgoto out;\n\t\tbr_mdb_notify(br->dev, mp, pg, RTM_NEWMDB);\n\t}\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_gc(struct hlist_head *head)\n{\n\tstruct net_bridge_mcast_gc *gcent;\n\tstruct hlist_node *tmp;\n\n\thlist_for_each_entry_safe(gcent, tmp, head, gc_node) {\n\t\thlist_del_init(&gcent->gc_node);\n\t\tgcent->destroy(gcent);\n\t}\n}\n\nstatic void __br_multicast_query_handle_vlan(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t     struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct net_bridge_vlan *vlan = NULL;\n\n\tif (pmctx && br_multicast_port_ctx_is_vlan(pmctx))\n\t\tvlan = pmctx->vlan;\n\telse if (br_multicast_ctx_is_vlan(brmctx))\n\t\tvlan = brmctx->vlan;\n\n\tif (vlan && !(vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED)) {\n\t\tu16 vlan_proto;\n\n\t\tif (br_vlan_get_proto(brmctx->br->dev, &vlan_proto) != 0)\n\t\t\treturn;\n\t\t__vlan_hwaccel_put_tag(skb, htons(vlan_proto), vlan->vid);\n\t}\n}\n\nstatic struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t\t    struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t\t    struct net_bridge_port_group *pg,\n\t\t\t\t\t\t    __be32 ip_dst, __be32 group,\n\t\t\t\t\t\t    bool with_srcs, bool over_lmqt,\n\t\t\t\t\t\t    u8 sflag, u8 *igmp_type,\n\t\t\t\t\t\t    bool *need_rexmit)\n{\n\tstruct net_bridge_port *p = pg ? pg->key.port : NULL;\n\tstruct net_bridge_group_src *ent;\n\tsize_t pkt_size, igmp_hdr_size;\n\tunsigned long now = jiffies;\n\tstruct igmpv3_query *ihv3;\n\tvoid *csum_start = NULL;\n\t__sum16 *csum = NULL;\n\tstruct sk_buff *skb;\n\tstruct igmphdr *ih;\n\tstruct ethhdr *eth;\n\tunsigned long lmqt;\n\tstruct iphdr *iph;\n\tu16 lmqt_srcs = 0;\n\n\tigmp_hdr_size = sizeof(*ih);\n\tif (brmctx->multicast_igmp_version == 3) {\n\t\tigmp_hdr_size = sizeof(*ihv3);\n\t\tif (pg && with_srcs) {\n\t\t\tlmqt = now + (brmctx->multicast_last_member_interval *\n\t\t\t\t      brmctx->multicast_last_member_count);\n\t\t\thlist_for_each_entry(ent, &pg->src_list, node) {\n\t\t\t\tif (over_lmqt == time_after(ent->timer.expires,\n\t\t\t\t\t\t\t    lmqt) &&\n\t\t\t\t    ent->src_query_rexmit_cnt > 0)\n\t\t\t\t\tlmqt_srcs++;\n\t\t\t}\n\n\t\t\tif (!lmqt_srcs)\n\t\t\t\treturn NULL;\n\t\t\tigmp_hdr_size += lmqt_srcs * sizeof(__be32);\n\t\t}\n\t}\n\n\tpkt_size = sizeof(*eth) + sizeof(*iph) + 4 + igmp_hdr_size;\n\tif ((p && pkt_size > p->dev->mtu) ||\n\t    pkt_size > brmctx->br->dev->mtu)\n\t\treturn NULL;\n\n\tskb = netdev_alloc_skb_ip_align(brmctx->br->dev, pkt_size);\n\tif (!skb)\n\t\tgoto out;\n\n\t__br_multicast_query_handle_vlan(brmctx, pmctx, skb);\n\tskb->protocol = htons(ETH_P_IP);\n\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tether_addr_copy(eth->h_source, brmctx->br->dev->dev_addr);\n\tip_eth_mc_map(ip_dst, eth->h_dest);\n\teth->h_proto = htons(ETH_P_IP);\n\tskb_put(skb, sizeof(*eth));\n\n\tskb_set_network_header(skb, skb->len);\n\tiph = ip_hdr(skb);\n\tiph->tot_len = htons(pkt_size - sizeof(*eth));\n\n\tiph->version = 4;\n\tiph->ihl = 6;\n\tiph->tos = 0xc0;\n\tiph->id = 0;\n\tiph->frag_off = htons(IP_DF);\n\tiph->ttl = 1;\n\tiph->protocol = IPPROTO_IGMP;\n\tiph->saddr = br_opt_get(brmctx->br, BROPT_MULTICAST_QUERY_USE_IFADDR) ?\n\t\t     inet_select_addr(brmctx->br->dev, 0, RT_SCOPE_LINK) : 0;\n\tiph->daddr = ip_dst;\n\t((u8 *)&iph[1])[0] = IPOPT_RA;\n\t((u8 *)&iph[1])[1] = 4;\n\t((u8 *)&iph[1])[2] = 0;\n\t((u8 *)&iph[1])[3] = 0;\n\tip_send_check(iph);\n\tskb_put(skb, 24);\n\n\tskb_set_transport_header(skb, skb->len);\n\t*igmp_type = IGMP_HOST_MEMBERSHIP_QUERY;\n\n\tswitch (brmctx->multicast_igmp_version) {\n\tcase 2:\n\t\tih = igmp_hdr(skb);\n\t\tih->type = IGMP_HOST_MEMBERSHIP_QUERY;\n\t\tih->code = (group ? brmctx->multicast_last_member_interval :\n\t\t\t\t    brmctx->multicast_query_response_interval) /\n\t\t\t   (HZ / IGMP_TIMER_SCALE);\n\t\tih->group = group;\n\t\tih->csum = 0;\n\t\tcsum = &ih->csum;\n\t\tcsum_start = (void *)ih;\n\t\tbreak;\n\tcase 3:\n\t\tihv3 = igmpv3_query_hdr(skb);\n\t\tihv3->type = IGMP_HOST_MEMBERSHIP_QUERY;\n\t\tihv3->code = (group ? brmctx->multicast_last_member_interval :\n\t\t\t\t      brmctx->multicast_query_response_interval) /\n\t\t\t     (HZ / IGMP_TIMER_SCALE);\n\t\tihv3->group = group;\n\t\tihv3->qqic = brmctx->multicast_query_interval / HZ;\n\t\tihv3->nsrcs = htons(lmqt_srcs);\n\t\tihv3->resv = 0;\n\t\tihv3->suppress = sflag;\n\t\tihv3->qrv = 2;\n\t\tihv3->csum = 0;\n\t\tcsum = &ihv3->csum;\n\t\tcsum_start = (void *)ihv3;\n\t\tif (!pg || !with_srcs)\n\t\t\tbreak;\n\n\t\tlmqt_srcs = 0;\n\t\thlist_for_each_entry(ent, &pg->src_list, node) {\n\t\t\tif (over_lmqt == time_after(ent->timer.expires,\n\t\t\t\t\t\t    lmqt) &&\n\t\t\t    ent->src_query_rexmit_cnt > 0) {\n\t\t\t\tihv3->srcs[lmqt_srcs++] = ent->addr.src.ip4;\n\t\t\t\tent->src_query_rexmit_cnt--;\n\t\t\t\tif (need_rexmit && ent->src_query_rexmit_cnt)\n\t\t\t\t\t*need_rexmit = true;\n\t\t\t}\n\t\t}\n\t\tif (WARN_ON(lmqt_srcs != ntohs(ihv3->nsrcs))) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (WARN_ON(!csum || !csum_start)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\t*csum = ip_compute_csum(csum_start, igmp_hdr_size);\n\tskb_put(skb, igmp_hdr_size);\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct sk_buff *br_ip6_multicast_alloc_query(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t\t    struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t\t    struct net_bridge_port_group *pg,\n\t\t\t\t\t\t    const struct in6_addr *ip6_dst,\n\t\t\t\t\t\t    const struct in6_addr *group,\n\t\t\t\t\t\t    bool with_srcs, bool over_llqt,\n\t\t\t\t\t\t    u8 sflag, u8 *igmp_type,\n\t\t\t\t\t\t    bool *need_rexmit)\n{\n\tstruct net_bridge_port *p = pg ? pg->key.port : NULL;\n\tstruct net_bridge_group_src *ent;\n\tsize_t pkt_size, mld_hdr_size;\n\tunsigned long now = jiffies;\n\tstruct mld2_query *mld2q;\n\tvoid *csum_start = NULL;\n\tunsigned long interval;\n\t__sum16 *csum = NULL;\n\tstruct ipv6hdr *ip6h;\n\tstruct mld_msg *mldq;\n\tstruct sk_buff *skb;\n\tunsigned long llqt;\n\tstruct ethhdr *eth;\n\tu16 llqt_srcs = 0;\n\tu8 *hopopt;\n\n\tmld_hdr_size = sizeof(*mldq);\n\tif (brmctx->multicast_mld_version == 2) {\n\t\tmld_hdr_size = sizeof(*mld2q);\n\t\tif (pg && with_srcs) {\n\t\t\tllqt = now + (brmctx->multicast_last_member_interval *\n\t\t\t\t      brmctx->multicast_last_member_count);\n\t\t\thlist_for_each_entry(ent, &pg->src_list, node) {\n\t\t\t\tif (over_llqt == time_after(ent->timer.expires,\n\t\t\t\t\t\t\t    llqt) &&\n\t\t\t\t    ent->src_query_rexmit_cnt > 0)\n\t\t\t\t\tllqt_srcs++;\n\t\t\t}\n\n\t\t\tif (!llqt_srcs)\n\t\t\t\treturn NULL;\n\t\t\tmld_hdr_size += llqt_srcs * sizeof(struct in6_addr);\n\t\t}\n\t}\n\n\tpkt_size = sizeof(*eth) + sizeof(*ip6h) + 8 + mld_hdr_size;\n\tif ((p && pkt_size > p->dev->mtu) ||\n\t    pkt_size > brmctx->br->dev->mtu)\n\t\treturn NULL;\n\n\tskb = netdev_alloc_skb_ip_align(brmctx->br->dev, pkt_size);\n\tif (!skb)\n\t\tgoto out;\n\n\t__br_multicast_query_handle_vlan(brmctx, pmctx, skb);\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\t \n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tether_addr_copy(eth->h_source, brmctx->br->dev->dev_addr);\n\teth->h_proto = htons(ETH_P_IPV6);\n\tskb_put(skb, sizeof(*eth));\n\n\t \n\tskb_set_network_header(skb, skb->len);\n\tip6h = ipv6_hdr(skb);\n\n\t*(__force __be32 *)ip6h = htonl(0x60000000);\n\tip6h->payload_len = htons(8 + mld_hdr_size);\n\tip6h->nexthdr = IPPROTO_HOPOPTS;\n\tip6h->hop_limit = 1;\n\tip6h->daddr = *ip6_dst;\n\tif (ipv6_dev_get_saddr(dev_net(brmctx->br->dev), brmctx->br->dev,\n\t\t\t       &ip6h->daddr, 0, &ip6h->saddr)) {\n\t\tkfree_skb(skb);\n\t\tbr_opt_toggle(brmctx->br, BROPT_HAS_IPV6_ADDR, false);\n\t\treturn NULL;\n\t}\n\n\tbr_opt_toggle(brmctx->br, BROPT_HAS_IPV6_ADDR, true);\n\tipv6_eth_mc_map(&ip6h->daddr, eth->h_dest);\n\n\thopopt = (u8 *)(ip6h + 1);\n\thopopt[0] = IPPROTO_ICMPV6;\t\t \n\thopopt[1] = 0;\t\t\t\t \n\thopopt[2] = IPV6_TLV_ROUTERALERT;\t \n\thopopt[3] = 2;\t\t\t\t \n\thopopt[4] = 0;\t\t\t\t \n\thopopt[5] = 0;\n\thopopt[6] = IPV6_TLV_PAD1;\t\t \n\thopopt[7] = IPV6_TLV_PAD1;\t\t \n\n\tskb_put(skb, sizeof(*ip6h) + 8);\n\n\t \n\tskb_set_transport_header(skb, skb->len);\n\tinterval = ipv6_addr_any(group) ?\n\t\t\tbrmctx->multicast_query_response_interval :\n\t\t\tbrmctx->multicast_last_member_interval;\n\t*igmp_type = ICMPV6_MGM_QUERY;\n\tswitch (brmctx->multicast_mld_version) {\n\tcase 1:\n\t\tmldq = (struct mld_msg *)icmp6_hdr(skb);\n\t\tmldq->mld_type = ICMPV6_MGM_QUERY;\n\t\tmldq->mld_code = 0;\n\t\tmldq->mld_cksum = 0;\n\t\tmldq->mld_maxdelay = htons((u16)jiffies_to_msecs(interval));\n\t\tmldq->mld_reserved = 0;\n\t\tmldq->mld_mca = *group;\n\t\tcsum = &mldq->mld_cksum;\n\t\tcsum_start = (void *)mldq;\n\t\tbreak;\n\tcase 2:\n\t\tmld2q = (struct mld2_query *)icmp6_hdr(skb);\n\t\tmld2q->mld2q_mrc = htons((u16)jiffies_to_msecs(interval));\n\t\tmld2q->mld2q_type = ICMPV6_MGM_QUERY;\n\t\tmld2q->mld2q_code = 0;\n\t\tmld2q->mld2q_cksum = 0;\n\t\tmld2q->mld2q_resv1 = 0;\n\t\tmld2q->mld2q_resv2 = 0;\n\t\tmld2q->mld2q_suppress = sflag;\n\t\tmld2q->mld2q_qrv = 2;\n\t\tmld2q->mld2q_nsrcs = htons(llqt_srcs);\n\t\tmld2q->mld2q_qqic = brmctx->multicast_query_interval / HZ;\n\t\tmld2q->mld2q_mca = *group;\n\t\tcsum = &mld2q->mld2q_cksum;\n\t\tcsum_start = (void *)mld2q;\n\t\tif (!pg || !with_srcs)\n\t\t\tbreak;\n\n\t\tllqt_srcs = 0;\n\t\thlist_for_each_entry(ent, &pg->src_list, node) {\n\t\t\tif (over_llqt == time_after(ent->timer.expires,\n\t\t\t\t\t\t    llqt) &&\n\t\t\t    ent->src_query_rexmit_cnt > 0) {\n\t\t\t\tmld2q->mld2q_srcs[llqt_srcs++] = ent->addr.src.ip6;\n\t\t\t\tent->src_query_rexmit_cnt--;\n\t\t\t\tif (need_rexmit && ent->src_query_rexmit_cnt)\n\t\t\t\t\t*need_rexmit = true;\n\t\t\t}\n\t\t}\n\t\tif (WARN_ON(llqt_srcs != ntohs(mld2q->mld2q_nsrcs))) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (WARN_ON(!csum || !csum_start)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\t*csum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr, mld_hdr_size,\n\t\t\t\tIPPROTO_ICMPV6,\n\t\t\t\tcsum_partial(csum_start, mld_hdr_size, 0));\n\tskb_put(skb, mld_hdr_size);\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n#endif\n\nstatic struct sk_buff *br_multicast_alloc_query(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t\tstruct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t\tstruct net_bridge_port_group *pg,\n\t\t\t\t\t\tstruct br_ip *ip_dst,\n\t\t\t\t\t\tstruct br_ip *group,\n\t\t\t\t\t\tbool with_srcs, bool over_lmqt,\n\t\t\t\t\t\tu8 sflag, u8 *igmp_type,\n\t\t\t\t\t\tbool *need_rexmit)\n{\n\t__be32 ip4_dst;\n\n\tswitch (group->proto) {\n\tcase htons(ETH_P_IP):\n\t\tip4_dst = ip_dst ? ip_dst->dst.ip4 : htonl(INADDR_ALLHOSTS_GROUP);\n\t\treturn br_ip4_multicast_alloc_query(brmctx, pmctx, pg,\n\t\t\t\t\t\t    ip4_dst, group->dst.ip4,\n\t\t\t\t\t\t    with_srcs, over_lmqt,\n\t\t\t\t\t\t    sflag, igmp_type,\n\t\t\t\t\t\t    need_rexmit);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6): {\n\t\tstruct in6_addr ip6_dst;\n\n\t\tif (ip_dst)\n\t\t\tip6_dst = ip_dst->dst.ip6;\n\t\telse\n\t\t\tipv6_addr_set(&ip6_dst, htonl(0xff020000), 0, 0,\n\t\t\t\t      htonl(1));\n\n\t\treturn br_ip6_multicast_alloc_query(brmctx, pmctx, pg,\n\t\t\t\t\t\t    &ip6_dst, &group->dst.ip6,\n\t\t\t\t\t\t    with_srcs, over_lmqt,\n\t\t\t\t\t\t    sflag, igmp_type,\n\t\t\t\t\t\t    need_rexmit);\n\t}\n#endif\n\t}\n\treturn NULL;\n}\n\nstruct net_bridge_mdb_entry *br_multicast_new_group(struct net_bridge *br,\n\t\t\t\t\t\t    struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tint err;\n\n\tmp = br_mdb_ip_get(br, group);\n\tif (mp)\n\t\treturn mp;\n\n\tif (atomic_read(&br->mdb_hash_tbl.nelems) >= br->hash_max) {\n\t\ttrace_br_mdb_full(br->dev, group);\n\t\tbr_mc_disabled_update(br->dev, false, NULL);\n\t\tbr_opt_toggle(br, BROPT_MULTICAST_ENABLED, false);\n\t\treturn ERR_PTR(-E2BIG);\n\t}\n\n\tmp = kzalloc(sizeof(*mp), GFP_ATOMIC);\n\tif (unlikely(!mp))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmp->br = br;\n\tmp->addr = *group;\n\tmp->mcast_gc.destroy = br_multicast_destroy_mdb_entry;\n\ttimer_setup(&mp->timer, br_multicast_group_expired, 0);\n\terr = rhashtable_lookup_insert_fast(&br->mdb_hash_tbl, &mp->rhnode,\n\t\t\t\t\t    br_mdb_rht_params);\n\tif (err) {\n\t\tkfree(mp);\n\t\tmp = ERR_PTR(err);\n\t} else {\n\t\thlist_add_head_rcu(&mp->mdb_node, &br->mdb_list);\n\t}\n\n\treturn mp;\n}\n\nstatic void br_multicast_group_src_expired(struct timer_list *t)\n{\n\tstruct net_bridge_group_src *src = from_timer(src, t, timer);\n\tstruct net_bridge_port_group *pg;\n\tstruct net_bridge *br = src->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (hlist_unhashed(&src->node) || !netif_running(br->dev) ||\n\t    timer_pending(&src->timer))\n\t\tgoto out;\n\n\tpg = src->pg;\n\tif (pg->filter_mode == MCAST_INCLUDE) {\n\t\tbr_multicast_del_group_src(src, false);\n\t\tif (!hlist_empty(&pg->src_list))\n\t\t\tgoto out;\n\t\tbr_multicast_find_del_pg(br, pg);\n\t} else {\n\t\tbr_multicast_fwd_src_handle(src);\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstruct net_bridge_group_src *\nbr_multicast_find_group_src(struct net_bridge_port_group *pg, struct br_ip *ip)\n{\n\tstruct net_bridge_group_src *ent;\n\n\tswitch (ip->proto) {\n\tcase htons(ETH_P_IP):\n\t\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\t\tif (ip->src.ip4 == ent->addr.src.ip4)\n\t\t\t\treturn ent;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\t\tif (!ipv6_addr_cmp(&ent->addr.src.ip6, &ip->src.ip6))\n\t\t\t\treturn ent;\n\t\tbreak;\n#endif\n\t}\n\n\treturn NULL;\n}\n\nstruct net_bridge_group_src *\nbr_multicast_new_group_src(struct net_bridge_port_group *pg, struct br_ip *src_ip)\n{\n\tstruct net_bridge_group_src *grp_src;\n\n\tif (unlikely(pg->src_ents >= PG_SRC_ENT_LIMIT))\n\t\treturn NULL;\n\n\tswitch (src_ip->proto) {\n\tcase htons(ETH_P_IP):\n\t\tif (ipv4_is_zeronet(src_ip->src.ip4) ||\n\t\t    ipv4_is_multicast(src_ip->src.ip4))\n\t\t\treturn NULL;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tif (ipv6_addr_any(&src_ip->src.ip6) ||\n\t\t    ipv6_addr_is_multicast(&src_ip->src.ip6))\n\t\t\treturn NULL;\n\t\tbreak;\n#endif\n\t}\n\n\tgrp_src = kzalloc(sizeof(*grp_src), GFP_ATOMIC);\n\tif (unlikely(!grp_src))\n\t\treturn NULL;\n\n\tgrp_src->pg = pg;\n\tgrp_src->br = pg->key.port->br;\n\tgrp_src->addr = *src_ip;\n\tgrp_src->mcast_gc.destroy = br_multicast_destroy_group_src;\n\ttimer_setup(&grp_src->timer, br_multicast_group_src_expired, 0);\n\n\thlist_add_head_rcu(&grp_src->node, &pg->src_list);\n\tpg->src_ents++;\n\n\treturn grp_src;\n}\n\nstruct net_bridge_port_group *br_multicast_new_port_group(\n\t\t\tstruct net_bridge_port *port,\n\t\t\tconst struct br_ip *group,\n\t\t\tstruct net_bridge_port_group __rcu *next,\n\t\t\tunsigned char flags,\n\t\t\tconst unsigned char *src,\n\t\t\tu8 filter_mode,\n\t\t\tu8 rt_protocol,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_port_group *p;\n\tint err;\n\n\terr = br_multicast_port_ngroups_inc(port, group, extack);\n\tif (err)\n\t\treturn NULL;\n\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\tif (unlikely(!p)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Couldn't allocate new port group\");\n\t\tgoto dec_out;\n\t}\n\n\tp->key.addr = *group;\n\tp->key.port = port;\n\tp->flags = flags;\n\tp->filter_mode = filter_mode;\n\tp->rt_protocol = rt_protocol;\n\tp->eht_host_tree = RB_ROOT;\n\tp->eht_set_tree = RB_ROOT;\n\tp->mcast_gc.destroy = br_multicast_destroy_port_group;\n\tINIT_HLIST_HEAD(&p->src_list);\n\n\tif (!br_multicast_is_star_g(group) &&\n\t    rhashtable_lookup_insert_fast(&port->br->sg_port_tbl, &p->rhnode,\n\t\t\t\t\t  br_sg_port_rht_params)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Couldn't insert new port group\");\n\t\tgoto free_out;\n\t}\n\n\trcu_assign_pointer(p->next, next);\n\ttimer_setup(&p->timer, br_multicast_port_group_expired, 0);\n\ttimer_setup(&p->rexmit_timer, br_multicast_port_group_rexmit, 0);\n\thlist_add_head(&p->mglist, &port->mglist);\n\n\tif (src)\n\t\tmemcpy(p->eth_addr, src, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(p->eth_addr);\n\n\treturn p;\n\nfree_out:\n\tkfree(p);\ndec_out:\n\tbr_multicast_port_ngroups_dec(port, group->vid);\n\treturn NULL;\n}\n\nvoid br_multicast_del_port_group(struct net_bridge_port_group *p)\n{\n\tstruct net_bridge_port *port = p->key.port;\n\t__u16 vid = p->key.addr.vid;\n\n\thlist_del_init(&p->mglist);\n\tif (!br_multicast_is_star_g(&p->key.addr))\n\t\trhashtable_remove_fast(&port->br->sg_port_tbl, &p->rhnode,\n\t\t\t\t       br_sg_port_rht_params);\n\tkfree(p);\n\tbr_multicast_port_ngroups_dec(port, vid);\n}\n\nvoid br_multicast_host_join(const struct net_bridge_mcast *brmctx,\n\t\t\t    struct net_bridge_mdb_entry *mp, bool notify)\n{\n\tif (!mp->host_joined) {\n\t\tmp->host_joined = true;\n\t\tif (br_multicast_is_star_g(&mp->addr))\n\t\t\tbr_multicast_star_g_host_state(mp);\n\t\tif (notify)\n\t\t\tbr_mdb_notify(mp->br->dev, mp, NULL, RTM_NEWMDB);\n\t}\n\n\tif (br_group_is_l2(&mp->addr))\n\t\treturn;\n\n\tmod_timer(&mp->timer, jiffies + brmctx->multicast_membership_interval);\n}\n\nvoid br_multicast_host_leave(struct net_bridge_mdb_entry *mp, bool notify)\n{\n\tif (!mp->host_joined)\n\t\treturn;\n\n\tmp->host_joined = false;\n\tif (br_multicast_is_star_g(&mp->addr))\n\t\tbr_multicast_star_g_host_state(mp);\n\tif (notify)\n\t\tbr_mdb_notify(mp->br->dev, mp, NULL, RTM_DELMDB);\n}\n\nstatic struct net_bridge_port_group *\n__br_multicast_add_group(struct net_bridge_mcast *brmctx,\n\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t struct br_ip *group,\n\t\t\t const unsigned char *src,\n\t\t\t u8 filter_mode,\n\t\t\t bool igmpv2_mldv1,\n\t\t\t bool blocked)\n{\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_port_group *p = NULL;\n\tstruct net_bridge_mdb_entry *mp;\n\tunsigned long now = jiffies;\n\n\tif (!br_multicast_ctx_should_use(brmctx, pmctx))\n\t\tgoto out;\n\n\tmp = br_multicast_new_group(brmctx->br, group);\n\tif (IS_ERR(mp))\n\t\treturn ERR_CAST(mp);\n\n\tif (!pmctx) {\n\t\tbr_multicast_host_join(brmctx, mp, true);\n\t\tgoto out;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, brmctx->br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (br_port_group_equal(p, pmctx->port, src))\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->key.port < (unsigned long)pmctx->port)\n\t\t\tbreak;\n\t}\n\n\tp = br_multicast_new_port_group(pmctx->port, group, *pp, 0, src,\n\t\t\t\t\tfilter_mode, RTPROT_KERNEL, NULL);\n\tif (unlikely(!p)) {\n\t\tp = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\trcu_assign_pointer(*pp, p);\n\tif (blocked)\n\t\tp->flags |= MDB_PG_FLAGS_BLOCKED;\n\tbr_mdb_notify(brmctx->br->dev, mp, p, RTM_NEWMDB);\n\nfound:\n\tif (igmpv2_mldv1)\n\t\tmod_timer(&p->timer,\n\t\t\t  now + brmctx->multicast_membership_interval);\n\nout:\n\treturn p;\n}\n\nstatic int br_multicast_add_group(struct net_bridge_mcast *brmctx,\n\t\t\t\t  struct net_bridge_mcast_port *pmctx,\n\t\t\t\t  struct br_ip *group,\n\t\t\t\t  const unsigned char *src,\n\t\t\t\t  u8 filter_mode,\n\t\t\t\t  bool igmpv2_mldv1)\n{\n\tstruct net_bridge_port_group *pg;\n\tint err;\n\n\tspin_lock(&brmctx->br->multicast_lock);\n\tpg = __br_multicast_add_group(brmctx, pmctx, group, src, filter_mode,\n\t\t\t\t      igmpv2_mldv1, false);\n\t \n\terr = PTR_ERR_OR_ZERO(pg);\n\tspin_unlock(&brmctx->br->multicast_lock);\n\n\treturn err;\n}\n\nstatic int br_ip4_multicast_add_group(struct net_bridge_mcast *brmctx,\n\t\t\t\t      struct net_bridge_mcast_port *pmctx,\n\t\t\t\t      __be32 group,\n\t\t\t\t      __u16 vid,\n\t\t\t\t      const unsigned char *src,\n\t\t\t\t      bool igmpv2)\n{\n\tstruct br_ip br_group;\n\tu8 filter_mode;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn 0;\n\n\tmemset(&br_group, 0, sizeof(br_group));\n\tbr_group.dst.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\tbr_group.vid = vid;\n\tfilter_mode = igmpv2 ? MCAST_EXCLUDE : MCAST_INCLUDE;\n\n\treturn br_multicast_add_group(brmctx, pmctx, &br_group, src,\n\t\t\t\t      filter_mode, igmpv2);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_ip6_multicast_add_group(struct net_bridge_mcast *brmctx,\n\t\t\t\t      struct net_bridge_mcast_port *pmctx,\n\t\t\t\t      const struct in6_addr *group,\n\t\t\t\t      __u16 vid,\n\t\t\t\t      const unsigned char *src,\n\t\t\t\t      bool mldv1)\n{\n\tstruct br_ip br_group;\n\tu8 filter_mode;\n\n\tif (ipv6_addr_is_ll_all_nodes(group))\n\t\treturn 0;\n\n\tmemset(&br_group, 0, sizeof(br_group));\n\tbr_group.dst.ip6 = *group;\n\tbr_group.proto = htons(ETH_P_IPV6);\n\tbr_group.vid = vid;\n\tfilter_mode = mldv1 ? MCAST_EXCLUDE : MCAST_INCLUDE;\n\n\treturn br_multicast_add_group(brmctx, pmctx, &br_group, src,\n\t\t\t\t      filter_mode, mldv1);\n}\n#endif\n\nstatic bool br_multicast_rport_del(struct hlist_node *rlist)\n{\n\tif (hlist_unhashed(rlist))\n\t\treturn false;\n\n\thlist_del_init_rcu(rlist);\n\treturn true;\n}\n\nstatic bool br_ip4_multicast_rport_del(struct net_bridge_mcast_port *pmctx)\n{\n\treturn br_multicast_rport_del(&pmctx->ip4_rlist);\n}\n\nstatic bool br_ip6_multicast_rport_del(struct net_bridge_mcast_port *pmctx)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\treturn br_multicast_rport_del(&pmctx->ip6_rlist);\n#else\n\treturn false;\n#endif\n}\n\nstatic void br_multicast_router_expired(struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\tstruct timer_list *t,\n\t\t\t\t\tstruct hlist_node *rlist)\n{\n\tstruct net_bridge *br = pmctx->port->br;\n\tbool del;\n\n\tspin_lock(&br->multicast_lock);\n\tif (pmctx->multicast_router == MDB_RTR_TYPE_DISABLED ||\n\t    pmctx->multicast_router == MDB_RTR_TYPE_PERM ||\n\t    timer_pending(t))\n\t\tgoto out;\n\n\tdel = br_multicast_rport_del(rlist);\n\tbr_multicast_rport_del_notify(pmctx, del);\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_ip4_multicast_router_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mcast_port *pmctx = from_timer(pmctx, t,\n\t\t\t\t\t\t\t ip4_mc_router_timer);\n\n\tbr_multicast_router_expired(pmctx, t, &pmctx->ip4_rlist);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_router_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mcast_port *pmctx = from_timer(pmctx, t,\n\t\t\t\t\t\t\t ip6_mc_router_timer);\n\n\tbr_multicast_router_expired(pmctx, t, &pmctx->ip6_rlist);\n}\n#endif\n\nstatic void br_mc_router_state_change(struct net_bridge *p,\n\t\t\t\t      bool is_mc_router)\n{\n\tstruct switchdev_attr attr = {\n\t\t.orig_dev = p->dev,\n\t\t.id = SWITCHDEV_ATTR_ID_BRIDGE_MROUTER,\n\t\t.flags = SWITCHDEV_F_DEFER,\n\t\t.u.mrouter = is_mc_router,\n\t};\n\n\tswitchdev_port_attr_set(p->dev, &attr, NULL);\n}\n\nstatic void br_multicast_local_router_expired(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t      struct timer_list *timer)\n{\n\tspin_lock(&brmctx->br->multicast_lock);\n\tif (brmctx->multicast_router == MDB_RTR_TYPE_DISABLED ||\n\t    brmctx->multicast_router == MDB_RTR_TYPE_PERM ||\n\t    br_ip4_multicast_is_router(brmctx) ||\n\t    br_ip6_multicast_is_router(brmctx))\n\t\tgoto out;\n\n\tbr_mc_router_state_change(brmctx->br, false);\nout:\n\tspin_unlock(&brmctx->br->multicast_lock);\n}\n\nstatic void br_ip4_multicast_local_router_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mcast *brmctx = from_timer(brmctx, t,\n\t\t\t\t\t\t     ip4_mc_router_timer);\n\n\tbr_multicast_local_router_expired(brmctx, t);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_local_router_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mcast *brmctx = from_timer(brmctx, t,\n\t\t\t\t\t\t     ip6_mc_router_timer);\n\n\tbr_multicast_local_router_expired(brmctx, t);\n}\n#endif\n\nstatic void br_multicast_querier_expired(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t struct bridge_mcast_own_query *query)\n{\n\tspin_lock(&brmctx->br->multicast_lock);\n\tif (!netif_running(brmctx->br->dev) ||\n\t    br_multicast_ctx_vlan_global_disabled(brmctx) ||\n\t    !br_opt_get(brmctx->br, BROPT_MULTICAST_ENABLED))\n\t\tgoto out;\n\n\tbr_multicast_start_querier(brmctx, query);\n\nout:\n\tspin_unlock(&brmctx->br->multicast_lock);\n}\n\nstatic void br_ip4_multicast_querier_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mcast *brmctx = from_timer(brmctx, t,\n\t\t\t\t\t\t     ip4_other_query.timer);\n\n\tbr_multicast_querier_expired(brmctx, &brmctx->ip4_own_query);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_querier_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mcast *brmctx = from_timer(brmctx, t,\n\t\t\t\t\t\t     ip6_other_query.timer);\n\n\tbr_multicast_querier_expired(brmctx, &brmctx->ip6_own_query);\n}\n#endif\n\nstatic void br_multicast_select_own_querier(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t    struct br_ip *ip,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tif (ip->proto == htons(ETH_P_IP))\n\t\tbrmctx->ip4_querier.addr.src.ip4 = ip_hdr(skb)->saddr;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tbrmctx->ip6_querier.addr.src.ip6 = ipv6_hdr(skb)->saddr;\n#endif\n}\n\nstatic void __br_multicast_send_query(struct net_bridge_mcast *brmctx,\n\t\t\t\t      struct net_bridge_mcast_port *pmctx,\n\t\t\t\t      struct net_bridge_port_group *pg,\n\t\t\t\t      struct br_ip *ip_dst,\n\t\t\t\t      struct br_ip *group,\n\t\t\t\t      bool with_srcs,\n\t\t\t\t      u8 sflag,\n\t\t\t\t      bool *need_rexmit)\n{\n\tbool over_lmqt = !!sflag;\n\tstruct sk_buff *skb;\n\tu8 igmp_type;\n\n\tif (!br_multicast_ctx_should_use(brmctx, pmctx) ||\n\t    !br_multicast_ctx_matches_vlan_snooping(brmctx))\n\t\treturn;\n\nagain_under_lmqt:\n\tskb = br_multicast_alloc_query(brmctx, pmctx, pg, ip_dst, group,\n\t\t\t\t       with_srcs, over_lmqt, sflag, &igmp_type,\n\t\t\t\t       need_rexmit);\n\tif (!skb)\n\t\treturn;\n\n\tif (pmctx) {\n\t\tskb->dev = pmctx->port->dev;\n\t\tbr_multicast_count(brmctx->br, pmctx->port, skb, igmp_type,\n\t\t\t\t   BR_MCAST_DIR_TX);\n\t\tNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT,\n\t\t\tdev_net(pmctx->port->dev), NULL, skb, NULL, skb->dev,\n\t\t\tbr_dev_queue_push_xmit);\n\n\t\tif (over_lmqt && with_srcs && sflag) {\n\t\t\tover_lmqt = false;\n\t\t\tgoto again_under_lmqt;\n\t\t}\n\t} else {\n\t\tbr_multicast_select_own_querier(brmctx, group, skb);\n\t\tbr_multicast_count(brmctx->br, NULL, skb, igmp_type,\n\t\t\t\t   BR_MCAST_DIR_RX);\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic void br_multicast_read_querier(const struct bridge_mcast_querier *querier,\n\t\t\t\t      struct bridge_mcast_querier *dest)\n{\n\tunsigned int seq;\n\n\tmemset(dest, 0, sizeof(*dest));\n\tdo {\n\t\tseq = read_seqcount_begin(&querier->seq);\n\t\tdest->port_ifidx = querier->port_ifidx;\n\t\tmemcpy(&dest->addr, &querier->addr, sizeof(struct br_ip));\n\t} while (read_seqcount_retry(&querier->seq, seq));\n}\n\nstatic void br_multicast_update_querier(struct net_bridge_mcast *brmctx,\n\t\t\t\t\tstruct bridge_mcast_querier *querier,\n\t\t\t\t\tint ifindex,\n\t\t\t\t\tstruct br_ip *saddr)\n{\n\twrite_seqcount_begin(&querier->seq);\n\tquerier->port_ifidx = ifindex;\n\tmemcpy(&querier->addr, saddr, sizeof(*saddr));\n\twrite_seqcount_end(&querier->seq);\n}\n\nstatic void br_multicast_send_query(struct net_bridge_mcast *brmctx,\n\t\t\t\t    struct net_bridge_mcast_port *pmctx,\n\t\t\t\t    struct bridge_mcast_own_query *own_query)\n{\n\tstruct bridge_mcast_other_query *other_query = NULL;\n\tstruct bridge_mcast_querier *querier;\n\tstruct br_ip br_group;\n\tunsigned long time;\n\n\tif (!br_multicast_ctx_should_use(brmctx, pmctx) ||\n\t    !br_opt_get(brmctx->br, BROPT_MULTICAST_ENABLED) ||\n\t    !brmctx->multicast_querier)\n\t\treturn;\n\n\tmemset(&br_group.dst, 0, sizeof(br_group.dst));\n\n\tif (pmctx ? (own_query == &pmctx->ip4_own_query) :\n\t\t    (own_query == &brmctx->ip4_own_query)) {\n\t\tquerier = &brmctx->ip4_querier;\n\t\tother_query = &brmctx->ip4_other_query;\n\t\tbr_group.proto = htons(ETH_P_IP);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tquerier = &brmctx->ip6_querier;\n\t\tother_query = &brmctx->ip6_other_query;\n\t\tbr_group.proto = htons(ETH_P_IPV6);\n#endif\n\t}\n\n\tif (!other_query || timer_pending(&other_query->timer))\n\t\treturn;\n\n\t \n\tif (!pmctx && querier->port_ifidx) {\n\t\tstruct br_ip zeroip = {};\n\n\t\tbr_multicast_update_querier(brmctx, querier, 0, &zeroip);\n\t}\n\n\t__br_multicast_send_query(brmctx, pmctx, NULL, NULL, &br_group, false,\n\t\t\t\t  0, NULL);\n\n\ttime = jiffies;\n\ttime += own_query->startup_sent < brmctx->multicast_startup_query_count ?\n\t\tbrmctx->multicast_startup_query_interval :\n\t\tbrmctx->multicast_query_interval;\n\tmod_timer(&own_query->timer, time);\n}\n\nstatic void\nbr_multicast_port_query_expired(struct net_bridge_mcast_port *pmctx,\n\t\t\t\tstruct bridge_mcast_own_query *query)\n{\n\tstruct net_bridge *br = pmctx->port->br;\n\tstruct net_bridge_mcast *brmctx;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br_multicast_port_ctx_state_stopped(pmctx))\n\t\tgoto out;\n\n\tbrmctx = br_multicast_port_ctx_get_global(pmctx);\n\tif (query->startup_sent < brmctx->multicast_startup_query_count)\n\t\tquery->startup_sent++;\n\n\tbr_multicast_send_query(brmctx, pmctx, query);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_ip4_multicast_port_query_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mcast_port *pmctx = from_timer(pmctx, t,\n\t\t\t\t\t\t\t ip4_own_query.timer);\n\n\tbr_multicast_port_query_expired(pmctx, &pmctx->ip4_own_query);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_port_query_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mcast_port *pmctx = from_timer(pmctx, t,\n\t\t\t\t\t\t\t ip6_own_query.timer);\n\n\tbr_multicast_port_query_expired(pmctx, &pmctx->ip6_own_query);\n}\n#endif\n\nstatic void br_multicast_port_group_rexmit(struct timer_list *t)\n{\n\tstruct net_bridge_port_group *pg = from_timer(pg, t, rexmit_timer);\n\tstruct bridge_mcast_other_query *other_query = NULL;\n\tstruct net_bridge *br = pg->key.port->br;\n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_mcast *brmctx;\n\tbool need_rexmit = false;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || hlist_unhashed(&pg->mglist) ||\n\t    !br_opt_get(br, BROPT_MULTICAST_ENABLED))\n\t\tgoto out;\n\n\tpmctx = br_multicast_pg_to_port_ctx(pg);\n\tif (!pmctx)\n\t\tgoto out;\n\tbrmctx = br_multicast_port_ctx_get_global(pmctx);\n\tif (!brmctx->multicast_querier)\n\t\tgoto out;\n\n\tif (pg->key.addr.proto == htons(ETH_P_IP))\n\t\tother_query = &brmctx->ip4_other_query;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tother_query = &brmctx->ip6_other_query;\n#endif\n\n\tif (!other_query || timer_pending(&other_query->timer))\n\t\tgoto out;\n\n\tif (pg->grp_query_rexmit_cnt) {\n\t\tpg->grp_query_rexmit_cnt--;\n\t\t__br_multicast_send_query(brmctx, pmctx, pg, &pg->key.addr,\n\t\t\t\t\t  &pg->key.addr, false, 1, NULL);\n\t}\n\t__br_multicast_send_query(brmctx, pmctx, pg, &pg->key.addr,\n\t\t\t\t  &pg->key.addr, true, 0, &need_rexmit);\n\n\tif (pg->grp_query_rexmit_cnt || need_rexmit)\n\t\tmod_timer(&pg->rexmit_timer, jiffies +\n\t\t\t\t\t     brmctx->multicast_last_member_interval);\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic int br_mc_disabled_update(struct net_device *dev, bool value,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_attr attr = {\n\t\t.orig_dev = dev,\n\t\t.id = SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED,\n\t\t.flags = SWITCHDEV_F_DEFER,\n\t\t.u.mc_disabled = !value,\n\t};\n\n\treturn switchdev_port_attr_set(dev, &attr, extack);\n}\n\nvoid br_multicast_port_ctx_init(struct net_bridge_port *port,\n\t\t\t\tstruct net_bridge_vlan *vlan,\n\t\t\t\tstruct net_bridge_mcast_port *pmctx)\n{\n\tpmctx->port = port;\n\tpmctx->vlan = vlan;\n\tpmctx->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;\n\ttimer_setup(&pmctx->ip4_mc_router_timer,\n\t\t    br_ip4_multicast_router_expired, 0);\n\ttimer_setup(&pmctx->ip4_own_query.timer,\n\t\t    br_ip4_multicast_port_query_expired, 0);\n#if IS_ENABLED(CONFIG_IPV6)\n\ttimer_setup(&pmctx->ip6_mc_router_timer,\n\t\t    br_ip6_multicast_router_expired, 0);\n\ttimer_setup(&pmctx->ip6_own_query.timer,\n\t\t    br_ip6_multicast_port_query_expired, 0);\n#endif\n}\n\nvoid br_multicast_port_ctx_deinit(struct net_bridge_mcast_port *pmctx)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tdel_timer_sync(&pmctx->ip6_mc_router_timer);\n#endif\n\tdel_timer_sync(&pmctx->ip4_mc_router_timer);\n}\n\nint br_multicast_add_port(struct net_bridge_port *port)\n{\n\tint err;\n\n\tport->multicast_eht_hosts_limit = BR_MCAST_DEFAULT_EHT_HOSTS_LIMIT;\n\tbr_multicast_port_ctx_init(port, NULL, &port->multicast_ctx);\n\n\terr = br_mc_disabled_update(port->dev,\n\t\t\t\t    br_opt_get(port->br,\n\t\t\t\t\t       BROPT_MULTICAST_ENABLED),\n\t\t\t\t    NULL);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\tport->mcast_stats = netdev_alloc_pcpu_stats(struct bridge_mcast_stats);\n\tif (!port->mcast_stats)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid br_multicast_del_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\tstruct net_bridge_port_group *pg;\n\tHLIST_HEAD(deleted_head);\n\tstruct hlist_node *n;\n\n\t \n\tspin_lock_bh(&br->multicast_lock);\n\thlist_for_each_entry_safe(pg, n, &port->mglist, mglist)\n\t\tbr_multicast_find_del_pg(br, pg);\n\thlist_move_list(&br->mcast_gc_list, &deleted_head);\n\tspin_unlock_bh(&br->multicast_lock);\n\tbr_multicast_gc(&deleted_head);\n\tbr_multicast_port_ctx_deinit(&port->multicast_ctx);\n\tfree_percpu(port->mcast_stats);\n}\n\nstatic void br_multicast_enable(struct bridge_mcast_own_query *query)\n{\n\tquery->startup_sent = 0;\n\n\tif (try_to_del_timer_sync(&query->timer) >= 0 ||\n\t    del_timer(&query->timer))\n\t\tmod_timer(&query->timer, jiffies);\n}\n\nstatic void __br_multicast_enable_port_ctx(struct net_bridge_mcast_port *pmctx)\n{\n\tstruct net_bridge *br = pmctx->port->br;\n\tstruct net_bridge_mcast *brmctx;\n\n\tbrmctx = br_multicast_port_ctx_get_global(pmctx);\n\tif (!br_opt_get(br, BROPT_MULTICAST_ENABLED) ||\n\t    !netif_running(br->dev))\n\t\treturn;\n\n\tbr_multicast_enable(&pmctx->ip4_own_query);\n#if IS_ENABLED(CONFIG_IPV6)\n\tbr_multicast_enable(&pmctx->ip6_own_query);\n#endif\n\tif (pmctx->multicast_router == MDB_RTR_TYPE_PERM) {\n\t\tbr_ip4_multicast_add_router(brmctx, pmctx);\n\t\tbr_ip6_multicast_add_router(brmctx, pmctx);\n\t}\n\n\tif (br_multicast_port_ctx_is_vlan(pmctx)) {\n\t\tstruct net_bridge_port_group *pg;\n\t\tu32 n = 0;\n\n\t\t \n\n\t\thlist_for_each_entry(pg, &pmctx->port->mglist, mglist) {\n\t\t\tif (pg->key.addr.vid == pmctx->vlan->vid)\n\t\t\t\tn++;\n\t\t}\n\t\tWRITE_ONCE(pmctx->mdb_n_entries, n);\n\t}\n}\n\nvoid br_multicast_enable_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock_bh(&br->multicast_lock);\n\t__br_multicast_enable_port_ctx(&port->multicast_ctx);\n\tspin_unlock_bh(&br->multicast_lock);\n}\n\nstatic void __br_multicast_disable_port_ctx(struct net_bridge_mcast_port *pmctx)\n{\n\tstruct net_bridge_port_group *pg;\n\tstruct hlist_node *n;\n\tbool del = false;\n\n\thlist_for_each_entry_safe(pg, n, &pmctx->port->mglist, mglist)\n\t\tif (!(pg->flags & MDB_PG_FLAGS_PERMANENT) &&\n\t\t    (!br_multicast_port_ctx_is_vlan(pmctx) ||\n\t\t     pg->key.addr.vid == pmctx->vlan->vid))\n\t\t\tbr_multicast_find_del_pg(pmctx->port->br, pg);\n\n\tdel |= br_ip4_multicast_rport_del(pmctx);\n\tdel_timer(&pmctx->ip4_mc_router_timer);\n\tdel_timer(&pmctx->ip4_own_query.timer);\n\tdel |= br_ip6_multicast_rport_del(pmctx);\n#if IS_ENABLED(CONFIG_IPV6)\n\tdel_timer(&pmctx->ip6_mc_router_timer);\n\tdel_timer(&pmctx->ip6_own_query.timer);\n#endif\n\tbr_multicast_rport_del_notify(pmctx, del);\n}\n\nvoid br_multicast_disable_port(struct net_bridge_port *port)\n{\n\tspin_lock_bh(&port->br->multicast_lock);\n\t__br_multicast_disable_port_ctx(&port->multicast_ctx);\n\tspin_unlock_bh(&port->br->multicast_lock);\n}\n\nstatic int __grp_src_delete_marked(struct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_group_src *ent;\n\tstruct hlist_node *tmp;\n\tint deleted = 0;\n\n\thlist_for_each_entry_safe(ent, tmp, &pg->src_list, node)\n\t\tif (ent->flags & BR_SGRP_F_DELETE) {\n\t\t\tbr_multicast_del_group_src(ent, false);\n\t\t\tdeleted++;\n\t\t}\n\n\treturn deleted;\n}\n\nstatic void __grp_src_mod_timer(struct net_bridge_group_src *src,\n\t\t\t\tunsigned long expires)\n{\n\tmod_timer(&src->timer, expires);\n\tbr_multicast_fwd_src_handle(src);\n}\n\nstatic void __grp_src_query_marked_and_rexmit(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t      struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t      struct net_bridge_port_group *pg)\n{\n\tstruct bridge_mcast_other_query *other_query = NULL;\n\tu32 lmqc = brmctx->multicast_last_member_count;\n\tunsigned long lmqt, lmi, now = jiffies;\n\tstruct net_bridge_group_src *ent;\n\n\tif (!netif_running(brmctx->br->dev) ||\n\t    !br_opt_get(brmctx->br, BROPT_MULTICAST_ENABLED))\n\t\treturn;\n\n\tif (pg->key.addr.proto == htons(ETH_P_IP))\n\t\tother_query = &brmctx->ip4_other_query;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tother_query = &brmctx->ip6_other_query;\n#endif\n\n\tlmqt = now + br_multicast_lmqt(brmctx);\n\thlist_for_each_entry(ent, &pg->src_list, node) {\n\t\tif (ent->flags & BR_SGRP_F_SEND) {\n\t\t\tent->flags &= ~BR_SGRP_F_SEND;\n\t\t\tif (ent->timer.expires > lmqt) {\n\t\t\t\tif (brmctx->multicast_querier &&\n\t\t\t\t    other_query &&\n\t\t\t\t    !timer_pending(&other_query->timer))\n\t\t\t\t\tent->src_query_rexmit_cnt = lmqc;\n\t\t\t\t__grp_src_mod_timer(ent, lmqt);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!brmctx->multicast_querier ||\n\t    !other_query || timer_pending(&other_query->timer))\n\t\treturn;\n\n\t__br_multicast_send_query(brmctx, pmctx, pg, &pg->key.addr,\n\t\t\t\t  &pg->key.addr, true, 1, NULL);\n\n\tlmi = now + brmctx->multicast_last_member_interval;\n\tif (!timer_pending(&pg->rexmit_timer) ||\n\t    time_after(pg->rexmit_timer.expires, lmi))\n\t\tmod_timer(&pg->rexmit_timer, lmi);\n}\n\nstatic void __grp_send_query_and_rexmit(struct net_bridge_mcast *brmctx,\n\t\t\t\t\tstruct net_bridge_mcast_port *pmctx,\n\t\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct bridge_mcast_other_query *other_query = NULL;\n\tunsigned long now = jiffies, lmi;\n\n\tif (!netif_running(brmctx->br->dev) ||\n\t    !br_opt_get(brmctx->br, BROPT_MULTICAST_ENABLED))\n\t\treturn;\n\n\tif (pg->key.addr.proto == htons(ETH_P_IP))\n\t\tother_query = &brmctx->ip4_other_query;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tother_query = &brmctx->ip6_other_query;\n#endif\n\n\tif (brmctx->multicast_querier &&\n\t    other_query && !timer_pending(&other_query->timer)) {\n\t\tlmi = now + brmctx->multicast_last_member_interval;\n\t\tpg->grp_query_rexmit_cnt = brmctx->multicast_last_member_count - 1;\n\t\t__br_multicast_send_query(brmctx, pmctx, pg, &pg->key.addr,\n\t\t\t\t\t  &pg->key.addr, false, 0, NULL);\n\t\tif (!timer_pending(&pg->rexmit_timer) ||\n\t\t    time_after(pg->rexmit_timer.expires, lmi))\n\t\t\tmod_timer(&pg->rexmit_timer, lmi);\n\t}\n\n\tif (pg->filter_mode == MCAST_EXCLUDE &&\n\t    (!timer_pending(&pg->timer) ||\n\t     time_after(pg->timer.expires, now + br_multicast_lmqt(brmctx))))\n\t\tmod_timer(&pg->timer, now + br_multicast_lmqt(brmctx));\n}\n\n \nstatic bool br_multicast_isinc_allow(const struct net_bridge_mcast *brmctx,\n\t\t\t\t     struct net_bridge_port_group *pg, void *h_addr,\n\t\t\t\t     void *srcs, u32 nsrcs, size_t addr_size,\n\t\t\t\t     int grec_type)\n{\n\tstruct net_bridge_group_src *ent;\n\tunsigned long now = jiffies;\n\tbool changed = false;\n\tstruct br_ip src_ip;\n\tu32 src_idx;\n\n\tmemset(&src_ip, 0, sizeof(src_ip));\n\tsrc_ip.proto = pg->key.addr.proto;\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);\n\t\tent = br_multicast_find_group_src(pg, &src_ip);\n\t\tif (!ent) {\n\t\t\tent = br_multicast_new_group_src(pg, &src_ip);\n\t\t\tif (ent)\n\t\t\t\tchanged = true;\n\t\t}\n\n\t\tif (ent)\n\t\t\t__grp_src_mod_timer(ent, now + br_multicast_gmi(brmctx));\n\t}\n\n\tif (br_multicast_eht_handle(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\t    grec_type))\n\t\tchanged = true;\n\n\treturn changed;\n}\n\n \nstatic void __grp_src_isexc_incl(const struct net_bridge_mcast *brmctx,\n\t\t\t\t struct net_bridge_port_group *pg, void *h_addr,\n\t\t\t\t void *srcs, u32 nsrcs, size_t addr_size,\n\t\t\t\t int grec_type)\n{\n\tstruct net_bridge_group_src *ent;\n\tstruct br_ip src_ip;\n\tu32 src_idx;\n\n\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\tent->flags |= BR_SGRP_F_DELETE;\n\n\tmemset(&src_ip, 0, sizeof(src_ip));\n\tsrc_ip.proto = pg->key.addr.proto;\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);\n\t\tent = br_multicast_find_group_src(pg, &src_ip);\n\t\tif (ent)\n\t\t\tent->flags &= ~BR_SGRP_F_DELETE;\n\t\telse\n\t\t\tent = br_multicast_new_group_src(pg, &src_ip);\n\t\tif (ent)\n\t\t\tbr_multicast_fwd_src_handle(ent);\n\t}\n\n\tbr_multicast_eht_handle(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\tgrec_type);\n\n\t__grp_src_delete_marked(pg);\n}\n\n \nstatic bool __grp_src_isexc_excl(const struct net_bridge_mcast *brmctx,\n\t\t\t\t struct net_bridge_port_group *pg, void *h_addr,\n\t\t\t\t void *srcs, u32 nsrcs, size_t addr_size,\n\t\t\t\t int grec_type)\n{\n\tstruct net_bridge_group_src *ent;\n\tunsigned long now = jiffies;\n\tbool changed = false;\n\tstruct br_ip src_ip;\n\tu32 src_idx;\n\n\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\tent->flags |= BR_SGRP_F_DELETE;\n\n\tmemset(&src_ip, 0, sizeof(src_ip));\n\tsrc_ip.proto = pg->key.addr.proto;\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);\n\t\tent = br_multicast_find_group_src(pg, &src_ip);\n\t\tif (ent) {\n\t\t\tent->flags &= ~BR_SGRP_F_DELETE;\n\t\t} else {\n\t\t\tent = br_multicast_new_group_src(pg, &src_ip);\n\t\t\tif (ent) {\n\t\t\t\t__grp_src_mod_timer(ent,\n\t\t\t\t\t\t    now + br_multicast_gmi(brmctx));\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (br_multicast_eht_handle(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\t    grec_type))\n\t\tchanged = true;\n\n\tif (__grp_src_delete_marked(pg))\n\t\tchanged = true;\n\n\treturn changed;\n}\n\nstatic bool br_multicast_isexc(const struct net_bridge_mcast *brmctx,\n\t\t\t       struct net_bridge_port_group *pg, void *h_addr,\n\t\t\t       void *srcs, u32 nsrcs, size_t addr_size,\n\t\t\t       int grec_type)\n{\n\tbool changed = false;\n\n\tswitch (pg->filter_mode) {\n\tcase MCAST_INCLUDE:\n\t\t__grp_src_isexc_incl(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\t     grec_type);\n\t\tbr_multicast_star_g_handle_mode(pg, MCAST_EXCLUDE);\n\t\tchanged = true;\n\t\tbreak;\n\tcase MCAST_EXCLUDE:\n\t\tchanged = __grp_src_isexc_excl(brmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t\t       addr_size, grec_type);\n\t\tbreak;\n\t}\n\n\tpg->filter_mode = MCAST_EXCLUDE;\n\tmod_timer(&pg->timer, jiffies + br_multicast_gmi(brmctx));\n\n\treturn changed;\n}\n\n \nstatic bool __grp_src_toin_incl(struct net_bridge_mcast *brmctx,\n\t\t\t\tstruct net_bridge_mcast_port *pmctx,\n\t\t\t\tstruct net_bridge_port_group *pg, void *h_addr,\n\t\t\t\tvoid *srcs, u32 nsrcs, size_t addr_size,\n\t\t\t\tint grec_type)\n{\n\tu32 src_idx, to_send = pg->src_ents;\n\tstruct net_bridge_group_src *ent;\n\tunsigned long now = jiffies;\n\tbool changed = false;\n\tstruct br_ip src_ip;\n\n\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\tent->flags |= BR_SGRP_F_SEND;\n\n\tmemset(&src_ip, 0, sizeof(src_ip));\n\tsrc_ip.proto = pg->key.addr.proto;\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);\n\t\tent = br_multicast_find_group_src(pg, &src_ip);\n\t\tif (ent) {\n\t\t\tent->flags &= ~BR_SGRP_F_SEND;\n\t\t\tto_send--;\n\t\t} else {\n\t\t\tent = br_multicast_new_group_src(pg, &src_ip);\n\t\t\tif (ent)\n\t\t\t\tchanged = true;\n\t\t}\n\t\tif (ent)\n\t\t\t__grp_src_mod_timer(ent, now + br_multicast_gmi(brmctx));\n\t}\n\n\tif (br_multicast_eht_handle(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\t    grec_type))\n\t\tchanged = true;\n\n\tif (to_send)\n\t\t__grp_src_query_marked_and_rexmit(brmctx, pmctx, pg);\n\n\treturn changed;\n}\n\n \nstatic bool __grp_src_toin_excl(struct net_bridge_mcast *brmctx,\n\t\t\t\tstruct net_bridge_mcast_port *pmctx,\n\t\t\t\tstruct net_bridge_port_group *pg, void *h_addr,\n\t\t\t\tvoid *srcs, u32 nsrcs, size_t addr_size,\n\t\t\t\tint grec_type)\n{\n\tu32 src_idx, to_send = pg->src_ents;\n\tstruct net_bridge_group_src *ent;\n\tunsigned long now = jiffies;\n\tbool changed = false;\n\tstruct br_ip src_ip;\n\n\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\tif (timer_pending(&ent->timer))\n\t\t\tent->flags |= BR_SGRP_F_SEND;\n\n\tmemset(&src_ip, 0, sizeof(src_ip));\n\tsrc_ip.proto = pg->key.addr.proto;\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);\n\t\tent = br_multicast_find_group_src(pg, &src_ip);\n\t\tif (ent) {\n\t\t\tif (timer_pending(&ent->timer)) {\n\t\t\t\tent->flags &= ~BR_SGRP_F_SEND;\n\t\t\t\tto_send--;\n\t\t\t}\n\t\t} else {\n\t\t\tent = br_multicast_new_group_src(pg, &src_ip);\n\t\t\tif (ent)\n\t\t\t\tchanged = true;\n\t\t}\n\t\tif (ent)\n\t\t\t__grp_src_mod_timer(ent, now + br_multicast_gmi(brmctx));\n\t}\n\n\tif (br_multicast_eht_handle(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\t    grec_type))\n\t\tchanged = true;\n\n\tif (to_send)\n\t\t__grp_src_query_marked_and_rexmit(brmctx, pmctx, pg);\n\n\t__grp_send_query_and_rexmit(brmctx, pmctx, pg);\n\n\treturn changed;\n}\n\nstatic bool br_multicast_toin(struct net_bridge_mcast *brmctx,\n\t\t\t      struct net_bridge_mcast_port *pmctx,\n\t\t\t      struct net_bridge_port_group *pg, void *h_addr,\n\t\t\t      void *srcs, u32 nsrcs, size_t addr_size,\n\t\t\t      int grec_type)\n{\n\tbool changed = false;\n\n\tswitch (pg->filter_mode) {\n\tcase MCAST_INCLUDE:\n\t\tchanged = __grp_src_toin_incl(brmctx, pmctx, pg, h_addr, srcs,\n\t\t\t\t\t      nsrcs, addr_size, grec_type);\n\t\tbreak;\n\tcase MCAST_EXCLUDE:\n\t\tchanged = __grp_src_toin_excl(brmctx, pmctx, pg, h_addr, srcs,\n\t\t\t\t\t      nsrcs, addr_size, grec_type);\n\t\tbreak;\n\t}\n\n\tif (br_multicast_eht_should_del_pg(pg)) {\n\t\tpg->flags |= MDB_PG_FLAGS_FAST_LEAVE;\n\t\tbr_multicast_find_del_pg(pg->key.port->br, pg);\n\t\t \n\t\tchanged = false;\n\t}\n\n\treturn changed;\n}\n\n \nstatic void __grp_src_toex_incl(struct net_bridge_mcast *brmctx,\n\t\t\t\tstruct net_bridge_mcast_port *pmctx,\n\t\t\t\tstruct net_bridge_port_group *pg, void *h_addr,\n\t\t\t\tvoid *srcs, u32 nsrcs, size_t addr_size,\n\t\t\t\tint grec_type)\n{\n\tstruct net_bridge_group_src *ent;\n\tu32 src_idx, to_send = 0;\n\tstruct br_ip src_ip;\n\n\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\tent->flags = (ent->flags & ~BR_SGRP_F_SEND) | BR_SGRP_F_DELETE;\n\n\tmemset(&src_ip, 0, sizeof(src_ip));\n\tsrc_ip.proto = pg->key.addr.proto;\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);\n\t\tent = br_multicast_find_group_src(pg, &src_ip);\n\t\tif (ent) {\n\t\t\tent->flags = (ent->flags & ~BR_SGRP_F_DELETE) |\n\t\t\t\t     BR_SGRP_F_SEND;\n\t\t\tto_send++;\n\t\t} else {\n\t\t\tent = br_multicast_new_group_src(pg, &src_ip);\n\t\t}\n\t\tif (ent)\n\t\t\tbr_multicast_fwd_src_handle(ent);\n\t}\n\n\tbr_multicast_eht_handle(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\tgrec_type);\n\n\t__grp_src_delete_marked(pg);\n\tif (to_send)\n\t\t__grp_src_query_marked_and_rexmit(brmctx, pmctx, pg);\n}\n\n \nstatic bool __grp_src_toex_excl(struct net_bridge_mcast *brmctx,\n\t\t\t\tstruct net_bridge_mcast_port *pmctx,\n\t\t\t\tstruct net_bridge_port_group *pg, void *h_addr,\n\t\t\t\tvoid *srcs, u32 nsrcs, size_t addr_size,\n\t\t\t\tint grec_type)\n{\n\tstruct net_bridge_group_src *ent;\n\tu32 src_idx, to_send = 0;\n\tbool changed = false;\n\tstruct br_ip src_ip;\n\n\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\tent->flags = (ent->flags & ~BR_SGRP_F_SEND) | BR_SGRP_F_DELETE;\n\n\tmemset(&src_ip, 0, sizeof(src_ip));\n\tsrc_ip.proto = pg->key.addr.proto;\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);\n\t\tent = br_multicast_find_group_src(pg, &src_ip);\n\t\tif (ent) {\n\t\t\tent->flags &= ~BR_SGRP_F_DELETE;\n\t\t} else {\n\t\t\tent = br_multicast_new_group_src(pg, &src_ip);\n\t\t\tif (ent) {\n\t\t\t\t__grp_src_mod_timer(ent, pg->timer.expires);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\tif (ent && timer_pending(&ent->timer)) {\n\t\t\tent->flags |= BR_SGRP_F_SEND;\n\t\t\tto_send++;\n\t\t}\n\t}\n\n\tif (br_multicast_eht_handle(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\t    grec_type))\n\t\tchanged = true;\n\n\tif (__grp_src_delete_marked(pg))\n\t\tchanged = true;\n\tif (to_send)\n\t\t__grp_src_query_marked_and_rexmit(brmctx, pmctx, pg);\n\n\treturn changed;\n}\n\nstatic bool br_multicast_toex(struct net_bridge_mcast *brmctx,\n\t\t\t      struct net_bridge_mcast_port *pmctx,\n\t\t\t      struct net_bridge_port_group *pg, void *h_addr,\n\t\t\t      void *srcs, u32 nsrcs, size_t addr_size,\n\t\t\t      int grec_type)\n{\n\tbool changed = false;\n\n\tswitch (pg->filter_mode) {\n\tcase MCAST_INCLUDE:\n\t\t__grp_src_toex_incl(brmctx, pmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t    addr_size, grec_type);\n\t\tbr_multicast_star_g_handle_mode(pg, MCAST_EXCLUDE);\n\t\tchanged = true;\n\t\tbreak;\n\tcase MCAST_EXCLUDE:\n\t\tchanged = __grp_src_toex_excl(brmctx, pmctx, pg, h_addr, srcs,\n\t\t\t\t\t      nsrcs, addr_size, grec_type);\n\t\tbreak;\n\t}\n\n\tpg->filter_mode = MCAST_EXCLUDE;\n\tmod_timer(&pg->timer, jiffies + br_multicast_gmi(brmctx));\n\n\treturn changed;\n}\n\n \nstatic bool __grp_src_block_incl(struct net_bridge_mcast *brmctx,\n\t\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t\t struct net_bridge_port_group *pg, void *h_addr,\n\t\t\t\t void *srcs, u32 nsrcs, size_t addr_size, int grec_type)\n{\n\tstruct net_bridge_group_src *ent;\n\tu32 src_idx, to_send = 0;\n\tbool changed = false;\n\tstruct br_ip src_ip;\n\n\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\tent->flags &= ~BR_SGRP_F_SEND;\n\n\tmemset(&src_ip, 0, sizeof(src_ip));\n\tsrc_ip.proto = pg->key.addr.proto;\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);\n\t\tent = br_multicast_find_group_src(pg, &src_ip);\n\t\tif (ent) {\n\t\t\tent->flags |= BR_SGRP_F_SEND;\n\t\t\tto_send++;\n\t\t}\n\t}\n\n\tif (br_multicast_eht_handle(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\t    grec_type))\n\t\tchanged = true;\n\n\tif (to_send)\n\t\t__grp_src_query_marked_and_rexmit(brmctx, pmctx, pg);\n\n\treturn changed;\n}\n\n \nstatic bool __grp_src_block_excl(struct net_bridge_mcast *brmctx,\n\t\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t\t struct net_bridge_port_group *pg, void *h_addr,\n\t\t\t\t void *srcs, u32 nsrcs, size_t addr_size, int grec_type)\n{\n\tstruct net_bridge_group_src *ent;\n\tu32 src_idx, to_send = 0;\n\tbool changed = false;\n\tstruct br_ip src_ip;\n\n\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\tent->flags &= ~BR_SGRP_F_SEND;\n\n\tmemset(&src_ip, 0, sizeof(src_ip));\n\tsrc_ip.proto = pg->key.addr.proto;\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);\n\t\tent = br_multicast_find_group_src(pg, &src_ip);\n\t\tif (!ent) {\n\t\t\tent = br_multicast_new_group_src(pg, &src_ip);\n\t\t\tif (ent) {\n\t\t\t\t__grp_src_mod_timer(ent, pg->timer.expires);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\tif (ent && timer_pending(&ent->timer)) {\n\t\t\tent->flags |= BR_SGRP_F_SEND;\n\t\t\tto_send++;\n\t\t}\n\t}\n\n\tif (br_multicast_eht_handle(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\t    grec_type))\n\t\tchanged = true;\n\n\tif (to_send)\n\t\t__grp_src_query_marked_and_rexmit(brmctx, pmctx, pg);\n\n\treturn changed;\n}\n\nstatic bool br_multicast_block(struct net_bridge_mcast *brmctx,\n\t\t\t       struct net_bridge_mcast_port *pmctx,\n\t\t\t       struct net_bridge_port_group *pg, void *h_addr,\n\t\t\t       void *srcs, u32 nsrcs, size_t addr_size, int grec_type)\n{\n\tbool changed = false;\n\n\tswitch (pg->filter_mode) {\n\tcase MCAST_INCLUDE:\n\t\tchanged = __grp_src_block_incl(brmctx, pmctx, pg, h_addr, srcs,\n\t\t\t\t\t       nsrcs, addr_size, grec_type);\n\t\tbreak;\n\tcase MCAST_EXCLUDE:\n\t\tchanged = __grp_src_block_excl(brmctx, pmctx, pg, h_addr, srcs,\n\t\t\t\t\t       nsrcs, addr_size, grec_type);\n\t\tbreak;\n\t}\n\n\tif ((pg->filter_mode == MCAST_INCLUDE && hlist_empty(&pg->src_list)) ||\n\t    br_multicast_eht_should_del_pg(pg)) {\n\t\tif (br_multicast_eht_should_del_pg(pg))\n\t\t\tpg->flags |= MDB_PG_FLAGS_FAST_LEAVE;\n\t\tbr_multicast_find_del_pg(pg->key.port->br, pg);\n\t\t \n\t\tchanged = false;\n\t}\n\n\treturn changed;\n}\n\nstatic struct net_bridge_port_group *\nbr_multicast_find_port(struct net_bridge_mdb_entry *mp,\n\t\t       struct net_bridge_port *p,\n\t\t       const unsigned char *src)\n{\n\tstruct net_bridge *br __maybe_unused = mp->br;\n\tstruct net_bridge_port_group *pg;\n\n\tfor (pg = mlock_dereference(mp->ports, br);\n\t     pg;\n\t     pg = mlock_dereference(pg->next, br))\n\t\tif (br_port_group_equal(pg, p, src))\n\t\t\treturn pg;\n\n\treturn NULL;\n}\n\nstatic int br_ip4_multicast_igmp3_report(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t u16 vid)\n{\n\tbool igmpv2 = brmctx->multicast_igmp_version == 2;\n\tstruct net_bridge_mdb_entry *mdst;\n\tstruct net_bridge_port_group *pg;\n\tconst unsigned char *src;\n\tstruct igmpv3_report *ih;\n\tstruct igmpv3_grec *grec;\n\tint i, len, num, type;\n\t__be32 group, *h_addr;\n\tbool changed = false;\n\tint err = 0;\n\tu16 nsrcs;\n\n\tih = igmpv3_report_hdr(skb);\n\tnum = ntohs(ih->ngrec);\n\tlen = skb_transport_offset(skb) + sizeof(*ih);\n\n\tfor (i = 0; i < num; i++) {\n\t\tlen += sizeof(*grec);\n\t\tif (!ip_mc_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (void *)(skb->data + len - sizeof(*grec));\n\t\tgroup = grec->grec_mca;\n\t\ttype = grec->grec_type;\n\t\tnsrcs = ntohs(grec->grec_nsrcs);\n\n\t\tlen += nsrcs * 4;\n\t\tif (!ip_mc_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (type) {\n\t\tcase IGMPV3_MODE_IS_INCLUDE:\n\t\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc = eth_hdr(skb)->h_source;\n\t\tif (nsrcs == 0 &&\n\t\t    (type == IGMPV3_CHANGE_TO_INCLUDE ||\n\t\t     type == IGMPV3_MODE_IS_INCLUDE)) {\n\t\t\tif (!pmctx || igmpv2) {\n\t\t\t\tbr_ip4_multicast_leave_group(brmctx, pmctx,\n\t\t\t\t\t\t\t     group, vid, src);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\terr = br_ip4_multicast_add_group(brmctx, pmctx, group,\n\t\t\t\t\t\t\t vid, src, igmpv2);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!pmctx || igmpv2)\n\t\t\tcontinue;\n\n\t\tspin_lock(&brmctx->br->multicast_lock);\n\t\tif (!br_multicast_ctx_should_use(brmctx, pmctx))\n\t\t\tgoto unlock_continue;\n\n\t\tmdst = br_mdb_ip4_get(brmctx->br, group, vid);\n\t\tif (!mdst)\n\t\t\tgoto unlock_continue;\n\t\tpg = br_multicast_find_port(mdst, pmctx->port, src);\n\t\tif (!pg || (pg->flags & MDB_PG_FLAGS_PERMANENT))\n\t\t\tgoto unlock_continue;\n\t\t \n\t\tgrec = (void *)(skb->data + len - sizeof(*grec) - (nsrcs * 4));\n\t\th_addr = &ip_hdr(skb)->saddr;\n\t\tswitch (type) {\n\t\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\t\tchanged = br_multicast_isinc_allow(brmctx, pg, h_addr,\n\t\t\t\t\t\t\t   grec->grec_src,\n\t\t\t\t\t\t\t   nsrcs, sizeof(__be32), type);\n\t\t\tbreak;\n\t\tcase IGMPV3_MODE_IS_INCLUDE:\n\t\t\tchanged = br_multicast_isinc_allow(brmctx, pg, h_addr,\n\t\t\t\t\t\t\t   grec->grec_src,\n\t\t\t\t\t\t\t   nsrcs, sizeof(__be32), type);\n\t\t\tbreak;\n\t\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\t\tchanged = br_multicast_isexc(brmctx, pg, h_addr,\n\t\t\t\t\t\t     grec->grec_src,\n\t\t\t\t\t\t     nsrcs, sizeof(__be32), type);\n\t\t\tbreak;\n\t\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\t\tchanged = br_multicast_toin(brmctx, pmctx, pg, h_addr,\n\t\t\t\t\t\t    grec->grec_src,\n\t\t\t\t\t\t    nsrcs, sizeof(__be32), type);\n\t\t\tbreak;\n\t\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\t\tchanged = br_multicast_toex(brmctx, pmctx, pg, h_addr,\n\t\t\t\t\t\t    grec->grec_src,\n\t\t\t\t\t\t    nsrcs, sizeof(__be32), type);\n\t\t\tbreak;\n\t\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\t\tchanged = br_multicast_block(brmctx, pmctx, pg, h_addr,\n\t\t\t\t\t\t     grec->grec_src,\n\t\t\t\t\t\t     nsrcs, sizeof(__be32), type);\n\t\t\tbreak;\n\t\t}\n\t\tif (changed)\n\t\t\tbr_mdb_notify(brmctx->br->dev, mdst, pg, RTM_NEWMDB);\nunlock_continue:\n\t\tspin_unlock(&brmctx->br->multicast_lock);\n\t}\n\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_ip6_multicast_mld2_report(struct net_bridge_mcast *brmctx,\n\t\t\t\t\tstruct net_bridge_mcast_port *pmctx,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tu16 vid)\n{\n\tbool mldv1 = brmctx->multicast_mld_version == 1;\n\tstruct net_bridge_mdb_entry *mdst;\n\tstruct net_bridge_port_group *pg;\n\tunsigned int nsrcs_offset;\n\tstruct mld2_report *mld2r;\n\tconst unsigned char *src;\n\tstruct in6_addr *h_addr;\n\tstruct mld2_grec *grec;\n\tunsigned int grec_len;\n\tbool changed = false;\n\tint i, len, num;\n\tint err = 0;\n\n\tif (!ipv6_mc_may_pull(skb, sizeof(*mld2r)))\n\t\treturn -EINVAL;\n\n\tmld2r = (struct mld2_report *)icmp6_hdr(skb);\n\tnum = ntohs(mld2r->mld2r_ngrec);\n\tlen = skb_transport_offset(skb) + sizeof(*mld2r);\n\n\tfor (i = 0; i < num; i++) {\n\t\t__be16 *_nsrcs, __nsrcs;\n\t\tu16 nsrcs;\n\n\t\tnsrcs_offset = len + offsetof(struct mld2_grec, grec_nsrcs);\n\n\t\tif (skb_transport_offset(skb) + ipv6_transport_len(skb) <\n\t\t    nsrcs_offset + sizeof(__nsrcs))\n\t\t\treturn -EINVAL;\n\n\t\t_nsrcs = skb_header_pointer(skb, nsrcs_offset,\n\t\t\t\t\t    sizeof(__nsrcs), &__nsrcs);\n\t\tif (!_nsrcs)\n\t\t\treturn -EINVAL;\n\n\t\tnsrcs = ntohs(*_nsrcs);\n\t\tgrec_len = struct_size(grec, grec_src, nsrcs);\n\n\t\tif (!ipv6_mc_may_pull(skb, len + grec_len))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (struct mld2_grec *)(skb->data + len);\n\t\tlen += grec_len;\n\n\t\tswitch (grec->grec_type) {\n\t\tcase MLD2_MODE_IS_INCLUDE:\n\t\tcase MLD2_MODE_IS_EXCLUDE:\n\t\tcase MLD2_CHANGE_TO_INCLUDE:\n\t\tcase MLD2_CHANGE_TO_EXCLUDE:\n\t\tcase MLD2_ALLOW_NEW_SOURCES:\n\t\tcase MLD2_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc = eth_hdr(skb)->h_source;\n\t\tif ((grec->grec_type == MLD2_CHANGE_TO_INCLUDE ||\n\t\t     grec->grec_type == MLD2_MODE_IS_INCLUDE) &&\n\t\t    nsrcs == 0) {\n\t\t\tif (!pmctx || mldv1) {\n\t\t\t\tbr_ip6_multicast_leave_group(brmctx, pmctx,\n\t\t\t\t\t\t\t     &grec->grec_mca,\n\t\t\t\t\t\t\t     vid, src);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\terr = br_ip6_multicast_add_group(brmctx, pmctx,\n\t\t\t\t\t\t\t &grec->grec_mca, vid,\n\t\t\t\t\t\t\t src, mldv1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!pmctx || mldv1)\n\t\t\tcontinue;\n\n\t\tspin_lock(&brmctx->br->multicast_lock);\n\t\tif (!br_multicast_ctx_should_use(brmctx, pmctx))\n\t\t\tgoto unlock_continue;\n\n\t\tmdst = br_mdb_ip6_get(brmctx->br, &grec->grec_mca, vid);\n\t\tif (!mdst)\n\t\t\tgoto unlock_continue;\n\t\tpg = br_multicast_find_port(mdst, pmctx->port, src);\n\t\tif (!pg || (pg->flags & MDB_PG_FLAGS_PERMANENT))\n\t\t\tgoto unlock_continue;\n\t\th_addr = &ipv6_hdr(skb)->saddr;\n\t\tswitch (grec->grec_type) {\n\t\tcase MLD2_ALLOW_NEW_SOURCES:\n\t\t\tchanged = br_multicast_isinc_allow(brmctx, pg, h_addr,\n\t\t\t\t\t\t\t   grec->grec_src, nsrcs,\n\t\t\t\t\t\t\t   sizeof(struct in6_addr),\n\t\t\t\t\t\t\t   grec->grec_type);\n\t\t\tbreak;\n\t\tcase MLD2_MODE_IS_INCLUDE:\n\t\t\tchanged = br_multicast_isinc_allow(brmctx, pg, h_addr,\n\t\t\t\t\t\t\t   grec->grec_src, nsrcs,\n\t\t\t\t\t\t\t   sizeof(struct in6_addr),\n\t\t\t\t\t\t\t   grec->grec_type);\n\t\t\tbreak;\n\t\tcase MLD2_MODE_IS_EXCLUDE:\n\t\t\tchanged = br_multicast_isexc(brmctx, pg, h_addr,\n\t\t\t\t\t\t     grec->grec_src, nsrcs,\n\t\t\t\t\t\t     sizeof(struct in6_addr),\n\t\t\t\t\t\t     grec->grec_type);\n\t\t\tbreak;\n\t\tcase MLD2_CHANGE_TO_INCLUDE:\n\t\t\tchanged = br_multicast_toin(brmctx, pmctx, pg, h_addr,\n\t\t\t\t\t\t    grec->grec_src, nsrcs,\n\t\t\t\t\t\t    sizeof(struct in6_addr),\n\t\t\t\t\t\t    grec->grec_type);\n\t\t\tbreak;\n\t\tcase MLD2_CHANGE_TO_EXCLUDE:\n\t\t\tchanged = br_multicast_toex(brmctx, pmctx, pg, h_addr,\n\t\t\t\t\t\t    grec->grec_src, nsrcs,\n\t\t\t\t\t\t    sizeof(struct in6_addr),\n\t\t\t\t\t\t    grec->grec_type);\n\t\t\tbreak;\n\t\tcase MLD2_BLOCK_OLD_SOURCES:\n\t\t\tchanged = br_multicast_block(brmctx, pmctx, pg, h_addr,\n\t\t\t\t\t\t     grec->grec_src, nsrcs,\n\t\t\t\t\t\t     sizeof(struct in6_addr),\n\t\t\t\t\t\t     grec->grec_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (changed)\n\t\t\tbr_mdb_notify(brmctx->br->dev, mdst, pg, RTM_NEWMDB);\nunlock_continue:\n\t\tspin_unlock(&brmctx->br->multicast_lock);\n\t}\n\n\treturn err;\n}\n#endif\n\nstatic bool br_multicast_select_querier(struct net_bridge_mcast *brmctx,\n\t\t\t\t\tstruct net_bridge_mcast_port *pmctx,\n\t\t\t\t\tstruct br_ip *saddr)\n{\n\tint port_ifidx = pmctx ? pmctx->port->dev->ifindex : 0;\n\tstruct timer_list *own_timer, *other_timer;\n\tstruct bridge_mcast_querier *querier;\n\n\tswitch (saddr->proto) {\n\tcase htons(ETH_P_IP):\n\t\tquerier = &brmctx->ip4_querier;\n\t\town_timer = &brmctx->ip4_own_query.timer;\n\t\tother_timer = &brmctx->ip4_other_query.timer;\n\t\tif (!querier->addr.src.ip4 ||\n\t\t    ntohl(saddr->src.ip4) <= ntohl(querier->addr.src.ip4))\n\t\t\tgoto update;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tquerier = &brmctx->ip6_querier;\n\t\town_timer = &brmctx->ip6_own_query.timer;\n\t\tother_timer = &brmctx->ip6_other_query.timer;\n\t\tif (ipv6_addr_cmp(&saddr->src.ip6, &querier->addr.src.ip6) <= 0)\n\t\t\tgoto update;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (!timer_pending(own_timer) && !timer_pending(other_timer))\n\t\tgoto update;\n\n\treturn false;\n\nupdate:\n\tbr_multicast_update_querier(brmctx, querier, port_ifidx, saddr);\n\n\treturn true;\n}\n\nstatic struct net_bridge_port *\n__br_multicast_get_querier_port(struct net_bridge *br,\n\t\t\t\tconst struct bridge_mcast_querier *querier)\n{\n\tint port_ifidx = READ_ONCE(querier->port_ifidx);\n\tstruct net_bridge_port *p;\n\tstruct net_device *dev;\n\n\tif (port_ifidx == 0)\n\t\treturn NULL;\n\n\tdev = dev_get_by_index_rcu(dev_net(br->dev), port_ifidx);\n\tif (!dev)\n\t\treturn NULL;\n\tp = br_port_get_rtnl_rcu(dev);\n\tif (!p || p->br != br)\n\t\treturn NULL;\n\n\treturn p;\n}\n\nsize_t br_multicast_querier_state_size(void)\n{\n\treturn nla_total_size(0) +\t\t \n\t       nla_total_size(sizeof(__be32)) +  \n\t       nla_total_size(sizeof(int)) +     \n\t       nla_total_size_64bit(sizeof(u64)) +  \n#if IS_ENABLED(CONFIG_IPV6)\n\t       nla_total_size(sizeof(struct in6_addr)) +  \n\t       nla_total_size(sizeof(int)) +\t\t  \n\t       nla_total_size_64bit(sizeof(u64)) +\t  \n#endif\n\t       0;\n}\n\n \nint br_multicast_dump_querier_state(struct sk_buff *skb,\n\t\t\t\t    const struct net_bridge_mcast *brmctx,\n\t\t\t\t    int nest_attr)\n{\n\tstruct bridge_mcast_querier querier = {};\n\tstruct net_bridge_port *p;\n\tstruct nlattr *nest;\n\n\tif (!br_opt_get(brmctx->br, BROPT_MULTICAST_ENABLED) ||\n\t    br_multicast_ctx_vlan_global_disabled(brmctx))\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, nest_attr);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\trcu_read_lock();\n\tif (!brmctx->multicast_querier &&\n\t    !timer_pending(&brmctx->ip4_other_query.timer))\n\t\tgoto out_v6;\n\n\tbr_multicast_read_querier(&brmctx->ip4_querier, &querier);\n\tif (nla_put_in_addr(skb, BRIDGE_QUERIER_IP_ADDRESS,\n\t\t\t    querier.addr.src.ip4)) {\n\t\trcu_read_unlock();\n\t\tgoto out_err;\n\t}\n\n\tp = __br_multicast_get_querier_port(brmctx->br, &querier);\n\tif (timer_pending(&brmctx->ip4_other_query.timer) &&\n\t    (nla_put_u64_64bit(skb, BRIDGE_QUERIER_IP_OTHER_TIMER,\n\t\t\t       br_timer_value(&brmctx->ip4_other_query.timer),\n\t\t\t       BRIDGE_QUERIER_PAD) ||\n\t     (p && nla_put_u32(skb, BRIDGE_QUERIER_IP_PORT, p->dev->ifindex)))) {\n\t\trcu_read_unlock();\n\t\tgoto out_err;\n\t}\n\nout_v6:\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (!brmctx->multicast_querier &&\n\t    !timer_pending(&brmctx->ip6_other_query.timer))\n\t\tgoto out;\n\n\tbr_multicast_read_querier(&brmctx->ip6_querier, &querier);\n\tif (nla_put_in6_addr(skb, BRIDGE_QUERIER_IPV6_ADDRESS,\n\t\t\t     &querier.addr.src.ip6)) {\n\t\trcu_read_unlock();\n\t\tgoto out_err;\n\t}\n\n\tp = __br_multicast_get_querier_port(brmctx->br, &querier);\n\tif (timer_pending(&brmctx->ip6_other_query.timer) &&\n\t    (nla_put_u64_64bit(skb, BRIDGE_QUERIER_IPV6_OTHER_TIMER,\n\t\t\t       br_timer_value(&brmctx->ip6_other_query.timer),\n\t\t\t       BRIDGE_QUERIER_PAD) ||\n\t     (p && nla_put_u32(skb, BRIDGE_QUERIER_IPV6_PORT,\n\t\t\t       p->dev->ifindex)))) {\n\t\trcu_read_unlock();\n\t\tgoto out_err;\n\t}\nout:\n#endif\n\trcu_read_unlock();\n\tnla_nest_end(skb, nest);\n\tif (!nla_len(nest))\n\t\tnla_nest_cancel(skb, nest);\n\n\treturn 0;\n\nout_err:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic void\nbr_multicast_update_query_timer(struct net_bridge_mcast *brmctx,\n\t\t\t\tstruct bridge_mcast_other_query *query,\n\t\t\t\tunsigned long max_delay)\n{\n\tif (!timer_pending(&query->timer))\n\t\tquery->delay_time = jiffies + max_delay;\n\n\tmod_timer(&query->timer, jiffies + brmctx->multicast_querier_interval);\n}\n\nstatic void br_port_mc_router_state_change(struct net_bridge_port *p,\n\t\t\t\t\t   bool is_mc_router)\n{\n\tstruct switchdev_attr attr = {\n\t\t.orig_dev = p->dev,\n\t\t.id = SWITCHDEV_ATTR_ID_PORT_MROUTER,\n\t\t.flags = SWITCHDEV_F_DEFER,\n\t\t.u.mrouter = is_mc_router,\n\t};\n\n\tswitchdev_port_attr_set(p->dev, &attr, NULL);\n}\n\nstatic struct net_bridge_port *\nbr_multicast_rport_from_node(struct net_bridge_mcast *brmctx,\n\t\t\t     struct hlist_head *mc_router_list,\n\t\t\t     struct hlist_node *rlist)\n{\n\tstruct net_bridge_mcast_port *pmctx;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (mc_router_list == &brmctx->ip6_mc_router_list)\n\t\tpmctx = hlist_entry(rlist, struct net_bridge_mcast_port,\n\t\t\t\t    ip6_rlist);\n\telse\n#endif\n\t\tpmctx = hlist_entry(rlist, struct net_bridge_mcast_port,\n\t\t\t\t    ip4_rlist);\n\n\treturn pmctx->port;\n}\n\nstatic struct hlist_node *\nbr_multicast_get_rport_slot(struct net_bridge_mcast *brmctx,\n\t\t\t    struct net_bridge_port *port,\n\t\t\t    struct hlist_head *mc_router_list)\n\n{\n\tstruct hlist_node *slot = NULL;\n\tstruct net_bridge_port *p;\n\tstruct hlist_node *rlist;\n\n\thlist_for_each(rlist, mc_router_list) {\n\t\tp = br_multicast_rport_from_node(brmctx, mc_router_list, rlist);\n\n\t\tif ((unsigned long)port >= (unsigned long)p)\n\t\t\tbreak;\n\n\t\tslot = rlist;\n\t}\n\n\treturn slot;\n}\n\nstatic bool br_multicast_no_router_otherpf(struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t   struct hlist_node *rnode)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (rnode != &pmctx->ip6_rlist)\n\t\treturn hlist_unhashed(&pmctx->ip6_rlist);\n\telse\n\t\treturn hlist_unhashed(&pmctx->ip4_rlist);\n#else\n\treturn true;\n#endif\n}\n\n \nstatic void br_multicast_add_router(struct net_bridge_mcast *brmctx,\n\t\t\t\t    struct net_bridge_mcast_port *pmctx,\n\t\t\t\t    struct hlist_node *rlist,\n\t\t\t\t    struct hlist_head *mc_router_list)\n{\n\tstruct hlist_node *slot;\n\n\tif (!hlist_unhashed(rlist))\n\t\treturn;\n\n\tslot = br_multicast_get_rport_slot(brmctx, pmctx->port, mc_router_list);\n\n\tif (slot)\n\t\thlist_add_behind_rcu(rlist, slot);\n\telse\n\t\thlist_add_head_rcu(rlist, mc_router_list);\n\n\t \n\tif (br_multicast_no_router_otherpf(pmctx, rlist)) {\n\t\tbr_rtr_notify(pmctx->port->br->dev, pmctx, RTM_NEWMDB);\n\t\tbr_port_mc_router_state_change(pmctx->port, true);\n\t}\n}\n\n \nstatic void br_ip4_multicast_add_router(struct net_bridge_mcast *brmctx,\n\t\t\t\t\tstruct net_bridge_mcast_port *pmctx)\n{\n\tbr_multicast_add_router(brmctx, pmctx, &pmctx->ip4_rlist,\n\t\t\t\t&brmctx->ip4_mc_router_list);\n}\n\n \nstatic void br_ip6_multicast_add_router(struct net_bridge_mcast *brmctx,\n\t\t\t\t\tstruct net_bridge_mcast_port *pmctx)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tbr_multicast_add_router(brmctx, pmctx, &pmctx->ip6_rlist,\n\t\t\t\t&brmctx->ip6_mc_router_list);\n#endif\n}\n\nstatic void br_multicast_mark_router(struct net_bridge_mcast *brmctx,\n\t\t\t\t     struct net_bridge_mcast_port *pmctx,\n\t\t\t\t     struct timer_list *timer,\n\t\t\t\t     struct hlist_node *rlist,\n\t\t\t\t     struct hlist_head *mc_router_list)\n{\n\tunsigned long now = jiffies;\n\n\tif (!br_multicast_ctx_should_use(brmctx, pmctx))\n\t\treturn;\n\n\tif (!pmctx) {\n\t\tif (brmctx->multicast_router == MDB_RTR_TYPE_TEMP_QUERY) {\n\t\t\tif (!br_ip4_multicast_is_router(brmctx) &&\n\t\t\t    !br_ip6_multicast_is_router(brmctx))\n\t\t\t\tbr_mc_router_state_change(brmctx->br, true);\n\t\t\tmod_timer(timer, now + brmctx->multicast_querier_interval);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (pmctx->multicast_router == MDB_RTR_TYPE_DISABLED ||\n\t    pmctx->multicast_router == MDB_RTR_TYPE_PERM)\n\t\treturn;\n\n\tbr_multicast_add_router(brmctx, pmctx, rlist, mc_router_list);\n\tmod_timer(timer, now + brmctx->multicast_querier_interval);\n}\n\nstatic void br_ip4_multicast_mark_router(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t struct net_bridge_mcast_port *pmctx)\n{\n\tstruct timer_list *timer = &brmctx->ip4_mc_router_timer;\n\tstruct hlist_node *rlist = NULL;\n\n\tif (pmctx) {\n\t\ttimer = &pmctx->ip4_mc_router_timer;\n\t\trlist = &pmctx->ip4_rlist;\n\t}\n\n\tbr_multicast_mark_router(brmctx, pmctx, timer, rlist,\n\t\t\t\t &brmctx->ip4_mc_router_list);\n}\n\nstatic void br_ip6_multicast_mark_router(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t struct net_bridge_mcast_port *pmctx)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct timer_list *timer = &brmctx->ip6_mc_router_timer;\n\tstruct hlist_node *rlist = NULL;\n\n\tif (pmctx) {\n\t\ttimer = &pmctx->ip6_mc_router_timer;\n\t\trlist = &pmctx->ip6_rlist;\n\t}\n\n\tbr_multicast_mark_router(brmctx, pmctx, timer, rlist,\n\t\t\t\t &brmctx->ip6_mc_router_list);\n#endif\n}\n\nstatic void\nbr_ip4_multicast_query_received(struct net_bridge_mcast *brmctx,\n\t\t\t\tstruct net_bridge_mcast_port *pmctx,\n\t\t\t\tstruct bridge_mcast_other_query *query,\n\t\t\t\tstruct br_ip *saddr,\n\t\t\t\tunsigned long max_delay)\n{\n\tif (!br_multicast_select_querier(brmctx, pmctx, saddr))\n\t\treturn;\n\n\tbr_multicast_update_query_timer(brmctx, query, max_delay);\n\tbr_ip4_multicast_mark_router(brmctx, pmctx);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void\nbr_ip6_multicast_query_received(struct net_bridge_mcast *brmctx,\n\t\t\t\tstruct net_bridge_mcast_port *pmctx,\n\t\t\t\tstruct bridge_mcast_other_query *query,\n\t\t\t\tstruct br_ip *saddr,\n\t\t\t\tunsigned long max_delay)\n{\n\tif (!br_multicast_select_querier(brmctx, pmctx, saddr))\n\t\treturn;\n\n\tbr_multicast_update_query_timer(brmctx, query, max_delay);\n\tbr_ip6_multicast_mark_router(brmctx, pmctx);\n}\n#endif\n\nstatic void br_ip4_multicast_query(struct net_bridge_mcast *brmctx,\n\t\t\t\t   struct net_bridge_mcast_port *pmctx,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   u16 vid)\n{\n\tunsigned int transport_len = ip_transport_len(skb);\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct igmphdr *ih = igmp_hdr(skb);\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct igmpv3_query *ih3;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip saddr = {};\n\tunsigned long max_delay;\n\tunsigned long now = jiffies;\n\t__be32 group;\n\n\tspin_lock(&brmctx->br->multicast_lock);\n\tif (!br_multicast_ctx_should_use(brmctx, pmctx))\n\t\tgoto out;\n\n\tgroup = ih->group;\n\n\tif (transport_len == sizeof(*ih)) {\n\t\tmax_delay = ih->code * (HZ / IGMP_TIMER_SCALE);\n\n\t\tif (!max_delay) {\n\t\t\tmax_delay = 10 * HZ;\n\t\t\tgroup = 0;\n\t\t}\n\t} else if (transport_len >= sizeof(*ih3)) {\n\t\tih3 = igmpv3_query_hdr(skb);\n\t\tif (ih3->nsrcs ||\n\t\t    (brmctx->multicast_igmp_version == 3 && group &&\n\t\t     ih3->suppress))\n\t\t\tgoto out;\n\n\t\tmax_delay = ih3->code ?\n\t\t\t    IGMPV3_MRC(ih3->code) * (HZ / IGMP_TIMER_SCALE) : 1;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (!group) {\n\t\tsaddr.proto = htons(ETH_P_IP);\n\t\tsaddr.src.ip4 = iph->saddr;\n\n\t\tbr_ip4_multicast_query_received(brmctx, pmctx,\n\t\t\t\t\t\t&brmctx->ip4_other_query,\n\t\t\t\t\t\t&saddr, max_delay);\n\t\tgoto out;\n\t}\n\n\tmp = br_mdb_ip4_get(brmctx->br, group, vid);\n\tif (!mp)\n\t\tgoto out;\n\n\tmax_delay *= brmctx->multicast_last_member_count;\n\n\tif (mp->host_joined &&\n\t    (timer_pending(&mp->timer) ?\n\t     time_after(mp->timer.expires, now + max_delay) :\n\t     try_to_del_timer_sync(&mp->timer) >= 0))\n\t\tmod_timer(&mp->timer, now + max_delay);\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, brmctx->br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (timer_pending(&p->timer) ?\n\t\t    time_after(p->timer.expires, now + max_delay) :\n\t\t    try_to_del_timer_sync(&p->timer) >= 0 &&\n\t\t    (brmctx->multicast_igmp_version == 2 ||\n\t\t     p->filter_mode == MCAST_EXCLUDE))\n\t\t\tmod_timer(&p->timer, now + max_delay);\n\t}\n\nout:\n\tspin_unlock(&brmctx->br->multicast_lock);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_ip6_multicast_query(struct net_bridge_mcast *brmctx,\n\t\t\t\t  struct net_bridge_mcast_port *pmctx,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  u16 vid)\n{\n\tunsigned int transport_len = ipv6_transport_len(skb);\n\tstruct mld_msg *mld;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct mld2_query *mld2q;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip saddr = {};\n\tunsigned long max_delay;\n\tunsigned long now = jiffies;\n\tunsigned int offset = skb_transport_offset(skb);\n\tconst struct in6_addr *group = NULL;\n\tbool is_general_query;\n\tint err = 0;\n\n\tspin_lock(&brmctx->br->multicast_lock);\n\tif (!br_multicast_ctx_should_use(brmctx, pmctx))\n\t\tgoto out;\n\n\tif (transport_len == sizeof(*mld)) {\n\t\tif (!pskb_may_pull(skb, offset + sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *) icmp6_hdr(skb);\n\t\tmax_delay = msecs_to_jiffies(ntohs(mld->mld_maxdelay));\n\t\tif (max_delay)\n\t\t\tgroup = &mld->mld_mca;\n\t} else {\n\t\tif (!pskb_may_pull(skb, offset + sizeof(*mld2q))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld2q = (struct mld2_query *)icmp6_hdr(skb);\n\t\tif (!mld2q->mld2q_nsrcs)\n\t\t\tgroup = &mld2q->mld2q_mca;\n\t\tif (brmctx->multicast_mld_version == 2 &&\n\t\t    !ipv6_addr_any(&mld2q->mld2q_mca) &&\n\t\t    mld2q->mld2q_suppress)\n\t\t\tgoto out;\n\n\t\tmax_delay = max(msecs_to_jiffies(mldv2_mrc(mld2q)), 1UL);\n\t}\n\n\tis_general_query = group && ipv6_addr_any(group);\n\n\tif (is_general_query) {\n\t\tsaddr.proto = htons(ETH_P_IPV6);\n\t\tsaddr.src.ip6 = ipv6_hdr(skb)->saddr;\n\n\t\tbr_ip6_multicast_query_received(brmctx, pmctx,\n\t\t\t\t\t\t&brmctx->ip6_other_query,\n\t\t\t\t\t\t&saddr, max_delay);\n\t\tgoto out;\n\t} else if (!group) {\n\t\tgoto out;\n\t}\n\n\tmp = br_mdb_ip6_get(brmctx->br, group, vid);\n\tif (!mp)\n\t\tgoto out;\n\n\tmax_delay *= brmctx->multicast_last_member_count;\n\tif (mp->host_joined &&\n\t    (timer_pending(&mp->timer) ?\n\t     time_after(mp->timer.expires, now + max_delay) :\n\t     try_to_del_timer_sync(&mp->timer) >= 0))\n\t\tmod_timer(&mp->timer, now + max_delay);\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, brmctx->br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (timer_pending(&p->timer) ?\n\t\t    time_after(p->timer.expires, now + max_delay) :\n\t\t    try_to_del_timer_sync(&p->timer) >= 0 &&\n\t\t    (brmctx->multicast_mld_version == 1 ||\n\t\t     p->filter_mode == MCAST_EXCLUDE))\n\t\t\tmod_timer(&p->timer, now + max_delay);\n\t}\n\nout:\n\tspin_unlock(&brmctx->br->multicast_lock);\n\treturn err;\n}\n#endif\n\nstatic void\nbr_multicast_leave_group(struct net_bridge_mcast *brmctx,\n\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t struct br_ip *group,\n\t\t\t struct bridge_mcast_other_query *other_query,\n\t\t\t struct bridge_mcast_own_query *own_query,\n\t\t\t const unsigned char *src)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tunsigned long now;\n\tunsigned long time;\n\n\tspin_lock(&brmctx->br->multicast_lock);\n\tif (!br_multicast_ctx_should_use(brmctx, pmctx))\n\t\tgoto out;\n\n\tmp = br_mdb_ip_get(brmctx->br, group);\n\tif (!mp)\n\t\tgoto out;\n\n\tif (pmctx && (pmctx->port->flags & BR_MULTICAST_FAST_LEAVE)) {\n\t\tstruct net_bridge_port_group __rcu **pp;\n\n\t\tfor (pp = &mp->ports;\n\t\t     (p = mlock_dereference(*pp, brmctx->br)) != NULL;\n\t\t     pp = &p->next) {\n\t\t\tif (!br_port_group_equal(p, pmctx->port, src))\n\t\t\t\tcontinue;\n\n\t\t\tif (p->flags & MDB_PG_FLAGS_PERMANENT)\n\t\t\t\tbreak;\n\n\t\t\tp->flags |= MDB_PG_FLAGS_FAST_LEAVE;\n\t\t\tbr_multicast_del_pg(mp, p, pp);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (timer_pending(&other_query->timer))\n\t\tgoto out;\n\n\tif (brmctx->multicast_querier) {\n\t\t__br_multicast_send_query(brmctx, pmctx, NULL, NULL, &mp->addr,\n\t\t\t\t\t  false, 0, NULL);\n\n\t\ttime = jiffies + brmctx->multicast_last_member_count *\n\t\t\t\t brmctx->multicast_last_member_interval;\n\n\t\tmod_timer(&own_query->timer, time);\n\n\t\tfor (p = mlock_dereference(mp->ports, brmctx->br);\n\t\t     p != NULL && pmctx != NULL;\n\t\t     p = mlock_dereference(p->next, brmctx->br)) {\n\t\t\tif (!br_port_group_equal(p, pmctx->port, src))\n\t\t\t\tcontinue;\n\n\t\t\tif (!hlist_unhashed(&p->mglist) &&\n\t\t\t    (timer_pending(&p->timer) ?\n\t\t\t     time_after(p->timer.expires, time) :\n\t\t\t     try_to_del_timer_sync(&p->timer) >= 0)) {\n\t\t\t\tmod_timer(&p->timer, time);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnow = jiffies;\n\ttime = now + brmctx->multicast_last_member_count *\n\t\t     brmctx->multicast_last_member_interval;\n\n\tif (!pmctx) {\n\t\tif (mp->host_joined &&\n\t\t    (timer_pending(&mp->timer) ?\n\t\t     time_after(mp->timer.expires, time) :\n\t\t     try_to_del_timer_sync(&mp->timer) >= 0)) {\n\t\t\tmod_timer(&mp->timer, time);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tfor (p = mlock_dereference(mp->ports, brmctx->br);\n\t     p != NULL;\n\t     p = mlock_dereference(p->next, brmctx->br)) {\n\t\tif (p->key.port != pmctx->port)\n\t\t\tcontinue;\n\n\t\tif (!hlist_unhashed(&p->mglist) &&\n\t\t    (timer_pending(&p->timer) ?\n\t\t     time_after(p->timer.expires, time) :\n\t\t     try_to_del_timer_sync(&p->timer) >= 0)) {\n\t\t\tmod_timer(&p->timer, time);\n\t\t}\n\n\t\tbreak;\n\t}\nout:\n\tspin_unlock(&brmctx->br->multicast_lock);\n}\n\nstatic void br_ip4_multicast_leave_group(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t __be32 group,\n\t\t\t\t\t __u16 vid,\n\t\t\t\t\t const unsigned char *src)\n{\n\tstruct br_ip br_group;\n\tstruct bridge_mcast_own_query *own_query;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn;\n\n\town_query = pmctx ? &pmctx->ip4_own_query : &brmctx->ip4_own_query;\n\n\tmemset(&br_group, 0, sizeof(br_group));\n\tbr_group.dst.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\tbr_group.vid = vid;\n\n\tbr_multicast_leave_group(brmctx, pmctx, &br_group,\n\t\t\t\t &brmctx->ip4_other_query,\n\t\t\t\t own_query, src);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_leave_group(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t\t\t const struct in6_addr *group,\n\t\t\t\t\t __u16 vid,\n\t\t\t\t\t const unsigned char *src)\n{\n\tstruct br_ip br_group;\n\tstruct bridge_mcast_own_query *own_query;\n\n\tif (ipv6_addr_is_ll_all_nodes(group))\n\t\treturn;\n\n\town_query = pmctx ? &pmctx->ip6_own_query : &brmctx->ip6_own_query;\n\n\tmemset(&br_group, 0, sizeof(br_group));\n\tbr_group.dst.ip6 = *group;\n\tbr_group.proto = htons(ETH_P_IPV6);\n\tbr_group.vid = vid;\n\n\tbr_multicast_leave_group(brmctx, pmctx, &br_group,\n\t\t\t\t &brmctx->ip6_other_query,\n\t\t\t\t own_query, src);\n}\n#endif\n\nstatic void br_multicast_err_count(const struct net_bridge *br,\n\t\t\t\t   const struct net_bridge_port *p,\n\t\t\t\t   __be16 proto)\n{\n\tstruct bridge_mcast_stats __percpu *stats;\n\tstruct bridge_mcast_stats *pstats;\n\n\tif (!br_opt_get(br, BROPT_MULTICAST_STATS_ENABLED))\n\t\treturn;\n\n\tif (p)\n\t\tstats = p->mcast_stats;\n\telse\n\t\tstats = br->mcast_stats;\n\tif (WARN_ON(!stats))\n\t\treturn;\n\n\tpstats = this_cpu_ptr(stats);\n\n\tu64_stats_update_begin(&pstats->syncp);\n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\tpstats->mstats.igmp_parse_errors++;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tpstats->mstats.mld_parse_errors++;\n\t\tbreak;\n#endif\n\t}\n\tu64_stats_update_end(&pstats->syncp);\n}\n\nstatic void br_multicast_pim(struct net_bridge_mcast *brmctx,\n\t\t\t     struct net_bridge_mcast_port *pmctx,\n\t\t\t     const struct sk_buff *skb)\n{\n\tunsigned int offset = skb_transport_offset(skb);\n\tstruct pimhdr *pimhdr, _pimhdr;\n\n\tpimhdr = skb_header_pointer(skb, offset, sizeof(_pimhdr), &_pimhdr);\n\tif (!pimhdr || pim_hdr_version(pimhdr) != PIM_VERSION ||\n\t    pim_hdr_type(pimhdr) != PIM_TYPE_HELLO)\n\t\treturn;\n\n\tspin_lock(&brmctx->br->multicast_lock);\n\tbr_ip4_multicast_mark_router(brmctx, pmctx);\n\tspin_unlock(&brmctx->br->multicast_lock);\n}\n\nstatic int br_ip4_multicast_mrd_rcv(struct net_bridge_mcast *brmctx,\n\t\t\t\t    struct net_bridge_mcast_port *pmctx,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tif (ip_hdr(skb)->protocol != IPPROTO_IGMP ||\n\t    igmp_hdr(skb)->type != IGMP_MRDISC_ADV)\n\t\treturn -ENOMSG;\n\n\tspin_lock(&brmctx->br->multicast_lock);\n\tbr_ip4_multicast_mark_router(brmctx, pmctx);\n\tspin_unlock(&brmctx->br->multicast_lock);\n\n\treturn 0;\n}\n\nstatic int br_multicast_ipv4_rcv(struct net_bridge_mcast *brmctx,\n\t\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t u16 vid)\n{\n\tstruct net_bridge_port *p = pmctx ? pmctx->port : NULL;\n\tconst unsigned char *src;\n\tstruct igmphdr *ih;\n\tint err;\n\n\terr = ip_mc_check_igmp(skb);\n\n\tif (err == -ENOMSG) {\n\t\tif (!ipv4_is_local_multicast(ip_hdr(skb)->daddr)) {\n\t\t\tBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\n\t\t} else if (pim_ipv4_all_pim_routers(ip_hdr(skb)->daddr)) {\n\t\t\tif (ip_hdr(skb)->protocol == IPPROTO_PIM)\n\t\t\t\tbr_multicast_pim(brmctx, pmctx, skb);\n\t\t} else if (ipv4_is_all_snoopers(ip_hdr(skb)->daddr)) {\n\t\t\tbr_ip4_multicast_mrd_rcv(brmctx, pmctx, skb);\n\t\t}\n\n\t\treturn 0;\n\t} else if (err < 0) {\n\t\tbr_multicast_err_count(brmctx->br, p, skb->protocol);\n\t\treturn err;\n\t}\n\n\tih = igmp_hdr(skb);\n\tsrc = eth_hdr(skb)->h_source;\n\tBR_INPUT_SKB_CB(skb)->igmp = ih->type;\n\n\tswitch (ih->type) {\n\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\tBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\n\t\terr = br_ip4_multicast_add_group(brmctx, pmctx, ih->group, vid,\n\t\t\t\t\t\t src, true);\n\t\tbreak;\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\t\terr = br_ip4_multicast_igmp3_report(brmctx, pmctx, skb, vid);\n\t\tbreak;\n\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\tbr_ip4_multicast_query(brmctx, pmctx, skb, vid);\n\t\tbreak;\n\tcase IGMP_HOST_LEAVE_MESSAGE:\n\t\tbr_ip4_multicast_leave_group(brmctx, pmctx, ih->group, vid, src);\n\t\tbreak;\n\t}\n\n\tbr_multicast_count(brmctx->br, p, skb, BR_INPUT_SKB_CB(skb)->igmp,\n\t\t\t   BR_MCAST_DIR_RX);\n\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_mrd_rcv(struct net_bridge_mcast *brmctx,\n\t\t\t\t     struct net_bridge_mcast_port *pmctx,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tif (icmp6_hdr(skb)->icmp6_type != ICMPV6_MRDISC_ADV)\n\t\treturn;\n\n\tspin_lock(&brmctx->br->multicast_lock);\n\tbr_ip6_multicast_mark_router(brmctx, pmctx);\n\tspin_unlock(&brmctx->br->multicast_lock);\n}\n\nstatic int br_multicast_ipv6_rcv(struct net_bridge_mcast *brmctx,\n\t\t\t\t struct net_bridge_mcast_port *pmctx,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t u16 vid)\n{\n\tstruct net_bridge_port *p = pmctx ? pmctx->port : NULL;\n\tconst unsigned char *src;\n\tstruct mld_msg *mld;\n\tint err;\n\n\terr = ipv6_mc_check_mld(skb);\n\n\tif (err == -ENOMSG || err == -ENODATA) {\n\t\tif (!ipv6_addr_is_ll_all_nodes(&ipv6_hdr(skb)->daddr))\n\t\t\tBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\n\t\tif (err == -ENODATA &&\n\t\t    ipv6_addr_is_all_snoopers(&ipv6_hdr(skb)->daddr))\n\t\t\tbr_ip6_multicast_mrd_rcv(brmctx, pmctx, skb);\n\n\t\treturn 0;\n\t} else if (err < 0) {\n\t\tbr_multicast_err_count(brmctx->br, p, skb->protocol);\n\t\treturn err;\n\t}\n\n\tmld = (struct mld_msg *)skb_transport_header(skb);\n\tBR_INPUT_SKB_CB(skb)->igmp = mld->mld_type;\n\n\tswitch (mld->mld_type) {\n\tcase ICMPV6_MGM_REPORT:\n\t\tsrc = eth_hdr(skb)->h_source;\n\t\tBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\n\t\terr = br_ip6_multicast_add_group(brmctx, pmctx, &mld->mld_mca,\n\t\t\t\t\t\t vid, src, true);\n\t\tbreak;\n\tcase ICMPV6_MLD2_REPORT:\n\t\terr = br_ip6_multicast_mld2_report(brmctx, pmctx, skb, vid);\n\t\tbreak;\n\tcase ICMPV6_MGM_QUERY:\n\t\terr = br_ip6_multicast_query(brmctx, pmctx, skb, vid);\n\t\tbreak;\n\tcase ICMPV6_MGM_REDUCTION:\n\t\tsrc = eth_hdr(skb)->h_source;\n\t\tbr_ip6_multicast_leave_group(brmctx, pmctx, &mld->mld_mca, vid,\n\t\t\t\t\t     src);\n\t\tbreak;\n\t}\n\n\tbr_multicast_count(brmctx->br, p, skb, BR_INPUT_SKB_CB(skb)->igmp,\n\t\t\t   BR_MCAST_DIR_RX);\n\n\treturn err;\n}\n#endif\n\nint br_multicast_rcv(struct net_bridge_mcast **brmctx,\n\t\t     struct net_bridge_mcast_port **pmctx,\n\t\t     struct net_bridge_vlan *vlan,\n\t\t     struct sk_buff *skb, u16 vid)\n{\n\tint ret = 0;\n\n\tBR_INPUT_SKB_CB(skb)->igmp = 0;\n\tBR_INPUT_SKB_CB(skb)->mrouters_only = 0;\n\n\tif (!br_opt_get((*brmctx)->br, BROPT_MULTICAST_ENABLED))\n\t\treturn 0;\n\n\tif (br_opt_get((*brmctx)->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) && vlan) {\n\t\tconst struct net_bridge_vlan *masterv;\n\n\t\t \n\t\tif (br_vlan_is_master(vlan)) {\n\t\t\tmasterv = vlan;\n\t\t\t*brmctx = &vlan->br_mcast_ctx;\n\t\t\t*pmctx = NULL;\n\t\t} else {\n\t\t\tmasterv = vlan->brvlan;\n\t\t\t*brmctx = &vlan->brvlan->br_mcast_ctx;\n\t\t\t*pmctx = &vlan->port_mcast_ctx;\n\t\t}\n\n\t\tif (!(masterv->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED))\n\t\t\treturn 0;\n\t}\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tret = br_multicast_ipv4_rcv(*brmctx, *pmctx, skb, vid);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tret = br_multicast_ipv6_rcv(*brmctx, *pmctx, skb, vid);\n\t\tbreak;\n#endif\n\t}\n\n\treturn ret;\n}\n\nstatic void br_multicast_query_expired(struct net_bridge_mcast *brmctx,\n\t\t\t\t       struct bridge_mcast_own_query *query,\n\t\t\t\t       struct bridge_mcast_querier *querier)\n{\n\tspin_lock(&brmctx->br->multicast_lock);\n\tif (br_multicast_ctx_vlan_disabled(brmctx))\n\t\tgoto out;\n\n\tif (query->startup_sent < brmctx->multicast_startup_query_count)\n\t\tquery->startup_sent++;\n\n\tbr_multicast_send_query(brmctx, NULL, query);\nout:\n\tspin_unlock(&brmctx->br->multicast_lock);\n}\n\nstatic void br_ip4_multicast_query_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mcast *brmctx = from_timer(brmctx, t,\n\t\t\t\t\t\t     ip4_own_query.timer);\n\n\tbr_multicast_query_expired(brmctx, &brmctx->ip4_own_query,\n\t\t\t\t   &brmctx->ip4_querier);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_query_expired(struct timer_list *t)\n{\n\tstruct net_bridge_mcast *brmctx = from_timer(brmctx, t,\n\t\t\t\t\t\t     ip6_own_query.timer);\n\n\tbr_multicast_query_expired(brmctx, &brmctx->ip6_own_query,\n\t\t\t\t   &brmctx->ip6_querier);\n}\n#endif\n\nstatic void br_multicast_gc_work(struct work_struct *work)\n{\n\tstruct net_bridge *br = container_of(work, struct net_bridge,\n\t\t\t\t\t     mcast_gc_work);\n\tHLIST_HEAD(deleted_head);\n\n\tspin_lock_bh(&br->multicast_lock);\n\thlist_move_list(&br->mcast_gc_list, &deleted_head);\n\tspin_unlock_bh(&br->multicast_lock);\n\n\tbr_multicast_gc(&deleted_head);\n}\n\nvoid br_multicast_ctx_init(struct net_bridge *br,\n\t\t\t   struct net_bridge_vlan *vlan,\n\t\t\t   struct net_bridge_mcast *brmctx)\n{\n\tbrmctx->br = br;\n\tbrmctx->vlan = vlan;\n\tbrmctx->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;\n\tbrmctx->multicast_last_member_count = 2;\n\tbrmctx->multicast_startup_query_count = 2;\n\n\tbrmctx->multicast_last_member_interval = HZ;\n\tbrmctx->multicast_query_response_interval = 10 * HZ;\n\tbrmctx->multicast_startup_query_interval = 125 * HZ / 4;\n\tbrmctx->multicast_query_interval = 125 * HZ;\n\tbrmctx->multicast_querier_interval = 255 * HZ;\n\tbrmctx->multicast_membership_interval = 260 * HZ;\n\n\tbrmctx->ip4_other_query.delay_time = 0;\n\tbrmctx->ip4_querier.port_ifidx = 0;\n\tseqcount_spinlock_init(&brmctx->ip4_querier.seq, &br->multicast_lock);\n\tbrmctx->multicast_igmp_version = 2;\n#if IS_ENABLED(CONFIG_IPV6)\n\tbrmctx->multicast_mld_version = 1;\n\tbrmctx->ip6_other_query.delay_time = 0;\n\tbrmctx->ip6_querier.port_ifidx = 0;\n\tseqcount_spinlock_init(&brmctx->ip6_querier.seq, &br->multicast_lock);\n#endif\n\n\ttimer_setup(&brmctx->ip4_mc_router_timer,\n\t\t    br_ip4_multicast_local_router_expired, 0);\n\ttimer_setup(&brmctx->ip4_other_query.timer,\n\t\t    br_ip4_multicast_querier_expired, 0);\n\ttimer_setup(&brmctx->ip4_own_query.timer,\n\t\t    br_ip4_multicast_query_expired, 0);\n#if IS_ENABLED(CONFIG_IPV6)\n\ttimer_setup(&brmctx->ip6_mc_router_timer,\n\t\t    br_ip6_multicast_local_router_expired, 0);\n\ttimer_setup(&brmctx->ip6_other_query.timer,\n\t\t    br_ip6_multicast_querier_expired, 0);\n\ttimer_setup(&brmctx->ip6_own_query.timer,\n\t\t    br_ip6_multicast_query_expired, 0);\n#endif\n}\n\nvoid br_multicast_ctx_deinit(struct net_bridge_mcast *brmctx)\n{\n\t__br_multicast_stop(brmctx);\n}\n\nvoid br_multicast_init(struct net_bridge *br)\n{\n\tbr->hash_max = BR_MULTICAST_DEFAULT_HASH_MAX;\n\n\tbr_multicast_ctx_init(br, NULL, &br->multicast_ctx);\n\n\tbr_opt_toggle(br, BROPT_MULTICAST_ENABLED, true);\n\tbr_opt_toggle(br, BROPT_HAS_IPV6_ADDR, true);\n\n\tspin_lock_init(&br->multicast_lock);\n\tINIT_HLIST_HEAD(&br->mdb_list);\n\tINIT_HLIST_HEAD(&br->mcast_gc_list);\n\tINIT_WORK(&br->mcast_gc_work, br_multicast_gc_work);\n}\n\nstatic void br_ip4_multicast_join_snoopers(struct net_bridge *br)\n{\n\tstruct in_device *in_dev = in_dev_get(br->dev);\n\n\tif (!in_dev)\n\t\treturn;\n\n\t__ip_mc_inc_group(in_dev, htonl(INADDR_ALLSNOOPERS_GROUP), GFP_ATOMIC);\n\tin_dev_put(in_dev);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_join_snoopers(struct net_bridge *br)\n{\n\tstruct in6_addr addr;\n\n\tipv6_addr_set(&addr, htonl(0xff020000), 0, 0, htonl(0x6a));\n\tipv6_dev_mc_inc(br->dev, &addr);\n}\n#else\nstatic inline void br_ip6_multicast_join_snoopers(struct net_bridge *br)\n{\n}\n#endif\n\nvoid br_multicast_join_snoopers(struct net_bridge *br)\n{\n\tbr_ip4_multicast_join_snoopers(br);\n\tbr_ip6_multicast_join_snoopers(br);\n}\n\nstatic void br_ip4_multicast_leave_snoopers(struct net_bridge *br)\n{\n\tstruct in_device *in_dev = in_dev_get(br->dev);\n\n\tif (WARN_ON(!in_dev))\n\t\treturn;\n\n\t__ip_mc_dec_group(in_dev, htonl(INADDR_ALLSNOOPERS_GROUP), GFP_ATOMIC);\n\tin_dev_put(in_dev);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_leave_snoopers(struct net_bridge *br)\n{\n\tstruct in6_addr addr;\n\n\tipv6_addr_set(&addr, htonl(0xff020000), 0, 0, htonl(0x6a));\n\tipv6_dev_mc_dec(br->dev, &addr);\n}\n#else\nstatic inline void br_ip6_multicast_leave_snoopers(struct net_bridge *br)\n{\n}\n#endif\n\nvoid br_multicast_leave_snoopers(struct net_bridge *br)\n{\n\tbr_ip4_multicast_leave_snoopers(br);\n\tbr_ip6_multicast_leave_snoopers(br);\n}\n\nstatic void __br_multicast_open_query(struct net_bridge *br,\n\t\t\t\t      struct bridge_mcast_own_query *query)\n{\n\tquery->startup_sent = 0;\n\n\tif (!br_opt_get(br, BROPT_MULTICAST_ENABLED))\n\t\treturn;\n\n\tmod_timer(&query->timer, jiffies);\n}\n\nstatic void __br_multicast_open(struct net_bridge_mcast *brmctx)\n{\n\t__br_multicast_open_query(brmctx->br, &brmctx->ip4_own_query);\n#if IS_ENABLED(CONFIG_IPV6)\n\t__br_multicast_open_query(brmctx->br, &brmctx->ip6_own_query);\n#endif\n}\n\nvoid br_multicast_open(struct net_bridge *br)\n{\n\tASSERT_RTNL();\n\n\tif (br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED)) {\n\t\tstruct net_bridge_vlan_group *vg;\n\t\tstruct net_bridge_vlan *vlan;\n\n\t\tvg = br_vlan_group(br);\n\t\tif (vg) {\n\t\t\tlist_for_each_entry(vlan, &vg->vlan_list, vlist) {\n\t\t\t\tstruct net_bridge_mcast *brmctx;\n\n\t\t\t\tbrmctx = &vlan->br_mcast_ctx;\n\t\t\t\tif (br_vlan_is_brentry(vlan) &&\n\t\t\t\t    !br_multicast_ctx_vlan_disabled(brmctx))\n\t\t\t\t\t__br_multicast_open(&vlan->br_mcast_ctx);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t__br_multicast_open(&br->multicast_ctx);\n\t}\n}\n\nstatic void __br_multicast_stop(struct net_bridge_mcast *brmctx)\n{\n\tdel_timer_sync(&brmctx->ip4_mc_router_timer);\n\tdel_timer_sync(&brmctx->ip4_other_query.timer);\n\tdel_timer_sync(&brmctx->ip4_own_query.timer);\n#if IS_ENABLED(CONFIG_IPV6)\n\tdel_timer_sync(&brmctx->ip6_mc_router_timer);\n\tdel_timer_sync(&brmctx->ip6_other_query.timer);\n\tdel_timer_sync(&brmctx->ip6_own_query.timer);\n#endif\n}\n\nvoid br_multicast_toggle_one_vlan(struct net_bridge_vlan *vlan, bool on)\n{\n\tstruct net_bridge *br;\n\n\t \n\tif (on == !!(vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED))\n\t\treturn;\n\n\tif (br_vlan_is_master(vlan)) {\n\t\tbr = vlan->br;\n\n\t\tif (!br_vlan_is_brentry(vlan) ||\n\t\t    (on &&\n\t\t     br_multicast_ctx_vlan_global_disabled(&vlan->br_mcast_ctx)))\n\t\t\treturn;\n\n\t\tspin_lock_bh(&br->multicast_lock);\n\t\tvlan->priv_flags ^= BR_VLFLAG_MCAST_ENABLED;\n\t\tspin_unlock_bh(&br->multicast_lock);\n\n\t\tif (on)\n\t\t\t__br_multicast_open(&vlan->br_mcast_ctx);\n\t\telse\n\t\t\t__br_multicast_stop(&vlan->br_mcast_ctx);\n\t} else {\n\t\tstruct net_bridge_mcast *brmctx;\n\n\t\tbrmctx = br_multicast_port_ctx_get_global(&vlan->port_mcast_ctx);\n\t\tif (on && br_multicast_ctx_vlan_global_disabled(brmctx))\n\t\t\treturn;\n\n\t\tbr = vlan->port->br;\n\t\tspin_lock_bh(&br->multicast_lock);\n\t\tvlan->priv_flags ^= BR_VLFLAG_MCAST_ENABLED;\n\t\tif (on)\n\t\t\t__br_multicast_enable_port_ctx(&vlan->port_mcast_ctx);\n\t\telse\n\t\t\t__br_multicast_disable_port_ctx(&vlan->port_mcast_ctx);\n\t\tspin_unlock_bh(&br->multicast_lock);\n\t}\n}\n\nstatic void br_multicast_toggle_vlan(struct net_bridge_vlan *vlan, bool on)\n{\n\tstruct net_bridge_port *p;\n\n\tif (WARN_ON_ONCE(!br_vlan_is_master(vlan)))\n\t\treturn;\n\n\tlist_for_each_entry(p, &vlan->br->port_list, list) {\n\t\tstruct net_bridge_vlan *vport;\n\n\t\tvport = br_vlan_find(nbp_vlan_group(p), vlan->vid);\n\t\tif (!vport)\n\t\t\tcontinue;\n\t\tbr_multicast_toggle_one_vlan(vport, on);\n\t}\n\n\tif (br_vlan_is_brentry(vlan))\n\t\tbr_multicast_toggle_one_vlan(vlan, on);\n}\n\nint br_multicast_toggle_vlan_snooping(struct net_bridge *br, bool on,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *vlan;\n\tstruct net_bridge_port *p;\n\n\tif (br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) == on)\n\t\treturn 0;\n\n\tif (on && !br_opt_get(br, BROPT_VLAN_ENABLED)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot enable multicast vlan snooping with vlan filtering disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tvg = br_vlan_group(br);\n\tif (!vg)\n\t\treturn 0;\n\n\tbr_opt_toggle(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED, on);\n\n\t \n\tif (on)\n\t\t__br_multicast_stop(&br->multicast_ctx);\n\telse\n\t\t__br_multicast_open(&br->multicast_ctx);\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (on)\n\t\t\tbr_multicast_disable_port(p);\n\t\telse\n\t\t\tbr_multicast_enable_port(p);\n\t}\n\n\tlist_for_each_entry(vlan, &vg->vlan_list, vlist)\n\t\tbr_multicast_toggle_vlan(vlan, on);\n\n\treturn 0;\n}\n\nbool br_multicast_toggle_global_vlan(struct net_bridge_vlan *vlan, bool on)\n{\n\tASSERT_RTNL();\n\n\t \n\tif (on == !!(vlan->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED))\n\t\treturn false;\n\n\tvlan->priv_flags ^= BR_VLFLAG_GLOBAL_MCAST_ENABLED;\n\tbr_multicast_toggle_vlan(vlan, on);\n\n\treturn true;\n}\n\nvoid br_multicast_stop(struct net_bridge *br)\n{\n\tASSERT_RTNL();\n\n\tif (br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED)) {\n\t\tstruct net_bridge_vlan_group *vg;\n\t\tstruct net_bridge_vlan *vlan;\n\n\t\tvg = br_vlan_group(br);\n\t\tif (vg) {\n\t\t\tlist_for_each_entry(vlan, &vg->vlan_list, vlist) {\n\t\t\t\tstruct net_bridge_mcast *brmctx;\n\n\t\t\t\tbrmctx = &vlan->br_mcast_ctx;\n\t\t\t\tif (br_vlan_is_brentry(vlan) &&\n\t\t\t\t    !br_multicast_ctx_vlan_disabled(brmctx))\n\t\t\t\t\t__br_multicast_stop(&vlan->br_mcast_ctx);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t__br_multicast_stop(&br->multicast_ctx);\n\t}\n}\n\nvoid br_multicast_dev_del(struct net_bridge *br)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tHLIST_HEAD(deleted_head);\n\tstruct hlist_node *tmp;\n\n\tspin_lock_bh(&br->multicast_lock);\n\thlist_for_each_entry_safe(mp, tmp, &br->mdb_list, mdb_node)\n\t\tbr_multicast_del_mdb_entry(mp);\n\thlist_move_list(&br->mcast_gc_list, &deleted_head);\n\tspin_unlock_bh(&br->multicast_lock);\n\n\tbr_multicast_ctx_deinit(&br->multicast_ctx);\n\tbr_multicast_gc(&deleted_head);\n\tcancel_work_sync(&br->mcast_gc_work);\n\n\trcu_barrier();\n}\n\nint br_multicast_set_router(struct net_bridge_mcast *brmctx, unsigned long val)\n{\n\tint err = -EINVAL;\n\n\tspin_lock_bh(&brmctx->br->multicast_lock);\n\n\tswitch (val) {\n\tcase MDB_RTR_TYPE_DISABLED:\n\tcase MDB_RTR_TYPE_PERM:\n\t\tbr_mc_router_state_change(brmctx->br, val == MDB_RTR_TYPE_PERM);\n\t\tdel_timer(&brmctx->ip4_mc_router_timer);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tdel_timer(&brmctx->ip6_mc_router_timer);\n#endif\n\t\tbrmctx->multicast_router = val;\n\t\terr = 0;\n\t\tbreak;\n\tcase MDB_RTR_TYPE_TEMP_QUERY:\n\t\tif (brmctx->multicast_router != MDB_RTR_TYPE_TEMP_QUERY)\n\t\t\tbr_mc_router_state_change(brmctx->br, false);\n\t\tbrmctx->multicast_router = val;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&brmctx->br->multicast_lock);\n\n\treturn err;\n}\n\nstatic void\nbr_multicast_rport_del_notify(struct net_bridge_mcast_port *pmctx, bool deleted)\n{\n\tif (!deleted)\n\t\treturn;\n\n\t \n\tif (!hlist_unhashed(&pmctx->ip4_rlist))\n\t\treturn;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (!hlist_unhashed(&pmctx->ip6_rlist))\n\t\treturn;\n#endif\n\n\tbr_rtr_notify(pmctx->port->br->dev, pmctx, RTM_DELMDB);\n\tbr_port_mc_router_state_change(pmctx->port, false);\n\n\t \n\tif (pmctx->multicast_router == MDB_RTR_TYPE_TEMP)\n\t\tpmctx->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;\n}\n\nint br_multicast_set_port_router(struct net_bridge_mcast_port *pmctx,\n\t\t\t\t unsigned long val)\n{\n\tstruct net_bridge_mcast *brmctx;\n\tunsigned long now = jiffies;\n\tint err = -EINVAL;\n\tbool del = false;\n\n\tbrmctx = br_multicast_port_ctx_get_global(pmctx);\n\tspin_lock_bh(&brmctx->br->multicast_lock);\n\tif (pmctx->multicast_router == val) {\n\t\t \n\t\tif (pmctx->multicast_router == MDB_RTR_TYPE_TEMP) {\n\t\t\tmod_timer(&pmctx->ip4_mc_router_timer,\n\t\t\t\t  now + brmctx->multicast_querier_interval);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tmod_timer(&pmctx->ip6_mc_router_timer,\n\t\t\t\t  now + brmctx->multicast_querier_interval);\n#endif\n\t\t}\n\t\terr = 0;\n\t\tgoto unlock;\n\t}\n\tswitch (val) {\n\tcase MDB_RTR_TYPE_DISABLED:\n\t\tpmctx->multicast_router = MDB_RTR_TYPE_DISABLED;\n\t\tdel |= br_ip4_multicast_rport_del(pmctx);\n\t\tdel_timer(&pmctx->ip4_mc_router_timer);\n\t\tdel |= br_ip6_multicast_rport_del(pmctx);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tdel_timer(&pmctx->ip6_mc_router_timer);\n#endif\n\t\tbr_multicast_rport_del_notify(pmctx, del);\n\t\tbreak;\n\tcase MDB_RTR_TYPE_TEMP_QUERY:\n\t\tpmctx->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;\n\t\tdel |= br_ip4_multicast_rport_del(pmctx);\n\t\tdel |= br_ip6_multicast_rport_del(pmctx);\n\t\tbr_multicast_rport_del_notify(pmctx, del);\n\t\tbreak;\n\tcase MDB_RTR_TYPE_PERM:\n\t\tpmctx->multicast_router = MDB_RTR_TYPE_PERM;\n\t\tdel_timer(&pmctx->ip4_mc_router_timer);\n\t\tbr_ip4_multicast_add_router(brmctx, pmctx);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tdel_timer(&pmctx->ip6_mc_router_timer);\n#endif\n\t\tbr_ip6_multicast_add_router(brmctx, pmctx);\n\t\tbreak;\n\tcase MDB_RTR_TYPE_TEMP:\n\t\tpmctx->multicast_router = MDB_RTR_TYPE_TEMP;\n\t\tbr_ip4_multicast_mark_router(brmctx, pmctx);\n\t\tbr_ip6_multicast_mark_router(brmctx, pmctx);\n\t\tbreak;\n\tdefault:\n\t\tgoto unlock;\n\t}\n\terr = 0;\nunlock:\n\tspin_unlock_bh(&brmctx->br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_set_vlan_router(struct net_bridge_vlan *v, u8 mcast_router)\n{\n\tint err;\n\n\tif (br_vlan_is_master(v))\n\t\terr = br_multicast_set_router(&v->br_mcast_ctx, mcast_router);\n\telse\n\t\terr = br_multicast_set_port_router(&v->port_mcast_ctx,\n\t\t\t\t\t\t   mcast_router);\n\n\treturn err;\n}\n\nstatic void br_multicast_start_querier(struct net_bridge_mcast *brmctx,\n\t\t\t\t       struct bridge_mcast_own_query *query)\n{\n\tstruct net_bridge_port *port;\n\n\tif (!br_multicast_ctx_matches_vlan_snooping(brmctx))\n\t\treturn;\n\n\t__br_multicast_open_query(brmctx->br, query);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(port, &brmctx->br->port_list, list) {\n\t\tstruct bridge_mcast_own_query *ip4_own_query;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct bridge_mcast_own_query *ip6_own_query;\n#endif\n\n\t\tif (br_multicast_port_ctx_state_stopped(&port->multicast_ctx))\n\t\t\tcontinue;\n\n\t\tif (br_multicast_ctx_is_vlan(brmctx)) {\n\t\t\tstruct net_bridge_vlan *vlan;\n\n\t\t\tvlan = br_vlan_find(nbp_vlan_group_rcu(port),\n\t\t\t\t\t    brmctx->vlan->vid);\n\t\t\tif (!vlan ||\n\t\t\t    br_multicast_port_ctx_state_stopped(&vlan->port_mcast_ctx))\n\t\t\t\tcontinue;\n\n\t\t\tip4_own_query = &vlan->port_mcast_ctx.ip4_own_query;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tip6_own_query = &vlan->port_mcast_ctx.ip6_own_query;\n#endif\n\t\t} else {\n\t\t\tip4_own_query = &port->multicast_ctx.ip4_own_query;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tip6_own_query = &port->multicast_ctx.ip6_own_query;\n#endif\n\t\t}\n\n\t\tif (query == &brmctx->ip4_own_query)\n\t\t\tbr_multicast_enable(ip4_own_query);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse\n\t\t\tbr_multicast_enable(ip6_own_query);\n#endif\n\t}\n\trcu_read_unlock();\n}\n\nint br_multicast_toggle(struct net_bridge *br, unsigned long val,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_port *port;\n\tbool change_snoopers = false;\n\tint err = 0;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tif (!!br_opt_get(br, BROPT_MULTICAST_ENABLED) == !!val)\n\t\tgoto unlock;\n\n\terr = br_mc_disabled_update(br->dev, val, extack);\n\tif (err == -EOPNOTSUPP)\n\t\terr = 0;\n\tif (err)\n\t\tgoto unlock;\n\n\tbr_opt_toggle(br, BROPT_MULTICAST_ENABLED, !!val);\n\tif (!br_opt_get(br, BROPT_MULTICAST_ENABLED)) {\n\t\tchange_snoopers = true;\n\t\tgoto unlock;\n\t}\n\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tbr_multicast_open(br);\n\tlist_for_each_entry(port, &br->port_list, list)\n\t\t__br_multicast_enable_port_ctx(&port->multicast_ctx);\n\n\tchange_snoopers = true;\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\n\t \n\tif (change_snoopers) {\n\t\tif (br_opt_get(br, BROPT_MULTICAST_ENABLED))\n\t\t\tbr_multicast_join_snoopers(br);\n\t\telse\n\t\t\tbr_multicast_leave_snoopers(br);\n\t}\n\n\treturn err;\n}\n\nbool br_multicast_enabled(const struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\treturn !!br_opt_get(br, BROPT_MULTICAST_ENABLED);\n}\nEXPORT_SYMBOL_GPL(br_multicast_enabled);\n\nbool br_multicast_router(const struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tbool is_router;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tis_router = br_multicast_is_router(&br->multicast_ctx, NULL);\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn is_router;\n}\nEXPORT_SYMBOL_GPL(br_multicast_router);\n\nint br_multicast_set_querier(struct net_bridge_mcast *brmctx, unsigned long val)\n{\n\tunsigned long max_delay;\n\n\tval = !!val;\n\n\tspin_lock_bh(&brmctx->br->multicast_lock);\n\tif (brmctx->multicast_querier == val)\n\t\tgoto unlock;\n\n\tWRITE_ONCE(brmctx->multicast_querier, val);\n\tif (!val)\n\t\tgoto unlock;\n\n\tmax_delay = brmctx->multicast_query_response_interval;\n\n\tif (!timer_pending(&brmctx->ip4_other_query.timer))\n\t\tbrmctx->ip4_other_query.delay_time = jiffies + max_delay;\n\n\tbr_multicast_start_querier(brmctx, &brmctx->ip4_own_query);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (!timer_pending(&brmctx->ip6_other_query.timer))\n\t\tbrmctx->ip6_other_query.delay_time = jiffies + max_delay;\n\n\tbr_multicast_start_querier(brmctx, &brmctx->ip6_own_query);\n#endif\n\nunlock:\n\tspin_unlock_bh(&brmctx->br->multicast_lock);\n\n\treturn 0;\n}\n\nint br_multicast_set_igmp_version(struct net_bridge_mcast *brmctx,\n\t\t\t\t  unsigned long val)\n{\n\t \n\tswitch (val) {\n\tcase 2:\n\tcase 3:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&brmctx->br->multicast_lock);\n\tbrmctx->multicast_igmp_version = val;\n\tspin_unlock_bh(&brmctx->br->multicast_lock);\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nint br_multicast_set_mld_version(struct net_bridge_mcast *brmctx,\n\t\t\t\t unsigned long val)\n{\n\t \n\tswitch (val) {\n\tcase 1:\n\tcase 2:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&brmctx->br->multicast_lock);\n\tbrmctx->multicast_mld_version = val;\n\tspin_unlock_bh(&brmctx->br->multicast_lock);\n\n\treturn 0;\n}\n#endif\n\nvoid br_multicast_set_query_intvl(struct net_bridge_mcast *brmctx,\n\t\t\t\t  unsigned long val)\n{\n\tunsigned long intvl_jiffies = clock_t_to_jiffies(val);\n\n\tif (intvl_jiffies < BR_MULTICAST_QUERY_INTVL_MIN) {\n\t\tbr_info(brmctx->br,\n\t\t\t\"trying to set multicast query interval below minimum, setting to %lu (%ums)\\n\",\n\t\t\tjiffies_to_clock_t(BR_MULTICAST_QUERY_INTVL_MIN),\n\t\t\tjiffies_to_msecs(BR_MULTICAST_QUERY_INTVL_MIN));\n\t\tintvl_jiffies = BR_MULTICAST_QUERY_INTVL_MIN;\n\t}\n\n\tbrmctx->multicast_query_interval = intvl_jiffies;\n}\n\nvoid br_multicast_set_startup_query_intvl(struct net_bridge_mcast *brmctx,\n\t\t\t\t\t  unsigned long val)\n{\n\tunsigned long intvl_jiffies = clock_t_to_jiffies(val);\n\n\tif (intvl_jiffies < BR_MULTICAST_STARTUP_QUERY_INTVL_MIN) {\n\t\tbr_info(brmctx->br,\n\t\t\t\"trying to set multicast startup query interval below minimum, setting to %lu (%ums)\\n\",\n\t\t\tjiffies_to_clock_t(BR_MULTICAST_STARTUP_QUERY_INTVL_MIN),\n\t\t\tjiffies_to_msecs(BR_MULTICAST_STARTUP_QUERY_INTVL_MIN));\n\t\tintvl_jiffies = BR_MULTICAST_STARTUP_QUERY_INTVL_MIN;\n\t}\n\n\tbrmctx->multicast_startup_query_interval = intvl_jiffies;\n}\n\n \nint br_multicast_list_adjacent(struct net_device *dev,\n\t\t\t       struct list_head *br_ip_list)\n{\n\tstruct net_bridge *br;\n\tstruct net_bridge_port *port;\n\tstruct net_bridge_port_group *group;\n\tstruct br_ip_list *entry;\n\tint count = 0;\n\n\trcu_read_lock();\n\tif (!br_ip_list || !netif_is_bridge_port(dev))\n\t\tgoto unlock;\n\n\tport = br_port_get_rcu(dev);\n\tif (!port || !port->br)\n\t\tgoto unlock;\n\n\tbr = port->br;\n\n\tlist_for_each_entry_rcu(port, &br->port_list, list) {\n\t\tif (!port->dev || port->dev == dev)\n\t\t\tcontinue;\n\n\t\thlist_for_each_entry_rcu(group, &port->mglist, mglist) {\n\t\t\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\t\t\tif (!entry)\n\t\t\t\tgoto unlock;\n\n\t\t\tentry->addr = group->key.addr;\n\t\t\tlist_add(&entry->list, br_ip_list);\n\t\t\tcount++;\n\t\t}\n\t}\n\nunlock:\n\trcu_read_unlock();\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(br_multicast_list_adjacent);\n\n \nbool br_multicast_has_querier_anywhere(struct net_device *dev, int proto)\n{\n\tstruct net_bridge *br;\n\tstruct net_bridge_port *port;\n\tstruct ethhdr eth;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tif (!netif_is_bridge_port(dev))\n\t\tgoto unlock;\n\n\tport = br_port_get_rcu(dev);\n\tif (!port || !port->br)\n\t\tgoto unlock;\n\n\tbr = port->br;\n\n\tmemset(&eth, 0, sizeof(eth));\n\teth.h_proto = htons(proto);\n\n\tret = br_multicast_querier_exists(&br->multicast_ctx, &eth, NULL);\n\nunlock:\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(br_multicast_has_querier_anywhere);\n\n \nbool br_multicast_has_querier_adjacent(struct net_device *dev, int proto)\n{\n\tstruct net_bridge_mcast *brmctx;\n\tstruct net_bridge *br;\n\tstruct net_bridge_port *port;\n\tbool ret = false;\n\tint port_ifidx;\n\n\trcu_read_lock();\n\tif (!netif_is_bridge_port(dev))\n\t\tgoto unlock;\n\n\tport = br_port_get_rcu(dev);\n\tif (!port || !port->br)\n\t\tgoto unlock;\n\n\tbr = port->br;\n\tbrmctx = &br->multicast_ctx;\n\n\tswitch (proto) {\n\tcase ETH_P_IP:\n\t\tport_ifidx = brmctx->ip4_querier.port_ifidx;\n\t\tif (!timer_pending(&brmctx->ip4_other_query.timer) ||\n\t\t    port_ifidx == port->dev->ifindex)\n\t\t\tgoto unlock;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase ETH_P_IPV6:\n\t\tport_ifidx = brmctx->ip6_querier.port_ifidx;\n\t\tif (!timer_pending(&brmctx->ip6_other_query.timer) ||\n\t\t    port_ifidx == port->dev->ifindex)\n\t\t\tgoto unlock;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tgoto unlock;\n\t}\n\n\tret = true;\nunlock:\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(br_multicast_has_querier_adjacent);\n\n \nbool br_multicast_has_router_adjacent(struct net_device *dev, int proto)\n{\n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_mcast *brmctx;\n\tstruct net_bridge_port *port;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tport = br_port_get_check_rcu(dev);\n\tif (!port)\n\t\tgoto unlock;\n\n\tbrmctx = &port->br->multicast_ctx;\n\tswitch (proto) {\n\tcase ETH_P_IP:\n\t\thlist_for_each_entry_rcu(pmctx, &brmctx->ip4_mc_router_list,\n\t\t\t\t\t ip4_rlist) {\n\t\t\tif (pmctx->port == port)\n\t\t\t\tcontinue;\n\n\t\t\tret = true;\n\t\t\tgoto unlock;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase ETH_P_IPV6:\n\t\thlist_for_each_entry_rcu(pmctx, &brmctx->ip6_mc_router_list,\n\t\t\t\t\t ip6_rlist) {\n\t\t\tif (pmctx->port == port)\n\t\t\t\tcontinue;\n\n\t\t\tret = true;\n\t\t\tgoto unlock;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\t \n\t\tret = true;\n\t}\n\nunlock:\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(br_multicast_has_router_adjacent);\n\nstatic void br_mcast_stats_add(struct bridge_mcast_stats __percpu *stats,\n\t\t\t       const struct sk_buff *skb, u8 type, u8 dir)\n{\n\tstruct bridge_mcast_stats *pstats = this_cpu_ptr(stats);\n\t__be16 proto = skb->protocol;\n\tunsigned int t_len;\n\n\tu64_stats_update_begin(&pstats->syncp);\n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\tt_len = ntohs(ip_hdr(skb)->tot_len) - ip_hdrlen(skb);\n\t\tswitch (type) {\n\t\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\t\t\tpstats->mstats.igmp_v1reports[dir]++;\n\t\t\tbreak;\n\t\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\t\tpstats->mstats.igmp_v2reports[dir]++;\n\t\t\tbreak;\n\t\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\t\t\tpstats->mstats.igmp_v3reports[dir]++;\n\t\t\tbreak;\n\t\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\t\tif (t_len != sizeof(struct igmphdr)) {\n\t\t\t\tpstats->mstats.igmp_v3queries[dir]++;\n\t\t\t} else {\n\t\t\t\tunsigned int offset = skb_transport_offset(skb);\n\t\t\t\tstruct igmphdr *ih, _ihdr;\n\n\t\t\t\tih = skb_header_pointer(skb, offset,\n\t\t\t\t\t\t\tsizeof(_ihdr), &_ihdr);\n\t\t\t\tif (!ih)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!ih->code)\n\t\t\t\t\tpstats->mstats.igmp_v1queries[dir]++;\n\t\t\t\telse\n\t\t\t\t\tpstats->mstats.igmp_v2queries[dir]++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IGMP_HOST_LEAVE_MESSAGE:\n\t\t\tpstats->mstats.igmp_leaves[dir]++;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tt_len = ntohs(ipv6_hdr(skb)->payload_len) +\n\t\t\tsizeof(struct ipv6hdr);\n\t\tt_len -= skb_network_header_len(skb);\n\t\tswitch (type) {\n\t\tcase ICMPV6_MGM_REPORT:\n\t\t\tpstats->mstats.mld_v1reports[dir]++;\n\t\t\tbreak;\n\t\tcase ICMPV6_MLD2_REPORT:\n\t\t\tpstats->mstats.mld_v2reports[dir]++;\n\t\t\tbreak;\n\t\tcase ICMPV6_MGM_QUERY:\n\t\t\tif (t_len != sizeof(struct mld_msg))\n\t\t\t\tpstats->mstats.mld_v2queries[dir]++;\n\t\t\telse\n\t\t\t\tpstats->mstats.mld_v1queries[dir]++;\n\t\t\tbreak;\n\t\tcase ICMPV6_MGM_REDUCTION:\n\t\t\tpstats->mstats.mld_leaves[dir]++;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif  \n\t}\n\tu64_stats_update_end(&pstats->syncp);\n}\n\nvoid br_multicast_count(struct net_bridge *br,\n\t\t\tconst struct net_bridge_port *p,\n\t\t\tconst struct sk_buff *skb, u8 type, u8 dir)\n{\n\tstruct bridge_mcast_stats __percpu *stats;\n\n\t \n\tif (!type || !br_opt_get(br, BROPT_MULTICAST_STATS_ENABLED))\n\t\treturn;\n\n\tif (p)\n\t\tstats = p->mcast_stats;\n\telse\n\t\tstats = br->mcast_stats;\n\tif (WARN_ON(!stats))\n\t\treturn;\n\n\tbr_mcast_stats_add(stats, skb, type, dir);\n}\n\nint br_multicast_init_stats(struct net_bridge *br)\n{\n\tbr->mcast_stats = netdev_alloc_pcpu_stats(struct bridge_mcast_stats);\n\tif (!br->mcast_stats)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid br_multicast_uninit_stats(struct net_bridge *br)\n{\n\tfree_percpu(br->mcast_stats);\n}\n\n/* noinline for https:\nstatic noinline_for_stack void mcast_stats_add_dir(u64 *dst, u64 *src)\n{\n\tdst[BR_MCAST_DIR_RX] += src[BR_MCAST_DIR_RX];\n\tdst[BR_MCAST_DIR_TX] += src[BR_MCAST_DIR_TX];\n}\n\nvoid br_multicast_get_stats(const struct net_bridge *br,\n\t\t\t    const struct net_bridge_port *p,\n\t\t\t    struct br_mcast_stats *dest)\n{\n\tstruct bridge_mcast_stats __percpu *stats;\n\tstruct br_mcast_stats tdst;\n\tint i;\n\n\tmemset(dest, 0, sizeof(*dest));\n\tif (p)\n\t\tstats = p->mcast_stats;\n\telse\n\t\tstats = br->mcast_stats;\n\tif (WARN_ON(!stats))\n\t\treturn;\n\n\tmemset(&tdst, 0, sizeof(tdst));\n\tfor_each_possible_cpu(i) {\n\t\tstruct bridge_mcast_stats *cpu_stats = per_cpu_ptr(stats, i);\n\t\tstruct br_mcast_stats temp;\n\t\tunsigned int start;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&cpu_stats->syncp);\n\t\t\tmemcpy(&temp, &cpu_stats->mstats, sizeof(temp));\n\t\t} while (u64_stats_fetch_retry(&cpu_stats->syncp, start));\n\n\t\tmcast_stats_add_dir(tdst.igmp_v1queries, temp.igmp_v1queries);\n\t\tmcast_stats_add_dir(tdst.igmp_v2queries, temp.igmp_v2queries);\n\t\tmcast_stats_add_dir(tdst.igmp_v3queries, temp.igmp_v3queries);\n\t\tmcast_stats_add_dir(tdst.igmp_leaves, temp.igmp_leaves);\n\t\tmcast_stats_add_dir(tdst.igmp_v1reports, temp.igmp_v1reports);\n\t\tmcast_stats_add_dir(tdst.igmp_v2reports, temp.igmp_v2reports);\n\t\tmcast_stats_add_dir(tdst.igmp_v3reports, temp.igmp_v3reports);\n\t\ttdst.igmp_parse_errors += temp.igmp_parse_errors;\n\n\t\tmcast_stats_add_dir(tdst.mld_v1queries, temp.mld_v1queries);\n\t\tmcast_stats_add_dir(tdst.mld_v2queries, temp.mld_v2queries);\n\t\tmcast_stats_add_dir(tdst.mld_leaves, temp.mld_leaves);\n\t\tmcast_stats_add_dir(tdst.mld_v1reports, temp.mld_v1reports);\n\t\tmcast_stats_add_dir(tdst.mld_v2reports, temp.mld_v2reports);\n\t\ttdst.mld_parse_errors += temp.mld_parse_errors;\n\t}\n\tmemcpy(dest, &tdst, sizeof(*dest));\n}\n\nint br_mdb_hash_init(struct net_bridge *br)\n{\n\tint err;\n\n\terr = rhashtable_init(&br->sg_port_tbl, &br_sg_port_rht_params);\n\tif (err)\n\t\treturn err;\n\n\terr = rhashtable_init(&br->mdb_hash_tbl, &br_mdb_rht_params);\n\tif (err) {\n\t\trhashtable_destroy(&br->sg_port_tbl);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid br_mdb_hash_fini(struct net_bridge *br)\n{\n\trhashtable_destroy(&br->sg_port_tbl);\n\trhashtable_destroy(&br->mdb_hash_tbl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}