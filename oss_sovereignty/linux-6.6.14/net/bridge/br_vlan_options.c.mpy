{
  "module_name": "br_vlan_options.c",
  "hash_id": "f9ede25fa6f46a9395431975782ce99047c5ee6bd1470f1ed451773f36666874",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_vlan_options.c",
  "human_readable_source": "\n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <net/ip_tunnels.h>\n\n#include \"br_private.h\"\n#include \"br_private_tunnel.h\"\n\nstatic bool __vlan_tun_put(struct sk_buff *skb, const struct net_bridge_vlan *v)\n{\n\t__be32 tid = tunnel_id_to_key32(v->tinfo.tunnel_id);\n\tstruct nlattr *nest;\n\n\tif (!v->tinfo.tunnel_dst)\n\t\treturn true;\n\n\tnest = nla_nest_start(skb, BRIDGE_VLANDB_ENTRY_TUNNEL_INFO);\n\tif (!nest)\n\t\treturn false;\n\tif (nla_put_u32(skb, BRIDGE_VLANDB_TINFO_ID, be32_to_cpu(tid))) {\n\t\tnla_nest_cancel(skb, nest);\n\t\treturn false;\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn true;\n}\n\nstatic bool __vlan_tun_can_enter_range(const struct net_bridge_vlan *v_curr,\n\t\t\t\t       const struct net_bridge_vlan *range_end)\n{\n\treturn (!v_curr->tinfo.tunnel_dst && !range_end->tinfo.tunnel_dst) ||\n\t       vlan_tunid_inrange(v_curr, range_end);\n}\n\n \nbool br_vlan_opts_eq_range(const struct net_bridge_vlan *v_curr,\n\t\t\t   const struct net_bridge_vlan *range_end)\n{\n\tu8 range_mc_rtr = br_vlan_multicast_router(range_end);\n\tu8 curr_mc_rtr = br_vlan_multicast_router(v_curr);\n\n\treturn v_curr->state == range_end->state &&\n\t       __vlan_tun_can_enter_range(v_curr, range_end) &&\n\t       curr_mc_rtr == range_mc_rtr;\n}\n\nbool br_vlan_opts_fill(struct sk_buff *skb, const struct net_bridge_vlan *v,\n\t\t       const struct net_bridge_port *p)\n{\n\tif (nla_put_u8(skb, BRIDGE_VLANDB_ENTRY_STATE, br_vlan_get_state(v)) ||\n\t    !__vlan_tun_put(skb, v) ||\n\t    nla_put_u8(skb, BRIDGE_VLANDB_ENTRY_NEIGH_SUPPRESS,\n\t\t       !!(v->priv_flags & BR_VLFLAG_NEIGH_SUPPRESS_ENABLED)))\n\t\treturn false;\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tif (nla_put_u8(skb, BRIDGE_VLANDB_ENTRY_MCAST_ROUTER,\n\t\t       br_vlan_multicast_router(v)))\n\t\treturn false;\n\tif (p && !br_multicast_port_ctx_vlan_disabled(&v->port_mcast_ctx) &&\n\t    (nla_put_u32(skb, BRIDGE_VLANDB_ENTRY_MCAST_N_GROUPS,\n\t\t\t br_multicast_ngroups_get(&v->port_mcast_ctx)) ||\n\t     nla_put_u32(skb, BRIDGE_VLANDB_ENTRY_MCAST_MAX_GROUPS,\n\t\t\t br_multicast_ngroups_get_max(&v->port_mcast_ctx))))\n\t\treturn false;\n#endif\n\n\treturn true;\n}\n\nsize_t br_vlan_opts_nl_size(void)\n{\n\treturn nla_total_size(sizeof(u8))  \n\t       + nla_total_size(0)  \n\t       + nla_total_size(sizeof(u32))  \n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\t       + nla_total_size(sizeof(u8))  \n\t       + nla_total_size(sizeof(u32))  \n\t       + nla_total_size(sizeof(u32))  \n#endif\n\t       + nla_total_size(sizeof(u8))  \n\t       + 0;\n}\n\nstatic int br_vlan_modify_state(struct net_bridge_vlan_group *vg,\n\t\t\t\tstruct net_bridge_vlan *v,\n\t\t\t\tu8 state,\n\t\t\t\tbool *changed,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_bridge *br;\n\n\tASSERT_RTNL();\n\n\tif (state > BR_STATE_BLOCKING) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid vlan state\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (br_vlan_is_brentry(v))\n\t\tbr = v->br;\n\telse\n\t\tbr = v->port->br;\n\n\tif (br->stp_enabled == BR_KERNEL_STP) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't modify vlan state when using kernel STP\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (br_opt_get(br, BROPT_MST_ENABLED)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't modify vlan state directly when MST is enabled\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (v->state == state)\n\t\treturn 0;\n\n\tif (v->vid == br_get_pvid(vg))\n\t\tbr_vlan_set_pvid_state(vg, state);\n\n\tbr_vlan_set_state(v, state);\n\t*changed = true;\n\n\treturn 0;\n}\n\nstatic const struct nla_policy br_vlandb_tinfo_pol[BRIDGE_VLANDB_TINFO_MAX + 1] = {\n\t[BRIDGE_VLANDB_TINFO_ID]\t= { .type = NLA_U32 },\n\t[BRIDGE_VLANDB_TINFO_CMD]\t= { .type = NLA_U32 },\n};\n\nstatic int br_vlan_modify_tunnel(const struct net_bridge_port *p,\n\t\t\t\t struct net_bridge_vlan *v,\n\t\t\t\t struct nlattr **tb,\n\t\t\t\t bool *changed,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tun_tb[BRIDGE_VLANDB_TINFO_MAX + 1], *attr;\n\tstruct bridge_vlan_info *vinfo;\n\tu32 tun_id = 0;\n\tint cmd, err;\n\n\tif (!p) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't modify tunnel mapping of non-port vlans\");\n\t\treturn -EINVAL;\n\t}\n\tif (!(p->flags & BR_VLAN_TUNNEL)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Port doesn't have tunnel flag set\");\n\t\treturn -EINVAL;\n\t}\n\n\tattr = tb[BRIDGE_VLANDB_ENTRY_TUNNEL_INFO];\n\terr = nla_parse_nested(tun_tb, BRIDGE_VLANDB_TINFO_MAX, attr,\n\t\t\t       br_vlandb_tinfo_pol, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tun_tb[BRIDGE_VLANDB_TINFO_CMD]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing tunnel command attribute\");\n\t\treturn -ENOENT;\n\t}\n\tcmd = nla_get_u32(tun_tb[BRIDGE_VLANDB_TINFO_CMD]);\n\tswitch (cmd) {\n\tcase RTM_SETLINK:\n\t\tif (!tun_tb[BRIDGE_VLANDB_TINFO_ID]) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing tunnel id attribute\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t \n\t\ttun_id = nla_get_u32(tun_tb[BRIDGE_VLANDB_TINFO_ID]);\n\t\t \n\t\tvinfo = nla_data(tb[BRIDGE_VLANDB_ENTRY_INFO]);\n\t\t \n\t\ttun_id += v->vid - vinfo->vid;\n\t\tbreak;\n\tcase RTM_DELLINK:\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported tunnel command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn br_vlan_tunnel_info(p, cmd, v->vid, tun_id, changed);\n}\n\nstatic int br_vlan_process_one_opts(const struct net_bridge *br,\n\t\t\t\t    const struct net_bridge_port *p,\n\t\t\t\t    struct net_bridge_vlan_group *vg,\n\t\t\t\t    struct net_bridge_vlan *v,\n\t\t\t\t    struct nlattr **tb,\n\t\t\t\t    bool *changed,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\t*changed = false;\n\tif (tb[BRIDGE_VLANDB_ENTRY_STATE]) {\n\t\tu8 state = nla_get_u8(tb[BRIDGE_VLANDB_ENTRY_STATE]);\n\n\t\terr = br_vlan_modify_state(vg, v, state, changed, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (tb[BRIDGE_VLANDB_ENTRY_TUNNEL_INFO]) {\n\t\terr = br_vlan_modify_tunnel(p, v, tb, changed, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tif (tb[BRIDGE_VLANDB_ENTRY_MCAST_ROUTER]) {\n\t\tu8 val;\n\n\t\tval = nla_get_u8(tb[BRIDGE_VLANDB_ENTRY_MCAST_ROUTER]);\n\t\terr = br_multicast_set_vlan_router(v, val);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_ENTRY_MCAST_MAX_GROUPS]) {\n\t\tu32 val;\n\n\t\tif (!p) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't set mcast_max_groups for non-port vlans\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (br_multicast_port_ctx_vlan_disabled(&v->port_mcast_ctx)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Multicast snooping disabled on this VLAN\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = nla_get_u32(tb[BRIDGE_VLANDB_ENTRY_MCAST_MAX_GROUPS]);\n\t\tbr_multicast_ngroups_set_max(&v->port_mcast_ctx, val);\n\t\t*changed = true;\n\t}\n#endif\n\n\tif (tb[BRIDGE_VLANDB_ENTRY_NEIGH_SUPPRESS]) {\n\t\tbool enabled = v->priv_flags & BR_VLFLAG_NEIGH_SUPPRESS_ENABLED;\n\t\tbool val = nla_get_u8(tb[BRIDGE_VLANDB_ENTRY_NEIGH_SUPPRESS]);\n\n\t\tif (!p) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't set neigh_suppress for non-port vlans\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (val != enabled) {\n\t\t\tv->priv_flags ^= BR_VLFLAG_NEIGH_SUPPRESS_ENABLED;\n\t\t\t*changed = true;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint br_vlan_process_options(const struct net_bridge *br,\n\t\t\t    const struct net_bridge_port *p,\n\t\t\t    struct net_bridge_vlan *range_start,\n\t\t\t    struct net_bridge_vlan *range_end,\n\t\t\t    struct nlattr **tb,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan *v, *curr_start = NULL, *curr_end = NULL;\n\tstruct net_bridge_vlan_group *vg;\n\tint vid, err = 0;\n\tu16 pvid;\n\n\tif (p)\n\t\tvg = nbp_vlan_group(p);\n\telse\n\t\tvg = br_vlan_group(br);\n\n\tif (!range_start || !br_vlan_should_use(range_start)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Vlan range start doesn't exist, can't process options\");\n\t\treturn -ENOENT;\n\t}\n\tif (!range_end || !br_vlan_should_use(range_end)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Vlan range end doesn't exist, can't process options\");\n\t\treturn -ENOENT;\n\t}\n\n\tpvid = br_get_pvid(vg);\n\tfor (vid = range_start->vid; vid <= range_end->vid; vid++) {\n\t\tbool changed = false;\n\n\t\tv = br_vlan_find(vg, vid);\n\t\tif (!v || !br_vlan_should_use(v)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Vlan in range doesn't exist, can't process options\");\n\t\t\terr = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = br_vlan_process_one_opts(br, p, vg, v, tb, &changed,\n\t\t\t\t\t       extack);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (changed) {\n\t\t\t \n\t\t\tif (!curr_start) {\n\t\t\t\tcurr_start = v;\n\t\t\t\tcurr_end = v;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (v->vid == pvid ||\n\t\t\t    !br_vlan_can_enter_range(v, curr_end)) {\n\t\t\t\tbr_vlan_notify(br, p, curr_start->vid,\n\t\t\t\t\t       curr_end->vid, RTM_NEWVLAN);\n\t\t\t\tcurr_start = v;\n\t\t\t}\n\t\t\tcurr_end = v;\n\t\t} else {\n\t\t\t \n\t\t\tif (!curr_start)\n\t\t\t\tcontinue;\n\n\t\t\tbr_vlan_notify(br, p, curr_start->vid, curr_end->vid,\n\t\t\t\t       RTM_NEWVLAN);\n\t\t\tcurr_start = NULL;\n\t\t\tcurr_end = NULL;\n\t\t}\n\t}\n\tif (curr_start)\n\t\tbr_vlan_notify(br, p, curr_start->vid, curr_end->vid,\n\t\t\t       RTM_NEWVLAN);\n\n\treturn err;\n}\n\nbool br_vlan_global_opts_can_enter_range(const struct net_bridge_vlan *v_curr,\n\t\t\t\t\t const struct net_bridge_vlan *r_end)\n{\n\treturn v_curr->vid - r_end->vid == 1 &&\n\t\tv_curr->msti == r_end->msti &&\n\t       ((v_curr->priv_flags ^ r_end->priv_flags) &\n\t\tBR_VLFLAG_GLOBAL_MCAST_ENABLED) == 0 &&\n\t\tbr_multicast_ctx_options_equal(&v_curr->br_mcast_ctx,\n\t\t\t\t\t       &r_end->br_mcast_ctx);\n}\n\nbool br_vlan_global_opts_fill(struct sk_buff *skb, u16 vid, u16 vid_range,\n\t\t\t      const struct net_bridge_vlan *v_opts)\n{\n\tstruct nlattr *nest2 __maybe_unused;\n\tu64 clockval __maybe_unused;\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start(skb, BRIDGE_VLANDB_GLOBAL_OPTIONS);\n\tif (!nest)\n\t\treturn false;\n\n\tif (nla_put_u16(skb, BRIDGE_VLANDB_GOPTS_ID, vid))\n\t\tgoto out_err;\n\n\tif (vid_range && vid < vid_range &&\n\t    nla_put_u16(skb, BRIDGE_VLANDB_GOPTS_RANGE, vid_range))\n\t\tgoto out_err;\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tif (nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING,\n\t\t       !!(v_opts->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED)) ||\n\t    nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION,\n\t\t       v_opts->br_mcast_ctx.multicast_igmp_version) ||\n\t    nla_put_u32(skb, BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT,\n\t\t\tv_opts->br_mcast_ctx.multicast_last_member_count) ||\n\t    nla_put_u32(skb, BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT,\n\t\t\tv_opts->br_mcast_ctx.multicast_startup_query_count) ||\n\t    nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERIER,\n\t\t       v_opts->br_mcast_ctx.multicast_querier) ||\n\t    br_multicast_dump_querier_state(skb, &v_opts->br_mcast_ctx,\n\t\t\t\t\t    BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_STATE))\n\t\tgoto out_err;\n\n\tclockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_last_member_interval);\n\tif (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL,\n\t\t\t      clockval, BRIDGE_VLANDB_GOPTS_PAD))\n\t\tgoto out_err;\n\tclockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_membership_interval);\n\tif (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL,\n\t\t\t      clockval, BRIDGE_VLANDB_GOPTS_PAD))\n\t\tgoto out_err;\n\tclockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_querier_interval);\n\tif (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL,\n\t\t\t      clockval, BRIDGE_VLANDB_GOPTS_PAD))\n\t\tgoto out_err;\n\tclockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_query_interval);\n\tif (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL,\n\t\t\t      clockval, BRIDGE_VLANDB_GOPTS_PAD))\n\t\tgoto out_err;\n\tclockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_query_response_interval);\n\tif (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL,\n\t\t\t      clockval, BRIDGE_VLANDB_GOPTS_PAD))\n\t\tgoto out_err;\n\tclockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_startup_query_interval);\n\tif (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL,\n\t\t\t      clockval, BRIDGE_VLANDB_GOPTS_PAD))\n\t\tgoto out_err;\n\n\tif (br_rports_have_mc_router(&v_opts->br_mcast_ctx)) {\n\t\tnest2 = nla_nest_start(skb,\n\t\t\t\t       BRIDGE_VLANDB_GOPTS_MCAST_ROUTER_PORTS);\n\t\tif (!nest2)\n\t\t\tgoto out_err;\n\n\t\trcu_read_lock();\n\t\tif (br_rports_fill_info(skb, &v_opts->br_mcast_ctx)) {\n\t\t\trcu_read_unlock();\n\t\t\tnla_nest_cancel(skb, nest2);\n\t\t\tgoto out_err;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tnla_nest_end(skb, nest2);\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION,\n\t\t       v_opts->br_mcast_ctx.multicast_mld_version))\n\t\tgoto out_err;\n#endif\n#endif\n\n\tif (nla_put_u16(skb, BRIDGE_VLANDB_GOPTS_MSTI, v_opts->msti))\n\t\tgoto out_err;\n\n\tnla_nest_end(skb, nest);\n\n\treturn true;\n\nout_err:\n\tnla_nest_cancel(skb, nest);\n\treturn false;\n}\n\nstatic size_t rtnl_vlan_global_opts_nlmsg_size(const struct net_bridge_vlan *v)\n{\n\treturn NLMSG_ALIGN(sizeof(struct br_vlan_msg))\n\t\t+ nla_total_size(0)  \n\t\t+ nla_total_size(sizeof(u16))  \n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\t\t+ nla_total_size(sizeof(u8))  \n\t\t+ nla_total_size(sizeof(u8))  \n\t\t+ nla_total_size(sizeof(u8))  \n\t\t+ nla_total_size(sizeof(u32))  \n\t\t+ nla_total_size(sizeof(u32))  \n\t\t+ nla_total_size(sizeof(u64))  \n\t\t+ nla_total_size(sizeof(u64))  \n\t\t+ nla_total_size(sizeof(u64))  \n\t\t+ nla_total_size(sizeof(u64))  \n\t\t+ nla_total_size(sizeof(u64))  \n\t\t+ nla_total_size(sizeof(u64))  \n\t\t+ nla_total_size(sizeof(u8))  \n\t\t+ br_multicast_querier_state_size()  \n\t\t+ nla_total_size(0)  \n\t\t+ br_rports_size(&v->br_mcast_ctx)  \n#endif\n\t\t+ nla_total_size(sizeof(u16))  \n\t\t+ nla_total_size(sizeof(u16));  \n}\n\nstatic void br_vlan_global_opts_notify(const struct net_bridge *br,\n\t\t\t\t       u16 vid, u16 vid_range)\n{\n\tstruct net_bridge_vlan *v;\n\tstruct br_vlan_msg *bvm;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\t \n\tASSERT_RTNL();\n\n\t \n\tv = br_vlan_find(br_vlan_group(br), vid);\n\tif (!v)\n\t\treturn;\n\n\tskb = nlmsg_new(rtnl_vlan_global_opts_nlmsg_size(v), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto out_err;\n\n\terr = -EMSGSIZE;\n\tnlh = nlmsg_put(skb, 0, 0, RTM_NEWVLAN, sizeof(*bvm), 0);\n\tif (!nlh)\n\t\tgoto out_err;\n\tbvm = nlmsg_data(nlh);\n\tmemset(bvm, 0, sizeof(*bvm));\n\tbvm->family = AF_BRIDGE;\n\tbvm->ifindex = br->dev->ifindex;\n\n\tif (!br_vlan_global_opts_fill(skb, vid, vid_range, v))\n\t\tgoto out_err;\n\n\tnlmsg_end(skb, nlh);\n\trtnl_notify(skb, dev_net(br->dev), 0, RTNLGRP_BRVLAN, NULL, GFP_KERNEL);\n\treturn;\n\nout_err:\n\trtnl_set_sk_err(dev_net(br->dev), RTNLGRP_BRVLAN, err);\n\tkfree_skb(skb);\n}\n\nstatic int br_vlan_process_global_one_opts(const struct net_bridge *br,\n\t\t\t\t\t   struct net_bridge_vlan_group *vg,\n\t\t\t\t\t   struct net_bridge_vlan *v,\n\t\t\t\t\t   struct nlattr **tb,\n\t\t\t\t\t   bool *changed,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tint err __maybe_unused;\n\n\t*changed = false;\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]) {\n\t\tu8 mc_snooping;\n\n\t\tmc_snooping = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]);\n\t\tif (br_multicast_toggle_global_vlan(v, !!mc_snooping))\n\t\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]) {\n\t\tu8 ver;\n\n\t\tver = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]);\n\t\terr = br_multicast_set_igmp_version(&v->br_mcast_ctx, ver);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]) {\n\t\tu32 cnt;\n\n\t\tcnt = nla_get_u32(tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]);\n\t\tv->br_mcast_ctx.multicast_last_member_count = cnt;\n\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]) {\n\t\tu32 cnt;\n\n\t\tcnt = nla_get_u32(tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]);\n\t\tv->br_mcast_ctx.multicast_startup_query_count = cnt;\n\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]) {\n\t\tu64 val;\n\n\t\tval = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]);\n\t\tv->br_mcast_ctx.multicast_last_member_interval = clock_t_to_jiffies(val);\n\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]) {\n\t\tu64 val;\n\n\t\tval = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]);\n\t\tv->br_mcast_ctx.multicast_membership_interval = clock_t_to_jiffies(val);\n\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]) {\n\t\tu64 val;\n\n\t\tval = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]);\n\t\tv->br_mcast_ctx.multicast_querier_interval = clock_t_to_jiffies(val);\n\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]) {\n\t\tu64 val;\n\n\t\tval = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]);\n\t\tbr_multicast_set_query_intvl(&v->br_mcast_ctx, val);\n\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL]) {\n\t\tu64 val;\n\n\t\tval = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL]);\n\t\tv->br_mcast_ctx.multicast_query_response_interval = clock_t_to_jiffies(val);\n\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]) {\n\t\tu64 val;\n\n\t\tval = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]);\n\t\tbr_multicast_set_startup_query_intvl(&v->br_mcast_ctx, val);\n\t\t*changed = true;\n\t}\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]) {\n\t\tu8 val;\n\n\t\tval = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]);\n\t\terr = br_multicast_set_querier(&v->br_mcast_ctx, val);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*changed = true;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (tb[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]) {\n\t\tu8 ver;\n\n\t\tver = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]);\n\t\terr = br_multicast_set_mld_version(&v->br_mcast_ctx, ver);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*changed = true;\n\t}\n#endif\n#endif\n\tif (tb[BRIDGE_VLANDB_GOPTS_MSTI]) {\n\t\tu16 msti;\n\n\t\tmsti = nla_get_u16(tb[BRIDGE_VLANDB_GOPTS_MSTI]);\n\t\terr = br_mst_vlan_set_msti(v, msti);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*changed = true;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nla_policy br_vlan_db_gpol[BRIDGE_VLANDB_GOPTS_MAX + 1] = {\n\t[BRIDGE_VLANDB_GOPTS_ID]\t= { .type = NLA_U16 },\n\t[BRIDGE_VLANDB_GOPTS_RANGE]\t= { .type = NLA_U16 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]\t= { .type = NLA_U8 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]\t= { .type = NLA_U8 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]\t= { .type = NLA_U64 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]\t= { .type = NLA_U8 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]\t= { .type = NLA_U8 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]\t= { .type = NLA_U32 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]\t= { .type = NLA_U32 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]\t= { .type = NLA_U64 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]\t= { .type = NLA_U64 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]\t= { .type = NLA_U64 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]\t= { .type = NLA_U64 },\n\t[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL] = { .type = NLA_U64 },\n\t[BRIDGE_VLANDB_GOPTS_MSTI] = NLA_POLICY_MAX(NLA_U16, VLAN_N_VID - 1),\n};\n\nint br_vlan_rtm_process_global_options(struct net_device *dev,\n\t\t\t\t       const struct nlattr *attr,\n\t\t\t\t       int cmd,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan *v, *curr_start = NULL, *curr_end = NULL;\n\tstruct nlattr *tb[BRIDGE_VLANDB_GOPTS_MAX + 1];\n\tstruct net_bridge_vlan_group *vg;\n\tu16 vid, vid_range = 0;\n\tstruct net_bridge *br;\n\tint err = 0;\n\n\tif (cmd != RTM_NEWVLAN) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Global vlan options support only set operation\");\n\t\treturn -EINVAL;\n\t}\n\tif (!netif_is_bridge_master(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Global vlan options can only be set on bridge device\");\n\t\treturn -EINVAL;\n\t}\n\tbr = netdev_priv(dev);\n\tvg = br_vlan_group(br);\n\tif (WARN_ON(!vg))\n\t\treturn -ENODEV;\n\n\terr = nla_parse_nested(tb, BRIDGE_VLANDB_GOPTS_MAX, attr,\n\t\t\t       br_vlan_db_gpol, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[BRIDGE_VLANDB_GOPTS_ID]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing vlan entry id\");\n\t\treturn -EINVAL;\n\t}\n\tvid = nla_get_u16(tb[BRIDGE_VLANDB_GOPTS_ID]);\n\tif (!br_vlan_valid_id(vid, extack))\n\t\treturn -EINVAL;\n\n\tif (tb[BRIDGE_VLANDB_GOPTS_RANGE]) {\n\t\tvid_range = nla_get_u16(tb[BRIDGE_VLANDB_GOPTS_RANGE]);\n\t\tif (!br_vlan_valid_id(vid_range, extack))\n\t\t\treturn -EINVAL;\n\t\tif (vid >= vid_range) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"End vlan id is less than or equal to start vlan id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tvid_range = vid;\n\t}\n\n\tfor (; vid <= vid_range; vid++) {\n\t\tbool changed = false;\n\n\t\tv = br_vlan_find(vg, vid);\n\t\tif (!v) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Vlan in range doesn't exist, can't process global options\");\n\t\t\terr = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = br_vlan_process_global_one_opts(br, vg, v, tb, &changed,\n\t\t\t\t\t\t      extack);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (changed) {\n\t\t\t \n\t\t\tif (!curr_start) {\n\t\t\t\tcurr_start = v;\n\t\t\t\tcurr_end = v;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!br_vlan_global_opts_can_enter_range(v, curr_end)) {\n\t\t\t\tbr_vlan_global_opts_notify(br, curr_start->vid,\n\t\t\t\t\t\t\t   curr_end->vid);\n\t\t\t\tcurr_start = v;\n\t\t\t}\n\t\t\tcurr_end = v;\n\t\t} else {\n\t\t\t \n\t\t\tif (!curr_start)\n\t\t\t\tcontinue;\n\n\t\t\tbr_vlan_global_opts_notify(br, curr_start->vid,\n\t\t\t\t\t\t   curr_end->vid);\n\t\t\tcurr_start = NULL;\n\t\t\tcurr_end = NULL;\n\t\t}\n\t}\n\tif (curr_start)\n\t\tbr_vlan_global_opts_notify(br, curr_start->vid, curr_end->vid);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}