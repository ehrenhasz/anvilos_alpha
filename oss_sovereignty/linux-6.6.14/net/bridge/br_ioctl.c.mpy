{
  "module_name": "br_ioctl.c",
  "hash_id": "61bac3a073f776159791d5a91713048bcf509025b70d55a1f338c01e3d1474ac",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/compat.h>\n#include <linux/kernel.h>\n#include <linux/if_bridge.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/times.h>\n#include <net/net_namespace.h>\n#include <linux/uaccess.h>\n#include \"br_private.h\"\n\nstatic int get_bridge_ifindices(struct net *net, int *indices, int num)\n{\n\tstruct net_device *dev;\n\tint i = 0;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (i >= num)\n\t\t\tbreak;\n\t\tif (netif_is_bridge_master(dev))\n\t\t\tindices[i++] = dev->ifindex;\n\t}\n\trcu_read_unlock();\n\n\treturn i;\n}\n\n \nstatic void get_port_ifindices(struct net_bridge *br, int *ifindices, int num)\n{\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->port_no < num)\n\t\t\tifindices[p->port_no] = p->dev->ifindex;\n\t}\n}\n\n \nstatic int get_fdb_entries(struct net_bridge *br, void __user *userbuf,\n\t\t\t   unsigned long maxnum, unsigned long offset)\n{\n\tint num;\n\tvoid *buf;\n\tsize_t size;\n\n\t \n\tif (maxnum > PAGE_SIZE/sizeof(struct __fdb_entry))\n\t\tmaxnum = PAGE_SIZE/sizeof(struct __fdb_entry);\n\n\tsize = maxnum * sizeof(struct __fdb_entry);\n\n\tbuf = kmalloc(size, GFP_USER);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tnum = br_fdb_fillbuf(br, buf, maxnum, offset);\n\tif (num > 0) {\n\t\tif (copy_to_user(userbuf, buf,\n\t\t\t\t array_size(num, sizeof(struct __fdb_entry))))\n\t\t\tnum = -EFAULT;\n\t}\n\tkfree(buf);\n\n\treturn num;\n}\n\n \nstatic int add_del_if(struct net_bridge *br, int ifindex, int isadd)\n{\n\tstruct net *net = dev_net(br->dev);\n\tstruct net_device *dev;\n\tint ret;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tdev = __dev_get_by_index(net, ifindex);\n\tif (dev == NULL)\n\t\treturn -EINVAL;\n\n\tif (isadd)\n\t\tret = br_add_if(br, dev, NULL);\n\telse\n\t\tret = br_del_if(br, dev);\n\n\treturn ret;\n}\n\n#define BR_UARGS_MAX 4\nstatic int br_dev_read_uargs(unsigned long *args, size_t nr_args,\n\t\t\t     void __user **argp, void __user *data)\n{\n\tint ret;\n\n\tif (nr_args < 2 || nr_args > BR_UARGS_MAX)\n\t\treturn -EINVAL;\n\n\tif (in_compat_syscall()) {\n\t\tunsigned int cargs[BR_UARGS_MAX];\n\t\tint i;\n\n\t\tret = copy_from_user(cargs, data, nr_args * sizeof(*cargs));\n\t\tif (ret)\n\t\t\tgoto fault;\n\n\t\tfor (i = 0; i < nr_args; ++i)\n\t\t\targs[i] = cargs[i];\n\n\t\t*argp = compat_ptr(args[1]);\n\t} else {\n\t\tret = copy_from_user(args, data, nr_args * sizeof(*args));\n\t\tif (ret)\n\t\t\tgoto fault;\n\t\t*argp = (void __user *)args[1];\n\t}\n\n\treturn 0;\nfault:\n\treturn -EFAULT;\n}\n\n \nint br_dev_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\t  void __user *data, int cmd)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_port *p = NULL;\n\tunsigned long args[4];\n\tvoid __user *argp;\n\tint ret;\n\n\tret = br_dev_read_uargs(args, ARRAY_SIZE(args), &argp, data);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (args[0]) {\n\tcase BRCTL_ADD_IF:\n\tcase BRCTL_DEL_IF:\n\t\treturn add_del_if(br, args[1], args[0] == BRCTL_ADD_IF);\n\n\tcase BRCTL_GET_BRIDGE_INFO:\n\t{\n\t\tstruct __bridge_info b;\n\n\t\tmemset(&b, 0, sizeof(struct __bridge_info));\n\t\trcu_read_lock();\n\t\tmemcpy(&b.designated_root, &br->designated_root, 8);\n\t\tmemcpy(&b.bridge_id, &br->bridge_id, 8);\n\t\tb.root_path_cost = br->root_path_cost;\n\t\tb.max_age = jiffies_to_clock_t(br->max_age);\n\t\tb.hello_time = jiffies_to_clock_t(br->hello_time);\n\t\tb.forward_delay = br->forward_delay;\n\t\tb.bridge_max_age = br->bridge_max_age;\n\t\tb.bridge_hello_time = br->bridge_hello_time;\n\t\tb.bridge_forward_delay = jiffies_to_clock_t(br->bridge_forward_delay);\n\t\tb.topology_change = br->topology_change;\n\t\tb.topology_change_detected = br->topology_change_detected;\n\t\tb.root_port = br->root_port;\n\n\t\tb.stp_enabled = (br->stp_enabled != BR_NO_STP);\n\t\tb.ageing_time = jiffies_to_clock_t(br->ageing_time);\n\t\tb.hello_timer_value = br_timer_value(&br->hello_timer);\n\t\tb.tcn_timer_value = br_timer_value(&br->tcn_timer);\n\t\tb.topology_change_timer_value = br_timer_value(&br->topology_change_timer);\n\t\tb.gc_timer_value = br_timer_value(&br->gc_work.timer);\n\t\trcu_read_unlock();\n\n\t\tif (copy_to_user((void __user *)args[1], &b, sizeof(b)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase BRCTL_GET_PORT_LIST:\n\t{\n\t\tint num, *indices;\n\n\t\tnum = args[2];\n\t\tif (num < 0)\n\t\t\treturn -EINVAL;\n\t\tif (num == 0)\n\t\t\tnum = 256;\n\t\tif (num > BR_MAX_PORTS)\n\t\t\tnum = BR_MAX_PORTS;\n\n\t\tindices = kcalloc(num, sizeof(int), GFP_KERNEL);\n\t\tif (indices == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tget_port_ifindices(br, indices, num);\n\t\tif (copy_to_user(argp, indices, array_size(num, sizeof(int))))\n\t\t\tnum =  -EFAULT;\n\t\tkfree(indices);\n\t\treturn num;\n\t}\n\n\tcase BRCTL_SET_BRIDGE_FORWARD_DELAY:\n\t\tif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tret = br_set_forward_delay(br, args[1]);\n\t\tbreak;\n\n\tcase BRCTL_SET_BRIDGE_HELLO_TIME:\n\t\tif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tret = br_set_hello_time(br, args[1]);\n\t\tbreak;\n\n\tcase BRCTL_SET_BRIDGE_MAX_AGE:\n\t\tif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tret = br_set_max_age(br, args[1]);\n\t\tbreak;\n\n\tcase BRCTL_SET_AGEING_TIME:\n\t\tif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tret = br_set_ageing_time(br, args[1]);\n\t\tbreak;\n\n\tcase BRCTL_GET_PORT_INFO:\n\t{\n\t\tstruct __port_info p;\n\t\tstruct net_bridge_port *pt;\n\n\t\trcu_read_lock();\n\t\tif ((pt = br_get_port(br, args[2])) == NULL) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemset(&p, 0, sizeof(struct __port_info));\n\t\tmemcpy(&p.designated_root, &pt->designated_root, 8);\n\t\tmemcpy(&p.designated_bridge, &pt->designated_bridge, 8);\n\t\tp.port_id = pt->port_id;\n\t\tp.designated_port = pt->designated_port;\n\t\tp.path_cost = pt->path_cost;\n\t\tp.designated_cost = pt->designated_cost;\n\t\tp.state = pt->state;\n\t\tp.top_change_ack = pt->topology_change_ack;\n\t\tp.config_pending = pt->config_pending;\n\t\tp.message_age_timer_value = br_timer_value(&pt->message_age_timer);\n\t\tp.forward_delay_timer_value = br_timer_value(&pt->forward_delay_timer);\n\t\tp.hold_timer_value = br_timer_value(&pt->hold_timer);\n\n\t\trcu_read_unlock();\n\n\t\tif (copy_to_user(argp, &p, sizeof(p)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase BRCTL_SET_BRIDGE_STP_STATE:\n\t\tif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tret = br_stp_set_enabled(br, args[1], NULL);\n\t\tbreak;\n\n\tcase BRCTL_SET_BRIDGE_PRIORITY:\n\t\tif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tbr_stp_set_bridge_priority(br, args[1]);\n\t\tret = 0;\n\t\tbreak;\n\n\tcase BRCTL_SET_PORT_PRIORITY:\n\t{\n\t\tif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tspin_lock_bh(&br->lock);\n\t\tif ((p = br_get_port(br, args[1])) == NULL)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = br_stp_set_port_priority(p, args[2]);\n\t\tspin_unlock_bh(&br->lock);\n\t\tbreak;\n\t}\n\n\tcase BRCTL_SET_PATH_COST:\n\t{\n\t\tif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tspin_lock_bh(&br->lock);\n\t\tif ((p = br_get_port(br, args[1])) == NULL)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = br_stp_set_path_cost(p, args[2]);\n\t\tspin_unlock_bh(&br->lock);\n\t\tbreak;\n\t}\n\n\tcase BRCTL_GET_FDB_ENTRIES:\n\t\treturn get_fdb_entries(br, argp, args[2], args[3]);\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\tif (!ret) {\n\t\tif (p)\n\t\t\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\t\telse\n\t\t\tnetdev_state_change(br->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int old_deviceless(struct net *net, void __user *data)\n{\n\tunsigned long args[3];\n\tvoid __user *argp;\n\tint ret;\n\n\tret = br_dev_read_uargs(args, ARRAY_SIZE(args), &argp, data);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (args[0]) {\n\tcase BRCTL_GET_VERSION:\n\t\treturn BRCTL_VERSION;\n\n\tcase BRCTL_GET_BRIDGES:\n\t{\n\t\tint *indices;\n\t\tint ret = 0;\n\n\t\tif (args[2] >= 2048)\n\t\t\treturn -ENOMEM;\n\t\tindices = kcalloc(args[2], sizeof(int), GFP_KERNEL);\n\t\tif (indices == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\targs[2] = get_bridge_ifindices(net, indices, args[2]);\n\n\t\tret = copy_to_user(argp, indices,\n\t\t\t\t   array_size(args[2], sizeof(int)))\n\t\t\t? -EFAULT : args[2];\n\n\t\tkfree(indices);\n\t\treturn ret;\n\t}\n\n\tcase BRCTL_ADD_BRIDGE:\n\tcase BRCTL_DEL_BRIDGE:\n\t{\n\t\tchar buf[IFNAMSIZ];\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(buf, argp, IFNAMSIZ))\n\t\t\treturn -EFAULT;\n\n\t\tbuf[IFNAMSIZ-1] = 0;\n\n\t\tif (args[0] == BRCTL_ADD_BRIDGE)\n\t\t\treturn br_add_bridge(net, buf);\n\n\t\treturn br_del_bridge(net, buf);\n\t}\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nint br_ioctl_stub(struct net *net, struct net_bridge *br, unsigned int cmd,\n\t\t  struct ifreq *ifr, void __user *uarg)\n{\n\tint ret = -EOPNOTSUPP;\n\n\trtnl_lock();\n\n\tswitch (cmd) {\n\tcase SIOCGIFBR:\n\tcase SIOCSIFBR:\n\t\tret = old_deviceless(net, uarg);\n\t\tbreak;\n\tcase SIOCBRADDBR:\n\tcase SIOCBRDELBR:\n\t{\n\t\tchar buf[IFNAMSIZ];\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(buf, uarg, IFNAMSIZ)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf[IFNAMSIZ-1] = 0;\n\t\tif (cmd == SIOCBRADDBR)\n\t\t\tret = br_add_bridge(net, buf);\n\t\telse\n\t\t\tret = br_del_bridge(net, buf);\n\t}\n\t\tbreak;\n\tcase SIOCBRADDIF:\n\tcase SIOCBRDELIF:\n\t\tret = add_del_if(br, ifr->ifr_ifindex, cmd == SIOCBRADDIF);\n\t\tbreak;\n\t}\n\n\trtnl_unlock();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}