{
  "module_name": "br_device.c",
  "hash_id": "f46720b0eb1a19e5a976e10ae4829e6a7417049dc9904ee50a2e3b3db80dc2dc",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_device.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/netpoll.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/list.h>\n#include <linux/netfilter_bridge.h>\n\n#include <linux/uaccess.h>\n#include \"br_private.h\"\n\n#define COMMON_FEATURES (NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA | \\\n\t\t\t NETIF_F_GSO_MASK | NETIF_F_HW_CSUM)\n\nconst struct nf_br_ops __rcu *nf_br_ops __read_mostly;\nEXPORT_SYMBOL_GPL(nf_br_ops);\n\n \nnetdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_bridge_mcast_port *pmctx_null = NULL;\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_mcast *brmctx = &br->multicast_ctx;\n\tstruct net_bridge_fdb_entry *dst;\n\tstruct net_bridge_mdb_entry *mdst;\n\tconst struct nf_br_ops *nf_ops;\n\tu8 state = BR_STATE_FORWARDING;\n\tstruct net_bridge_vlan *vlan;\n\tconst unsigned char *dest;\n\tu16 vid = 0;\n\n\tmemset(skb->cb, 0, sizeof(struct br_input_skb_cb));\n\tbr_tc_skb_miss_set(skb, false);\n\n\trcu_read_lock();\n\tnf_ops = rcu_dereference(nf_br_ops);\n\tif (nf_ops && nf_ops->br_dev_xmit_hook(skb)) {\n\t\trcu_read_unlock();\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tdev_sw_netstats_tx_add(dev, 1, skb->len);\n\n\tbr_switchdev_frame_unmark(skb);\n\tBR_INPUT_SKB_CB(skb)->brdev = dev;\n\tBR_INPUT_SKB_CB(skb)->frag_max_size = 0;\n\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, ETH_HLEN);\n\n\tif (!br_allowed_ingress(br, br_vlan_group_rcu(br), skb, &vid,\n\t\t\t\t&state, &vlan))\n\t\tgoto out;\n\n\tif (IS_ENABLED(CONFIG_INET) &&\n\t    (eth_hdr(skb)->h_proto == htons(ETH_P_ARP) ||\n\t     eth_hdr(skb)->h_proto == htons(ETH_P_RARP)) &&\n\t    br_opt_get(br, BROPT_NEIGH_SUPPRESS_ENABLED)) {\n\t\tbr_do_proxy_suppress_arp(skb, br, vid, NULL);\n\t} else if (IS_ENABLED(CONFIG_IPV6) &&\n\t\t   skb->protocol == htons(ETH_P_IPV6) &&\n\t\t   br_opt_get(br, BROPT_NEIGH_SUPPRESS_ENABLED) &&\n\t\t   pskb_may_pull(skb, sizeof(struct ipv6hdr) +\n\t\t\t\t sizeof(struct nd_msg)) &&\n\t\t   ipv6_hdr(skb)->nexthdr == IPPROTO_ICMPV6) {\n\t\t\tstruct nd_msg *msg, _msg;\n\n\t\t\tmsg = br_is_nd_neigh_msg(skb, &_msg);\n\t\t\tif (msg)\n\t\t\t\tbr_do_suppress_nd(skb, br, vid, NULL, msg);\n\t}\n\n\tdest = eth_hdr(skb)->h_dest;\n\tif (is_broadcast_ether_addr(dest)) {\n\t\tbr_flood(br, skb, BR_PKT_BROADCAST, false, true, vid);\n\t} else if (is_multicast_ether_addr(dest)) {\n\t\tif (unlikely(netpoll_tx_running(dev))) {\n\t\t\tbr_flood(br, skb, BR_PKT_MULTICAST, false, true, vid);\n\t\t\tgoto out;\n\t\t}\n\t\tif (br_multicast_rcv(&brmctx, &pmctx_null, vlan, skb, vid)) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmdst = br_mdb_get(brmctx, skb, vid);\n\t\tif ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &&\n\t\t    br_multicast_querier_exists(brmctx, eth_hdr(skb), mdst))\n\t\t\tbr_multicast_flood(mdst, skb, brmctx, false, true);\n\t\telse\n\t\t\tbr_flood(br, skb, BR_PKT_MULTICAST, false, true, vid);\n\t} else if ((dst = br_fdb_find_rcu(br, dest, vid)) != NULL) {\n\t\tbr_forward(dst->dst, skb, false, true);\n\t} else {\n\t\tbr_flood(br, skb, BR_PKT_UNICAST, false, true, vid);\n\t}\nout:\n\trcu_read_unlock();\n\treturn NETDEV_TX_OK;\n}\n\nstatic struct lock_class_key bridge_netdev_addr_lock_key;\n\nstatic void br_set_lockdep_class(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock, &bridge_netdev_addr_lock_key);\n}\n\nstatic int br_dev_init(struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tint err;\n\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\terr = br_fdb_hash_init(br);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\treturn err;\n\t}\n\n\terr = br_mdb_hash_init(br);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\tbr_fdb_hash_fini(br);\n\t\treturn err;\n\t}\n\n\terr = br_vlan_init(br);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\tbr_mdb_hash_fini(br);\n\t\tbr_fdb_hash_fini(br);\n\t\treturn err;\n\t}\n\n\terr = br_multicast_init_stats(br);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\tbr_vlan_flush(br);\n\t\tbr_mdb_hash_fini(br);\n\t\tbr_fdb_hash_fini(br);\n\t}\n\n\tbr_set_lockdep_class(dev);\n\treturn err;\n}\n\nstatic void br_dev_uninit(struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\tbr_multicast_dev_del(br);\n\tbr_multicast_uninit_stats(br);\n\tbr_vlan_flush(br);\n\tbr_mdb_hash_fini(br);\n\tbr_fdb_hash_fini(br);\n\tfree_percpu(dev->tstats);\n}\n\nstatic int br_dev_open(struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\tnetdev_update_features(dev);\n\tnetif_start_queue(dev);\n\tbr_stp_enable_bridge(br);\n\tbr_multicast_open(br);\n\n\tif (br_opt_get(br, BROPT_MULTICAST_ENABLED))\n\t\tbr_multicast_join_snoopers(br);\n\n\treturn 0;\n}\n\nstatic void br_dev_set_multicast_list(struct net_device *dev)\n{\n}\n\nstatic void br_dev_change_rx_flags(struct net_device *dev, int change)\n{\n\tif (change & IFF_PROMISC)\n\t\tbr_manage_promisc(netdev_priv(dev));\n}\n\nstatic int br_dev_stop(struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\tbr_stp_disable_bridge(br);\n\tbr_multicast_stop(br);\n\n\tif (br_opt_get(br, BROPT_MULTICAST_ENABLED))\n\t\tbr_multicast_leave_snoopers(br);\n\n\tnetif_stop_queue(dev);\n\n\treturn 0;\n}\n\nstatic int br_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\tdev->mtu = new_mtu;\n\n\t \n\tbr_opt_toggle(br, BROPT_MTU_SET_BY_USER, true);\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\t \n\tdst_metric_set(&br->fake_rtable.dst, RTAX_MTU, new_mtu);\n#endif\n\n\treturn 0;\n}\n\n \nstatic int br_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\tif (dev->reg_state != NETREG_REGISTERED)\n\t\treturn -EBUSY;\n\n\tspin_lock_bh(&br->lock);\n\tif (!ether_addr_equal(dev->dev_addr, addr->sa_data)) {\n\t\t \n\t\tbr_stp_change_bridge_id(br, addr->sa_data);\n\t}\n\tspin_unlock_bh(&br->lock);\n\n\treturn 0;\n}\n\nstatic void br_getinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, \"bridge\", sizeof(info->driver));\n\tstrscpy(info->version, BR_VERSION, sizeof(info->version));\n\tstrscpy(info->fw_version, \"N/A\", sizeof(info->fw_version));\n\tstrscpy(info->bus_info, \"N/A\", sizeof(info->bus_info));\n}\n\nstatic int br_get_link_ksettings(struct net_device *dev,\n\t\t\t\t struct ethtool_link_ksettings *cmd)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_port *p;\n\n\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\tcmd->base.port = PORT_OTHER;\n\tcmd->base.speed = SPEED_UNKNOWN;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tstruct ethtool_link_ksettings ecmd;\n\t\tstruct net_device *pdev = p->dev;\n\n\t\tif (!netif_running(pdev) || !netif_oper_up(pdev))\n\t\t\tcontinue;\n\n\t\tif (__ethtool_get_link_ksettings(pdev, &ecmd))\n\t\t\tcontinue;\n\n\t\tif (ecmd.base.speed == (__u32)SPEED_UNKNOWN)\n\t\t\tcontinue;\n\n\t\tif (cmd->base.speed == (__u32)SPEED_UNKNOWN ||\n\t\t    cmd->base.speed < ecmd.base.speed)\n\t\t\tcmd->base.speed = ecmd.base.speed;\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_features_t br_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\treturn br_features_recompute(br, features);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void br_poll_controller(struct net_device *br_dev)\n{\n}\n\nstatic void br_netpoll_cleanup(struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry(p, &br->port_list, list)\n\t\tbr_netpoll_disable(p);\n}\n\nstatic int __br_netpoll_enable(struct net_bridge_port *p)\n{\n\tstruct netpoll *np;\n\tint err;\n\n\tnp = kzalloc(sizeof(*p->np), GFP_KERNEL);\n\tif (!np)\n\t\treturn -ENOMEM;\n\n\terr = __netpoll_setup(np, p->dev);\n\tif (err) {\n\t\tkfree(np);\n\t\treturn err;\n\t}\n\n\tp->np = np;\n\treturn err;\n}\n\nint br_netpoll_enable(struct net_bridge_port *p)\n{\n\tif (!p->br->dev->npinfo)\n\t\treturn 0;\n\n\treturn __br_netpoll_enable(p);\n}\n\nstatic int br_netpoll_setup(struct net_device *dev, struct netpoll_info *ni)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_port *p;\n\tint err = 0;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (!p->dev)\n\t\t\tcontinue;\n\t\terr = __br_netpoll_enable(p);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\nout:\n\treturn err;\n\nfail:\n\tbr_netpoll_cleanup(dev);\n\tgoto out;\n}\n\nvoid br_netpoll_disable(struct net_bridge_port *p)\n{\n\tstruct netpoll *np = p->np;\n\n\tif (!np)\n\t\treturn;\n\n\tp->np = NULL;\n\n\t__netpoll_free(np);\n}\n\n#endif\n\nstatic int br_add_slave(struct net_device *dev, struct net_device *slave_dev,\n\t\t\tstruct netlink_ext_ack *extack)\n\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\treturn br_add_if(br, slave_dev, extack);\n}\n\nstatic int br_del_slave(struct net_device *dev, struct net_device *slave_dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\treturn br_del_if(br, slave_dev);\n}\n\nstatic int br_fill_forward_path(struct net_device_path_ctx *ctx,\n\t\t\t\tstruct net_device_path *path)\n{\n\tstruct net_bridge_fdb_entry *f;\n\tstruct net_bridge_port *dst;\n\tstruct net_bridge *br;\n\n\tif (netif_is_bridge_port(ctx->dev))\n\t\treturn -1;\n\n\tbr = netdev_priv(ctx->dev);\n\n\tbr_vlan_fill_forward_path_pvid(br, ctx, path);\n\n\tf = br_fdb_find_rcu(br, ctx->daddr, path->bridge.vlan_id);\n\tif (!f || !f->dst)\n\t\treturn -1;\n\n\tdst = READ_ONCE(f->dst);\n\tif (!dst)\n\t\treturn -1;\n\n\tif (br_vlan_fill_forward_path_mode(br, dst, path))\n\t\treturn -1;\n\n\tpath->type = DEV_PATH_BRIDGE;\n\tpath->dev = dst->br->dev;\n\tctx->dev = dst->dev;\n\n\tswitch (path->bridge.vlan_mode) {\n\tcase DEV_PATH_BR_VLAN_TAG:\n\t\tif (ctx->num_vlans >= ARRAY_SIZE(ctx->vlan))\n\t\t\treturn -ENOSPC;\n\t\tctx->vlan[ctx->num_vlans].id = path->bridge.vlan_id;\n\t\tctx->vlan[ctx->num_vlans].proto = path->bridge.vlan_proto;\n\t\tctx->num_vlans++;\n\t\tbreak;\n\tcase DEV_PATH_BR_VLAN_UNTAG_HW:\n\tcase DEV_PATH_BR_VLAN_UNTAG:\n\t\tctx->num_vlans--;\n\t\tbreak;\n\tcase DEV_PATH_BR_VLAN_KEEP:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops br_ethtool_ops = {\n\t.get_drvinfo\t\t = br_getinfo,\n\t.get_link\t\t = ethtool_op_get_link,\n\t.get_link_ksettings\t = br_get_link_ksettings,\n};\n\nstatic const struct net_device_ops br_netdev_ops = {\n\t.ndo_open\t\t = br_dev_open,\n\t.ndo_stop\t\t = br_dev_stop,\n\t.ndo_init\t\t = br_dev_init,\n\t.ndo_uninit\t\t = br_dev_uninit,\n\t.ndo_start_xmit\t\t = br_dev_xmit,\n\t.ndo_get_stats64\t = dev_get_tstats64,\n\t.ndo_set_mac_address\t = br_set_mac_address,\n\t.ndo_set_rx_mode\t = br_dev_set_multicast_list,\n\t.ndo_change_rx_flags\t = br_dev_change_rx_flags,\n\t.ndo_change_mtu\t\t = br_change_mtu,\n\t.ndo_siocdevprivate\t = br_dev_siocdevprivate,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_netpoll_setup\t = br_netpoll_setup,\n\t.ndo_netpoll_cleanup\t = br_netpoll_cleanup,\n\t.ndo_poll_controller\t = br_poll_controller,\n#endif\n\t.ndo_add_slave\t\t = br_add_slave,\n\t.ndo_del_slave\t\t = br_del_slave,\n\t.ndo_fix_features        = br_fix_features,\n\t.ndo_fdb_add\t\t = br_fdb_add,\n\t.ndo_fdb_del\t\t = br_fdb_delete,\n\t.ndo_fdb_del_bulk\t = br_fdb_delete_bulk,\n\t.ndo_fdb_dump\t\t = br_fdb_dump,\n\t.ndo_fdb_get\t\t = br_fdb_get,\n\t.ndo_mdb_add\t\t = br_mdb_add,\n\t.ndo_mdb_del\t\t = br_mdb_del,\n\t.ndo_mdb_dump\t\t = br_mdb_dump,\n\t.ndo_bridge_getlink\t = br_getlink,\n\t.ndo_bridge_setlink\t = br_setlink,\n\t.ndo_bridge_dellink\t = br_dellink,\n\t.ndo_features_check\t = passthru_features_check,\n\t.ndo_fill_forward_path\t = br_fill_forward_path,\n};\n\nstatic struct device_type br_type = {\n\t.name\t= \"bridge\",\n};\n\nvoid br_dev_setup(struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\teth_hw_addr_random(dev);\n\tether_setup(dev);\n\n\tdev->netdev_ops = &br_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev->ethtool_ops = &br_ethtool_ops;\n\tSET_NETDEV_DEVTYPE(dev, &br_type);\n\tdev->priv_flags = IFF_EBRIDGE | IFF_NO_QUEUE;\n\n\tdev->features = COMMON_FEATURES | NETIF_F_LLTX | NETIF_F_NETNS_LOCAL |\n\t\t\tNETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX;\n\tdev->hw_features = COMMON_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\tdev->vlan_features = COMMON_FEATURES;\n\n\tbr->dev = dev;\n\tspin_lock_init(&br->lock);\n\tINIT_LIST_HEAD(&br->port_list);\n\tINIT_HLIST_HEAD(&br->fdb_list);\n\tINIT_HLIST_HEAD(&br->frame_type_list);\n#if IS_ENABLED(CONFIG_BRIDGE_MRP)\n\tINIT_HLIST_HEAD(&br->mrp_list);\n#endif\n#if IS_ENABLED(CONFIG_BRIDGE_CFM)\n\tINIT_HLIST_HEAD(&br->mep_list);\n#endif\n\tspin_lock_init(&br->hash_lock);\n\n\tbr->bridge_id.prio[0] = 0x80;\n\tbr->bridge_id.prio[1] = 0x00;\n\n\tether_addr_copy(br->group_addr, eth_stp_addr);\n\n\tbr->stp_enabled = BR_NO_STP;\n\tbr->group_fwd_mask = BR_GROUPFWD_DEFAULT;\n\tbr->group_fwd_mask_required = BR_GROUPFWD_DEFAULT;\n\n\tbr->designated_root = br->bridge_id;\n\tbr->bridge_max_age = br->max_age = 20 * HZ;\n\tbr->bridge_hello_time = br->hello_time = 2 * HZ;\n\tbr->bridge_forward_delay = br->forward_delay = 15 * HZ;\n\tbr->bridge_ageing_time = br->ageing_time = BR_DEFAULT_AGEING_TIME;\n\tdev->max_mtu = ETH_MAX_MTU;\n\n\tbr_netfilter_rtable_init(br);\n\tbr_stp_timer_init(br);\n\tbr_multicast_init(br);\n\tINIT_DELAYED_WORK(&br->gc_work, br_fdb_cleanup);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}