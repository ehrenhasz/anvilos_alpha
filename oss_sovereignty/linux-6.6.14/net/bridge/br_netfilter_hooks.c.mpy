{
  "module_name": "br_netfilter_hooks.c",
  "hash_id": "70c1880e41ccdfae8efe15a17676e6ad0747a6c890e5c77d8d186e549ef8231f",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_netfilter_hooks.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/ip.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp_defs.h>\n#include <linux/netfilter_bridge.h>\n#include <uapi/linux/netfilter_bridge.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_arp.h>\n#include <linux/in_route.h>\n#include <linux/rculist.h>\n#include <linux/inetdevice.h>\n\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <net/route.h>\n#include <net/netfilter/br_netfilter.h>\n#include <net/netns/generic.h>\n\n#include <linux/uaccess.h>\n#include \"br_private.h\"\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\nstatic unsigned int brnf_net_id __read_mostly;\n\nstruct brnf_net {\n\tbool enabled;\n\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table_header *ctl_hdr;\n#endif\n\n\t \n\tint call_iptables;\n\tint call_ip6tables;\n\tint call_arptables;\n\n\t \n\tint filter_vlan_tagged;\n\tint filter_pppoe_tagged;\n\tint pass_vlan_indev;\n};\n\n#define IS_IP(skb) \\\n\t(!skb_vlan_tag_present(skb) && skb->protocol == htons(ETH_P_IP))\n\n#define IS_IPV6(skb) \\\n\t(!skb_vlan_tag_present(skb) && skb->protocol == htons(ETH_P_IPV6))\n\n#define IS_ARP(skb) \\\n\t(!skb_vlan_tag_present(skb) && skb->protocol == htons(ETH_P_ARP))\n\nstatic inline __be16 vlan_proto(const struct sk_buff *skb)\n{\n\tif (skb_vlan_tag_present(skb))\n\t\treturn skb->protocol;\n\telse if (skb->protocol == htons(ETH_P_8021Q))\n\t\treturn vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;\n\telse\n\t\treturn 0;\n}\n\nstatic inline bool is_vlan_ip(const struct sk_buff *skb, const struct net *net)\n{\n\tstruct brnf_net *brnet = net_generic(net, brnf_net_id);\n\n\treturn vlan_proto(skb) == htons(ETH_P_IP) && brnet->filter_vlan_tagged;\n}\n\nstatic inline bool is_vlan_ipv6(const struct sk_buff *skb,\n\t\t\t\tconst struct net *net)\n{\n\tstruct brnf_net *brnet = net_generic(net, brnf_net_id);\n\n\treturn vlan_proto(skb) == htons(ETH_P_IPV6) &&\n\t       brnet->filter_vlan_tagged;\n}\n\nstatic inline bool is_vlan_arp(const struct sk_buff *skb, const struct net *net)\n{\n\tstruct brnf_net *brnet = net_generic(net, brnf_net_id);\n\n\treturn vlan_proto(skb) == htons(ETH_P_ARP) && brnet->filter_vlan_tagged;\n}\n\nstatic inline __be16 pppoe_proto(const struct sk_buff *skb)\n{\n\treturn *((__be16 *)(skb_mac_header(skb) + ETH_HLEN +\n\t\t\t    sizeof(struct pppoe_hdr)));\n}\n\nstatic inline bool is_pppoe_ip(const struct sk_buff *skb, const struct net *net)\n{\n\tstruct brnf_net *brnet = net_generic(net, brnf_net_id);\n\n\treturn skb->protocol == htons(ETH_P_PPP_SES) &&\n\t       pppoe_proto(skb) == htons(PPP_IP) && brnet->filter_pppoe_tagged;\n}\n\nstatic inline bool is_pppoe_ipv6(const struct sk_buff *skb,\n\t\t\t\t const struct net *net)\n{\n\tstruct brnf_net *brnet = net_generic(net, brnf_net_id);\n\n\treturn skb->protocol == htons(ETH_P_PPP_SES) &&\n\t       pppoe_proto(skb) == htons(PPP_IPV6) &&\n\t       brnet->filter_pppoe_tagged;\n}\n\n \n#define NF_BRIDGE_MAX_MAC_HEADER_LENGTH (PPPOE_SES_HLEN + ETH_HLEN)\n\nstruct brnf_frag_data {\n\tchar mac[NF_BRIDGE_MAX_MAC_HEADER_LENGTH];\n\tu8 encap_size;\n\tu8 size;\n\tu16 vlan_tci;\n\t__be16 vlan_proto;\n};\n\nstatic DEFINE_PER_CPU(struct brnf_frag_data, brnf_frag_data_storage);\n\nstatic void nf_bridge_info_free(struct sk_buff *skb)\n{\n\tskb_ext_del(skb, SKB_EXT_BRIDGE_NF);\n}\n\nstatic inline struct net_device *bridge_parent(const struct net_device *dev)\n{\n\tstruct net_bridge_port *port;\n\n\tport = br_port_get_rcu(dev);\n\treturn port ? port->br->dev : NULL;\n}\n\nstatic inline struct nf_bridge_info *nf_bridge_unshare(struct sk_buff *skb)\n{\n\treturn skb_ext_add(skb, SKB_EXT_BRIDGE_NF);\n}\n\nunsigned int nf_bridge_encap_header_len(const struct sk_buff *skb)\n{\n\tswitch (skb->protocol) {\n\tcase __cpu_to_be16(ETH_P_8021Q):\n\t\treturn VLAN_HLEN;\n\tcase __cpu_to_be16(ETH_P_PPP_SES):\n\t\treturn PPPOE_SES_HLEN;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline void nf_bridge_pull_encap_header(struct sk_buff *skb)\n{\n\tunsigned int len = nf_bridge_encap_header_len(skb);\n\n\tskb_pull(skb, len);\n\tskb->network_header += len;\n}\n\nstatic inline void nf_bridge_pull_encap_header_rcsum(struct sk_buff *skb)\n{\n\tunsigned int len = nf_bridge_encap_header_len(skb);\n\n\tskb_pull_rcsum(skb, len);\n\tskb->network_header += len;\n}\n\n \n\nstatic int br_validate_ipv4(struct net *net, struct sk_buff *skb)\n{\n\tconst struct iphdr *iph;\n\tu32 len;\n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\n\t \n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto csum_error;\n\n\tlen = skb_ip_totlen(skb);\n\tif (skb->len < len) {\n\t\t__IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\t__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t \n\treturn 0;\n\ncsum_error:\n\t__IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS);\ninhdr_error:\n\t__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}\n\nvoid nf_bridge_update_protocol(struct sk_buff *skb)\n{\n\tconst struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\n\tswitch (nf_bridge->orig_proto) {\n\tcase BRNF_PROTO_8021Q:\n\t\tskb->protocol = htons(ETH_P_8021Q);\n\t\tbreak;\n\tcase BRNF_PROTO_PPPOE:\n\t\tskb->protocol = htons(ETH_P_PPP_SES);\n\t\tbreak;\n\tcase BRNF_PROTO_UNCHANGED:\n\t\tbreak;\n\t}\n}\n\n \nint br_nf_pre_routing_finish_bridge(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct neighbour *neigh;\n\tstruct dst_entry *dst;\n\n\tskb->dev = bridge_parent(skb->dev);\n\tif (!skb->dev)\n\t\tgoto free_skb;\n\tdst = skb_dst(skb);\n\tneigh = dst_neigh_lookup_skb(dst, skb);\n\tif (neigh) {\n\t\tstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\t\tint ret;\n\n\t\tif ((READ_ONCE(neigh->nud_state) & NUD_CONNECTED) &&\n\t\t    READ_ONCE(neigh->hh.hh_len)) {\n\t\t\tstruct net_device *br_indev;\n\n\t\t\tbr_indev = nf_bridge_get_physindev(skb, net);\n\t\t\tif (!br_indev) {\n\t\t\t\tneigh_release(neigh);\n\t\t\t\tgoto free_skb;\n\t\t\t}\n\n\t\t\tneigh_hh_bridge(&neigh->hh, skb);\n\t\t\tskb->dev = br_indev;\n\n\t\t\tret = br_handle_frame_finish(net, sk, skb);\n\t\t} else {\n\t\t\t \n\t\t\tskb_copy_from_linear_data_offset(skb,\n\t\t\t\t\t\t\t -(ETH_HLEN-ETH_ALEN),\n\t\t\t\t\t\t\t nf_bridge->neigh_header,\n\t\t\t\t\t\t\t ETH_HLEN-ETH_ALEN);\n\t\t\t \n\t\t\tnf_bridge->bridged_dnat = 1;\n\t\t\t \n\t\t\tret = READ_ONCE(neigh->output)(neigh, skb);\n\t\t}\n\t\tneigh_release(neigh);\n\t\treturn ret;\n\t}\nfree_skb:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic inline bool\nbr_nf_ipv4_daddr_was_changed(const struct sk_buff *skb,\n\t\t\t     const struct nf_bridge_info *nf_bridge)\n{\n\treturn ip_hdr(skb)->daddr != nf_bridge->ipv4_daddr;\n}\n\n \nstatic int br_nf_pre_routing_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev, *br_indev;\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\tstruct rtable *rt;\n\tint err;\n\n\tbr_indev = nf_bridge_get_physindev(skb, net);\n\tif (!br_indev) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tnf_bridge->frag_max_size = IPCB(skb)->frag_max_size;\n\n\tif (nf_bridge->pkt_otherhost) {\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tnf_bridge->pkt_otherhost = false;\n\t}\n\tnf_bridge->in_prerouting = 0;\n\tif (br_nf_ipv4_daddr_was_changed(skb, nf_bridge)) {\n\t\tif ((err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))) {\n\t\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\n\t\t\t \n\t\t\tif (err != -EHOSTUNREACH || !in_dev || IN_DEV_FORWARD(in_dev))\n\t\t\t\tgoto free_skb;\n\n\t\t\trt = ip_route_output(net, iph->daddr, 0,\n\t\t\t\t\t     RT_TOS(iph->tos), 0);\n\t\t\tif (!IS_ERR(rt)) {\n\t\t\t\t \n\t\t\t\tif (rt->dst.dev == dev) {\n\t\t\t\t\tskb_dst_drop(skb);\n\t\t\t\t\tskb_dst_set(skb, &rt->dst);\n\t\t\t\t\tgoto bridged_dnat;\n\t\t\t\t}\n\t\t\t\tip_rt_put(rt);\n\t\t\t}\nfree_skb:\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (skb_dst(skb)->dev == dev) {\nbridged_dnat:\n\t\t\t\tskb->dev = br_indev;\n\t\t\t\tnf_bridge_update_protocol(skb);\n\t\t\t\tnf_bridge_push_encap_header(skb);\n\t\t\t\tbr_nf_hook_thresh(NF_BR_PRE_ROUTING,\n\t\t\t\t\t\t  net, sk, skb, skb->dev,\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  br_nf_pre_routing_finish_bridge);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tether_addr_copy(eth_hdr(skb)->h_dest, dev->dev_addr);\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t}\n\t} else {\n\t\trt = bridge_parent_rtable(br_indev);\n\t\tif (!rt) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tskb_dst_drop(skb);\n\t\tskb_dst_set_noref(skb, &rt->dst);\n\t}\n\n\tskb->dev = br_indev;\n\tnf_bridge_update_protocol(skb);\n\tnf_bridge_push_encap_header(skb);\n\tbr_nf_hook_thresh(NF_BR_PRE_ROUTING, net, sk, skb, skb->dev, NULL,\n\t\t\t  br_handle_frame_finish);\n\treturn 0;\n}\n\nstatic struct net_device *brnf_get_logical_dev(struct sk_buff *skb,\n\t\t\t\t\t       const struct net_device *dev,\n\t\t\t\t\t       const struct net *net)\n{\n\tstruct net_device *vlan, *br;\n\tstruct brnf_net *brnet = net_generic(net, brnf_net_id);\n\n\tbr = bridge_parent(dev);\n\n\tif (brnet->pass_vlan_indev == 0 || !skb_vlan_tag_present(skb))\n\t\treturn br;\n\n\tvlan = __vlan_find_dev_deep_rcu(br, skb->vlan_proto,\n\t\t\t\t    skb_vlan_tag_get(skb) & VLAN_VID_MASK);\n\n\treturn vlan ? vlan : br;\n}\n\n \nstruct net_device *setup_pre_routing(struct sk_buff *skb, const struct net *net)\n{\n\tstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tnf_bridge->pkt_otherhost = true;\n\t}\n\n\tnf_bridge->in_prerouting = 1;\n\tnf_bridge->physinif = skb->dev->ifindex;\n\tskb->dev = brnf_get_logical_dev(skb, skb->dev, net);\n\n\tif (skb->protocol == htons(ETH_P_8021Q))\n\t\tnf_bridge->orig_proto = BRNF_PROTO_8021Q;\n\telse if (skb->protocol == htons(ETH_P_PPP_SES))\n\t\tnf_bridge->orig_proto = BRNF_PROTO_PPPOE;\n\n\t \n\tskb_orphan(skb);\n\treturn skb->dev;\n}\n\n \nstatic unsigned int br_nf_pre_routing(void *priv,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const struct nf_hook_state *state)\n{\n\tstruct nf_bridge_info *nf_bridge;\n\tstruct net_bridge_port *p;\n\tstruct net_bridge *br;\n\t__u32 len = nf_bridge_encap_header_len(skb);\n\tstruct brnf_net *brnet;\n\n\tif (unlikely(!pskb_may_pull(skb, len)))\n\t\treturn NF_DROP;\n\n\tp = br_port_get_rcu(state->in);\n\tif (p == NULL)\n\t\treturn NF_DROP;\n\tbr = p->br;\n\n\tbrnet = net_generic(state->net, brnf_net_id);\n\tif (IS_IPV6(skb) || is_vlan_ipv6(skb, state->net) ||\n\t    is_pppoe_ipv6(skb, state->net)) {\n\t\tif (!brnet->call_ip6tables &&\n\t\t    !br_opt_get(br, BROPT_NF_CALL_IP6TABLES))\n\t\t\treturn NF_ACCEPT;\n\t\tif (!ipv6_mod_enabled()) {\n\t\t\tpr_warn_once(\"Module ipv6 is disabled, so call_ip6tables is not supported.\");\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\tnf_bridge_pull_encap_header_rcsum(skb);\n\t\treturn br_nf_pre_routing_ipv6(priv, skb, state);\n\t}\n\n\tif (!brnet->call_iptables && !br_opt_get(br, BROPT_NF_CALL_IPTABLES))\n\t\treturn NF_ACCEPT;\n\n\tif (!IS_IP(skb) && !is_vlan_ip(skb, state->net) &&\n\t    !is_pppoe_ip(skb, state->net))\n\t\treturn NF_ACCEPT;\n\n\tnf_bridge_pull_encap_header_rcsum(skb);\n\n\tif (br_validate_ipv4(state->net, skb))\n\t\treturn NF_DROP;\n\n\tif (!nf_bridge_alloc(skb))\n\t\treturn NF_DROP;\n\tif (!setup_pre_routing(skb, state->net))\n\t\treturn NF_DROP;\n\n\tnf_bridge = nf_bridge_info_get(skb);\n\tnf_bridge->ipv4_daddr = ip_hdr(skb)->daddr;\n\n\tskb->protocol = htons(ETH_P_IP);\n\tskb->transport_header = skb->network_header + ip_hdr(skb)->ihl * 4;\n\n\tNF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, state->net, state->sk, skb,\n\t\tskb->dev, NULL,\n\t\tbr_nf_pre_routing_finish);\n\n\treturn NF_STOLEN;\n}\n\n\n \nstatic int br_nf_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\tstruct net_device *in;\n\n\tif (!IS_ARP(skb) && !is_vlan_arp(skb, net)) {\n\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tnf_bridge->frag_max_size = IPCB(skb)->frag_max_size;\n\n\t\tif (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tnf_bridge->frag_max_size = IP6CB(skb)->frag_max_size;\n\n\t\tin = nf_bridge_get_physindev(skb, net);\n\t\tif (!in) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tif (nf_bridge->pkt_otherhost) {\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t\tnf_bridge->pkt_otherhost = false;\n\t\t}\n\t\tnf_bridge_update_protocol(skb);\n\t} else {\n\t\tin = *((struct net_device **)(skb->cb));\n\t}\n\tnf_bridge_push_encap_header(skb);\n\n\tbr_nf_hook_thresh(NF_BR_FORWARD, net, sk, skb, in, skb->dev,\n\t\t\t  br_forward_finish);\n\treturn 0;\n}\n\n\n \nstatic unsigned int br_nf_forward_ip(void *priv,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     const struct nf_hook_state *state)\n{\n\tstruct nf_bridge_info *nf_bridge;\n\tstruct net_device *parent;\n\tu_int8_t pf;\n\n\tnf_bridge = nf_bridge_info_get(skb);\n\tif (!nf_bridge)\n\t\treturn NF_ACCEPT;\n\n\t \n\tif (!nf_bridge_unshare(skb))\n\t\treturn NF_DROP;\n\n\tnf_bridge = nf_bridge_info_get(skb);\n\tif (!nf_bridge)\n\t\treturn NF_DROP;\n\n\tparent = bridge_parent(state->out);\n\tif (!parent)\n\t\treturn NF_DROP;\n\n\tif (IS_IP(skb) || is_vlan_ip(skb, state->net) ||\n\t    is_pppoe_ip(skb, state->net))\n\t\tpf = NFPROTO_IPV4;\n\telse if (IS_IPV6(skb) || is_vlan_ipv6(skb, state->net) ||\n\t\t is_pppoe_ipv6(skb, state->net))\n\t\tpf = NFPROTO_IPV6;\n\telse\n\t\treturn NF_ACCEPT;\n\n\tnf_bridge_pull_encap_header(skb);\n\n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tnf_bridge->pkt_otherhost = true;\n\t}\n\n\tif (pf == NFPROTO_IPV4) {\n\t\tif (br_validate_ipv4(state->net, skb))\n\t\t\treturn NF_DROP;\n\t\tIPCB(skb)->frag_max_size = nf_bridge->frag_max_size;\n\t}\n\n\tif (pf == NFPROTO_IPV6) {\n\t\tif (br_validate_ipv6(state->net, skb))\n\t\t\treturn NF_DROP;\n\t\tIP6CB(skb)->frag_max_size = nf_bridge->frag_max_size;\n\t}\n\n\tnf_bridge->physoutdev = skb->dev;\n\tif (pf == NFPROTO_IPV4)\n\t\tskb->protocol = htons(ETH_P_IP);\n\telse\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\tNF_HOOK(pf, NF_INET_FORWARD, state->net, NULL, skb,\n\t\tbrnf_get_logical_dev(skb, state->in, state->net),\n\t\tparent,\tbr_nf_forward_finish);\n\n\treturn NF_STOLEN;\n}\n\nstatic unsigned int br_nf_forward_arp(void *priv,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const struct nf_hook_state *state)\n{\n\tstruct net_bridge_port *p;\n\tstruct net_bridge *br;\n\tstruct net_device **d = (struct net_device **)(skb->cb);\n\tstruct brnf_net *brnet;\n\n\tp = br_port_get_rcu(state->out);\n\tif (p == NULL)\n\t\treturn NF_ACCEPT;\n\tbr = p->br;\n\n\tbrnet = net_generic(state->net, brnf_net_id);\n\tif (!brnet->call_arptables && !br_opt_get(br, BROPT_NF_CALL_ARPTABLES))\n\t\treturn NF_ACCEPT;\n\n\tif (!IS_ARP(skb)) {\n\t\tif (!is_vlan_arp(skb, state->net))\n\t\t\treturn NF_ACCEPT;\n\t\tnf_bridge_pull_encap_header(skb);\n\t}\n\n\tif (unlikely(!pskb_may_pull(skb, sizeof(struct arphdr))))\n\t\treturn NF_DROP;\n\n\tif (arp_hdr(skb)->ar_pln != 4) {\n\t\tif (is_vlan_arp(skb, state->net))\n\t\t\tnf_bridge_push_encap_header(skb);\n\t\treturn NF_ACCEPT;\n\t}\n\t*d = state->in;\n\tNF_HOOK(NFPROTO_ARP, NF_ARP_FORWARD, state->net, state->sk, skb,\n\t\tstate->in, state->out, br_nf_forward_finish);\n\n\treturn NF_STOLEN;\n}\n\nstatic int br_nf_push_frag_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct brnf_frag_data *data;\n\tint err;\n\n\tdata = this_cpu_ptr(&brnf_frag_data_storage);\n\terr = skb_cow_head(skb, data->size);\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (data->vlan_proto)\n\t\t__vlan_hwaccel_put_tag(skb, data->vlan_proto, data->vlan_tci);\n\n\tskb_copy_to_linear_data_offset(skb, -data->size, data->mac, data->size);\n\t__skb_push(skb, data->encap_size);\n\n\tnf_bridge_info_free(skb);\n\treturn br_dev_queue_push_xmit(net, sk, skb);\n}\n\nstatic int\nbr_nf_ip_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,\n\t\t  int (*output)(struct net *, struct sock *, struct sk_buff *))\n{\n\tunsigned int mtu = ip_skb_dst_mtu(sk, skb);\n\tstruct iphdr *iph = ip_hdr(skb);\n\n\tif (unlikely(((iph->frag_off & htons(IP_DF)) && !skb->ignore_df) ||\n\t\t     (IPCB(skb)->frag_max_size &&\n\t\t      IPCB(skb)->frag_max_size > mtu))) {\n\t\tIP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\treturn ip_do_fragment(net, sk, skb, output);\n}\n\nstatic unsigned int nf_bridge_mtu_reduction(const struct sk_buff *skb)\n{\n\tconst struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\n\tif (nf_bridge->orig_proto == BRNF_PROTO_PPPOE)\n\t\treturn PPPOE_SES_HLEN;\n\treturn 0;\n}\n\nstatic int br_nf_dev_queue_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\tunsigned int mtu, mtu_reserved;\n\n\tmtu_reserved = nf_bridge_mtu_reduction(skb);\n\tmtu = skb->dev->mtu;\n\n\tif (nf_bridge->pkt_otherhost) {\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tnf_bridge->pkt_otherhost = false;\n\t}\n\n\tif (nf_bridge->frag_max_size && nf_bridge->frag_max_size < mtu)\n\t\tmtu = nf_bridge->frag_max_size;\n\n\tnf_bridge_update_protocol(skb);\n\tnf_bridge_push_encap_header(skb);\n\n\tif (skb_is_gso(skb) || skb->len + mtu_reserved <= mtu) {\n\t\tnf_bridge_info_free(skb);\n\t\treturn br_dev_queue_push_xmit(net, sk, skb);\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_NF_DEFRAG_IPV4) &&\n\t    skb->protocol == htons(ETH_P_IP)) {\n\t\tstruct brnf_frag_data *data;\n\n\t\tif (br_validate_ipv4(net, skb))\n\t\t\tgoto drop;\n\n\t\tIPCB(skb)->frag_max_size = nf_bridge->frag_max_size;\n\n\t\tdata = this_cpu_ptr(&brnf_frag_data_storage);\n\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\tdata->vlan_tci = skb->vlan_tci;\n\t\t\tdata->vlan_proto = skb->vlan_proto;\n\t\t} else {\n\t\t\tdata->vlan_proto = 0;\n\t\t}\n\n\t\tdata->encap_size = nf_bridge_encap_header_len(skb);\n\t\tdata->size = ETH_HLEN + data->encap_size;\n\n\t\tskb_copy_from_linear_data_offset(skb, -data->size, data->mac,\n\t\t\t\t\t\t data->size);\n\n\t\treturn br_nf_ip_fragment(net, sk, skb, br_nf_push_frag_xmit);\n\t}\n\tif (IS_ENABLED(CONFIG_NF_DEFRAG_IPV6) &&\n\t    skb->protocol == htons(ETH_P_IPV6)) {\n\t\tconst struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();\n\t\tstruct brnf_frag_data *data;\n\n\t\tif (br_validate_ipv6(net, skb))\n\t\t\tgoto drop;\n\n\t\tIP6CB(skb)->frag_max_size = nf_bridge->frag_max_size;\n\n\t\tdata = this_cpu_ptr(&brnf_frag_data_storage);\n\t\tdata->encap_size = nf_bridge_encap_header_len(skb);\n\t\tdata->size = ETH_HLEN + data->encap_size;\n\n\t\tskb_copy_from_linear_data_offset(skb, -data->size, data->mac,\n\t\t\t\t\t\t data->size);\n\n\t\tif (v6ops)\n\t\t\treturn v6ops->fragment(net, sk, skb, br_nf_push_frag_xmit);\n\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\tnf_bridge_info_free(skb);\n\treturn br_dev_queue_push_xmit(net, sk, skb);\n drop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \nstatic unsigned int br_nf_post_routing(void *priv,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       const struct nf_hook_state *state)\n{\n\tstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\tstruct net_device *realoutdev = bridge_parent(skb->dev);\n\tu_int8_t pf;\n\n\t \n\tif (!nf_bridge || !nf_bridge->physoutdev)\n\t\treturn NF_ACCEPT;\n\n\tif (!realoutdev)\n\t\treturn NF_DROP;\n\n\tif (IS_IP(skb) || is_vlan_ip(skb, state->net) ||\n\t    is_pppoe_ip(skb, state->net))\n\t\tpf = NFPROTO_IPV4;\n\telse if (IS_IPV6(skb) || is_vlan_ipv6(skb, state->net) ||\n\t\t is_pppoe_ipv6(skb, state->net))\n\t\tpf = NFPROTO_IPV6;\n\telse\n\t\treturn NF_ACCEPT;\n\n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tnf_bridge->pkt_otherhost = true;\n\t}\n\n\tnf_bridge_pull_encap_header(skb);\n\tif (pf == NFPROTO_IPV4)\n\t\tskb->protocol = htons(ETH_P_IP);\n\telse\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\tNF_HOOK(pf, NF_INET_POST_ROUTING, state->net, state->sk, skb,\n\t\tNULL, realoutdev,\n\t\tbr_nf_dev_queue_xmit);\n\n\treturn NF_STOLEN;\n}\n\n \n \nstatic unsigned int ip_sabotage_in(void *priv,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   const struct nf_hook_state *state)\n{\n\tstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\n\tif (nf_bridge) {\n\t\tif (nf_bridge->sabotage_in_done)\n\t\t\treturn NF_ACCEPT;\n\n\t\tif (!nf_bridge->in_prerouting &&\n\t\t    !netif_is_l3_master(skb->dev) &&\n\t\t    !netif_is_l3_slave(skb->dev)) {\n\t\t\tnf_bridge->sabotage_in_done = 1;\n\t\t\tstate->okfn(state->net, state->sk, skb);\n\t\t\treturn NF_STOLEN;\n\t\t}\n\t}\n\n\treturn NF_ACCEPT;\n}\n\n \nstatic void br_nf_pre_routing_finish_bridge_slow(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\tstruct net_device *br_indev;\n\n\tbr_indev = nf_bridge_get_physindev(skb, dev_net(skb->dev));\n\tif (!br_indev) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tskb_pull(skb, ETH_HLEN);\n\tnf_bridge->bridged_dnat = 0;\n\n\tBUILD_BUG_ON(sizeof(nf_bridge->neigh_header) != (ETH_HLEN - ETH_ALEN));\n\n\tskb_copy_to_linear_data_offset(skb, -(ETH_HLEN - ETH_ALEN),\n\t\t\t\t       nf_bridge->neigh_header,\n\t\t\t\t       ETH_HLEN - ETH_ALEN);\n\tskb->dev = br_indev;\n\n\tnf_bridge->physoutdev = NULL;\n\tbr_handle_frame_finish(dev_net(skb->dev), NULL, skb);\n}\n\nstatic int br_nf_dev_xmit(struct sk_buff *skb)\n{\n\tconst struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\n\tif (nf_bridge && nf_bridge->bridged_dnat) {\n\t\tbr_nf_pre_routing_finish_bridge_slow(skb);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const struct nf_br_ops br_ops = {\n\t.br_dev_xmit_hook =\tbr_nf_dev_xmit,\n};\n\n \nstatic const struct nf_hook_ops br_nf_ops[] = {\n\t{\n\t\t.hook = br_nf_pre_routing,\n\t\t.pf = NFPROTO_BRIDGE,\n\t\t.hooknum = NF_BR_PRE_ROUTING,\n\t\t.priority = NF_BR_PRI_BRNF,\n\t},\n\t{\n\t\t.hook = br_nf_forward_ip,\n\t\t.pf = NFPROTO_BRIDGE,\n\t\t.hooknum = NF_BR_FORWARD,\n\t\t.priority = NF_BR_PRI_BRNF - 1,\n\t},\n\t{\n\t\t.hook = br_nf_forward_arp,\n\t\t.pf = NFPROTO_BRIDGE,\n\t\t.hooknum = NF_BR_FORWARD,\n\t\t.priority = NF_BR_PRI_BRNF,\n\t},\n\t{\n\t\t.hook = br_nf_post_routing,\n\t\t.pf = NFPROTO_BRIDGE,\n\t\t.hooknum = NF_BR_POST_ROUTING,\n\t\t.priority = NF_BR_PRI_LAST,\n\t},\n\t{\n\t\t.hook = ip_sabotage_in,\n\t\t.pf = NFPROTO_IPV4,\n\t\t.hooknum = NF_INET_PRE_ROUTING,\n\t\t.priority = NF_IP_PRI_FIRST,\n\t},\n\t{\n\t\t.hook = ip_sabotage_in,\n\t\t.pf = NFPROTO_IPV6,\n\t\t.hooknum = NF_INET_PRE_ROUTING,\n\t\t.priority = NF_IP6_PRI_FIRST,\n\t},\n};\n\nstatic int brnf_device_event(struct notifier_block *unused, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct brnf_net *brnet;\n\tstruct net *net;\n\tint ret;\n\n\tif (event != NETDEV_REGISTER || !netif_is_bridge_master(dev))\n\t\treturn NOTIFY_DONE;\n\n\tASSERT_RTNL();\n\n\tnet = dev_net(dev);\n\tbrnet = net_generic(net, brnf_net_id);\n\tif (brnet->enabled)\n\t\treturn NOTIFY_OK;\n\n\tret = nf_register_net_hooks(net, br_nf_ops, ARRAY_SIZE(br_nf_ops));\n\tif (ret)\n\t\treturn NOTIFY_BAD;\n\n\tbrnet->enabled = true;\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block brnf_notifier __read_mostly = {\n\t.notifier_call = brnf_device_event,\n};\n\n \nint br_nf_hook_thresh(unsigned int hook, struct net *net,\n\t\t      struct sock *sk, struct sk_buff *skb,\n\t\t      struct net_device *indev,\n\t\t      struct net_device *outdev,\n\t\t      int (*okfn)(struct net *, struct sock *,\n\t\t\t\t  struct sk_buff *))\n{\n\tconst struct nf_hook_entries *e;\n\tstruct nf_hook_state state;\n\tstruct nf_hook_ops **ops;\n\tunsigned int i;\n\tint ret;\n\n\te = rcu_dereference(net->nf.hooks_bridge[hook]);\n\tif (!e)\n\t\treturn okfn(net, sk, skb);\n\n\tops = nf_hook_entries_get_hook_ops(e);\n\tfor (i = 0; i < e->num_hook_entries; i++) {\n\t\t \n\t\tif (ops[i]->priority < NF_BR_PRI_BRNF)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ops[i]->priority > NF_BR_PRI_BRNF)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ops[i]->hook == br_nf_pre_routing) {\n\t\t\t \n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnf_hook_state_init(&state, hook, NFPROTO_BRIDGE, indev, outdev,\n\t\t\t   sk, net, okfn);\n\n\tret = nf_hook_slow(skb, &state, e, i);\n\tif (ret == 1)\n\t\tret = okfn(net, sk, skb);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_SYSCTL\nstatic\nint brnf_sysctl_call_tables(struct ctl_table *ctl, int write,\n\t\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write && *(int *)(ctl->data))\n\t\t*(int *)(ctl->data) = 1;\n\treturn ret;\n}\n\nstatic struct ctl_table brnf_table[] = {\n\t{\n\t\t.procname\t= \"bridge-nf-call-arptables\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-call-iptables\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-call-ip6tables\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-filter-vlan-tagged\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-filter-pppoe-tagged\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-pass-vlan-input-dev\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{ }\n};\n\nstatic inline void br_netfilter_sysctl_default(struct brnf_net *brnf)\n{\n\tbrnf->call_iptables = 1;\n\tbrnf->call_ip6tables = 1;\n\tbrnf->call_arptables = 1;\n\tbrnf->filter_vlan_tagged = 0;\n\tbrnf->filter_pppoe_tagged = 0;\n\tbrnf->pass_vlan_indev = 0;\n}\n\nstatic int br_netfilter_sysctl_init_net(struct net *net)\n{\n\tstruct ctl_table *table = brnf_table;\n\tstruct brnf_net *brnet;\n\n\tif (!net_eq(net, &init_net)) {\n\t\ttable = kmemdup(table, sizeof(brnf_table), GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tbrnet = net_generic(net, brnf_net_id);\n\ttable[0].data = &brnet->call_arptables;\n\ttable[1].data = &brnet->call_iptables;\n\ttable[2].data = &brnet->call_ip6tables;\n\ttable[3].data = &brnet->filter_vlan_tagged;\n\ttable[4].data = &brnet->filter_pppoe_tagged;\n\ttable[5].data = &brnet->pass_vlan_indev;\n\n\tbr_netfilter_sysctl_default(brnet);\n\n\tbrnet->ctl_hdr = register_net_sysctl_sz(net, \"net/bridge\", table,\n\t\t\t\t\t\tARRAY_SIZE(brnf_table));\n\tif (!brnet->ctl_hdr) {\n\t\tif (!net_eq(net, &init_net))\n\t\t\tkfree(table);\n\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void br_netfilter_sysctl_exit_net(struct net *net,\n\t\t\t\t\t struct brnf_net *brnet)\n{\n\tstruct ctl_table *table = brnet->ctl_hdr->ctl_table_arg;\n\n\tunregister_net_sysctl_table(brnet->ctl_hdr);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n}\n\nstatic int __net_init brnf_init_net(struct net *net)\n{\n\treturn br_netfilter_sysctl_init_net(net);\n}\n#endif\n\nstatic void __net_exit brnf_exit_net(struct net *net)\n{\n\tstruct brnf_net *brnet;\n\n\tbrnet = net_generic(net, brnf_net_id);\n\tif (brnet->enabled) {\n\t\tnf_unregister_net_hooks(net, br_nf_ops, ARRAY_SIZE(br_nf_ops));\n\t\tbrnet->enabled = false;\n\t}\n\n#ifdef CONFIG_SYSCTL\n\tbr_netfilter_sysctl_exit_net(net, brnet);\n#endif\n}\n\nstatic struct pernet_operations brnf_net_ops __read_mostly = {\n#ifdef CONFIG_SYSCTL\n\t.init = brnf_init_net,\n#endif\n\t.exit = brnf_exit_net,\n\t.id   = &brnf_net_id,\n\t.size = sizeof(struct brnf_net),\n};\n\nstatic int __init br_netfilter_init(void)\n{\n\tint ret;\n\n\tret = register_pernet_subsys(&brnf_net_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = register_netdevice_notifier(&brnf_notifier);\n\tif (ret < 0) {\n\t\tunregister_pernet_subsys(&brnf_net_ops);\n\t\treturn ret;\n\t}\n\n\tRCU_INIT_POINTER(nf_br_ops, &br_ops);\n\tprintk(KERN_NOTICE \"Bridge firewalling registered\\n\");\n\treturn 0;\n}\n\nstatic void __exit br_netfilter_fini(void)\n{\n\tRCU_INIT_POINTER(nf_br_ops, NULL);\n\tunregister_netdevice_notifier(&brnf_notifier);\n\tunregister_pernet_subsys(&brnf_net_ops);\n}\n\nmodule_init(br_netfilter_init);\nmodule_exit(br_netfilter_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Lennert Buytenhek <buytenh@gnu.org>\");\nMODULE_AUTHOR(\"Bart De Schuymer <bdschuym@pandora.be>\");\nMODULE_DESCRIPTION(\"Linux ethernet netfilter firewall bridge\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}