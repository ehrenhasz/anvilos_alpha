{
  "module_name": "br_multicast_eht.c",
  "hash_id": "5e87d16f66bc6d092534edc05c45286f9cf30e7876db7898e66bd63477bc3c21",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_multicast_eht.c",
  "human_readable_source": "\n\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/if_ether.h>\n#include <linux/igmp.h>\n#include <linux/in.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/inetdevice.h>\n#include <linux/mroute.h>\n#include <net/ip.h>\n#include <net/switchdev.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/icmpv6.h>\n#include <net/ipv6.h>\n#include <net/mld.h>\n#include <net/ip6_checksum.h>\n#include <net/addrconf.h>\n#endif\n\n#include \"br_private.h\"\n#include \"br_private_mcast_eht.h\"\n\nstatic bool br_multicast_del_eht_set_entry(struct net_bridge_port_group *pg,\n\t\t\t\t\t   union net_bridge_eht_addr *src_addr,\n\t\t\t\t\t   union net_bridge_eht_addr *h_addr);\nstatic void br_multicast_create_eht_set_entry(const struct net_bridge_mcast *brmctx,\n\t\t\t\t\t      struct net_bridge_port_group *pg,\n\t\t\t\t\t      union net_bridge_eht_addr *src_addr,\n\t\t\t\t\t      union net_bridge_eht_addr *h_addr,\n\t\t\t\t\t      int filter_mode,\n\t\t\t\t\t      bool allow_zero_src);\n\nstatic struct net_bridge_group_eht_host *\nbr_multicast_eht_host_lookup(struct net_bridge_port_group *pg,\n\t\t\t     union net_bridge_eht_addr *h_addr)\n{\n\tstruct rb_node *node = pg->eht_host_tree.rb_node;\n\n\twhile (node) {\n\t\tstruct net_bridge_group_eht_host *this;\n\t\tint result;\n\n\t\tthis = rb_entry(node, struct net_bridge_group_eht_host,\n\t\t\t\trb_node);\n\t\tresult = memcmp(h_addr, &this->h_addr, sizeof(*h_addr));\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn this;\n\t}\n\n\treturn NULL;\n}\n\nstatic int br_multicast_eht_host_filter_mode(struct net_bridge_port_group *pg,\n\t\t\t\t\t     union net_bridge_eht_addr *h_addr)\n{\n\tstruct net_bridge_group_eht_host *eht_host;\n\n\teht_host = br_multicast_eht_host_lookup(pg, h_addr);\n\tif (!eht_host)\n\t\treturn MCAST_INCLUDE;\n\n\treturn eht_host->filter_mode;\n}\n\nstatic struct net_bridge_group_eht_set_entry *\nbr_multicast_eht_set_entry_lookup(struct net_bridge_group_eht_set *eht_set,\n\t\t\t\t  union net_bridge_eht_addr *h_addr)\n{\n\tstruct rb_node *node = eht_set->entry_tree.rb_node;\n\n\twhile (node) {\n\t\tstruct net_bridge_group_eht_set_entry *this;\n\t\tint result;\n\n\t\tthis = rb_entry(node, struct net_bridge_group_eht_set_entry,\n\t\t\t\trb_node);\n\t\tresult = memcmp(h_addr, &this->h_addr, sizeof(*h_addr));\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn this;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct net_bridge_group_eht_set *\nbr_multicast_eht_set_lookup(struct net_bridge_port_group *pg,\n\t\t\t    union net_bridge_eht_addr *src_addr)\n{\n\tstruct rb_node *node = pg->eht_set_tree.rb_node;\n\n\twhile (node) {\n\t\tstruct net_bridge_group_eht_set *this;\n\t\tint result;\n\n\t\tthis = rb_entry(node, struct net_bridge_group_eht_set,\n\t\t\t\trb_node);\n\t\tresult = memcmp(src_addr, &this->src_addr, sizeof(*src_addr));\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn this;\n\t}\n\n\treturn NULL;\n}\n\nstatic void __eht_destroy_host(struct net_bridge_group_eht_host *eht_host)\n{\n\tWARN_ON(!hlist_empty(&eht_host->set_entries));\n\n\tbr_multicast_eht_hosts_dec(eht_host->pg);\n\n\trb_erase(&eht_host->rb_node, &eht_host->pg->eht_host_tree);\n\tRB_CLEAR_NODE(&eht_host->rb_node);\n\tkfree(eht_host);\n}\n\nstatic void br_multicast_destroy_eht_set_entry(struct net_bridge_mcast_gc *gc)\n{\n\tstruct net_bridge_group_eht_set_entry *set_h;\n\n\tset_h = container_of(gc, struct net_bridge_group_eht_set_entry, mcast_gc);\n\tWARN_ON(!RB_EMPTY_NODE(&set_h->rb_node));\n\n\ttimer_shutdown_sync(&set_h->timer);\n\tkfree(set_h);\n}\n\nstatic void br_multicast_destroy_eht_set(struct net_bridge_mcast_gc *gc)\n{\n\tstruct net_bridge_group_eht_set *eht_set;\n\n\teht_set = container_of(gc, struct net_bridge_group_eht_set, mcast_gc);\n\tWARN_ON(!RB_EMPTY_NODE(&eht_set->rb_node));\n\tWARN_ON(!RB_EMPTY_ROOT(&eht_set->entry_tree));\n\n\ttimer_shutdown_sync(&eht_set->timer);\n\tkfree(eht_set);\n}\n\nstatic void __eht_del_set_entry(struct net_bridge_group_eht_set_entry *set_h)\n{\n\tstruct net_bridge_group_eht_host *eht_host = set_h->h_parent;\n\tunion net_bridge_eht_addr zero_addr;\n\n\trb_erase(&set_h->rb_node, &set_h->eht_set->entry_tree);\n\tRB_CLEAR_NODE(&set_h->rb_node);\n\thlist_del_init(&set_h->host_list);\n\tmemset(&zero_addr, 0, sizeof(zero_addr));\n\tif (memcmp(&set_h->h_addr, &zero_addr, sizeof(zero_addr)))\n\t\teht_host->num_entries--;\n\thlist_add_head(&set_h->mcast_gc.gc_node, &set_h->br->mcast_gc_list);\n\tqueue_work(system_long_wq, &set_h->br->mcast_gc_work);\n\n\tif (hlist_empty(&eht_host->set_entries))\n\t\t__eht_destroy_host(eht_host);\n}\n\nstatic void br_multicast_del_eht_set(struct net_bridge_group_eht_set *eht_set)\n{\n\tstruct net_bridge_group_eht_set_entry *set_h;\n\tstruct rb_node *node;\n\n\twhile ((node = rb_first(&eht_set->entry_tree))) {\n\t\tset_h = rb_entry(node, struct net_bridge_group_eht_set_entry,\n\t\t\t\t rb_node);\n\t\t__eht_del_set_entry(set_h);\n\t}\n\n\trb_erase(&eht_set->rb_node, &eht_set->pg->eht_set_tree);\n\tRB_CLEAR_NODE(&eht_set->rb_node);\n\thlist_add_head(&eht_set->mcast_gc.gc_node, &eht_set->br->mcast_gc_list);\n\tqueue_work(system_long_wq, &eht_set->br->mcast_gc_work);\n}\n\nvoid br_multicast_eht_clean_sets(struct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_group_eht_set *eht_set;\n\tstruct rb_node *node;\n\n\twhile ((node = rb_first(&pg->eht_set_tree))) {\n\t\teht_set = rb_entry(node, struct net_bridge_group_eht_set,\n\t\t\t\t   rb_node);\n\t\tbr_multicast_del_eht_set(eht_set);\n\t}\n}\n\nstatic void br_multicast_eht_set_entry_expired(struct timer_list *t)\n{\n\tstruct net_bridge_group_eht_set_entry *set_h = from_timer(set_h, t, timer);\n\tstruct net_bridge *br = set_h->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (RB_EMPTY_NODE(&set_h->rb_node) || timer_pending(&set_h->timer))\n\t\tgoto out;\n\n\tbr_multicast_del_eht_set_entry(set_h->eht_set->pg,\n\t\t\t\t       &set_h->eht_set->src_addr,\n\t\t\t\t       &set_h->h_addr);\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_eht_set_expired(struct timer_list *t)\n{\n\tstruct net_bridge_group_eht_set *eht_set = from_timer(eht_set, t,\n\t\t\t\t\t\t\t      timer);\n\tstruct net_bridge *br = eht_set->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (RB_EMPTY_NODE(&eht_set->rb_node) || timer_pending(&eht_set->timer))\n\t\tgoto out;\n\n\tbr_multicast_del_eht_set(eht_set);\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic struct net_bridge_group_eht_host *\n__eht_lookup_create_host(struct net_bridge_port_group *pg,\n\t\t\t union net_bridge_eht_addr *h_addr,\n\t\t\t unsigned char filter_mode)\n{\n\tstruct rb_node **link = &pg->eht_host_tree.rb_node, *parent = NULL;\n\tstruct net_bridge_group_eht_host *eht_host;\n\n\twhile (*link) {\n\t\tstruct net_bridge_group_eht_host *this;\n\t\tint result;\n\n\t\tthis = rb_entry(*link, struct net_bridge_group_eht_host,\n\t\t\t\trb_node);\n\t\tresult = memcmp(h_addr, &this->h_addr, sizeof(*h_addr));\n\t\tparent = *link;\n\t\tif (result < 0)\n\t\t\tlink = &((*link)->rb_left);\n\t\telse if (result > 0)\n\t\t\tlink = &((*link)->rb_right);\n\t\telse\n\t\t\treturn this;\n\t}\n\n\tif (br_multicast_eht_hosts_over_limit(pg))\n\t\treturn NULL;\n\n\teht_host = kzalloc(sizeof(*eht_host), GFP_ATOMIC);\n\tif (!eht_host)\n\t\treturn NULL;\n\n\tmemcpy(&eht_host->h_addr, h_addr, sizeof(*h_addr));\n\tINIT_HLIST_HEAD(&eht_host->set_entries);\n\teht_host->pg = pg;\n\teht_host->filter_mode = filter_mode;\n\n\trb_link_node(&eht_host->rb_node, parent, link);\n\trb_insert_color(&eht_host->rb_node, &pg->eht_host_tree);\n\n\tbr_multicast_eht_hosts_inc(pg);\n\n\treturn eht_host;\n}\n\nstatic struct net_bridge_group_eht_set_entry *\n__eht_lookup_create_set_entry(struct net_bridge *br,\n\t\t\t      struct net_bridge_group_eht_set *eht_set,\n\t\t\t      struct net_bridge_group_eht_host *eht_host,\n\t\t\t      bool allow_zero_src)\n{\n\tstruct rb_node **link = &eht_set->entry_tree.rb_node, *parent = NULL;\n\tstruct net_bridge_group_eht_set_entry *set_h;\n\n\twhile (*link) {\n\t\tstruct net_bridge_group_eht_set_entry *this;\n\t\tint result;\n\n\t\tthis = rb_entry(*link, struct net_bridge_group_eht_set_entry,\n\t\t\t\trb_node);\n\t\tresult = memcmp(&eht_host->h_addr, &this->h_addr,\n\t\t\t\tsizeof(union net_bridge_eht_addr));\n\t\tparent = *link;\n\t\tif (result < 0)\n\t\t\tlink = &((*link)->rb_left);\n\t\telse if (result > 0)\n\t\t\tlink = &((*link)->rb_right);\n\t\telse\n\t\t\treturn this;\n\t}\n\n\t \n\tif (!allow_zero_src && eht_host->num_entries >= PG_SRC_ENT_LIMIT)\n\t\treturn NULL;\n\n\tset_h = kzalloc(sizeof(*set_h), GFP_ATOMIC);\n\tif (!set_h)\n\t\treturn NULL;\n\n\tmemcpy(&set_h->h_addr, &eht_host->h_addr,\n\t       sizeof(union net_bridge_eht_addr));\n\tset_h->mcast_gc.destroy = br_multicast_destroy_eht_set_entry;\n\tset_h->eht_set = eht_set;\n\tset_h->h_parent = eht_host;\n\tset_h->br = br;\n\ttimer_setup(&set_h->timer, br_multicast_eht_set_entry_expired, 0);\n\n\thlist_add_head(&set_h->host_list, &eht_host->set_entries);\n\trb_link_node(&set_h->rb_node, parent, link);\n\trb_insert_color(&set_h->rb_node, &eht_set->entry_tree);\n\t \n\tif (!allow_zero_src)\n\t\teht_host->num_entries++;\n\n\treturn set_h;\n}\n\nstatic struct net_bridge_group_eht_set *\n__eht_lookup_create_set(struct net_bridge_port_group *pg,\n\t\t\tunion net_bridge_eht_addr *src_addr)\n{\n\tstruct rb_node **link = &pg->eht_set_tree.rb_node, *parent = NULL;\n\tstruct net_bridge_group_eht_set *eht_set;\n\n\twhile (*link) {\n\t\tstruct net_bridge_group_eht_set *this;\n\t\tint result;\n\n\t\tthis = rb_entry(*link, struct net_bridge_group_eht_set,\n\t\t\t\trb_node);\n\t\tresult = memcmp(src_addr, &this->src_addr, sizeof(*src_addr));\n\t\tparent = *link;\n\t\tif (result < 0)\n\t\t\tlink = &((*link)->rb_left);\n\t\telse if (result > 0)\n\t\t\tlink = &((*link)->rb_right);\n\t\telse\n\t\t\treturn this;\n\t}\n\n\teht_set = kzalloc(sizeof(*eht_set), GFP_ATOMIC);\n\tif (!eht_set)\n\t\treturn NULL;\n\n\tmemcpy(&eht_set->src_addr, src_addr, sizeof(*src_addr));\n\teht_set->mcast_gc.destroy = br_multicast_destroy_eht_set;\n\teht_set->pg = pg;\n\teht_set->br = pg->key.port->br;\n\teht_set->entry_tree = RB_ROOT;\n\ttimer_setup(&eht_set->timer, br_multicast_eht_set_expired, 0);\n\n\trb_link_node(&eht_set->rb_node, parent, link);\n\trb_insert_color(&eht_set->rb_node, &pg->eht_set_tree);\n\n\treturn eht_set;\n}\n\nstatic void br_multicast_ip_src_to_eht_addr(const struct br_ip *src,\n\t\t\t\t\t    union net_bridge_eht_addr *dest)\n{\n\tswitch (src->proto) {\n\tcase htons(ETH_P_IP):\n\t\tdest->ip4 = src->src.ip4;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tmemcpy(&dest->ip6, &src->src.ip6, sizeof(struct in6_addr));\n\t\tbreak;\n#endif\n\t}\n}\n\nstatic void br_eht_convert_host_filter_mode(const struct net_bridge_mcast *brmctx,\n\t\t\t\t\t    struct net_bridge_port_group *pg,\n\t\t\t\t\t    union net_bridge_eht_addr *h_addr,\n\t\t\t\t\t    int filter_mode)\n{\n\tstruct net_bridge_group_eht_host *eht_host;\n\tunion net_bridge_eht_addr zero_addr;\n\n\teht_host = br_multicast_eht_host_lookup(pg, h_addr);\n\tif (eht_host)\n\t\teht_host->filter_mode = filter_mode;\n\n\tmemset(&zero_addr, 0, sizeof(zero_addr));\n\tswitch (filter_mode) {\n\tcase MCAST_INCLUDE:\n\t\tbr_multicast_del_eht_set_entry(pg, &zero_addr, h_addr);\n\t\tbreak;\n\tcase MCAST_EXCLUDE:\n\t\tbr_multicast_create_eht_set_entry(brmctx, pg, &zero_addr,\n\t\t\t\t\t\t  h_addr, MCAST_EXCLUDE,\n\t\t\t\t\t\t  true);\n\t\tbreak;\n\t}\n}\n\nstatic void br_multicast_create_eht_set_entry(const struct net_bridge_mcast *brmctx,\n\t\t\t\t\t      struct net_bridge_port_group *pg,\n\t\t\t\t\t      union net_bridge_eht_addr *src_addr,\n\t\t\t\t\t      union net_bridge_eht_addr *h_addr,\n\t\t\t\t\t      int filter_mode,\n\t\t\t\t\t      bool allow_zero_src)\n{\n\tstruct net_bridge_group_eht_set_entry *set_h;\n\tstruct net_bridge_group_eht_host *eht_host;\n\tstruct net_bridge *br = pg->key.port->br;\n\tstruct net_bridge_group_eht_set *eht_set;\n\tunion net_bridge_eht_addr zero_addr;\n\n\tmemset(&zero_addr, 0, sizeof(zero_addr));\n\tif (!allow_zero_src && !memcmp(src_addr, &zero_addr, sizeof(zero_addr)))\n\t\treturn;\n\n\teht_set = __eht_lookup_create_set(pg, src_addr);\n\tif (!eht_set)\n\t\treturn;\n\n\teht_host = __eht_lookup_create_host(pg, h_addr, filter_mode);\n\tif (!eht_host)\n\t\tgoto fail_host;\n\n\tset_h = __eht_lookup_create_set_entry(br, eht_set, eht_host,\n\t\t\t\t\t      allow_zero_src);\n\tif (!set_h)\n\t\tgoto fail_set_entry;\n\n\tmod_timer(&set_h->timer, jiffies + br_multicast_gmi(brmctx));\n\tmod_timer(&eht_set->timer, jiffies + br_multicast_gmi(brmctx));\n\n\treturn;\n\nfail_set_entry:\n\tif (hlist_empty(&eht_host->set_entries))\n\t\t__eht_destroy_host(eht_host);\nfail_host:\n\tif (RB_EMPTY_ROOT(&eht_set->entry_tree))\n\t\tbr_multicast_del_eht_set(eht_set);\n}\n\nstatic bool br_multicast_del_eht_set_entry(struct net_bridge_port_group *pg,\n\t\t\t\t\t   union net_bridge_eht_addr *src_addr,\n\t\t\t\t\t   union net_bridge_eht_addr *h_addr)\n{\n\tstruct net_bridge_group_eht_set_entry *set_h;\n\tstruct net_bridge_group_eht_set *eht_set;\n\tbool set_deleted = false;\n\n\teht_set = br_multicast_eht_set_lookup(pg, src_addr);\n\tif (!eht_set)\n\t\tgoto out;\n\n\tset_h = br_multicast_eht_set_entry_lookup(eht_set, h_addr);\n\tif (!set_h)\n\t\tgoto out;\n\n\t__eht_del_set_entry(set_h);\n\n\tif (RB_EMPTY_ROOT(&eht_set->entry_tree)) {\n\t\tbr_multicast_del_eht_set(eht_set);\n\t\tset_deleted = true;\n\t}\n\nout:\n\treturn set_deleted;\n}\n\nstatic void br_multicast_del_eht_host(struct net_bridge_port_group *pg,\n\t\t\t\t      union net_bridge_eht_addr *h_addr)\n{\n\tstruct net_bridge_group_eht_set_entry *set_h;\n\tstruct net_bridge_group_eht_host *eht_host;\n\tstruct hlist_node *tmp;\n\n\teht_host = br_multicast_eht_host_lookup(pg, h_addr);\n\tif (!eht_host)\n\t\treturn;\n\n\thlist_for_each_entry_safe(set_h, tmp, &eht_host->set_entries, host_list)\n\t\tbr_multicast_del_eht_set_entry(set_h->eht_set->pg,\n\t\t\t\t\t       &set_h->eht_set->src_addr,\n\t\t\t\t\t       &set_h->h_addr);\n}\n\n \nstatic void __eht_create_set_entries(const struct net_bridge_mcast *brmctx,\n\t\t\t\t     struct net_bridge_port_group *pg,\n\t\t\t\t     union net_bridge_eht_addr *h_addr,\n\t\t\t\t     void *srcs,\n\t\t\t\t     u32 nsrcs,\n\t\t\t\t     size_t addr_size,\n\t\t\t\t     int filter_mode)\n{\n\tunion net_bridge_eht_addr eht_src_addr;\n\tu32 src_idx;\n\n\tmemset(&eht_src_addr, 0, sizeof(eht_src_addr));\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&eht_src_addr, srcs + (src_idx * addr_size), addr_size);\n\t\tbr_multicast_create_eht_set_entry(brmctx, pg, &eht_src_addr,\n\t\t\t\t\t\t  h_addr, filter_mode,\n\t\t\t\t\t\t  false);\n\t}\n}\n\n \nstatic bool __eht_del_set_entries(struct net_bridge_port_group *pg,\n\t\t\t\t  union net_bridge_eht_addr *h_addr,\n\t\t\t\t  void *srcs,\n\t\t\t\t  u32 nsrcs,\n\t\t\t\t  size_t addr_size)\n{\n\tunion net_bridge_eht_addr eht_src_addr;\n\tstruct net_bridge_group_src *src_ent;\n\tbool changed = false;\n\tstruct br_ip src_ip;\n\tu32 src_idx;\n\n\tmemset(&eht_src_addr, 0, sizeof(eht_src_addr));\n\tmemset(&src_ip, 0, sizeof(src_ip));\n\tsrc_ip.proto = pg->key.addr.proto;\n\tfor (src_idx = 0; src_idx < nsrcs; src_idx++) {\n\t\tmemcpy(&eht_src_addr, srcs + (src_idx * addr_size), addr_size);\n\t\tif (!br_multicast_del_eht_set_entry(pg, &eht_src_addr, h_addr))\n\t\t\tcontinue;\n\t\tmemcpy(&src_ip, srcs + (src_idx * addr_size), addr_size);\n\t\tsrc_ent = br_multicast_find_group_src(pg, &src_ip);\n\t\tif (!src_ent)\n\t\t\tcontinue;\n\t\tbr_multicast_del_group_src(src_ent, true);\n\t\tchanged = true;\n\t}\n\n\treturn changed;\n}\n\nstatic bool br_multicast_eht_allow(const struct net_bridge_mcast *brmctx,\n\t\t\t\t   struct net_bridge_port_group *pg,\n\t\t\t\t   union net_bridge_eht_addr *h_addr,\n\t\t\t\t   void *srcs,\n\t\t\t\t   u32 nsrcs,\n\t\t\t\t   size_t addr_size)\n{\n\tbool changed = false;\n\n\tswitch (br_multicast_eht_host_filter_mode(pg, h_addr)) {\n\tcase MCAST_INCLUDE:\n\t\t__eht_create_set_entries(brmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t\t addr_size, MCAST_INCLUDE);\n\t\tbreak;\n\tcase MCAST_EXCLUDE:\n\t\tchanged = __eht_del_set_entries(pg, h_addr, srcs, nsrcs,\n\t\t\t\t\t\taddr_size);\n\t\tbreak;\n\t}\n\n\treturn changed;\n}\n\nstatic bool br_multicast_eht_block(const struct net_bridge_mcast *brmctx,\n\t\t\t\t   struct net_bridge_port_group *pg,\n\t\t\t\t   union net_bridge_eht_addr *h_addr,\n\t\t\t\t   void *srcs,\n\t\t\t\t   u32 nsrcs,\n\t\t\t\t   size_t addr_size)\n{\n\tbool changed = false;\n\n\tswitch (br_multicast_eht_host_filter_mode(pg, h_addr)) {\n\tcase MCAST_INCLUDE:\n\t\tchanged = __eht_del_set_entries(pg, h_addr, srcs, nsrcs,\n\t\t\t\t\t\taddr_size);\n\t\tbreak;\n\tcase MCAST_EXCLUDE:\n\t\t__eht_create_set_entries(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\t\t MCAST_EXCLUDE);\n\t\tbreak;\n\t}\n\n\treturn changed;\n}\n\n \nstatic bool __eht_inc_exc(const struct net_bridge_mcast *brmctx,\n\t\t\t  struct net_bridge_port_group *pg,\n\t\t\t  union net_bridge_eht_addr *h_addr,\n\t\t\t  void *srcs,\n\t\t\t  u32 nsrcs,\n\t\t\t  size_t addr_size,\n\t\t\t  unsigned char filter_mode,\n\t\t\t  bool to_report)\n{\n\tbool changed = false, flush_entries = to_report;\n\tunion net_bridge_eht_addr eht_src_addr;\n\n\tif (br_multicast_eht_host_filter_mode(pg, h_addr) != filter_mode)\n\t\tflush_entries = true;\n\n\tmemset(&eht_src_addr, 0, sizeof(eht_src_addr));\n\t \n\tif (flush_entries)\n\t\tbr_multicast_del_eht_host(pg, h_addr);\n\t__eht_create_set_entries(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\t filter_mode);\n\t \n\tif (flush_entries) {\n\t\tstruct net_bridge_group_eht_set *eht_set;\n\t\tstruct net_bridge_group_src *src_ent;\n\t\tstruct hlist_node *tmp;\n\n\t\thlist_for_each_entry_safe(src_ent, tmp, &pg->src_list, node) {\n\t\t\tbr_multicast_ip_src_to_eht_addr(&src_ent->addr,\n\t\t\t\t\t\t\t&eht_src_addr);\n\t\t\tif (!br_multicast_eht_set_lookup(pg, &eht_src_addr)) {\n\t\t\t\tbr_multicast_del_group_src(src_ent, true);\n\t\t\t\tchanged = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (!(src_ent->flags & BR_SGRP_F_SEND) ||\n\t\t\t    filter_mode != MCAST_INCLUDE ||\n\t\t\t    !to_report)\n\t\t\t\tcontinue;\n\t\t\teht_set = br_multicast_eht_set_lookup(pg,\n\t\t\t\t\t\t\t      &eht_src_addr);\n\t\t\tif (!eht_set)\n\t\t\t\tcontinue;\n\t\t\tmod_timer(&eht_set->timer, jiffies + br_multicast_lmqt(brmctx));\n\t\t}\n\t}\n\n\treturn changed;\n}\n\nstatic bool br_multicast_eht_inc(const struct net_bridge_mcast *brmctx,\n\t\t\t\t struct net_bridge_port_group *pg,\n\t\t\t\t union net_bridge_eht_addr *h_addr,\n\t\t\t\t void *srcs,\n\t\t\t\t u32 nsrcs,\n\t\t\t\t size_t addr_size,\n\t\t\t\t bool to_report)\n{\n\tbool changed;\n\n\tchanged = __eht_inc_exc(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\tMCAST_INCLUDE, to_report);\n\tbr_eht_convert_host_filter_mode(brmctx, pg, h_addr, MCAST_INCLUDE);\n\n\treturn changed;\n}\n\nstatic bool br_multicast_eht_exc(const struct net_bridge_mcast *brmctx,\n\t\t\t\t struct net_bridge_port_group *pg,\n\t\t\t\t union net_bridge_eht_addr *h_addr,\n\t\t\t\t void *srcs,\n\t\t\t\t u32 nsrcs,\n\t\t\t\t size_t addr_size,\n\t\t\t\t bool to_report)\n{\n\tbool changed;\n\n\tchanged = __eht_inc_exc(brmctx, pg, h_addr, srcs, nsrcs, addr_size,\n\t\t\t\tMCAST_EXCLUDE, to_report);\n\tbr_eht_convert_host_filter_mode(brmctx, pg, h_addr, MCAST_EXCLUDE);\n\n\treturn changed;\n}\n\nstatic bool __eht_ip4_handle(const struct net_bridge_mcast *brmctx,\n\t\t\t     struct net_bridge_port_group *pg,\n\t\t\t     union net_bridge_eht_addr *h_addr,\n\t\t\t     void *srcs,\n\t\t\t     u32 nsrcs,\n\t\t\t     int grec_type)\n{\n\tbool changed = false, to_report = false;\n\n\tswitch (grec_type) {\n\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\tbr_multicast_eht_allow(brmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t       sizeof(__be32));\n\t\tbreak;\n\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\tchanged = br_multicast_eht_block(brmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t\t\t sizeof(__be32));\n\t\tbreak;\n\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\tto_report = true;\n\t\tfallthrough;\n\tcase IGMPV3_MODE_IS_INCLUDE:\n\t\tchanged = br_multicast_eht_inc(brmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t\t       sizeof(__be32), to_report);\n\t\tbreak;\n\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\tto_report = true;\n\t\tfallthrough;\n\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\tchanged = br_multicast_eht_exc(brmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t\t       sizeof(__be32), to_report);\n\t\tbreak;\n\t}\n\n\treturn changed;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic bool __eht_ip6_handle(const struct net_bridge_mcast *brmctx,\n\t\t\t     struct net_bridge_port_group *pg,\n\t\t\t     union net_bridge_eht_addr *h_addr,\n\t\t\t     void *srcs,\n\t\t\t     u32 nsrcs,\n\t\t\t     int grec_type)\n{\n\tbool changed = false, to_report = false;\n\n\tswitch (grec_type) {\n\tcase MLD2_ALLOW_NEW_SOURCES:\n\t\tbr_multicast_eht_allow(brmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t       sizeof(struct in6_addr));\n\t\tbreak;\n\tcase MLD2_BLOCK_OLD_SOURCES:\n\t\tchanged = br_multicast_eht_block(brmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t\t\t sizeof(struct in6_addr));\n\t\tbreak;\n\tcase MLD2_CHANGE_TO_INCLUDE:\n\t\tto_report = true;\n\t\tfallthrough;\n\tcase MLD2_MODE_IS_INCLUDE:\n\t\tchanged = br_multicast_eht_inc(brmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t\t       sizeof(struct in6_addr),\n\t\t\t\t\t       to_report);\n\t\tbreak;\n\tcase MLD2_CHANGE_TO_EXCLUDE:\n\t\tto_report = true;\n\t\tfallthrough;\n\tcase MLD2_MODE_IS_EXCLUDE:\n\t\tchanged = br_multicast_eht_exc(brmctx, pg, h_addr, srcs, nsrcs,\n\t\t\t\t\t       sizeof(struct in6_addr),\n\t\t\t\t\t       to_report);\n\t\tbreak;\n\t}\n\n\treturn changed;\n}\n#endif\n\n \nbool br_multicast_eht_handle(const struct net_bridge_mcast *brmctx,\n\t\t\t     struct net_bridge_port_group *pg,\n\t\t\t     void *h_addr,\n\t\t\t     void *srcs,\n\t\t\t     u32 nsrcs,\n\t\t\t     size_t addr_size,\n\t\t\t     int grec_type)\n{\n\tbool eht_enabled = !!(pg->key.port->flags & BR_MULTICAST_FAST_LEAVE);\n\tunion net_bridge_eht_addr eht_host_addr;\n\tbool changed = false;\n\n\tif (!eht_enabled)\n\t\tgoto out;\n\n\tmemset(&eht_host_addr, 0, sizeof(eht_host_addr));\n\tmemcpy(&eht_host_addr, h_addr, addr_size);\n\tif (addr_size == sizeof(__be32))\n\t\tchanged = __eht_ip4_handle(brmctx, pg, &eht_host_addr, srcs,\n\t\t\t\t\t   nsrcs, grec_type);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tchanged = __eht_ip6_handle(brmctx, pg, &eht_host_addr, srcs,\n\t\t\t\t\t   nsrcs, grec_type);\n#endif\n\nout:\n\treturn changed;\n}\n\nint br_multicast_eht_set_hosts_limit(struct net_bridge_port *p,\n\t\t\t\t     u32 eht_hosts_limit)\n{\n\tstruct net_bridge *br = p->br;\n\n\tif (!eht_hosts_limit)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tp->multicast_eht_hosts_limit = eht_hosts_limit;\n\tspin_unlock_bh(&br->multicast_lock);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}