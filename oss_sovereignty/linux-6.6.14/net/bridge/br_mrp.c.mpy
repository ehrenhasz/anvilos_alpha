{
  "module_name": "br_mrp.c",
  "hash_id": "7638ef1feff2f608ba1b077795fcf3cf3c559db98e61d222c881b3bd3d510724",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_mrp.c",
  "human_readable_source": "\n\n#include <linux/mrp_bridge.h>\n#include \"br_private_mrp.h\"\n\nstatic const u8 mrp_test_dmac[ETH_ALEN] = { 0x1, 0x15, 0x4e, 0x0, 0x0, 0x1 };\nstatic const u8 mrp_in_test_dmac[ETH_ALEN] = { 0x1, 0x15, 0x4e, 0x0, 0x0, 0x3 };\n\nstatic int br_mrp_process(struct net_bridge_port *p, struct sk_buff *skb);\n\nstatic struct br_frame_type mrp_frame_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_MRP),\n\t.frame_handler = br_mrp_process,\n};\n\nstatic bool br_mrp_is_ring_port(struct net_bridge_port *p_port,\n\t\t\t\tstruct net_bridge_port *s_port,\n\t\t\t\tstruct net_bridge_port *port)\n{\n\tif (port == p_port ||\n\t    port == s_port)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool br_mrp_is_in_port(struct net_bridge_port *i_port,\n\t\t\t      struct net_bridge_port *port)\n{\n\tif (port == i_port)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct net_bridge_port *br_mrp_get_port(struct net_bridge *br,\n\t\t\t\t\t       u32 ifindex)\n{\n\tstruct net_bridge_port *res = NULL;\n\tstruct net_bridge_port *port;\n\n\tlist_for_each_entry(port, &br->port_list, list) {\n\t\tif (port->dev->ifindex == ifindex) {\n\t\t\tres = port;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic struct br_mrp *br_mrp_find_id(struct net_bridge *br, u32 ring_id)\n{\n\tstruct br_mrp *res = NULL;\n\tstruct br_mrp *mrp;\n\n\thlist_for_each_entry_rcu(mrp, &br->mrp_list, list,\n\t\t\t\t lockdep_rtnl_is_held()) {\n\t\tif (mrp->ring_id == ring_id) {\n\t\t\tres = mrp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic struct br_mrp *br_mrp_find_in_id(struct net_bridge *br, u32 in_id)\n{\n\tstruct br_mrp *res = NULL;\n\tstruct br_mrp *mrp;\n\n\thlist_for_each_entry_rcu(mrp, &br->mrp_list, list,\n\t\t\t\t lockdep_rtnl_is_held()) {\n\t\tif (mrp->in_id == in_id) {\n\t\t\tres = mrp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic bool br_mrp_unique_ifindex(struct net_bridge *br, u32 ifindex)\n{\n\tstruct br_mrp *mrp;\n\n\thlist_for_each_entry_rcu(mrp, &br->mrp_list, list,\n\t\t\t\t lockdep_rtnl_is_held()) {\n\t\tstruct net_bridge_port *p;\n\n\t\tp = rtnl_dereference(mrp->p_port);\n\t\tif (p && p->dev->ifindex == ifindex)\n\t\t\treturn false;\n\n\t\tp = rtnl_dereference(mrp->s_port);\n\t\tif (p && p->dev->ifindex == ifindex)\n\t\t\treturn false;\n\n\t\tp = rtnl_dereference(mrp->i_port);\n\t\tif (p && p->dev->ifindex == ifindex)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic struct br_mrp *br_mrp_find_port(struct net_bridge *br,\n\t\t\t\t       struct net_bridge_port *p)\n{\n\tstruct br_mrp *res = NULL;\n\tstruct br_mrp *mrp;\n\n\thlist_for_each_entry_rcu(mrp, &br->mrp_list, list,\n\t\t\t\t lockdep_rtnl_is_held()) {\n\t\tif (rcu_access_pointer(mrp->p_port) == p ||\n\t\t    rcu_access_pointer(mrp->s_port) == p ||\n\t\t    rcu_access_pointer(mrp->i_port) == p) {\n\t\t\tres = mrp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int br_mrp_next_seq(struct br_mrp *mrp)\n{\n\tmrp->seq_id++;\n\treturn mrp->seq_id;\n}\n\nstatic struct sk_buff *br_mrp_skb_alloc(struct net_bridge_port *p,\n\t\t\t\t\tconst u8 *src, const u8 *dst)\n{\n\tstruct ethhdr *eth_hdr;\n\tstruct sk_buff *skb;\n\t__be16 *version;\n\n\tskb = dev_alloc_skb(MRP_MAX_FRAME_LENGTH);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb->dev = p->dev;\n\tskb->protocol = htons(ETH_P_MRP);\n\tskb->priority = MRP_FRAME_PRIO;\n\tskb_reserve(skb, sizeof(*eth_hdr));\n\n\teth_hdr = skb_push(skb, sizeof(*eth_hdr));\n\tether_addr_copy(eth_hdr->h_dest, dst);\n\tether_addr_copy(eth_hdr->h_source, src);\n\teth_hdr->h_proto = htons(ETH_P_MRP);\n\n\tversion = skb_put(skb, sizeof(*version));\n\t*version = cpu_to_be16(MRP_VERSION);\n\n\treturn skb;\n}\n\nstatic void br_mrp_skb_tlv(struct sk_buff *skb,\n\t\t\t   enum br_mrp_tlv_header_type type,\n\t\t\t   u8 length)\n{\n\tstruct br_mrp_tlv_hdr *hdr;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\thdr->type = type;\n\thdr->length = length;\n}\n\nstatic void br_mrp_skb_common(struct sk_buff *skb, struct br_mrp *mrp)\n{\n\tstruct br_mrp_common_hdr *hdr;\n\n\tbr_mrp_skb_tlv(skb, BR_MRP_TLV_HEADER_COMMON, sizeof(*hdr));\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\thdr->seq_id = cpu_to_be16(br_mrp_next_seq(mrp));\n\tmemset(hdr->domain, 0xff, MRP_DOMAIN_UUID_LENGTH);\n}\n\nstatic struct sk_buff *br_mrp_alloc_test_skb(struct br_mrp *mrp,\n\t\t\t\t\t     struct net_bridge_port *p,\n\t\t\t\t\t     enum br_mrp_port_role_type port_role)\n{\n\tstruct br_mrp_ring_test_hdr *hdr = NULL;\n\tstruct sk_buff *skb = NULL;\n\n\tif (!p)\n\t\treturn NULL;\n\n\tskb = br_mrp_skb_alloc(p, p->dev->dev_addr, mrp_test_dmac);\n\tif (!skb)\n\t\treturn NULL;\n\n\tbr_mrp_skb_tlv(skb, BR_MRP_TLV_HEADER_RING_TEST, sizeof(*hdr));\n\thdr = skb_put(skb, sizeof(*hdr));\n\n\thdr->prio = cpu_to_be16(mrp->prio);\n\tether_addr_copy(hdr->sa, p->br->dev->dev_addr);\n\thdr->port_role = cpu_to_be16(port_role);\n\thdr->state = cpu_to_be16(mrp->ring_state);\n\thdr->transitions = cpu_to_be16(mrp->ring_transitions);\n\thdr->timestamp = cpu_to_be32(jiffies_to_msecs(jiffies));\n\n\tbr_mrp_skb_common(skb, mrp);\n\n\t \n\tif (mrp->ring_role == BR_MRP_RING_ROLE_MRA) {\n\t\tstruct br_mrp_sub_option1_hdr *sub_opt = NULL;\n\t\tstruct br_mrp_tlv_hdr *sub_tlv = NULL;\n\t\tstruct br_mrp_oui_hdr *oui = NULL;\n\t\tu8 length;\n\n\t\tlength = sizeof(*sub_opt) + sizeof(*sub_tlv) + sizeof(oui) +\n\t\t\tMRP_OPT_PADDING;\n\t\tbr_mrp_skb_tlv(skb, BR_MRP_TLV_HEADER_OPTION, length);\n\n\t\toui = skb_put(skb, sizeof(*oui));\n\t\tmemset(oui, 0x0, sizeof(*oui));\n\t\tsub_opt = skb_put(skb, sizeof(*sub_opt));\n\t\tmemset(sub_opt, 0x0, sizeof(*sub_opt));\n\n\t\tsub_tlv = skb_put(skb, sizeof(*sub_tlv));\n\t\tsub_tlv->type = BR_MRP_SUB_TLV_HEADER_TEST_AUTO_MGR;\n\n\t\t \n\t\tskb_put(skb, MRP_OPT_PADDING);\n\t}\n\n\tbr_mrp_skb_tlv(skb, BR_MRP_TLV_HEADER_END, 0x0);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *br_mrp_alloc_in_test_skb(struct br_mrp *mrp,\n\t\t\t\t\t\tstruct net_bridge_port *p,\n\t\t\t\t\t\tenum br_mrp_port_role_type port_role)\n{\n\tstruct br_mrp_in_test_hdr *hdr = NULL;\n\tstruct sk_buff *skb = NULL;\n\n\tif (!p)\n\t\treturn NULL;\n\n\tskb = br_mrp_skb_alloc(p, p->dev->dev_addr, mrp_in_test_dmac);\n\tif (!skb)\n\t\treturn NULL;\n\n\tbr_mrp_skb_tlv(skb, BR_MRP_TLV_HEADER_IN_TEST, sizeof(*hdr));\n\thdr = skb_put(skb, sizeof(*hdr));\n\n\thdr->id = cpu_to_be16(mrp->in_id);\n\tether_addr_copy(hdr->sa, p->br->dev->dev_addr);\n\thdr->port_role = cpu_to_be16(port_role);\n\thdr->state = cpu_to_be16(mrp->in_state);\n\thdr->transitions = cpu_to_be16(mrp->in_transitions);\n\thdr->timestamp = cpu_to_be32(jiffies_to_msecs(jiffies));\n\n\tbr_mrp_skb_common(skb, mrp);\n\tbr_mrp_skb_tlv(skb, BR_MRP_TLV_HEADER_END, 0x0);\n\n\treturn skb;\n}\n\n \nstatic void br_mrp_test_work_expired(struct work_struct *work)\n{\n\tstruct delayed_work *del_work = to_delayed_work(work);\n\tstruct br_mrp *mrp = container_of(del_work, struct br_mrp, test_work);\n\tstruct net_bridge_port *p;\n\tbool notify_open = false;\n\tstruct sk_buff *skb;\n\n\tif (time_before_eq(mrp->test_end, jiffies))\n\t\treturn;\n\n\tif (mrp->test_count_miss < mrp->test_max_miss) {\n\t\tmrp->test_count_miss++;\n\t} else {\n\t\t \n\t\tif (mrp->ring_state == BR_MRP_RING_STATE_CLOSED ||\n\t\t    mrp->test_monitor)\n\t\t\tnotify_open = true;\n\t}\n\n\trcu_read_lock();\n\n\tp = rcu_dereference(mrp->p_port);\n\tif (p) {\n\t\tif (!mrp->test_monitor) {\n\t\t\tskb = br_mrp_alloc_test_skb(mrp, p,\n\t\t\t\t\t\t    BR_MRP_PORT_ROLE_PRIMARY);\n\t\t\tif (!skb)\n\t\t\t\tgoto out;\n\n\t\t\tskb_reset_network_header(skb);\n\t\t\tdev_queue_xmit(skb);\n\t\t}\n\n\t\tif (notify_open && !mrp->ring_role_offloaded)\n\t\t\tbr_mrp_ring_port_open(p->dev, true);\n\t}\n\n\tp = rcu_dereference(mrp->s_port);\n\tif (p) {\n\t\tif (!mrp->test_monitor) {\n\t\t\tskb = br_mrp_alloc_test_skb(mrp, p,\n\t\t\t\t\t\t    BR_MRP_PORT_ROLE_SECONDARY);\n\t\t\tif (!skb)\n\t\t\t\tgoto out;\n\n\t\t\tskb_reset_network_header(skb);\n\t\t\tdev_queue_xmit(skb);\n\t\t}\n\n\t\tif (notify_open && !mrp->ring_role_offloaded)\n\t\t\tbr_mrp_ring_port_open(p->dev, true);\n\t}\n\nout:\n\trcu_read_unlock();\n\n\tqueue_delayed_work(system_wq, &mrp->test_work,\n\t\t\t   usecs_to_jiffies(mrp->test_interval));\n}\n\n \nstatic void br_mrp_in_test_work_expired(struct work_struct *work)\n{\n\tstruct delayed_work *del_work = to_delayed_work(work);\n\tstruct br_mrp *mrp = container_of(del_work, struct br_mrp, in_test_work);\n\tstruct net_bridge_port *p;\n\tbool notify_open = false;\n\tstruct sk_buff *skb;\n\n\tif (time_before_eq(mrp->in_test_end, jiffies))\n\t\treturn;\n\n\tif (mrp->in_test_count_miss < mrp->in_test_max_miss) {\n\t\tmrp->in_test_count_miss++;\n\t} else {\n\t\t \n\t\tif (mrp->in_state == BR_MRP_IN_STATE_CLOSED)\n\t\t\tnotify_open = true;\n\t}\n\n\trcu_read_lock();\n\n\tp = rcu_dereference(mrp->p_port);\n\tif (p) {\n\t\tskb = br_mrp_alloc_in_test_skb(mrp, p,\n\t\t\t\t\t       BR_MRP_PORT_ROLE_PRIMARY);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tskb_reset_network_header(skb);\n\t\tdev_queue_xmit(skb);\n\n\t\tif (notify_open && !mrp->in_role_offloaded)\n\t\t\tbr_mrp_in_port_open(p->dev, true);\n\t}\n\n\tp = rcu_dereference(mrp->s_port);\n\tif (p) {\n\t\tskb = br_mrp_alloc_in_test_skb(mrp, p,\n\t\t\t\t\t       BR_MRP_PORT_ROLE_SECONDARY);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tskb_reset_network_header(skb);\n\t\tdev_queue_xmit(skb);\n\n\t\tif (notify_open && !mrp->in_role_offloaded)\n\t\t\tbr_mrp_in_port_open(p->dev, true);\n\t}\n\n\tp = rcu_dereference(mrp->i_port);\n\tif (p) {\n\t\tskb = br_mrp_alloc_in_test_skb(mrp, p,\n\t\t\t\t\t       BR_MRP_PORT_ROLE_INTER);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tskb_reset_network_header(skb);\n\t\tdev_queue_xmit(skb);\n\n\t\tif (notify_open && !mrp->in_role_offloaded)\n\t\t\tbr_mrp_in_port_open(p->dev, true);\n\t}\n\nout:\n\trcu_read_unlock();\n\n\tqueue_delayed_work(system_wq, &mrp->in_test_work,\n\t\t\t   usecs_to_jiffies(mrp->in_test_interval));\n}\n\n \nstatic void br_mrp_del_impl(struct net_bridge *br, struct br_mrp *mrp)\n{\n\tstruct net_bridge_port *p;\n\tu8 state;\n\n\t \n\tcancel_delayed_work_sync(&mrp->test_work);\n\tbr_mrp_switchdev_send_ring_test(br, mrp, 0, 0, 0, 0);\n\n\t \n\tcancel_delayed_work_sync(&mrp->in_test_work);\n\tbr_mrp_switchdev_send_in_test(br, mrp, 0, 0, 0);\n\n\t \n\tbr_mrp_switchdev_set_ring_role(br, mrp, BR_MRP_RING_ROLE_DISABLED);\n\tp = rtnl_dereference(mrp->i_port);\n\tif (p)\n\t\tbr_mrp_switchdev_set_in_role(br, mrp, mrp->in_id, mrp->ring_id,\n\t\t\t\t\t     BR_MRP_IN_ROLE_DISABLED);\n\n\tbr_mrp_switchdev_del(br, mrp);\n\n\t \n\tp = rtnl_dereference(mrp->p_port);\n\tif (p) {\n\t\tspin_lock_bh(&br->lock);\n\t\tstate = netif_running(br->dev) ?\n\t\t\t\tBR_STATE_FORWARDING : BR_STATE_DISABLED;\n\t\tp->state = state;\n\t\tp->flags &= ~BR_MRP_AWARE;\n\t\tspin_unlock_bh(&br->lock);\n\t\tbr_mrp_port_switchdev_set_state(p, state);\n\t\trcu_assign_pointer(mrp->p_port, NULL);\n\t}\n\n\tp = rtnl_dereference(mrp->s_port);\n\tif (p) {\n\t\tspin_lock_bh(&br->lock);\n\t\tstate = netif_running(br->dev) ?\n\t\t\t\tBR_STATE_FORWARDING : BR_STATE_DISABLED;\n\t\tp->state = state;\n\t\tp->flags &= ~BR_MRP_AWARE;\n\t\tspin_unlock_bh(&br->lock);\n\t\tbr_mrp_port_switchdev_set_state(p, state);\n\t\trcu_assign_pointer(mrp->s_port, NULL);\n\t}\n\n\tp = rtnl_dereference(mrp->i_port);\n\tif (p) {\n\t\tspin_lock_bh(&br->lock);\n\t\tstate = netif_running(br->dev) ?\n\t\t\t\tBR_STATE_FORWARDING : BR_STATE_DISABLED;\n\t\tp->state = state;\n\t\tp->flags &= ~BR_MRP_AWARE;\n\t\tspin_unlock_bh(&br->lock);\n\t\tbr_mrp_port_switchdev_set_state(p, state);\n\t\trcu_assign_pointer(mrp->i_port, NULL);\n\t}\n\n\thlist_del_rcu(&mrp->list);\n\tkfree_rcu(mrp, rcu);\n\n\tif (hlist_empty(&br->mrp_list))\n\t\tbr_del_frame(br, &mrp_frame_type);\n}\n\n \nint br_mrp_add(struct net_bridge *br, struct br_mrp_instance *instance)\n{\n\tstruct net_bridge_port *p;\n\tstruct br_mrp *mrp;\n\tint err;\n\n\t \n\tmrp = br_mrp_find_id(br, instance->ring_id);\n\tif (mrp)\n\t\treturn -EINVAL;\n\n\tif (!br_mrp_get_port(br, instance->p_ifindex) ||\n\t    !br_mrp_get_port(br, instance->s_ifindex))\n\t\treturn -EINVAL;\n\n\t \n\tif (!br_mrp_unique_ifindex(br, instance->p_ifindex) ||\n\t    !br_mrp_unique_ifindex(br, instance->s_ifindex))\n\t\treturn -EINVAL;\n\n\tmrp = kzalloc(sizeof(*mrp), GFP_KERNEL);\n\tif (!mrp)\n\t\treturn -ENOMEM;\n\n\tmrp->ring_id = instance->ring_id;\n\tmrp->prio = instance->prio;\n\n\tp = br_mrp_get_port(br, instance->p_ifindex);\n\tspin_lock_bh(&br->lock);\n\tp->state = BR_STATE_FORWARDING;\n\tp->flags |= BR_MRP_AWARE;\n\tspin_unlock_bh(&br->lock);\n\trcu_assign_pointer(mrp->p_port, p);\n\n\tp = br_mrp_get_port(br, instance->s_ifindex);\n\tspin_lock_bh(&br->lock);\n\tp->state = BR_STATE_FORWARDING;\n\tp->flags |= BR_MRP_AWARE;\n\tspin_unlock_bh(&br->lock);\n\trcu_assign_pointer(mrp->s_port, p);\n\n\tif (hlist_empty(&br->mrp_list))\n\t\tbr_add_frame(br, &mrp_frame_type);\n\n\tINIT_DELAYED_WORK(&mrp->test_work, br_mrp_test_work_expired);\n\tINIT_DELAYED_WORK(&mrp->in_test_work, br_mrp_in_test_work_expired);\n\thlist_add_tail_rcu(&mrp->list, &br->mrp_list);\n\n\terr = br_mrp_switchdev_add(br, mrp);\n\tif (err)\n\t\tgoto delete_mrp;\n\n\treturn 0;\n\ndelete_mrp:\n\tbr_mrp_del_impl(br, mrp);\n\n\treturn err;\n}\n\n \nvoid br_mrp_port_del(struct net_bridge *br, struct net_bridge_port *p)\n{\n\tstruct br_mrp *mrp = br_mrp_find_port(br, p);\n\n\t \n\tif (!mrp)\n\t\treturn;\n\n\tbr_mrp_del_impl(br, mrp);\n}\n\n \nint br_mrp_del(struct net_bridge *br, struct br_mrp_instance *instance)\n{\n\tstruct br_mrp *mrp = br_mrp_find_id(br, instance->ring_id);\n\n\tif (!mrp)\n\t\treturn -EINVAL;\n\n\tbr_mrp_del_impl(br, mrp);\n\n\treturn 0;\n}\n\n \nint br_mrp_set_port_state(struct net_bridge_port *p,\n\t\t\t  enum br_mrp_port_state_type state)\n{\n\tu32 port_state;\n\n\tif (!p || !(p->flags & BR_MRP_AWARE))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&p->br->lock);\n\n\tif (state == BR_MRP_PORT_STATE_FORWARDING)\n\t\tport_state = BR_STATE_FORWARDING;\n\telse\n\t\tport_state = BR_STATE_BLOCKING;\n\n\tp->state = port_state;\n\tspin_unlock_bh(&p->br->lock);\n\n\tbr_mrp_port_switchdev_set_state(p, port_state);\n\n\treturn 0;\n}\n\n \nint br_mrp_set_port_role(struct net_bridge_port *p,\n\t\t\t enum br_mrp_port_role_type role)\n{\n\tstruct br_mrp *mrp;\n\n\tif (!p || !(p->flags & BR_MRP_AWARE))\n\t\treturn -EINVAL;\n\n\tmrp = br_mrp_find_port(p->br, p);\n\n\tif (!mrp)\n\t\treturn -EINVAL;\n\n\tswitch (role) {\n\tcase BR_MRP_PORT_ROLE_PRIMARY:\n\t\trcu_assign_pointer(mrp->p_port, p);\n\t\tbreak;\n\tcase BR_MRP_PORT_ROLE_SECONDARY:\n\t\trcu_assign_pointer(mrp->s_port, p);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tbr_mrp_port_switchdev_set_role(p, role);\n\n\treturn 0;\n}\n\n \nint br_mrp_set_ring_state(struct net_bridge *br,\n\t\t\t  struct br_mrp_ring_state *state)\n{\n\tstruct br_mrp *mrp = br_mrp_find_id(br, state->ring_id);\n\n\tif (!mrp)\n\t\treturn -EINVAL;\n\n\tif (mrp->ring_state != state->ring_state)\n\t\tmrp->ring_transitions++;\n\n\tmrp->ring_state = state->ring_state;\n\n\tbr_mrp_switchdev_set_ring_state(br, mrp, state->ring_state);\n\n\treturn 0;\n}\n\n \nint br_mrp_set_ring_role(struct net_bridge *br,\n\t\t\t struct br_mrp_ring_role *role)\n{\n\tstruct br_mrp *mrp = br_mrp_find_id(br, role->ring_id);\n\tenum br_mrp_hw_support support;\n\n\tif (!mrp)\n\t\treturn -EINVAL;\n\n\tmrp->ring_role = role->ring_role;\n\n\t \n\tsupport = br_mrp_switchdev_set_ring_role(br, mrp, role->ring_role);\n\tif (support == BR_MRP_NONE)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tmrp->ring_role_offloaded = support == BR_MRP_SW ? 0 : 1;\n\n\treturn 0;\n}\n\n \nint br_mrp_start_test(struct net_bridge *br,\n\t\t      struct br_mrp_start_test *test)\n{\n\tstruct br_mrp *mrp = br_mrp_find_id(br, test->ring_id);\n\tenum br_mrp_hw_support support;\n\n\tif (!mrp)\n\t\treturn -EINVAL;\n\n\t \n\tsupport = br_mrp_switchdev_send_ring_test(br, mrp, test->interval,\n\t\t\t\t\t\t  test->max_miss, test->period,\n\t\t\t\t\t\t  test->monitor);\n\tif (support == BR_MRP_NONE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (support == BR_MRP_HW)\n\t\treturn 0;\n\n\tmrp->test_interval = test->interval;\n\tmrp->test_end = jiffies + usecs_to_jiffies(test->period);\n\tmrp->test_max_miss = test->max_miss;\n\tmrp->test_monitor = test->monitor;\n\tmrp->test_count_miss = 0;\n\tqueue_delayed_work(system_wq, &mrp->test_work,\n\t\t\t   usecs_to_jiffies(test->interval));\n\n\treturn 0;\n}\n\n \nint br_mrp_set_in_state(struct net_bridge *br, struct br_mrp_in_state *state)\n{\n\tstruct br_mrp *mrp = br_mrp_find_in_id(br, state->in_id);\n\n\tif (!mrp)\n\t\treturn -EINVAL;\n\n\tif (mrp->in_state != state->in_state)\n\t\tmrp->in_transitions++;\n\n\tmrp->in_state = state->in_state;\n\n\tbr_mrp_switchdev_set_in_state(br, mrp, state->in_state);\n\n\treturn 0;\n}\n\n \nint br_mrp_set_in_role(struct net_bridge *br, struct br_mrp_in_role *role)\n{\n\tstruct br_mrp *mrp = br_mrp_find_id(br, role->ring_id);\n\tenum br_mrp_hw_support support;\n\tstruct net_bridge_port *p;\n\n\tif (!mrp)\n\t\treturn -EINVAL;\n\n\tif (!br_mrp_get_port(br, role->i_ifindex))\n\t\treturn -EINVAL;\n\n\tif (role->in_role == BR_MRP_IN_ROLE_DISABLED) {\n\t\tu8 state;\n\n\t\t \n\t\tp = rtnl_dereference(mrp->i_port);\n\t\tif (!p)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tcancel_delayed_work_sync(&mrp->in_test_work);\n\t\tbr_mrp_switchdev_send_in_test(br, mrp, 0, 0, 0);\n\n\t\t \n\t\tspin_lock_bh(&br->lock);\n\t\tstate = netif_running(br->dev) ?\n\t\t\t\tBR_STATE_FORWARDING : BR_STATE_DISABLED;\n\t\tp->state = state;\n\t\tp->flags &= ~BR_MRP_AWARE;\n\t\tspin_unlock_bh(&br->lock);\n\t\tbr_mrp_port_switchdev_set_state(p, state);\n\t\trcu_assign_pointer(mrp->i_port, NULL);\n\n\t\tmrp->in_role = role->in_role;\n\t\tmrp->in_id = 0;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (!br_mrp_unique_ifindex(br, role->i_ifindex))\n\t\treturn -EINVAL;\n\n\t \n\tif (rcu_access_pointer(mrp->i_port))\n\t\treturn -EINVAL;\n\n\tp = br_mrp_get_port(br, role->i_ifindex);\n\tspin_lock_bh(&br->lock);\n\tp->state = BR_STATE_FORWARDING;\n\tp->flags |= BR_MRP_AWARE;\n\tspin_unlock_bh(&br->lock);\n\trcu_assign_pointer(mrp->i_port, p);\n\n\tmrp->in_role = role->in_role;\n\tmrp->in_id = role->in_id;\n\n\t \n\tsupport = br_mrp_switchdev_set_in_role(br, mrp, role->in_id,\n\t\t\t\t\t       role->ring_id, role->in_role);\n\tif (support == BR_MRP_NONE)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tmrp->in_role_offloaded = support == BR_MRP_SW ? 0 : 1;\n\n\treturn 0;\n}\n\n \nint br_mrp_start_in_test(struct net_bridge *br,\n\t\t\t struct br_mrp_start_in_test *in_test)\n{\n\tstruct br_mrp *mrp = br_mrp_find_in_id(br, in_test->in_id);\n\tenum br_mrp_hw_support support;\n\n\tif (!mrp)\n\t\treturn -EINVAL;\n\n\tif (mrp->in_role != BR_MRP_IN_ROLE_MIM)\n\t\treturn -EINVAL;\n\n\t \n\tsupport =  br_mrp_switchdev_send_in_test(br, mrp, in_test->interval,\n\t\t\t\t\t\t in_test->max_miss,\n\t\t\t\t\t\t in_test->period);\n\tif (support == BR_MRP_NONE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (support == BR_MRP_HW)\n\t\treturn 0;\n\n\tmrp->in_test_interval = in_test->interval;\n\tmrp->in_test_end = jiffies + usecs_to_jiffies(in_test->period);\n\tmrp->in_test_max_miss = in_test->max_miss;\n\tmrp->in_test_count_miss = 0;\n\tqueue_delayed_work(system_wq, &mrp->in_test_work,\n\t\t\t   usecs_to_jiffies(in_test->interval));\n\n\treturn 0;\n}\n\n \nstatic bool br_mrp_ring_frame(struct sk_buff *skb)\n{\n\tconst struct br_mrp_tlv_hdr *hdr;\n\tstruct br_mrp_tlv_hdr _hdr;\n\n\thdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);\n\tif (!hdr)\n\t\treturn false;\n\n\tif (hdr->type == BR_MRP_TLV_HEADER_RING_TEST ||\n\t    hdr->type == BR_MRP_TLV_HEADER_RING_TOPO ||\n\t    hdr->type == BR_MRP_TLV_HEADER_RING_LINK_DOWN ||\n\t    hdr->type == BR_MRP_TLV_HEADER_RING_LINK_UP ||\n\t    hdr->type == BR_MRP_TLV_HEADER_OPTION)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool br_mrp_in_frame(struct sk_buff *skb)\n{\n\tconst struct br_mrp_tlv_hdr *hdr;\n\tstruct br_mrp_tlv_hdr _hdr;\n\n\thdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);\n\tif (!hdr)\n\t\treturn false;\n\n\tif (hdr->type == BR_MRP_TLV_HEADER_IN_TEST ||\n\t    hdr->type == BR_MRP_TLV_HEADER_IN_TOPO ||\n\t    hdr->type == BR_MRP_TLV_HEADER_IN_LINK_DOWN ||\n\t    hdr->type == BR_MRP_TLV_HEADER_IN_LINK_UP ||\n\t    hdr->type == BR_MRP_TLV_HEADER_IN_LINK_STATUS)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void br_mrp_mrm_process(struct br_mrp *mrp, struct net_bridge_port *port,\n\t\t\t       struct sk_buff *skb)\n{\n\tconst struct br_mrp_tlv_hdr *hdr;\n\tstruct br_mrp_tlv_hdr _hdr;\n\n\t \n\thdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);\n\tif (!hdr)\n\t\treturn;\n\n\tif (hdr->type != BR_MRP_TLV_HEADER_RING_TEST)\n\t\treturn;\n\n\tmrp->test_count_miss = 0;\n\n\t \n\tif (mrp->ring_state != BR_MRP_RING_STATE_CLOSED)\n\t\tbr_mrp_ring_port_open(port->dev, false);\n}\n\n \nstatic bool br_mrp_test_better_than_own(struct br_mrp *mrp,\n\t\t\t\t\tstruct net_bridge *br,\n\t\t\t\t\tconst struct br_mrp_ring_test_hdr *hdr)\n{\n\tu16 prio = be16_to_cpu(hdr->prio);\n\n\tif (prio < mrp->prio ||\n\t    (prio == mrp->prio &&\n\t    ether_addr_to_u64(hdr->sa) < ether_addr_to_u64(br->dev->dev_addr)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void br_mrp_mra_process(struct br_mrp *mrp, struct net_bridge *br,\n\t\t\t       struct net_bridge_port *port,\n\t\t\t       struct sk_buff *skb)\n{\n\tconst struct br_mrp_ring_test_hdr *test_hdr;\n\tstruct br_mrp_ring_test_hdr _test_hdr;\n\tconst struct br_mrp_tlv_hdr *hdr;\n\tstruct br_mrp_tlv_hdr _hdr;\n\n\t \n\thdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);\n\tif (!hdr)\n\t\treturn;\n\n\tif (hdr->type != BR_MRP_TLV_HEADER_RING_TEST)\n\t\treturn;\n\n\ttest_hdr = skb_header_pointer(skb, sizeof(uint16_t) + sizeof(_hdr),\n\t\t\t\t      sizeof(_test_hdr), &_test_hdr);\n\tif (!test_hdr)\n\t\treturn;\n\n\t \n\tif (br_mrp_test_better_than_own(mrp, br, test_hdr))\n\t\tmrp->test_count_miss = 0;\n}\n\n \nstatic bool br_mrp_mim_process(struct br_mrp *mrp, struct net_bridge_port *port,\n\t\t\t       struct sk_buff *skb)\n{\n\tconst struct br_mrp_in_test_hdr *in_hdr;\n\tstruct br_mrp_in_test_hdr _in_hdr;\n\tconst struct br_mrp_tlv_hdr *hdr;\n\tstruct br_mrp_tlv_hdr _hdr;\n\n\t \n\thdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);\n\tif (!hdr)\n\t\treturn false;\n\n\t \n\tin_hdr = skb_header_pointer(skb, sizeof(uint16_t) + sizeof(_hdr),\n\t\t\t\t    sizeof(_in_hdr), &_in_hdr);\n\tif (!in_hdr)\n\t\treturn false;\n\n\t \n\tif (mrp->in_id != ntohs(in_hdr->id))\n\t\treturn false;\n\n\tmrp->in_test_count_miss = 0;\n\n\t \n\tif (mrp->in_state != BR_MRP_IN_STATE_CLOSED)\n\t\tbr_mrp_in_port_open(port->dev, false);\n\n\treturn true;\n}\n\n \nstatic u8 br_mrp_get_frame_type(struct sk_buff *skb)\n{\n\tconst struct br_mrp_tlv_hdr *hdr;\n\tstruct br_mrp_tlv_hdr _hdr;\n\n\t \n\thdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);\n\tif (!hdr)\n\t\treturn 0xff;\n\n\treturn hdr->type;\n}\n\nstatic bool br_mrp_mrm_behaviour(struct br_mrp *mrp)\n{\n\tif (mrp->ring_role == BR_MRP_RING_ROLE_MRM ||\n\t    (mrp->ring_role == BR_MRP_RING_ROLE_MRA && !mrp->test_monitor))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool br_mrp_mrc_behaviour(struct br_mrp *mrp)\n{\n\tif (mrp->ring_role == BR_MRP_RING_ROLE_MRC ||\n\t    (mrp->ring_role == BR_MRP_RING_ROLE_MRA && mrp->test_monitor))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int br_mrp_rcv(struct net_bridge_port *p,\n\t\t      struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_bridge_port *p_port, *s_port, *i_port = NULL;\n\tstruct net_bridge_port *p_dst, *s_dst, *i_dst = NULL;\n\tstruct net_bridge *br;\n\tstruct br_mrp *mrp;\n\n\t \n\tif (p->state == BR_STATE_DISABLED)\n\t\treturn 0;\n\n\tbr = p->br;\n\tmrp =  br_mrp_find_port(br, p);\n\tif (unlikely(!mrp))\n\t\treturn 0;\n\n\tp_port = rcu_dereference(mrp->p_port);\n\tif (!p_port)\n\t\treturn 0;\n\tp_dst = p_port;\n\n\ts_port = rcu_dereference(mrp->s_port);\n\tif (!s_port)\n\t\treturn 0;\n\ts_dst = s_port;\n\n\t \n\tif (br_mrp_ring_frame(skb)) {\n\t\t \n\t\tif (mrp->ring_role == BR_MRP_RING_ROLE_MRM) {\n\t\t\tbr_mrp_mrm_process(mrp, p, skb);\n\t\t\tgoto no_forward;\n\t\t}\n\n\t\t \n\t\tif (mrp->ring_role == BR_MRP_RING_ROLE_MRA) {\n\t\t\tif (!mrp->test_monitor) {\n\t\t\t\tbr_mrp_mrm_process(mrp, p, skb);\n\t\t\t\tgoto no_forward;\n\t\t\t}\n\n\t\t\tbr_mrp_mra_process(mrp, br, p, skb);\n\t\t}\n\n\t\tgoto forward;\n\t}\n\n\tif (br_mrp_in_frame(skb)) {\n\t\tu8 in_type = br_mrp_get_frame_type(skb);\n\n\t\ti_port = rcu_dereference(mrp->i_port);\n\t\ti_dst = i_port;\n\n\t\t \n\t\tif (br_mrp_is_ring_port(p_port, s_port, p) &&\n\t\t    p->state == BR_STATE_BLOCKING &&\n\t\t    in_type == BR_MRP_TLV_HEADER_IN_TEST)\n\t\t\tgoto no_forward;\n\n\t\t \n\t\tif (br_mrp_mrm_behaviour(mrp) &&\n\t\t    br_mrp_is_ring_port(p_port, s_port, p) &&\n\t\t    (s_port->state != BR_STATE_FORWARDING ||\n\t\t     p_port->state != BR_STATE_FORWARDING)) {\n\t\t\tp_dst = NULL;\n\t\t\ts_dst = NULL;\n\t\t}\n\n\t\t \n\t\tif (br_mrp_mrc_behaviour(mrp) &&\n\t\t    mrp->in_role == BR_MRP_IN_ROLE_DISABLED)\n\t\t\tgoto forward;\n\n\t\tif (mrp->in_role == BR_MRP_IN_ROLE_MIM) {\n\t\t\tif (in_type == BR_MRP_TLV_HEADER_IN_TEST) {\n\t\t\t\t \n\t\t\t\tif (br_mrp_mim_process(mrp, p, skb)) {\n\t\t\t\t\tgoto no_forward;\n\t\t\t\t} else {\n\t\t\t\t\tif (br_mrp_is_ring_port(p_port, s_port,\n\t\t\t\t\t\t\t\tp))\n\t\t\t\t\t\ti_dst = NULL;\n\n\t\t\t\t\tif (br_mrp_is_in_port(i_port, p))\n\t\t\t\t\t\tgoto no_forward;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (br_mrp_is_ring_port(p_port, s_port, p))\n\t\t\t\t\ti_dst = NULL;\n\n\t\t\t\tif (br_mrp_is_in_port(i_port, p))\n\t\t\t\t\tgoto no_forward;\n\t\t\t}\n\t\t}\n\n\t\tif (mrp->in_role == BR_MRP_IN_ROLE_MIC) {\n\t\t\t \n\t\t\tif (in_type == BR_MRP_TLV_HEADER_IN_TEST)\n\t\t\t\tgoto forward;\n\n\t\t\t \n\t\t\tif (br_mrp_is_ring_port(p_port, s_port, p) &&\n\t\t\t    (in_type == BR_MRP_TLV_HEADER_IN_LINK_UP ||\n\t\t\t     in_type == BR_MRP_TLV_HEADER_IN_LINK_DOWN))\n\t\t\t\tgoto forward;\n\n\t\t\t \n\t\t\tif (br_mrp_is_ring_port(p_port, s_port, p) &&\n\t\t\t    in_type == BR_MRP_TLV_HEADER_IN_LINK_STATUS) {\n\t\t\t\tp_dst = NULL;\n\t\t\t\ts_dst = NULL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (in_type == BR_MRP_TLV_HEADER_IN_TOPO) {\n\t\t\t\ti_dst = NULL;\n\t\t\t\tgoto forward;\n\t\t\t}\n\n\t\t\t \n\t\t\tgoto no_forward;\n\t\t}\n\t}\n\nforward:\n\tif (p_dst)\n\t\tbr_forward(p_dst, skb, true, false);\n\tif (s_dst)\n\t\tbr_forward(s_dst, skb, true, false);\n\tif (i_dst)\n\t\tbr_forward(i_dst, skb, true, false);\n\nno_forward:\n\treturn 1;\n}\n\n \nstatic int br_mrp_process(struct net_bridge_port *p, struct sk_buff *skb)\n{\n\t \n\tif (likely(!(p->flags & BR_MRP_AWARE)))\n\t\tgoto out;\n\n\treturn br_mrp_rcv(p, skb, p->dev);\nout:\n\treturn 0;\n}\n\nbool br_mrp_enabled(struct net_bridge *br)\n{\n\treturn !hlist_empty(&br->mrp_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}