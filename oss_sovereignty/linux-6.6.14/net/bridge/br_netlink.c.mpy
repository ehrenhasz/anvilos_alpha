{
  "module_name": "br_netlink.c",
  "hash_id": "183ae2b87034adec52b691e99102d1ff51ebef79313589a9cc710e40dc4de2ba",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_netlink.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/etherdevice.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <uapi/linux/if_bridge.h>\n\n#include \"br_private.h\"\n#include \"br_private_stp.h\"\n#include \"br_private_cfm.h\"\n#include \"br_private_tunnel.h\"\n#include \"br_private_mcast_eht.h\"\n\nstatic int __get_num_vlan_infos(struct net_bridge_vlan_group *vg,\n\t\t\t\tu32 filter_mask)\n{\n\tstruct net_bridge_vlan *v;\n\tu16 vid_range_start = 0, vid_range_end = 0, vid_range_flags = 0;\n\tu16 flags, pvid;\n\tint num_vlans = 0;\n\n\tif (!(filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED))\n\t\treturn 0;\n\n\tpvid = br_get_pvid(vg);\n\t \n\tlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\n\t\tflags = 0;\n\t\t \n\t\tif (!br_vlan_should_use(v))\n\t\t\tcontinue;\n\t\tif (v->vid == pvid)\n\t\t\tflags |= BRIDGE_VLAN_INFO_PVID;\n\n\t\tif (v->flags & BRIDGE_VLAN_INFO_UNTAGGED)\n\t\t\tflags |= BRIDGE_VLAN_INFO_UNTAGGED;\n\n\t\tif (vid_range_start == 0) {\n\t\t\tgoto initvars;\n\t\t} else if ((v->vid - vid_range_end) == 1 &&\n\t\t\tflags == vid_range_flags) {\n\t\t\tvid_range_end = v->vid;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif ((vid_range_end - vid_range_start) > 0)\n\t\t\t\tnum_vlans += 2;\n\t\t\telse\n\t\t\t\tnum_vlans += 1;\n\t\t}\ninitvars:\n\t\tvid_range_start = v->vid;\n\t\tvid_range_end = v->vid;\n\t\tvid_range_flags = flags;\n\t}\n\n\tif (vid_range_start != 0) {\n\t\tif ((vid_range_end - vid_range_start) > 0)\n\t\t\tnum_vlans += 2;\n\t\telse\n\t\t\tnum_vlans += 1;\n\t}\n\n\treturn num_vlans;\n}\n\nstatic int br_get_num_vlan_infos(struct net_bridge_vlan_group *vg,\n\t\t\t\t u32 filter_mask)\n{\n\tint num_vlans;\n\n\tif (!vg)\n\t\treturn 0;\n\n\tif (filter_mask & RTEXT_FILTER_BRVLAN)\n\t\treturn vg->num_vlans;\n\n\trcu_read_lock();\n\tnum_vlans = __get_num_vlan_infos(vg, filter_mask);\n\trcu_read_unlock();\n\n\treturn num_vlans;\n}\n\nstatic size_t br_get_link_af_size_filtered(const struct net_device *dev,\n\t\t\t\t\t   u32 filter_mask)\n{\n\tstruct net_bridge_vlan_group *vg = NULL;\n\tstruct net_bridge_port *p = NULL;\n\tstruct net_bridge *br = NULL;\n\tu32 num_cfm_peer_mep_infos;\n\tu32 num_cfm_mep_infos;\n\tsize_t vinfo_sz = 0;\n\tint num_vlan_infos;\n\n\trcu_read_lock();\n\tif (netif_is_bridge_port(dev)) {\n\t\tp = br_port_get_check_rcu(dev);\n\t\tif (p)\n\t\t\tvg = nbp_vlan_group_rcu(p);\n\t} else if (netif_is_bridge_master(dev)) {\n\t\tbr = netdev_priv(dev);\n\t\tvg = br_vlan_group_rcu(br);\n\t}\n\tnum_vlan_infos = br_get_num_vlan_infos(vg, filter_mask);\n\trcu_read_unlock();\n\n\tif (p && (p->flags & BR_VLAN_TUNNEL))\n\t\tvinfo_sz += br_get_vlan_tunnel_info_size(vg);\n\n\t \n\tvinfo_sz += num_vlan_infos * nla_total_size(sizeof(struct bridge_vlan_info));\n\n\tif (p && vg && (filter_mask & RTEXT_FILTER_MST))\n\t\tvinfo_sz += br_mst_info_size(vg);\n\n\tif (!(filter_mask & RTEXT_FILTER_CFM_STATUS))\n\t\treturn vinfo_sz;\n\n\tif (!br)\n\t\treturn vinfo_sz;\n\n\t \n\tbr_cfm_mep_count(br, &num_cfm_mep_infos);\n\tbr_cfm_peer_mep_count(br, &num_cfm_peer_mep_infos);\n\n\tvinfo_sz += nla_total_size(0);\t \n\t \n\t \n\tvinfo_sz += num_cfm_mep_infos *\n\t\t      \n\t\t    (nla_total_size(sizeof(u32))\n\t\t      \n\t\t     + nla_total_size(sizeof(u32))\n\t\t      \n\t\t     + nla_total_size(sizeof(u32))\n\t\t      \n\t\t     + nla_total_size(sizeof(u32)));\n\t \n\tvinfo_sz += num_cfm_peer_mep_infos *\n\t\t      \n\t\t    (nla_total_size(sizeof(u32))\n\t\t      \n\t\t     + nla_total_size(sizeof(u32))\n\t\t      \n\t\t     + nla_total_size(sizeof(u32))\n\t\t      \n\t\t     + nla_total_size(sizeof(u32))\n\t\t      \n\t\t     + nla_total_size(sizeof(u8))\n\t\t      \n\t\t     + nla_total_size(sizeof(u8))\n\t\t      \n\t\t     + nla_total_size(sizeof(u32))\n\t\t      \n\t\t     + nla_total_size(sizeof(u32))\n\t\t      \n\t\t     + nla_total_size(sizeof(u32)));\n\n\treturn vinfo_sz;\n}\n\nstatic inline size_t br_port_info_size(void)\n{\n\treturn nla_total_size(1)\t \n\t\t+ nla_total_size(2)\t \n\t\t+ nla_total_size(4)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(sizeof(struct ifla_bridge_id))\t \n\t\t+ nla_total_size(sizeof(struct ifla_bridge_id))\t \n\t\t+ nla_total_size(sizeof(u16))\t \n\t\t+ nla_total_size(sizeof(u16))\t \n\t\t+ nla_total_size(sizeof(u16))\t \n\t\t+ nla_total_size(sizeof(u16))\t \n\t\t+ nla_total_size(sizeof(u8))\t \n\t\t+ nla_total_size(sizeof(u8))\t \n\t\t+ nla_total_size_64bit(sizeof(u64))  \n\t\t+ nla_total_size_64bit(sizeof(u64))  \n\t\t+ nla_total_size_64bit(sizeof(u64))  \n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\t\t+ nla_total_size(sizeof(u8))\t \n\t\t+ nla_total_size(sizeof(u32))\t \n\t\t+ nla_total_size(sizeof(u32))\t \n#endif\n\t\t+ nla_total_size(sizeof(u16))\t \n\t\t+ nla_total_size(sizeof(u8))\t \n\t\t+ nla_total_size(sizeof(u8))\t \n\t\t+ nla_total_size(sizeof(u32))\t \n\t\t+ nla_total_size(sizeof(u32))\t \n\t\t+ nla_total_size(sizeof(u32))\t \n\t\t+ 0;\n}\n\nstatic inline size_t br_nlmsg_size(struct net_device *dev, u32 filter_mask)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t\t+ nla_total_size(IFNAMSIZ)  \n\t\t+ nla_total_size(MAX_ADDR_LEN)  \n\t\t+ nla_total_size(4)  \n\t\t+ nla_total_size(4)  \n\t\t+ nla_total_size(4)  \n\t\t+ nla_total_size(1)  \n\t\t+ nla_total_size(br_port_info_size())  \n\t\t+ nla_total_size(br_get_link_af_size_filtered(dev,\n\t\t\t\t filter_mask))  \n\t\t+ nla_total_size(4);  \n}\n\nstatic int br_port_fill_attrs(struct sk_buff *skb,\n\t\t\t      const struct net_bridge_port *p)\n{\n\tu8 mode = !!(p->flags & BR_HAIRPIN_MODE);\n\tstruct net_bridge_port *backup_p;\n\tu64 timerval;\n\n\tif (nla_put_u8(skb, IFLA_BRPORT_STATE, p->state) ||\n\t    nla_put_u16(skb, IFLA_BRPORT_PRIORITY, p->priority) ||\n\t    nla_put_u32(skb, IFLA_BRPORT_COST, p->path_cost) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_MODE, mode) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_GUARD, !!(p->flags & BR_BPDU_GUARD)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_PROTECT,\n\t\t       !!(p->flags & BR_ROOT_BLOCK)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_FAST_LEAVE,\n\t\t       !!(p->flags & BR_MULTICAST_FAST_LEAVE)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_MCAST_TO_UCAST,\n\t\t       !!(p->flags & BR_MULTICAST_TO_UNICAST)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_LEARNING, !!(p->flags & BR_LEARNING)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_UNICAST_FLOOD,\n\t\t       !!(p->flags & BR_FLOOD)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_MCAST_FLOOD,\n\t\t       !!(p->flags & BR_MCAST_FLOOD)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_BCAST_FLOOD,\n\t\t       !!(p->flags & BR_BCAST_FLOOD)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_PROXYARP, !!(p->flags & BR_PROXYARP)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_PROXYARP_WIFI,\n\t\t       !!(p->flags & BR_PROXYARP_WIFI)) ||\n\t    nla_put(skb, IFLA_BRPORT_ROOT_ID, sizeof(struct ifla_bridge_id),\n\t\t    &p->designated_root) ||\n\t    nla_put(skb, IFLA_BRPORT_BRIDGE_ID, sizeof(struct ifla_bridge_id),\n\t\t    &p->designated_bridge) ||\n\t    nla_put_u16(skb, IFLA_BRPORT_DESIGNATED_PORT, p->designated_port) ||\n\t    nla_put_u16(skb, IFLA_BRPORT_DESIGNATED_COST, p->designated_cost) ||\n\t    nla_put_u16(skb, IFLA_BRPORT_ID, p->port_id) ||\n\t    nla_put_u16(skb, IFLA_BRPORT_NO, p->port_no) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_TOPOLOGY_CHANGE_ACK,\n\t\t       p->topology_change_ack) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_CONFIG_PENDING, p->config_pending) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_VLAN_TUNNEL, !!(p->flags &\n\t\t\t\t\t\t\tBR_VLAN_TUNNEL)) ||\n\t    nla_put_u16(skb, IFLA_BRPORT_GROUP_FWD_MASK, p->group_fwd_mask) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_NEIGH_SUPPRESS,\n\t\t       !!(p->flags & BR_NEIGH_SUPPRESS)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_MRP_RING_OPEN, !!(p->flags &\n\t\t\t\t\t\t\t  BR_MRP_LOST_CONT)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_MRP_IN_OPEN,\n\t\t       !!(p->flags & BR_MRP_LOST_IN_CONT)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_ISOLATED, !!(p->flags & BR_ISOLATED)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_LOCKED, !!(p->flags & BR_PORT_LOCKED)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_MAB, !!(p->flags & BR_PORT_MAB)) ||\n\t    nla_put_u8(skb, IFLA_BRPORT_NEIGH_VLAN_SUPPRESS,\n\t\t       !!(p->flags & BR_NEIGH_VLAN_SUPPRESS)))\n\t\treturn -EMSGSIZE;\n\n\ttimerval = br_timer_value(&p->message_age_timer);\n\tif (nla_put_u64_64bit(skb, IFLA_BRPORT_MESSAGE_AGE_TIMER, timerval,\n\t\t\t      IFLA_BRPORT_PAD))\n\t\treturn -EMSGSIZE;\n\ttimerval = br_timer_value(&p->forward_delay_timer);\n\tif (nla_put_u64_64bit(skb, IFLA_BRPORT_FORWARD_DELAY_TIMER, timerval,\n\t\t\t      IFLA_BRPORT_PAD))\n\t\treturn -EMSGSIZE;\n\ttimerval = br_timer_value(&p->hold_timer);\n\tif (nla_put_u64_64bit(skb, IFLA_BRPORT_HOLD_TIMER, timerval,\n\t\t\t      IFLA_BRPORT_PAD))\n\t\treturn -EMSGSIZE;\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tif (nla_put_u8(skb, IFLA_BRPORT_MULTICAST_ROUTER,\n\t\t       p->multicast_ctx.multicast_router) ||\n\t    nla_put_u32(skb, IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT,\n\t\t\tp->multicast_eht_hosts_limit) ||\n\t    nla_put_u32(skb, IFLA_BRPORT_MCAST_EHT_HOSTS_CNT,\n\t\t\tp->multicast_eht_hosts_cnt) ||\n\t    nla_put_u32(skb, IFLA_BRPORT_MCAST_N_GROUPS,\n\t\t\tbr_multicast_ngroups_get(&p->multicast_ctx)) ||\n\t    nla_put_u32(skb, IFLA_BRPORT_MCAST_MAX_GROUPS,\n\t\t\tbr_multicast_ngroups_get_max(&p->multicast_ctx)))\n\t\treturn -EMSGSIZE;\n#endif\n\n\t \n\trcu_read_lock();\n\tbackup_p = rcu_dereference(p->backup_port);\n\tif (backup_p)\n\t\tnla_put_u32(skb, IFLA_BRPORT_BACKUP_PORT,\n\t\t\t    backup_p->dev->ifindex);\n\trcu_read_unlock();\n\n\tif (p->backup_nhid &&\n\t    nla_put_u32(skb, IFLA_BRPORT_BACKUP_NHID, p->backup_nhid))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int br_fill_ifvlaninfo_range(struct sk_buff *skb, u16 vid_start,\n\t\t\t\t    u16 vid_end, u16 flags)\n{\n\tstruct  bridge_vlan_info vinfo;\n\n\tif ((vid_end - vid_start) > 0) {\n\t\t \n\t\tvinfo.vid = vid_start;\n\t\tvinfo.flags = flags | BRIDGE_VLAN_INFO_RANGE_BEGIN;\n\t\tif (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,\n\t\t\t    sizeof(vinfo), &vinfo))\n\t\t\tgoto nla_put_failure;\n\n\t\tvinfo.vid = vid_end;\n\t\tvinfo.flags = flags | BRIDGE_VLAN_INFO_RANGE_END;\n\t\tif (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,\n\t\t\t    sizeof(vinfo), &vinfo))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tvinfo.vid = vid_start;\n\t\tvinfo.flags = flags;\n\t\tif (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,\n\t\t\t    sizeof(vinfo), &vinfo))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int br_fill_ifvlaninfo_compressed(struct sk_buff *skb,\n\t\t\t\t\t struct net_bridge_vlan_group *vg)\n{\n\tstruct net_bridge_vlan *v;\n\tu16 vid_range_start = 0, vid_range_end = 0, vid_range_flags = 0;\n\tu16 flags, pvid;\n\tint err = 0;\n\n\t \n\tpvid = br_get_pvid(vg);\n\tlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\n\t\tflags = 0;\n\t\tif (!br_vlan_should_use(v))\n\t\t\tcontinue;\n\t\tif (v->vid == pvid)\n\t\t\tflags |= BRIDGE_VLAN_INFO_PVID;\n\n\t\tif (v->flags & BRIDGE_VLAN_INFO_UNTAGGED)\n\t\t\tflags |= BRIDGE_VLAN_INFO_UNTAGGED;\n\n\t\tif (vid_range_start == 0) {\n\t\t\tgoto initvars;\n\t\t} else if ((v->vid - vid_range_end) == 1 &&\n\t\t\tflags == vid_range_flags) {\n\t\t\tvid_range_end = v->vid;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\terr = br_fill_ifvlaninfo_range(skb, vid_range_start,\n\t\t\t\t\t\t       vid_range_end,\n\t\t\t\t\t\t       vid_range_flags);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\ninitvars:\n\t\tvid_range_start = v->vid;\n\t\tvid_range_end = v->vid;\n\t\tvid_range_flags = flags;\n\t}\n\n\tif (vid_range_start != 0) {\n\t\t \n\t\terr = br_fill_ifvlaninfo_range(skb, vid_range_start,\n\t\t\t\t\t       vid_range_end,\n\t\t\t\t\t       vid_range_flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int br_fill_ifvlaninfo(struct sk_buff *skb,\n\t\t\t      struct net_bridge_vlan_group *vg)\n{\n\tstruct bridge_vlan_info vinfo;\n\tstruct net_bridge_vlan *v;\n\tu16 pvid;\n\n\tpvid = br_get_pvid(vg);\n\tlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\n\t\tif (!br_vlan_should_use(v))\n\t\t\tcontinue;\n\n\t\tvinfo.vid = v->vid;\n\t\tvinfo.flags = 0;\n\t\tif (v->vid == pvid)\n\t\t\tvinfo.flags |= BRIDGE_VLAN_INFO_PVID;\n\n\t\tif (v->flags & BRIDGE_VLAN_INFO_UNTAGGED)\n\t\t\tvinfo.flags |= BRIDGE_VLAN_INFO_UNTAGGED;\n\n\t\tif (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,\n\t\t\t    sizeof(vinfo), &vinfo))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\n \nstatic int br_fill_ifinfo(struct sk_buff *skb,\n\t\t\t  const struct net_bridge_port *port,\n\t\t\t  u32 pid, u32 seq, int event, unsigned int flags,\n\t\t\t  u32 filter_mask, const struct net_device *dev,\n\t\t\t  bool getlink)\n{\n\tu8 operstate = netif_running(dev) ? dev->operstate : IF_OPER_DOWN;\n\tstruct nlattr *af = NULL;\n\tstruct net_bridge *br;\n\tstruct ifinfomsg *hdr;\n\tstruct nlmsghdr *nlh;\n\n\tif (port)\n\t\tbr = port->br;\n\telse\n\t\tbr = netdev_priv(dev);\n\n\tbr_debug(br, \"br_fill_info event %d port %s master %s\\n\",\n\t\t     event, dev->name, br->dev->name);\n\n\tnlh = nlmsg_put(skb, pid, seq, event, sizeof(*hdr), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\thdr = nlmsg_data(nlh);\n\thdr->ifi_family = AF_BRIDGE;\n\thdr->__ifi_pad = 0;\n\thdr->ifi_type = dev->type;\n\thdr->ifi_index = dev->ifindex;\n\thdr->ifi_flags = dev_get_flags(dev);\n\thdr->ifi_change = 0;\n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    nla_put_u32(skb, IFLA_MASTER, br->dev->ifindex) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE, operstate) ||\n\t    (dev->addr_len &&\n\t     nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||\n\t    (dev->ifindex != dev_get_iflink(dev) &&\n\t     nla_put_u32(skb, IFLA_LINK, dev_get_iflink(dev))))\n\t\tgoto nla_put_failure;\n\n\tif (event == RTM_NEWLINK && port) {\n\t\tstruct nlattr *nest;\n\n\t\tnest = nla_nest_start(skb, IFLA_PROTINFO);\n\t\tif (nest == NULL || br_port_fill_attrs(skb, port) < 0)\n\t\t\tgoto nla_put_failure;\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\tif (filter_mask & (RTEXT_FILTER_BRVLAN |\n\t\t\t   RTEXT_FILTER_BRVLAN_COMPRESSED |\n\t\t\t   RTEXT_FILTER_MRP |\n\t\t\t   RTEXT_FILTER_CFM_CONFIG |\n\t\t\t   RTEXT_FILTER_CFM_STATUS |\n\t\t\t   RTEXT_FILTER_MST)) {\n\t\taf = nla_nest_start_noflag(skb, IFLA_AF_SPEC);\n\t\tif (!af)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\t \n\tif ((filter_mask & RTEXT_FILTER_BRVLAN) ||\n\t    (filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED)) {\n\t\tstruct net_bridge_vlan_group *vg;\n\t\tint err;\n\n\t\t \n\t\trcu_read_lock();\n\t\tif (port)\n\t\t\tvg = nbp_vlan_group_rcu(port);\n\t\telse\n\t\t\tvg = br_vlan_group_rcu(br);\n\n\t\tif (!vg || !vg->num_vlans) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto done;\n\t\t}\n\t\tif (filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED)\n\t\t\terr = br_fill_ifvlaninfo_compressed(skb, vg);\n\t\telse\n\t\t\terr = br_fill_ifvlaninfo(skb, vg);\n\n\t\tif (port && (port->flags & BR_VLAN_TUNNEL))\n\t\t\terr = br_fill_vlan_tunnel_info(skb, vg);\n\t\trcu_read_unlock();\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (filter_mask & RTEXT_FILTER_MRP) {\n\t\tint err;\n\n\t\tif (!br_mrp_enabled(br) || port)\n\t\t\tgoto done;\n\n\t\trcu_read_lock();\n\t\terr = br_mrp_fill_info(skb, br);\n\t\trcu_read_unlock();\n\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (filter_mask & (RTEXT_FILTER_CFM_CONFIG | RTEXT_FILTER_CFM_STATUS)) {\n\t\tstruct nlattr *cfm_nest = NULL;\n\t\tint err;\n\n\t\tif (!br_cfm_created(br) || port)\n\t\t\tgoto done;\n\n\t\tcfm_nest = nla_nest_start(skb, IFLA_BRIDGE_CFM);\n\t\tif (!cfm_nest)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (filter_mask & RTEXT_FILTER_CFM_CONFIG) {\n\t\t\trcu_read_lock();\n\t\t\terr = br_cfm_config_fill_info(skb, br);\n\t\t\trcu_read_unlock();\n\t\t\tif (err)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tif (filter_mask & RTEXT_FILTER_CFM_STATUS) {\n\t\t\trcu_read_lock();\n\t\t\terr = br_cfm_status_fill_info(skb, br, getlink);\n\t\t\trcu_read_unlock();\n\t\t\tif (err)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tnla_nest_end(skb, cfm_nest);\n\t}\n\n\tif ((filter_mask & RTEXT_FILTER_MST) &&\n\t    br_opt_get(br, BROPT_MST_ENABLED) && port) {\n\t\tconst struct net_bridge_vlan_group *vg = nbp_vlan_group(port);\n\t\tstruct nlattr *mst_nest;\n\t\tint err;\n\n\t\tif (!vg || !vg->num_vlans)\n\t\t\tgoto done;\n\n\t\tmst_nest = nla_nest_start(skb, IFLA_BRIDGE_MST);\n\t\tif (!mst_nest)\n\t\t\tgoto nla_put_failure;\n\n\t\terr = br_mst_fill_info(skb, vg);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, mst_nest);\n\t}\n\ndone:\n\tif (af) {\n\t\tif (nlmsg_get_pos(skb) - (void *)af > nla_attr_size(0))\n\t\t\tnla_nest_end(skb, af);\n\t\telse\n\t\t\tnla_nest_cancel(skb, af);\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nvoid br_info_notify(int event, const struct net_bridge *br,\n\t\t    const struct net_bridge_port *port, u32 filter)\n{\n\tstruct net_device *dev;\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\tstruct net *net;\n\tu16 port_no = 0;\n\n\tif (WARN_ON(!port && !br))\n\t\treturn;\n\n\tif (port) {\n\t\tdev = port->dev;\n\t\tbr = port->br;\n\t\tport_no = port->port_no;\n\t} else {\n\t\tdev = br->dev;\n\t}\n\n\tnet = dev_net(dev);\n\tbr_debug(br, \"port %u(%s) event %d\\n\", port_no, dev->name, event);\n\n\tskb = nlmsg_new(br_nlmsg_size(dev, filter), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = br_fill_ifinfo(skb, port, 0, 0, event, 0, filter, dev, false);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n}\n\n \nvoid br_ifinfo_notify(int event, const struct net_bridge *br,\n\t\t      const struct net_bridge_port *port)\n{\n\tu32 filter = RTEXT_FILTER_BRVLAN_COMPRESSED;\n\n\treturn br_info_notify(event, br, port, filter);\n}\n\n \nint br_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t       struct net_device *dev, u32 filter_mask, int nlflags)\n{\n\tstruct net_bridge_port *port = br_port_get_rtnl(dev);\n\n\tif (!port && !(filter_mask & RTEXT_FILTER_BRVLAN) &&\n\t    !(filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED) &&\n\t    !(filter_mask & RTEXT_FILTER_MRP) &&\n\t    !(filter_mask & RTEXT_FILTER_CFM_CONFIG) &&\n\t    !(filter_mask & RTEXT_FILTER_CFM_STATUS))\n\t\treturn 0;\n\n\treturn br_fill_ifinfo(skb, port, pid, seq, RTM_NEWLINK, nlflags,\n\t\t\t      filter_mask, dev, true);\n}\n\nstatic int br_vlan_info(struct net_bridge *br, struct net_bridge_port *p,\n\t\t\tint cmd, struct bridge_vlan_info *vinfo, bool *changed,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbool curr_change;\n\tint err = 0;\n\n\tswitch (cmd) {\n\tcase RTM_SETLINK:\n\t\tif (p) {\n\t\t\t \n\t\t\terr = nbp_vlan_add(p, vinfo->vid, vinfo->flags,\n\t\t\t\t\t   &curr_change, extack);\n\t\t} else {\n\t\t\tvinfo->flags |= BRIDGE_VLAN_INFO_BRENTRY;\n\t\t\terr = br_vlan_add(br, vinfo->vid, vinfo->flags,\n\t\t\t\t\t  &curr_change, extack);\n\t\t}\n\t\tif (curr_change)\n\t\t\t*changed = true;\n\t\tbreak;\n\n\tcase RTM_DELLINK:\n\t\tif (p) {\n\t\t\tif (!nbp_vlan_delete(p, vinfo->vid))\n\t\t\t\t*changed = true;\n\n\t\t\tif ((vinfo->flags & BRIDGE_VLAN_INFO_MASTER) &&\n\t\t\t    !br_vlan_delete(p->br, vinfo->vid))\n\t\t\t\t*changed = true;\n\t\t} else if (!br_vlan_delete(br, vinfo->vid)) {\n\t\t\t*changed = true;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint br_process_vlan_info(struct net_bridge *br,\n\t\t\t struct net_bridge_port *p, int cmd,\n\t\t\t struct bridge_vlan_info *vinfo_curr,\n\t\t\t struct bridge_vlan_info **vinfo_last,\n\t\t\t bool *changed,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err, rtm_cmd;\n\n\tif (!br_vlan_valid_id(vinfo_curr->vid, extack))\n\t\treturn -EINVAL;\n\n\t \n\trtm_cmd = br_afspec_cmd_to_rtm(cmd);\n\n\tif (vinfo_curr->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {\n\t\tif (!br_vlan_valid_range(vinfo_curr, *vinfo_last, extack))\n\t\t\treturn -EINVAL;\n\t\t*vinfo_last = vinfo_curr;\n\t\treturn 0;\n\t}\n\n\tif (*vinfo_last) {\n\t\tstruct bridge_vlan_info tmp_vinfo;\n\t\tint v, v_change_start = 0;\n\n\t\tif (!br_vlan_valid_range(vinfo_curr, *vinfo_last, extack))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&tmp_vinfo, *vinfo_last,\n\t\t       sizeof(struct bridge_vlan_info));\n\t\tfor (v = (*vinfo_last)->vid; v <= vinfo_curr->vid; v++) {\n\t\t\tbool curr_change = false;\n\n\t\t\ttmp_vinfo.vid = v;\n\t\t\terr = br_vlan_info(br, p, cmd, &tmp_vinfo, &curr_change,\n\t\t\t\t\t   extack);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (curr_change) {\n\t\t\t\t*changed = curr_change;\n\t\t\t\tif (!v_change_start)\n\t\t\t\t\tv_change_start = v;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (!v_change_start)\n\t\t\t\t\tcontinue;\n\t\t\t\tbr_vlan_notify(br, p, v_change_start,\n\t\t\t\t\t       v - 1, rtm_cmd);\n\t\t\t\tv_change_start = 0;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t\t \n\t\tif (v_change_start)\n\t\t\tbr_vlan_notify(br, p, v_change_start,\n\t\t\t\t       v - 1, rtm_cmd);\n\n\t\t*vinfo_last = NULL;\n\n\t\treturn err;\n\t}\n\n\terr = br_vlan_info(br, p, cmd, vinfo_curr, changed, extack);\n\tif (*changed)\n\t\tbr_vlan_notify(br, p, vinfo_curr->vid, 0, rtm_cmd);\n\n\treturn err;\n}\n\nstatic int br_afspec(struct net_bridge *br,\n\t\t     struct net_bridge_port *p,\n\t\t     struct nlattr *af_spec,\n\t\t     int cmd, bool *changed,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bridge_vlan_info *vinfo_curr = NULL;\n\tstruct bridge_vlan_info *vinfo_last = NULL;\n\tstruct nlattr *attr;\n\tstruct vtunnel_info tinfo_last = {};\n\tstruct vtunnel_info tinfo_curr = {};\n\tint err = 0, rem;\n\n\tnla_for_each_nested(attr, af_spec, rem) {\n\t\terr = 0;\n\t\tswitch (nla_type(attr)) {\n\t\tcase IFLA_BRIDGE_VLAN_TUNNEL_INFO:\n\t\t\tif (!p || !(p->flags & BR_VLAN_TUNNEL))\n\t\t\t\treturn -EINVAL;\n\t\t\terr = br_parse_vlan_tunnel_info(attr, &tinfo_curr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = br_process_vlan_tunnel_info(br, p, cmd,\n\t\t\t\t\t\t\t  &tinfo_curr,\n\t\t\t\t\t\t\t  &tinfo_last,\n\t\t\t\t\t\t\t  changed);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase IFLA_BRIDGE_VLAN_INFO:\n\t\t\tif (nla_len(attr) != sizeof(struct bridge_vlan_info))\n\t\t\t\treturn -EINVAL;\n\t\t\tvinfo_curr = nla_data(attr);\n\t\t\terr = br_process_vlan_info(br, p, cmd, vinfo_curr,\n\t\t\t\t\t\t   &vinfo_last, changed,\n\t\t\t\t\t\t   extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase IFLA_BRIDGE_MRP:\n\t\t\terr = br_mrp_parse(br, p, attr, cmd, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase IFLA_BRIDGE_CFM:\n\t\t\terr = br_cfm_parse(br, p, attr, cmd, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase IFLA_BRIDGE_MST:\n\t\t\tif (!p) {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"MST states can only be set on bridge ports\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (cmd != RTM_SETLINK) {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"MST states can only be set through RTM_SETLINK\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\terr = br_mst_process(p, attr, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic const struct nla_policy br_port_policy[IFLA_BRPORT_MAX + 1] = {\n\t[IFLA_BRPORT_UNSPEC]\t= { .strict_start_type =\n\t\t\t\t\tIFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT + 1 },\n\t[IFLA_BRPORT_STATE]\t= { .type = NLA_U8 },\n\t[IFLA_BRPORT_COST]\t= { .type = NLA_U32 },\n\t[IFLA_BRPORT_PRIORITY]\t= { .type = NLA_U16 },\n\t[IFLA_BRPORT_MODE]\t= { .type = NLA_U8 },\n\t[IFLA_BRPORT_GUARD]\t= { .type = NLA_U8 },\n\t[IFLA_BRPORT_PROTECT]\t= { .type = NLA_U8 },\n\t[IFLA_BRPORT_FAST_LEAVE]= { .type = NLA_U8 },\n\t[IFLA_BRPORT_LEARNING]\t= { .type = NLA_U8 },\n\t[IFLA_BRPORT_UNICAST_FLOOD] = { .type = NLA_U8 },\n\t[IFLA_BRPORT_PROXYARP]\t= { .type = NLA_U8 },\n\t[IFLA_BRPORT_PROXYARP_WIFI] = { .type = NLA_U8 },\n\t[IFLA_BRPORT_MULTICAST_ROUTER] = { .type = NLA_U8 },\n\t[IFLA_BRPORT_MCAST_TO_UCAST] = { .type = NLA_U8 },\n\t[IFLA_BRPORT_MCAST_FLOOD] = { .type = NLA_U8 },\n\t[IFLA_BRPORT_BCAST_FLOOD] = { .type = NLA_U8 },\n\t[IFLA_BRPORT_VLAN_TUNNEL] = { .type = NLA_U8 },\n\t[IFLA_BRPORT_GROUP_FWD_MASK] = { .type = NLA_U16 },\n\t[IFLA_BRPORT_NEIGH_SUPPRESS] = { .type = NLA_U8 },\n\t[IFLA_BRPORT_ISOLATED]\t= { .type = NLA_U8 },\n\t[IFLA_BRPORT_LOCKED] = { .type = NLA_U8 },\n\t[IFLA_BRPORT_MAB] = { .type = NLA_U8 },\n\t[IFLA_BRPORT_BACKUP_PORT] = { .type = NLA_U32 },\n\t[IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT] = { .type = NLA_U32 },\n\t[IFLA_BRPORT_MCAST_N_GROUPS] = { .type = NLA_REJECT },\n\t[IFLA_BRPORT_MCAST_MAX_GROUPS] = { .type = NLA_U32 },\n\t[IFLA_BRPORT_NEIGH_VLAN_SUPPRESS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[IFLA_BRPORT_BACKUP_NHID] = { .type = NLA_U32 },\n};\n\n \nstatic int br_set_port_state(struct net_bridge_port *p, u8 state)\n{\n\tif (state > BR_STATE_BLOCKING)\n\t\treturn -EINVAL;\n\n\t \n\tif (p->br->stp_enabled == BR_KERNEL_STP)\n\t\treturn -EBUSY;\n\n\t \n\tif (!netif_running(p->dev) ||\n\t    (!netif_oper_up(p->dev) && state != BR_STATE_DISABLED))\n\t\treturn -ENETDOWN;\n\n\tbr_set_state(p, state);\n\tbr_port_state_selection(p->br);\n\treturn 0;\n}\n\n \nstatic void br_set_port_flag(struct net_bridge_port *p, struct nlattr *tb[],\n\t\t\t     int attrtype, unsigned long mask)\n{\n\tif (!tb[attrtype])\n\t\treturn;\n\n\tif (nla_get_u8(tb[attrtype]))\n\t\tp->flags |= mask;\n\telse\n\t\tp->flags &= ~mask;\n}\n\n \nstatic int br_setport(struct net_bridge_port *p, struct nlattr *tb[],\n\t\t      struct netlink_ext_ack *extack)\n{\n\tunsigned long old_flags, changed_mask;\n\tbool br_vlan_tunnel_old;\n\tint err;\n\n\told_flags = p->flags;\n\tbr_vlan_tunnel_old = (old_flags & BR_VLAN_TUNNEL) ? true : false;\n\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_MODE, BR_HAIRPIN_MODE);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_GUARD, BR_BPDU_GUARD);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_FAST_LEAVE,\n\t\t\t BR_MULTICAST_FAST_LEAVE);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_PROTECT, BR_ROOT_BLOCK);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_LEARNING, BR_LEARNING);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_UNICAST_FLOOD, BR_FLOOD);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_MCAST_FLOOD, BR_MCAST_FLOOD);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_MCAST_TO_UCAST,\n\t\t\t BR_MULTICAST_TO_UNICAST);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_BCAST_FLOOD, BR_BCAST_FLOOD);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_PROXYARP, BR_PROXYARP);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_PROXYARP_WIFI, BR_PROXYARP_WIFI);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_VLAN_TUNNEL, BR_VLAN_TUNNEL);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_NEIGH_SUPPRESS, BR_NEIGH_SUPPRESS);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_ISOLATED, BR_ISOLATED);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_LOCKED, BR_PORT_LOCKED);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_MAB, BR_PORT_MAB);\n\tbr_set_port_flag(p, tb, IFLA_BRPORT_NEIGH_VLAN_SUPPRESS,\n\t\t\t BR_NEIGH_VLAN_SUPPRESS);\n\n\tif ((p->flags & BR_PORT_MAB) &&\n\t    (!(p->flags & BR_PORT_LOCKED) || !(p->flags & BR_LEARNING))) {\n\t\tNL_SET_ERR_MSG(extack, \"Bridge port must be locked and have learning enabled when MAB is enabled\");\n\t\tp->flags = old_flags;\n\t\treturn -EINVAL;\n\t} else if (!(p->flags & BR_PORT_MAB) && (old_flags & BR_PORT_MAB)) {\n\t\tstruct net_bridge_fdb_flush_desc desc = {\n\t\t\t.flags = BIT(BR_FDB_LOCKED),\n\t\t\t.flags_mask = BIT(BR_FDB_LOCKED),\n\t\t\t.port_ifindex = p->dev->ifindex,\n\t\t};\n\n\t\tbr_fdb_flush(p->br, &desc);\n\t}\n\n\tchanged_mask = old_flags ^ p->flags;\n\n\terr = br_switchdev_set_port_flag(p, p->flags, changed_mask, extack);\n\tif (err) {\n\t\tp->flags = old_flags;\n\t\treturn err;\n\t}\n\n\tif (br_vlan_tunnel_old && !(p->flags & BR_VLAN_TUNNEL))\n\t\tnbp_vlan_tunnel_info_flush(p);\n\n\tbr_port_flags_change(p, changed_mask);\n\n\tif (tb[IFLA_BRPORT_COST]) {\n\t\terr = br_stp_set_path_cost(p, nla_get_u32(tb[IFLA_BRPORT_COST]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRPORT_PRIORITY]) {\n\t\terr = br_stp_set_port_priority(p, nla_get_u16(tb[IFLA_BRPORT_PRIORITY]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRPORT_STATE]) {\n\t\terr = br_set_port_state(p, nla_get_u8(tb[IFLA_BRPORT_STATE]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRPORT_FLUSH])\n\t\tbr_fdb_delete_by_port(p->br, p, 0, 0);\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tif (tb[IFLA_BRPORT_MULTICAST_ROUTER]) {\n\t\tu8 mcast_router = nla_get_u8(tb[IFLA_BRPORT_MULTICAST_ROUTER]);\n\n\t\terr = br_multicast_set_port_router(&p->multicast_ctx,\n\t\t\t\t\t\t   mcast_router);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT]) {\n\t\tu32 hlimit;\n\n\t\thlimit = nla_get_u32(tb[IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT]);\n\t\terr = br_multicast_eht_set_hosts_limit(p, hlimit);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRPORT_MCAST_MAX_GROUPS]) {\n\t\tu32 max_groups;\n\n\t\tmax_groups = nla_get_u32(tb[IFLA_BRPORT_MCAST_MAX_GROUPS]);\n\t\tbr_multicast_ngroups_set_max(&p->multicast_ctx, max_groups);\n\t}\n#endif\n\n\tif (tb[IFLA_BRPORT_GROUP_FWD_MASK]) {\n\t\tu16 fwd_mask = nla_get_u16(tb[IFLA_BRPORT_GROUP_FWD_MASK]);\n\n\t\tif (fwd_mask & BR_GROUPFWD_MACPAUSE)\n\t\t\treturn -EINVAL;\n\t\tp->group_fwd_mask = fwd_mask;\n\t}\n\n\tif (tb[IFLA_BRPORT_BACKUP_PORT]) {\n\t\tstruct net_device *backup_dev = NULL;\n\t\tu32 backup_ifindex;\n\n\t\tbackup_ifindex = nla_get_u32(tb[IFLA_BRPORT_BACKUP_PORT]);\n\t\tif (backup_ifindex) {\n\t\t\tbackup_dev = __dev_get_by_index(dev_net(p->dev),\n\t\t\t\t\t\t\tbackup_ifindex);\n\t\t\tif (!backup_dev)\n\t\t\t\treturn -ENOENT;\n\t\t}\n\n\t\terr = nbp_backup_change(p, backup_dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRPORT_BACKUP_NHID]) {\n\t\tu32 backup_nhid = nla_get_u32(tb[IFLA_BRPORT_BACKUP_NHID]);\n\n\t\tWRITE_ONCE(p->backup_nhid, backup_nhid);\n\t}\n\n\treturn 0;\n}\n\n \nint br_setlink(struct net_device *dev, struct nlmsghdr *nlh, u16 flags,\n\t       struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge *br = (struct net_bridge *)netdev_priv(dev);\n\tstruct nlattr *tb[IFLA_BRPORT_MAX + 1];\n\tstruct net_bridge_port *p;\n\tstruct nlattr *protinfo;\n\tstruct nlattr *afspec;\n\tbool changed = false;\n\tint err = 0;\n\n\tprotinfo = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_PROTINFO);\n\tafspec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (!protinfo && !afspec)\n\t\treturn 0;\n\n\tp = br_port_get_rtnl(dev);\n\t \n\tif (!p && !afspec)\n\t\treturn -EINVAL;\n\n\tif (p && protinfo) {\n\t\tif (protinfo->nla_type & NLA_F_NESTED) {\n\t\t\terr = nla_parse_nested_deprecated(tb, IFLA_BRPORT_MAX,\n\t\t\t\t\t\t\t  protinfo,\n\t\t\t\t\t\t\t  br_port_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tspin_lock_bh(&p->br->lock);\n\t\t\terr = br_setport(p, tb, extack);\n\t\t\tspin_unlock_bh(&p->br->lock);\n\t\t} else {\n\t\t\t \n\t\t\tif (nla_len(protinfo) < sizeof(u8))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tspin_lock_bh(&p->br->lock);\n\t\t\terr = br_set_port_state(p, nla_get_u8(protinfo));\n\t\t\tspin_unlock_bh(&p->br->lock);\n\t\t}\n\t\tif (err)\n\t\t\tgoto out;\n\t\tchanged = true;\n\t}\n\n\tif (afspec)\n\t\terr = br_afspec(br, p, afspec, RTM_SETLINK, &changed, extack);\n\n\tif (changed)\n\t\tbr_ifinfo_notify(RTM_NEWLINK, br, p);\nout:\n\treturn err;\n}\n\n \nint br_dellink(struct net_device *dev, struct nlmsghdr *nlh, u16 flags)\n{\n\tstruct net_bridge *br = (struct net_bridge *)netdev_priv(dev);\n\tstruct net_bridge_port *p;\n\tstruct nlattr *afspec;\n\tbool changed = false;\n\tint err = 0;\n\n\tafspec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (!afspec)\n\t\treturn 0;\n\n\tp = br_port_get_rtnl(dev);\n\t \n\tif (!p && !netif_is_bridge_master(dev))\n\t\treturn -EINVAL;\n\n\terr = br_afspec(br, p, afspec, RTM_DELLINK, &changed, NULL);\n\tif (changed)\n\t\t \n\t\tbr_ifinfo_notify(RTM_NEWLINK, br, p);\n\n\treturn err;\n}\n\nstatic int br_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t       struct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (!data)\n\t\treturn 0;\n\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\n\tif (data[IFLA_BR_VLAN_PROTOCOL] &&\n\t    !eth_type_vlan(nla_get_be16(data[IFLA_BR_VLAN_PROTOCOL])))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (data[IFLA_BR_VLAN_DEFAULT_PVID]) {\n\t\t__u16 defpvid = nla_get_u16(data[IFLA_BR_VLAN_DEFAULT_PVID]);\n\n\t\tif (defpvid >= VLAN_VID_MASK)\n\t\t\treturn -EINVAL;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int br_port_slave_changelink(struct net_device *brdev,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    struct nlattr *tb[],\n\t\t\t\t    struct nlattr *data[],\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge *br = netdev_priv(brdev);\n\tint ret;\n\n\tif (!data)\n\t\treturn 0;\n\n\tspin_lock_bh(&br->lock);\n\tret = br_setport(br_port_get_rtnl(dev), data, extack);\n\tspin_unlock_bh(&br->lock);\n\n\treturn ret;\n}\n\nstatic int br_port_fill_slave_info(struct sk_buff *skb,\n\t\t\t\t   const struct net_device *brdev,\n\t\t\t\t   const struct net_device *dev)\n{\n\treturn br_port_fill_attrs(skb, br_port_get_rtnl(dev));\n}\n\nstatic size_t br_port_get_slave_size(const struct net_device *brdev,\n\t\t\t\t     const struct net_device *dev)\n{\n\treturn br_port_info_size();\n}\n\nstatic const struct nla_policy br_policy[IFLA_BR_MAX + 1] = {\n\t[IFLA_BR_FORWARD_DELAY]\t= { .type = NLA_U32 },\n\t[IFLA_BR_HELLO_TIME]\t= { .type = NLA_U32 },\n\t[IFLA_BR_MAX_AGE]\t= { .type = NLA_U32 },\n\t[IFLA_BR_AGEING_TIME] = { .type = NLA_U32 },\n\t[IFLA_BR_STP_STATE] = { .type = NLA_U32 },\n\t[IFLA_BR_PRIORITY] = { .type = NLA_U16 },\n\t[IFLA_BR_VLAN_FILTERING] = { .type = NLA_U8 },\n\t[IFLA_BR_VLAN_PROTOCOL] = { .type = NLA_U16 },\n\t[IFLA_BR_GROUP_FWD_MASK] = { .type = NLA_U16 },\n\t[IFLA_BR_GROUP_ADDR] = { .type = NLA_BINARY,\n\t\t\t\t .len  = ETH_ALEN },\n\t[IFLA_BR_MCAST_ROUTER] = { .type = NLA_U8 },\n\t[IFLA_BR_MCAST_SNOOPING] = { .type = NLA_U8 },\n\t[IFLA_BR_MCAST_QUERY_USE_IFADDR] = { .type = NLA_U8 },\n\t[IFLA_BR_MCAST_QUERIER] = { .type = NLA_U8 },\n\t[IFLA_BR_MCAST_HASH_ELASTICITY] = { .type = NLA_U32 },\n\t[IFLA_BR_MCAST_HASH_MAX] = { .type = NLA_U32 },\n\t[IFLA_BR_MCAST_LAST_MEMBER_CNT] = { .type = NLA_U32 },\n\t[IFLA_BR_MCAST_STARTUP_QUERY_CNT] = { .type = NLA_U32 },\n\t[IFLA_BR_MCAST_LAST_MEMBER_INTVL] = { .type = NLA_U64 },\n\t[IFLA_BR_MCAST_MEMBERSHIP_INTVL] = { .type = NLA_U64 },\n\t[IFLA_BR_MCAST_QUERIER_INTVL] = { .type = NLA_U64 },\n\t[IFLA_BR_MCAST_QUERY_INTVL] = { .type = NLA_U64 },\n\t[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL] = { .type = NLA_U64 },\n\t[IFLA_BR_MCAST_STARTUP_QUERY_INTVL] = { .type = NLA_U64 },\n\t[IFLA_BR_NF_CALL_IPTABLES] = { .type = NLA_U8 },\n\t[IFLA_BR_NF_CALL_IP6TABLES] = { .type = NLA_U8 },\n\t[IFLA_BR_NF_CALL_ARPTABLES] = { .type = NLA_U8 },\n\t[IFLA_BR_VLAN_DEFAULT_PVID] = { .type = NLA_U16 },\n\t[IFLA_BR_VLAN_STATS_ENABLED] = { .type = NLA_U8 },\n\t[IFLA_BR_MCAST_STATS_ENABLED] = { .type = NLA_U8 },\n\t[IFLA_BR_MCAST_IGMP_VERSION] = { .type = NLA_U8 },\n\t[IFLA_BR_MCAST_MLD_VERSION] = { .type = NLA_U8 },\n\t[IFLA_BR_VLAN_STATS_PER_PORT] = { .type = NLA_U8 },\n\t[IFLA_BR_MULTI_BOOLOPT] =\n\t\tNLA_POLICY_EXACT_LEN(sizeof(struct br_boolopt_multi)),\n};\n\nstatic int br_changelink(struct net_device *brdev, struct nlattr *tb[],\n\t\t\t struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge *br = netdev_priv(brdev);\n\tint err;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_BR_FORWARD_DELAY]) {\n\t\terr = br_set_forward_delay(br, nla_get_u32(data[IFLA_BR_FORWARD_DELAY]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_HELLO_TIME]) {\n\t\terr = br_set_hello_time(br, nla_get_u32(data[IFLA_BR_HELLO_TIME]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_MAX_AGE]) {\n\t\terr = br_set_max_age(br, nla_get_u32(data[IFLA_BR_MAX_AGE]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_AGEING_TIME]) {\n\t\terr = br_set_ageing_time(br, nla_get_u32(data[IFLA_BR_AGEING_TIME]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_STP_STATE]) {\n\t\tu32 stp_enabled = nla_get_u32(data[IFLA_BR_STP_STATE]);\n\n\t\terr = br_stp_set_enabled(br, stp_enabled, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_PRIORITY]) {\n\t\tu32 priority = nla_get_u16(data[IFLA_BR_PRIORITY]);\n\n\t\tbr_stp_set_bridge_priority(br, priority);\n\t}\n\n\tif (data[IFLA_BR_VLAN_FILTERING]) {\n\t\tu8 vlan_filter = nla_get_u8(data[IFLA_BR_VLAN_FILTERING]);\n\n\t\terr = br_vlan_filter_toggle(br, vlan_filter, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\n\tif (data[IFLA_BR_VLAN_PROTOCOL]) {\n\t\t__be16 vlan_proto = nla_get_be16(data[IFLA_BR_VLAN_PROTOCOL]);\n\n\t\terr = __br_vlan_set_proto(br, vlan_proto, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_VLAN_DEFAULT_PVID]) {\n\t\t__u16 defpvid = nla_get_u16(data[IFLA_BR_VLAN_DEFAULT_PVID]);\n\n\t\terr = __br_vlan_set_default_pvid(br, defpvid, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_VLAN_STATS_ENABLED]) {\n\t\t__u8 vlan_stats = nla_get_u8(data[IFLA_BR_VLAN_STATS_ENABLED]);\n\n\t\terr = br_vlan_set_stats(br, vlan_stats);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_VLAN_STATS_PER_PORT]) {\n\t\t__u8 per_port = nla_get_u8(data[IFLA_BR_VLAN_STATS_PER_PORT]);\n\n\t\terr = br_vlan_set_stats_per_port(br, per_port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n#endif\n\n\tif (data[IFLA_BR_GROUP_FWD_MASK]) {\n\t\tu16 fwd_mask = nla_get_u16(data[IFLA_BR_GROUP_FWD_MASK]);\n\n\t\tif (fwd_mask & BR_GROUPFWD_RESTRICTED)\n\t\t\treturn -EINVAL;\n\t\tbr->group_fwd_mask = fwd_mask;\n\t}\n\n\tif (data[IFLA_BR_GROUP_ADDR]) {\n\t\tu8 new_addr[ETH_ALEN];\n\n\t\tif (nla_len(data[IFLA_BR_GROUP_ADDR]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(new_addr, nla_data(data[IFLA_BR_GROUP_ADDR]), ETH_ALEN);\n\t\tif (!is_link_local_ether_addr(new_addr))\n\t\t\treturn -EINVAL;\n\t\tif (new_addr[5] == 1 ||\t\t \n\t\t    new_addr[5] == 2 ||\t\t \n\t\t    new_addr[5] == 3)\t\t \n\t\t\treturn -EINVAL;\n\t\tspin_lock_bh(&br->lock);\n\t\tmemcpy(br->group_addr, new_addr, sizeof(br->group_addr));\n\t\tspin_unlock_bh(&br->lock);\n\t\tbr_opt_toggle(br, BROPT_GROUP_ADDR_SET, true);\n\t\tbr_recalculate_fwd_mask(br);\n\t}\n\n\tif (data[IFLA_BR_FDB_FLUSH]) {\n\t\tstruct net_bridge_fdb_flush_desc desc = {\n\t\t\t.flags_mask = BIT(BR_FDB_STATIC)\n\t\t};\n\n\t\tbr_fdb_flush(br, &desc);\n\t}\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tif (data[IFLA_BR_MCAST_ROUTER]) {\n\t\tu8 multicast_router = nla_get_u8(data[IFLA_BR_MCAST_ROUTER]);\n\n\t\terr = br_multicast_set_router(&br->multicast_ctx,\n\t\t\t\t\t      multicast_router);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_MCAST_SNOOPING]) {\n\t\tu8 mcast_snooping = nla_get_u8(data[IFLA_BR_MCAST_SNOOPING]);\n\n\t\terr = br_multicast_toggle(br, mcast_snooping, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_MCAST_QUERY_USE_IFADDR]) {\n\t\tu8 val;\n\n\t\tval = nla_get_u8(data[IFLA_BR_MCAST_QUERY_USE_IFADDR]);\n\t\tbr_opt_toggle(br, BROPT_MULTICAST_QUERY_USE_IFADDR, !!val);\n\t}\n\n\tif (data[IFLA_BR_MCAST_QUERIER]) {\n\t\tu8 mcast_querier = nla_get_u8(data[IFLA_BR_MCAST_QUERIER]);\n\n\t\terr = br_multicast_set_querier(&br->multicast_ctx,\n\t\t\t\t\t       mcast_querier);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BR_MCAST_HASH_ELASTICITY])\n\t\tbr_warn(br, \"the hash_elasticity option has been deprecated and is always %u\\n\",\n\t\t\tRHT_ELASTICITY);\n\n\tif (data[IFLA_BR_MCAST_HASH_MAX])\n\t\tbr->hash_max = nla_get_u32(data[IFLA_BR_MCAST_HASH_MAX]);\n\n\tif (data[IFLA_BR_MCAST_LAST_MEMBER_CNT]) {\n\t\tu32 val = nla_get_u32(data[IFLA_BR_MCAST_LAST_MEMBER_CNT]);\n\n\t\tbr->multicast_ctx.multicast_last_member_count = val;\n\t}\n\n\tif (data[IFLA_BR_MCAST_STARTUP_QUERY_CNT]) {\n\t\tu32 val = nla_get_u32(data[IFLA_BR_MCAST_STARTUP_QUERY_CNT]);\n\n\t\tbr->multicast_ctx.multicast_startup_query_count = val;\n\t}\n\n\tif (data[IFLA_BR_MCAST_LAST_MEMBER_INTVL]) {\n\t\tu64 val = nla_get_u64(data[IFLA_BR_MCAST_LAST_MEMBER_INTVL]);\n\n\t\tbr->multicast_ctx.multicast_last_member_interval = clock_t_to_jiffies(val);\n\t}\n\n\tif (data[IFLA_BR_MCAST_MEMBERSHIP_INTVL]) {\n\t\tu64 val = nla_get_u64(data[IFLA_BR_MCAST_MEMBERSHIP_INTVL]);\n\n\t\tbr->multicast_ctx.multicast_membership_interval = clock_t_to_jiffies(val);\n\t}\n\n\tif (data[IFLA_BR_MCAST_QUERIER_INTVL]) {\n\t\tu64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERIER_INTVL]);\n\n\t\tbr->multicast_ctx.multicast_querier_interval = clock_t_to_jiffies(val);\n\t}\n\n\tif (data[IFLA_BR_MCAST_QUERY_INTVL]) {\n\t\tu64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERY_INTVL]);\n\n\t\tbr_multicast_set_query_intvl(&br->multicast_ctx, val);\n\t}\n\n\tif (data[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL]) {\n\t\tu64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL]);\n\n\t\tbr->multicast_ctx.multicast_query_response_interval = clock_t_to_jiffies(val);\n\t}\n\n\tif (data[IFLA_BR_MCAST_STARTUP_QUERY_INTVL]) {\n\t\tu64 val = nla_get_u64(data[IFLA_BR_MCAST_STARTUP_QUERY_INTVL]);\n\n\t\tbr_multicast_set_startup_query_intvl(&br->multicast_ctx, val);\n\t}\n\n\tif (data[IFLA_BR_MCAST_STATS_ENABLED]) {\n\t\t__u8 mcast_stats;\n\n\t\tmcast_stats = nla_get_u8(data[IFLA_BR_MCAST_STATS_ENABLED]);\n\t\tbr_opt_toggle(br, BROPT_MULTICAST_STATS_ENABLED, !!mcast_stats);\n\t}\n\n\tif (data[IFLA_BR_MCAST_IGMP_VERSION]) {\n\t\t__u8 igmp_version;\n\n\t\tigmp_version = nla_get_u8(data[IFLA_BR_MCAST_IGMP_VERSION]);\n\t\terr = br_multicast_set_igmp_version(&br->multicast_ctx,\n\t\t\t\t\t\t    igmp_version);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (data[IFLA_BR_MCAST_MLD_VERSION]) {\n\t\t__u8 mld_version;\n\n\t\tmld_version = nla_get_u8(data[IFLA_BR_MCAST_MLD_VERSION]);\n\t\terr = br_multicast_set_mld_version(&br->multicast_ctx,\n\t\t\t\t\t\t   mld_version);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n#endif\n#endif\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tif (data[IFLA_BR_NF_CALL_IPTABLES]) {\n\t\tu8 val = nla_get_u8(data[IFLA_BR_NF_CALL_IPTABLES]);\n\n\t\tbr_opt_toggle(br, BROPT_NF_CALL_IPTABLES, !!val);\n\t}\n\n\tif (data[IFLA_BR_NF_CALL_IP6TABLES]) {\n\t\tu8 val = nla_get_u8(data[IFLA_BR_NF_CALL_IP6TABLES]);\n\n\t\tbr_opt_toggle(br, BROPT_NF_CALL_IP6TABLES, !!val);\n\t}\n\n\tif (data[IFLA_BR_NF_CALL_ARPTABLES]) {\n\t\tu8 val = nla_get_u8(data[IFLA_BR_NF_CALL_ARPTABLES]);\n\n\t\tbr_opt_toggle(br, BROPT_NF_CALL_ARPTABLES, !!val);\n\t}\n#endif\n\n\tif (data[IFLA_BR_MULTI_BOOLOPT]) {\n\t\tstruct br_boolopt_multi *bm;\n\n\t\tbm = nla_data(data[IFLA_BR_MULTI_BOOLOPT]);\n\t\terr = br_boolopt_multi_toggle(br, bm, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int br_dev_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t  struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tint err;\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tspin_lock_bh(&br->lock);\n\t\tbr_stp_change_bridge_id(br, nla_data(tb[IFLA_ADDRESS]));\n\t\tspin_unlock_bh(&br->lock);\n\t}\n\n\terr = br_changelink(dev, tb, data, extack);\n\tif (err)\n\t\tbr_dev_delete(dev, NULL);\n\n\treturn err;\n}\n\nstatic size_t br_get_size(const struct net_device *brdev)\n{\n\treturn nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +     \n\t       nla_total_size(sizeof(u32)) +     \n\t       nla_total_size(sizeof(u16)) +     \n\t       nla_total_size(sizeof(u8)) +      \n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\n\t       nla_total_size(sizeof(__be16)) +\t \n\t       nla_total_size(sizeof(u16)) +     \n\t       nla_total_size(sizeof(u8)) +      \n\t       nla_total_size(sizeof(u8)) +\t \n#endif\n\t       nla_total_size(sizeof(u16)) +     \n\t       nla_total_size(sizeof(struct ifla_bridge_id)) +    \n\t       nla_total_size(sizeof(struct ifla_bridge_id)) +    \n\t       nla_total_size(sizeof(u16)) +     \n\t       nla_total_size(sizeof(u32)) +     \n\t       nla_total_size(sizeof(u8)) +      \n\t       nla_total_size(sizeof(u8)) +      \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size(ETH_ALEN) +        \n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\t       nla_total_size(sizeof(u8)) +      \n\t       nla_total_size(sizeof(u8)) +      \n\t       nla_total_size(sizeof(u8)) +      \n\t       nla_total_size(sizeof(u8)) +      \n\t       nla_total_size(sizeof(u8)) +      \n\t       nla_total_size(sizeof(u32)) +     \n\t       nla_total_size(sizeof(u32)) +     \n\t       nla_total_size(sizeof(u32)) +     \n\t       nla_total_size(sizeof(u32)) +     \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size(sizeof(u8)) +\t \n\t       nla_total_size(sizeof(u8)) +\t \n\t       br_multicast_querier_state_size() +  \n#endif\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\t       nla_total_size(sizeof(u8)) +      \n\t       nla_total_size(sizeof(u8)) +      \n\t       nla_total_size(sizeof(u8)) +      \n#endif\n\t       nla_total_size(sizeof(struct br_boolopt_multi)) +  \n\t       0;\n}\n\nstatic int br_fill_info(struct sk_buff *skb, const struct net_device *brdev)\n{\n\tstruct net_bridge *br = netdev_priv(brdev);\n\tu32 forward_delay = jiffies_to_clock_t(br->forward_delay);\n\tu32 hello_time = jiffies_to_clock_t(br->hello_time);\n\tu32 age_time = jiffies_to_clock_t(br->max_age);\n\tu32 ageing_time = jiffies_to_clock_t(br->ageing_time);\n\tu32 stp_enabled = br->stp_enabled;\n\tu16 priority = (br->bridge_id.prio[0] << 8) | br->bridge_id.prio[1];\n\tu8 vlan_enabled = br_vlan_enabled(br->dev);\n\tstruct br_boolopt_multi bm;\n\tu64 clockval;\n\n\tclockval = br_timer_value(&br->hello_timer);\n\tif (nla_put_u64_64bit(skb, IFLA_BR_HELLO_TIMER, clockval, IFLA_BR_PAD))\n\t\treturn -EMSGSIZE;\n\tclockval = br_timer_value(&br->tcn_timer);\n\tif (nla_put_u64_64bit(skb, IFLA_BR_TCN_TIMER, clockval, IFLA_BR_PAD))\n\t\treturn -EMSGSIZE;\n\tclockval = br_timer_value(&br->topology_change_timer);\n\tif (nla_put_u64_64bit(skb, IFLA_BR_TOPOLOGY_CHANGE_TIMER, clockval,\n\t\t\t      IFLA_BR_PAD))\n\t\treturn -EMSGSIZE;\n\tclockval = br_timer_value(&br->gc_work.timer);\n\tif (nla_put_u64_64bit(skb, IFLA_BR_GC_TIMER, clockval, IFLA_BR_PAD))\n\t\treturn -EMSGSIZE;\n\n\tbr_boolopt_multi_get(br, &bm);\n\tif (nla_put_u32(skb, IFLA_BR_FORWARD_DELAY, forward_delay) ||\n\t    nla_put_u32(skb, IFLA_BR_HELLO_TIME, hello_time) ||\n\t    nla_put_u32(skb, IFLA_BR_MAX_AGE, age_time) ||\n\t    nla_put_u32(skb, IFLA_BR_AGEING_TIME, ageing_time) ||\n\t    nla_put_u32(skb, IFLA_BR_STP_STATE, stp_enabled) ||\n\t    nla_put_u16(skb, IFLA_BR_PRIORITY, priority) ||\n\t    nla_put_u8(skb, IFLA_BR_VLAN_FILTERING, vlan_enabled) ||\n\t    nla_put_u16(skb, IFLA_BR_GROUP_FWD_MASK, br->group_fwd_mask) ||\n\t    nla_put(skb, IFLA_BR_BRIDGE_ID, sizeof(struct ifla_bridge_id),\n\t\t    &br->bridge_id) ||\n\t    nla_put(skb, IFLA_BR_ROOT_ID, sizeof(struct ifla_bridge_id),\n\t\t    &br->designated_root) ||\n\t    nla_put_u16(skb, IFLA_BR_ROOT_PORT, br->root_port) ||\n\t    nla_put_u32(skb, IFLA_BR_ROOT_PATH_COST, br->root_path_cost) ||\n\t    nla_put_u8(skb, IFLA_BR_TOPOLOGY_CHANGE, br->topology_change) ||\n\t    nla_put_u8(skb, IFLA_BR_TOPOLOGY_CHANGE_DETECTED,\n\t\t       br->topology_change_detected) ||\n\t    nla_put(skb, IFLA_BR_GROUP_ADDR, ETH_ALEN, br->group_addr) ||\n\t    nla_put(skb, IFLA_BR_MULTI_BOOLOPT, sizeof(bm), &bm))\n\t\treturn -EMSGSIZE;\n\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\n\tif (nla_put_be16(skb, IFLA_BR_VLAN_PROTOCOL, br->vlan_proto) ||\n\t    nla_put_u16(skb, IFLA_BR_VLAN_DEFAULT_PVID, br->default_pvid) ||\n\t    nla_put_u8(skb, IFLA_BR_VLAN_STATS_ENABLED,\n\t\t       br_opt_get(br, BROPT_VLAN_STATS_ENABLED)) ||\n\t    nla_put_u8(skb, IFLA_BR_VLAN_STATS_PER_PORT,\n\t\t       br_opt_get(br, BROPT_VLAN_STATS_PER_PORT)))\n\t\treturn -EMSGSIZE;\n#endif\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tif (nla_put_u8(skb, IFLA_BR_MCAST_ROUTER,\n\t\t       br->multicast_ctx.multicast_router) ||\n\t    nla_put_u8(skb, IFLA_BR_MCAST_SNOOPING,\n\t\t       br_opt_get(br, BROPT_MULTICAST_ENABLED)) ||\n\t    nla_put_u8(skb, IFLA_BR_MCAST_QUERY_USE_IFADDR,\n\t\t       br_opt_get(br, BROPT_MULTICAST_QUERY_USE_IFADDR)) ||\n\t    nla_put_u8(skb, IFLA_BR_MCAST_QUERIER,\n\t\t       br->multicast_ctx.multicast_querier) ||\n\t    nla_put_u8(skb, IFLA_BR_MCAST_STATS_ENABLED,\n\t\t       br_opt_get(br, BROPT_MULTICAST_STATS_ENABLED)) ||\n\t    nla_put_u32(skb, IFLA_BR_MCAST_HASH_ELASTICITY, RHT_ELASTICITY) ||\n\t    nla_put_u32(skb, IFLA_BR_MCAST_HASH_MAX, br->hash_max) ||\n\t    nla_put_u32(skb, IFLA_BR_MCAST_LAST_MEMBER_CNT,\n\t\t\tbr->multicast_ctx.multicast_last_member_count) ||\n\t    nla_put_u32(skb, IFLA_BR_MCAST_STARTUP_QUERY_CNT,\n\t\t\tbr->multicast_ctx.multicast_startup_query_count) ||\n\t    nla_put_u8(skb, IFLA_BR_MCAST_IGMP_VERSION,\n\t\t       br->multicast_ctx.multicast_igmp_version) ||\n\t    br_multicast_dump_querier_state(skb, &br->multicast_ctx,\n\t\t\t\t\t    IFLA_BR_MCAST_QUERIER_STATE))\n\t\treturn -EMSGSIZE;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (nla_put_u8(skb, IFLA_BR_MCAST_MLD_VERSION,\n\t\t       br->multicast_ctx.multicast_mld_version))\n\t\treturn -EMSGSIZE;\n#endif\n\tclockval = jiffies_to_clock_t(br->multicast_ctx.multicast_last_member_interval);\n\tif (nla_put_u64_64bit(skb, IFLA_BR_MCAST_LAST_MEMBER_INTVL, clockval,\n\t\t\t      IFLA_BR_PAD))\n\t\treturn -EMSGSIZE;\n\tclockval = jiffies_to_clock_t(br->multicast_ctx.multicast_membership_interval);\n\tif (nla_put_u64_64bit(skb, IFLA_BR_MCAST_MEMBERSHIP_INTVL, clockval,\n\t\t\t      IFLA_BR_PAD))\n\t\treturn -EMSGSIZE;\n\tclockval = jiffies_to_clock_t(br->multicast_ctx.multicast_querier_interval);\n\tif (nla_put_u64_64bit(skb, IFLA_BR_MCAST_QUERIER_INTVL, clockval,\n\t\t\t      IFLA_BR_PAD))\n\t\treturn -EMSGSIZE;\n\tclockval = jiffies_to_clock_t(br->multicast_ctx.multicast_query_interval);\n\tif (nla_put_u64_64bit(skb, IFLA_BR_MCAST_QUERY_INTVL, clockval,\n\t\t\t      IFLA_BR_PAD))\n\t\treturn -EMSGSIZE;\n\tclockval = jiffies_to_clock_t(br->multicast_ctx.multicast_query_response_interval);\n\tif (nla_put_u64_64bit(skb, IFLA_BR_MCAST_QUERY_RESPONSE_INTVL, clockval,\n\t\t\t      IFLA_BR_PAD))\n\t\treturn -EMSGSIZE;\n\tclockval = jiffies_to_clock_t(br->multicast_ctx.multicast_startup_query_interval);\n\tif (nla_put_u64_64bit(skb, IFLA_BR_MCAST_STARTUP_QUERY_INTVL, clockval,\n\t\t\t      IFLA_BR_PAD))\n\t\treturn -EMSGSIZE;\n#endif\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tif (nla_put_u8(skb, IFLA_BR_NF_CALL_IPTABLES,\n\t\t       br_opt_get(br, BROPT_NF_CALL_IPTABLES) ? 1 : 0) ||\n\t    nla_put_u8(skb, IFLA_BR_NF_CALL_IP6TABLES,\n\t\t       br_opt_get(br, BROPT_NF_CALL_IP6TABLES) ? 1 : 0) ||\n\t    nla_put_u8(skb, IFLA_BR_NF_CALL_ARPTABLES,\n\t\t       br_opt_get(br, BROPT_NF_CALL_ARPTABLES) ? 1 : 0))\n\t\treturn -EMSGSIZE;\n#endif\n\n\treturn 0;\n}\n\nstatic size_t br_get_linkxstats_size(const struct net_device *dev, int attr)\n{\n\tstruct net_bridge_port *p = NULL;\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\tstruct net_bridge *br;\n\tint numvls = 0;\n\n\tswitch (attr) {\n\tcase IFLA_STATS_LINK_XSTATS:\n\t\tbr = netdev_priv(dev);\n\t\tvg = br_vlan_group(br);\n\t\tbreak;\n\tcase IFLA_STATS_LINK_XSTATS_SLAVE:\n\t\tp = br_port_get_rtnl(dev);\n\t\tif (!p)\n\t\t\treturn 0;\n\t\tvg = nbp_vlan_group(p);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (vg) {\n\t\t \n\t\tlist_for_each_entry(v, &vg->vlan_list, vlist)\n\t\t\tnumvls++;\n\t}\n\n\treturn numvls * nla_total_size(sizeof(struct bridge_vlan_xstats)) +\n\t       nla_total_size_64bit(sizeof(struct br_mcast_stats)) +\n\t       (p ? nla_total_size_64bit(sizeof(p->stp_xstats)) : 0) +\n\t       nla_total_size(0);\n}\n\nstatic int br_fill_linkxstats(struct sk_buff *skb,\n\t\t\t      const struct net_device *dev,\n\t\t\t      int *prividx, int attr)\n{\n\tstruct nlattr *nla __maybe_unused;\n\tstruct net_bridge_port *p = NULL;\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\tstruct net_bridge *br;\n\tstruct nlattr *nest;\n\tint vl_idx = 0;\n\n\tswitch (attr) {\n\tcase IFLA_STATS_LINK_XSTATS:\n\t\tbr = netdev_priv(dev);\n\t\tvg = br_vlan_group(br);\n\t\tbreak;\n\tcase IFLA_STATS_LINK_XSTATS_SLAVE:\n\t\tp = br_port_get_rtnl(dev);\n\t\tif (!p)\n\t\t\treturn 0;\n\t\tbr = p->br;\n\t\tvg = nbp_vlan_group(p);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnest = nla_nest_start_noflag(skb, LINK_XSTATS_TYPE_BRIDGE);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (vg) {\n\t\tu16 pvid;\n\n\t\tpvid = br_get_pvid(vg);\n\t\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\t\tstruct bridge_vlan_xstats vxi;\n\t\t\tstruct pcpu_sw_netstats stats;\n\n\t\t\tif (++vl_idx < *prividx)\n\t\t\t\tcontinue;\n\t\t\tmemset(&vxi, 0, sizeof(vxi));\n\t\t\tvxi.vid = v->vid;\n\t\t\tvxi.flags = v->flags;\n\t\t\tif (v->vid == pvid)\n\t\t\t\tvxi.flags |= BRIDGE_VLAN_INFO_PVID;\n\t\t\tbr_vlan_get_stats(v, &stats);\n\t\t\tvxi.rx_bytes = u64_stats_read(&stats.rx_bytes);\n\t\t\tvxi.rx_packets = u64_stats_read(&stats.rx_packets);\n\t\t\tvxi.tx_bytes = u64_stats_read(&stats.tx_bytes);\n\t\t\tvxi.tx_packets = u64_stats_read(&stats.tx_packets);\n\n\t\t\tif (nla_put(skb, BRIDGE_XSTATS_VLAN, sizeof(vxi), &vxi))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tif (++vl_idx >= *prividx) {\n\t\tnla = nla_reserve_64bit(skb, BRIDGE_XSTATS_MCAST,\n\t\t\t\t\tsizeof(struct br_mcast_stats),\n\t\t\t\t\tBRIDGE_XSTATS_PAD);\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\t\tbr_multicast_get_stats(br, p, nla_data(nla));\n\t}\n#endif\n\n\tif (p) {\n\t\tnla = nla_reserve_64bit(skb, BRIDGE_XSTATS_STP,\n\t\t\t\t\tsizeof(p->stp_xstats),\n\t\t\t\t\tBRIDGE_XSTATS_PAD);\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\n\t\tspin_lock_bh(&br->lock);\n\t\tmemcpy(nla_data(nla), &p->stp_xstats, sizeof(p->stp_xstats));\n\t\tspin_unlock_bh(&br->lock);\n\t}\n\n\tnla_nest_end(skb, nest);\n\t*prividx = 0;\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_end(skb, nest);\n\t*prividx = vl_idx;\n\n\treturn -EMSGSIZE;\n}\n\nstatic struct rtnl_af_ops br_af_ops __read_mostly = {\n\t.family\t\t\t= AF_BRIDGE,\n\t.get_link_af_size\t= br_get_link_af_size_filtered,\n};\n\nstruct rtnl_link_ops br_link_ops __read_mostly = {\n\t.kind\t\t\t= \"bridge\",\n\t.priv_size\t\t= sizeof(struct net_bridge),\n\t.setup\t\t\t= br_dev_setup,\n\t.maxtype\t\t= IFLA_BR_MAX,\n\t.policy\t\t\t= br_policy,\n\t.validate\t\t= br_validate,\n\t.newlink\t\t= br_dev_newlink,\n\t.changelink\t\t= br_changelink,\n\t.dellink\t\t= br_dev_delete,\n\t.get_size\t\t= br_get_size,\n\t.fill_info\t\t= br_fill_info,\n\t.fill_linkxstats\t= br_fill_linkxstats,\n\t.get_linkxstats_size\t= br_get_linkxstats_size,\n\n\t.slave_maxtype\t\t= IFLA_BRPORT_MAX,\n\t.slave_policy\t\t= br_port_policy,\n\t.slave_changelink\t= br_port_slave_changelink,\n\t.get_slave_size\t\t= br_port_get_slave_size,\n\t.fill_slave_info\t= br_port_fill_slave_info,\n};\n\nint __init br_netlink_init(void)\n{\n\tint err;\n\n\tbr_vlan_rtnl_init();\n\trtnl_af_register(&br_af_ops);\n\n\terr = rtnl_link_register(&br_link_ops);\n\tif (err)\n\t\tgoto out_af;\n\n\treturn 0;\n\nout_af:\n\trtnl_af_unregister(&br_af_ops);\n\treturn err;\n}\n\nvoid br_netlink_fini(void)\n{\n\tbr_vlan_rtnl_uninit();\n\trtnl_af_unregister(&br_af_ops);\n\trtnl_link_unregister(&br_link_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}