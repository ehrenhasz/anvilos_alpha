{
  "module_name": "br_sysfs_br.c",
  "hash_id": "2097e93057a7ef4ba0176fd84d194b0b768e92a370dcf942ee07e4b97160abff",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_sysfs_br.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/rtnetlink.h>\n#include <linux/spinlock.h>\n#include <linux/times.h>\n#include <linux/sched/signal.h>\n\n#include \"br_private.h\"\n\n \n\n#define to_bridge(cd)\t((struct net_bridge *)netdev_priv(to_net_dev(cd)))\n\n \nstatic ssize_t store_bridge_parm(struct device *d,\n\t\t\t\t const char *buf, size_t len,\n\t\t\t\t int (*set)(struct net_bridge *br, unsigned long val,\n\t\t\t\t\t    struct netlink_ext_ack *extack))\n{\n\tstruct net_bridge *br = to_bridge(d);\n\tstruct netlink_ext_ack extack = {0};\n\tunsigned long val;\n\tint err;\n\n\tif (!ns_capable(dev_net(br->dev)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\terr = kstrtoul(buf, 0, &val);\n\tif (err != 0)\n\t\treturn err;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\terr = (*set)(br, val, &extack);\n\tif (!err)\n\t\tnetdev_state_change(br->dev);\n\tif (extack._msg) {\n\t\tif (err)\n\t\t\tbr_err(br, \"%s\\n\", extack._msg);\n\t\telse\n\t\t\tbr_warn(br, \"%s\\n\", extack._msg);\n\t}\n\trtnl_unlock();\n\n\treturn err ? err : len;\n}\n\n\nstatic ssize_t forward_delay_show(struct device *d,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%lu\\n\", jiffies_to_clock_t(br->forward_delay));\n}\n\nstatic int set_forward_delay(struct net_bridge *br, unsigned long val,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn br_set_forward_delay(br, val);\n}\n\nstatic ssize_t forward_delay_store(struct device *d,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_forward_delay);\n}\nstatic DEVICE_ATTR_RW(forward_delay);\n\nstatic ssize_t hello_time_show(struct device *d, struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\",\n\t\t       jiffies_to_clock_t(to_bridge(d)->hello_time));\n}\n\nstatic int set_hello_time(struct net_bridge *br, unsigned long val,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn br_set_hello_time(br, val);\n}\n\nstatic ssize_t hello_time_store(struct device *d,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_hello_time);\n}\nstatic DEVICE_ATTR_RW(hello_time);\n\nstatic ssize_t max_age_show(struct device *d, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\",\n\t\t       jiffies_to_clock_t(to_bridge(d)->max_age));\n}\n\nstatic int set_max_age(struct net_bridge *br, unsigned long val,\n\t\t       struct netlink_ext_ack *extack)\n{\n\treturn br_set_max_age(br, val);\n}\n\nstatic ssize_t max_age_store(struct device *d, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_max_age);\n}\nstatic DEVICE_ATTR_RW(max_age);\n\nstatic ssize_t ageing_time_show(struct device *d,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%lu\\n\", jiffies_to_clock_t(br->ageing_time));\n}\n\nstatic int set_ageing_time(struct net_bridge *br, unsigned long val,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\treturn br_set_ageing_time(br, val);\n}\n\nstatic ssize_t ageing_time_store(struct device *d,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_ageing_time);\n}\nstatic DEVICE_ATTR_RW(ageing_time);\n\nstatic ssize_t stp_state_show(struct device *d,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%d\\n\", br->stp_enabled);\n}\n\n\nstatic int set_stp_state(struct net_bridge *br, unsigned long val,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn br_stp_set_enabled(br, val, extack);\n}\n\nstatic ssize_t stp_state_store(struct device *d,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_stp_state);\n}\nstatic DEVICE_ATTR_RW(stp_state);\n\nstatic ssize_t group_fwd_mask_show(struct device *d,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%#x\\n\", br->group_fwd_mask);\n}\n\nstatic int set_group_fwd_mask(struct net_bridge *br, unsigned long val,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (val & BR_GROUPFWD_RESTRICTED)\n\t\treturn -EINVAL;\n\n\tbr->group_fwd_mask = val;\n\n\treturn 0;\n}\n\nstatic ssize_t group_fwd_mask_store(struct device *d,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf,\n\t\t\t\t    size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_group_fwd_mask);\n}\nstatic DEVICE_ATTR_RW(group_fwd_mask);\n\nstatic ssize_t priority_show(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       (br->bridge_id.prio[0] << 8) | br->bridge_id.prio[1]);\n}\n\nstatic int set_priority(struct net_bridge *br, unsigned long val,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbr_stp_set_bridge_priority(br, (u16) val);\n\treturn 0;\n}\n\nstatic ssize_t priority_store(struct device *d, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_priority);\n}\nstatic DEVICE_ATTR_RW(priority);\n\nstatic ssize_t root_id_show(struct device *d, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn br_show_bridge_id(buf, &to_bridge(d)->designated_root);\n}\nstatic DEVICE_ATTR_RO(root_id);\n\nstatic ssize_t bridge_id_show(struct device *d, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn br_show_bridge_id(buf, &to_bridge(d)->bridge_id);\n}\nstatic DEVICE_ATTR_RO(bridge_id);\n\nstatic ssize_t root_port_show(struct device *d, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", to_bridge(d)->root_port);\n}\nstatic DEVICE_ATTR_RO(root_port);\n\nstatic ssize_t root_path_cost_show(struct device *d,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", to_bridge(d)->root_path_cost);\n}\nstatic DEVICE_ATTR_RO(root_path_cost);\n\nstatic ssize_t topology_change_show(struct device *d,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", to_bridge(d)->topology_change);\n}\nstatic DEVICE_ATTR_RO(topology_change);\n\nstatic ssize_t topology_change_detected_show(struct device *d,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%d\\n\", br->topology_change_detected);\n}\nstatic DEVICE_ATTR_RO(topology_change_detected);\n\nstatic ssize_t hello_timer_show(struct device *d,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%ld\\n\", br_timer_value(&br->hello_timer));\n}\nstatic DEVICE_ATTR_RO(hello_timer);\n\nstatic ssize_t tcn_timer_show(struct device *d, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%ld\\n\", br_timer_value(&br->tcn_timer));\n}\nstatic DEVICE_ATTR_RO(tcn_timer);\n\nstatic ssize_t topology_change_timer_show(struct device *d,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%ld\\n\", br_timer_value(&br->topology_change_timer));\n}\nstatic DEVICE_ATTR_RO(topology_change_timer);\n\nstatic ssize_t gc_timer_show(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%ld\\n\", br_timer_value(&br->gc_work.timer));\n}\nstatic DEVICE_ATTR_RO(gc_timer);\n\nstatic ssize_t group_addr_show(struct device *d,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%pM\\n\", br->group_addr);\n}\n\nstatic ssize_t group_addr_store(struct device *d,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\tu8 new_addr[6];\n\n\tif (!ns_capable(dev_net(br->dev)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!mac_pton(buf, new_addr))\n\t\treturn -EINVAL;\n\n\tif (!is_link_local_ether_addr(new_addr))\n\t\treturn -EINVAL;\n\n\tif (new_addr[5] == 1 ||\t\t \n\t    new_addr[5] == 2 ||\t\t \n\t    new_addr[5] == 3)\t\t \n\t\treturn -EINVAL;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tspin_lock_bh(&br->lock);\n\tether_addr_copy(br->group_addr, new_addr);\n\tspin_unlock_bh(&br->lock);\n\n\tbr_opt_toggle(br, BROPT_GROUP_ADDR_SET, true);\n\tbr_recalculate_fwd_mask(br);\n\tnetdev_state_change(br->dev);\n\n\trtnl_unlock();\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RW(group_addr);\n\nstatic int set_flush(struct net_bridge *br, unsigned long val,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_fdb_flush_desc desc = {\n\t\t.flags_mask = BIT(BR_FDB_STATIC)\n\t};\n\n\tbr_fdb_flush(br, &desc);\n\treturn 0;\n}\n\nstatic ssize_t flush_store(struct device *d,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_flush);\n}\nstatic DEVICE_ATTR_WO(flush);\n\nstatic ssize_t no_linklocal_learn_show(struct device *d,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%d\\n\", br_boolopt_get(br, BR_BOOLOPT_NO_LL_LEARN));\n}\n\nstatic int set_no_linklocal_learn(struct net_bridge *br, unsigned long val,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn br_boolopt_toggle(br, BR_BOOLOPT_NO_LL_LEARN, !!val, extack);\n}\n\nstatic ssize_t no_linklocal_learn_store(struct device *d,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_no_linklocal_learn);\n}\nstatic DEVICE_ATTR_RW(no_linklocal_learn);\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\nstatic ssize_t multicast_router_show(struct device *d,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%d\\n\", br->multicast_ctx.multicast_router);\n}\n\nstatic int set_multicast_router(struct net_bridge *br, unsigned long val,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn br_multicast_set_router(&br->multicast_ctx, val);\n}\n\nstatic ssize_t multicast_router_store(struct device *d,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_multicast_router);\n}\nstatic DEVICE_ATTR_RW(multicast_router);\n\nstatic ssize_t multicast_snooping_show(struct device *d,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%d\\n\", br_opt_get(br, BROPT_MULTICAST_ENABLED));\n}\n\nstatic ssize_t multicast_snooping_store(struct device *d,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, br_multicast_toggle);\n}\nstatic DEVICE_ATTR_RW(multicast_snooping);\n\nstatic ssize_t multicast_query_use_ifaddr_show(struct device *d,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       br_opt_get(br, BROPT_MULTICAST_QUERY_USE_IFADDR));\n}\n\nstatic int set_query_use_ifaddr(struct net_bridge *br, unsigned long val,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbr_opt_toggle(br, BROPT_MULTICAST_QUERY_USE_IFADDR, !!val);\n\treturn 0;\n}\n\nstatic ssize_t\nmulticast_query_use_ifaddr_store(struct device *d,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_query_use_ifaddr);\n}\nstatic DEVICE_ATTR_RW(multicast_query_use_ifaddr);\n\nstatic ssize_t multicast_querier_show(struct device *d,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%d\\n\", br->multicast_ctx.multicast_querier);\n}\n\nstatic int set_multicast_querier(struct net_bridge *br, unsigned long val,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn br_multicast_set_querier(&br->multicast_ctx, val);\n}\n\nstatic ssize_t multicast_querier_store(struct device *d,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_multicast_querier);\n}\nstatic DEVICE_ATTR_RW(multicast_querier);\n\nstatic ssize_t hash_elasticity_show(struct device *d,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", RHT_ELASTICITY);\n}\n\nstatic int set_elasticity(struct net_bridge *br, unsigned long val,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\t \n\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t   \"the hash_elasticity option has been deprecated and is always 16\");\n\treturn 0;\n}\n\nstatic ssize_t hash_elasticity_store(struct device *d,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_elasticity);\n}\nstatic DEVICE_ATTR_RW(hash_elasticity);\n\nstatic ssize_t hash_max_show(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%u\\n\", br->hash_max);\n}\n\nstatic int set_hash_max(struct net_bridge *br, unsigned long val,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbr->hash_max = val;\n\treturn 0;\n}\n\nstatic ssize_t hash_max_store(struct device *d, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_hash_max);\n}\nstatic DEVICE_ATTR_RW(hash_max);\n\nstatic ssize_t multicast_igmp_version_show(struct device *d,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\n\treturn sprintf(buf, \"%u\\n\", br->multicast_ctx.multicast_igmp_version);\n}\n\nstatic int set_multicast_igmp_version(struct net_bridge *br, unsigned long val,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn br_multicast_set_igmp_version(&br->multicast_ctx, val);\n}\n\nstatic ssize_t multicast_igmp_version_store(struct device *d,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_multicast_igmp_version);\n}\nstatic DEVICE_ATTR_RW(multicast_igmp_version);\n\nstatic ssize_t multicast_last_member_count_show(struct device *d,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%u\\n\", br->multicast_ctx.multicast_last_member_count);\n}\n\nstatic int set_last_member_count(struct net_bridge *br, unsigned long val,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tbr->multicast_ctx.multicast_last_member_count = val;\n\treturn 0;\n}\n\nstatic ssize_t multicast_last_member_count_store(struct device *d,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_last_member_count);\n}\nstatic DEVICE_ATTR_RW(multicast_last_member_count);\n\nstatic ssize_t multicast_startup_query_count_show(\n\tstruct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%u\\n\", br->multicast_ctx.multicast_startup_query_count);\n}\n\nstatic int set_startup_query_count(struct net_bridge *br, unsigned long val,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tbr->multicast_ctx.multicast_startup_query_count = val;\n\treturn 0;\n}\n\nstatic ssize_t multicast_startup_query_count_store(\n\tstruct device *d, struct device_attribute *attr, const char *buf,\n\tsize_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_startup_query_count);\n}\nstatic DEVICE_ATTR_RW(multicast_startup_query_count);\n\nstatic ssize_t multicast_last_member_interval_show(\n\tstruct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%lu\\n\",\n\t\t       jiffies_to_clock_t(br->multicast_ctx.multicast_last_member_interval));\n}\n\nstatic int set_last_member_interval(struct net_bridge *br, unsigned long val,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tbr->multicast_ctx.multicast_last_member_interval = clock_t_to_jiffies(val);\n\treturn 0;\n}\n\nstatic ssize_t multicast_last_member_interval_store(\n\tstruct device *d, struct device_attribute *attr, const char *buf,\n\tsize_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_last_member_interval);\n}\nstatic DEVICE_ATTR_RW(multicast_last_member_interval);\n\nstatic ssize_t multicast_membership_interval_show(\n\tstruct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%lu\\n\",\n\t\t       jiffies_to_clock_t(br->multicast_ctx.multicast_membership_interval));\n}\n\nstatic int set_membership_interval(struct net_bridge *br, unsigned long val,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tbr->multicast_ctx.multicast_membership_interval = clock_t_to_jiffies(val);\n\treturn 0;\n}\n\nstatic ssize_t multicast_membership_interval_store(\n\tstruct device *d, struct device_attribute *attr, const char *buf,\n\tsize_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_membership_interval);\n}\nstatic DEVICE_ATTR_RW(multicast_membership_interval);\n\nstatic ssize_t multicast_querier_interval_show(struct device *d,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%lu\\n\",\n\t\t       jiffies_to_clock_t(br->multicast_ctx.multicast_querier_interval));\n}\n\nstatic int set_querier_interval(struct net_bridge *br, unsigned long val,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbr->multicast_ctx.multicast_querier_interval = clock_t_to_jiffies(val);\n\treturn 0;\n}\n\nstatic ssize_t multicast_querier_interval_store(struct device *d,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_querier_interval);\n}\nstatic DEVICE_ATTR_RW(multicast_querier_interval);\n\nstatic ssize_t multicast_query_interval_show(struct device *d,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%lu\\n\",\n\t\t       jiffies_to_clock_t(br->multicast_ctx.multicast_query_interval));\n}\n\nstatic int set_query_interval(struct net_bridge *br, unsigned long val,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tbr_multicast_set_query_intvl(&br->multicast_ctx, val);\n\treturn 0;\n}\n\nstatic ssize_t multicast_query_interval_store(struct device *d,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_query_interval);\n}\nstatic DEVICE_ATTR_RW(multicast_query_interval);\n\nstatic ssize_t multicast_query_response_interval_show(\n\tstruct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(\n\t\tbuf, \"%lu\\n\",\n\t\tjiffies_to_clock_t(br->multicast_ctx.multicast_query_response_interval));\n}\n\nstatic int set_query_response_interval(struct net_bridge *br, unsigned long val,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tbr->multicast_ctx.multicast_query_response_interval = clock_t_to_jiffies(val);\n\treturn 0;\n}\n\nstatic ssize_t multicast_query_response_interval_store(\n\tstruct device *d, struct device_attribute *attr, const char *buf,\n\tsize_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_query_response_interval);\n}\nstatic DEVICE_ATTR_RW(multicast_query_response_interval);\n\nstatic ssize_t multicast_startup_query_interval_show(\n\tstruct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(\n\t\tbuf, \"%lu\\n\",\n\t\tjiffies_to_clock_t(br->multicast_ctx.multicast_startup_query_interval));\n}\n\nstatic int set_startup_query_interval(struct net_bridge *br, unsigned long val,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tbr_multicast_set_startup_query_intvl(&br->multicast_ctx, val);\n\treturn 0;\n}\n\nstatic ssize_t multicast_startup_query_interval_store(\n\tstruct device *d, struct device_attribute *attr, const char *buf,\n\tsize_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_startup_query_interval);\n}\nstatic DEVICE_ATTR_RW(multicast_startup_query_interval);\n\nstatic ssize_t multicast_stats_enabled_show(struct device *d,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       br_opt_get(br, BROPT_MULTICAST_STATS_ENABLED));\n}\n\nstatic int set_stats_enabled(struct net_bridge *br, unsigned long val,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tbr_opt_toggle(br, BROPT_MULTICAST_STATS_ENABLED, !!val);\n\treturn 0;\n}\n\nstatic ssize_t multicast_stats_enabled_store(struct device *d,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf,\n\t\t\t\t\t     size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_stats_enabled);\n}\nstatic DEVICE_ATTR_RW(multicast_stats_enabled);\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic ssize_t multicast_mld_version_show(struct device *d,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\n\treturn sprintf(buf, \"%u\\n\", br->multicast_ctx.multicast_mld_version);\n}\n\nstatic int set_multicast_mld_version(struct net_bridge *br, unsigned long val,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn br_multicast_set_mld_version(&br->multicast_ctx, val);\n}\n\nstatic ssize_t multicast_mld_version_store(struct device *d,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_multicast_mld_version);\n}\nstatic DEVICE_ATTR_RW(multicast_mld_version);\n#endif\n#endif\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\nstatic ssize_t nf_call_iptables_show(\n\tstruct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%u\\n\", br_opt_get(br, BROPT_NF_CALL_IPTABLES));\n}\n\nstatic int set_nf_call_iptables(struct net_bridge *br, unsigned long val,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbr_opt_toggle(br, BROPT_NF_CALL_IPTABLES, !!val);\n\treturn 0;\n}\n\nstatic ssize_t nf_call_iptables_store(\n\tstruct device *d, struct device_attribute *attr, const char *buf,\n\tsize_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_nf_call_iptables);\n}\nstatic DEVICE_ATTR_RW(nf_call_iptables);\n\nstatic ssize_t nf_call_ip6tables_show(\n\tstruct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%u\\n\", br_opt_get(br, BROPT_NF_CALL_IP6TABLES));\n}\n\nstatic int set_nf_call_ip6tables(struct net_bridge *br, unsigned long val,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tbr_opt_toggle(br, BROPT_NF_CALL_IP6TABLES, !!val);\n\treturn 0;\n}\n\nstatic ssize_t nf_call_ip6tables_store(\n\tstruct device *d, struct device_attribute *attr, const char *buf,\n\tsize_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_nf_call_ip6tables);\n}\nstatic DEVICE_ATTR_RW(nf_call_ip6tables);\n\nstatic ssize_t nf_call_arptables_show(\n\tstruct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%u\\n\", br_opt_get(br, BROPT_NF_CALL_ARPTABLES));\n}\n\nstatic int set_nf_call_arptables(struct net_bridge *br, unsigned long val,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tbr_opt_toggle(br, BROPT_NF_CALL_ARPTABLES, !!val);\n\treturn 0;\n}\n\nstatic ssize_t nf_call_arptables_store(\n\tstruct device *d, struct device_attribute *attr, const char *buf,\n\tsize_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_nf_call_arptables);\n}\nstatic DEVICE_ATTR_RW(nf_call_arptables);\n#endif\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\nstatic ssize_t vlan_filtering_show(struct device *d,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%d\\n\", br_opt_get(br, BROPT_VLAN_ENABLED));\n}\n\nstatic ssize_t vlan_filtering_store(struct device *d,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, br_vlan_filter_toggle);\n}\nstatic DEVICE_ATTR_RW(vlan_filtering);\n\nstatic ssize_t vlan_protocol_show(struct device *d,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%#06x\\n\", ntohs(br->vlan_proto));\n}\n\nstatic ssize_t vlan_protocol_store(struct device *d,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, br_vlan_set_proto);\n}\nstatic DEVICE_ATTR_RW(vlan_protocol);\n\nstatic ssize_t default_pvid_show(struct device *d,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%d\\n\", br->default_pvid);\n}\n\nstatic ssize_t default_pvid_store(struct device *d,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, br_vlan_set_default_pvid);\n}\nstatic DEVICE_ATTR_RW(default_pvid);\n\nstatic ssize_t vlan_stats_enabled_show(struct device *d,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%u\\n\", br_opt_get(br, BROPT_VLAN_STATS_ENABLED));\n}\n\nstatic int set_vlan_stats_enabled(struct net_bridge *br, unsigned long val,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn br_vlan_set_stats(br, val);\n}\n\nstatic ssize_t vlan_stats_enabled_store(struct device *d,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_vlan_stats_enabled);\n}\nstatic DEVICE_ATTR_RW(vlan_stats_enabled);\n\nstatic ssize_t vlan_stats_per_port_show(struct device *d,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct net_bridge *br = to_bridge(d);\n\treturn sprintf(buf, \"%u\\n\", br_opt_get(br, BROPT_VLAN_STATS_PER_PORT));\n}\n\nstatic int set_vlan_stats_per_port(struct net_bridge *br, unsigned long val,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\treturn br_vlan_set_stats_per_port(br, val);\n}\n\nstatic ssize_t vlan_stats_per_port_store(struct device *d,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t len)\n{\n\treturn store_bridge_parm(d, buf, len, set_vlan_stats_per_port);\n}\nstatic DEVICE_ATTR_RW(vlan_stats_per_port);\n#endif\n\nstatic struct attribute *bridge_attrs[] = {\n\t&dev_attr_forward_delay.attr,\n\t&dev_attr_hello_time.attr,\n\t&dev_attr_max_age.attr,\n\t&dev_attr_ageing_time.attr,\n\t&dev_attr_stp_state.attr,\n\t&dev_attr_group_fwd_mask.attr,\n\t&dev_attr_priority.attr,\n\t&dev_attr_bridge_id.attr,\n\t&dev_attr_root_id.attr,\n\t&dev_attr_root_path_cost.attr,\n\t&dev_attr_root_port.attr,\n\t&dev_attr_topology_change.attr,\n\t&dev_attr_topology_change_detected.attr,\n\t&dev_attr_hello_timer.attr,\n\t&dev_attr_tcn_timer.attr,\n\t&dev_attr_topology_change_timer.attr,\n\t&dev_attr_gc_timer.attr,\n\t&dev_attr_group_addr.attr,\n\t&dev_attr_flush.attr,\n\t&dev_attr_no_linklocal_learn.attr,\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\t&dev_attr_multicast_router.attr,\n\t&dev_attr_multicast_snooping.attr,\n\t&dev_attr_multicast_querier.attr,\n\t&dev_attr_multicast_query_use_ifaddr.attr,\n\t&dev_attr_hash_elasticity.attr,\n\t&dev_attr_hash_max.attr,\n\t&dev_attr_multicast_last_member_count.attr,\n\t&dev_attr_multicast_startup_query_count.attr,\n\t&dev_attr_multicast_last_member_interval.attr,\n\t&dev_attr_multicast_membership_interval.attr,\n\t&dev_attr_multicast_querier_interval.attr,\n\t&dev_attr_multicast_query_interval.attr,\n\t&dev_attr_multicast_query_response_interval.attr,\n\t&dev_attr_multicast_startup_query_interval.attr,\n\t&dev_attr_multicast_stats_enabled.attr,\n\t&dev_attr_multicast_igmp_version.attr,\n#if IS_ENABLED(CONFIG_IPV6)\n\t&dev_attr_multicast_mld_version.attr,\n#endif\n#endif\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\t&dev_attr_nf_call_iptables.attr,\n\t&dev_attr_nf_call_ip6tables.attr,\n\t&dev_attr_nf_call_arptables.attr,\n#endif\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\n\t&dev_attr_vlan_filtering.attr,\n\t&dev_attr_vlan_protocol.attr,\n\t&dev_attr_default_pvid.attr,\n\t&dev_attr_vlan_stats_enabled.attr,\n\t&dev_attr_vlan_stats_per_port.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group bridge_group = {\n\t.name = SYSFS_BRIDGE_ATTR,\n\t.attrs = bridge_attrs,\n};\n\n \nstatic ssize_t brforward_read(struct file *filp, struct kobject *kobj,\n\t\t\t      struct bin_attribute *bin_attr,\n\t\t\t      char *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct net_bridge *br = to_bridge(dev);\n\tint n;\n\n\t \n\tif (off % sizeof(struct __fdb_entry) != 0)\n\t\treturn -EINVAL;\n\n\tn =  br_fdb_fillbuf(br, buf,\n\t\t\t    count / sizeof(struct __fdb_entry),\n\t\t\t    off / sizeof(struct __fdb_entry));\n\n\tif (n > 0)\n\t\tn *= sizeof(struct __fdb_entry);\n\n\treturn n;\n}\n\nstatic struct bin_attribute bridge_forward = {\n\t.attr = { .name = SYSFS_BRIDGE_FDB,\n\t\t  .mode = 0444, },\n\t.read = brforward_read,\n};\n\n \nint br_sysfs_addbr(struct net_device *dev)\n{\n\tstruct kobject *brobj = &dev->dev.kobj;\n\tstruct net_bridge *br = netdev_priv(dev);\n\tint err;\n\n\terr = sysfs_create_group(brobj, &bridge_group);\n\tif (err) {\n\t\tpr_info(\"%s: can't create group %s/%s\\n\",\n\t\t\t__func__, dev->name, bridge_group.name);\n\t\tgoto out1;\n\t}\n\n\terr = sysfs_create_bin_file(brobj, &bridge_forward);\n\tif (err) {\n\t\tpr_info(\"%s: can't create attribute file %s/%s\\n\",\n\t\t\t__func__, dev->name, bridge_forward.attr.name);\n\t\tgoto out2;\n\t}\n\n\tbr->ifobj = kobject_create_and_add(SYSFS_BRIDGE_PORT_SUBDIR, brobj);\n\tif (!br->ifobj) {\n\t\tpr_info(\"%s: can't add kobject (directory) %s/%s\\n\",\n\t\t\t__func__, dev->name, SYSFS_BRIDGE_PORT_SUBDIR);\n\t\terr = -ENOMEM;\n\t\tgoto out3;\n\t}\n\treturn 0;\n out3:\n\tsysfs_remove_bin_file(&dev->dev.kobj, &bridge_forward);\n out2:\n\tsysfs_remove_group(&dev->dev.kobj, &bridge_group);\n out1:\n\treturn err;\n\n}\n\nvoid br_sysfs_delbr(struct net_device *dev)\n{\n\tstruct kobject *kobj = &dev->dev.kobj;\n\tstruct net_bridge *br = netdev_priv(dev);\n\n\tkobject_put(br->ifobj);\n\tsysfs_remove_bin_file(kobj, &bridge_forward);\n\tsysfs_remove_group(kobj, &bridge_group);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}