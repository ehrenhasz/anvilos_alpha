{
  "module_name": "br_stp_if.c",
  "hash_id": "2133788da3bb9cb23b90859d53d27fc181f447a8f12dc8df2a8a69f00f34a6c1",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_stp_if.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <net/switchdev.h>\n\n#include \"br_private.h\"\n#include \"br_private_stp.h\"\n\n\n \nstatic inline port_id br_make_port_id(__u8 priority, __u16 port_no)\n{\n\treturn ((u16)priority << BR_PORT_BITS)\n\t\t| (port_no & ((1<<BR_PORT_BITS)-1));\n}\n\n#define BR_MAX_PORT_PRIORITY ((u16)~0 >> BR_PORT_BITS)\n\n \nvoid br_init_port(struct net_bridge_port *p)\n{\n\tint err;\n\n\tp->port_id = br_make_port_id(p->priority, p->port_no);\n\tbr_become_designated_port(p);\n\tbr_set_state(p, BR_STATE_BLOCKING);\n\tp->topology_change_ack = 0;\n\tp->config_pending = 0;\n\n\terr = __set_ageing_time(p->dev, p->br->ageing_time);\n\tif (err)\n\t\tnetdev_err(p->dev, \"failed to offload ageing time\\n\");\n}\n\n \nvoid br_stp_enable_bridge(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\n\tspin_lock_bh(&br->lock);\n\tif (br->stp_enabled == BR_KERNEL_STP)\n\t\tmod_timer(&br->hello_timer, jiffies + br->hello_time);\n\tmod_delayed_work(system_long_wq, &br->gc_work, HZ / 10);\n\n\tbr_config_bpdu_generation(br);\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (netif_running(p->dev) && netif_oper_up(p->dev))\n\t\t\tbr_stp_enable_port(p);\n\n\t}\n\tspin_unlock_bh(&br->lock);\n}\n\n \nvoid br_stp_disable_bridge(struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\n\tspin_lock_bh(&br->lock);\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->state != BR_STATE_DISABLED)\n\t\t\tbr_stp_disable_port(p);\n\n\t}\n\n\t__br_set_topology_change(br, 0);\n\tbr->topology_change_detected = 0;\n\tspin_unlock_bh(&br->lock);\n\n\tdel_timer_sync(&br->hello_timer);\n\tdel_timer_sync(&br->topology_change_timer);\n\tdel_timer_sync(&br->tcn_timer);\n\tcancel_delayed_work_sync(&br->gc_work);\n}\n\n \nvoid br_stp_enable_port(struct net_bridge_port *p)\n{\n\tbr_init_port(p);\n\tbr_port_state_selection(p->br);\n\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n}\n\n \nvoid br_stp_disable_port(struct net_bridge_port *p)\n{\n\tstruct net_bridge *br = p->br;\n\tint wasroot;\n\n\twasroot = br_is_root_bridge(br);\n\tbr_become_designated_port(p);\n\tbr_set_state(p, BR_STATE_DISABLED);\n\tp->topology_change_ack = 0;\n\tp->config_pending = 0;\n\n\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\n\tdel_timer(&p->message_age_timer);\n\tdel_timer(&p->forward_delay_timer);\n\tdel_timer(&p->hold_timer);\n\n\tif (!rcu_access_pointer(p->backup_port))\n\t\tbr_fdb_delete_by_port(br, p, 0, 0);\n\tbr_multicast_disable_port(p);\n\n\tbr_configuration_update(br);\n\n\tbr_port_state_selection(br);\n\n\tif (br_is_root_bridge(br) && !wasroot)\n\t\tbr_become_root_bridge(br);\n}\n\nstatic int br_stp_call_user(struct net_bridge *br, char *arg)\n{\n\tchar *argv[] = { BR_STP_PROG, br->dev->name, arg, NULL };\n\tchar *envp[] = { NULL };\n\tint rc;\n\n\t \n\trc = call_usermodehelper(BR_STP_PROG, argv, envp, UMH_WAIT_PROC);\n\tif (rc > 0) {\n\t\tif (rc & 0xff)\n\t\t\tbr_debug(br, BR_STP_PROG \" received signal %d\\n\",\n\t\t\t\t rc & 0x7f);\n\t\telse\n\t\t\tbr_debug(br, BR_STP_PROG \" exited with code %d\\n\",\n\t\t\t\t (rc >> 8) & 0xff);\n\t}\n\n\treturn rc;\n}\n\nstatic void br_stp_start(struct net_bridge *br)\n{\n\tint err = -ENOENT;\n\n\tif (net_eq(dev_net(br->dev), &init_net))\n\t\terr = br_stp_call_user(br, \"start\");\n\n\tif (err && err != -ENOENT)\n\t\tbr_err(br, \"failed to start userspace STP (%d)\\n\", err);\n\n\tspin_lock_bh(&br->lock);\n\n\tif (br->bridge_forward_delay < BR_MIN_FORWARD_DELAY)\n\t\t__br_set_forward_delay(br, BR_MIN_FORWARD_DELAY);\n\telse if (br->bridge_forward_delay > BR_MAX_FORWARD_DELAY)\n\t\t__br_set_forward_delay(br, BR_MAX_FORWARD_DELAY);\n\n\tif (!err) {\n\t\tbr->stp_enabled = BR_USER_STP;\n\t\tbr_debug(br, \"userspace STP started\\n\");\n\t} else {\n\t\tbr->stp_enabled = BR_KERNEL_STP;\n\t\tbr_debug(br, \"using kernel STP\\n\");\n\n\t\t \n\t\tif (br->dev->flags & IFF_UP)\n\t\t\tmod_timer(&br->hello_timer, jiffies + br->hello_time);\n\t\tbr_port_state_selection(br);\n\t}\n\n\tspin_unlock_bh(&br->lock);\n}\n\nstatic void br_stp_stop(struct net_bridge *br)\n{\n\tint err;\n\n\tif (br->stp_enabled == BR_USER_STP) {\n\t\terr = br_stp_call_user(br, \"stop\");\n\t\tif (err)\n\t\t\tbr_err(br, \"failed to stop userspace STP (%d)\\n\", err);\n\n\t\t \n\t\tspin_lock_bh(&br->lock);\n\t\tbr_port_state_selection(br);\n\t\tspin_unlock_bh(&br->lock);\n\t}\n\n\tbr->stp_enabled = BR_NO_STP;\n}\n\nint br_stp_set_enabled(struct net_bridge *br, unsigned long val,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tASSERT_RTNL();\n\n\tif (br_mrp_enabled(br)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"STP can't be enabled if MRP is already enabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (val) {\n\t\tif (br->stp_enabled == BR_NO_STP)\n\t\t\tbr_stp_start(br);\n\t} else {\n\t\tif (br->stp_enabled != BR_NO_STP)\n\t\t\tbr_stp_stop(br);\n\t}\n\n\treturn 0;\n}\n\n \nvoid br_stp_change_bridge_id(struct net_bridge *br, const unsigned char *addr)\n{\n\t \n\tunsigned short oldaddr_aligned[ETH_ALEN >> 1];\n\tunsigned char *oldaddr = (unsigned char *)oldaddr_aligned;\n\tstruct net_bridge_port *p;\n\tint wasroot;\n\n\twasroot = br_is_root_bridge(br);\n\n\tbr_fdb_change_mac_address(br, addr);\n\n\tmemcpy(oldaddr, br->bridge_id.addr, ETH_ALEN);\n\tmemcpy(br->bridge_id.addr, addr, ETH_ALEN);\n\teth_hw_addr_set(br->dev, addr);\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (ether_addr_equal(p->designated_bridge.addr, oldaddr))\n\t\t\tmemcpy(p->designated_bridge.addr, addr, ETH_ALEN);\n\n\t\tif (ether_addr_equal(p->designated_root.addr, oldaddr))\n\t\t\tmemcpy(p->designated_root.addr, addr, ETH_ALEN);\n\t}\n\n\tbr_configuration_update(br);\n\tbr_port_state_selection(br);\n\tif (br_is_root_bridge(br) && !wasroot)\n\t\tbr_become_root_bridge(br);\n}\n\n \nstatic const unsigned short br_mac_zero_aligned[ETH_ALEN >> 1];\n\n \nbool br_stp_recalculate_bridge_id(struct net_bridge *br)\n{\n\tconst unsigned char *br_mac_zero =\n\t\t\t(const unsigned char *)br_mac_zero_aligned;\n\tconst unsigned char *addr = br_mac_zero;\n\tstruct net_bridge_port *p;\n\n\t \n\tif (br->dev->addr_assign_type == NET_ADDR_SET)\n\t\treturn false;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (addr == br_mac_zero ||\n\t\t    memcmp(p->dev->dev_addr, addr, ETH_ALEN) < 0)\n\t\t\taddr = p->dev->dev_addr;\n\n\t}\n\n\tif (ether_addr_equal(br->bridge_id.addr, addr))\n\t\treturn false;\t \n\n\tbr_stp_change_bridge_id(br, addr);\n\treturn true;\n}\n\n \nvoid br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)\n{\n\tstruct net_bridge_port *p;\n\tint wasroot;\n\n\tspin_lock_bh(&br->lock);\n\twasroot = br_is_root_bridge(br);\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->state != BR_STATE_DISABLED &&\n\t\t    br_is_designated_port(p)) {\n\t\t\tp->designated_bridge.prio[0] = (newprio >> 8) & 0xFF;\n\t\t\tp->designated_bridge.prio[1] = newprio & 0xFF;\n\t\t}\n\n\t}\n\n\tbr->bridge_id.prio[0] = (newprio >> 8) & 0xFF;\n\tbr->bridge_id.prio[1] = newprio & 0xFF;\n\tbr_configuration_update(br);\n\tbr_port_state_selection(br);\n\tif (br_is_root_bridge(br) && !wasroot)\n\t\tbr_become_root_bridge(br);\n\tspin_unlock_bh(&br->lock);\n}\n\n \nint br_stp_set_port_priority(struct net_bridge_port *p, unsigned long newprio)\n{\n\tport_id new_port_id;\n\n\tif (newprio > BR_MAX_PORT_PRIORITY)\n\t\treturn -ERANGE;\n\n\tnew_port_id = br_make_port_id(newprio, p->port_no);\n\tif (br_is_designated_port(p))\n\t\tp->designated_port = new_port_id;\n\n\tp->port_id = new_port_id;\n\tp->priority = newprio;\n\tif (!memcmp(&p->br->bridge_id, &p->designated_bridge, 8) &&\n\t    p->port_id < p->designated_port) {\n\t\tbr_become_designated_port(p);\n\t\tbr_port_state_selection(p->br);\n\t}\n\n\treturn 0;\n}\n\n \nint br_stp_set_path_cost(struct net_bridge_port *p, unsigned long path_cost)\n{\n\tif (path_cost < BR_MIN_PATH_COST ||\n\t    path_cost > BR_MAX_PATH_COST)\n\t\treturn -ERANGE;\n\n\tp->flags |= BR_ADMIN_COST;\n\tp->path_cost = path_cost;\n\tbr_configuration_update(p->br);\n\tbr_port_state_selection(p->br);\n\treturn 0;\n}\n\nssize_t br_show_bridge_id(char *buf, const struct bridge_id *id)\n{\n\treturn sprintf(buf, \"%.2x%.2x.%.2x%.2x%.2x%.2x%.2x%.2x\\n\",\n\t       id->prio[0], id->prio[1],\n\t       id->addr[0], id->addr[1], id->addr[2],\n\t       id->addr[3], id->addr[4], id->addr[5]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}