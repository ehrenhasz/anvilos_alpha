{
  "module_name": "ebt_log.c",
  "hash_id": "d9bde0b7197875f9a9e6af499f7601181799cc5d3bd905da2914ad94839c0a54",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/netfilter/ebt_log.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/in.h>\n#include <linux/if_arp.h>\n#include <linux/spinlock.h>\n#include <net/netfilter/nf_log.h>\n#include <linux/ipv6.h>\n#include <net/ipv6.h>\n#include <linux/in6.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_bridge/ebtables.h>\n#include <linux/netfilter_bridge/ebt_log.h>\n#include <linux/netfilter.h>\n\nstatic DEFINE_SPINLOCK(ebt_log_lock);\n\nstatic int ebt_log_tg_check(const struct xt_tgchk_param *par)\n{\n\tstruct ebt_log_info *info = par->targinfo;\n\n\tif (info->bitmask & ~EBT_LOG_MASK)\n\t\treturn -EINVAL;\n\tif (info->loglevel >= 8)\n\t\treturn -EINVAL;\n\tinfo->prefix[EBT_LOG_PREFIX_SIZE - 1] = '\\0';\n\treturn 0;\n}\n\nstruct tcpudphdr {\n\t__be16 src;\n\t__be16 dst;\n};\n\nstruct arppayload {\n\tunsigned char mac_src[ETH_ALEN];\n\tunsigned char ip_src[4];\n\tunsigned char mac_dst[ETH_ALEN];\n\tunsigned char ip_dst[4];\n};\n\nstatic void\nprint_ports(const struct sk_buff *skb, uint8_t protocol, int offset)\n{\n\tif (protocol == IPPROTO_TCP ||\n\t    protocol == IPPROTO_UDP ||\n\t    protocol == IPPROTO_UDPLITE ||\n\t    protocol == IPPROTO_SCTP ||\n\t    protocol == IPPROTO_DCCP) {\n\t\tconst struct tcpudphdr *pptr;\n\t\tstruct tcpudphdr _ports;\n\n\t\tpptr = skb_header_pointer(skb, offset,\n\t\t\t\t\t  sizeof(_ports), &_ports);\n\t\tif (pptr == NULL) {\n\t\t\tpr_cont(\" INCOMPLETE TCP/UDP header\");\n\t\t\treturn;\n\t\t}\n\t\tpr_cont(\" SPT=%u DPT=%u\", ntohs(pptr->src), ntohs(pptr->dst));\n\t}\n}\n\nstatic void\nebt_log_packet(struct net *net, u_int8_t pf, unsigned int hooknum,\n\t       const struct sk_buff *skb, const struct net_device *in,\n\t       const struct net_device *out, const struct nf_loginfo *loginfo,\n\t       const char *prefix)\n{\n\tunsigned int bitmask;\n\n\t \n\tif (!net_eq(net, &init_net) && !sysctl_nf_log_all_netns)\n\t\treturn;\n\n\tspin_lock_bh(&ebt_log_lock);\n\tprintk(KERN_SOH \"%c%s IN=%s OUT=%s MAC source = %pM MAC dest = %pM proto = 0x%04x\",\n\t       '0' + loginfo->u.log.level, prefix,\n\t       in ? in->name : \"\", out ? out->name : \"\",\n\t       eth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,\n\t       ntohs(eth_hdr(skb)->h_proto));\n\n\tif (loginfo->type == NF_LOG_TYPE_LOG)\n\t\tbitmask = loginfo->u.log.logflags;\n\telse\n\t\tbitmask = NF_LOG_DEFAULT_MASK;\n\n\tif ((bitmask & EBT_LOG_IP) && eth_hdr(skb)->h_proto ==\n\t   htons(ETH_P_IP)) {\n\t\tconst struct iphdr *ih;\n\t\tstruct iphdr _iph;\n\n\t\tih = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\n\t\tif (ih == NULL) {\n\t\t\tpr_cont(\" INCOMPLETE IP header\");\n\t\t\tgoto out;\n\t\t}\n\t\tpr_cont(\" IP SRC=%pI4 IP DST=%pI4, IP tos=0x%02X, IP proto=%d\",\n\t\t\t&ih->saddr, &ih->daddr, ih->tos, ih->protocol);\n\t\tprint_ports(skb, ih->protocol, ih->ihl*4);\n\t\tgoto out;\n\t}\n\n#if IS_ENABLED(CONFIG_BRIDGE_EBT_IP6)\n\tif ((bitmask & EBT_LOG_IP6) && eth_hdr(skb)->h_proto ==\n\t   htons(ETH_P_IPV6)) {\n\t\tconst struct ipv6hdr *ih;\n\t\tstruct ipv6hdr _iph;\n\t\tuint8_t nexthdr;\n\t\t__be16 frag_off;\n\t\tint offset_ph;\n\n\t\tih = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\n\t\tif (ih == NULL) {\n\t\t\tpr_cont(\" INCOMPLETE IPv6 header\");\n\t\t\tgoto out;\n\t\t}\n\t\tpr_cont(\" IPv6 SRC=%pI6 IPv6 DST=%pI6, IPv6 priority=0x%01X, Next Header=%d\",\n\t\t\t&ih->saddr, &ih->daddr, ih->priority, ih->nexthdr);\n\t\tnexthdr = ih->nexthdr;\n\t\toffset_ph = ipv6_skip_exthdr(skb, sizeof(_iph), &nexthdr, &frag_off);\n\t\tif (offset_ph == -1)\n\t\t\tgoto out;\n\t\tprint_ports(skb, nexthdr, offset_ph);\n\t\tgoto out;\n\t}\n#endif\n\n\tif ((bitmask & EBT_LOG_ARP) &&\n\t    ((eth_hdr(skb)->h_proto == htons(ETH_P_ARP)) ||\n\t     (eth_hdr(skb)->h_proto == htons(ETH_P_RARP)))) {\n\t\tconst struct arphdr *ah;\n\t\tstruct arphdr _arph;\n\n\t\tah = skb_header_pointer(skb, 0, sizeof(_arph), &_arph);\n\t\tif (ah == NULL) {\n\t\t\tpr_cont(\" INCOMPLETE ARP header\");\n\t\t\tgoto out;\n\t\t}\n\t\tpr_cont(\" ARP HTYPE=%d, PTYPE=0x%04x, OPCODE=%d\",\n\t\t\tntohs(ah->ar_hrd), ntohs(ah->ar_pro),\n\t\t\tntohs(ah->ar_op));\n\n\t\t \n\t\tif (ah->ar_hrd == htons(1) &&\n\t\t    ah->ar_hln == ETH_ALEN &&\n\t\t    ah->ar_pln == sizeof(__be32)) {\n\t\t\tconst struct arppayload *ap;\n\t\t\tstruct arppayload _arpp;\n\n\t\t\tap = skb_header_pointer(skb, sizeof(_arph),\n\t\t\t\t\t\tsizeof(_arpp), &_arpp);\n\t\t\tif (ap == NULL) {\n\t\t\t\tpr_cont(\" INCOMPLETE ARP payload\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpr_cont(\" ARP MAC SRC=%pM ARP IP SRC=%pI4 ARP MAC DST=%pM ARP IP DST=%pI4\",\n\t\t\t\tap->mac_src, ap->ip_src,\n\t\t\t\tap->mac_dst, ap->ip_dst);\n\t\t}\n\t}\nout:\n\tpr_cont(\"\\n\");\n\tspin_unlock_bh(&ebt_log_lock);\n}\n\nstatic unsigned int\nebt_log_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct ebt_log_info *info = par->targinfo;\n\tstruct nf_loginfo li;\n\tstruct net *net = xt_net(par);\n\n\tli.type = NF_LOG_TYPE_LOG;\n\tli.u.log.level = info->loglevel;\n\tli.u.log.logflags = info->bitmask;\n\n\t \n\tif (info->bitmask & EBT_LOG_NFLOG)\n\t\tnf_log_packet(net, NFPROTO_BRIDGE, xt_hooknum(par), skb,\n\t\t\t      xt_in(par), xt_out(par), &li, \"%s\",\n\t\t\t      info->prefix);\n\telse\n\t\tebt_log_packet(net, NFPROTO_BRIDGE, xt_hooknum(par), skb,\n\t\t\t       xt_in(par), xt_out(par), &li, info->prefix);\n\treturn EBT_CONTINUE;\n}\n\nstatic struct xt_target ebt_log_tg_reg __read_mostly = {\n\t.name\t\t= \"log\",\n\t.revision\t= 0,\n\t.family\t\t= NFPROTO_BRIDGE,\n\t.target\t\t= ebt_log_tg,\n\t.checkentry\t= ebt_log_tg_check,\n\t.targetsize\t= sizeof(struct ebt_log_info),\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init ebt_log_init(void)\n{\n\treturn xt_register_target(&ebt_log_tg_reg);\n}\n\nstatic void __exit ebt_log_fini(void)\n{\n\txt_unregister_target(&ebt_log_tg_reg);\n}\n\nmodule_init(ebt_log_init);\nmodule_exit(ebt_log_fini);\nMODULE_DESCRIPTION(\"Ebtables: Packet logging to syslog\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}