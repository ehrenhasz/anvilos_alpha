{
  "module_name": "ebt_among.c",
  "hash_id": "df21d6457ceff8bd243b47de88e52b193c2fdd5853d25b9da84abb08567f06c1",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/netfilter/ebt_among.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/ip.h>\n#include <linux/if_arp.h>\n#include <linux/module.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_bridge/ebtables.h>\n#include <linux/netfilter_bridge/ebt_among.h>\n\nstatic bool ebt_mac_wormhash_contains(const struct ebt_mac_wormhash *wh,\n\t\t\t\t      const char *mac, __be32 ip)\n{\n\t \n\tconst struct ebt_mac_wormhash_tuple *p;\n\tint start, limit, i;\n\tuint32_t cmp[2] = { 0, 0 };\n\tint key = ((const unsigned char *)mac)[5];\n\n\tether_addr_copy(((char *) cmp) + 2, mac);\n\tstart = wh->table[key];\n\tlimit = wh->table[key + 1];\n\tif (ip) {\n\t\tfor (i = start; i < limit; i++) {\n\t\t\tp = &wh->pool[i];\n\t\t\tif (cmp[1] == p->cmp[1] && cmp[0] == p->cmp[0])\n\t\t\t\tif (p->ip == 0 || p->ip == ip)\n\t\t\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tfor (i = start; i < limit; i++) {\n\t\t\tp = &wh->pool[i];\n\t\t\tif (cmp[1] == p->cmp[1] && cmp[0] == p->cmp[0])\n\t\t\t\tif (p->ip == 0)\n\t\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int ebt_mac_wormhash_check_integrity(const struct ebt_mac_wormhash\n\t\t\t\t\t    *wh)\n{\n\tint i;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (wh->table[i] > wh->table[i + 1])\n\t\t\treturn -0x100 - i;\n\t\tif (wh->table[i] < 0)\n\t\t\treturn -0x200 - i;\n\t\tif (wh->table[i] > wh->poolsize)\n\t\t\treturn -0x300 - i;\n\t}\n\tif (wh->table[256] > wh->poolsize)\n\t\treturn -0xc00;\n\treturn 0;\n}\n\nstatic int get_ip_dst(const struct sk_buff *skb, __be32 *addr)\n{\n\tif (eth_hdr(skb)->h_proto == htons(ETH_P_IP)) {\n\t\tconst struct iphdr *ih;\n\t\tstruct iphdr _iph;\n\n\t\tih = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\n\t\tif (ih == NULL)\n\t\t\treturn -1;\n\t\t*addr = ih->daddr;\n\t} else if (eth_hdr(skb)->h_proto == htons(ETH_P_ARP)) {\n\t\tconst struct arphdr *ah;\n\t\tstruct arphdr _arph;\n\t\tconst __be32 *bp;\n\t\t__be32 buf;\n\n\t\tah = skb_header_pointer(skb, 0, sizeof(_arph), &_arph);\n\t\tif (ah == NULL ||\n\t\t    ah->ar_pln != sizeof(__be32) ||\n\t\t    ah->ar_hln != ETH_ALEN)\n\t\t\treturn -1;\n\t\tbp = skb_header_pointer(skb, sizeof(struct arphdr) +\n\t\t\t\t\t2 * ETH_ALEN + sizeof(__be32),\n\t\t\t\t\tsizeof(__be32), &buf);\n\t\tif (bp == NULL)\n\t\t\treturn -1;\n\t\t*addr = *bp;\n\t}\n\treturn 0;\n}\n\nstatic int get_ip_src(const struct sk_buff *skb, __be32 *addr)\n{\n\tif (eth_hdr(skb)->h_proto == htons(ETH_P_IP)) {\n\t\tconst struct iphdr *ih;\n\t\tstruct iphdr _iph;\n\n\t\tih = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\n\t\tif (ih == NULL)\n\t\t\treturn -1;\n\t\t*addr = ih->saddr;\n\t} else if (eth_hdr(skb)->h_proto == htons(ETH_P_ARP)) {\n\t\tconst struct arphdr *ah;\n\t\tstruct arphdr _arph;\n\t\tconst __be32 *bp;\n\t\t__be32 buf;\n\n\t\tah = skb_header_pointer(skb, 0, sizeof(_arph), &_arph);\n\t\tif (ah == NULL ||\n\t\t    ah->ar_pln != sizeof(__be32) ||\n\t\t    ah->ar_hln != ETH_ALEN)\n\t\t\treturn -1;\n\t\tbp = skb_header_pointer(skb, sizeof(struct arphdr) +\n\t\t\t\t\tETH_ALEN, sizeof(__be32), &buf);\n\t\tif (bp == NULL)\n\t\t\treturn -1;\n\t\t*addr = *bp;\n\t}\n\treturn 0;\n}\n\nstatic bool\nebt_among_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct ebt_among_info *info = par->matchinfo;\n\tconst char *dmac, *smac;\n\tconst struct ebt_mac_wormhash *wh_dst, *wh_src;\n\t__be32 dip = 0, sip = 0;\n\n\twh_dst = ebt_among_wh_dst(info);\n\twh_src = ebt_among_wh_src(info);\n\n\tif (wh_src) {\n\t\tsmac = eth_hdr(skb)->h_source;\n\t\tif (get_ip_src(skb, &sip))\n\t\t\treturn false;\n\t\tif (!(info->bitmask & EBT_AMONG_SRC_NEG)) {\n\t\t\t \n\t\t\tif (!ebt_mac_wormhash_contains(wh_src, smac, sip))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\t \n\t\t\tif (ebt_mac_wormhash_contains(wh_src, smac, sip))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (wh_dst) {\n\t\tdmac = eth_hdr(skb)->h_dest;\n\t\tif (get_ip_dst(skb, &dip))\n\t\t\treturn false;\n\t\tif (!(info->bitmask & EBT_AMONG_DST_NEG)) {\n\t\t\t \n\t\t\tif (!ebt_mac_wormhash_contains(wh_dst, dmac, dip))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\t \n\t\t\tif (ebt_mac_wormhash_contains(wh_dst, dmac, dip))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool poolsize_invalid(const struct ebt_mac_wormhash *w)\n{\n\treturn w && w->poolsize >= (INT_MAX / sizeof(struct ebt_mac_wormhash_tuple));\n}\n\nstatic bool wormhash_offset_invalid(int off, unsigned int len)\n{\n\tif (off == 0)  \n\t\treturn false;\n\n\tif (off < (int)sizeof(struct ebt_among_info) ||\n\t    off % __alignof__(struct ebt_mac_wormhash))\n\t\treturn true;\n\n\toff += sizeof(struct ebt_mac_wormhash);\n\n\treturn off > len;\n}\n\nstatic bool wormhash_sizes_valid(const struct ebt_mac_wormhash *wh, int a, int b)\n{\n\tif (a == 0)\n\t\ta = sizeof(struct ebt_among_info);\n\n\treturn ebt_mac_wormhash_size(wh) + a == b;\n}\n\nstatic int ebt_among_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ebt_among_info *info = par->matchinfo;\n\tconst struct ebt_entry_match *em =\n\t\tcontainer_of(par->matchinfo, const struct ebt_entry_match, data);\n\tunsigned int expected_length = sizeof(struct ebt_among_info);\n\tconst struct ebt_mac_wormhash *wh_dst, *wh_src;\n\tint err;\n\n\tif (expected_length > em->match_size)\n\t\treturn -EINVAL;\n\n\tif (wormhash_offset_invalid(info->wh_dst_ofs, em->match_size) ||\n\t    wormhash_offset_invalid(info->wh_src_ofs, em->match_size))\n\t\treturn -EINVAL;\n\n\twh_dst = ebt_among_wh_dst(info);\n\tif (poolsize_invalid(wh_dst))\n\t\treturn -EINVAL;\n\n\texpected_length += ebt_mac_wormhash_size(wh_dst);\n\tif (expected_length > em->match_size)\n\t\treturn -EINVAL;\n\n\twh_src = ebt_among_wh_src(info);\n\tif (poolsize_invalid(wh_src))\n\t\treturn -EINVAL;\n\n\tif (info->wh_src_ofs < info->wh_dst_ofs) {\n\t\tif (!wormhash_sizes_valid(wh_src, info->wh_src_ofs, info->wh_dst_ofs))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!wormhash_sizes_valid(wh_dst, info->wh_dst_ofs, info->wh_src_ofs))\n\t\t\treturn -EINVAL;\n\t}\n\n\texpected_length += ebt_mac_wormhash_size(wh_src);\n\n\tif (em->match_size != EBT_ALIGN(expected_length)) {\n\t\tpr_err_ratelimited(\"wrong size: %d against expected %d, rounded to %zd\\n\",\n\t\t\t\t   em->match_size, expected_length,\n\t\t\t\t   EBT_ALIGN(expected_length));\n\t\treturn -EINVAL;\n\t}\n\tif (wh_dst && (err = ebt_mac_wormhash_check_integrity(wh_dst))) {\n\t\tpr_err_ratelimited(\"dst integrity fail: %x\\n\", -err);\n\t\treturn -EINVAL;\n\t}\n\tif (wh_src && (err = ebt_mac_wormhash_check_integrity(wh_src))) {\n\t\tpr_err_ratelimited(\"src integrity fail: %x\\n\", -err);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct xt_match ebt_among_mt_reg __read_mostly = {\n\t.name\t\t= \"among\",\n\t.revision\t= 0,\n\t.family\t\t= NFPROTO_BRIDGE,\n\t.match\t\t= ebt_among_mt,\n\t.checkentry\t= ebt_among_mt_check,\n\t.matchsize\t= -1,  \n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init ebt_among_init(void)\n{\n\treturn xt_register_match(&ebt_among_mt_reg);\n}\n\nstatic void __exit ebt_among_fini(void)\n{\n\txt_unregister_match(&ebt_among_mt_reg);\n}\n\nmodule_init(ebt_among_init);\nmodule_exit(ebt_among_fini);\nMODULE_DESCRIPTION(\"Ebtables: Combined MAC/IP address list matching\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}