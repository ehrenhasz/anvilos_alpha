{
  "module_name": "nft_meta_bridge.c",
  "hash_id": "8ef289d51714a70e42a1fbd5db167c0716e648dc6897a10e9ec8e2a07e1663c0",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/netfilter/nft_meta_bridge.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nft_meta.h>\n#include <linux/if_bridge.h>\n#include <uapi/linux/netfilter_bridge.h>  \n\n#include \"../br_private.h\"\n\nstatic const struct net_device *\nnft_meta_get_bridge(const struct net_device *dev)\n{\n\tif (dev && netif_is_bridge_port(dev))\n\t\treturn netdev_master_upper_dev_get_rcu((struct net_device *)dev);\n\n\treturn NULL;\n}\n\nstatic void nft_meta_bridge_get_eval(const struct nft_expr *expr,\n\t\t\t\t     struct nft_regs *regs,\n\t\t\t\t     const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tconst struct net_device *in = nft_in(pkt), *out = nft_out(pkt);\n\tu32 *dest = &regs->data[priv->dreg];\n\tconst struct net_device *br_dev;\n\n\tswitch (priv->key) {\n\tcase NFT_META_BRI_IIFNAME:\n\t\tbr_dev = nft_meta_get_bridge(in);\n\t\tbreak;\n\tcase NFT_META_BRI_OIFNAME:\n\t\tbr_dev = nft_meta_get_bridge(out);\n\t\tbreak;\n\tcase NFT_META_BRI_IIFPVID: {\n\t\tu16 p_pvid;\n\n\t\tbr_dev = nft_meta_get_bridge(in);\n\t\tif (!br_dev || !br_vlan_enabled(br_dev))\n\t\t\tgoto err;\n\n\t\tbr_vlan_get_pvid_rcu(in, &p_pvid);\n\t\tnft_reg_store16(dest, p_pvid);\n\t\treturn;\n\t}\n\tcase NFT_META_BRI_IIFVPROTO: {\n\t\tu16 p_proto;\n\n\t\tbr_dev = nft_meta_get_bridge(in);\n\t\tif (!br_dev || !br_vlan_enabled(br_dev))\n\t\t\tgoto err;\n\n\t\tbr_vlan_get_proto(br_dev, &p_proto);\n\t\tnft_reg_store_be16(dest, htons(p_proto));\n\t\treturn;\n\t}\n\tdefault:\n\t\treturn nft_meta_get_eval(expr, regs, pkt);\n\t}\n\n\tstrncpy((char *)dest, br_dev ? br_dev->name : \"\", IFNAMSIZ);\n\treturn;\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic int nft_meta_bridge_get_init(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr,\n\t\t\t\t    const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_BRI_IIFNAME:\n\tcase NFT_META_BRI_OIFNAME:\n\t\tlen = IFNAMSIZ;\n\t\tbreak;\n\tcase NFT_META_BRI_IIFPVID:\n\tcase NFT_META_BRI_IIFVPROTO:\n\t\tlen = sizeof(u16);\n\t\tbreak;\n\tdefault:\n\t\treturn nft_meta_get_init(ctx, expr, tb);\n\t}\n\n\tpriv->len = len;\n\treturn nft_parse_register_store(ctx, tb[NFTA_META_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\n\nstatic struct nft_expr_type nft_meta_bridge_type;\nstatic const struct nft_expr_ops nft_meta_bridge_get_ops = {\n\t.type\t\t= &nft_meta_bridge_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.eval\t\t= nft_meta_bridge_get_eval,\n\t.init\t\t= nft_meta_bridge_get_init,\n\t.dump\t\t= nft_meta_get_dump,\n\t.reduce\t\t= nft_meta_get_reduce,\n};\n\nstatic void nft_meta_bridge_set_eval(const struct nft_expr *expr,\n\t\t\t\t     struct nft_regs *regs,\n\t\t\t\t     const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_meta *meta = nft_expr_priv(expr);\n\tu32 *sreg = &regs->data[meta->sreg];\n\tstruct sk_buff *skb = pkt->skb;\n\tu8 value8;\n\n\tswitch (meta->key) {\n\tcase NFT_META_BRI_BROUTE:\n\t\tvalue8 = nft_reg_load8(sreg);\n\t\tBR_INPUT_SKB_CB(skb)->br_netfilter_broute = !!value8;\n\t\tbreak;\n\tdefault:\n\t\tnft_meta_set_eval(expr, regs, pkt);\n\t}\n}\n\nstatic int nft_meta_bridge_set_init(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr,\n\t\t\t\t    const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\tint err;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_BRI_BROUTE:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tdefault:\n\t\treturn nft_meta_set_init(ctx, expr, tb);\n\t}\n\n\tpriv->len = len;\n\terr = nft_parse_register_load(tb[NFTA_META_SREG], &priv->sreg, len);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic bool nft_meta_bridge_set_reduce(struct nft_regs_track *track,\n\t\t\t\t       const struct nft_expr *expr)\n{\n\tint i;\n\n\tfor (i = 0; i < NFT_REG32_NUM; i++) {\n\t\tif (!track->regs[i].selector)\n\t\t\tcontinue;\n\n\t\tif (track->regs[i].selector->ops != &nft_meta_bridge_get_ops)\n\t\t\tcontinue;\n\n\t\t__nft_reg_track_cancel(track, i);\n\t}\n\n\treturn false;\n}\n\nstatic int nft_meta_bridge_set_validate(const struct nft_ctx *ctx,\n\t\t\t\t\tconst struct nft_expr *expr,\n\t\t\t\t\tconst struct nft_data **data)\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int hooks;\n\n\tswitch (priv->key) {\n\tcase NFT_META_BRI_BROUTE:\n\t\thooks = 1 << NF_BR_PRE_ROUTING;\n\t\tbreak;\n\tdefault:\n\t\treturn nft_meta_set_validate(ctx, expr, data);\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\n\nstatic const struct nft_expr_ops nft_meta_bridge_set_ops = {\n\t.type\t\t= &nft_meta_bridge_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.eval\t\t= nft_meta_bridge_set_eval,\n\t.init\t\t= nft_meta_bridge_set_init,\n\t.destroy\t= nft_meta_set_destroy,\n\t.dump\t\t= nft_meta_set_dump,\n\t.reduce\t\t= nft_meta_bridge_set_reduce,\n\t.validate\t= nft_meta_bridge_set_validate,\n};\n\nstatic const struct nft_expr_ops *\nnft_meta_bridge_select_ops(const struct nft_ctx *ctx,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tif (tb[NFTA_META_KEY] == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tb[NFTA_META_DREG] && tb[NFTA_META_SREG])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tb[NFTA_META_DREG])\n\t\treturn &nft_meta_bridge_get_ops;\n\n\tif (tb[NFTA_META_SREG])\n\t\treturn &nft_meta_bridge_set_ops;\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct nft_expr_type nft_meta_bridge_type __read_mostly = {\n\t.family         = NFPROTO_BRIDGE,\n\t.name           = \"meta\",\n\t.select_ops     = nft_meta_bridge_select_ops,\n\t.policy         = nft_meta_policy,\n\t.maxattr        = NFTA_META_MAX,\n\t.owner          = THIS_MODULE,\n};\n\nstatic int __init nft_meta_bridge_module_init(void)\n{\n\treturn nft_register_expr(&nft_meta_bridge_type);\n}\n\nstatic void __exit nft_meta_bridge_module_exit(void)\n{\n\tnft_unregister_expr(&nft_meta_bridge_type);\n}\n\nmodule_init(nft_meta_bridge_module_init);\nmodule_exit(nft_meta_bridge_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"wenxu <wenxu@ucloud.cn>\");\nMODULE_ALIAS_NFT_AF_EXPR(AF_BRIDGE, \"meta\");\nMODULE_DESCRIPTION(\"Support for bridge dedicated meta key\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}