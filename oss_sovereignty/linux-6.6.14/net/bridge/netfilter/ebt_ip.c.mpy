{
  "module_name": "ebt_ip.c",
  "hash_id": "6d558787a1367dc2687152938689689e58723972879c0a83f273432739129cf2",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/netfilter/ebt_ip.c",
  "human_readable_source": "\n \n#include <linux/ip.h>\n#include <net/ip.h>\n#include <linux/in.h>\n#include <linux/module.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_bridge/ebtables.h>\n#include <linux/netfilter_bridge/ebt_ip.h>\n\nunion pkthdr {\n\tstruct {\n\t\t__be16 src;\n\t\t__be16 dst;\n\t} tcpudphdr;\n\tstruct {\n\t\tu8 type;\n\t\tu8 code;\n\t} icmphdr;\n\tstruct {\n\t\tu8 type;\n\t} igmphdr;\n};\n\nstatic bool\nebt_ip_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct ebt_ip_info *info = par->matchinfo;\n\tconst struct iphdr *ih;\n\tstruct iphdr _iph;\n\tconst union pkthdr *pptr;\n\tunion pkthdr _pkthdr;\n\n\tih = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\n\tif (ih == NULL)\n\t\treturn false;\n\tif ((info->bitmask & EBT_IP_TOS) &&\n\t    NF_INVF(info, EBT_IP_TOS, info->tos != ih->tos))\n\t\treturn false;\n\tif ((info->bitmask & EBT_IP_SOURCE) &&\n\t    NF_INVF(info, EBT_IP_SOURCE,\n\t\t    (ih->saddr & info->smsk) != info->saddr))\n\t\treturn false;\n\tif ((info->bitmask & EBT_IP_DEST) &&\n\t    NF_INVF(info, EBT_IP_DEST,\n\t\t    (ih->daddr & info->dmsk) != info->daddr))\n\t\treturn false;\n\tif (info->bitmask & EBT_IP_PROTO) {\n\t\tif (NF_INVF(info, EBT_IP_PROTO, info->protocol != ih->protocol))\n\t\t\treturn false;\n\t\tif (!(info->bitmask & (EBT_IP_DPORT | EBT_IP_SPORT |\n\t\t\t\t       EBT_IP_ICMP | EBT_IP_IGMP)))\n\t\t\treturn true;\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\treturn false;\n\n\t\t \n\t\tpptr = skb_header_pointer(skb, ih->ihl*4,\n\t\t\t\t\t  sizeof(_pkthdr), &_pkthdr);\n\t\tif (pptr == NULL)\n\t\t\treturn false;\n\t\tif (info->bitmask & EBT_IP_DPORT) {\n\t\t\tu32 dst = ntohs(pptr->tcpudphdr.dst);\n\t\t\tif (NF_INVF(info, EBT_IP_DPORT,\n\t\t\t\t    dst < info->dport[0] ||\n\t\t\t\t    dst > info->dport[1]))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (info->bitmask & EBT_IP_SPORT) {\n\t\t\tu32 src = ntohs(pptr->tcpudphdr.src);\n\t\t\tif (NF_INVF(info, EBT_IP_SPORT,\n\t\t\t\t    src < info->sport[0] ||\n\t\t\t\t    src > info->sport[1]))\n\t\t\t\treturn false;\n\t\t}\n\t\tif ((info->bitmask & EBT_IP_ICMP) &&\n\t\t    NF_INVF(info, EBT_IP_ICMP,\n\t\t\t    pptr->icmphdr.type < info->icmp_type[0] ||\n\t\t\t    pptr->icmphdr.type > info->icmp_type[1] ||\n\t\t\t    pptr->icmphdr.code < info->icmp_code[0] ||\n\t\t\t    pptr->icmphdr.code > info->icmp_code[1]))\n\t\t\treturn false;\n\t\tif ((info->bitmask & EBT_IP_IGMP) &&\n\t\t    NF_INVF(info, EBT_IP_IGMP,\n\t\t\t    pptr->igmphdr.type < info->igmp_type[0] ||\n\t\t\t    pptr->igmphdr.type > info->igmp_type[1]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int ebt_ip_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ebt_ip_info *info = par->matchinfo;\n\tconst struct ebt_entry *e = par->entryinfo;\n\n\tif (e->ethproto != htons(ETH_P_IP) ||\n\t   e->invflags & EBT_IPROTO)\n\t\treturn -EINVAL;\n\tif (info->bitmask & ~EBT_IP_MASK || info->invflags & ~EBT_IP_MASK)\n\t\treturn -EINVAL;\n\tif (info->bitmask & (EBT_IP_DPORT | EBT_IP_SPORT)) {\n\t\tif (info->invflags & EBT_IP_PROTO)\n\t\t\treturn -EINVAL;\n\t\tif (info->protocol != IPPROTO_TCP &&\n\t\t    info->protocol != IPPROTO_UDP &&\n\t\t    info->protocol != IPPROTO_UDPLITE &&\n\t\t    info->protocol != IPPROTO_SCTP &&\n\t\t    info->protocol != IPPROTO_DCCP)\n\t\t\t return -EINVAL;\n\t}\n\tif (info->bitmask & EBT_IP_DPORT && info->dport[0] > info->dport[1])\n\t\treturn -EINVAL;\n\tif (info->bitmask & EBT_IP_SPORT && info->sport[0] > info->sport[1])\n\t\treturn -EINVAL;\n\tif (info->bitmask & EBT_IP_ICMP) {\n\t\tif ((info->invflags & EBT_IP_PROTO) ||\n\t\t    info->protocol != IPPROTO_ICMP)\n\t\t\treturn -EINVAL;\n\t\tif (info->icmp_type[0] > info->icmp_type[1] ||\n\t\t    info->icmp_code[0] > info->icmp_code[1])\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->bitmask & EBT_IP_IGMP) {\n\t\tif ((info->invflags & EBT_IP_PROTO) ||\n\t\t    info->protocol != IPPROTO_IGMP)\n\t\t\treturn -EINVAL;\n\t\tif (info->igmp_type[0] > info->igmp_type[1])\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct xt_match ebt_ip_mt_reg __read_mostly = {\n\t.name\t\t= \"ip\",\n\t.revision\t= 0,\n\t.family\t\t= NFPROTO_BRIDGE,\n\t.match\t\t= ebt_ip_mt,\n\t.checkentry\t= ebt_ip_mt_check,\n\t.matchsize\t= sizeof(struct ebt_ip_info),\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init ebt_ip_init(void)\n{\n\treturn xt_register_match(&ebt_ip_mt_reg);\n}\n\nstatic void __exit ebt_ip_fini(void)\n{\n\txt_unregister_match(&ebt_ip_mt_reg);\n}\n\nmodule_init(ebt_ip_init);\nmodule_exit(ebt_ip_fini);\nMODULE_DESCRIPTION(\"Ebtables: IPv4 protocol packet match\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}