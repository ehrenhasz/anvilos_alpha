{
  "module_name": "ebt_stp.c",
  "hash_id": "e5a8676850adcb7decb1f7dd47fedfeb94c9acdd58c59dc1c4e70d99c4ead043",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/netfilter/ebt_stp.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_bridge/ebtables.h>\n#include <linux/netfilter_bridge/ebt_stp.h>\n\n#define BPDU_TYPE_CONFIG 0\n\nstruct stp_header {\n\tu8 dsap;\n\tu8 ssap;\n\tu8 ctrl;\n\tu8 pid;\n\tu8 vers;\n\tu8 type;\n};\n\nstruct stp_config_pdu {\n\tu8 flags;\n\tu8 root[8];\n\tu8 root_cost[4];\n\tu8 sender[8];\n\tu8 port[2];\n\tu8 msg_age[2];\n\tu8 max_age[2];\n\tu8 hello_time[2];\n\tu8 forward_delay[2];\n};\n\n#define NR16(p) (p[0] << 8 | p[1])\n#define NR32(p) ((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3])\n\nstatic bool ebt_filter_config(const struct ebt_stp_info *info,\n\t\t\t      const struct stp_config_pdu *stpc)\n{\n\tconst struct ebt_stp_config_info *c;\n\tu16 v16;\n\tu32 v32;\n\n\tc = &info->config;\n\tif ((info->bitmask & EBT_STP_FLAGS) &&\n\t    NF_INVF(info, EBT_STP_FLAGS, c->flags != stpc->flags))\n\t\treturn false;\n\tif (info->bitmask & EBT_STP_ROOTPRIO) {\n\t\tv16 = NR16(stpc->root);\n\t\tif (NF_INVF(info, EBT_STP_ROOTPRIO,\n\t\t\t    v16 < c->root_priol || v16 > c->root_priou))\n\t\t\treturn false;\n\t}\n\tif (info->bitmask & EBT_STP_ROOTADDR) {\n\t\tif (NF_INVF(info, EBT_STP_ROOTADDR,\n\t\t\t    !ether_addr_equal_masked(&stpc->root[2],\n\t\t\t\t\t\t     c->root_addr,\n\t\t\t\t\t\t     c->root_addrmsk)))\n\t\t\treturn false;\n\t}\n\tif (info->bitmask & EBT_STP_ROOTCOST) {\n\t\tv32 = NR32(stpc->root_cost);\n\t\tif (NF_INVF(info, EBT_STP_ROOTCOST,\n\t\t\t    v32 < c->root_costl || v32 > c->root_costu))\n\t\t\treturn false;\n\t}\n\tif (info->bitmask & EBT_STP_SENDERPRIO) {\n\t\tv16 = NR16(stpc->sender);\n\t\tif (NF_INVF(info, EBT_STP_SENDERPRIO,\n\t\t\t    v16 < c->sender_priol || v16 > c->sender_priou))\n\t\t\treturn false;\n\t}\n\tif (info->bitmask & EBT_STP_SENDERADDR) {\n\t\tif (NF_INVF(info, EBT_STP_SENDERADDR,\n\t\t\t    !ether_addr_equal_masked(&stpc->sender[2],\n\t\t\t\t\t\t     c->sender_addr,\n\t\t\t\t\t\t     c->sender_addrmsk)))\n\t\t\treturn false;\n\t}\n\tif (info->bitmask & EBT_STP_PORT) {\n\t\tv16 = NR16(stpc->port);\n\t\tif (NF_INVF(info, EBT_STP_PORT,\n\t\t\t    v16 < c->portl || v16 > c->portu))\n\t\t\treturn false;\n\t}\n\tif (info->bitmask & EBT_STP_MSGAGE) {\n\t\tv16 = NR16(stpc->msg_age);\n\t\tif (NF_INVF(info, EBT_STP_MSGAGE,\n\t\t\t    v16 < c->msg_agel || v16 > c->msg_ageu))\n\t\t\treturn false;\n\t}\n\tif (info->bitmask & EBT_STP_MAXAGE) {\n\t\tv16 = NR16(stpc->max_age);\n\t\tif (NF_INVF(info, EBT_STP_MAXAGE,\n\t\t\t    v16 < c->max_agel || v16 > c->max_ageu))\n\t\t\treturn false;\n\t}\n\tif (info->bitmask & EBT_STP_HELLOTIME) {\n\t\tv16 = NR16(stpc->hello_time);\n\t\tif (NF_INVF(info, EBT_STP_HELLOTIME,\n\t\t\t    v16 < c->hello_timel || v16 > c->hello_timeu))\n\t\t\treturn false;\n\t}\n\tif (info->bitmask & EBT_STP_FWDD) {\n\t\tv16 = NR16(stpc->forward_delay);\n\t\tif (NF_INVF(info, EBT_STP_FWDD,\n\t\t\t    v16 < c->forward_delayl || v16 > c->forward_delayu))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool\nebt_stp_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct ebt_stp_info *info = par->matchinfo;\n\tconst struct stp_header *sp;\n\tstruct stp_header _stph;\n\tconst u8 header[6] = {0x42, 0x42, 0x03, 0x00, 0x00, 0x00};\n\n\tsp = skb_header_pointer(skb, 0, sizeof(_stph), &_stph);\n\tif (sp == NULL)\n\t\treturn false;\n\n\t \n\tif (memcmp(sp, header, sizeof(header)))\n\t\treturn false;\n\n\tif ((info->bitmask & EBT_STP_TYPE) &&\n\t    NF_INVF(info, EBT_STP_TYPE, info->type != sp->type))\n\t\treturn false;\n\n\tif (sp->type == BPDU_TYPE_CONFIG &&\n\t    info->bitmask & EBT_STP_CONFIG_MASK) {\n\t\tconst struct stp_config_pdu *st;\n\t\tstruct stp_config_pdu _stpc;\n\n\t\tst = skb_header_pointer(skb, sizeof(_stph),\n\t\t\t\t\tsizeof(_stpc), &_stpc);\n\t\tif (st == NULL)\n\t\t\treturn false;\n\t\treturn ebt_filter_config(info, st);\n\t}\n\treturn true;\n}\n\nstatic int ebt_stp_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ebt_stp_info *info = par->matchinfo;\n\tconst struct ebt_entry *e = par->entryinfo;\n\n\tif (info->bitmask & ~EBT_STP_MASK || info->invflags & ~EBT_STP_MASK ||\n\t    !(info->bitmask & EBT_STP_MASK))\n\t\treturn -EINVAL;\n\t \n\tif (!par->nft_compat &&\n\t    (!ether_addr_equal(e->destmac, eth_stp_addr) ||\n\t     !(e->bitmask & EBT_DESTMAC) ||\n\t     !is_broadcast_ether_addr(e->destmsk)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct xt_match ebt_stp_mt_reg __read_mostly = {\n\t.name\t\t= \"stp\",\n\t.revision\t= 0,\n\t.family\t\t= NFPROTO_BRIDGE,\n\t.match\t\t= ebt_stp_mt,\n\t.checkentry\t= ebt_stp_mt_check,\n\t.matchsize\t= sizeof(struct ebt_stp_info),\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init ebt_stp_init(void)\n{\n\treturn xt_register_match(&ebt_stp_mt_reg);\n}\n\nstatic void __exit ebt_stp_fini(void)\n{\n\txt_unregister_match(&ebt_stp_mt_reg);\n}\n\nmodule_init(ebt_stp_init);\nmodule_exit(ebt_stp_fini);\nMODULE_DESCRIPTION(\"Ebtables: Spanning Tree Protocol packet match\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}