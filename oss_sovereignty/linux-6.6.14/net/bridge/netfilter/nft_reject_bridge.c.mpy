{
  "module_name": "nft_reject_bridge.c",
  "hash_id": "dc559608652e1a56ec51c0968b8c365e63b0594dcbbf07606c6f411f2eaf8949",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/netfilter/nft_reject_bridge.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nft_reject.h>\n#include <net/netfilter/ipv4/nf_reject.h>\n#include <net/netfilter/ipv6/nf_reject.h>\n#include <linux/ip.h>\n#include <net/ip.h>\n#include <net/ip6_checksum.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/netfilter_ipv6.h>\n#include \"../br_private.h\"\n\nstatic void nft_reject_br_push_etherhdr(struct sk_buff *oldskb,\n\t\t\t\t\tstruct sk_buff *nskb)\n{\n\tstruct ethhdr *eth;\n\n\teth = skb_push(nskb, ETH_HLEN);\n\tskb_reset_mac_header(nskb);\n\tether_addr_copy(eth->h_source, eth_hdr(oldskb)->h_dest);\n\tether_addr_copy(eth->h_dest, eth_hdr(oldskb)->h_source);\n\teth->h_proto = eth_hdr(oldskb)->h_proto;\n\tskb_pull(nskb, ETH_HLEN);\n\n\tif (skb_vlan_tag_present(oldskb)) {\n\t\tu16 vid = skb_vlan_tag_get(oldskb);\n\n\t\t__vlan_hwaccel_put_tag(nskb, oldskb->vlan_proto, vid);\n\t}\n}\n\n \nstatic void nft_reject_br_send_v4_tcp_reset(struct net *net,\n\t\t\t\t\t    struct sk_buff *oldskb,\n\t\t\t\t\t    const struct net_device *dev,\n\t\t\t\t\t    int hook)\n{\n\tstruct sk_buff *nskb;\n\n\tnskb = nf_reject_skb_v4_tcp_reset(net, oldskb, NULL, hook);\n\tif (!nskb)\n\t\treturn;\n\n\tnft_reject_br_push_etherhdr(oldskb, nskb);\n\n\tbr_forward(br_port_get_rcu(dev), nskb, false, true);\n}\n\nstatic void nft_reject_br_send_v4_unreach(struct net *net,\n\t\t\t\t\t  struct sk_buff *oldskb,\n\t\t\t\t\t  const struct net_device *dev,\n\t\t\t\t\t  int hook, u8 code)\n{\n\tstruct sk_buff *nskb;\n\n\tnskb = nf_reject_skb_v4_unreach(net, oldskb, NULL, hook, code);\n\tif (!nskb)\n\t\treturn;\n\n\tnft_reject_br_push_etherhdr(oldskb, nskb);\n\n\tbr_forward(br_port_get_rcu(dev), nskb, false, true);\n}\n\nstatic void nft_reject_br_send_v6_tcp_reset(struct net *net,\n\t\t\t\t\t    struct sk_buff *oldskb,\n\t\t\t\t\t    const struct net_device *dev,\n\t\t\t\t\t    int hook)\n{\n\tstruct sk_buff *nskb;\n\n\tnskb = nf_reject_skb_v6_tcp_reset(net, oldskb, NULL, hook);\n\tif (!nskb)\n\t\treturn;\n\n\tnft_reject_br_push_etherhdr(oldskb, nskb);\n\n\tbr_forward(br_port_get_rcu(dev), nskb, false, true);\n}\n\n\nstatic void nft_reject_br_send_v6_unreach(struct net *net,\n\t\t\t\t\t  struct sk_buff *oldskb,\n\t\t\t\t\t  const struct net_device *dev,\n\t\t\t\t\t  int hook, u8 code)\n{\n\tstruct sk_buff *nskb;\n\n\tnskb = nf_reject_skb_v6_unreach(net, oldskb, NULL, hook, code);\n\tif (!nskb)\n\t\treturn;\n\n\tnft_reject_br_push_etherhdr(oldskb, nskb);\n\n\tbr_forward(br_port_get_rcu(dev), nskb, false, true);\n}\n\nstatic void nft_reject_bridge_eval(const struct nft_expr *expr,\n\t\t\t\t   struct nft_regs *regs,\n\t\t\t\t   const struct nft_pktinfo *pkt)\n{\n\tstruct nft_reject *priv = nft_expr_priv(expr);\n\tconst unsigned char *dest = eth_hdr(pkt->skb)->h_dest;\n\n\tif (is_broadcast_ether_addr(dest) ||\n\t    is_multicast_ether_addr(dest))\n\t\tgoto out;\n\n\tswitch (eth_hdr(pkt->skb)->h_proto) {\n\tcase htons(ETH_P_IP):\n\t\tswitch (priv->type) {\n\t\tcase NFT_REJECT_ICMP_UNREACH:\n\t\t\tnft_reject_br_send_v4_unreach(nft_net(pkt), pkt->skb,\n\t\t\t\t\t\t      nft_in(pkt),\n\t\t\t\t\t\t      nft_hook(pkt),\n\t\t\t\t\t\t      priv->icmp_code);\n\t\t\tbreak;\n\t\tcase NFT_REJECT_TCP_RST:\n\t\t\tnft_reject_br_send_v4_tcp_reset(nft_net(pkt), pkt->skb,\n\t\t\t\t\t\t\tnft_in(pkt),\n\t\t\t\t\t\t\tnft_hook(pkt));\n\t\t\tbreak;\n\t\tcase NFT_REJECT_ICMPX_UNREACH:\n\t\t\tnft_reject_br_send_v4_unreach(nft_net(pkt), pkt->skb,\n\t\t\t\t\t\t      nft_in(pkt),\n\t\t\t\t\t\t      nft_hook(pkt),\n\t\t\t\t\t\t      nft_reject_icmp_code(priv->icmp_code));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tswitch (priv->type) {\n\t\tcase NFT_REJECT_ICMP_UNREACH:\n\t\t\tnft_reject_br_send_v6_unreach(nft_net(pkt), pkt->skb,\n\t\t\t\t\t\t      nft_in(pkt),\n\t\t\t\t\t\t      nft_hook(pkt),\n\t\t\t\t\t\t      priv->icmp_code);\n\t\t\tbreak;\n\t\tcase NFT_REJECT_TCP_RST:\n\t\t\tnft_reject_br_send_v6_tcp_reset(nft_net(pkt), pkt->skb,\n\t\t\t\t\t\t\tnft_in(pkt),\n\t\t\t\t\t\t\tnft_hook(pkt));\n\t\t\tbreak;\n\t\tcase NFT_REJECT_ICMPX_UNREACH:\n\t\t\tnft_reject_br_send_v6_unreach(nft_net(pkt), pkt->skb,\n\t\t\t\t\t\t      nft_in(pkt),\n\t\t\t\t\t\t      nft_hook(pkt),\n\t\t\t\t\t\t      nft_reject_icmpv6_code(priv->icmp_code));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\nout:\n\tregs->verdict.code = NF_DROP;\n}\n\nstatic int nft_reject_bridge_validate(const struct nft_ctx *ctx,\n\t\t\t\t      const struct nft_expr *expr,\n\t\t\t\t      const struct nft_data **data)\n{\n\treturn nft_chain_validate_hooks(ctx->chain, (1 << NF_BR_PRE_ROUTING) |\n\t\t\t\t\t\t    (1 << NF_BR_LOCAL_IN));\n}\n\nstatic struct nft_expr_type nft_reject_bridge_type;\nstatic const struct nft_expr_ops nft_reject_bridge_ops = {\n\t.type\t\t= &nft_reject_bridge_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_reject)),\n\t.eval\t\t= nft_reject_bridge_eval,\n\t.init\t\t= nft_reject_init,\n\t.dump\t\t= nft_reject_dump,\n\t.validate\t= nft_reject_bridge_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_reject_bridge_type __read_mostly = {\n\t.family\t\t= NFPROTO_BRIDGE,\n\t.name\t\t= \"reject\",\n\t.ops\t\t= &nft_reject_bridge_ops,\n\t.policy\t\t= nft_reject_policy,\n\t.maxattr\t= NFTA_REJECT_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_reject_bridge_module_init(void)\n{\n\treturn nft_register_expr(&nft_reject_bridge_type);\n}\n\nstatic void __exit nft_reject_bridge_module_exit(void)\n{\n\tnft_unregister_expr(&nft_reject_bridge_type);\n}\n\nmodule_init(nft_reject_bridge_module_init);\nmodule_exit(nft_reject_bridge_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_ALIAS_NFT_AF_EXPR(AF_BRIDGE, \"reject\");\nMODULE_DESCRIPTION(\"Reject packets from bridge via nftables\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}