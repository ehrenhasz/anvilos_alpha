{
  "module_name": "nf_conntrack_bridge.c",
  "hash_id": "af3e35dbcee774be4a232f4f67ade319ef17b924b4f70acab990bd65fbde7a04",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/netfilter/nf_conntrack_bridge.c",
  "human_readable_source": " \n#include <linux/types.h>\n#include <linux/ip.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/icmp.h>\n#include <linux/sysctl.h>\n#include <net/route.h>\n#include <net/ip.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_bridge.h>\n\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n\n#include \"../br_private.h\"\n\n \nstatic int nf_br_ip_fragment(struct net *net, struct sock *sk,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct nf_bridge_frag_data *data,\n\t\t\t     int (*output)(struct net *, struct sock *sk,\n\t\t\t\t\t   const struct nf_bridge_frag_data *data,\n\t\t\t\t\t   struct sk_buff *))\n{\n\tint frag_max_size = BR_INPUT_SKB_CB(skb)->frag_max_size;\n\tbool mono_delivery_time = skb->mono_delivery_time;\n\tunsigned int hlen, ll_rs, mtu;\n\tktime_t tstamp = skb->tstamp;\n\tstruct ip_frag_state state;\n\tstruct iphdr *iph;\n\tint err = 0;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    (err = skb_checksum_help(skb)))\n\t\tgoto blackhole;\n\n\tiph = ip_hdr(skb);\n\n\t \n\n\thlen = iph->ihl * 4;\n\tfrag_max_size -= hlen;\n\tll_rs = LL_RESERVED_SPACE(skb->dev);\n\tmtu = skb->dev->mtu;\n\n\tif (skb_has_frag_list(skb)) {\n\t\tunsigned int first_len = skb_pagelen(skb);\n\t\tstruct ip_fraglist_iter iter;\n\t\tstruct sk_buff *frag;\n\n\t\tif (first_len - hlen > mtu ||\n\t\t    skb_headroom(skb) < ll_rs)\n\t\t\tgoto blackhole;\n\n\t\tif (skb_cloned(skb))\n\t\t\tgoto slow_path;\n\n\t\tskb_walk_frags(skb, frag) {\n\t\t\tif (frag->len > mtu ||\n\t\t\t    skb_headroom(frag) < hlen + ll_rs)\n\t\t\t\tgoto blackhole;\n\n\t\t\tif (skb_shared(frag))\n\t\t\t\tgoto slow_path;\n\t\t}\n\n\t\tip_fraglist_init(skb, iph, hlen, &iter);\n\n\t\tfor (;;) {\n\t\t\tif (iter.frag)\n\t\t\t\tip_fraglist_prepare(skb, &iter);\n\n\t\t\tskb_set_delivery_time(skb, tstamp, mono_delivery_time);\n\t\t\terr = output(net, sk, data, skb);\n\t\t\tif (err || !iter.frag)\n\t\t\t\tbreak;\n\n\t\t\tskb = ip_fraglist_next(&iter);\n\t\t}\n\n\t\tif (!err)\n\t\t\treturn 0;\n\n\t\tkfree_skb_list(iter.frag);\n\n\t\treturn err;\n\t}\nslow_path:\n\t \n\tip_frag_init(skb, hlen, ll_rs, frag_max_size, false, &state);\n\n\twhile (state.left > 0) {\n\t\tstruct sk_buff *skb2;\n\n\t\tskb2 = ip_frag_next(skb, &state);\n\t\tif (IS_ERR(skb2)) {\n\t\t\terr = PTR_ERR(skb2);\n\t\t\tgoto blackhole;\n\t\t}\n\n\t\tskb_set_delivery_time(skb2, tstamp, mono_delivery_time);\n\t\terr = output(net, sk, data, skb2);\n\t\tif (err)\n\t\t\tgoto blackhole;\n\t}\n\tconsume_skb(skb);\n\treturn err;\n\nblackhole:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \nstatic void br_skb_cb_save(struct sk_buff *skb, struct br_input_skb_cb *cb,\n\t\t\t   size_t inet_skb_parm_size)\n{\n\tmemcpy(cb, skb->cb, sizeof(*cb));\n\tmemset(skb->cb, 0, inet_skb_parm_size);\n}\n\nstatic void br_skb_cb_restore(struct sk_buff *skb,\n\t\t\t      const struct br_input_skb_cb *cb,\n\t\t\t      u16 fragsz)\n{\n\tmemcpy(skb->cb, cb, sizeof(*cb));\n\tBR_INPUT_SKB_CB(skb)->frag_max_size = fragsz;\n}\n\nstatic unsigned int nf_ct_br_defrag4(struct sk_buff *skb,\n\t\t\t\t     const struct nf_hook_state *state)\n{\n\tu16 zone_id = NF_CT_DEFAULT_ZONE_ID;\n\tenum ip_conntrack_info ctinfo;\n\tstruct br_input_skb_cb cb;\n\tconst struct nf_conn *ct;\n\tint err;\n\n\tif (!ip_is_fragment(ip_hdr(skb)))\n\t\treturn NF_ACCEPT;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct)\n\t\tzone_id = nf_ct_zone_id(nf_ct_zone(ct), CTINFO2DIR(ctinfo));\n\n\tbr_skb_cb_save(skb, &cb, sizeof(struct inet_skb_parm));\n\tlocal_bh_disable();\n\terr = ip_defrag(state->net, skb,\n\t\t\tIP_DEFRAG_CONNTRACK_BRIDGE_IN + zone_id);\n\tlocal_bh_enable();\n\tif (!err) {\n\t\tbr_skb_cb_restore(skb, &cb, IPCB(skb)->frag_max_size);\n\t\tskb->ignore_df = 1;\n\t\treturn NF_ACCEPT;\n\t}\n\n\treturn NF_STOLEN;\n}\n\nstatic unsigned int nf_ct_br_defrag6(struct sk_buff *skb,\n\t\t\t\t     const struct nf_hook_state *state)\n{\n#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV6)\n\tu16 zone_id = NF_CT_DEFAULT_ZONE_ID;\n\tenum ip_conntrack_info ctinfo;\n\tstruct br_input_skb_cb cb;\n\tconst struct nf_conn *ct;\n\tint err;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct)\n\t\tzone_id = nf_ct_zone_id(nf_ct_zone(ct), CTINFO2DIR(ctinfo));\n\n\tbr_skb_cb_save(skb, &cb, sizeof(struct inet6_skb_parm));\n\n\terr = nf_ct_frag6_gather(state->net, skb,\n\t\t\t\t IP_DEFRAG_CONNTRACK_BRIDGE_IN + zone_id);\n\t \n\tif (err == -EINPROGRESS)\n\t\treturn NF_STOLEN;\n\n\tbr_skb_cb_restore(skb, &cb, IP6CB(skb)->frag_max_size);\n\treturn err == 0 ? NF_ACCEPT : NF_DROP;\n#else\n\treturn NF_ACCEPT;\n#endif\n}\n\nstatic int nf_ct_br_ip_check(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph;\n\tint nhoff, len;\n\n\tnhoff = skb_network_offset(skb);\n\tiph = ip_hdr(skb);\n\tif (iph->ihl < 5 ||\n\t    iph->version != 4)\n\t\treturn -1;\n\n\tlen = skb_ip_totlen(skb);\n\tif (skb->len < nhoff + len ||\n\t    len < (iph->ihl * 4))\n                return -1;\n\n\treturn 0;\n}\n\nstatic int nf_ct_br_ipv6_check(const struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *hdr;\n\tint nhoff, len;\n\n\tnhoff = skb_network_offset(skb);\n\thdr = ipv6_hdr(skb);\n\tif (hdr->version != 6)\n\t\treturn -1;\n\n\tlen = ntohs(hdr->payload_len) + sizeof(struct ipv6hdr) + nhoff;\n\tif (skb->len < len)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic unsigned int nf_ct_bridge_pre(void *priv, struct sk_buff *skb,\n\t\t\t\t     const struct nf_hook_state *state)\n{\n\tstruct nf_hook_state bridge_state = *state;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\tu32 len;\n\tint ret;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif ((ct && !nf_ct_is_template(ct)) ||\n\t    ctinfo == IP_CT_UNTRACKED)\n\t\treturn NF_ACCEPT;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\t\treturn NF_ACCEPT;\n\n\t\tlen = skb_ip_totlen(skb);\n\t\tif (pskb_trim_rcsum(skb, len))\n\t\t\treturn NF_ACCEPT;\n\n\t\tif (nf_ct_br_ip_check(skb))\n\t\t\treturn NF_ACCEPT;\n\n\t\tbridge_state.pf = NFPROTO_IPV4;\n\t\tret = nf_ct_br_defrag4(skb, &bridge_state);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\t\treturn NF_ACCEPT;\n\n\t\tlen = sizeof(struct ipv6hdr) + ntohs(ipv6_hdr(skb)->payload_len);\n\t\tif (pskb_trim_rcsum(skb, len))\n\t\t\treturn NF_ACCEPT;\n\n\t\tif (nf_ct_br_ipv6_check(skb))\n\t\t\treturn NF_ACCEPT;\n\n\t\tbridge_state.pf = NFPROTO_IPV6;\n\t\tret = nf_ct_br_defrag6(skb, &bridge_state);\n\t\tbreak;\n\tdefault:\n\t\tnf_ct_set(skb, NULL, IP_CT_UNTRACKED);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tif (ret != NF_ACCEPT)\n\t\treturn ret;\n\n\treturn nf_conntrack_in(skb, &bridge_state);\n}\n\nstatic void nf_ct_bridge_frag_save(struct sk_buff *skb,\n\t\t\t\t   struct nf_bridge_frag_data *data)\n{\n\tif (skb_vlan_tag_present(skb)) {\n\t\tdata->vlan_present = true;\n\t\tdata->vlan_tci = skb->vlan_tci;\n\t\tdata->vlan_proto = skb->vlan_proto;\n\t} else {\n\t\tdata->vlan_present = false;\n\t}\n\tskb_copy_from_linear_data_offset(skb, -ETH_HLEN, data->mac, ETH_HLEN);\n}\n\nstatic unsigned int\nnf_ct_bridge_refrag(struct sk_buff *skb, const struct nf_hook_state *state,\n\t\t    int (*output)(struct net *, struct sock *sk,\n\t\t\t\t  const struct nf_bridge_frag_data *data,\n\t\t\t\t  struct sk_buff *))\n{\n\tstruct nf_bridge_frag_data data;\n\n\tif (!BR_INPUT_SKB_CB(skb)->frag_max_size)\n\t\treturn NF_ACCEPT;\n\n\tnf_ct_bridge_frag_save(skb, &data);\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tnf_br_ip_fragment(state->net, state->sk, skb, &data, output);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tnf_br_ip6_fragment(state->net, state->sk, skb, &data, output);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn NF_DROP;\n\t}\n\n\treturn NF_STOLEN;\n}\n\n \nstatic int nf_ct_bridge_frag_restore(struct sk_buff *skb,\n\t\t\t\t     const struct nf_bridge_frag_data *data)\n{\n\tint err;\n\n\terr = skb_cow_head(skb, ETH_HLEN);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\tif (data->vlan_present)\n\t\t__vlan_hwaccel_put_tag(skb, data->vlan_proto, data->vlan_tci);\n\telse if (skb_vlan_tag_present(skb))\n\t\t__vlan_hwaccel_clear_tag(skb);\n\n\tskb_copy_to_linear_data_offset(skb, -ETH_HLEN, data->mac, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\n\treturn 0;\n}\n\nstatic int nf_ct_bridge_refrag_post(struct net *net, struct sock *sk,\n\t\t\t\t    const struct nf_bridge_frag_data *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tint err;\n\n\terr = nf_ct_bridge_frag_restore(skb, data);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn br_dev_queue_push_xmit(net, sk, skb);\n}\n\nstatic unsigned int nf_ct_bridge_post(void *priv, struct sk_buff *skb,\n\t\t\t\t      const struct nf_hook_state *state)\n{\n\tint ret;\n\n\tret = nf_confirm(priv, skb, state);\n\tif (ret != NF_ACCEPT)\n\t\treturn ret;\n\n\treturn nf_ct_bridge_refrag(skb, state, nf_ct_bridge_refrag_post);\n}\n\nstatic struct nf_hook_ops nf_ct_bridge_hook_ops[] __read_mostly = {\n\t{\n\t\t.hook\t\t= nf_ct_bridge_pre,\n\t\t.pf\t\t= NFPROTO_BRIDGE,\n\t\t.hooknum\t= NF_BR_PRE_ROUTING,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK,\n\t},\n\t{\n\t\t.hook\t\t= nf_ct_bridge_post,\n\t\t.pf\t\t= NFPROTO_BRIDGE,\n\t\t.hooknum\t= NF_BR_POST_ROUTING,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK_CONFIRM,\n\t},\n};\n\nstatic struct nf_ct_bridge_info bridge_info = {\n\t.ops\t\t= nf_ct_bridge_hook_ops,\n\t.ops_size\t= ARRAY_SIZE(nf_ct_bridge_hook_ops),\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init nf_conntrack_l3proto_bridge_init(void)\n{\n\tnf_ct_bridge_register(&bridge_info);\n\n\treturn 0;\n}\n\nstatic void __exit nf_conntrack_l3proto_bridge_fini(void)\n{\n\tnf_ct_bridge_unregister(&bridge_info);\n}\n\nmodule_init(nf_conntrack_l3proto_bridge_init);\nmodule_exit(nf_conntrack_l3proto_bridge_fini);\n\nMODULE_ALIAS(\"nf_conntrack-\" __stringify(AF_BRIDGE));\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}