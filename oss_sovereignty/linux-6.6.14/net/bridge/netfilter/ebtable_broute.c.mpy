{
  "module_name": "ebtable_broute.c",
  "hash_id": "9eb0444f13eab76b30e70e1459ae6771f2fb7ee056ec56b0d096ef2580df3d86",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/netfilter/ebtable_broute.c",
  "human_readable_source": "\n \n\n#include <linux/netfilter_bridge/ebtables.h>\n#include <linux/module.h>\n#include <linux/if_bridge.h>\n\n#include \"../br_private.h\"\n\n \nstatic struct ebt_entries initial_chain = {\n\t.name\t\t= \"BROUTING\",\n\t.policy\t\t= EBT_ACCEPT,\n};\n\nstatic struct ebt_replace_kernel initial_table = {\n\t.name\t\t= \"broute\",\n\t.valid_hooks\t= 1 << NF_BR_BROUTING,\n\t.entries_size\t= sizeof(struct ebt_entries),\n\t.hook_entry\t= {\n\t\t[NF_BR_BROUTING]\t= &initial_chain,\n\t},\n\t.entries\t= (char *)&initial_chain,\n};\n\nstatic const struct ebt_table broute_table = {\n\t.name\t\t= \"broute\",\n\t.table\t\t= &initial_table,\n\t.valid_hooks\t= 1 << NF_BR_BROUTING,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic unsigned int ebt_broute(void *priv, struct sk_buff *skb,\n\t\t\t       const struct nf_hook_state *s)\n{\n\tstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\n\tstruct nf_hook_state state;\n\tunsigned char *dest;\n\tint ret;\n\n\tif (!p || p->state != BR_STATE_FORWARDING)\n\t\treturn NF_ACCEPT;\n\n\tnf_hook_state_init(&state, NF_BR_BROUTING,\n\t\t\t   NFPROTO_BRIDGE, s->in, NULL, NULL,\n\t\t\t   s->net, NULL);\n\n\tret = ebt_do_table(priv, skb, &state);\n\tif (ret != NF_DROP)\n\t\treturn ret;\n\n\t \n\tBR_INPUT_SKB_CB(skb)->br_netfilter_broute = 1;\n\n\t \n\tdest = eth_hdr(skb)->h_dest;\n\tif (skb->pkt_type == PACKET_HOST &&\n\t    !ether_addr_equal(skb->dev->dev_addr, dest) &&\n\t     ether_addr_equal(p->br->dev->dev_addr, dest))\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\n\treturn NF_ACCEPT;\n}\n\nstatic const struct nf_hook_ops ebt_ops_broute = {\n\t.hook\t\t= ebt_broute,\n\t.pf\t\t= NFPROTO_BRIDGE,\n\t.hooknum\t= NF_BR_PRE_ROUTING,\n\t.priority\t= NF_BR_PRI_FIRST,\n};\n\nstatic int broute_table_init(struct net *net)\n{\n\treturn ebt_register_table(net, &broute_table, &ebt_ops_broute);\n}\n\nstatic void __net_exit broute_net_pre_exit(struct net *net)\n{\n\tebt_unregister_table_pre_exit(net, \"broute\");\n}\n\nstatic void __net_exit broute_net_exit(struct net *net)\n{\n\tebt_unregister_table(net, \"broute\");\n}\n\nstatic struct pernet_operations broute_net_ops = {\n\t.exit = broute_net_exit,\n\t.pre_exit = broute_net_pre_exit,\n};\n\nstatic int __init ebtable_broute_init(void)\n{\n\tint ret = ebt_register_template(&broute_table, broute_table_init);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_pernet_subsys(&broute_net_ops);\n\tif (ret) {\n\t\tebt_unregister_template(&broute_table);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit ebtable_broute_fini(void)\n{\n\tunregister_pernet_subsys(&broute_net_ops);\n\tebt_unregister_template(&broute_table);\n}\n\nmodule_init(ebtable_broute_init);\nmodule_exit(ebtable_broute_fini);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}