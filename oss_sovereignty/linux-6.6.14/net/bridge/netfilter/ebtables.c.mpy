{
  "module_name": "ebtables.c",
  "hash_id": "a598f926625ea4d97f184bbfedf1d5c989257e9963ca5269fefccbb5802d91ad",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/netfilter/ebtables.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/kmod.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_bridge/ebtables.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/smp.h>\n#include <linux/cpumask.h>\n#include <linux/audit.h>\n#include <net/sock.h>\n#include <net/netns/generic.h>\n \n#include \"../br_private.h\"\n\n \n\n \n#define SMP_ALIGN(x) (((x) + SMP_CACHE_BYTES-1) & ~(SMP_CACHE_BYTES-1))\n#define COUNTER_OFFSET(n) (SMP_ALIGN(n * sizeof(struct ebt_counter)))\n#define COUNTER_BASE(c, n, cpu) ((struct ebt_counter *)(((char *)c) + \\\n\t\t\t\t COUNTER_OFFSET(n) * cpu))\n\nstruct ebt_pernet {\n\tstruct list_head tables;\n};\n\nstruct ebt_template {\n\tstruct list_head list;\n\tchar name[EBT_TABLE_MAXNAMELEN];\n\tstruct module *owner;\n\t \n\tint (*table_init)(struct net *net);\n};\n\nstatic unsigned int ebt_pernet_id __read_mostly;\nstatic LIST_HEAD(template_tables);\nstatic DEFINE_MUTEX(ebt_mutex);\n\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\nstatic void ebt_standard_compat_from_user(void *dst, const void *src)\n{\n\tint v = *(compat_int_t *)src;\n\n\tif (v >= 0)\n\t\tv += xt_compat_calc_jump(NFPROTO_BRIDGE, v);\n\tmemcpy(dst, &v, sizeof(v));\n}\n\nstatic int ebt_standard_compat_to_user(void __user *dst, const void *src)\n{\n\tcompat_int_t cv = *(int *)src;\n\n\tif (cv >= 0)\n\t\tcv -= xt_compat_calc_jump(NFPROTO_BRIDGE, cv);\n\treturn copy_to_user(dst, &cv, sizeof(cv)) ? -EFAULT : 0;\n}\n#endif\n\n\nstatic struct xt_target ebt_standard_target = {\n\t.name       = \"standard\",\n\t.revision   = 0,\n\t.family     = NFPROTO_BRIDGE,\n\t.targetsize = sizeof(int),\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t.compatsize = sizeof(compat_int_t),\n\t.compat_from_user = ebt_standard_compat_from_user,\n\t.compat_to_user =  ebt_standard_compat_to_user,\n#endif\n};\n\nstatic inline int\nebt_do_watcher(const struct ebt_entry_watcher *w, struct sk_buff *skb,\n\t       struct xt_action_param *par)\n{\n\tpar->target   = w->u.watcher;\n\tpar->targinfo = w->data;\n\tw->u.watcher->target(skb, par);\n\t \n\treturn 0;\n}\n\nstatic inline int\nebt_do_match(struct ebt_entry_match *m, const struct sk_buff *skb,\n\t     struct xt_action_param *par)\n{\n\tpar->match     = m->u.match;\n\tpar->matchinfo = m->data;\n\treturn !m->u.match->match(skb, par);\n}\n\nstatic inline int\nebt_dev_check(const char *entry, const struct net_device *device)\n{\n\tint i = 0;\n\tconst char *devname;\n\n\tif (*entry == '\\0')\n\t\treturn 0;\n\tif (!device)\n\t\treturn 1;\n\tdevname = device->name;\n\t \n\twhile (entry[i] != '\\0' && entry[i] != 1 && entry[i] == devname[i])\n\t\ti++;\n\treturn devname[i] != entry[i] && entry[i] != 1;\n}\n\n \nstatic inline int\nebt_basic_match(const struct ebt_entry *e, const struct sk_buff *skb,\n\t\tconst struct net_device *in, const struct net_device *out)\n{\n\tconst struct ethhdr *h = eth_hdr(skb);\n\tconst struct net_bridge_port *p;\n\t__be16 ethproto;\n\n\tif (skb_vlan_tag_present(skb))\n\t\tethproto = htons(ETH_P_8021Q);\n\telse\n\t\tethproto = h->h_proto;\n\n\tif (e->bitmask & EBT_802_3) {\n\t\tif (NF_INVF(e, EBT_IPROTO, eth_proto_is_802_3(ethproto)))\n\t\t\treturn 1;\n\t} else if (!(e->bitmask & EBT_NOPROTO) &&\n\t\t   NF_INVF(e, EBT_IPROTO, e->ethproto != ethproto))\n\t\treturn 1;\n\n\tif (NF_INVF(e, EBT_IIN, ebt_dev_check(e->in, in)))\n\t\treturn 1;\n\tif (NF_INVF(e, EBT_IOUT, ebt_dev_check(e->out, out)))\n\t\treturn 1;\n\t \n\tif (in && (p = br_port_get_rcu(in)) != NULL &&\n\t    NF_INVF(e, EBT_ILOGICALIN,\n\t\t    ebt_dev_check(e->logical_in, p->br->dev)))\n\t\treturn 1;\n\tif (out && (p = br_port_get_rcu(out)) != NULL &&\n\t    NF_INVF(e, EBT_ILOGICALOUT,\n\t\t    ebt_dev_check(e->logical_out, p->br->dev)))\n\t\treturn 1;\n\n\tif (e->bitmask & EBT_SOURCEMAC) {\n\t\tif (NF_INVF(e, EBT_ISOURCE,\n\t\t\t    !ether_addr_equal_masked(h->h_source, e->sourcemac,\n\t\t\t\t\t\t     e->sourcemsk)))\n\t\t\treturn 1;\n\t}\n\tif (e->bitmask & EBT_DESTMAC) {\n\t\tif (NF_INVF(e, EBT_IDEST,\n\t\t\t    !ether_addr_equal_masked(h->h_dest, e->destmac,\n\t\t\t\t\t\t     e->destmsk)))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline\nstruct ebt_entry *ebt_next_entry(const struct ebt_entry *entry)\n{\n\treturn (void *)entry + entry->next_offset;\n}\n\nstatic inline const struct ebt_entry_target *\nebt_get_target_c(const struct ebt_entry *e)\n{\n\treturn ebt_get_target((struct ebt_entry *)e);\n}\n\n \nunsigned int ebt_do_table(void *priv, struct sk_buff *skb,\n\t\t\t  const struct nf_hook_state *state)\n{\n\tstruct ebt_table *table = priv;\n\tunsigned int hook = state->hook;\n\tint i, nentries;\n\tstruct ebt_entry *point;\n\tstruct ebt_counter *counter_base, *cb_base;\n\tconst struct ebt_entry_target *t;\n\tint verdict, sp = 0;\n\tstruct ebt_chainstack *cs;\n\tstruct ebt_entries *chaininfo;\n\tconst char *base;\n\tconst struct ebt_table_info *private;\n\tstruct xt_action_param acpar;\n\n\tacpar.state   = state;\n\tacpar.hotdrop = false;\n\n\tread_lock_bh(&table->lock);\n\tprivate = table->private;\n\tcb_base = COUNTER_BASE(private->counters, private->nentries,\n\t   smp_processor_id());\n\tif (private->chainstack)\n\t\tcs = private->chainstack[smp_processor_id()];\n\telse\n\t\tcs = NULL;\n\tchaininfo = private->hook_entry[hook];\n\tnentries = private->hook_entry[hook]->nentries;\n\tpoint = (struct ebt_entry *)(private->hook_entry[hook]->data);\n\tcounter_base = cb_base + private->hook_entry[hook]->counter_offset;\n\t \n\tbase = private->entries;\n\ti = 0;\n\twhile (i < nentries) {\n\t\tif (ebt_basic_match(point, skb, state->in, state->out))\n\t\t\tgoto letscontinue;\n\n\t\tif (EBT_MATCH_ITERATE(point, ebt_do_match, skb, &acpar) != 0)\n\t\t\tgoto letscontinue;\n\t\tif (acpar.hotdrop) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\tADD_COUNTER(*(counter_base + i), skb->len, 1);\n\n\t\t \n\t\tEBT_WATCHER_ITERATE(point, ebt_do_watcher, skb, &acpar);\n\n\t\tt = ebt_get_target_c(point);\n\t\t \n\t\tif (!t->u.target->target)\n\t\t\tverdict = ((struct ebt_standard_target *)t)->verdict;\n\t\telse {\n\t\t\tacpar.target   = t->u.target;\n\t\t\tacpar.targinfo = t->data;\n\t\t\tverdict = t->u.target->target(skb, &acpar);\n\t\t}\n\t\tif (verdict == EBT_ACCEPT) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_ACCEPT;\n\t\t}\n\t\tif (verdict == EBT_DROP) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\t\tif (verdict == EBT_RETURN) {\nletsreturn:\n\t\t\tif (WARN(sp == 0, \"RETURN on base chain\")) {\n\t\t\t\t \n\t\t\t\tgoto letscontinue;\n\t\t\t}\n\n\t\t\tsp--;\n\t\t\t \n\t\t\ti = cs[sp].n;\n\t\t\tchaininfo = cs[sp].chaininfo;\n\t\t\tnentries = chaininfo->nentries;\n\t\t\tpoint = cs[sp].e;\n\t\t\tcounter_base = cb_base +\n\t\t\t   chaininfo->counter_offset;\n\t\t\tcontinue;\n\t\t}\n\t\tif (verdict == EBT_CONTINUE)\n\t\t\tgoto letscontinue;\n\n\t\tif (WARN(verdict < 0, \"bogus standard verdict\\n\")) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\t \n\t\tcs[sp].n = i + 1;\n\t\tcs[sp].chaininfo = chaininfo;\n\t\tcs[sp].e = ebt_next_entry(point);\n\t\ti = 0;\n\t\tchaininfo = (struct ebt_entries *) (base + verdict);\n\n\t\tif (WARN(chaininfo->distinguisher, \"jump to non-chain\\n\")) {\n\t\t\tread_unlock_bh(&table->lock);\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\tnentries = chaininfo->nentries;\n\t\tpoint = (struct ebt_entry *)chaininfo->data;\n\t\tcounter_base = cb_base + chaininfo->counter_offset;\n\t\tsp++;\n\t\tcontinue;\nletscontinue:\n\t\tpoint = ebt_next_entry(point);\n\t\ti++;\n\t}\n\n\t \n\tif (chaininfo->policy == EBT_RETURN)\n\t\tgoto letsreturn;\n\tif (chaininfo->policy == EBT_ACCEPT) {\n\t\tread_unlock_bh(&table->lock);\n\t\treturn NF_ACCEPT;\n\t}\n\tread_unlock_bh(&table->lock);\n\treturn NF_DROP;\n}\n\n \nstatic inline void *\nfind_inlist_lock_noload(struct net *net, const char *name, int *error,\n\t\t\tstruct mutex *mutex)\n{\n\tstruct ebt_pernet *ebt_net = net_generic(net, ebt_pernet_id);\n\tstruct ebt_template *tmpl;\n\tstruct ebt_table *table;\n\n\tmutex_lock(mutex);\n\tlist_for_each_entry(table, &ebt_net->tables, list) {\n\t\tif (strcmp(table->name, name) == 0)\n\t\t\treturn table;\n\t}\n\n\tlist_for_each_entry(tmpl, &template_tables, list) {\n\t\tif (strcmp(name, tmpl->name) == 0) {\n\t\t\tstruct module *owner = tmpl->owner;\n\n\t\t\tif (!try_module_get(owner))\n\t\t\t\tgoto out;\n\n\t\t\tmutex_unlock(mutex);\n\n\t\t\t*error = tmpl->table_init(net);\n\t\t\tif (*error) {\n\t\t\t\tmodule_put(owner);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tmutex_lock(mutex);\n\t\t\tmodule_put(owner);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(table, &ebt_net->tables, list) {\n\t\tif (strcmp(table->name, name) == 0)\n\t\t\treturn table;\n\t}\n\nout:\n\t*error = -ENOENT;\n\tmutex_unlock(mutex);\n\treturn NULL;\n}\n\nstatic void *\nfind_inlist_lock(struct net *net, const char *name, const char *prefix,\n\t\t int *error, struct mutex *mutex)\n{\n\treturn try_then_request_module(\n\t\t\tfind_inlist_lock_noload(net, name, error, mutex),\n\t\t\t\"%s%s\", prefix, name);\n}\n\nstatic inline struct ebt_table *\nfind_table_lock(struct net *net, const char *name, int *error,\n\t\tstruct mutex *mutex)\n{\n\treturn find_inlist_lock(net, name, \"ebtable_\", error, mutex);\n}\n\nstatic inline void ebt_free_table_info(struct ebt_table_info *info)\n{\n\tint i;\n\n\tif (info->chainstack) {\n\t\tfor_each_possible_cpu(i)\n\t\t\tvfree(info->chainstack[i]);\n\t\tvfree(info->chainstack);\n\t}\n}\nstatic inline int\nebt_check_match(struct ebt_entry_match *m, struct xt_mtchk_param *par,\n\t\tunsigned int *cnt)\n{\n\tconst struct ebt_entry *e = par->entryinfo;\n\tstruct xt_match *match;\n\tsize_t left = ((char *)e + e->watchers_offset) - (char *)m;\n\tint ret;\n\n\tif (left < sizeof(struct ebt_entry_match) ||\n\t    left - sizeof(struct ebt_entry_match) < m->match_size)\n\t\treturn -EINVAL;\n\n\tmatch = xt_find_match(NFPROTO_BRIDGE, m->u.name, m->u.revision);\n\tif (IS_ERR(match) || match->family != NFPROTO_BRIDGE) {\n\t\tif (!IS_ERR(match))\n\t\t\tmodule_put(match->me);\n\t\trequest_module(\"ebt_%s\", m->u.name);\n\t\tmatch = xt_find_match(NFPROTO_BRIDGE, m->u.name, m->u.revision);\n\t}\n\tif (IS_ERR(match))\n\t\treturn PTR_ERR(match);\n\tm->u.match = match;\n\n\tpar->match     = match;\n\tpar->matchinfo = m->data;\n\tret = xt_check_match(par, m->match_size,\n\t      ntohs(e->ethproto), e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(match->me);\n\t\treturn ret;\n\t}\n\n\t(*cnt)++;\n\treturn 0;\n}\n\nstatic inline int\nebt_check_watcher(struct ebt_entry_watcher *w, struct xt_tgchk_param *par,\n\t\t  unsigned int *cnt)\n{\n\tconst struct ebt_entry *e = par->entryinfo;\n\tstruct xt_target *watcher;\n\tsize_t left = ((char *)e + e->target_offset) - (char *)w;\n\tint ret;\n\n\tif (left < sizeof(struct ebt_entry_watcher) ||\n\t   left - sizeof(struct ebt_entry_watcher) < w->watcher_size)\n\t\treturn -EINVAL;\n\n\twatcher = xt_request_find_target(NFPROTO_BRIDGE, w->u.name, 0);\n\tif (IS_ERR(watcher))\n\t\treturn PTR_ERR(watcher);\n\n\tif (watcher->family != NFPROTO_BRIDGE) {\n\t\tmodule_put(watcher->me);\n\t\treturn -ENOENT;\n\t}\n\n\tw->u.watcher = watcher;\n\n\tpar->target   = watcher;\n\tpar->targinfo = w->data;\n\tret = xt_check_target(par, w->watcher_size,\n\t      ntohs(e->ethproto), e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(watcher->me);\n\t\treturn ret;\n\t}\n\n\t(*cnt)++;\n\treturn 0;\n}\n\nstatic int ebt_verify_pointers(const struct ebt_replace *repl,\n\t\t\t       struct ebt_table_info *newinfo)\n{\n\tunsigned int limit = repl->entries_size;\n\tunsigned int valid_hooks = repl->valid_hooks;\n\tunsigned int offset = 0;\n\tint i;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++)\n\t\tnewinfo->hook_entry[i] = NULL;\n\n\tnewinfo->entries_size = repl->entries_size;\n\tnewinfo->nentries = repl->nentries;\n\n\twhile (offset < limit) {\n\t\tsize_t left = limit - offset;\n\t\tstruct ebt_entry *e = (void *)newinfo->entries + offset;\n\n\t\tif (left < sizeof(unsigned int))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\t\tif ((valid_hooks & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((char __user *)repl->hook_entry[i] ==\n\t\t\t     repl->entries + offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i != NF_BR_NUMHOOKS || !(e->bitmask & EBT_ENTRY_OR_ENTRIES)) {\n\t\t\tif (e->bitmask != 0) {\n\t\t\t\t \n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (i != NF_BR_NUMHOOKS)\n\t\t\t\tnewinfo->hook_entry[i] = (struct ebt_entries *)e;\n\t\t\tif (left < sizeof(struct ebt_entries))\n\t\t\t\tbreak;\n\t\t\toffset += sizeof(struct ebt_entries);\n\t\t} else {\n\t\t\tif (left < sizeof(struct ebt_entry))\n\t\t\t\tbreak;\n\t\t\tif (left < e->next_offset)\n\t\t\t\tbreak;\n\t\t\tif (e->next_offset < sizeof(struct ebt_entry))\n\t\t\t\treturn -EINVAL;\n\t\t\toffset += e->next_offset;\n\t\t}\n\t}\n\tif (offset != limit)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (!newinfo->hook_entry[i] &&\n\t\t   (valid_hooks & (1 << i)))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic inline int\nebt_check_entry_size_and_hooks(const struct ebt_entry *e,\n\t\t\t       const struct ebt_table_info *newinfo,\n\t\t\t       unsigned int *n, unsigned int *cnt,\n\t\t\t       unsigned int *totalcnt, unsigned int *udc_cnt)\n{\n\tint i;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif ((void *)e == (void *)newinfo->hook_entry[i])\n\t\t\tbreak;\n\t}\n\t \n\tif (i != NF_BR_NUMHOOKS || !e->bitmask) {\n\t\t \n\t\tif (*n != *cnt)\n\t\t\treturn -EINVAL;\n\n\t\tif (((struct ebt_entries *)e)->policy != EBT_DROP &&\n\t\t   ((struct ebt_entries *)e)->policy != EBT_ACCEPT) {\n\t\t\t \n\t\t\tif (i != NF_BR_NUMHOOKS ||\n\t\t\t   ((struct ebt_entries *)e)->policy != EBT_RETURN)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (i == NF_BR_NUMHOOKS)  \n\t\t\t(*udc_cnt)++;\n\t\tif (((struct ebt_entries *)e)->counter_offset != *totalcnt)\n\t\t\treturn -EINVAL;\n\t\t*n = ((struct ebt_entries *)e)->nentries;\n\t\t*cnt = 0;\n\t\treturn 0;\n\t}\n\t \n\tif (sizeof(struct ebt_entry) > e->watchers_offset ||\n\t   e->watchers_offset > e->target_offset ||\n\t   e->target_offset >= e->next_offset)\n\t\treturn -EINVAL;\n\n\t \n\tif (e->next_offset - e->target_offset < sizeof(struct ebt_entry_target))\n\t\treturn -EINVAL;\n\n\t(*cnt)++;\n\t(*totalcnt)++;\n\treturn 0;\n}\n\nstruct ebt_cl_stack {\n\tstruct ebt_chainstack cs;\n\tint from;\n\tunsigned int hookmask;\n};\n\n \nstatic inline int\nebt_get_udc_positions(struct ebt_entry *e, struct ebt_table_info *newinfo,\n\t\t      unsigned int *n, struct ebt_cl_stack *udc)\n{\n\tint i;\n\n\t \n\tif (e->bitmask)\n\t\treturn 0;\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (newinfo->hook_entry[i] == (struct ebt_entries *)e)\n\t\t\tbreak;\n\t}\n\t \n\tif (i != NF_BR_NUMHOOKS)\n\t\treturn 0;\n\n\tudc[*n].cs.chaininfo = (struct ebt_entries *)e;\n\t \n\tudc[*n].cs.n = 0;\n\tudc[*n].hookmask = 0;\n\n\t(*n)++;\n\treturn 0;\n}\n\nstatic inline int\nebt_cleanup_match(struct ebt_entry_match *m, struct net *net, unsigned int *i)\n{\n\tstruct xt_mtdtor_param par;\n\n\tif (i && (*i)-- == 0)\n\t\treturn 1;\n\n\tpar.net       = net;\n\tpar.match     = m->u.match;\n\tpar.matchinfo = m->data;\n\tpar.family    = NFPROTO_BRIDGE;\n\tif (par.match->destroy != NULL)\n\t\tpar.match->destroy(&par);\n\tmodule_put(par.match->me);\n\treturn 0;\n}\n\nstatic inline int\nebt_cleanup_watcher(struct ebt_entry_watcher *w, struct net *net, unsigned int *i)\n{\n\tstruct xt_tgdtor_param par;\n\n\tif (i && (*i)-- == 0)\n\t\treturn 1;\n\n\tpar.net      = net;\n\tpar.target   = w->u.watcher;\n\tpar.targinfo = w->data;\n\tpar.family   = NFPROTO_BRIDGE;\n\tif (par.target->destroy != NULL)\n\t\tpar.target->destroy(&par);\n\tmodule_put(par.target->me);\n\treturn 0;\n}\n\nstatic inline int\nebt_cleanup_entry(struct ebt_entry *e, struct net *net, unsigned int *cnt)\n{\n\tstruct xt_tgdtor_param par;\n\tstruct ebt_entry_target *t;\n\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\t \n\tif (cnt && (*cnt)-- == 0)\n\t\treturn 1;\n\tEBT_WATCHER_ITERATE(e, ebt_cleanup_watcher, net, NULL);\n\tEBT_MATCH_ITERATE(e, ebt_cleanup_match, net, NULL);\n\tt = ebt_get_target(e);\n\n\tpar.net      = net;\n\tpar.target   = t->u.target;\n\tpar.targinfo = t->data;\n\tpar.family   = NFPROTO_BRIDGE;\n\tif (par.target->destroy != NULL)\n\t\tpar.target->destroy(&par);\n\tmodule_put(par.target->me);\n\treturn 0;\n}\n\nstatic inline int\nebt_check_entry(struct ebt_entry *e, struct net *net,\n\t\tconst struct ebt_table_info *newinfo,\n\t\tconst char *name, unsigned int *cnt,\n\t\tstruct ebt_cl_stack *cl_s, unsigned int udc_cnt)\n{\n\tstruct ebt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int i, j, hook = 0, hookmask = 0;\n\tsize_t gap;\n\tint ret;\n\tstruct xt_mtchk_param mtpar;\n\tstruct xt_tgchk_param tgpar;\n\n\t \n\tif (e->bitmask == 0)\n\t\treturn 0;\n\n\tif (e->bitmask & ~EBT_F_MASK)\n\t\treturn -EINVAL;\n\n\tif (e->invflags & ~EBT_INV_MASK)\n\t\treturn -EINVAL;\n\n\tif ((e->bitmask & EBT_NOPROTO) && (e->bitmask & EBT_802_3))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (!newinfo->hook_entry[i])\n\t\t\tcontinue;\n\t\tif ((char *)newinfo->hook_entry[i] < (char *)e)\n\t\t\thook = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\t \n\tif (i < NF_BR_NUMHOOKS)\n\t\thookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\n\telse {\n\t\tfor (i = 0; i < udc_cnt; i++)\n\t\t\tif ((char *)(cl_s[i].cs.chaininfo) > (char *)e)\n\t\t\t\tbreak;\n\t\tif (i == 0)\n\t\t\thookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\n\t\telse\n\t\t\thookmask = cl_s[i - 1].hookmask;\n\t}\n\ti = 0;\n\n\tmemset(&mtpar, 0, sizeof(mtpar));\n\tmemset(&tgpar, 0, sizeof(tgpar));\n\tmtpar.net\t= tgpar.net       = net;\n\tmtpar.table     = tgpar.table     = name;\n\tmtpar.entryinfo = tgpar.entryinfo = e;\n\tmtpar.hook_mask = tgpar.hook_mask = hookmask;\n\tmtpar.family    = tgpar.family    = NFPROTO_BRIDGE;\n\tret = EBT_MATCH_ITERATE(e, ebt_check_match, &mtpar, &i);\n\tif (ret != 0)\n\t\tgoto cleanup_matches;\n\tj = 0;\n\tret = EBT_WATCHER_ITERATE(e, ebt_check_watcher, &tgpar, &j);\n\tif (ret != 0)\n\t\tgoto cleanup_watchers;\n\tt = ebt_get_target(e);\n\tgap = e->next_offset - e->target_offset;\n\n\ttarget = xt_request_find_target(NFPROTO_BRIDGE, t->u.name, 0);\n\tif (IS_ERR(target)) {\n\t\tret = PTR_ERR(target);\n\t\tgoto cleanup_watchers;\n\t}\n\n\t \n\tif (target->family != NFPROTO_BRIDGE) {\n\t\tmodule_put(target->me);\n\t\tret = -ENOENT;\n\t\tgoto cleanup_watchers;\n\t}\n\n\tt->u.target = target;\n\tif (t->u.target == &ebt_standard_target) {\n\t\tif (gap < sizeof(struct ebt_standard_target)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup_watchers;\n\t\t}\n\t\tif (((struct ebt_standard_target *)t)->verdict <\n\t\t   -NUM_STANDARD_TARGETS) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup_watchers;\n\t\t}\n\t} else if (t->target_size > gap - sizeof(struct ebt_entry_target)) {\n\t\tmodule_put(t->u.target->me);\n\t\tret = -EFAULT;\n\t\tgoto cleanup_watchers;\n\t}\n\n\ttgpar.target   = target;\n\ttgpar.targinfo = t->data;\n\tret = xt_check_target(&tgpar, t->target_size,\n\t      ntohs(e->ethproto), e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(target->me);\n\t\tgoto cleanup_watchers;\n\t}\n\t(*cnt)++;\n\treturn 0;\ncleanup_watchers:\n\tEBT_WATCHER_ITERATE(e, ebt_cleanup_watcher, net, &j);\ncleanup_matches:\n\tEBT_MATCH_ITERATE(e, ebt_cleanup_match, net, &i);\n\treturn ret;\n}\n\n \nstatic int check_chainloops(const struct ebt_entries *chain, struct ebt_cl_stack *cl_s,\n\t\t\t    unsigned int udc_cnt, unsigned int hooknr, char *base)\n{\n\tint i, chain_nr = -1, pos = 0, nentries = chain->nentries, verdict;\n\tconst struct ebt_entry *e = (struct ebt_entry *)chain->data;\n\tconst struct ebt_entry_target *t;\n\n\twhile (pos < nentries || chain_nr != -1) {\n\t\t \n\t\tif (pos == nentries) {\n\t\t\t \n\t\t\te = cl_s[chain_nr].cs.e;\n\t\t\tif (cl_s[chain_nr].from != -1)\n\t\t\t\tnentries =\n\t\t\t\tcl_s[cl_s[chain_nr].from].cs.chaininfo->nentries;\n\t\t\telse\n\t\t\t\tnentries = chain->nentries;\n\t\t\tpos = cl_s[chain_nr].cs.n;\n\t\t\t \n\t\t\tcl_s[chain_nr].cs.n = 0;\n\t\t\tchain_nr = cl_s[chain_nr].from;\n\t\t\tif (pos == nentries)\n\t\t\t\tcontinue;\n\t\t}\n\t\tt = ebt_get_target_c(e);\n\t\tif (strcmp(t->u.name, EBT_STANDARD_TARGET))\n\t\t\tgoto letscontinue;\n\t\tif (e->target_offset + sizeof(struct ebt_standard_target) >\n\t\t   e->next_offset)\n\t\t\treturn -1;\n\n\t\tverdict = ((struct ebt_standard_target *)t)->verdict;\n\t\tif (verdict >= 0) {  \n\t\t\tstruct ebt_entries *hlp2 =\n\t\t\t   (struct ebt_entries *)(base + verdict);\n\t\t\tfor (i = 0; i < udc_cnt; i++)\n\t\t\t\tif (hlp2 == cl_s[i].cs.chaininfo)\n\t\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (i == udc_cnt)\n\t\t\t\treturn -1;\n\n\t\t\tif (cl_s[i].cs.n)\n\t\t\t\treturn -1;\n\n\t\t\tif (cl_s[i].hookmask & (1 << hooknr))\n\t\t\t\tgoto letscontinue;\n\t\t\t \n\t\t\tcl_s[i].cs.n = pos + 1;\n\t\t\tpos = 0;\n\t\t\tcl_s[i].cs.e = ebt_next_entry(e);\n\t\t\te = (struct ebt_entry *)(hlp2->data);\n\t\t\tnentries = hlp2->nentries;\n\t\t\tcl_s[i].from = chain_nr;\n\t\t\tchain_nr = i;\n\t\t\t \n\t\t\tcl_s[i].hookmask |= (1 << hooknr);\n\t\t\tcontinue;\n\t\t}\nletscontinue:\n\t\te = ebt_next_entry(e);\n\t\tpos++;\n\t}\n\treturn 0;\n}\n\n \nstatic int translate_table(struct net *net, const char *name,\n\t\t\t   struct ebt_table_info *newinfo)\n{\n\tunsigned int i, j, k, udc_cnt;\n\tint ret;\n\tstruct ebt_cl_stack *cl_s = NULL;  \n\n\ti = 0;\n\twhile (i < NF_BR_NUMHOOKS && !newinfo->hook_entry[i])\n\t\ti++;\n\tif (i == NF_BR_NUMHOOKS)\n\t\treturn -EINVAL;\n\n\tif (newinfo->hook_entry[i] != (struct ebt_entries *)newinfo->entries)\n\t\treturn -EINVAL;\n\n\t \n\tfor (j = i + 1; j < NF_BR_NUMHOOKS; j++) {\n\t\tif (!newinfo->hook_entry[j])\n\t\t\tcontinue;\n\t\tif (newinfo->hook_entry[j] <= newinfo->hook_entry[i])\n\t\t\treturn -EINVAL;\n\n\t\ti = j;\n\t}\n\n\t \n\ti = 0;  \n\tj = 0;  \n\tk = 0;  \n\tudc_cnt = 0;  \n\tret = EBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t   ebt_check_entry_size_and_hooks, newinfo,\n\t   &i, &j, &k, &udc_cnt);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (i != j)\n\t\treturn -EINVAL;\n\n\tif (k != newinfo->nentries)\n\t\treturn -EINVAL;\n\n\t \n\tif (udc_cnt) {\n\t\t \n\t\tnewinfo->chainstack =\n\t\t\tvmalloc(array_size(nr_cpu_ids,\n\t\t\t\t\t   sizeof(*(newinfo->chainstack))));\n\t\tif (!newinfo->chainstack)\n\t\t\treturn -ENOMEM;\n\t\tfor_each_possible_cpu(i) {\n\t\t\tnewinfo->chainstack[i] =\n\t\t\t  vmalloc_node(array_size(udc_cnt,\n\t\t\t\t\t  sizeof(*(newinfo->chainstack[0]))),\n\t\t\t\t       cpu_to_node(i));\n\t\t\tif (!newinfo->chainstack[i]) {\n\t\t\t\twhile (i)\n\t\t\t\t\tvfree(newinfo->chainstack[--i]);\n\t\t\t\tvfree(newinfo->chainstack);\n\t\t\t\tnewinfo->chainstack = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tcl_s = vmalloc(array_size(udc_cnt, sizeof(*cl_s)));\n\t\tif (!cl_s)\n\t\t\treturn -ENOMEM;\n\t\ti = 0;  \n\t\tEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t\t   ebt_get_udc_positions, newinfo, &i, cl_s);\n\t\t \n\t\tif (i != udc_cnt) {\n\t\t\tvfree(cl_s);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++)\n\t\tif (newinfo->hook_entry[i])\n\t\t\tif (check_chainloops(newinfo->hook_entry[i],\n\t\t\t   cl_s, udc_cnt, i, newinfo->entries)) {\n\t\t\t\tvfree(cl_s);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t \n\n\t \n\ti = 0;\n\tret = EBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t   ebt_check_entry, net, newinfo, name, &i, cl_s, udc_cnt);\n\tif (ret != 0) {\n\t\tEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t\t\t\t  ebt_cleanup_entry, net, &i);\n\t}\n\tvfree(cl_s);\n\treturn ret;\n}\n\n \nstatic void get_counters(const struct ebt_counter *oldcounters,\n\t\t\t struct ebt_counter *counters, unsigned int nentries)\n{\n\tint i, cpu;\n\tstruct ebt_counter *counter_base;\n\n\t \n\tmemcpy(counters, oldcounters,\n\t       sizeof(struct ebt_counter) * nentries);\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == 0)\n\t\t\tcontinue;\n\t\tcounter_base = COUNTER_BASE(oldcounters, nentries, cpu);\n\t\tfor (i = 0; i < nentries; i++)\n\t\t\tADD_COUNTER(counters[i], counter_base[i].bcnt,\n\t\t\t\t    counter_base[i].pcnt);\n\t}\n}\n\nstatic int do_replace_finish(struct net *net, struct ebt_replace *repl,\n\t\t\t      struct ebt_table_info *newinfo)\n{\n\tint ret;\n\tstruct ebt_counter *counterstmp = NULL;\n\t \n\tstruct ebt_table_info *table;\n\tstruct ebt_table *t;\n\n\t \n\tif (repl->num_counters) {\n\t\tunsigned long size = repl->num_counters * sizeof(*counterstmp);\n\t\tcounterstmp = vmalloc(size);\n\t\tif (!counterstmp)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tnewinfo->chainstack = NULL;\n\tret = ebt_verify_pointers(repl, newinfo);\n\tif (ret != 0)\n\t\tgoto free_counterstmp;\n\n\tret = translate_table(net, repl->name, newinfo);\n\n\tif (ret != 0)\n\t\tgoto free_counterstmp;\n\n\tt = find_table_lock(net, repl->name, &ret, &ebt_mutex);\n\tif (!t) {\n\t\tret = -ENOENT;\n\t\tgoto free_iterate;\n\t}\n\n\tif (repl->valid_hooks != t->valid_hooks) {\n\t\tret = -EINVAL;\n\t\tgoto free_unlock;\n\t}\n\n\tif (repl->num_counters && repl->num_counters != t->private->nentries) {\n\t\tret = -EINVAL;\n\t\tgoto free_unlock;\n\t}\n\n\t \n\ttable = t->private;\n\t \n\tif (!table->nentries && newinfo->nentries && !try_module_get(t->me)) {\n\t\tret = -ENOENT;\n\t\tgoto free_unlock;\n\t} else if (table->nentries && !newinfo->nentries)\n\t\tmodule_put(t->me);\n\t \n\twrite_lock_bh(&t->lock);\n\tif (repl->num_counters)\n\t\tget_counters(t->private->counters, counterstmp,\n\t\t   t->private->nentries);\n\n\tt->private = newinfo;\n\twrite_unlock_bh(&t->lock);\n\tmutex_unlock(&ebt_mutex);\n\t \n\tif (repl->num_counters &&\n\t   copy_to_user(repl->counters, counterstmp,\n\t   array_size(repl->num_counters, sizeof(struct ebt_counter)))) {\n\t\t \n\t\tnet_warn_ratelimited(\"ebtables: counters copy to user failed while replacing table\\n\");\n\t}\n\n\t \n\tEBT_ENTRY_ITERATE(table->entries, table->entries_size,\n\t\t\t  ebt_cleanup_entry, net, NULL);\n\n\tvfree(table->entries);\n\tebt_free_table_info(table);\n\tvfree(table);\n\tvfree(counterstmp);\n\n\taudit_log_nfcfg(repl->name, AF_BRIDGE, repl->nentries,\n\t\t\tAUDIT_XT_OP_REPLACE, GFP_KERNEL);\n\treturn 0;\n\nfree_unlock:\n\tmutex_unlock(&ebt_mutex);\nfree_iterate:\n\tEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\n\t\t\t  ebt_cleanup_entry, net, NULL);\nfree_counterstmp:\n\tvfree(counterstmp);\n\t \n\tebt_free_table_info(newinfo);\n\treturn ret;\n}\n\n \nstatic int do_replace(struct net *net, sockptr_t arg, unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\n\tif (copy_from_sockptr(&tmp, arg, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size)\n\t\treturn -EINVAL;\n\n\tif (tmp.entries_size == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\n\ttmp.name[sizeof(tmp.name) - 1] = 0;\n\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = __vmalloc(sizeof(*newinfo) + countersize, GFP_KERNEL_ACCOUNT);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tnewinfo->entries = __vmalloc(tmp.entries_size, GFP_KERNEL_ACCOUNT);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}\n\nstatic void __ebt_unregister_table(struct net *net, struct ebt_table *table)\n{\n\tmutex_lock(&ebt_mutex);\n\tlist_del(&table->list);\n\tmutex_unlock(&ebt_mutex);\n\taudit_log_nfcfg(table->name, AF_BRIDGE, table->private->nentries,\n\t\t\tAUDIT_XT_OP_UNREGISTER, GFP_KERNEL);\n\tEBT_ENTRY_ITERATE(table->private->entries, table->private->entries_size,\n\t\t\t  ebt_cleanup_entry, net, NULL);\n\tif (table->private->nentries)\n\t\tmodule_put(table->me);\n\tvfree(table->private->entries);\n\tebt_free_table_info(table->private);\n\tvfree(table->private);\n\tkfree(table->ops);\n\tkfree(table);\n}\n\nint ebt_register_table(struct net *net, const struct ebt_table *input_table,\n\t\t       const struct nf_hook_ops *template_ops)\n{\n\tstruct ebt_pernet *ebt_net = net_generic(net, ebt_pernet_id);\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_table *t, *table;\n\tstruct nf_hook_ops *ops;\n\tunsigned int num_ops;\n\tstruct ebt_replace_kernel *repl;\n\tint ret, i, countersize;\n\tvoid *p;\n\n\tif (input_table == NULL || (repl = input_table->table) == NULL ||\n\t    repl->entries == NULL || repl->entries_size == 0 ||\n\t    repl->counters != NULL || input_table->private != NULL)\n\t\treturn -EINVAL;\n\n\t \n\ttable = kmemdup(input_table, sizeof(struct ebt_table), GFP_KERNEL);\n\tif (!table) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcountersize = COUNTER_OFFSET(repl->nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tret = -ENOMEM;\n\tif (!newinfo)\n\t\tgoto free_table;\n\n\tp = vmalloc(repl->entries_size);\n\tif (!p)\n\t\tgoto free_newinfo;\n\n\tmemcpy(p, repl->entries, repl->entries_size);\n\tnewinfo->entries = p;\n\n\tnewinfo->entries_size = repl->entries_size;\n\tnewinfo->nentries = repl->nentries;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\t \n\tnewinfo->chainstack = NULL;\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif ((repl->valid_hooks & (1 << i)) == 0)\n\t\t\tnewinfo->hook_entry[i] = NULL;\n\t\telse\n\t\t\tnewinfo->hook_entry[i] = p +\n\t\t\t\t((char *)repl->hook_entry[i] - repl->entries);\n\t}\n\tret = translate_table(net, repl->name, newinfo);\n\tif (ret != 0)\n\t\tgoto free_chainstack;\n\n\ttable->private = newinfo;\n\trwlock_init(&table->lock);\n\tmutex_lock(&ebt_mutex);\n\tlist_for_each_entry(t, &ebt_net->tables, list) {\n\t\tif (strcmp(t->name, table->name) == 0) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto free_unlock;\n\t\t}\n\t}\n\n\t \n\tif (newinfo->nentries && !try_module_get(table->me)) {\n\t\tret = -ENOENT;\n\t\tgoto free_unlock;\n\t}\n\n\tnum_ops = hweight32(table->valid_hooks);\n\tif (num_ops == 0) {\n\t\tret = -EINVAL;\n\t\tgoto free_unlock;\n\t}\n\n\tops = kmemdup(template_ops, sizeof(*ops) * num_ops, GFP_KERNEL);\n\tif (!ops) {\n\t\tret = -ENOMEM;\n\t\tif (newinfo->nentries)\n\t\t\tmodule_put(table->me);\n\t\tgoto free_unlock;\n\t}\n\n\tfor (i = 0; i < num_ops; i++)\n\t\tops[i].priv = table;\n\n\tlist_add(&table->list, &ebt_net->tables);\n\tmutex_unlock(&ebt_mutex);\n\n\ttable->ops = ops;\n\tret = nf_register_net_hooks(net, ops, num_ops);\n\tif (ret)\n\t\t__ebt_unregister_table(net, table);\n\n\taudit_log_nfcfg(repl->name, AF_BRIDGE, repl->nentries,\n\t\t\tAUDIT_XT_OP_REGISTER, GFP_KERNEL);\n\treturn ret;\nfree_unlock:\n\tmutex_unlock(&ebt_mutex);\nfree_chainstack:\n\tebt_free_table_info(newinfo);\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\nfree_table:\n\tkfree(table);\nout:\n\treturn ret;\n}\n\nint ebt_register_template(const struct ebt_table *t, int (*table_init)(struct net *net))\n{\n\tstruct ebt_template *tmpl;\n\n\tmutex_lock(&ebt_mutex);\n\tlist_for_each_entry(tmpl, &template_tables, list) {\n\t\tif (WARN_ON_ONCE(strcmp(t->name, tmpl->name) == 0)) {\n\t\t\tmutex_unlock(&ebt_mutex);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\ttmpl = kzalloc(sizeof(*tmpl), GFP_KERNEL);\n\tif (!tmpl) {\n\t\tmutex_unlock(&ebt_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\ttmpl->table_init = table_init;\n\tstrscpy(tmpl->name, t->name, sizeof(tmpl->name));\n\ttmpl->owner = t->me;\n\tlist_add(&tmpl->list, &template_tables);\n\n\tmutex_unlock(&ebt_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(ebt_register_template);\n\nvoid ebt_unregister_template(const struct ebt_table *t)\n{\n\tstruct ebt_template *tmpl;\n\n\tmutex_lock(&ebt_mutex);\n\tlist_for_each_entry(tmpl, &template_tables, list) {\n\t\tif (strcmp(t->name, tmpl->name))\n\t\t\tcontinue;\n\n\t\tlist_del(&tmpl->list);\n\t\tmutex_unlock(&ebt_mutex);\n\t\tkfree(tmpl);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&ebt_mutex);\n\tWARN_ON_ONCE(1);\n}\nEXPORT_SYMBOL(ebt_unregister_template);\n\nstatic struct ebt_table *__ebt_find_table(struct net *net, const char *name)\n{\n\tstruct ebt_pernet *ebt_net = net_generic(net, ebt_pernet_id);\n\tstruct ebt_table *t;\n\n\tmutex_lock(&ebt_mutex);\n\n\tlist_for_each_entry(t, &ebt_net->tables, list) {\n\t\tif (strcmp(t->name, name) == 0) {\n\t\t\tmutex_unlock(&ebt_mutex);\n\t\t\treturn t;\n\t\t}\n\t}\n\n\tmutex_unlock(&ebt_mutex);\n\treturn NULL;\n}\n\nvoid ebt_unregister_table_pre_exit(struct net *net, const char *name)\n{\n\tstruct ebt_table *table = __ebt_find_table(net, name);\n\n\tif (table)\n\t\tnf_unregister_net_hooks(net, table->ops, hweight32(table->valid_hooks));\n}\nEXPORT_SYMBOL(ebt_unregister_table_pre_exit);\n\nvoid ebt_unregister_table(struct net *net, const char *name)\n{\n\tstruct ebt_table *table = __ebt_find_table(net, name);\n\n\tif (table)\n\t\t__ebt_unregister_table(net, table);\n}\n\n \nstatic int do_update_counters(struct net *net, const char *name,\n\t\t\t      struct ebt_counter __user *counters,\n\t\t\t      unsigned int num_counters, unsigned int len)\n{\n\tint i, ret;\n\tstruct ebt_counter *tmp;\n\tstruct ebt_table *t;\n\n\tif (num_counters == 0)\n\t\treturn -EINVAL;\n\n\ttmp = vmalloc(array_size(num_counters, sizeof(*tmp)));\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tt = find_table_lock(net, name, &ret, &ebt_mutex);\n\tif (!t)\n\t\tgoto free_tmp;\n\n\tif (num_counters != t->private->nentries) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_mutex;\n\t}\n\n\tif (copy_from_user(tmp, counters,\n\t\t\t   array_size(num_counters, sizeof(*counters)))) {\n\t\tret = -EFAULT;\n\t\tgoto unlock_mutex;\n\t}\n\n\t \n\twrite_lock_bh(&t->lock);\n\n\t \n\tfor (i = 0; i < num_counters; i++)\n\t\tADD_COUNTER(t->private->counters[i], tmp[i].bcnt, tmp[i].pcnt);\n\n\twrite_unlock_bh(&t->lock);\n\tret = 0;\nunlock_mutex:\n\tmutex_unlock(&ebt_mutex);\nfree_tmp:\n\tvfree(tmp);\n\treturn ret;\n}\n\nstatic int update_counters(struct net *net, sockptr_t arg, unsigned int len)\n{\n\tstruct ebt_replace hlp;\n\n\tif (copy_from_sockptr(&hlp, arg, sizeof(hlp)))\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(hlp) + hlp.num_counters * sizeof(struct ebt_counter))\n\t\treturn -EINVAL;\n\n\treturn do_update_counters(net, hlp.name, hlp.counters,\n\t\t\t\t  hlp.num_counters, len);\n}\n\nstatic inline int ebt_obj_to_user(char __user *um, const char *_name,\n\t\t\t\t  const char *data, int entrysize,\n\t\t\t\t  int usersize, int datasize, u8 revision)\n{\n\tchar name[EBT_EXTENSION_MAXNAMELEN] = {0};\n\n\t \n\tstrscpy(name, _name, sizeof(name));\n\tif (copy_to_user(um, name, EBT_EXTENSION_MAXNAMELEN) ||\n\t    put_user(revision, (u8 __user *)(um + EBT_EXTENSION_MAXNAMELEN)) ||\n\t    put_user(datasize, (int __user *)(um + EBT_EXTENSION_MAXNAMELEN + 1)) ||\n\t    xt_data_to_user(um + entrysize, data, usersize, datasize,\n\t\t\t    XT_ALIGN(datasize)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic inline int ebt_match_to_user(const struct ebt_entry_match *m,\n\t\t\t\t    const char *base, char __user *ubase)\n{\n\treturn ebt_obj_to_user(ubase + ((char *)m - base),\n\t\t\t       m->u.match->name, m->data, sizeof(*m),\n\t\t\t       m->u.match->usersize, m->match_size,\n\t\t\t       m->u.match->revision);\n}\n\nstatic inline int ebt_watcher_to_user(const struct ebt_entry_watcher *w,\n\t\t\t\t      const char *base, char __user *ubase)\n{\n\treturn ebt_obj_to_user(ubase + ((char *)w - base),\n\t\t\t       w->u.watcher->name, w->data, sizeof(*w),\n\t\t\t       w->u.watcher->usersize, w->watcher_size,\n\t\t\t       w->u.watcher->revision);\n}\n\nstatic inline int ebt_entry_to_user(struct ebt_entry *e, const char *base,\n\t\t\t\t    char __user *ubase)\n{\n\tint ret;\n\tchar __user *hlp;\n\tconst struct ebt_entry_target *t;\n\n\tif (e->bitmask == 0) {\n\t\t \n\t\tif (copy_to_user(ubase + ((char *)e - base), e,\n\t\t\t\t sizeof(struct ebt_entries)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tif (copy_to_user(ubase + ((char *)e - base), e, sizeof(*e)))\n\t\treturn -EFAULT;\n\n\thlp = ubase + (((char *)e + e->target_offset) - base);\n\tt = ebt_get_target_c(e);\n\n\tret = EBT_MATCH_ITERATE(e, ebt_match_to_user, base, ubase);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = EBT_WATCHER_ITERATE(e, ebt_watcher_to_user, base, ubase);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = ebt_obj_to_user(hlp, t->u.target->name, t->data, sizeof(*t),\n\t\t\t      t->u.target->usersize, t->target_size,\n\t\t\t      t->u.target->revision);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int copy_counters_to_user(struct ebt_table *t,\n\t\t\t\t const struct ebt_counter *oldcounters,\n\t\t\t\t void __user *user, unsigned int num_counters,\n\t\t\t\t unsigned int nentries)\n{\n\tstruct ebt_counter *counterstmp;\n\tint ret = 0;\n\n\t \n\tif (num_counters == 0)\n\t\treturn 0;\n\n\tif (num_counters != nentries)\n\t\treturn -EINVAL;\n\n\tcounterstmp = vmalloc(array_size(nentries, sizeof(*counterstmp)));\n\tif (!counterstmp)\n\t\treturn -ENOMEM;\n\n\twrite_lock_bh(&t->lock);\n\tget_counters(oldcounters, counterstmp, nentries);\n\twrite_unlock_bh(&t->lock);\n\n\tif (copy_to_user(user, counterstmp,\n\t    array_size(nentries, sizeof(struct ebt_counter))))\n\t\tret = -EFAULT;\n\tvfree(counterstmp);\n\treturn ret;\n}\n\n \nstatic int copy_everything_to_user(struct ebt_table *t, void __user *user,\n\t\t\t\t   const int *len, int cmd)\n{\n\tstruct ebt_replace tmp;\n\tconst struct ebt_counter *oldcounters;\n\tunsigned int entries_size, nentries;\n\tint ret;\n\tchar *entries;\n\n\tif (cmd == EBT_SO_GET_ENTRIES) {\n\t\tentries_size = t->private->entries_size;\n\t\tnentries = t->private->nentries;\n\t\tentries = t->private->entries;\n\t\toldcounters = t->private->counters;\n\t} else {\n\t\tentries_size = t->table->entries_size;\n\t\tnentries = t->table->nentries;\n\t\tentries = t->table->entries;\n\t\toldcounters = t->table->counters;\n\t}\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (*len != sizeof(struct ebt_replace) + entries_size +\n\t   (tmp.num_counters ? nentries * sizeof(struct ebt_counter) : 0))\n\t\treturn -EINVAL;\n\n\tif (tmp.nentries != nentries)\n\t\treturn -EINVAL;\n\n\tif (tmp.entries_size != entries_size)\n\t\treturn -EINVAL;\n\n\tret = copy_counters_to_user(t, oldcounters, tmp.counters,\n\t\t\t\t\ttmp.num_counters, nentries);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn EBT_ENTRY_ITERATE(entries, entries_size,\n\t   ebt_entry_to_user, entries, tmp.entries);\n}\n\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n \nstruct compat_ebt_replace {\n\tchar name[EBT_TABLE_MAXNAMELEN];\n\tcompat_uint_t valid_hooks;\n\tcompat_uint_t nentries;\n\tcompat_uint_t entries_size;\n\t \n\tcompat_uptr_t hook_entry[NF_BR_NUMHOOKS];\n\t \n\tcompat_uint_t num_counters;\n\t \n\tcompat_uptr_t counters;\n\tcompat_uptr_t entries;\n};\n\n \nstruct compat_ebt_entry_mwt {\n\tunion {\n\t\tstruct {\n\t\t\tchar name[EBT_EXTENSION_MAXNAMELEN];\n\t\t\tu8 revision;\n\t\t};\n\t\tcompat_uptr_t ptr;\n\t} u;\n\tcompat_uint_t match_size;\n\tcompat_uint_t data[] __aligned(__alignof__(struct compat_ebt_replace));\n};\n\n \nstatic int ebt_compat_entry_padsize(void)\n{\n\tBUILD_BUG_ON(sizeof(struct ebt_entry_match) <\n\t\t\tsizeof(struct compat_ebt_entry_mwt));\n\treturn (int) sizeof(struct ebt_entry_match) -\n\t\t\tsizeof(struct compat_ebt_entry_mwt);\n}\n\nstatic int ebt_compat_match_offset(const struct xt_match *match,\n\t\t\t\t   unsigned int userlen)\n{\n\t \n\tif (unlikely(match->matchsize == -1))\n\t\treturn XT_ALIGN(userlen) - COMPAT_XT_ALIGN(userlen);\n\treturn xt_compat_match_offset(match);\n}\n\nstatic int compat_match_to_user(struct ebt_entry_match *m, void __user **dstptr,\n\t\t\t\tunsigned int *size)\n{\n\tconst struct xt_match *match = m->u.match;\n\tstruct compat_ebt_entry_mwt __user *cm = *dstptr;\n\tint off = ebt_compat_match_offset(match, m->match_size);\n\tcompat_uint_t msize = m->match_size - off;\n\n\tif (WARN_ON(off >= m->match_size))\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(cm->u.name, match->name, strlen(match->name) + 1) ||\n\t    put_user(match->revision, &cm->u.revision) ||\n\t    put_user(msize, &cm->match_size))\n\t\treturn -EFAULT;\n\n\tif (match->compat_to_user) {\n\t\tif (match->compat_to_user(cm->data, m->data))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (xt_data_to_user(cm->data, m->data, match->usersize, msize,\n\t\t\t\t    COMPAT_XT_ALIGN(msize)))\n\t\t\treturn -EFAULT;\n\t}\n\n\t*size -= ebt_compat_entry_padsize() + off;\n\t*dstptr = cm->data;\n\t*dstptr += msize;\n\treturn 0;\n}\n\nstatic int compat_target_to_user(struct ebt_entry_target *t,\n\t\t\t\t void __user **dstptr,\n\t\t\t\t unsigned int *size)\n{\n\tconst struct xt_target *target = t->u.target;\n\tstruct compat_ebt_entry_mwt __user *cm = *dstptr;\n\tint off = xt_compat_target_offset(target);\n\tcompat_uint_t tsize = t->target_size - off;\n\n\tif (WARN_ON(off >= t->target_size))\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(cm->u.name, target->name, strlen(target->name) + 1) ||\n\t    put_user(target->revision, &cm->u.revision) ||\n\t    put_user(tsize, &cm->match_size))\n\t\treturn -EFAULT;\n\n\tif (target->compat_to_user) {\n\t\tif (target->compat_to_user(cm->data, t->data))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (xt_data_to_user(cm->data, t->data, target->usersize, tsize,\n\t\t\t\t    COMPAT_XT_ALIGN(tsize)))\n\t\t\treturn -EFAULT;\n\t}\n\n\t*size -= ebt_compat_entry_padsize() + off;\n\t*dstptr = cm->data;\n\t*dstptr += tsize;\n\treturn 0;\n}\n\nstatic int compat_watcher_to_user(struct ebt_entry_watcher *w,\n\t\t\t\t  void __user **dstptr,\n\t\t\t\t  unsigned int *size)\n{\n\treturn compat_target_to_user((struct ebt_entry_target *)w,\n\t\t\t\t\t\t\tdstptr, size);\n}\n\nstatic int compat_copy_entry_to_user(struct ebt_entry *e, void __user **dstptr,\n\t\t\t\tunsigned int *size)\n{\n\tstruct ebt_entry_target *t;\n\tstruct ebt_entry __user *ce;\n\tu32 watchers_offset, target_offset, next_offset;\n\tcompat_uint_t origsize;\n\tint ret;\n\n\tif (e->bitmask == 0) {\n\t\tif (*size < sizeof(struct ebt_entries))\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(*dstptr, e, sizeof(struct ebt_entries)))\n\t\t\treturn -EFAULT;\n\n\t\t*dstptr += sizeof(struct ebt_entries);\n\t\t*size -= sizeof(struct ebt_entries);\n\t\treturn 0;\n\t}\n\n\tif (*size < sizeof(*ce))\n\t\treturn -EINVAL;\n\n\tce = *dstptr;\n\tif (copy_to_user(ce, e, sizeof(*ce)))\n\t\treturn -EFAULT;\n\n\torigsize = *size;\n\t*dstptr += sizeof(*ce);\n\n\tret = EBT_MATCH_ITERATE(e, compat_match_to_user, dstptr, size);\n\tif (ret)\n\t\treturn ret;\n\twatchers_offset = e->watchers_offset - (origsize - *size);\n\n\tret = EBT_WATCHER_ITERATE(e, compat_watcher_to_user, dstptr, size);\n\tif (ret)\n\t\treturn ret;\n\ttarget_offset = e->target_offset - (origsize - *size);\n\n\tt = ebt_get_target(e);\n\n\tret = compat_target_to_user(t, dstptr, size);\n\tif (ret)\n\t\treturn ret;\n\tnext_offset = e->next_offset - (origsize - *size);\n\n\tif (put_user(watchers_offset, &ce->watchers_offset) ||\n\t    put_user(target_offset, &ce->target_offset) ||\n\t    put_user(next_offset, &ce->next_offset))\n\t\treturn -EFAULT;\n\n\t*size -= sizeof(*ce);\n\treturn 0;\n}\n\nstatic int compat_calc_match(struct ebt_entry_match *m, int *off)\n{\n\t*off += ebt_compat_match_offset(m->u.match, m->match_size);\n\t*off += ebt_compat_entry_padsize();\n\treturn 0;\n}\n\nstatic int compat_calc_watcher(struct ebt_entry_watcher *w, int *off)\n{\n\t*off += xt_compat_target_offset(w->u.watcher);\n\t*off += ebt_compat_entry_padsize();\n\treturn 0;\n}\n\nstatic int compat_calc_entry(const struct ebt_entry *e,\n\t\t\t     const struct ebt_table_info *info,\n\t\t\t     const void *base,\n\t\t\t     struct compat_ebt_replace *newinfo)\n{\n\tconst struct ebt_entry_target *t;\n\tunsigned int entry_offset;\n\tint off, ret, i;\n\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\n\toff = 0;\n\tentry_offset = (void *)e - base;\n\n\tEBT_MATCH_ITERATE(e, compat_calc_match, &off);\n\tEBT_WATCHER_ITERATE(e, compat_calc_watcher, &off);\n\n\tt = ebt_get_target_c(e);\n\n\toff += xt_compat_target_offset(t->u.target);\n\toff += ebt_compat_entry_padsize();\n\n\tnewinfo->entries_size -= off;\n\n\tret = xt_compat_add_offset(NFPROTO_BRIDGE, entry_offset, off);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tconst void *hookptr = info->hook_entry[i];\n\t\tif (info->hook_entry[i] &&\n\t\t    (e < (struct ebt_entry *)(base - hookptr))) {\n\t\t\tnewinfo->hook_entry[i] -= off;\n\t\t\tpr_debug(\"0x%08X -> 0x%08X\\n\",\n\t\t\t\t\tnewinfo->hook_entry[i] + off,\n\t\t\t\t\tnewinfo->hook_entry[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ebt_compat_init_offsets(unsigned int number)\n{\n\tif (number > INT_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tnumber += NF_BR_NUMHOOKS;\n\n\treturn xt_compat_init_offsets(NFPROTO_BRIDGE, number);\n}\n\nstatic int compat_table_info(const struct ebt_table_info *info,\n\t\t\t     struct compat_ebt_replace *newinfo)\n{\n\tunsigned int size = info->entries_size;\n\tconst void *entries = info->entries;\n\tint ret;\n\n\tnewinfo->entries_size = size;\n\tret = ebt_compat_init_offsets(info->nentries);\n\tif (ret)\n\t\treturn ret;\n\n\treturn EBT_ENTRY_ITERATE(entries, size, compat_calc_entry, info,\n\t\t\t\t\t\t\tentries, newinfo);\n}\n\nstatic int compat_copy_everything_to_user(struct ebt_table *t,\n\t\t\t\t\t  void __user *user, int *len, int cmd)\n{\n\tstruct compat_ebt_replace repl, tmp;\n\tstruct ebt_counter *oldcounters;\n\tstruct ebt_table_info tinfo;\n\tint ret;\n\tvoid __user *pos;\n\n\tmemset(&tinfo, 0, sizeof(tinfo));\n\n\tif (cmd == EBT_SO_GET_ENTRIES) {\n\t\ttinfo.entries_size = t->private->entries_size;\n\t\ttinfo.nentries = t->private->nentries;\n\t\ttinfo.entries = t->private->entries;\n\t\toldcounters = t->private->counters;\n\t} else {\n\t\ttinfo.entries_size = t->table->entries_size;\n\t\ttinfo.nentries = t->table->nentries;\n\t\ttinfo.entries = t->table->entries;\n\t\toldcounters = t->table->counters;\n\t}\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (tmp.nentries != tinfo.nentries ||\n\t   (tmp.num_counters && tmp.num_counters != tinfo.nentries))\n\t\treturn -EINVAL;\n\n\tmemcpy(&repl, &tmp, sizeof(repl));\n\tif (cmd == EBT_SO_GET_ENTRIES)\n\t\tret = compat_table_info(t->private, &repl);\n\telse\n\t\tret = compat_table_info(&tinfo, &repl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*len != sizeof(tmp) + repl.entries_size +\n\t   (tmp.num_counters? tinfo.nentries * sizeof(struct ebt_counter): 0)) {\n\t\tpr_err(\"wrong size: *len %d, entries_size %u, replsz %d\\n\",\n\t\t\t\t*len, tinfo.entries_size, repl.entries_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = copy_counters_to_user(t, oldcounters, compat_ptr(tmp.counters),\n\t\t\t\t\ttmp.num_counters, tinfo.nentries);\n\tif (ret)\n\t\treturn ret;\n\n\tpos = compat_ptr(tmp.entries);\n\treturn EBT_ENTRY_ITERATE(tinfo.entries, tinfo.entries_size,\n\t\t\tcompat_copy_entry_to_user, &pos, &tmp.entries_size);\n}\n\nstruct ebt_entries_buf_state {\n\tchar *buf_kern_start;\t \n\tu32 buf_kern_len;\t \n\tu32 buf_kern_offset;\t \n\tu32 buf_user_offset;\t \n};\n\nstatic int ebt_buf_count(struct ebt_entries_buf_state *state, unsigned int sz)\n{\n\tstate->buf_kern_offset += sz;\n\treturn state->buf_kern_offset >= sz ? 0 : -EINVAL;\n}\n\nstatic int ebt_buf_add(struct ebt_entries_buf_state *state,\n\t\t       const void *data, unsigned int sz)\n{\n\tif (state->buf_kern_start == NULL)\n\t\tgoto count_only;\n\n\tif (WARN_ON(state->buf_kern_offset + sz > state->buf_kern_len))\n\t\treturn -EINVAL;\n\n\tmemcpy(state->buf_kern_start + state->buf_kern_offset, data, sz);\n\n count_only:\n\tstate->buf_user_offset += sz;\n\treturn ebt_buf_count(state, sz);\n}\n\nstatic int ebt_buf_add_pad(struct ebt_entries_buf_state *state, unsigned int sz)\n{\n\tchar *b = state->buf_kern_start;\n\n\tif (WARN_ON(b && state->buf_kern_offset > state->buf_kern_len))\n\t\treturn -EINVAL;\n\n\tif (b != NULL && sz > 0)\n\t\tmemset(b + state->buf_kern_offset, 0, sz);\n\t \n\treturn ebt_buf_count(state, sz);\n}\n\nenum compat_mwt {\n\tEBT_COMPAT_MATCH,\n\tEBT_COMPAT_WATCHER,\n\tEBT_COMPAT_TARGET,\n};\n\nstatic int compat_mtw_from_user(const struct compat_ebt_entry_mwt *mwt,\n\t\t\t\tenum compat_mwt compat_mwt,\n\t\t\t\tstruct ebt_entries_buf_state *state,\n\t\t\t\tconst unsigned char *base)\n{\n\tchar name[EBT_EXTENSION_MAXNAMELEN];\n\tstruct xt_match *match;\n\tstruct xt_target *wt;\n\tvoid *dst = NULL;\n\tint off, pad = 0;\n\tunsigned int size_kern, match_size = mwt->match_size;\n\n\tif (strscpy(name, mwt->u.name, sizeof(name)) < 0)\n\t\treturn -EINVAL;\n\n\tif (state->buf_kern_start)\n\t\tdst = state->buf_kern_start + state->buf_kern_offset;\n\n\tswitch (compat_mwt) {\n\tcase EBT_COMPAT_MATCH:\n\t\tmatch = xt_request_find_match(NFPROTO_BRIDGE, name,\n\t\t\t\t\t      mwt->u.revision);\n\t\tif (IS_ERR(match))\n\t\t\treturn PTR_ERR(match);\n\n\t\toff = ebt_compat_match_offset(match, match_size);\n\t\tif (dst) {\n\t\t\tif (match->compat_from_user)\n\t\t\t\tmatch->compat_from_user(dst, mwt->data);\n\t\t\telse\n\t\t\t\tmemcpy(dst, mwt->data, match_size);\n\t\t}\n\n\t\tsize_kern = match->matchsize;\n\t\tif (unlikely(size_kern == -1))\n\t\t\tsize_kern = match_size;\n\t\tmodule_put(match->me);\n\t\tbreak;\n\tcase EBT_COMPAT_WATCHER:\n\tcase EBT_COMPAT_TARGET:\n\t\twt = xt_request_find_target(NFPROTO_BRIDGE, name,\n\t\t\t\t\t    mwt->u.revision);\n\t\tif (IS_ERR(wt))\n\t\t\treturn PTR_ERR(wt);\n\t\toff = xt_compat_target_offset(wt);\n\n\t\tif (dst) {\n\t\t\tif (wt->compat_from_user)\n\t\t\t\twt->compat_from_user(dst, mwt->data);\n\t\t\telse\n\t\t\t\tmemcpy(dst, mwt->data, match_size);\n\t\t}\n\n\t\tsize_kern = wt->targetsize;\n\t\tmodule_put(wt->me);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstate->buf_kern_offset += match_size + off;\n\tstate->buf_user_offset += match_size;\n\tpad = XT_ALIGN(size_kern) - size_kern;\n\n\tif (pad > 0 && dst) {\n\t\tif (WARN_ON(state->buf_kern_len <= pad))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(state->buf_kern_offset - (match_size + off) + size_kern > state->buf_kern_len - pad))\n\t\t\treturn -EINVAL;\n\t\tmemset(dst + size_kern, 0, pad);\n\t}\n\treturn off + match_size;\n}\n\n \nstatic int ebt_size_mwt(const struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tconst char *buf = (const char *)match32;\n\tint growth = 0;\n\n\tif (size_left == 0)\n\t\treturn 0;\n\n\tdo {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\n\t\tif (size_left < sizeof(*match32))\n\t\t\treturn -EINVAL;\n\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\n\t\t \n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\n\t\tsize_left -= match32->match_size;\n\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t} while (size_left);\n\n\treturn growth;\n}\n\n \nstatic int size_entry_mwt(const struct ebt_entry *entry, const unsigned char *base,\n\t\t\t  unsigned int *total,\n\t\t\t  struct ebt_entries_buf_state *state)\n{\n\tunsigned int i, j, startoff, next_expected_off, new_offset = 0;\n\t \n\tunsigned int offsets[4];\n\tunsigned int *offsets_update = NULL;\n\tint ret;\n\tchar *buf_start;\n\n\tif (*total < sizeof(struct ebt_entries))\n\t\treturn -EINVAL;\n\n\tif (!entry->bitmask) {\n\t\t*total -= sizeof(struct ebt_entries);\n\t\treturn ebt_buf_add(state, entry, sizeof(struct ebt_entries));\n\t}\n\tif (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))\n\t\treturn -EINVAL;\n\n\tstartoff = state->buf_user_offset;\n\t \n\tret = ebt_buf_add(state, entry,\n\t\t\toffsetof(struct ebt_entry, watchers_offset));\n\tif (ret < 0)\n\t\treturn ret;\n\n\toffsets[0] = sizeof(struct ebt_entry);  \n\tmemcpy(&offsets[1], &entry->offsets, sizeof(entry->offsets));\n\n\tif (state->buf_kern_start) {\n\t\tbuf_start = state->buf_kern_start + state->buf_kern_offset;\n\t\toffsets_update = (unsigned int *) buf_start;\n\t}\n\tret = ebt_buf_add(state, &offsets[1],\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\tif (ret < 0)\n\t\treturn ret;\n\tbuf_start = (char *) entry;\n\t \n\tfor (i = 0; i < 4 ; ++i) {\n\t\tif (offsets[i] > *total)\n\t\t\treturn -EINVAL;\n\n\t\tif (i < 3 && offsets[i] == *total)\n\t\t\treturn -EINVAL;\n\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (offsets[i-1] > offsets[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, j = 1 ; j < 4 ; j++, i++) {\n\t\tstruct compat_ebt_entry_mwt *match32;\n\t\tunsigned int size;\n\t\tchar *buf = buf_start + offsets[i];\n\n\t\tif (offsets[i] > offsets[j])\n\t\t\treturn -EINVAL;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t\tsize = offsets[j] - offsets[i];\n\t\tret = ebt_size_mwt(match32, size, i, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_offset += ret;\n\t\tif (offsets_update && new_offset) {\n\t\t\tpr_debug(\"change offset %d to %d\\n\",\n\t\t\t\toffsets_update[i], offsets[j] + new_offset);\n\t\t\toffsets_update[i] = offsets[j] + new_offset;\n\t\t}\n\t}\n\n\tif (state->buf_kern_start == NULL) {\n\t\tunsigned int offset = buf_start - (char *) base;\n\n\t\tret = xt_compat_add_offset(NFPROTO_BRIDGE, offset, new_offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tnext_expected_off = state->buf_user_offset - startoff;\n\tif (next_expected_off != entry->next_offset)\n\t\treturn -EINVAL;\n\n\tif (*total < entry->next_offset)\n\t\treturn -EINVAL;\n\t*total -= entry->next_offset;\n\treturn 0;\n}\n\n \nstatic int compat_copy_entries(unsigned char *data, unsigned int size_user,\n\t\t\t\tstruct ebt_entries_buf_state *state)\n{\n\tunsigned int size_remaining = size_user;\n\tint ret;\n\n\tret = EBT_ENTRY_ITERATE(data, size_user, size_entry_mwt, data,\n\t\t\t\t\t&size_remaining, state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (size_remaining)\n\t\treturn -EINVAL;\n\n\treturn state->buf_kern_offset;\n}\n\n\nstatic int compat_copy_ebt_replace_from_user(struct ebt_replace *repl,\n\t\t\t\t\t     sockptr_t arg, unsigned int len)\n{\n\tstruct compat_ebt_replace tmp;\n\tint i;\n\n\tif (len < sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&tmp, arg, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size)\n\t\treturn -EINVAL;\n\n\tif (tmp.entries_size == 0)\n\t\treturn -EINVAL;\n\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\n\tmemcpy(repl, &tmp, offsetof(struct ebt_replace, hook_entry));\n\n\t \n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++)\n\t\trepl->hook_entry[i] = compat_ptr(tmp.hook_entry[i]);\n\n\trepl->num_counters = tmp.num_counters;\n\trepl->counters = compat_ptr(tmp.counters);\n\trepl->entries = compat_ptr(tmp.entries);\n\treturn 0;\n}\n\nstatic int compat_do_replace(struct net *net, sockptr_t arg, unsigned int len)\n{\n\tint ret, i, countersize, size64;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\tstruct ebt_entries_buf_state state;\n\tvoid *entries_tmp;\n\n\tret = compat_copy_ebt_replace_from_user(&tmp, arg, len);\n\tif (ret) {\n\t\t \n\t\tif (ret == -EINVAL && do_replace(net, arg, len) == 0)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tmemset(&state, 0, sizeof(state));\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tentries_tmp = newinfo->entries;\n\n\txt_compat_lock(NFPROTO_BRIDGE);\n\n\tret = ebt_compat_init_offsets(tmp.nentries);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tret = compat_copy_entries(entries_tmp, tmp.entries_size, &state);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tpr_debug(\"tmp.entries_size %d, kern off %d, user off %d delta %d\\n\",\n\t\ttmp.entries_size, state.buf_kern_offset, state.buf_user_offset,\n\t\txt_compat_calc_jump(NFPROTO_BRIDGE, tmp.entries_size));\n\n\tsize64 = ret;\n\tnewinfo->entries = vmalloc(size64);\n\tif (!newinfo->entries) {\n\t\tvfree(entries_tmp);\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.buf_kern_start = newinfo->entries;\n\tstate.buf_kern_len = size64;\n\n\tret = compat_copy_entries(entries_tmp, tmp.entries_size, &state);\n\tif (WARN_ON(ret < 0)) {\n\t\tvfree(entries_tmp);\n\t\tgoto out_unlock;\n\t}\n\n\tvfree(entries_tmp);\n\ttmp.entries_size = size64;\n\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tchar __user *usrptr;\n\t\tif (tmp.hook_entry[i]) {\n\t\t\tunsigned int delta;\n\t\t\tusrptr = (char __user *) tmp.hook_entry[i];\n\t\t\tdelta = usrptr - tmp.entries;\n\t\t\tusrptr += xt_compat_calc_jump(NFPROTO_BRIDGE, delta);\n\t\t\ttmp.hook_entry[i] = (struct ebt_entries __user *)usrptr;\n\t\t}\n\t}\n\n\txt_compat_flush_offsets(NFPROTO_BRIDGE);\n\txt_compat_unlock(NFPROTO_BRIDGE);\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(NFPROTO_BRIDGE);\n\txt_compat_unlock(NFPROTO_BRIDGE);\n\tgoto free_entries;\n}\n\nstatic int compat_update_counters(struct net *net, sockptr_t arg,\n\t\t\t\t  unsigned int len)\n{\n\tstruct compat_ebt_replace hlp;\n\n\tif (copy_from_sockptr(&hlp, arg, sizeof(hlp)))\n\t\treturn -EFAULT;\n\n\t \n\tif (len != sizeof(hlp) + hlp.num_counters * sizeof(struct ebt_counter))\n\t\treturn update_counters(net, arg, len);\n\n\treturn do_update_counters(net, hlp.name, compat_ptr(hlp.counters),\n\t\t\t\t  hlp.num_counters, len);\n}\n\nstatic int compat_do_ebt_get_ctl(struct sock *sk, int cmd,\n\t\tvoid __user *user, int *len)\n{\n\tint ret;\n\tstruct compat_ebt_replace tmp;\n\tstruct ebt_table *t;\n\tstruct net *net = sock_net(sk);\n\n\tif ((cmd == EBT_SO_GET_INFO || cmd == EBT_SO_GET_INIT_INFO) &&\n\t    *len != sizeof(struct compat_ebt_replace))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\ttmp.name[sizeof(tmp.name) - 1] = '\\0';\n\n\tt = find_table_lock(net, tmp.name, &ret, &ebt_mutex);\n\tif (!t)\n\t\treturn ret;\n\n\txt_compat_lock(NFPROTO_BRIDGE);\n\tswitch (cmd) {\n\tcase EBT_SO_GET_INFO:\n\t\ttmp.nentries = t->private->nentries;\n\t\tret = compat_table_info(t->private, &tmp);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\ttmp.valid_hooks = t->valid_hooks;\n\n\t\tif (copy_to_user(user, &tmp, *len) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase EBT_SO_GET_INIT_INFO:\n\t\ttmp.nentries = t->table->nentries;\n\t\ttmp.entries_size = t->table->entries_size;\n\t\ttmp.valid_hooks = t->table->valid_hooks;\n\n\t\tif (copy_to_user(user, &tmp, *len) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase EBT_SO_GET_ENTRIES:\n\tcase EBT_SO_GET_INIT_ENTRIES:\n\t\t \n\t\tif (copy_everything_to_user(t, user, len, cmd) == 0)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = compat_copy_everything_to_user(t, user, len, cmd);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n out:\n\txt_compat_flush_offsets(NFPROTO_BRIDGE);\n\txt_compat_unlock(NFPROTO_BRIDGE);\n\tmutex_unlock(&ebt_mutex);\n\treturn ret;\n}\n#endif\n\nstatic int do_ebt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct ebt_replace tmp;\n\tstruct ebt_table *t;\n\tint ret;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t \n\tif (in_compat_syscall() &&\n\t    ((cmd != EBT_SO_GET_INFO && cmd != EBT_SO_GET_INIT_INFO) ||\n\t     *len != sizeof(tmp)))\n\t\treturn compat_do_ebt_get_ctl(sk, cmd, user, len);\n#endif\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\ttmp.name[sizeof(tmp.name) - 1] = '\\0';\n\n\tt = find_table_lock(net, tmp.name, &ret, &ebt_mutex);\n\tif (!t)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase EBT_SO_GET_INFO:\n\tcase EBT_SO_GET_INIT_INFO:\n\t\tif (*len != sizeof(struct ebt_replace)) {\n\t\t\tret = -EINVAL;\n\t\t\tmutex_unlock(&ebt_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tif (cmd == EBT_SO_GET_INFO) {\n\t\t\ttmp.nentries = t->private->nentries;\n\t\t\ttmp.entries_size = t->private->entries_size;\n\t\t\ttmp.valid_hooks = t->valid_hooks;\n\t\t} else {\n\t\t\ttmp.nentries = t->table->nentries;\n\t\t\ttmp.entries_size = t->table->entries_size;\n\t\t\ttmp.valid_hooks = t->table->valid_hooks;\n\t\t}\n\t\tmutex_unlock(&ebt_mutex);\n\t\tif (copy_to_user(user, &tmp, *len) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\n\tcase EBT_SO_GET_ENTRIES:\n\tcase EBT_SO_GET_INIT_ENTRIES:\n\t\tret = copy_everything_to_user(t, user, len, cmd);\n\t\tmutex_unlock(&ebt_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&ebt_mutex);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int do_ebt_set_ctl(struct sock *sk, int cmd, sockptr_t arg,\n\t\tunsigned int len)\n{\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase EBT_SO_SET_ENTRIES:\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t\tif (in_compat_syscall())\n\t\t\tret = compat_do_replace(net, arg, len);\n\t\telse\n#endif\n\t\t\tret = do_replace(net, arg, len);\n\t\tbreak;\n\tcase EBT_SO_SET_COUNTERS:\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t\tif (in_compat_syscall())\n\t\t\tret = compat_update_counters(net, arg, len);\n\t\telse\n#endif\n\t\t\tret = update_counters(net, arg, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic struct nf_sockopt_ops ebt_sockopts = {\n\t.pf\t\t= PF_INET,\n\t.set_optmin\t= EBT_BASE_CTL,\n\t.set_optmax\t= EBT_SO_SET_MAX + 1,\n\t.set\t\t= do_ebt_set_ctl,\n\t.get_optmin\t= EBT_BASE_CTL,\n\t.get_optmax\t= EBT_SO_GET_MAX + 1,\n\t.get\t\t= do_ebt_get_ctl,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __net_init ebt_pernet_init(struct net *net)\n{\n\tstruct ebt_pernet *ebt_net = net_generic(net, ebt_pernet_id);\n\n\tINIT_LIST_HEAD(&ebt_net->tables);\n\treturn 0;\n}\n\nstatic struct pernet_operations ebt_net_ops = {\n\t.init = ebt_pernet_init,\n\t.id   = &ebt_pernet_id,\n\t.size = sizeof(struct ebt_pernet),\n};\n\nstatic int __init ebtables_init(void)\n{\n\tint ret;\n\n\tret = xt_register_target(&ebt_standard_target);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = nf_register_sockopt(&ebt_sockopts);\n\tif (ret < 0) {\n\t\txt_unregister_target(&ebt_standard_target);\n\t\treturn ret;\n\t}\n\n\tret = register_pernet_subsys(&ebt_net_ops);\n\tif (ret < 0) {\n\t\tnf_unregister_sockopt(&ebt_sockopts);\n\t\txt_unregister_target(&ebt_standard_target);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ebtables_fini(void)\n{\n\tnf_unregister_sockopt(&ebt_sockopts);\n\txt_unregister_target(&ebt_standard_target);\n\tunregister_pernet_subsys(&ebt_net_ops);\n}\n\nEXPORT_SYMBOL(ebt_register_table);\nEXPORT_SYMBOL(ebt_unregister_table);\nEXPORT_SYMBOL(ebt_do_table);\nmodule_init(ebtables_init);\nmodule_exit(ebtables_fini);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}