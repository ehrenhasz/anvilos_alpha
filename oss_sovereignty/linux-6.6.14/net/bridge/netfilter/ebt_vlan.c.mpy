{
  "module_name": "ebt_vlan.c",
  "hash_id": "10593a2b7f7d7d3fc13e60daaa2bd0c76727e0c9b52938b33d5de726bcade216",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/netfilter/ebt_vlan.c",
  "human_readable_source": "\n \n\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_bridge/ebtables.h>\n#include <linux/netfilter_bridge/ebt_vlan.h>\n\n#define MODULE_VERS \"0.6\"\n\nMODULE_AUTHOR(\"Nick Fedchik <nick@fedchik.org.ua>\");\nMODULE_DESCRIPTION(\"Ebtables: 802.1Q VLAN tag match\");\nMODULE_LICENSE(\"GPL\");\n\n#define GET_BITMASK(_BIT_MASK_) info->bitmask & _BIT_MASK_\n#define EXIT_ON_MISMATCH(_MATCH_,_MASK_) {if (!((info->_MATCH_ == _MATCH_)^!!(info->invflags & _MASK_))) return false; }\n\nstatic bool\nebt_vlan_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct ebt_vlan_info *info = par->matchinfo;\n\n\tunsigned short TCI;\t \n\tunsigned short id;\t \n\tunsigned char prio;\t \n\t \n\t__be16 encap;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tTCI = skb_vlan_tag_get(skb);\n\t\tencap = skb->protocol;\n\t} else {\n\t\tconst struct vlan_hdr *fp;\n\t\tstruct vlan_hdr _frame;\n\n\t\tfp = skb_header_pointer(skb, 0, sizeof(_frame), &_frame);\n\t\tif (fp == NULL)\n\t\t\treturn false;\n\n\t\tTCI = ntohs(fp->h_vlan_TCI);\n\t\tencap = fp->h_vlan_encapsulated_proto;\n\t}\n\n\t \n\tid = TCI & VLAN_VID_MASK;\n\tprio = (TCI >> 13) & 0x7;\n\n\t \n\tif (GET_BITMASK(EBT_VLAN_ID))\n\t\tEXIT_ON_MISMATCH(id, EBT_VLAN_ID);\n\n\t \n\tif (GET_BITMASK(EBT_VLAN_PRIO))\n\t\tEXIT_ON_MISMATCH(prio, EBT_VLAN_PRIO);\n\n\t \n\tif (GET_BITMASK(EBT_VLAN_ENCAP))\n\t\tEXIT_ON_MISMATCH(encap, EBT_VLAN_ENCAP);\n\n\treturn true;\n}\n\nstatic int ebt_vlan_mt_check(const struct xt_mtchk_param *par)\n{\n\tstruct ebt_vlan_info *info = par->matchinfo;\n\tconst struct ebt_entry *e = par->entryinfo;\n\n\t \n\tif (e->ethproto != htons(ETH_P_8021Q)) {\n\t\tpr_debug(\"passed entry proto %2.4X is not 802.1Q (8100)\\n\",\n\t\t\t ntohs(e->ethproto));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (info->bitmask & ~EBT_VLAN_MASK) {\n\t\tpr_debug(\"bitmask %2X is out of mask (%2X)\\n\",\n\t\t\t info->bitmask, EBT_VLAN_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (info->invflags & ~EBT_VLAN_MASK) {\n\t\tpr_debug(\"inversion flags %2X is out of mask (%2X)\\n\",\n\t\t\t info->invflags, EBT_VLAN_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (GET_BITMASK(EBT_VLAN_ID)) {\n\t\tif (!!info->id) {  \n\t\t\tif (info->id > VLAN_N_VID) {\n\t\t\t\tpr_debug(\"id %d is out of range (1-4096)\\n\",\n\t\t\t\t\t info->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tinfo->bitmask &= ~EBT_VLAN_PRIO;\n\t\t}\n\t\t \n\t}\n\n\tif (GET_BITMASK(EBT_VLAN_PRIO)) {\n\t\tif ((unsigned char) info->prio > 7) {\n\t\t\tpr_debug(\"prio %d is out of range (0-7)\\n\",\n\t\t\t\t info->prio);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tif (GET_BITMASK(EBT_VLAN_ENCAP)) {\n\t\tif ((unsigned short) ntohs(info->encap) < ETH_ZLEN) {\n\t\t\tpr_debug(\"encap frame length %d is less than \"\n\t\t\t\t \"minimal\\n\", ntohs(info->encap));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_match ebt_vlan_mt_reg __read_mostly = {\n\t.name\t\t= \"vlan\",\n\t.revision\t= 0,\n\t.family\t\t= NFPROTO_BRIDGE,\n\t.match\t\t= ebt_vlan_mt,\n\t.checkentry\t= ebt_vlan_mt_check,\n\t.matchsize\t= sizeof(struct ebt_vlan_info),\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init ebt_vlan_init(void)\n{\n\tpr_debug(\"ebtables 802.1Q extension module v\" MODULE_VERS \"\\n\");\n\treturn xt_register_match(&ebt_vlan_mt_reg);\n}\n\nstatic void __exit ebt_vlan_fini(void)\n{\n\txt_unregister_match(&ebt_vlan_mt_reg);\n}\n\nmodule_init(ebt_vlan_init);\nmodule_exit(ebt_vlan_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}