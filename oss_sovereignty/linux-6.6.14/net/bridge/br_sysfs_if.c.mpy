{
  "module_name": "br_sysfs_if.c",
  "hash_id": "3e4f4dc7daedcce2dd2736f28fa6ca0598a08d9924a2a8b96f55ecf059ba084a",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_sysfs_if.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/rtnetlink.h>\n#include <linux/spinlock.h>\n#include <linux/sched/signal.h>\n\n#include \"br_private.h\"\n\n \n\nstruct brport_attribute {\n\tstruct attribute\tattr;\n\tssize_t (*show)(struct net_bridge_port *, char *);\n\tint (*store)(struct net_bridge_port *, unsigned long);\n\tint (*store_raw)(struct net_bridge_port *, char *);\n};\n\n#define BRPORT_ATTR_RAW(_name, _mode, _show, _store)\t\t\t\\\nconst struct brport_attribute brport_attr_##_name = {\t\t\t\\\n\t.attr\t\t= {.name = __stringify(_name),\t\t\t\\\n\t\t\t   .mode = _mode },\t\t\t\t\\\n\t.show\t\t= _show,\t\t\t\t\t\\\n\t.store_raw\t= _store,\t\t\t\t\t\\\n};\n\n#define BRPORT_ATTR(_name, _mode, _show, _store)\t\t\\\nconst struct brport_attribute brport_attr_##_name = { \t        \\\n\t.attr = {.name = __stringify(_name), \t\t\t\\\n\t\t .mode = _mode },\t\t\t\t\\\n\t.show\t= _show,\t\t\t\t\t\\\n\t.store\t= _store,\t\t\t\t\t\\\n};\n\n#define BRPORT_ATTR_FLAG(_name, _mask)\t\t\t\t\\\nstatic ssize_t show_##_name(struct net_bridge_port *p, char *buf) \\\n{\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%d\\n\", !!(p->flags & _mask));\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic int store_##_name(struct net_bridge_port *p, unsigned long v) \\\n{\t\t\t\t\t\t\t\t\\\n\treturn store_flag(p, v, _mask);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic BRPORT_ATTR(_name, 0644,\t\t\t\t\t\\\n\t\t   show_##_name, store_##_name)\n\nstatic int store_flag(struct net_bridge_port *p, unsigned long v,\n\t\t      unsigned long mask)\n{\n\tstruct netlink_ext_ack extack = {0};\n\tunsigned long flags = p->flags;\n\tint err;\n\n\tif (v)\n\t\tflags |= mask;\n\telse\n\t\tflags &= ~mask;\n\n\tif (flags != p->flags) {\n\t\terr = br_switchdev_set_port_flag(p, flags, mask, &extack);\n\t\tif (err) {\n\t\t\tnetdev_err(p->dev, \"%s\\n\", extack._msg);\n\t\t\treturn err;\n\t\t}\n\n\t\tp->flags = flags;\n\t\tbr_port_flags_change(p, mask);\n\t}\n\treturn 0;\n}\n\nstatic ssize_t show_path_cost(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", p->path_cost);\n}\n\nstatic BRPORT_ATTR(path_cost, 0644,\n\t\t   show_path_cost, br_stp_set_path_cost);\n\nstatic ssize_t show_priority(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", p->priority);\n}\n\nstatic BRPORT_ATTR(priority, 0644,\n\t\t\t show_priority, br_stp_set_port_priority);\n\nstatic ssize_t show_designated_root(struct net_bridge_port *p, char *buf)\n{\n\treturn br_show_bridge_id(buf, &p->designated_root);\n}\nstatic BRPORT_ATTR(designated_root, 0444, show_designated_root, NULL);\n\nstatic ssize_t show_designated_bridge(struct net_bridge_port *p, char *buf)\n{\n\treturn br_show_bridge_id(buf, &p->designated_bridge);\n}\nstatic BRPORT_ATTR(designated_bridge, 0444, show_designated_bridge, NULL);\n\nstatic ssize_t show_designated_port(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", p->designated_port);\n}\nstatic BRPORT_ATTR(designated_port, 0444, show_designated_port, NULL);\n\nstatic ssize_t show_designated_cost(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", p->designated_cost);\n}\nstatic BRPORT_ATTR(designated_cost, 0444, show_designated_cost, NULL);\n\nstatic ssize_t show_port_id(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"0x%x\\n\", p->port_id);\n}\nstatic BRPORT_ATTR(port_id, 0444, show_port_id, NULL);\n\nstatic ssize_t show_port_no(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"0x%x\\n\", p->port_no);\n}\n\nstatic BRPORT_ATTR(port_no, 0444, show_port_no, NULL);\n\nstatic ssize_t show_change_ack(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", p->topology_change_ack);\n}\nstatic BRPORT_ATTR(change_ack, 0444, show_change_ack, NULL);\n\nstatic ssize_t show_config_pending(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", p->config_pending);\n}\nstatic BRPORT_ATTR(config_pending, 0444, show_config_pending, NULL);\n\nstatic ssize_t show_port_state(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", p->state);\n}\nstatic BRPORT_ATTR(state, 0444, show_port_state, NULL);\n\nstatic ssize_t show_message_age_timer(struct net_bridge_port *p,\n\t\t\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%ld\\n\", br_timer_value(&p->message_age_timer));\n}\nstatic BRPORT_ATTR(message_age_timer, 0444, show_message_age_timer, NULL);\n\nstatic ssize_t show_forward_delay_timer(struct net_bridge_port *p,\n\t\t\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%ld\\n\", br_timer_value(&p->forward_delay_timer));\n}\nstatic BRPORT_ATTR(forward_delay_timer, 0444, show_forward_delay_timer, NULL);\n\nstatic ssize_t show_hold_timer(struct net_bridge_port *p,\n\t\t\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%ld\\n\", br_timer_value(&p->hold_timer));\n}\nstatic BRPORT_ATTR(hold_timer, 0444, show_hold_timer, NULL);\n\nstatic int store_flush(struct net_bridge_port *p, unsigned long v)\n{\n\tbr_fdb_delete_by_port(p->br, p, 0, 0); \n\treturn 0;\n}\nstatic BRPORT_ATTR(flush, 0200, NULL, store_flush);\n\nstatic ssize_t show_group_fwd_mask(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"%#x\\n\", p->group_fwd_mask);\n}\n\nstatic int store_group_fwd_mask(struct net_bridge_port *p,\n\t\t\t\tunsigned long v)\n{\n\tif (v & BR_GROUPFWD_MACPAUSE)\n\t\treturn -EINVAL;\n\tp->group_fwd_mask = v;\n\n\treturn 0;\n}\nstatic BRPORT_ATTR(group_fwd_mask, 0644, show_group_fwd_mask,\n\t\t   store_group_fwd_mask);\n\nstatic ssize_t show_backup_port(struct net_bridge_port *p, char *buf)\n{\n\tstruct net_bridge_port *backup_p;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tbackup_p = rcu_dereference(p->backup_port);\n\tif (backup_p)\n\t\tret = sprintf(buf, \"%s\\n\", backup_p->dev->name);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic int store_backup_port(struct net_bridge_port *p, char *buf)\n{\n\tstruct net_device *backup_dev = NULL;\n\tchar *nl = strchr(buf, '\\n');\n\n\tif (nl)\n\t\t*nl = '\\0';\n\n\tif (strlen(buf) > 0) {\n\t\tbackup_dev = __dev_get_by_name(dev_net(p->dev), buf);\n\t\tif (!backup_dev)\n\t\t\treturn -ENOENT;\n\t}\n\n\treturn nbp_backup_change(p, backup_dev);\n}\nstatic BRPORT_ATTR_RAW(backup_port, 0644, show_backup_port, store_backup_port);\n\nBRPORT_ATTR_FLAG(hairpin_mode, BR_HAIRPIN_MODE);\nBRPORT_ATTR_FLAG(bpdu_guard, BR_BPDU_GUARD);\nBRPORT_ATTR_FLAG(root_block, BR_ROOT_BLOCK);\nBRPORT_ATTR_FLAG(learning, BR_LEARNING);\nBRPORT_ATTR_FLAG(unicast_flood, BR_FLOOD);\nBRPORT_ATTR_FLAG(proxyarp, BR_PROXYARP);\nBRPORT_ATTR_FLAG(proxyarp_wifi, BR_PROXYARP_WIFI);\nBRPORT_ATTR_FLAG(multicast_flood, BR_MCAST_FLOOD);\nBRPORT_ATTR_FLAG(broadcast_flood, BR_BCAST_FLOOD);\nBRPORT_ATTR_FLAG(neigh_suppress, BR_NEIGH_SUPPRESS);\nBRPORT_ATTR_FLAG(isolated, BR_ISOLATED);\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\nstatic ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", p->multicast_ctx.multicast_router);\n}\n\nstatic int store_multicast_router(struct net_bridge_port *p,\n\t\t\t\t      unsigned long v)\n{\n\treturn br_multicast_set_port_router(&p->multicast_ctx, v);\n}\nstatic BRPORT_ATTR(multicast_router, 0644, show_multicast_router,\n\t\t   store_multicast_router);\n\nBRPORT_ATTR_FLAG(multicast_fast_leave, BR_MULTICAST_FAST_LEAVE);\nBRPORT_ATTR_FLAG(multicast_to_unicast, BR_MULTICAST_TO_UNICAST);\n#endif\n\nstatic const struct brport_attribute *brport_attrs[] = {\n\t&brport_attr_path_cost,\n\t&brport_attr_priority,\n\t&brport_attr_port_id,\n\t&brport_attr_port_no,\n\t&brport_attr_designated_root,\n\t&brport_attr_designated_bridge,\n\t&brport_attr_designated_port,\n\t&brport_attr_designated_cost,\n\t&brport_attr_state,\n\t&brport_attr_change_ack,\n\t&brport_attr_config_pending,\n\t&brport_attr_message_age_timer,\n\t&brport_attr_forward_delay_timer,\n\t&brport_attr_hold_timer,\n\t&brport_attr_flush,\n\t&brport_attr_hairpin_mode,\n\t&brport_attr_bpdu_guard,\n\t&brport_attr_root_block,\n\t&brport_attr_learning,\n\t&brport_attr_unicast_flood,\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\t&brport_attr_multicast_router,\n\t&brport_attr_multicast_fast_leave,\n\t&brport_attr_multicast_to_unicast,\n#endif\n\t&brport_attr_proxyarp,\n\t&brport_attr_proxyarp_wifi,\n\t&brport_attr_multicast_flood,\n\t&brport_attr_broadcast_flood,\n\t&brport_attr_group_fwd_mask,\n\t&brport_attr_neigh_suppress,\n\t&brport_attr_isolated,\n\t&brport_attr_backup_port,\n\tNULL\n};\n\n#define to_brport_attr(_at) container_of(_at, struct brport_attribute, attr)\n\nstatic ssize_t brport_show(struct kobject *kobj,\n\t\t\t   struct attribute *attr, char *buf)\n{\n\tstruct brport_attribute *brport_attr = to_brport_attr(attr);\n\tstruct net_bridge_port *p = kobj_to_brport(kobj);\n\n\tif (!brport_attr->show)\n\t\treturn -EINVAL;\n\n\treturn brport_attr->show(p, buf);\n}\n\nstatic ssize_t brport_store(struct kobject *kobj,\n\t\t\t    struct attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct brport_attribute *brport_attr = to_brport_attr(attr);\n\tstruct net_bridge_port *p = kobj_to_brport(kobj);\n\tssize_t ret = -EINVAL;\n\tunsigned long val;\n\tchar *endp;\n\n\tif (!ns_capable(dev_net(p->dev)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tif (brport_attr->store_raw) {\n\t\tchar *buf_copy;\n\n\t\tbuf_copy = kstrndup(buf, count, GFP_KERNEL);\n\t\tif (!buf_copy) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tspin_lock_bh(&p->br->lock);\n\t\tret = brport_attr->store_raw(p, buf_copy);\n\t\tspin_unlock_bh(&p->br->lock);\n\t\tkfree(buf_copy);\n\t} else if (brport_attr->store) {\n\t\tval = simple_strtoul(buf, &endp, 0);\n\t\tif (endp == buf)\n\t\t\tgoto out_unlock;\n\t\tspin_lock_bh(&p->br->lock);\n\t\tret = brport_attr->store(p, val);\n\t\tspin_unlock_bh(&p->br->lock);\n\t}\n\n\tif (!ret) {\n\t\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\t\tret = count;\n\t}\nout_unlock:\n\trtnl_unlock();\n\n\treturn ret;\n}\n\nconst struct sysfs_ops brport_sysfs_ops = {\n\t.show = brport_show,\n\t.store = brport_store,\n};\n\n \nint br_sysfs_addif(struct net_bridge_port *p)\n{\n\tstruct net_bridge *br = p->br;\n\tconst struct brport_attribute **a;\n\tint err;\n\n\terr = sysfs_create_link(&p->kobj, &br->dev->dev.kobj,\n\t\t\t\tSYSFS_BRIDGE_PORT_LINK);\n\tif (err)\n\t\treturn err;\n\n\tfor (a = brport_attrs; *a; ++a) {\n\t\terr = sysfs_create_file(&p->kobj, &((*a)->attr));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tstrscpy(p->sysfs_name, p->dev->name, IFNAMSIZ);\n\treturn sysfs_create_link(br->ifobj, &p->kobj, p->sysfs_name);\n}\n\n \nint br_sysfs_renameif(struct net_bridge_port *p)\n{\n\tstruct net_bridge *br = p->br;\n\tint err;\n\n\t \n\tif (!strncmp(p->sysfs_name, p->dev->name, IFNAMSIZ))\n\t\treturn 0;\n\n\terr = sysfs_rename_link(br->ifobj, &p->kobj,\n\t\t\t\tp->sysfs_name, p->dev->name);\n\tif (err)\n\t\tnetdev_notice(br->dev, \"unable to rename link %s to %s\",\n\t\t\t      p->sysfs_name, p->dev->name);\n\telse\n\t\tstrscpy(p->sysfs_name, p->dev->name, IFNAMSIZ);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}