{
  "module_name": "br_stp_timer.c",
  "hash_id": "aafa263b882d58632892ded5c73cfa1c7e51e23ae2d8fdb94ce7287004e661dc",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_stp_timer.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/times.h>\n\n#include \"br_private.h\"\n#include \"br_private_stp.h\"\n\n \nstatic int br_is_designated_for_some_port(const struct net_bridge *br)\n{\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->state != BR_STATE_DISABLED &&\n\t\t    !memcmp(&p->designated_bridge, &br->bridge_id, 8))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void br_hello_timer_expired(struct timer_list *t)\n{\n\tstruct net_bridge *br = from_timer(br, t, hello_timer);\n\n\tbr_debug(br, \"hello timer expired\\n\");\n\tspin_lock(&br->lock);\n\tif (br->dev->flags & IFF_UP) {\n\t\tbr_config_bpdu_generation(br);\n\n\t\tif (br->stp_enabled == BR_KERNEL_STP)\n\t\t\tmod_timer(&br->hello_timer,\n\t\t\t\t  round_jiffies(jiffies + br->hello_time));\n\t}\n\tspin_unlock(&br->lock);\n}\n\nstatic void br_message_age_timer_expired(struct timer_list *t)\n{\n\tstruct net_bridge_port *p = from_timer(p, t, message_age_timer);\n\tstruct net_bridge *br = p->br;\n\tconst bridge_id *id = &p->designated_bridge;\n\tint was_root;\n\n\tif (p->state == BR_STATE_DISABLED)\n\t\treturn;\n\n\tbr_info(br, \"port %u(%s) neighbor %.2x%.2x.%pM lost\\n\",\n\t\t(unsigned int) p->port_no, p->dev->name,\n\t\tid->prio[0], id->prio[1], &id->addr);\n\n\t \n\tspin_lock(&br->lock);\n\tif (p->state == BR_STATE_DISABLED)\n\t\tgoto unlock;\n\twas_root = br_is_root_bridge(br);\n\n\tbr_become_designated_port(p);\n\tbr_configuration_update(br);\n\tbr_port_state_selection(br);\n\tif (br_is_root_bridge(br) && !was_root)\n\t\tbr_become_root_bridge(br);\n unlock:\n\tspin_unlock(&br->lock);\n}\n\nstatic void br_forward_delay_timer_expired(struct timer_list *t)\n{\n\tstruct net_bridge_port *p = from_timer(p, t, forward_delay_timer);\n\tstruct net_bridge *br = p->br;\n\n\tbr_debug(br, \"port %u(%s) forward delay timer\\n\",\n\t\t (unsigned int) p->port_no, p->dev->name);\n\tspin_lock(&br->lock);\n\tif (p->state == BR_STATE_LISTENING) {\n\t\tbr_set_state(p, BR_STATE_LEARNING);\n\t\tmod_timer(&p->forward_delay_timer,\n\t\t\t  jiffies + br->forward_delay);\n\t} else if (p->state == BR_STATE_LEARNING) {\n\t\tbr_set_state(p, BR_STATE_FORWARDING);\n\t\tif (br_is_designated_for_some_port(br))\n\t\t\tbr_topology_change_detection(br);\n\t\tnetif_carrier_on(br->dev);\n\t}\n\trcu_read_lock();\n\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\trcu_read_unlock();\n\tspin_unlock(&br->lock);\n}\n\nstatic void br_tcn_timer_expired(struct timer_list *t)\n{\n\tstruct net_bridge *br = from_timer(br, t, tcn_timer);\n\n\tbr_debug(br, \"tcn timer expired\\n\");\n\tspin_lock(&br->lock);\n\tif (!br_is_root_bridge(br) && (br->dev->flags & IFF_UP)) {\n\t\tbr_transmit_tcn(br);\n\n\t\tmod_timer(&br->tcn_timer, jiffies + br->bridge_hello_time);\n\t}\n\tspin_unlock(&br->lock);\n}\n\nstatic void br_topology_change_timer_expired(struct timer_list *t)\n{\n\tstruct net_bridge *br = from_timer(br, t, topology_change_timer);\n\n\tbr_debug(br, \"topo change timer expired\\n\");\n\tspin_lock(&br->lock);\n\tbr->topology_change_detected = 0;\n\t__br_set_topology_change(br, 0);\n\tspin_unlock(&br->lock);\n}\n\nstatic void br_hold_timer_expired(struct timer_list *t)\n{\n\tstruct net_bridge_port *p = from_timer(p, t, hold_timer);\n\n\tbr_debug(p->br, \"port %u(%s) hold timer expired\\n\",\n\t\t (unsigned int) p->port_no, p->dev->name);\n\n\tspin_lock(&p->br->lock);\n\tif (p->config_pending)\n\t\tbr_transmit_config(p);\n\tspin_unlock(&p->br->lock);\n}\n\nvoid br_stp_timer_init(struct net_bridge *br)\n{\n\ttimer_setup(&br->hello_timer, br_hello_timer_expired, 0);\n\ttimer_setup(&br->tcn_timer, br_tcn_timer_expired, 0);\n\ttimer_setup(&br->topology_change_timer,\n\t\t    br_topology_change_timer_expired, 0);\n}\n\nvoid br_stp_port_timer_init(struct net_bridge_port *p)\n{\n\ttimer_setup(&p->message_age_timer, br_message_age_timer_expired, 0);\n\ttimer_setup(&p->forward_delay_timer, br_forward_delay_timer_expired, 0);\n\ttimer_setup(&p->hold_timer, br_hold_timer_expired, 0);\n}\n\n \nunsigned long br_timer_value(const struct timer_list *timer)\n{\n\treturn timer_pending(timer)\n\t\t? jiffies_delta_to_clock_t(timer->expires - jiffies) : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}