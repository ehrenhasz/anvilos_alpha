{
  "module_name": "br_switchdev.c",
  "hash_id": "29163765c09fef3ee0609d6c826b545f0c982e751e827bd55a631925a3fb1275",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_switchdev.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <net/ip.h>\n#include <net/switchdev.h>\n\n#include \"br_private.h\"\n\nstatic struct static_key_false br_switchdev_tx_fwd_offload;\n\nstatic bool nbp_switchdev_can_offload_tx_fwd(const struct net_bridge_port *p,\n\t\t\t\t\t     const struct sk_buff *skb)\n{\n\tif (!static_branch_unlikely(&br_switchdev_tx_fwd_offload))\n\t\treturn false;\n\n\treturn (p->flags & BR_TX_FWD_OFFLOAD) &&\n\t       (p->hwdom != BR_INPUT_SKB_CB(skb)->src_hwdom);\n}\n\nbool br_switchdev_frame_uses_tx_fwd_offload(struct sk_buff *skb)\n{\n\tif (!static_branch_unlikely(&br_switchdev_tx_fwd_offload))\n\t\treturn false;\n\n\treturn BR_INPUT_SKB_CB(skb)->tx_fwd_offload;\n}\n\nvoid br_switchdev_frame_set_offload_fwd_mark(struct sk_buff *skb)\n{\n\tskb->offload_fwd_mark = br_switchdev_frame_uses_tx_fwd_offload(skb);\n}\n\n \nvoid nbp_switchdev_frame_mark_tx_fwd_offload(const struct net_bridge_port *p,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tif (nbp_switchdev_can_offload_tx_fwd(p, skb))\n\t\tBR_INPUT_SKB_CB(skb)->tx_fwd_offload = true;\n}\n\n \nvoid nbp_switchdev_frame_mark_tx_fwd_to_hwdom(const struct net_bridge_port *p,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tif (nbp_switchdev_can_offload_tx_fwd(p, skb))\n\t\tset_bit(p->hwdom, &BR_INPUT_SKB_CB(skb)->fwd_hwdoms);\n}\n\nvoid nbp_switchdev_frame_mark(const struct net_bridge_port *p,\n\t\t\t      struct sk_buff *skb)\n{\n\tif (p->hwdom)\n\t\tBR_INPUT_SKB_CB(skb)->src_hwdom = p->hwdom;\n}\n\nbool nbp_switchdev_allowed_egress(const struct net_bridge_port *p,\n\t\t\t\t  const struct sk_buff *skb)\n{\n\tstruct br_input_skb_cb *cb = BR_INPUT_SKB_CB(skb);\n\n\treturn !test_bit(p->hwdom, &cb->fwd_hwdoms) &&\n\t\t(!skb->offload_fwd_mark || cb->src_hwdom != p->hwdom);\n}\n\n \n#define BR_PORT_FLAGS_HW_OFFLOAD (BR_LEARNING | BR_FLOOD | BR_PORT_MAB | \\\n\t\t\t\t  BR_MCAST_FLOOD | BR_BCAST_FLOOD | BR_PORT_LOCKED | \\\n\t\t\t\t  BR_HAIRPIN_MODE | BR_ISOLATED | BR_MULTICAST_TO_UNICAST)\n\nint br_switchdev_set_port_flag(struct net_bridge_port *p,\n\t\t\t       unsigned long flags,\n\t\t\t       unsigned long mask,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_attr attr = {\n\t\t.orig_dev = p->dev,\n\t};\n\tstruct switchdev_notifier_port_attr_info info = {\n\t\t.attr = &attr,\n\t};\n\tint err;\n\n\tmask &= BR_PORT_FLAGS_HW_OFFLOAD;\n\tif (!mask)\n\t\treturn 0;\n\n\tattr.id = SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS;\n\tattr.u.brport_flags.val = flags;\n\tattr.u.brport_flags.mask = mask;\n\n\t \n\terr = call_switchdev_notifiers(SWITCHDEV_PORT_ATTR_SET, p->dev,\n\t\t\t\t       &info.info, extack);\n\terr = notifier_to_errno(err);\n\tif (err == -EOPNOTSUPP)\n\t\treturn 0;\n\n\tif (err) {\n\t\tNL_SET_ERR_MSG_WEAK_MOD(extack,\n\t\t\t\t\t\"bridge flag offload is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tattr.id = SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS;\n\tattr.flags = SWITCHDEV_F_DEFER;\n\n\terr = switchdev_port_attr_set(p->dev, &attr, extack);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_WEAK_MOD(extack,\n\t\t\t\t\t\"error setting offload flag on port\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void br_switchdev_fdb_populate(struct net_bridge *br,\n\t\t\t\t      struct switchdev_notifier_fdb_info *item,\n\t\t\t\t      const struct net_bridge_fdb_entry *fdb,\n\t\t\t\t      const void *ctx)\n{\n\tconst struct net_bridge_port *p = READ_ONCE(fdb->dst);\n\n\titem->addr = fdb->key.addr.addr;\n\titem->vid = fdb->key.vlan_id;\n\titem->added_by_user = test_bit(BR_FDB_ADDED_BY_USER, &fdb->flags);\n\titem->offloaded = test_bit(BR_FDB_OFFLOADED, &fdb->flags);\n\titem->is_local = test_bit(BR_FDB_LOCAL, &fdb->flags);\n\titem->locked = false;\n\titem->info.dev = (!p || item->is_local) ? br->dev : p->dev;\n\titem->info.ctx = ctx;\n}\n\nvoid\nbr_switchdev_fdb_notify(struct net_bridge *br,\n\t\t\tconst struct net_bridge_fdb_entry *fdb, int type)\n{\n\tstruct switchdev_notifier_fdb_info item;\n\n\tif (test_bit(BR_FDB_LOCKED, &fdb->flags))\n\t\treturn;\n\n\t \n\tif (test_bit(BR_FDB_ADDED_BY_USER, &fdb->flags) &&\n\t    !test_bit(BR_FDB_STATIC, &fdb->flags) &&\n\t    !test_bit(BR_FDB_ADDED_BY_EXT_LEARN, &fdb->flags))\n\t\treturn;\n\n\tbr_switchdev_fdb_populate(br, &item, fdb, NULL);\n\n\tswitch (type) {\n\tcase RTM_DELNEIGH:\n\t\tcall_switchdev_notifiers(SWITCHDEV_FDB_DEL_TO_DEVICE,\n\t\t\t\t\t item.info.dev, &item.info, NULL);\n\t\tbreak;\n\tcase RTM_NEWNEIGH:\n\t\tcall_switchdev_notifiers(SWITCHDEV_FDB_ADD_TO_DEVICE,\n\t\t\t\t\t item.info.dev, &item.info, NULL);\n\t\tbreak;\n\t}\n}\n\nint br_switchdev_port_vlan_add(struct net_device *dev, u16 vid, u16 flags,\n\t\t\t       bool changed, struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_obj_port_vlan v = {\n\t\t.obj.orig_dev = dev,\n\t\t.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\n\t\t.flags = flags,\n\t\t.vid = vid,\n\t\t.changed = changed,\n\t};\n\n\treturn switchdev_port_obj_add(dev, &v.obj, extack);\n}\n\nint br_switchdev_port_vlan_del(struct net_device *dev, u16 vid)\n{\n\tstruct switchdev_obj_port_vlan v = {\n\t\t.obj.orig_dev = dev,\n\t\t.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\n\t\t.vid = vid,\n\t};\n\n\treturn switchdev_port_obj_del(dev, &v.obj);\n}\n\nstatic int nbp_switchdev_hwdom_set(struct net_bridge_port *joining)\n{\n\tstruct net_bridge *br = joining->br;\n\tstruct net_bridge_port *p;\n\tint hwdom;\n\n\t \n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (netdev_phys_item_id_same(&joining->ppid, &p->ppid)) {\n\t\t\tjoining->hwdom = p->hwdom;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\thwdom = find_next_zero_bit(&br->busy_hwdoms, BR_HWDOM_MAX, 1);\n\tif (hwdom >= BR_HWDOM_MAX)\n\t\treturn -EBUSY;\n\n\tset_bit(hwdom, &br->busy_hwdoms);\n\tjoining->hwdom = hwdom;\n\treturn 0;\n}\n\nstatic void nbp_switchdev_hwdom_put(struct net_bridge_port *leaving)\n{\n\tstruct net_bridge *br = leaving->br;\n\tstruct net_bridge_port *p;\n\n\t \n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->hwdom == leaving->hwdom)\n\t\t\treturn;\n\t}\n\n\tclear_bit(leaving->hwdom, &br->busy_hwdoms);\n}\n\nstatic int nbp_switchdev_add(struct net_bridge_port *p,\n\t\t\t     struct netdev_phys_item_id ppid,\n\t\t\t     bool tx_fwd_offload,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tif (p->offload_count) {\n\t\t \n\t\tif (!netdev_phys_item_id_same(&p->ppid, &ppid)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Same bridge port cannot be offloaded by two physical switches\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\tp->offload_count++;\n\n\t\treturn 0;\n\t}\n\n\tp->ppid = ppid;\n\tp->offload_count = 1;\n\n\terr = nbp_switchdev_hwdom_set(p);\n\tif (err)\n\t\treturn err;\n\n\tif (tx_fwd_offload) {\n\t\tp->flags |= BR_TX_FWD_OFFLOAD;\n\t\tstatic_branch_inc(&br_switchdev_tx_fwd_offload);\n\t}\n\n\treturn 0;\n}\n\nstatic void nbp_switchdev_del(struct net_bridge_port *p)\n{\n\tif (WARN_ON(!p->offload_count))\n\t\treturn;\n\n\tp->offload_count--;\n\n\tif (p->offload_count)\n\t\treturn;\n\n\tif (p->hwdom)\n\t\tnbp_switchdev_hwdom_put(p);\n\n\tif (p->flags & BR_TX_FWD_OFFLOAD) {\n\t\tp->flags &= ~BR_TX_FWD_OFFLOAD;\n\t\tstatic_branch_dec(&br_switchdev_tx_fwd_offload);\n\t}\n}\n\nstatic int\nbr_switchdev_fdb_replay_one(struct net_bridge *br, struct notifier_block *nb,\n\t\t\t    const struct net_bridge_fdb_entry *fdb,\n\t\t\t    unsigned long action, const void *ctx)\n{\n\tstruct switchdev_notifier_fdb_info item;\n\tint err;\n\n\tbr_switchdev_fdb_populate(br, &item, fdb, ctx);\n\n\terr = nb->notifier_call(nb, action, &item);\n\treturn notifier_to_errno(err);\n}\n\nstatic int\nbr_switchdev_fdb_replay(const struct net_device *br_dev, const void *ctx,\n\t\t\tbool adding, struct notifier_block *nb)\n{\n\tstruct net_bridge_fdb_entry *fdb;\n\tstruct net_bridge *br;\n\tunsigned long action;\n\tint err = 0;\n\n\tif (!nb)\n\t\treturn 0;\n\n\tif (!netif_is_bridge_master(br_dev))\n\t\treturn -EINVAL;\n\n\tbr = netdev_priv(br_dev);\n\n\tif (adding)\n\t\taction = SWITCHDEV_FDB_ADD_TO_DEVICE;\n\telse\n\t\taction = SWITCHDEV_FDB_DEL_TO_DEVICE;\n\n\trcu_read_lock();\n\n\thlist_for_each_entry_rcu(fdb, &br->fdb_list, fdb_node) {\n\t\terr = br_switchdev_fdb_replay_one(br, nb, fdb, action, ctx);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic int br_switchdev_vlan_attr_replay(struct net_device *br_dev,\n\t\t\t\t\t const void *ctx,\n\t\t\t\t\t struct notifier_block *nb,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_notifier_port_attr_info attr_info = {\n\t\t.info = {\n\t\t\t.dev = br_dev,\n\t\t\t.extack = extack,\n\t\t\t.ctx = ctx,\n\t\t},\n\t};\n\tstruct net_bridge *br = netdev_priv(br_dev);\n\tstruct net_bridge_vlan_group *vg;\n\tstruct switchdev_attr attr;\n\tstruct net_bridge_vlan *v;\n\tint err;\n\n\tattr_info.attr = &attr;\n\tattr.orig_dev = br_dev;\n\n\tvg = br_vlan_group(br);\n\tif (!vg)\n\t\treturn 0;\n\n\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\tif (v->msti) {\n\t\t\tattr.id = SWITCHDEV_ATTR_ID_VLAN_MSTI;\n\t\t\tattr.u.vlan_msti.vid = v->vid;\n\t\t\tattr.u.vlan_msti.msti = v->msti;\n\n\t\t\terr = nb->notifier_call(nb, SWITCHDEV_PORT_ATTR_SET,\n\t\t\t\t\t\t&attr_info);\n\t\t\terr = notifier_to_errno(err);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbr_switchdev_vlan_replay_one(struct notifier_block *nb,\n\t\t\t     struct net_device *dev,\n\t\t\t     struct switchdev_obj_port_vlan *vlan,\n\t\t\t     const void *ctx, unsigned long action,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_notifier_port_obj_info obj_info = {\n\t\t.info = {\n\t\t\t.dev = dev,\n\t\t\t.extack = extack,\n\t\t\t.ctx = ctx,\n\t\t},\n\t\t.obj = &vlan->obj,\n\t};\n\tint err;\n\n\terr = nb->notifier_call(nb, action, &obj_info);\n\treturn notifier_to_errno(err);\n}\n\nstatic int br_switchdev_vlan_replay_group(struct notifier_block *nb,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  struct net_bridge_vlan_group *vg,\n\t\t\t\t\t  const void *ctx, unsigned long action,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan *v;\n\tint err = 0;\n\tu16 pvid;\n\n\tif (!vg)\n\t\treturn 0;\n\n\tpvid = br_get_pvid(vg);\n\n\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\tstruct switchdev_obj_port_vlan vlan = {\n\t\t\t.obj.orig_dev = dev,\n\t\t\t.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\n\t\t\t.flags = br_vlan_flags(v, pvid),\n\t\t\t.vid = v->vid,\n\t\t};\n\n\t\tif (!br_vlan_should_use(v))\n\t\t\tcontinue;\n\n\t\terr = br_switchdev_vlan_replay_one(nb, dev, &vlan, ctx,\n\t\t\t\t\t\t   action, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int br_switchdev_vlan_replay(struct net_device *br_dev,\n\t\t\t\t    const void *ctx, bool adding,\n\t\t\t\t    struct notifier_block *nb,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge *br = netdev_priv(br_dev);\n\tstruct net_bridge_port *p;\n\tunsigned long action;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tif (!nb)\n\t\treturn 0;\n\n\tif (!netif_is_bridge_master(br_dev))\n\t\treturn -EINVAL;\n\n\tif (adding)\n\t\taction = SWITCHDEV_PORT_OBJ_ADD;\n\telse\n\t\taction = SWITCHDEV_PORT_OBJ_DEL;\n\n\terr = br_switchdev_vlan_replay_group(nb, br_dev, br_vlan_group(br),\n\t\t\t\t\t     ctx, action, extack);\n\tif (err)\n\t\treturn err;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tstruct net_device *dev = p->dev;\n\n\t\terr = br_switchdev_vlan_replay_group(nb, dev,\n\t\t\t\t\t\t     nbp_vlan_group(p),\n\t\t\t\t\t\t     ctx, action, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (adding) {\n\t\terr = br_switchdev_vlan_attr_replay(br_dev, ctx, nb, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\nstruct br_switchdev_mdb_complete_info {\n\tstruct net_bridge_port *port;\n\tstruct br_ip ip;\n};\n\nstatic void br_switchdev_mdb_complete(struct net_device *dev, int err, void *priv)\n{\n\tstruct br_switchdev_mdb_complete_info *data = priv;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port *port = data->port;\n\tstruct net_bridge *br = port->br;\n\n\tif (err)\n\t\tgoto err;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmp = br_mdb_ip_get(br, &data->ip);\n\tif (!mp)\n\t\tgoto out;\n\tfor (pp = &mp->ports; (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->key.port != port)\n\t\t\tcontinue;\n\t\tp->flags |= MDB_PG_FLAGS_OFFLOAD;\n\t}\nout:\n\tspin_unlock_bh(&br->multicast_lock);\nerr:\n\tkfree(priv);\n}\n\nstatic void br_switchdev_mdb_populate(struct switchdev_obj_port_mdb *mdb,\n\t\t\t\t      const struct net_bridge_mdb_entry *mp)\n{\n\tif (mp->addr.proto == htons(ETH_P_IP))\n\t\tip_eth_mc_map(mp->addr.dst.ip4, mdb->addr);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (mp->addr.proto == htons(ETH_P_IPV6))\n\t\tipv6_eth_mc_map(&mp->addr.dst.ip6, mdb->addr);\n#endif\n\telse\n\t\tether_addr_copy(mdb->addr, mp->addr.dst.mac_addr);\n\n\tmdb->vid = mp->addr.vid;\n}\n\nstatic void br_switchdev_host_mdb_one(struct net_device *dev,\n\t\t\t\t      struct net_device *lower_dev,\n\t\t\t\t      struct net_bridge_mdb_entry *mp,\n\t\t\t\t      int type)\n{\n\tstruct switchdev_obj_port_mdb mdb = {\n\t\t.obj = {\n\t\t\t.id = SWITCHDEV_OBJ_ID_HOST_MDB,\n\t\t\t.flags = SWITCHDEV_F_DEFER,\n\t\t\t.orig_dev = dev,\n\t\t},\n\t};\n\n\tbr_switchdev_mdb_populate(&mdb, mp);\n\n\tswitch (type) {\n\tcase RTM_NEWMDB:\n\t\tswitchdev_port_obj_add(lower_dev, &mdb.obj, NULL);\n\t\tbreak;\n\tcase RTM_DELMDB:\n\t\tswitchdev_port_obj_del(lower_dev, &mdb.obj);\n\t\tbreak;\n\t}\n}\n\nstatic void br_switchdev_host_mdb(struct net_device *dev,\n\t\t\t\t  struct net_bridge_mdb_entry *mp, int type)\n{\n\tstruct net_device *lower_dev;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_lower_dev(dev, lower_dev, iter)\n\t\tbr_switchdev_host_mdb_one(dev, lower_dev, mp, type);\n}\n\nstatic int\nbr_switchdev_mdb_replay_one(struct notifier_block *nb, struct net_device *dev,\n\t\t\t    const struct switchdev_obj_port_mdb *mdb,\n\t\t\t    unsigned long action, const void *ctx,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_notifier_port_obj_info obj_info = {\n\t\t.info = {\n\t\t\t.dev = dev,\n\t\t\t.extack = extack,\n\t\t\t.ctx = ctx,\n\t\t},\n\t\t.obj = &mdb->obj,\n\t};\n\tint err;\n\n\terr = nb->notifier_call(nb, action, &obj_info);\n\treturn notifier_to_errno(err);\n}\n\nstatic int br_switchdev_mdb_queue_one(struct list_head *mdb_list,\n\t\t\t\t      enum switchdev_obj_id id,\n\t\t\t\t      const struct net_bridge_mdb_entry *mp,\n\t\t\t\t      struct net_device *orig_dev)\n{\n\tstruct switchdev_obj_port_mdb *mdb;\n\n\tmdb = kzalloc(sizeof(*mdb), GFP_ATOMIC);\n\tif (!mdb)\n\t\treturn -ENOMEM;\n\n\tmdb->obj.id = id;\n\tmdb->obj.orig_dev = orig_dev;\n\tbr_switchdev_mdb_populate(mdb, mp);\n\tlist_add_tail(&mdb->obj.list, mdb_list);\n\n\treturn 0;\n}\n\nvoid br_switchdev_mdb_notify(struct net_device *dev,\n\t\t\t     struct net_bridge_mdb_entry *mp,\n\t\t\t     struct net_bridge_port_group *pg,\n\t\t\t     int type)\n{\n\tstruct br_switchdev_mdb_complete_info *complete_info;\n\tstruct switchdev_obj_port_mdb mdb = {\n\t\t.obj = {\n\t\t\t.id = SWITCHDEV_OBJ_ID_PORT_MDB,\n\t\t\t.flags = SWITCHDEV_F_DEFER,\n\t\t},\n\t};\n\n\tif (!pg)\n\t\treturn br_switchdev_host_mdb(dev, mp, type);\n\n\tbr_switchdev_mdb_populate(&mdb, mp);\n\n\tmdb.obj.orig_dev = pg->key.port->dev;\n\tswitch (type) {\n\tcase RTM_NEWMDB:\n\t\tcomplete_info = kmalloc(sizeof(*complete_info), GFP_ATOMIC);\n\t\tif (!complete_info)\n\t\t\tbreak;\n\t\tcomplete_info->port = pg->key.port;\n\t\tcomplete_info->ip = mp->addr;\n\t\tmdb.obj.complete_priv = complete_info;\n\t\tmdb.obj.complete = br_switchdev_mdb_complete;\n\t\tif (switchdev_port_obj_add(pg->key.port->dev, &mdb.obj, NULL))\n\t\t\tkfree(complete_info);\n\t\tbreak;\n\tcase RTM_DELMDB:\n\t\tswitchdev_port_obj_del(pg->key.port->dev, &mdb.obj);\n\t\tbreak;\n\t}\n}\n#endif\n\nstatic int\nbr_switchdev_mdb_replay(struct net_device *br_dev, struct net_device *dev,\n\t\t\tconst void *ctx, bool adding, struct notifier_block *nb,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\n\tconst struct net_bridge_mdb_entry *mp;\n\tstruct switchdev_obj *obj, *tmp;\n\tstruct net_bridge *br;\n\tunsigned long action;\n\tLIST_HEAD(mdb_list);\n\tint err = 0;\n\n\tASSERT_RTNL();\n\n\tif (!nb)\n\t\treturn 0;\n\n\tif (!netif_is_bridge_master(br_dev) || !netif_is_bridge_port(dev))\n\t\treturn -EINVAL;\n\n\tbr = netdev_priv(br_dev);\n\n\tif (!br_opt_get(br, BROPT_MULTICAST_ENABLED))\n\t\treturn 0;\n\n\t \n\trcu_read_lock();\n\n\thlist_for_each_entry_rcu(mp, &br->mdb_list, mdb_node) {\n\t\tstruct net_bridge_port_group __rcu * const *pp;\n\t\tconst struct net_bridge_port_group *p;\n\n\t\tif (mp->host_joined) {\n\t\t\terr = br_switchdev_mdb_queue_one(&mdb_list,\n\t\t\t\t\t\t\t SWITCHDEV_OBJ_ID_HOST_MDB,\n\t\t\t\t\t\t\t mp, br_dev);\n\t\t\tif (err) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out_free_mdb;\n\t\t\t}\n\t\t}\n\n\t\tfor (pp = &mp->ports; (p = rcu_dereference(*pp)) != NULL;\n\t\t     pp = &p->next) {\n\t\t\tif (p->key.port->dev != dev)\n\t\t\t\tcontinue;\n\n\t\t\terr = br_switchdev_mdb_queue_one(&mdb_list,\n\t\t\t\t\t\t\t SWITCHDEV_OBJ_ID_PORT_MDB,\n\t\t\t\t\t\t\t mp, dev);\n\t\t\tif (err) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out_free_mdb;\n\t\t\t}\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (adding)\n\t\taction = SWITCHDEV_PORT_OBJ_ADD;\n\telse\n\t\taction = SWITCHDEV_PORT_OBJ_DEL;\n\n\tlist_for_each_entry(obj, &mdb_list, list) {\n\t\terr = br_switchdev_mdb_replay_one(nb, dev,\n\t\t\t\t\t\t  SWITCHDEV_OBJ_PORT_MDB(obj),\n\t\t\t\t\t\t  action, ctx, extack);\n\t\tif (err == -EOPNOTSUPP)\n\t\t\terr = 0;\n\t\tif (err)\n\t\t\tgoto out_free_mdb;\n\t}\n\nout_free_mdb:\n\tlist_for_each_entry_safe(obj, tmp, &mdb_list, list) {\n\t\tlist_del(&obj->list);\n\t\tkfree(SWITCHDEV_OBJ_PORT_MDB(obj));\n\t}\n\n\tif (err)\n\t\treturn err;\n#endif\n\n\treturn 0;\n}\n\nstatic int nbp_switchdev_sync_objs(struct net_bridge_port *p, const void *ctx,\n\t\t\t\t   struct notifier_block *atomic_nb,\n\t\t\t\t   struct notifier_block *blocking_nb,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_device *br_dev = p->br->dev;\n\tstruct net_device *dev = p->dev;\n\tint err;\n\n\terr = br_switchdev_vlan_replay(br_dev, ctx, true, blocking_nb, extack);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\terr = br_switchdev_mdb_replay(br_dev, dev, ctx, true, blocking_nb,\n\t\t\t\t      extack);\n\tif (err) {\n\t\t \n\t\treturn err;\n\t}\n\n\terr = br_switchdev_fdb_replay(br_dev, ctx, true, atomic_nb);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void nbp_switchdev_unsync_objs(struct net_bridge_port *p,\n\t\t\t\t      const void *ctx,\n\t\t\t\t      struct notifier_block *atomic_nb,\n\t\t\t\t      struct notifier_block *blocking_nb)\n{\n\tstruct net_device *br_dev = p->br->dev;\n\tstruct net_device *dev = p->dev;\n\n\tbr_switchdev_fdb_replay(br_dev, ctx, false, atomic_nb);\n\n\tbr_switchdev_mdb_replay(br_dev, dev, ctx, false, blocking_nb, NULL);\n\n\tbr_switchdev_vlan_replay(br_dev, ctx, false, blocking_nb, NULL);\n}\n\n \nint br_switchdev_port_offload(struct net_bridge_port *p,\n\t\t\t      struct net_device *dev, const void *ctx,\n\t\t\t      struct notifier_block *atomic_nb,\n\t\t\t      struct notifier_block *blocking_nb,\n\t\t\t      bool tx_fwd_offload,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct netdev_phys_item_id ppid;\n\tint err;\n\n\terr = dev_get_port_parent_id(dev, &ppid, false);\n\tif (err)\n\t\treturn err;\n\n\terr = nbp_switchdev_add(p, ppid, tx_fwd_offload, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = nbp_switchdev_sync_objs(p, ctx, atomic_nb, blocking_nb, extack);\n\tif (err)\n\t\tgoto out_switchdev_del;\n\n\treturn 0;\n\nout_switchdev_del:\n\tnbp_switchdev_del(p);\n\n\treturn err;\n}\n\nvoid br_switchdev_port_unoffload(struct net_bridge_port *p, const void *ctx,\n\t\t\t\t struct notifier_block *atomic_nb,\n\t\t\t\t struct notifier_block *blocking_nb)\n{\n\tnbp_switchdev_unsync_objs(p, ctx, atomic_nb, blocking_nb);\n\n\tnbp_switchdev_del(p);\n}\n\nint br_switchdev_port_replay(struct net_bridge_port *p,\n\t\t\t     struct net_device *dev, const void *ctx,\n\t\t\t     struct notifier_block *atomic_nb,\n\t\t\t     struct notifier_block *blocking_nb,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn nbp_switchdev_sync_objs(p, ctx, atomic_nb, blocking_nb, extack);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}