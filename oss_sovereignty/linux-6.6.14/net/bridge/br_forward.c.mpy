{
  "module_name": "br_forward.c",
  "hash_id": "4d05693394e94ec2f4ddff06eb8e8e57a6cf76fa24ae5d117a377d6e42ad5c29",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_forward.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/netpoll.h>\n#include <linux/skbuff.h>\n#include <linux/if_vlan.h>\n#include <linux/netfilter_bridge.h>\n#include \"br_private.h\"\n\n \nstatic inline int should_deliver(const struct net_bridge_port *p,\n\t\t\t\t const struct sk_buff *skb)\n{\n\tstruct net_bridge_vlan_group *vg;\n\n\tvg = nbp_vlan_group_rcu(p);\n\treturn ((p->flags & BR_HAIRPIN_MODE) || skb->dev != p->dev) &&\n\t\tp->state == BR_STATE_FORWARDING && br_allowed_egress(vg, skb) &&\n\t\tnbp_switchdev_allowed_egress(p, skb) &&\n\t\t!br_skb_isolated(p, skb);\n}\n\nint br_dev_queue_push_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tskb_push(skb, ETH_HLEN);\n\tif (!is_skb_forwardable(skb->dev, skb))\n\t\tgoto drop;\n\n\tbr_drop_fake_rtable(skb);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    eth_type_vlan(skb->protocol)) {\n\t\tint depth;\n\n\t\tif (!vlan_get_protocol_and_depth(skb, skb->protocol, &depth))\n\t\t\tgoto drop;\n\n\t\tskb_set_network_header(skb, depth);\n\t}\n\n\tbr_switchdev_frame_set_offload_fwd_mark(skb);\n\n\tdev_queue_xmit(skb);\n\n\treturn 0;\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(br_dev_queue_push_xmit);\n\nint br_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tskb_clear_tstamp(skb);\n\treturn NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,\n\t\t       net, sk, skb, NULL, skb->dev,\n\t\t       br_dev_queue_push_xmit);\n\n}\nEXPORT_SYMBOL_GPL(br_forward_finish);\n\nstatic void __br_forward(const struct net_bridge_port *to,\n\t\t\t struct sk_buff *skb, bool local_orig)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_device *indev;\n\tstruct net *net;\n\tint br_hook;\n\n\t \n\tnbp_switchdev_frame_mark_tx_fwd_offload(to, skb);\n\n\tvg = nbp_vlan_group_rcu(to);\n\tskb = br_handle_vlan(to->br, to, vg, skb);\n\tif (!skb)\n\t\treturn;\n\n\tindev = skb->dev;\n\tskb->dev = to->dev;\n\tif (!local_orig) {\n\t\tif (skb_warn_if_lro(skb)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tbr_hook = NF_BR_FORWARD;\n\t\tskb_forward_csum(skb);\n\t\tnet = dev_net(indev);\n\t} else {\n\t\tif (unlikely(netpoll_tx_running(to->br->dev))) {\n\t\t\tskb_push(skb, ETH_HLEN);\n\t\t\tif (!is_skb_forwardable(skb->dev, skb))\n\t\t\t\tkfree_skb(skb);\n\t\t\telse\n\t\t\t\tbr_netpoll_send_skb(to, skb);\n\t\t\treturn;\n\t\t}\n\t\tbr_hook = NF_BR_LOCAL_OUT;\n\t\tnet = dev_net(skb->dev);\n\t\tindev = NULL;\n\t}\n\n\tNF_HOOK(NFPROTO_BRIDGE, br_hook,\n\t\tnet, NULL, skb, indev, skb->dev,\n\t\tbr_forward_finish);\n}\n\nstatic int deliver_clone(const struct net_bridge_port *prev,\n\t\t\t struct sk_buff *skb, bool local_orig)\n{\n\tstruct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;\n\n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\tDEV_STATS_INC(dev, tx_dropped);\n\t\treturn -ENOMEM;\n\t}\n\n\t__br_forward(prev, skb, local_orig);\n\treturn 0;\n}\n\n \nvoid br_forward(const struct net_bridge_port *to,\n\t\tstruct sk_buff *skb, bool local_rcv, bool local_orig)\n{\n\tif (unlikely(!to))\n\t\tgoto out;\n\n\t \n\tif (rcu_access_pointer(to->backup_port) && !netif_carrier_ok(to->dev)) {\n\t\tstruct net_bridge_port *backup_port;\n\n\t\tbackup_port = rcu_dereference(to->backup_port);\n\t\tif (unlikely(!backup_port))\n\t\t\tgoto out;\n\t\tBR_INPUT_SKB_CB(skb)->backup_nhid = READ_ONCE(to->backup_nhid);\n\t\tto = backup_port;\n\t}\n\n\tif (should_deliver(to, skb)) {\n\t\tif (local_rcv)\n\t\t\tdeliver_clone(to, skb, local_orig);\n\t\telse\n\t\t\t__br_forward(to, skb, local_orig);\n\t\treturn;\n\t}\n\nout:\n\tif (!local_rcv)\n\t\tkfree_skb(skb);\n}\nEXPORT_SYMBOL_GPL(br_forward);\n\nstatic struct net_bridge_port *maybe_deliver(\n\tstruct net_bridge_port *prev, struct net_bridge_port *p,\n\tstruct sk_buff *skb, bool local_orig)\n{\n\tu8 igmp_type = br_multicast_igmp_type(skb);\n\tint err;\n\n\tif (!should_deliver(p, skb))\n\t\treturn prev;\n\n\tnbp_switchdev_frame_mark_tx_fwd_to_hwdom(p, skb);\n\n\tif (!prev)\n\t\tgoto out;\n\n\terr = deliver_clone(prev, skb, local_orig);\n\tif (err)\n\t\treturn ERR_PTR(err);\nout:\n\tbr_multicast_count(p->br, p, skb, igmp_type, BR_MCAST_DIR_TX);\n\n\treturn p;\n}\n\n \nvoid br_flood(struct net_bridge *br, struct sk_buff *skb,\n\t      enum br_pkt_type pkt_type, bool local_rcv, bool local_orig,\n\t      u16 vid)\n{\n\tstruct net_bridge_port *prev = NULL;\n\tstruct net_bridge_port *p;\n\n\tbr_tc_skb_miss_set(skb, pkt_type != BR_PKT_BROADCAST);\n\n\tlist_for_each_entry_rcu(p, &br->port_list, list) {\n\t\t \n\t\tswitch (pkt_type) {\n\t\tcase BR_PKT_UNICAST:\n\t\t\tif (!(p->flags & BR_FLOOD))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase BR_PKT_MULTICAST:\n\t\t\tif (!(p->flags & BR_MCAST_FLOOD) && skb->dev != br->dev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase BR_PKT_BROADCAST:\n\t\t\tif (!(p->flags & BR_BCAST_FLOOD) && skb->dev != br->dev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (p->flags & BR_PROXYARP)\n\t\t\tcontinue;\n\t\tif (BR_INPUT_SKB_CB(skb)->proxyarp_replied &&\n\t\t    ((p->flags & BR_PROXYARP_WIFI) ||\n\t\t     br_is_neigh_suppress_enabled(p, vid)))\n\t\t\tcontinue;\n\n\t\tprev = maybe_deliver(prev, p, skb, local_orig);\n\t\tif (IS_ERR(prev))\n\t\t\tgoto out;\n\t}\n\n\tif (!prev)\n\t\tgoto out;\n\n\tif (local_rcv)\n\t\tdeliver_clone(prev, skb, local_orig);\n\telse\n\t\t__br_forward(prev, skb, local_orig);\n\treturn;\n\nout:\n\tif (!local_rcv)\n\t\tkfree_skb(skb);\n}\n\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\nstatic void maybe_deliver_addr(struct net_bridge_port *p, struct sk_buff *skb,\n\t\t\t       const unsigned char *addr, bool local_orig)\n{\n\tstruct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;\n\tconst unsigned char *src = eth_hdr(skb)->h_source;\n\n\tif (!should_deliver(p, skb))\n\t\treturn;\n\n\t \n\tif (skb->dev == p->dev && ether_addr_equal(src, addr))\n\t\treturn;\n\n\tskb = skb_copy(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\tDEV_STATS_INC(dev, tx_dropped);\n\t\treturn;\n\t}\n\n\tif (!is_broadcast_ether_addr(addr))\n\t\tmemcpy(eth_hdr(skb)->h_dest, addr, ETH_ALEN);\n\n\t__br_forward(p, skb, local_orig);\n}\n\n \nvoid br_multicast_flood(struct net_bridge_mdb_entry *mdst,\n\t\t\tstruct sk_buff *skb,\n\t\t\tstruct net_bridge_mcast *brmctx,\n\t\t\tbool local_rcv, bool local_orig)\n{\n\tstruct net_bridge_port *prev = NULL;\n\tstruct net_bridge_port_group *p;\n\tbool allow_mode_include = true;\n\tstruct hlist_node *rp;\n\n\trp = br_multicast_get_first_rport_node(brmctx, skb);\n\n\tif (mdst) {\n\t\tp = rcu_dereference(mdst->ports);\n\t\tif (br_multicast_should_handle_mode(brmctx, mdst->addr.proto) &&\n\t\t    br_multicast_is_star_g(&mdst->addr))\n\t\t\tallow_mode_include = false;\n\t} else {\n\t\tp = NULL;\n\t\tbr_tc_skb_miss_set(skb, true);\n\t}\n\n\twhile (p || rp) {\n\t\tstruct net_bridge_port *port, *lport, *rport;\n\n\t\tlport = p ? p->key.port : NULL;\n\t\trport = br_multicast_rport_from_node_skb(rp, skb);\n\n\t\tif ((unsigned long)lport > (unsigned long)rport) {\n\t\t\tport = lport;\n\n\t\t\tif (port->flags & BR_MULTICAST_TO_UNICAST) {\n\t\t\t\tmaybe_deliver_addr(lport, skb, p->eth_addr,\n\t\t\t\t\t\t   local_orig);\n\t\t\t\tgoto delivered;\n\t\t\t}\n\t\t\tif ((!allow_mode_include &&\n\t\t\t     p->filter_mode == MCAST_INCLUDE) ||\n\t\t\t    (p->flags & MDB_PG_FLAGS_BLOCKED))\n\t\t\t\tgoto delivered;\n\t\t} else {\n\t\t\tport = rport;\n\t\t}\n\n\t\tprev = maybe_deliver(prev, port, skb, local_orig);\n\t\tif (IS_ERR(prev))\n\t\t\tgoto out;\ndelivered:\n\t\tif ((unsigned long)lport >= (unsigned long)port)\n\t\t\tp = rcu_dereference(p->next);\n\t\tif ((unsigned long)rport >= (unsigned long)port)\n\t\t\trp = rcu_dereference(hlist_next_rcu(rp));\n\t}\n\n\tif (!prev)\n\t\tgoto out;\n\n\tif (local_rcv)\n\t\tdeliver_clone(prev, skb, local_orig);\n\telse\n\t\t__br_forward(prev, skb, local_orig);\n\treturn;\n\nout:\n\tif (!local_rcv)\n\t\tkfree_skb(skb);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}