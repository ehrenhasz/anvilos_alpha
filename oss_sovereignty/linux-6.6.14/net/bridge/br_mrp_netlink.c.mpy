{
  "module_name": "br_mrp_netlink.c",
  "hash_id": "bf2815f124f665b625c66bdfb4f68db85607d916b5b090b8ffe0e87ed275409f",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_mrp_netlink.c",
  "human_readable_source": "\n\n#include <net/genetlink.h>\n\n#include <uapi/linux/mrp_bridge.h>\n#include \"br_private.h\"\n#include \"br_private_mrp.h\"\n\nstatic const struct nla_policy br_mrp_policy[IFLA_BRIDGE_MRP_MAX + 1] = {\n\t[IFLA_BRIDGE_MRP_UNSPEC]\t= { .type = NLA_REJECT },\n\t[IFLA_BRIDGE_MRP_INSTANCE]\t= { .type = NLA_NESTED },\n\t[IFLA_BRIDGE_MRP_PORT_STATE]\t= { .type = NLA_NESTED },\n\t[IFLA_BRIDGE_MRP_PORT_ROLE]\t= { .type = NLA_NESTED },\n\t[IFLA_BRIDGE_MRP_RING_STATE]\t= { .type = NLA_NESTED },\n\t[IFLA_BRIDGE_MRP_RING_ROLE]\t= { .type = NLA_NESTED },\n\t[IFLA_BRIDGE_MRP_START_TEST]\t= { .type = NLA_NESTED },\n\t[IFLA_BRIDGE_MRP_IN_ROLE]\t= { .type = NLA_NESTED },\n\t[IFLA_BRIDGE_MRP_IN_STATE]\t= { .type = NLA_NESTED },\n\t[IFLA_BRIDGE_MRP_START_IN_TEST]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\nbr_mrp_instance_policy[IFLA_BRIDGE_MRP_INSTANCE_MAX + 1] = {\n\t[IFLA_BRIDGE_MRP_INSTANCE_UNSPEC]\t= { .type = NLA_REJECT },\n\t[IFLA_BRIDGE_MRP_INSTANCE_RING_ID]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_INSTANCE_P_IFINDEX]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_INSTANCE_S_IFINDEX]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_INSTANCE_PRIO]\t\t= { .type = NLA_U16 },\n};\n\nstatic int br_mrp_instance_parse(struct net_bridge *br, struct nlattr *attr,\n\t\t\t\t int cmd, struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MRP_INSTANCE_MAX + 1];\n\tstruct br_mrp_instance inst;\n\tint err;\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MRP_INSTANCE_MAX, attr,\n\t\t\t       br_mrp_instance_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_MRP_INSTANCE_RING_ID] ||\n\t    !tb[IFLA_BRIDGE_MRP_INSTANCE_P_IFINDEX] ||\n\t    !tb[IFLA_BRIDGE_MRP_INSTANCE_S_IFINDEX]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Missing attribute: RING_ID or P_IFINDEX or S_IFINDEX\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&inst, 0, sizeof(inst));\n\n\tinst.ring_id = nla_get_u32(tb[IFLA_BRIDGE_MRP_INSTANCE_RING_ID]);\n\tinst.p_ifindex = nla_get_u32(tb[IFLA_BRIDGE_MRP_INSTANCE_P_IFINDEX]);\n\tinst.s_ifindex = nla_get_u32(tb[IFLA_BRIDGE_MRP_INSTANCE_S_IFINDEX]);\n\tinst.prio = MRP_DEFAULT_PRIO;\n\n\tif (tb[IFLA_BRIDGE_MRP_INSTANCE_PRIO])\n\t\tinst.prio = nla_get_u16(tb[IFLA_BRIDGE_MRP_INSTANCE_PRIO]);\n\n\tif (cmd == RTM_SETLINK)\n\t\treturn br_mrp_add(br, &inst);\n\telse\n\t\treturn br_mrp_del(br, &inst);\n\n\treturn 0;\n}\n\nstatic const struct nla_policy\nbr_mrp_port_state_policy[IFLA_BRIDGE_MRP_PORT_STATE_MAX + 1] = {\n\t[IFLA_BRIDGE_MRP_PORT_STATE_UNSPEC]\t= { .type = NLA_REJECT },\n\t[IFLA_BRIDGE_MRP_PORT_STATE_STATE]\t= { .type = NLA_U32 },\n};\n\nstatic int br_mrp_port_state_parse(struct net_bridge_port *p,\n\t\t\t\t   struct nlattr *attr,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MRP_PORT_STATE_MAX + 1];\n\tenum br_mrp_port_state_type state;\n\tint err;\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MRP_PORT_STATE_MAX, attr,\n\t\t\t       br_mrp_port_state_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_MRP_PORT_STATE_STATE]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing attribute: STATE\");\n\t\treturn -EINVAL;\n\t}\n\n\tstate = nla_get_u32(tb[IFLA_BRIDGE_MRP_PORT_STATE_STATE]);\n\n\treturn br_mrp_set_port_state(p, state);\n}\n\nstatic const struct nla_policy\nbr_mrp_port_role_policy[IFLA_BRIDGE_MRP_PORT_ROLE_MAX + 1] = {\n\t[IFLA_BRIDGE_MRP_PORT_ROLE_UNSPEC]\t= { .type = NLA_REJECT },\n\t[IFLA_BRIDGE_MRP_PORT_ROLE_ROLE]\t= { .type = NLA_U32 },\n};\n\nstatic int br_mrp_port_role_parse(struct net_bridge_port *p,\n\t\t\t\t  struct nlattr *attr,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MRP_PORT_ROLE_MAX + 1];\n\tenum br_mrp_port_role_type role;\n\tint err;\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MRP_PORT_ROLE_MAX, attr,\n\t\t\t       br_mrp_port_role_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_MRP_PORT_ROLE_ROLE]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing attribute: ROLE\");\n\t\treturn -EINVAL;\n\t}\n\n\trole = nla_get_u32(tb[IFLA_BRIDGE_MRP_PORT_ROLE_ROLE]);\n\n\treturn br_mrp_set_port_role(p, role);\n}\n\nstatic const struct nla_policy\nbr_mrp_ring_state_policy[IFLA_BRIDGE_MRP_RING_STATE_MAX + 1] = {\n\t[IFLA_BRIDGE_MRP_RING_STATE_UNSPEC]\t= { .type = NLA_REJECT },\n\t[IFLA_BRIDGE_MRP_RING_STATE_RING_ID]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_RING_STATE_STATE]\t= { .type = NLA_U32 },\n};\n\nstatic int br_mrp_ring_state_parse(struct net_bridge *br, struct nlattr *attr,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MRP_RING_STATE_MAX + 1];\n\tstruct br_mrp_ring_state state;\n\tint err;\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MRP_RING_STATE_MAX, attr,\n\t\t\t       br_mrp_ring_state_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_MRP_RING_STATE_RING_ID] ||\n\t    !tb[IFLA_BRIDGE_MRP_RING_STATE_STATE]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Missing attribute: RING_ID or STATE\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&state, 0x0, sizeof(state));\n\n\tstate.ring_id = nla_get_u32(tb[IFLA_BRIDGE_MRP_RING_STATE_RING_ID]);\n\tstate.ring_state = nla_get_u32(tb[IFLA_BRIDGE_MRP_RING_STATE_STATE]);\n\n\treturn br_mrp_set_ring_state(br, &state);\n}\n\nstatic const struct nla_policy\nbr_mrp_ring_role_policy[IFLA_BRIDGE_MRP_RING_ROLE_MAX + 1] = {\n\t[IFLA_BRIDGE_MRP_RING_ROLE_UNSPEC]\t= { .type = NLA_REJECT },\n\t[IFLA_BRIDGE_MRP_RING_ROLE_RING_ID]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_RING_ROLE_ROLE]\t= { .type = NLA_U32 },\n};\n\nstatic int br_mrp_ring_role_parse(struct net_bridge *br, struct nlattr *attr,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MRP_RING_ROLE_MAX + 1];\n\tstruct br_mrp_ring_role role;\n\tint err;\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MRP_RING_ROLE_MAX, attr,\n\t\t\t       br_mrp_ring_role_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_MRP_RING_ROLE_RING_ID] ||\n\t    !tb[IFLA_BRIDGE_MRP_RING_ROLE_ROLE]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Missing attribute: RING_ID or ROLE\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&role, 0x0, sizeof(role));\n\n\trole.ring_id = nla_get_u32(tb[IFLA_BRIDGE_MRP_RING_ROLE_RING_ID]);\n\trole.ring_role = nla_get_u32(tb[IFLA_BRIDGE_MRP_RING_ROLE_ROLE]);\n\n\treturn br_mrp_set_ring_role(br, &role);\n}\n\nstatic const struct nla_policy\nbr_mrp_start_test_policy[IFLA_BRIDGE_MRP_START_TEST_MAX + 1] = {\n\t[IFLA_BRIDGE_MRP_START_TEST_UNSPEC]\t= { .type = NLA_REJECT },\n\t[IFLA_BRIDGE_MRP_START_TEST_RING_ID]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_START_TEST_INTERVAL]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_START_TEST_MAX_MISS]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_START_TEST_PERIOD]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_START_TEST_MONITOR]\t= { .type = NLA_U32 },\n};\n\nstatic int br_mrp_start_test_parse(struct net_bridge *br, struct nlattr *attr,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MRP_START_TEST_MAX + 1];\n\tstruct br_mrp_start_test test;\n\tint err;\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MRP_START_TEST_MAX, attr,\n\t\t\t       br_mrp_start_test_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_MRP_START_TEST_RING_ID] ||\n\t    !tb[IFLA_BRIDGE_MRP_START_TEST_INTERVAL] ||\n\t    !tb[IFLA_BRIDGE_MRP_START_TEST_MAX_MISS] ||\n\t    !tb[IFLA_BRIDGE_MRP_START_TEST_PERIOD]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Missing attribute: RING_ID or INTERVAL or MAX_MISS or PERIOD\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&test, 0x0, sizeof(test));\n\n\ttest.ring_id = nla_get_u32(tb[IFLA_BRIDGE_MRP_START_TEST_RING_ID]);\n\ttest.interval = nla_get_u32(tb[IFLA_BRIDGE_MRP_START_TEST_INTERVAL]);\n\ttest.max_miss = nla_get_u32(tb[IFLA_BRIDGE_MRP_START_TEST_MAX_MISS]);\n\ttest.period = nla_get_u32(tb[IFLA_BRIDGE_MRP_START_TEST_PERIOD]);\n\ttest.monitor = false;\n\n\tif (tb[IFLA_BRIDGE_MRP_START_TEST_MONITOR])\n\t\ttest.monitor =\n\t\t\tnla_get_u32(tb[IFLA_BRIDGE_MRP_START_TEST_MONITOR]);\n\n\treturn br_mrp_start_test(br, &test);\n}\n\nstatic const struct nla_policy\nbr_mrp_in_state_policy[IFLA_BRIDGE_MRP_IN_STATE_MAX + 1] = {\n\t[IFLA_BRIDGE_MRP_IN_STATE_UNSPEC]\t= { .type = NLA_REJECT },\n\t[IFLA_BRIDGE_MRP_IN_STATE_IN_ID]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_IN_STATE_STATE]\t= { .type = NLA_U32 },\n};\n\nstatic int br_mrp_in_state_parse(struct net_bridge *br, struct nlattr *attr,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MRP_IN_STATE_MAX + 1];\n\tstruct br_mrp_in_state state;\n\tint err;\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MRP_IN_STATE_MAX, attr,\n\t\t\t       br_mrp_in_state_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_MRP_IN_STATE_IN_ID] ||\n\t    !tb[IFLA_BRIDGE_MRP_IN_STATE_STATE]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Missing attribute: IN_ID or STATE\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&state, 0x0, sizeof(state));\n\n\tstate.in_id = nla_get_u32(tb[IFLA_BRIDGE_MRP_IN_STATE_IN_ID]);\n\tstate.in_state = nla_get_u32(tb[IFLA_BRIDGE_MRP_IN_STATE_STATE]);\n\n\treturn br_mrp_set_in_state(br, &state);\n}\n\nstatic const struct nla_policy\nbr_mrp_in_role_policy[IFLA_BRIDGE_MRP_IN_ROLE_MAX + 1] = {\n\t[IFLA_BRIDGE_MRP_IN_ROLE_UNSPEC]\t= { .type = NLA_REJECT },\n\t[IFLA_BRIDGE_MRP_IN_ROLE_RING_ID]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_IN_ROLE_IN_ID]\t\t= { .type = NLA_U16 },\n\t[IFLA_BRIDGE_MRP_IN_ROLE_ROLE]\t\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_IN_ROLE_I_IFINDEX]\t= { .type = NLA_U32 },\n};\n\nstatic int br_mrp_in_role_parse(struct net_bridge *br, struct nlattr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MRP_IN_ROLE_MAX + 1];\n\tstruct br_mrp_in_role role;\n\tint err;\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MRP_IN_ROLE_MAX, attr,\n\t\t\t       br_mrp_in_role_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_MRP_IN_ROLE_RING_ID] ||\n\t    !tb[IFLA_BRIDGE_MRP_IN_ROLE_IN_ID] ||\n\t    !tb[IFLA_BRIDGE_MRP_IN_ROLE_I_IFINDEX] ||\n\t    !tb[IFLA_BRIDGE_MRP_IN_ROLE_ROLE]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Missing attribute: RING_ID or ROLE or IN_ID or I_IFINDEX\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&role, 0x0, sizeof(role));\n\n\trole.ring_id = nla_get_u32(tb[IFLA_BRIDGE_MRP_IN_ROLE_RING_ID]);\n\trole.in_id = nla_get_u16(tb[IFLA_BRIDGE_MRP_IN_ROLE_IN_ID]);\n\trole.i_ifindex = nla_get_u32(tb[IFLA_BRIDGE_MRP_IN_ROLE_I_IFINDEX]);\n\trole.in_role = nla_get_u32(tb[IFLA_BRIDGE_MRP_IN_ROLE_ROLE]);\n\n\treturn br_mrp_set_in_role(br, &role);\n}\n\nstatic const struct nla_policy\nbr_mrp_start_in_test_policy[IFLA_BRIDGE_MRP_START_IN_TEST_MAX + 1] = {\n\t[IFLA_BRIDGE_MRP_START_IN_TEST_UNSPEC]\t= { .type = NLA_REJECT },\n\t[IFLA_BRIDGE_MRP_START_IN_TEST_IN_ID]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_START_IN_TEST_INTERVAL]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_START_IN_TEST_MAX_MISS]\t= { .type = NLA_U32 },\n\t[IFLA_BRIDGE_MRP_START_IN_TEST_PERIOD]\t= { .type = NLA_U32 },\n};\n\nstatic int br_mrp_start_in_test_parse(struct net_bridge *br,\n\t\t\t\t      struct nlattr *attr,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MRP_START_IN_TEST_MAX + 1];\n\tstruct br_mrp_start_in_test test;\n\tint err;\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MRP_START_IN_TEST_MAX, attr,\n\t\t\t       br_mrp_start_in_test_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_MRP_START_IN_TEST_IN_ID] ||\n\t    !tb[IFLA_BRIDGE_MRP_START_IN_TEST_INTERVAL] ||\n\t    !tb[IFLA_BRIDGE_MRP_START_IN_TEST_MAX_MISS] ||\n\t    !tb[IFLA_BRIDGE_MRP_START_IN_TEST_PERIOD]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Missing attribute: RING_ID or INTERVAL or MAX_MISS or PERIOD\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&test, 0x0, sizeof(test));\n\n\ttest.in_id = nla_get_u32(tb[IFLA_BRIDGE_MRP_START_IN_TEST_IN_ID]);\n\ttest.interval = nla_get_u32(tb[IFLA_BRIDGE_MRP_START_IN_TEST_INTERVAL]);\n\ttest.max_miss = nla_get_u32(tb[IFLA_BRIDGE_MRP_START_IN_TEST_MAX_MISS]);\n\ttest.period = nla_get_u32(tb[IFLA_BRIDGE_MRP_START_IN_TEST_PERIOD]);\n\n\treturn br_mrp_start_in_test(br, &test);\n}\n\nint br_mrp_parse(struct net_bridge *br, struct net_bridge_port *p,\n\t\t struct nlattr *attr, int cmd, struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MRP_MAX + 1];\n\tint err;\n\n\t \n\tif (p)\n\t\tbr = p->br;\n\n\tif (br->stp_enabled != BR_NO_STP) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MRP can't be enabled if STP is already enabled\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MRP_MAX, attr,\n\t\t\t       br_mrp_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[IFLA_BRIDGE_MRP_INSTANCE]) {\n\t\terr = br_mrp_instance_parse(br, tb[IFLA_BRIDGE_MRP_INSTANCE],\n\t\t\t\t\t    cmd, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRIDGE_MRP_PORT_STATE]) {\n\t\terr = br_mrp_port_state_parse(p, tb[IFLA_BRIDGE_MRP_PORT_STATE],\n\t\t\t\t\t      extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRIDGE_MRP_PORT_ROLE]) {\n\t\terr = br_mrp_port_role_parse(p, tb[IFLA_BRIDGE_MRP_PORT_ROLE],\n\t\t\t\t\t     extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRIDGE_MRP_RING_STATE]) {\n\t\terr = br_mrp_ring_state_parse(br,\n\t\t\t\t\t      tb[IFLA_BRIDGE_MRP_RING_STATE],\n\t\t\t\t\t      extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRIDGE_MRP_RING_ROLE]) {\n\t\terr = br_mrp_ring_role_parse(br, tb[IFLA_BRIDGE_MRP_RING_ROLE],\n\t\t\t\t\t     extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRIDGE_MRP_START_TEST]) {\n\t\terr = br_mrp_start_test_parse(br,\n\t\t\t\t\t      tb[IFLA_BRIDGE_MRP_START_TEST],\n\t\t\t\t\t      extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRIDGE_MRP_IN_STATE]) {\n\t\terr = br_mrp_in_state_parse(br, tb[IFLA_BRIDGE_MRP_IN_STATE],\n\t\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRIDGE_MRP_IN_ROLE]) {\n\t\terr = br_mrp_in_role_parse(br, tb[IFLA_BRIDGE_MRP_IN_ROLE],\n\t\t\t\t\t   extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_BRIDGE_MRP_START_IN_TEST]) {\n\t\terr = br_mrp_start_in_test_parse(br,\n\t\t\t\t\t\t tb[IFLA_BRIDGE_MRP_START_IN_TEST],\n\t\t\t\t\t\t extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint br_mrp_fill_info(struct sk_buff *skb, struct net_bridge *br)\n{\n\tstruct nlattr *tb, *mrp_tb;\n\tstruct br_mrp *mrp;\n\n\tmrp_tb = nla_nest_start_noflag(skb, IFLA_BRIDGE_MRP);\n\tif (!mrp_tb)\n\t\treturn -EMSGSIZE;\n\n\thlist_for_each_entry_rcu(mrp, &br->mrp_list, list) {\n\t\tstruct net_bridge_port *p;\n\n\t\ttb = nla_nest_start_noflag(skb, IFLA_BRIDGE_MRP_INFO);\n\t\tif (!tb)\n\t\t\tgoto nla_info_failure;\n\n\t\tif (nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_RING_ID,\n\t\t\t\tmrp->ring_id))\n\t\t\tgoto nla_put_failure;\n\n\t\tp = rcu_dereference(mrp->p_port);\n\t\tif (p && nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_P_IFINDEX,\n\t\t\t\t     p->dev->ifindex))\n\t\t\tgoto nla_put_failure;\n\n\t\tp = rcu_dereference(mrp->s_port);\n\t\tif (p && nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_S_IFINDEX,\n\t\t\t\t     p->dev->ifindex))\n\t\t\tgoto nla_put_failure;\n\n\t\tp = rcu_dereference(mrp->i_port);\n\t\tif (p && nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_I_IFINDEX,\n\t\t\t\t     p->dev->ifindex))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u16(skb, IFLA_BRIDGE_MRP_INFO_PRIO,\n\t\t\t\tmrp->prio))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_RING_STATE,\n\t\t\t\tmrp->ring_state))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_RING_ROLE,\n\t\t\t\tmrp->ring_role))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_TEST_INTERVAL,\n\t\t\t\tmrp->test_interval))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_TEST_MAX_MISS,\n\t\t\t\tmrp->test_max_miss))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_TEST_MONITOR,\n\t\t\t\tmrp->test_monitor))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_IN_STATE,\n\t\t\t\tmrp->in_state))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_IN_ROLE,\n\t\t\t\tmrp->in_role))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_IN_TEST_INTERVAL,\n\t\t\t\tmrp->in_test_interval))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_BRIDGE_MRP_INFO_IN_TEST_MAX_MISS,\n\t\t\t\tmrp->in_test_max_miss))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, tb);\n\t}\n\tnla_nest_end(skb, mrp_tb);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, tb);\n\nnla_info_failure:\n\tnla_nest_cancel(skb, mrp_tb);\n\n\treturn -EMSGSIZE;\n}\n\nint br_mrp_ring_port_open(struct net_device *dev, u8 loc)\n{\n\tstruct net_bridge_port *p;\n\tint err = 0;\n\n\tp = br_port_get_rcu(dev);\n\tif (!p) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (loc)\n\t\tp->flags |= BR_MRP_LOST_CONT;\n\telse\n\t\tp->flags &= ~BR_MRP_LOST_CONT;\n\n\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\nout:\n\treturn err;\n}\n\nint br_mrp_in_port_open(struct net_device *dev, u8 loc)\n{\n\tstruct net_bridge_port *p;\n\tint err = 0;\n\n\tp = br_port_get_rcu(dev);\n\tif (!p) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (loc)\n\t\tp->flags |= BR_MRP_LOST_IN_CONT;\n\telse\n\t\tp->flags &= ~BR_MRP_LOST_IN_CONT;\n\n\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\nout:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}