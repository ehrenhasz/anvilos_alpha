{
  "module_name": "br_netfilter_ipv6.c",
  "hash_id": "e3f3c8f12bb932204934aa68dbc80916042f6af01b0211c330268f519ff3ece3",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_netfilter_ipv6.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/ip.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp_defs.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_arp.h>\n#include <linux/in_route.h>\n#include <linux/inetdevice.h>\n\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <net/route.h>\n#include <net/netfilter/br_netfilter.h>\n\n#include <linux/uaccess.h>\n#include \"br_private.h\"\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\nint br_validate_ipv6(struct net *net, struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *hdr;\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\tu32 pkt_len;\n\tu8 ip6h_len = sizeof(struct ipv6hdr);\n\n\tif (!pskb_may_pull(skb, ip6h_len))\n\t\tgoto inhdr_error;\n\n\tif (skb->len < ip6h_len)\n\t\tgoto drop;\n\n\thdr = ipv6_hdr(skb);\n\n\tif (hdr->version != 6)\n\t\tgoto inhdr_error;\n\n\tpkt_len = ntohs(hdr->payload_len);\n\tif (hdr->nexthdr == NEXTHDR_HOP && nf_ip6_check_hbh_len(skb, &pkt_len))\n\t\tgoto drop;\n\n\tif (pkt_len + ip6h_len > skb->len) {\n\t\t__IP6_INC_STATS(net, idev,\n\t\t\t\tIPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t}\n\tif (pskb_trim_rcsum(skb, pkt_len + ip6h_len)) {\n\t\t__IP6_INC_STATS(net, idev,\n\t\t\t\tIPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tmemset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));\n\t \n\treturn 0;\n\ninhdr_error:\n\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}\n\nstatic inline bool\nbr_nf_ipv6_daddr_was_changed(const struct sk_buff *skb,\n\t\t\t     const struct nf_bridge_info *nf_bridge)\n{\n\treturn memcmp(&nf_bridge->ipv6_daddr, &ipv6_hdr(skb)->daddr,\n\t\t      sizeof(ipv6_hdr(skb)->daddr)) != 0;\n}\n\n \nstatic int br_nf_pre_routing_finish_ipv6(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\tstruct rtable *rt;\n\tstruct net_device *dev = skb->dev, *br_indev;\n\tconst struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();\n\n\tbr_indev = nf_bridge_get_physindev(skb, net);\n\tif (!br_indev) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tnf_bridge->frag_max_size = IP6CB(skb)->frag_max_size;\n\n\tif (nf_bridge->pkt_otherhost) {\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tnf_bridge->pkt_otherhost = false;\n\t}\n\tnf_bridge->in_prerouting = 0;\n\tif (br_nf_ipv6_daddr_was_changed(skb, nf_bridge)) {\n\t\tskb_dst_drop(skb);\n\t\tv6ops->route_input(skb);\n\n\t\tif (skb_dst(skb)->error) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (skb_dst(skb)->dev == dev) {\n\t\t\tskb->dev = br_indev;\n\t\t\tnf_bridge_update_protocol(skb);\n\t\t\tnf_bridge_push_encap_header(skb);\n\t\t\tbr_nf_hook_thresh(NF_BR_PRE_ROUTING,\n\t\t\t\t\t  net, sk, skb, skb->dev, NULL,\n\t\t\t\t\t  br_nf_pre_routing_finish_bridge);\n\t\t\treturn 0;\n\t\t}\n\t\tether_addr_copy(eth_hdr(skb)->h_dest, dev->dev_addr);\n\t\tskb->pkt_type = PACKET_HOST;\n\t} else {\n\t\trt = bridge_parent_rtable(br_indev);\n\t\tif (!rt) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tskb_dst_drop(skb);\n\t\tskb_dst_set_noref(skb, &rt->dst);\n\t}\n\n\tskb->dev = br_indev;\n\tnf_bridge_update_protocol(skb);\n\tnf_bridge_push_encap_header(skb);\n\tbr_nf_hook_thresh(NF_BR_PRE_ROUTING, net, sk, skb,\n\t\t\t  skb->dev, NULL, br_handle_frame_finish);\n\n\treturn 0;\n}\n\n \nunsigned int br_nf_pre_routing_ipv6(void *priv,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    const struct nf_hook_state *state)\n{\n\tstruct nf_bridge_info *nf_bridge;\n\n\tif (br_validate_ipv6(state->net, skb))\n\t\treturn NF_DROP;\n\n\tnf_bridge = nf_bridge_alloc(skb);\n\tif (!nf_bridge)\n\t\treturn NF_DROP;\n\tif (!setup_pre_routing(skb, state->net))\n\t\treturn NF_DROP;\n\n\tnf_bridge = nf_bridge_info_get(skb);\n\tnf_bridge->ipv6_daddr = ipv6_hdr(skb)->daddr;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->transport_header = skb->network_header + sizeof(struct ipv6hdr);\n\n\tNF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, state->net, state->sk, skb,\n\t\tskb->dev, NULL,\n\t\tbr_nf_pre_routing_finish_ipv6);\n\n\treturn NF_STOLEN;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}