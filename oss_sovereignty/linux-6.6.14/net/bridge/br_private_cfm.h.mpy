{
  "module_name": "br_private_cfm.h",
  "hash_id": "bc7615e68338658eabbf05aea363055732c083fcfe27ee00ed7c70d09d60e554",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_private_cfm.h",
  "human_readable_source": " \n\n#ifndef _BR_PRIVATE_CFM_H_\n#define _BR_PRIVATE_CFM_H_\n\n#include \"br_private.h\"\n#include <uapi/linux/cfm_bridge.h>\n\nstruct br_cfm_mep_create {\n\tenum br_cfm_domain domain;  \n\tenum br_cfm_mep_direction direction;  \n\tu32 ifindex;  \n};\n\nint br_cfm_mep_create(struct net_bridge *br,\n\t\t      const u32 instance,\n\t\t      struct br_cfm_mep_create *const create,\n\t\t      struct netlink_ext_ack *extack);\n\nint br_cfm_mep_delete(struct net_bridge *br,\n\t\t      const u32 instance,\n\t\t      struct netlink_ext_ack *extack);\n\nstruct br_cfm_mep_config {\n\tu32 mdlevel;\n\tu32 mepid;  \n\tstruct mac_addr unicast_mac;  \n};\n\nint br_cfm_mep_config_set(struct net_bridge *br,\n\t\t\t  const u32 instance,\n\t\t\t  const struct br_cfm_mep_config *const config,\n\t\t\t  struct netlink_ext_ack *extack);\n\nstruct br_cfm_maid {\n\tu8 data[CFM_MAID_LENGTH];\n};\n\nstruct br_cfm_cc_config {\n\t \n\tstruct br_cfm_maid exp_maid;\n\n\t \n\t \n\tenum br_cfm_ccm_interval exp_interval;\n\n\tbool enable;  \n};\n\nint br_cfm_cc_config_set(struct net_bridge *br,\n\t\t\t const u32 instance,\n\t\t\t const struct br_cfm_cc_config *const config,\n\t\t\t struct netlink_ext_ack *extack);\n\nint br_cfm_cc_peer_mep_add(struct net_bridge *br, const u32 instance,\n\t\t\t   u32 peer_mep_id,\n\t\t\t   struct netlink_ext_ack *extack);\nint br_cfm_cc_peer_mep_remove(struct net_bridge *br, const u32 instance,\n\t\t\t      u32 peer_mep_id,\n\t\t\t      struct netlink_ext_ack *extack);\n\n \nint br_cfm_cc_rdi_set(struct net_bridge *br, const u32 instance,\n\t\t      const bool rdi, struct netlink_ext_ack *extack);\n\n \nstruct br_cfm_cc_ccm_tx_info {\n\tstruct mac_addr dmac;\n\t \n\tu32 period;\n\n\tbool seq_no_update;  \n\tbool if_tlv;  \n\tu8 if_tlv_value;  \n\tbool port_tlv;  \n\tu8 port_tlv_value;  \n\t \n};\n\nint br_cfm_cc_ccm_tx(struct net_bridge *br, const u32 instance,\n\t\t     const struct br_cfm_cc_ccm_tx_info *const tx_info,\n\t\t     struct netlink_ext_ack *extack);\n\nstruct br_cfm_mep_status {\n\t \n\tbool opcode_unexp_seen;  \n\tbool version_unexp_seen;  \n\tbool rx_level_low_seen;  \n};\n\nstruct br_cfm_cc_peer_status {\n\t \n\tu8 port_tlv_value;  \n\tu8 if_tlv_value;  \n\n\t \n\tu8 ccm_defect:1;\n\n\t \n\tu8 rdi:1;\n\n\t \n\tu8 seen:1;  \n\tu8 tlv_seen:1;  \n\t \n\tu8 seq_unexp_seen:1;\n};\n\nstruct br_cfm_mep {\n\t \n\tstruct hlist_node\t\thead;\n\tu32\t\t\t\tinstance;\n\tstruct br_cfm_mep_create\tcreate;\n\tstruct br_cfm_mep_config\tconfig;\n\tstruct br_cfm_cc_config\t\tcc_config;\n\tstruct br_cfm_cc_ccm_tx_info\tcc_ccm_tx_info;\n\t \n\tstruct hlist_head\t\tpeer_mep_list;\n\tstruct net_bridge_port __rcu\t*b_port;\n\tunsigned long\t\t\tccm_tx_end;\n\tstruct delayed_work\t\tccm_tx_dwork;\n\tu32\t\t\t\tccm_tx_snumber;\n\tu32\t\t\t\tccm_rx_snumber;\n\tstruct br_cfm_mep_status\tstatus;\n\tbool\t\t\t\trdi;\n\tstruct rcu_head\t\t\trcu;\n};\n\nstruct br_cfm_peer_mep {\n\tstruct hlist_node\t\thead;\n\tstruct br_cfm_mep\t\t*mep;\n\tstruct delayed_work\t\tccm_rx_dwork;\n\tu32\t\t\t\tmepid;\n\tstruct br_cfm_cc_peer_status\tcc_status;\n\tu32\t\t\t\tccm_rx_count_miss;\n\tstruct rcu_head\t\t\trcu;\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}