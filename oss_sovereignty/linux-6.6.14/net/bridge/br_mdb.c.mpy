{
  "module_name": "br_mdb.c",
  "hash_id": "edf364c6a0a694f6da8f09d155838a23bdc2b8c50cc292dc9d1d5c706bc2f2c8",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_mdb.c",
  "human_readable_source": "\n#include <linux/err.h>\n#include <linux/igmp.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/if_ether.h>\n#include <net/ip.h>\n#include <net/netlink.h>\n#include <net/switchdev.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#endif\n\n#include \"br_private.h\"\n\nstatic bool\nbr_ip4_rports_get_timer(struct net_bridge_mcast_port *pmctx,\n\t\t\tunsigned long *timer)\n{\n\t*timer = br_timer_value(&pmctx->ip4_mc_router_timer);\n\treturn !hlist_unhashed(&pmctx->ip4_rlist);\n}\n\nstatic bool\nbr_ip6_rports_get_timer(struct net_bridge_mcast_port *pmctx,\n\t\t\tunsigned long *timer)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\t*timer = br_timer_value(&pmctx->ip6_mc_router_timer);\n\treturn !hlist_unhashed(&pmctx->ip6_rlist);\n#else\n\t*timer = 0;\n\treturn false;\n#endif\n}\n\nstatic size_t __br_rports_one_size(void)\n{\n\treturn nla_total_size(sizeof(u32)) +  \n\t       nla_total_size(sizeof(u32)) +  \n\t       nla_total_size(sizeof(u8)) +   \n\t       nla_total_size(sizeof(u32)) +  \n\t       nla_total_size(sizeof(u32)) +  \n\t       nla_total_size(sizeof(u32));   \n}\n\nsize_t br_rports_size(const struct net_bridge_mcast *brmctx)\n{\n\tstruct net_bridge_mcast_port *pmctx;\n\tsize_t size = nla_total_size(0);  \n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(pmctx, &brmctx->ip4_mc_router_list,\n\t\t\t\t ip4_rlist)\n\t\tsize += __br_rports_one_size();\n\n#if IS_ENABLED(CONFIG_IPV6)\n\thlist_for_each_entry_rcu(pmctx, &brmctx->ip6_mc_router_list,\n\t\t\t\t ip6_rlist)\n\t\tsize += __br_rports_one_size();\n#endif\n\trcu_read_unlock();\n\n\treturn size;\n}\n\nint br_rports_fill_info(struct sk_buff *skb,\n\t\t\tconst struct net_bridge_mcast *brmctx)\n{\n\tu16 vid = brmctx->vlan ? brmctx->vlan->vid : 0;\n\tbool have_ip4_mc_rtr, have_ip6_mc_rtr;\n\tunsigned long ip4_timer, ip6_timer;\n\tstruct nlattr *nest, *port_nest;\n\tstruct net_bridge_port *p;\n\n\tif (!brmctx->multicast_router || !br_rports_have_mc_router(brmctx))\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(skb, MDBA_ROUTER);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\tlist_for_each_entry_rcu(p, &brmctx->br->port_list, list) {\n\t\tstruct net_bridge_mcast_port *pmctx;\n\n\t\tif (vid) {\n\t\t\tstruct net_bridge_vlan *v;\n\n\t\t\tv = br_vlan_find(nbp_vlan_group(p), vid);\n\t\t\tif (!v)\n\t\t\t\tcontinue;\n\t\t\tpmctx = &v->port_mcast_ctx;\n\t\t} else {\n\t\t\tpmctx = &p->multicast_ctx;\n\t\t}\n\n\t\thave_ip4_mc_rtr = br_ip4_rports_get_timer(pmctx, &ip4_timer);\n\t\thave_ip6_mc_rtr = br_ip6_rports_get_timer(pmctx, &ip6_timer);\n\n\t\tif (!have_ip4_mc_rtr && !have_ip6_mc_rtr)\n\t\t\tcontinue;\n\n\t\tport_nest = nla_nest_start_noflag(skb, MDBA_ROUTER_PORT);\n\t\tif (!port_nest)\n\t\t\tgoto fail;\n\n\t\tif (nla_put_nohdr(skb, sizeof(u32), &p->dev->ifindex) ||\n\t\t    nla_put_u32(skb, MDBA_ROUTER_PATTR_TIMER,\n\t\t\t\tmax(ip4_timer, ip6_timer)) ||\n\t\t    nla_put_u8(skb, MDBA_ROUTER_PATTR_TYPE,\n\t\t\t       p->multicast_ctx.multicast_router) ||\n\t\t    (have_ip4_mc_rtr &&\n\t\t     nla_put_u32(skb, MDBA_ROUTER_PATTR_INET_TIMER,\n\t\t\t\t ip4_timer)) ||\n\t\t    (have_ip6_mc_rtr &&\n\t\t     nla_put_u32(skb, MDBA_ROUTER_PATTR_INET6_TIMER,\n\t\t\t\t ip6_timer)) ||\n\t\t    (vid && nla_put_u16(skb, MDBA_ROUTER_PATTR_VID, vid))) {\n\t\t\tnla_nest_cancel(skb, port_nest);\n\t\t\tgoto fail;\n\t\t}\n\t\tnla_nest_end(skb, port_nest);\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\nfail:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic void __mdb_entry_fill_flags(struct br_mdb_entry *e, unsigned char flags)\n{\n\te->state = flags & MDB_PG_FLAGS_PERMANENT;\n\te->flags = 0;\n\tif (flags & MDB_PG_FLAGS_OFFLOAD)\n\t\te->flags |= MDB_FLAGS_OFFLOAD;\n\tif (flags & MDB_PG_FLAGS_FAST_LEAVE)\n\t\te->flags |= MDB_FLAGS_FAST_LEAVE;\n\tif (flags & MDB_PG_FLAGS_STAR_EXCL)\n\t\te->flags |= MDB_FLAGS_STAR_EXCL;\n\tif (flags & MDB_PG_FLAGS_BLOCKED)\n\t\te->flags |= MDB_FLAGS_BLOCKED;\n}\n\nstatic void __mdb_entry_to_br_ip(struct br_mdb_entry *entry, struct br_ip *ip,\n\t\t\t\t struct nlattr **mdb_attrs)\n{\n\tmemset(ip, 0, sizeof(struct br_ip));\n\tip->vid = entry->vid;\n\tip->proto = entry->addr.proto;\n\tswitch (ip->proto) {\n\tcase htons(ETH_P_IP):\n\t\tip->dst.ip4 = entry->addr.u.ip4;\n\t\tif (mdb_attrs && mdb_attrs[MDBE_ATTR_SOURCE])\n\t\t\tip->src.ip4 = nla_get_in_addr(mdb_attrs[MDBE_ATTR_SOURCE]);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tip->dst.ip6 = entry->addr.u.ip6;\n\t\tif (mdb_attrs && mdb_attrs[MDBE_ATTR_SOURCE])\n\t\t\tip->src.ip6 = nla_get_in6_addr(mdb_attrs[MDBE_ATTR_SOURCE]);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tether_addr_copy(ip->dst.mac_addr, entry->addr.u.mac_addr);\n\t}\n\n}\n\nstatic int __mdb_fill_srcs(struct sk_buff *skb,\n\t\t\t   struct net_bridge_port_group *p)\n{\n\tstruct net_bridge_group_src *ent;\n\tstruct nlattr *nest, *nest_ent;\n\n\tif (hlist_empty(&p->src_list))\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_MDB_EATTR_SRC_LIST);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\thlist_for_each_entry_rcu(ent, &p->src_list, node,\n\t\t\t\t lockdep_is_held(&p->key.port->br->multicast_lock)) {\n\t\tnest_ent = nla_nest_start(skb, MDBA_MDB_SRCLIST_ENTRY);\n\t\tif (!nest_ent)\n\t\t\tgoto out_cancel_err;\n\t\tswitch (ent->addr.proto) {\n\t\tcase htons(ETH_P_IP):\n\t\t\tif (nla_put_in_addr(skb, MDBA_MDB_SRCATTR_ADDRESS,\n\t\t\t\t\t    ent->addr.src.ip4)) {\n\t\t\t\tnla_nest_cancel(skb, nest_ent);\n\t\t\t\tgoto out_cancel_err;\n\t\t\t}\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tif (nla_put_in6_addr(skb, MDBA_MDB_SRCATTR_ADDRESS,\n\t\t\t\t\t     &ent->addr.src.ip6)) {\n\t\t\t\tnla_nest_cancel(skb, nest_ent);\n\t\t\t\tgoto out_cancel_err;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tnla_nest_cancel(skb, nest_ent);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nla_put_u32(skb, MDBA_MDB_SRCATTR_TIMER,\n\t\t\t\tbr_timer_value(&ent->timer))) {\n\t\t\tnla_nest_cancel(skb, nest_ent);\n\t\t\tgoto out_cancel_err;\n\t\t}\n\t\tnla_nest_end(skb, nest_ent);\n\t}\n\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n\nout_cancel_err:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int __mdb_fill_info(struct sk_buff *skb,\n\t\t\t   struct net_bridge_mdb_entry *mp,\n\t\t\t   struct net_bridge_port_group *p)\n{\n\tbool dump_srcs_mode = false;\n\tstruct timer_list *mtimer;\n\tstruct nlattr *nest_ent;\n\tstruct br_mdb_entry e;\n\tu8 flags = 0;\n\tint ifindex;\n\n\tmemset(&e, 0, sizeof(e));\n\tif (p) {\n\t\tifindex = p->key.port->dev->ifindex;\n\t\tmtimer = &p->timer;\n\t\tflags = p->flags;\n\t} else {\n\t\tifindex = mp->br->dev->ifindex;\n\t\tmtimer = &mp->timer;\n\t}\n\n\t__mdb_entry_fill_flags(&e, flags);\n\te.ifindex = ifindex;\n\te.vid = mp->addr.vid;\n\tif (mp->addr.proto == htons(ETH_P_IP)) {\n\t\te.addr.u.ip4 = mp->addr.dst.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (mp->addr.proto == htons(ETH_P_IPV6)) {\n\t\te.addr.u.ip6 = mp->addr.dst.ip6;\n#endif\n\t} else {\n\t\tether_addr_copy(e.addr.u.mac_addr, mp->addr.dst.mac_addr);\n\t\te.state = MDB_PERMANENT;\n\t}\n\te.addr.proto = mp->addr.proto;\n\tnest_ent = nla_nest_start_noflag(skb,\n\t\t\t\t\t MDBA_MDB_ENTRY_INFO);\n\tif (!nest_ent)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_nohdr(skb, sizeof(e), &e) ||\n\t    nla_put_u32(skb,\n\t\t\tMDBA_MDB_EATTR_TIMER,\n\t\t\tbr_timer_value(mtimer)))\n\t\tgoto nest_err;\n\n\tswitch (mp->addr.proto) {\n\tcase htons(ETH_P_IP):\n\t\tdump_srcs_mode = !!(mp->br->multicast_ctx.multicast_igmp_version == 3);\n\t\tif (mp->addr.src.ip4) {\n\t\t\tif (nla_put_in_addr(skb, MDBA_MDB_EATTR_SOURCE,\n\t\t\t\t\t    mp->addr.src.ip4))\n\t\t\t\tgoto nest_err;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tdump_srcs_mode = !!(mp->br->multicast_ctx.multicast_mld_version == 2);\n\t\tif (!ipv6_addr_any(&mp->addr.src.ip6)) {\n\t\t\tif (nla_put_in6_addr(skb, MDBA_MDB_EATTR_SOURCE,\n\t\t\t\t\t     &mp->addr.src.ip6))\n\t\t\t\tgoto nest_err;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tether_addr_copy(e.addr.u.mac_addr, mp->addr.dst.mac_addr);\n\t}\n\tif (p) {\n\t\tif (nla_put_u8(skb, MDBA_MDB_EATTR_RTPROT, p->rt_protocol))\n\t\t\tgoto nest_err;\n\t\tif (dump_srcs_mode &&\n\t\t    (__mdb_fill_srcs(skb, p) ||\n\t\t     nla_put_u8(skb, MDBA_MDB_EATTR_GROUP_MODE,\n\t\t\t\tp->filter_mode)))\n\t\t\tgoto nest_err;\n\t}\n\tnla_nest_end(skb, nest_ent);\n\n\treturn 0;\n\nnest_err:\n\tnla_nest_cancel(skb, nest_ent);\n\treturn -EMSGSIZE;\n}\n\nstatic int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t    struct net_device *dev)\n{\n\tint idx = 0, s_idx = cb->args[1], err = 0, pidx = 0, s_pidx = cb->args[2];\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct nlattr *nest, *nest2;\n\n\tif (!br_opt_get(br, BROPT_MULTICAST_ENABLED))\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\thlist_for_each_entry_rcu(mp, &br->mdb_list, mdb_node) {\n\t\tstruct net_bridge_port_group *p;\n\t\tstruct net_bridge_port_group __rcu **pp;\n\n\t\tif (idx < s_idx)\n\t\t\tgoto skip;\n\n\t\tnest2 = nla_nest_start_noflag(skb, MDBA_MDB_ENTRY);\n\t\tif (!nest2) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!s_pidx && mp->host_joined) {\n\t\t\terr = __mdb_fill_info(skb, mp, NULL);\n\t\t\tif (err) {\n\t\t\t\tnla_nest_cancel(skb, nest2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (pp = &mp->ports; (p = rcu_dereference(*pp)) != NULL;\n\t\t      pp = &p->next) {\n\t\t\tif (!p->key.port)\n\t\t\t\tcontinue;\n\t\t\tif (pidx < s_pidx)\n\t\t\t\tgoto skip_pg;\n\n\t\t\terr = __mdb_fill_info(skb, mp, p);\n\t\t\tif (err) {\n\t\t\t\tnla_nest_end(skb, nest2);\n\t\t\t\tgoto out;\n\t\t\t}\nskip_pg:\n\t\t\tpidx++;\n\t\t}\n\t\tpidx = 0;\n\t\ts_pidx = 0;\n\t\tnla_nest_end(skb, nest2);\nskip:\n\t\tidx++;\n\t}\n\nout:\n\tcb->args[1] = idx;\n\tcb->args[2] = pidx;\n\tnla_nest_end(skb, nest);\n\treturn err;\n}\n\nint br_mdb_dump(struct net_device *dev, struct sk_buff *skb,\n\t\tstruct netlink_callback *cb)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct br_port_msg *bpm;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB, sizeof(*bpm),\n\t\t\tNLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->ifindex = dev->ifindex;\n\n\trcu_read_lock();\n\n\terr = br_mdb_fill_info(skb, cb, dev);\n\tif (err)\n\t\tgoto out;\n\terr = br_rports_fill_info(skb, &br->multicast_ctx);\n\tif (err)\n\t\tgoto out;\n\nout:\n\trcu_read_unlock();\n\tnlmsg_end(skb, nlh);\n\treturn err;\n}\n\nstatic int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct net_bridge_mdb_entry *mp,\n\t\t\t\t   struct net_bridge_port_group *pg,\n\t\t\t\t   int type)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *nest, *nest2;\n\n\tnlh = nlmsg_put(skb, 0, 0, type, sizeof(*bpm), 0);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start_noflag(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\tgoto cancel;\n\tnest2 = nla_nest_start_noflag(skb, MDBA_MDB_ENTRY);\n\tif (nest2 == NULL)\n\t\tgoto end;\n\n\tif (__mdb_fill_info(skb, mp, pg))\n\t\tgoto end;\n\n\tnla_nest_end(skb, nest2);\n\tnla_nest_end(skb, nest);\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic size_t rtnl_mdb_nlmsg_size(struct net_bridge_port_group *pg)\n{\n\tsize_t nlmsg_size = NLMSG_ALIGN(sizeof(struct br_port_msg)) +\n\t\t\t    nla_total_size(sizeof(struct br_mdb_entry)) +\n\t\t\t    nla_total_size(sizeof(u32));\n\tstruct net_bridge_group_src *ent;\n\tsize_t addr_size = 0;\n\n\tif (!pg)\n\t\tgoto out;\n\n\t \n\tnlmsg_size += nla_total_size(sizeof(u8));\n\n\tswitch (pg->key.addr.proto) {\n\tcase htons(ETH_P_IP):\n\t\t \n\t\tif (pg->key.addr.src.ip4)\n\t\t\tnlmsg_size += nla_total_size(sizeof(__be32));\n\t\tif (pg->key.port->br->multicast_ctx.multicast_igmp_version == 2)\n\t\t\tgoto out;\n\t\taddr_size = sizeof(__be32);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\t \n\t\tif (!ipv6_addr_any(&pg->key.addr.src.ip6))\n\t\t\tnlmsg_size += nla_total_size(sizeof(struct in6_addr));\n\t\tif (pg->key.port->br->multicast_ctx.multicast_mld_version == 1)\n\t\t\tgoto out;\n\t\taddr_size = sizeof(struct in6_addr);\n\t\tbreak;\n#endif\n\t}\n\n\t \n\tnlmsg_size += nla_total_size(sizeof(u8));\n\n\t \n\tif (!hlist_empty(&pg->src_list))\n\t\tnlmsg_size += nla_total_size(0);\n\n\thlist_for_each_entry(ent, &pg->src_list, node) {\n\t\t \n\t\tnlmsg_size += nla_total_size(0) +\n\t\t\t      nla_total_size(addr_size) +\n\t\t\t      nla_total_size(sizeof(u32));\n\t}\nout:\n\treturn nlmsg_size;\n}\n\nvoid br_mdb_notify(struct net_device *dev,\n\t\t   struct net_bridge_mdb_entry *mp,\n\t\t   struct net_bridge_port_group *pg,\n\t\t   int type)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tbr_switchdev_mdb_notify(dev, mp, pg, type);\n\n\tskb = nlmsg_new(rtnl_mdb_nlmsg_size(pg), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nlmsg_populate_mdb_fill(skb, dev, mp, pg, type);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_MDB, err);\n}\n\nstatic int nlmsg_populate_rtr_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   int ifindex, u16 vid, u32 pid,\n\t\t\t\t   u32 seq, int type, unsigned int flags)\n{\n\tstruct nlattr *nest, *port_nest;\n\tstruct br_port_msg *bpm;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), 0);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start_noflag(skb, MDBA_ROUTER);\n\tif (!nest)\n\t\tgoto cancel;\n\n\tport_nest = nla_nest_start_noflag(skb, MDBA_ROUTER_PORT);\n\tif (!port_nest)\n\t\tgoto end;\n\tif (nla_put_nohdr(skb, sizeof(u32), &ifindex)) {\n\t\tnla_nest_cancel(skb, port_nest);\n\t\tgoto end;\n\t}\n\tif (vid && nla_put_u16(skb, MDBA_ROUTER_PATTR_VID, vid)) {\n\t\tnla_nest_cancel(skb, port_nest);\n\t\tgoto end;\n\t}\n\tnla_nest_end(skb, port_nest);\n\n\tnla_nest_end(skb, nest);\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t rtnl_rtr_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct br_port_msg))\n\t\t+ nla_total_size(sizeof(__u32))\n\t\t+ nla_total_size(sizeof(u16));\n}\n\nvoid br_rtr_notify(struct net_device *dev, struct net_bridge_mcast_port *pmctx,\n\t\t   int type)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\tint ifindex;\n\tu16 vid;\n\n\tifindex = pmctx ? pmctx->port->dev->ifindex : 0;\n\tvid = pmctx && br_multicast_port_ctx_is_vlan(pmctx) ? pmctx->vlan->vid :\n\t\t\t\t\t\t\t      0;\n\tskb = nlmsg_new(rtnl_rtr_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nlmsg_populate_rtr_fill(skb, dev, ifindex, vid, 0, 0, type,\n\t\t\t\t      NTF_SELF);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_ATOMIC);\n\treturn;\n\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_MDB, err);\n}\n\nstatic const struct nla_policy\nbr_mdbe_src_list_entry_pol[MDBE_SRCATTR_MAX + 1] = {\n\t[MDBE_SRCATTR_ADDRESS] = NLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t\t\t  sizeof(struct in_addr),\n\t\t\t\t\t\t  sizeof(struct in6_addr)),\n};\n\nstatic const struct nla_policy\nbr_mdbe_src_list_pol[MDBE_SRC_LIST_MAX + 1] = {\n\t[MDBE_SRC_LIST_ENTRY] = NLA_POLICY_NESTED(br_mdbe_src_list_entry_pol),\n};\n\nstatic const struct nla_policy br_mdbe_attrs_pol[MDBE_ATTR_MAX + 1] = {\n\t[MDBE_ATTR_SOURCE] = NLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t\t      sizeof(struct in_addr),\n\t\t\t\t\t      sizeof(struct in6_addr)),\n\t[MDBE_ATTR_GROUP_MODE] = NLA_POLICY_RANGE(NLA_U8, MCAST_EXCLUDE,\n\t\t\t\t\t\t  MCAST_INCLUDE),\n\t[MDBE_ATTR_SRC_LIST] = NLA_POLICY_NESTED(br_mdbe_src_list_pol),\n\t[MDBE_ATTR_RTPROT] = NLA_POLICY_MIN(NLA_U8, RTPROT_STATIC),\n};\n\nstatic bool is_valid_mdb_source(struct nlattr *attr, __be16 proto,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\tif (nla_len(attr) != sizeof(struct in_addr)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv4 invalid source address length\");\n\t\t\treturn false;\n\t\t}\n\t\tif (ipv4_is_multicast(nla_get_in_addr(attr))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv4 multicast source address is not allowed\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6): {\n\t\tstruct in6_addr src;\n\n\t\tif (nla_len(attr) != sizeof(struct in6_addr)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv6 invalid source address length\");\n\t\t\treturn false;\n\t\t}\n\t\tsrc = nla_get_in6_addr(attr);\n\t\tif (ipv6_addr_is_multicast(&src)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv6 multicast source address is not allowed\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid protocol used with source address\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic struct net_bridge_mcast *\n__br_mdb_choose_context(struct net_bridge *br,\n\t\t\tconst struct br_mdb_entry *entry,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_mcast *brmctx = NULL;\n\tstruct net_bridge_vlan *v;\n\n\tif (!br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED)) {\n\t\tbrmctx = &br->multicast_ctx;\n\t\tgoto out;\n\t}\n\n\tif (!entry->vid) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot add an entry without a vlan when vlan snooping is enabled\");\n\t\tgoto out;\n\t}\n\n\tv = br_vlan_find(br_vlan_group(br), entry->vid);\n\tif (!v) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Vlan is not configured\");\n\t\tgoto out;\n\t}\n\tif (br_multicast_ctx_vlan_global_disabled(&v->br_mcast_ctx)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Vlan's multicast processing is disabled\");\n\t\tgoto out;\n\t}\n\tbrmctx = &v->br_mcast_ctx;\nout:\n\treturn brmctx;\n}\n\nstatic int br_mdb_replace_group_sg(const struct br_mdb_config *cfg,\n\t\t\t\t   struct net_bridge_mdb_entry *mp,\n\t\t\t\t   struct net_bridge_port_group *pg,\n\t\t\t\t   struct net_bridge_mcast *brmctx,\n\t\t\t\t   unsigned char flags)\n{\n\tunsigned long now = jiffies;\n\n\tpg->flags = flags;\n\tpg->rt_protocol = cfg->rt_protocol;\n\tif (!(flags & MDB_PG_FLAGS_PERMANENT) && !cfg->src_entry)\n\t\tmod_timer(&pg->timer,\n\t\t\t  now + brmctx->multicast_membership_interval);\n\telse\n\t\tdel_timer(&pg->timer);\n\n\tbr_mdb_notify(cfg->br->dev, mp, pg, RTM_NEWMDB);\n\n\treturn 0;\n}\n\nstatic int br_mdb_add_group_sg(const struct br_mdb_config *cfg,\n\t\t\t       struct net_bridge_mdb_entry *mp,\n\t\t\t       struct net_bridge_mcast *brmctx,\n\t\t\t       unsigned char flags,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_port_group *p;\n\tunsigned long now = jiffies;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, cfg->br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->key.port == cfg->p) {\n\t\t\tif (!(cfg->nlflags & NLM_F_REPLACE)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"(S, G) group is already joined by port\");\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\treturn br_mdb_replace_group_sg(cfg, mp, p, brmctx,\n\t\t\t\t\t\t       flags);\n\t\t}\n\t\tif ((unsigned long)p->key.port < (unsigned long)cfg->p)\n\t\t\tbreak;\n\t}\n\n\tp = br_multicast_new_port_group(cfg->p, &cfg->group, *pp, flags, NULL,\n\t\t\t\t\tMCAST_INCLUDE, cfg->rt_protocol, extack);\n\tif (unlikely(!p))\n\t\treturn -ENOMEM;\n\n\trcu_assign_pointer(*pp, p);\n\tif (!(flags & MDB_PG_FLAGS_PERMANENT) && !cfg->src_entry)\n\t\tmod_timer(&p->timer,\n\t\t\t  now + brmctx->multicast_membership_interval);\n\tbr_mdb_notify(cfg->br->dev, mp, p, RTM_NEWMDB);\n\n\t \n\tif (br_multicast_should_handle_mode(brmctx, cfg->group.proto)) {\n\t\tstruct net_bridge_mdb_entry *star_mp;\n\t\tstruct br_ip star_group;\n\n\t\tstar_group = p->key.addr;\n\t\tmemset(&star_group.src, 0, sizeof(star_group.src));\n\t\tstar_mp = br_mdb_ip_get(cfg->br, &star_group);\n\t\tif (star_mp)\n\t\t\tbr_multicast_sg_add_exclude_ports(star_mp, p);\n\t}\n\n\treturn 0;\n}\n\nstatic int br_mdb_add_group_src_fwd(const struct br_mdb_config *cfg,\n\t\t\t\t    struct br_ip *src_ip,\n\t\t\t\t    struct net_bridge_mcast *brmctx,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_mdb_entry *sgmp;\n\tstruct br_mdb_config sg_cfg;\n\tstruct br_ip sg_ip;\n\tu8 flags = 0;\n\n\tsg_ip = cfg->group;\n\tsg_ip.src = src_ip->src;\n\tsgmp = br_multicast_new_group(cfg->br, &sg_ip);\n\tif (IS_ERR(sgmp)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to add (S, G) MDB entry\");\n\t\treturn PTR_ERR(sgmp);\n\t}\n\n\tif (cfg->entry->state == MDB_PERMANENT)\n\t\tflags |= MDB_PG_FLAGS_PERMANENT;\n\tif (cfg->filter_mode == MCAST_EXCLUDE)\n\t\tflags |= MDB_PG_FLAGS_BLOCKED;\n\n\tmemset(&sg_cfg, 0, sizeof(sg_cfg));\n\tsg_cfg.br = cfg->br;\n\tsg_cfg.p = cfg->p;\n\tsg_cfg.entry = cfg->entry;\n\tsg_cfg.group = sg_ip;\n\tsg_cfg.src_entry = true;\n\tsg_cfg.filter_mode = MCAST_INCLUDE;\n\tsg_cfg.rt_protocol = cfg->rt_protocol;\n\tsg_cfg.nlflags = cfg->nlflags;\n\treturn br_mdb_add_group_sg(&sg_cfg, sgmp, brmctx, flags, extack);\n}\n\nstatic int br_mdb_add_group_src(const struct br_mdb_config *cfg,\n\t\t\t\tstruct net_bridge_port_group *pg,\n\t\t\t\tstruct net_bridge_mcast *brmctx,\n\t\t\t\tstruct br_mdb_src_entry *src,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_group_src *ent;\n\tunsigned long now = jiffies;\n\tint err;\n\n\tent = br_multicast_find_group_src(pg, &src->addr);\n\tif (!ent) {\n\t\tent = br_multicast_new_group_src(pg, &src->addr);\n\t\tif (!ent) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to add new source entry\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\t} else if (!(cfg->nlflags & NLM_F_REPLACE)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Source entry already exists\");\n\t\treturn -EEXIST;\n\t}\n\n\tif (cfg->filter_mode == MCAST_INCLUDE &&\n\t    cfg->entry->state == MDB_TEMPORARY)\n\t\tmod_timer(&ent->timer, now + br_multicast_gmi(brmctx));\n\telse\n\t\tdel_timer(&ent->timer);\n\n\t \n\terr = br_mdb_add_group_src_fwd(cfg, &src->addr, brmctx, extack);\n\tif (err)\n\t\tgoto err_del_sg;\n\n\tent->flags = BR_SGRP_F_INSTALLED | BR_SGRP_F_USER_ADDED;\n\n\treturn 0;\n\nerr_del_sg:\n\t__br_multicast_del_group_src(ent);\n\treturn err;\n}\n\nstatic void br_mdb_del_group_src(struct net_bridge_port_group *pg,\n\t\t\t\t struct br_mdb_src_entry *src)\n{\n\tstruct net_bridge_group_src *ent;\n\n\tent = br_multicast_find_group_src(pg, &src->addr);\n\tif (WARN_ON_ONCE(!ent))\n\t\treturn;\n\tbr_multicast_del_group_src(ent, false);\n}\n\nstatic int br_mdb_add_group_srcs(const struct br_mdb_config *cfg,\n\t\t\t\t struct net_bridge_port_group *pg,\n\t\t\t\t struct net_bridge_mcast *brmctx,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint i, err;\n\n\tfor (i = 0; i < cfg->num_src_entries; i++) {\n\t\terr = br_mdb_add_group_src(cfg, pg, brmctx,\n\t\t\t\t\t   &cfg->src_entries[i], extack);\n\t\tif (err)\n\t\t\tgoto err_del_group_srcs;\n\t}\n\n\treturn 0;\n\nerr_del_group_srcs:\n\tfor (i--; i >= 0; i--)\n\t\tbr_mdb_del_group_src(pg, &cfg->src_entries[i]);\n\treturn err;\n}\n\nstatic int br_mdb_replace_group_srcs(const struct br_mdb_config *cfg,\n\t\t\t\t     struct net_bridge_port_group *pg,\n\t\t\t\t     struct net_bridge_mcast *brmctx,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_group_src *ent;\n\tstruct hlist_node *tmp;\n\tint err;\n\n\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\tent->flags |= BR_SGRP_F_DELETE;\n\n\terr = br_mdb_add_group_srcs(cfg, pg, brmctx, extack);\n\tif (err)\n\t\tgoto err_clear_delete;\n\n\thlist_for_each_entry_safe(ent, tmp, &pg->src_list, node) {\n\t\tif (ent->flags & BR_SGRP_F_DELETE)\n\t\t\tbr_multicast_del_group_src(ent, false);\n\t}\n\n\treturn 0;\n\nerr_clear_delete:\n\thlist_for_each_entry(ent, &pg->src_list, node)\n\t\tent->flags &= ~BR_SGRP_F_DELETE;\n\treturn err;\n}\n\nstatic int br_mdb_replace_group_star_g(const struct br_mdb_config *cfg,\n\t\t\t\t       struct net_bridge_mdb_entry *mp,\n\t\t\t\t       struct net_bridge_port_group *pg,\n\t\t\t\t       struct net_bridge_mcast *brmctx,\n\t\t\t\t       unsigned char flags,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tunsigned long now = jiffies;\n\tint err;\n\n\terr = br_mdb_replace_group_srcs(cfg, pg, brmctx, extack);\n\tif (err)\n\t\treturn err;\n\n\tpg->flags = flags;\n\tpg->filter_mode = cfg->filter_mode;\n\tpg->rt_protocol = cfg->rt_protocol;\n\tif (!(flags & MDB_PG_FLAGS_PERMANENT) &&\n\t    cfg->filter_mode == MCAST_EXCLUDE)\n\t\tmod_timer(&pg->timer,\n\t\t\t  now + brmctx->multicast_membership_interval);\n\telse\n\t\tdel_timer(&pg->timer);\n\n\tbr_mdb_notify(cfg->br->dev, mp, pg, RTM_NEWMDB);\n\n\tif (br_multicast_should_handle_mode(brmctx, cfg->group.proto))\n\t\tbr_multicast_star_g_handle_mode(pg, cfg->filter_mode);\n\n\treturn 0;\n}\n\nstatic int br_mdb_add_group_star_g(const struct br_mdb_config *cfg,\n\t\t\t\t   struct net_bridge_mdb_entry *mp,\n\t\t\t\t   struct net_bridge_mcast *brmctx,\n\t\t\t\t   unsigned char flags,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_port_group *p;\n\tunsigned long now = jiffies;\n\tint err;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, cfg->br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->key.port == cfg->p) {\n\t\t\tif (!(cfg->nlflags & NLM_F_REPLACE)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"(*, G) group is already joined by port\");\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\treturn br_mdb_replace_group_star_g(cfg, mp, p, brmctx,\n\t\t\t\t\t\t\t   flags, extack);\n\t\t}\n\t\tif ((unsigned long)p->key.port < (unsigned long)cfg->p)\n\t\t\tbreak;\n\t}\n\n\tp = br_multicast_new_port_group(cfg->p, &cfg->group, *pp, flags, NULL,\n\t\t\t\t\tcfg->filter_mode, cfg->rt_protocol,\n\t\t\t\t\textack);\n\tif (unlikely(!p))\n\t\treturn -ENOMEM;\n\n\terr = br_mdb_add_group_srcs(cfg, p, brmctx, extack);\n\tif (err)\n\t\tgoto err_del_port_group;\n\n\trcu_assign_pointer(*pp, p);\n\tif (!(flags & MDB_PG_FLAGS_PERMANENT) &&\n\t    cfg->filter_mode == MCAST_EXCLUDE)\n\t\tmod_timer(&p->timer,\n\t\t\t  now + brmctx->multicast_membership_interval);\n\tbr_mdb_notify(cfg->br->dev, mp, p, RTM_NEWMDB);\n\t \n\tif (br_multicast_should_handle_mode(brmctx, cfg->group.proto) &&\n\t    cfg->filter_mode == MCAST_EXCLUDE)\n\t\tbr_multicast_star_g_handle_mode(p, MCAST_EXCLUDE);\n\n\treturn 0;\n\nerr_del_port_group:\n\tbr_multicast_del_port_group(p);\n\treturn err;\n}\n\nstatic int br_mdb_add_group(const struct br_mdb_config *cfg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct br_mdb_entry *entry = cfg->entry;\n\tstruct net_bridge_port *port = cfg->p;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge *br = cfg->br;\n\tstruct net_bridge_mcast *brmctx;\n\tstruct br_ip group = cfg->group;\n\tunsigned char flags = 0;\n\n\tbrmctx = __br_mdb_choose_context(br, entry, extack);\n\tif (!brmctx)\n\t\treturn -EINVAL;\n\n\tmp = br_multicast_new_group(br, &group);\n\tif (IS_ERR(mp))\n\t\treturn PTR_ERR(mp);\n\n\t \n\tif (!port) {\n\t\tif (mp->host_joined) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Group is already joined by host\");\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tbr_multicast_host_join(brmctx, mp, false);\n\t\tbr_mdb_notify(br->dev, mp, NULL, RTM_NEWMDB);\n\n\t\treturn 0;\n\t}\n\n\tif (entry->state == MDB_PERMANENT)\n\t\tflags |= MDB_PG_FLAGS_PERMANENT;\n\n\tif (br_multicast_is_star_g(&group))\n\t\treturn br_mdb_add_group_star_g(cfg, mp, brmctx, flags, extack);\n\telse\n\t\treturn br_mdb_add_group_sg(cfg, mp, brmctx, flags, extack);\n}\n\nstatic int __br_mdb_add(const struct br_mdb_config *cfg,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint ret;\n\n\tspin_lock_bh(&cfg->br->multicast_lock);\n\tret = br_mdb_add_group(cfg, extack);\n\tspin_unlock_bh(&cfg->br->multicast_lock);\n\n\treturn ret;\n}\n\nstatic int br_mdb_config_src_entry_init(struct nlattr *src_entry,\n\t\t\t\t\tstruct br_mdb_src_entry *src,\n\t\t\t\t\t__be16 proto,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[MDBE_SRCATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, MDBE_SRCATTR_MAX, src_entry,\n\t\t\t       br_mdbe_src_list_entry_pol, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (NL_REQ_ATTR_CHECK(extack, src_entry, tb, MDBE_SRCATTR_ADDRESS))\n\t\treturn -EINVAL;\n\n\tif (!is_valid_mdb_source(tb[MDBE_SRCATTR_ADDRESS], proto, extack))\n\t\treturn -EINVAL;\n\n\tsrc->addr.proto = proto;\n\tnla_memcpy(&src->addr.src, tb[MDBE_SRCATTR_ADDRESS],\n\t\t   nla_len(tb[MDBE_SRCATTR_ADDRESS]));\n\n\treturn 0;\n}\n\nstatic int br_mdb_config_src_list_init(struct nlattr *src_list,\n\t\t\t\t       struct br_mdb_config *cfg,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *src_entry;\n\tint rem, err;\n\tint i = 0;\n\n\tnla_for_each_nested(src_entry, src_list, rem)\n\t\tcfg->num_src_entries++;\n\n\tif (cfg->num_src_entries >= PG_SRC_ENT_LIMIT) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"Exceeded maximum number of source entries (%u)\",\n\t\t\t\t       PG_SRC_ENT_LIMIT - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tcfg->src_entries = kcalloc(cfg->num_src_entries,\n\t\t\t\t   sizeof(struct br_mdb_src_entry), GFP_KERNEL);\n\tif (!cfg->src_entries)\n\t\treturn -ENOMEM;\n\n\tnla_for_each_nested(src_entry, src_list, rem) {\n\t\terr = br_mdb_config_src_entry_init(src_entry,\n\t\t\t\t\t\t   &cfg->src_entries[i],\n\t\t\t\t\t\t   cfg->entry->addr.proto,\n\t\t\t\t\t\t   extack);\n\t\tif (err)\n\t\t\tgoto err_src_entry_init;\n\t\ti++;\n\t}\n\n\treturn 0;\n\nerr_src_entry_init:\n\tkfree(cfg->src_entries);\n\treturn err;\n}\n\nstatic void br_mdb_config_src_list_fini(struct br_mdb_config *cfg)\n{\n\tkfree(cfg->src_entries);\n}\n\nstatic int br_mdb_config_attrs_init(struct nlattr *set_attrs,\n\t\t\t\t    struct br_mdb_config *cfg,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *mdb_attrs[MDBE_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(mdb_attrs, MDBE_ATTR_MAX, set_attrs,\n\t\t\t       br_mdbe_attrs_pol, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (mdb_attrs[MDBE_ATTR_SOURCE] &&\n\t    !is_valid_mdb_source(mdb_attrs[MDBE_ATTR_SOURCE],\n\t\t\t\t cfg->entry->addr.proto, extack))\n\t\treturn -EINVAL;\n\n\t__mdb_entry_to_br_ip(cfg->entry, &cfg->group, mdb_attrs);\n\n\tif (mdb_attrs[MDBE_ATTR_GROUP_MODE]) {\n\t\tif (!cfg->p) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Filter mode cannot be set for host groups\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!br_multicast_is_star_g(&cfg->group)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Filter mode can only be set for (*, G) entries\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcfg->filter_mode = nla_get_u8(mdb_attrs[MDBE_ATTR_GROUP_MODE]);\n\t} else {\n\t\tcfg->filter_mode = MCAST_EXCLUDE;\n\t}\n\n\tif (mdb_attrs[MDBE_ATTR_SRC_LIST]) {\n\t\tif (!cfg->p) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Source list cannot be set for host groups\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!br_multicast_is_star_g(&cfg->group)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Source list can only be set for (*, G) entries\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!mdb_attrs[MDBE_ATTR_GROUP_MODE]) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Source list cannot be set without filter mode\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = br_mdb_config_src_list_init(mdb_attrs[MDBE_ATTR_SRC_LIST],\n\t\t\t\t\t\t  cfg, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!cfg->num_src_entries && cfg->filter_mode == MCAST_INCLUDE) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot add (*, G) INCLUDE with an empty source list\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mdb_attrs[MDBE_ATTR_RTPROT]) {\n\t\tif (!cfg->p) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Protocol cannot be set for host groups\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcfg->rt_protocol = nla_get_u8(mdb_attrs[MDBE_ATTR_RTPROT]);\n\t}\n\n\treturn 0;\n}\n\nstatic int br_mdb_config_init(struct br_mdb_config *cfg, struct net_device *dev,\n\t\t\t      struct nlattr *tb[], u16 nlmsg_flags,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net *net = dev_net(dev);\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\tcfg->filter_mode = MCAST_EXCLUDE;\n\tcfg->rt_protocol = RTPROT_STATIC;\n\tcfg->nlflags = nlmsg_flags;\n\n\tcfg->br = netdev_priv(dev);\n\n\tif (!netif_running(cfg->br->dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Bridge device is not running\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!br_opt_get(cfg->br, BROPT_MULTICAST_ENABLED)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Bridge's multicast processing is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tcfg->entry = nla_data(tb[MDBA_SET_ENTRY]);\n\n\tif (cfg->entry->ifindex != cfg->br->dev->ifindex) {\n\t\tstruct net_device *pdev;\n\n\t\tpdev = __dev_get_by_index(net, cfg->entry->ifindex);\n\t\tif (!pdev) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Port net device doesn't exist\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tcfg->p = br_port_get_rtnl(pdev);\n\t\tif (!cfg->p) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Net device is not a bridge port\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (cfg->p->br != cfg->br) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Port belongs to a different bridge device\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (cfg->entry->addr.proto == htons(ETH_P_IP) &&\n\t    ipv4_is_zeronet(cfg->entry->addr.u.ip4)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv4 entry group address 0.0.0.0 is not allowed\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[MDBA_SET_ENTRY_ATTRS])\n\t\treturn br_mdb_config_attrs_init(tb[MDBA_SET_ENTRY_ATTRS], cfg,\n\t\t\t\t\t\textack);\n\telse\n\t\t__mdb_entry_to_br_ip(cfg->entry, &cfg->group, NULL);\n\n\treturn 0;\n}\n\nstatic void br_mdb_config_fini(struct br_mdb_config *cfg)\n{\n\tbr_mdb_config_src_list_fini(cfg);\n}\n\nint br_mdb_add(struct net_device *dev, struct nlattr *tb[], u16 nlmsg_flags,\n\t       struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\tstruct br_mdb_config cfg;\n\tint err;\n\n\terr = br_mdb_config_init(&cfg, dev, tb, nlmsg_flags, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\t \n\tif (!cfg.p && !br_group_is_l2(&cfg.group)) {\n\t\t \n\t\tif (cfg.entry->state) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Flags are not allowed for host groups\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (!br_multicast_is_star_g(&cfg.group)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Groups with sources cannot be manually host joined\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (br_group_is_l2(&cfg.group) && cfg.entry->state != MDB_PERMANENT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only permanent L2 entries allowed\");\n\t\tgoto out;\n\t}\n\n\tif (cfg.p) {\n\t\tif (cfg.p->state == BR_STATE_DISABLED && cfg.entry->state != MDB_PERMANENT) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Port is in disabled state and entry is not permanent\");\n\t\t\tgoto out;\n\t\t}\n\t\tvg = nbp_vlan_group(cfg.p);\n\t} else {\n\t\tvg = br_vlan_group(cfg.br);\n\t}\n\n\t \n\tif (br_vlan_enabled(cfg.br->dev) && vg && cfg.entry->vid == 0) {\n\t\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\t\tcfg.entry->vid = v->vid;\n\t\t\tcfg.group.vid = v->vid;\n\t\t\terr = __br_mdb_add(&cfg, extack);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\terr = __br_mdb_add(&cfg, extack);\n\t}\n\nout:\n\tbr_mdb_config_fini(&cfg);\n\treturn err;\n}\n\nstatic int __br_mdb_del(const struct br_mdb_config *cfg)\n{\n\tstruct br_mdb_entry *entry = cfg->entry;\n\tstruct net_bridge *br = cfg->br;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip = cfg->group;\n\tint err = -EINVAL;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmp = br_mdb_ip_get(br, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\n\t \n\tif (entry->ifindex == mp->br->dev->ifindex && mp->host_joined) {\n\t\tbr_multicast_host_leave(mp, false);\n\t\terr = 0;\n\t\tbr_mdb_notify(br->dev, mp, NULL, RTM_DELMDB);\n\t\tif (!mp->ports && netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tgoto unlock;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->key.port || p->key.port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\n\t\tbr_multicast_del_pg(mp, p, pp);\n\t\terr = 0;\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}\n\nint br_mdb_del(struct net_device *dev, struct nlattr *tb[],\n\t       struct netlink_ext_ack *extack)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\tstruct br_mdb_config cfg;\n\tint err;\n\n\terr = br_mdb_config_init(&cfg, dev, tb, 0, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (cfg.p)\n\t\tvg = nbp_vlan_group(cfg.p);\n\telse\n\t\tvg = br_vlan_group(cfg.br);\n\n\t \n\tif (br_vlan_enabled(cfg.br->dev) && vg && cfg.entry->vid == 0) {\n\t\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\t\tcfg.entry->vid = v->vid;\n\t\t\tcfg.group.vid = v->vid;\n\t\t\terr = __br_mdb_del(&cfg);\n\t\t}\n\t} else {\n\t\terr = __br_mdb_del(&cfg);\n\t}\n\n\tbr_mdb_config_fini(&cfg);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}