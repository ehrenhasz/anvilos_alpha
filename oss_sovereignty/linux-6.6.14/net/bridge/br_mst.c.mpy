{
  "module_name": "br_mst.c",
  "hash_id": "3d1bf9f9553ccf6a8190b511b47b1c29c3cec9f2bf801b3a09ae759800263e82",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_mst.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <net/switchdev.h>\n\n#include \"br_private.h\"\n\nDEFINE_STATIC_KEY_FALSE(br_mst_used);\n\nbool br_mst_enabled(const struct net_device *dev)\n{\n\tif (!netif_is_bridge_master(dev))\n\t\treturn false;\n\n\treturn br_opt_get(netdev_priv(dev), BROPT_MST_ENABLED);\n}\nEXPORT_SYMBOL_GPL(br_mst_enabled);\n\nint br_mst_get_info(const struct net_device *dev, u16 msti, unsigned long *vids)\n{\n\tconst struct net_bridge_vlan_group *vg;\n\tconst struct net_bridge_vlan *v;\n\tconst struct net_bridge *br;\n\n\tASSERT_RTNL();\n\n\tif (!netif_is_bridge_master(dev))\n\t\treturn -EINVAL;\n\n\tbr = netdev_priv(dev);\n\tif (!br_opt_get(br, BROPT_MST_ENABLED))\n\t\treturn -EINVAL;\n\n\tvg = br_vlan_group(br);\n\n\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\tif (v->msti == msti)\n\t\t\t__set_bit(v->vid, vids);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(br_mst_get_info);\n\nint br_mst_get_state(const struct net_device *dev, u16 msti, u8 *state)\n{\n\tconst struct net_bridge_port *p = NULL;\n\tconst struct net_bridge_vlan_group *vg;\n\tconst struct net_bridge_vlan *v;\n\n\tASSERT_RTNL();\n\n\tp = br_port_get_check_rtnl(dev);\n\tif (!p || !br_opt_get(p->br, BROPT_MST_ENABLED))\n\t\treturn -EINVAL;\n\n\tvg = nbp_vlan_group(p);\n\n\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\tif (v->brvlan->msti == msti) {\n\t\t\t*state = v->state;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(br_mst_get_state);\n\nstatic void br_mst_vlan_set_state(struct net_bridge_port *p, struct net_bridge_vlan *v,\n\t\t\t\t  u8 state)\n{\n\tstruct net_bridge_vlan_group *vg = nbp_vlan_group(p);\n\n\tif (v->state == state)\n\t\treturn;\n\n\tbr_vlan_set_state(v, state);\n\n\tif (v->vid == vg->pvid)\n\t\tbr_vlan_set_pvid_state(vg, state);\n}\n\nint br_mst_set_state(struct net_bridge_port *p, u16 msti, u8 state,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_attr attr = {\n\t\t.id = SWITCHDEV_ATTR_ID_PORT_MST_STATE,\n\t\t.orig_dev = p->dev,\n\t\t.u.mst_state = {\n\t\t\t.msti = msti,\n\t\t\t.state = state,\n\t\t},\n\t};\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\tint err;\n\n\tvg = nbp_vlan_group(p);\n\tif (!vg)\n\t\treturn 0;\n\n\t \n\tif (msti) {\n\t\terr = switchdev_port_attr_set(p->dev, &attr, extack);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\tif (v->brvlan->msti != msti)\n\t\t\tcontinue;\n\n\t\tbr_mst_vlan_set_state(p, v, state);\n\t}\n\n\treturn 0;\n}\n\nstatic void br_mst_vlan_sync_state(struct net_bridge_vlan *pv, u16 msti)\n{\n\tstruct net_bridge_vlan_group *vg = nbp_vlan_group(pv->port);\n\tstruct net_bridge_vlan *v;\n\n\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\t \n\t\tif (v != pv && v->brvlan->msti == msti) {\n\t\t\tbr_mst_vlan_set_state(pv->port, pv, v->state);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\treturn br_mst_vlan_set_state(pv->port, pv, BR_STATE_DISABLED);\n}\n\nint br_mst_vlan_set_msti(struct net_bridge_vlan *mv, u16 msti)\n{\n\tstruct switchdev_attr attr = {\n\t\t.id = SWITCHDEV_ATTR_ID_VLAN_MSTI,\n\t\t.orig_dev = mv->br->dev,\n\t\t.u.vlan_msti = {\n\t\t\t.vid = mv->vid,\n\t\t\t.msti = msti,\n\t\t},\n\t};\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *pv;\n\tstruct net_bridge_port *p;\n\tint err;\n\n\tif (mv->msti == msti)\n\t\treturn 0;\n\n\terr = switchdev_port_attr_set(mv->br->dev, &attr, NULL);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\tmv->msti = msti;\n\n\tlist_for_each_entry(p, &mv->br->port_list, list) {\n\t\tvg = nbp_vlan_group(p);\n\n\t\tpv = br_vlan_find(vg, mv->vid);\n\t\tif (pv)\n\t\t\tbr_mst_vlan_sync_state(pv, msti);\n\t}\n\n\treturn 0;\n}\n\nvoid br_mst_vlan_init_state(struct net_bridge_vlan *v)\n{\n\t \n\tv->msti = 0;\n\n\tif (br_vlan_is_master(v))\n\t\tv->state = BR_STATE_FORWARDING;\n\telse\n\t\tv->state = v->port->state;\n}\n\nint br_mst_set_enabled(struct net_bridge *br, bool on,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_attr attr = {\n\t\t.id = SWITCHDEV_ATTR_ID_BRIDGE_MST,\n\t\t.orig_dev = br->dev,\n\t\t.u.mst = on,\n\t};\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_port *p;\n\tint err;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tvg = nbp_vlan_group(p);\n\n\t\tif (!vg->num_vlans)\n\t\t\tcontinue;\n\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"MST mode can't be changed while VLANs exist\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (br_opt_get(br, BROPT_MST_ENABLED) == on)\n\t\treturn 0;\n\n\terr = switchdev_port_attr_set(br->dev, &attr, extack);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\tif (on)\n\t\tstatic_branch_enable(&br_mst_used);\n\telse\n\t\tstatic_branch_disable(&br_mst_used);\n\n\tbr_opt_toggle(br, BROPT_MST_ENABLED, on);\n\treturn 0;\n}\n\nsize_t br_mst_info_size(const struct net_bridge_vlan_group *vg)\n{\n\tDECLARE_BITMAP(seen, VLAN_N_VID) = { 0 };\n\tconst struct net_bridge_vlan *v;\n\tsize_t sz;\n\n\t \n\tsz = nla_total_size(0);\n\n\tlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\n\t\tif (test_bit(v->brvlan->msti, seen))\n\t\t\tcontinue;\n\n\t\t \n\t\tsz += nla_total_size(0) +\n\t\t\t \n\t\t\tnla_total_size(sizeof(u16)) +\n\t\t\t \n\t\t\tnla_total_size(sizeof(u8));\n\n\t\t__set_bit(v->brvlan->msti, seen);\n\t}\n\n\treturn sz;\n}\n\nint br_mst_fill_info(struct sk_buff *skb,\n\t\t     const struct net_bridge_vlan_group *vg)\n{\n\tDECLARE_BITMAP(seen, VLAN_N_VID) = { 0 };\n\tconst struct net_bridge_vlan *v;\n\tstruct nlattr *nest;\n\tint err = 0;\n\n\tlist_for_each_entry(v, &vg->vlan_list, vlist) {\n\t\tif (test_bit(v->brvlan->msti, seen))\n\t\t\tcontinue;\n\n\t\tnest = nla_nest_start_noflag(skb, IFLA_BRIDGE_MST_ENTRY);\n\t\tif (!nest ||\n\t\t    nla_put_u16(skb, IFLA_BRIDGE_MST_ENTRY_MSTI, v->brvlan->msti) ||\n\t\t    nla_put_u8(skb, IFLA_BRIDGE_MST_ENTRY_STATE, v->state)) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\n\t\t__set_bit(v->brvlan->msti, seen);\n\t}\n\n\treturn err;\n}\n\nstatic const struct nla_policy br_mst_nl_policy[IFLA_BRIDGE_MST_ENTRY_MAX + 1] = {\n\t[IFLA_BRIDGE_MST_ENTRY_MSTI] = NLA_POLICY_RANGE(NLA_U16,\n\t\t\t\t\t\t   1,  \n\t\t\t\t\t\t   VLAN_N_VID - 1),\n\t[IFLA_BRIDGE_MST_ENTRY_STATE] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\t    BR_STATE_DISABLED,\n\t\t\t\t\t\t    BR_STATE_BLOCKING),\n};\n\nstatic int br_mst_process_one(struct net_bridge_port *p,\n\t\t\t      const struct nlattr *attr,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_MST_ENTRY_MAX + 1];\n\tu16 msti;\n\tu8 state;\n\tint err;\n\n\terr = nla_parse_nested(tb, IFLA_BRIDGE_MST_ENTRY_MAX, attr,\n\t\t\t       br_mst_nl_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_MST_ENTRY_MSTI]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MSTI not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tb[IFLA_BRIDGE_MST_ENTRY_STATE]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"State not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tmsti = nla_get_u16(tb[IFLA_BRIDGE_MST_ENTRY_MSTI]);\n\tstate = nla_get_u8(tb[IFLA_BRIDGE_MST_ENTRY_STATE]);\n\n\treturn br_mst_set_state(p, msti, state, extack);\n}\n\nint br_mst_process(struct net_bridge_port *p, const struct nlattr *mst_attr,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *attr;\n\tint err, msts = 0;\n\tint rem;\n\n\tif (!br_opt_get(p->br, BROPT_MST_ENABLED)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't modify MST state when MST is disabled\");\n\t\treturn -EBUSY;\n\t}\n\n\tnla_for_each_nested(attr, mst_attr, rem) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase IFLA_BRIDGE_MST_ENTRY:\n\t\t\terr = br_mst_process_one(p, attr, extack);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tmsts++;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!msts) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Found no MST entries to process\");\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}