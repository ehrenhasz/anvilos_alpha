{
  "module_name": "br_netlink_tunnel.c",
  "hash_id": "4401480f71d1a4e48a9e9cfd7a28187cdc353648783a63444bb9e0e43a30adb5",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br_netlink_tunnel.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/etherdevice.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <uapi/linux/if_bridge.h>\n#include <net/dst_metadata.h>\n\n#include \"br_private.h\"\n#include \"br_private_tunnel.h\"\n\nstatic size_t __get_vlan_tinfo_size(void)\n{\n\treturn nla_total_size(0) +  \n\t\t  nla_total_size(sizeof(u32)) +  \n\t\t  nla_total_size(sizeof(u16)) +  \n\t\t  nla_total_size(sizeof(u16));  \n}\n\nbool vlan_tunid_inrange(const struct net_bridge_vlan *v_curr,\n\t\t\tconst struct net_bridge_vlan *v_last)\n{\n\t__be32 tunid_curr = tunnel_id_to_key32(v_curr->tinfo.tunnel_id);\n\t__be32 tunid_last = tunnel_id_to_key32(v_last->tinfo.tunnel_id);\n\n\treturn (be32_to_cpu(tunid_curr) - be32_to_cpu(tunid_last)) == 1;\n}\n\nstatic int __get_num_vlan_tunnel_infos(struct net_bridge_vlan_group *vg)\n{\n\tstruct net_bridge_vlan *v, *vtbegin = NULL, *vtend = NULL;\n\tint num_tinfos = 0;\n\n\t \n\tlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\n\t\t \n\t\tif (!br_vlan_should_use(v) || !v->tinfo.tunnel_id)\n\t\t\tcontinue;\n\n\t\tif (!vtbegin) {\n\t\t\tgoto initvars;\n\t\t} else if ((v->vid - vtend->vid) == 1 &&\n\t\t\t   vlan_tunid_inrange(v, vtend)) {\n\t\t\tvtend = v;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif ((vtend->vid - vtbegin->vid) > 0)\n\t\t\t\tnum_tinfos += 2;\n\t\t\telse\n\t\t\t\tnum_tinfos += 1;\n\t\t}\ninitvars:\n\t\tvtbegin = v;\n\t\tvtend = v;\n\t}\n\n\tif (vtbegin && vtend) {\n\t\tif ((vtend->vid - vtbegin->vid) > 0)\n\t\t\tnum_tinfos += 2;\n\t\telse\n\t\t\tnum_tinfos += 1;\n\t}\n\n\treturn num_tinfos;\n}\n\nint br_get_vlan_tunnel_info_size(struct net_bridge_vlan_group *vg)\n{\n\tint num_tinfos;\n\n\tif (!vg)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tnum_tinfos = __get_num_vlan_tunnel_infos(vg);\n\trcu_read_unlock();\n\n\treturn num_tinfos * __get_vlan_tinfo_size();\n}\n\nstatic int br_fill_vlan_tinfo(struct sk_buff *skb, u16 vid,\n\t\t\t      __be64 tunnel_id, u16 flags)\n{\n\t__be32 tid = tunnel_id_to_key32(tunnel_id);\n\tstruct nlattr *tmap;\n\n\ttmap = nla_nest_start_noflag(skb, IFLA_BRIDGE_VLAN_TUNNEL_INFO);\n\tif (!tmap)\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u32(skb, IFLA_BRIDGE_VLAN_TUNNEL_ID,\n\t\t\tbe32_to_cpu(tid)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(skb, IFLA_BRIDGE_VLAN_TUNNEL_VID,\n\t\t\tvid))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(skb, IFLA_BRIDGE_VLAN_TUNNEL_FLAGS,\n\t\t\tflags))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, tmap);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, tmap);\n\n\treturn -EMSGSIZE;\n}\n\nstatic int br_fill_vlan_tinfo_range(struct sk_buff *skb,\n\t\t\t\t    struct net_bridge_vlan *vtbegin,\n\t\t\t\t    struct net_bridge_vlan *vtend)\n{\n\tint err;\n\n\tif (vtend && (vtend->vid - vtbegin->vid) > 0) {\n\t\t \n\t\terr = br_fill_vlan_tinfo(skb, vtbegin->vid,\n\t\t\t\t\t vtbegin->tinfo.tunnel_id,\n\t\t\t\t\t BRIDGE_VLAN_INFO_RANGE_BEGIN);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = br_fill_vlan_tinfo(skb, vtend->vid,\n\t\t\t\t\t vtend->tinfo.tunnel_id,\n\t\t\t\t\t BRIDGE_VLAN_INFO_RANGE_END);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = br_fill_vlan_tinfo(skb, vtbegin->vid,\n\t\t\t\t\t vtbegin->tinfo.tunnel_id,\n\t\t\t\t\t 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint br_fill_vlan_tunnel_info(struct sk_buff *skb,\n\t\t\t     struct net_bridge_vlan_group *vg)\n{\n\tstruct net_bridge_vlan *vtbegin = NULL;\n\tstruct net_bridge_vlan *vtend = NULL;\n\tstruct net_bridge_vlan *v;\n\tint err;\n\n\t \n\tlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\n\t\t \n\t\tif (!br_vlan_should_use(v))\n\t\t\tcontinue;\n\n\t\tif (!v->tinfo.tunnel_dst)\n\t\t\tcontinue;\n\n\t\tif (!vtbegin) {\n\t\t\tgoto initvars;\n\t\t} else if ((v->vid - vtend->vid) == 1 &&\n\t\t\t    vlan_tunid_inrange(v, vtend)) {\n\t\t\tvtend = v;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\terr = br_fill_vlan_tinfo_range(skb, vtbegin, vtend);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\ninitvars:\n\t\tvtbegin = v;\n\t\tvtend = v;\n\t}\n\n\tif (vtbegin) {\n\t\terr = br_fill_vlan_tinfo_range(skb, vtbegin, vtend);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nla_policy vlan_tunnel_policy[IFLA_BRIDGE_VLAN_TUNNEL_MAX + 1] = {\n\t[IFLA_BRIDGE_VLAN_TUNNEL_UNSPEC] = {\n\t\t.strict_start_type = IFLA_BRIDGE_VLAN_TUNNEL_FLAGS + 1\n\t},\n\t[IFLA_BRIDGE_VLAN_TUNNEL_ID] = { .type = NLA_U32 },\n\t[IFLA_BRIDGE_VLAN_TUNNEL_VID] = { .type = NLA_U16 },\n\t[IFLA_BRIDGE_VLAN_TUNNEL_FLAGS] = { .type = NLA_U16 },\n};\n\nint br_vlan_tunnel_info(const struct net_bridge_port *p, int cmd,\n\t\t\tu16 vid, u32 tun_id, bool *changed)\n{\n\tint err = 0;\n\n\tif (!p)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase RTM_SETLINK:\n\t\terr = nbp_vlan_tunnel_info_add(p, vid, tun_id);\n\t\tif (!err)\n\t\t\t*changed = true;\n\t\tbreak;\n\tcase RTM_DELLINK:\n\t\tif (!nbp_vlan_tunnel_info_delete(p, vid))\n\t\t\t*changed = true;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint br_parse_vlan_tunnel_info(struct nlattr *attr,\n\t\t\t      struct vtunnel_info *tinfo)\n{\n\tstruct nlattr *tb[IFLA_BRIDGE_VLAN_TUNNEL_MAX + 1];\n\tu32 tun_id;\n\tu16 vid, flags = 0;\n\tint err;\n\n\tmemset(tinfo, 0, sizeof(*tinfo));\n\n\terr = nla_parse_nested_deprecated(tb, IFLA_BRIDGE_VLAN_TUNNEL_MAX,\n\t\t\t\t\t  attr, vlan_tunnel_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[IFLA_BRIDGE_VLAN_TUNNEL_ID] ||\n\t    !tb[IFLA_BRIDGE_VLAN_TUNNEL_VID])\n\t\treturn -EINVAL;\n\n\ttun_id = nla_get_u32(tb[IFLA_BRIDGE_VLAN_TUNNEL_ID]);\n\tvid = nla_get_u16(tb[IFLA_BRIDGE_VLAN_TUNNEL_VID]);\n\tif (vid >= VLAN_VID_MASK)\n\t\treturn -ERANGE;\n\n\tif (tb[IFLA_BRIDGE_VLAN_TUNNEL_FLAGS])\n\t\tflags = nla_get_u16(tb[IFLA_BRIDGE_VLAN_TUNNEL_FLAGS]);\n\n\ttinfo->tunid = tun_id;\n\ttinfo->vid = vid;\n\ttinfo->flags = flags;\n\n\treturn 0;\n}\n\n \nstatic void __vlan_tunnel_handle_range(const struct net_bridge_port *p,\n\t\t\t\t       struct net_bridge_vlan **v_start,\n\t\t\t\t       struct net_bridge_vlan **v_end,\n\t\t\t\t       int v_curr, bool curr_change)\n{\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\n\tvg = nbp_vlan_group(p);\n\tif (!vg)\n\t\treturn;\n\n\tv = br_vlan_find(vg, v_curr);\n\n\tif (!*v_start)\n\t\tgoto out_init;\n\n\tif (v && curr_change && br_vlan_can_enter_range(v, *v_end)) {\n\t\t*v_end = v;\n\t\treturn;\n\t}\n\n\tbr_vlan_notify(p->br, p, (*v_start)->vid, (*v_end)->vid, RTM_NEWVLAN);\nout_init:\n\t \n\t*v_start = curr_change ? v : NULL;\n\t*v_end = *v_start;\n}\n\nint br_process_vlan_tunnel_info(const struct net_bridge *br,\n\t\t\t\tconst struct net_bridge_port *p, int cmd,\n\t\t\t\tstruct vtunnel_info *tinfo_curr,\n\t\t\t\tstruct vtunnel_info *tinfo_last,\n\t\t\t\tbool *changed)\n{\n\tint err;\n\n\tif (tinfo_curr->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {\n\t\tif (tinfo_last->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(tinfo_last, tinfo_curr, sizeof(struct vtunnel_info));\n\t} else if (tinfo_curr->flags & BRIDGE_VLAN_INFO_RANGE_END) {\n\t\tstruct net_bridge_vlan *v_start = NULL, *v_end = NULL;\n\t\tint t, v;\n\n\t\tif (!(tinfo_last->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN))\n\t\t\treturn -EINVAL;\n\t\tif ((tinfo_curr->vid - tinfo_last->vid) !=\n\t\t    (tinfo_curr->tunid - tinfo_last->tunid))\n\t\t\treturn -EINVAL;\n\t\tt = tinfo_last->tunid;\n\t\tfor (v = tinfo_last->vid; v <= tinfo_curr->vid; v++) {\n\t\t\tbool curr_change = false;\n\n\t\t\terr = br_vlan_tunnel_info(p, cmd, v, t, &curr_change);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tt++;\n\n\t\t\tif (curr_change)\n\t\t\t\t*changed = curr_change;\n\t\t\t __vlan_tunnel_handle_range(p, &v_start, &v_end, v,\n\t\t\t\t\t\t    curr_change);\n\t\t}\n\t\tif (v_start && v_end)\n\t\t\tbr_vlan_notify(br, p, v_start->vid, v_end->vid,\n\t\t\t\t       RTM_NEWVLAN);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmemset(tinfo_last, 0, sizeof(struct vtunnel_info));\n\t\tmemset(tinfo_curr, 0, sizeof(struct vtunnel_info));\n\t} else {\n\t\tif (tinfo_last->flags)\n\t\t\treturn -EINVAL;\n\t\terr = br_vlan_tunnel_info(p, cmd, tinfo_curr->vid,\n\t\t\t\t\t  tinfo_curr->tunid, changed);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbr_vlan_notify(br, p, tinfo_curr->vid, 0, RTM_NEWVLAN);\n\t\tmemset(tinfo_last, 0, sizeof(struct vtunnel_info));\n\t\tmemset(tinfo_curr, 0, sizeof(struct vtunnel_info));\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}