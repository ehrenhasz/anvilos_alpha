{
  "module_name": "br.c",
  "hash_id": "c4c53e61cee92d60c621903e1eb135df3e7e2c93ad7cd3602f5ca66f1931a766",
  "original_prompt": "Ingested from linux-6.6.14/net/bridge/br.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/llc.h>\n#include <net/llc.h>\n#include <net/stp.h>\n#include <net/switchdev.h>\n\n#include \"br_private.h\"\n\n \nstatic int br_device_event(struct notifier_block *unused, unsigned long event, void *ptr)\n{\n\tstruct netlink_ext_ack *extack = netdev_notifier_info_to_extack(ptr);\n\tstruct netdev_notifier_pre_changeaddr_info *prechaddr_info;\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net_bridge_port *p;\n\tstruct net_bridge *br;\n\tbool notified = false;\n\tbool changed_addr;\n\tint err;\n\n\tif (netif_is_bridge_master(dev)) {\n\t\terr = br_vlan_bridge_event(dev, event, ptr);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\n\t\tif (event == NETDEV_REGISTER) {\n\t\t\t \n\t\t\terr = br_sysfs_addbr(dev);\n\t\t\tif (err)\n\t\t\t\treturn notifier_from_errno(err);\n\n\t\t\treturn NOTIFY_DONE;\n\t\t}\n\t}\n\n\t \n\tp = br_port_get_rtnl(dev);\n\tif (!p)\n\t\treturn NOTIFY_DONE;\n\n\tbr = p->br;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEMTU:\n\t\tbr_mtu_auto_adjust(br);\n\t\tbreak;\n\n\tcase NETDEV_PRE_CHANGEADDR:\n\t\tif (br->dev->addr_assign_type == NET_ADDR_SET)\n\t\t\tbreak;\n\t\tprechaddr_info = ptr;\n\t\terr = dev_pre_changeaddr_notify(br->dev,\n\t\t\t\t\t\tprechaddr_info->dev_addr,\n\t\t\t\t\t\textack);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tbreak;\n\n\tcase NETDEV_CHANGEADDR:\n\t\tspin_lock_bh(&br->lock);\n\t\tbr_fdb_changeaddr(p, dev->dev_addr);\n\t\tchanged_addr = br_stp_recalculate_bridge_id(br);\n\t\tspin_unlock_bh(&br->lock);\n\n\t\tif (changed_addr)\n\t\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, br->dev);\n\n\t\tbreak;\n\n\tcase NETDEV_CHANGE:\n\t\tbr_port_carrier_check(p, &notified);\n\t\tbreak;\n\n\tcase NETDEV_FEAT_CHANGE:\n\t\tnetdev_update_features(br->dev);\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tspin_lock_bh(&br->lock);\n\t\tif (br->dev->flags & IFF_UP) {\n\t\t\tbr_stp_disable_port(p);\n\t\t\tnotified = true;\n\t\t}\n\t\tspin_unlock_bh(&br->lock);\n\t\tbreak;\n\n\tcase NETDEV_UP:\n\t\tif (netif_running(br->dev) && netif_oper_up(dev)) {\n\t\t\tspin_lock_bh(&br->lock);\n\t\t\tbr_stp_enable_port(p);\n\t\t\tnotified = true;\n\t\t\tspin_unlock_bh(&br->lock);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_UNREGISTER:\n\t\tbr_del_if(br, dev);\n\t\tbreak;\n\n\tcase NETDEV_CHANGENAME:\n\t\terr = br_sysfs_renameif(p);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tbreak;\n\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\t \n\t\treturn NOTIFY_BAD;\n\n\tcase NETDEV_RESEND_IGMP:\n\t\t \n\t\tcall_netdevice_notifiers(event, br->dev);\n\t\tbreak;\n\t}\n\n\tif (event != NETDEV_UNREGISTER)\n\t\tbr_vlan_port_event(p, event);\n\n\t \n\tif (!notified && (event == NETDEV_CHANGEADDR || event == NETDEV_UP ||\n\t\t\t  event == NETDEV_CHANGE || event == NETDEV_DOWN))\n\t\tbr_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block br_device_notifier = {\n\t.notifier_call = br_device_event\n};\n\n \nstatic int br_switchdev_event(struct notifier_block *unused,\n\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct net_bridge_port *p;\n\tstruct net_bridge *br;\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tint err = NOTIFY_DONE;\n\n\tp = br_port_get_rtnl_rcu(dev);\n\tif (!p)\n\t\tgoto out;\n\n\tbr = p->br;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_BRIDGE:\n\t\tfdb_info = ptr;\n\t\terr = br_fdb_external_learn_add(br, p, fdb_info->addr,\n\t\t\t\t\t\tfdb_info->vid,\n\t\t\t\t\t\tfdb_info->locked, false);\n\t\tif (err) {\n\t\t\terr = notifier_from_errno(err);\n\t\t\tbreak;\n\t\t}\n\t\tbr_fdb_offloaded_set(br, p, fdb_info->addr,\n\t\t\t\t     fdb_info->vid, fdb_info->offloaded);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_BRIDGE:\n\t\tfdb_info = ptr;\n\t\terr = br_fdb_external_learn_del(br, p, fdb_info->addr,\n\t\t\t\t\t\tfdb_info->vid, false);\n\t\tif (err)\n\t\t\terr = notifier_from_errno(err);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_OFFLOADED:\n\t\tfdb_info = ptr;\n\t\tbr_fdb_offloaded_set(br, p, fdb_info->addr,\n\t\t\t\t     fdb_info->vid, fdb_info->offloaded);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_FLUSH_TO_BRIDGE:\n\t\tfdb_info = ptr;\n\t\t \n\t\tbr_fdb_delete_by_port(br, p, fdb_info->vid, 0);\n\t\tbreak;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic struct notifier_block br_switchdev_notifier = {\n\t.notifier_call = br_switchdev_event,\n};\n\n \nstatic int br_switchdev_blocking_event(struct notifier_block *nb,\n\t\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct netlink_ext_ack *extack = netdev_notifier_info_to_extack(ptr);\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct switchdev_notifier_brport_info *brport_info;\n\tconst struct switchdev_brport *b;\n\tstruct net_bridge_port *p;\n\tint err = NOTIFY_DONE;\n\n\tp = br_port_get_rtnl(dev);\n\tif (!p)\n\t\tgoto out;\n\n\tswitch (event) {\n\tcase SWITCHDEV_BRPORT_OFFLOADED:\n\t\tbrport_info = ptr;\n\t\tb = &brport_info->brport;\n\n\t\terr = br_switchdev_port_offload(p, b->dev, b->ctx,\n\t\t\t\t\t\tb->atomic_nb, b->blocking_nb,\n\t\t\t\t\t\tb->tx_fwd_offload, extack);\n\t\terr = notifier_from_errno(err);\n\t\tbreak;\n\tcase SWITCHDEV_BRPORT_UNOFFLOADED:\n\t\tbrport_info = ptr;\n\t\tb = &brport_info->brport;\n\n\t\tbr_switchdev_port_unoffload(p, b->ctx, b->atomic_nb,\n\t\t\t\t\t    b->blocking_nb);\n\t\tbreak;\n\tcase SWITCHDEV_BRPORT_REPLAY:\n\t\tbrport_info = ptr;\n\t\tb = &brport_info->brport;\n\n\t\terr = br_switchdev_port_replay(p, b->dev, b->ctx, b->atomic_nb,\n\t\t\t\t\t       b->blocking_nb, extack);\n\t\terr = notifier_from_errno(err);\n\t\tbreak;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic struct notifier_block br_switchdev_blocking_notifier = {\n\t.notifier_call = br_switchdev_blocking_event,\n};\n\n \nint br_boolopt_toggle(struct net_bridge *br, enum br_boolopt_id opt, bool on,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tint err = 0;\n\n\tswitch (opt) {\n\tcase BR_BOOLOPT_NO_LL_LEARN:\n\t\tbr_opt_toggle(br, BROPT_NO_LL_LEARN, on);\n\t\tbreak;\n\tcase BR_BOOLOPT_MCAST_VLAN_SNOOPING:\n\t\terr = br_multicast_toggle_vlan_snooping(br, on, extack);\n\t\tbreak;\n\tcase BR_BOOLOPT_MST_ENABLE:\n\t\terr = br_mst_set_enabled(br, on, extack);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint br_boolopt_get(const struct net_bridge *br, enum br_boolopt_id opt)\n{\n\tswitch (opt) {\n\tcase BR_BOOLOPT_NO_LL_LEARN:\n\t\treturn br_opt_get(br, BROPT_NO_LL_LEARN);\n\tcase BR_BOOLOPT_MCAST_VLAN_SNOOPING:\n\t\treturn br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED);\n\tcase BR_BOOLOPT_MST_ENABLE:\n\t\treturn br_opt_get(br, BROPT_MST_ENABLED);\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint br_boolopt_multi_toggle(struct net_bridge *br,\n\t\t\t    struct br_boolopt_multi *bm,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tunsigned long bitmap = bm->optmask;\n\tint err = 0;\n\tint opt_id;\n\n\tfor_each_set_bit(opt_id, &bitmap, BR_BOOLOPT_MAX) {\n\t\tbool on = !!(bm->optval & BIT(opt_id));\n\n\t\terr = br_boolopt_toggle(br, opt_id, on, extack);\n\t\tif (err) {\n\t\t\tbr_debug(br, \"boolopt multi-toggle error: option: %d current: %d new: %d error: %d\\n\",\n\t\t\t\t opt_id, br_boolopt_get(br, opt_id), on, err);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nvoid br_boolopt_multi_get(const struct net_bridge *br,\n\t\t\t  struct br_boolopt_multi *bm)\n{\n\tu32 optval = 0;\n\tint opt_id;\n\n\tfor (opt_id = 0; opt_id < BR_BOOLOPT_MAX; opt_id++)\n\t\toptval |= (br_boolopt_get(br, opt_id) << opt_id);\n\n\tbm->optval = optval;\n\tbm->optmask = GENMASK((BR_BOOLOPT_MAX - 1), 0);\n}\n\n \nvoid br_opt_toggle(struct net_bridge *br, enum net_bridge_opts opt, bool on)\n{\n\tbool cur = !!br_opt_get(br, opt);\n\n\tbr_debug(br, \"toggle option: %d state: %d -> %d\\n\",\n\t\t opt, cur, on);\n\n\tif (cur == on)\n\t\treturn;\n\n\tif (on)\n\t\tset_bit(opt, &br->options);\n\telse\n\t\tclear_bit(opt, &br->options);\n}\n\nstatic void __net_exit br_net_exit_batch(struct list_head *net_list)\n{\n\tstruct net_device *dev;\n\tstruct net *net;\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\n\tlist_for_each_entry(net, net_list, exit_list)\n\t\tfor_each_netdev(net, dev)\n\t\t\tif (netif_is_bridge_master(dev))\n\t\t\t\tbr_dev_delete(dev, &list);\n\n\tunregister_netdevice_many(&list);\n\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations br_net_ops = {\n\t.exit_batch\t= br_net_exit_batch,\n};\n\nstatic const struct stp_proto br_stp_proto = {\n\t.rcv\t= br_stp_rcv,\n};\n\nstatic int __init br_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct br_input_skb_cb) > sizeof_field(struct sk_buff, cb));\n\n\terr = stp_proto_register(&br_stp_proto);\n\tif (err < 0) {\n\t\tpr_err(\"bridge: can't register sap for STP\\n\");\n\t\treturn err;\n\t}\n\n\terr = br_fdb_init();\n\tif (err)\n\t\tgoto err_out;\n\n\terr = register_pernet_subsys(&br_net_ops);\n\tif (err)\n\t\tgoto err_out1;\n\n\terr = br_nf_core_init();\n\tif (err)\n\t\tgoto err_out2;\n\n\terr = register_netdevice_notifier(&br_device_notifier);\n\tif (err)\n\t\tgoto err_out3;\n\n\terr = register_switchdev_notifier(&br_switchdev_notifier);\n\tif (err)\n\t\tgoto err_out4;\n\n\terr = register_switchdev_blocking_notifier(&br_switchdev_blocking_notifier);\n\tif (err)\n\t\tgoto err_out5;\n\n\terr = br_netlink_init();\n\tif (err)\n\t\tgoto err_out6;\n\n\tbrioctl_set(br_ioctl_stub);\n\n#if IS_ENABLED(CONFIG_ATM_LANE)\n\tbr_fdb_test_addr_hook = br_fdb_test_addr;\n#endif\n\n#if IS_MODULE(CONFIG_BRIDGE_NETFILTER)\n\tpr_info(\"bridge: filtering via arp/ip/ip6tables is no longer available \"\n\t\t\"by default. Update your scripts to load br_netfilter if you \"\n\t\t\"need this.\\n\");\n#endif\n\n\treturn 0;\n\nerr_out6:\n\tunregister_switchdev_blocking_notifier(&br_switchdev_blocking_notifier);\nerr_out5:\n\tunregister_switchdev_notifier(&br_switchdev_notifier);\nerr_out4:\n\tunregister_netdevice_notifier(&br_device_notifier);\nerr_out3:\n\tbr_nf_core_fini();\nerr_out2:\n\tunregister_pernet_subsys(&br_net_ops);\nerr_out1:\n\tbr_fdb_fini();\nerr_out:\n\tstp_proto_unregister(&br_stp_proto);\n\treturn err;\n}\n\nstatic void __exit br_deinit(void)\n{\n\tstp_proto_unregister(&br_stp_proto);\n\tbr_netlink_fini();\n\tunregister_switchdev_blocking_notifier(&br_switchdev_blocking_notifier);\n\tunregister_switchdev_notifier(&br_switchdev_notifier);\n\tunregister_netdevice_notifier(&br_device_notifier);\n\tbrioctl_set(NULL);\n\tunregister_pernet_subsys(&br_net_ops);\n\n\trcu_barrier();  \n\n\tbr_nf_core_fini();\n#if IS_ENABLED(CONFIG_ATM_LANE)\n\tbr_fdb_test_addr_hook = NULL;\n#endif\n\tbr_fdb_fini();\n}\n\nmodule_init(br_init)\nmodule_exit(br_deinit)\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(BR_VERSION);\nMODULE_ALIAS_RTNL_LINK(\"bridge\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}