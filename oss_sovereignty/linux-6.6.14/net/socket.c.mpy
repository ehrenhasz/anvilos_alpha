{
  "module_name": "socket.c",
  "hash_id": "85a84f64ec243fd4e55c3ce9c278130f615e7b5d29c320bb0fb44a68ea017d85",
  "original_prompt": "Ingested from linux-6.6.14/net/socket.c",
  "human_readable_source": "\n \n\n#include <linux/bpf-cgroup.h>\n#include <linux/ethtool.h>\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/file.h>\n#include <linux/splice.h>\n#include <linux/net.h>\n#include <linux/interrupt.h>\n#include <linux/thread_info.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/ptp_classify.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/cache.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mount.h>\n#include <linux/pseudo_fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/kmod.h>\n#include <linux/audit.h>\n#include <linux/wireless.h>\n#include <linux/nsproxy.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/nospec.h>\n#include <linux/indirect_call_wrapper.h>\n#include <linux/io_uring.h>\n\n#include <linux/uaccess.h>\n#include <asm/unistd.h>\n\n#include <net/compat.h>\n#include <net/wext.h>\n#include <net/cls_cgroup.h>\n\n#include <net/sock.h>\n#include <linux/netfilter.h>\n\n#include <linux/if_tun.h>\n#include <linux/ipv6_route.h>\n#include <linux/route.h>\n#include <linux/termios.h>\n#include <linux/sockios.h>\n#include <net/busy_poll.h>\n#include <linux/errqueue.h>\n#include <linux/ptp_clock_kernel.h>\n#include <trace/events/sock.h>\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\nunsigned int sysctl_net_busy_read __read_mostly;\nunsigned int sysctl_net_busy_poll __read_mostly;\n#endif\n\nstatic ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to);\nstatic ssize_t sock_write_iter(struct kiocb *iocb, struct iov_iter *from);\nstatic int sock_mmap(struct file *file, struct vm_area_struct *vma);\n\nstatic int sock_close(struct inode *inode, struct file *file);\nstatic __poll_t sock_poll(struct file *file,\n\t\t\t      struct poll_table_struct *wait);\nstatic long sock_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n#ifdef CONFIG_COMPAT\nstatic long compat_sock_ioctl(struct file *file,\n\t\t\t      unsigned int cmd, unsigned long arg);\n#endif\nstatic int sock_fasync(int fd, struct file *filp, int on);\nstatic ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags);\nstatic void sock_splice_eof(struct file *file);\n\n#ifdef CONFIG_PROC_FS\nstatic void sock_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct socket *sock = f->private_data;\n\tconst struct proto_ops *ops = READ_ONCE(sock->ops);\n\n\tif (ops->show_fdinfo)\n\t\tops->show_fdinfo(m, sock);\n}\n#else\n#define sock_show_fdinfo NULL\n#endif\n\n \n\nstatic const struct file_operations socket_file_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.read_iter =\tsock_read_iter,\n\t.write_iter =\tsock_write_iter,\n\t.poll =\t\tsock_poll,\n\t.unlocked_ioctl = sock_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_sock_ioctl,\n#endif\n\t.uring_cmd =    io_uring_cmd_sock,\n\t.mmap =\t\tsock_mmap,\n\t.release =\tsock_close,\n\t.fasync =\tsock_fasync,\n\t.splice_write = splice_to_socket,\n\t.splice_read =\tsock_splice_read,\n\t.splice_eof =\tsock_splice_eof,\n\t.show_fdinfo =\tsock_show_fdinfo,\n};\n\nstatic const char * const pf_family_names[] = {\n\t[PF_UNSPEC]\t= \"PF_UNSPEC\",\n\t[PF_UNIX]\t= \"PF_UNIX/PF_LOCAL\",\n\t[PF_INET]\t= \"PF_INET\",\n\t[PF_AX25]\t= \"PF_AX25\",\n\t[PF_IPX]\t= \"PF_IPX\",\n\t[PF_APPLETALK]\t= \"PF_APPLETALK\",\n\t[PF_NETROM]\t= \"PF_NETROM\",\n\t[PF_BRIDGE]\t= \"PF_BRIDGE\",\n\t[PF_ATMPVC]\t= \"PF_ATMPVC\",\n\t[PF_X25]\t= \"PF_X25\",\n\t[PF_INET6]\t= \"PF_INET6\",\n\t[PF_ROSE]\t= \"PF_ROSE\",\n\t[PF_DECnet]\t= \"PF_DECnet\",\n\t[PF_NETBEUI]\t= \"PF_NETBEUI\",\n\t[PF_SECURITY]\t= \"PF_SECURITY\",\n\t[PF_KEY]\t= \"PF_KEY\",\n\t[PF_NETLINK]\t= \"PF_NETLINK/PF_ROUTE\",\n\t[PF_PACKET]\t= \"PF_PACKET\",\n\t[PF_ASH]\t= \"PF_ASH\",\n\t[PF_ECONET]\t= \"PF_ECONET\",\n\t[PF_ATMSVC]\t= \"PF_ATMSVC\",\n\t[PF_RDS]\t= \"PF_RDS\",\n\t[PF_SNA]\t= \"PF_SNA\",\n\t[PF_IRDA]\t= \"PF_IRDA\",\n\t[PF_PPPOX]\t= \"PF_PPPOX\",\n\t[PF_WANPIPE]\t= \"PF_WANPIPE\",\n\t[PF_LLC]\t= \"PF_LLC\",\n\t[PF_IB]\t\t= \"PF_IB\",\n\t[PF_MPLS]\t= \"PF_MPLS\",\n\t[PF_CAN]\t= \"PF_CAN\",\n\t[PF_TIPC]\t= \"PF_TIPC\",\n\t[PF_BLUETOOTH]\t= \"PF_BLUETOOTH\",\n\t[PF_IUCV]\t= \"PF_IUCV\",\n\t[PF_RXRPC]\t= \"PF_RXRPC\",\n\t[PF_ISDN]\t= \"PF_ISDN\",\n\t[PF_PHONET]\t= \"PF_PHONET\",\n\t[PF_IEEE802154]\t= \"PF_IEEE802154\",\n\t[PF_CAIF]\t= \"PF_CAIF\",\n\t[PF_ALG]\t= \"PF_ALG\",\n\t[PF_NFC]\t= \"PF_NFC\",\n\t[PF_VSOCK]\t= \"PF_VSOCK\",\n\t[PF_KCM]\t= \"PF_KCM\",\n\t[PF_QIPCRTR]\t= \"PF_QIPCRTR\",\n\t[PF_SMC]\t= \"PF_SMC\",\n\t[PF_XDP]\t= \"PF_XDP\",\n\t[PF_MCTP]\t= \"PF_MCTP\",\n};\n\n \n\nstatic DEFINE_SPINLOCK(net_family_lock);\nstatic const struct net_proto_family __rcu *net_families[NPROTO] __read_mostly;\n\n \n\n \n\nint move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr_storage *kaddr)\n{\n\tif (ulen < 0 || ulen > sizeof(struct sockaddr_storage))\n\t\treturn -EINVAL;\n\tif (ulen == 0)\n\t\treturn 0;\n\tif (copy_from_user(kaddr, uaddr, ulen))\n\t\treturn -EFAULT;\n\treturn audit_sockaddr(ulen, kaddr);\n}\n\n \n\nstatic int move_addr_to_user(struct sockaddr_storage *kaddr, int klen,\n\t\t\t     void __user *uaddr, int __user *ulen)\n{\n\tint err;\n\tint len;\n\n\tBUG_ON(klen > sizeof(struct sockaddr_storage));\n\terr = get_user(len, ulen);\n\tif (err)\n\t\treturn err;\n\tif (len > klen)\n\t\tlen = klen;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tif (len) {\n\t\tif (audit_sockaddr(klen, kaddr))\n\t\t\treturn -ENOMEM;\n\t\tif (copy_to_user(uaddr, kaddr, len))\n\t\t\treturn -EFAULT;\n\t}\n\t \n\treturn __put_user(klen, ulen);\n}\n\nstatic struct kmem_cache *sock_inode_cachep __ro_after_init;\n\nstatic struct inode *sock_alloc_inode(struct super_block *sb)\n{\n\tstruct socket_alloc *ei;\n\n\tei = alloc_inode_sb(sb, sock_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tinit_waitqueue_head(&ei->socket.wq.wait);\n\tei->socket.wq.fasync_list = NULL;\n\tei->socket.wq.flags = 0;\n\n\tei->socket.state = SS_UNCONNECTED;\n\tei->socket.flags = 0;\n\tei->socket.ops = NULL;\n\tei->socket.sk = NULL;\n\tei->socket.file = NULL;\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void sock_free_inode(struct inode *inode)\n{\n\tstruct socket_alloc *ei;\n\n\tei = container_of(inode, struct socket_alloc, vfs_inode);\n\tkmem_cache_free(sock_inode_cachep, ei);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct socket_alloc *ei = (struct socket_alloc *)foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic void init_inodecache(void)\n{\n\tsock_inode_cachep = kmem_cache_create(\"sock_inode_cache\",\n\t\t\t\t\t      sizeof(struct socket_alloc),\n\t\t\t\t\t      0,\n\t\t\t\t\t      (SLAB_HWCACHE_ALIGN |\n\t\t\t\t\t       SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t       SLAB_MEM_SPREAD | SLAB_ACCOUNT),\n\t\t\t\t\t      init_once);\n\tBUG_ON(sock_inode_cachep == NULL);\n}\n\nstatic const struct super_operations sockfs_ops = {\n\t.alloc_inode\t= sock_alloc_inode,\n\t.free_inode\t= sock_free_inode,\n\t.statfs\t\t= simple_statfs,\n};\n\n \nstatic char *sockfs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(buffer, buflen, \"socket:[%lu]\",\n\t\t\t\td_inode(dentry)->i_ino);\n}\n\nstatic const struct dentry_operations sockfs_dentry_operations = {\n\t.d_dname  = sockfs_dname,\n};\n\nstatic int sockfs_xattr_get(const struct xattr_handler *handler,\n\t\t\t    struct dentry *dentry, struct inode *inode,\n\t\t\t    const char *suffix, void *value, size_t size)\n{\n\tif (value) {\n\t\tif (dentry->d_name.len + 1 > size)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(value, dentry->d_name.name, dentry->d_name.len + 1);\n\t}\n\treturn dentry->d_name.len + 1;\n}\n\n#define XATTR_SOCKPROTONAME_SUFFIX \"sockprotoname\"\n#define XATTR_NAME_SOCKPROTONAME (XATTR_SYSTEM_PREFIX XATTR_SOCKPROTONAME_SUFFIX)\n#define XATTR_NAME_SOCKPROTONAME_LEN (sizeof(XATTR_NAME_SOCKPROTONAME)-1)\n\nstatic const struct xattr_handler sockfs_xattr_handler = {\n\t.name = XATTR_NAME_SOCKPROTONAME,\n\t.get = sockfs_xattr_get,\n};\n\nstatic int sockfs_security_xattr_set(const struct xattr_handler *handler,\n\t\t\t\t     struct mnt_idmap *idmap,\n\t\t\t\t     struct dentry *dentry, struct inode *inode,\n\t\t\t\t     const char *suffix, const void *value,\n\t\t\t\t     size_t size, int flags)\n{\n\t \n\treturn -EAGAIN;\n}\n\nstatic const struct xattr_handler sockfs_security_xattr_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.set = sockfs_security_xattr_set,\n};\n\nstatic const struct xattr_handler *sockfs_xattr_handlers[] = {\n\t&sockfs_xattr_handler,\n\t&sockfs_security_xattr_handler,\n\tNULL\n};\n\nstatic int sockfs_init_fs_context(struct fs_context *fc)\n{\n\tstruct pseudo_fs_context *ctx = init_pseudo(fc, SOCKFS_MAGIC);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->ops = &sockfs_ops;\n\tctx->dops = &sockfs_dentry_operations;\n\tctx->xattr = sockfs_xattr_handlers;\n\treturn 0;\n}\n\nstatic struct vfsmount *sock_mnt __read_mostly;\n\nstatic struct file_system_type sock_fs_type = {\n\t.name =\t\t\"sockfs\",\n\t.init_fs_context = sockfs_init_fs_context,\n\t.kill_sb =\tkill_anon_super,\n};\n\n \n\n \n\nstruct file *sock_alloc_file(struct socket *sock, int flags, const char *dname)\n{\n\tstruct file *file;\n\n\tif (!dname)\n\t\tdname = sock->sk ? sock->sk->sk_prot_creator->name : \"\";\n\n\tfile = alloc_file_pseudo(SOCK_INODE(sock), sock_mnt, dname,\n\t\t\t\tO_RDWR | (flags & O_NONBLOCK),\n\t\t\t\t&socket_file_ops);\n\tif (IS_ERR(file)) {\n\t\tsock_release(sock);\n\t\treturn file;\n\t}\n\n\tfile->f_mode |= FMODE_NOWAIT;\n\tsock->file = file;\n\tfile->private_data = sock;\n\tstream_open(SOCK_INODE(sock), file);\n\treturn file;\n}\nEXPORT_SYMBOL(sock_alloc_file);\n\nstatic int sock_map_fd(struct socket *sock, int flags)\n{\n\tstruct file *newfile;\n\tint fd = get_unused_fd_flags(flags);\n\tif (unlikely(fd < 0)) {\n\t\tsock_release(sock);\n\t\treturn fd;\n\t}\n\n\tnewfile = sock_alloc_file(sock, flags, NULL);\n\tif (!IS_ERR(newfile)) {\n\t\tfd_install(fd, newfile);\n\t\treturn fd;\n\t}\n\n\tput_unused_fd(fd);\n\treturn PTR_ERR(newfile);\n}\n\n \n\nstruct socket *sock_from_file(struct file *file)\n{\n\tif (file->f_op == &socket_file_ops)\n\t\treturn file->private_data;\t \n\n\treturn NULL;\n}\nEXPORT_SYMBOL(sock_from_file);\n\n \n\nstruct socket *sockfd_lookup(int fd, int *err)\n{\n\tstruct file *file;\n\tstruct socket *sock;\n\n\tfile = fget(fd);\n\tif (!file) {\n\t\t*err = -EBADF;\n\t\treturn NULL;\n\t}\n\n\tsock = sock_from_file(file);\n\tif (!sock) {\n\t\t*err = -ENOTSOCK;\n\t\tfput(file);\n\t}\n\treturn sock;\n}\nEXPORT_SYMBOL(sockfd_lookup);\n\nstatic struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed)\n{\n\tstruct fd f = fdget(fd);\n\tstruct socket *sock;\n\n\t*err = -EBADF;\n\tif (f.file) {\n\t\tsock = sock_from_file(f.file);\n\t\tif (likely(sock)) {\n\t\t\t*fput_needed = f.flags & FDPUT_FPUT;\n\t\t\treturn sock;\n\t\t}\n\t\t*err = -ENOTSOCK;\n\t\tfdput(f);\n\t}\n\treturn NULL;\n}\n\nstatic ssize_t sockfs_listxattr(struct dentry *dentry, char *buffer,\n\t\t\t\tsize_t size)\n{\n\tssize_t len;\n\tssize_t used = 0;\n\n\tlen = security_inode_listsecurity(d_inode(dentry), buffer, size);\n\tif (len < 0)\n\t\treturn len;\n\tused += len;\n\tif (buffer) {\n\t\tif (size < used)\n\t\t\treturn -ERANGE;\n\t\tbuffer += len;\n\t}\n\n\tlen = (XATTR_NAME_SOCKPROTONAME_LEN + 1);\n\tused += len;\n\tif (buffer) {\n\t\tif (size < used)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(buffer, XATTR_NAME_SOCKPROTONAME, len);\n\t\tbuffer += len;\n\t}\n\n\treturn used;\n}\n\nstatic int sockfs_setattr(struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(&nop_mnt_idmap, dentry, iattr);\n\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\n\t\tif (sock->sk)\n\t\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t\telse\n\t\t\terr = -ENOENT;\n\t}\n\n\treturn err;\n}\n\nstatic const struct inode_operations sockfs_inode_ops = {\n\t.listxattr = sockfs_listxattr,\n\t.setattr = sockfs_setattr,\n};\n\n \n\nstruct socket *sock_alloc(void)\n{\n\tstruct inode *inode;\n\tstruct socket *sock;\n\n\tinode = new_inode_pseudo(sock_mnt->mnt_sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tsock = SOCKET_I(inode);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = S_IFSOCK | S_IRWXUGO;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_op = &sockfs_inode_ops;\n\n\treturn sock;\n}\nEXPORT_SYMBOL(sock_alloc);\n\nstatic void __sock_release(struct socket *sock, struct inode *inode)\n{\n\tconst struct proto_ops *ops = READ_ONCE(sock->ops);\n\n\tif (ops) {\n\t\tstruct module *owner = ops->owner;\n\n\t\tif (inode)\n\t\t\tinode_lock(inode);\n\t\tops->release(sock);\n\t\tsock->sk = NULL;\n\t\tif (inode)\n\t\t\tinode_unlock(inode);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\n\tif (sock->wq.fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}\n\n \nvoid sock_release(struct socket *sock)\n{\n\t__sock_release(sock, NULL);\n}\nEXPORT_SYMBOL(sock_release);\n\nvoid __sock_tx_timestamp(__u16 tsflags, __u8 *tx_flags)\n{\n\tu8 flags = *tx_flags;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_HARDWARE) {\n\t\tflags |= SKBTX_HW_TSTAMP;\n\n\t\t \n\t\tif (tsflags & SOF_TIMESTAMPING_BIND_PHC)\n\t\t\tflags |= SKBTX_HW_TSTAMP_USE_CYCLES;\n\t}\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_SOFTWARE)\n\t\tflags |= SKBTX_SW_TSTAMP;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_SCHED)\n\t\tflags |= SKBTX_SCHED_TSTAMP;\n\n\t*tx_flags = flags;\n}\nEXPORT_SYMBOL(__sock_tx_timestamp);\n\nINDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,\n\t\t\t\t\t   size_t));\nINDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,\n\t\t\t\t\t    size_t));\n\nstatic noinline void call_trace_sock_send_length(struct sock *sk, int ret,\n\t\t\t\t\t\t int flags)\n{\n\ttrace_sock_send_length(sk, ret, 0);\n}\n\nstatic inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)\n{\n\tint ret = INDIRECT_CALL_INET(READ_ONCE(sock->ops)->sendmsg, inet6_sendmsg,\n\t\t\t\t     inet_sendmsg, sock, msg,\n\t\t\t\t     msg_data_left(msg));\n\tBUG_ON(ret == -EIOCBQUEUED);\n\n\tif (trace_sock_send_length_enabled())\n\t\tcall_trace_sock_send_length(sock->sk, ret, 0);\n\treturn ret;\n}\n\nstatic int __sock_sendmsg(struct socket *sock, struct msghdr *msg)\n{\n\tint err = security_socket_sendmsg(sock, msg,\n\t\t\t\t\t  msg_data_left(msg));\n\n\treturn err ?: sock_sendmsg_nosec(sock, msg);\n}\n\n \nint sock_sendmsg(struct socket *sock, struct msghdr *msg)\n{\n\tstruct sockaddr_storage *save_addr = (struct sockaddr_storage *)msg->msg_name;\n\tstruct sockaddr_storage address;\n\tint save_len = msg->msg_namelen;\n\tint ret;\n\n\tif (msg->msg_name) {\n\t\tmemcpy(&address, msg->msg_name, msg->msg_namelen);\n\t\tmsg->msg_name = &address;\n\t}\n\n\tret = __sock_sendmsg(sock, msg);\n\tmsg->msg_name = save_addr;\n\tmsg->msg_namelen = save_len;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sock_sendmsg);\n\n \n\nint kernel_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size)\n{\n\tiov_iter_kvec(&msg->msg_iter, ITER_SOURCE, vec, num, size);\n\treturn sock_sendmsg(sock, msg);\n}\nEXPORT_SYMBOL(kernel_sendmsg);\n\n \n\nint kernel_sendmsg_locked(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct kvec *vec, size_t num, size_t size)\n{\n\tstruct socket *sock = sk->sk_socket;\n\tconst struct proto_ops *ops = READ_ONCE(sock->ops);\n\n\tif (!ops->sendmsg_locked)\n\t\treturn sock_no_sendmsg_locked(sk, msg, size);\n\n\tiov_iter_kvec(&msg->msg_iter, ITER_SOURCE, vec, num, size);\n\n\treturn ops->sendmsg_locked(sk, msg, msg_data_left(msg));\n}\nEXPORT_SYMBOL(kernel_sendmsg_locked);\n\nstatic bool skb_is_err_queue(const struct sk_buff *skb)\n{\n\t \n\treturn skb->pkt_type == PACKET_OUTGOING;\n}\n\n \nstatic bool skb_is_swtx_tstamp(const struct sk_buff *skb, int false_tstamp)\n{\n\treturn skb->tstamp && !false_tstamp && skb_is_err_queue(skb);\n}\n\nstatic ktime_t get_timestamp(struct sock *sk, struct sk_buff *skb, int *if_index)\n{\n\tbool cycles = READ_ONCE(sk->sk_tsflags) & SOF_TIMESTAMPING_BIND_PHC;\n\tstruct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);\n\tstruct net_device *orig_dev;\n\tktime_t hwtstamp;\n\n\trcu_read_lock();\n\torig_dev = dev_get_by_napi_id(skb_napi_id(skb));\n\tif (orig_dev) {\n\t\t*if_index = orig_dev->ifindex;\n\t\thwtstamp = netdev_get_tstamp(orig_dev, shhwtstamps, cycles);\n\t} else {\n\t\thwtstamp = shhwtstamps->hwtstamp;\n\t}\n\trcu_read_unlock();\n\n\treturn hwtstamp;\n}\n\nstatic void put_ts_pktinfo(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t   int if_index)\n{\n\tstruct scm_ts_pktinfo ts_pktinfo;\n\tstruct net_device *orig_dev;\n\n\tif (!skb_mac_header_was_set(skb))\n\t\treturn;\n\n\tmemset(&ts_pktinfo, 0, sizeof(ts_pktinfo));\n\n\tif (!if_index) {\n\t\trcu_read_lock();\n\t\torig_dev = dev_get_by_napi_id(skb_napi_id(skb));\n\t\tif (orig_dev)\n\t\t\tif_index = orig_dev->ifindex;\n\t\trcu_read_unlock();\n\t}\n\tts_pktinfo.if_index = if_index;\n\n\tts_pktinfo.pkt_length = skb->len - skb_mac_offset(skb);\n\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_PKTINFO,\n\t\t sizeof(ts_pktinfo), &ts_pktinfo);\n}\n\n \nvoid __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tint new_tstamp = sock_flag(sk, SOCK_TSTAMP_NEW);\n\tstruct scm_timestamping_internal tss;\n\tint empty = 1, false_tstamp = 0;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\tint if_index;\n\tktime_t hwtstamp;\n\tu32 tsflags;\n\n\t \n\tif (need_software_tstamp && skb->tstamp == 0) {\n\t\t__net_timestamp(skb);\n\t\tfalse_tstamp = 1;\n\t}\n\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tif (new_tstamp) {\n\t\t\t\tstruct __kernel_sock_timeval tv;\n\n\t\t\t\tskb_get_new_timestamp(skb, &tv);\n\t\t\t\tput_cmsg(msg, SOL_SOCKET, SO_TIMESTAMP_NEW,\n\t\t\t\t\t sizeof(tv), &tv);\n\t\t\t} else {\n\t\t\t\tstruct __kernel_old_timeval tv;\n\n\t\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\t\tput_cmsg(msg, SOL_SOCKET, SO_TIMESTAMP_OLD,\n\t\t\t\t\t sizeof(tv), &tv);\n\t\t\t}\n\t\t} else {\n\t\t\tif (new_tstamp) {\n\t\t\t\tstruct __kernel_timespec ts;\n\n\t\t\t\tskb_get_new_timestampns(skb, &ts);\n\t\t\t\tput_cmsg(msg, SOL_SOCKET, SO_TIMESTAMPNS_NEW,\n\t\t\t\t\t sizeof(ts), &ts);\n\t\t\t} else {\n\t\t\t\tstruct __kernel_old_timespec ts;\n\n\t\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\t\tput_cmsg(msg, SOL_SOCKET, SO_TIMESTAMPNS_OLD,\n\t\t\t\t\t sizeof(ts), &ts);\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(&tss, 0, sizeof(tss));\n\ttsflags = READ_ONCE(sk->sk_tsflags);\n\tif ((tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec64_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    !skb_is_swtx_tstamp(skb, false_tstamp)) {\n\t\tif_index = 0;\n\t\tif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP_NETDEV)\n\t\t\thwtstamp = get_timestamp(sk, skb, &if_index);\n\t\telse\n\t\t\thwtstamp = shhwtstamps->hwtstamp;\n\n\t\tif (tsflags & SOF_TIMESTAMPING_BIND_PHC)\n\t\t\thwtstamp = ptp_convert_timestamp(&hwtstamp,\n\t\t\t\t\t\t\t READ_ONCE(sk->sk_bind_phc));\n\n\t\tif (ktime_to_timespec64_cond(hwtstamp, tss.ts + 2)) {\n\t\t\tempty = 0;\n\n\t\t\tif ((tsflags & SOF_TIMESTAMPING_OPT_PKTINFO) &&\n\t\t\t    !skb_is_err_queue(skb))\n\t\t\t\tput_ts_pktinfo(msg, skb, if_index);\n\t\t}\n\t}\n\tif (!empty) {\n\t\tif (sock_flag(sk, SOCK_TSTAMP_NEW))\n\t\t\tput_cmsg_scm_timestamping64(msg, &tss);\n\t\telse\n\t\t\tput_cmsg_scm_timestamping(msg, &tss);\n\n\t\tif (skb_is_err_queue(skb) && skb->len &&\n\t\t    SKB_EXT_ERR(skb)->opt_stats)\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n\t\t\t\t skb->len, skb->data);\n\t}\n}\nEXPORT_SYMBOL_GPL(__sock_recv_timestamp);\n\n#ifdef CONFIG_WIRELESS\nvoid __sock_recv_wifi_status(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint ack;\n\n\tif (!sock_flag(sk, SOCK_WIFI_STATUS))\n\t\treturn;\n\tif (!skb->wifi_acked_valid)\n\t\treturn;\n\n\tack = skb->wifi_acked;\n\n\tput_cmsg(msg, SOL_SOCKET, SCM_WIFI_STATUS, sizeof(ack), &ack);\n}\nEXPORT_SYMBOL_GPL(__sock_recv_wifi_status);\n#endif\n\nstatic inline void sock_recv_drops(struct msghdr *msg, struct sock *sk,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tif (sock_flag(sk, SOCK_RXQ_OVFL) && skb && SOCK_SKB_CB(skb)->dropcount)\n\t\tput_cmsg(msg, SOL_SOCKET, SO_RXQ_OVFL,\n\t\t\tsizeof(__u32), &SOCK_SKB_CB(skb)->dropcount);\n}\n\nstatic void sock_recv_mark(struct msghdr *msg, struct sock *sk,\n\t\t\t   struct sk_buff *skb)\n{\n\tif (sock_flag(sk, SOCK_RCVMARK) && skb) {\n\t\t \n\t\t__u32 mark = skb->mark;\n\n\t\tput_cmsg(msg, SOL_SOCKET, SO_MARK, sizeof(__u32), &mark);\n\t}\n}\n\nvoid __sock_recv_cmsgs(struct msghdr *msg, struct sock *sk,\n\t\t       struct sk_buff *skb)\n{\n\tsock_recv_timestamp(msg, sk, skb);\n\tsock_recv_drops(msg, sk, skb);\n\tsock_recv_mark(msg, sk, skb);\n}\nEXPORT_SYMBOL_GPL(__sock_recv_cmsgs);\n\nINDIRECT_CALLABLE_DECLARE(int inet_recvmsg(struct socket *, struct msghdr *,\n\t\t\t\t\t   size_t, int));\nINDIRECT_CALLABLE_DECLARE(int inet6_recvmsg(struct socket *, struct msghdr *,\n\t\t\t\t\t    size_t, int));\n\nstatic noinline void call_trace_sock_recv_length(struct sock *sk, int ret, int flags)\n{\n\ttrace_sock_recv_length(sk, ret, flags);\n}\n\nstatic inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     int flags)\n{\n\tint ret = INDIRECT_CALL_INET(READ_ONCE(sock->ops)->recvmsg,\n\t\t\t\t     inet6_recvmsg,\n\t\t\t\t     inet_recvmsg, sock, msg,\n\t\t\t\t     msg_data_left(msg), flags);\n\tif (trace_sock_recv_length_enabled())\n\t\tcall_trace_sock_recv_length(sock->sk, ret, flags);\n\treturn ret;\n}\n\n \nint sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags)\n{\n\tint err = security_socket_recvmsg(sock, msg, msg_data_left(msg), flags);\n\n\treturn err ?: sock_recvmsg_nosec(sock, msg, flags);\n}\nEXPORT_SYMBOL(sock_recvmsg);\n\n \n\nint kernel_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size, int flags)\n{\n\tmsg->msg_control_is_user = false;\n\tiov_iter_kvec(&msg->msg_iter, ITER_DEST, vec, num, size);\n\treturn sock_recvmsg(sock, msg, flags);\n}\nEXPORT_SYMBOL(kernel_recvmsg);\n\nstatic ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags)\n{\n\tstruct socket *sock = file->private_data;\n\tconst struct proto_ops *ops;\n\n\tops = READ_ONCE(sock->ops);\n\tif (unlikely(!ops->splice_read))\n\t\treturn copy_splice_read(file, ppos, pipe, len, flags);\n\n\treturn ops->splice_read(sock, ppos, pipe, len, flags);\n}\n\nstatic void sock_splice_eof(struct file *file)\n{\n\tstruct socket *sock = file->private_data;\n\tconst struct proto_ops *ops;\n\n\tops = READ_ONCE(sock->ops);\n\tif (ops->splice_eof)\n\t\tops->splice_eof(sock);\n}\n\nstatic ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct socket *sock = file->private_data;\n\tstruct msghdr msg = {.msg_iter = *to,\n\t\t\t     .msg_iocb = iocb};\n\tssize_t res;\n\n\tif (file->f_flags & O_NONBLOCK || (iocb->ki_flags & IOCB_NOWAIT))\n\t\tmsg.msg_flags = MSG_DONTWAIT;\n\n\tif (iocb->ki_pos != 0)\n\t\treturn -ESPIPE;\n\n\tif (!iov_iter_count(to))\t \n\t\treturn 0;\n\n\tres = sock_recvmsg(sock, &msg, msg.msg_flags);\n\t*to = msg.msg_iter;\n\treturn res;\n}\n\nstatic ssize_t sock_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct socket *sock = file->private_data;\n\tstruct msghdr msg = {.msg_iter = *from,\n\t\t\t     .msg_iocb = iocb};\n\tssize_t res;\n\n\tif (iocb->ki_pos != 0)\n\t\treturn -ESPIPE;\n\n\tif (file->f_flags & O_NONBLOCK || (iocb->ki_flags & IOCB_NOWAIT))\n\t\tmsg.msg_flags = MSG_DONTWAIT;\n\n\tif (sock->type == SOCK_SEQPACKET)\n\t\tmsg.msg_flags |= MSG_EOR;\n\n\tres = __sock_sendmsg(sock, &msg);\n\t*from = msg.msg_iter;\n\treturn res;\n}\n\n \n\nstatic DEFINE_MUTEX(br_ioctl_mutex);\nstatic int (*br_ioctl_hook)(struct net *net, struct net_bridge *br,\n\t\t\t    unsigned int cmd, struct ifreq *ifr,\n\t\t\t    void __user *uarg);\n\nvoid brioctl_set(int (*hook)(struct net *net, struct net_bridge *br,\n\t\t\t     unsigned int cmd, struct ifreq *ifr,\n\t\t\t     void __user *uarg))\n{\n\tmutex_lock(&br_ioctl_mutex);\n\tbr_ioctl_hook = hook;\n\tmutex_unlock(&br_ioctl_mutex);\n}\nEXPORT_SYMBOL(brioctl_set);\n\nint br_ioctl_call(struct net *net, struct net_bridge *br, unsigned int cmd,\n\t\t  struct ifreq *ifr, void __user *uarg)\n{\n\tint err = -ENOPKG;\n\n\tif (!br_ioctl_hook)\n\t\trequest_module(\"bridge\");\n\n\tmutex_lock(&br_ioctl_mutex);\n\tif (br_ioctl_hook)\n\t\terr = br_ioctl_hook(net, br, cmd, ifr, uarg);\n\tmutex_unlock(&br_ioctl_mutex);\n\n\treturn err;\n}\n\nstatic DEFINE_MUTEX(vlan_ioctl_mutex);\nstatic int (*vlan_ioctl_hook) (struct net *, void __user *arg);\n\nvoid vlan_ioctl_set(int (*hook) (struct net *, void __user *))\n{\n\tmutex_lock(&vlan_ioctl_mutex);\n\tvlan_ioctl_hook = hook;\n\tmutex_unlock(&vlan_ioctl_mutex);\n}\nEXPORT_SYMBOL(vlan_ioctl_set);\n\nstatic long sock_do_ioctl(struct net *net, struct socket *sock,\n\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\tconst struct proto_ops *ops = READ_ONCE(sock->ops);\n\tstruct ifreq ifr;\n\tbool need_copyout;\n\tint err;\n\tvoid __user *argp = (void __user *)arg;\n\tvoid __user *data;\n\n\terr = ops->ioctl(sock, cmd, arg);\n\n\t \n\tif (err != -ENOIOCTLCMD)\n\t\treturn err;\n\n\tif (!is_socket_ioctl_cmd(cmd))\n\t\treturn -ENOTTY;\n\n\tif (get_user_ifreq(&ifr, &data, argp))\n\t\treturn -EFAULT;\n\terr = dev_ioctl(net, cmd, &ifr, data, &need_copyout);\n\tif (!err && need_copyout)\n\t\tif (put_user_ifreq(&ifr, argp))\n\t\t\treturn -EFAULT;\n\n\treturn err;\n}\n\n \n\nstatic long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tconst struct proto_ops  *ops;\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tvoid __user *argp = (void __user *)arg;\n\tint pid, err;\n\tstruct net *net;\n\n\tsock = file->private_data;\n\tops = READ_ONCE(sock->ops);\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\tif (unlikely(cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))) {\n\t\tstruct ifreq ifr;\n\t\tvoid __user *data;\n\t\tbool need_copyout;\n\t\tif (get_user_ifreq(&ifr, &data, argp))\n\t\t\treturn -EFAULT;\n\t\terr = dev_ioctl(net, cmd, &ifr, data, &need_copyout);\n\t\tif (!err && need_copyout)\n\t\t\tif (put_user_ifreq(&ifr, argp))\n\t\t\t\treturn -EFAULT;\n\t} else\n#ifdef CONFIG_WEXT_CORE\n\tif (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {\n\t\terr = wext_handle_ioctl(net, cmd, argp);\n\t} else\n#endif\n\t\tswitch (cmd) {\n\t\tcase FIOSETOWN:\n\t\tcase SIOCSPGRP:\n\t\t\terr = -EFAULT;\n\t\t\tif (get_user(pid, (int __user *)argp))\n\t\t\t\tbreak;\n\t\t\terr = f_setown(sock->file, pid, 1);\n\t\t\tbreak;\n\t\tcase FIOGETOWN:\n\t\tcase SIOCGPGRP:\n\t\t\terr = put_user(f_getown(sock->file),\n\t\t\t\t       (int __user *)argp);\n\t\t\tbreak;\n\t\tcase SIOCGIFBR:\n\t\tcase SIOCSIFBR:\n\t\tcase SIOCBRADDBR:\n\t\tcase SIOCBRDELBR:\n\t\t\terr = br_ioctl_call(net, NULL, cmd, NULL, argp);\n\t\t\tbreak;\n\t\tcase SIOCGIFVLAN:\n\t\tcase SIOCSIFVLAN:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!vlan_ioctl_hook)\n\t\t\t\trequest_module(\"8021q\");\n\n\t\t\tmutex_lock(&vlan_ioctl_mutex);\n\t\t\tif (vlan_ioctl_hook)\n\t\t\t\terr = vlan_ioctl_hook(net, argp);\n\t\t\tmutex_unlock(&vlan_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCGSKNS:\n\t\t\terr = -EPERM;\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\t\tbreak;\n\n\t\t\terr = open_related_ns(&net->ns, get_net_ns);\n\t\t\tbreak;\n\t\tcase SIOCGSTAMP_OLD:\n\t\tcase SIOCGSTAMPNS_OLD:\n\t\t\tif (!ops->gettstamp) {\n\t\t\t\terr = -ENOIOCTLCMD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = ops->gettstamp(sock, argp,\n\t\t\t\t\t     cmd == SIOCGSTAMP_OLD,\n\t\t\t\t\t     !IS_ENABLED(CONFIG_64BIT));\n\t\t\tbreak;\n\t\tcase SIOCGSTAMP_NEW:\n\t\tcase SIOCGSTAMPNS_NEW:\n\t\t\tif (!ops->gettstamp) {\n\t\t\t\terr = -ENOIOCTLCMD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = ops->gettstamp(sock, argp,\n\t\t\t\t\t     cmd == SIOCGSTAMP_NEW,\n\t\t\t\t\t     false);\n\t\t\tbreak;\n\n\t\tcase SIOCGIFCONF:\n\t\t\terr = dev_ifconf(net, argp);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = sock_do_ioctl(net, sock, cmd, arg);\n\t\t\tbreak;\n\t\t}\n\treturn err;\n}\n\n \n\nint sock_create_lite(int family, int type, int protocol, struct socket **res)\n{\n\tint err;\n\tstruct socket *sock = NULL;\n\n\terr = security_socket_create(family, type, protocol, 1);\n\tif (err)\n\t\tgoto out;\n\n\tsock = sock_alloc();\n\tif (!sock) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsock->type = type;\n\terr = security_socket_post_create(sock, family, type, protocol, 1);\n\tif (err)\n\t\tgoto out_release;\n\nout:\n\t*res = sock;\n\treturn err;\nout_release:\n\tsock_release(sock);\n\tsock = NULL;\n\tgoto out;\n}\nEXPORT_SYMBOL(sock_create_lite);\n\n \nstatic __poll_t sock_poll(struct file *file, poll_table *wait)\n{\n\tstruct socket *sock = file->private_data;\n\tconst struct proto_ops *ops = READ_ONCE(sock->ops);\n\t__poll_t events = poll_requested_events(wait), flag = 0;\n\n\tif (!ops->poll)\n\t\treturn 0;\n\n\tif (sk_can_busy_loop(sock->sk)) {\n\t\t \n\t\tif (events & POLL_BUSY_LOOP)\n\t\t\tsk_busy_loop(sock->sk, 1);\n\n\t\t \n\t\tflag = POLL_BUSY_LOOP;\n\t}\n\n\treturn ops->poll(file, sock, wait) | flag;\n}\n\nstatic int sock_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct socket *sock = file->private_data;\n\n\treturn READ_ONCE(sock->ops)->mmap(file, sock, vma);\n}\n\nstatic int sock_close(struct inode *inode, struct file *filp)\n{\n\t__sock_release(SOCKET_I(inode), inode);\n\treturn 0;\n}\n\n \n\nstatic int sock_fasync(int fd, struct file *filp, int on)\n{\n\tstruct socket *sock = filp->private_data;\n\tstruct sock *sk = sock->sk;\n\tstruct socket_wq *wq = &sock->wq;\n\n\tif (sk == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tfasync_helper(fd, filp, on, &wq->fasync_list);\n\n\tif (!wq->fasync_list)\n\t\tsock_reset_flag(sk, SOCK_FASYNC);\n\telse\n\t\tsock_set_flag(sk, SOCK_FASYNC);\n\n\trelease_sock(sk);\n\treturn 0;\n}\n\n \n\nint sock_wake_async(struct socket_wq *wq, int how, int band)\n{\n\tif (!wq || !wq->fasync_list)\n\t\treturn -1;\n\n\tswitch (how) {\n\tcase SOCK_WAKE_WAITD:\n\t\tif (test_bit(SOCKWQ_ASYNC_WAITDATA, &wq->flags))\n\t\t\tbreak;\n\t\tgoto call_kill;\n\tcase SOCK_WAKE_SPACE:\n\t\tif (!test_and_clear_bit(SOCKWQ_ASYNC_NOSPACE, &wq->flags))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SOCK_WAKE_IO:\ncall_kill:\n\t\tkill_fasync(&wq->fasync_list, SIGIO, band);\n\t\tbreak;\n\tcase SOCK_WAKE_URG:\n\t\tkill_fasync(&wq->fasync_list, SIGURG, band);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sock_wake_async);\n\n \n\nint __sock_create(struct net *net, int family, int type, int protocol,\n\t\t\t struct socket **res, int kern)\n{\n\tint err;\n\tstruct socket *sock;\n\tconst struct net_proto_family *pf;\n\n\t \n\tif (family < 0 || family >= NPROTO)\n\t\treturn -EAFNOSUPPORT;\n\tif (type < 0 || type >= SOCK_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tif (family == PF_INET && type == SOCK_PACKET) {\n\t\tpr_info_once(\"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\",\n\t\t\t     current->comm);\n\t\tfamily = PF_PACKET;\n\t}\n\n\terr = security_socket_create(family, type, protocol, kern);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsock = sock_alloc();\n\tif (!sock) {\n\t\tnet_warn_ratelimited(\"socket: no more sockets\\n\");\n\t\treturn -ENFILE;\t \n\t}\n\n\tsock->type = type;\n\n#ifdef CONFIG_MODULES\n\t \n\tif (rcu_access_pointer(net_families[family]) == NULL)\n\t\trequest_module(\"net-pf-%d\", family);\n#endif\n\n\trcu_read_lock();\n\tpf = rcu_dereference(net_families[family]);\n\terr = -EAFNOSUPPORT;\n\tif (!pf)\n\t\tgoto out_release;\n\n\t \n\tif (!try_module_get(pf->owner))\n\t\tgoto out_release;\n\n\t \n\trcu_read_unlock();\n\n\terr = pf->create(net, sock, protocol, kern);\n\tif (err < 0)\n\t\tgoto out_module_put;\n\n\t \n\tif (!try_module_get(sock->ops->owner))\n\t\tgoto out_module_busy;\n\n\t \n\tmodule_put(pf->owner);\n\terr = security_socket_post_create(sock, family, type, protocol, kern);\n\tif (err)\n\t\tgoto out_sock_release;\n\t*res = sock;\n\n\treturn 0;\n\nout_module_busy:\n\terr = -EAFNOSUPPORT;\nout_module_put:\n\tsock->ops = NULL;\n\tmodule_put(pf->owner);\nout_sock_release:\n\tsock_release(sock);\n\treturn err;\n\nout_release:\n\trcu_read_unlock();\n\tgoto out_sock_release;\n}\nEXPORT_SYMBOL(__sock_create);\n\n \n\nint sock_create(int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);\n}\nEXPORT_SYMBOL(sock_create);\n\n \n\nint sock_create_kern(struct net *net, int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(net, family, type, protocol, res, 1);\n}\nEXPORT_SYMBOL(sock_create_kern);\n\nstatic struct socket *__sys_socket_create(int family, int type, int protocol)\n{\n\tstruct socket *sock;\n\tint retval;\n\n\t \n\tBUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);\n\tBUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);\n\tBUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);\n\n\tif ((type & ~SOCK_TYPE_MASK) & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn ERR_PTR(-EINVAL);\n\ttype &= SOCK_TYPE_MASK;\n\n\tretval = sock_create(family, type, protocol, &sock);\n\tif (retval < 0)\n\t\treturn ERR_PTR(retval);\n\n\treturn sock;\n}\n\nstruct file *__sys_socket_file(int family, int type, int protocol)\n{\n\tstruct socket *sock;\n\tint flags;\n\n\tsock = __sys_socket_create(family, type, protocol);\n\tif (IS_ERR(sock))\n\t\treturn ERR_CAST(sock);\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\treturn sock_alloc_file(sock, flags, NULL);\n}\n\n \n\n__diag_push();\n__diag_ignore_all(\"-Wmissing-prototypes\",\n\t\t  \"A fmod_ret entry point for BPF programs\");\n\n__weak noinline int update_socket_protocol(int family, int type, int protocol)\n{\n\treturn protocol;\n}\n\n__diag_pop();\n\nint __sys_socket(int family, int type, int protocol)\n{\n\tstruct socket *sock;\n\tint flags;\n\n\tsock = __sys_socket_create(family, type,\n\t\t\t\t   update_socket_protocol(family, type, protocol));\n\tif (IS_ERR(sock))\n\t\treturn PTR_ERR(sock);\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\treturn sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));\n}\n\nSYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)\n{\n\treturn __sys_socket(family, type, protocol);\n}\n\n \n\nint __sys_socketpair(int family, int type, int protocol, int __user *usockvec)\n{\n\tstruct socket *sock1, *sock2;\n\tint fd1, fd2, err;\n\tstruct file *newfile1, *newfile2;\n\tint flags;\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\t \n\tfd1 = get_unused_fd_flags(flags);\n\tif (unlikely(fd1 < 0))\n\t\treturn fd1;\n\n\tfd2 = get_unused_fd_flags(flags);\n\tif (unlikely(fd2 < 0)) {\n\t\tput_unused_fd(fd1);\n\t\treturn fd2;\n\t}\n\n\terr = put_user(fd1, &usockvec[0]);\n\tif (err)\n\t\tgoto out;\n\n\terr = put_user(fd2, &usockvec[1]);\n\tif (err)\n\t\tgoto out;\n\n\t \n\n\terr = sock_create(family, type, protocol, &sock1);\n\tif (unlikely(err < 0))\n\t\tgoto out;\n\n\terr = sock_create(family, type, protocol, &sock2);\n\tif (unlikely(err < 0)) {\n\t\tsock_release(sock1);\n\t\tgoto out;\n\t}\n\n\terr = security_socket_socketpair(sock1, sock2);\n\tif (unlikely(err)) {\n\t\tsock_release(sock2);\n\t\tsock_release(sock1);\n\t\tgoto out;\n\t}\n\n\terr = READ_ONCE(sock1->ops)->socketpair(sock1, sock2);\n\tif (unlikely(err < 0)) {\n\t\tsock_release(sock2);\n\t\tsock_release(sock1);\n\t\tgoto out;\n\t}\n\n\tnewfile1 = sock_alloc_file(sock1, flags, NULL);\n\tif (IS_ERR(newfile1)) {\n\t\terr = PTR_ERR(newfile1);\n\t\tsock_release(sock2);\n\t\tgoto out;\n\t}\n\n\tnewfile2 = sock_alloc_file(sock2, flags, NULL);\n\tif (IS_ERR(newfile2)) {\n\t\terr = PTR_ERR(newfile2);\n\t\tfput(newfile1);\n\t\tgoto out;\n\t}\n\n\taudit_fd_pair(fd1, fd2);\n\n\tfd_install(fd1, newfile1);\n\tfd_install(fd2, newfile2);\n\treturn 0;\n\nout:\n\tput_unused_fd(fd2);\n\tput_unused_fd(fd1);\n\treturn err;\n}\n\nSYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol,\n\t\tint __user *, usockvec)\n{\n\treturn __sys_socketpair(family, type, protocol, usockvec);\n}\n\n \n\nint __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\terr = move_addr_to_kernel(umyaddr, addrlen, &address);\n\t\tif (!err) {\n\t\t\terr = security_socket_bind(sock,\n\t\t\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t\t\t   addrlen);\n\t\t\tif (!err)\n\t\t\t\terr = READ_ONCE(sock->ops)->bind(sock,\n\t\t\t\t\t\t      (struct sockaddr *)\n\t\t\t\t\t\t      &address, addrlen);\n\t\t}\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)\n{\n\treturn __sys_bind(fd, umyaddr, addrlen);\n}\n\n \n\nint __sys_listen(int fd, int backlog)\n{\n\tstruct socket *sock;\n\tint err, fput_needed;\n\tint somaxconn;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\tsomaxconn = READ_ONCE(sock_net(sock->sk)->core.sysctl_somaxconn);\n\t\tif ((unsigned int)backlog > somaxconn)\n\t\t\tbacklog = somaxconn;\n\n\t\terr = security_socket_listen(sock, backlog);\n\t\tif (!err)\n\t\t\terr = READ_ONCE(sock->ops)->listen(sock, backlog);\n\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE2(listen, int, fd, int, backlog)\n{\n\treturn __sys_listen(fd, backlog);\n}\n\nstruct file *do_accept(struct file *file, unsigned file_flags,\n\t\t       struct sockaddr __user *upeer_sockaddr,\n\t\t       int __user *upeer_addrlen, int flags)\n{\n\tstruct socket *sock, *newsock;\n\tstruct file *newfile;\n\tint err, len;\n\tstruct sockaddr_storage address;\n\tconst struct proto_ops *ops;\n\n\tsock = sock_from_file(file);\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\n\tnewsock = sock_alloc();\n\tif (!newsock)\n\t\treturn ERR_PTR(-ENFILE);\n\tops = READ_ONCE(sock->ops);\n\n\tnewsock->type = sock->type;\n\tnewsock->ops = ops;\n\n\t \n\t__module_get(ops->owner);\n\n\tnewfile = sock_alloc_file(newsock, flags, sock->sk->sk_prot_creator->name);\n\tif (IS_ERR(newfile))\n\t\treturn newfile;\n\n\terr = security_socket_accept(sock, newsock);\n\tif (err)\n\t\tgoto out_fd;\n\n\terr = ops->accept(sock, newsock, sock->file->f_flags | file_flags,\n\t\t\t\t\tfalse);\n\tif (err < 0)\n\t\tgoto out_fd;\n\n\tif (upeer_sockaddr) {\n\t\tlen = ops->getname(newsock, (struct sockaddr *)&address, 2);\n\t\tif (len < 0) {\n\t\t\terr = -ECONNABORTED;\n\t\t\tgoto out_fd;\n\t\t}\n\t\terr = move_addr_to_user(&address,\n\t\t\t\t\tlen, upeer_sockaddr, upeer_addrlen);\n\t\tif (err < 0)\n\t\t\tgoto out_fd;\n\t}\n\n\t \n\treturn newfile;\nout_fd:\n\tfput(newfile);\n\treturn ERR_PTR(err);\n}\n\nstatic int __sys_accept4_file(struct file *file, struct sockaddr __user *upeer_sockaddr,\n\t\t\t      int __user *upeer_addrlen, int flags)\n{\n\tstruct file *newfile;\n\tint newfd;\n\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\tnewfd = get_unused_fd_flags(flags);\n\tif (unlikely(newfd < 0))\n\t\treturn newfd;\n\n\tnewfile = do_accept(file, 0, upeer_sockaddr, upeer_addrlen,\n\t\t\t    flags);\n\tif (IS_ERR(newfile)) {\n\t\tput_unused_fd(newfd);\n\t\treturn PTR_ERR(newfile);\n\t}\n\tfd_install(newfd, newfile);\n\treturn newfd;\n}\n\n \n\nint __sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr,\n\t\t  int __user *upeer_addrlen, int flags)\n{\n\tint ret = -EBADF;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = __sys_accept4_file(f.file, upeer_sockaddr,\n\t\t\t\t\t upeer_addrlen, flags);\n\t\tfdput(f);\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen, int, flags)\n{\n\treturn __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, flags);\n}\n\nSYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen)\n{\n\treturn __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0);\n}\n\n \n\nint __sys_connect_file(struct file *file, struct sockaddr_storage *address,\n\t\t       int addrlen, int file_flags)\n{\n\tstruct socket *sock;\n\tint err;\n\n\tsock = sock_from_file(file);\n\tif (!sock) {\n\t\terr = -ENOTSOCK;\n\t\tgoto out;\n\t}\n\n\terr =\n\t    security_socket_connect(sock, (struct sockaddr *)address, addrlen);\n\tif (err)\n\t\tgoto out;\n\n\terr = READ_ONCE(sock->ops)->connect(sock, (struct sockaddr *)address,\n\t\t\t\taddrlen, sock->file->f_flags | file_flags);\nout:\n\treturn err;\n}\n\nint __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen)\n{\n\tint ret = -EBADF;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tstruct sockaddr_storage address;\n\n\t\tret = move_addr_to_kernel(uservaddr, addrlen, &address);\n\t\tif (!ret)\n\t\t\tret = __sys_connect_file(f.file, &address, addrlen, 0);\n\t\tfdput(f);\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,\n\t\tint, addrlen)\n{\n\treturn __sys_connect(fd, uservaddr, addrlen);\n}\n\n \n\nint __sys_getsockname(int fd, struct sockaddr __user *usockaddr,\n\t\t      int __user *usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = security_socket_getsockname(sock);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = READ_ONCE(sock->ops)->getname(sock, (struct sockaddr *)&address, 0);\n\tif (err < 0)\n\t\tgoto out_put;\n\t \n\terr = move_addr_to_user(&address, err, usockaddr, usockaddr_len);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\treturn __sys_getsockname(fd, usockaddr, usockaddr_len);\n}\n\n \n\nint __sys_getpeername(int fd, struct sockaddr __user *usockaddr,\n\t\t      int __user *usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\tconst struct proto_ops *ops = READ_ONCE(sock->ops);\n\n\t\terr = security_socket_getpeername(sock);\n\t\tif (err) {\n\t\t\tfput_light(sock->file, fput_needed);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = ops->getname(sock, (struct sockaddr *)&address, 1);\n\t\tif (err >= 0)\n\t\t\t \n\t\t\terr = move_addr_to_user(&address, err, usockaddr,\n\t\t\t\t\t\tusockaddr_len);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\treturn __sys_getpeername(fd, usockaddr, usockaddr_len);\n}\n\n \nint __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,\n\t\t struct sockaddr __user *addr,  int addr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint fput_needed;\n\n\terr = import_single_range(ITER_SOURCE, buff, len, &iov, &msg.msg_iter);\n\tif (unlikely(err))\n\t\treturn err;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_ubuf = NULL;\n\tif (addr) {\n\t\terr = move_addr_to_kernel(addr, addr_len, &address);\n\t\tif (err < 0)\n\t\t\tgoto out_put;\n\t\tmsg.msg_name = (struct sockaddr *)&address;\n\t\tmsg.msg_namelen = addr_len;\n\t}\n\tflags &= ~MSG_INTERNAL_SENDMSG_FLAGS;\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tmsg.msg_flags = flags;\n\terr = __sock_sendmsg(sock, &msg);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint, addr_len)\n{\n\treturn __sys_sendto(fd, buff, len, flags, addr, addr_len);\n}\n\n \n\nSYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned int, flags)\n{\n\treturn __sys_sendto(fd, buff, len, flags, NULL, 0);\n}\n\n \nint __sys_recvfrom(int fd, void __user *ubuf, size_t size, unsigned int flags,\n\t\t   struct sockaddr __user *addr, int __user *addr_len)\n{\n\tstruct sockaddr_storage address;\n\tstruct msghdr msg = {\n\t\t \n\t\t.msg_name = addr ? (struct sockaddr *)&address : NULL,\n\t};\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tint err, err2;\n\tint fput_needed;\n\n\terr = import_single_range(ITER_DEST, ubuf, size, &iov, &msg.msg_iter);\n\tif (unlikely(err))\n\t\treturn err;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, flags);\n\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user(&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\treturn __sys_recvfrom(fd, ubuf, size, flags, addr, addr_len);\n}\n\n \n\nSYSCALL_DEFINE4(recv, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags)\n{\n\treturn __sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);\n}\n\nstatic bool sock_use_custom_sol_socket(const struct socket *sock)\n{\n\treturn test_bit(SOCK_CUSTOM_SOCKOPT, &sock->flags);\n}\n\n \nint __sys_setsockopt(int fd, int level, int optname, char __user *user_optval,\n\t\tint optlen)\n{\n\tsockptr_t optval = USER_SOCKPTR(user_optval);\n\tconst struct proto_ops *ops;\n\tchar *kernel_optval = NULL;\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tif (optlen < 0)\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\terr = security_socket_setsockopt(sock, level, optname);\n\tif (err)\n\t\tgoto out_put;\n\n\tif (!in_compat_syscall())\n\t\terr = BPF_CGROUP_RUN_PROG_SETSOCKOPT(sock->sk, &level, &optname,\n\t\t\t\t\t\t     user_optval, &optlen,\n\t\t\t\t\t\t     &kernel_optval);\n\tif (err < 0)\n\t\tgoto out_put;\n\tif (err > 0) {\n\t\terr = 0;\n\t\tgoto out_put;\n\t}\n\n\tif (kernel_optval)\n\t\toptval = KERNEL_SOCKPTR(kernel_optval);\n\tops = READ_ONCE(sock->ops);\n\tif (level == SOL_SOCKET && !sock_use_custom_sol_socket(sock))\n\t\terr = sock_setsockopt(sock, level, optname, optval, optlen);\n\telse if (unlikely(!ops->setsockopt))\n\t\terr = -EOPNOTSUPP;\n\telse\n\t\terr = ops->setsockopt(sock, level, optname, optval,\n\t\t\t\t\t    optlen);\n\tkfree(kernel_optval);\nout_put:\n\tfput_light(sock->file, fput_needed);\n\treturn err;\n}\n\nSYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,\n\t\tchar __user *, optval, int, optlen)\n{\n\treturn __sys_setsockopt(fd, level, optname, optval, optlen);\n}\n\nINDIRECT_CALLABLE_DECLARE(bool tcp_bpf_bypass_getsockopt(int level,\n\t\t\t\t\t\t\t int optname));\n\n \nint __sys_getsockopt(int fd, int level, int optname, char __user *optval,\n\t\tint __user *optlen)\n{\n\tint max_optlen __maybe_unused;\n\tconst struct proto_ops *ops;\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\terr = security_socket_getsockopt(sock, level, optname);\n\tif (err)\n\t\tgoto out_put;\n\n\tif (!in_compat_syscall())\n\t\tmax_optlen = BPF_CGROUP_GETSOCKOPT_MAX_OPTLEN(optlen);\n\n\tops = READ_ONCE(sock->ops);\n\tif (level == SOL_SOCKET)\n\t\terr = sock_getsockopt(sock, level, optname, optval, optlen);\n\telse if (unlikely(!ops->getsockopt))\n\t\terr = -EOPNOTSUPP;\n\telse\n\t\terr = ops->getsockopt(sock, level, optname, optval,\n\t\t\t\t\t    optlen);\n\n\tif (!in_compat_syscall())\n\t\terr = BPF_CGROUP_RUN_PROG_GETSOCKOPT(sock->sk, level, optname,\n\t\t\t\t\t\t     optval, optlen, max_optlen,\n\t\t\t\t\t\t     err);\nout_put:\n\tfput_light(sock->file, fput_needed);\n\treturn err;\n}\n\nSYSCALL_DEFINE5(getsockopt, int, fd, int, level, int, optname,\n\t\tchar __user *, optval, int __user *, optlen)\n{\n\treturn __sys_getsockopt(fd, level, optname, optval, optlen);\n}\n\n \n\nint __sys_shutdown_sock(struct socket *sock, int how)\n{\n\tint err;\n\n\terr = security_socket_shutdown(sock, how);\n\tif (!err)\n\t\terr = READ_ONCE(sock->ops)->shutdown(sock, how);\n\n\treturn err;\n}\n\nint __sys_shutdown(int fd, int how)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = __sys_shutdown_sock(sock, how);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE2(shutdown, int, fd, int, how)\n{\n\treturn __sys_shutdown(fd, how);\n}\n\n \n#define COMPAT_MSG(msg, member)\t((MSG_CMSG_COMPAT & flags) ? &msg##_compat->member : &msg->member)\n#define COMPAT_NAMELEN(msg)\tCOMPAT_MSG(msg, msg_namelen)\n#define COMPAT_FLAGS(msg)\tCOMPAT_MSG(msg, msg_flags)\n\nstruct used_address {\n\tstruct sockaddr_storage name;\n\tunsigned int name_len;\n};\n\nint __copy_msghdr(struct msghdr *kmsg,\n\t\t  struct user_msghdr *msg,\n\t\t  struct sockaddr __user **save_addr)\n{\n\tssize_t err;\n\n\tkmsg->msg_control_is_user = true;\n\tkmsg->msg_get_inq = 0;\n\tkmsg->msg_control_user = msg->msg_control;\n\tkmsg->msg_controllen = msg->msg_controllen;\n\tkmsg->msg_flags = msg->msg_flags;\n\n\tkmsg->msg_namelen = msg->msg_namelen;\n\tif (!msg->msg_name)\n\t\tkmsg->msg_namelen = 0;\n\n\tif (kmsg->msg_namelen < 0)\n\t\treturn -EINVAL;\n\n\tif (kmsg->msg_namelen > sizeof(struct sockaddr_storage))\n\t\tkmsg->msg_namelen = sizeof(struct sockaddr_storage);\n\n\tif (save_addr)\n\t\t*save_addr = msg->msg_name;\n\n\tif (msg->msg_name && kmsg->msg_namelen) {\n\t\tif (!save_addr) {\n\t\t\terr = move_addr_to_kernel(msg->msg_name,\n\t\t\t\t\t\t  kmsg->msg_namelen,\n\t\t\t\t\t\t  kmsg->msg_name);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tkmsg->msg_name = NULL;\n\t\tkmsg->msg_namelen = 0;\n\t}\n\n\tif (msg->msg_iovlen > UIO_MAXIOV)\n\t\treturn -EMSGSIZE;\n\n\tkmsg->msg_iocb = NULL;\n\tkmsg->msg_ubuf = NULL;\n\treturn 0;\n}\n\nstatic int copy_msghdr_from_user(struct msghdr *kmsg,\n\t\t\t\t struct user_msghdr __user *umsg,\n\t\t\t\t struct sockaddr __user **save_addr,\n\t\t\t\t struct iovec **iov)\n{\n\tstruct user_msghdr msg;\n\tssize_t err;\n\n\tif (copy_from_user(&msg, umsg, sizeof(*umsg)))\n\t\treturn -EFAULT;\n\n\terr = __copy_msghdr(kmsg, &msg, save_addr);\n\tif (err)\n\t\treturn err;\n\n\terr = import_iovec(save_addr ? ITER_DEST : ITER_SOURCE,\n\t\t\t    msg.msg_iov, msg.msg_iovlen,\n\t\t\t    UIO_FASTIOV, iov, &kmsg->msg_iter);\n\treturn err < 0 ? err : 0;\n}\n\nstatic int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,\n\t\t\t   unsigned int flags, struct used_address *used_address,\n\t\t\t   unsigned int allowed_msghdr_flags)\n{\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t\t\t\t__aligned(sizeof(__kernel_size_t));\n\t \n\tunsigned char *ctl_buf = ctl;\n\tint ctl_len;\n\tssize_t err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out;\n\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=\n\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t\tmsg_sys->msg_control_is_user = false;\n\t}\n\tflags &= ~MSG_INTERNAL_SENDMSG_FLAGS;\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t \n\tif (used_address && msg_sys->msg_name &&\n\t    used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg_sys->msg_name,\n\t\t    used_address->name_len)) {\n\t\terr = sock_sendmsg_nosec(sock, msg_sys);\n\t\tgoto out_freectl;\n\t}\n\terr = __sock_sendmsg(sock, msg_sys);\n\t \n\tif (used_address && err >= 0) {\n\t\tused_address->name_len = msg_sys->msg_namelen;\n\t\tif (msg_sys->msg_name)\n\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,\n\t\t\t       used_address->name_len);\n\t}\n\nout_freectl:\n\tif (ctl_buf != ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout:\n\treturn err;\n}\n\nint sendmsg_copy_msghdr(struct msghdr *msg,\n\t\t\tstruct user_msghdr __user *umsg, unsigned flags,\n\t\t\tstruct iovec **iov)\n{\n\tint err;\n\n\tif (flags & MSG_CMSG_COMPAT) {\n\t\tstruct compat_msghdr __user *msg_compat;\n\n\t\tmsg_compat = (struct compat_msghdr __user *) umsg;\n\t\terr = get_compat_msghdr(msg, msg_compat, NULL, iov);\n\t} else {\n\t\terr = copy_msghdr_from_user(msg, umsg, NULL, iov);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned int flags,\n\t\t\t struct used_address *used_address,\n\t\t\t unsigned int allowed_msghdr_flags)\n{\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tssize_t err;\n\n\tmsg_sys->msg_name = &address;\n\n\terr = sendmsg_copy_msghdr(msg_sys, msg, flags, &iov);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ____sys_sendmsg(sock, msg_sys, flags, used_address,\n\t\t\t\tallowed_msghdr_flags);\n\tkfree(iov);\n\treturn err;\n}\n\n \nlong __sys_sendmsg_sock(struct socket *sock, struct msghdr *msg,\n\t\t\tunsigned int flags)\n{\n\treturn ____sys_sendmsg(sock, msg, flags, NULL, 0);\n}\n\nlong __sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned int flags,\n\t\t   bool forbid_cmsg_compat)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock;\n\n\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags)\n{\n\treturn __sys_sendmsg(fd, msg, flags, true);\n}\n\n \n\nint __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, bool forbid_cmsg_compat)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct used_address used_address;\n\tunsigned int oflags = flags;\n\n\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (vlen > UIO_MAXIOV)\n\t\tvlen = UIO_MAXIOV;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\tused_address.name_len = UINT_MAX;\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\terr = 0;\n\tflags |= MSG_BATCH;\n\n\twhile (datagrams < vlen) {\n\t\tif (datagrams == vlen - 1)\n\t\t\tflags = oflags;\n\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = ___sys_sendmsg(sock, (struct user_msghdr __user *)compat_entry,\n\t\t\t\t\t     &msg_sys, flags, &used_address, MSG_EOR);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = ___sys_sendmsg(sock,\n\t\t\t\t\t     (struct user_msghdr __user *)entry,\n\t\t\t\t\t     &msg_sys, flags, &used_address, MSG_EOR);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\t\tif (msg_data_left(&msg_sys))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tfput_light(sock->file, fput_needed);\n\n\t \n\tif (datagrams != 0)\n\t\treturn datagrams;\n\n\treturn err;\n}\n\nSYSCALL_DEFINE4(sendmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags)\n{\n\treturn __sys_sendmmsg(fd, mmsg, vlen, flags, true);\n}\n\nint recvmsg_copy_msghdr(struct msghdr *msg,\n\t\t\tstruct user_msghdr __user *umsg, unsigned flags,\n\t\t\tstruct sockaddr __user **uaddr,\n\t\t\tstruct iovec **iov)\n{\n\tssize_t err;\n\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\tstruct compat_msghdr __user *msg_compat;\n\n\t\tmsg_compat = (struct compat_msghdr __user *) umsg;\n\t\terr = get_compat_msghdr(msg, msg_compat, uaddr, iov);\n\t} else {\n\t\terr = copy_msghdr_from_user(msg, umsg, uaddr, iov);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int ____sys_recvmsg(struct socket *sock, struct msghdr *msg_sys,\n\t\t\t   struct user_msghdr __user *msg,\n\t\t\t   struct sockaddr __user *uaddr,\n\t\t\t   unsigned int flags, int nosec)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t\t\t\t\t(struct compat_msghdr __user *) msg;\n\tint __user *uaddr_len = COMPAT_NAMELEN(msg);\n\tstruct sockaddr_storage addr;\n\tunsigned long cmsg_ptr;\n\tint len;\n\tssize_t err;\n\n\tmsg_sys->msg_name = &addr;\n\tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n\tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\n\t \n\tmsg_sys->msg_namelen = 0;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\n\tif (unlikely(nosec))\n\t\terr = sock_recvmsg_nosec(sock, msg_sys, flags);\n\telse\n\t\terr = sock_recvmsg(sock, msg_sys, flags);\n\n\tif (err < 0)\n\t\tgoto out;\n\tlen = err;\n\n\tif (uaddr != NULL) {\n\t\terr = move_addr_to_user(&addr,\n\t\t\t\t\tmsg_sys->msg_namelen, uaddr,\n\t\t\t\t\tuaddr_len);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\terr = __put_user((msg_sys->msg_flags & ~MSG_CMSG_COMPAT),\n\t\t\t COMPAT_FLAGS(msg));\n\tif (err)\n\t\tgoto out;\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg_compat->msg_controllen);\n\telse\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg->msg_controllen);\n\tif (err)\n\t\tgoto out;\n\terr = len;\nout:\n\treturn err;\n}\n\nstatic int ___sys_recvmsg(struct socket *sock, struct user_msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned int flags, int nosec)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\t \n\tstruct sockaddr __user *uaddr;\n\tssize_t err;\n\n\terr = recvmsg_copy_msghdr(msg_sys, msg, flags, &uaddr, &iov);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ____sys_recvmsg(sock, msg_sys, msg, uaddr, flags, nosec);\n\tkfree(iov);\n\treturn err;\n}\n\n \n\nlong __sys_recvmsg_sock(struct socket *sock, struct msghdr *msg,\n\t\t\tstruct user_msghdr __user *umsg,\n\t\t\tstruct sockaddr __user *uaddr, unsigned int flags)\n{\n\treturn ____sys_recvmsg(sock, msg, umsg, uaddr, flags, 0);\n}\n\nlong __sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned int flags,\n\t\t   bool forbid_cmsg_compat)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock;\n\n\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = ___sys_recvmsg(sock, msg, &msg_sys, flags, 0);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(recvmsg, int, fd, struct user_msghdr __user *, msg,\n\t\tunsigned int, flags)\n{\n\treturn __sys_recvmsg(fd, msg, flags, true);\n}\n\n \n\nstatic int do_recvmmsg(int fd, struct mmsghdr __user *mmsg,\n\t\t\t  unsigned int vlen, unsigned int flags,\n\t\t\t  struct timespec64 *timeout)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct timespec64 end_time;\n\tstruct timespec64 timeout64;\n\n\tif (timeout &&\n\t    poll_select_set_timeout(&end_time, timeout->tv_sec,\n\t\t\t\t    timeout->tv_nsec))\n\t\treturn -EINVAL;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\tif (likely(!(flags & MSG_ERRQUEUE))) {\n\t\terr = sock_error(sock->sk);\n\t\tif (err) {\n\t\t\tdatagrams = err;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\n\twhile (datagrams < vlen) {\n\t\t \n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = ___sys_recvmsg(sock,\n\t\t\t\t\t     (struct user_msghdr __user *)entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\n\t\t \n\t\tif (flags & MSG_WAITFORONE)\n\t\t\tflags |= MSG_DONTWAIT;\n\n\t\tif (timeout) {\n\t\t\tktime_get_ts64(&timeout64);\n\t\t\t*timeout = timespec64_sub(end_time, timeout64);\n\t\t\tif (timeout->tv_sec < 0) {\n\t\t\t\ttimeout->tv_sec = timeout->tv_nsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (timeout->tv_nsec == 0 && timeout->tv_sec == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (msg_sys.msg_flags & MSG_OOB)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tif (err == 0)\n\t\tgoto out_put;\n\n\tif (datagrams == 0) {\n\t\tdatagrams = err;\n\t\tgoto out_put;\n\t}\n\n\t \n\tif (err != -EAGAIN) {\n\t\t \n\t\tWRITE_ONCE(sock->sk->sk_err, -err);\n\t}\nout_put:\n\tfput_light(sock->file, fput_needed);\n\n\treturn datagrams;\n}\n\nint __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg,\n\t\t   unsigned int vlen, unsigned int flags,\n\t\t   struct __kernel_timespec __user *timeout,\n\t\t   struct old_timespec32 __user *timeout32)\n{\n\tint datagrams;\n\tstruct timespec64 timeout_sys;\n\n\tif (timeout && get_timespec64(&timeout_sys, timeout))\n\t\treturn -EFAULT;\n\n\tif (timeout32 && get_old_timespec32(&timeout_sys, timeout32))\n\t\treturn -EFAULT;\n\n\tif (!timeout && !timeout32)\n\t\treturn do_recvmmsg(fd, mmsg, vlen, flags, NULL);\n\n\tdatagrams = do_recvmmsg(fd, mmsg, vlen, flags, &timeout_sys);\n\n\tif (datagrams <= 0)\n\t\treturn datagrams;\n\n\tif (timeout && put_timespec64(&timeout_sys, timeout))\n\t\tdatagrams = -EFAULT;\n\n\tif (timeout32 && put_old_timespec32(&timeout_sys, timeout32))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}\n\nSYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags,\n\t\tstruct __kernel_timespec __user *, timeout)\n{\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\treturn __sys_recvmmsg(fd, mmsg, vlen, flags, timeout, NULL);\n}\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nSYSCALL_DEFINE5(recvmmsg_time32, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags,\n\t\tstruct old_timespec32 __user *, timeout)\n{\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\treturn __sys_recvmmsg(fd, mmsg, vlen, flags, NULL, timeout);\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_SOCKETCALL\n \n#define AL(x) ((x) * sizeof(unsigned long))\nstatic const unsigned char nargs[21] = {\n\tAL(0), AL(3), AL(3), AL(3), AL(2), AL(3),\n\tAL(3), AL(3), AL(4), AL(4), AL(4), AL(6),\n\tAL(6), AL(2), AL(5), AL(5), AL(3), AL(3),\n\tAL(4), AL(5), AL(4)\n};\n\n#undef AL\n\n \n\nSYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)\n{\n\tunsigned long a[AUDITSC_ARGS];\n\tunsigned long a0, a1;\n\tint err;\n\tunsigned int len;\n\n\tif (call < 1 || call > SYS_SENDMMSG)\n\t\treturn -EINVAL;\n\tcall = array_index_nospec(call, SYS_SENDMMSG + 1);\n\n\tlen = nargs[call];\n\tif (len > sizeof(a))\n\t\treturn -EINVAL;\n\n\t \n\tif (copy_from_user(a, args, len))\n\t\treturn -EFAULT;\n\n\terr = audit_socketcall(nargs[call] / sizeof(unsigned long), a);\n\tif (err)\n\t\treturn err;\n\n\ta0 = a[0];\n\ta1 = a[1];\n\n\tswitch (call) {\n\tcase SYS_SOCKET:\n\t\terr = __sys_socket(a0, a1, a[2]);\n\t\tbreak;\n\tcase SYS_BIND:\n\t\terr = __sys_bind(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\terr = __sys_connect(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_LISTEN:\n\t\terr = __sys_listen(a0, a1);\n\t\tbreak;\n\tcase SYS_ACCEPT:\n\t\terr = __sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2], 0);\n\t\tbreak;\n\tcase SYS_GETSOCKNAME:\n\t\terr =\n\t\t    __sys_getsockname(a0, (struct sockaddr __user *)a1,\n\t\t\t\t      (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_GETPEERNAME:\n\t\terr =\n\t\t    __sys_getpeername(a0, (struct sockaddr __user *)a1,\n\t\t\t\t      (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_SOCKETPAIR:\n\t\terr = __sys_socketpair(a0, a1, a[2], (int __user *)a[3]);\n\t\tbreak;\n\tcase SYS_SEND:\n\t\terr = __sys_sendto(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t   NULL, 0);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\terr = __sys_sendto(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t   (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_RECV:\n\t\terr = __sys_recvfrom(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t     NULL, NULL);\n\t\tbreak;\n\tcase SYS_RECVFROM:\n\t\terr = __sys_recvfrom(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t     (struct sockaddr __user *)a[4],\n\t\t\t\t     (int __user *)a[5]);\n\t\tbreak;\n\tcase SYS_SHUTDOWN:\n\t\terr = __sys_shutdown(a0, a1);\n\t\tbreak;\n\tcase SYS_SETSOCKOPT:\n\t\terr = __sys_setsockopt(a0, a1, a[2], (char __user *)a[3],\n\t\t\t\t       a[4]);\n\t\tbreak;\n\tcase SYS_GETSOCKOPT:\n\t\terr =\n\t\t    __sys_getsockopt(a0, a1, a[2], (char __user *)a[3],\n\t\t\t\t     (int __user *)a[4]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\terr = __sys_sendmsg(a0, (struct user_msghdr __user *)a1,\n\t\t\t\t    a[2], true);\n\t\tbreak;\n\tcase SYS_SENDMMSG:\n\t\terr = __sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[2],\n\t\t\t\t     a[3], true);\n\t\tbreak;\n\tcase SYS_RECVMSG:\n\t\terr = __sys_recvmsg(a0, (struct user_msghdr __user *)a1,\n\t\t\t\t    a[2], true);\n\t\tbreak;\n\tcase SYS_RECVMMSG:\n\t\tif (IS_ENABLED(CONFIG_64BIT))\n\t\t\terr = __sys_recvmmsg(a0, (struct mmsghdr __user *)a1,\n\t\t\t\t\t     a[2], a[3],\n\t\t\t\t\t     (struct __kernel_timespec __user *)a[4],\n\t\t\t\t\t     NULL);\n\t\telse\n\t\t\terr = __sys_recvmmsg(a0, (struct mmsghdr __user *)a1,\n\t\t\t\t\t     a[2], a[3], NULL,\n\t\t\t\t\t     (struct old_timespec32 __user *)a[4]);\n\t\tbreak;\n\tcase SYS_ACCEPT4:\n\t\terr = __sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2], a[3]);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n#endif\t\t\t\t \n\n \nint sock_register(const struct net_proto_family *ops)\n{\n\tint err;\n\n\tif (ops->family >= NPROTO) {\n\t\tpr_crit(\"protocol %d >= NPROTO(%d)\\n\", ops->family, NPROTO);\n\t\treturn -ENOBUFS;\n\t}\n\n\tspin_lock(&net_family_lock);\n\tif (rcu_dereference_protected(net_families[ops->family],\n\t\t\t\t      lockdep_is_held(&net_family_lock)))\n\t\terr = -EEXIST;\n\telse {\n\t\trcu_assign_pointer(net_families[ops->family], ops);\n\t\terr = 0;\n\t}\n\tspin_unlock(&net_family_lock);\n\n\tpr_info(\"NET: Registered %s protocol family\\n\", pf_family_names[ops->family]);\n\treturn err;\n}\nEXPORT_SYMBOL(sock_register);\n\n \nvoid sock_unregister(int family)\n{\n\tBUG_ON(family < 0 || family >= NPROTO);\n\n\tspin_lock(&net_family_lock);\n\tRCU_INIT_POINTER(net_families[family], NULL);\n\tspin_unlock(&net_family_lock);\n\n\tsynchronize_rcu();\n\n\tpr_info(\"NET: Unregistered %s protocol family\\n\", pf_family_names[family]);\n}\nEXPORT_SYMBOL(sock_unregister);\n\nbool sock_is_registered(int family)\n{\n\treturn family < NPROTO && rcu_access_pointer(net_families[family]);\n}\n\nstatic int __init sock_init(void)\n{\n\tint err;\n\t \n\terr = net_sysctl_init();\n\tif (err)\n\t\tgoto out;\n\n\t \n\tskb_init();\n\n\t \n\n\tinit_inodecache();\n\n\terr = register_filesystem(&sock_fs_type);\n\tif (err)\n\t\tgoto out;\n\tsock_mnt = kern_mount(&sock_fs_type);\n\tif (IS_ERR(sock_mnt)) {\n\t\terr = PTR_ERR(sock_mnt);\n\t\tgoto out_mount;\n\t}\n\n\t \n\n#ifdef CONFIG_NETFILTER\n\terr = netfilter_init();\n\tif (err)\n\t\tgoto out;\n#endif\n\n\tptp_classifier_init();\n\nout:\n\treturn err;\n\nout_mount:\n\tunregister_filesystem(&sock_fs_type);\n\tgoto out;\n}\n\ncore_initcall(sock_init);\t \n\n#ifdef CONFIG_PROC_FS\nvoid socket_seq_show(struct seq_file *seq)\n{\n\tseq_printf(seq, \"sockets: used %d\\n\",\n\t\t   sock_inuse_get(seq->private));\n}\n#endif\t\t\t\t \n\n \nint get_user_ifreq(struct ifreq *ifr, void __user **ifrdata, void __user *arg)\n{\n\tif (in_compat_syscall()) {\n\t\tstruct compat_ifreq *ifr32 = (struct compat_ifreq *)ifr;\n\n\t\tmemset(ifr, 0, sizeof(*ifr));\n\t\tif (copy_from_user(ifr32, arg, sizeof(*ifr32)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ifrdata)\n\t\t\t*ifrdata = compat_ptr(ifr32->ifr_data);\n\n\t\treturn 0;\n\t}\n\n\tif (copy_from_user(ifr, arg, sizeof(*ifr)))\n\t\treturn -EFAULT;\n\n\tif (ifrdata)\n\t\t*ifrdata = ifr->ifr_data;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(get_user_ifreq);\n\nint put_user_ifreq(struct ifreq *ifr, void __user *arg)\n{\n\tsize_t size = sizeof(*ifr);\n\n\tif (in_compat_syscall())\n\t\tsize = sizeof(struct compat_ifreq);\n\n\tif (copy_to_user(arg, ifr, size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(put_user_ifreq);\n\n#ifdef CONFIG_COMPAT\nstatic int compat_siocwandev(struct net *net, struct compat_ifreq __user *uifr32)\n{\n\tcompat_uptr_t uptr32;\n\tstruct ifreq ifr;\n\tvoid __user *saved;\n\tint err;\n\n\tif (get_user_ifreq(&ifr, NULL, uifr32))\n\t\treturn -EFAULT;\n\n\tif (get_user(uptr32, &uifr32->ifr_settings.ifs_ifsu))\n\t\treturn -EFAULT;\n\n\tsaved = ifr.ifr_settings.ifs_ifsu.raw_hdlc;\n\tifr.ifr_settings.ifs_ifsu.raw_hdlc = compat_ptr(uptr32);\n\n\terr = dev_ioctl(net, SIOCWANDEV, &ifr, NULL, NULL);\n\tif (!err) {\n\t\tifr.ifr_settings.ifs_ifsu.raw_hdlc = saved;\n\t\tif (put_user_ifreq(&ifr, uifr32))\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\n\n \nstatic int compat_ifr_data_ioctl(struct net *net, unsigned int cmd,\n\t\t\t\t struct compat_ifreq __user *u_ifreq32)\n{\n\tstruct ifreq ifreq;\n\tvoid __user *data;\n\n\tif (!is_socket_ioctl_cmd(cmd))\n\t\treturn -ENOTTY;\n\tif (get_user_ifreq(&ifreq, &data, u_ifreq32))\n\t\treturn -EFAULT;\n\tifreq.ifr_data = data;\n\n\treturn dev_ioctl(net, cmd, &ifreq, data, NULL);\n}\n\nstatic int compat_sock_ioctl_trans(struct file *file, struct socket *sock,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tconst struct proto_ops *ops;\n\n\tif (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))\n\t\treturn sock_ioctl(file, cmd, (unsigned long)argp);\n\n\tswitch (cmd) {\n\tcase SIOCWANDEV:\n\t\treturn compat_siocwandev(net, argp);\n\tcase SIOCGSTAMP_OLD:\n\tcase SIOCGSTAMPNS_OLD:\n\t\tops = READ_ONCE(sock->ops);\n\t\tif (!ops->gettstamp)\n\t\t\treturn -ENOIOCTLCMD;\n\t\treturn ops->gettstamp(sock, argp, cmd == SIOCGSTAMP_OLD,\n\t\t\t\t      !COMPAT_USE_64BIT_TIME);\n\n\tcase SIOCETHTOOL:\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\tcase SIOCSHWTSTAMP:\n\tcase SIOCGHWTSTAMP:\n\t\treturn compat_ifr_data_ioctl(net, cmd, argp);\n\n\tcase FIOSETOWN:\n\tcase SIOCSPGRP:\n\tcase FIOGETOWN:\n\tcase SIOCGPGRP:\n\tcase SIOCBRADDBR:\n\tcase SIOCBRDELBR:\n\tcase SIOCGIFVLAN:\n\tcase SIOCSIFVLAN:\n\tcase SIOCGSKNS:\n\tcase SIOCGSTAMP_NEW:\n\tcase SIOCGSTAMPNS_NEW:\n\tcase SIOCGIFCONF:\n\tcase SIOCSIFBR:\n\tcase SIOCGIFBR:\n\t\treturn sock_ioctl(file, cmd, arg);\n\n\tcase SIOCGIFFLAGS:\n\tcase SIOCSIFFLAGS:\n\tcase SIOCGIFMAP:\n\tcase SIOCSIFMAP:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\tcase SIOCGIFMTU:\n\tcase SIOCSIFMTU:\n\tcase SIOCGIFMEM:\n\tcase SIOCSIFMEM:\n\tcase SIOCGIFHWADDR:\n\tcase SIOCSIFHWADDR:\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\tcase SIOCGIFINDEX:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCSIFHWBROADCAST:\n\tcase SIOCDIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCSIFPFLAGS:\n\tcase SIOCGIFPFLAGS:\n\tcase SIOCGIFTXQLEN:\n\tcase SIOCSIFTXQLEN:\n\tcase SIOCBRADDIF:\n\tcase SIOCBRDELIF:\n\tcase SIOCGIFNAME:\n\tcase SIOCSIFNAME:\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDCHANGEACTIVE:\n\tcase SIOCSARP:\n\tcase SIOCGARP:\n\tcase SIOCDARP:\n\tcase SIOCOUTQ:\n\tcase SIOCOUTQNSD:\n\tcase SIOCATMARK:\n\t\treturn sock_do_ioctl(net, sock, cmd, arg);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic long compat_sock_ioctl(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct socket *sock = file->private_data;\n\tconst struct proto_ops *ops = READ_ONCE(sock->ops);\n\tint ret = -ENOIOCTLCMD;\n\tstruct sock *sk;\n\tstruct net *net;\n\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\n\tif (ops->compat_ioctl)\n\t\tret = ops->compat_ioctl(sock, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD &&\n\t    (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST))\n\t\tret = compat_wext_handle_ioctl(net, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD)\n\t\tret = compat_sock_ioctl_trans(file, sock, cmd, arg);\n\n\treturn ret;\n}\n#endif\n\n \n\nint kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen)\n{\n\tstruct sockaddr_storage address;\n\n\tmemcpy(&address, addr, addrlen);\n\n\treturn READ_ONCE(sock->ops)->bind(sock, (struct sockaddr *)&address,\n\t\t\t\t\t  addrlen);\n}\nEXPORT_SYMBOL(kernel_bind);\n\n \n\nint kernel_listen(struct socket *sock, int backlog)\n{\n\treturn READ_ONCE(sock->ops)->listen(sock, backlog);\n}\nEXPORT_SYMBOL(kernel_listen);\n\n \n\nint kernel_accept(struct socket *sock, struct socket **newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tconst struct proto_ops *ops = READ_ONCE(sock->ops);\n\tint err;\n\n\terr = sock_create_lite(sk->sk_family, sk->sk_type, sk->sk_protocol,\n\t\t\t       newsock);\n\tif (err < 0)\n\t\tgoto done;\n\n\terr = ops->accept(sock, *newsock, flags, true);\n\tif (err < 0) {\n\t\tsock_release(*newsock);\n\t\t*newsock = NULL;\n\t\tgoto done;\n\t}\n\n\t(*newsock)->ops = ops;\n\t__module_get(ops->owner);\n\ndone:\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_accept);\n\n \n\nint kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,\n\t\t   int flags)\n{\n\tstruct sockaddr_storage address;\n\n\tmemcpy(&address, addr, addrlen);\n\n\treturn READ_ONCE(sock->ops)->connect(sock, (struct sockaddr *)&address,\n\t\t\t\t\t     addrlen, flags);\n}\nEXPORT_SYMBOL(kernel_connect);\n\n \n\nint kernel_getsockname(struct socket *sock, struct sockaddr *addr)\n{\n\treturn READ_ONCE(sock->ops)->getname(sock, addr, 0);\n}\nEXPORT_SYMBOL(kernel_getsockname);\n\n \n\nint kernel_getpeername(struct socket *sock, struct sockaddr *addr)\n{\n\treturn READ_ONCE(sock->ops)->getname(sock, addr, 1);\n}\nEXPORT_SYMBOL(kernel_getpeername);\n\n \n\nint kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how)\n{\n\treturn READ_ONCE(sock->ops)->shutdown(sock, how);\n}\nEXPORT_SYMBOL(kernel_sock_shutdown);\n\n \n\nu32 kernel_sock_ip_overhead(struct sock *sk)\n{\n\tstruct inet_sock *inet;\n\tstruct ip_options_rcu *opt;\n\tu32 overhead = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct ipv6_pinfo *np;\n\tstruct ipv6_txoptions *optv6 = NULL;\n#endif  \n\n\tif (!sk)\n\t\treturn overhead;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tinet = inet_sk(sk);\n\t\toverhead += sizeof(struct iphdr);\n\t\topt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\tsock_owned_by_user(sk));\n\t\tif (opt)\n\t\t\toverhead += opt->opt.optlen;\n\t\treturn overhead;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tnp = inet6_sk(sk);\n\t\toverhead += sizeof(struct ipv6hdr);\n\t\tif (np)\n\t\t\toptv6 = rcu_dereference_protected(np->opt,\n\t\t\t\t\t\t\t  sock_owned_by_user(sk));\n\t\tif (optv6)\n\t\t\toverhead += (optv6->opt_flen + optv6->opt_nflen);\n\t\treturn overhead;\n#endif  \n\tdefault:  \n\t\treturn overhead;\n\t}\n}\nEXPORT_SYMBOL(kernel_sock_ip_overhead);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}