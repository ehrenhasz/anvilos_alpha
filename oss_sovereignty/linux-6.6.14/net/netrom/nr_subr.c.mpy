{
  "module_name": "nr_subr.c",
  "hash_id": "18615bf149b4f672cd834fc4d4497c441e2c0ec099a14955f95f816515a179a6",
  "original_prompt": "Ingested from linux-6.6.14/net/netrom/nr_subr.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/netrom.h>\n\n \nvoid nr_clear_queues(struct sock *sk)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&nr->ack_queue);\n\tskb_queue_purge(&nr->reseq_queue);\n\tskb_queue_purge(&nr->frag_queue);\n}\n\n \nvoid nr_frames_acked(struct sock *sk, unsigned short nr)\n{\n\tstruct nr_sock *nrom = nr_sk(sk);\n\tstruct sk_buff *skb;\n\n\t \n\tif (nrom->va != nr) {\n\t\twhile (skb_peek(&nrom->ack_queue) != NULL && nrom->va != nr) {\n\t\t\tskb = skb_dequeue(&nrom->ack_queue);\n\t\t\tkfree_skb(skb);\n\t\t\tnrom->va = (nrom->va + 1) % NR_MODULUS;\n\t\t}\n\t}\n}\n\n \nvoid nr_requeue_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\n\twhile ((skb = skb_dequeue(&nr_sk(sk)->ack_queue)) != NULL) {\n\t\tif (skb_prev == NULL)\n\t\t\tskb_queue_head(&sk->sk_write_queue, skb);\n\t\telse\n\t\t\tskb_append(skb_prev, skb, &sk->sk_write_queue);\n\t\tskb_prev = skb;\n\t}\n}\n\n \nint nr_validate_nr(struct sock *sk, unsigned short nr)\n{\n\tstruct nr_sock *nrom = nr_sk(sk);\n\tunsigned short vc = nrom->va;\n\n\twhile (vc != nrom->vs) {\n\t\tif (nr == vc) return 1;\n\t\tvc = (vc + 1) % NR_MODULUS;\n\t}\n\n\treturn nr == nrom->vs;\n}\n\n \nint nr_in_rx_window(struct sock *sk, unsigned short ns)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\tunsigned short vc = nr->vr;\n\tunsigned short vt = (nr->vl + nr->window) % NR_MODULUS;\n\n\twhile (vc != vt) {\n\t\tif (ns == vc) return 1;\n\t\tvc = (vc + 1) % NR_MODULUS;\n\t}\n\n\treturn 0;\n}\n\n \nvoid nr_write_internal(struct sock *sk, int frametype)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\tint len, timeout;\n\n\tlen = NR_TRANSPORT_LEN;\n\n\tswitch (frametype & 0x0F) {\n\tcase NR_CONNREQ:\n\t\tlen += 17;\n\t\tbreak;\n\tcase NR_CONNACK:\n\t\tlen += (nr->bpqext) ? 2 : 1;\n\t\tbreak;\n\tcase NR_DISCREQ:\n\tcase NR_DISCACK:\n\tcase NR_INFOACK:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"NET/ROM: nr_write_internal - invalid frame type %d\\n\", frametype);\n\t\treturn;\n\t}\n\n\tskb = alloc_skb(NR_NETWORK_LEN + len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\t \n\tskb_reserve(skb, NR_NETWORK_LEN);\n\n\tdptr = skb_put(skb, len);\n\n\tswitch (frametype & 0x0F) {\n\tcase NR_CONNREQ:\n\t\ttimeout  = nr->t1 / HZ;\n\t\t*dptr++  = nr->my_index;\n\t\t*dptr++  = nr->my_id;\n\t\t*dptr++  = 0;\n\t\t*dptr++  = 0;\n\t\t*dptr++  = frametype;\n\t\t*dptr++  = nr->window;\n\t\tmemcpy(dptr, &nr->user_addr, AX25_ADDR_LEN);\n\t\tdptr[6] &= ~AX25_CBIT;\n\t\tdptr[6] &= ~AX25_EBIT;\n\t\tdptr[6] |= AX25_SSSID_SPARE;\n\t\tdptr    += AX25_ADDR_LEN;\n\t\tmemcpy(dptr, &nr->source_addr, AX25_ADDR_LEN);\n\t\tdptr[6] &= ~AX25_CBIT;\n\t\tdptr[6] &= ~AX25_EBIT;\n\t\tdptr[6] |= AX25_SSSID_SPARE;\n\t\tdptr    += AX25_ADDR_LEN;\n\t\t*dptr++  = timeout % 256;\n\t\t*dptr++  = timeout / 256;\n\t\tbreak;\n\n\tcase NR_CONNACK:\n\t\t*dptr++ = nr->your_index;\n\t\t*dptr++ = nr->your_id;\n\t\t*dptr++ = nr->my_index;\n\t\t*dptr++ = nr->my_id;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = nr->window;\n\t\tif (nr->bpqext) *dptr++ = sysctl_netrom_network_ttl_initialiser;\n\t\tbreak;\n\n\tcase NR_DISCREQ:\n\tcase NR_DISCACK:\n\t\t*dptr++ = nr->your_index;\n\t\t*dptr++ = nr->your_id;\n\t\t*dptr++ = 0;\n\t\t*dptr++ = 0;\n\t\t*dptr++ = frametype;\n\t\tbreak;\n\n\tcase NR_INFOACK:\n\t\t*dptr++ = nr->your_index;\n\t\t*dptr++ = nr->your_id;\n\t\t*dptr++ = 0;\n\t\t*dptr++ = nr->vr;\n\t\t*dptr++ = frametype;\n\t\tbreak;\n\t}\n\n\tnr_transmit_buffer(sk, skb);\n}\n\n \nvoid __nr_transmit_reply(struct sk_buff *skb, int mine, unsigned char cmdflags)\n{\n\tstruct sk_buff *skbn;\n\tunsigned char *dptr;\n\tint len;\n\n\tlen = NR_NETWORK_LEN + NR_TRANSPORT_LEN + 1;\n\n\tif ((skbn = alloc_skb(len, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\tskb_reserve(skbn, 0);\n\n\tdptr = skb_put(skbn, NR_NETWORK_LEN + NR_TRANSPORT_LEN);\n\n\tskb_copy_from_linear_data_offset(skb, 7, dptr, AX25_ADDR_LEN);\n\tdptr[6] &= ~AX25_CBIT;\n\tdptr[6] &= ~AX25_EBIT;\n\tdptr[6] |= AX25_SSSID_SPARE;\n\tdptr += AX25_ADDR_LEN;\n\n\tskb_copy_from_linear_data(skb, dptr, AX25_ADDR_LEN);\n\tdptr[6] &= ~AX25_CBIT;\n\tdptr[6] |= AX25_EBIT;\n\tdptr[6] |= AX25_SSSID_SPARE;\n\tdptr += AX25_ADDR_LEN;\n\n\t*dptr++ = sysctl_netrom_network_ttl_initialiser;\n\n\tif (mine) {\n\t\t*dptr++ = 0;\n\t\t*dptr++ = 0;\n\t\t*dptr++ = skb->data[15];\n\t\t*dptr++ = skb->data[16];\n\t} else {\n\t\t*dptr++ = skb->data[15];\n\t\t*dptr++ = skb->data[16];\n\t\t*dptr++ = 0;\n\t\t*dptr++ = 0;\n\t}\n\n\t*dptr++ = cmdflags;\n\t*dptr++ = 0;\n\n\tif (!nr_route_frame(skbn, NULL))\n\t\tkfree_skb(skbn);\n}\n\nvoid nr_disconnect(struct sock *sk, int reason)\n{\n\tnr_stop_t1timer(sk);\n\tnr_stop_t2timer(sk);\n\tnr_stop_t4timer(sk);\n\tnr_stop_idletimer(sk);\n\n\tnr_clear_queues(sk);\n\n\tnr_sk(sk)->state = NR_STATE_0;\n\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = reason;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}