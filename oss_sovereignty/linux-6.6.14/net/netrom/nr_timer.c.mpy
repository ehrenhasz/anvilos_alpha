{
  "module_name": "nr_timer.c",
  "hash_id": "45ff4724b9827db29b70d39a90bace74107773dfebc96033bffa3c7cd0d60d28",
  "original_prompt": "Ingested from linux-6.6.14/net/netrom/nr_timer.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/netrom.h>\n\nstatic void nr_heartbeat_expiry(struct timer_list *);\nstatic void nr_t1timer_expiry(struct timer_list *);\nstatic void nr_t2timer_expiry(struct timer_list *);\nstatic void nr_t4timer_expiry(struct timer_list *);\nstatic void nr_idletimer_expiry(struct timer_list *);\n\nvoid nr_init_timers(struct sock *sk)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\ttimer_setup(&nr->t1timer, nr_t1timer_expiry, 0);\n\ttimer_setup(&nr->t2timer, nr_t2timer_expiry, 0);\n\ttimer_setup(&nr->t4timer, nr_t4timer_expiry, 0);\n\ttimer_setup(&nr->idletimer, nr_idletimer_expiry, 0);\n\n\t \n\tsk->sk_timer.function = nr_heartbeat_expiry;\n}\n\nvoid nr_start_t1timer(struct sock *sk)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tsk_reset_timer(sk, &nr->t1timer, jiffies + nr->t1);\n}\n\nvoid nr_start_t2timer(struct sock *sk)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tsk_reset_timer(sk, &nr->t2timer, jiffies + nr->t2);\n}\n\nvoid nr_start_t4timer(struct sock *sk)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tsk_reset_timer(sk, &nr->t4timer, jiffies + nr->t4);\n}\n\nvoid nr_start_idletimer(struct sock *sk)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tif (nr->idle > 0)\n\t\tsk_reset_timer(sk, &nr->idletimer, jiffies + nr->idle);\n}\n\nvoid nr_start_heartbeat(struct sock *sk)\n{\n\tsk_reset_timer(sk, &sk->sk_timer, jiffies + 5 * HZ);\n}\n\nvoid nr_stop_t1timer(struct sock *sk)\n{\n\tsk_stop_timer(sk, &nr_sk(sk)->t1timer);\n}\n\nvoid nr_stop_t2timer(struct sock *sk)\n{\n\tsk_stop_timer(sk, &nr_sk(sk)->t2timer);\n}\n\nvoid nr_stop_t4timer(struct sock *sk)\n{\n\tsk_stop_timer(sk, &nr_sk(sk)->t4timer);\n}\n\nvoid nr_stop_idletimer(struct sock *sk)\n{\n\tsk_stop_timer(sk, &nr_sk(sk)->idletimer);\n}\n\nvoid nr_stop_heartbeat(struct sock *sk)\n{\n\tsk_stop_timer(sk, &sk->sk_timer);\n}\n\nint nr_t1timer_running(struct sock *sk)\n{\n\treturn timer_pending(&nr_sk(sk)->t1timer);\n}\n\nstatic void nr_heartbeat_expiry(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tbh_lock_sock(sk);\n\tswitch (nr->state) {\n\tcase NR_STATE_0:\n\t\t \n\t\tif (sock_flag(sk, SOCK_DESTROY) ||\n\t\t    (sk->sk_state == TCP_LISTEN && sock_flag(sk, SOCK_DEAD))) {\n\t\t\tsock_hold(sk);\n\t\t\tbh_unlock_sock(sk);\n\t\t\tnr_destroy_socket(sk);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase NR_STATE_3:\n\t\t \n\t\tif (atomic_read(&sk->sk_rmem_alloc) < (sk->sk_rcvbuf / 2) &&\n\t\t    (nr->condition & NR_COND_OWN_RX_BUSY)) {\n\t\t\tnr->condition &= ~NR_COND_OWN_RX_BUSY;\n\t\t\tnr->condition &= ~NR_COND_ACK_PENDING;\n\t\t\tnr->vl         = nr->vr;\n\t\t\tnr_write_internal(sk, NR_INFOACK);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tnr_start_heartbeat(sk);\n\tbh_unlock_sock(sk);\nout:\n\tsock_put(sk);\n}\n\nstatic void nr_t2timer_expiry(struct timer_list *t)\n{\n\tstruct nr_sock *nr = from_timer(nr, t, t2timer);\n\tstruct sock *sk = &nr->sock;\n\n\tbh_lock_sock(sk);\n\tif (nr->condition & NR_COND_ACK_PENDING) {\n\t\tnr->condition &= ~NR_COND_ACK_PENDING;\n\t\tnr_enquiry_response(sk);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void nr_t4timer_expiry(struct timer_list *t)\n{\n\tstruct nr_sock *nr = from_timer(nr, t, t4timer);\n\tstruct sock *sk = &nr->sock;\n\n\tbh_lock_sock(sk);\n\tnr_sk(sk)->condition &= ~NR_COND_PEER_RX_BUSY;\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void nr_idletimer_expiry(struct timer_list *t)\n{\n\tstruct nr_sock *nr = from_timer(nr, t, idletimer);\n\tstruct sock *sk = &nr->sock;\n\n\tbh_lock_sock(sk);\n\n\tnr_clear_queues(sk);\n\n\tnr->n2count = 0;\n\tnr_write_internal(sk, NR_DISCREQ);\n\tnr->state = NR_STATE_2;\n\n\tnr_start_t1timer(sk);\n\tnr_stop_t2timer(sk);\n\tnr_stop_t4timer(sk);\n\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = 0;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void nr_t1timer_expiry(struct timer_list *t)\n{\n\tstruct nr_sock *nr = from_timer(nr, t, t1timer);\n\tstruct sock *sk = &nr->sock;\n\n\tbh_lock_sock(sk);\n\tswitch (nr->state) {\n\tcase NR_STATE_1:\n\t\tif (nr->n2count == nr->n2) {\n\t\t\tnr_disconnect(sk, ETIMEDOUT);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnr->n2count++;\n\t\t\tnr_write_internal(sk, NR_CONNREQ);\n\t\t}\n\t\tbreak;\n\n\tcase NR_STATE_2:\n\t\tif (nr->n2count == nr->n2) {\n\t\t\tnr_disconnect(sk, ETIMEDOUT);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnr->n2count++;\n\t\t\tnr_write_internal(sk, NR_DISCREQ);\n\t\t}\n\t\tbreak;\n\n\tcase NR_STATE_3:\n\t\tif (nr->n2count == nr->n2) {\n\t\t\tnr_disconnect(sk, ETIMEDOUT);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnr->n2count++;\n\t\t\tnr_requeue_frames(sk);\n\t\t}\n\t\tbreak;\n\t}\n\n\tnr_start_t1timer(sk);\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}