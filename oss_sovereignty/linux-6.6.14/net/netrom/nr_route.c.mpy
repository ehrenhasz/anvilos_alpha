{
  "module_name": "nr_route.c",
  "hash_id": "7dadd4a0e2e8420d52c0eab8a10bf546b73882837475aab970a99856f35e99a7",
  "original_prompt": "Ingested from linux-6.6.14/net/netrom/nr_route.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/arp.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t \n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <net/netrom.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n\nstatic unsigned int nr_neigh_no = 1;\n\nstatic HLIST_HEAD(nr_node_list);\nstatic DEFINE_SPINLOCK(nr_node_list_lock);\nstatic HLIST_HEAD(nr_neigh_list);\nstatic DEFINE_SPINLOCK(nr_neigh_list_lock);\n\nstatic struct nr_node *nr_node_get(ax25_address *callsign)\n{\n\tstruct nr_node *found = NULL;\n\tstruct nr_node *nr_node;\n\n\tspin_lock_bh(&nr_node_list_lock);\n\tnr_node_for_each(nr_node, &nr_node_list)\n\t\tif (ax25cmp(callsign, &nr_node->callsign) == 0) {\n\t\t\tnr_node_hold(nr_node);\n\t\t\tfound = nr_node;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock_bh(&nr_node_list_lock);\n\treturn found;\n}\n\nstatic struct nr_neigh *nr_neigh_get_dev(ax25_address *callsign,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct nr_neigh *found = NULL;\n\tstruct nr_neigh *nr_neigh;\n\n\tspin_lock_bh(&nr_neigh_list_lock);\n\tnr_neigh_for_each(nr_neigh, &nr_neigh_list)\n\t\tif (ax25cmp(callsign, &nr_neigh->callsign) == 0 &&\n\t\t    nr_neigh->dev == dev) {\n\t\t\tnr_neigh_hold(nr_neigh);\n\t\t\tfound = nr_neigh;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock_bh(&nr_neigh_list_lock);\n\treturn found;\n}\n\nstatic void nr_remove_neigh(struct nr_neigh *);\n\n \nstatic void re_sort_routes(struct nr_node *nr_node, int x, int y)\n{\n\tif (nr_node->routes[y].quality > nr_node->routes[x].quality) {\n\t\tif (nr_node->which == x)\n\t\t\tnr_node->which = y;\n\t\telse if (nr_node->which == y)\n\t\t\tnr_node->which = x;\n\n\t\tswap(nr_node->routes[x], nr_node->routes[y]);\n\t}\n}\n\n \nstatic int __must_check nr_add_node(ax25_address *nr, const char *mnemonic,\n\tax25_address *ax25, ax25_digi *ax25_digi, struct net_device *dev,\n\tint quality, int obs_count)\n{\n\tstruct nr_node  *nr_node;\n\tstruct nr_neigh *nr_neigh;\n\tint i, found;\n\tstruct net_device *odev;\n\n\tif ((odev=nr_dev_get(nr)) != NULL) {\t \n\t\tdev_put(odev);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_node = nr_node_get(nr);\n\n\tnr_neigh = nr_neigh_get_dev(ax25, dev);\n\n\t \n\tif (nr_neigh != NULL && nr_neigh->failed != 0 && quality == 0) {\n\t\tstruct nr_node *nr_nodet;\n\n\t\tspin_lock_bh(&nr_node_list_lock);\n\t\tnr_node_for_each(nr_nodet, &nr_node_list) {\n\t\t\tnr_node_lock(nr_nodet);\n\t\t\tfor (i = 0; i < nr_nodet->count; i++)\n\t\t\t\tif (nr_nodet->routes[i].neighbour == nr_neigh)\n\t\t\t\t\tif (i < nr_nodet->which)\n\t\t\t\t\t\tnr_nodet->which = i;\n\t\t\tnr_node_unlock(nr_nodet);\n\t\t}\n\t\tspin_unlock_bh(&nr_node_list_lock);\n\t}\n\n\tif (nr_neigh != NULL)\n\t\tnr_neigh->failed = 0;\n\n\tif (quality == 0 && nr_neigh != NULL && nr_node != NULL) {\n\t\tnr_neigh_put(nr_neigh);\n\t\tnr_node_put(nr_node);\n\t\treturn 0;\n\t}\n\n\tif (nr_neigh == NULL) {\n\t\tif ((nr_neigh = kmalloc(sizeof(*nr_neigh), GFP_ATOMIC)) == NULL) {\n\t\t\tif (nr_node)\n\t\t\t\tnr_node_put(nr_node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnr_neigh->callsign = *ax25;\n\t\tnr_neigh->digipeat = NULL;\n\t\tnr_neigh->ax25     = NULL;\n\t\tnr_neigh->dev      = dev;\n\t\tnr_neigh->quality  = sysctl_netrom_default_path_quality;\n\t\tnr_neigh->locked   = 0;\n\t\tnr_neigh->count    = 0;\n\t\tnr_neigh->number   = nr_neigh_no++;\n\t\tnr_neigh->failed   = 0;\n\t\trefcount_set(&nr_neigh->refcount, 1);\n\n\t\tif (ax25_digi != NULL && ax25_digi->ndigi > 0) {\n\t\t\tnr_neigh->digipeat = kmemdup(ax25_digi,\n\t\t\t\t\t\t     sizeof(*ax25_digi),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (nr_neigh->digipeat == NULL) {\n\t\t\t\tkfree(nr_neigh);\n\t\t\t\tif (nr_node)\n\t\t\t\t\tnr_node_put(nr_node);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_bh(&nr_neigh_list_lock);\n\t\thlist_add_head(&nr_neigh->neigh_node, &nr_neigh_list);\n\t\tnr_neigh_hold(nr_neigh);\n\t\tspin_unlock_bh(&nr_neigh_list_lock);\n\t}\n\n\tif (quality != 0 && ax25cmp(nr, ax25) == 0 && !nr_neigh->locked)\n\t\tnr_neigh->quality = quality;\n\n\tif (nr_node == NULL) {\n\t\tif ((nr_node = kmalloc(sizeof(*nr_node), GFP_ATOMIC)) == NULL) {\n\t\t\tif (nr_neigh)\n\t\t\t\tnr_neigh_put(nr_neigh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnr_node->callsign = *nr;\n\t\tstrcpy(nr_node->mnemonic, mnemonic);\n\n\t\tnr_node->which = 0;\n\t\tnr_node->count = 1;\n\t\trefcount_set(&nr_node->refcount, 1);\n\t\tspin_lock_init(&nr_node->node_lock);\n\n\t\tnr_node->routes[0].quality   = quality;\n\t\tnr_node->routes[0].obs_count = obs_count;\n\t\tnr_node->routes[0].neighbour = nr_neigh;\n\n\t\tnr_neigh_hold(nr_neigh);\n\t\tnr_neigh->count++;\n\n\t\tspin_lock_bh(&nr_node_list_lock);\n\t\thlist_add_head(&nr_node->node_node, &nr_node_list);\n\t\t \n\t\tspin_unlock_bh(&nr_node_list_lock);\n\n\t\tnr_neigh_put(nr_neigh);\n\t\treturn 0;\n\t}\n\tnr_node_lock(nr_node);\n\n\tif (quality != 0)\n\t\tstrcpy(nr_node->mnemonic, mnemonic);\n\n\tfor (found = 0, i = 0; i < nr_node->count; i++) {\n\t\tif (nr_node->routes[i].neighbour == nr_neigh) {\n\t\t\tnr_node->routes[i].quality   = quality;\n\t\t\tnr_node->routes[i].obs_count = obs_count;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\t \n\t\tif (nr_node->count < 3) {\n\t\t\tnr_node->routes[2] = nr_node->routes[1];\n\t\t\tnr_node->routes[1] = nr_node->routes[0];\n\n\t\t\tnr_node->routes[0].quality   = quality;\n\t\t\tnr_node->routes[0].obs_count = obs_count;\n\t\t\tnr_node->routes[0].neighbour = nr_neigh;\n\n\t\t\tnr_node->which++;\n\t\t\tnr_node->count++;\n\t\t\tnr_neigh_hold(nr_neigh);\n\t\t\tnr_neigh->count++;\n\t\t} else {\n\t\t\t \n\t\t\tif (quality > nr_node->routes[2].quality) {\n\t\t\t\tnr_node->routes[2].neighbour->count--;\n\t\t\t\tnr_neigh_put(nr_node->routes[2].neighbour);\n\n\t\t\t\tif (nr_node->routes[2].neighbour->count == 0 && !nr_node->routes[2].neighbour->locked)\n\t\t\t\t\tnr_remove_neigh(nr_node->routes[2].neighbour);\n\n\t\t\t\tnr_node->routes[2].quality   = quality;\n\t\t\t\tnr_node->routes[2].obs_count = obs_count;\n\t\t\t\tnr_node->routes[2].neighbour = nr_neigh;\n\n\t\t\t\tnr_neigh_hold(nr_neigh);\n\t\t\t\tnr_neigh->count++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tswitch (nr_node->count) {\n\tcase 3:\n\t\tre_sort_routes(nr_node, 0, 1);\n\t\tre_sort_routes(nr_node, 1, 2);\n\t\tfallthrough;\n\tcase 2:\n\t\tre_sort_routes(nr_node, 0, 1);\n\t\tbreak;\n\tcase 1:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < nr_node->count; i++) {\n\t\tif (nr_node->routes[i].neighbour == nr_neigh) {\n\t\t\tif (i < nr_node->which)\n\t\t\t\tnr_node->which = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnr_neigh_put(nr_neigh);\n\tnr_node_unlock(nr_node);\n\tnr_node_put(nr_node);\n\treturn 0;\n}\n\nstatic inline void __nr_remove_node(struct nr_node *nr_node)\n{\n\thlist_del_init(&nr_node->node_node);\n\tnr_node_put(nr_node);\n}\n\n#define nr_remove_node_locked(__node) \\\n\t__nr_remove_node(__node)\n\nstatic void nr_remove_node(struct nr_node *nr_node)\n{\n\tspin_lock_bh(&nr_node_list_lock);\n\t__nr_remove_node(nr_node);\n\tspin_unlock_bh(&nr_node_list_lock);\n}\n\nstatic inline void __nr_remove_neigh(struct nr_neigh *nr_neigh)\n{\n\thlist_del_init(&nr_neigh->neigh_node);\n\tnr_neigh_put(nr_neigh);\n}\n\n#define nr_remove_neigh_locked(__neigh) \\\n\t__nr_remove_neigh(__neigh)\n\nstatic void nr_remove_neigh(struct nr_neigh *nr_neigh)\n{\n\tspin_lock_bh(&nr_neigh_list_lock);\n\t__nr_remove_neigh(nr_neigh);\n\tspin_unlock_bh(&nr_neigh_list_lock);\n}\n\n \nstatic int nr_del_node(ax25_address *callsign, ax25_address *neighbour, struct net_device *dev)\n{\n\tstruct nr_node  *nr_node;\n\tstruct nr_neigh *nr_neigh;\n\tint i;\n\n\tnr_node = nr_node_get(callsign);\n\n\tif (nr_node == NULL)\n\t\treturn -EINVAL;\n\n\tnr_neigh = nr_neigh_get_dev(neighbour, dev);\n\n\tif (nr_neigh == NULL) {\n\t\tnr_node_put(nr_node);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_node_lock(nr_node);\n\tfor (i = 0; i < nr_node->count; i++) {\n\t\tif (nr_node->routes[i].neighbour == nr_neigh) {\n\t\t\tnr_neigh->count--;\n\t\t\tnr_neigh_put(nr_neigh);\n\n\t\t\tif (nr_neigh->count == 0 && !nr_neigh->locked)\n\t\t\t\tnr_remove_neigh(nr_neigh);\n\t\t\tnr_neigh_put(nr_neigh);\n\n\t\t\tnr_node->count--;\n\n\t\t\tif (nr_node->count == 0) {\n\t\t\t\tnr_remove_node(nr_node);\n\t\t\t} else {\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tnr_node->routes[0] = nr_node->routes[1];\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 1:\n\t\t\t\t\tnr_node->routes[1] = nr_node->routes[2];\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 2:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnr_node_put(nr_node);\n\t\t\t}\n\t\t\tnr_node_unlock(nr_node);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\tnr_neigh_put(nr_neigh);\n\tnr_node_unlock(nr_node);\n\tnr_node_put(nr_node);\n\n\treturn -EINVAL;\n}\n\n \nstatic int __must_check nr_add_neigh(ax25_address *callsign,\n\tax25_digi *ax25_digi, struct net_device *dev, unsigned int quality)\n{\n\tstruct nr_neigh *nr_neigh;\n\n\tnr_neigh = nr_neigh_get_dev(callsign, dev);\n\tif (nr_neigh) {\n\t\tnr_neigh->quality = quality;\n\t\tnr_neigh->locked  = 1;\n\t\tnr_neigh_put(nr_neigh);\n\t\treturn 0;\n\t}\n\n\tif ((nr_neigh = kmalloc(sizeof(*nr_neigh), GFP_ATOMIC)) == NULL)\n\t\treturn -ENOMEM;\n\n\tnr_neigh->callsign = *callsign;\n\tnr_neigh->digipeat = NULL;\n\tnr_neigh->ax25     = NULL;\n\tnr_neigh->dev      = dev;\n\tnr_neigh->quality  = quality;\n\tnr_neigh->locked   = 1;\n\tnr_neigh->count    = 0;\n\tnr_neigh->number   = nr_neigh_no++;\n\tnr_neigh->failed   = 0;\n\trefcount_set(&nr_neigh->refcount, 1);\n\n\tif (ax25_digi != NULL && ax25_digi->ndigi > 0) {\n\t\tnr_neigh->digipeat = kmemdup(ax25_digi, sizeof(*ax25_digi),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (nr_neigh->digipeat == NULL) {\n\t\t\tkfree(nr_neigh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock_bh(&nr_neigh_list_lock);\n\thlist_add_head(&nr_neigh->neigh_node, &nr_neigh_list);\n\t \n\tspin_unlock_bh(&nr_neigh_list_lock);\n\n\treturn 0;\n}\n\n \nstatic int nr_del_neigh(ax25_address *callsign, struct net_device *dev, unsigned int quality)\n{\n\tstruct nr_neigh *nr_neigh;\n\n\tnr_neigh = nr_neigh_get_dev(callsign, dev);\n\n\tif (nr_neigh == NULL) return -EINVAL;\n\n\tnr_neigh->quality = quality;\n\tnr_neigh->locked  = 0;\n\n\tif (nr_neigh->count == 0)\n\t\tnr_remove_neigh(nr_neigh);\n\tnr_neigh_put(nr_neigh);\n\n\treturn 0;\n}\n\n \nstatic int nr_dec_obs(void)\n{\n\tstruct nr_neigh *nr_neigh;\n\tstruct nr_node  *s;\n\tstruct hlist_node *nodet;\n\tint i;\n\n\tspin_lock_bh(&nr_node_list_lock);\n\tnr_node_for_each_safe(s, nodet, &nr_node_list) {\n\t\tnr_node_lock(s);\n\t\tfor (i = 0; i < s->count; i++) {\n\t\t\tswitch (s->routes[i].obs_count) {\n\t\t\tcase 0:\t\t \n\t\t\t\tbreak;\n\n\t\t\tcase 1:\t\t \n\t\t\t\tnr_neigh = s->routes[i].neighbour;\n\n\t\t\t\tnr_neigh->count--;\n\t\t\t\tnr_neigh_put(nr_neigh);\n\n\t\t\t\tif (nr_neigh->count == 0 && !nr_neigh->locked)\n\t\t\t\t\tnr_remove_neigh(nr_neigh);\n\n\t\t\t\ts->count--;\n\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\ts->routes[0] = s->routes[1];\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 1:\n\t\t\t\t\ts->routes[1] = s->routes[2];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ts->routes[i].obs_count--;\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\tif (s->count <= 0)\n\t\t\tnr_remove_node_locked(s);\n\t\tnr_node_unlock(s);\n\t}\n\tspin_unlock_bh(&nr_node_list_lock);\n\n\treturn 0;\n}\n\n \nvoid nr_rt_device_down(struct net_device *dev)\n{\n\tstruct nr_neigh *s;\n\tstruct hlist_node *nodet, *node2t;\n\tstruct nr_node  *t;\n\tint i;\n\n\tspin_lock_bh(&nr_neigh_list_lock);\n\tnr_neigh_for_each_safe(s, nodet, &nr_neigh_list) {\n\t\tif (s->dev == dev) {\n\t\t\tspin_lock_bh(&nr_node_list_lock);\n\t\t\tnr_node_for_each_safe(t, node2t, &nr_node_list) {\n\t\t\t\tnr_node_lock(t);\n\t\t\t\tfor (i = 0; i < t->count; i++) {\n\t\t\t\t\tif (t->routes[i].neighbour == s) {\n\t\t\t\t\t\tt->count--;\n\n\t\t\t\t\t\tswitch (i) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tt->routes[0] = t->routes[1];\n\t\t\t\t\t\t\tfallthrough;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tt->routes[1] = t->routes[2];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (t->count <= 0)\n\t\t\t\t\tnr_remove_node_locked(t);\n\t\t\t\tnr_node_unlock(t);\n\t\t\t}\n\t\t\tspin_unlock_bh(&nr_node_list_lock);\n\n\t\t\tnr_remove_neigh_locked(s);\n\t\t}\n\t}\n\tspin_unlock_bh(&nr_neigh_list_lock);\n}\n\n \nstatic struct net_device *nr_ax25_dev_get(char *devname)\n{\n\tstruct net_device *dev;\n\n\tif ((dev = dev_get_by_name(&init_net, devname)) == NULL)\n\t\treturn NULL;\n\n\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_AX25)\n\t\treturn dev;\n\n\tdev_put(dev);\n\treturn NULL;\n}\n\n \nstruct net_device *nr_dev_first(void)\n{\n\tstruct net_device *dev, *first = NULL;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_NETROM)\n\t\t\tif (first == NULL || strncmp(dev->name, first->name, 3) < 0)\n\t\t\t\tfirst = dev;\n\t}\n\tdev_hold(first);\n\trcu_read_unlock();\n\n\treturn first;\n}\n\n \nstruct net_device *nr_dev_get(ax25_address *addr)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_NETROM &&\n\t\t    ax25cmp(addr, (const ax25_address *)dev->dev_addr) == 0) {\n\t\t\tdev_hold(dev);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdev = NULL;\nout:\n\trcu_read_unlock();\n\treturn dev;\n}\n\nstatic ax25_digi *nr_call_to_digi(ax25_digi *digi, int ndigis,\n\tax25_address *digipeaters)\n{\n\tint i;\n\n\tif (ndigis == 0)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ndigis; i++) {\n\t\tdigi->calls[i]    = digipeaters[i];\n\t\tdigi->repeated[i] = 0;\n\t}\n\n\tdigi->ndigi      = ndigis;\n\tdigi->lastrepeat = -1;\n\n\treturn digi;\n}\n\n \nint nr_rt_ioctl(unsigned int cmd, void __user *arg)\n{\n\tstruct nr_route_struct nr_route;\n\tstruct net_device *dev;\n\tax25_digi digi;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\t\tif (copy_from_user(&nr_route, arg, sizeof(struct nr_route_struct)))\n\t\t\treturn -EFAULT;\n\t\tif (nr_route.ndigis > AX25_MAX_DIGIS)\n\t\t\treturn -EINVAL;\n\t\tif ((dev = nr_ax25_dev_get(nr_route.device)) == NULL)\n\t\t\treturn -EINVAL;\n\t\tswitch (nr_route.type) {\n\t\tcase NETROM_NODE:\n\t\t\tif (strnlen(nr_route.mnemonic, 7) == 7) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = nr_add_node(&nr_route.callsign,\n\t\t\t\tnr_route.mnemonic,\n\t\t\t\t&nr_route.neighbour,\n\t\t\t\tnr_call_to_digi(&digi, nr_route.ndigis,\n\t\t\t\t\t\tnr_route.digipeaters),\n\t\t\t\tdev, nr_route.quality,\n\t\t\t\tnr_route.obs_count);\n\t\t\tbreak;\n\t\tcase NETROM_NEIGH:\n\t\t\tret = nr_add_neigh(&nr_route.callsign,\n\t\t\t\tnr_call_to_digi(&digi, nr_route.ndigis,\n\t\t\t\t\t\tnr_route.digipeaters),\n\t\t\t\tdev, nr_route.quality);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tdev_put(dev);\n\t\treturn ret;\n\n\tcase SIOCDELRT:\n\t\tif (copy_from_user(&nr_route, arg, sizeof(struct nr_route_struct)))\n\t\t\treturn -EFAULT;\n\t\tif ((dev = nr_ax25_dev_get(nr_route.device)) == NULL)\n\t\t\treturn -EINVAL;\n\t\tswitch (nr_route.type) {\n\t\tcase NETROM_NODE:\n\t\t\tret = nr_del_node(&nr_route.callsign,\n\t\t\t\t&nr_route.neighbour, dev);\n\t\t\tbreak;\n\t\tcase NETROM_NEIGH:\n\t\t\tret = nr_del_neigh(&nr_route.callsign,\n\t\t\t\tdev, nr_route.quality);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tdev_put(dev);\n\t\treturn ret;\n\n\tcase SIOCNRDECOBS:\n\t\treturn nr_dec_obs();\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nvoid nr_link_failed(ax25_cb *ax25, int reason)\n{\n\tstruct nr_neigh *s, *nr_neigh = NULL;\n\tstruct nr_node  *nr_node = NULL;\n\n\tspin_lock_bh(&nr_neigh_list_lock);\n\tnr_neigh_for_each(s, &nr_neigh_list) {\n\t\tif (s->ax25 == ax25) {\n\t\t\tnr_neigh_hold(s);\n\t\t\tnr_neigh = s;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&nr_neigh_list_lock);\n\n\tif (nr_neigh == NULL)\n\t\treturn;\n\n\tnr_neigh->ax25 = NULL;\n\tax25_cb_put(ax25);\n\n\tif (++nr_neigh->failed < sysctl_netrom_link_fails_count) {\n\t\tnr_neigh_put(nr_neigh);\n\t\treturn;\n\t}\n\tspin_lock_bh(&nr_node_list_lock);\n\tnr_node_for_each(nr_node, &nr_node_list) {\n\t\tnr_node_lock(nr_node);\n\t\tif (nr_node->which < nr_node->count &&\n\t\t    nr_node->routes[nr_node->which].neighbour == nr_neigh)\n\t\t\tnr_node->which++;\n\t\tnr_node_unlock(nr_node);\n\t}\n\tspin_unlock_bh(&nr_node_list_lock);\n\tnr_neigh_put(nr_neigh);\n}\n\n \nint nr_route_frame(struct sk_buff *skb, ax25_cb *ax25)\n{\n\tax25_address *nr_src, *nr_dest;\n\tstruct nr_neigh *nr_neigh;\n\tstruct nr_node  *nr_node;\n\tstruct net_device *dev;\n\tunsigned char *dptr;\n\tax25_cb *ax25s;\n\tint ret;\n\tstruct sk_buff *skbn;\n\n\n\tnr_src  = (ax25_address *)(skb->data + 0);\n\tnr_dest = (ax25_address *)(skb->data + 7);\n\n\tif (ax25 != NULL) {\n\t\tret = nr_add_node(nr_src, \"\", &ax25->dest_addr, ax25->digipeat,\n\t\t\t\t  ax25->ax25_dev->dev, 0,\n\t\t\t\t  sysctl_netrom_obsolescence_count_initialiser);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif ((dev = nr_dev_get(nr_dest)) != NULL) {\t \n\t\tif (ax25 == NULL)\t\t\t \n\t\t\tret = nr_loopback_queue(skb);\n\t\telse\n\t\t\tret = nr_rx_frame(skb, dev);\n\t\tdev_put(dev);\n\t\treturn ret;\n\t}\n\n\tif (!sysctl_netrom_routing_control && ax25 != NULL)\n\t\treturn 0;\n\n\t \n\tif (skb->data[14] == 1) {\n\t\treturn 0;\n\t}\n\n\tnr_node = nr_node_get(nr_dest);\n\tif (nr_node == NULL)\n\t\treturn 0;\n\tnr_node_lock(nr_node);\n\n\tif (nr_node->which >= nr_node->count) {\n\t\tnr_node_unlock(nr_node);\n\t\tnr_node_put(nr_node);\n\t\treturn 0;\n\t}\n\n\tnr_neigh = nr_node->routes[nr_node->which].neighbour;\n\n\tif ((dev = nr_dev_first()) == NULL) {\n\t\tnr_node_unlock(nr_node);\n\t\tnr_node_put(nr_node);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((skbn=skb_copy_expand(skb, dev->hard_header_len, 0, GFP_ATOMIC)) == NULL) {\n\t\tnr_node_unlock(nr_node);\n\t\tnr_node_put(nr_node);\n\t\tdev_put(dev);\n\t\treturn 0;\n\t}\n\tkfree_skb(skb);\n\tskb=skbn;\n\tskb->data[14]--;\n\n\tdptr  = skb_push(skb, 1);\n\t*dptr = AX25_P_NETROM;\n\n\tax25s = nr_neigh->ax25;\n\tnr_neigh->ax25 = ax25_send_frame(skb, 256,\n\t\t\t\t\t (const ax25_address *)dev->dev_addr,\n\t\t\t\t\t &nr_neigh->callsign,\n\t\t\t\t\t nr_neigh->digipeat, nr_neigh->dev);\n\tif (ax25s)\n\t\tax25_cb_put(ax25s);\n\n\tdev_put(dev);\n\tret = (nr_neigh->ax25 != NULL);\n\tnr_node_unlock(nr_node);\n\tnr_node_put(nr_node);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *nr_node_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(&nr_node_list_lock)\n{\n\tspin_lock_bh(&nr_node_list_lock);\n\treturn seq_hlist_start_head(&nr_node_list, *pos);\n}\n\nstatic void *nr_node_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &nr_node_list, pos);\n}\n\nstatic void nr_node_stop(struct seq_file *seq, void *v)\n\t__releases(&nr_node_list_lock)\n{\n\tspin_unlock_bh(&nr_node_list_lock);\n}\n\nstatic int nr_node_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11];\n\tint i;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"callsign  mnemonic w n qual obs neigh qual obs neigh qual obs neigh\\n\");\n\telse {\n\t\tstruct nr_node *nr_node = hlist_entry(v, struct nr_node,\n\t\t\t\t\t\t      node_node);\n\n\t\tnr_node_lock(nr_node);\n\t\tseq_printf(seq, \"%-9s %-7s  %d %d\",\n\t\t\tax2asc(buf, &nr_node->callsign),\n\t\t\t(nr_node->mnemonic[0] == '\\0') ? \"*\" : nr_node->mnemonic,\n\t\t\tnr_node->which + 1,\n\t\t\tnr_node->count);\n\n\t\tfor (i = 0; i < nr_node->count; i++) {\n\t\t\tseq_printf(seq, \"  %3d   %d %05d\",\n\t\t\t\tnr_node->routes[i].quality,\n\t\t\t\tnr_node->routes[i].obs_count,\n\t\t\t\tnr_node->routes[i].neighbour->number);\n\t\t}\n\t\tnr_node_unlock(nr_node);\n\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\treturn 0;\n}\n\nconst struct seq_operations nr_node_seqops = {\n\t.start = nr_node_start,\n\t.next = nr_node_next,\n\t.stop = nr_node_stop,\n\t.show = nr_node_show,\n};\n\nstatic void *nr_neigh_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(&nr_neigh_list_lock)\n{\n\tspin_lock_bh(&nr_neigh_list_lock);\n\treturn seq_hlist_start_head(&nr_neigh_list, *pos);\n}\n\nstatic void *nr_neigh_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &nr_neigh_list, pos);\n}\n\nstatic void nr_neigh_stop(struct seq_file *seq, void *v)\n\t__releases(&nr_neigh_list_lock)\n{\n\tspin_unlock_bh(&nr_neigh_list_lock);\n}\n\nstatic int nr_neigh_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11];\n\tint i;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"addr  callsign  dev  qual lock count failed digipeaters\\n\");\n\telse {\n\t\tstruct nr_neigh *nr_neigh;\n\n\t\tnr_neigh = hlist_entry(v, struct nr_neigh, neigh_node);\n\t\tseq_printf(seq, \"%05d %-9s %-4s  %3d    %d   %3d    %3d\",\n\t\t\tnr_neigh->number,\n\t\t\tax2asc(buf, &nr_neigh->callsign),\n\t\t\tnr_neigh->dev ? nr_neigh->dev->name : \"???\",\n\t\t\tnr_neigh->quality,\n\t\t\tnr_neigh->locked,\n\t\t\tnr_neigh->count,\n\t\t\tnr_neigh->failed);\n\n\t\tif (nr_neigh->digipeat != NULL) {\n\t\t\tfor (i = 0; i < nr_neigh->digipeat->ndigi; i++)\n\t\t\t\tseq_printf(seq, \" %s\",\n\t\t\t\t\t   ax2asc(buf, &nr_neigh->digipeat->calls[i]));\n\t\t}\n\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\treturn 0;\n}\n\nconst struct seq_operations nr_neigh_seqops = {\n\t.start = nr_neigh_start,\n\t.next = nr_neigh_next,\n\t.stop = nr_neigh_stop,\n\t.show = nr_neigh_show,\n};\n#endif\n\n \nvoid nr_rt_free(void)\n{\n\tstruct nr_neigh *s = NULL;\n\tstruct nr_node  *t = NULL;\n\tstruct hlist_node *nodet;\n\n\tspin_lock_bh(&nr_neigh_list_lock);\n\tspin_lock_bh(&nr_node_list_lock);\n\tnr_node_for_each_safe(t, nodet, &nr_node_list) {\n\t\tnr_node_lock(t);\n\t\tnr_remove_node_locked(t);\n\t\tnr_node_unlock(t);\n\t}\n\tnr_neigh_for_each_safe(s, nodet, &nr_neigh_list) {\n\t\twhile(s->count) {\n\t\t\ts->count--;\n\t\t\tnr_neigh_put(s);\n\t\t}\n\t\tnr_remove_neigh_locked(s);\n\t}\n\tspin_unlock_bh(&nr_node_list_lock);\n\tspin_unlock_bh(&nr_neigh_list_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}