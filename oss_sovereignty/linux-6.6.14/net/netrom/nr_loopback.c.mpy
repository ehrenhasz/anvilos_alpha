{
  "module_name": "nr_loopback.c",
  "hash_id": "9a9cf5462fa0222c8678d491bb8d70b931b23b267878cf38fbcb240b5e916d58",
  "original_prompt": "Ingested from linux-6.6.14/net/netrom/nr_loopback.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/timer.h>\n#include <net/ax25.h>\n#include <linux/skbuff.h>\n#include <net/netrom.h>\n#include <linux/init.h>\n\nstatic void nr_loopback_timer(struct timer_list *);\n\nstatic struct sk_buff_head loopback_queue;\nstatic DEFINE_TIMER(loopback_timer, nr_loopback_timer);\n\nvoid __init nr_loopback_init(void)\n{\n\tskb_queue_head_init(&loopback_queue);\n}\n\nstatic inline int nr_loopback_running(void)\n{\n\treturn timer_pending(&loopback_timer);\n}\n\nint nr_loopback_queue(struct sk_buff *skb)\n{\n\tstruct sk_buff *skbn;\n\n\tif ((skbn = alloc_skb(skb->len, GFP_ATOMIC)) != NULL) {\n\t\tskb_copy_from_linear_data(skb, skb_put(skbn, skb->len), skb->len);\n\t\tskb_reset_transport_header(skbn);\n\n\t\tskb_queue_tail(&loopback_queue, skbn);\n\n\t\tif (!nr_loopback_running())\n\t\t\tmod_timer(&loopback_timer, jiffies + 10);\n\t}\n\n\tkfree_skb(skb);\n\treturn 1;\n}\n\nstatic void nr_loopback_timer(struct timer_list *unused)\n{\n\tstruct sk_buff *skb;\n\tax25_address *nr_dest;\n\tstruct net_device *dev;\n\n\tif ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tnr_dest = (ax25_address *)(skb->data + 7);\n\n\t\tdev = nr_dev_get(nr_dest);\n\n\t\tif (dev == NULL || nr_rx_frame(skb, dev) == 0)\n\t\t\tkfree_skb(skb);\n\n\t\tdev_put(dev);\n\n\t\tif (!skb_queue_empty(&loopback_queue) && !nr_loopback_running())\n\t\t\tmod_timer(&loopback_timer, jiffies + 10);\n\t}\n}\n\nvoid nr_loopback_clear(void)\n{\n\tdel_timer_sync(&loopback_timer);\n\tskb_queue_purge(&loopback_queue);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}