{
  "module_name": "nr_out.c",
  "hash_id": "009ad3ace2a3c0e498665a565646ad40be7a121af188c05b9f450a594bc3d810",
  "original_prompt": "Ingested from linux-6.6.14/net/netrom/nr_out.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/netrom.h>\n\n \nvoid nr_output(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sk_buff *skbn;\n\tunsigned char transport[NR_TRANSPORT_LEN];\n\tint err, frontlen, len;\n\n\tif (skb->len - NR_TRANSPORT_LEN > NR_MAX_PACKET_SIZE) {\n\t\t \n\t\tskb_copy_from_linear_data(skb, transport, NR_TRANSPORT_LEN);\n\t\tskb_pull(skb, NR_TRANSPORT_LEN);\n\n\t\tfrontlen = skb_headroom(skb);\n\n\t\twhile (skb->len > 0) {\n\t\t\tif ((skbn = sock_alloc_send_skb(sk, frontlen + NR_MAX_PACKET_SIZE, 0, &err)) == NULL)\n\t\t\t\treturn;\n\n\t\t\tskb_reserve(skbn, frontlen);\n\n\t\t\tlen = (NR_MAX_PACKET_SIZE > skb->len) ? skb->len : NR_MAX_PACKET_SIZE;\n\n\t\t\t \n\t\t\tskb_copy_from_linear_data(skb, skb_put(skbn, len), len);\n\t\t\tskb_pull(skb, len);\n\n\t\t\t \n\t\t\tskb_push(skbn, NR_TRANSPORT_LEN);\n\t\t\tskb_copy_to_linear_data(skbn, transport,\n\t\t\t\t\t\tNR_TRANSPORT_LEN);\n\t\t\tif (skb->len > 0)\n\t\t\t\tskbn->data[4] |= NR_MORE_FLAG;\n\n\t\t\tskb_queue_tail(&sk->sk_write_queue, skbn);  \n\t\t}\n\n\t\tkfree_skb(skb);\n\t} else {\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\t\t \n\t}\n\n\tnr_kick(sk);\n}\n\n \nstatic void nr_send_iframe(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tif (skb == NULL)\n\t\treturn;\n\n\tskb->data[2] = nr->vs;\n\tskb->data[3] = nr->vr;\n\n\tif (nr->condition & NR_COND_OWN_RX_BUSY)\n\t\tskb->data[4] |= NR_CHOKE_FLAG;\n\n\tnr_start_idletimer(sk);\n\n\tnr_transmit_buffer(sk, skb);\n}\n\nvoid nr_send_nak_frame(struct sock *sk)\n{\n\tstruct sk_buff *skb, *skbn;\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tif ((skb = skb_peek(&nr->ack_queue)) == NULL)\n\t\treturn;\n\n\tif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\tskbn->data[2] = nr->va;\n\tskbn->data[3] = nr->vr;\n\n\tif (nr->condition & NR_COND_OWN_RX_BUSY)\n\t\tskbn->data[4] |= NR_CHOKE_FLAG;\n\n\tnr_transmit_buffer(sk, skbn);\n\n\tnr->condition &= ~NR_COND_ACK_PENDING;\n\tnr->vl         = nr->vr;\n\n\tnr_stop_t1timer(sk);\n}\n\nvoid nr_kick(struct sock *sk)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\tstruct sk_buff *skb, *skbn;\n\tunsigned short start, end;\n\n\tif (nr->state != NR_STATE_3)\n\t\treturn;\n\n\tif (nr->condition & NR_COND_PEER_RX_BUSY)\n\t\treturn;\n\n\tif (!skb_peek(&sk->sk_write_queue))\n\t\treturn;\n\n\tstart = (skb_peek(&nr->ack_queue) == NULL) ? nr->va : nr->vs;\n\tend   = (nr->va + nr->window) % NR_MODULUS;\n\n\tif (start == end)\n\t\treturn;\n\n\tnr->vs = start;\n\n\t \n\n\t \n\tskb = skb_dequeue(&sk->sk_write_queue);\n\n\tdo {\n\t\tif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {\n\t\t\tskb_queue_head(&sk->sk_write_queue, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tskb_set_owner_w(skbn, sk);\n\n\t\t \n\t\tnr_send_iframe(sk, skbn);\n\n\t\tnr->vs = (nr->vs + 1) % NR_MODULUS;\n\n\t\t \n\t\tskb_queue_tail(&nr->ack_queue, skb);\n\n\t} while (nr->vs != end &&\n\t\t (skb = skb_dequeue(&sk->sk_write_queue)) != NULL);\n\n\tnr->vl         = nr->vr;\n\tnr->condition &= ~NR_COND_ACK_PENDING;\n\n\tif (!nr_t1timer_running(sk))\n\t\tnr_start_t1timer(sk);\n}\n\nvoid nr_transmit_buffer(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\tunsigned char *dptr;\n\n\t \n\tdptr = skb_push(skb, NR_NETWORK_LEN);\n\n\tmemcpy(dptr, &nr->source_addr, AX25_ADDR_LEN);\n\tdptr[6] &= ~AX25_CBIT;\n\tdptr[6] &= ~AX25_EBIT;\n\tdptr[6] |= AX25_SSSID_SPARE;\n\tdptr += AX25_ADDR_LEN;\n\n\tmemcpy(dptr, &nr->dest_addr, AX25_ADDR_LEN);\n\tdptr[6] &= ~AX25_CBIT;\n\tdptr[6] |= AX25_EBIT;\n\tdptr[6] |= AX25_SSSID_SPARE;\n\tdptr += AX25_ADDR_LEN;\n\n\t*dptr++ = sysctl_netrom_network_ttl_initialiser;\n\n\tif (!nr_route_frame(skb, NULL)) {\n\t\tkfree_skb(skb);\n\t\tnr_disconnect(sk, ENETUNREACH);\n\t}\n}\n\n \n\nvoid nr_establish_data_link(struct sock *sk)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tnr->condition = 0x00;\n\tnr->n2count   = 0;\n\n\tnr_write_internal(sk, NR_CONNREQ);\n\n\tnr_stop_t2timer(sk);\n\tnr_stop_t4timer(sk);\n\tnr_stop_idletimer(sk);\n\tnr_start_t1timer(sk);\n}\n\n \nvoid nr_enquiry_response(struct sock *sk)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\tint frametype = NR_INFOACK;\n\n\tif (nr->condition & NR_COND_OWN_RX_BUSY) {\n\t\tframetype |= NR_CHOKE_FLAG;\n\t} else {\n\t\tif (skb_peek(&nr->reseq_queue) != NULL)\n\t\t\tframetype |= NR_NAK_FLAG;\n\t}\n\n\tnr_write_internal(sk, frametype);\n\n\tnr->vl         = nr->vr;\n\tnr->condition &= ~NR_COND_ACK_PENDING;\n}\n\nvoid nr_check_iframes_acked(struct sock *sk, unsigned short nr)\n{\n\tstruct nr_sock *nrom = nr_sk(sk);\n\n\tif (nrom->vs == nr) {\n\t\tnr_frames_acked(sk, nr);\n\t\tnr_stop_t1timer(sk);\n\t\tnrom->n2count = 0;\n\t} else {\n\t\tif (nrom->va != nr) {\n\t\t\tnr_frames_acked(sk, nr);\n\t\t\tnr_start_t1timer(sk);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}