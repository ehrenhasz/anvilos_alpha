{
  "module_name": "nr_dev.c",
  "hash_id": "171a0458492562374cbef43d7ef96bd9f2e2d7c4f4b2749e45255067acf3c07a",
  "original_prompt": "Ingested from linux-6.6.14/net/netrom/nr_dev.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/sysctl.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/in.h>\n#include <linux/if_ether.h>\t \n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <asm/io.h>\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n\n#include <net/ip.h>\n#include <net/arp.h>\n\n#include <net/ax25.h>\n#include <net/netrom.h>\n\n \n\nint nr_rx_ip(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\n\tif (!netif_running(dev)) {\n\t\tstats->rx_dropped++;\n\t\treturn 0;\n\t}\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len;\n\n\tskb->protocol = htons(ETH_P_IP);\n\n\t \n\tskb->dev      = dev;\n\tskb->mac_header = skb->network_header;\n\tskb_reset_network_header(skb);\n\tskb->pkt_type = PACKET_HOST;\n\n\tnetif_rx(skb);\n\n\treturn 1;\n}\n\nstatic int nr_header(struct sk_buff *skb, struct net_device *dev,\n\t\t     unsigned short type,\n\t\t     const void *daddr, const void *saddr, unsigned int len)\n{\n\tunsigned char *buff = skb_push(skb, NR_NETWORK_LEN + NR_TRANSPORT_LEN);\n\n\tmemcpy(buff, (saddr != NULL) ? saddr : dev->dev_addr, dev->addr_len);\n\tbuff[6] &= ~AX25_CBIT;\n\tbuff[6] &= ~AX25_EBIT;\n\tbuff[6] |= AX25_SSSID_SPARE;\n\tbuff    += AX25_ADDR_LEN;\n\n\tif (daddr != NULL)\n\t\tmemcpy(buff, daddr, dev->addr_len);\n\tbuff[6] &= ~AX25_CBIT;\n\tbuff[6] |= AX25_EBIT;\n\tbuff[6] |= AX25_SSSID_SPARE;\n\tbuff    += AX25_ADDR_LEN;\n\n\t*buff++ = sysctl_netrom_network_ttl_initialiser;\n\n\t*buff++ = NR_PROTO_IP;\n\t*buff++ = NR_PROTO_IP;\n\t*buff++ = 0;\n\t*buff++ = 0;\n\t*buff++ = NR_PROTOEXT;\n\n\tif (daddr != NULL)\n\t\treturn 37;\n\n\treturn -37;\n}\n\nstatic int __must_check nr_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = addr;\n\tint err;\n\n\tif (!memcmp(dev->dev_addr, sa->sa_data, dev->addr_len))\n\t\treturn 0;\n\n\tif (dev->flags & IFF_UP) {\n\t\terr = ax25_listen_register((ax25_address *)sa->sa_data, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tax25_listen_release((const ax25_address *)dev->dev_addr, NULL);\n\t}\n\n\tdev_addr_set(dev, sa->sa_data);\n\n\treturn 0;\n}\n\nstatic int nr_open(struct net_device *dev)\n{\n\tint err;\n\n\terr = ax25_listen_register((const ax25_address *)dev->dev_addr, NULL);\n\tif (err)\n\t\treturn err;\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int nr_close(struct net_device *dev)\n{\n\tax25_listen_release((const ax25_address *)dev->dev_addr, NULL);\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\nstatic netdev_tx_t nr_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tunsigned int len = skb->len;\n\n\tif (!nr_route_frame(skb, NULL)) {\n\t\tkfree_skb(skb);\n\t\tstats->tx_errors++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tstats->tx_packets++;\n\tstats->tx_bytes += len;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct header_ops nr_header_ops = {\n\t.create\t= nr_header,\n};\n\nstatic const struct net_device_ops nr_netdev_ops = {\n\t.ndo_open\t\t= nr_open,\n\t.ndo_stop\t\t= nr_close,\n\t.ndo_start_xmit\t\t= nr_xmit,\n\t.ndo_set_mac_address    = nr_set_mac_address,\n};\n\nvoid nr_setup(struct net_device *dev)\n{\n\tdev->mtu\t\t= NR_MAX_PACKET_SIZE;\n\tdev->netdev_ops\t\t= &nr_netdev_ops;\n\tdev->header_ops\t\t= &nr_header_ops;\n\tdev->hard_header_len\t= NR_NETWORK_LEN + NR_TRANSPORT_LEN;\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_NETROM;\n\n\t \n\tdev->flags\t\t= IFF_NOARP;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}