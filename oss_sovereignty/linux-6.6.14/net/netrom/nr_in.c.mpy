{
  "module_name": "nr_in.c",
  "hash_id": "865dfbd14cfdf424686ec48d2ee64009d6dabd34fdc596ab1c51c3cf1c0b971d",
  "original_prompt": "Ingested from linux-6.6.14/net/netrom/nr_in.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/netrom.h>\n\nstatic int nr_queue_rx_frame(struct sock *sk, struct sk_buff *skb, int more)\n{\n\tstruct sk_buff *skbo, *skbn = skb;\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tskb_pull(skb, NR_NETWORK_LEN + NR_TRANSPORT_LEN);\n\n\tnr_start_idletimer(sk);\n\n\tif (more) {\n\t\tnr->fraglen += skb->len;\n\t\tskb_queue_tail(&nr->frag_queue, skb);\n\t\treturn 0;\n\t}\n\n\tif (!more && nr->fraglen > 0) {\t \n\t\tnr->fraglen += skb->len;\n\t\tskb_queue_tail(&nr->frag_queue, skb);\n\n\t\tif ((skbn = alloc_skb(nr->fraglen, GFP_ATOMIC)) == NULL)\n\t\t\treturn 1;\n\n\t\tskb_reset_transport_header(skbn);\n\n\t\twhile ((skbo = skb_dequeue(&nr->frag_queue)) != NULL) {\n\t\t\tskb_copy_from_linear_data(skbo,\n\t\t\t\t\t\t  skb_put(skbn, skbo->len),\n\t\t\t\t\t\t  skbo->len);\n\t\t\tkfree_skb(skbo);\n\t\t}\n\n\t\tnr->fraglen = 0;\n\t}\n\n\treturn sock_queue_rcv_skb(sk, skbn);\n}\n\n \nstatic int nr_state1_machine(struct sock *sk, struct sk_buff *skb,\n\tint frametype)\n{\n\tswitch (frametype) {\n\tcase NR_CONNACK: {\n\t\tstruct nr_sock *nr = nr_sk(sk);\n\n\t\tnr_stop_t1timer(sk);\n\t\tnr_start_idletimer(sk);\n\t\tnr->your_index = skb->data[17];\n\t\tnr->your_id    = skb->data[18];\n\t\tnr->vs\t       = 0;\n\t\tnr->va\t       = 0;\n\t\tnr->vr\t       = 0;\n\t\tnr->vl\t       = 0;\n\t\tnr->state      = NR_STATE_3;\n\t\tnr->n2count    = 0;\n\t\tnr->window     = skb->data[20];\n\t\tsk->sk_state   = TCP_ESTABLISHED;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\t}\n\n\tcase NR_CONNACK | NR_CHOKE_FLAG:\n\t\tnr_disconnect(sk, ECONNREFUSED);\n\t\tbreak;\n\n\tcase NR_RESET:\n\t\tif (sysctl_netrom_reset_circuit)\n\t\t\tnr_disconnect(sk, ECONNRESET);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int nr_state2_machine(struct sock *sk, struct sk_buff *skb,\n\tint frametype)\n{\n\tswitch (frametype) {\n\tcase NR_CONNACK | NR_CHOKE_FLAG:\n\t\tnr_disconnect(sk, ECONNRESET);\n\t\tbreak;\n\n\tcase NR_DISCREQ:\n\t\tnr_write_internal(sk, NR_DISCACK);\n\t\tfallthrough;\n\tcase NR_DISCACK:\n\t\tnr_disconnect(sk, 0);\n\t\tbreak;\n\n\tcase NR_RESET:\n\t\tif (sysctl_netrom_reset_circuit)\n\t\t\tnr_disconnect(sk, ECONNRESET);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int nr_state3_machine(struct sock *sk, struct sk_buff *skb, int frametype)\n{\n\tstruct nr_sock *nrom = nr_sk(sk);\n\tstruct sk_buff_head temp_queue;\n\tstruct sk_buff *skbn;\n\tunsigned short save_vr;\n\tunsigned short nr, ns;\n\tint queued = 0;\n\n\tnr = skb->data[18];\n\n\tswitch (frametype) {\n\tcase NR_CONNREQ:\n\t\tnr_write_internal(sk, NR_CONNACK);\n\t\tbreak;\n\n\tcase NR_DISCREQ:\n\t\tnr_write_internal(sk, NR_DISCACK);\n\t\tnr_disconnect(sk, 0);\n\t\tbreak;\n\n\tcase NR_CONNACK | NR_CHOKE_FLAG:\n\tcase NR_DISCACK:\n\t\tnr_disconnect(sk, ECONNRESET);\n\t\tbreak;\n\n\tcase NR_INFOACK:\n\tcase NR_INFOACK | NR_CHOKE_FLAG:\n\tcase NR_INFOACK | NR_NAK_FLAG:\n\tcase NR_INFOACK | NR_NAK_FLAG | NR_CHOKE_FLAG:\n\t\tif (frametype & NR_CHOKE_FLAG) {\n\t\t\tnrom->condition |= NR_COND_PEER_RX_BUSY;\n\t\t\tnr_start_t4timer(sk);\n\t\t} else {\n\t\t\tnrom->condition &= ~NR_COND_PEER_RX_BUSY;\n\t\t\tnr_stop_t4timer(sk);\n\t\t}\n\t\tif (!nr_validate_nr(sk, nr)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (frametype & NR_NAK_FLAG) {\n\t\t\tnr_frames_acked(sk, nr);\n\t\t\tnr_send_nak_frame(sk);\n\t\t} else {\n\t\t\tif (nrom->condition & NR_COND_PEER_RX_BUSY) {\n\t\t\t\tnr_frames_acked(sk, nr);\n\t\t\t} else {\n\t\t\t\tnr_check_iframes_acked(sk, nr);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase NR_INFO:\n\tcase NR_INFO | NR_NAK_FLAG:\n\tcase NR_INFO | NR_CHOKE_FLAG:\n\tcase NR_INFO | NR_MORE_FLAG:\n\tcase NR_INFO | NR_NAK_FLAG | NR_CHOKE_FLAG:\n\tcase NR_INFO | NR_CHOKE_FLAG | NR_MORE_FLAG:\n\tcase NR_INFO | NR_NAK_FLAG | NR_MORE_FLAG:\n\tcase NR_INFO | NR_NAK_FLAG | NR_CHOKE_FLAG | NR_MORE_FLAG:\n\t\tif (frametype & NR_CHOKE_FLAG) {\n\t\t\tnrom->condition |= NR_COND_PEER_RX_BUSY;\n\t\t\tnr_start_t4timer(sk);\n\t\t} else {\n\t\t\tnrom->condition &= ~NR_COND_PEER_RX_BUSY;\n\t\t\tnr_stop_t4timer(sk);\n\t\t}\n\t\tif (nr_validate_nr(sk, nr)) {\n\t\t\tif (frametype & NR_NAK_FLAG) {\n\t\t\t\tnr_frames_acked(sk, nr);\n\t\t\t\tnr_send_nak_frame(sk);\n\t\t\t} else {\n\t\t\t\tif (nrom->condition & NR_COND_PEER_RX_BUSY) {\n\t\t\t\t\tnr_frames_acked(sk, nr);\n\t\t\t\t} else {\n\t\t\t\t\tnr_check_iframes_acked(sk, nr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueued = 1;\n\t\tskb_queue_head(&nrom->reseq_queue, skb);\n\t\tif (nrom->condition & NR_COND_OWN_RX_BUSY)\n\t\t\tbreak;\n\t\tskb_queue_head_init(&temp_queue);\n\t\tdo {\n\t\t\tsave_vr = nrom->vr;\n\t\t\twhile ((skbn = skb_dequeue(&nrom->reseq_queue)) != NULL) {\n\t\t\t\tns = skbn->data[17];\n\t\t\t\tif (ns == nrom->vr) {\n\t\t\t\t\tif (nr_queue_rx_frame(sk, skbn, frametype & NR_MORE_FLAG) == 0) {\n\t\t\t\t\t\tnrom->vr = (nrom->vr + 1) % NR_MODULUS;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnrom->condition |= NR_COND_OWN_RX_BUSY;\n\t\t\t\t\t\tskb_queue_tail(&temp_queue, skbn);\n\t\t\t\t\t}\n\t\t\t\t} else if (nr_in_rx_window(sk, ns)) {\n\t\t\t\t\tskb_queue_tail(&temp_queue, skbn);\n\t\t\t\t} else {\n\t\t\t\t\tkfree_skb(skbn);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ((skbn = skb_dequeue(&temp_queue)) != NULL) {\n\t\t\t\tskb_queue_tail(&nrom->reseq_queue, skbn);\n\t\t\t}\n\t\t} while (save_vr != nrom->vr);\n\t\t \n\t\tif (((nrom->vl + nrom->window) % NR_MODULUS) == nrom->vr) {\n\t\t\tnr_enquiry_response(sk);\n\t\t} else {\n\t\t\tif (!(nrom->condition & NR_COND_ACK_PENDING)) {\n\t\t\t\tnrom->condition |= NR_COND_ACK_PENDING;\n\t\t\t\tnr_start_t2timer(sk);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase NR_RESET:\n\t\tif (sysctl_netrom_reset_circuit)\n\t\t\tnr_disconnect(sk, ECONNRESET);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn queued;\n}\n\n \nint nr_process_rx_frame(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct nr_sock *nr = nr_sk(sk);\n\tint queued = 0, frametype;\n\n\tif (nr->state == NR_STATE_0)\n\t\treturn 0;\n\n\tframetype = skb->data[19];\n\n\tswitch (nr->state) {\n\tcase NR_STATE_1:\n\t\tqueued = nr_state1_machine(sk, skb, frametype);\n\t\tbreak;\n\tcase NR_STATE_2:\n\t\tqueued = nr_state2_machine(sk, skb, frametype);\n\t\tbreak;\n\tcase NR_STATE_3:\n\t\tqueued = nr_state3_machine(sk, skb, frametype);\n\t\tbreak;\n\t}\n\n\tnr_kick(sk);\n\n\treturn queued;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}