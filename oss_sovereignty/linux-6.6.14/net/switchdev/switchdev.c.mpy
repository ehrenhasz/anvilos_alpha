{
  "module_name": "switchdev.c",
  "hash_id": "1397cb24b530d0c58749335323818004932394b9d980ab5930e959ee0ec8f48b",
  "original_prompt": "Ingested from linux-6.6.14/net/switchdev/switchdev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/if_vlan.h>\n#include <linux/rtnetlink.h>\n#include <net/switchdev.h>\n\nstatic LIST_HEAD(deferred);\nstatic DEFINE_SPINLOCK(deferred_lock);\n\ntypedef void switchdev_deferred_func_t(struct net_device *dev,\n\t\t\t\t       const void *data);\n\nstruct switchdev_deferred_item {\n\tstruct list_head list;\n\tstruct net_device *dev;\n\tnetdevice_tracker dev_tracker;\n\tswitchdev_deferred_func_t *func;\n\tunsigned long data[];\n};\n\nstatic struct switchdev_deferred_item *switchdev_deferred_dequeue(void)\n{\n\tstruct switchdev_deferred_item *dfitem;\n\n\tspin_lock_bh(&deferred_lock);\n\tif (list_empty(&deferred)) {\n\t\tdfitem = NULL;\n\t\tgoto unlock;\n\t}\n\tdfitem = list_first_entry(&deferred,\n\t\t\t\t  struct switchdev_deferred_item, list);\n\tlist_del(&dfitem->list);\nunlock:\n\tspin_unlock_bh(&deferred_lock);\n\treturn dfitem;\n}\n\n \nvoid switchdev_deferred_process(void)\n{\n\tstruct switchdev_deferred_item *dfitem;\n\n\tASSERT_RTNL();\n\n\twhile ((dfitem = switchdev_deferred_dequeue())) {\n\t\tdfitem->func(dfitem->dev, dfitem->data);\n\t\tnetdev_put(dfitem->dev, &dfitem->dev_tracker);\n\t\tkfree(dfitem);\n\t}\n}\nEXPORT_SYMBOL_GPL(switchdev_deferred_process);\n\nstatic void switchdev_deferred_process_work(struct work_struct *work)\n{\n\trtnl_lock();\n\tswitchdev_deferred_process();\n\trtnl_unlock();\n}\n\nstatic DECLARE_WORK(deferred_process_work, switchdev_deferred_process_work);\n\nstatic int switchdev_deferred_enqueue(struct net_device *dev,\n\t\t\t\t      const void *data, size_t data_len,\n\t\t\t\t      switchdev_deferred_func_t *func)\n{\n\tstruct switchdev_deferred_item *dfitem;\n\n\tdfitem = kmalloc(struct_size(dfitem, data, data_len), GFP_ATOMIC);\n\tif (!dfitem)\n\t\treturn -ENOMEM;\n\tdfitem->dev = dev;\n\tdfitem->func = func;\n\tmemcpy(dfitem->data, data, data_len);\n\tnetdev_hold(dev, &dfitem->dev_tracker, GFP_ATOMIC);\n\tspin_lock_bh(&deferred_lock);\n\tlist_add_tail(&dfitem->list, &deferred);\n\tspin_unlock_bh(&deferred_lock);\n\tschedule_work(&deferred_process_work);\n\treturn 0;\n}\n\nstatic int switchdev_port_attr_notify(enum switchdev_notifier_type nt,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      const struct switchdev_attr *attr,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint err;\n\tint rc;\n\n\tstruct switchdev_notifier_port_attr_info attr_info = {\n\t\t.attr = attr,\n\t\t.handled = false,\n\t};\n\n\trc = call_switchdev_blocking_notifiers(nt, dev,\n\t\t\t\t\t       &attr_info.info, extack);\n\terr = notifier_to_errno(rc);\n\tif (err) {\n\t\tWARN_ON(!attr_info.handled);\n\t\treturn err;\n\t}\n\n\tif (!attr_info.handled)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int switchdev_port_attr_set_now(struct net_device *dev,\n\t\t\t\t       const struct switchdev_attr *attr,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn switchdev_port_attr_notify(SWITCHDEV_PORT_ATTR_SET, dev, attr,\n\t\t\t\t\t  extack);\n}\n\nstatic void switchdev_port_attr_set_deferred(struct net_device *dev,\n\t\t\t\t\t     const void *data)\n{\n\tconst struct switchdev_attr *attr = data;\n\tint err;\n\n\terr = switchdev_port_attr_set_now(dev, attr, NULL);\n\tif (err && err != -EOPNOTSUPP)\n\t\tnetdev_err(dev, \"failed (err=%d) to set attribute (id=%d)\\n\",\n\t\t\t   err, attr->id);\n\tif (attr->complete)\n\t\tattr->complete(dev, err, attr->complete_priv);\n}\n\nstatic int switchdev_port_attr_set_defer(struct net_device *dev,\n\t\t\t\t\t const struct switchdev_attr *attr)\n{\n\treturn switchdev_deferred_enqueue(dev, attr, sizeof(*attr),\n\t\t\t\t\t  switchdev_port_attr_set_deferred);\n}\n\n \nint switchdev_port_attr_set(struct net_device *dev,\n\t\t\t    const struct switchdev_attr *attr,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (attr->flags & SWITCHDEV_F_DEFER)\n\t\treturn switchdev_port_attr_set_defer(dev, attr);\n\tASSERT_RTNL();\n\treturn switchdev_port_attr_set_now(dev, attr, extack);\n}\nEXPORT_SYMBOL_GPL(switchdev_port_attr_set);\n\nstatic size_t switchdev_obj_size(const struct switchdev_obj *obj)\n{\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\treturn sizeof(struct switchdev_obj_port_vlan);\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\treturn sizeof(struct switchdev_obj_port_mdb);\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\treturn sizeof(struct switchdev_obj_port_mdb);\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\nstatic int switchdev_port_obj_notify(enum switchdev_notifier_type nt,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     const struct switchdev_obj *obj,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tint rc;\n\tint err;\n\n\tstruct switchdev_notifier_port_obj_info obj_info = {\n\t\t.obj = obj,\n\t\t.handled = false,\n\t};\n\n\trc = call_switchdev_blocking_notifiers(nt, dev, &obj_info.info, extack);\n\terr = notifier_to_errno(rc);\n\tif (err) {\n\t\tWARN_ON(!obj_info.handled);\n\t\treturn err;\n\t}\n\tif (!obj_info.handled)\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic void switchdev_port_obj_add_deferred(struct net_device *dev,\n\t\t\t\t\t    const void *data)\n{\n\tconst struct switchdev_obj *obj = data;\n\tint err;\n\n\tASSERT_RTNL();\n\terr = switchdev_port_obj_notify(SWITCHDEV_PORT_OBJ_ADD,\n\t\t\t\t\tdev, obj, NULL);\n\tif (err && err != -EOPNOTSUPP)\n\t\tnetdev_err(dev, \"failed (err=%d) to add object (id=%d)\\n\",\n\t\t\t   err, obj->id);\n\tif (obj->complete)\n\t\tobj->complete(dev, err, obj->complete_priv);\n}\n\nstatic int switchdev_port_obj_add_defer(struct net_device *dev,\n\t\t\t\t\tconst struct switchdev_obj *obj)\n{\n\treturn switchdev_deferred_enqueue(dev, obj, switchdev_obj_size(obj),\n\t\t\t\t\t  switchdev_port_obj_add_deferred);\n}\n\n \nint switchdev_port_obj_add(struct net_device *dev,\n\t\t\t   const struct switchdev_obj *obj,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tif (obj->flags & SWITCHDEV_F_DEFER)\n\t\treturn switchdev_port_obj_add_defer(dev, obj);\n\tASSERT_RTNL();\n\treturn switchdev_port_obj_notify(SWITCHDEV_PORT_OBJ_ADD,\n\t\t\t\t\t dev, obj, extack);\n}\nEXPORT_SYMBOL_GPL(switchdev_port_obj_add);\n\nstatic int switchdev_port_obj_del_now(struct net_device *dev,\n\t\t\t\t      const struct switchdev_obj *obj)\n{\n\treturn switchdev_port_obj_notify(SWITCHDEV_PORT_OBJ_DEL,\n\t\t\t\t\t dev, obj, NULL);\n}\n\nstatic void switchdev_port_obj_del_deferred(struct net_device *dev,\n\t\t\t\t\t    const void *data)\n{\n\tconst struct switchdev_obj *obj = data;\n\tint err;\n\n\terr = switchdev_port_obj_del_now(dev, obj);\n\tif (err && err != -EOPNOTSUPP)\n\t\tnetdev_err(dev, \"failed (err=%d) to del object (id=%d)\\n\",\n\t\t\t   err, obj->id);\n\tif (obj->complete)\n\t\tobj->complete(dev, err, obj->complete_priv);\n}\n\nstatic int switchdev_port_obj_del_defer(struct net_device *dev,\n\t\t\t\t\tconst struct switchdev_obj *obj)\n{\n\treturn switchdev_deferred_enqueue(dev, obj, switchdev_obj_size(obj),\n\t\t\t\t\t  switchdev_port_obj_del_deferred);\n}\n\n \nint switchdev_port_obj_del(struct net_device *dev,\n\t\t\t   const struct switchdev_obj *obj)\n{\n\tif (obj->flags & SWITCHDEV_F_DEFER)\n\t\treturn switchdev_port_obj_del_defer(dev, obj);\n\tASSERT_RTNL();\n\treturn switchdev_port_obj_del_now(dev, obj);\n}\nEXPORT_SYMBOL_GPL(switchdev_port_obj_del);\n\nstatic ATOMIC_NOTIFIER_HEAD(switchdev_notif_chain);\nstatic BLOCKING_NOTIFIER_HEAD(switchdev_blocking_notif_chain);\n\n \nint register_switchdev_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&switchdev_notif_chain, nb);\n}\nEXPORT_SYMBOL_GPL(register_switchdev_notifier);\n\n \nint unregister_switchdev_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&switchdev_notif_chain, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_switchdev_notifier);\n\n \nint call_switchdev_notifiers(unsigned long val, struct net_device *dev,\n\t\t\t     struct switchdev_notifier_info *info,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tinfo->dev = dev;\n\tinfo->extack = extack;\n\treturn atomic_notifier_call_chain(&switchdev_notif_chain, val, info);\n}\nEXPORT_SYMBOL_GPL(call_switchdev_notifiers);\n\nint register_switchdev_blocking_notifier(struct notifier_block *nb)\n{\n\tstruct blocking_notifier_head *chain = &switchdev_blocking_notif_chain;\n\n\treturn blocking_notifier_chain_register(chain, nb);\n}\nEXPORT_SYMBOL_GPL(register_switchdev_blocking_notifier);\n\nint unregister_switchdev_blocking_notifier(struct notifier_block *nb)\n{\n\tstruct blocking_notifier_head *chain = &switchdev_blocking_notif_chain;\n\n\treturn blocking_notifier_chain_unregister(chain, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_switchdev_blocking_notifier);\n\nint call_switchdev_blocking_notifiers(unsigned long val, struct net_device *dev,\n\t\t\t\t      struct switchdev_notifier_info *info,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tinfo->dev = dev;\n\tinfo->extack = extack;\n\treturn blocking_notifier_call_chain(&switchdev_blocking_notif_chain,\n\t\t\t\t\t    val, info);\n}\nEXPORT_SYMBOL_GPL(call_switchdev_blocking_notifiers);\n\nstruct switchdev_nested_priv {\n\tbool (*check_cb)(const struct net_device *dev);\n\tbool (*foreign_dev_check_cb)(const struct net_device *dev,\n\t\t\t\t     const struct net_device *foreign_dev);\n\tconst struct net_device *dev;\n\tstruct net_device *lower_dev;\n};\n\nstatic int switchdev_lower_dev_walk(struct net_device *lower_dev,\n\t\t\t\t    struct netdev_nested_priv *priv)\n{\n\tstruct switchdev_nested_priv *switchdev_priv = priv->data;\n\tbool (*foreign_dev_check_cb)(const struct net_device *dev,\n\t\t\t\t     const struct net_device *foreign_dev);\n\tbool (*check_cb)(const struct net_device *dev);\n\tconst struct net_device *dev;\n\n\tcheck_cb = switchdev_priv->check_cb;\n\tforeign_dev_check_cb = switchdev_priv->foreign_dev_check_cb;\n\tdev = switchdev_priv->dev;\n\n\tif (check_cb(lower_dev) && !foreign_dev_check_cb(lower_dev, dev)) {\n\t\tswitchdev_priv->lower_dev = lower_dev;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct net_device *\nswitchdev_lower_dev_find_rcu(struct net_device *dev,\n\t\t\t     bool (*check_cb)(const struct net_device *dev),\n\t\t\t     bool (*foreign_dev_check_cb)(const struct net_device *dev,\n\t\t\t\t\t\t\t  const struct net_device *foreign_dev))\n{\n\tstruct switchdev_nested_priv switchdev_priv = {\n\t\t.check_cb = check_cb,\n\t\t.foreign_dev_check_cb = foreign_dev_check_cb,\n\t\t.dev = dev,\n\t\t.lower_dev = NULL,\n\t};\n\tstruct netdev_nested_priv priv = {\n\t\t.data = &switchdev_priv,\n\t};\n\n\tnetdev_walk_all_lower_dev_rcu(dev, switchdev_lower_dev_walk, &priv);\n\n\treturn switchdev_priv.lower_dev;\n}\n\nstatic struct net_device *\nswitchdev_lower_dev_find(struct net_device *dev,\n\t\t\t bool (*check_cb)(const struct net_device *dev),\n\t\t\t bool (*foreign_dev_check_cb)(const struct net_device *dev,\n\t\t\t\t\t\t      const struct net_device *foreign_dev))\n{\n\tstruct switchdev_nested_priv switchdev_priv = {\n\t\t.check_cb = check_cb,\n\t\t.foreign_dev_check_cb = foreign_dev_check_cb,\n\t\t.dev = dev,\n\t\t.lower_dev = NULL,\n\t};\n\tstruct netdev_nested_priv priv = {\n\t\t.data = &switchdev_priv,\n\t};\n\n\tnetdev_walk_all_lower_dev(dev, switchdev_lower_dev_walk, &priv);\n\n\treturn switchdev_priv.lower_dev;\n}\n\nstatic int __switchdev_handle_fdb_event_to_device(struct net_device *dev,\n\t\tstruct net_device *orig_dev, unsigned long event,\n\t\tconst struct switchdev_notifier_fdb_info *fdb_info,\n\t\tbool (*check_cb)(const struct net_device *dev),\n\t\tbool (*foreign_dev_check_cb)(const struct net_device *dev,\n\t\t\t\t\t     const struct net_device *foreign_dev),\n\t\tint (*mod_cb)(struct net_device *dev, struct net_device *orig_dev,\n\t\t\t      unsigned long event, const void *ctx,\n\t\t\t      const struct switchdev_notifier_fdb_info *fdb_info))\n{\n\tconst struct switchdev_notifier_info *info = &fdb_info->info;\n\tstruct net_device *br, *lower_dev, *switchdev;\n\tstruct list_head *iter;\n\tint err = -EOPNOTSUPP;\n\n\tif (check_cb(dev))\n\t\treturn mod_cb(dev, orig_dev, event, info->ctx, fdb_info);\n\n\t \n\tnetdev_for_each_lower_dev(dev, lower_dev, iter) {\n\t\t \n\t\tif (netif_is_bridge_master(lower_dev))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!check_cb(lower_dev) &&\n\t\t    !switchdev_lower_dev_find_rcu(lower_dev, check_cb,\n\t\t\t\t\t\t  foreign_dev_check_cb))\n\t\t\tcontinue;\n\n\t\terr = __switchdev_handle_fdb_event_to_device(lower_dev, orig_dev,\n\t\t\t\t\t\t\t     event, fdb_info, check_cb,\n\t\t\t\t\t\t\t     foreign_dev_check_cb,\n\t\t\t\t\t\t\t     mod_cb);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\t \n\tbr = netdev_master_upper_dev_get_rcu(dev);\n\tif (!br || !netif_is_bridge_master(br))\n\t\treturn 0;\n\n\tswitchdev = switchdev_lower_dev_find_rcu(br, check_cb, foreign_dev_check_cb);\n\tif (!switchdev)\n\t\treturn 0;\n\n\tif (!foreign_dev_check_cb(switchdev, dev))\n\t\treturn err;\n\n\treturn __switchdev_handle_fdb_event_to_device(br, orig_dev, event, fdb_info,\n\t\t\t\t\t\t      check_cb, foreign_dev_check_cb,\n\t\t\t\t\t\t      mod_cb);\n}\n\nint switchdev_handle_fdb_event_to_device(struct net_device *dev, unsigned long event,\n\t\tconst struct switchdev_notifier_fdb_info *fdb_info,\n\t\tbool (*check_cb)(const struct net_device *dev),\n\t\tbool (*foreign_dev_check_cb)(const struct net_device *dev,\n\t\t\t\t\t     const struct net_device *foreign_dev),\n\t\tint (*mod_cb)(struct net_device *dev, struct net_device *orig_dev,\n\t\t\t      unsigned long event, const void *ctx,\n\t\t\t      const struct switchdev_notifier_fdb_info *fdb_info))\n{\n\tint err;\n\n\terr = __switchdev_handle_fdb_event_to_device(dev, dev, event, fdb_info,\n\t\t\t\t\t\t     check_cb, foreign_dev_check_cb,\n\t\t\t\t\t\t     mod_cb);\n\tif (err == -EOPNOTSUPP)\n\t\terr = 0;\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(switchdev_handle_fdb_event_to_device);\n\nstatic int __switchdev_handle_port_obj_add(struct net_device *dev,\n\t\t\tstruct switchdev_notifier_port_obj_info *port_obj_info,\n\t\t\tbool (*check_cb)(const struct net_device *dev),\n\t\t\tbool (*foreign_dev_check_cb)(const struct net_device *dev,\n\t\t\t\t\t\t     const struct net_device *foreign_dev),\n\t\t\tint (*add_cb)(struct net_device *dev, const void *ctx,\n\t\t\t\t      const struct switchdev_obj *obj,\n\t\t\t\t      struct netlink_ext_ack *extack))\n{\n\tstruct switchdev_notifier_info *info = &port_obj_info->info;\n\tstruct net_device *br, *lower_dev, *switchdev;\n\tstruct netlink_ext_ack *extack;\n\tstruct list_head *iter;\n\tint err = -EOPNOTSUPP;\n\n\textack = switchdev_notifier_info_to_extack(info);\n\n\tif (check_cb(dev)) {\n\t\terr = add_cb(dev, info->ctx, port_obj_info->obj, extack);\n\t\tif (err != -EOPNOTSUPP)\n\t\t\tport_obj_info->handled = true;\n\t\treturn err;\n\t}\n\n\t \n\tnetdev_for_each_lower_dev(dev, lower_dev, iter) {\n\t\tif (netif_is_bridge_master(lower_dev))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (foreign_dev_check_cb && !check_cb(lower_dev) &&\n\t\t    !switchdev_lower_dev_find(lower_dev, check_cb, foreign_dev_check_cb))\n\t\t\tcontinue;\n\n\t\terr = __switchdev_handle_port_obj_add(lower_dev, port_obj_info,\n\t\t\t\t\t\t      check_cb, foreign_dev_check_cb,\n\t\t\t\t\t\t      add_cb);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!foreign_dev_check_cb)\n\t\treturn err;\n\n\tbr = netdev_master_upper_dev_get(dev);\n\tif (!br || !netif_is_bridge_master(br))\n\t\treturn err;\n\n\tswitchdev = switchdev_lower_dev_find(br, check_cb, foreign_dev_check_cb);\n\tif (!switchdev)\n\t\treturn err;\n\n\tif (!foreign_dev_check_cb(switchdev, dev))\n\t\treturn err;\n\n\treturn __switchdev_handle_port_obj_add(br, port_obj_info, check_cb,\n\t\t\t\t\t       foreign_dev_check_cb, add_cb);\n}\n\n \nint switchdev_handle_port_obj_add(struct net_device *dev,\n\t\t\tstruct switchdev_notifier_port_obj_info *port_obj_info,\n\t\t\tbool (*check_cb)(const struct net_device *dev),\n\t\t\tint (*add_cb)(struct net_device *dev, const void *ctx,\n\t\t\t\t      const struct switchdev_obj *obj,\n\t\t\t\t      struct netlink_ext_ack *extack))\n{\n\tint err;\n\n\terr = __switchdev_handle_port_obj_add(dev, port_obj_info, check_cb,\n\t\t\t\t\t      NULL, add_cb);\n\tif (err == -EOPNOTSUPP)\n\t\terr = 0;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(switchdev_handle_port_obj_add);\n\n \nint switchdev_handle_port_obj_add_foreign(struct net_device *dev,\n\t\t\tstruct switchdev_notifier_port_obj_info *port_obj_info,\n\t\t\tbool (*check_cb)(const struct net_device *dev),\n\t\t\tbool (*foreign_dev_check_cb)(const struct net_device *dev,\n\t\t\t\t\t\t     const struct net_device *foreign_dev),\n\t\t\tint (*add_cb)(struct net_device *dev, const void *ctx,\n\t\t\t\t      const struct switchdev_obj *obj,\n\t\t\t\t      struct netlink_ext_ack *extack))\n{\n\tint err;\n\n\terr = __switchdev_handle_port_obj_add(dev, port_obj_info, check_cb,\n\t\t\t\t\t      foreign_dev_check_cb, add_cb);\n\tif (err == -EOPNOTSUPP)\n\t\terr = 0;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(switchdev_handle_port_obj_add_foreign);\n\nstatic int __switchdev_handle_port_obj_del(struct net_device *dev,\n\t\t\tstruct switchdev_notifier_port_obj_info *port_obj_info,\n\t\t\tbool (*check_cb)(const struct net_device *dev),\n\t\t\tbool (*foreign_dev_check_cb)(const struct net_device *dev,\n\t\t\t\t\t\t     const struct net_device *foreign_dev),\n\t\t\tint (*del_cb)(struct net_device *dev, const void *ctx,\n\t\t\t\t      const struct switchdev_obj *obj))\n{\n\tstruct switchdev_notifier_info *info = &port_obj_info->info;\n\tstruct net_device *br, *lower_dev, *switchdev;\n\tstruct list_head *iter;\n\tint err = -EOPNOTSUPP;\n\n\tif (check_cb(dev)) {\n\t\terr = del_cb(dev, info->ctx, port_obj_info->obj);\n\t\tif (err != -EOPNOTSUPP)\n\t\t\tport_obj_info->handled = true;\n\t\treturn err;\n\t}\n\n\t \n\tnetdev_for_each_lower_dev(dev, lower_dev, iter) {\n\t\tif (netif_is_bridge_master(lower_dev))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (foreign_dev_check_cb && !check_cb(lower_dev) &&\n\t\t    !switchdev_lower_dev_find(lower_dev, check_cb, foreign_dev_check_cb))\n\t\t\tcontinue;\n\n\t\terr = __switchdev_handle_port_obj_del(lower_dev, port_obj_info,\n\t\t\t\t\t\t      check_cb, foreign_dev_check_cb,\n\t\t\t\t\t\t      del_cb);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!foreign_dev_check_cb)\n\t\treturn err;\n\n\tbr = netdev_master_upper_dev_get(dev);\n\tif (!br || !netif_is_bridge_master(br))\n\t\treturn err;\n\n\tswitchdev = switchdev_lower_dev_find(br, check_cb, foreign_dev_check_cb);\n\tif (!switchdev)\n\t\treturn err;\n\n\tif (!foreign_dev_check_cb(switchdev, dev))\n\t\treturn err;\n\n\treturn __switchdev_handle_port_obj_del(br, port_obj_info, check_cb,\n\t\t\t\t\t       foreign_dev_check_cb, del_cb);\n}\n\n \nint switchdev_handle_port_obj_del(struct net_device *dev,\n\t\t\tstruct switchdev_notifier_port_obj_info *port_obj_info,\n\t\t\tbool (*check_cb)(const struct net_device *dev),\n\t\t\tint (*del_cb)(struct net_device *dev, const void *ctx,\n\t\t\t\t      const struct switchdev_obj *obj))\n{\n\tint err;\n\n\terr = __switchdev_handle_port_obj_del(dev, port_obj_info, check_cb,\n\t\t\t\t\t      NULL, del_cb);\n\tif (err == -EOPNOTSUPP)\n\t\terr = 0;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(switchdev_handle_port_obj_del);\n\n \nint switchdev_handle_port_obj_del_foreign(struct net_device *dev,\n\t\t\tstruct switchdev_notifier_port_obj_info *port_obj_info,\n\t\t\tbool (*check_cb)(const struct net_device *dev),\n\t\t\tbool (*foreign_dev_check_cb)(const struct net_device *dev,\n\t\t\t\t\t\t     const struct net_device *foreign_dev),\n\t\t\tint (*del_cb)(struct net_device *dev, const void *ctx,\n\t\t\t\t      const struct switchdev_obj *obj))\n{\n\tint err;\n\n\terr = __switchdev_handle_port_obj_del(dev, port_obj_info, check_cb,\n\t\t\t\t\t      foreign_dev_check_cb, del_cb);\n\tif (err == -EOPNOTSUPP)\n\t\terr = 0;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(switchdev_handle_port_obj_del_foreign);\n\nstatic int __switchdev_handle_port_attr_set(struct net_device *dev,\n\t\t\tstruct switchdev_notifier_port_attr_info *port_attr_info,\n\t\t\tbool (*check_cb)(const struct net_device *dev),\n\t\t\tint (*set_cb)(struct net_device *dev, const void *ctx,\n\t\t\t\t      const struct switchdev_attr *attr,\n\t\t\t\t      struct netlink_ext_ack *extack))\n{\n\tstruct switchdev_notifier_info *info = &port_attr_info->info;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *lower_dev;\n\tstruct list_head *iter;\n\tint err = -EOPNOTSUPP;\n\n\textack = switchdev_notifier_info_to_extack(info);\n\n\tif (check_cb(dev)) {\n\t\terr = set_cb(dev, info->ctx, port_attr_info->attr, extack);\n\t\tif (err != -EOPNOTSUPP)\n\t\t\tport_attr_info->handled = true;\n\t\treturn err;\n\t}\n\n\t \n\tnetdev_for_each_lower_dev(dev, lower_dev, iter) {\n\t\tif (netif_is_bridge_master(lower_dev))\n\t\t\tcontinue;\n\n\t\terr = __switchdev_handle_port_attr_set(lower_dev, port_attr_info,\n\t\t\t\t\t\t       check_cb, set_cb);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nint switchdev_handle_port_attr_set(struct net_device *dev,\n\t\t\tstruct switchdev_notifier_port_attr_info *port_attr_info,\n\t\t\tbool (*check_cb)(const struct net_device *dev),\n\t\t\tint (*set_cb)(struct net_device *dev, const void *ctx,\n\t\t\t\t      const struct switchdev_attr *attr,\n\t\t\t\t      struct netlink_ext_ack *extack))\n{\n\tint err;\n\n\terr = __switchdev_handle_port_attr_set(dev, port_attr_info, check_cb,\n\t\t\t\t\t       set_cb);\n\tif (err == -EOPNOTSUPP)\n\t\terr = 0;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(switchdev_handle_port_attr_set);\n\nint switchdev_bridge_port_offload(struct net_device *brport_dev,\n\t\t\t\t  struct net_device *dev, const void *ctx,\n\t\t\t\t  struct notifier_block *atomic_nb,\n\t\t\t\t  struct notifier_block *blocking_nb,\n\t\t\t\t  bool tx_fwd_offload,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_notifier_brport_info brport_info = {\n\t\t.brport = {\n\t\t\t.dev = dev,\n\t\t\t.ctx = ctx,\n\t\t\t.atomic_nb = atomic_nb,\n\t\t\t.blocking_nb = blocking_nb,\n\t\t\t.tx_fwd_offload = tx_fwd_offload,\n\t\t},\n\t};\n\tint err;\n\n\tASSERT_RTNL();\n\n\terr = call_switchdev_blocking_notifiers(SWITCHDEV_BRPORT_OFFLOADED,\n\t\t\t\t\t\tbrport_dev, &brport_info.info,\n\t\t\t\t\t\textack);\n\treturn notifier_to_errno(err);\n}\nEXPORT_SYMBOL_GPL(switchdev_bridge_port_offload);\n\nvoid switchdev_bridge_port_unoffload(struct net_device *brport_dev,\n\t\t\t\t     const void *ctx,\n\t\t\t\t     struct notifier_block *atomic_nb,\n\t\t\t\t     struct notifier_block *blocking_nb)\n{\n\tstruct switchdev_notifier_brport_info brport_info = {\n\t\t.brport = {\n\t\t\t.ctx = ctx,\n\t\t\t.atomic_nb = atomic_nb,\n\t\t\t.blocking_nb = blocking_nb,\n\t\t},\n\t};\n\n\tASSERT_RTNL();\n\n\tcall_switchdev_blocking_notifiers(SWITCHDEV_BRPORT_UNOFFLOADED,\n\t\t\t\t\t  brport_dev, &brport_info.info,\n\t\t\t\t\t  NULL);\n}\nEXPORT_SYMBOL_GPL(switchdev_bridge_port_unoffload);\n\nint switchdev_bridge_port_replay(struct net_device *brport_dev,\n\t\t\t\t struct net_device *dev, const void *ctx,\n\t\t\t\t struct notifier_block *atomic_nb,\n\t\t\t\t struct notifier_block *blocking_nb,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_notifier_brport_info brport_info = {\n\t\t.brport = {\n\t\t\t.dev = dev,\n\t\t\t.ctx = ctx,\n\t\t\t.atomic_nb = atomic_nb,\n\t\t\t.blocking_nb = blocking_nb,\n\t\t},\n\t};\n\tint err;\n\n\tASSERT_RTNL();\n\n\terr = call_switchdev_blocking_notifiers(SWITCHDEV_BRPORT_REPLAY,\n\t\t\t\t\t\tbrport_dev, &brport_info.info,\n\t\t\t\t\t\textack);\n\treturn notifier_to_errno(err);\n}\nEXPORT_SYMBOL_GPL(switchdev_bridge_port_replay);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}