{
  "module_name": "tls_strp.c",
  "hash_id": "e1a1c36414cfcb337a5381f406dc1efafcbeb7468f93c078fad3c754182d61b3",
  "original_prompt": "Ingested from linux-6.6.14/net/tls/tls_strp.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <linux/workqueue.h>\n#include <net/strparser.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <net/tls.h>\n\n#include \"tls.h\"\n\nstatic struct workqueue_struct *tls_strp_wq;\n\nstatic void tls_strp_abort_strp(struct tls_strparser *strp, int err)\n{\n\tif (strp->stopped)\n\t\treturn;\n\n\tstrp->stopped = 1;\n\n\t \n\tWRITE_ONCE(strp->sk->sk_err, -err);\n\t \n\tsmp_wmb();\n\tsk_error_report(strp->sk);\n}\n\nstatic void tls_strp_anchor_free(struct tls_strparser *strp)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(strp->anchor);\n\n\tDEBUG_NET_WARN_ON_ONCE(atomic_read(&shinfo->dataref) != 1);\n\tif (!strp->copy_mode)\n\t\tshinfo->frag_list = NULL;\n\tconsume_skb(strp->anchor);\n\tstrp->anchor = NULL;\n}\n\nstatic struct sk_buff *\ntls_strp_skb_copy(struct tls_strparser *strp, struct sk_buff *in_skb,\n\t\t  int offset, int len)\n{\n\tstruct sk_buff *skb;\n\tint i, err;\n\n\tskb = alloc_skb_with_frags(0, len, TLS_PAGE_ORDER,\n\t\t\t\t   &err, strp->sk->sk_allocation);\n\tif (!skb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tWARN_ON_ONCE(skb_copy_bits(in_skb, offset,\n\t\t\t\t\t   skb_frag_address(frag),\n\t\t\t\t\t   skb_frag_size(frag)));\n\t\toffset += skb_frag_size(frag);\n\t}\n\n\tskb->len = len;\n\tskb->data_len = len;\n\tskb_copy_header(skb, in_skb);\n\treturn skb;\n}\n\n \nstatic struct sk_buff *tls_strp_msg_make_copy(struct tls_strparser *strp)\n{\n\tstruct strp_msg *rxm;\n\tstruct sk_buff *skb;\n\n\tskb = tls_strp_skb_copy(strp, strp->anchor, strp->stm.offset,\n\t\t\t\tstrp->stm.full_len);\n\tif (!skb)\n\t\treturn NULL;\n\n\trxm = strp_msg(skb);\n\trxm->offset = 0;\n\treturn skb;\n}\n\n \nstruct sk_buff *tls_strp_msg_detach(struct tls_sw_context_rx *ctx)\n{\n\tstruct tls_strparser *strp = &ctx->strp;\n\n#ifdef CONFIG_TLS_DEVICE\n\tDEBUG_NET_WARN_ON_ONCE(!strp->anchor->decrypted);\n#else\n\t \n\tWARN_ON(1);\n#endif\n\n\tif (strp->copy_mode) {\n\t\tstruct sk_buff *skb;\n\n\t\t \n\t\tskb = alloc_skb(0, strp->sk->sk_allocation);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\tswap(strp->anchor, skb);\n\t\treturn skb;\n\t}\n\n\treturn tls_strp_msg_make_copy(strp);\n}\n\n \nint tls_strp_msg_cow(struct tls_sw_context_rx *ctx)\n{\n\tstruct tls_strparser *strp = &ctx->strp;\n\tstruct sk_buff *skb;\n\n\tif (strp->copy_mode)\n\t\treturn 0;\n\n\tskb = tls_strp_msg_make_copy(strp);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\ttls_strp_anchor_free(strp);\n\tstrp->anchor = skb;\n\n\ttcp_read_done(strp->sk, strp->stm.full_len);\n\tstrp->copy_mode = 1;\n\n\treturn 0;\n}\n\n \nint tls_strp_msg_hold(struct tls_strparser *strp, struct sk_buff_head *dst)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(strp->anchor);\n\n\tif (strp->copy_mode) {\n\t\tstruct sk_buff *skb;\n\n\t\tWARN_ON_ONCE(!shinfo->nr_frags);\n\n\t\t \n\t\tskb = alloc_skb(0, strp->sk->sk_allocation);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\t__skb_queue_tail(dst, strp->anchor);\n\t\tstrp->anchor = skb;\n\t} else {\n\t\tstruct sk_buff *iter, *clone;\n\t\tint chunk, len, offset;\n\n\t\toffset = strp->stm.offset;\n\t\tlen = strp->stm.full_len;\n\t\titer = shinfo->frag_list;\n\n\t\twhile (len > 0) {\n\t\t\tif (iter->len <= offset) {\n\t\t\t\toffset -= iter->len;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tchunk = iter->len - offset;\n\t\t\toffset = 0;\n\n\t\t\tclone = skb_clone(iter, strp->sk->sk_allocation);\n\t\t\tif (!clone)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__skb_queue_tail(dst, clone);\n\n\t\t\tlen -= chunk;\nnext:\n\t\t\titer = iter->next;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tls_strp_flush_anchor_copy(struct tls_strparser *strp)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(strp->anchor);\n\tint i;\n\n\tDEBUG_NET_WARN_ON_ONCE(atomic_read(&shinfo->dataref) != 1);\n\n\tfor (i = 0; i < shinfo->nr_frags; i++)\n\t\t__skb_frag_unref(&shinfo->frags[i], false);\n\tshinfo->nr_frags = 0;\n\tif (strp->copy_mode) {\n\t\tkfree_skb_list(shinfo->frag_list);\n\t\tshinfo->frag_list = NULL;\n\t}\n\tstrp->copy_mode = 0;\n\tstrp->mixed_decrypted = 0;\n}\n\nstatic int tls_strp_copyin_frag(struct tls_strparser *strp, struct sk_buff *skb,\n\t\t\t\tstruct sk_buff *in_skb, unsigned int offset,\n\t\t\t\tsize_t in_len)\n{\n\tsize_t len, chunk;\n\tskb_frag_t *frag;\n\tint sz;\n\n\tfrag = &skb_shinfo(skb)->frags[skb->len / PAGE_SIZE];\n\n\tlen = in_len;\n\t \n\tif (!strp->stm.full_len) {\n\t\t \n\t\tchunk =\tmin_t(size_t, len, PAGE_SIZE - skb_frag_size(frag));\n\t\tWARN_ON_ONCE(skb_copy_bits(in_skb, offset,\n\t\t\t\t\t   skb_frag_address(frag) +\n\t\t\t\t\t   skb_frag_size(frag),\n\t\t\t\t\t   chunk));\n\n\t\tskb->len += chunk;\n\t\tskb->data_len += chunk;\n\t\tskb_frag_size_add(frag, chunk);\n\n\t\tsz = tls_rx_msg_size(strp, skb);\n\t\tif (sz < 0)\n\t\t\treturn sz;\n\n\t\t \n\t\tif (unlikely(sz && sz < skb->len)) {\n\t\t\tint over = skb->len - sz;\n\n\t\t\tWARN_ON_ONCE(over > chunk);\n\t\t\tskb->len -= over;\n\t\t\tskb->data_len -= over;\n\t\t\tskb_frag_size_add(frag, -over);\n\n\t\t\tchunk -= over;\n\t\t}\n\n\t\tfrag++;\n\t\tlen -= chunk;\n\t\toffset += chunk;\n\n\t\tstrp->stm.full_len = sz;\n\t\tif (!strp->stm.full_len)\n\t\t\tgoto read_done;\n\t}\n\n\t \n\twhile (len && strp->stm.full_len > skb->len) {\n\t\tchunk =\tmin_t(size_t, len, strp->stm.full_len - skb->len);\n\t\tchunk = min_t(size_t, chunk, PAGE_SIZE - skb_frag_size(frag));\n\t\tWARN_ON_ONCE(skb_copy_bits(in_skb, offset,\n\t\t\t\t\t   skb_frag_address(frag) +\n\t\t\t\t\t   skb_frag_size(frag),\n\t\t\t\t\t   chunk));\n\n\t\tskb->len += chunk;\n\t\tskb->data_len += chunk;\n\t\tskb_frag_size_add(frag, chunk);\n\t\tfrag++;\n\t\tlen -= chunk;\n\t\toffset += chunk;\n\t}\n\nread_done:\n\treturn in_len - len;\n}\n\nstatic int tls_strp_copyin_skb(struct tls_strparser *strp, struct sk_buff *skb,\n\t\t\t       struct sk_buff *in_skb, unsigned int offset,\n\t\t\t       size_t in_len)\n{\n\tstruct sk_buff *nskb, *first, *last;\n\tstruct skb_shared_info *shinfo;\n\tsize_t chunk;\n\tint sz;\n\n\tif (strp->stm.full_len)\n\t\tchunk = strp->stm.full_len - skb->len;\n\telse\n\t\tchunk = TLS_MAX_PAYLOAD_SIZE + PAGE_SIZE;\n\tchunk = min(chunk, in_len);\n\n\tnskb = tls_strp_skb_copy(strp, in_skb, offset, chunk);\n\tif (!nskb)\n\t\treturn -ENOMEM;\n\n\tshinfo = skb_shinfo(skb);\n\tif (!shinfo->frag_list) {\n\t\tshinfo->frag_list = nskb;\n\t\tnskb->prev = nskb;\n\t} else {\n\t\tfirst = shinfo->frag_list;\n\t\tlast = first->prev;\n\t\tlast->next = nskb;\n\t\tfirst->prev = nskb;\n\t}\n\n\tskb->len += chunk;\n\tskb->data_len += chunk;\n\n\tif (!strp->stm.full_len) {\n\t\tsz = tls_rx_msg_size(strp, skb);\n\t\tif (sz < 0)\n\t\t\treturn sz;\n\n\t\t \n\t\tif (unlikely(sz && sz < skb->len)) {\n\t\t\tint over = skb->len - sz;\n\n\t\t\tWARN_ON_ONCE(over > chunk);\n\t\t\tskb->len -= over;\n\t\t\tskb->data_len -= over;\n\t\t\t__pskb_trim(nskb, nskb->len - over);\n\n\t\t\tchunk -= over;\n\t\t}\n\n\t\tstrp->stm.full_len = sz;\n\t}\n\n\treturn chunk;\n}\n\nstatic int tls_strp_copyin(read_descriptor_t *desc, struct sk_buff *in_skb,\n\t\t\t   unsigned int offset, size_t in_len)\n{\n\tstruct tls_strparser *strp = (struct tls_strparser *)desc->arg.data;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tif (strp->msg_ready)\n\t\treturn 0;\n\n\tskb = strp->anchor;\n\tif (!skb->len)\n\t\tskb_copy_decrypted(skb, in_skb);\n\telse\n\t\tstrp->mixed_decrypted |= !!skb_cmp_decrypted(skb, in_skb);\n\n\tif (IS_ENABLED(CONFIG_TLS_DEVICE) && strp->mixed_decrypted)\n\t\tret = tls_strp_copyin_skb(strp, skb, in_skb, offset, in_len);\n\telse\n\t\tret = tls_strp_copyin_frag(strp, skb, in_skb, offset, in_len);\n\tif (ret < 0) {\n\t\tdesc->error = ret;\n\t\tret = 0;\n\t}\n\n\tif (strp->stm.full_len && strp->stm.full_len == skb->len) {\n\t\tdesc->count = 0;\n\n\t\tstrp->msg_ready = 1;\n\t\ttls_rx_msg_ready(strp);\n\t}\n\n\treturn ret;\n}\n\nstatic int tls_strp_read_copyin(struct tls_strparser *strp)\n{\n\tread_descriptor_t desc;\n\n\tdesc.arg.data = strp;\n\tdesc.error = 0;\n\tdesc.count = 1;  \n\n\t \n\ttcp_read_sock(strp->sk, &desc, tls_strp_copyin);\n\n\treturn desc.error;\n}\n\nstatic int tls_strp_read_copy(struct tls_strparser *strp, bool qshort)\n{\n\tstruct skb_shared_info *shinfo;\n\tstruct page *page;\n\tint need_spc, len;\n\n\t \n\tif (likely(qshort && !tcp_epollin_ready(strp->sk, INT_MAX)))\n\t\treturn 0;\n\n\tshinfo = skb_shinfo(strp->anchor);\n\tshinfo->frag_list = NULL;\n\n\t \n\tneed_spc = strp->stm.full_len ?: TLS_MAX_PAYLOAD_SIZE + PAGE_SIZE;\n\n\tfor (len = need_spc; len > 0; len -= PAGE_SIZE) {\n\t\tpage = alloc_page(strp->sk->sk_allocation);\n\t\tif (!page) {\n\t\t\ttls_strp_flush_anchor_copy(strp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_fill_page_desc(strp->anchor, shinfo->nr_frags++,\n\t\t\t\t   page, 0, 0);\n\t}\n\n\tstrp->copy_mode = 1;\n\tstrp->stm.offset = 0;\n\n\tstrp->anchor->len = 0;\n\tstrp->anchor->data_len = 0;\n\tstrp->anchor->truesize = round_up(need_spc, PAGE_SIZE);\n\n\ttls_strp_read_copyin(strp);\n\n\treturn 0;\n}\n\nstatic bool tls_strp_check_queue_ok(struct tls_strparser *strp)\n{\n\tunsigned int len = strp->stm.offset + strp->stm.full_len;\n\tstruct sk_buff *first, *skb;\n\tu32 seq;\n\n\tfirst = skb_shinfo(strp->anchor)->frag_list;\n\tskb = first;\n\tseq = TCP_SKB_CB(first)->seq;\n\n\t \n\twhile (skb->len < len) {\n\t\tseq += skb->len;\n\t\tlen -= skb->len;\n\t\tskb = skb->next;\n\n\t\tif (TCP_SKB_CB(skb)->seq != seq)\n\t\t\treturn false;\n\t\tif (skb_cmp_decrypted(first, skb))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void tls_strp_load_anchor_with_queue(struct tls_strparser *strp, int len)\n{\n\tstruct tcp_sock *tp = tcp_sk(strp->sk);\n\tstruct sk_buff *first;\n\tu32 offset;\n\n\tfirst = tcp_recv_skb(strp->sk, tp->copied_seq, &offset);\n\tif (WARN_ON_ONCE(!first))\n\t\treturn;\n\n\t \n\tstrp->anchor->len = offset + len;\n\tstrp->anchor->data_len = offset + len;\n\tstrp->anchor->truesize = offset + len;\n\n\tskb_shinfo(strp->anchor)->frag_list = first;\n\n\tskb_copy_header(strp->anchor, first);\n\tstrp->anchor->destructor = NULL;\n\n\tstrp->stm.offset = offset;\n}\n\nvoid tls_strp_msg_load(struct tls_strparser *strp, bool force_refresh)\n{\n\tstruct strp_msg *rxm;\n\tstruct tls_msg *tlm;\n\n\tDEBUG_NET_WARN_ON_ONCE(!strp->msg_ready);\n\tDEBUG_NET_WARN_ON_ONCE(!strp->stm.full_len);\n\n\tif (!strp->copy_mode && force_refresh) {\n\t\tif (WARN_ON(tcp_inq(strp->sk) < strp->stm.full_len))\n\t\t\treturn;\n\n\t\ttls_strp_load_anchor_with_queue(strp, strp->stm.full_len);\n\t}\n\n\trxm = strp_msg(strp->anchor);\n\trxm->full_len\t= strp->stm.full_len;\n\trxm->offset\t= strp->stm.offset;\n\ttlm = tls_msg(strp->anchor);\n\ttlm->control\t= strp->mark;\n}\n\n \nstatic int tls_strp_read_sock(struct tls_strparser *strp)\n{\n\tint sz, inq;\n\n\tinq = tcp_inq(strp->sk);\n\tif (inq < 1)\n\t\treturn 0;\n\n\tif (unlikely(strp->copy_mode))\n\t\treturn tls_strp_read_copyin(strp);\n\n\tif (inq < strp->stm.full_len)\n\t\treturn tls_strp_read_copy(strp, true);\n\n\tif (!strp->stm.full_len) {\n\t\ttls_strp_load_anchor_with_queue(strp, inq);\n\n\t\tsz = tls_rx_msg_size(strp, strp->anchor);\n\t\tif (sz < 0) {\n\t\t\ttls_strp_abort_strp(strp, sz);\n\t\t\treturn sz;\n\t\t}\n\n\t\tstrp->stm.full_len = sz;\n\n\t\tif (!strp->stm.full_len || inq < strp->stm.full_len)\n\t\t\treturn tls_strp_read_copy(strp, true);\n\t}\n\n\tif (!tls_strp_check_queue_ok(strp))\n\t\treturn tls_strp_read_copy(strp, false);\n\n\tstrp->msg_ready = 1;\n\ttls_rx_msg_ready(strp);\n\n\treturn 0;\n}\n\nvoid tls_strp_check_rcv(struct tls_strparser *strp)\n{\n\tif (unlikely(strp->stopped) || strp->msg_ready)\n\t\treturn;\n\n\tif (tls_strp_read_sock(strp) == -ENOMEM)\n\t\tqueue_work(tls_strp_wq, &strp->work);\n}\n\n \nvoid tls_strp_data_ready(struct tls_strparser *strp)\n{\n\t \n\tif (sock_owned_by_user_nocheck(strp->sk)) {\n\t\tqueue_work(tls_strp_wq, &strp->work);\n\t\treturn;\n\t}\n\n\ttls_strp_check_rcv(strp);\n}\n\nstatic void tls_strp_work(struct work_struct *w)\n{\n\tstruct tls_strparser *strp =\n\t\tcontainer_of(w, struct tls_strparser, work);\n\n\tlock_sock(strp->sk);\n\ttls_strp_check_rcv(strp);\n\trelease_sock(strp->sk);\n}\n\nvoid tls_strp_msg_done(struct tls_strparser *strp)\n{\n\tWARN_ON(!strp->stm.full_len);\n\n\tif (likely(!strp->copy_mode))\n\t\ttcp_read_done(strp->sk, strp->stm.full_len);\n\telse\n\t\ttls_strp_flush_anchor_copy(strp);\n\n\tstrp->msg_ready = 0;\n\tmemset(&strp->stm, 0, sizeof(strp->stm));\n\n\ttls_strp_check_rcv(strp);\n}\n\nvoid tls_strp_stop(struct tls_strparser *strp)\n{\n\tstrp->stopped = 1;\n}\n\nint tls_strp_init(struct tls_strparser *strp, struct sock *sk)\n{\n\tmemset(strp, 0, sizeof(*strp));\n\n\tstrp->sk = sk;\n\n\tstrp->anchor = alloc_skb(0, GFP_KERNEL);\n\tif (!strp->anchor)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&strp->work, tls_strp_work);\n\n\treturn 0;\n}\n\n \nvoid tls_strp_done(struct tls_strparser *strp)\n{\n\tWARN_ON(!strp->stopped);\n\n\tcancel_work_sync(&strp->work);\n\ttls_strp_anchor_free(strp);\n}\n\nint __init tls_strp_dev_init(void)\n{\n\ttls_strp_wq = create_workqueue(\"tls-strp\");\n\tif (unlikely(!tls_strp_wq))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid tls_strp_dev_exit(void)\n{\n\tdestroy_workqueue(tls_strp_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}