{
  "module_name": "tls_main.c",
  "hash_id": "9861ae14b54b4e83980c184b8eae3992824ab1c4ba4bf2edd38e9f3f96c04169",
  "original_prompt": "Ingested from linux-6.6.14/net/tls/tls_main.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <net/tcp.h>\n#include <net/inet_common.h>\n#include <linux/highmem.h>\n#include <linux/netdevice.h>\n#include <linux/sched/signal.h>\n#include <linux/inetdevice.h>\n#include <linux/inet_diag.h>\n\n#include <net/snmp.h>\n#include <net/tls.h>\n#include <net/tls_toe.h>\n\n#include \"tls.h\"\n\nMODULE_AUTHOR(\"Mellanox Technologies\");\nMODULE_DESCRIPTION(\"Transport Layer Security Support\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS_TCP_ULP(\"tls\");\n\nenum {\n\tTLSV4,\n\tTLSV6,\n\tTLS_NUM_PROTS,\n};\n\n#define CHECK_CIPHER_DESC(cipher,ci)\t\t\t\t\\\n\tstatic_assert(cipher ## _IV_SIZE <= MAX_IV_SIZE);\t\t\\\n\tstatic_assert(cipher ## _REC_SEQ_SIZE <= TLS_MAX_REC_SEQ_SIZE);\t\\\n\tstatic_assert(cipher ## _TAG_SIZE == TLS_TAG_SIZE);\t\t\\\n\tstatic_assert(sizeof_field(struct ci, iv) == cipher ## _IV_SIZE);\t\\\n\tstatic_assert(sizeof_field(struct ci, key) == cipher ## _KEY_SIZE);\t\\\n\tstatic_assert(sizeof_field(struct ci, salt) == cipher ## _SALT_SIZE);\t\\\n\tstatic_assert(sizeof_field(struct ci, rec_seq) == cipher ## _REC_SEQ_SIZE);\n\n#define __CIPHER_DESC(ci) \\\n\t.iv_offset = offsetof(struct ci, iv), \\\n\t.key_offset = offsetof(struct ci, key), \\\n\t.salt_offset = offsetof(struct ci, salt), \\\n\t.rec_seq_offset = offsetof(struct ci, rec_seq), \\\n\t.crypto_info = sizeof(struct ci)\n\n#define CIPHER_DESC(cipher,ci,algname,_offloadable) [cipher - TLS_CIPHER_MIN] = {\t\\\n\t.nonce = cipher ## _IV_SIZE, \\\n\t.iv = cipher ## _IV_SIZE, \\\n\t.key = cipher ## _KEY_SIZE, \\\n\t.salt = cipher ## _SALT_SIZE, \\\n\t.tag = cipher ## _TAG_SIZE, \\\n\t.rec_seq = cipher ## _REC_SEQ_SIZE, \\\n\t.cipher_name = algname,\t\\\n\t.offloadable = _offloadable, \\\n\t__CIPHER_DESC(ci), \\\n}\n\n#define CIPHER_DESC_NONCE0(cipher,ci,algname,_offloadable) [cipher - TLS_CIPHER_MIN] = { \\\n\t.nonce = 0, \\\n\t.iv = cipher ## _IV_SIZE, \\\n\t.key = cipher ## _KEY_SIZE, \\\n\t.salt = cipher ## _SALT_SIZE, \\\n\t.tag = cipher ## _TAG_SIZE, \\\n\t.rec_seq = cipher ## _REC_SEQ_SIZE, \\\n\t.cipher_name = algname,\t\\\n\t.offloadable = _offloadable, \\\n\t__CIPHER_DESC(ci), \\\n}\n\nconst struct tls_cipher_desc tls_cipher_desc[TLS_CIPHER_MAX + 1 - TLS_CIPHER_MIN] = {\n\tCIPHER_DESC(TLS_CIPHER_AES_GCM_128, tls12_crypto_info_aes_gcm_128, \"gcm(aes)\", true),\n\tCIPHER_DESC(TLS_CIPHER_AES_GCM_256, tls12_crypto_info_aes_gcm_256, \"gcm(aes)\", true),\n\tCIPHER_DESC(TLS_CIPHER_AES_CCM_128, tls12_crypto_info_aes_ccm_128, \"ccm(aes)\", false),\n\tCIPHER_DESC_NONCE0(TLS_CIPHER_CHACHA20_POLY1305, tls12_crypto_info_chacha20_poly1305, \"rfc7539(chacha20,poly1305)\", false),\n\tCIPHER_DESC(TLS_CIPHER_SM4_GCM, tls12_crypto_info_sm4_gcm, \"gcm(sm4)\", false),\n\tCIPHER_DESC(TLS_CIPHER_SM4_CCM, tls12_crypto_info_sm4_ccm, \"ccm(sm4)\", false),\n\tCIPHER_DESC(TLS_CIPHER_ARIA_GCM_128, tls12_crypto_info_aria_gcm_128, \"gcm(aria)\", false),\n\tCIPHER_DESC(TLS_CIPHER_ARIA_GCM_256, tls12_crypto_info_aria_gcm_256, \"gcm(aria)\", false),\n};\n\nCHECK_CIPHER_DESC(TLS_CIPHER_AES_GCM_128, tls12_crypto_info_aes_gcm_128);\nCHECK_CIPHER_DESC(TLS_CIPHER_AES_GCM_256, tls12_crypto_info_aes_gcm_256);\nCHECK_CIPHER_DESC(TLS_CIPHER_AES_CCM_128, tls12_crypto_info_aes_ccm_128);\nCHECK_CIPHER_DESC(TLS_CIPHER_CHACHA20_POLY1305, tls12_crypto_info_chacha20_poly1305);\nCHECK_CIPHER_DESC(TLS_CIPHER_SM4_GCM, tls12_crypto_info_sm4_gcm);\nCHECK_CIPHER_DESC(TLS_CIPHER_SM4_CCM, tls12_crypto_info_sm4_ccm);\nCHECK_CIPHER_DESC(TLS_CIPHER_ARIA_GCM_128, tls12_crypto_info_aria_gcm_128);\nCHECK_CIPHER_DESC(TLS_CIPHER_ARIA_GCM_256, tls12_crypto_info_aria_gcm_256);\n\nstatic const struct proto *saved_tcpv6_prot;\nstatic DEFINE_MUTEX(tcpv6_prot_mutex);\nstatic const struct proto *saved_tcpv4_prot;\nstatic DEFINE_MUTEX(tcpv4_prot_mutex);\nstatic struct proto tls_prots[TLS_NUM_PROTS][TLS_NUM_CONFIG][TLS_NUM_CONFIG];\nstatic struct proto_ops tls_proto_ops[TLS_NUM_PROTS][TLS_NUM_CONFIG][TLS_NUM_CONFIG];\nstatic void build_protos(struct proto prot[TLS_NUM_CONFIG][TLS_NUM_CONFIG],\n\t\t\t const struct proto *base);\n\nvoid update_sk_prot(struct sock *sk, struct tls_context *ctx)\n{\n\tint ip_ver = sk->sk_family == AF_INET6 ? TLSV6 : TLSV4;\n\n\tWRITE_ONCE(sk->sk_prot,\n\t\t   &tls_prots[ip_ver][ctx->tx_conf][ctx->rx_conf]);\n\tWRITE_ONCE(sk->sk_socket->ops,\n\t\t   &tls_proto_ops[ip_ver][ctx->tx_conf][ctx->rx_conf]);\n}\n\nint wait_on_pending_writer(struct sock *sk, long *timeo)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint ret, rc = 0;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (!*timeo) {\n\t\t\trc = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\trc = sock_intr_errno(*timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = sk_wait_event(sk, timeo,\n\t\t\t\t    !READ_ONCE(sk->sk_write_pending), &wait);\n\t\tif (ret) {\n\t\t\tif (ret < 0)\n\t\t\t\trc = ret;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\n\nint tls_push_sg(struct sock *sk,\n\t\tstruct tls_context *ctx,\n\t\tstruct scatterlist *sg,\n\t\tu16 first_offset,\n\t\tint flags)\n{\n\tstruct bio_vec bvec;\n\tstruct msghdr msg = {\n\t\t.msg_flags = MSG_SPLICE_PAGES | flags,\n\t};\n\tint ret = 0;\n\tstruct page *p;\n\tsize_t size;\n\tint offset = first_offset;\n\n\tsize = sg->length - offset;\n\toffset += sg->offset;\n\n\tctx->splicing_pages = true;\n\twhile (1) {\n\t\t \n\t\ttcp_rate_check_app_limited(sk);\n\t\tp = sg_page(sg);\nretry:\n\t\tbvec_set_page(&bvec, p, size, offset);\n\t\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, &bvec, 1, size);\n\n\t\tret = tcp_sendmsg_locked(sk, &msg, size);\n\n\t\tif (ret != size) {\n\t\t\tif (ret > 0) {\n\t\t\t\toffset += ret;\n\t\t\t\tsize -= ret;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\toffset -= sg->offset;\n\t\t\tctx->partially_sent_offset = offset;\n\t\t\tctx->partially_sent_record = (void *)sg;\n\t\t\tctx->splicing_pages = false;\n\t\t\treturn ret;\n\t\t}\n\n\t\tput_page(p);\n\t\tsk_mem_uncharge(sk, sg->length);\n\t\tsg = sg_next(sg);\n\t\tif (!sg)\n\t\t\tbreak;\n\n\t\toffset = sg->offset;\n\t\tsize = sg->length;\n\t}\n\n\tctx->splicing_pages = false;\n\n\treturn 0;\n}\n\nstatic int tls_handle_open_record(struct sock *sk, int flags)\n{\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\n\tif (tls_is_pending_open_record(ctx))\n\t\treturn ctx->push_pending_record(sk, flags);\n\n\treturn 0;\n}\n\nint tls_process_cmsg(struct sock *sk, struct msghdr *msg,\n\t\t     unsigned char *record_type)\n{\n\tstruct cmsghdr *cmsg;\n\tint rc = -EINVAL;\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\treturn -EINVAL;\n\t\tif (cmsg->cmsg_level != SOL_TLS)\n\t\t\tcontinue;\n\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase TLS_SET_RECORD_TYPE:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(*record_type)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (msg->msg_flags & MSG_MORE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\trc = tls_handle_open_record(sk, msg->msg_flags);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t*record_type = *(unsigned char *)CMSG_DATA(cmsg);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nint tls_push_partial_record(struct sock *sk, struct tls_context *ctx,\n\t\t\t    int flags)\n{\n\tstruct scatterlist *sg;\n\tu16 offset;\n\n\tsg = ctx->partially_sent_record;\n\toffset = ctx->partially_sent_offset;\n\n\tctx->partially_sent_record = NULL;\n\treturn tls_push_sg(sk, ctx, sg, offset, flags);\n}\n\nvoid tls_free_partial_record(struct sock *sk, struct tls_context *ctx)\n{\n\tstruct scatterlist *sg;\n\n\tfor (sg = ctx->partially_sent_record; sg; sg = sg_next(sg)) {\n\t\tput_page(sg_page(sg));\n\t\tsk_mem_uncharge(sk, sg->length);\n\t}\n\tctx->partially_sent_record = NULL;\n}\n\nstatic void tls_write_space(struct sock *sk)\n{\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\n\t \n\tif (ctx->splicing_pages) {\n\t\tctx->sk_write_space(sk);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_TLS_DEVICE\n\tif (ctx->tx_conf == TLS_HW)\n\t\ttls_device_write_space(sk, ctx);\n\telse\n#endif\n\t\ttls_sw_write_space(sk, ctx);\n\n\tctx->sk_write_space(sk);\n}\n\n \nvoid tls_ctx_free(struct sock *sk, struct tls_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tmemzero_explicit(&ctx->crypto_send, sizeof(ctx->crypto_send));\n\tmemzero_explicit(&ctx->crypto_recv, sizeof(ctx->crypto_recv));\n\tmutex_destroy(&ctx->tx_lock);\n\n\tif (sk)\n\t\tkfree_rcu(ctx, rcu);\n\telse\n\t\tkfree(ctx);\n}\n\nstatic void tls_sk_proto_cleanup(struct sock *sk,\n\t\t\t\t struct tls_context *ctx, long timeo)\n{\n\tif (unlikely(sk->sk_write_pending) &&\n\t    !wait_on_pending_writer(sk, &timeo))\n\t\ttls_handle_open_record(sk, 0);\n\n\t \n\tif (ctx->tx_conf == TLS_SW) {\n\t\tkfree(ctx->tx.rec_seq);\n\t\tkfree(ctx->tx.iv);\n\t\ttls_sw_release_resources_tx(sk);\n\t\tTLS_DEC_STATS(sock_net(sk), LINUX_MIB_TLSCURRTXSW);\n\t} else if (ctx->tx_conf == TLS_HW) {\n\t\ttls_device_free_resources_tx(sk);\n\t\tTLS_DEC_STATS(sock_net(sk), LINUX_MIB_TLSCURRTXDEVICE);\n\t}\n\n\tif (ctx->rx_conf == TLS_SW) {\n\t\ttls_sw_release_resources_rx(sk);\n\t\tTLS_DEC_STATS(sock_net(sk), LINUX_MIB_TLSCURRRXSW);\n\t} else if (ctx->rx_conf == TLS_HW) {\n\t\ttls_device_offload_cleanup_rx(sk);\n\t\tTLS_DEC_STATS(sock_net(sk), LINUX_MIB_TLSCURRRXDEVICE);\n\t}\n}\n\nstatic void tls_sk_proto_close(struct sock *sk, long timeout)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tlong timeo = sock_sndtimeo(sk, 0);\n\tbool free_ctx;\n\n\tif (ctx->tx_conf == TLS_SW)\n\t\ttls_sw_cancel_work_tx(ctx);\n\n\tlock_sock(sk);\n\tfree_ctx = ctx->tx_conf != TLS_HW && ctx->rx_conf != TLS_HW;\n\n\tif (ctx->tx_conf != TLS_BASE || ctx->rx_conf != TLS_BASE)\n\t\ttls_sk_proto_cleanup(sk, ctx, timeo);\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tif (free_ctx)\n\t\trcu_assign_pointer(icsk->icsk_ulp_data, NULL);\n\tWRITE_ONCE(sk->sk_prot, ctx->sk_proto);\n\tif (sk->sk_write_space == tls_write_space)\n\t\tsk->sk_write_space = ctx->sk_write_space;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\trelease_sock(sk);\n\tif (ctx->tx_conf == TLS_SW)\n\t\ttls_sw_free_ctx_tx(ctx);\n\tif (ctx->rx_conf == TLS_SW || ctx->rx_conf == TLS_HW)\n\t\ttls_sw_strparser_done(ctx);\n\tif (ctx->rx_conf == TLS_SW)\n\t\ttls_sw_free_ctx_rx(ctx);\n\tctx->sk_proto->close(sk, timeout);\n\n\tif (free_ctx)\n\t\ttls_ctx_free(sk, ctx);\n}\n\nstatic __poll_t tls_sk_poll(struct file *file, struct socket *sock,\n\t\t\t    struct poll_table_struct *wait)\n{\n\tstruct tls_sw_context_rx *ctx;\n\tstruct tls_context *tls_ctx;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_psock *psock;\n\t__poll_t mask = 0;\n\tu8 shutdown;\n\tint state;\n\n\tmask = tcp_poll(file, sock, wait);\n\n\tstate = inet_sk_state_load(sk);\n\tshutdown = READ_ONCE(sk->sk_shutdown);\n\tif (unlikely(state != TCP_ESTABLISHED || shutdown & RCV_SHUTDOWN))\n\t\treturn mask;\n\n\ttls_ctx = tls_get_ctx(sk);\n\tctx = tls_sw_ctx_rx(tls_ctx);\n\tpsock = sk_psock_get(sk);\n\n\tif (skb_queue_empty_lockless(&ctx->rx_list) &&\n\t    !tls_strp_msg_ready(ctx) &&\n\t    sk_psock_queue_empty(psock))\n\t\tmask &= ~(EPOLLIN | EPOLLRDNORM);\n\n\tif (psock)\n\t\tsk_psock_put(sk, psock);\n\n\treturn mask;\n}\n\nstatic int do_tls_getsockopt_conf(struct sock *sk, char __user *optval,\n\t\t\t\t  int __user *optlen, int tx)\n{\n\tint rc = 0;\n\tconst struct tls_cipher_desc *cipher_desc;\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tstruct tls_crypto_info *crypto_info;\n\tstruct cipher_context *cctx;\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (!optval || (len < sizeof(*crypto_info))) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!ctx) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (tx) {\n\t\tcrypto_info = &ctx->crypto_send.info;\n\t\tcctx = &ctx->tx;\n\t} else {\n\t\tcrypto_info = &ctx->crypto_recv.info;\n\t\tcctx = &ctx->rx;\n\t}\n\n\tif (!TLS_CRYPTO_INFO_READY(crypto_info)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (len == sizeof(*crypto_info)) {\n\t\tif (copy_to_user(optval, crypto_info, sizeof(*crypto_info)))\n\t\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tcipher_desc = get_cipher_desc(crypto_info->cipher_type);\n\tif (!cipher_desc || len != cipher_desc->crypto_info) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(crypto_info_iv(crypto_info, cipher_desc),\n\t       cctx->iv + cipher_desc->salt, cipher_desc->iv);\n\tmemcpy(crypto_info_rec_seq(crypto_info, cipher_desc),\n\t       cctx->rec_seq, cipher_desc->rec_seq);\n\n\tif (copy_to_user(optval, crypto_info, cipher_desc->crypto_info))\n\t\trc = -EFAULT;\n\nout:\n\treturn rc;\n}\n\nstatic int do_tls_getsockopt_tx_zc(struct sock *sk, char __user *optval,\n\t\t\t\t   int __user *optlen)\n{\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tunsigned int value;\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(value))\n\t\treturn -EINVAL;\n\n\tvalue = ctx->zerocopy_sendfile;\n\tif (copy_to_user(optval, &value, sizeof(value)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int do_tls_getsockopt_no_pad(struct sock *sk, char __user *optval,\n\t\t\t\t    int __user *optlen)\n{\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tint value, len;\n\n\tif (ctx->prot_info.version != TLS_1_3_VERSION)\n\t\treturn -EINVAL;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < sizeof(value))\n\t\treturn -EINVAL;\n\n\tvalue = -EINVAL;\n\tif (ctx->rx_conf == TLS_SW || ctx->rx_conf == TLS_HW)\n\t\tvalue = ctx->rx_no_pad;\n\tif (value < 0)\n\t\treturn value;\n\n\tif (put_user(sizeof(value), optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &value, sizeof(value)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int do_tls_getsockopt(struct sock *sk, int optname,\n\t\t\t     char __user *optval, int __user *optlen)\n{\n\tint rc = 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase TLS_TX:\n\tcase TLS_RX:\n\t\trc = do_tls_getsockopt_conf(sk, optval, optlen,\n\t\t\t\t\t    optname == TLS_TX);\n\t\tbreak;\n\tcase TLS_TX_ZEROCOPY_RO:\n\t\trc = do_tls_getsockopt_tx_zc(sk, optval, optlen);\n\t\tbreak;\n\tcase TLS_RX_EXPECT_NO_PAD:\n\t\trc = do_tls_getsockopt_no_pad(sk, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int tls_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\n\tif (level != SOL_TLS)\n\t\treturn ctx->sk_proto->getsockopt(sk, level,\n\t\t\t\t\t\t optname, optval, optlen);\n\n\treturn do_tls_getsockopt(sk, optname, optval, optlen);\n}\n\nstatic int do_tls_setsockopt_conf(struct sock *sk, sockptr_t optval,\n\t\t\t\t  unsigned int optlen, int tx)\n{\n\tstruct tls_crypto_info *crypto_info;\n\tstruct tls_crypto_info *alt_crypto_info;\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tconst struct tls_cipher_desc *cipher_desc;\n\tint rc = 0;\n\tint conf;\n\n\tif (sockptr_is_null(optval) || (optlen < sizeof(*crypto_info)))\n\t\treturn -EINVAL;\n\n\tif (tx) {\n\t\tcrypto_info = &ctx->crypto_send.info;\n\t\talt_crypto_info = &ctx->crypto_recv.info;\n\t} else {\n\t\tcrypto_info = &ctx->crypto_recv.info;\n\t\talt_crypto_info = &ctx->crypto_send.info;\n\t}\n\n\t \n\tif (TLS_CRYPTO_INFO_READY(crypto_info))\n\t\treturn -EBUSY;\n\n\trc = copy_from_sockptr(crypto_info, optval, sizeof(*crypto_info));\n\tif (rc) {\n\t\trc = -EFAULT;\n\t\tgoto err_crypto_info;\n\t}\n\n\t \n\tif (crypto_info->version != TLS_1_2_VERSION &&\n\t    crypto_info->version != TLS_1_3_VERSION) {\n\t\trc = -EINVAL;\n\t\tgoto err_crypto_info;\n\t}\n\n\t \n\tif (TLS_CRYPTO_INFO_READY(alt_crypto_info)) {\n\t\tif (alt_crypto_info->version != crypto_info->version ||\n\t\t    alt_crypto_info->cipher_type != crypto_info->cipher_type) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_crypto_info;\n\t\t}\n\t}\n\n\tcipher_desc = get_cipher_desc(crypto_info->cipher_type);\n\tif (!cipher_desc) {\n\t\trc = -EINVAL;\n\t\tgoto err_crypto_info;\n\t}\n\n\tswitch (crypto_info->cipher_type) {\n\tcase TLS_CIPHER_ARIA_GCM_128:\n\tcase TLS_CIPHER_ARIA_GCM_256:\n\t\tif (crypto_info->version != TLS_1_2_VERSION) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_crypto_info;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (optlen != cipher_desc->crypto_info) {\n\t\trc = -EINVAL;\n\t\tgoto err_crypto_info;\n\t}\n\n\trc = copy_from_sockptr_offset(crypto_info + 1, optval,\n\t\t\t\t      sizeof(*crypto_info),\n\t\t\t\t      optlen - sizeof(*crypto_info));\n\tif (rc) {\n\t\trc = -EFAULT;\n\t\tgoto err_crypto_info;\n\t}\n\n\tif (tx) {\n\t\trc = tls_set_device_offload(sk, ctx);\n\t\tconf = TLS_HW;\n\t\tif (!rc) {\n\t\t\tTLS_INC_STATS(sock_net(sk), LINUX_MIB_TLSTXDEVICE);\n\t\t\tTLS_INC_STATS(sock_net(sk), LINUX_MIB_TLSCURRTXDEVICE);\n\t\t} else {\n\t\t\trc = tls_set_sw_offload(sk, ctx, 1);\n\t\t\tif (rc)\n\t\t\t\tgoto err_crypto_info;\n\t\t\tTLS_INC_STATS(sock_net(sk), LINUX_MIB_TLSTXSW);\n\t\t\tTLS_INC_STATS(sock_net(sk), LINUX_MIB_TLSCURRTXSW);\n\t\t\tconf = TLS_SW;\n\t\t}\n\t} else {\n\t\trc = tls_set_device_offload_rx(sk, ctx);\n\t\tconf = TLS_HW;\n\t\tif (!rc) {\n\t\t\tTLS_INC_STATS(sock_net(sk), LINUX_MIB_TLSRXDEVICE);\n\t\t\tTLS_INC_STATS(sock_net(sk), LINUX_MIB_TLSCURRRXDEVICE);\n\t\t} else {\n\t\t\trc = tls_set_sw_offload(sk, ctx, 0);\n\t\t\tif (rc)\n\t\t\t\tgoto err_crypto_info;\n\t\t\tTLS_INC_STATS(sock_net(sk), LINUX_MIB_TLSRXSW);\n\t\t\tTLS_INC_STATS(sock_net(sk), LINUX_MIB_TLSCURRRXSW);\n\t\t\tconf = TLS_SW;\n\t\t}\n\t\ttls_sw_strparser_arm(sk, ctx);\n\t}\n\n\tif (tx)\n\t\tctx->tx_conf = conf;\n\telse\n\t\tctx->rx_conf = conf;\n\tupdate_sk_prot(sk, ctx);\n\tif (tx) {\n\t\tctx->sk_write_space = sk->sk_write_space;\n\t\tsk->sk_write_space = tls_write_space;\n\t} else {\n\t\tstruct tls_sw_context_rx *rx_ctx = tls_sw_ctx_rx(ctx);\n\n\t\ttls_strp_check_rcv(&rx_ctx->strp);\n\t}\n\treturn 0;\n\nerr_crypto_info:\n\tmemzero_explicit(crypto_info, sizeof(union tls_crypto_context));\n\treturn rc;\n}\n\nstatic int do_tls_setsockopt_tx_zc(struct sock *sk, sockptr_t optval,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tunsigned int value;\n\n\tif (sockptr_is_null(optval) || optlen != sizeof(value))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&value, optval, sizeof(value)))\n\t\treturn -EFAULT;\n\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tctx->zerocopy_sendfile = value;\n\n\treturn 0;\n}\n\nstatic int do_tls_setsockopt_no_pad(struct sock *sk, sockptr_t optval,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tu32 val;\n\tint rc;\n\n\tif (ctx->prot_info.version != TLS_1_3_VERSION ||\n\t    sockptr_is_null(optval) || optlen < sizeof(val))\n\t\treturn -EINVAL;\n\n\trc = copy_from_sockptr(&val, optval, sizeof(val));\n\tif (rc)\n\t\treturn -EFAULT;\n\tif (val > 1)\n\t\treturn -EINVAL;\n\trc = check_zeroed_sockptr(optval, sizeof(val), optlen - sizeof(val));\n\tif (rc < 1)\n\t\treturn rc == 0 ? -EINVAL : rc;\n\n\tlock_sock(sk);\n\trc = -EINVAL;\n\tif (ctx->rx_conf == TLS_SW || ctx->rx_conf == TLS_HW) {\n\t\tctx->rx_no_pad = val;\n\t\ttls_update_rx_zc_capable(ctx);\n\t\trc = 0;\n\t}\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int do_tls_setsockopt(struct sock *sk, int optname, sockptr_t optval,\n\t\t\t     unsigned int optlen)\n{\n\tint rc = 0;\n\n\tswitch (optname) {\n\tcase TLS_TX:\n\tcase TLS_RX:\n\t\tlock_sock(sk);\n\t\trc = do_tls_setsockopt_conf(sk, optval, optlen,\n\t\t\t\t\t    optname == TLS_TX);\n\t\trelease_sock(sk);\n\t\tbreak;\n\tcase TLS_TX_ZEROCOPY_RO:\n\t\tlock_sock(sk);\n\t\trc = do_tls_setsockopt_tx_zc(sk, optval, optlen);\n\t\trelease_sock(sk);\n\t\tbreak;\n\tcase TLS_RX_EXPECT_NO_PAD:\n\t\trc = do_tls_setsockopt_no_pad(sk, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic int tls_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\n\tif (level != SOL_TLS)\n\t\treturn ctx->sk_proto->setsockopt(sk, level, optname, optval,\n\t\t\t\t\t\t optlen);\n\n\treturn do_tls_setsockopt(sk, optname, optval, optlen);\n}\n\nstruct tls_context *tls_ctx_create(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tls_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tmutex_init(&ctx->tx_lock);\n\trcu_assign_pointer(icsk->icsk_ulp_data, ctx);\n\tctx->sk_proto = READ_ONCE(sk->sk_prot);\n\tctx->sk = sk;\n\treturn ctx;\n}\n\nstatic void build_proto_ops(struct proto_ops ops[TLS_NUM_CONFIG][TLS_NUM_CONFIG],\n\t\t\t    const struct proto_ops *base)\n{\n\tops[TLS_BASE][TLS_BASE] = *base;\n\n\tops[TLS_SW  ][TLS_BASE] = ops[TLS_BASE][TLS_BASE];\n\tops[TLS_SW  ][TLS_BASE].splice_eof\t= tls_sw_splice_eof;\n\n\tops[TLS_BASE][TLS_SW  ] = ops[TLS_BASE][TLS_BASE];\n\tops[TLS_BASE][TLS_SW  ].splice_read\t= tls_sw_splice_read;\n\tops[TLS_BASE][TLS_SW  ].poll\t\t= tls_sk_poll;\n\tops[TLS_BASE][TLS_SW  ].read_sock\t= tls_sw_read_sock;\n\n\tops[TLS_SW  ][TLS_SW  ] = ops[TLS_SW  ][TLS_BASE];\n\tops[TLS_SW  ][TLS_SW  ].splice_read\t= tls_sw_splice_read;\n\tops[TLS_SW  ][TLS_SW  ].poll\t\t= tls_sk_poll;\n\tops[TLS_SW  ][TLS_SW  ].read_sock\t= tls_sw_read_sock;\n\n#ifdef CONFIG_TLS_DEVICE\n\tops[TLS_HW  ][TLS_BASE] = ops[TLS_BASE][TLS_BASE];\n\n\tops[TLS_HW  ][TLS_SW  ] = ops[TLS_BASE][TLS_SW  ];\n\n\tops[TLS_BASE][TLS_HW  ] = ops[TLS_BASE][TLS_SW  ];\n\n\tops[TLS_SW  ][TLS_HW  ] = ops[TLS_SW  ][TLS_SW  ];\n\n\tops[TLS_HW  ][TLS_HW  ] = ops[TLS_HW  ][TLS_SW  ];\n#endif\n#ifdef CONFIG_TLS_TOE\n\tops[TLS_HW_RECORD][TLS_HW_RECORD] = *base;\n#endif\n}\n\nstatic void tls_build_proto(struct sock *sk)\n{\n\tint ip_ver = sk->sk_family == AF_INET6 ? TLSV6 : TLSV4;\n\tstruct proto *prot = READ_ONCE(sk->sk_prot);\n\n\t \n\tif (ip_ver == TLSV6 &&\n\t    unlikely(prot != smp_load_acquire(&saved_tcpv6_prot))) {\n\t\tmutex_lock(&tcpv6_prot_mutex);\n\t\tif (likely(prot != saved_tcpv6_prot)) {\n\t\t\tbuild_protos(tls_prots[TLSV6], prot);\n\t\t\tbuild_proto_ops(tls_proto_ops[TLSV6],\n\t\t\t\t\tsk->sk_socket->ops);\n\t\t\tsmp_store_release(&saved_tcpv6_prot, prot);\n\t\t}\n\t\tmutex_unlock(&tcpv6_prot_mutex);\n\t}\n\n\tif (ip_ver == TLSV4 &&\n\t    unlikely(prot != smp_load_acquire(&saved_tcpv4_prot))) {\n\t\tmutex_lock(&tcpv4_prot_mutex);\n\t\tif (likely(prot != saved_tcpv4_prot)) {\n\t\t\tbuild_protos(tls_prots[TLSV4], prot);\n\t\t\tbuild_proto_ops(tls_proto_ops[TLSV4],\n\t\t\t\t\tsk->sk_socket->ops);\n\t\t\tsmp_store_release(&saved_tcpv4_prot, prot);\n\t\t}\n\t\tmutex_unlock(&tcpv4_prot_mutex);\n\t}\n}\n\nstatic void build_protos(struct proto prot[TLS_NUM_CONFIG][TLS_NUM_CONFIG],\n\t\t\t const struct proto *base)\n{\n\tprot[TLS_BASE][TLS_BASE] = *base;\n\tprot[TLS_BASE][TLS_BASE].setsockopt\t= tls_setsockopt;\n\tprot[TLS_BASE][TLS_BASE].getsockopt\t= tls_getsockopt;\n\tprot[TLS_BASE][TLS_BASE].close\t\t= tls_sk_proto_close;\n\n\tprot[TLS_SW][TLS_BASE] = prot[TLS_BASE][TLS_BASE];\n\tprot[TLS_SW][TLS_BASE].sendmsg\t\t= tls_sw_sendmsg;\n\tprot[TLS_SW][TLS_BASE].splice_eof\t= tls_sw_splice_eof;\n\n\tprot[TLS_BASE][TLS_SW] = prot[TLS_BASE][TLS_BASE];\n\tprot[TLS_BASE][TLS_SW].recvmsg\t\t  = tls_sw_recvmsg;\n\tprot[TLS_BASE][TLS_SW].sock_is_readable   = tls_sw_sock_is_readable;\n\tprot[TLS_BASE][TLS_SW].close\t\t  = tls_sk_proto_close;\n\n\tprot[TLS_SW][TLS_SW] = prot[TLS_SW][TLS_BASE];\n\tprot[TLS_SW][TLS_SW].recvmsg\t\t= tls_sw_recvmsg;\n\tprot[TLS_SW][TLS_SW].sock_is_readable   = tls_sw_sock_is_readable;\n\tprot[TLS_SW][TLS_SW].close\t\t= tls_sk_proto_close;\n\n#ifdef CONFIG_TLS_DEVICE\n\tprot[TLS_HW][TLS_BASE] = prot[TLS_BASE][TLS_BASE];\n\tprot[TLS_HW][TLS_BASE].sendmsg\t\t= tls_device_sendmsg;\n\tprot[TLS_HW][TLS_BASE].splice_eof\t= tls_device_splice_eof;\n\n\tprot[TLS_HW][TLS_SW] = prot[TLS_BASE][TLS_SW];\n\tprot[TLS_HW][TLS_SW].sendmsg\t\t= tls_device_sendmsg;\n\tprot[TLS_HW][TLS_SW].splice_eof\t\t= tls_device_splice_eof;\n\n\tprot[TLS_BASE][TLS_HW] = prot[TLS_BASE][TLS_SW];\n\n\tprot[TLS_SW][TLS_HW] = prot[TLS_SW][TLS_SW];\n\n\tprot[TLS_HW][TLS_HW] = prot[TLS_HW][TLS_SW];\n#endif\n#ifdef CONFIG_TLS_TOE\n\tprot[TLS_HW_RECORD][TLS_HW_RECORD] = *base;\n\tprot[TLS_HW_RECORD][TLS_HW_RECORD].hash\t\t= tls_toe_hash;\n\tprot[TLS_HW_RECORD][TLS_HW_RECORD].unhash\t= tls_toe_unhash;\n#endif\n}\n\nstatic int tls_init(struct sock *sk)\n{\n\tstruct tls_context *ctx;\n\tint rc = 0;\n\n\ttls_build_proto(sk);\n\n#ifdef CONFIG_TLS_TOE\n\tif (tls_toe_bypass(sk))\n\t\treturn 0;\n#endif\n\n\t \n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\n\t \n\twrite_lock_bh(&sk->sk_callback_lock);\n\tctx = tls_ctx_create(sk);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tctx->tx_conf = TLS_BASE;\n\tctx->rx_conf = TLS_BASE;\n\tupdate_sk_prot(sk, ctx);\nout:\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\treturn rc;\n}\n\nstatic void tls_update(struct sock *sk, struct proto *p,\n\t\t       void (*write_space)(struct sock *sk))\n{\n\tstruct tls_context *ctx;\n\n\tWARN_ON_ONCE(sk->sk_prot == p);\n\n\tctx = tls_get_ctx(sk);\n\tif (likely(ctx)) {\n\t\tctx->sk_write_space = write_space;\n\t\tctx->sk_proto = p;\n\t} else {\n\t\t \n\t\tWRITE_ONCE(sk->sk_prot, p);\n\t\tsk->sk_write_space = write_space;\n\t}\n}\n\nstatic u16 tls_user_config(struct tls_context *ctx, bool tx)\n{\n\tu16 config = tx ? ctx->tx_conf : ctx->rx_conf;\n\n\tswitch (config) {\n\tcase TLS_BASE:\n\t\treturn TLS_CONF_BASE;\n\tcase TLS_SW:\n\t\treturn TLS_CONF_SW;\n\tcase TLS_HW:\n\t\treturn TLS_CONF_HW;\n\tcase TLS_HW_RECORD:\n\t\treturn TLS_CONF_HW_RECORD;\n\t}\n\treturn 0;\n}\n\nstatic int tls_get_info(const struct sock *sk, struct sk_buff *skb)\n{\n\tu16 version, cipher_type;\n\tstruct tls_context *ctx;\n\tstruct nlattr *start;\n\tint err;\n\n\tstart = nla_nest_start_noflag(skb, INET_ULP_INFO_TLS);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\trcu_read_lock();\n\tctx = rcu_dereference(inet_csk(sk)->icsk_ulp_data);\n\tif (!ctx) {\n\t\terr = 0;\n\t\tgoto nla_failure;\n\t}\n\tversion = ctx->prot_info.version;\n\tif (version) {\n\t\terr = nla_put_u16(skb, TLS_INFO_VERSION, version);\n\t\tif (err)\n\t\t\tgoto nla_failure;\n\t}\n\tcipher_type = ctx->prot_info.cipher_type;\n\tif (cipher_type) {\n\t\terr = nla_put_u16(skb, TLS_INFO_CIPHER, cipher_type);\n\t\tif (err)\n\t\t\tgoto nla_failure;\n\t}\n\terr = nla_put_u16(skb, TLS_INFO_TXCONF, tls_user_config(ctx, true));\n\tif (err)\n\t\tgoto nla_failure;\n\n\terr = nla_put_u16(skb, TLS_INFO_RXCONF, tls_user_config(ctx, false));\n\tif (err)\n\t\tgoto nla_failure;\n\n\tif (ctx->tx_conf == TLS_HW && ctx->zerocopy_sendfile) {\n\t\terr = nla_put_flag(skb, TLS_INFO_ZC_RO_TX);\n\t\tif (err)\n\t\t\tgoto nla_failure;\n\t}\n\tif (ctx->rx_no_pad) {\n\t\terr = nla_put_flag(skb, TLS_INFO_RX_NO_PAD);\n\t\tif (err)\n\t\t\tgoto nla_failure;\n\t}\n\n\trcu_read_unlock();\n\tnla_nest_end(skb, start);\n\treturn 0;\n\nnla_failure:\n\trcu_read_unlock();\n\tnla_nest_cancel(skb, start);\n\treturn err;\n}\n\nstatic size_t tls_get_info_size(const struct sock *sk)\n{\n\tsize_t size = 0;\n\n\tsize += nla_total_size(0) +\t\t \n\t\tnla_total_size(sizeof(u16)) +\t \n\t\tnla_total_size(sizeof(u16)) +\t \n\t\tnla_total_size(sizeof(u16)) +\t \n\t\tnla_total_size(sizeof(u16)) +\t \n\t\tnla_total_size(0) +\t\t \n\t\tnla_total_size(0) +\t\t \n\t\t0;\n\n\treturn size;\n}\n\nstatic int __net_init tls_init_net(struct net *net)\n{\n\tint err;\n\n\tnet->mib.tls_statistics = alloc_percpu(struct linux_tls_mib);\n\tif (!net->mib.tls_statistics)\n\t\treturn -ENOMEM;\n\n\terr = tls_proc_init(net);\n\tif (err)\n\t\tgoto err_free_stats;\n\n\treturn 0;\nerr_free_stats:\n\tfree_percpu(net->mib.tls_statistics);\n\treturn err;\n}\n\nstatic void __net_exit tls_exit_net(struct net *net)\n{\n\ttls_proc_fini(net);\n\tfree_percpu(net->mib.tls_statistics);\n}\n\nstatic struct pernet_operations tls_proc_ops = {\n\t.init = tls_init_net,\n\t.exit = tls_exit_net,\n};\n\nstatic struct tcp_ulp_ops tcp_tls_ulp_ops __read_mostly = {\n\t.name\t\t\t= \"tls\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.init\t\t\t= tls_init,\n\t.update\t\t\t= tls_update,\n\t.get_info\t\t= tls_get_info,\n\t.get_info_size\t\t= tls_get_info_size,\n};\n\nstatic int __init tls_register(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&tls_proc_ops);\n\tif (err)\n\t\treturn err;\n\n\terr = tls_strp_dev_init();\n\tif (err)\n\t\tgoto err_pernet;\n\n\terr = tls_device_init();\n\tif (err)\n\t\tgoto err_strp;\n\n\ttcp_register_ulp(&tcp_tls_ulp_ops);\n\n\treturn 0;\nerr_strp:\n\ttls_strp_dev_exit();\nerr_pernet:\n\tunregister_pernet_subsys(&tls_proc_ops);\n\treturn err;\n}\n\nstatic void __exit tls_unregister(void)\n{\n\ttcp_unregister_ulp(&tcp_tls_ulp_ops);\n\ttls_strp_dev_exit();\n\ttls_device_cleanup();\n\tunregister_pernet_subsys(&tls_proc_ops);\n}\n\nmodule_init(tls_register);\nmodule_exit(tls_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}