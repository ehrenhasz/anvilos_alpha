{
  "module_name": "tls_toe.c",
  "hash_id": "8dc0ccf434cd7a8422f7c51206d31384f37c20c53f7646454a9660d1604e1b9d",
  "original_prompt": "Ingested from linux-6.6.14/net/tls/tls_toe.c",
  "human_readable_source": " \n\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <net/inet_connection_sock.h>\n#include <net/tls.h>\n#include <net/tls_toe.h>\n\n#include \"tls.h\"\n\nstatic LIST_HEAD(device_list);\nstatic DEFINE_SPINLOCK(device_spinlock);\n\nstatic void tls_toe_sk_destruct(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\n\tctx->sk_destruct(sk);\n\t \n\trcu_assign_pointer(icsk->icsk_ulp_data, NULL);\n\ttls_ctx_free(sk, ctx);\n}\n\nint tls_toe_bypass(struct sock *sk)\n{\n\tstruct tls_toe_device *dev;\n\tstruct tls_context *ctx;\n\tint rc = 0;\n\n\tspin_lock_bh(&device_spinlock);\n\tlist_for_each_entry(dev, &device_list, dev_list) {\n\t\tif (dev->feature && dev->feature(dev)) {\n\t\t\tctx = tls_ctx_create(sk);\n\t\t\tif (!ctx)\n\t\t\t\tgoto out;\n\n\t\t\tctx->sk_destruct = sk->sk_destruct;\n\t\t\tsk->sk_destruct = tls_toe_sk_destruct;\n\t\t\tctx->rx_conf = TLS_HW_RECORD;\n\t\t\tctx->tx_conf = TLS_HW_RECORD;\n\t\t\tupdate_sk_prot(sk, ctx);\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tspin_unlock_bh(&device_spinlock);\n\treturn rc;\n}\n\nvoid tls_toe_unhash(struct sock *sk)\n{\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tstruct tls_toe_device *dev;\n\n\tspin_lock_bh(&device_spinlock);\n\tlist_for_each_entry(dev, &device_list, dev_list) {\n\t\tif (dev->unhash) {\n\t\t\tkref_get(&dev->kref);\n\t\t\tspin_unlock_bh(&device_spinlock);\n\t\t\tdev->unhash(dev, sk);\n\t\t\tkref_put(&dev->kref, dev->release);\n\t\t\tspin_lock_bh(&device_spinlock);\n\t\t}\n\t}\n\tspin_unlock_bh(&device_spinlock);\n\tctx->sk_proto->unhash(sk);\n}\n\nint tls_toe_hash(struct sock *sk)\n{\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tstruct tls_toe_device *dev;\n\tint err;\n\n\terr = ctx->sk_proto->hash(sk);\n\tspin_lock_bh(&device_spinlock);\n\tlist_for_each_entry(dev, &device_list, dev_list) {\n\t\tif (dev->hash) {\n\t\t\tkref_get(&dev->kref);\n\t\t\tspin_unlock_bh(&device_spinlock);\n\t\t\terr |= dev->hash(dev, sk);\n\t\t\tkref_put(&dev->kref, dev->release);\n\t\t\tspin_lock_bh(&device_spinlock);\n\t\t}\n\t}\n\tspin_unlock_bh(&device_spinlock);\n\n\tif (err)\n\t\ttls_toe_unhash(sk);\n\treturn err;\n}\n\nvoid tls_toe_register_device(struct tls_toe_device *device)\n{\n\tspin_lock_bh(&device_spinlock);\n\tlist_add_tail(&device->dev_list, &device_list);\n\tspin_unlock_bh(&device_spinlock);\n}\nEXPORT_SYMBOL(tls_toe_register_device);\n\nvoid tls_toe_unregister_device(struct tls_toe_device *device)\n{\n\tspin_lock_bh(&device_spinlock);\n\tlist_del(&device->dev_list);\n\tspin_unlock_bh(&device_spinlock);\n}\nEXPORT_SYMBOL(tls_toe_unregister_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}