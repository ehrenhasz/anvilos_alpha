{
  "module_name": "tls.h",
  "hash_id": "651cf7d7cc18266098c8e08ad3beadc1df7ba406fd950916f6df5e51acb7555d",
  "original_prompt": "Ingested from linux-6.6.14/net/tls/tls.h",
  "human_readable_source": " \n\n#ifndef _TLS_INT_H\n#define _TLS_INT_H\n\n#include <asm/byteorder.h>\n#include <linux/types.h>\n#include <linux/skmsg.h>\n#include <net/tls.h>\n#include <net/tls_prot.h>\n\n#define TLS_PAGE_ORDER\t(min_t(unsigned int, PAGE_ALLOC_COSTLY_ORDER,\t\\\n\t\t\t       TLS_MAX_PAYLOAD_SIZE >> PAGE_SHIFT))\n\n#define __TLS_INC_STATS(net, field)\t\t\t\t\\\n\t__SNMP_INC_STATS((net)->mib.tls_statistics, field)\n#define TLS_INC_STATS(net, field)\t\t\t\t\\\n\tSNMP_INC_STATS((net)->mib.tls_statistics, field)\n#define TLS_DEC_STATS(net, field)\t\t\t\t\\\n\tSNMP_DEC_STATS((net)->mib.tls_statistics, field)\n\nstruct tls_cipher_desc {\n\tunsigned int nonce;\n\tunsigned int iv;\n\tunsigned int key;\n\tunsigned int salt;\n\tunsigned int tag;\n\tunsigned int rec_seq;\n\tunsigned int iv_offset;\n\tunsigned int key_offset;\n\tunsigned int salt_offset;\n\tunsigned int rec_seq_offset;\n\tchar *cipher_name;\n\tbool offloadable;\n\tsize_t crypto_info;\n};\n\n#define TLS_CIPHER_MIN TLS_CIPHER_AES_GCM_128\n#define TLS_CIPHER_MAX TLS_CIPHER_ARIA_GCM_256\nextern const struct tls_cipher_desc tls_cipher_desc[TLS_CIPHER_MAX + 1 - TLS_CIPHER_MIN];\n\nstatic inline const struct tls_cipher_desc *get_cipher_desc(u16 cipher_type)\n{\n\tif (cipher_type < TLS_CIPHER_MIN || cipher_type > TLS_CIPHER_MAX)\n\t\treturn NULL;\n\n\treturn &tls_cipher_desc[cipher_type - TLS_CIPHER_MIN];\n}\n\nstatic inline char *crypto_info_iv(struct tls_crypto_info *crypto_info,\n\t\t\t\t   const struct tls_cipher_desc *cipher_desc)\n{\n\treturn (char *)crypto_info + cipher_desc->iv_offset;\n}\n\nstatic inline char *crypto_info_key(struct tls_crypto_info *crypto_info,\n\t\t\t\t    const struct tls_cipher_desc *cipher_desc)\n{\n\treturn (char *)crypto_info + cipher_desc->key_offset;\n}\n\nstatic inline char *crypto_info_salt(struct tls_crypto_info *crypto_info,\n\t\t\t\t     const struct tls_cipher_desc *cipher_desc)\n{\n\treturn (char *)crypto_info + cipher_desc->salt_offset;\n}\n\nstatic inline char *crypto_info_rec_seq(struct tls_crypto_info *crypto_info,\n\t\t\t\t\tconst struct tls_cipher_desc *cipher_desc)\n{\n\treturn (char *)crypto_info + cipher_desc->rec_seq_offset;\n}\n\n\n \nstruct tls_rec {\n\tstruct list_head list;\n\tint tx_ready;\n\tint tx_flags;\n\n\tstruct sk_msg msg_plaintext;\n\tstruct sk_msg msg_encrypted;\n\n\t \n\tstruct scatterlist sg_aead_in[2];\n\t \n\tstruct scatterlist sg_aead_out[2];\n\n\tchar content_type;\n\tstruct scatterlist sg_content_type;\n\n\tstruct sock *sk;\n\n\tchar aad_space[TLS_AAD_SPACE_SIZE];\n\tu8 iv_data[MAX_IV_SIZE];\n\tstruct aead_request aead_req;\n\tu8 aead_req_ctx[];\n};\n\nint __net_init tls_proc_init(struct net *net);\nvoid __net_exit tls_proc_fini(struct net *net);\n\nstruct tls_context *tls_ctx_create(struct sock *sk);\nvoid tls_ctx_free(struct sock *sk, struct tls_context *ctx);\nvoid update_sk_prot(struct sock *sk, struct tls_context *ctx);\n\nint wait_on_pending_writer(struct sock *sk, long *timeo);\nvoid tls_err_abort(struct sock *sk, int err);\n\nint tls_set_sw_offload(struct sock *sk, struct tls_context *ctx, int tx);\nvoid tls_update_rx_zc_capable(struct tls_context *tls_ctx);\nvoid tls_sw_strparser_arm(struct sock *sk, struct tls_context *ctx);\nvoid tls_sw_strparser_done(struct tls_context *tls_ctx);\nint tls_sw_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);\nvoid tls_sw_splice_eof(struct socket *sock);\nvoid tls_sw_cancel_work_tx(struct tls_context *tls_ctx);\nvoid tls_sw_release_resources_tx(struct sock *sk);\nvoid tls_sw_free_ctx_tx(struct tls_context *tls_ctx);\nvoid tls_sw_free_resources_rx(struct sock *sk);\nvoid tls_sw_release_resources_rx(struct sock *sk);\nvoid tls_sw_free_ctx_rx(struct tls_context *tls_ctx);\nint tls_sw_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t   int flags, int *addr_len);\nbool tls_sw_sock_is_readable(struct sock *sk);\nssize_t tls_sw_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\t   struct pipe_inode_info *pipe,\n\t\t\t   size_t len, unsigned int flags);\nint tls_sw_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t     sk_read_actor_t read_actor);\n\nint tls_device_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);\nvoid tls_device_splice_eof(struct socket *sock);\nint tls_tx_records(struct sock *sk, int flags);\n\nvoid tls_sw_write_space(struct sock *sk, struct tls_context *ctx);\nvoid tls_device_write_space(struct sock *sk, struct tls_context *ctx);\n\nint tls_process_cmsg(struct sock *sk, struct msghdr *msg,\n\t\t     unsigned char *record_type);\nint decrypt_skb(struct sock *sk, struct scatterlist *sgout);\n\nint tls_sw_fallback_init(struct sock *sk,\n\t\t\t struct tls_offload_context_tx *offload_ctx,\n\t\t\t struct tls_crypto_info *crypto_info);\n\nint tls_strp_dev_init(void);\nvoid tls_strp_dev_exit(void);\n\nvoid tls_strp_done(struct tls_strparser *strp);\nvoid tls_strp_stop(struct tls_strparser *strp);\nint tls_strp_init(struct tls_strparser *strp, struct sock *sk);\nvoid tls_strp_data_ready(struct tls_strparser *strp);\n\nvoid tls_strp_check_rcv(struct tls_strparser *strp);\nvoid tls_strp_msg_done(struct tls_strparser *strp);\n\nint tls_rx_msg_size(struct tls_strparser *strp, struct sk_buff *skb);\nvoid tls_rx_msg_ready(struct tls_strparser *strp);\n\nvoid tls_strp_msg_load(struct tls_strparser *strp, bool force_refresh);\nint tls_strp_msg_cow(struct tls_sw_context_rx *ctx);\nstruct sk_buff *tls_strp_msg_detach(struct tls_sw_context_rx *ctx);\nint tls_strp_msg_hold(struct tls_strparser *strp, struct sk_buff_head *dst);\n\nstatic inline struct tls_msg *tls_msg(struct sk_buff *skb)\n{\n\tstruct sk_skb_cb *scb = (struct sk_skb_cb *)skb->cb;\n\n\treturn &scb->tls;\n}\n\nstatic inline struct sk_buff *tls_strp_msg(struct tls_sw_context_rx *ctx)\n{\n\tDEBUG_NET_WARN_ON_ONCE(!ctx->strp.msg_ready || !ctx->strp.anchor->len);\n\treturn ctx->strp.anchor;\n}\n\nstatic inline bool tls_strp_msg_ready(struct tls_sw_context_rx *ctx)\n{\n\treturn ctx->strp.msg_ready;\n}\n\nstatic inline bool tls_strp_msg_mixed_decrypted(struct tls_sw_context_rx *ctx)\n{\n\treturn ctx->strp.mixed_decrypted;\n}\n\n#ifdef CONFIG_TLS_DEVICE\nint tls_device_init(void);\nvoid tls_device_cleanup(void);\nint tls_set_device_offload(struct sock *sk, struct tls_context *ctx);\nvoid tls_device_free_resources_tx(struct sock *sk);\nint tls_set_device_offload_rx(struct sock *sk, struct tls_context *ctx);\nvoid tls_device_offload_cleanup_rx(struct sock *sk);\nvoid tls_device_rx_resync_new_rec(struct sock *sk, u32 rcd_len, u32 seq);\nint tls_device_decrypted(struct sock *sk, struct tls_context *tls_ctx);\n#else\nstatic inline int tls_device_init(void) { return 0; }\nstatic inline void tls_device_cleanup(void) {}\n\nstatic inline int\ntls_set_device_offload(struct sock *sk, struct tls_context *ctx)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void tls_device_free_resources_tx(struct sock *sk) {}\n\nstatic inline int\ntls_set_device_offload_rx(struct sock *sk, struct tls_context *ctx)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void tls_device_offload_cleanup_rx(struct sock *sk) {}\nstatic inline void\ntls_device_rx_resync_new_rec(struct sock *sk, u32 rcd_len, u32 seq) {}\n\nstatic inline int\ntls_device_decrypted(struct sock *sk, struct tls_context *tls_ctx)\n{\n\treturn 0;\n}\n#endif\n\nint tls_push_sg(struct sock *sk, struct tls_context *ctx,\n\t\tstruct scatterlist *sg, u16 first_offset,\n\t\tint flags);\nint tls_push_partial_record(struct sock *sk, struct tls_context *ctx,\n\t\t\t    int flags);\nvoid tls_free_partial_record(struct sock *sk, struct tls_context *ctx);\n\nstatic inline bool tls_is_partially_sent_record(struct tls_context *ctx)\n{\n\treturn !!ctx->partially_sent_record;\n}\n\nstatic inline bool tls_is_pending_open_record(struct tls_context *tls_ctx)\n{\n\treturn tls_ctx->pending_open_record_frags;\n}\n\nstatic inline bool tls_bigint_increment(unsigned char *seq, int len)\n{\n\tint i;\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\t++seq[i];\n\t\tif (seq[i] != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (i == -1);\n}\n\nstatic inline void tls_bigint_subtract(unsigned char *seq, int  n)\n{\n\tu64 rcd_sn;\n\t__be64 *p;\n\n\tBUILD_BUG_ON(TLS_MAX_REC_SEQ_SIZE != 8);\n\n\tp = (__be64 *)seq;\n\trcd_sn = be64_to_cpu(*p);\n\t*p = cpu_to_be64(rcd_sn - n);\n}\n\nstatic inline void\ntls_advance_record_sn(struct sock *sk, struct tls_prot_info *prot,\n\t\t      struct cipher_context *ctx)\n{\n\tif (tls_bigint_increment(ctx->rec_seq, prot->rec_seq_size))\n\t\ttls_err_abort(sk, -EBADMSG);\n\n\tif (prot->version != TLS_1_3_VERSION &&\n\t    prot->cipher_type != TLS_CIPHER_CHACHA20_POLY1305)\n\t\ttls_bigint_increment(ctx->iv + prot->salt_size,\n\t\t\t\t     prot->iv_size);\n}\n\nstatic inline void\ntls_xor_iv_with_seq(struct tls_prot_info *prot, char *iv, char *seq)\n{\n\tint i;\n\n\tif (prot->version == TLS_1_3_VERSION ||\n\t    prot->cipher_type == TLS_CIPHER_CHACHA20_POLY1305) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tiv[i + 4] ^= seq[i];\n\t}\n}\n\nstatic inline void\ntls_fill_prepend(struct tls_context *ctx, char *buf, size_t plaintext_len,\n\t\t unsigned char record_type)\n{\n\tstruct tls_prot_info *prot = &ctx->prot_info;\n\tsize_t pkt_len, iv_size = prot->iv_size;\n\n\tpkt_len = plaintext_len + prot->tag_size;\n\tif (prot->version != TLS_1_3_VERSION &&\n\t    prot->cipher_type != TLS_CIPHER_CHACHA20_POLY1305) {\n\t\tpkt_len += iv_size;\n\n\t\tmemcpy(buf + TLS_NONCE_OFFSET,\n\t\t       ctx->tx.iv + prot->salt_size, iv_size);\n\t}\n\n\t \n\tbuf[0] = prot->version == TLS_1_3_VERSION ?\n\t\t   TLS_RECORD_TYPE_DATA : record_type;\n\t \n\tbuf[1] = TLS_1_2_VERSION_MINOR;\n\tbuf[2] = TLS_1_2_VERSION_MAJOR;\n\t \n\tbuf[3] = pkt_len >> 8;\n\tbuf[4] = pkt_len & 0xFF;\n}\n\nstatic inline\nvoid tls_make_aad(char *buf, size_t size, char *record_sequence,\n\t\t  unsigned char record_type, struct tls_prot_info *prot)\n{\n\tif (prot->version != TLS_1_3_VERSION) {\n\t\tmemcpy(buf, record_sequence, prot->rec_seq_size);\n\t\tbuf += 8;\n\t} else {\n\t\tsize += prot->tag_size;\n\t}\n\n\tbuf[0] = prot->version == TLS_1_3_VERSION ?\n\t\t  TLS_RECORD_TYPE_DATA : record_type;\n\tbuf[1] = TLS_1_2_VERSION_MAJOR;\n\tbuf[2] = TLS_1_2_VERSION_MINOR;\n\tbuf[3] = size >> 8;\n\tbuf[4] = size & 0xFF;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}