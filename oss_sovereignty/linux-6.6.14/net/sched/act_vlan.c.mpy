{
  "module_name": "act_vlan.c",
  "hash_id": "c1ee8493b05931d26c4d2fc9f69edeef77b47d7f032f24b182c42b7a90f0dc11",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_vlan.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_vlan.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <net/tc_wrapper.h>\n\n#include <linux/tc_act/tc_vlan.h>\n#include <net/tc_act/tc_vlan.h>\n\nstatic struct tc_action_ops act_vlan_ops;\n\nTC_INDIRECT_SCOPE int tcf_vlan_act(struct sk_buff *skb,\n\t\t\t\t   const struct tc_action *a,\n\t\t\t\t   struct tcf_result *res)\n{\n\tstruct tcf_vlan *v = to_vlan(a);\n\tstruct tcf_vlan_params *p;\n\tint action;\n\tint err;\n\tu16 tci;\n\n\ttcf_lastuse_update(&v->tcf_tm);\n\ttcf_action_update_bstats(&v->common, skb);\n\n\t \n\tif (skb_at_tc_ingress(skb))\n\t\tskb_push_rcsum(skb, skb->mac_len);\n\n\taction = READ_ONCE(v->tcf_action);\n\n\tp = rcu_dereference_bh(v->vlan_p);\n\n\tswitch (p->tcfv_action) {\n\tcase TCA_VLAN_ACT_POP:\n\t\terr = skb_vlan_pop(skb);\n\t\tif (err)\n\t\t\tgoto drop;\n\t\tbreak;\n\tcase TCA_VLAN_ACT_PUSH:\n\t\terr = skb_vlan_push(skb, p->tcfv_push_proto, p->tcfv_push_vid |\n\t\t\t\t    (p->tcfv_push_prio << VLAN_PRIO_SHIFT));\n\t\tif (err)\n\t\t\tgoto drop;\n\t\tbreak;\n\tcase TCA_VLAN_ACT_MODIFY:\n\t\t \n\t\tif (!skb_vlan_tagged(skb))\n\t\t\tgoto out;\n\t\t \n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\ttci = skb_vlan_tag_get(skb);\n\t\t\t__vlan_hwaccel_clear_tag(skb);\n\t\t} else {\n\t\t\t \n\t\t\terr = __skb_vlan_pop(skb, &tci);\n\t\t\tif (err)\n\t\t\t\tgoto drop;\n\t\t}\n\t\t \n\t\ttci = (tci & ~VLAN_VID_MASK) | p->tcfv_push_vid;\n\t\t \n\t\tif (p->tcfv_push_prio_exists) {\n\t\t\ttci &= ~VLAN_PRIO_MASK;\n\t\t\ttci |= p->tcfv_push_prio << VLAN_PRIO_SHIFT;\n\t\t}\n\t\t \n\t\t__vlan_hwaccel_put_tag(skb, p->tcfv_push_proto, tci);\n\t\tbreak;\n\tcase TCA_VLAN_ACT_POP_ETH:\n\t\terr = skb_eth_pop(skb);\n\t\tif (err)\n\t\t\tgoto drop;\n\t\tbreak;\n\tcase TCA_VLAN_ACT_PUSH_ETH:\n\t\terr = skb_eth_push(skb, p->tcfv_push_dst, p->tcfv_push_src);\n\t\tif (err)\n\t\t\tgoto drop;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\nout:\n\tif (skb_at_tc_ingress(skb))\n\t\tskb_pull_rcsum(skb, skb->mac_len);\n\n\treturn action;\n\ndrop:\n\ttcf_action_inc_drop_qstats(&v->common);\n\treturn TC_ACT_SHOT;\n}\n\nstatic const struct nla_policy vlan_policy[TCA_VLAN_MAX + 1] = {\n\t[TCA_VLAN_UNSPEC]\t\t= { .strict_start_type = TCA_VLAN_PUSH_ETH_DST },\n\t[TCA_VLAN_PARMS]\t\t= { .len = sizeof(struct tc_vlan) },\n\t[TCA_VLAN_PUSH_VLAN_ID]\t\t= { .type = NLA_U16 },\n\t[TCA_VLAN_PUSH_VLAN_PROTOCOL]\t= { .type = NLA_U16 },\n\t[TCA_VLAN_PUSH_VLAN_PRIORITY]\t= { .type = NLA_U8 },\n\t[TCA_VLAN_PUSH_ETH_DST]\t\t= NLA_POLICY_ETH_ADDR,\n\t[TCA_VLAN_PUSH_ETH_SRC]\t\t= NLA_POLICY_ETH_ADDR,\n};\n\nstatic int tcf_vlan_init(struct net *net, struct nlattr *nla,\n\t\t\t struct nlattr *est, struct tc_action **a,\n\t\t\t struct tcf_proto *tp, u32 flags,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_vlan_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_VLAN_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tbool push_prio_exists = false;\n\tstruct tcf_vlan_params *p;\n\tstruct tc_vlan *parm;\n\tstruct tcf_vlan *v;\n\tint action;\n\tu16 push_vid = 0;\n\t__be16 push_proto = 0;\n\tu8 push_prio = 0;\n\tbool exists = false;\n\tint ret = 0, err;\n\tu32 index;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_VLAN_MAX, nla, vlan_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_VLAN_PARMS])\n\t\treturn -EINVAL;\n\tparm = nla_data(tb[TCA_VLAN_PARMS]);\n\tindex = parm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0)\n\t\treturn err;\n\texists = err;\n\tif (exists && bind)\n\t\treturn 0;\n\n\tswitch (parm->v_action) {\n\tcase TCA_VLAN_ACT_POP:\n\t\tbreak;\n\tcase TCA_VLAN_ACT_PUSH:\n\tcase TCA_VLAN_ACT_MODIFY:\n\t\tif (!tb[TCA_VLAN_PUSH_VLAN_ID]) {\n\t\t\tif (exists)\n\t\t\t\ttcf_idr_release(*a, bind);\n\t\t\telse\n\t\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpush_vid = nla_get_u16(tb[TCA_VLAN_PUSH_VLAN_ID]);\n\t\tif (push_vid >= VLAN_VID_MASK) {\n\t\t\tif (exists)\n\t\t\t\ttcf_idr_release(*a, bind);\n\t\t\telse\n\t\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tif (tb[TCA_VLAN_PUSH_VLAN_PROTOCOL]) {\n\t\t\tpush_proto = nla_get_be16(tb[TCA_VLAN_PUSH_VLAN_PROTOCOL]);\n\t\t\tswitch (push_proto) {\n\t\t\tcase htons(ETH_P_8021Q):\n\t\t\tcase htons(ETH_P_8021AD):\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (exists)\n\t\t\t\t\ttcf_idr_release(*a, bind);\n\t\t\t\telse\n\t\t\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\t\treturn -EPROTONOSUPPORT;\n\t\t\t}\n\t\t} else {\n\t\t\tpush_proto = htons(ETH_P_8021Q);\n\t\t}\n\n\t\tpush_prio_exists = !!tb[TCA_VLAN_PUSH_VLAN_PRIORITY];\n\t\tif (push_prio_exists)\n\t\t\tpush_prio = nla_get_u8(tb[TCA_VLAN_PUSH_VLAN_PRIORITY]);\n\t\tbreak;\n\tcase TCA_VLAN_ACT_POP_ETH:\n\t\tbreak;\n\tcase TCA_VLAN_ACT_PUSH_ETH:\n\t\tif (!tb[TCA_VLAN_PUSH_ETH_DST] || !tb[TCA_VLAN_PUSH_ETH_SRC]) {\n\t\t\tif (exists)\n\t\t\t\ttcf_idr_release(*a, bind);\n\t\t\telse\n\t\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (exists)\n\t\t\ttcf_idr_release(*a, bind);\n\t\telse\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\treturn -EINVAL;\n\t}\n\taction = parm->v_action;\n\n\tif (!exists) {\n\t\tret = tcf_idr_create_from_flags(tn, index, est, a,\n\t\t\t\t\t\t&act_vlan_ops, bind, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ACT_P_CREATED;\n\t} else if (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\ttcf_idr_release(*a, bind);\n\t\treturn -EEXIST;\n\t}\n\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\tv = to_vlan(*a);\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p) {\n\t\terr = -ENOMEM;\n\t\tgoto put_chain;\n\t}\n\n\tp->tcfv_action = action;\n\tp->tcfv_push_vid = push_vid;\n\tp->tcfv_push_prio = push_prio;\n\tp->tcfv_push_prio_exists = push_prio_exists || action == TCA_VLAN_ACT_PUSH;\n\tp->tcfv_push_proto = push_proto;\n\n\tif (action == TCA_VLAN_ACT_PUSH_ETH) {\n\t\tnla_memcpy(&p->tcfv_push_dst, tb[TCA_VLAN_PUSH_ETH_DST],\n\t\t\t   ETH_ALEN);\n\t\tnla_memcpy(&p->tcfv_push_src, tb[TCA_VLAN_PUSH_ETH_SRC],\n\t\t\t   ETH_ALEN);\n\t}\n\n\tspin_lock_bh(&v->tcf_lock);\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\tp = rcu_replace_pointer(v->vlan_p, p, lockdep_is_held(&v->tcf_lock));\n\tspin_unlock_bh(&v->tcf_lock);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\tif (p)\n\t\tkfree_rcu(p, rcu);\n\n\treturn ret;\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic void tcf_vlan_cleanup(struct tc_action *a)\n{\n\tstruct tcf_vlan *v = to_vlan(a);\n\tstruct tcf_vlan_params *p;\n\n\tp = rcu_dereference_protected(v->vlan_p, 1);\n\tif (p)\n\t\tkfree_rcu(p, rcu);\n}\n\nstatic int tcf_vlan_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_vlan *v = to_vlan(a);\n\tstruct tcf_vlan_params *p;\n\tstruct tc_vlan opt = {\n\t\t.index    = v->tcf_index,\n\t\t.refcnt   = refcount_read(&v->tcf_refcnt) - ref,\n\t\t.bindcnt  = atomic_read(&v->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&v->tcf_lock);\n\topt.action = v->tcf_action;\n\tp = rcu_dereference_protected(v->vlan_p, lockdep_is_held(&v->tcf_lock));\n\topt.v_action = p->tcfv_action;\n\tif (nla_put(skb, TCA_VLAN_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\tif ((p->tcfv_action == TCA_VLAN_ACT_PUSH ||\n\t     p->tcfv_action == TCA_VLAN_ACT_MODIFY) &&\n\t    (nla_put_u16(skb, TCA_VLAN_PUSH_VLAN_ID, p->tcfv_push_vid) ||\n\t     nla_put_be16(skb, TCA_VLAN_PUSH_VLAN_PROTOCOL,\n\t\t\t  p->tcfv_push_proto) ||\n\t     (p->tcfv_push_prio_exists &&\n\t      nla_put_u8(skb, TCA_VLAN_PUSH_VLAN_PRIORITY, p->tcfv_push_prio))))\n\t\tgoto nla_put_failure;\n\n\tif (p->tcfv_action == TCA_VLAN_ACT_PUSH_ETH) {\n\t\tif (nla_put(skb, TCA_VLAN_PUSH_ETH_DST, ETH_ALEN,\n\t\t\t    p->tcfv_push_dst))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put(skb, TCA_VLAN_PUSH_ETH_SRC, ETH_ALEN,\n\t\t\t    p->tcfv_push_src))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\ttcf_tm_dump(&t, &v->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_VLAN_TM, sizeof(t), &t, TCA_VLAN_PAD))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&v->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&v->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic void tcf_vlan_stats_update(struct tc_action *a, u64 bytes, u64 packets,\n\t\t\t\t  u64 drops, u64 lastuse, bool hw)\n{\n\tstruct tcf_vlan *v = to_vlan(a);\n\tstruct tcf_t *tm = &v->tcf_tm;\n\n\ttcf_action_update_stats(a, bytes, packets, drops, hw);\n\ttm->lastuse = max_t(u64, tm->lastuse, lastuse);\n}\n\nstatic size_t tcf_vlan_get_fill_size(const struct tc_action *act)\n{\n\treturn nla_total_size(sizeof(struct tc_vlan))\n\t\t+ nla_total_size(sizeof(u16))  \n\t\t+ nla_total_size(sizeof(u16))  \n\t\t+ nla_total_size(sizeof(u8));  \n}\n\nstatic int tcf_vlan_offload_act_setup(struct tc_action *act, void *entry_data,\n\t\t\t\t      u32 *index_inc, bool bind,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (bind) {\n\t\tstruct flow_action_entry *entry = entry_data;\n\n\t\tswitch (tcf_vlan_action(act)) {\n\t\tcase TCA_VLAN_ACT_PUSH:\n\t\t\tentry->id = FLOW_ACTION_VLAN_PUSH;\n\t\t\tentry->vlan.vid = tcf_vlan_push_vid(act);\n\t\t\tentry->vlan.proto = tcf_vlan_push_proto(act);\n\t\t\tentry->vlan.prio = tcf_vlan_push_prio(act);\n\t\t\tbreak;\n\t\tcase TCA_VLAN_ACT_POP:\n\t\t\tentry->id = FLOW_ACTION_VLAN_POP;\n\t\t\tbreak;\n\t\tcase TCA_VLAN_ACT_MODIFY:\n\t\t\tentry->id = FLOW_ACTION_VLAN_MANGLE;\n\t\t\tentry->vlan.vid = tcf_vlan_push_vid(act);\n\t\t\tentry->vlan.proto = tcf_vlan_push_proto(act);\n\t\t\tentry->vlan.prio = tcf_vlan_push_prio(act);\n\t\t\tbreak;\n\t\tcase TCA_VLAN_ACT_POP_ETH:\n\t\t\tentry->id = FLOW_ACTION_VLAN_POP_ETH;\n\t\t\tbreak;\n\t\tcase TCA_VLAN_ACT_PUSH_ETH:\n\t\t\tentry->id = FLOW_ACTION_VLAN_PUSH_ETH;\n\t\t\ttcf_vlan_push_eth(entry->vlan_push_eth.src, entry->vlan_push_eth.dst, act);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported vlan action mode offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t*index_inc = 1;\n\t} else {\n\t\tstruct flow_offload_action *fl_action = entry_data;\n\n\t\tswitch (tcf_vlan_action(act)) {\n\t\tcase TCA_VLAN_ACT_PUSH:\n\t\t\tfl_action->id = FLOW_ACTION_VLAN_PUSH;\n\t\t\tbreak;\n\t\tcase TCA_VLAN_ACT_POP:\n\t\t\tfl_action->id = FLOW_ACTION_VLAN_POP;\n\t\t\tbreak;\n\t\tcase TCA_VLAN_ACT_MODIFY:\n\t\t\tfl_action->id = FLOW_ACTION_VLAN_MANGLE;\n\t\t\tbreak;\n\t\tcase TCA_VLAN_ACT_POP_ETH:\n\t\t\tfl_action->id = FLOW_ACTION_VLAN_POP_ETH;\n\t\t\tbreak;\n\t\tcase TCA_VLAN_ACT_PUSH_ETH:\n\t\t\tfl_action->id = FLOW_ACTION_VLAN_PUSH_ETH;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct tc_action_ops act_vlan_ops = {\n\t.kind\t\t=\t\"vlan\",\n\t.id\t\t=\tTCA_ID_VLAN,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_vlan_act,\n\t.dump\t\t=\ttcf_vlan_dump,\n\t.init\t\t=\ttcf_vlan_init,\n\t.cleanup\t=\ttcf_vlan_cleanup,\n\t.stats_update\t=\ttcf_vlan_stats_update,\n\t.get_fill_size\t=\ttcf_vlan_get_fill_size,\n\t.offload_act_setup =\ttcf_vlan_offload_act_setup,\n\t.size\t\t=\tsizeof(struct tcf_vlan),\n};\n\nstatic __net_init int vlan_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_vlan_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_vlan_ops);\n}\n\nstatic void __net_exit vlan_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_vlan_ops.net_id);\n}\n\nstatic struct pernet_operations vlan_net_ops = {\n\t.init = vlan_init_net,\n\t.exit_batch = vlan_exit_net,\n\t.id   = &act_vlan_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nstatic int __init vlan_init_module(void)\n{\n\treturn tcf_register_action(&act_vlan_ops, &vlan_net_ops);\n}\n\nstatic void __exit vlan_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_vlan_ops, &vlan_net_ops);\n}\n\nmodule_init(vlan_init_module);\nmodule_exit(vlan_cleanup_module);\n\nMODULE_AUTHOR(\"Jiri Pirko <jiri@resnulli.us>\");\nMODULE_DESCRIPTION(\"vlan manipulation actions\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}