{
  "module_name": "sch_codel.c",
  "hash_id": "4e2ac160e5bad13c8a4d74ad3c9d40bb99b441b255da18773cd5be0655a82f65",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_codel.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/prefetch.h>\n#include <net/pkt_sched.h>\n#include <net/codel.h>\n#include <net/codel_impl.h>\n#include <net/codel_qdisc.h>\n\n\n#define DEFAULT_CODEL_LIMIT 1000\n\nstruct codel_sched_data {\n\tstruct codel_params\tparams;\n\tstruct codel_vars\tvars;\n\tstruct codel_stats\tstats;\n\tu32\t\t\tdrop_overlimit;\n};\n\n \nstatic struct sk_buff *dequeue_func(struct codel_vars *vars, void *ctx)\n{\n\tstruct Qdisc *sch = ctx;\n\tstruct sk_buff *skb = __qdisc_dequeue_head(&sch->q);\n\n\tif (skb) {\n\t\tsch->qstats.backlog -= qdisc_pkt_len(skb);\n\t\tprefetch(&skb->end);  \n\t}\n\treturn skb;\n}\n\nstatic void drop_func(struct sk_buff *skb, void *ctx)\n{\n\tstruct Qdisc *sch = ctx;\n\n\tkfree_skb(skb);\n\tqdisc_qstats_drop(sch);\n}\n\nstatic struct sk_buff *codel_qdisc_dequeue(struct Qdisc *sch)\n{\n\tstruct codel_sched_data *q = qdisc_priv(sch);\n\tstruct sk_buff *skb;\n\n\tskb = codel_dequeue(sch, &sch->qstats.backlog, &q->params, &q->vars,\n\t\t\t    &q->stats, qdisc_pkt_len, codel_get_enqueue_time,\n\t\t\t    drop_func, dequeue_func);\n\n\t \n\tif (q->stats.drop_count && sch->q.qlen) {\n\t\tqdisc_tree_reduce_backlog(sch, q->stats.drop_count, q->stats.drop_len);\n\t\tq->stats.drop_count = 0;\n\t\tq->stats.drop_len = 0;\n\t}\n\tif (skb)\n\t\tqdisc_bstats_update(sch, skb);\n\treturn skb;\n}\n\nstatic int codel_qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t       struct sk_buff **to_free)\n{\n\tstruct codel_sched_data *q;\n\n\tif (likely(qdisc_qlen(sch) < sch->limit)) {\n\t\tcodel_set_enqueue_time(skb);\n\t\treturn qdisc_enqueue_tail(skb, sch);\n\t}\n\tq = qdisc_priv(sch);\n\tq->drop_overlimit++;\n\treturn qdisc_drop(skb, sch, to_free);\n}\n\nstatic const struct nla_policy codel_policy[TCA_CODEL_MAX + 1] = {\n\t[TCA_CODEL_TARGET]\t= { .type = NLA_U32 },\n\t[TCA_CODEL_LIMIT]\t= { .type = NLA_U32 },\n\t[TCA_CODEL_INTERVAL]\t= { .type = NLA_U32 },\n\t[TCA_CODEL_ECN]\t\t= { .type = NLA_U32 },\n\t[TCA_CODEL_CE_THRESHOLD]= { .type = NLA_U32 },\n};\n\nstatic int codel_change(struct Qdisc *sch, struct nlattr *opt,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct codel_sched_data *q = qdisc_priv(sch);\n\tstruct nlattr *tb[TCA_CODEL_MAX + 1];\n\tunsigned int qlen, dropped = 0;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_CODEL_MAX, opt,\n\t\t\t\t\t  codel_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tsch_tree_lock(sch);\n\n\tif (tb[TCA_CODEL_TARGET]) {\n\t\tu32 target = nla_get_u32(tb[TCA_CODEL_TARGET]);\n\n\t\tq->params.target = ((u64)target * NSEC_PER_USEC) >> CODEL_SHIFT;\n\t}\n\n\tif (tb[TCA_CODEL_CE_THRESHOLD]) {\n\t\tu64 val = nla_get_u32(tb[TCA_CODEL_CE_THRESHOLD]);\n\n\t\tq->params.ce_threshold = (val * NSEC_PER_USEC) >> CODEL_SHIFT;\n\t}\n\n\tif (tb[TCA_CODEL_INTERVAL]) {\n\t\tu32 interval = nla_get_u32(tb[TCA_CODEL_INTERVAL]);\n\n\t\tq->params.interval = ((u64)interval * NSEC_PER_USEC) >> CODEL_SHIFT;\n\t}\n\n\tif (tb[TCA_CODEL_LIMIT])\n\t\tsch->limit = nla_get_u32(tb[TCA_CODEL_LIMIT]);\n\n\tif (tb[TCA_CODEL_ECN])\n\t\tq->params.ecn = !!nla_get_u32(tb[TCA_CODEL_ECN]);\n\n\tqlen = sch->q.qlen;\n\twhile (sch->q.qlen > sch->limit) {\n\t\tstruct sk_buff *skb = __qdisc_dequeue_head(&sch->q);\n\n\t\tdropped += qdisc_pkt_len(skb);\n\t\tqdisc_qstats_backlog_dec(sch, skb);\n\t\trtnl_qdisc_drop(skb, sch);\n\t}\n\tqdisc_tree_reduce_backlog(sch, qlen - sch->q.qlen, dropped);\n\n\tsch_tree_unlock(sch);\n\treturn 0;\n}\n\nstatic int codel_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct codel_sched_data *q = qdisc_priv(sch);\n\n\tsch->limit = DEFAULT_CODEL_LIMIT;\n\n\tcodel_params_init(&q->params);\n\tcodel_vars_init(&q->vars);\n\tcodel_stats_init(&q->stats);\n\tq->params.mtu = psched_mtu(qdisc_dev(sch));\n\n\tif (opt) {\n\t\tint err = codel_change(sch, opt, extack);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (sch->limit >= 1)\n\t\tsch->flags |= TCQ_F_CAN_BYPASS;\n\telse\n\t\tsch->flags &= ~TCQ_F_CAN_BYPASS;\n\n\treturn 0;\n}\n\nstatic int codel_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct codel_sched_data *q = qdisc_priv(sch);\n\tstruct nlattr *opts;\n\n\topts = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (opts == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, TCA_CODEL_TARGET,\n\t\t\tcodel_time_to_us(q->params.target)) ||\n\t    nla_put_u32(skb, TCA_CODEL_LIMIT,\n\t\t\tsch->limit) ||\n\t    nla_put_u32(skb, TCA_CODEL_INTERVAL,\n\t\t\tcodel_time_to_us(q->params.interval)) ||\n\t    nla_put_u32(skb, TCA_CODEL_ECN,\n\t\t\tq->params.ecn))\n\t\tgoto nla_put_failure;\n\tif (q->params.ce_threshold != CODEL_DISABLED_THRESHOLD &&\n\t    nla_put_u32(skb, TCA_CODEL_CE_THRESHOLD,\n\t\t\tcodel_time_to_us(q->params.ce_threshold)))\n\t\tgoto nla_put_failure;\n\treturn nla_nest_end(skb, opts);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, opts);\n\treturn -1;\n}\n\nstatic int codel_dump_stats(struct Qdisc *sch, struct gnet_dump *d)\n{\n\tconst struct codel_sched_data *q = qdisc_priv(sch);\n\tstruct tc_codel_xstats st = {\n\t\t.maxpacket\t= q->stats.maxpacket,\n\t\t.count\t\t= q->vars.count,\n\t\t.lastcount\t= q->vars.lastcount,\n\t\t.drop_overlimit = q->drop_overlimit,\n\t\t.ldelay\t\t= codel_time_to_us(q->vars.ldelay),\n\t\t.dropping\t= q->vars.dropping,\n\t\t.ecn_mark\t= q->stats.ecn_mark,\n\t\t.ce_mark\t= q->stats.ce_mark,\n\t};\n\n\tif (q->vars.dropping) {\n\t\tcodel_tdiff_t delta = q->vars.drop_next - codel_get_time();\n\n\t\tif (delta >= 0)\n\t\t\tst.drop_next = codel_time_to_us(delta);\n\t\telse\n\t\t\tst.drop_next = -codel_time_to_us(-delta);\n\t}\n\n\treturn gnet_stats_copy_app(d, &st, sizeof(st));\n}\n\nstatic void codel_reset(struct Qdisc *sch)\n{\n\tstruct codel_sched_data *q = qdisc_priv(sch);\n\n\tqdisc_reset_queue(sch);\n\tcodel_vars_init(&q->vars);\n}\n\nstatic struct Qdisc_ops codel_qdisc_ops __read_mostly = {\n\t.id\t\t=\t\"codel\",\n\t.priv_size\t=\tsizeof(struct codel_sched_data),\n\n\t.enqueue\t=\tcodel_qdisc_enqueue,\n\t.dequeue\t=\tcodel_qdisc_dequeue,\n\t.peek\t\t=\tqdisc_peek_dequeued,\n\t.init\t\t=\tcodel_init,\n\t.reset\t\t=\tcodel_reset,\n\t.change \t=\tcodel_change,\n\t.dump\t\t=\tcodel_dump,\n\t.dump_stats\t=\tcodel_dump_stats,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init codel_module_init(void)\n{\n\treturn register_qdisc(&codel_qdisc_ops);\n}\n\nstatic void __exit codel_module_exit(void)\n{\n\tunregister_qdisc(&codel_qdisc_ops);\n}\n\nmodule_init(codel_module_init)\nmodule_exit(codel_module_exit)\n\nMODULE_DESCRIPTION(\"Controlled Delay queue discipline\");\nMODULE_AUTHOR(\"Dave Taht\");\nMODULE_AUTHOR(\"Eric Dumazet\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}