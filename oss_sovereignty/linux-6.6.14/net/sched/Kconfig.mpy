{
  "module_name": "Kconfig",
  "hash_id": "0a8ab4a63cdf635d459d847f0a5f92b2e26e5703329ca5801aaca8b94de3bd5e",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Traffic control configuration.\n#\n\nmenuconfig NET_SCHED\n\tbool \"QoS and/or fair queueing\"\n\tselect NET_SCH_FIFO\n\thelp\n\t  When the kernel has several packets to send out over a network\n\t  device, it has to decide which ones to send first, which ones to\n\t  delay, and which ones to drop. This is the job of the queueing\n\t  disciplines, several different algorithms for how to do this\n\t  \"fairly\" have been proposed.\n\n\t  If you say N here, you will get the standard packet scheduler, which\n\t  is a FIFO (first come, first served). If you say Y here, you will be\n\t  able to choose from among several alternative algorithms which can\n\t  then be attached to different network devices. This is useful for\n\t  example if some of your network devices are real time devices that\n\t  need a certain minimum data flow rate, or if you need to limit the\n\t  maximum data flow rate for traffic which matches specified criteria.\n\t  This code is considered to be experimental.\n\n\t  To administer these schedulers, you'll need the user-level utilities\n\t  from the package iproute2+tc at\n\t  <https://www.kernel.org/pub/linux/utils/net/iproute2/>.  That package\n\t  also contains some documentation; for more, check out\n\t  <http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2>.\n\n\t  This Quality of Service (QoS) support will enable you to use\n\t  Differentiated Services (diffserv) and Resource Reservation Protocol\n\t  (RSVP) on your Linux router if you also say Y to the corresponding\n\t  classifiers below.  Documentation and software is at\n\t  <http://diffserv.sourceforge.net/>.\n\n\t  If you say Y here and to \"/proc file system\" below, you will be able\n\t  to read status information about packet schedulers from the file\n\t  /proc/net/psched.\n\n\t  The available schedulers are listed in the following questions; you\n\t  can say Y to as many as you like. If unsure, say N now.\n\nif NET_SCHED\n\ncomment \"Queueing/Scheduling\"\n\nconfig NET_SCH_HTB\n\ttristate \"Hierarchical Token Bucket (HTB)\"\n\thelp\n\t  Say Y here if you want to use the Hierarchical Token Buckets (HTB)\n\t  packet scheduling algorithm. See\n\t  <http://luxik.cdi.cz/~devik/qos/htb/> for complete manual and\n\t  in-depth articles.\n\n\t  HTB is very similar to CBQ regarding its goals however is has\n\t  different properties and different algorithm.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_htb.\n\nconfig NET_SCH_HFSC\n\ttristate \"Hierarchical Fair Service Curve (HFSC)\"\n\thelp\n\t  Say Y here if you want to use the Hierarchical Fair Service Curve\n\t  (HFSC) packet scheduling algorithm.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_hfsc.\n\nconfig NET_SCH_PRIO\n\ttristate \"Multi Band Priority Queueing (PRIO)\"\n\thelp\n\t  Say Y here if you want to use an n-band priority queue packet\n\t  scheduler.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_prio.\n\nconfig NET_SCH_MULTIQ\n\ttristate \"Hardware Multiqueue-aware Multi Band Queuing (MULTIQ)\"\n\thelp\n\t  Say Y here if you want to use an n-band queue packet scheduler\n\t  to support devices that have multiple hardware transmit queues.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_multiq.\n\nconfig NET_SCH_RED\n\ttristate \"Random Early Detection (RED)\"\n\thelp\n\t  Say Y here if you want to use the Random Early Detection (RED)\n\t  packet scheduling algorithm.\n\n\t  See the top of <file:net/sched/sch_red.c> for more details.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_red.\n\nconfig NET_SCH_SFB\n\ttristate \"Stochastic Fair Blue (SFB)\"\n\thelp\n\t  Say Y here if you want to use the Stochastic Fair Blue (SFB)\n\t  packet scheduling algorithm.\n\n\t  See the top of <file:net/sched/sch_sfb.c> for more details.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_sfb.\n\nconfig NET_SCH_SFQ\n\ttristate \"Stochastic Fairness Queueing (SFQ)\"\n\thelp\n\t  Say Y here if you want to use the Stochastic Fairness Queueing (SFQ)\n\t  packet scheduling algorithm.\n\n\t  See the top of <file:net/sched/sch_sfq.c> for more details.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_sfq.\n\nconfig NET_SCH_TEQL\n\ttristate \"True Link Equalizer (TEQL)\"\n\thelp\n\t  Say Y here if you want to use the True Link Equalizer (TLE) packet\n\t  scheduling algorithm. This queueing discipline allows the combination\n\t  of several physical devices into one virtual device.\n\n\t  See the top of <file:net/sched/sch_teql.c> for more details.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_teql.\n\nconfig NET_SCH_TBF\n\ttristate \"Token Bucket Filter (TBF)\"\n\thelp\n\t  Say Y here if you want to use the Token Bucket Filter (TBF) packet\n\t  scheduling algorithm.\n\n\t  See the top of <file:net/sched/sch_tbf.c> for more details.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_tbf.\n\nconfig NET_SCH_CBS\n\ttristate \"Credit Based Shaper (CBS)\"\n\thelp\n\t  Say Y here if you want to use the Credit Based Shaper (CBS) packet\n\t  scheduling algorithm.\n\n\t  See the top of <file:net/sched/sch_cbs.c> for more details.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_cbs.\n\nconfig NET_SCH_ETF\n\ttristate \"Earliest TxTime First (ETF)\"\n\thelp\n\t  Say Y here if you want to use the Earliest TxTime First (ETF) packet\n\t  scheduling algorithm.\n\n\t  See the top of <file:net/sched/sch_etf.c> for more details.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_etf.\n\nconfig NET_SCH_MQPRIO_LIB\n\ttristate\n\thelp\n\t  Common library for manipulating mqprio queue configurations.\n\nconfig NET_SCH_TAPRIO\n\ttristate \"Time Aware Priority (taprio) Scheduler\"\n\tselect NET_SCH_MQPRIO_LIB\n\thelp\n\t  Say Y here if you want to use the Time Aware Priority (taprio) packet\n\t  scheduling algorithm.\n\n\t  See the top of <file:net/sched/sch_taprio.c> for more details.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_taprio.\n\nconfig NET_SCH_GRED\n\ttristate \"Generic Random Early Detection (GRED)\"\n\thelp\n\t  Say Y here if you want to use the Generic Random Early Detection\n\t  (GRED) packet scheduling algorithm for some of your network devices\n\t  (see the top of <file:net/sched/sch_red.c> for details and\n\t  references about the algorithm).\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_gred.\n\nconfig NET_SCH_NETEM\n\ttristate \"Network emulator (NETEM)\"\n\thelp\n\t  Say Y if you want to emulate network delay, loss, and packet\n\t  re-ordering. This is often useful to simulate networks when\n\t  testing applications or protocols.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_netem.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_DRR\n\ttristate \"Deficit Round Robin scheduler (DRR)\"\n\thelp\n\t  Say Y here if you want to use the Deficit Round Robin (DRR) packet\n\t  scheduling algorithm.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_drr.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_MQPRIO\n\ttristate \"Multi-queue priority scheduler (MQPRIO)\"\n\tselect NET_SCH_MQPRIO_LIB\n\thelp\n\t  Say Y here if you want to use the Multi-queue Priority scheduler.\n\t  This scheduler allows QOS to be offloaded on NICs that have support\n\t  for offloading QOS schedulers.\n\n\t  To compile this driver as a module, choose M here: the module will\n\t  be called sch_mqprio.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_SKBPRIO\n\ttristate \"SKB priority queue scheduler (SKBPRIO)\"\n\thelp\n\t  Say Y here if you want to use the SKB priority queue\n\t  scheduler. This schedules packets according to skb->priority,\n\t  which is useful for request packets in DoS mitigation systems such\n\t  as Gatekeeper.\n\n\t  To compile this driver as a module, choose M here: the module will\n\t  be called sch_skbprio.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_CHOKE\n\ttristate \"CHOose and Keep responsive flow scheduler (CHOKE)\"\n\thelp\n\t  Say Y here if you want to use the CHOKe packet scheduler (CHOose\n\t  and Keep for responsive flows, CHOose and Kill for unresponsive\n\t  flows). This is a variation of RED which tries to penalize flows\n\t  that monopolize the queue.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_choke.\n\nconfig NET_SCH_QFQ\n\ttristate \"Quick Fair Queueing scheduler (QFQ)\"\n\thelp\n\t  Say Y here if you want to use the Quick Fair Queueing Scheduler (QFQ)\n\t  packet scheduling algorithm.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_qfq.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_CODEL\n\ttristate \"Controlled Delay AQM (CODEL)\"\n\thelp\n\t  Say Y here if you want to use the Controlled Delay (CODEL)\n\t  packet scheduling algorithm.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_codel.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_FQ_CODEL\n\ttristate \"Fair Queue Controlled Delay AQM (FQ_CODEL)\"\n\thelp\n\t  Say Y here if you want to use the FQ Controlled Delay (FQ_CODEL)\n\t  packet scheduling algorithm.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_fq_codel.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_CAKE\n\ttristate \"Common Applications Kept Enhanced (CAKE)\"\n\thelp\n\t  Say Y here if you want to use the Common Applications Kept Enhanced\n\t  (CAKE) queue management algorithm.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_cake.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_FQ\n\ttristate \"Fair Queue\"\n\thelp\n\t  Say Y here if you want to use the FQ packet scheduling algorithm.\n\n\t  FQ does flow separation, and is able to respect pacing requirements\n\t  set by TCP stack into sk->sk_pacing_rate (for locally generated\n\t  traffic)\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_fq.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_HHF\n\ttristate \"Heavy-Hitter Filter (HHF)\"\n\thelp\n\t  Say Y here if you want to use the Heavy-Hitter Filter (HHF)\n\t  packet scheduling algorithm.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_hhf.\n\nconfig NET_SCH_PIE\n\ttristate \"Proportional Integral controller Enhanced (PIE) scheduler\"\n\thelp\n\t  Say Y here if you want to use the Proportional Integral controller\n\t  Enhanced scheduler packet scheduling algorithm.\n\t  For more information, please see https://tools.ietf.org/html/rfc8033\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_pie.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_FQ_PIE\n\tdepends on NET_SCH_PIE\n\ttristate \"Flow Queue Proportional Integral controller Enhanced (FQ-PIE)\"\n\thelp\n\t  Say Y here if you want to use the Flow Queue Proportional Integral\n\t  controller Enhanced (FQ-PIE) packet scheduling algorithm.\n\t  For more information, please see https://tools.ietf.org/html/rfc8033\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_fq_pie.\n\n\t  If unsure, say N.\n\nconfig NET_SCH_INGRESS\n\ttristate \"Ingress/classifier-action Qdisc\"\n\tdepends on NET_CLS_ACT\n\tselect NET_XGRESS\n\thelp\n\t  Say Y here if you want to use classifiers for incoming and/or outgoing\n\t  packets. This qdisc doesn't do anything else besides running classifiers,\n\t  which can also have actions attached to them. In case of outgoing packets,\n\t  classifiers that this qdisc holds are executed in the transmit path\n\t  before real enqueuing to an egress qdisc happens.\n\n\t  If unsure, say Y.\n\n\t  To compile this code as a module, choose M here: the module will be\n\t  called sch_ingress with alias of sch_clsact.\n\nconfig NET_SCH_PLUG\n\ttristate \"Plug network traffic until release (PLUG)\"\n\thelp\n\n\t  This queuing discipline allows userspace to plug/unplug a network\n\t  output queue, using the netlink interface.  When it receives an\n\t  enqueue command it inserts a plug into the outbound queue that\n\t  causes following packets to enqueue until a dequeue command arrives\n\t  over netlink, causing the plug to be removed and resuming the normal\n\t  packet flow.\n\n\t  This module also provides a generic \"network output buffering\"\n\t  functionality (aka output commit), wherein upon arrival of a dequeue\n\t  command, only packets up to the first plug are released for delivery.\n\t  The Remus HA project uses this module to enable speculative execution\n\t  of virtual machines by allowing the generated network output to be rolled\n\t  back if needed.\n\n\t  For more information, please refer to <http://wiki.xenproject.org/wiki/Remus>\n\n\t  Say Y here if you are using this kernel for Xen dom0 and\n\t  want to protect Xen guests with Remus.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called sch_plug.\n\nconfig NET_SCH_ETS\n\ttristate \"Enhanced transmission selection scheduler (ETS)\"\n\thelp\n          The Enhanced Transmission Selection scheduler is a classful\n          queuing discipline that merges functionality of PRIO and DRR\n          qdiscs in one scheduler. ETS makes it easy to configure a set of\n          strict and bandwidth-sharing bands to implement the transmission\n          selection described in 802.1Qaz.\n\n\t  Say Y here if you want to use the ETS packet scheduling\n\t  algorithm.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called sch_ets.\n\n\t  If unsure, say N.\n\nmenuconfig NET_SCH_DEFAULT\n\tbool \"Allow override default queue discipline\"\n\thelp\n\t  Support for selection of default queuing discipline.\n\n\t  Nearly all users can safely say no here, and the default\n\t  of pfifo_fast will be used. Many distributions already set\n\t  the default value via /proc/sys/net/core/default_qdisc.\n\n\t  If unsure, say N.\n\nif NET_SCH_DEFAULT\n\nchoice\n\tprompt \"Default queuing discipline\"\n\tdefault DEFAULT_PFIFO_FAST\n\thelp\n\t  Select the queueing discipline that will be used by default\n\t  for all network devices.\n\n\tconfig DEFAULT_FQ\n\t\tbool \"Fair Queue\" if NET_SCH_FQ\n\n\tconfig DEFAULT_CODEL\n\t\tbool \"Controlled Delay\" if NET_SCH_CODEL\n\n\tconfig DEFAULT_FQ_CODEL\n\t\tbool \"Fair Queue Controlled Delay\" if NET_SCH_FQ_CODEL\n\n\tconfig DEFAULT_FQ_PIE\n\t\tbool \"Flow Queue Proportional Integral controller Enhanced\" if NET_SCH_FQ_PIE\n\n\tconfig DEFAULT_SFQ\n\t\tbool \"Stochastic Fair Queue\" if NET_SCH_SFQ\n\n\tconfig DEFAULT_PFIFO_FAST\n\t\tbool \"Priority FIFO Fast\"\nendchoice\n\nconfig DEFAULT_NET_SCH\n\tstring\n\tdefault \"pfifo_fast\" if DEFAULT_PFIFO_FAST\n\tdefault \"fq\" if DEFAULT_FQ\n\tdefault \"fq_codel\" if DEFAULT_FQ_CODEL\n\tdefault \"fq_pie\" if DEFAULT_FQ_PIE\n\tdefault \"sfq\" if DEFAULT_SFQ\n\tdefault \"pfifo_fast\"\nendif\n\ncomment \"Classification\"\n\nconfig NET_CLS\n\tbool\n\nconfig NET_CLS_BASIC\n\ttristate \"Elementary classification (BASIC)\"\n\tselect NET_CLS\n\thelp\n\t  Say Y here if you want to be able to classify packets using\n\t  only extended matches and actions.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called cls_basic.\n\nconfig NET_CLS_ROUTE4\n\ttristate \"Routing decision (ROUTE)\"\n\tdepends on INET\n\tselect IP_ROUTE_CLASSID\n\tselect NET_CLS\n\thelp\n\t  If you say Y here, you will be able to classify packets\n\t  according to the route table entry they matched.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called cls_route.\n\nconfig NET_CLS_FW\n\ttristate \"Netfilter mark (FW)\"\n\tselect NET_CLS\n\thelp\n\t  If you say Y here, you will be able to classify packets\n\t  according to netfilter/firewall marks.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called cls_fw.\n\nconfig NET_CLS_U32\n\ttristate \"Universal 32bit comparisons w/ hashing (U32)\"\n\tselect NET_CLS\n\thelp\n\t  Say Y here to be able to classify packets using a universal\n\t  32bit pieces based comparison scheme.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called cls_u32.\n\nconfig CLS_U32_PERF\n\tbool \"Performance counters support\"\n\tdepends on NET_CLS_U32\n\thelp\n\t  Say Y here to make u32 gather additional statistics useful for\n\t  fine tuning u32 classifiers.\n\nconfig CLS_U32_MARK\n\tbool \"Netfilter marks support\"\n\tdepends on NET_CLS_U32\n\thelp\n\t  Say Y here to be able to use netfilter marks as u32 key.\n\nconfig NET_CLS_FLOW\n\ttristate \"Flow classifier\"\n\tselect NET_CLS\n\thelp\n\t  If you say Y here, you will be able to classify packets based on\n\t  a configurable combination of packet keys. This is mostly useful\n\t  in combination with SFQ.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called cls_flow.\n\nconfig NET_CLS_CGROUP\n\ttristate \"Control Group Classifier\"\n\tselect NET_CLS\n\tselect CGROUP_NET_CLASSID\n\tdepends on CGROUPS\n\thelp\n\t  Say Y here if you want to classify packets based on the control\n\t  cgroup of their process.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called cls_cgroup.\n\nconfig NET_CLS_BPF\n\ttristate \"BPF-based classifier\"\n\tselect NET_CLS\n\thelp\n\t  If you say Y here, you will be able to classify packets based on\n\t  programmable BPF (JIT'ed) filters as an alternative to ematches.\n\n\t  To compile this code as a module, choose M here: the module will\n\t  be called cls_bpf.\n\nconfig NET_CLS_FLOWER\n\ttristate \"Flower classifier\"\n\tselect NET_CLS\n\thelp\n\t  If you say Y here, you will be able to classify packets based on\n\t  a configurable combination of packet keys and masks.\n\n\t  To compile this code as a module, choose M here: the module will\n\t  be called cls_flower.\n\nconfig NET_CLS_MATCHALL\n\ttristate \"Match-all classifier\"\n\tselect NET_CLS\n\thelp\n\t  If you say Y here, you will be able to classify packets based on\n\t  nothing. Every packet will match.\n\n\t  To compile this code as a module, choose M here: the module will\n\t  be called cls_matchall.\n\nconfig NET_EMATCH\n\tbool \"Extended Matches\"\n\tselect NET_CLS\n\thelp\n\t  Say Y here if you want to use extended matches on top of classifiers\n\t  and select the extended matches below.\n\n\t  Extended matches are small classification helpers not worth writing\n\t  a separate classifier for.\n\n\t  A recent version of the iproute2 package is required to use\n\t  extended matches.\n\nconfig NET_EMATCH_STACK\n\tint \"Stack size\"\n\tdepends on NET_EMATCH\n\tdefault \"32\"\n\thelp\n\t  Size of the local stack variable used while evaluating the tree of\n\t  ematches. Limits the depth of the tree, i.e. the number of\n\t  encapsulated precedences. Every level requires 4 bytes of additional\n\t  stack space.\n\nconfig NET_EMATCH_CMP\n\ttristate \"Simple packet data comparison\"\n\tdepends on NET_EMATCH\n\thelp\n\t  Say Y here if you want to be able to classify packets based on\n\t  simple packet data comparisons for 8, 16, and 32bit values.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called em_cmp.\n\nconfig NET_EMATCH_NBYTE\n\ttristate \"Multi byte comparison\"\n\tdepends on NET_EMATCH\n\thelp\n\t  Say Y here if you want to be able to classify packets based on\n\t  multiple byte comparisons mainly useful for IPv6 address comparisons.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called em_nbyte.\n\nconfig NET_EMATCH_U32\n\ttristate \"U32 key\"\n\tdepends on NET_EMATCH\n\thelp\n\t  Say Y here if you want to be able to classify packets using\n\t  the famous u32 key in combination with logic relations.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called em_u32.\n\nconfig NET_EMATCH_META\n\ttristate \"Metadata\"\n\tdepends on NET_EMATCH\n\thelp\n\t  Say Y here if you want to be able to classify packets based on\n\t  metadata such as load average, netfilter attributes, socket\n\t  attributes and routing decisions.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called em_meta.\n\nconfig NET_EMATCH_TEXT\n\ttristate \"Textsearch\"\n\tdepends on NET_EMATCH\n\tselect TEXTSEARCH\n\tselect TEXTSEARCH_KMP\n\tselect TEXTSEARCH_BM\n\tselect TEXTSEARCH_FSM\n\thelp\n\t  Say Y here if you want to be able to classify packets based on\n\t  textsearch comparisons.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called em_text.\n\nconfig NET_EMATCH_CANID\n\ttristate \"CAN Identifier\"\n\tdepends on NET_EMATCH && (CAN=y || CAN=m)\n\thelp\n\t  Say Y here if you want to be able to classify CAN frames based\n\t  on CAN Identifier.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called em_canid.\n\nconfig NET_EMATCH_IPSET\n\ttristate \"IPset\"\n\tdepends on NET_EMATCH && IP_SET\n\thelp\n\t  Say Y here if you want to be able to classify packets based on\n\t  ipset membership.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called em_ipset.\n\nconfig NET_EMATCH_IPT\n\ttristate \"IPtables Matches\"\n\tdepends on NET_EMATCH && NETFILTER && NETFILTER_XTABLES\n\thelp\n\t  Say Y here to be able to classify packets based on iptables\n\t  matches.\n\t  Current supported match is \"policy\" which allows packet classification\n\t  based on IPsec policy that was used during decapsulation\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called em_ipt.\n\nconfig NET_CLS_ACT\n\tbool \"Actions\"\n\tselect NET_CLS\n\tselect NET_XGRESS\n\thelp\n\t  Say Y here if you want to use traffic control actions. Actions\n\t  get attached to classifiers and are invoked after a successful\n\t  classification. They are used to overwrite the classification\n\t  result, instantly drop or redirect packets, etc.\n\n\t  A recent version of the iproute2 package is required to use\n\t  extended matches.\n\nconfig NET_ACT_POLICE\n\ttristate \"Traffic Policing\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here if you want to do traffic policing, i.e. strict\n\t  bandwidth limiting. This action replaces the existing policing\n\t  module.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_police.\n\nconfig NET_ACT_GACT\n\ttristate \"Generic actions\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here to take generic actions such as dropping and\n\t  accepting packets.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_gact.\n\nconfig GACT_PROB\n\tbool \"Probability support\"\n\tdepends on NET_ACT_GACT\n\thelp\n\t  Say Y here to use the generic action randomly or deterministically.\n\nconfig NET_ACT_MIRRED\n\ttristate \"Redirecting and Mirroring\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here to allow packets to be mirrored or redirected to\n\t  other devices.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_mirred.\n\nconfig NET_ACT_SAMPLE\n\ttristate \"Traffic Sampling\"\n\tdepends on NET_CLS_ACT\n\tselect PSAMPLE\n\thelp\n\t  Say Y here to allow packet sampling tc action. The packet sample\n\t  action consists of statistically choosing packets and sampling\n\t  them using the psample module.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_sample.\n\nconfig NET_ACT_IPT\n\ttristate \"IPtables targets\"\n\tdepends on NET_CLS_ACT && NETFILTER && NETFILTER_XTABLES\n\thelp\n\t  Say Y here to be able to invoke iptables targets after successful\n\t  classification.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_ipt.\n\nconfig NET_ACT_NAT\n\ttristate \"Stateless NAT\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here to do stateless NAT on IPv4 packets.  You should use\n\t  netfilter for NAT unless you know what you are doing.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_nat.\n\nconfig NET_ACT_PEDIT\n\ttristate \"Packet Editing\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here if you want to mangle the content of packets.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_pedit.\n\nconfig NET_ACT_SIMP\n\ttristate \"Simple Example (Debug)\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here to add a simple action for demonstration purposes.\n\t  It is meant as an example and for debugging purposes. It will\n\t  print a configured policy string followed by the packet count\n\t  to the console for every packet that passes by.\n\n\t  If unsure, say N.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_simple.\n\nconfig NET_ACT_SKBEDIT\n\ttristate \"SKB Editing\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here to change skb priority or queue_mapping settings.\n\n\t  If unsure, say N.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_skbedit.\n\nconfig NET_ACT_CSUM\n\ttristate \"Checksum Updating\"\n\tdepends on NET_CLS_ACT && INET\n\tselect LIBCRC32C\n\thelp\n\t  Say Y here to update some common checksum after some direct\n\t  packet alterations.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_csum.\n\nconfig NET_ACT_MPLS\n\ttristate \"MPLS manipulation\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here to push or pop MPLS headers.\n\n\t  If unsure, say N.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_mpls.\n\nconfig NET_ACT_VLAN\n\ttristate \"Vlan manipulation\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here to push or pop vlan headers.\n\n\t  If unsure, say N.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_vlan.\n\nconfig NET_ACT_BPF\n\ttristate \"BPF based action\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here to execute BPF code on packets. The BPF code will decide\n\t  if the packet should be dropped or not.\n\n\t  If unsure, say N.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_bpf.\n\nconfig NET_ACT_CONNMARK\n\ttristate \"Netfilter Connection Mark Retriever\"\n\tdepends on NET_CLS_ACT && NETFILTER\n\tdepends on NF_CONNTRACK && NF_CONNTRACK_MARK\n\thelp\n\t  Say Y here to allow retrieving of conn mark\n\n\t  If unsure, say N.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_connmark.\n\nconfig NET_ACT_CTINFO\n\ttristate \"Netfilter Connection Mark Actions\"\n\tdepends on NET_CLS_ACT && NETFILTER\n\tdepends on NF_CONNTRACK && NF_CONNTRACK_MARK\n\thelp\n\t  Say Y here to allow transfer of a connmark stored information.\n\t  Current actions transfer connmark stored DSCP into\n\t  ipv4/v6 diffserv and/or to transfer connmark to packet\n\t  mark.  Both are useful for restoring egress based marks\n\t  back onto ingress connections for qdisc priority mapping\n\t  purposes.\n\n\t  If unsure, say N.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_ctinfo.\n\nconfig NET_ACT_SKBMOD\n\ttristate \"skb data modification action\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t Say Y here to allow modification of skb data\n\n\t If unsure, say N.\n\n\t To compile this code as a module, choose M here: the\n\t module will be called act_skbmod.\n\nconfig NET_ACT_IFE\n\ttristate \"Inter-FE action based on IETF ForCES InterFE LFB\"\n\tdepends on NET_CLS_ACT\n\tselect NET_IFE\n\thelp\n\t  Say Y here to allow for sourcing and terminating metadata\n\t  For details refer to netdev01 paper:\n\t  \"Distributing Linux Traffic Control Classifier-Action Subsystem\"\n\t   Authors: Jamal Hadi Salim and Damascene M. Joachimpillai\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_ife.\n\nconfig NET_ACT_TUNNEL_KEY\n\ttristate \"IP tunnel metadata manipulation\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here to set/release ip tunnel metadata.\n\n\t  If unsure, say N.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_tunnel_key.\n\nconfig NET_ACT_CT\n\ttristate \"connection tracking tc action\"\n\tdepends on NET_CLS_ACT && NF_CONNTRACK && (!NF_NAT || NF_NAT) && NF_FLOW_TABLE\n\tselect NF_CONNTRACK_OVS\n\tselect NF_NAT_OVS if NF_NAT\n\thelp\n\t  Say Y here to allow sending the packets to conntrack module.\n\n\t  If unsure, say N.\n\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_ct.\n\nconfig NET_ACT_GATE\n\ttristate \"Frame gate entry list control tc action\"\n\tdepends on NET_CLS_ACT\n\thelp\n\t  Say Y here to allow to control the ingress flow to be passed at\n\t  specific time slot and be dropped at other specific time slot by\n\t  the gate entry list.\n\n\t  If unsure, say N.\n\t  To compile this code as a module, choose M here: the\n\t  module will be called act_gate.\n\nconfig NET_IFE_SKBMARK\n\ttristate \"Support to encoding decoding skb mark on IFE action\"\n\tdepends on NET_ACT_IFE\n\nconfig NET_IFE_SKBPRIO\n\ttristate \"Support to encoding decoding skb prio on IFE action\"\n\tdepends on NET_ACT_IFE\n\nconfig NET_IFE_SKBTCINDEX\n\ttristate \"Support to encoding decoding skb tcindex on IFE action\"\n\tdepends on NET_ACT_IFE\n\nconfig NET_TC_SKB_EXT\n\tbool \"TC recirculation support\"\n\tdepends on NET_CLS_ACT\n\tselect SKB_EXTENSIONS\n\n\thelp\n\t  Say Y here to allow tc chain misses to continue in OvS datapath in\n\t  the correct recirc_id, and hardware chain misses to continue in\n\t  the correct chain in tc software datapath.\n\n\t  Say N here if you won't be using tc<->ovs offload or tc chains offload.\n\nendif # NET_SCHED\n\nconfig NET_SCH_FIFO\n\tbool\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}