{
  "module_name": "sch_plug.c",
  "hash_id": "79b88d11d65f7b97b2ecad46d5f257c028cc1c544d570c41f49f801f553cdaa4",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_plug.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/pkt_sched.h>\n\n \n\nstruct plug_sched_data {\n\t \n\tbool unplug_indefinite;\n\n\tbool throttled;\n\n\t \n\tu32 limit;\n\n\t \n\tu32 pkts_current_epoch;\n\n\t \n\tu32 pkts_last_epoch;\n\n\t \n\tu32 pkts_to_release;\n};\n\nstatic int plug_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\tstruct sk_buff **to_free)\n{\n\tstruct plug_sched_data *q = qdisc_priv(sch);\n\n\tif (likely(sch->qstats.backlog + skb->len <= q->limit)) {\n\t\tif (!q->unplug_indefinite)\n\t\t\tq->pkts_current_epoch++;\n\t\treturn qdisc_enqueue_tail(skb, sch);\n\t}\n\n\treturn qdisc_drop(skb, sch, to_free);\n}\n\nstatic struct sk_buff *plug_dequeue(struct Qdisc *sch)\n{\n\tstruct plug_sched_data *q = qdisc_priv(sch);\n\n\tif (q->throttled)\n\t\treturn NULL;\n\n\tif (!q->unplug_indefinite) {\n\t\tif (!q->pkts_to_release) {\n\t\t\t \n\t\t\tq->throttled = true;\n\t\t\treturn NULL;\n\t\t}\n\t\tq->pkts_to_release--;\n\t}\n\n\treturn qdisc_dequeue_head(sch);\n}\n\nstatic int plug_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct plug_sched_data *q = qdisc_priv(sch);\n\n\tq->pkts_current_epoch = 0;\n\tq->pkts_last_epoch = 0;\n\tq->pkts_to_release = 0;\n\tq->unplug_indefinite = false;\n\n\tif (opt == NULL) {\n\t\tq->limit = qdisc_dev(sch)->tx_queue_len\n\t\t           * psched_mtu(qdisc_dev(sch));\n\t} else {\n\t\tstruct tc_plug_qopt *ctl = nla_data(opt);\n\n\t\tif (nla_len(opt) < sizeof(*ctl))\n\t\t\treturn -EINVAL;\n\n\t\tq->limit = ctl->limit;\n\t}\n\n\tq->throttled = true;\n\treturn 0;\n}\n\n \nstatic int plug_change(struct Qdisc *sch, struct nlattr *opt,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct plug_sched_data *q = qdisc_priv(sch);\n\tstruct tc_plug_qopt *msg;\n\n\tmsg = nla_data(opt);\n\tif (nla_len(opt) < sizeof(*msg))\n\t\treturn -EINVAL;\n\n\tswitch (msg->action) {\n\tcase TCQ_PLUG_BUFFER:\n\t\t \n\t\tq->pkts_last_epoch = q->pkts_current_epoch;\n\t\tq->pkts_current_epoch = 0;\n\t\tif (q->unplug_indefinite)\n\t\t\tq->throttled = true;\n\t\tq->unplug_indefinite = false;\n\t\tbreak;\n\tcase TCQ_PLUG_RELEASE_ONE:\n\t\t \n\t\tq->pkts_to_release += q->pkts_last_epoch;\n\t\tq->pkts_last_epoch = 0;\n\t\tq->throttled = false;\n\t\tnetif_schedule_queue(sch->dev_queue);\n\t\tbreak;\n\tcase TCQ_PLUG_RELEASE_INDEFINITE:\n\t\tq->unplug_indefinite = true;\n\t\tq->pkts_to_release = 0;\n\t\tq->pkts_last_epoch = 0;\n\t\tq->pkts_current_epoch = 0;\n\t\tq->throttled = false;\n\t\tnetif_schedule_queue(sch->dev_queue);\n\t\tbreak;\n\tcase TCQ_PLUG_LIMIT:\n\t\t \n\t\tq->limit = msg->limit;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct Qdisc_ops plug_qdisc_ops __read_mostly = {\n\t.id          =       \"plug\",\n\t.priv_size   =       sizeof(struct plug_sched_data),\n\t.enqueue     =       plug_enqueue,\n\t.dequeue     =       plug_dequeue,\n\t.peek        =       qdisc_peek_dequeued,\n\t.init        =       plug_init,\n\t.change      =       plug_change,\n\t.reset       =\t     qdisc_reset_queue,\n\t.owner       =       THIS_MODULE,\n};\n\nstatic int __init plug_module_init(void)\n{\n\treturn register_qdisc(&plug_qdisc_ops);\n}\n\nstatic void __exit plug_module_exit(void)\n{\n\tunregister_qdisc(&plug_qdisc_ops);\n}\nmodule_init(plug_module_init)\nmodule_exit(plug_module_exit)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}