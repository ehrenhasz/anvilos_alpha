{
  "module_name": "sch_frag.c",
  "hash_id": "30cd3c4db4ef010046ff495c0de7b2ee9ab83e6806aee4a635f0f33fd24df2e4",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_frag.c",
  "human_readable_source": "\n#include <linux/if_vlan.h>\n#include <net/netlink.h>\n#include <net/sch_generic.h>\n#include <net/pkt_sched.h>\n#include <net/dst.h>\n#include <net/ip.h>\n#include <net/ip6_fib.h>\n\nstruct sch_frag_data {\n\tunsigned long dst;\n\tstruct qdisc_skb_cb cb;\n\t__be16 inner_protocol;\n\tu16 vlan_tci;\n\t__be16 vlan_proto;\n\tunsigned int l2_len;\n\tu8 l2_data[VLAN_ETH_HLEN];\n\tint (*xmit)(struct sk_buff *skb);\n};\n\nstatic DEFINE_PER_CPU(struct sch_frag_data, sch_frag_data_storage);\n\nstatic int sch_frag_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sch_frag_data *data = this_cpu_ptr(&sch_frag_data_storage);\n\n\tif (skb_cow_head(skb, data->l2_len) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\t__skb_dst_copy(skb, data->dst);\n\t*qdisc_skb_cb(skb) = data->cb;\n\tskb->inner_protocol = data->inner_protocol;\n\tif (data->vlan_tci & VLAN_CFI_MASK)\n\t\t__vlan_hwaccel_put_tag(skb, data->vlan_proto,\n\t\t\t\t       data->vlan_tci & ~VLAN_CFI_MASK);\n\telse\n\t\t__vlan_hwaccel_clear_tag(skb);\n\n\t \n\tskb_push(skb, data->l2_len);\n\tmemcpy(skb->data, &data->l2_data, data->l2_len);\n\tskb_postpush_rcsum(skb, skb->data, data->l2_len);\n\tskb_reset_mac_header(skb);\n\n\treturn data->xmit(skb);\n}\n\nstatic void sch_frag_prepare_frag(struct sk_buff *skb,\n\t\t\t\t  int (*xmit)(struct sk_buff *skb))\n{\n\tunsigned int hlen = skb_network_offset(skb);\n\tstruct sch_frag_data *data;\n\n\tdata = this_cpu_ptr(&sch_frag_data_storage);\n\tdata->dst = skb->_skb_refdst;\n\tdata->cb = *qdisc_skb_cb(skb);\n\tdata->xmit = xmit;\n\tdata->inner_protocol = skb->inner_protocol;\n\tif (skb_vlan_tag_present(skb))\n\t\tdata->vlan_tci = skb_vlan_tag_get(skb) | VLAN_CFI_MASK;\n\telse\n\t\tdata->vlan_tci = 0;\n\tdata->vlan_proto = skb->vlan_proto;\n\tdata->l2_len = hlen;\n\tmemcpy(&data->l2_data, skb->data, hlen);\n\n\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\tskb_pull(skb, hlen);\n}\n\nstatic unsigned int\nsch_frag_dst_get_mtu(const struct dst_entry *dst)\n{\n\treturn dst->dev->mtu;\n}\n\nstatic struct dst_ops sch_frag_dst_ops = {\n\t.family = AF_UNSPEC,\n\t.mtu = sch_frag_dst_get_mtu,\n};\n\nstatic int sch_fragment(struct net *net, struct sk_buff *skb,\n\t\t\tu16 mru, int (*xmit)(struct sk_buff *skb))\n{\n\tint ret = -1;\n\n\tif (skb_network_offset(skb) > VLAN_ETH_HLEN) {\n\t\tnet_warn_ratelimited(\"L2 header too long to fragment\\n\");\n\t\tgoto err;\n\t}\n\n\tif (skb_protocol(skb, true) == htons(ETH_P_IP)) {\n\t\tstruct rtable sch_frag_rt = { 0 };\n\t\tunsigned long orig_dst;\n\n\t\tsch_frag_prepare_frag(skb, xmit);\n\t\tdst_init(&sch_frag_rt.dst, &sch_frag_dst_ops, NULL, 1,\n\t\t\t DST_OBSOLETE_NONE, DST_NOCOUNT);\n\t\tsch_frag_rt.dst.dev = skb->dev;\n\n\t\torig_dst = skb->_skb_refdst;\n\t\tskb_dst_set_noref(skb, &sch_frag_rt.dst);\n\t\tIPCB(skb)->frag_max_size = mru;\n\n\t\tret = ip_do_fragment(net, skb->sk, skb, sch_frag_xmit);\n\t\trefdst_drop(orig_dst);\n\t} else if (skb_protocol(skb, true) == htons(ETH_P_IPV6)) {\n\t\tunsigned long orig_dst;\n\t\tstruct rt6_info sch_frag_rt;\n\n\t\tsch_frag_prepare_frag(skb, xmit);\n\t\tmemset(&sch_frag_rt, 0, sizeof(sch_frag_rt));\n\t\tdst_init(&sch_frag_rt.dst, &sch_frag_dst_ops, NULL, 1,\n\t\t\t DST_OBSOLETE_NONE, DST_NOCOUNT);\n\t\tsch_frag_rt.dst.dev = skb->dev;\n\n\t\torig_dst = skb->_skb_refdst;\n\t\tskb_dst_set_noref(skb, &sch_frag_rt.dst);\n\t\tIP6CB(skb)->frag_max_size = mru;\n\n\t\tret = ipv6_stub->ipv6_fragment(net, skb->sk, skb,\n\t\t\t\t\t       sch_frag_xmit);\n\t\trefdst_drop(orig_dst);\n\t} else {\n\t\tnet_warn_ratelimited(\"Fail frag %s: eth=%x, MRU=%d, MTU=%d\\n\",\n\t\t\t\t     netdev_name(skb->dev),\n\t\t\t\t     ntohs(skb_protocol(skb, true)), mru,\n\t\t\t\t     skb->dev->mtu);\n\t\tgoto err;\n\t}\n\n\treturn ret;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nint sch_frag_xmit_hook(struct sk_buff *skb, int (*xmit)(struct sk_buff *skb))\n{\n\tu16 mru = tc_skb_cb(skb)->mru;\n\tint err;\n\n\tif (mru && skb->len > mru + skb->dev->hard_header_len)\n\t\terr = sch_fragment(dev_net(skb->dev), skb, mru, xmit);\n\telse\n\t\terr = xmit(skb);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sch_frag_xmit_hook);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}