{
  "module_name": "act_ife.c",
  "hash_id": "927aef235939c92577f18237e42a2b6dfcd95185b957b4885e1c03ce4c219a6e",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_ife.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <net/net_namespace.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <uapi/linux/tc_act/tc_ife.h>\n#include <net/tc_act/tc_ife.h>\n#include <linux/etherdevice.h>\n#include <net/ife.h>\n#include <net/tc_wrapper.h>\n\nstatic int max_metacnt = IFE_META_MAX + 1;\nstatic struct tc_action_ops act_ife_ops;\n\nstatic const struct nla_policy ife_policy[TCA_IFE_MAX + 1] = {\n\t[TCA_IFE_PARMS] = { .len = sizeof(struct tc_ife)},\n\t[TCA_IFE_DMAC] = { .len = ETH_ALEN},\n\t[TCA_IFE_SMAC] = { .len = ETH_ALEN},\n\t[TCA_IFE_TYPE] = { .type = NLA_U16},\n};\n\nint ife_encode_meta_u16(u16 metaval, void *skbdata, struct tcf_meta_info *mi)\n{\n\tu16 edata = 0;\n\n\tif (mi->metaval)\n\t\tedata = *(u16 *)mi->metaval;\n\telse if (metaval)\n\t\tedata = metaval;\n\n\tif (!edata)  \n\t\treturn 0;\n\n\tedata = htons(edata);\n\treturn ife_tlv_meta_encode(skbdata, mi->metaid, 2, &edata);\n}\nEXPORT_SYMBOL_GPL(ife_encode_meta_u16);\n\nint ife_get_meta_u32(struct sk_buff *skb, struct tcf_meta_info *mi)\n{\n\tif (mi->metaval)\n\t\treturn nla_put_u32(skb, mi->metaid, *(u32 *)mi->metaval);\n\telse\n\t\treturn nla_put(skb, mi->metaid, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(ife_get_meta_u32);\n\nint ife_check_meta_u32(u32 metaval, struct tcf_meta_info *mi)\n{\n\tif (metaval || mi->metaval)\n\t\treturn 8;  \n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ife_check_meta_u32);\n\nint ife_check_meta_u16(u16 metaval, struct tcf_meta_info *mi)\n{\n\tif (metaval || mi->metaval)\n\t\treturn 8;  \n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ife_check_meta_u16);\n\nint ife_encode_meta_u32(u32 metaval, void *skbdata, struct tcf_meta_info *mi)\n{\n\tu32 edata = metaval;\n\n\tif (mi->metaval)\n\t\tedata = *(u32 *)mi->metaval;\n\telse if (metaval)\n\t\tedata = metaval;\n\n\tif (!edata)  \n\t\treturn 0;\n\n\tedata = htonl(edata);\n\treturn ife_tlv_meta_encode(skbdata, mi->metaid, 4, &edata);\n}\nEXPORT_SYMBOL_GPL(ife_encode_meta_u32);\n\nint ife_get_meta_u16(struct sk_buff *skb, struct tcf_meta_info *mi)\n{\n\tif (mi->metaval)\n\t\treturn nla_put_u16(skb, mi->metaid, *(u16 *)mi->metaval);\n\telse\n\t\treturn nla_put(skb, mi->metaid, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(ife_get_meta_u16);\n\nint ife_alloc_meta_u32(struct tcf_meta_info *mi, void *metaval, gfp_t gfp)\n{\n\tmi->metaval = kmemdup(metaval, sizeof(u32), gfp);\n\tif (!mi->metaval)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ife_alloc_meta_u32);\n\nint ife_alloc_meta_u16(struct tcf_meta_info *mi, void *metaval, gfp_t gfp)\n{\n\tmi->metaval = kmemdup(metaval, sizeof(u16), gfp);\n\tif (!mi->metaval)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ife_alloc_meta_u16);\n\nvoid ife_release_meta_gen(struct tcf_meta_info *mi)\n{\n\tkfree(mi->metaval);\n}\nEXPORT_SYMBOL_GPL(ife_release_meta_gen);\n\nint ife_validate_meta_u32(void *val, int len)\n{\n\tif (len == sizeof(u32))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(ife_validate_meta_u32);\n\nint ife_validate_meta_u16(void *val, int len)\n{\n\t \n\tif (len == sizeof(u16))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(ife_validate_meta_u16);\n\nstatic LIST_HEAD(ifeoplist);\nstatic DEFINE_RWLOCK(ife_mod_lock);\n\nstatic struct tcf_meta_ops *find_ife_oplist(u16 metaid)\n{\n\tstruct tcf_meta_ops *o;\n\n\tread_lock(&ife_mod_lock);\n\tlist_for_each_entry(o, &ifeoplist, list) {\n\t\tif (o->metaid == metaid) {\n\t\t\tif (!try_module_get(o->owner))\n\t\t\t\to = NULL;\n\t\t\tread_unlock(&ife_mod_lock);\n\t\t\treturn o;\n\t\t}\n\t}\n\tread_unlock(&ife_mod_lock);\n\n\treturn NULL;\n}\n\nint register_ife_op(struct tcf_meta_ops *mops)\n{\n\tstruct tcf_meta_ops *m;\n\n\tif (!mops->metaid || !mops->metatype || !mops->name ||\n\t    !mops->check_presence || !mops->encode || !mops->decode ||\n\t    !mops->get || !mops->alloc)\n\t\treturn -EINVAL;\n\n\twrite_lock(&ife_mod_lock);\n\n\tlist_for_each_entry(m, &ifeoplist, list) {\n\t\tif (m->metaid == mops->metaid ||\n\t\t    (strcmp(mops->name, m->name) == 0)) {\n\t\t\twrite_unlock(&ife_mod_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tif (!mops->release)\n\t\tmops->release = ife_release_meta_gen;\n\n\tlist_add_tail(&mops->list, &ifeoplist);\n\twrite_unlock(&ife_mod_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(unregister_ife_op);\n\nint unregister_ife_op(struct tcf_meta_ops *mops)\n{\n\tstruct tcf_meta_ops *m;\n\tint err = -ENOENT;\n\n\twrite_lock(&ife_mod_lock);\n\tlist_for_each_entry(m, &ifeoplist, list) {\n\t\tif (m->metaid == mops->metaid) {\n\t\t\tlist_del(&mops->list);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\twrite_unlock(&ife_mod_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(register_ife_op);\n\nstatic int ife_validate_metatype(struct tcf_meta_ops *ops, void *val, int len)\n{\n\tint ret = 0;\n\t \n\tif (ops->validate)\n\t\treturn ops->validate(val, len);\n\n\tif (ops->metatype == NLA_U32)\n\t\tret = ife_validate_meta_u32(val, len);\n\telse if (ops->metatype == NLA_U16)\n\t\tret = ife_validate_meta_u16(val, len);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_MODULES\nstatic const char *ife_meta_id2name(u32 metaid)\n{\n\tswitch (metaid) {\n\tcase IFE_META_SKBMARK:\n\t\treturn \"skbmark\";\n\tcase IFE_META_PRIO:\n\t\treturn \"skbprio\";\n\tcase IFE_META_TCINDEX:\n\t\treturn \"tcindex\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n#endif\n\n \nstatic int load_metaops_and_vet(u32 metaid, void *val, int len, bool rtnl_held)\n{\n\tstruct tcf_meta_ops *ops = find_ife_oplist(metaid);\n\tint ret = 0;\n\n\tif (!ops) {\n\t\tret = -ENOENT;\n#ifdef CONFIG_MODULES\n\t\tif (rtnl_held)\n\t\t\trtnl_unlock();\n\t\trequest_module(\"ife-meta-%s\", ife_meta_id2name(metaid));\n\t\tif (rtnl_held)\n\t\t\trtnl_lock();\n\t\tops = find_ife_oplist(metaid);\n#endif\n\t}\n\n\tif (ops) {\n\t\tret = 0;\n\t\tif (len)\n\t\t\tret = ife_validate_metatype(ops, val, len);\n\n\t\tmodule_put(ops->owner);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int __add_metainfo(const struct tcf_meta_ops *ops,\n\t\t\t  struct tcf_ife_info *ife, u32 metaid, void *metaval,\n\t\t\t  int len, bool atomic, bool exists)\n{\n\tstruct tcf_meta_info *mi = NULL;\n\tint ret = 0;\n\n\tmi = kzalloc(sizeof(*mi), atomic ? GFP_ATOMIC : GFP_KERNEL);\n\tif (!mi)\n\t\treturn -ENOMEM;\n\n\tmi->metaid = metaid;\n\tmi->ops = ops;\n\tif (len > 0) {\n\t\tret = ops->alloc(mi, metaval, atomic ? GFP_ATOMIC : GFP_KERNEL);\n\t\tif (ret != 0) {\n\t\t\tkfree(mi);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (exists)\n\t\tspin_lock_bh(&ife->tcf_lock);\n\tlist_add_tail(&mi->metalist, &ife->metalist);\n\tif (exists)\n\t\tspin_unlock_bh(&ife->tcf_lock);\n\n\treturn ret;\n}\n\nstatic int add_metainfo_and_get_ops(const struct tcf_meta_ops *ops,\n\t\t\t\t    struct tcf_ife_info *ife, u32 metaid,\n\t\t\t\t    bool exists)\n{\n\tint ret;\n\n\tif (!try_module_get(ops->owner))\n\t\treturn -ENOENT;\n\tret = __add_metainfo(ops, ife, metaid, NULL, 0, true, exists);\n\tif (ret)\n\t\tmodule_put(ops->owner);\n\treturn ret;\n}\n\nstatic int add_metainfo(struct tcf_ife_info *ife, u32 metaid, void *metaval,\n\t\t\tint len, bool exists)\n{\n\tconst struct tcf_meta_ops *ops = find_ife_oplist(metaid);\n\tint ret;\n\n\tif (!ops)\n\t\treturn -ENOENT;\n\tret = __add_metainfo(ops, ife, metaid, metaval, len, false, exists);\n\tif (ret)\n\t\t \n\t\tmodule_put(ops->owner);\n\treturn ret;\n}\n\nstatic int use_all_metadata(struct tcf_ife_info *ife, bool exists)\n{\n\tstruct tcf_meta_ops *o;\n\tint rc = 0;\n\tint installed = 0;\n\n\tread_lock(&ife_mod_lock);\n\tlist_for_each_entry(o, &ifeoplist, list) {\n\t\trc = add_metainfo_and_get_ops(o, ife, o->metaid, exists);\n\t\tif (rc == 0)\n\t\t\tinstalled += 1;\n\t}\n\tread_unlock(&ife_mod_lock);\n\n\tif (installed)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int dump_metalist(struct sk_buff *skb, struct tcf_ife_info *ife)\n{\n\tstruct tcf_meta_info *e;\n\tstruct nlattr *nest;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tint total_encoded = 0;\n\n\t \n\tif (list_empty(&ife->metalist))\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(skb, TCA_IFE_METALST);\n\tif (!nest)\n\t\tgoto out_nlmsg_trim;\n\n\tlist_for_each_entry(e, &ife->metalist, metalist) {\n\t\tif (!e->ops->get(skb, e))\n\t\t\ttotal_encoded += 1;\n\t}\n\n\tif (!total_encoded)\n\t\tgoto out_nlmsg_trim;\n\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n\nout_nlmsg_trim:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\n \nstatic void _tcf_ife_cleanup(struct tc_action *a)\n{\n\tstruct tcf_ife_info *ife = to_ife(a);\n\tstruct tcf_meta_info *e, *n;\n\n\tlist_for_each_entry_safe(e, n, &ife->metalist, metalist) {\n\t\tlist_del(&e->metalist);\n\t\tif (e->metaval) {\n\t\t\tif (e->ops->release)\n\t\t\t\te->ops->release(e);\n\t\t\telse\n\t\t\t\tkfree(e->metaval);\n\t\t}\n\t\tmodule_put(e->ops->owner);\n\t\tkfree(e);\n\t}\n}\n\nstatic void tcf_ife_cleanup(struct tc_action *a)\n{\n\tstruct tcf_ife_info *ife = to_ife(a);\n\tstruct tcf_ife_params *p;\n\n\tspin_lock_bh(&ife->tcf_lock);\n\t_tcf_ife_cleanup(a);\n\tspin_unlock_bh(&ife->tcf_lock);\n\n\tp = rcu_dereference_protected(ife->params, 1);\n\tif (p)\n\t\tkfree_rcu(p, rcu);\n}\n\nstatic int load_metalist(struct nlattr **tb, bool rtnl_held)\n{\n\tint i;\n\n\tfor (i = 1; i < max_metacnt; i++) {\n\t\tif (tb[i]) {\n\t\t\tvoid *val = nla_data(tb[i]);\n\t\t\tint len = nla_len(tb[i]);\n\t\t\tint rc;\n\n\t\t\trc = load_metaops_and_vet(i, val, len, rtnl_held);\n\t\t\tif (rc != 0)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int populate_metalist(struct tcf_ife_info *ife, struct nlattr **tb,\n\t\t\t     bool exists, bool rtnl_held)\n{\n\tint len = 0;\n\tint rc = 0;\n\tint i = 0;\n\tvoid *val;\n\n\tfor (i = 1; i < max_metacnt; i++) {\n\t\tif (tb[i]) {\n\t\t\tval = nla_data(tb[i]);\n\t\t\tlen = nla_len(tb[i]);\n\n\t\t\trc = add_metainfo(ife, i, val, len, exists);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int tcf_ife_init(struct net *net, struct nlattr *nla,\n\t\t\tstruct nlattr *est, struct tc_action **a,\n\t\t\tstruct tcf_proto *tp, u32 flags,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_ife_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_IFE_MAX + 1];\n\tstruct nlattr *tb2[IFE_META_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tcf_ife_params *p;\n\tstruct tcf_ife_info *ife;\n\tu16 ife_type = ETH_P_IFE;\n\tstruct tc_ife *parm;\n\tu8 *daddr = NULL;\n\tu8 *saddr = NULL;\n\tbool exists = false;\n\tint ret = 0;\n\tu32 index;\n\tint err;\n\n\tif (!nla) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"IFE requires attributes to be passed\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, TCA_IFE_MAX, nla, ife_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_IFE_PARMS])\n\t\treturn -EINVAL;\n\n\tparm = nla_data(tb[TCA_IFE_PARMS]);\n\n\t \n\tif (parm->flags & ~IFE_ENCODE)\n\t\treturn -EINVAL;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (tb[TCA_IFE_METALST]) {\n\t\terr = nla_parse_nested_deprecated(tb2, IFE_META_MAX,\n\t\t\t\t\t\t  tb[TCA_IFE_METALST], NULL,\n\t\t\t\t\t\t  NULL);\n\t\tif (err) {\n\t\t\tkfree(p);\n\t\t\treturn err;\n\t\t}\n\t\terr = load_metalist(tb2, !(flags & TCA_ACT_FLAGS_NO_RTNL));\n\t\tif (err) {\n\t\t\tkfree(p);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tindex = parm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0) {\n\t\tkfree(p);\n\t\treturn err;\n\t}\n\texists = err;\n\tif (exists && bind) {\n\t\tkfree(p);\n\t\treturn 0;\n\t}\n\n\tif (!exists) {\n\t\tret = tcf_idr_create(tn, index, est, a, &act_ife_ops,\n\t\t\t\t     bind, true, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\tkfree(p);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ACT_P_CREATED;\n\t} else if (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\ttcf_idr_release(*a, bind);\n\t\tkfree(p);\n\t\treturn -EEXIST;\n\t}\n\n\tife = to_ife(*a);\n\tif (ret == ACT_P_CREATED)\n\t\tINIT_LIST_HEAD(&ife->metalist);\n\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\tp->flags = parm->flags;\n\n\tif (parm->flags & IFE_ENCODE) {\n\t\tif (tb[TCA_IFE_TYPE])\n\t\t\tife_type = nla_get_u16(tb[TCA_IFE_TYPE]);\n\t\tif (tb[TCA_IFE_DMAC])\n\t\t\tdaddr = nla_data(tb[TCA_IFE_DMAC]);\n\t\tif (tb[TCA_IFE_SMAC])\n\t\t\tsaddr = nla_data(tb[TCA_IFE_SMAC]);\n\t}\n\n\tif (parm->flags & IFE_ENCODE) {\n\t\tif (daddr)\n\t\t\tether_addr_copy(p->eth_dst, daddr);\n\t\telse\n\t\t\teth_zero_addr(p->eth_dst);\n\n\t\tif (saddr)\n\t\t\tether_addr_copy(p->eth_src, saddr);\n\t\telse\n\t\t\teth_zero_addr(p->eth_src);\n\n\t\tp->eth_type = ife_type;\n\t}\n\n\tif (tb[TCA_IFE_METALST]) {\n\t\terr = populate_metalist(ife, tb2, exists,\n\t\t\t\t\t!(flags & TCA_ACT_FLAGS_NO_RTNL));\n\t\tif (err)\n\t\t\tgoto metadata_parse_err;\n\t} else {\n\t\t \n\t\terr = use_all_metadata(ife, exists);\n\t\tif (err)\n\t\t\tgoto metadata_parse_err;\n\t}\n\n\tif (exists)\n\t\tspin_lock_bh(&ife->tcf_lock);\n\t \n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\tp = rcu_replace_pointer(ife->params, p, 1);\n\n\tif (exists)\n\t\tspin_unlock_bh(&ife->tcf_lock);\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\tif (p)\n\t\tkfree_rcu(p, rcu);\n\n\treturn ret;\nmetadata_parse_err:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\tkfree(p);\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic int tcf_ife_dump(struct sk_buff *skb, struct tc_action *a, int bind,\n\t\t\tint ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_ife_info *ife = to_ife(a);\n\tstruct tcf_ife_params *p;\n\tstruct tc_ife opt = {\n\t\t.index = ife->tcf_index,\n\t\t.refcnt = refcount_read(&ife->tcf_refcnt) - ref,\n\t\t.bindcnt = atomic_read(&ife->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&ife->tcf_lock);\n\topt.action = ife->tcf_action;\n\tp = rcu_dereference_protected(ife->params,\n\t\t\t\t      lockdep_is_held(&ife->tcf_lock));\n\topt.flags = p->flags;\n\n\tif (nla_put(skb, TCA_IFE_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &ife->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_IFE_TM, sizeof(t), &t, TCA_IFE_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (!is_zero_ether_addr(p->eth_dst)) {\n\t\tif (nla_put(skb, TCA_IFE_DMAC, ETH_ALEN, p->eth_dst))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (!is_zero_ether_addr(p->eth_src)) {\n\t\tif (nla_put(skb, TCA_IFE_SMAC, ETH_ALEN, p->eth_src))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put(skb, TCA_IFE_TYPE, 2, &p->eth_type))\n\t\tgoto nla_put_failure;\n\n\tif (dump_metalist(skb, ife)) {\n\t\t \n\t\tpr_info(\"Failed to dump metalist\\n\");\n\t}\n\n\tspin_unlock_bh(&ife->tcf_lock);\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&ife->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic int find_decode_metaid(struct sk_buff *skb, struct tcf_ife_info *ife,\n\t\t\t      u16 metaid, u16 mlen, void *mdata)\n{\n\tstruct tcf_meta_info *e;\n\n\t \n\tlist_for_each_entry(e, &ife->metalist, metalist) {\n\t\tif (metaid == e->metaid) {\n\t\t\tif (e->ops) {\n\t\t\t\t \n\t\t\t\treturn e->ops->decode(skb, mdata, mlen);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int tcf_ife_decode(struct sk_buff *skb, const struct tc_action *a,\n\t\t\t  struct tcf_result *res)\n{\n\tstruct tcf_ife_info *ife = to_ife(a);\n\tint action = ife->tcf_action;\n\tu8 *ifehdr_end;\n\tu8 *tlv_data;\n\tu16 metalen;\n\n\tbstats_update(this_cpu_ptr(ife->common.cpu_bstats), skb);\n\ttcf_lastuse_update(&ife->tcf_tm);\n\n\tif (skb_at_tc_ingress(skb))\n\t\tskb_push(skb, skb->dev->hard_header_len);\n\n\ttlv_data = ife_decode(skb, &metalen);\n\tif (unlikely(!tlv_data)) {\n\t\tqstats_drop_inc(this_cpu_ptr(ife->common.cpu_qstats));\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tifehdr_end = tlv_data + metalen;\n\tfor (; tlv_data < ifehdr_end; tlv_data = ife_tlv_meta_next(tlv_data)) {\n\t\tu8 *curr_data;\n\t\tu16 mtype;\n\t\tu16 dlen;\n\n\t\tcurr_data = ife_tlv_meta_decode(tlv_data, ifehdr_end, &mtype,\n\t\t\t\t\t\t&dlen, NULL);\n\t\tif (!curr_data) {\n\t\t\tqstats_drop_inc(this_cpu_ptr(ife->common.cpu_qstats));\n\t\t\treturn TC_ACT_SHOT;\n\t\t}\n\n\t\tif (find_decode_metaid(skb, ife, mtype, dlen, curr_data)) {\n\t\t\t \n\t\t\tpr_info_ratelimited(\"Unknown metaid %d dlen %d\\n\",\n\t\t\t\t\t    mtype, dlen);\n\t\t\tqstats_overlimit_inc(this_cpu_ptr(ife->common.cpu_qstats));\n\t\t}\n\t}\n\n\tif (WARN_ON(tlv_data != ifehdr_end)) {\n\t\tqstats_drop_inc(this_cpu_ptr(ife->common.cpu_qstats));\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tskb->protocol = eth_type_trans(skb, skb->dev);\n\tskb_reset_network_header(skb);\n\n\treturn action;\n}\n\n \nstatic int ife_get_sz(struct sk_buff *skb, struct tcf_ife_info *ife)\n{\n\tstruct tcf_meta_info *e, *n;\n\tint tot_run_sz = 0, run_sz = 0;\n\n\tlist_for_each_entry_safe(e, n, &ife->metalist, metalist) {\n\t\tif (e->ops->check_presence) {\n\t\t\trun_sz = e->ops->check_presence(skb, e);\n\t\t\ttot_run_sz += run_sz;\n\t\t}\n\t}\n\n\treturn tot_run_sz;\n}\n\nstatic int tcf_ife_encode(struct sk_buff *skb, const struct tc_action *a,\n\t\t\t  struct tcf_result *res, struct tcf_ife_params *p)\n{\n\tstruct tcf_ife_info *ife = to_ife(a);\n\tint action = ife->tcf_action;\n\tstruct ethhdr *oethh;\t \n\tstruct tcf_meta_info *e;\n\t \n\tu16 metalen = ife_get_sz(skb, ife);\n\tint hdrm = metalen + skb->dev->hard_header_len + IFE_METAHDRLEN;\n\tunsigned int skboff = 0;\n\tint new_len = skb->len + hdrm;\n\tbool exceed_mtu = false;\n\tvoid *ife_meta;\n\tint err = 0;\n\n\tif (!skb_at_tc_ingress(skb)) {\n\t\tif (new_len > skb->dev->mtu)\n\t\t\texceed_mtu = true;\n\t}\n\n\tbstats_update(this_cpu_ptr(ife->common.cpu_bstats), skb);\n\ttcf_lastuse_update(&ife->tcf_tm);\n\n\tif (!metalen) {\t\t \n\t\t \n\t\tqstats_overlimit_inc(this_cpu_ptr(ife->common.cpu_qstats));\n\t\treturn action;\n\t}\n\t \n\tif ((action == TC_ACT_SHOT) || exceed_mtu) {\n\t\tqstats_drop_inc(this_cpu_ptr(ife->common.cpu_qstats));\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tif (skb_at_tc_ingress(skb))\n\t\tskb_push(skb, skb->dev->hard_header_len);\n\n\tife_meta = ife_encode(skb, metalen);\n\n\tspin_lock(&ife->tcf_lock);\n\n\t \n\tlist_for_each_entry(e, &ife->metalist, metalist) {\n\t\tif (e->ops->encode) {\n\t\t\terr = e->ops->encode(skb, (void *)(ife_meta + skboff),\n\t\t\t\t\t     e);\n\t\t}\n\t\tif (err < 0) {\n\t\t\t \n\t\t\tspin_unlock(&ife->tcf_lock);\n\t\t\tqstats_drop_inc(this_cpu_ptr(ife->common.cpu_qstats));\n\t\t\treturn TC_ACT_SHOT;\n\t\t}\n\t\tskboff += err;\n\t}\n\tspin_unlock(&ife->tcf_lock);\n\toethh = (struct ethhdr *)skb->data;\n\n\tif (!is_zero_ether_addr(p->eth_src))\n\t\tether_addr_copy(oethh->h_source, p->eth_src);\n\tif (!is_zero_ether_addr(p->eth_dst))\n\t\tether_addr_copy(oethh->h_dest, p->eth_dst);\n\toethh->h_proto = htons(p->eth_type);\n\n\tif (skb_at_tc_ingress(skb))\n\t\tskb_pull(skb, skb->dev->hard_header_len);\n\n\treturn action;\n}\n\nTC_INDIRECT_SCOPE int tcf_ife_act(struct sk_buff *skb,\n\t\t\t\t  const struct tc_action *a,\n\t\t\t\t  struct tcf_result *res)\n{\n\tstruct tcf_ife_info *ife = to_ife(a);\n\tstruct tcf_ife_params *p;\n\tint ret;\n\n\tp = rcu_dereference_bh(ife->params);\n\tif (p->flags & IFE_ENCODE) {\n\t\tret = tcf_ife_encode(skb, a, res, p);\n\t\treturn ret;\n\t}\n\n\treturn tcf_ife_decode(skb, a, res);\n}\n\nstatic struct tc_action_ops act_ife_ops = {\n\t.kind = \"ife\",\n\t.id = TCA_ID_IFE,\n\t.owner = THIS_MODULE,\n\t.act = tcf_ife_act,\n\t.dump = tcf_ife_dump,\n\t.cleanup = tcf_ife_cleanup,\n\t.init = tcf_ife_init,\n\t.size =\tsizeof(struct tcf_ife_info),\n};\n\nstatic __net_init int ife_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_ife_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_ife_ops);\n}\n\nstatic void __net_exit ife_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_ife_ops.net_id);\n}\n\nstatic struct pernet_operations ife_net_ops = {\n\t.init = ife_init_net,\n\t.exit_batch = ife_exit_net,\n\t.id   = &act_ife_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nstatic int __init ife_init_module(void)\n{\n\treturn tcf_register_action(&act_ife_ops, &ife_net_ops);\n}\n\nstatic void __exit ife_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_ife_ops, &ife_net_ops);\n}\n\nmodule_init(ife_init_module);\nmodule_exit(ife_cleanup_module);\n\nMODULE_AUTHOR(\"Jamal Hadi Salim(2015)\");\nMODULE_DESCRIPTION(\"Inter-FE LFB action\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}