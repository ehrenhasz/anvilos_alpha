{
  "module_name": "cls_bpf.c",
  "hash_id": "a19de8708158442712d4490622ed3046aba74626e3842b125024410e855e1b96",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/cls_bpf.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/idr.h>\n\n#include <net/rtnetlink.h>\n#include <net/pkt_cls.h>\n#include <net/sock.h>\n#include <net/tc_wrapper.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Daniel Borkmann <dborkman@redhat.com>\");\nMODULE_DESCRIPTION(\"TC BPF based classifier\");\n\n#define CLS_BPF_NAME_LEN\t256\n#define CLS_BPF_SUPPORTED_GEN_FLAGS\t\t\\\n\t(TCA_CLS_FLAGS_SKIP_HW | TCA_CLS_FLAGS_SKIP_SW)\n\nstruct cls_bpf_head {\n\tstruct list_head plist;\n\tstruct idr handle_idr;\n\tstruct rcu_head rcu;\n};\n\nstruct cls_bpf_prog {\n\tstruct bpf_prog *filter;\n\tstruct list_head link;\n\tstruct tcf_result res;\n\tbool exts_integrated;\n\tu32 gen_flags;\n\tunsigned int in_hw_count;\n\tstruct tcf_exts exts;\n\tu32 handle;\n\tu16 bpf_num_ops;\n\tstruct sock_filter *bpf_ops;\n\tconst char *bpf_name;\n\tstruct tcf_proto *tp;\n\tstruct rcu_work rwork;\n};\n\nstatic const struct nla_policy bpf_policy[TCA_BPF_MAX + 1] = {\n\t[TCA_BPF_CLASSID]\t= { .type = NLA_U32 },\n\t[TCA_BPF_FLAGS]\t\t= { .type = NLA_U32 },\n\t[TCA_BPF_FLAGS_GEN]\t= { .type = NLA_U32 },\n\t[TCA_BPF_FD]\t\t= { .type = NLA_U32 },\n\t[TCA_BPF_NAME]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = CLS_BPF_NAME_LEN },\n\t[TCA_BPF_OPS_LEN]\t= { .type = NLA_U16 },\n\t[TCA_BPF_OPS]\t\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct sock_filter) * BPF_MAXINSNS },\n};\n\nstatic int cls_bpf_exec_opcode(int code)\n{\n\tswitch (code) {\n\tcase TC_ACT_OK:\n\tcase TC_ACT_SHOT:\n\tcase TC_ACT_STOLEN:\n\tcase TC_ACT_TRAP:\n\tcase TC_ACT_REDIRECT:\n\tcase TC_ACT_UNSPEC:\n\t\treturn code;\n\tdefault:\n\t\treturn TC_ACT_UNSPEC;\n\t}\n}\n\nTC_INDIRECT_SCOPE int cls_bpf_classify(struct sk_buff *skb,\n\t\t\t\t       const struct tcf_proto *tp,\n\t\t\t\t       struct tcf_result *res)\n{\n\tstruct cls_bpf_head *head = rcu_dereference_bh(tp->root);\n\tbool at_ingress = skb_at_tc_ingress(skb);\n\tstruct cls_bpf_prog *prog;\n\tint ret = -1;\n\n\tlist_for_each_entry_rcu(prog, &head->plist, link) {\n\t\tint filter_res;\n\n\t\tqdisc_skb_cb(skb)->tc_classid = prog->res.classid;\n\n\t\tif (tc_skip_sw(prog->gen_flags)) {\n\t\t\tfilter_res = prog->exts_integrated ? TC_ACT_UNSPEC : 0;\n\t\t} else if (at_ingress) {\n\t\t\t \n\t\t\t__skb_push(skb, skb->mac_len);\n\t\t\tbpf_compute_data_pointers(skb);\n\t\t\tfilter_res = bpf_prog_run(prog->filter, skb);\n\t\t\t__skb_pull(skb, skb->mac_len);\n\t\t} else {\n\t\t\tbpf_compute_data_pointers(skb);\n\t\t\tfilter_res = bpf_prog_run(prog->filter, skb);\n\t\t}\n\t\tif (unlikely(!skb->tstamp && skb->mono_delivery_time))\n\t\t\tskb->mono_delivery_time = 0;\n\n\t\tif (prog->exts_integrated) {\n\t\t\tres->class   = 0;\n\t\t\tres->classid = TC_H_MAJ(prog->res.classid) |\n\t\t\t\t       qdisc_skb_cb(skb)->tc_classid;\n\n\t\t\tret = cls_bpf_exec_opcode(filter_res);\n\t\t\tif (ret == TC_ACT_UNSPEC)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (filter_res == 0)\n\t\t\tcontinue;\n\t\tif (filter_res != -1) {\n\t\t\tres->class   = 0;\n\t\t\tres->classid = filter_res;\n\t\t} else {\n\t\t\t*res = prog->res;\n\t\t}\n\n\t\tret = tcf_exts_exec(skb, &prog->exts, res);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic bool cls_bpf_is_ebpf(const struct cls_bpf_prog *prog)\n{\n\treturn !prog->bpf_ops;\n}\n\nstatic int cls_bpf_offload_cmd(struct tcf_proto *tp, struct cls_bpf_prog *prog,\n\t\t\t       struct cls_bpf_prog *oldprog,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct tc_cls_bpf_offload cls_bpf = {};\n\tstruct cls_bpf_prog *obj;\n\tbool skip_sw;\n\tint err;\n\n\tskip_sw = prog && tc_skip_sw(prog->gen_flags);\n\tobj = prog ?: oldprog;\n\n\ttc_cls_common_offload_init(&cls_bpf.common, tp, obj->gen_flags, extack);\n\tcls_bpf.command = TC_CLSBPF_OFFLOAD;\n\tcls_bpf.exts = &obj->exts;\n\tcls_bpf.prog = prog ? prog->filter : NULL;\n\tcls_bpf.oldprog = oldprog ? oldprog->filter : NULL;\n\tcls_bpf.name = obj->bpf_name;\n\tcls_bpf.exts_integrated = obj->exts_integrated;\n\n\tif (oldprog && prog)\n\t\terr = tc_setup_cb_replace(block, tp, TC_SETUP_CLSBPF, &cls_bpf,\n\t\t\t\t\t  skip_sw, &oldprog->gen_flags,\n\t\t\t\t\t  &oldprog->in_hw_count,\n\t\t\t\t\t  &prog->gen_flags, &prog->in_hw_count,\n\t\t\t\t\t  true);\n\telse if (prog)\n\t\terr = tc_setup_cb_add(block, tp, TC_SETUP_CLSBPF, &cls_bpf,\n\t\t\t\t      skip_sw, &prog->gen_flags,\n\t\t\t\t      &prog->in_hw_count, true);\n\telse\n\t\terr = tc_setup_cb_destroy(block, tp, TC_SETUP_CLSBPF, &cls_bpf,\n\t\t\t\t\t  skip_sw, &oldprog->gen_flags,\n\t\t\t\t\t  &oldprog->in_hw_count, true);\n\n\tif (prog && err) {\n\t\tcls_bpf_offload_cmd(tp, oldprog, prog, extack);\n\t\treturn err;\n\t}\n\n\tif (prog && skip_sw && !(prog->gen_flags & TCA_CLS_FLAGS_IN_HW))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic u32 cls_bpf_flags(u32 flags)\n{\n\treturn flags & CLS_BPF_SUPPORTED_GEN_FLAGS;\n}\n\nstatic int cls_bpf_offload(struct tcf_proto *tp, struct cls_bpf_prog *prog,\n\t\t\t   struct cls_bpf_prog *oldprog,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tif (prog && oldprog &&\n\t    cls_bpf_flags(prog->gen_flags) !=\n\t    cls_bpf_flags(oldprog->gen_flags))\n\t\treturn -EINVAL;\n\n\tif (prog && tc_skip_hw(prog->gen_flags))\n\t\tprog = NULL;\n\tif (oldprog && tc_skip_hw(oldprog->gen_flags))\n\t\toldprog = NULL;\n\tif (!prog && !oldprog)\n\t\treturn 0;\n\n\treturn cls_bpf_offload_cmd(tp, prog, oldprog, extack);\n}\n\nstatic void cls_bpf_stop_offload(struct tcf_proto *tp,\n\t\t\t\t struct cls_bpf_prog *prog,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = cls_bpf_offload_cmd(tp, NULL, prog, extack);\n\tif (err)\n\t\tpr_err(\"Stopping hardware offload failed: %d\\n\", err);\n}\n\nstatic void cls_bpf_offload_update_stats(struct tcf_proto *tp,\n\t\t\t\t\t struct cls_bpf_prog *prog)\n{\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct tc_cls_bpf_offload cls_bpf = {};\n\n\ttc_cls_common_offload_init(&cls_bpf.common, tp, prog->gen_flags, NULL);\n\tcls_bpf.command = TC_CLSBPF_STATS;\n\tcls_bpf.exts = &prog->exts;\n\tcls_bpf.prog = prog->filter;\n\tcls_bpf.name = prog->bpf_name;\n\tcls_bpf.exts_integrated = prog->exts_integrated;\n\n\ttc_setup_cb_call(block, TC_SETUP_CLSBPF, &cls_bpf, false, true);\n}\n\nstatic int cls_bpf_init(struct tcf_proto *tp)\n{\n\tstruct cls_bpf_head *head;\n\n\thead = kzalloc(sizeof(*head), GFP_KERNEL);\n\tif (head == NULL)\n\t\treturn -ENOBUFS;\n\n\tINIT_LIST_HEAD_RCU(&head->plist);\n\tidr_init(&head->handle_idr);\n\trcu_assign_pointer(tp->root, head);\n\n\treturn 0;\n}\n\nstatic void cls_bpf_free_parms(struct cls_bpf_prog *prog)\n{\n\tif (cls_bpf_is_ebpf(prog))\n\t\tbpf_prog_put(prog->filter);\n\telse\n\t\tbpf_prog_destroy(prog->filter);\n\n\tkfree(prog->bpf_name);\n\tkfree(prog->bpf_ops);\n}\n\nstatic void __cls_bpf_delete_prog(struct cls_bpf_prog *prog)\n{\n\ttcf_exts_destroy(&prog->exts);\n\ttcf_exts_put_net(&prog->exts);\n\n\tcls_bpf_free_parms(prog);\n\tkfree(prog);\n}\n\nstatic void cls_bpf_delete_prog_work(struct work_struct *work)\n{\n\tstruct cls_bpf_prog *prog = container_of(to_rcu_work(work),\n\t\t\t\t\t\t struct cls_bpf_prog,\n\t\t\t\t\t\t rwork);\n\trtnl_lock();\n\t__cls_bpf_delete_prog(prog);\n\trtnl_unlock();\n}\n\nstatic void __cls_bpf_delete(struct tcf_proto *tp, struct cls_bpf_prog *prog,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct cls_bpf_head *head = rtnl_dereference(tp->root);\n\n\tidr_remove(&head->handle_idr, prog->handle);\n\tcls_bpf_stop_offload(tp, prog, extack);\n\tlist_del_rcu(&prog->link);\n\ttcf_unbind_filter(tp, &prog->res);\n\tif (tcf_exts_get_net(&prog->exts))\n\t\ttcf_queue_work(&prog->rwork, cls_bpf_delete_prog_work);\n\telse\n\t\t__cls_bpf_delete_prog(prog);\n}\n\nstatic int cls_bpf_delete(struct tcf_proto *tp, void *arg, bool *last,\n\t\t\t  bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct cls_bpf_head *head = rtnl_dereference(tp->root);\n\n\t__cls_bpf_delete(tp, arg, extack);\n\t*last = list_empty(&head->plist);\n\treturn 0;\n}\n\nstatic void cls_bpf_destroy(struct tcf_proto *tp, bool rtnl_held,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct cls_bpf_head *head = rtnl_dereference(tp->root);\n\tstruct cls_bpf_prog *prog, *tmp;\n\n\tlist_for_each_entry_safe(prog, tmp, &head->plist, link)\n\t\t__cls_bpf_delete(tp, prog, extack);\n\n\tidr_destroy(&head->handle_idr);\n\tkfree_rcu(head, rcu);\n}\n\nstatic void *cls_bpf_get(struct tcf_proto *tp, u32 handle)\n{\n\tstruct cls_bpf_head *head = rtnl_dereference(tp->root);\n\tstruct cls_bpf_prog *prog;\n\n\tlist_for_each_entry(prog, &head->plist, link) {\n\t\tif (prog->handle == handle)\n\t\t\treturn prog;\n\t}\n\n\treturn NULL;\n}\n\nstatic int cls_bpf_prog_from_ops(struct nlattr **tb, struct cls_bpf_prog *prog)\n{\n\tstruct sock_filter *bpf_ops;\n\tstruct sock_fprog_kern fprog_tmp;\n\tstruct bpf_prog *fp;\n\tu16 bpf_size, bpf_num_ops;\n\tint ret;\n\n\tbpf_num_ops = nla_get_u16(tb[TCA_BPF_OPS_LEN]);\n\tif (bpf_num_ops > BPF_MAXINSNS || bpf_num_ops == 0)\n\t\treturn -EINVAL;\n\n\tbpf_size = bpf_num_ops * sizeof(*bpf_ops);\n\tif (bpf_size != nla_len(tb[TCA_BPF_OPS]))\n\t\treturn -EINVAL;\n\n\tbpf_ops = kmemdup(nla_data(tb[TCA_BPF_OPS]), bpf_size, GFP_KERNEL);\n\tif (bpf_ops == NULL)\n\t\treturn -ENOMEM;\n\n\tfprog_tmp.len = bpf_num_ops;\n\tfprog_tmp.filter = bpf_ops;\n\n\tret = bpf_prog_create(&fp, &fprog_tmp);\n\tif (ret < 0) {\n\t\tkfree(bpf_ops);\n\t\treturn ret;\n\t}\n\n\tprog->bpf_ops = bpf_ops;\n\tprog->bpf_num_ops = bpf_num_ops;\n\tprog->bpf_name = NULL;\n\tprog->filter = fp;\n\n\treturn 0;\n}\n\nstatic int cls_bpf_prog_from_efd(struct nlattr **tb, struct cls_bpf_prog *prog,\n\t\t\t\t u32 gen_flags, const struct tcf_proto *tp)\n{\n\tstruct bpf_prog *fp;\n\tchar *name = NULL;\n\tbool skip_sw;\n\tu32 bpf_fd;\n\n\tbpf_fd = nla_get_u32(tb[TCA_BPF_FD]);\n\tskip_sw = gen_flags & TCA_CLS_FLAGS_SKIP_SW;\n\n\tfp = bpf_prog_get_type_dev(bpf_fd, BPF_PROG_TYPE_SCHED_CLS, skip_sw);\n\tif (IS_ERR(fp))\n\t\treturn PTR_ERR(fp);\n\n\tif (tb[TCA_BPF_NAME]) {\n\t\tname = nla_memdup(tb[TCA_BPF_NAME], GFP_KERNEL);\n\t\tif (!name) {\n\t\t\tbpf_prog_put(fp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tprog->bpf_ops = NULL;\n\tprog->bpf_name = name;\n\tprog->filter = fp;\n\n\tif (fp->dst_needed)\n\t\ttcf_block_netif_keep_dst(tp->chain->block);\n\n\treturn 0;\n}\n\nstatic int cls_bpf_change(struct net *net, struct sk_buff *in_skb,\n\t\t\t  struct tcf_proto *tp, unsigned long base,\n\t\t\t  u32 handle, struct nlattr **tca,\n\t\t\t  void **arg, u32 flags,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct cls_bpf_head *head = rtnl_dereference(tp->root);\n\tbool is_bpf, is_ebpf, have_exts = false;\n\tstruct cls_bpf_prog *oldprog = *arg;\n\tstruct nlattr *tb[TCA_BPF_MAX + 1];\n\tbool bound_to_filter = false;\n\tstruct cls_bpf_prog *prog;\n\tu32 gen_flags = 0;\n\tint ret;\n\n\tif (tca[TCA_OPTIONS] == NULL)\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested_deprecated(tb, TCA_BPF_MAX, tca[TCA_OPTIONS],\n\t\t\t\t\t  bpf_policy, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tprog = kzalloc(sizeof(*prog), GFP_KERNEL);\n\tif (!prog)\n\t\treturn -ENOBUFS;\n\n\tret = tcf_exts_init(&prog->exts, net, TCA_BPF_ACT, TCA_BPF_POLICE);\n\tif (ret < 0)\n\t\tgoto errout;\n\n\tif (oldprog) {\n\t\tif (handle && oldprog->handle != handle) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (handle == 0) {\n\t\thandle = 1;\n\t\tret = idr_alloc_u32(&head->handle_idr, prog, &handle,\n\t\t\t\t    INT_MAX, GFP_KERNEL);\n\t} else if (!oldprog) {\n\t\tret = idr_alloc_u32(&head->handle_idr, prog, &handle,\n\t\t\t\t    handle, GFP_KERNEL);\n\t}\n\n\tif (ret)\n\t\tgoto errout;\n\tprog->handle = handle;\n\n\tis_bpf = tb[TCA_BPF_OPS_LEN] && tb[TCA_BPF_OPS];\n\tis_ebpf = tb[TCA_BPF_FD];\n\tif ((!is_bpf && !is_ebpf) || (is_bpf && is_ebpf)) {\n\t\tret = -EINVAL;\n\t\tgoto errout_idr;\n\t}\n\n\tret = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &prog->exts,\n\t\t\t\tflags, extack);\n\tif (ret < 0)\n\t\tgoto errout_idr;\n\n\tif (tb[TCA_BPF_FLAGS]) {\n\t\tu32 bpf_flags = nla_get_u32(tb[TCA_BPF_FLAGS]);\n\n\t\tif (bpf_flags & ~TCA_BPF_FLAG_ACT_DIRECT) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto errout_idr;\n\t\t}\n\n\t\thave_exts = bpf_flags & TCA_BPF_FLAG_ACT_DIRECT;\n\t}\n\tif (tb[TCA_BPF_FLAGS_GEN]) {\n\t\tgen_flags = nla_get_u32(tb[TCA_BPF_FLAGS_GEN]);\n\t\tif (gen_flags & ~CLS_BPF_SUPPORTED_GEN_FLAGS ||\n\t\t    !tc_flags_valid(gen_flags)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto errout_idr;\n\t\t}\n\t}\n\n\tprog->exts_integrated = have_exts;\n\tprog->gen_flags = gen_flags;\n\n\tret = is_bpf ? cls_bpf_prog_from_ops(tb, prog) :\n\t\tcls_bpf_prog_from_efd(tb, prog, gen_flags, tp);\n\tif (ret < 0)\n\t\tgoto errout_idr;\n\n\tif (tb[TCA_BPF_CLASSID]) {\n\t\tprog->res.classid = nla_get_u32(tb[TCA_BPF_CLASSID]);\n\t\ttcf_bind_filter(tp, &prog->res, base);\n\t\tbound_to_filter = true;\n\t}\n\n\tret = cls_bpf_offload(tp, prog, oldprog, extack);\n\tif (ret)\n\t\tgoto errout_parms;\n\n\tif (!tc_in_hw(prog->gen_flags))\n\t\tprog->gen_flags |= TCA_CLS_FLAGS_NOT_IN_HW;\n\n\tif (oldprog) {\n\t\tidr_replace(&head->handle_idr, prog, handle);\n\t\tlist_replace_rcu(&oldprog->link, &prog->link);\n\t\ttcf_unbind_filter(tp, &oldprog->res);\n\t\ttcf_exts_get_net(&oldprog->exts);\n\t\ttcf_queue_work(&oldprog->rwork, cls_bpf_delete_prog_work);\n\t} else {\n\t\tlist_add_rcu(&prog->link, &head->plist);\n\t}\n\n\t*arg = prog;\n\treturn 0;\n\nerrout_parms:\n\tif (bound_to_filter)\n\t\ttcf_unbind_filter(tp, &prog->res);\n\tcls_bpf_free_parms(prog);\nerrout_idr:\n\tif (!oldprog)\n\t\tidr_remove(&head->handle_idr, prog->handle);\nerrout:\n\ttcf_exts_destroy(&prog->exts);\n\tkfree(prog);\n\treturn ret;\n}\n\nstatic int cls_bpf_dump_bpf_info(const struct cls_bpf_prog *prog,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct nlattr *nla;\n\n\tif (nla_put_u16(skb, TCA_BPF_OPS_LEN, prog->bpf_num_ops))\n\t\treturn -EMSGSIZE;\n\n\tnla = nla_reserve(skb, TCA_BPF_OPS, prog->bpf_num_ops *\n\t\t\t  sizeof(struct sock_filter));\n\tif (nla == NULL)\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(nla_data(nla), prog->bpf_ops, nla_len(nla));\n\n\treturn 0;\n}\n\nstatic int cls_bpf_dump_ebpf_info(const struct cls_bpf_prog *prog,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct nlattr *nla;\n\n\tif (prog->bpf_name &&\n\t    nla_put_string(skb, TCA_BPF_NAME, prog->bpf_name))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, TCA_BPF_ID, prog->filter->aux->id))\n\t\treturn -EMSGSIZE;\n\n\tnla = nla_reserve(skb, TCA_BPF_TAG, sizeof(prog->filter->tag));\n\tif (nla == NULL)\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(nla_data(nla), prog->filter->tag, nla_len(nla));\n\n\treturn 0;\n}\n\nstatic int cls_bpf_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t\tstruct sk_buff *skb, struct tcmsg *tm, bool rtnl_held)\n{\n\tstruct cls_bpf_prog *prog = fh;\n\tstruct nlattr *nest;\n\tu32 bpf_flags = 0;\n\tint ret;\n\n\tif (prog == NULL)\n\t\treturn skb->len;\n\n\ttm->tcm_handle = prog->handle;\n\n\tcls_bpf_offload_update_stats(tp, prog);\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (prog->res.classid &&\n\t    nla_put_u32(skb, TCA_BPF_CLASSID, prog->res.classid))\n\t\tgoto nla_put_failure;\n\n\tif (cls_bpf_is_ebpf(prog))\n\t\tret = cls_bpf_dump_ebpf_info(prog, skb);\n\telse\n\t\tret = cls_bpf_dump_bpf_info(prog, skb);\n\tif (ret)\n\t\tgoto nla_put_failure;\n\n\tif (tcf_exts_dump(skb, &prog->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (prog->exts_integrated)\n\t\tbpf_flags |= TCA_BPF_FLAG_ACT_DIRECT;\n\tif (bpf_flags && nla_put_u32(skb, TCA_BPF_FLAGS, bpf_flags))\n\t\tgoto nla_put_failure;\n\tif (prog->gen_flags &&\n\t    nla_put_u32(skb, TCA_BPF_FLAGS_GEN, prog->gen_flags))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tif (tcf_exts_dump_stats(skb, &prog->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic void cls_bpf_bind_class(void *fh, u32 classid, unsigned long cl,\n\t\t\t       void *q, unsigned long base)\n{\n\tstruct cls_bpf_prog *prog = fh;\n\n\ttc_cls_bind_class(classid, cl, q, &prog->res, base);\n}\n\nstatic void cls_bpf_walk(struct tcf_proto *tp, struct tcf_walker *arg,\n\t\t\t bool rtnl_held)\n{\n\tstruct cls_bpf_head *head = rtnl_dereference(tp->root);\n\tstruct cls_bpf_prog *prog;\n\n\tlist_for_each_entry(prog, &head->plist, link) {\n\t\tif (!tc_cls_stats_dump(tp, arg, prog))\n\t\t\tbreak;\n\t}\n}\n\nstatic int cls_bpf_reoffload(struct tcf_proto *tp, bool add, flow_setup_cb_t *cb,\n\t\t\t     void *cb_priv, struct netlink_ext_ack *extack)\n{\n\tstruct cls_bpf_head *head = rtnl_dereference(tp->root);\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct tc_cls_bpf_offload cls_bpf = {};\n\tstruct cls_bpf_prog *prog;\n\tint err;\n\n\tlist_for_each_entry(prog, &head->plist, link) {\n\t\tif (tc_skip_hw(prog->gen_flags))\n\t\t\tcontinue;\n\n\t\ttc_cls_common_offload_init(&cls_bpf.common, tp, prog->gen_flags,\n\t\t\t\t\t   extack);\n\t\tcls_bpf.command = TC_CLSBPF_OFFLOAD;\n\t\tcls_bpf.exts = &prog->exts;\n\t\tcls_bpf.prog = add ? prog->filter : NULL;\n\t\tcls_bpf.oldprog = add ? NULL : prog->filter;\n\t\tcls_bpf.name = prog->bpf_name;\n\t\tcls_bpf.exts_integrated = prog->exts_integrated;\n\n\t\terr = tc_setup_cb_reoffload(block, tp, add, cb, TC_SETUP_CLSBPF,\n\t\t\t\t\t    &cls_bpf, cb_priv, &prog->gen_flags,\n\t\t\t\t\t    &prog->in_hw_count);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct tcf_proto_ops cls_bpf_ops __read_mostly = {\n\t.kind\t\t=\t\"bpf\",\n\t.owner\t\t=\tTHIS_MODULE,\n\t.classify\t=\tcls_bpf_classify,\n\t.init\t\t=\tcls_bpf_init,\n\t.destroy\t=\tcls_bpf_destroy,\n\t.get\t\t=\tcls_bpf_get,\n\t.change\t\t=\tcls_bpf_change,\n\t.delete\t\t=\tcls_bpf_delete,\n\t.walk\t\t=\tcls_bpf_walk,\n\t.reoffload\t=\tcls_bpf_reoffload,\n\t.dump\t\t=\tcls_bpf_dump,\n\t.bind_class\t=\tcls_bpf_bind_class,\n};\n\nstatic int __init cls_bpf_init_mod(void)\n{\n\treturn register_tcf_proto_ops(&cls_bpf_ops);\n}\n\nstatic void __exit cls_bpf_exit_mod(void)\n{\n\tunregister_tcf_proto_ops(&cls_bpf_ops);\n}\n\nmodule_init(cls_bpf_init_mod);\nmodule_exit(cls_bpf_exit_mod);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}