{
  "module_name": "act_bpf.c",
  "hash_id": "c444e8c30981914ab2d84911eea277fb1ad05db1d6249724f767040ef5f4f1ed",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_bpf.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n\n#include <linux/tc_act/tc_bpf.h>\n#include <net/tc_act/tc_bpf.h>\n#include <net/tc_wrapper.h>\n\n#define ACT_BPF_NAME_LEN\t256\n\nstruct tcf_bpf_cfg {\n\tstruct bpf_prog *filter;\n\tstruct sock_filter *bpf_ops;\n\tconst char *bpf_name;\n\tu16 bpf_num_ops;\n\tbool is_ebpf;\n};\n\nstatic struct tc_action_ops act_bpf_ops;\n\nTC_INDIRECT_SCOPE int tcf_bpf_act(struct sk_buff *skb,\n\t\t\t\t  const struct tc_action *act,\n\t\t\t\t  struct tcf_result *res)\n{\n\tbool at_ingress = skb_at_tc_ingress(skb);\n\tstruct tcf_bpf *prog = to_bpf(act);\n\tstruct bpf_prog *filter;\n\tint action, filter_res;\n\n\ttcf_lastuse_update(&prog->tcf_tm);\n\tbstats_update(this_cpu_ptr(prog->common.cpu_bstats), skb);\n\n\tfilter = rcu_dereference(prog->filter);\n\tif (at_ingress) {\n\t\t__skb_push(skb, skb->mac_len);\n\t\tbpf_compute_data_pointers(skb);\n\t\tfilter_res = bpf_prog_run(filter, skb);\n\t\t__skb_pull(skb, skb->mac_len);\n\t} else {\n\t\tbpf_compute_data_pointers(skb);\n\t\tfilter_res = bpf_prog_run(filter, skb);\n\t}\n\tif (unlikely(!skb->tstamp && skb->mono_delivery_time))\n\t\tskb->mono_delivery_time = 0;\n\tif (skb_sk_is_prefetched(skb) && filter_res != TC_ACT_OK)\n\t\tskb_orphan(skb);\n\n\t \n\tswitch (filter_res) {\n\tcase TC_ACT_PIPE:\n\tcase TC_ACT_RECLASSIFY:\n\tcase TC_ACT_OK:\n\tcase TC_ACT_REDIRECT:\n\t\taction = filter_res;\n\t\tbreak;\n\tcase TC_ACT_SHOT:\n\t\taction = filter_res;\n\t\tqstats_drop_inc(this_cpu_ptr(prog->common.cpu_qstats));\n\t\tbreak;\n\tcase TC_ACT_UNSPEC:\n\t\taction = prog->tcf_action;\n\t\tbreak;\n\tdefault:\n\t\taction = TC_ACT_UNSPEC;\n\t\tbreak;\n\t}\n\n\treturn action;\n}\n\nstatic bool tcf_bpf_is_ebpf(const struct tcf_bpf *prog)\n{\n\treturn !prog->bpf_ops;\n}\n\nstatic int tcf_bpf_dump_bpf_info(const struct tcf_bpf *prog,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct nlattr *nla;\n\n\tif (nla_put_u16(skb, TCA_ACT_BPF_OPS_LEN, prog->bpf_num_ops))\n\t\treturn -EMSGSIZE;\n\n\tnla = nla_reserve(skb, TCA_ACT_BPF_OPS, prog->bpf_num_ops *\n\t\t\t  sizeof(struct sock_filter));\n\tif (nla == NULL)\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(nla_data(nla), prog->bpf_ops, nla_len(nla));\n\n\treturn 0;\n}\n\nstatic int tcf_bpf_dump_ebpf_info(const struct tcf_bpf *prog,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct nlattr *nla;\n\n\tif (prog->bpf_name &&\n\t    nla_put_string(skb, TCA_ACT_BPF_NAME, prog->bpf_name))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, TCA_ACT_BPF_ID, prog->filter->aux->id))\n\t\treturn -EMSGSIZE;\n\n\tnla = nla_reserve(skb, TCA_ACT_BPF_TAG, sizeof(prog->filter->tag));\n\tif (nla == NULL)\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(nla_data(nla), prog->filter->tag, nla_len(nla));\n\n\treturn 0;\n}\n\nstatic int tcf_bpf_dump(struct sk_buff *skb, struct tc_action *act,\n\t\t\tint bind, int ref)\n{\n\tunsigned char *tp = skb_tail_pointer(skb);\n\tstruct tcf_bpf *prog = to_bpf(act);\n\tstruct tc_act_bpf opt = {\n\t\t.index   = prog->tcf_index,\n\t\t.refcnt  = refcount_read(&prog->tcf_refcnt) - ref,\n\t\t.bindcnt = atomic_read(&prog->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t tm;\n\tint ret;\n\n\tspin_lock_bh(&prog->tcf_lock);\n\topt.action = prog->tcf_action;\n\tif (nla_put(skb, TCA_ACT_BPF_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\tif (tcf_bpf_is_ebpf(prog))\n\t\tret = tcf_bpf_dump_ebpf_info(prog, skb);\n\telse\n\t\tret = tcf_bpf_dump_bpf_info(prog, skb);\n\tif (ret)\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&tm, &prog->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_ACT_BPF_TM, sizeof(tm), &tm,\n\t\t\t  TCA_ACT_BPF_PAD))\n\t\tgoto nla_put_failure;\n\n\tspin_unlock_bh(&prog->tcf_lock);\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&prog->tcf_lock);\n\tnlmsg_trim(skb, tp);\n\treturn -1;\n}\n\nstatic const struct nla_policy act_bpf_policy[TCA_ACT_BPF_MAX + 1] = {\n\t[TCA_ACT_BPF_PARMS]\t= { .len = sizeof(struct tc_act_bpf) },\n\t[TCA_ACT_BPF_FD]\t= { .type = NLA_U32 },\n\t[TCA_ACT_BPF_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = ACT_BPF_NAME_LEN },\n\t[TCA_ACT_BPF_OPS_LEN]\t= { .type = NLA_U16 },\n\t[TCA_ACT_BPF_OPS]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct sock_filter) * BPF_MAXINSNS },\n};\n\nstatic int tcf_bpf_init_from_ops(struct nlattr **tb, struct tcf_bpf_cfg *cfg)\n{\n\tstruct sock_filter *bpf_ops;\n\tstruct sock_fprog_kern fprog_tmp;\n\tstruct bpf_prog *fp;\n\tu16 bpf_size, bpf_num_ops;\n\tint ret;\n\n\tbpf_num_ops = nla_get_u16(tb[TCA_ACT_BPF_OPS_LEN]);\n\tif (bpf_num_ops\t> BPF_MAXINSNS || bpf_num_ops == 0)\n\t\treturn -EINVAL;\n\n\tbpf_size = bpf_num_ops * sizeof(*bpf_ops);\n\tif (bpf_size != nla_len(tb[TCA_ACT_BPF_OPS]))\n\t\treturn -EINVAL;\n\n\tbpf_ops = kmemdup(nla_data(tb[TCA_ACT_BPF_OPS]), bpf_size, GFP_KERNEL);\n\tif (bpf_ops == NULL)\n\t\treturn -ENOMEM;\n\n\tfprog_tmp.len = bpf_num_ops;\n\tfprog_tmp.filter = bpf_ops;\n\n\tret = bpf_prog_create(&fp, &fprog_tmp);\n\tif (ret < 0) {\n\t\tkfree(bpf_ops);\n\t\treturn ret;\n\t}\n\n\tcfg->bpf_ops = bpf_ops;\n\tcfg->bpf_num_ops = bpf_num_ops;\n\tcfg->filter = fp;\n\tcfg->is_ebpf = false;\n\n\treturn 0;\n}\n\nstatic int tcf_bpf_init_from_efd(struct nlattr **tb, struct tcf_bpf_cfg *cfg)\n{\n\tstruct bpf_prog *fp;\n\tchar *name = NULL;\n\tu32 bpf_fd;\n\n\tbpf_fd = nla_get_u32(tb[TCA_ACT_BPF_FD]);\n\n\tfp = bpf_prog_get_type(bpf_fd, BPF_PROG_TYPE_SCHED_ACT);\n\tif (IS_ERR(fp))\n\t\treturn PTR_ERR(fp);\n\n\tif (tb[TCA_ACT_BPF_NAME]) {\n\t\tname = nla_memdup(tb[TCA_ACT_BPF_NAME], GFP_KERNEL);\n\t\tif (!name) {\n\t\t\tbpf_prog_put(fp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tcfg->bpf_name = name;\n\tcfg->filter = fp;\n\tcfg->is_ebpf = true;\n\n\treturn 0;\n}\n\nstatic void tcf_bpf_cfg_cleanup(const struct tcf_bpf_cfg *cfg)\n{\n\tstruct bpf_prog *filter = cfg->filter;\n\n\tif (filter) {\n\t\tif (cfg->is_ebpf)\n\t\t\tbpf_prog_put(filter);\n\t\telse\n\t\t\tbpf_prog_destroy(filter);\n\t}\n\n\tkfree(cfg->bpf_ops);\n\tkfree(cfg->bpf_name);\n}\n\nstatic void tcf_bpf_prog_fill_cfg(const struct tcf_bpf *prog,\n\t\t\t\t  struct tcf_bpf_cfg *cfg)\n{\n\tcfg->is_ebpf = tcf_bpf_is_ebpf(prog);\n\t \n\tcfg->filter = rcu_dereference_protected(prog->filter, 1);\n\n\tcfg->bpf_ops = prog->bpf_ops;\n\tcfg->bpf_name = prog->bpf_name;\n}\n\nstatic int tcf_bpf_init(struct net *net, struct nlattr *nla,\n\t\t\tstruct nlattr *est, struct tc_action **act,\n\t\t\tstruct tcf_proto *tp, u32 flags,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_bpf_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_ACT_BPF_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tcf_bpf_cfg cfg, old;\n\tstruct tc_act_bpf *parm;\n\tstruct tcf_bpf *prog;\n\tbool is_bpf, is_ebpf;\n\tint ret, res = 0;\n\tu32 index;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested_deprecated(tb, TCA_ACT_BPF_MAX, nla,\n\t\t\t\t\t  act_bpf_policy, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!tb[TCA_ACT_BPF_PARMS])\n\t\treturn -EINVAL;\n\n\tparm = nla_data(tb[TCA_ACT_BPF_PARMS]);\n\tindex = parm->index;\n\tret = tcf_idr_check_alloc(tn, &index, act, bind);\n\tif (!ret) {\n\t\tret = tcf_idr_create(tn, index, est, act,\n\t\t\t\t     &act_bpf_ops, bind, true, flags);\n\t\tif (ret < 0) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\n\t\tres = ACT_P_CREATED;\n\t} else if (ret > 0) {\n\t\t \n\t\tif (bind)\n\t\t\treturn 0;\n\n\t\tif (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\t\ttcf_idr_release(*act, bind);\n\t\t\treturn -EEXIST;\n\t\t}\n\t} else {\n\t\treturn ret;\n\t}\n\n\tret = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (ret < 0)\n\t\tgoto release_idr;\n\n\tis_bpf = tb[TCA_ACT_BPF_OPS_LEN] && tb[TCA_ACT_BPF_OPS];\n\tis_ebpf = tb[TCA_ACT_BPF_FD];\n\n\tif (is_bpf == is_ebpf) {\n\t\tret = -EINVAL;\n\t\tgoto put_chain;\n\t}\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tret = is_bpf ? tcf_bpf_init_from_ops(tb, &cfg) :\n\t\t       tcf_bpf_init_from_efd(tb, &cfg);\n\tif (ret < 0)\n\t\tgoto put_chain;\n\n\tprog = to_bpf(*act);\n\n\tspin_lock_bh(&prog->tcf_lock);\n\tif (res != ACT_P_CREATED)\n\t\ttcf_bpf_prog_fill_cfg(prog, &old);\n\n\tprog->bpf_ops = cfg.bpf_ops;\n\tprog->bpf_name = cfg.bpf_name;\n\n\tif (cfg.bpf_num_ops)\n\t\tprog->bpf_num_ops = cfg.bpf_num_ops;\n\n\tgoto_ch = tcf_action_set_ctrlact(*act, parm->action, goto_ch);\n\trcu_assign_pointer(prog->filter, cfg.filter);\n\tspin_unlock_bh(&prog->tcf_lock);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\n\tif (res != ACT_P_CREATED) {\n\t\t \n\t\tsynchronize_rcu();\n\t\ttcf_bpf_cfg_cleanup(&old);\n\t}\n\n\treturn res;\n\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\nrelease_idr:\n\ttcf_idr_release(*act, bind);\n\treturn ret;\n}\n\nstatic void tcf_bpf_cleanup(struct tc_action *act)\n{\n\tstruct tcf_bpf_cfg tmp;\n\n\ttcf_bpf_prog_fill_cfg(to_bpf(act), &tmp);\n\ttcf_bpf_cfg_cleanup(&tmp);\n}\n\nstatic struct tc_action_ops act_bpf_ops __read_mostly = {\n\t.kind\t\t=\t\"bpf\",\n\t.id\t\t=\tTCA_ID_BPF,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_bpf_act,\n\t.dump\t\t=\ttcf_bpf_dump,\n\t.cleanup\t=\ttcf_bpf_cleanup,\n\t.init\t\t=\ttcf_bpf_init,\n\t.size\t\t=\tsizeof(struct tcf_bpf),\n};\n\nstatic __net_init int bpf_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_bpf_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_bpf_ops);\n}\n\nstatic void __net_exit bpf_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_bpf_ops.net_id);\n}\n\nstatic struct pernet_operations bpf_net_ops = {\n\t.init = bpf_init_net,\n\t.exit_batch = bpf_exit_net,\n\t.id   = &act_bpf_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nstatic int __init bpf_init_module(void)\n{\n\treturn tcf_register_action(&act_bpf_ops, &bpf_net_ops);\n}\n\nstatic void __exit bpf_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_bpf_ops, &bpf_net_ops);\n}\n\nmodule_init(bpf_init_module);\nmodule_exit(bpf_cleanup_module);\n\nMODULE_AUTHOR(\"Jiri Pirko <jiri@resnulli.us>\");\nMODULE_DESCRIPTION(\"TC BPF based action\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}