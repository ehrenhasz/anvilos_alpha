{
  "module_name": "cls_flower.c",
  "hash_id": "a38d3b00cfa2bdfa839b72b8c51a28fc3bd66a992abb7ab9ed8337b65f2b279f",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/cls_flower.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/rhashtable.h>\n#include <linux/workqueue.h>\n#include <linux/refcount.h>\n#include <linux/bitfield.h>\n\n#include <linux/if_ether.h>\n#include <linux/in6.h>\n#include <linux/ip.h>\n#include <linux/mpls.h>\n#include <linux/ppp_defs.h>\n\n#include <net/sch_generic.h>\n#include <net/pkt_cls.h>\n#include <net/pkt_sched.h>\n#include <net/ip.h>\n#include <net/flow_dissector.h>\n#include <net/geneve.h>\n#include <net/vxlan.h>\n#include <net/erspan.h>\n#include <net/gtp.h>\n#include <net/tc_wrapper.h>\n\n#include <net/dst.h>\n#include <net/dst_metadata.h>\n\n#include <uapi/linux/netfilter/nf_conntrack_common.h>\n\n#define TCA_FLOWER_KEY_CT_FLAGS_MAX \\\n\t\t((__TCA_FLOWER_KEY_CT_FLAGS_MAX - 1) << 1)\n#define TCA_FLOWER_KEY_CT_FLAGS_MASK \\\n\t\t(TCA_FLOWER_KEY_CT_FLAGS_MAX - 1)\n\nstruct fl_flow_key {\n\tstruct flow_dissector_key_meta meta;\n\tstruct flow_dissector_key_control control;\n\tstruct flow_dissector_key_control enc_control;\n\tstruct flow_dissector_key_basic basic;\n\tstruct flow_dissector_key_eth_addrs eth;\n\tstruct flow_dissector_key_vlan vlan;\n\tstruct flow_dissector_key_vlan cvlan;\n\tunion {\n\t\tstruct flow_dissector_key_ipv4_addrs ipv4;\n\t\tstruct flow_dissector_key_ipv6_addrs ipv6;\n\t};\n\tstruct flow_dissector_key_ports tp;\n\tstruct flow_dissector_key_icmp icmp;\n\tstruct flow_dissector_key_arp arp;\n\tstruct flow_dissector_key_keyid enc_key_id;\n\tunion {\n\t\tstruct flow_dissector_key_ipv4_addrs enc_ipv4;\n\t\tstruct flow_dissector_key_ipv6_addrs enc_ipv6;\n\t};\n\tstruct flow_dissector_key_ports enc_tp;\n\tstruct flow_dissector_key_mpls mpls;\n\tstruct flow_dissector_key_tcp tcp;\n\tstruct flow_dissector_key_ip ip;\n\tstruct flow_dissector_key_ip enc_ip;\n\tstruct flow_dissector_key_enc_opts enc_opts;\n\tstruct flow_dissector_key_ports_range tp_range;\n\tstruct flow_dissector_key_ct ct;\n\tstruct flow_dissector_key_hash hash;\n\tstruct flow_dissector_key_num_of_vlans num_of_vlans;\n\tstruct flow_dissector_key_pppoe pppoe;\n\tstruct flow_dissector_key_l2tpv3 l2tpv3;\n\tstruct flow_dissector_key_ipsec ipsec;\n\tstruct flow_dissector_key_cfm cfm;\n} __aligned(BITS_PER_LONG / 8);  \n\nstruct fl_flow_mask_range {\n\tunsigned short int start;\n\tunsigned short int end;\n};\n\nstruct fl_flow_mask {\n\tstruct fl_flow_key key;\n\tstruct fl_flow_mask_range range;\n\tu32 flags;\n\tstruct rhash_head ht_node;\n\tstruct rhashtable ht;\n\tstruct rhashtable_params filter_ht_params;\n\tstruct flow_dissector dissector;\n\tstruct list_head filters;\n\tstruct rcu_work rwork;\n\tstruct list_head list;\n\trefcount_t refcnt;\n};\n\nstruct fl_flow_tmplt {\n\tstruct fl_flow_key dummy_key;\n\tstruct fl_flow_key mask;\n\tstruct flow_dissector dissector;\n\tstruct tcf_chain *chain;\n};\n\nstruct cls_fl_head {\n\tstruct rhashtable ht;\n\tspinlock_t masks_lock;  \n\tstruct list_head masks;\n\tstruct list_head hw_filters;\n\tstruct rcu_work rwork;\n\tstruct idr handle_idr;\n};\n\nstruct cls_fl_filter {\n\tstruct fl_flow_mask *mask;\n\tstruct rhash_head ht_node;\n\tstruct fl_flow_key mkey;\n\tstruct tcf_exts exts;\n\tstruct tcf_result res;\n\tstruct fl_flow_key key;\n\tstruct list_head list;\n\tstruct list_head hw_list;\n\tu32 handle;\n\tu32 flags;\n\tu32 in_hw_count;\n\tu8 needs_tc_skb_ext:1;\n\tstruct rcu_work rwork;\n\tstruct net_device *hw_dev;\n\t \n\trefcount_t refcnt;\n\tbool deleted;\n};\n\nstatic const struct rhashtable_params mask_ht_params = {\n\t.key_offset = offsetof(struct fl_flow_mask, key),\n\t.key_len = sizeof(struct fl_flow_key),\n\t.head_offset = offsetof(struct fl_flow_mask, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstatic unsigned short int fl_mask_range(const struct fl_flow_mask *mask)\n{\n\treturn mask->range.end - mask->range.start;\n}\n\nstatic void fl_mask_update_range(struct fl_flow_mask *mask)\n{\n\tconst u8 *bytes = (const u8 *) &mask->key;\n\tsize_t size = sizeof(mask->key);\n\tsize_t i, first = 0, last;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (bytes[i]) {\n\t\t\tfirst = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlast = first;\n\tfor (i = size - 1; i != first; i--) {\n\t\tif (bytes[i]) {\n\t\t\tlast = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmask->range.start = rounddown(first, sizeof(long));\n\tmask->range.end = roundup(last + 1, sizeof(long));\n}\n\nstatic void *fl_key_get_start(struct fl_flow_key *key,\n\t\t\t      const struct fl_flow_mask *mask)\n{\n\treturn (u8 *) key + mask->range.start;\n}\n\nstatic void fl_set_masked_key(struct fl_flow_key *mkey, struct fl_flow_key *key,\n\t\t\t      struct fl_flow_mask *mask)\n{\n\tconst long *lkey = fl_key_get_start(key, mask);\n\tconst long *lmask = fl_key_get_start(&mask->key, mask);\n\tlong *lmkey = fl_key_get_start(mkey, mask);\n\tint i;\n\n\tfor (i = 0; i < fl_mask_range(mask); i += sizeof(long))\n\t\t*lmkey++ = *lkey++ & *lmask++;\n}\n\nstatic bool fl_mask_fits_tmplt(struct fl_flow_tmplt *tmplt,\n\t\t\t       struct fl_flow_mask *mask)\n{\n\tconst long *lmask = fl_key_get_start(&mask->key, mask);\n\tconst long *ltmplt;\n\tint i;\n\n\tif (!tmplt)\n\t\treturn true;\n\tltmplt = fl_key_get_start(&tmplt->mask, mask);\n\tfor (i = 0; i < fl_mask_range(mask); i += sizeof(long)) {\n\t\tif (~*ltmplt++ & *lmask++)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void fl_clear_masked_range(struct fl_flow_key *key,\n\t\t\t\t  struct fl_flow_mask *mask)\n{\n\tmemset(fl_key_get_start(key, mask), 0, fl_mask_range(mask));\n}\n\nstatic bool fl_range_port_dst_cmp(struct cls_fl_filter *filter,\n\t\t\t\t  struct fl_flow_key *key,\n\t\t\t\t  struct fl_flow_key *mkey)\n{\n\tu16 min_mask, max_mask, min_val, max_val;\n\n\tmin_mask = ntohs(filter->mask->key.tp_range.tp_min.dst);\n\tmax_mask = ntohs(filter->mask->key.tp_range.tp_max.dst);\n\tmin_val = ntohs(filter->key.tp_range.tp_min.dst);\n\tmax_val = ntohs(filter->key.tp_range.tp_max.dst);\n\n\tif (min_mask && max_mask) {\n\t\tif (ntohs(key->tp_range.tp.dst) < min_val ||\n\t\t    ntohs(key->tp_range.tp.dst) > max_val)\n\t\t\treturn false;\n\n\t\t \n\t\tmkey->tp_range.tp_min.dst = filter->mkey.tp_range.tp_min.dst;\n\t\tmkey->tp_range.tp_max.dst = filter->mkey.tp_range.tp_max.dst;\n\t}\n\treturn true;\n}\n\nstatic bool fl_range_port_src_cmp(struct cls_fl_filter *filter,\n\t\t\t\t  struct fl_flow_key *key,\n\t\t\t\t  struct fl_flow_key *mkey)\n{\n\tu16 min_mask, max_mask, min_val, max_val;\n\n\tmin_mask = ntohs(filter->mask->key.tp_range.tp_min.src);\n\tmax_mask = ntohs(filter->mask->key.tp_range.tp_max.src);\n\tmin_val = ntohs(filter->key.tp_range.tp_min.src);\n\tmax_val = ntohs(filter->key.tp_range.tp_max.src);\n\n\tif (min_mask && max_mask) {\n\t\tif (ntohs(key->tp_range.tp.src) < min_val ||\n\t\t    ntohs(key->tp_range.tp.src) > max_val)\n\t\t\treturn false;\n\n\t\t \n\t\tmkey->tp_range.tp_min.src = filter->mkey.tp_range.tp_min.src;\n\t\tmkey->tp_range.tp_max.src = filter->mkey.tp_range.tp_max.src;\n\t}\n\treturn true;\n}\n\nstatic struct cls_fl_filter *__fl_lookup(struct fl_flow_mask *mask,\n\t\t\t\t\t struct fl_flow_key *mkey)\n{\n\treturn rhashtable_lookup_fast(&mask->ht, fl_key_get_start(mkey, mask),\n\t\t\t\t      mask->filter_ht_params);\n}\n\nstatic struct cls_fl_filter *fl_lookup_range(struct fl_flow_mask *mask,\n\t\t\t\t\t     struct fl_flow_key *mkey,\n\t\t\t\t\t     struct fl_flow_key *key)\n{\n\tstruct cls_fl_filter *filter, *f;\n\n\tlist_for_each_entry_rcu(filter, &mask->filters, list) {\n\t\tif (!fl_range_port_dst_cmp(filter, key, mkey))\n\t\t\tcontinue;\n\n\t\tif (!fl_range_port_src_cmp(filter, key, mkey))\n\t\t\tcontinue;\n\n\t\tf = __fl_lookup(mask, mkey);\n\t\tif (f)\n\t\t\treturn f;\n\t}\n\treturn NULL;\n}\n\nstatic noinline_for_stack\nstruct cls_fl_filter *fl_mask_lookup(struct fl_flow_mask *mask, struct fl_flow_key *key)\n{\n\tstruct fl_flow_key mkey;\n\n\tfl_set_masked_key(&mkey, key, mask);\n\tif ((mask->flags & TCA_FLOWER_MASK_FLAGS_RANGE))\n\t\treturn fl_lookup_range(mask, &mkey, key);\n\n\treturn __fl_lookup(mask, &mkey);\n}\n\nstatic u16 fl_ct_info_to_flower_map[] = {\n\t[IP_CT_ESTABLISHED] =\t\tTCA_FLOWER_KEY_CT_FLAGS_TRACKED |\n\t\t\t\t\tTCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED,\n\t[IP_CT_RELATED] =\t\tTCA_FLOWER_KEY_CT_FLAGS_TRACKED |\n\t\t\t\t\tTCA_FLOWER_KEY_CT_FLAGS_RELATED,\n\t[IP_CT_ESTABLISHED_REPLY] =\tTCA_FLOWER_KEY_CT_FLAGS_TRACKED |\n\t\t\t\t\tTCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED |\n\t\t\t\t\tTCA_FLOWER_KEY_CT_FLAGS_REPLY,\n\t[IP_CT_RELATED_REPLY] =\t\tTCA_FLOWER_KEY_CT_FLAGS_TRACKED |\n\t\t\t\t\tTCA_FLOWER_KEY_CT_FLAGS_RELATED |\n\t\t\t\t\tTCA_FLOWER_KEY_CT_FLAGS_REPLY,\n\t[IP_CT_NEW] =\t\t\tTCA_FLOWER_KEY_CT_FLAGS_TRACKED |\n\t\t\t\t\tTCA_FLOWER_KEY_CT_FLAGS_NEW,\n};\n\nTC_INDIRECT_SCOPE int fl_classify(struct sk_buff *skb,\n\t\t\t\t  const struct tcf_proto *tp,\n\t\t\t\t  struct tcf_result *res)\n{\n\tstruct cls_fl_head *head = rcu_dereference_bh(tp->root);\n\tbool post_ct = tc_skb_cb(skb)->post_ct;\n\tu16 zone = tc_skb_cb(skb)->zone;\n\tstruct fl_flow_key skb_key;\n\tstruct fl_flow_mask *mask;\n\tstruct cls_fl_filter *f;\n\n\tlist_for_each_entry_rcu(mask, &head->masks, list) {\n\t\tflow_dissector_init_keys(&skb_key.control, &skb_key.basic);\n\t\tfl_clear_masked_range(&skb_key, mask);\n\n\t\tskb_flow_dissect_meta(skb, &mask->dissector, &skb_key);\n\t\t \n\t\tskb_key.basic.n_proto = skb_protocol(skb, false);\n\t\tskb_flow_dissect_tunnel_info(skb, &mask->dissector, &skb_key);\n\t\tskb_flow_dissect_ct(skb, &mask->dissector, &skb_key,\n\t\t\t\t    fl_ct_info_to_flower_map,\n\t\t\t\t    ARRAY_SIZE(fl_ct_info_to_flower_map),\n\t\t\t\t    post_ct, zone);\n\t\tskb_flow_dissect_hash(skb, &mask->dissector, &skb_key);\n\t\tskb_flow_dissect(skb, &mask->dissector, &skb_key,\n\t\t\t\t FLOW_DISSECTOR_F_STOP_BEFORE_ENCAP);\n\n\t\tf = fl_mask_lookup(mask, &skb_key);\n\t\tif (f && !tc_skip_sw(f->flags)) {\n\t\t\t*res = f->res;\n\t\t\treturn tcf_exts_exec(skb, &f->exts, res);\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int fl_init(struct tcf_proto *tp)\n{\n\tstruct cls_fl_head *head;\n\n\thead = kzalloc(sizeof(*head), GFP_KERNEL);\n\tif (!head)\n\t\treturn -ENOBUFS;\n\n\tspin_lock_init(&head->masks_lock);\n\tINIT_LIST_HEAD_RCU(&head->masks);\n\tINIT_LIST_HEAD(&head->hw_filters);\n\trcu_assign_pointer(tp->root, head);\n\tidr_init(&head->handle_idr);\n\n\treturn rhashtable_init(&head->ht, &mask_ht_params);\n}\n\nstatic void fl_mask_free(struct fl_flow_mask *mask, bool mask_init_done)\n{\n\t \n\tif (mask_init_done) {\n\t\tWARN_ON(!list_empty(&mask->filters));\n\t\trhashtable_destroy(&mask->ht);\n\t}\n\tkfree(mask);\n}\n\nstatic void fl_mask_free_work(struct work_struct *work)\n{\n\tstruct fl_flow_mask *mask = container_of(to_rcu_work(work),\n\t\t\t\t\t\t struct fl_flow_mask, rwork);\n\n\tfl_mask_free(mask, true);\n}\n\nstatic void fl_uninit_mask_free_work(struct work_struct *work)\n{\n\tstruct fl_flow_mask *mask = container_of(to_rcu_work(work),\n\t\t\t\t\t\t struct fl_flow_mask, rwork);\n\n\tfl_mask_free(mask, false);\n}\n\nstatic bool fl_mask_put(struct cls_fl_head *head, struct fl_flow_mask *mask)\n{\n\tif (!refcount_dec_and_test(&mask->refcnt))\n\t\treturn false;\n\n\trhashtable_remove_fast(&head->ht, &mask->ht_node, mask_ht_params);\n\n\tspin_lock(&head->masks_lock);\n\tlist_del_rcu(&mask->list);\n\tspin_unlock(&head->masks_lock);\n\n\ttcf_queue_work(&mask->rwork, fl_mask_free_work);\n\n\treturn true;\n}\n\nstatic struct cls_fl_head *fl_head_dereference(struct tcf_proto *tp)\n{\n\t \n\treturn rcu_dereference_raw(tp->root);\n}\n\nstatic void __fl_destroy_filter(struct cls_fl_filter *f)\n{\n\tif (f->needs_tc_skb_ext)\n\t\ttc_skb_ext_tc_disable();\n\ttcf_exts_destroy(&f->exts);\n\ttcf_exts_put_net(&f->exts);\n\tkfree(f);\n}\n\nstatic void fl_destroy_filter_work(struct work_struct *work)\n{\n\tstruct cls_fl_filter *f = container_of(to_rcu_work(work),\n\t\t\t\t\tstruct cls_fl_filter, rwork);\n\n\t__fl_destroy_filter(f);\n}\n\nstatic void fl_hw_destroy_filter(struct tcf_proto *tp, struct cls_fl_filter *f,\n\t\t\t\t bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct flow_cls_offload cls_flower = {};\n\n\ttc_cls_common_offload_init(&cls_flower.common, tp, f->flags, extack);\n\tcls_flower.command = FLOW_CLS_DESTROY;\n\tcls_flower.cookie = (unsigned long) f;\n\n\ttc_setup_cb_destroy(block, tp, TC_SETUP_CLSFLOWER, &cls_flower, false,\n\t\t\t    &f->flags, &f->in_hw_count, rtnl_held);\n\n}\n\nstatic int fl_hw_replace_filter(struct tcf_proto *tp,\n\t\t\t\tstruct cls_fl_filter *f, bool rtnl_held,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct flow_cls_offload cls_flower = {};\n\tbool skip_sw = tc_skip_sw(f->flags);\n\tint err = 0;\n\n\tcls_flower.rule = flow_rule_alloc(tcf_exts_num_actions(&f->exts));\n\tif (!cls_flower.rule)\n\t\treturn -ENOMEM;\n\n\ttc_cls_common_offload_init(&cls_flower.common, tp, f->flags, extack);\n\tcls_flower.command = FLOW_CLS_REPLACE;\n\tcls_flower.cookie = (unsigned long) f;\n\tcls_flower.rule->match.dissector = &f->mask->dissector;\n\tcls_flower.rule->match.mask = &f->mask->key;\n\tcls_flower.rule->match.key = &f->mkey;\n\tcls_flower.classid = f->res.classid;\n\n\terr = tc_setup_offload_action(&cls_flower.rule->action, &f->exts,\n\t\t\t\t      cls_flower.common.extack);\n\tif (err) {\n\t\tkfree(cls_flower.rule);\n\n\t\treturn skip_sw ? err : 0;\n\t}\n\n\terr = tc_setup_cb_add(block, tp, TC_SETUP_CLSFLOWER, &cls_flower,\n\t\t\t      skip_sw, &f->flags, &f->in_hw_count, rtnl_held);\n\ttc_cleanup_offload_action(&cls_flower.rule->action);\n\tkfree(cls_flower.rule);\n\n\tif (err) {\n\t\tfl_hw_destroy_filter(tp, f, rtnl_held, NULL);\n\t\treturn err;\n\t}\n\n\tif (skip_sw && !(f->flags & TCA_CLS_FLAGS_IN_HW))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void fl_hw_update_stats(struct tcf_proto *tp, struct cls_fl_filter *f,\n\t\t\t       bool rtnl_held)\n{\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct flow_cls_offload cls_flower = {};\n\n\ttc_cls_common_offload_init(&cls_flower.common, tp, f->flags, NULL);\n\tcls_flower.command = FLOW_CLS_STATS;\n\tcls_flower.cookie = (unsigned long) f;\n\tcls_flower.classid = f->res.classid;\n\n\ttc_setup_cb_call(block, TC_SETUP_CLSFLOWER, &cls_flower, false,\n\t\t\t rtnl_held);\n\n\ttcf_exts_hw_stats_update(&f->exts, &cls_flower.stats, cls_flower.use_act_stats);\n}\n\nstatic void __fl_put(struct cls_fl_filter *f)\n{\n\tif (!refcount_dec_and_test(&f->refcnt))\n\t\treturn;\n\n\tif (tcf_exts_get_net(&f->exts))\n\t\ttcf_queue_work(&f->rwork, fl_destroy_filter_work);\n\telse\n\t\t__fl_destroy_filter(f);\n}\n\nstatic struct cls_fl_filter *__fl_get(struct cls_fl_head *head, u32 handle)\n{\n\tstruct cls_fl_filter *f;\n\n\trcu_read_lock();\n\tf = idr_find(&head->handle_idr, handle);\n\tif (f && !refcount_inc_not_zero(&f->refcnt))\n\t\tf = NULL;\n\trcu_read_unlock();\n\n\treturn f;\n}\n\nstatic struct tcf_exts *fl_get_exts(const struct tcf_proto *tp, u32 handle)\n{\n\tstruct cls_fl_head *head = rcu_dereference_bh(tp->root);\n\tstruct cls_fl_filter *f;\n\n\tf = idr_find(&head->handle_idr, handle);\n\treturn f ? &f->exts : NULL;\n}\n\nstatic int __fl_delete(struct tcf_proto *tp, struct cls_fl_filter *f,\n\t\t       bool *last, bool rtnl_held,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct cls_fl_head *head = fl_head_dereference(tp);\n\n\t*last = false;\n\n\tspin_lock(&tp->lock);\n\tif (f->deleted) {\n\t\tspin_unlock(&tp->lock);\n\t\treturn -ENOENT;\n\t}\n\n\tf->deleted = true;\n\trhashtable_remove_fast(&f->mask->ht, &f->ht_node,\n\t\t\t       f->mask->filter_ht_params);\n\tidr_remove(&head->handle_idr, f->handle);\n\tlist_del_rcu(&f->list);\n\tspin_unlock(&tp->lock);\n\n\t*last = fl_mask_put(head, f->mask);\n\tif (!tc_skip_hw(f->flags))\n\t\tfl_hw_destroy_filter(tp, f, rtnl_held, extack);\n\ttcf_unbind_filter(tp, &f->res);\n\t__fl_put(f);\n\n\treturn 0;\n}\n\nstatic void fl_destroy_sleepable(struct work_struct *work)\n{\n\tstruct cls_fl_head *head = container_of(to_rcu_work(work),\n\t\t\t\t\t\tstruct cls_fl_head,\n\t\t\t\t\t\trwork);\n\n\trhashtable_destroy(&head->ht);\n\tkfree(head);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic void fl_destroy(struct tcf_proto *tp, bool rtnl_held,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct cls_fl_head *head = fl_head_dereference(tp);\n\tstruct fl_flow_mask *mask, *next_mask;\n\tstruct cls_fl_filter *f, *next;\n\tbool last;\n\n\tlist_for_each_entry_safe(mask, next_mask, &head->masks, list) {\n\t\tlist_for_each_entry_safe(f, next, &mask->filters, list) {\n\t\t\t__fl_delete(tp, f, &last, rtnl_held, extack);\n\t\t\tif (last)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tidr_destroy(&head->handle_idr);\n\n\t__module_get(THIS_MODULE);\n\ttcf_queue_work(&head->rwork, fl_destroy_sleepable);\n}\n\nstatic void fl_put(struct tcf_proto *tp, void *arg)\n{\n\tstruct cls_fl_filter *f = arg;\n\n\t__fl_put(f);\n}\n\nstatic void *fl_get(struct tcf_proto *tp, u32 handle)\n{\n\tstruct cls_fl_head *head = fl_head_dereference(tp);\n\n\treturn __fl_get(head, handle);\n}\n\nstatic const struct nla_policy fl_policy[TCA_FLOWER_MAX + 1] = {\n\t[TCA_FLOWER_UNSPEC]\t\t= { .strict_start_type =\n\t\t\t\t\t\tTCA_FLOWER_L2_MISS },\n\t[TCA_FLOWER_CLASSID]\t\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_INDEV]\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = IFNAMSIZ },\n\t[TCA_FLOWER_KEY_ETH_DST]\t= { .len = ETH_ALEN },\n\t[TCA_FLOWER_KEY_ETH_DST_MASK]\t= { .len = ETH_ALEN },\n\t[TCA_FLOWER_KEY_ETH_SRC]\t= { .len = ETH_ALEN },\n\t[TCA_FLOWER_KEY_ETH_SRC_MASK]\t= { .len = ETH_ALEN },\n\t[TCA_FLOWER_KEY_ETH_TYPE]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_IP_PROTO]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_IPV4_SRC]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_IPV4_SRC_MASK]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_IPV4_DST]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_IPV4_DST_MASK]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_IPV6_SRC]\t= { .len = sizeof(struct in6_addr) },\n\t[TCA_FLOWER_KEY_IPV6_SRC_MASK]\t= { .len = sizeof(struct in6_addr) },\n\t[TCA_FLOWER_KEY_IPV6_DST]\t= { .len = sizeof(struct in6_addr) },\n\t[TCA_FLOWER_KEY_IPV6_DST_MASK]\t= { .len = sizeof(struct in6_addr) },\n\t[TCA_FLOWER_KEY_TCP_SRC]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_TCP_DST]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_UDP_SRC]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_UDP_DST]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_VLAN_ID]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_VLAN_PRIO]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_VLAN_ETH_TYPE]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_ENC_KEY_ID]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ENC_IPV4_SRC]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK] = { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ENC_IPV4_DST]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ENC_IPV4_DST_MASK] = { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ENC_IPV6_SRC]\t= { .len = sizeof(struct in6_addr) },\n\t[TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK] = { .len = sizeof(struct in6_addr) },\n\t[TCA_FLOWER_KEY_ENC_IPV6_DST]\t= { .len = sizeof(struct in6_addr) },\n\t[TCA_FLOWER_KEY_ENC_IPV6_DST_MASK] = { .len = sizeof(struct in6_addr) },\n\t[TCA_FLOWER_KEY_TCP_SRC_MASK]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_TCP_DST_MASK]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_UDP_SRC_MASK]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_UDP_DST_MASK]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_SCTP_SRC_MASK]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_SCTP_DST_MASK]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_SCTP_SRC]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_SCTP_DST]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_ENC_UDP_SRC_PORT]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_ENC_UDP_SRC_PORT_MASK]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_ENC_UDP_DST_PORT]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_ENC_UDP_DST_PORT_MASK]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_FLAGS]\t\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_FLAGS_MASK]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ICMPV4_TYPE]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ICMPV4_TYPE_MASK] = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ICMPV4_CODE]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ICMPV4_CODE_MASK] = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ICMPV6_TYPE]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ICMPV6_TYPE_MASK] = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ICMPV6_CODE]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ICMPV6_CODE_MASK] = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ARP_SIP]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ARP_SIP_MASK]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ARP_TIP]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ARP_TIP_MASK]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ARP_OP]\t\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ARP_OP_MASK]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ARP_SHA]\t= { .len = ETH_ALEN },\n\t[TCA_FLOWER_KEY_ARP_SHA_MASK]\t= { .len = ETH_ALEN },\n\t[TCA_FLOWER_KEY_ARP_THA]\t= { .len = ETH_ALEN },\n\t[TCA_FLOWER_KEY_ARP_THA_MASK]\t= { .len = ETH_ALEN },\n\t[TCA_FLOWER_KEY_MPLS_TTL]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_MPLS_BOS]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_MPLS_TC]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_MPLS_LABEL]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_MPLS_OPTS]\t= { .type = NLA_NESTED },\n\t[TCA_FLOWER_KEY_TCP_FLAGS]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_TCP_FLAGS_MASK]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_IP_TOS]\t\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_IP_TOS_MASK]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_IP_TTL]\t\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_IP_TTL_MASK]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_CVLAN_ID]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_CVLAN_PRIO]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_CVLAN_ETH_TYPE]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_ENC_IP_TOS]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ENC_IP_TOS_MASK] = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ENC_IP_TTL]\t = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ENC_IP_TTL_MASK] = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ENC_OPTS]\t= { .type = NLA_NESTED },\n\t[TCA_FLOWER_KEY_ENC_OPTS_MASK]\t= { .type = NLA_NESTED },\n\t[TCA_FLOWER_KEY_CT_STATE]\t=\n\t\tNLA_POLICY_MASK(NLA_U16, TCA_FLOWER_KEY_CT_FLAGS_MASK),\n\t[TCA_FLOWER_KEY_CT_STATE_MASK]\t=\n\t\tNLA_POLICY_MASK(NLA_U16, TCA_FLOWER_KEY_CT_FLAGS_MASK),\n\t[TCA_FLOWER_KEY_CT_ZONE]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_CT_ZONE_MASK]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_CT_MARK]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_CT_MARK_MASK]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_CT_LABELS]\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = 128 / BITS_PER_BYTE },\n\t[TCA_FLOWER_KEY_CT_LABELS_MASK]\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = 128 / BITS_PER_BYTE },\n\t[TCA_FLOWER_FLAGS]\t\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_HASH]\t\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_HASH_MASK]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_NUM_OF_VLANS]\t= { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_PPPOE_SID]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_PPP_PROTO]\t= { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_L2TPV3_SID]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_SPI]\t\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_SPI_MASK]\t= { .type = NLA_U32 },\n\t[TCA_FLOWER_L2_MISS]\t\t= NLA_POLICY_MAX(NLA_U8, 1),\n\t[TCA_FLOWER_KEY_CFM]\t\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\nenc_opts_policy[TCA_FLOWER_KEY_ENC_OPTS_MAX + 1] = {\n\t[TCA_FLOWER_KEY_ENC_OPTS_UNSPEC]        = {\n\t\t.strict_start_type = TCA_FLOWER_KEY_ENC_OPTS_VXLAN },\n\t[TCA_FLOWER_KEY_ENC_OPTS_GENEVE]        = { .type = NLA_NESTED },\n\t[TCA_FLOWER_KEY_ENC_OPTS_VXLAN]         = { .type = NLA_NESTED },\n\t[TCA_FLOWER_KEY_ENC_OPTS_ERSPAN]        = { .type = NLA_NESTED },\n\t[TCA_FLOWER_KEY_ENC_OPTS_GTP]\t\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\ngeneve_opt_policy[TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX + 1] = {\n\t[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS]      = { .type = NLA_U16 },\n\t[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE]       = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA]       = { .type = NLA_BINARY,\n\t\t\t\t\t\t       .len = 128 },\n};\n\nstatic const struct nla_policy\nvxlan_opt_policy[TCA_FLOWER_KEY_ENC_OPT_VXLAN_MAX + 1] = {\n\t[TCA_FLOWER_KEY_ENC_OPT_VXLAN_GBP]         = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nerspan_opt_policy[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_MAX + 1] = {\n\t[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_VER]        = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_INDEX]      = { .type = NLA_U32 },\n\t[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_DIR]        = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_HWID]       = { .type = NLA_U8 },\n};\n\nstatic const struct nla_policy\ngtp_opt_policy[TCA_FLOWER_KEY_ENC_OPT_GTP_MAX + 1] = {\n\t[TCA_FLOWER_KEY_ENC_OPT_GTP_PDU_TYPE]\t   = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_ENC_OPT_GTP_QFI]\t   = { .type = NLA_U8 },\n};\n\nstatic const struct nla_policy\nmpls_stack_entry_policy[TCA_FLOWER_KEY_MPLS_OPT_LSE_MAX + 1] = {\n\t[TCA_FLOWER_KEY_MPLS_OPT_LSE_DEPTH]    = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_MPLS_OPT_LSE_TTL]      = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_MPLS_OPT_LSE_BOS]      = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_MPLS_OPT_LSE_TC]       = { .type = NLA_U8 },\n\t[TCA_FLOWER_KEY_MPLS_OPT_LSE_LABEL]    = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\ncfm_opt_policy[TCA_FLOWER_KEY_CFM_OPT_MAX + 1] = {\n\t[TCA_FLOWER_KEY_CFM_MD_LEVEL]\t= NLA_POLICY_MAX(NLA_U8,\n\t\t\t\t\t\tFLOW_DIS_CFM_MDL_MAX),\n\t[TCA_FLOWER_KEY_CFM_OPCODE]\t= { .type = NLA_U8 },\n};\n\nstatic void fl_set_key_val(struct nlattr **tb,\n\t\t\t   void *val, int val_type,\n\t\t\t   void *mask, int mask_type, int len)\n{\n\tif (!tb[val_type])\n\t\treturn;\n\tnla_memcpy(val, tb[val_type], len);\n\tif (mask_type == TCA_FLOWER_UNSPEC || !tb[mask_type])\n\t\tmemset(mask, 0xff, len);\n\telse\n\t\tnla_memcpy(mask, tb[mask_type], len);\n}\n\nstatic int fl_set_key_spi(struct nlattr **tb, struct fl_flow_key *key,\n\t\t\t  struct fl_flow_key *mask,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (key->basic.ip_proto != IPPROTO_ESP &&\n\t    key->basic.ip_proto != IPPROTO_AH) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Protocol must be either ESP or AH\");\n\t\treturn -EINVAL;\n\t}\n\n\tfl_set_key_val(tb, &key->ipsec.spi,\n\t\t       TCA_FLOWER_KEY_SPI,\n\t\t       &mask->ipsec.spi, TCA_FLOWER_KEY_SPI_MASK,\n\t\t       sizeof(key->ipsec.spi));\n\treturn 0;\n}\n\nstatic int fl_set_key_port_range(struct nlattr **tb, struct fl_flow_key *key,\n\t\t\t\t struct fl_flow_key *mask,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tfl_set_key_val(tb, &key->tp_range.tp_min.dst,\n\t\t       TCA_FLOWER_KEY_PORT_DST_MIN, &mask->tp_range.tp_min.dst,\n\t\t       TCA_FLOWER_UNSPEC, sizeof(key->tp_range.tp_min.dst));\n\tfl_set_key_val(tb, &key->tp_range.tp_max.dst,\n\t\t       TCA_FLOWER_KEY_PORT_DST_MAX, &mask->tp_range.tp_max.dst,\n\t\t       TCA_FLOWER_UNSPEC, sizeof(key->tp_range.tp_max.dst));\n\tfl_set_key_val(tb, &key->tp_range.tp_min.src,\n\t\t       TCA_FLOWER_KEY_PORT_SRC_MIN, &mask->tp_range.tp_min.src,\n\t\t       TCA_FLOWER_UNSPEC, sizeof(key->tp_range.tp_min.src));\n\tfl_set_key_val(tb, &key->tp_range.tp_max.src,\n\t\t       TCA_FLOWER_KEY_PORT_SRC_MAX, &mask->tp_range.tp_max.src,\n\t\t       TCA_FLOWER_UNSPEC, sizeof(key->tp_range.tp_max.src));\n\n\tif (mask->tp_range.tp_min.dst != mask->tp_range.tp_max.dst) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Both min and max destination ports must be specified\");\n\t\treturn -EINVAL;\n\t}\n\tif (mask->tp_range.tp_min.src != mask->tp_range.tp_max.src) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Both min and max source ports must be specified\");\n\t\treturn -EINVAL;\n\t}\n\tif (mask->tp_range.tp_min.dst && mask->tp_range.tp_max.dst &&\n\t    ntohs(key->tp_range.tp_max.dst) <=\n\t    ntohs(key->tp_range.tp_min.dst)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t    tb[TCA_FLOWER_KEY_PORT_DST_MIN],\n\t\t\t\t    \"Invalid destination port range (min must be strictly smaller than max)\");\n\t\treturn -EINVAL;\n\t}\n\tif (mask->tp_range.tp_min.src && mask->tp_range.tp_max.src &&\n\t    ntohs(key->tp_range.tp_max.src) <=\n\t    ntohs(key->tp_range.tp_min.src)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t    tb[TCA_FLOWER_KEY_PORT_SRC_MIN],\n\t\t\t\t    \"Invalid source port range (min must be strictly smaller than max)\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fl_set_key_mpls_lse(const struct nlattr *nla_lse,\n\t\t\t       struct flow_dissector_key_mpls *key_val,\n\t\t\t       struct flow_dissector_key_mpls *key_mask,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_MAX + 1];\n\tstruct flow_dissector_mpls_lse *lse_mask;\n\tstruct flow_dissector_mpls_lse *lse_val;\n\tu8 lse_index;\n\tu8 depth;\n\tint err;\n\n\terr = nla_parse_nested(tb, TCA_FLOWER_KEY_MPLS_OPT_LSE_MAX, nla_lse,\n\t\t\t       mpls_stack_entry_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_DEPTH]) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing MPLS option \\\"depth\\\"\");\n\t\treturn -EINVAL;\n\t}\n\n\tdepth = nla_get_u8(tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_DEPTH]);\n\n\t \n\tif (depth < 1 || depth > FLOW_DIS_MPLS_MAX) {\n\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t    tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_DEPTH],\n\t\t\t\t    \"Invalid MPLS depth\");\n\t\treturn -EINVAL;\n\t}\n\tlse_index = depth - 1;\n\n\tdissector_set_mpls_lse(key_val, lse_index);\n\tdissector_set_mpls_lse(key_mask, lse_index);\n\n\tlse_val = &key_val->ls[lse_index];\n\tlse_mask = &key_mask->ls[lse_index];\n\n\tif (tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_TTL]) {\n\t\tlse_val->mpls_ttl = nla_get_u8(tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_TTL]);\n\t\tlse_mask->mpls_ttl = MPLS_TTL_MASK;\n\t}\n\tif (tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_BOS]) {\n\t\tu8 bos = nla_get_u8(tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_BOS]);\n\n\t\tif (bos & ~MPLS_BOS_MASK) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_BOS],\n\t\t\t\t\t    \"Bottom Of Stack (BOS) must be 0 or 1\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlse_val->mpls_bos = bos;\n\t\tlse_mask->mpls_bos = MPLS_BOS_MASK;\n\t}\n\tif (tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_TC]) {\n\t\tu8 tc = nla_get_u8(tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_TC]);\n\n\t\tif (tc & ~MPLS_TC_MASK) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_TC],\n\t\t\t\t\t    \"Traffic Class (TC) must be between 0 and 7\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlse_val->mpls_tc = tc;\n\t\tlse_mask->mpls_tc = MPLS_TC_MASK;\n\t}\n\tif (tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_LABEL]) {\n\t\tu32 label = nla_get_u32(tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_LABEL]);\n\n\t\tif (label & ~MPLS_LABEL_MASK) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[TCA_FLOWER_KEY_MPLS_OPT_LSE_LABEL],\n\t\t\t\t\t    \"Label must be between 0 and 1048575\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlse_val->mpls_label = label;\n\t\tlse_mask->mpls_label = MPLS_LABEL_MASK;\n\t}\n\n\treturn 0;\n}\n\nstatic int fl_set_key_mpls_opts(const struct nlattr *nla_mpls_opts,\n\t\t\t\tstruct flow_dissector_key_mpls *key_val,\n\t\t\t\tstruct flow_dissector_key_mpls *key_mask,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr *nla_lse;\n\tint rem;\n\tint err;\n\n\tif (!(nla_mpls_opts->nla_type & NLA_F_NESTED)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla_mpls_opts,\n\t\t\t\t    \"NLA_F_NESTED is missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tnla_for_each_nested(nla_lse, nla_mpls_opts, rem) {\n\t\tif (nla_type(nla_lse) != TCA_FLOWER_KEY_MPLS_OPTS_LSE) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla_lse,\n\t\t\t\t\t    \"Invalid MPLS option type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = fl_set_key_mpls_lse(nla_lse, key_val, key_mask, extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (rem) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Bytes leftover after parsing MPLS options\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fl_set_key_mpls(struct nlattr **tb,\n\t\t\t   struct flow_dissector_key_mpls *key_val,\n\t\t\t   struct flow_dissector_key_mpls *key_mask,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct flow_dissector_mpls_lse *lse_mask;\n\tstruct flow_dissector_mpls_lse *lse_val;\n\n\tif (tb[TCA_FLOWER_KEY_MPLS_OPTS]) {\n\t\tif (tb[TCA_FLOWER_KEY_MPLS_TTL] ||\n\t\t    tb[TCA_FLOWER_KEY_MPLS_BOS] ||\n\t\t    tb[TCA_FLOWER_KEY_MPLS_TC] ||\n\t\t    tb[TCA_FLOWER_KEY_MPLS_LABEL]) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[TCA_FLOWER_KEY_MPLS_OPTS],\n\t\t\t\t\t    \"MPLS label, Traffic Class, Bottom Of Stack and Time To Live must be encapsulated in the MPLS options attribute\");\n\t\t\treturn -EBADMSG;\n\t\t}\n\n\t\treturn fl_set_key_mpls_opts(tb[TCA_FLOWER_KEY_MPLS_OPTS],\n\t\t\t\t\t    key_val, key_mask, extack);\n\t}\n\n\tlse_val = &key_val->ls[0];\n\tlse_mask = &key_mask->ls[0];\n\n\tif (tb[TCA_FLOWER_KEY_MPLS_TTL]) {\n\t\tlse_val->mpls_ttl = nla_get_u8(tb[TCA_FLOWER_KEY_MPLS_TTL]);\n\t\tlse_mask->mpls_ttl = MPLS_TTL_MASK;\n\t\tdissector_set_mpls_lse(key_val, 0);\n\t\tdissector_set_mpls_lse(key_mask, 0);\n\t}\n\tif (tb[TCA_FLOWER_KEY_MPLS_BOS]) {\n\t\tu8 bos = nla_get_u8(tb[TCA_FLOWER_KEY_MPLS_BOS]);\n\n\t\tif (bos & ~MPLS_BOS_MASK) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[TCA_FLOWER_KEY_MPLS_BOS],\n\t\t\t\t\t    \"Bottom Of Stack (BOS) must be 0 or 1\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlse_val->mpls_bos = bos;\n\t\tlse_mask->mpls_bos = MPLS_BOS_MASK;\n\t\tdissector_set_mpls_lse(key_val, 0);\n\t\tdissector_set_mpls_lse(key_mask, 0);\n\t}\n\tif (tb[TCA_FLOWER_KEY_MPLS_TC]) {\n\t\tu8 tc = nla_get_u8(tb[TCA_FLOWER_KEY_MPLS_TC]);\n\n\t\tif (tc & ~MPLS_TC_MASK) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[TCA_FLOWER_KEY_MPLS_TC],\n\t\t\t\t\t    \"Traffic Class (TC) must be between 0 and 7\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlse_val->mpls_tc = tc;\n\t\tlse_mask->mpls_tc = MPLS_TC_MASK;\n\t\tdissector_set_mpls_lse(key_val, 0);\n\t\tdissector_set_mpls_lse(key_mask, 0);\n\t}\n\tif (tb[TCA_FLOWER_KEY_MPLS_LABEL]) {\n\t\tu32 label = nla_get_u32(tb[TCA_FLOWER_KEY_MPLS_LABEL]);\n\n\t\tif (label & ~MPLS_LABEL_MASK) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[TCA_FLOWER_KEY_MPLS_LABEL],\n\t\t\t\t\t    \"Label must be between 0 and 1048575\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlse_val->mpls_label = label;\n\t\tlse_mask->mpls_label = MPLS_LABEL_MASK;\n\t\tdissector_set_mpls_lse(key_val, 0);\n\t\tdissector_set_mpls_lse(key_mask, 0);\n\t}\n\treturn 0;\n}\n\nstatic void fl_set_key_vlan(struct nlattr **tb,\n\t\t\t    __be16 ethertype,\n\t\t\t    int vlan_id_key, int vlan_prio_key,\n\t\t\t    int vlan_next_eth_type_key,\n\t\t\t    struct flow_dissector_key_vlan *key_val,\n\t\t\t    struct flow_dissector_key_vlan *key_mask)\n{\n#define VLAN_PRIORITY_MASK\t0x7\n\n\tif (tb[vlan_id_key]) {\n\t\tkey_val->vlan_id =\n\t\t\tnla_get_u16(tb[vlan_id_key]) & VLAN_VID_MASK;\n\t\tkey_mask->vlan_id = VLAN_VID_MASK;\n\t}\n\tif (tb[vlan_prio_key]) {\n\t\tkey_val->vlan_priority =\n\t\t\tnla_get_u8(tb[vlan_prio_key]) &\n\t\t\tVLAN_PRIORITY_MASK;\n\t\tkey_mask->vlan_priority = VLAN_PRIORITY_MASK;\n\t}\n\tif (ethertype) {\n\t\tkey_val->vlan_tpid = ethertype;\n\t\tkey_mask->vlan_tpid = cpu_to_be16(~0);\n\t}\n\tif (tb[vlan_next_eth_type_key]) {\n\t\tkey_val->vlan_eth_type =\n\t\t\tnla_get_be16(tb[vlan_next_eth_type_key]);\n\t\tkey_mask->vlan_eth_type = cpu_to_be16(~0);\n\t}\n}\n\nstatic void fl_set_key_pppoe(struct nlattr **tb,\n\t\t\t     struct flow_dissector_key_pppoe *key_val,\n\t\t\t     struct flow_dissector_key_pppoe *key_mask,\n\t\t\t     struct fl_flow_key *key,\n\t\t\t     struct fl_flow_key *mask)\n{\n\t \n\tkey_val->type = htons(ETH_P_PPP_SES);\n\tkey_mask->type = cpu_to_be16(~0);\n\n\tif (tb[TCA_FLOWER_KEY_PPPOE_SID]) {\n\t\tkey_val->session_id =\n\t\t\tnla_get_be16(tb[TCA_FLOWER_KEY_PPPOE_SID]);\n\t\tkey_mask->session_id = cpu_to_be16(~0);\n\t}\n\tif (tb[TCA_FLOWER_KEY_PPP_PROTO]) {\n\t\tkey_val->ppp_proto =\n\t\t\tnla_get_be16(tb[TCA_FLOWER_KEY_PPP_PROTO]);\n\t\tkey_mask->ppp_proto = cpu_to_be16(~0);\n\n\t\tif (key_val->ppp_proto == htons(PPP_IP)) {\n\t\t\tkey->basic.n_proto = htons(ETH_P_IP);\n\t\t\tmask->basic.n_proto = cpu_to_be16(~0);\n\t\t} else if (key_val->ppp_proto == htons(PPP_IPV6)) {\n\t\t\tkey->basic.n_proto = htons(ETH_P_IPV6);\n\t\t\tmask->basic.n_proto = cpu_to_be16(~0);\n\t\t} else if (key_val->ppp_proto == htons(PPP_MPLS_UC)) {\n\t\t\tkey->basic.n_proto = htons(ETH_P_MPLS_UC);\n\t\t\tmask->basic.n_proto = cpu_to_be16(~0);\n\t\t} else if (key_val->ppp_proto == htons(PPP_MPLS_MC)) {\n\t\t\tkey->basic.n_proto = htons(ETH_P_MPLS_MC);\n\t\t\tmask->basic.n_proto = cpu_to_be16(~0);\n\t\t}\n\t} else {\n\t\tkey->basic.n_proto = 0;\n\t\tmask->basic.n_proto = cpu_to_be16(0);\n\t}\n}\n\nstatic void fl_set_key_flag(u32 flower_key, u32 flower_mask,\n\t\t\t    u32 *dissector_key, u32 *dissector_mask,\n\t\t\t    u32 flower_flag_bit, u32 dissector_flag_bit)\n{\n\tif (flower_mask & flower_flag_bit) {\n\t\t*dissector_mask |= dissector_flag_bit;\n\t\tif (flower_key & flower_flag_bit)\n\t\t\t*dissector_key |= dissector_flag_bit;\n\t}\n}\n\nstatic int fl_set_key_flags(struct nlattr **tb, u32 *flags_key,\n\t\t\t    u32 *flags_mask, struct netlink_ext_ack *extack)\n{\n\tu32 key, mask;\n\n\t \n\tif (!tb[TCA_FLOWER_KEY_FLAGS_MASK]) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing flags mask\");\n\t\treturn -EINVAL;\n\t}\n\n\tkey = be32_to_cpu(nla_get_be32(tb[TCA_FLOWER_KEY_FLAGS]));\n\tmask = be32_to_cpu(nla_get_be32(tb[TCA_FLOWER_KEY_FLAGS_MASK]));\n\n\t*flags_key  = 0;\n\t*flags_mask = 0;\n\n\tfl_set_key_flag(key, mask, flags_key, flags_mask,\n\t\t\tTCA_FLOWER_KEY_FLAGS_IS_FRAGMENT, FLOW_DIS_IS_FRAGMENT);\n\tfl_set_key_flag(key, mask, flags_key, flags_mask,\n\t\t\tTCA_FLOWER_KEY_FLAGS_FRAG_IS_FIRST,\n\t\t\tFLOW_DIS_FIRST_FRAG);\n\n\treturn 0;\n}\n\nstatic void fl_set_key_ip(struct nlattr **tb, bool encap,\n\t\t\t  struct flow_dissector_key_ip *key,\n\t\t\t  struct flow_dissector_key_ip *mask)\n{\n\tint tos_key = encap ? TCA_FLOWER_KEY_ENC_IP_TOS : TCA_FLOWER_KEY_IP_TOS;\n\tint ttl_key = encap ? TCA_FLOWER_KEY_ENC_IP_TTL : TCA_FLOWER_KEY_IP_TTL;\n\tint tos_mask = encap ? TCA_FLOWER_KEY_ENC_IP_TOS_MASK : TCA_FLOWER_KEY_IP_TOS_MASK;\n\tint ttl_mask = encap ? TCA_FLOWER_KEY_ENC_IP_TTL_MASK : TCA_FLOWER_KEY_IP_TTL_MASK;\n\n\tfl_set_key_val(tb, &key->tos, tos_key, &mask->tos, tos_mask, sizeof(key->tos));\n\tfl_set_key_val(tb, &key->ttl, ttl_key, &mask->ttl, ttl_mask, sizeof(key->ttl));\n}\n\nstatic int fl_set_geneve_opt(const struct nlattr *nla, struct fl_flow_key *key,\n\t\t\t     int depth, int option_len,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX + 1];\n\tstruct nlattr *class = NULL, *type = NULL, *data = NULL;\n\tstruct geneve_opt *opt;\n\tint err, data_len = 0;\n\n\tif (option_len > sizeof(struct geneve_opt))\n\t\tdata_len = option_len - sizeof(struct geneve_opt);\n\n\tif (key->enc_opts.len > FLOW_DIS_TUN_OPTS_MAX - 4)\n\t\treturn -ERANGE;\n\n\topt = (struct geneve_opt *)&key->enc_opts.data[key->enc_opts.len];\n\tmemset(opt, 0xff, option_len);\n\topt->length = data_len / 4;\n\topt->r1 = 0;\n\topt->r2 = 0;\n\topt->r3 = 0;\n\n\t \n\tif (!depth)\n\t\treturn sizeof(struct geneve_opt) + data_len;\n\n\tif (nla_type(nla) != TCA_FLOWER_KEY_ENC_OPTS_GENEVE) {\n\t\tNL_SET_ERR_MSG(extack, \"Non-geneve option type for mask\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t  TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX,\n\t\t\t\t\t  nla, geneve_opt_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!option_len &&\n\t    (!tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS] ||\n\t     !tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE] ||\n\t     !tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA])) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key geneve option class, type or data\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA]) {\n\t\tint new_len = key->enc_opts.len;\n\n\t\tdata = tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA];\n\t\tdata_len = nla_len(data);\n\t\tif (data_len < 4) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Tunnel key geneve option data is less than 4 bytes long\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tif (data_len % 4) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Tunnel key geneve option data is not a multiple of 4 bytes long\");\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tnew_len += sizeof(struct geneve_opt) + data_len;\n\t\tBUILD_BUG_ON(FLOW_DIS_TUN_OPTS_MAX != IP_TUNNEL_OPTS_MAX);\n\t\tif (new_len > FLOW_DIS_TUN_OPTS_MAX) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Tunnel options exceeds max size\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\topt->length = data_len / 4;\n\t\tmemcpy(opt->opt_data, nla_data(data), data_len);\n\t}\n\n\tif (tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS]) {\n\t\tclass = tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS];\n\t\topt->opt_class = nla_get_be16(class);\n\t}\n\n\tif (tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE]) {\n\t\ttype = tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE];\n\t\topt->type = nla_get_u8(type);\n\t}\n\n\treturn sizeof(struct geneve_opt) + data_len;\n}\n\nstatic int fl_set_vxlan_opt(const struct nlattr *nla, struct fl_flow_key *key,\n\t\t\t    int depth, int option_len,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_FLOWER_KEY_ENC_OPT_VXLAN_MAX + 1];\n\tstruct vxlan_metadata *md;\n\tint err;\n\n\tmd = (struct vxlan_metadata *)&key->enc_opts.data[key->enc_opts.len];\n\tmemset(md, 0xff, sizeof(*md));\n\n\tif (!depth)\n\t\treturn sizeof(*md);\n\n\tif (nla_type(nla) != TCA_FLOWER_KEY_ENC_OPTS_VXLAN) {\n\t\tNL_SET_ERR_MSG(extack, \"Non-vxlan option type for mask\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested(tb, TCA_FLOWER_KEY_ENC_OPT_VXLAN_MAX, nla,\n\t\t\t       vxlan_opt_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!option_len && !tb[TCA_FLOWER_KEY_ENC_OPT_VXLAN_GBP]) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key vxlan option gbp\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[TCA_FLOWER_KEY_ENC_OPT_VXLAN_GBP]) {\n\t\tmd->gbp = nla_get_u32(tb[TCA_FLOWER_KEY_ENC_OPT_VXLAN_GBP]);\n\t\tmd->gbp &= VXLAN_GBP_MASK;\n\t}\n\n\treturn sizeof(*md);\n}\n\nstatic int fl_set_erspan_opt(const struct nlattr *nla, struct fl_flow_key *key,\n\t\t\t     int depth, int option_len,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_MAX + 1];\n\tstruct erspan_metadata *md;\n\tint err;\n\n\tmd = (struct erspan_metadata *)&key->enc_opts.data[key->enc_opts.len];\n\tmemset(md, 0xff, sizeof(*md));\n\tmd->version = 1;\n\n\tif (!depth)\n\t\treturn sizeof(*md);\n\n\tif (nla_type(nla) != TCA_FLOWER_KEY_ENC_OPTS_ERSPAN) {\n\t\tNL_SET_ERR_MSG(extack, \"Non-erspan option type for mask\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested(tb, TCA_FLOWER_KEY_ENC_OPT_ERSPAN_MAX, nla,\n\t\t\t       erspan_opt_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!option_len && !tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_VER]) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key erspan option ver\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_VER])\n\t\tmd->version = nla_get_u8(tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_VER]);\n\n\tif (md->version == 1) {\n\t\tif (!option_len && !tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_INDEX]) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key erspan option index\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_INDEX]) {\n\t\t\tnla = tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_INDEX];\n\t\t\tmemset(&md->u, 0x00, sizeof(md->u));\n\t\t\tmd->u.index = nla_get_be32(nla);\n\t\t}\n\t} else if (md->version == 2) {\n\t\tif (!option_len && (!tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_DIR] ||\n\t\t\t\t    !tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_HWID])) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key erspan option dir or hwid\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_DIR]) {\n\t\t\tnla = tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_DIR];\n\t\t\tmd->u.md2.dir = nla_get_u8(nla);\n\t\t}\n\t\tif (tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_HWID]) {\n\t\t\tnla = tb[TCA_FLOWER_KEY_ENC_OPT_ERSPAN_HWID];\n\t\t\tset_hwid(&md->u.md2, nla_get_u8(nla));\n\t\t}\n\t} else {\n\t\tNL_SET_ERR_MSG(extack, \"Tunnel key erspan option ver is incorrect\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn sizeof(*md);\n}\n\nstatic int fl_set_gtp_opt(const struct nlattr *nla, struct fl_flow_key *key,\n\t\t\t  int depth, int option_len,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_FLOWER_KEY_ENC_OPT_GTP_MAX + 1];\n\tstruct gtp_pdu_session_info *sinfo;\n\tu8 len = key->enc_opts.len;\n\tint err;\n\n\tsinfo = (struct gtp_pdu_session_info *)&key->enc_opts.data[len];\n\tmemset(sinfo, 0xff, option_len);\n\n\tif (!depth)\n\t\treturn sizeof(*sinfo);\n\n\tif (nla_type(nla) != TCA_FLOWER_KEY_ENC_OPTS_GTP) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Non-gtp option type for mask\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested(tb, TCA_FLOWER_KEY_ENC_OPT_GTP_MAX, nla,\n\t\t\t       gtp_opt_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!option_len &&\n\t    (!tb[TCA_FLOWER_KEY_ENC_OPT_GTP_PDU_TYPE] ||\n\t     !tb[TCA_FLOWER_KEY_ENC_OPT_GTP_QFI])) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Missing tunnel key gtp option pdu type or qfi\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[TCA_FLOWER_KEY_ENC_OPT_GTP_PDU_TYPE])\n\t\tsinfo->pdu_type =\n\t\t\tnla_get_u8(tb[TCA_FLOWER_KEY_ENC_OPT_GTP_PDU_TYPE]);\n\n\tif (tb[TCA_FLOWER_KEY_ENC_OPT_GTP_QFI])\n\t\tsinfo->qfi = nla_get_u8(tb[TCA_FLOWER_KEY_ENC_OPT_GTP_QFI]);\n\n\treturn sizeof(*sinfo);\n}\n\nstatic int fl_set_enc_opt(struct nlattr **tb, struct fl_flow_key *key,\n\t\t\t  struct fl_flow_key *mask,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tconst struct nlattr *nla_enc_key, *nla_opt_key, *nla_opt_msk = NULL;\n\tint err, option_len, key_depth, msk_depth = 0;\n\n\terr = nla_validate_nested_deprecated(tb[TCA_FLOWER_KEY_ENC_OPTS],\n\t\t\t\t\t     TCA_FLOWER_KEY_ENC_OPTS_MAX,\n\t\t\t\t\t     enc_opts_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tnla_enc_key = nla_data(tb[TCA_FLOWER_KEY_ENC_OPTS]);\n\n\tif (tb[TCA_FLOWER_KEY_ENC_OPTS_MASK]) {\n\t\terr = nla_validate_nested_deprecated(tb[TCA_FLOWER_KEY_ENC_OPTS_MASK],\n\t\t\t\t\t\t     TCA_FLOWER_KEY_ENC_OPTS_MAX,\n\t\t\t\t\t\t     enc_opts_policy, extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnla_opt_msk = nla_data(tb[TCA_FLOWER_KEY_ENC_OPTS_MASK]);\n\t\tmsk_depth = nla_len(tb[TCA_FLOWER_KEY_ENC_OPTS_MASK]);\n\t\tif (!nla_ok(nla_opt_msk, msk_depth)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid nested attribute for masks\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnla_for_each_attr(nla_opt_key, nla_enc_key,\n\t\t\t  nla_len(tb[TCA_FLOWER_KEY_ENC_OPTS]), key_depth) {\n\t\tswitch (nla_type(nla_opt_key)) {\n\t\tcase TCA_FLOWER_KEY_ENC_OPTS_GENEVE:\n\t\t\tif (key->enc_opts.dst_opt_type &&\n\t\t\t    key->enc_opts.dst_opt_type != TUNNEL_GENEVE_OPT) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Duplicate type for geneve options\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toption_len = 0;\n\t\t\tkey->enc_opts.dst_opt_type = TUNNEL_GENEVE_OPT;\n\t\t\toption_len = fl_set_geneve_opt(nla_opt_key, key,\n\t\t\t\t\t\t       key_depth, option_len,\n\t\t\t\t\t\t       extack);\n\t\t\tif (option_len < 0)\n\t\t\t\treturn option_len;\n\n\t\t\tkey->enc_opts.len += option_len;\n\t\t\t \n\t\t\tmask->enc_opts.dst_opt_type = TUNNEL_GENEVE_OPT;\n\t\t\toption_len = fl_set_geneve_opt(nla_opt_msk, mask,\n\t\t\t\t\t\t       msk_depth, option_len,\n\t\t\t\t\t\t       extack);\n\t\t\tif (option_len < 0)\n\t\t\t\treturn option_len;\n\n\t\t\tmask->enc_opts.len += option_len;\n\t\t\tif (key->enc_opts.len != mask->enc_opts.len) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Key and mask miss aligned\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TCA_FLOWER_KEY_ENC_OPTS_VXLAN:\n\t\t\tif (key->enc_opts.dst_opt_type) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Duplicate type for vxlan options\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toption_len = 0;\n\t\t\tkey->enc_opts.dst_opt_type = TUNNEL_VXLAN_OPT;\n\t\t\toption_len = fl_set_vxlan_opt(nla_opt_key, key,\n\t\t\t\t\t\t      key_depth, option_len,\n\t\t\t\t\t\t      extack);\n\t\t\tif (option_len < 0)\n\t\t\t\treturn option_len;\n\n\t\t\tkey->enc_opts.len += option_len;\n\t\t\t \n\t\t\tmask->enc_opts.dst_opt_type = TUNNEL_VXLAN_OPT;\n\t\t\toption_len = fl_set_vxlan_opt(nla_opt_msk, mask,\n\t\t\t\t\t\t      msk_depth, option_len,\n\t\t\t\t\t\t      extack);\n\t\t\tif (option_len < 0)\n\t\t\t\treturn option_len;\n\n\t\t\tmask->enc_opts.len += option_len;\n\t\t\tif (key->enc_opts.len != mask->enc_opts.len) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Key and mask miss aligned\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TCA_FLOWER_KEY_ENC_OPTS_ERSPAN:\n\t\t\tif (key->enc_opts.dst_opt_type) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Duplicate type for erspan options\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toption_len = 0;\n\t\t\tkey->enc_opts.dst_opt_type = TUNNEL_ERSPAN_OPT;\n\t\t\toption_len = fl_set_erspan_opt(nla_opt_key, key,\n\t\t\t\t\t\t       key_depth, option_len,\n\t\t\t\t\t\t       extack);\n\t\t\tif (option_len < 0)\n\t\t\t\treturn option_len;\n\n\t\t\tkey->enc_opts.len += option_len;\n\t\t\t \n\t\t\tmask->enc_opts.dst_opt_type = TUNNEL_ERSPAN_OPT;\n\t\t\toption_len = fl_set_erspan_opt(nla_opt_msk, mask,\n\t\t\t\t\t\t       msk_depth, option_len,\n\t\t\t\t\t\t       extack);\n\t\t\tif (option_len < 0)\n\t\t\t\treturn option_len;\n\n\t\t\tmask->enc_opts.len += option_len;\n\t\t\tif (key->enc_opts.len != mask->enc_opts.len) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Key and mask miss aligned\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TCA_FLOWER_KEY_ENC_OPTS_GTP:\n\t\t\tif (key->enc_opts.dst_opt_type) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Duplicate type for gtp options\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toption_len = 0;\n\t\t\tkey->enc_opts.dst_opt_type = TUNNEL_GTP_OPT;\n\t\t\toption_len = fl_set_gtp_opt(nla_opt_key, key,\n\t\t\t\t\t\t    key_depth, option_len,\n\t\t\t\t\t\t    extack);\n\t\t\tif (option_len < 0)\n\t\t\t\treturn option_len;\n\n\t\t\tkey->enc_opts.len += option_len;\n\t\t\t \n\t\t\tmask->enc_opts.dst_opt_type = TUNNEL_GTP_OPT;\n\t\t\toption_len = fl_set_gtp_opt(nla_opt_msk, mask,\n\t\t\t\t\t\t    msk_depth, option_len,\n\t\t\t\t\t\t    extack);\n\t\t\tif (option_len < 0)\n\t\t\t\treturn option_len;\n\n\t\t\tmask->enc_opts.len += option_len;\n\t\t\tif (key->enc_opts.len != mask->enc_opts.len) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Key and mask miss aligned\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Unknown tunnel option type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!msk_depth)\n\t\t\tcontinue;\n\n\t\tif (!nla_ok(nla_opt_msk, msk_depth)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"A mask attribute is invalid\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnla_opt_msk = nla_next(nla_opt_msk, &msk_depth);\n\t}\n\n\treturn 0;\n}\n\nstatic int fl_validate_ct_state(u16 state, struct nlattr *tb,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (state && !(state & TCA_FLOWER_KEY_CT_FLAGS_TRACKED)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb,\n\t\t\t\t    \"no trk, so no other flag can be set\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (state & TCA_FLOWER_KEY_CT_FLAGS_NEW &&\n\t    state & TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb,\n\t\t\t\t    \"new and est are mutually exclusive\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (state & TCA_FLOWER_KEY_CT_FLAGS_INVALID &&\n\t    state & ~(TCA_FLOWER_KEY_CT_FLAGS_TRACKED |\n\t\t      TCA_FLOWER_KEY_CT_FLAGS_INVALID)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb,\n\t\t\t\t    \"when inv is set, only trk may be set\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (state & TCA_FLOWER_KEY_CT_FLAGS_NEW &&\n\t    state & TCA_FLOWER_KEY_CT_FLAGS_REPLY) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb,\n\t\t\t\t    \"new and rpl are mutually exclusive\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fl_set_key_ct(struct nlattr **tb,\n\t\t\t struct flow_dissector_key_ct *key,\n\t\t\t struct flow_dissector_key_ct *mask,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tif (tb[TCA_FLOWER_KEY_CT_STATE]) {\n\t\tint err;\n\n\t\tif (!IS_ENABLED(CONFIG_NF_CONNTRACK)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Conntrack isn't enabled\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tfl_set_key_val(tb, &key->ct_state, TCA_FLOWER_KEY_CT_STATE,\n\t\t\t       &mask->ct_state, TCA_FLOWER_KEY_CT_STATE_MASK,\n\t\t\t       sizeof(key->ct_state));\n\n\t\terr = fl_validate_ct_state(key->ct_state & mask->ct_state,\n\t\t\t\t\t   tb[TCA_FLOWER_KEY_CT_STATE_MASK],\n\t\t\t\t\t   extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t}\n\tif (tb[TCA_FLOWER_KEY_CT_ZONE]) {\n\t\tif (!IS_ENABLED(CONFIG_NF_CONNTRACK_ZONES)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Conntrack zones isn't enabled\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tfl_set_key_val(tb, &key->ct_zone, TCA_FLOWER_KEY_CT_ZONE,\n\t\t\t       &mask->ct_zone, TCA_FLOWER_KEY_CT_ZONE_MASK,\n\t\t\t       sizeof(key->ct_zone));\n\t}\n\tif (tb[TCA_FLOWER_KEY_CT_MARK]) {\n\t\tif (!IS_ENABLED(CONFIG_NF_CONNTRACK_MARK)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Conntrack mark isn't enabled\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tfl_set_key_val(tb, &key->ct_mark, TCA_FLOWER_KEY_CT_MARK,\n\t\t\t       &mask->ct_mark, TCA_FLOWER_KEY_CT_MARK_MASK,\n\t\t\t       sizeof(key->ct_mark));\n\t}\n\tif (tb[TCA_FLOWER_KEY_CT_LABELS]) {\n\t\tif (!IS_ENABLED(CONFIG_NF_CONNTRACK_LABELS)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Conntrack labels aren't enabled\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tfl_set_key_val(tb, key->ct_labels, TCA_FLOWER_KEY_CT_LABELS,\n\t\t\t       mask->ct_labels, TCA_FLOWER_KEY_CT_LABELS_MASK,\n\t\t\t       sizeof(key->ct_labels));\n\t}\n\n\treturn 0;\n}\n\nstatic bool is_vlan_key(struct nlattr *tb, __be16 *ethertype,\n\t\t\tstruct fl_flow_key *key, struct fl_flow_key *mask,\n\t\t\tint vthresh)\n{\n\tconst bool good_num_of_vlans = key->num_of_vlans.num_of_vlans > vthresh;\n\n\tif (!tb) {\n\t\t*ethertype = 0;\n\t\treturn good_num_of_vlans;\n\t}\n\n\t*ethertype = nla_get_be16(tb);\n\tif (good_num_of_vlans || eth_type_vlan(*ethertype))\n\t\treturn true;\n\n\tkey->basic.n_proto = *ethertype;\n\tmask->basic.n_proto = cpu_to_be16(~0);\n\treturn false;\n}\n\nstatic void fl_set_key_cfm_md_level(struct nlattr **tb,\n\t\t\t\t    struct fl_flow_key *key,\n\t\t\t\t    struct fl_flow_key *mask,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tu8 level;\n\n\tif (!tb[TCA_FLOWER_KEY_CFM_MD_LEVEL])\n\t\treturn;\n\n\tlevel = nla_get_u8(tb[TCA_FLOWER_KEY_CFM_MD_LEVEL]);\n\tkey->cfm.mdl_ver = FIELD_PREP(FLOW_DIS_CFM_MDL_MASK, level);\n\tmask->cfm.mdl_ver = FLOW_DIS_CFM_MDL_MASK;\n}\n\nstatic void fl_set_key_cfm_opcode(struct nlattr **tb,\n\t\t\t\t  struct fl_flow_key *key,\n\t\t\t\t  struct fl_flow_key *mask,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tfl_set_key_val(tb, &key->cfm.opcode, TCA_FLOWER_KEY_CFM_OPCODE,\n\t\t       &mask->cfm.opcode, TCA_FLOWER_UNSPEC,\n\t\t       sizeof(key->cfm.opcode));\n}\n\nstatic int fl_set_key_cfm(struct nlattr **tb,\n\t\t\t  struct fl_flow_key *key,\n\t\t\t  struct fl_flow_key *mask,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *nla_cfm_opt[TCA_FLOWER_KEY_CFM_OPT_MAX + 1];\n\tint err;\n\n\tif (!tb[TCA_FLOWER_KEY_CFM])\n\t\treturn 0;\n\n\terr = nla_parse_nested(nla_cfm_opt, TCA_FLOWER_KEY_CFM_OPT_MAX,\n\t\t\t       tb[TCA_FLOWER_KEY_CFM], cfm_opt_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tfl_set_key_cfm_opcode(nla_cfm_opt, key, mask, extack);\n\tfl_set_key_cfm_md_level(nla_cfm_opt, key, mask, extack);\n\n\treturn 0;\n}\n\nstatic int fl_set_key(struct net *net, struct nlattr **tb,\n\t\t      struct fl_flow_key *key, struct fl_flow_key *mask,\n\t\t      struct netlink_ext_ack *extack)\n{\n\t__be16 ethertype;\n\tint ret = 0;\n\n\tif (tb[TCA_FLOWER_INDEV]) {\n\t\tint err = tcf_change_indev(net, tb[TCA_FLOWER_INDEV], extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tkey->meta.ingress_ifindex = err;\n\t\tmask->meta.ingress_ifindex = 0xffffffff;\n\t}\n\n\tfl_set_key_val(tb, &key->meta.l2_miss, TCA_FLOWER_L2_MISS,\n\t\t       &mask->meta.l2_miss, TCA_FLOWER_UNSPEC,\n\t\t       sizeof(key->meta.l2_miss));\n\n\tfl_set_key_val(tb, key->eth.dst, TCA_FLOWER_KEY_ETH_DST,\n\t\t       mask->eth.dst, TCA_FLOWER_KEY_ETH_DST_MASK,\n\t\t       sizeof(key->eth.dst));\n\tfl_set_key_val(tb, key->eth.src, TCA_FLOWER_KEY_ETH_SRC,\n\t\t       mask->eth.src, TCA_FLOWER_KEY_ETH_SRC_MASK,\n\t\t       sizeof(key->eth.src));\n\tfl_set_key_val(tb, &key->num_of_vlans,\n\t\t       TCA_FLOWER_KEY_NUM_OF_VLANS,\n\t\t       &mask->num_of_vlans,\n\t\t       TCA_FLOWER_UNSPEC,\n\t\t       sizeof(key->num_of_vlans));\n\n\tif (is_vlan_key(tb[TCA_FLOWER_KEY_ETH_TYPE], &ethertype, key, mask, 0)) {\n\t\tfl_set_key_vlan(tb, ethertype, TCA_FLOWER_KEY_VLAN_ID,\n\t\t\t\tTCA_FLOWER_KEY_VLAN_PRIO,\n\t\t\t\tTCA_FLOWER_KEY_VLAN_ETH_TYPE,\n\t\t\t\t&key->vlan, &mask->vlan);\n\n\t\tif (is_vlan_key(tb[TCA_FLOWER_KEY_VLAN_ETH_TYPE],\n\t\t\t\t&ethertype, key, mask, 1)) {\n\t\t\tfl_set_key_vlan(tb, ethertype,\n\t\t\t\t\tTCA_FLOWER_KEY_CVLAN_ID,\n\t\t\t\t\tTCA_FLOWER_KEY_CVLAN_PRIO,\n\t\t\t\t\tTCA_FLOWER_KEY_CVLAN_ETH_TYPE,\n\t\t\t\t\t&key->cvlan, &mask->cvlan);\n\t\t\tfl_set_key_val(tb, &key->basic.n_proto,\n\t\t\t\t       TCA_FLOWER_KEY_CVLAN_ETH_TYPE,\n\t\t\t\t       &mask->basic.n_proto,\n\t\t\t\t       TCA_FLOWER_UNSPEC,\n\t\t\t\t       sizeof(key->basic.n_proto));\n\t\t}\n\t}\n\n\tif (key->basic.n_proto == htons(ETH_P_PPP_SES))\n\t\tfl_set_key_pppoe(tb, &key->pppoe, &mask->pppoe, key, mask);\n\n\tif (key->basic.n_proto == htons(ETH_P_IP) ||\n\t    key->basic.n_proto == htons(ETH_P_IPV6)) {\n\t\tfl_set_key_val(tb, &key->basic.ip_proto, TCA_FLOWER_KEY_IP_PROTO,\n\t\t\t       &mask->basic.ip_proto, TCA_FLOWER_UNSPEC,\n\t\t\t       sizeof(key->basic.ip_proto));\n\t\tfl_set_key_ip(tb, false, &key->ip, &mask->ip);\n\t}\n\n\tif (tb[TCA_FLOWER_KEY_IPV4_SRC] || tb[TCA_FLOWER_KEY_IPV4_DST]) {\n\t\tkey->control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tmask->control.addr_type = ~0;\n\t\tfl_set_key_val(tb, &key->ipv4.src, TCA_FLOWER_KEY_IPV4_SRC,\n\t\t\t       &mask->ipv4.src, TCA_FLOWER_KEY_IPV4_SRC_MASK,\n\t\t\t       sizeof(key->ipv4.src));\n\t\tfl_set_key_val(tb, &key->ipv4.dst, TCA_FLOWER_KEY_IPV4_DST,\n\t\t\t       &mask->ipv4.dst, TCA_FLOWER_KEY_IPV4_DST_MASK,\n\t\t\t       sizeof(key->ipv4.dst));\n\t} else if (tb[TCA_FLOWER_KEY_IPV6_SRC] || tb[TCA_FLOWER_KEY_IPV6_DST]) {\n\t\tkey->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\tmask->control.addr_type = ~0;\n\t\tfl_set_key_val(tb, &key->ipv6.src, TCA_FLOWER_KEY_IPV6_SRC,\n\t\t\t       &mask->ipv6.src, TCA_FLOWER_KEY_IPV6_SRC_MASK,\n\t\t\t       sizeof(key->ipv6.src));\n\t\tfl_set_key_val(tb, &key->ipv6.dst, TCA_FLOWER_KEY_IPV6_DST,\n\t\t\t       &mask->ipv6.dst, TCA_FLOWER_KEY_IPV6_DST_MASK,\n\t\t\t       sizeof(key->ipv6.dst));\n\t}\n\n\tif (key->basic.ip_proto == IPPROTO_TCP) {\n\t\tfl_set_key_val(tb, &key->tp.src, TCA_FLOWER_KEY_TCP_SRC,\n\t\t\t       &mask->tp.src, TCA_FLOWER_KEY_TCP_SRC_MASK,\n\t\t\t       sizeof(key->tp.src));\n\t\tfl_set_key_val(tb, &key->tp.dst, TCA_FLOWER_KEY_TCP_DST,\n\t\t\t       &mask->tp.dst, TCA_FLOWER_KEY_TCP_DST_MASK,\n\t\t\t       sizeof(key->tp.dst));\n\t\tfl_set_key_val(tb, &key->tcp.flags, TCA_FLOWER_KEY_TCP_FLAGS,\n\t\t\t       &mask->tcp.flags, TCA_FLOWER_KEY_TCP_FLAGS_MASK,\n\t\t\t       sizeof(key->tcp.flags));\n\t} else if (key->basic.ip_proto == IPPROTO_UDP) {\n\t\tfl_set_key_val(tb, &key->tp.src, TCA_FLOWER_KEY_UDP_SRC,\n\t\t\t       &mask->tp.src, TCA_FLOWER_KEY_UDP_SRC_MASK,\n\t\t\t       sizeof(key->tp.src));\n\t\tfl_set_key_val(tb, &key->tp.dst, TCA_FLOWER_KEY_UDP_DST,\n\t\t\t       &mask->tp.dst, TCA_FLOWER_KEY_UDP_DST_MASK,\n\t\t\t       sizeof(key->tp.dst));\n\t} else if (key->basic.ip_proto == IPPROTO_SCTP) {\n\t\tfl_set_key_val(tb, &key->tp.src, TCA_FLOWER_KEY_SCTP_SRC,\n\t\t\t       &mask->tp.src, TCA_FLOWER_KEY_SCTP_SRC_MASK,\n\t\t\t       sizeof(key->tp.src));\n\t\tfl_set_key_val(tb, &key->tp.dst, TCA_FLOWER_KEY_SCTP_DST,\n\t\t\t       &mask->tp.dst, TCA_FLOWER_KEY_SCTP_DST_MASK,\n\t\t\t       sizeof(key->tp.dst));\n\t} else if (key->basic.n_proto == htons(ETH_P_IP) &&\n\t\t   key->basic.ip_proto == IPPROTO_ICMP) {\n\t\tfl_set_key_val(tb, &key->icmp.type, TCA_FLOWER_KEY_ICMPV4_TYPE,\n\t\t\t       &mask->icmp.type,\n\t\t\t       TCA_FLOWER_KEY_ICMPV4_TYPE_MASK,\n\t\t\t       sizeof(key->icmp.type));\n\t\tfl_set_key_val(tb, &key->icmp.code, TCA_FLOWER_KEY_ICMPV4_CODE,\n\t\t\t       &mask->icmp.code,\n\t\t\t       TCA_FLOWER_KEY_ICMPV4_CODE_MASK,\n\t\t\t       sizeof(key->icmp.code));\n\t} else if (key->basic.n_proto == htons(ETH_P_IPV6) &&\n\t\t   key->basic.ip_proto == IPPROTO_ICMPV6) {\n\t\tfl_set_key_val(tb, &key->icmp.type, TCA_FLOWER_KEY_ICMPV6_TYPE,\n\t\t\t       &mask->icmp.type,\n\t\t\t       TCA_FLOWER_KEY_ICMPV6_TYPE_MASK,\n\t\t\t       sizeof(key->icmp.type));\n\t\tfl_set_key_val(tb, &key->icmp.code, TCA_FLOWER_KEY_ICMPV6_CODE,\n\t\t\t       &mask->icmp.code,\n\t\t\t       TCA_FLOWER_KEY_ICMPV6_CODE_MASK,\n\t\t\t       sizeof(key->icmp.code));\n\t} else if (key->basic.n_proto == htons(ETH_P_MPLS_UC) ||\n\t\t   key->basic.n_proto == htons(ETH_P_MPLS_MC)) {\n\t\tret = fl_set_key_mpls(tb, &key->mpls, &mask->mpls, extack);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (key->basic.n_proto == htons(ETH_P_ARP) ||\n\t\t   key->basic.n_proto == htons(ETH_P_RARP)) {\n\t\tfl_set_key_val(tb, &key->arp.sip, TCA_FLOWER_KEY_ARP_SIP,\n\t\t\t       &mask->arp.sip, TCA_FLOWER_KEY_ARP_SIP_MASK,\n\t\t\t       sizeof(key->arp.sip));\n\t\tfl_set_key_val(tb, &key->arp.tip, TCA_FLOWER_KEY_ARP_TIP,\n\t\t\t       &mask->arp.tip, TCA_FLOWER_KEY_ARP_TIP_MASK,\n\t\t\t       sizeof(key->arp.tip));\n\t\tfl_set_key_val(tb, &key->arp.op, TCA_FLOWER_KEY_ARP_OP,\n\t\t\t       &mask->arp.op, TCA_FLOWER_KEY_ARP_OP_MASK,\n\t\t\t       sizeof(key->arp.op));\n\t\tfl_set_key_val(tb, key->arp.sha, TCA_FLOWER_KEY_ARP_SHA,\n\t\t\t       mask->arp.sha, TCA_FLOWER_KEY_ARP_SHA_MASK,\n\t\t\t       sizeof(key->arp.sha));\n\t\tfl_set_key_val(tb, key->arp.tha, TCA_FLOWER_KEY_ARP_THA,\n\t\t\t       mask->arp.tha, TCA_FLOWER_KEY_ARP_THA_MASK,\n\t\t\t       sizeof(key->arp.tha));\n\t} else if (key->basic.ip_proto == IPPROTO_L2TP) {\n\t\tfl_set_key_val(tb, &key->l2tpv3.session_id,\n\t\t\t       TCA_FLOWER_KEY_L2TPV3_SID,\n\t\t\t       &mask->l2tpv3.session_id, TCA_FLOWER_UNSPEC,\n\t\t\t       sizeof(key->l2tpv3.session_id));\n\t} else if (key->basic.n_proto  == htons(ETH_P_CFM)) {\n\t\tret = fl_set_key_cfm(tb, key, mask, extack);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (key->basic.ip_proto == IPPROTO_TCP ||\n\t    key->basic.ip_proto == IPPROTO_UDP ||\n\t    key->basic.ip_proto == IPPROTO_SCTP) {\n\t\tret = fl_set_key_port_range(tb, key, mask, extack);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (tb[TCA_FLOWER_KEY_SPI]) {\n\t\tret = fl_set_key_spi(tb, key, mask, extack);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (tb[TCA_FLOWER_KEY_ENC_IPV4_SRC] ||\n\t    tb[TCA_FLOWER_KEY_ENC_IPV4_DST]) {\n\t\tkey->enc_control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tmask->enc_control.addr_type = ~0;\n\t\tfl_set_key_val(tb, &key->enc_ipv4.src,\n\t\t\t       TCA_FLOWER_KEY_ENC_IPV4_SRC,\n\t\t\t       &mask->enc_ipv4.src,\n\t\t\t       TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK,\n\t\t\t       sizeof(key->enc_ipv4.src));\n\t\tfl_set_key_val(tb, &key->enc_ipv4.dst,\n\t\t\t       TCA_FLOWER_KEY_ENC_IPV4_DST,\n\t\t\t       &mask->enc_ipv4.dst,\n\t\t\t       TCA_FLOWER_KEY_ENC_IPV4_DST_MASK,\n\t\t\t       sizeof(key->enc_ipv4.dst));\n\t}\n\n\tif (tb[TCA_FLOWER_KEY_ENC_IPV6_SRC] ||\n\t    tb[TCA_FLOWER_KEY_ENC_IPV6_DST]) {\n\t\tkey->enc_control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\tmask->enc_control.addr_type = ~0;\n\t\tfl_set_key_val(tb, &key->enc_ipv6.src,\n\t\t\t       TCA_FLOWER_KEY_ENC_IPV6_SRC,\n\t\t\t       &mask->enc_ipv6.src,\n\t\t\t       TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK,\n\t\t\t       sizeof(key->enc_ipv6.src));\n\t\tfl_set_key_val(tb, &key->enc_ipv6.dst,\n\t\t\t       TCA_FLOWER_KEY_ENC_IPV6_DST,\n\t\t\t       &mask->enc_ipv6.dst,\n\t\t\t       TCA_FLOWER_KEY_ENC_IPV6_DST_MASK,\n\t\t\t       sizeof(key->enc_ipv6.dst));\n\t}\n\n\tfl_set_key_val(tb, &key->enc_key_id.keyid, TCA_FLOWER_KEY_ENC_KEY_ID,\n\t\t       &mask->enc_key_id.keyid, TCA_FLOWER_UNSPEC,\n\t\t       sizeof(key->enc_key_id.keyid));\n\n\tfl_set_key_val(tb, &key->enc_tp.src, TCA_FLOWER_KEY_ENC_UDP_SRC_PORT,\n\t\t       &mask->enc_tp.src, TCA_FLOWER_KEY_ENC_UDP_SRC_PORT_MASK,\n\t\t       sizeof(key->enc_tp.src));\n\n\tfl_set_key_val(tb, &key->enc_tp.dst, TCA_FLOWER_KEY_ENC_UDP_DST_PORT,\n\t\t       &mask->enc_tp.dst, TCA_FLOWER_KEY_ENC_UDP_DST_PORT_MASK,\n\t\t       sizeof(key->enc_tp.dst));\n\n\tfl_set_key_ip(tb, true, &key->enc_ip, &mask->enc_ip);\n\n\tfl_set_key_val(tb, &key->hash.hash, TCA_FLOWER_KEY_HASH,\n\t\t       &mask->hash.hash, TCA_FLOWER_KEY_HASH_MASK,\n\t\t       sizeof(key->hash.hash));\n\n\tif (tb[TCA_FLOWER_KEY_ENC_OPTS]) {\n\t\tret = fl_set_enc_opt(tb, key, mask, extack);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = fl_set_key_ct(tb, &key->ct, &mask->ct, extack);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[TCA_FLOWER_KEY_FLAGS])\n\t\tret = fl_set_key_flags(tb, &key->control.flags,\n\t\t\t\t       &mask->control.flags, extack);\n\n\treturn ret;\n}\n\nstatic void fl_mask_copy(struct fl_flow_mask *dst,\n\t\t\t struct fl_flow_mask *src)\n{\n\tconst void *psrc = fl_key_get_start(&src->key, src);\n\tvoid *pdst = fl_key_get_start(&dst->key, src);\n\n\tmemcpy(pdst, psrc, fl_mask_range(src));\n\tdst->range = src->range;\n}\n\nstatic const struct rhashtable_params fl_ht_params = {\n\t.key_offset = offsetof(struct cls_fl_filter, mkey),  \n\t.head_offset = offsetof(struct cls_fl_filter, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstatic int fl_init_mask_hashtable(struct fl_flow_mask *mask)\n{\n\tmask->filter_ht_params = fl_ht_params;\n\tmask->filter_ht_params.key_len = fl_mask_range(mask);\n\tmask->filter_ht_params.key_offset += mask->range.start;\n\n\treturn rhashtable_init(&mask->ht, &mask->filter_ht_params);\n}\n\n#define FL_KEY_MEMBER_OFFSET(member) offsetof(struct fl_flow_key, member)\n#define FL_KEY_MEMBER_SIZE(member) sizeof_field(struct fl_flow_key, member)\n\n#define FL_KEY_IS_MASKED(mask, member)\t\t\t\t\t\t\\\n\tmemchr_inv(((char *)mask) + FL_KEY_MEMBER_OFFSET(member),\t\t\\\n\t\t   0, FL_KEY_MEMBER_SIZE(member))\t\t\t\t\\\n\n#define FL_KEY_SET(keys, cnt, id, member)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\tkeys[cnt].key_id = id;\t\t\t\t\t\t\\\n\t\tkeys[cnt].offset = FL_KEY_MEMBER_OFFSET(member);\t\t\\\n\t\tcnt++;\t\t\t\t\t\t\t\t\\\n\t} while(0);\n\n#define FL_KEY_SET_IF_MASKED(mask, keys, cnt, id, member)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\tif (FL_KEY_IS_MASKED(mask, member))\t\t\t\t\\\n\t\t\tFL_KEY_SET(keys, cnt, id, member);\t\t\t\\\n\t} while(0);\n\nstatic void fl_init_dissector(struct flow_dissector *dissector,\n\t\t\t      struct fl_flow_key *mask)\n{\n\tstruct flow_dissector_key keys[FLOW_DISSECTOR_KEY_MAX];\n\tsize_t cnt = 0;\n\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_META, meta);\n\tFL_KEY_SET(keys, cnt, FLOW_DISSECTOR_KEY_CONTROL, control);\n\tFL_KEY_SET(keys, cnt, FLOW_DISSECTOR_KEY_BASIC, basic);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_ETH_ADDRS, eth);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_IPV4_ADDRS, ipv4);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_IPV6_ADDRS, ipv6);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_PORTS, tp);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_PORTS_RANGE, tp_range);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_IP, ip);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_TCP, tcp);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_ICMP, icmp);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_ARP, arp);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_MPLS, mpls);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_VLAN, vlan);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_CVLAN, cvlan);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_ENC_KEYID, enc_key_id);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS, enc_ipv4);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS, enc_ipv6);\n\tif (FL_KEY_IS_MASKED(mask, enc_ipv4) ||\n\t    FL_KEY_IS_MASKED(mask, enc_ipv6))\n\t\tFL_KEY_SET(keys, cnt, FLOW_DISSECTOR_KEY_ENC_CONTROL,\n\t\t\t   enc_control);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_ENC_PORTS, enc_tp);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_ENC_IP, enc_ip);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_ENC_OPTS, enc_opts);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_CT, ct);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_HASH, hash);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_NUM_OF_VLANS, num_of_vlans);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_PPPOE, pppoe);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_L2TPV3, l2tpv3);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_IPSEC, ipsec);\n\tFL_KEY_SET_IF_MASKED(mask, keys, cnt,\n\t\t\t     FLOW_DISSECTOR_KEY_CFM, cfm);\n\n\tskb_flow_dissector_init(dissector, keys, cnt);\n}\n\nstatic struct fl_flow_mask *fl_create_new_mask(struct cls_fl_head *head,\n\t\t\t\t\t       struct fl_flow_mask *mask)\n{\n\tstruct fl_flow_mask *newmask;\n\tint err;\n\n\tnewmask = kzalloc(sizeof(*newmask), GFP_KERNEL);\n\tif (!newmask)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfl_mask_copy(newmask, mask);\n\n\tif ((newmask->key.tp_range.tp_min.dst &&\n\t     newmask->key.tp_range.tp_max.dst) ||\n\t    (newmask->key.tp_range.tp_min.src &&\n\t     newmask->key.tp_range.tp_max.src))\n\t\tnewmask->flags |= TCA_FLOWER_MASK_FLAGS_RANGE;\n\n\terr = fl_init_mask_hashtable(newmask);\n\tif (err)\n\t\tgoto errout_free;\n\n\tfl_init_dissector(&newmask->dissector, &newmask->key);\n\n\tINIT_LIST_HEAD_RCU(&newmask->filters);\n\n\trefcount_set(&newmask->refcnt, 1);\n\terr = rhashtable_replace_fast(&head->ht, &mask->ht_node,\n\t\t\t\t      &newmask->ht_node, mask_ht_params);\n\tif (err)\n\t\tgoto errout_destroy;\n\n\tspin_lock(&head->masks_lock);\n\tlist_add_tail_rcu(&newmask->list, &head->masks);\n\tspin_unlock(&head->masks_lock);\n\n\treturn newmask;\n\nerrout_destroy:\n\trhashtable_destroy(&newmask->ht);\nerrout_free:\n\tkfree(newmask);\n\n\treturn ERR_PTR(err);\n}\n\nstatic int fl_check_assign_mask(struct cls_fl_head *head,\n\t\t\t\tstruct cls_fl_filter *fnew,\n\t\t\t\tstruct cls_fl_filter *fold,\n\t\t\t\tstruct fl_flow_mask *mask)\n{\n\tstruct fl_flow_mask *newmask;\n\tint ret = 0;\n\n\trcu_read_lock();\n\n\t \n\tfnew->mask = rhashtable_lookup_get_insert_fast(&head->ht,\n\t\t\t\t\t\t       &mask->ht_node,\n\t\t\t\t\t\t       mask_ht_params);\n\tif (!fnew->mask) {\n\t\trcu_read_unlock();\n\n\t\tif (fold) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto errout_cleanup;\n\t\t}\n\n\t\tnewmask = fl_create_new_mask(head, mask);\n\t\tif (IS_ERR(newmask)) {\n\t\t\tret = PTR_ERR(newmask);\n\t\t\tgoto errout_cleanup;\n\t\t}\n\n\t\tfnew->mask = newmask;\n\t\treturn 0;\n\t} else if (IS_ERR(fnew->mask)) {\n\t\tret = PTR_ERR(fnew->mask);\n\t} else if (fold && fold->mask != fnew->mask) {\n\t\tret = -EINVAL;\n\t} else if (!refcount_inc_not_zero(&fnew->mask->refcnt)) {\n\t\t \n\t\tret = -EAGAIN;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n\nerrout_cleanup:\n\trhashtable_remove_fast(&head->ht, &mask->ht_node,\n\t\t\t       mask_ht_params);\n\treturn ret;\n}\n\nstatic bool fl_needs_tc_skb_ext(const struct fl_flow_key *mask)\n{\n\treturn mask->meta.l2_miss;\n}\n\nstatic int fl_ht_insert_unique(struct cls_fl_filter *fnew,\n\t\t\t       struct cls_fl_filter *fold,\n\t\t\t       bool *in_ht)\n{\n\tstruct fl_flow_mask *mask = fnew->mask;\n\tint err;\n\n\terr = rhashtable_lookup_insert_fast(&mask->ht,\n\t\t\t\t\t    &fnew->ht_node,\n\t\t\t\t\t    mask->filter_ht_params);\n\tif (err) {\n\t\t*in_ht = false;\n\t\t \n\t\treturn fold && err == -EEXIST ? 0 : err;\n\t}\n\n\t*in_ht = true;\n\treturn 0;\n}\n\nstatic int fl_change(struct net *net, struct sk_buff *in_skb,\n\t\t     struct tcf_proto *tp, unsigned long base,\n\t\t     u32 handle, struct nlattr **tca,\n\t\t     void **arg, u32 flags,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct cls_fl_head *head = fl_head_dereference(tp);\n\tbool rtnl_held = !(flags & TCA_ACT_FLAGS_NO_RTNL);\n\tstruct cls_fl_filter *fold = *arg;\n\tbool bound_to_filter = false;\n\tstruct cls_fl_filter *fnew;\n\tstruct fl_flow_mask *mask;\n\tstruct nlattr **tb;\n\tbool in_ht;\n\tint err;\n\n\tif (!tca[TCA_OPTIONS]) {\n\t\terr = -EINVAL;\n\t\tgoto errout_fold;\n\t}\n\n\tmask = kzalloc(sizeof(struct fl_flow_mask), GFP_KERNEL);\n\tif (!mask) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout_fold;\n\t}\n\n\ttb = kcalloc(TCA_FLOWER_MAX + 1, sizeof(struct nlattr *), GFP_KERNEL);\n\tif (!tb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout_mask_alloc;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, TCA_FLOWER_MAX,\n\t\t\t\t\t  tca[TCA_OPTIONS], fl_policy, NULL);\n\tif (err < 0)\n\t\tgoto errout_tb;\n\n\tif (fold && handle && fold->handle != handle) {\n\t\terr = -EINVAL;\n\t\tgoto errout_tb;\n\t}\n\n\tfnew = kzalloc(sizeof(*fnew), GFP_KERNEL);\n\tif (!fnew) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout_tb;\n\t}\n\tINIT_LIST_HEAD(&fnew->hw_list);\n\trefcount_set(&fnew->refcnt, 1);\n\n\tif (tb[TCA_FLOWER_FLAGS]) {\n\t\tfnew->flags = nla_get_u32(tb[TCA_FLOWER_FLAGS]);\n\n\t\tif (!tc_flags_valid(fnew->flags)) {\n\t\t\tkfree(fnew);\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_tb;\n\t\t}\n\t}\n\n\tif (!fold) {\n\t\tspin_lock(&tp->lock);\n\t\tif (!handle) {\n\t\t\thandle = 1;\n\t\t\terr = idr_alloc_u32(&head->handle_idr, NULL, &handle,\n\t\t\t\t\t    INT_MAX, GFP_ATOMIC);\n\t\t} else {\n\t\t\terr = idr_alloc_u32(&head->handle_idr, NULL, &handle,\n\t\t\t\t\t    handle, GFP_ATOMIC);\n\n\t\t\t \n\t\t\tif (err == -ENOSPC)\n\t\t\t\terr = -EAGAIN;\n\t\t}\n\t\tspin_unlock(&tp->lock);\n\n\t\tif (err) {\n\t\t\tkfree(fnew);\n\t\t\tgoto errout_tb;\n\t\t}\n\t}\n\tfnew->handle = handle;\n\n\terr = tcf_exts_init_ex(&fnew->exts, net, TCA_FLOWER_ACT, 0, tp, handle,\n\t\t\t       !tc_skip_hw(fnew->flags));\n\tif (err < 0)\n\t\tgoto errout_idr;\n\n\terr = tcf_exts_validate_ex(net, tp, tb, tca[TCA_RATE],\n\t\t\t\t   &fnew->exts, flags, fnew->flags,\n\t\t\t\t   extack);\n\tif (err < 0)\n\t\tgoto errout_idr;\n\n\tif (tb[TCA_FLOWER_CLASSID]) {\n\t\tfnew->res.classid = nla_get_u32(tb[TCA_FLOWER_CLASSID]);\n\t\tif (flags & TCA_ACT_FLAGS_NO_RTNL)\n\t\t\trtnl_lock();\n\t\ttcf_bind_filter(tp, &fnew->res, base);\n\t\tif (flags & TCA_ACT_FLAGS_NO_RTNL)\n\t\t\trtnl_unlock();\n\t\tbound_to_filter = true;\n\t}\n\n\terr = fl_set_key(net, tb, &fnew->key, &mask->key, extack);\n\tif (err)\n\t\tgoto unbind_filter;\n\n\tfl_mask_update_range(mask);\n\tfl_set_masked_key(&fnew->mkey, &fnew->key, mask);\n\n\tif (!fl_mask_fits_tmplt(tp->chain->tmplt_priv, mask)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Mask does not fit the template\");\n\t\terr = -EINVAL;\n\t\tgoto unbind_filter;\n\t}\n\n\t \n\tif (fl_needs_tc_skb_ext(&mask->key)) {\n\t\tfnew->needs_tc_skb_ext = 1;\n\t\ttc_skb_ext_tc_enable();\n\t}\n\n\terr = fl_check_assign_mask(head, fnew, fold, mask);\n\tif (err)\n\t\tgoto unbind_filter;\n\n\terr = fl_ht_insert_unique(fnew, fold, &in_ht);\n\tif (err)\n\t\tgoto errout_mask;\n\n\tif (!tc_skip_hw(fnew->flags)) {\n\t\terr = fl_hw_replace_filter(tp, fnew, rtnl_held, extack);\n\t\tif (err)\n\t\t\tgoto errout_ht;\n\t}\n\n\tif (!tc_in_hw(fnew->flags))\n\t\tfnew->flags |= TCA_CLS_FLAGS_NOT_IN_HW;\n\n\tspin_lock(&tp->lock);\n\n\t \n\tif (tp->deleting) {\n\t\terr = -EAGAIN;\n\t\tgoto errout_hw;\n\t}\n\n\tif (fold) {\n\t\t \n\t\tif (fold->deleted) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto errout_hw;\n\t\t}\n\n\t\tfnew->handle = handle;\n\n\t\tif (!in_ht) {\n\t\t\tstruct rhashtable_params params =\n\t\t\t\tfnew->mask->filter_ht_params;\n\n\t\t\terr = rhashtable_insert_fast(&fnew->mask->ht,\n\t\t\t\t\t\t     &fnew->ht_node,\n\t\t\t\t\t\t     params);\n\t\t\tif (err)\n\t\t\t\tgoto errout_hw;\n\t\t\tin_ht = true;\n\t\t}\n\n\t\trefcount_inc(&fnew->refcnt);\n\t\trhashtable_remove_fast(&fold->mask->ht,\n\t\t\t\t       &fold->ht_node,\n\t\t\t\t       fold->mask->filter_ht_params);\n\t\tidr_replace(&head->handle_idr, fnew, fnew->handle);\n\t\tlist_replace_rcu(&fold->list, &fnew->list);\n\t\tfold->deleted = true;\n\n\t\tspin_unlock(&tp->lock);\n\n\t\tfl_mask_put(head, fold->mask);\n\t\tif (!tc_skip_hw(fold->flags))\n\t\t\tfl_hw_destroy_filter(tp, fold, rtnl_held, NULL);\n\t\ttcf_unbind_filter(tp, &fold->res);\n\t\t \n\t\trefcount_dec(&fold->refcnt);\n\t\t__fl_put(fold);\n\t} else {\n\t\tidr_replace(&head->handle_idr, fnew, fnew->handle);\n\n\t\trefcount_inc(&fnew->refcnt);\n\t\tlist_add_tail_rcu(&fnew->list, &fnew->mask->filters);\n\t\tspin_unlock(&tp->lock);\n\t}\n\n\t*arg = fnew;\n\n\tkfree(tb);\n\ttcf_queue_work(&mask->rwork, fl_uninit_mask_free_work);\n\treturn 0;\n\nerrout_ht:\n\tspin_lock(&tp->lock);\nerrout_hw:\n\tfnew->deleted = true;\n\tspin_unlock(&tp->lock);\n\tif (!tc_skip_hw(fnew->flags))\n\t\tfl_hw_destroy_filter(tp, fnew, rtnl_held, NULL);\n\tif (in_ht)\n\t\trhashtable_remove_fast(&fnew->mask->ht, &fnew->ht_node,\n\t\t\t\t       fnew->mask->filter_ht_params);\nerrout_mask:\n\tfl_mask_put(head, fnew->mask);\n\nunbind_filter:\n\tif (bound_to_filter) {\n\t\tif (flags & TCA_ACT_FLAGS_NO_RTNL)\n\t\t\trtnl_lock();\n\t\ttcf_unbind_filter(tp, &fnew->res);\n\t\tif (flags & TCA_ACT_FLAGS_NO_RTNL)\n\t\t\trtnl_unlock();\n\t}\n\nerrout_idr:\n\tif (!fold)\n\t\tidr_remove(&head->handle_idr, fnew->handle);\n\t__fl_put(fnew);\nerrout_tb:\n\tkfree(tb);\nerrout_mask_alloc:\n\ttcf_queue_work(&mask->rwork, fl_uninit_mask_free_work);\nerrout_fold:\n\tif (fold)\n\t\t__fl_put(fold);\n\treturn err;\n}\n\nstatic int fl_delete(struct tcf_proto *tp, void *arg, bool *last,\n\t\t     bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct cls_fl_head *head = fl_head_dereference(tp);\n\tstruct cls_fl_filter *f = arg;\n\tbool last_on_mask;\n\tint err = 0;\n\n\terr = __fl_delete(tp, f, &last_on_mask, rtnl_held, extack);\n\t*last = list_empty(&head->masks);\n\t__fl_put(f);\n\n\treturn err;\n}\n\nstatic void fl_walk(struct tcf_proto *tp, struct tcf_walker *arg,\n\t\t    bool rtnl_held)\n{\n\tstruct cls_fl_head *head = fl_head_dereference(tp);\n\tunsigned long id = arg->cookie, tmp;\n\tstruct cls_fl_filter *f;\n\n\targ->count = arg->skip;\n\n\trcu_read_lock();\n\tidr_for_each_entry_continue_ul(&head->handle_idr, f, tmp, id) {\n\t\t \n\t\tif (!f || !refcount_inc_not_zero(&f->refcnt))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tif (arg->fn(tp, f, arg) < 0) {\n\t\t\t__fl_put(f);\n\t\t\targ->stop = 1;\n\t\t\trcu_read_lock();\n\t\t\tbreak;\n\t\t}\n\t\t__fl_put(f);\n\t\targ->count++;\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n\targ->cookie = id;\n}\n\nstatic struct cls_fl_filter *\nfl_get_next_hw_filter(struct tcf_proto *tp, struct cls_fl_filter *f, bool add)\n{\n\tstruct cls_fl_head *head = fl_head_dereference(tp);\n\n\tspin_lock(&tp->lock);\n\tif (list_empty(&head->hw_filters)) {\n\t\tspin_unlock(&tp->lock);\n\t\treturn NULL;\n\t}\n\n\tif (!f)\n\t\tf = list_entry(&head->hw_filters, struct cls_fl_filter,\n\t\t\t       hw_list);\n\tlist_for_each_entry_continue(f, &head->hw_filters, hw_list) {\n\t\tif (!(add && f->deleted) && refcount_inc_not_zero(&f->refcnt)) {\n\t\t\tspin_unlock(&tp->lock);\n\t\t\treturn f;\n\t\t}\n\t}\n\n\tspin_unlock(&tp->lock);\n\treturn NULL;\n}\n\nstatic int fl_reoffload(struct tcf_proto *tp, bool add, flow_setup_cb_t *cb,\n\t\t\tvoid *cb_priv, struct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct flow_cls_offload cls_flower = {};\n\tstruct cls_fl_filter *f = NULL;\n\tint err;\n\n\t \n\tASSERT_RTNL();\n\n\twhile ((f = fl_get_next_hw_filter(tp, f, add))) {\n\t\tcls_flower.rule =\n\t\t\tflow_rule_alloc(tcf_exts_num_actions(&f->exts));\n\t\tif (!cls_flower.rule) {\n\t\t\t__fl_put(f);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttc_cls_common_offload_init(&cls_flower.common, tp, f->flags,\n\t\t\t\t\t   extack);\n\t\tcls_flower.command = add ?\n\t\t\tFLOW_CLS_REPLACE : FLOW_CLS_DESTROY;\n\t\tcls_flower.cookie = (unsigned long)f;\n\t\tcls_flower.rule->match.dissector = &f->mask->dissector;\n\t\tcls_flower.rule->match.mask = &f->mask->key;\n\t\tcls_flower.rule->match.key = &f->mkey;\n\n\t\terr = tc_setup_offload_action(&cls_flower.rule->action, &f->exts,\n\t\t\t\t\t      cls_flower.common.extack);\n\t\tif (err) {\n\t\t\tkfree(cls_flower.rule);\n\t\t\tif (tc_skip_sw(f->flags)) {\n\t\t\t\t__fl_put(f);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tgoto next_flow;\n\t\t}\n\n\t\tcls_flower.classid = f->res.classid;\n\n\t\terr = tc_setup_cb_reoffload(block, tp, add, cb,\n\t\t\t\t\t    TC_SETUP_CLSFLOWER, &cls_flower,\n\t\t\t\t\t    cb_priv, &f->flags,\n\t\t\t\t\t    &f->in_hw_count);\n\t\ttc_cleanup_offload_action(&cls_flower.rule->action);\n\t\tkfree(cls_flower.rule);\n\n\t\tif (err) {\n\t\t\t__fl_put(f);\n\t\t\treturn err;\n\t\t}\nnext_flow:\n\t\t__fl_put(f);\n\t}\n\n\treturn 0;\n}\n\nstatic void fl_hw_add(struct tcf_proto *tp, void *type_data)\n{\n\tstruct flow_cls_offload *cls_flower = type_data;\n\tstruct cls_fl_filter *f =\n\t\t(struct cls_fl_filter *) cls_flower->cookie;\n\tstruct cls_fl_head *head = fl_head_dereference(tp);\n\n\tspin_lock(&tp->lock);\n\tlist_add(&f->hw_list, &head->hw_filters);\n\tspin_unlock(&tp->lock);\n}\n\nstatic void fl_hw_del(struct tcf_proto *tp, void *type_data)\n{\n\tstruct flow_cls_offload *cls_flower = type_data;\n\tstruct cls_fl_filter *f =\n\t\t(struct cls_fl_filter *) cls_flower->cookie;\n\n\tspin_lock(&tp->lock);\n\tif (!list_empty(&f->hw_list))\n\t\tlist_del_init(&f->hw_list);\n\tspin_unlock(&tp->lock);\n}\n\nstatic int fl_hw_create_tmplt(struct tcf_chain *chain,\n\t\t\t      struct fl_flow_tmplt *tmplt)\n{\n\tstruct flow_cls_offload cls_flower = {};\n\tstruct tcf_block *block = chain->block;\n\n\tcls_flower.rule = flow_rule_alloc(0);\n\tif (!cls_flower.rule)\n\t\treturn -ENOMEM;\n\n\tcls_flower.common.chain_index = chain->index;\n\tcls_flower.command = FLOW_CLS_TMPLT_CREATE;\n\tcls_flower.cookie = (unsigned long) tmplt;\n\tcls_flower.rule->match.dissector = &tmplt->dissector;\n\tcls_flower.rule->match.mask = &tmplt->mask;\n\tcls_flower.rule->match.key = &tmplt->dummy_key;\n\n\t \n\ttc_setup_cb_call(block, TC_SETUP_CLSFLOWER, &cls_flower, false, true);\n\tkfree(cls_flower.rule);\n\n\treturn 0;\n}\n\nstatic void fl_hw_destroy_tmplt(struct tcf_chain *chain,\n\t\t\t\tstruct fl_flow_tmplt *tmplt)\n{\n\tstruct flow_cls_offload cls_flower = {};\n\tstruct tcf_block *block = chain->block;\n\n\tcls_flower.common.chain_index = chain->index;\n\tcls_flower.command = FLOW_CLS_TMPLT_DESTROY;\n\tcls_flower.cookie = (unsigned long) tmplt;\n\n\ttc_setup_cb_call(block, TC_SETUP_CLSFLOWER, &cls_flower, false, true);\n}\n\nstatic void *fl_tmplt_create(struct net *net, struct tcf_chain *chain,\n\t\t\t     struct nlattr **tca,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct fl_flow_tmplt *tmplt;\n\tstruct nlattr **tb;\n\tint err;\n\n\tif (!tca[TCA_OPTIONS])\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttb = kcalloc(TCA_FLOWER_MAX + 1, sizeof(struct nlattr *), GFP_KERNEL);\n\tif (!tb)\n\t\treturn ERR_PTR(-ENOBUFS);\n\terr = nla_parse_nested_deprecated(tb, TCA_FLOWER_MAX,\n\t\t\t\t\t  tca[TCA_OPTIONS], fl_policy, NULL);\n\tif (err)\n\t\tgoto errout_tb;\n\n\ttmplt = kzalloc(sizeof(*tmplt), GFP_KERNEL);\n\tif (!tmplt) {\n\t\terr = -ENOMEM;\n\t\tgoto errout_tb;\n\t}\n\ttmplt->chain = chain;\n\terr = fl_set_key(net, tb, &tmplt->dummy_key, &tmplt->mask, extack);\n\tif (err)\n\t\tgoto errout_tmplt;\n\n\tfl_init_dissector(&tmplt->dissector, &tmplt->mask);\n\n\terr = fl_hw_create_tmplt(chain, tmplt);\n\tif (err)\n\t\tgoto errout_tmplt;\n\n\tkfree(tb);\n\treturn tmplt;\n\nerrout_tmplt:\n\tkfree(tmplt);\nerrout_tb:\n\tkfree(tb);\n\treturn ERR_PTR(err);\n}\n\nstatic void fl_tmplt_destroy(void *tmplt_priv)\n{\n\tstruct fl_flow_tmplt *tmplt = tmplt_priv;\n\n\tfl_hw_destroy_tmplt(tmplt->chain, tmplt);\n\tkfree(tmplt);\n}\n\nstatic int fl_dump_key_val(struct sk_buff *skb,\n\t\t\t   void *val, int val_type,\n\t\t\t   void *mask, int mask_type, int len)\n{\n\tint err;\n\n\tif (!memchr_inv(mask, 0, len))\n\t\treturn 0;\n\terr = nla_put(skb, val_type, len, val);\n\tif (err)\n\t\treturn err;\n\tif (mask_type != TCA_FLOWER_UNSPEC) {\n\t\terr = nla_put(skb, mask_type, len, mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fl_dump_key_port_range(struct sk_buff *skb, struct fl_flow_key *key,\n\t\t\t\t  struct fl_flow_key *mask)\n{\n\tif (fl_dump_key_val(skb, &key->tp_range.tp_min.dst,\n\t\t\t    TCA_FLOWER_KEY_PORT_DST_MIN,\n\t\t\t    &mask->tp_range.tp_min.dst, TCA_FLOWER_UNSPEC,\n\t\t\t    sizeof(key->tp_range.tp_min.dst)) ||\n\t    fl_dump_key_val(skb, &key->tp_range.tp_max.dst,\n\t\t\t    TCA_FLOWER_KEY_PORT_DST_MAX,\n\t\t\t    &mask->tp_range.tp_max.dst, TCA_FLOWER_UNSPEC,\n\t\t\t    sizeof(key->tp_range.tp_max.dst)) ||\n\t    fl_dump_key_val(skb, &key->tp_range.tp_min.src,\n\t\t\t    TCA_FLOWER_KEY_PORT_SRC_MIN,\n\t\t\t    &mask->tp_range.tp_min.src, TCA_FLOWER_UNSPEC,\n\t\t\t    sizeof(key->tp_range.tp_min.src)) ||\n\t    fl_dump_key_val(skb, &key->tp_range.tp_max.src,\n\t\t\t    TCA_FLOWER_KEY_PORT_SRC_MAX,\n\t\t\t    &mask->tp_range.tp_max.src, TCA_FLOWER_UNSPEC,\n\t\t\t    sizeof(key->tp_range.tp_max.src)))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int fl_dump_key_mpls_opt_lse(struct sk_buff *skb,\n\t\t\t\t    struct flow_dissector_key_mpls *mpls_key,\n\t\t\t\t    struct flow_dissector_key_mpls *mpls_mask,\n\t\t\t\t    u8 lse_index)\n{\n\tstruct flow_dissector_mpls_lse *lse_mask = &mpls_mask->ls[lse_index];\n\tstruct flow_dissector_mpls_lse *lse_key = &mpls_key->ls[lse_index];\n\tint err;\n\n\terr = nla_put_u8(skb, TCA_FLOWER_KEY_MPLS_OPT_LSE_DEPTH,\n\t\t\t lse_index + 1);\n\tif (err)\n\t\treturn err;\n\n\tif (lse_mask->mpls_ttl) {\n\t\terr = nla_put_u8(skb, TCA_FLOWER_KEY_MPLS_OPT_LSE_TTL,\n\t\t\t\t lse_key->mpls_ttl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (lse_mask->mpls_bos) {\n\t\terr = nla_put_u8(skb, TCA_FLOWER_KEY_MPLS_OPT_LSE_BOS,\n\t\t\t\t lse_key->mpls_bos);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (lse_mask->mpls_tc) {\n\t\terr = nla_put_u8(skb, TCA_FLOWER_KEY_MPLS_OPT_LSE_TC,\n\t\t\t\t lse_key->mpls_tc);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (lse_mask->mpls_label) {\n\t\terr = nla_put_u32(skb, TCA_FLOWER_KEY_MPLS_OPT_LSE_LABEL,\n\t\t\t\t  lse_key->mpls_label);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int fl_dump_key_mpls_opts(struct sk_buff *skb,\n\t\t\t\t struct flow_dissector_key_mpls *mpls_key,\n\t\t\t\t struct flow_dissector_key_mpls *mpls_mask)\n{\n\tstruct nlattr *opts;\n\tstruct nlattr *lse;\n\tu8 lse_index;\n\tint err;\n\n\topts = nla_nest_start(skb, TCA_FLOWER_KEY_MPLS_OPTS);\n\tif (!opts)\n\t\treturn -EMSGSIZE;\n\n\tfor (lse_index = 0; lse_index < FLOW_DIS_MPLS_MAX; lse_index++) {\n\t\tif (!(mpls_mask->used_lses & 1 << lse_index))\n\t\t\tcontinue;\n\n\t\tlse = nla_nest_start(skb, TCA_FLOWER_KEY_MPLS_OPTS_LSE);\n\t\tif (!lse) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tgoto err_opts;\n\t\t}\n\n\t\terr = fl_dump_key_mpls_opt_lse(skb, mpls_key, mpls_mask,\n\t\t\t\t\t       lse_index);\n\t\tif (err)\n\t\t\tgoto err_opts_lse;\n\t\tnla_nest_end(skb, lse);\n\t}\n\tnla_nest_end(skb, opts);\n\n\treturn 0;\n\nerr_opts_lse:\n\tnla_nest_cancel(skb, lse);\nerr_opts:\n\tnla_nest_cancel(skb, opts);\n\n\treturn err;\n}\n\nstatic int fl_dump_key_mpls(struct sk_buff *skb,\n\t\t\t    struct flow_dissector_key_mpls *mpls_key,\n\t\t\t    struct flow_dissector_key_mpls *mpls_mask)\n{\n\tstruct flow_dissector_mpls_lse *lse_mask;\n\tstruct flow_dissector_mpls_lse *lse_key;\n\tint err;\n\n\tif (!mpls_mask->used_lses)\n\t\treturn 0;\n\n\tlse_mask = &mpls_mask->ls[0];\n\tlse_key = &mpls_key->ls[0];\n\n\t \n\tif (mpls_mask->used_lses & ~1 ||\n\t    (!lse_mask->mpls_ttl && !lse_mask->mpls_bos &&\n\t     !lse_mask->mpls_tc && !lse_mask->mpls_label))\n\t\treturn fl_dump_key_mpls_opts(skb, mpls_key, mpls_mask);\n\n\tif (lse_mask->mpls_ttl) {\n\t\terr = nla_put_u8(skb, TCA_FLOWER_KEY_MPLS_TTL,\n\t\t\t\t lse_key->mpls_ttl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (lse_mask->mpls_tc) {\n\t\terr = nla_put_u8(skb, TCA_FLOWER_KEY_MPLS_TC,\n\t\t\t\t lse_key->mpls_tc);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (lse_mask->mpls_label) {\n\t\terr = nla_put_u32(skb, TCA_FLOWER_KEY_MPLS_LABEL,\n\t\t\t\t  lse_key->mpls_label);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (lse_mask->mpls_bos) {\n\t\terr = nla_put_u8(skb, TCA_FLOWER_KEY_MPLS_BOS,\n\t\t\t\t lse_key->mpls_bos);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fl_dump_key_ip(struct sk_buff *skb, bool encap,\n\t\t\t  struct flow_dissector_key_ip *key,\n\t\t\t  struct flow_dissector_key_ip *mask)\n{\n\tint tos_key = encap ? TCA_FLOWER_KEY_ENC_IP_TOS : TCA_FLOWER_KEY_IP_TOS;\n\tint ttl_key = encap ? TCA_FLOWER_KEY_ENC_IP_TTL : TCA_FLOWER_KEY_IP_TTL;\n\tint tos_mask = encap ? TCA_FLOWER_KEY_ENC_IP_TOS_MASK : TCA_FLOWER_KEY_IP_TOS_MASK;\n\tint ttl_mask = encap ? TCA_FLOWER_KEY_ENC_IP_TTL_MASK : TCA_FLOWER_KEY_IP_TTL_MASK;\n\n\tif (fl_dump_key_val(skb, &key->tos, tos_key, &mask->tos, tos_mask, sizeof(key->tos)) ||\n\t    fl_dump_key_val(skb, &key->ttl, ttl_key, &mask->ttl, ttl_mask, sizeof(key->ttl)))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int fl_dump_key_vlan(struct sk_buff *skb,\n\t\t\t    int vlan_id_key, int vlan_prio_key,\n\t\t\t    struct flow_dissector_key_vlan *vlan_key,\n\t\t\t    struct flow_dissector_key_vlan *vlan_mask)\n{\n\tint err;\n\n\tif (!memchr_inv(vlan_mask, 0, sizeof(*vlan_mask)))\n\t\treturn 0;\n\tif (vlan_mask->vlan_id) {\n\t\terr = nla_put_u16(skb, vlan_id_key,\n\t\t\t\t  vlan_key->vlan_id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (vlan_mask->vlan_priority) {\n\t\terr = nla_put_u8(skb, vlan_prio_key,\n\t\t\t\t vlan_key->vlan_priority);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void fl_get_key_flag(u32 dissector_key, u32 dissector_mask,\n\t\t\t    u32 *flower_key, u32 *flower_mask,\n\t\t\t    u32 flower_flag_bit, u32 dissector_flag_bit)\n{\n\tif (dissector_mask & dissector_flag_bit) {\n\t\t*flower_mask |= flower_flag_bit;\n\t\tif (dissector_key & dissector_flag_bit)\n\t\t\t*flower_key |= flower_flag_bit;\n\t}\n}\n\nstatic int fl_dump_key_flags(struct sk_buff *skb, u32 flags_key, u32 flags_mask)\n{\n\tu32 key, mask;\n\t__be32 _key, _mask;\n\tint err;\n\n\tif (!memchr_inv(&flags_mask, 0, sizeof(flags_mask)))\n\t\treturn 0;\n\n\tkey = 0;\n\tmask = 0;\n\n\tfl_get_key_flag(flags_key, flags_mask, &key, &mask,\n\t\t\tTCA_FLOWER_KEY_FLAGS_IS_FRAGMENT, FLOW_DIS_IS_FRAGMENT);\n\tfl_get_key_flag(flags_key, flags_mask, &key, &mask,\n\t\t\tTCA_FLOWER_KEY_FLAGS_FRAG_IS_FIRST,\n\t\t\tFLOW_DIS_FIRST_FRAG);\n\n\t_key = cpu_to_be32(key);\n\t_mask = cpu_to_be32(mask);\n\n\terr = nla_put(skb, TCA_FLOWER_KEY_FLAGS, 4, &_key);\n\tif (err)\n\t\treturn err;\n\n\treturn nla_put(skb, TCA_FLOWER_KEY_FLAGS_MASK, 4, &_mask);\n}\n\nstatic int fl_dump_key_geneve_opt(struct sk_buff *skb,\n\t\t\t\t  struct flow_dissector_key_enc_opts *enc_opts)\n{\n\tstruct geneve_opt *opt;\n\tstruct nlattr *nest;\n\tint opt_off = 0;\n\n\tnest = nla_nest_start_noflag(skb, TCA_FLOWER_KEY_ENC_OPTS_GENEVE);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\twhile (enc_opts->len > opt_off) {\n\t\topt = (struct geneve_opt *)&enc_opts->data[opt_off];\n\n\t\tif (nla_put_be16(skb, TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS,\n\t\t\t\t opt->opt_class))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u8(skb, TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE,\n\t\t\t       opt->type))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put(skb, TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA,\n\t\t\t    opt->length * 4, opt->opt_data))\n\t\t\tgoto nla_put_failure;\n\n\t\topt_off += sizeof(struct geneve_opt) + opt->length * 4;\n\t}\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int fl_dump_key_vxlan_opt(struct sk_buff *skb,\n\t\t\t\t struct flow_dissector_key_enc_opts *enc_opts)\n{\n\tstruct vxlan_metadata *md;\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, TCA_FLOWER_KEY_ENC_OPTS_VXLAN);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tmd = (struct vxlan_metadata *)&enc_opts->data[0];\n\tif (nla_put_u32(skb, TCA_FLOWER_KEY_ENC_OPT_VXLAN_GBP, md->gbp))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int fl_dump_key_erspan_opt(struct sk_buff *skb,\n\t\t\t\t  struct flow_dissector_key_enc_opts *enc_opts)\n{\n\tstruct erspan_metadata *md;\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, TCA_FLOWER_KEY_ENC_OPTS_ERSPAN);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tmd = (struct erspan_metadata *)&enc_opts->data[0];\n\tif (nla_put_u8(skb, TCA_FLOWER_KEY_ENC_OPT_ERSPAN_VER, md->version))\n\t\tgoto nla_put_failure;\n\n\tif (md->version == 1 &&\n\t    nla_put_be32(skb, TCA_FLOWER_KEY_ENC_OPT_ERSPAN_INDEX, md->u.index))\n\t\tgoto nla_put_failure;\n\n\tif (md->version == 2 &&\n\t    (nla_put_u8(skb, TCA_FLOWER_KEY_ENC_OPT_ERSPAN_DIR,\n\t\t\tmd->u.md2.dir) ||\n\t     nla_put_u8(skb, TCA_FLOWER_KEY_ENC_OPT_ERSPAN_HWID,\n\t\t\tget_hwid(&md->u.md2))))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int fl_dump_key_gtp_opt(struct sk_buff *skb,\n\t\t\t       struct flow_dissector_key_enc_opts *enc_opts)\n\n{\n\tstruct gtp_pdu_session_info *session_info;\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, TCA_FLOWER_KEY_ENC_OPTS_GTP);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tsession_info = (struct gtp_pdu_session_info *)&enc_opts->data[0];\n\n\tif (nla_put_u8(skb, TCA_FLOWER_KEY_ENC_OPT_GTP_PDU_TYPE,\n\t\t       session_info->pdu_type))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, TCA_FLOWER_KEY_ENC_OPT_GTP_QFI, session_info->qfi))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int fl_dump_key_ct(struct sk_buff *skb,\n\t\t\t  struct flow_dissector_key_ct *key,\n\t\t\t  struct flow_dissector_key_ct *mask)\n{\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK) &&\n\t    fl_dump_key_val(skb, &key->ct_state, TCA_FLOWER_KEY_CT_STATE,\n\t\t\t    &mask->ct_state, TCA_FLOWER_KEY_CT_STATE_MASK,\n\t\t\t    sizeof(key->ct_state)))\n\t\tgoto nla_put_failure;\n\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_ZONES) &&\n\t    fl_dump_key_val(skb, &key->ct_zone, TCA_FLOWER_KEY_CT_ZONE,\n\t\t\t    &mask->ct_zone, TCA_FLOWER_KEY_CT_ZONE_MASK,\n\t\t\t    sizeof(key->ct_zone)))\n\t\tgoto nla_put_failure;\n\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_MARK) &&\n\t    fl_dump_key_val(skb, &key->ct_mark, TCA_FLOWER_KEY_CT_MARK,\n\t\t\t    &mask->ct_mark, TCA_FLOWER_KEY_CT_MARK_MASK,\n\t\t\t    sizeof(key->ct_mark)))\n\t\tgoto nla_put_failure;\n\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_LABELS) &&\n\t    fl_dump_key_val(skb, &key->ct_labels, TCA_FLOWER_KEY_CT_LABELS,\n\t\t\t    &mask->ct_labels, TCA_FLOWER_KEY_CT_LABELS_MASK,\n\t\t\t    sizeof(key->ct_labels)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int fl_dump_key_cfm(struct sk_buff *skb,\n\t\t\t   struct flow_dissector_key_cfm *key,\n\t\t\t   struct flow_dissector_key_cfm *mask)\n{\n\tstruct nlattr *opts;\n\tint err;\n\tu8 mdl;\n\n\tif (!memchr_inv(mask, 0, sizeof(*mask)))\n\t\treturn 0;\n\n\topts = nla_nest_start(skb, TCA_FLOWER_KEY_CFM);\n\tif (!opts)\n\t\treturn -EMSGSIZE;\n\n\tif (FIELD_GET(FLOW_DIS_CFM_MDL_MASK, mask->mdl_ver)) {\n\t\tmdl = FIELD_GET(FLOW_DIS_CFM_MDL_MASK, key->mdl_ver);\n\t\terr = nla_put_u8(skb, TCA_FLOWER_KEY_CFM_MD_LEVEL, mdl);\n\t\tif (err)\n\t\t\tgoto err_cfm_opts;\n\t}\n\n\tif (mask->opcode) {\n\t\terr = nla_put_u8(skb, TCA_FLOWER_KEY_CFM_OPCODE, key->opcode);\n\t\tif (err)\n\t\t\tgoto err_cfm_opts;\n\t}\n\n\tnla_nest_end(skb, opts);\n\n\treturn 0;\n\nerr_cfm_opts:\n\tnla_nest_cancel(skb, opts);\n\treturn err;\n}\n\nstatic int fl_dump_key_options(struct sk_buff *skb, int enc_opt_type,\n\t\t\t       struct flow_dissector_key_enc_opts *enc_opts)\n{\n\tstruct nlattr *nest;\n\tint err;\n\n\tif (!enc_opts->len)\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(skb, enc_opt_type);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tswitch (enc_opts->dst_opt_type) {\n\tcase TUNNEL_GENEVE_OPT:\n\t\terr = fl_dump_key_geneve_opt(skb, enc_opts);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase TUNNEL_VXLAN_OPT:\n\t\terr = fl_dump_key_vxlan_opt(skb, enc_opts);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase TUNNEL_ERSPAN_OPT:\n\t\terr = fl_dump_key_erspan_opt(skb, enc_opts);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase TUNNEL_GTP_OPT:\n\t\terr = fl_dump_key_gtp_opt(skb, enc_opts);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int fl_dump_key_enc_opt(struct sk_buff *skb,\n\t\t\t       struct flow_dissector_key_enc_opts *key_opts,\n\t\t\t       struct flow_dissector_key_enc_opts *msk_opts)\n{\n\tint err;\n\n\terr = fl_dump_key_options(skb, TCA_FLOWER_KEY_ENC_OPTS, key_opts);\n\tif (err)\n\t\treturn err;\n\n\treturn fl_dump_key_options(skb, TCA_FLOWER_KEY_ENC_OPTS_MASK, msk_opts);\n}\n\nstatic int fl_dump_key(struct sk_buff *skb, struct net *net,\n\t\t       struct fl_flow_key *key, struct fl_flow_key *mask)\n{\n\tif (mask->meta.ingress_ifindex) {\n\t\tstruct net_device *dev;\n\n\t\tdev = __dev_get_by_index(net, key->meta.ingress_ifindex);\n\t\tif (dev && nla_put_string(skb, TCA_FLOWER_INDEV, dev->name))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (fl_dump_key_val(skb, &key->meta.l2_miss,\n\t\t\t    TCA_FLOWER_L2_MISS, &mask->meta.l2_miss,\n\t\t\t    TCA_FLOWER_UNSPEC, sizeof(key->meta.l2_miss)))\n\t\tgoto nla_put_failure;\n\n\tif (fl_dump_key_val(skb, key->eth.dst, TCA_FLOWER_KEY_ETH_DST,\n\t\t\t    mask->eth.dst, TCA_FLOWER_KEY_ETH_DST_MASK,\n\t\t\t    sizeof(key->eth.dst)) ||\n\t    fl_dump_key_val(skb, key->eth.src, TCA_FLOWER_KEY_ETH_SRC,\n\t\t\t    mask->eth.src, TCA_FLOWER_KEY_ETH_SRC_MASK,\n\t\t\t    sizeof(key->eth.src)) ||\n\t    fl_dump_key_val(skb, &key->basic.n_proto, TCA_FLOWER_KEY_ETH_TYPE,\n\t\t\t    &mask->basic.n_proto, TCA_FLOWER_UNSPEC,\n\t\t\t    sizeof(key->basic.n_proto)))\n\t\tgoto nla_put_failure;\n\n\tif (mask->num_of_vlans.num_of_vlans) {\n\t\tif (nla_put_u8(skb, TCA_FLOWER_KEY_NUM_OF_VLANS, key->num_of_vlans.num_of_vlans))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (fl_dump_key_mpls(skb, &key->mpls, &mask->mpls))\n\t\tgoto nla_put_failure;\n\n\tif (fl_dump_key_vlan(skb, TCA_FLOWER_KEY_VLAN_ID,\n\t\t\t     TCA_FLOWER_KEY_VLAN_PRIO, &key->vlan, &mask->vlan))\n\t\tgoto nla_put_failure;\n\n\tif (fl_dump_key_vlan(skb, TCA_FLOWER_KEY_CVLAN_ID,\n\t\t\t     TCA_FLOWER_KEY_CVLAN_PRIO,\n\t\t\t     &key->cvlan, &mask->cvlan) ||\n\t    (mask->cvlan.vlan_tpid &&\n\t     nla_put_be16(skb, TCA_FLOWER_KEY_VLAN_ETH_TYPE,\n\t\t\t  key->cvlan.vlan_tpid)))\n\t\tgoto nla_put_failure;\n\n\tif (mask->basic.n_proto) {\n\t\tif (mask->cvlan.vlan_eth_type) {\n\t\t\tif (nla_put_be16(skb, TCA_FLOWER_KEY_CVLAN_ETH_TYPE,\n\t\t\t\t\t key->basic.n_proto))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else if (mask->vlan.vlan_eth_type) {\n\t\t\tif (nla_put_be16(skb, TCA_FLOWER_KEY_VLAN_ETH_TYPE,\n\t\t\t\t\t key->vlan.vlan_eth_type))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif ((key->basic.n_proto == htons(ETH_P_IP) ||\n\t     key->basic.n_proto == htons(ETH_P_IPV6)) &&\n\t    (fl_dump_key_val(skb, &key->basic.ip_proto, TCA_FLOWER_KEY_IP_PROTO,\n\t\t\t    &mask->basic.ip_proto, TCA_FLOWER_UNSPEC,\n\t\t\t    sizeof(key->basic.ip_proto)) ||\n\t    fl_dump_key_ip(skb, false, &key->ip, &mask->ip)))\n\t\tgoto nla_put_failure;\n\n\tif (mask->pppoe.session_id) {\n\t\tif (nla_put_be16(skb, TCA_FLOWER_KEY_PPPOE_SID,\n\t\t\t\t key->pppoe.session_id))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (mask->basic.n_proto && mask->pppoe.ppp_proto) {\n\t\tif (nla_put_be16(skb, TCA_FLOWER_KEY_PPP_PROTO,\n\t\t\t\t key->pppoe.ppp_proto))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (key->control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS &&\n\t    (fl_dump_key_val(skb, &key->ipv4.src, TCA_FLOWER_KEY_IPV4_SRC,\n\t\t\t     &mask->ipv4.src, TCA_FLOWER_KEY_IPV4_SRC_MASK,\n\t\t\t     sizeof(key->ipv4.src)) ||\n\t     fl_dump_key_val(skb, &key->ipv4.dst, TCA_FLOWER_KEY_IPV4_DST,\n\t\t\t     &mask->ipv4.dst, TCA_FLOWER_KEY_IPV4_DST_MASK,\n\t\t\t     sizeof(key->ipv4.dst))))\n\t\tgoto nla_put_failure;\n\telse if (key->control.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS &&\n\t\t (fl_dump_key_val(skb, &key->ipv6.src, TCA_FLOWER_KEY_IPV6_SRC,\n\t\t\t\t  &mask->ipv6.src, TCA_FLOWER_KEY_IPV6_SRC_MASK,\n\t\t\t\t  sizeof(key->ipv6.src)) ||\n\t\t  fl_dump_key_val(skb, &key->ipv6.dst, TCA_FLOWER_KEY_IPV6_DST,\n\t\t\t\t  &mask->ipv6.dst, TCA_FLOWER_KEY_IPV6_DST_MASK,\n\t\t\t\t  sizeof(key->ipv6.dst))))\n\t\tgoto nla_put_failure;\n\n\tif (key->basic.ip_proto == IPPROTO_TCP &&\n\t    (fl_dump_key_val(skb, &key->tp.src, TCA_FLOWER_KEY_TCP_SRC,\n\t\t\t     &mask->tp.src, TCA_FLOWER_KEY_TCP_SRC_MASK,\n\t\t\t     sizeof(key->tp.src)) ||\n\t     fl_dump_key_val(skb, &key->tp.dst, TCA_FLOWER_KEY_TCP_DST,\n\t\t\t     &mask->tp.dst, TCA_FLOWER_KEY_TCP_DST_MASK,\n\t\t\t     sizeof(key->tp.dst)) ||\n\t     fl_dump_key_val(skb, &key->tcp.flags, TCA_FLOWER_KEY_TCP_FLAGS,\n\t\t\t     &mask->tcp.flags, TCA_FLOWER_KEY_TCP_FLAGS_MASK,\n\t\t\t     sizeof(key->tcp.flags))))\n\t\tgoto nla_put_failure;\n\telse if (key->basic.ip_proto == IPPROTO_UDP &&\n\t\t (fl_dump_key_val(skb, &key->tp.src, TCA_FLOWER_KEY_UDP_SRC,\n\t\t\t\t  &mask->tp.src, TCA_FLOWER_KEY_UDP_SRC_MASK,\n\t\t\t\t  sizeof(key->tp.src)) ||\n\t\t  fl_dump_key_val(skb, &key->tp.dst, TCA_FLOWER_KEY_UDP_DST,\n\t\t\t\t  &mask->tp.dst, TCA_FLOWER_KEY_UDP_DST_MASK,\n\t\t\t\t  sizeof(key->tp.dst))))\n\t\tgoto nla_put_failure;\n\telse if (key->basic.ip_proto == IPPROTO_SCTP &&\n\t\t (fl_dump_key_val(skb, &key->tp.src, TCA_FLOWER_KEY_SCTP_SRC,\n\t\t\t\t  &mask->tp.src, TCA_FLOWER_KEY_SCTP_SRC_MASK,\n\t\t\t\t  sizeof(key->tp.src)) ||\n\t\t  fl_dump_key_val(skb, &key->tp.dst, TCA_FLOWER_KEY_SCTP_DST,\n\t\t\t\t  &mask->tp.dst, TCA_FLOWER_KEY_SCTP_DST_MASK,\n\t\t\t\t  sizeof(key->tp.dst))))\n\t\tgoto nla_put_failure;\n\telse if (key->basic.n_proto == htons(ETH_P_IP) &&\n\t\t key->basic.ip_proto == IPPROTO_ICMP &&\n\t\t (fl_dump_key_val(skb, &key->icmp.type,\n\t\t\t\t  TCA_FLOWER_KEY_ICMPV4_TYPE, &mask->icmp.type,\n\t\t\t\t  TCA_FLOWER_KEY_ICMPV4_TYPE_MASK,\n\t\t\t\t  sizeof(key->icmp.type)) ||\n\t\t  fl_dump_key_val(skb, &key->icmp.code,\n\t\t\t\t  TCA_FLOWER_KEY_ICMPV4_CODE, &mask->icmp.code,\n\t\t\t\t  TCA_FLOWER_KEY_ICMPV4_CODE_MASK,\n\t\t\t\t  sizeof(key->icmp.code))))\n\t\tgoto nla_put_failure;\n\telse if (key->basic.n_proto == htons(ETH_P_IPV6) &&\n\t\t key->basic.ip_proto == IPPROTO_ICMPV6 &&\n\t\t (fl_dump_key_val(skb, &key->icmp.type,\n\t\t\t\t  TCA_FLOWER_KEY_ICMPV6_TYPE, &mask->icmp.type,\n\t\t\t\t  TCA_FLOWER_KEY_ICMPV6_TYPE_MASK,\n\t\t\t\t  sizeof(key->icmp.type)) ||\n\t\t  fl_dump_key_val(skb, &key->icmp.code,\n\t\t\t\t  TCA_FLOWER_KEY_ICMPV6_CODE, &mask->icmp.code,\n\t\t\t\t  TCA_FLOWER_KEY_ICMPV6_CODE_MASK,\n\t\t\t\t  sizeof(key->icmp.code))))\n\t\tgoto nla_put_failure;\n\telse if ((key->basic.n_proto == htons(ETH_P_ARP) ||\n\t\t  key->basic.n_proto == htons(ETH_P_RARP)) &&\n\t\t (fl_dump_key_val(skb, &key->arp.sip,\n\t\t\t\t  TCA_FLOWER_KEY_ARP_SIP, &mask->arp.sip,\n\t\t\t\t  TCA_FLOWER_KEY_ARP_SIP_MASK,\n\t\t\t\t  sizeof(key->arp.sip)) ||\n\t\t  fl_dump_key_val(skb, &key->arp.tip,\n\t\t\t\t  TCA_FLOWER_KEY_ARP_TIP, &mask->arp.tip,\n\t\t\t\t  TCA_FLOWER_KEY_ARP_TIP_MASK,\n\t\t\t\t  sizeof(key->arp.tip)) ||\n\t\t  fl_dump_key_val(skb, &key->arp.op,\n\t\t\t\t  TCA_FLOWER_KEY_ARP_OP, &mask->arp.op,\n\t\t\t\t  TCA_FLOWER_KEY_ARP_OP_MASK,\n\t\t\t\t  sizeof(key->arp.op)) ||\n\t\t  fl_dump_key_val(skb, key->arp.sha, TCA_FLOWER_KEY_ARP_SHA,\n\t\t\t\t  mask->arp.sha, TCA_FLOWER_KEY_ARP_SHA_MASK,\n\t\t\t\t  sizeof(key->arp.sha)) ||\n\t\t  fl_dump_key_val(skb, key->arp.tha, TCA_FLOWER_KEY_ARP_THA,\n\t\t\t\t  mask->arp.tha, TCA_FLOWER_KEY_ARP_THA_MASK,\n\t\t\t\t  sizeof(key->arp.tha))))\n\t\tgoto nla_put_failure;\n\telse if (key->basic.ip_proto == IPPROTO_L2TP &&\n\t\t fl_dump_key_val(skb, &key->l2tpv3.session_id,\n\t\t\t\t TCA_FLOWER_KEY_L2TPV3_SID,\n\t\t\t\t &mask->l2tpv3.session_id,\n\t\t\t\t TCA_FLOWER_UNSPEC,\n\t\t\t\t sizeof(key->l2tpv3.session_id)))\n\t\tgoto nla_put_failure;\n\n\tif (key->ipsec.spi &&\n\t    fl_dump_key_val(skb, &key->ipsec.spi, TCA_FLOWER_KEY_SPI,\n\t\t\t    &mask->ipsec.spi, TCA_FLOWER_KEY_SPI_MASK,\n\t\t\t    sizeof(key->ipsec.spi)))\n\t\tgoto nla_put_failure;\n\n\tif ((key->basic.ip_proto == IPPROTO_TCP ||\n\t     key->basic.ip_proto == IPPROTO_UDP ||\n\t     key->basic.ip_proto == IPPROTO_SCTP) &&\n\t     fl_dump_key_port_range(skb, key, mask))\n\t\tgoto nla_put_failure;\n\n\tif (key->enc_control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS &&\n\t    (fl_dump_key_val(skb, &key->enc_ipv4.src,\n\t\t\t    TCA_FLOWER_KEY_ENC_IPV4_SRC, &mask->enc_ipv4.src,\n\t\t\t    TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK,\n\t\t\t    sizeof(key->enc_ipv4.src)) ||\n\t     fl_dump_key_val(skb, &key->enc_ipv4.dst,\n\t\t\t     TCA_FLOWER_KEY_ENC_IPV4_DST, &mask->enc_ipv4.dst,\n\t\t\t     TCA_FLOWER_KEY_ENC_IPV4_DST_MASK,\n\t\t\t     sizeof(key->enc_ipv4.dst))))\n\t\tgoto nla_put_failure;\n\telse if (key->enc_control.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS &&\n\t\t (fl_dump_key_val(skb, &key->enc_ipv6.src,\n\t\t\t    TCA_FLOWER_KEY_ENC_IPV6_SRC, &mask->enc_ipv6.src,\n\t\t\t    TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK,\n\t\t\t    sizeof(key->enc_ipv6.src)) ||\n\t\t fl_dump_key_val(skb, &key->enc_ipv6.dst,\n\t\t\t\t TCA_FLOWER_KEY_ENC_IPV6_DST,\n\t\t\t\t &mask->enc_ipv6.dst,\n\t\t\t\t TCA_FLOWER_KEY_ENC_IPV6_DST_MASK,\n\t\t\t    sizeof(key->enc_ipv6.dst))))\n\t\tgoto nla_put_failure;\n\n\tif (fl_dump_key_val(skb, &key->enc_key_id, TCA_FLOWER_KEY_ENC_KEY_ID,\n\t\t\t    &mask->enc_key_id, TCA_FLOWER_UNSPEC,\n\t\t\t    sizeof(key->enc_key_id)) ||\n\t    fl_dump_key_val(skb, &key->enc_tp.src,\n\t\t\t    TCA_FLOWER_KEY_ENC_UDP_SRC_PORT,\n\t\t\t    &mask->enc_tp.src,\n\t\t\t    TCA_FLOWER_KEY_ENC_UDP_SRC_PORT_MASK,\n\t\t\t    sizeof(key->enc_tp.src)) ||\n\t    fl_dump_key_val(skb, &key->enc_tp.dst,\n\t\t\t    TCA_FLOWER_KEY_ENC_UDP_DST_PORT,\n\t\t\t    &mask->enc_tp.dst,\n\t\t\t    TCA_FLOWER_KEY_ENC_UDP_DST_PORT_MASK,\n\t\t\t    sizeof(key->enc_tp.dst)) ||\n\t    fl_dump_key_ip(skb, true, &key->enc_ip, &mask->enc_ip) ||\n\t    fl_dump_key_enc_opt(skb, &key->enc_opts, &mask->enc_opts))\n\t\tgoto nla_put_failure;\n\n\tif (fl_dump_key_ct(skb, &key->ct, &mask->ct))\n\t\tgoto nla_put_failure;\n\n\tif (fl_dump_key_flags(skb, key->control.flags, mask->control.flags))\n\t\tgoto nla_put_failure;\n\n\tif (fl_dump_key_val(skb, &key->hash.hash, TCA_FLOWER_KEY_HASH,\n\t\t\t     &mask->hash.hash, TCA_FLOWER_KEY_HASH_MASK,\n\t\t\t     sizeof(key->hash.hash)))\n\t\tgoto nla_put_failure;\n\n\tif (fl_dump_key_cfm(skb, &key->cfm, &mask->cfm))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int fl_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t   struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)\n{\n\tstruct cls_fl_filter *f = fh;\n\tstruct nlattr *nest;\n\tstruct fl_flow_key *key, *mask;\n\tbool skip_hw;\n\n\tif (!f)\n\t\treturn skb->len;\n\n\tt->tcm_handle = f->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tspin_lock(&tp->lock);\n\n\tif (f->res.classid &&\n\t    nla_put_u32(skb, TCA_FLOWER_CLASSID, f->res.classid))\n\t\tgoto nla_put_failure_locked;\n\n\tkey = &f->key;\n\tmask = &f->mask->key;\n\tskip_hw = tc_skip_hw(f->flags);\n\n\tif (fl_dump_key(skb, net, key, mask))\n\t\tgoto nla_put_failure_locked;\n\n\tif (f->flags && nla_put_u32(skb, TCA_FLOWER_FLAGS, f->flags))\n\t\tgoto nla_put_failure_locked;\n\n\tspin_unlock(&tp->lock);\n\n\tif (!skip_hw)\n\t\tfl_hw_update_stats(tp, f, rtnl_held);\n\n\tif (nla_put_u32(skb, TCA_FLOWER_IN_HW_COUNT, f->in_hw_count))\n\t\tgoto nla_put_failure;\n\n\tif (tcf_exts_dump(skb, &f->exts))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tif (tcf_exts_dump_stats(skb, &f->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn skb->len;\n\nnla_put_failure_locked:\n\tspin_unlock(&tp->lock);\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic int fl_terse_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t\t struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)\n{\n\tstruct cls_fl_filter *f = fh;\n\tstruct nlattr *nest;\n\tbool skip_hw;\n\n\tif (!f)\n\t\treturn skb->len;\n\n\tt->tcm_handle = f->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tspin_lock(&tp->lock);\n\n\tskip_hw = tc_skip_hw(f->flags);\n\n\tif (f->flags && nla_put_u32(skb, TCA_FLOWER_FLAGS, f->flags))\n\t\tgoto nla_put_failure_locked;\n\n\tspin_unlock(&tp->lock);\n\n\tif (!skip_hw)\n\t\tfl_hw_update_stats(tp, f, rtnl_held);\n\n\tif (tcf_exts_terse_dump(skb, &f->exts))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\treturn skb->len;\n\nnla_put_failure_locked:\n\tspin_unlock(&tp->lock);\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic int fl_tmplt_dump(struct sk_buff *skb, struct net *net, void *tmplt_priv)\n{\n\tstruct fl_flow_tmplt *tmplt = tmplt_priv;\n\tstruct fl_flow_key *key, *mask;\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tkey = &tmplt->dummy_key;\n\tmask = &tmplt->mask;\n\n\tif (fl_dump_key(skb, net, key, mask))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic void fl_bind_class(void *fh, u32 classid, unsigned long cl, void *q,\n\t\t\t  unsigned long base)\n{\n\tstruct cls_fl_filter *f = fh;\n\n\ttc_cls_bind_class(classid, cl, q, &f->res, base);\n}\n\nstatic bool fl_delete_empty(struct tcf_proto *tp)\n{\n\tstruct cls_fl_head *head = fl_head_dereference(tp);\n\n\tspin_lock(&tp->lock);\n\ttp->deleting = idr_is_empty(&head->handle_idr);\n\tspin_unlock(&tp->lock);\n\n\treturn tp->deleting;\n}\n\nstatic struct tcf_proto_ops cls_fl_ops __read_mostly = {\n\t.kind\t\t= \"flower\",\n\t.classify\t= fl_classify,\n\t.init\t\t= fl_init,\n\t.destroy\t= fl_destroy,\n\t.get\t\t= fl_get,\n\t.put\t\t= fl_put,\n\t.change\t\t= fl_change,\n\t.delete\t\t= fl_delete,\n\t.delete_empty\t= fl_delete_empty,\n\t.walk\t\t= fl_walk,\n\t.reoffload\t= fl_reoffload,\n\t.hw_add\t\t= fl_hw_add,\n\t.hw_del\t\t= fl_hw_del,\n\t.dump\t\t= fl_dump,\n\t.terse_dump\t= fl_terse_dump,\n\t.bind_class\t= fl_bind_class,\n\t.tmplt_create\t= fl_tmplt_create,\n\t.tmplt_destroy\t= fl_tmplt_destroy,\n\t.tmplt_dump\t= fl_tmplt_dump,\n\t.get_exts\t= fl_get_exts,\n\t.owner\t\t= THIS_MODULE,\n\t.flags\t\t= TCF_PROTO_OPS_DOIT_UNLOCKED,\n};\n\nstatic int __init cls_fl_init(void)\n{\n\treturn register_tcf_proto_ops(&cls_fl_ops);\n}\n\nstatic void __exit cls_fl_exit(void)\n{\n\tunregister_tcf_proto_ops(&cls_fl_ops);\n}\n\nmodule_init(cls_fl_init);\nmodule_exit(cls_fl_exit);\n\nMODULE_AUTHOR(\"Jiri Pirko <jiri@resnulli.us>\");\nMODULE_DESCRIPTION(\"Flower classifier\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}