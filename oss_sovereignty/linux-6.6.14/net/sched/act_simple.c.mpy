{
  "module_name": "act_simple.c",
  "hash_id": "fc5886ed4aa5ffc5a6da6a4ae986b4000597c5e141d0faaf51d971e0bdd7dfb9",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_simple.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <net/tc_wrapper.h>\n\n#include <linux/tc_act/tc_defact.h>\n#include <net/tc_act/tc_defact.h>\n\nstatic struct tc_action_ops act_simp_ops;\n\n#define SIMP_MAX_DATA\t32\nTC_INDIRECT_SCOPE int tcf_simp_act(struct sk_buff *skb,\n\t\t\t\t   const struct tc_action *a,\n\t\t\t\t   struct tcf_result *res)\n{\n\tstruct tcf_defact *d = to_defact(a);\n\n\tspin_lock(&d->tcf_lock);\n\ttcf_lastuse_update(&d->tcf_tm);\n\tbstats_update(&d->tcf_bstats, skb);\n\n\t \n\tpr_info(\"simple: %s_%llu\\n\",\n\t\t(char *)d->tcfd_defdata,\n\t\tu64_stats_read(&d->tcf_bstats.packets));\n\tspin_unlock(&d->tcf_lock);\n\treturn d->tcf_action;\n}\n\nstatic void tcf_simp_release(struct tc_action *a)\n{\n\tstruct tcf_defact *d = to_defact(a);\n\tkfree(d->tcfd_defdata);\n}\n\nstatic int alloc_defdata(struct tcf_defact *d, const struct nlattr *defdata)\n{\n\td->tcfd_defdata = kzalloc(SIMP_MAX_DATA, GFP_KERNEL);\n\tif (unlikely(!d->tcfd_defdata))\n\t\treturn -ENOMEM;\n\tnla_strscpy(d->tcfd_defdata, defdata, SIMP_MAX_DATA);\n\treturn 0;\n}\n\nstatic int reset_policy(struct tc_action *a, const struct nlattr *defdata,\n\t\t\tstruct tc_defact *p, struct tcf_proto *tp,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tcf_defact *d;\n\tint err;\n\n\terr = tcf_action_check_ctrlact(p->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\treturn err;\n\td = to_defact(a);\n\tspin_lock_bh(&d->tcf_lock);\n\tgoto_ch = tcf_action_set_ctrlact(a, p->action, goto_ch);\n\tmemset(d->tcfd_defdata, 0, SIMP_MAX_DATA);\n\tnla_strscpy(d->tcfd_defdata, defdata, SIMP_MAX_DATA);\n\tspin_unlock_bh(&d->tcf_lock);\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\treturn 0;\n}\n\nstatic const struct nla_policy simple_policy[TCA_DEF_MAX + 1] = {\n\t[TCA_DEF_PARMS]\t= { .len = sizeof(struct tc_defact) },\n\t[TCA_DEF_DATA]\t= { .type = NLA_STRING, .len = SIMP_MAX_DATA },\n};\n\nstatic int tcf_simp_init(struct net *net, struct nlattr *nla,\n\t\t\t struct nlattr *est, struct tc_action **a,\n\t\t\t struct tcf_proto *tp, u32 flags,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_simp_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_DEF_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tc_defact *parm;\n\tstruct tcf_defact *d;\n\tbool exists = false;\n\tint ret = 0, err;\n\tu32 index;\n\n\tif (nla == NULL)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_DEF_MAX, nla, simple_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_DEF_PARMS] == NULL)\n\t\treturn -EINVAL;\n\n\tparm = nla_data(tb[TCA_DEF_PARMS]);\n\tindex = parm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0)\n\t\treturn err;\n\texists = err;\n\tif (exists && bind)\n\t\treturn 0;\n\n\tif (tb[TCA_DEF_DATA] == NULL) {\n\t\tif (exists)\n\t\t\ttcf_idr_release(*a, bind);\n\t\telse\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!exists) {\n\t\tret = tcf_idr_create(tn, index, est, a,\n\t\t\t\t     &act_simp_ops, bind, false, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\n\t\td = to_defact(*a);\n\t\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch,\n\t\t\t\t\t       extack);\n\t\tif (err < 0)\n\t\t\tgoto release_idr;\n\n\t\terr = alloc_defdata(d, tb[TCA_DEF_DATA]);\n\t\tif (err < 0)\n\t\t\tgoto put_chain;\n\n\t\ttcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\t\tret = ACT_P_CREATED;\n\t} else {\n\t\tif (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto release_idr;\n\t\t}\n\n\t\terr = reset_policy(*a, tb[TCA_DEF_DATA], parm, tp, extack);\n\t\tif (err)\n\t\t\tgoto release_idr;\n\t}\n\n\treturn ret;\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic int tcf_simp_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_defact *d = to_defact(a);\n\tstruct tc_defact opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n\t\t.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&d->tcf_lock);\n\topt.action = d->tcf_action;\n\tif (nla_put(skb, TCA_DEF_PARMS, sizeof(opt), &opt) ||\n\t    nla_put_string(skb, TCA_DEF_DATA, d->tcfd_defdata))\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &d->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_DEF_TM, sizeof(t), &t, TCA_DEF_PAD))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&d->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&d->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic struct tc_action_ops act_simp_ops = {\n\t.kind\t\t=\t\"simple\",\n\t.id\t\t=\tTCA_ID_SIMP,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_simp_act,\n\t.dump\t\t=\ttcf_simp_dump,\n\t.cleanup\t=\ttcf_simp_release,\n\t.init\t\t=\ttcf_simp_init,\n\t.size\t\t=\tsizeof(struct tcf_defact),\n};\n\nstatic __net_init int simp_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_simp_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_simp_ops);\n}\n\nstatic void __net_exit simp_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_simp_ops.net_id);\n}\n\nstatic struct pernet_operations simp_net_ops = {\n\t.init = simp_init_net,\n\t.exit_batch = simp_exit_net,\n\t.id   = &act_simp_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nMODULE_AUTHOR(\"Jamal Hadi Salim(2005)\");\nMODULE_DESCRIPTION(\"Simple example action\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init simp_init_module(void)\n{\n\tint ret = tcf_register_action(&act_simp_ops, &simp_net_ops);\n\tif (!ret)\n\t\tpr_info(\"Simple TC action Loaded\\n\");\n\treturn ret;\n}\n\nstatic void __exit simp_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_simp_ops, &simp_net_ops);\n}\n\nmodule_init(simp_init_module);\nmodule_exit(simp_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}