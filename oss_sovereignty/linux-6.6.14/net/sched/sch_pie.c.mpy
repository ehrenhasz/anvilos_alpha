{
  "module_name": "sch_pie.c",
  "hash_id": "9772702a5064536e0c31c935daacadd41ebaf0273288d34a5fc0b344de2ebfb2",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_pie.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <net/pkt_sched.h>\n#include <net/inet_ecn.h>\n#include <net/pie.h>\n\n \nstruct pie_sched_data {\n\tstruct pie_vars vars;\n\tstruct pie_params params;\n\tstruct pie_stats stats;\n\tstruct timer_list adapt_timer;\n\tstruct Qdisc *sch;\n};\n\nbool pie_drop_early(struct Qdisc *sch, struct pie_params *params,\n\t\t    struct pie_vars *vars, u32 backlog, u32 packet_size)\n{\n\tu64 rnd;\n\tu64 local_prob = vars->prob;\n\tu32 mtu = psched_mtu(qdisc_dev(sch));\n\n\t \n\tif (vars->burst_time > 0)\n\t\treturn false;\n\n\t \n\tif ((vars->qdelay < params->target / 2) &&\n\t    (vars->prob < MAX_PROB / 5))\n\t\treturn false;\n\n\t \n\tif (backlog < 2 * mtu)\n\t\treturn false;\n\n\t \n\tif (params->bytemode && packet_size <= mtu)\n\t\tlocal_prob = (u64)packet_size * div_u64(local_prob, mtu);\n\telse\n\t\tlocal_prob = vars->prob;\n\n\tif (local_prob == 0)\n\t\tvars->accu_prob = 0;\n\telse\n\t\tvars->accu_prob += local_prob;\n\n\tif (vars->accu_prob < (MAX_PROB / 100) * 85)\n\t\treturn false;\n\tif (vars->accu_prob >= (MAX_PROB / 2) * 17)\n\t\treturn true;\n\n\tget_random_bytes(&rnd, 8);\n\tif ((rnd >> BITS_PER_BYTE) < local_prob) {\n\t\tvars->accu_prob = 0;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(pie_drop_early);\n\nstatic int pie_qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t     struct sk_buff **to_free)\n{\n\tstruct pie_sched_data *q = qdisc_priv(sch);\n\tbool enqueue = false;\n\n\tif (unlikely(qdisc_qlen(sch) >= sch->limit)) {\n\t\tq->stats.overlimit++;\n\t\tgoto out;\n\t}\n\n\tif (!pie_drop_early(sch, &q->params, &q->vars, sch->qstats.backlog,\n\t\t\t    skb->len)) {\n\t\tenqueue = true;\n\t} else if (q->params.ecn && (q->vars.prob <= MAX_PROB / 10) &&\n\t\t   INET_ECN_set_ce(skb)) {\n\t\t \n\t\tq->stats.ecn_mark++;\n\t\tenqueue = true;\n\t}\n\n\t \n\tif (enqueue) {\n\t\t \n\t\tif (!q->params.dq_rate_estimator)\n\t\t\tpie_set_enqueue_time(skb);\n\n\t\tq->stats.packets_in++;\n\t\tif (qdisc_qlen(sch) > q->stats.maxq)\n\t\t\tq->stats.maxq = qdisc_qlen(sch);\n\n\t\treturn qdisc_enqueue_tail(skb, sch);\n\t}\n\nout:\n\tq->stats.dropped++;\n\tq->vars.accu_prob = 0;\n\treturn qdisc_drop(skb, sch, to_free);\n}\n\nstatic const struct nla_policy pie_policy[TCA_PIE_MAX + 1] = {\n\t[TCA_PIE_TARGET]\t\t= {.type = NLA_U32},\n\t[TCA_PIE_LIMIT]\t\t\t= {.type = NLA_U32},\n\t[TCA_PIE_TUPDATE]\t\t= {.type = NLA_U32},\n\t[TCA_PIE_ALPHA]\t\t\t= {.type = NLA_U32},\n\t[TCA_PIE_BETA]\t\t\t= {.type = NLA_U32},\n\t[TCA_PIE_ECN]\t\t\t= {.type = NLA_U32},\n\t[TCA_PIE_BYTEMODE]\t\t= {.type = NLA_U32},\n\t[TCA_PIE_DQ_RATE_ESTIMATOR]\t= {.type = NLA_U32},\n};\n\nstatic int pie_change(struct Qdisc *sch, struct nlattr *opt,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct pie_sched_data *q = qdisc_priv(sch);\n\tstruct nlattr *tb[TCA_PIE_MAX + 1];\n\tunsigned int qlen, dropped = 0;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_PIE_MAX, opt, pie_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tsch_tree_lock(sch);\n\n\t \n\tif (tb[TCA_PIE_TARGET]) {\n\t\t \n\t\tu32 target = nla_get_u32(tb[TCA_PIE_TARGET]);\n\n\t\t \n\t\tq->params.target = PSCHED_NS2TICKS((u64)target * NSEC_PER_USEC);\n\t}\n\n\t \n\tif (tb[TCA_PIE_TUPDATE])\n\t\tq->params.tupdate =\n\t\t\tusecs_to_jiffies(nla_get_u32(tb[TCA_PIE_TUPDATE]));\n\n\tif (tb[TCA_PIE_LIMIT]) {\n\t\tu32 limit = nla_get_u32(tb[TCA_PIE_LIMIT]);\n\n\t\tq->params.limit = limit;\n\t\tsch->limit = limit;\n\t}\n\n\tif (tb[TCA_PIE_ALPHA])\n\t\tq->params.alpha = nla_get_u32(tb[TCA_PIE_ALPHA]);\n\n\tif (tb[TCA_PIE_BETA])\n\t\tq->params.beta = nla_get_u32(tb[TCA_PIE_BETA]);\n\n\tif (tb[TCA_PIE_ECN])\n\t\tq->params.ecn = nla_get_u32(tb[TCA_PIE_ECN]);\n\n\tif (tb[TCA_PIE_BYTEMODE])\n\t\tq->params.bytemode = nla_get_u32(tb[TCA_PIE_BYTEMODE]);\n\n\tif (tb[TCA_PIE_DQ_RATE_ESTIMATOR])\n\t\tq->params.dq_rate_estimator =\n\t\t\t\tnla_get_u32(tb[TCA_PIE_DQ_RATE_ESTIMATOR]);\n\n\t \n\tqlen = sch->q.qlen;\n\twhile (sch->q.qlen > sch->limit) {\n\t\tstruct sk_buff *skb = __qdisc_dequeue_head(&sch->q);\n\n\t\tdropped += qdisc_pkt_len(skb);\n\t\tqdisc_qstats_backlog_dec(sch, skb);\n\t\trtnl_qdisc_drop(skb, sch);\n\t}\n\tqdisc_tree_reduce_backlog(sch, qlen - sch->q.qlen, dropped);\n\n\tsch_tree_unlock(sch);\n\treturn 0;\n}\n\nvoid pie_process_dequeue(struct sk_buff *skb, struct pie_params *params,\n\t\t\t struct pie_vars *vars, u32 backlog)\n{\n\tpsched_time_t now = psched_get_time();\n\tu32 dtime = 0;\n\n\t \n\tif (!params->dq_rate_estimator) {\n\t\tvars->qdelay = now - pie_get_enqueue_time(skb);\n\n\t\tif (vars->dq_tstamp != DTIME_INVALID)\n\t\t\tdtime = now - vars->dq_tstamp;\n\n\t\tvars->dq_tstamp = now;\n\n\t\tif (backlog == 0)\n\t\t\tvars->qdelay = 0;\n\n\t\tif (dtime == 0)\n\t\t\treturn;\n\n\t\tgoto burst_allowance_reduction;\n\t}\n\n\t \n\tif (backlog >= QUEUE_THRESHOLD && vars->dq_count == DQCOUNT_INVALID) {\n\t\tvars->dq_tstamp = psched_get_time();\n\t\tvars->dq_count = 0;\n\t}\n\n\t \n\tif (vars->dq_count != DQCOUNT_INVALID) {\n\t\tvars->dq_count += skb->len;\n\n\t\tif (vars->dq_count >= QUEUE_THRESHOLD) {\n\t\t\tu32 count = vars->dq_count << PIE_SCALE;\n\n\t\t\tdtime = now - vars->dq_tstamp;\n\n\t\t\tif (dtime == 0)\n\t\t\t\treturn;\n\n\t\t\tcount = count / dtime;\n\n\t\t\tif (vars->avg_dq_rate == 0)\n\t\t\t\tvars->avg_dq_rate = count;\n\t\t\telse\n\t\t\t\tvars->avg_dq_rate =\n\t\t\t\t    (vars->avg_dq_rate -\n\t\t\t\t     (vars->avg_dq_rate >> 3)) + (count >> 3);\n\n\t\t\t \n\t\t\tif (backlog < QUEUE_THRESHOLD) {\n\t\t\t\tvars->dq_count = DQCOUNT_INVALID;\n\t\t\t} else {\n\t\t\t\tvars->dq_count = 0;\n\t\t\t\tvars->dq_tstamp = psched_get_time();\n\t\t\t}\n\n\t\t\tgoto burst_allowance_reduction;\n\t\t}\n\t}\n\n\treturn;\n\nburst_allowance_reduction:\n\tif (vars->burst_time > 0) {\n\t\tif (vars->burst_time > dtime)\n\t\t\tvars->burst_time -= dtime;\n\t\telse\n\t\t\tvars->burst_time = 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(pie_process_dequeue);\n\nvoid pie_calculate_probability(struct pie_params *params, struct pie_vars *vars,\n\t\t\t       u32 backlog)\n{\n\tpsched_time_t qdelay = 0;\t \n\tpsched_time_t qdelay_old = 0;\t \n\ts64 delta = 0;\t\t \n\tu64 oldprob;\n\tu64 alpha, beta;\n\tu32 power;\n\tbool update_prob = true;\n\n\tif (params->dq_rate_estimator) {\n\t\tqdelay_old = vars->qdelay;\n\t\tvars->qdelay_old = vars->qdelay;\n\n\t\tif (vars->avg_dq_rate > 0)\n\t\t\tqdelay = (backlog << PIE_SCALE) / vars->avg_dq_rate;\n\t\telse\n\t\t\tqdelay = 0;\n\t} else {\n\t\tqdelay = vars->qdelay;\n\t\tqdelay_old = vars->qdelay_old;\n\t}\n\n\t \n\tif (qdelay == 0 && backlog != 0)\n\t\tupdate_prob = false;\n\n\t \n\talpha = ((u64)params->alpha * (MAX_PROB / PSCHED_TICKS_PER_SEC)) >> 4;\n\tbeta = ((u64)params->beta * (MAX_PROB / PSCHED_TICKS_PER_SEC)) >> 4;\n\n\t \n\tif (vars->prob < MAX_PROB / 10) {\n\t\talpha >>= 1;\n\t\tbeta >>= 1;\n\n\t\tpower = 100;\n\t\twhile (vars->prob < div_u64(MAX_PROB, power) &&\n\t\t       power <= 1000000) {\n\t\t\talpha >>= 2;\n\t\t\tbeta >>= 2;\n\t\t\tpower *= 10;\n\t\t}\n\t}\n\n\t \n\tdelta += alpha * (qdelay - params->target);\n\tdelta += beta * (qdelay - qdelay_old);\n\n\toldprob = vars->prob;\n\n\t \n\tif (delta > (s64)(MAX_PROB / (100 / 2)) &&\n\t    vars->prob >= MAX_PROB / 10)\n\t\tdelta = (MAX_PROB / 100) * 2;\n\n\t \n\n\tif (qdelay > (PSCHED_NS2TICKS(250 * NSEC_PER_MSEC)))\n\t\tdelta += MAX_PROB / (100 / 2);\n\n\tvars->prob += delta;\n\n\tif (delta > 0) {\n\t\t \n\t\tif (vars->prob < oldprob) {\n\t\t\tvars->prob = MAX_PROB;\n\t\t\t \n\t\t\tupdate_prob = false;\n\t\t}\n\t} else {\n\t\t \n\t\tif (vars->prob > oldprob)\n\t\t\tvars->prob = 0;\n\t}\n\n\t \n\n\tif (qdelay == 0 && qdelay_old == 0 && update_prob)\n\t\t \n\t\tvars->prob -= vars->prob / 64;\n\n\tvars->qdelay = qdelay;\n\tvars->backlog_old = backlog;\n\n\t \n\tif ((vars->qdelay < params->target / 2) &&\n\t    (vars->qdelay_old < params->target / 2) &&\n\t    vars->prob == 0 &&\n\t    (!params->dq_rate_estimator || vars->avg_dq_rate > 0)) {\n\t\tpie_vars_init(vars);\n\t}\n\n\tif (!params->dq_rate_estimator)\n\t\tvars->qdelay_old = qdelay;\n}\nEXPORT_SYMBOL_GPL(pie_calculate_probability);\n\nstatic void pie_timer(struct timer_list *t)\n{\n\tstruct pie_sched_data *q = from_timer(q, t, adapt_timer);\n\tstruct Qdisc *sch = q->sch;\n\tspinlock_t *root_lock;\n\n\trcu_read_lock();\n\troot_lock = qdisc_lock(qdisc_root_sleeping(sch));\n\tspin_lock(root_lock);\n\tpie_calculate_probability(&q->params, &q->vars, sch->qstats.backlog);\n\n\t \n\tif (q->params.tupdate)\n\t\tmod_timer(&q->adapt_timer, jiffies + q->params.tupdate);\n\tspin_unlock(root_lock);\n\trcu_read_unlock();\n}\n\nstatic int pie_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct pie_sched_data *q = qdisc_priv(sch);\n\n\tpie_params_init(&q->params);\n\tpie_vars_init(&q->vars);\n\tsch->limit = q->params.limit;\n\n\tq->sch = sch;\n\ttimer_setup(&q->adapt_timer, pie_timer, 0);\n\n\tif (opt) {\n\t\tint err = pie_change(sch, opt, extack);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmod_timer(&q->adapt_timer, jiffies + HZ / 2);\n\treturn 0;\n}\n\nstatic int pie_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct pie_sched_data *q = qdisc_priv(sch);\n\tstruct nlattr *opts;\n\n\topts = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (!opts)\n\t\tgoto nla_put_failure;\n\n\t \n\tif (nla_put_u32(skb, TCA_PIE_TARGET,\n\t\t\t((u32)PSCHED_TICKS2NS(q->params.target)) /\n\t\t\tNSEC_PER_USEC) ||\n\t    nla_put_u32(skb, TCA_PIE_LIMIT, sch->limit) ||\n\t    nla_put_u32(skb, TCA_PIE_TUPDATE,\n\t\t\tjiffies_to_usecs(q->params.tupdate)) ||\n\t    nla_put_u32(skb, TCA_PIE_ALPHA, q->params.alpha) ||\n\t    nla_put_u32(skb, TCA_PIE_BETA, q->params.beta) ||\n\t    nla_put_u32(skb, TCA_PIE_ECN, q->params.ecn) ||\n\t    nla_put_u32(skb, TCA_PIE_BYTEMODE, q->params.bytemode) ||\n\t    nla_put_u32(skb, TCA_PIE_DQ_RATE_ESTIMATOR,\n\t\t\tq->params.dq_rate_estimator))\n\t\tgoto nla_put_failure;\n\n\treturn nla_nest_end(skb, opts);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, opts);\n\treturn -1;\n}\n\nstatic int pie_dump_stats(struct Qdisc *sch, struct gnet_dump *d)\n{\n\tstruct pie_sched_data *q = qdisc_priv(sch);\n\tstruct tc_pie_xstats st = {\n\t\t.prob\t\t= q->vars.prob << BITS_PER_BYTE,\n\t\t.delay\t\t= ((u32)PSCHED_TICKS2NS(q->vars.qdelay)) /\n\t\t\t\t   NSEC_PER_USEC,\n\t\t.packets_in\t= q->stats.packets_in,\n\t\t.overlimit\t= q->stats.overlimit,\n\t\t.maxq\t\t= q->stats.maxq,\n\t\t.dropped\t= q->stats.dropped,\n\t\t.ecn_mark\t= q->stats.ecn_mark,\n\t};\n\n\t \n\tst.dq_rate_estimating = q->params.dq_rate_estimator;\n\n\t \n\tif (q->params.dq_rate_estimator)\n\t\tst.avg_dq_rate = q->vars.avg_dq_rate *\n\t\t\t\t (PSCHED_TICKS_PER_SEC) >> PIE_SCALE;\n\n\treturn gnet_stats_copy_app(d, &st, sizeof(st));\n}\n\nstatic struct sk_buff *pie_qdisc_dequeue(struct Qdisc *sch)\n{\n\tstruct pie_sched_data *q = qdisc_priv(sch);\n\tstruct sk_buff *skb = qdisc_dequeue_head(sch);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tpie_process_dequeue(skb, &q->params, &q->vars, sch->qstats.backlog);\n\treturn skb;\n}\n\nstatic void pie_reset(struct Qdisc *sch)\n{\n\tstruct pie_sched_data *q = qdisc_priv(sch);\n\n\tqdisc_reset_queue(sch);\n\tpie_vars_init(&q->vars);\n}\n\nstatic void pie_destroy(struct Qdisc *sch)\n{\n\tstruct pie_sched_data *q = qdisc_priv(sch);\n\n\tq->params.tupdate = 0;\n\tdel_timer_sync(&q->adapt_timer);\n}\n\nstatic struct Qdisc_ops pie_qdisc_ops __read_mostly = {\n\t.id\t\t= \"pie\",\n\t.priv_size\t= sizeof(struct pie_sched_data),\n\t.enqueue\t= pie_qdisc_enqueue,\n\t.dequeue\t= pie_qdisc_dequeue,\n\t.peek\t\t= qdisc_peek_dequeued,\n\t.init\t\t= pie_init,\n\t.destroy\t= pie_destroy,\n\t.reset\t\t= pie_reset,\n\t.change\t\t= pie_change,\n\t.dump\t\t= pie_dump,\n\t.dump_stats\t= pie_dump_stats,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init pie_module_init(void)\n{\n\treturn register_qdisc(&pie_qdisc_ops);\n}\n\nstatic void __exit pie_module_exit(void)\n{\n\tunregister_qdisc(&pie_qdisc_ops);\n}\n\nmodule_init(pie_module_init);\nmodule_exit(pie_module_exit);\n\nMODULE_DESCRIPTION(\"Proportional Integral controller Enhanced (PIE) scheduler\");\nMODULE_AUTHOR(\"Vijay Subramanian\");\nMODULE_AUTHOR(\"Mythili Prabhu\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}