{
  "module_name": "sch_teql.c",
  "hash_id": "436b2d8494fa73a6d3eaed8d3547f48251c2c7e71855e30cf4c9947ef0ef9939",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_teql.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/moduleparam.h>\n#include <net/dst.h>\n#include <net/neighbour.h>\n#include <net/pkt_sched.h>\n\n \n\nstruct teql_master {\n\tstruct Qdisc_ops qops;\n\tstruct net_device *dev;\n\tstruct Qdisc *slaves;\n\tstruct list_head master_list;\n\tunsigned long\ttx_bytes;\n\tunsigned long\ttx_packets;\n\tunsigned long\ttx_errors;\n\tunsigned long\ttx_dropped;\n};\n\nstruct teql_sched_data {\n\tstruct Qdisc *next;\n\tstruct teql_master *m;\n\tstruct sk_buff_head q;\n};\n\n#define NEXT_SLAVE(q) (((struct teql_sched_data *)qdisc_priv(q))->next)\n\n#define FMASK (IFF_BROADCAST | IFF_POINTOPOINT)\n\n \n\nstatic int\nteql_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct teql_sched_data *q = qdisc_priv(sch);\n\n\tif (q->q.qlen < dev->tx_queue_len) {\n\t\t__skb_queue_tail(&q->q, skb);\n\t\treturn NET_XMIT_SUCCESS;\n\t}\n\n\treturn qdisc_drop(skb, sch, to_free);\n}\n\nstatic struct sk_buff *\nteql_dequeue(struct Qdisc *sch)\n{\n\tstruct teql_sched_data *dat = qdisc_priv(sch);\n\tstruct netdev_queue *dat_queue;\n\tstruct sk_buff *skb;\n\tstruct Qdisc *q;\n\n\tskb = __skb_dequeue(&dat->q);\n\tdat_queue = netdev_get_tx_queue(dat->m->dev, 0);\n\tq = rcu_dereference_bh(dat_queue->qdisc);\n\n\tif (skb == NULL) {\n\t\tstruct net_device *m = qdisc_dev(q);\n\t\tif (m) {\n\t\t\tdat->m->slaves = sch;\n\t\t\tnetif_wake_queue(m);\n\t\t}\n\t} else {\n\t\tqdisc_bstats_update(sch, skb);\n\t}\n\tsch->q.qlen = dat->q.qlen + q->q.qlen;\n\treturn skb;\n}\n\nstatic struct sk_buff *\nteql_peek(struct Qdisc *sch)\n{\n\t \n\treturn NULL;\n}\n\nstatic void\nteql_reset(struct Qdisc *sch)\n{\n\tstruct teql_sched_data *dat = qdisc_priv(sch);\n\n\tskb_queue_purge(&dat->q);\n}\n\nstatic void\nteql_destroy(struct Qdisc *sch)\n{\n\tstruct Qdisc *q, *prev;\n\tstruct teql_sched_data *dat = qdisc_priv(sch);\n\tstruct teql_master *master = dat->m;\n\n\tif (!master)\n\t\treturn;\n\n\tprev = master->slaves;\n\tif (prev) {\n\t\tdo {\n\t\t\tq = NEXT_SLAVE(prev);\n\t\t\tif (q == sch) {\n\t\t\t\tNEXT_SLAVE(prev) = NEXT_SLAVE(q);\n\t\t\t\tif (q == master->slaves) {\n\t\t\t\t\tmaster->slaves = NEXT_SLAVE(q);\n\t\t\t\t\tif (q == master->slaves) {\n\t\t\t\t\t\tstruct netdev_queue *txq;\n\t\t\t\t\t\tspinlock_t *root_lock;\n\n\t\t\t\t\t\ttxq = netdev_get_tx_queue(master->dev, 0);\n\t\t\t\t\t\tmaster->slaves = NULL;\n\n\t\t\t\t\t\troot_lock = qdisc_root_sleeping_lock(rtnl_dereference(txq->qdisc));\n\t\t\t\t\t\tspin_lock_bh(root_lock);\n\t\t\t\t\t\tqdisc_reset(rtnl_dereference(txq->qdisc));\n\t\t\t\t\t\tspin_unlock_bh(root_lock);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tskb_queue_purge(&dat->q);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} while ((prev = q) != master->slaves);\n\t}\n}\n\nstatic int teql_qdisc_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct teql_master *m = (struct teql_master *)sch->ops;\n\tstruct teql_sched_data *q = qdisc_priv(sch);\n\n\tif (dev->hard_header_len > m->dev->hard_header_len)\n\t\treturn -EINVAL;\n\n\tif (m->dev == dev)\n\t\treturn -ELOOP;\n\n\tq->m = m;\n\n\tskb_queue_head_init(&q->q);\n\n\tif (m->slaves) {\n\t\tif (m->dev->flags & IFF_UP) {\n\t\t\tif ((m->dev->flags & IFF_POINTOPOINT &&\n\t\t\t     !(dev->flags & IFF_POINTOPOINT)) ||\n\t\t\t    (m->dev->flags & IFF_BROADCAST &&\n\t\t\t     !(dev->flags & IFF_BROADCAST)) ||\n\t\t\t    (m->dev->flags & IFF_MULTICAST &&\n\t\t\t     !(dev->flags & IFF_MULTICAST)) ||\n\t\t\t    dev->mtu < m->dev->mtu)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (!(dev->flags&IFF_POINTOPOINT))\n\t\t\t\tm->dev->flags &= ~IFF_POINTOPOINT;\n\t\t\tif (!(dev->flags&IFF_BROADCAST))\n\t\t\t\tm->dev->flags &= ~IFF_BROADCAST;\n\t\t\tif (!(dev->flags&IFF_MULTICAST))\n\t\t\t\tm->dev->flags &= ~IFF_MULTICAST;\n\t\t\tif (dev->mtu < m->dev->mtu)\n\t\t\t\tm->dev->mtu = dev->mtu;\n\t\t}\n\t\tq->next = NEXT_SLAVE(m->slaves);\n\t\tNEXT_SLAVE(m->slaves) = sch;\n\t} else {\n\t\tq->next = sch;\n\t\tm->slaves = sch;\n\t\tm->dev->mtu = dev->mtu;\n\t\tm->dev->flags = (m->dev->flags&~FMASK)|(dev->flags&FMASK);\n\t}\n\treturn 0;\n}\n\n\nstatic int\n__teql_resolve(struct sk_buff *skb, struct sk_buff *skb_res,\n\t       struct net_device *dev, struct netdev_queue *txq,\n\t       struct dst_entry *dst)\n{\n\tstruct neighbour *n;\n\tint err = 0;\n\n\tn = dst_neigh_lookup_skb(dst, skb);\n\tif (!n)\n\t\treturn -ENOENT;\n\n\tif (dst->dev != dev) {\n\t\tstruct neighbour *mn;\n\n\t\tmn = __neigh_lookup_errno(n->tbl, n->primary_key, dev);\n\t\tneigh_release(n);\n\t\tif (IS_ERR(mn))\n\t\t\treturn PTR_ERR(mn);\n\t\tn = mn;\n\t}\n\n\tif (neigh_event_send(n, skb_res) == 0) {\n\t\tint err;\n\t\tchar haddr[MAX_ADDR_LEN];\n\n\t\tneigh_ha_snapshot(haddr, n, dev);\n\t\terr = dev_hard_header(skb, dev, ntohs(skb_protocol(skb, false)),\n\t\t\t\t      haddr, NULL, skb->len);\n\n\t\tif (err < 0)\n\t\t\terr = -EINVAL;\n\t} else {\n\t\terr = (skb_res == NULL) ? -EAGAIN : 1;\n\t}\n\tneigh_release(n);\n\treturn err;\n}\n\nstatic inline int teql_resolve(struct sk_buff *skb,\n\t\t\t       struct sk_buff *skb_res,\n\t\t\t       struct net_device *dev,\n\t\t\t       struct netdev_queue *txq)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tint res;\n\n\tif (rcu_access_pointer(txq->qdisc) == &noop_qdisc)\n\t\treturn -ENODEV;\n\n\tif (!dev->header_ops || !dst)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tres = __teql_resolve(skb, skb_res, dev, txq, dst);\n\trcu_read_unlock();\n\n\treturn res;\n}\n\nstatic netdev_tx_t teql_master_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct teql_master *master = netdev_priv(dev);\n\tstruct Qdisc *start, *q;\n\tint busy;\n\tint nores;\n\tint subq = skb_get_queue_mapping(skb);\n\tstruct sk_buff *skb_res = NULL;\n\n\tstart = master->slaves;\n\nrestart:\n\tnores = 0;\n\tbusy = 0;\n\n\tq = start;\n\tif (!q)\n\t\tgoto drop;\n\n\tdo {\n\t\tstruct net_device *slave = qdisc_dev(q);\n\t\tstruct netdev_queue *slave_txq = netdev_get_tx_queue(slave, 0);\n\n\t\tif (rcu_access_pointer(slave_txq->qdisc_sleeping) != q)\n\t\t\tcontinue;\n\t\tif (netif_xmit_stopped(netdev_get_tx_queue(slave, subq)) ||\n\t\t    !netif_running(slave)) {\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (teql_resolve(skb, skb_res, slave, slave_txq)) {\n\t\tcase 0:\n\t\t\tif (__netif_tx_trylock(slave_txq)) {\n\t\t\t\tunsigned int length = qdisc_pkt_len(skb);\n\n\t\t\t\tif (!netif_xmit_frozen_or_stopped(slave_txq) &&\n\t\t\t\t    netdev_start_xmit(skb, slave, slave_txq, false) ==\n\t\t\t\t    NETDEV_TX_OK) {\n\t\t\t\t\t__netif_tx_unlock(slave_txq);\n\t\t\t\t\tmaster->slaves = NEXT_SLAVE(q);\n\t\t\t\t\tnetif_wake_queue(dev);\n\t\t\t\t\tmaster->tx_packets++;\n\t\t\t\t\tmaster->tx_bytes += length;\n\t\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t\t}\n\t\t\t\t__netif_tx_unlock(slave_txq);\n\t\t\t}\n\t\t\tif (netif_xmit_stopped(netdev_get_tx_queue(dev, 0)))\n\t\t\t\tbusy = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmaster->slaves = NEXT_SLAVE(q);\n\t\t\treturn NETDEV_TX_OK;\n\t\tdefault:\n\t\t\tnores = 1;\n\t\t\tbreak;\n\t\t}\n\t\t__skb_pull(skb, skb_network_offset(skb));\n\t} while ((q = NEXT_SLAVE(q)) != start);\n\n\tif (nores && skb_res == NULL) {\n\t\tskb_res = skb;\n\t\tgoto restart;\n\t}\n\n\tif (busy) {\n\t\tnetif_stop_queue(dev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\tmaster->tx_errors++;\n\ndrop:\n\tmaster->tx_dropped++;\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int teql_master_open(struct net_device *dev)\n{\n\tstruct Qdisc *q;\n\tstruct teql_master *m = netdev_priv(dev);\n\tint mtu = 0xFFFE;\n\tunsigned int flags = IFF_NOARP | IFF_MULTICAST;\n\n\tif (m->slaves == NULL)\n\t\treturn -EUNATCH;\n\n\tflags = FMASK;\n\n\tq = m->slaves;\n\tdo {\n\t\tstruct net_device *slave = qdisc_dev(q);\n\n\t\tif (slave == NULL)\n\t\t\treturn -EUNATCH;\n\n\t\tif (slave->mtu < mtu)\n\t\t\tmtu = slave->mtu;\n\t\tif (slave->hard_header_len > LL_MAX_HEADER)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!(slave->flags&IFF_POINTOPOINT))\n\t\t\tflags &= ~IFF_POINTOPOINT;\n\t\tif (!(slave->flags&IFF_BROADCAST))\n\t\t\tflags &= ~IFF_BROADCAST;\n\t\tif (!(slave->flags&IFF_MULTICAST))\n\t\t\tflags &= ~IFF_MULTICAST;\n\t} while ((q = NEXT_SLAVE(q)) != m->slaves);\n\n\tm->dev->mtu = mtu;\n\tm->dev->flags = (m->dev->flags&~FMASK) | flags;\n\tnetif_start_queue(m->dev);\n\treturn 0;\n}\n\nstatic int teql_master_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\nstatic void teql_master_stats64(struct net_device *dev,\n\t\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tstruct teql_master *m = netdev_priv(dev);\n\n\tstats->tx_packets\t= m->tx_packets;\n\tstats->tx_bytes\t\t= m->tx_bytes;\n\tstats->tx_errors\t= m->tx_errors;\n\tstats->tx_dropped\t= m->tx_dropped;\n}\n\nstatic int teql_master_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct teql_master *m = netdev_priv(dev);\n\tstruct Qdisc *q;\n\n\tq = m->slaves;\n\tif (q) {\n\t\tdo {\n\t\t\tif (new_mtu > qdisc_dev(q)->mtu)\n\t\t\t\treturn -EINVAL;\n\t\t} while ((q = NEXT_SLAVE(q)) != m->slaves);\n\t}\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic const struct net_device_ops teql_netdev_ops = {\n\t.ndo_open\t= teql_master_open,\n\t.ndo_stop\t= teql_master_close,\n\t.ndo_start_xmit\t= teql_master_xmit,\n\t.ndo_get_stats64 = teql_master_stats64,\n\t.ndo_change_mtu\t= teql_master_mtu,\n};\n\nstatic __init void teql_master_setup(struct net_device *dev)\n{\n\tstruct teql_master *master = netdev_priv(dev);\n\tstruct Qdisc_ops *ops = &master->qops;\n\n\tmaster->dev\t= dev;\n\tops->priv_size  = sizeof(struct teql_sched_data);\n\n\tops->enqueue\t=\tteql_enqueue;\n\tops->dequeue\t=\tteql_dequeue;\n\tops->peek\t=\tteql_peek;\n\tops->init\t=\tteql_qdisc_init;\n\tops->reset\t=\tteql_reset;\n\tops->destroy\t=\tteql_destroy;\n\tops->owner\t=\tTHIS_MODULE;\n\n\tdev->netdev_ops =       &teql_netdev_ops;\n\tdev->type\t\t= ARPHRD_VOID;\n\tdev->mtu\t\t= 1500;\n\tdev->min_mtu\t\t= 68;\n\tdev->max_mtu\t\t= 65535;\n\tdev->tx_queue_len\t= 100;\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->hard_header_len\t= LL_MAX_HEADER;\n\tnetif_keep_dst(dev);\n}\n\nstatic LIST_HEAD(master_dev_list);\nstatic int max_equalizers = 1;\nmodule_param(max_equalizers, int, 0);\nMODULE_PARM_DESC(max_equalizers, \"Max number of link equalizers\");\n\nstatic int __init teql_init(void)\n{\n\tint i;\n\tint err = -ENODEV;\n\n\tfor (i = 0; i < max_equalizers; i++) {\n\t\tstruct net_device *dev;\n\t\tstruct teql_master *master;\n\n\t\tdev = alloc_netdev(sizeof(struct teql_master), \"teql%d\",\n\t\t\t\t   NET_NAME_UNKNOWN, teql_master_setup);\n\t\tif (!dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((err = register_netdev(dev))) {\n\t\t\tfree_netdev(dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tmaster = netdev_priv(dev);\n\n\t\tstrscpy(master->qops.id, dev->name, IFNAMSIZ);\n\t\terr = register_qdisc(&master->qops);\n\n\t\tif (err) {\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&master->master_list, &master_dev_list);\n\t}\n\treturn i ? 0 : err;\n}\n\nstatic void __exit teql_exit(void)\n{\n\tstruct teql_master *master, *nxt;\n\n\tlist_for_each_entry_safe(master, nxt, &master_dev_list, master_list) {\n\n\t\tlist_del(&master->master_list);\n\n\t\tunregister_qdisc(&master->qops);\n\t\tunregister_netdev(master->dev);\n\t\tfree_netdev(master->dev);\n\t}\n}\n\nmodule_init(teql_init);\nmodule_exit(teql_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}