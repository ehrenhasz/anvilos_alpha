{
  "module_name": "em_meta.c",
  "hash_id": "729339c1b7a777c477bdc443e29d7b64ff7fe644b28a57cc3500d00e718c717d",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/em_meta.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/loadavg.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/if_vlan.h>\n#include <linux/tc_ematch/tc_em_meta.h>\n#include <net/dst.h>\n#include <net/route.h>\n#include <net/pkt_cls.h>\n#include <net/sock.h>\n\nstruct meta_obj {\n\tunsigned long\t\tvalue;\n\tunsigned int\t\tlen;\n};\n\nstruct meta_value {\n\tstruct tcf_meta_val\thdr;\n\tunsigned long\t\tval;\n\tunsigned int\t\tlen;\n};\n\nstruct meta_match {\n\tstruct meta_value\tlvalue;\n\tstruct meta_value\trvalue;\n};\n\nstatic inline int meta_id(struct meta_value *v)\n{\n\treturn TCF_META_ID(v->hdr.kind);\n}\n\nstatic inline int meta_type(struct meta_value *v)\n{\n\treturn TCF_META_TYPE(v->hdr.kind);\n}\n\n#define META_COLLECTOR(FUNC) static void meta_##FUNC(struct sk_buff *skb, \\\n\tstruct tcf_pkt_info *info, struct meta_value *v, \\\n\tstruct meta_obj *dst, int *err)\n\n \n\nMETA_COLLECTOR(int_random)\n{\n\tget_random_bytes(&dst->value, sizeof(dst->value));\n}\n\nstatic inline unsigned long fixed_loadavg(int load)\n{\n\tint rnd_load = load + (FIXED_1/200);\n\tint rnd_frac = ((rnd_load & (FIXED_1-1)) * 100) >> FSHIFT;\n\n\treturn ((rnd_load >> FSHIFT) * 100) + rnd_frac;\n}\n\nMETA_COLLECTOR(int_loadavg_0)\n{\n\tdst->value = fixed_loadavg(avenrun[0]);\n}\n\nMETA_COLLECTOR(int_loadavg_1)\n{\n\tdst->value = fixed_loadavg(avenrun[1]);\n}\n\nMETA_COLLECTOR(int_loadavg_2)\n{\n\tdst->value = fixed_loadavg(avenrun[2]);\n}\n\n \n\nstatic inline int int_dev(struct net_device *dev, struct meta_obj *dst)\n{\n\tif (unlikely(dev == NULL))\n\t\treturn -1;\n\n\tdst->value = dev->ifindex;\n\treturn 0;\n}\n\nstatic inline int var_dev(struct net_device *dev, struct meta_obj *dst)\n{\n\tif (unlikely(dev == NULL))\n\t\treturn -1;\n\n\tdst->value = (unsigned long) dev->name;\n\tdst->len = strlen(dev->name);\n\treturn 0;\n}\n\nMETA_COLLECTOR(int_dev)\n{\n\t*err = int_dev(skb->dev, dst);\n}\n\nMETA_COLLECTOR(var_dev)\n{\n\t*err = var_dev(skb->dev, dst);\n}\n\n \n\nMETA_COLLECTOR(int_vlan_tag)\n{\n\tunsigned short tag;\n\n\tif (skb_vlan_tag_present(skb))\n\t\tdst->value = skb_vlan_tag_get(skb);\n\telse if (!__vlan_get_tag(skb, &tag))\n\t\tdst->value = tag;\n\telse\n\t\t*err = -1;\n}\n\n\n\n \n\nMETA_COLLECTOR(int_priority)\n{\n\tdst->value = skb->priority;\n}\n\nMETA_COLLECTOR(int_protocol)\n{\n\t \n\tdst->value = skb_protocol(skb, false);\n}\n\nMETA_COLLECTOR(int_pkttype)\n{\n\tdst->value = skb->pkt_type;\n}\n\nMETA_COLLECTOR(int_pktlen)\n{\n\tdst->value = skb->len;\n}\n\nMETA_COLLECTOR(int_datalen)\n{\n\tdst->value = skb->data_len;\n}\n\nMETA_COLLECTOR(int_maclen)\n{\n\tdst->value = skb->mac_len;\n}\n\nMETA_COLLECTOR(int_rxhash)\n{\n\tdst->value = skb_get_hash(skb);\n}\n\n \n\nMETA_COLLECTOR(int_mark)\n{\n\tdst->value = skb->mark;\n}\n\n \n\nMETA_COLLECTOR(int_tcindex)\n{\n\tdst->value = skb->tc_index;\n}\n\n \n\nMETA_COLLECTOR(int_rtclassid)\n{\n\tif (unlikely(skb_dst(skb) == NULL))\n\t\t*err = -1;\n\telse\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\t\tdst->value = skb_dst(skb)->tclassid;\n#else\n\t\tdst->value = 0;\n#endif\n}\n\nMETA_COLLECTOR(int_rtiif)\n{\n\tif (unlikely(skb_rtable(skb) == NULL))\n\t\t*err = -1;\n\telse\n\t\tdst->value = inet_iif(skb);\n}\n\n \n\n#define skip_nonlocal(skb) \\\n\t(unlikely(skb->sk == NULL))\n\nMETA_COLLECTOR(int_sk_family)\n{\n\tif (skip_nonlocal(skb)) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = skb->sk->sk_family;\n}\n\nMETA_COLLECTOR(int_sk_state)\n{\n\tif (skip_nonlocal(skb)) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = skb->sk->sk_state;\n}\n\nMETA_COLLECTOR(int_sk_reuse)\n{\n\tif (skip_nonlocal(skb)) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = skb->sk->sk_reuse;\n}\n\nMETA_COLLECTOR(int_sk_bound_if)\n{\n\tif (skip_nonlocal(skb)) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\t \n\tdst->value = skb->sk->sk_bound_dev_if;\n}\n\nMETA_COLLECTOR(var_sk_bound_if)\n{\n\tint bound_dev_if;\n\n\tif (skip_nonlocal(skb)) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\n\tbound_dev_if = READ_ONCE(skb->sk->sk_bound_dev_if);\n\tif (bound_dev_if == 0) {\n\t\tdst->value = (unsigned long) \"any\";\n\t\tdst->len = 3;\n\t} else {\n\t\tstruct net_device *dev;\n\n\t\trcu_read_lock();\n\t\tdev = dev_get_by_index_rcu(sock_net(skb->sk),\n\t\t\t\t\t   bound_dev_if);\n\t\t*err = var_dev(dev, dst);\n\t\trcu_read_unlock();\n\t}\n}\n\nMETA_COLLECTOR(int_sk_refcnt)\n{\n\tif (skip_nonlocal(skb)) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = refcount_read(&skb->sk->sk_refcnt);\n}\n\nMETA_COLLECTOR(int_sk_rcvbuf)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_rcvbuf;\n}\n\nMETA_COLLECTOR(int_sk_shutdown)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_shutdown;\n}\n\nMETA_COLLECTOR(int_sk_proto)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_protocol;\n}\n\nMETA_COLLECTOR(int_sk_type)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_type;\n}\n\nMETA_COLLECTOR(int_sk_rmem_alloc)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk_rmem_alloc_get(sk);\n}\n\nMETA_COLLECTOR(int_sk_wmem_alloc)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk_wmem_alloc_get(sk);\n}\n\nMETA_COLLECTOR(int_sk_omem_alloc)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = atomic_read(&sk->sk_omem_alloc);\n}\n\nMETA_COLLECTOR(int_sk_rcv_qlen)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_receive_queue.qlen;\n}\n\nMETA_COLLECTOR(int_sk_snd_qlen)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_write_queue.qlen;\n}\n\nMETA_COLLECTOR(int_sk_wmem_queued)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = READ_ONCE(sk->sk_wmem_queued);\n}\n\nMETA_COLLECTOR(int_sk_fwd_alloc)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk_forward_alloc_get(sk);\n}\n\nMETA_COLLECTOR(int_sk_sndbuf)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_sndbuf;\n}\n\nMETA_COLLECTOR(int_sk_alloc)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = (__force int) sk->sk_allocation;\n}\n\nMETA_COLLECTOR(int_sk_hash)\n{\n\tif (skip_nonlocal(skb)) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = skb->sk->sk_hash;\n}\n\nMETA_COLLECTOR(int_sk_lingertime)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = READ_ONCE(sk->sk_lingertime) / HZ;\n}\n\nMETA_COLLECTOR(int_sk_err_qlen)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_error_queue.qlen;\n}\n\nMETA_COLLECTOR(int_sk_ack_bl)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = READ_ONCE(sk->sk_ack_backlog);\n}\n\nMETA_COLLECTOR(int_sk_max_ack_bl)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = READ_ONCE(sk->sk_max_ack_backlog);\n}\n\nMETA_COLLECTOR(int_sk_prio)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_priority;\n}\n\nMETA_COLLECTOR(int_sk_rcvlowat)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = READ_ONCE(sk->sk_rcvlowat);\n}\n\nMETA_COLLECTOR(int_sk_rcvtimeo)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = READ_ONCE(sk->sk_rcvtimeo) / HZ;\n}\n\nMETA_COLLECTOR(int_sk_sndtimeo)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = READ_ONCE(sk->sk_sndtimeo) / HZ;\n}\n\nMETA_COLLECTOR(int_sk_sendmsg_off)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_frag.offset;\n}\n\nMETA_COLLECTOR(int_sk_write_pend)\n{\n\tconst struct sock *sk = skb_to_full_sk(skb);\n\n\tif (!sk) {\n\t\t*err = -1;\n\t\treturn;\n\t}\n\tdst->value = sk->sk_write_pending;\n}\n\n \n\nstruct meta_ops {\n\tvoid\t\t(*get)(struct sk_buff *, struct tcf_pkt_info *,\n\t\t\t       struct meta_value *, struct meta_obj *, int *);\n};\n\n#define META_ID(name) TCF_META_ID_##name\n#define META_FUNC(name) { .get = meta_##name }\n\n \nstatic struct meta_ops __meta_ops[TCF_META_TYPE_MAX + 1][TCF_META_ID_MAX + 1] = {\n\t[TCF_META_TYPE_VAR] = {\n\t\t[META_ID(DEV)]\t\t\t= META_FUNC(var_dev),\n\t\t[META_ID(SK_BOUND_IF)] \t\t= META_FUNC(var_sk_bound_if),\n\t},\n\t[TCF_META_TYPE_INT] = {\n\t\t[META_ID(RANDOM)]\t\t= META_FUNC(int_random),\n\t\t[META_ID(LOADAVG_0)]\t\t= META_FUNC(int_loadavg_0),\n\t\t[META_ID(LOADAVG_1)]\t\t= META_FUNC(int_loadavg_1),\n\t\t[META_ID(LOADAVG_2)]\t\t= META_FUNC(int_loadavg_2),\n\t\t[META_ID(DEV)]\t\t\t= META_FUNC(int_dev),\n\t\t[META_ID(PRIORITY)]\t\t= META_FUNC(int_priority),\n\t\t[META_ID(PROTOCOL)]\t\t= META_FUNC(int_protocol),\n\t\t[META_ID(PKTTYPE)]\t\t= META_FUNC(int_pkttype),\n\t\t[META_ID(PKTLEN)]\t\t= META_FUNC(int_pktlen),\n\t\t[META_ID(DATALEN)]\t\t= META_FUNC(int_datalen),\n\t\t[META_ID(MACLEN)]\t\t= META_FUNC(int_maclen),\n\t\t[META_ID(NFMARK)]\t\t= META_FUNC(int_mark),\n\t\t[META_ID(TCINDEX)]\t\t= META_FUNC(int_tcindex),\n\t\t[META_ID(RTCLASSID)]\t\t= META_FUNC(int_rtclassid),\n\t\t[META_ID(RTIIF)]\t\t= META_FUNC(int_rtiif),\n\t\t[META_ID(SK_FAMILY)]\t\t= META_FUNC(int_sk_family),\n\t\t[META_ID(SK_STATE)]\t\t= META_FUNC(int_sk_state),\n\t\t[META_ID(SK_REUSE)]\t\t= META_FUNC(int_sk_reuse),\n\t\t[META_ID(SK_BOUND_IF)]\t\t= META_FUNC(int_sk_bound_if),\n\t\t[META_ID(SK_REFCNT)]\t\t= META_FUNC(int_sk_refcnt),\n\t\t[META_ID(SK_RCVBUF)]\t\t= META_FUNC(int_sk_rcvbuf),\n\t\t[META_ID(SK_SNDBUF)]\t\t= META_FUNC(int_sk_sndbuf),\n\t\t[META_ID(SK_SHUTDOWN)]\t\t= META_FUNC(int_sk_shutdown),\n\t\t[META_ID(SK_PROTO)]\t\t= META_FUNC(int_sk_proto),\n\t\t[META_ID(SK_TYPE)]\t\t= META_FUNC(int_sk_type),\n\t\t[META_ID(SK_RMEM_ALLOC)]\t= META_FUNC(int_sk_rmem_alloc),\n\t\t[META_ID(SK_WMEM_ALLOC)]\t= META_FUNC(int_sk_wmem_alloc),\n\t\t[META_ID(SK_OMEM_ALLOC)]\t= META_FUNC(int_sk_omem_alloc),\n\t\t[META_ID(SK_WMEM_QUEUED)]\t= META_FUNC(int_sk_wmem_queued),\n\t\t[META_ID(SK_RCV_QLEN)]\t\t= META_FUNC(int_sk_rcv_qlen),\n\t\t[META_ID(SK_SND_QLEN)]\t\t= META_FUNC(int_sk_snd_qlen),\n\t\t[META_ID(SK_ERR_QLEN)]\t\t= META_FUNC(int_sk_err_qlen),\n\t\t[META_ID(SK_FORWARD_ALLOCS)]\t= META_FUNC(int_sk_fwd_alloc),\n\t\t[META_ID(SK_ALLOCS)]\t\t= META_FUNC(int_sk_alloc),\n\t\t[META_ID(SK_HASH)]\t\t= META_FUNC(int_sk_hash),\n\t\t[META_ID(SK_LINGERTIME)]\t= META_FUNC(int_sk_lingertime),\n\t\t[META_ID(SK_ACK_BACKLOG)]\t= META_FUNC(int_sk_ack_bl),\n\t\t[META_ID(SK_MAX_ACK_BACKLOG)]\t= META_FUNC(int_sk_max_ack_bl),\n\t\t[META_ID(SK_PRIO)]\t\t= META_FUNC(int_sk_prio),\n\t\t[META_ID(SK_RCVLOWAT)]\t\t= META_FUNC(int_sk_rcvlowat),\n\t\t[META_ID(SK_RCVTIMEO)]\t\t= META_FUNC(int_sk_rcvtimeo),\n\t\t[META_ID(SK_SNDTIMEO)]\t\t= META_FUNC(int_sk_sndtimeo),\n\t\t[META_ID(SK_SENDMSG_OFF)]\t= META_FUNC(int_sk_sendmsg_off),\n\t\t[META_ID(SK_WRITE_PENDING)]\t= META_FUNC(int_sk_write_pend),\n\t\t[META_ID(VLAN_TAG)]\t\t= META_FUNC(int_vlan_tag),\n\t\t[META_ID(RXHASH)]\t\t= META_FUNC(int_rxhash),\n\t}\n};\n\nstatic inline struct meta_ops *meta_ops(struct meta_value *val)\n{\n\treturn &__meta_ops[meta_type(val)][meta_id(val)];\n}\n\n \n\nstatic int meta_var_compare(struct meta_obj *a, struct meta_obj *b)\n{\n\tint r = a->len - b->len;\n\n\tif (r == 0)\n\t\tr = memcmp((void *) a->value, (void *) b->value, a->len);\n\n\treturn r;\n}\n\nstatic int meta_var_change(struct meta_value *dst, struct nlattr *nla)\n{\n\tint len = nla_len(nla);\n\n\tdst->val = (unsigned long)kmemdup(nla_data(nla), len, GFP_KERNEL);\n\tif (dst->val == 0UL)\n\t\treturn -ENOMEM;\n\tdst->len = len;\n\treturn 0;\n}\n\nstatic void meta_var_destroy(struct meta_value *v)\n{\n\tkfree((void *) v->val);\n}\n\nstatic void meta_var_apply_extras(struct meta_value *v,\n\t\t\t\t  struct meta_obj *dst)\n{\n\tint shift = v->hdr.shift;\n\n\tif (shift && shift < dst->len)\n\t\tdst->len -= shift;\n}\n\nstatic int meta_var_dump(struct sk_buff *skb, struct meta_value *v, int tlv)\n{\n\tif (v->val && v->len &&\n\t    nla_put(skb, tlv, v->len, (void *) v->val))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\n \n\nstatic int meta_int_compare(struct meta_obj *a, struct meta_obj *b)\n{\n\t \n\tif (unlikely(a->value == b->value))\n\t\treturn 0;\n\telse if (a->value < b->value)\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}\n\nstatic int meta_int_change(struct meta_value *dst, struct nlattr *nla)\n{\n\tif (nla_len(nla) >= sizeof(unsigned long)) {\n\t\tdst->val = *(unsigned long *) nla_data(nla);\n\t\tdst->len = sizeof(unsigned long);\n\t} else if (nla_len(nla) == sizeof(u32)) {\n\t\tdst->val = nla_get_u32(nla);\n\t\tdst->len = sizeof(u32);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void meta_int_apply_extras(struct meta_value *v,\n\t\t\t\t  struct meta_obj *dst)\n{\n\tif (v->hdr.shift)\n\t\tdst->value >>= v->hdr.shift;\n\n\tif (v->val)\n\t\tdst->value &= v->val;\n}\n\nstatic int meta_int_dump(struct sk_buff *skb, struct meta_value *v, int tlv)\n{\n\tif (v->len == sizeof(unsigned long)) {\n\t\tif (nla_put(skb, tlv, sizeof(unsigned long), &v->val))\n\t\t\tgoto nla_put_failure;\n\t} else if (v->len == sizeof(u32)) {\n\t\tif (nla_put_u32(skb, tlv, v->val))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\n \n\nstruct meta_type_ops {\n\tvoid\t(*destroy)(struct meta_value *);\n\tint\t(*compare)(struct meta_obj *, struct meta_obj *);\n\tint\t(*change)(struct meta_value *, struct nlattr *);\n\tvoid\t(*apply_extras)(struct meta_value *, struct meta_obj *);\n\tint\t(*dump)(struct sk_buff *, struct meta_value *, int);\n};\n\nstatic const struct meta_type_ops __meta_type_ops[TCF_META_TYPE_MAX + 1] = {\n\t[TCF_META_TYPE_VAR] = {\n\t\t.destroy = meta_var_destroy,\n\t\t.compare = meta_var_compare,\n\t\t.change = meta_var_change,\n\t\t.apply_extras = meta_var_apply_extras,\n\t\t.dump = meta_var_dump\n\t},\n\t[TCF_META_TYPE_INT] = {\n\t\t.compare = meta_int_compare,\n\t\t.change = meta_int_change,\n\t\t.apply_extras = meta_int_apply_extras,\n\t\t.dump = meta_int_dump\n\t}\n};\n\nstatic inline const struct meta_type_ops *meta_type_ops(struct meta_value *v)\n{\n\treturn &__meta_type_ops[meta_type(v)];\n}\n\n \n\nstatic int meta_get(struct sk_buff *skb, struct tcf_pkt_info *info,\n\t\t    struct meta_value *v, struct meta_obj *dst)\n{\n\tint err = 0;\n\n\tif (meta_id(v) == TCF_META_ID_VALUE) {\n\t\tdst->value = v->val;\n\t\tdst->len = v->len;\n\t\treturn 0;\n\t}\n\n\tmeta_ops(v)->get(skb, info, v, dst, &err);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (meta_type_ops(v)->apply_extras)\n\t\tmeta_type_ops(v)->apply_extras(v, dst);\n\n\treturn 0;\n}\n\nstatic int em_meta_match(struct sk_buff *skb, struct tcf_ematch *m,\n\t\t\t struct tcf_pkt_info *info)\n{\n\tint r;\n\tstruct meta_match *meta = (struct meta_match *) m->data;\n\tstruct meta_obj l_value, r_value;\n\n\tif (meta_get(skb, info, &meta->lvalue, &l_value) < 0 ||\n\t    meta_get(skb, info, &meta->rvalue, &r_value) < 0)\n\t\treturn 0;\n\n\tr = meta_type_ops(&meta->lvalue)->compare(&l_value, &r_value);\n\n\tswitch (meta->lvalue.hdr.op) {\n\tcase TCF_EM_OPND_EQ:\n\t\treturn !r;\n\tcase TCF_EM_OPND_LT:\n\t\treturn r < 0;\n\tcase TCF_EM_OPND_GT:\n\t\treturn r > 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void meta_delete(struct meta_match *meta)\n{\n\tif (meta) {\n\t\tconst struct meta_type_ops *ops = meta_type_ops(&meta->lvalue);\n\n\t\tif (ops && ops->destroy) {\n\t\t\tops->destroy(&meta->lvalue);\n\t\t\tops->destroy(&meta->rvalue);\n\t\t}\n\t}\n\n\tkfree(meta);\n}\n\nstatic inline int meta_change_data(struct meta_value *dst, struct nlattr *nla)\n{\n\tif (nla) {\n\t\tif (nla_len(nla) == 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn meta_type_ops(dst)->change(dst, nla);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int meta_is_supported(struct meta_value *val)\n{\n\treturn !meta_id(val) || meta_ops(val)->get;\n}\n\nstatic const struct nla_policy meta_policy[TCA_EM_META_MAX + 1] = {\n\t[TCA_EM_META_HDR]\t= { .len = sizeof(struct tcf_meta_hdr) },\n};\n\nstatic int em_meta_change(struct net *net, void *data, int len,\n\t\t\t  struct tcf_ematch *m)\n{\n\tint err;\n\tstruct nlattr *tb[TCA_EM_META_MAX + 1];\n\tstruct tcf_meta_hdr *hdr;\n\tstruct meta_match *meta = NULL;\n\n\terr = nla_parse_deprecated(tb, TCA_EM_META_MAX, data, len,\n\t\t\t\t   meta_policy, NULL);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\tif (tb[TCA_EM_META_HDR] == NULL)\n\t\tgoto errout;\n\thdr = nla_data(tb[TCA_EM_META_HDR]);\n\n\tif (TCF_META_TYPE(hdr->left.kind) != TCF_META_TYPE(hdr->right.kind) ||\n\t    TCF_META_TYPE(hdr->left.kind) > TCF_META_TYPE_MAX ||\n\t    TCF_META_ID(hdr->left.kind) > TCF_META_ID_MAX ||\n\t    TCF_META_ID(hdr->right.kind) > TCF_META_ID_MAX)\n\t\tgoto errout;\n\n\tmeta = kzalloc(sizeof(*meta), GFP_KERNEL);\n\tif (meta == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tmemcpy(&meta->lvalue.hdr, &hdr->left, sizeof(hdr->left));\n\tmemcpy(&meta->rvalue.hdr, &hdr->right, sizeof(hdr->right));\n\n\tif (!meta_is_supported(&meta->lvalue) ||\n\t    !meta_is_supported(&meta->rvalue)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto errout;\n\t}\n\n\tif (meta_change_data(&meta->lvalue, tb[TCA_EM_META_LVALUE]) < 0 ||\n\t    meta_change_data(&meta->rvalue, tb[TCA_EM_META_RVALUE]) < 0)\n\t\tgoto errout;\n\n\tm->datalen = sizeof(*meta);\n\tm->data = (unsigned long) meta;\n\n\terr = 0;\nerrout:\n\tif (err && meta)\n\t\tmeta_delete(meta);\n\treturn err;\n}\n\nstatic void em_meta_destroy(struct tcf_ematch *m)\n{\n\tif (m)\n\t\tmeta_delete((struct meta_match *) m->data);\n}\n\nstatic int em_meta_dump(struct sk_buff *skb, struct tcf_ematch *em)\n{\n\tstruct meta_match *meta = (struct meta_match *) em->data;\n\tstruct tcf_meta_hdr hdr;\n\tconst struct meta_type_ops *ops;\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\tmemcpy(&hdr.left, &meta->lvalue.hdr, sizeof(hdr.left));\n\tmemcpy(&hdr.right, &meta->rvalue.hdr, sizeof(hdr.right));\n\n\tif (nla_put(skb, TCA_EM_META_HDR, sizeof(hdr), &hdr))\n\t\tgoto nla_put_failure;\n\n\tops = meta_type_ops(&meta->lvalue);\n\tif (ops->dump(skb, &meta->lvalue, TCA_EM_META_LVALUE) < 0 ||\n\t    ops->dump(skb, &meta->rvalue, TCA_EM_META_RVALUE) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic struct tcf_ematch_ops em_meta_ops = {\n\t.kind\t  = TCF_EM_META,\n\t.change\t  = em_meta_change,\n\t.match\t  = em_meta_match,\n\t.destroy  = em_meta_destroy,\n\t.dump\t  = em_meta_dump,\n\t.owner\t  = THIS_MODULE,\n\t.link\t  = LIST_HEAD_INIT(em_meta_ops.link)\n};\n\nstatic int __init init_em_meta(void)\n{\n\treturn tcf_em_register(&em_meta_ops);\n}\n\nstatic void __exit exit_em_meta(void)\n{\n\ttcf_em_unregister(&em_meta_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(init_em_meta);\nmodule_exit(exit_em_meta);\n\nMODULE_ALIAS_TCF_EMATCH(TCF_EM_META);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}