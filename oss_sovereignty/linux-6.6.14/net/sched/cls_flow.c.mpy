{
  "module_name": "cls_flow.c",
  "hash_id": "188f2e138da28a9e80086d1aaf0283b1b93aa0d3e31d44beb1c2fb87304c24db",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/cls_flow.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/pkt_cls.h>\n#include <linux/skbuff.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/if_vlan.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <net/inet_sock.h>\n\n#include <net/pkt_cls.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/flow_dissector.h>\n#include <net/tc_wrapper.h>\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <net/netfilter/nf_conntrack.h>\n#endif\n\nstruct flow_head {\n\tstruct list_head\tfilters;\n\tstruct rcu_head\t\trcu;\n};\n\nstruct flow_filter {\n\tstruct list_head\tlist;\n\tstruct tcf_exts\t\texts;\n\tstruct tcf_ematch_tree\tematches;\n\tstruct tcf_proto\t*tp;\n\tstruct timer_list\tperturb_timer;\n\tu32\t\t\tperturb_period;\n\tu32\t\t\thandle;\n\n\tu32\t\t\tnkeys;\n\tu32\t\t\tkeymask;\n\tu32\t\t\tmode;\n\tu32\t\t\tmask;\n\tu32\t\t\txor;\n\tu32\t\t\trshift;\n\tu32\t\t\taddend;\n\tu32\t\t\tdivisor;\n\tu32\t\t\tbaseclass;\n\tu32\t\t\thashrnd;\n\tstruct rcu_work\t\trwork;\n};\n\nstatic inline u32 addr_fold(void *addr)\n{\n\tunsigned long a = (unsigned long)addr;\n\n\treturn (a & 0xFFFFFFFF) ^ (BITS_PER_LONG > 32 ? a >> 32 : 0);\n}\n\nstatic u32 flow_get_src(const struct sk_buff *skb, const struct flow_keys *flow)\n{\n\t__be32 src = flow_get_u32_src(flow);\n\n\tif (src)\n\t\treturn ntohl(src);\n\n\treturn addr_fold(skb->sk);\n}\n\nstatic u32 flow_get_dst(const struct sk_buff *skb, const struct flow_keys *flow)\n{\n\t__be32 dst = flow_get_u32_dst(flow);\n\n\tif (dst)\n\t\treturn ntohl(dst);\n\n\treturn addr_fold(skb_dst(skb)) ^ (__force u16)skb_protocol(skb, true);\n}\n\nstatic u32 flow_get_proto(const struct sk_buff *skb,\n\t\t\t  const struct flow_keys *flow)\n{\n\treturn flow->basic.ip_proto;\n}\n\nstatic u32 flow_get_proto_src(const struct sk_buff *skb,\n\t\t\t      const struct flow_keys *flow)\n{\n\tif (flow->ports.ports)\n\t\treturn ntohs(flow->ports.src);\n\n\treturn addr_fold(skb->sk);\n}\n\nstatic u32 flow_get_proto_dst(const struct sk_buff *skb,\n\t\t\t      const struct flow_keys *flow)\n{\n\tif (flow->ports.ports)\n\t\treturn ntohs(flow->ports.dst);\n\n\treturn addr_fold(skb_dst(skb)) ^ (__force u16)skb_protocol(skb, true);\n}\n\nstatic u32 flow_get_iif(const struct sk_buff *skb)\n{\n\treturn skb->skb_iif;\n}\n\nstatic u32 flow_get_priority(const struct sk_buff *skb)\n{\n\treturn skb->priority;\n}\n\nstatic u32 flow_get_mark(const struct sk_buff *skb)\n{\n\treturn skb->mark;\n}\n\nstatic u32 flow_get_nfct(const struct sk_buff *skb)\n{\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\treturn addr_fold(skb_nfct(skb));\n#else\n\treturn 0;\n#endif\n}\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#define CTTUPLE(skb, member)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tenum ip_conntrack_info ctinfo;\t\t\t\t\t\\\n\tconst struct nf_conn *ct = nf_ct_get(skb, &ctinfo);\t\t\\\n\tif (ct == NULL)\t\t\t\t\t\t\t\\\n\t\tgoto fallback;\t\t\t\t\t\t\\\n\tct->tuplehash[CTINFO2DIR(ctinfo)].tuple.member;\t\t\t\\\n})\n#else\n#define CTTUPLE(skb, member)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tgoto fallback;\t\t\t\t\t\t\t\\\n\t0;\t\t\t\t\t\t\t\t\\\n})\n#endif\n\nstatic u32 flow_get_nfct_src(const struct sk_buff *skb,\n\t\t\t     const struct flow_keys *flow)\n{\n\tswitch (skb_protocol(skb, true)) {\n\tcase htons(ETH_P_IP):\n\t\treturn ntohl(CTTUPLE(skb, src.u3.ip));\n\tcase htons(ETH_P_IPV6):\n\t\treturn ntohl(CTTUPLE(skb, src.u3.ip6[3]));\n\t}\nfallback:\n\treturn flow_get_src(skb, flow);\n}\n\nstatic u32 flow_get_nfct_dst(const struct sk_buff *skb,\n\t\t\t     const struct flow_keys *flow)\n{\n\tswitch (skb_protocol(skb, true)) {\n\tcase htons(ETH_P_IP):\n\t\treturn ntohl(CTTUPLE(skb, dst.u3.ip));\n\tcase htons(ETH_P_IPV6):\n\t\treturn ntohl(CTTUPLE(skb, dst.u3.ip6[3]));\n\t}\nfallback:\n\treturn flow_get_dst(skb, flow);\n}\n\nstatic u32 flow_get_nfct_proto_src(const struct sk_buff *skb,\n\t\t\t\t   const struct flow_keys *flow)\n{\n\treturn ntohs(CTTUPLE(skb, src.u.all));\nfallback:\n\treturn flow_get_proto_src(skb, flow);\n}\n\nstatic u32 flow_get_nfct_proto_dst(const struct sk_buff *skb,\n\t\t\t\t   const struct flow_keys *flow)\n{\n\treturn ntohs(CTTUPLE(skb, dst.u.all));\nfallback:\n\treturn flow_get_proto_dst(skb, flow);\n}\n\nstatic u32 flow_get_rtclassid(const struct sk_buff *skb)\n{\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (skb_dst(skb))\n\t\treturn skb_dst(skb)->tclassid;\n#endif\n\treturn 0;\n}\n\nstatic u32 flow_get_skuid(const struct sk_buff *skb)\n{\n\tstruct sock *sk = skb_to_full_sk(skb);\n\n\tif (sk && sk->sk_socket && sk->sk_socket->file) {\n\t\tkuid_t skuid = sk->sk_socket->file->f_cred->fsuid;\n\n\t\treturn from_kuid(&init_user_ns, skuid);\n\t}\n\treturn 0;\n}\n\nstatic u32 flow_get_skgid(const struct sk_buff *skb)\n{\n\tstruct sock *sk = skb_to_full_sk(skb);\n\n\tif (sk && sk->sk_socket && sk->sk_socket->file) {\n\t\tkgid_t skgid = sk->sk_socket->file->f_cred->fsgid;\n\n\t\treturn from_kgid(&init_user_ns, skgid);\n\t}\n\treturn 0;\n}\n\nstatic u32 flow_get_vlan_tag(const struct sk_buff *skb)\n{\n\tu16 tag;\n\n\tif (vlan_get_tag(skb, &tag) < 0)\n\t\treturn 0;\n\treturn tag & VLAN_VID_MASK;\n}\n\nstatic u32 flow_get_rxhash(struct sk_buff *skb)\n{\n\treturn skb_get_hash(skb);\n}\n\nstatic u32 flow_key_get(struct sk_buff *skb, int key, struct flow_keys *flow)\n{\n\tswitch (key) {\n\tcase FLOW_KEY_SRC:\n\t\treturn flow_get_src(skb, flow);\n\tcase FLOW_KEY_DST:\n\t\treturn flow_get_dst(skb, flow);\n\tcase FLOW_KEY_PROTO:\n\t\treturn flow_get_proto(skb, flow);\n\tcase FLOW_KEY_PROTO_SRC:\n\t\treturn flow_get_proto_src(skb, flow);\n\tcase FLOW_KEY_PROTO_DST:\n\t\treturn flow_get_proto_dst(skb, flow);\n\tcase FLOW_KEY_IIF:\n\t\treturn flow_get_iif(skb);\n\tcase FLOW_KEY_PRIORITY:\n\t\treturn flow_get_priority(skb);\n\tcase FLOW_KEY_MARK:\n\t\treturn flow_get_mark(skb);\n\tcase FLOW_KEY_NFCT:\n\t\treturn flow_get_nfct(skb);\n\tcase FLOW_KEY_NFCT_SRC:\n\t\treturn flow_get_nfct_src(skb, flow);\n\tcase FLOW_KEY_NFCT_DST:\n\t\treturn flow_get_nfct_dst(skb, flow);\n\tcase FLOW_KEY_NFCT_PROTO_SRC:\n\t\treturn flow_get_nfct_proto_src(skb, flow);\n\tcase FLOW_KEY_NFCT_PROTO_DST:\n\t\treturn flow_get_nfct_proto_dst(skb, flow);\n\tcase FLOW_KEY_RTCLASSID:\n\t\treturn flow_get_rtclassid(skb);\n\tcase FLOW_KEY_SKUID:\n\t\treturn flow_get_skuid(skb);\n\tcase FLOW_KEY_SKGID:\n\t\treturn flow_get_skgid(skb);\n\tcase FLOW_KEY_VLAN_TAG:\n\t\treturn flow_get_vlan_tag(skb);\n\tcase FLOW_KEY_RXHASH:\n\t\treturn flow_get_rxhash(skb);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n}\n\n#define FLOW_KEYS_NEEDED ((1 << FLOW_KEY_SRC) | \t\t\\\n\t\t\t  (1 << FLOW_KEY_DST) |\t\t\t\\\n\t\t\t  (1 << FLOW_KEY_PROTO) |\t\t\\\n\t\t\t  (1 << FLOW_KEY_PROTO_SRC) |\t\t\\\n\t\t\t  (1 << FLOW_KEY_PROTO_DST) | \t\t\\\n\t\t\t  (1 << FLOW_KEY_NFCT_SRC) |\t\t\\\n\t\t\t  (1 << FLOW_KEY_NFCT_DST) |\t\t\\\n\t\t\t  (1 << FLOW_KEY_NFCT_PROTO_SRC) |\t\\\n\t\t\t  (1 << FLOW_KEY_NFCT_PROTO_DST))\n\nTC_INDIRECT_SCOPE int flow_classify(struct sk_buff *skb,\n\t\t\t\t    const struct tcf_proto *tp,\n\t\t\t\t    struct tcf_result *res)\n{\n\tstruct flow_head *head = rcu_dereference_bh(tp->root);\n\tstruct flow_filter *f;\n\tu32 keymask;\n\tu32 classid;\n\tunsigned int n, key;\n\tint r;\n\n\tlist_for_each_entry_rcu(f, &head->filters, list) {\n\t\tu32 keys[FLOW_KEY_MAX + 1];\n\t\tstruct flow_keys flow_keys;\n\n\t\tif (!tcf_em_tree_match(skb, &f->ematches, NULL))\n\t\t\tcontinue;\n\n\t\tkeymask = f->keymask;\n\t\tif (keymask & FLOW_KEYS_NEEDED)\n\t\t\tskb_flow_dissect_flow_keys(skb, &flow_keys, 0);\n\n\t\tfor (n = 0; n < f->nkeys; n++) {\n\t\t\tkey = ffs(keymask) - 1;\n\t\t\tkeymask &= ~(1 << key);\n\t\t\tkeys[n] = flow_key_get(skb, key, &flow_keys);\n\t\t}\n\n\t\tif (f->mode == FLOW_MODE_HASH)\n\t\t\tclassid = jhash2(keys, f->nkeys, f->hashrnd);\n\t\telse {\n\t\t\tclassid = keys[0];\n\t\t\tclassid = (classid & f->mask) ^ f->xor;\n\t\t\tclassid = (classid >> f->rshift) + f->addend;\n\t\t}\n\n\t\tif (f->divisor)\n\t\t\tclassid %= f->divisor;\n\n\t\tres->class   = 0;\n\t\tres->classid = TC_H_MAKE(f->baseclass, f->baseclass + classid);\n\n\t\tr = tcf_exts_exec(skb, &f->exts, res);\n\t\tif (r < 0)\n\t\t\tcontinue;\n\t\treturn r;\n\t}\n\treturn -1;\n}\n\nstatic void flow_perturbation(struct timer_list *t)\n{\n\tstruct flow_filter *f = from_timer(f, t, perturb_timer);\n\n\tget_random_bytes(&f->hashrnd, 4);\n\tif (f->perturb_period)\n\t\tmod_timer(&f->perturb_timer, jiffies + f->perturb_period);\n}\n\nstatic const struct nla_policy flow_policy[TCA_FLOW_MAX + 1] = {\n\t[TCA_FLOW_KEYS]\t\t= { .type = NLA_U32 },\n\t[TCA_FLOW_MODE]\t\t= { .type = NLA_U32 },\n\t[TCA_FLOW_BASECLASS]\t= { .type = NLA_U32 },\n\t[TCA_FLOW_RSHIFT]\t= { .type = NLA_U32 },\n\t[TCA_FLOW_ADDEND]\t= { .type = NLA_U32 },\n\t[TCA_FLOW_MASK]\t\t= { .type = NLA_U32 },\n\t[TCA_FLOW_XOR]\t\t= { .type = NLA_U32 },\n\t[TCA_FLOW_DIVISOR]\t= { .type = NLA_U32 },\n\t[TCA_FLOW_ACT]\t\t= { .type = NLA_NESTED },\n\t[TCA_FLOW_POLICE]\t= { .type = NLA_NESTED },\n\t[TCA_FLOW_EMATCHES]\t= { .type = NLA_NESTED },\n\t[TCA_FLOW_PERTURB]\t= { .type = NLA_U32 },\n};\n\nstatic void __flow_destroy_filter(struct flow_filter *f)\n{\n\ttimer_shutdown_sync(&f->perturb_timer);\n\ttcf_exts_destroy(&f->exts);\n\ttcf_em_tree_destroy(&f->ematches);\n\ttcf_exts_put_net(&f->exts);\n\tkfree(f);\n}\n\nstatic void flow_destroy_filter_work(struct work_struct *work)\n{\n\tstruct flow_filter *f = container_of(to_rcu_work(work),\n\t\t\t\t\t     struct flow_filter,\n\t\t\t\t\t     rwork);\n\trtnl_lock();\n\t__flow_destroy_filter(f);\n\trtnl_unlock();\n}\n\nstatic int flow_change(struct net *net, struct sk_buff *in_skb,\n\t\t       struct tcf_proto *tp, unsigned long base,\n\t\t       u32 handle, struct nlattr **tca,\n\t\t       void **arg, u32 flags,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct flow_head *head = rtnl_dereference(tp->root);\n\tstruct flow_filter *fold, *fnew;\n\tstruct nlattr *opt = tca[TCA_OPTIONS];\n\tstruct nlattr *tb[TCA_FLOW_MAX + 1];\n\tunsigned int nkeys = 0;\n\tunsigned int perturb_period = 0;\n\tu32 baseclass = 0;\n\tu32 keymask = 0;\n\tu32 mode;\n\tint err;\n\n\tif (opt == NULL)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_FLOW_MAX, opt, flow_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_FLOW_BASECLASS]) {\n\t\tbaseclass = nla_get_u32(tb[TCA_FLOW_BASECLASS]);\n\t\tif (TC_H_MIN(baseclass) == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[TCA_FLOW_KEYS]) {\n\t\tkeymask = nla_get_u32(tb[TCA_FLOW_KEYS]);\n\n\t\tnkeys = hweight32(keymask);\n\t\tif (nkeys == 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (fls(keymask) - 1 > FLOW_KEY_MAX)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif ((keymask & (FLOW_KEY_SKUID|FLOW_KEY_SKGID)) &&\n\t\t    sk_user_ns(NETLINK_CB(in_skb).sk) != &init_user_ns)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfnew = kzalloc(sizeof(*fnew), GFP_KERNEL);\n\tif (!fnew)\n\t\treturn -ENOBUFS;\n\n\terr = tcf_em_tree_validate(tp, tb[TCA_FLOW_EMATCHES], &fnew->ematches);\n\tif (err < 0)\n\t\tgoto err1;\n\n\terr = tcf_exts_init(&fnew->exts, net, TCA_FLOW_ACT, TCA_FLOW_POLICE);\n\tif (err < 0)\n\t\tgoto err2;\n\n\terr = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &fnew->exts, flags,\n\t\t\t\textack);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tfold = *arg;\n\tif (fold) {\n\t\terr = -EINVAL;\n\t\tif (fold->handle != handle && handle)\n\t\t\tgoto err2;\n\n\t\t \n\t\tfnew->tp = fold->tp;\n\t\tfnew->handle = fold->handle;\n\t\tfnew->nkeys = fold->nkeys;\n\t\tfnew->keymask = fold->keymask;\n\t\tfnew->mode = fold->mode;\n\t\tfnew->mask = fold->mask;\n\t\tfnew->xor = fold->xor;\n\t\tfnew->rshift = fold->rshift;\n\t\tfnew->addend = fold->addend;\n\t\tfnew->divisor = fold->divisor;\n\t\tfnew->baseclass = fold->baseclass;\n\t\tfnew->hashrnd = fold->hashrnd;\n\n\t\tmode = fold->mode;\n\t\tif (tb[TCA_FLOW_MODE])\n\t\t\tmode = nla_get_u32(tb[TCA_FLOW_MODE]);\n\t\tif (mode != FLOW_MODE_HASH && nkeys > 1)\n\t\t\tgoto err2;\n\n\t\tif (mode == FLOW_MODE_HASH)\n\t\t\tperturb_period = fold->perturb_period;\n\t\tif (tb[TCA_FLOW_PERTURB]) {\n\t\t\tif (mode != FLOW_MODE_HASH)\n\t\t\t\tgoto err2;\n\t\t\tperturb_period = nla_get_u32(tb[TCA_FLOW_PERTURB]) * HZ;\n\t\t}\n\t} else {\n\t\terr = -EINVAL;\n\t\tif (!handle)\n\t\t\tgoto err2;\n\t\tif (!tb[TCA_FLOW_KEYS])\n\t\t\tgoto err2;\n\n\t\tmode = FLOW_MODE_MAP;\n\t\tif (tb[TCA_FLOW_MODE])\n\t\t\tmode = nla_get_u32(tb[TCA_FLOW_MODE]);\n\t\tif (mode != FLOW_MODE_HASH && nkeys > 1)\n\t\t\tgoto err2;\n\n\t\tif (tb[TCA_FLOW_PERTURB]) {\n\t\t\tif (mode != FLOW_MODE_HASH)\n\t\t\t\tgoto err2;\n\t\t\tperturb_period = nla_get_u32(tb[TCA_FLOW_PERTURB]) * HZ;\n\t\t}\n\n\t\tif (TC_H_MAJ(baseclass) == 0) {\n\t\t\tstruct Qdisc *q = tcf_block_q(tp->chain->block);\n\n\t\t\tbaseclass = TC_H_MAKE(q->handle, baseclass);\n\t\t}\n\t\tif (TC_H_MIN(baseclass) == 0)\n\t\t\tbaseclass = TC_H_MAKE(baseclass, 1);\n\n\t\tfnew->handle = handle;\n\t\tfnew->mask  = ~0U;\n\t\tfnew->tp = tp;\n\t\tget_random_bytes(&fnew->hashrnd, 4);\n\t}\n\n\ttimer_setup(&fnew->perturb_timer, flow_perturbation, TIMER_DEFERRABLE);\n\n\ttcf_block_netif_keep_dst(tp->chain->block);\n\n\tif (tb[TCA_FLOW_KEYS]) {\n\t\tfnew->keymask = keymask;\n\t\tfnew->nkeys   = nkeys;\n\t}\n\n\tfnew->mode = mode;\n\n\tif (tb[TCA_FLOW_MASK])\n\t\tfnew->mask = nla_get_u32(tb[TCA_FLOW_MASK]);\n\tif (tb[TCA_FLOW_XOR])\n\t\tfnew->xor = nla_get_u32(tb[TCA_FLOW_XOR]);\n\tif (tb[TCA_FLOW_RSHIFT])\n\t\tfnew->rshift = nla_get_u32(tb[TCA_FLOW_RSHIFT]);\n\tif (tb[TCA_FLOW_ADDEND])\n\t\tfnew->addend = nla_get_u32(tb[TCA_FLOW_ADDEND]);\n\n\tif (tb[TCA_FLOW_DIVISOR])\n\t\tfnew->divisor = nla_get_u32(tb[TCA_FLOW_DIVISOR]);\n\tif (baseclass)\n\t\tfnew->baseclass = baseclass;\n\n\tfnew->perturb_period = perturb_period;\n\tif (perturb_period)\n\t\tmod_timer(&fnew->perturb_timer, jiffies + perturb_period);\n\n\tif (!*arg)\n\t\tlist_add_tail_rcu(&fnew->list, &head->filters);\n\telse\n\t\tlist_replace_rcu(&fold->list, &fnew->list);\n\n\t*arg = fnew;\n\n\tif (fold) {\n\t\ttcf_exts_get_net(&fold->exts);\n\t\ttcf_queue_work(&fold->rwork, flow_destroy_filter_work);\n\t}\n\treturn 0;\n\nerr2:\n\ttcf_exts_destroy(&fnew->exts);\n\ttcf_em_tree_destroy(&fnew->ematches);\nerr1:\n\tkfree(fnew);\n\treturn err;\n}\n\nstatic int flow_delete(struct tcf_proto *tp, void *arg, bool *last,\n\t\t       bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct flow_head *head = rtnl_dereference(tp->root);\n\tstruct flow_filter *f = arg;\n\n\tlist_del_rcu(&f->list);\n\ttcf_exts_get_net(&f->exts);\n\ttcf_queue_work(&f->rwork, flow_destroy_filter_work);\n\t*last = list_empty(&head->filters);\n\treturn 0;\n}\n\nstatic int flow_init(struct tcf_proto *tp)\n{\n\tstruct flow_head *head;\n\n\thead = kzalloc(sizeof(*head), GFP_KERNEL);\n\tif (head == NULL)\n\t\treturn -ENOBUFS;\n\tINIT_LIST_HEAD(&head->filters);\n\trcu_assign_pointer(tp->root, head);\n\treturn 0;\n}\n\nstatic void flow_destroy(struct tcf_proto *tp, bool rtnl_held,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct flow_head *head = rtnl_dereference(tp->root);\n\tstruct flow_filter *f, *next;\n\n\tlist_for_each_entry_safe(f, next, &head->filters, list) {\n\t\tlist_del_rcu(&f->list);\n\t\tif (tcf_exts_get_net(&f->exts))\n\t\t\ttcf_queue_work(&f->rwork, flow_destroy_filter_work);\n\t\telse\n\t\t\t__flow_destroy_filter(f);\n\t}\n\tkfree_rcu(head, rcu);\n}\n\nstatic void *flow_get(struct tcf_proto *tp, u32 handle)\n{\n\tstruct flow_head *head = rtnl_dereference(tp->root);\n\tstruct flow_filter *f;\n\n\tlist_for_each_entry(f, &head->filters, list)\n\t\tif (f->handle == handle)\n\t\t\treturn f;\n\treturn NULL;\n}\n\nstatic int flow_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t     struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)\n{\n\tstruct flow_filter *f = fh;\n\tstruct nlattr *nest;\n\n\tif (f == NULL)\n\t\treturn skb->len;\n\n\tt->tcm_handle = f->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, TCA_FLOW_KEYS, f->keymask) ||\n\t    nla_put_u32(skb, TCA_FLOW_MODE, f->mode))\n\t\tgoto nla_put_failure;\n\n\tif (f->mask != ~0 || f->xor != 0) {\n\t\tif (nla_put_u32(skb, TCA_FLOW_MASK, f->mask) ||\n\t\t    nla_put_u32(skb, TCA_FLOW_XOR, f->xor))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (f->rshift &&\n\t    nla_put_u32(skb, TCA_FLOW_RSHIFT, f->rshift))\n\t\tgoto nla_put_failure;\n\tif (f->addend &&\n\t    nla_put_u32(skb, TCA_FLOW_ADDEND, f->addend))\n\t\tgoto nla_put_failure;\n\n\tif (f->divisor &&\n\t    nla_put_u32(skb, TCA_FLOW_DIVISOR, f->divisor))\n\t\tgoto nla_put_failure;\n\tif (f->baseclass &&\n\t    nla_put_u32(skb, TCA_FLOW_BASECLASS, f->baseclass))\n\t\tgoto nla_put_failure;\n\n\tif (f->perturb_period &&\n\t    nla_put_u32(skb, TCA_FLOW_PERTURB, f->perturb_period / HZ))\n\t\tgoto nla_put_failure;\n\n\tif (tcf_exts_dump(skb, &f->exts) < 0)\n\t\tgoto nla_put_failure;\n#ifdef CONFIG_NET_EMATCH\n\tif (f->ematches.hdr.nmatches &&\n\t    tcf_em_tree_dump(skb, &f->ematches, TCA_FLOW_EMATCHES) < 0)\n\t\tgoto nla_put_failure;\n#endif\n\tnla_nest_end(skb, nest);\n\n\tif (tcf_exts_dump_stats(skb, &f->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic void flow_walk(struct tcf_proto *tp, struct tcf_walker *arg,\n\t\t      bool rtnl_held)\n{\n\tstruct flow_head *head = rtnl_dereference(tp->root);\n\tstruct flow_filter *f;\n\n\tlist_for_each_entry(f, &head->filters, list) {\n\t\tif (!tc_cls_stats_dump(tp, arg, f))\n\t\t\tbreak;\n\t}\n}\n\nstatic struct tcf_proto_ops cls_flow_ops __read_mostly = {\n\t.kind\t\t= \"flow\",\n\t.classify\t= flow_classify,\n\t.init\t\t= flow_init,\n\t.destroy\t= flow_destroy,\n\t.change\t\t= flow_change,\n\t.delete\t\t= flow_delete,\n\t.get\t\t= flow_get,\n\t.dump\t\t= flow_dump,\n\t.walk\t\t= flow_walk,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init cls_flow_init(void)\n{\n\treturn register_tcf_proto_ops(&cls_flow_ops);\n}\n\nstatic void __exit cls_flow_exit(void)\n{\n\tunregister_tcf_proto_ops(&cls_flow_ops);\n}\n\nmodule_init(cls_flow_init);\nmodule_exit(cls_flow_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_DESCRIPTION(\"TC flow classifier\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}