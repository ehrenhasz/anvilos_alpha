{
  "module_name": "em_canid.c",
  "hash_id": "2b255df6e2992d1b737e3cbf541dfe47034b17ff554c92f5d1f8293bf78077b6",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/em_canid.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <net/pkt_cls.h>\n#include <linux/can.h>\n\n#define EM_CAN_RULES_MAX 500\n\nstruct canid_match {\n\t \n\tDECLARE_BITMAP(match_sff, (1 << CAN_SFF_ID_BITS));\n\n\tint rules_count;\n\tint sff_rules_count;\n\tint eff_rules_count;\n\n\t \n\tstruct can_filter rules_raw[];\n};\n\n \nstatic canid_t em_canid_get_id(struct sk_buff *skb)\n{\n\t \n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\n\treturn cf->can_id;\n}\n\nstatic void em_canid_sff_match_add(struct canid_match *cm, u32 can_id,\n\t\t\t\t\tu32 can_mask)\n{\n\tint i;\n\n\t \n\tcan_mask &= CAN_SFF_MASK;\n\tcan_id &= can_mask;\n\n\t \n\tif (can_mask == CAN_SFF_MASK) {\n\t\tset_bit(can_id, cm->match_sff);\n\t\treturn;\n\t}\n\n\t \n\tif (can_mask == 0) {\n\t\tbitmap_fill(cm->match_sff, (1 << CAN_SFF_ID_BITS));\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < (1 << CAN_SFF_ID_BITS); i++) {\n\t\tif ((i & can_mask) == can_id)\n\t\t\tset_bit(i, cm->match_sff);\n\t}\n}\n\nstatic inline struct canid_match *em_canid_priv(struct tcf_ematch *m)\n{\n\treturn (struct canid_match *)m->data;\n}\n\nstatic int em_canid_match(struct sk_buff *skb, struct tcf_ematch *m,\n\t\t\t struct tcf_pkt_info *info)\n{\n\tstruct canid_match *cm = em_canid_priv(m);\n\tcanid_t can_id;\n\tint match = 0;\n\tint i;\n\tconst struct can_filter *lp;\n\n\tcan_id = em_canid_get_id(skb);\n\n\tif (can_id & CAN_EFF_FLAG) {\n\t\tfor (i = 0, lp = cm->rules_raw;\n\t\t     i < cm->eff_rules_count; i++, lp++) {\n\t\t\tif (!(((lp->can_id ^ can_id) & lp->can_mask))) {\n\t\t\t\tmatch = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {  \n\t\tcan_id &= CAN_SFF_MASK;\n\t\tmatch = (test_bit(can_id, cm->match_sff) ? 1 : 0);\n\t}\n\n\treturn match;\n}\n\nstatic int em_canid_change(struct net *net, void *data, int len,\n\t\t\t  struct tcf_ematch *m)\n{\n\tstruct can_filter *conf = data;  \n\tstruct canid_match *cm;\n\tint i;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (len % sizeof(struct can_filter))\n\t\treturn -EINVAL;\n\n\tif (len > sizeof(struct can_filter) * EM_CAN_RULES_MAX)\n\t\treturn -EINVAL;\n\n\tcm = kzalloc(sizeof(struct canid_match) + len, GFP_KERNEL);\n\tif (!cm)\n\t\treturn -ENOMEM;\n\n\tcm->rules_count = len / sizeof(struct can_filter);\n\n\t \n\n\t \n\tfor (i = 0; i < cm->rules_count; i++) {\n\t\tif (conf[i].can_id & CAN_EFF_FLAG) {\n\t\t\tmemcpy(cm->rules_raw + cm->eff_rules_count,\n\t\t\t\t&conf[i],\n\t\t\t\tsizeof(struct can_filter));\n\n\t\t\tcm->eff_rules_count++;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < cm->rules_count; i++) {\n\t\tif (!(conf[i].can_id & CAN_EFF_FLAG)) {\n\t\t\tmemcpy(cm->rules_raw\n\t\t\t\t+ cm->eff_rules_count\n\t\t\t\t+ cm->sff_rules_count,\n\t\t\t\t&conf[i], sizeof(struct can_filter));\n\n\t\t\tcm->sff_rules_count++;\n\n\t\t\tem_canid_sff_match_add(cm,\n\t\t\t\tconf[i].can_id, conf[i].can_mask);\n\t\t}\n\t}\n\n\tm->datalen = sizeof(struct canid_match) + len;\n\tm->data = (unsigned long)cm;\n\treturn 0;\n}\n\nstatic void em_canid_destroy(struct tcf_ematch *m)\n{\n\tstruct canid_match *cm = em_canid_priv(m);\n\n\tkfree(cm);\n}\n\nstatic int em_canid_dump(struct sk_buff *skb, struct tcf_ematch *m)\n{\n\tstruct canid_match *cm = em_canid_priv(m);\n\n\t \n\tif (nla_put_nohdr(skb, sizeof(struct can_filter) * cm->rules_count,\n\t    &cm->rules_raw) < 0)\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic struct tcf_ematch_ops em_canid_ops = {\n\t.kind\t  = TCF_EM_CANID,\n\t.change\t  = em_canid_change,\n\t.match\t  = em_canid_match,\n\t.destroy  = em_canid_destroy,\n\t.dump\t  = em_canid_dump,\n\t.owner\t  = THIS_MODULE,\n\t.link\t  = LIST_HEAD_INIT(em_canid_ops.link)\n};\n\nstatic int __init init_em_canid(void)\n{\n\treturn tcf_em_register(&em_canid_ops);\n}\n\nstatic void __exit exit_em_canid(void)\n{\n\ttcf_em_unregister(&em_canid_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(init_em_canid);\nmodule_exit(exit_em_canid);\n\nMODULE_ALIAS_TCF_EMATCH(TCF_EM_CANID);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}