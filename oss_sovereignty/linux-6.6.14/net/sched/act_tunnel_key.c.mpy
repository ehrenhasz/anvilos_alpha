{
  "module_name": "act_tunnel_key.c",
  "hash_id": "ea4b52e0bed9bfd7c3d51fd6a5b13627ece4fc4c5eadbbfca52064b7c3101500",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_tunnel_key.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <net/geneve.h>\n#include <net/vxlan.h>\n#include <net/erspan.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/dst.h>\n#include <net/pkt_cls.h>\n#include <net/tc_wrapper.h>\n\n#include <linux/tc_act/tc_tunnel_key.h>\n#include <net/tc_act/tc_tunnel_key.h>\n\nstatic struct tc_action_ops act_tunnel_key_ops;\n\nTC_INDIRECT_SCOPE int tunnel_key_act(struct sk_buff *skb,\n\t\t\t\t     const struct tc_action *a,\n\t\t\t\t     struct tcf_result *res)\n{\n\tstruct tcf_tunnel_key *t = to_tunnel_key(a);\n\tstruct tcf_tunnel_key_params *params;\n\tint action;\n\n\tparams = rcu_dereference_bh(t->params);\n\n\ttcf_lastuse_update(&t->tcf_tm);\n\ttcf_action_update_bstats(&t->common, skb);\n\taction = READ_ONCE(t->tcf_action);\n\n\tswitch (params->tcft_action) {\n\tcase TCA_TUNNEL_KEY_ACT_RELEASE:\n\t\tskb_dst_drop(skb);\n\t\tbreak;\n\tcase TCA_TUNNEL_KEY_ACT_SET:\n\t\tskb_dst_drop(skb);\n\t\tskb_dst_set(skb, dst_clone(&params->tcft_enc_metadata->dst));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Bad tunnel_key action %d.\\n\",\n\t\t\t  params->tcft_action);\n\t\tbreak;\n\t}\n\n\treturn action;\n}\n\nstatic const struct nla_policy\nenc_opts_policy[TCA_TUNNEL_KEY_ENC_OPTS_MAX + 1] = {\n\t[TCA_TUNNEL_KEY_ENC_OPTS_UNSPEC]\t= {\n\t\t.strict_start_type = TCA_TUNNEL_KEY_ENC_OPTS_VXLAN },\n\t[TCA_TUNNEL_KEY_ENC_OPTS_GENEVE]\t= { .type = NLA_NESTED },\n\t[TCA_TUNNEL_KEY_ENC_OPTS_VXLAN]\t\t= { .type = NLA_NESTED },\n\t[TCA_TUNNEL_KEY_ENC_OPTS_ERSPAN]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\ngeneve_opt_policy[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_MAX + 1] = {\n\t[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS]\t   = { .type = NLA_U16 },\n\t[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE]\t   = { .type = NLA_U8 },\n\t[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA]\t   = { .type = NLA_BINARY,\n\t\t\t\t\t\t       .len = 128 },\n};\n\nstatic const struct nla_policy\nvxlan_opt_policy[TCA_TUNNEL_KEY_ENC_OPT_VXLAN_MAX + 1] = {\n\t[TCA_TUNNEL_KEY_ENC_OPT_VXLAN_GBP]\t   = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nerspan_opt_policy[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_MAX + 1] = {\n\t[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_VER]\t   = { .type = NLA_U8 },\n\t[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_INDEX]\t   = { .type = NLA_U32 },\n\t[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_DIR]\t   = { .type = NLA_U8 },\n\t[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_HWID]\t   = { .type = NLA_U8 },\n};\n\nstatic int\ntunnel_key_copy_geneve_opt(const struct nlattr *nla, void *dst, int dst_len,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_MAX + 1];\n\tint err, data_len, opt_len;\n\tu8 *data;\n\n\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t  TCA_TUNNEL_KEY_ENC_OPT_GENEVE_MAX,\n\t\t\t\t\t  nla, geneve_opt_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS] ||\n\t    !tb[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE] ||\n\t    !tb[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA]) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key geneve option class, type or data\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = nla_data(tb[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA]);\n\tdata_len = nla_len(tb[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA]);\n\tif (data_len < 4) {\n\t\tNL_SET_ERR_MSG(extack, \"Tunnel key geneve option data is less than 4 bytes long\");\n\t\treturn -ERANGE;\n\t}\n\tif (data_len % 4) {\n\t\tNL_SET_ERR_MSG(extack, \"Tunnel key geneve option data is not a multiple of 4 bytes long\");\n\t\treturn -ERANGE;\n\t}\n\n\topt_len = sizeof(struct geneve_opt) + data_len;\n\tif (dst) {\n\t\tstruct geneve_opt *opt = dst;\n\n\t\tWARN_ON(dst_len < opt_len);\n\n\t\topt->opt_class =\n\t\t\tnla_get_be16(tb[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS]);\n\t\topt->type = nla_get_u8(tb[TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE]);\n\t\topt->length = data_len / 4;  \n\t\topt->r1 = 0;\n\t\topt->r2 = 0;\n\t\topt->r3 = 0;\n\n\t\tmemcpy(opt + 1, data, data_len);\n\t}\n\n\treturn opt_len;\n}\n\nstatic int\ntunnel_key_copy_vxlan_opt(const struct nlattr *nla, void *dst, int dst_len,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_TUNNEL_KEY_ENC_OPT_VXLAN_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, TCA_TUNNEL_KEY_ENC_OPT_VXLAN_MAX, nla,\n\t\t\t       vxlan_opt_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_TUNNEL_KEY_ENC_OPT_VXLAN_GBP]) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key vxlan option gbp\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dst) {\n\t\tstruct vxlan_metadata *md = dst;\n\n\t\tmd->gbp = nla_get_u32(tb[TCA_TUNNEL_KEY_ENC_OPT_VXLAN_GBP]);\n\t\tmd->gbp &= VXLAN_GBP_MASK;\n\t}\n\n\treturn sizeof(struct vxlan_metadata);\n}\n\nstatic int\ntunnel_key_copy_erspan_opt(const struct nlattr *nla, void *dst, int dst_len,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_MAX + 1];\n\tint err;\n\tu8 ver;\n\n\terr = nla_parse_nested(tb, TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_MAX, nla,\n\t\t\t       erspan_opt_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_VER]) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key erspan option ver\");\n\t\treturn -EINVAL;\n\t}\n\n\tver = nla_get_u8(tb[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_VER]);\n\tif (ver == 1) {\n\t\tif (!tb[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_INDEX]) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key erspan option index\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (ver == 2) {\n\t\tif (!tb[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_DIR] ||\n\t\t    !tb[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_HWID]) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key erspan option dir or hwid\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tNL_SET_ERR_MSG(extack, \"Tunnel key erspan option ver is incorrect\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dst) {\n\t\tstruct erspan_metadata *md = dst;\n\n\t\tmd->version = ver;\n\t\tif (ver == 1) {\n\t\t\tnla = tb[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_INDEX];\n\t\t\tmd->u.index = nla_get_be32(nla);\n\t\t} else {\n\t\t\tnla = tb[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_DIR];\n\t\t\tmd->u.md2.dir = nla_get_u8(nla);\n\t\t\tnla = tb[TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_HWID];\n\t\t\tset_hwid(&md->u.md2, nla_get_u8(nla));\n\t\t}\n\t}\n\n\treturn sizeof(struct erspan_metadata);\n}\n\nstatic int tunnel_key_copy_opts(const struct nlattr *nla, u8 *dst,\n\t\t\t\tint dst_len, struct netlink_ext_ack *extack)\n{\n\tint err, rem, opt_len, len = nla_len(nla), opts_len = 0, type = 0;\n\tconst struct nlattr *attr, *head = nla_data(nla);\n\n\terr = nla_validate_deprecated(head, len, TCA_TUNNEL_KEY_ENC_OPTS_MAX,\n\t\t\t\t      enc_opts_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tnla_for_each_attr(attr, head, len, rem) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase TCA_TUNNEL_KEY_ENC_OPTS_GENEVE:\n\t\t\tif (type && type != TUNNEL_GENEVE_OPT) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Duplicate type for geneve options\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\topt_len = tunnel_key_copy_geneve_opt(attr, dst,\n\t\t\t\t\t\t\t     dst_len, extack);\n\t\t\tif (opt_len < 0)\n\t\t\t\treturn opt_len;\n\t\t\topts_len += opt_len;\n\t\t\tif (opts_len > IP_TUNNEL_OPTS_MAX) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Tunnel options exceeds max size\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (dst) {\n\t\t\t\tdst_len -= opt_len;\n\t\t\t\tdst += opt_len;\n\t\t\t}\n\t\t\ttype = TUNNEL_GENEVE_OPT;\n\t\t\tbreak;\n\t\tcase TCA_TUNNEL_KEY_ENC_OPTS_VXLAN:\n\t\t\tif (type) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Duplicate type for vxlan options\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\topt_len = tunnel_key_copy_vxlan_opt(attr, dst,\n\t\t\t\t\t\t\t    dst_len, extack);\n\t\t\tif (opt_len < 0)\n\t\t\t\treturn opt_len;\n\t\t\topts_len += opt_len;\n\t\t\ttype = TUNNEL_VXLAN_OPT;\n\t\t\tbreak;\n\t\tcase TCA_TUNNEL_KEY_ENC_OPTS_ERSPAN:\n\t\t\tif (type) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Duplicate type for erspan options\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\topt_len = tunnel_key_copy_erspan_opt(attr, dst,\n\t\t\t\t\t\t\t     dst_len, extack);\n\t\t\tif (opt_len < 0)\n\t\t\t\treturn opt_len;\n\t\t\topts_len += opt_len;\n\t\t\ttype = TUNNEL_ERSPAN_OPT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!opts_len) {\n\t\tNL_SET_ERR_MSG(extack, \"Empty list of tunnel options\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rem > 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Trailing data after parsing tunnel key options attributes\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn opts_len;\n}\n\nstatic int tunnel_key_get_opts_len(struct nlattr *nla,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\treturn tunnel_key_copy_opts(nla, NULL, 0, extack);\n}\n\nstatic int tunnel_key_opts_set(struct nlattr *nla, struct ip_tunnel_info *info,\n\t\t\t       int opts_len, struct netlink_ext_ack *extack)\n{\n\tinfo->options_len = opts_len;\n\tswitch (nla_type(nla_data(nla))) {\n\tcase TCA_TUNNEL_KEY_ENC_OPTS_GENEVE:\n#if IS_ENABLED(CONFIG_INET)\n\t\tinfo->key.tun_flags |= TUNNEL_GENEVE_OPT;\n\t\treturn tunnel_key_copy_opts(nla, ip_tunnel_info_opts(info),\n\t\t\t\t\t    opts_len, extack);\n#else\n\t\treturn -EAFNOSUPPORT;\n#endif\n\tcase TCA_TUNNEL_KEY_ENC_OPTS_VXLAN:\n#if IS_ENABLED(CONFIG_INET)\n\t\tinfo->key.tun_flags |= TUNNEL_VXLAN_OPT;\n\t\treturn tunnel_key_copy_opts(nla, ip_tunnel_info_opts(info),\n\t\t\t\t\t    opts_len, extack);\n#else\n\t\treturn -EAFNOSUPPORT;\n#endif\n\tcase TCA_TUNNEL_KEY_ENC_OPTS_ERSPAN:\n#if IS_ENABLED(CONFIG_INET)\n\t\tinfo->key.tun_flags |= TUNNEL_ERSPAN_OPT;\n\t\treturn tunnel_key_copy_opts(nla, ip_tunnel_info_opts(info),\n\t\t\t\t\t    opts_len, extack);\n#else\n\t\treturn -EAFNOSUPPORT;\n#endif\n\tdefault:\n\t\tNL_SET_ERR_MSG(extack, \"Cannot set tunnel options for unknown tunnel type\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct nla_policy tunnel_key_policy[TCA_TUNNEL_KEY_MAX + 1] = {\n\t[TCA_TUNNEL_KEY_PARMS]\t    = { .len = sizeof(struct tc_tunnel_key) },\n\t[TCA_TUNNEL_KEY_ENC_IPV4_SRC] = { .type = NLA_U32 },\n\t[TCA_TUNNEL_KEY_ENC_IPV4_DST] = { .type = NLA_U32 },\n\t[TCA_TUNNEL_KEY_ENC_IPV6_SRC] = { .len = sizeof(struct in6_addr) },\n\t[TCA_TUNNEL_KEY_ENC_IPV6_DST] = { .len = sizeof(struct in6_addr) },\n\t[TCA_TUNNEL_KEY_ENC_KEY_ID]   = { .type = NLA_U32 },\n\t[TCA_TUNNEL_KEY_ENC_DST_PORT] = {.type = NLA_U16},\n\t[TCA_TUNNEL_KEY_NO_CSUM]      = { .type = NLA_U8 },\n\t[TCA_TUNNEL_KEY_ENC_OPTS]     = { .type = NLA_NESTED },\n\t[TCA_TUNNEL_KEY_ENC_TOS]      = { .type = NLA_U8 },\n\t[TCA_TUNNEL_KEY_ENC_TTL]      = { .type = NLA_U8 },\n};\n\nstatic void tunnel_key_release_params(struct tcf_tunnel_key_params *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->tcft_action == TCA_TUNNEL_KEY_ACT_SET)\n\t\tdst_release(&p->tcft_enc_metadata->dst);\n\n\tkfree_rcu(p, rcu);\n}\n\nstatic int tunnel_key_init(struct net *net, struct nlattr *nla,\n\t\t\t   struct nlattr *est, struct tc_action **a,\n\t\t\t   struct tcf_proto *tp, u32 act_flags,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_tunnel_key_ops.net_id);\n\tbool bind = act_flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_TUNNEL_KEY_MAX + 1];\n\tstruct tcf_tunnel_key_params *params_new;\n\tstruct metadata_dst *metadata = NULL;\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tc_tunnel_key *parm;\n\tstruct tcf_tunnel_key *t;\n\tbool exists = false;\n\t__be16 dst_port = 0;\n\t__be64 key_id = 0;\n\tint opts_len = 0;\n\t__be16 flags = 0;\n\tu8 tos, ttl;\n\tint ret = 0;\n\tu32 index;\n\tint err;\n\n\tif (!nla) {\n\t\tNL_SET_ERR_MSG(extack, \"Tunnel requires attributes to be passed\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, TCA_TUNNEL_KEY_MAX, nla,\n\t\t\t\t\t  tunnel_key_policy, extack);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to parse nested tunnel key attributes\");\n\t\treturn err;\n\t}\n\n\tif (!tb[TCA_TUNNEL_KEY_PARMS]) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing tunnel key parameters\");\n\t\treturn -EINVAL;\n\t}\n\n\tparm = nla_data(tb[TCA_TUNNEL_KEY_PARMS]);\n\tindex = parm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0)\n\t\treturn err;\n\texists = err;\n\tif (exists && bind)\n\t\treturn 0;\n\n\tswitch (parm->t_action) {\n\tcase TCA_TUNNEL_KEY_ACT_RELEASE:\n\t\tbreak;\n\tcase TCA_TUNNEL_KEY_ACT_SET:\n\t\tif (tb[TCA_TUNNEL_KEY_ENC_KEY_ID]) {\n\t\t\t__be32 key32;\n\n\t\t\tkey32 = nla_get_be32(tb[TCA_TUNNEL_KEY_ENC_KEY_ID]);\n\t\t\tkey_id = key32_to_tunnel_id(key32);\n\t\t\tflags = TUNNEL_KEY;\n\t\t}\n\n\t\tflags |= TUNNEL_CSUM;\n\t\tif (tb[TCA_TUNNEL_KEY_NO_CSUM] &&\n\t\t    nla_get_u8(tb[TCA_TUNNEL_KEY_NO_CSUM]))\n\t\t\tflags &= ~TUNNEL_CSUM;\n\n\t\tif (nla_get_flag(tb[TCA_TUNNEL_KEY_NO_FRAG]))\n\t\t\tflags |= TUNNEL_DONT_FRAGMENT;\n\n\t\tif (tb[TCA_TUNNEL_KEY_ENC_DST_PORT])\n\t\t\tdst_port = nla_get_be16(tb[TCA_TUNNEL_KEY_ENC_DST_PORT]);\n\n\t\tif (tb[TCA_TUNNEL_KEY_ENC_OPTS]) {\n\t\t\topts_len = tunnel_key_get_opts_len(tb[TCA_TUNNEL_KEY_ENC_OPTS],\n\t\t\t\t\t\t\t   extack);\n\t\t\tif (opts_len < 0) {\n\t\t\t\tret = opts_len;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\n\t\ttos = 0;\n\t\tif (tb[TCA_TUNNEL_KEY_ENC_TOS])\n\t\t\ttos = nla_get_u8(tb[TCA_TUNNEL_KEY_ENC_TOS]);\n\t\tttl = 0;\n\t\tif (tb[TCA_TUNNEL_KEY_ENC_TTL])\n\t\t\tttl = nla_get_u8(tb[TCA_TUNNEL_KEY_ENC_TTL]);\n\n\t\tif (tb[TCA_TUNNEL_KEY_ENC_IPV4_SRC] &&\n\t\t    tb[TCA_TUNNEL_KEY_ENC_IPV4_DST]) {\n\t\t\t__be32 saddr;\n\t\t\t__be32 daddr;\n\n\t\t\tsaddr = nla_get_in_addr(tb[TCA_TUNNEL_KEY_ENC_IPV4_SRC]);\n\t\t\tdaddr = nla_get_in_addr(tb[TCA_TUNNEL_KEY_ENC_IPV4_DST]);\n\n\t\t\tmetadata = __ip_tun_set_dst(saddr, daddr, tos, ttl,\n\t\t\t\t\t\t    dst_port, flags,\n\t\t\t\t\t\t    key_id, opts_len);\n\t\t} else if (tb[TCA_TUNNEL_KEY_ENC_IPV6_SRC] &&\n\t\t\t   tb[TCA_TUNNEL_KEY_ENC_IPV6_DST]) {\n\t\t\tstruct in6_addr saddr;\n\t\t\tstruct in6_addr daddr;\n\n\t\t\tsaddr = nla_get_in6_addr(tb[TCA_TUNNEL_KEY_ENC_IPV6_SRC]);\n\t\t\tdaddr = nla_get_in6_addr(tb[TCA_TUNNEL_KEY_ENC_IPV6_DST]);\n\n\t\t\tmetadata = __ipv6_tun_set_dst(&saddr, &daddr, tos, ttl, dst_port,\n\t\t\t\t\t\t      0, flags,\n\t\t\t\t\t\t      key_id, opts_len);\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"Missing either ipv4 or ipv6 src and dst\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (!metadata) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot allocate tunnel metadata dst\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n#ifdef CONFIG_DST_CACHE\n\t\tret = dst_cache_init(&metadata->u.tun_info.dst_cache, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tgoto release_tun_meta;\n#endif\n\n\t\tif (opts_len) {\n\t\t\tret = tunnel_key_opts_set(tb[TCA_TUNNEL_KEY_ENC_OPTS],\n\t\t\t\t\t\t  &metadata->u.tun_info,\n\t\t\t\t\t\t  opts_len, extack);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto release_tun_meta;\n\t\t}\n\n\t\tmetadata->u.tun_info.mode |= IP_TUNNEL_INFO_TX;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG(extack, \"Unknown tunnel key action\");\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (!exists) {\n\t\tret = tcf_idr_create_from_flags(tn, index, est, a,\n\t\t\t\t\t\t&act_tunnel_key_ops, bind,\n\t\t\t\t\t\tact_flags);\n\t\tif (ret) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot create TC IDR\");\n\t\t\tgoto release_tun_meta;\n\t\t}\n\n\t\tret = ACT_P_CREATED;\n\t} else if (!(act_flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\tNL_SET_ERR_MSG(extack, \"TC IDR already exists\");\n\t\tret = -EEXIST;\n\t\tgoto release_tun_meta;\n\t}\n\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0) {\n\t\tret = err;\n\t\texists = true;\n\t\tgoto release_tun_meta;\n\t}\n\tt = to_tunnel_key(*a);\n\n\tparams_new = kzalloc(sizeof(*params_new), GFP_KERNEL);\n\tif (unlikely(!params_new)) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot allocate tunnel key parameters\");\n\t\tret = -ENOMEM;\n\t\texists = true;\n\t\tgoto put_chain;\n\t}\n\tparams_new->tcft_action = parm->t_action;\n\tparams_new->tcft_enc_metadata = metadata;\n\n\tspin_lock_bh(&t->tcf_lock);\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\tparams_new = rcu_replace_pointer(t->params, params_new,\n\t\t\t\t\t lockdep_is_held(&t->tcf_lock));\n\tspin_unlock_bh(&t->tcf_lock);\n\ttunnel_key_release_params(params_new);\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\n\treturn ret;\n\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\nrelease_tun_meta:\n\tif (metadata)\n\t\tdst_release(&metadata->dst);\n\nerr_out:\n\tif (exists)\n\t\ttcf_idr_release(*a, bind);\n\telse\n\t\ttcf_idr_cleanup(tn, index);\n\treturn ret;\n}\n\nstatic void tunnel_key_release(struct tc_action *a)\n{\n\tstruct tcf_tunnel_key *t = to_tunnel_key(a);\n\tstruct tcf_tunnel_key_params *params;\n\n\tparams = rcu_dereference_protected(t->params, 1);\n\ttunnel_key_release_params(params);\n}\n\nstatic int tunnel_key_geneve_opts_dump(struct sk_buff *skb,\n\t\t\t\t       const struct ip_tunnel_info *info)\n{\n\tint len = info->options_len;\n\tu8 *src = (u8 *)(info + 1);\n\tstruct nlattr *start;\n\n\tstart = nla_nest_start_noflag(skb, TCA_TUNNEL_KEY_ENC_OPTS_GENEVE);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\twhile (len > 0) {\n\t\tstruct geneve_opt *opt = (struct geneve_opt *)src;\n\n\t\tif (nla_put_be16(skb, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS,\n\t\t\t\t opt->opt_class) ||\n\t\t    nla_put_u8(skb, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE,\n\t\t\t       opt->type) ||\n\t\t    nla_put(skb, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA,\n\t\t\t    opt->length * 4, opt + 1)) {\n\t\t\tnla_nest_cancel(skb, start);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tlen -= sizeof(struct geneve_opt) + opt->length * 4;\n\t\tsrc += sizeof(struct geneve_opt) + opt->length * 4;\n\t}\n\n\tnla_nest_end(skb, start);\n\treturn 0;\n}\n\nstatic int tunnel_key_vxlan_opts_dump(struct sk_buff *skb,\n\t\t\t\t      const struct ip_tunnel_info *info)\n{\n\tstruct vxlan_metadata *md = (struct vxlan_metadata *)(info + 1);\n\tstruct nlattr *start;\n\n\tstart = nla_nest_start_noflag(skb, TCA_TUNNEL_KEY_ENC_OPTS_VXLAN);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, TCA_TUNNEL_KEY_ENC_OPT_VXLAN_GBP, md->gbp)) {\n\t\tnla_nest_cancel(skb, start);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnla_nest_end(skb, start);\n\treturn 0;\n}\n\nstatic int tunnel_key_erspan_opts_dump(struct sk_buff *skb,\n\t\t\t\t       const struct ip_tunnel_info *info)\n{\n\tstruct erspan_metadata *md = (struct erspan_metadata *)(info + 1);\n\tstruct nlattr *start;\n\n\tstart = nla_nest_start_noflag(skb, TCA_TUNNEL_KEY_ENC_OPTS_ERSPAN);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(skb, TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_VER, md->version))\n\t\tgoto err;\n\n\tif (md->version == 1 &&\n\t    nla_put_be32(skb, TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_INDEX, md->u.index))\n\t\tgoto err;\n\n\tif (md->version == 2 &&\n\t    (nla_put_u8(skb, TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_DIR,\n\t\t\tmd->u.md2.dir) ||\n\t     nla_put_u8(skb, TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_HWID,\n\t\t\tget_hwid(&md->u.md2))))\n\t\tgoto err;\n\n\tnla_nest_end(skb, start);\n\treturn 0;\nerr:\n\tnla_nest_cancel(skb, start);\n\treturn -EMSGSIZE;\n}\n\nstatic int tunnel_key_opts_dump(struct sk_buff *skb,\n\t\t\t\tconst struct ip_tunnel_info *info)\n{\n\tstruct nlattr *start;\n\tint err = -EINVAL;\n\n\tif (!info->options_len)\n\t\treturn 0;\n\n\tstart = nla_nest_start_noflag(skb, TCA_TUNNEL_KEY_ENC_OPTS);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\tif (info->key.tun_flags & TUNNEL_GENEVE_OPT) {\n\t\terr = tunnel_key_geneve_opts_dump(skb, info);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else if (info->key.tun_flags & TUNNEL_VXLAN_OPT) {\n\t\terr = tunnel_key_vxlan_opts_dump(skb, info);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else if (info->key.tun_flags & TUNNEL_ERSPAN_OPT) {\n\t\terr = tunnel_key_erspan_opts_dump(skb, info);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else {\nerr_out:\n\t\tnla_nest_cancel(skb, start);\n\t\treturn err;\n\t}\n\n\tnla_nest_end(skb, start);\n\treturn 0;\n}\n\nstatic int tunnel_key_dump_addresses(struct sk_buff *skb,\n\t\t\t\t     const struct ip_tunnel_info *info)\n{\n\tunsigned short family = ip_tunnel_info_af(info);\n\n\tif (family == AF_INET) {\n\t\t__be32 saddr = info->key.u.ipv4.src;\n\t\t__be32 daddr = info->key.u.ipv4.dst;\n\n\t\tif (!nla_put_in_addr(skb, TCA_TUNNEL_KEY_ENC_IPV4_SRC, saddr) &&\n\t\t    !nla_put_in_addr(skb, TCA_TUNNEL_KEY_ENC_IPV4_DST, daddr))\n\t\t\treturn 0;\n\t}\n\n\tif (family == AF_INET6) {\n\t\tconst struct in6_addr *saddr6 = &info->key.u.ipv6.src;\n\t\tconst struct in6_addr *daddr6 = &info->key.u.ipv6.dst;\n\n\t\tif (!nla_put_in6_addr(skb,\n\t\t\t\t      TCA_TUNNEL_KEY_ENC_IPV6_SRC, saddr6) &&\n\t\t    !nla_put_in6_addr(skb,\n\t\t\t\t      TCA_TUNNEL_KEY_ENC_IPV6_DST, daddr6))\n\t\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tunnel_key_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_tunnel_key *t = to_tunnel_key(a);\n\tstruct tcf_tunnel_key_params *params;\n\tstruct tc_tunnel_key opt = {\n\t\t.index    = t->tcf_index,\n\t\t.refcnt   = refcount_read(&t->tcf_refcnt) - ref,\n\t\t.bindcnt  = atomic_read(&t->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t tm;\n\n\tspin_lock_bh(&t->tcf_lock);\n\tparams = rcu_dereference_protected(t->params,\n\t\t\t\t\t   lockdep_is_held(&t->tcf_lock));\n\topt.action   = t->tcf_action;\n\topt.t_action = params->tcft_action;\n\n\tif (nla_put(skb, TCA_TUNNEL_KEY_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\tif (params->tcft_action == TCA_TUNNEL_KEY_ACT_SET) {\n\t\tstruct ip_tunnel_info *info =\n\t\t\t&params->tcft_enc_metadata->u.tun_info;\n\t\tstruct ip_tunnel_key *key = &info->key;\n\t\t__be32 key_id = tunnel_id_to_key32(key->tun_id);\n\n\t\tif (((key->tun_flags & TUNNEL_KEY) &&\n\t\t     nla_put_be32(skb, TCA_TUNNEL_KEY_ENC_KEY_ID, key_id)) ||\n\t\t    tunnel_key_dump_addresses(skb,\n\t\t\t\t\t      &params->tcft_enc_metadata->u.tun_info) ||\n\t\t    (key->tp_dst &&\n\t\t      nla_put_be16(skb, TCA_TUNNEL_KEY_ENC_DST_PORT,\n\t\t\t\t   key->tp_dst)) ||\n\t\t    nla_put_u8(skb, TCA_TUNNEL_KEY_NO_CSUM,\n\t\t\t       !(key->tun_flags & TUNNEL_CSUM)) ||\n\t\t    ((key->tun_flags & TUNNEL_DONT_FRAGMENT) &&\n\t\t     nla_put_flag(skb, TCA_TUNNEL_KEY_NO_FRAG)) ||\n\t\t    tunnel_key_opts_dump(skb, info))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (key->tos && nla_put_u8(skb, TCA_TUNNEL_KEY_ENC_TOS, key->tos))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (key->ttl && nla_put_u8(skb, TCA_TUNNEL_KEY_ENC_TTL, key->ttl))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\ttcf_tm_dump(&tm, &t->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_TUNNEL_KEY_TM, sizeof(tm),\n\t\t\t  &tm, TCA_TUNNEL_KEY_PAD))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&t->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&t->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic void tcf_tunnel_encap_put_tunnel(void *priv)\n{\n\tstruct ip_tunnel_info *tunnel = priv;\n\n\tkfree(tunnel);\n}\n\nstatic int tcf_tunnel_encap_get_tunnel(struct flow_action_entry *entry,\n\t\t\t\t       const struct tc_action *act)\n{\n\tentry->tunnel = tcf_tunnel_info_copy(act);\n\tif (!entry->tunnel)\n\t\treturn -ENOMEM;\n\tentry->destructor = tcf_tunnel_encap_put_tunnel;\n\tentry->destructor_priv = entry->tunnel;\n\treturn 0;\n}\n\nstatic int tcf_tunnel_key_offload_act_setup(struct tc_action *act,\n\t\t\t\t\t    void *entry_data,\n\t\t\t\t\t    u32 *index_inc,\n\t\t\t\t\t    bool bind,\n\t\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tif (bind) {\n\t\tstruct flow_action_entry *entry = entry_data;\n\n\t\tif (is_tcf_tunnel_set(act)) {\n\t\t\tentry->id = FLOW_ACTION_TUNNEL_ENCAP;\n\t\t\terr = tcf_tunnel_encap_get_tunnel(entry, act);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (is_tcf_tunnel_release(act)) {\n\t\t\tentry->id = FLOW_ACTION_TUNNEL_DECAP;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported tunnel key mode offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t*index_inc = 1;\n\t} else {\n\t\tstruct flow_offload_action *fl_action = entry_data;\n\n\t\tif (is_tcf_tunnel_set(act))\n\t\t\tfl_action->id = FLOW_ACTION_TUNNEL_ENCAP;\n\t\telse if (is_tcf_tunnel_release(act))\n\t\t\tfl_action->id = FLOW_ACTION_TUNNEL_DECAP;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic struct tc_action_ops act_tunnel_key_ops = {\n\t.kind\t\t=\t\"tunnel_key\",\n\t.id\t\t=\tTCA_ID_TUNNEL_KEY,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttunnel_key_act,\n\t.dump\t\t=\ttunnel_key_dump,\n\t.init\t\t=\ttunnel_key_init,\n\t.cleanup\t=\ttunnel_key_release,\n\t.offload_act_setup =\ttcf_tunnel_key_offload_act_setup,\n\t.size\t\t=\tsizeof(struct tcf_tunnel_key),\n};\n\nstatic __net_init int tunnel_key_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_tunnel_key_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_tunnel_key_ops);\n}\n\nstatic void __net_exit tunnel_key_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_tunnel_key_ops.net_id);\n}\n\nstatic struct pernet_operations tunnel_key_net_ops = {\n\t.init = tunnel_key_init_net,\n\t.exit_batch = tunnel_key_exit_net,\n\t.id   = &act_tunnel_key_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nstatic int __init tunnel_key_init_module(void)\n{\n\treturn tcf_register_action(&act_tunnel_key_ops, &tunnel_key_net_ops);\n}\n\nstatic void __exit tunnel_key_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_tunnel_key_ops, &tunnel_key_net_ops);\n}\n\nmodule_init(tunnel_key_init_module);\nmodule_exit(tunnel_key_cleanup_module);\n\nMODULE_AUTHOR(\"Amir Vadai <amir@vadai.me>\");\nMODULE_DESCRIPTION(\"ip tunnel manipulation actions\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}