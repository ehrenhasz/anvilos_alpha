{
  "module_name": "act_ipt.c",
  "hash_id": "57ae5cb93d433ba20228f59f00925bf7703caf8baf1fe27598183703cab90eaf",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_ipt.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <linux/tc_act/tc_ipt.h>\n#include <net/tc_act/tc_ipt.h>\n#include <net/tc_wrapper.h>\n#include <net/ip.h>\n\n#include <linux/netfilter_ipv4/ip_tables.h>\n\n\nstatic struct tc_action_ops act_ipt_ops;\nstatic struct tc_action_ops act_xt_ops;\n\nstatic int ipt_init_target(struct net *net, struct xt_entry_target *t,\n\t\t\t   char *table, unsigned int hook)\n{\n\tstruct xt_tgchk_param par;\n\tstruct xt_target *target;\n\tstruct ipt_entry e = {};\n\tint ret = 0;\n\n\ttarget = xt_request_find_target(AF_INET, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target))\n\t\treturn PTR_ERR(target);\n\n\tt->u.kernel.target = target;\n\tmemset(&par, 0, sizeof(par));\n\tpar.net       = net;\n\tpar.table     = table;\n\tpar.entryinfo = &e;\n\tpar.target    = target;\n\tpar.targinfo  = t->data;\n\tpar.hook_mask = 1 << hook;\n\tpar.family    = NFPROTO_IPV4;\n\n\tret = xt_check_target(&par, t->u.target_size - sizeof(*t), 0, false);\n\tif (ret < 0) {\n\t\tmodule_put(t->u.kernel.target->me);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void ipt_destroy_target(struct xt_entry_target *t, struct net *net)\n{\n\tstruct xt_tgdtor_param par = {\n\t\t.target   = t->u.kernel.target,\n\t\t.targinfo = t->data,\n\t\t.family   = NFPROTO_IPV4,\n\t\t.net      = net,\n\t};\n\tif (par.target->destroy != NULL)\n\t\tpar.target->destroy(&par);\n\tmodule_put(par.target->me);\n}\n\nstatic void tcf_ipt_release(struct tc_action *a)\n{\n\tstruct tcf_ipt *ipt = to_ipt(a);\n\n\tif (ipt->tcfi_t) {\n\t\tipt_destroy_target(ipt->tcfi_t, a->idrinfo->net);\n\t\tkfree(ipt->tcfi_t);\n\t}\n\tkfree(ipt->tcfi_tname);\n}\n\nstatic const struct nla_policy ipt_policy[TCA_IPT_MAX + 1] = {\n\t[TCA_IPT_TABLE]\t= { .type = NLA_STRING, .len = IFNAMSIZ },\n\t[TCA_IPT_HOOK]\t= NLA_POLICY_RANGE(NLA_U32, NF_INET_PRE_ROUTING,\n\t\t\t\t\t   NF_INET_NUMHOOKS),\n\t[TCA_IPT_INDEX]\t= { .type = NLA_U32 },\n\t[TCA_IPT_TARG]\t= { .len = sizeof(struct xt_entry_target) },\n};\n\nstatic int __tcf_ipt_init(struct net *net, unsigned int id, struct nlattr *nla,\n\t\t\t  struct nlattr *est, struct tc_action **a,\n\t\t\t  const struct tc_action_ops *ops,\n\t\t\t  struct tcf_proto *tp, u32 flags)\n{\n\tstruct tc_action_net *tn = net_generic(net, id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_IPT_MAX + 1];\n\tstruct tcf_ipt *ipt;\n\tstruct xt_entry_target *td, *t;\n\tchar *tname;\n\tbool exists = false;\n\tint ret = 0, err;\n\tu32 hook = 0;\n\tu32 index = 0;\n\n\tif (nla == NULL)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_IPT_MAX, nla, ipt_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_IPT_INDEX] != NULL)\n\t\tindex = nla_get_u32(tb[TCA_IPT_INDEX]);\n\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0)\n\t\treturn err;\n\texists = err;\n\tif (exists && bind)\n\t\treturn 0;\n\n\tif (tb[TCA_IPT_HOOK] == NULL || tb[TCA_IPT_TARG] == NULL) {\n\t\tif (exists)\n\t\t\ttcf_idr_release(*a, bind);\n\t\telse\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\treturn -EINVAL;\n\t}\n\n\ttd = (struct xt_entry_target *)nla_data(tb[TCA_IPT_TARG]);\n\tif (nla_len(tb[TCA_IPT_TARG]) != td->u.target_size) {\n\t\tif (exists)\n\t\t\ttcf_idr_release(*a, bind);\n\t\telse\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!exists) {\n\t\tret = tcf_idr_create(tn, index, est, a, ops, bind,\n\t\t\t\t     false, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ACT_P_CREATED;\n\t} else {\n\t\tif (bind) \n\t\t\treturn 0;\n\n\t\tif (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\t\ttcf_idr_release(*a, bind);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\terr = -EINVAL;\n\thook = nla_get_u32(tb[TCA_IPT_HOOK]);\n\tswitch (hook) {\n\tcase NF_INET_PRE_ROUTING:\n\t\tbreak;\n\tcase NF_INET_POST_ROUTING:\n\t\tbreak;\n\tdefault:\n\t\tgoto err1;\n\t}\n\n\tif (tb[TCA_IPT_TABLE]) {\n\t\t \n\t\tif (nla_strcmp(tb[TCA_IPT_TABLE], \"mangle\"))\n\t\t\tgoto err1;\n\t}\n\n\ttname = kstrdup(\"mangle\", GFP_KERNEL);\n\tif (unlikely(!tname))\n\t\tgoto err1;\n\n\tt = kmemdup(td, td->u.target_size, GFP_KERNEL);\n\tif (unlikely(!t))\n\t\tgoto err2;\n\n\terr = ipt_init_target(net, t, tname, hook);\n\tif (err < 0)\n\t\tgoto err3;\n\n\tipt = to_ipt(*a);\n\n\tspin_lock_bh(&ipt->tcf_lock);\n\tif (ret != ACT_P_CREATED) {\n\t\tipt_destroy_target(ipt->tcfi_t, net);\n\t\tkfree(ipt->tcfi_tname);\n\t\tkfree(ipt->tcfi_t);\n\t}\n\tipt->tcfi_tname = tname;\n\tipt->tcfi_t     = t;\n\tipt->tcfi_hook  = hook;\n\tspin_unlock_bh(&ipt->tcf_lock);\n\treturn ret;\n\nerr3:\n\tkfree(t);\nerr2:\n\tkfree(tname);\nerr1:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic int tcf_ipt_init(struct net *net, struct nlattr *nla,\n\t\t\tstruct nlattr *est, struct tc_action **a,\n\t\t\tstruct tcf_proto *tp,\n\t\t\tu32 flags, struct netlink_ext_ack *extack)\n{\n\treturn __tcf_ipt_init(net, act_ipt_ops.net_id, nla, est,\n\t\t\t      a, &act_ipt_ops, tp, flags);\n}\n\nstatic int tcf_xt_init(struct net *net, struct nlattr *nla,\n\t\t       struct nlattr *est, struct tc_action **a,\n\t\t       struct tcf_proto *tp,\n\t\t       u32 flags, struct netlink_ext_ack *extack)\n{\n\treturn __tcf_ipt_init(net, act_xt_ops.net_id, nla, est,\n\t\t\t      a, &act_xt_ops, tp, flags);\n}\n\nstatic bool tcf_ipt_act_check(struct sk_buff *skb)\n{\n\tconst struct iphdr *iph;\n\tunsigned int nhoff, len;\n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\treturn false;\n\n\tnhoff = skb_network_offset(skb);\n\tiph = ip_hdr(skb);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\treturn false;\n\n\tlen = skb_ip_totlen(skb);\n\tif (skb->len < nhoff + len || len < (iph->ihl * 4u))\n\t\treturn false;\n\n\treturn pskb_may_pull(skb, iph->ihl * 4u);\n}\n\nTC_INDIRECT_SCOPE int tcf_ipt_act(struct sk_buff *skb,\n\t\t\t\t  const struct tc_action *a,\n\t\t\t\t  struct tcf_result *res)\n{\n\tchar saved_cb[sizeof_field(struct sk_buff, cb)];\n\tint ret = 0, result = 0;\n\tstruct tcf_ipt *ipt = to_ipt(a);\n\tstruct xt_action_param par;\n\tstruct nf_hook_state state = {\n\t\t.net\t= dev_net(skb->dev),\n\t\t.in\t= skb->dev,\n\t\t.hook\t= ipt->tcfi_hook,\n\t\t.pf\t= NFPROTO_IPV4,\n\t};\n\n\tif (skb_protocol(skb, false) != htons(ETH_P_IP))\n\t\treturn TC_ACT_UNSPEC;\n\n\tif (skb_unclone(skb, GFP_ATOMIC))\n\t\treturn TC_ACT_UNSPEC;\n\n\tif (!tcf_ipt_act_check(skb))\n\t\treturn TC_ACT_UNSPEC;\n\n\tif (state.hook == NF_INET_POST_ROUTING) {\n\t\tif (!skb_dst(skb))\n\t\t\treturn TC_ACT_UNSPEC;\n\n\t\tstate.out = skb->dev;\n\t}\n\n\tmemcpy(saved_cb, skb->cb, sizeof(saved_cb));\n\n\tspin_lock(&ipt->tcf_lock);\n\n\ttcf_lastuse_update(&ipt->tcf_tm);\n\tbstats_update(&ipt->tcf_bstats, skb);\n\n\t \n\tpar.state    = &state;\n\tpar.target   = ipt->tcfi_t->u.kernel.target;\n\tpar.targinfo = ipt->tcfi_t->data;\n\n\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\n\tret = par.target->target(skb, &par);\n\n\tswitch (ret) {\n\tcase NF_ACCEPT:\n\t\tresult = TC_ACT_OK;\n\t\tbreak;\n\tcase NF_DROP:\n\t\tresult = TC_ACT_SHOT;\n\t\tipt->tcf_qstats.drops++;\n\t\tbreak;\n\tcase XT_CONTINUE:\n\t\tresult = TC_ACT_PIPE;\n\t\tbreak;\n\tdefault:\n\t\tnet_notice_ratelimited(\"tc filter: Bogus netfilter code %d assume ACCEPT\\n\",\n\t\t\t\t       ret);\n\t\tresult = TC_ACT_OK;\n\t\tbreak;\n\t}\n\tspin_unlock(&ipt->tcf_lock);\n\n\tmemcpy(skb->cb, saved_cb, sizeof(skb->cb));\n\n\treturn result;\n\n}\n\nstatic int tcf_ipt_dump(struct sk_buff *skb, struct tc_action *a, int bind,\n\t\t\tint ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_ipt *ipt = to_ipt(a);\n\tstruct xt_entry_target *t;\n\tstruct tcf_t tm;\n\tstruct tc_cnt c;\n\n\t \n\n\tspin_lock_bh(&ipt->tcf_lock);\n\tt = kmemdup(ipt->tcfi_t, ipt->tcfi_t->u.user.target_size, GFP_ATOMIC);\n\tif (unlikely(!t))\n\t\tgoto nla_put_failure;\n\n\tc.bindcnt = atomic_read(&ipt->tcf_bindcnt) - bind;\n\tc.refcnt = refcount_read(&ipt->tcf_refcnt) - ref;\n\tstrcpy(t->u.user.name, ipt->tcfi_t->u.kernel.target->name);\n\n\tif (nla_put(skb, TCA_IPT_TARG, ipt->tcfi_t->u.user.target_size, t) ||\n\t    nla_put_u32(skb, TCA_IPT_INDEX, ipt->tcf_index) ||\n\t    nla_put_u32(skb, TCA_IPT_HOOK, ipt->tcfi_hook) ||\n\t    nla_put(skb, TCA_IPT_CNT, sizeof(struct tc_cnt), &c) ||\n\t    nla_put_string(skb, TCA_IPT_TABLE, ipt->tcfi_tname))\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&tm, &ipt->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_IPT_TM, sizeof(tm), &tm, TCA_IPT_PAD))\n\t\tgoto nla_put_failure;\n\n\tspin_unlock_bh(&ipt->tcf_lock);\n\tkfree(t);\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&ipt->tcf_lock);\n\tnlmsg_trim(skb, b);\n\tkfree(t);\n\treturn -1;\n}\n\nstatic struct tc_action_ops act_ipt_ops = {\n\t.kind\t\t=\t\"ipt\",\n\t.id\t\t=\tTCA_ID_IPT,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_ipt_act,\n\t.dump\t\t=\ttcf_ipt_dump,\n\t.cleanup\t=\ttcf_ipt_release,\n\t.init\t\t=\ttcf_ipt_init,\n\t.size\t\t=\tsizeof(struct tcf_ipt),\n};\n\nstatic __net_init int ipt_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_ipt_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_ipt_ops);\n}\n\nstatic void __net_exit ipt_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_ipt_ops.net_id);\n}\n\nstatic struct pernet_operations ipt_net_ops = {\n\t.init = ipt_init_net,\n\t.exit_batch = ipt_exit_net,\n\t.id   = &act_ipt_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nstatic struct tc_action_ops act_xt_ops = {\n\t.kind\t\t=\t\"xt\",\n\t.id\t\t=\tTCA_ID_XT,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_ipt_act,\n\t.dump\t\t=\ttcf_ipt_dump,\n\t.cleanup\t=\ttcf_ipt_release,\n\t.init\t\t=\ttcf_xt_init,\n\t.size\t\t=\tsizeof(struct tcf_ipt),\n};\n\nstatic __net_init int xt_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_xt_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_xt_ops);\n}\n\nstatic void __net_exit xt_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_xt_ops.net_id);\n}\n\nstatic struct pernet_operations xt_net_ops = {\n\t.init = xt_init_net,\n\t.exit_batch = xt_exit_net,\n\t.id   = &act_xt_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nMODULE_AUTHOR(\"Jamal Hadi Salim(2002-13)\");\nMODULE_DESCRIPTION(\"Iptables target actions\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"act_xt\");\n\nstatic int __init ipt_init_module(void)\n{\n\tint ret1, ret2;\n\n\tret1 = tcf_register_action(&act_xt_ops, &xt_net_ops);\n\tif (ret1 < 0)\n\t\tpr_err(\"Failed to load xt action\\n\");\n\n\tret2 = tcf_register_action(&act_ipt_ops, &ipt_net_ops);\n\tif (ret2 < 0)\n\t\tpr_err(\"Failed to load ipt action\\n\");\n\n\tif (ret1 < 0 && ret2 < 0) {\n\t\treturn ret1;\n\t} else\n\t\treturn 0;\n}\n\nstatic void __exit ipt_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_ipt_ops, &ipt_net_ops);\n\ttcf_unregister_action(&act_xt_ops, &xt_net_ops);\n}\n\nmodule_init(ipt_init_module);\nmodule_exit(ipt_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}