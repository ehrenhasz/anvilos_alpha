{
  "module_name": "cls_fw.c",
  "hash_id": "2630a97e7ba0b88cc1b2ca2336d21105a8c2060c0191acb561faa4d2dc47210f",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/cls_fw.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/act_api.h>\n#include <net/pkt_cls.h>\n#include <net/sch_generic.h>\n#include <net/tc_wrapper.h>\n\n#define HTSIZE 256\n\nstruct fw_head {\n\tu32\t\t\tmask;\n\tstruct fw_filter __rcu\t*ht[HTSIZE];\n\tstruct rcu_head\t\trcu;\n};\n\nstruct fw_filter {\n\tstruct fw_filter __rcu\t*next;\n\tu32\t\t\tid;\n\tstruct tcf_result\tres;\n\tint\t\t\tifindex;\n\tstruct tcf_exts\t\texts;\n\tstruct tcf_proto\t*tp;\n\tstruct rcu_work\t\trwork;\n};\n\nstatic u32 fw_hash(u32 handle)\n{\n\thandle ^= (handle >> 16);\n\thandle ^= (handle >> 8);\n\treturn handle % HTSIZE;\n}\n\nTC_INDIRECT_SCOPE int fw_classify(struct sk_buff *skb,\n\t\t\t\t  const struct tcf_proto *tp,\n\t\t\t\t  struct tcf_result *res)\n{\n\tstruct fw_head *head = rcu_dereference_bh(tp->root);\n\tstruct fw_filter *f;\n\tint r;\n\tu32 id = skb->mark;\n\n\tif (head != NULL) {\n\t\tid &= head->mask;\n\n\t\tfor (f = rcu_dereference_bh(head->ht[fw_hash(id)]); f;\n\t\t     f = rcu_dereference_bh(f->next)) {\n\t\t\tif (f->id == id) {\n\t\t\t\t*res = f->res;\n\t\t\t\tif (!tcf_match_indev(skb, f->ifindex))\n\t\t\t\t\tcontinue;\n\t\t\t\tr = tcf_exts_exec(skb, &f->exts, res);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct Qdisc *q = tcf_block_q(tp->chain->block);\n\n\t\t \n\t\tif (id && (TC_H_MAJ(id) == 0 ||\n\t\t\t   !(TC_H_MAJ(id ^ q->handle)))) {\n\t\t\tres->classid = id;\n\t\t\tres->class = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic void *fw_get(struct tcf_proto *tp, u32 handle)\n{\n\tstruct fw_head *head = rtnl_dereference(tp->root);\n\tstruct fw_filter *f;\n\n\tif (head == NULL)\n\t\treturn NULL;\n\n\tf = rtnl_dereference(head->ht[fw_hash(handle)]);\n\tfor (; f; f = rtnl_dereference(f->next)) {\n\t\tif (f->id == handle)\n\t\t\treturn f;\n\t}\n\treturn NULL;\n}\n\nstatic int fw_init(struct tcf_proto *tp)\n{\n\t \n\treturn 0;\n}\n\nstatic void __fw_delete_filter(struct fw_filter *f)\n{\n\ttcf_exts_destroy(&f->exts);\n\ttcf_exts_put_net(&f->exts);\n\tkfree(f);\n}\n\nstatic void fw_delete_filter_work(struct work_struct *work)\n{\n\tstruct fw_filter *f = container_of(to_rcu_work(work),\n\t\t\t\t\t   struct fw_filter,\n\t\t\t\t\t   rwork);\n\trtnl_lock();\n\t__fw_delete_filter(f);\n\trtnl_unlock();\n}\n\nstatic void fw_destroy(struct tcf_proto *tp, bool rtnl_held,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct fw_head *head = rtnl_dereference(tp->root);\n\tstruct fw_filter *f;\n\tint h;\n\n\tif (head == NULL)\n\t\treturn;\n\n\tfor (h = 0; h < HTSIZE; h++) {\n\t\twhile ((f = rtnl_dereference(head->ht[h])) != NULL) {\n\t\t\tRCU_INIT_POINTER(head->ht[h],\n\t\t\t\t\t rtnl_dereference(f->next));\n\t\t\ttcf_unbind_filter(tp, &f->res);\n\t\t\tif (tcf_exts_get_net(&f->exts))\n\t\t\t\ttcf_queue_work(&f->rwork, fw_delete_filter_work);\n\t\t\telse\n\t\t\t\t__fw_delete_filter(f);\n\t\t}\n\t}\n\tkfree_rcu(head, rcu);\n}\n\nstatic int fw_delete(struct tcf_proto *tp, void *arg, bool *last,\n\t\t     bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct fw_head *head = rtnl_dereference(tp->root);\n\tstruct fw_filter *f = arg;\n\tstruct fw_filter __rcu **fp;\n\tstruct fw_filter *pfp;\n\tint ret = -EINVAL;\n\tint h;\n\n\tif (head == NULL || f == NULL)\n\t\tgoto out;\n\n\tfp = &head->ht[fw_hash(f->id)];\n\n\tfor (pfp = rtnl_dereference(*fp); pfp;\n\t     fp = &pfp->next, pfp = rtnl_dereference(*fp)) {\n\t\tif (pfp == f) {\n\t\t\tRCU_INIT_POINTER(*fp, rtnl_dereference(f->next));\n\t\t\ttcf_unbind_filter(tp, &f->res);\n\t\t\ttcf_exts_get_net(&f->exts);\n\t\t\ttcf_queue_work(&f->rwork, fw_delete_filter_work);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*last = true;\n\tfor (h = 0; h < HTSIZE; h++) {\n\t\tif (rcu_access_pointer(head->ht[h])) {\n\t\t\t*last = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic const struct nla_policy fw_policy[TCA_FW_MAX + 1] = {\n\t[TCA_FW_CLASSID]\t= { .type = NLA_U32 },\n\t[TCA_FW_INDEV]\t\t= { .type = NLA_STRING, .len = IFNAMSIZ },\n\t[TCA_FW_MASK]\t\t= { .type = NLA_U32 },\n};\n\nstatic int fw_set_parms(struct net *net, struct tcf_proto *tp,\n\t\t\tstruct fw_filter *f, struct nlattr **tb,\n\t\t\tstruct nlattr **tca, unsigned long base, u32 flags,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct fw_head *head = rtnl_dereference(tp->root);\n\tu32 mask;\n\tint err;\n\n\terr = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &f->exts, flags,\n\t\t\t\textack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_FW_INDEV]) {\n\t\tint ret;\n\t\tret = tcf_change_indev(net, tb[TCA_FW_INDEV], extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tf->ifindex = ret;\n\t}\n\n\terr = -EINVAL;\n\tif (tb[TCA_FW_MASK]) {\n\t\tmask = nla_get_u32(tb[TCA_FW_MASK]);\n\t\tif (mask != head->mask)\n\t\t\treturn err;\n\t} else if (head->mask != 0xFFFFFFFF)\n\t\treturn err;\n\n\tif (tb[TCA_FW_CLASSID]) {\n\t\tf->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);\n\t\ttcf_bind_filter(tp, &f->res, base);\n\t}\n\n\treturn 0;\n}\n\nstatic int fw_change(struct net *net, struct sk_buff *in_skb,\n\t\t     struct tcf_proto *tp, unsigned long base,\n\t\t     u32 handle, struct nlattr **tca, void **arg,\n\t\t     u32 flags, struct netlink_ext_ack *extack)\n{\n\tstruct fw_head *head = rtnl_dereference(tp->root);\n\tstruct fw_filter *f = *arg;\n\tstruct nlattr *opt = tca[TCA_OPTIONS];\n\tstruct nlattr *tb[TCA_FW_MAX + 1];\n\tint err;\n\n\tif (!opt)\n\t\treturn handle ? -EINVAL : 0;  \n\n\terr = nla_parse_nested_deprecated(tb, TCA_FW_MAX, opt, fw_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (f) {\n\t\tstruct fw_filter *pfp, *fnew;\n\t\tstruct fw_filter __rcu **fp;\n\n\t\tif (f->id != handle && handle)\n\t\t\treturn -EINVAL;\n\n\t\tfnew = kzalloc(sizeof(struct fw_filter), GFP_KERNEL);\n\t\tif (!fnew)\n\t\t\treturn -ENOBUFS;\n\n\t\tfnew->id = f->id;\n\t\tfnew->ifindex = f->ifindex;\n\t\tfnew->tp = f->tp;\n\n\t\terr = tcf_exts_init(&fnew->exts, net, TCA_FW_ACT,\n\t\t\t\t    TCA_FW_POLICE);\n\t\tif (err < 0) {\n\t\t\tkfree(fnew);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = fw_set_parms(net, tp, fnew, tb, tca, base, flags, extack);\n\t\tif (err < 0) {\n\t\t\ttcf_exts_destroy(&fnew->exts);\n\t\t\tkfree(fnew);\n\t\t\treturn err;\n\t\t}\n\n\t\tfp = &head->ht[fw_hash(fnew->id)];\n\t\tfor (pfp = rtnl_dereference(*fp); pfp;\n\t\t     fp = &pfp->next, pfp = rtnl_dereference(*fp))\n\t\t\tif (pfp == f)\n\t\t\t\tbreak;\n\n\t\tRCU_INIT_POINTER(fnew->next, rtnl_dereference(pfp->next));\n\t\trcu_assign_pointer(*fp, fnew);\n\t\ttcf_unbind_filter(tp, &f->res);\n\t\ttcf_exts_get_net(&f->exts);\n\t\ttcf_queue_work(&f->rwork, fw_delete_filter_work);\n\n\t\t*arg = fnew;\n\t\treturn err;\n\t}\n\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tif (!head) {\n\t\tu32 mask = 0xFFFFFFFF;\n\t\tif (tb[TCA_FW_MASK])\n\t\t\tmask = nla_get_u32(tb[TCA_FW_MASK]);\n\n\t\thead = kzalloc(sizeof(*head), GFP_KERNEL);\n\t\tif (!head)\n\t\t\treturn -ENOBUFS;\n\t\thead->mask = mask;\n\n\t\trcu_assign_pointer(tp->root, head);\n\t}\n\n\tf = kzalloc(sizeof(struct fw_filter), GFP_KERNEL);\n\tif (f == NULL)\n\t\treturn -ENOBUFS;\n\n\terr = tcf_exts_init(&f->exts, net, TCA_FW_ACT, TCA_FW_POLICE);\n\tif (err < 0)\n\t\tgoto errout;\n\tf->id = handle;\n\tf->tp = tp;\n\n\terr = fw_set_parms(net, tp, f, tb, tca, base, flags, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tRCU_INIT_POINTER(f->next, head->ht[fw_hash(handle)]);\n\trcu_assign_pointer(head->ht[fw_hash(handle)], f);\n\n\t*arg = f;\n\treturn 0;\n\nerrout:\n\ttcf_exts_destroy(&f->exts);\n\tkfree(f);\n\treturn err;\n}\n\nstatic void fw_walk(struct tcf_proto *tp, struct tcf_walker *arg,\n\t\t    bool rtnl_held)\n{\n\tstruct fw_head *head = rtnl_dereference(tp->root);\n\tint h;\n\n\tif (head == NULL)\n\t\targ->stop = 1;\n\n\tif (arg->stop)\n\t\treturn;\n\n\tfor (h = 0; h < HTSIZE; h++) {\n\t\tstruct fw_filter *f;\n\n\t\tfor (f = rtnl_dereference(head->ht[h]); f;\n\t\t     f = rtnl_dereference(f->next)) {\n\t\t\tif (!tc_cls_stats_dump(tp, arg, f))\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int fw_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t   struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)\n{\n\tstruct fw_head *head = rtnl_dereference(tp->root);\n\tstruct fw_filter *f = fh;\n\tstruct nlattr *nest;\n\n\tif (f == NULL)\n\t\treturn skb->len;\n\n\tt->tcm_handle = f->id;\n\n\tif (!f->res.classid && !tcf_exts_has_actions(&f->exts))\n\t\treturn skb->len;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (f->res.classid &&\n\t    nla_put_u32(skb, TCA_FW_CLASSID, f->res.classid))\n\t\tgoto nla_put_failure;\n\tif (f->ifindex) {\n\t\tstruct net_device *dev;\n\t\tdev = __dev_get_by_index(net, f->ifindex);\n\t\tif (dev && nla_put_string(skb, TCA_FW_INDEV, dev->name))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (head->mask != 0xFFFFFFFF &&\n\t    nla_put_u32(skb, TCA_FW_MASK, head->mask))\n\t\tgoto nla_put_failure;\n\n\tif (tcf_exts_dump(skb, &f->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tif (tcf_exts_dump_stats(skb, &f->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic void fw_bind_class(void *fh, u32 classid, unsigned long cl, void *q,\n\t\t\t  unsigned long base)\n{\n\tstruct fw_filter *f = fh;\n\n\ttc_cls_bind_class(classid, cl, q, &f->res, base);\n}\n\nstatic struct tcf_proto_ops cls_fw_ops __read_mostly = {\n\t.kind\t\t=\t\"fw\",\n\t.classify\t=\tfw_classify,\n\t.init\t\t=\tfw_init,\n\t.destroy\t=\tfw_destroy,\n\t.get\t\t=\tfw_get,\n\t.change\t\t=\tfw_change,\n\t.delete\t\t=\tfw_delete,\n\t.walk\t\t=\tfw_walk,\n\t.dump\t\t=\tfw_dump,\n\t.bind_class\t=\tfw_bind_class,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init init_fw(void)\n{\n\treturn register_tcf_proto_ops(&cls_fw_ops);\n}\n\nstatic void __exit exit_fw(void)\n{\n\tunregister_tcf_proto_ops(&cls_fw_ops);\n}\n\nmodule_init(init_fw)\nmodule_exit(exit_fw)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}