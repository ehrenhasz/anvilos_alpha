{
  "module_name": "sch_mqprio_lib.c",
  "hash_id": "4c0f7f5e1c78f7d73491d3fc50094b636216858508ada9921e494ca35b953e92",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_mqprio_lib.c",
  "human_readable_source": "\n\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/types.h>\n#include <net/pkt_sched.h>\n\n#include \"sch_mqprio_lib.h\"\n\n \nstatic bool intervals_overlap(int a, int b, int c, int d)\n{\n\tint left = max(a, c), right = min(b, d);\n\n\treturn left < right;\n}\n\nstatic int mqprio_validate_queue_counts(struct net_device *dev,\n\t\t\t\t\tconst struct tc_mqprio_qopt *qopt,\n\t\t\t\t\tbool allow_overlapping_txqs,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint i, j;\n\n\tfor (i = 0; i < qopt->num_tc; i++) {\n\t\tunsigned int last = qopt->offset[i] + qopt->count[i];\n\n\t\tif (!qopt->count[i]) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack, \"No queues for TC %d\",\n\t\t\t\t\t       i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (qopt->offset[i] >= dev->real_num_tx_queues ||\n\t\t    last > dev->real_num_tx_queues) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"Queues %d:%d for TC %d exceed the %d TX queues available\",\n\t\t\t\t\t       qopt->count[i], qopt->offset[i],\n\t\t\t\t\t       i, dev->real_num_tx_queues);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (allow_overlapping_txqs)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (j = i + 1; j < qopt->num_tc; j++) {\n\t\t\tif (intervals_overlap(qopt->offset[i], last,\n\t\t\t\t\t      qopt->offset[j],\n\t\t\t\t\t      qopt->offset[j] +\n\t\t\t\t\t      qopt->count[j])) {\n\t\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t\t       \"TC %d queues %d@%d overlap with TC %d queues %d@%d\",\n\t\t\t\t\t\t       i, qopt->count[i], qopt->offset[i],\n\t\t\t\t\t\t       j, qopt->count[j], qopt->offset[j]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint mqprio_validate_qopt(struct net_device *dev, struct tc_mqprio_qopt *qopt,\n\t\t\t bool validate_queue_counts,\n\t\t\t bool allow_overlapping_txqs,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tint i, err;\n\n\t \n\tif (qopt->num_tc > TC_MAX_QUEUE) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Number of traffic classes is outside valid range\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i <= TC_BITMASK; i++) {\n\t\tif (qopt->prio_tc_map[i] >= qopt->num_tc) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Invalid traffic class in priority to traffic class mapping\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (validate_queue_counts) {\n\t\terr = mqprio_validate_queue_counts(dev, qopt,\n\t\t\t\t\t\t   allow_overlapping_txqs,\n\t\t\t\t\t\t   extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mqprio_validate_qopt);\n\nvoid mqprio_qopt_reconstruct(struct net_device *dev, struct tc_mqprio_qopt *qopt)\n{\n\tint tc, num_tc = netdev_get_num_tc(dev);\n\n\tqopt->num_tc = num_tc;\n\tmemcpy(qopt->prio_tc_map, dev->prio_tc_map, sizeof(qopt->prio_tc_map));\n\n\tfor (tc = 0; tc < num_tc; tc++) {\n\t\tqopt->count[tc] = dev->tc_to_txq[tc].count;\n\t\tqopt->offset[tc] = dev->tc_to_txq[tc].offset;\n\t}\n}\nEXPORT_SYMBOL_GPL(mqprio_qopt_reconstruct);\n\nvoid mqprio_fp_to_offload(u32 fp[TC_QOPT_MAX_QUEUE],\n\t\t\t  struct tc_mqprio_qopt_offload *mqprio)\n{\n\tunsigned long preemptible_tcs = 0;\n\tint tc;\n\n\tfor (tc = 0; tc < TC_QOPT_MAX_QUEUE; tc++)\n\t\tif (fp[tc] == TC_FP_PREEMPTIBLE)\n\t\t\tpreemptible_tcs |= BIT(tc);\n\n\tmqprio->preemptible_tcs = preemptible_tcs;\n}\nEXPORT_SYMBOL_GPL(mqprio_fp_to_offload);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}