{
  "module_name": "act_nat.c",
  "hash_id": "08f13d7a5ed9bf2141700cf0764d79cd7593df304ab80ec1f54c7f00c0c24d9a",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_nat.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netfilter.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/tc_act/tc_nat.h>\n#include <net/act_api.h>\n#include <net/pkt_cls.h>\n#include <net/icmp.h>\n#include <net/ip.h>\n#include <net/netlink.h>\n#include <net/tc_act/tc_nat.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/tc_wrapper.h>\n\nstatic struct tc_action_ops act_nat_ops;\n\nstatic const struct nla_policy nat_policy[TCA_NAT_MAX + 1] = {\n\t[TCA_NAT_PARMS]\t= { .len = sizeof(struct tc_nat) },\n};\n\nstatic int tcf_nat_init(struct net *net, struct nlattr *nla, struct nlattr *est,\n\t\t\tstruct tc_action **a, struct tcf_proto *tp,\n\t\t\tu32 flags, struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_nat_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct tcf_nat_parms *nparm, *oparm;\n\tstruct nlattr *tb[TCA_NAT_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tc_nat *parm;\n\tint ret = 0, err;\n\tstruct tcf_nat *p;\n\tu32 index;\n\n\tif (nla == NULL)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_NAT_MAX, nla, nat_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_NAT_PARMS] == NULL)\n\t\treturn -EINVAL;\n\tparm = nla_data(tb[TCA_NAT_PARMS]);\n\tindex = parm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (!err) {\n\t\tret = tcf_idr_create_from_flags(tn, index, est, a, &act_nat_ops,\n\t\t\t\t\t\tbind, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ACT_P_CREATED;\n\t} else if (err > 0) {\n\t\tif (bind)\n\t\t\treturn 0;\n\t\tif (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\t\ttcf_idr_release(*a, bind);\n\t\t\treturn -EEXIST;\n\t\t}\n\t} else {\n\t\treturn err;\n\t}\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\tnparm = kzalloc(sizeof(*nparm), GFP_KERNEL);\n\tif (!nparm) {\n\t\terr = -ENOMEM;\n\t\tgoto release_idr;\n\t}\n\n\tnparm->old_addr = parm->old_addr;\n\tnparm->new_addr = parm->new_addr;\n\tnparm->mask = parm->mask;\n\tnparm->flags = parm->flags;\n\n\tp = to_tcf_nat(*a);\n\n\tspin_lock_bh(&p->tcf_lock);\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\toparm = rcu_replace_pointer(p->parms, nparm, lockdep_is_held(&p->tcf_lock));\n\tspin_unlock_bh(&p->tcf_lock);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\n\tif (oparm)\n\t\tkfree_rcu(oparm, rcu);\n\n\treturn ret;\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nTC_INDIRECT_SCOPE int tcf_nat_act(struct sk_buff *skb,\n\t\t\t\t  const struct tc_action *a,\n\t\t\t\t  struct tcf_result *res)\n{\n\tstruct tcf_nat *p = to_tcf_nat(a);\n\tstruct tcf_nat_parms *parms;\n\tstruct iphdr *iph;\n\t__be32 old_addr;\n\t__be32 new_addr;\n\t__be32 mask;\n\t__be32 addr;\n\tint egress;\n\tint action;\n\tint ihl;\n\tint noff;\n\n\ttcf_lastuse_update(&p->tcf_tm);\n\ttcf_action_update_bstats(&p->common, skb);\n\n\taction = READ_ONCE(p->tcf_action);\n\n\tparms = rcu_dereference_bh(p->parms);\n\told_addr = parms->old_addr;\n\tnew_addr = parms->new_addr;\n\tmask = parms->mask;\n\tegress = parms->flags & TCA_NAT_FLAG_EGRESS;\n\n\tif (unlikely(action == TC_ACT_SHOT))\n\t\tgoto drop;\n\n\tnoff = skb_network_offset(skb);\n\tif (!pskb_may_pull(skb, sizeof(*iph) + noff))\n\t\tgoto drop;\n\n\tiph = ip_hdr(skb);\n\n\tif (egress)\n\t\taddr = iph->saddr;\n\telse\n\t\taddr = iph->daddr;\n\n\tif (!((old_addr ^ addr) & mask)) {\n\t\tif (skb_try_make_writable(skb, sizeof(*iph) + noff))\n\t\t\tgoto drop;\n\n\t\tnew_addr &= mask;\n\t\tnew_addr |= addr & ~mask;\n\n\t\t \n\t\tiph = ip_hdr(skb);\n\t\tif (egress)\n\t\t\tiph->saddr = new_addr;\n\t\telse\n\t\t\tiph->daddr = new_addr;\n\n\t\tcsum_replace4(&iph->check, addr, new_addr);\n\t} else if ((iph->frag_off & htons(IP_OFFSET)) ||\n\t\t   iph->protocol != IPPROTO_ICMP) {\n\t\tgoto out;\n\t}\n\n\tihl = iph->ihl * 4;\n\n\t \n\tswitch (iph->frag_off & htons(IP_OFFSET) ? 0 : iph->protocol) {\n\tcase IPPROTO_TCP:\n\t{\n\t\tstruct tcphdr *tcph;\n\n\t\tif (!pskb_may_pull(skb, ihl + sizeof(*tcph) + noff) ||\n\t\t    skb_try_make_writable(skb, ihl + sizeof(*tcph) + noff))\n\t\t\tgoto drop;\n\n\t\ttcph = (void *)(skb_network_header(skb) + ihl);\n\t\tinet_proto_csum_replace4(&tcph->check, skb, addr, new_addr,\n\t\t\t\t\t true);\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP:\n\t{\n\t\tstruct udphdr *udph;\n\n\t\tif (!pskb_may_pull(skb, ihl + sizeof(*udph) + noff) ||\n\t\t    skb_try_make_writable(skb, ihl + sizeof(*udph) + noff))\n\t\t\tgoto drop;\n\n\t\tudph = (void *)(skb_network_header(skb) + ihl);\n\t\tif (udph->check || skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tinet_proto_csum_replace4(&udph->check, skb, addr,\n\t\t\t\t\t\t new_addr, true);\n\t\t\tif (!udph->check)\n\t\t\t\tudph->check = CSUM_MANGLED_0;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IPPROTO_ICMP:\n\t{\n\t\tstruct icmphdr *icmph;\n\n\t\tif (!pskb_may_pull(skb, ihl + sizeof(*icmph) + noff))\n\t\t\tgoto drop;\n\n\t\ticmph = (void *)(skb_network_header(skb) + ihl);\n\n\t\tif (!icmp_is_err(icmph->type))\n\t\t\tbreak;\n\n\t\tif (!pskb_may_pull(skb, ihl + sizeof(*icmph) + sizeof(*iph) +\n\t\t\t\t\tnoff))\n\t\t\tgoto drop;\n\n\t\ticmph = (void *)(skb_network_header(skb) + ihl);\n\t\tiph = (void *)(icmph + 1);\n\t\tif (egress)\n\t\t\taddr = iph->daddr;\n\t\telse\n\t\t\taddr = iph->saddr;\n\n\t\tif ((old_addr ^ addr) & mask)\n\t\t\tbreak;\n\n\t\tif (skb_try_make_writable(skb, ihl + sizeof(*icmph) +\n\t\t\t\t\t  sizeof(*iph) + noff))\n\t\t\tgoto drop;\n\n\t\ticmph = (void *)(skb_network_header(skb) + ihl);\n\t\tiph = (void *)(icmph + 1);\n\n\t\tnew_addr &= mask;\n\t\tnew_addr |= addr & ~mask;\n\n\t\t \n\t\tif (egress)\n\t\t\tiph->daddr = new_addr;\n\t\telse\n\t\t\tiph->saddr = new_addr;\n\n\t\tinet_proto_csum_replace4(&icmph->checksum, skb, addr, new_addr,\n\t\t\t\t\t false);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\treturn action;\n\ndrop:\n\ttcf_action_inc_drop_qstats(&p->common);\n\treturn TC_ACT_SHOT;\n}\n\nstatic int tcf_nat_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\tint bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_nat *p = to_tcf_nat(a);\n\tstruct tc_nat opt = {\n\t\t.index    = p->tcf_index,\n\t\t.refcnt   = refcount_read(&p->tcf_refcnt) - ref,\n\t\t.bindcnt  = atomic_read(&p->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_nat_parms *parms;\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&p->tcf_lock);\n\n\topt.action = p->tcf_action;\n\n\tparms = rcu_dereference_protected(p->parms, lockdep_is_held(&p->tcf_lock));\n\n\topt.old_addr = parms->old_addr;\n\topt.new_addr = parms->new_addr;\n\topt.mask = parms->mask;\n\topt.flags = parms->flags;\n\n\tif (nla_put(skb, TCA_NAT_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &p->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_NAT_TM, sizeof(t), &t, TCA_NAT_PAD))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&p->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&p->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic void tcf_nat_cleanup(struct tc_action *a)\n{\n\tstruct tcf_nat *p = to_tcf_nat(a);\n\tstruct tcf_nat_parms *parms;\n\n\tparms = rcu_dereference_protected(p->parms, 1);\n\tif (parms)\n\t\tkfree_rcu(parms, rcu);\n}\n\nstatic struct tc_action_ops act_nat_ops = {\n\t.kind\t\t=\t\"nat\",\n\t.id\t\t=\tTCA_ID_NAT,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_nat_act,\n\t.dump\t\t=\ttcf_nat_dump,\n\t.init\t\t=\ttcf_nat_init,\n\t.cleanup\t=\ttcf_nat_cleanup,\n\t.size\t\t=\tsizeof(struct tcf_nat),\n};\n\nstatic __net_init int nat_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_nat_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_nat_ops);\n}\n\nstatic void __net_exit nat_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_nat_ops.net_id);\n}\n\nstatic struct pernet_operations nat_net_ops = {\n\t.init = nat_init_net,\n\t.exit_batch = nat_exit_net,\n\t.id   = &act_nat_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nMODULE_DESCRIPTION(\"Stateless NAT actions\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init nat_init_module(void)\n{\n\treturn tcf_register_action(&act_nat_ops, &nat_net_ops);\n}\n\nstatic void __exit nat_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_nat_ops, &nat_net_ops);\n}\n\nmodule_init(nat_init_module);\nmodule_exit(nat_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}