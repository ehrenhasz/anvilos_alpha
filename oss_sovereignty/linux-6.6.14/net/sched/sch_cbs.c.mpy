{
  "module_name": "sch_cbs.c",
  "hash_id": "68c41c5f0354974e99c3a656aed5feacad4d9425bfe134f086d932d5edaae18e",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_cbs.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <net/netevent.h>\n#include <net/netlink.h>\n#include <net/sch_generic.h>\n#include <net/pkt_sched.h>\n\nstatic LIST_HEAD(cbs_list);\nstatic DEFINE_SPINLOCK(cbs_list_lock);\n\n#define BYTES_PER_KBIT (1000LL / 8)\n\nstruct cbs_sched_data {\n\tbool offload;\n\tint queue;\n\tatomic64_t port_rate;  \n\ts64 last;  \n\ts64 credits;  \n\ts32 locredit;  \n\ts32 hicredit;  \n\ts64 sendslope;  \n\ts64 idleslope;  \n\tstruct qdisc_watchdog watchdog;\n\tint (*enqueue)(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free);\n\tstruct sk_buff *(*dequeue)(struct Qdisc *sch);\n\tstruct Qdisc *qdisc;\n\tstruct list_head cbs_list;\n};\n\nstatic int cbs_child_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t     struct Qdisc *child,\n\t\t\t     struct sk_buff **to_free)\n{\n\tunsigned int len = qdisc_pkt_len(skb);\n\tint err;\n\n\terr = child->ops->enqueue(skb, child, to_free);\n\tif (err != NET_XMIT_SUCCESS)\n\t\treturn err;\n\n\tsch->qstats.backlog += len;\n\tsch->q.qlen++;\n\n\treturn NET_XMIT_SUCCESS;\n}\n\nstatic int cbs_enqueue_offload(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t       struct sk_buff **to_free)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *qdisc = q->qdisc;\n\n\treturn cbs_child_enqueue(skb, sch, qdisc, to_free);\n}\n\nstatic int cbs_enqueue_soft(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t    struct sk_buff **to_free)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *qdisc = q->qdisc;\n\n\tif (sch->q.qlen == 0 && q->credits > 0) {\n\t\t \n\t\tq->credits = 0;\n\t\tq->last = ktime_get_ns();\n\t}\n\n\treturn cbs_child_enqueue(skb, sch, qdisc, to_free);\n}\n\nstatic int cbs_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\n\treturn q->enqueue(skb, sch, to_free);\n}\n\n \nstatic s64 timediff_to_credits(s64 timediff, s64 slope)\n{\n\treturn div64_s64(timediff * slope, NSEC_PER_SEC);\n}\n\nstatic s64 delay_from_credits(s64 credits, s64 slope)\n{\n\tif (unlikely(slope == 0))\n\t\treturn S64_MAX;\n\n\treturn div64_s64(-credits * NSEC_PER_SEC, slope);\n}\n\nstatic s64 credits_from_len(unsigned int len, s64 slope, s64 port_rate)\n{\n\tif (unlikely(port_rate == 0))\n\t\treturn S64_MAX;\n\n\treturn div64_s64(len * slope, port_rate);\n}\n\nstatic struct sk_buff *cbs_child_dequeue(struct Qdisc *sch, struct Qdisc *child)\n{\n\tstruct sk_buff *skb;\n\n\tskb = child->ops->dequeue(child);\n\tif (!skb)\n\t\treturn NULL;\n\n\tqdisc_qstats_backlog_dec(sch, skb);\n\tqdisc_bstats_update(sch, skb);\n\tsch->q.qlen--;\n\n\treturn skb;\n}\n\nstatic struct sk_buff *cbs_dequeue_soft(struct Qdisc *sch)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *qdisc = q->qdisc;\n\ts64 now = ktime_get_ns();\n\tstruct sk_buff *skb;\n\ts64 credits;\n\tint len;\n\n\t \n\tif (now < q->last) {\n\t\tqdisc_watchdog_schedule_ns(&q->watchdog, q->last);\n\t\treturn NULL;\n\t}\n\tif (q->credits < 0) {\n\t\tcredits = timediff_to_credits(now - q->last, q->idleslope);\n\n\t\tcredits = q->credits + credits;\n\t\tq->credits = min_t(s64, credits, q->hicredit);\n\n\t\tif (q->credits < 0) {\n\t\t\ts64 delay;\n\n\t\t\tdelay = delay_from_credits(q->credits, q->idleslope);\n\t\t\tqdisc_watchdog_schedule_ns(&q->watchdog, now + delay);\n\n\t\t\tq->last = now;\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tskb = cbs_child_dequeue(sch, qdisc);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlen = qdisc_pkt_len(skb);\n\n\t \n\tcredits = credits_from_len(len, q->sendslope,\n\t\t\t\t   atomic64_read(&q->port_rate));\n\tcredits += q->credits;\n\n\tq->credits = max_t(s64, credits, q->locredit);\n\t \n\tif (unlikely(atomic64_read(&q->port_rate) == 0))\n\t\tq->last = now;\n\telse\n\t\tq->last = now + div64_s64(len * NSEC_PER_SEC,\n\t\t\t\t\t  atomic64_read(&q->port_rate));\n\n\treturn skb;\n}\n\nstatic struct sk_buff *cbs_dequeue_offload(struct Qdisc *sch)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *qdisc = q->qdisc;\n\n\treturn cbs_child_dequeue(sch, qdisc);\n}\n\nstatic struct sk_buff *cbs_dequeue(struct Qdisc *sch)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\n\treturn q->dequeue(sch);\n}\n\nstatic const struct nla_policy cbs_policy[TCA_CBS_MAX + 1] = {\n\t[TCA_CBS_PARMS]\t= { .len = sizeof(struct tc_cbs_qopt) },\n};\n\nstatic void cbs_disable_offload(struct net_device *dev,\n\t\t\t\tstruct cbs_sched_data *q)\n{\n\tstruct tc_cbs_qopt_offload cbs = { };\n\tconst struct net_device_ops *ops;\n\tint err;\n\n\tif (!q->offload)\n\t\treturn;\n\n\tq->enqueue = cbs_enqueue_soft;\n\tq->dequeue = cbs_dequeue_soft;\n\n\tops = dev->netdev_ops;\n\tif (!ops->ndo_setup_tc)\n\t\treturn;\n\n\tcbs.queue = q->queue;\n\tcbs.enable = 0;\n\n\terr = ops->ndo_setup_tc(dev, TC_SETUP_QDISC_CBS, &cbs);\n\tif (err < 0)\n\t\tpr_warn(\"Couldn't disable CBS offload for queue %d\\n\",\n\t\t\tcbs.queue);\n}\n\nstatic int cbs_enable_offload(struct net_device *dev, struct cbs_sched_data *q,\n\t\t\t      const struct tc_cbs_qopt *opt,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tstruct tc_cbs_qopt_offload cbs = { };\n\tint err;\n\n\tif (!ops->ndo_setup_tc) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified device does not support cbs offload\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcbs.queue = q->queue;\n\n\tcbs.enable = 1;\n\tcbs.hicredit = opt->hicredit;\n\tcbs.locredit = opt->locredit;\n\tcbs.idleslope = opt->idleslope;\n\tcbs.sendslope = opt->sendslope;\n\n\terr = ops->ndo_setup_tc(dev, TC_SETUP_QDISC_CBS, &cbs);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified device failed to setup cbs hardware offload\");\n\t\treturn err;\n\t}\n\n\tq->enqueue = cbs_enqueue_offload;\n\tq->dequeue = cbs_dequeue_offload;\n\n\treturn 0;\n}\n\nstatic void cbs_set_port_rate(struct net_device *dev, struct cbs_sched_data *q)\n{\n\tstruct ethtool_link_ksettings ecmd;\n\tint speed = SPEED_10;\n\tint port_rate;\n\tint err;\n\n\terr = __ethtool_get_link_ksettings(dev, &ecmd);\n\tif (err < 0)\n\t\tgoto skip;\n\n\tif (ecmd.base.speed && ecmd.base.speed != SPEED_UNKNOWN)\n\t\tspeed = ecmd.base.speed;\n\nskip:\n\tport_rate = speed * 1000 * BYTES_PER_KBIT;\n\n\tatomic64_set(&q->port_rate, port_rate);\n\tnetdev_dbg(dev, \"cbs: set %s's port_rate to: %lld, linkspeed: %d\\n\",\n\t\t   dev->name, (long long)atomic64_read(&q->port_rate),\n\t\t   ecmd.base.speed);\n}\n\nstatic int cbs_dev_notifier(struct notifier_block *nb, unsigned long event,\n\t\t\t    void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct cbs_sched_data *q;\n\tstruct net_device *qdev;\n\tbool found = false;\n\n\tASSERT_RTNL();\n\n\tif (event != NETDEV_UP && event != NETDEV_CHANGE)\n\t\treturn NOTIFY_DONE;\n\n\tspin_lock(&cbs_list_lock);\n\tlist_for_each_entry(q, &cbs_list, cbs_list) {\n\t\tqdev = qdisc_dev(q->qdisc);\n\t\tif (qdev == dev) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cbs_list_lock);\n\n\tif (found)\n\t\tcbs_set_port_rate(dev, q);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int cbs_change(struct Qdisc *sch, struct nlattr *opt,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct nlattr *tb[TCA_CBS_MAX + 1];\n\tstruct tc_cbs_qopt *qopt;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_CBS_MAX, opt, cbs_policy,\n\t\t\t\t\t  extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_CBS_PARMS]) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing CBS parameter which are mandatory\");\n\t\treturn -EINVAL;\n\t}\n\n\tqopt = nla_data(tb[TCA_CBS_PARMS]);\n\n\tif (!qopt->offload) {\n\t\tcbs_set_port_rate(dev, q);\n\t\tcbs_disable_offload(dev, q);\n\t} else {\n\t\terr = cbs_enable_offload(dev, q, qopt, extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tq->hicredit = qopt->hicredit;\n\tq->locredit = qopt->locredit;\n\tq->idleslope = qopt->idleslope * BYTES_PER_KBIT;\n\tq->sendslope = qopt->sendslope * BYTES_PER_KBIT;\n\tq->offload = qopt->offload;\n\n\treturn 0;\n}\n\nstatic int cbs_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\n\tif (!opt) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing CBS qdisc options  which are mandatory\");\n\t\treturn -EINVAL;\n\t}\n\n\tq->qdisc = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\n\t\t\t\t     sch->handle, extack);\n\tif (!q->qdisc)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&cbs_list_lock);\n\tlist_add(&q->cbs_list, &cbs_list);\n\tspin_unlock(&cbs_list_lock);\n\n\tqdisc_hash_add(q->qdisc, false);\n\n\tq->queue = sch->dev_queue - netdev_get_tx_queue(dev, 0);\n\n\tq->enqueue = cbs_enqueue_soft;\n\tq->dequeue = cbs_dequeue_soft;\n\n\tqdisc_watchdog_init(&q->watchdog, sch);\n\n\treturn cbs_change(sch, opt, extack);\n}\n\nstatic void cbs_destroy(struct Qdisc *sch)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\n\t \n\tif (!q->qdisc)\n\t\treturn;\n\n\tqdisc_watchdog_cancel(&q->watchdog);\n\tcbs_disable_offload(dev, q);\n\n\tspin_lock(&cbs_list_lock);\n\tlist_del(&q->cbs_list);\n\tspin_unlock(&cbs_list_lock);\n\n\tqdisc_put(q->qdisc);\n}\n\nstatic int cbs_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\tstruct tc_cbs_qopt opt = { };\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\topt.hicredit = q->hicredit;\n\topt.locredit = q->locredit;\n\topt.sendslope = div64_s64(q->sendslope, BYTES_PER_KBIT);\n\topt.idleslope = div64_s64(q->idleslope, BYTES_PER_KBIT);\n\topt.offload = q->offload;\n\n\tif (nla_put(skb, TCA_CBS_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\treturn nla_nest_end(skb, nest);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic int cbs_dump_class(struct Qdisc *sch, unsigned long cl,\n\t\t\t  struct sk_buff *skb, struct tcmsg *tcm)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\n\tif (cl != 1 || !q->qdisc)\t \n\t\treturn -ENOENT;\n\n\ttcm->tcm_handle |= TC_H_MIN(1);\n\ttcm->tcm_info = q->qdisc->handle;\n\n\treturn 0;\n}\n\nstatic int cbs_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,\n\t\t     struct Qdisc **old, struct netlink_ext_ack *extack)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\n\tif (!new) {\n\t\tnew = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\n\t\t\t\t\tsch->handle, NULL);\n\t\tif (!new)\n\t\t\tnew = &noop_qdisc;\n\t}\n\n\t*old = qdisc_replace(sch, new, &q->qdisc);\n\treturn 0;\n}\n\nstatic struct Qdisc *cbs_leaf(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct cbs_sched_data *q = qdisc_priv(sch);\n\n\treturn q->qdisc;\n}\n\nstatic unsigned long cbs_find(struct Qdisc *sch, u32 classid)\n{\n\treturn 1;\n}\n\nstatic void cbs_walk(struct Qdisc *sch, struct qdisc_walker *walker)\n{\n\tif (!walker->stop) {\n\t\ttc_qdisc_stats_dump(sch, 1, walker);\n\t}\n}\n\nstatic const struct Qdisc_class_ops cbs_class_ops = {\n\t.graft\t\t=\tcbs_graft,\n\t.leaf\t\t=\tcbs_leaf,\n\t.find\t\t=\tcbs_find,\n\t.walk\t\t=\tcbs_walk,\n\t.dump\t\t=\tcbs_dump_class,\n};\n\nstatic struct Qdisc_ops cbs_qdisc_ops __read_mostly = {\n\t.id\t\t=\t\"cbs\",\n\t.cl_ops\t\t=\t&cbs_class_ops,\n\t.priv_size\t=\tsizeof(struct cbs_sched_data),\n\t.enqueue\t=\tcbs_enqueue,\n\t.dequeue\t=\tcbs_dequeue,\n\t.peek\t\t=\tqdisc_peek_dequeued,\n\t.init\t\t=\tcbs_init,\n\t.reset\t\t=\tqdisc_reset_queue,\n\t.destroy\t=\tcbs_destroy,\n\t.change\t\t=\tcbs_change,\n\t.dump\t\t=\tcbs_dump,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic struct notifier_block cbs_device_notifier = {\n\t.notifier_call = cbs_dev_notifier,\n};\n\nstatic int __init cbs_module_init(void)\n{\n\tint err;\n\n\terr = register_netdevice_notifier(&cbs_device_notifier);\n\tif (err)\n\t\treturn err;\n\n\terr = register_qdisc(&cbs_qdisc_ops);\n\tif (err)\n\t\tunregister_netdevice_notifier(&cbs_device_notifier);\n\n\treturn err;\n}\n\nstatic void __exit cbs_module_exit(void)\n{\n\tunregister_qdisc(&cbs_qdisc_ops);\n\tunregister_netdevice_notifier(&cbs_device_notifier);\n}\nmodule_init(cbs_module_init)\nmodule_exit(cbs_module_exit)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}