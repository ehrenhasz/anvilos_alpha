{
  "module_name": "sch_api.c",
  "hash_id": "55c7d60b60dbf834cd82de62abf7629ebf4ec8076f0d3485246f320da59c858d",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_api.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/kmod.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <net/tc_wrapper.h>\n\n#include <trace/events/qdisc.h>\n\n \n\n \nstatic DEFINE_RWLOCK(qdisc_mod_lock);\n\n\n \n\n\n \n\nstatic struct Qdisc_ops *qdisc_base;\n\n \n\nint register_qdisc(struct Qdisc_ops *qops)\n{\n\tstruct Qdisc_ops *q, **qp;\n\tint rc = -EEXIST;\n\n\twrite_lock(&qdisc_mod_lock);\n\tfor (qp = &qdisc_base; (q = *qp) != NULL; qp = &q->next)\n\t\tif (!strcmp(qops->id, q->id))\n\t\t\tgoto out;\n\n\tif (qops->enqueue == NULL)\n\t\tqops->enqueue = noop_qdisc_ops.enqueue;\n\tif (qops->peek == NULL) {\n\t\tif (qops->dequeue == NULL)\n\t\t\tqops->peek = noop_qdisc_ops.peek;\n\t\telse\n\t\t\tgoto out_einval;\n\t}\n\tif (qops->dequeue == NULL)\n\t\tqops->dequeue = noop_qdisc_ops.dequeue;\n\n\tif (qops->cl_ops) {\n\t\tconst struct Qdisc_class_ops *cops = qops->cl_ops;\n\n\t\tif (!(cops->find && cops->walk && cops->leaf))\n\t\t\tgoto out_einval;\n\n\t\tif (cops->tcf_block && !(cops->bind_tcf && cops->unbind_tcf))\n\t\t\tgoto out_einval;\n\t}\n\n\tqops->next = NULL;\n\t*qp = qops;\n\trc = 0;\nout:\n\twrite_unlock(&qdisc_mod_lock);\n\treturn rc;\n\nout_einval:\n\trc = -EINVAL;\n\tgoto out;\n}\nEXPORT_SYMBOL(register_qdisc);\n\nvoid unregister_qdisc(struct Qdisc_ops *qops)\n{\n\tstruct Qdisc_ops *q, **qp;\n\tint err = -ENOENT;\n\n\twrite_lock(&qdisc_mod_lock);\n\tfor (qp = &qdisc_base; (q = *qp) != NULL; qp = &q->next)\n\t\tif (q == qops)\n\t\t\tbreak;\n\tif (q) {\n\t\t*qp = q->next;\n\t\tq->next = NULL;\n\t\terr = 0;\n\t}\n\twrite_unlock(&qdisc_mod_lock);\n\n\tWARN(err, \"unregister qdisc(%s) failed\\n\", qops->id);\n}\nEXPORT_SYMBOL(unregister_qdisc);\n\n \nvoid qdisc_get_default(char *name, size_t len)\n{\n\tread_lock(&qdisc_mod_lock);\n\tstrscpy(name, default_qdisc_ops->id, len);\n\tread_unlock(&qdisc_mod_lock);\n}\n\nstatic struct Qdisc_ops *qdisc_lookup_default(const char *name)\n{\n\tstruct Qdisc_ops *q = NULL;\n\n\tfor (q = qdisc_base; q; q = q->next) {\n\t\tif (!strcmp(name, q->id)) {\n\t\t\tif (!try_module_get(q->owner))\n\t\t\t\tq = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn q;\n}\n\n \nint qdisc_set_default(const char *name)\n{\n\tconst struct Qdisc_ops *ops;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\twrite_lock(&qdisc_mod_lock);\n\tops = qdisc_lookup_default(name);\n\tif (!ops) {\n\t\t \n\t\twrite_unlock(&qdisc_mod_lock);\n\t\trequest_module(\"sch_%s\", name);\n\t\twrite_lock(&qdisc_mod_lock);\n\n\t\tops = qdisc_lookup_default(name);\n\t}\n\n\tif (ops) {\n\t\t \n\t\tmodule_put(default_qdisc_ops->owner);\n\t\tdefault_qdisc_ops = ops;\n\t}\n\twrite_unlock(&qdisc_mod_lock);\n\n\treturn ops ? 0 : -ENOENT;\n}\n\n#ifdef CONFIG_NET_SCH_DEFAULT\n \nstatic int __init sch_default_qdisc(void)\n{\n\treturn qdisc_set_default(CONFIG_DEFAULT_NET_SCH);\n}\nlate_initcall(sch_default_qdisc);\n#endif\n\n \n\nstatic struct Qdisc *qdisc_match_from_root(struct Qdisc *root, u32 handle)\n{\n\tstruct Qdisc *q;\n\n\tif (!qdisc_dev(root))\n\t\treturn (root->handle == handle ? root : NULL);\n\n\tif (!(root->flags & TCQ_F_BUILTIN) &&\n\t    root->handle == handle)\n\t\treturn root;\n\n\thash_for_each_possible_rcu(qdisc_dev(root)->qdisc_hash, q, hash, handle,\n\t\t\t\t   lockdep_rtnl_is_held()) {\n\t\tif (q->handle == handle)\n\t\t\treturn q;\n\t}\n\treturn NULL;\n}\n\nvoid qdisc_hash_add(struct Qdisc *q, bool invisible)\n{\n\tif ((q->parent != TC_H_ROOT) && !(q->flags & TCQ_F_INGRESS)) {\n\t\tASSERT_RTNL();\n\t\thash_add_rcu(qdisc_dev(q)->qdisc_hash, &q->hash, q->handle);\n\t\tif (invisible)\n\t\t\tq->flags |= TCQ_F_INVISIBLE;\n\t}\n}\nEXPORT_SYMBOL(qdisc_hash_add);\n\nvoid qdisc_hash_del(struct Qdisc *q)\n{\n\tif ((q->parent != TC_H_ROOT) && !(q->flags & TCQ_F_INGRESS)) {\n\t\tASSERT_RTNL();\n\t\thash_del_rcu(&q->hash);\n\t}\n}\nEXPORT_SYMBOL(qdisc_hash_del);\n\nstruct Qdisc *qdisc_lookup(struct net_device *dev, u32 handle)\n{\n\tstruct Qdisc *q;\n\n\tif (!handle)\n\t\treturn NULL;\n\tq = qdisc_match_from_root(rtnl_dereference(dev->qdisc), handle);\n\tif (q)\n\t\tgoto out;\n\n\tif (dev_ingress_queue(dev))\n\t\tq = qdisc_match_from_root(\n\t\t\trtnl_dereference(dev_ingress_queue(dev)->qdisc_sleeping),\n\t\t\thandle);\nout:\n\treturn q;\n}\n\nstruct Qdisc *qdisc_lookup_rcu(struct net_device *dev, u32 handle)\n{\n\tstruct netdev_queue *nq;\n\tstruct Qdisc *q;\n\n\tif (!handle)\n\t\treturn NULL;\n\tq = qdisc_match_from_root(rcu_dereference(dev->qdisc), handle);\n\tif (q)\n\t\tgoto out;\n\n\tnq = dev_ingress_queue_rcu(dev);\n\tif (nq)\n\t\tq = qdisc_match_from_root(rcu_dereference(nq->qdisc_sleeping),\n\t\t\t\t\t  handle);\nout:\n\treturn q;\n}\n\nstatic struct Qdisc *qdisc_leaf(struct Qdisc *p, u32 classid)\n{\n\tunsigned long cl;\n\tconst struct Qdisc_class_ops *cops = p->ops->cl_ops;\n\n\tif (cops == NULL)\n\t\treturn NULL;\n\tcl = cops->find(p, classid);\n\n\tif (cl == 0)\n\t\treturn NULL;\n\treturn cops->leaf(p, cl);\n}\n\n \n\nstatic struct Qdisc_ops *qdisc_lookup_ops(struct nlattr *kind)\n{\n\tstruct Qdisc_ops *q = NULL;\n\n\tif (kind) {\n\t\tread_lock(&qdisc_mod_lock);\n\t\tfor (q = qdisc_base; q; q = q->next) {\n\t\t\tif (nla_strcmp(kind, q->id) == 0) {\n\t\t\t\tif (!try_module_get(q->owner))\n\t\t\t\t\tq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tread_unlock(&qdisc_mod_lock);\n\t}\n\treturn q;\n}\n\n \nstatic __u8 __detect_linklayer(struct tc_ratespec *r, __u32 *rtab)\n{\n\tint low       = roundup(r->mpu, 48);\n\tint high      = roundup(low+1, 48);\n\tint cell_low  = low >> r->cell_log;\n\tint cell_high = (high >> r->cell_log) - 1;\n\n\t \n\tif ((r->rate > (100000000/8)) || (rtab[0] == 0)) {\n\t\tpr_debug(\"TC linklayer: Giving up ATM detection\\n\");\n\t\treturn TC_LINKLAYER_ETHERNET;\n\t}\n\n\tif ((cell_high > cell_low) && (cell_high < 256)\n\t    && (rtab[cell_low] == rtab[cell_high])) {\n\t\tpr_debug(\"TC linklayer: Detected ATM, low(%d)=high(%d)=%u\\n\",\n\t\t\t cell_low, cell_high, rtab[cell_high]);\n\t\treturn TC_LINKLAYER_ATM;\n\t}\n\treturn TC_LINKLAYER_ETHERNET;\n}\n\nstatic struct qdisc_rate_table *qdisc_rtab_list;\n\nstruct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r,\n\t\t\t\t\tstruct nlattr *tab,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct qdisc_rate_table *rtab;\n\n\tif (tab == NULL || r->rate == 0 ||\n\t    r->cell_log == 0 || r->cell_log >= 32 ||\n\t    nla_len(tab) != TC_RTAB_SIZE) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid rate table parameters for searching\");\n\t\treturn NULL;\n\t}\n\n\tfor (rtab = qdisc_rtab_list; rtab; rtab = rtab->next) {\n\t\tif (!memcmp(&rtab->rate, r, sizeof(struct tc_ratespec)) &&\n\t\t    !memcmp(&rtab->data, nla_data(tab), 1024)) {\n\t\t\trtab->refcnt++;\n\t\t\treturn rtab;\n\t\t}\n\t}\n\n\trtab = kmalloc(sizeof(*rtab), GFP_KERNEL);\n\tif (rtab) {\n\t\trtab->rate = *r;\n\t\trtab->refcnt = 1;\n\t\tmemcpy(rtab->data, nla_data(tab), 1024);\n\t\tif (r->linklayer == TC_LINKLAYER_UNAWARE)\n\t\t\tr->linklayer = __detect_linklayer(r, rtab->data);\n\t\trtab->next = qdisc_rtab_list;\n\t\tqdisc_rtab_list = rtab;\n\t} else {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to allocate new qdisc rate table\");\n\t}\n\treturn rtab;\n}\nEXPORT_SYMBOL(qdisc_get_rtab);\n\nvoid qdisc_put_rtab(struct qdisc_rate_table *tab)\n{\n\tstruct qdisc_rate_table *rtab, **rtabp;\n\n\tif (!tab || --tab->refcnt)\n\t\treturn;\n\n\tfor (rtabp = &qdisc_rtab_list;\n\t     (rtab = *rtabp) != NULL;\n\t     rtabp = &rtab->next) {\n\t\tif (rtab == tab) {\n\t\t\t*rtabp = rtab->next;\n\t\t\tkfree(rtab);\n\t\t\treturn;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(qdisc_put_rtab);\n\nstatic LIST_HEAD(qdisc_stab_list);\n\nstatic const struct nla_policy stab_policy[TCA_STAB_MAX + 1] = {\n\t[TCA_STAB_BASE]\t= { .len = sizeof(struct tc_sizespec) },\n\t[TCA_STAB_DATA] = { .type = NLA_BINARY },\n};\n\nstatic struct qdisc_size_table *qdisc_get_stab(struct nlattr *opt,\n\t\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_STAB_MAX + 1];\n\tstruct qdisc_size_table *stab;\n\tstruct tc_sizespec *s;\n\tunsigned int tsize = 0;\n\tu16 *tab = NULL;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_STAB_MAX, opt, stab_policy,\n\t\t\t\t\t  extack);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\tif (!tb[TCA_STAB_BASE]) {\n\t\tNL_SET_ERR_MSG(extack, \"Size table base attribute is missing\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ts = nla_data(tb[TCA_STAB_BASE]);\n\n\tif (s->tsize > 0) {\n\t\tif (!tb[TCA_STAB_DATA]) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Size table data attribute is missing\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\ttab = nla_data(tb[TCA_STAB_DATA]);\n\t\ttsize = nla_len(tb[TCA_STAB_DATA]) / sizeof(u16);\n\t}\n\n\tif (tsize != s->tsize || (!tab && tsize > 0)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid size of size table\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlist_for_each_entry(stab, &qdisc_stab_list, list) {\n\t\tif (memcmp(&stab->szopts, s, sizeof(*s)))\n\t\t\tcontinue;\n\t\tif (tsize > 0 &&\n\t\t    memcmp(stab->data, tab, flex_array_size(stab, data, tsize)))\n\t\t\tcontinue;\n\t\tstab->refcnt++;\n\t\treturn stab;\n\t}\n\n\tif (s->size_log > STAB_SIZE_LOG_MAX ||\n\t    s->cell_log > STAB_SIZE_LOG_MAX) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid logarithmic size of size table\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tstab = kmalloc(struct_size(stab, data, tsize), GFP_KERNEL);\n\tif (!stab)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstab->refcnt = 1;\n\tstab->szopts = *s;\n\tif (tsize > 0)\n\t\tmemcpy(stab->data, tab, flex_array_size(stab, data, tsize));\n\n\tlist_add_tail(&stab->list, &qdisc_stab_list);\n\n\treturn stab;\n}\n\nvoid qdisc_put_stab(struct qdisc_size_table *tab)\n{\n\tif (!tab)\n\t\treturn;\n\n\tif (--tab->refcnt == 0) {\n\t\tlist_del(&tab->list);\n\t\tkfree_rcu(tab, rcu);\n\t}\n}\nEXPORT_SYMBOL(qdisc_put_stab);\n\nstatic int qdisc_dump_stab(struct sk_buff *skb, struct qdisc_size_table *stab)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, TCA_STAB);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\tif (nla_put(skb, TCA_STAB_BASE, sizeof(stab->szopts), &stab->szopts))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\n\treturn skb->len;\n\nnla_put_failure:\n\treturn -1;\n}\n\nvoid __qdisc_calculate_pkt_len(struct sk_buff *skb,\n\t\t\t       const struct qdisc_size_table *stab)\n{\n\tint pkt_len, slot;\n\n\tpkt_len = skb->len + stab->szopts.overhead;\n\tif (unlikely(!stab->szopts.tsize))\n\t\tgoto out;\n\n\tslot = pkt_len + stab->szopts.cell_align;\n\tif (unlikely(slot < 0))\n\t\tslot = 0;\n\n\tslot >>= stab->szopts.cell_log;\n\tif (likely(slot < stab->szopts.tsize))\n\t\tpkt_len = stab->data[slot];\n\telse\n\t\tpkt_len = stab->data[stab->szopts.tsize - 1] *\n\t\t\t\t(slot / stab->szopts.tsize) +\n\t\t\t\tstab->data[slot % stab->szopts.tsize];\n\n\tpkt_len <<= stab->szopts.size_log;\nout:\n\tif (unlikely(pkt_len < 1))\n\t\tpkt_len = 1;\n\tqdisc_skb_cb(skb)->pkt_len = pkt_len;\n}\nEXPORT_SYMBOL(__qdisc_calculate_pkt_len);\n\nvoid qdisc_warn_nonwc(const char *txt, struct Qdisc *qdisc)\n{\n\tif (!(qdisc->flags & TCQ_F_WARN_NONWC)) {\n\t\tpr_warn(\"%s: %s qdisc %X: is non-work-conserving?\\n\",\n\t\t\ttxt, qdisc->ops->id, qdisc->handle >> 16);\n\t\tqdisc->flags |= TCQ_F_WARN_NONWC;\n\t}\n}\nEXPORT_SYMBOL(qdisc_warn_nonwc);\n\nstatic enum hrtimer_restart qdisc_watchdog(struct hrtimer *timer)\n{\n\tstruct qdisc_watchdog *wd = container_of(timer, struct qdisc_watchdog,\n\t\t\t\t\t\t timer);\n\n\trcu_read_lock();\n\t__netif_schedule(qdisc_root(wd->qdisc));\n\trcu_read_unlock();\n\n\treturn HRTIMER_NORESTART;\n}\n\nvoid qdisc_watchdog_init_clockid(struct qdisc_watchdog *wd, struct Qdisc *qdisc,\n\t\t\t\t clockid_t clockid)\n{\n\thrtimer_init(&wd->timer, clockid, HRTIMER_MODE_ABS_PINNED);\n\twd->timer.function = qdisc_watchdog;\n\twd->qdisc = qdisc;\n}\nEXPORT_SYMBOL(qdisc_watchdog_init_clockid);\n\nvoid qdisc_watchdog_init(struct qdisc_watchdog *wd, struct Qdisc *qdisc)\n{\n\tqdisc_watchdog_init_clockid(wd, qdisc, CLOCK_MONOTONIC);\n}\nEXPORT_SYMBOL(qdisc_watchdog_init);\n\nvoid qdisc_watchdog_schedule_range_ns(struct qdisc_watchdog *wd, u64 expires,\n\t\t\t\t      u64 delta_ns)\n{\n\tbool deactivated;\n\n\trcu_read_lock();\n\tdeactivated = test_bit(__QDISC_STATE_DEACTIVATED,\n\t\t\t       &qdisc_root_sleeping(wd->qdisc)->state);\n\trcu_read_unlock();\n\tif (deactivated)\n\t\treturn;\n\n\tif (hrtimer_is_queued(&wd->timer)) {\n\t\tu64 softexpires;\n\n\t\tsoftexpires = ktime_to_ns(hrtimer_get_softexpires(&wd->timer));\n\t\t \n\t\tif (softexpires - expires <= delta_ns)\n\t\t\treturn;\n\t}\n\n\thrtimer_start_range_ns(&wd->timer,\n\t\t\t       ns_to_ktime(expires),\n\t\t\t       delta_ns,\n\t\t\t       HRTIMER_MODE_ABS_PINNED);\n}\nEXPORT_SYMBOL(qdisc_watchdog_schedule_range_ns);\n\nvoid qdisc_watchdog_cancel(struct qdisc_watchdog *wd)\n{\n\thrtimer_cancel(&wd->timer);\n}\nEXPORT_SYMBOL(qdisc_watchdog_cancel);\n\nstatic struct hlist_head *qdisc_class_hash_alloc(unsigned int n)\n{\n\tstruct hlist_head *h;\n\tunsigned int i;\n\n\th = kvmalloc_array(n, sizeof(struct hlist_head), GFP_KERNEL);\n\n\tif (h != NULL) {\n\t\tfor (i = 0; i < n; i++)\n\t\t\tINIT_HLIST_HEAD(&h[i]);\n\t}\n\treturn h;\n}\n\nvoid qdisc_class_hash_grow(struct Qdisc *sch, struct Qdisc_class_hash *clhash)\n{\n\tstruct Qdisc_class_common *cl;\n\tstruct hlist_node *next;\n\tstruct hlist_head *nhash, *ohash;\n\tunsigned int nsize, nmask, osize;\n\tunsigned int i, h;\n\n\t \n\tif (clhash->hashelems * 4 <= clhash->hashsize * 3)\n\t\treturn;\n\tnsize = clhash->hashsize * 2;\n\tnmask = nsize - 1;\n\tnhash = qdisc_class_hash_alloc(nsize);\n\tif (nhash == NULL)\n\t\treturn;\n\n\tohash = clhash->hash;\n\tosize = clhash->hashsize;\n\n\tsch_tree_lock(sch);\n\tfor (i = 0; i < osize; i++) {\n\t\thlist_for_each_entry_safe(cl, next, &ohash[i], hnode) {\n\t\t\th = qdisc_class_hash(cl->classid, nmask);\n\t\t\thlist_add_head(&cl->hnode, &nhash[h]);\n\t\t}\n\t}\n\tclhash->hash     = nhash;\n\tclhash->hashsize = nsize;\n\tclhash->hashmask = nmask;\n\tsch_tree_unlock(sch);\n\n\tkvfree(ohash);\n}\nEXPORT_SYMBOL(qdisc_class_hash_grow);\n\nint qdisc_class_hash_init(struct Qdisc_class_hash *clhash)\n{\n\tunsigned int size = 4;\n\n\tclhash->hash = qdisc_class_hash_alloc(size);\n\tif (!clhash->hash)\n\t\treturn -ENOMEM;\n\tclhash->hashsize  = size;\n\tclhash->hashmask  = size - 1;\n\tclhash->hashelems = 0;\n\treturn 0;\n}\nEXPORT_SYMBOL(qdisc_class_hash_init);\n\nvoid qdisc_class_hash_destroy(struct Qdisc_class_hash *clhash)\n{\n\tkvfree(clhash->hash);\n}\nEXPORT_SYMBOL(qdisc_class_hash_destroy);\n\nvoid qdisc_class_hash_insert(struct Qdisc_class_hash *clhash,\n\t\t\t     struct Qdisc_class_common *cl)\n{\n\tunsigned int h;\n\n\tINIT_HLIST_NODE(&cl->hnode);\n\th = qdisc_class_hash(cl->classid, clhash->hashmask);\n\thlist_add_head(&cl->hnode, &clhash->hash[h]);\n\tclhash->hashelems++;\n}\nEXPORT_SYMBOL(qdisc_class_hash_insert);\n\nvoid qdisc_class_hash_remove(struct Qdisc_class_hash *clhash,\n\t\t\t     struct Qdisc_class_common *cl)\n{\n\thlist_del(&cl->hnode);\n\tclhash->hashelems--;\n}\nEXPORT_SYMBOL(qdisc_class_hash_remove);\n\n \nstatic u32 qdisc_alloc_handle(struct net_device *dev)\n{\n\tint i = 0x8000;\n\tstatic u32 autohandle = TC_H_MAKE(0x80000000U, 0);\n\n\tdo {\n\t\tautohandle += TC_H_MAKE(0x10000U, 0);\n\t\tif (autohandle == TC_H_MAKE(TC_H_ROOT, 0))\n\t\t\tautohandle = TC_H_MAKE(0x80000000U, 0);\n\t\tif (!qdisc_lookup(dev, autohandle))\n\t\t\treturn autohandle;\n\t\tcond_resched();\n\t} while\t(--i > 0);\n\n\treturn 0;\n}\n\nvoid qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)\n{\n\tbool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;\n\tconst struct Qdisc_class_ops *cops;\n\tunsigned long cl;\n\tu32 parentid;\n\tbool notify;\n\tint drops;\n\n\tif (n == 0 && len == 0)\n\t\treturn;\n\tdrops = max_t(int, n, 0);\n\trcu_read_lock();\n\twhile ((parentid = sch->parent)) {\n\t\tif (TC_H_MAJ(parentid) == TC_H_MAJ(TC_H_INGRESS))\n\t\t\tbreak;\n\n\t\tif (sch->flags & TCQ_F_NOPARENT)\n\t\t\tbreak;\n\t\t \n\t\tnotify = !sch->q.qlen && !WARN_ON_ONCE(!n &&\n\t\t\t\t\t\t       !qdisc_is_offloaded);\n\t\t \n\t\tsch = qdisc_lookup(qdisc_dev(sch), TC_H_MAJ(parentid));\n\t\tif (sch == NULL) {\n\t\t\tWARN_ON_ONCE(parentid != TC_H_ROOT);\n\t\t\tbreak;\n\t\t}\n\t\tcops = sch->ops->cl_ops;\n\t\tif (notify && cops->qlen_notify) {\n\t\t\tcl = cops->find(sch, parentid);\n\t\t\tcops->qlen_notify(sch, cl);\n\t\t}\n\t\tsch->q.qlen -= n;\n\t\tsch->qstats.backlog -= len;\n\t\t__qdisc_qstats_drop(sch, drops);\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(qdisc_tree_reduce_backlog);\n\nint qdisc_offload_dump_helper(struct Qdisc *sch, enum tc_setup_type type,\n\t\t\t      void *type_data)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tint err;\n\n\tsch->flags &= ~TCQ_F_OFFLOADED;\n\tif (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)\n\t\treturn 0;\n\n\terr = dev->netdev_ops->ndo_setup_tc(dev, type, type_data);\n\tif (err == -EOPNOTSUPP)\n\t\treturn 0;\n\n\tif (!err)\n\t\tsch->flags |= TCQ_F_OFFLOADED;\n\n\treturn err;\n}\nEXPORT_SYMBOL(qdisc_offload_dump_helper);\n\nvoid qdisc_offload_graft_helper(struct net_device *dev, struct Qdisc *sch,\n\t\t\t\tstruct Qdisc *new, struct Qdisc *old,\n\t\t\t\tenum tc_setup_type type, void *type_data,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbool any_qdisc_is_offloaded;\n\tint err;\n\n\tif (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)\n\t\treturn;\n\n\terr = dev->netdev_ops->ndo_setup_tc(dev, type, type_data);\n\n\t \n\tif (!err || !new || new == &noop_qdisc)\n\t\treturn;\n\n\t \n\tany_qdisc_is_offloaded = new->flags & TCQ_F_OFFLOADED;\n\tany_qdisc_is_offloaded |= sch && sch->flags & TCQ_F_OFFLOADED;\n\tany_qdisc_is_offloaded |= old && old->flags & TCQ_F_OFFLOADED;\n\n\tif (any_qdisc_is_offloaded)\n\t\tNL_SET_ERR_MSG(extack, \"Offloading graft operation failed.\");\n}\nEXPORT_SYMBOL(qdisc_offload_graft_helper);\n\nvoid qdisc_offload_query_caps(struct net_device *dev,\n\t\t\t      enum tc_setup_type type,\n\t\t\t      void *caps, size_t caps_len)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tstruct tc_query_caps_base base = {\n\t\t.type = type,\n\t\t.caps = caps,\n\t};\n\n\tmemset(caps, 0, caps_len);\n\n\tif (ops->ndo_setup_tc)\n\t\tops->ndo_setup_tc(dev, TC_QUERY_CAPS, &base);\n}\nEXPORT_SYMBOL(qdisc_offload_query_caps);\n\nstatic void qdisc_offload_graft_root(struct net_device *dev,\n\t\t\t\t     struct Qdisc *new, struct Qdisc *old,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct tc_root_qopt_offload graft_offload = {\n\t\t.command\t= TC_ROOT_GRAFT,\n\t\t.handle\t\t= new ? new->handle : 0,\n\t\t.ingress\t= (new && new->flags & TCQ_F_INGRESS) ||\n\t\t\t\t  (old && old->flags & TCQ_F_INGRESS),\n\t};\n\n\tqdisc_offload_graft_helper(dev, NULL, new, old,\n\t\t\t\t   TC_SETUP_ROOT_QDISC, &graft_offload, extack);\n}\n\nstatic int tc_fill_qdisc(struct sk_buff *skb, struct Qdisc *q, u32 clid,\n\t\t\t u32 portid, u32 seq, u16 flags, int event,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct gnet_stats_basic_sync __percpu *cpu_bstats = NULL;\n\tstruct gnet_stats_queue __percpu *cpu_qstats = NULL;\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tstruct qdisc_size_table *stab;\n\tu32 block_index;\n\t__u32 qlen;\n\n\tcond_resched();\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*tcm), flags);\n\tif (!nlh)\n\t\tgoto out_nlmsg_trim;\n\ttcm = nlmsg_data(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad2 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = clid;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = refcount_read(&q->refcnt);\n\tif (nla_put_string(skb, TCA_KIND, q->ops->id))\n\t\tgoto nla_put_failure;\n\tif (q->ops->ingress_block_get) {\n\t\tblock_index = q->ops->ingress_block_get(q);\n\t\tif (block_index &&\n\t\t    nla_put_u32(skb, TCA_INGRESS_BLOCK, block_index))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (q->ops->egress_block_get) {\n\t\tblock_index = q->ops->egress_block_get(q);\n\t\tif (block_index &&\n\t\t    nla_put_u32(skb, TCA_EGRESS_BLOCK, block_index))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (q->ops->dump && q->ops->dump(q, skb) < 0)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, TCA_HW_OFFLOAD, !!(q->flags & TCQ_F_OFFLOADED)))\n\t\tgoto nla_put_failure;\n\tqlen = qdisc_qlen_sum(q);\n\n\tstab = rtnl_dereference(q->stab);\n\tif (stab && qdisc_dump_stab(skb, stab) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t NULL, &d, TCA_PAD) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (q->ops->dump_stats && q->ops->dump_stats(q, &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (qdisc_is_percpu_stats(q)) {\n\t\tcpu_bstats = q->cpu_bstats;\n\t\tcpu_qstats = q->cpu_qstats;\n\t}\n\n\tif (gnet_stats_copy_basic(&d, cpu_bstats, &q->bstats, true) < 0 ||\n\t    gnet_stats_copy_rate_est(&d, &q->rate_est) < 0 ||\n\t    gnet_stats_copy_queue(&d, cpu_qstats, &q->qstats, qlen) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (extack && extack->_msg &&\n\t    nla_put_string(skb, TCA_EXT_WARN_MSG, extack->_msg))\n\t\tgoto out_nlmsg_trim;\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\n\treturn skb->len;\n\nout_nlmsg_trim:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic bool tc_qdisc_dump_ignore(struct Qdisc *q, bool dump_invisible)\n{\n\tif (q->flags & TCQ_F_BUILTIN)\n\t\treturn true;\n\tif ((q->flags & TCQ_F_INVISIBLE) && !dump_invisible)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int qdisc_notify(struct net *net, struct sk_buff *oskb,\n\t\t\tstruct nlmsghdr *n, u32 clid,\n\t\t\tstruct Qdisc *old, struct Qdisc *new,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct sk_buff *skb;\n\tu32 portid = oskb ? NETLINK_CB(oskb).portid : 0;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (old && !tc_qdisc_dump_ignore(old, false)) {\n\t\tif (tc_fill_qdisc(skb, old, clid, portid, n->nlmsg_seq,\n\t\t\t\t  0, RTM_DELQDISC, extack) < 0)\n\t\t\tgoto err_out;\n\t}\n\tif (new && !tc_qdisc_dump_ignore(new, false)) {\n\t\tif (tc_fill_qdisc(skb, new, clid, portid, n->nlmsg_seq,\n\t\t\t\t  old ? NLM_F_REPLACE : 0, RTM_NEWQDISC, extack) < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tif (skb->len)\n\t\treturn rtnetlink_send(skb, net, portid, RTNLGRP_TC,\n\t\t\t\t      n->nlmsg_flags & NLM_F_ECHO);\n\nerr_out:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic void notify_and_destroy(struct net *net, struct sk_buff *skb,\n\t\t\t       struct nlmsghdr *n, u32 clid,\n\t\t\t       struct Qdisc *old, struct Qdisc *new,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (new || old)\n\t\tqdisc_notify(net, skb, n, clid, old, new, extack);\n\n\tif (old)\n\t\tqdisc_put(old);\n}\n\nstatic void qdisc_clear_nolock(struct Qdisc *sch)\n{\n\tsch->flags &= ~TCQ_F_NOLOCK;\n\tif (!(sch->flags & TCQ_F_CPUSTATS))\n\t\treturn;\n\n\tfree_percpu(sch->cpu_bstats);\n\tfree_percpu(sch->cpu_qstats);\n\tsch->cpu_bstats = NULL;\n\tsch->cpu_qstats = NULL;\n\tsch->flags &= ~TCQ_F_CPUSTATS;\n}\n\n \n\nstatic int qdisc_graft(struct net_device *dev, struct Qdisc *parent,\n\t\t       struct sk_buff *skb, struct nlmsghdr *n, u32 classid,\n\t\t       struct Qdisc *new, struct Qdisc *old,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct Qdisc *q = old;\n\tstruct net *net = dev_net(dev);\n\n\tif (parent == NULL) {\n\t\tunsigned int i, num_q, ingress;\n\t\tstruct netdev_queue *dev_queue;\n\n\t\tingress = 0;\n\t\tnum_q = dev->num_tx_queues;\n\t\tif ((q && q->flags & TCQ_F_INGRESS) ||\n\t\t    (new && new->flags & TCQ_F_INGRESS)) {\n\t\t\tingress = 1;\n\t\t\tdev_queue = dev_ingress_queue(dev);\n\t\t\tif (!dev_queue) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Device does not have an ingress queue\");\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\tq = rtnl_dereference(dev_queue->qdisc_sleeping);\n\n\t\t\t \n\t\t\tif (!qdisc_refcount_dec_if_one(q)) {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"Current ingress or clsact Qdisc has ongoing filter requests\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\tdev_deactivate(dev);\n\n\t\tqdisc_offload_graft_root(dev, new, old, extack);\n\n\t\tif (new && new->ops->attach && !ingress)\n\t\t\tgoto skip;\n\n\t\tif (!ingress) {\n\t\t\tfor (i = 0; i < num_q; i++) {\n\t\t\t\tdev_queue = netdev_get_tx_queue(dev, i);\n\t\t\t\told = dev_graft_qdisc(dev_queue, new);\n\n\t\t\t\tif (new && i > 0)\n\t\t\t\t\tqdisc_refcount_inc(new);\n\t\t\t\tqdisc_put(old);\n\t\t\t}\n\t\t} else {\n\t\t\told = dev_graft_qdisc(dev_queue, NULL);\n\n\t\t\t \n\t\t\tqdisc_notify(net, skb, n, classid, old, new, extack);\n\t\t\tqdisc_destroy(old);\n\n\t\t\tdev_graft_qdisc(dev_queue, new);\n\t\t}\n\nskip:\n\t\tif (!ingress) {\n\t\t\told = rtnl_dereference(dev->qdisc);\n\t\t\tif (new && !new->ops->attach)\n\t\t\t\tqdisc_refcount_inc(new);\n\t\t\trcu_assign_pointer(dev->qdisc, new ? : &noop_qdisc);\n\n\t\t\tnotify_and_destroy(net, skb, n, classid, old, new, extack);\n\n\t\t\tif (new && new->ops->attach)\n\t\t\t\tnew->ops->attach(new);\n\t\t}\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\tdev_activate(dev);\n\t} else {\n\t\tconst struct Qdisc_class_ops *cops = parent->ops->cl_ops;\n\t\tunsigned long cl;\n\t\tint err;\n\n\t\t \n\t\tif (new && (new->flags & TCQ_F_NOLOCK) && !(parent->flags & TCQ_F_NOLOCK))\n\t\t\tqdisc_clear_nolock(new);\n\n\t\tif (!cops || !cops->graft)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tcl = cops->find(parent, classid);\n\t\tif (!cl) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Specified class not found\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (new && new->ops == &noqueue_qdisc_ops) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot assign noqueue to a class\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = cops->graft(parent, cl, new, &old, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tnotify_and_destroy(net, skb, n, classid, old, new, extack);\n\t}\n\treturn 0;\n}\n\nstatic int qdisc_block_indexes_set(struct Qdisc *sch, struct nlattr **tca,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tu32 block_index;\n\n\tif (tca[TCA_INGRESS_BLOCK]) {\n\t\tblock_index = nla_get_u32(tca[TCA_INGRESS_BLOCK]);\n\n\t\tif (!block_index) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Ingress block index cannot be 0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!sch->ops->ingress_block_set) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Ingress block sharing is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tsch->ops->ingress_block_set(sch, block_index);\n\t}\n\tif (tca[TCA_EGRESS_BLOCK]) {\n\t\tblock_index = nla_get_u32(tca[TCA_EGRESS_BLOCK]);\n\n\t\tif (!block_index) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Egress block index cannot be 0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!sch->ops->egress_block_set) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Egress block sharing is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tsch->ops->egress_block_set(sch, block_index);\n\t}\n\treturn 0;\n}\n\n \n\nstatic struct Qdisc *qdisc_create(struct net_device *dev,\n\t\t\t\t  struct netdev_queue *dev_queue,\n\t\t\t\t  u32 parent, u32 handle,\n\t\t\t\t  struct nlattr **tca, int *errp,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tint err;\n\tstruct nlattr *kind = tca[TCA_KIND];\n\tstruct Qdisc *sch;\n\tstruct Qdisc_ops *ops;\n\tstruct qdisc_size_table *stab;\n\n\tops = qdisc_lookup_ops(kind);\n#ifdef CONFIG_MODULES\n\tif (ops == NULL && kind != NULL) {\n\t\tchar name[IFNAMSIZ];\n\t\tif (nla_strscpy(name, kind, IFNAMSIZ) >= 0) {\n\t\t\t \n\t\t\trtnl_unlock();\n\t\t\trequest_module(\"sch_%s\", name);\n\t\t\trtnl_lock();\n\t\t\tops = qdisc_lookup_ops(kind);\n\t\t\tif (ops != NULL) {\n\t\t\t\t \n\t\t\t\tmodule_put(ops->owner);\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\terr = -ENOENT;\n\tif (!ops) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified qdisc kind is unknown\");\n\t\tgoto err_out;\n\t}\n\n\tsch = qdisc_alloc(dev_queue, ops, extack);\n\tif (IS_ERR(sch)) {\n\t\terr = PTR_ERR(sch);\n\t\tgoto err_out2;\n\t}\n\n\tsch->parent = parent;\n\n\tif (handle == TC_H_INGRESS) {\n\t\tif (!(sch->flags & TCQ_F_INGRESS)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Specified parent ID is reserved for ingress and clsact Qdiscs\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out3;\n\t\t}\n\t\thandle = TC_H_MAKE(TC_H_INGRESS, 0);\n\t} else {\n\t\tif (handle == 0) {\n\t\t\thandle = qdisc_alloc_handle(dev);\n\t\t\tif (handle == 0) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Maximum number of qdisc handles was exceeded\");\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto err_out3;\n\t\t\t}\n\t\t}\n\t\tif (!netif_is_multiqueue(dev))\n\t\t\tsch->flags |= TCQ_F_ONETXQUEUE;\n\t}\n\n\tsch->handle = handle;\n\n\t \n\tif ((dev->priv_flags & IFF_NO_QUEUE) && (dev->tx_queue_len == 0)) {\n\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;\n\t\tnetdev_info(dev, \"Caught tx_queue_len zero misconfig\\n\");\n\t}\n\n\terr = qdisc_block_indexes_set(sch, tca, extack);\n\tif (err)\n\t\tgoto err_out3;\n\n\tif (tca[TCA_STAB]) {\n\t\tstab = qdisc_get_stab(tca[TCA_STAB], extack);\n\t\tif (IS_ERR(stab)) {\n\t\t\terr = PTR_ERR(stab);\n\t\t\tgoto err_out3;\n\t\t}\n\t\trcu_assign_pointer(sch->stab, stab);\n\t}\n\n\tif (ops->init) {\n\t\terr = ops->init(sch, tca[TCA_OPTIONS], extack);\n\t\tif (err != 0)\n\t\t\tgoto err_out4;\n\t}\n\n\tif (tca[TCA_RATE]) {\n\t\terr = -EOPNOTSUPP;\n\t\tif (sch->flags & TCQ_F_MQROOT) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot attach rate estimator to a multi-queue root qdisc\");\n\t\t\tgoto err_out4;\n\t\t}\n\n\t\terr = gen_new_estimator(&sch->bstats,\n\t\t\t\t\tsch->cpu_bstats,\n\t\t\t\t\t&sch->rate_est,\n\t\t\t\t\tNULL,\n\t\t\t\t\ttrue,\n\t\t\t\t\ttca[TCA_RATE]);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Failed to generate new estimator\");\n\t\t\tgoto err_out4;\n\t\t}\n\t}\n\n\tqdisc_hash_add(sch, false);\n\ttrace_qdisc_create(ops, dev, parent);\n\n\treturn sch;\n\nerr_out4:\n\t \n\tif (ops->destroy)\n\t\tops->destroy(sch);\n\tqdisc_put_stab(rtnl_dereference(sch->stab));\nerr_out3:\n\tnetdev_put(dev, &sch->dev_tracker);\n\tqdisc_free(sch);\nerr_out2:\n\tmodule_put(ops->owner);\nerr_out:\n\t*errp = err;\n\treturn NULL;\n}\n\nstatic int qdisc_change(struct Qdisc *sch, struct nlattr **tca,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct qdisc_size_table *ostab, *stab = NULL;\n\tint err = 0;\n\n\tif (tca[TCA_OPTIONS]) {\n\t\tif (!sch->ops->change) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Change operation not supported by specified qdisc\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tca[TCA_INGRESS_BLOCK] || tca[TCA_EGRESS_BLOCK]) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Change of blocks is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\terr = sch->ops->change(sch, tca[TCA_OPTIONS], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tca[TCA_STAB]) {\n\t\tstab = qdisc_get_stab(tca[TCA_STAB], extack);\n\t\tif (IS_ERR(stab))\n\t\t\treturn PTR_ERR(stab);\n\t}\n\n\tostab = rtnl_dereference(sch->stab);\n\trcu_assign_pointer(sch->stab, stab);\n\tqdisc_put_stab(ostab);\n\n\tif (tca[TCA_RATE]) {\n\t\t \n\t\tif (sch->flags & TCQ_F_MQROOT)\n\t\t\tgoto out;\n\t\tgen_replace_estimator(&sch->bstats,\n\t\t\t\t      sch->cpu_bstats,\n\t\t\t\t      &sch->rate_est,\n\t\t\t\t      NULL,\n\t\t\t\t      true,\n\t\t\t\t      tca[TCA_RATE]);\n\t}\nout:\n\treturn 0;\n}\n\nstruct check_loop_arg {\n\tstruct qdisc_walker\tw;\n\tstruct Qdisc\t\t*p;\n\tint\t\t\tdepth;\n};\n\nstatic int check_loop_fn(struct Qdisc *q, unsigned long cl,\n\t\t\t struct qdisc_walker *w);\n\nstatic int check_loop(struct Qdisc *q, struct Qdisc *p, int depth)\n{\n\tstruct check_loop_arg\targ;\n\n\tif (q->ops->cl_ops == NULL)\n\t\treturn 0;\n\n\targ.w.stop = arg.w.skip = arg.w.count = 0;\n\targ.w.fn = check_loop_fn;\n\targ.depth = depth;\n\targ.p = p;\n\tq->ops->cl_ops->walk(q, &arg.w);\n\treturn arg.w.stop ? -ELOOP : 0;\n}\n\nstatic int\ncheck_loop_fn(struct Qdisc *q, unsigned long cl, struct qdisc_walker *w)\n{\n\tstruct Qdisc *leaf;\n\tconst struct Qdisc_class_ops *cops = q->ops->cl_ops;\n\tstruct check_loop_arg *arg = (struct check_loop_arg *)w;\n\n\tleaf = cops->leaf(q, cl);\n\tif (leaf) {\n\t\tif (leaf == arg->p || arg->depth > 7)\n\t\t\treturn -ELOOP;\n\t\treturn check_loop(leaf, arg->p, arg->depth + 1);\n\t}\n\treturn 0;\n}\n\nconst struct nla_policy rtm_tca_policy[TCA_MAX + 1] = {\n\t[TCA_KIND]\t\t= { .type = NLA_STRING },\n\t[TCA_RATE]\t\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct tc_estimator) },\n\t[TCA_STAB]\t\t= { .type = NLA_NESTED },\n\t[TCA_DUMP_INVISIBLE]\t= { .type = NLA_FLAG },\n\t[TCA_CHAIN]\t\t= { .type = NLA_U32 },\n\t[TCA_INGRESS_BLOCK]\t= { .type = NLA_U32 },\n\t[TCA_EGRESS_BLOCK]\t= { .type = NLA_U32 },\n};\n\n \n\nstatic int tc_get_qdisc(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tcmsg *tcm = nlmsg_data(n);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tstruct net_device *dev;\n\tu32 clid;\n\tstruct Qdisc *q = NULL;\n\tstruct Qdisc *p = NULL;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*tcm), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev = __dev_get_by_index(net, tcm->tcm_ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tclid = tcm->tcm_parent;\n\tif (clid) {\n\t\tif (clid != TC_H_ROOT) {\n\t\t\tif (TC_H_MAJ(clid) != TC_H_MAJ(TC_H_INGRESS)) {\n\t\t\t\tp = qdisc_lookup(dev, TC_H_MAJ(clid));\n\t\t\t\tif (!p) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Failed to find qdisc with specified classid\");\n\t\t\t\t\treturn -ENOENT;\n\t\t\t\t}\n\t\t\t\tq = qdisc_leaf(p, clid);\n\t\t\t} else if (dev_ingress_queue(dev)) {\n\t\t\t\tq = rtnl_dereference(dev_ingress_queue(dev)->qdisc_sleeping);\n\t\t\t}\n\t\t} else {\n\t\t\tq = rtnl_dereference(dev->qdisc);\n\t\t}\n\t\tif (!q) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot find specified qdisc on specified device\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (tcm->tcm_handle && q->handle != tcm->tcm_handle) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid handle\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tq = qdisc_lookup(dev, tcm->tcm_handle);\n\t\tif (!q) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Failed to find qdisc with specified handle\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], q->ops->id)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid qdisc name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n->nlmsg_type == RTM_DELQDISC) {\n\t\tif (!clid) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Classid cannot be zero\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (q->handle == 0) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot delete qdisc with handle of zero\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\terr = qdisc_graft(dev, p, skb, n, clid, NULL, q, extack);\n\t\tif (err != 0)\n\t\t\treturn err;\n\t} else {\n\t\tqdisc_notify(net, skb, n, clid, NULL, q, NULL);\n\t}\n\treturn 0;\n}\n\nstatic bool req_create_or_replace(struct nlmsghdr *n)\n{\n\treturn (n->nlmsg_flags & NLM_F_CREATE &&\n\t\tn->nlmsg_flags & NLM_F_REPLACE);\n}\n\nstatic bool req_create_exclusive(struct nlmsghdr *n)\n{\n\treturn (n->nlmsg_flags & NLM_F_CREATE &&\n\t\tn->nlmsg_flags & NLM_F_EXCL);\n}\n\nstatic bool req_change(struct nlmsghdr *n)\n{\n\treturn (!(n->nlmsg_flags & NLM_F_CREATE) &&\n\t\t!(n->nlmsg_flags & NLM_F_REPLACE) &&\n\t\t!(n->nlmsg_flags & NLM_F_EXCL));\n}\n\n \nstatic int tc_modify_qdisc(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tcmsg *tcm;\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tstruct net_device *dev;\n\tu32 clid;\n\tstruct Qdisc *q, *p;\n\tint err;\n\nreplay:\n\t \n\terr = nlmsg_parse_deprecated(n, sizeof(*tcm), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\ttcm = nlmsg_data(n);\n\tclid = tcm->tcm_parent;\n\tq = p = NULL;\n\n\tdev = __dev_get_by_index(net, tcm->tcm_ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\n\tif (clid) {\n\t\tif (clid != TC_H_ROOT) {\n\t\t\tif (clid != TC_H_INGRESS) {\n\t\t\t\tp = qdisc_lookup(dev, TC_H_MAJ(clid));\n\t\t\t\tif (!p) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Failed to find specified qdisc\");\n\t\t\t\t\treturn -ENOENT;\n\t\t\t\t}\n\t\t\t\tq = qdisc_leaf(p, clid);\n\t\t\t} else if (dev_ingress_queue_create(dev)) {\n\t\t\t\tq = rtnl_dereference(dev_ingress_queue(dev)->qdisc_sleeping);\n\t\t\t}\n\t\t} else {\n\t\t\tq = rtnl_dereference(dev->qdisc);\n\t\t}\n\n\t\t \n\t\tif (q && q->handle == 0)\n\t\t\tq = NULL;\n\n\t\tif (!q || !tcm->tcm_handle || q->handle != tcm->tcm_handle) {\n\t\t\tif (tcm->tcm_handle) {\n\t\t\t\tif (q && !(n->nlmsg_flags & NLM_F_REPLACE)) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"NLM_F_REPLACE needed to override\");\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tif (TC_H_MIN(tcm->tcm_handle)) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid minor handle\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tq = qdisc_lookup(dev, tcm->tcm_handle);\n\t\t\t\tif (!q)\n\t\t\t\t\tgoto create_n_graft;\n\t\t\t\tif (n->nlmsg_flags & NLM_F_EXCL) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Exclusivity flag on, cannot override\");\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\tif (tca[TCA_KIND] &&\n\t\t\t\t    nla_strcmp(tca[TCA_KIND], q->ops->id)) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid qdisc name\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif (q->flags & TCQ_F_INGRESS) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t\t       \"Cannot regraft ingress or clsact Qdiscs\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif (q == p ||\n\t\t\t\t    (p && check_loop(q, p, 0))) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Qdisc parent/child loop detected\");\n\t\t\t\t\treturn -ELOOP;\n\t\t\t\t}\n\t\t\t\tif (clid == TC_H_INGRESS) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Ingress cannot graft directly\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tqdisc_refcount_inc(q);\n\t\t\t\tgoto graft;\n\t\t\t} else {\n\t\t\t\tif (!q)\n\t\t\t\t\tgoto create_n_graft;\n\n\t\t\t\t \n\t\t\t\tif (tca[TCA_KIND] &&\n\t\t\t\t    nla_strcmp(tca[TCA_KIND], q->ops->id)) {\n\t\t\t\t\tif (req_create_or_replace(n) ||\n\t\t\t\t\t    req_create_exclusive(n))\n\t\t\t\t\t\tgoto create_n_graft;\n\t\t\t\t\telse if (req_change(n))\n\t\t\t\t\t\tgoto create_n_graft2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!tcm->tcm_handle) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Handle cannot be zero\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tq = qdisc_lookup(dev, tcm->tcm_handle);\n\t}\n\n\t \n\tif (!q) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified qdisc not found\");\n\t\treturn -ENOENT;\n\t}\n\tif (n->nlmsg_flags & NLM_F_EXCL) {\n\t\tNL_SET_ERR_MSG(extack, \"Exclusivity flag on, cannot modify\");\n\t\treturn -EEXIST;\n\t}\n\tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], q->ops->id)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid qdisc name\");\n\t\treturn -EINVAL;\n\t}\n\terr = qdisc_change(q, tca, extack);\n\tif (err == 0)\n\t\tqdisc_notify(net, skb, n, clid, NULL, q, extack);\n\treturn err;\n\ncreate_n_graft:\n\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\tNL_SET_ERR_MSG(extack, \"Qdisc not found. To create specify NLM_F_CREATE flag\");\n\t\treturn -ENOENT;\n\t}\ncreate_n_graft2:\n\tif (clid == TC_H_INGRESS) {\n\t\tif (dev_ingress_queue(dev)) {\n\t\t\tq = qdisc_create(dev, dev_ingress_queue(dev),\n\t\t\t\t\t tcm->tcm_parent, tcm->tcm_parent,\n\t\t\t\t\t tca, &err, extack);\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot find ingress queue for specified device\");\n\t\t\terr = -ENOENT;\n\t\t}\n\t} else {\n\t\tstruct netdev_queue *dev_queue;\n\n\t\tif (p && p->ops->cl_ops && p->ops->cl_ops->select_queue)\n\t\t\tdev_queue = p->ops->cl_ops->select_queue(p, tcm);\n\t\telse if (p)\n\t\t\tdev_queue = p->dev_queue;\n\t\telse\n\t\t\tdev_queue = netdev_get_tx_queue(dev, 0);\n\n\t\tq = qdisc_create(dev, dev_queue,\n\t\t\t\t tcm->tcm_parent, tcm->tcm_handle,\n\t\t\t\t tca, &err, extack);\n\t}\n\tif (q == NULL) {\n\t\tif (err == -EAGAIN)\n\t\t\tgoto replay;\n\t\treturn err;\n\t}\n\ngraft:\n\terr = qdisc_graft(dev, p, skb, n, clid, q, NULL, extack);\n\tif (err) {\n\t\tif (q)\n\t\t\tqdisc_put(q);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc_dump_qdisc_root(struct Qdisc *root, struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb,\n\t\t\t      int *q_idx_p, int s_q_idx, bool recur,\n\t\t\t      bool dump_invisible)\n{\n\tint ret = 0, q_idx = *q_idx_p;\n\tstruct Qdisc *q;\n\tint b;\n\n\tif (!root)\n\t\treturn 0;\n\n\tq = root;\n\tif (q_idx < s_q_idx) {\n\t\tq_idx++;\n\t} else {\n\t\tif (!tc_qdisc_dump_ignore(q, dump_invisible) &&\n\t\t    tc_fill_qdisc(skb, q, q->parent, NETLINK_CB(cb->skb).portid,\n\t\t\t\t  cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t  RTM_NEWQDISC, NULL) <= 0)\n\t\t\tgoto done;\n\t\tq_idx++;\n\t}\n\n\t \n\tif (!qdisc_dev(root) || !recur)\n\t\tgoto out;\n\n\thash_for_each(qdisc_dev(root)->qdisc_hash, b, q, hash) {\n\t\tif (q_idx < s_q_idx) {\n\t\t\tq_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!tc_qdisc_dump_ignore(q, dump_invisible) &&\n\t\t    tc_fill_qdisc(skb, q, q->parent, NETLINK_CB(cb->skb).portid,\n\t\t\t\t  cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t  RTM_NEWQDISC, NULL) <= 0)\n\t\t\tgoto done;\n\t\tq_idx++;\n\t}\n\nout:\n\t*q_idx_p = q_idx;\n\treturn ret;\ndone:\n\tret = -1;\n\tgoto out;\n}\n\nstatic int tc_dump_qdisc(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint idx, q_idx;\n\tint s_idx, s_q_idx;\n\tstruct net_device *dev;\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tint err;\n\n\ts_idx = cb->args[0];\n\ts_q_idx = q_idx = cb->args[1];\n\n\tidx = 0;\n\tASSERT_RTNL();\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(struct tcmsg), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, cb->extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor_each_netdev(net, dev) {\n\t\tstruct netdev_queue *dev_queue;\n\n\t\tif (idx < s_idx)\n\t\t\tgoto cont;\n\t\tif (idx > s_idx)\n\t\t\ts_q_idx = 0;\n\t\tq_idx = 0;\n\n\t\tif (tc_dump_qdisc_root(rtnl_dereference(dev->qdisc),\n\t\t\t\t       skb, cb, &q_idx, s_q_idx,\n\t\t\t\t       true, tca[TCA_DUMP_INVISIBLE]) < 0)\n\t\t\tgoto done;\n\n\t\tdev_queue = dev_ingress_queue(dev);\n\t\tif (dev_queue &&\n\t\t    tc_dump_qdisc_root(rtnl_dereference(dev_queue->qdisc_sleeping),\n\t\t\t\t       skb, cb, &q_idx, s_q_idx, false,\n\t\t\t\t       tca[TCA_DUMP_INVISIBLE]) < 0)\n\t\t\tgoto done;\n\ncont:\n\t\tidx++;\n\t}\n\ndone:\n\tcb->args[0] = idx;\n\tcb->args[1] = q_idx;\n\n\treturn skb->len;\n}\n\n\n\n \n\nstatic int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl, u32 portid, u32 seq, u16 flags,\n\t\t\t  int event, struct netlink_ext_ack *extack)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\n\tcond_resched();\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*tcm), flags);\n\tif (!nlh)\n\t\tgoto out_nlmsg_trim;\n\ttcm = nlmsg_data(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad2 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tif (nla_put_string(skb, TCA_KIND, q->ops->id))\n\t\tgoto nla_put_failure;\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t NULL, &d, TCA_PAD) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (extack && extack->_msg &&\n\t    nla_put_string(skb, TCA_EXT_WARN_MSG, extack->_msg))\n\t\tgoto out_nlmsg_trim;\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\n\treturn skb->len;\n\nout_nlmsg_trim:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic int tclass_notify(struct net *net, struct sk_buff *oskb,\n\t\t\t struct nlmsghdr *n, struct Qdisc *q,\n\t\t\t unsigned long cl, int event, struct netlink_ext_ack *extack)\n{\n\tstruct sk_buff *skb;\n\tu32 portid = oskb ? NETLINK_CB(oskb).portid : 0;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (tc_fill_tclass(skb, q, cl, portid, n->nlmsg_seq, 0, event, extack) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rtnetlink_send(skb, net, portid, RTNLGRP_TC,\n\t\t\t      n->nlmsg_flags & NLM_F_ECHO);\n}\n\nstatic int tclass_del_notify(struct net *net,\n\t\t\t     const struct Qdisc_class_ops *cops,\n\t\t\t     struct sk_buff *oskb, struct nlmsghdr *n,\n\t\t\t     struct Qdisc *q, unsigned long cl,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu32 portid = oskb ? NETLINK_CB(oskb).portid : 0;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tif (!cops->delete)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (tc_fill_tclass(skb, q, cl, portid, n->nlmsg_seq, 0,\n\t\t\t   RTM_DELTCLASS, extack) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\terr = cops->delete(q, cl, extack);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\terr = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\n\t\t\t     n->nlmsg_flags & NLM_F_ECHO);\n\treturn err;\n}\n\n#ifdef CONFIG_NET_CLS\n\nstruct tcf_bind_args {\n\tstruct tcf_walker w;\n\tunsigned long base;\n\tunsigned long cl;\n\tu32 classid;\n};\n\nstatic int tcf_node_bind(struct tcf_proto *tp, void *n, struct tcf_walker *arg)\n{\n\tstruct tcf_bind_args *a = (void *)arg;\n\n\tif (n && tp->ops->bind_class) {\n\t\tstruct Qdisc *q = tcf_block_q(tp->chain->block);\n\n\t\tsch_tree_lock(q);\n\t\ttp->ops->bind_class(n, a->classid, a->cl, q, a->base);\n\t\tsch_tree_unlock(q);\n\t}\n\treturn 0;\n}\n\nstruct tc_bind_class_args {\n\tstruct qdisc_walker w;\n\tunsigned long new_cl;\n\tu32 portid;\n\tu32 clid;\n};\n\nstatic int tc_bind_class_walker(struct Qdisc *q, unsigned long cl,\n\t\t\t\tstruct qdisc_walker *w)\n{\n\tstruct tc_bind_class_args *a = (struct tc_bind_class_args *)w;\n\tconst struct Qdisc_class_ops *cops = q->ops->cl_ops;\n\tstruct tcf_block *block;\n\tstruct tcf_chain *chain;\n\n\tblock = cops->tcf_block(q, cl, NULL);\n\tif (!block)\n\t\treturn 0;\n\tfor (chain = tcf_get_next_chain(block, NULL);\n\t     chain;\n\t     chain = tcf_get_next_chain(block, chain)) {\n\t\tstruct tcf_proto *tp;\n\n\t\tfor (tp = tcf_get_next_proto(chain, NULL);\n\t\t     tp; tp = tcf_get_next_proto(chain, tp)) {\n\t\t\tstruct tcf_bind_args arg = {};\n\n\t\t\targ.w.fn = tcf_node_bind;\n\t\t\targ.classid = a->clid;\n\t\t\targ.base = cl;\n\t\t\targ.cl = a->new_cl;\n\t\t\ttp->ops->walk(tp, &arg.w, true);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tc_bind_tclass(struct Qdisc *q, u32 portid, u32 clid,\n\t\t\t   unsigned long new_cl)\n{\n\tconst struct Qdisc_class_ops *cops = q->ops->cl_ops;\n\tstruct tc_bind_class_args args = {};\n\n\tif (!cops->tcf_block)\n\t\treturn;\n\targs.portid = portid;\n\targs.clid = clid;\n\targs.new_cl = new_cl;\n\targs.w.fn = tc_bind_class_walker;\n\tq->ops->cl_ops->walk(q, &args.w);\n}\n\n#else\n\nstatic void tc_bind_tclass(struct Qdisc *q, u32 portid, u32 clid,\n\t\t\t   unsigned long new_cl)\n{\n}\n\n#endif\n\nstatic int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tcmsg *tcm = nlmsg_data(n);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tstruct net_device *dev;\n\tstruct Qdisc *q = NULL;\n\tconst struct Qdisc_class_ops *cops;\n\tunsigned long cl = 0;\n\tunsigned long new_cl;\n\tu32 portid;\n\tu32 clid;\n\tu32 qid;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*tcm), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev = __dev_get_by_index(net, tcm->tcm_ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\t \n\n\t \n\n\tportid = tcm->tcm_parent;\n\tclid = tcm->tcm_handle;\n\tqid = TC_H_MAJ(clid);\n\n\tif (portid != TC_H_ROOT) {\n\t\tu32 qid1 = TC_H_MAJ(portid);\n\n\t\tif (qid && qid1) {\n\t\t\t \n\t\t\tif (qid != qid1)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (qid1) {\n\t\t\tqid = qid1;\n\t\t} else if (qid == 0)\n\t\t\tqid = rtnl_dereference(dev->qdisc)->handle;\n\n\t\t \n\t\tif (portid)\n\t\t\tportid = TC_H_MAKE(qid, portid);\n\t} else {\n\t\tif (qid == 0)\n\t\t\tqid = rtnl_dereference(dev->qdisc)->handle;\n\t}\n\n\t \n\tq = qdisc_lookup(dev, qid);\n\tif (!q)\n\t\treturn -ENOENT;\n\n\t \n\tcops = q->ops->cl_ops;\n\tif (cops == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tif (clid == 0) {\n\t\tif (portid == TC_H_ROOT)\n\t\t\tclid = qid;\n\t} else\n\t\tclid = TC_H_MAKE(qid, clid);\n\n\tif (clid)\n\t\tcl = cops->find(q, clid);\n\n\tif (cl == 0) {\n\t\terr = -ENOENT;\n\t\tif (n->nlmsg_type != RTM_NEWTCLASS ||\n\t\t    !(n->nlmsg_flags & NLM_F_CREATE))\n\t\t\tgoto out;\n\t} else {\n\t\tswitch (n->nlmsg_type) {\n\t\tcase RTM_NEWTCLASS:\n\t\t\terr = -EEXIST;\n\t\t\tif (n->nlmsg_flags & NLM_F_EXCL)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase RTM_DELTCLASS:\n\t\t\terr = tclass_del_notify(net, cops, skb, n, q, cl, extack);\n\t\t\t \n\t\t\ttc_bind_tclass(q, portid, clid, 0);\n\t\t\tgoto out;\n\t\tcase RTM_GETTCLASS:\n\t\t\terr = tclass_notify(net, skb, n, q, cl, RTM_NEWTCLASS, extack);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (tca[TCA_INGRESS_BLOCK] || tca[TCA_EGRESS_BLOCK]) {\n\t\tNL_SET_ERR_MSG(extack, \"Shared blocks are not supported for classes\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tnew_cl = cl;\n\terr = -EOPNOTSUPP;\n\tif (cops->change)\n\t\terr = cops->change(q, clid, portid, tca, &new_cl, extack);\n\tif (err == 0) {\n\t\ttclass_notify(net, skb, n, q, new_cl, RTM_NEWTCLASS, extack);\n\t\t \n\t\tif (cl != new_cl)\n\t\t\ttc_bind_tclass(q, portid, clid, new_cl);\n\t}\nout:\n\treturn err;\n}\n\nstruct qdisc_dump_args {\n\tstruct qdisc_walker\tw;\n\tstruct sk_buff\t\t*skb;\n\tstruct netlink_callback\t*cb;\n};\n\nstatic int qdisc_class_dump(struct Qdisc *q, unsigned long cl,\n\t\t\t    struct qdisc_walker *arg)\n{\n\tstruct qdisc_dump_args *a = (struct qdisc_dump_args *)arg;\n\n\treturn tc_fill_tclass(a->skb, q, cl, NETLINK_CB(a->cb->skb).portid,\n\t\t\t      a->cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t      RTM_NEWTCLASS, NULL);\n}\n\nstatic int tc_dump_tclass_qdisc(struct Qdisc *q, struct sk_buff *skb,\n\t\t\t\tstruct tcmsg *tcm, struct netlink_callback *cb,\n\t\t\t\tint *t_p, int s_t)\n{\n\tstruct qdisc_dump_args arg;\n\n\tif (tc_qdisc_dump_ignore(q, false) ||\n\t    *t_p < s_t || !q->ops->cl_ops ||\n\t    (tcm->tcm_parent &&\n\t     TC_H_MAJ(tcm->tcm_parent) != q->handle)) {\n\t\t(*t_p)++;\n\t\treturn 0;\n\t}\n\tif (*t_p > s_t)\n\t\tmemset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));\n\targ.w.fn = qdisc_class_dump;\n\targ.skb = skb;\n\targ.cb = cb;\n\targ.w.stop  = 0;\n\targ.w.skip = cb->args[1];\n\targ.w.count = 0;\n\tq->ops->cl_ops->walk(q, &arg.w);\n\tcb->args[1] = arg.w.count;\n\tif (arg.w.stop)\n\t\treturn -1;\n\t(*t_p)++;\n\treturn 0;\n}\n\nstatic int tc_dump_tclass_root(struct Qdisc *root, struct sk_buff *skb,\n\t\t\t       struct tcmsg *tcm, struct netlink_callback *cb,\n\t\t\t       int *t_p, int s_t, bool recur)\n{\n\tstruct Qdisc *q;\n\tint b;\n\n\tif (!root)\n\t\treturn 0;\n\n\tif (tc_dump_tclass_qdisc(root, skb, tcm, cb, t_p, s_t) < 0)\n\t\treturn -1;\n\n\tif (!qdisc_dev(root) || !recur)\n\t\treturn 0;\n\n\tif (tcm->tcm_parent) {\n\t\tq = qdisc_match_from_root(root, TC_H_MAJ(tcm->tcm_parent));\n\t\tif (q && q != root &&\n\t\t    tc_dump_tclass_qdisc(q, skb, tcm, cb, t_p, s_t) < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\thash_for_each(qdisc_dev(root)->qdisc_hash, b, q, hash) {\n\t\tif (tc_dump_tclass_qdisc(q, skb, tcm, cb, t_p, s_t) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc_dump_tclass(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct tcmsg *tcm = nlmsg_data(cb->nlh);\n\tstruct net *net = sock_net(skb->sk);\n\tstruct netdev_queue *dev_queue;\n\tstruct net_device *dev;\n\tint t, s_t;\n\n\tif (nlmsg_len(cb->nlh) < sizeof(*tcm))\n\t\treturn 0;\n\tdev = dev_get_by_index(net, tcm->tcm_ifindex);\n\tif (!dev)\n\t\treturn 0;\n\n\ts_t = cb->args[0];\n\tt = 0;\n\n\tif (tc_dump_tclass_root(rtnl_dereference(dev->qdisc),\n\t\t\t\tskb, tcm, cb, &t, s_t, true) < 0)\n\t\tgoto done;\n\n\tdev_queue = dev_ingress_queue(dev);\n\tif (dev_queue &&\n\t    tc_dump_tclass_root(rtnl_dereference(dev_queue->qdisc_sleeping),\n\t\t\t\tskb, tcm, cb, &t, s_t, false) < 0)\n\t\tgoto done;\n\ndone:\n\tcb->args[0] = t;\n\n\tdev_put(dev);\n\treturn skb->len;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int psched_show(struct seq_file *seq, void *v)\n{\n\tseq_printf(seq, \"%08x %08x %08x %08x\\n\",\n\t\t   (u32)NSEC_PER_USEC, (u32)PSCHED_TICKS2NS(1),\n\t\t   1000000,\n\t\t   (u32)NSEC_PER_SEC / hrtimer_resolution);\n\n\treturn 0;\n}\n\nstatic int __net_init psched_net_init(struct net *net)\n{\n\tstruct proc_dir_entry *e;\n\n\te = proc_create_single(\"psched\", 0, net->proc_net, psched_show);\n\tif (e == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit psched_net_exit(struct net *net)\n{\n\tremove_proc_entry(\"psched\", net->proc_net);\n}\n#else\nstatic int __net_init psched_net_init(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void __net_exit psched_net_exit(struct net *net)\n{\n}\n#endif\n\nstatic struct pernet_operations psched_net_ops = {\n\t.init = psched_net_init,\n\t.exit = psched_net_exit,\n};\n\n#if IS_ENABLED(CONFIG_RETPOLINE)\nDEFINE_STATIC_KEY_FALSE(tc_skip_wrapper);\n#endif\n\nstatic int __init pktsched_init(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&psched_net_ops);\n\tif (err) {\n\t\tpr_err(\"pktsched_init: \"\n\t\t       \"cannot initialize per netns operations\\n\");\n\t\treturn err;\n\t}\n\n\tregister_qdisc(&pfifo_fast_ops);\n\tregister_qdisc(&pfifo_qdisc_ops);\n\tregister_qdisc(&bfifo_qdisc_ops);\n\tregister_qdisc(&pfifo_head_drop_qdisc_ops);\n\tregister_qdisc(&mq_qdisc_ops);\n\tregister_qdisc(&noqueue_qdisc_ops);\n\n\trtnl_register(PF_UNSPEC, RTM_NEWQDISC, tc_modify_qdisc, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELQDISC, tc_get_qdisc, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETQDISC, tc_get_qdisc, tc_dump_qdisc,\n\t\t      0);\n\trtnl_register(PF_UNSPEC, RTM_NEWTCLASS, tc_ctl_tclass, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELTCLASS, tc_ctl_tclass, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETTCLASS, tc_ctl_tclass, tc_dump_tclass,\n\t\t      0);\n\n\ttc_wrapper_init();\n\n\treturn 0;\n}\n\nsubsys_initcall(pktsched_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}