{
  "module_name": "sch_fq_pie.c",
  "hash_id": "d447ea16d7e369b952a18a37e6254e0cf4fa3c4d34d62f6247592af82bcd5d49",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_fq_pie.c",
  "human_readable_source": "\n \n\n#include <linux/jhash.h>\n#include <linux/sizes.h>\n#include <linux/vmalloc.h>\n#include <net/pkt_cls.h>\n#include <net/pie.h>\n\n \n\n \nstruct fq_pie_flow {\n\tstruct pie_vars vars;\n\ts32 deficit;\n\tu32 backlog;\n\tu32 qlen;\n\tstruct list_head flowchain;\n\tstruct sk_buff *head;\n\tstruct sk_buff *tail;\n};\n\nstruct fq_pie_sched_data {\n\tstruct tcf_proto __rcu *filter_list;  \n\tstruct tcf_block *block;\n\tstruct fq_pie_flow *flows;\n\tstruct Qdisc *sch;\n\tstruct list_head old_flows;\n\tstruct list_head new_flows;\n\tstruct pie_params p_params;\n\tu32 ecn_prob;\n\tu32 flows_cnt;\n\tu32 flows_cursor;\n\tu32 quantum;\n\tu32 memory_limit;\n\tu32 new_flow_count;\n\tu32 memory_usage;\n\tu32 overmemory;\n\tstruct pie_stats stats;\n\tstruct timer_list adapt_timer;\n};\n\nstatic unsigned int fq_pie_hash(const struct fq_pie_sched_data *q,\n\t\t\t\tstruct sk_buff *skb)\n{\n\treturn reciprocal_scale(skb_get_hash(skb), q->flows_cnt);\n}\n\nstatic unsigned int fq_pie_classify(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t\t    int *qerr)\n{\n\tstruct fq_pie_sched_data *q = qdisc_priv(sch);\n\tstruct tcf_proto *filter;\n\tstruct tcf_result res;\n\tint result;\n\n\tif (TC_H_MAJ(skb->priority) == sch->handle &&\n\t    TC_H_MIN(skb->priority) > 0 &&\n\t    TC_H_MIN(skb->priority) <= q->flows_cnt)\n\t\treturn TC_H_MIN(skb->priority);\n\n\tfilter = rcu_dereference_bh(q->filter_list);\n\tif (!filter)\n\t\treturn fq_pie_hash(q, skb) + 1;\n\n\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\tresult = tcf_classify(skb, NULL, filter, &res, false);\n\tif (result >= 0) {\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\tfallthrough;\n\t\tcase TC_ACT_SHOT:\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\tif (TC_H_MIN(res.classid) <= q->flows_cnt)\n\t\t\treturn TC_H_MIN(res.classid);\n\t}\n\treturn 0;\n}\n\n \nstatic inline void flow_queue_add(struct fq_pie_flow *flow,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tif (!flow->head)\n\t\tflow->head = skb;\n\telse\n\t\tflow->tail->next = skb;\n\tflow->tail = skb;\n\tskb->next = NULL;\n}\n\nstatic int fq_pie_qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t\tstruct sk_buff **to_free)\n{\n\tstruct fq_pie_sched_data *q = qdisc_priv(sch);\n\tstruct fq_pie_flow *sel_flow;\n\tint ret;\n\tu8 memory_limited = false;\n\tu8 enqueue = false;\n\tu32 pkt_len;\n\tu32 idx;\n\n\t \n\tidx = fq_pie_classify(skb, sch, &ret);\n\tif (idx == 0) {\n\t\tif (ret & __NET_XMIT_BYPASS)\n\t\t\tqdisc_qstats_drop(sch);\n\t\t__qdisc_drop(skb, to_free);\n\t\treturn ret;\n\t}\n\tidx--;\n\n\tsel_flow = &q->flows[idx];\n\t \n\tget_pie_cb(skb)->mem_usage = skb->truesize;\n\tmemory_limited = q->memory_usage > q->memory_limit + skb->truesize;\n\n\t \n\tif (unlikely(qdisc_qlen(sch) >= sch->limit)) {\n\t\tq->stats.overlimit++;\n\t\tgoto out;\n\t} else if (unlikely(memory_limited)) {\n\t\tq->overmemory++;\n\t}\n\n\tif (!pie_drop_early(sch, &q->p_params, &sel_flow->vars,\n\t\t\t    sel_flow->backlog, skb->len)) {\n\t\tenqueue = true;\n\t} else if (q->p_params.ecn &&\n\t\t   sel_flow->vars.prob <= (MAX_PROB / 100) * q->ecn_prob &&\n\t\t   INET_ECN_set_ce(skb)) {\n\t\t \n\t\tq->stats.ecn_mark++;\n\t\tenqueue = true;\n\t}\n\tif (enqueue) {\n\t\t \n\t\tif (!q->p_params.dq_rate_estimator)\n\t\t\tpie_set_enqueue_time(skb);\n\n\t\tpkt_len = qdisc_pkt_len(skb);\n\t\tq->stats.packets_in++;\n\t\tq->memory_usage += skb->truesize;\n\t\tsch->qstats.backlog += pkt_len;\n\t\tsch->q.qlen++;\n\t\tflow_queue_add(sel_flow, skb);\n\t\tif (list_empty(&sel_flow->flowchain)) {\n\t\t\tlist_add_tail(&sel_flow->flowchain, &q->new_flows);\n\t\t\tq->new_flow_count++;\n\t\t\tsel_flow->deficit = q->quantum;\n\t\t\tsel_flow->qlen = 0;\n\t\t\tsel_flow->backlog = 0;\n\t\t}\n\t\tsel_flow->qlen++;\n\t\tsel_flow->backlog += pkt_len;\n\t\treturn NET_XMIT_SUCCESS;\n\t}\nout:\n\tq->stats.dropped++;\n\tsel_flow->vars.accu_prob = 0;\n\t__qdisc_drop(skb, to_free);\n\tqdisc_qstats_drop(sch);\n\treturn NET_XMIT_CN;\n}\n\nstatic struct netlink_range_validation fq_pie_q_range = {\n\t.min = 1,\n\t.max = 1 << 20,\n};\n\nstatic const struct nla_policy fq_pie_policy[TCA_FQ_PIE_MAX + 1] = {\n\t[TCA_FQ_PIE_LIMIT]\t\t= {.type = NLA_U32},\n\t[TCA_FQ_PIE_FLOWS]\t\t= {.type = NLA_U32},\n\t[TCA_FQ_PIE_TARGET]\t\t= {.type = NLA_U32},\n\t[TCA_FQ_PIE_TUPDATE]\t\t= {.type = NLA_U32},\n\t[TCA_FQ_PIE_ALPHA]\t\t= {.type = NLA_U32},\n\t[TCA_FQ_PIE_BETA]\t\t= {.type = NLA_U32},\n\t[TCA_FQ_PIE_QUANTUM]\t\t=\n\t\t\tNLA_POLICY_FULL_RANGE(NLA_U32, &fq_pie_q_range),\n\t[TCA_FQ_PIE_MEMORY_LIMIT]\t= {.type = NLA_U32},\n\t[TCA_FQ_PIE_ECN_PROB]\t\t= {.type = NLA_U32},\n\t[TCA_FQ_PIE_ECN]\t\t= {.type = NLA_U32},\n\t[TCA_FQ_PIE_BYTEMODE]\t\t= {.type = NLA_U32},\n\t[TCA_FQ_PIE_DQ_RATE_ESTIMATOR]\t= {.type = NLA_U32},\n};\n\nstatic inline struct sk_buff *dequeue_head(struct fq_pie_flow *flow)\n{\n\tstruct sk_buff *skb = flow->head;\n\n\tflow->head = skb->next;\n\tskb->next = NULL;\n\treturn skb;\n}\n\nstatic struct sk_buff *fq_pie_qdisc_dequeue(struct Qdisc *sch)\n{\n\tstruct fq_pie_sched_data *q = qdisc_priv(sch);\n\tstruct sk_buff *skb = NULL;\n\tstruct fq_pie_flow *flow;\n\tstruct list_head *head;\n\tu32 pkt_len;\n\nbegin:\n\thead = &q->new_flows;\n\tif (list_empty(head)) {\n\t\thead = &q->old_flows;\n\t\tif (list_empty(head))\n\t\t\treturn NULL;\n\t}\n\n\tflow = list_first_entry(head, struct fq_pie_flow, flowchain);\n\t \n\tif (flow->deficit <= 0) {\n\t\tflow->deficit += q->quantum;\n\t\tlist_move_tail(&flow->flowchain, &q->old_flows);\n\t\tgoto begin;\n\t}\n\n\tif (flow->head) {\n\t\tskb = dequeue_head(flow);\n\t\tpkt_len = qdisc_pkt_len(skb);\n\t\tsch->qstats.backlog -= pkt_len;\n\t\tsch->q.qlen--;\n\t\tqdisc_bstats_update(sch, skb);\n\t}\n\n\tif (!skb) {\n\t\t \n\t\tif (head == &q->new_flows && !list_empty(&q->old_flows))\n\t\t\tlist_move_tail(&flow->flowchain, &q->old_flows);\n\t\telse\n\t\t\tlist_del_init(&flow->flowchain);\n\t\tgoto begin;\n\t}\n\n\tflow->qlen--;\n\tflow->deficit -= pkt_len;\n\tflow->backlog -= pkt_len;\n\tq->memory_usage -= get_pie_cb(skb)->mem_usage;\n\tpie_process_dequeue(skb, &q->p_params, &flow->vars, flow->backlog);\n\treturn skb;\n}\n\nstatic int fq_pie_change(struct Qdisc *sch, struct nlattr *opt,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct fq_pie_sched_data *q = qdisc_priv(sch);\n\tstruct nlattr *tb[TCA_FQ_PIE_MAX + 1];\n\tunsigned int len_dropped = 0;\n\tunsigned int num_dropped = 0;\n\tint err;\n\n\terr = nla_parse_nested(tb, TCA_FQ_PIE_MAX, opt, fq_pie_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tsch_tree_lock(sch);\n\tif (tb[TCA_FQ_PIE_LIMIT]) {\n\t\tu32 limit = nla_get_u32(tb[TCA_FQ_PIE_LIMIT]);\n\n\t\tq->p_params.limit = limit;\n\t\tsch->limit = limit;\n\t}\n\tif (tb[TCA_FQ_PIE_FLOWS]) {\n\t\tif (q->flows) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Number of flows cannot be changed\");\n\t\t\tgoto flow_error;\n\t\t}\n\t\tq->flows_cnt = nla_get_u32(tb[TCA_FQ_PIE_FLOWS]);\n\t\tif (!q->flows_cnt || q->flows_cnt > 65536) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Number of flows must range in [1..65536]\");\n\t\t\tgoto flow_error;\n\t\t}\n\t}\n\n\t \n\tif (tb[TCA_FQ_PIE_TARGET]) {\n\t\t \n\t\tu32 target = nla_get_u32(tb[TCA_FQ_PIE_TARGET]);\n\n\t\t \n\t\tq->p_params.target =\n\t\t\tPSCHED_NS2TICKS((u64)target * NSEC_PER_USEC);\n\t}\n\n\t \n\tif (tb[TCA_FQ_PIE_TUPDATE])\n\t\tq->p_params.tupdate =\n\t\t\tusecs_to_jiffies(nla_get_u32(tb[TCA_FQ_PIE_TUPDATE]));\n\n\tif (tb[TCA_FQ_PIE_ALPHA])\n\t\tq->p_params.alpha = nla_get_u32(tb[TCA_FQ_PIE_ALPHA]);\n\n\tif (tb[TCA_FQ_PIE_BETA])\n\t\tq->p_params.beta = nla_get_u32(tb[TCA_FQ_PIE_BETA]);\n\n\tif (tb[TCA_FQ_PIE_QUANTUM])\n\t\tq->quantum = nla_get_u32(tb[TCA_FQ_PIE_QUANTUM]);\n\n\tif (tb[TCA_FQ_PIE_MEMORY_LIMIT])\n\t\tq->memory_limit = nla_get_u32(tb[TCA_FQ_PIE_MEMORY_LIMIT]);\n\n\tif (tb[TCA_FQ_PIE_ECN_PROB])\n\t\tq->ecn_prob = nla_get_u32(tb[TCA_FQ_PIE_ECN_PROB]);\n\n\tif (tb[TCA_FQ_PIE_ECN])\n\t\tq->p_params.ecn = nla_get_u32(tb[TCA_FQ_PIE_ECN]);\n\n\tif (tb[TCA_FQ_PIE_BYTEMODE])\n\t\tq->p_params.bytemode = nla_get_u32(tb[TCA_FQ_PIE_BYTEMODE]);\n\n\tif (tb[TCA_FQ_PIE_DQ_RATE_ESTIMATOR])\n\t\tq->p_params.dq_rate_estimator =\n\t\t\tnla_get_u32(tb[TCA_FQ_PIE_DQ_RATE_ESTIMATOR]);\n\n\t \n\twhile (sch->q.qlen > sch->limit) {\n\t\tstruct sk_buff *skb = fq_pie_qdisc_dequeue(sch);\n\n\t\tlen_dropped += qdisc_pkt_len(skb);\n\t\tnum_dropped += 1;\n\t\trtnl_kfree_skbs(skb, skb);\n\t}\n\tqdisc_tree_reduce_backlog(sch, num_dropped, len_dropped);\n\n\tsch_tree_unlock(sch);\n\treturn 0;\n\nflow_error:\n\tsch_tree_unlock(sch);\n\treturn -EINVAL;\n}\n\nstatic void fq_pie_timer(struct timer_list *t)\n{\n\tstruct fq_pie_sched_data *q = from_timer(q, t, adapt_timer);\n\tunsigned long next, tupdate;\n\tstruct Qdisc *sch = q->sch;\n\tspinlock_t *root_lock;  \n\tint max_cnt, i;\n\n\trcu_read_lock();\n\troot_lock = qdisc_lock(qdisc_root_sleeping(sch));\n\tspin_lock(root_lock);\n\n\t \n\tmax_cnt = min_t(int, q->flows_cnt - q->flows_cursor, 2048);\n\tfor (i = 0; i < max_cnt; i++) {\n\t\tpie_calculate_probability(&q->p_params,\n\t\t\t\t\t  &q->flows[q->flows_cursor].vars,\n\t\t\t\t\t  q->flows[q->flows_cursor].backlog);\n\t\tq->flows_cursor++;\n\t}\n\n\ttupdate = q->p_params.tupdate;\n\tnext = 0;\n\tif (q->flows_cursor >= q->flows_cnt) {\n\t\tq->flows_cursor = 0;\n\t\tnext = tupdate;\n\t}\n\tif (tupdate)\n\t\tmod_timer(&q->adapt_timer, jiffies + next);\n\tspin_unlock(root_lock);\n\trcu_read_unlock();\n}\n\nstatic int fq_pie_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct fq_pie_sched_data *q = qdisc_priv(sch);\n\tint err;\n\tu32 idx;\n\n\tpie_params_init(&q->p_params);\n\tsch->limit = 10 * 1024;\n\tq->p_params.limit = sch->limit;\n\tq->quantum = psched_mtu(qdisc_dev(sch));\n\tq->sch = sch;\n\tq->ecn_prob = 10;\n\tq->flows_cnt = 1024;\n\tq->memory_limit = SZ_32M;\n\n\tINIT_LIST_HEAD(&q->new_flows);\n\tINIT_LIST_HEAD(&q->old_flows);\n\ttimer_setup(&q->adapt_timer, fq_pie_timer, 0);\n\n\tif (opt) {\n\t\terr = fq_pie_change(sch, opt, extack);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);\n\tif (err)\n\t\tgoto init_failure;\n\n\tq->flows = kvcalloc(q->flows_cnt, sizeof(struct fq_pie_flow),\n\t\t\t    GFP_KERNEL);\n\tif (!q->flows) {\n\t\terr = -ENOMEM;\n\t\tgoto init_failure;\n\t}\n\tfor (idx = 0; idx < q->flows_cnt; idx++) {\n\t\tstruct fq_pie_flow *flow = q->flows + idx;\n\n\t\tINIT_LIST_HEAD(&flow->flowchain);\n\t\tpie_vars_init(&flow->vars);\n\t}\n\n\tmod_timer(&q->adapt_timer, jiffies + HZ / 2);\n\n\treturn 0;\n\ninit_failure:\n\tq->flows_cnt = 0;\n\n\treturn err;\n}\n\nstatic int fq_pie_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct fq_pie_sched_data *q = qdisc_priv(sch);\n\tstruct nlattr *opts;\n\n\topts = nla_nest_start(skb, TCA_OPTIONS);\n\tif (!opts)\n\t\treturn -EMSGSIZE;\n\n\t \n\tif (nla_put_u32(skb, TCA_FQ_PIE_LIMIT, sch->limit) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_FLOWS, q->flows_cnt) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_TARGET,\n\t\t\t((u32)PSCHED_TICKS2NS(q->p_params.target)) /\n\t\t\tNSEC_PER_USEC) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_TUPDATE,\n\t\t\tjiffies_to_usecs(q->p_params.tupdate)) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_ALPHA, q->p_params.alpha) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_BETA, q->p_params.beta) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_QUANTUM, q->quantum) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_MEMORY_LIMIT, q->memory_limit) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_ECN_PROB, q->ecn_prob) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_ECN, q->p_params.ecn) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_BYTEMODE, q->p_params.bytemode) ||\n\t    nla_put_u32(skb, TCA_FQ_PIE_DQ_RATE_ESTIMATOR,\n\t\t\tq->p_params.dq_rate_estimator))\n\t\tgoto nla_put_failure;\n\n\treturn nla_nest_end(skb, opts);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, opts);\n\treturn -EMSGSIZE;\n}\n\nstatic int fq_pie_dump_stats(struct Qdisc *sch, struct gnet_dump *d)\n{\n\tstruct fq_pie_sched_data *q = qdisc_priv(sch);\n\tstruct tc_fq_pie_xstats st = {\n\t\t.packets_in\t= q->stats.packets_in,\n\t\t.overlimit\t= q->stats.overlimit,\n\t\t.overmemory\t= q->overmemory,\n\t\t.dropped\t= q->stats.dropped,\n\t\t.ecn_mark\t= q->stats.ecn_mark,\n\t\t.new_flow_count = q->new_flow_count,\n\t\t.memory_usage   = q->memory_usage,\n\t};\n\tstruct list_head *pos;\n\n\tsch_tree_lock(sch);\n\tlist_for_each(pos, &q->new_flows)\n\t\tst.new_flows_len++;\n\n\tlist_for_each(pos, &q->old_flows)\n\t\tst.old_flows_len++;\n\tsch_tree_unlock(sch);\n\n\treturn gnet_stats_copy_app(d, &st, sizeof(st));\n}\n\nstatic void fq_pie_reset(struct Qdisc *sch)\n{\n\tstruct fq_pie_sched_data *q = qdisc_priv(sch);\n\tu32 idx;\n\n\tINIT_LIST_HEAD(&q->new_flows);\n\tINIT_LIST_HEAD(&q->old_flows);\n\tfor (idx = 0; idx < q->flows_cnt; idx++) {\n\t\tstruct fq_pie_flow *flow = q->flows + idx;\n\n\t\t \n\t\trtnl_kfree_skbs(flow->head, flow->tail);\n\t\tflow->head = NULL;\n\n\t\tINIT_LIST_HEAD(&flow->flowchain);\n\t\tpie_vars_init(&flow->vars);\n\t}\n}\n\nstatic void fq_pie_destroy(struct Qdisc *sch)\n{\n\tstruct fq_pie_sched_data *q = qdisc_priv(sch);\n\n\ttcf_block_put(q->block);\n\tq->p_params.tupdate = 0;\n\tdel_timer_sync(&q->adapt_timer);\n\tkvfree(q->flows);\n}\n\nstatic struct Qdisc_ops fq_pie_qdisc_ops __read_mostly = {\n\t.id\t\t= \"fq_pie\",\n\t.priv_size\t= sizeof(struct fq_pie_sched_data),\n\t.enqueue\t= fq_pie_qdisc_enqueue,\n\t.dequeue\t= fq_pie_qdisc_dequeue,\n\t.peek\t\t= qdisc_peek_dequeued,\n\t.init\t\t= fq_pie_init,\n\t.destroy\t= fq_pie_destroy,\n\t.reset\t\t= fq_pie_reset,\n\t.change\t\t= fq_pie_change,\n\t.dump\t\t= fq_pie_dump,\n\t.dump_stats\t= fq_pie_dump_stats,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init fq_pie_module_init(void)\n{\n\treturn register_qdisc(&fq_pie_qdisc_ops);\n}\n\nstatic void __exit fq_pie_module_exit(void)\n{\n\tunregister_qdisc(&fq_pie_qdisc_ops);\n}\n\nmodule_init(fq_pie_module_init);\nmodule_exit(fq_pie_module_exit);\n\nMODULE_DESCRIPTION(\"Flow Queue Proportional Integral controller Enhanced (FQ-PIE)\");\nMODULE_AUTHOR(\"Mohit P. Tahiliani\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}