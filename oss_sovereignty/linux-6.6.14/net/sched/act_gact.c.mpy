{
  "module_name": "act_gact.c",
  "hash_id": "0b1cde3c98555d0fe972031cba0e5d88b414d8f3e868127d2350cba3ce03804c",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_gact.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <linux/tc_act/tc_gact.h>\n#include <net/tc_act/tc_gact.h>\n#include <net/tc_wrapper.h>\n\nstatic struct tc_action_ops act_gact_ops;\n\n#ifdef CONFIG_GACT_PROB\nstatic int gact_net_rand(struct tcf_gact *gact)\n{\n\tsmp_rmb();  \n\tif (get_random_u32_below(gact->tcfg_pval))\n\t\treturn gact->tcf_action;\n\treturn gact->tcfg_paction;\n}\n\nstatic int gact_determ(struct tcf_gact *gact)\n{\n\tu32 pack = atomic_inc_return(&gact->packets);\n\n\tsmp_rmb();  \n\tif (pack % gact->tcfg_pval)\n\t\treturn gact->tcf_action;\n\treturn gact->tcfg_paction;\n}\n\ntypedef int (*g_rand)(struct tcf_gact *gact);\nstatic g_rand gact_rand[MAX_RAND] = { NULL, gact_net_rand, gact_determ };\n#endif  \n\nstatic const struct nla_policy gact_policy[TCA_GACT_MAX + 1] = {\n\t[TCA_GACT_PARMS]\t= { .len = sizeof(struct tc_gact) },\n\t[TCA_GACT_PROB]\t\t= { .len = sizeof(struct tc_gact_p) },\n};\n\nstatic int tcf_gact_init(struct net *net, struct nlattr *nla,\n\t\t\t struct nlattr *est, struct tc_action **a,\n\t\t\t struct tcf_proto *tp, u32 flags,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_gact_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_GACT_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tc_gact *parm;\n\tstruct tcf_gact *gact;\n\tint ret = 0;\n\tu32 index;\n\tint err;\n#ifdef CONFIG_GACT_PROB\n\tstruct tc_gact_p *p_parm = NULL;\n#endif\n\n\tif (nla == NULL)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_GACT_MAX, nla, gact_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_GACT_PARMS] == NULL)\n\t\treturn -EINVAL;\n\tparm = nla_data(tb[TCA_GACT_PARMS]);\n\tindex = parm->index;\n\n#ifndef CONFIG_GACT_PROB\n\tif (tb[TCA_GACT_PROB] != NULL)\n\t\treturn -EOPNOTSUPP;\n#else\n\tif (tb[TCA_GACT_PROB]) {\n\t\tp_parm = nla_data(tb[TCA_GACT_PROB]);\n\t\tif (p_parm->ptype >= MAX_RAND)\n\t\t\treturn -EINVAL;\n\t\tif (TC_ACT_EXT_CMP(p_parm->paction, TC_ACT_GOTO_CHAIN)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"goto chain not allowed on fallback\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#endif\n\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (!err) {\n\t\tret = tcf_idr_create_from_flags(tn, index, est, a,\n\t\t\t\t\t\t&act_gact_ops, bind, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ACT_P_CREATED;\n\t} else if (err > 0) {\n\t\tif (bind) \n\t\t\treturn 0;\n\t\tif (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\t\ttcf_idr_release(*a, bind);\n\t\t\treturn -EEXIST;\n\t\t}\n\t} else {\n\t\treturn err;\n\t}\n\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\tgact = to_gact(*a);\n\n\tspin_lock_bh(&gact->tcf_lock);\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n#ifdef CONFIG_GACT_PROB\n\tif (p_parm) {\n\t\tgact->tcfg_paction = p_parm->paction;\n\t\tgact->tcfg_pval    = max_t(u16, 1, p_parm->pval);\n\t\t \n\t\tsmp_wmb();\n\t\tgact->tcfg_ptype   = p_parm->ptype;\n\t}\n#endif\n\tspin_unlock_bh(&gact->tcf_lock);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\n\treturn ret;\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nTC_INDIRECT_SCOPE int tcf_gact_act(struct sk_buff *skb,\n\t\t\t\t   const struct tc_action *a,\n\t\t\t\t   struct tcf_result *res)\n{\n\tstruct tcf_gact *gact = to_gact(a);\n\tint action = READ_ONCE(gact->tcf_action);\n\n#ifdef CONFIG_GACT_PROB\n\t{\n\tu32 ptype = READ_ONCE(gact->tcfg_ptype);\n\n\tif (ptype)\n\t\taction = gact_rand[ptype](gact);\n\t}\n#endif\n\ttcf_action_update_bstats(&gact->common, skb);\n\tif (action == TC_ACT_SHOT)\n\t\ttcf_action_inc_drop_qstats(&gact->common);\n\n\ttcf_lastuse_update(&gact->tcf_tm);\n\n\treturn action;\n}\n\nstatic void tcf_gact_stats_update(struct tc_action *a, u64 bytes, u64 packets,\n\t\t\t\t  u64 drops, u64 lastuse, bool hw)\n{\n\tstruct tcf_gact *gact = to_gact(a);\n\tint action = READ_ONCE(gact->tcf_action);\n\tstruct tcf_t *tm = &gact->tcf_tm;\n\n\ttcf_action_update_stats(a, bytes, packets,\n\t\t\t\taction == TC_ACT_SHOT ? packets : drops, hw);\n\ttm->lastuse = max_t(u64, tm->lastuse, lastuse);\n}\n\nstatic int tcf_gact_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_gact *gact = to_gact(a);\n\tstruct tc_gact opt = {\n\t\t.index   = gact->tcf_index,\n\t\t.refcnt  = refcount_read(&gact->tcf_refcnt) - ref,\n\t\t.bindcnt = atomic_read(&gact->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&gact->tcf_lock);\n\topt.action = gact->tcf_action;\n\tif (nla_put(skb, TCA_GACT_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n#ifdef CONFIG_GACT_PROB\n\tif (gact->tcfg_ptype) {\n\t\tstruct tc_gact_p p_opt = {\n\t\t\t.paction = gact->tcfg_paction,\n\t\t\t.pval    = gact->tcfg_pval,\n\t\t\t.ptype   = gact->tcfg_ptype,\n\t\t};\n\n\t\tif (nla_put(skb, TCA_GACT_PROB, sizeof(p_opt), &p_opt))\n\t\t\tgoto nla_put_failure;\n\t}\n#endif\n\ttcf_tm_dump(&t, &gact->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_GACT_TM, sizeof(t), &t, TCA_GACT_PAD))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&gact->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&gact->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic size_t tcf_gact_get_fill_size(const struct tc_action *act)\n{\n\tsize_t sz = nla_total_size(sizeof(struct tc_gact));  \n\n#ifdef CONFIG_GACT_PROB\n\tif (to_gact(act)->tcfg_ptype)\n\t\t \n\t\tsz += nla_total_size(sizeof(struct tc_gact_p));\n#endif\n\n\treturn sz;\n}\n\nstatic int tcf_gact_offload_act_setup(struct tc_action *act, void *entry_data,\n\t\t\t\t      u32 *index_inc, bool bind,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (bind) {\n\t\tstruct flow_action_entry *entry = entry_data;\n\n\t\tif (is_tcf_gact_ok(act)) {\n\t\t\tentry->id = FLOW_ACTION_ACCEPT;\n\t\t} else if (is_tcf_gact_shot(act)) {\n\t\t\tentry->id = FLOW_ACTION_DROP;\n\t\t} else if (is_tcf_gact_trap(act)) {\n\t\t\tentry->id = FLOW_ACTION_TRAP;\n\t\t} else if (is_tcf_gact_goto_chain(act)) {\n\t\t\tentry->id = FLOW_ACTION_GOTO;\n\t\t\tentry->chain_index = tcf_gact_goto_chain_index(act);\n\t\t} else if (is_tcf_gact_continue(act)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Offload of \\\"continue\\\" action is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t} else if (is_tcf_gact_reclassify(act)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Offload of \\\"reclassify\\\" action is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t} else if (is_tcf_gact_pipe(act)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Offload of \\\"pipe\\\" action is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported generic action offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t*index_inc = 1;\n\t} else {\n\t\tstruct flow_offload_action *fl_action = entry_data;\n\n\t\tif (is_tcf_gact_ok(act))\n\t\t\tfl_action->id = FLOW_ACTION_ACCEPT;\n\t\telse if (is_tcf_gact_shot(act))\n\t\t\tfl_action->id = FLOW_ACTION_DROP;\n\t\telse if (is_tcf_gact_trap(act))\n\t\t\tfl_action->id = FLOW_ACTION_TRAP;\n\t\telse if (is_tcf_gact_goto_chain(act))\n\t\t\tfl_action->id = FLOW_ACTION_GOTO;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic struct tc_action_ops act_gact_ops = {\n\t.kind\t\t=\t\"gact\",\n\t.id\t\t=\tTCA_ID_GACT,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_gact_act,\n\t.stats_update\t=\ttcf_gact_stats_update,\n\t.dump\t\t=\ttcf_gact_dump,\n\t.init\t\t=\ttcf_gact_init,\n\t.get_fill_size\t=\ttcf_gact_get_fill_size,\n\t.offload_act_setup =\ttcf_gact_offload_act_setup,\n\t.size\t\t=\tsizeof(struct tcf_gact),\n};\n\nstatic __net_init int gact_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_gact_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_gact_ops);\n}\n\nstatic void __net_exit gact_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_gact_ops.net_id);\n}\n\nstatic struct pernet_operations gact_net_ops = {\n\t.init = gact_init_net,\n\t.exit_batch = gact_exit_net,\n\t.id   = &act_gact_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nMODULE_AUTHOR(\"Jamal Hadi Salim(2002-4)\");\nMODULE_DESCRIPTION(\"Generic Classifier actions\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init gact_init_module(void)\n{\n#ifdef CONFIG_GACT_PROB\n\tpr_info(\"GACT probability on\\n\");\n#else\n\tpr_info(\"GACT probability NOT on\\n\");\n#endif\n\n\treturn tcf_register_action(&act_gact_ops, &gact_net_ops);\n}\n\nstatic void __exit gact_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_gact_ops, &gact_net_ops);\n}\n\nmodule_init(gact_init_module);\nmodule_exit(gact_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}