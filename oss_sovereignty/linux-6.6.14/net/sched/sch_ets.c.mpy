{
  "module_name": "sch_ets.c",
  "hash_id": "8c464e89a51d1838181719f6683f6b76d1663b2958f30560a39ba5572ca70451",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_ets.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <net/gen_stats.h>\n#include <net/netlink.h>\n#include <net/pkt_cls.h>\n#include <net/pkt_sched.h>\n#include <net/sch_generic.h>\n\nstruct ets_class {\n\tstruct list_head alist;  \n\tstruct Qdisc *qdisc;\n\tu32 quantum;\n\tu32 deficit;\n\tstruct gnet_stats_basic_sync bstats;\n\tstruct gnet_stats_queue qstats;\n};\n\nstruct ets_sched {\n\tstruct list_head active;\n\tstruct tcf_proto __rcu *filter_list;\n\tstruct tcf_block *block;\n\tunsigned int nbands;\n\tunsigned int nstrict;\n\tu8 prio2band[TC_PRIO_MAX + 1];\n\tstruct ets_class classes[TCQ_ETS_MAX_BANDS];\n};\n\nstatic const struct nla_policy ets_policy[TCA_ETS_MAX + 1] = {\n\t[TCA_ETS_NBANDS] = { .type = NLA_U8 },\n\t[TCA_ETS_NSTRICT] = { .type = NLA_U8 },\n\t[TCA_ETS_QUANTA] = { .type = NLA_NESTED },\n\t[TCA_ETS_PRIOMAP] = { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy ets_priomap_policy[TCA_ETS_MAX + 1] = {\n\t[TCA_ETS_PRIOMAP_BAND] = { .type = NLA_U8 },\n};\n\nstatic const struct nla_policy ets_quanta_policy[TCA_ETS_MAX + 1] = {\n\t[TCA_ETS_QUANTA_BAND] = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy ets_class_policy[TCA_ETS_MAX + 1] = {\n\t[TCA_ETS_QUANTA_BAND] = { .type = NLA_U32 },\n};\n\nstatic int ets_quantum_parse(struct Qdisc *sch, const struct nlattr *attr,\n\t\t\t     unsigned int *quantum,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\t*quantum = nla_get_u32(attr);\n\tif (!*quantum) {\n\t\tNL_SET_ERR_MSG(extack, \"ETS quantum cannot be zero\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct ets_class *\nets_class_from_arg(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct ets_sched *q = qdisc_priv(sch);\n\n\treturn &q->classes[arg - 1];\n}\n\nstatic u32 ets_class_id(struct Qdisc *sch, const struct ets_class *cl)\n{\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tint band = cl - q->classes;\n\n\treturn TC_H_MAKE(sch->handle, band + 1);\n}\n\nstatic void ets_offload_change(struct Qdisc *sch)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tstruct tc_ets_qopt_offload qopt;\n\tunsigned int w_psum_prev = 0;\n\tunsigned int q_psum = 0;\n\tunsigned int q_sum = 0;\n\tunsigned int quantum;\n\tunsigned int w_psum;\n\tunsigned int weight;\n\tunsigned int i;\n\n\tif (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)\n\t\treturn;\n\n\tqopt.command = TC_ETS_REPLACE;\n\tqopt.handle = sch->handle;\n\tqopt.parent = sch->parent;\n\tqopt.replace_params.bands = q->nbands;\n\tqopt.replace_params.qstats = &sch->qstats;\n\tmemcpy(&qopt.replace_params.priomap,\n\t       q->prio2band, sizeof(q->prio2band));\n\n\tfor (i = 0; i < q->nbands; i++)\n\t\tq_sum += q->classes[i].quantum;\n\n\tfor (i = 0; i < q->nbands; i++) {\n\t\tquantum = q->classes[i].quantum;\n\t\tq_psum += quantum;\n\t\tw_psum = quantum ? q_psum * 100 / q_sum : 0;\n\t\tweight = w_psum - w_psum_prev;\n\t\tw_psum_prev = w_psum;\n\n\t\tqopt.replace_params.quanta[i] = quantum;\n\t\tqopt.replace_params.weights[i] = weight;\n\t}\n\n\tdev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_ETS, &qopt);\n}\n\nstatic void ets_offload_destroy(struct Qdisc *sch)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct tc_ets_qopt_offload qopt;\n\n\tif (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)\n\t\treturn;\n\n\tqopt.command = TC_ETS_DESTROY;\n\tqopt.handle = sch->handle;\n\tqopt.parent = sch->parent;\n\tdev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_ETS, &qopt);\n}\n\nstatic void ets_offload_graft(struct Qdisc *sch, struct Qdisc *new,\n\t\t\t      struct Qdisc *old, unsigned long arg,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct tc_ets_qopt_offload qopt;\n\n\tqopt.command = TC_ETS_GRAFT;\n\tqopt.handle = sch->handle;\n\tqopt.parent = sch->parent;\n\tqopt.graft_params.band = arg - 1;\n\tqopt.graft_params.child_handle = new->handle;\n\n\tqdisc_offload_graft_helper(dev, sch, new, old, TC_SETUP_QDISC_ETS,\n\t\t\t\t   &qopt, extack);\n}\n\nstatic int ets_offload_dump(struct Qdisc *sch)\n{\n\tstruct tc_ets_qopt_offload qopt;\n\n\tqopt.command = TC_ETS_STATS;\n\tqopt.handle = sch->handle;\n\tqopt.parent = sch->parent;\n\tqopt.stats.bstats = &sch->bstats;\n\tqopt.stats.qstats = &sch->qstats;\n\n\treturn qdisc_offload_dump_helper(sch, TC_SETUP_QDISC_ETS, &qopt);\n}\n\nstatic bool ets_class_is_strict(struct ets_sched *q, const struct ets_class *cl)\n{\n\tunsigned int band = cl - q->classes;\n\n\treturn band < q->nstrict;\n}\n\nstatic int ets_class_change(struct Qdisc *sch, u32 classid, u32 parentid,\n\t\t\t    struct nlattr **tca, unsigned long *arg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ets_class *cl = ets_class_from_arg(sch, *arg);\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tstruct nlattr *opt = tca[TCA_OPTIONS];\n\tstruct nlattr *tb[TCA_ETS_MAX + 1];\n\tunsigned int quantum;\n\tint err;\n\n\t \n\tif (!cl) {\n\t\tNL_SET_ERR_MSG(extack, \"Fine-grained class addition and removal is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!opt) {\n\t\tNL_SET_ERR_MSG(extack, \"ETS options are required for this operation\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested(tb, TCA_ETS_MAX, opt, ets_class_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_ETS_QUANTA_BAND])\n\t\t \n\t\treturn 0;\n\n\tif (ets_class_is_strict(q, cl)) {\n\t\tNL_SET_ERR_MSG(extack, \"Strict bands do not have a configurable quantum\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = ets_quantum_parse(sch, tb[TCA_ETS_QUANTA_BAND], &quantum,\n\t\t\t\textack);\n\tif (err)\n\t\treturn err;\n\n\tsch_tree_lock(sch);\n\tcl->quantum = quantum;\n\tsch_tree_unlock(sch);\n\n\tets_offload_change(sch);\n\treturn 0;\n}\n\nstatic int ets_class_graft(struct Qdisc *sch, unsigned long arg,\n\t\t\t   struct Qdisc *new, struct Qdisc **old,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ets_class *cl = ets_class_from_arg(sch, arg);\n\n\tif (!new) {\n\t\tnew = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\n\t\t\t\t\tets_class_id(sch, cl), NULL);\n\t\tif (!new)\n\t\t\tnew = &noop_qdisc;\n\t\telse\n\t\t\tqdisc_hash_add(new, true);\n\t}\n\n\t*old = qdisc_replace(sch, new, &cl->qdisc);\n\tets_offload_graft(sch, new, *old, arg, extack);\n\treturn 0;\n}\n\nstatic struct Qdisc *ets_class_leaf(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct ets_class *cl = ets_class_from_arg(sch, arg);\n\n\treturn cl->qdisc;\n}\n\nstatic unsigned long ets_class_find(struct Qdisc *sch, u32 classid)\n{\n\tunsigned long band = TC_H_MIN(classid);\n\tstruct ets_sched *q = qdisc_priv(sch);\n\n\tif (band - 1 >= q->nbands)\n\t\treturn 0;\n\treturn band;\n}\n\nstatic void ets_class_qlen_notify(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct ets_class *cl = ets_class_from_arg(sch, arg);\n\tstruct ets_sched *q = qdisc_priv(sch);\n\n\t \n\tif (!ets_class_is_strict(q, cl) && sch->q.qlen)\n\t\tlist_del(&cl->alist);\n}\n\nstatic int ets_class_dump(struct Qdisc *sch, unsigned long arg,\n\t\t\t  struct sk_buff *skb, struct tcmsg *tcm)\n{\n\tstruct ets_class *cl = ets_class_from_arg(sch, arg);\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tstruct nlattr *nest;\n\n\ttcm->tcm_parent = TC_H_ROOT;\n\ttcm->tcm_handle = ets_class_id(sch, cl);\n\ttcm->tcm_info = cl->qdisc->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tif (!ets_class_is_strict(q, cl)) {\n\t\tif (nla_put_u32(skb, TCA_ETS_QUANTA_BAND, cl->quantum))\n\t\t\tgoto nla_put_failure;\n\t}\n\treturn nla_nest_end(skb, nest);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int ets_class_dump_stats(struct Qdisc *sch, unsigned long arg,\n\t\t\t\tstruct gnet_dump *d)\n{\n\tstruct ets_class *cl = ets_class_from_arg(sch, arg);\n\tstruct Qdisc *cl_q = cl->qdisc;\n\n\tif (gnet_stats_copy_basic(d, NULL, &cl_q->bstats, true) < 0 ||\n\t    qdisc_qstats_copy(d, cl_q) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void ets_qdisc_walk(struct Qdisc *sch, struct qdisc_walker *arg)\n{\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tint i;\n\n\tif (arg->stop)\n\t\treturn;\n\n\tfor (i = 0; i < q->nbands; i++) {\n\t\tif (!tc_qdisc_stats_dump(sch, i + 1, arg))\n\t\t\tbreak;\n\t}\n}\n\nstatic struct tcf_block *\nets_qdisc_tcf_block(struct Qdisc *sch, unsigned long cl,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ets_sched *q = qdisc_priv(sch);\n\n\tif (cl) {\n\t\tNL_SET_ERR_MSG(extack, \"ETS classid must be zero\");\n\t\treturn NULL;\n\t}\n\n\treturn q->block;\n}\n\nstatic unsigned long ets_qdisc_bind_tcf(struct Qdisc *sch, unsigned long parent,\n\t\t\t\t\tu32 classid)\n{\n\treturn ets_class_find(sch, classid);\n}\n\nstatic void ets_qdisc_unbind_tcf(struct Qdisc *sch, unsigned long arg)\n{\n}\n\nstatic struct ets_class *ets_classify(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t\t      int *qerr)\n{\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tu32 band = skb->priority;\n\tstruct tcf_result res;\n\tstruct tcf_proto *fl;\n\tint err;\n\n\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\tif (TC_H_MAJ(skb->priority) != sch->handle) {\n\t\tfl = rcu_dereference_bh(q->filter_list);\n\t\terr = tcf_classify(skb, NULL, fl, &res, false);\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (err) {\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\tfallthrough;\n\t\tcase TC_ACT_SHOT:\n\t\t\treturn NULL;\n\t\t}\n#endif\n\t\tif (!fl || err < 0) {\n\t\t\tif (TC_H_MAJ(band))\n\t\t\t\tband = 0;\n\t\t\treturn &q->classes[q->prio2band[band & TC_PRIO_MAX]];\n\t\t}\n\t\tband = res.classid;\n\t}\n\tband = TC_H_MIN(band) - 1;\n\tif (band >= q->nbands)\n\t\treturn &q->classes[q->prio2band[0]];\n\treturn &q->classes[band];\n}\n\nstatic int ets_qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t     struct sk_buff **to_free)\n{\n\tunsigned int len = qdisc_pkt_len(skb);\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tstruct ets_class *cl;\n\tint err = 0;\n\tbool first;\n\n\tcl = ets_classify(skb, sch, &err);\n\tif (!cl) {\n\t\tif (err & __NET_XMIT_BYPASS)\n\t\t\tqdisc_qstats_drop(sch);\n\t\t__qdisc_drop(skb, to_free);\n\t\treturn err;\n\t}\n\n\tfirst = !cl->qdisc->q.qlen;\n\terr = qdisc_enqueue(skb, cl->qdisc, to_free);\n\tif (unlikely(err != NET_XMIT_SUCCESS)) {\n\t\tif (net_xmit_drop_count(err)) {\n\t\t\tcl->qstats.drops++;\n\t\t\tqdisc_qstats_drop(sch);\n\t\t}\n\t\treturn err;\n\t}\n\n\tif (first && !ets_class_is_strict(q, cl)) {\n\t\tlist_add_tail(&cl->alist, &q->active);\n\t\tcl->deficit = cl->quantum;\n\t}\n\n\tsch->qstats.backlog += len;\n\tsch->q.qlen++;\n\treturn err;\n}\n\nstatic struct sk_buff *\nets_qdisc_dequeue_skb(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tqdisc_bstats_update(sch, skb);\n\tqdisc_qstats_backlog_dec(sch, skb);\n\tsch->q.qlen--;\n\treturn skb;\n}\n\nstatic struct sk_buff *ets_qdisc_dequeue(struct Qdisc *sch)\n{\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tstruct ets_class *cl;\n\tstruct sk_buff *skb;\n\tunsigned int band;\n\tunsigned int len;\n\n\twhile (1) {\n\t\tfor (band = 0; band < q->nstrict; band++) {\n\t\t\tcl = &q->classes[band];\n\t\t\tskb = qdisc_dequeue_peeked(cl->qdisc);\n\t\t\tif (skb)\n\t\t\t\treturn ets_qdisc_dequeue_skb(sch, skb);\n\t\t}\n\n\t\tif (list_empty(&q->active))\n\t\t\tgoto out;\n\n\t\tcl = list_first_entry(&q->active, struct ets_class, alist);\n\t\tskb = cl->qdisc->ops->peek(cl->qdisc);\n\t\tif (!skb) {\n\t\t\tqdisc_warn_nonwc(__func__, cl->qdisc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlen = qdisc_pkt_len(skb);\n\t\tif (len <= cl->deficit) {\n\t\t\tcl->deficit -= len;\n\t\t\tskb = qdisc_dequeue_peeked(cl->qdisc);\n\t\t\tif (unlikely(!skb))\n\t\t\t\tgoto out;\n\t\t\tif (cl->qdisc->q.qlen == 0)\n\t\t\t\tlist_del(&cl->alist);\n\t\t\treturn ets_qdisc_dequeue_skb(sch, skb);\n\t\t}\n\n\t\tcl->deficit += cl->quantum;\n\t\tlist_move_tail(&cl->alist, &q->active);\n\t}\nout:\n\treturn NULL;\n}\n\nstatic int ets_qdisc_priomap_parse(struct nlattr *priomap_attr,\n\t\t\t\t   unsigned int nbands, u8 *priomap,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tconst struct nlattr *attr;\n\tint prio = 0;\n\tu8 band;\n\tint rem;\n\tint err;\n\n\terr = __nla_validate_nested(priomap_attr, TCA_ETS_MAX,\n\t\t\t\t    ets_priomap_policy, NL_VALIDATE_STRICT,\n\t\t\t\t    extack);\n\tif (err)\n\t\treturn err;\n\n\tnla_for_each_nested(attr, priomap_attr, rem) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase TCA_ETS_PRIOMAP_BAND:\n\t\t\tif (prio > TC_PRIO_MAX) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Too many priorities in ETS priomap\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tband = nla_get_u8(attr);\n\t\t\tif (band >= nbands) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid band number in ETS priomap\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpriomap[prio++] = band;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);  \n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ets_qdisc_quanta_parse(struct Qdisc *sch, struct nlattr *quanta_attr,\n\t\t\t\t  unsigned int nbands, unsigned int nstrict,\n\t\t\t\t  unsigned int *quanta,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tconst struct nlattr *attr;\n\tint band = nstrict;\n\tint rem;\n\tint err;\n\n\terr = __nla_validate_nested(quanta_attr, TCA_ETS_MAX,\n\t\t\t\t    ets_quanta_policy, NL_VALIDATE_STRICT,\n\t\t\t\t    extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tnla_for_each_nested(attr, quanta_attr, rem) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase TCA_ETS_QUANTA_BAND:\n\t\t\tif (band >= nbands) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"ETS quanta has more values than bands\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = ets_quantum_parse(sch, attr, &quanta[band++],\n\t\t\t\t\t\textack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);  \n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ets_qdisc_change(struct Qdisc *sch, struct nlattr *opt,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tunsigned int quanta[TCQ_ETS_MAX_BANDS] = {0};\n\tstruct Qdisc *queues[TCQ_ETS_MAX_BANDS];\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tstruct nlattr *tb[TCA_ETS_MAX + 1];\n\tunsigned int oldbands = q->nbands;\n\tu8 priomap[TC_PRIO_MAX + 1];\n\tunsigned int nstrict = 0;\n\tunsigned int nbands;\n\tunsigned int i;\n\tint err;\n\n\terr = nla_parse_nested(tb, TCA_ETS_MAX, opt, ets_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_ETS_NBANDS]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Number of bands is a required argument\");\n\t\treturn -EINVAL;\n\t}\n\tnbands = nla_get_u8(tb[TCA_ETS_NBANDS]);\n\tif (nbands < 1 || nbands > TCQ_ETS_MAX_BANDS) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid number of bands\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tmemset(priomap, nbands - 1, sizeof(priomap));\n\n\tif (tb[TCA_ETS_NSTRICT]) {\n\t\tnstrict = nla_get_u8(tb[TCA_ETS_NSTRICT]);\n\t\tif (nstrict > nbands) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid number of strict bands\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (tb[TCA_ETS_PRIOMAP]) {\n\t\terr = ets_qdisc_priomap_parse(tb[TCA_ETS_PRIOMAP],\n\t\t\t\t\t      nbands, priomap, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[TCA_ETS_QUANTA]) {\n\t\terr = ets_qdisc_quanta_parse(sch, tb[TCA_ETS_QUANTA],\n\t\t\t\t\t     nbands, nstrict, quanta, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t \n\tfor (i = nstrict; i < nbands; i++) {\n\t\tif (!quanta[i])\n\t\t\tquanta[i] = psched_mtu(qdisc_dev(sch));\n\t}\n\n\t \n\tfor (i = oldbands; i < nbands; i++) {\n\t\tqueues[i] = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\n\t\t\t\t\t      ets_class_id(sch, &q->classes[i]),\n\t\t\t\t\t      extack);\n\t\tif (!queues[i]) {\n\t\t\twhile (i > oldbands)\n\t\t\t\tqdisc_put(queues[--i]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tsch_tree_lock(sch);\n\n\tq->nbands = nbands;\n\tfor (i = nstrict; i < q->nstrict; i++) {\n\t\tif (q->classes[i].qdisc->q.qlen) {\n\t\t\tlist_add_tail(&q->classes[i].alist, &q->active);\n\t\t\tq->classes[i].deficit = quanta[i];\n\t\t}\n\t}\n\tfor (i = q->nbands; i < oldbands; i++) {\n\t\tif (i >= q->nstrict && q->classes[i].qdisc->q.qlen)\n\t\t\tlist_del(&q->classes[i].alist);\n\t\tqdisc_tree_flush_backlog(q->classes[i].qdisc);\n\t}\n\tq->nstrict = nstrict;\n\tmemcpy(q->prio2band, priomap, sizeof(priomap));\n\n\tfor (i = 0; i < q->nbands; i++)\n\t\tq->classes[i].quantum = quanta[i];\n\n\tfor (i = oldbands; i < q->nbands; i++) {\n\t\tq->classes[i].qdisc = queues[i];\n\t\tif (q->classes[i].qdisc != &noop_qdisc)\n\t\t\tqdisc_hash_add(q->classes[i].qdisc, true);\n\t}\n\n\tsch_tree_unlock(sch);\n\n\tets_offload_change(sch);\n\tfor (i = q->nbands; i < oldbands; i++) {\n\t\tqdisc_put(q->classes[i].qdisc);\n\t\tq->classes[i].qdisc = NULL;\n\t\tq->classes[i].quantum = 0;\n\t\tq->classes[i].deficit = 0;\n\t\tgnet_stats_basic_sync_init(&q->classes[i].bstats);\n\t\tmemset(&q->classes[i].qstats, 0, sizeof(q->classes[i].qstats));\n\t}\n\treturn 0;\n}\n\nstatic int ets_qdisc_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tint err, i;\n\n\tif (!opt)\n\t\treturn -EINVAL;\n\n\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);\n\tif (err)\n\t\treturn err;\n\n\tINIT_LIST_HEAD(&q->active);\n\tfor (i = 0; i < TCQ_ETS_MAX_BANDS; i++)\n\t\tINIT_LIST_HEAD(&q->classes[i].alist);\n\n\treturn ets_qdisc_change(sch, opt, extack);\n}\n\nstatic void ets_qdisc_reset(struct Qdisc *sch)\n{\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tint band;\n\n\tfor (band = q->nstrict; band < q->nbands; band++) {\n\t\tif (q->classes[band].qdisc->q.qlen)\n\t\t\tlist_del(&q->classes[band].alist);\n\t}\n\tfor (band = 0; band < q->nbands; band++)\n\t\tqdisc_reset(q->classes[band].qdisc);\n}\n\nstatic void ets_qdisc_destroy(struct Qdisc *sch)\n{\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tint band;\n\n\tets_offload_destroy(sch);\n\ttcf_block_put(q->block);\n\tfor (band = 0; band < q->nbands; band++)\n\t\tqdisc_put(q->classes[band].qdisc);\n}\n\nstatic int ets_qdisc_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct ets_sched *q = qdisc_priv(sch);\n\tstruct nlattr *opts;\n\tstruct nlattr *nest;\n\tint band;\n\tint prio;\n\tint err;\n\n\terr = ets_offload_dump(sch);\n\tif (err)\n\t\treturn err;\n\n\topts = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (!opts)\n\t\tgoto nla_err;\n\n\tif (nla_put_u8(skb, TCA_ETS_NBANDS, q->nbands))\n\t\tgoto nla_err;\n\n\tif (q->nstrict &&\n\t    nla_put_u8(skb, TCA_ETS_NSTRICT, q->nstrict))\n\t\tgoto nla_err;\n\n\tif (q->nbands > q->nstrict) {\n\t\tnest = nla_nest_start(skb, TCA_ETS_QUANTA);\n\t\tif (!nest)\n\t\t\tgoto nla_err;\n\n\t\tfor (band = q->nstrict; band < q->nbands; band++) {\n\t\t\tif (nla_put_u32(skb, TCA_ETS_QUANTA_BAND,\n\t\t\t\t\tq->classes[band].quantum))\n\t\t\t\tgoto nla_err;\n\t\t}\n\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\tnest = nla_nest_start(skb, TCA_ETS_PRIOMAP);\n\tif (!nest)\n\t\tgoto nla_err;\n\n\tfor (prio = 0; prio <= TC_PRIO_MAX; prio++) {\n\t\tif (nla_put_u8(skb, TCA_ETS_PRIOMAP_BAND, q->prio2band[prio]))\n\t\t\tgoto nla_err;\n\t}\n\n\tnla_nest_end(skb, nest);\n\n\treturn nla_nest_end(skb, opts);\n\nnla_err:\n\tnla_nest_cancel(skb, opts);\n\treturn -EMSGSIZE;\n}\n\nstatic const struct Qdisc_class_ops ets_class_ops = {\n\t.change\t\t= ets_class_change,\n\t.graft\t\t= ets_class_graft,\n\t.leaf\t\t= ets_class_leaf,\n\t.find\t\t= ets_class_find,\n\t.qlen_notify\t= ets_class_qlen_notify,\n\t.dump\t\t= ets_class_dump,\n\t.dump_stats\t= ets_class_dump_stats,\n\t.walk\t\t= ets_qdisc_walk,\n\t.tcf_block\t= ets_qdisc_tcf_block,\n\t.bind_tcf\t= ets_qdisc_bind_tcf,\n\t.unbind_tcf\t= ets_qdisc_unbind_tcf,\n};\n\nstatic struct Qdisc_ops ets_qdisc_ops __read_mostly = {\n\t.cl_ops\t\t= &ets_class_ops,\n\t.id\t\t= \"ets\",\n\t.priv_size\t= sizeof(struct ets_sched),\n\t.enqueue\t= ets_qdisc_enqueue,\n\t.dequeue\t= ets_qdisc_dequeue,\n\t.peek\t\t= qdisc_peek_dequeued,\n\t.change\t\t= ets_qdisc_change,\n\t.init\t\t= ets_qdisc_init,\n\t.reset\t\t= ets_qdisc_reset,\n\t.destroy\t= ets_qdisc_destroy,\n\t.dump\t\t= ets_qdisc_dump,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init ets_init(void)\n{\n\treturn register_qdisc(&ets_qdisc_ops);\n}\n\nstatic void __exit ets_exit(void)\n{\n\tunregister_qdisc(&ets_qdisc_ops);\n}\n\nmodule_init(ets_init);\nmodule_exit(ets_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}