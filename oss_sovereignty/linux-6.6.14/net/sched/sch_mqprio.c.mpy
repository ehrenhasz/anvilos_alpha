{
  "module_name": "sch_mqprio.c",
  "hash_id": "32deeebcfb383d5bb4082941ba2322d50c3cf395ed1f29cf7c71de44760ff218",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_mqprio.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool_netlink.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/module.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/sch_generic.h>\n#include <net/pkt_cls.h>\n\n#include \"sch_mqprio_lib.h\"\n\nstruct mqprio_sched {\n\tstruct Qdisc\t\t**qdiscs;\n\tu16 mode;\n\tu16 shaper;\n\tint hw_offload;\n\tu32 flags;\n\tu64 min_rate[TC_QOPT_MAX_QUEUE];\n\tu64 max_rate[TC_QOPT_MAX_QUEUE];\n\tu32 fp[TC_QOPT_MAX_QUEUE];\n};\n\nstatic int mqprio_enable_offload(struct Qdisc *sch,\n\t\t\t\t const struct tc_mqprio_qopt *qopt,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mqprio_sched *priv = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct tc_mqprio_qopt_offload mqprio = {\n\t\t.qopt = *qopt,\n\t\t.extack = extack,\n\t};\n\tint err, i;\n\n\tswitch (priv->mode) {\n\tcase TC_MQPRIO_MODE_DCB:\n\t\tif (priv->shaper != TC_MQPRIO_SHAPER_DCB)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase TC_MQPRIO_MODE_CHANNEL:\n\t\tmqprio.flags = priv->flags;\n\t\tif (priv->flags & TC_MQPRIO_F_MODE)\n\t\t\tmqprio.mode = priv->mode;\n\t\tif (priv->flags & TC_MQPRIO_F_SHAPER)\n\t\t\tmqprio.shaper = priv->shaper;\n\t\tif (priv->flags & TC_MQPRIO_F_MIN_RATE)\n\t\t\tfor (i = 0; i < mqprio.qopt.num_tc; i++)\n\t\t\t\tmqprio.min_rate[i] = priv->min_rate[i];\n\t\tif (priv->flags & TC_MQPRIO_F_MAX_RATE)\n\t\t\tfor (i = 0; i < mqprio.qopt.num_tc; i++)\n\t\t\t\tmqprio.max_rate[i] = priv->max_rate[i];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmqprio_fp_to_offload(priv->fp, &mqprio);\n\n\terr = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_MQPRIO,\n\t\t\t\t\t    &mqprio);\n\tif (err)\n\t\treturn err;\n\n\tpriv->hw_offload = mqprio.qopt.hw;\n\n\treturn 0;\n}\n\nstatic void mqprio_disable_offload(struct Qdisc *sch)\n{\n\tstruct tc_mqprio_qopt_offload mqprio = { { 0 } };\n\tstruct mqprio_sched *priv = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\n\tswitch (priv->mode) {\n\tcase TC_MQPRIO_MODE_DCB:\n\tcase TC_MQPRIO_MODE_CHANNEL:\n\t\tdev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_MQPRIO,\n\t\t\t\t\t      &mqprio);\n\t\tbreak;\n\t}\n}\n\nstatic void mqprio_destroy(struct Qdisc *sch)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct mqprio_sched *priv = qdisc_priv(sch);\n\tunsigned int ntx;\n\n\tif (priv->qdiscs) {\n\t\tfor (ntx = 0;\n\t\t     ntx < dev->num_tx_queues && priv->qdiscs[ntx];\n\t\t     ntx++)\n\t\t\tqdisc_put(priv->qdiscs[ntx]);\n\t\tkfree(priv->qdiscs);\n\t}\n\n\tif (priv->hw_offload && dev->netdev_ops->ndo_setup_tc)\n\t\tmqprio_disable_offload(sch);\n\telse\n\t\tnetdev_set_num_tc(dev, 0);\n}\n\nstatic int mqprio_parse_opt(struct net_device *dev, struct tc_mqprio_qopt *qopt,\n\t\t\t    const struct tc_mqprio_caps *caps,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\t \n\tif (qopt->hw > TC_MQPRIO_HW_OFFLOAD_MAX)\n\t\tqopt->hw = TC_MQPRIO_HW_OFFLOAD_MAX;\n\n\t \n\terr = mqprio_validate_qopt(dev, qopt,\n\t\t\t\t   !qopt->hw || caps->validate_queue_counts,\n\t\t\t\t   false, extack);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (qopt->hw && !dev->netdev_ops->ndo_setup_tc) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Device does not support hardware offload\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct\nnla_policy mqprio_tc_entry_policy[TCA_MQPRIO_TC_ENTRY_MAX + 1] = {\n\t[TCA_MQPRIO_TC_ENTRY_INDEX]\t= NLA_POLICY_MAX(NLA_U32,\n\t\t\t\t\t\t\t TC_QOPT_MAX_QUEUE),\n\t[TCA_MQPRIO_TC_ENTRY_FP]\t= NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t\t   TC_FP_EXPRESS,\n\t\t\t\t\t\t\t   TC_FP_PREEMPTIBLE),\n};\n\nstatic const struct nla_policy mqprio_policy[TCA_MQPRIO_MAX + 1] = {\n\t[TCA_MQPRIO_MODE]\t= { .len = sizeof(u16) },\n\t[TCA_MQPRIO_SHAPER]\t= { .len = sizeof(u16) },\n\t[TCA_MQPRIO_MIN_RATE64]\t= { .type = NLA_NESTED },\n\t[TCA_MQPRIO_MAX_RATE64]\t= { .type = NLA_NESTED },\n\t[TCA_MQPRIO_TC_ENTRY]\t= { .type = NLA_NESTED },\n};\n\nstatic int mqprio_parse_tc_entry(u32 fp[TC_QOPT_MAX_QUEUE],\n\t\t\t\t struct nlattr *opt,\n\t\t\t\t unsigned long *seen_tcs,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_MQPRIO_TC_ENTRY_MAX + 1];\n\tint err, tc;\n\n\terr = nla_parse_nested(tb, TCA_MQPRIO_TC_ENTRY_MAX, opt,\n\t\t\t       mqprio_tc_entry_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (NL_REQ_ATTR_CHECK(extack, opt, tb, TCA_MQPRIO_TC_ENTRY_INDEX)) {\n\t\tNL_SET_ERR_MSG(extack, \"TC entry index missing\");\n\t\treturn -EINVAL;\n\t}\n\n\ttc = nla_get_u32(tb[TCA_MQPRIO_TC_ENTRY_INDEX]);\n\tif (*seen_tcs & BIT(tc)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[TCA_MQPRIO_TC_ENTRY_INDEX],\n\t\t\t\t    \"Duplicate tc entry\");\n\t\treturn -EINVAL;\n\t}\n\n\t*seen_tcs |= BIT(tc);\n\n\tif (tb[TCA_MQPRIO_TC_ENTRY_FP])\n\t\tfp[tc] = nla_get_u32(tb[TCA_MQPRIO_TC_ENTRY_FP]);\n\n\treturn 0;\n}\n\nstatic int mqprio_parse_tc_entries(struct Qdisc *sch, struct nlattr *nlattr_opt,\n\t\t\t\t   int nlattr_opt_len,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mqprio_sched *priv = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tbool have_preemption = false;\n\tunsigned long seen_tcs = 0;\n\tu32 fp[TC_QOPT_MAX_QUEUE];\n\tstruct nlattr *n;\n\tint tc, rem;\n\tint err = 0;\n\n\tfor (tc = 0; tc < TC_QOPT_MAX_QUEUE; tc++)\n\t\tfp[tc] = priv->fp[tc];\n\n\tnla_for_each_attr(n, nlattr_opt, nlattr_opt_len, rem) {\n\t\tif (nla_type(n) != TCA_MQPRIO_TC_ENTRY)\n\t\t\tcontinue;\n\n\t\terr = mqprio_parse_tc_entry(fp, n, &seen_tcs, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfor (tc = 0; tc < TC_QOPT_MAX_QUEUE; tc++) {\n\t\tpriv->fp[tc] = fp[tc];\n\t\tif (fp[tc] == TC_FP_PREEMPTIBLE)\n\t\t\thave_preemption = true;\n\t}\n\n\tif (have_preemption && !ethtool_dev_mm_supported(dev)) {\n\t\tNL_SET_ERR_MSG(extack, \"Device does not support preemption\");\n\t\treturn -EOPNOTSUPP;\n\t}\nout:\n\treturn err;\n}\n\n \nstatic int mqprio_parse_nlattr(struct Qdisc *sch, struct tc_mqprio_qopt *qopt,\n\t\t\t       struct nlattr *opt,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *nlattr_opt = nla_data(opt) + NLA_ALIGN(sizeof(*qopt));\n\tint nlattr_opt_len = nla_len(opt) - NLA_ALIGN(sizeof(*qopt));\n\tstruct mqprio_sched *priv = qdisc_priv(sch);\n\tstruct nlattr *tb[TCA_MQPRIO_MAX + 1] = {};\n\tstruct nlattr *attr;\n\tint i, rem, err;\n\n\tif (nlattr_opt_len >= nla_attr_size(0)) {\n\t\terr = nla_parse_deprecated(tb, TCA_MQPRIO_MAX, nlattr_opt,\n\t\t\t\t\t   nlattr_opt_len, mqprio_policy,\n\t\t\t\t\t   NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!qopt->hw) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"mqprio TCA_OPTIONS can only contain netlink attributes in hardware mode\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[TCA_MQPRIO_MODE]) {\n\t\tpriv->flags |= TC_MQPRIO_F_MODE;\n\t\tpriv->mode = nla_get_u16(tb[TCA_MQPRIO_MODE]);\n\t}\n\n\tif (tb[TCA_MQPRIO_SHAPER]) {\n\t\tpriv->flags |= TC_MQPRIO_F_SHAPER;\n\t\tpriv->shaper = nla_get_u16(tb[TCA_MQPRIO_SHAPER]);\n\t}\n\n\tif (tb[TCA_MQPRIO_MIN_RATE64]) {\n\t\tif (priv->shaper != TC_MQPRIO_SHAPER_BW_RATE) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[TCA_MQPRIO_MIN_RATE64],\n\t\t\t\t\t    \"min_rate accepted only when shaper is in bw_rlimit mode\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti = 0;\n\t\tnla_for_each_nested(attr, tb[TCA_MQPRIO_MIN_RATE64],\n\t\t\t\t    rem) {\n\t\t\tif (nla_type(attr) != TCA_MQPRIO_MIN_RATE64) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t\t    \"Attribute type expected to be TCA_MQPRIO_MIN_RATE64\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (nla_len(attr) != sizeof(u64)) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t\t    \"Attribute TCA_MQPRIO_MIN_RATE64 expected to have 8 bytes length\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (i >= qopt->num_tc)\n\t\t\t\tbreak;\n\t\t\tpriv->min_rate[i] = nla_get_u64(attr);\n\t\t\ti++;\n\t\t}\n\t\tpriv->flags |= TC_MQPRIO_F_MIN_RATE;\n\t}\n\n\tif (tb[TCA_MQPRIO_MAX_RATE64]) {\n\t\tif (priv->shaper != TC_MQPRIO_SHAPER_BW_RATE) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[TCA_MQPRIO_MAX_RATE64],\n\t\t\t\t\t    \"max_rate accepted only when shaper is in bw_rlimit mode\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti = 0;\n\t\tnla_for_each_nested(attr, tb[TCA_MQPRIO_MAX_RATE64],\n\t\t\t\t    rem) {\n\t\t\tif (nla_type(attr) != TCA_MQPRIO_MAX_RATE64) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t\t    \"Attribute type expected to be TCA_MQPRIO_MAX_RATE64\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (nla_len(attr) != sizeof(u64)) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t\t    \"Attribute TCA_MQPRIO_MAX_RATE64 expected to have 8 bytes length\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (i >= qopt->num_tc)\n\t\t\t\tbreak;\n\t\t\tpriv->max_rate[i] = nla_get_u64(attr);\n\t\t\ti++;\n\t\t}\n\t\tpriv->flags |= TC_MQPRIO_F_MAX_RATE;\n\t}\n\n\tif (tb[TCA_MQPRIO_TC_ENTRY]) {\n\t\terr = mqprio_parse_tc_entries(sch, nlattr_opt, nlattr_opt_len,\n\t\t\t\t\t      extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mqprio_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct mqprio_sched *priv = qdisc_priv(sch);\n\tstruct netdev_queue *dev_queue;\n\tstruct Qdisc *qdisc;\n\tint i, err = -EOPNOTSUPP;\n\tstruct tc_mqprio_qopt *qopt = NULL;\n\tstruct tc_mqprio_caps caps;\n\tint len, tc;\n\n\tBUILD_BUG_ON(TC_MAX_QUEUE != TC_QOPT_MAX_QUEUE);\n\tBUILD_BUG_ON(TC_BITMASK != TC_QOPT_BITMASK);\n\n\tif (sch->parent != TC_H_ROOT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!netif_is_multiqueue(dev))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (dev->num_tx_queues >= TC_H_MIN_PRIORITY)\n\t\treturn -ENOMEM;\n\n\tif (!opt || nla_len(opt) < sizeof(*qopt))\n\t\treturn -EINVAL;\n\n\tfor (tc = 0; tc < TC_QOPT_MAX_QUEUE; tc++)\n\t\tpriv->fp[tc] = TC_FP_EXPRESS;\n\n\tqdisc_offload_query_caps(dev, TC_SETUP_QDISC_MQPRIO,\n\t\t\t\t &caps, sizeof(caps));\n\n\tqopt = nla_data(opt);\n\tif (mqprio_parse_opt(dev, qopt, &caps, extack))\n\t\treturn -EINVAL;\n\n\tlen = nla_len(opt) - NLA_ALIGN(sizeof(*qopt));\n\tif (len > 0) {\n\t\terr = mqprio_parse_nlattr(sch, qopt, opt, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tpriv->qdiscs = kcalloc(dev->num_tx_queues, sizeof(priv->qdiscs[0]),\n\t\t\t       GFP_KERNEL);\n\tif (!priv->qdiscs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++) {\n\t\tdev_queue = netdev_get_tx_queue(dev, i);\n\t\tqdisc = qdisc_create_dflt(dev_queue,\n\t\t\t\t\t  get_default_qdisc_ops(dev, i),\n\t\t\t\t\t  TC_H_MAKE(TC_H_MAJ(sch->handle),\n\t\t\t\t\t\t    TC_H_MIN(i + 1)), extack);\n\t\tif (!qdisc)\n\t\t\treturn -ENOMEM;\n\n\t\tpriv->qdiscs[i] = qdisc;\n\t\tqdisc->flags |= TCQ_F_ONETXQUEUE | TCQ_F_NOPARENT;\n\t}\n\n\t \n\tif (qopt->hw) {\n\t\terr = mqprio_enable_offload(sch, qopt, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tnetdev_set_num_tc(dev, qopt->num_tc);\n\t\tfor (i = 0; i < qopt->num_tc; i++)\n\t\t\tnetdev_set_tc_queue(dev, i,\n\t\t\t\t\t    qopt->count[i], qopt->offset[i]);\n\t}\n\n\t \n\tfor (i = 0; i < TC_BITMASK + 1; i++)\n\t\tnetdev_set_prio_tc_map(dev, i, qopt->prio_tc_map[i]);\n\n\tsch->flags |= TCQ_F_MQROOT;\n\treturn 0;\n}\n\nstatic void mqprio_attach(struct Qdisc *sch)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct mqprio_sched *priv = qdisc_priv(sch);\n\tstruct Qdisc *qdisc, *old;\n\tunsigned int ntx;\n\n\t \n\tfor (ntx = 0; ntx < dev->num_tx_queues; ntx++) {\n\t\tqdisc = priv->qdiscs[ntx];\n\t\told = dev_graft_qdisc(qdisc->dev_queue, qdisc);\n\t\tif (old)\n\t\t\tqdisc_put(old);\n\t\tif (ntx < dev->real_num_tx_queues)\n\t\t\tqdisc_hash_add(qdisc, false);\n\t}\n\tkfree(priv->qdiscs);\n\tpriv->qdiscs = NULL;\n}\n\nstatic struct netdev_queue *mqprio_queue_get(struct Qdisc *sch,\n\t\t\t\t\t     unsigned long cl)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tunsigned long ntx = cl - 1;\n\n\tif (ntx >= dev->num_tx_queues)\n\t\treturn NULL;\n\treturn netdev_get_tx_queue(dev, ntx);\n}\n\nstatic int mqprio_graft(struct Qdisc *sch, unsigned long cl, struct Qdisc *new,\n\t\t\tstruct Qdisc **old, struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct netdev_queue *dev_queue = mqprio_queue_get(sch, cl);\n\n\tif (!dev_queue)\n\t\treturn -EINVAL;\n\n\tif (dev->flags & IFF_UP)\n\t\tdev_deactivate(dev);\n\n\t*old = dev_graft_qdisc(dev_queue, new);\n\n\tif (new)\n\t\tnew->flags |= TCQ_F_ONETXQUEUE | TCQ_F_NOPARENT;\n\n\tif (dev->flags & IFF_UP)\n\t\tdev_activate(dev);\n\n\treturn 0;\n}\n\nstatic int dump_rates(struct mqprio_sched *priv,\n\t\t      struct tc_mqprio_qopt *opt, struct sk_buff *skb)\n{\n\tstruct nlattr *nest;\n\tint i;\n\n\tif (priv->flags & TC_MQPRIO_F_MIN_RATE) {\n\t\tnest = nla_nest_start_noflag(skb, TCA_MQPRIO_MIN_RATE64);\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < opt->num_tc; i++) {\n\t\t\tif (nla_put(skb, TCA_MQPRIO_MIN_RATE64,\n\t\t\t\t    sizeof(priv->min_rate[i]),\n\t\t\t\t    &priv->min_rate[i]))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\tif (priv->flags & TC_MQPRIO_F_MAX_RATE) {\n\t\tnest = nla_nest_start_noflag(skb, TCA_MQPRIO_MAX_RATE64);\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < opt->num_tc; i++) {\n\t\t\tif (nla_put(skb, TCA_MQPRIO_MAX_RATE64,\n\t\t\t\t    sizeof(priv->max_rate[i]),\n\t\t\t\t    &priv->max_rate[i]))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\t}\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic int mqprio_dump_tc_entries(struct mqprio_sched *priv,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct nlattr *n;\n\tint tc;\n\n\tfor (tc = 0; tc < TC_QOPT_MAX_QUEUE; tc++) {\n\t\tn = nla_nest_start(skb, TCA_MQPRIO_TC_ENTRY);\n\t\tif (!n)\n\t\t\treturn -EMSGSIZE;\n\n\t\tif (nla_put_u32(skb, TCA_MQPRIO_TC_ENTRY_INDEX, tc))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(skb, TCA_MQPRIO_TC_ENTRY_FP, priv->fp[tc]))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, n);\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, n);\n\treturn -EMSGSIZE;\n}\n\nstatic int mqprio_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct mqprio_sched *priv = qdisc_priv(sch);\n\tstruct nlattr *nla = (struct nlattr *)skb_tail_pointer(skb);\n\tstruct tc_mqprio_qopt opt = { 0 };\n\tstruct Qdisc *qdisc;\n\tunsigned int ntx;\n\n\tsch->q.qlen = 0;\n\tgnet_stats_basic_sync_init(&sch->bstats);\n\tmemset(&sch->qstats, 0, sizeof(sch->qstats));\n\n\t \n\tfor (ntx = 0; ntx < dev->num_tx_queues; ntx++) {\n\t\tqdisc = rtnl_dereference(netdev_get_tx_queue(dev, ntx)->qdisc_sleeping);\n\t\tspin_lock_bh(qdisc_lock(qdisc));\n\n\t\tgnet_stats_add_basic(&sch->bstats, qdisc->cpu_bstats,\n\t\t\t\t     &qdisc->bstats, false);\n\t\tgnet_stats_add_queue(&sch->qstats, qdisc->cpu_qstats,\n\t\t\t\t     &qdisc->qstats);\n\t\tsch->q.qlen += qdisc_qlen(qdisc);\n\n\t\tspin_unlock_bh(qdisc_lock(qdisc));\n\t}\n\n\tmqprio_qopt_reconstruct(dev, &opt);\n\topt.hw = priv->hw_offload;\n\n\tif (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\tif ((priv->flags & TC_MQPRIO_F_MODE) &&\n\t    nla_put_u16(skb, TCA_MQPRIO_MODE, priv->mode))\n\t\tgoto nla_put_failure;\n\n\tif ((priv->flags & TC_MQPRIO_F_SHAPER) &&\n\t    nla_put_u16(skb, TCA_MQPRIO_SHAPER, priv->shaper))\n\t\tgoto nla_put_failure;\n\n\tif ((priv->flags & TC_MQPRIO_F_MIN_RATE ||\n\t     priv->flags & TC_MQPRIO_F_MAX_RATE) &&\n\t    (dump_rates(priv, &opt, skb) != 0))\n\t\tgoto nla_put_failure;\n\n\tif (mqprio_dump_tc_entries(priv, skb))\n\t\tgoto nla_put_failure;\n\n\treturn nla_nest_end(skb, nla);\nnla_put_failure:\n\tnlmsg_trim(skb, nla);\n\treturn -1;\n}\n\nstatic struct Qdisc *mqprio_leaf(struct Qdisc *sch, unsigned long cl)\n{\n\tstruct netdev_queue *dev_queue = mqprio_queue_get(sch, cl);\n\n\tif (!dev_queue)\n\t\treturn NULL;\n\n\treturn rtnl_dereference(dev_queue->qdisc_sleeping);\n}\n\nstatic unsigned long mqprio_find(struct Qdisc *sch, u32 classid)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tunsigned int ntx = TC_H_MIN(classid);\n\n\t \n\tif (ntx < TC_H_MIN_PRIORITY)\n\t\treturn (ntx <= dev->num_tx_queues) ? ntx : 0;\n\n\t \n\treturn ((ntx - TC_H_MIN_PRIORITY) < netdev_get_num_tc(dev)) ? ntx : 0;\n}\n\nstatic int mqprio_dump_class(struct Qdisc *sch, unsigned long cl,\n\t\t\t struct sk_buff *skb, struct tcmsg *tcm)\n{\n\tif (cl < TC_H_MIN_PRIORITY) {\n\t\tstruct netdev_queue *dev_queue = mqprio_queue_get(sch, cl);\n\t\tstruct net_device *dev = qdisc_dev(sch);\n\t\tint tc = netdev_txq_to_tc(dev, cl - 1);\n\n\t\ttcm->tcm_parent = (tc < 0) ? 0 :\n\t\t\tTC_H_MAKE(TC_H_MAJ(sch->handle),\n\t\t\t\t  TC_H_MIN(tc + TC_H_MIN_PRIORITY));\n\t\ttcm->tcm_info = rtnl_dereference(dev_queue->qdisc_sleeping)->handle;\n\t} else {\n\t\ttcm->tcm_parent = TC_H_ROOT;\n\t\ttcm->tcm_info = 0;\n\t}\n\ttcm->tcm_handle |= TC_H_MIN(cl);\n\treturn 0;\n}\n\nstatic int mqprio_dump_class_stats(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t   struct gnet_dump *d)\n\t__releases(d->lock)\n\t__acquires(d->lock)\n{\n\tif (cl >= TC_H_MIN_PRIORITY) {\n\t\tint i;\n\t\t__u32 qlen;\n\t\tstruct gnet_stats_queue qstats = {0};\n\t\tstruct gnet_stats_basic_sync bstats;\n\t\tstruct net_device *dev = qdisc_dev(sch);\n\t\tstruct netdev_tc_txq tc = dev->tc_to_txq[cl & TC_BITMASK];\n\n\t\tgnet_stats_basic_sync_init(&bstats);\n\t\t \n\t\tif (d->lock)\n\t\t\tspin_unlock_bh(d->lock);\n\n\t\tfor (i = tc.offset; i < tc.offset + tc.count; i++) {\n\t\t\tstruct netdev_queue *q = netdev_get_tx_queue(dev, i);\n\t\t\tstruct Qdisc *qdisc = rtnl_dereference(q->qdisc);\n\n\t\t\tspin_lock_bh(qdisc_lock(qdisc));\n\n\t\t\tgnet_stats_add_basic(&bstats, qdisc->cpu_bstats,\n\t\t\t\t\t     &qdisc->bstats, false);\n\t\t\tgnet_stats_add_queue(&qstats, qdisc->cpu_qstats,\n\t\t\t\t\t     &qdisc->qstats);\n\t\t\tsch->q.qlen += qdisc_qlen(qdisc);\n\n\t\t\tspin_unlock_bh(qdisc_lock(qdisc));\n\t\t}\n\t\tqlen = qdisc_qlen(sch) + qstats.qlen;\n\n\t\t \n\t\tif (d->lock)\n\t\t\tspin_lock_bh(d->lock);\n\t\tif (gnet_stats_copy_basic(d, NULL, &bstats, false) < 0 ||\n\t\t    gnet_stats_copy_queue(d, NULL, &qstats, qlen) < 0)\n\t\t\treturn -1;\n\t} else {\n\t\tstruct netdev_queue *dev_queue = mqprio_queue_get(sch, cl);\n\n\t\tsch = rtnl_dereference(dev_queue->qdisc_sleeping);\n\t\tif (gnet_stats_copy_basic(d, sch->cpu_bstats,\n\t\t\t\t\t  &sch->bstats, true) < 0 ||\n\t\t    qdisc_qstats_copy(d, sch) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void mqprio_walk(struct Qdisc *sch, struct qdisc_walker *arg)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tunsigned long ntx;\n\n\tif (arg->stop)\n\t\treturn;\n\n\t \n\targ->count = arg->skip;\n\tfor (ntx = arg->skip; ntx < netdev_get_num_tc(dev); ntx++) {\n\t\tif (!tc_qdisc_stats_dump(sch, ntx + TC_H_MIN_PRIORITY, arg))\n\t\t\treturn;\n\t}\n\n\t \n\tif (ntx < TC_MAX_QUEUE) {\n\t\targ->count = TC_MAX_QUEUE;\n\t\tntx = TC_MAX_QUEUE;\n\t}\n\n\t \n\tfor (ntx -= TC_MAX_QUEUE; ntx < dev->num_tx_queues; ntx++) {\n\t\tif (arg->fn(sch, ntx + 1, arg) < 0) {\n\t\t\targ->stop = 1;\n\t\t\treturn;\n\t\t}\n\t\targ->count++;\n\t}\n}\n\nstatic struct netdev_queue *mqprio_select_queue(struct Qdisc *sch,\n\t\t\t\t\t\tstruct tcmsg *tcm)\n{\n\treturn mqprio_queue_get(sch, TC_H_MIN(tcm->tcm_parent));\n}\n\nstatic const struct Qdisc_class_ops mqprio_class_ops = {\n\t.graft\t\t= mqprio_graft,\n\t.leaf\t\t= mqprio_leaf,\n\t.find\t\t= mqprio_find,\n\t.walk\t\t= mqprio_walk,\n\t.dump\t\t= mqprio_dump_class,\n\t.dump_stats\t= mqprio_dump_class_stats,\n\t.select_queue\t= mqprio_select_queue,\n};\n\nstatic struct Qdisc_ops mqprio_qdisc_ops __read_mostly = {\n\t.cl_ops\t\t= &mqprio_class_ops,\n\t.id\t\t= \"mqprio\",\n\t.priv_size\t= sizeof(struct mqprio_sched),\n\t.init\t\t= mqprio_init,\n\t.destroy\t= mqprio_destroy,\n\t.attach\t\t= mqprio_attach,\n\t.change_real_num_tx = mq_change_real_num_tx,\n\t.dump\t\t= mqprio_dump,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init mqprio_module_init(void)\n{\n\treturn register_qdisc(&mqprio_qdisc_ops);\n}\n\nstatic void __exit mqprio_module_exit(void)\n{\n\tunregister_qdisc(&mqprio_qdisc_ops);\n}\n\nmodule_init(mqprio_module_init);\nmodule_exit(mqprio_module_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}