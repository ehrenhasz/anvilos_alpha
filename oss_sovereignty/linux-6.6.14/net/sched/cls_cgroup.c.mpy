{
  "module_name": "cls_cgroup.c",
  "hash_id": "0b6757cccb441d146461005c89906444b84dae3679077e0bf76f158065376355",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/cls_cgroup.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/rcupdate.h>\n#include <net/rtnetlink.h>\n#include <net/pkt_cls.h>\n#include <net/sock.h>\n#include <net/cls_cgroup.h>\n#include <net/tc_wrapper.h>\n\nstruct cls_cgroup_head {\n\tu32\t\t\thandle;\n\tstruct tcf_exts\t\texts;\n\tstruct tcf_ematch_tree\tematches;\n\tstruct tcf_proto\t*tp;\n\tstruct rcu_work\t\trwork;\n};\n\nTC_INDIRECT_SCOPE int cls_cgroup_classify(struct sk_buff *skb,\n\t\t\t\t\t  const struct tcf_proto *tp,\n\t\t\t\t\t  struct tcf_result *res)\n{\n\tstruct cls_cgroup_head *head = rcu_dereference_bh(tp->root);\n\tu32 classid = task_get_classid(skb);\n\n\tif (unlikely(!head))\n\t\treturn -1;\n\tif (!classid)\n\t\treturn -1;\n\tif (!tcf_em_tree_match(skb, &head->ematches, NULL))\n\t\treturn -1;\n\n\tres->classid = classid;\n\tres->class = 0;\n\n\treturn tcf_exts_exec(skb, &head->exts, res);\n}\n\nstatic void *cls_cgroup_get(struct tcf_proto *tp, u32 handle)\n{\n\treturn NULL;\n}\n\nstatic int cls_cgroup_init(struct tcf_proto *tp)\n{\n\treturn 0;\n}\n\nstatic const struct nla_policy cgroup_policy[TCA_CGROUP_MAX + 1] = {\n\t[TCA_CGROUP_EMATCHES]\t= { .type = NLA_NESTED },\n};\n\nstatic void __cls_cgroup_destroy(struct cls_cgroup_head *head)\n{\n\ttcf_exts_destroy(&head->exts);\n\ttcf_em_tree_destroy(&head->ematches);\n\ttcf_exts_put_net(&head->exts);\n\tkfree(head);\n}\n\nstatic void cls_cgroup_destroy_work(struct work_struct *work)\n{\n\tstruct cls_cgroup_head *head = container_of(to_rcu_work(work),\n\t\t\t\t\t\t    struct cls_cgroup_head,\n\t\t\t\t\t\t    rwork);\n\trtnl_lock();\n\t__cls_cgroup_destroy(head);\n\trtnl_unlock();\n}\n\nstatic int cls_cgroup_change(struct net *net, struct sk_buff *in_skb,\n\t\t\t     struct tcf_proto *tp, unsigned long base,\n\t\t\t     u32 handle, struct nlattr **tca,\n\t\t\t     void **arg, u32 flags,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_CGROUP_MAX + 1];\n\tstruct cls_cgroup_head *head = rtnl_dereference(tp->root);\n\tstruct cls_cgroup_head *new;\n\tint err;\n\n\tif (!tca[TCA_OPTIONS])\n\t\treturn -EINVAL;\n\n\tif (!head && !handle)\n\t\treturn -EINVAL;\n\n\tif (head && handle != head->handle)\n\t\treturn -ENOENT;\n\n\tnew = kzalloc(sizeof(*head), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOBUFS;\n\n\terr = tcf_exts_init(&new->exts, net, TCA_CGROUP_ACT, TCA_CGROUP_POLICE);\n\tif (err < 0)\n\t\tgoto errout;\n\tnew->handle = handle;\n\tnew->tp = tp;\n\terr = nla_parse_nested_deprecated(tb, TCA_CGROUP_MAX,\n\t\t\t\t\t  tca[TCA_OPTIONS], cgroup_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &new->exts, flags,\n\t\t\t\textack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = tcf_em_tree_validate(tp, tb[TCA_CGROUP_EMATCHES], &new->ematches);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trcu_assign_pointer(tp->root, new);\n\tif (head) {\n\t\ttcf_exts_get_net(&head->exts);\n\t\ttcf_queue_work(&head->rwork, cls_cgroup_destroy_work);\n\t}\n\treturn 0;\nerrout:\n\ttcf_exts_destroy(&new->exts);\n\tkfree(new);\n\treturn err;\n}\n\nstatic void cls_cgroup_destroy(struct tcf_proto *tp, bool rtnl_held,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct cls_cgroup_head *head = rtnl_dereference(tp->root);\n\n\t \n\tif (head) {\n\t\tif (tcf_exts_get_net(&head->exts))\n\t\t\ttcf_queue_work(&head->rwork, cls_cgroup_destroy_work);\n\t\telse\n\t\t\t__cls_cgroup_destroy(head);\n\t}\n}\n\nstatic int cls_cgroup_delete(struct tcf_proto *tp, void *arg, bool *last,\n\t\t\t     bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void cls_cgroup_walk(struct tcf_proto *tp, struct tcf_walker *arg,\n\t\t\t    bool rtnl_held)\n{\n\tstruct cls_cgroup_head *head = rtnl_dereference(tp->root);\n\n\tif (arg->count < arg->skip)\n\t\tgoto skip;\n\n\tif (!head)\n\t\treturn;\n\tif (arg->fn(tp, head, arg) < 0) {\n\t\targ->stop = 1;\n\t\treturn;\n\t}\nskip:\n\targ->count++;\n}\n\nstatic int cls_cgroup_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t\t   struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)\n{\n\tstruct cls_cgroup_head *head = rtnl_dereference(tp->root);\n\tstruct nlattr *nest;\n\n\tt->tcm_handle = head->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (tcf_exts_dump(skb, &head->exts) < 0 ||\n\t    tcf_em_tree_dump(skb, &head->ematches, TCA_CGROUP_EMATCHES) < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tif (tcf_exts_dump_stats(skb, &head->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic struct tcf_proto_ops cls_cgroup_ops __read_mostly = {\n\t.kind\t\t=\t\"cgroup\",\n\t.init\t\t=\tcls_cgroup_init,\n\t.change\t\t=\tcls_cgroup_change,\n\t.classify\t=\tcls_cgroup_classify,\n\t.destroy\t=\tcls_cgroup_destroy,\n\t.get\t\t=\tcls_cgroup_get,\n\t.delete\t\t=\tcls_cgroup_delete,\n\t.walk\t\t=\tcls_cgroup_walk,\n\t.dump\t\t=\tcls_cgroup_dump,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init init_cgroup_cls(void)\n{\n\treturn register_tcf_proto_ops(&cls_cgroup_ops);\n}\n\nstatic void __exit exit_cgroup_cls(void)\n{\n\tunregister_tcf_proto_ops(&cls_cgroup_ops);\n}\n\nmodule_init(init_cgroup_cls);\nmodule_exit(exit_cgroup_cls);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}