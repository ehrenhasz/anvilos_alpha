{
  "module_name": "sch_sfb.c",
  "hash_id": "a2451e2c8536b1767f3eaf0c751ba29b465bc033b74ef6183713af2e2c483e58",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_sfb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/siphash.h>\n#include <net/ip.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <net/inet_ecn.h>\n\n \n#define SFB_BUCKET_SHIFT 4\n#define SFB_NUMBUCKETS\t(1 << SFB_BUCKET_SHIFT)  \n#define SFB_BUCKET_MASK (SFB_NUMBUCKETS - 1)\n#define SFB_LEVELS\t(32 / SFB_BUCKET_SHIFT)  \n\n \nstruct sfb_bucket {\n\tu16\t\tqlen;  \n\tu16\t\tp_mark;  \n};\n\n \nstruct sfb_bins {\n\tsiphash_key_t\t  perturbation;  \n\tstruct sfb_bucket bins[SFB_LEVELS][SFB_NUMBUCKETS];\n};\n\nstruct sfb_sched_data {\n\tstruct Qdisc\t*qdisc;\n\tstruct tcf_proto __rcu *filter_list;\n\tstruct tcf_block *block;\n\tunsigned long\trehash_interval;\n\tunsigned long\twarmup_time;\t \n\tu32\t\tmax;\n\tu32\t\tbin_size;\t \n\tu32\t\tincrement;\t \n\tu32\t\tdecrement;\t \n\tu32\t\tlimit;\t\t \n\tu32\t\tpenalty_rate;\n\tu32\t\tpenalty_burst;\n\tu32\t\ttokens_avail;\n\tunsigned long\trehash_time;\n\tunsigned long\ttoken_time;\n\n\tu8\t\tslot;\t\t \n\tbool\t\tdouble_buffering;\n\tstruct sfb_bins bins[2];\n\n\tstruct {\n\t\tu32\tearlydrop;\n\t\tu32\tpenaltydrop;\n\t\tu32\tbucketdrop;\n\t\tu32\tqueuedrop;\n\t\tu32\tchilddrop;\t \n\t\tu32\tmarked;\t\t \n\t} stats;\n};\n\n \nstruct sfb_skb_cb {\n\tu32 hashes[2];\n};\n\nstatic inline struct sfb_skb_cb *sfb_skb_cb(const struct sk_buff *skb)\n{\n\tqdisc_cb_private_validate(skb, sizeof(struct sfb_skb_cb));\n\treturn (struct sfb_skb_cb *)qdisc_skb_cb(skb)->data;\n}\n\n \nstatic u32 sfb_hash(const struct sk_buff *skb, u32 slot)\n{\n\treturn sfb_skb_cb(skb)->hashes[slot];\n}\n\n \nstatic u32 prob_plus(u32 p1, u32 p2)\n{\n\tu32 res = p1 + p2;\n\n\treturn min_t(u32, res, SFB_MAX_PROB);\n}\n\nstatic u32 prob_minus(u32 p1, u32 p2)\n{\n\treturn p1 > p2 ? p1 - p2 : 0;\n}\n\nstatic void increment_one_qlen(u32 sfbhash, u32 slot, struct sfb_sched_data *q)\n{\n\tint i;\n\tstruct sfb_bucket *b = &q->bins[slot].bins[0][0];\n\n\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\n\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\tif (b[hash].qlen < 0xFFFF)\n\t\t\tb[hash].qlen++;\n\t\tb += SFB_NUMBUCKETS;  \n\t}\n}\n\nstatic void increment_qlen(const struct sfb_skb_cb *cb, struct sfb_sched_data *q)\n{\n\tu32 sfbhash;\n\n\tsfbhash = cb->hashes[0];\n\tif (sfbhash)\n\t\tincrement_one_qlen(sfbhash, 0, q);\n\n\tsfbhash = cb->hashes[1];\n\tif (sfbhash)\n\t\tincrement_one_qlen(sfbhash, 1, q);\n}\n\nstatic void decrement_one_qlen(u32 sfbhash, u32 slot,\n\t\t\t       struct sfb_sched_data *q)\n{\n\tint i;\n\tstruct sfb_bucket *b = &q->bins[slot].bins[0][0];\n\n\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\n\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\tif (b[hash].qlen > 0)\n\t\t\tb[hash].qlen--;\n\t\tb += SFB_NUMBUCKETS;  \n\t}\n}\n\nstatic void decrement_qlen(const struct sk_buff *skb, struct sfb_sched_data *q)\n{\n\tu32 sfbhash;\n\n\tsfbhash = sfb_hash(skb, 0);\n\tif (sfbhash)\n\t\tdecrement_one_qlen(sfbhash, 0, q);\n\n\tsfbhash = sfb_hash(skb, 1);\n\tif (sfbhash)\n\t\tdecrement_one_qlen(sfbhash, 1, q);\n}\n\nstatic void decrement_prob(struct sfb_bucket *b, struct sfb_sched_data *q)\n{\n\tb->p_mark = prob_minus(b->p_mark, q->decrement);\n}\n\nstatic void increment_prob(struct sfb_bucket *b, struct sfb_sched_data *q)\n{\n\tb->p_mark = prob_plus(b->p_mark, q->increment);\n}\n\nstatic void sfb_zero_all_buckets(struct sfb_sched_data *q)\n{\n\tmemset(&q->bins, 0, sizeof(q->bins));\n}\n\n \nstatic u32 sfb_compute_qlen(u32 *prob_r, u32 *avgpm_r, const struct sfb_sched_data *q)\n{\n\tint i;\n\tu32 qlen = 0, prob = 0, totalpm = 0;\n\tconst struct sfb_bucket *b = &q->bins[q->slot].bins[0][0];\n\n\tfor (i = 0; i < SFB_LEVELS * SFB_NUMBUCKETS; i++) {\n\t\tif (qlen < b->qlen)\n\t\t\tqlen = b->qlen;\n\t\ttotalpm += b->p_mark;\n\t\tif (prob < b->p_mark)\n\t\t\tprob = b->p_mark;\n\t\tb++;\n\t}\n\t*prob_r = prob;\n\t*avgpm_r = totalpm / (SFB_LEVELS * SFB_NUMBUCKETS);\n\treturn qlen;\n}\n\n\nstatic void sfb_init_perturbation(u32 slot, struct sfb_sched_data *q)\n{\n\tget_random_bytes(&q->bins[slot].perturbation,\n\t\t\t sizeof(q->bins[slot].perturbation));\n}\n\nstatic void sfb_swap_slot(struct sfb_sched_data *q)\n{\n\tsfb_init_perturbation(q->slot, q);\n\tq->slot ^= 1;\n\tq->double_buffering = false;\n}\n\n \nstatic bool sfb_rate_limit(struct sk_buff *skb, struct sfb_sched_data *q)\n{\n\tif (q->penalty_rate == 0 || q->penalty_burst == 0)\n\t\treturn true;\n\n\tif (q->tokens_avail < 1) {\n\t\tunsigned long age = min(10UL * HZ, jiffies - q->token_time);\n\n\t\tq->tokens_avail = (age * q->penalty_rate) / HZ;\n\t\tif (q->tokens_avail > q->penalty_burst)\n\t\t\tq->tokens_avail = q->penalty_burst;\n\t\tq->token_time = jiffies;\n\t\tif (q->tokens_avail < 1)\n\t\t\treturn true;\n\t}\n\n\tq->tokens_avail--;\n\treturn false;\n}\n\nstatic bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,\n\t\t\t int *qerr, u32 *salt)\n{\n\tstruct tcf_result res;\n\tint result;\n\n\tresult = tcf_classify(skb, NULL, fl, &res, false);\n\tif (result >= 0) {\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\tfallthrough;\n\t\tcase TC_ACT_SHOT:\n\t\t\treturn false;\n\t\t}\n#endif\n\t\t*salt = TC_H_MIN(res.classid);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int sfb_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tunsigned int len = qdisc_pkt_len(skb);\n\tstruct Qdisc *child = q->qdisc;\n\tstruct tcf_proto *fl;\n\tstruct sfb_skb_cb cb;\n\tint i;\n\tu32 p_min = ~0;\n\tu32 minqlen = ~0;\n\tu32 r, sfbhash;\n\tu32 slot = q->slot;\n\tint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\n\tif (unlikely(sch->q.qlen >= q->limit)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.queuedrop++;\n\t\tgoto drop;\n\t}\n\n\tif (q->rehash_interval > 0) {\n\t\tunsigned long limit = q->rehash_time + q->rehash_interval;\n\n\t\tif (unlikely(time_after(jiffies, limit))) {\n\t\t\tsfb_swap_slot(q);\n\t\t\tq->rehash_time = jiffies;\n\t\t} else if (unlikely(!q->double_buffering && q->warmup_time > 0 &&\n\t\t\t\t    time_after(jiffies, limit - q->warmup_time))) {\n\t\t\tq->double_buffering = true;\n\t\t}\n\t}\n\n\tfl = rcu_dereference_bh(q->filter_list);\n\tif (fl) {\n\t\tu32 salt;\n\n\t\t \n\t\tif (!sfb_classify(skb, fl, &ret, &salt))\n\t\t\tgoto other_drop;\n\t\tsfbhash = siphash_1u32(salt, &q->bins[slot].perturbation);\n\t} else {\n\t\tsfbhash = skb_get_hash_perturb(skb, &q->bins[slot].perturbation);\n\t}\n\n\n\tif (!sfbhash)\n\t\tsfbhash = 1;\n\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\tif (b->qlen == 0)\n\t\t\tdecrement_prob(b, q);\n\t\telse if (b->qlen >= q->bin_size)\n\t\t\tincrement_prob(b, q);\n\t\tif (minqlen > b->qlen)\n\t\t\tminqlen = b->qlen;\n\t\tif (p_min > b->p_mark)\n\t\t\tp_min = b->p_mark;\n\t}\n\n\tslot ^= 1;\n\tsfb_skb_cb(skb)->hashes[slot] = 0;\n\n\tif (unlikely(minqlen >= q->max)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.bucketdrop++;\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(p_min >= SFB_MAX_PROB)) {\n\t\t \n\t\tif (q->double_buffering) {\n\t\t\tsfbhash = skb_get_hash_perturb(skb,\n\t\t\t    &q->bins[slot].perturbation);\n\t\t\tif (!sfbhash)\n\t\t\t\tsfbhash = 1;\n\t\t\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\t\t\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\t\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\t\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\t\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\t\t\tif (b->qlen == 0)\n\t\t\t\t\tdecrement_prob(b, q);\n\t\t\t\telse if (b->qlen >= q->bin_size)\n\t\t\t\t\tincrement_prob(b, q);\n\t\t\t}\n\t\t}\n\t\tif (sfb_rate_limit(skb, q)) {\n\t\t\tqdisc_qstats_overlimit(sch);\n\t\t\tq->stats.penaltydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t\tgoto enqueue;\n\t}\n\n\tr = get_random_u16() & SFB_MAX_PROB;\n\n\tif (unlikely(r < p_min)) {\n\t\tif (unlikely(p_min > SFB_MAX_PROB / 2)) {\n\t\t\t \n\t\t\tif (r < (p_min - SFB_MAX_PROB / 2) * 2) {\n\t\t\t\tq->stats.earlydrop++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tif (INET_ECN_set_ce(skb)) {\n\t\t\tq->stats.marked++;\n\t\t} else {\n\t\t\tq->stats.earlydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\nenqueue:\n\tmemcpy(&cb, sfb_skb_cb(skb), sizeof(cb));\n\tret = qdisc_enqueue(skb, child, to_free);\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tsch->qstats.backlog += len;\n\t\tsch->q.qlen++;\n\t\tincrement_qlen(&cb, q);\n\t} else if (net_xmit_drop_count(ret)) {\n\t\tq->stats.childdrop++;\n\t\tqdisc_qstats_drop(sch);\n\t}\n\treturn ret;\n\ndrop:\n\tqdisc_drop(skb, sch, to_free);\n\treturn NET_XMIT_CN;\nother_drop:\n\tif (ret & __NET_XMIT_BYPASS)\n\t\tqdisc_qstats_drop(sch);\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic struct sk_buff *sfb_dequeue(struct Qdisc *sch)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\tstruct sk_buff *skb;\n\n\tskb = child->dequeue(q->qdisc);\n\n\tif (skb) {\n\t\tqdisc_bstats_update(sch, skb);\n\t\tqdisc_qstats_backlog_dec(sch, skb);\n\t\tsch->q.qlen--;\n\t\tdecrement_qlen(skb, q);\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *sfb_peek(struct Qdisc *sch)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\n\treturn child->ops->peek(child);\n}\n\n \n\nstatic void sfb_reset(struct Qdisc *sch)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\n\tif (likely(q->qdisc))\n\t\tqdisc_reset(q->qdisc);\n\tq->slot = 0;\n\tq->double_buffering = false;\n\tsfb_zero_all_buckets(q);\n\tsfb_init_perturbation(0, q);\n}\n\nstatic void sfb_destroy(struct Qdisc *sch)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\n\ttcf_block_put(q->block);\n\tqdisc_put(q->qdisc);\n}\n\nstatic const struct nla_policy sfb_policy[TCA_SFB_MAX + 1] = {\n\t[TCA_SFB_PARMS]\t= { .len = sizeof(struct tc_sfb_qopt) },\n};\n\nstatic const struct tc_sfb_qopt sfb_default_ops = {\n\t.rehash_interval = 600 * MSEC_PER_SEC,\n\t.warmup_time = 60 * MSEC_PER_SEC,\n\t.limit = 0,\n\t.max = 25,\n\t.bin_size = 20,\n\t.increment = (SFB_MAX_PROB + 500) / 1000,  \n\t.decrement = (SFB_MAX_PROB + 3000) / 6000,\n\t.penalty_rate = 10,\n\t.penalty_burst = 20,\n};\n\nstatic int sfb_change(struct Qdisc *sch, struct nlattr *opt,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child, *old;\n\tstruct nlattr *tb[TCA_SFB_MAX + 1];\n\tconst struct tc_sfb_qopt *ctl = &sfb_default_ops;\n\tu32 limit;\n\tint err;\n\n\tif (opt) {\n\t\terr = nla_parse_nested_deprecated(tb, TCA_SFB_MAX, opt,\n\t\t\t\t\t\t  sfb_policy, NULL);\n\t\tif (err < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (tb[TCA_SFB_PARMS] == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tctl = nla_data(tb[TCA_SFB_PARMS]);\n\t}\n\n\tlimit = ctl->limit;\n\tif (limit == 0)\n\t\tlimit = qdisc_dev(sch)->tx_queue_len;\n\n\tchild = fifo_create_dflt(sch, &pfifo_qdisc_ops, limit, extack);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\n\tif (child != &noop_qdisc)\n\t\tqdisc_hash_add(child, true);\n\tsch_tree_lock(sch);\n\n\tqdisc_purge_queue(q->qdisc);\n\told = q->qdisc;\n\tq->qdisc = child;\n\n\tq->rehash_interval = msecs_to_jiffies(ctl->rehash_interval);\n\tq->warmup_time = msecs_to_jiffies(ctl->warmup_time);\n\tq->rehash_time = jiffies;\n\tq->limit = limit;\n\tq->increment = ctl->increment;\n\tq->decrement = ctl->decrement;\n\tq->max = ctl->max;\n\tq->bin_size = ctl->bin_size;\n\tq->penalty_rate = ctl->penalty_rate;\n\tq->penalty_burst = ctl->penalty_burst;\n\tq->tokens_avail = ctl->penalty_burst;\n\tq->token_time = jiffies;\n\n\tq->slot = 0;\n\tq->double_buffering = false;\n\tsfb_zero_all_buckets(q);\n\tsfb_init_perturbation(0, q);\n\tsfb_init_perturbation(1, q);\n\n\tsch_tree_unlock(sch);\n\tqdisc_put(old);\n\n\treturn 0;\n}\n\nstatic int sfb_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tint err;\n\n\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);\n\tif (err)\n\t\treturn err;\n\n\tq->qdisc = &noop_qdisc;\n\treturn sfb_change(sch, opt, extack);\n}\n\nstatic int sfb_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct nlattr *opts;\n\tstruct tc_sfb_qopt opt = {\n\t\t.rehash_interval = jiffies_to_msecs(q->rehash_interval),\n\t\t.warmup_time = jiffies_to_msecs(q->warmup_time),\n\t\t.limit = q->limit,\n\t\t.max = q->max,\n\t\t.bin_size = q->bin_size,\n\t\t.increment = q->increment,\n\t\t.decrement = q->decrement,\n\t\t.penalty_rate = q->penalty_rate,\n\t\t.penalty_burst = q->penalty_burst,\n\t};\n\n\tsch->qstats.backlog = q->qdisc->qstats.backlog;\n\topts = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (opts == NULL)\n\t\tgoto nla_put_failure;\n\tif (nla_put(skb, TCA_SFB_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\treturn nla_nest_end(skb, opts);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, opts);\n\treturn -EMSGSIZE;\n}\n\nstatic int sfb_dump_stats(struct Qdisc *sch, struct gnet_dump *d)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct tc_sfb_xstats st = {\n\t\t.earlydrop = q->stats.earlydrop,\n\t\t.penaltydrop = q->stats.penaltydrop,\n\t\t.bucketdrop = q->stats.bucketdrop,\n\t\t.queuedrop = q->stats.queuedrop,\n\t\t.childdrop = q->stats.childdrop,\n\t\t.marked = q->stats.marked,\n\t};\n\n\tst.maxqlen = sfb_compute_qlen(&st.maxprob, &st.avgprob, q);\n\n\treturn gnet_stats_copy_app(d, &st, sizeof(st));\n}\n\nstatic int sfb_dump_class(struct Qdisc *sch, unsigned long cl,\n\t\t\t  struct sk_buff *skb, struct tcmsg *tcm)\n{\n\treturn -ENOSYS;\n}\n\nstatic int sfb_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,\n\t\t     struct Qdisc **old, struct netlink_ext_ack *extack)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\n\tif (new == NULL)\n\t\tnew = &noop_qdisc;\n\n\t*old = qdisc_replace(sch, new, &q->qdisc);\n\treturn 0;\n}\n\nstatic struct Qdisc *sfb_leaf(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\n\treturn q->qdisc;\n}\n\nstatic unsigned long sfb_find(struct Qdisc *sch, u32 classid)\n{\n\treturn 1;\n}\n\nstatic void sfb_unbind(struct Qdisc *sch, unsigned long arg)\n{\n}\n\nstatic int sfb_change_class(struct Qdisc *sch, u32 classid, u32 parentid,\n\t\t\t    struct nlattr **tca, unsigned long *arg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn -ENOSYS;\n}\n\nstatic int sfb_delete(struct Qdisc *sch, unsigned long cl,\n\t\t      struct netlink_ext_ack *extack)\n{\n\treturn -ENOSYS;\n}\n\nstatic void sfb_walk(struct Qdisc *sch, struct qdisc_walker *walker)\n{\n\tif (!walker->stop) {\n\t\ttc_qdisc_stats_dump(sch, 1, walker);\n\t}\n}\n\nstatic struct tcf_block *sfb_tcf_block(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\n\tif (cl)\n\t\treturn NULL;\n\treturn q->block;\n}\n\nstatic unsigned long sfb_bind(struct Qdisc *sch, unsigned long parent,\n\t\t\t      u32 classid)\n{\n\treturn 0;\n}\n\n\nstatic const struct Qdisc_class_ops sfb_class_ops = {\n\t.graft\t\t=\tsfb_graft,\n\t.leaf\t\t=\tsfb_leaf,\n\t.find\t\t=\tsfb_find,\n\t.change\t\t=\tsfb_change_class,\n\t.delete\t\t=\tsfb_delete,\n\t.walk\t\t=\tsfb_walk,\n\t.tcf_block\t=\tsfb_tcf_block,\n\t.bind_tcf\t=\tsfb_bind,\n\t.unbind_tcf\t=\tsfb_unbind,\n\t.dump\t\t=\tsfb_dump_class,\n};\n\nstatic struct Qdisc_ops sfb_qdisc_ops __read_mostly = {\n\t.id\t\t=\t\"sfb\",\n\t.priv_size\t=\tsizeof(struct sfb_sched_data),\n\t.cl_ops\t\t=\t&sfb_class_ops,\n\t.enqueue\t=\tsfb_enqueue,\n\t.dequeue\t=\tsfb_dequeue,\n\t.peek\t\t=\tsfb_peek,\n\t.init\t\t=\tsfb_init,\n\t.reset\t\t=\tsfb_reset,\n\t.destroy\t=\tsfb_destroy,\n\t.change\t\t=\tsfb_change,\n\t.dump\t\t=\tsfb_dump,\n\t.dump_stats\t=\tsfb_dump_stats,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init sfb_module_init(void)\n{\n\treturn register_qdisc(&sfb_qdisc_ops);\n}\n\nstatic void __exit sfb_module_exit(void)\n{\n\tunregister_qdisc(&sfb_qdisc_ops);\n}\n\nmodule_init(sfb_module_init)\nmodule_exit(sfb_module_exit)\n\nMODULE_DESCRIPTION(\"Stochastic Fair Blue queue discipline\");\nMODULE_AUTHOR(\"Juliusz Chroboczek\");\nMODULE_AUTHOR(\"Eric Dumazet\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}