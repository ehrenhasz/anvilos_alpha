{
  "module_name": "act_sample.c",
  "hash_id": "50c0f89050a5fa64e667cb3ce7907b155e10c81c9dab31615010336657131ecc",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_sample.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <net/net_namespace.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <linux/tc_act/tc_sample.h>\n#include <net/tc_act/tc_sample.h>\n#include <net/psample.h>\n#include <net/pkt_cls.h>\n#include <net/tc_wrapper.h>\n\n#include <linux/if_arp.h>\n\nstatic struct tc_action_ops act_sample_ops;\n\nstatic const struct nla_policy sample_policy[TCA_SAMPLE_MAX + 1] = {\n\t[TCA_SAMPLE_PARMS]\t\t= { .len = sizeof(struct tc_sample) },\n\t[TCA_SAMPLE_RATE]\t\t= { .type = NLA_U32 },\n\t[TCA_SAMPLE_TRUNC_SIZE]\t\t= { .type = NLA_U32 },\n\t[TCA_SAMPLE_PSAMPLE_GROUP]\t= { .type = NLA_U32 },\n};\n\nstatic int tcf_sample_init(struct net *net, struct nlattr *nla,\n\t\t\t   struct nlattr *est, struct tc_action **a,\n\t\t\t   struct tcf_proto *tp,\n\t\t\t   u32 flags, struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_sample_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_SAMPLE_MAX + 1];\n\tstruct psample_group *psample_group;\n\tu32 psample_group_num, rate, index;\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tc_sample *parm;\n\tstruct tcf_sample *s;\n\tbool exists = false;\n\tint ret, err;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\tret = nla_parse_nested_deprecated(tb, TCA_SAMPLE_MAX, nla,\n\t\t\t\t\t  sample_policy, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!tb[TCA_SAMPLE_PARMS])\n\t\treturn -EINVAL;\n\n\tparm = nla_data(tb[TCA_SAMPLE_PARMS]);\n\tindex = parm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0)\n\t\treturn err;\n\texists = err;\n\tif (exists && bind)\n\t\treturn 0;\n\n\tif (!exists) {\n\t\tret = tcf_idr_create(tn, index, est, a,\n\t\t\t\t     &act_sample_ops, bind, true, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ACT_P_CREATED;\n\t} else if (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\ttcf_idr_release(*a, bind);\n\t\treturn -EEXIST;\n\t}\n\n\tif (!tb[TCA_SAMPLE_RATE] || !tb[TCA_SAMPLE_PSAMPLE_GROUP]) {\n\t\tNL_SET_ERR_MSG(extack, \"sample rate and group are required\");\n\t\terr = -EINVAL;\n\t\tgoto release_idr;\n\t}\n\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\trate = nla_get_u32(tb[TCA_SAMPLE_RATE]);\n\tif (!rate) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid sample rate\");\n\t\terr = -EINVAL;\n\t\tgoto put_chain;\n\t}\n\tpsample_group_num = nla_get_u32(tb[TCA_SAMPLE_PSAMPLE_GROUP]);\n\tpsample_group = psample_group_get(net, psample_group_num);\n\tif (!psample_group) {\n\t\terr = -ENOMEM;\n\t\tgoto put_chain;\n\t}\n\n\ts = to_sample(*a);\n\n\tspin_lock_bh(&s->tcf_lock);\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\ts->rate = rate;\n\ts->psample_group_num = psample_group_num;\n\tpsample_group = rcu_replace_pointer(s->psample_group, psample_group,\n\t\t\t\t\t    lockdep_is_held(&s->tcf_lock));\n\n\tif (tb[TCA_SAMPLE_TRUNC_SIZE]) {\n\t\ts->truncate = true;\n\t\ts->trunc_size = nla_get_u32(tb[TCA_SAMPLE_TRUNC_SIZE]);\n\t}\n\tspin_unlock_bh(&s->tcf_lock);\n\n\tif (psample_group)\n\t\tpsample_group_put(psample_group);\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\n\treturn ret;\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic void tcf_sample_cleanup(struct tc_action *a)\n{\n\tstruct tcf_sample *s = to_sample(a);\n\tstruct psample_group *psample_group;\n\n\t \n\tpsample_group = rcu_dereference_protected(s->psample_group, 1);\n\tRCU_INIT_POINTER(s->psample_group, NULL);\n\tif (psample_group)\n\t\tpsample_group_put(psample_group);\n}\n\nstatic bool tcf_sample_dev_ok_push(struct net_device *dev)\n{\n\tswitch (dev->type) {\n\tcase ARPHRD_TUNNEL:\n\tcase ARPHRD_TUNNEL6:\n\tcase ARPHRD_SIT:\n\tcase ARPHRD_IPGRE:\n\tcase ARPHRD_IP6GRE:\n\tcase ARPHRD_VOID:\n\tcase ARPHRD_NONE:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nTC_INDIRECT_SCOPE int tcf_sample_act(struct sk_buff *skb,\n\t\t\t\t     const struct tc_action *a,\n\t\t\t\t     struct tcf_result *res)\n{\n\tstruct tcf_sample *s = to_sample(a);\n\tstruct psample_group *psample_group;\n\tstruct psample_metadata md = {};\n\tint retval;\n\n\ttcf_lastuse_update(&s->tcf_tm);\n\tbstats_update(this_cpu_ptr(s->common.cpu_bstats), skb);\n\tretval = READ_ONCE(s->tcf_action);\n\n\tpsample_group = rcu_dereference_bh(s->psample_group);\n\n\t \n\tif (psample_group && (get_random_u32_below(s->rate) == 0)) {\n\t\tif (!skb_at_tc_ingress(skb)) {\n\t\t\tmd.in_ifindex = skb->skb_iif;\n\t\t\tmd.out_ifindex = skb->dev->ifindex;\n\t\t} else {\n\t\t\tmd.in_ifindex = skb->dev->ifindex;\n\t\t}\n\n\t\t \n\t\tif (skb_at_tc_ingress(skb) && tcf_sample_dev_ok_push(skb->dev))\n\t\t\tskb_push(skb, skb->mac_len);\n\n\t\tmd.trunc_size = s->truncate ? s->trunc_size : skb->len;\n\t\tpsample_sample_packet(psample_group, skb, s->rate, &md);\n\n\t\tif (skb_at_tc_ingress(skb) && tcf_sample_dev_ok_push(skb->dev))\n\t\t\tskb_pull(skb, skb->mac_len);\n\t}\n\n\treturn retval;\n}\n\nstatic void tcf_sample_stats_update(struct tc_action *a, u64 bytes, u64 packets,\n\t\t\t\t    u64 drops, u64 lastuse, bool hw)\n{\n\tstruct tcf_sample *s = to_sample(a);\n\tstruct tcf_t *tm = &s->tcf_tm;\n\n\ttcf_action_update_stats(a, bytes, packets, drops, hw);\n\ttm->lastuse = max_t(u64, tm->lastuse, lastuse);\n}\n\nstatic int tcf_sample_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_sample *s = to_sample(a);\n\tstruct tc_sample opt = {\n\t\t.index      = s->tcf_index,\n\t\t.refcnt     = refcount_read(&s->tcf_refcnt) - ref,\n\t\t.bindcnt    = atomic_read(&s->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&s->tcf_lock);\n\topt.action = s->tcf_action;\n\tif (nla_put(skb, TCA_SAMPLE_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &s->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_SAMPLE_TM, sizeof(t), &t, TCA_SAMPLE_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, TCA_SAMPLE_RATE, s->rate))\n\t\tgoto nla_put_failure;\n\n\tif (s->truncate)\n\t\tif (nla_put_u32(skb, TCA_SAMPLE_TRUNC_SIZE, s->trunc_size))\n\t\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, TCA_SAMPLE_PSAMPLE_GROUP, s->psample_group_num))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&s->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&s->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic void tcf_psample_group_put(void *priv)\n{\n\tstruct psample_group *group = priv;\n\n\tpsample_group_put(group);\n}\n\nstatic struct psample_group *\ntcf_sample_get_group(const struct tc_action *a,\n\t\t     tc_action_priv_destructor *destructor)\n{\n\tstruct tcf_sample *s = to_sample(a);\n\tstruct psample_group *group;\n\n\tgroup = rcu_dereference_protected(s->psample_group,\n\t\t\t\t\t  lockdep_is_held(&s->tcf_lock));\n\tif (group) {\n\t\tpsample_group_take(group);\n\t\t*destructor = tcf_psample_group_put;\n\t}\n\n\treturn group;\n}\n\nstatic void tcf_offload_sample_get_group(struct flow_action_entry *entry,\n\t\t\t\t\t const struct tc_action *act)\n{\n\tentry->sample.psample_group =\n\t\tact->ops->get_psample_group(act, &entry->destructor);\n\tentry->destructor_priv = entry->sample.psample_group;\n}\n\nstatic int tcf_sample_offload_act_setup(struct tc_action *act, void *entry_data,\n\t\t\t\t\tu32 *index_inc, bool bind,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (bind) {\n\t\tstruct flow_action_entry *entry = entry_data;\n\n\t\tentry->id = FLOW_ACTION_SAMPLE;\n\t\tentry->sample.trunc_size = tcf_sample_trunc_size(act);\n\t\tentry->sample.truncate = tcf_sample_truncate(act);\n\t\tentry->sample.rate = tcf_sample_rate(act);\n\t\ttcf_offload_sample_get_group(entry, act);\n\t\t*index_inc = 1;\n\t} else {\n\t\tstruct flow_offload_action *fl_action = entry_data;\n\n\t\tfl_action->id = FLOW_ACTION_SAMPLE;\n\t}\n\n\treturn 0;\n}\n\nstatic struct tc_action_ops act_sample_ops = {\n\t.kind\t  = \"sample\",\n\t.id\t  = TCA_ID_SAMPLE,\n\t.owner\t  = THIS_MODULE,\n\t.act\t  = tcf_sample_act,\n\t.stats_update = tcf_sample_stats_update,\n\t.dump\t  = tcf_sample_dump,\n\t.init\t  = tcf_sample_init,\n\t.cleanup  = tcf_sample_cleanup,\n\t.get_psample_group = tcf_sample_get_group,\n\t.offload_act_setup    = tcf_sample_offload_act_setup,\n\t.size\t  = sizeof(struct tcf_sample),\n};\n\nstatic __net_init int sample_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_sample_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_sample_ops);\n}\n\nstatic void __net_exit sample_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_sample_ops.net_id);\n}\n\nstatic struct pernet_operations sample_net_ops = {\n\t.init = sample_init_net,\n\t.exit_batch = sample_exit_net,\n\t.id   = &act_sample_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nstatic int __init sample_init_module(void)\n{\n\treturn tcf_register_action(&act_sample_ops, &sample_net_ops);\n}\n\nstatic void __exit sample_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_sample_ops, &sample_net_ops);\n}\n\nmodule_init(sample_init_module);\nmodule_exit(sample_cleanup_module);\n\nMODULE_AUTHOR(\"Yotam Gigi <yotam.gi@gmail.com>\");\nMODULE_DESCRIPTION(\"Packet sampling action\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}