{
  "module_name": "act_api.c",
  "hash_id": "5ea935a98828203164c0e205698d33deb74bd8268270c09dd1f038c2bacdfad7",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_api.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/sch_generic.h>\n#include <net/pkt_cls.h>\n#include <net/tc_act/tc_pedit.h>\n#include <net/act_api.h>\n#include <net/netlink.h>\n#include <net/flow_offload.h>\n#include <net/tc_wrapper.h>\n\n#ifdef CONFIG_INET\nDEFINE_STATIC_KEY_FALSE(tcf_frag_xmit_count);\nEXPORT_SYMBOL_GPL(tcf_frag_xmit_count);\n#endif\n\nint tcf_dev_queue_xmit(struct sk_buff *skb, int (*xmit)(struct sk_buff *skb))\n{\n#ifdef CONFIG_INET\n\tif (static_branch_unlikely(&tcf_frag_xmit_count))\n\t\treturn sch_frag_xmit_hook(skb, xmit);\n#endif\n\n\treturn xmit(skb);\n}\nEXPORT_SYMBOL_GPL(tcf_dev_queue_xmit);\n\nstatic void tcf_action_goto_chain_exec(const struct tc_action *a,\n\t\t\t\t       struct tcf_result *res)\n{\n\tconst struct tcf_chain *chain = rcu_dereference_bh(a->goto_chain);\n\n\tres->goto_tp = rcu_dereference_bh(chain->filter_chain);\n}\n\nstatic void tcf_free_cookie_rcu(struct rcu_head *p)\n{\n\tstruct tc_cookie *cookie = container_of(p, struct tc_cookie, rcu);\n\n\tkfree(cookie->data);\n\tkfree(cookie);\n}\n\nstatic void tcf_set_action_cookie(struct tc_cookie __rcu **old_cookie,\n\t\t\t\t  struct tc_cookie *new_cookie)\n{\n\tstruct tc_cookie *old;\n\n\told = xchg((__force struct tc_cookie **)old_cookie, new_cookie);\n\tif (old)\n\t\tcall_rcu(&old->rcu, tcf_free_cookie_rcu);\n}\n\nint tcf_action_check_ctrlact(int action, struct tcf_proto *tp,\n\t\t\t     struct tcf_chain **newchain,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tint opcode = TC_ACT_EXT_OPCODE(action), ret = -EINVAL;\n\tu32 chain_index;\n\n\tif (!opcode)\n\t\tret = action > TC_ACT_VALUE_MAX ? -EINVAL : 0;\n\telse if (opcode <= TC_ACT_EXT_OPCODE_MAX || action == TC_ACT_UNSPEC)\n\t\tret = 0;\n\tif (ret) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid control action\");\n\t\tgoto end;\n\t}\n\n\tif (TC_ACT_EXT_CMP(action, TC_ACT_GOTO_CHAIN)) {\n\t\tchain_index = action & TC_ACT_EXT_VAL_MASK;\n\t\tif (!tp || !newchain) {\n\t\t\tret = -EINVAL;\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"can't goto NULL proto/chain\");\n\t\t\tgoto end;\n\t\t}\n\t\t*newchain = tcf_chain_get_by_act(tp->chain->block, chain_index);\n\t\tif (!*newchain) {\n\t\t\tret = -ENOMEM;\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"can't allocate goto_chain\");\n\t\t}\n\t}\nend:\n\treturn ret;\n}\nEXPORT_SYMBOL(tcf_action_check_ctrlact);\n\nstruct tcf_chain *tcf_action_set_ctrlact(struct tc_action *a, int action,\n\t\t\t\t\t struct tcf_chain *goto_chain)\n{\n\ta->tcfa_action = action;\n\tgoto_chain = rcu_replace_pointer(a->goto_chain, goto_chain, 1);\n\treturn goto_chain;\n}\nEXPORT_SYMBOL(tcf_action_set_ctrlact);\n\n \nstatic void free_tcf(struct tc_action *p)\n{\n\tstruct tcf_chain *chain = rcu_dereference_protected(p->goto_chain, 1);\n\n\tfree_percpu(p->cpu_bstats);\n\tfree_percpu(p->cpu_bstats_hw);\n\tfree_percpu(p->cpu_qstats);\n\n\ttcf_set_action_cookie(&p->user_cookie, NULL);\n\tif (chain)\n\t\ttcf_chain_put_by_act(chain);\n\n\tkfree(p);\n}\n\nstatic void offload_action_hw_count_set(struct tc_action *act,\n\t\t\t\t\tu32 hw_count)\n{\n\tact->in_hw_count = hw_count;\n}\n\nstatic void offload_action_hw_count_inc(struct tc_action *act,\n\t\t\t\t\tu32 hw_count)\n{\n\tact->in_hw_count += hw_count;\n}\n\nstatic void offload_action_hw_count_dec(struct tc_action *act,\n\t\t\t\t\tu32 hw_count)\n{\n\tact->in_hw_count = act->in_hw_count > hw_count ?\n\t\t\t   act->in_hw_count - hw_count : 0;\n}\n\nstatic unsigned int tcf_offload_act_num_actions_single(struct tc_action *act)\n{\n\tif (is_tcf_pedit(act))\n\t\treturn tcf_pedit_nkeys(act);\n\telse\n\t\treturn 1;\n}\n\nstatic bool tc_act_skip_hw(u32 flags)\n{\n\treturn (flags & TCA_ACT_FLAGS_SKIP_HW) ? true : false;\n}\n\nstatic bool tc_act_skip_sw(u32 flags)\n{\n\treturn (flags & TCA_ACT_FLAGS_SKIP_SW) ? true : false;\n}\n\n \nstatic bool tc_act_flags_valid(u32 flags)\n{\n\tflags &= TCA_ACT_FLAGS_SKIP_HW | TCA_ACT_FLAGS_SKIP_SW;\n\n\treturn flags ^ (TCA_ACT_FLAGS_SKIP_HW | TCA_ACT_FLAGS_SKIP_SW);\n}\n\nstatic int offload_action_init(struct flow_offload_action *fl_action,\n\t\t\t       struct tc_action *act,\n\t\t\t       enum offload_act_command  cmd,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tfl_action->extack = extack;\n\tfl_action->command = cmd;\n\tfl_action->index = act->tcfa_index;\n\tfl_action->cookie = (unsigned long)act;\n\n\tif (act->ops->offload_act_setup) {\n\t\tspin_lock_bh(&act->tcfa_lock);\n\t\terr = act->ops->offload_act_setup(act, fl_action, NULL,\n\t\t\t\t\t\t  false, extack);\n\t\tspin_unlock_bh(&act->tcfa_lock);\n\t\treturn err;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int tcf_action_offload_cmd_ex(struct flow_offload_action *fl_act,\n\t\t\t\t     u32 *hw_count)\n{\n\tint err;\n\n\terr = flow_indr_dev_setup_offload(NULL, NULL, TC_SETUP_ACT,\n\t\t\t\t\t  fl_act, NULL, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (hw_count)\n\t\t*hw_count = err;\n\n\treturn 0;\n}\n\nstatic int tcf_action_offload_cmd_cb_ex(struct flow_offload_action *fl_act,\n\t\t\t\t\tu32 *hw_count,\n\t\t\t\t\tflow_indr_block_bind_cb_t *cb,\n\t\t\t\t\tvoid *cb_priv)\n{\n\tint err;\n\n\terr = cb(NULL, NULL, cb_priv, TC_SETUP_ACT, NULL, fl_act, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (hw_count)\n\t\t*hw_count = 1;\n\n\treturn 0;\n}\n\nstatic int tcf_action_offload_cmd(struct flow_offload_action *fl_act,\n\t\t\t\t  u32 *hw_count,\n\t\t\t\t  flow_indr_block_bind_cb_t *cb,\n\t\t\t\t  void *cb_priv)\n{\n\treturn cb ? tcf_action_offload_cmd_cb_ex(fl_act, hw_count,\n\t\t\t\t\t\t cb, cb_priv) :\n\t\t    tcf_action_offload_cmd_ex(fl_act, hw_count);\n}\n\nstatic int tcf_action_offload_add_ex(struct tc_action *action,\n\t\t\t\t     struct netlink_ext_ack *extack,\n\t\t\t\t     flow_indr_block_bind_cb_t *cb,\n\t\t\t\t     void *cb_priv)\n{\n\tbool skip_sw = tc_act_skip_sw(action->tcfa_flags);\n\tstruct tc_action *actions[TCA_ACT_MAX_PRIO] = {\n\t\t[0] = action,\n\t};\n\tstruct flow_offload_action *fl_action;\n\tu32 in_hw_count = 0;\n\tint num, err = 0;\n\n\tif (tc_act_skip_hw(action->tcfa_flags))\n\t\treturn 0;\n\n\tnum = tcf_offload_act_num_actions_single(action);\n\tfl_action = offload_action_alloc(num);\n\tif (!fl_action)\n\t\treturn -ENOMEM;\n\n\terr = offload_action_init(fl_action, action, FLOW_ACT_REPLACE, extack);\n\tif (err)\n\t\tgoto fl_err;\n\n\terr = tc_setup_action(&fl_action->action, actions, 0, extack);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Failed to setup tc actions for offload\");\n\t\tgoto fl_err;\n\t}\n\n\terr = tcf_action_offload_cmd(fl_action, &in_hw_count, cb, cb_priv);\n\tif (!err)\n\t\tcb ? offload_action_hw_count_inc(action, in_hw_count) :\n\t\t     offload_action_hw_count_set(action, in_hw_count);\n\n\tif (skip_sw && !tc_act_in_hw(action))\n\t\terr = -EINVAL;\n\n\ttc_cleanup_offload_action(&fl_action->action);\n\nfl_err:\n\tkfree(fl_action);\n\n\treturn err;\n}\n\n \nstatic int tcf_action_offload_add(struct tc_action *action,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn tcf_action_offload_add_ex(action, extack, NULL, NULL);\n}\n\nint tcf_action_update_hw_stats(struct tc_action *action)\n{\n\tstruct flow_offload_action fl_act = {};\n\tint err;\n\n\terr = offload_action_init(&fl_act, action, FLOW_ACT_STATS, NULL);\n\tif (err)\n\t\treturn err;\n\n\terr = tcf_action_offload_cmd(&fl_act, NULL, NULL, NULL);\n\tif (!err) {\n\t\tpreempt_disable();\n\t\ttcf_action_stats_update(action, fl_act.stats.bytes,\n\t\t\t\t\tfl_act.stats.pkts,\n\t\t\t\t\tfl_act.stats.drops,\n\t\t\t\t\tfl_act.stats.lastused,\n\t\t\t\t\ttrue);\n\t\tpreempt_enable();\n\t\taction->used_hw_stats = fl_act.stats.used_hw_stats;\n\t\taction->used_hw_stats_valid = true;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tcf_action_update_hw_stats);\n\nstatic int tcf_action_offload_del_ex(struct tc_action *action,\n\t\t\t\t     flow_indr_block_bind_cb_t *cb,\n\t\t\t\t     void *cb_priv)\n{\n\tstruct flow_offload_action fl_act = {};\n\tu32 in_hw_count = 0;\n\tint err = 0;\n\n\tif (!tc_act_in_hw(action))\n\t\treturn 0;\n\n\terr = offload_action_init(&fl_act, action, FLOW_ACT_DESTROY, NULL);\n\tif (err)\n\t\treturn err;\n\n\terr = tcf_action_offload_cmd(&fl_act, &in_hw_count, cb, cb_priv);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!cb && action->in_hw_count != in_hw_count)\n\t\treturn -EINVAL;\n\n\t \n\tif (cb && in_hw_count)\n\t\toffload_action_hw_count_dec(action, in_hw_count);\n\n\treturn 0;\n}\n\nstatic int tcf_action_offload_del(struct tc_action *action)\n{\n\treturn tcf_action_offload_del_ex(action, NULL, NULL);\n}\n\nstatic void tcf_action_cleanup(struct tc_action *p)\n{\n\ttcf_action_offload_del(p);\n\tif (p->ops->cleanup)\n\t\tp->ops->cleanup(p);\n\n\tgen_kill_estimator(&p->tcfa_rate_est);\n\tfree_tcf(p);\n}\n\nstatic int __tcf_action_put(struct tc_action *p, bool bind)\n{\n\tstruct tcf_idrinfo *idrinfo = p->idrinfo;\n\n\tif (refcount_dec_and_mutex_lock(&p->tcfa_refcnt, &idrinfo->lock)) {\n\t\tif (bind)\n\t\t\tatomic_dec(&p->tcfa_bindcnt);\n\t\tidr_remove(&idrinfo->action_idr, p->tcfa_index);\n\t\tmutex_unlock(&idrinfo->lock);\n\n\t\ttcf_action_cleanup(p);\n\t\treturn 1;\n\t}\n\n\tif (bind)\n\t\tatomic_dec(&p->tcfa_bindcnt);\n\n\treturn 0;\n}\n\nstatic int __tcf_idr_release(struct tc_action *p, bool bind, bool strict)\n{\n\tint ret = 0;\n\n\t \n\tif (p) {\n\t\tif (!bind && strict && atomic_read(&p->tcfa_bindcnt) > 0)\n\t\t\treturn -EPERM;\n\n\t\tif (__tcf_action_put(p, bind))\n\t\t\tret = ACT_P_DELETED;\n\t}\n\n\treturn ret;\n}\n\nint tcf_idr_release(struct tc_action *a, bool bind)\n{\n\tconst struct tc_action_ops *ops = a->ops;\n\tint ret;\n\n\tret = __tcf_idr_release(a, bind, false);\n\tif (ret == ACT_P_DELETED)\n\t\tmodule_put(ops->owner);\n\treturn ret;\n}\nEXPORT_SYMBOL(tcf_idr_release);\n\nstatic size_t tcf_action_shared_attrs_size(const struct tc_action *act)\n{\n\tstruct tc_cookie *user_cookie;\n\tu32 cookie_len = 0;\n\n\trcu_read_lock();\n\tuser_cookie = rcu_dereference(act->user_cookie);\n\n\tif (user_cookie)\n\t\tcookie_len = nla_total_size(user_cookie->len);\n\trcu_read_unlock();\n\n\treturn  nla_total_size(0)  \n\t\t+ nla_total_size(IFNAMSIZ)  \n\t\t+ cookie_len  \n\t\t+ nla_total_size(sizeof(struct nla_bitfield32))  \n\t\t+ nla_total_size(0)  \n\t\t+ nla_total_size(sizeof(struct nla_bitfield32))  \n\t\t \n\t\t+ nla_total_size_64bit(sizeof(struct gnet_stats_basic))\n\t\t \n\t\t+ nla_total_size_64bit(sizeof(u64))\n\t\t \n\t\t+ nla_total_size_64bit(sizeof(struct gnet_stats_queue))\n\t\t+ nla_total_size(0)  \n\t\t+ nla_total_size(sizeof(struct tcf_t));  \n}\n\nstatic size_t tcf_action_full_attrs_size(size_t sz)\n{\n\treturn NLMSG_HDRLEN                      \n\t\t+ sizeof(struct tcamsg)\n\t\t+ nla_total_size(0)              \n\t\t+ sz;\n}\n\nstatic size_t tcf_action_fill_size(const struct tc_action *act)\n{\n\tsize_t sz = tcf_action_shared_attrs_size(act);\n\n\tif (act->ops->get_fill_size)\n\t\treturn act->ops->get_fill_size(act) + sz;\n\treturn sz;\n}\n\nstatic int\ntcf_action_dump_terse(struct sk_buff *skb, struct tc_action *a, bool from_act)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tc_cookie *cookie;\n\n\tif (nla_put_string(skb, TCA_ACT_KIND, a->ops->kind))\n\t\tgoto nla_put_failure;\n\tif (tcf_action_copy_stats(skb, a, 0))\n\t\tgoto nla_put_failure;\n\tif (from_act && nla_put_u32(skb, TCA_ACT_INDEX, a->tcfa_index))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\tcookie = rcu_dereference(a->user_cookie);\n\tif (cookie) {\n\t\tif (nla_put(skb, TCA_ACT_COOKIE, cookie->len, cookie->data)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic int tcf_dump_walker(struct tcf_idrinfo *idrinfo, struct sk_buff *skb,\n\t\t\t   struct netlink_callback *cb)\n{\n\tint err = 0, index = -1, s_i = 0, n_i = 0;\n\tu32 act_flags = cb->args[2];\n\tunsigned long jiffy_since = cb->args[3];\n\tstruct nlattr *nest;\n\tstruct idr *idr = &idrinfo->action_idr;\n\tstruct tc_action *p;\n\tunsigned long id = 1;\n\tunsigned long tmp;\n\n\tmutex_lock(&idrinfo->lock);\n\n\ts_i = cb->args[0];\n\n\tidr_for_each_entry_ul(idr, p, tmp, id) {\n\t\tindex++;\n\t\tif (index < s_i)\n\t\t\tcontinue;\n\t\tif (IS_ERR(p))\n\t\t\tcontinue;\n\n\t\tif (jiffy_since &&\n\t\t    time_after(jiffy_since,\n\t\t\t       (unsigned long)p->tcfa_tm.lastuse))\n\t\t\tcontinue;\n\n\t\ttcf_action_update_hw_stats(p);\n\n\t\tnest = nla_nest_start_noflag(skb, n_i);\n\t\tif (!nest) {\n\t\t\tindex--;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t\terr = (act_flags & TCA_ACT_FLAG_TERSE_DUMP) ?\n\t\t\ttcf_action_dump_terse(skb, p, true) :\n\t\t\ttcf_action_dump_1(skb, p, 0, 0);\n\t\tif (err < 0) {\n\t\t\tindex--;\n\t\t\tnlmsg_trim(skb, nest);\n\t\t\tgoto done;\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\t\tn_i++;\n\t\tif (!(act_flags & TCA_ACT_FLAG_LARGE_DUMP_ON) &&\n\t\t    n_i >= TCA_ACT_MAX_PRIO)\n\t\t\tgoto done;\n\t}\ndone:\n\tif (index >= 0)\n\t\tcb->args[0] = index + 1;\n\n\tmutex_unlock(&idrinfo->lock);\n\tif (n_i) {\n\t\tif (act_flags & TCA_ACT_FLAG_LARGE_DUMP_ON)\n\t\t\tcb->args[1] = n_i;\n\t}\n\treturn n_i;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\tgoto done;\n}\n\nstatic int tcf_idr_release_unsafe(struct tc_action *p)\n{\n\tif (atomic_read(&p->tcfa_bindcnt) > 0)\n\t\treturn -EPERM;\n\n\tif (refcount_dec_and_test(&p->tcfa_refcnt)) {\n\t\tidr_remove(&p->idrinfo->action_idr, p->tcfa_index);\n\t\ttcf_action_cleanup(p);\n\t\treturn ACT_P_DELETED;\n\t}\n\n\treturn 0;\n}\n\nstatic int tcf_del_walker(struct tcf_idrinfo *idrinfo, struct sk_buff *skb,\n\t\t\t  const struct tc_action_ops *ops,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *nest;\n\tint n_i = 0;\n\tint ret = -EINVAL;\n\tstruct idr *idr = &idrinfo->action_idr;\n\tstruct tc_action *p;\n\tunsigned long id = 1;\n\tunsigned long tmp;\n\n\tnest = nla_nest_start_noflag(skb, 0);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, TCA_ACT_KIND, ops->kind))\n\t\tgoto nla_put_failure;\n\n\tret = 0;\n\tmutex_lock(&idrinfo->lock);\n\tidr_for_each_entry_ul(idr, p, tmp, id) {\n\t\tif (IS_ERR(p))\n\t\t\tcontinue;\n\t\tret = tcf_idr_release_unsafe(p);\n\t\tif (ret == ACT_P_DELETED)\n\t\t\tmodule_put(ops->owner);\n\t\telse if (ret < 0)\n\t\t\tbreak;\n\t\tn_i++;\n\t}\n\tmutex_unlock(&idrinfo->lock);\n\tif (ret < 0) {\n\t\tif (n_i)\n\t\t\tNL_SET_ERR_MSG(extack, \"Unable to flush all TC actions\");\n\t\telse\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tret = nla_put_u32(skb, TCA_FCNT, n_i);\n\tif (ret)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\n\treturn n_i;\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn ret;\n}\n\nint tcf_generic_walker(struct tc_action_net *tn, struct sk_buff *skb,\n\t\t       struct netlink_callback *cb, int type,\n\t\t       const struct tc_action_ops *ops,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct tcf_idrinfo *idrinfo = tn->idrinfo;\n\n\tif (type == RTM_DELACTION) {\n\t\treturn tcf_del_walker(idrinfo, skb, ops, extack);\n\t} else if (type == RTM_GETACTION) {\n\t\treturn tcf_dump_walker(idrinfo, skb, cb);\n\t} else {\n\t\tWARN(1, \"tcf_generic_walker: unknown command %d\\n\", type);\n\t\tNL_SET_ERR_MSG(extack, \"tcf_generic_walker: unknown command\");\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(tcf_generic_walker);\n\nint tcf_idr_search(struct tc_action_net *tn, struct tc_action **a, u32 index)\n{\n\tstruct tcf_idrinfo *idrinfo = tn->idrinfo;\n\tstruct tc_action *p;\n\n\tmutex_lock(&idrinfo->lock);\n\tp = idr_find(&idrinfo->action_idr, index);\n\tif (IS_ERR(p))\n\t\tp = NULL;\n\telse if (p)\n\t\trefcount_inc(&p->tcfa_refcnt);\n\tmutex_unlock(&idrinfo->lock);\n\n\tif (p) {\n\t\t*a = p;\n\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL(tcf_idr_search);\n\nstatic int __tcf_generic_walker(struct net *net, struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb, int type,\n\t\t\t\tconst struct tc_action_ops *ops,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, ops->net_id);\n\n\tif (unlikely(ops->walk))\n\t\treturn ops->walk(net, skb, cb, type, ops, extack);\n\n\treturn tcf_generic_walker(tn, skb, cb, type, ops, extack);\n}\n\nstatic int __tcf_idr_search(struct net *net,\n\t\t\t    const struct tc_action_ops *ops,\n\t\t\t    struct tc_action **a, u32 index)\n{\n\tstruct tc_action_net *tn = net_generic(net, ops->net_id);\n\n\tif (unlikely(ops->lookup))\n\t\treturn ops->lookup(net, a, index);\n\n\treturn tcf_idr_search(tn, a, index);\n}\n\nstatic int tcf_idr_delete_index(struct tcf_idrinfo *idrinfo, u32 index)\n{\n\tstruct tc_action *p;\n\tint ret = 0;\n\n\tmutex_lock(&idrinfo->lock);\n\tp = idr_find(&idrinfo->action_idr, index);\n\tif (!p) {\n\t\tmutex_unlock(&idrinfo->lock);\n\t\treturn -ENOENT;\n\t}\n\n\tif (!atomic_read(&p->tcfa_bindcnt)) {\n\t\tif (refcount_dec_and_test(&p->tcfa_refcnt)) {\n\t\t\tstruct module *owner = p->ops->owner;\n\n\t\t\tWARN_ON(p != idr_remove(&idrinfo->action_idr,\n\t\t\t\t\t\tp->tcfa_index));\n\t\t\tmutex_unlock(&idrinfo->lock);\n\n\t\t\ttcf_action_cleanup(p);\n\t\t\tmodule_put(owner);\n\t\t\treturn 0;\n\t\t}\n\t\tret = 0;\n\t} else {\n\t\tret = -EPERM;\n\t}\n\n\tmutex_unlock(&idrinfo->lock);\n\treturn ret;\n}\n\nint tcf_idr_create(struct tc_action_net *tn, u32 index, struct nlattr *est,\n\t\t   struct tc_action **a, const struct tc_action_ops *ops,\n\t\t   int bind, bool cpustats, u32 flags)\n{\n\tstruct tc_action *p = kzalloc(ops->size, GFP_KERNEL);\n\tstruct tcf_idrinfo *idrinfo = tn->idrinfo;\n\tint err = -ENOMEM;\n\n\tif (unlikely(!p))\n\t\treturn -ENOMEM;\n\trefcount_set(&p->tcfa_refcnt, 1);\n\tif (bind)\n\t\tatomic_set(&p->tcfa_bindcnt, 1);\n\n\tif (cpustats) {\n\t\tp->cpu_bstats = netdev_alloc_pcpu_stats(struct gnet_stats_basic_sync);\n\t\tif (!p->cpu_bstats)\n\t\t\tgoto err1;\n\t\tp->cpu_bstats_hw = netdev_alloc_pcpu_stats(struct gnet_stats_basic_sync);\n\t\tif (!p->cpu_bstats_hw)\n\t\t\tgoto err2;\n\t\tp->cpu_qstats = alloc_percpu(struct gnet_stats_queue);\n\t\tif (!p->cpu_qstats)\n\t\t\tgoto err3;\n\t}\n\tgnet_stats_basic_sync_init(&p->tcfa_bstats);\n\tgnet_stats_basic_sync_init(&p->tcfa_bstats_hw);\n\tspin_lock_init(&p->tcfa_lock);\n\tp->tcfa_index = index;\n\tp->tcfa_tm.install = jiffies;\n\tp->tcfa_tm.lastuse = jiffies;\n\tp->tcfa_tm.firstuse = 0;\n\tp->tcfa_flags = flags;\n\tif (est) {\n\t\terr = gen_new_estimator(&p->tcfa_bstats, p->cpu_bstats,\n\t\t\t\t\t&p->tcfa_rate_est,\n\t\t\t\t\t&p->tcfa_lock, false, est);\n\t\tif (err)\n\t\t\tgoto err4;\n\t}\n\n\tp->idrinfo = idrinfo;\n\t__module_get(ops->owner);\n\tp->ops = ops;\n\t*a = p;\n\treturn 0;\nerr4:\n\tfree_percpu(p->cpu_qstats);\nerr3:\n\tfree_percpu(p->cpu_bstats_hw);\nerr2:\n\tfree_percpu(p->cpu_bstats);\nerr1:\n\tkfree(p);\n\treturn err;\n}\nEXPORT_SYMBOL(tcf_idr_create);\n\nint tcf_idr_create_from_flags(struct tc_action_net *tn, u32 index,\n\t\t\t      struct nlattr *est, struct tc_action **a,\n\t\t\t      const struct tc_action_ops *ops, int bind,\n\t\t\t      u32 flags)\n{\n\t \n\treturn tcf_idr_create(tn, index, est, a, ops, bind,\n\t\t\t      !(flags & TCA_ACT_FLAGS_NO_PERCPU_STATS), flags);\n}\nEXPORT_SYMBOL(tcf_idr_create_from_flags);\n\n \n\nvoid tcf_idr_cleanup(struct tc_action_net *tn, u32 index)\n{\n\tstruct tcf_idrinfo *idrinfo = tn->idrinfo;\n\n\tmutex_lock(&idrinfo->lock);\n\t \n\tWARN_ON(!IS_ERR(idr_remove(&idrinfo->action_idr, index)));\n\tmutex_unlock(&idrinfo->lock);\n}\nEXPORT_SYMBOL(tcf_idr_cleanup);\n\n \n\nint tcf_idr_check_alloc(struct tc_action_net *tn, u32 *index,\n\t\t\tstruct tc_action **a, int bind)\n{\n\tstruct tcf_idrinfo *idrinfo = tn->idrinfo;\n\tstruct tc_action *p;\n\tint ret;\n\nagain:\n\tmutex_lock(&idrinfo->lock);\n\tif (*index) {\n\t\tp = idr_find(&idrinfo->action_idr, *index);\n\t\tif (IS_ERR(p)) {\n\t\t\t \n\t\t\tmutex_unlock(&idrinfo->lock);\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (p) {\n\t\t\trefcount_inc(&p->tcfa_refcnt);\n\t\t\tif (bind)\n\t\t\t\tatomic_inc(&p->tcfa_bindcnt);\n\t\t\t*a = p;\n\t\t\tret = 1;\n\t\t} else {\n\t\t\t*a = NULL;\n\t\t\tret = idr_alloc_u32(&idrinfo->action_idr, NULL, index,\n\t\t\t\t\t    *index, GFP_KERNEL);\n\t\t\tif (!ret)\n\t\t\t\tidr_replace(&idrinfo->action_idr,\n\t\t\t\t\t    ERR_PTR(-EBUSY), *index);\n\t\t}\n\t} else {\n\t\t*index = 1;\n\t\t*a = NULL;\n\t\tret = idr_alloc_u32(&idrinfo->action_idr, NULL, index,\n\t\t\t\t    UINT_MAX, GFP_KERNEL);\n\t\tif (!ret)\n\t\t\tidr_replace(&idrinfo->action_idr, ERR_PTR(-EBUSY),\n\t\t\t\t    *index);\n\t}\n\tmutex_unlock(&idrinfo->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(tcf_idr_check_alloc);\n\nvoid tcf_idrinfo_destroy(const struct tc_action_ops *ops,\n\t\t\t struct tcf_idrinfo *idrinfo)\n{\n\tstruct idr *idr = &idrinfo->action_idr;\n\tstruct tc_action *p;\n\tint ret;\n\tunsigned long id = 1;\n\tunsigned long tmp;\n\n\tidr_for_each_entry_ul(idr, p, tmp, id) {\n\t\tret = __tcf_idr_release(p, false, true);\n\t\tif (ret == ACT_P_DELETED)\n\t\t\tmodule_put(ops->owner);\n\t\telse if (ret < 0)\n\t\t\treturn;\n\t}\n\tidr_destroy(&idrinfo->action_idr);\n}\nEXPORT_SYMBOL(tcf_idrinfo_destroy);\n\nstatic LIST_HEAD(act_base);\nstatic DEFINE_RWLOCK(act_mod_lock);\n \nstatic LIST_HEAD(act_pernet_id_list);\nstatic DEFINE_MUTEX(act_id_mutex);\nstruct tc_act_pernet_id {\n\tstruct list_head list;\n\tunsigned int id;\n};\n\nstatic int tcf_pernet_add_id_list(unsigned int id)\n{\n\tstruct tc_act_pernet_id *id_ptr;\n\tint ret = 0;\n\n\tmutex_lock(&act_id_mutex);\n\tlist_for_each_entry(id_ptr, &act_pernet_id_list, list) {\n\t\tif (id_ptr->id == id) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tid_ptr = kzalloc(sizeof(*id_ptr), GFP_KERNEL);\n\tif (!id_ptr) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tid_ptr->id = id;\n\n\tlist_add_tail(&id_ptr->list, &act_pernet_id_list);\n\nerr_out:\n\tmutex_unlock(&act_id_mutex);\n\treturn ret;\n}\n\nstatic void tcf_pernet_del_id_list(unsigned int id)\n{\n\tstruct tc_act_pernet_id *id_ptr;\n\n\tmutex_lock(&act_id_mutex);\n\tlist_for_each_entry(id_ptr, &act_pernet_id_list, list) {\n\t\tif (id_ptr->id == id) {\n\t\t\tlist_del(&id_ptr->list);\n\t\t\tkfree(id_ptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&act_id_mutex);\n}\n\nint tcf_register_action(struct tc_action_ops *act,\n\t\t\tstruct pernet_operations *ops)\n{\n\tstruct tc_action_ops *a;\n\tint ret;\n\n\tif (!act->act || !act->dump || !act->init)\n\t\treturn -EINVAL;\n\n\t \n\tret = register_pernet_subsys(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ops->id) {\n\t\tret = tcf_pernet_add_id_list(*ops->id);\n\t\tif (ret)\n\t\t\tgoto err_id;\n\t}\n\n\twrite_lock(&act_mod_lock);\n\tlist_for_each_entry(a, &act_base, head) {\n\t\tif (act->id == a->id || (strcmp(act->kind, a->kind) == 0)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tlist_add_tail(&act->head, &act_base);\n\twrite_unlock(&act_mod_lock);\n\n\treturn 0;\n\nerr_out:\n\twrite_unlock(&act_mod_lock);\n\tif (ops->id)\n\t\ttcf_pernet_del_id_list(*ops->id);\nerr_id:\n\tunregister_pernet_subsys(ops);\n\treturn ret;\n}\nEXPORT_SYMBOL(tcf_register_action);\n\nint tcf_unregister_action(struct tc_action_ops *act,\n\t\t\t  struct pernet_operations *ops)\n{\n\tstruct tc_action_ops *a;\n\tint err = -ENOENT;\n\n\twrite_lock(&act_mod_lock);\n\tlist_for_each_entry(a, &act_base, head) {\n\t\tif (a == act) {\n\t\t\tlist_del(&act->head);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\twrite_unlock(&act_mod_lock);\n\tif (!err) {\n\t\tunregister_pernet_subsys(ops);\n\t\tif (ops->id)\n\t\t\ttcf_pernet_del_id_list(*ops->id);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(tcf_unregister_action);\n\n \nstatic struct tc_action_ops *tc_lookup_action_n(char *kind)\n{\n\tstruct tc_action_ops *a, *res = NULL;\n\n\tif (kind) {\n\t\tread_lock(&act_mod_lock);\n\t\tlist_for_each_entry(a, &act_base, head) {\n\t\t\tif (strcmp(kind, a->kind) == 0) {\n\t\t\t\tif (try_module_get(a->owner))\n\t\t\t\t\tres = a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tread_unlock(&act_mod_lock);\n\t}\n\treturn res;\n}\n\n \nstatic struct tc_action_ops *tc_lookup_action(struct nlattr *kind)\n{\n\tstruct tc_action_ops *a, *res = NULL;\n\n\tif (kind) {\n\t\tread_lock(&act_mod_lock);\n\t\tlist_for_each_entry(a, &act_base, head) {\n\t\t\tif (nla_strcmp(kind, a->kind) == 0) {\n\t\t\t\tif (try_module_get(a->owner))\n\t\t\t\t\tres = a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tread_unlock(&act_mod_lock);\n\t}\n\treturn res;\n}\n\n \n#define TCA_ACT_MAX_PRIO_MASK 0x1FF\nint tcf_action_exec(struct sk_buff *skb, struct tc_action **actions,\n\t\t    int nr_actions, struct tcf_result *res)\n{\n\tu32 jmp_prgcnt = 0;\n\tu32 jmp_ttl = TCA_ACT_MAX_PRIO;  \n\tint i;\n\tint ret = TC_ACT_OK;\n\n\tif (skb_skip_tc_classify(skb))\n\t\treturn TC_ACT_OK;\n\nrestart_act_graph:\n\tfor (i = 0; i < nr_actions; i++) {\n\t\tconst struct tc_action *a = actions[i];\n\t\tint repeat_ttl;\n\n\t\tif (jmp_prgcnt > 0) {\n\t\t\tjmp_prgcnt -= 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tc_act_skip_sw(a->tcfa_flags))\n\t\t\tcontinue;\n\n\t\trepeat_ttl = 32;\nrepeat:\n\t\tret = tc_act(skb, a, res);\n\t\tif (unlikely(ret == TC_ACT_REPEAT)) {\n\t\t\tif (--repeat_ttl != 0)\n\t\t\t\tgoto repeat;\n\t\t\t \n\t\t\tnet_warn_ratelimited(\"TC_ACT_REPEAT abuse ?\\n\");\n\t\t\treturn TC_ACT_OK;\n\t\t}\n\t\tif (TC_ACT_EXT_CMP(ret, TC_ACT_JUMP)) {\n\t\t\tjmp_prgcnt = ret & TCA_ACT_MAX_PRIO_MASK;\n\t\t\tif (!jmp_prgcnt || (jmp_prgcnt > nr_actions)) {\n\t\t\t\t \n\t\t\t\treturn TC_ACT_OK;\n\t\t\t} else {\n\t\t\t\tjmp_ttl -= 1;\n\t\t\t\tif (jmp_ttl > 0)\n\t\t\t\t\tgoto restart_act_graph;\n\t\t\t\telse  \n\t\t\t\t\treturn TC_ACT_OK;\n\t\t\t}\n\t\t} else if (TC_ACT_EXT_CMP(ret, TC_ACT_GOTO_CHAIN)) {\n\t\t\tif (unlikely(!rcu_access_pointer(a->goto_chain))) {\n\t\t\t\tnet_warn_ratelimited(\"can't go to NULL chain!\\n\");\n\t\t\t\treturn TC_ACT_SHOT;\n\t\t\t}\n\t\t\ttcf_action_goto_chain_exec(a, res);\n\t\t}\n\n\t\tif (ret != TC_ACT_PIPE)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(tcf_action_exec);\n\nint tcf_action_destroy(struct tc_action *actions[], int bind)\n{\n\tconst struct tc_action_ops *ops;\n\tstruct tc_action *a;\n\tint ret = 0, i;\n\n\tfor (i = 0; i < TCA_ACT_MAX_PRIO && actions[i]; i++) {\n\t\ta = actions[i];\n\t\tactions[i] = NULL;\n\t\tops = a->ops;\n\t\tret = __tcf_idr_release(a, bind, true);\n\t\tif (ret == ACT_P_DELETED)\n\t\t\tmodule_put(ops->owner);\n\t\telse if (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic int tcf_action_put(struct tc_action *p)\n{\n\treturn __tcf_action_put(p, false);\n}\n\n \nstatic void tcf_action_put_many(struct tc_action *actions[])\n{\n\tint i;\n\n\tfor (i = 0; i < TCA_ACT_MAX_PRIO; i++) {\n\t\tstruct tc_action *a = actions[i];\n\t\tconst struct tc_action_ops *ops;\n\n\t\tif (!a)\n\t\t\tcontinue;\n\t\tops = a->ops;\n\t\tif (tcf_action_put(a))\n\t\t\tmodule_put(ops->owner);\n\t}\n}\n\nint\ntcf_action_dump_old(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\n{\n\treturn a->ops->dump(skb, a, bind, ref);\n}\n\nint\ntcf_action_dump_1(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\n{\n\tint err = -EINVAL;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct nlattr *nest;\n\tu32 flags;\n\n\tif (tcf_action_dump_terse(skb, a, false))\n\t\tgoto nla_put_failure;\n\n\tif (a->hw_stats != TCA_ACT_HW_STATS_ANY &&\n\t    nla_put_bitfield32(skb, TCA_ACT_HW_STATS,\n\t\t\t       a->hw_stats, TCA_ACT_HW_STATS_ANY))\n\t\tgoto nla_put_failure;\n\n\tif (a->used_hw_stats_valid &&\n\t    nla_put_bitfield32(skb, TCA_ACT_USED_HW_STATS,\n\t\t\t       a->used_hw_stats, TCA_ACT_HW_STATS_ANY))\n\t\tgoto nla_put_failure;\n\n\tflags = a->tcfa_flags & TCA_ACT_FLAGS_USER_MASK;\n\tif (flags &&\n\t    nla_put_bitfield32(skb, TCA_ACT_FLAGS,\n\t\t\t       flags, flags))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, TCA_ACT_IN_HW_COUNT, a->in_hw_count))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, TCA_ACT_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\terr = tcf_action_dump_old(skb, a, bind, ref);\n\tif (err > 0) {\n\t\tnla_nest_end(skb, nest);\n\t\treturn err;\n\t}\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\nEXPORT_SYMBOL(tcf_action_dump_1);\n\nint tcf_action_dump(struct sk_buff *skb, struct tc_action *actions[],\n\t\t    int bind, int ref, bool terse)\n{\n\tstruct tc_action *a;\n\tint err = -EINVAL, i;\n\tstruct nlattr *nest;\n\n\tfor (i = 0; i < TCA_ACT_MAX_PRIO && actions[i]; i++) {\n\t\ta = actions[i];\n\t\tnest = nla_nest_start_noflag(skb, i + 1);\n\t\tif (nest == NULL)\n\t\t\tgoto nla_put_failure;\n\t\terr = terse ? tcf_action_dump_terse(skb, a, false) :\n\t\t\ttcf_action_dump_1(skb, a, bind, ref);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\terr = -EINVAL;\nerrout:\n\tnla_nest_cancel(skb, nest);\n\treturn err;\n}\n\nstatic struct tc_cookie *nla_memdup_cookie(struct nlattr **tb)\n{\n\tstruct tc_cookie *c = kzalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn NULL;\n\n\tc->data = nla_memdup(tb[TCA_ACT_COOKIE], GFP_KERNEL);\n\tif (!c->data) {\n\t\tkfree(c);\n\t\treturn NULL;\n\t}\n\tc->len = nla_len(tb[TCA_ACT_COOKIE]);\n\n\treturn c;\n}\n\nstatic u8 tcf_action_hw_stats_get(struct nlattr *hw_stats_attr)\n{\n\tstruct nla_bitfield32 hw_stats_bf;\n\n\t \n\tif (!hw_stats_attr)\n\t\treturn TCA_ACT_HW_STATS_ANY;\n\thw_stats_bf = nla_get_bitfield32(hw_stats_attr);\n\treturn hw_stats_bf.value;\n}\n\nstatic const struct nla_policy tcf_action_policy[TCA_ACT_MAX + 1] = {\n\t[TCA_ACT_KIND]\t\t= { .type = NLA_STRING },\n\t[TCA_ACT_INDEX]\t\t= { .type = NLA_U32 },\n\t[TCA_ACT_COOKIE]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = TC_COOKIE_MAX_SIZE },\n\t[TCA_ACT_OPTIONS]\t= { .type = NLA_NESTED },\n\t[TCA_ACT_FLAGS]\t\t= NLA_POLICY_BITFIELD32(TCA_ACT_FLAGS_NO_PERCPU_STATS |\n\t\t\t\t\t\t\tTCA_ACT_FLAGS_SKIP_HW |\n\t\t\t\t\t\t\tTCA_ACT_FLAGS_SKIP_SW),\n\t[TCA_ACT_HW_STATS]\t= NLA_POLICY_BITFIELD32(TCA_ACT_HW_STATS_ANY),\n};\n\nvoid tcf_idr_insert_many(struct tc_action *actions[])\n{\n\tint i;\n\n\tfor (i = 0; i < TCA_ACT_MAX_PRIO; i++) {\n\t\tstruct tc_action *a = actions[i];\n\t\tstruct tcf_idrinfo *idrinfo;\n\n\t\tif (!a)\n\t\t\tcontinue;\n\t\tidrinfo = a->idrinfo;\n\t\tmutex_lock(&idrinfo->lock);\n\t\t \n\t\tidr_replace(&idrinfo->action_idr, a, a->tcfa_index);\n\t\tmutex_unlock(&idrinfo->lock);\n\t}\n}\n\nstruct tc_action_ops *tc_action_load_ops(struct nlattr *nla, bool police,\n\t\t\t\t\t bool rtnl_held,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_ACT_MAX + 1];\n\tstruct tc_action_ops *a_o;\n\tchar act_name[IFNAMSIZ];\n\tstruct nlattr *kind;\n\tint err;\n\n\tif (!police) {\n\t\terr = nla_parse_nested_deprecated(tb, TCA_ACT_MAX, nla,\n\t\t\t\t\t\t  tcf_action_policy, extack);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t\terr = -EINVAL;\n\t\tkind = tb[TCA_ACT_KIND];\n\t\tif (!kind) {\n\t\t\tNL_SET_ERR_MSG(extack, \"TC action kind must be specified\");\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tif (nla_strscpy(act_name, kind, IFNAMSIZ) < 0) {\n\t\t\tNL_SET_ERR_MSG(extack, \"TC action name too long\");\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t} else {\n\t\tif (strscpy(act_name, \"police\", IFNAMSIZ) < 0) {\n\t\t\tNL_SET_ERR_MSG(extack, \"TC action name too long\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\ta_o = tc_lookup_action_n(act_name);\n\tif (a_o == NULL) {\n#ifdef CONFIG_MODULES\n\t\tif (rtnl_held)\n\t\t\trtnl_unlock();\n\t\trequest_module(\"act_%s\", act_name);\n\t\tif (rtnl_held)\n\t\t\trtnl_lock();\n\n\t\ta_o = tc_lookup_action_n(act_name);\n\n\t\t \n\t\tif (a_o != NULL) {\n\t\t\tmodule_put(a_o->owner);\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t}\n#endif\n\t\tNL_SET_ERR_MSG(extack, \"Failed to load TC action module\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn a_o;\n}\n\nstruct tc_action *tcf_action_init_1(struct net *net, struct tcf_proto *tp,\n\t\t\t\t    struct nlattr *nla, struct nlattr *est,\n\t\t\t\t    struct tc_action_ops *a_o, int *init_res,\n\t\t\t\t    u32 flags, struct netlink_ext_ack *extack)\n{\n\tbool police = flags & TCA_ACT_FLAGS_POLICE;\n\tstruct nla_bitfield32 userflags = { 0, 0 };\n\tstruct tc_cookie *user_cookie = NULL;\n\tu8 hw_stats = TCA_ACT_HW_STATS_ANY;\n\tstruct nlattr *tb[TCA_ACT_MAX + 1];\n\tstruct tc_action *a;\n\tint err;\n\n\t \n\tif (!police) {\n\t\terr = nla_parse_nested_deprecated(tb, TCA_ACT_MAX, nla,\n\t\t\t\t\t\t  tcf_action_policy, extack);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t\tif (tb[TCA_ACT_COOKIE]) {\n\t\t\tuser_cookie = nla_memdup_cookie(tb);\n\t\t\tif (!user_cookie) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"No memory to generate TC cookie\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\thw_stats = tcf_action_hw_stats_get(tb[TCA_ACT_HW_STATS]);\n\t\tif (tb[TCA_ACT_FLAGS]) {\n\t\t\tuserflags = nla_get_bitfield32(tb[TCA_ACT_FLAGS]);\n\t\t\tif (!tc_act_flags_valid(userflags.value)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\n\t\terr = a_o->init(net, tb[TCA_ACT_OPTIONS], est, &a, tp,\n\t\t\t\tuserflags.value | flags, extack);\n\t} else {\n\t\terr = a_o->init(net, nla, est, &a, tp, userflags.value | flags,\n\t\t\t\textack);\n\t}\n\tif (err < 0)\n\t\tgoto err_out;\n\t*init_res = err;\n\n\tif (!police && tb[TCA_ACT_COOKIE])\n\t\ttcf_set_action_cookie(&a->user_cookie, user_cookie);\n\n\tif (!police)\n\t\ta->hw_stats = hw_stats;\n\n\treturn a;\n\nerr_out:\n\tif (user_cookie) {\n\t\tkfree(user_cookie->data);\n\t\tkfree(user_cookie);\n\t}\n\treturn ERR_PTR(err);\n}\n\nstatic bool tc_act_bind(u32 flags)\n{\n\treturn !!(flags & TCA_ACT_FLAGS_BIND);\n}\n\n \n\nint tcf_action_init(struct net *net, struct tcf_proto *tp, struct nlattr *nla,\n\t\t    struct nlattr *est, struct tc_action *actions[],\n\t\t    int init_res[], size_t *attr_size,\n\t\t    u32 flags, u32 fl_flags,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_ops *ops[TCA_ACT_MAX_PRIO] = {};\n\tstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];\n\tstruct tc_action *act;\n\tsize_t sz = 0;\n\tint err;\n\tint i;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_ACT_MAX_PRIO, nla, NULL,\n\t\t\t\t\t  extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {\n\t\tstruct tc_action_ops *a_o;\n\n\t\ta_o = tc_action_load_ops(tb[i], flags & TCA_ACT_FLAGS_POLICE,\n\t\t\t\t\t !(flags & TCA_ACT_FLAGS_NO_RTNL),\n\t\t\t\t\t extack);\n\t\tif (IS_ERR(a_o)) {\n\t\t\terr = PTR_ERR(a_o);\n\t\t\tgoto err_mod;\n\t\t}\n\t\tops[i - 1] = a_o;\n\t}\n\n\tfor (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {\n\t\tact = tcf_action_init_1(net, tp, tb[i], est, ops[i - 1],\n\t\t\t\t\t&init_res[i - 1], flags, extack);\n\t\tif (IS_ERR(act)) {\n\t\t\terr = PTR_ERR(act);\n\t\t\tgoto err;\n\t\t}\n\t\tsz += tcf_action_fill_size(act);\n\t\t \n\t\tactions[i - 1] = act;\n\t\tif (tc_act_bind(flags)) {\n\t\t\tbool skip_sw = tc_skip_sw(fl_flags);\n\t\t\tbool skip_hw = tc_skip_hw(fl_flags);\n\n\t\t\tif (tc_act_bind(act->tcfa_flags))\n\t\t\t\tcontinue;\n\t\t\tif (skip_sw != tc_act_skip_sw(act->tcfa_flags) ||\n\t\t\t    skip_hw != tc_act_skip_hw(act->tcfa_flags)) {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"Mismatch between action and filter offload flags\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\terr = tcf_action_offload_add(act, extack);\n\t\t\tif (tc_act_skip_sw(act->tcfa_flags) && err)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\ttcf_idr_insert_many(actions);\n\n\t*attr_size = tcf_action_full_attrs_size(sz);\n\terr = i - 1;\n\tgoto err_mod;\n\nerr:\n\ttcf_action_destroy(actions, flags & TCA_ACT_FLAGS_BIND);\nerr_mod:\n\tfor (i = 0; i < TCA_ACT_MAX_PRIO; i++) {\n\t\tif (ops[i])\n\t\t\tmodule_put(ops[i]->owner);\n\t}\n\treturn err;\n}\n\nvoid tcf_action_update_stats(struct tc_action *a, u64 bytes, u64 packets,\n\t\t\t     u64 drops, bool hw)\n{\n\tif (a->cpu_bstats) {\n\t\t_bstats_update(this_cpu_ptr(a->cpu_bstats), bytes, packets);\n\n\t\tthis_cpu_ptr(a->cpu_qstats)->drops += drops;\n\n\t\tif (hw)\n\t\t\t_bstats_update(this_cpu_ptr(a->cpu_bstats_hw),\n\t\t\t\t       bytes, packets);\n\t\treturn;\n\t}\n\n\t_bstats_update(&a->tcfa_bstats, bytes, packets);\n\ta->tcfa_qstats.drops += drops;\n\tif (hw)\n\t\t_bstats_update(&a->tcfa_bstats_hw, bytes, packets);\n}\nEXPORT_SYMBOL(tcf_action_update_stats);\n\nint tcf_action_copy_stats(struct sk_buff *skb, struct tc_action *p,\n\t\t\t  int compat_mode)\n{\n\tint err = 0;\n\tstruct gnet_dump d;\n\n\tif (p == NULL)\n\t\tgoto errout;\n\n\t \n\tif (compat_mode) {\n\t\tif (p->type == TCA_OLD_COMPAT)\n\t\t\terr = gnet_stats_start_copy_compat(skb, 0,\n\t\t\t\t\t\t\t   TCA_STATS,\n\t\t\t\t\t\t\t   TCA_XSTATS,\n\t\t\t\t\t\t\t   &p->tcfa_lock, &d,\n\t\t\t\t\t\t\t   TCA_PAD);\n\t\telse\n\t\t\treturn 0;\n\t} else\n\t\terr = gnet_stats_start_copy(skb, TCA_ACT_STATS,\n\t\t\t\t\t    &p->tcfa_lock, &d, TCA_ACT_PAD);\n\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (gnet_stats_copy_basic(&d, p->cpu_bstats,\n\t\t\t\t  &p->tcfa_bstats, false) < 0 ||\n\t    gnet_stats_copy_basic_hw(&d, p->cpu_bstats_hw,\n\t\t\t\t     &p->tcfa_bstats_hw, false) < 0 ||\n\t    gnet_stats_copy_rate_est(&d, &p->tcfa_rate_est) < 0 ||\n\t    gnet_stats_copy_queue(&d, p->cpu_qstats,\n\t\t\t\t  &p->tcfa_qstats,\n\t\t\t\t  p->tcfa_qstats.qlen) < 0)\n\t\tgoto errout;\n\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto errout;\n\n\treturn 0;\n\nerrout:\n\treturn -1;\n}\n\nstatic int tca_get_fill(struct sk_buff *skb, struct tc_action *actions[],\n\t\t\tu32 portid, u32 seq, u16 flags, int event, int bind,\n\t\t\tint ref, struct netlink_ext_ack *extack)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct nlattr *nest;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*t), flags);\n\tif (!nlh)\n\t\tgoto out_nlmsg_trim;\n\tt = nlmsg_data(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tt->tca__pad1 = 0;\n\tt->tca__pad2 = 0;\n\n\tif (extack && extack->_msg &&\n\t    nla_put_string(skb, TCA_ROOT_EXT_WARN_MSG, extack->_msg))\n\t\tgoto out_nlmsg_trim;\n\n\tnest = nla_nest_start_noflag(skb, TCA_ACT_TAB);\n\tif (!nest)\n\t\tgoto out_nlmsg_trim;\n\n\tif (tcf_action_dump(skb, actions, bind, ref, false) < 0)\n\t\tgoto out_nlmsg_trim;\n\n\tnla_nest_end(skb, nest);\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\n\treturn skb->len;\n\nout_nlmsg_trim:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic int\ntcf_get_notify(struct net *net, u32 portid, struct nlmsghdr *n,\n\t       struct tc_action *actions[], int event,\n\t       struct netlink_ext_ack *extack)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\tif (tca_get_fill(skb, actions, portid, n->nlmsg_seq, 0, event,\n\t\t\t 0, 1, NULL) <= 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to fill netlink attributes while adding TC action\");\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rtnl_unicast(skb, net, portid);\n}\n\nstatic struct tc_action *tcf_action_get_1(struct net *net, struct nlattr *nla,\n\t\t\t\t\t  struct nlmsghdr *n, u32 portid,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_ACT_MAX + 1];\n\tconst struct tc_action_ops *ops;\n\tstruct tc_action *a;\n\tint index;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_ACT_MAX, nla,\n\t\t\t\t\t  tcf_action_policy, extack);\n\tif (err < 0)\n\t\tgoto err_out;\n\n\terr = -EINVAL;\n\tif (tb[TCA_ACT_INDEX] == NULL ||\n\t    nla_len(tb[TCA_ACT_INDEX]) < sizeof(index)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid TC action index value\");\n\t\tgoto err_out;\n\t}\n\tindex = nla_get_u32(tb[TCA_ACT_INDEX]);\n\n\terr = -EINVAL;\n\tops = tc_lookup_action(tb[TCA_ACT_KIND]);\n\tif (!ops) {  \n\t\tNL_SET_ERR_MSG(extack, \"Specified TC action kind not found\");\n\t\tgoto err_out;\n\t}\n\terr = -ENOENT;\n\tif (__tcf_idr_search(net, ops, &a, index) == 0) {\n\t\tNL_SET_ERR_MSG(extack, \"TC action with specified index not found\");\n\t\tgoto err_mod;\n\t}\n\n\tmodule_put(ops->owner);\n\treturn a;\n\nerr_mod:\n\tmodule_put(ops->owner);\nerr_out:\n\treturn ERR_PTR(err);\n}\n\nstatic int tca_action_flush(struct net *net, struct nlattr *nla,\n\t\t\t    struct nlmsghdr *n, u32 portid,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *b;\n\tstruct nlmsghdr *nlh;\n\tstruct tcamsg *t;\n\tstruct netlink_callback dcb;\n\tstruct nlattr *nest;\n\tstruct nlattr *tb[TCA_ACT_MAX + 1];\n\tconst struct tc_action_ops *ops;\n\tstruct nlattr *kind;\n\tint err = -ENOMEM;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn err;\n\n\tb = skb_tail_pointer(skb);\n\n\terr = nla_parse_nested_deprecated(tb, TCA_ACT_MAX, nla,\n\t\t\t\t\t  tcf_action_policy, extack);\n\tif (err < 0)\n\t\tgoto err_out;\n\n\terr = -EINVAL;\n\tkind = tb[TCA_ACT_KIND];\n\tops = tc_lookup_action(kind);\n\tif (!ops) {  \n\t\tNL_SET_ERR_MSG(extack, \"Cannot flush unknown TC action\");\n\t\tgoto err_out;\n\t}\n\n\tnlh = nlmsg_put(skb, portid, n->nlmsg_seq, RTM_DELACTION,\n\t\t\tsizeof(*t), 0);\n\tif (!nlh) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to create TC action flush notification\");\n\t\tgoto out_module_put;\n\t}\n\tt = nlmsg_data(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tt->tca__pad1 = 0;\n\tt->tca__pad2 = 0;\n\n\tnest = nla_nest_start_noflag(skb, TCA_ACT_TAB);\n\tif (!nest) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to add new netlink message\");\n\t\tgoto out_module_put;\n\t}\n\n\terr = __tcf_generic_walker(net, skb, &dcb, RTM_DELACTION, ops, extack);\n\tif (err <= 0) {\n\t\tnla_nest_cancel(skb, nest);\n\t\tgoto out_module_put;\n\t}\n\n\tnla_nest_end(skb, nest);\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\tnlh->nlmsg_flags |= NLM_F_ROOT;\n\tmodule_put(ops->owner);\n\terr = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\n\t\t\t     n->nlmsg_flags & NLM_F_ECHO);\n\tif (err < 0)\n\t\tNL_SET_ERR_MSG(extack, \"Failed to send TC action flush notification\");\n\n\treturn err;\n\nout_module_put:\n\tmodule_put(ops->owner);\nerr_out:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int tcf_action_delete(struct net *net, struct tc_action *actions[])\n{\n\tint i;\n\n\tfor (i = 0; i < TCA_ACT_MAX_PRIO && actions[i]; i++) {\n\t\tstruct tc_action *a = actions[i];\n\t\tconst struct tc_action_ops *ops = a->ops;\n\t\t \n\t\tstruct tcf_idrinfo *idrinfo = a->idrinfo;\n\t\tu32 act_index = a->tcfa_index;\n\n\t\tactions[i] = NULL;\n\t\tif (tcf_action_put(a)) {\n\t\t\t \n\t\t\tmodule_put(ops->owner);\n\t\t} else  {\n\t\t\tint ret;\n\n\t\t\t \n\t\t\tret = tcf_idr_delete_index(idrinfo, act_index);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\ntcf_reoffload_del_notify(struct net *net, struct tc_action *action)\n{\n\tsize_t attr_size = tcf_action_fill_size(action);\n\tstruct tc_action *actions[TCA_ACT_MAX_PRIO] = {\n\t\t[0] = action,\n\t};\n\tconst struct tc_action_ops *ops = action->ops;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = alloc_skb(attr_size <= NLMSG_GOODSIZE ? NLMSG_GOODSIZE : attr_size,\n\t\t\tGFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (tca_get_fill(skb, actions, 0, 0, 0, RTM_DELACTION, 0, 1, NULL) <= 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tret = tcf_idr_release_unsafe(action);\n\tif (ret == ACT_P_DELETED) {\n\t\tmodule_put(ops->owner);\n\t\tret = rtnetlink_send(skb, net, 0, RTNLGRP_TC, 0);\n\t} else {\n\t\tkfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint tcf_action_reoffload_cb(flow_indr_block_bind_cb_t *cb,\n\t\t\t    void *cb_priv, bool add)\n{\n\tstruct tc_act_pernet_id *id_ptr;\n\tstruct tcf_idrinfo *idrinfo;\n\tstruct tc_action_net *tn;\n\tstruct tc_action *p;\n\tunsigned int act_id;\n\tunsigned long tmp;\n\tunsigned long id;\n\tstruct idr *idr;\n\tstruct net *net;\n\tint ret;\n\n\tif (!cb)\n\t\treturn -EINVAL;\n\n\tdown_read(&net_rwsem);\n\tmutex_lock(&act_id_mutex);\n\n\tfor_each_net(net) {\n\t\tlist_for_each_entry(id_ptr, &act_pernet_id_list, list) {\n\t\t\tact_id = id_ptr->id;\n\t\t\ttn = net_generic(net, act_id);\n\t\t\tif (!tn)\n\t\t\t\tcontinue;\n\t\t\tidrinfo = tn->idrinfo;\n\t\t\tif (!idrinfo)\n\t\t\t\tcontinue;\n\n\t\t\tmutex_lock(&idrinfo->lock);\n\t\t\tidr = &idrinfo->action_idr;\n\t\t\tidr_for_each_entry_ul(idr, p, tmp, id) {\n\t\t\t\tif (IS_ERR(p) || tc_act_bind(p->tcfa_flags))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add) {\n\t\t\t\t\ttcf_action_offload_add_ex(p, NULL, cb,\n\t\t\t\t\t\t\t\t  cb_priv);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tret = tcf_action_offload_del_ex(p, cb, cb_priv);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tc_act_skip_sw(p->tcfa_flags) &&\n\t\t\t\t    !tc_act_in_hw(p))\n\t\t\t\t\ttcf_reoffload_del_notify(net, p);\n\t\t\t}\n\t\t\tmutex_unlock(&idrinfo->lock);\n\t\t}\n\t}\n\tmutex_unlock(&act_id_mutex);\n\tup_read(&net_rwsem);\n\n\treturn 0;\n}\n\nstatic int\ntcf_del_notify(struct net *net, struct nlmsghdr *n, struct tc_action *actions[],\n\t       u32 portid, size_t attr_size, struct netlink_ext_ack *extack)\n{\n\tint ret;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(attr_size <= NLMSG_GOODSIZE ? NLMSG_GOODSIZE : attr_size,\n\t\t\tGFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (tca_get_fill(skb, actions, portid, n->nlmsg_seq, 0, RTM_DELACTION,\n\t\t\t 0, 2, extack) <= 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to fill netlink TC action attributes\");\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = tcf_action_delete(net, actions);\n\tif (ret < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to delete TC action\");\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tret = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\n\t\t\t     n->nlmsg_flags & NLM_F_ECHO);\n\treturn ret;\n}\n\nstatic int\ntca_action_gd(struct net *net, struct nlattr *nla, struct nlmsghdr *n,\n\t      u32 portid, int event, struct netlink_ext_ack *extack)\n{\n\tint i, ret;\n\tstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];\n\tstruct tc_action *act;\n\tsize_t attr_size = 0;\n\tstruct tc_action *actions[TCA_ACT_MAX_PRIO] = {};\n\n\tret = nla_parse_nested_deprecated(tb, TCA_ACT_MAX_PRIO, nla, NULL,\n\t\t\t\t\t  extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (event == RTM_DELACTION && n->nlmsg_flags & NLM_F_ROOT) {\n\t\tif (tb[1])\n\t\t\treturn tca_action_flush(net, tb[1], n, portid, extack);\n\n\t\tNL_SET_ERR_MSG(extack, \"Invalid netlink attributes while flushing TC action\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {\n\t\tact = tcf_action_get_1(net, tb[i], n, portid, extack);\n\t\tif (IS_ERR(act)) {\n\t\t\tret = PTR_ERR(act);\n\t\t\tgoto err;\n\t\t}\n\t\tattr_size += tcf_action_fill_size(act);\n\t\tactions[i - 1] = act;\n\t}\n\n\tattr_size = tcf_action_full_attrs_size(attr_size);\n\n\tif (event == RTM_GETACTION)\n\t\tret = tcf_get_notify(net, portid, n, actions, event, extack);\n\telse {  \n\t\tret = tcf_del_notify(net, n, actions, portid, attr_size, extack);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\treturn 0;\n\t}\nerr:\n\ttcf_action_put_many(actions);\n\treturn ret;\n}\n\nstatic int\ntcf_add_notify(struct net *net, struct nlmsghdr *n, struct tc_action *actions[],\n\t       u32 portid, size_t attr_size, struct netlink_ext_ack *extack)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(attr_size <= NLMSG_GOODSIZE ? NLMSG_GOODSIZE : attr_size,\n\t\t\tGFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (tca_get_fill(skb, actions, portid, n->nlmsg_seq, n->nlmsg_flags,\n\t\t\t RTM_NEWACTION, 0, 0, extack) <= 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to fill netlink attributes while adding TC action\");\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rtnetlink_send(skb, net, portid, RTNLGRP_TC,\n\t\t\t      n->nlmsg_flags & NLM_F_ECHO);\n}\n\nstatic int tcf_action_add(struct net *net, struct nlattr *nla,\n\t\t\t  struct nlmsghdr *n, u32 portid, u32 flags,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tsize_t attr_size = 0;\n\tint loop, ret, i;\n\tstruct tc_action *actions[TCA_ACT_MAX_PRIO] = {};\n\tint init_res[TCA_ACT_MAX_PRIO] = {};\n\n\tfor (loop = 0; loop < 10; loop++) {\n\t\tret = tcf_action_init(net, NULL, nla, NULL, actions, init_res,\n\t\t\t\t      &attr_size, flags, 0, extack);\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\tret = tcf_add_notify(net, n, actions, portid, attr_size, extack);\n\n\t \n\tfor (i = 0; i < TCA_ACT_MAX_PRIO; i++)\n\t\tif (init_res[i] == ACT_P_CREATED)\n\t\t\tactions[i] = NULL;\n\ttcf_action_put_many(actions);\n\n\treturn ret;\n}\n\nstatic const struct nla_policy tcaa_policy[TCA_ROOT_MAX + 1] = {\n\t[TCA_ROOT_FLAGS] = NLA_POLICY_BITFIELD32(TCA_ACT_FLAG_LARGE_DUMP_ON |\n\t\t\t\t\t\t TCA_ACT_FLAG_TERSE_DUMP),\n\t[TCA_ROOT_TIME_DELTA]      = { .type = NLA_U32 },\n};\n\nstatic int tc_ctl_action(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_ROOT_MAX + 1];\n\tu32 portid = NETLINK_CB(skb).portid;\n\tu32 flags = 0;\n\tint ret = 0;\n\n\tif ((n->nlmsg_type != RTM_GETACTION) &&\n\t    !netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tret = nlmsg_parse_deprecated(n, sizeof(struct tcamsg), tca,\n\t\t\t\t     TCA_ROOT_MAX, NULL, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tca[TCA_ACT_TAB] == NULL) {\n\t\tNL_SET_ERR_MSG(extack, \"Netlink action attributes missing\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (n->nlmsg_type) {\n\tcase RTM_NEWACTION:\n\t\t \n\t\tif (n->nlmsg_flags & NLM_F_REPLACE)\n\t\t\tflags = TCA_ACT_FLAGS_REPLACE;\n\t\tret = tcf_action_add(net, tca[TCA_ACT_TAB], n, portid, flags,\n\t\t\t\t     extack);\n\t\tbreak;\n\tcase RTM_DELACTION:\n\t\tret = tca_action_gd(net, tca[TCA_ACT_TAB], n,\n\t\t\t\t    portid, RTM_DELACTION, extack);\n\t\tbreak;\n\tcase RTM_GETACTION:\n\t\tret = tca_action_gd(net, tca[TCA_ACT_TAB], n,\n\t\t\t\t    portid, RTM_GETACTION, extack);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn ret;\n}\n\nstatic struct nlattr *find_dump_kind(struct nlattr **nla)\n{\n\tstruct nlattr *tb1, *tb2[TCA_ACT_MAX + 1];\n\tstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];\n\tstruct nlattr *kind;\n\n\ttb1 = nla[TCA_ACT_TAB];\n\tif (tb1 == NULL)\n\t\treturn NULL;\n\n\tif (nla_parse_deprecated(tb, TCA_ACT_MAX_PRIO, nla_data(tb1), NLMSG_ALIGN(nla_len(tb1)), NULL, NULL) < 0)\n\t\treturn NULL;\n\n\tif (tb[1] == NULL)\n\t\treturn NULL;\n\tif (nla_parse_nested_deprecated(tb2, TCA_ACT_MAX, tb[1], tcf_action_policy, NULL) < 0)\n\t\treturn NULL;\n\tkind = tb2[TCA_ACT_KIND];\n\n\treturn kind;\n}\n\nstatic int tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct nlattr *nest;\n\tstruct tc_action_ops *a_o;\n\tint ret = 0;\n\tstruct tcamsg *t = (struct tcamsg *) nlmsg_data(cb->nlh);\n\tstruct nlattr *tb[TCA_ROOT_MAX + 1];\n\tstruct nlattr *count_attr = NULL;\n\tunsigned long jiffy_since = 0;\n\tstruct nlattr *kind = NULL;\n\tstruct nla_bitfield32 bf;\n\tu32 msecs_since = 0;\n\tu32 act_count = 0;\n\n\tret = nlmsg_parse_deprecated(cb->nlh, sizeof(struct tcamsg), tb,\n\t\t\t\t     TCA_ROOT_MAX, tcaa_policy, cb->extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tkind = find_dump_kind(tb);\n\tif (kind == NULL) {\n\t\tpr_info(\"tc_dump_action: action bad kind\\n\");\n\t\treturn 0;\n\t}\n\n\ta_o = tc_lookup_action(kind);\n\tif (a_o == NULL)\n\t\treturn 0;\n\n\tcb->args[2] = 0;\n\tif (tb[TCA_ROOT_FLAGS]) {\n\t\tbf = nla_get_bitfield32(tb[TCA_ROOT_FLAGS]);\n\t\tcb->args[2] = bf.value;\n\t}\n\n\tif (tb[TCA_ROOT_TIME_DELTA]) {\n\t\tmsecs_since = nla_get_u32(tb[TCA_ROOT_TIME_DELTA]);\n\t}\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\tcb->nlh->nlmsg_type, sizeof(*t), 0);\n\tif (!nlh)\n\t\tgoto out_module_put;\n\n\tif (msecs_since)\n\t\tjiffy_since = jiffies - msecs_to_jiffies(msecs_since);\n\n\tt = nlmsg_data(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tt->tca__pad1 = 0;\n\tt->tca__pad2 = 0;\n\tcb->args[3] = jiffy_since;\n\tcount_attr = nla_reserve(skb, TCA_ROOT_COUNT, sizeof(u32));\n\tif (!count_attr)\n\t\tgoto out_module_put;\n\n\tnest = nla_nest_start_noflag(skb, TCA_ACT_TAB);\n\tif (nest == NULL)\n\t\tgoto out_module_put;\n\n\tret = __tcf_generic_walker(net, skb, cb, RTM_GETACTION, a_o, NULL);\n\tif (ret < 0)\n\t\tgoto out_module_put;\n\n\tif (ret > 0) {\n\t\tnla_nest_end(skb, nest);\n\t\tret = skb->len;\n\t\tact_count = cb->args[1];\n\t\tmemcpy(nla_data(count_attr), &act_count, sizeof(u32));\n\t\tcb->args[1] = 0;\n\t} else\n\t\tnlmsg_trim(skb, b);\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\tif (NETLINK_CB(cb->skb).portid && ret)\n\t\tnlh->nlmsg_flags |= NLM_F_MULTI;\n\tmodule_put(a_o->owner);\n\treturn skb->len;\n\nout_module_put:\n\tmodule_put(a_o->owner);\n\tnlmsg_trim(skb, b);\n\treturn skb->len;\n}\n\nstatic int __init tc_action_init(void)\n{\n\trtnl_register(PF_UNSPEC, RTM_NEWACTION, tc_ctl_action, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELACTION, tc_ctl_action, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETACTION, tc_ctl_action, tc_dump_action,\n\t\t      0);\n\n\treturn 0;\n}\n\nsubsys_initcall(tc_action_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}