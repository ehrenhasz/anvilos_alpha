{
  "module_name": "sch_drr.c",
  "hash_id": "63a1c3fb881f686f01263a40cf4c4aee486e89294d9d10c534d7ccbf25405448",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_drr.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/pkt_sched.h>\n#include <net/sch_generic.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n\nstruct drr_class {\n\tstruct Qdisc_class_common\tcommon;\n\n\tstruct gnet_stats_basic_sync\t\tbstats;\n\tstruct gnet_stats_queue\t\tqstats;\n\tstruct net_rate_estimator __rcu *rate_est;\n\tstruct list_head\t\talist;\n\tstruct Qdisc\t\t\t*qdisc;\n\n\tu32\t\t\t\tquantum;\n\tu32\t\t\t\tdeficit;\n};\n\nstruct drr_sched {\n\tstruct list_head\t\tactive;\n\tstruct tcf_proto __rcu\t\t*filter_list;\n\tstruct tcf_block\t\t*block;\n\tstruct Qdisc_class_hash\t\tclhash;\n};\n\nstatic struct drr_class *drr_find_class(struct Qdisc *sch, u32 classid)\n{\n\tstruct drr_sched *q = qdisc_priv(sch);\n\tstruct Qdisc_class_common *clc;\n\n\tclc = qdisc_class_find(&q->clhash, classid);\n\tif (clc == NULL)\n\t\treturn NULL;\n\treturn container_of(clc, struct drr_class, common);\n}\n\nstatic const struct nla_policy drr_policy[TCA_DRR_MAX + 1] = {\n\t[TCA_DRR_QUANTUM]\t= { .type = NLA_U32 },\n};\n\nstatic int drr_change_class(struct Qdisc *sch, u32 classid, u32 parentid,\n\t\t\t    struct nlattr **tca, unsigned long *arg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct drr_sched *q = qdisc_priv(sch);\n\tstruct drr_class *cl = (struct drr_class *)*arg;\n\tstruct nlattr *opt = tca[TCA_OPTIONS];\n\tstruct nlattr *tb[TCA_DRR_MAX + 1];\n\tu32 quantum;\n\tint err;\n\n\tif (!opt) {\n\t\tNL_SET_ERR_MSG(extack, \"DRR options are required for this operation\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, TCA_DRR_MAX, opt, drr_policy,\n\t\t\t\t\t  extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_DRR_QUANTUM]) {\n\t\tquantum = nla_get_u32(tb[TCA_DRR_QUANTUM]);\n\t\tif (quantum == 0) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Specified DRR quantum cannot be zero\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\t\tquantum = psched_mtu(qdisc_dev(sch));\n\n\tif (cl != NULL) {\n\t\tif (tca[TCA_RATE]) {\n\t\t\terr = gen_replace_estimator(&cl->bstats, NULL,\n\t\t\t\t\t\t    &cl->rate_est,\n\t\t\t\t\t\t    NULL, true,\n\t\t\t\t\t\t    tca[TCA_RATE]);\n\t\t\tif (err) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Failed to replace estimator\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tsch_tree_lock(sch);\n\t\tif (tb[TCA_DRR_QUANTUM])\n\t\t\tcl->quantum = quantum;\n\t\tsch_tree_unlock(sch);\n\n\t\treturn 0;\n\t}\n\n\tcl = kzalloc(sizeof(struct drr_class), GFP_KERNEL);\n\tif (cl == NULL)\n\t\treturn -ENOBUFS;\n\n\tgnet_stats_basic_sync_init(&cl->bstats);\n\tcl->common.classid = classid;\n\tcl->quantum\t   = quantum;\n\tcl->qdisc\t   = qdisc_create_dflt(sch->dev_queue,\n\t\t\t\t\t       &pfifo_qdisc_ops, classid,\n\t\t\t\t\t       NULL);\n\tif (cl->qdisc == NULL)\n\t\tcl->qdisc = &noop_qdisc;\n\telse\n\t\tqdisc_hash_add(cl->qdisc, true);\n\n\tif (tca[TCA_RATE]) {\n\t\terr = gen_replace_estimator(&cl->bstats, NULL, &cl->rate_est,\n\t\t\t\t\t    NULL, true, tca[TCA_RATE]);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Failed to replace estimator\");\n\t\t\tqdisc_put(cl->qdisc);\n\t\t\tkfree(cl);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tsch_tree_lock(sch);\n\tqdisc_class_hash_insert(&q->clhash, &cl->common);\n\tsch_tree_unlock(sch);\n\n\tqdisc_class_hash_grow(sch, &q->clhash);\n\n\t*arg = (unsigned long)cl;\n\treturn 0;\n}\n\nstatic void drr_destroy_class(struct Qdisc *sch, struct drr_class *cl)\n{\n\tgen_kill_estimator(&cl->rate_est);\n\tqdisc_put(cl->qdisc);\n\tkfree(cl);\n}\n\nstatic int drr_delete_class(struct Qdisc *sch, unsigned long arg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct drr_sched *q = qdisc_priv(sch);\n\tstruct drr_class *cl = (struct drr_class *)arg;\n\n\tif (qdisc_class_in_use(&cl->common)) {\n\t\tNL_SET_ERR_MSG(extack, \"DRR class is in use\");\n\t\treturn -EBUSY;\n\t}\n\n\tsch_tree_lock(sch);\n\n\tqdisc_purge_queue(cl->qdisc);\n\tqdisc_class_hash_remove(&q->clhash, &cl->common);\n\n\tsch_tree_unlock(sch);\n\n\tdrr_destroy_class(sch, cl);\n\treturn 0;\n}\n\nstatic unsigned long drr_search_class(struct Qdisc *sch, u32 classid)\n{\n\treturn (unsigned long)drr_find_class(sch, classid);\n}\n\nstatic struct tcf_block *drr_tcf_block(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct drr_sched *q = qdisc_priv(sch);\n\n\tif (cl) {\n\t\tNL_SET_ERR_MSG(extack, \"DRR classid must be zero\");\n\t\treturn NULL;\n\t}\n\n\treturn q->block;\n}\n\nstatic unsigned long drr_bind_tcf(struct Qdisc *sch, unsigned long parent,\n\t\t\t\t  u32 classid)\n{\n\tstruct drr_class *cl = drr_find_class(sch, classid);\n\n\tif (cl)\n\t\tqdisc_class_get(&cl->common);\n\n\treturn (unsigned long)cl;\n}\n\nstatic void drr_unbind_tcf(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct drr_class *cl = (struct drr_class *)arg;\n\n\tqdisc_class_put(&cl->common);\n}\n\nstatic int drr_graft_class(struct Qdisc *sch, unsigned long arg,\n\t\t\t   struct Qdisc *new, struct Qdisc **old,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct drr_class *cl = (struct drr_class *)arg;\n\n\tif (new == NULL) {\n\t\tnew = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\n\t\t\t\t\tcl->common.classid, NULL);\n\t\tif (new == NULL)\n\t\t\tnew = &noop_qdisc;\n\t}\n\n\t*old = qdisc_replace(sch, new, &cl->qdisc);\n\treturn 0;\n}\n\nstatic struct Qdisc *drr_class_leaf(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct drr_class *cl = (struct drr_class *)arg;\n\n\treturn cl->qdisc;\n}\n\nstatic void drr_qlen_notify(struct Qdisc *csh, unsigned long arg)\n{\n\tstruct drr_class *cl = (struct drr_class *)arg;\n\n\tlist_del(&cl->alist);\n}\n\nstatic int drr_dump_class(struct Qdisc *sch, unsigned long arg,\n\t\t\t  struct sk_buff *skb, struct tcmsg *tcm)\n{\n\tstruct drr_class *cl = (struct drr_class *)arg;\n\tstruct nlattr *nest;\n\n\ttcm->tcm_parent\t= TC_H_ROOT;\n\ttcm->tcm_handle\t= cl->common.classid;\n\ttcm->tcm_info\t= cl->qdisc->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, TCA_DRR_QUANTUM, cl->quantum))\n\t\tgoto nla_put_failure;\n\treturn nla_nest_end(skb, nest);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int drr_dump_class_stats(struct Qdisc *sch, unsigned long arg,\n\t\t\t\tstruct gnet_dump *d)\n{\n\tstruct drr_class *cl = (struct drr_class *)arg;\n\t__u32 qlen = qdisc_qlen_sum(cl->qdisc);\n\tstruct Qdisc *cl_q = cl->qdisc;\n\tstruct tc_drr_stats xstats;\n\n\tmemset(&xstats, 0, sizeof(xstats));\n\tif (qlen)\n\t\txstats.deficit = cl->deficit;\n\n\tif (gnet_stats_copy_basic(d, NULL, &cl->bstats, true) < 0 ||\n\t    gnet_stats_copy_rate_est(d, &cl->rate_est) < 0 ||\n\t    gnet_stats_copy_queue(d, cl_q->cpu_qstats, &cl_q->qstats, qlen) < 0)\n\t\treturn -1;\n\n\treturn gnet_stats_copy_app(d, &xstats, sizeof(xstats));\n}\n\nstatic void drr_walk(struct Qdisc *sch, struct qdisc_walker *arg)\n{\n\tstruct drr_sched *q = qdisc_priv(sch);\n\tstruct drr_class *cl;\n\tunsigned int i;\n\n\tif (arg->stop)\n\t\treturn;\n\n\tfor (i = 0; i < q->clhash.hashsize; i++) {\n\t\thlist_for_each_entry(cl, &q->clhash.hash[i], common.hnode) {\n\t\t\tif (!tc_qdisc_stats_dump(sch, (unsigned long)cl, arg))\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic struct drr_class *drr_classify(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t\t      int *qerr)\n{\n\tstruct drr_sched *q = qdisc_priv(sch);\n\tstruct drr_class *cl;\n\tstruct tcf_result res;\n\tstruct tcf_proto *fl;\n\tint result;\n\n\tif (TC_H_MAJ(skb->priority ^ sch->handle) == 0) {\n\t\tcl = drr_find_class(sch, skb->priority);\n\t\tif (cl != NULL)\n\t\t\treturn cl;\n\t}\n\n\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\tfl = rcu_dereference_bh(q->filter_list);\n\tresult = tcf_classify(skb, NULL, fl, &res, false);\n\tif (result >= 0) {\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\tfallthrough;\n\t\tcase TC_ACT_SHOT:\n\t\t\treturn NULL;\n\t\t}\n#endif\n\t\tcl = (struct drr_class *)res.class;\n\t\tif (cl == NULL)\n\t\t\tcl = drr_find_class(sch, res.classid);\n\t\treturn cl;\n\t}\n\treturn NULL;\n}\n\nstatic int drr_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\tunsigned int len = qdisc_pkt_len(skb);\n\tstruct drr_sched *q = qdisc_priv(sch);\n\tstruct drr_class *cl;\n\tint err = 0;\n\tbool first;\n\n\tcl = drr_classify(skb, sch, &err);\n\tif (cl == NULL) {\n\t\tif (err & __NET_XMIT_BYPASS)\n\t\t\tqdisc_qstats_drop(sch);\n\t\t__qdisc_drop(skb, to_free);\n\t\treturn err;\n\t}\n\n\tfirst = !cl->qdisc->q.qlen;\n\terr = qdisc_enqueue(skb, cl->qdisc, to_free);\n\tif (unlikely(err != NET_XMIT_SUCCESS)) {\n\t\tif (net_xmit_drop_count(err)) {\n\t\t\tcl->qstats.drops++;\n\t\t\tqdisc_qstats_drop(sch);\n\t\t}\n\t\treturn err;\n\t}\n\n\tif (first) {\n\t\tlist_add_tail(&cl->alist, &q->active);\n\t\tcl->deficit = cl->quantum;\n\t}\n\n\tsch->qstats.backlog += len;\n\tsch->q.qlen++;\n\treturn err;\n}\n\nstatic struct sk_buff *drr_dequeue(struct Qdisc *sch)\n{\n\tstruct drr_sched *q = qdisc_priv(sch);\n\tstruct drr_class *cl;\n\tstruct sk_buff *skb;\n\tunsigned int len;\n\n\tif (list_empty(&q->active))\n\t\tgoto out;\n\twhile (1) {\n\t\tcl = list_first_entry(&q->active, struct drr_class, alist);\n\t\tskb = cl->qdisc->ops->peek(cl->qdisc);\n\t\tif (skb == NULL) {\n\t\t\tqdisc_warn_nonwc(__func__, cl->qdisc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlen = qdisc_pkt_len(skb);\n\t\tif (len <= cl->deficit) {\n\t\t\tcl->deficit -= len;\n\t\t\tskb = qdisc_dequeue_peeked(cl->qdisc);\n\t\t\tif (unlikely(skb == NULL))\n\t\t\t\tgoto out;\n\t\t\tif (cl->qdisc->q.qlen == 0)\n\t\t\t\tlist_del(&cl->alist);\n\n\t\t\tbstats_update(&cl->bstats, skb);\n\t\t\tqdisc_bstats_update(sch, skb);\n\t\t\tqdisc_qstats_backlog_dec(sch, skb);\n\t\t\tsch->q.qlen--;\n\t\t\treturn skb;\n\t\t}\n\n\t\tcl->deficit += cl->quantum;\n\t\tlist_move_tail(&cl->alist, &q->active);\n\t}\nout:\n\treturn NULL;\n}\n\nstatic int drr_init_qdisc(struct Qdisc *sch, struct nlattr *opt,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct drr_sched *q = qdisc_priv(sch);\n\tint err;\n\n\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);\n\tif (err)\n\t\treturn err;\n\terr = qdisc_class_hash_init(&q->clhash);\n\tif (err < 0)\n\t\treturn err;\n\tINIT_LIST_HEAD(&q->active);\n\treturn 0;\n}\n\nstatic void drr_reset_qdisc(struct Qdisc *sch)\n{\n\tstruct drr_sched *q = qdisc_priv(sch);\n\tstruct drr_class *cl;\n\tunsigned int i;\n\n\tfor (i = 0; i < q->clhash.hashsize; i++) {\n\t\thlist_for_each_entry(cl, &q->clhash.hash[i], common.hnode) {\n\t\t\tif (cl->qdisc->q.qlen)\n\t\t\t\tlist_del(&cl->alist);\n\t\t\tqdisc_reset(cl->qdisc);\n\t\t}\n\t}\n}\n\nstatic void drr_destroy_qdisc(struct Qdisc *sch)\n{\n\tstruct drr_sched *q = qdisc_priv(sch);\n\tstruct drr_class *cl;\n\tstruct hlist_node *next;\n\tunsigned int i;\n\n\ttcf_block_put(q->block);\n\n\tfor (i = 0; i < q->clhash.hashsize; i++) {\n\t\thlist_for_each_entry_safe(cl, next, &q->clhash.hash[i],\n\t\t\t\t\t  common.hnode)\n\t\t\tdrr_destroy_class(sch, cl);\n\t}\n\tqdisc_class_hash_destroy(&q->clhash);\n}\n\nstatic const struct Qdisc_class_ops drr_class_ops = {\n\t.change\t\t= drr_change_class,\n\t.delete\t\t= drr_delete_class,\n\t.find\t\t= drr_search_class,\n\t.tcf_block\t= drr_tcf_block,\n\t.bind_tcf\t= drr_bind_tcf,\n\t.unbind_tcf\t= drr_unbind_tcf,\n\t.graft\t\t= drr_graft_class,\n\t.leaf\t\t= drr_class_leaf,\n\t.qlen_notify\t= drr_qlen_notify,\n\t.dump\t\t= drr_dump_class,\n\t.dump_stats\t= drr_dump_class_stats,\n\t.walk\t\t= drr_walk,\n};\n\nstatic struct Qdisc_ops drr_qdisc_ops __read_mostly = {\n\t.cl_ops\t\t= &drr_class_ops,\n\t.id\t\t= \"drr\",\n\t.priv_size\t= sizeof(struct drr_sched),\n\t.enqueue\t= drr_enqueue,\n\t.dequeue\t= drr_dequeue,\n\t.peek\t\t= qdisc_peek_dequeued,\n\t.init\t\t= drr_init_qdisc,\n\t.reset\t\t= drr_reset_qdisc,\n\t.destroy\t= drr_destroy_qdisc,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init drr_init(void)\n{\n\treturn register_qdisc(&drr_qdisc_ops);\n}\n\nstatic void __exit drr_exit(void)\n{\n\tunregister_qdisc(&drr_qdisc_ops);\n}\n\nmodule_init(drr_init);\nmodule_exit(drr_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}