{
  "module_name": "act_mpls.c",
  "hash_id": "14c02e683861a54340e7c8896410011bd7895529503f5f37a2b7af754356b4db",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_mpls.c",
  "human_readable_source": "\n \n\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mpls.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/tc_act/tc_mpls.h>\n#include <net/mpls.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <net/tc_act/tc_mpls.h>\n#include <net/tc_wrapper.h>\n\nstatic struct tc_action_ops act_mpls_ops;\n\n#define ACT_MPLS_TTL_DEFAULT\t255\n\nstatic __be32 tcf_mpls_get_lse(struct mpls_shim_hdr *lse,\n\t\t\t       struct tcf_mpls_params *p, bool set_bos)\n{\n\tu32 new_lse = 0;\n\n\tif (lse)\n\t\tnew_lse = be32_to_cpu(lse->label_stack_entry);\n\n\tif (p->tcfm_label != ACT_MPLS_LABEL_NOT_SET) {\n\t\tnew_lse &= ~MPLS_LS_LABEL_MASK;\n\t\tnew_lse |= p->tcfm_label << MPLS_LS_LABEL_SHIFT;\n\t}\n\tif (p->tcfm_ttl) {\n\t\tnew_lse &= ~MPLS_LS_TTL_MASK;\n\t\tnew_lse |= p->tcfm_ttl << MPLS_LS_TTL_SHIFT;\n\t}\n\tif (p->tcfm_tc != ACT_MPLS_TC_NOT_SET) {\n\t\tnew_lse &= ~MPLS_LS_TC_MASK;\n\t\tnew_lse |= p->tcfm_tc << MPLS_LS_TC_SHIFT;\n\t}\n\tif (p->tcfm_bos != ACT_MPLS_BOS_NOT_SET) {\n\t\tnew_lse &= ~MPLS_LS_S_MASK;\n\t\tnew_lse |= p->tcfm_bos << MPLS_LS_S_SHIFT;\n\t} else if (set_bos) {\n\t\tnew_lse |= 1 << MPLS_LS_S_SHIFT;\n\t}\n\n\treturn cpu_to_be32(new_lse);\n}\n\nTC_INDIRECT_SCOPE int tcf_mpls_act(struct sk_buff *skb,\n\t\t\t\t   const struct tc_action *a,\n\t\t\t\t   struct tcf_result *res)\n{\n\tstruct tcf_mpls *m = to_mpls(a);\n\tstruct tcf_mpls_params *p;\n\t__be32 new_lse;\n\tint ret, mac_len;\n\n\ttcf_lastuse_update(&m->tcf_tm);\n\tbstats_update(this_cpu_ptr(m->common.cpu_bstats), skb);\n\n\t \n\tif (skb_at_tc_ingress(skb)) {\n\t\tskb_push_rcsum(skb, skb->mac_len);\n\t\tmac_len = skb->mac_len;\n\t} else {\n\t\tmac_len = skb_network_offset(skb);\n\t}\n\n\tret = READ_ONCE(m->tcf_action);\n\n\tp = rcu_dereference_bh(m->mpls_p);\n\n\tswitch (p->tcfm_action) {\n\tcase TCA_MPLS_ACT_POP:\n\t\tif (skb_mpls_pop(skb, p->tcfm_proto, mac_len,\n\t\t\t\t skb->dev && skb->dev->type == ARPHRD_ETHER))\n\t\t\tgoto drop;\n\t\tbreak;\n\tcase TCA_MPLS_ACT_PUSH:\n\t\tnew_lse = tcf_mpls_get_lse(NULL, p, !eth_p_mpls(skb_protocol(skb, true)));\n\t\tif (skb_mpls_push(skb, new_lse, p->tcfm_proto, mac_len,\n\t\t\t\t  skb->dev && skb->dev->type == ARPHRD_ETHER))\n\t\t\tgoto drop;\n\t\tbreak;\n\tcase TCA_MPLS_ACT_MAC_PUSH:\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\tif (__vlan_insert_inner_tag(skb, skb->vlan_proto,\n\t\t\t\t\t\t    skb_vlan_tag_get(skb),\n\t\t\t\t\t\t    ETH_HLEN) < 0)\n\t\t\t\tgoto drop;\n\n\t\t\tskb->protocol = skb->vlan_proto;\n\t\t\t__vlan_hwaccel_clear_tag(skb);\n\t\t}\n\n\t\tnew_lse = tcf_mpls_get_lse(NULL, p, mac_len ||\n\t\t\t\t\t   !eth_p_mpls(skb->protocol));\n\n\t\tif (skb_mpls_push(skb, new_lse, p->tcfm_proto, 0, false))\n\t\t\tgoto drop;\n\t\tbreak;\n\tcase TCA_MPLS_ACT_MODIFY:\n\t\tif (!pskb_may_pull(skb,\n\t\t\t\t   skb_network_offset(skb) + MPLS_HLEN))\n\t\t\tgoto drop;\n\t\tnew_lse = tcf_mpls_get_lse(mpls_hdr(skb), p, false);\n\t\tif (skb_mpls_update_lse(skb, new_lse))\n\t\t\tgoto drop;\n\t\tbreak;\n\tcase TCA_MPLS_ACT_DEC_TTL:\n\t\tif (skb_mpls_dec_ttl(skb))\n\t\t\tgoto drop;\n\t\tbreak;\n\t}\n\n\tif (skb_at_tc_ingress(skb))\n\t\tskb_pull_rcsum(skb, skb->mac_len);\n\n\treturn ret;\n\ndrop:\n\tqstats_drop_inc(this_cpu_ptr(m->common.cpu_qstats));\n\treturn TC_ACT_SHOT;\n}\n\nstatic int valid_label(const struct nlattr *attr,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tconst u32 *label = nla_data(attr);\n\n\tif (nla_len(attr) != sizeof(*label)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid MPLS label length\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*label & ~MPLS_LABEL_MASK || *label == MPLS_LABEL_IMPLNULL) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MPLS label out of range\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nla_policy mpls_policy[TCA_MPLS_MAX + 1] = {\n\t[TCA_MPLS_PARMS]\t= NLA_POLICY_EXACT_LEN(sizeof(struct tc_mpls)),\n\t[TCA_MPLS_PROTO]\t= { .type = NLA_U16 },\n\t[TCA_MPLS_LABEL]\t= NLA_POLICY_VALIDATE_FN(NLA_BINARY,\n\t\t\t\t\t\t\t valid_label),\n\t[TCA_MPLS_TC]\t\t= NLA_POLICY_RANGE(NLA_U8, 0, 7),\n\t[TCA_MPLS_TTL]\t\t= NLA_POLICY_MIN(NLA_U8, 1),\n\t[TCA_MPLS_BOS]\t\t= NLA_POLICY_RANGE(NLA_U8, 0, 1),\n};\n\nstatic int tcf_mpls_init(struct net *net, struct nlattr *nla,\n\t\t\t struct nlattr *est, struct tc_action **a,\n\t\t\t struct tcf_proto *tp, u32 flags,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_mpls_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_MPLS_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tcf_mpls_params *p;\n\tstruct tc_mpls *parm;\n\tbool exists = false;\n\tstruct tcf_mpls *m;\n\tint ret = 0, err;\n\tu8 mpls_ttl = 0;\n\tu32 index;\n\n\tif (!nla) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing netlink attributes\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested(tb, TCA_MPLS_MAX, nla, mpls_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_MPLS_PARMS]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No MPLS params\");\n\t\treturn -EINVAL;\n\t}\n\tparm = nla_data(tb[TCA_MPLS_PARMS]);\n\tindex = parm->index;\n\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0)\n\t\treturn err;\n\texists = err;\n\tif (exists && bind)\n\t\treturn 0;\n\n\tif (!exists) {\n\t\tret = tcf_idr_create(tn, index, est, a, &act_mpls_ops, bind,\n\t\t\t\t     true, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ACT_P_CREATED;\n\t} else if (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\ttcf_idr_release(*a, bind);\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tswitch (parm->m_action) {\n\tcase TCA_MPLS_ACT_POP:\n\t\tif (!tb[TCA_MPLS_PROTO]) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Protocol must be set for MPLS pop\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto release_idr;\n\t\t}\n\t\tif (!eth_proto_is_802_3(nla_get_be16(tb[TCA_MPLS_PROTO]))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid protocol type for MPLS pop\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto release_idr;\n\t\t}\n\t\tif (tb[TCA_MPLS_LABEL] || tb[TCA_MPLS_TTL] || tb[TCA_MPLS_TC] ||\n\t\t    tb[TCA_MPLS_BOS]) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Label, TTL, TC or BOS cannot be used with MPLS pop\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto release_idr;\n\t\t}\n\t\tbreak;\n\tcase TCA_MPLS_ACT_DEC_TTL:\n\t\tif (tb[TCA_MPLS_PROTO] || tb[TCA_MPLS_LABEL] ||\n\t\t    tb[TCA_MPLS_TTL] || tb[TCA_MPLS_TC] || tb[TCA_MPLS_BOS]) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Label, TTL, TC, BOS or protocol cannot be used with MPLS dec_ttl\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto release_idr;\n\t\t}\n\t\tbreak;\n\tcase TCA_MPLS_ACT_PUSH:\n\tcase TCA_MPLS_ACT_MAC_PUSH:\n\t\tif (!tb[TCA_MPLS_LABEL]) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Label is required for MPLS push\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto release_idr;\n\t\t}\n\t\tif (tb[TCA_MPLS_PROTO] &&\n\t\t    !eth_p_mpls(nla_get_be16(tb[TCA_MPLS_PROTO]))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Protocol must be an MPLS type for MPLS push\");\n\t\t\terr = -EPROTONOSUPPORT;\n\t\t\tgoto release_idr;\n\t\t}\n\t\t \n\t\tif (!tb[TCA_MPLS_TTL]) {\n#if IS_ENABLED(CONFIG_MPLS)\n\t\t\tmpls_ttl = net->mpls.default_ttl ?\n\t\t\t\t   net->mpls.default_ttl : ACT_MPLS_TTL_DEFAULT;\n#else\n\t\t\tmpls_ttl = ACT_MPLS_TTL_DEFAULT;\n#endif\n\t\t}\n\t\tbreak;\n\tcase TCA_MPLS_ACT_MODIFY:\n\t\tif (tb[TCA_MPLS_PROTO]) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Protocol cannot be used with MPLS modify\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto release_idr;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown MPLS action\");\n\t\terr = -EINVAL;\n\t\tgoto release_idr;\n\t}\n\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\tm = to_mpls(*a);\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p) {\n\t\terr = -ENOMEM;\n\t\tgoto put_chain;\n\t}\n\n\tp->tcfm_action = parm->m_action;\n\tp->tcfm_label = tb[TCA_MPLS_LABEL] ? nla_get_u32(tb[TCA_MPLS_LABEL]) :\n\t\t\t\t\t     ACT_MPLS_LABEL_NOT_SET;\n\tp->tcfm_tc = tb[TCA_MPLS_TC] ? nla_get_u8(tb[TCA_MPLS_TC]) :\n\t\t\t\t       ACT_MPLS_TC_NOT_SET;\n\tp->tcfm_ttl = tb[TCA_MPLS_TTL] ? nla_get_u8(tb[TCA_MPLS_TTL]) :\n\t\t\t\t\t mpls_ttl;\n\tp->tcfm_bos = tb[TCA_MPLS_BOS] ? nla_get_u8(tb[TCA_MPLS_BOS]) :\n\t\t\t\t\t ACT_MPLS_BOS_NOT_SET;\n\tp->tcfm_proto = tb[TCA_MPLS_PROTO] ? nla_get_be16(tb[TCA_MPLS_PROTO]) :\n\t\t\t\t\t     htons(ETH_P_MPLS_UC);\n\n\tspin_lock_bh(&m->tcf_lock);\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\tp = rcu_replace_pointer(m->mpls_p, p, lockdep_is_held(&m->tcf_lock));\n\tspin_unlock_bh(&m->tcf_lock);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\tif (p)\n\t\tkfree_rcu(p, rcu);\n\n\treturn ret;\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic void tcf_mpls_cleanup(struct tc_action *a)\n{\n\tstruct tcf_mpls *m = to_mpls(a);\n\tstruct tcf_mpls_params *p;\n\n\tp = rcu_dereference_protected(m->mpls_p, 1);\n\tif (p)\n\t\tkfree_rcu(p, rcu);\n}\n\nstatic int tcf_mpls_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_mpls *m = to_mpls(a);\n\tstruct tcf_mpls_params *p;\n\tstruct tc_mpls opt = {\n\t\t.index    = m->tcf_index,\n\t\t.refcnt   = refcount_read(&m->tcf_refcnt) - ref,\n\t\t.bindcnt  = atomic_read(&m->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&m->tcf_lock);\n\topt.action = m->tcf_action;\n\tp = rcu_dereference_protected(m->mpls_p, lockdep_is_held(&m->tcf_lock));\n\topt.m_action = p->tcfm_action;\n\n\tif (nla_put(skb, TCA_MPLS_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\tif (p->tcfm_label != ACT_MPLS_LABEL_NOT_SET &&\n\t    nla_put_u32(skb, TCA_MPLS_LABEL, p->tcfm_label))\n\t\tgoto nla_put_failure;\n\n\tif (p->tcfm_tc != ACT_MPLS_TC_NOT_SET &&\n\t    nla_put_u8(skb, TCA_MPLS_TC, p->tcfm_tc))\n\t\tgoto nla_put_failure;\n\n\tif (p->tcfm_ttl && nla_put_u8(skb, TCA_MPLS_TTL, p->tcfm_ttl))\n\t\tgoto nla_put_failure;\n\n\tif (p->tcfm_bos != ACT_MPLS_BOS_NOT_SET &&\n\t    nla_put_u8(skb, TCA_MPLS_BOS, p->tcfm_bos))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be16(skb, TCA_MPLS_PROTO, p->tcfm_proto))\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &m->tcf_tm);\n\n\tif (nla_put_64bit(skb, TCA_MPLS_TM, sizeof(t), &t, TCA_MPLS_PAD))\n\t\tgoto nla_put_failure;\n\n\tspin_unlock_bh(&m->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&m->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -EMSGSIZE;\n}\n\nstatic int tcf_mpls_offload_act_setup(struct tc_action *act, void *entry_data,\n\t\t\t\t      u32 *index_inc, bool bind,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (bind) {\n\t\tstruct flow_action_entry *entry = entry_data;\n\n\t\tswitch (tcf_mpls_action(act)) {\n\t\tcase TCA_MPLS_ACT_PUSH:\n\t\t\tentry->id = FLOW_ACTION_MPLS_PUSH;\n\t\t\tentry->mpls_push.proto = tcf_mpls_proto(act);\n\t\t\tentry->mpls_push.label = tcf_mpls_label(act);\n\t\t\tentry->mpls_push.tc = tcf_mpls_tc(act);\n\t\t\tentry->mpls_push.bos = tcf_mpls_bos(act);\n\t\t\tentry->mpls_push.ttl = tcf_mpls_ttl(act);\n\t\t\tbreak;\n\t\tcase TCA_MPLS_ACT_POP:\n\t\t\tentry->id = FLOW_ACTION_MPLS_POP;\n\t\t\tentry->mpls_pop.proto = tcf_mpls_proto(act);\n\t\t\tbreak;\n\t\tcase TCA_MPLS_ACT_MODIFY:\n\t\t\tentry->id = FLOW_ACTION_MPLS_MANGLE;\n\t\t\tentry->mpls_mangle.label = tcf_mpls_label(act);\n\t\t\tentry->mpls_mangle.tc = tcf_mpls_tc(act);\n\t\t\tentry->mpls_mangle.bos = tcf_mpls_bos(act);\n\t\t\tentry->mpls_mangle.ttl = tcf_mpls_ttl(act);\n\t\t\tbreak;\n\t\tcase TCA_MPLS_ACT_DEC_TTL:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Offload not supported when \\\"dec_ttl\\\" option is used\");\n\t\t\treturn -EOPNOTSUPP;\n\t\tcase TCA_MPLS_ACT_MAC_PUSH:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Offload not supported when \\\"mac_push\\\" option is used\");\n\t\t\treturn -EOPNOTSUPP;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported MPLS mode offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t*index_inc = 1;\n\t} else {\n\t\tstruct flow_offload_action *fl_action = entry_data;\n\n\t\tswitch (tcf_mpls_action(act)) {\n\t\tcase TCA_MPLS_ACT_PUSH:\n\t\t\tfl_action->id = FLOW_ACTION_MPLS_PUSH;\n\t\t\tbreak;\n\t\tcase TCA_MPLS_ACT_POP:\n\t\t\tfl_action->id = FLOW_ACTION_MPLS_POP;\n\t\t\tbreak;\n\t\tcase TCA_MPLS_ACT_MODIFY:\n\t\t\tfl_action->id = FLOW_ACTION_MPLS_MANGLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct tc_action_ops act_mpls_ops = {\n\t.kind\t\t=\t\"mpls\",\n\t.id\t\t=\tTCA_ID_MPLS,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_mpls_act,\n\t.dump\t\t=\ttcf_mpls_dump,\n\t.init\t\t=\ttcf_mpls_init,\n\t.cleanup\t=\ttcf_mpls_cleanup,\n\t.offload_act_setup =\ttcf_mpls_offload_act_setup,\n\t.size\t\t=\tsizeof(struct tcf_mpls),\n};\n\nstatic __net_init int mpls_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_mpls_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_mpls_ops);\n}\n\nstatic void __net_exit mpls_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_mpls_ops.net_id);\n}\n\nstatic struct pernet_operations mpls_net_ops = {\n\t.init = mpls_init_net,\n\t.exit_batch = mpls_exit_net,\n\t.id   = &act_mpls_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nstatic int __init mpls_init_module(void)\n{\n\treturn tcf_register_action(&act_mpls_ops, &mpls_net_ops);\n}\n\nstatic void __exit mpls_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_mpls_ops, &mpls_net_ops);\n}\n\nmodule_init(mpls_init_module);\nmodule_exit(mpls_cleanup_module);\n\nMODULE_SOFTDEP(\"post: mpls_gso\");\nMODULE_AUTHOR(\"Netronome Systems <oss-drivers@netronome.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MPLS manipulation actions\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}