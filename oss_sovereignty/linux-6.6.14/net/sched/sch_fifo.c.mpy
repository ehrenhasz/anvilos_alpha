{
  "module_name": "sch_fifo.c",
  "hash_id": "e29acba15a86c8f79b799d029922e469e2a1d95b360f1fe39fcbf702ff56fc70",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_fifo.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n\n \n\nstatic int bfifo_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t struct sk_buff **to_free)\n{\n\tif (likely(sch->qstats.backlog + qdisc_pkt_len(skb) <= sch->limit))\n\t\treturn qdisc_enqueue_tail(skb, sch);\n\n\treturn qdisc_drop(skb, sch, to_free);\n}\n\nstatic int pfifo_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t struct sk_buff **to_free)\n{\n\tif (likely(sch->q.qlen < sch->limit))\n\t\treturn qdisc_enqueue_tail(skb, sch);\n\n\treturn qdisc_drop(skb, sch, to_free);\n}\n\nstatic int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t      struct sk_buff **to_free)\n{\n\tunsigned int prev_backlog;\n\n\tif (likely(sch->q.qlen < sch->limit))\n\t\treturn qdisc_enqueue_tail(skb, sch);\n\n\tprev_backlog = sch->qstats.backlog;\n\t \n\t__qdisc_queue_drop_head(sch, &sch->q, to_free);\n\tqdisc_qstats_drop(sch);\n\tqdisc_enqueue_tail(skb, sch);\n\n\tqdisc_tree_reduce_backlog(sch, 0, prev_backlog - sch->qstats.backlog);\n\treturn NET_XMIT_CN;\n}\n\nstatic void fifo_offload_init(struct Qdisc *sch)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct tc_fifo_qopt_offload qopt;\n\n\tif (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)\n\t\treturn;\n\n\tqopt.command = TC_FIFO_REPLACE;\n\tqopt.handle = sch->handle;\n\tqopt.parent = sch->parent;\n\tdev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_FIFO, &qopt);\n}\n\nstatic void fifo_offload_destroy(struct Qdisc *sch)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct tc_fifo_qopt_offload qopt;\n\n\tif (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)\n\t\treturn;\n\n\tqopt.command = TC_FIFO_DESTROY;\n\tqopt.handle = sch->handle;\n\tqopt.parent = sch->parent;\n\tdev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_FIFO, &qopt);\n}\n\nstatic int fifo_offload_dump(struct Qdisc *sch)\n{\n\tstruct tc_fifo_qopt_offload qopt;\n\n\tqopt.command = TC_FIFO_STATS;\n\tqopt.handle = sch->handle;\n\tqopt.parent = sch->parent;\n\tqopt.stats.bstats = &sch->bstats;\n\tqopt.stats.qstats = &sch->qstats;\n\n\treturn qdisc_offload_dump_helper(sch, TC_SETUP_QDISC_FIFO, &qopt);\n}\n\nstatic int __fifo_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tbool bypass;\n\tbool is_bfifo = sch->ops == &bfifo_qdisc_ops;\n\n\tif (opt == NULL) {\n\t\tu32 limit = qdisc_dev(sch)->tx_queue_len;\n\n\t\tif (is_bfifo)\n\t\t\tlimit *= psched_mtu(qdisc_dev(sch));\n\n\t\tsch->limit = limit;\n\t} else {\n\t\tstruct tc_fifo_qopt *ctl = nla_data(opt);\n\n\t\tif (nla_len(opt) < sizeof(*ctl))\n\t\t\treturn -EINVAL;\n\n\t\tsch->limit = ctl->limit;\n\t}\n\n\tif (is_bfifo)\n\t\tbypass = sch->limit >= psched_mtu(qdisc_dev(sch));\n\telse\n\t\tbypass = sch->limit >= 1;\n\n\tif (bypass)\n\t\tsch->flags |= TCQ_F_CAN_BYPASS;\n\telse\n\t\tsch->flags &= ~TCQ_F_CAN_BYPASS;\n\n\treturn 0;\n}\n\nstatic int fifo_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = __fifo_init(sch, opt, extack);\n\tif (err)\n\t\treturn err;\n\n\tfifo_offload_init(sch);\n\treturn 0;\n}\n\nstatic int fifo_hd_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __fifo_init(sch, opt, extack);\n}\n\nstatic void fifo_destroy(struct Qdisc *sch)\n{\n\tfifo_offload_destroy(sch);\n}\n\nstatic int __fifo_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct tc_fifo_qopt opt = { .limit = sch->limit };\n\n\tif (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\treturn skb->len;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int fifo_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tint err;\n\n\terr = fifo_offload_dump(sch);\n\tif (err)\n\t\treturn err;\n\n\treturn __fifo_dump(sch, skb);\n}\n\nstatic int fifo_hd_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\treturn __fifo_dump(sch, skb);\n}\n\nstruct Qdisc_ops pfifo_qdisc_ops __read_mostly = {\n\t.id\t\t=\t\"pfifo\",\n\t.priv_size\t=\t0,\n\t.enqueue\t=\tpfifo_enqueue,\n\t.dequeue\t=\tqdisc_dequeue_head,\n\t.peek\t\t=\tqdisc_peek_head,\n\t.init\t\t=\tfifo_init,\n\t.destroy\t=\tfifo_destroy,\n\t.reset\t\t=\tqdisc_reset_queue,\n\t.change\t\t=\tfifo_init,\n\t.dump\t\t=\tfifo_dump,\n\t.owner\t\t=\tTHIS_MODULE,\n};\nEXPORT_SYMBOL(pfifo_qdisc_ops);\n\nstruct Qdisc_ops bfifo_qdisc_ops __read_mostly = {\n\t.id\t\t=\t\"bfifo\",\n\t.priv_size\t=\t0,\n\t.enqueue\t=\tbfifo_enqueue,\n\t.dequeue\t=\tqdisc_dequeue_head,\n\t.peek\t\t=\tqdisc_peek_head,\n\t.init\t\t=\tfifo_init,\n\t.destroy\t=\tfifo_destroy,\n\t.reset\t\t=\tqdisc_reset_queue,\n\t.change\t\t=\tfifo_init,\n\t.dump\t\t=\tfifo_dump,\n\t.owner\t\t=\tTHIS_MODULE,\n};\nEXPORT_SYMBOL(bfifo_qdisc_ops);\n\nstruct Qdisc_ops pfifo_head_drop_qdisc_ops __read_mostly = {\n\t.id\t\t=\t\"pfifo_head_drop\",\n\t.priv_size\t=\t0,\n\t.enqueue\t=\tpfifo_tail_enqueue,\n\t.dequeue\t=\tqdisc_dequeue_head,\n\t.peek\t\t=\tqdisc_peek_head,\n\t.init\t\t=\tfifo_hd_init,\n\t.reset\t\t=\tqdisc_reset_queue,\n\t.change\t\t=\tfifo_hd_init,\n\t.dump\t\t=\tfifo_hd_dump,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\n \nint fifo_set_limit(struct Qdisc *q, unsigned int limit)\n{\n\tstruct nlattr *nla;\n\tint ret = -ENOMEM;\n\n\t \n\tif (strncmp(q->ops->id + 1, \"fifo\", 4) != 0)\n\t\treturn 0;\n\n\tif (!q->ops->change)\n\t\treturn 0;\n\n\tnla = kmalloc(nla_attr_size(sizeof(struct tc_fifo_qopt)), GFP_KERNEL);\n\tif (nla) {\n\t\tnla->nla_type = RTM_NEWQDISC;\n\t\tnla->nla_len = nla_attr_size(sizeof(struct tc_fifo_qopt));\n\t\t((struct tc_fifo_qopt *)nla_data(nla))->limit = limit;\n\n\t\tret = q->ops->change(q, nla, NULL);\n\t\tkfree(nla);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(fifo_set_limit);\n\nstruct Qdisc *fifo_create_dflt(struct Qdisc *sch, struct Qdisc_ops *ops,\n\t\t\t       unsigned int limit,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct Qdisc *q;\n\tint err = -ENOMEM;\n\n\tq = qdisc_create_dflt(sch->dev_queue, ops, TC_H_MAKE(sch->handle, 1),\n\t\t\t      extack);\n\tif (q) {\n\t\terr = fifo_set_limit(q, limit);\n\t\tif (err < 0) {\n\t\t\tqdisc_put(q);\n\t\t\tq = NULL;\n\t\t}\n\t}\n\n\treturn q ? : ERR_PTR(err);\n}\nEXPORT_SYMBOL(fifo_create_dflt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}