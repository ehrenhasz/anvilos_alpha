{
  "module_name": "sch_mq.c",
  "hash_id": "a3b568dc201febbdb4bed6a186ae4985239cd81f121779a86ea65435d46cc807",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_mq.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/pkt_cls.h>\n#include <net/pkt_sched.h>\n#include <net/sch_generic.h>\n\nstruct mq_sched {\n\tstruct Qdisc\t\t**qdiscs;\n};\n\nstatic int mq_offload(struct Qdisc *sch, enum tc_mq_command cmd)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct tc_mq_qopt_offload opt = {\n\t\t.command = cmd,\n\t\t.handle = sch->handle,\n\t};\n\n\tif (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_MQ, &opt);\n}\n\nstatic int mq_offload_stats(struct Qdisc *sch)\n{\n\tstruct tc_mq_qopt_offload opt = {\n\t\t.command = TC_MQ_STATS,\n\t\t.handle = sch->handle,\n\t\t.stats = {\n\t\t\t.bstats = &sch->bstats,\n\t\t\t.qstats = &sch->qstats,\n\t\t},\n\t};\n\n\treturn qdisc_offload_dump_helper(sch, TC_SETUP_QDISC_MQ, &opt);\n}\n\nstatic void mq_destroy(struct Qdisc *sch)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct mq_sched *priv = qdisc_priv(sch);\n\tunsigned int ntx;\n\n\tmq_offload(sch, TC_MQ_DESTROY);\n\n\tif (!priv->qdiscs)\n\t\treturn;\n\tfor (ntx = 0; ntx < dev->num_tx_queues && priv->qdiscs[ntx]; ntx++)\n\t\tqdisc_put(priv->qdiscs[ntx]);\n\tkfree(priv->qdiscs);\n}\n\nstatic int mq_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct mq_sched *priv = qdisc_priv(sch);\n\tstruct netdev_queue *dev_queue;\n\tstruct Qdisc *qdisc;\n\tunsigned int ntx;\n\n\tif (sch->parent != TC_H_ROOT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!netif_is_multiqueue(dev))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tpriv->qdiscs = kcalloc(dev->num_tx_queues, sizeof(priv->qdiscs[0]),\n\t\t\t       GFP_KERNEL);\n\tif (!priv->qdiscs)\n\t\treturn -ENOMEM;\n\n\tfor (ntx = 0; ntx < dev->num_tx_queues; ntx++) {\n\t\tdev_queue = netdev_get_tx_queue(dev, ntx);\n\t\tqdisc = qdisc_create_dflt(dev_queue, get_default_qdisc_ops(dev, ntx),\n\t\t\t\t\t  TC_H_MAKE(TC_H_MAJ(sch->handle),\n\t\t\t\t\t\t    TC_H_MIN(ntx + 1)),\n\t\t\t\t\t  extack);\n\t\tif (!qdisc)\n\t\t\treturn -ENOMEM;\n\t\tpriv->qdiscs[ntx] = qdisc;\n\t\tqdisc->flags |= TCQ_F_ONETXQUEUE | TCQ_F_NOPARENT;\n\t}\n\n\tsch->flags |= TCQ_F_MQROOT;\n\n\tmq_offload(sch, TC_MQ_CREATE);\n\treturn 0;\n}\n\nstatic void mq_attach(struct Qdisc *sch)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct mq_sched *priv = qdisc_priv(sch);\n\tstruct Qdisc *qdisc, *old;\n\tunsigned int ntx;\n\n\tfor (ntx = 0; ntx < dev->num_tx_queues; ntx++) {\n\t\tqdisc = priv->qdiscs[ntx];\n\t\told = dev_graft_qdisc(qdisc->dev_queue, qdisc);\n\t\tif (old)\n\t\t\tqdisc_put(old);\n#ifdef CONFIG_NET_SCHED\n\t\tif (ntx < dev->real_num_tx_queues)\n\t\t\tqdisc_hash_add(qdisc, false);\n#endif\n\n\t}\n\tkfree(priv->qdiscs);\n\tpriv->qdiscs = NULL;\n}\n\nstatic int mq_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct Qdisc *qdisc;\n\tunsigned int ntx;\n\n\tsch->q.qlen = 0;\n\tgnet_stats_basic_sync_init(&sch->bstats);\n\tmemset(&sch->qstats, 0, sizeof(sch->qstats));\n\n\t \n\tfor (ntx = 0; ntx < dev->num_tx_queues; ntx++) {\n\t\tqdisc = rtnl_dereference(netdev_get_tx_queue(dev, ntx)->qdisc_sleeping);\n\t\tspin_lock_bh(qdisc_lock(qdisc));\n\n\t\tgnet_stats_add_basic(&sch->bstats, qdisc->cpu_bstats,\n\t\t\t\t     &qdisc->bstats, false);\n\t\tgnet_stats_add_queue(&sch->qstats, qdisc->cpu_qstats,\n\t\t\t\t     &qdisc->qstats);\n\t\tsch->q.qlen += qdisc_qlen(qdisc);\n\n\t\tspin_unlock_bh(qdisc_lock(qdisc));\n\t}\n\n\treturn mq_offload_stats(sch);\n}\n\nstatic struct netdev_queue *mq_queue_get(struct Qdisc *sch, unsigned long cl)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tunsigned long ntx = cl - 1;\n\n\tif (ntx >= dev->num_tx_queues)\n\t\treturn NULL;\n\treturn netdev_get_tx_queue(dev, ntx);\n}\n\nstatic struct netdev_queue *mq_select_queue(struct Qdisc *sch,\n\t\t\t\t\t    struct tcmsg *tcm)\n{\n\treturn mq_queue_get(sch, TC_H_MIN(tcm->tcm_parent));\n}\n\nstatic int mq_graft(struct Qdisc *sch, unsigned long cl, struct Qdisc *new,\n\t\t    struct Qdisc **old, struct netlink_ext_ack *extack)\n{\n\tstruct netdev_queue *dev_queue = mq_queue_get(sch, cl);\n\tstruct tc_mq_qopt_offload graft_offload;\n\tstruct net_device *dev = qdisc_dev(sch);\n\n\tif (dev->flags & IFF_UP)\n\t\tdev_deactivate(dev);\n\n\t*old = dev_graft_qdisc(dev_queue, new);\n\tif (new)\n\t\tnew->flags |= TCQ_F_ONETXQUEUE | TCQ_F_NOPARENT;\n\tif (dev->flags & IFF_UP)\n\t\tdev_activate(dev);\n\n\tgraft_offload.handle = sch->handle;\n\tgraft_offload.graft_params.queue = cl - 1;\n\tgraft_offload.graft_params.child_handle = new ? new->handle : 0;\n\tgraft_offload.command = TC_MQ_GRAFT;\n\n\tqdisc_offload_graft_helper(qdisc_dev(sch), sch, new, *old,\n\t\t\t\t   TC_SETUP_QDISC_MQ, &graft_offload, extack);\n\treturn 0;\n}\n\nstatic struct Qdisc *mq_leaf(struct Qdisc *sch, unsigned long cl)\n{\n\tstruct netdev_queue *dev_queue = mq_queue_get(sch, cl);\n\n\treturn rtnl_dereference(dev_queue->qdisc_sleeping);\n}\n\nstatic unsigned long mq_find(struct Qdisc *sch, u32 classid)\n{\n\tunsigned int ntx = TC_H_MIN(classid);\n\n\tif (!mq_queue_get(sch, ntx))\n\t\treturn 0;\n\treturn ntx;\n}\n\nstatic int mq_dump_class(struct Qdisc *sch, unsigned long cl,\n\t\t\t struct sk_buff *skb, struct tcmsg *tcm)\n{\n\tstruct netdev_queue *dev_queue = mq_queue_get(sch, cl);\n\n\ttcm->tcm_parent = TC_H_ROOT;\n\ttcm->tcm_handle |= TC_H_MIN(cl);\n\ttcm->tcm_info = rtnl_dereference(dev_queue->qdisc_sleeping)->handle;\n\treturn 0;\n}\n\nstatic int mq_dump_class_stats(struct Qdisc *sch, unsigned long cl,\n\t\t\t       struct gnet_dump *d)\n{\n\tstruct netdev_queue *dev_queue = mq_queue_get(sch, cl);\n\n\tsch = rtnl_dereference(dev_queue->qdisc_sleeping);\n\tif (gnet_stats_copy_basic(d, sch->cpu_bstats, &sch->bstats, true) < 0 ||\n\t    qdisc_qstats_copy(d, sch) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void mq_walk(struct Qdisc *sch, struct qdisc_walker *arg)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tunsigned int ntx;\n\n\tif (arg->stop)\n\t\treturn;\n\n\targ->count = arg->skip;\n\tfor (ntx = arg->skip; ntx < dev->num_tx_queues; ntx++) {\n\t\tif (!tc_qdisc_stats_dump(sch, ntx + 1, arg))\n\t\t\tbreak;\n\t}\n}\n\nstatic const struct Qdisc_class_ops mq_class_ops = {\n\t.select_queue\t= mq_select_queue,\n\t.graft\t\t= mq_graft,\n\t.leaf\t\t= mq_leaf,\n\t.find\t\t= mq_find,\n\t.walk\t\t= mq_walk,\n\t.dump\t\t= mq_dump_class,\n\t.dump_stats\t= mq_dump_class_stats,\n};\n\nstruct Qdisc_ops mq_qdisc_ops __read_mostly = {\n\t.cl_ops\t\t= &mq_class_ops,\n\t.id\t\t= \"mq\",\n\t.priv_size\t= sizeof(struct mq_sched),\n\t.init\t\t= mq_init,\n\t.destroy\t= mq_destroy,\n\t.attach\t\t= mq_attach,\n\t.change_real_num_tx = mq_change_real_num_tx,\n\t.dump\t\t= mq_dump,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}