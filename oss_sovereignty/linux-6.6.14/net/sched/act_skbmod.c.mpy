{
  "module_name": "act_skbmod.c",
  "hash_id": "aee0c85963c0424df10eb469e50b1188e44441903f1baabb4bcd49c8ca4f9e40",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_skbmod.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <net/inet_ecn.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <net/tc_wrapper.h>\n\n#include <linux/tc_act/tc_skbmod.h>\n#include <net/tc_act/tc_skbmod.h>\n\nstatic struct tc_action_ops act_skbmod_ops;\n\nTC_INDIRECT_SCOPE int tcf_skbmod_act(struct sk_buff *skb,\n\t\t\t\t     const struct tc_action *a,\n\t\t\t\t     struct tcf_result *res)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\tint action, max_edit_len, err;\n\tstruct tcf_skbmod_params *p;\n\tu64 flags;\n\n\ttcf_lastuse_update(&d->tcf_tm);\n\tbstats_update(this_cpu_ptr(d->common.cpu_bstats), skb);\n\n\taction = READ_ONCE(d->tcf_action);\n\tif (unlikely(action == TC_ACT_SHOT))\n\t\tgoto drop;\n\n\tmax_edit_len = skb_mac_header_len(skb);\n\tp = rcu_dereference_bh(d->skbmod_p);\n\tflags = p->flags;\n\n\t \n\tif (flags == SKBMOD_F_ECN) {\n\t\tswitch (skb_protocol(skb, true)) {\n\t\tcase cpu_to_be16(ETH_P_IP):\n\t\tcase cpu_to_be16(ETH_P_IPV6):\n\t\t\tmax_edit_len += skb_network_header_len(skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t} else if (!skb->dev || skb->dev->type != ARPHRD_ETHER) {\n\t\tgoto out;\n\t}\n\n\terr = skb_ensure_writable(skb, max_edit_len);\n\tif (unlikely(err))  \n\t\tgoto drop;\n\n\tif (flags & SKBMOD_F_DMAC)\n\t\tether_addr_copy(eth_hdr(skb)->h_dest, p->eth_dst);\n\tif (flags & SKBMOD_F_SMAC)\n\t\tether_addr_copy(eth_hdr(skb)->h_source, p->eth_src);\n\tif (flags & SKBMOD_F_ETYPE)\n\t\teth_hdr(skb)->h_proto = p->eth_type;\n\n\tif (flags & SKBMOD_F_SWAPMAC) {\n\t\tu16 tmpaddr[ETH_ALEN / 2];  \n\t\t \n\t\tether_addr_copy((u8 *)tmpaddr, eth_hdr(skb)->h_dest);\n\t\tether_addr_copy(eth_hdr(skb)->h_dest, eth_hdr(skb)->h_source);\n\t\tether_addr_copy(eth_hdr(skb)->h_source, (u8 *)tmpaddr);\n\t}\n\n\tif (flags & SKBMOD_F_ECN)\n\t\tINET_ECN_set_ce(skb);\n\nout:\n\treturn action;\n\ndrop:\n\tqstats_overlimit_inc(this_cpu_ptr(d->common.cpu_qstats));\n\treturn TC_ACT_SHOT;\n}\n\nstatic const struct nla_policy skbmod_policy[TCA_SKBMOD_MAX + 1] = {\n\t[TCA_SKBMOD_PARMS]\t\t= { .len = sizeof(struct tc_skbmod) },\n\t[TCA_SKBMOD_DMAC]\t\t= { .len = ETH_ALEN },\n\t[TCA_SKBMOD_SMAC]\t\t= { .len = ETH_ALEN },\n\t[TCA_SKBMOD_ETYPE]\t\t= { .type = NLA_U16 },\n};\n\nstatic int tcf_skbmod_init(struct net *net, struct nlattr *nla,\n\t\t\t   struct nlattr *est, struct tc_action **a,\n\t\t\t   struct tcf_proto *tp, u32 flags,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_skbmod_ops.net_id);\n\tbool ovr = flags & TCA_ACT_FLAGS_REPLACE;\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_SKBMOD_MAX + 1];\n\tstruct tcf_skbmod_params *p, *p_old;\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tc_skbmod *parm;\n\tu32 lflags = 0, index;\n\tstruct tcf_skbmod *d;\n\tbool exists = false;\n\tu8 *daddr = NULL;\n\tu8 *saddr = NULL;\n\tu16 eth_type = 0;\n\tint ret = 0, err;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_SKBMOD_MAX, nla,\n\t\t\t\t\t  skbmod_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_SKBMOD_PARMS])\n\t\treturn -EINVAL;\n\n\tif (tb[TCA_SKBMOD_DMAC]) {\n\t\tdaddr = nla_data(tb[TCA_SKBMOD_DMAC]);\n\t\tlflags |= SKBMOD_F_DMAC;\n\t}\n\n\tif (tb[TCA_SKBMOD_SMAC]) {\n\t\tsaddr = nla_data(tb[TCA_SKBMOD_SMAC]);\n\t\tlflags |= SKBMOD_F_SMAC;\n\t}\n\n\tif (tb[TCA_SKBMOD_ETYPE]) {\n\t\teth_type = nla_get_u16(tb[TCA_SKBMOD_ETYPE]);\n\t\tlflags |= SKBMOD_F_ETYPE;\n\t}\n\n\tparm = nla_data(tb[TCA_SKBMOD_PARMS]);\n\tindex = parm->index;\n\tif (parm->flags & SKBMOD_F_SWAPMAC)\n\t\tlflags = SKBMOD_F_SWAPMAC;\n\tif (parm->flags & SKBMOD_F_ECN)\n\t\tlflags = SKBMOD_F_ECN;\n\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0)\n\t\treturn err;\n\texists = err;\n\tif (exists && bind)\n\t\treturn 0;\n\n\tif (!lflags) {\n\t\tif (exists)\n\t\t\ttcf_idr_release(*a, bind);\n\t\telse\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!exists) {\n\t\tret = tcf_idr_create(tn, index, est, a,\n\t\t\t\t     &act_skbmod_ops, bind, true, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ACT_P_CREATED;\n\t} else if (!ovr) {\n\t\ttcf_idr_release(*a, bind);\n\t\treturn -EEXIST;\n\t}\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\td = to_skbmod(*a);\n\n\tp = kzalloc(sizeof(struct tcf_skbmod_params), GFP_KERNEL);\n\tif (unlikely(!p)) {\n\t\terr = -ENOMEM;\n\t\tgoto put_chain;\n\t}\n\n\tp->flags = lflags;\n\n\tif (ovr)\n\t\tspin_lock_bh(&d->tcf_lock);\n\t \n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\tp_old = rcu_dereference_protected(d->skbmod_p, 1);\n\n\tif (lflags & SKBMOD_F_DMAC)\n\t\tether_addr_copy(p->eth_dst, daddr);\n\tif (lflags & SKBMOD_F_SMAC)\n\t\tether_addr_copy(p->eth_src, saddr);\n\tif (lflags & SKBMOD_F_ETYPE)\n\t\tp->eth_type = htons(eth_type);\n\n\trcu_assign_pointer(d->skbmod_p, p);\n\tif (ovr)\n\t\tspin_unlock_bh(&d->tcf_lock);\n\n\tif (p_old)\n\t\tkfree_rcu(p_old, rcu);\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\n\treturn ret;\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic void tcf_skbmod_cleanup(struct tc_action *a)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\tstruct tcf_skbmod_params  *p;\n\n\tp = rcu_dereference_protected(d->skbmod_p, 1);\n\tif (p)\n\t\tkfree_rcu(p, rcu);\n}\n\nstatic int tcf_skbmod_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbmod_params  *p;\n\tstruct tc_skbmod opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n\t\t.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&d->tcf_lock);\n\topt.action = d->tcf_action;\n\tp = rcu_dereference_protected(d->skbmod_p,\n\t\t\t\t      lockdep_is_held(&d->tcf_lock));\n\topt.flags  = p->flags;\n\tif (nla_put(skb, TCA_SKBMOD_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_DMAC) &&\n\t    nla_put(skb, TCA_SKBMOD_DMAC, ETH_ALEN, p->eth_dst))\n\t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_SMAC) &&\n\t    nla_put(skb, TCA_SKBMOD_SMAC, ETH_ALEN, p->eth_src))\n\t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_ETYPE) &&\n\t    nla_put_u16(skb, TCA_SKBMOD_ETYPE, ntohs(p->eth_type)))\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &d->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_SKBMOD_TM, sizeof(t), &t, TCA_SKBMOD_PAD))\n\t\tgoto nla_put_failure;\n\n\tspin_unlock_bh(&d->tcf_lock);\n\treturn skb->len;\nnla_put_failure:\n\tspin_unlock_bh(&d->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic struct tc_action_ops act_skbmod_ops = {\n\t.kind\t\t=\t\"skbmod\",\n\t.id\t\t=\tTCA_ACT_SKBMOD,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_skbmod_act,\n\t.dump\t\t=\ttcf_skbmod_dump,\n\t.init\t\t=\ttcf_skbmod_init,\n\t.cleanup\t=\ttcf_skbmod_cleanup,\n\t.size\t\t=\tsizeof(struct tcf_skbmod),\n};\n\nstatic __net_init int skbmod_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_skbmod_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_skbmod_ops);\n}\n\nstatic void __net_exit skbmod_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_skbmod_ops.net_id);\n}\n\nstatic struct pernet_operations skbmod_net_ops = {\n\t.init = skbmod_init_net,\n\t.exit_batch = skbmod_exit_net,\n\t.id   = &act_skbmod_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nMODULE_AUTHOR(\"Jamal Hadi Salim, <jhs@mojatatu.com>\");\nMODULE_DESCRIPTION(\"SKB data mod-ing\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init skbmod_init_module(void)\n{\n\treturn tcf_register_action(&act_skbmod_ops, &skbmod_net_ops);\n}\n\nstatic void __exit skbmod_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_skbmod_ops, &skbmod_net_ops);\n}\n\nmodule_init(skbmod_init_module);\nmodule_exit(skbmod_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}