{
  "module_name": "act_csum.c",
  "hash_id": "9cee63c2692a1a5121e043fb99cb505c0f048ad9e223e432d26409763a1b262b",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_csum.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n\n#include <linux/netlink.h>\n#include <net/netlink.h>\n#include <linux/rtnetlink.h>\n\n#include <linux/skbuff.h>\n\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/igmp.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/ip6_checksum.h>\n#include <net/sctp/checksum.h>\n\n#include <net/act_api.h>\n#include <net/pkt_cls.h>\n\n#include <linux/tc_act/tc_csum.h>\n#include <net/tc_act/tc_csum.h>\n#include <net/tc_wrapper.h>\n\nstatic const struct nla_policy csum_policy[TCA_CSUM_MAX + 1] = {\n\t[TCA_CSUM_PARMS] = { .len = sizeof(struct tc_csum), },\n};\n\nstatic struct tc_action_ops act_csum_ops;\n\nstatic int tcf_csum_init(struct net *net, struct nlattr *nla,\n\t\t\t struct nlattr *est, struct tc_action **a,\n\t\t\t struct tcf_proto *tp,\n\t\t\t u32 flags, struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_csum_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct tcf_csum_params *params_new;\n\tstruct nlattr *tb[TCA_CSUM_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tc_csum *parm;\n\tstruct tcf_csum *p;\n\tint ret = 0, err;\n\tu32 index;\n\n\tif (nla == NULL)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_CSUM_MAX, nla, csum_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_CSUM_PARMS] == NULL)\n\t\treturn -EINVAL;\n\tparm = nla_data(tb[TCA_CSUM_PARMS]);\n\tindex = parm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (!err) {\n\t\tret = tcf_idr_create_from_flags(tn, index, est, a,\n\t\t\t\t\t\t&act_csum_ops, bind, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ACT_P_CREATED;\n\t} else if (err > 0) {\n\t\tif (bind) \n\t\t\treturn 0;\n\t\tif (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\t\ttcf_idr_release(*a, bind);\n\t\t\treturn -EEXIST;\n\t\t}\n\t} else {\n\t\treturn err;\n\t}\n\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\tp = to_tcf_csum(*a);\n\n\tparams_new = kzalloc(sizeof(*params_new), GFP_KERNEL);\n\tif (unlikely(!params_new)) {\n\t\terr = -ENOMEM;\n\t\tgoto put_chain;\n\t}\n\tparams_new->update_flags = parm->update_flags;\n\n\tspin_lock_bh(&p->tcf_lock);\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\tparams_new = rcu_replace_pointer(p->params, params_new,\n\t\t\t\t\t lockdep_is_held(&p->tcf_lock));\n\tspin_unlock_bh(&p->tcf_lock);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\tif (params_new)\n\t\tkfree_rcu(params_new, rcu);\n\n\treturn ret;\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\n \nstatic void *tcf_csum_skb_nextlayer(struct sk_buff *skb,\n\t\t\t\t    unsigned int ihl, unsigned int ipl,\n\t\t\t\t    unsigned int jhl)\n{\n\tint ntkoff = skb_network_offset(skb);\n\tint hl = ihl + jhl;\n\n\tif (!pskb_may_pull(skb, ipl + ntkoff) || (ipl < hl) ||\n\t    skb_try_make_writable(skb, hl + ntkoff))\n\t\treturn NULL;\n\telse\n\t\treturn (void *)(skb_network_header(skb) + ihl);\n}\n\nstatic int tcf_csum_ipv4_icmp(struct sk_buff *skb, unsigned int ihl,\n\t\t\t      unsigned int ipl)\n{\n\tstruct icmphdr *icmph;\n\n\ticmph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*icmph));\n\tif (icmph == NULL)\n\t\treturn 0;\n\n\ticmph->checksum = 0;\n\tskb->csum = csum_partial(icmph, ipl - ihl, 0);\n\ticmph->checksum = csum_fold(skb->csum);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\treturn 1;\n}\n\nstatic int tcf_csum_ipv4_igmp(struct sk_buff *skb,\n\t\t\t      unsigned int ihl, unsigned int ipl)\n{\n\tstruct igmphdr *igmph;\n\n\tigmph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*igmph));\n\tif (igmph == NULL)\n\t\treturn 0;\n\n\tigmph->csum = 0;\n\tskb->csum = csum_partial(igmph, ipl - ihl, 0);\n\tigmph->csum = csum_fold(skb->csum);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\treturn 1;\n}\n\nstatic int tcf_csum_ipv6_icmp(struct sk_buff *skb, unsigned int ihl,\n\t\t\t      unsigned int ipl)\n{\n\tstruct icmp6hdr *icmp6h;\n\tconst struct ipv6hdr *ip6h;\n\n\ticmp6h = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*icmp6h));\n\tif (icmp6h == NULL)\n\t\treturn 0;\n\n\tip6h = ipv6_hdr(skb);\n\ticmp6h->icmp6_cksum = 0;\n\tskb->csum = csum_partial(icmp6h, ipl - ihl, 0);\n\ticmp6h->icmp6_cksum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\n\t\t\t\t\t      ipl - ihl, IPPROTO_ICMPV6,\n\t\t\t\t\t      skb->csum);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\treturn 1;\n}\n\nstatic int tcf_csum_ipv4_tcp(struct sk_buff *skb, unsigned int ihl,\n\t\t\t     unsigned int ipl)\n{\n\tstruct tcphdr *tcph;\n\tconst struct iphdr *iph;\n\n\tif (skb_is_gso(skb) && skb_shinfo(skb)->gso_type & SKB_GSO_TCPV4)\n\t\treturn 1;\n\n\ttcph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*tcph));\n\tif (tcph == NULL)\n\t\treturn 0;\n\n\tiph = ip_hdr(skb);\n\ttcph->check = 0;\n\tskb->csum = csum_partial(tcph, ipl - ihl, 0);\n\ttcph->check = tcp_v4_check(ipl - ihl,\n\t\t\t\t   iph->saddr, iph->daddr, skb->csum);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\treturn 1;\n}\n\nstatic int tcf_csum_ipv6_tcp(struct sk_buff *skb, unsigned int ihl,\n\t\t\t     unsigned int ipl)\n{\n\tstruct tcphdr *tcph;\n\tconst struct ipv6hdr *ip6h;\n\n\tif (skb_is_gso(skb) && skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6)\n\t\treturn 1;\n\n\ttcph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*tcph));\n\tif (tcph == NULL)\n\t\treturn 0;\n\n\tip6h = ipv6_hdr(skb);\n\ttcph->check = 0;\n\tskb->csum = csum_partial(tcph, ipl - ihl, 0);\n\ttcph->check = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\n\t\t\t\t      ipl - ihl, IPPROTO_TCP,\n\t\t\t\t      skb->csum);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\treturn 1;\n}\n\nstatic int tcf_csum_ipv4_udp(struct sk_buff *skb, unsigned int ihl,\n\t\t\t     unsigned int ipl, int udplite)\n{\n\tstruct udphdr *udph;\n\tconst struct iphdr *iph;\n\tu16 ul;\n\n\tif (skb_is_gso(skb) && skb_shinfo(skb)->gso_type & SKB_GSO_UDP)\n\t\treturn 1;\n\n\t \n\n\tudph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*udph));\n\tif (udph == NULL)\n\t\treturn 0;\n\n\tiph = ip_hdr(skb);\n\tul = ntohs(udph->len);\n\n\tif (udplite || udph->check) {\n\n\t\tudph->check = 0;\n\n\t\tif (udplite) {\n\t\t\tif (ul == 0)\n\t\t\t\tskb->csum = csum_partial(udph, ipl - ihl, 0);\n\t\t\telse if ((ul >= sizeof(*udph)) && (ul <= ipl - ihl))\n\t\t\t\tskb->csum = csum_partial(udph, ul, 0);\n\t\t\telse\n\t\t\t\tgoto ignore_obscure_skb;\n\t\t} else {\n\t\t\tif (ul != ipl - ihl)\n\t\t\t\tgoto ignore_obscure_skb;\n\n\t\t\tskb->csum = csum_partial(udph, ul, 0);\n\t\t}\n\n\t\tudph->check = csum_tcpudp_magic(iph->saddr, iph->daddr,\n\t\t\t\t\t\tul, iph->protocol,\n\t\t\t\t\t\tskb->csum);\n\n\t\tif (!udph->check)\n\t\t\tudph->check = CSUM_MANGLED_0;\n\t}\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\nignore_obscure_skb:\n\treturn 1;\n}\n\nstatic int tcf_csum_ipv6_udp(struct sk_buff *skb, unsigned int ihl,\n\t\t\t     unsigned int ipl, int udplite)\n{\n\tstruct udphdr *udph;\n\tconst struct ipv6hdr *ip6h;\n\tu16 ul;\n\n\tif (skb_is_gso(skb) && skb_shinfo(skb)->gso_type & SKB_GSO_UDP)\n\t\treturn 1;\n\n\t \n\n\tudph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*udph));\n\tif (udph == NULL)\n\t\treturn 0;\n\n\tip6h = ipv6_hdr(skb);\n\tul = ntohs(udph->len);\n\n\tudph->check = 0;\n\n\tif (udplite) {\n\t\tif (ul == 0)\n\t\t\tskb->csum = csum_partial(udph, ipl - ihl, 0);\n\n\t\telse if ((ul >= sizeof(*udph)) && (ul <= ipl - ihl))\n\t\t\tskb->csum = csum_partial(udph, ul, 0);\n\n\t\telse\n\t\t\tgoto ignore_obscure_skb;\n\t} else {\n\t\tif (ul != ipl - ihl)\n\t\t\tgoto ignore_obscure_skb;\n\n\t\tskb->csum = csum_partial(udph, ul, 0);\n\t}\n\n\tudph->check = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr, ul,\n\t\t\t\t      udplite ? IPPROTO_UDPLITE : IPPROTO_UDP,\n\t\t\t\t      skb->csum);\n\n\tif (!udph->check)\n\t\tudph->check = CSUM_MANGLED_0;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\nignore_obscure_skb:\n\treturn 1;\n}\n\nstatic int tcf_csum_sctp(struct sk_buff *skb, unsigned int ihl,\n\t\t\t unsigned int ipl)\n{\n\tstruct sctphdr *sctph;\n\n\tif (skb_is_gso(skb) && skb_is_gso_sctp(skb))\n\t\treturn 1;\n\n\tsctph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*sctph));\n\tif (!sctph)\n\t\treturn 0;\n\n\tsctph->checksum = sctp_compute_cksum(skb,\n\t\t\t\t\t     skb_network_offset(skb) + ihl);\n\tskb_reset_csum_not_inet(skb);\n\n\treturn 1;\n}\n\nstatic int tcf_csum_ipv4(struct sk_buff *skb, u32 update_flags)\n{\n\tconst struct iphdr *iph;\n\tint ntkoff;\n\n\tntkoff = skb_network_offset(skb);\n\n\tif (!pskb_may_pull(skb, sizeof(*iph) + ntkoff))\n\t\tgoto fail;\n\n\tiph = ip_hdr(skb);\n\n\tswitch (iph->frag_off & htons(IP_OFFSET) ? 0 : iph->protocol) {\n\tcase IPPROTO_ICMP:\n\t\tif (update_flags & TCA_CSUM_UPDATE_FLAG_ICMP)\n\t\t\tif (!tcf_csum_ipv4_icmp(skb, iph->ihl * 4,\n\t\t\t\t\t\tntohs(iph->tot_len)))\n\t\t\t\tgoto fail;\n\t\tbreak;\n\tcase IPPROTO_IGMP:\n\t\tif (update_flags & TCA_CSUM_UPDATE_FLAG_IGMP)\n\t\t\tif (!tcf_csum_ipv4_igmp(skb, iph->ihl * 4,\n\t\t\t\t\t\tntohs(iph->tot_len)))\n\t\t\t\tgoto fail;\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tif (update_flags & TCA_CSUM_UPDATE_FLAG_TCP)\n\t\t\tif (!tcf_csum_ipv4_tcp(skb, iph->ihl * 4,\n\t\t\t\t\t       ntohs(iph->tot_len)))\n\t\t\t\tgoto fail;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tif (update_flags & TCA_CSUM_UPDATE_FLAG_UDP)\n\t\t\tif (!tcf_csum_ipv4_udp(skb, iph->ihl * 4,\n\t\t\t\t\t       ntohs(iph->tot_len), 0))\n\t\t\t\tgoto fail;\n\t\tbreak;\n\tcase IPPROTO_UDPLITE:\n\t\tif (update_flags & TCA_CSUM_UPDATE_FLAG_UDPLITE)\n\t\t\tif (!tcf_csum_ipv4_udp(skb, iph->ihl * 4,\n\t\t\t\t\t       ntohs(iph->tot_len), 1))\n\t\t\t\tgoto fail;\n\t\tbreak;\n\tcase IPPROTO_SCTP:\n\t\tif ((update_flags & TCA_CSUM_UPDATE_FLAG_SCTP) &&\n\t\t    !tcf_csum_sctp(skb, iph->ihl * 4, ntohs(iph->tot_len)))\n\t\t\tgoto fail;\n\t\tbreak;\n\t}\n\n\tif (update_flags & TCA_CSUM_UPDATE_FLAG_IPV4HDR) {\n\t\tif (skb_try_make_writable(skb, sizeof(*iph) + ntkoff))\n\t\t\tgoto fail;\n\n\t\tip_send_check(ip_hdr(skb));\n\t}\n\n\treturn 1;\n\nfail:\n\treturn 0;\n}\n\nstatic int tcf_csum_ipv6_hopopts(struct ipv6_opt_hdr *ip6xh, unsigned int ixhl,\n\t\t\t\t unsigned int *pl)\n{\n\tint off, len, optlen;\n\tunsigned char *xh = (void *)ip6xh;\n\n\toff = sizeof(*ip6xh);\n\tlen = ixhl - off;\n\n\twhile (len > 1) {\n\t\tswitch (xh[off]) {\n\t\tcase IPV6_TLV_PAD1:\n\t\t\toptlen = 1;\n\t\t\tbreak;\n\t\tcase IPV6_TLV_JUMBO:\n\t\t\toptlen = xh[off + 1] + 2;\n\t\t\tif (optlen != 6 || len < 6 || (off & 3) != 2)\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t*pl = ntohl(*(__be32 *)(xh + off + 2));\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\toptlen = xh[off + 1] + 2;\n\t\t\tif (optlen > len)\n\t\t\t\t \n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\n\t\toff += optlen;\n\t\tlen -= optlen;\n\t}\n\ndone:\n\treturn 1;\n}\n\nstatic int tcf_csum_ipv6(struct sk_buff *skb, u32 update_flags)\n{\n\tstruct ipv6hdr *ip6h;\n\tstruct ipv6_opt_hdr *ip6xh;\n\tunsigned int hl, ixhl;\n\tunsigned int pl;\n\tint ntkoff;\n\tu8 nexthdr;\n\n\tntkoff = skb_network_offset(skb);\n\n\thl = sizeof(*ip6h);\n\n\tif (!pskb_may_pull(skb, hl + ntkoff))\n\t\tgoto fail;\n\n\tip6h = ipv6_hdr(skb);\n\n\tpl = ntohs(ip6h->payload_len);\n\tnexthdr = ip6h->nexthdr;\n\n\tdo {\n\t\tswitch (nexthdr) {\n\t\tcase NEXTHDR_FRAGMENT:\n\t\t\tgoto ignore_skb;\n\t\tcase NEXTHDR_ROUTING:\n\t\tcase NEXTHDR_HOP:\n\t\tcase NEXTHDR_DEST:\n\t\t\tif (!pskb_may_pull(skb, hl + sizeof(*ip6xh) + ntkoff))\n\t\t\t\tgoto fail;\n\t\t\tip6xh = (void *)(skb_network_header(skb) + hl);\n\t\t\tixhl = ipv6_optlen(ip6xh);\n\t\t\tif (!pskb_may_pull(skb, hl + ixhl + ntkoff))\n\t\t\t\tgoto fail;\n\t\t\tip6xh = (void *)(skb_network_header(skb) + hl);\n\t\t\tif ((nexthdr == NEXTHDR_HOP) &&\n\t\t\t    !(tcf_csum_ipv6_hopopts(ip6xh, ixhl, &pl)))\n\t\t\t\tgoto fail;\n\t\t\tnexthdr = ip6xh->nexthdr;\n\t\t\thl += ixhl;\n\t\t\tbreak;\n\t\tcase IPPROTO_ICMPV6:\n\t\t\tif (update_flags & TCA_CSUM_UPDATE_FLAG_ICMP)\n\t\t\t\tif (!tcf_csum_ipv6_icmp(skb,\n\t\t\t\t\t\t\thl, pl + sizeof(*ip6h)))\n\t\t\t\t\tgoto fail;\n\t\t\tgoto done;\n\t\tcase IPPROTO_TCP:\n\t\t\tif (update_flags & TCA_CSUM_UPDATE_FLAG_TCP)\n\t\t\t\tif (!tcf_csum_ipv6_tcp(skb,\n\t\t\t\t\t\t       hl, pl + sizeof(*ip6h)))\n\t\t\t\t\tgoto fail;\n\t\t\tgoto done;\n\t\tcase IPPROTO_UDP:\n\t\t\tif (update_flags & TCA_CSUM_UPDATE_FLAG_UDP)\n\t\t\t\tif (!tcf_csum_ipv6_udp(skb, hl,\n\t\t\t\t\t\t       pl + sizeof(*ip6h), 0))\n\t\t\t\t\tgoto fail;\n\t\t\tgoto done;\n\t\tcase IPPROTO_UDPLITE:\n\t\t\tif (update_flags & TCA_CSUM_UPDATE_FLAG_UDPLITE)\n\t\t\t\tif (!tcf_csum_ipv6_udp(skb, hl,\n\t\t\t\t\t\t       pl + sizeof(*ip6h), 1))\n\t\t\t\t\tgoto fail;\n\t\t\tgoto done;\n\t\tcase IPPROTO_SCTP:\n\t\t\tif ((update_flags & TCA_CSUM_UPDATE_FLAG_SCTP) &&\n\t\t\t    !tcf_csum_sctp(skb, hl, pl + sizeof(*ip6h)))\n\t\t\t\tgoto fail;\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tgoto ignore_skb;\n\t\t}\n\t} while (pskb_may_pull(skb, hl + 1 + ntkoff));\n\ndone:\nignore_skb:\n\treturn 1;\n\nfail:\n\treturn 0;\n}\n\nTC_INDIRECT_SCOPE int tcf_csum_act(struct sk_buff *skb,\n\t\t\t\t   const struct tc_action *a,\n\t\t\t\t   struct tcf_result *res)\n{\n\tstruct tcf_csum *p = to_tcf_csum(a);\n\tbool orig_vlan_tag_present = false;\n\tunsigned int vlan_hdr_count = 0;\n\tstruct tcf_csum_params *params;\n\tu32 update_flags;\n\t__be16 protocol;\n\tint action;\n\n\tparams = rcu_dereference_bh(p->params);\n\n\ttcf_lastuse_update(&p->tcf_tm);\n\ttcf_action_update_bstats(&p->common, skb);\n\n\taction = READ_ONCE(p->tcf_action);\n\tif (unlikely(action == TC_ACT_SHOT))\n\t\tgoto drop;\n\n\tupdate_flags = params->update_flags;\n\tprotocol = skb_protocol(skb, false);\nagain:\n\tswitch (protocol) {\n\tcase cpu_to_be16(ETH_P_IP):\n\t\tif (!tcf_csum_ipv4(skb, update_flags))\n\t\t\tgoto drop;\n\t\tbreak;\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\tif (!tcf_csum_ipv6(skb, update_flags))\n\t\t\tgoto drop;\n\t\tbreak;\n\tcase cpu_to_be16(ETH_P_8021AD):\n\t\tfallthrough;\n\tcase cpu_to_be16(ETH_P_8021Q):\n\t\tif (skb_vlan_tag_present(skb) && !orig_vlan_tag_present) {\n\t\t\tprotocol = skb->protocol;\n\t\t\torig_vlan_tag_present = true;\n\t\t} else {\n\t\t\tstruct vlan_hdr *vlan = (struct vlan_hdr *)skb->data;\n\n\t\t\tprotocol = vlan->h_vlan_encapsulated_proto;\n\t\t\tskb_pull(skb, VLAN_HLEN);\n\t\t\tskb_reset_network_header(skb);\n\t\t\tvlan_hdr_count++;\n\t\t}\n\t\tgoto again;\n\t}\n\nout:\n\t \n\twhile (vlan_hdr_count--) {\n\t\tskb_push(skb, VLAN_HLEN);\n\t\tskb_reset_network_header(skb);\n\t}\n\n\treturn action;\n\ndrop:\n\ttcf_action_inc_drop_qstats(&p->common);\n\taction = TC_ACT_SHOT;\n\tgoto out;\n}\n\nstatic int tcf_csum_dump(struct sk_buff *skb, struct tc_action *a, int bind,\n\t\t\t int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_csum *p = to_tcf_csum(a);\n\tstruct tcf_csum_params *params;\n\tstruct tc_csum opt = {\n\t\t.index   = p->tcf_index,\n\t\t.refcnt  = refcount_read(&p->tcf_refcnt) - ref,\n\t\t.bindcnt = atomic_read(&p->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&p->tcf_lock);\n\tparams = rcu_dereference_protected(p->params,\n\t\t\t\t\t   lockdep_is_held(&p->tcf_lock));\n\topt.action = p->tcf_action;\n\topt.update_flags = params->update_flags;\n\n\tif (nla_put(skb, TCA_CSUM_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &p->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_CSUM_TM, sizeof(t), &t, TCA_CSUM_PAD))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&p->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&p->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic void tcf_csum_cleanup(struct tc_action *a)\n{\n\tstruct tcf_csum *p = to_tcf_csum(a);\n\tstruct tcf_csum_params *params;\n\n\tparams = rcu_dereference_protected(p->params, 1);\n\tif (params)\n\t\tkfree_rcu(params, rcu);\n}\n\nstatic size_t tcf_csum_get_fill_size(const struct tc_action *act)\n{\n\treturn nla_total_size(sizeof(struct tc_csum));\n}\n\nstatic int tcf_csum_offload_act_setup(struct tc_action *act, void *entry_data,\n\t\t\t\t      u32 *index_inc, bool bind,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (bind) {\n\t\tstruct flow_action_entry *entry = entry_data;\n\n\t\tentry->id = FLOW_ACTION_CSUM;\n\t\tentry->csum_flags = tcf_csum_update_flags(act);\n\t\t*index_inc = 1;\n\t} else {\n\t\tstruct flow_offload_action *fl_action = entry_data;\n\n\t\tfl_action->id = FLOW_ACTION_CSUM;\n\t}\n\n\treturn 0;\n}\n\nstatic struct tc_action_ops act_csum_ops = {\n\t.kind\t\t= \"csum\",\n\t.id\t\t= TCA_ID_CSUM,\n\t.owner\t\t= THIS_MODULE,\n\t.act\t\t= tcf_csum_act,\n\t.dump\t\t= tcf_csum_dump,\n\t.init\t\t= tcf_csum_init,\n\t.cleanup\t= tcf_csum_cleanup,\n\t.get_fill_size  = tcf_csum_get_fill_size,\n\t.offload_act_setup = tcf_csum_offload_act_setup,\n\t.size\t\t= sizeof(struct tcf_csum),\n};\n\nstatic __net_init int csum_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_csum_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_csum_ops);\n}\n\nstatic void __net_exit csum_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_csum_ops.net_id);\n}\n\nstatic struct pernet_operations csum_net_ops = {\n\t.init = csum_init_net,\n\t.exit_batch = csum_exit_net,\n\t.id   = &act_csum_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nMODULE_DESCRIPTION(\"Checksum updating actions\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init csum_init_module(void)\n{\n\treturn tcf_register_action(&act_csum_ops, &csum_net_ops);\n}\n\nstatic void __exit csum_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_csum_ops, &csum_net_ops);\n}\n\nmodule_init(csum_init_module);\nmodule_exit(csum_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}