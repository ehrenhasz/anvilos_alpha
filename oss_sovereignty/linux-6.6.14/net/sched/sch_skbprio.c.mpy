{
  "module_name": "sch_skbprio.c",
  "hash_id": "7f75fefac604cd82ec7e985b5b52751592d0ad62a55fb6ee3ed854fef5f94956",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_skbprio.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <net/pkt_sched.h>\n#include <net/sch_generic.h>\n#include <net/inet_ecn.h>\n\n \n\nstruct skbprio_sched_data {\n\t \n\tstruct sk_buff_head qdiscs[SKBPRIO_MAX_PRIORITY];\n\tstruct gnet_stats_queue qstats[SKBPRIO_MAX_PRIORITY];\n\tu16 highest_prio;\n\tu16 lowest_prio;\n};\n\nstatic u16 calc_new_high_prio(const struct skbprio_sched_data *q)\n{\n\tint prio;\n\n\tfor (prio = q->highest_prio - 1; prio >= q->lowest_prio; prio--) {\n\t\tif (!skb_queue_empty(&q->qdiscs[prio]))\n\t\t\treturn prio;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic u16 calc_new_low_prio(const struct skbprio_sched_data *q)\n{\n\tint prio;\n\n\tfor (prio = q->lowest_prio + 1; prio <= q->highest_prio; prio++) {\n\t\tif (!skb_queue_empty(&q->qdiscs[prio]))\n\t\t\treturn prio;\n\t}\n\n\t \n\treturn SKBPRIO_MAX_PRIORITY - 1;\n}\n\nstatic int skbprio_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t  struct sk_buff **to_free)\n{\n\tconst unsigned int max_priority = SKBPRIO_MAX_PRIORITY - 1;\n\tstruct skbprio_sched_data *q = qdisc_priv(sch);\n\tstruct sk_buff_head *qdisc;\n\tstruct sk_buff_head *lp_qdisc;\n\tstruct sk_buff *to_drop;\n\tu16 prio, lp;\n\n\t \n\tprio = min(skb->priority, max_priority);\n\n\tqdisc = &q->qdiscs[prio];\n\tif (sch->q.qlen < sch->limit) {\n\t\t__skb_queue_tail(qdisc, skb);\n\t\tqdisc_qstats_backlog_inc(sch, skb);\n\t\tq->qstats[prio].backlog += qdisc_pkt_len(skb);\n\n\t\t \n\t\tif (prio > q->highest_prio)\n\t\t\tq->highest_prio = prio;\n\n\t\tif (prio < q->lowest_prio)\n\t\t\tq->lowest_prio = prio;\n\n\t\tsch->q.qlen++;\n\t\treturn NET_XMIT_SUCCESS;\n\t}\n\n\t \n\tlp = q->lowest_prio;\n\tif (prio <= lp) {\n\t\tq->qstats[prio].drops++;\n\t\tq->qstats[prio].overlimits++;\n\t\treturn qdisc_drop(skb, sch, to_free);\n\t}\n\n\t__skb_queue_tail(qdisc, skb);\n\tqdisc_qstats_backlog_inc(sch, skb);\n\tq->qstats[prio].backlog += qdisc_pkt_len(skb);\n\n\t \n\tlp_qdisc = &q->qdiscs[lp];\n\tto_drop = __skb_dequeue_tail(lp_qdisc);\n\tBUG_ON(!to_drop);\n\tqdisc_qstats_backlog_dec(sch, to_drop);\n\tqdisc_drop(to_drop, sch, to_free);\n\n\tq->qstats[lp].backlog -= qdisc_pkt_len(to_drop);\n\tq->qstats[lp].drops++;\n\tq->qstats[lp].overlimits++;\n\n\t \n\tif (skb_queue_empty(lp_qdisc)) {\n\t\tif (q->lowest_prio == q->highest_prio) {\n\t\t\t \n\t\t\tBUG_ON(sch->q.qlen != 1);\n\t\t\tq->lowest_prio = prio;\n\t\t\tq->highest_prio = prio;\n\t\t} else {\n\t\t\tq->lowest_prio = calc_new_low_prio(q);\n\t\t}\n\t}\n\n\tif (prio > q->highest_prio)\n\t\tq->highest_prio = prio;\n\n\treturn NET_XMIT_CN;\n}\n\nstatic struct sk_buff *skbprio_dequeue(struct Qdisc *sch)\n{\n\tstruct skbprio_sched_data *q = qdisc_priv(sch);\n\tstruct sk_buff_head *hpq = &q->qdiscs[q->highest_prio];\n\tstruct sk_buff *skb = __skb_dequeue(hpq);\n\n\tif (unlikely(!skb))\n\t\treturn NULL;\n\n\tsch->q.qlen--;\n\tqdisc_qstats_backlog_dec(sch, skb);\n\tqdisc_bstats_update(sch, skb);\n\n\tq->qstats[q->highest_prio].backlog -= qdisc_pkt_len(skb);\n\n\t \n\tif (skb_queue_empty(hpq)) {\n\t\tif (q->lowest_prio == q->highest_prio) {\n\t\t\tBUG_ON(sch->q.qlen);\n\t\t\tq->highest_prio = 0;\n\t\t\tq->lowest_prio = SKBPRIO_MAX_PRIORITY - 1;\n\t\t} else {\n\t\t\tq->highest_prio = calc_new_high_prio(q);\n\t\t}\n\t}\n\treturn skb;\n}\n\nstatic int skbprio_change(struct Qdisc *sch, struct nlattr *opt,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tc_skbprio_qopt *ctl = nla_data(opt);\n\n\tif (opt->nla_len != nla_attr_size(sizeof(*ctl)))\n\t\treturn -EINVAL;\n\n\tsch->limit = ctl->limit;\n\treturn 0;\n}\n\nstatic int skbprio_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct skbprio_sched_data *q = qdisc_priv(sch);\n\tint prio;\n\n\t \n\tfor (prio = 0; prio < SKBPRIO_MAX_PRIORITY; prio++)\n\t\t__skb_queue_head_init(&q->qdiscs[prio]);\n\n\tmemset(&q->qstats, 0, sizeof(q->qstats));\n\tq->highest_prio = 0;\n\tq->lowest_prio = SKBPRIO_MAX_PRIORITY - 1;\n\tsch->limit = 64;\n\tif (!opt)\n\t\treturn 0;\n\n\treturn skbprio_change(sch, opt, extack);\n}\n\nstatic int skbprio_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct tc_skbprio_qopt opt;\n\n\topt.limit = sch->limit;\n\n\tif (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))\n\t\treturn -1;\n\n\treturn skb->len;\n}\n\nstatic void skbprio_reset(struct Qdisc *sch)\n{\n\tstruct skbprio_sched_data *q = qdisc_priv(sch);\n\tint prio;\n\n\tfor (prio = 0; prio < SKBPRIO_MAX_PRIORITY; prio++)\n\t\t__skb_queue_purge(&q->qdiscs[prio]);\n\n\tmemset(&q->qstats, 0, sizeof(q->qstats));\n\tq->highest_prio = 0;\n\tq->lowest_prio = SKBPRIO_MAX_PRIORITY - 1;\n}\n\nstatic void skbprio_destroy(struct Qdisc *sch)\n{\n\tstruct skbprio_sched_data *q = qdisc_priv(sch);\n\tint prio;\n\n\tfor (prio = 0; prio < SKBPRIO_MAX_PRIORITY; prio++)\n\t\t__skb_queue_purge(&q->qdiscs[prio]);\n}\n\nstatic struct Qdisc *skbprio_leaf(struct Qdisc *sch, unsigned long arg)\n{\n\treturn NULL;\n}\n\nstatic unsigned long skbprio_find(struct Qdisc *sch, u32 classid)\n{\n\treturn 0;\n}\n\nstatic int skbprio_dump_class(struct Qdisc *sch, unsigned long cl,\n\t\t\t     struct sk_buff *skb, struct tcmsg *tcm)\n{\n\ttcm->tcm_handle |= TC_H_MIN(cl);\n\treturn 0;\n}\n\nstatic int skbprio_dump_class_stats(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t   struct gnet_dump *d)\n{\n\tstruct skbprio_sched_data *q = qdisc_priv(sch);\n\tif (gnet_stats_copy_queue(d, NULL, &q->qstats[cl - 1],\n\t\tq->qstats[cl - 1].qlen) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void skbprio_walk(struct Qdisc *sch, struct qdisc_walker *arg)\n{\n\tunsigned int i;\n\n\tif (arg->stop)\n\t\treturn;\n\n\tfor (i = 0; i < SKBPRIO_MAX_PRIORITY; i++) {\n\t\tif (!tc_qdisc_stats_dump(sch, i + 1, arg))\n\t\t\tbreak;\n\t}\n}\n\nstatic const struct Qdisc_class_ops skbprio_class_ops = {\n\t.leaf\t\t=\tskbprio_leaf,\n\t.find\t\t=\tskbprio_find,\n\t.dump\t\t=\tskbprio_dump_class,\n\t.dump_stats\t=\tskbprio_dump_class_stats,\n\t.walk\t\t=\tskbprio_walk,\n};\n\nstatic struct Qdisc_ops skbprio_qdisc_ops __read_mostly = {\n\t.cl_ops\t\t=\t&skbprio_class_ops,\n\t.id\t\t=\t\"skbprio\",\n\t.priv_size\t=\tsizeof(struct skbprio_sched_data),\n\t.enqueue\t=\tskbprio_enqueue,\n\t.dequeue\t=\tskbprio_dequeue,\n\t.peek\t\t=\tqdisc_peek_dequeued,\n\t.init\t\t=\tskbprio_init,\n\t.reset\t\t=\tskbprio_reset,\n\t.change\t\t=\tskbprio_change,\n\t.dump\t\t=\tskbprio_dump,\n\t.destroy\t=\tskbprio_destroy,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init skbprio_module_init(void)\n{\n\treturn register_qdisc(&skbprio_qdisc_ops);\n}\n\nstatic void __exit skbprio_module_exit(void)\n{\n\tunregister_qdisc(&skbprio_qdisc_ops);\n}\n\nmodule_init(skbprio_module_init)\nmodule_exit(skbprio_module_exit)\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}