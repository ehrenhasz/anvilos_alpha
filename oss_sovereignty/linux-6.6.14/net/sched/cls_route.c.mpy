{
  "module_name": "cls_route.c",
  "hash_id": "fe53dc6760689e689d42936c99a232d6c007489cb7b98a3e49c8f913aa85b5a3",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/cls_route.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <net/dst.h>\n#include <net/route.h>\n#include <net/netlink.h>\n#include <net/act_api.h>\n#include <net/pkt_cls.h>\n#include <net/tc_wrapper.h>\n\n \nstruct route4_fastmap {\n\tstruct route4_filter\t\t*filter;\n\tu32\t\t\t\tid;\n\tint\t\t\t\tiif;\n};\n\nstruct route4_head {\n\tstruct route4_fastmap\t\tfastmap[16];\n\tstruct route4_bucket __rcu\t*table[256 + 1];\n\tstruct rcu_head\t\t\trcu;\n};\n\nstruct route4_bucket {\n\t \n\tstruct route4_filter __rcu\t*ht[16 + 16 + 1];\n\tstruct rcu_head\t\t\trcu;\n};\n\nstruct route4_filter {\n\tstruct route4_filter __rcu\t*next;\n\tu32\t\t\tid;\n\tint\t\t\tiif;\n\n\tstruct tcf_result\tres;\n\tstruct tcf_exts\t\texts;\n\tu32\t\t\thandle;\n\tstruct route4_bucket\t*bkt;\n\tstruct tcf_proto\t*tp;\n\tstruct rcu_work\t\trwork;\n};\n\n#define ROUTE4_FAILURE ((struct route4_filter *)(-1L))\n\nstatic inline int route4_fastmap_hash(u32 id, int iif)\n{\n\treturn id & 0xF;\n}\n\nstatic DEFINE_SPINLOCK(fastmap_lock);\nstatic void\nroute4_reset_fastmap(struct route4_head *head)\n{\n\tspin_lock_bh(&fastmap_lock);\n\tmemset(head->fastmap, 0, sizeof(head->fastmap));\n\tspin_unlock_bh(&fastmap_lock);\n}\n\nstatic void\nroute4_set_fastmap(struct route4_head *head, u32 id, int iif,\n\t\t   struct route4_filter *f)\n{\n\tint h = route4_fastmap_hash(id, iif);\n\n\t \n\tspin_lock_bh(&fastmap_lock);\n\thead->fastmap[h].id = id;\n\thead->fastmap[h].iif = iif;\n\thead->fastmap[h].filter = f;\n\tspin_unlock_bh(&fastmap_lock);\n}\n\nstatic inline int route4_hash_to(u32 id)\n{\n\treturn id & 0xFF;\n}\n\nstatic inline int route4_hash_from(u32 id)\n{\n\treturn (id >> 16) & 0xF;\n}\n\nstatic inline int route4_hash_iif(int iif)\n{\n\treturn 16 + ((iif >> 16) & 0xF);\n}\n\nstatic inline int route4_hash_wild(void)\n{\n\treturn 32;\n}\n\n#define ROUTE4_APPLY_RESULT()\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t*res = f->res;\t\t\t\t\t\t\\\n\tif (tcf_exts_has_actions(&f->exts)) {\t\t\t\\\n\t\tint r = tcf_exts_exec(skb, &f->exts, res);\t\\\n\t\tif (r < 0) {\t\t\t\t\t\\\n\t\t\tdont_cache = 1;\t\t\t\t\\\n\t\t\tcontinue;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\treturn r;\t\t\t\t\t\\\n\t} else if (!dont_cache)\t\t\t\t\t\\\n\t\troute4_set_fastmap(head, id, iif, f);\t\t\\\n\treturn 0;\t\t\t\t\t\t\\\n}\n\nTC_INDIRECT_SCOPE int route4_classify(struct sk_buff *skb,\n\t\t\t\t      const struct tcf_proto *tp,\n\t\t\t\t      struct tcf_result *res)\n{\n\tstruct route4_head *head = rcu_dereference_bh(tp->root);\n\tstruct dst_entry *dst;\n\tstruct route4_bucket *b;\n\tstruct route4_filter *f;\n\tu32 id, h;\n\tint iif, dont_cache = 0;\n\n\tdst = skb_dst(skb);\n\tif (!dst)\n\t\tgoto failure;\n\n\tid = dst->tclassid;\n\n\tiif = inet_iif(skb);\n\n\th = route4_fastmap_hash(id, iif);\n\n\tspin_lock(&fastmap_lock);\n\tif (id == head->fastmap[h].id &&\n\t    iif == head->fastmap[h].iif &&\n\t    (f = head->fastmap[h].filter) != NULL) {\n\t\tif (f == ROUTE4_FAILURE) {\n\t\t\tspin_unlock(&fastmap_lock);\n\t\t\tgoto failure;\n\t\t}\n\n\t\t*res = f->res;\n\t\tspin_unlock(&fastmap_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fastmap_lock);\n\n\th = route4_hash_to(id);\n\nrestart:\n\tb = rcu_dereference_bh(head->table[h]);\n\tif (b) {\n\t\tfor (f = rcu_dereference_bh(b->ht[route4_hash_from(id)]);\n\t\t     f;\n\t\t     f = rcu_dereference_bh(f->next))\n\t\t\tif (f->id == id)\n\t\t\t\tROUTE4_APPLY_RESULT();\n\n\t\tfor (f = rcu_dereference_bh(b->ht[route4_hash_iif(iif)]);\n\t\t     f;\n\t\t     f = rcu_dereference_bh(f->next))\n\t\t\tif (f->iif == iif)\n\t\t\t\tROUTE4_APPLY_RESULT();\n\n\t\tfor (f = rcu_dereference_bh(b->ht[route4_hash_wild()]);\n\t\t     f;\n\t\t     f = rcu_dereference_bh(f->next))\n\t\t\tROUTE4_APPLY_RESULT();\n\t}\n\tif (h < 256) {\n\t\th = 256;\n\t\tid &= ~0xFFFF;\n\t\tgoto restart;\n\t}\n\n\tif (!dont_cache)\n\t\troute4_set_fastmap(head, id, iif, ROUTE4_FAILURE);\nfailure:\n\treturn -1;\n}\n\nstatic inline u32 to_hash(u32 id)\n{\n\tu32 h = id & 0xFF;\n\n\tif (id & 0x8000)\n\t\th += 256;\n\treturn h;\n}\n\nstatic inline u32 from_hash(u32 id)\n{\n\tid &= 0xFFFF;\n\tif (id == 0xFFFF)\n\t\treturn 32;\n\tif (!(id & 0x8000)) {\n\t\tif (id > 255)\n\t\t\treturn 256;\n\t\treturn id & 0xF;\n\t}\n\treturn 16 + (id & 0xF);\n}\n\nstatic void *route4_get(struct tcf_proto *tp, u32 handle)\n{\n\tstruct route4_head *head = rtnl_dereference(tp->root);\n\tstruct route4_bucket *b;\n\tstruct route4_filter *f;\n\tunsigned int h1, h2;\n\n\th1 = to_hash(handle);\n\tif (h1 > 256)\n\t\treturn NULL;\n\n\th2 = from_hash(handle >> 16);\n\tif (h2 > 32)\n\t\treturn NULL;\n\n\tb = rtnl_dereference(head->table[h1]);\n\tif (b) {\n\t\tfor (f = rtnl_dereference(b->ht[h2]);\n\t\t     f;\n\t\t     f = rtnl_dereference(f->next))\n\t\t\tif (f->handle == handle)\n\t\t\t\treturn f;\n\t}\n\treturn NULL;\n}\n\nstatic int route4_init(struct tcf_proto *tp)\n{\n\tstruct route4_head *head;\n\n\thead = kzalloc(sizeof(struct route4_head), GFP_KERNEL);\n\tif (head == NULL)\n\t\treturn -ENOBUFS;\n\n\trcu_assign_pointer(tp->root, head);\n\treturn 0;\n}\n\nstatic void __route4_delete_filter(struct route4_filter *f)\n{\n\ttcf_exts_destroy(&f->exts);\n\ttcf_exts_put_net(&f->exts);\n\tkfree(f);\n}\n\nstatic void route4_delete_filter_work(struct work_struct *work)\n{\n\tstruct route4_filter *f = container_of(to_rcu_work(work),\n\t\t\t\t\t       struct route4_filter,\n\t\t\t\t\t       rwork);\n\trtnl_lock();\n\t__route4_delete_filter(f);\n\trtnl_unlock();\n}\n\nstatic void route4_queue_work(struct route4_filter *f)\n{\n\ttcf_queue_work(&f->rwork, route4_delete_filter_work);\n}\n\nstatic void route4_destroy(struct tcf_proto *tp, bool rtnl_held,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct route4_head *head = rtnl_dereference(tp->root);\n\tint h1, h2;\n\n\tif (head == NULL)\n\t\treturn;\n\n\tfor (h1 = 0; h1 <= 256; h1++) {\n\t\tstruct route4_bucket *b;\n\n\t\tb = rtnl_dereference(head->table[h1]);\n\t\tif (b) {\n\t\t\tfor (h2 = 0; h2 <= 32; h2++) {\n\t\t\t\tstruct route4_filter *f;\n\n\t\t\t\twhile ((f = rtnl_dereference(b->ht[h2])) != NULL) {\n\t\t\t\t\tstruct route4_filter *next;\n\n\t\t\t\t\tnext = rtnl_dereference(f->next);\n\t\t\t\t\tRCU_INIT_POINTER(b->ht[h2], next);\n\t\t\t\t\ttcf_unbind_filter(tp, &f->res);\n\t\t\t\t\tif (tcf_exts_get_net(&f->exts))\n\t\t\t\t\t\troute4_queue_work(f);\n\t\t\t\t\telse\n\t\t\t\t\t\t__route4_delete_filter(f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRCU_INIT_POINTER(head->table[h1], NULL);\n\t\t\tkfree_rcu(b, rcu);\n\t\t}\n\t}\n\tkfree_rcu(head, rcu);\n}\n\nstatic int route4_delete(struct tcf_proto *tp, void *arg, bool *last,\n\t\t\t bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct route4_head *head = rtnl_dereference(tp->root);\n\tstruct route4_filter *f = arg;\n\tstruct route4_filter __rcu **fp;\n\tstruct route4_filter *nf;\n\tstruct route4_bucket *b;\n\tunsigned int h = 0;\n\tint i, h1;\n\n\tif (!head || !f)\n\t\treturn -EINVAL;\n\n\th = f->handle;\n\tb = f->bkt;\n\n\tfp = &b->ht[from_hash(h >> 16)];\n\tfor (nf = rtnl_dereference(*fp); nf;\n\t     fp = &nf->next, nf = rtnl_dereference(*fp)) {\n\t\tif (nf == f) {\n\t\t\t \n\t\t\tRCU_INIT_POINTER(*fp, rtnl_dereference(f->next));\n\n\t\t\t \n\t\t\troute4_reset_fastmap(head);\n\n\t\t\t \n\t\t\ttcf_unbind_filter(tp, &f->res);\n\t\t\ttcf_exts_get_net(&f->exts);\n\t\t\ttcf_queue_work(&f->rwork, route4_delete_filter_work);\n\n\t\t\t \n\t\t\tfor (i = 0; i <= 32; i++) {\n\t\t\t\tstruct route4_filter *rt;\n\n\t\t\t\trt = rtnl_dereference(b->ht[i]);\n\t\t\t\tif (rt)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tRCU_INIT_POINTER(head->table[to_hash(h)], NULL);\n\t\t\tkfree_rcu(b, rcu);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*last = true;\n\tfor (h1 = 0; h1 <= 256; h1++) {\n\t\tif (rcu_access_pointer(head->table[h1])) {\n\t\t\t*last = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nla_policy route4_policy[TCA_ROUTE4_MAX + 1] = {\n\t[TCA_ROUTE4_CLASSID]\t= { .type = NLA_U32 },\n\t[TCA_ROUTE4_TO]\t\t= { .type = NLA_U32 },\n\t[TCA_ROUTE4_FROM]\t= { .type = NLA_U32 },\n\t[TCA_ROUTE4_IIF]\t= { .type = NLA_U32 },\n};\n\nstatic int route4_set_parms(struct net *net, struct tcf_proto *tp,\n\t\t\t    unsigned long base, struct route4_filter *f,\n\t\t\t    u32 handle, struct route4_head *head,\n\t\t\t    struct nlattr **tb, struct nlattr *est, int new,\n\t\t\t    u32 flags, struct netlink_ext_ack *extack)\n{\n\tu32 id = 0, to = 0, nhandle = 0x8000;\n\tstruct route4_filter *fp;\n\tunsigned int h1;\n\tstruct route4_bucket *b;\n\tint err;\n\n\terr = tcf_exts_validate(net, tp, tb, est, &f->exts, flags, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_ROUTE4_TO]) {\n\t\tif (new && handle & 0x8000)\n\t\t\treturn -EINVAL;\n\t\tto = nla_get_u32(tb[TCA_ROUTE4_TO]);\n\t\tif (to > 0xFF)\n\t\t\treturn -EINVAL;\n\t\tnhandle = to;\n\t}\n\n\tif (tb[TCA_ROUTE4_FROM]) {\n\t\tif (tb[TCA_ROUTE4_IIF])\n\t\t\treturn -EINVAL;\n\t\tid = nla_get_u32(tb[TCA_ROUTE4_FROM]);\n\t\tif (id > 0xFF)\n\t\t\treturn -EINVAL;\n\t\tnhandle |= id << 16;\n\t} else if (tb[TCA_ROUTE4_IIF]) {\n\t\tid = nla_get_u32(tb[TCA_ROUTE4_IIF]);\n\t\tif (id > 0x7FFF)\n\t\t\treturn -EINVAL;\n\t\tnhandle |= (id | 0x8000) << 16;\n\t} else\n\t\tnhandle |= 0xFFFF << 16;\n\n\tif (handle && new) {\n\t\tnhandle |= handle & 0x7F00;\n\t\tif (nhandle != handle)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!nhandle) {\n\t\tNL_SET_ERR_MSG(extack, \"Replacing with handle of 0 is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\th1 = to_hash(nhandle);\n\tb = rtnl_dereference(head->table[h1]);\n\tif (!b) {\n\t\tb = kzalloc(sizeof(struct route4_bucket), GFP_KERNEL);\n\t\tif (b == NULL)\n\t\t\treturn -ENOBUFS;\n\n\t\trcu_assign_pointer(head->table[h1], b);\n\t} else {\n\t\tunsigned int h2 = from_hash(nhandle >> 16);\n\n\t\tfor (fp = rtnl_dereference(b->ht[h2]);\n\t\t     fp;\n\t\t     fp = rtnl_dereference(fp->next))\n\t\t\tif (fp->handle == f->handle)\n\t\t\t\treturn -EEXIST;\n\t}\n\n\tif (tb[TCA_ROUTE4_TO])\n\t\tf->id = to;\n\n\tif (tb[TCA_ROUTE4_FROM])\n\t\tf->id = to | id<<16;\n\telse if (tb[TCA_ROUTE4_IIF])\n\t\tf->iif = id;\n\n\tf->handle = nhandle;\n\tf->bkt = b;\n\tf->tp = tp;\n\n\tif (tb[TCA_ROUTE4_CLASSID]) {\n\t\tf->res.classid = nla_get_u32(tb[TCA_ROUTE4_CLASSID]);\n\t\ttcf_bind_filter(tp, &f->res, base);\n\t}\n\n\treturn 0;\n}\n\nstatic int route4_change(struct net *net, struct sk_buff *in_skb,\n\t\t\t struct tcf_proto *tp, unsigned long base, u32 handle,\n\t\t\t struct nlattr **tca, void **arg, u32 flags,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct route4_head *head = rtnl_dereference(tp->root);\n\tstruct route4_filter __rcu **fp;\n\tstruct route4_filter *fold, *f1, *pfp, *f = NULL;\n\tstruct route4_bucket *b;\n\tstruct nlattr *opt = tca[TCA_OPTIONS];\n\tstruct nlattr *tb[TCA_ROUTE4_MAX + 1];\n\tunsigned int h, th;\n\tint err;\n\tbool new = true;\n\n\tif (!handle) {\n\t\tNL_SET_ERR_MSG(extack, \"Creating with handle of 0 is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (opt == NULL)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt,\n\t\t\t\t\t  route4_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tfold = *arg;\n\tif (fold && fold->handle != handle)\n\t\t\treturn -EINVAL;\n\n\terr = -ENOBUFS;\n\tf = kzalloc(sizeof(struct route4_filter), GFP_KERNEL);\n\tif (!f)\n\t\tgoto errout;\n\n\terr = tcf_exts_init(&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (fold) {\n\t\tf->id = fold->id;\n\t\tf->iif = fold->iif;\n\t\tf->handle = fold->handle;\n\n\t\tf->tp = fold->tp;\n\t\tf->bkt = fold->bkt;\n\t\tnew = false;\n\t}\n\n\terr = route4_set_parms(net, tp, base, f, handle, head, tb,\n\t\t\t       tca[TCA_RATE], new, flags, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\th = from_hash(f->handle >> 16);\n\tfp = &f->bkt->ht[h];\n\tfor (pfp = rtnl_dereference(*fp);\n\t     (f1 = rtnl_dereference(*fp)) != NULL;\n\t     fp = &f1->next)\n\t\tif (f->handle < f1->handle)\n\t\t\tbreak;\n\n\ttcf_block_netif_keep_dst(tp->chain->block);\n\trcu_assign_pointer(f->next, f1);\n\trcu_assign_pointer(*fp, f);\n\n\tif (fold) {\n\t\tth = to_hash(fold->handle);\n\t\th = from_hash(fold->handle >> 16);\n\t\tb = rtnl_dereference(head->table[th]);\n\t\tif (b) {\n\t\t\tfp = &b->ht[h];\n\t\t\tfor (pfp = rtnl_dereference(*fp); pfp;\n\t\t\t     fp = &pfp->next, pfp = rtnl_dereference(*fp)) {\n\t\t\t\tif (pfp == fold) {\n\t\t\t\t\trcu_assign_pointer(*fp, fold->next);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\troute4_reset_fastmap(head);\n\t*arg = f;\n\tif (fold) {\n\t\ttcf_unbind_filter(tp, &fold->res);\n\t\ttcf_exts_get_net(&fold->exts);\n\t\ttcf_queue_work(&fold->rwork, route4_delete_filter_work);\n\t}\n\treturn 0;\n\nerrout:\n\tif (f)\n\t\ttcf_exts_destroy(&f->exts);\n\tkfree(f);\n\treturn err;\n}\n\nstatic void route4_walk(struct tcf_proto *tp, struct tcf_walker *arg,\n\t\t\tbool rtnl_held)\n{\n\tstruct route4_head *head = rtnl_dereference(tp->root);\n\tunsigned int h, h1;\n\n\tif (head == NULL || arg->stop)\n\t\treturn;\n\n\tfor (h = 0; h <= 256; h++) {\n\t\tstruct route4_bucket *b = rtnl_dereference(head->table[h]);\n\n\t\tif (b) {\n\t\t\tfor (h1 = 0; h1 <= 32; h1++) {\n\t\t\t\tstruct route4_filter *f;\n\n\t\t\t\tfor (f = rtnl_dereference(b->ht[h1]);\n\t\t\t\t     f;\n\t\t\t\t     f = rtnl_dereference(f->next)) {\n\t\t\t\t\tif (!tc_cls_stats_dump(tp, arg, f))\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int route4_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t       struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)\n{\n\tstruct route4_filter *f = fh;\n\tstruct nlattr *nest;\n\tu32 id;\n\n\tif (f == NULL)\n\t\treturn skb->len;\n\n\tt->tcm_handle = f->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (!(f->handle & 0x8000)) {\n\t\tid = f->id & 0xFF;\n\t\tif (nla_put_u32(skb, TCA_ROUTE4_TO, id))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (f->handle & 0x80000000) {\n\t\tif ((f->handle >> 16) != 0xFFFF &&\n\t\t    nla_put_u32(skb, TCA_ROUTE4_IIF, f->iif))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tid = f->id >> 16;\n\t\tif (nla_put_u32(skb, TCA_ROUTE4_FROM, id))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (f->res.classid &&\n\t    nla_put_u32(skb, TCA_ROUTE4_CLASSID, f->res.classid))\n\t\tgoto nla_put_failure;\n\n\tif (tcf_exts_dump(skb, &f->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tif (tcf_exts_dump_stats(skb, &f->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic void route4_bind_class(void *fh, u32 classid, unsigned long cl, void *q,\n\t\t\t      unsigned long base)\n{\n\tstruct route4_filter *f = fh;\n\n\ttc_cls_bind_class(classid, cl, q, &f->res, base);\n}\n\nstatic struct tcf_proto_ops cls_route4_ops __read_mostly = {\n\t.kind\t\t=\t\"route\",\n\t.classify\t=\troute4_classify,\n\t.init\t\t=\troute4_init,\n\t.destroy\t=\troute4_destroy,\n\t.get\t\t=\troute4_get,\n\t.change\t\t=\troute4_change,\n\t.delete\t\t=\troute4_delete,\n\t.walk\t\t=\troute4_walk,\n\t.dump\t\t=\troute4_dump,\n\t.bind_class\t=\troute4_bind_class,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init init_route4(void)\n{\n\treturn register_tcf_proto_ops(&cls_route4_ops);\n}\n\nstatic void __exit exit_route4(void)\n{\n\tunregister_tcf_proto_ops(&cls_route4_ops);\n}\n\nmodule_init(init_route4)\nmodule_exit(exit_route4)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}