{
  "module_name": "cls_api.c",
  "hash_id": "90d8b6b663cbf8fe52e4f6e3a01446ffa49989d6c6144694bb96a57ac49ef8cb",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/cls_api.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/jhash.h>\n#include <linux/rculist.h>\n#include <linux/rhashtable.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <net/tc_act/tc_pedit.h>\n#include <net/tc_act/tc_mirred.h>\n#include <net/tc_act/tc_vlan.h>\n#include <net/tc_act/tc_tunnel_key.h>\n#include <net/tc_act/tc_csum.h>\n#include <net/tc_act/tc_gact.h>\n#include <net/tc_act/tc_police.h>\n#include <net/tc_act/tc_sample.h>\n#include <net/tc_act/tc_skbedit.h>\n#include <net/tc_act/tc_ct.h>\n#include <net/tc_act/tc_mpls.h>\n#include <net/tc_act/tc_gate.h>\n#include <net/flow_offload.h>\n#include <net/tc_wrapper.h>\n\n \nstatic LIST_HEAD(tcf_proto_base);\n\n \nstatic DEFINE_RWLOCK(cls_mod_lock);\n\nstatic struct xarray tcf_exts_miss_cookies_xa;\nstruct tcf_exts_miss_cookie_node {\n\tconst struct tcf_chain *chain;\n\tconst struct tcf_proto *tp;\n\tconst struct tcf_exts *exts;\n\tu32 chain_index;\n\tu32 tp_prio;\n\tu32 handle;\n\tu32 miss_cookie_base;\n\tstruct rcu_head rcu;\n};\n\n \nunion tcf_exts_miss_cookie {\n\tstruct {\n\t\tu32 miss_cookie_base;\n\t\tu32 act_index;\n\t};\n\tu64 miss_cookie;\n};\n\n#if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)\nstatic int\ntcf_exts_miss_cookie_base_alloc(struct tcf_exts *exts, struct tcf_proto *tp,\n\t\t\t\tu32 handle)\n{\n\tstruct tcf_exts_miss_cookie_node *n;\n\tstatic u32 next;\n\tint err;\n\n\tif (WARN_ON(!handle || !tp->ops->get_exts))\n\t\treturn -EINVAL;\n\n\tn = kzalloc(sizeof(*n), GFP_KERNEL);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\tn->chain_index = tp->chain->index;\n\tn->chain = tp->chain;\n\tn->tp_prio = tp->prio;\n\tn->tp = tp;\n\tn->exts = exts;\n\tn->handle = handle;\n\n\terr = xa_alloc_cyclic(&tcf_exts_miss_cookies_xa, &n->miss_cookie_base,\n\t\t\t      n, xa_limit_32b, &next, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_xa_alloc;\n\n\texts->miss_cookie_node = n;\n\treturn 0;\n\nerr_xa_alloc:\n\tkfree(n);\n\treturn err;\n}\n\nstatic void tcf_exts_miss_cookie_base_destroy(struct tcf_exts *exts)\n{\n\tstruct tcf_exts_miss_cookie_node *n;\n\n\tif (!exts->miss_cookie_node)\n\t\treturn;\n\n\tn = exts->miss_cookie_node;\n\txa_erase(&tcf_exts_miss_cookies_xa, n->miss_cookie_base);\n\tkfree_rcu(n, rcu);\n}\n\nstatic struct tcf_exts_miss_cookie_node *\ntcf_exts_miss_cookie_lookup(u64 miss_cookie, int *act_index)\n{\n\tunion tcf_exts_miss_cookie mc = { .miss_cookie = miss_cookie, };\n\n\t*act_index = mc.act_index;\n\treturn xa_load(&tcf_exts_miss_cookies_xa, mc.miss_cookie_base);\n}\n#else  \nstatic int\ntcf_exts_miss_cookie_base_alloc(struct tcf_exts *exts, struct tcf_proto *tp,\n\t\t\t\tu32 handle)\n{\n\treturn 0;\n}\n\nstatic void tcf_exts_miss_cookie_base_destroy(struct tcf_exts *exts)\n{\n}\n#endif  \n\nstatic u64 tcf_exts_miss_cookie_get(u32 miss_cookie_base, int act_index)\n{\n\tunion tcf_exts_miss_cookie mc = { .act_index = act_index, };\n\n\tif (!miss_cookie_base)\n\t\treturn 0;\n\n\tmc.miss_cookie_base = miss_cookie_base;\n\treturn mc.miss_cookie;\n}\n\n#ifdef CONFIG_NET_CLS_ACT\nDEFINE_STATIC_KEY_FALSE(tc_skb_ext_tc);\nEXPORT_SYMBOL(tc_skb_ext_tc);\n\nvoid tc_skb_ext_tc_enable(void)\n{\n\tstatic_branch_inc(&tc_skb_ext_tc);\n}\nEXPORT_SYMBOL(tc_skb_ext_tc_enable);\n\nvoid tc_skb_ext_tc_disable(void)\n{\n\tstatic_branch_dec(&tc_skb_ext_tc);\n}\nEXPORT_SYMBOL(tc_skb_ext_tc_disable);\n#endif\n\nstatic u32 destroy_obj_hashfn(const struct tcf_proto *tp)\n{\n\treturn jhash_3words(tp->chain->index, tp->prio,\n\t\t\t    (__force __u32)tp->protocol, 0);\n}\n\nstatic void tcf_proto_signal_destroying(struct tcf_chain *chain,\n\t\t\t\t\tstruct tcf_proto *tp)\n{\n\tstruct tcf_block *block = chain->block;\n\n\tmutex_lock(&block->proto_destroy_lock);\n\thash_add_rcu(block->proto_destroy_ht, &tp->destroy_ht_node,\n\t\t     destroy_obj_hashfn(tp));\n\tmutex_unlock(&block->proto_destroy_lock);\n}\n\nstatic bool tcf_proto_cmp(const struct tcf_proto *tp1,\n\t\t\t  const struct tcf_proto *tp2)\n{\n\treturn tp1->chain->index == tp2->chain->index &&\n\t       tp1->prio == tp2->prio &&\n\t       tp1->protocol == tp2->protocol;\n}\n\nstatic bool tcf_proto_exists_destroying(struct tcf_chain *chain,\n\t\t\t\t\tstruct tcf_proto *tp)\n{\n\tu32 hash = destroy_obj_hashfn(tp);\n\tstruct tcf_proto *iter;\n\tbool found = false;\n\n\trcu_read_lock();\n\thash_for_each_possible_rcu(chain->block->proto_destroy_ht, iter,\n\t\t\t\t   destroy_ht_node, hash) {\n\t\tif (tcf_proto_cmp(tp, iter)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}\n\nstatic void\ntcf_proto_signal_destroyed(struct tcf_chain *chain, struct tcf_proto *tp)\n{\n\tstruct tcf_block *block = chain->block;\n\n\tmutex_lock(&block->proto_destroy_lock);\n\tif (hash_hashed(&tp->destroy_ht_node))\n\t\thash_del_rcu(&tp->destroy_ht_node);\n\tmutex_unlock(&block->proto_destroy_lock);\n}\n\n \n\nstatic const struct tcf_proto_ops *__tcf_proto_lookup_ops(const char *kind)\n{\n\tconst struct tcf_proto_ops *t, *res = NULL;\n\n\tif (kind) {\n\t\tread_lock(&cls_mod_lock);\n\t\tlist_for_each_entry(t, &tcf_proto_base, head) {\n\t\t\tif (strcmp(kind, t->kind) == 0) {\n\t\t\t\tif (try_module_get(t->owner))\n\t\t\t\t\tres = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tread_unlock(&cls_mod_lock);\n\t}\n\treturn res;\n}\n\nstatic const struct tcf_proto_ops *\ntcf_proto_lookup_ops(const char *kind, bool rtnl_held,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tconst struct tcf_proto_ops *ops;\n\n\tops = __tcf_proto_lookup_ops(kind);\n\tif (ops)\n\t\treturn ops;\n#ifdef CONFIG_MODULES\n\tif (rtnl_held)\n\t\trtnl_unlock();\n\trequest_module(\"cls_%s\", kind);\n\tif (rtnl_held)\n\t\trtnl_lock();\n\tops = __tcf_proto_lookup_ops(kind);\n\t \n\tif (ops) {\n\t\tmodule_put(ops->owner);\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\tNL_SET_ERR_MSG(extack, \"TC classifier not found\");\n\treturn ERR_PTR(-ENOENT);\n}\n\n \n\nint register_tcf_proto_ops(struct tcf_proto_ops *ops)\n{\n\tstruct tcf_proto_ops *t;\n\tint rc = -EEXIST;\n\n\twrite_lock(&cls_mod_lock);\n\tlist_for_each_entry(t, &tcf_proto_base, head)\n\t\tif (!strcmp(ops->kind, t->kind))\n\t\t\tgoto out;\n\n\tlist_add_tail(&ops->head, &tcf_proto_base);\n\trc = 0;\nout:\n\twrite_unlock(&cls_mod_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL(register_tcf_proto_ops);\n\nstatic struct workqueue_struct *tc_filter_wq;\n\nvoid unregister_tcf_proto_ops(struct tcf_proto_ops *ops)\n{\n\tstruct tcf_proto_ops *t;\n\tint rc = -ENOENT;\n\n\t \n\trcu_barrier();\n\tflush_workqueue(tc_filter_wq);\n\n\twrite_lock(&cls_mod_lock);\n\tlist_for_each_entry(t, &tcf_proto_base, head) {\n\t\tif (t == ops) {\n\t\t\tlist_del(&t->head);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\twrite_unlock(&cls_mod_lock);\n\n\tWARN(rc, \"unregister tc filter kind(%s) failed %d\\n\", ops->kind, rc);\n}\nEXPORT_SYMBOL(unregister_tcf_proto_ops);\n\nbool tcf_queue_work(struct rcu_work *rwork, work_func_t func)\n{\n\tINIT_RCU_WORK(rwork, func);\n\treturn queue_rcu_work(tc_filter_wq, rwork);\n}\nEXPORT_SYMBOL(tcf_queue_work);\n\n \n\nstatic inline u32 tcf_auto_prio(struct tcf_proto *tp)\n{\n\tu32 first = TC_H_MAKE(0xC0000000U, 0U);\n\n\tif (tp)\n\t\tfirst = tp->prio - 1;\n\n\treturn TC_H_MAJ(first);\n}\n\nstatic bool tcf_proto_check_kind(struct nlattr *kind, char *name)\n{\n\tif (kind)\n\t\treturn nla_strscpy(name, kind, IFNAMSIZ) < 0;\n\tmemset(name, 0, IFNAMSIZ);\n\treturn false;\n}\n\nstatic bool tcf_proto_is_unlocked(const char *kind)\n{\n\tconst struct tcf_proto_ops *ops;\n\tbool ret;\n\n\tif (strlen(kind) == 0)\n\t\treturn false;\n\n\tops = tcf_proto_lookup_ops(kind, false, NULL);\n\t \n\tif (IS_ERR(ops))\n\t\treturn false;\n\n\tret = !!(ops->flags & TCF_PROTO_OPS_DOIT_UNLOCKED);\n\tmodule_put(ops->owner);\n\treturn ret;\n}\n\nstatic struct tcf_proto *tcf_proto_create(const char *kind, u32 protocol,\n\t\t\t\t\t  u32 prio, struct tcf_chain *chain,\n\t\t\t\t\t  bool rtnl_held,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct tcf_proto *tp;\n\tint err;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\ttp->ops = tcf_proto_lookup_ops(kind, rtnl_held, extack);\n\tif (IS_ERR(tp->ops)) {\n\t\terr = PTR_ERR(tp->ops);\n\t\tgoto errout;\n\t}\n\ttp->classify = tp->ops->classify;\n\ttp->protocol = protocol;\n\ttp->prio = prio;\n\ttp->chain = chain;\n\tspin_lock_init(&tp->lock);\n\trefcount_set(&tp->refcnt, 1);\n\n\terr = tp->ops->init(tp);\n\tif (err) {\n\t\tmodule_put(tp->ops->owner);\n\t\tgoto errout;\n\t}\n\treturn tp;\n\nerrout:\n\tkfree(tp);\n\treturn ERR_PTR(err);\n}\n\nstatic void tcf_proto_get(struct tcf_proto *tp)\n{\n\trefcount_inc(&tp->refcnt);\n}\n\nstatic void tcf_chain_put(struct tcf_chain *chain);\n\nstatic void tcf_proto_destroy(struct tcf_proto *tp, bool rtnl_held,\n\t\t\t      bool sig_destroy, struct netlink_ext_ack *extack)\n{\n\ttp->ops->destroy(tp, rtnl_held, extack);\n\tif (sig_destroy)\n\t\ttcf_proto_signal_destroyed(tp->chain, tp);\n\ttcf_chain_put(tp->chain);\n\tmodule_put(tp->ops->owner);\n\tkfree_rcu(tp, rcu);\n}\n\nstatic void tcf_proto_put(struct tcf_proto *tp, bool rtnl_held,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (refcount_dec_and_test(&tp->refcnt))\n\t\ttcf_proto_destroy(tp, rtnl_held, true, extack);\n}\n\nstatic bool tcf_proto_check_delete(struct tcf_proto *tp)\n{\n\tif (tp->ops->delete_empty)\n\t\treturn tp->ops->delete_empty(tp);\n\n\ttp->deleting = true;\n\treturn tp->deleting;\n}\n\nstatic void tcf_proto_mark_delete(struct tcf_proto *tp)\n{\n\tspin_lock(&tp->lock);\n\ttp->deleting = true;\n\tspin_unlock(&tp->lock);\n}\n\nstatic bool tcf_proto_is_deleting(struct tcf_proto *tp)\n{\n\tbool deleting;\n\n\tspin_lock(&tp->lock);\n\tdeleting = tp->deleting;\n\tspin_unlock(&tp->lock);\n\n\treturn deleting;\n}\n\n#define ASSERT_BLOCK_LOCKED(block)\t\t\t\t\t\\\n\tlockdep_assert_held(&(block)->lock)\n\nstruct tcf_filter_chain_list_item {\n\tstruct list_head list;\n\ttcf_chain_head_change_t *chain_head_change;\n\tvoid *chain_head_change_priv;\n};\n\nstatic struct tcf_chain *tcf_chain_create(struct tcf_block *block,\n\t\t\t\t\t  u32 chain_index)\n{\n\tstruct tcf_chain *chain;\n\n\tASSERT_BLOCK_LOCKED(block);\n\n\tchain = kzalloc(sizeof(*chain), GFP_KERNEL);\n\tif (!chain)\n\t\treturn NULL;\n\tlist_add_tail_rcu(&chain->list, &block->chain_list);\n\tmutex_init(&chain->filter_chain_lock);\n\tchain->block = block;\n\tchain->index = chain_index;\n\tchain->refcnt = 1;\n\tif (!chain->index)\n\t\tblock->chain0.chain = chain;\n\treturn chain;\n}\n\nstatic void tcf_chain_head_change_item(struct tcf_filter_chain_list_item *item,\n\t\t\t\t       struct tcf_proto *tp_head)\n{\n\tif (item->chain_head_change)\n\t\titem->chain_head_change(tp_head, item->chain_head_change_priv);\n}\n\nstatic void tcf_chain0_head_change(struct tcf_chain *chain,\n\t\t\t\t   struct tcf_proto *tp_head)\n{\n\tstruct tcf_filter_chain_list_item *item;\n\tstruct tcf_block *block = chain->block;\n\n\tif (chain->index)\n\t\treturn;\n\n\tmutex_lock(&block->lock);\n\tlist_for_each_entry(item, &block->chain0.filter_chain_list, list)\n\t\ttcf_chain_head_change_item(item, tp_head);\n\tmutex_unlock(&block->lock);\n}\n\n \n\nstatic bool tcf_chain_detach(struct tcf_chain *chain)\n{\n\tstruct tcf_block *block = chain->block;\n\n\tASSERT_BLOCK_LOCKED(block);\n\n\tlist_del_rcu(&chain->list);\n\tif (!chain->index)\n\t\tblock->chain0.chain = NULL;\n\n\tif (list_empty(&block->chain_list) &&\n\t    refcount_read(&block->refcnt) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void tcf_block_destroy(struct tcf_block *block)\n{\n\tmutex_destroy(&block->lock);\n\tmutex_destroy(&block->proto_destroy_lock);\n\tkfree_rcu(block, rcu);\n}\n\nstatic void tcf_chain_destroy(struct tcf_chain *chain, bool free_block)\n{\n\tstruct tcf_block *block = chain->block;\n\n\tmutex_destroy(&chain->filter_chain_lock);\n\tkfree_rcu(chain, rcu);\n\tif (free_block)\n\t\ttcf_block_destroy(block);\n}\n\nstatic void tcf_chain_hold(struct tcf_chain *chain)\n{\n\tASSERT_BLOCK_LOCKED(chain->block);\n\n\t++chain->refcnt;\n}\n\nstatic bool tcf_chain_held_by_acts_only(struct tcf_chain *chain)\n{\n\tASSERT_BLOCK_LOCKED(chain->block);\n\n\t \n\treturn chain->refcnt == chain->action_refcnt;\n}\n\nstatic struct tcf_chain *tcf_chain_lookup(struct tcf_block *block,\n\t\t\t\t\t  u32 chain_index)\n{\n\tstruct tcf_chain *chain;\n\n\tASSERT_BLOCK_LOCKED(block);\n\n\tlist_for_each_entry(chain, &block->chain_list, list) {\n\t\tif (chain->index == chain_index)\n\t\t\treturn chain;\n\t}\n\treturn NULL;\n}\n\n#if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)\nstatic struct tcf_chain *tcf_chain_lookup_rcu(const struct tcf_block *block,\n\t\t\t\t\t      u32 chain_index)\n{\n\tstruct tcf_chain *chain;\n\n\tlist_for_each_entry_rcu(chain, &block->chain_list, list) {\n\t\tif (chain->index == chain_index)\n\t\t\treturn chain;\n\t}\n\treturn NULL;\n}\n#endif\n\nstatic int tc_chain_notify(struct tcf_chain *chain, struct sk_buff *oskb,\n\t\t\t   u32 seq, u16 flags, int event, bool unicast,\n\t\t\t   struct netlink_ext_ack *extack);\n\nstatic struct tcf_chain *__tcf_chain_get(struct tcf_block *block,\n\t\t\t\t\t u32 chain_index, bool create,\n\t\t\t\t\t bool by_act)\n{\n\tstruct tcf_chain *chain = NULL;\n\tbool is_first_reference;\n\n\tmutex_lock(&block->lock);\n\tchain = tcf_chain_lookup(block, chain_index);\n\tif (chain) {\n\t\ttcf_chain_hold(chain);\n\t} else {\n\t\tif (!create)\n\t\t\tgoto errout;\n\t\tchain = tcf_chain_create(block, chain_index);\n\t\tif (!chain)\n\t\t\tgoto errout;\n\t}\n\n\tif (by_act)\n\t\t++chain->action_refcnt;\n\tis_first_reference = chain->refcnt - chain->action_refcnt == 1;\n\tmutex_unlock(&block->lock);\n\n\t \n\tif (is_first_reference && !by_act)\n\t\ttc_chain_notify(chain, NULL, 0, NLM_F_CREATE | NLM_F_EXCL,\n\t\t\t\tRTM_NEWCHAIN, false, NULL);\n\n\treturn chain;\n\nerrout:\n\tmutex_unlock(&block->lock);\n\treturn chain;\n}\n\nstatic struct tcf_chain *tcf_chain_get(struct tcf_block *block, u32 chain_index,\n\t\t\t\t       bool create)\n{\n\treturn __tcf_chain_get(block, chain_index, create, false);\n}\n\nstruct tcf_chain *tcf_chain_get_by_act(struct tcf_block *block, u32 chain_index)\n{\n\treturn __tcf_chain_get(block, chain_index, true, true);\n}\nEXPORT_SYMBOL(tcf_chain_get_by_act);\n\nstatic void tc_chain_tmplt_del(const struct tcf_proto_ops *tmplt_ops,\n\t\t\t       void *tmplt_priv);\nstatic int tc_chain_notify_delete(const struct tcf_proto_ops *tmplt_ops,\n\t\t\t\t  void *tmplt_priv, u32 chain_index,\n\t\t\t\t  struct tcf_block *block, struct sk_buff *oskb,\n\t\t\t\t  u32 seq, u16 flags, bool unicast);\n\nstatic void __tcf_chain_put(struct tcf_chain *chain, bool by_act,\n\t\t\t    bool explicitly_created)\n{\n\tstruct tcf_block *block = chain->block;\n\tconst struct tcf_proto_ops *tmplt_ops;\n\tunsigned int refcnt, non_act_refcnt;\n\tbool free_block = false;\n\tvoid *tmplt_priv;\n\n\tmutex_lock(&block->lock);\n\tif (explicitly_created) {\n\t\tif (!chain->explicitly_created) {\n\t\t\tmutex_unlock(&block->lock);\n\t\t\treturn;\n\t\t}\n\t\tchain->explicitly_created = false;\n\t}\n\n\tif (by_act)\n\t\tchain->action_refcnt--;\n\n\t \n\trefcnt = --chain->refcnt;\n\tnon_act_refcnt = refcnt - chain->action_refcnt;\n\ttmplt_ops = chain->tmplt_ops;\n\ttmplt_priv = chain->tmplt_priv;\n\n\tif (non_act_refcnt == chain->explicitly_created && !by_act) {\n\t\tif (non_act_refcnt == 0)\n\t\t\ttc_chain_notify_delete(tmplt_ops, tmplt_priv,\n\t\t\t\t\t       chain->index, block, NULL, 0, 0,\n\t\t\t\t\t       false);\n\t\t \n\t\tchain->flushing = false;\n\t}\n\n\tif (refcnt == 0)\n\t\tfree_block = tcf_chain_detach(chain);\n\tmutex_unlock(&block->lock);\n\n\tif (refcnt == 0) {\n\t\ttc_chain_tmplt_del(tmplt_ops, tmplt_priv);\n\t\ttcf_chain_destroy(chain, free_block);\n\t}\n}\n\nstatic void tcf_chain_put(struct tcf_chain *chain)\n{\n\t__tcf_chain_put(chain, false, false);\n}\n\nvoid tcf_chain_put_by_act(struct tcf_chain *chain)\n{\n\t__tcf_chain_put(chain, true, false);\n}\nEXPORT_SYMBOL(tcf_chain_put_by_act);\n\nstatic void tcf_chain_put_explicitly_created(struct tcf_chain *chain)\n{\n\t__tcf_chain_put(chain, false, true);\n}\n\nstatic void tcf_chain_flush(struct tcf_chain *chain, bool rtnl_held)\n{\n\tstruct tcf_proto *tp, *tp_next;\n\n\tmutex_lock(&chain->filter_chain_lock);\n\ttp = tcf_chain_dereference(chain->filter_chain, chain);\n\twhile (tp) {\n\t\ttp_next = rcu_dereference_protected(tp->next, 1);\n\t\ttcf_proto_signal_destroying(chain, tp);\n\t\ttp = tp_next;\n\t}\n\ttp = tcf_chain_dereference(chain->filter_chain, chain);\n\tRCU_INIT_POINTER(chain->filter_chain, NULL);\n\ttcf_chain0_head_change(chain, NULL);\n\tchain->flushing = true;\n\tmutex_unlock(&chain->filter_chain_lock);\n\n\twhile (tp) {\n\t\ttp_next = rcu_dereference_protected(tp->next, 1);\n\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\ttp = tp_next;\n\t}\n}\n\nstatic int tcf_block_setup(struct tcf_block *block,\n\t\t\t   struct flow_block_offload *bo);\n\nstatic void tcf_block_offload_init(struct flow_block_offload *bo,\n\t\t\t\t   struct net_device *dev, struct Qdisc *sch,\n\t\t\t\t   enum flow_block_command command,\n\t\t\t\t   enum flow_block_binder_type binder_type,\n\t\t\t\t   struct flow_block *flow_block,\n\t\t\t\t   bool shared, struct netlink_ext_ack *extack)\n{\n\tbo->net = dev_net(dev);\n\tbo->command = command;\n\tbo->binder_type = binder_type;\n\tbo->block = flow_block;\n\tbo->block_shared = shared;\n\tbo->extack = extack;\n\tbo->sch = sch;\n\tbo->cb_list_head = &flow_block->cb_list;\n\tINIT_LIST_HEAD(&bo->cb_list);\n}\n\nstatic void tcf_block_unbind(struct tcf_block *block,\n\t\t\t     struct flow_block_offload *bo);\n\nstatic void tc_block_indr_cleanup(struct flow_block_cb *block_cb)\n{\n\tstruct tcf_block *block = block_cb->indr.data;\n\tstruct net_device *dev = block_cb->indr.dev;\n\tstruct Qdisc *sch = block_cb->indr.sch;\n\tstruct netlink_ext_ack extack = {};\n\tstruct flow_block_offload bo = {};\n\n\ttcf_block_offload_init(&bo, dev, sch, FLOW_BLOCK_UNBIND,\n\t\t\t       block_cb->indr.binder_type,\n\t\t\t       &block->flow_block, tcf_block_shared(block),\n\t\t\t       &extack);\n\trtnl_lock();\n\tdown_write(&block->cb_lock);\n\tlist_del(&block_cb->driver_list);\n\tlist_move(&block_cb->list, &bo.cb_list);\n\ttcf_block_unbind(block, &bo);\n\tup_write(&block->cb_lock);\n\trtnl_unlock();\n}\n\nstatic bool tcf_block_offload_in_use(struct tcf_block *block)\n{\n\treturn atomic_read(&block->offloadcnt);\n}\n\nstatic int tcf_block_offload_cmd(struct tcf_block *block,\n\t\t\t\t struct net_device *dev, struct Qdisc *sch,\n\t\t\t\t struct tcf_block_ext_info *ei,\n\t\t\t\t enum flow_block_command command,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct flow_block_offload bo = {};\n\n\ttcf_block_offload_init(&bo, dev, sch, command, ei->binder_type,\n\t\t\t       &block->flow_block, tcf_block_shared(block),\n\t\t\t       extack);\n\n\tif (dev->netdev_ops->ndo_setup_tc) {\n\t\tint err;\n\n\t\terr = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_BLOCK, &bo);\n\t\tif (err < 0) {\n\t\t\tif (err != -EOPNOTSUPP)\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Driver ndo_setup_tc failed\");\n\t\t\treturn err;\n\t\t}\n\n\t\treturn tcf_block_setup(block, &bo);\n\t}\n\n\tflow_indr_dev_setup_offload(dev, sch, TC_SETUP_BLOCK, block, &bo,\n\t\t\t\t    tc_block_indr_cleanup);\n\ttcf_block_setup(block, &bo);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int tcf_block_offload_bind(struct tcf_block *block, struct Qdisc *q,\n\t\t\t\t  struct tcf_block_ext_info *ei,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = q->dev_queue->dev;\n\tint err;\n\n\tdown_write(&block->cb_lock);\n\n\t \n\tif (dev->netdev_ops->ndo_setup_tc &&\n\t    !tc_can_offload(dev) &&\n\t    tcf_block_offload_in_use(block)) {\n\t\tNL_SET_ERR_MSG(extack, \"Bind to offloaded block failed as dev has offload disabled\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_unlock;\n\t}\n\n\terr = tcf_block_offload_cmd(block, dev, q, ei, FLOW_BLOCK_BIND, extack);\n\tif (err == -EOPNOTSUPP)\n\t\tgoto no_offload_dev_inc;\n\tif (err)\n\t\tgoto err_unlock;\n\n\tup_write(&block->cb_lock);\n\treturn 0;\n\nno_offload_dev_inc:\n\tif (tcf_block_offload_in_use(block))\n\t\tgoto err_unlock;\n\n\terr = 0;\n\tblock->nooffloaddevcnt++;\nerr_unlock:\n\tup_write(&block->cb_lock);\n\treturn err;\n}\n\nstatic void tcf_block_offload_unbind(struct tcf_block *block, struct Qdisc *q,\n\t\t\t\t     struct tcf_block_ext_info *ei)\n{\n\tstruct net_device *dev = q->dev_queue->dev;\n\tint err;\n\n\tdown_write(&block->cb_lock);\n\terr = tcf_block_offload_cmd(block, dev, q, ei, FLOW_BLOCK_UNBIND, NULL);\n\tif (err == -EOPNOTSUPP)\n\t\tgoto no_offload_dev_dec;\n\tup_write(&block->cb_lock);\n\treturn;\n\nno_offload_dev_dec:\n\tWARN_ON(block->nooffloaddevcnt-- == 0);\n\tup_write(&block->cb_lock);\n}\n\nstatic int\ntcf_chain0_head_change_cb_add(struct tcf_block *block,\n\t\t\t      struct tcf_block_ext_info *ei,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct tcf_filter_chain_list_item *item;\n\tstruct tcf_chain *chain0;\n\n\titem = kmalloc(sizeof(*item), GFP_KERNEL);\n\tif (!item) {\n\t\tNL_SET_ERR_MSG(extack, \"Memory allocation for head change callback item failed\");\n\t\treturn -ENOMEM;\n\t}\n\titem->chain_head_change = ei->chain_head_change;\n\titem->chain_head_change_priv = ei->chain_head_change_priv;\n\n\tmutex_lock(&block->lock);\n\tchain0 = block->chain0.chain;\n\tif (chain0)\n\t\ttcf_chain_hold(chain0);\n\telse\n\t\tlist_add(&item->list, &block->chain0.filter_chain_list);\n\tmutex_unlock(&block->lock);\n\n\tif (chain0) {\n\t\tstruct tcf_proto *tp_head;\n\n\t\tmutex_lock(&chain0->filter_chain_lock);\n\n\t\ttp_head = tcf_chain_dereference(chain0->filter_chain, chain0);\n\t\tif (tp_head)\n\t\t\ttcf_chain_head_change_item(item, tp_head);\n\n\t\tmutex_lock(&block->lock);\n\t\tlist_add(&item->list, &block->chain0.filter_chain_list);\n\t\tmutex_unlock(&block->lock);\n\n\t\tmutex_unlock(&chain0->filter_chain_lock);\n\t\ttcf_chain_put(chain0);\n\t}\n\n\treturn 0;\n}\n\nstatic void\ntcf_chain0_head_change_cb_del(struct tcf_block *block,\n\t\t\t      struct tcf_block_ext_info *ei)\n{\n\tstruct tcf_filter_chain_list_item *item;\n\n\tmutex_lock(&block->lock);\n\tlist_for_each_entry(item, &block->chain0.filter_chain_list, list) {\n\t\tif ((!ei->chain_head_change && !ei->chain_head_change_priv) ||\n\t\t    (item->chain_head_change == ei->chain_head_change &&\n\t\t     item->chain_head_change_priv == ei->chain_head_change_priv)) {\n\t\t\tif (block->chain0.chain)\n\t\t\t\ttcf_chain_head_change_item(item, NULL);\n\t\t\tlist_del(&item->list);\n\t\t\tmutex_unlock(&block->lock);\n\n\t\t\tkfree(item);\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&block->lock);\n\tWARN_ON(1);\n}\n\nstruct tcf_net {\n\tspinlock_t idr_lock;  \n\tstruct idr idr;\n};\n\nstatic unsigned int tcf_net_id;\n\nstatic int tcf_block_insert(struct tcf_block *block, struct net *net,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct tcf_net *tn = net_generic(net, tcf_net_id);\n\tint err;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&tn->idr_lock);\n\terr = idr_alloc_u32(&tn->idr, block, &block->index, block->index,\n\t\t\t    GFP_NOWAIT);\n\tspin_unlock(&tn->idr_lock);\n\tidr_preload_end();\n\n\treturn err;\n}\n\nstatic void tcf_block_remove(struct tcf_block *block, struct net *net)\n{\n\tstruct tcf_net *tn = net_generic(net, tcf_net_id);\n\n\tspin_lock(&tn->idr_lock);\n\tidr_remove(&tn->idr, block->index);\n\tspin_unlock(&tn->idr_lock);\n}\n\nstatic struct tcf_block *tcf_block_create(struct net *net, struct Qdisc *q,\n\t\t\t\t\t  u32 block_index,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block;\n\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (!block) {\n\t\tNL_SET_ERR_MSG(extack, \"Memory allocation for block failed\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&block->lock);\n\tmutex_init(&block->proto_destroy_lock);\n\tinit_rwsem(&block->cb_lock);\n\tflow_block_init(&block->flow_block);\n\tINIT_LIST_HEAD(&block->chain_list);\n\tINIT_LIST_HEAD(&block->owner_list);\n\tINIT_LIST_HEAD(&block->chain0.filter_chain_list);\n\n\trefcount_set(&block->refcnt, 1);\n\tblock->net = net;\n\tblock->index = block_index;\n\n\t \n\tif (!tcf_block_shared(block))\n\t\tblock->q = q;\n\treturn block;\n}\n\nstatic struct tcf_block *tcf_block_lookup(struct net *net, u32 block_index)\n{\n\tstruct tcf_net *tn = net_generic(net, tcf_net_id);\n\n\treturn idr_find(&tn->idr, block_index);\n}\n\nstatic struct tcf_block *tcf_block_refcnt_get(struct net *net, u32 block_index)\n{\n\tstruct tcf_block *block;\n\n\trcu_read_lock();\n\tblock = tcf_block_lookup(net, block_index);\n\tif (block && !refcount_inc_not_zero(&block->refcnt))\n\t\tblock = NULL;\n\trcu_read_unlock();\n\n\treturn block;\n}\n\nstatic struct tcf_chain *\n__tcf_get_next_chain(struct tcf_block *block, struct tcf_chain *chain)\n{\n\tmutex_lock(&block->lock);\n\tif (chain)\n\t\tchain = list_is_last(&chain->list, &block->chain_list) ?\n\t\t\tNULL : list_next_entry(chain, list);\n\telse\n\t\tchain = list_first_entry_or_null(&block->chain_list,\n\t\t\t\t\t\t struct tcf_chain, list);\n\n\t \n\twhile (chain && tcf_chain_held_by_acts_only(chain))\n\t\tchain = list_is_last(&chain->list, &block->chain_list) ?\n\t\t\tNULL : list_next_entry(chain, list);\n\n\tif (chain)\n\t\ttcf_chain_hold(chain);\n\tmutex_unlock(&block->lock);\n\n\treturn chain;\n}\n\n \n\nstruct tcf_chain *\ntcf_get_next_chain(struct tcf_block *block, struct tcf_chain *chain)\n{\n\tstruct tcf_chain *chain_next = __tcf_get_next_chain(block, chain);\n\n\tif (chain)\n\t\ttcf_chain_put(chain);\n\n\treturn chain_next;\n}\nEXPORT_SYMBOL(tcf_get_next_chain);\n\nstatic struct tcf_proto *\n__tcf_get_next_proto(struct tcf_chain *chain, struct tcf_proto *tp)\n{\n\tu32 prio = 0;\n\n\tASSERT_RTNL();\n\tmutex_lock(&chain->filter_chain_lock);\n\n\tif (!tp) {\n\t\ttp = tcf_chain_dereference(chain->filter_chain, chain);\n\t} else if (tcf_proto_is_deleting(tp)) {\n\t\t \n\t\tprio = tp->prio + 1;\n\t\ttp = tcf_chain_dereference(chain->filter_chain, chain);\n\n\t\tfor (; tp; tp = tcf_chain_dereference(tp->next, chain))\n\t\t\tif (!tp->deleting && tp->prio >= prio)\n\t\t\t\tbreak;\n\t} else {\n\t\ttp = tcf_chain_dereference(tp->next, chain);\n\t}\n\n\tif (tp)\n\t\ttcf_proto_get(tp);\n\n\tmutex_unlock(&chain->filter_chain_lock);\n\n\treturn tp;\n}\n\n \n\nstruct tcf_proto *\ntcf_get_next_proto(struct tcf_chain *chain, struct tcf_proto *tp)\n{\n\tstruct tcf_proto *tp_next = __tcf_get_next_proto(chain, tp);\n\n\tif (tp)\n\t\ttcf_proto_put(tp, true, NULL);\n\n\treturn tp_next;\n}\nEXPORT_SYMBOL(tcf_get_next_proto);\n\nstatic void tcf_block_flush_all_chains(struct tcf_block *block, bool rtnl_held)\n{\n\tstruct tcf_chain *chain;\n\n\t \n\tfor (chain = tcf_get_next_chain(block, NULL);\n\t     chain;\n\t     chain = tcf_get_next_chain(block, chain)) {\n\t\ttcf_chain_put_explicitly_created(chain);\n\t\ttcf_chain_flush(chain, rtnl_held);\n\t}\n}\n\n \n\nstatic int __tcf_qdisc_find(struct net *net, struct Qdisc **q,\n\t\t\t    u32 *parent, int ifindex, bool rtnl_held,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tconst struct Qdisc_class_ops *cops;\n\tstruct net_device *dev;\n\tint err = 0;\n\n\tif (ifindex == TCM_IFINDEX_MAGIC_BLOCK)\n\t\treturn 0;\n\n\trcu_read_lock();\n\n\t \n\tdev = dev_get_by_index_rcu(net, ifindex);\n\tif (!dev) {\n\t\trcu_read_unlock();\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!*parent) {\n\t\t*q = rcu_dereference(dev->qdisc);\n\t\t*parent = (*q)->handle;\n\t} else {\n\t\t*q = qdisc_lookup_rcu(dev, TC_H_MAJ(*parent));\n\t\tif (!*q) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Parent Qdisc doesn't exists\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_rcu;\n\t\t}\n\t}\n\n\t*q = qdisc_refcount_inc_nz(*q);\n\tif (!*q) {\n\t\tNL_SET_ERR_MSG(extack, \"Parent Qdisc doesn't exists\");\n\t\terr = -EINVAL;\n\t\tgoto errout_rcu;\n\t}\n\n\t \n\tcops = (*q)->ops->cl_ops;\n\tif (!cops) {\n\t\tNL_SET_ERR_MSG(extack, \"Qdisc not classful\");\n\t\terr = -EINVAL;\n\t\tgoto errout_qdisc;\n\t}\n\n\tif (!cops->tcf_block) {\n\t\tNL_SET_ERR_MSG(extack, \"Class doesn't support blocks\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto errout_qdisc;\n\t}\n\nerrout_rcu:\n\t \n\trcu_read_unlock();\n\treturn err;\n\nerrout_qdisc:\n\trcu_read_unlock();\n\n\tif (rtnl_held)\n\t\tqdisc_put(*q);\n\telse\n\t\tqdisc_put_unlocked(*q);\n\t*q = NULL;\n\n\treturn err;\n}\n\nstatic int __tcf_qdisc_cl_find(struct Qdisc *q, u32 parent, unsigned long *cl,\n\t\t\t       int ifindex, struct netlink_ext_ack *extack)\n{\n\tif (ifindex == TCM_IFINDEX_MAGIC_BLOCK)\n\t\treturn 0;\n\n\t \n\tif (TC_H_MIN(parent)) {\n\t\tconst struct Qdisc_class_ops *cops = q->ops->cl_ops;\n\n\t\t*cl = cops->find(q, parent);\n\t\tif (*cl == 0) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Specified class doesn't exist\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct tcf_block *__tcf_block_find(struct net *net, struct Qdisc *q,\n\t\t\t\t\t  unsigned long cl, int ifindex,\n\t\t\t\t\t  u32 block_index,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block;\n\n\tif (ifindex == TCM_IFINDEX_MAGIC_BLOCK) {\n\t\tblock = tcf_block_refcnt_get(net, block_index);\n\t\tif (!block) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Block of given index was not found\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else {\n\t\tconst struct Qdisc_class_ops *cops = q->ops->cl_ops;\n\n\t\tblock = cops->tcf_block(q, cl, extack);\n\t\tif (!block)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tif (tcf_block_shared(block)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"This filter block is shared. Please use the block index to manipulate the filters\");\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t\t}\n\n\t\t \n\t\trefcount_inc(&block->refcnt);\n\t}\n\n\treturn block;\n}\n\nstatic void __tcf_block_put(struct tcf_block *block, struct Qdisc *q,\n\t\t\t    struct tcf_block_ext_info *ei, bool rtnl_held)\n{\n\tif (refcount_dec_and_mutex_lock(&block->refcnt, &block->lock)) {\n\t\t \n\t\tbool free_block = list_empty(&block->chain_list);\n\n\t\tmutex_unlock(&block->lock);\n\t\tif (tcf_block_shared(block))\n\t\t\ttcf_block_remove(block, block->net);\n\n\t\tif (q)\n\t\t\ttcf_block_offload_unbind(block, q, ei);\n\n\t\tif (free_block)\n\t\t\ttcf_block_destroy(block);\n\t\telse\n\t\t\ttcf_block_flush_all_chains(block, rtnl_held);\n\t} else if (q) {\n\t\ttcf_block_offload_unbind(block, q, ei);\n\t}\n}\n\nstatic void tcf_block_refcnt_put(struct tcf_block *block, bool rtnl_held)\n{\n\t__tcf_block_put(block, NULL, NULL, rtnl_held);\n}\n\n \n\nstatic struct tcf_block *tcf_block_find(struct net *net, struct Qdisc **q,\n\t\t\t\t\tu32 *parent, unsigned long *cl,\n\t\t\t\t\tint ifindex, u32 block_index,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block;\n\tint err = 0;\n\n\tASSERT_RTNL();\n\n\terr = __tcf_qdisc_find(net, q, parent, ifindex, true, extack);\n\tif (err)\n\t\tgoto errout;\n\n\terr = __tcf_qdisc_cl_find(*q, *parent, cl, ifindex, extack);\n\tif (err)\n\t\tgoto errout_qdisc;\n\n\tblock = __tcf_block_find(net, *q, *cl, ifindex, block_index, extack);\n\tif (IS_ERR(block)) {\n\t\terr = PTR_ERR(block);\n\t\tgoto errout_qdisc;\n\t}\n\n\treturn block;\n\nerrout_qdisc:\n\tif (*q)\n\t\tqdisc_put(*q);\nerrout:\n\t*q = NULL;\n\treturn ERR_PTR(err);\n}\n\nstatic void tcf_block_release(struct Qdisc *q, struct tcf_block *block,\n\t\t\t      bool rtnl_held)\n{\n\tif (!IS_ERR_OR_NULL(block))\n\t\ttcf_block_refcnt_put(block, rtnl_held);\n\n\tif (q) {\n\t\tif (rtnl_held)\n\t\t\tqdisc_put(q);\n\t\telse\n\t\t\tqdisc_put_unlocked(q);\n\t}\n}\n\nstruct tcf_block_owner_item {\n\tstruct list_head list;\n\tstruct Qdisc *q;\n\tenum flow_block_binder_type binder_type;\n};\n\nstatic void\ntcf_block_owner_netif_keep_dst(struct tcf_block *block,\n\t\t\t       struct Qdisc *q,\n\t\t\t       enum flow_block_binder_type binder_type)\n{\n\tif (block->keep_dst &&\n\t    binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS &&\n\t    binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS)\n\t\tnetif_keep_dst(qdisc_dev(q));\n}\n\nvoid tcf_block_netif_keep_dst(struct tcf_block *block)\n{\n\tstruct tcf_block_owner_item *item;\n\n\tblock->keep_dst = true;\n\tlist_for_each_entry(item, &block->owner_list, list)\n\t\ttcf_block_owner_netif_keep_dst(block, item->q,\n\t\t\t\t\t       item->binder_type);\n}\nEXPORT_SYMBOL(tcf_block_netif_keep_dst);\n\nstatic int tcf_block_owner_add(struct tcf_block *block,\n\t\t\t       struct Qdisc *q,\n\t\t\t       enum flow_block_binder_type binder_type)\n{\n\tstruct tcf_block_owner_item *item;\n\n\titem = kmalloc(sizeof(*item), GFP_KERNEL);\n\tif (!item)\n\t\treturn -ENOMEM;\n\titem->q = q;\n\titem->binder_type = binder_type;\n\tlist_add(&item->list, &block->owner_list);\n\treturn 0;\n}\n\nstatic void tcf_block_owner_del(struct tcf_block *block,\n\t\t\t\tstruct Qdisc *q,\n\t\t\t\tenum flow_block_binder_type binder_type)\n{\n\tstruct tcf_block_owner_item *item;\n\n\tlist_for_each_entry(item, &block->owner_list, list) {\n\t\tif (item->q == q && item->binder_type == binder_type) {\n\t\t\tlist_del(&item->list);\n\t\t\tkfree(item);\n\t\t\treturn;\n\t\t}\n\t}\n\tWARN_ON(1);\n}\n\nint tcf_block_get_ext(struct tcf_block **p_block, struct Qdisc *q,\n\t\t      struct tcf_block_ext_info *ei,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net *net = qdisc_net(q);\n\tstruct tcf_block *block = NULL;\n\tint err;\n\n\tif (ei->block_index)\n\t\t \n\t\tblock = tcf_block_refcnt_get(net, ei->block_index);\n\n\tif (!block) {\n\t\tblock = tcf_block_create(net, q, ei->block_index, extack);\n\t\tif (IS_ERR(block))\n\t\t\treturn PTR_ERR(block);\n\t\tif (tcf_block_shared(block)) {\n\t\t\terr = tcf_block_insert(block, net, extack);\n\t\t\tif (err)\n\t\t\t\tgoto err_block_insert;\n\t\t}\n\t}\n\n\terr = tcf_block_owner_add(block, q, ei->binder_type);\n\tif (err)\n\t\tgoto err_block_owner_add;\n\n\ttcf_block_owner_netif_keep_dst(block, q, ei->binder_type);\n\n\terr = tcf_chain0_head_change_cb_add(block, ei, extack);\n\tif (err)\n\t\tgoto err_chain0_head_change_cb_add;\n\n\terr = tcf_block_offload_bind(block, q, ei, extack);\n\tif (err)\n\t\tgoto err_block_offload_bind;\n\n\t*p_block = block;\n\treturn 0;\n\nerr_block_offload_bind:\n\ttcf_chain0_head_change_cb_del(block, ei);\nerr_chain0_head_change_cb_add:\n\ttcf_block_owner_del(block, q, ei->binder_type);\nerr_block_owner_add:\nerr_block_insert:\n\ttcf_block_refcnt_put(block, true);\n\treturn err;\n}\nEXPORT_SYMBOL(tcf_block_get_ext);\n\nstatic void tcf_chain_head_change_dflt(struct tcf_proto *tp_head, void *priv)\n{\n\tstruct tcf_proto __rcu **p_filter_chain = priv;\n\n\trcu_assign_pointer(*p_filter_chain, tp_head);\n}\n\nint tcf_block_get(struct tcf_block **p_block,\n\t\t  struct tcf_proto __rcu **p_filter_chain, struct Qdisc *q,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct tcf_block_ext_info ei = {\n\t\t.chain_head_change = tcf_chain_head_change_dflt,\n\t\t.chain_head_change_priv = p_filter_chain,\n\t};\n\n\tWARN_ON(!p_filter_chain);\n\treturn tcf_block_get_ext(p_block, q, &ei, extack);\n}\nEXPORT_SYMBOL(tcf_block_get);\n\n \nvoid tcf_block_put_ext(struct tcf_block *block, struct Qdisc *q,\n\t\t       struct tcf_block_ext_info *ei)\n{\n\tif (!block)\n\t\treturn;\n\ttcf_chain0_head_change_cb_del(block, ei);\n\ttcf_block_owner_del(block, q, ei->binder_type);\n\n\t__tcf_block_put(block, q, ei, true);\n}\nEXPORT_SYMBOL(tcf_block_put_ext);\n\nvoid tcf_block_put(struct tcf_block *block)\n{\n\tstruct tcf_block_ext_info ei = {0, };\n\n\tif (!block)\n\t\treturn;\n\ttcf_block_put_ext(block, block->q, &ei);\n}\n\nEXPORT_SYMBOL(tcf_block_put);\n\nstatic int\ntcf_block_playback_offloads(struct tcf_block *block, flow_setup_cb_t *cb,\n\t\t\t    void *cb_priv, bool add, bool offload_in_use,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct tcf_chain *chain, *chain_prev;\n\tstruct tcf_proto *tp, *tp_prev;\n\tint err;\n\n\tlockdep_assert_held(&block->cb_lock);\n\n\tfor (chain = __tcf_get_next_chain(block, NULL);\n\t     chain;\n\t     chain_prev = chain,\n\t\t     chain = __tcf_get_next_chain(block, chain),\n\t\t     tcf_chain_put(chain_prev)) {\n\t\tfor (tp = __tcf_get_next_proto(chain, NULL); tp;\n\t\t     tp_prev = tp,\n\t\t\t     tp = __tcf_get_next_proto(chain, tp),\n\t\t\t     tcf_proto_put(tp_prev, true, NULL)) {\n\t\t\tif (tp->ops->reoffload) {\n\t\t\t\terr = tp->ops->reoffload(tp, add, cb, cb_priv,\n\t\t\t\t\t\t\t extack);\n\t\t\t\tif (err && add)\n\t\t\t\t\tgoto err_playback_remove;\n\t\t\t} else if (add && offload_in_use) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Filter HW offload failed - classifier without re-offloading support\");\n\t\t\t\tgoto err_playback_remove;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_playback_remove:\n\ttcf_proto_put(tp, true, NULL);\n\ttcf_chain_put(chain);\n\ttcf_block_playback_offloads(block, cb, cb_priv, false, offload_in_use,\n\t\t\t\t    extack);\n\treturn err;\n}\n\nstatic int tcf_block_bind(struct tcf_block *block,\n\t\t\t  struct flow_block_offload *bo)\n{\n\tstruct flow_block_cb *block_cb, *next;\n\tint err, i = 0;\n\n\tlockdep_assert_held(&block->cb_lock);\n\n\tlist_for_each_entry(block_cb, &bo->cb_list, list) {\n\t\terr = tcf_block_playback_offloads(block, block_cb->cb,\n\t\t\t\t\t\t  block_cb->cb_priv, true,\n\t\t\t\t\t\t  tcf_block_offload_in_use(block),\n\t\t\t\t\t\t  bo->extack);\n\t\tif (err)\n\t\t\tgoto err_unroll;\n\t\tif (!bo->unlocked_driver_cb)\n\t\t\tblock->lockeddevcnt++;\n\n\t\ti++;\n\t}\n\tlist_splice(&bo->cb_list, &block->flow_block.cb_list);\n\n\treturn 0;\n\nerr_unroll:\n\tlist_for_each_entry_safe(block_cb, next, &bo->cb_list, list) {\n\t\tlist_del(&block_cb->driver_list);\n\t\tif (i-- > 0) {\n\t\t\tlist_del(&block_cb->list);\n\t\t\ttcf_block_playback_offloads(block, block_cb->cb,\n\t\t\t\t\t\t    block_cb->cb_priv, false,\n\t\t\t\t\t\t    tcf_block_offload_in_use(block),\n\t\t\t\t\t\t    NULL);\n\t\t\tif (!bo->unlocked_driver_cb)\n\t\t\t\tblock->lockeddevcnt--;\n\t\t}\n\t\tflow_block_cb_free(block_cb);\n\t}\n\n\treturn err;\n}\n\nstatic void tcf_block_unbind(struct tcf_block *block,\n\t\t\t     struct flow_block_offload *bo)\n{\n\tstruct flow_block_cb *block_cb, *next;\n\n\tlockdep_assert_held(&block->cb_lock);\n\n\tlist_for_each_entry_safe(block_cb, next, &bo->cb_list, list) {\n\t\ttcf_block_playback_offloads(block, block_cb->cb,\n\t\t\t\t\t    block_cb->cb_priv, false,\n\t\t\t\t\t    tcf_block_offload_in_use(block),\n\t\t\t\t\t    NULL);\n\t\tlist_del(&block_cb->list);\n\t\tflow_block_cb_free(block_cb);\n\t\tif (!bo->unlocked_driver_cb)\n\t\t\tblock->lockeddevcnt--;\n\t}\n}\n\nstatic int tcf_block_setup(struct tcf_block *block,\n\t\t\t   struct flow_block_offload *bo)\n{\n\tint err;\n\n\tswitch (bo->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\terr = tcf_block_bind(block, bo);\n\t\tbreak;\n\tcase FLOW_BLOCK_UNBIND:\n\t\terr = 0;\n\t\ttcf_block_unbind(block, bo);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\n \nstatic inline int __tcf_classify(struct sk_buff *skb,\n\t\t\t\t const struct tcf_proto *tp,\n\t\t\t\t const struct tcf_proto *orig_tp,\n\t\t\t\t struct tcf_result *res,\n\t\t\t\t bool compat_mode,\n\t\t\t\t struct tcf_exts_miss_cookie_node *n,\n\t\t\t\t int act_index,\n\t\t\t\t u32 *last_executed_chain)\n{\n#ifdef CONFIG_NET_CLS_ACT\n\tconst int max_reclassify_loop = 16;\n\tconst struct tcf_proto *first_tp;\n\tint limit = 0;\n\nreclassify:\n#endif\n\tfor (; tp; tp = rcu_dereference_bh(tp->next)) {\n\t\t__be16 protocol = skb_protocol(skb, false);\n\t\tint err = 0;\n\n\t\tif (n) {\n\t\t\tstruct tcf_exts *exts;\n\n\t\t\tif (n->tp_prio != tp->prio)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (unlikely(n->tp != tp || n->tp->chain != n->chain ||\n\t\t\t\t     !tp->ops->get_exts))\n\t\t\t\treturn TC_ACT_SHOT;\n\n\t\t\texts = tp->ops->get_exts(tp, n->handle);\n\t\t\tif (unlikely(!exts || n->exts != exts))\n\t\t\t\treturn TC_ACT_SHOT;\n\n\t\t\tn = NULL;\n\t\t\terr = tcf_exts_exec_ex(skb, exts, act_index, res);\n\t\t} else {\n\t\t\tif (tp->protocol != protocol &&\n\t\t\t    tp->protocol != htons(ETH_P_ALL))\n\t\t\t\tcontinue;\n\n\t\t\terr = tc_classify(skb, tp, res);\n\t\t}\n#ifdef CONFIG_NET_CLS_ACT\n\t\tif (unlikely(err == TC_ACT_RECLASSIFY && !compat_mode)) {\n\t\t\tfirst_tp = orig_tp;\n\t\t\t*last_executed_chain = first_tp->chain->index;\n\t\t\tgoto reset;\n\t\t} else if (unlikely(TC_ACT_EXT_CMP(err, TC_ACT_GOTO_CHAIN))) {\n\t\t\tfirst_tp = res->goto_tp;\n\t\t\t*last_executed_chain = err & TC_ACT_EXT_VAL_MASK;\n\t\t\tgoto reset;\n\t\t}\n#endif\n\t\tif (err >= 0)\n\t\t\treturn err;\n\t}\n\n\tif (unlikely(n))\n\t\treturn TC_ACT_SHOT;\n\n\treturn TC_ACT_UNSPEC;  \n#ifdef CONFIG_NET_CLS_ACT\nreset:\n\tif (unlikely(limit++ >= max_reclassify_loop)) {\n\t\tnet_notice_ratelimited(\"%u: reclassify loop, rule prio %u, protocol %02x\\n\",\n\t\t\t\t       tp->chain->block->index,\n\t\t\t\t       tp->prio & 0xffff,\n\t\t\t\t       ntohs(tp->protocol));\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\ttp = first_tp;\n\tgoto reclassify;\n#endif\n}\n\nint tcf_classify(struct sk_buff *skb,\n\t\t const struct tcf_block *block,\n\t\t const struct tcf_proto *tp,\n\t\t struct tcf_result *res, bool compat_mode)\n{\n#if !IS_ENABLED(CONFIG_NET_TC_SKB_EXT)\n\tu32 last_executed_chain = 0;\n\n\treturn __tcf_classify(skb, tp, tp, res, compat_mode, NULL, 0,\n\t\t\t      &last_executed_chain);\n#else\n\tu32 last_executed_chain = tp ? tp->chain->index : 0;\n\tstruct tcf_exts_miss_cookie_node *n = NULL;\n\tconst struct tcf_proto *orig_tp = tp;\n\tstruct tc_skb_ext *ext;\n\tint act_index = 0;\n\tint ret;\n\n\tif (block) {\n\t\text = skb_ext_find(skb, TC_SKB_EXT);\n\n\t\tif (ext && (ext->chain || ext->act_miss)) {\n\t\t\tstruct tcf_chain *fchain;\n\t\t\tu32 chain;\n\n\t\t\tif (ext->act_miss) {\n\t\t\t\tn = tcf_exts_miss_cookie_lookup(ext->act_miss_cookie,\n\t\t\t\t\t\t\t\t&act_index);\n\t\t\t\tif (!n)\n\t\t\t\t\treturn TC_ACT_SHOT;\n\n\t\t\t\tchain = n->chain_index;\n\t\t\t} else {\n\t\t\t\tchain = ext->chain;\n\t\t\t}\n\n\t\t\tfchain = tcf_chain_lookup_rcu(block, chain);\n\t\t\tif (!fchain)\n\t\t\t\treturn TC_ACT_SHOT;\n\n\t\t\t \n\t\t\tskb_ext_del(skb, TC_SKB_EXT);\n\n\t\t\ttp = rcu_dereference_bh(fchain->filter_chain);\n\t\t\tlast_executed_chain = fchain->index;\n\t\t}\n\t}\n\n\tret = __tcf_classify(skb, tp, orig_tp, res, compat_mode, n, act_index,\n\t\t\t     &last_executed_chain);\n\n\tif (tc_skb_ext_tc_enabled()) {\n\t\t \n\t\tif (ret == TC_ACT_UNSPEC && last_executed_chain) {\n\t\t\tstruct tc_skb_cb *cb = tc_skb_cb(skb);\n\n\t\t\text = tc_skb_ext_alloc(skb);\n\t\t\tif (WARN_ON_ONCE(!ext))\n\t\t\t\treturn TC_ACT_SHOT;\n\t\t\text->chain = last_executed_chain;\n\t\t\text->mru = cb->mru;\n\t\t\text->post_ct = cb->post_ct;\n\t\t\text->post_ct_snat = cb->post_ct_snat;\n\t\t\text->post_ct_dnat = cb->post_ct_dnat;\n\t\t\text->zone = cb->zone;\n\t\t}\n\t}\n\n\treturn ret;\n#endif\n}\nEXPORT_SYMBOL(tcf_classify);\n\nstruct tcf_chain_info {\n\tstruct tcf_proto __rcu **pprev;\n\tstruct tcf_proto __rcu *next;\n};\n\nstatic struct tcf_proto *tcf_chain_tp_prev(struct tcf_chain *chain,\n\t\t\t\t\t   struct tcf_chain_info *chain_info)\n{\n\treturn tcf_chain_dereference(*chain_info->pprev, chain);\n}\n\nstatic int tcf_chain_tp_insert(struct tcf_chain *chain,\n\t\t\t       struct tcf_chain_info *chain_info,\n\t\t\t       struct tcf_proto *tp)\n{\n\tif (chain->flushing)\n\t\treturn -EAGAIN;\n\n\tRCU_INIT_POINTER(tp->next, tcf_chain_tp_prev(chain, chain_info));\n\tif (*chain_info->pprev == chain->filter_chain)\n\t\ttcf_chain0_head_change(chain, tp);\n\ttcf_proto_get(tp);\n\trcu_assign_pointer(*chain_info->pprev, tp);\n\n\treturn 0;\n}\n\nstatic void tcf_chain_tp_remove(struct tcf_chain *chain,\n\t\t\t\tstruct tcf_chain_info *chain_info,\n\t\t\t\tstruct tcf_proto *tp)\n{\n\tstruct tcf_proto *next = tcf_chain_dereference(chain_info->next, chain);\n\n\ttcf_proto_mark_delete(tp);\n\tif (tp == chain->filter_chain)\n\t\ttcf_chain0_head_change(chain, next);\n\tRCU_INIT_POINTER(*chain_info->pprev, next);\n}\n\nstatic struct tcf_proto *tcf_chain_tp_find(struct tcf_chain *chain,\n\t\t\t\t\t   struct tcf_chain_info *chain_info,\n\t\t\t\t\t   u32 protocol, u32 prio,\n\t\t\t\t\t   bool prio_allocate);\n\n \n\nstatic struct tcf_proto *tcf_chain_tp_insert_unique(struct tcf_chain *chain,\n\t\t\t\t\t\t    struct tcf_proto *tp_new,\n\t\t\t\t\t\t    u32 protocol, u32 prio,\n\t\t\t\t\t\t    bool rtnl_held)\n{\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_proto *tp;\n\tint err = 0;\n\n\tmutex_lock(&chain->filter_chain_lock);\n\n\tif (tcf_proto_exists_destroying(chain, tp_new)) {\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t\ttcf_proto_destroy(tp_new, rtnl_held, false, NULL);\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\n\ttp = tcf_chain_tp_find(chain, &chain_info,\n\t\t\t       protocol, prio, false);\n\tif (!tp)\n\t\terr = tcf_chain_tp_insert(chain, &chain_info, tp_new);\n\tmutex_unlock(&chain->filter_chain_lock);\n\n\tif (tp) {\n\t\ttcf_proto_destroy(tp_new, rtnl_held, false, NULL);\n\t\ttp_new = tp;\n\t} else if (err) {\n\t\ttcf_proto_destroy(tp_new, rtnl_held, false, NULL);\n\t\ttp_new = ERR_PTR(err);\n\t}\n\n\treturn tp_new;\n}\n\nstatic void tcf_chain_tp_delete_empty(struct tcf_chain *chain,\n\t\t\t\t      struct tcf_proto *tp, bool rtnl_held,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_proto *tp_iter;\n\tstruct tcf_proto **pprev;\n\tstruct tcf_proto *next;\n\n\tmutex_lock(&chain->filter_chain_lock);\n\n\t \n\tfor (pprev = &chain->filter_chain;\n\t     (tp_iter = tcf_chain_dereference(*pprev, chain));\n\t     pprev = &tp_iter->next) {\n\t\tif (tp_iter == tp) {\n\t\t\tchain_info.pprev = pprev;\n\t\t\tchain_info.next = tp_iter->next;\n\t\t\tWARN_ON(tp_iter->deleting);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (!tp_iter || !tcf_proto_check_delete(tp)) {\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t\treturn;\n\t}\n\n\ttcf_proto_signal_destroying(chain, tp);\n\tnext = tcf_chain_dereference(chain_info.next, chain);\n\tif (tp == chain->filter_chain)\n\t\ttcf_chain0_head_change(chain, next);\n\tRCU_INIT_POINTER(*chain_info.pprev, next);\n\tmutex_unlock(&chain->filter_chain_lock);\n\n\ttcf_proto_put(tp, rtnl_held, extack);\n}\n\nstatic struct tcf_proto *tcf_chain_tp_find(struct tcf_chain *chain,\n\t\t\t\t\t   struct tcf_chain_info *chain_info,\n\t\t\t\t\t   u32 protocol, u32 prio,\n\t\t\t\t\t   bool prio_allocate)\n{\n\tstruct tcf_proto **pprev;\n\tstruct tcf_proto *tp;\n\n\t \n\tfor (pprev = &chain->filter_chain;\n\t     (tp = tcf_chain_dereference(*pprev, chain));\n\t     pprev = &tp->next) {\n\t\tif (tp->prio >= prio) {\n\t\t\tif (tp->prio == prio) {\n\t\t\t\tif (prio_allocate ||\n\t\t\t\t    (tp->protocol != protocol && protocol))\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t} else {\n\t\t\t\ttp = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tchain_info->pprev = pprev;\n\tif (tp) {\n\t\tchain_info->next = tp->next;\n\t\ttcf_proto_get(tp);\n\t} else {\n\t\tchain_info->next = NULL;\n\t}\n\treturn tp;\n}\n\nstatic int tcf_fill_node(struct net *net, struct sk_buff *skb,\n\t\t\t struct tcf_proto *tp, struct tcf_block *block,\n\t\t\t struct Qdisc *q, u32 parent, void *fh,\n\t\t\t u32 portid, u32 seq, u16 flags, int event,\n\t\t\t bool terse_dump, bool rtnl_held,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*tcm), flags);\n\tif (!nlh)\n\t\tgoto out_nlmsg_trim;\n\ttcm = nlmsg_data(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad2 = 0;\n\tif (q) {\n\t\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\t\ttcm->tcm_parent = parent;\n\t} else {\n\t\ttcm->tcm_ifindex = TCM_IFINDEX_MAGIC_BLOCK;\n\t\ttcm->tcm_block_index = block->index;\n\t}\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tif (nla_put_string(skb, TCA_KIND, tp->ops->kind))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, TCA_CHAIN, tp->chain->index))\n\t\tgoto nla_put_failure;\n\tif (!fh) {\n\t\ttcm->tcm_handle = 0;\n\t} else if (terse_dump) {\n\t\tif (tp->ops->terse_dump) {\n\t\t\tif (tp->ops->terse_dump(net, tp, fh, skb, tcm,\n\t\t\t\t\t\trtnl_held) < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\tgoto cls_op_not_supp;\n\t\t}\n\t} else {\n\t\tif (tp->ops->dump &&\n\t\t    tp->ops->dump(net, tp, fh, skb, tcm, rtnl_held) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (extack && extack->_msg &&\n\t    nla_put_string(skb, TCA_EXT_WARN_MSG, extack->_msg))\n\t\tgoto nla_put_failure;\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\n\treturn skb->len;\n\nout_nlmsg_trim:\nnla_put_failure:\ncls_op_not_supp:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic int tfilter_notify(struct net *net, struct sk_buff *oskb,\n\t\t\t  struct nlmsghdr *n, struct tcf_proto *tp,\n\t\t\t  struct tcf_block *block, struct Qdisc *q,\n\t\t\t  u32 parent, void *fh, int event, bool unicast,\n\t\t\t  bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct sk_buff *skb;\n\tu32 portid = oskb ? NETLINK_CB(oskb).portid : 0;\n\tint err = 0;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (tcf_fill_node(net, skb, tp, block, q, parent, fh, portid,\n\t\t\t  n->nlmsg_seq, n->nlmsg_flags, event,\n\t\t\t  false, rtnl_held, extack) <= 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unicast)\n\t\terr = rtnl_unicast(skb, net, portid);\n\telse\n\t\terr = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\n\t\t\t\t     n->nlmsg_flags & NLM_F_ECHO);\n\treturn err;\n}\n\nstatic int tfilter_del_notify(struct net *net, struct sk_buff *oskb,\n\t\t\t      struct nlmsghdr *n, struct tcf_proto *tp,\n\t\t\t      struct tcf_block *block, struct Qdisc *q,\n\t\t\t      u32 parent, void *fh, bool unicast, bool *last,\n\t\t\t      bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct sk_buff *skb;\n\tu32 portid = oskb ? NETLINK_CB(oskb).portid : 0;\n\tint err;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (tcf_fill_node(net, skb, tp, block, q, parent, fh, portid,\n\t\t\t  n->nlmsg_seq, n->nlmsg_flags, RTM_DELTFILTER,\n\t\t\t  false, rtnl_held, extack) <= 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to build del event notification\");\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\terr = tp->ops->delete(tp, fh, last, rtnl_held, extack);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tif (unicast)\n\t\terr = rtnl_unicast(skb, net, portid);\n\telse\n\t\terr = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\n\t\t\t\t     n->nlmsg_flags & NLM_F_ECHO);\n\tif (err < 0)\n\t\tNL_SET_ERR_MSG(extack, \"Failed to send filter delete notification\");\n\n\treturn err;\n}\n\nstatic void tfilter_notify_chain(struct net *net, struct sk_buff *oskb,\n\t\t\t\t struct tcf_block *block, struct Qdisc *q,\n\t\t\t\t u32 parent, struct nlmsghdr *n,\n\t\t\t\t struct tcf_chain *chain, int event,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct tcf_proto *tp;\n\n\tfor (tp = tcf_get_next_proto(chain, NULL);\n\t     tp; tp = tcf_get_next_proto(chain, tp))\n\t\ttfilter_notify(net, oskb, n, tp, block, q, parent, NULL,\n\t\t\t       event, false, true, extack);\n}\n\nstatic void tfilter_put(struct tcf_proto *tp, void *fh)\n{\n\tif (tp->ops->put && fh)\n\t\ttp->ops->put(tp, fh);\n}\n\nstatic bool is_qdisc_ingress(__u32 classid)\n{\n\treturn (TC_H_MIN(classid) == TC_H_MIN(TC_H_MIN_INGRESS));\n}\n\nstatic int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tchar name[IFNAMSIZ];\n\tstruct tcmsg *t;\n\tu32 protocol;\n\tu32 prio;\n\tbool prio_allocate;\n\tu32 parent;\n\tu32 chain_index;\n\tstruct Qdisc *q;\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_chain *chain;\n\tstruct tcf_block *block;\n\tstruct tcf_proto *tp;\n\tunsigned long cl;\n\tvoid *fh;\n\tint err;\n\tint tp_created;\n\tbool rtnl_held = false;\n\tu32 flags;\n\nreplay:\n\ttp_created = 0;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tt = nlmsg_data(n);\n\tprotocol = TC_H_MIN(t->tcm_info);\n\tprio = TC_H_MAJ(t->tcm_info);\n\tprio_allocate = false;\n\tparent = t->tcm_parent;\n\ttp = NULL;\n\tcl = 0;\n\tblock = NULL;\n\tq = NULL;\n\tchain = NULL;\n\tflags = 0;\n\n\tif (prio == 0) {\n\t\t \n\t\tif (n->nlmsg_flags & NLM_F_CREATE) {\n\t\t\tprio = TC_H_MAKE(0x80000000U, 0U);\n\t\t\tprio_allocate = true;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid filter command with priority of zero\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\t \n\n\terr = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified TC filter name too long\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\t \n\tif (rtnl_held ||\n\t    (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\n\t    !tcf_proto_is_unlocked(name)) {\n\t\trtnl_held = true;\n\t\trtnl_lock();\n\t}\n\n\terr = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack);\n\tif (err)\n\t\tgoto errout;\n\n\tblock = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index,\n\t\t\t\t extack);\n\tif (IS_ERR(block)) {\n\t\terr = PTR_ERR(block);\n\t\tgoto errout;\n\t}\n\tblock->classid = parent;\n\n\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n\tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\tchain = tcf_chain_get(block, chain_index, true);\n\tif (!chain) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot create specified filter chain\");\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tmutex_lock(&chain->filter_chain_lock);\n\ttp = tcf_chain_tp_find(chain, &chain_info, protocol,\n\t\t\t       prio, prio_allocate);\n\tif (IS_ERR(tp)) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter with specified priority/protocol not found\");\n\t\terr = PTR_ERR(tp);\n\t\tgoto errout_locked;\n\t}\n\n\tif (tp == NULL) {\n\t\tstruct tcf_proto *tp_new = NULL;\n\n\t\tif (chain->flushing) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\t \n\n\t\tif (tca[TCA_KIND] == NULL || !protocol) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Filter kind and protocol must be specified\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (prio_allocate)\n\t\t\tprio = tcf_auto_prio(tcf_chain_tp_prev(chain,\n\t\t\t\t\t\t\t       &chain_info));\n\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t\ttp_new = tcf_proto_create(name, protocol, prio, chain,\n\t\t\t\t\t  rtnl_held, extack);\n\t\tif (IS_ERR(tp_new)) {\n\t\t\terr = PTR_ERR(tp_new);\n\t\t\tgoto errout_tp;\n\t\t}\n\n\t\ttp_created = 1;\n\t\ttp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,\n\t\t\t\t\t\trtnl_held);\n\t\tif (IS_ERR(tp)) {\n\t\t\terr = PTR_ERR(tp);\n\t\t\tgoto errout_tp;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t}\n\n\tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter kind does not match existing one\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tfh = tp->ops->get(tp, t->tcm_handle);\n\n\tif (!fh) {\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout;\n\t\t}\n\t} else if (n->nlmsg_flags & NLM_F_EXCL) {\n\t\ttfilter_put(tp, fh);\n\t\tNL_SET_ERR_MSG(extack, \"Filter already exists\");\n\t\terr = -EEXIST;\n\t\tgoto errout;\n\t}\n\n\tif (chain->tmplt_ops && chain->tmplt_ops != tp->ops) {\n\t\ttfilter_put(tp, fh);\n\t\tNL_SET_ERR_MSG(extack, \"Chain template is set to a different filter kind\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tif (!(n->nlmsg_flags & NLM_F_CREATE))\n\t\tflags |= TCA_ACT_FLAGS_REPLACE;\n\tif (!rtnl_held)\n\t\tflags |= TCA_ACT_FLAGS_NO_RTNL;\n\tif (is_qdisc_ingress(parent))\n\t\tflags |= TCA_ACT_FLAGS_AT_INGRESS;\n\terr = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh,\n\t\t\t      flags, extack);\n\tif (err == 0) {\n\t\ttfilter_notify(net, skb, n, tp, block, q, parent, fh,\n\t\t\t       RTM_NEWTFILTER, false, rtnl_held, extack);\n\t\ttfilter_put(tp, fh);\n\t\t \n\t\tif (q)\n\t\t\tq->flags &= ~TCQ_F_CAN_BYPASS;\n\t}\n\nerrout:\n\tif (err && tp_created)\n\t\ttcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL);\nerrout_tp:\n\tif (chain) {\n\t\tif (tp && !IS_ERR(tp))\n\t\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\tif (!tp_created)\n\t\t\ttcf_chain_put(chain);\n\t}\n\ttcf_block_release(q, block, rtnl_held);\n\n\tif (rtnl_held)\n\t\trtnl_unlock();\n\n\tif (err == -EAGAIN) {\n\t\t \n\t\trtnl_held = true;\n\t\t \n\t\tgoto replay;\n\t}\n\treturn err;\n\nerrout_locked:\n\tmutex_unlock(&chain->filter_chain_lock);\n\tgoto errout;\n}\n\nstatic int tc_del_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tchar name[IFNAMSIZ];\n\tstruct tcmsg *t;\n\tu32 protocol;\n\tu32 prio;\n\tu32 parent;\n\tu32 chain_index;\n\tstruct Qdisc *q = NULL;\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_chain *chain = NULL;\n\tstruct tcf_block *block = NULL;\n\tstruct tcf_proto *tp = NULL;\n\tunsigned long cl = 0;\n\tvoid *fh = NULL;\n\tint err;\n\tbool rtnl_held = false;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tt = nlmsg_data(n);\n\tprotocol = TC_H_MIN(t->tcm_info);\n\tprio = TC_H_MAJ(t->tcm_info);\n\tparent = t->tcm_parent;\n\n\tif (prio == 0 && (protocol || t->tcm_handle || tca[TCA_KIND])) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot flush filters with protocol, handle or kind set\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\n\terr = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified TC filter name too long\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\t \n\tif (!prio ||\n\t    (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\n\t    !tcf_proto_is_unlocked(name)) {\n\t\trtnl_held = true;\n\t\trtnl_lock();\n\t}\n\n\terr = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack);\n\tif (err)\n\t\tgoto errout;\n\n\tblock = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index,\n\t\t\t\t extack);\n\tif (IS_ERR(block)) {\n\t\terr = PTR_ERR(block);\n\t\tgoto errout;\n\t}\n\n\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n\tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\tchain = tcf_chain_get(block, chain_index, false);\n\tif (!chain) {\n\t\t \n\t\tif (prio == 0) {\n\t\t\terr = 0;\n\t\t\tgoto errout;\n\t\t}\n\t\tNL_SET_ERR_MSG(extack, \"Cannot find specified filter chain\");\n\t\terr = -ENOENT;\n\t\tgoto errout;\n\t}\n\n\tif (prio == 0) {\n\t\ttfilter_notify_chain(net, skb, block, q, parent, n,\n\t\t\t\t     chain, RTM_DELTFILTER, extack);\n\t\ttcf_chain_flush(chain, rtnl_held);\n\t\terr = 0;\n\t\tgoto errout;\n\t}\n\n\tmutex_lock(&chain->filter_chain_lock);\n\ttp = tcf_chain_tp_find(chain, &chain_info, protocol,\n\t\t\t       prio, false);\n\tif (!tp || IS_ERR(tp)) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter with specified priority/protocol not found\");\n\t\terr = tp ? PTR_ERR(tp) : -ENOENT;\n\t\tgoto errout_locked;\n\t} else if (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter kind does not match existing one\");\n\t\terr = -EINVAL;\n\t\tgoto errout_locked;\n\t} else if (t->tcm_handle == 0) {\n\t\ttcf_proto_signal_destroying(chain, tp);\n\t\ttcf_chain_tp_remove(chain, &chain_info, tp);\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\n\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\ttfilter_notify(net, skb, n, tp, block, q, parent, fh,\n\t\t\t       RTM_DELTFILTER, false, rtnl_held, extack);\n\t\terr = 0;\n\t\tgoto errout;\n\t}\n\tmutex_unlock(&chain->filter_chain_lock);\n\n\tfh = tp->ops->get(tp, t->tcm_handle);\n\n\tif (!fh) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter handle not found\");\n\t\terr = -ENOENT;\n\t} else {\n\t\tbool last;\n\n\t\terr = tfilter_del_notify(net, skb, n, tp, block,\n\t\t\t\t\t q, parent, fh, false, &last,\n\t\t\t\t\t rtnl_held, extack);\n\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tif (last)\n\t\t\ttcf_chain_tp_delete_empty(chain, tp, rtnl_held, extack);\n\t}\n\nerrout:\n\tif (chain) {\n\t\tif (tp && !IS_ERR(tp))\n\t\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\ttcf_chain_put(chain);\n\t}\n\ttcf_block_release(q, block, rtnl_held);\n\n\tif (rtnl_held)\n\t\trtnl_unlock();\n\n\treturn err;\n\nerrout_locked:\n\tmutex_unlock(&chain->filter_chain_lock);\n\tgoto errout;\n}\n\nstatic int tc_get_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tchar name[IFNAMSIZ];\n\tstruct tcmsg *t;\n\tu32 protocol;\n\tu32 prio;\n\tu32 parent;\n\tu32 chain_index;\n\tstruct Qdisc *q = NULL;\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_chain *chain = NULL;\n\tstruct tcf_block *block = NULL;\n\tstruct tcf_proto *tp = NULL;\n\tunsigned long cl = 0;\n\tvoid *fh = NULL;\n\tint err;\n\tbool rtnl_held = false;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tt = nlmsg_data(n);\n\tprotocol = TC_H_MIN(t->tcm_info);\n\tprio = TC_H_MAJ(t->tcm_info);\n\tparent = t->tcm_parent;\n\n\tif (prio == 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid filter command with priority of zero\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\n\terr = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified TC filter name too long\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\t \n\tif ((q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\n\t    !tcf_proto_is_unlocked(name)) {\n\t\trtnl_held = true;\n\t\trtnl_lock();\n\t}\n\n\terr = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack);\n\tif (err)\n\t\tgoto errout;\n\n\tblock = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index,\n\t\t\t\t extack);\n\tif (IS_ERR(block)) {\n\t\terr = PTR_ERR(block);\n\t\tgoto errout;\n\t}\n\n\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n\tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\tchain = tcf_chain_get(block, chain_index, false);\n\tif (!chain) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot find specified filter chain\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tmutex_lock(&chain->filter_chain_lock);\n\ttp = tcf_chain_tp_find(chain, &chain_info, protocol,\n\t\t\t       prio, false);\n\tmutex_unlock(&chain->filter_chain_lock);\n\tif (!tp || IS_ERR(tp)) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter with specified priority/protocol not found\");\n\t\terr = tp ? PTR_ERR(tp) : -ENOENT;\n\t\tgoto errout;\n\t} else if (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter kind does not match existing one\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tfh = tp->ops->get(tp, t->tcm_handle);\n\n\tif (!fh) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter handle not found\");\n\t\terr = -ENOENT;\n\t} else {\n\t\terr = tfilter_notify(net, skb, n, tp, block, q, parent,\n\t\t\t\t     fh, RTM_NEWTFILTER, true, rtnl_held, NULL);\n\t\tif (err < 0)\n\t\t\tNL_SET_ERR_MSG(extack, \"Failed to send filter notify message\");\n\t}\n\n\ttfilter_put(tp, fh);\nerrout:\n\tif (chain) {\n\t\tif (tp && !IS_ERR(tp))\n\t\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\ttcf_chain_put(chain);\n\t}\n\ttcf_block_release(q, block, rtnl_held);\n\n\tif (rtnl_held)\n\t\trtnl_unlock();\n\n\treturn err;\n}\n\nstruct tcf_dump_args {\n\tstruct tcf_walker w;\n\tstruct sk_buff *skb;\n\tstruct netlink_callback *cb;\n\tstruct tcf_block *block;\n\tstruct Qdisc *q;\n\tu32 parent;\n\tbool terse_dump;\n};\n\nstatic int tcf_node_dump(struct tcf_proto *tp, void *n, struct tcf_walker *arg)\n{\n\tstruct tcf_dump_args *a = (void *)arg;\n\tstruct net *net = sock_net(a->skb->sk);\n\n\treturn tcf_fill_node(net, a->skb, tp, a->block, a->q, a->parent,\n\t\t\t     n, NETLINK_CB(a->cb->skb).portid,\n\t\t\t     a->cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t     RTM_NEWTFILTER, a->terse_dump, true, NULL);\n}\n\nstatic bool tcf_chain_dump(struct tcf_chain *chain, struct Qdisc *q, u32 parent,\n\t\t\t   struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t   long index_start, long *p_index, bool terse)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tcf_block *block = chain->block;\n\tstruct tcmsg *tcm = nlmsg_data(cb->nlh);\n\tstruct tcf_proto *tp, *tp_prev;\n\tstruct tcf_dump_args arg;\n\n\tfor (tp = __tcf_get_next_proto(chain, NULL);\n\t     tp;\n\t     tp_prev = tp,\n\t\t     tp = __tcf_get_next_proto(chain, tp),\n\t\t     tcf_proto_put(tp_prev, true, NULL),\n\t\t     (*p_index)++) {\n\t\tif (*p_index < index_start)\n\t\t\tcontinue;\n\t\tif (TC_H_MAJ(tcm->tcm_info) &&\n\t\t    TC_H_MAJ(tcm->tcm_info) != tp->prio)\n\t\t\tcontinue;\n\t\tif (TC_H_MIN(tcm->tcm_info) &&\n\t\t    TC_H_MIN(tcm->tcm_info) != tp->protocol)\n\t\t\tcontinue;\n\t\tif (*p_index > index_start)\n\t\t\tmemset(&cb->args[1], 0,\n\t\t\t       sizeof(cb->args) - sizeof(cb->args[0]));\n\t\tif (cb->args[1] == 0) {\n\t\t\tif (tcf_fill_node(net, skb, tp, block, q, parent, NULL,\n\t\t\t\t\t  NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t  cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t  RTM_NEWTFILTER, false, true, NULL) <= 0)\n\t\t\t\tgoto errout;\n\t\t\tcb->args[1] = 1;\n\t\t}\n\t\tif (!tp->ops->walk)\n\t\t\tcontinue;\n\t\targ.w.fn = tcf_node_dump;\n\t\targ.skb = skb;\n\t\targ.cb = cb;\n\t\targ.block = block;\n\t\targ.q = q;\n\t\targ.parent = parent;\n\t\targ.w.stop = 0;\n\t\targ.w.skip = cb->args[1] - 1;\n\t\targ.w.count = 0;\n\t\targ.w.cookie = cb->args[2];\n\t\targ.terse_dump = terse;\n\t\ttp->ops->walk(tp, &arg.w, true);\n\t\tcb->args[2] = arg.w.cookie;\n\t\tcb->args[1] = arg.w.count + 1;\n\t\tif (arg.w.stop)\n\t\t\tgoto errout;\n\t}\n\treturn true;\n\nerrout:\n\ttcf_proto_put(tp, true, NULL);\n\treturn false;\n}\n\nstatic const struct nla_policy tcf_tfilter_dump_policy[TCA_MAX + 1] = {\n\t[TCA_DUMP_FLAGS] = NLA_POLICY_BITFIELD32(TCA_DUMP_FLAGS_TERSE),\n};\n\n \nstatic int tc_dump_tfilter(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct tcf_chain *chain, *chain_prev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tstruct Qdisc *q = NULL;\n\tstruct tcf_block *block;\n\tstruct tcmsg *tcm = nlmsg_data(cb->nlh);\n\tbool terse_dump = false;\n\tlong index_start;\n\tlong index;\n\tu32 parent;\n\tint err;\n\n\tif (nlmsg_len(cb->nlh) < sizeof(*tcm))\n\t\treturn skb->len;\n\n\terr = nlmsg_parse_deprecated(cb->nlh, sizeof(*tcm), tca, TCA_MAX,\n\t\t\t\t     tcf_tfilter_dump_policy, cb->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tca[TCA_DUMP_FLAGS]) {\n\t\tstruct nla_bitfield32 flags =\n\t\t\tnla_get_bitfield32(tca[TCA_DUMP_FLAGS]);\n\n\t\tterse_dump = flags.value & TCA_DUMP_FLAGS_TERSE;\n\t}\n\n\tif (tcm->tcm_ifindex == TCM_IFINDEX_MAGIC_BLOCK) {\n\t\tblock = tcf_block_refcnt_get(net, tcm->tcm_block_index);\n\t\tif (!block)\n\t\t\tgoto out;\n\t\t \n\t\tparent = 0;\n\t} else {\n\t\tconst struct Qdisc_class_ops *cops;\n\t\tstruct net_device *dev;\n\t\tunsigned long cl = 0;\n\n\t\tdev = __dev_get_by_index(net, tcm->tcm_ifindex);\n\t\tif (!dev)\n\t\t\treturn skb->len;\n\n\t\tparent = tcm->tcm_parent;\n\t\tif (!parent)\n\t\t\tq = rtnl_dereference(dev->qdisc);\n\t\telse\n\t\t\tq = qdisc_lookup(dev, TC_H_MAJ(tcm->tcm_parent));\n\t\tif (!q)\n\t\t\tgoto out;\n\t\tcops = q->ops->cl_ops;\n\t\tif (!cops)\n\t\t\tgoto out;\n\t\tif (!cops->tcf_block)\n\t\t\tgoto out;\n\t\tif (TC_H_MIN(tcm->tcm_parent)) {\n\t\t\tcl = cops->find(q, tcm->tcm_parent);\n\t\t\tif (cl == 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tblock = cops->tcf_block(q, cl, NULL);\n\t\tif (!block)\n\t\t\tgoto out;\n\t\tparent = block->classid;\n\t\tif (tcf_block_shared(block))\n\t\t\tq = NULL;\n\t}\n\n\tindex_start = cb->args[0];\n\tindex = 0;\n\n\tfor (chain = __tcf_get_next_chain(block, NULL);\n\t     chain;\n\t     chain_prev = chain,\n\t\t     chain = __tcf_get_next_chain(block, chain),\n\t\t     tcf_chain_put(chain_prev)) {\n\t\tif (tca[TCA_CHAIN] &&\n\t\t    nla_get_u32(tca[TCA_CHAIN]) != chain->index)\n\t\t\tcontinue;\n\t\tif (!tcf_chain_dump(chain, q, parent, skb, cb,\n\t\t\t\t    index_start, &index, terse_dump)) {\n\t\t\ttcf_chain_put(chain);\n\t\t\terr = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tcm->tcm_ifindex == TCM_IFINDEX_MAGIC_BLOCK)\n\t\ttcf_block_refcnt_put(block, true);\n\tcb->args[0] = index;\n\nout:\n\t \n\tif (skb->len == 0 && err)\n\t\treturn err;\n\treturn skb->len;\n}\n\nstatic int tc_chain_fill_node(const struct tcf_proto_ops *tmplt_ops,\n\t\t\t      void *tmplt_priv, u32 chain_index,\n\t\t\t      struct net *net, struct sk_buff *skb,\n\t\t\t      struct tcf_block *block,\n\t\t\t      u32 portid, u32 seq, u16 flags, int event,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tconst struct tcf_proto_ops *ops;\n\tstruct nlmsghdr *nlh;\n\tstruct tcmsg *tcm;\n\tvoid *priv;\n\n\tops = tmplt_ops;\n\tpriv = tmplt_priv;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*tcm), flags);\n\tif (!nlh)\n\t\tgoto out_nlmsg_trim;\n\ttcm = nlmsg_data(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad2 = 0;\n\ttcm->tcm_handle = 0;\n\tif (block->q) {\n\t\ttcm->tcm_ifindex = qdisc_dev(block->q)->ifindex;\n\t\ttcm->tcm_parent = block->q->handle;\n\t} else {\n\t\ttcm->tcm_ifindex = TCM_IFINDEX_MAGIC_BLOCK;\n\t\ttcm->tcm_block_index = block->index;\n\t}\n\n\tif (nla_put_u32(skb, TCA_CHAIN, chain_index))\n\t\tgoto nla_put_failure;\n\n\tif (ops) {\n\t\tif (nla_put_string(skb, TCA_KIND, ops->kind))\n\t\t\tgoto nla_put_failure;\n\t\tif (ops->tmplt_dump(skb, net, priv) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (extack && extack->_msg &&\n\t    nla_put_string(skb, TCA_EXT_WARN_MSG, extack->_msg))\n\t\tgoto out_nlmsg_trim;\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\n\treturn skb->len;\n\nout_nlmsg_trim:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -EMSGSIZE;\n}\n\nstatic int tc_chain_notify(struct tcf_chain *chain, struct sk_buff *oskb,\n\t\t\t   u32 seq, u16 flags, int event, bool unicast,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tu32 portid = oskb ? NETLINK_CB(oskb).portid : 0;\n\tstruct tcf_block *block = chain->block;\n\tstruct net *net = block->net;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (tc_chain_fill_node(chain->tmplt_ops, chain->tmplt_priv,\n\t\t\t       chain->index, net, skb, block, portid,\n\t\t\t       seq, flags, event, extack) <= 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unicast)\n\t\terr = rtnl_unicast(skb, net, portid);\n\telse\n\t\terr = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\n\t\t\t\t     flags & NLM_F_ECHO);\n\n\treturn err;\n}\n\nstatic int tc_chain_notify_delete(const struct tcf_proto_ops *tmplt_ops,\n\t\t\t\t  void *tmplt_priv, u32 chain_index,\n\t\t\t\t  struct tcf_block *block, struct sk_buff *oskb,\n\t\t\t\t  u32 seq, u16 flags, bool unicast)\n{\n\tu32 portid = oskb ? NETLINK_CB(oskb).portid : 0;\n\tstruct net *net = block->net;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (tc_chain_fill_node(tmplt_ops, tmplt_priv, chain_index, net, skb,\n\t\t\t       block, portid, seq, flags, RTM_DELCHAIN, NULL) <= 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unicast)\n\t\treturn rtnl_unicast(skb, net, portid);\n\n\treturn rtnetlink_send(skb, net, portid, RTNLGRP_TC, flags & NLM_F_ECHO);\n}\n\nstatic int tc_chain_tmplt_add(struct tcf_chain *chain, struct net *net,\n\t\t\t      struct nlattr **tca,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tconst struct tcf_proto_ops *ops;\n\tchar name[IFNAMSIZ];\n\tvoid *tmplt_priv;\n\n\t \n\tif (!tca[TCA_KIND])\n\t\treturn 0;\n\n\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified TC chain template name too long\");\n\t\treturn -EINVAL;\n\t}\n\n\tops = tcf_proto_lookup_ops(name, true, extack);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\tif (!ops->tmplt_create || !ops->tmplt_destroy || !ops->tmplt_dump) {\n\t\tNL_SET_ERR_MSG(extack, \"Chain templates are not supported with specified classifier\");\n\t\tmodule_put(ops->owner);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ttmplt_priv = ops->tmplt_create(net, chain, tca, extack);\n\tif (IS_ERR(tmplt_priv)) {\n\t\tmodule_put(ops->owner);\n\t\treturn PTR_ERR(tmplt_priv);\n\t}\n\tchain->tmplt_ops = ops;\n\tchain->tmplt_priv = tmplt_priv;\n\treturn 0;\n}\n\nstatic void tc_chain_tmplt_del(const struct tcf_proto_ops *tmplt_ops,\n\t\t\t       void *tmplt_priv)\n{\n\t \n\tif (!tmplt_ops)\n\t\treturn;\n\n\ttmplt_ops->tmplt_destroy(tmplt_priv);\n\tmodule_put(tmplt_ops->owner);\n}\n\n \n\nstatic int tc_ctl_chain(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tstruct tcmsg *t;\n\tu32 parent;\n\tu32 chain_index;\n\tstruct Qdisc *q;\n\tstruct tcf_chain *chain;\n\tstruct tcf_block *block;\n\tunsigned long cl;\n\tint err;\n\nreplay:\n\tq = NULL;\n\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tt = nlmsg_data(n);\n\tparent = t->tcm_parent;\n\tcl = 0;\n\n\tblock = tcf_block_find(net, &q, &parent, &cl,\n\t\t\t       t->tcm_ifindex, t->tcm_block_index, extack);\n\tif (IS_ERR(block))\n\t\treturn PTR_ERR(block);\n\n\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n\tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n\t\terr = -EINVAL;\n\t\tgoto errout_block;\n\t}\n\n\tmutex_lock(&block->lock);\n\tchain = tcf_chain_lookup(block, chain_index);\n\tif (n->nlmsg_type == RTM_NEWCHAIN) {\n\t\tif (chain) {\n\t\t\tif (tcf_chain_held_by_acts_only(chain)) {\n\t\t\t\t \n\t\t\t\ttcf_chain_hold(chain);\n\t\t\t} else {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Filter chain already exists\");\n\t\t\t\terr = -EEXIST;\n\t\t\t\tgoto errout_block_locked;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWCHAIN and NLM_F_CREATE to create a new chain\");\n\t\t\t\terr = -ENOENT;\n\t\t\t\tgoto errout_block_locked;\n\t\t\t}\n\t\t\tchain = tcf_chain_create(block, chain_index);\n\t\t\tif (!chain) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Failed to create filter chain\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto errout_block_locked;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!chain || tcf_chain_held_by_acts_only(chain)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot find specified filter chain\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_block_locked;\n\t\t}\n\t\ttcf_chain_hold(chain);\n\t}\n\n\tif (n->nlmsg_type == RTM_NEWCHAIN) {\n\t\t \n\t\ttcf_chain_hold(chain);\n\t\tchain->explicitly_created = true;\n\t}\n\tmutex_unlock(&block->lock);\n\n\tswitch (n->nlmsg_type) {\n\tcase RTM_NEWCHAIN:\n\t\terr = tc_chain_tmplt_add(chain, net, tca, extack);\n\t\tif (err) {\n\t\t\ttcf_chain_put_explicitly_created(chain);\n\t\t\tgoto errout;\n\t\t}\n\n\t\ttc_chain_notify(chain, NULL, 0, NLM_F_CREATE | NLM_F_EXCL,\n\t\t\t\tRTM_NEWCHAIN, false, extack);\n\t\tbreak;\n\tcase RTM_DELCHAIN:\n\t\ttfilter_notify_chain(net, skb, block, q, parent, n,\n\t\t\t\t     chain, RTM_DELTFILTER, extack);\n\t\t \n\t\ttcf_chain_flush(chain, true);\n\t\t \n\t\ttcf_chain_put_explicitly_created(chain);\n\t\tbreak;\n\tcase RTM_GETCHAIN:\n\t\terr = tc_chain_notify(chain, skb, n->nlmsg_seq,\n\t\t\t\t      n->nlmsg_flags, n->nlmsg_type, true, extack);\n\t\tif (err < 0)\n\t\t\tNL_SET_ERR_MSG(extack, \"Failed to send chain notify message\");\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported message type\");\n\t\tgoto errout;\n\t}\n\nerrout:\n\ttcf_chain_put(chain);\nerrout_block:\n\ttcf_block_release(q, block, true);\n\tif (err == -EAGAIN)\n\t\t \n\t\tgoto replay;\n\treturn err;\n\nerrout_block_locked:\n\tmutex_unlock(&block->lock);\n\tgoto errout_block;\n}\n\n \nstatic int tc_dump_chain(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tstruct Qdisc *q = NULL;\n\tstruct tcf_block *block;\n\tstruct tcmsg *tcm = nlmsg_data(cb->nlh);\n\tstruct tcf_chain *chain;\n\tlong index_start;\n\tlong index;\n\tint err;\n\n\tif (nlmsg_len(cb->nlh) < sizeof(*tcm))\n\t\treturn skb->len;\n\n\terr = nlmsg_parse_deprecated(cb->nlh, sizeof(*tcm), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, cb->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tcm->tcm_ifindex == TCM_IFINDEX_MAGIC_BLOCK) {\n\t\tblock = tcf_block_refcnt_get(net, tcm->tcm_block_index);\n\t\tif (!block)\n\t\t\tgoto out;\n\t} else {\n\t\tconst struct Qdisc_class_ops *cops;\n\t\tstruct net_device *dev;\n\t\tunsigned long cl = 0;\n\n\t\tdev = __dev_get_by_index(net, tcm->tcm_ifindex);\n\t\tif (!dev)\n\t\t\treturn skb->len;\n\n\t\tif (!tcm->tcm_parent)\n\t\t\tq = rtnl_dereference(dev->qdisc);\n\t\telse\n\t\t\tq = qdisc_lookup(dev, TC_H_MAJ(tcm->tcm_parent));\n\n\t\tif (!q)\n\t\t\tgoto out;\n\t\tcops = q->ops->cl_ops;\n\t\tif (!cops)\n\t\t\tgoto out;\n\t\tif (!cops->tcf_block)\n\t\t\tgoto out;\n\t\tif (TC_H_MIN(tcm->tcm_parent)) {\n\t\t\tcl = cops->find(q, tcm->tcm_parent);\n\t\t\tif (cl == 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tblock = cops->tcf_block(q, cl, NULL);\n\t\tif (!block)\n\t\t\tgoto out;\n\t\tif (tcf_block_shared(block))\n\t\t\tq = NULL;\n\t}\n\n\tindex_start = cb->args[0];\n\tindex = 0;\n\n\tmutex_lock(&block->lock);\n\tlist_for_each_entry(chain, &block->chain_list, list) {\n\t\tif ((tca[TCA_CHAIN] &&\n\t\t     nla_get_u32(tca[TCA_CHAIN]) != chain->index))\n\t\t\tcontinue;\n\t\tif (index < index_start) {\n\t\t\tindex++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tcf_chain_held_by_acts_only(chain))\n\t\t\tcontinue;\n\t\terr = tc_chain_fill_node(chain->tmplt_ops, chain->tmplt_priv,\n\t\t\t\t\t chain->index, net, skb, block,\n\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t RTM_NEWCHAIN, NULL);\n\t\tif (err <= 0)\n\t\t\tbreak;\n\t\tindex++;\n\t}\n\tmutex_unlock(&block->lock);\n\n\tif (tcm->tcm_ifindex == TCM_IFINDEX_MAGIC_BLOCK)\n\t\ttcf_block_refcnt_put(block, true);\n\tcb->args[0] = index;\n\nout:\n\t \n\tif (skb->len == 0 && err)\n\t\treturn err;\n\treturn skb->len;\n}\n\nint tcf_exts_init_ex(struct tcf_exts *exts, struct net *net, int action,\n\t\t     int police, struct tcf_proto *tp, u32 handle,\n\t\t     bool use_action_miss)\n{\n\tint err = 0;\n\n#ifdef CONFIG_NET_CLS_ACT\n\texts->type = 0;\n\texts->nr_actions = 0;\n\texts->miss_cookie_node = NULL;\n\t \n\texts->net = net;\n\texts->actions = kcalloc(TCA_ACT_MAX_PRIO, sizeof(struct tc_action *),\n\t\t\t\tGFP_KERNEL);\n\tif (!exts->actions)\n\t\treturn -ENOMEM;\n#endif\n\n\texts->action = action;\n\texts->police = police;\n\n\tif (!use_action_miss)\n\t\treturn 0;\n\n\terr = tcf_exts_miss_cookie_base_alloc(exts, tp, handle);\n\tif (err)\n\t\tgoto err_miss_alloc;\n\n\treturn 0;\n\nerr_miss_alloc:\n\ttcf_exts_destroy(exts);\n#ifdef CONFIG_NET_CLS_ACT\n\texts->actions = NULL;\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(tcf_exts_init_ex);\n\nvoid tcf_exts_destroy(struct tcf_exts *exts)\n{\n\ttcf_exts_miss_cookie_base_destroy(exts);\n\n#ifdef CONFIG_NET_CLS_ACT\n\tif (exts->actions) {\n\t\ttcf_action_destroy(exts->actions, TCA_ACT_UNBIND);\n\t\tkfree(exts->actions);\n\t}\n\texts->nr_actions = 0;\n#endif\n}\nEXPORT_SYMBOL(tcf_exts_destroy);\n\nint tcf_exts_validate_ex(struct net *net, struct tcf_proto *tp, struct nlattr **tb,\n\t\t\t struct nlattr *rate_tlv, struct tcf_exts *exts,\n\t\t\t u32 flags, u32 fl_flags, struct netlink_ext_ack *extack)\n{\n#ifdef CONFIG_NET_CLS_ACT\n\t{\n\t\tint init_res[TCA_ACT_MAX_PRIO] = {};\n\t\tstruct tc_action *act;\n\t\tsize_t attr_size = 0;\n\n\t\tif (exts->police && tb[exts->police]) {\n\t\t\tstruct tc_action_ops *a_o;\n\n\t\t\ta_o = tc_action_load_ops(tb[exts->police], true,\n\t\t\t\t\t\t !(flags & TCA_ACT_FLAGS_NO_RTNL),\n\t\t\t\t\t\t extack);\n\t\t\tif (IS_ERR(a_o))\n\t\t\t\treturn PTR_ERR(a_o);\n\t\t\tflags |= TCA_ACT_FLAGS_POLICE | TCA_ACT_FLAGS_BIND;\n\t\t\tact = tcf_action_init_1(net, tp, tb[exts->police],\n\t\t\t\t\t\trate_tlv, a_o, init_res, flags,\n\t\t\t\t\t\textack);\n\t\t\tmodule_put(a_o->owner);\n\t\t\tif (IS_ERR(act))\n\t\t\t\treturn PTR_ERR(act);\n\n\t\t\tact->type = exts->type = TCA_OLD_COMPAT;\n\t\t\texts->actions[0] = act;\n\t\t\texts->nr_actions = 1;\n\t\t\ttcf_idr_insert_many(exts->actions);\n\t\t} else if (exts->action && tb[exts->action]) {\n\t\t\tint err;\n\n\t\t\tflags |= TCA_ACT_FLAGS_BIND;\n\t\t\terr = tcf_action_init(net, tp, tb[exts->action],\n\t\t\t\t\t      rate_tlv, exts->actions, init_res,\n\t\t\t\t\t      &attr_size, flags, fl_flags,\n\t\t\t\t\t      extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\texts->nr_actions = err;\n\t\t}\n\t}\n#else\n\tif ((exts->action && tb[exts->action]) ||\n\t    (exts->police && tb[exts->police])) {\n\t\tNL_SET_ERR_MSG(extack, \"Classifier actions are not supported per compile options (CONFIG_NET_CLS_ACT)\");\n\t\treturn -EOPNOTSUPP;\n\t}\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tcf_exts_validate_ex);\n\nint tcf_exts_validate(struct net *net, struct tcf_proto *tp, struct nlattr **tb,\n\t\t      struct nlattr *rate_tlv, struct tcf_exts *exts,\n\t\t      u32 flags, struct netlink_ext_ack *extack)\n{\n\treturn tcf_exts_validate_ex(net, tp, tb, rate_tlv, exts,\n\t\t\t\t    flags, 0, extack);\n}\nEXPORT_SYMBOL(tcf_exts_validate);\n\nvoid tcf_exts_change(struct tcf_exts *dst, struct tcf_exts *src)\n{\n#ifdef CONFIG_NET_CLS_ACT\n\tstruct tcf_exts old = *dst;\n\n\t*dst = *src;\n\ttcf_exts_destroy(&old);\n#endif\n}\nEXPORT_SYMBOL(tcf_exts_change);\n\n#ifdef CONFIG_NET_CLS_ACT\nstatic struct tc_action *tcf_exts_first_act(struct tcf_exts *exts)\n{\n\tif (exts->nr_actions == 0)\n\t\treturn NULL;\n\telse\n\t\treturn exts->actions[0];\n}\n#endif\n\nint tcf_exts_dump(struct sk_buff *skb, struct tcf_exts *exts)\n{\n#ifdef CONFIG_NET_CLS_ACT\n\tstruct nlattr *nest;\n\n\tif (exts->action && tcf_exts_has_actions(exts)) {\n\t\t \n\t\tif (exts->type != TCA_OLD_COMPAT) {\n\t\t\tnest = nla_nest_start_noflag(skb, exts->action);\n\t\t\tif (nest == NULL)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (tcf_action_dump(skb, exts->actions, 0, 0, false)\n\t\t\t    < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(skb, nest);\n\t\t} else if (exts->police) {\n\t\t\tstruct tc_action *act = tcf_exts_first_act(exts);\n\t\t\tnest = nla_nest_start_noflag(skb, exts->police);\n\t\t\tif (nest == NULL || !act)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (tcf_action_dump_old(skb, act, 0, 0) < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\t}\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n#else\n\treturn 0;\n#endif\n}\nEXPORT_SYMBOL(tcf_exts_dump);\n\nint tcf_exts_terse_dump(struct sk_buff *skb, struct tcf_exts *exts)\n{\n#ifdef CONFIG_NET_CLS_ACT\n\tstruct nlattr *nest;\n\n\tif (!exts->action || !tcf_exts_has_actions(exts))\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(skb, exts->action);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tif (tcf_action_dump(skb, exts->actions, 0, 0, true) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n#else\n\treturn 0;\n#endif\n}\nEXPORT_SYMBOL(tcf_exts_terse_dump);\n\nint tcf_exts_dump_stats(struct sk_buff *skb, struct tcf_exts *exts)\n{\n#ifdef CONFIG_NET_CLS_ACT\n\tstruct tc_action *a = tcf_exts_first_act(exts);\n\tif (a != NULL && tcf_action_copy_stats(skb, a, 1) < 0)\n\t\treturn -1;\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL(tcf_exts_dump_stats);\n\nstatic void tcf_block_offload_inc(struct tcf_block *block, u32 *flags)\n{\n\tif (*flags & TCA_CLS_FLAGS_IN_HW)\n\t\treturn;\n\t*flags |= TCA_CLS_FLAGS_IN_HW;\n\tatomic_inc(&block->offloadcnt);\n}\n\nstatic void tcf_block_offload_dec(struct tcf_block *block, u32 *flags)\n{\n\tif (!(*flags & TCA_CLS_FLAGS_IN_HW))\n\t\treturn;\n\t*flags &= ~TCA_CLS_FLAGS_IN_HW;\n\tatomic_dec(&block->offloadcnt);\n}\n\nstatic void tc_cls_offload_cnt_update(struct tcf_block *block,\n\t\t\t\t      struct tcf_proto *tp, u32 *cnt,\n\t\t\t\t      u32 *flags, u32 diff, bool add)\n{\n\tlockdep_assert_held(&block->cb_lock);\n\n\tspin_lock(&tp->lock);\n\tif (add) {\n\t\tif (!*cnt)\n\t\t\ttcf_block_offload_inc(block, flags);\n\t\t*cnt += diff;\n\t} else {\n\t\t*cnt -= diff;\n\t\tif (!*cnt)\n\t\t\ttcf_block_offload_dec(block, flags);\n\t}\n\tspin_unlock(&tp->lock);\n}\n\nstatic void\ntc_cls_offload_cnt_reset(struct tcf_block *block, struct tcf_proto *tp,\n\t\t\t u32 *cnt, u32 *flags)\n{\n\tlockdep_assert_held(&block->cb_lock);\n\n\tspin_lock(&tp->lock);\n\ttcf_block_offload_dec(block, flags);\n\t*cnt = 0;\n\tspin_unlock(&tp->lock);\n}\n\nstatic int\n__tc_setup_cb_call(struct tcf_block *block, enum tc_setup_type type,\n\t\t   void *type_data, bool err_stop)\n{\n\tstruct flow_block_cb *block_cb;\n\tint ok_count = 0;\n\tint err;\n\n\tlist_for_each_entry(block_cb, &block->flow_block.cb_list, list) {\n\t\terr = block_cb->cb(type, type_data, block_cb->cb_priv);\n\t\tif (err) {\n\t\t\tif (err_stop)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tok_count++;\n\t\t}\n\t}\n\treturn ok_count;\n}\n\nint tc_setup_cb_call(struct tcf_block *block, enum tc_setup_type type,\n\t\t     void *type_data, bool err_stop, bool rtnl_held)\n{\n\tbool take_rtnl = READ_ONCE(block->lockeddevcnt) && !rtnl_held;\n\tint ok_count;\n\nretry:\n\tif (take_rtnl)\n\t\trtnl_lock();\n\tdown_read(&block->cb_lock);\n\t \n\tif (!rtnl_held && !take_rtnl && block->lockeddevcnt) {\n\t\tup_read(&block->cb_lock);\n\t\ttake_rtnl = true;\n\t\tgoto retry;\n\t}\n\n\tok_count = __tc_setup_cb_call(block, type, type_data, err_stop);\n\n\tup_read(&block->cb_lock);\n\tif (take_rtnl)\n\t\trtnl_unlock();\n\treturn ok_count;\n}\nEXPORT_SYMBOL(tc_setup_cb_call);\n\n \n\nint tc_setup_cb_add(struct tcf_block *block, struct tcf_proto *tp,\n\t\t    enum tc_setup_type type, void *type_data, bool err_stop,\n\t\t    u32 *flags, unsigned int *in_hw_count, bool rtnl_held)\n{\n\tbool take_rtnl = READ_ONCE(block->lockeddevcnt) && !rtnl_held;\n\tint ok_count;\n\nretry:\n\tif (take_rtnl)\n\t\trtnl_lock();\n\tdown_read(&block->cb_lock);\n\t \n\tif (!rtnl_held && !take_rtnl && block->lockeddevcnt) {\n\t\tup_read(&block->cb_lock);\n\t\ttake_rtnl = true;\n\t\tgoto retry;\n\t}\n\n\t \n\tif (block->nooffloaddevcnt && err_stop) {\n\t\tok_count = -EOPNOTSUPP;\n\t\tgoto err_unlock;\n\t}\n\n\tok_count = __tc_setup_cb_call(block, type, type_data, err_stop);\n\tif (ok_count < 0)\n\t\tgoto err_unlock;\n\n\tif (tp->ops->hw_add)\n\t\ttp->ops->hw_add(tp, type_data);\n\tif (ok_count > 0)\n\t\ttc_cls_offload_cnt_update(block, tp, in_hw_count, flags,\n\t\t\t\t\t  ok_count, true);\nerr_unlock:\n\tup_read(&block->cb_lock);\n\tif (take_rtnl)\n\t\trtnl_unlock();\n\treturn min(ok_count, 0);\n}\nEXPORT_SYMBOL(tc_setup_cb_add);\n\n \n\nint tc_setup_cb_replace(struct tcf_block *block, struct tcf_proto *tp,\n\t\t\tenum tc_setup_type type, void *type_data, bool err_stop,\n\t\t\tu32 *old_flags, unsigned int *old_in_hw_count,\n\t\t\tu32 *new_flags, unsigned int *new_in_hw_count,\n\t\t\tbool rtnl_held)\n{\n\tbool take_rtnl = READ_ONCE(block->lockeddevcnt) && !rtnl_held;\n\tint ok_count;\n\nretry:\n\tif (take_rtnl)\n\t\trtnl_lock();\n\tdown_read(&block->cb_lock);\n\t \n\tif (!rtnl_held && !take_rtnl && block->lockeddevcnt) {\n\t\tup_read(&block->cb_lock);\n\t\ttake_rtnl = true;\n\t\tgoto retry;\n\t}\n\n\t \n\tif (block->nooffloaddevcnt && err_stop) {\n\t\tok_count = -EOPNOTSUPP;\n\t\tgoto err_unlock;\n\t}\n\n\ttc_cls_offload_cnt_reset(block, tp, old_in_hw_count, old_flags);\n\tif (tp->ops->hw_del)\n\t\ttp->ops->hw_del(tp, type_data);\n\n\tok_count = __tc_setup_cb_call(block, type, type_data, err_stop);\n\tif (ok_count < 0)\n\t\tgoto err_unlock;\n\n\tif (tp->ops->hw_add)\n\t\ttp->ops->hw_add(tp, type_data);\n\tif (ok_count > 0)\n\t\ttc_cls_offload_cnt_update(block, tp, new_in_hw_count,\n\t\t\t\t\t  new_flags, ok_count, true);\nerr_unlock:\n\tup_read(&block->cb_lock);\n\tif (take_rtnl)\n\t\trtnl_unlock();\n\treturn min(ok_count, 0);\n}\nEXPORT_SYMBOL(tc_setup_cb_replace);\n\n \n\nint tc_setup_cb_destroy(struct tcf_block *block, struct tcf_proto *tp,\n\t\t\tenum tc_setup_type type, void *type_data, bool err_stop,\n\t\t\tu32 *flags, unsigned int *in_hw_count, bool rtnl_held)\n{\n\tbool take_rtnl = READ_ONCE(block->lockeddevcnt) && !rtnl_held;\n\tint ok_count;\n\nretry:\n\tif (take_rtnl)\n\t\trtnl_lock();\n\tdown_read(&block->cb_lock);\n\t \n\tif (!rtnl_held && !take_rtnl && block->lockeddevcnt) {\n\t\tup_read(&block->cb_lock);\n\t\ttake_rtnl = true;\n\t\tgoto retry;\n\t}\n\n\tok_count = __tc_setup_cb_call(block, type, type_data, err_stop);\n\n\ttc_cls_offload_cnt_reset(block, tp, in_hw_count, flags);\n\tif (tp->ops->hw_del)\n\t\ttp->ops->hw_del(tp, type_data);\n\n\tup_read(&block->cb_lock);\n\tif (take_rtnl)\n\t\trtnl_unlock();\n\treturn min(ok_count, 0);\n}\nEXPORT_SYMBOL(tc_setup_cb_destroy);\n\nint tc_setup_cb_reoffload(struct tcf_block *block, struct tcf_proto *tp,\n\t\t\t  bool add, flow_setup_cb_t *cb,\n\t\t\t  enum tc_setup_type type, void *type_data,\n\t\t\t  void *cb_priv, u32 *flags, unsigned int *in_hw_count)\n{\n\tint err = cb(type, type_data, cb_priv);\n\n\tif (err) {\n\t\tif (add && tc_skip_sw(*flags))\n\t\t\treturn err;\n\t} else {\n\t\ttc_cls_offload_cnt_update(block, tp, in_hw_count, flags, 1,\n\t\t\t\t\t  add);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tc_setup_cb_reoffload);\n\nstatic int tcf_act_get_user_cookie(struct flow_action_entry *entry,\n\t\t\t\t   const struct tc_action *act)\n{\n\tstruct tc_cookie *user_cookie;\n\tint err = 0;\n\n\trcu_read_lock();\n\tuser_cookie = rcu_dereference(act->user_cookie);\n\tif (user_cookie) {\n\t\tentry->user_cookie = flow_action_cookie_create(user_cookie->data,\n\t\t\t\t\t\t\t       user_cookie->len,\n\t\t\t\t\t\t\t       GFP_ATOMIC);\n\t\tif (!entry->user_cookie)\n\t\t\terr = -ENOMEM;\n\t}\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic void tcf_act_put_user_cookie(struct flow_action_entry *entry)\n{\n\tflow_action_cookie_destroy(entry->user_cookie);\n}\n\nvoid tc_cleanup_offload_action(struct flow_action *flow_action)\n{\n\tstruct flow_action_entry *entry;\n\tint i;\n\n\tflow_action_for_each(i, entry, flow_action) {\n\t\ttcf_act_put_user_cookie(entry);\n\t\tif (entry->destructor)\n\t\t\tentry->destructor(entry->destructor_priv);\n\t}\n}\nEXPORT_SYMBOL(tc_cleanup_offload_action);\n\nstatic int tc_setup_offload_act(struct tc_action *act,\n\t\t\t\tstruct flow_action_entry *entry,\n\t\t\t\tu32 *index_inc,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n#ifdef CONFIG_NET_CLS_ACT\n\tif (act->ops->offload_act_setup) {\n\t\treturn act->ops->offload_act_setup(act, entry, index_inc, true,\n\t\t\t\t\t\t   extack);\n\t} else {\n\t\tNL_SET_ERR_MSG(extack, \"Action does not support offload\");\n\t\treturn -EOPNOTSUPP;\n\t}\n#else\n\treturn 0;\n#endif\n}\n\nint tc_setup_action(struct flow_action *flow_action,\n\t\t    struct tc_action *actions[],\n\t\t    u32 miss_cookie_base,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tint i, j, k, index, err = 0;\n\tstruct tc_action *act;\n\n\tBUILD_BUG_ON(TCA_ACT_HW_STATS_ANY != FLOW_ACTION_HW_STATS_ANY);\n\tBUILD_BUG_ON(TCA_ACT_HW_STATS_IMMEDIATE != FLOW_ACTION_HW_STATS_IMMEDIATE);\n\tBUILD_BUG_ON(TCA_ACT_HW_STATS_DELAYED != FLOW_ACTION_HW_STATS_DELAYED);\n\n\tif (!actions)\n\t\treturn 0;\n\n\tj = 0;\n\ttcf_act_for_each_action(i, act, actions) {\n\t\tstruct flow_action_entry *entry;\n\n\t\tentry = &flow_action->entries[j];\n\t\tspin_lock_bh(&act->tcfa_lock);\n\t\terr = tcf_act_get_user_cookie(entry, act);\n\t\tif (err)\n\t\t\tgoto err_out_locked;\n\n\t\tindex = 0;\n\t\terr = tc_setup_offload_act(act, entry, &index, extack);\n\t\tif (err)\n\t\t\tgoto err_out_locked;\n\n\t\tfor (k = 0; k < index ; k++) {\n\t\t\tentry[k].hw_stats = tc_act_hw_stats(act->hw_stats);\n\t\t\tentry[k].hw_index = act->tcfa_index;\n\t\t\tentry[k].cookie = (unsigned long)act;\n\t\t\tentry[k].miss_cookie =\n\t\t\t\ttcf_exts_miss_cookie_get(miss_cookie_base, i);\n\t\t}\n\n\t\tj += index;\n\n\t\tspin_unlock_bh(&act->tcfa_lock);\n\t}\n\nerr_out:\n\tif (err)\n\t\ttc_cleanup_offload_action(flow_action);\n\n\treturn err;\nerr_out_locked:\n\tspin_unlock_bh(&act->tcfa_lock);\n\tgoto err_out;\n}\n\nint tc_setup_offload_action(struct flow_action *flow_action,\n\t\t\t    const struct tcf_exts *exts,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n#ifdef CONFIG_NET_CLS_ACT\n\tu32 miss_cookie_base;\n\n\tif (!exts)\n\t\treturn 0;\n\n\tmiss_cookie_base = exts->miss_cookie_node ?\n\t\t\t   exts->miss_cookie_node->miss_cookie_base : 0;\n\treturn tc_setup_action(flow_action, exts->actions, miss_cookie_base,\n\t\t\t       extack);\n#else\n\treturn 0;\n#endif\n}\nEXPORT_SYMBOL(tc_setup_offload_action);\n\nunsigned int tcf_exts_num_actions(struct tcf_exts *exts)\n{\n\tunsigned int num_acts = 0;\n\tstruct tc_action *act;\n\tint i;\n\n\ttcf_exts_for_each_action(i, act, exts) {\n\t\tif (is_tcf_pedit(act))\n\t\t\tnum_acts += tcf_pedit_nkeys(act);\n\t\telse\n\t\t\tnum_acts++;\n\t}\n\treturn num_acts;\n}\nEXPORT_SYMBOL(tcf_exts_num_actions);\n\n#ifdef CONFIG_NET_CLS_ACT\nstatic int tcf_qevent_parse_block_index(struct nlattr *block_index_attr,\n\t\t\t\t\tu32 *p_block_index,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\t*p_block_index = nla_get_u32(block_index_attr);\n\tif (!*p_block_index) {\n\t\tNL_SET_ERR_MSG(extack, \"Block number may not be zero\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint tcf_qevent_init(struct tcf_qevent *qe, struct Qdisc *sch,\n\t\t    enum flow_block_binder_type binder_type,\n\t\t    struct nlattr *block_index_attr,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tu32 block_index;\n\tint err;\n\n\tif (!block_index_attr)\n\t\treturn 0;\n\n\terr = tcf_qevent_parse_block_index(block_index_attr, &block_index, extack);\n\tif (err)\n\t\treturn err;\n\n\tqe->info.binder_type = binder_type;\n\tqe->info.chain_head_change = tcf_chain_head_change_dflt;\n\tqe->info.chain_head_change_priv = &qe->filter_chain;\n\tqe->info.block_index = block_index;\n\n\treturn tcf_block_get_ext(&qe->block, sch, &qe->info, extack);\n}\nEXPORT_SYMBOL(tcf_qevent_init);\n\nvoid tcf_qevent_destroy(struct tcf_qevent *qe, struct Qdisc *sch)\n{\n\tif (qe->info.block_index)\n\t\ttcf_block_put_ext(qe->block, sch, &qe->info);\n}\nEXPORT_SYMBOL(tcf_qevent_destroy);\n\nint tcf_qevent_validate_change(struct tcf_qevent *qe, struct nlattr *block_index_attr,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tu32 block_index;\n\tint err;\n\n\tif (!block_index_attr)\n\t\treturn 0;\n\n\terr = tcf_qevent_parse_block_index(block_index_attr, &block_index, extack);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (block_index != qe->info.block_index) {\n\t\tNL_SET_ERR_MSG(extack, \"Change of blocks is not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tcf_qevent_validate_change);\n\nstruct sk_buff *tcf_qevent_handle(struct tcf_qevent *qe, struct Qdisc *sch, struct sk_buff *skb,\n\t\t\t\t  struct sk_buff **to_free, int *ret)\n{\n\tstruct tcf_result cl_res;\n\tstruct tcf_proto *fl;\n\n\tif (!qe->info.block_index)\n\t\treturn skb;\n\n\tfl = rcu_dereference_bh(qe->filter_chain);\n\n\tswitch (tcf_classify(skb, NULL, fl, &cl_res, false)) {\n\tcase TC_ACT_SHOT:\n\t\tqdisc_qstats_drop(sch);\n\t\t__qdisc_drop(skb, to_free);\n\t\t*ret = __NET_XMIT_BYPASS;\n\t\treturn NULL;\n\tcase TC_ACT_STOLEN:\n\tcase TC_ACT_QUEUED:\n\tcase TC_ACT_TRAP:\n\t\t__qdisc_drop(skb, to_free);\n\t\t*ret = __NET_XMIT_STOLEN;\n\t\treturn NULL;\n\tcase TC_ACT_REDIRECT:\n\t\tskb_do_redirect(skb);\n\t\t*ret = __NET_XMIT_STOLEN;\n\t\treturn NULL;\n\t}\n\n\treturn skb;\n}\nEXPORT_SYMBOL(tcf_qevent_handle);\n\nint tcf_qevent_dump(struct sk_buff *skb, int attr_name, struct tcf_qevent *qe)\n{\n\tif (!qe->info.block_index)\n\t\treturn 0;\n\treturn nla_put_u32(skb, attr_name, qe->info.block_index);\n}\nEXPORT_SYMBOL(tcf_qevent_dump);\n#endif\n\nstatic __net_init int tcf_net_init(struct net *net)\n{\n\tstruct tcf_net *tn = net_generic(net, tcf_net_id);\n\n\tspin_lock_init(&tn->idr_lock);\n\tidr_init(&tn->idr);\n\treturn 0;\n}\n\nstatic void __net_exit tcf_net_exit(struct net *net)\n{\n\tstruct tcf_net *tn = net_generic(net, tcf_net_id);\n\n\tidr_destroy(&tn->idr);\n}\n\nstatic struct pernet_operations tcf_net_ops = {\n\t.init = tcf_net_init,\n\t.exit = tcf_net_exit,\n\t.id   = &tcf_net_id,\n\t.size = sizeof(struct tcf_net),\n};\n\nstatic int __init tc_filter_init(void)\n{\n\tint err;\n\n\ttc_filter_wq = alloc_ordered_workqueue(\"tc_filter_workqueue\", 0);\n\tif (!tc_filter_wq)\n\t\treturn -ENOMEM;\n\n\terr = register_pernet_subsys(&tcf_net_ops);\n\tif (err)\n\t\tgoto err_register_pernet_subsys;\n\n\txa_init_flags(&tcf_exts_miss_cookies_xa, XA_FLAGS_ALLOC1);\n\n\trtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_new_tfilter, NULL,\n\t\t      RTNL_FLAG_DOIT_UNLOCKED);\n\trtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_del_tfilter, NULL,\n\t\t      RTNL_FLAG_DOIT_UNLOCKED);\n\trtnl_register(PF_UNSPEC, RTM_GETTFILTER, tc_get_tfilter,\n\t\t      tc_dump_tfilter, RTNL_FLAG_DOIT_UNLOCKED);\n\trtnl_register(PF_UNSPEC, RTM_NEWCHAIN, tc_ctl_chain, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELCHAIN, tc_ctl_chain, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETCHAIN, tc_ctl_chain,\n\t\t      tc_dump_chain, 0);\n\n\treturn 0;\n\nerr_register_pernet_subsys:\n\tdestroy_workqueue(tc_filter_wq);\n\treturn err;\n}\n\nsubsys_initcall(tc_filter_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}