{
  "module_name": "act_ctinfo.c",
  "hash_id": "6b7f2af7664950e60e877b67ff2d4844468f73ec76bb96e25ed970b271a4a694",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_ctinfo.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/pkt_cls.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/act_api.h>\n#include <net/pkt_cls.h>\n#include <uapi/linux/tc_act/tc_ctinfo.h>\n#include <net/tc_act/tc_ctinfo.h>\n#include <net/tc_wrapper.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n\nstatic struct tc_action_ops act_ctinfo_ops;\n\nstatic void tcf_ctinfo_dscp_set(struct nf_conn *ct, struct tcf_ctinfo *ca,\n\t\t\t\tstruct tcf_ctinfo_params *cp,\n\t\t\t\tstruct sk_buff *skb, int wlen, int proto)\n{\n\tu8 dscp, newdscp;\n\n\tnewdscp = (((READ_ONCE(ct->mark) & cp->dscpmask) >> cp->dscpmaskshift) << 2) &\n\t\t     ~INET_ECN_MASK;\n\n\tswitch (proto) {\n\tcase NFPROTO_IPV4:\n\t\tdscp = ipv4_get_dsfield(ip_hdr(skb)) & ~INET_ECN_MASK;\n\t\tif (dscp != newdscp) {\n\t\t\tif (likely(!skb_try_make_writable(skb, wlen))) {\n\t\t\t\tipv4_change_dsfield(ip_hdr(skb),\n\t\t\t\t\t\t    INET_ECN_MASK,\n\t\t\t\t\t\t    newdscp);\n\t\t\t\tca->stats_dscp_set++;\n\t\t\t} else {\n\t\t\t\tca->stats_dscp_error++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tdscp = ipv6_get_dsfield(ipv6_hdr(skb)) & ~INET_ECN_MASK;\n\t\tif (dscp != newdscp) {\n\t\t\tif (likely(!skb_try_make_writable(skb, wlen))) {\n\t\t\t\tipv6_change_dsfield(ipv6_hdr(skb),\n\t\t\t\t\t\t    INET_ECN_MASK,\n\t\t\t\t\t\t    newdscp);\n\t\t\t\tca->stats_dscp_set++;\n\t\t\t} else {\n\t\t\t\tca->stats_dscp_error++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void tcf_ctinfo_cpmark_set(struct nf_conn *ct, struct tcf_ctinfo *ca,\n\t\t\t\t  struct tcf_ctinfo_params *cp,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tca->stats_cpmark_set++;\n\tskb->mark = READ_ONCE(ct->mark) & cp->cpmarkmask;\n}\n\nTC_INDIRECT_SCOPE int tcf_ctinfo_act(struct sk_buff *skb,\n\t\t\t\t     const struct tc_action *a,\n\t\t\t\t     struct tcf_result *res)\n{\n\tconst struct nf_conntrack_tuple_hash *thash = NULL;\n\tstruct tcf_ctinfo *ca = to_ctinfo(a);\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nf_conntrack_zone zone;\n\tenum ip_conntrack_info ctinfo;\n\tstruct tcf_ctinfo_params *cp;\n\tstruct nf_conn *ct;\n\tint proto, wlen;\n\tint action;\n\n\tcp = rcu_dereference_bh(ca->params);\n\n\ttcf_lastuse_update(&ca->tcf_tm);\n\ttcf_action_update_bstats(&ca->common, skb);\n\taction = READ_ONCE(ca->tcf_action);\n\n\twlen = skb_network_offset(skb);\n\tswitch (skb_protocol(skb, true)) {\n\tcase htons(ETH_P_IP):\n\t\twlen += sizeof(struct iphdr);\n\t\tif (!pskb_may_pull(skb, wlen))\n\t\t\tgoto out;\n\n\t\tproto = NFPROTO_IPV4;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\twlen += sizeof(struct ipv6hdr);\n\t\tif (!pskb_may_pull(skb, wlen))\n\t\t\tgoto out;\n\n\t\tproto = NFPROTO_IPV6;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (!ct) {  \n\t\tif (!nf_ct_get_tuplepr(skb, skb_network_offset(skb),\n\t\t\t\t       proto, cp->net, &tuple))\n\t\t\tgoto out;\n\t\tzone.id = cp->zone;\n\t\tzone.dir = NF_CT_DEFAULT_ZONE_DIR;\n\n\t\tthash = nf_conntrack_find_get(cp->net, &zone, &tuple);\n\t\tif (!thash)\n\t\t\tgoto out;\n\n\t\tct = nf_ct_tuplehash_to_ctrack(thash);\n\t}\n\n\tif (cp->mode & CTINFO_MODE_DSCP)\n\t\tif (!cp->dscpstatemask || (READ_ONCE(ct->mark) & cp->dscpstatemask))\n\t\t\ttcf_ctinfo_dscp_set(ct, ca, cp, skb, wlen, proto);\n\n\tif (cp->mode & CTINFO_MODE_CPMARK)\n\t\ttcf_ctinfo_cpmark_set(ct, ca, cp, skb);\n\n\tif (thash)\n\t\tnf_ct_put(ct);\nout:\n\treturn action;\n}\n\nstatic const struct nla_policy ctinfo_policy[TCA_CTINFO_MAX + 1] = {\n\t[TCA_CTINFO_ACT]\t\t  =\n\t\tNLA_POLICY_EXACT_LEN(sizeof(struct tc_ctinfo)),\n\t[TCA_CTINFO_ZONE]\t\t  = { .type = NLA_U16 },\n\t[TCA_CTINFO_PARMS_DSCP_MASK]\t  = { .type = NLA_U32 },\n\t[TCA_CTINFO_PARMS_DSCP_STATEMASK] = { .type = NLA_U32 },\n\t[TCA_CTINFO_PARMS_CPMARK_MASK]\t  = { .type = NLA_U32 },\n};\n\nstatic int tcf_ctinfo_init(struct net *net, struct nlattr *nla,\n\t\t\t   struct nlattr *est, struct tc_action **a,\n\t\t\t   struct tcf_proto *tp, u32 flags,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_ctinfo_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tu32 dscpmask = 0, dscpstatemask, index;\n\tstruct nlattr *tb[TCA_CTINFO_MAX + 1];\n\tstruct tcf_ctinfo_params *cp_new;\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tc_ctinfo *actparm;\n\tstruct tcf_ctinfo *ci;\n\tu8 dscpmaskshift;\n\tint ret = 0, err;\n\n\tif (!nla) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"ctinfo requires attributes to be passed\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested(tb, TCA_CTINFO_MAX, nla, ctinfo_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_CTINFO_ACT]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Missing required TCA_CTINFO_ACT attribute\");\n\t\treturn -EINVAL;\n\t}\n\tactparm = nla_data(tb[TCA_CTINFO_ACT]);\n\n\t \n\t \n\tif (tb[TCA_CTINFO_PARMS_DSCP_MASK]) {\n\t\tdscpmask = nla_get_u32(tb[TCA_CTINFO_PARMS_DSCP_MASK]);\n\t\t \n\t\tdscpmaskshift = dscpmask ? __ffs(dscpmask) : 0;\n\t\tif ((~0 & (dscpmask >> dscpmaskshift)) != 0x3f) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[TCA_CTINFO_PARMS_DSCP_MASK],\n\t\t\t\t\t    \"dscp mask must be 6 contiguous bits\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdscpstatemask = tb[TCA_CTINFO_PARMS_DSCP_STATEMASK] ?\n\t\t\tnla_get_u32(tb[TCA_CTINFO_PARMS_DSCP_STATEMASK]) : 0;\n\t\t \n\t\tif (dscpmask & dscpstatemask) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[TCA_CTINFO_PARMS_DSCP_STATEMASK],\n\t\t\t\t\t    \"dscp statemask must not overlap dscp mask\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tindex = actparm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (!err) {\n\t\tret = tcf_idr_create_from_flags(tn, index, est, a,\n\t\t\t\t\t\t&act_ctinfo_ops, bind, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ACT_P_CREATED;\n\t} else if (err > 0) {\n\t\tif (bind)  \n\t\t\treturn 0;\n\t\tif (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\t\ttcf_idr_release(*a, bind);\n\t\t\treturn -EEXIST;\n\t\t}\n\t} else {\n\t\treturn err;\n\t}\n\n\terr = tcf_action_check_ctrlact(actparm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\tci = to_ctinfo(*a);\n\n\tcp_new = kzalloc(sizeof(*cp_new), GFP_KERNEL);\n\tif (unlikely(!cp_new)) {\n\t\terr = -ENOMEM;\n\t\tgoto put_chain;\n\t}\n\n\tcp_new->net = net;\n\tcp_new->zone = tb[TCA_CTINFO_ZONE] ?\n\t\t\tnla_get_u16(tb[TCA_CTINFO_ZONE]) : 0;\n\tif (dscpmask) {\n\t\tcp_new->dscpmask = dscpmask;\n\t\tcp_new->dscpmaskshift = dscpmaskshift;\n\t\tcp_new->dscpstatemask = dscpstatemask;\n\t\tcp_new->mode |= CTINFO_MODE_DSCP;\n\t}\n\n\tif (tb[TCA_CTINFO_PARMS_CPMARK_MASK]) {\n\t\tcp_new->cpmarkmask =\n\t\t\t\tnla_get_u32(tb[TCA_CTINFO_PARMS_CPMARK_MASK]);\n\t\tcp_new->mode |= CTINFO_MODE_CPMARK;\n\t}\n\n\tspin_lock_bh(&ci->tcf_lock);\n\tgoto_ch = tcf_action_set_ctrlact(*a, actparm->action, goto_ch);\n\tcp_new = rcu_replace_pointer(ci->params, cp_new,\n\t\t\t\t     lockdep_is_held(&ci->tcf_lock));\n\tspin_unlock_bh(&ci->tcf_lock);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\tif (cp_new)\n\t\tkfree_rcu(cp_new, rcu);\n\n\treturn ret;\n\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic int tcf_ctinfo_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tstruct tcf_ctinfo *ci = to_ctinfo(a);\n\tstruct tc_ctinfo opt = {\n\t\t.index   = ci->tcf_index,\n\t\t.refcnt  = refcount_read(&ci->tcf_refcnt) - ref,\n\t\t.bindcnt = atomic_read(&ci->tcf_bindcnt) - bind,\n\t};\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_ctinfo_params *cp;\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&ci->tcf_lock);\n\tcp = rcu_dereference_protected(ci->params,\n\t\t\t\t       lockdep_is_held(&ci->tcf_lock));\n\n\ttcf_tm_dump(&t, &ci->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_CTINFO_TM, sizeof(t), &t, TCA_CTINFO_PAD))\n\t\tgoto nla_put_failure;\n\n\topt.action = ci->tcf_action;\n\tif (nla_put(skb, TCA_CTINFO_ACT, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, TCA_CTINFO_ZONE, cp->zone))\n\t\tgoto nla_put_failure;\n\n\tif (cp->mode & CTINFO_MODE_DSCP) {\n\t\tif (nla_put_u32(skb, TCA_CTINFO_PARMS_DSCP_MASK,\n\t\t\t\tcp->dscpmask))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, TCA_CTINFO_PARMS_DSCP_STATEMASK,\n\t\t\t\tcp->dscpstatemask))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (cp->mode & CTINFO_MODE_CPMARK) {\n\t\tif (nla_put_u32(skb, TCA_CTINFO_PARMS_CPMARK_MASK,\n\t\t\t\tcp->cpmarkmask))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u64_64bit(skb, TCA_CTINFO_STATS_DSCP_SET,\n\t\t\t      ci->stats_dscp_set, TCA_CTINFO_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(skb, TCA_CTINFO_STATS_DSCP_ERROR,\n\t\t\t      ci->stats_dscp_error, TCA_CTINFO_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(skb, TCA_CTINFO_STATS_CPMARK_SET,\n\t\t\t      ci->stats_cpmark_set, TCA_CTINFO_PAD))\n\t\tgoto nla_put_failure;\n\n\tspin_unlock_bh(&ci->tcf_lock);\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&ci->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic void tcf_ctinfo_cleanup(struct tc_action *a)\n{\n\tstruct tcf_ctinfo *ci = to_ctinfo(a);\n\tstruct tcf_ctinfo_params *cp;\n\n\tcp = rcu_dereference_protected(ci->params, 1);\n\tif (cp)\n\t\tkfree_rcu(cp, rcu);\n}\n\nstatic struct tc_action_ops act_ctinfo_ops = {\n\t.kind\t= \"ctinfo\",\n\t.id\t= TCA_ID_CTINFO,\n\t.owner\t= THIS_MODULE,\n\t.act\t= tcf_ctinfo_act,\n\t.dump\t= tcf_ctinfo_dump,\n\t.init\t= tcf_ctinfo_init,\n\t.cleanup= tcf_ctinfo_cleanup,\n\t.size\t= sizeof(struct tcf_ctinfo),\n};\n\nstatic __net_init int ctinfo_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_ctinfo_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_ctinfo_ops);\n}\n\nstatic void __net_exit ctinfo_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_ctinfo_ops.net_id);\n}\n\nstatic struct pernet_operations ctinfo_net_ops = {\n\t.init\t\t= ctinfo_init_net,\n\t.exit_batch\t= ctinfo_exit_net,\n\t.id\t\t= &act_ctinfo_ops.net_id,\n\t.size\t\t= sizeof(struct tc_action_net),\n};\n\nstatic int __init ctinfo_init_module(void)\n{\n\treturn tcf_register_action(&act_ctinfo_ops, &ctinfo_net_ops);\n}\n\nstatic void __exit ctinfo_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_ctinfo_ops, &ctinfo_net_ops);\n}\n\nmodule_init(ctinfo_init_module);\nmodule_exit(ctinfo_cleanup_module);\nMODULE_AUTHOR(\"Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>\");\nMODULE_DESCRIPTION(\"Connection tracking mark actions\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}