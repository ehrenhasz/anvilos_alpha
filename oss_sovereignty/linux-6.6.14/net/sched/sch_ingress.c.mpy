{
  "module_name": "sch_ingress.c",
  "hash_id": "8ee0425e5cc081d15306138cc218a2ac87674d326b0b7a0e6c6f01d18c649e5e",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_ingress.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <net/tcx.h>\n\nstruct ingress_sched_data {\n\tstruct tcf_block *block;\n\tstruct tcf_block_ext_info block_info;\n\tstruct mini_Qdisc_pair miniqp;\n};\n\nstatic struct Qdisc *ingress_leaf(struct Qdisc *sch, unsigned long arg)\n{\n\treturn NULL;\n}\n\nstatic unsigned long ingress_find(struct Qdisc *sch, u32 classid)\n{\n\treturn TC_H_MIN(classid) + 1;\n}\n\nstatic unsigned long ingress_bind_filter(struct Qdisc *sch,\n\t\t\t\t\t unsigned long parent, u32 classid)\n{\n\treturn ingress_find(sch, classid);\n}\n\nstatic void ingress_unbind_filter(struct Qdisc *sch, unsigned long cl)\n{\n}\n\nstatic void ingress_walk(struct Qdisc *sch, struct qdisc_walker *walker)\n{\n}\n\nstatic struct tcf_block *ingress_tcf_block(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ingress_sched_data *q = qdisc_priv(sch);\n\n\treturn q->block;\n}\n\nstatic void clsact_chain_head_change(struct tcf_proto *tp_head, void *priv)\n{\n\tstruct mini_Qdisc_pair *miniqp = priv;\n\n\tmini_qdisc_pair_swap(miniqp, tp_head);\n};\n\nstatic void ingress_ingress_block_set(struct Qdisc *sch, u32 block_index)\n{\n\tstruct ingress_sched_data *q = qdisc_priv(sch);\n\n\tq->block_info.block_index = block_index;\n}\n\nstatic u32 ingress_ingress_block_get(struct Qdisc *sch)\n{\n\tstruct ingress_sched_data *q = qdisc_priv(sch);\n\n\treturn q->block_info.block_index;\n}\n\nstatic int ingress_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ingress_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct bpf_mprog_entry *entry;\n\tbool created;\n\tint err;\n\n\tif (sch->parent != TC_H_INGRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tnet_inc_ingress_queue();\n\n\tentry = tcx_entry_fetch_or_create(dev, true, &created);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\ttcx_miniq_set_active(entry, true);\n\tmini_qdisc_pair_init(&q->miniqp, sch, &tcx_entry(entry)->miniq);\n\tif (created)\n\t\ttcx_entry_update(dev, entry, true);\n\n\tq->block_info.binder_type = FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS;\n\tq->block_info.chain_head_change = clsact_chain_head_change;\n\tq->block_info.chain_head_change_priv = &q->miniqp;\n\n\terr = tcf_block_get_ext(&q->block, sch, &q->block_info, extack);\n\tif (err)\n\t\treturn err;\n\n\tmini_qdisc_pair_block_init(&q->miniqp, q->block);\n\n\treturn 0;\n}\n\nstatic void ingress_destroy(struct Qdisc *sch)\n{\n\tstruct ingress_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct bpf_mprog_entry *entry = rtnl_dereference(dev->tcx_ingress);\n\n\tif (sch->parent != TC_H_INGRESS)\n\t\treturn;\n\n\ttcf_block_put_ext(q->block, sch, &q->block_info);\n\n\tif (entry) {\n\t\ttcx_miniq_set_active(entry, false);\n\t\tif (!tcx_entry_is_active(entry)) {\n\t\t\ttcx_entry_update(dev, NULL, true);\n\t\t\ttcx_entry_free(entry);\n\t\t}\n\t}\n\n\tnet_dec_ingress_queue();\n}\n\nstatic int ingress_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\treturn nla_nest_end(skb, nest);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic const struct Qdisc_class_ops ingress_class_ops = {\n\t.flags\t\t=\tQDISC_CLASS_OPS_DOIT_UNLOCKED,\n\t.leaf\t\t=\tingress_leaf,\n\t.find\t\t=\tingress_find,\n\t.walk\t\t=\tingress_walk,\n\t.tcf_block\t=\tingress_tcf_block,\n\t.bind_tcf\t=\tingress_bind_filter,\n\t.unbind_tcf\t=\tingress_unbind_filter,\n};\n\nstatic struct Qdisc_ops ingress_qdisc_ops __read_mostly = {\n\t.cl_ops\t\t\t=\t&ingress_class_ops,\n\t.id\t\t\t=\t\"ingress\",\n\t.priv_size\t\t=\tsizeof(struct ingress_sched_data),\n\t.static_flags\t\t=\tTCQ_F_INGRESS | TCQ_F_CPUSTATS,\n\t.init\t\t\t=\tingress_init,\n\t.destroy\t\t=\tingress_destroy,\n\t.dump\t\t\t=\tingress_dump,\n\t.ingress_block_set\t=\tingress_ingress_block_set,\n\t.ingress_block_get\t=\tingress_ingress_block_get,\n\t.owner\t\t\t=\tTHIS_MODULE,\n};\n\nstruct clsact_sched_data {\n\tstruct tcf_block *ingress_block;\n\tstruct tcf_block *egress_block;\n\tstruct tcf_block_ext_info ingress_block_info;\n\tstruct tcf_block_ext_info egress_block_info;\n\tstruct mini_Qdisc_pair miniqp_ingress;\n\tstruct mini_Qdisc_pair miniqp_egress;\n};\n\nstatic unsigned long clsact_find(struct Qdisc *sch, u32 classid)\n{\n\tswitch (TC_H_MIN(classid)) {\n\tcase TC_H_MIN(TC_H_MIN_INGRESS):\n\tcase TC_H_MIN(TC_H_MIN_EGRESS):\n\t\treturn TC_H_MIN(classid);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic unsigned long clsact_bind_filter(struct Qdisc *sch,\n\t\t\t\t\tunsigned long parent, u32 classid)\n{\n\treturn clsact_find(sch, classid);\n}\n\nstatic struct tcf_block *clsact_tcf_block(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct clsact_sched_data *q = qdisc_priv(sch);\n\n\tswitch (cl) {\n\tcase TC_H_MIN(TC_H_MIN_INGRESS):\n\t\treturn q->ingress_block;\n\tcase TC_H_MIN(TC_H_MIN_EGRESS):\n\t\treturn q->egress_block;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic void clsact_ingress_block_set(struct Qdisc *sch, u32 block_index)\n{\n\tstruct clsact_sched_data *q = qdisc_priv(sch);\n\n\tq->ingress_block_info.block_index = block_index;\n}\n\nstatic void clsact_egress_block_set(struct Qdisc *sch, u32 block_index)\n{\n\tstruct clsact_sched_data *q = qdisc_priv(sch);\n\n\tq->egress_block_info.block_index = block_index;\n}\n\nstatic u32 clsact_ingress_block_get(struct Qdisc *sch)\n{\n\tstruct clsact_sched_data *q = qdisc_priv(sch);\n\n\treturn q->ingress_block_info.block_index;\n}\n\nstatic u32 clsact_egress_block_get(struct Qdisc *sch)\n{\n\tstruct clsact_sched_data *q = qdisc_priv(sch);\n\n\treturn q->egress_block_info.block_index;\n}\n\nstatic int clsact_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct clsact_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct bpf_mprog_entry *entry;\n\tbool created;\n\tint err;\n\n\tif (sch->parent != TC_H_CLSACT)\n\t\treturn -EOPNOTSUPP;\n\n\tnet_inc_ingress_queue();\n\tnet_inc_egress_queue();\n\n\tentry = tcx_entry_fetch_or_create(dev, true, &created);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\ttcx_miniq_set_active(entry, true);\n\tmini_qdisc_pair_init(&q->miniqp_ingress, sch, &tcx_entry(entry)->miniq);\n\tif (created)\n\t\ttcx_entry_update(dev, entry, true);\n\n\tq->ingress_block_info.binder_type = FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS;\n\tq->ingress_block_info.chain_head_change = clsact_chain_head_change;\n\tq->ingress_block_info.chain_head_change_priv = &q->miniqp_ingress;\n\n\terr = tcf_block_get_ext(&q->ingress_block, sch, &q->ingress_block_info,\n\t\t\t\textack);\n\tif (err)\n\t\treturn err;\n\n\tmini_qdisc_pair_block_init(&q->miniqp_ingress, q->ingress_block);\n\n\tentry = tcx_entry_fetch_or_create(dev, false, &created);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\ttcx_miniq_set_active(entry, true);\n\tmini_qdisc_pair_init(&q->miniqp_egress, sch, &tcx_entry(entry)->miniq);\n\tif (created)\n\t\ttcx_entry_update(dev, entry, false);\n\n\tq->egress_block_info.binder_type = FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS;\n\tq->egress_block_info.chain_head_change = clsact_chain_head_change;\n\tq->egress_block_info.chain_head_change_priv = &q->miniqp_egress;\n\n\treturn tcf_block_get_ext(&q->egress_block, sch, &q->egress_block_info, extack);\n}\n\nstatic void clsact_destroy(struct Qdisc *sch)\n{\n\tstruct clsact_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct bpf_mprog_entry *ingress_entry = rtnl_dereference(dev->tcx_ingress);\n\tstruct bpf_mprog_entry *egress_entry = rtnl_dereference(dev->tcx_egress);\n\n\tif (sch->parent != TC_H_CLSACT)\n\t\treturn;\n\n\ttcf_block_put_ext(q->ingress_block, sch, &q->ingress_block_info);\n\ttcf_block_put_ext(q->egress_block, sch, &q->egress_block_info);\n\n\tif (ingress_entry) {\n\t\ttcx_miniq_set_active(ingress_entry, false);\n\t\tif (!tcx_entry_is_active(ingress_entry)) {\n\t\t\ttcx_entry_update(dev, NULL, true);\n\t\t\ttcx_entry_free(ingress_entry);\n\t\t}\n\t}\n\n\tif (egress_entry) {\n\t\ttcx_miniq_set_active(egress_entry, false);\n\t\tif (!tcx_entry_is_active(egress_entry)) {\n\t\t\ttcx_entry_update(dev, NULL, false);\n\t\t\ttcx_entry_free(egress_entry);\n\t\t}\n\t}\n\n\tnet_dec_ingress_queue();\n\tnet_dec_egress_queue();\n}\n\nstatic const struct Qdisc_class_ops clsact_class_ops = {\n\t.flags\t\t=\tQDISC_CLASS_OPS_DOIT_UNLOCKED,\n\t.leaf\t\t=\tingress_leaf,\n\t.find\t\t=\tclsact_find,\n\t.walk\t\t=\tingress_walk,\n\t.tcf_block\t=\tclsact_tcf_block,\n\t.bind_tcf\t=\tclsact_bind_filter,\n\t.unbind_tcf\t=\tingress_unbind_filter,\n};\n\nstatic struct Qdisc_ops clsact_qdisc_ops __read_mostly = {\n\t.cl_ops\t\t\t=\t&clsact_class_ops,\n\t.id\t\t\t=\t\"clsact\",\n\t.priv_size\t\t=\tsizeof(struct clsact_sched_data),\n\t.static_flags\t\t=\tTCQ_F_INGRESS | TCQ_F_CPUSTATS,\n\t.init\t\t\t=\tclsact_init,\n\t.destroy\t\t=\tclsact_destroy,\n\t.dump\t\t\t=\tingress_dump,\n\t.ingress_block_set\t=\tclsact_ingress_block_set,\n\t.egress_block_set\t=\tclsact_egress_block_set,\n\t.ingress_block_get\t=\tclsact_ingress_block_get,\n\t.egress_block_get\t=\tclsact_egress_block_get,\n\t.owner\t\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init ingress_module_init(void)\n{\n\tint ret;\n\n\tret = register_qdisc(&ingress_qdisc_ops);\n\tif (!ret) {\n\t\tret = register_qdisc(&clsact_qdisc_ops);\n\t\tif (ret)\n\t\t\tunregister_qdisc(&ingress_qdisc_ops);\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit ingress_module_exit(void)\n{\n\tunregister_qdisc(&ingress_qdisc_ops);\n\tunregister_qdisc(&clsact_qdisc_ops);\n}\n\nmodule_init(ingress_module_init);\nmodule_exit(ingress_module_exit);\n\nMODULE_ALIAS(\"sch_clsact\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}