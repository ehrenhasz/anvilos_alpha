{
  "module_name": "act_gate.c",
  "hash_id": "00bb595c80d7439124c90503e92f288edbff9ad27b5da53738630833d5f47cd7",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_gate.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/act_api.h>\n#include <net/netlink.h>\n#include <net/pkt_cls.h>\n#include <net/tc_act/tc_gate.h>\n#include <net/tc_wrapper.h>\n\nstatic struct tc_action_ops act_gate_ops;\n\nstatic ktime_t gate_get_time(struct tcf_gate *gact)\n{\n\tktime_t mono = ktime_get();\n\n\tswitch (gact->tk_offset) {\n\tcase TK_OFFS_MAX:\n\t\treturn mono;\n\tdefault:\n\t\treturn ktime_mono_to_any(mono, gact->tk_offset);\n\t}\n\n\treturn KTIME_MAX;\n}\n\nstatic void gate_get_start_time(struct tcf_gate *gact, ktime_t *start)\n{\n\tstruct tcf_gate_params *param = &gact->param;\n\tktime_t now, base, cycle;\n\tu64 n;\n\n\tbase = ns_to_ktime(param->tcfg_basetime);\n\tnow = gate_get_time(gact);\n\n\tif (ktime_after(base, now)) {\n\t\t*start = base;\n\t\treturn;\n\t}\n\n\tcycle = param->tcfg_cycletime;\n\n\tn = div64_u64(ktime_sub_ns(now, base), cycle);\n\t*start = ktime_add_ns(base, (n + 1) * cycle);\n}\n\nstatic void gate_start_timer(struct tcf_gate *gact, ktime_t start)\n{\n\tktime_t expires;\n\n\texpires = hrtimer_get_expires(&gact->hitimer);\n\tif (expires == 0)\n\t\texpires = KTIME_MAX;\n\n\tstart = min_t(ktime_t, start, expires);\n\n\thrtimer_start(&gact->hitimer, start, HRTIMER_MODE_ABS_SOFT);\n}\n\nstatic enum hrtimer_restart gate_timer_func(struct hrtimer *timer)\n{\n\tstruct tcf_gate *gact = container_of(timer, struct tcf_gate,\n\t\t\t\t\t     hitimer);\n\tstruct tcf_gate_params *p = &gact->param;\n\tstruct tcfg_gate_entry *next;\n\tktime_t close_time, now;\n\n\tspin_lock(&gact->tcf_lock);\n\n\tnext = gact->next_entry;\n\n\t \n\tgact->current_gate_status = next->gate_state ? GATE_ACT_GATE_OPEN : 0;\n\tgact->current_entry_octets = 0;\n\tgact->current_max_octets = next->maxoctets;\n\n\tgact->current_close_time = ktime_add_ns(gact->current_close_time,\n\t\t\t\t\t\tnext->interval);\n\n\tclose_time = gact->current_close_time;\n\n\tif (list_is_last(&next->list, &p->entries))\n\t\tnext = list_first_entry(&p->entries,\n\t\t\t\t\tstruct tcfg_gate_entry, list);\n\telse\n\t\tnext = list_next_entry(next, list);\n\n\tnow = gate_get_time(gact);\n\n\tif (ktime_after(now, close_time)) {\n\t\tktime_t cycle, base;\n\t\tu64 n;\n\n\t\tcycle = p->tcfg_cycletime;\n\t\tbase = ns_to_ktime(p->tcfg_basetime);\n\t\tn = div64_u64(ktime_sub_ns(now, base), cycle);\n\t\tclose_time = ktime_add_ns(base, (n + 1) * cycle);\n\t}\n\n\tgact->next_entry = next;\n\n\thrtimer_set_expires(&gact->hitimer, close_time);\n\n\tspin_unlock(&gact->tcf_lock);\n\n\treturn HRTIMER_RESTART;\n}\n\nTC_INDIRECT_SCOPE int tcf_gate_act(struct sk_buff *skb,\n\t\t\t\t   const struct tc_action *a,\n\t\t\t\t   struct tcf_result *res)\n{\n\tstruct tcf_gate *gact = to_gate(a);\n\tint action = READ_ONCE(gact->tcf_action);\n\n\ttcf_lastuse_update(&gact->tcf_tm);\n\ttcf_action_update_bstats(&gact->common, skb);\n\n\tspin_lock(&gact->tcf_lock);\n\tif (unlikely(gact->current_gate_status & GATE_ACT_PENDING)) {\n\t\tspin_unlock(&gact->tcf_lock);\n\t\treturn action;\n\t}\n\n\tif (!(gact->current_gate_status & GATE_ACT_GATE_OPEN)) {\n\t\tspin_unlock(&gact->tcf_lock);\n\t\tgoto drop;\n\t}\n\n\tif (gact->current_max_octets >= 0) {\n\t\tgact->current_entry_octets += qdisc_pkt_len(skb);\n\t\tif (gact->current_entry_octets > gact->current_max_octets) {\n\t\t\tspin_unlock(&gact->tcf_lock);\n\t\t\tgoto overlimit;\n\t\t}\n\t}\n\tspin_unlock(&gact->tcf_lock);\n\n\treturn action;\n\noverlimit:\n\ttcf_action_inc_overlimit_qstats(&gact->common);\ndrop:\n\ttcf_action_inc_drop_qstats(&gact->common);\n\treturn TC_ACT_SHOT;\n}\n\nstatic const struct nla_policy entry_policy[TCA_GATE_ENTRY_MAX + 1] = {\n\t[TCA_GATE_ENTRY_INDEX]\t\t= { .type = NLA_U32 },\n\t[TCA_GATE_ENTRY_GATE]\t\t= { .type = NLA_FLAG },\n\t[TCA_GATE_ENTRY_INTERVAL]\t= { .type = NLA_U32 },\n\t[TCA_GATE_ENTRY_IPV]\t\t= { .type = NLA_S32 },\n\t[TCA_GATE_ENTRY_MAX_OCTETS]\t= { .type = NLA_S32 },\n};\n\nstatic const struct nla_policy gate_policy[TCA_GATE_MAX + 1] = {\n\t[TCA_GATE_PARMS]\t\t=\n\t\tNLA_POLICY_EXACT_LEN(sizeof(struct tc_gate)),\n\t[TCA_GATE_PRIORITY]\t\t= { .type = NLA_S32 },\n\t[TCA_GATE_ENTRY_LIST]\t\t= { .type = NLA_NESTED },\n\t[TCA_GATE_BASE_TIME]\t\t= { .type = NLA_U64 },\n\t[TCA_GATE_CYCLE_TIME]\t\t= { .type = NLA_U64 },\n\t[TCA_GATE_CYCLE_TIME_EXT]\t= { .type = NLA_U64 },\n\t[TCA_GATE_FLAGS]\t\t= { .type = NLA_U32 },\n\t[TCA_GATE_CLOCKID]\t\t= { .type = NLA_S32 },\n};\n\nstatic int fill_gate_entry(struct nlattr **tb, struct tcfg_gate_entry *entry,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tu32 interval = 0;\n\n\tentry->gate_state = nla_get_flag(tb[TCA_GATE_ENTRY_GATE]);\n\n\tif (tb[TCA_GATE_ENTRY_INTERVAL])\n\t\tinterval = nla_get_u32(tb[TCA_GATE_ENTRY_INTERVAL]);\n\n\tif (interval == 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid interval for schedule entry\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry->interval = interval;\n\n\tif (tb[TCA_GATE_ENTRY_IPV])\n\t\tentry->ipv = nla_get_s32(tb[TCA_GATE_ENTRY_IPV]);\n\telse\n\t\tentry->ipv = -1;\n\n\tif (tb[TCA_GATE_ENTRY_MAX_OCTETS])\n\t\tentry->maxoctets = nla_get_s32(tb[TCA_GATE_ENTRY_MAX_OCTETS]);\n\telse\n\t\tentry->maxoctets = -1;\n\n\treturn 0;\n}\n\nstatic int parse_gate_entry(struct nlattr *n, struct  tcfg_gate_entry *entry,\n\t\t\t    int index, struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[TCA_GATE_ENTRY_MAX + 1] = { };\n\tint err;\n\n\terr = nla_parse_nested(tb, TCA_GATE_ENTRY_MAX, n, entry_policy, extack);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Could not parse nested entry\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry->index = index;\n\n\treturn fill_gate_entry(tb, entry, extack);\n}\n\nstatic void release_entry_list(struct list_head *entries)\n{\n\tstruct tcfg_gate_entry *entry, *e;\n\n\tlist_for_each_entry_safe(entry, e, entries, list) {\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n}\n\nstatic int parse_gate_list(struct nlattr *list_attr,\n\t\t\t   struct tcf_gate_params *sched,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct tcfg_gate_entry *entry;\n\tstruct nlattr *n;\n\tint err, rem;\n\tint i = 0;\n\n\tif (!list_attr)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(n, list_attr, rem) {\n\t\tif (nla_type(n) != TCA_GATE_ONE_ENTRY) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Attribute isn't type 'entry'\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\t\tif (!entry) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Not enough memory for entry\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto release_list;\n\t\t}\n\n\t\terr = parse_gate_entry(n, entry, i, extack);\n\t\tif (err < 0) {\n\t\t\tkfree(entry);\n\t\t\tgoto release_list;\n\t\t}\n\n\t\tlist_add_tail(&entry->list, &sched->entries);\n\t\ti++;\n\t}\n\n\tsched->num_entries = i;\n\n\treturn i;\n\nrelease_list:\n\trelease_entry_list(&sched->entries);\n\n\treturn err;\n}\n\nstatic void gate_setup_timer(struct tcf_gate *gact, u64 basetime,\n\t\t\t     enum tk_offsets tko, s32 clockid,\n\t\t\t     bool do_init)\n{\n\tif (!do_init) {\n\t\tif (basetime == gact->param.tcfg_basetime &&\n\t\t    tko == gact->tk_offset &&\n\t\t    clockid == gact->param.tcfg_clockid)\n\t\t\treturn;\n\n\t\tspin_unlock_bh(&gact->tcf_lock);\n\t\thrtimer_cancel(&gact->hitimer);\n\t\tspin_lock_bh(&gact->tcf_lock);\n\t}\n\tgact->param.tcfg_basetime = basetime;\n\tgact->param.tcfg_clockid = clockid;\n\tgact->tk_offset = tko;\n\thrtimer_init(&gact->hitimer, clockid, HRTIMER_MODE_ABS_SOFT);\n\tgact->hitimer.function = gate_timer_func;\n}\n\nstatic int tcf_gate_init(struct net *net, struct nlattr *nla,\n\t\t\t struct nlattr *est, struct tc_action **a,\n\t\t\t struct tcf_proto *tp, u32 flags,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_gate_ops.net_id);\n\tenum tk_offsets tk_offset = TK_OFFS_TAI;\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_GATE_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tu64 cycletime = 0, basetime = 0;\n\tstruct tcf_gate_params *p;\n\ts32 clockid = CLOCK_TAI;\n\tstruct tcf_gate *gact;\n\tstruct tc_gate *parm;\n\tint ret = 0, err;\n\tu32 gflags = 0;\n\ts32 prio = -1;\n\tktime_t start;\n\tu32 index;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(tb, TCA_GATE_MAX, nla, gate_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[TCA_GATE_PARMS])\n\t\treturn -EINVAL;\n\n\tif (tb[TCA_GATE_CLOCKID]) {\n\t\tclockid = nla_get_s32(tb[TCA_GATE_CLOCKID]);\n\t\tswitch (clockid) {\n\t\tcase CLOCK_REALTIME:\n\t\t\ttk_offset = TK_OFFS_REAL;\n\t\t\tbreak;\n\t\tcase CLOCK_MONOTONIC:\n\t\t\ttk_offset = TK_OFFS_MAX;\n\t\t\tbreak;\n\t\tcase CLOCK_BOOTTIME:\n\t\t\ttk_offset = TK_OFFS_BOOT;\n\t\t\tbreak;\n\t\tcase CLOCK_TAI:\n\t\t\ttk_offset = TK_OFFS_TAI;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid 'clockid'\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tparm = nla_data(tb[TCA_GATE_PARMS]);\n\tindex = parm->index;\n\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (err && bind)\n\t\treturn 0;\n\n\tif (!err) {\n\t\tret = tcf_idr_create_from_flags(tn, index, est, a,\n\t\t\t\t\t\t&act_gate_ops, bind, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ACT_P_CREATED;\n\t} else if (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\ttcf_idr_release(*a, bind);\n\t\treturn -EEXIST;\n\t}\n\n\tif (tb[TCA_GATE_PRIORITY])\n\t\tprio = nla_get_s32(tb[TCA_GATE_PRIORITY]);\n\n\tif (tb[TCA_GATE_BASE_TIME])\n\t\tbasetime = nla_get_u64(tb[TCA_GATE_BASE_TIME]);\n\n\tif (tb[TCA_GATE_FLAGS])\n\t\tgflags = nla_get_u32(tb[TCA_GATE_FLAGS]);\n\n\tgact = to_gate(*a);\n\tif (ret == ACT_P_CREATED)\n\t\tINIT_LIST_HEAD(&gact->param.entries);\n\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\tspin_lock_bh(&gact->tcf_lock);\n\tp = &gact->param;\n\n\tif (tb[TCA_GATE_CYCLE_TIME])\n\t\tcycletime = nla_get_u64(tb[TCA_GATE_CYCLE_TIME]);\n\n\tif (tb[TCA_GATE_ENTRY_LIST]) {\n\t\terr = parse_gate_list(tb[TCA_GATE_ENTRY_LIST], p, extack);\n\t\tif (err < 0)\n\t\t\tgoto chain_put;\n\t}\n\n\tif (!cycletime) {\n\t\tstruct tcfg_gate_entry *entry;\n\t\tktime_t cycle = 0;\n\n\t\tlist_for_each_entry(entry, &p->entries, list)\n\t\t\tcycle = ktime_add_ns(cycle, entry->interval);\n\t\tcycletime = cycle;\n\t\tif (!cycletime) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto chain_put;\n\t\t}\n\t}\n\tp->tcfg_cycletime = cycletime;\n\n\tif (tb[TCA_GATE_CYCLE_TIME_EXT])\n\t\tp->tcfg_cycletime_ext =\n\t\t\tnla_get_u64(tb[TCA_GATE_CYCLE_TIME_EXT]);\n\n\tgate_setup_timer(gact, basetime, tk_offset, clockid,\n\t\t\t ret == ACT_P_CREATED);\n\tp->tcfg_priority = prio;\n\tp->tcfg_flags = gflags;\n\tgate_get_start_time(gact, &start);\n\n\tgact->current_close_time = start;\n\tgact->current_gate_status = GATE_ACT_GATE_OPEN | GATE_ACT_PENDING;\n\n\tgact->next_entry = list_first_entry(&p->entries,\n\t\t\t\t\t    struct tcfg_gate_entry, list);\n\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\n\tgate_start_timer(gact, start);\n\n\tspin_unlock_bh(&gact->tcf_lock);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\n\treturn ret;\n\nchain_put:\n\tspin_unlock_bh(&gact->tcf_lock);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\t \n\tif (ret == ACT_P_CREATED)\n\t\tgate_setup_timer(gact, gact->param.tcfg_basetime,\n\t\t\t\t gact->tk_offset, gact->param.tcfg_clockid,\n\t\t\t\t true);\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic void tcf_gate_cleanup(struct tc_action *a)\n{\n\tstruct tcf_gate *gact = to_gate(a);\n\tstruct tcf_gate_params *p;\n\n\tp = &gact->param;\n\thrtimer_cancel(&gact->hitimer);\n\trelease_entry_list(&p->entries);\n}\n\nstatic int dumping_entry(struct sk_buff *skb,\n\t\t\t struct tcfg_gate_entry *entry)\n{\n\tstruct nlattr *item;\n\n\titem = nla_nest_start_noflag(skb, TCA_GATE_ONE_ENTRY);\n\tif (!item)\n\t\treturn -ENOSPC;\n\n\tif (nla_put_u32(skb, TCA_GATE_ENTRY_INDEX, entry->index))\n\t\tgoto nla_put_failure;\n\n\tif (entry->gate_state && nla_put_flag(skb, TCA_GATE_ENTRY_GATE))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, TCA_GATE_ENTRY_INTERVAL, entry->interval))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_s32(skb, TCA_GATE_ENTRY_MAX_OCTETS, entry->maxoctets))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_s32(skb, TCA_GATE_ENTRY_IPV, entry->ipv))\n\t\tgoto nla_put_failure;\n\n\treturn nla_nest_end(skb, item);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, item);\n\treturn -1;\n}\n\nstatic int tcf_gate_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_gate *gact = to_gate(a);\n\tstruct tc_gate opt = {\n\t\t.index    = gact->tcf_index,\n\t\t.refcnt   = refcount_read(&gact->tcf_refcnt) - ref,\n\t\t.bindcnt  = atomic_read(&gact->tcf_bindcnt) - bind,\n\t};\n\tstruct tcfg_gate_entry *entry;\n\tstruct tcf_gate_params *p;\n\tstruct nlattr *entry_list;\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&gact->tcf_lock);\n\topt.action = gact->tcf_action;\n\n\tp = &gact->param;\n\n\tif (nla_put(skb, TCA_GATE_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(skb, TCA_GATE_BASE_TIME,\n\t\t\t      p->tcfg_basetime, TCA_GATE_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(skb, TCA_GATE_CYCLE_TIME,\n\t\t\t      p->tcfg_cycletime, TCA_GATE_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(skb, TCA_GATE_CYCLE_TIME_EXT,\n\t\t\t      p->tcfg_cycletime_ext, TCA_GATE_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_s32(skb, TCA_GATE_CLOCKID, p->tcfg_clockid))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, TCA_GATE_FLAGS, p->tcfg_flags))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_s32(skb, TCA_GATE_PRIORITY, p->tcfg_priority))\n\t\tgoto nla_put_failure;\n\n\tentry_list = nla_nest_start_noflag(skb, TCA_GATE_ENTRY_LIST);\n\tif (!entry_list)\n\t\tgoto nla_put_failure;\n\n\tlist_for_each_entry(entry, &p->entries, list) {\n\t\tif (dumping_entry(skb, entry) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnla_nest_end(skb, entry_list);\n\n\ttcf_tm_dump(&t, &gact->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_GATE_TM, sizeof(t), &t, TCA_GATE_PAD))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&gact->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&gact->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic void tcf_gate_stats_update(struct tc_action *a, u64 bytes, u64 packets,\n\t\t\t\t  u64 drops, u64 lastuse, bool hw)\n{\n\tstruct tcf_gate *gact = to_gate(a);\n\tstruct tcf_t *tm = &gact->tcf_tm;\n\n\ttcf_action_update_stats(a, bytes, packets, drops, hw);\n\ttm->lastuse = max_t(u64, tm->lastuse, lastuse);\n}\n\nstatic size_t tcf_gate_get_fill_size(const struct tc_action *act)\n{\n\treturn nla_total_size(sizeof(struct tc_gate));\n}\n\nstatic void tcf_gate_entry_destructor(void *priv)\n{\n\tstruct action_gate_entry *oe = priv;\n\n\tkfree(oe);\n}\n\nstatic int tcf_gate_get_entries(struct flow_action_entry *entry,\n\t\t\t\tconst struct tc_action *act)\n{\n\tentry->gate.entries = tcf_gate_get_list(act);\n\n\tif (!entry->gate.entries)\n\t\treturn -EINVAL;\n\n\tentry->destructor = tcf_gate_entry_destructor;\n\tentry->destructor_priv = entry->gate.entries;\n\n\treturn 0;\n}\n\nstatic int tcf_gate_offload_act_setup(struct tc_action *act, void *entry_data,\n\t\t\t\t      u32 *index_inc, bool bind,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tif (bind) {\n\t\tstruct flow_action_entry *entry = entry_data;\n\n\t\tentry->id = FLOW_ACTION_GATE;\n\t\tentry->gate.prio = tcf_gate_prio(act);\n\t\tentry->gate.basetime = tcf_gate_basetime(act);\n\t\tentry->gate.cycletime = tcf_gate_cycletime(act);\n\t\tentry->gate.cycletimeext = tcf_gate_cycletimeext(act);\n\t\tentry->gate.num_entries = tcf_gate_num_entries(act);\n\t\terr = tcf_gate_get_entries(entry, act);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*index_inc = 1;\n\t} else {\n\t\tstruct flow_offload_action *fl_action = entry_data;\n\n\t\tfl_action->id = FLOW_ACTION_GATE;\n\t}\n\n\treturn 0;\n}\n\nstatic struct tc_action_ops act_gate_ops = {\n\t.kind\t\t=\t\"gate\",\n\t.id\t\t=\tTCA_ID_GATE,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_gate_act,\n\t.dump\t\t=\ttcf_gate_dump,\n\t.init\t\t=\ttcf_gate_init,\n\t.cleanup\t=\ttcf_gate_cleanup,\n\t.stats_update\t=\ttcf_gate_stats_update,\n\t.get_fill_size\t=\ttcf_gate_get_fill_size,\n\t.offload_act_setup =\ttcf_gate_offload_act_setup,\n\t.size\t\t=\tsizeof(struct tcf_gate),\n};\n\nstatic __net_init int gate_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_gate_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_gate_ops);\n}\n\nstatic void __net_exit gate_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_gate_ops.net_id);\n}\n\nstatic struct pernet_operations gate_net_ops = {\n\t.init = gate_init_net,\n\t.exit_batch = gate_exit_net,\n\t.id   = &act_gate_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nstatic int __init gate_init_module(void)\n{\n\treturn tcf_register_action(&act_gate_ops, &gate_net_ops);\n}\n\nstatic void __exit gate_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_gate_ops, &gate_net_ops);\n}\n\nmodule_init(gate_init_module);\nmodule_exit(gate_cleanup_module);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}