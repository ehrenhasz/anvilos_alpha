{
  "module_name": "em_text.c",
  "hash_id": "38356ee37ad47290e893dc240b885229ac2b973275c1bf26eb55c90b3bdffcd3",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/em_text.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/textsearch.h>\n#include <linux/tc_ematch/tc_em_text.h>\n#include <net/pkt_cls.h>\n\nstruct text_match {\n\tu16\t\t\tfrom_offset;\n\tu16\t\t\tto_offset;\n\tu8\t\t\tfrom_layer;\n\tu8\t\t\tto_layer;\n\tstruct ts_config\t*config;\n};\n\n#define EM_TEXT_PRIV(m) ((struct text_match *) (m)->data)\n\nstatic int em_text_match(struct sk_buff *skb, struct tcf_ematch *m,\n\t\t\t struct tcf_pkt_info *info)\n{\n\tstruct text_match *tm = EM_TEXT_PRIV(m);\n\tint from, to;\n\n\tfrom = tcf_get_base_ptr(skb, tm->from_layer) - skb->data;\n\tfrom += tm->from_offset;\n\n\tto = tcf_get_base_ptr(skb, tm->to_layer) - skb->data;\n\tto += tm->to_offset;\n\n\treturn skb_find_text(skb, from, to, tm->config) != UINT_MAX;\n}\n\nstatic int em_text_change(struct net *net, void *data, int len,\n\t\t\t  struct tcf_ematch *m)\n{\n\tstruct text_match *tm;\n\tstruct tcf_em_text *conf = data;\n\tstruct ts_config *ts_conf;\n\tint flags = 0;\n\n\tif (len < sizeof(*conf) || len < (sizeof(*conf) + conf->pattern_len))\n\t\treturn -EINVAL;\n\n\tif (conf->from_layer > conf->to_layer)\n\t\treturn -EINVAL;\n\n\tif (conf->from_layer == conf->to_layer &&\n\t    conf->from_offset > conf->to_offset)\n\t\treturn -EINVAL;\n\nretry:\n\tts_conf = textsearch_prepare(conf->algo, (u8 *) conf + sizeof(*conf),\n\t\t\t\t     conf->pattern_len, GFP_KERNEL, flags);\n\n\tif (flags & TS_AUTOLOAD)\n\t\trtnl_lock();\n\n\tif (IS_ERR(ts_conf)) {\n\t\tif (PTR_ERR(ts_conf) == -ENOENT && !(flags & TS_AUTOLOAD)) {\n\t\t\trtnl_unlock();\n\t\t\tflags |= TS_AUTOLOAD;\n\t\t\tgoto retry;\n\t\t} else\n\t\t\treturn PTR_ERR(ts_conf);\n\t} else if (flags & TS_AUTOLOAD) {\n\t\ttextsearch_destroy(ts_conf);\n\t\treturn -EAGAIN;\n\t}\n\n\ttm = kmalloc(sizeof(*tm), GFP_KERNEL);\n\tif (tm == NULL) {\n\t\ttextsearch_destroy(ts_conf);\n\t\treturn -ENOBUFS;\n\t}\n\n\ttm->from_offset = conf->from_offset;\n\ttm->to_offset   = conf->to_offset;\n\ttm->from_layer  = conf->from_layer;\n\ttm->to_layer    = conf->to_layer;\n\ttm->config      = ts_conf;\n\n\tm->datalen = sizeof(*tm);\n\tm->data = (unsigned long) tm;\n\n\treturn 0;\n}\n\nstatic void em_text_destroy(struct tcf_ematch *m)\n{\n\tif (EM_TEXT_PRIV(m) && EM_TEXT_PRIV(m)->config) {\n\t\ttextsearch_destroy(EM_TEXT_PRIV(m)->config);\n\t\tkfree(EM_TEXT_PRIV(m));\n\t}\n}\n\nstatic int em_text_dump(struct sk_buff *skb, struct tcf_ematch *m)\n{\n\tstruct text_match *tm = EM_TEXT_PRIV(m);\n\tstruct tcf_em_text conf;\n\n\tstrncpy(conf.algo, tm->config->ops->name, sizeof(conf.algo) - 1);\n\tconf.from_offset = tm->from_offset;\n\tconf.to_offset = tm->to_offset;\n\tconf.from_layer = tm->from_layer;\n\tconf.to_layer = tm->to_layer;\n\tconf.pattern_len = textsearch_get_pattern_len(tm->config);\n\tconf.pad = 0;\n\n\tif (nla_put_nohdr(skb, sizeof(conf), &conf) < 0)\n\t\tgoto nla_put_failure;\n\tif (nla_append(skb, conf.pattern_len,\n\t\t       textsearch_get_pattern(tm->config)) < 0)\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic struct tcf_ematch_ops em_text_ops = {\n\t.kind\t  = TCF_EM_TEXT,\n\t.change\t  = em_text_change,\n\t.match\t  = em_text_match,\n\t.destroy  = em_text_destroy,\n\t.dump\t  = em_text_dump,\n\t.owner\t  = THIS_MODULE,\n\t.link\t  = LIST_HEAD_INIT(em_text_ops.link)\n};\n\nstatic int __init init_em_text(void)\n{\n\treturn tcf_em_register(&em_text_ops);\n}\n\nstatic void __exit exit_em_text(void)\n{\n\ttcf_em_unregister(&em_text_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(init_em_text);\nmodule_exit(exit_em_text);\n\nMODULE_ALIAS_TCF_EMATCH(TCF_EM_TEXT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}