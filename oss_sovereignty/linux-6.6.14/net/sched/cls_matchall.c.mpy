{
  "module_name": "cls_matchall.c",
  "hash_id": "5a4e2cf3f1bc1e5f0f463c204459ab0d2e10afff5f957eeca7dec73ed7a07672",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/cls_matchall.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/percpu.h>\n\n#include <net/sch_generic.h>\n#include <net/pkt_cls.h>\n#include <net/tc_wrapper.h>\n\nstruct cls_mall_head {\n\tstruct tcf_exts exts;\n\tstruct tcf_result res;\n\tu32 handle;\n\tu32 flags;\n\tunsigned int in_hw_count;\n\tstruct tc_matchall_pcnt __percpu *pf;\n\tstruct rcu_work rwork;\n\tbool deleting;\n};\n\nTC_INDIRECT_SCOPE int mall_classify(struct sk_buff *skb,\n\t\t\t\t    const struct tcf_proto *tp,\n\t\t\t\t    struct tcf_result *res)\n{\n\tstruct cls_mall_head *head = rcu_dereference_bh(tp->root);\n\n\tif (unlikely(!head))\n\t\treturn -1;\n\n\tif (tc_skip_sw(head->flags))\n\t\treturn -1;\n\n\t*res = head->res;\n\t__this_cpu_inc(head->pf->rhit);\n\treturn tcf_exts_exec(skb, &head->exts, res);\n}\n\nstatic int mall_init(struct tcf_proto *tp)\n{\n\treturn 0;\n}\n\nstatic void __mall_destroy(struct cls_mall_head *head)\n{\n\ttcf_exts_destroy(&head->exts);\n\ttcf_exts_put_net(&head->exts);\n\tfree_percpu(head->pf);\n\tkfree(head);\n}\n\nstatic void mall_destroy_work(struct work_struct *work)\n{\n\tstruct cls_mall_head *head = container_of(to_rcu_work(work),\n\t\t\t\t\t\t  struct cls_mall_head,\n\t\t\t\t\t\t  rwork);\n\trtnl_lock();\n\t__mall_destroy(head);\n\trtnl_unlock();\n}\n\nstatic void mall_destroy_hw_filter(struct tcf_proto *tp,\n\t\t\t\t   struct cls_mall_head *head,\n\t\t\t\t   unsigned long cookie,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct tc_cls_matchall_offload cls_mall = {};\n\tstruct tcf_block *block = tp->chain->block;\n\n\ttc_cls_common_offload_init(&cls_mall.common, tp, head->flags, extack);\n\tcls_mall.command = TC_CLSMATCHALL_DESTROY;\n\tcls_mall.cookie = cookie;\n\n\ttc_setup_cb_destroy(block, tp, TC_SETUP_CLSMATCHALL, &cls_mall, false,\n\t\t\t    &head->flags, &head->in_hw_count, true);\n}\n\nstatic int mall_replace_hw_filter(struct tcf_proto *tp,\n\t\t\t\t  struct cls_mall_head *head,\n\t\t\t\t  unsigned long cookie,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct tc_cls_matchall_offload cls_mall = {};\n\tstruct tcf_block *block = tp->chain->block;\n\tbool skip_sw = tc_skip_sw(head->flags);\n\tint err;\n\n\tcls_mall.rule =\tflow_rule_alloc(tcf_exts_num_actions(&head->exts));\n\tif (!cls_mall.rule)\n\t\treturn -ENOMEM;\n\n\ttc_cls_common_offload_init(&cls_mall.common, tp, head->flags, extack);\n\tcls_mall.command = TC_CLSMATCHALL_REPLACE;\n\tcls_mall.cookie = cookie;\n\n\terr = tc_setup_offload_action(&cls_mall.rule->action, &head->exts,\n\t\t\t\t      cls_mall.common.extack);\n\tif (err) {\n\t\tkfree(cls_mall.rule);\n\t\tmall_destroy_hw_filter(tp, head, cookie, NULL);\n\n\t\treturn skip_sw ? err : 0;\n\t}\n\n\terr = tc_setup_cb_add(block, tp, TC_SETUP_CLSMATCHALL, &cls_mall,\n\t\t\t      skip_sw, &head->flags, &head->in_hw_count, true);\n\ttc_cleanup_offload_action(&cls_mall.rule->action);\n\tkfree(cls_mall.rule);\n\n\tif (err) {\n\t\tmall_destroy_hw_filter(tp, head, cookie, NULL);\n\t\treturn err;\n\t}\n\n\tif (skip_sw && !(head->flags & TCA_CLS_FLAGS_IN_HW))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void mall_destroy(struct tcf_proto *tp, bool rtnl_held,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct cls_mall_head *head = rtnl_dereference(tp->root);\n\n\tif (!head)\n\t\treturn;\n\n\ttcf_unbind_filter(tp, &head->res);\n\n\tif (!tc_skip_hw(head->flags))\n\t\tmall_destroy_hw_filter(tp, head, (unsigned long) head, extack);\n\n\tif (tcf_exts_get_net(&head->exts))\n\t\ttcf_queue_work(&head->rwork, mall_destroy_work);\n\telse\n\t\t__mall_destroy(head);\n}\n\nstatic void *mall_get(struct tcf_proto *tp, u32 handle)\n{\n\tstruct cls_mall_head *head = rtnl_dereference(tp->root);\n\n\tif (head && head->handle == handle)\n\t\treturn head;\n\n\treturn NULL;\n}\n\nstatic const struct nla_policy mall_policy[TCA_MATCHALL_MAX + 1] = {\n\t[TCA_MATCHALL_UNSPEC]\t\t= { .type = NLA_UNSPEC },\n\t[TCA_MATCHALL_CLASSID]\t\t= { .type = NLA_U32 },\n\t[TCA_MATCHALL_FLAGS]\t\t= { .type = NLA_U32 },\n};\n\nstatic int mall_change(struct net *net, struct sk_buff *in_skb,\n\t\t       struct tcf_proto *tp, unsigned long base,\n\t\t       u32 handle, struct nlattr **tca,\n\t\t       void **arg, u32 flags,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct cls_mall_head *head = rtnl_dereference(tp->root);\n\tstruct nlattr *tb[TCA_MATCHALL_MAX + 1];\n\tbool bound_to_filter = false;\n\tstruct cls_mall_head *new;\n\tu32 userflags = 0;\n\tint err;\n\n\tif (!tca[TCA_OPTIONS])\n\t\treturn -EINVAL;\n\n\tif (head)\n\t\treturn -EEXIST;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_MATCHALL_MAX,\n\t\t\t\t\t  tca[TCA_OPTIONS], mall_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_MATCHALL_FLAGS]) {\n\t\tuserflags = nla_get_u32(tb[TCA_MATCHALL_FLAGS]);\n\t\tif (!tc_flags_valid(userflags))\n\t\t\treturn -EINVAL;\n\t}\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOBUFS;\n\n\terr = tcf_exts_init(&new->exts, net, TCA_MATCHALL_ACT, 0);\n\tif (err)\n\t\tgoto err_exts_init;\n\n\tif (!handle)\n\t\thandle = 1;\n\tnew->handle = handle;\n\tnew->flags = userflags;\n\tnew->pf = alloc_percpu(struct tc_matchall_pcnt);\n\tif (!new->pf) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_percpu;\n\t}\n\n\terr = tcf_exts_validate_ex(net, tp, tb, tca[TCA_RATE],\n\t\t\t\t   &new->exts, flags, new->flags, extack);\n\tif (err < 0)\n\t\tgoto err_set_parms;\n\n\tif (tb[TCA_MATCHALL_CLASSID]) {\n\t\tnew->res.classid = nla_get_u32(tb[TCA_MATCHALL_CLASSID]);\n\t\ttcf_bind_filter(tp, &new->res, base);\n\t\tbound_to_filter = true;\n\t}\n\n\tif (!tc_skip_hw(new->flags)) {\n\t\terr = mall_replace_hw_filter(tp, new, (unsigned long)new,\n\t\t\t\t\t     extack);\n\t\tif (err)\n\t\t\tgoto err_replace_hw_filter;\n\t}\n\n\tif (!tc_in_hw(new->flags))\n\t\tnew->flags |= TCA_CLS_FLAGS_NOT_IN_HW;\n\n\t*arg = head;\n\trcu_assign_pointer(tp->root, new);\n\treturn 0;\n\nerr_replace_hw_filter:\n\tif (bound_to_filter)\n\t\ttcf_unbind_filter(tp, &new->res);\nerr_set_parms:\n\tfree_percpu(new->pf);\nerr_alloc_percpu:\n\ttcf_exts_destroy(&new->exts);\nerr_exts_init:\n\tkfree(new);\n\treturn err;\n}\n\nstatic int mall_delete(struct tcf_proto *tp, void *arg, bool *last,\n\t\t       bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct cls_mall_head *head = rtnl_dereference(tp->root);\n\n\thead->deleting = true;\n\t*last = true;\n\treturn 0;\n}\n\nstatic void mall_walk(struct tcf_proto *tp, struct tcf_walker *arg,\n\t\t      bool rtnl_held)\n{\n\tstruct cls_mall_head *head = rtnl_dereference(tp->root);\n\n\tif (arg->count < arg->skip)\n\t\tgoto skip;\n\n\tif (!head || head->deleting)\n\t\treturn;\n\tif (arg->fn(tp, head, arg) < 0)\n\t\targ->stop = 1;\nskip:\n\targ->count++;\n}\n\nstatic int mall_reoffload(struct tcf_proto *tp, bool add, flow_setup_cb_t *cb,\n\t\t\t  void *cb_priv, struct netlink_ext_ack *extack)\n{\n\tstruct cls_mall_head *head = rtnl_dereference(tp->root);\n\tstruct tc_cls_matchall_offload cls_mall = {};\n\tstruct tcf_block *block = tp->chain->block;\n\tint err;\n\n\tif (tc_skip_hw(head->flags))\n\t\treturn 0;\n\n\tcls_mall.rule =\tflow_rule_alloc(tcf_exts_num_actions(&head->exts));\n\tif (!cls_mall.rule)\n\t\treturn -ENOMEM;\n\n\ttc_cls_common_offload_init(&cls_mall.common, tp, head->flags, extack);\n\tcls_mall.command = add ?\n\t\tTC_CLSMATCHALL_REPLACE : TC_CLSMATCHALL_DESTROY;\n\tcls_mall.cookie = (unsigned long)head;\n\n\terr = tc_setup_offload_action(&cls_mall.rule->action, &head->exts,\n\t\t\t\t      cls_mall.common.extack);\n\tif (err) {\n\t\tkfree(cls_mall.rule);\n\n\t\treturn add && tc_skip_sw(head->flags) ? err : 0;\n\t}\n\n\terr = tc_setup_cb_reoffload(block, tp, add, cb, TC_SETUP_CLSMATCHALL,\n\t\t\t\t    &cls_mall, cb_priv, &head->flags,\n\t\t\t\t    &head->in_hw_count);\n\ttc_cleanup_offload_action(&cls_mall.rule->action);\n\tkfree(cls_mall.rule);\n\n\treturn err;\n}\n\nstatic void mall_stats_hw_filter(struct tcf_proto *tp,\n\t\t\t\t struct cls_mall_head *head,\n\t\t\t\t unsigned long cookie)\n{\n\tstruct tc_cls_matchall_offload cls_mall = {};\n\tstruct tcf_block *block = tp->chain->block;\n\n\ttc_cls_common_offload_init(&cls_mall.common, tp, head->flags, NULL);\n\tcls_mall.command = TC_CLSMATCHALL_STATS;\n\tcls_mall.cookie = cookie;\n\n\ttc_setup_cb_call(block, TC_SETUP_CLSMATCHALL, &cls_mall, false, true);\n\n\ttcf_exts_hw_stats_update(&head->exts, &cls_mall.stats, cls_mall.use_act_stats);\n}\n\nstatic int mall_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t     struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)\n{\n\tstruct tc_matchall_pcnt gpf = {};\n\tstruct cls_mall_head *head = fh;\n\tstruct nlattr *nest;\n\tint cpu;\n\n\tif (!head)\n\t\treturn skb->len;\n\n\tif (!tc_skip_hw(head->flags))\n\t\tmall_stats_hw_filter(tp, head, (unsigned long)head);\n\n\tt->tcm_handle = head->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tif (head->res.classid &&\n\t    nla_put_u32(skb, TCA_MATCHALL_CLASSID, head->res.classid))\n\t\tgoto nla_put_failure;\n\n\tif (head->flags && nla_put_u32(skb, TCA_MATCHALL_FLAGS, head->flags))\n\t\tgoto nla_put_failure;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct tc_matchall_pcnt *pf = per_cpu_ptr(head->pf, cpu);\n\n\t\tgpf.rhit += pf->rhit;\n\t}\n\n\tif (nla_put_64bit(skb, TCA_MATCHALL_PCNT,\n\t\t\t  sizeof(struct tc_matchall_pcnt),\n\t\t\t  &gpf, TCA_MATCHALL_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (tcf_exts_dump(skb, &head->exts))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tif (tcf_exts_dump_stats(skb, &head->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic void mall_bind_class(void *fh, u32 classid, unsigned long cl, void *q,\n\t\t\t    unsigned long base)\n{\n\tstruct cls_mall_head *head = fh;\n\n\ttc_cls_bind_class(classid, cl, q, &head->res, base);\n}\n\nstatic struct tcf_proto_ops cls_mall_ops __read_mostly = {\n\t.kind\t\t= \"matchall\",\n\t.classify\t= mall_classify,\n\t.init\t\t= mall_init,\n\t.destroy\t= mall_destroy,\n\t.get\t\t= mall_get,\n\t.change\t\t= mall_change,\n\t.delete\t\t= mall_delete,\n\t.walk\t\t= mall_walk,\n\t.reoffload\t= mall_reoffload,\n\t.dump\t\t= mall_dump,\n\t.bind_class\t= mall_bind_class,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init cls_mall_init(void)\n{\n\treturn register_tcf_proto_ops(&cls_mall_ops);\n}\n\nstatic void __exit cls_mall_exit(void)\n{\n\tunregister_tcf_proto_ops(&cls_mall_ops);\n}\n\nmodule_init(cls_mall_init);\nmodule_exit(cls_mall_exit);\n\nMODULE_AUTHOR(\"Jiri Pirko <jiri@mellanox.com>\");\nMODULE_DESCRIPTION(\"Match-all classifier\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}