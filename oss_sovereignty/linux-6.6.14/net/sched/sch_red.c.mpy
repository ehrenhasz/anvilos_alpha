{
  "module_name": "sch_red.c",
  "hash_id": "d1bfdc05ab0cbf673c7ddec91f353bd383c43c720f285092ddc93221d95c1276",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_red.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <net/inet_ecn.h>\n#include <net/red.h>\n\n\n \n\nstruct red_sched_data {\n\tu32\t\t\tlimit;\t\t \n\n\tunsigned char\t\tflags;\n\t \n\tunsigned char\t\tuserbits;\n\n\tstruct timer_list\tadapt_timer;\n\tstruct Qdisc\t\t*sch;\n\tstruct red_parms\tparms;\n\tstruct red_vars\t\tvars;\n\tstruct red_stats\tstats;\n\tstruct Qdisc\t\t*qdisc;\n\tstruct tcf_qevent\tqe_early_drop;\n\tstruct tcf_qevent\tqe_mark;\n};\n\n#define TC_RED_SUPPORTED_FLAGS (TC_RED_HISTORIC_FLAGS | TC_RED_NODROP)\n\nstatic inline int red_use_ecn(struct red_sched_data *q)\n{\n\treturn q->flags & TC_RED_ECN;\n}\n\nstatic inline int red_use_harddrop(struct red_sched_data *q)\n{\n\treturn q->flags & TC_RED_HARDDROP;\n}\n\nstatic int red_use_nodrop(struct red_sched_data *q)\n{\n\treturn q->flags & TC_RED_NODROP;\n}\n\nstatic int red_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\tunsigned int len;\n\tint ret;\n\n\tq->vars.qavg = red_calc_qavg(&q->parms,\n\t\t\t\t     &q->vars,\n\t\t\t\t     child->qstats.backlog);\n\n\tif (red_is_idling(&q->vars))\n\t\tred_end_of_idle_period(&q->vars);\n\n\tswitch (red_action(&q->parms, &q->vars, q->vars.qavg)) {\n\tcase RED_DONT_MARK:\n\t\tbreak;\n\n\tcase RED_PROB_MARK:\n\t\tqdisc_qstats_overlimit(sch);\n\t\tif (!red_use_ecn(q)) {\n\t\t\tq->stats.prob_drop++;\n\t\t\tgoto congestion_drop;\n\t\t}\n\n\t\tif (INET_ECN_set_ce(skb)) {\n\t\t\tq->stats.prob_mark++;\n\t\t\tskb = tcf_qevent_handle(&q->qe_mark, sch, skb, to_free, &ret);\n\t\t\tif (!skb)\n\t\t\t\treturn NET_XMIT_CN | ret;\n\t\t} else if (!red_use_nodrop(q)) {\n\t\t\tq->stats.prob_drop++;\n\t\t\tgoto congestion_drop;\n\t\t}\n\n\t\t \n\t\tbreak;\n\n\tcase RED_HARD_MARK:\n\t\tqdisc_qstats_overlimit(sch);\n\t\tif (red_use_harddrop(q) || !red_use_ecn(q)) {\n\t\t\tq->stats.forced_drop++;\n\t\t\tgoto congestion_drop;\n\t\t}\n\n\t\tif (INET_ECN_set_ce(skb)) {\n\t\t\tq->stats.forced_mark++;\n\t\t\tskb = tcf_qevent_handle(&q->qe_mark, sch, skb, to_free, &ret);\n\t\t\tif (!skb)\n\t\t\t\treturn NET_XMIT_CN | ret;\n\t\t} else if (!red_use_nodrop(q)) {\n\t\t\tq->stats.forced_drop++;\n\t\t\tgoto congestion_drop;\n\t\t}\n\n\t\t \n\t\tbreak;\n\t}\n\n\tlen = qdisc_pkt_len(skb);\n\tret = qdisc_enqueue(skb, child, to_free);\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tsch->qstats.backlog += len;\n\t\tsch->q.qlen++;\n\t} else if (net_xmit_drop_count(ret)) {\n\t\tq->stats.pdrop++;\n\t\tqdisc_qstats_drop(sch);\n\t}\n\treturn ret;\n\ncongestion_drop:\n\tskb = tcf_qevent_handle(&q->qe_early_drop, sch, skb, to_free, &ret);\n\tif (!skb)\n\t\treturn NET_XMIT_CN | ret;\n\n\tqdisc_drop(skb, sch, to_free);\n\treturn NET_XMIT_CN;\n}\n\nstatic struct sk_buff *red_dequeue(struct Qdisc *sch)\n{\n\tstruct sk_buff *skb;\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\n\tskb = child->dequeue(child);\n\tif (skb) {\n\t\tqdisc_bstats_update(sch, skb);\n\t\tqdisc_qstats_backlog_dec(sch, skb);\n\t\tsch->q.qlen--;\n\t} else {\n\t\tif (!red_is_idling(&q->vars))\n\t\t\tred_start_of_idle_period(&q->vars);\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *red_peek(struct Qdisc *sch)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\n\treturn child->ops->peek(child);\n}\n\nstatic void red_reset(struct Qdisc *sch)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\n\tqdisc_reset(q->qdisc);\n\tred_restart(&q->vars);\n}\n\nstatic int red_offload(struct Qdisc *sch, bool enable)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct tc_red_qopt_offload opt = {\n\t\t.handle = sch->handle,\n\t\t.parent = sch->parent,\n\t};\n\n\tif (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (enable) {\n\t\topt.command = TC_RED_REPLACE;\n\t\topt.set.min = q->parms.qth_min >> q->parms.Wlog;\n\t\topt.set.max = q->parms.qth_max >> q->parms.Wlog;\n\t\topt.set.probability = q->parms.max_P;\n\t\topt.set.limit = q->limit;\n\t\topt.set.is_ecn = red_use_ecn(q);\n\t\topt.set.is_harddrop = red_use_harddrop(q);\n\t\topt.set.is_nodrop = red_use_nodrop(q);\n\t\topt.set.qstats = &sch->qstats;\n\t} else {\n\t\topt.command = TC_RED_DESTROY;\n\t}\n\n\treturn dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_RED, &opt);\n}\n\nstatic void red_destroy(struct Qdisc *sch)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\n\ttcf_qevent_destroy(&q->qe_mark, sch);\n\ttcf_qevent_destroy(&q->qe_early_drop, sch);\n\tdel_timer_sync(&q->adapt_timer);\n\tred_offload(sch, false);\n\tqdisc_put(q->qdisc);\n}\n\nstatic const struct nla_policy red_policy[TCA_RED_MAX + 1] = {\n\t[TCA_RED_UNSPEC] = { .strict_start_type = TCA_RED_FLAGS },\n\t[TCA_RED_PARMS]\t= { .len = sizeof(struct tc_red_qopt) },\n\t[TCA_RED_STAB]\t= { .len = RED_STAB_SIZE },\n\t[TCA_RED_MAX_P] = { .type = NLA_U32 },\n\t[TCA_RED_FLAGS] = NLA_POLICY_BITFIELD32(TC_RED_SUPPORTED_FLAGS),\n\t[TCA_RED_EARLY_DROP_BLOCK] = { .type = NLA_U32 },\n\t[TCA_RED_MARK_BLOCK] = { .type = NLA_U32 },\n};\n\nstatic int __red_change(struct Qdisc *sch, struct nlattr **tb,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct Qdisc *old_child = NULL, *child = NULL;\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\tstruct nla_bitfield32 flags_bf;\n\tstruct tc_red_qopt *ctl;\n\tunsigned char userbits;\n\tunsigned char flags;\n\tint err;\n\tu32 max_P;\n\tu8 *stab;\n\n\tif (tb[TCA_RED_PARMS] == NULL ||\n\t    tb[TCA_RED_STAB] == NULL)\n\t\treturn -EINVAL;\n\n\tmax_P = tb[TCA_RED_MAX_P] ? nla_get_u32(tb[TCA_RED_MAX_P]) : 0;\n\n\tctl = nla_data(tb[TCA_RED_PARMS]);\n\tstab = nla_data(tb[TCA_RED_STAB]);\n\tif (!red_check_params(ctl->qth_min, ctl->qth_max, ctl->Wlog,\n\t\t\t      ctl->Scell_log, stab))\n\t\treturn -EINVAL;\n\n\terr = red_get_flags(ctl->flags, TC_RED_HISTORIC_FLAGS,\n\t\t\t    tb[TCA_RED_FLAGS], TC_RED_SUPPORTED_FLAGS,\n\t\t\t    &flags_bf, &userbits, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (ctl->limit > 0) {\n\t\tchild = fifo_create_dflt(sch, &bfifo_qdisc_ops, ctl->limit,\n\t\t\t\t\t extack);\n\t\tif (IS_ERR(child))\n\t\t\treturn PTR_ERR(child);\n\n\t\t \n\t\tqdisc_hash_add(child, true);\n\t}\n\n\tsch_tree_lock(sch);\n\n\tflags = (q->flags & ~flags_bf.selector) | flags_bf.value;\n\terr = red_validate_flags(flags, extack);\n\tif (err)\n\t\tgoto unlock_out;\n\n\tq->flags = flags;\n\tq->userbits = userbits;\n\tq->limit = ctl->limit;\n\tif (child) {\n\t\tqdisc_tree_flush_backlog(q->qdisc);\n\t\told_child = q->qdisc;\n\t\tq->qdisc = child;\n\t}\n\n\tred_set_parms(&q->parms,\n\t\t      ctl->qth_min, ctl->qth_max, ctl->Wlog,\n\t\t      ctl->Plog, ctl->Scell_log,\n\t\t      stab,\n\t\t      max_P);\n\tred_set_vars(&q->vars);\n\n\tdel_timer(&q->adapt_timer);\n\tif (ctl->flags & TC_RED_ADAPTATIVE)\n\t\tmod_timer(&q->adapt_timer, jiffies + HZ/2);\n\n\tif (!q->qdisc->q.qlen)\n\t\tred_start_of_idle_period(&q->vars);\n\n\tsch_tree_unlock(sch);\n\n\tred_offload(sch, true);\n\n\tif (old_child)\n\t\tqdisc_put(old_child);\n\treturn 0;\n\nunlock_out:\n\tsch_tree_unlock(sch);\n\tif (child)\n\t\tqdisc_put(child);\n\treturn err;\n}\n\nstatic inline void red_adaptative_timer(struct timer_list *t)\n{\n\tstruct red_sched_data *q = from_timer(q, t, adapt_timer);\n\tstruct Qdisc *sch = q->sch;\n\tspinlock_t *root_lock;\n\n\trcu_read_lock();\n\troot_lock = qdisc_lock(qdisc_root_sleeping(sch));\n\tspin_lock(root_lock);\n\tred_adaptative_algo(&q->parms, &q->vars);\n\tmod_timer(&q->adapt_timer, jiffies + HZ/2);\n\tspin_unlock(root_lock);\n\trcu_read_unlock();\n}\n\nstatic int red_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\tstruct nlattr *tb[TCA_RED_MAX + 1];\n\tint err;\n\n\tq->qdisc = &noop_qdisc;\n\tq->sch = sch;\n\ttimer_setup(&q->adapt_timer, red_adaptative_timer, 0);\n\n\tif (!opt)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_RED_MAX, opt, red_policy,\n\t\t\t\t\t  extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = __red_change(sch, tb, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = tcf_qevent_init(&q->qe_early_drop, sch,\n\t\t\t      FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP,\n\t\t\t      tb[TCA_RED_EARLY_DROP_BLOCK], extack);\n\tif (err)\n\t\treturn err;\n\n\treturn tcf_qevent_init(&q->qe_mark, sch,\n\t\t\t       FLOW_BLOCK_BINDER_TYPE_RED_MARK,\n\t\t\t       tb[TCA_RED_MARK_BLOCK], extack);\n}\n\nstatic int red_change(struct Qdisc *sch, struct nlattr *opt,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\tstruct nlattr *tb[TCA_RED_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_RED_MAX, opt, red_policy,\n\t\t\t\t\t  extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tcf_qevent_validate_change(&q->qe_early_drop,\n\t\t\t\t\t tb[TCA_RED_EARLY_DROP_BLOCK], extack);\n\tif (err)\n\t\treturn err;\n\n\terr = tcf_qevent_validate_change(&q->qe_mark,\n\t\t\t\t\t tb[TCA_RED_MARK_BLOCK], extack);\n\tif (err)\n\t\treturn err;\n\n\treturn __red_change(sch, tb, extack);\n}\n\nstatic int red_dump_offload_stats(struct Qdisc *sch)\n{\n\tstruct tc_red_qopt_offload hw_stats = {\n\t\t.command = TC_RED_STATS,\n\t\t.handle = sch->handle,\n\t\t.parent = sch->parent,\n\t\t{\n\t\t\t.stats.bstats = &sch->bstats,\n\t\t\t.stats.qstats = &sch->qstats,\n\t\t},\n\t};\n\n\treturn qdisc_offload_dump_helper(sch, TC_SETUP_QDISC_RED, &hw_stats);\n}\n\nstatic int red_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\tstruct nlattr *opts = NULL;\n\tstruct tc_red_qopt opt = {\n\t\t.limit\t\t= q->limit,\n\t\t.flags\t\t= (q->flags & TC_RED_HISTORIC_FLAGS) |\n\t\t\t\t  q->userbits,\n\t\t.qth_min\t= q->parms.qth_min >> q->parms.Wlog,\n\t\t.qth_max\t= q->parms.qth_max >> q->parms.Wlog,\n\t\t.Wlog\t\t= q->parms.Wlog,\n\t\t.Plog\t\t= q->parms.Plog,\n\t\t.Scell_log\t= q->parms.Scell_log,\n\t};\n\tint err;\n\n\terr = red_dump_offload_stats(sch);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\topts = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (opts == NULL)\n\t\tgoto nla_put_failure;\n\tif (nla_put(skb, TCA_RED_PARMS, sizeof(opt), &opt) ||\n\t    nla_put_u32(skb, TCA_RED_MAX_P, q->parms.max_P) ||\n\t    nla_put_bitfield32(skb, TCA_RED_FLAGS,\n\t\t\t       q->flags, TC_RED_SUPPORTED_FLAGS) ||\n\t    tcf_qevent_dump(skb, TCA_RED_MARK_BLOCK, &q->qe_mark) ||\n\t    tcf_qevent_dump(skb, TCA_RED_EARLY_DROP_BLOCK, &q->qe_early_drop))\n\t\tgoto nla_put_failure;\n\treturn nla_nest_end(skb, opts);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, opts);\n\treturn -EMSGSIZE;\n}\n\nstatic int red_dump_stats(struct Qdisc *sch, struct gnet_dump *d)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct tc_red_xstats st = {0};\n\n\tif (sch->flags & TCQ_F_OFFLOADED) {\n\t\tstruct tc_red_qopt_offload hw_stats_request = {\n\t\t\t.command = TC_RED_XSTATS,\n\t\t\t.handle = sch->handle,\n\t\t\t.parent = sch->parent,\n\t\t\t{\n\t\t\t\t.xstats = &q->stats,\n\t\t\t},\n\t\t};\n\t\tdev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_RED,\n\t\t\t\t\t      &hw_stats_request);\n\t}\n\tst.early = q->stats.prob_drop + q->stats.forced_drop;\n\tst.pdrop = q->stats.pdrop;\n\tst.marked = q->stats.prob_mark + q->stats.forced_mark;\n\n\treturn gnet_stats_copy_app(d, &st, sizeof(st));\n}\n\nstatic int red_dump_class(struct Qdisc *sch, unsigned long cl,\n\t\t\t  struct sk_buff *skb, struct tcmsg *tcm)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\n\ttcm->tcm_handle |= TC_H_MIN(1);\n\ttcm->tcm_info = q->qdisc->handle;\n\treturn 0;\n}\n\nstatic void red_graft_offload(struct Qdisc *sch,\n\t\t\t      struct Qdisc *new, struct Qdisc *old,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct tc_red_qopt_offload graft_offload = {\n\t\t.handle\t\t= sch->handle,\n\t\t.parent\t\t= sch->parent,\n\t\t.child_handle\t= new->handle,\n\t\t.command\t= TC_RED_GRAFT,\n\t};\n\n\tqdisc_offload_graft_helper(qdisc_dev(sch), sch, new, old,\n\t\t\t\t   TC_SETUP_QDISC_RED, &graft_offload, extack);\n}\n\nstatic int red_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,\n\t\t     struct Qdisc **old, struct netlink_ext_ack *extack)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\n\tif (new == NULL)\n\t\tnew = &noop_qdisc;\n\n\t*old = qdisc_replace(sch, new, &q->qdisc);\n\n\tred_graft_offload(sch, new, *old, extack);\n\treturn 0;\n}\n\nstatic struct Qdisc *red_leaf(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct red_sched_data *q = qdisc_priv(sch);\n\treturn q->qdisc;\n}\n\nstatic unsigned long red_find(struct Qdisc *sch, u32 classid)\n{\n\treturn 1;\n}\n\nstatic void red_walk(struct Qdisc *sch, struct qdisc_walker *walker)\n{\n\tif (!walker->stop) {\n\t\ttc_qdisc_stats_dump(sch, 1, walker);\n\t}\n}\n\nstatic const struct Qdisc_class_ops red_class_ops = {\n\t.graft\t\t=\tred_graft,\n\t.leaf\t\t=\tred_leaf,\n\t.find\t\t=\tred_find,\n\t.walk\t\t=\tred_walk,\n\t.dump\t\t=\tred_dump_class,\n};\n\nstatic struct Qdisc_ops red_qdisc_ops __read_mostly = {\n\t.id\t\t=\t\"red\",\n\t.priv_size\t=\tsizeof(struct red_sched_data),\n\t.cl_ops\t\t=\t&red_class_ops,\n\t.enqueue\t=\tred_enqueue,\n\t.dequeue\t=\tred_dequeue,\n\t.peek\t\t=\tred_peek,\n\t.init\t\t=\tred_init,\n\t.reset\t\t=\tred_reset,\n\t.destroy\t=\tred_destroy,\n\t.change\t\t=\tred_change,\n\t.dump\t\t=\tred_dump,\n\t.dump_stats\t=\tred_dump_stats,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init red_module_init(void)\n{\n\treturn register_qdisc(&red_qdisc_ops);\n}\n\nstatic void __exit red_module_exit(void)\n{\n\tunregister_qdisc(&red_qdisc_ops);\n}\n\nmodule_init(red_module_init)\nmodule_exit(red_module_exit)\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}