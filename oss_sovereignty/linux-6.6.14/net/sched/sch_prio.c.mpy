{
  "module_name": "sch_prio.c",
  "hash_id": "6c242ccbf9822829b57aa170547adcca53c8ccd4e4b9380d91471d898c799ae1",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_prio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n\nstruct prio_sched_data {\n\tint bands;\n\tstruct tcf_proto __rcu *filter_list;\n\tstruct tcf_block *block;\n\tu8  prio2band[TC_PRIO_MAX+1];\n\tstruct Qdisc *queues[TCQ_PRIO_BANDS];\n};\n\n\nstatic struct Qdisc *\nprio_classify(struct sk_buff *skb, struct Qdisc *sch, int *qerr)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tu32 band = skb->priority;\n\tstruct tcf_result res;\n\tstruct tcf_proto *fl;\n\tint err;\n\n\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\tif (TC_H_MAJ(skb->priority) != sch->handle) {\n\t\tfl = rcu_dereference_bh(q->filter_list);\n\t\terr = tcf_classify(skb, NULL, fl, &res, false);\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (err) {\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\tfallthrough;\n\t\tcase TC_ACT_SHOT:\n\t\t\treturn NULL;\n\t\t}\n#endif\n\t\tif (!fl || err < 0) {\n\t\t\tif (TC_H_MAJ(band))\n\t\t\t\tband = 0;\n\t\t\treturn q->queues[q->prio2band[band & TC_PRIO_MAX]];\n\t\t}\n\t\tband = res.classid;\n\t}\n\tband = TC_H_MIN(band) - 1;\n\tif (band >= q->bands)\n\t\treturn q->queues[q->prio2band[0]];\n\n\treturn q->queues[band];\n}\n\nstatic int\nprio_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)\n{\n\tunsigned int len = qdisc_pkt_len(skb);\n\tstruct Qdisc *qdisc;\n\tint ret;\n\n\tqdisc = prio_classify(skb, sch, &ret);\n#ifdef CONFIG_NET_CLS_ACT\n\tif (qdisc == NULL) {\n\n\t\tif (ret & __NET_XMIT_BYPASS)\n\t\t\tqdisc_qstats_drop(sch);\n\t\t__qdisc_drop(skb, to_free);\n\t\treturn ret;\n\t}\n#endif\n\n\tret = qdisc_enqueue(skb, qdisc, to_free);\n\tif (ret == NET_XMIT_SUCCESS) {\n\t\tsch->qstats.backlog += len;\n\t\tsch->q.qlen++;\n\t\treturn NET_XMIT_SUCCESS;\n\t}\n\tif (net_xmit_drop_count(ret))\n\t\tqdisc_qstats_drop(sch);\n\treturn ret;\n}\n\nstatic struct sk_buff *prio_peek(struct Qdisc *sch)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tint prio;\n\n\tfor (prio = 0; prio < q->bands; prio++) {\n\t\tstruct Qdisc *qdisc = q->queues[prio];\n\t\tstruct sk_buff *skb = qdisc->ops->peek(qdisc);\n\t\tif (skb)\n\t\t\treturn skb;\n\t}\n\treturn NULL;\n}\n\nstatic struct sk_buff *prio_dequeue(struct Qdisc *sch)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tint prio;\n\n\tfor (prio = 0; prio < q->bands; prio++) {\n\t\tstruct Qdisc *qdisc = q->queues[prio];\n\t\tstruct sk_buff *skb = qdisc_dequeue_peeked(qdisc);\n\t\tif (skb) {\n\t\t\tqdisc_bstats_update(sch, skb);\n\t\t\tqdisc_qstats_backlog_dec(sch, skb);\n\t\t\tsch->q.qlen--;\n\t\t\treturn skb;\n\t\t}\n\t}\n\treturn NULL;\n\n}\n\nstatic void\nprio_reset(struct Qdisc *sch)\n{\n\tint prio;\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\n\tfor (prio = 0; prio < q->bands; prio++)\n\t\tqdisc_reset(q->queues[prio]);\n}\n\nstatic int prio_offload(struct Qdisc *sch, struct tc_prio_qopt *qopt)\n{\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct tc_prio_qopt_offload opt = {\n\t\t.handle = sch->handle,\n\t\t.parent = sch->parent,\n\t};\n\n\tif (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (qopt) {\n\t\topt.command = TC_PRIO_REPLACE;\n\t\topt.replace_params.bands = qopt->bands;\n\t\tmemcpy(&opt.replace_params.priomap, qopt->priomap,\n\t\t       TC_PRIO_MAX + 1);\n\t\topt.replace_params.qstats = &sch->qstats;\n\t} else {\n\t\topt.command = TC_PRIO_DESTROY;\n\t}\n\n\treturn dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_PRIO, &opt);\n}\n\nstatic void\nprio_destroy(struct Qdisc *sch)\n{\n\tint prio;\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\n\ttcf_block_put(q->block);\n\tprio_offload(sch, NULL);\n\tfor (prio = 0; prio < q->bands; prio++)\n\t\tqdisc_put(q->queues[prio]);\n}\n\nstatic int prio_tune(struct Qdisc *sch, struct nlattr *opt,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *queues[TCQ_PRIO_BANDS];\n\tint oldbands = q->bands, i;\n\tstruct tc_prio_qopt *qopt;\n\n\tif (nla_len(opt) < sizeof(*qopt))\n\t\treturn -EINVAL;\n\tqopt = nla_data(opt);\n\n\tif (qopt->bands > TCQ_PRIO_BANDS || qopt->bands < TCQ_MIN_PRIO_BANDS)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i <= TC_PRIO_MAX; i++) {\n\t\tif (qopt->priomap[i] >= qopt->bands)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = oldbands; i < qopt->bands; i++) {\n\t\tqueues[i] = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\n\t\t\t\t\t      TC_H_MAKE(sch->handle, i + 1),\n\t\t\t\t\t      extack);\n\t\tif (!queues[i]) {\n\t\t\twhile (i > oldbands)\n\t\t\t\tqdisc_put(queues[--i]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tprio_offload(sch, qopt);\n\tsch_tree_lock(sch);\n\tq->bands = qopt->bands;\n\tmemcpy(q->prio2band, qopt->priomap, TC_PRIO_MAX+1);\n\n\tfor (i = q->bands; i < oldbands; i++)\n\t\tqdisc_tree_flush_backlog(q->queues[i]);\n\n\tfor (i = oldbands; i < q->bands; i++) {\n\t\tq->queues[i] = queues[i];\n\t\tif (q->queues[i] != &noop_qdisc)\n\t\t\tqdisc_hash_add(q->queues[i], true);\n\t}\n\n\tsch_tree_unlock(sch);\n\n\tfor (i = q->bands; i < oldbands; i++)\n\t\tqdisc_put(q->queues[i]);\n\treturn 0;\n}\n\nstatic int prio_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tint err;\n\n\tif (!opt)\n\t\treturn -EINVAL;\n\n\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);\n\tif (err)\n\t\treturn err;\n\n\treturn prio_tune(sch, opt, extack);\n}\n\nstatic int prio_dump_offload(struct Qdisc *sch)\n{\n\tstruct tc_prio_qopt_offload hw_stats = {\n\t\t.command = TC_PRIO_STATS,\n\t\t.handle = sch->handle,\n\t\t.parent = sch->parent,\n\t\t{\n\t\t\t.stats = {\n\t\t\t\t.bstats = &sch->bstats,\n\t\t\t\t.qstats = &sch->qstats,\n\t\t\t},\n\t\t},\n\t};\n\n\treturn qdisc_offload_dump_helper(sch, TC_SETUP_QDISC_PRIO, &hw_stats);\n}\n\nstatic int prio_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tc_prio_qopt opt;\n\tint err;\n\n\topt.bands = q->bands;\n\tmemcpy(&opt.priomap, q->prio2band, TC_PRIO_MAX + 1);\n\n\terr = prio_dump_offload(sch);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic int prio_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,\n\t\t      struct Qdisc **old, struct netlink_ext_ack *extack)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tstruct tc_prio_qopt_offload graft_offload;\n\tunsigned long band = arg - 1;\n\n\tif (!new) {\n\t\tnew = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\n\t\t\t\t\tTC_H_MAKE(sch->handle, arg), extack);\n\t\tif (!new)\n\t\t\tnew = &noop_qdisc;\n\t\telse\n\t\t\tqdisc_hash_add(new, true);\n\t}\n\n\t*old = qdisc_replace(sch, new, &q->queues[band]);\n\n\tgraft_offload.handle = sch->handle;\n\tgraft_offload.parent = sch->parent;\n\tgraft_offload.graft_params.band = band;\n\tgraft_offload.graft_params.child_handle = new->handle;\n\tgraft_offload.command = TC_PRIO_GRAFT;\n\n\tqdisc_offload_graft_helper(qdisc_dev(sch), sch, new, *old,\n\t\t\t\t   TC_SETUP_QDISC_PRIO, &graft_offload,\n\t\t\t\t   extack);\n\treturn 0;\n}\n\nstatic struct Qdisc *\nprio_leaf(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tunsigned long band = arg - 1;\n\n\treturn q->queues[band];\n}\n\nstatic unsigned long prio_find(struct Qdisc *sch, u32 classid)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tunsigned long band = TC_H_MIN(classid);\n\n\tif (band - 1 >= q->bands)\n\t\treturn 0;\n\treturn band;\n}\n\nstatic unsigned long prio_bind(struct Qdisc *sch, unsigned long parent, u32 classid)\n{\n\treturn prio_find(sch, classid);\n}\n\n\nstatic void prio_unbind(struct Qdisc *q, unsigned long cl)\n{\n}\n\nstatic int prio_dump_class(struct Qdisc *sch, unsigned long cl, struct sk_buff *skb,\n\t\t\t   struct tcmsg *tcm)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\n\ttcm->tcm_handle |= TC_H_MIN(cl);\n\ttcm->tcm_info = q->queues[cl-1]->handle;\n\treturn 0;\n}\n\nstatic int prio_dump_class_stats(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t struct gnet_dump *d)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *cl_q;\n\n\tcl_q = q->queues[cl - 1];\n\tif (gnet_stats_copy_basic(d, cl_q->cpu_bstats,\n\t\t\t\t  &cl_q->bstats, true) < 0 ||\n\t    qdisc_qstats_copy(d, cl_q) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void prio_walk(struct Qdisc *sch, struct qdisc_walker *arg)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\tint prio;\n\n\tif (arg->stop)\n\t\treturn;\n\n\tfor (prio = 0; prio < q->bands; prio++) {\n\t\tif (!tc_qdisc_stats_dump(sch, prio + 1, arg))\n\t\t\tbreak;\n\t}\n}\n\nstatic struct tcf_block *prio_tcf_block(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct prio_sched_data *q = qdisc_priv(sch);\n\n\tif (cl)\n\t\treturn NULL;\n\treturn q->block;\n}\n\nstatic const struct Qdisc_class_ops prio_class_ops = {\n\t.graft\t\t=\tprio_graft,\n\t.leaf\t\t=\tprio_leaf,\n\t.find\t\t=\tprio_find,\n\t.walk\t\t=\tprio_walk,\n\t.tcf_block\t=\tprio_tcf_block,\n\t.bind_tcf\t=\tprio_bind,\n\t.unbind_tcf\t=\tprio_unbind,\n\t.dump\t\t=\tprio_dump_class,\n\t.dump_stats\t=\tprio_dump_class_stats,\n};\n\nstatic struct Qdisc_ops prio_qdisc_ops __read_mostly = {\n\t.next\t\t=\tNULL,\n\t.cl_ops\t\t=\t&prio_class_ops,\n\t.id\t\t=\t\"prio\",\n\t.priv_size\t=\tsizeof(struct prio_sched_data),\n\t.enqueue\t=\tprio_enqueue,\n\t.dequeue\t=\tprio_dequeue,\n\t.peek\t\t=\tprio_peek,\n\t.init\t\t=\tprio_init,\n\t.reset\t\t=\tprio_reset,\n\t.destroy\t=\tprio_destroy,\n\t.change\t\t=\tprio_tune,\n\t.dump\t\t=\tprio_dump,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init prio_module_init(void)\n{\n\treturn register_qdisc(&prio_qdisc_ops);\n}\n\nstatic void __exit prio_module_exit(void)\n{\n\tunregister_qdisc(&prio_qdisc_ops);\n}\n\nmodule_init(prio_module_init)\nmodule_exit(prio_module_exit)\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}