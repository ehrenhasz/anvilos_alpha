{
  "module_name": "act_pedit.c",
  "hash_id": "3584403ed0d1c8861622dba4cdb4600de45c8cf0cbe4b29d43215a3535d41fc6",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_pedit.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/slab.h>\n#include <net/ipv6.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <linux/tc_act/tc_pedit.h>\n#include <net/tc_act/tc_pedit.h>\n#include <uapi/linux/tc_act/tc_pedit.h>\n#include <net/pkt_cls.h>\n#include <net/tc_wrapper.h>\n\nstatic struct tc_action_ops act_pedit_ops;\n\nstatic const struct nla_policy pedit_policy[TCA_PEDIT_MAX + 1] = {\n\t[TCA_PEDIT_PARMS]\t= { .len = sizeof(struct tc_pedit) },\n\t[TCA_PEDIT_PARMS_EX]\t= { .len = sizeof(struct tc_pedit) },\n\t[TCA_PEDIT_KEYS_EX]   = { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy pedit_key_ex_policy[TCA_PEDIT_KEY_EX_MAX + 1] = {\n\t[TCA_PEDIT_KEY_EX_HTYPE] =\n\t\tNLA_POLICY_MAX(NLA_U16, TCA_PEDIT_HDR_TYPE_MAX),\n\t[TCA_PEDIT_KEY_EX_CMD] = NLA_POLICY_MAX(NLA_U16, TCA_PEDIT_CMD_MAX),\n};\n\nstatic struct tcf_pedit_key_ex *tcf_pedit_keys_ex_parse(struct nlattr *nla,\n\t\t\t\t\t\t\tu8 n, struct netlink_ext_ack *extack)\n{\n\tstruct tcf_pedit_key_ex *keys_ex;\n\tstruct tcf_pedit_key_ex *k;\n\tconst struct nlattr *ka;\n\tint err = -EINVAL;\n\tint rem;\n\n\tif (!nla)\n\t\treturn NULL;\n\n\tkeys_ex = kcalloc(n, sizeof(*k), GFP_KERNEL);\n\tif (!keys_ex)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tk = keys_ex;\n\n\tnla_for_each_nested(ka, nla, rem) {\n\t\tstruct nlattr *tb[TCA_PEDIT_KEY_EX_MAX + 1];\n\n\t\tif (!n) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't parse more extended keys than requested\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tn--;\n\n\t\tif (nla_type(ka) != TCA_PEDIT_KEY_EX) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, ka, \"Unknown attribute, expected extended key\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\terr = nla_parse_nested_deprecated(tb, TCA_PEDIT_KEY_EX_MAX,\n\t\t\t\t\t\t  ka, pedit_key_ex_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tif (NL_REQ_ATTR_CHECK(extack, nla, tb, TCA_PEDIT_KEY_EX_HTYPE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Missing required attribute\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (NL_REQ_ATTR_CHECK(extack, nla, tb, TCA_PEDIT_KEY_EX_CMD)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Missing required attribute\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tk->htype = nla_get_u16(tb[TCA_PEDIT_KEY_EX_HTYPE]);\n\t\tk->cmd = nla_get_u16(tb[TCA_PEDIT_KEY_EX_CMD]);\n\n\t\tk++;\n\t}\n\n\tif (n) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Not enough extended keys to parse\");\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\treturn keys_ex;\n\nerr_out:\n\tkfree(keys_ex);\n\treturn ERR_PTR(err);\n}\n\nstatic int tcf_pedit_key_ex_dump(struct sk_buff *skb,\n\t\t\t\t struct tcf_pedit_key_ex *keys_ex, int n)\n{\n\tstruct nlattr *keys_start = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t  TCA_PEDIT_KEYS_EX);\n\n\tif (!keys_start)\n\t\tgoto nla_failure;\n\tfor (; n > 0; n--) {\n\t\tstruct nlattr *key_start;\n\n\t\tkey_start = nla_nest_start_noflag(skb, TCA_PEDIT_KEY_EX);\n\t\tif (!key_start)\n\t\t\tgoto nla_failure;\n\n\t\tif (nla_put_u16(skb, TCA_PEDIT_KEY_EX_HTYPE, keys_ex->htype) ||\n\t\t    nla_put_u16(skb, TCA_PEDIT_KEY_EX_CMD, keys_ex->cmd))\n\t\t\tgoto nla_failure;\n\n\t\tnla_nest_end(skb, key_start);\n\n\t\tkeys_ex++;\n\t}\n\n\tnla_nest_end(skb, keys_start);\n\n\treturn 0;\nnla_failure:\n\tnla_nest_cancel(skb, keys_start);\n\treturn -EINVAL;\n}\n\nstatic void tcf_pedit_cleanup_rcu(struct rcu_head *head)\n{\n\tstruct tcf_pedit_parms *parms =\n\t\tcontainer_of(head, struct tcf_pedit_parms, rcu);\n\n\tkfree(parms->tcfp_keys_ex);\n\tkfree(parms->tcfp_keys);\n\n\tkfree(parms);\n}\n\nstatic int tcf_pedit_init(struct net *net, struct nlattr *nla,\n\t\t\t  struct nlattr *est, struct tc_action **a,\n\t\t\t  struct tcf_proto *tp, u32 flags,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_pedit_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tcf_pedit_parms *oparms, *nparms;\n\tstruct nlattr *tb[TCA_PEDIT_MAX + 1];\n\tstruct tc_pedit *parm;\n\tstruct nlattr *pattr;\n\tstruct tcf_pedit *p;\n\tint ret = 0, err;\n\tint i, ksize;\n\tu32 index;\n\n\tif (!nla) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Pedit requires attributes to be passed\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, TCA_PEDIT_MAX, nla,\n\t\t\t\t\t  pedit_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tpattr = tb[TCA_PEDIT_PARMS];\n\tif (!pattr)\n\t\tpattr = tb[TCA_PEDIT_PARMS_EX];\n\tif (!pattr) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing required TCA_PEDIT_PARMS or TCA_PEDIT_PARMS_EX pedit attribute\");\n\t\treturn -EINVAL;\n\t}\n\n\tparm = nla_data(pattr);\n\n\tindex = parm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (!err) {\n\t\tret = tcf_idr_create_from_flags(tn, index, est, a,\n\t\t\t\t\t\t&act_pedit_ops, bind, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ACT_P_CREATED;\n\t} else if (err > 0) {\n\t\tif (bind)\n\t\t\treturn 0;\n\t\tif (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out_release;\n\t\t}\n\t} else {\n\t\treturn err;\n\t}\n\n\tif (!parm->nkeys) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Pedit requires keys to be passed\");\n\t\tret = -EINVAL;\n\t\tgoto out_release;\n\t}\n\tksize = parm->nkeys * sizeof(struct tc_pedit_key);\n\tif (nla_len(pattr) < sizeof(*parm) + ksize) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, pattr, \"Length of TCA_PEDIT_PARMS or TCA_PEDIT_PARMS_EX pedit attribute is invalid\");\n\t\tret = -EINVAL;\n\t\tgoto out_release;\n\t}\n\n\tnparms = kzalloc(sizeof(*nparms), GFP_KERNEL);\n\tif (!nparms) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\n\tnparms->tcfp_keys_ex =\n\t\ttcf_pedit_keys_ex_parse(tb[TCA_PEDIT_KEYS_EX], parm->nkeys, extack);\n\tif (IS_ERR(nparms->tcfp_keys_ex)) {\n\t\tret = PTR_ERR(nparms->tcfp_keys_ex);\n\t\tgoto out_free;\n\t}\n\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0) {\n\t\tret = err;\n\t\tgoto out_free_ex;\n\t}\n\n\tnparms->tcfp_off_max_hint = 0;\n\tnparms->tcfp_flags = parm->flags;\n\tnparms->tcfp_nkeys = parm->nkeys;\n\n\tnparms->tcfp_keys = kmemdup(parm->keys, ksize, GFP_KERNEL);\n\tif (!nparms->tcfp_keys) {\n\t\tret = -ENOMEM;\n\t\tgoto put_chain;\n\t}\n\n\tfor (i = 0; i < nparms->tcfp_nkeys; ++i) {\n\t\tu32 offmask = nparms->tcfp_keys[i].offmask;\n\t\tu32 cur = nparms->tcfp_keys[i].off;\n\n\t\t \n\t\tif (!offmask && cur % 4) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Offsets must be on 32bit boundaries\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free_keys;\n\t\t}\n\n\t\t \n\t\tnparms->tcfp_keys[i].shift = min_t(size_t,\n\t\t\t\t\t\t   BITS_PER_TYPE(int) - 1,\n\t\t\t\t\t\t   nparms->tcfp_keys[i].shift);\n\n\t\t \n\t\tcur += (0xff & offmask) >> nparms->tcfp_keys[i].shift;\n\n\t\t \n\t\tnparms->tcfp_off_max_hint =\n\t\t\tmax(nparms->tcfp_off_max_hint, cur + 4);\n\t}\n\n\tp = to_pedit(*a);\n\n\tspin_lock_bh(&p->tcf_lock);\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\toparms = rcu_replace_pointer(p->parms, nparms, 1);\n\tspin_unlock_bh(&p->tcf_lock);\n\n\tif (oparms)\n\t\tcall_rcu(&oparms->rcu, tcf_pedit_cleanup_rcu);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\n\treturn ret;\n\nout_free_keys:\n\tkfree(nparms->tcfp_keys);\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nout_free_ex:\n\tkfree(nparms->tcfp_keys_ex);\nout_free:\n\tkfree(nparms);\nout_release:\n\ttcf_idr_release(*a, bind);\n\treturn ret;\n}\n\nstatic void tcf_pedit_cleanup(struct tc_action *a)\n{\n\tstruct tcf_pedit *p = to_pedit(a);\n\tstruct tcf_pedit_parms *parms;\n\n\tparms = rcu_dereference_protected(p->parms, 1);\n\n\tif (parms)\n\t\tcall_rcu(&parms->rcu, tcf_pedit_cleanup_rcu);\n}\n\nstatic bool offset_valid(struct sk_buff *skb, int offset)\n{\n\tif (offset > 0 && offset > skb->len)\n\t\treturn false;\n\n\tif  (offset < 0 && -offset > skb_headroom(skb))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int pedit_l4_skb_offset(struct sk_buff *skb, int *hoffset, const int header_type)\n{\n\tconst int noff = skb_network_offset(skb);\n\tint ret = -EINVAL;\n\tstruct iphdr _iph;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph = skb_header_pointer(skb, noff, sizeof(_iph), &_iph);\n\n\t\tif (!iph)\n\t\t\tgoto out;\n\t\t*hoffset = noff + iph->ihl * 4;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6):\n\t\tret = ipv6_find_hdr(skb, hoffset, header_type, NULL, NULL) == header_type ? 0 : -EINVAL;\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int pedit_skb_hdr_offset(struct sk_buff *skb,\n\t\t\t\t enum pedit_header_type htype, int *hoffset)\n{\n\tint ret = -EINVAL;\n\t \n\tswitch (htype) {\n\tcase TCA_PEDIT_KEY_EX_HDR_TYPE_ETH:\n\t\tif (skb_mac_header_was_set(skb)) {\n\t\t\t*hoffset = skb_mac_offset(skb);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK:\n\tcase TCA_PEDIT_KEY_EX_HDR_TYPE_IP4:\n\tcase TCA_PEDIT_KEY_EX_HDR_TYPE_IP6:\n\t\t*hoffset = skb_network_offset(skb);\n\t\tret = 0;\n\t\tbreak;\n\tcase TCA_PEDIT_KEY_EX_HDR_TYPE_TCP:\n\t\tret = pedit_l4_skb_offset(skb, hoffset, IPPROTO_TCP);\n\t\tbreak;\n\tcase TCA_PEDIT_KEY_EX_HDR_TYPE_UDP:\n\t\tret = pedit_l4_skb_offset(skb, hoffset, IPPROTO_UDP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nTC_INDIRECT_SCOPE int tcf_pedit_act(struct sk_buff *skb,\n\t\t\t\t    const struct tc_action *a,\n\t\t\t\t    struct tcf_result *res)\n{\n\tenum pedit_header_type htype = TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK;\n\tenum pedit_cmd cmd = TCA_PEDIT_KEY_EX_CMD_SET;\n\tstruct tcf_pedit *p = to_pedit(a);\n\tstruct tcf_pedit_key_ex *tkey_ex;\n\tstruct tcf_pedit_parms *parms;\n\tstruct tc_pedit_key *tkey;\n\tu32 max_offset;\n\tint i;\n\n\tparms = rcu_dereference_bh(p->parms);\n\n\tmax_offset = (skb_transport_header_was_set(skb) ?\n\t\t      skb_transport_offset(skb) :\n\t\t      skb_network_offset(skb)) +\n\t\t     parms->tcfp_off_max_hint;\n\tif (skb_ensure_writable(skb, min(skb->len, max_offset)))\n\t\tgoto done;\n\n\ttcf_lastuse_update(&p->tcf_tm);\n\ttcf_action_update_bstats(&p->common, skb);\n\n\ttkey = parms->tcfp_keys;\n\ttkey_ex = parms->tcfp_keys_ex;\n\n\tfor (i = parms->tcfp_nkeys; i > 0; i--, tkey++) {\n\t\tint offset = tkey->off;\n\t\tint hoffset = 0;\n\t\tu32 *ptr, hdata;\n\t\tu32 val;\n\t\tint rc;\n\n\t\tif (tkey_ex) {\n\t\t\thtype = tkey_ex->htype;\n\t\t\tcmd = tkey_ex->cmd;\n\n\t\t\ttkey_ex++;\n\t\t}\n\n\t\trc = pedit_skb_hdr_offset(skb, htype, &hoffset);\n\t\tif (rc) {\n\t\t\tpr_info_ratelimited(\"tc action pedit unable to extract header offset for header type (0x%x)\\n\", htype);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (tkey->offmask) {\n\t\t\tu8 *d, _d;\n\n\t\t\tif (!offset_valid(skb, hoffset + tkey->at)) {\n\t\t\t\tpr_info_ratelimited(\"tc action pedit 'at' offset %d out of bounds\\n\",\n\t\t\t\t\t\t    hoffset + tkey->at);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\td = skb_header_pointer(skb, hoffset + tkey->at,\n\t\t\t\t\t       sizeof(_d), &_d);\n\t\t\tif (!d)\n\t\t\t\tgoto bad;\n\n\t\t\toffset += (*d & tkey->offmask) >> tkey->shift;\n\t\t\tif (offset % 4) {\n\t\t\t\tpr_info_ratelimited(\"tc action pedit offset must be on 32 bit boundaries\\n\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\n\t\tif (!offset_valid(skb, hoffset + offset)) {\n\t\t\tpr_info_ratelimited(\"tc action pedit offset %d out of bounds\\n\", hoffset + offset);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tptr = skb_header_pointer(skb, hoffset + offset,\n\t\t\t\t\t sizeof(hdata), &hdata);\n\t\tif (!ptr)\n\t\t\tgoto bad;\n\t\t \n\t\tswitch (cmd) {\n\t\tcase TCA_PEDIT_KEY_EX_CMD_SET:\n\t\t\tval = tkey->val;\n\t\t\tbreak;\n\t\tcase TCA_PEDIT_KEY_EX_CMD_ADD:\n\t\t\tval = (*ptr + tkey->val) & ~tkey->mask;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info_ratelimited(\"tc action pedit bad command (%d)\\n\", cmd);\n\t\t\tgoto bad;\n\t\t}\n\n\t\t*ptr = ((*ptr & tkey->mask) ^ val);\n\t\tif (ptr == &hdata)\n\t\t\tskb_store_bits(skb, hoffset + offset, ptr, 4);\n\t}\n\n\tgoto done;\n\nbad:\n\ttcf_action_inc_overlimit_qstats(&p->common);\ndone:\n\treturn p->tcf_action;\n}\n\nstatic void tcf_pedit_stats_update(struct tc_action *a, u64 bytes, u64 packets,\n\t\t\t\t   u64 drops, u64 lastuse, bool hw)\n{\n\tstruct tcf_pedit *d = to_pedit(a);\n\tstruct tcf_t *tm = &d->tcf_tm;\n\n\ttcf_action_update_stats(a, bytes, packets, drops, hw);\n\ttm->lastuse = max_t(u64, tm->lastuse, lastuse);\n}\n\nstatic int tcf_pedit_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t  int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_pedit *p = to_pedit(a);\n\tstruct tcf_pedit_parms *parms;\n\tstruct tc_pedit *opt;\n\tstruct tcf_t t;\n\tint s;\n\n\tspin_lock_bh(&p->tcf_lock);\n\tparms = rcu_dereference_protected(p->parms, 1);\n\ts = struct_size(opt, keys, parms->tcfp_nkeys);\n\n\topt = kzalloc(s, GFP_ATOMIC);\n\tif (unlikely(!opt)) {\n\t\tspin_unlock_bh(&p->tcf_lock);\n\t\treturn -ENOBUFS;\n\t}\n\n\tmemcpy(opt->keys, parms->tcfp_keys,\n\t       flex_array_size(opt, keys, parms->tcfp_nkeys));\n\topt->index = p->tcf_index;\n\topt->nkeys = parms->tcfp_nkeys;\n\topt->flags = parms->tcfp_flags;\n\topt->action = p->tcf_action;\n\topt->refcnt = refcount_read(&p->tcf_refcnt) - ref;\n\topt->bindcnt = atomic_read(&p->tcf_bindcnt) - bind;\n\n\tif (parms->tcfp_keys_ex) {\n\t\tif (tcf_pedit_key_ex_dump(skb, parms->tcfp_keys_ex,\n\t\t\t\t\t  parms->tcfp_nkeys))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(skb, TCA_PEDIT_PARMS_EX, s, opt))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tif (nla_put(skb, TCA_PEDIT_PARMS, s, opt))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\ttcf_tm_dump(&t, &p->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_PEDIT_TM, sizeof(t), &t, TCA_PEDIT_PAD))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&p->tcf_lock);\n\n\tkfree(opt);\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&p->tcf_lock);\n\tnlmsg_trim(skb, b);\n\tkfree(opt);\n\treturn -1;\n}\n\nstatic int tcf_pedit_offload_act_setup(struct tc_action *act, void *entry_data,\n\t\t\t\t       u32 *index_inc, bool bind,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (bind) {\n\t\tstruct flow_action_entry *entry = entry_data;\n\t\tint k;\n\n\t\tfor (k = 0; k < tcf_pedit_nkeys(act); k++) {\n\t\t\tswitch (tcf_pedit_cmd(act, k)) {\n\t\t\tcase TCA_PEDIT_KEY_EX_CMD_SET:\n\t\t\t\tentry->id = FLOW_ACTION_MANGLE;\n\t\t\t\tbreak;\n\t\t\tcase TCA_PEDIT_KEY_EX_CMD_ADD:\n\t\t\t\tentry->id = FLOW_ACTION_ADD;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported pedit command offload\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tentry->mangle.htype = tcf_pedit_htype(act, k);\n\t\t\tentry->mangle.mask = tcf_pedit_mask(act, k);\n\t\t\tentry->mangle.val = tcf_pedit_val(act, k);\n\t\t\tentry->mangle.offset = tcf_pedit_offset(act, k);\n\t\t\tentry->hw_stats = tc_act_hw_stats(act->hw_stats);\n\t\t\tentry++;\n\t\t}\n\t\t*index_inc = k;\n\t} else {\n\t\tstruct flow_offload_action *fl_action = entry_data;\n\t\tu32 cmd = tcf_pedit_cmd(act, 0);\n\t\tint k;\n\n\t\tswitch (cmd) {\n\t\tcase TCA_PEDIT_KEY_EX_CMD_SET:\n\t\t\tfl_action->id = FLOW_ACTION_MANGLE;\n\t\t\tbreak;\n\t\tcase TCA_PEDIT_KEY_EX_CMD_ADD:\n\t\t\tfl_action->id = FLOW_ACTION_ADD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported pedit command offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tfor (k = 1; k < tcf_pedit_nkeys(act); k++) {\n\t\t\tif (cmd != tcf_pedit_cmd(act, k)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported pedit command offload\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct tc_action_ops act_pedit_ops = {\n\t.kind\t\t=\t\"pedit\",\n\t.id\t\t=\tTCA_ID_PEDIT,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_pedit_act,\n\t.stats_update\t=\ttcf_pedit_stats_update,\n\t.dump\t\t=\ttcf_pedit_dump,\n\t.cleanup\t=\ttcf_pedit_cleanup,\n\t.init\t\t=\ttcf_pedit_init,\n\t.offload_act_setup =\ttcf_pedit_offload_act_setup,\n\t.size\t\t=\tsizeof(struct tcf_pedit),\n};\n\nstatic __net_init int pedit_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_pedit_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_pedit_ops);\n}\n\nstatic void __net_exit pedit_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_pedit_ops.net_id);\n}\n\nstatic struct pernet_operations pedit_net_ops = {\n\t.init = pedit_init_net,\n\t.exit_batch = pedit_exit_net,\n\t.id   = &act_pedit_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nMODULE_AUTHOR(\"Jamal Hadi Salim(2002-4)\");\nMODULE_DESCRIPTION(\"Generic Packet Editor actions\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init pedit_init_module(void)\n{\n\treturn tcf_register_action(&act_pedit_ops, &pedit_net_ops);\n}\n\nstatic void __exit pedit_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_pedit_ops, &pedit_net_ops);\n}\n\nmodule_init(pedit_init_module);\nmodule_exit(pedit_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}