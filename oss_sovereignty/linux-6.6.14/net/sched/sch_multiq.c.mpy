{
  "module_name": "sch_multiq.c",
  "hash_id": "7e3dc171de4bee56bc5bff2fac4c5e6d6a0b73898abc6582387965a5a64decb8",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_multiq.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n\nstruct multiq_sched_data {\n\tu16 bands;\n\tu16 max_bands;\n\tu16 curband;\n\tstruct tcf_proto __rcu *filter_list;\n\tstruct tcf_block *block;\n\tstruct Qdisc **queues;\n};\n\n\nstatic struct Qdisc *\nmultiq_classify(struct sk_buff *skb, struct Qdisc *sch, int *qerr)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tu32 band;\n\tstruct tcf_result res;\n\tstruct tcf_proto *fl = rcu_dereference_bh(q->filter_list);\n\tint err;\n\n\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\terr = tcf_classify(skb, NULL, fl, &res, false);\n#ifdef CONFIG_NET_CLS_ACT\n\tswitch (err) {\n\tcase TC_ACT_STOLEN:\n\tcase TC_ACT_QUEUED:\n\tcase TC_ACT_TRAP:\n\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\tfallthrough;\n\tcase TC_ACT_SHOT:\n\t\treturn NULL;\n\t}\n#endif\n\tband = skb_get_queue_mapping(skb);\n\n\tif (band >= q->bands)\n\t\treturn q->queues[0];\n\n\treturn q->queues[band];\n}\n\nstatic int\nmultiq_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t       struct sk_buff **to_free)\n{\n\tstruct Qdisc *qdisc;\n\tint ret;\n\n\tqdisc = multiq_classify(skb, sch, &ret);\n#ifdef CONFIG_NET_CLS_ACT\n\tif (qdisc == NULL) {\n\n\t\tif (ret & __NET_XMIT_BYPASS)\n\t\t\tqdisc_qstats_drop(sch);\n\t\t__qdisc_drop(skb, to_free);\n\t\treturn ret;\n\t}\n#endif\n\n\tret = qdisc_enqueue(skb, qdisc, to_free);\n\tif (ret == NET_XMIT_SUCCESS) {\n\t\tsch->q.qlen++;\n\t\treturn NET_XMIT_SUCCESS;\n\t}\n\tif (net_xmit_drop_count(ret))\n\t\tqdisc_qstats_drop(sch);\n\treturn ret;\n}\n\nstatic struct sk_buff *multiq_dequeue(struct Qdisc *sch)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *qdisc;\n\tstruct sk_buff *skb;\n\tint band;\n\n\tfor (band = 0; band < q->bands; band++) {\n\t\t \n\t\tq->curband++;\n\t\tif (q->curband >= q->bands)\n\t\t\tq->curband = 0;\n\n\t\t \n\t\tif (!netif_xmit_stopped(\n\t\t    netdev_get_tx_queue(qdisc_dev(sch), q->curband))) {\n\t\t\tqdisc = q->queues[q->curband];\n\t\t\tskb = qdisc->dequeue(qdisc);\n\t\t\tif (skb) {\n\t\t\t\tqdisc_bstats_update(sch, skb);\n\t\t\t\tsch->q.qlen--;\n\t\t\t\treturn skb;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n\n}\n\nstatic struct sk_buff *multiq_peek(struct Qdisc *sch)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tunsigned int curband = q->curband;\n\tstruct Qdisc *qdisc;\n\tstruct sk_buff *skb;\n\tint band;\n\n\tfor (band = 0; band < q->bands; band++) {\n\t\t \n\t\tcurband++;\n\t\tif (curband >= q->bands)\n\t\t\tcurband = 0;\n\n\t\t \n\t\tif (!netif_xmit_stopped(\n\t\t    netdev_get_tx_queue(qdisc_dev(sch), curband))) {\n\t\t\tqdisc = q->queues[curband];\n\t\t\tskb = qdisc->ops->peek(qdisc);\n\t\t\tif (skb)\n\t\t\t\treturn skb;\n\t\t}\n\t}\n\treturn NULL;\n\n}\n\nstatic void\nmultiq_reset(struct Qdisc *sch)\n{\n\tu16 band;\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\n\tfor (band = 0; band < q->bands; band++)\n\t\tqdisc_reset(q->queues[band]);\n\tq->curband = 0;\n}\n\nstatic void\nmultiq_destroy(struct Qdisc *sch)\n{\n\tint band;\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\n\ttcf_block_put(q->block);\n\tfor (band = 0; band < q->bands; band++)\n\t\tqdisc_put(q->queues[band]);\n\n\tkfree(q->queues);\n}\n\nstatic int multiq_tune(struct Qdisc *sch, struct nlattr *opt,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tstruct tc_multiq_qopt *qopt;\n\tstruct Qdisc **removed;\n\tint i, n_removed = 0;\n\n\tif (!netif_is_multiqueue(qdisc_dev(sch)))\n\t\treturn -EOPNOTSUPP;\n\tif (nla_len(opt) < sizeof(*qopt))\n\t\treturn -EINVAL;\n\n\tqopt = nla_data(opt);\n\n\tqopt->bands = qdisc_dev(sch)->real_num_tx_queues;\n\n\tremoved = kmalloc(sizeof(*removed) * (q->max_bands - q->bands),\n\t\t\t  GFP_KERNEL);\n\tif (!removed)\n\t\treturn -ENOMEM;\n\n\tsch_tree_lock(sch);\n\tq->bands = qopt->bands;\n\tfor (i = q->bands; i < q->max_bands; i++) {\n\t\tif (q->queues[i] != &noop_qdisc) {\n\t\t\tstruct Qdisc *child = q->queues[i];\n\n\t\t\tq->queues[i] = &noop_qdisc;\n\t\t\tqdisc_purge_queue(child);\n\t\t\tremoved[n_removed++] = child;\n\t\t}\n\t}\n\n\tsch_tree_unlock(sch);\n\n\tfor (i = 0; i < n_removed; i++)\n\t\tqdisc_put(removed[i]);\n\tkfree(removed);\n\n\tfor (i = 0; i < q->bands; i++) {\n\t\tif (q->queues[i] == &noop_qdisc) {\n\t\t\tstruct Qdisc *child, *old;\n\t\t\tchild = qdisc_create_dflt(sch->dev_queue,\n\t\t\t\t\t\t  &pfifo_qdisc_ops,\n\t\t\t\t\t\t  TC_H_MAKE(sch->handle,\n\t\t\t\t\t\t\t    i + 1), extack);\n\t\t\tif (child) {\n\t\t\t\tsch_tree_lock(sch);\n\t\t\t\told = q->queues[i];\n\t\t\t\tq->queues[i] = child;\n\t\t\t\tif (child != &noop_qdisc)\n\t\t\t\t\tqdisc_hash_add(child, true);\n\n\t\t\t\tif (old != &noop_qdisc)\n\t\t\t\t\tqdisc_purge_queue(old);\n\t\t\t\tsch_tree_unlock(sch);\n\t\t\t\tqdisc_put(old);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int multiq_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tint i, err;\n\n\tq->queues = NULL;\n\n\tif (!opt)\n\t\treturn -EINVAL;\n\n\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);\n\tif (err)\n\t\treturn err;\n\n\tq->max_bands = qdisc_dev(sch)->num_tx_queues;\n\n\tq->queues = kcalloc(q->max_bands, sizeof(struct Qdisc *), GFP_KERNEL);\n\tif (!q->queues)\n\t\treturn -ENOBUFS;\n\tfor (i = 0; i < q->max_bands; i++)\n\t\tq->queues[i] = &noop_qdisc;\n\n\treturn multiq_tune(sch, opt, extack);\n}\n\nstatic int multiq_dump(struct Qdisc *sch, struct sk_buff *skb)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tc_multiq_qopt opt;\n\n\topt.bands = q->bands;\n\topt.max_bands = q->max_bands;\n\n\tif (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic int multiq_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,\n\t\t\tstruct Qdisc **old, struct netlink_ext_ack *extack)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tunsigned long band = arg - 1;\n\n\tif (new == NULL)\n\t\tnew = &noop_qdisc;\n\n\t*old = qdisc_replace(sch, new, &q->queues[band]);\n\treturn 0;\n}\n\nstatic struct Qdisc *\nmultiq_leaf(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tunsigned long band = arg - 1;\n\n\treturn q->queues[band];\n}\n\nstatic unsigned long multiq_find(struct Qdisc *sch, u32 classid)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tunsigned long band = TC_H_MIN(classid);\n\n\tif (band - 1 >= q->bands)\n\t\treturn 0;\n\treturn band;\n}\n\nstatic unsigned long multiq_bind(struct Qdisc *sch, unsigned long parent,\n\t\t\t\t u32 classid)\n{\n\treturn multiq_find(sch, classid);\n}\n\n\nstatic void multiq_unbind(struct Qdisc *q, unsigned long cl)\n{\n}\n\nstatic int multiq_dump_class(struct Qdisc *sch, unsigned long cl,\n\t\t\t     struct sk_buff *skb, struct tcmsg *tcm)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\n\ttcm->tcm_handle |= TC_H_MIN(cl);\n\ttcm->tcm_info = q->queues[cl - 1]->handle;\n\treturn 0;\n}\n\nstatic int multiq_dump_class_stats(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t struct gnet_dump *d)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *cl_q;\n\n\tcl_q = q->queues[cl - 1];\n\tif (gnet_stats_copy_basic(d, cl_q->cpu_bstats, &cl_q->bstats, true) < 0 ||\n\t    qdisc_qstats_copy(d, cl_q) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void multiq_walk(struct Qdisc *sch, struct qdisc_walker *arg)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tint band;\n\n\tif (arg->stop)\n\t\treturn;\n\n\tfor (band = 0; band < q->bands; band++) {\n\t\tif (!tc_qdisc_stats_dump(sch, band + 1, arg))\n\t\t\tbreak;\n\t}\n}\n\nstatic struct tcf_block *multiq_tcf_block(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\n\tif (cl)\n\t\treturn NULL;\n\treturn q->block;\n}\n\nstatic const struct Qdisc_class_ops multiq_class_ops = {\n\t.graft\t\t=\tmultiq_graft,\n\t.leaf\t\t=\tmultiq_leaf,\n\t.find\t\t=\tmultiq_find,\n\t.walk\t\t=\tmultiq_walk,\n\t.tcf_block\t=\tmultiq_tcf_block,\n\t.bind_tcf\t=\tmultiq_bind,\n\t.unbind_tcf\t=\tmultiq_unbind,\n\t.dump\t\t=\tmultiq_dump_class,\n\t.dump_stats\t=\tmultiq_dump_class_stats,\n};\n\nstatic struct Qdisc_ops multiq_qdisc_ops __read_mostly = {\n\t.next\t\t=\tNULL,\n\t.cl_ops\t\t=\t&multiq_class_ops,\n\t.id\t\t=\t\"multiq\",\n\t.priv_size\t=\tsizeof(struct multiq_sched_data),\n\t.enqueue\t=\tmultiq_enqueue,\n\t.dequeue\t=\tmultiq_dequeue,\n\t.peek\t\t=\tmultiq_peek,\n\t.init\t\t=\tmultiq_init,\n\t.reset\t\t=\tmultiq_reset,\n\t.destroy\t=\tmultiq_destroy,\n\t.change\t\t=\tmultiq_tune,\n\t.dump\t\t=\tmultiq_dump,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init multiq_module_init(void)\n{\n\treturn register_qdisc(&multiq_qdisc_ops);\n}\n\nstatic void __exit multiq_module_exit(void)\n{\n\tunregister_qdisc(&multiq_qdisc_ops);\n}\n\nmodule_init(multiq_module_init)\nmodule_exit(multiq_module_exit)\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}