{
  "module_name": "em_ipset.c",
  "hash_id": "d3951ebb7b417b0300682f6d9da628b932d7c922c702e2ab0b109dd66893ce48",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/em_ipset.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter/xt_set.h>\n#include <linux/ipv6.h>\n#include <net/ip.h>\n#include <net/pkt_cls.h>\n\nstatic int em_ipset_change(struct net *net, void *data, int data_len,\n\t\t\t   struct tcf_ematch *em)\n{\n\tstruct xt_set_info *set = data;\n\tip_set_id_t index;\n\n\tif (data_len != sizeof(*set))\n\t\treturn -EINVAL;\n\n\tindex = ip_set_nfnl_get_byindex(net, set->index);\n\tif (index == IPSET_INVALID_ID)\n\t\treturn -ENOENT;\n\n\tem->datalen = sizeof(*set);\n\tem->data = (unsigned long)kmemdup(data, em->datalen, GFP_KERNEL);\n\tif (em->data)\n\t\treturn 0;\n\n\tip_set_nfnl_put(net, index);\n\treturn -ENOMEM;\n}\n\nstatic void em_ipset_destroy(struct tcf_ematch *em)\n{\n\tconst struct xt_set_info *set = (const void *) em->data;\n\tif (set) {\n\t\tip_set_nfnl_put(em->net, set->index);\n\t\tkfree((void *) em->data);\n\t}\n}\n\nstatic int em_ipset_match(struct sk_buff *skb, struct tcf_ematch *em,\n\t\t\t  struct tcf_pkt_info *info)\n{\n\tstruct ip_set_adt_opt opt;\n\tstruct xt_action_param acpar;\n\tconst struct xt_set_info *set = (const void *) em->data;\n\tstruct net_device *dev, *indev = NULL;\n\tstruct nf_hook_state state = {\n\t\t.net\t= em->net,\n\t};\n\tint ret, network_offset;\n\n\tswitch (skb_protocol(skb, true)) {\n\tcase htons(ETH_P_IP):\n\t\tstate.pf = NFPROTO_IPV4;\n\t\tif (!pskb_network_may_pull(skb, sizeof(struct iphdr)))\n\t\t\treturn 0;\n\t\tacpar.thoff = ip_hdrlen(skb);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tstate.pf = NFPROTO_IPV6;\n\t\tif (!pskb_network_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\t\treturn 0;\n\t\t \n\t\tacpar.thoff = sizeof(struct ipv6hdr);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\topt.family = state.pf;\n\topt.dim = set->dim;\n\topt.flags = set->flags;\n\topt.cmdflags = 0;\n\topt.ext.timeout = ~0u;\n\n\tnetwork_offset = skb_network_offset(skb);\n\tskb_pull(skb, network_offset);\n\n\tdev = skb->dev;\n\n\trcu_read_lock();\n\n\tif (skb->skb_iif)\n\t\tindev = dev_get_by_index_rcu(em->net, skb->skb_iif);\n\n\tstate.in      = indev ? indev : dev;\n\tstate.out     = dev;\n\tacpar.state   = &state;\n\n\tret = ip_set_test(set->index, skb, &acpar, &opt);\n\n\trcu_read_unlock();\n\n\tskb_push(skb, network_offset);\n\treturn ret;\n}\n\nstatic struct tcf_ematch_ops em_ipset_ops = {\n\t.kind\t  = TCF_EM_IPSET,\n\t.change\t  = em_ipset_change,\n\t.destroy  = em_ipset_destroy,\n\t.match\t  = em_ipset_match,\n\t.owner\t  = THIS_MODULE,\n\t.link\t  = LIST_HEAD_INIT(em_ipset_ops.link)\n};\n\nstatic int __init init_em_ipset(void)\n{\n\treturn tcf_em_register(&em_ipset_ops);\n}\n\nstatic void __exit exit_em_ipset(void)\n{\n\ttcf_em_unregister(&em_ipset_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Florian Westphal <fw@strlen.de>\");\nMODULE_DESCRIPTION(\"TC extended match for IP sets\");\n\nmodule_init(init_em_ipset);\nmodule_exit(exit_em_ipset);\n\nMODULE_ALIAS_TCF_EMATCH(TCF_EM_IPSET);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}