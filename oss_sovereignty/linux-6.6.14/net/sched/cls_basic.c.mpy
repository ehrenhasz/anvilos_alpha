{
  "module_name": "cls_basic.c",
  "hash_id": "22875f6a28de85fbceb51c6939de77812704e70dde9718fb131b4360a286c6ce",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/cls_basic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/idr.h>\n#include <linux/percpu.h>\n#include <net/netlink.h>\n#include <net/act_api.h>\n#include <net/pkt_cls.h>\n#include <net/tc_wrapper.h>\n\nstruct basic_head {\n\tstruct list_head\tflist;\n\tstruct idr\t\thandle_idr;\n\tstruct rcu_head\t\trcu;\n};\n\nstruct basic_filter {\n\tu32\t\t\thandle;\n\tstruct tcf_exts\t\texts;\n\tstruct tcf_ematch_tree\tematches;\n\tstruct tcf_result\tres;\n\tstruct tcf_proto\t*tp;\n\tstruct list_head\tlink;\n\tstruct tc_basic_pcnt __percpu *pf;\n\tstruct rcu_work\t\trwork;\n};\n\nTC_INDIRECT_SCOPE int basic_classify(struct sk_buff *skb,\n\t\t\t\t     const struct tcf_proto *tp,\n\t\t\t\t     struct tcf_result *res)\n{\n\tint r;\n\tstruct basic_head *head = rcu_dereference_bh(tp->root);\n\tstruct basic_filter *f;\n\n\tlist_for_each_entry_rcu(f, &head->flist, link) {\n\t\t__this_cpu_inc(f->pf->rcnt);\n\t\tif (!tcf_em_tree_match(skb, &f->ematches, NULL))\n\t\t\tcontinue;\n\t\t__this_cpu_inc(f->pf->rhit);\n\t\t*res = f->res;\n\t\tr = tcf_exts_exec(skb, &f->exts, res);\n\t\tif (r < 0)\n\t\t\tcontinue;\n\t\treturn r;\n\t}\n\treturn -1;\n}\n\nstatic void *basic_get(struct tcf_proto *tp, u32 handle)\n{\n\tstruct basic_head *head = rtnl_dereference(tp->root);\n\tstruct basic_filter *f;\n\n\tlist_for_each_entry(f, &head->flist, link) {\n\t\tif (f->handle == handle) {\n\t\t\treturn f;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int basic_init(struct tcf_proto *tp)\n{\n\tstruct basic_head *head;\n\n\thead = kzalloc(sizeof(*head), GFP_KERNEL);\n\tif (head == NULL)\n\t\treturn -ENOBUFS;\n\tINIT_LIST_HEAD(&head->flist);\n\tidr_init(&head->handle_idr);\n\trcu_assign_pointer(tp->root, head);\n\treturn 0;\n}\n\nstatic void __basic_delete_filter(struct basic_filter *f)\n{\n\ttcf_exts_destroy(&f->exts);\n\ttcf_em_tree_destroy(&f->ematches);\n\ttcf_exts_put_net(&f->exts);\n\tfree_percpu(f->pf);\n\tkfree(f);\n}\n\nstatic void basic_delete_filter_work(struct work_struct *work)\n{\n\tstruct basic_filter *f = container_of(to_rcu_work(work),\n\t\t\t\t\t      struct basic_filter,\n\t\t\t\t\t      rwork);\n\trtnl_lock();\n\t__basic_delete_filter(f);\n\trtnl_unlock();\n}\n\nstatic void basic_destroy(struct tcf_proto *tp, bool rtnl_held,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct basic_head *head = rtnl_dereference(tp->root);\n\tstruct basic_filter *f, *n;\n\n\tlist_for_each_entry_safe(f, n, &head->flist, link) {\n\t\tlist_del_rcu(&f->link);\n\t\ttcf_unbind_filter(tp, &f->res);\n\t\tidr_remove(&head->handle_idr, f->handle);\n\t\tif (tcf_exts_get_net(&f->exts))\n\t\t\ttcf_queue_work(&f->rwork, basic_delete_filter_work);\n\t\telse\n\t\t\t__basic_delete_filter(f);\n\t}\n\tidr_destroy(&head->handle_idr);\n\tkfree_rcu(head, rcu);\n}\n\nstatic int basic_delete(struct tcf_proto *tp, void *arg, bool *last,\n\t\t\tbool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct basic_head *head = rtnl_dereference(tp->root);\n\tstruct basic_filter *f = arg;\n\n\tlist_del_rcu(&f->link);\n\ttcf_unbind_filter(tp, &f->res);\n\tidr_remove(&head->handle_idr, f->handle);\n\ttcf_exts_get_net(&f->exts);\n\ttcf_queue_work(&f->rwork, basic_delete_filter_work);\n\t*last = list_empty(&head->flist);\n\treturn 0;\n}\n\nstatic const struct nla_policy basic_policy[TCA_BASIC_MAX + 1] = {\n\t[TCA_BASIC_CLASSID]\t= { .type = NLA_U32 },\n\t[TCA_BASIC_EMATCHES]\t= { .type = NLA_NESTED },\n};\n\nstatic int basic_set_parms(struct net *net, struct tcf_proto *tp,\n\t\t\t   struct basic_filter *f, unsigned long base,\n\t\t\t   struct nlattr **tb,\n\t\t\t   struct nlattr *est, u32 flags,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = tcf_exts_validate(net, tp, tb, est, &f->exts, flags, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tcf_em_tree_validate(tp, tb[TCA_BASIC_EMATCHES], &f->ematches);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_BASIC_CLASSID]) {\n\t\tf->res.classid = nla_get_u32(tb[TCA_BASIC_CLASSID]);\n\t\ttcf_bind_filter(tp, &f->res, base);\n\t}\n\n\tf->tp = tp;\n\treturn 0;\n}\n\nstatic int basic_change(struct net *net, struct sk_buff *in_skb,\n\t\t\tstruct tcf_proto *tp, unsigned long base, u32 handle,\n\t\t\tstruct nlattr **tca, void **arg,\n\t\t\tu32 flags, struct netlink_ext_ack *extack)\n{\n\tint err;\n\tstruct basic_head *head = rtnl_dereference(tp->root);\n\tstruct nlattr *tb[TCA_BASIC_MAX + 1];\n\tstruct basic_filter *fold = (struct basic_filter *) *arg;\n\tstruct basic_filter *fnew;\n\n\tif (tca[TCA_OPTIONS] == NULL)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_BASIC_MAX, tca[TCA_OPTIONS],\n\t\t\t\t\t  basic_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (fold != NULL) {\n\t\tif (handle && fold->handle != handle)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfnew = kzalloc(sizeof(*fnew), GFP_KERNEL);\n\tif (!fnew)\n\t\treturn -ENOBUFS;\n\n\terr = tcf_exts_init(&fnew->exts, net, TCA_BASIC_ACT, TCA_BASIC_POLICE);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (!handle) {\n\t\thandle = 1;\n\t\terr = idr_alloc_u32(&head->handle_idr, fnew, &handle,\n\t\t\t\t    INT_MAX, GFP_KERNEL);\n\t} else if (!fold) {\n\t\terr = idr_alloc_u32(&head->handle_idr, fnew, &handle,\n\t\t\t\t    handle, GFP_KERNEL);\n\t}\n\tif (err)\n\t\tgoto errout;\n\tfnew->handle = handle;\n\tfnew->pf = alloc_percpu(struct tc_basic_pcnt);\n\tif (!fnew->pf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\terr = basic_set_parms(net, tp, fnew, base, tb, tca[TCA_RATE], flags,\n\t\t\t      extack);\n\tif (err < 0) {\n\t\tif (!fold)\n\t\t\tidr_remove(&head->handle_idr, fnew->handle);\n\t\tgoto errout;\n\t}\n\n\t*arg = fnew;\n\n\tif (fold) {\n\t\tidr_replace(&head->handle_idr, fnew, fnew->handle);\n\t\tlist_replace_rcu(&fold->link, &fnew->link);\n\t\ttcf_unbind_filter(tp, &fold->res);\n\t\ttcf_exts_get_net(&fold->exts);\n\t\ttcf_queue_work(&fold->rwork, basic_delete_filter_work);\n\t} else {\n\t\tlist_add_rcu(&fnew->link, &head->flist);\n\t}\n\n\treturn 0;\nerrout:\n\tfree_percpu(fnew->pf);\n\ttcf_exts_destroy(&fnew->exts);\n\tkfree(fnew);\n\treturn err;\n}\n\nstatic void basic_walk(struct tcf_proto *tp, struct tcf_walker *arg,\n\t\t       bool rtnl_held)\n{\n\tstruct basic_head *head = rtnl_dereference(tp->root);\n\tstruct basic_filter *f;\n\n\tlist_for_each_entry(f, &head->flist, link) {\n\t\tif (!tc_cls_stats_dump(tp, arg, f))\n\t\t\tbreak;\n\t}\n}\n\nstatic void basic_bind_class(void *fh, u32 classid, unsigned long cl, void *q,\n\t\t\t     unsigned long base)\n{\n\tstruct basic_filter *f = fh;\n\n\ttc_cls_bind_class(classid, cl, q, &f->res, base);\n}\n\nstatic int basic_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t      struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)\n{\n\tstruct tc_basic_pcnt gpf = {};\n\tstruct basic_filter *f = fh;\n\tstruct nlattr *nest;\n\tint cpu;\n\n\tif (f == NULL)\n\t\treturn skb->len;\n\n\tt->tcm_handle = f->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (f->res.classid &&\n\t    nla_put_u32(skb, TCA_BASIC_CLASSID, f->res.classid))\n\t\tgoto nla_put_failure;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct tc_basic_pcnt *pf = per_cpu_ptr(f->pf, cpu);\n\n\t\tgpf.rcnt += pf->rcnt;\n\t\tgpf.rhit += pf->rhit;\n\t}\n\n\tif (nla_put_64bit(skb, TCA_BASIC_PCNT,\n\t\t\t  sizeof(struct tc_basic_pcnt),\n\t\t\t  &gpf, TCA_BASIC_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (tcf_exts_dump(skb, &f->exts) < 0 ||\n\t    tcf_em_tree_dump(skb, &f->ematches, TCA_BASIC_EMATCHES) < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\n\tif (tcf_exts_dump_stats(skb, &f->exts) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic struct tcf_proto_ops cls_basic_ops __read_mostly = {\n\t.kind\t\t=\t\"basic\",\n\t.classify\t=\tbasic_classify,\n\t.init\t\t=\tbasic_init,\n\t.destroy\t=\tbasic_destroy,\n\t.get\t\t=\tbasic_get,\n\t.change\t\t=\tbasic_change,\n\t.delete\t\t=\tbasic_delete,\n\t.walk\t\t=\tbasic_walk,\n\t.dump\t\t=\tbasic_dump,\n\t.bind_class\t=\tbasic_bind_class,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init init_basic(void)\n{\n\treturn register_tcf_proto_ops(&cls_basic_ops);\n}\n\nstatic void __exit exit_basic(void)\n{\n\tunregister_tcf_proto_ops(&cls_basic_ops);\n}\n\nmodule_init(init_basic)\nmodule_exit(exit_basic)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}