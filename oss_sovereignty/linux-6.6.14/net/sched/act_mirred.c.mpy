{
  "module_name": "act_mirred.c",
  "hash_id": "b2c78f06572a76fbfbd5a925313d73c1a818e92bd7556718c23f1e0b4b9d5c75",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_mirred.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/if_arp.h>\n#include <net/net_namespace.h>\n#include <net/netlink.h>\n#include <net/dst.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <linux/tc_act/tc_mirred.h>\n#include <net/tc_act/tc_mirred.h>\n#include <net/tc_wrapper.h>\n\nstatic LIST_HEAD(mirred_list);\nstatic DEFINE_SPINLOCK(mirred_list_lock);\n\n#define MIRRED_NEST_LIMIT    4\nstatic DEFINE_PER_CPU(unsigned int, mirred_nest_level);\n\nstatic bool tcf_mirred_is_act_redirect(int action)\n{\n\treturn action == TCA_EGRESS_REDIR || action == TCA_INGRESS_REDIR;\n}\n\nstatic bool tcf_mirred_act_wants_ingress(int action)\n{\n\tswitch (action) {\n\tcase TCA_EGRESS_REDIR:\n\tcase TCA_EGRESS_MIRROR:\n\t\treturn false;\n\tcase TCA_INGRESS_REDIR:\n\tcase TCA_INGRESS_MIRROR:\n\t\treturn true;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic bool tcf_mirred_can_reinsert(int action)\n{\n\tswitch (action) {\n\tcase TC_ACT_SHOT:\n\tcase TC_ACT_STOLEN:\n\tcase TC_ACT_QUEUED:\n\tcase TC_ACT_TRAP:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic struct net_device *tcf_mirred_dev_dereference(struct tcf_mirred *m)\n{\n\treturn rcu_dereference_protected(m->tcfm_dev,\n\t\t\t\t\t lockdep_is_held(&m->tcf_lock));\n}\n\nstatic void tcf_mirred_release(struct tc_action *a)\n{\n\tstruct tcf_mirred *m = to_mirred(a);\n\tstruct net_device *dev;\n\n\tspin_lock(&mirred_list_lock);\n\tlist_del(&m->tcfm_list);\n\tspin_unlock(&mirred_list_lock);\n\n\t \n\tdev = rcu_dereference_protected(m->tcfm_dev, 1);\n\tnetdev_put(dev, &m->tcfm_dev_tracker);\n}\n\nstatic const struct nla_policy mirred_policy[TCA_MIRRED_MAX + 1] = {\n\t[TCA_MIRRED_PARMS]\t= { .len = sizeof(struct tc_mirred) },\n};\n\nstatic struct tc_action_ops act_mirred_ops;\n\nstatic int tcf_mirred_init(struct net *net, struct nlattr *nla,\n\t\t\t   struct nlattr *est, struct tc_action **a,\n\t\t\t   struct tcf_proto *tp,\n\t\t\t   u32 flags, struct netlink_ext_ack *extack)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_mirred_ops.net_id);\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_MIRRED_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tbool mac_header_xmit = false;\n\tstruct tc_mirred *parm;\n\tstruct tcf_mirred *m;\n\tbool exists = false;\n\tint ret, err;\n\tu32 index;\n\n\tif (!nla) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Mirred requires attributes to be passed\");\n\t\treturn -EINVAL;\n\t}\n\tret = nla_parse_nested_deprecated(tb, TCA_MIRRED_MAX, nla,\n\t\t\t\t\t  mirred_policy, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!tb[TCA_MIRRED_PARMS]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing required mirred parameters\");\n\t\treturn -EINVAL;\n\t}\n\tparm = nla_data(tb[TCA_MIRRED_PARMS]);\n\tindex = parm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0)\n\t\treturn err;\n\texists = err;\n\tif (exists && bind)\n\t\treturn 0;\n\n\tswitch (parm->eaction) {\n\tcase TCA_EGRESS_MIRROR:\n\tcase TCA_EGRESS_REDIR:\n\tcase TCA_INGRESS_REDIR:\n\tcase TCA_INGRESS_MIRROR:\n\t\tbreak;\n\tdefault:\n\t\tif (exists)\n\t\t\ttcf_idr_release(*a, bind);\n\t\telse\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown mirred option\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!exists) {\n\t\tif (!parm->ifindex) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Specified device does not exist\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = tcf_idr_create_from_flags(tn, index, est, a,\n\t\t\t\t\t\t&act_mirred_ops, bind, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ACT_P_CREATED;\n\t} else if (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\ttcf_idr_release(*a, bind);\n\t\treturn -EEXIST;\n\t}\n\n\tm = to_mirred(*a);\n\tif (ret == ACT_P_CREATED)\n\t\tINIT_LIST_HEAD(&m->tcfm_list);\n\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\tspin_lock_bh(&m->tcf_lock);\n\n\tif (parm->ifindex) {\n\t\tstruct net_device *odev, *ndev;\n\n\t\tndev = dev_get_by_index(net, parm->ifindex);\n\t\tif (!ndev) {\n\t\t\tspin_unlock_bh(&m->tcf_lock);\n\t\t\terr = -ENODEV;\n\t\t\tgoto put_chain;\n\t\t}\n\t\tmac_header_xmit = dev_is_mac_header_xmit(ndev);\n\t\todev = rcu_replace_pointer(m->tcfm_dev, ndev,\n\t\t\t\t\t  lockdep_is_held(&m->tcf_lock));\n\t\tnetdev_put(odev, &m->tcfm_dev_tracker);\n\t\tnetdev_tracker_alloc(ndev, &m->tcfm_dev_tracker, GFP_ATOMIC);\n\t\tm->tcfm_mac_header_xmit = mac_header_xmit;\n\t}\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\tm->tcfm_eaction = parm->eaction;\n\tspin_unlock_bh(&m->tcf_lock);\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\n\tif (ret == ACT_P_CREATED) {\n\t\tspin_lock(&mirred_list_lock);\n\t\tlist_add(&m->tcfm_list, &mirred_list);\n\t\tspin_unlock(&mirred_list_lock);\n\t}\n\n\treturn ret;\nput_chain:\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic bool is_mirred_nested(void)\n{\n\treturn unlikely(__this_cpu_read(mirred_nest_level) > 1);\n}\n\nstatic int tcf_mirred_forward(bool want_ingress, struct sk_buff *skb)\n{\n\tint err;\n\n\tif (!want_ingress)\n\t\terr = tcf_dev_queue_xmit(skb, dev_queue_xmit);\n\telse if (is_mirred_nested())\n\t\terr = netif_rx(skb);\n\telse\n\t\terr = netif_receive_skb(skb);\n\n\treturn err;\n}\n\nTC_INDIRECT_SCOPE int tcf_mirred_act(struct sk_buff *skb,\n\t\t\t\t     const struct tc_action *a,\n\t\t\t\t     struct tcf_result *res)\n{\n\tstruct tcf_mirred *m = to_mirred(a);\n\tstruct sk_buff *skb2 = skb;\n\tbool m_mac_header_xmit;\n\tstruct net_device *dev;\n\tunsigned int nest_level;\n\tint retval, err = 0;\n\tbool use_reinsert;\n\tbool want_ingress;\n\tbool is_redirect;\n\tbool expects_nh;\n\tbool at_ingress;\n\tint m_eaction;\n\tint mac_len;\n\tbool at_nh;\n\n\tnest_level = __this_cpu_inc_return(mirred_nest_level);\n\tif (unlikely(nest_level > MIRRED_NEST_LIMIT)) {\n\t\tnet_warn_ratelimited(\"Packet exceeded mirred recursion limit on dev %s\\n\",\n\t\t\t\t     netdev_name(skb->dev));\n\t\t__this_cpu_dec(mirred_nest_level);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\ttcf_lastuse_update(&m->tcf_tm);\n\ttcf_action_update_bstats(&m->common, skb);\n\n\tm_mac_header_xmit = READ_ONCE(m->tcfm_mac_header_xmit);\n\tm_eaction = READ_ONCE(m->tcfm_eaction);\n\tretval = READ_ONCE(m->tcf_action);\n\tdev = rcu_dereference_bh(m->tcfm_dev);\n\tif (unlikely(!dev)) {\n\t\tpr_notice_once(\"tc mirred: target device is gone\\n\");\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!(dev->flags & IFF_UP)) || !netif_carrier_ok(dev)) {\n\t\tnet_notice_ratelimited(\"tc mirred to Houston: device %s is down\\n\",\n\t\t\t\t       dev->name);\n\t\tgoto out;\n\t}\n\n\t \n\tis_redirect = tcf_mirred_is_act_redirect(m_eaction);\n\tat_ingress = skb_at_tc_ingress(skb);\n\tuse_reinsert = at_ingress && is_redirect &&\n\t\t       tcf_mirred_can_reinsert(retval);\n\tif (!use_reinsert) {\n\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb2)\n\t\t\tgoto out;\n\t}\n\n\twant_ingress = tcf_mirred_act_wants_ingress(m_eaction);\n\n\t \n\tnf_reset_ct(skb2);\n\tif (want_ingress && !at_ingress)  \n\t\tskb_dst_drop(skb2);\n\n\texpects_nh = want_ingress || !m_mac_header_xmit;\n\tat_nh = skb->data == skb_network_header(skb);\n\tif (at_nh != expects_nh) {\n\t\tmac_len = skb_at_tc_ingress(skb) ? skb->mac_len :\n\t\t\t  skb_network_offset(skb);\n\t\tif (expects_nh) {\n\t\t\t \n\t\t\tskb_pull_rcsum(skb2, mac_len);\n\t\t} else {\n\t\t\t \n\t\t\tskb_push_rcsum(skb2, mac_len);\n\t\t}\n\t}\n\n\tskb2->skb_iif = skb->dev->ifindex;\n\tskb2->dev = dev;\n\n\t \n\tif (is_redirect) {\n\t\tskb_set_redirected(skb2, skb2->tc_at_ingress);\n\n\t\t \n\t\tif (use_reinsert) {\n\t\t\terr = tcf_mirred_forward(want_ingress, skb);\n\t\t\tif (err)\n\t\t\t\ttcf_action_inc_overlimit_qstats(&m->common);\n\t\t\t__this_cpu_dec(mirred_nest_level);\n\t\t\treturn TC_ACT_CONSUMED;\n\t\t}\n\t}\n\n\terr = tcf_mirred_forward(want_ingress, skb2);\n\tif (err) {\nout:\n\t\ttcf_action_inc_overlimit_qstats(&m->common);\n\t\tif (tcf_mirred_is_act_redirect(m_eaction))\n\t\t\tretval = TC_ACT_SHOT;\n\t}\n\t__this_cpu_dec(mirred_nest_level);\n\n\treturn retval;\n}\n\nstatic void tcf_stats_update(struct tc_action *a, u64 bytes, u64 packets,\n\t\t\t     u64 drops, u64 lastuse, bool hw)\n{\n\tstruct tcf_mirred *m = to_mirred(a);\n\tstruct tcf_t *tm = &m->tcf_tm;\n\n\ttcf_action_update_stats(a, bytes, packets, drops, hw);\n\ttm->lastuse = max_t(u64, tm->lastuse, lastuse);\n}\n\nstatic int tcf_mirred_dump(struct sk_buff *skb, struct tc_action *a, int bind,\n\t\t\t   int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_mirred *m = to_mirred(a);\n\tstruct tc_mirred opt = {\n\t\t.index   = m->tcf_index,\n\t\t.refcnt  = refcount_read(&m->tcf_refcnt) - ref,\n\t\t.bindcnt = atomic_read(&m->tcf_bindcnt) - bind,\n\t};\n\tstruct net_device *dev;\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&m->tcf_lock);\n\topt.action = m->tcf_action;\n\topt.eaction = m->tcfm_eaction;\n\tdev = tcf_mirred_dev_dereference(m);\n\tif (dev)\n\t\topt.ifindex = dev->ifindex;\n\n\tif (nla_put(skb, TCA_MIRRED_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &m->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_MIRRED_TM, sizeof(t), &t, TCA_MIRRED_PAD))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&m->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&m->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic int mirred_device_event(struct notifier_block *unused,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct tcf_mirred *m;\n\n\tASSERT_RTNL();\n\tif (event == NETDEV_UNREGISTER) {\n\t\tspin_lock(&mirred_list_lock);\n\t\tlist_for_each_entry(m, &mirred_list, tcfm_list) {\n\t\t\tspin_lock_bh(&m->tcf_lock);\n\t\t\tif (tcf_mirred_dev_dereference(m) == dev) {\n\t\t\t\tnetdev_put(dev, &m->tcfm_dev_tracker);\n\t\t\t\t \n\t\t\t\tRCU_INIT_POINTER(m->tcfm_dev, NULL);\n\t\t\t}\n\t\t\tspin_unlock_bh(&m->tcf_lock);\n\t\t}\n\t\tspin_unlock(&mirred_list_lock);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block mirred_device_notifier = {\n\t.notifier_call = mirred_device_event,\n};\n\nstatic void tcf_mirred_dev_put(void *priv)\n{\n\tstruct net_device *dev = priv;\n\n\tdev_put(dev);\n}\n\nstatic struct net_device *\ntcf_mirred_get_dev(const struct tc_action *a,\n\t\t   tc_action_priv_destructor *destructor)\n{\n\tstruct tcf_mirred *m = to_mirred(a);\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tdev = rcu_dereference(m->tcfm_dev);\n\tif (dev) {\n\t\tdev_hold(dev);\n\t\t*destructor = tcf_mirred_dev_put;\n\t}\n\trcu_read_unlock();\n\n\treturn dev;\n}\n\nstatic size_t tcf_mirred_get_fill_size(const struct tc_action *act)\n{\n\treturn nla_total_size(sizeof(struct tc_mirred));\n}\n\nstatic void tcf_offload_mirred_get_dev(struct flow_action_entry *entry,\n\t\t\t\t       const struct tc_action *act)\n{\n\tentry->dev = act->ops->get_dev(act, &entry->destructor);\n\tif (!entry->dev)\n\t\treturn;\n\tentry->destructor_priv = entry->dev;\n}\n\nstatic int tcf_mirred_offload_act_setup(struct tc_action *act, void *entry_data,\n\t\t\t\t\tu32 *index_inc, bool bind,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (bind) {\n\t\tstruct flow_action_entry *entry = entry_data;\n\n\t\tif (is_tcf_mirred_egress_redirect(act)) {\n\t\t\tentry->id = FLOW_ACTION_REDIRECT;\n\t\t\ttcf_offload_mirred_get_dev(entry, act);\n\t\t} else if (is_tcf_mirred_egress_mirror(act)) {\n\t\t\tentry->id = FLOW_ACTION_MIRRED;\n\t\t\ttcf_offload_mirred_get_dev(entry, act);\n\t\t} else if (is_tcf_mirred_ingress_redirect(act)) {\n\t\t\tentry->id = FLOW_ACTION_REDIRECT_INGRESS;\n\t\t\ttcf_offload_mirred_get_dev(entry, act);\n\t\t} else if (is_tcf_mirred_ingress_mirror(act)) {\n\t\t\tentry->id = FLOW_ACTION_MIRRED_INGRESS;\n\t\t\ttcf_offload_mirred_get_dev(entry, act);\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported mirred offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t*index_inc = 1;\n\t} else {\n\t\tstruct flow_offload_action *fl_action = entry_data;\n\n\t\tif (is_tcf_mirred_egress_redirect(act))\n\t\t\tfl_action->id = FLOW_ACTION_REDIRECT;\n\t\telse if (is_tcf_mirred_egress_mirror(act))\n\t\t\tfl_action->id = FLOW_ACTION_MIRRED;\n\t\telse if (is_tcf_mirred_ingress_redirect(act))\n\t\t\tfl_action->id = FLOW_ACTION_REDIRECT_INGRESS;\n\t\telse if (is_tcf_mirred_ingress_mirror(act))\n\t\t\tfl_action->id = FLOW_ACTION_MIRRED_INGRESS;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic struct tc_action_ops act_mirred_ops = {\n\t.kind\t\t=\t\"mirred\",\n\t.id\t\t=\tTCA_ID_MIRRED,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.act\t\t=\ttcf_mirred_act,\n\t.stats_update\t=\ttcf_stats_update,\n\t.dump\t\t=\ttcf_mirred_dump,\n\t.cleanup\t=\ttcf_mirred_release,\n\t.init\t\t=\ttcf_mirred_init,\n\t.get_fill_size\t=\ttcf_mirred_get_fill_size,\n\t.offload_act_setup =\ttcf_mirred_offload_act_setup,\n\t.size\t\t=\tsizeof(struct tcf_mirred),\n\t.get_dev\t=\ttcf_mirred_get_dev,\n};\n\nstatic __net_init int mirred_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_mirred_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_mirred_ops);\n}\n\nstatic void __net_exit mirred_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_mirred_ops.net_id);\n}\n\nstatic struct pernet_operations mirred_net_ops = {\n\t.init = mirred_init_net,\n\t.exit_batch = mirred_exit_net,\n\t.id   = &act_mirred_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nMODULE_AUTHOR(\"Jamal Hadi Salim(2002)\");\nMODULE_DESCRIPTION(\"Device Mirror/redirect actions\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init mirred_init_module(void)\n{\n\tint err = register_netdevice_notifier(&mirred_device_notifier);\n\tif (err)\n\t\treturn err;\n\n\tpr_info(\"Mirror/redirect action on\\n\");\n\terr = tcf_register_action(&act_mirred_ops, &mirred_net_ops);\n\tif (err)\n\t\tunregister_netdevice_notifier(&mirred_device_notifier);\n\n\treturn err;\n}\n\nstatic void __exit mirred_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_mirred_ops, &mirred_net_ops);\n\tunregister_netdevice_notifier(&mirred_device_notifier);\n}\n\nmodule_init(mirred_init_module);\nmodule_exit(mirred_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}