{
  "module_name": "em_ipt.c",
  "hash_id": "8f6aaaa5fd1bb44c017138e59ed7583a56e1b1c1f773b6e272e0289fcb3b3b21",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/em_ipt.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/tc_ematch/tc_em_ipt.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <net/pkt_cls.h>\n\nstruct em_ipt_match {\n\tconst struct xt_match *match;\n\tu32 hook;\n\tu8 nfproto;\n\tu8 match_data[] __aligned(8);\n};\n\nstruct em_ipt_xt_match {\n\tchar *match_name;\n\tint (*validate_match_data)(struct nlattr **tb, u8 mrev);\n};\n\nstatic const struct nla_policy em_ipt_policy[TCA_EM_IPT_MAX + 1] = {\n\t[TCA_EM_IPT_MATCH_NAME]\t\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = XT_EXTENSION_MAXNAMELEN },\n\t[TCA_EM_IPT_MATCH_REVISION]\t= { .type = NLA_U8 },\n\t[TCA_EM_IPT_HOOK]\t\t= { .type = NLA_U32 },\n\t[TCA_EM_IPT_NFPROTO]\t\t= { .type = NLA_U8 },\n\t[TCA_EM_IPT_MATCH_DATA]\t\t= { .type = NLA_UNSPEC },\n};\n\nstatic int check_match(struct net *net, struct em_ipt_match *im, int mdata_len)\n{\n\tstruct xt_mtchk_param mtpar = {};\n\tunion {\n\t\tstruct ipt_entry e4;\n\t\tstruct ip6t_entry e6;\n\t} e = {};\n\n\tmtpar.net\t= net;\n\tmtpar.table\t= \"filter\";\n\tmtpar.hook_mask\t= 1 << im->hook;\n\tmtpar.family\t= im->match->family;\n\tmtpar.match\t= im->match;\n\tmtpar.entryinfo = &e;\n\tmtpar.matchinfo\t= (void *)im->match_data;\n\treturn xt_check_match(&mtpar, mdata_len, 0, 0);\n}\n\nstatic int policy_validate_match_data(struct nlattr **tb, u8 mrev)\n{\n\tif (mrev != 0) {\n\t\tpr_err(\"only policy match revision 0 supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla_get_u32(tb[TCA_EM_IPT_HOOK]) != NF_INET_PRE_ROUTING) {\n\t\tpr_err(\"policy can only be matched on NF_INET_PRE_ROUTING\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int addrtype_validate_match_data(struct nlattr **tb, u8 mrev)\n{\n\tif (mrev != 1) {\n\t\tpr_err(\"only addrtype match revision 1 supported\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct em_ipt_xt_match em_ipt_xt_matches[] = {\n\t{\n\t\t.match_name = \"policy\",\n\t\t.validate_match_data = policy_validate_match_data\n\t},\n\t{\n\t\t.match_name = \"addrtype\",\n\t\t.validate_match_data = addrtype_validate_match_data\n\t},\n\t{}\n};\n\nstatic struct xt_match *get_xt_match(struct nlattr **tb)\n{\n\tconst struct em_ipt_xt_match *m;\n\tstruct nlattr *mname_attr;\n\tu8 nfproto, mrev = 0;\n\tint ret;\n\n\tmname_attr = tb[TCA_EM_IPT_MATCH_NAME];\n\tfor (m = em_ipt_xt_matches; m->match_name; m++) {\n\t\tif (!nla_strcmp(mname_attr, m->match_name))\n\t\t\tbreak;\n\t}\n\n\tif (!m->match_name) {\n\t\tpr_err(\"Unsupported xt match\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (tb[TCA_EM_IPT_MATCH_REVISION])\n\t\tmrev = nla_get_u8(tb[TCA_EM_IPT_MATCH_REVISION]);\n\n\tret = m->validate_match_data(tb, mrev);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tnfproto = nla_get_u8(tb[TCA_EM_IPT_NFPROTO]);\n\treturn xt_request_find_match(nfproto, m->match_name, mrev);\n}\n\nstatic int em_ipt_change(struct net *net, void *data, int data_len,\n\t\t\t struct tcf_ematch *em)\n{\n\tstruct nlattr *tb[TCA_EM_IPT_MAX + 1];\n\tstruct em_ipt_match *im = NULL;\n\tstruct xt_match *match;\n\tint mdata_len, ret;\n\tu8 nfproto;\n\n\tret = nla_parse_deprecated(tb, TCA_EM_IPT_MAX, data, data_len,\n\t\t\t\t   em_ipt_policy, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!tb[TCA_EM_IPT_HOOK] || !tb[TCA_EM_IPT_MATCH_NAME] ||\n\t    !tb[TCA_EM_IPT_MATCH_DATA] || !tb[TCA_EM_IPT_NFPROTO])\n\t\treturn -EINVAL;\n\n\tnfproto = nla_get_u8(tb[TCA_EM_IPT_NFPROTO]);\n\tswitch (nfproto) {\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmatch = get_xt_match(tb);\n\tif (IS_ERR(match)) {\n\t\tpr_err(\"unable to load match\\n\");\n\t\treturn PTR_ERR(match);\n\t}\n\n\tmdata_len = XT_ALIGN(nla_len(tb[TCA_EM_IPT_MATCH_DATA]));\n\tim = kzalloc(sizeof(*im) + mdata_len, GFP_KERNEL);\n\tif (!im) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tim->match = match;\n\tim->hook = nla_get_u32(tb[TCA_EM_IPT_HOOK]);\n\tim->nfproto = nfproto;\n\tnla_memcpy(im->match_data, tb[TCA_EM_IPT_MATCH_DATA], mdata_len);\n\n\tret = check_match(net, im, mdata_len);\n\tif (ret)\n\t\tgoto err;\n\n\tem->datalen = sizeof(*im) + mdata_len;\n\tem->data = (unsigned long)im;\n\treturn 0;\n\nerr:\n\tkfree(im);\n\tmodule_put(match->me);\n\treturn ret;\n}\n\nstatic void em_ipt_destroy(struct tcf_ematch *em)\n{\n\tstruct em_ipt_match *im = (void *)em->data;\n\n\tif (!im)\n\t\treturn;\n\n\tif (im->match->destroy) {\n\t\tstruct xt_mtdtor_param par = {\n\t\t\t.net = em->net,\n\t\t\t.match = im->match,\n\t\t\t.matchinfo = im->match_data,\n\t\t\t.family = im->match->family\n\t\t};\n\t\tim->match->destroy(&par);\n\t}\n\tmodule_put(im->match->me);\n\tkfree(im);\n}\n\nstatic int em_ipt_match(struct sk_buff *skb, struct tcf_ematch *em,\n\t\t\tstruct tcf_pkt_info *info)\n{\n\tconst struct em_ipt_match *im = (const void *)em->data;\n\tstruct xt_action_param acpar = {};\n\tstruct net_device *indev = NULL;\n\tu8 nfproto = im->match->family;\n\tstruct nf_hook_state state;\n\tint ret;\n\n\tswitch (skb_protocol(skb, true)) {\n\tcase htons(ETH_P_IP):\n\t\tif (!pskb_network_may_pull(skb, sizeof(struct iphdr)))\n\t\t\treturn 0;\n\t\tif (nfproto == NFPROTO_UNSPEC)\n\t\t\tnfproto = NFPROTO_IPV4;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tif (!pskb_network_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\t\treturn 0;\n\t\tif (nfproto == NFPROTO_UNSPEC)\n\t\t\tnfproto = NFPROTO_IPV6;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\trcu_read_lock();\n\n\tif (skb->skb_iif)\n\t\tindev = dev_get_by_index_rcu(em->net, skb->skb_iif);\n\n\tnf_hook_state_init(&state, im->hook, nfproto,\n\t\t\t   indev ?: skb->dev, skb->dev, NULL, em->net, NULL);\n\n\tacpar.match = im->match;\n\tacpar.matchinfo = im->match_data;\n\tacpar.state = &state;\n\n\tret = im->match->match(skb, &acpar);\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int em_ipt_dump(struct sk_buff *skb, struct tcf_ematch *em)\n{\n\tstruct em_ipt_match *im = (void *)em->data;\n\n\tif (nla_put_string(skb, TCA_EM_IPT_MATCH_NAME, im->match->name) < 0)\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u32(skb, TCA_EM_IPT_HOOK, im->hook) < 0)\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u8(skb, TCA_EM_IPT_MATCH_REVISION, im->match->revision) < 0)\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u8(skb, TCA_EM_IPT_NFPROTO, im->nfproto) < 0)\n\t\treturn -EMSGSIZE;\n\tif (nla_put(skb, TCA_EM_IPT_MATCH_DATA,\n\t\t    im->match->usersize ?: im->match->matchsize,\n\t\t    im->match_data) < 0)\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic struct tcf_ematch_ops em_ipt_ops = {\n\t.kind\t  = TCF_EM_IPT,\n\t.change\t  = em_ipt_change,\n\t.destroy  = em_ipt_destroy,\n\t.match\t  = em_ipt_match,\n\t.dump\t  = em_ipt_dump,\n\t.owner\t  = THIS_MODULE,\n\t.link\t  = LIST_HEAD_INIT(em_ipt_ops.link)\n};\n\nstatic int __init init_em_ipt(void)\n{\n\treturn tcf_em_register(&em_ipt_ops);\n}\n\nstatic void __exit exit_em_ipt(void)\n{\n\ttcf_em_unregister(&em_ipt_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Eyal Birger <eyal.birger@gmail.com>\");\nMODULE_DESCRIPTION(\"TC extended match for IPtables matches\");\n\nmodule_init(init_em_ipt);\nmodule_exit(exit_em_ipt);\n\nMODULE_ALIAS_TCF_EMATCH(TCF_EM_IPT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}