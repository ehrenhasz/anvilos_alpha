{
  "module_name": "sch_qfq.c",
  "hash_id": "3c0101433deb34d2ba376993c025ebfe78c015a8b43c69ee81362b47aea697b2",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/sch_qfq.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/pkt_sched.h>\n#include <net/sch_generic.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n\n\n \n\n \n\n \n#define QFQ_MAX_SLOTS\t32\n\n \n#define QFQ_MAX_INDEX\t\t24\n#define QFQ_MAX_WSHIFT\t\t10\n\n#define\tQFQ_MAX_WEIGHT\t\t(1<<QFQ_MAX_WSHIFT)  \n#define QFQ_MAX_WSUM\t\t(64*QFQ_MAX_WEIGHT)\n\n#define FRAC_BITS\t\t30\t \n#define ONE_FP\t\t\t(1UL << FRAC_BITS)\n\n#define QFQ_MTU_SHIFT\t\t16\t \n#define QFQ_MIN_LMAX\t\t512\t \n#define QFQ_MAX_LMAX\t\t(1UL << QFQ_MTU_SHIFT)\n\n#define QFQ_MAX_AGG_CLASSES\t8  \n\n \nenum qfq_state { ER, IR, EB, IB, QFQ_MAX_STATE };\n\nstruct qfq_group;\n\nstruct qfq_aggregate;\n\nstruct qfq_class {\n\tstruct Qdisc_class_common common;\n\n\tstruct gnet_stats_basic_sync bstats;\n\tstruct gnet_stats_queue qstats;\n\tstruct net_rate_estimator __rcu *rate_est;\n\tstruct Qdisc *qdisc;\n\tstruct list_head alist;\t\t \n\tstruct qfq_aggregate *agg;\t \n\tint deficit;\t\t\t \n};\n\nstruct qfq_aggregate {\n\tstruct hlist_node next;\t \n\tu64 S, F;\t\t \n\n\t \n\tstruct qfq_group *grp;\n\n\t \n\tu32\tclass_weight;  \n\t \n\tint\tlmax;\n\n\tu32\tinv_w;\t     \n\tu32\tbudgetmax;   \n\tu32\tinitial_budget, budget;      \n\n\tint\t\t  num_classes;\t \n\tstruct list_head  active;\t \n\n\tstruct hlist_node nonfull_next;\t \n};\n\nstruct qfq_group {\n\tu64 S, F;\t\t\t \n\tunsigned int slot_shift;\t \n\tunsigned int index;\t\t \n\tunsigned int front;\t\t \n\tunsigned long full_slots;\t \n\n\t \n\tstruct hlist_head slots[QFQ_MAX_SLOTS];\n};\n\nstruct qfq_sched {\n\tstruct tcf_proto __rcu *filter_list;\n\tstruct tcf_block\t*block;\n\tstruct Qdisc_class_hash clhash;\n\n\tu64\t\t\toldV, V;\t \n\tstruct qfq_aggregate\t*in_serv_agg;    \n\tu32\t\t\twsum;\t\t \n\tu32\t\t\tiwsum;\t\t \n\n\tunsigned long bitmaps[QFQ_MAX_STATE];\t     \n\tstruct qfq_group groups[QFQ_MAX_INDEX + 1];  \n\tu32 min_slot_shift;\t \n\n\tu32 max_agg_classes;\t\t \n\tstruct hlist_head nonfull_aggs;  \n};\n\n \nenum update_reason {enqueue, requeue};\n\nstatic struct qfq_class *qfq_find_class(struct Qdisc *sch, u32 classid)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct Qdisc_class_common *clc;\n\n\tclc = qdisc_class_find(&q->clhash, classid);\n\tif (clc == NULL)\n\t\treturn NULL;\n\treturn container_of(clc, struct qfq_class, common);\n}\n\nstatic struct netlink_range_validation lmax_range = {\n\t.min = QFQ_MIN_LMAX,\n\t.max = QFQ_MAX_LMAX,\n};\n\nstatic const struct nla_policy qfq_policy[TCA_QFQ_MAX + 1] = {\n\t[TCA_QFQ_WEIGHT] = NLA_POLICY_RANGE(NLA_U32, 1, QFQ_MAX_WEIGHT),\n\t[TCA_QFQ_LMAX] = NLA_POLICY_FULL_RANGE(NLA_U32, &lmax_range),\n};\n\n \nstatic int qfq_calc_index(u32 inv_w, unsigned int maxlen, u32 min_slot_shift)\n{\n\tu64 slot_size = (u64)maxlen * inv_w;\n\tunsigned long size_map;\n\tint index = 0;\n\n\tsize_map = slot_size >> min_slot_shift;\n\tif (!size_map)\n\t\tgoto out;\n\n\tindex = __fls(size_map) + 1;\t \n\tindex -= !(slot_size - (1ULL << (index + min_slot_shift - 1)));\n\n\tif (index < 0)\n\t\tindex = 0;\nout:\n\tpr_debug(\"qfq calc_index: W = %lu, L = %u, I = %d\\n\",\n\t\t (unsigned long) ONE_FP/inv_w, maxlen, index);\n\n\treturn index;\n}\n\nstatic void qfq_deactivate_agg(struct qfq_sched *, struct qfq_aggregate *);\nstatic void qfq_activate_agg(struct qfq_sched *, struct qfq_aggregate *,\n\t\t\t     enum update_reason);\n\nstatic void qfq_init_agg(struct qfq_sched *q, struct qfq_aggregate *agg,\n\t\t\t u32 lmax, u32 weight)\n{\n\tINIT_LIST_HEAD(&agg->active);\n\thlist_add_head(&agg->nonfull_next, &q->nonfull_aggs);\n\n\tagg->lmax = lmax;\n\tagg->class_weight = weight;\n}\n\nstatic struct qfq_aggregate *qfq_find_agg(struct qfq_sched *q,\n\t\t\t\t\t  u32 lmax, u32 weight)\n{\n\tstruct qfq_aggregate *agg;\n\n\thlist_for_each_entry(agg, &q->nonfull_aggs, nonfull_next)\n\t\tif (agg->lmax == lmax && agg->class_weight == weight)\n\t\t\treturn agg;\n\n\treturn NULL;\n}\n\n\n \nstatic void qfq_update_agg(struct qfq_sched *q, struct qfq_aggregate *agg,\n\t\t\t   int new_num_classes)\n{\n\tu32 new_agg_weight;\n\n\tif (new_num_classes == q->max_agg_classes)\n\t\thlist_del_init(&agg->nonfull_next);\n\n\tif (agg->num_classes > new_num_classes &&\n\t    new_num_classes == q->max_agg_classes - 1)  \n\t\thlist_add_head(&agg->nonfull_next, &q->nonfull_aggs);\n\n\t \n\tagg->budgetmax = new_num_classes * agg->lmax;\n\tnew_agg_weight = agg->class_weight * new_num_classes;\n\tagg->inv_w = ONE_FP/new_agg_weight;\n\n\tif (agg->grp == NULL) {\n\t\tint i = qfq_calc_index(agg->inv_w, agg->budgetmax,\n\t\t\t\t       q->min_slot_shift);\n\t\tagg->grp = &q->groups[i];\n\t}\n\n\tq->wsum +=\n\t\t(int) agg->class_weight * (new_num_classes - agg->num_classes);\n\tq->iwsum = ONE_FP / q->wsum;\n\n\tagg->num_classes = new_num_classes;\n}\n\n \nstatic void qfq_add_to_agg(struct qfq_sched *q,\n\t\t\t   struct qfq_aggregate *agg,\n\t\t\t   struct qfq_class *cl)\n{\n\tcl->agg = agg;\n\n\tqfq_update_agg(q, agg, agg->num_classes+1);\n\tif (cl->qdisc->q.qlen > 0) {  \n\t\tlist_add_tail(&cl->alist, &agg->active);\n\t\tif (list_first_entry(&agg->active, struct qfq_class, alist) ==\n\t\t    cl && q->in_serv_agg != agg)  \n\t\t\tqfq_activate_agg(q, agg, enqueue);  \n\t}\n}\n\nstatic struct qfq_aggregate *qfq_choose_next_agg(struct qfq_sched *);\n\nstatic void qfq_destroy_agg(struct qfq_sched *q, struct qfq_aggregate *agg)\n{\n\thlist_del_init(&agg->nonfull_next);\n\tq->wsum -= agg->class_weight;\n\tif (q->wsum != 0)\n\t\tq->iwsum = ONE_FP / q->wsum;\n\n\tif (q->in_serv_agg == agg)\n\t\tq->in_serv_agg = qfq_choose_next_agg(q);\n\tkfree(agg);\n}\n\n \nstatic void qfq_deactivate_class(struct qfq_sched *q, struct qfq_class *cl)\n{\n\tstruct qfq_aggregate *agg = cl->agg;\n\n\n\tlist_del(&cl->alist);  \n\tif (list_empty(&agg->active))  \n\t\tqfq_deactivate_agg(q, agg);\n}\n\n \nstatic void qfq_rm_from_agg(struct qfq_sched *q, struct qfq_class *cl)\n{\n\tstruct qfq_aggregate *agg = cl->agg;\n\n\tcl->agg = NULL;\n\tif (agg->num_classes == 1) {  \n\t\tqfq_destroy_agg(q, agg);\n\t\treturn;\n\t}\n\tqfq_update_agg(q, agg, agg->num_classes-1);\n}\n\n \nstatic void qfq_deact_rm_from_agg(struct qfq_sched *q, struct qfq_class *cl)\n{\n\tif (cl->qdisc->q.qlen > 0)  \n\t\tqfq_deactivate_class(q, cl);\n\n\tqfq_rm_from_agg(q, cl);\n}\n\n \nstatic int qfq_change_agg(struct Qdisc *sch, struct qfq_class *cl, u32 weight,\n\t\t\t   u32 lmax)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_aggregate *new_agg;\n\n\t \n\tif (lmax > QFQ_MAX_LMAX)\n\t\treturn -EINVAL;\n\n\tnew_agg = qfq_find_agg(q, lmax, weight);\n\tif (new_agg == NULL) {  \n\t\tnew_agg = kzalloc(sizeof(*new_agg), GFP_ATOMIC);\n\t\tif (new_agg == NULL)\n\t\t\treturn -ENOBUFS;\n\t\tqfq_init_agg(q, new_agg, lmax, weight);\n\t}\n\tqfq_deact_rm_from_agg(q, cl);\n\tqfq_add_to_agg(q, new_agg, cl);\n\n\treturn 0;\n}\n\nstatic int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,\n\t\t\t    struct nlattr **tca, unsigned long *arg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_class *cl = (struct qfq_class *)*arg;\n\tbool existing = false;\n\tstruct nlattr *tb[TCA_QFQ_MAX + 1];\n\tstruct qfq_aggregate *new_agg = NULL;\n\tu32 weight, lmax, inv_w;\n\tint err;\n\tint delta_w;\n\n\tif (NL_REQ_ATTR_CHECK(extack, NULL, tca, TCA_OPTIONS)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"missing options\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, TCA_QFQ_MAX, tca[TCA_OPTIONS],\n\t\t\t\t\t  qfq_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_QFQ_WEIGHT])\n\t\tweight = nla_get_u32(tb[TCA_QFQ_WEIGHT]);\n\telse\n\t\tweight = 1;\n\n\tif (tb[TCA_QFQ_LMAX]) {\n\t\tlmax = nla_get_u32(tb[TCA_QFQ_LMAX]);\n\t} else {\n\t\t \n\t\tlmax = psched_mtu(qdisc_dev(sch));\n\t\tif (lmax < QFQ_MIN_LMAX || lmax > QFQ_MAX_LMAX) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"MTU size out of bounds for qfq\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tinv_w = ONE_FP / weight;\n\tweight = ONE_FP / inv_w;\n\n\tif (cl != NULL &&\n\t    lmax == cl->agg->lmax &&\n\t    weight == cl->agg->class_weight)\n\t\treturn 0;  \n\n\tdelta_w = weight - (cl ? cl->agg->class_weight : 0);\n\n\tif (q->wsum + delta_w > QFQ_MAX_WSUM) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t       \"total weight out of range (%d + %u)\\n\",\n\t\t\t\t       delta_w, q->wsum);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cl != NULL) {  \n\t\tif (tca[TCA_RATE]) {\n\t\t\terr = gen_replace_estimator(&cl->bstats, NULL,\n\t\t\t\t\t\t    &cl->rate_est,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    true,\n\t\t\t\t\t\t    tca[TCA_RATE]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\texisting = true;\n\t\tgoto set_change_agg;\n\t}\n\n\t \n\tcl = kzalloc(sizeof(struct qfq_class), GFP_KERNEL);\n\tif (cl == NULL)\n\t\treturn -ENOBUFS;\n\n\tgnet_stats_basic_sync_init(&cl->bstats);\n\tcl->common.classid = classid;\n\tcl->deficit = lmax;\n\n\tcl->qdisc = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\n\t\t\t\t      classid, NULL);\n\tif (cl->qdisc == NULL)\n\t\tcl->qdisc = &noop_qdisc;\n\n\tif (tca[TCA_RATE]) {\n\t\terr = gen_new_estimator(&cl->bstats, NULL,\n\t\t\t\t\t&cl->rate_est,\n\t\t\t\t\tNULL,\n\t\t\t\t\ttrue,\n\t\t\t\t\ttca[TCA_RATE]);\n\t\tif (err)\n\t\t\tgoto destroy_class;\n\t}\n\n\tif (cl->qdisc != &noop_qdisc)\n\t\tqdisc_hash_add(cl->qdisc, true);\n\nset_change_agg:\n\tsch_tree_lock(sch);\n\tnew_agg = qfq_find_agg(q, lmax, weight);\n\tif (new_agg == NULL) {  \n\t\tsch_tree_unlock(sch);\n\t\tnew_agg = kzalloc(sizeof(*new_agg), GFP_KERNEL);\n\t\tif (new_agg == NULL) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgen_kill_estimator(&cl->rate_est);\n\t\t\tgoto destroy_class;\n\t\t}\n\t\tsch_tree_lock(sch);\n\t\tqfq_init_agg(q, new_agg, lmax, weight);\n\t}\n\tif (existing)\n\t\tqfq_deact_rm_from_agg(q, cl);\n\telse\n\t\tqdisc_class_hash_insert(&q->clhash, &cl->common);\n\tqfq_add_to_agg(q, new_agg, cl);\n\tsch_tree_unlock(sch);\n\tqdisc_class_hash_grow(sch, &q->clhash);\n\n\t*arg = (unsigned long)cl;\n\treturn 0;\n\ndestroy_class:\n\tqdisc_put(cl->qdisc);\n\tkfree(cl);\n\treturn err;\n}\n\nstatic void qfq_destroy_class(struct Qdisc *sch, struct qfq_class *cl)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\n\tqfq_rm_from_agg(q, cl);\n\tgen_kill_estimator(&cl->rate_est);\n\tqdisc_put(cl->qdisc);\n\tkfree(cl);\n}\n\nstatic int qfq_delete_class(struct Qdisc *sch, unsigned long arg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_class *cl = (struct qfq_class *)arg;\n\n\tif (qdisc_class_in_use(&cl->common)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"QFQ class in use\");\n\t\treturn -EBUSY;\n\t}\n\n\tsch_tree_lock(sch);\n\n\tqdisc_purge_queue(cl->qdisc);\n\tqdisc_class_hash_remove(&q->clhash, &cl->common);\n\n\tsch_tree_unlock(sch);\n\n\tqfq_destroy_class(sch, cl);\n\treturn 0;\n}\n\nstatic unsigned long qfq_search_class(struct Qdisc *sch, u32 classid)\n{\n\treturn (unsigned long)qfq_find_class(sch, classid);\n}\n\nstatic struct tcf_block *qfq_tcf_block(struct Qdisc *sch, unsigned long cl,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\n\tif (cl)\n\t\treturn NULL;\n\n\treturn q->block;\n}\n\nstatic unsigned long qfq_bind_tcf(struct Qdisc *sch, unsigned long parent,\n\t\t\t\t  u32 classid)\n{\n\tstruct qfq_class *cl = qfq_find_class(sch, classid);\n\n\tif (cl)\n\t\tqdisc_class_get(&cl->common);\n\n\treturn (unsigned long)cl;\n}\n\nstatic void qfq_unbind_tcf(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct qfq_class *cl = (struct qfq_class *)arg;\n\n\tqdisc_class_put(&cl->common);\n}\n\nstatic int qfq_graft_class(struct Qdisc *sch, unsigned long arg,\n\t\t\t   struct Qdisc *new, struct Qdisc **old,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct qfq_class *cl = (struct qfq_class *)arg;\n\n\tif (new == NULL) {\n\t\tnew = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\n\t\t\t\t\tcl->common.classid, NULL);\n\t\tif (new == NULL)\n\t\t\tnew = &noop_qdisc;\n\t}\n\n\t*old = qdisc_replace(sch, new, &cl->qdisc);\n\treturn 0;\n}\n\nstatic struct Qdisc *qfq_class_leaf(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct qfq_class *cl = (struct qfq_class *)arg;\n\n\treturn cl->qdisc;\n}\n\nstatic int qfq_dump_class(struct Qdisc *sch, unsigned long arg,\n\t\t\t  struct sk_buff *skb, struct tcmsg *tcm)\n{\n\tstruct qfq_class *cl = (struct qfq_class *)arg;\n\tstruct nlattr *nest;\n\n\ttcm->tcm_parent\t= TC_H_ROOT;\n\ttcm->tcm_handle\t= cl->common.classid;\n\ttcm->tcm_info\t= cl->qdisc->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, TCA_QFQ_WEIGHT, cl->agg->class_weight) ||\n\t    nla_put_u32(skb, TCA_QFQ_LMAX, cl->agg->lmax))\n\t\tgoto nla_put_failure;\n\treturn nla_nest_end(skb, nest);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int qfq_dump_class_stats(struct Qdisc *sch, unsigned long arg,\n\t\t\t\tstruct gnet_dump *d)\n{\n\tstruct qfq_class *cl = (struct qfq_class *)arg;\n\tstruct tc_qfq_stats xstats;\n\n\tmemset(&xstats, 0, sizeof(xstats));\n\n\txstats.weight = cl->agg->class_weight;\n\txstats.lmax = cl->agg->lmax;\n\n\tif (gnet_stats_copy_basic(d, NULL, &cl->bstats, true) < 0 ||\n\t    gnet_stats_copy_rate_est(d, &cl->rate_est) < 0 ||\n\t    qdisc_qstats_copy(d, cl->qdisc) < 0)\n\t\treturn -1;\n\n\treturn gnet_stats_copy_app(d, &xstats, sizeof(xstats));\n}\n\nstatic void qfq_walk(struct Qdisc *sch, struct qdisc_walker *arg)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_class *cl;\n\tunsigned int i;\n\n\tif (arg->stop)\n\t\treturn;\n\n\tfor (i = 0; i < q->clhash.hashsize; i++) {\n\t\thlist_for_each_entry(cl, &q->clhash.hash[i], common.hnode) {\n\t\t\tif (!tc_qdisc_stats_dump(sch, (unsigned long)cl, arg))\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic struct qfq_class *qfq_classify(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t\t      int *qerr)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_class *cl;\n\tstruct tcf_result res;\n\tstruct tcf_proto *fl;\n\tint result;\n\n\tif (TC_H_MAJ(skb->priority ^ sch->handle) == 0) {\n\t\tpr_debug(\"qfq_classify: found %d\\n\", skb->priority);\n\t\tcl = qfq_find_class(sch, skb->priority);\n\t\tif (cl != NULL)\n\t\t\treturn cl;\n\t}\n\n\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\tfl = rcu_dereference_bh(q->filter_list);\n\tresult = tcf_classify(skb, NULL, fl, &res, false);\n\tif (result >= 0) {\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\tfallthrough;\n\t\tcase TC_ACT_SHOT:\n\t\t\treturn NULL;\n\t\t}\n#endif\n\t\tcl = (struct qfq_class *)res.class;\n\t\tif (cl == NULL)\n\t\t\tcl = qfq_find_class(sch, res.classid);\n\t\treturn cl;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline int qfq_gt(u64 a, u64 b)\n{\n\treturn (s64)(a - b) > 0;\n}\n\n \nstatic inline u64 qfq_round_down(u64 ts, unsigned int shift)\n{\n\treturn ts & ~((1ULL << shift) - 1);\n}\n\n \nstatic inline struct qfq_group *qfq_ffs(struct qfq_sched *q,\n\t\t\t\t\tunsigned long bitmap)\n{\n\tint index = __ffs(bitmap);\n\treturn &q->groups[index];\n}\n \nstatic inline unsigned long mask_from(unsigned long bitmap, int from)\n{\n\treturn bitmap & ~((1UL << from) - 1);\n}\n\n \nstatic int qfq_calc_state(struct qfq_sched *q, const struct qfq_group *grp)\n{\n\t \n\tunsigned int state = qfq_gt(grp->S, q->V);\n\tunsigned long mask = mask_from(q->bitmaps[ER], grp->index);\n\tstruct qfq_group *next;\n\n\tif (mask) {\n\t\tnext = qfq_ffs(q, mask);\n\t\tif (qfq_gt(grp->F, next->F))\n\t\t\tstate |= EB;\n\t}\n\n\treturn state;\n}\n\n\n \nstatic inline void qfq_move_groups(struct qfq_sched *q, unsigned long mask,\n\t\t\t\t   int src, int dst)\n{\n\tq->bitmaps[dst] |= q->bitmaps[src] & mask;\n\tq->bitmaps[src] &= ~mask;\n}\n\nstatic void qfq_unblock_groups(struct qfq_sched *q, int index, u64 old_F)\n{\n\tunsigned long mask = mask_from(q->bitmaps[ER], index + 1);\n\tstruct qfq_group *next;\n\n\tif (mask) {\n\t\tnext = qfq_ffs(q, mask);\n\t\tif (!qfq_gt(next->F, old_F))\n\t\t\treturn;\n\t}\n\n\tmask = (1UL << index) - 1;\n\tqfq_move_groups(q, mask, EB, ER);\n\tqfq_move_groups(q, mask, IB, IR);\n}\n\n \nstatic void qfq_make_eligible(struct qfq_sched *q)\n{\n\tunsigned long vslot = q->V >> q->min_slot_shift;\n\tunsigned long old_vslot = q->oldV >> q->min_slot_shift;\n\n\tif (vslot != old_vslot) {\n\t\tunsigned long mask;\n\t\tint last_flip_pos = fls(vslot ^ old_vslot);\n\n\t\tif (last_flip_pos > 31)  \n\t\t\tmask = ~0UL;     \n\t\telse\n\t\t\tmask = (1UL << last_flip_pos) - 1;\n\n\t\tqfq_move_groups(q, mask, IR, ER);\n\t\tqfq_move_groups(q, mask, IB, EB);\n\t}\n}\n\n \nstatic void qfq_slot_insert(struct qfq_group *grp, struct qfq_aggregate *agg,\n\t\t\t    u64 roundedS)\n{\n\tu64 slot = (roundedS - grp->S) >> grp->slot_shift;\n\tunsigned int i;  \n\n\tif (unlikely(slot > QFQ_MAX_SLOTS - 2)) {\n\t\tu64 deltaS = roundedS - grp->S -\n\t\t\t((u64)(QFQ_MAX_SLOTS - 2)<<grp->slot_shift);\n\t\tagg->S -= deltaS;\n\t\tagg->F -= deltaS;\n\t\tslot = QFQ_MAX_SLOTS - 2;\n\t}\n\n\ti = (grp->front + slot) % QFQ_MAX_SLOTS;\n\n\thlist_add_head(&agg->next, &grp->slots[i]);\n\t__set_bit(slot, &grp->full_slots);\n}\n\n \nstatic struct qfq_aggregate *qfq_slot_head(struct qfq_group *grp)\n{\n\treturn hlist_entry(grp->slots[grp->front].first,\n\t\t\t   struct qfq_aggregate, next);\n}\n\n \nstatic void qfq_front_slot_remove(struct qfq_group *grp)\n{\n\tstruct qfq_aggregate *agg = qfq_slot_head(grp);\n\n\tBUG_ON(!agg);\n\thlist_del(&agg->next);\n\tif (hlist_empty(&grp->slots[grp->front]))\n\t\t__clear_bit(0, &grp->full_slots);\n}\n\n \nstatic struct qfq_aggregate *qfq_slot_scan(struct qfq_group *grp)\n{\n\tunsigned int i;\n\n\tpr_debug(\"qfq slot_scan: grp %u full %#lx\\n\",\n\t\t grp->index, grp->full_slots);\n\n\tif (grp->full_slots == 0)\n\t\treturn NULL;\n\n\ti = __ffs(grp->full_slots);   \n\tif (i > 0) {\n\t\tgrp->front = (grp->front + i) % QFQ_MAX_SLOTS;\n\t\tgrp->full_slots >>= i;\n\t}\n\n\treturn qfq_slot_head(grp);\n}\n\n \nstatic void qfq_slot_rotate(struct qfq_group *grp, u64 roundedS)\n{\n\tunsigned int i = (grp->S - roundedS) >> grp->slot_shift;\n\n\tgrp->full_slots <<= i;\n\tgrp->front = (grp->front - i) % QFQ_MAX_SLOTS;\n}\n\nstatic void qfq_update_eligible(struct qfq_sched *q)\n{\n\tstruct qfq_group *grp;\n\tunsigned long ineligible;\n\n\tineligible = q->bitmaps[IR] | q->bitmaps[IB];\n\tif (ineligible) {\n\t\tif (!q->bitmaps[ER]) {\n\t\t\tgrp = qfq_ffs(q, ineligible);\n\t\t\tif (qfq_gt(grp->S, q->V))\n\t\t\t\tq->V = grp->S;\n\t\t}\n\t\tqfq_make_eligible(q);\n\t}\n}\n\n \nstatic struct sk_buff *agg_dequeue(struct qfq_aggregate *agg,\n\t\t\t\t   struct qfq_class *cl, unsigned int len)\n{\n\tstruct sk_buff *skb = qdisc_dequeue_peeked(cl->qdisc);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tcl->deficit -= (int) len;\n\n\tif (cl->qdisc->q.qlen == 0)  \n\t\tlist_del(&cl->alist);\n\telse if (cl->deficit < qdisc_pkt_len(cl->qdisc->ops->peek(cl->qdisc))) {\n\t\tcl->deficit += agg->lmax;\n\t\tlist_move_tail(&cl->alist, &agg->active);\n\t}\n\n\treturn skb;\n}\n\nstatic inline struct sk_buff *qfq_peek_skb(struct qfq_aggregate *agg,\n\t\t\t\t\t   struct qfq_class **cl,\n\t\t\t\t\t   unsigned int *len)\n{\n\tstruct sk_buff *skb;\n\n\t*cl = list_first_entry(&agg->active, struct qfq_class, alist);\n\tskb = (*cl)->qdisc->ops->peek((*cl)->qdisc);\n\tif (skb == NULL)\n\t\tWARN_ONCE(1, \"qfq_dequeue: non-workconserving leaf\\n\");\n\telse\n\t\t*len = qdisc_pkt_len(skb);\n\n\treturn skb;\n}\n\n \nstatic inline void charge_actual_service(struct qfq_aggregate *agg)\n{\n\t \n\tu32 service_received = min(agg->budgetmax,\n\t\t\t\t   agg->initial_budget - agg->budget);\n\n\tagg->F = agg->S + (u64)service_received * agg->inv_w;\n}\n\n \nstatic void qfq_update_start(struct qfq_sched *q, struct qfq_aggregate *agg)\n{\n\tunsigned long mask;\n\tu64 limit, roundedF;\n\tint slot_shift = agg->grp->slot_shift;\n\n\troundedF = qfq_round_down(agg->F, slot_shift);\n\tlimit = qfq_round_down(q->V, slot_shift) + (1ULL << slot_shift);\n\n\tif (!qfq_gt(agg->F, q->V) || qfq_gt(roundedF, limit)) {\n\t\t \n\t\tmask = mask_from(q->bitmaps[ER], agg->grp->index);\n\t\tif (mask) {\n\t\t\tstruct qfq_group *next = qfq_ffs(q, mask);\n\t\t\tif (qfq_gt(roundedF, next->F)) {\n\t\t\t\tif (qfq_gt(limit, next->F))\n\t\t\t\t\tagg->S = next->F;\n\t\t\t\telse  \n\t\t\t\t\tagg->S = limit;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tagg->S = q->V;\n\t} else   \n\t\tagg->S = agg->F;\n}\n\n \nstatic inline void\nqfq_update_agg_ts(struct qfq_sched *q,\n\t\t    struct qfq_aggregate *agg, enum update_reason reason)\n{\n\tif (reason != requeue)\n\t\tqfq_update_start(q, agg);\n\telse  \n\t\tagg->S = agg->F;\n\n\tagg->F = agg->S + (u64)agg->budgetmax * agg->inv_w;\n}\n\nstatic void qfq_schedule_agg(struct qfq_sched *q, struct qfq_aggregate *agg);\n\nstatic struct sk_buff *qfq_dequeue(struct Qdisc *sch)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_aggregate *in_serv_agg = q->in_serv_agg;\n\tstruct qfq_class *cl;\n\tstruct sk_buff *skb = NULL;\n\t \n\tunsigned int len = 0;\n\n\tif (in_serv_agg == NULL)\n\t\treturn NULL;\n\n\tif (!list_empty(&in_serv_agg->active))\n\t\tskb = qfq_peek_skb(in_serv_agg, &cl, &len);\n\n\t \n\tif (len == 0 || in_serv_agg->budget < len) {\n\t\tcharge_actual_service(in_serv_agg);\n\n\t\t \n\t\tin_serv_agg->initial_budget = in_serv_agg->budget =\n\t\t\tin_serv_agg->budgetmax;\n\n\t\tif (!list_empty(&in_serv_agg->active)) {\n\t\t\t \n\t\t\tqfq_update_agg_ts(q, in_serv_agg, requeue);\n\t\t\tqfq_schedule_agg(q, in_serv_agg);\n\t\t} else if (sch->q.qlen == 0) {  \n\t\t\tq->in_serv_agg = NULL;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tin_serv_agg = q->in_serv_agg = qfq_choose_next_agg(q);\n\t\tskb = qfq_peek_skb(in_serv_agg, &cl, &len);\n\t}\n\tif (!skb)\n\t\treturn NULL;\n\n\tsch->q.qlen--;\n\n\tskb = agg_dequeue(in_serv_agg, cl, len);\n\n\tif (!skb) {\n\t\tsch->q.qlen++;\n\t\treturn NULL;\n\t}\n\n\tqdisc_qstats_backlog_dec(sch, skb);\n\tqdisc_bstats_update(sch, skb);\n\n\t \n\tif (unlikely(in_serv_agg->budget < len))\n\t\tin_serv_agg->budget = 0;\n\telse\n\t\tin_serv_agg->budget -= len;\n\n\tq->V += (u64)len * q->iwsum;\n\tpr_debug(\"qfq dequeue: len %u F %lld now %lld\\n\",\n\t\t len, (unsigned long long) in_serv_agg->F,\n\t\t (unsigned long long) q->V);\n\n\treturn skb;\n}\n\nstatic struct qfq_aggregate *qfq_choose_next_agg(struct qfq_sched *q)\n{\n\tstruct qfq_group *grp;\n\tstruct qfq_aggregate *agg, *new_front_agg;\n\tu64 old_F;\n\n\tqfq_update_eligible(q);\n\tq->oldV = q->V;\n\n\tif (!q->bitmaps[ER])\n\t\treturn NULL;\n\n\tgrp = qfq_ffs(q, q->bitmaps[ER]);\n\told_F = grp->F;\n\n\tagg = qfq_slot_head(grp);\n\n\t \n\tqfq_front_slot_remove(grp);\n\n\tnew_front_agg = qfq_slot_scan(grp);\n\n\tif (new_front_agg == NULL)  \n\t\t__clear_bit(grp->index, &q->bitmaps[ER]);\n\telse {\n\t\tu64 roundedS = qfq_round_down(new_front_agg->S,\n\t\t\t\t\t      grp->slot_shift);\n\t\tunsigned int s;\n\n\t\tif (grp->S == roundedS)\n\t\t\treturn agg;\n\t\tgrp->S = roundedS;\n\t\tgrp->F = roundedS + (2ULL << grp->slot_shift);\n\t\t__clear_bit(grp->index, &q->bitmaps[ER]);\n\t\ts = qfq_calc_state(q, grp);\n\t\t__set_bit(grp->index, &q->bitmaps[s]);\n\t}\n\n\tqfq_unblock_groups(q, grp->index, old_F);\n\n\treturn agg;\n}\n\nstatic int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\tunsigned int len = qdisc_pkt_len(skb), gso_segs;\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_class *cl;\n\tstruct qfq_aggregate *agg;\n\tint err = 0;\n\tbool first;\n\n\tcl = qfq_classify(skb, sch, &err);\n\tif (cl == NULL) {\n\t\tif (err & __NET_XMIT_BYPASS)\n\t\t\tqdisc_qstats_drop(sch);\n\t\t__qdisc_drop(skb, to_free);\n\t\treturn err;\n\t}\n\tpr_debug(\"qfq_enqueue: cl = %x\\n\", cl->common.classid);\n\n\tif (unlikely(cl->agg->lmax < len)) {\n\t\tpr_debug(\"qfq: increasing maxpkt from %u to %u for class %u\",\n\t\t\t cl->agg->lmax, len, cl->common.classid);\n\t\terr = qfq_change_agg(sch, cl, cl->agg->class_weight, len);\n\t\tif (err) {\n\t\t\tcl->qstats.drops++;\n\t\t\treturn qdisc_drop(skb, sch, to_free);\n\t\t}\n\t}\n\n\tgso_segs = skb_is_gso(skb) ? skb_shinfo(skb)->gso_segs : 1;\n\tfirst = !cl->qdisc->q.qlen;\n\terr = qdisc_enqueue(skb, cl->qdisc, to_free);\n\tif (unlikely(err != NET_XMIT_SUCCESS)) {\n\t\tpr_debug(\"qfq_enqueue: enqueue failed %d\\n\", err);\n\t\tif (net_xmit_drop_count(err)) {\n\t\t\tcl->qstats.drops++;\n\t\t\tqdisc_qstats_drop(sch);\n\t\t}\n\t\treturn err;\n\t}\n\n\t_bstats_update(&cl->bstats, len, gso_segs);\n\tsch->qstats.backlog += len;\n\t++sch->q.qlen;\n\n\tagg = cl->agg;\n\t \n\tif (!first) {\n\t\tif (unlikely(skb == cl->qdisc->ops->peek(cl->qdisc)) &&\n\t\t    list_first_entry(&agg->active, struct qfq_class, alist)\n\t\t    == cl && cl->deficit < len)\n\t\t\tlist_move_tail(&cl->alist, &agg->active);\n\n\t\treturn err;\n\t}\n\n\t \n\tcl->deficit = agg->lmax;\n\tlist_add_tail(&cl->alist, &agg->active);\n\n\tif (list_first_entry(&agg->active, struct qfq_class, alist) != cl ||\n\t    q->in_serv_agg == agg)\n\t\treturn err;  \n\n\tqfq_activate_agg(q, agg, enqueue);\n\n\treturn err;\n}\n\n \nstatic void qfq_schedule_agg(struct qfq_sched *q, struct qfq_aggregate *agg)\n{\n\tstruct qfq_group *grp = agg->grp;\n\tu64 roundedS;\n\tint s;\n\n\troundedS = qfq_round_down(agg->S, grp->slot_shift);\n\n\t \n\tif (grp->full_slots) {\n\t\tif (!qfq_gt(grp->S, agg->S))\n\t\t\tgoto skip_update;\n\n\t\t \n\t\tqfq_slot_rotate(grp, roundedS);\n\t\t \n\t\t__clear_bit(grp->index, &q->bitmaps[IR]);\n\t\t__clear_bit(grp->index, &q->bitmaps[IB]);\n\t} else if (!q->bitmaps[ER] && qfq_gt(roundedS, q->V) &&\n\t\t   q->in_serv_agg == NULL)\n\t\tq->V = roundedS;\n\n\tgrp->S = roundedS;\n\tgrp->F = roundedS + (2ULL << grp->slot_shift);\n\ts = qfq_calc_state(q, grp);\n\t__set_bit(grp->index, &q->bitmaps[s]);\n\n\tpr_debug(\"qfq enqueue: new state %d %#lx S %lld F %lld V %lld\\n\",\n\t\t s, q->bitmaps[s],\n\t\t (unsigned long long) agg->S,\n\t\t (unsigned long long) agg->F,\n\t\t (unsigned long long) q->V);\n\nskip_update:\n\tqfq_slot_insert(grp, agg, roundedS);\n}\n\n\n \nstatic void qfq_activate_agg(struct qfq_sched *q, struct qfq_aggregate *agg,\n\t\t\t     enum update_reason reason)\n{\n\tagg->initial_budget = agg->budget = agg->budgetmax;  \n\n\tqfq_update_agg_ts(q, agg, reason);\n\tif (q->in_serv_agg == NULL) {  \n\t\tq->in_serv_agg = agg;  \n\t\t  \n\t\tq->oldV = q->V = agg->S;\n\t} else if (agg != q->in_serv_agg)\n\t\tqfq_schedule_agg(q, agg);\n}\n\nstatic void qfq_slot_remove(struct qfq_sched *q, struct qfq_group *grp,\n\t\t\t    struct qfq_aggregate *agg)\n{\n\tunsigned int i, offset;\n\tu64 roundedS;\n\n\troundedS = qfq_round_down(agg->S, grp->slot_shift);\n\toffset = (roundedS - grp->S) >> grp->slot_shift;\n\n\ti = (grp->front + offset) % QFQ_MAX_SLOTS;\n\n\thlist_del(&agg->next);\n\tif (hlist_empty(&grp->slots[i]))\n\t\t__clear_bit(offset, &grp->full_slots);\n}\n\n \nstatic void qfq_deactivate_agg(struct qfq_sched *q, struct qfq_aggregate *agg)\n{\n\tstruct qfq_group *grp = agg->grp;\n\tunsigned long mask;\n\tu64 roundedS;\n\tint s;\n\n\tif (agg == q->in_serv_agg) {\n\t\tcharge_actual_service(agg);\n\t\tq->in_serv_agg = qfq_choose_next_agg(q);\n\t\treturn;\n\t}\n\n\tagg->F = agg->S;\n\tqfq_slot_remove(q, grp, agg);\n\n\tif (!grp->full_slots) {\n\t\t__clear_bit(grp->index, &q->bitmaps[IR]);\n\t\t__clear_bit(grp->index, &q->bitmaps[EB]);\n\t\t__clear_bit(grp->index, &q->bitmaps[IB]);\n\n\t\tif (test_bit(grp->index, &q->bitmaps[ER]) &&\n\t\t    !(q->bitmaps[ER] & ~((1UL << grp->index) - 1))) {\n\t\t\tmask = q->bitmaps[ER] & ((1UL << grp->index) - 1);\n\t\t\tif (mask)\n\t\t\t\tmask = ~((1UL << __fls(mask)) - 1);\n\t\t\telse\n\t\t\t\tmask = ~0UL;\n\t\t\tqfq_move_groups(q, mask, EB, ER);\n\t\t\tqfq_move_groups(q, mask, IB, IR);\n\t\t}\n\t\t__clear_bit(grp->index, &q->bitmaps[ER]);\n\t} else if (hlist_empty(&grp->slots[grp->front])) {\n\t\tagg = qfq_slot_scan(grp);\n\t\troundedS = qfq_round_down(agg->S, grp->slot_shift);\n\t\tif (grp->S != roundedS) {\n\t\t\t__clear_bit(grp->index, &q->bitmaps[ER]);\n\t\t\t__clear_bit(grp->index, &q->bitmaps[IR]);\n\t\t\t__clear_bit(grp->index, &q->bitmaps[EB]);\n\t\t\t__clear_bit(grp->index, &q->bitmaps[IB]);\n\t\t\tgrp->S = roundedS;\n\t\t\tgrp->F = roundedS + (2ULL << grp->slot_shift);\n\t\t\ts = qfq_calc_state(q, grp);\n\t\t\t__set_bit(grp->index, &q->bitmaps[s]);\n\t\t}\n\t}\n}\n\nstatic void qfq_qlen_notify(struct Qdisc *sch, unsigned long arg)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_class *cl = (struct qfq_class *)arg;\n\n\tqfq_deactivate_class(q, cl);\n}\n\nstatic int qfq_init_qdisc(struct Qdisc *sch, struct nlattr *opt,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_group *grp;\n\tint i, j, err;\n\tu32 max_cl_shift, maxbudg_shift, max_classes;\n\n\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = qdisc_class_hash_init(&q->clhash);\n\tif (err < 0)\n\t\treturn err;\n\n\tmax_classes = min_t(u64, (u64)qdisc_dev(sch)->tx_queue_len + 1,\n\t\t\t    QFQ_MAX_AGG_CLASSES);\n\t \n\tmax_cl_shift = __fls(max_classes);\n\tq->max_agg_classes = 1<<max_cl_shift;\n\n\t \n\tmaxbudg_shift = QFQ_MTU_SHIFT + max_cl_shift;\n\tq->min_slot_shift = FRAC_BITS + maxbudg_shift - QFQ_MAX_INDEX;\n\n\tfor (i = 0; i <= QFQ_MAX_INDEX; i++) {\n\t\tgrp = &q->groups[i];\n\t\tgrp->index = i;\n\t\tgrp->slot_shift = q->min_slot_shift + i;\n\t\tfor (j = 0; j < QFQ_MAX_SLOTS; j++)\n\t\t\tINIT_HLIST_HEAD(&grp->slots[j]);\n\t}\n\n\tINIT_HLIST_HEAD(&q->nonfull_aggs);\n\n\treturn 0;\n}\n\nstatic void qfq_reset_qdisc(struct Qdisc *sch)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_class *cl;\n\tunsigned int i;\n\n\tfor (i = 0; i < q->clhash.hashsize; i++) {\n\t\thlist_for_each_entry(cl, &q->clhash.hash[i], common.hnode) {\n\t\t\tif (cl->qdisc->q.qlen > 0)\n\t\t\t\tqfq_deactivate_class(q, cl);\n\n\t\t\tqdisc_reset(cl->qdisc);\n\t\t}\n\t}\n}\n\nstatic void qfq_destroy_qdisc(struct Qdisc *sch)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_class *cl;\n\tstruct hlist_node *next;\n\tunsigned int i;\n\n\ttcf_block_put(q->block);\n\n\tfor (i = 0; i < q->clhash.hashsize; i++) {\n\t\thlist_for_each_entry_safe(cl, next, &q->clhash.hash[i],\n\t\t\t\t\t  common.hnode) {\n\t\t\tqfq_destroy_class(sch, cl);\n\t\t}\n\t}\n\tqdisc_class_hash_destroy(&q->clhash);\n}\n\nstatic const struct Qdisc_class_ops qfq_class_ops = {\n\t.change\t\t= qfq_change_class,\n\t.delete\t\t= qfq_delete_class,\n\t.find\t\t= qfq_search_class,\n\t.tcf_block\t= qfq_tcf_block,\n\t.bind_tcf\t= qfq_bind_tcf,\n\t.unbind_tcf\t= qfq_unbind_tcf,\n\t.graft\t\t= qfq_graft_class,\n\t.leaf\t\t= qfq_class_leaf,\n\t.qlen_notify\t= qfq_qlen_notify,\n\t.dump\t\t= qfq_dump_class,\n\t.dump_stats\t= qfq_dump_class_stats,\n\t.walk\t\t= qfq_walk,\n};\n\nstatic struct Qdisc_ops qfq_qdisc_ops __read_mostly = {\n\t.cl_ops\t\t= &qfq_class_ops,\n\t.id\t\t= \"qfq\",\n\t.priv_size\t= sizeof(struct qfq_sched),\n\t.enqueue\t= qfq_enqueue,\n\t.dequeue\t= qfq_dequeue,\n\t.peek\t\t= qdisc_peek_dequeued,\n\t.init\t\t= qfq_init_qdisc,\n\t.reset\t\t= qfq_reset_qdisc,\n\t.destroy\t= qfq_destroy_qdisc,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init qfq_init(void)\n{\n\treturn register_qdisc(&qfq_qdisc_ops);\n}\n\nstatic void __exit qfq_exit(void)\n{\n\tunregister_qdisc(&qfq_qdisc_ops);\n}\n\nmodule_init(qfq_init);\nmodule_exit(qfq_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}