{
  "module_name": "cls_u32.c",
  "hash_id": "1cf915b276e4e39bfc03192a324b9e3d92c4bbee96518e2b16a6f0d726b0c54f",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/cls_u32.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/percpu.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/bitmap.h>\n#include <linux/netdevice.h>\n#include <linux/hash.h>\n#include <net/netlink.h>\n#include <net/act_api.h>\n#include <net/pkt_cls.h>\n#include <linux/idr.h>\n#include <net/tc_wrapper.h>\n\nstruct tc_u_knode {\n\tstruct tc_u_knode __rcu\t*next;\n\tu32\t\t\thandle;\n\tstruct tc_u_hnode __rcu\t*ht_up;\n\tstruct tcf_exts\t\texts;\n\tint\t\t\tifindex;\n\tu8\t\t\tfshift;\n\tstruct tcf_result\tres;\n\tstruct tc_u_hnode __rcu\t*ht_down;\n#ifdef CONFIG_CLS_U32_PERF\n\tstruct tc_u32_pcnt __percpu *pf;\n#endif\n\tu32\t\t\tflags;\n\tunsigned int\t\tin_hw_count;\n#ifdef CONFIG_CLS_U32_MARK\n\tu32\t\t\tval;\n\tu32\t\t\tmask;\n\tu32 __percpu\t\t*pcpu_success;\n#endif\n\tstruct rcu_work\t\trwork;\n\t \n\tstruct tc_u32_sel\tsel;\n};\n\nstruct tc_u_hnode {\n\tstruct tc_u_hnode __rcu\t*next;\n\tu32\t\t\thandle;\n\tu32\t\t\tprio;\n\tint\t\t\trefcnt;\n\tunsigned int\t\tdivisor;\n\tstruct idr\t\thandle_idr;\n\tbool\t\t\tis_root;\n\tstruct rcu_head\t\trcu;\n\tu32\t\t\tflags;\n\t \n\tstruct tc_u_knode __rcu\t*ht[];\n};\n\nstruct tc_u_common {\n\tstruct tc_u_hnode __rcu\t*hlist;\n\tvoid\t\t\t*ptr;\n\tint\t\t\trefcnt;\n\tstruct idr\t\thandle_idr;\n\tstruct hlist_node\thnode;\n\tlong\t\t\tknodes;\n};\n\nstatic inline unsigned int u32_hash_fold(__be32 key,\n\t\t\t\t\t const struct tc_u32_sel *sel,\n\t\t\t\t\t u8 fshift)\n{\n\tunsigned int h = ntohl(key & sel->hmask) >> fshift;\n\n\treturn h;\n}\n\nTC_INDIRECT_SCOPE int u32_classify(struct sk_buff *skb,\n\t\t\t\t   const struct tcf_proto *tp,\n\t\t\t\t   struct tcf_result *res)\n{\n\tstruct {\n\t\tstruct tc_u_knode *knode;\n\t\tunsigned int\t  off;\n\t} stack[TC_U32_MAXDEPTH];\n\n\tstruct tc_u_hnode *ht = rcu_dereference_bh(tp->root);\n\tunsigned int off = skb_network_offset(skb);\n\tstruct tc_u_knode *n;\n\tint sdepth = 0;\n\tint off2 = 0;\n\tint sel = 0;\n#ifdef CONFIG_CLS_U32_PERF\n\tint j;\n#endif\n\tint i, r;\n\nnext_ht:\n\tn = rcu_dereference_bh(ht->ht[sel]);\n\nnext_knode:\n\tif (n) {\n\t\tstruct tc_u32_key *key = n->sel.keys;\n\n#ifdef CONFIG_CLS_U32_PERF\n\t\t__this_cpu_inc(n->pf->rcnt);\n\t\tj = 0;\n#endif\n\n\t\tif (tc_skip_sw(n->flags)) {\n\t\t\tn = rcu_dereference_bh(n->next);\n\t\t\tgoto next_knode;\n\t\t}\n\n#ifdef CONFIG_CLS_U32_MARK\n\t\tif ((skb->mark & n->mask) != n->val) {\n\t\t\tn = rcu_dereference_bh(n->next);\n\t\t\tgoto next_knode;\n\t\t} else {\n\t\t\t__this_cpu_inc(*n->pcpu_success);\n\t\t}\n#endif\n\n\t\tfor (i = n->sel.nkeys; i > 0; i--, key++) {\n\t\t\tint toff = off + key->off + (off2 & key->offmask);\n\t\t\t__be32 *data, hdata;\n\n\t\t\tif (skb_headroom(skb) + toff > INT_MAX)\n\t\t\t\tgoto out;\n\n\t\t\tdata = skb_header_pointer(skb, toff, 4, &hdata);\n\t\t\tif (!data)\n\t\t\t\tgoto out;\n\t\t\tif ((*data ^ key->val) & key->mask) {\n\t\t\t\tn = rcu_dereference_bh(n->next);\n\t\t\t\tgoto next_knode;\n\t\t\t}\n#ifdef CONFIG_CLS_U32_PERF\n\t\t\t__this_cpu_inc(n->pf->kcnts[j]);\n\t\t\tj++;\n#endif\n\t\t}\n\n\t\tht = rcu_dereference_bh(n->ht_down);\n\t\tif (!ht) {\ncheck_terminal:\n\t\t\tif (n->sel.flags & TC_U32_TERMINAL) {\n\n\t\t\t\t*res = n->res;\n\t\t\t\tif (!tcf_match_indev(skb, n->ifindex)) {\n\t\t\t\t\tn = rcu_dereference_bh(n->next);\n\t\t\t\t\tgoto next_knode;\n\t\t\t\t}\n#ifdef CONFIG_CLS_U32_PERF\n\t\t\t\t__this_cpu_inc(n->pf->rhit);\n#endif\n\t\t\t\tr = tcf_exts_exec(skb, &n->exts, res);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tn = rcu_dereference_bh(n->next);\n\t\t\t\t\tgoto next_knode;\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tn = rcu_dereference_bh(n->next);\n\t\t\tgoto next_knode;\n\t\t}\n\n\t\t \n\t\tif (sdepth >= TC_U32_MAXDEPTH)\n\t\t\tgoto deadloop;\n\t\tstack[sdepth].knode = n;\n\t\tstack[sdepth].off = off;\n\t\tsdepth++;\n\n\t\tht = rcu_dereference_bh(n->ht_down);\n\t\tsel = 0;\n\t\tif (ht->divisor) {\n\t\t\t__be32 *data, hdata;\n\n\t\t\tdata = skb_header_pointer(skb, off + n->sel.hoff, 4,\n\t\t\t\t\t\t  &hdata);\n\t\t\tif (!data)\n\t\t\t\tgoto out;\n\t\t\tsel = ht->divisor & u32_hash_fold(*data, &n->sel,\n\t\t\t\t\t\t\t  n->fshift);\n\t\t}\n\t\tif (!(n->sel.flags & (TC_U32_VAROFFSET | TC_U32_OFFSET | TC_U32_EAT)))\n\t\t\tgoto next_ht;\n\n\t\tif (n->sel.flags & (TC_U32_OFFSET | TC_U32_VAROFFSET)) {\n\t\t\toff2 = n->sel.off + 3;\n\t\t\tif (n->sel.flags & TC_U32_VAROFFSET) {\n\t\t\t\t__be16 *data, hdata;\n\n\t\t\t\tdata = skb_header_pointer(skb,\n\t\t\t\t\t\t\t  off + n->sel.offoff,\n\t\t\t\t\t\t\t  2, &hdata);\n\t\t\t\tif (!data)\n\t\t\t\t\tgoto out;\n\t\t\t\toff2 += ntohs(n->sel.offmask & *data) >>\n\t\t\t\t\tn->sel.offshift;\n\t\t\t}\n\t\t\toff2 &= ~3;\n\t\t}\n\t\tif (n->sel.flags & TC_U32_EAT) {\n\t\t\toff += off2;\n\t\t\toff2 = 0;\n\t\t}\n\n\t\tif (off < skb->len)\n\t\t\tgoto next_ht;\n\t}\n\n\t \n\tif (sdepth--) {\n\t\tn = stack[sdepth].knode;\n\t\tht = rcu_dereference_bh(n->ht_up);\n\t\toff = stack[sdepth].off;\n\t\tgoto check_terminal;\n\t}\nout:\n\treturn -1;\n\ndeadloop:\n\tnet_warn_ratelimited(\"cls_u32: dead loop\\n\");\n\treturn -1;\n}\n\nstatic struct tc_u_hnode *u32_lookup_ht(struct tc_u_common *tp_c, u32 handle)\n{\n\tstruct tc_u_hnode *ht;\n\n\tfor (ht = rtnl_dereference(tp_c->hlist);\n\t     ht;\n\t     ht = rtnl_dereference(ht->next))\n\t\tif (ht->handle == handle)\n\t\t\tbreak;\n\n\treturn ht;\n}\n\nstatic struct tc_u_knode *u32_lookup_key(struct tc_u_hnode *ht, u32 handle)\n{\n\tunsigned int sel;\n\tstruct tc_u_knode *n = NULL;\n\n\tsel = TC_U32_HASH(handle);\n\tif (sel > ht->divisor)\n\t\tgoto out;\n\n\tfor (n = rtnl_dereference(ht->ht[sel]);\n\t     n;\n\t     n = rtnl_dereference(n->next))\n\t\tif (n->handle == handle)\n\t\t\tbreak;\nout:\n\treturn n;\n}\n\n\nstatic void *u32_get(struct tcf_proto *tp, u32 handle)\n{\n\tstruct tc_u_hnode *ht;\n\tstruct tc_u_common *tp_c = tp->data;\n\n\tif (TC_U32_HTID(handle) == TC_U32_ROOT)\n\t\tht = rtnl_dereference(tp->root);\n\telse\n\t\tht = u32_lookup_ht(tp_c, TC_U32_HTID(handle));\n\n\tif (!ht)\n\t\treturn NULL;\n\n\tif (TC_U32_KEY(handle) == 0)\n\t\treturn ht;\n\n\treturn u32_lookup_key(ht, handle);\n}\n\n \nstatic u32 gen_new_htid(struct tc_u_common *tp_c, struct tc_u_hnode *ptr)\n{\n\tint id = idr_alloc_cyclic(&tp_c->handle_idr, ptr, 1, 0x7FF, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn 0;\n\treturn (id | 0x800U) << 20;\n}\n\nstatic struct hlist_head *tc_u_common_hash;\n\n#define U32_HASH_SHIFT 10\n#define U32_HASH_SIZE (1 << U32_HASH_SHIFT)\n\nstatic void *tc_u_common_ptr(const struct tcf_proto *tp)\n{\n\tstruct tcf_block *block = tp->chain->block;\n\n\t \n\tif (tcf_block_shared(block))\n\t\treturn block;\n\telse\n\t\treturn block->q;\n}\n\nstatic struct hlist_head *tc_u_hash(void *key)\n{\n\treturn tc_u_common_hash + hash_ptr(key, U32_HASH_SHIFT);\n}\n\nstatic struct tc_u_common *tc_u_common_find(void *key)\n{\n\tstruct tc_u_common *tc;\n\thlist_for_each_entry(tc, tc_u_hash(key), hnode) {\n\t\tif (tc->ptr == key)\n\t\t\treturn tc;\n\t}\n\treturn NULL;\n}\n\nstatic int u32_init(struct tcf_proto *tp)\n{\n\tstruct tc_u_hnode *root_ht;\n\tvoid *key = tc_u_common_ptr(tp);\n\tstruct tc_u_common *tp_c = tc_u_common_find(key);\n\n\troot_ht = kzalloc(struct_size(root_ht, ht, 1), GFP_KERNEL);\n\tif (root_ht == NULL)\n\t\treturn -ENOBUFS;\n\n\troot_ht->refcnt++;\n\troot_ht->handle = tp_c ? gen_new_htid(tp_c, root_ht) : 0x80000000;\n\troot_ht->prio = tp->prio;\n\troot_ht->is_root = true;\n\tidr_init(&root_ht->handle_idr);\n\n\tif (tp_c == NULL) {\n\t\ttp_c = kzalloc(sizeof(*tp_c), GFP_KERNEL);\n\t\tif (tp_c == NULL) {\n\t\t\tkfree(root_ht);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\ttp_c->ptr = key;\n\t\tINIT_HLIST_NODE(&tp_c->hnode);\n\t\tidr_init(&tp_c->handle_idr);\n\n\t\thlist_add_head(&tp_c->hnode, tc_u_hash(key));\n\t}\n\n\ttp_c->refcnt++;\n\tRCU_INIT_POINTER(root_ht->next, tp_c->hlist);\n\trcu_assign_pointer(tp_c->hlist, root_ht);\n\n\troot_ht->refcnt++;\n\trcu_assign_pointer(tp->root, root_ht);\n\ttp->data = tp_c;\n\treturn 0;\n}\n\nstatic void __u32_destroy_key(struct tc_u_knode *n)\n{\n\tstruct tc_u_hnode *ht = rtnl_dereference(n->ht_down);\n\n\ttcf_exts_destroy(&n->exts);\n\tif (ht && --ht->refcnt == 0)\n\t\tkfree(ht);\n\tkfree(n);\n}\n\nstatic void u32_destroy_key(struct tc_u_knode *n, bool free_pf)\n{\n\ttcf_exts_put_net(&n->exts);\n#ifdef CONFIG_CLS_U32_PERF\n\tif (free_pf)\n\t\tfree_percpu(n->pf);\n#endif\n#ifdef CONFIG_CLS_U32_MARK\n\tif (free_pf)\n\t\tfree_percpu(n->pcpu_success);\n#endif\n\t__u32_destroy_key(n);\n}\n\n \nstatic void u32_delete_key_work(struct work_struct *work)\n{\n\tstruct tc_u_knode *key = container_of(to_rcu_work(work),\n\t\t\t\t\t      struct tc_u_knode,\n\t\t\t\t\t      rwork);\n\trtnl_lock();\n\tu32_destroy_key(key, false);\n\trtnl_unlock();\n}\n\n \nstatic void u32_delete_key_freepf_work(struct work_struct *work)\n{\n\tstruct tc_u_knode *key = container_of(to_rcu_work(work),\n\t\t\t\t\t      struct tc_u_knode,\n\t\t\t\t\t      rwork);\n\trtnl_lock();\n\tu32_destroy_key(key, true);\n\trtnl_unlock();\n}\n\nstatic int u32_delete_key(struct tcf_proto *tp, struct tc_u_knode *key)\n{\n\tstruct tc_u_common *tp_c = tp->data;\n\tstruct tc_u_knode __rcu **kp;\n\tstruct tc_u_knode *pkp;\n\tstruct tc_u_hnode *ht = rtnl_dereference(key->ht_up);\n\n\tif (ht) {\n\t\tkp = &ht->ht[TC_U32_HASH(key->handle)];\n\t\tfor (pkp = rtnl_dereference(*kp); pkp;\n\t\t     kp = &pkp->next, pkp = rtnl_dereference(*kp)) {\n\t\t\tif (pkp == key) {\n\t\t\t\tRCU_INIT_POINTER(*kp, key->next);\n\t\t\t\ttp_c->knodes--;\n\n\t\t\t\ttcf_unbind_filter(tp, &key->res);\n\t\t\t\tidr_remove(&ht->handle_idr, key->handle);\n\t\t\t\ttcf_exts_get_net(&key->exts);\n\t\t\t\ttcf_queue_work(&key->rwork, u32_delete_key_freepf_work);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tWARN_ON(1);\n\treturn 0;\n}\n\nstatic void u32_clear_hw_hnode(struct tcf_proto *tp, struct tc_u_hnode *h,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct tc_cls_u32_offload cls_u32 = {};\n\n\ttc_cls_common_offload_init(&cls_u32.common, tp, h->flags, extack);\n\tcls_u32.command = TC_CLSU32_DELETE_HNODE;\n\tcls_u32.hnode.divisor = h->divisor;\n\tcls_u32.hnode.handle = h->handle;\n\tcls_u32.hnode.prio = h->prio;\n\n\ttc_setup_cb_call(block, TC_SETUP_CLSU32, &cls_u32, false, true);\n}\n\nstatic int u32_replace_hw_hnode(struct tcf_proto *tp, struct tc_u_hnode *h,\n\t\t\t\tu32 flags, struct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct tc_cls_u32_offload cls_u32 = {};\n\tbool skip_sw = tc_skip_sw(flags);\n\tbool offloaded = false;\n\tint err;\n\n\ttc_cls_common_offload_init(&cls_u32.common, tp, flags, extack);\n\tcls_u32.command = TC_CLSU32_NEW_HNODE;\n\tcls_u32.hnode.divisor = h->divisor;\n\tcls_u32.hnode.handle = h->handle;\n\tcls_u32.hnode.prio = h->prio;\n\n\terr = tc_setup_cb_call(block, TC_SETUP_CLSU32, &cls_u32, skip_sw, true);\n\tif (err < 0) {\n\t\tu32_clear_hw_hnode(tp, h, NULL);\n\t\treturn err;\n\t} else if (err > 0) {\n\t\toffloaded = true;\n\t}\n\n\tif (skip_sw && !offloaded)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void u32_remove_hw_knode(struct tcf_proto *tp, struct tc_u_knode *n,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct tc_cls_u32_offload cls_u32 = {};\n\n\ttc_cls_common_offload_init(&cls_u32.common, tp, n->flags, extack);\n\tcls_u32.command = TC_CLSU32_DELETE_KNODE;\n\tcls_u32.knode.handle = n->handle;\n\n\ttc_setup_cb_destroy(block, tp, TC_SETUP_CLSU32, &cls_u32, false,\n\t\t\t    &n->flags, &n->in_hw_count, true);\n}\n\nstatic int u32_replace_hw_knode(struct tcf_proto *tp, struct tc_u_knode *n,\n\t\t\t\tu32 flags, struct netlink_ext_ack *extack)\n{\n\tstruct tc_u_hnode *ht = rtnl_dereference(n->ht_down);\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct tc_cls_u32_offload cls_u32 = {};\n\tbool skip_sw = tc_skip_sw(flags);\n\tint err;\n\n\ttc_cls_common_offload_init(&cls_u32.common, tp, flags, extack);\n\tcls_u32.command = TC_CLSU32_REPLACE_KNODE;\n\tcls_u32.knode.handle = n->handle;\n\tcls_u32.knode.fshift = n->fshift;\n#ifdef CONFIG_CLS_U32_MARK\n\tcls_u32.knode.val = n->val;\n\tcls_u32.knode.mask = n->mask;\n#else\n\tcls_u32.knode.val = 0;\n\tcls_u32.knode.mask = 0;\n#endif\n\tcls_u32.knode.sel = &n->sel;\n\tcls_u32.knode.res = &n->res;\n\tcls_u32.knode.exts = &n->exts;\n\tif (n->ht_down)\n\t\tcls_u32.knode.link_handle = ht->handle;\n\n\terr = tc_setup_cb_add(block, tp, TC_SETUP_CLSU32, &cls_u32, skip_sw,\n\t\t\t      &n->flags, &n->in_hw_count, true);\n\tif (err) {\n\t\tu32_remove_hw_knode(tp, n, NULL);\n\t\treturn err;\n\t}\n\n\tif (skip_sw && !(n->flags & TCA_CLS_FLAGS_IN_HW))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void u32_clear_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct tc_u_common *tp_c = tp->data;\n\tstruct tc_u_knode *n;\n\tunsigned int h;\n\n\tfor (h = 0; h <= ht->divisor; h++) {\n\t\twhile ((n = rtnl_dereference(ht->ht[h])) != NULL) {\n\t\t\tRCU_INIT_POINTER(ht->ht[h],\n\t\t\t\t\t rtnl_dereference(n->next));\n\t\t\ttp_c->knodes--;\n\t\t\ttcf_unbind_filter(tp, &n->res);\n\t\t\tu32_remove_hw_knode(tp, n, extack);\n\t\t\tidr_remove(&ht->handle_idr, n->handle);\n\t\t\tif (tcf_exts_get_net(&n->exts))\n\t\t\t\ttcf_queue_work(&n->rwork, u32_delete_key_freepf_work);\n\t\t\telse\n\t\t\t\tu32_destroy_key(n, true);\n\t\t}\n\t}\n}\n\nstatic int u32_destroy_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct tc_u_common *tp_c = tp->data;\n\tstruct tc_u_hnode __rcu **hn;\n\tstruct tc_u_hnode *phn;\n\n\tWARN_ON(--ht->refcnt);\n\n\tu32_clear_hnode(tp, ht, extack);\n\n\thn = &tp_c->hlist;\n\tfor (phn = rtnl_dereference(*hn);\n\t     phn;\n\t     hn = &phn->next, phn = rtnl_dereference(*hn)) {\n\t\tif (phn == ht) {\n\t\t\tu32_clear_hw_hnode(tp, ht, extack);\n\t\t\tidr_destroy(&ht->handle_idr);\n\t\t\tidr_remove(&tp_c->handle_idr, ht->handle);\n\t\t\tRCU_INIT_POINTER(*hn, ht->next);\n\t\t\tkfree_rcu(ht, rcu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic void u32_destroy(struct tcf_proto *tp, bool rtnl_held,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tc_u_common *tp_c = tp->data;\n\tstruct tc_u_hnode *root_ht = rtnl_dereference(tp->root);\n\n\tWARN_ON(root_ht == NULL);\n\n\tif (root_ht && --root_ht->refcnt == 1)\n\t\tu32_destroy_hnode(tp, root_ht, extack);\n\n\tif (--tp_c->refcnt == 0) {\n\t\tstruct tc_u_hnode *ht;\n\n\t\thlist_del(&tp_c->hnode);\n\n\t\twhile ((ht = rtnl_dereference(tp_c->hlist)) != NULL) {\n\t\t\tu32_clear_hnode(tp, ht, extack);\n\t\t\tRCU_INIT_POINTER(tp_c->hlist, ht->next);\n\n\t\t\t \n\t\t\tif (--ht->refcnt == 0)\n\t\t\t\tkfree_rcu(ht, rcu);\n\t\t}\n\n\t\tidr_destroy(&tp_c->handle_idr);\n\t\tkfree(tp_c);\n\t}\n\n\ttp->data = NULL;\n}\n\nstatic int u32_delete(struct tcf_proto *tp, void *arg, bool *last,\n\t\t      bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct tc_u_hnode *ht = arg;\n\tstruct tc_u_common *tp_c = tp->data;\n\tint ret = 0;\n\n\tif (TC_U32_KEY(ht->handle)) {\n\t\tu32_remove_hw_knode(tp, (struct tc_u_knode *)ht, extack);\n\t\tret = u32_delete_key(tp, (struct tc_u_knode *)ht);\n\t\tgoto out;\n\t}\n\n\tif (ht->is_root) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Not allowed to delete root node\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ht->refcnt == 1) {\n\t\tu32_destroy_hnode(tp, ht, extack);\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Can not delete in-use filter\");\n\t\treturn -EBUSY;\n\t}\n\nout:\n\t*last = tp_c->refcnt == 1 && tp_c->knodes == 0;\n\treturn ret;\n}\n\nstatic u32 gen_new_kid(struct tc_u_hnode *ht, u32 htid)\n{\n\tu32 index = htid | 0x800;\n\tu32 max = htid | 0xFFF;\n\n\tif (idr_alloc_u32(&ht->handle_idr, NULL, &index, max, GFP_KERNEL)) {\n\t\tindex = htid + 1;\n\t\tif (idr_alloc_u32(&ht->handle_idr, NULL, &index, max,\n\t\t\t\t GFP_KERNEL))\n\t\t\tindex = max;\n\t}\n\n\treturn index;\n}\n\nstatic const struct nla_policy u32_policy[TCA_U32_MAX + 1] = {\n\t[TCA_U32_CLASSID]\t= { .type = NLA_U32 },\n\t[TCA_U32_HASH]\t\t= { .type = NLA_U32 },\n\t[TCA_U32_LINK]\t\t= { .type = NLA_U32 },\n\t[TCA_U32_DIVISOR]\t= { .type = NLA_U32 },\n\t[TCA_U32_SEL]\t\t= { .len = sizeof(struct tc_u32_sel) },\n\t[TCA_U32_INDEV]\t\t= { .type = NLA_STRING, .len = IFNAMSIZ },\n\t[TCA_U32_MARK]\t\t= { .len = sizeof(struct tc_u32_mark) },\n\t[TCA_U32_FLAGS]\t\t= { .type = NLA_U32 },\n};\n\nstatic void u32_unbind_filter(struct tcf_proto *tp, struct tc_u_knode *n,\n\t\t\t      struct nlattr **tb)\n{\n\tif (tb[TCA_U32_CLASSID])\n\t\ttcf_unbind_filter(tp, &n->res);\n}\n\nstatic void u32_bind_filter(struct tcf_proto *tp, struct tc_u_knode *n,\n\t\t\t    unsigned long base, struct nlattr **tb)\n{\n\tif (tb[TCA_U32_CLASSID]) {\n\t\tn->res.classid = nla_get_u32(tb[TCA_U32_CLASSID]);\n\t\ttcf_bind_filter(tp, &n->res, base);\n\t}\n}\n\nstatic int u32_set_parms(struct net *net, struct tcf_proto *tp,\n\t\t\t struct tc_u_knode *n, struct nlattr **tb,\n\t\t\t struct nlattr *est, u32 flags, u32 fl_flags,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err, ifindex = -1;\n\n\terr = tcf_exts_validate_ex(net, tp, tb, est, &n->exts, flags,\n\t\t\t\t   fl_flags, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_U32_INDEV]) {\n\t\tifindex = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);\n\t\tif (ifindex < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[TCA_U32_LINK]) {\n\t\tu32 handle = nla_get_u32(tb[TCA_U32_LINK]);\n\t\tstruct tc_u_hnode *ht_down = NULL, *ht_old;\n\n\t\tif (TC_U32_KEY(handle)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"u32 Link handle must be a hash table\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (handle) {\n\t\t\tht_down = u32_lookup_ht(tp->data, handle);\n\n\t\t\tif (!ht_down) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Link hash table not found\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ht_down->is_root) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Not linking to root node\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tht_down->refcnt++;\n\t\t}\n\n\t\tht_old = rtnl_dereference(n->ht_down);\n\t\trcu_assign_pointer(n->ht_down, ht_down);\n\n\t\tif (ht_old)\n\t\t\tht_old->refcnt--;\n\t}\n\n\tif (ifindex >= 0)\n\t\tn->ifindex = ifindex;\n\n\treturn 0;\n}\n\nstatic void u32_replace_knode(struct tcf_proto *tp, struct tc_u_common *tp_c,\n\t\t\t      struct tc_u_knode *n)\n{\n\tstruct tc_u_knode __rcu **ins;\n\tstruct tc_u_knode *pins;\n\tstruct tc_u_hnode *ht;\n\n\tif (TC_U32_HTID(n->handle) == TC_U32_ROOT)\n\t\tht = rtnl_dereference(tp->root);\n\telse\n\t\tht = u32_lookup_ht(tp_c, TC_U32_HTID(n->handle));\n\n\tins = &ht->ht[TC_U32_HASH(n->handle)];\n\n\t \n\tfor (pins = rtnl_dereference(*ins); ;\n\t     ins = &pins->next, pins = rtnl_dereference(*ins))\n\t\tif (pins->handle == n->handle)\n\t\t\tbreak;\n\n\tidr_replace(&ht->handle_idr, n, n->handle);\n\tRCU_INIT_POINTER(n->next, pins->next);\n\trcu_assign_pointer(*ins, n);\n}\n\nstatic struct tc_u_knode *u32_init_knode(struct net *net, struct tcf_proto *tp,\n\t\t\t\t\t struct tc_u_knode *n)\n{\n\tstruct tc_u_hnode *ht = rtnl_dereference(n->ht_down);\n\tstruct tc_u32_sel *s = &n->sel;\n\tstruct tc_u_knode *new;\n\n\tnew = kzalloc(struct_size(new, sel.keys, s->nkeys), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tRCU_INIT_POINTER(new->next, n->next);\n\tnew->handle = n->handle;\n\tRCU_INIT_POINTER(new->ht_up, n->ht_up);\n\n\tnew->ifindex = n->ifindex;\n\tnew->fshift = n->fshift;\n\tnew->flags = n->flags;\n\tRCU_INIT_POINTER(new->ht_down, ht);\n\n#ifdef CONFIG_CLS_U32_PERF\n\t \n\tnew->pf = n->pf;\n#endif\n\n#ifdef CONFIG_CLS_U32_MARK\n\tnew->val = n->val;\n\tnew->mask = n->mask;\n\t \n\tnew->pcpu_success = n->pcpu_success;\n#endif\n\tmemcpy(&new->sel, s, struct_size(s, keys, s->nkeys));\n\n\tif (tcf_exts_init(&new->exts, net, TCA_U32_ACT, TCA_U32_POLICE)) {\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (ht)\n\t\tht->refcnt++;\n\n\treturn new;\n}\n\nstatic int u32_change(struct net *net, struct sk_buff *in_skb,\n\t\t      struct tcf_proto *tp, unsigned long base, u32 handle,\n\t\t      struct nlattr **tca, void **arg, u32 flags,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct tc_u_common *tp_c = tp->data;\n\tstruct tc_u_hnode *ht;\n\tstruct tc_u_knode *n;\n\tstruct tc_u32_sel *s;\n\tstruct nlattr *opt = tca[TCA_OPTIONS];\n\tstruct nlattr *tb[TCA_U32_MAX + 1];\n\tu32 htid, userflags = 0;\n\tsize_t sel_size;\n\tint err;\n\n\tif (!opt) {\n\t\tif (handle) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Filter handle requires options\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, TCA_U32_MAX, opt, u32_policy,\n\t\t\t\t\t  extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_U32_FLAGS]) {\n\t\tuserflags = nla_get_u32(tb[TCA_U32_FLAGS]);\n\t\tif (!tc_flags_valid(userflags)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid filter flags\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tn = *arg;\n\tif (n) {\n\t\tstruct tc_u_knode *new;\n\n\t\tif (TC_U32_KEY(n->handle) == 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Key node id cannot be zero\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((n->flags ^ userflags) &\n\t\t    ~(TCA_CLS_FLAGS_IN_HW | TCA_CLS_FLAGS_NOT_IN_HW)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Key node flags do not match passed flags\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnew = u32_init_knode(net, tp, n);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\n\t\terr = u32_set_parms(net, tp, new, tb, tca[TCA_RATE],\n\t\t\t\t    flags, new->flags, extack);\n\n\t\tif (err) {\n\t\t\t__u32_destroy_key(new);\n\t\t\treturn err;\n\t\t}\n\n\t\tu32_bind_filter(tp, new, base, tb);\n\n\t\terr = u32_replace_hw_knode(tp, new, flags, extack);\n\t\tif (err) {\n\t\t\tu32_unbind_filter(tp, new, tb);\n\n\t\t\tif (tb[TCA_U32_LINK]) {\n\t\t\t\tstruct tc_u_hnode *ht_old;\n\n\t\t\t\tht_old = rtnl_dereference(n->ht_down);\n\t\t\t\tif (ht_old)\n\t\t\t\t\tht_old->refcnt++;\n\t\t\t}\n\t\t\t__u32_destroy_key(new);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (!tc_in_hw(new->flags))\n\t\t\tnew->flags |= TCA_CLS_FLAGS_NOT_IN_HW;\n\n\t\tu32_replace_knode(tp, tp_c, new);\n\t\ttcf_unbind_filter(tp, &n->res);\n\t\ttcf_exts_get_net(&n->exts);\n\t\ttcf_queue_work(&n->rwork, u32_delete_key_work);\n\t\treturn 0;\n\t}\n\n\tif (tb[TCA_U32_DIVISOR]) {\n\t\tunsigned int divisor = nla_get_u32(tb[TCA_U32_DIVISOR]);\n\n\t\tif (!is_power_of_2(divisor)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Divisor is not a power of 2\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (divisor-- > 0x100) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded maximum 256 hash buckets\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (TC_U32_KEY(handle)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Divisor can only be used on a hash table\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tht = kzalloc(struct_size(ht, ht, divisor + 1), GFP_KERNEL);\n\t\tif (ht == NULL)\n\t\t\treturn -ENOBUFS;\n\t\tif (handle == 0) {\n\t\t\thandle = gen_new_htid(tp->data, ht);\n\t\t\tif (handle == 0) {\n\t\t\t\tkfree(ht);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\terr = idr_alloc_u32(&tp_c->handle_idr, ht, &handle,\n\t\t\t\t\t    handle, GFP_KERNEL);\n\t\t\tif (err) {\n\t\t\t\tkfree(ht);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tht->refcnt = 1;\n\t\tht->divisor = divisor;\n\t\tht->handle = handle;\n\t\tht->prio = tp->prio;\n\t\tidr_init(&ht->handle_idr);\n\t\tht->flags = userflags;\n\n\t\terr = u32_replace_hw_hnode(tp, ht, userflags, extack);\n\t\tif (err) {\n\t\t\tidr_remove(&tp_c->handle_idr, handle);\n\t\t\tkfree(ht);\n\t\t\treturn err;\n\t\t}\n\n\t\tRCU_INIT_POINTER(ht->next, tp_c->hlist);\n\t\trcu_assign_pointer(tp_c->hlist, ht);\n\t\t*arg = ht;\n\n\t\treturn 0;\n\t}\n\n\tif (tb[TCA_U32_HASH]) {\n\t\thtid = nla_get_u32(tb[TCA_U32_HASH]);\n\t\tif (TC_U32_HTID(htid) == TC_U32_ROOT) {\n\t\t\tht = rtnl_dereference(tp->root);\n\t\t\thtid = ht->handle;\n\t\t} else {\n\t\t\tht = u32_lookup_ht(tp->data, TC_U32_HTID(htid));\n\t\t\tif (!ht) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Specified hash table not found\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tht = rtnl_dereference(tp->root);\n\t\thtid = ht->handle;\n\t}\n\n\tif (ht->divisor < TC_U32_HASH(htid)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Specified hash table buckets exceed configured value\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (handle) {\n\t\t \n\t\tif (TC_U32_HTID(handle) && TC_U32_HTID(handle ^ htid)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Handle specified hash table address mismatch\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (!TC_U32_NODE(handle)) {\n\t\t\thandle = gen_new_kid(ht, htid);\n\t\t} else {\n\t\t\thandle = htid | TC_U32_NODE(handle);\n\t\t\terr = idr_alloc_u32(&ht->handle_idr, NULL, &handle,\n\t\t\t\t\t    handle, GFP_KERNEL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\t \n\t\thandle = gen_new_kid(ht, htid);\n\t}\n\n\tif (tb[TCA_U32_SEL] == NULL) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Selector not specified\");\n\t\terr = -EINVAL;\n\t\tgoto erridr;\n\t}\n\n\ts = nla_data(tb[TCA_U32_SEL]);\n\tsel_size = struct_size(s, keys, s->nkeys);\n\tif (nla_len(tb[TCA_U32_SEL]) < sel_size) {\n\t\terr = -EINVAL;\n\t\tgoto erridr;\n\t}\n\n\tn = kzalloc(struct_size(n, sel.keys, s->nkeys), GFP_KERNEL);\n\tif (n == NULL) {\n\t\terr = -ENOBUFS;\n\t\tgoto erridr;\n\t}\n\n#ifdef CONFIG_CLS_U32_PERF\n\tn->pf = __alloc_percpu(struct_size(n->pf, kcnts, s->nkeys),\n\t\t\t       __alignof__(struct tc_u32_pcnt));\n\tif (!n->pf) {\n\t\terr = -ENOBUFS;\n\t\tgoto errfree;\n\t}\n#endif\n\n\tunsafe_memcpy(&n->sel, s, sel_size,\n\t\t       );\n\tRCU_INIT_POINTER(n->ht_up, ht);\n\tn->handle = handle;\n\tn->fshift = s->hmask ? ffs(ntohl(s->hmask)) - 1 : 0;\n\tn->flags = userflags;\n\n\terr = tcf_exts_init(&n->exts, net, TCA_U32_ACT, TCA_U32_POLICE);\n\tif (err < 0)\n\t\tgoto errout;\n\n#ifdef CONFIG_CLS_U32_MARK\n\tn->pcpu_success = alloc_percpu(u32);\n\tif (!n->pcpu_success) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tif (tb[TCA_U32_MARK]) {\n\t\tstruct tc_u32_mark *mark;\n\n\t\tmark = nla_data(tb[TCA_U32_MARK]);\n\t\tn->val = mark->val;\n\t\tn->mask = mark->mask;\n\t}\n#endif\n\n\terr = u32_set_parms(net, tp, n, tb, tca[TCA_RATE],\n\t\t\t    flags, n->flags, extack);\n\n\tu32_bind_filter(tp, n, base, tb);\n\n\tif (err == 0) {\n\t\tstruct tc_u_knode __rcu **ins;\n\t\tstruct tc_u_knode *pins;\n\n\t\terr = u32_replace_hw_knode(tp, n, flags, extack);\n\t\tif (err)\n\t\t\tgoto errunbind;\n\n\t\tif (!tc_in_hw(n->flags))\n\t\t\tn->flags |= TCA_CLS_FLAGS_NOT_IN_HW;\n\n\t\tins = &ht->ht[TC_U32_HASH(handle)];\n\t\tfor (pins = rtnl_dereference(*ins); pins;\n\t\t     ins = &pins->next, pins = rtnl_dereference(*ins))\n\t\t\tif (TC_U32_NODE(handle) < TC_U32_NODE(pins->handle))\n\t\t\t\tbreak;\n\n\t\tRCU_INIT_POINTER(n->next, pins);\n\t\trcu_assign_pointer(*ins, n);\n\t\ttp_c->knodes++;\n\t\t*arg = n;\n\t\treturn 0;\n\t}\n\nerrunbind:\n\tu32_unbind_filter(tp, n, tb);\n\n#ifdef CONFIG_CLS_U32_MARK\n\tfree_percpu(n->pcpu_success);\n#endif\n\nerrout:\n\ttcf_exts_destroy(&n->exts);\n#ifdef CONFIG_CLS_U32_PERF\nerrfree:\n\tfree_percpu(n->pf);\n#endif\n\tkfree(n);\nerridr:\n\tidr_remove(&ht->handle_idr, handle);\n\treturn err;\n}\n\nstatic void u32_walk(struct tcf_proto *tp, struct tcf_walker *arg,\n\t\t     bool rtnl_held)\n{\n\tstruct tc_u_common *tp_c = tp->data;\n\tstruct tc_u_hnode *ht;\n\tstruct tc_u_knode *n;\n\tunsigned int h;\n\n\tif (arg->stop)\n\t\treturn;\n\n\tfor (ht = rtnl_dereference(tp_c->hlist);\n\t     ht;\n\t     ht = rtnl_dereference(ht->next)) {\n\t\tif (ht->prio != tp->prio)\n\t\t\tcontinue;\n\n\t\tif (!tc_cls_stats_dump(tp, arg, ht))\n\t\t\treturn;\n\n\t\tfor (h = 0; h <= ht->divisor; h++) {\n\t\t\tfor (n = rtnl_dereference(ht->ht[h]);\n\t\t\t     n;\n\t\t\t     n = rtnl_dereference(n->next)) {\n\t\t\t\tif (!tc_cls_stats_dump(tp, arg, n))\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int u32_reoffload_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht,\n\t\t\t       bool add, flow_setup_cb_t *cb, void *cb_priv,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct tc_cls_u32_offload cls_u32 = {};\n\tint err;\n\n\ttc_cls_common_offload_init(&cls_u32.common, tp, ht->flags, extack);\n\tcls_u32.command = add ? TC_CLSU32_NEW_HNODE : TC_CLSU32_DELETE_HNODE;\n\tcls_u32.hnode.divisor = ht->divisor;\n\tcls_u32.hnode.handle = ht->handle;\n\tcls_u32.hnode.prio = ht->prio;\n\n\terr = cb(TC_SETUP_CLSU32, &cls_u32, cb_priv);\n\tif (err && add && tc_skip_sw(ht->flags))\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int u32_reoffload_knode(struct tcf_proto *tp, struct tc_u_knode *n,\n\t\t\t       bool add, flow_setup_cb_t *cb, void *cb_priv,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct tc_u_hnode *ht = rtnl_dereference(n->ht_down);\n\tstruct tcf_block *block = tp->chain->block;\n\tstruct tc_cls_u32_offload cls_u32 = {};\n\n\ttc_cls_common_offload_init(&cls_u32.common, tp, n->flags, extack);\n\tcls_u32.command = add ?\n\t\tTC_CLSU32_REPLACE_KNODE : TC_CLSU32_DELETE_KNODE;\n\tcls_u32.knode.handle = n->handle;\n\n\tif (add) {\n\t\tcls_u32.knode.fshift = n->fshift;\n#ifdef CONFIG_CLS_U32_MARK\n\t\tcls_u32.knode.val = n->val;\n\t\tcls_u32.knode.mask = n->mask;\n#else\n\t\tcls_u32.knode.val = 0;\n\t\tcls_u32.knode.mask = 0;\n#endif\n\t\tcls_u32.knode.sel = &n->sel;\n\t\tcls_u32.knode.res = &n->res;\n\t\tcls_u32.knode.exts = &n->exts;\n\t\tif (n->ht_down)\n\t\t\tcls_u32.knode.link_handle = ht->handle;\n\t}\n\n\treturn tc_setup_cb_reoffload(block, tp, add, cb, TC_SETUP_CLSU32,\n\t\t\t\t     &cls_u32, cb_priv, &n->flags,\n\t\t\t\t     &n->in_hw_count);\n}\n\nstatic int u32_reoffload(struct tcf_proto *tp, bool add, flow_setup_cb_t *cb,\n\t\t\t void *cb_priv, struct netlink_ext_ack *extack)\n{\n\tstruct tc_u_common *tp_c = tp->data;\n\tstruct tc_u_hnode *ht;\n\tstruct tc_u_knode *n;\n\tunsigned int h;\n\tint err;\n\n\tfor (ht = rtnl_dereference(tp_c->hlist);\n\t     ht;\n\t     ht = rtnl_dereference(ht->next)) {\n\t\tif (ht->prio != tp->prio)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (add && !tc_skip_hw(ht->flags)) {\n\t\t\terr = u32_reoffload_hnode(tp, ht, add, cb, cb_priv,\n\t\t\t\t\t\t  extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfor (h = 0; h <= ht->divisor; h++) {\n\t\t\tfor (n = rtnl_dereference(ht->ht[h]);\n\t\t\t     n;\n\t\t\t     n = rtnl_dereference(n->next)) {\n\t\t\t\tif (tc_skip_hw(n->flags))\n\t\t\t\t\tcontinue;\n\n\t\t\t\terr = u32_reoffload_knode(tp, n, add, cb,\n\t\t\t\t\t\t\t  cb_priv, extack);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tif (!add && !tc_skip_hw(ht->flags))\n\t\t\tu32_reoffload_hnode(tp, ht, add, cb, cb_priv, extack);\n\t}\n\n\treturn 0;\n}\n\nstatic void u32_bind_class(void *fh, u32 classid, unsigned long cl, void *q,\n\t\t\t   unsigned long base)\n{\n\tstruct tc_u_knode *n = fh;\n\n\ttc_cls_bind_class(classid, cl, q, &n->res, base);\n}\n\nstatic int u32_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t    struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)\n{\n\tstruct tc_u_knode *n = fh;\n\tstruct tc_u_hnode *ht_up, *ht_down;\n\tstruct nlattr *nest;\n\n\tif (n == NULL)\n\t\treturn skb->len;\n\n\tt->tcm_handle = n->handle;\n\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (TC_U32_KEY(n->handle) == 0) {\n\t\tstruct tc_u_hnode *ht = fh;\n\t\tu32 divisor = ht->divisor + 1;\n\n\t\tif (nla_put_u32(skb, TCA_U32_DIVISOR, divisor))\n\t\t\tgoto nla_put_failure;\n\t} else {\n#ifdef CONFIG_CLS_U32_PERF\n\t\tstruct tc_u32_pcnt *gpf;\n\t\tint cpu;\n#endif\n\n\t\tif (nla_put(skb, TCA_U32_SEL, struct_size(&n->sel, keys, n->sel.nkeys),\n\t\t\t    &n->sel))\n\t\t\tgoto nla_put_failure;\n\n\t\tht_up = rtnl_dereference(n->ht_up);\n\t\tif (ht_up) {\n\t\t\tu32 htid = n->handle & 0xFFFFF000;\n\t\t\tif (nla_put_u32(skb, TCA_U32_HASH, htid))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tif (n->res.classid &&\n\t\t    nla_put_u32(skb, TCA_U32_CLASSID, n->res.classid))\n\t\t\tgoto nla_put_failure;\n\n\t\tht_down = rtnl_dereference(n->ht_down);\n\t\tif (ht_down &&\n\t\t    nla_put_u32(skb, TCA_U32_LINK, ht_down->handle))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (n->flags && nla_put_u32(skb, TCA_U32_FLAGS, n->flags))\n\t\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_CLS_U32_MARK\n\t\tif ((n->val || n->mask)) {\n\t\t\tstruct tc_u32_mark mark = {.val = n->val,\n\t\t\t\t\t\t   .mask = n->mask,\n\t\t\t\t\t\t   .success = 0};\n\t\t\tint cpum;\n\n\t\t\tfor_each_possible_cpu(cpum) {\n\t\t\t\t__u32 cnt = *per_cpu_ptr(n->pcpu_success, cpum);\n\n\t\t\t\tmark.success += cnt;\n\t\t\t}\n\n\t\t\tif (nla_put(skb, TCA_U32_MARK, sizeof(mark), &mark))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#endif\n\n\t\tif (tcf_exts_dump(skb, &n->exts) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (n->ifindex) {\n\t\t\tstruct net_device *dev;\n\t\t\tdev = __dev_get_by_index(net, n->ifindex);\n\t\t\tif (dev && nla_put_string(skb, TCA_U32_INDEV, dev->name))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#ifdef CONFIG_CLS_U32_PERF\n\t\tgpf = kzalloc(struct_size(gpf, kcnts, n->sel.nkeys), GFP_KERNEL);\n\t\tif (!gpf)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tint i;\n\t\t\tstruct tc_u32_pcnt *pf = per_cpu_ptr(n->pf, cpu);\n\n\t\t\tgpf->rcnt += pf->rcnt;\n\t\t\tgpf->rhit += pf->rhit;\n\t\t\tfor (i = 0; i < n->sel.nkeys; i++)\n\t\t\t\tgpf->kcnts[i] += pf->kcnts[i];\n\t\t}\n\n\t\tif (nla_put_64bit(skb, TCA_U32_PCNT, struct_size(gpf, kcnts, n->sel.nkeys),\n\t\t\t\t  gpf, TCA_U32_PAD)) {\n\t\t\tkfree(gpf);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tkfree(gpf);\n#endif\n\t}\n\n\tnla_nest_end(skb, nest);\n\n\tif (TC_U32_KEY(n->handle))\n\t\tif (tcf_exts_dump_stats(skb, &n->exts) < 0)\n\t\t\tgoto nla_put_failure;\n\treturn skb->len;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic struct tcf_proto_ops cls_u32_ops __read_mostly = {\n\t.kind\t\t=\t\"u32\",\n\t.classify\t=\tu32_classify,\n\t.init\t\t=\tu32_init,\n\t.destroy\t=\tu32_destroy,\n\t.get\t\t=\tu32_get,\n\t.change\t\t=\tu32_change,\n\t.delete\t\t=\tu32_delete,\n\t.walk\t\t=\tu32_walk,\n\t.reoffload\t=\tu32_reoffload,\n\t.dump\t\t=\tu32_dump,\n\t.bind_class\t=\tu32_bind_class,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic int __init init_u32(void)\n{\n\tint i, ret;\n\n\tpr_info(\"u32 classifier\\n\");\n#ifdef CONFIG_CLS_U32_PERF\n\tpr_info(\"    Performance counters on\\n\");\n#endif\n\tpr_info(\"    input device check on\\n\");\n#ifdef CONFIG_NET_CLS_ACT\n\tpr_info(\"    Actions configured\\n\");\n#endif\n\ttc_u_common_hash = kvmalloc_array(U32_HASH_SIZE,\n\t\t\t\t\t  sizeof(struct hlist_head),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!tc_u_common_hash)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < U32_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&tc_u_common_hash[i]);\n\n\tret = register_tcf_proto_ops(&cls_u32_ops);\n\tif (ret)\n\t\tkvfree(tc_u_common_hash);\n\treturn ret;\n}\n\nstatic void __exit exit_u32(void)\n{\n\tunregister_tcf_proto_ops(&cls_u32_ops);\n\tkvfree(tc_u_common_hash);\n}\n\nmodule_init(init_u32)\nmodule_exit(exit_u32)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}