{
  "module_name": "ematch.c",
  "hash_id": "691be97f1af404c3a870652f9d7964e9e29aedf50a0d5e2a40e89815f7b5aca7",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/ematch.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <net/pkt_cls.h>\n\nstatic LIST_HEAD(ematch_ops);\nstatic DEFINE_RWLOCK(ematch_mod_lock);\n\nstatic struct tcf_ematch_ops *tcf_em_lookup(u16 kind)\n{\n\tstruct tcf_ematch_ops *e = NULL;\n\n\tread_lock(&ematch_mod_lock);\n\tlist_for_each_entry(e, &ematch_ops, link) {\n\t\tif (kind == e->kind) {\n\t\t\tif (!try_module_get(e->owner))\n\t\t\t\te = NULL;\n\t\t\tread_unlock(&ematch_mod_lock);\n\t\t\treturn e;\n\t\t}\n\t}\n\tread_unlock(&ematch_mod_lock);\n\n\treturn NULL;\n}\n\n \nint tcf_em_register(struct tcf_ematch_ops *ops)\n{\n\tint err = -EEXIST;\n\tstruct tcf_ematch_ops *e;\n\n\tif (ops->match == NULL)\n\t\treturn -EINVAL;\n\n\twrite_lock(&ematch_mod_lock);\n\tlist_for_each_entry(e, &ematch_ops, link)\n\t\tif (ops->kind == e->kind)\n\t\t\tgoto errout;\n\n\tlist_add_tail(&ops->link, &ematch_ops);\n\terr = 0;\nerrout:\n\twrite_unlock(&ematch_mod_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(tcf_em_register);\n\n \nvoid tcf_em_unregister(struct tcf_ematch_ops *ops)\n{\n\twrite_lock(&ematch_mod_lock);\n\tlist_del(&ops->link);\n\twrite_unlock(&ematch_mod_lock);\n}\nEXPORT_SYMBOL(tcf_em_unregister);\n\nstatic inline struct tcf_ematch *tcf_em_get_match(struct tcf_ematch_tree *tree,\n\t\t\t\t\t\t  int index)\n{\n\treturn &tree->matches[index];\n}\n\n\nstatic int tcf_em_validate(struct tcf_proto *tp,\n\t\t\t   struct tcf_ematch_tree_hdr *tree_hdr,\n\t\t\t   struct tcf_ematch *em, struct nlattr *nla, int idx)\n{\n\tint err = -EINVAL;\n\tstruct tcf_ematch_hdr *em_hdr = nla_data(nla);\n\tint data_len = nla_len(nla) - sizeof(*em_hdr);\n\tvoid *data = (void *) em_hdr + sizeof(*em_hdr);\n\tstruct net *net = tp->chain->block->net;\n\n\tif (!TCF_EM_REL_VALID(em_hdr->flags))\n\t\tgoto errout;\n\n\tif (em_hdr->kind == TCF_EM_CONTAINER) {\n\t\t \n\t\tu32 ref;\n\n\t\tif (data_len < sizeof(ref))\n\t\t\tgoto errout;\n\t\tref = *(u32 *) data;\n\n\t\tif (ref >= tree_hdr->nmatches)\n\t\t\tgoto errout;\n\n\t\t \n\t\tif (ref <= idx)\n\t\t\tgoto errout;\n\n\n\t\tem->data = ref;\n\t} else {\n\t\t \n\t\tem->ops = tcf_em_lookup(em_hdr->kind);\n\n\t\tif (em->ops == NULL) {\n\t\t\terr = -ENOENT;\n#ifdef CONFIG_MODULES\n\t\t\t__rtnl_unlock();\n\t\t\trequest_module(\"ematch-kind-%u\", em_hdr->kind);\n\t\t\trtnl_lock();\n\t\t\tem->ops = tcf_em_lookup(em_hdr->kind);\n\t\t\tif (em->ops) {\n\t\t\t\t \n\t\t\t\tmodule_put(em->ops->owner);\n\t\t\t\tem->ops = NULL;\n\t\t\t\terr = -EAGAIN;\n\t\t\t}\n#endif\n\t\t\tgoto errout;\n\t\t}\n\n\t\t \n\t\tif (em->ops->datalen && data_len < em->ops->datalen)\n\t\t\tgoto errout;\n\n\t\tif (em->ops->change) {\n\t\t\terr = -EINVAL;\n\t\t\tif (em_hdr->flags & TCF_EM_SIMPLE)\n\t\t\t\tgoto errout;\n\t\t\terr = em->ops->change(net, data, data_len, em);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t} else if (data_len > 0) {\n\t\t\t \n\t\t\tif (em_hdr->flags & TCF_EM_SIMPLE) {\n\t\t\t\tif (em->ops->datalen > 0)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (data_len < sizeof(u32))\n\t\t\t\t\tgoto errout;\n\t\t\t\tem->data = *(u32 *) data;\n\t\t\t} else {\n\t\t\t\tvoid *v = kmemdup(data, data_len, GFP_KERNEL);\n\t\t\t\tif (v == NULL) {\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\t\tgoto errout;\n\t\t\t\t}\n\t\t\t\tem->data = (unsigned long) v;\n\t\t\t}\n\t\t\tem->datalen = data_len;\n\t\t}\n\t}\n\n\tem->matchid = em_hdr->matchid;\n\tem->flags = em_hdr->flags;\n\tem->net = net;\n\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstatic const struct nla_policy em_policy[TCA_EMATCH_TREE_MAX + 1] = {\n\t[TCA_EMATCH_TREE_HDR]\t= { .len = sizeof(struct tcf_ematch_tree_hdr) },\n\t[TCA_EMATCH_TREE_LIST]\t= { .type = NLA_NESTED },\n};\n\n \nint tcf_em_tree_validate(struct tcf_proto *tp, struct nlattr *nla,\n\t\t\t struct tcf_ematch_tree *tree)\n{\n\tint idx, list_len, matches_len, err;\n\tstruct nlattr *tb[TCA_EMATCH_TREE_MAX + 1];\n\tstruct nlattr *rt_match, *rt_hdr, *rt_list;\n\tstruct tcf_ematch_tree_hdr *tree_hdr;\n\tstruct tcf_ematch *em;\n\n\tmemset(tree, 0, sizeof(*tree));\n\tif (!nla)\n\t\treturn 0;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_EMATCH_TREE_MAX, nla,\n\t\t\t\t\t  em_policy, NULL);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\trt_hdr = tb[TCA_EMATCH_TREE_HDR];\n\trt_list = tb[TCA_EMATCH_TREE_LIST];\n\n\tif (rt_hdr == NULL || rt_list == NULL)\n\t\tgoto errout;\n\n\ttree_hdr = nla_data(rt_hdr);\n\tmemcpy(&tree->hdr, tree_hdr, sizeof(*tree_hdr));\n\n\trt_match = nla_data(rt_list);\n\tlist_len = nla_len(rt_list);\n\tmatches_len = tree_hdr->nmatches * sizeof(*em);\n\n\ttree->matches = kzalloc(matches_len, GFP_KERNEL);\n\tif (tree->matches == NULL)\n\t\tgoto errout;\n\n\t \n\tfor (idx = 0; nla_ok(rt_match, list_len); idx++) {\n\t\terr = -EINVAL;\n\n\t\tif (rt_match->nla_type != (idx + 1))\n\t\t\tgoto errout_abort;\n\n\t\tif (idx >= tree_hdr->nmatches)\n\t\t\tgoto errout_abort;\n\n\t\tif (nla_len(rt_match) < sizeof(struct tcf_ematch_hdr))\n\t\t\tgoto errout_abort;\n\n\t\tem = tcf_em_get_match(tree, idx);\n\n\t\terr = tcf_em_validate(tp, tree_hdr, em, rt_match, idx);\n\t\tif (err < 0)\n\t\t\tgoto errout_abort;\n\n\t\trt_match = nla_next(rt_match, &list_len);\n\t}\n\n\t \n\tif (idx != tree_hdr->nmatches) {\n\t\terr = -EINVAL;\n\t\tgoto errout_abort;\n\t}\n\n\terr = 0;\nerrout:\n\treturn err;\n\nerrout_abort:\n\ttcf_em_tree_destroy(tree);\n\treturn err;\n}\nEXPORT_SYMBOL(tcf_em_tree_validate);\n\n \nvoid tcf_em_tree_destroy(struct tcf_ematch_tree *tree)\n{\n\tint i;\n\n\tif (tree->matches == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < tree->hdr.nmatches; i++) {\n\t\tstruct tcf_ematch *em = tcf_em_get_match(tree, i);\n\n\t\tif (em->ops) {\n\t\t\tif (em->ops->destroy)\n\t\t\t\tem->ops->destroy(em);\n\t\t\telse if (!tcf_em_is_simple(em))\n\t\t\t\tkfree((void *) em->data);\n\t\t\tmodule_put(em->ops->owner);\n\t\t}\n\t}\n\n\ttree->hdr.nmatches = 0;\n\tkfree(tree->matches);\n\ttree->matches = NULL;\n}\nEXPORT_SYMBOL(tcf_em_tree_destroy);\n\n \nint tcf_em_tree_dump(struct sk_buff *skb, struct tcf_ematch_tree *tree, int tlv)\n{\n\tint i;\n\tu8 *tail;\n\tstruct nlattr *top_start;\n\tstruct nlattr *list_start;\n\n\ttop_start = nla_nest_start_noflag(skb, tlv);\n\tif (top_start == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(skb, TCA_EMATCH_TREE_HDR, sizeof(tree->hdr), &tree->hdr))\n\t\tgoto nla_put_failure;\n\n\tlist_start = nla_nest_start_noflag(skb, TCA_EMATCH_TREE_LIST);\n\tif (list_start == NULL)\n\t\tgoto nla_put_failure;\n\n\ttail = skb_tail_pointer(skb);\n\tfor (i = 0; i < tree->hdr.nmatches; i++) {\n\t\tstruct nlattr *match_start = (struct nlattr *)tail;\n\t\tstruct tcf_ematch *em = tcf_em_get_match(tree, i);\n\t\tstruct tcf_ematch_hdr em_hdr = {\n\t\t\t.kind = em->ops ? em->ops->kind : TCF_EM_CONTAINER,\n\t\t\t.matchid = em->matchid,\n\t\t\t.flags = em->flags\n\t\t};\n\n\t\tif (nla_put(skb, i + 1, sizeof(em_hdr), &em_hdr))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (em->ops && em->ops->dump) {\n\t\t\tif (em->ops->dump(skb, em) < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t} else if (tcf_em_is_container(em) || tcf_em_is_simple(em)) {\n\t\t\tu32 u = em->data;\n\t\t\tnla_put_nohdr(skb, sizeof(u), &u);\n\t\t} else if (em->datalen > 0)\n\t\t\tnla_put_nohdr(skb, em->datalen, (void *) em->data);\n\n\t\ttail = skb_tail_pointer(skb);\n\t\tmatch_start->nla_len = tail - (u8 *)match_start;\n\t}\n\n\tnla_nest_end(skb, list_start);\n\tnla_nest_end(skb, top_start);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\nEXPORT_SYMBOL(tcf_em_tree_dump);\n\nstatic inline int tcf_em_match(struct sk_buff *skb, struct tcf_ematch *em,\n\t\t\t       struct tcf_pkt_info *info)\n{\n\tint r = em->ops->match(skb, em, info);\n\n\treturn tcf_em_is_inverted(em) ? !r : r;\n}\n\n \nint __tcf_em_tree_match(struct sk_buff *skb, struct tcf_ematch_tree *tree,\n\t\t\tstruct tcf_pkt_info *info)\n{\n\tint stackp = 0, match_idx = 0, res = 0;\n\tstruct tcf_ematch *cur_match;\n\tint stack[CONFIG_NET_EMATCH_STACK];\n\nproceed:\n\twhile (match_idx < tree->hdr.nmatches) {\n\t\tcur_match = tcf_em_get_match(tree, match_idx);\n\n\t\tif (tcf_em_is_container(cur_match)) {\n\t\t\tif (unlikely(stackp >= CONFIG_NET_EMATCH_STACK))\n\t\t\t\tgoto stack_overflow;\n\n\t\t\tstack[stackp++] = match_idx;\n\t\t\tmatch_idx = cur_match->data;\n\t\t\tgoto proceed;\n\t\t}\n\n\t\tres = tcf_em_match(skb, cur_match, info);\n\n\t\tif (tcf_em_early_end(cur_match, res))\n\t\t\tbreak;\n\n\t\tmatch_idx++;\n\t}\n\npop_stack:\n\tif (stackp > 0) {\n\t\tmatch_idx = stack[--stackp];\n\t\tcur_match = tcf_em_get_match(tree, match_idx);\n\n\t\tif (tcf_em_is_inverted(cur_match))\n\t\t\tres = !res;\n\n\t\tif (tcf_em_early_end(cur_match, res)) {\n\t\t\tgoto pop_stack;\n\t\t} else {\n\t\t\tmatch_idx++;\n\t\t\tgoto proceed;\n\t\t}\n\t}\n\n\treturn res;\n\nstack_overflow:\n\tnet_warn_ratelimited(\"tc ematch: local stack overflow, increase NET_EMATCH_STACK\\n\");\n\treturn -1;\n}\nEXPORT_SYMBOL(__tcf_em_tree_match);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}