{
  "module_name": "act_police.c",
  "hash_id": "8ccab70decc2f662deba52f5b6e168369939d34dac3c422b129759b14fdea600",
  "original_prompt": "Ingested from linux-6.6.14/net/sched/act_police.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/act_api.h>\n#include <net/gso.h>\n#include <net/netlink.h>\n#include <net/pkt_cls.h>\n#include <net/tc_act/tc_police.h>\n#include <net/tc_wrapper.h>\n\n \n\nstatic struct tc_action_ops act_police_ops;\n\nstatic const struct nla_policy police_policy[TCA_POLICE_MAX + 1] = {\n\t[TCA_POLICE_RATE]\t= { .len = TC_RTAB_SIZE },\n\t[TCA_POLICE_PEAKRATE]\t= { .len = TC_RTAB_SIZE },\n\t[TCA_POLICE_AVRATE]\t= { .type = NLA_U32 },\n\t[TCA_POLICE_RESULT]\t= { .type = NLA_U32 },\n\t[TCA_POLICE_RATE64]     = { .type = NLA_U64 },\n\t[TCA_POLICE_PEAKRATE64] = { .type = NLA_U64 },\n\t[TCA_POLICE_PKTRATE64]  = { .type = NLA_U64, .min = 1 },\n\t[TCA_POLICE_PKTBURST64] = { .type = NLA_U64, .min = 1 },\n};\n\nstatic int tcf_police_init(struct net *net, struct nlattr *nla,\n\t\t\t       struct nlattr *est, struct tc_action **a,\n\t\t\t       struct tcf_proto *tp, u32 flags,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tint ret = 0, tcfp_result = TC_ACT_OK, err, size;\n\tbool bind = flags & TCA_ACT_FLAGS_BIND;\n\tstruct nlattr *tb[TCA_POLICE_MAX + 1];\n\tstruct tcf_chain *goto_ch = NULL;\n\tstruct tc_police *parm;\n\tstruct tcf_police *police;\n\tstruct qdisc_rate_table *R_tab = NULL, *P_tab = NULL;\n\tstruct tc_action_net *tn = net_generic(net, act_police_ops.net_id);\n\tstruct tcf_police_params *new;\n\tbool exists = false;\n\tu32 index;\n\tu64 rate64, prate64;\n\tu64 pps, ppsburst;\n\n\tif (nla == NULL)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_POLICE_MAX, nla,\n\t\t\t\t\t  police_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_POLICE_TBF] == NULL)\n\t\treturn -EINVAL;\n\tsize = nla_len(tb[TCA_POLICE_TBF]);\n\tif (size != sizeof(*parm) && size != sizeof(struct tc_police_compat))\n\t\treturn -EINVAL;\n\n\tparm = nla_data(tb[TCA_POLICE_TBF]);\n\tindex = parm->index;\n\terr = tcf_idr_check_alloc(tn, &index, a, bind);\n\tif (err < 0)\n\t\treturn err;\n\texists = err;\n\tif (exists && bind)\n\t\treturn 0;\n\n\tif (!exists) {\n\t\tret = tcf_idr_create(tn, index, NULL, a,\n\t\t\t\t     &act_police_ops, bind, true, flags);\n\t\tif (ret) {\n\t\t\ttcf_idr_cleanup(tn, index);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ACT_P_CREATED;\n\t\tspin_lock_init(&(to_police(*a)->tcfp_lock));\n\t} else if (!(flags & TCA_ACT_FLAGS_REPLACE)) {\n\t\ttcf_idr_release(*a, bind);\n\t\treturn -EEXIST;\n\t}\n\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);\n\tif (err < 0)\n\t\tgoto release_idr;\n\n\tpolice = to_police(*a);\n\tif (parm->rate.rate) {\n\t\terr = -ENOMEM;\n\t\tR_tab = qdisc_get_rtab(&parm->rate, tb[TCA_POLICE_RATE], NULL);\n\t\tif (R_tab == NULL)\n\t\t\tgoto failure;\n\n\t\tif (parm->peakrate.rate) {\n\t\t\tP_tab = qdisc_get_rtab(&parm->peakrate,\n\t\t\t\t\t       tb[TCA_POLICE_PEAKRATE], NULL);\n\t\t\tif (P_tab == NULL)\n\t\t\t\tgoto failure;\n\t\t}\n\t}\n\n\tif (est) {\n\t\terr = gen_replace_estimator(&police->tcf_bstats,\n\t\t\t\t\t    police->common.cpu_bstats,\n\t\t\t\t\t    &police->tcf_rate_est,\n\t\t\t\t\t    &police->tcf_lock,\n\t\t\t\t\t    false, est);\n\t\tif (err)\n\t\t\tgoto failure;\n\t} else if (tb[TCA_POLICE_AVRATE] &&\n\t\t   (ret == ACT_P_CREATED ||\n\t\t    !gen_estimator_active(&police->tcf_rate_est))) {\n\t\terr = -EINVAL;\n\t\tgoto failure;\n\t}\n\n\tif (tb[TCA_POLICE_RESULT]) {\n\t\ttcfp_result = nla_get_u32(tb[TCA_POLICE_RESULT]);\n\t\tif (TC_ACT_EXT_CMP(tcfp_result, TC_ACT_GOTO_CHAIN)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"goto chain not allowed on fallback\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto failure;\n\t\t}\n\t}\n\n\tif ((tb[TCA_POLICE_PKTRATE64] && !tb[TCA_POLICE_PKTBURST64]) ||\n\t    (!tb[TCA_POLICE_PKTRATE64] && tb[TCA_POLICE_PKTBURST64])) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Both or neither packet-per-second burst and rate must be provided\");\n\t\terr = -EINVAL;\n\t\tgoto failure;\n\t}\n\n\tif (tb[TCA_POLICE_PKTRATE64] && R_tab) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"packet-per-second and byte-per-second rate limits not allowed in same action\");\n\t\terr = -EINVAL;\n\t\tgoto failure;\n\t}\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (unlikely(!new)) {\n\t\terr = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\t \n\tnew->tcfp_result = tcfp_result;\n\tnew->tcfp_mtu = parm->mtu;\n\tif (!new->tcfp_mtu) {\n\t\tnew->tcfp_mtu = ~0;\n\t\tif (R_tab)\n\t\t\tnew->tcfp_mtu = 255 << R_tab->rate.cell_log;\n\t}\n\tif (R_tab) {\n\t\tnew->rate_present = true;\n\t\trate64 = tb[TCA_POLICE_RATE64] ?\n\t\t\t nla_get_u64(tb[TCA_POLICE_RATE64]) : 0;\n\t\tpsched_ratecfg_precompute(&new->rate, &R_tab->rate, rate64);\n\t\tqdisc_put_rtab(R_tab);\n\t} else {\n\t\tnew->rate_present = false;\n\t}\n\tif (P_tab) {\n\t\tnew->peak_present = true;\n\t\tprate64 = tb[TCA_POLICE_PEAKRATE64] ?\n\t\t\t  nla_get_u64(tb[TCA_POLICE_PEAKRATE64]) : 0;\n\t\tpsched_ratecfg_precompute(&new->peak, &P_tab->rate, prate64);\n\t\tqdisc_put_rtab(P_tab);\n\t} else {\n\t\tnew->peak_present = false;\n\t}\n\n\tnew->tcfp_burst = PSCHED_TICKS2NS(parm->burst);\n\tif (new->peak_present)\n\t\tnew->tcfp_mtu_ptoks = (s64)psched_l2t_ns(&new->peak,\n\t\t\t\t\t\t\t new->tcfp_mtu);\n\n\tif (tb[TCA_POLICE_AVRATE])\n\t\tnew->tcfp_ewma_rate = nla_get_u32(tb[TCA_POLICE_AVRATE]);\n\n\tif (tb[TCA_POLICE_PKTRATE64]) {\n\t\tpps = nla_get_u64(tb[TCA_POLICE_PKTRATE64]);\n\t\tppsburst = nla_get_u64(tb[TCA_POLICE_PKTBURST64]);\n\t\tnew->pps_present = true;\n\t\tnew->tcfp_pkt_burst = PSCHED_TICKS2NS(ppsburst);\n\t\tpsched_ppscfg_precompute(&new->ppsrate, pps);\n\t}\n\n\tspin_lock_bh(&police->tcf_lock);\n\tspin_lock_bh(&police->tcfp_lock);\n\tpolice->tcfp_t_c = ktime_get_ns();\n\tpolice->tcfp_toks = new->tcfp_burst;\n\tif (new->peak_present)\n\t\tpolice->tcfp_ptoks = new->tcfp_mtu_ptoks;\n\tspin_unlock_bh(&police->tcfp_lock);\n\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);\n\tnew = rcu_replace_pointer(police->params,\n\t\t\t\t  new,\n\t\t\t\t  lockdep_is_held(&police->tcf_lock));\n\tspin_unlock_bh(&police->tcf_lock);\n\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\n\tif (new)\n\t\tkfree_rcu(new, rcu);\n\n\treturn ret;\n\nfailure:\n\tqdisc_put_rtab(P_tab);\n\tqdisc_put_rtab(R_tab);\n\tif (goto_ch)\n\t\ttcf_chain_put_by_act(goto_ch);\nrelease_idr:\n\ttcf_idr_release(*a, bind);\n\treturn err;\n}\n\nstatic bool tcf_police_mtu_check(struct sk_buff *skb, u32 limit)\n{\n\tu32 len;\n\n\tif (skb_is_gso(skb))\n\t\treturn skb_gso_validate_mac_len(skb, limit);\n\n\tlen = qdisc_pkt_len(skb);\n\tif (skb_at_tc_ingress(skb))\n\t\tlen += skb->mac_len;\n\n\treturn len <= limit;\n}\n\nTC_INDIRECT_SCOPE int tcf_police_act(struct sk_buff *skb,\n\t\t\t\t     const struct tc_action *a,\n\t\t\t\t     struct tcf_result *res)\n{\n\tstruct tcf_police *police = to_police(a);\n\ts64 now, toks, ppstoks = 0, ptoks = 0;\n\tstruct tcf_police_params *p;\n\tint ret;\n\n\ttcf_lastuse_update(&police->tcf_tm);\n\tbstats_update(this_cpu_ptr(police->common.cpu_bstats), skb);\n\n\tret = READ_ONCE(police->tcf_action);\n\tp = rcu_dereference_bh(police->params);\n\n\tif (p->tcfp_ewma_rate) {\n\t\tstruct gnet_stats_rate_est64 sample;\n\n\t\tif (!gen_estimator_read(&police->tcf_rate_est, &sample) ||\n\t\t    sample.bps >= p->tcfp_ewma_rate)\n\t\t\tgoto inc_overlimits;\n\t}\n\n\tif (tcf_police_mtu_check(skb, p->tcfp_mtu)) {\n\t\tif (!p->rate_present && !p->pps_present) {\n\t\t\tret = p->tcfp_result;\n\t\t\tgoto end;\n\t\t}\n\n\t\tnow = ktime_get_ns();\n\t\tspin_lock_bh(&police->tcfp_lock);\n\t\ttoks = min_t(s64, now - police->tcfp_t_c, p->tcfp_burst);\n\t\tif (p->peak_present) {\n\t\t\tptoks = toks + police->tcfp_ptoks;\n\t\t\tif (ptoks > p->tcfp_mtu_ptoks)\n\t\t\t\tptoks = p->tcfp_mtu_ptoks;\n\t\t\tptoks -= (s64)psched_l2t_ns(&p->peak,\n\t\t\t\t\t\t    qdisc_pkt_len(skb));\n\t\t}\n\t\tif (p->rate_present) {\n\t\t\ttoks += police->tcfp_toks;\n\t\t\tif (toks > p->tcfp_burst)\n\t\t\t\ttoks = p->tcfp_burst;\n\t\t\ttoks -= (s64)psched_l2t_ns(&p->rate, qdisc_pkt_len(skb));\n\t\t} else if (p->pps_present) {\n\t\t\tppstoks = min_t(s64, now - police->tcfp_t_c, p->tcfp_pkt_burst);\n\t\t\tppstoks += police->tcfp_pkttoks;\n\t\t\tif (ppstoks > p->tcfp_pkt_burst)\n\t\t\t\tppstoks = p->tcfp_pkt_burst;\n\t\t\tppstoks -= (s64)psched_pkt2t_ns(&p->ppsrate, 1);\n\t\t}\n\t\tif ((toks | ptoks | ppstoks) >= 0) {\n\t\t\tpolice->tcfp_t_c = now;\n\t\t\tpolice->tcfp_toks = toks;\n\t\t\tpolice->tcfp_ptoks = ptoks;\n\t\t\tpolice->tcfp_pkttoks = ppstoks;\n\t\t\tspin_unlock_bh(&police->tcfp_lock);\n\t\t\tret = p->tcfp_result;\n\t\t\tgoto inc_drops;\n\t\t}\n\t\tspin_unlock_bh(&police->tcfp_lock);\n\t}\n\ninc_overlimits:\n\tqstats_overlimit_inc(this_cpu_ptr(police->common.cpu_qstats));\ninc_drops:\n\tif (ret == TC_ACT_SHOT)\n\t\tqstats_drop_inc(this_cpu_ptr(police->common.cpu_qstats));\nend:\n\treturn ret;\n}\n\nstatic void tcf_police_cleanup(struct tc_action *a)\n{\n\tstruct tcf_police *police = to_police(a);\n\tstruct tcf_police_params *p;\n\n\tp = rcu_dereference_protected(police->params, 1);\n\tif (p)\n\t\tkfree_rcu(p, rcu);\n}\n\nstatic void tcf_police_stats_update(struct tc_action *a,\n\t\t\t\t    u64 bytes, u64 packets, u64 drops,\n\t\t\t\t    u64 lastuse, bool hw)\n{\n\tstruct tcf_police *police = to_police(a);\n\tstruct tcf_t *tm = &police->tcf_tm;\n\n\ttcf_action_update_stats(a, bytes, packets, drops, hw);\n\ttm->lastuse = max_t(u64, tm->lastuse, lastuse);\n}\n\nstatic int tcf_police_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t       int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_police *police = to_police(a);\n\tstruct tcf_police_params *p;\n\tstruct tc_police opt = {\n\t\t.index = police->tcf_index,\n\t\t.refcnt = refcount_read(&police->tcf_refcnt) - ref,\n\t\t.bindcnt = atomic_read(&police->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t t;\n\n\tspin_lock_bh(&police->tcf_lock);\n\topt.action = police->tcf_action;\n\tp = rcu_dereference_protected(police->params,\n\t\t\t\t      lockdep_is_held(&police->tcf_lock));\n\topt.mtu = p->tcfp_mtu;\n\topt.burst = PSCHED_NS2TICKS(p->tcfp_burst);\n\tif (p->rate_present) {\n\t\tpsched_ratecfg_getrate(&opt.rate, &p->rate);\n\t\tif ((p->rate.rate_bytes_ps >= (1ULL << 32)) &&\n\t\t    nla_put_u64_64bit(skb, TCA_POLICE_RATE64,\n\t\t\t\t      p->rate.rate_bytes_ps,\n\t\t\t\t      TCA_POLICE_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (p->peak_present) {\n\t\tpsched_ratecfg_getrate(&opt.peakrate, &p->peak);\n\t\tif ((p->peak.rate_bytes_ps >= (1ULL << 32)) &&\n\t\t    nla_put_u64_64bit(skb, TCA_POLICE_PEAKRATE64,\n\t\t\t\t      p->peak.rate_bytes_ps,\n\t\t\t\t      TCA_POLICE_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (p->pps_present) {\n\t\tif (nla_put_u64_64bit(skb, TCA_POLICE_PKTRATE64,\n\t\t\t\t      p->ppsrate.rate_pkts_ps,\n\t\t\t\t      TCA_POLICE_PAD))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u64_64bit(skb, TCA_POLICE_PKTBURST64,\n\t\t\t\t      PSCHED_NS2TICKS(p->tcfp_pkt_burst),\n\t\t\t\t      TCA_POLICE_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (nla_put(skb, TCA_POLICE_TBF, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\tif (p->tcfp_result &&\n\t    nla_put_u32(skb, TCA_POLICE_RESULT, p->tcfp_result))\n\t\tgoto nla_put_failure;\n\tif (p->tcfp_ewma_rate &&\n\t    nla_put_u32(skb, TCA_POLICE_AVRATE, p->tcfp_ewma_rate))\n\t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &police->tcf_tm);\n\tif (nla_put_64bit(skb, TCA_POLICE_TM, sizeof(t), &t, TCA_POLICE_PAD))\n\t\tgoto nla_put_failure;\n\tspin_unlock_bh(&police->tcf_lock);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tspin_unlock_bh(&police->tcf_lock);\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}\n\nstatic int tcf_police_act_to_flow_act(int tc_act, u32 *extval,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint act_id = -EOPNOTSUPP;\n\n\tif (!TC_ACT_EXT_OPCODE(tc_act)) {\n\t\tif (tc_act == TC_ACT_OK)\n\t\t\tact_id = FLOW_ACTION_ACCEPT;\n\t\telse if (tc_act ==  TC_ACT_SHOT)\n\t\t\tact_id = FLOW_ACTION_DROP;\n\t\telse if (tc_act == TC_ACT_PIPE)\n\t\t\tact_id = FLOW_ACTION_PIPE;\n\t\telse if (tc_act == TC_ACT_RECLASSIFY)\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Offload not supported when conform/exceed action is \\\"reclassify\\\"\");\n\t\telse\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported conform/exceed action offload\");\n\t} else if (TC_ACT_EXT_CMP(tc_act, TC_ACT_GOTO_CHAIN)) {\n\t\tact_id = FLOW_ACTION_GOTO;\n\t\t*extval = tc_act & TC_ACT_EXT_VAL_MASK;\n\t} else if (TC_ACT_EXT_CMP(tc_act, TC_ACT_JUMP)) {\n\t\tact_id = FLOW_ACTION_JUMP;\n\t\t*extval = tc_act & TC_ACT_EXT_VAL_MASK;\n\t} else if (tc_act == TC_ACT_UNSPEC) {\n\t\tact_id = FLOW_ACTION_CONTINUE;\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported conform/exceed action offload\");\n\t}\n\n\treturn act_id;\n}\n\nstatic int tcf_police_offload_act_setup(struct tc_action *act, void *entry_data,\n\t\t\t\t\tu32 *index_inc, bool bind,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (bind) {\n\t\tstruct flow_action_entry *entry = entry_data;\n\t\tstruct tcf_police *police = to_police(act);\n\t\tstruct tcf_police_params *p;\n\t\tint act_id;\n\n\t\tp = rcu_dereference_protected(police->params,\n\t\t\t\t\t      lockdep_is_held(&police->tcf_lock));\n\n\t\tentry->id = FLOW_ACTION_POLICE;\n\t\tentry->police.burst = tcf_police_burst(act);\n\t\tentry->police.rate_bytes_ps =\n\t\t\ttcf_police_rate_bytes_ps(act);\n\t\tentry->police.peakrate_bytes_ps = tcf_police_peakrate_bytes_ps(act);\n\t\tentry->police.avrate = tcf_police_tcfp_ewma_rate(act);\n\t\tentry->police.overhead = tcf_police_rate_overhead(act);\n\t\tentry->police.burst_pkt = tcf_police_burst_pkt(act);\n\t\tentry->police.rate_pkt_ps =\n\t\t\ttcf_police_rate_pkt_ps(act);\n\t\tentry->police.mtu = tcf_police_tcfp_mtu(act);\n\n\t\tact_id = tcf_police_act_to_flow_act(police->tcf_action,\n\t\t\t\t\t\t    &entry->police.exceed.extval,\n\t\t\t\t\t\t    extack);\n\t\tif (act_id < 0)\n\t\t\treturn act_id;\n\n\t\tentry->police.exceed.act_id = act_id;\n\n\t\tact_id = tcf_police_act_to_flow_act(p->tcfp_result,\n\t\t\t\t\t\t    &entry->police.notexceed.extval,\n\t\t\t\t\t\t    extack);\n\t\tif (act_id < 0)\n\t\t\treturn act_id;\n\n\t\tentry->police.notexceed.act_id = act_id;\n\n\t\t*index_inc = 1;\n\t} else {\n\t\tstruct flow_offload_action *fl_action = entry_data;\n\n\t\tfl_action->id = FLOW_ACTION_POLICE;\n\t}\n\n\treturn 0;\n}\n\nMODULE_AUTHOR(\"Alexey Kuznetsov\");\nMODULE_DESCRIPTION(\"Policing actions\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct tc_action_ops act_police_ops = {\n\t.kind\t\t=\t\"police\",\n\t.id\t\t=\tTCA_ID_POLICE,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.stats_update\t=\ttcf_police_stats_update,\n\t.act\t\t=\ttcf_police_act,\n\t.dump\t\t=\ttcf_police_dump,\n\t.init\t\t=\ttcf_police_init,\n\t.cleanup\t=\ttcf_police_cleanup,\n\t.offload_act_setup =\ttcf_police_offload_act_setup,\n\t.size\t\t=\tsizeof(struct tcf_police),\n};\n\nstatic __net_init int police_init_net(struct net *net)\n{\n\tstruct tc_action_net *tn = net_generic(net, act_police_ops.net_id);\n\n\treturn tc_action_net_init(net, tn, &act_police_ops);\n}\n\nstatic void __net_exit police_exit_net(struct list_head *net_list)\n{\n\ttc_action_net_exit(net_list, act_police_ops.net_id);\n}\n\nstatic struct pernet_operations police_net_ops = {\n\t.init = police_init_net,\n\t.exit_batch = police_exit_net,\n\t.id   = &act_police_ops.net_id,\n\t.size = sizeof(struct tc_action_net),\n};\n\nstatic int __init police_init_module(void)\n{\n\treturn tcf_register_action(&act_police_ops, &police_net_ops);\n}\n\nstatic void __exit police_cleanup_module(void)\n{\n\ttcf_unregister_action(&act_police_ops, &police_net_ops);\n}\n\nmodule_init(police_init_module);\nmodule_exit(police_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}