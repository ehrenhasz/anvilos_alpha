{
  "module_name": "netlink.c",
  "hash_id": "4302986765417cb739f6e728dc04834b5d886ab51a244f5bec37051a262e3b68",
  "original_prompt": "Ingested from linux-6.6.14/net/handshake/netlink.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/mm.h>\n\n#include <net/sock.h>\n#include <net/genetlink.h>\n#include <net/netns/generic.h>\n\n#include <kunit/visibility.h>\n\n#include <uapi/linux/handshake.h>\n#include \"handshake.h\"\n#include \"genl.h\"\n\n#include <trace/events/handshake.h>\n\n \nint handshake_genl_notify(struct net *net, const struct handshake_proto *proto,\n\t\t\t  gfp_t flags)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\t \n\tif (!test_bit(HANDSHAKE_F_PROTO_NOTIFY, &proto->hp_flags))\n\t\treturn 0;\n\n\tif (!genl_has_listeners(&handshake_nl_family, net,\n\t\t\t\tproto->hp_handler_class))\n\t\treturn -ESRCH;\n\n\tmsg = genlmsg_new(GENLMSG_DEFAULT_SIZE, flags);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &handshake_nl_family, 0,\n\t\t\t  HANDSHAKE_CMD_READY);\n\tif (!hdr)\n\t\tgoto out_free;\n\n\tif (nla_put_u32(msg, HANDSHAKE_A_ACCEPT_HANDLER_CLASS,\n\t\t\tproto->hp_handler_class) < 0) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\tgoto out_free;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_multicast_netns(&handshake_nl_family, net, msg,\n\t\t\t\t       0, proto->hp_handler_class, flags);\n\nout_free:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\n \nstruct nlmsghdr *handshake_genl_put(struct sk_buff *msg,\n\t\t\t\t    struct genl_info *info)\n{\n\treturn genlmsg_put(msg, info->snd_portid, info->snd_seq,\n\t\t\t   &handshake_nl_family, 0, info->genlhdr->cmd);\n}\nEXPORT_SYMBOL(handshake_genl_put);\n\nint handshake_nl_accept_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct handshake_net *hn = handshake_pernet(net);\n\tstruct handshake_req *req = NULL;\n\tstruct socket *sock;\n\tint class, fd, err;\n\n\terr = -EOPNOTSUPP;\n\tif (!hn)\n\t\tgoto out_status;\n\n\terr = -EINVAL;\n\tif (GENL_REQ_ATTR_CHECK(info, HANDSHAKE_A_ACCEPT_HANDLER_CLASS))\n\t\tgoto out_status;\n\tclass = nla_get_u32(info->attrs[HANDSHAKE_A_ACCEPT_HANDLER_CLASS]);\n\n\terr = -EAGAIN;\n\treq = handshake_req_next(hn, class);\n\tif (!req)\n\t\tgoto out_status;\n\n\tsock = req->hr_sk->sk_socket;\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0) {\n\t\terr = fd;\n\t\tgoto out_complete;\n\t}\n\n\terr = req->hr_proto->hp_accept(req, info, fd);\n\tif (err) {\n\t\tput_unused_fd(fd);\n\t\tgoto out_complete;\n\t}\n\n\tfd_install(fd, get_file(sock->file));\n\n\ttrace_handshake_cmd_accept(net, req, req->hr_sk, fd);\n\treturn 0;\n\nout_complete:\n\thandshake_complete(req, -EIO, NULL);\nout_status:\n\ttrace_handshake_cmd_accept_err(net, req, NULL, err);\n\treturn err;\n}\n\nint handshake_nl_done_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct handshake_req *req;\n\tstruct socket *sock;\n\tint fd, status, err;\n\n\tif (GENL_REQ_ATTR_CHECK(info, HANDSHAKE_A_DONE_SOCKFD))\n\t\treturn -EINVAL;\n\tfd = nla_get_u32(info->attrs[HANDSHAKE_A_DONE_SOCKFD]);\n\n\tsock = sockfd_lookup(fd, &err);\n\tif (!sock)\n\t\treturn err;\n\n\treq = handshake_req_hash_lookup(sock->sk);\n\tif (!req) {\n\t\terr = -EBUSY;\n\t\ttrace_handshake_cmd_done_err(net, req, sock->sk, err);\n\t\tfput(sock->file);\n\t\treturn err;\n\t}\n\n\ttrace_handshake_cmd_done(net, req, sock->sk, fd);\n\n\tstatus = -EIO;\n\tif (info->attrs[HANDSHAKE_A_DONE_STATUS])\n\t\tstatus = nla_get_u32(info->attrs[HANDSHAKE_A_DONE_STATUS]);\n\n\thandshake_complete(req, status, info);\n\tfput(sock->file);\n\treturn 0;\n}\n\nstatic unsigned int handshake_net_id;\n\nstatic int __net_init handshake_net_init(struct net *net)\n{\n\tstruct handshake_net *hn = net_generic(net, handshake_net_id);\n\tunsigned long tmp;\n\tstruct sysinfo si;\n\n\t \n\tsi_meminfo(&si);\n\ttmp = si.totalram / (25 * si.mem_unit);\n\thn->hn_pending_max = clamp(tmp, 3UL, 50UL);\n\n\tspin_lock_init(&hn->hn_lock);\n\thn->hn_pending = 0;\n\thn->hn_flags = 0;\n\tINIT_LIST_HEAD(&hn->hn_requests);\n\treturn 0;\n}\n\nstatic void __net_exit handshake_net_exit(struct net *net)\n{\n\tstruct handshake_net *hn = net_generic(net, handshake_net_id);\n\tstruct handshake_req *req;\n\tLIST_HEAD(requests);\n\n\t \n\tspin_lock(&hn->hn_lock);\n\tset_bit(HANDSHAKE_F_NET_DRAINING, &hn->hn_flags);\n\tlist_splice_init(&requests, &hn->hn_requests);\n\tspin_unlock(&hn->hn_lock);\n\n\twhile (!list_empty(&requests)) {\n\t\treq = list_first_entry(&requests, struct handshake_req, hr_list);\n\t\tlist_del(&req->hr_list);\n\n\t\t \n\n\t\thandshake_complete(req, -ETIMEDOUT, NULL);\n\t}\n}\n\nstatic struct pernet_operations handshake_genl_net_ops = {\n\t.init\t\t= handshake_net_init,\n\t.exit\t\t= handshake_net_exit,\n\t.id\t\t= &handshake_net_id,\n\t.size\t\t= sizeof(struct handshake_net),\n};\n\n \nstruct handshake_net *handshake_pernet(struct net *net)\n{\n\treturn handshake_net_id ?\n\t\tnet_generic(net, handshake_net_id) : NULL;\n}\nEXPORT_SYMBOL_IF_KUNIT(handshake_pernet);\n\nstatic int __init handshake_init(void)\n{\n\tint ret;\n\n\tret = handshake_req_hash_init();\n\tif (ret) {\n\t\tpr_warn(\"handshake: hash initialization failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = genl_register_family(&handshake_nl_family);\n\tif (ret) {\n\t\tpr_warn(\"handshake: netlink registration failed (%d)\\n\", ret);\n\t\thandshake_req_hash_destroy();\n\t\treturn ret;\n\t}\n\n\t \n\tret = register_pernet_subsys(&handshake_genl_net_ops);\n\tif (ret) {\n\t\tpr_warn(\"handshake: pernet registration failed (%d)\\n\", ret);\n\t\tgenl_unregister_family(&handshake_nl_family);\n\t\thandshake_req_hash_destroy();\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit handshake_exit(void)\n{\n\tunregister_pernet_subsys(&handshake_genl_net_ops);\n\thandshake_net_id = 0;\n\n\thandshake_req_hash_destroy();\n\tgenl_unregister_family(&handshake_nl_family);\n}\n\nmodule_init(handshake_init);\nmodule_exit(handshake_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}