{
  "module_name": "alert.c",
  "hash_id": "2ea533460017de1692989c91ef7ec26a9ecb1652f076766c973749f2e0452fe0",
  "original_prompt": "Ingested from linux-6.6.14/net/handshake/alert.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/inet.h>\n\n#include <net/sock.h>\n#include <net/handshake.h>\n#include <net/tls.h>\n#include <net/tls_prot.h>\n\n#include \"handshake.h\"\n\n#include <trace/events/handshake.h>\n\n \nint tls_alert_send(struct socket *sock, u8 level, u8 description)\n{\n\tu8 record_type = TLS_RECORD_TYPE_ALERT;\n\tu8 buf[CMSG_SPACE(sizeof(record_type))];\n\tstruct msghdr msg = { 0 };\n\tstruct cmsghdr *cmsg;\n\tstruct kvec iov;\n\tu8 alert[2];\n\tint ret;\n\n\ttrace_tls_alert_send(sock->sk, level, description);\n\n\talert[0] = level;\n\talert[1] = description;\n\tiov.iov_base = alert;\n\tiov.iov_len = sizeof(alert);\n\n\tmemset(buf, 0, sizeof(buf));\n\tmsg.msg_control = buf;\n\tmsg.msg_controllen = sizeof(buf);\n\tmsg.msg_flags = MSG_DONTWAIT;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_level = SOL_TLS;\n\tcmsg->cmsg_type = TLS_SET_RECORD_TYPE;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(record_type));\n\tmemcpy(CMSG_DATA(cmsg), &record_type, sizeof(record_type));\n\n\tiov_iter_kvec(&msg.msg_iter, ITER_SOURCE, &iov, 1, iov.iov_len);\n\tret = sock_sendmsg(sock, &msg);\n\treturn ret < 0 ? ret : 0;\n}\n\n \nu8 tls_get_record_type(const struct sock *sk, const struct cmsghdr *cmsg)\n{\n\tu8 record_type;\n\n\tif (cmsg->cmsg_level != SOL_TLS)\n\t\treturn 0;\n\tif (cmsg->cmsg_type != TLS_GET_RECORD_TYPE)\n\t\treturn 0;\n\n\trecord_type = *((u8 *)CMSG_DATA(cmsg));\n\ttrace_tls_contenttype(sk, record_type);\n\treturn record_type;\n}\nEXPORT_SYMBOL(tls_get_record_type);\n\n \nvoid tls_alert_recv(const struct sock *sk, const struct msghdr *msg,\n\t\t    u8 *level, u8 *description)\n{\n\tconst struct kvec *iov;\n\tu8 *data;\n\n\tiov = msg->msg_iter.kvec;\n\tdata = iov->iov_base;\n\t*level = data[0];\n\t*description = data[1];\n\n\ttrace_tls_alert_recv(sk, *level, *description);\n}\nEXPORT_SYMBOL(tls_alert_recv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}