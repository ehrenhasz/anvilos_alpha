{
  "module_name": "request.c",
  "hash_id": "7fe8b4dce0b2fee5c5fd877be74a5d83179e8c67ce1831a489aae934ec914df6",
  "original_prompt": "Ingested from linux-6.6.14/net/handshake/request.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/inet.h>\n#include <linux/fdtable.h>\n#include <linux/rhashtable.h>\n\n#include <net/sock.h>\n#include <net/genetlink.h>\n#include <net/netns/generic.h>\n\n#include <kunit/visibility.h>\n\n#include <uapi/linux/handshake.h>\n#include \"handshake.h\"\n\n#include <trace/events/handshake.h>\n\n \n\nstatic struct rhashtable handshake_rhashtbl ____cacheline_aligned_in_smp;\n\nstatic const struct rhashtable_params handshake_rhash_params = {\n\t.key_len\t\t= sizeof_field(struct handshake_req, hr_sk),\n\t.key_offset\t\t= offsetof(struct handshake_req, hr_sk),\n\t.head_offset\t\t= offsetof(struct handshake_req, hr_rhash),\n\t.automatic_shrinking\t= true,\n};\n\nint handshake_req_hash_init(void)\n{\n\treturn rhashtable_init(&handshake_rhashtbl, &handshake_rhash_params);\n}\n\nvoid handshake_req_hash_destroy(void)\n{\n\trhashtable_destroy(&handshake_rhashtbl);\n}\n\nstruct handshake_req *handshake_req_hash_lookup(struct sock *sk)\n{\n\treturn rhashtable_lookup_fast(&handshake_rhashtbl, &sk,\n\t\t\t\t      handshake_rhash_params);\n}\nEXPORT_SYMBOL_IF_KUNIT(handshake_req_hash_lookup);\n\nstatic bool handshake_req_hash_add(struct handshake_req *req)\n{\n\tint ret;\n\n\tret = rhashtable_lookup_insert_fast(&handshake_rhashtbl,\n\t\t\t\t\t    &req->hr_rhash,\n\t\t\t\t\t    handshake_rhash_params);\n\treturn ret == 0;\n}\n\nstatic void handshake_req_destroy(struct handshake_req *req)\n{\n\tif (req->hr_proto->hp_destroy)\n\t\treq->hr_proto->hp_destroy(req);\n\trhashtable_remove_fast(&handshake_rhashtbl, &req->hr_rhash,\n\t\t\t       handshake_rhash_params);\n\tkfree(req);\n}\n\nstatic void handshake_sk_destruct(struct sock *sk)\n{\n\tvoid (*sk_destruct)(struct sock *sk);\n\tstruct handshake_req *req;\n\n\treq = handshake_req_hash_lookup(sk);\n\tif (!req)\n\t\treturn;\n\n\ttrace_handshake_destruct(sock_net(sk), req, sk);\n\tsk_destruct = req->hr_odestruct;\n\thandshake_req_destroy(req);\n\tif (sk_destruct)\n\t\tsk_destruct(sk);\n}\n\n \nstruct handshake_req *handshake_req_alloc(const struct handshake_proto *proto,\n\t\t\t\t\t  gfp_t flags)\n{\n\tstruct handshake_req *req;\n\n\tif (!proto)\n\t\treturn NULL;\n\tif (proto->hp_handler_class <= HANDSHAKE_HANDLER_CLASS_NONE)\n\t\treturn NULL;\n\tif (proto->hp_handler_class >= HANDSHAKE_HANDLER_CLASS_MAX)\n\t\treturn NULL;\n\tif (!proto->hp_accept || !proto->hp_done)\n\t\treturn NULL;\n\n\treq = kzalloc(struct_size(req, hr_priv, proto->hp_privsize), flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->hr_list);\n\treq->hr_proto = proto;\n\treturn req;\n}\nEXPORT_SYMBOL(handshake_req_alloc);\n\n \nvoid *handshake_req_private(struct handshake_req *req)\n{\n\treturn (void *)&req->hr_priv;\n}\nEXPORT_SYMBOL(handshake_req_private);\n\nstatic bool __add_pending_locked(struct handshake_net *hn,\n\t\t\t\t struct handshake_req *req)\n{\n\tif (WARN_ON_ONCE(!list_empty(&req->hr_list)))\n\t\treturn false;\n\thn->hn_pending++;\n\tlist_add_tail(&req->hr_list, &hn->hn_requests);\n\treturn true;\n}\n\nstatic void __remove_pending_locked(struct handshake_net *hn,\n\t\t\t\t    struct handshake_req *req)\n{\n\thn->hn_pending--;\n\tlist_del_init(&req->hr_list);\n}\n\n \nstatic bool remove_pending(struct handshake_net *hn, struct handshake_req *req)\n{\n\tbool ret = false;\n\n\tspin_lock(&hn->hn_lock);\n\tif (!list_empty(&req->hr_list)) {\n\t\t__remove_pending_locked(hn, req);\n\t\tret = true;\n\t}\n\tspin_unlock(&hn->hn_lock);\n\n\treturn ret;\n}\n\nstruct handshake_req *handshake_req_next(struct handshake_net *hn, int class)\n{\n\tstruct handshake_req *req, *pos;\n\n\treq = NULL;\n\tspin_lock(&hn->hn_lock);\n\tlist_for_each_entry(pos, &hn->hn_requests, hr_list) {\n\t\tif (pos->hr_proto->hp_handler_class != class)\n\t\t\tcontinue;\n\t\t__remove_pending_locked(hn, pos);\n\t\treq = pos;\n\t\tbreak;\n\t}\n\tspin_unlock(&hn->hn_lock);\n\n\treturn req;\n}\nEXPORT_SYMBOL_IF_KUNIT(handshake_req_next);\n\n \nint handshake_req_submit(struct socket *sock, struct handshake_req *req,\n\t\t\t gfp_t flags)\n{\n\tstruct handshake_net *hn;\n\tstruct net *net;\n\tint ret;\n\n\tif (!sock || !req || !sock->file) {\n\t\tkfree(req);\n\t\treturn -EINVAL;\n\t}\n\n\treq->hr_sk = sock->sk;\n\tif (!req->hr_sk) {\n\t\tkfree(req);\n\t\treturn -EINVAL;\n\t}\n\treq->hr_odestruct = req->hr_sk->sk_destruct;\n\treq->hr_sk->sk_destruct = handshake_sk_destruct;\n\n\tret = -EOPNOTSUPP;\n\tnet = sock_net(req->hr_sk);\n\thn = handshake_pernet(net);\n\tif (!hn)\n\t\tgoto out_err;\n\n\tret = -EAGAIN;\n\tif (READ_ONCE(hn->hn_pending) >= hn->hn_pending_max)\n\t\tgoto out_err;\n\n\tspin_lock(&hn->hn_lock);\n\tret = -EOPNOTSUPP;\n\tif (test_bit(HANDSHAKE_F_NET_DRAINING, &hn->hn_flags))\n\t\tgoto out_unlock;\n\tret = -EBUSY;\n\tif (!handshake_req_hash_add(req))\n\t\tgoto out_unlock;\n\tif (!__add_pending_locked(hn, req))\n\t\tgoto out_unlock;\n\tspin_unlock(&hn->hn_lock);\n\n\tret = handshake_genl_notify(net, req->hr_proto, flags);\n\tif (ret) {\n\t\ttrace_handshake_notify_err(net, req, req->hr_sk, ret);\n\t\tif (remove_pending(hn, req))\n\t\t\tgoto out_err;\n\t}\n\n\t \n\tsock_hold(req->hr_sk);\n\n\ttrace_handshake_submit(net, req, req->hr_sk);\n\treturn 0;\n\nout_unlock:\n\tspin_unlock(&hn->hn_lock);\nout_err:\n\ttrace_handshake_submit_err(net, req, req->hr_sk, ret);\n\thandshake_req_destroy(req);\n\treturn ret;\n}\nEXPORT_SYMBOL(handshake_req_submit);\n\nvoid handshake_complete(struct handshake_req *req, unsigned int status,\n\t\t\tstruct genl_info *info)\n{\n\tstruct sock *sk = req->hr_sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (!test_and_set_bit(HANDSHAKE_F_REQ_COMPLETED, &req->hr_flags)) {\n\t\ttrace_handshake_complete(net, req, sk, status);\n\t\treq->hr_proto->hp_done(req, status, info);\n\n\t\t \n\t\tsock_put(sk);\n\t}\n}\nEXPORT_SYMBOL_IF_KUNIT(handshake_complete);\n\n \nbool handshake_req_cancel(struct sock *sk)\n{\n\tstruct handshake_req *req;\n\tstruct handshake_net *hn;\n\tstruct net *net;\n\n\tnet = sock_net(sk);\n\treq = handshake_req_hash_lookup(sk);\n\tif (!req) {\n\t\ttrace_handshake_cancel_none(net, req, sk);\n\t\treturn false;\n\t}\n\n\thn = handshake_pernet(net);\n\tif (hn && remove_pending(hn, req)) {\n\t\t \n\t\tgoto out_true;\n\t}\n\tif (test_and_set_bit(HANDSHAKE_F_REQ_COMPLETED, &req->hr_flags)) {\n\t\t \n\t\ttrace_handshake_cancel_busy(net, req, sk);\n\t\treturn false;\n\t}\n\nout_true:\n\ttrace_handshake_cancel(net, req, sk);\n\n\t \n\tsock_put(sk);\n\treturn true;\n}\nEXPORT_SYMBOL(handshake_req_cancel);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}