{
  "module_name": "handshake-test.c",
  "hash_id": "f98c50e16af2dd16f708817ea4e9f1e7db7319a138ea28e206d9f52ad7287f11",
  "original_prompt": "Ingested from linux-6.6.14/net/handshake/handshake-test.c",
  "human_readable_source": "\n \n\n#include <kunit/test.h>\n#include <kunit/visibility.h>\n\n#include <linux/kernel.h>\n\n#include <net/sock.h>\n#include <net/genetlink.h>\n#include <net/netns/generic.h>\n\n#include <uapi/linux/handshake.h>\n#include \"handshake.h\"\n\nMODULE_IMPORT_NS(EXPORTED_FOR_KUNIT_TESTING);\n\nstatic int test_accept_func(struct handshake_req *req, struct genl_info *info,\n\t\t\t    int fd)\n{\n\treturn 0;\n}\n\nstatic void test_done_func(struct handshake_req *req, unsigned int status,\n\t\t\t   struct genl_info *info)\n{\n}\n\nstruct handshake_req_alloc_test_param {\n\tconst char\t\t\t*desc;\n\tstruct handshake_proto\t\t*proto;\n\tgfp_t\t\t\t\tgfp;\n\tbool\t\t\t\texpect_success;\n};\n\nstatic struct handshake_proto handshake_req_alloc_proto_2 = {\n\t.hp_handler_class\t= HANDSHAKE_HANDLER_CLASS_NONE,\n};\n\nstatic struct handshake_proto handshake_req_alloc_proto_3 = {\n\t.hp_handler_class\t= HANDSHAKE_HANDLER_CLASS_MAX,\n};\n\nstatic struct handshake_proto handshake_req_alloc_proto_4 = {\n\t.hp_handler_class\t= HANDSHAKE_HANDLER_CLASS_TLSHD,\n};\n\nstatic struct handshake_proto handshake_req_alloc_proto_5 = {\n\t.hp_handler_class\t= HANDSHAKE_HANDLER_CLASS_TLSHD,\n\t.hp_accept\t\t= test_accept_func,\n};\n\nstatic struct handshake_proto handshake_req_alloc_proto_6 = {\n\t.hp_handler_class\t= HANDSHAKE_HANDLER_CLASS_TLSHD,\n\t.hp_privsize\t\t= UINT_MAX,\n\t.hp_accept\t\t= test_accept_func,\n\t.hp_done\t\t= test_done_func,\n};\n\nstatic struct handshake_proto handshake_req_alloc_proto_good = {\n\t.hp_handler_class\t= HANDSHAKE_HANDLER_CLASS_TLSHD,\n\t.hp_accept\t\t= test_accept_func,\n\t.hp_done\t\t= test_done_func,\n};\n\nstatic const\nstruct handshake_req_alloc_test_param handshake_req_alloc_params[] = {\n\t{\n\t\t.desc\t\t\t= \"handshake_req_alloc NULL proto\",\n\t\t.proto\t\t\t= NULL,\n\t\t.gfp\t\t\t= GFP_KERNEL,\n\t\t.expect_success\t\t= false,\n\t},\n\t{\n\t\t.desc\t\t\t= \"handshake_req_alloc CLASS_NONE\",\n\t\t.proto\t\t\t= &handshake_req_alloc_proto_2,\n\t\t.gfp\t\t\t= GFP_KERNEL,\n\t\t.expect_success\t\t= false,\n\t},\n\t{\n\t\t.desc\t\t\t= \"handshake_req_alloc CLASS_MAX\",\n\t\t.proto\t\t\t= &handshake_req_alloc_proto_3,\n\t\t.gfp\t\t\t= GFP_KERNEL,\n\t\t.expect_success\t\t= false,\n\t},\n\t{\n\t\t.desc\t\t\t= \"handshake_req_alloc no callbacks\",\n\t\t.proto\t\t\t= &handshake_req_alloc_proto_4,\n\t\t.gfp\t\t\t= GFP_KERNEL,\n\t\t.expect_success\t\t= false,\n\t},\n\t{\n\t\t.desc\t\t\t= \"handshake_req_alloc no done callback\",\n\t\t.proto\t\t\t= &handshake_req_alloc_proto_5,\n\t\t.gfp\t\t\t= GFP_KERNEL,\n\t\t.expect_success\t\t= false,\n\t},\n\t{\n\t\t.desc\t\t\t= \"handshake_req_alloc excessive privsize\",\n\t\t.proto\t\t\t= &handshake_req_alloc_proto_6,\n\t\t.gfp\t\t\t= GFP_KERNEL | __GFP_NOWARN,\n\t\t.expect_success\t\t= false,\n\t},\n\t{\n\t\t.desc\t\t\t= \"handshake_req_alloc all good\",\n\t\t.proto\t\t\t= &handshake_req_alloc_proto_good,\n\t\t.gfp\t\t\t= GFP_KERNEL,\n\t\t.expect_success\t\t= true,\n\t},\n};\n\nstatic void\nhandshake_req_alloc_get_desc(const struct handshake_req_alloc_test_param *param,\n\t\t\t     char *desc)\n{\n\tstrscpy(desc, param->desc, KUNIT_PARAM_DESC_SIZE);\n}\n\n \nKUNIT_ARRAY_PARAM(handshake_req_alloc, handshake_req_alloc_params,\n\t\t  handshake_req_alloc_get_desc);\n\nstatic void handshake_req_alloc_case(struct kunit *test)\n{\n\tconst struct handshake_req_alloc_test_param *param = test->param_value;\n\tstruct handshake_req *result;\n\n\t \n\n\t \n\tresult = handshake_req_alloc(param->proto, param->gfp);\n\n\t \n\tif (param->expect_success)\n\t\tKUNIT_EXPECT_NOT_NULL(test, result);\n\telse\n\t\tKUNIT_EXPECT_NULL(test, result);\n\n\tkfree(result);\n}\n\nstatic void handshake_req_submit_test1(struct kunit *test)\n{\n\tstruct socket *sock;\n\tint err, result;\n\n\t \n\terr = __sock_create(&init_net, PF_INET, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t    &sock, 1);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\n\t \n\tresult = handshake_req_submit(sock, NULL, GFP_KERNEL);\n\n\t \n\tKUNIT_EXPECT_EQ(test, result, -EINVAL);\n\n\tsock_release(sock);\n}\n\nstatic void handshake_req_submit_test2(struct kunit *test)\n{\n\tstruct handshake_req *req;\n\tint result;\n\n\t \n\treq = handshake_req_alloc(&handshake_req_alloc_proto_good, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_NULL(test, req);\n\n\t \n\tresult = handshake_req_submit(NULL, req, GFP_KERNEL);\n\n\t \n\tKUNIT_EXPECT_EQ(test, result, -EINVAL);\n\n\t \n}\n\nstatic void handshake_req_submit_test3(struct kunit *test)\n{\n\tstruct handshake_req *req;\n\tstruct socket *sock;\n\tint err, result;\n\n\t \n\treq = handshake_req_alloc(&handshake_req_alloc_proto_good, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_NULL(test, req);\n\n\terr = __sock_create(&init_net, PF_INET, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t    &sock, 1);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\tsock->file = NULL;\n\n\t \n\tresult = handshake_req_submit(sock, req, GFP_KERNEL);\n\n\t \n\tKUNIT_EXPECT_EQ(test, result, -EINVAL);\n\n\t \n\tsock_release(sock);\n}\n\nstatic void handshake_req_submit_test4(struct kunit *test)\n{\n\tstruct handshake_req *req, *result;\n\tstruct socket *sock;\n\tstruct file *filp;\n\tint err;\n\n\t \n\treq = handshake_req_alloc(&handshake_req_alloc_proto_good, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_NULL(test, req);\n\n\terr = __sock_create(&init_net, PF_INET, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t    &sock, 1);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\tfilp = sock_alloc_file(sock, O_NONBLOCK, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, filp);\n\tKUNIT_ASSERT_NOT_NULL(test, sock->sk);\n\tsock->file = filp;\n\n\terr = handshake_req_submit(sock, req, GFP_KERNEL);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\n\t \n\tresult = handshake_req_hash_lookup(sock->sk);\n\n\t \n\tKUNIT_EXPECT_NOT_NULL(test, result);\n\tKUNIT_EXPECT_PTR_EQ(test, req, result);\n\n\thandshake_req_cancel(sock->sk);\n\tfput(filp);\n}\n\nstatic void handshake_req_submit_test5(struct kunit *test)\n{\n\tstruct handshake_req *req;\n\tstruct handshake_net *hn;\n\tstruct socket *sock;\n\tstruct file *filp;\n\tstruct net *net;\n\tint saved, err;\n\n\t \n\treq = handshake_req_alloc(&handshake_req_alloc_proto_good, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_NULL(test, req);\n\n\terr = __sock_create(&init_net, PF_INET, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t    &sock, 1);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\tfilp = sock_alloc_file(sock, O_NONBLOCK, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, filp);\n\tKUNIT_ASSERT_NOT_NULL(test, sock->sk);\n\tsock->file = filp;\n\n\tnet = sock_net(sock->sk);\n\thn = handshake_pernet(net);\n\tKUNIT_ASSERT_NOT_NULL(test, hn);\n\n\tsaved = hn->hn_pending;\n\thn->hn_pending = hn->hn_pending_max + 1;\n\n\t \n\terr = handshake_req_submit(sock, req, GFP_KERNEL);\n\n\t \n\tKUNIT_EXPECT_EQ(test, err, -EAGAIN);\n\n\tfput(filp);\n\thn->hn_pending = saved;\n}\n\nstatic void handshake_req_submit_test6(struct kunit *test)\n{\n\tstruct handshake_req *req1, *req2;\n\tstruct socket *sock;\n\tstruct file *filp;\n\tint err;\n\n\t \n\treq1 = handshake_req_alloc(&handshake_req_alloc_proto_good, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_NULL(test, req1);\n\treq2 = handshake_req_alloc(&handshake_req_alloc_proto_good, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_NULL(test, req2);\n\n\terr = __sock_create(&init_net, PF_INET, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t    &sock, 1);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\tfilp = sock_alloc_file(sock, O_NONBLOCK, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, filp);\n\tKUNIT_ASSERT_NOT_NULL(test, sock->sk);\n\tsock->file = filp;\n\n\t \n\terr = handshake_req_submit(sock, req1, GFP_KERNEL);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\terr = handshake_req_submit(sock, req2, GFP_KERNEL);\n\n\t \n\tKUNIT_EXPECT_EQ(test, err, -EBUSY);\n\n\thandshake_req_cancel(sock->sk);\n\tfput(filp);\n}\n\nstatic void handshake_req_cancel_test1(struct kunit *test)\n{\n\tstruct handshake_req *req;\n\tstruct socket *sock;\n\tstruct file *filp;\n\tbool result;\n\tint err;\n\n\t \n\treq = handshake_req_alloc(&handshake_req_alloc_proto_good, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_NULL(test, req);\n\n\terr = __sock_create(&init_net, PF_INET, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t    &sock, 1);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\n\tfilp = sock_alloc_file(sock, O_NONBLOCK, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, filp);\n\tsock->file = filp;\n\n\terr = handshake_req_submit(sock, req, GFP_KERNEL);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\n\t \n\n\t \n\tresult = handshake_req_cancel(sock->sk);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, result);\n\n\tfput(filp);\n}\n\nstatic void handshake_req_cancel_test2(struct kunit *test)\n{\n\tstruct handshake_req *req, *next;\n\tstruct handshake_net *hn;\n\tstruct socket *sock;\n\tstruct file *filp;\n\tstruct net *net;\n\tbool result;\n\tint err;\n\n\t \n\treq = handshake_req_alloc(&handshake_req_alloc_proto_good, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_NULL(test, req);\n\n\terr = __sock_create(&init_net, PF_INET, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t    &sock, 1);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\n\tfilp = sock_alloc_file(sock, O_NONBLOCK, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, filp);\n\tsock->file = filp;\n\n\terr = handshake_req_submit(sock, req, GFP_KERNEL);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\n\tnet = sock_net(sock->sk);\n\thn = handshake_pernet(net);\n\tKUNIT_ASSERT_NOT_NULL(test, hn);\n\n\t \n\tnext = handshake_req_next(hn, HANDSHAKE_HANDLER_CLASS_TLSHD);\n\tKUNIT_ASSERT_PTR_EQ(test, req, next);\n\n\t \n\tresult = handshake_req_cancel(sock->sk);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, result);\n\n\tfput(filp);\n}\n\nstatic void handshake_req_cancel_test3(struct kunit *test)\n{\n\tstruct handshake_req *req, *next;\n\tstruct handshake_net *hn;\n\tstruct socket *sock;\n\tstruct file *filp;\n\tstruct net *net;\n\tbool result;\n\tint err;\n\n\t \n\treq = handshake_req_alloc(&handshake_req_alloc_proto_good, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_NULL(test, req);\n\n\terr = __sock_create(&init_net, PF_INET, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t    &sock, 1);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\n\tfilp = sock_alloc_file(sock, O_NONBLOCK, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, filp);\n\tsock->file = filp;\n\n\terr = handshake_req_submit(sock, req, GFP_KERNEL);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\n\tnet = sock_net(sock->sk);\n\thn = handshake_pernet(net);\n\tKUNIT_ASSERT_NOT_NULL(test, hn);\n\n\t \n\tnext = handshake_req_next(hn, HANDSHAKE_HANDLER_CLASS_TLSHD);\n\tKUNIT_ASSERT_PTR_EQ(test, req, next);\n\n\t \n\thandshake_complete(next, -ETIMEDOUT, NULL);\n\n\t \n\tresult = handshake_req_cancel(sock->sk);\n\n\t \n\tKUNIT_EXPECT_FALSE(test, result);\n\n\tfput(filp);\n}\n\nstatic struct handshake_req *handshake_req_destroy_test;\n\nstatic void test_destroy_func(struct handshake_req *req)\n{\n\thandshake_req_destroy_test = req;\n}\n\nstatic struct handshake_proto handshake_req_alloc_proto_destroy = {\n\t.hp_handler_class\t= HANDSHAKE_HANDLER_CLASS_TLSHD,\n\t.hp_accept\t\t= test_accept_func,\n\t.hp_done\t\t= test_done_func,\n\t.hp_destroy\t\t= test_destroy_func,\n};\n\nstatic void handshake_req_destroy_test1(struct kunit *test)\n{\n\tstruct handshake_req *req;\n\tstruct socket *sock;\n\tstruct file *filp;\n\tint err;\n\n\t \n\thandshake_req_destroy_test = NULL;\n\n\treq = handshake_req_alloc(&handshake_req_alloc_proto_destroy, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_NULL(test, req);\n\n\terr = __sock_create(&init_net, PF_INET, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t    &sock, 1);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\n\tfilp = sock_alloc_file(sock, O_NONBLOCK, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, filp);\n\tsock->file = filp;\n\n\terr = handshake_req_submit(sock, req, GFP_KERNEL);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\n\thandshake_req_cancel(sock->sk);\n\n\t \n\tfput(filp);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, handshake_req_destroy_test, req);\n}\n\nstatic struct kunit_case handshake_api_test_cases[] = {\n\t{\n\t\t.name\t\t\t= \"req_alloc API fuzzing\",\n\t\t.run_case\t\t= handshake_req_alloc_case,\n\t\t.generate_params\t= handshake_req_alloc_gen_params,\n\t},\n\t{\n\t\t.name\t\t\t= \"req_submit NULL req arg\",\n\t\t.run_case\t\t= handshake_req_submit_test1,\n\t},\n\t{\n\t\t.name\t\t\t= \"req_submit NULL sock arg\",\n\t\t.run_case\t\t= handshake_req_submit_test2,\n\t},\n\t{\n\t\t.name\t\t\t= \"req_submit NULL sock->file\",\n\t\t.run_case\t\t= handshake_req_submit_test3,\n\t},\n\t{\n\t\t.name\t\t\t= \"req_lookup works\",\n\t\t.run_case\t\t= handshake_req_submit_test4,\n\t},\n\t{\n\t\t.name\t\t\t= \"req_submit max pending\",\n\t\t.run_case\t\t= handshake_req_submit_test5,\n\t},\n\t{\n\t\t.name\t\t\t= \"req_submit multiple\",\n\t\t.run_case\t\t= handshake_req_submit_test6,\n\t},\n\t{\n\t\t.name\t\t\t= \"req_cancel before accept\",\n\t\t.run_case\t\t= handshake_req_cancel_test1,\n\t},\n\t{\n\t\t.name\t\t\t= \"req_cancel after accept\",\n\t\t.run_case\t\t= handshake_req_cancel_test2,\n\t},\n\t{\n\t\t.name\t\t\t= \"req_cancel after done\",\n\t\t.run_case\t\t= handshake_req_cancel_test3,\n\t},\n\t{\n\t\t.name\t\t\t= \"req_destroy works\",\n\t\t.run_case\t\t= handshake_req_destroy_test1,\n\t},\n\t{}\n};\n\nstatic struct kunit_suite handshake_api_suite = {\n       .name                   = \"Handshake API tests\",\n       .test_cases             = handshake_api_test_cases,\n};\n\nkunit_test_suites(&handshake_api_suite);\n\nMODULE_DESCRIPTION(\"Test handshake upcall API functions\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}