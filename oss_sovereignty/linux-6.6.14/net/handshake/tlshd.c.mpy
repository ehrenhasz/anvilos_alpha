{
  "module_name": "tlshd.c",
  "hash_id": "5e5ff80114832f68687fc9f589c907dcdc756d1a5942bf0fb188972526d5b3bf",
  "original_prompt": "Ingested from linux-6.6.14/net/handshake/tlshd.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/key.h>\n\n#include <net/sock.h>\n#include <net/handshake.h>\n#include <net/genetlink.h>\n#include <net/tls_prot.h>\n\n#include <uapi/linux/keyctl.h>\n#include <uapi/linux/handshake.h>\n#include \"handshake.h\"\n\nstruct tls_handshake_req {\n\tvoid\t\t\t(*th_consumer_done)(void *data, int status,\n\t\t\t\t\t\t    key_serial_t peerid);\n\tvoid\t\t\t*th_consumer_data;\n\n\tint\t\t\tth_type;\n\tunsigned int\t\tth_timeout_ms;\n\tint\t\t\tth_auth_mode;\n\tconst char\t\t*th_peername;\n\tkey_serial_t\t\tth_keyring;\n\tkey_serial_t\t\tth_certificate;\n\tkey_serial_t\t\tth_privkey;\n\n\tunsigned int\t\tth_num_peerids;\n\tkey_serial_t\t\tth_peerid[5];\n};\n\nstatic struct tls_handshake_req *\ntls_handshake_req_init(struct handshake_req *req,\n\t\t       const struct tls_handshake_args *args)\n{\n\tstruct tls_handshake_req *treq = handshake_req_private(req);\n\n\ttreq->th_timeout_ms = args->ta_timeout_ms;\n\ttreq->th_consumer_done = args->ta_done;\n\ttreq->th_consumer_data = args->ta_data;\n\ttreq->th_peername = args->ta_peername;\n\ttreq->th_keyring = args->ta_keyring;\n\ttreq->th_num_peerids = 0;\n\ttreq->th_certificate = TLS_NO_CERT;\n\ttreq->th_privkey = TLS_NO_PRIVKEY;\n\treturn treq;\n}\n\nstatic void tls_handshake_remote_peerids(struct tls_handshake_req *treq,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct nlattr *head = nlmsg_attrdata(info->nlhdr, GENL_HDRLEN);\n\tint rem, len = nlmsg_attrlen(info->nlhdr, GENL_HDRLEN);\n\tstruct nlattr *nla;\n\tunsigned int i;\n\n\ti = 0;\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tif (nla_type(nla) == HANDSHAKE_A_DONE_REMOTE_AUTH)\n\t\t\ti++;\n\t}\n\tif (!i)\n\t\treturn;\n\ttreq->th_num_peerids = min_t(unsigned int, i,\n\t\t\t\t     ARRAY_SIZE(treq->th_peerid));\n\n\ti = 0;\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tif (nla_type(nla) == HANDSHAKE_A_DONE_REMOTE_AUTH)\n\t\t\ttreq->th_peerid[i++] = nla_get_u32(nla);\n\t\tif (i >= treq->th_num_peerids)\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void tls_handshake_done(struct handshake_req *req,\n\t\t\t       unsigned int status, struct genl_info *info)\n{\n\tstruct tls_handshake_req *treq = handshake_req_private(req);\n\n\ttreq->th_peerid[0] = TLS_NO_PEERID;\n\tif (info)\n\t\ttls_handshake_remote_peerids(treq, info);\n\n\tif (!status)\n\t\tset_bit(HANDSHAKE_F_REQ_SESSION, &req->hr_flags);\n\n\ttreq->th_consumer_done(treq->th_consumer_data, -status,\n\t\t\t       treq->th_peerid[0]);\n}\n\n#if IS_ENABLED(CONFIG_KEYS)\nstatic int tls_handshake_private_keyring(struct tls_handshake_req *treq)\n{\n\tkey_ref_t process_keyring_ref, keyring_ref;\n\tint ret;\n\n\tif (treq->th_keyring == TLS_NO_KEYRING)\n\t\treturn 0;\n\n\tprocess_keyring_ref = lookup_user_key(KEY_SPEC_PROCESS_KEYRING,\n\t\t\t\t\t      KEY_LOOKUP_CREATE,\n\t\t\t\t\t      KEY_NEED_WRITE);\n\tif (IS_ERR(process_keyring_ref)) {\n\t\tret = PTR_ERR(process_keyring_ref);\n\t\tgoto out;\n\t}\n\n\tkeyring_ref = lookup_user_key(treq->th_keyring, KEY_LOOKUP_CREATE,\n\t\t\t\t      KEY_NEED_LINK);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto out_put_key;\n\t}\n\n\tret = key_link(key_ref_to_ptr(process_keyring_ref),\n\t\t       key_ref_to_ptr(keyring_ref));\n\n\tkey_ref_put(keyring_ref);\nout_put_key:\n\tkey_ref_put(process_keyring_ref);\nout:\n\treturn ret;\n}\n#else\nstatic int tls_handshake_private_keyring(struct tls_handshake_req *treq)\n{\n\treturn 0;\n}\n#endif\n\nstatic int tls_handshake_put_peer_identity(struct sk_buff *msg,\n\t\t\t\t\t   struct tls_handshake_req *treq)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < treq->th_num_peerids; i++)\n\t\tif (nla_put_u32(msg, HANDSHAKE_A_ACCEPT_PEER_IDENTITY,\n\t\t\t\ttreq->th_peerid[i]) < 0)\n\t\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int tls_handshake_put_certificate(struct sk_buff *msg,\n\t\t\t\t\t struct tls_handshake_req *treq)\n{\n\tstruct nlattr *entry_attr;\n\n\tif (treq->th_certificate == TLS_NO_CERT &&\n\t    treq->th_privkey == TLS_NO_PRIVKEY)\n\t\treturn 0;\n\n\tentry_attr = nla_nest_start(msg, HANDSHAKE_A_ACCEPT_CERTIFICATE);\n\tif (!entry_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(msg, HANDSHAKE_A_X509_CERT,\n\t\t\ttreq->th_certificate) ||\n\t    nla_put_u32(msg, HANDSHAKE_A_X509_PRIVKEY,\n\t\t\ttreq->th_privkey)) {\n\t\tnla_nest_cancel(msg, entry_attr);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnla_nest_end(msg, entry_attr);\n\treturn 0;\n}\n\n \nstatic int tls_handshake_accept(struct handshake_req *req,\n\t\t\t\tstruct genl_info *info, int fd)\n{\n\tstruct tls_handshake_req *treq = handshake_req_private(req);\n\tstruct nlmsghdr *hdr;\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tret = tls_handshake_private_keyring(treq);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tmsg = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\tgoto out;\n\thdr = handshake_genl_put(msg, info);\n\tif (!hdr)\n\t\tgoto out_cancel;\n\n\tret = -EMSGSIZE;\n\tret = nla_put_u32(msg, HANDSHAKE_A_ACCEPT_SOCKFD, fd);\n\tif (ret < 0)\n\t\tgoto out_cancel;\n\tret = nla_put_u32(msg, HANDSHAKE_A_ACCEPT_MESSAGE_TYPE, treq->th_type);\n\tif (ret < 0)\n\t\tgoto out_cancel;\n\tif (treq->th_peername) {\n\t\tret = nla_put_string(msg, HANDSHAKE_A_ACCEPT_PEERNAME,\n\t\t\t\t     treq->th_peername);\n\t\tif (ret < 0)\n\t\t\tgoto out_cancel;\n\t}\n\tif (treq->th_timeout_ms) {\n\t\tret = nla_put_u32(msg, HANDSHAKE_A_ACCEPT_TIMEOUT, treq->th_timeout_ms);\n\t\tif (ret < 0)\n\t\t\tgoto out_cancel;\n\t}\n\n\tret = nla_put_u32(msg, HANDSHAKE_A_ACCEPT_AUTH_MODE,\n\t\t\t  treq->th_auth_mode);\n\tif (ret < 0)\n\t\tgoto out_cancel;\n\tswitch (treq->th_auth_mode) {\n\tcase HANDSHAKE_AUTH_PSK:\n\t\tret = tls_handshake_put_peer_identity(msg, treq);\n\t\tif (ret < 0)\n\t\t\tgoto out_cancel;\n\t\tbreak;\n\tcase HANDSHAKE_AUTH_X509:\n\t\tret = tls_handshake_put_certificate(msg, treq);\n\t\tif (ret < 0)\n\t\t\tgoto out_cancel;\n\t\tbreak;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nout_cancel:\n\tgenlmsg_cancel(msg, hdr);\nout:\n\treturn ret;\n}\n\nstatic const struct handshake_proto tls_handshake_proto = {\n\t.hp_handler_class\t= HANDSHAKE_HANDLER_CLASS_TLSHD,\n\t.hp_privsize\t\t= sizeof(struct tls_handshake_req),\n\t.hp_flags\t\t= BIT(HANDSHAKE_F_PROTO_NOTIFY),\n\n\t.hp_accept\t\t= tls_handshake_accept,\n\t.hp_done\t\t= tls_handshake_done,\n};\n\n \nint tls_client_hello_anon(const struct tls_handshake_args *args, gfp_t flags)\n{\n\tstruct tls_handshake_req *treq;\n\tstruct handshake_req *req;\n\n\treq = handshake_req_alloc(&tls_handshake_proto, flags);\n\tif (!req)\n\t\treturn -ENOMEM;\n\ttreq = tls_handshake_req_init(req, args);\n\ttreq->th_type = HANDSHAKE_MSG_TYPE_CLIENTHELLO;\n\ttreq->th_auth_mode = HANDSHAKE_AUTH_UNAUTH;\n\n\treturn handshake_req_submit(args->ta_sock, req, flags);\n}\nEXPORT_SYMBOL(tls_client_hello_anon);\n\n \nint tls_client_hello_x509(const struct tls_handshake_args *args, gfp_t flags)\n{\n\tstruct tls_handshake_req *treq;\n\tstruct handshake_req *req;\n\n\treq = handshake_req_alloc(&tls_handshake_proto, flags);\n\tif (!req)\n\t\treturn -ENOMEM;\n\ttreq = tls_handshake_req_init(req, args);\n\ttreq->th_type = HANDSHAKE_MSG_TYPE_CLIENTHELLO;\n\ttreq->th_auth_mode = HANDSHAKE_AUTH_X509;\n\ttreq->th_certificate = args->ta_my_cert;\n\ttreq->th_privkey = args->ta_my_privkey;\n\n\treturn handshake_req_submit(args->ta_sock, req, flags);\n}\nEXPORT_SYMBOL(tls_client_hello_x509);\n\n \nint tls_client_hello_psk(const struct tls_handshake_args *args, gfp_t flags)\n{\n\tstruct tls_handshake_req *treq;\n\tstruct handshake_req *req;\n\tunsigned int i;\n\n\tif (!args->ta_num_peerids ||\n\t    args->ta_num_peerids > ARRAY_SIZE(treq->th_peerid))\n\t\treturn -EINVAL;\n\n\treq = handshake_req_alloc(&tls_handshake_proto, flags);\n\tif (!req)\n\t\treturn -ENOMEM;\n\ttreq = tls_handshake_req_init(req, args);\n\ttreq->th_type = HANDSHAKE_MSG_TYPE_CLIENTHELLO;\n\ttreq->th_auth_mode = HANDSHAKE_AUTH_PSK;\n\ttreq->th_num_peerids = args->ta_num_peerids;\n\tfor (i = 0; i < args->ta_num_peerids; i++)\n\t\ttreq->th_peerid[i] = args->ta_my_peerids[i];\n\n\treturn handshake_req_submit(args->ta_sock, req, flags);\n}\nEXPORT_SYMBOL(tls_client_hello_psk);\n\n \nint tls_server_hello_x509(const struct tls_handshake_args *args, gfp_t flags)\n{\n\tstruct tls_handshake_req *treq;\n\tstruct handshake_req *req;\n\n\treq = handshake_req_alloc(&tls_handshake_proto, flags);\n\tif (!req)\n\t\treturn -ENOMEM;\n\ttreq = tls_handshake_req_init(req, args);\n\ttreq->th_type = HANDSHAKE_MSG_TYPE_SERVERHELLO;\n\ttreq->th_auth_mode = HANDSHAKE_AUTH_X509;\n\ttreq->th_certificate = args->ta_my_cert;\n\ttreq->th_privkey = args->ta_my_privkey;\n\n\treturn handshake_req_submit(args->ta_sock, req, flags);\n}\nEXPORT_SYMBOL(tls_server_hello_x509);\n\n \nint tls_server_hello_psk(const struct tls_handshake_args *args, gfp_t flags)\n{\n\tstruct tls_handshake_req *treq;\n\tstruct handshake_req *req;\n\n\treq = handshake_req_alloc(&tls_handshake_proto, flags);\n\tif (!req)\n\t\treturn -ENOMEM;\n\ttreq = tls_handshake_req_init(req, args);\n\ttreq->th_type = HANDSHAKE_MSG_TYPE_SERVERHELLO;\n\ttreq->th_auth_mode = HANDSHAKE_AUTH_PSK;\n\ttreq->th_num_peerids = 1;\n\ttreq->th_peerid[0] = args->ta_my_peerids[0];\n\n\treturn handshake_req_submit(args->ta_sock, req, flags);\n}\nEXPORT_SYMBOL(tls_server_hello_psk);\n\n \nbool tls_handshake_cancel(struct sock *sk)\n{\n\treturn handshake_req_cancel(sk);\n}\nEXPORT_SYMBOL(tls_handshake_cancel);\n\n \nvoid tls_handshake_close(struct socket *sock)\n{\n\tstruct handshake_req *req;\n\n\treq = handshake_req_hash_lookup(sock->sk);\n\tif (!req)\n\t\treturn;\n\tif (!test_and_clear_bit(HANDSHAKE_F_REQ_SESSION, &req->hr_flags))\n\t\treturn;\n\ttls_alert_send(sock, TLS_ALERT_LEVEL_WARNING,\n\t\t       TLS_ALERT_DESC_CLOSE_NOTIFY);\n}\nEXPORT_SYMBOL(tls_handshake_close);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}