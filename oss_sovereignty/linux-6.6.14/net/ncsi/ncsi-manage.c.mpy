{
  "module_name": "ncsi-manage.c",
  "hash_id": "7fefc0655de6c6454bc0035464144a50c18707991e32c1d4b5355952698ff1d1",
  "original_prompt": "Ingested from linux-6.6.14/net/ncsi/ncsi-manage.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <net/ncsi.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/addrconf.h>\n#include <net/ipv6.h>\n#include <net/genetlink.h>\n\n#include \"internal.h\"\n#include \"ncsi-pkt.h\"\n#include \"ncsi-netlink.h\"\n\nLIST_HEAD(ncsi_dev_list);\nDEFINE_SPINLOCK(ncsi_dev_lock);\n\nbool ncsi_channel_has_link(struct ncsi_channel *channel)\n{\n\treturn !!(channel->modes[NCSI_MODE_LINK].data[2] & 0x1);\n}\n\nbool ncsi_channel_is_last(struct ncsi_dev_priv *ndp,\n\t\t\t  struct ncsi_channel *channel)\n{\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc;\n\n\tNCSI_FOR_EACH_PACKAGE(ndp, np)\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\tif (nc == channel)\n\t\t\t\tcontinue;\n\t\t\tif (nc->state == NCSI_CHANNEL_ACTIVE &&\n\t\t\t    ncsi_channel_has_link(nc))\n\t\t\t\treturn false;\n\t\t}\n\n\treturn true;\n}\n\nstatic void ncsi_report_link(struct ncsi_dev_priv *ndp, bool force_down)\n{\n\tstruct ncsi_dev *nd = &ndp->ndev;\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc;\n\tunsigned long flags;\n\n\tnd->state = ncsi_dev_state_functional;\n\tif (force_down) {\n\t\tnd->link_up = 0;\n\t\tgoto report;\n\t}\n\n\tnd->link_up = 0;\n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\tspin_lock_irqsave(&nc->lock, flags);\n\n\t\t\tif (!list_empty(&nc->link) ||\n\t\t\t    nc->state != NCSI_CHANNEL_ACTIVE) {\n\t\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ncsi_channel_has_link(nc)) {\n\t\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\t\t\tnd->link_up = 1;\n\t\t\t\tgoto report;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\t}\n\t}\n\nreport:\n\tnd->handler(nd);\n}\n\nstatic void ncsi_channel_monitor(struct timer_list *t)\n{\n\tstruct ncsi_channel *nc = from_timer(nc, t, monitor.timer);\n\tstruct ncsi_package *np = nc->package;\n\tstruct ncsi_dev_priv *ndp = np->ndp;\n\tstruct ncsi_channel_mode *ncm;\n\tstruct ncsi_cmd_arg nca;\n\tbool enabled, chained;\n\tunsigned int monitor_state;\n\tunsigned long flags;\n\tint state, ret;\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\tstate = nc->state;\n\tchained = !list_empty(&nc->link);\n\tenabled = nc->monitor.enabled;\n\tmonitor_state = nc->monitor.state;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\tif (!enabled)\n\t\treturn;\t\t \n\tif (WARN_ON_ONCE(chained))\n\t\tgoto bad_state;\n\n\tif (state != NCSI_CHANNEL_INACTIVE &&\n\t    state != NCSI_CHANNEL_ACTIVE) {\nbad_state:\n\t\tnetdev_warn(ndp->ndev.dev,\n\t\t\t    \"Bad NCSI monitor state channel %d 0x%x %s queue\\n\",\n\t\t\t    nc->id, state, chained ? \"on\" : \"off\");\n\t\tspin_lock_irqsave(&nc->lock, flags);\n\t\tnc->monitor.enabled = false;\n\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\treturn;\n\t}\n\n\tswitch (monitor_state) {\n\tcase NCSI_CHANNEL_MONITOR_START:\n\tcase NCSI_CHANNEL_MONITOR_RETRY:\n\t\tnca.ndp = ndp;\n\t\tnca.package = np->id;\n\t\tnca.channel = nc->id;\n\t\tnca.type = NCSI_PKT_CMD_GLS;\n\t\tnca.req_flags = 0;\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret)\n\t\t\tnetdev_err(ndp->ndev.dev, \"Error %d sending GLS\\n\",\n\t\t\t\t   ret);\n\t\tbreak;\n\tcase NCSI_CHANNEL_MONITOR_WAIT ... NCSI_CHANNEL_MONITOR_WAIT_MAX:\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(ndp->ndev.dev, \"NCSI Channel %d timed out!\\n\",\n\t\t\t   nc->id);\n\t\tncsi_report_link(ndp, true);\n\t\tndp->flags |= NCSI_DEV_RESHUFFLE;\n\n\t\tncm = &nc->modes[NCSI_MODE_LINK];\n\t\tspin_lock_irqsave(&nc->lock, flags);\n\t\tnc->monitor.enabled = false;\n\t\tnc->state = NCSI_CHANNEL_INVISIBLE;\n\t\tncm->data[2] &= ~0x1;\n\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\t\tspin_lock_irqsave(&ndp->lock, flags);\n\t\tnc->state = NCSI_CHANNEL_ACTIVE;\n\t\tlist_add_tail_rcu(&nc->link, &ndp->channel_queue);\n\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\tncsi_process_next_channel(ndp);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\tnc->monitor.state++;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\tmod_timer(&nc->monitor.timer, jiffies + HZ);\n}\n\nvoid ncsi_start_channel_monitor(struct ncsi_channel *nc)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\tWARN_ON_ONCE(nc->monitor.enabled);\n\tnc->monitor.enabled = true;\n\tnc->monitor.state = NCSI_CHANNEL_MONITOR_START;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\tmod_timer(&nc->monitor.timer, jiffies + HZ);\n}\n\nvoid ncsi_stop_channel_monitor(struct ncsi_channel *nc)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\tif (!nc->monitor.enabled) {\n\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\treturn;\n\t}\n\tnc->monitor.enabled = false;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\tdel_timer_sync(&nc->monitor.timer);\n}\n\nstruct ncsi_channel *ncsi_find_channel(struct ncsi_package *np,\n\t\t\t\t       unsigned char id)\n{\n\tstruct ncsi_channel *nc;\n\n\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\tif (nc->id == id)\n\t\t\treturn nc;\n\t}\n\n\treturn NULL;\n}\n\nstruct ncsi_channel *ncsi_add_channel(struct ncsi_package *np, unsigned char id)\n{\n\tstruct ncsi_channel *nc, *tmp;\n\tint index;\n\tunsigned long flags;\n\n\tnc = kzalloc(sizeof(*nc), GFP_ATOMIC);\n\tif (!nc)\n\t\treturn NULL;\n\n\tnc->id = id;\n\tnc->package = np;\n\tnc->state = NCSI_CHANNEL_INACTIVE;\n\tnc->monitor.enabled = false;\n\ttimer_setup(&nc->monitor.timer, ncsi_channel_monitor, 0);\n\tspin_lock_init(&nc->lock);\n\tINIT_LIST_HEAD(&nc->link);\n\tfor (index = 0; index < NCSI_CAP_MAX; index++)\n\t\tnc->caps[index].index = index;\n\tfor (index = 0; index < NCSI_MODE_MAX; index++)\n\t\tnc->modes[index].index = index;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\ttmp = ncsi_find_channel(np, id);\n\tif (tmp) {\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\tkfree(nc);\n\t\treturn tmp;\n\t}\n\n\tlist_add_tail_rcu(&nc->node, &np->channels);\n\tnp->channel_num++;\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn nc;\n}\n\nstatic void ncsi_remove_channel(struct ncsi_channel *nc)\n{\n\tstruct ncsi_package *np = nc->package;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\n\t \n\tkfree(nc->mac_filter.addrs);\n\tkfree(nc->vlan_filter.vids);\n\n\tnc->state = NCSI_CHANNEL_INACTIVE;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\tncsi_stop_channel_monitor(nc);\n\n\t \n\tspin_lock_irqsave(&np->lock, flags);\n\tlist_del_rcu(&nc->node);\n\tnp->channel_num--;\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tkfree(nc);\n}\n\nstruct ncsi_package *ncsi_find_package(struct ncsi_dev_priv *ndp,\n\t\t\t\t       unsigned char id)\n{\n\tstruct ncsi_package *np;\n\n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tif (np->id == id)\n\t\t\treturn np;\n\t}\n\n\treturn NULL;\n}\n\nstruct ncsi_package *ncsi_add_package(struct ncsi_dev_priv *ndp,\n\t\t\t\t      unsigned char id)\n{\n\tstruct ncsi_package *np, *tmp;\n\tunsigned long flags;\n\n\tnp = kzalloc(sizeof(*np), GFP_ATOMIC);\n\tif (!np)\n\t\treturn NULL;\n\n\tnp->id = id;\n\tnp->ndp = ndp;\n\tspin_lock_init(&np->lock);\n\tINIT_LIST_HEAD(&np->channels);\n\tnp->channel_whitelist = UINT_MAX;\n\n\tspin_lock_irqsave(&ndp->lock, flags);\n\ttmp = ncsi_find_package(ndp, id);\n\tif (tmp) {\n\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\tkfree(np);\n\t\treturn tmp;\n\t}\n\n\tlist_add_tail_rcu(&np->node, &ndp->packages);\n\tndp->package_num++;\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\treturn np;\n}\n\nvoid ncsi_remove_package(struct ncsi_package *np)\n{\n\tstruct ncsi_dev_priv *ndp = np->ndp;\n\tstruct ncsi_channel *nc, *tmp;\n\tunsigned long flags;\n\n\t \n\tlist_for_each_entry_safe(nc, tmp, &np->channels, node)\n\t\tncsi_remove_channel(nc);\n\n\t \n\tspin_lock_irqsave(&ndp->lock, flags);\n\tlist_del_rcu(&np->node);\n\tndp->package_num--;\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\tkfree(np);\n}\n\nvoid ncsi_find_package_and_channel(struct ncsi_dev_priv *ndp,\n\t\t\t\t   unsigned char id,\n\t\t\t\t   struct ncsi_package **np,\n\t\t\t\t   struct ncsi_channel **nc)\n{\n\tstruct ncsi_package *p;\n\tstruct ncsi_channel *c;\n\n\tp = ncsi_find_package(ndp, NCSI_PACKAGE_INDEX(id));\n\tc = p ? ncsi_find_channel(p, NCSI_CHANNEL_INDEX(id)) : NULL;\n\n\tif (np)\n\t\t*np = p;\n\tif (nc)\n\t\t*nc = c;\n}\n\n \nstruct ncsi_request *ncsi_alloc_request(struct ncsi_dev_priv *ndp,\n\t\t\t\t\tunsigned int req_flags)\n{\n\tstruct ncsi_request *nr = NULL;\n\tint i, limit = ARRAY_SIZE(ndp->requests);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ndp->lock, flags);\n\tfor (i = ndp->request_id; i < limit; i++) {\n\t\tif (ndp->requests[i].used)\n\t\t\tcontinue;\n\n\t\tnr = &ndp->requests[i];\n\t\tnr->used = true;\n\t\tnr->flags = req_flags;\n\t\tndp->request_id = i + 1;\n\t\tgoto found;\n\t}\n\n\t \n\tfor (i = NCSI_REQ_START_IDX; i < ndp->request_id; i++) {\n\t\tif (ndp->requests[i].used)\n\t\t\tcontinue;\n\n\t\tnr = &ndp->requests[i];\n\t\tnr->used = true;\n\t\tnr->flags = req_flags;\n\t\tndp->request_id = i + 1;\n\t\tgoto found;\n\t}\n\nfound:\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\treturn nr;\n}\n\nvoid ncsi_free_request(struct ncsi_request *nr)\n{\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct sk_buff *cmd, *rsp;\n\tunsigned long flags;\n\tbool driven;\n\n\tif (nr->enabled) {\n\t\tnr->enabled = false;\n\t\tdel_timer_sync(&nr->timer);\n\t}\n\n\tspin_lock_irqsave(&ndp->lock, flags);\n\tcmd = nr->cmd;\n\trsp = nr->rsp;\n\tnr->cmd = NULL;\n\tnr->rsp = NULL;\n\tnr->used = false;\n\tdriven = !!(nr->flags & NCSI_REQ_FLAG_EVENT_DRIVEN);\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\tif (driven && cmd && --ndp->pending_req_num == 0)\n\t\tschedule_work(&ndp->work);\n\n\t \n\tconsume_skb(cmd);\n\tconsume_skb(rsp);\n}\n\nstruct ncsi_dev *ncsi_find_dev(struct net_device *dev)\n{\n\tstruct ncsi_dev_priv *ndp;\n\n\tNCSI_FOR_EACH_DEV(ndp) {\n\t\tif (ndp->ndev.dev == dev)\n\t\t\treturn &ndp->ndev;\n\t}\n\n\treturn NULL;\n}\n\nstatic void ncsi_request_timeout(struct timer_list *t)\n{\n\tstruct ncsi_request *nr = from_timer(nr, t, timer);\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_cmd_pkt *cmd;\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ndp->lock, flags);\n\tnr->enabled = false;\n\tif (nr->rsp || !nr->cmd) {\n\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\tif (nr->flags == NCSI_REQ_FLAG_NETLINK_DRIVEN) {\n\t\tif (nr->cmd) {\n\t\t\t \n\t\t\tcmd = (struct ncsi_cmd_pkt *)\n\t\t\t      skb_network_header(nr->cmd);\n\t\t\tncsi_find_package_and_channel(ndp,\n\t\t\t\t\t\t      cmd->cmd.common.channel,\n\t\t\t\t\t\t      &np, &nc);\n\t\t\tncsi_send_netlink_timeout(nr, np, nc);\n\t\t}\n\t}\n\n\t \n\tncsi_free_request(nr);\n}\n\nstatic void ncsi_suspend_channel(struct ncsi_dev_priv *ndp)\n{\n\tstruct ncsi_dev *nd = &ndp->ndev;\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc, *tmp;\n\tstruct ncsi_cmd_arg nca;\n\tunsigned long flags;\n\tint ret;\n\n\tnp = ndp->active_package;\n\tnc = ndp->active_channel;\n\tnca.ndp = ndp;\n\tnca.req_flags = NCSI_REQ_FLAG_EVENT_DRIVEN;\n\tswitch (nd->state) {\n\tcase ncsi_dev_state_suspend:\n\t\tnd->state = ncsi_dev_state_suspend_select;\n\t\tfallthrough;\n\tcase ncsi_dev_state_suspend_select:\n\t\tndp->pending_req_num = 1;\n\n\t\tnca.type = NCSI_PKT_CMD_SP;\n\t\tnca.package = np->id;\n\t\tnca.channel = NCSI_RESERVED_CHANNEL;\n\t\tif (ndp->flags & NCSI_DEV_HWA)\n\t\t\tnca.bytes[0] = 0;\n\t\telse\n\t\t\tnca.bytes[0] = 1;\n\n\t\t \n\t\tif (ndp->flags & NCSI_DEV_RESHUFFLE)\n\t\t\tnd->state = ncsi_dev_state_suspend_gls;\n\t\telse\n\t\t\tnd->state = ncsi_dev_state_suspend_dcnt;\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tbreak;\n\tcase ncsi_dev_state_suspend_gls:\n\t\tndp->pending_req_num = np->channel_num;\n\n\t\tnca.type = NCSI_PKT_CMD_GLS;\n\t\tnca.package = np->id;\n\n\t\tnd->state = ncsi_dev_state_suspend_dcnt;\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\tnca.channel = nc->id;\n\t\t\tret = ncsi_xmit_cmd(&nca);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tbreak;\n\tcase ncsi_dev_state_suspend_dcnt:\n\t\tndp->pending_req_num = 1;\n\n\t\tnca.type = NCSI_PKT_CMD_DCNT;\n\t\tnca.package = np->id;\n\t\tnca.channel = nc->id;\n\n\t\tnd->state = ncsi_dev_state_suspend_dc;\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tbreak;\n\tcase ncsi_dev_state_suspend_dc:\n\t\tndp->pending_req_num = 1;\n\n\t\tnca.type = NCSI_PKT_CMD_DC;\n\t\tnca.package = np->id;\n\t\tnca.channel = nc->id;\n\t\tnca.bytes[0] = 1;\n\n\t\tnd->state = ncsi_dev_state_suspend_deselect;\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tNCSI_FOR_EACH_CHANNEL(np, tmp) {\n\t\t\t \n\t\t\tif (tmp != nc && tmp->state == NCSI_CHANNEL_ACTIVE) {\n\t\t\t\tnd->state = ncsi_dev_state_suspend_done;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ncsi_dev_state_suspend_deselect:\n\t\tndp->pending_req_num = 1;\n\n\t\tnca.type = NCSI_PKT_CMD_DP;\n\t\tnca.package = np->id;\n\t\tnca.channel = NCSI_RESERVED_CHANNEL;\n\n\t\tnd->state = ncsi_dev_state_suspend_done;\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tbreak;\n\tcase ncsi_dev_state_suspend_done:\n\t\tspin_lock_irqsave(&nc->lock, flags);\n\t\tnc->state = NCSI_CHANNEL_INACTIVE;\n\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\tif (ndp->flags & NCSI_DEV_RESET)\n\t\t\tncsi_reset_dev(nd);\n\t\telse\n\t\t\tncsi_process_next_channel(ndp);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(nd->dev, \"Wrong NCSI state 0x%x in suspend\\n\",\n\t\t\t    nd->state);\n\t}\n\n\treturn;\nerror:\n\tnd->state = ncsi_dev_state_functional;\n}\n\n \nstatic int clear_one_vid(struct ncsi_dev_priv *ndp, struct ncsi_channel *nc,\n\t\t\t struct ncsi_cmd_arg *nca)\n{\n\tstruct ncsi_channel_vlan_filter *ncf;\n\tunsigned long flags;\n\tvoid *bitmap;\n\tint index;\n\tu16 vid;\n\n\tncf = &nc->vlan_filter;\n\tbitmap = &ncf->bitmap;\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\tindex = find_first_bit(bitmap, ncf->n_vids);\n\tif (index >= ncf->n_vids) {\n\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\treturn -1;\n\t}\n\tvid = ncf->vids[index];\n\n\tclear_bit(index, bitmap);\n\tncf->vids[index] = 0;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\tnca->type = NCSI_PKT_CMD_SVF;\n\tnca->words[1] = vid;\n\t \n\tnca->bytes[6] = index + 1;\n\tnca->bytes[7] = 0x00;\n\treturn 0;\n}\n\n \nstatic int set_one_vid(struct ncsi_dev_priv *ndp, struct ncsi_channel *nc,\n\t\t       struct ncsi_cmd_arg *nca)\n{\n\tstruct ncsi_channel_vlan_filter *ncf;\n\tstruct vlan_vid *vlan = NULL;\n\tunsigned long flags;\n\tint i, index;\n\tvoid *bitmap;\n\tu16 vid;\n\n\tif (list_empty(&ndp->vlan_vids))\n\t\treturn -1;\n\n\tncf = &nc->vlan_filter;\n\tbitmap = &ncf->bitmap;\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(vlan, &ndp->vlan_vids, list) {\n\t\tvid = vlan->vid;\n\t\tfor (i = 0; i < ncf->n_vids; i++)\n\t\t\tif (ncf->vids[i] == vid) {\n\t\t\t\tvid = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (vid)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (!vid) {\n\t\t \n\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\treturn -1;\n\t}\n\n\tindex = find_first_zero_bit(bitmap, ncf->n_vids);\n\tif (index < 0 || index >= ncf->n_vids) {\n\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t   \"Channel %u already has all VLAN filters set\\n\",\n\t\t\t   nc->id);\n\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\treturn -1;\n\t}\n\n\tncf->vids[index] = vid;\n\tset_bit(index, bitmap);\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\tnca->type = NCSI_PKT_CMD_SVF;\n\tnca->words[1] = vid;\n\t \n\tnca->bytes[6] = index + 1;\n\tnca->bytes[7] = 0x01;\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_NCSI_OEM_CMD_KEEP_PHY)\n\nstatic int ncsi_oem_keep_phy_intel(struct ncsi_cmd_arg *nca)\n{\n\tunsigned char data[NCSI_OEM_INTEL_CMD_KEEP_PHY_LEN];\n\tint ret = 0;\n\n\tnca->payload = NCSI_OEM_INTEL_CMD_KEEP_PHY_LEN;\n\n\tmemset(data, 0, NCSI_OEM_INTEL_CMD_KEEP_PHY_LEN);\n\t*(unsigned int *)data = ntohl((__force __be32)NCSI_OEM_MFR_INTEL_ID);\n\n\tdata[4] = NCSI_OEM_INTEL_CMD_KEEP_PHY;\n\n\t \n\tdata[6] = 0x1;\n\n\tnca->data = data;\n\n\tret = ncsi_xmit_cmd(nca);\n\tif (ret)\n\t\tnetdev_err(nca->ndp->ndev.dev,\n\t\t\t   \"NCSI: Failed to transmit cmd 0x%x during configure\\n\",\n\t\t\t   nca->type);\n\treturn ret;\n}\n\n#endif\n\n#if IS_ENABLED(CONFIG_NCSI_OEM_CMD_GET_MAC)\n\n \nstatic int ncsi_oem_gma_handler_bcm(struct ncsi_cmd_arg *nca)\n{\n\tunsigned char data[NCSI_OEM_BCM_CMD_GMA_LEN];\n\tint ret = 0;\n\n\tnca->payload = NCSI_OEM_BCM_CMD_GMA_LEN;\n\n\tmemset(data, 0, NCSI_OEM_BCM_CMD_GMA_LEN);\n\t*(unsigned int *)data = ntohl((__force __be32)NCSI_OEM_MFR_BCM_ID);\n\tdata[5] = NCSI_OEM_BCM_CMD_GMA;\n\n\tnca->data = data;\n\n\tret = ncsi_xmit_cmd(nca);\n\tif (ret)\n\t\tnetdev_err(nca->ndp->ndev.dev,\n\t\t\t   \"NCSI: Failed to transmit cmd 0x%x during configure\\n\",\n\t\t\t   nca->type);\n\treturn ret;\n}\n\nstatic int ncsi_oem_gma_handler_mlx(struct ncsi_cmd_arg *nca)\n{\n\tunion {\n\t\tu8 data_u8[NCSI_OEM_MLX_CMD_GMA_LEN];\n\t\tu32 data_u32[NCSI_OEM_MLX_CMD_GMA_LEN / sizeof(u32)];\n\t} u;\n\tint ret = 0;\n\n\tnca->payload = NCSI_OEM_MLX_CMD_GMA_LEN;\n\n\tmemset(&u, 0, sizeof(u));\n\tu.data_u32[0] = ntohl((__force __be32)NCSI_OEM_MFR_MLX_ID);\n\tu.data_u8[5] = NCSI_OEM_MLX_CMD_GMA;\n\tu.data_u8[6] = NCSI_OEM_MLX_CMD_GMA_PARAM;\n\n\tnca->data = u.data_u8;\n\n\tret = ncsi_xmit_cmd(nca);\n\tif (ret)\n\t\tnetdev_err(nca->ndp->ndev.dev,\n\t\t\t   \"NCSI: Failed to transmit cmd 0x%x during configure\\n\",\n\t\t\t   nca->type);\n\treturn ret;\n}\n\nstatic int ncsi_oem_smaf_mlx(struct ncsi_cmd_arg *nca)\n{\n\tunion {\n\t\tu8 data_u8[NCSI_OEM_MLX_CMD_SMAF_LEN];\n\t\tu32 data_u32[NCSI_OEM_MLX_CMD_SMAF_LEN / sizeof(u32)];\n\t} u;\n\tint ret = 0;\n\n\tmemset(&u, 0, sizeof(u));\n\tu.data_u32[0] = ntohl((__force __be32)NCSI_OEM_MFR_MLX_ID);\n\tu.data_u8[5] = NCSI_OEM_MLX_CMD_SMAF;\n\tu.data_u8[6] = NCSI_OEM_MLX_CMD_SMAF_PARAM;\n\tmemcpy(&u.data_u8[MLX_SMAF_MAC_ADDR_OFFSET],\n\t       nca->ndp->ndev.dev->dev_addr,\tETH_ALEN);\n\tu.data_u8[MLX_SMAF_MED_SUPPORT_OFFSET] =\n\t\t(MLX_MC_RBT_AVL | MLX_MC_RBT_SUPPORT);\n\n\tnca->payload = NCSI_OEM_MLX_CMD_SMAF_LEN;\n\tnca->data = u.data_u8;\n\n\tret = ncsi_xmit_cmd(nca);\n\tif (ret)\n\t\tnetdev_err(nca->ndp->ndev.dev,\n\t\t\t   \"NCSI: Failed to transmit cmd 0x%x during probe\\n\",\n\t\t\t   nca->type);\n\treturn ret;\n}\n\nstatic int ncsi_oem_gma_handler_intel(struct ncsi_cmd_arg *nca)\n{\n\tunsigned char data[NCSI_OEM_INTEL_CMD_GMA_LEN];\n\tint ret = 0;\n\n\tnca->payload = NCSI_OEM_INTEL_CMD_GMA_LEN;\n\n\tmemset(data, 0, NCSI_OEM_INTEL_CMD_GMA_LEN);\n\t*(unsigned int *)data = ntohl((__force __be32)NCSI_OEM_MFR_INTEL_ID);\n\tdata[4] = NCSI_OEM_INTEL_CMD_GMA;\n\n\tnca->data = data;\n\n\tret = ncsi_xmit_cmd(nca);\n\tif (ret)\n\t\tnetdev_err(nca->ndp->ndev.dev,\n\t\t\t   \"NCSI: Failed to transmit cmd 0x%x during configure\\n\",\n\t\t\t   nca->type);\n\n\treturn ret;\n}\n\n \nstatic struct ncsi_oem_gma_handler {\n\tunsigned int\tmfr_id;\n\tint\t\t(*handler)(struct ncsi_cmd_arg *nca);\n} ncsi_oem_gma_handlers[] = {\n\t{ NCSI_OEM_MFR_BCM_ID, ncsi_oem_gma_handler_bcm },\n\t{ NCSI_OEM_MFR_MLX_ID, ncsi_oem_gma_handler_mlx },\n\t{ NCSI_OEM_MFR_INTEL_ID, ncsi_oem_gma_handler_intel }\n};\n\nstatic int ncsi_gma_handler(struct ncsi_cmd_arg *nca, unsigned int mf_id)\n{\n\tstruct ncsi_oem_gma_handler *nch = NULL;\n\tint i;\n\n\t \n\tif (nca->ndp->gma_flag == 1)\n\t\treturn -1;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ncsi_oem_gma_handlers); i++) {\n\t\tif (ncsi_oem_gma_handlers[i].mfr_id == mf_id) {\n\t\t\tif (ncsi_oem_gma_handlers[i].handler)\n\t\t\t\tnch = &ncsi_oem_gma_handlers[i];\n\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tif (!nch) {\n\t\tnetdev_err(nca->ndp->ndev.dev,\n\t\t\t   \"NCSI: No GMA handler available for MFR-ID (0x%x)\\n\",\n\t\t\t   mf_id);\n\t\treturn -1;\n\t}\n\n\t \n\treturn nch->handler(nca);\n}\n\n#endif  \n\n \nstatic bool ncsi_channel_is_tx(struct ncsi_dev_priv *ndp,\n\t\t\t       struct ncsi_channel *nc)\n{\n\tstruct ncsi_channel_mode *ncm;\n\tstruct ncsi_channel *channel;\n\tstruct ncsi_package *np;\n\n\t \n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tif (!ndp->multi_package && np != nc->package)\n\t\t\tcontinue;\n\t\tNCSI_FOR_EACH_CHANNEL(np, channel) {\n\t\t\tncm = &channel->modes[NCSI_MODE_TX_ENABLE];\n\t\t\tif (ncm->enable)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_rcu(channel, &ndp->channel_queue, link) {\n\t\tnp = channel->package;\n\t\tif (np->preferred_channel &&\n\t\t    ncsi_channel_has_link(np->preferred_channel)) {\n\t\t\treturn np->preferred_channel == nc;\n\t\t}\n\t}\n\n\t \n\tif (ncsi_channel_has_link(nc))\n\t\treturn true;\n\n\tlist_for_each_entry_rcu(channel, &ndp->channel_queue, link)\n\t\tif (ncsi_channel_has_link(channel))\n\t\t\treturn false;\n\n\t \n\treturn true;\n}\n\n \nint ncsi_update_tx_channel(struct ncsi_dev_priv *ndp,\n\t\t\t   struct ncsi_package *package,\n\t\t\t   struct ncsi_channel *disable,\n\t\t\t   struct ncsi_channel *enable)\n{\n\tstruct ncsi_cmd_arg nca;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_package *np;\n\tint ret = 0;\n\n\tif (!package->multi_channel && !ndp->multi_package)\n\t\tnetdev_warn(ndp->ndev.dev,\n\t\t\t    \"NCSI: Trying to update Tx channel in single-channel mode\\n\");\n\tnca.ndp = ndp;\n\tnca.req_flags = 0;\n\n\t \n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tif (disable)\n\t\t\tbreak;\n\t\tif (!ndp->multi_package && np != package)\n\t\t\tcontinue;\n\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc)\n\t\t\tif (nc->modes[NCSI_MODE_TX_ENABLE].enable) {\n\t\t\t\tdisable = nc;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t \n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tif (enable)\n\t\t\tbreak;\n\t\tif (!ndp->multi_package && np != package)\n\t\t\tcontinue;\n\t\tif (!(ndp->package_whitelist & (0x1 << np->id)))\n\t\t\tcontinue;\n\n\t\tif (np->preferred_channel &&\n\t\t    ncsi_channel_has_link(np->preferred_channel)) {\n\t\t\tenable = np->preferred_channel;\n\t\t\tbreak;\n\t\t}\n\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\tif (!(np->channel_whitelist & 0x1 << nc->id))\n\t\t\t\tcontinue;\n\t\t\tif (nc->state != NCSI_CHANNEL_ACTIVE)\n\t\t\t\tcontinue;\n\t\t\tif (ncsi_channel_has_link(nc)) {\n\t\t\t\tenable = nc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (disable == enable)\n\t\treturn -1;\n\n\tif (!enable)\n\t\treturn -1;\n\n\tif (disable) {\n\t\tnca.channel = disable->id;\n\t\tnca.package = disable->package->id;\n\t\tnca.type = NCSI_PKT_CMD_DCNT;\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret)\n\t\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t\t   \"Error %d sending DCNT\\n\",\n\t\t\t\t   ret);\n\t}\n\n\tnetdev_info(ndp->ndev.dev, \"NCSI: channel %u enables Tx\\n\", enable->id);\n\n\tnca.channel = enable->id;\n\tnca.package = enable->package->id;\n\tnca.type = NCSI_PKT_CMD_ECNT;\n\tret = ncsi_xmit_cmd(&nca);\n\tif (ret)\n\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t   \"Error %d sending ECNT\\n\",\n\t\t\t   ret);\n\n\treturn ret;\n}\n\nstatic void ncsi_configure_channel(struct ncsi_dev_priv *ndp)\n{\n\tstruct ncsi_package *np = ndp->active_package;\n\tstruct ncsi_channel *nc = ndp->active_channel;\n\tstruct ncsi_channel *hot_nc = NULL;\n\tstruct ncsi_dev *nd = &ndp->ndev;\n\tstruct net_device *dev = nd->dev;\n\tstruct ncsi_cmd_arg nca;\n\tunsigned char index;\n\tunsigned long flags;\n\tint ret;\n\n\tnca.ndp = ndp;\n\tnca.req_flags = NCSI_REQ_FLAG_EVENT_DRIVEN;\n\tswitch (nd->state) {\n\tcase ncsi_dev_state_config:\n\tcase ncsi_dev_state_config_sp:\n\t\tndp->pending_req_num = 1;\n\n\t\t \n\t\tnca.type = NCSI_PKT_CMD_SP;\n\t\tif (ndp->flags & NCSI_DEV_HWA)\n\t\t\tnca.bytes[0] = 0;\n\t\telse\n\t\t\tnca.bytes[0] = 1;\n\t\tnca.package = np->id;\n\t\tnca.channel = NCSI_RESERVED_CHANNEL;\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret) {\n\t\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t\t   \"NCSI: Failed to transmit CMD_SP\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tnd->state = ncsi_dev_state_config_cis;\n\t\tbreak;\n\tcase ncsi_dev_state_config_cis:\n\t\tndp->pending_req_num = 1;\n\n\t\t \n\t\tnca.type = NCSI_PKT_CMD_CIS;\n\t\tnca.package = np->id;\n\t\tnca.channel = nc->id;\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret) {\n\t\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t\t   \"NCSI: Failed to transmit CMD_CIS\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tnd->state = ncsi_dev_state_config_oem_gma;\n\t\tbreak;\n\tcase ncsi_dev_state_config_oem_gma:\n\t\tnd->state = ncsi_dev_state_config_clear_vids;\n\t\tret = -1;\n\n#if IS_ENABLED(CONFIG_NCSI_OEM_CMD_GET_MAC)\n\t\tnca.type = NCSI_PKT_CMD_OEM;\n\t\tnca.package = np->id;\n\t\tnca.channel = nc->id;\n\t\tndp->pending_req_num = 1;\n\t\tret = ncsi_gma_handler(&nca, nc->version.mf_id);\n#endif  \n\n\t\tif (ret < 0)\n\t\t\tschedule_work(&ndp->work);\n\n\t\tbreak;\n\tcase ncsi_dev_state_config_clear_vids:\n\tcase ncsi_dev_state_config_svf:\n\tcase ncsi_dev_state_config_ev:\n\tcase ncsi_dev_state_config_sma:\n\tcase ncsi_dev_state_config_ebf:\n\tcase ncsi_dev_state_config_dgmf:\n\tcase ncsi_dev_state_config_ecnt:\n\tcase ncsi_dev_state_config_ec:\n\tcase ncsi_dev_state_config_ae:\n\tcase ncsi_dev_state_config_gls:\n\t\tndp->pending_req_num = 1;\n\n\t\tnca.package = np->id;\n\t\tnca.channel = nc->id;\n\n\t\t \n\t\tif (nd->state == ncsi_dev_state_config_clear_vids) {\n\t\t\tret = clear_one_vid(ndp, nc, &nca);\n\t\t\tif (ret) {\n\t\t\t\tnd->state = ncsi_dev_state_config_svf;\n\t\t\t\tschedule_work(&ndp->work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tnd->state = ncsi_dev_state_config_clear_vids;\n\t\t \n\t\t} else if (nd->state == ncsi_dev_state_config_svf) {\n\t\t\tret = set_one_vid(ndp, nc, &nca);\n\t\t\tif (ret) {\n\t\t\t\tnd->state = ncsi_dev_state_config_ev;\n\t\t\t\tschedule_work(&ndp->work);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tnd->state = ncsi_dev_state_config_svf;\n\t\t \n\t\t} else if (nd->state == ncsi_dev_state_config_ev) {\n\t\t\tif (list_empty(&ndp->vlan_vids)) {\n\t\t\t\tnca.type = NCSI_PKT_CMD_DV;\n\t\t\t} else {\n\t\t\t\tnca.type = NCSI_PKT_CMD_EV;\n\t\t\t\tnca.bytes[3] = NCSI_CAP_VLAN_NO;\n\t\t\t}\n\t\t\tnd->state = ncsi_dev_state_config_sma;\n\t\t} else if (nd->state == ncsi_dev_state_config_sma) {\n\t\t \n\t\t\tnca.type = NCSI_PKT_CMD_SMA;\n\t\t\tfor (index = 0; index < 6; index++)\n\t\t\t\tnca.bytes[index] = dev->dev_addr[index];\n\t\t\tnca.bytes[6] = 0x1;\n\t\t\tnca.bytes[7] = 0x1;\n\t\t\tnd->state = ncsi_dev_state_config_ebf;\n\t\t} else if (nd->state == ncsi_dev_state_config_ebf) {\n\t\t\tnca.type = NCSI_PKT_CMD_EBF;\n\t\t\tnca.dwords[0] = nc->caps[NCSI_CAP_BC].cap;\n\t\t\t \n\t\t\tif (nc->caps[NCSI_CAP_GENERIC].cap &\n\t\t\t    NCSI_CAP_GENERIC_MC)\n\t\t\t\tnd->state = ncsi_dev_state_config_dgmf;\n\t\t\telse if (ncsi_channel_is_tx(ndp, nc))\n\t\t\t\tnd->state = ncsi_dev_state_config_ecnt;\n\t\t\telse\n\t\t\t\tnd->state = ncsi_dev_state_config_ec;\n\t\t} else if (nd->state == ncsi_dev_state_config_dgmf) {\n\t\t\tnca.type = NCSI_PKT_CMD_DGMF;\n\t\t\tif (ncsi_channel_is_tx(ndp, nc))\n\t\t\t\tnd->state = ncsi_dev_state_config_ecnt;\n\t\t\telse\n\t\t\t\tnd->state = ncsi_dev_state_config_ec;\n\t\t} else if (nd->state == ncsi_dev_state_config_ecnt) {\n\t\t\tif (np->preferred_channel &&\n\t\t\t    nc != np->preferred_channel)\n\t\t\t\tnetdev_info(ndp->ndev.dev,\n\t\t\t\t\t    \"NCSI: Tx failed over to channel %u\\n\",\n\t\t\t\t\t    nc->id);\n\t\t\tnca.type = NCSI_PKT_CMD_ECNT;\n\t\t\tnd->state = ncsi_dev_state_config_ec;\n\t\t} else if (nd->state == ncsi_dev_state_config_ec) {\n\t\t\t \n\t\t\tnca.type = NCSI_PKT_CMD_EC;\n\t\t\tnd->state = ncsi_dev_state_config_ae;\n\t\t\tif (!(nc->caps[NCSI_CAP_AEN].cap & NCSI_CAP_AEN_MASK))\n\t\t\t\tnd->state = ncsi_dev_state_config_gls;\n\t\t} else if (nd->state == ncsi_dev_state_config_ae) {\n\t\t\tnca.type = NCSI_PKT_CMD_AE;\n\t\t\tnca.bytes[0] = 0;\n\t\t\tnca.dwords[1] = nc->caps[NCSI_CAP_AEN].cap;\n\t\t\tnd->state = ncsi_dev_state_config_gls;\n\t\t} else if (nd->state == ncsi_dev_state_config_gls) {\n\t\t\tnca.type = NCSI_PKT_CMD_GLS;\n\t\t\tnd->state = ncsi_dev_state_config_done;\n\t\t}\n\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret) {\n\t\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t\t   \"NCSI: Failed to transmit CMD %x\\n\",\n\t\t\t\t   nca.type);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase ncsi_dev_state_config_done:\n\t\tnetdev_dbg(ndp->ndev.dev, \"NCSI: channel %u config done\\n\",\n\t\t\t   nc->id);\n\t\tspin_lock_irqsave(&nc->lock, flags);\n\t\tnc->state = NCSI_CHANNEL_ACTIVE;\n\n\t\tif (ndp->flags & NCSI_DEV_RESET) {\n\t\t\t \n\t\t\tnc->reconfigure_needed = false;\n\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\t\tncsi_reset_dev(nd);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (nc->reconfigure_needed) {\n\t\t\t \n\t\t\tnc->reconfigure_needed = false;\n\t\t\tnc->state = NCSI_CHANNEL_INACTIVE;\n\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\t\t\tspin_lock_irqsave(&ndp->lock, flags);\n\t\t\tlist_add_tail_rcu(&nc->link, &ndp->channel_queue);\n\t\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\t\t\tnetdev_dbg(dev, \"Dirty NCSI channel state reset\\n\");\n\t\t\tncsi_process_next_channel(ndp);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (nc->modes[NCSI_MODE_LINK].data[2] & 0x1) {\n\t\t\thot_nc = nc;\n\t\t} else {\n\t\t\thot_nc = NULL;\n\t\t\tnetdev_dbg(ndp->ndev.dev,\n\t\t\t\t   \"NCSI: channel %u link down after config\\n\",\n\t\t\t\t   nc->id);\n\t\t}\n\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\t\t \n\t\tspin_lock_irqsave(&ndp->lock, flags);\n\t\tndp->hot_channel = hot_nc;\n\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\t\tncsi_start_channel_monitor(nc);\n\t\tncsi_process_next_channel(ndp);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_alert(dev, \"Wrong NCSI state 0x%x in config\\n\",\n\t\t\t     nd->state);\n\t}\n\n\treturn;\n\nerror:\n\tncsi_report_link(ndp, true);\n}\n\nstatic int ncsi_choose_active_channel(struct ncsi_dev_priv *ndp)\n{\n\tstruct ncsi_channel *nc, *found, *hot_nc;\n\tstruct ncsi_channel_mode *ncm;\n\tunsigned long flags, cflags;\n\tstruct ncsi_package *np;\n\tbool with_link;\n\n\tspin_lock_irqsave(&ndp->lock, flags);\n\thot_nc = ndp->hot_channel;\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\t \n\tfound = NULL;\n\twith_link = false;\n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tif (!(ndp->package_whitelist & (0x1 << np->id)))\n\t\t\tcontinue;\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\tif (!(np->channel_whitelist & (0x1 << nc->id)))\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_irqsave(&nc->lock, cflags);\n\n\t\t\tif (!list_empty(&nc->link) ||\n\t\t\t    nc->state != NCSI_CHANNEL_INACTIVE) {\n\t\t\t\tspin_unlock_irqrestore(&nc->lock, cflags);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t\tfound = nc;\n\n\t\t\tif (nc == hot_nc)\n\t\t\t\tfound = nc;\n\n\t\t\tncm = &nc->modes[NCSI_MODE_LINK];\n\t\t\tif (ncm->data[2] & 0x1) {\n\t\t\t\tfound = nc;\n\t\t\t\twith_link = true;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (with_link || np->multi_channel) {\n\t\t\t\tspin_lock_irqsave(&ndp->lock, flags);\n\t\t\t\tlist_add_tail_rcu(&nc->link,\n\t\t\t\t\t\t  &ndp->channel_queue);\n\t\t\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\t\t\t\tnetdev_dbg(ndp->ndev.dev,\n\t\t\t\t\t   \"NCSI: Channel %u added to queue (link %s)\\n\",\n\t\t\t\t\t   nc->id,\n\t\t\t\t\t   ncm->data[2] & 0x1 ? \"up\" : \"down\");\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&nc->lock, cflags);\n\n\t\t\tif (with_link && !np->multi_channel)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (with_link && !ndp->multi_package)\n\t\t\tbreak;\n\t}\n\n\tif (list_empty(&ndp->channel_queue) && found) {\n\t\tnetdev_info(ndp->ndev.dev,\n\t\t\t    \"NCSI: No channel with link found, configuring channel %u\\n\",\n\t\t\t    found->id);\n\t\tspin_lock_irqsave(&ndp->lock, flags);\n\t\tlist_add_tail_rcu(&found->link, &ndp->channel_queue);\n\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t} else if (!found) {\n\t\tnetdev_warn(ndp->ndev.dev,\n\t\t\t    \"NCSI: No channel found to configure!\\n\");\n\t\tncsi_report_link(ndp, true);\n\t\treturn -ENODEV;\n\t}\n\n\treturn ncsi_process_next_channel(ndp);\n}\n\nstatic bool ncsi_check_hwa(struct ncsi_dev_priv *ndp)\n{\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc;\n\tunsigned int cap;\n\tbool has_channel = false;\n\n\t \n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\thas_channel = true;\n\n\t\t\tcap = nc->caps[NCSI_CAP_GENERIC].cap;\n\t\t\tif (!(cap & NCSI_CAP_GENERIC_HWA) ||\n\t\t\t    (cap & NCSI_CAP_GENERIC_HWA_MASK) !=\n\t\t\t    NCSI_CAP_GENERIC_HWA_SUPPORT) {\n\t\t\t\tndp->flags &= ~NCSI_DEV_HWA;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (has_channel) {\n\t\tndp->flags |= NCSI_DEV_HWA;\n\t\treturn true;\n\t}\n\n\tndp->flags &= ~NCSI_DEV_HWA;\n\treturn false;\n}\n\nstatic void ncsi_probe_channel(struct ncsi_dev_priv *ndp)\n{\n\tstruct ncsi_dev *nd = &ndp->ndev;\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_cmd_arg nca;\n\tunsigned char index;\n\tint ret;\n\n\tnca.ndp = ndp;\n\tnca.req_flags = NCSI_REQ_FLAG_EVENT_DRIVEN;\n\tswitch (nd->state) {\n\tcase ncsi_dev_state_probe:\n\t\tnd->state = ncsi_dev_state_probe_deselect;\n\t\tfallthrough;\n\tcase ncsi_dev_state_probe_deselect:\n\t\tndp->pending_req_num = 8;\n\n\t\t \n\t\tnca.type = NCSI_PKT_CMD_DP;\n\t\tnca.channel = NCSI_RESERVED_CHANNEL;\n\t\tfor (index = 0; index < 8; index++) {\n\t\t\tnca.package = index;\n\t\t\tret = ncsi_xmit_cmd(&nca);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tnd->state = ncsi_dev_state_probe_package;\n\t\tbreak;\n\tcase ncsi_dev_state_probe_package:\n\t\tndp->pending_req_num = 1;\n\n\t\tnca.type = NCSI_PKT_CMD_SP;\n\t\tnca.bytes[0] = 1;\n\t\tnca.package = ndp->package_probe_id;\n\t\tnca.channel = NCSI_RESERVED_CHANNEL;\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tnd->state = ncsi_dev_state_probe_channel;\n\t\tbreak;\n\tcase ncsi_dev_state_probe_channel:\n\t\tndp->active_package = ncsi_find_package(ndp,\n\t\t\t\t\t\t\tndp->package_probe_id);\n\t\tif (!ndp->active_package) {\n\t\t\t \n\t\t\tnd->state = ncsi_dev_state_probe_dp;\n\t\t\tschedule_work(&ndp->work);\n\t\t\tbreak;\n\t\t}\n\t\tnd->state = ncsi_dev_state_probe_cis;\n\t\tif (IS_ENABLED(CONFIG_NCSI_OEM_CMD_GET_MAC) &&\n\t\t    ndp->mlx_multi_host)\n\t\t\tnd->state = ncsi_dev_state_probe_mlx_gma;\n\n\t\tschedule_work(&ndp->work);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_NCSI_OEM_CMD_GET_MAC)\n\tcase ncsi_dev_state_probe_mlx_gma:\n\t\tndp->pending_req_num = 1;\n\n\t\tnca.type = NCSI_PKT_CMD_OEM;\n\t\tnca.package = ndp->active_package->id;\n\t\tnca.channel = 0;\n\t\tret = ncsi_oem_gma_handler_mlx(&nca);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tnd->state = ncsi_dev_state_probe_mlx_smaf;\n\t\tbreak;\n\tcase ncsi_dev_state_probe_mlx_smaf:\n\t\tndp->pending_req_num = 1;\n\n\t\tnca.type = NCSI_PKT_CMD_OEM;\n\t\tnca.package = ndp->active_package->id;\n\t\tnca.channel = 0;\n\t\tret = ncsi_oem_smaf_mlx(&nca);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tnd->state = ncsi_dev_state_probe_cis;\n\t\tbreak;\n#endif  \n\tcase ncsi_dev_state_probe_cis:\n\t\tndp->pending_req_num = NCSI_RESERVED_CHANNEL;\n\n\t\t \n\t\tnca.type = NCSI_PKT_CMD_CIS;\n\t\tnca.package = ndp->active_package->id;\n\t\tfor (index = 0; index < NCSI_RESERVED_CHANNEL; index++) {\n\t\t\tnca.channel = index;\n\t\t\tret = ncsi_xmit_cmd(&nca);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tnd->state = ncsi_dev_state_probe_gvi;\n\t\tif (IS_ENABLED(CONFIG_NCSI_OEM_CMD_KEEP_PHY))\n\t\t\tnd->state = ncsi_dev_state_probe_keep_phy;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_NCSI_OEM_CMD_KEEP_PHY)\n\tcase ncsi_dev_state_probe_keep_phy:\n\t\tndp->pending_req_num = 1;\n\n\t\tnca.type = NCSI_PKT_CMD_OEM;\n\t\tnca.package = ndp->active_package->id;\n\t\tnca.channel = 0;\n\t\tret = ncsi_oem_keep_phy_intel(&nca);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tnd->state = ncsi_dev_state_probe_gvi;\n\t\tbreak;\n#endif  \n\tcase ncsi_dev_state_probe_gvi:\n\tcase ncsi_dev_state_probe_gc:\n\tcase ncsi_dev_state_probe_gls:\n\t\tnp = ndp->active_package;\n\t\tndp->pending_req_num = np->channel_num;\n\n\t\t \n\t\tif (nd->state == ncsi_dev_state_probe_gvi)\n\t\t\tnca.type = NCSI_PKT_CMD_GVI;\n\t\telse if (nd->state == ncsi_dev_state_probe_gc)\n\t\t\tnca.type = NCSI_PKT_CMD_GC;\n\t\telse\n\t\t\tnca.type = NCSI_PKT_CMD_GLS;\n\n\t\tnca.package = np->id;\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\tnca.channel = nc->id;\n\t\t\tret = ncsi_xmit_cmd(&nca);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tif (nd->state == ncsi_dev_state_probe_gvi)\n\t\t\tnd->state = ncsi_dev_state_probe_gc;\n\t\telse if (nd->state == ncsi_dev_state_probe_gc)\n\t\t\tnd->state = ncsi_dev_state_probe_gls;\n\t\telse\n\t\t\tnd->state = ncsi_dev_state_probe_dp;\n\t\tbreak;\n\tcase ncsi_dev_state_probe_dp:\n\t\tndp->pending_req_num = 1;\n\n\t\t \n\t\tnca.type = NCSI_PKT_CMD_DP;\n\t\tnca.package = ndp->package_probe_id;\n\t\tnca.channel = NCSI_RESERVED_CHANNEL;\n\t\tret = ncsi_xmit_cmd(&nca);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tndp->package_probe_id++;\n\t\tif (ndp->package_probe_id >= 8) {\n\t\t\t \n\t\t\tndp->flags |= NCSI_DEV_PROBED;\n\t\t\tbreak;\n\t\t}\n\t\tnd->state = ncsi_dev_state_probe_package;\n\t\tndp->active_package = NULL;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(nd->dev, \"Wrong NCSI state 0x%0x in enumeration\\n\",\n\t\t\t    nd->state);\n\t}\n\n\tif (ndp->flags & NCSI_DEV_PROBED) {\n\t\t \n\t\tncsi_check_hwa(ndp);\n\t\tncsi_choose_active_channel(ndp);\n\t}\n\n\treturn;\nerror:\n\tnetdev_err(ndp->ndev.dev,\n\t\t   \"NCSI: Failed to transmit cmd 0x%x during probe\\n\",\n\t\t   nca.type);\n\tncsi_report_link(ndp, true);\n}\n\nstatic void ncsi_dev_work(struct work_struct *work)\n{\n\tstruct ncsi_dev_priv *ndp = container_of(work,\n\t\t\tstruct ncsi_dev_priv, work);\n\tstruct ncsi_dev *nd = &ndp->ndev;\n\n\tswitch (nd->state & ncsi_dev_state_major) {\n\tcase ncsi_dev_state_probe:\n\t\tncsi_probe_channel(ndp);\n\t\tbreak;\n\tcase ncsi_dev_state_suspend:\n\t\tncsi_suspend_channel(ndp);\n\t\tbreak;\n\tcase ncsi_dev_state_config:\n\t\tncsi_configure_channel(ndp);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(nd->dev, \"Wrong NCSI state 0x%x in workqueue\\n\",\n\t\t\t    nd->state);\n\t}\n}\n\nint ncsi_process_next_channel(struct ncsi_dev_priv *ndp)\n{\n\tstruct ncsi_channel *nc;\n\tint old_state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ndp->lock, flags);\n\tnc = list_first_or_null_rcu(&ndp->channel_queue,\n\t\t\t\t    struct ncsi_channel, link);\n\tif (!nc) {\n\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\tgoto out;\n\t}\n\n\tlist_del_init(&nc->link);\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\told_state = nc->state;\n\tnc->state = NCSI_CHANNEL_INVISIBLE;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\tndp->active_channel = nc;\n\tndp->active_package = nc->package;\n\n\tswitch (old_state) {\n\tcase NCSI_CHANNEL_INACTIVE:\n\t\tndp->ndev.state = ncsi_dev_state_config;\n\t\tnetdev_dbg(ndp->ndev.dev, \"NCSI: configuring channel %u\\n\",\n\t                   nc->id);\n\t\tncsi_configure_channel(ndp);\n\t\tbreak;\n\tcase NCSI_CHANNEL_ACTIVE:\n\t\tndp->ndev.state = ncsi_dev_state_suspend;\n\t\tnetdev_dbg(ndp->ndev.dev, \"NCSI: suspending channel %u\\n\",\n\t\t\t   nc->id);\n\t\tncsi_suspend_channel(ndp);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(ndp->ndev.dev, \"Invalid state 0x%x on %d:%d\\n\",\n\t\t\t   old_state, nc->package->id, nc->id);\n\t\tncsi_report_link(ndp, false);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\nout:\n\tndp->active_channel = NULL;\n\tndp->active_package = NULL;\n\tif (ndp->flags & NCSI_DEV_RESHUFFLE) {\n\t\tndp->flags &= ~NCSI_DEV_RESHUFFLE;\n\t\treturn ncsi_choose_active_channel(ndp);\n\t}\n\n\tncsi_report_link(ndp, false);\n\treturn -ENODEV;\n}\n\nstatic int ncsi_kick_channels(struct ncsi_dev_priv *ndp)\n{\n\tstruct ncsi_dev *nd = &ndp->ndev;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_package *np;\n\tunsigned long flags;\n\tunsigned int n = 0;\n\n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\tspin_lock_irqsave(&nc->lock, flags);\n\n\t\t\t \n\t\t\tif (nc->state != NCSI_CHANNEL_ACTIVE) {\n\t\t\t\tif ((ndp->ndev.state & 0xff00) ==\n\t\t\t\t\t\tncsi_dev_state_config ||\n\t\t\t\t\t\t!list_empty(&nc->link)) {\n\t\t\t\t\tnetdev_dbg(nd->dev,\n\t\t\t\t\t\t   \"NCSI: channel %p marked dirty\\n\",\n\t\t\t\t\t\t   nc);\n\t\t\t\t\tnc->reconfigure_needed = true;\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\t\t\tncsi_stop_channel_monitor(nc);\n\t\t\tspin_lock_irqsave(&nc->lock, flags);\n\t\t\tnc->state = NCSI_CHANNEL_INACTIVE;\n\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\t\t\tspin_lock_irqsave(&ndp->lock, flags);\n\t\t\tlist_add_tail_rcu(&nc->link, &ndp->channel_queue);\n\t\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\t\t\tnetdev_dbg(nd->dev, \"NCSI: kicked channel %p\\n\", nc);\n\t\t\tn++;\n\t\t}\n\t}\n\n\treturn n;\n}\n\nint ncsi_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct ncsi_dev_priv *ndp;\n\tunsigned int n_vids = 0;\n\tstruct vlan_vid *vlan;\n\tstruct ncsi_dev *nd;\n\tbool found = false;\n\n\tif (vid == 0)\n\t\treturn 0;\n\n\tnd = ncsi_find_dev(dev);\n\tif (!nd) {\n\t\tnetdev_warn(dev, \"NCSI: No net_device?\\n\");\n\t\treturn 0;\n\t}\n\n\tndp = TO_NCSI_DEV_PRIV(nd);\n\n\t \n\tlist_for_each_entry_rcu(vlan, &ndp->vlan_vids, list) {\n\t\tn_vids++;\n\t\tif (vlan->vid == vid) {\n\t\t\tnetdev_dbg(dev, \"NCSI: vid %u already registered\\n\",\n\t\t\t\t   vid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (n_vids >= NCSI_MAX_VLAN_VIDS) {\n\t\tnetdev_warn(dev,\n\t\t\t    \"tried to add vlan id %u but NCSI max already registered (%u)\\n\",\n\t\t\t    vid, NCSI_MAX_VLAN_VIDS);\n\t\treturn -ENOSPC;\n\t}\n\n\tvlan = kzalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\n\tvlan->proto = proto;\n\tvlan->vid = vid;\n\tlist_add_rcu(&vlan->list, &ndp->vlan_vids);\n\n\tnetdev_dbg(dev, \"NCSI: Added new vid %u\\n\", vid);\n\n\tfound = ncsi_kick_channels(ndp) != 0;\n\n\treturn found ? ncsi_process_next_channel(ndp) : 0;\n}\nEXPORT_SYMBOL_GPL(ncsi_vlan_rx_add_vid);\n\nint ncsi_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct vlan_vid *vlan, *tmp;\n\tstruct ncsi_dev_priv *ndp;\n\tstruct ncsi_dev *nd;\n\tbool found = false;\n\n\tif (vid == 0)\n\t\treturn 0;\n\n\tnd = ncsi_find_dev(dev);\n\tif (!nd) {\n\t\tnetdev_warn(dev, \"NCSI: no net_device?\\n\");\n\t\treturn 0;\n\t}\n\n\tndp = TO_NCSI_DEV_PRIV(nd);\n\n\t \n\tlist_for_each_entry_safe(vlan, tmp, &ndp->vlan_vids, list)\n\t\tif (vlan->vid == vid) {\n\t\t\tnetdev_dbg(dev, \"NCSI: vid %u found, removing\\n\", vid);\n\t\t\tlist_del_rcu(&vlan->list);\n\t\t\tfound = true;\n\t\t\tkfree(vlan);\n\t\t}\n\n\tif (!found) {\n\t\tnetdev_err(dev, \"NCSI: vid %u wasn't registered!\\n\", vid);\n\t\treturn -EINVAL;\n\t}\n\n\tfound = ncsi_kick_channels(ndp) != 0;\n\n\treturn found ? ncsi_process_next_channel(ndp) : 0;\n}\nEXPORT_SYMBOL_GPL(ncsi_vlan_rx_kill_vid);\n\nstruct ncsi_dev *ncsi_register_dev(struct net_device *dev,\n\t\t\t\t   void (*handler)(struct ncsi_dev *ndev))\n{\n\tstruct ncsi_dev_priv *ndp;\n\tstruct ncsi_dev *nd;\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tnd = ncsi_find_dev(dev);\n\tif (nd)\n\t\treturn nd;\n\n\t \n\tndp = kzalloc(sizeof(*ndp), GFP_ATOMIC);\n\tif (!ndp)\n\t\treturn NULL;\n\n\tnd = &ndp->ndev;\n\tnd->state = ncsi_dev_state_registered;\n\tnd->dev = dev;\n\tnd->handler = handler;\n\tndp->pending_req_num = 0;\n\tINIT_LIST_HEAD(&ndp->channel_queue);\n\tINIT_LIST_HEAD(&ndp->vlan_vids);\n\tINIT_WORK(&ndp->work, ncsi_dev_work);\n\tndp->package_whitelist = UINT_MAX;\n\n\t \n\tspin_lock_init(&ndp->lock);\n\tINIT_LIST_HEAD(&ndp->packages);\n\tndp->request_id = NCSI_REQ_START_IDX;\n\tfor (i = 0; i < ARRAY_SIZE(ndp->requests); i++) {\n\t\tndp->requests[i].id = i;\n\t\tndp->requests[i].ndp = ndp;\n\t\ttimer_setup(&ndp->requests[i].timer, ncsi_request_timeout, 0);\n\t}\n\n\tspin_lock_irqsave(&ncsi_dev_lock, flags);\n\tlist_add_tail_rcu(&ndp->node, &ncsi_dev_list);\n\tspin_unlock_irqrestore(&ncsi_dev_lock, flags);\n\n\t \n\tndp->ptype.type = cpu_to_be16(ETH_P_NCSI);\n\tndp->ptype.func = ncsi_rcv_rsp;\n\tndp->ptype.dev = dev;\n\tdev_add_pack(&ndp->ptype);\n\n\tpdev = to_platform_device(dev->dev.parent);\n\tif (pdev) {\n\t\tnp = pdev->dev.of_node;\n\t\tif (np && (of_property_read_bool(np, \"mellanox,multi-host\") ||\n\t\t\t   of_property_read_bool(np, \"mlx,multi-host\")))\n\t\t\tndp->mlx_multi_host = true;\n\t}\n\n\treturn nd;\n}\nEXPORT_SYMBOL_GPL(ncsi_register_dev);\n\nint ncsi_start_dev(struct ncsi_dev *nd)\n{\n\tstruct ncsi_dev_priv *ndp = TO_NCSI_DEV_PRIV(nd);\n\n\tif (nd->state != ncsi_dev_state_registered &&\n\t    nd->state != ncsi_dev_state_functional)\n\t\treturn -ENOTTY;\n\n\tif (!(ndp->flags & NCSI_DEV_PROBED)) {\n\t\tndp->package_probe_id = 0;\n\t\tnd->state = ncsi_dev_state_probe;\n\t\tschedule_work(&ndp->work);\n\t\treturn 0;\n\t}\n\n\treturn ncsi_reset_dev(nd);\n}\nEXPORT_SYMBOL_GPL(ncsi_start_dev);\n\nvoid ncsi_stop_dev(struct ncsi_dev *nd)\n{\n\tstruct ncsi_dev_priv *ndp = TO_NCSI_DEV_PRIV(nd);\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc;\n\tbool chained;\n\tint old_state;\n\tunsigned long flags;\n\n\t \n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\tncsi_stop_channel_monitor(nc);\n\n\t\t\tspin_lock_irqsave(&nc->lock, flags);\n\t\t\tchained = !list_empty(&nc->link);\n\t\t\told_state = nc->state;\n\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\t\t\tWARN_ON_ONCE(chained ||\n\t\t\t\t     old_state == NCSI_CHANNEL_INVISIBLE);\n\t\t}\n\t}\n\n\tnetdev_dbg(ndp->ndev.dev, \"NCSI: Stopping device\\n\");\n\tncsi_report_link(ndp, true);\n}\nEXPORT_SYMBOL_GPL(ncsi_stop_dev);\n\nint ncsi_reset_dev(struct ncsi_dev *nd)\n{\n\tstruct ncsi_dev_priv *ndp = TO_NCSI_DEV_PRIV(nd);\n\tstruct ncsi_channel *nc, *active, *tmp;\n\tstruct ncsi_package *np;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ndp->lock, flags);\n\n\tif (!(ndp->flags & NCSI_DEV_RESET)) {\n\t\t \n\t\tswitch (nd->state & ncsi_dev_state_major) {\n\t\tcase ncsi_dev_state_registered:\n\t\tcase ncsi_dev_state_probe:\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\t\treturn 0;\n\t\tcase ncsi_dev_state_suspend:\n\t\tcase ncsi_dev_state_config:\n\t\t\t \n\t\t\tndp->flags |= NCSI_DEV_RESET;\n\t\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tswitch (nd->state) {\n\t\tcase ncsi_dev_state_suspend_done:\n\t\tcase ncsi_dev_state_config_done:\n\t\tcase ncsi_dev_state_functional:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!list_empty(&ndp->channel_queue)) {\n\t\t \n\t\tlist_for_each_entry_safe(nc, tmp, &ndp->channel_queue, link)\n\t\t\tlist_del_init(&nc->link);\n\t}\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\tactive = NULL;\n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\tspin_lock_irqsave(&nc->lock, flags);\n\n\t\t\tif (nc->state == NCSI_CHANNEL_ACTIVE) {\n\t\t\t\tactive = nc;\n\t\t\t\tnc->state = NCSI_CHANNEL_INVISIBLE;\n\t\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\t\t\tncsi_stop_channel_monitor(nc);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\t}\n\t\tif (active)\n\t\t\tbreak;\n\t}\n\n\tif (!active) {\n\t\t \n\t\tspin_lock_irqsave(&ndp->lock, flags);\n\t\tndp->flags &= ~NCSI_DEV_RESET;\n\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\treturn ncsi_choose_active_channel(ndp);\n\t}\n\n\tspin_lock_irqsave(&ndp->lock, flags);\n\tndp->flags |= NCSI_DEV_RESET;\n\tndp->active_channel = active;\n\tndp->active_package = active->package;\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\tnd->state = ncsi_dev_state_suspend;\n\tschedule_work(&ndp->work);\n\treturn 0;\n}\n\nvoid ncsi_unregister_dev(struct ncsi_dev *nd)\n{\n\tstruct ncsi_dev_priv *ndp = TO_NCSI_DEV_PRIV(nd);\n\tstruct ncsi_package *np, *tmp;\n\tunsigned long flags;\n\n\tdev_remove_pack(&ndp->ptype);\n\n\tlist_for_each_entry_safe(np, tmp, &ndp->packages, node)\n\t\tncsi_remove_package(np);\n\n\tspin_lock_irqsave(&ncsi_dev_lock, flags);\n\tlist_del_rcu(&ndp->node);\n\tspin_unlock_irqrestore(&ncsi_dev_lock, flags);\n\n\tkfree(ndp);\n}\nEXPORT_SYMBOL_GPL(ncsi_unregister_dev);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}