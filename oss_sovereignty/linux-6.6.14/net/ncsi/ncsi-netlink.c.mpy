{
  "module_name": "ncsi-netlink.c",
  "hash_id": "abb2b7d096b55a875282c0ee4870b008029701549e1627811475c1e08c025f01",
  "original_prompt": "Ingested from linux-6.6.14/net/ncsi/ncsi-netlink.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <linux/rtnetlink.h>\n#include <linux/etherdevice.h>\n#include <net/genetlink.h>\n#include <net/ncsi.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <uapi/linux/ncsi.h>\n\n#include \"internal.h\"\n#include \"ncsi-pkt.h\"\n#include \"ncsi-netlink.h\"\n\nstatic struct genl_family ncsi_genl_family;\n\nstatic const struct nla_policy ncsi_genl_policy[NCSI_ATTR_MAX + 1] = {\n\t[NCSI_ATTR_IFINDEX] =\t\t{ .type = NLA_U32 },\n\t[NCSI_ATTR_PACKAGE_LIST] =\t{ .type = NLA_NESTED },\n\t[NCSI_ATTR_PACKAGE_ID] =\t{ .type = NLA_U32 },\n\t[NCSI_ATTR_CHANNEL_ID] =\t{ .type = NLA_U32 },\n\t[NCSI_ATTR_DATA] =\t\t{ .type = NLA_BINARY, .len = 2048 },\n\t[NCSI_ATTR_MULTI_FLAG] =\t{ .type = NLA_FLAG },\n\t[NCSI_ATTR_PACKAGE_MASK] =\t{ .type = NLA_U32 },\n\t[NCSI_ATTR_CHANNEL_MASK] =\t{ .type = NLA_U32 },\n};\n\nstatic struct ncsi_dev_priv *ndp_from_ifindex(struct net *net, u32 ifindex)\n{\n\tstruct ncsi_dev_priv *ndp;\n\tstruct net_device *dev;\n\tstruct ncsi_dev *nd;\n\tstruct ncsi_dev;\n\n\tif (!net)\n\t\treturn NULL;\n\n\tdev = dev_get_by_index(net, ifindex);\n\tif (!dev) {\n\t\tpr_err(\"NCSI netlink: No device for ifindex %u\\n\", ifindex);\n\t\treturn NULL;\n\t}\n\n\tnd = ncsi_find_dev(dev);\n\tndp = nd ? TO_NCSI_DEV_PRIV(nd) : NULL;\n\n\tdev_put(dev);\n\treturn ndp;\n}\n\nstatic int ncsi_write_channel_info(struct sk_buff *skb,\n\t\t\t\t   struct ncsi_dev_priv *ndp,\n\t\t\t\t   struct ncsi_channel *nc)\n{\n\tstruct ncsi_channel_vlan_filter *ncf;\n\tstruct ncsi_channel_mode *m;\n\tstruct nlattr *vid_nest;\n\tint i;\n\n\tnla_put_u32(skb, NCSI_CHANNEL_ATTR_ID, nc->id);\n\tm = &nc->modes[NCSI_MODE_LINK];\n\tnla_put_u32(skb, NCSI_CHANNEL_ATTR_LINK_STATE, m->data[2]);\n\tif (nc->state == NCSI_CHANNEL_ACTIVE)\n\t\tnla_put_flag(skb, NCSI_CHANNEL_ATTR_ACTIVE);\n\tif (nc == nc->package->preferred_channel)\n\t\tnla_put_flag(skb, NCSI_CHANNEL_ATTR_FORCED);\n\n\tnla_put_u32(skb, NCSI_CHANNEL_ATTR_VERSION_MAJOR, nc->version.major);\n\tnla_put_u32(skb, NCSI_CHANNEL_ATTR_VERSION_MINOR, nc->version.minor);\n\tnla_put_string(skb, NCSI_CHANNEL_ATTR_VERSION_STR, nc->version.fw_name);\n\n\tvid_nest = nla_nest_start_noflag(skb, NCSI_CHANNEL_ATTR_VLAN_LIST);\n\tif (!vid_nest)\n\t\treturn -ENOMEM;\n\tncf = &nc->vlan_filter;\n\ti = -1;\n\twhile ((i = find_next_bit((void *)&ncf->bitmap, ncf->n_vids,\n\t\t\t\t  i + 1)) < ncf->n_vids) {\n\t\tif (ncf->vids[i])\n\t\t\tnla_put_u16(skb, NCSI_CHANNEL_ATTR_VLAN_ID,\n\t\t\t\t    ncf->vids[i]);\n\t}\n\tnla_nest_end(skb, vid_nest);\n\n\treturn 0;\n}\n\nstatic int ncsi_write_package_info(struct sk_buff *skb,\n\t\t\t\t   struct ncsi_dev_priv *ndp, unsigned int id)\n{\n\tstruct nlattr *pnest, *cnest, *nest;\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc;\n\tbool found;\n\tint rc;\n\n\tif (id > ndp->package_num - 1) {\n\t\tnetdev_info(ndp->ndev.dev, \"NCSI: No package with id %u\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\tfound = false;\n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tif (np->id != id)\n\t\t\tcontinue;\n\t\tpnest = nla_nest_start_noflag(skb, NCSI_PKG_ATTR);\n\t\tif (!pnest)\n\t\t\treturn -ENOMEM;\n\t\trc = nla_put_u32(skb, NCSI_PKG_ATTR_ID, np->id);\n\t\tif (rc) {\n\t\t\tnla_nest_cancel(skb, pnest);\n\t\t\treturn rc;\n\t\t}\n\t\tif ((0x1 << np->id) == ndp->package_whitelist)\n\t\t\tnla_put_flag(skb, NCSI_PKG_ATTR_FORCED);\n\t\tcnest = nla_nest_start_noflag(skb, NCSI_PKG_ATTR_CHANNEL_LIST);\n\t\tif (!cnest) {\n\t\t\tnla_nest_cancel(skb, pnest);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\t\tnest = nla_nest_start_noflag(skb, NCSI_CHANNEL_ATTR);\n\t\t\tif (!nest) {\n\t\t\t\tnla_nest_cancel(skb, cnest);\n\t\t\t\tnla_nest_cancel(skb, pnest);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\trc = ncsi_write_channel_info(skb, ndp, nc);\n\t\t\tif (rc) {\n\t\t\t\tnla_nest_cancel(skb, nest);\n\t\t\t\tnla_nest_cancel(skb, cnest);\n\t\t\t\tnla_nest_cancel(skb, pnest);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\t\tnla_nest_end(skb, cnest);\n\t\tnla_nest_end(skb, pnest);\n\t\tfound = true;\n\t}\n\n\tif (!found)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int ncsi_pkg_info_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct ncsi_dev_priv *ndp;\n\tunsigned int package_id;\n\tstruct sk_buff *skb;\n\tstruct nlattr *attr;\n\tvoid *hdr;\n\tint rc;\n\n\tif (!info || !info->attrs)\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NCSI_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NCSI_ATTR_PACKAGE_ID])\n\t\treturn -EINVAL;\n\n\tndp = ndp_from_ifindex(genl_info_net(info),\n\t\t\t       nla_get_u32(info->attrs[NCSI_ATTR_IFINDEX]));\n\tif (!ndp)\n\t\treturn -ENODEV;\n\n\tskb = genlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(skb, info->snd_portid, info->snd_seq,\n\t\t\t  &ncsi_genl_family, 0, NCSI_CMD_PKG_INFO);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tpackage_id = nla_get_u32(info->attrs[NCSI_ATTR_PACKAGE_ID]);\n\n\tattr = nla_nest_start_noflag(skb, NCSI_ATTR_PACKAGE_LIST);\n\tif (!attr) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\trc = ncsi_write_package_info(skb, ndp, package_id);\n\n\tif (rc) {\n\t\tnla_nest_cancel(skb, attr);\n\t\tgoto err;\n\t}\n\n\tnla_nest_end(skb, attr);\n\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, info);\n\nerr:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\nstatic int ncsi_pkg_info_all_nl(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tstruct nlattr *attrs[NCSI_ATTR_MAX + 1];\n\tstruct ncsi_package *np, *package;\n\tstruct ncsi_dev_priv *ndp;\n\tunsigned int package_id;\n\tstruct nlattr *attr;\n\tvoid *hdr;\n\tint rc;\n\n\trc = genlmsg_parse_deprecated(cb->nlh, &ncsi_genl_family, attrs, NCSI_ATTR_MAX,\n\t\t\t\t      ncsi_genl_policy, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!attrs[NCSI_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tndp = ndp_from_ifindex(get_net(sock_net(skb->sk)),\n\t\t\t       nla_get_u32(attrs[NCSI_ATTR_IFINDEX]));\n\n\tif (!ndp)\n\t\treturn -ENODEV;\n\n\tpackage_id = cb->args[0];\n\tpackage = NULL;\n\tNCSI_FOR_EACH_PACKAGE(ndp, np)\n\t\tif (np->id == package_id)\n\t\t\tpackage = np;\n\n\tif (!package)\n\t\treturn 0;  \n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &ncsi_genl_family, NLM_F_MULTI,  NCSI_CMD_PKG_INFO);\n\tif (!hdr) {\n\t\trc = -EMSGSIZE;\n\t\tgoto err;\n\t}\n\n\tattr = nla_nest_start_noflag(skb, NCSI_ATTR_PACKAGE_LIST);\n\tif (!attr) {\n\t\trc = -EMSGSIZE;\n\t\tgoto err;\n\t}\n\trc = ncsi_write_package_info(skb, ndp, package->id);\n\tif (rc) {\n\t\tnla_nest_cancel(skb, attr);\n\t\tgoto err;\n\t}\n\n\tnla_nest_end(skb, attr);\n\tgenlmsg_end(skb, hdr);\n\n\tcb->args[0] = package_id + 1;\n\n\treturn skb->len;\nerr:\n\tgenlmsg_cancel(skb, hdr);\n\treturn rc;\n}\n\nstatic int ncsi_set_interface_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct ncsi_package *np, *package;\n\tstruct ncsi_channel *nc, *channel;\n\tu32 package_id, channel_id;\n\tstruct ncsi_dev_priv *ndp;\n\tunsigned long flags;\n\n\tif (!info || !info->attrs)\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NCSI_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NCSI_ATTR_PACKAGE_ID])\n\t\treturn -EINVAL;\n\n\tndp = ndp_from_ifindex(get_net(sock_net(msg->sk)),\n\t\t\t       nla_get_u32(info->attrs[NCSI_ATTR_IFINDEX]));\n\tif (!ndp)\n\t\treturn -ENODEV;\n\n\tpackage_id = nla_get_u32(info->attrs[NCSI_ATTR_PACKAGE_ID]);\n\tpackage = NULL;\n\n\tNCSI_FOR_EACH_PACKAGE(ndp, np)\n\t\tif (np->id == package_id)\n\t\t\tpackage = np;\n\tif (!package) {\n\t\t \n\t\treturn -ERANGE;\n\t}\n\n\tchannel = NULL;\n\tif (info->attrs[NCSI_ATTR_CHANNEL_ID]) {\n\t\tchannel_id = nla_get_u32(info->attrs[NCSI_ATTR_CHANNEL_ID]);\n\t\tNCSI_FOR_EACH_CHANNEL(package, nc)\n\t\t\tif (nc->id == channel_id) {\n\t\t\t\tchannel = nc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!channel) {\n\t\t\tnetdev_info(ndp->ndev.dev,\n\t\t\t\t    \"NCSI: Channel %u does not exist!\\n\",\n\t\t\t\t    channel_id);\n\t\t\treturn -ERANGE;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&ndp->lock, flags);\n\tndp->package_whitelist = 0x1 << package->id;\n\tndp->multi_package = false;\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\tspin_lock_irqsave(&package->lock, flags);\n\tpackage->multi_channel = false;\n\tif (channel) {\n\t\tpackage->channel_whitelist = 0x1 << channel->id;\n\t\tpackage->preferred_channel = channel;\n\t} else {\n\t\t \n\t\tpackage->channel_whitelist = UINT_MAX;\n\t\tpackage->preferred_channel = NULL;\n\t}\n\tspin_unlock_irqrestore(&package->lock, flags);\n\n\tif (channel)\n\t\tnetdev_info(ndp->ndev.dev,\n\t\t\t    \"Set package 0x%x, channel 0x%x as preferred\\n\",\n\t\t\t    package_id, channel_id);\n\telse\n\t\tnetdev_info(ndp->ndev.dev, \"Set package 0x%x as preferred\\n\",\n\t\t\t    package_id);\n\n\t \n\tif (!(ndp->flags & NCSI_DEV_RESET))\n\t\tncsi_reset_dev(&ndp->ndev);\n\n\treturn 0;\n}\n\nstatic int ncsi_clear_interface_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct ncsi_dev_priv *ndp;\n\tstruct ncsi_package *np;\n\tunsigned long flags;\n\n\tif (!info || !info->attrs)\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NCSI_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tndp = ndp_from_ifindex(get_net(sock_net(msg->sk)),\n\t\t\t       nla_get_u32(info->attrs[NCSI_ATTR_IFINDEX]));\n\tif (!ndp)\n\t\treturn -ENODEV;\n\n\t \n\tspin_lock_irqsave(&ndp->lock, flags);\n\tndp->package_whitelist = UINT_MAX;\n\tndp->multi_package = false;\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tnp->multi_channel = false;\n\t\tnp->channel_whitelist = UINT_MAX;\n\t\tnp->preferred_channel = NULL;\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t}\n\tnetdev_info(ndp->ndev.dev, \"NCSI: Cleared preferred package/channel\\n\");\n\n\t \n\tif (!(ndp->flags & NCSI_DEV_RESET))\n\t\tncsi_reset_dev(&ndp->ndev);\n\n\treturn 0;\n}\n\nstatic int ncsi_send_cmd_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct ncsi_dev_priv *ndp;\n\tstruct ncsi_pkt_hdr *hdr;\n\tstruct ncsi_cmd_arg nca;\n\tunsigned char *data;\n\tu32 package_id;\n\tu32 channel_id;\n\tint len, ret;\n\n\tif (!info || !info->attrs) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!info->attrs[NCSI_ATTR_IFINDEX]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!info->attrs[NCSI_ATTR_PACKAGE_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!info->attrs[NCSI_ATTR_CHANNEL_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!info->attrs[NCSI_ATTR_DATA]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tndp = ndp_from_ifindex(get_net(sock_net(msg->sk)),\n\t\t\t       nla_get_u32(info->attrs[NCSI_ATTR_IFINDEX]));\n\tif (!ndp) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tpackage_id = nla_get_u32(info->attrs[NCSI_ATTR_PACKAGE_ID]);\n\tchannel_id = nla_get_u32(info->attrs[NCSI_ATTR_CHANNEL_ID]);\n\n\tif (package_id >= NCSI_MAX_PACKAGE || channel_id >= NCSI_MAX_CHANNEL) {\n\t\tret = -ERANGE;\n\t\tgoto out_netlink;\n\t}\n\n\tlen = nla_len(info->attrs[NCSI_ATTR_DATA]);\n\tif (len < sizeof(struct ncsi_pkt_hdr)) {\n\t\tnetdev_info(ndp->ndev.dev, \"NCSI: no command to send %u\\n\",\n\t\t\t    package_id);\n\t\tret = -EINVAL;\n\t\tgoto out_netlink;\n\t} else {\n\t\tdata = (unsigned char *)nla_data(info->attrs[NCSI_ATTR_DATA]);\n\t}\n\n\thdr = (struct ncsi_pkt_hdr *)data;\n\n\tnca.ndp = ndp;\n\tnca.package = (unsigned char)package_id;\n\tnca.channel = (unsigned char)channel_id;\n\tnca.type = hdr->type;\n\tnca.req_flags = NCSI_REQ_FLAG_NETLINK_DRIVEN;\n\tnca.info = info;\n\tnca.payload = ntohs(hdr->length);\n\tnca.data = data + sizeof(*hdr);\n\n\tret = ncsi_xmit_cmd(&nca);\nout_netlink:\n\tif (ret != 0) {\n\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t   \"NCSI: Error %d sending command\\n\",\n\t\t\t   ret);\n\t\tncsi_send_netlink_err(ndp->ndev.dev,\n\t\t\t\t      info->snd_seq,\n\t\t\t\t      info->snd_portid,\n\t\t\t\t      info->nlhdr,\n\t\t\t\t      ret);\n\t}\nout:\n\treturn ret;\n}\n\nint ncsi_send_netlink_rsp(struct ncsi_request *nr,\n\t\t\t  struct ncsi_package *np,\n\t\t\t  struct ncsi_channel *nc)\n{\n\tstruct sk_buff *skb;\n\tstruct net *net;\n\tvoid *hdr;\n\tint rc;\n\n\tnet = dev_net(nr->rsp->dev);\n\n\tskb = genlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(skb, nr->snd_portid, nr->snd_seq,\n\t\t\t  &ncsi_genl_family, 0, NCSI_CMD_SEND_CMD);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnla_put_u32(skb, NCSI_ATTR_IFINDEX, nr->rsp->dev->ifindex);\n\tif (np)\n\t\tnla_put_u32(skb, NCSI_ATTR_PACKAGE_ID, np->id);\n\tif (nc)\n\t\tnla_put_u32(skb, NCSI_ATTR_CHANNEL_ID, nc->id);\n\telse\n\t\tnla_put_u32(skb, NCSI_ATTR_CHANNEL_ID, NCSI_RESERVED_CHANNEL);\n\n\trc = nla_put(skb, NCSI_ATTR_DATA, nr->rsp->len, (void *)nr->rsp->data);\n\tif (rc)\n\t\tgoto err;\n\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_unicast(net, skb, nr->snd_portid);\n\nerr:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\nint ncsi_send_netlink_timeout(struct ncsi_request *nr,\n\t\t\t      struct ncsi_package *np,\n\t\t\t      struct ncsi_channel *nc)\n{\n\tstruct sk_buff *skb;\n\tstruct net *net;\n\tvoid *hdr;\n\n\tskb = genlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(skb, nr->snd_portid, nr->snd_seq,\n\t\t\t  &ncsi_genl_family, 0, NCSI_CMD_SEND_CMD);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnet = dev_net(nr->cmd->dev);\n\n\tnla_put_u32(skb, NCSI_ATTR_IFINDEX, nr->cmd->dev->ifindex);\n\n\tif (np)\n\t\tnla_put_u32(skb, NCSI_ATTR_PACKAGE_ID, np->id);\n\telse\n\t\tnla_put_u32(skb, NCSI_ATTR_PACKAGE_ID,\n\t\t\t    NCSI_PACKAGE_INDEX((((struct ncsi_pkt_hdr *)\n\t\t\t\t\t\t nr->cmd->data)->channel)));\n\n\tif (nc)\n\t\tnla_put_u32(skb, NCSI_ATTR_CHANNEL_ID, nc->id);\n\telse\n\t\tnla_put_u32(skb, NCSI_ATTR_CHANNEL_ID, NCSI_RESERVED_CHANNEL);\n\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_unicast(net, skb, nr->snd_portid);\n}\n\nint ncsi_send_netlink_err(struct net_device *dev,\n\t\t\t  u32 snd_seq,\n\t\t\t  u32 snd_portid,\n\t\t\t  const struct nlmsghdr *nlhdr,\n\t\t\t  int err)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct nlmsgerr *nle;\n\tstruct sk_buff *skb;\n\tstruct net *net;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tnet = dev_net(dev);\n\n\tnlh = nlmsg_put(skb, snd_portid, snd_seq,\n\t\t\tNLMSG_ERROR, sizeof(*nle), 0);\n\tnle = (struct nlmsgerr *)nlmsg_data(nlh);\n\tnle->error = err;\n\tmemcpy(&nle->msg, nlhdr, sizeof(*nlh));\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_unicast(net->genl_sock, skb, snd_portid);\n}\n\nstatic int ncsi_set_package_mask_nl(struct sk_buff *msg,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct ncsi_dev_priv *ndp;\n\tunsigned long flags;\n\tint rc;\n\n\tif (!info || !info->attrs)\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NCSI_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NCSI_ATTR_PACKAGE_MASK])\n\t\treturn -EINVAL;\n\n\tndp = ndp_from_ifindex(get_net(sock_net(msg->sk)),\n\t\t\t       nla_get_u32(info->attrs[NCSI_ATTR_IFINDEX]));\n\tif (!ndp)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&ndp->lock, flags);\n\tif (nla_get_flag(info->attrs[NCSI_ATTR_MULTI_FLAG])) {\n\t\tif (ndp->flags & NCSI_DEV_HWA) {\n\t\t\tndp->multi_package = true;\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t\t   \"NCSI: Can't use multiple packages without HWA\\n\");\n\t\t\trc = -EPERM;\n\t\t}\n\t} else {\n\t\tndp->multi_package = false;\n\t\trc = 0;\n\t}\n\n\tif (!rc)\n\t\tndp->package_whitelist =\n\t\t\tnla_get_u32(info->attrs[NCSI_ATTR_PACKAGE_MASK]);\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\n\tif (!rc) {\n\t\t \n\t\tif (!(ndp->flags & NCSI_DEV_RESET))\n\t\t\tncsi_reset_dev(&ndp->ndev);\n\t}\n\n\treturn rc;\n}\n\nstatic int ncsi_set_channel_mask_nl(struct sk_buff *msg,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct ncsi_package *np, *package;\n\tstruct ncsi_channel *nc, *channel;\n\tu32 package_id, channel_id;\n\tstruct ncsi_dev_priv *ndp;\n\tunsigned long flags;\n\n\tif (!info || !info->attrs)\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NCSI_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NCSI_ATTR_PACKAGE_ID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NCSI_ATTR_CHANNEL_MASK])\n\t\treturn -EINVAL;\n\n\tndp = ndp_from_ifindex(get_net(sock_net(msg->sk)),\n\t\t\t       nla_get_u32(info->attrs[NCSI_ATTR_IFINDEX]));\n\tif (!ndp)\n\t\treturn -ENODEV;\n\n\tpackage_id = nla_get_u32(info->attrs[NCSI_ATTR_PACKAGE_ID]);\n\tpackage = NULL;\n\tNCSI_FOR_EACH_PACKAGE(ndp, np)\n\t\tif (np->id == package_id) {\n\t\t\tpackage = np;\n\t\t\tbreak;\n\t\t}\n\tif (!package)\n\t\treturn -ERANGE;\n\n\tspin_lock_irqsave(&package->lock, flags);\n\n\tchannel = NULL;\n\tif (info->attrs[NCSI_ATTR_CHANNEL_ID]) {\n\t\tchannel_id = nla_get_u32(info->attrs[NCSI_ATTR_CHANNEL_ID]);\n\t\tNCSI_FOR_EACH_CHANNEL(np, nc)\n\t\t\tif (nc->id == channel_id) {\n\t\t\t\tchannel = nc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!channel) {\n\t\t\tspin_unlock_irqrestore(&package->lock, flags);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tnetdev_dbg(ndp->ndev.dev,\n\t\t\t   \"NCSI: Channel %u set as preferred channel\\n\",\n\t\t\t   channel->id);\n\t}\n\n\tpackage->channel_whitelist =\n\t\tnla_get_u32(info->attrs[NCSI_ATTR_CHANNEL_MASK]);\n\tif (package->channel_whitelist == 0)\n\t\tnetdev_dbg(ndp->ndev.dev,\n\t\t\t   \"NCSI: Package %u set to all channels disabled\\n\",\n\t\t\t   package->id);\n\n\tpackage->preferred_channel = channel;\n\n\tif (nla_get_flag(info->attrs[NCSI_ATTR_MULTI_FLAG])) {\n\t\tpackage->multi_channel = true;\n\t\tnetdev_info(ndp->ndev.dev,\n\t\t\t    \"NCSI: Multi-channel enabled on package %u\\n\",\n\t\t\t    package_id);\n\t} else {\n\t\tpackage->multi_channel = false;\n\t}\n\n\tspin_unlock_irqrestore(&package->lock, flags);\n\n\t \n\tif (!(ndp->flags & NCSI_DEV_RESET))\n\t\tncsi_reset_dev(&ndp->ndev);\n\n\treturn 0;\n}\n\nstatic const struct genl_small_ops ncsi_ops[] = {\n\t{\n\t\t.cmd = NCSI_CMD_PKG_INFO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = ncsi_pkg_info_nl,\n\t\t.dumpit = ncsi_pkg_info_all_nl,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.cmd = NCSI_CMD_SET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = ncsi_set_interface_nl,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NCSI_CMD_CLEAR_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = ncsi_clear_interface_nl,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NCSI_CMD_SEND_CMD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = ncsi_send_cmd_nl,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NCSI_CMD_SET_PACKAGE_MASK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = ncsi_set_package_mask_nl,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NCSI_CMD_SET_CHANNEL_MASK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = ncsi_set_channel_mask_nl,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family ncsi_genl_family __ro_after_init = {\n\t.name = \"NCSI\",\n\t.version = 0,\n\t.maxattr = NCSI_ATTR_MAX,\n\t.policy = ncsi_genl_policy,\n\t.module = THIS_MODULE,\n\t.small_ops = ncsi_ops,\n\t.n_small_ops = ARRAY_SIZE(ncsi_ops),\n\t.resv_start_op = NCSI_CMD_SET_CHANNEL_MASK + 1,\n};\n\nstatic int __init ncsi_init_netlink(void)\n{\n\treturn genl_register_family(&ncsi_genl_family);\n}\nsubsys_initcall(ncsi_init_netlink);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}