{
  "module_name": "ncsi-aen.c",
  "hash_id": "2eb8cdf3be1d4bc26e0746d47588fcaf998250bf151eabaf5877cec8c64f7e7a",
  "original_prompt": "Ingested from linux-6.6.14/net/ncsi/ncsi-aen.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n\n#include <net/ncsi.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n\n#include \"internal.h\"\n#include \"ncsi-pkt.h\"\n\nstatic int ncsi_validate_aen_pkt(struct ncsi_aen_pkt_hdr *h,\n\t\t\t\t const unsigned short payload)\n{\n\tu32 checksum;\n\t__be32 *pchecksum;\n\n\tif (h->common.revision != NCSI_PKT_REVISION)\n\t\treturn -EINVAL;\n\tif (ntohs(h->common.length) != payload)\n\t\treturn -EINVAL;\n\n\t \n\tpchecksum = (__be32 *)((void *)(h + 1) + payload - 4);\n\tif (ntohl(*pchecksum) == 0)\n\t\treturn 0;\n\n\tchecksum = ncsi_calculate_checksum((unsigned char *)h,\n\t\t\t\t\t   sizeof(*h) + payload - 4);\n\tif (*pchecksum != htonl(checksum))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ncsi_aen_handler_lsc(struct ncsi_dev_priv *ndp,\n\t\t\t\tstruct ncsi_aen_pkt_hdr *h)\n{\n\tstruct ncsi_channel *nc, *tmp;\n\tstruct ncsi_channel_mode *ncm;\n\tunsigned long old_data, data;\n\tstruct ncsi_aen_lsc_pkt *lsc;\n\tstruct ncsi_package *np;\n\tbool had_link, has_link;\n\tunsigned long flags;\n\tbool chained;\n\tint state;\n\n\t \n\tncsi_find_package_and_channel(ndp, h->common.channel, NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tlsc = (struct ncsi_aen_lsc_pkt *)h;\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\tncm = &nc->modes[NCSI_MODE_LINK];\n\told_data = ncm->data[2];\n\tdata = ntohl(lsc->status);\n\tncm->data[2] = data;\n\tncm->data[4] = ntohl(lsc->oem_status);\n\n\thad_link = !!(old_data & 0x1);\n\thas_link = !!(data & 0x1);\n\n\tnetdev_dbg(ndp->ndev.dev, \"NCSI: LSC AEN - channel %u state %s\\n\",\n\t\t   nc->id, data & 0x1 ? \"up\" : \"down\");\n\n\tchained = !list_empty(&nc->link);\n\tstate = nc->state;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\tif (state == NCSI_CHANNEL_INACTIVE)\n\t\tnetdev_warn(ndp->ndev.dev,\n\t\t\t    \"NCSI: Inactive channel %u received AEN!\\n\",\n\t\t\t    nc->id);\n\n\tif ((had_link == has_link) || chained)\n\t\treturn 0;\n\n\tif (!ndp->multi_package && !nc->package->multi_channel) {\n\t\tif (had_link) {\n\t\t\tndp->flags |= NCSI_DEV_RESHUFFLE;\n\t\t\tncsi_stop_channel_monitor(nc);\n\t\t\tspin_lock_irqsave(&ndp->lock, flags);\n\t\t\tlist_add_tail_rcu(&nc->link, &ndp->channel_queue);\n\t\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\t\treturn ncsi_process_next_channel(ndp);\n\t\t}\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (had_link) {\n\t\tncm = &nc->modes[NCSI_MODE_TX_ENABLE];\n\t\tif (ncsi_channel_is_last(ndp, nc)) {\n\t\t\t \n\t\t\treturn ncsi_reset_dev(&ndp->ndev);\n\t\t} else if (ncm->enable) {\n\t\t\t \n\t\t\tncsi_update_tx_channel(ndp, nc->package, nc, NULL);\n\t\t}\n\t} else if (has_link && nc->package->preferred_channel == nc) {\n\t\t \n\t\tncsi_update_tx_channel(ndp, nc->package, NULL, nc);\n\t} else if (has_link) {\n\t\tNCSI_FOR_EACH_PACKAGE(ndp, np) {\n\t\t\tNCSI_FOR_EACH_CHANNEL(np, tmp) {\n\t\t\t\t \n\t\t\t\tncm = &tmp->modes[NCSI_MODE_TX_ENABLE];\n\t\t\t\tif (ncm->enable &&\n\t\t\t\t    !ncsi_channel_has_link(tmp)) {\n\t\t\t\t\tncsi_update_tx_channel(ndp, nc->package,\n\t\t\t\t\t\t\t       tmp, nc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int ncsi_aen_handler_cr(struct ncsi_dev_priv *ndp,\n\t\t\t       struct ncsi_aen_pkt_hdr *h)\n{\n\tstruct ncsi_channel *nc;\n\tunsigned long flags;\n\n\t \n\tncsi_find_package_and_channel(ndp, h->common.channel, NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\tif (!list_empty(&nc->link) ||\n\t    nc->state != NCSI_CHANNEL_ACTIVE) {\n\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\tncsi_stop_channel_monitor(nc);\n\tspin_lock_irqsave(&nc->lock, flags);\n\tnc->state = NCSI_CHANNEL_INVISIBLE;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\tspin_lock_irqsave(&ndp->lock, flags);\n\tnc->state = NCSI_CHANNEL_INACTIVE;\n\tlist_add_tail_rcu(&nc->link, &ndp->channel_queue);\n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\tnc->modes[NCSI_MODE_TX_ENABLE].enable = 0;\n\n\treturn ncsi_process_next_channel(ndp);\n}\n\nstatic int ncsi_aen_handler_hncdsc(struct ncsi_dev_priv *ndp,\n\t\t\t\t   struct ncsi_aen_pkt_hdr *h)\n{\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\tstruct ncsi_aen_hncdsc_pkt *hncdsc;\n\tunsigned long flags;\n\n\t \n\tncsi_find_package_and_channel(ndp, h->common.channel, NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&nc->lock, flags);\n\tncm = &nc->modes[NCSI_MODE_LINK];\n\thncdsc = (struct ncsi_aen_hncdsc_pkt *)h;\n\tncm->data[3] = ntohl(hncdsc->status);\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\tnetdev_dbg(ndp->ndev.dev,\n\t\t   \"NCSI: host driver %srunning on channel %u\\n\",\n\t\t   ncm->data[3] & 0x1 ? \"\" : \"not \", nc->id);\n\n\treturn 0;\n}\n\nstatic struct ncsi_aen_handler {\n\tunsigned char type;\n\tint           payload;\n\tint           (*handler)(struct ncsi_dev_priv *ndp,\n\t\t\t\t struct ncsi_aen_pkt_hdr *h);\n} ncsi_aen_handlers[] = {\n\t{ NCSI_PKT_AEN_LSC,    12, ncsi_aen_handler_lsc    },\n\t{ NCSI_PKT_AEN_CR,      4, ncsi_aen_handler_cr     },\n\t{ NCSI_PKT_AEN_HNCDSC,  8, ncsi_aen_handler_hncdsc }\n};\n\nint ncsi_aen_handler(struct ncsi_dev_priv *ndp, struct sk_buff *skb)\n{\n\tstruct ncsi_aen_pkt_hdr *h;\n\tstruct ncsi_aen_handler *nah = NULL;\n\tint i, ret;\n\n\t \n\th = (struct ncsi_aen_pkt_hdr *)skb_network_header(skb);\n\tfor (i = 0; i < ARRAY_SIZE(ncsi_aen_handlers); i++) {\n\t\tif (ncsi_aen_handlers[i].type == h->type) {\n\t\t\tnah = &ncsi_aen_handlers[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nah) {\n\t\tnetdev_warn(ndp->ndev.dev, \"Invalid AEN (0x%x) received\\n\",\n\t\t\t    h->type);\n\t\treturn -ENOENT;\n\t}\n\n\tret = ncsi_validate_aen_pkt(h, nah->payload);\n\tif (ret) {\n\t\tnetdev_warn(ndp->ndev.dev,\n\t\t\t    \"NCSI: 'bad' packet ignored for AEN type 0x%x\\n\",\n\t\t\t    h->type);\n\t\tgoto out;\n\t}\n\n\tret = nah->handler(ndp, h);\n\tif (ret)\n\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t   \"NCSI: Handler for AEN type 0x%x returned %d\\n\",\n\t\t\t   h->type, ret);\nout:\n\tconsume_skb(skb);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}