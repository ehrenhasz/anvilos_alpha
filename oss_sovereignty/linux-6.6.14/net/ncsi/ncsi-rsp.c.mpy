{
  "module_name": "ncsi-rsp.c",
  "hash_id": "bdc7e24dda57471365ef1238dda8ad48f1b823e4286f6c44b9757ad63a705ef3",
  "original_prompt": "Ingested from linux-6.6.14/net/ncsi/ncsi-rsp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n\n#include <net/ncsi.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/genetlink.h>\n\n#include \"internal.h\"\n#include \"ncsi-pkt.h\"\n#include \"ncsi-netlink.h\"\n\n \nstatic u8 decode_bcd_u8(u8 x)\n{\n\tint lo = x & 0xF;\n\tint hi = x >> 4;\n\n\tlo = lo < 0xA ? lo : 0;\n\thi = hi < 0xA ? hi : 0;\n\treturn lo + hi * 10;\n}\n\nstatic int ncsi_validate_rsp_pkt(struct ncsi_request *nr,\n\t\t\t\t unsigned short payload)\n{\n\tstruct ncsi_rsp_pkt_hdr *h;\n\tu32 checksum;\n\t__be32 *pchecksum;\n\n\t \n\th = (struct ncsi_rsp_pkt_hdr *)skb_network_header(nr->rsp);\n\n\tif (h->common.revision != NCSI_PKT_REVISION) {\n\t\tnetdev_dbg(nr->ndp->ndev.dev,\n\t\t\t   \"NCSI: unsupported header revision\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (ntohs(h->common.length) != payload) {\n\t\tnetdev_dbg(nr->ndp->ndev.dev,\n\t\t\t   \"NCSI: payload length mismatched\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ntohs(h->code) != NCSI_PKT_RSP_C_COMPLETED ||\n\t    ntohs(h->reason) != NCSI_PKT_RSP_R_NO_ERROR) {\n\t\tnetdev_dbg(nr->ndp->ndev.dev,\n\t\t\t   \"NCSI: non zero response/reason code %04xh, %04xh\\n\",\n\t\t\t    ntohs(h->code), ntohs(h->reason));\n\t\treturn -EPERM;\n\t}\n\n\t \n\tpchecksum = (__be32 *)((void *)(h + 1) + ALIGN(payload, 4) - 4);\n\tif (ntohl(*pchecksum) == 0)\n\t\treturn 0;\n\n\tchecksum = ncsi_calculate_checksum((unsigned char *)h,\n\t\t\t\t\t   sizeof(*h) + payload - 4);\n\n\tif (*pchecksum != htonl(checksum)) {\n\t\tnetdev_dbg(nr->ndp->ndev.dev,\n\t\t\t   \"NCSI: checksum mismatched; recd: %08x calc: %08x\\n\",\n\t\t\t   *pchecksum, htonl(checksum));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_cis(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc;\n\tunsigned char id;\n\n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel, &np, &nc);\n\tif (!nc) {\n\t\tif (ndp->flags & NCSI_DEV_PROBED)\n\t\t\treturn -ENXIO;\n\n\t\tid = NCSI_CHANNEL_INDEX(rsp->rsp.common.channel);\n\t\tnc = ncsi_add_channel(np, id);\n\t}\n\n\treturn nc ? 0 : -ENODEV;\n}\n\nstatic int ncsi_rsp_handler_sp(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_package *np;\n\tunsigned char id;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      &np, NULL);\n\tif (!np) {\n\t\tif (ndp->flags & NCSI_DEV_PROBED)\n\t\t\treturn -ENXIO;\n\n\t\tid = NCSI_PACKAGE_INDEX(rsp->rsp.common.channel);\n\t\tnp = ncsi_add_package(ndp, id);\n\t\tif (!np)\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_dp(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc;\n\tunsigned long flags;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      &np, NULL);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\t \n\tNCSI_FOR_EACH_CHANNEL(np, nc) {\n\t\tspin_lock_irqsave(&nc->lock, flags);\n\t\tnc->state = NCSI_CHANNEL_INACTIVE;\n\t\tspin_unlock_irqrestore(&nc->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_ec(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\tncm = &nc->modes[NCSI_MODE_ENABLE];\n\tif (ncm->enable)\n\t\treturn 0;\n\n\tncm->enable = 1;\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_dc(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\tint ret;\n\n\tret = ncsi_validate_rsp_pkt(nr, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\tncm = &nc->modes[NCSI_MODE_ENABLE];\n\tif (!ncm->enable)\n\t\treturn 0;\n\n\tncm->enable = 0;\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_rc(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tunsigned long flags;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tspin_lock_irqsave(&nc->lock, flags);\n\tnc->state = NCSI_CHANNEL_INACTIVE;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_ecnt(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\tncm = &nc->modes[NCSI_MODE_TX_ENABLE];\n\tif (ncm->enable)\n\t\treturn 0;\n\n\tncm->enable = 1;\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_dcnt(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\tncm = &nc->modes[NCSI_MODE_TX_ENABLE];\n\tif (!ncm->enable)\n\t\treturn 0;\n\n\tncm->enable = 0;\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_ae(struct ncsi_request *nr)\n{\n\tstruct ncsi_cmd_ae_pkt *cmd;\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncm = &nc->modes[NCSI_MODE_AEN];\n\tif (ncm->enable)\n\t\treturn 0;\n\n\t \n\tcmd = (struct ncsi_cmd_ae_pkt *)skb_network_header(nr->cmd);\n\tncm->enable = 1;\n\tncm->data[0] = cmd->mc_id;\n\tncm->data[1] = ntohl(cmd->mode);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_sl(struct ncsi_request *nr)\n{\n\tstruct ncsi_cmd_sl_pkt *cmd;\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\tcmd = (struct ncsi_cmd_sl_pkt *)skb_network_header(nr->cmd);\n\tncm = &nc->modes[NCSI_MODE_LINK];\n\tncm->data[0] = ntohl(cmd->mode);\n\tncm->data[1] = ntohl(cmd->oem_mode);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_gls(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_gls_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\tunsigned long flags;\n\n\t \n\trsp = (struct ncsi_rsp_gls_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\tncm = &nc->modes[NCSI_MODE_LINK];\n\tncm->data[2] = ntohl(rsp->status);\n\tncm->data[3] = ntohl(rsp->other);\n\tncm->data[4] = ntohl(rsp->oem_status);\n\n\tif (nr->flags & NCSI_REQ_FLAG_EVENT_DRIVEN)\n\t\treturn 0;\n\n\t \n\tspin_lock_irqsave(&nc->lock, flags);\n\tnc->monitor.state = NCSI_CHANNEL_MONITOR_START;\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_svf(struct ncsi_request *nr)\n{\n\tstruct ncsi_cmd_svf_pkt *cmd;\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_vlan_filter *ncf;\n\tunsigned long flags;\n\tvoid *bitmap;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\tcmd = (struct ncsi_cmd_svf_pkt *)skb_network_header(nr->cmd);\n\tncf = &nc->vlan_filter;\n\tif (cmd->index == 0 || cmd->index > ncf->n_vids)\n\t\treturn -ERANGE;\n\n\t \n\tspin_lock_irqsave(&nc->lock, flags);\n\tbitmap = &ncf->bitmap;\n\tif (!(cmd->enable & 0x1)) {\n\t\tif (test_and_clear_bit(cmd->index - 1, bitmap))\n\t\t\tncf->vids[cmd->index - 1] = 0;\n\t} else {\n\t\tset_bit(cmd->index - 1, bitmap);\n\t\tncf->vids[cmd->index - 1] = ntohs(cmd->vlan);\n\t}\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_ev(struct ncsi_request *nr)\n{\n\tstruct ncsi_cmd_ev_pkt *cmd;\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncm = &nc->modes[NCSI_MODE_VLAN];\n\tif (ncm->enable)\n\t\treturn 0;\n\n\t \n\tcmd = (struct ncsi_cmd_ev_pkt *)skb_network_header(nr->cmd);\n\tncm->enable = 1;\n\tncm->data[0] = ntohl((__force __be32)cmd->mode);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_dv(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncm = &nc->modes[NCSI_MODE_VLAN];\n\tif (!ncm->enable)\n\t\treturn 0;\n\n\t \n\tncm->enable = 0;\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_sma(struct ncsi_request *nr)\n{\n\tstruct ncsi_cmd_sma_pkt *cmd;\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mac_filter *ncf;\n\tunsigned long flags;\n\tvoid *bitmap;\n\tbool enabled;\n\tint index;\n\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tcmd = (struct ncsi_cmd_sma_pkt *)skb_network_header(nr->cmd);\n\tenabled = cmd->at_e & 0x1;\n\tncf = &nc->mac_filter;\n\tbitmap = &ncf->bitmap;\n\n\tif (cmd->index == 0 ||\n\t    cmd->index > ncf->n_uc + ncf->n_mc + ncf->n_mixed)\n\t\treturn -ERANGE;\n\n\tindex = (cmd->index - 1) * ETH_ALEN;\n\tspin_lock_irqsave(&nc->lock, flags);\n\tif (enabled) {\n\t\tset_bit(cmd->index - 1, bitmap);\n\t\tmemcpy(&ncf->addrs[index], cmd->mac, ETH_ALEN);\n\t} else {\n\t\tclear_bit(cmd->index - 1, bitmap);\n\t\teth_zero_addr(&ncf->addrs[index]);\n\t}\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_ebf(struct ncsi_request *nr)\n{\n\tstruct ncsi_cmd_ebf_pkt *cmd;\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel, NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncm = &nc->modes[NCSI_MODE_BC];\n\tif (ncm->enable)\n\t\treturn 0;\n\n\t \n\tcmd = (struct ncsi_cmd_ebf_pkt *)skb_network_header(nr->cmd);\n\tncm->enable = 1;\n\tncm->data[0] = ntohl(cmd->mode);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_dbf(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncm = &nc->modes[NCSI_MODE_BC];\n\tif (!ncm->enable)\n\t\treturn 0;\n\n\t \n\tncm->enable = 0;\n\tncm->data[0] = 0;\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_egmf(struct ncsi_request *nr)\n{\n\tstruct ncsi_cmd_egmf_pkt *cmd;\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncm = &nc->modes[NCSI_MODE_MC];\n\tif (ncm->enable)\n\t\treturn 0;\n\n\t \n\tcmd = (struct ncsi_cmd_egmf_pkt *)skb_network_header(nr->cmd);\n\tncm->enable = 1;\n\tncm->data[0] = ntohl(cmd->mode);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_dgmf(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncm = &nc->modes[NCSI_MODE_MC];\n\tif (!ncm->enable)\n\t\treturn 0;\n\n\t \n\tncm->enable = 0;\n\tncm->data[0] = 0;\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_snfc(struct ncsi_request *nr)\n{\n\tstruct ncsi_cmd_snfc_pkt *cmd;\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_mode *ncm;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncm = &nc->modes[NCSI_MODE_FC];\n\tif (ncm->enable)\n\t\treturn 0;\n\n\t \n\tcmd = (struct ncsi_cmd_snfc_pkt *)skb_network_header(nr->cmd);\n\tncm->enable = 1;\n\tncm->data[0] = cmd->mode;\n\n\treturn 0;\n}\n\n \nstatic int ncsi_rsp_handler_oem_gma(struct ncsi_request *nr, int mfr_id)\n{\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct net_device *ndev = ndp->ndev.dev;\n\tstruct ncsi_rsp_oem_pkt *rsp;\n\tstruct sockaddr saddr;\n\tu32 mac_addr_off = 0;\n\tint ret = 0;\n\n\t \n\trsp = (struct ncsi_rsp_oem_pkt *)skb_network_header(nr->rsp);\n\n\tsaddr.sa_family = ndev->type;\n\tndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\tif (mfr_id == NCSI_OEM_MFR_BCM_ID)\n\t\tmac_addr_off = BCM_MAC_ADDR_OFFSET;\n\telse if (mfr_id == NCSI_OEM_MFR_MLX_ID)\n\t\tmac_addr_off = MLX_MAC_ADDR_OFFSET;\n\telse if (mfr_id == NCSI_OEM_MFR_INTEL_ID)\n\t\tmac_addr_off = INTEL_MAC_ADDR_OFFSET;\n\n\tmemcpy(saddr.sa_data, &rsp->data[mac_addr_off], ETH_ALEN);\n\tif (mfr_id == NCSI_OEM_MFR_BCM_ID || mfr_id == NCSI_OEM_MFR_INTEL_ID)\n\t\teth_addr_inc((u8 *)saddr.sa_data);\n\tif (!is_valid_ether_addr((const u8 *)saddr.sa_data))\n\t\treturn -ENXIO;\n\n\t \n\tndp->gma_flag = 1;\n\n\trtnl_lock();\n\tret = dev_set_mac_address(ndev, &saddr, NULL);\n\trtnl_unlock();\n\tif (ret < 0)\n\t\tnetdev_warn(ndev, \"NCSI: 'Writing mac address to device failed\\n\");\n\n\treturn ret;\n}\n\n \nstatic int ncsi_rsp_handler_oem_mlx(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_oem_mlx_pkt *mlx;\n\tstruct ncsi_rsp_oem_pkt *rsp;\n\n\t \n\trsp = (struct ncsi_rsp_oem_pkt *)skb_network_header(nr->rsp);\n\tmlx = (struct ncsi_rsp_oem_mlx_pkt *)(rsp->data);\n\n\tif (mlx->cmd == NCSI_OEM_MLX_CMD_GMA &&\n\t    mlx->param == NCSI_OEM_MLX_CMD_GMA_PARAM)\n\t\treturn ncsi_rsp_handler_oem_gma(nr, NCSI_OEM_MFR_MLX_ID);\n\treturn 0;\n}\n\n \nstatic int ncsi_rsp_handler_oem_bcm(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_oem_bcm_pkt *bcm;\n\tstruct ncsi_rsp_oem_pkt *rsp;\n\n\t \n\trsp = (struct ncsi_rsp_oem_pkt *)skb_network_header(nr->rsp);\n\tbcm = (struct ncsi_rsp_oem_bcm_pkt *)(rsp->data);\n\n\tif (bcm->type == NCSI_OEM_BCM_CMD_GMA)\n\t\treturn ncsi_rsp_handler_oem_gma(nr, NCSI_OEM_MFR_BCM_ID);\n\treturn 0;\n}\n\n \nstatic int ncsi_rsp_handler_oem_intel(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_oem_intel_pkt *intel;\n\tstruct ncsi_rsp_oem_pkt *rsp;\n\n\t \n\trsp = (struct ncsi_rsp_oem_pkt *)skb_network_header(nr->rsp);\n\tintel = (struct ncsi_rsp_oem_intel_pkt *)(rsp->data);\n\n\tif (intel->cmd == NCSI_OEM_INTEL_CMD_GMA)\n\t\treturn ncsi_rsp_handler_oem_gma(nr, NCSI_OEM_MFR_INTEL_ID);\n\n\treturn 0;\n}\n\nstatic struct ncsi_rsp_oem_handler {\n\tunsigned int\tmfr_id;\n\tint\t\t(*handler)(struct ncsi_request *nr);\n} ncsi_rsp_oem_handlers[] = {\n\t{ NCSI_OEM_MFR_MLX_ID, ncsi_rsp_handler_oem_mlx },\n\t{ NCSI_OEM_MFR_BCM_ID, ncsi_rsp_handler_oem_bcm },\n\t{ NCSI_OEM_MFR_INTEL_ID, ncsi_rsp_handler_oem_intel }\n};\n\n \nstatic int ncsi_rsp_handler_oem(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_oem_handler *nrh = NULL;\n\tstruct ncsi_rsp_oem_pkt *rsp;\n\tunsigned int mfr_id, i;\n\n\t \n\trsp = (struct ncsi_rsp_oem_pkt *)skb_network_header(nr->rsp);\n\tmfr_id = ntohl(rsp->mfr_id);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ncsi_rsp_oem_handlers); i++) {\n\t\tif (ncsi_rsp_oem_handlers[i].mfr_id == mfr_id) {\n\t\t\tif (ncsi_rsp_oem_handlers[i].handler)\n\t\t\t\tnrh = &ncsi_rsp_oem_handlers[i];\n\t\t\telse\n\t\t\t\tnrh = NULL;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nrh) {\n\t\tnetdev_err(nr->ndp->ndev.dev, \"Received unrecognized OEM packet with MFR-ID (0x%x)\\n\",\n\t\t\t   mfr_id);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\treturn nrh->handler(nr);\n}\n\nstatic int ncsi_rsp_handler_gvi(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_gvi_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_version *ncv;\n\tint i;\n\n\t \n\trsp = (struct ncsi_rsp_gvi_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncv = &nc->version;\n\tncv->major = decode_bcd_u8(rsp->major);\n\tncv->minor = decode_bcd_u8(rsp->minor);\n\tncv->update = decode_bcd_u8(rsp->update);\n\tncv->alpha1 = rsp->alpha1;\n\tncv->alpha2 = rsp->alpha2;\n\tmemcpy(ncv->fw_name, rsp->fw_name, 12);\n\tncv->fw_version = ntohl(rsp->fw_version);\n\tfor (i = 0; i < ARRAY_SIZE(ncv->pci_ids); i++)\n\t\tncv->pci_ids[i] = ntohs(rsp->pci_ids[i]);\n\tncv->mf_id = ntohl(rsp->mf_id);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_gc(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_gc_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tsize_t size;\n\n\t \n\trsp = (struct ncsi_rsp_gc_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tnc->caps[NCSI_CAP_GENERIC].cap = ntohl(rsp->cap) &\n\t\t\t\t\t NCSI_CAP_GENERIC_MASK;\n\tnc->caps[NCSI_CAP_BC].cap = ntohl(rsp->bc_cap) &\n\t\t\t\t    NCSI_CAP_BC_MASK;\n\tnc->caps[NCSI_CAP_MC].cap = ntohl(rsp->mc_cap) &\n\t\t\t\t    NCSI_CAP_MC_MASK;\n\tnc->caps[NCSI_CAP_BUFFER].cap = ntohl(rsp->buf_cap);\n\tnc->caps[NCSI_CAP_AEN].cap = ntohl(rsp->aen_cap) &\n\t\t\t\t     NCSI_CAP_AEN_MASK;\n\tnc->caps[NCSI_CAP_VLAN].cap = rsp->vlan_mode &\n\t\t\t\t      NCSI_CAP_VLAN_MASK;\n\n\tsize = (rsp->uc_cnt + rsp->mc_cnt + rsp->mixed_cnt) * ETH_ALEN;\n\tnc->mac_filter.addrs = kzalloc(size, GFP_ATOMIC);\n\tif (!nc->mac_filter.addrs)\n\t\treturn -ENOMEM;\n\tnc->mac_filter.n_uc = rsp->uc_cnt;\n\tnc->mac_filter.n_mc = rsp->mc_cnt;\n\tnc->mac_filter.n_mixed = rsp->mixed_cnt;\n\n\tnc->vlan_filter.vids = kcalloc(rsp->vlan_cnt,\n\t\t\t\t       sizeof(*nc->vlan_filter.vids),\n\t\t\t\t       GFP_ATOMIC);\n\tif (!nc->vlan_filter.vids)\n\t\treturn -ENOMEM;\n\t \n\tnc->vlan_filter.bitmap = U64_MAX;\n\tnc->vlan_filter.n_vids = rsp->vlan_cnt;\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_gp(struct ncsi_request *nr)\n{\n\tstruct ncsi_channel_vlan_filter *ncvf;\n\tstruct ncsi_channel_mac_filter *ncmf;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_rsp_gp_pkt *rsp;\n\tstruct ncsi_channel *nc;\n\tunsigned short enable;\n\tunsigned char *pdata;\n\tunsigned long flags;\n\tvoid *bitmap;\n\tint i;\n\n\t \n\trsp = (struct ncsi_rsp_gp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tif (ntohl(rsp->valid_modes) & 0x1) {\t \n\t\tnc->modes[NCSI_MODE_BC].enable = 1;\n\t\tnc->modes[NCSI_MODE_BC].data[0] = ntohl(rsp->bc_mode);\n\t}\n\tif (ntohl(rsp->valid_modes) & 0x2)\t \n\t\tnc->modes[NCSI_MODE_ENABLE].enable = 1;\n\tif (ntohl(rsp->valid_modes) & 0x4)\t \n\t\tnc->modes[NCSI_MODE_TX_ENABLE].enable = 1;\n\tif (ntohl(rsp->valid_modes) & 0x8)\t \n\t\tnc->modes[NCSI_MODE_MC].enable = 1;\n\n\t \n\tnc->modes[NCSI_MODE_LINK].enable = 1;\n\tnc->modes[NCSI_MODE_LINK].data[0] = ntohl(rsp->link_mode);\n\tnc->modes[NCSI_MODE_VLAN].enable = 1;\n\tnc->modes[NCSI_MODE_VLAN].data[0] = rsp->vlan_mode;\n\tnc->modes[NCSI_MODE_FC].enable = 1;\n\tnc->modes[NCSI_MODE_FC].data[0] = rsp->fc_mode;\n\tnc->modes[NCSI_MODE_AEN].enable = 1;\n\tnc->modes[NCSI_MODE_AEN].data[0] = ntohl(rsp->aen_mode);\n\n\t \n\tpdata = (unsigned char *)rsp + 48;\n\tenable = rsp->mac_enable;\n\tncmf = &nc->mac_filter;\n\tspin_lock_irqsave(&nc->lock, flags);\n\tbitmap = &ncmf->bitmap;\n\tfor (i = 0; i < rsp->mac_cnt; i++, pdata += 6) {\n\t\tif (!(enable & (0x1 << i)))\n\t\t\tclear_bit(i, bitmap);\n\t\telse\n\t\t\tset_bit(i, bitmap);\n\n\t\tmemcpy(&ncmf->addrs[i * ETH_ALEN], pdata, ETH_ALEN);\n\t}\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\t \n\tenable = ntohs(rsp->vlan_enable);\n\tncvf = &nc->vlan_filter;\n\tbitmap = &ncvf->bitmap;\n\tspin_lock_irqsave(&nc->lock, flags);\n\tfor (i = 0; i < rsp->vlan_cnt; i++, pdata += 2) {\n\t\tif (!(enable & (0x1 << i)))\n\t\t\tclear_bit(i, bitmap);\n\t\telse\n\t\t\tset_bit(i, bitmap);\n\n\t\tncvf->vids[i] = ntohs(*(__be16 *)pdata);\n\t}\n\tspin_unlock_irqrestore(&nc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_gcps(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_gcps_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_stats *ncs;\n\n\t \n\trsp = (struct ncsi_rsp_gcps_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncs = &nc->stats;\n\tncs->hnc_cnt_hi         = ntohl(rsp->cnt_hi);\n\tncs->hnc_cnt_lo         = ntohl(rsp->cnt_lo);\n\tncs->hnc_rx_bytes       = ntohl(rsp->rx_bytes);\n\tncs->hnc_tx_bytes       = ntohl(rsp->tx_bytes);\n\tncs->hnc_rx_uc_pkts     = ntohl(rsp->rx_uc_pkts);\n\tncs->hnc_rx_mc_pkts     = ntohl(rsp->rx_mc_pkts);\n\tncs->hnc_rx_bc_pkts     = ntohl(rsp->rx_bc_pkts);\n\tncs->hnc_tx_uc_pkts     = ntohl(rsp->tx_uc_pkts);\n\tncs->hnc_tx_mc_pkts     = ntohl(rsp->tx_mc_pkts);\n\tncs->hnc_tx_bc_pkts     = ntohl(rsp->tx_bc_pkts);\n\tncs->hnc_fcs_err        = ntohl(rsp->fcs_err);\n\tncs->hnc_align_err      = ntohl(rsp->align_err);\n\tncs->hnc_false_carrier  = ntohl(rsp->false_carrier);\n\tncs->hnc_runt_pkts      = ntohl(rsp->runt_pkts);\n\tncs->hnc_jabber_pkts    = ntohl(rsp->jabber_pkts);\n\tncs->hnc_rx_pause_xon   = ntohl(rsp->rx_pause_xon);\n\tncs->hnc_rx_pause_xoff  = ntohl(rsp->rx_pause_xoff);\n\tncs->hnc_tx_pause_xon   = ntohl(rsp->tx_pause_xon);\n\tncs->hnc_tx_pause_xoff  = ntohl(rsp->tx_pause_xoff);\n\tncs->hnc_tx_s_collision = ntohl(rsp->tx_s_collision);\n\tncs->hnc_tx_m_collision = ntohl(rsp->tx_m_collision);\n\tncs->hnc_l_collision    = ntohl(rsp->l_collision);\n\tncs->hnc_e_collision    = ntohl(rsp->e_collision);\n\tncs->hnc_rx_ctl_frames  = ntohl(rsp->rx_ctl_frames);\n\tncs->hnc_rx_64_frames   = ntohl(rsp->rx_64_frames);\n\tncs->hnc_rx_127_frames  = ntohl(rsp->rx_127_frames);\n\tncs->hnc_rx_255_frames  = ntohl(rsp->rx_255_frames);\n\tncs->hnc_rx_511_frames  = ntohl(rsp->rx_511_frames);\n\tncs->hnc_rx_1023_frames = ntohl(rsp->rx_1023_frames);\n\tncs->hnc_rx_1522_frames = ntohl(rsp->rx_1522_frames);\n\tncs->hnc_rx_9022_frames = ntohl(rsp->rx_9022_frames);\n\tncs->hnc_tx_64_frames   = ntohl(rsp->tx_64_frames);\n\tncs->hnc_tx_127_frames  = ntohl(rsp->tx_127_frames);\n\tncs->hnc_tx_255_frames  = ntohl(rsp->tx_255_frames);\n\tncs->hnc_tx_511_frames  = ntohl(rsp->tx_511_frames);\n\tncs->hnc_tx_1023_frames = ntohl(rsp->tx_1023_frames);\n\tncs->hnc_tx_1522_frames = ntohl(rsp->tx_1522_frames);\n\tncs->hnc_tx_9022_frames = ntohl(rsp->tx_9022_frames);\n\tncs->hnc_rx_valid_bytes = ntohl(rsp->rx_valid_bytes);\n\tncs->hnc_rx_runt_pkts   = ntohl(rsp->rx_runt_pkts);\n\tncs->hnc_rx_jabber_pkts = ntohl(rsp->rx_jabber_pkts);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_gns(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_gns_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_stats *ncs;\n\n\t \n\trsp = (struct ncsi_rsp_gns_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncs = &nc->stats;\n\tncs->ncsi_rx_cmds       = ntohl(rsp->rx_cmds);\n\tncs->ncsi_dropped_cmds  = ntohl(rsp->dropped_cmds);\n\tncs->ncsi_cmd_type_errs = ntohl(rsp->cmd_type_errs);\n\tncs->ncsi_cmd_csum_errs = ntohl(rsp->cmd_csum_errs);\n\tncs->ncsi_rx_pkts       = ntohl(rsp->rx_pkts);\n\tncs->ncsi_tx_pkts       = ntohl(rsp->tx_pkts);\n\tncs->ncsi_tx_aen_pkts   = ntohl(rsp->tx_aen_pkts);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_gnpts(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_gnpts_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_channel *nc;\n\tstruct ncsi_channel_stats *ncs;\n\n\t \n\trsp = (struct ncsi_rsp_gnpts_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      NULL, &nc);\n\tif (!nc)\n\t\treturn -ENODEV;\n\n\t \n\tncs = &nc->stats;\n\tncs->pt_tx_pkts        = ntohl(rsp->tx_pkts);\n\tncs->pt_tx_dropped     = ntohl(rsp->tx_dropped);\n\tncs->pt_tx_channel_err = ntohl(rsp->tx_channel_err);\n\tncs->pt_tx_us_err      = ntohl(rsp->tx_us_err);\n\tncs->pt_rx_pkts        = ntohl(rsp->rx_pkts);\n\tncs->pt_rx_dropped     = ntohl(rsp->rx_dropped);\n\tncs->pt_rx_channel_err = ntohl(rsp->rx_channel_err);\n\tncs->pt_rx_us_err      = ntohl(rsp->rx_us_err);\n\tncs->pt_rx_os_err      = ntohl(rsp->rx_os_err);\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_gps(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_gps_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_package *np;\n\n\t \n\trsp = (struct ncsi_rsp_gps_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      &np, NULL);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_gpuuid(struct ncsi_request *nr)\n{\n\tstruct ncsi_rsp_gpuuid_pkt *rsp;\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_package *np;\n\n\t \n\trsp = (struct ncsi_rsp_gpuuid_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      &np, NULL);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tmemcpy(np->uuid, rsp->uuid, sizeof(rsp->uuid));\n\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_pldm(struct ncsi_request *nr)\n{\n\treturn 0;\n}\n\nstatic int ncsi_rsp_handler_netlink(struct ncsi_request *nr)\n{\n\tstruct ncsi_dev_priv *ndp = nr->ndp;\n\tstruct ncsi_rsp_pkt *rsp;\n\tstruct ncsi_package *np;\n\tstruct ncsi_channel *nc;\n\tint ret;\n\n\t \n\trsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);\n\tncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,\n\t\t\t\t      &np, &nc);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tret = ncsi_send_netlink_rsp(nr, np, nc);\n\n\treturn ret;\n}\n\nstatic struct ncsi_rsp_handler {\n\tunsigned char\ttype;\n\tint             payload;\n\tint\t\t(*handler)(struct ncsi_request *nr);\n} ncsi_rsp_handlers[] = {\n\t{ NCSI_PKT_RSP_CIS,     4, ncsi_rsp_handler_cis     },\n\t{ NCSI_PKT_RSP_SP,      4, ncsi_rsp_handler_sp      },\n\t{ NCSI_PKT_RSP_DP,      4, ncsi_rsp_handler_dp      },\n\t{ NCSI_PKT_RSP_EC,      4, ncsi_rsp_handler_ec      },\n\t{ NCSI_PKT_RSP_DC,      4, ncsi_rsp_handler_dc      },\n\t{ NCSI_PKT_RSP_RC,      4, ncsi_rsp_handler_rc      },\n\t{ NCSI_PKT_RSP_ECNT,    4, ncsi_rsp_handler_ecnt    },\n\t{ NCSI_PKT_RSP_DCNT,    4, ncsi_rsp_handler_dcnt    },\n\t{ NCSI_PKT_RSP_AE,      4, ncsi_rsp_handler_ae      },\n\t{ NCSI_PKT_RSP_SL,      4, ncsi_rsp_handler_sl      },\n\t{ NCSI_PKT_RSP_GLS,    16, ncsi_rsp_handler_gls     },\n\t{ NCSI_PKT_RSP_SVF,     4, ncsi_rsp_handler_svf     },\n\t{ NCSI_PKT_RSP_EV,      4, ncsi_rsp_handler_ev      },\n\t{ NCSI_PKT_RSP_DV,      4, ncsi_rsp_handler_dv      },\n\t{ NCSI_PKT_RSP_SMA,     4, ncsi_rsp_handler_sma     },\n\t{ NCSI_PKT_RSP_EBF,     4, ncsi_rsp_handler_ebf     },\n\t{ NCSI_PKT_RSP_DBF,     4, ncsi_rsp_handler_dbf     },\n\t{ NCSI_PKT_RSP_EGMF,    4, ncsi_rsp_handler_egmf    },\n\t{ NCSI_PKT_RSP_DGMF,    4, ncsi_rsp_handler_dgmf    },\n\t{ NCSI_PKT_RSP_SNFC,    4, ncsi_rsp_handler_snfc    },\n\t{ NCSI_PKT_RSP_GVI,    40, ncsi_rsp_handler_gvi     },\n\t{ NCSI_PKT_RSP_GC,     32, ncsi_rsp_handler_gc      },\n\t{ NCSI_PKT_RSP_GP,     -1, ncsi_rsp_handler_gp      },\n\t{ NCSI_PKT_RSP_GCPS,  204, ncsi_rsp_handler_gcps    },\n\t{ NCSI_PKT_RSP_GNS,    32, ncsi_rsp_handler_gns     },\n\t{ NCSI_PKT_RSP_GNPTS,  48, ncsi_rsp_handler_gnpts   },\n\t{ NCSI_PKT_RSP_GPS,     8, ncsi_rsp_handler_gps     },\n\t{ NCSI_PKT_RSP_OEM,    -1, ncsi_rsp_handler_oem     },\n\t{ NCSI_PKT_RSP_PLDM,   -1, ncsi_rsp_handler_pldm    },\n\t{ NCSI_PKT_RSP_GPUUID, 20, ncsi_rsp_handler_gpuuid  },\n\t{ NCSI_PKT_RSP_QPNPR,  -1, ncsi_rsp_handler_pldm    },\n\t{ NCSI_PKT_RSP_SNPR,   -1, ncsi_rsp_handler_pldm    }\n};\n\nint ncsi_rcv_rsp(struct sk_buff *skb, struct net_device *dev,\n\t\t struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct ncsi_rsp_handler *nrh = NULL;\n\tstruct ncsi_dev *nd;\n\tstruct ncsi_dev_priv *ndp;\n\tstruct ncsi_request *nr;\n\tstruct ncsi_pkt_hdr *hdr;\n\tunsigned long flags;\n\tint payload, i, ret;\n\n\t \n\tnd = ncsi_find_dev(orig_dev);\n\tndp = nd ? TO_NCSI_DEV_PRIV(nd) : NULL;\n\tif (!ndp)\n\t\treturn -ENODEV;\n\n\t \n\thdr = (struct ncsi_pkt_hdr *)skb_network_header(skb);\n\tif (hdr->type == NCSI_PKT_AEN)\n\t\treturn ncsi_aen_handler(ndp, skb);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ncsi_rsp_handlers); i++) {\n\t\tif (ncsi_rsp_handlers[i].type == hdr->type) {\n\t\t\tif (ncsi_rsp_handlers[i].handler)\n\t\t\t\tnrh = &ncsi_rsp_handlers[i];\n\t\t\telse\n\t\t\t\tnrh = NULL;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nrh) {\n\t\tnetdev_err(nd->dev, \"Received unrecognized packet (0x%x)\\n\",\n\t\t\t   hdr->type);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tspin_lock_irqsave(&ndp->lock, flags);\n\tnr = &ndp->requests[hdr->id];\n\tif (!nr->used) {\n\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tnr->rsp = skb;\n\tif (!nr->enabled) {\n\t\tspin_unlock_irqrestore(&ndp->lock, flags);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t \n\tspin_unlock_irqrestore(&ndp->lock, flags);\n\tpayload = nrh->payload;\n\tif (payload < 0)\n\t\tpayload = ntohs(hdr->length);\n\tret = ncsi_validate_rsp_pkt(nr, payload);\n\tif (ret) {\n\t\tnetdev_warn(ndp->ndev.dev,\n\t\t\t    \"NCSI: 'bad' packet ignored for type 0x%x\\n\",\n\t\t\t    hdr->type);\n\n\t\tif (nr->flags == NCSI_REQ_FLAG_NETLINK_DRIVEN) {\n\t\t\tif (ret == -EPERM)\n\t\t\t\tgoto out_netlink;\n\t\t\telse\n\t\t\t\tncsi_send_netlink_err(ndp->ndev.dev,\n\t\t\t\t\t\t      nr->snd_seq,\n\t\t\t\t\t\t      nr->snd_portid,\n\t\t\t\t\t\t      &nr->nlhdr,\n\t\t\t\t\t\t      ret);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tret = nrh->handler(nr);\n\tif (ret)\n\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t   \"NCSI: Handler for packet type 0x%x returned %d\\n\",\n\t\t\t   hdr->type, ret);\n\nout_netlink:\n\tif (nr->flags == NCSI_REQ_FLAG_NETLINK_DRIVEN) {\n\t\tret = ncsi_rsp_handler_netlink(nr);\n\t\tif (ret) {\n\t\t\tnetdev_err(ndp->ndev.dev,\n\t\t\t\t   \"NCSI: Netlink handler for packet type 0x%x returned %d\\n\",\n\t\t\t\t   hdr->type, ret);\n\t\t}\n\t}\n\nout:\n\tncsi_free_request(nr);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}