{
  "module_name": "virtio_transport_common.c",
  "hash_id": "860d7caea3a0dd4e2f7b26f39ac397716c82df00d43127b9ffb26366e7a3fe45",
  "original_prompt": "Ingested from linux-6.6.14/net/vmw_vsock/virtio_transport_common.c",
  "human_readable_source": "\n \n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/ctype.h>\n#include <linux/list.h>\n#include <linux/virtio_vsock.h>\n#include <uapi/linux/vsockmon.h>\n\n#include <net/sock.h>\n#include <net/af_vsock.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/vsock_virtio_transport_common.h>\n\n \n#define VSOCK_CLOSE_TIMEOUT (8 * HZ)\n\n \n#define GOOD_COPY_LEN  128\n\nstatic const struct virtio_transport *\nvirtio_transport_get_ops(struct vsock_sock *vsk)\n{\n\tconst struct vsock_transport *t = vsock_core_get_transport(vsk);\n\n\tif (WARN_ON(!t))\n\t\treturn NULL;\n\n\treturn container_of(t, struct virtio_transport, transport);\n}\n\n \nstatic struct sk_buff *\nvirtio_transport_alloc_skb(struct virtio_vsock_pkt_info *info,\n\t\t\t   size_t len,\n\t\t\t   u32 src_cid,\n\t\t\t   u32 src_port,\n\t\t\t   u32 dst_cid,\n\t\t\t   u32 dst_port)\n{\n\tconst size_t skb_len = VIRTIO_VSOCK_SKB_HEADROOM + len;\n\tstruct virtio_vsock_hdr *hdr;\n\tstruct sk_buff *skb;\n\tvoid *payload;\n\tint err;\n\n\tskb = virtio_vsock_alloc_skb(skb_len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = virtio_vsock_hdr(skb);\n\thdr->type\t= cpu_to_le16(info->type);\n\thdr->op\t\t= cpu_to_le16(info->op);\n\thdr->src_cid\t= cpu_to_le64(src_cid);\n\thdr->dst_cid\t= cpu_to_le64(dst_cid);\n\thdr->src_port\t= cpu_to_le32(src_port);\n\thdr->dst_port\t= cpu_to_le32(dst_port);\n\thdr->flags\t= cpu_to_le32(info->flags);\n\thdr->len\t= cpu_to_le32(len);\n\thdr->buf_alloc\t= cpu_to_le32(0);\n\thdr->fwd_cnt\t= cpu_to_le32(0);\n\n\tif (info->msg && len > 0) {\n\t\tpayload = skb_put(skb, len);\n\t\terr = memcpy_from_msg(payload, info->msg, len);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (msg_data_left(info->msg) == 0 &&\n\t\t    info->type == VIRTIO_VSOCK_TYPE_SEQPACKET) {\n\t\t\thdr->flags |= cpu_to_le32(VIRTIO_VSOCK_SEQ_EOM);\n\n\t\t\tif (info->msg->msg_flags & MSG_EOR)\n\t\t\t\thdr->flags |= cpu_to_le32(VIRTIO_VSOCK_SEQ_EOR);\n\t\t}\n\t}\n\n\tif (info->reply)\n\t\tvirtio_vsock_skb_set_reply(skb);\n\n\ttrace_virtio_transport_alloc_pkt(src_cid, src_port,\n\t\t\t\t\t dst_cid, dst_port,\n\t\t\t\t\t len,\n\t\t\t\t\t info->type,\n\t\t\t\t\t info->op,\n\t\t\t\t\t info->flags);\n\n\tif (info->vsk && !skb_set_owner_sk_safe(skb, sk_vsock(info->vsk))) {\n\t\tWARN_ONCE(1, \"failed to allocate skb on vsock socket with sk_refcnt == 0\\n\");\n\t\tgoto out;\n\t}\n\n\treturn skb;\n\nout:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\n \nstatic struct sk_buff *virtio_transport_build_skb(void *opaque)\n{\n\tstruct virtio_vsock_hdr *pkt_hdr;\n\tstruct sk_buff *pkt = opaque;\n\tstruct af_vsockmon_hdr *hdr;\n\tstruct sk_buff *skb;\n\tsize_t payload_len;\n\tvoid *payload_buf;\n\n\t \n\tpkt_hdr = virtio_vsock_hdr(pkt);\n\tpayload_len = pkt->len;\n\tpayload_buf = pkt->data;\n\n\tskb = alloc_skb(sizeof(*hdr) + sizeof(*pkt_hdr) + payload_len,\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\n\t \n\thdr->src_cid = pkt_hdr->src_cid;\n\thdr->src_port = pkt_hdr->src_port;\n\thdr->dst_cid = pkt_hdr->dst_cid;\n\thdr->dst_port = pkt_hdr->dst_port;\n\n\thdr->transport = cpu_to_le16(AF_VSOCK_TRANSPORT_VIRTIO);\n\thdr->len = cpu_to_le16(sizeof(*pkt_hdr));\n\tmemset(hdr->reserved, 0, sizeof(hdr->reserved));\n\n\tswitch (le16_to_cpu(pkt_hdr->op)) {\n\tcase VIRTIO_VSOCK_OP_REQUEST:\n\tcase VIRTIO_VSOCK_OP_RESPONSE:\n\t\thdr->op = cpu_to_le16(AF_VSOCK_OP_CONNECT);\n\t\tbreak;\n\tcase VIRTIO_VSOCK_OP_RST:\n\tcase VIRTIO_VSOCK_OP_SHUTDOWN:\n\t\thdr->op = cpu_to_le16(AF_VSOCK_OP_DISCONNECT);\n\t\tbreak;\n\tcase VIRTIO_VSOCK_OP_RW:\n\t\thdr->op = cpu_to_le16(AF_VSOCK_OP_PAYLOAD);\n\t\tbreak;\n\tcase VIRTIO_VSOCK_OP_CREDIT_UPDATE:\n\tcase VIRTIO_VSOCK_OP_CREDIT_REQUEST:\n\t\thdr->op = cpu_to_le16(AF_VSOCK_OP_CONTROL);\n\t\tbreak;\n\tdefault:\n\t\thdr->op = cpu_to_le16(AF_VSOCK_OP_UNKNOWN);\n\t\tbreak;\n\t}\n\n\tskb_put_data(skb, pkt_hdr, sizeof(*pkt_hdr));\n\n\tif (payload_len) {\n\t\tskb_put_data(skb, payload_buf, payload_len);\n\t}\n\n\treturn skb;\n}\n\nvoid virtio_transport_deliver_tap_pkt(struct sk_buff *skb)\n{\n\tif (virtio_vsock_skb_tap_delivered(skb))\n\t\treturn;\n\n\tvsock_deliver_tap(virtio_transport_build_skb, skb);\n\tvirtio_vsock_skb_set_tap_delivered(skb);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_deliver_tap_pkt);\n\nstatic u16 virtio_transport_get_type(struct sock *sk)\n{\n\tif (sk->sk_type == SOCK_STREAM)\n\t\treturn VIRTIO_VSOCK_TYPE_STREAM;\n\telse\n\t\treturn VIRTIO_VSOCK_TYPE_SEQPACKET;\n}\n\n \nstatic int virtio_transport_send_pkt_info(struct vsock_sock *vsk,\n\t\t\t\t\t  struct virtio_vsock_pkt_info *info)\n{\n\tu32 src_cid, src_port, dst_cid, dst_port;\n\tconst struct virtio_transport *t_ops;\n\tstruct virtio_vsock_sock *vvs;\n\tu32 pkt_len = info->pkt_len;\n\tu32 rest_len;\n\tint ret;\n\n\tinfo->type = virtio_transport_get_type(sk_vsock(vsk));\n\n\tt_ops = virtio_transport_get_ops(vsk);\n\tif (unlikely(!t_ops))\n\t\treturn -EFAULT;\n\n\tsrc_cid = t_ops->transport.get_local_cid();\n\tsrc_port = vsk->local_addr.svm_port;\n\tif (!info->remote_cid) {\n\t\tdst_cid\t= vsk->remote_addr.svm_cid;\n\t\tdst_port = vsk->remote_addr.svm_port;\n\t} else {\n\t\tdst_cid = info->remote_cid;\n\t\tdst_port = info->remote_port;\n\t}\n\n\tvvs = vsk->trans;\n\n\t \n\tpkt_len = virtio_transport_get_credit(vvs, pkt_len);\n\n\t \n\tif (pkt_len == 0 && info->op == VIRTIO_VSOCK_OP_RW)\n\t\treturn pkt_len;\n\n\trest_len = pkt_len;\n\n\tdo {\n\t\tstruct sk_buff *skb;\n\t\tsize_t skb_len;\n\n\t\tskb_len = min_t(u32, VIRTIO_VSOCK_MAX_PKT_BUF_SIZE, rest_len);\n\n\t\tskb = virtio_transport_alloc_skb(info, skb_len,\n\t\t\t\t\t\t src_cid, src_port,\n\t\t\t\t\t\t dst_cid, dst_port);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tvirtio_transport_inc_tx_pkt(vvs, skb);\n\n\t\tret = t_ops->send_pkt(skb);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\trest_len -= ret;\n\n\t\tif (WARN_ONCE(ret != skb_len,\n\t\t\t      \"'send_pkt()' returns %i, but %zu expected\\n\",\n\t\t\t      ret, skb_len))\n\t\t\tbreak;\n\t} while (rest_len);\n\n\tvirtio_transport_put_credit(vvs, rest_len);\n\n\t \n\tif (rest_len != pkt_len)\n\t\tret = pkt_len - rest_len;\n\n\treturn ret;\n}\n\nstatic bool virtio_transport_inc_rx_pkt(struct virtio_vsock_sock *vvs,\n\t\t\t\t\tu32 len)\n{\n\tif (vvs->rx_bytes + len > vvs->buf_alloc)\n\t\treturn false;\n\n\tvvs->rx_bytes += len;\n\treturn true;\n}\n\nstatic void virtio_transport_dec_rx_pkt(struct virtio_vsock_sock *vvs,\n\t\t\t\t\tu32 len)\n{\n\tvvs->rx_bytes -= len;\n\tvvs->fwd_cnt += len;\n}\n\nvoid virtio_transport_inc_tx_pkt(struct virtio_vsock_sock *vvs, struct sk_buff *skb)\n{\n\tstruct virtio_vsock_hdr *hdr = virtio_vsock_hdr(skb);\n\n\tspin_lock_bh(&vvs->rx_lock);\n\tvvs->last_fwd_cnt = vvs->fwd_cnt;\n\thdr->fwd_cnt = cpu_to_le32(vvs->fwd_cnt);\n\thdr->buf_alloc = cpu_to_le32(vvs->buf_alloc);\n\tspin_unlock_bh(&vvs->rx_lock);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_inc_tx_pkt);\n\nu32 virtio_transport_get_credit(struct virtio_vsock_sock *vvs, u32 credit)\n{\n\tu32 ret;\n\n\tif (!credit)\n\t\treturn 0;\n\n\tspin_lock_bh(&vvs->tx_lock);\n\tret = vvs->peer_buf_alloc - (vvs->tx_cnt - vvs->peer_fwd_cnt);\n\tif (ret > credit)\n\t\tret = credit;\n\tvvs->tx_cnt += ret;\n\tspin_unlock_bh(&vvs->tx_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_get_credit);\n\nvoid virtio_transport_put_credit(struct virtio_vsock_sock *vvs, u32 credit)\n{\n\tif (!credit)\n\t\treturn;\n\n\tspin_lock_bh(&vvs->tx_lock);\n\tvvs->tx_cnt -= credit;\n\tspin_unlock_bh(&vvs->tx_lock);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_put_credit);\n\nstatic int virtio_transport_send_credit_update(struct vsock_sock *vsk)\n{\n\tstruct virtio_vsock_pkt_info info = {\n\t\t.op = VIRTIO_VSOCK_OP_CREDIT_UPDATE,\n\t\t.vsk = vsk,\n\t};\n\n\treturn virtio_transport_send_pkt_info(vsk, &info);\n}\n\nstatic ssize_t\nvirtio_transport_stream_do_peek(struct vsock_sock *vsk,\n\t\t\t\tstruct msghdr *msg,\n\t\t\t\tsize_t len)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\tstruct sk_buff *skb;\n\tsize_t total = 0;\n\tint err;\n\n\tspin_lock_bh(&vvs->rx_lock);\n\n\tskb_queue_walk(&vvs->rx_queue, skb) {\n\t\tsize_t bytes;\n\n\t\tbytes = len - total;\n\t\tif (bytes > skb->len)\n\t\t\tbytes = skb->len;\n\n\t\tspin_unlock_bh(&vvs->rx_lock);\n\n\t\t \n\t\terr = memcpy_to_msg(msg, skb->data, bytes);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttotal += bytes;\n\n\t\tspin_lock_bh(&vvs->rx_lock);\n\n\t\tif (total == len)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&vvs->rx_lock);\n\n\treturn total;\n\nout:\n\tif (total)\n\t\terr = total;\n\treturn err;\n}\n\nstatic ssize_t\nvirtio_transport_stream_do_dequeue(struct vsock_sock *vsk,\n\t\t\t\t   struct msghdr *msg,\n\t\t\t\t   size_t len)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\tsize_t bytes, total = 0;\n\tstruct sk_buff *skb;\n\tu32 fwd_cnt_delta;\n\tbool low_rx_bytes;\n\tint err = -EFAULT;\n\tu32 free_space;\n\n\tspin_lock_bh(&vvs->rx_lock);\n\n\tif (WARN_ONCE(skb_queue_empty(&vvs->rx_queue) && vvs->rx_bytes,\n\t\t      \"rx_queue is empty, but rx_bytes is non-zero\\n\")) {\n\t\tspin_unlock_bh(&vvs->rx_lock);\n\t\treturn err;\n\t}\n\n\twhile (total < len && !skb_queue_empty(&vvs->rx_queue)) {\n\t\tskb = skb_peek(&vvs->rx_queue);\n\n\t\tbytes = len - total;\n\t\tif (bytes > skb->len)\n\t\t\tbytes = skb->len;\n\n\t\t \n\t\tspin_unlock_bh(&vvs->rx_lock);\n\n\t\terr = memcpy_to_msg(msg, skb->data, bytes);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tspin_lock_bh(&vvs->rx_lock);\n\n\t\ttotal += bytes;\n\t\tskb_pull(skb, bytes);\n\n\t\tif (skb->len == 0) {\n\t\t\tu32 pkt_len = le32_to_cpu(virtio_vsock_hdr(skb)->len);\n\n\t\t\tvirtio_transport_dec_rx_pkt(vvs, pkt_len);\n\t\t\t__skb_unlink(skb, &vvs->rx_queue);\n\t\t\tconsume_skb(skb);\n\t\t}\n\t}\n\n\tfwd_cnt_delta = vvs->fwd_cnt - vvs->last_fwd_cnt;\n\tfree_space = vvs->buf_alloc - fwd_cnt_delta;\n\tlow_rx_bytes = (vvs->rx_bytes <\n\t\t\tsock_rcvlowat(sk_vsock(vsk), 0, INT_MAX));\n\n\tspin_unlock_bh(&vvs->rx_lock);\n\n\t \n\tif (fwd_cnt_delta &&\n\t    (free_space < VIRTIO_VSOCK_MAX_PKT_BUF_SIZE || low_rx_bytes))\n\t\tvirtio_transport_send_credit_update(vsk);\n\n\treturn total;\n\nout:\n\tif (total)\n\t\terr = total;\n\treturn err;\n}\n\nstatic ssize_t\nvirtio_transport_seqpacket_do_peek(struct vsock_sock *vsk,\n\t\t\t\t   struct msghdr *msg)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\tstruct sk_buff *skb;\n\tsize_t total, len;\n\n\tspin_lock_bh(&vvs->rx_lock);\n\n\tif (!vvs->msg_count) {\n\t\tspin_unlock_bh(&vvs->rx_lock);\n\t\treturn 0;\n\t}\n\n\ttotal = 0;\n\tlen = msg_data_left(msg);\n\n\tskb_queue_walk(&vvs->rx_queue, skb) {\n\t\tstruct virtio_vsock_hdr *hdr;\n\n\t\tif (total < len) {\n\t\t\tsize_t bytes;\n\t\t\tint err;\n\n\t\t\tbytes = len - total;\n\t\t\tif (bytes > skb->len)\n\t\t\t\tbytes = skb->len;\n\n\t\t\tspin_unlock_bh(&vvs->rx_lock);\n\n\t\t\t \n\t\t\terr = memcpy_to_msg(msg, skb->data, bytes);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tspin_lock_bh(&vvs->rx_lock);\n\t\t}\n\n\t\ttotal += skb->len;\n\t\thdr = virtio_vsock_hdr(skb);\n\n\t\tif (le32_to_cpu(hdr->flags) & VIRTIO_VSOCK_SEQ_EOM) {\n\t\t\tif (le32_to_cpu(hdr->flags) & VIRTIO_VSOCK_SEQ_EOR)\n\t\t\t\tmsg->msg_flags |= MSG_EOR;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&vvs->rx_lock);\n\n\treturn total;\n}\n\nstatic int virtio_transport_seqpacket_do_dequeue(struct vsock_sock *vsk,\n\t\t\t\t\t\t struct msghdr *msg,\n\t\t\t\t\t\t int flags)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\tint dequeued_len = 0;\n\tsize_t user_buf_len = msg_data_left(msg);\n\tbool msg_ready = false;\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&vvs->rx_lock);\n\n\tif (vvs->msg_count == 0) {\n\t\tspin_unlock_bh(&vvs->rx_lock);\n\t\treturn 0;\n\t}\n\n\twhile (!msg_ready) {\n\t\tstruct virtio_vsock_hdr *hdr;\n\t\tsize_t pkt_len;\n\n\t\tskb = __skb_dequeue(&vvs->rx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\thdr = virtio_vsock_hdr(skb);\n\t\tpkt_len = (size_t)le32_to_cpu(hdr->len);\n\n\t\tif (dequeued_len >= 0) {\n\t\t\tsize_t bytes_to_copy;\n\n\t\t\tbytes_to_copy = min(user_buf_len, pkt_len);\n\n\t\t\tif (bytes_to_copy) {\n\t\t\t\tint err;\n\n\t\t\t\t \n\t\t\t\tspin_unlock_bh(&vvs->rx_lock);\n\n\t\t\t\terr = memcpy_to_msg(msg, skb->data, bytes_to_copy);\n\t\t\t\tif (err) {\n\t\t\t\t\t \n\t\t\t\t\tdequeued_len = err;\n\t\t\t\t} else {\n\t\t\t\t\tuser_buf_len -= bytes_to_copy;\n\t\t\t\t}\n\n\t\t\t\tspin_lock_bh(&vvs->rx_lock);\n\t\t\t}\n\n\t\t\tif (dequeued_len >= 0)\n\t\t\t\tdequeued_len += pkt_len;\n\t\t}\n\n\t\tif (le32_to_cpu(hdr->flags) & VIRTIO_VSOCK_SEQ_EOM) {\n\t\t\tmsg_ready = true;\n\t\t\tvvs->msg_count--;\n\n\t\t\tif (le32_to_cpu(hdr->flags) & VIRTIO_VSOCK_SEQ_EOR)\n\t\t\t\tmsg->msg_flags |= MSG_EOR;\n\t\t}\n\n\t\tvirtio_transport_dec_rx_pkt(vvs, pkt_len);\n\t\tkfree_skb(skb);\n\t}\n\n\tspin_unlock_bh(&vvs->rx_lock);\n\n\tvirtio_transport_send_credit_update(vsk);\n\n\treturn dequeued_len;\n}\n\nssize_t\nvirtio_transport_stream_dequeue(struct vsock_sock *vsk,\n\t\t\t\tstruct msghdr *msg,\n\t\t\t\tsize_t len, int flags)\n{\n\tif (flags & MSG_PEEK)\n\t\treturn virtio_transport_stream_do_peek(vsk, msg, len);\n\telse\n\t\treturn virtio_transport_stream_do_dequeue(vsk, msg, len);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_stream_dequeue);\n\nssize_t\nvirtio_transport_seqpacket_dequeue(struct vsock_sock *vsk,\n\t\t\t\t   struct msghdr *msg,\n\t\t\t\t   int flags)\n{\n\tif (flags & MSG_PEEK)\n\t\treturn virtio_transport_seqpacket_do_peek(vsk, msg);\n\telse\n\t\treturn virtio_transport_seqpacket_do_dequeue(vsk, msg, flags);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_seqpacket_dequeue);\n\nint\nvirtio_transport_seqpacket_enqueue(struct vsock_sock *vsk,\n\t\t\t\t   struct msghdr *msg,\n\t\t\t\t   size_t len)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\n\tspin_lock_bh(&vvs->tx_lock);\n\n\tif (len > vvs->peer_buf_alloc) {\n\t\tspin_unlock_bh(&vvs->tx_lock);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tspin_unlock_bh(&vvs->tx_lock);\n\n\treturn virtio_transport_stream_enqueue(vsk, msg, len);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_seqpacket_enqueue);\n\nint\nvirtio_transport_dgram_dequeue(struct vsock_sock *vsk,\n\t\t\t       struct msghdr *msg,\n\t\t\t       size_t len, int flags)\n{\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_dgram_dequeue);\n\ns64 virtio_transport_stream_has_data(struct vsock_sock *vsk)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\ts64 bytes;\n\n\tspin_lock_bh(&vvs->rx_lock);\n\tbytes = vvs->rx_bytes;\n\tspin_unlock_bh(&vvs->rx_lock);\n\n\treturn bytes;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_stream_has_data);\n\nu32 virtio_transport_seqpacket_has_data(struct vsock_sock *vsk)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\tu32 msg_count;\n\n\tspin_lock_bh(&vvs->rx_lock);\n\tmsg_count = vvs->msg_count;\n\tspin_unlock_bh(&vvs->rx_lock);\n\n\treturn msg_count;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_seqpacket_has_data);\n\nstatic s64 virtio_transport_has_space(struct vsock_sock *vsk)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\ts64 bytes;\n\n\tbytes = (s64)vvs->peer_buf_alloc - (vvs->tx_cnt - vvs->peer_fwd_cnt);\n\tif (bytes < 0)\n\t\tbytes = 0;\n\n\treturn bytes;\n}\n\ns64 virtio_transport_stream_has_space(struct vsock_sock *vsk)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\ts64 bytes;\n\n\tspin_lock_bh(&vvs->tx_lock);\n\tbytes = virtio_transport_has_space(vsk);\n\tspin_unlock_bh(&vvs->tx_lock);\n\n\treturn bytes;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_stream_has_space);\n\nint virtio_transport_do_socket_init(struct vsock_sock *vsk,\n\t\t\t\t    struct vsock_sock *psk)\n{\n\tstruct virtio_vsock_sock *vvs;\n\n\tvvs = kzalloc(sizeof(*vvs), GFP_KERNEL);\n\tif (!vvs)\n\t\treturn -ENOMEM;\n\n\tvsk->trans = vvs;\n\tvvs->vsk = vsk;\n\tif (psk && psk->trans) {\n\t\tstruct virtio_vsock_sock *ptrans = psk->trans;\n\n\t\tvvs->peer_buf_alloc = ptrans->peer_buf_alloc;\n\t}\n\n\tif (vsk->buffer_size > VIRTIO_VSOCK_MAX_BUF_SIZE)\n\t\tvsk->buffer_size = VIRTIO_VSOCK_MAX_BUF_SIZE;\n\n\tvvs->buf_alloc = vsk->buffer_size;\n\n\tspin_lock_init(&vvs->rx_lock);\n\tspin_lock_init(&vvs->tx_lock);\n\tskb_queue_head_init(&vvs->rx_queue);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_do_socket_init);\n\n \nvoid virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\n\tif (*val > VIRTIO_VSOCK_MAX_BUF_SIZE)\n\t\t*val = VIRTIO_VSOCK_MAX_BUF_SIZE;\n\n\tvvs->buf_alloc = *val;\n\n\tvirtio_transport_send_credit_update(vsk);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_buffer_size);\n\nint\nvirtio_transport_notify_poll_in(struct vsock_sock *vsk,\n\t\t\t\tsize_t target,\n\t\t\t\tbool *data_ready_now)\n{\n\t*data_ready_now = vsock_stream_has_data(vsk) >= target;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_poll_in);\n\nint\nvirtio_transport_notify_poll_out(struct vsock_sock *vsk,\n\t\t\t\t size_t target,\n\t\t\t\t bool *space_avail_now)\n{\n\ts64 free_space;\n\n\tfree_space = vsock_stream_has_space(vsk);\n\tif (free_space > 0)\n\t\t*space_avail_now = true;\n\telse if (free_space == 0)\n\t\t*space_avail_now = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_poll_out);\n\nint virtio_transport_notify_recv_init(struct vsock_sock *vsk,\n\tsize_t target, struct vsock_transport_recv_notify_data *data)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_recv_init);\n\nint virtio_transport_notify_recv_pre_block(struct vsock_sock *vsk,\n\tsize_t target, struct vsock_transport_recv_notify_data *data)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_recv_pre_block);\n\nint virtio_transport_notify_recv_pre_dequeue(struct vsock_sock *vsk,\n\tsize_t target, struct vsock_transport_recv_notify_data *data)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_recv_pre_dequeue);\n\nint virtio_transport_notify_recv_post_dequeue(struct vsock_sock *vsk,\n\tsize_t target, ssize_t copied, bool data_read,\n\tstruct vsock_transport_recv_notify_data *data)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_recv_post_dequeue);\n\nint virtio_transport_notify_send_init(struct vsock_sock *vsk,\n\tstruct vsock_transport_send_notify_data *data)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_send_init);\n\nint virtio_transport_notify_send_pre_block(struct vsock_sock *vsk,\n\tstruct vsock_transport_send_notify_data *data)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_send_pre_block);\n\nint virtio_transport_notify_send_pre_enqueue(struct vsock_sock *vsk,\n\tstruct vsock_transport_send_notify_data *data)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_send_pre_enqueue);\n\nint virtio_transport_notify_send_post_enqueue(struct vsock_sock *vsk,\n\tssize_t written, struct vsock_transport_send_notify_data *data)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_send_post_enqueue);\n\nu64 virtio_transport_stream_rcvhiwat(struct vsock_sock *vsk)\n{\n\treturn vsk->buffer_size;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_stream_rcvhiwat);\n\nbool virtio_transport_stream_is_active(struct vsock_sock *vsk)\n{\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_stream_is_active);\n\nbool virtio_transport_stream_allow(u32 cid, u32 port)\n{\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_stream_allow);\n\nint virtio_transport_dgram_bind(struct vsock_sock *vsk,\n\t\t\t\tstruct sockaddr_vm *addr)\n{\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_dgram_bind);\n\nbool virtio_transport_dgram_allow(u32 cid, u32 port)\n{\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_dgram_allow);\n\nint virtio_transport_connect(struct vsock_sock *vsk)\n{\n\tstruct virtio_vsock_pkt_info info = {\n\t\t.op = VIRTIO_VSOCK_OP_REQUEST,\n\t\t.vsk = vsk,\n\t};\n\n\treturn virtio_transport_send_pkt_info(vsk, &info);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_connect);\n\nint virtio_transport_shutdown(struct vsock_sock *vsk, int mode)\n{\n\tstruct virtio_vsock_pkt_info info = {\n\t\t.op = VIRTIO_VSOCK_OP_SHUTDOWN,\n\t\t.flags = (mode & RCV_SHUTDOWN ?\n\t\t\t  VIRTIO_VSOCK_SHUTDOWN_RCV : 0) |\n\t\t\t (mode & SEND_SHUTDOWN ?\n\t\t\t  VIRTIO_VSOCK_SHUTDOWN_SEND : 0),\n\t\t.vsk = vsk,\n\t};\n\n\treturn virtio_transport_send_pkt_info(vsk, &info);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_shutdown);\n\nint\nvirtio_transport_dgram_enqueue(struct vsock_sock *vsk,\n\t\t\t       struct sockaddr_vm *remote_addr,\n\t\t\t       struct msghdr *msg,\n\t\t\t       size_t dgram_len)\n{\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_dgram_enqueue);\n\nssize_t\nvirtio_transport_stream_enqueue(struct vsock_sock *vsk,\n\t\t\t\tstruct msghdr *msg,\n\t\t\t\tsize_t len)\n{\n\tstruct virtio_vsock_pkt_info info = {\n\t\t.op = VIRTIO_VSOCK_OP_RW,\n\t\t.msg = msg,\n\t\t.pkt_len = len,\n\t\t.vsk = vsk,\n\t};\n\n\treturn virtio_transport_send_pkt_info(vsk, &info);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_stream_enqueue);\n\nvoid virtio_transport_destruct(struct vsock_sock *vsk)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\n\tkfree(vvs);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_destruct);\n\nstatic int virtio_transport_reset(struct vsock_sock *vsk,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct virtio_vsock_pkt_info info = {\n\t\t.op = VIRTIO_VSOCK_OP_RST,\n\t\t.reply = !!skb,\n\t\t.vsk = vsk,\n\t};\n\n\t \n\tif (skb && le16_to_cpu(virtio_vsock_hdr(skb)->op) == VIRTIO_VSOCK_OP_RST)\n\t\treturn 0;\n\n\treturn virtio_transport_send_pkt_info(vsk, &info);\n}\n\n \nstatic int virtio_transport_reset_no_sock(const struct virtio_transport *t,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct virtio_vsock_hdr *hdr = virtio_vsock_hdr(skb);\n\tstruct virtio_vsock_pkt_info info = {\n\t\t.op = VIRTIO_VSOCK_OP_RST,\n\t\t.type = le16_to_cpu(hdr->type),\n\t\t.reply = true,\n\t};\n\tstruct sk_buff *reply;\n\n\t \n\tif (le16_to_cpu(hdr->op) == VIRTIO_VSOCK_OP_RST)\n\t\treturn 0;\n\n\tif (!t)\n\t\treturn -ENOTCONN;\n\n\treply = virtio_transport_alloc_skb(&info, 0,\n\t\t\t\t\t   le64_to_cpu(hdr->dst_cid),\n\t\t\t\t\t   le32_to_cpu(hdr->dst_port),\n\t\t\t\t\t   le64_to_cpu(hdr->src_cid),\n\t\t\t\t\t   le32_to_cpu(hdr->src_port));\n\tif (!reply)\n\t\treturn -ENOMEM;\n\n\treturn t->send_pkt(reply);\n}\n\n \nstatic void virtio_transport_remove_sock(struct vsock_sock *vsk)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\n\t \n\t__skb_queue_purge(&vvs->rx_queue);\n\tvsock_remove_sock(vsk);\n}\n\nstatic void virtio_transport_wait_close(struct sock *sk, long timeout)\n{\n\tif (timeout) {\n\t\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\t\tadd_wait_queue(sk_sleep(sk), &wait);\n\n\t\tdo {\n\t\t\tif (sk_wait_event(sk, &timeout,\n\t\t\t\t\t  sock_flag(sk, SOCK_DONE), &wait))\n\t\t\t\tbreak;\n\t\t} while (!signal_pending(current) && timeout);\n\n\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\t}\n}\n\nstatic void virtio_transport_do_close(struct vsock_sock *vsk,\n\t\t\t\t      bool cancel_timeout)\n{\n\tstruct sock *sk = sk_vsock(vsk);\n\n\tsock_set_flag(sk, SOCK_DONE);\n\tvsk->peer_shutdown = SHUTDOWN_MASK;\n\tif (vsock_stream_has_data(vsk) <= 0)\n\t\tsk->sk_state = TCP_CLOSING;\n\tsk->sk_state_change(sk);\n\n\tif (vsk->close_work_scheduled &&\n\t    (!cancel_timeout || cancel_delayed_work(&vsk->close_work))) {\n\t\tvsk->close_work_scheduled = false;\n\n\t\tvirtio_transport_remove_sock(vsk);\n\n\t\t \n\t\tsock_put(sk);\n\t}\n}\n\nstatic void virtio_transport_close_timeout(struct work_struct *work)\n{\n\tstruct vsock_sock *vsk =\n\t\tcontainer_of(work, struct vsock_sock, close_work.work);\n\tstruct sock *sk = sk_vsock(vsk);\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\n\tif (!sock_flag(sk, SOCK_DONE)) {\n\t\t(void)virtio_transport_reset(vsk, NULL);\n\n\t\tvirtio_transport_do_close(vsk, false);\n\t}\n\n\tvsk->close_work_scheduled = false;\n\n\trelease_sock(sk);\n\tsock_put(sk);\n}\n\n \nstatic bool virtio_transport_close(struct vsock_sock *vsk)\n{\n\tstruct sock *sk = &vsk->sk;\n\n\tif (!(sk->sk_state == TCP_ESTABLISHED ||\n\t      sk->sk_state == TCP_CLOSING))\n\t\treturn true;\n\n\t \n\tif ((vsk->peer_shutdown & SHUTDOWN_MASK) == SHUTDOWN_MASK) {\n\t\t(void)virtio_transport_reset(vsk, NULL);\n\t\treturn true;\n\t}\n\n\tif ((sk->sk_shutdown & SHUTDOWN_MASK) != SHUTDOWN_MASK)\n\t\t(void)virtio_transport_shutdown(vsk, SHUTDOWN_MASK);\n\n\tif (sock_flag(sk, SOCK_LINGER) && !(current->flags & PF_EXITING))\n\t\tvirtio_transport_wait_close(sk, sk->sk_lingertime);\n\n\tif (sock_flag(sk, SOCK_DONE)) {\n\t\treturn true;\n\t}\n\n\tsock_hold(sk);\n\tINIT_DELAYED_WORK(&vsk->close_work,\n\t\t\t  virtio_transport_close_timeout);\n\tvsk->close_work_scheduled = true;\n\tschedule_delayed_work(&vsk->close_work, VSOCK_CLOSE_TIMEOUT);\n\treturn false;\n}\n\nvoid virtio_transport_release(struct vsock_sock *vsk)\n{\n\tstruct sock *sk = &vsk->sk;\n\tbool remove_sock = true;\n\n\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET)\n\t\tremove_sock = virtio_transport_close(vsk);\n\n\tif (remove_sock) {\n\t\tsock_set_flag(sk, SOCK_DONE);\n\t\tvirtio_transport_remove_sock(vsk);\n\t}\n}\nEXPORT_SYMBOL_GPL(virtio_transport_release);\n\nstatic int\nvirtio_transport_recv_connecting(struct sock *sk,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct virtio_vsock_hdr *hdr = virtio_vsock_hdr(skb);\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\tint skerr;\n\tint err;\n\n\tswitch (le16_to_cpu(hdr->op)) {\n\tcase VIRTIO_VSOCK_OP_RESPONSE:\n\t\tsk->sk_state = TCP_ESTABLISHED;\n\t\tsk->sk_socket->state = SS_CONNECTED;\n\t\tvsock_insert_connected(vsk);\n\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\tcase VIRTIO_VSOCK_OP_INVALID:\n\t\tbreak;\n\tcase VIRTIO_VSOCK_OP_RST:\n\t\tskerr = ECONNRESET;\n\t\terr = 0;\n\t\tgoto destroy;\n\tdefault:\n\t\tskerr = EPROTO;\n\t\terr = -EINVAL;\n\t\tgoto destroy;\n\t}\n\treturn 0;\n\ndestroy:\n\tvirtio_transport_reset(vsk, skb);\n\tsk->sk_state = TCP_CLOSE;\n\tsk->sk_err = skerr;\n\tsk_error_report(sk);\n\treturn err;\n}\n\nstatic void\nvirtio_transport_recv_enqueue(struct vsock_sock *vsk,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\tbool can_enqueue, free_pkt = false;\n\tstruct virtio_vsock_hdr *hdr;\n\tu32 len;\n\n\thdr = virtio_vsock_hdr(skb);\n\tlen = le32_to_cpu(hdr->len);\n\n\tspin_lock_bh(&vvs->rx_lock);\n\n\tcan_enqueue = virtio_transport_inc_rx_pkt(vvs, len);\n\tif (!can_enqueue) {\n\t\tfree_pkt = true;\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(hdr->flags) & VIRTIO_VSOCK_SEQ_EOM)\n\t\tvvs->msg_count++;\n\n\t \n\tif (len <= GOOD_COPY_LEN && !skb_queue_empty(&vvs->rx_queue)) {\n\t\tstruct virtio_vsock_hdr *last_hdr;\n\t\tstruct sk_buff *last_skb;\n\n\t\tlast_skb = skb_peek_tail(&vvs->rx_queue);\n\t\tlast_hdr = virtio_vsock_hdr(last_skb);\n\n\t\t \n\t\tif (skb->len < skb_tailroom(last_skb) &&\n\t\t    !(le32_to_cpu(last_hdr->flags) & VIRTIO_VSOCK_SEQ_EOM)) {\n\t\t\tmemcpy(skb_put(last_skb, skb->len), skb->data, skb->len);\n\t\t\tfree_pkt = true;\n\t\t\tlast_hdr->flags |= hdr->flags;\n\t\t\tle32_add_cpu(&last_hdr->len, len);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t__skb_queue_tail(&vvs->rx_queue, skb);\n\nout:\n\tspin_unlock_bh(&vvs->rx_lock);\n\tif (free_pkt)\n\t\tkfree_skb(skb);\n}\n\nstatic int\nvirtio_transport_recv_connected(struct sock *sk,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct virtio_vsock_hdr *hdr = virtio_vsock_hdr(skb);\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\tint err = 0;\n\n\tswitch (le16_to_cpu(hdr->op)) {\n\tcase VIRTIO_VSOCK_OP_RW:\n\t\tvirtio_transport_recv_enqueue(vsk, skb);\n\t\tvsock_data_ready(sk);\n\t\treturn err;\n\tcase VIRTIO_VSOCK_OP_CREDIT_REQUEST:\n\t\tvirtio_transport_send_credit_update(vsk);\n\t\tbreak;\n\tcase VIRTIO_VSOCK_OP_CREDIT_UPDATE:\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\tcase VIRTIO_VSOCK_OP_SHUTDOWN:\n\t\tif (le32_to_cpu(hdr->flags) & VIRTIO_VSOCK_SHUTDOWN_RCV)\n\t\t\tvsk->peer_shutdown |= RCV_SHUTDOWN;\n\t\tif (le32_to_cpu(hdr->flags) & VIRTIO_VSOCK_SHUTDOWN_SEND)\n\t\t\tvsk->peer_shutdown |= SEND_SHUTDOWN;\n\t\tif (vsk->peer_shutdown == SHUTDOWN_MASK) {\n\t\t\tif (vsock_stream_has_data(vsk) <= 0 && !sock_flag(sk, SOCK_DONE)) {\n\t\t\t\t(void)virtio_transport_reset(vsk, NULL);\n\t\t\t\tvirtio_transport_do_close(vsk, true);\n\t\t\t}\n\t\t\t \n\t\t\tvsock_remove_sock(vsk);\n\t\t}\n\t\tif (le32_to_cpu(virtio_vsock_hdr(skb)->flags))\n\t\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\tcase VIRTIO_VSOCK_OP_RST:\n\t\tvirtio_transport_do_close(vsk, true);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic void\nvirtio_transport_recv_disconnecting(struct sock *sk,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct virtio_vsock_hdr *hdr = virtio_vsock_hdr(skb);\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tif (le16_to_cpu(hdr->op) == VIRTIO_VSOCK_OP_RST)\n\t\tvirtio_transport_do_close(vsk, true);\n}\n\nstatic int\nvirtio_transport_send_response(struct vsock_sock *vsk,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct virtio_vsock_hdr *hdr = virtio_vsock_hdr(skb);\n\tstruct virtio_vsock_pkt_info info = {\n\t\t.op = VIRTIO_VSOCK_OP_RESPONSE,\n\t\t.remote_cid = le64_to_cpu(hdr->src_cid),\n\t\t.remote_port = le32_to_cpu(hdr->src_port),\n\t\t.reply = true,\n\t\t.vsk = vsk,\n\t};\n\n\treturn virtio_transport_send_pkt_info(vsk, &info);\n}\n\nstatic bool virtio_transport_space_update(struct sock *sk,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct virtio_vsock_hdr *hdr = virtio_vsock_hdr(skb);\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\tbool space_available;\n\n\t \n\tif (!vvs)\n\t\treturn true;\n\n\t \n\tspin_lock_bh(&vvs->tx_lock);\n\tvvs->peer_buf_alloc = le32_to_cpu(hdr->buf_alloc);\n\tvvs->peer_fwd_cnt = le32_to_cpu(hdr->fwd_cnt);\n\tspace_available = virtio_transport_has_space(vsk);\n\tspin_unlock_bh(&vvs->tx_lock);\n\treturn space_available;\n}\n\n \nstatic int\nvirtio_transport_recv_listen(struct sock *sk, struct sk_buff *skb,\n\t\t\t     struct virtio_transport *t)\n{\n\tstruct virtio_vsock_hdr *hdr = virtio_vsock_hdr(skb);\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\tstruct vsock_sock *vchild;\n\tstruct sock *child;\n\tint ret;\n\n\tif (le16_to_cpu(hdr->op) != VIRTIO_VSOCK_OP_REQUEST) {\n\t\tvirtio_transport_reset_no_sock(t, skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sk_acceptq_is_full(sk)) {\n\t\tvirtio_transport_reset_no_sock(t, skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tchild = vsock_create_connected(sk);\n\tif (!child) {\n\t\tvirtio_transport_reset_no_sock(t, skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tsk_acceptq_added(sk);\n\n\tlock_sock_nested(child, SINGLE_DEPTH_NESTING);\n\n\tchild->sk_state = TCP_ESTABLISHED;\n\n\tvchild = vsock_sk(child);\n\tvsock_addr_init(&vchild->local_addr, le64_to_cpu(hdr->dst_cid),\n\t\t\tle32_to_cpu(hdr->dst_port));\n\tvsock_addr_init(&vchild->remote_addr, le64_to_cpu(hdr->src_cid),\n\t\t\tle32_to_cpu(hdr->src_port));\n\n\tret = vsock_assign_transport(vchild, vsk);\n\t \n\tif (ret || vchild->transport != &t->transport) {\n\t\trelease_sock(child);\n\t\tvirtio_transport_reset_no_sock(t, skb);\n\t\tsock_put(child);\n\t\treturn ret;\n\t}\n\n\tif (virtio_transport_space_update(child, skb))\n\t\tchild->sk_write_space(child);\n\n\tvsock_insert_connected(vchild);\n\tvsock_enqueue_accept(sk, child);\n\tvirtio_transport_send_response(vchild, skb);\n\n\trelease_sock(child);\n\n\tsk->sk_data_ready(sk);\n\treturn 0;\n}\n\nstatic bool virtio_transport_valid_type(u16 type)\n{\n\treturn (type == VIRTIO_VSOCK_TYPE_STREAM) ||\n\t       (type == VIRTIO_VSOCK_TYPE_SEQPACKET);\n}\n\n \nvoid virtio_transport_recv_pkt(struct virtio_transport *t,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct virtio_vsock_hdr *hdr = virtio_vsock_hdr(skb);\n\tstruct sockaddr_vm src, dst;\n\tstruct vsock_sock *vsk;\n\tstruct sock *sk;\n\tbool space_available;\n\n\tvsock_addr_init(&src, le64_to_cpu(hdr->src_cid),\n\t\t\tle32_to_cpu(hdr->src_port));\n\tvsock_addr_init(&dst, le64_to_cpu(hdr->dst_cid),\n\t\t\tle32_to_cpu(hdr->dst_port));\n\n\ttrace_virtio_transport_recv_pkt(src.svm_cid, src.svm_port,\n\t\t\t\t\tdst.svm_cid, dst.svm_port,\n\t\t\t\t\tle32_to_cpu(hdr->len),\n\t\t\t\t\tle16_to_cpu(hdr->type),\n\t\t\t\t\tle16_to_cpu(hdr->op),\n\t\t\t\t\tle32_to_cpu(hdr->flags),\n\t\t\t\t\tle32_to_cpu(hdr->buf_alloc),\n\t\t\t\t\tle32_to_cpu(hdr->fwd_cnt));\n\n\tif (!virtio_transport_valid_type(le16_to_cpu(hdr->type))) {\n\t\t(void)virtio_transport_reset_no_sock(t, skb);\n\t\tgoto free_pkt;\n\t}\n\n\t \n\tsk = vsock_find_connected_socket(&src, &dst);\n\tif (!sk) {\n\t\tsk = vsock_find_bound_socket(&dst);\n\t\tif (!sk) {\n\t\t\t(void)virtio_transport_reset_no_sock(t, skb);\n\t\t\tgoto free_pkt;\n\t\t}\n\t}\n\n\tif (virtio_transport_get_type(sk) != le16_to_cpu(hdr->type)) {\n\t\t(void)virtio_transport_reset_no_sock(t, skb);\n\t\tsock_put(sk);\n\t\tgoto free_pkt;\n\t}\n\n\tif (!skb_set_owner_sk_safe(skb, sk)) {\n\t\tWARN_ONCE(1, \"receiving vsock socket has sk_refcnt == 0\\n\");\n\t\tgoto free_pkt;\n\t}\n\n\tvsk = vsock_sk(sk);\n\n\tlock_sock(sk);\n\n\t \n\tif (sock_flag(sk, SOCK_DONE)) {\n\t\t(void)virtio_transport_reset_no_sock(t, skb);\n\t\trelease_sock(sk);\n\t\tsock_put(sk);\n\t\tgoto free_pkt;\n\t}\n\n\tspace_available = virtio_transport_space_update(sk, skb);\n\n\t \n\tif (vsk->local_addr.svm_cid != VMADDR_CID_ANY)\n\t\tvsk->local_addr.svm_cid = dst.svm_cid;\n\n\tif (space_available)\n\t\tsk->sk_write_space(sk);\n\n\tswitch (sk->sk_state) {\n\tcase TCP_LISTEN:\n\t\tvirtio_transport_recv_listen(sk, skb, t);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\tcase TCP_SYN_SENT:\n\t\tvirtio_transport_recv_connecting(sk, skb);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\t\tvirtio_transport_recv_connected(sk, skb);\n\t\tbreak;\n\tcase TCP_CLOSING:\n\t\tvirtio_transport_recv_disconnecting(sk, skb);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\tdefault:\n\t\t(void)virtio_transport_reset_no_sock(t, skb);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\t \n\tsock_put(sk);\n\treturn;\n\nfree_pkt:\n\tkfree_skb(skb);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_recv_pkt);\n\n \nint virtio_transport_purge_skbs(void *vsk, struct sk_buff_head *queue)\n{\n\tstruct sk_buff_head freeme;\n\tstruct sk_buff *skb, *tmp;\n\tint cnt = 0;\n\n\tskb_queue_head_init(&freeme);\n\n\tspin_lock_bh(&queue->lock);\n\tskb_queue_walk_safe(queue, skb, tmp) {\n\t\tif (vsock_sk(skb->sk) != vsk)\n\t\t\tcontinue;\n\n\t\t__skb_unlink(skb, queue);\n\t\t__skb_queue_tail(&freeme, skb);\n\n\t\tif (virtio_vsock_skb_reply(skb))\n\t\t\tcnt++;\n\t}\n\tspin_unlock_bh(&queue->lock);\n\n\t__skb_queue_purge(&freeme);\n\n\treturn cnt;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_purge_skbs);\n\nint virtio_transport_read_skb(struct vsock_sock *vsk, skb_read_actor_t recv_actor)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\tstruct sock *sk = sk_vsock(vsk);\n\tstruct sk_buff *skb;\n\tint off = 0;\n\tint err;\n\n\tspin_lock_bh(&vvs->rx_lock);\n\t \n\tskb = __skb_recv_datagram(sk, &vvs->rx_queue, MSG_DONTWAIT, &off, &err);\n\tspin_unlock_bh(&vvs->rx_lock);\n\n\tif (!skb)\n\t\treturn err;\n\n\treturn recv_actor(sk, skb);\n}\nEXPORT_SYMBOL_GPL(virtio_transport_read_skb);\n\nint virtio_transport_notify_set_rcvlowat(struct vsock_sock *vsk, int val)\n{\n\tstruct virtio_vsock_sock *vvs = vsk->trans;\n\tbool send_update;\n\n\tspin_lock_bh(&vvs->rx_lock);\n\n\t \n\tsend_update = (vvs->rx_bytes < val) &&\n\t\t      (vvs->fwd_cnt != vvs->last_fwd_cnt);\n\n\tspin_unlock_bh(&vvs->rx_lock);\n\n\tif (send_update) {\n\t\tint err;\n\n\t\terr = virtio_transport_send_credit_update(vsk);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_transport_notify_set_rcvlowat);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Asias He\");\nMODULE_DESCRIPTION(\"common code for virtio vsock\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}