{
  "module_name": "hyperv_transport.c",
  "hash_id": "285f6a6c7450cca0d02bf0bb8220a20ffd6e5c24760f80f47c6a16896d64b6bb",
  "original_prompt": "Ingested from linux-6.6.14/net/vmw_vsock/hyperv_transport.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/hyperv.h>\n#include <net/sock.h>\n#include <net/af_vsock.h>\n#include <asm/hyperv-tlfs.h>\n\n \n#define RINGBUFFER_HVS_RCV_SIZE (HV_HYP_PAGE_SIZE * 6)\n#define RINGBUFFER_HVS_SND_SIZE (HV_HYP_PAGE_SIZE * 6)\n#define RINGBUFFER_HVS_MAX_SIZE (HV_HYP_PAGE_SIZE * 64)\n\n \n#define HVS_MTU_SIZE\t\t(1024 * 16)\n\n \n#define HVS_CLOSE_TIMEOUT (8 * HZ)\n\nstruct vmpipe_proto_header {\n\tu32 pkt_type;\n\tu32 data_size;\n};\n\n \nstruct hvs_recv_buf {\n\t \n\tstruct vmpipe_proto_header hdr;\n\n\t \n\tu8 data[HVS_MTU_SIZE];\n};\n\n \n#define HVS_SEND_BUF_SIZE \\\n\t\t(HV_HYP_PAGE_SIZE - sizeof(struct vmpipe_proto_header))\n\nstruct hvs_send_buf {\n\t \n\tstruct vmpipe_proto_header hdr;\n\n\t \n\tu8 data[HVS_SEND_BUF_SIZE];\n};\n\n#define HVS_HEADER_LEN\t(sizeof(struct vmpacket_descriptor) + \\\n\t\t\t sizeof(struct vmpipe_proto_header))\n\n \n#define VMBUS_PKT_TRAILER_SIZE\t(sizeof(u64))\n\n#define HVS_PKT_LEN(payload_len)\t(HVS_HEADER_LEN + \\\n\t\t\t\t\t ALIGN((payload_len), 8) + \\\n\t\t\t\t\t VMBUS_PKT_TRAILER_SIZE)\n\n \n#define HVS_MAX_PKT_SIZE\tHVS_PKT_LEN(HVS_MTU_SIZE)\n\nunion hvs_service_id {\n\tguid_t\tsrv_id;\n\n\tstruct {\n\t\tunsigned int svm_port;\n\t\tunsigned char b[sizeof(guid_t) - sizeof(unsigned int)];\n\t};\n};\n\n \nstruct hvsock {\n\tstruct vsock_sock *vsk;\n\n\tguid_t vm_srv_id;\n\tguid_t host_srv_id;\n\n\tstruct vmbus_channel *chan;\n\tstruct vmpacket_descriptor *recv_desc;\n\n\t \n\tu32 recv_data_len;\n\t \n\tu32 recv_data_off;\n\n\t \n\tbool fin_sent;\n};\n\n \n\n \nstatic const guid_t srv_id_template =\n\tGUID_INIT(0x00000000, 0xfacb, 0x11e6, 0xbd, 0x58,\n\t\t  0x64, 0x00, 0x6a, 0x79, 0x86, 0xd3);\n\nstatic bool hvs_check_transport(struct vsock_sock *vsk);\n\nstatic bool is_valid_srv_id(const guid_t *id)\n{\n\treturn !memcmp(&id->b[4], &srv_id_template.b[4], sizeof(guid_t) - 4);\n}\n\nstatic unsigned int get_port_by_srv_id(const guid_t *svr_id)\n{\n\treturn *((unsigned int *)svr_id);\n}\n\nstatic void hvs_addr_init(struct sockaddr_vm *addr, const guid_t *svr_id)\n{\n\tunsigned int port = get_port_by_srv_id(svr_id);\n\n\tvsock_addr_init(addr, VMADDR_CID_ANY, port);\n}\n\nstatic void hvs_set_channel_pending_send_size(struct vmbus_channel *chan)\n{\n\tset_channel_pending_send_size(chan,\n\t\t\t\t      HVS_PKT_LEN(HVS_SEND_BUF_SIZE));\n\n\tvirt_mb();\n}\n\nstatic bool hvs_channel_readable(struct vmbus_channel *chan)\n{\n\tu32 readable = hv_get_bytes_to_read(&chan->inbound);\n\n\t \n\treturn readable >= HVS_PKT_LEN(0);\n}\n\nstatic int hvs_channel_readable_payload(struct vmbus_channel *chan)\n{\n\tu32 readable = hv_get_bytes_to_read(&chan->inbound);\n\n\tif (readable > HVS_PKT_LEN(0)) {\n\t\t \n\t\treturn 1;\n\t}\n\n\tif (readable == HVS_PKT_LEN(0)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\treturn -1;\n}\n\nstatic size_t hvs_channel_writable_bytes(struct vmbus_channel *chan)\n{\n\tu32 writeable = hv_get_bytes_to_write(&chan->outbound);\n\tsize_t ret;\n\n\t \n\tif (writeable <= HVS_PKT_LEN(1) + HVS_PKT_LEN(0))\n\t\treturn 0;\n\n\tret = writeable - HVS_PKT_LEN(1) - HVS_PKT_LEN(0);\n\n\treturn round_down(ret, 8);\n}\n\nstatic int __hvs_send_data(struct vmbus_channel *chan,\n\t\t\t   struct vmpipe_proto_header *hdr,\n\t\t\t   size_t to_write)\n{\n\thdr->pkt_type = 1;\n\thdr->data_size = to_write;\n\treturn vmbus_sendpacket(chan, hdr, sizeof(*hdr) + to_write,\n\t\t\t\t0, VM_PKT_DATA_INBAND, 0);\n}\n\nstatic int hvs_send_data(struct vmbus_channel *chan,\n\t\t\t struct hvs_send_buf *send_buf, size_t to_write)\n{\n\treturn __hvs_send_data(chan, &send_buf->hdr, to_write);\n}\n\nstatic void hvs_channel_cb(void *ctx)\n{\n\tstruct sock *sk = (struct sock *)ctx;\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\tstruct hvsock *hvs = vsk->trans;\n\tstruct vmbus_channel *chan = hvs->chan;\n\n\tif (hvs_channel_readable(chan))\n\t\tsk->sk_data_ready(sk);\n\n\tif (hv_get_bytes_to_write(&chan->outbound) > 0)\n\t\tsk->sk_write_space(sk);\n}\n\nstatic void hvs_do_close_lock_held(struct vsock_sock *vsk,\n\t\t\t\t   bool cancel_timeout)\n{\n\tstruct sock *sk = sk_vsock(vsk);\n\n\tsock_set_flag(sk, SOCK_DONE);\n\tvsk->peer_shutdown = SHUTDOWN_MASK;\n\tif (vsock_stream_has_data(vsk) <= 0)\n\t\tsk->sk_state = TCP_CLOSING;\n\tsk->sk_state_change(sk);\n\tif (vsk->close_work_scheduled &&\n\t    (!cancel_timeout || cancel_delayed_work(&vsk->close_work))) {\n\t\tvsk->close_work_scheduled = false;\n\t\tvsock_remove_sock(vsk);\n\n\t\t \n\t\tsock_put(sk);\n\t}\n}\n\nstatic void hvs_close_connection(struct vmbus_channel *chan)\n{\n\tstruct sock *sk = get_per_channel_state(chan);\n\n\tlock_sock(sk);\n\thvs_do_close_lock_held(vsock_sk(sk), true);\n\trelease_sock(sk);\n\n\t \n\tsock_put(sk);\n}\n\nstatic void hvs_open_connection(struct vmbus_channel *chan)\n{\n\tguid_t *if_instance, *if_type;\n\tunsigned char conn_from_host;\n\n\tstruct sockaddr_vm addr;\n\tstruct sock *sk, *new = NULL;\n\tstruct vsock_sock *vnew = NULL;\n\tstruct hvsock *hvs = NULL;\n\tstruct hvsock *hvs_new = NULL;\n\tint rcvbuf;\n\tint ret;\n\tint sndbuf;\n\n\tif_type = &chan->offermsg.offer.if_type;\n\tif_instance = &chan->offermsg.offer.if_instance;\n\tconn_from_host = chan->offermsg.offer.u.pipe.user_def[0];\n\tif (!is_valid_srv_id(if_type))\n\t\treturn;\n\n\thvs_addr_init(&addr, conn_from_host ? if_type : if_instance);\n\tsk = vsock_find_bound_socket(&addr);\n\tif (!sk)\n\t\treturn;\n\n\tlock_sock(sk);\n\tif ((conn_from_host && sk->sk_state != TCP_LISTEN) ||\n\t    (!conn_from_host && sk->sk_state != TCP_SYN_SENT))\n\t\tgoto out;\n\n\tif (conn_from_host) {\n\t\tif (sk->sk_ack_backlog >= sk->sk_max_ack_backlog)\n\t\t\tgoto out;\n\n\t\tnew = vsock_create_connected(sk);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tnew->sk_state = TCP_SYN_SENT;\n\t\tvnew = vsock_sk(new);\n\n\t\thvs_addr_init(&vnew->local_addr, if_type);\n\n\t\t \n\t\tvsock_addr_init(&vnew->remote_addr,\n\t\t\t\tVMADDR_CID_HOST, VMADDR_PORT_ANY);\n\t\tvnew->remote_addr.svm_port = get_port_by_srv_id(if_instance);\n\t\tret = vsock_assign_transport(vnew, vsock_sk(sk));\n\t\t \n\t\tif (ret || !hvs_check_transport(vnew)) {\n\t\t\tsock_put(new);\n\t\t\tgoto out;\n\t\t}\n\t\thvs_new = vnew->trans;\n\t\thvs_new->chan = chan;\n\t} else {\n\t\thvs = vsock_sk(sk)->trans;\n\t\thvs->chan = chan;\n\t}\n\n\tset_channel_read_mode(chan, HV_CALL_DIRECT);\n\n\t \n\tif (vmbus_proto_version < VERSION_WIN10_V5) {\n\t\tsndbuf = RINGBUFFER_HVS_SND_SIZE;\n\t\trcvbuf = RINGBUFFER_HVS_RCV_SIZE;\n\t} else {\n\t\tsndbuf = max_t(int, sk->sk_sndbuf, RINGBUFFER_HVS_SND_SIZE);\n\t\tsndbuf = min_t(int, sndbuf, RINGBUFFER_HVS_MAX_SIZE);\n\t\tsndbuf = ALIGN(sndbuf, HV_HYP_PAGE_SIZE);\n\t\trcvbuf = max_t(int, sk->sk_rcvbuf, RINGBUFFER_HVS_RCV_SIZE);\n\t\trcvbuf = min_t(int, rcvbuf, RINGBUFFER_HVS_MAX_SIZE);\n\t\trcvbuf = ALIGN(rcvbuf, HV_HYP_PAGE_SIZE);\n\t}\n\n\tchan->max_pkt_size = HVS_MAX_PKT_SIZE;\n\n\tret = vmbus_open(chan, sndbuf, rcvbuf, NULL, 0, hvs_channel_cb,\n\t\t\t conn_from_host ? new : sk);\n\tif (ret != 0) {\n\t\tif (conn_from_host) {\n\t\t\thvs_new->chan = NULL;\n\t\t\tsock_put(new);\n\t\t} else {\n\t\t\thvs->chan = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tset_per_channel_state(chan, conn_from_host ? new : sk);\n\n\t \n\tsock_hold(conn_from_host ? new : sk);\n\tvmbus_set_chn_rescind_callback(chan, hvs_close_connection);\n\n\t \n\thvs_set_channel_pending_send_size(chan);\n\n\tif (conn_from_host) {\n\t\tnew->sk_state = TCP_ESTABLISHED;\n\t\tsk_acceptq_added(sk);\n\n\t\thvs_new->vm_srv_id = *if_type;\n\t\thvs_new->host_srv_id = *if_instance;\n\n\t\tvsock_insert_connected(vnew);\n\n\t\tvsock_enqueue_accept(sk, new);\n\t} else {\n\t\tsk->sk_state = TCP_ESTABLISHED;\n\t\tsk->sk_socket->state = SS_CONNECTED;\n\n\t\tvsock_insert_connected(vsock_sk(sk));\n\t}\n\n\tsk->sk_state_change(sk);\n\nout:\n\t \n\tsock_put(sk);\n\n\trelease_sock(sk);\n}\n\nstatic u32 hvs_get_local_cid(void)\n{\n\treturn VMADDR_CID_ANY;\n}\n\nstatic int hvs_sock_init(struct vsock_sock *vsk, struct vsock_sock *psk)\n{\n\tstruct hvsock *hvs;\n\tstruct sock *sk = sk_vsock(vsk);\n\n\thvs = kzalloc(sizeof(*hvs), GFP_KERNEL);\n\tif (!hvs)\n\t\treturn -ENOMEM;\n\n\tvsk->trans = hvs;\n\thvs->vsk = vsk;\n\tsk->sk_sndbuf = RINGBUFFER_HVS_SND_SIZE;\n\tsk->sk_rcvbuf = RINGBUFFER_HVS_RCV_SIZE;\n\treturn 0;\n}\n\nstatic int hvs_connect(struct vsock_sock *vsk)\n{\n\tunion hvs_service_id vm, host;\n\tstruct hvsock *h = vsk->trans;\n\n\tvm.srv_id = srv_id_template;\n\tvm.svm_port = vsk->local_addr.svm_port;\n\th->vm_srv_id = vm.srv_id;\n\n\thost.srv_id = srv_id_template;\n\thost.svm_port = vsk->remote_addr.svm_port;\n\th->host_srv_id = host.srv_id;\n\n\treturn vmbus_send_tl_connect_request(&h->vm_srv_id, &h->host_srv_id);\n}\n\nstatic void hvs_shutdown_lock_held(struct hvsock *hvs, int mode)\n{\n\tstruct vmpipe_proto_header hdr;\n\n\tif (hvs->fin_sent || !hvs->chan)\n\t\treturn;\n\n\t \n\t(void)__hvs_send_data(hvs->chan, &hdr, 0);\n\thvs->fin_sent = true;\n}\n\nstatic int hvs_shutdown(struct vsock_sock *vsk, int mode)\n{\n\tif (!(mode & SEND_SHUTDOWN))\n\t\treturn 0;\n\n\thvs_shutdown_lock_held(vsk->trans, mode);\n\treturn 0;\n}\n\nstatic void hvs_close_timeout(struct work_struct *work)\n{\n\tstruct vsock_sock *vsk =\n\t\tcontainer_of(work, struct vsock_sock, close_work.work);\n\tstruct sock *sk = sk_vsock(vsk);\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tif (!sock_flag(sk, SOCK_DONE))\n\t\thvs_do_close_lock_held(vsk, false);\n\n\tvsk->close_work_scheduled = false;\n\trelease_sock(sk);\n\tsock_put(sk);\n}\n\n \nstatic bool hvs_close_lock_held(struct vsock_sock *vsk)\n{\n\tstruct sock *sk = sk_vsock(vsk);\n\n\tif (!(sk->sk_state == TCP_ESTABLISHED ||\n\t      sk->sk_state == TCP_CLOSING))\n\t\treturn true;\n\n\tif ((sk->sk_shutdown & SHUTDOWN_MASK) != SHUTDOWN_MASK)\n\t\thvs_shutdown_lock_held(vsk->trans, SHUTDOWN_MASK);\n\n\tif (sock_flag(sk, SOCK_DONE))\n\t\treturn true;\n\n\t \n\tsock_hold(sk);\n\tINIT_DELAYED_WORK(&vsk->close_work, hvs_close_timeout);\n\tvsk->close_work_scheduled = true;\n\tschedule_delayed_work(&vsk->close_work, HVS_CLOSE_TIMEOUT);\n\treturn false;\n}\n\nstatic void hvs_release(struct vsock_sock *vsk)\n{\n\tbool remove_sock;\n\n\tremove_sock = hvs_close_lock_held(vsk);\n\tif (remove_sock)\n\t\tvsock_remove_sock(vsk);\n}\n\nstatic void hvs_destruct(struct vsock_sock *vsk)\n{\n\tstruct hvsock *hvs = vsk->trans;\n\tstruct vmbus_channel *chan = hvs->chan;\n\n\tif (chan)\n\t\tvmbus_hvsock_device_unregister(chan);\n\n\tkfree(hvs);\n}\n\nstatic int hvs_dgram_bind(struct vsock_sock *vsk, struct sockaddr_vm *addr)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int hvs_dgram_dequeue(struct vsock_sock *vsk, struct msghdr *msg,\n\t\t\t     size_t len, int flags)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int hvs_dgram_enqueue(struct vsock_sock *vsk,\n\t\t\t     struct sockaddr_vm *remote, struct msghdr *msg,\n\t\t\t     size_t dgram_len)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic bool hvs_dgram_allow(u32 cid, u32 port)\n{\n\treturn false;\n}\n\nstatic int hvs_update_recv_data(struct hvsock *hvs)\n{\n\tstruct hvs_recv_buf *recv_buf;\n\tu32 pkt_len, payload_len;\n\n\tpkt_len = hv_pkt_len(hvs->recv_desc);\n\n\tif (pkt_len < HVS_HEADER_LEN)\n\t\treturn -EIO;\n\n\trecv_buf = (struct hvs_recv_buf *)(hvs->recv_desc + 1);\n\tpayload_len = recv_buf->hdr.data_size;\n\n\tif (payload_len > pkt_len - HVS_HEADER_LEN ||\n\t    payload_len > HVS_MTU_SIZE)\n\t\treturn -EIO;\n\n\tif (payload_len == 0)\n\t\thvs->vsk->peer_shutdown |= SEND_SHUTDOWN;\n\n\thvs->recv_data_len = payload_len;\n\thvs->recv_data_off = 0;\n\n\treturn 0;\n}\n\nstatic ssize_t hvs_stream_dequeue(struct vsock_sock *vsk, struct msghdr *msg,\n\t\t\t\t  size_t len, int flags)\n{\n\tstruct hvsock *hvs = vsk->trans;\n\tbool need_refill = !hvs->recv_desc;\n\tstruct hvs_recv_buf *recv_buf;\n\tu32 to_read;\n\tint ret;\n\n\tif (flags & MSG_PEEK)\n\t\treturn -EOPNOTSUPP;\n\n\tif (need_refill) {\n\t\thvs->recv_desc = hv_pkt_iter_first(hvs->chan);\n\t\tif (!hvs->recv_desc)\n\t\t\treturn -ENOBUFS;\n\t\tret = hvs_update_recv_data(hvs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\trecv_buf = (struct hvs_recv_buf *)(hvs->recv_desc + 1);\n\tto_read = min_t(u32, len, hvs->recv_data_len);\n\tret = memcpy_to_msg(msg, recv_buf->data + hvs->recv_data_off, to_read);\n\tif (ret != 0)\n\t\treturn ret;\n\n\thvs->recv_data_len -= to_read;\n\tif (hvs->recv_data_len == 0) {\n\t\thvs->recv_desc = hv_pkt_iter_next(hvs->chan, hvs->recv_desc);\n\t\tif (hvs->recv_desc) {\n\t\t\tret = hvs_update_recv_data(hvs);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\thvs->recv_data_off += to_read;\n\t}\n\n\treturn to_read;\n}\n\nstatic ssize_t hvs_stream_enqueue(struct vsock_sock *vsk, struct msghdr *msg,\n\t\t\t\t  size_t len)\n{\n\tstruct hvsock *hvs = vsk->trans;\n\tstruct vmbus_channel *chan = hvs->chan;\n\tstruct hvs_send_buf *send_buf;\n\tssize_t to_write, max_writable;\n\tssize_t ret = 0;\n\tssize_t bytes_written = 0;\n\n\tBUILD_BUG_ON(sizeof(*send_buf) != HV_HYP_PAGE_SIZE);\n\n\tsend_buf = kmalloc(sizeof(*send_buf), GFP_KERNEL);\n\tif (!send_buf)\n\t\treturn -ENOMEM;\n\n\t \n\twhile (len) {\n\t\tmax_writable = hvs_channel_writable_bytes(chan);\n\t\tif (!max_writable)\n\t\t\tbreak;\n\t\tto_write = min_t(ssize_t, len, max_writable);\n\t\tto_write = min_t(ssize_t, to_write, HVS_SEND_BUF_SIZE);\n\t\t \n\t\tret = memcpy_from_msg(send_buf->data, msg, to_write);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = hvs_send_data(hvs->chan, send_buf, to_write);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tbytes_written += to_write;\n\t\tlen -= to_write;\n\t}\nout:\n\t \n\tif (bytes_written)\n\t\tret = bytes_written;\n\tkfree(send_buf);\n\treturn ret;\n}\n\nstatic s64 hvs_stream_has_data(struct vsock_sock *vsk)\n{\n\tstruct hvsock *hvs = vsk->trans;\n\ts64 ret;\n\n\tif (hvs->recv_data_len > 0)\n\t\treturn 1;\n\n\tswitch (hvs_channel_readable_payload(hvs->chan)) {\n\tcase 1:\n\t\tret = 1;\n\t\tbreak;\n\tcase 0:\n\t\tvsk->peer_shutdown |= SEND_SHUTDOWN;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:  \n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic s64 hvs_stream_has_space(struct vsock_sock *vsk)\n{\n\tstruct hvsock *hvs = vsk->trans;\n\n\treturn hvs_channel_writable_bytes(hvs->chan);\n}\n\nstatic u64 hvs_stream_rcvhiwat(struct vsock_sock *vsk)\n{\n\treturn HVS_MTU_SIZE + 1;\n}\n\nstatic bool hvs_stream_is_active(struct vsock_sock *vsk)\n{\n\tstruct hvsock *hvs = vsk->trans;\n\n\treturn hvs->chan != NULL;\n}\n\nstatic bool hvs_stream_allow(u32 cid, u32 port)\n{\n\tif (cid == VMADDR_CID_HOST)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic\nint hvs_notify_poll_in(struct vsock_sock *vsk, size_t target, bool *readable)\n{\n\tstruct hvsock *hvs = vsk->trans;\n\n\t*readable = hvs_channel_readable(hvs->chan);\n\treturn 0;\n}\n\nstatic\nint hvs_notify_poll_out(struct vsock_sock *vsk, size_t target, bool *writable)\n{\n\t*writable = hvs_stream_has_space(vsk) > 0;\n\n\treturn 0;\n}\n\nstatic\nint hvs_notify_recv_init(struct vsock_sock *vsk, size_t target,\n\t\t\t struct vsock_transport_recv_notify_data *d)\n{\n\treturn 0;\n}\n\nstatic\nint hvs_notify_recv_pre_block(struct vsock_sock *vsk, size_t target,\n\t\t\t      struct vsock_transport_recv_notify_data *d)\n{\n\treturn 0;\n}\n\nstatic\nint hvs_notify_recv_pre_dequeue(struct vsock_sock *vsk, size_t target,\n\t\t\t\tstruct vsock_transport_recv_notify_data *d)\n{\n\treturn 0;\n}\n\nstatic\nint hvs_notify_recv_post_dequeue(struct vsock_sock *vsk, size_t target,\n\t\t\t\t ssize_t copied, bool data_read,\n\t\t\t\t struct vsock_transport_recv_notify_data *d)\n{\n\treturn 0;\n}\n\nstatic\nint hvs_notify_send_init(struct vsock_sock *vsk,\n\t\t\t struct vsock_transport_send_notify_data *d)\n{\n\treturn 0;\n}\n\nstatic\nint hvs_notify_send_pre_block(struct vsock_sock *vsk,\n\t\t\t      struct vsock_transport_send_notify_data *d)\n{\n\treturn 0;\n}\n\nstatic\nint hvs_notify_send_pre_enqueue(struct vsock_sock *vsk,\n\t\t\t\tstruct vsock_transport_send_notify_data *d)\n{\n\treturn 0;\n}\n\nstatic\nint hvs_notify_send_post_enqueue(struct vsock_sock *vsk, ssize_t written,\n\t\t\t\t struct vsock_transport_send_notify_data *d)\n{\n\treturn 0;\n}\n\nstatic\nint hvs_notify_set_rcvlowat(struct vsock_sock *vsk, int val)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct vsock_transport hvs_transport = {\n\t.module                   = THIS_MODULE,\n\n\t.get_local_cid            = hvs_get_local_cid,\n\n\t.init                     = hvs_sock_init,\n\t.destruct                 = hvs_destruct,\n\t.release                  = hvs_release,\n\t.connect                  = hvs_connect,\n\t.shutdown                 = hvs_shutdown,\n\n\t.dgram_bind               = hvs_dgram_bind,\n\t.dgram_dequeue            = hvs_dgram_dequeue,\n\t.dgram_enqueue            = hvs_dgram_enqueue,\n\t.dgram_allow              = hvs_dgram_allow,\n\n\t.stream_dequeue           = hvs_stream_dequeue,\n\t.stream_enqueue           = hvs_stream_enqueue,\n\t.stream_has_data          = hvs_stream_has_data,\n\t.stream_has_space         = hvs_stream_has_space,\n\t.stream_rcvhiwat          = hvs_stream_rcvhiwat,\n\t.stream_is_active         = hvs_stream_is_active,\n\t.stream_allow             = hvs_stream_allow,\n\n\t.notify_poll_in           = hvs_notify_poll_in,\n\t.notify_poll_out          = hvs_notify_poll_out,\n\t.notify_recv_init         = hvs_notify_recv_init,\n\t.notify_recv_pre_block    = hvs_notify_recv_pre_block,\n\t.notify_recv_pre_dequeue  = hvs_notify_recv_pre_dequeue,\n\t.notify_recv_post_dequeue = hvs_notify_recv_post_dequeue,\n\t.notify_send_init         = hvs_notify_send_init,\n\t.notify_send_pre_block    = hvs_notify_send_pre_block,\n\t.notify_send_pre_enqueue  = hvs_notify_send_pre_enqueue,\n\t.notify_send_post_enqueue = hvs_notify_send_post_enqueue,\n\n\t.notify_set_rcvlowat      = hvs_notify_set_rcvlowat\n};\n\nstatic bool hvs_check_transport(struct vsock_sock *vsk)\n{\n\treturn vsk->transport == &hvs_transport;\n}\n\nstatic int hvs_probe(struct hv_device *hdev,\n\t\t     const struct hv_vmbus_device_id *dev_id)\n{\n\tstruct vmbus_channel *chan = hdev->channel;\n\n\thvs_open_connection(chan);\n\n\t \n\treturn 0;\n}\n\nstatic void hvs_remove(struct hv_device *hdev)\n{\n\tstruct vmbus_channel *chan = hdev->channel;\n\n\tvmbus_close(chan);\n}\n\n \nstatic int hvs_suspend(struct hv_device *hv_dev)\n{\n\t \n\treturn 0;\n}\n\nstatic int hvs_resume(struct hv_device *dev)\n{\n\t \n\treturn 0;\n}\n\n \nstatic const struct hv_vmbus_device_id id_table[] = {\n\t{},\n};\n\nstatic struct hv_driver hvs_drv = {\n\t.name\t\t= \"hv_sock\",\n\t.hvsock\t\t= true,\n\t.id_table\t= id_table,\n\t.probe\t\t= hvs_probe,\n\t.remove\t\t= hvs_remove,\n\t.suspend\t= hvs_suspend,\n\t.resume\t\t= hvs_resume,\n};\n\nstatic int __init hvs_init(void)\n{\n\tint ret;\n\n\tif (vmbus_proto_version < VERSION_WIN10)\n\t\treturn -ENODEV;\n\n\tret = vmbus_driver_register(&hvs_drv);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = vsock_core_register(&hvs_transport, VSOCK_TRANSPORT_F_G2H);\n\tif (ret) {\n\t\tvmbus_driver_unregister(&hvs_drv);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit hvs_exit(void)\n{\n\tvsock_core_unregister(&hvs_transport);\n\tvmbus_driver_unregister(&hvs_drv);\n}\n\nmodule_init(hvs_init);\nmodule_exit(hvs_exit);\n\nMODULE_DESCRIPTION(\"Hyper-V Sockets\");\nMODULE_VERSION(\"1.0.0\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_VSOCK);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}