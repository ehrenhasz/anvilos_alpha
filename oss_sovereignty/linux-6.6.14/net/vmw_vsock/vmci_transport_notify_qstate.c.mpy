{
  "module_name": "vmci_transport_notify_qstate.c",
  "hash_id": "9ccab6b7e5c034981eb28db86d765eeb5bdd72ef44b18d50e47db6ef92532ada",
  "original_prompt": "Ingested from linux-6.6.14/net/vmw_vsock/vmci_transport_notify_qstate.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/stddef.h>\n#include <net/sock.h>\n\n#include \"vmci_transport_notify.h\"\n\n#define PKT_FIELD(vsk, field_name) \\\n\t(vmci_trans(vsk)->notify.pkt_q_state.field_name)\n\nstatic bool vmci_transport_notify_waiting_write(struct vsock_sock *vsk)\n{\n\tbool retval;\n\tu64 notify_limit;\n\n\tif (!PKT_FIELD(vsk, peer_waiting_write))\n\t\treturn false;\n\n\t \n\n\tif (!PKT_FIELD(vsk, peer_waiting_write_detected)) {\n\t\tPKT_FIELD(vsk, peer_waiting_write_detected) = true;\n\t\tif (PKT_FIELD(vsk, write_notify_window) < PAGE_SIZE) {\n\t\t\tPKT_FIELD(vsk, write_notify_window) =\n\t\t\t    PKT_FIELD(vsk, write_notify_min_window);\n\t\t} else {\n\t\t\tPKT_FIELD(vsk, write_notify_window) -= PAGE_SIZE;\n\t\t\tif (PKT_FIELD(vsk, write_notify_window) <\n\t\t\t    PKT_FIELD(vsk, write_notify_min_window))\n\t\t\t\tPKT_FIELD(vsk, write_notify_window) =\n\t\t\t\t    PKT_FIELD(vsk, write_notify_min_window);\n\n\t\t}\n\t}\n\tnotify_limit = vmci_trans(vsk)->consume_size -\n\t\tPKT_FIELD(vsk, write_notify_window);\n\n\t \n\n\tretval = vmci_qpair_consume_free_space(vmci_trans(vsk)->qpair) >\n\t\tnotify_limit;\n\n\tif (retval) {\n\t\t \n\n\t\tPKT_FIELD(vsk, peer_waiting_write_detected) = false;\n\t}\n\treturn retval;\n}\n\nstatic void\nvmci_transport_handle_read(struct sock *sk,\n\t\t\t   struct vmci_transport_packet *pkt,\n\t\t\t   bool bottom_half,\n\t\t\t   struct sockaddr_vm *dst, struct sockaddr_vm *src)\n{\n\tsk->sk_write_space(sk);\n}\n\nstatic void\nvmci_transport_handle_wrote(struct sock *sk,\n\t\t\t    struct vmci_transport_packet *pkt,\n\t\t\t    bool bottom_half,\n\t\t\t    struct sockaddr_vm *dst, struct sockaddr_vm *src)\n{\n\tvsock_data_ready(sk);\n}\n\nstatic void vsock_block_update_write_window(struct sock *sk)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tif (PKT_FIELD(vsk, write_notify_window) < vmci_trans(vsk)->consume_size)\n\t\tPKT_FIELD(vsk, write_notify_window) =\n\t\t    min(PKT_FIELD(vsk, write_notify_window) + PAGE_SIZE,\n\t\t\tvmci_trans(vsk)->consume_size);\n}\n\nstatic int vmci_transport_send_read_notification(struct sock *sk)\n{\n\tstruct vsock_sock *vsk;\n\tbool sent_read;\n\tunsigned int retries;\n\tint err;\n\n\tvsk = vsock_sk(sk);\n\tsent_read = false;\n\tretries = 0;\n\terr = 0;\n\n\tif (vmci_transport_notify_waiting_write(vsk)) {\n\t\t \n\t\twhile (!(vsk->peer_shutdown & RCV_SHUTDOWN) &&\n\t\t       !sent_read &&\n\t\t       retries < VMCI_TRANSPORT_MAX_DGRAM_RESENDS) {\n\t\t\terr = vmci_transport_send_read(sk);\n\t\t\tif (err >= 0)\n\t\t\t\tsent_read = true;\n\n\t\t\tretries++;\n\t\t}\n\n\t\tif (retries >= VMCI_TRANSPORT_MAX_DGRAM_RESENDS && !sent_read)\n\t\t\tpr_err(\"%p unable to send read notification to peer\\n\",\n\t\t\t       sk);\n\t\telse\n\t\t\tPKT_FIELD(vsk, peer_waiting_write) = false;\n\n\t}\n\treturn err;\n}\n\nstatic void vmci_transport_notify_pkt_socket_init(struct sock *sk)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tPKT_FIELD(vsk, write_notify_window) = PAGE_SIZE;\n\tPKT_FIELD(vsk, write_notify_min_window) = PAGE_SIZE;\n\tPKT_FIELD(vsk, peer_waiting_write) = false;\n\tPKT_FIELD(vsk, peer_waiting_write_detected) = false;\n}\n\nstatic void vmci_transport_notify_pkt_socket_destruct(struct vsock_sock *vsk)\n{\n\tPKT_FIELD(vsk, write_notify_window) = PAGE_SIZE;\n\tPKT_FIELD(vsk, write_notify_min_window) = PAGE_SIZE;\n\tPKT_FIELD(vsk, peer_waiting_write) = false;\n\tPKT_FIELD(vsk, peer_waiting_write_detected) = false;\n}\n\nstatic int\nvmci_transport_notify_pkt_poll_in(struct sock *sk,\n\t\t\t\t  size_t target, bool *data_ready_now)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tif (vsock_stream_has_data(vsk) >= target) {\n\t\t*data_ready_now = true;\n\t} else {\n\t\t \n\t\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\t\tvsock_block_update_write_window(sk);\n\t\t*data_ready_now = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvmci_transport_notify_pkt_poll_out(struct sock *sk,\n\t\t\t\t   size_t target, bool *space_avail_now)\n{\n\ts64 produce_q_free_space;\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tproduce_q_free_space = vsock_stream_has_space(vsk);\n\tif (produce_q_free_space > 0) {\n\t\t*space_avail_now = true;\n\t\treturn 0;\n\t} else if (produce_q_free_space == 0) {\n\t\t \n\t\t*space_avail_now = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvmci_transport_notify_pkt_recv_init(\n\t\t\t\tstruct sock *sk,\n\t\t\t\tsize_t target,\n\t\t\t\tstruct vmci_transport_recv_notify_data *data)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tdata->consume_head = 0;\n\tdata->produce_tail = 0;\n\tdata->notify_on_block = false;\n\n\tif (PKT_FIELD(vsk, write_notify_min_window) < target + 1) {\n\t\tPKT_FIELD(vsk, write_notify_min_window) = target + 1;\n\t\tif (PKT_FIELD(vsk, write_notify_window) <\n\t\t    PKT_FIELD(vsk, write_notify_min_window)) {\n\t\t\t \n\n\t\t\tPKT_FIELD(vsk, write_notify_window) =\n\t\t\t    PKT_FIELD(vsk, write_notify_min_window);\n\t\t\tdata->notify_on_block = true;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvmci_transport_notify_pkt_recv_pre_block(\n\t\t\t\tstruct sock *sk,\n\t\t\t\tsize_t target,\n\t\t\t\tstruct vmci_transport_recv_notify_data *data)\n{\n\tint err = 0;\n\n\tvsock_block_update_write_window(sk);\n\n\tif (data->notify_on_block) {\n\t\terr = vmci_transport_send_read_notification(sk);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->notify_on_block = false;\n\t}\n\n\treturn err;\n}\n\nstatic int\nvmci_transport_notify_pkt_recv_post_dequeue(\n\t\t\t\tstruct sock *sk,\n\t\t\t\tsize_t target,\n\t\t\t\tssize_t copied,\n\t\t\t\tbool data_read,\n\t\t\t\tstruct vmci_transport_recv_notify_data *data)\n{\n\tstruct vsock_sock *vsk;\n\tint err;\n\tbool was_full = false;\n\tu64 free_space;\n\n\tvsk = vsock_sk(sk);\n\terr = 0;\n\n\tif (data_read) {\n\t\tsmp_mb();\n\n\t\tfree_space =\n\t\t\tvmci_qpair_consume_free_space(vmci_trans(vsk)->qpair);\n\t\twas_full = free_space == copied;\n\n\t\tif (was_full)\n\t\t\tPKT_FIELD(vsk, peer_waiting_write) = true;\n\n\t\terr = vmci_transport_send_read_notification(sk);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tvsock_data_ready(sk);\n\t}\n\n\treturn err;\n}\n\nstatic int\nvmci_transport_notify_pkt_send_init(\n\t\t\t\tstruct sock *sk,\n\t\t\t\tstruct vmci_transport_send_notify_data *data)\n{\n\tdata->consume_head = 0;\n\tdata->produce_tail = 0;\n\n\treturn 0;\n}\n\nstatic int\nvmci_transport_notify_pkt_send_post_enqueue(\n\t\t\t\tstruct sock *sk,\n\t\t\t\tssize_t written,\n\t\t\t\tstruct vmci_transport_send_notify_data *data)\n{\n\tint err = 0;\n\tstruct vsock_sock *vsk;\n\tbool sent_wrote = false;\n\tbool was_empty;\n\tint retries = 0;\n\n\tvsk = vsock_sk(sk);\n\n\tsmp_mb();\n\n\twas_empty =\n\t\tvmci_qpair_produce_buf_ready(vmci_trans(vsk)->qpair) == written;\n\tif (was_empty) {\n\t\twhile (!(vsk->peer_shutdown & RCV_SHUTDOWN) &&\n\t\t       !sent_wrote &&\n\t\t       retries < VMCI_TRANSPORT_MAX_DGRAM_RESENDS) {\n\t\t\terr = vmci_transport_send_wrote(sk);\n\t\t\tif (err >= 0)\n\t\t\t\tsent_wrote = true;\n\n\t\t\tretries++;\n\t\t}\n\t}\n\n\tif (retries >= VMCI_TRANSPORT_MAX_DGRAM_RESENDS && !sent_wrote) {\n\t\tpr_err(\"%p unable to send wrote notification to peer\\n\",\n\t\t       sk);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic void\nvmci_transport_notify_pkt_handle_pkt(\n\t\t\t\tstruct sock *sk,\n\t\t\t\tstruct vmci_transport_packet *pkt,\n\t\t\t\tbool bottom_half,\n\t\t\t\tstruct sockaddr_vm *dst,\n\t\t\t\tstruct sockaddr_vm *src, bool *pkt_processed)\n{\n\tbool processed = false;\n\n\tswitch (pkt->type) {\n\tcase VMCI_TRANSPORT_PACKET_TYPE_WROTE:\n\t\tvmci_transport_handle_wrote(sk, pkt, bottom_half, dst, src);\n\t\tprocessed = true;\n\t\tbreak;\n\tcase VMCI_TRANSPORT_PACKET_TYPE_READ:\n\t\tvmci_transport_handle_read(sk, pkt, bottom_half, dst, src);\n\t\tprocessed = true;\n\t\tbreak;\n\t}\n\n\tif (pkt_processed)\n\t\t*pkt_processed = processed;\n}\n\nstatic void vmci_transport_notify_pkt_process_request(struct sock *sk)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tPKT_FIELD(vsk, write_notify_window) = vmci_trans(vsk)->consume_size;\n\tif (vmci_trans(vsk)->consume_size <\n\t\tPKT_FIELD(vsk, write_notify_min_window))\n\t\tPKT_FIELD(vsk, write_notify_min_window) =\n\t\t\tvmci_trans(vsk)->consume_size;\n}\n\nstatic void vmci_transport_notify_pkt_process_negotiate(struct sock *sk)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tPKT_FIELD(vsk, write_notify_window) = vmci_trans(vsk)->consume_size;\n\tif (vmci_trans(vsk)->consume_size <\n\t\tPKT_FIELD(vsk, write_notify_min_window))\n\t\tPKT_FIELD(vsk, write_notify_min_window) =\n\t\t\tvmci_trans(vsk)->consume_size;\n}\n\nstatic int\nvmci_transport_notify_pkt_recv_pre_dequeue(\n\t\t\t\tstruct sock *sk,\n\t\t\t\tsize_t target,\n\t\t\t\tstruct vmci_transport_recv_notify_data *data)\n{\n\treturn 0;  \n}\n\nstatic int\nvmci_transport_notify_pkt_send_pre_block(\n\t\t\t\tstruct sock *sk,\n\t\t\t\tstruct vmci_transport_send_notify_data *data)\n{\n\treturn 0;  \n}\n\nstatic int\nvmci_transport_notify_pkt_send_pre_enqueue(\n\t\t\t\tstruct sock *sk,\n\t\t\t\tstruct vmci_transport_send_notify_data *data)\n{\n\treturn 0;  \n}\n\n \nconst struct vmci_transport_notify_ops vmci_transport_notify_pkt_q_state_ops = {\n\t.socket_init = vmci_transport_notify_pkt_socket_init,\n\t.socket_destruct = vmci_transport_notify_pkt_socket_destruct,\n\t.poll_in = vmci_transport_notify_pkt_poll_in,\n\t.poll_out = vmci_transport_notify_pkt_poll_out,\n\t.handle_notify_pkt = vmci_transport_notify_pkt_handle_pkt,\n\t.recv_init = vmci_transport_notify_pkt_recv_init,\n\t.recv_pre_block = vmci_transport_notify_pkt_recv_pre_block,\n\t.recv_pre_dequeue = vmci_transport_notify_pkt_recv_pre_dequeue,\n\t.recv_post_dequeue = vmci_transport_notify_pkt_recv_post_dequeue,\n\t.send_init = vmci_transport_notify_pkt_send_init,\n\t.send_pre_block = vmci_transport_notify_pkt_send_pre_block,\n\t.send_pre_enqueue = vmci_transport_notify_pkt_send_pre_enqueue,\n\t.send_post_enqueue = vmci_transport_notify_pkt_send_post_enqueue,\n\t.process_request = vmci_transport_notify_pkt_process_request,\n\t.process_negotiate = vmci_transport_notify_pkt_process_negotiate,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}