{
  "module_name": "vsock_bpf.c",
  "hash_id": "d2f84ca1604e94ccc575e8a5fbba44ea855245a2cd112b494a6151ab2cf20286",
  "original_prompt": "Ingested from linux-6.6.14/net/vmw_vsock/vsock_bpf.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <linux/module.h>\n#include <linux/skmsg.h>\n#include <linux/socket.h>\n#include <linux/wait.h>\n#include <net/af_vsock.h>\n#include <net/sock.h>\n\n#define vsock_sk_has_data(__sk, __psock)\t\t\t\t\\\n\t\t({\t!skb_queue_empty(&(__sk)->sk_receive_queue) ||\t\\\n\t\t\t!skb_queue_empty(&(__psock)->ingress_skb) ||\t\\\n\t\t\t!list_empty(&(__psock)->ingress_msg);\t\t\\\n\t\t})\n\nstatic struct proto *vsock_prot_saved __read_mostly;\nstatic DEFINE_SPINLOCK(vsock_prot_lock);\nstatic struct proto vsock_bpf_prot;\n\nstatic bool vsock_has_data(struct sock *sk, struct sk_psock *psock)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\ts64 ret;\n\n\tret = vsock_connectible_has_data(vsk);\n\tif (ret > 0)\n\t\treturn true;\n\n\treturn vsock_sk_has_data(sk, psock);\n}\n\nstatic bool vsock_msg_wait_data(struct sock *sk, struct sk_psock *psock, long timeo)\n{\n\tbool ret;\n\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\treturn true;\n\n\tif (!timeo)\n\t\treturn false;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\tret = vsock_has_data(sk, psock);\n\tif (!ret) {\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\t\tret = vsock_has_data(sk, psock);\n\t}\n\tsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn ret;\n}\n\nstatic int __vsock_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int flags)\n{\n\tstruct socket *sock = sk->sk_socket;\n\tint err;\n\n\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET)\n\t\terr = vsock_connectible_recvmsg(sock, msg, len, flags);\n\telse if (sk->sk_type == SOCK_DGRAM)\n\t\terr = vsock_dgram_recvmsg(sock, msg, len, flags);\n\telse\n\t\terr = -EPROTOTYPE;\n\n\treturn err;\n}\n\nstatic int vsock_bpf_recvmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t     size_t len, int flags, int *addr_len)\n{\n\tstruct sk_psock *psock;\n\tint copied;\n\n\tpsock = sk_psock_get(sk);\n\tif (unlikely(!psock))\n\t\treturn __vsock_recvmsg(sk, msg, len, flags);\n\n\tlock_sock(sk);\n\tif (vsock_has_data(sk, psock) && sk_psock_queue_empty(psock)) {\n\t\trelease_sock(sk);\n\t\tsk_psock_put(sk, psock);\n\t\treturn __vsock_recvmsg(sk, msg, len, flags);\n\t}\n\n\tcopied = sk_msg_recvmsg(sk, psock, msg, len, flags);\n\twhile (copied == 0) {\n\t\tlong timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\t\tif (!vsock_msg_wait_data(sk, psock, timeo)) {\n\t\t\tcopied = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk_psock_queue_empty(psock)) {\n\t\t\trelease_sock(sk);\n\t\t\tsk_psock_put(sk, psock);\n\t\t\treturn __vsock_recvmsg(sk, msg, len, flags);\n\t\t}\n\n\t\tcopied = sk_msg_recvmsg(sk, psock, msg, len, flags);\n\t}\n\n\trelease_sock(sk);\n\tsk_psock_put(sk, psock);\n\n\treturn copied;\n}\n\n \nstatic struct proto vsock_bpf_prot = {\n\t.close = sock_map_close,\n\t.recvmsg = vsock_bpf_recvmsg,\n\t.sock_is_readable = sk_msg_is_readable,\n\t.unhash = sock_map_unhash,\n};\n\nstatic void vsock_bpf_rebuild_protos(struct proto *prot, const struct proto *base)\n{\n\t*prot        = *base;\n\tprot->close  = sock_map_close;\n\tprot->recvmsg = vsock_bpf_recvmsg;\n\tprot->sock_is_readable = sk_msg_is_readable;\n}\n\nstatic void vsock_bpf_check_needs_rebuild(struct proto *ops)\n{\n\t \n\tif (unlikely(ops != smp_load_acquire(&vsock_prot_saved))) {\n\t\tspin_lock_bh(&vsock_prot_lock);\n\t\tif (likely(ops != vsock_prot_saved)) {\n\t\t\tvsock_bpf_rebuild_protos(&vsock_bpf_prot, ops);\n\t\t\t \n\t\t\tsmp_store_release(&vsock_prot_saved, ops);\n\t\t}\n\t\tspin_unlock_bh(&vsock_prot_lock);\n\t}\n}\n\nint vsock_bpf_update_proto(struct sock *sk, struct sk_psock *psock, bool restore)\n{\n\tstruct vsock_sock *vsk;\n\n\tif (restore) {\n\t\tsk->sk_write_space = psock->saved_write_space;\n\t\tsock_replace_proto(sk, psock->sk_proto);\n\t\treturn 0;\n\t}\n\n\tvsk = vsock_sk(sk);\n\tif (!vsk->transport)\n\t\treturn -ENODEV;\n\n\tif (!vsk->transport->read_skb)\n\t\treturn -EOPNOTSUPP;\n\n\tvsock_bpf_check_needs_rebuild(psock->sk_proto);\n\tsock_replace_proto(sk, &vsock_bpf_prot);\n\treturn 0;\n}\n\nvoid __init vsock_bpf_build_proto(void)\n{\n\tvsock_bpf_rebuild_protos(&vsock_bpf_prot, &vsock_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}