{
  "module_name": "vmci_transport.c",
  "hash_id": "faa9092aad3c209ea59e3c846329e0fdfedaed3b8549396df063dda8848e6f50",
  "original_prompt": "Ingested from linux-6.6.14/net/vmw_vsock/vmci_transport.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/cred.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/net.h>\n#include <linux/poll.h>\n#include <linux/skbuff.h>\n#include <linux/smp.h>\n#include <linux/socket.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <net/sock.h>\n#include <net/af_vsock.h>\n\n#include \"vmci_transport_notify.h\"\n\nstatic int vmci_transport_recv_dgram_cb(void *data, struct vmci_datagram *dg);\nstatic int vmci_transport_recv_stream_cb(void *data, struct vmci_datagram *dg);\nstatic void vmci_transport_peer_detach_cb(u32 sub_id,\n\t\t\t\t\t  const struct vmci_event_data *ed,\n\t\t\t\t\t  void *client_data);\nstatic void vmci_transport_recv_pkt_work(struct work_struct *work);\nstatic void vmci_transport_cleanup(struct work_struct *work);\nstatic int vmci_transport_recv_listen(struct sock *sk,\n\t\t\t\t      struct vmci_transport_packet *pkt);\nstatic int vmci_transport_recv_connecting_server(\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tstruct sock *pending,\n\t\t\t\t\tstruct vmci_transport_packet *pkt);\nstatic int vmci_transport_recv_connecting_client(\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tstruct vmci_transport_packet *pkt);\nstatic int vmci_transport_recv_connecting_client_negotiate(\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tstruct vmci_transport_packet *pkt);\nstatic int vmci_transport_recv_connecting_client_invalid(\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tstruct vmci_transport_packet *pkt);\nstatic int vmci_transport_recv_connected(struct sock *sk,\n\t\t\t\t\t struct vmci_transport_packet *pkt);\nstatic bool vmci_transport_old_proto_override(bool *old_pkt_proto);\nstatic u16 vmci_transport_new_proto_supported_versions(void);\nstatic bool vmci_transport_proto_to_notify_struct(struct sock *sk, u16 *proto,\n\t\t\t\t\t\t  bool old_pkt_proto);\nstatic bool vmci_check_transport(struct vsock_sock *vsk);\n\nstruct vmci_transport_recv_pkt_info {\n\tstruct work_struct work;\n\tstruct sock *sk;\n\tstruct vmci_transport_packet pkt;\n};\n\nstatic LIST_HEAD(vmci_transport_cleanup_list);\nstatic DEFINE_SPINLOCK(vmci_transport_cleanup_lock);\nstatic DECLARE_WORK(vmci_transport_cleanup_work, vmci_transport_cleanup);\n\nstatic struct vmci_handle vmci_transport_stream_handle = { VMCI_INVALID_ID,\n\t\t\t\t\t\t\t   VMCI_INVALID_ID };\nstatic u32 vmci_transport_qp_resumed_sub_id = VMCI_INVALID_ID;\n\nstatic int PROTOCOL_OVERRIDE = -1;\n\nstatic struct vsock_transport vmci_transport;  \n\n \n\nstatic s32 vmci_transport_error_to_vsock_error(s32 vmci_error)\n{\n\tswitch (vmci_error) {\n\tcase VMCI_ERROR_NO_MEM:\n\t\treturn -ENOMEM;\n\tcase VMCI_ERROR_DUPLICATE_ENTRY:\n\tcase VMCI_ERROR_ALREADY_EXISTS:\n\t\treturn -EADDRINUSE;\n\tcase VMCI_ERROR_NO_ACCESS:\n\t\treturn -EPERM;\n\tcase VMCI_ERROR_NO_RESOURCES:\n\t\treturn -ENOBUFS;\n\tcase VMCI_ERROR_INVALID_RESOURCE:\n\t\treturn -EHOSTUNREACH;\n\tcase VMCI_ERROR_INVALID_ARGS:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic u32 vmci_transport_peer_rid(u32 peer_cid)\n{\n\tif (VMADDR_CID_HYPERVISOR == peer_cid)\n\t\treturn VMCI_TRANSPORT_HYPERVISOR_PACKET_RID;\n\n\treturn VMCI_TRANSPORT_PACKET_RID;\n}\n\nstatic inline void\nvmci_transport_packet_init(struct vmci_transport_packet *pkt,\n\t\t\t   struct sockaddr_vm *src,\n\t\t\t   struct sockaddr_vm *dst,\n\t\t\t   u8 type,\n\t\t\t   u64 size,\n\t\t\t   u64 mode,\n\t\t\t   struct vmci_transport_waiting_info *wait,\n\t\t\t   u16 proto,\n\t\t\t   struct vmci_handle handle)\n{\n\t \n\tpkt->dg.src = vmci_make_handle(VMADDR_CID_ANY,\n\t\t\t\t       VMCI_TRANSPORT_PACKET_RID);\n\tpkt->dg.dst = vmci_make_handle(dst->svm_cid,\n\t\t\t\t       vmci_transport_peer_rid(dst->svm_cid));\n\tpkt->dg.payload_size = sizeof(*pkt) - sizeof(pkt->dg);\n\tpkt->version = VMCI_TRANSPORT_PACKET_VERSION;\n\tpkt->type = type;\n\tpkt->src_port = src->svm_port;\n\tpkt->dst_port = dst->svm_port;\n\tmemset(&pkt->proto, 0, sizeof(pkt->proto));\n\tmemset(&pkt->_reserved2, 0, sizeof(pkt->_reserved2));\n\n\tswitch (pkt->type) {\n\tcase VMCI_TRANSPORT_PACKET_TYPE_INVALID:\n\t\tpkt->u.size = 0;\n\t\tbreak;\n\n\tcase VMCI_TRANSPORT_PACKET_TYPE_REQUEST:\n\tcase VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE:\n\t\tpkt->u.size = size;\n\t\tbreak;\n\n\tcase VMCI_TRANSPORT_PACKET_TYPE_OFFER:\n\tcase VMCI_TRANSPORT_PACKET_TYPE_ATTACH:\n\t\tpkt->u.handle = handle;\n\t\tbreak;\n\n\tcase VMCI_TRANSPORT_PACKET_TYPE_WROTE:\n\tcase VMCI_TRANSPORT_PACKET_TYPE_READ:\n\tcase VMCI_TRANSPORT_PACKET_TYPE_RST:\n\t\tpkt->u.size = 0;\n\t\tbreak;\n\n\tcase VMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN:\n\t\tpkt->u.mode = mode;\n\t\tbreak;\n\n\tcase VMCI_TRANSPORT_PACKET_TYPE_WAITING_READ:\n\tcase VMCI_TRANSPORT_PACKET_TYPE_WAITING_WRITE:\n\t\tmemcpy(&pkt->u.wait, wait, sizeof(pkt->u.wait));\n\t\tbreak;\n\n\tcase VMCI_TRANSPORT_PACKET_TYPE_REQUEST2:\n\tcase VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2:\n\t\tpkt->u.size = size;\n\t\tpkt->proto = proto;\n\t\tbreak;\n\t}\n}\n\nstatic inline void\nvmci_transport_packet_get_addresses(struct vmci_transport_packet *pkt,\n\t\t\t\t    struct sockaddr_vm *local,\n\t\t\t\t    struct sockaddr_vm *remote)\n{\n\tvsock_addr_init(local, pkt->dg.dst.context, pkt->dst_port);\n\tvsock_addr_init(remote, pkt->dg.src.context, pkt->src_port);\n}\n\nstatic int\n__vmci_transport_send_control_pkt(struct vmci_transport_packet *pkt,\n\t\t\t\t  struct sockaddr_vm *src,\n\t\t\t\t  struct sockaddr_vm *dst,\n\t\t\t\t  enum vmci_transport_packet_type type,\n\t\t\t\t  u64 size,\n\t\t\t\t  u64 mode,\n\t\t\t\t  struct vmci_transport_waiting_info *wait,\n\t\t\t\t  u16 proto,\n\t\t\t\t  struct vmci_handle handle,\n\t\t\t\t  bool convert_error)\n{\n\tint err;\n\n\tvmci_transport_packet_init(pkt, src, dst, type, size, mode, wait,\n\t\t\t\t   proto, handle);\n\terr = vmci_datagram_send(&pkt->dg);\n\tif (convert_error && (err < 0))\n\t\treturn vmci_transport_error_to_vsock_error(err);\n\n\treturn err;\n}\n\nstatic int\nvmci_transport_reply_control_pkt_fast(struct vmci_transport_packet *pkt,\n\t\t\t\t      enum vmci_transport_packet_type type,\n\t\t\t\t      u64 size,\n\t\t\t\t      u64 mode,\n\t\t\t\t      struct vmci_transport_waiting_info *wait,\n\t\t\t\t      struct vmci_handle handle)\n{\n\tstruct vmci_transport_packet reply;\n\tstruct sockaddr_vm src, dst;\n\n\tif (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST) {\n\t\treturn 0;\n\t} else {\n\t\tvmci_transport_packet_get_addresses(pkt, &src, &dst);\n\t\treturn __vmci_transport_send_control_pkt(&reply, &src, &dst,\n\t\t\t\t\t\t\t type,\n\t\t\t\t\t\t\t size, mode, wait,\n\t\t\t\t\t\t\t VSOCK_PROTO_INVALID,\n\t\t\t\t\t\t\t handle, true);\n\t}\n}\n\nstatic int\nvmci_transport_send_control_pkt_bh(struct sockaddr_vm *src,\n\t\t\t\t   struct sockaddr_vm *dst,\n\t\t\t\t   enum vmci_transport_packet_type type,\n\t\t\t\t   u64 size,\n\t\t\t\t   u64 mode,\n\t\t\t\t   struct vmci_transport_waiting_info *wait,\n\t\t\t\t   struct vmci_handle handle)\n{\n\t \n\tstatic struct vmci_transport_packet pkt;\n\n\treturn __vmci_transport_send_control_pkt(&pkt, src, dst, type,\n\t\t\t\t\t\t size, mode, wait,\n\t\t\t\t\t\t VSOCK_PROTO_INVALID, handle,\n\t\t\t\t\t\t false);\n}\n\nstatic int\nvmci_transport_alloc_send_control_pkt(struct sockaddr_vm *src,\n\t\t\t\t      struct sockaddr_vm *dst,\n\t\t\t\t      enum vmci_transport_packet_type type,\n\t\t\t\t      u64 size,\n\t\t\t\t      u64 mode,\n\t\t\t\t      struct vmci_transport_waiting_info *wait,\n\t\t\t\t      u16 proto,\n\t\t\t\t      struct vmci_handle handle)\n{\n\tstruct vmci_transport_packet *pkt;\n\tint err;\n\n\tpkt = kmalloc(sizeof(*pkt), GFP_KERNEL);\n\tif (!pkt)\n\t\treturn -ENOMEM;\n\n\terr = __vmci_transport_send_control_pkt(pkt, src, dst, type, size,\n\t\t\t\t\t\tmode, wait, proto, handle,\n\t\t\t\t\t\ttrue);\n\tkfree(pkt);\n\n\treturn err;\n}\n\nstatic int\nvmci_transport_send_control_pkt(struct sock *sk,\n\t\t\t\tenum vmci_transport_packet_type type,\n\t\t\t\tu64 size,\n\t\t\t\tu64 mode,\n\t\t\t\tstruct vmci_transport_waiting_info *wait,\n\t\t\t\tu16 proto,\n\t\t\t\tstruct vmci_handle handle)\n{\n\tstruct vsock_sock *vsk;\n\n\tvsk = vsock_sk(sk);\n\n\tif (!vsock_addr_bound(&vsk->local_addr))\n\t\treturn -EINVAL;\n\n\tif (!vsock_addr_bound(&vsk->remote_addr))\n\t\treturn -EINVAL;\n\n\treturn vmci_transport_alloc_send_control_pkt(&vsk->local_addr,\n\t\t\t\t\t\t     &vsk->remote_addr,\n\t\t\t\t\t\t     type, size, mode,\n\t\t\t\t\t\t     wait, proto, handle);\n}\n\nstatic int vmci_transport_send_reset_bh(struct sockaddr_vm *dst,\n\t\t\t\t\tstruct sockaddr_vm *src,\n\t\t\t\t\tstruct vmci_transport_packet *pkt)\n{\n\tif (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST)\n\t\treturn 0;\n\treturn vmci_transport_send_control_pkt_bh(\n\t\t\t\t\tdst, src,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_RST, 0,\n\t\t\t\t\t0, NULL, VMCI_INVALID_HANDLE);\n}\n\nstatic int vmci_transport_send_reset(struct sock *sk,\n\t\t\t\t     struct vmci_transport_packet *pkt)\n{\n\tstruct sockaddr_vm *dst_ptr;\n\tstruct sockaddr_vm dst;\n\tstruct vsock_sock *vsk;\n\n\tif (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST)\n\t\treturn 0;\n\n\tvsk = vsock_sk(sk);\n\n\tif (!vsock_addr_bound(&vsk->local_addr))\n\t\treturn -EINVAL;\n\n\tif (vsock_addr_bound(&vsk->remote_addr)) {\n\t\tdst_ptr = &vsk->remote_addr;\n\t} else {\n\t\tvsock_addr_init(&dst, pkt->dg.src.context,\n\t\t\t\tpkt->src_port);\n\t\tdst_ptr = &dst;\n\t}\n\treturn vmci_transport_alloc_send_control_pkt(&vsk->local_addr, dst_ptr,\n\t\t\t\t\t     VMCI_TRANSPORT_PACKET_TYPE_RST,\n\t\t\t\t\t     0, 0, NULL, VSOCK_PROTO_INVALID,\n\t\t\t\t\t     VMCI_INVALID_HANDLE);\n}\n\nstatic int vmci_transport_send_negotiate(struct sock *sk, size_t size)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\tsk,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE,\n\t\t\t\t\tsize, 0, NULL,\n\t\t\t\t\tVSOCK_PROTO_INVALID,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}\n\nstatic int vmci_transport_send_negotiate2(struct sock *sk, size_t size,\n\t\t\t\t\t  u16 version)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\tsk,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2,\n\t\t\t\t\tsize, 0, NULL, version,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}\n\nstatic int vmci_transport_send_qp_offer(struct sock *sk,\n\t\t\t\t\tstruct vmci_handle handle)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\tsk, VMCI_TRANSPORT_PACKET_TYPE_OFFER, 0,\n\t\t\t\t\t0, NULL,\n\t\t\t\t\tVSOCK_PROTO_INVALID, handle);\n}\n\nstatic int vmci_transport_send_attach(struct sock *sk,\n\t\t\t\t      struct vmci_handle handle)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\tsk, VMCI_TRANSPORT_PACKET_TYPE_ATTACH,\n\t\t\t\t\t0, 0, NULL, VSOCK_PROTO_INVALID,\n\t\t\t\t\thandle);\n}\n\nstatic int vmci_transport_reply_reset(struct vmci_transport_packet *pkt)\n{\n\treturn vmci_transport_reply_control_pkt_fast(\n\t\t\t\t\t\tpkt,\n\t\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_RST,\n\t\t\t\t\t\t0, 0, NULL,\n\t\t\t\t\t\tVMCI_INVALID_HANDLE);\n}\n\nstatic int vmci_transport_send_invalid_bh(struct sockaddr_vm *dst,\n\t\t\t\t\t  struct sockaddr_vm *src)\n{\n\treturn vmci_transport_send_control_pkt_bh(\n\t\t\t\t\tdst, src,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_INVALID,\n\t\t\t\t\t0, 0, NULL, VMCI_INVALID_HANDLE);\n}\n\nint vmci_transport_send_wrote_bh(struct sockaddr_vm *dst,\n\t\t\t\t struct sockaddr_vm *src)\n{\n\treturn vmci_transport_send_control_pkt_bh(\n\t\t\t\t\tdst, src,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_WROTE, 0,\n\t\t\t\t\t0, NULL, VMCI_INVALID_HANDLE);\n}\n\nint vmci_transport_send_read_bh(struct sockaddr_vm *dst,\n\t\t\t\tstruct sockaddr_vm *src)\n{\n\treturn vmci_transport_send_control_pkt_bh(\n\t\t\t\t\tdst, src,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_READ, 0,\n\t\t\t\t\t0, NULL, VMCI_INVALID_HANDLE);\n}\n\nint vmci_transport_send_wrote(struct sock *sk)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\tsk, VMCI_TRANSPORT_PACKET_TYPE_WROTE, 0,\n\t\t\t\t\t0, NULL, VSOCK_PROTO_INVALID,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}\n\nint vmci_transport_send_read(struct sock *sk)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\tsk, VMCI_TRANSPORT_PACKET_TYPE_READ, 0,\n\t\t\t\t\t0, NULL, VSOCK_PROTO_INVALID,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}\n\nint vmci_transport_send_waiting_write(struct sock *sk,\n\t\t\t\t      struct vmci_transport_waiting_info *wait)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\tsk, VMCI_TRANSPORT_PACKET_TYPE_WAITING_WRITE,\n\t\t\t\t0, 0, wait, VSOCK_PROTO_INVALID,\n\t\t\t\tVMCI_INVALID_HANDLE);\n}\n\nint vmci_transport_send_waiting_read(struct sock *sk,\n\t\t\t\t     struct vmci_transport_waiting_info *wait)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\tsk, VMCI_TRANSPORT_PACKET_TYPE_WAITING_READ,\n\t\t\t\t0, 0, wait, VSOCK_PROTO_INVALID,\n\t\t\t\tVMCI_INVALID_HANDLE);\n}\n\nstatic int vmci_transport_shutdown(struct vsock_sock *vsk, int mode)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\t&vsk->sk,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN,\n\t\t\t\t\t0, mode, NULL,\n\t\t\t\t\tVSOCK_PROTO_INVALID,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}\n\nstatic int vmci_transport_send_conn_request(struct sock *sk, size_t size)\n{\n\treturn vmci_transport_send_control_pkt(sk,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_REQUEST,\n\t\t\t\t\tsize, 0, NULL,\n\t\t\t\t\tVSOCK_PROTO_INVALID,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}\n\nstatic int vmci_transport_send_conn_request2(struct sock *sk, size_t size,\n\t\t\t\t\t     u16 version)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\tsk, VMCI_TRANSPORT_PACKET_TYPE_REQUEST2,\n\t\t\t\t\tsize, 0, NULL, version,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}\n\nstatic struct sock *vmci_transport_get_pending(\n\t\t\t\t\tstruct sock *listener,\n\t\t\t\t\tstruct vmci_transport_packet *pkt)\n{\n\tstruct vsock_sock *vlistener;\n\tstruct vsock_sock *vpending;\n\tstruct sock *pending;\n\tstruct sockaddr_vm src;\n\n\tvsock_addr_init(&src, pkt->dg.src.context, pkt->src_port);\n\n\tvlistener = vsock_sk(listener);\n\n\tlist_for_each_entry(vpending, &vlistener->pending_links,\n\t\t\t    pending_links) {\n\t\tif (vsock_addr_equals_addr(&src, &vpending->remote_addr) &&\n\t\t    pkt->dst_port == vpending->local_addr.svm_port) {\n\t\t\tpending = sk_vsock(vpending);\n\t\t\tsock_hold(pending);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tpending = NULL;\nfound:\n\treturn pending;\n\n}\n\nstatic void vmci_transport_release_pending(struct sock *pending)\n{\n\tsock_put(pending);\n}\n\n \n\nstatic bool vmci_transport_is_trusted(struct vsock_sock *vsock, u32 peer_cid)\n{\n\treturn vsock->trusted ||\n\t       vmci_is_context_owner(peer_cid, vsock->owner->uid);\n}\n\n \n\nstatic bool vmci_transport_allow_dgram(struct vsock_sock *vsock, u32 peer_cid)\n{\n\tif (VMADDR_CID_HYPERVISOR == peer_cid)\n\t\treturn true;\n\n\tif (vsock->cached_peer != peer_cid) {\n\t\tvsock->cached_peer = peer_cid;\n\t\tif (!vmci_transport_is_trusted(vsock, peer_cid) &&\n\t\t    (vmci_context_get_priv_flags(peer_cid) &\n\t\t     VMCI_PRIVILEGE_FLAG_RESTRICTED)) {\n\t\t\tvsock->cached_peer_allow_dgram = false;\n\t\t} else {\n\t\t\tvsock->cached_peer_allow_dgram = true;\n\t\t}\n\t}\n\n\treturn vsock->cached_peer_allow_dgram;\n}\n\nstatic int\nvmci_transport_queue_pair_alloc(struct vmci_qp **qpair,\n\t\t\t\tstruct vmci_handle *handle,\n\t\t\t\tu64 produce_size,\n\t\t\t\tu64 consume_size,\n\t\t\t\tu32 peer, u32 flags, bool trusted)\n{\n\tint err = 0;\n\n\tif (trusted) {\n\t\t \n\n\t\terr = vmci_qpair_alloc(qpair, handle, produce_size,\n\t\t\t\t       consume_size,\n\t\t\t\t       peer, flags,\n\t\t\t\t       VMCI_PRIVILEGE_FLAG_TRUSTED);\n\t\tif (err != VMCI_ERROR_NO_ACCESS)\n\t\t\tgoto out;\n\n\t}\n\n\terr = vmci_qpair_alloc(qpair, handle, produce_size, consume_size,\n\t\t\t       peer, flags, VMCI_NO_PRIVILEGE_FLAGS);\nout:\n\tif (err < 0) {\n\t\tpr_err_once(\"Could not attach to queue pair with %d\\n\", err);\n\t\terr = vmci_transport_error_to_vsock_error(err);\n\t}\n\n\treturn err;\n}\n\nstatic int\nvmci_transport_datagram_create_hnd(u32 resource_id,\n\t\t\t\t   u32 flags,\n\t\t\t\t   vmci_datagram_recv_cb recv_cb,\n\t\t\t\t   void *client_data,\n\t\t\t\t   struct vmci_handle *out_handle)\n{\n\tint err = 0;\n\n\t \n\n\terr = vmci_datagram_create_handle_priv(resource_id, flags,\n\t\t\t\t\t       VMCI_PRIVILEGE_FLAG_TRUSTED,\n\t\t\t\t\t       recv_cb,\n\t\t\t\t\t       client_data, out_handle);\n\n\tif (err == VMCI_ERROR_NO_ACCESS)\n\t\terr = vmci_datagram_create_handle(resource_id, flags,\n\t\t\t\t\t\t  recv_cb, client_data,\n\t\t\t\t\t\t  out_handle);\n\n\treturn err;\n}\n\n \n\nstatic int vmci_transport_recv_dgram_cb(void *data, struct vmci_datagram *dg)\n{\n\tstruct sock *sk;\n\tsize_t size;\n\tstruct sk_buff *skb;\n\tstruct vsock_sock *vsk;\n\n\tsk = (struct sock *)data;\n\n\t \n\tvsk = vsock_sk(sk);\n\tif (!vmci_transport_allow_dgram(vsk, dg->src.context))\n\t\treturn VMCI_ERROR_NO_ACCESS;\n\n\tsize = VMCI_DG_SIZE(dg);\n\n\t \n\tskb = alloc_skb(size, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn VMCI_ERROR_NO_MEM;\n\n\t \n\tsock_hold(sk);\n\tskb_put(skb, size);\n\tmemcpy(skb->data, dg, size);\n\tsk_receive_skb(sk, skb, 0);\n\n\treturn VMCI_SUCCESS;\n}\n\nstatic bool vmci_transport_stream_allow(u32 cid, u32 port)\n{\n\tstatic const u32 non_socket_contexts[] = {\n\t\tVMADDR_CID_LOCAL,\n\t};\n\tint i;\n\n\tBUILD_BUG_ON(sizeof(cid) != sizeof(*non_socket_contexts));\n\n\tfor (i = 0; i < ARRAY_SIZE(non_socket_contexts); i++) {\n\t\tif (cid == non_socket_contexts[i])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \n\nstatic int vmci_transport_recv_stream_cb(void *data, struct vmci_datagram *dg)\n{\n\tstruct sock *sk;\n\tstruct sockaddr_vm dst;\n\tstruct sockaddr_vm src;\n\tstruct vmci_transport_packet *pkt;\n\tstruct vsock_sock *vsk;\n\tbool bh_process_pkt;\n\tint err;\n\n\tsk = NULL;\n\terr = VMCI_SUCCESS;\n\tbh_process_pkt = false;\n\n\t \n\n\tif (!vmci_transport_stream_allow(dg->src.context, -1)\n\t    || vmci_transport_peer_rid(dg->src.context) != dg->src.resource)\n\t\treturn VMCI_ERROR_NO_ACCESS;\n\n\tif (VMCI_DG_SIZE(dg) < sizeof(*pkt))\n\t\t \n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tpkt = (struct vmci_transport_packet *)dg;\n\n\t \n\tvsock_addr_init(&src, pkt->dg.src.context, pkt->src_port);\n\tvsock_addr_init(&dst, pkt->dg.dst.context, pkt->dst_port);\n\n\tsk = vsock_find_connected_socket(&src, &dst);\n\tif (!sk) {\n\t\tsk = vsock_find_bound_socket(&dst);\n\t\tif (!sk) {\n\t\t\t \n\t\t\tif (vmci_transport_send_reset_bh(&dst, &src, pkt) < 0)\n\t\t\t\tpr_err(\"unable to send reset\\n\");\n\n\t\t\terr = VMCI_ERROR_NOT_FOUND;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (pkt->type >= VMCI_TRANSPORT_PACKET_TYPE_MAX) {\n\t\tvmci_transport_send_invalid_bh(&dst, &src);\n\t\terr = VMCI_ERROR_INVALID_ARGS;\n\t\tgoto out;\n\t}\n\n\t \n\tvsk = vsock_sk(sk);\n\tif (!vmci_transport_allow_dgram(vsk, pkt->dg.src.context)) {\n\t\terr = VMCI_ERROR_NO_ACCESS;\n\t\tgoto out;\n\t}\n\n\t \n\tbh_lock_sock(sk);\n\n\tif (!sock_owned_by_user(sk)) {\n\t\t \n\t\tvsk->local_addr.svm_cid = dst.svm_cid;\n\n\t\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\t\tvmci_trans(vsk)->notify_ops->handle_notify_pkt(\n\t\t\t\t\tsk, pkt, true, &dst, &src,\n\t\t\t\t\t&bh_process_pkt);\n\t}\n\n\tbh_unlock_sock(sk);\n\n\tif (!bh_process_pkt) {\n\t\tstruct vmci_transport_recv_pkt_info *recv_pkt_info;\n\n\t\trecv_pkt_info = kmalloc(sizeof(*recv_pkt_info), GFP_ATOMIC);\n\t\tif (!recv_pkt_info) {\n\t\t\tif (vmci_transport_send_reset_bh(&dst, &src, pkt) < 0)\n\t\t\t\tpr_err(\"unable to send reset\\n\");\n\n\t\t\terr = VMCI_ERROR_NO_MEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trecv_pkt_info->sk = sk;\n\t\tmemcpy(&recv_pkt_info->pkt, pkt, sizeof(recv_pkt_info->pkt));\n\t\tINIT_WORK(&recv_pkt_info->work, vmci_transport_recv_pkt_work);\n\n\t\tschedule_work(&recv_pkt_info->work);\n\t\t \n\t\tsk = NULL;\n\t}\n\nout:\n\tif (sk)\n\t\tsock_put(sk);\n\n\treturn err;\n}\n\nstatic void vmci_transport_handle_detach(struct sock *sk)\n{\n\tstruct vsock_sock *vsk;\n\n\tvsk = vsock_sk(sk);\n\tif (!vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle)) {\n\t\tsock_set_flag(sk, SOCK_DONE);\n\n\t\t \n\t\tvsk->peer_shutdown = SHUTDOWN_MASK;\n\n\t\t \n\t\tif (vsk->local_addr.svm_cid == VMADDR_CID_HOST ||\n\t\t    vsock_stream_has_data(vsk) <= 0) {\n\t\t\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\t\t\t \n\n\t\t\t\tsk->sk_state = TCP_CLOSE;\n\t\t\t\tsk->sk_err = ECONNRESET;\n\t\t\t\tsk_error_report(sk);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsk->sk_state = TCP_CLOSE;\n\t\t}\n\t\tsk->sk_state_change(sk);\n\t}\n}\n\nstatic void vmci_transport_peer_detach_cb(u32 sub_id,\n\t\t\t\t\t  const struct vmci_event_data *e_data,\n\t\t\t\t\t  void *client_data)\n{\n\tstruct vmci_transport *trans = client_data;\n\tconst struct vmci_event_payload_qp *e_payload;\n\n\te_payload = vmci_event_data_const_payload(e_data);\n\n\t \n\tif (vmci_handle_is_invalid(e_payload->handle) ||\n\t    !vmci_handle_is_equal(trans->qp_handle, e_payload->handle))\n\t\treturn;\n\n\t \n\tspin_lock_bh(&trans->lock);\n\tif (!trans->sk)\n\t\tgoto out;\n\n\t \n\tbh_lock_sock(trans->sk);\n\n\tvmci_transport_handle_detach(trans->sk);\n\n\tbh_unlock_sock(trans->sk);\n out:\n\tspin_unlock_bh(&trans->lock);\n}\n\nstatic void vmci_transport_qp_resumed_cb(u32 sub_id,\n\t\t\t\t\t const struct vmci_event_data *e_data,\n\t\t\t\t\t void *client_data)\n{\n\tvsock_for_each_connected_socket(&vmci_transport,\n\t\t\t\t\tvmci_transport_handle_detach);\n}\n\nstatic void vmci_transport_recv_pkt_work(struct work_struct *work)\n{\n\tstruct vmci_transport_recv_pkt_info *recv_pkt_info;\n\tstruct vmci_transport_packet *pkt;\n\tstruct sock *sk;\n\n\trecv_pkt_info =\n\t\tcontainer_of(work, struct vmci_transport_recv_pkt_info, work);\n\tsk = recv_pkt_info->sk;\n\tpkt = &recv_pkt_info->pkt;\n\n\tlock_sock(sk);\n\n\t \n\tvsock_sk(sk)->local_addr.svm_cid = pkt->dg.dst.context;\n\n\tswitch (sk->sk_state) {\n\tcase TCP_LISTEN:\n\t\tvmci_transport_recv_listen(sk, pkt);\n\t\tbreak;\n\tcase TCP_SYN_SENT:\n\t\t \n\t\tvmci_transport_recv_connecting_client(sk, pkt);\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\t\tvmci_transport_recv_connected(sk, pkt);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tvmci_transport_send_reset(sk, pkt);\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\tkfree(recv_pkt_info);\n\t \n\tsock_put(sk);\n}\n\nstatic int vmci_transport_recv_listen(struct sock *sk,\n\t\t\t\t      struct vmci_transport_packet *pkt)\n{\n\tstruct sock *pending;\n\tstruct vsock_sock *vpending;\n\tint err;\n\tu64 qp_size;\n\tbool old_request = false;\n\tbool old_pkt_proto = false;\n\n\t \n\tpending = vmci_transport_get_pending(sk, pkt);\n\tif (pending) {\n\t\tlock_sock(pending);\n\n\t\t \n\t\tvsock_sk(pending)->local_addr.svm_cid = pkt->dg.dst.context;\n\n\t\tswitch (pending->sk_state) {\n\t\tcase TCP_SYN_SENT:\n\t\t\terr = vmci_transport_recv_connecting_server(sk,\n\t\t\t\t\t\t\t\t    pending,\n\t\t\t\t\t\t\t\t    pkt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvmci_transport_send_reset(pending, pkt);\n\t\t\terr = -EINVAL;\n\t\t}\n\n\t\tif (err < 0)\n\t\t\tvsock_remove_pending(sk, pending);\n\n\t\trelease_sock(pending);\n\t\tvmci_transport_release_pending(pending);\n\n\t\treturn err;\n\t}\n\n\t \n\n\tif (!(pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST ||\n\t      pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST2)) {\n\t\tvmci_transport_reply_reset(pkt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pkt->u.size == 0) {\n\t\tvmci_transport_reply_reset(pkt);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (sk->sk_ack_backlog >= sk->sk_max_ack_backlog) {\n\t\tvmci_transport_reply_reset(pkt);\n\t\treturn -ECONNREFUSED;\n\t}\n\n\tpending = vsock_create_connected(sk);\n\tif (!pending) {\n\t\tvmci_transport_send_reset(sk, pkt);\n\t\treturn -ENOMEM;\n\t}\n\n\tvpending = vsock_sk(pending);\n\n\tvsock_addr_init(&vpending->local_addr, pkt->dg.dst.context,\n\t\t\tpkt->dst_port);\n\tvsock_addr_init(&vpending->remote_addr, pkt->dg.src.context,\n\t\t\tpkt->src_port);\n\n\terr = vsock_assign_transport(vpending, vsock_sk(sk));\n\t \n\tif (err || !vmci_check_transport(vpending)) {\n\t\tvmci_transport_send_reset(sk, pkt);\n\t\tsock_put(pending);\n\t\treturn err;\n\t}\n\n\t \n\tif (pkt->u.size >= vpending->buffer_min_size &&\n\t    pkt->u.size <= vpending->buffer_max_size) {\n\t\tqp_size = pkt->u.size;\n\t} else {\n\t\tqp_size = vpending->buffer_size;\n\t}\n\n\t \n\tif (vmci_transport_old_proto_override(&old_pkt_proto)) {\n\t\told_request = old_pkt_proto;\n\t} else {\n\t\tif (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST)\n\t\t\told_request = true;\n\t\telse if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST2)\n\t\t\told_request = false;\n\n\t}\n\n\tif (old_request) {\n\t\t \n\t\tu16 version = VSOCK_PROTO_INVALID;\n\t\tif (vmci_transport_proto_to_notify_struct(\n\t\t\tpending, &version, true))\n\t\t\terr = vmci_transport_send_negotiate(pending, qp_size);\n\t\telse\n\t\t\terr = -EINVAL;\n\n\t} else {\n\t\t \n\t\tint proto_int = pkt->proto;\n\t\tint pos;\n\t\tu16 active_proto_version = 0;\n\n\t\t \n\t\tproto_int &= vmci_transport_new_proto_supported_versions();\n\n\t\t \n\t\tpos = fls(proto_int);\n\t\tif (pos) {\n\t\t\tactive_proto_version = (1 << (pos - 1));\n\t\t\tif (vmci_transport_proto_to_notify_struct(\n\t\t\t\tpending, &active_proto_version, false))\n\t\t\t\terr = vmci_transport_send_negotiate2(pending,\n\t\t\t\t\t\t\tqp_size,\n\t\t\t\t\t\t\tactive_proto_version);\n\t\t\telse\n\t\t\t\terr = -EINVAL;\n\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tif (err < 0) {\n\t\tvmci_transport_send_reset(sk, pkt);\n\t\tsock_put(pending);\n\t\terr = vmci_transport_error_to_vsock_error(err);\n\t\tgoto out;\n\t}\n\n\tvsock_add_pending(sk, pending);\n\tsk_acceptq_added(sk);\n\n\tpending->sk_state = TCP_SYN_SENT;\n\tvmci_trans(vpending)->produce_size =\n\t\tvmci_trans(vpending)->consume_size = qp_size;\n\tvpending->buffer_size = qp_size;\n\n\tvmci_trans(vpending)->notify_ops->process_request(pending);\n\n\t \n\tvpending->listener = sk;\n\tsock_hold(sk);\n\tsock_hold(pending);\n\tschedule_delayed_work(&vpending->pending_work, HZ);\n\nout:\n\treturn err;\n}\n\nstatic int\nvmci_transport_recv_connecting_server(struct sock *listener,\n\t\t\t\t      struct sock *pending,\n\t\t\t\t      struct vmci_transport_packet *pkt)\n{\n\tstruct vsock_sock *vpending;\n\tstruct vmci_handle handle;\n\tstruct vmci_qp *qpair;\n\tbool is_local;\n\tu32 flags;\n\tu32 detach_sub_id;\n\tint err;\n\tint skerr;\n\n\tvpending = vsock_sk(pending);\n\tdetach_sub_id = VMCI_INVALID_ID;\n\n\tswitch (pkt->type) {\n\tcase VMCI_TRANSPORT_PACKET_TYPE_OFFER:\n\t\tif (vmci_handle_is_invalid(pkt->u.handle)) {\n\t\t\tvmci_transport_send_reset(pending, pkt);\n\t\t\tskerr = EPROTO;\n\t\t\terr = -EINVAL;\n\t\t\tgoto destroy;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tvmci_transport_send_reset(pending, pkt);\n\t\tskerr = EPROTO;\n\t\terr = pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST ? 0 : -EINVAL;\n\t\tgoto destroy;\n\t}\n\n\t \n\n\t \n\terr = vmci_event_subscribe(VMCI_EVENT_QP_PEER_DETACH,\n\t\t\t\t   vmci_transport_peer_detach_cb,\n\t\t\t\t   vmci_trans(vpending), &detach_sub_id);\n\tif (err < VMCI_SUCCESS) {\n\t\tvmci_transport_send_reset(pending, pkt);\n\t\terr = vmci_transport_error_to_vsock_error(err);\n\t\tskerr = -err;\n\t\tgoto destroy;\n\t}\n\n\tvmci_trans(vpending)->detach_sub_id = detach_sub_id;\n\n\t \n\thandle = pkt->u.handle;\n\n\t \n\tis_local =\n\t    vpending->remote_addr.svm_cid == vpending->local_addr.svm_cid;\n\tflags = VMCI_QPFLAG_ATTACH_ONLY;\n\tflags |= is_local ? VMCI_QPFLAG_LOCAL : 0;\n\n\terr = vmci_transport_queue_pair_alloc(\n\t\t\t\t\t&qpair,\n\t\t\t\t\t&handle,\n\t\t\t\t\tvmci_trans(vpending)->produce_size,\n\t\t\t\t\tvmci_trans(vpending)->consume_size,\n\t\t\t\t\tpkt->dg.src.context,\n\t\t\t\t\tflags,\n\t\t\t\t\tvmci_transport_is_trusted(\n\t\t\t\t\t\tvpending,\n\t\t\t\t\t\tvpending->remote_addr.svm_cid));\n\tif (err < 0) {\n\t\tvmci_transport_send_reset(pending, pkt);\n\t\tskerr = -err;\n\t\tgoto destroy;\n\t}\n\n\tvmci_trans(vpending)->qp_handle = handle;\n\tvmci_trans(vpending)->qpair = qpair;\n\n\t \n\tpending->sk_state = TCP_ESTABLISHED;\n\n\tvsock_insert_connected(vpending);\n\n\t \n\terr = vmci_transport_send_attach(pending, handle);\n\tif (err < 0) {\n\t\tvsock_remove_connected(vpending);\n\t\tpr_err(\"Could not send attach\\n\");\n\t\tvmci_transport_send_reset(pending, pkt);\n\t\terr = vmci_transport_error_to_vsock_error(err);\n\t\tskerr = -err;\n\t\tgoto destroy;\n\t}\n\n\t \n\tvsock_remove_pending(listener, pending);\n\tvsock_enqueue_accept(listener, pending);\n\n\t \n\tlistener->sk_data_ready(listener);\n\n\treturn 0;\n\ndestroy:\n\tpending->sk_err = skerr;\n\tpending->sk_state = TCP_CLOSE;\n\t \n\tsock_put(pending);\n\n\treturn err;\n}\n\nstatic int\nvmci_transport_recv_connecting_client(struct sock *sk,\n\t\t\t\t      struct vmci_transport_packet *pkt)\n{\n\tstruct vsock_sock *vsk;\n\tint err;\n\tint skerr;\n\n\tvsk = vsock_sk(sk);\n\n\tswitch (pkt->type) {\n\tcase VMCI_TRANSPORT_PACKET_TYPE_ATTACH:\n\t\tif (vmci_handle_is_invalid(pkt->u.handle) ||\n\t\t    !vmci_handle_is_equal(pkt->u.handle,\n\t\t\t\t\t  vmci_trans(vsk)->qp_handle)) {\n\t\t\tskerr = EPROTO;\n\t\t\terr = -EINVAL;\n\t\t\tgoto destroy;\n\t\t}\n\n\t\t \n\t\tsk->sk_state = TCP_ESTABLISHED;\n\t\tsk->sk_socket->state = SS_CONNECTED;\n\t\tvsock_insert_connected(vsk);\n\t\tsk->sk_state_change(sk);\n\n\t\tbreak;\n\tcase VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE:\n\tcase VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2:\n\t\tif (pkt->u.size == 0\n\t\t    || pkt->dg.src.context != vsk->remote_addr.svm_cid\n\t\t    || pkt->src_port != vsk->remote_addr.svm_port\n\t\t    || !vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle)\n\t\t    || vmci_trans(vsk)->qpair\n\t\t    || vmci_trans(vsk)->produce_size != 0\n\t\t    || vmci_trans(vsk)->consume_size != 0\n\t\t    || vmci_trans(vsk)->detach_sub_id != VMCI_INVALID_ID) {\n\t\t\tskerr = EPROTO;\n\t\t\terr = -EINVAL;\n\n\t\t\tgoto destroy;\n\t\t}\n\n\t\terr = vmci_transport_recv_connecting_client_negotiate(sk, pkt);\n\t\tif (err) {\n\t\t\tskerr = -err;\n\t\t\tgoto destroy;\n\t\t}\n\n\t\tbreak;\n\tcase VMCI_TRANSPORT_PACKET_TYPE_INVALID:\n\t\terr = vmci_transport_recv_connecting_client_invalid(sk, pkt);\n\t\tif (err) {\n\t\t\tskerr = -err;\n\t\t\tgoto destroy;\n\t\t}\n\n\t\tbreak;\n\tcase VMCI_TRANSPORT_PACKET_TYPE_RST:\n\t\t \n\t\tif (vsk->ignore_connecting_rst) {\n\t\t\tvsk->ignore_connecting_rst = false;\n\t\t} else {\n\t\t\tskerr = ECONNRESET;\n\t\t\terr = 0;\n\t\t\tgoto destroy;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tskerr = EPROTO;\n\t\terr = -EINVAL;\n\t\tgoto destroy;\n\t}\n\n\treturn 0;\n\ndestroy:\n\tvmci_transport_send_reset(sk, pkt);\n\n\tsk->sk_state = TCP_CLOSE;\n\tsk->sk_err = skerr;\n\tsk_error_report(sk);\n\treturn err;\n}\n\nstatic int vmci_transport_recv_connecting_client_negotiate(\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tstruct vmci_transport_packet *pkt)\n{\n\tint err;\n\tstruct vsock_sock *vsk;\n\tstruct vmci_handle handle;\n\tstruct vmci_qp *qpair;\n\tu32 detach_sub_id;\n\tbool is_local;\n\tu32 flags;\n\tbool old_proto = true;\n\tbool old_pkt_proto;\n\tu16 version;\n\n\tvsk = vsock_sk(sk);\n\thandle = VMCI_INVALID_HANDLE;\n\tdetach_sub_id = VMCI_INVALID_ID;\n\n\t \n\tvsk->sent_request = false;\n\tvsk->ignore_connecting_rst = false;\n\n\t \n\tif (pkt->u.size < vsk->buffer_min_size ||\n\t    pkt->u.size > vsk->buffer_max_size) {\n\t\terr = -EINVAL;\n\t\tgoto destroy;\n\t}\n\n\t \n\n\tif (vsk->local_addr.svm_cid == VMADDR_CID_ANY)\n\t\tvsk->local_addr.svm_cid = pkt->dg.dst.context;\n\n\t \n\n\tif (vmci_transport_old_proto_override(&old_pkt_proto)) {\n\t\told_proto = old_pkt_proto;\n\t} else {\n\t\tif (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE)\n\t\t\told_proto = true;\n\t\telse if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2)\n\t\t\told_proto = false;\n\n\t}\n\n\tif (old_proto)\n\t\tversion = VSOCK_PROTO_INVALID;\n\telse\n\t\tversion = pkt->proto;\n\n\tif (!vmci_transport_proto_to_notify_struct(sk, &version, old_proto)) {\n\t\terr = -EINVAL;\n\t\tgoto destroy;\n\t}\n\n\t \n\terr = vmci_event_subscribe(VMCI_EVENT_QP_PEER_DETACH,\n\t\t\t\t   vmci_transport_peer_detach_cb,\n\t\t\t\t   vmci_trans(vsk), &detach_sub_id);\n\tif (err < VMCI_SUCCESS) {\n\t\terr = vmci_transport_error_to_vsock_error(err);\n\t\tgoto destroy;\n\t}\n\n\t \n\thandle = VMCI_INVALID_HANDLE;\n\tis_local = vsk->remote_addr.svm_cid == vsk->local_addr.svm_cid;\n\tflags = is_local ? VMCI_QPFLAG_LOCAL : 0;\n\n\terr = vmci_transport_queue_pair_alloc(&qpair,\n\t\t\t\t\t      &handle,\n\t\t\t\t\t      pkt->u.size,\n\t\t\t\t\t      pkt->u.size,\n\t\t\t\t\t      vsk->remote_addr.svm_cid,\n\t\t\t\t\t      flags,\n\t\t\t\t\t      vmci_transport_is_trusted(\n\t\t\t\t\t\t  vsk,\n\t\t\t\t\t\t  vsk->\n\t\t\t\t\t\t  remote_addr.svm_cid));\n\tif (err < 0)\n\t\tgoto destroy;\n\n\terr = vmci_transport_send_qp_offer(sk, handle);\n\tif (err < 0) {\n\t\terr = vmci_transport_error_to_vsock_error(err);\n\t\tgoto destroy;\n\t}\n\n\tvmci_trans(vsk)->qp_handle = handle;\n\tvmci_trans(vsk)->qpair = qpair;\n\n\tvmci_trans(vsk)->produce_size = vmci_trans(vsk)->consume_size =\n\t\tpkt->u.size;\n\n\tvmci_trans(vsk)->detach_sub_id = detach_sub_id;\n\n\tvmci_trans(vsk)->notify_ops->process_negotiate(sk);\n\n\treturn 0;\n\ndestroy:\n\tif (detach_sub_id != VMCI_INVALID_ID)\n\t\tvmci_event_unsubscribe(detach_sub_id);\n\n\tif (!vmci_handle_is_invalid(handle))\n\t\tvmci_qpair_detach(&qpair);\n\n\treturn err;\n}\n\nstatic int\nvmci_transport_recv_connecting_client_invalid(struct sock *sk,\n\t\t\t\t\t      struct vmci_transport_packet *pkt)\n{\n\tint err = 0;\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tif (vsk->sent_request) {\n\t\tvsk->sent_request = false;\n\t\tvsk->ignore_connecting_rst = true;\n\n\t\terr = vmci_transport_send_conn_request(sk, vsk->buffer_size);\n\t\tif (err < 0)\n\t\t\terr = vmci_transport_error_to_vsock_error(err);\n\t\telse\n\t\t\terr = 0;\n\n\t}\n\n\treturn err;\n}\n\nstatic int vmci_transport_recv_connected(struct sock *sk,\n\t\t\t\t\t struct vmci_transport_packet *pkt)\n{\n\tstruct vsock_sock *vsk;\n\tbool pkt_processed = false;\n\n\t \n\tswitch (pkt->type) {\n\tcase VMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN:\n\t\tif (pkt->u.mode) {\n\t\t\tvsk = vsock_sk(sk);\n\n\t\t\tvsk->peer_shutdown |= pkt->u.mode;\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t\tbreak;\n\n\tcase VMCI_TRANSPORT_PACKET_TYPE_RST:\n\t\tvsk = vsock_sk(sk);\n\t\t \n\t\tsock_set_flag(sk, SOCK_DONE);\n\t\tvsk->peer_shutdown = SHUTDOWN_MASK;\n\t\tif (vsock_stream_has_data(vsk) <= 0)\n\t\t\tsk->sk_state = TCP_CLOSING;\n\n\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\n\tdefault:\n\t\tvsk = vsock_sk(sk);\n\t\tvmci_trans(vsk)->notify_ops->handle_notify_pkt(\n\t\t\t\tsk, pkt, false, NULL, NULL,\n\t\t\t\t&pkt_processed);\n\t\tif (!pkt_processed)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int vmci_transport_socket_init(struct vsock_sock *vsk,\n\t\t\t\t      struct vsock_sock *psk)\n{\n\tvsk->trans = kmalloc(sizeof(struct vmci_transport), GFP_KERNEL);\n\tif (!vsk->trans)\n\t\treturn -ENOMEM;\n\n\tvmci_trans(vsk)->dg_handle = VMCI_INVALID_HANDLE;\n\tvmci_trans(vsk)->qp_handle = VMCI_INVALID_HANDLE;\n\tvmci_trans(vsk)->qpair = NULL;\n\tvmci_trans(vsk)->produce_size = vmci_trans(vsk)->consume_size = 0;\n\tvmci_trans(vsk)->detach_sub_id = VMCI_INVALID_ID;\n\tvmci_trans(vsk)->notify_ops = NULL;\n\tINIT_LIST_HEAD(&vmci_trans(vsk)->elem);\n\tvmci_trans(vsk)->sk = &vsk->sk;\n\tspin_lock_init(&vmci_trans(vsk)->lock);\n\n\treturn 0;\n}\n\nstatic void vmci_transport_free_resources(struct list_head *transport_list)\n{\n\twhile (!list_empty(transport_list)) {\n\t\tstruct vmci_transport *transport =\n\t\t    list_first_entry(transport_list, struct vmci_transport,\n\t\t\t\t     elem);\n\t\tlist_del(&transport->elem);\n\n\t\tif (transport->detach_sub_id != VMCI_INVALID_ID) {\n\t\t\tvmci_event_unsubscribe(transport->detach_sub_id);\n\t\t\ttransport->detach_sub_id = VMCI_INVALID_ID;\n\t\t}\n\n\t\tif (!vmci_handle_is_invalid(transport->qp_handle)) {\n\t\t\tvmci_qpair_detach(&transport->qpair);\n\t\t\ttransport->qp_handle = VMCI_INVALID_HANDLE;\n\t\t\ttransport->produce_size = 0;\n\t\t\ttransport->consume_size = 0;\n\t\t}\n\n\t\tkfree(transport);\n\t}\n}\n\nstatic void vmci_transport_cleanup(struct work_struct *work)\n{\n\tLIST_HEAD(pending);\n\n\tspin_lock_bh(&vmci_transport_cleanup_lock);\n\tlist_replace_init(&vmci_transport_cleanup_list, &pending);\n\tspin_unlock_bh(&vmci_transport_cleanup_lock);\n\tvmci_transport_free_resources(&pending);\n}\n\nstatic void vmci_transport_destruct(struct vsock_sock *vsk)\n{\n\t \n\tif (!vmci_trans(vsk))\n\t\treturn;\n\n\t \n\tspin_lock_bh(&vmci_trans(vsk)->lock);\n\tvmci_trans(vsk)->sk = NULL;\n\tspin_unlock_bh(&vmci_trans(vsk)->lock);\n\n\tif (vmci_trans(vsk)->notify_ops)\n\t\tvmci_trans(vsk)->notify_ops->socket_destruct(vsk);\n\n\tspin_lock_bh(&vmci_transport_cleanup_lock);\n\tlist_add(&vmci_trans(vsk)->elem, &vmci_transport_cleanup_list);\n\tspin_unlock_bh(&vmci_transport_cleanup_lock);\n\tschedule_work(&vmci_transport_cleanup_work);\n\n\tvsk->trans = NULL;\n}\n\nstatic void vmci_transport_release(struct vsock_sock *vsk)\n{\n\tvsock_remove_sock(vsk);\n\n\tif (!vmci_handle_is_invalid(vmci_trans(vsk)->dg_handle)) {\n\t\tvmci_datagram_destroy_handle(vmci_trans(vsk)->dg_handle);\n\t\tvmci_trans(vsk)->dg_handle = VMCI_INVALID_HANDLE;\n\t}\n}\n\nstatic int vmci_transport_dgram_bind(struct vsock_sock *vsk,\n\t\t\t\t     struct sockaddr_vm *addr)\n{\n\tu32 port;\n\tu32 flags;\n\tint err;\n\n\t \n\tport = addr->svm_port == VMADDR_PORT_ANY ?\n\t\t\tVMCI_INVALID_ID : addr->svm_port;\n\n\tif (port <= LAST_RESERVED_PORT && !capable(CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\tflags = addr->svm_cid == VMADDR_CID_ANY ?\n\t\t\t\tVMCI_FLAG_ANYCID_DG_HND : 0;\n\n\terr = vmci_transport_datagram_create_hnd(port, flags,\n\t\t\t\t\t\t vmci_transport_recv_dgram_cb,\n\t\t\t\t\t\t &vsk->sk,\n\t\t\t\t\t\t &vmci_trans(vsk)->dg_handle);\n\tif (err < VMCI_SUCCESS)\n\t\treturn vmci_transport_error_to_vsock_error(err);\n\tvsock_addr_init(&vsk->local_addr, addr->svm_cid,\n\t\t\tvmci_trans(vsk)->dg_handle.resource);\n\n\treturn 0;\n}\n\nstatic int vmci_transport_dgram_enqueue(\n\tstruct vsock_sock *vsk,\n\tstruct sockaddr_vm *remote_addr,\n\tstruct msghdr *msg,\n\tsize_t len)\n{\n\tint err;\n\tstruct vmci_datagram *dg;\n\n\tif (len > VMCI_MAX_DG_PAYLOAD_SIZE)\n\t\treturn -EMSGSIZE;\n\n\tif (!vmci_transport_allow_dgram(vsk, remote_addr->svm_cid))\n\t\treturn -EPERM;\n\n\t \n\tdg = kmalloc(len + sizeof(*dg), GFP_KERNEL);\n\tif (!dg)\n\t\treturn -ENOMEM;\n\n\terr = memcpy_from_msg(VMCI_DG_PAYLOAD(dg), msg, len);\n\tif (err) {\n\t\tkfree(dg);\n\t\treturn err;\n\t}\n\n\tdg->dst = vmci_make_handle(remote_addr->svm_cid,\n\t\t\t\t   remote_addr->svm_port);\n\tdg->src = vmci_make_handle(vsk->local_addr.svm_cid,\n\t\t\t\t   vsk->local_addr.svm_port);\n\tdg->payload_size = len;\n\n\terr = vmci_datagram_send(dg);\n\tkfree(dg);\n\tif (err < 0)\n\t\treturn vmci_transport_error_to_vsock_error(err);\n\n\treturn err - sizeof(*dg);\n}\n\nstatic int vmci_transport_dgram_dequeue(struct vsock_sock *vsk,\n\t\t\t\t\tstruct msghdr *msg, size_t len,\n\t\t\t\t\tint flags)\n{\n\tint err;\n\tstruct vmci_datagram *dg;\n\tsize_t payload_len;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terr = 0;\n\tskb = skb_recv_datagram(&vsk->sk, flags, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tdg = (struct vmci_datagram *)skb->data;\n\tif (!dg)\n\t\t \n\t\tgoto out;\n\n\tpayload_len = dg->payload_size;\n\t \n\tif (payload_len != skb->len - sizeof(*dg)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (payload_len > len) {\n\t\tpayload_len = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t \n\terr = skb_copy_datagram_msg(skb, sizeof(*dg), msg, payload_len);\n\tif (err)\n\t\tgoto out;\n\n\tif (msg->msg_name) {\n\t\t \n\t\tDECLARE_SOCKADDR(struct sockaddr_vm *, vm_addr, msg->msg_name);\n\t\tvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\n\t\tmsg->msg_namelen = sizeof(*vm_addr);\n\t}\n\terr = payload_len;\n\nout:\n\tskb_free_datagram(&vsk->sk, skb);\n\treturn err;\n}\n\nstatic bool vmci_transport_dgram_allow(u32 cid, u32 port)\n{\n\tif (cid == VMADDR_CID_HYPERVISOR) {\n\t\t \n\t\treturn port == VMCI_UNITY_PBRPC_REGISTER;\n\t}\n\n\treturn true;\n}\n\nstatic int vmci_transport_connect(struct vsock_sock *vsk)\n{\n\tint err;\n\tbool old_pkt_proto = false;\n\tstruct sock *sk = &vsk->sk;\n\n\tif (vmci_transport_old_proto_override(&old_pkt_proto) &&\n\t\told_pkt_proto) {\n\t\terr = vmci_transport_send_conn_request(sk, vsk->buffer_size);\n\t\tif (err < 0) {\n\t\t\tsk->sk_state = TCP_CLOSE;\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tint supported_proto_versions =\n\t\t\tvmci_transport_new_proto_supported_versions();\n\t\terr = vmci_transport_send_conn_request2(sk, vsk->buffer_size,\n\t\t\t\tsupported_proto_versions);\n\t\tif (err < 0) {\n\t\t\tsk->sk_state = TCP_CLOSE;\n\t\t\treturn err;\n\t\t}\n\n\t\tvsk->sent_request = true;\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t vmci_transport_stream_dequeue(\n\tstruct vsock_sock *vsk,\n\tstruct msghdr *msg,\n\tsize_t len,\n\tint flags)\n{\n\tssize_t err;\n\n\tif (flags & MSG_PEEK)\n\t\terr = vmci_qpair_peekv(vmci_trans(vsk)->qpair, msg, len, 0);\n\telse\n\t\terr = vmci_qpair_dequev(vmci_trans(vsk)->qpair, msg, len, 0);\n\n\tif (err < 0)\n\t\terr = -ENOMEM;\n\n\treturn err;\n}\n\nstatic ssize_t vmci_transport_stream_enqueue(\n\tstruct vsock_sock *vsk,\n\tstruct msghdr *msg,\n\tsize_t len)\n{\n\tssize_t err;\n\n\terr = vmci_qpair_enquev(vmci_trans(vsk)->qpair, msg, len, 0);\n\tif (err < 0)\n\t\terr = -ENOMEM;\n\n\treturn err;\n}\n\nstatic s64 vmci_transport_stream_has_data(struct vsock_sock *vsk)\n{\n\treturn vmci_qpair_consume_buf_ready(vmci_trans(vsk)->qpair);\n}\n\nstatic s64 vmci_transport_stream_has_space(struct vsock_sock *vsk)\n{\n\treturn vmci_qpair_produce_free_space(vmci_trans(vsk)->qpair);\n}\n\nstatic u64 vmci_transport_stream_rcvhiwat(struct vsock_sock *vsk)\n{\n\treturn vmci_trans(vsk)->consume_size;\n}\n\nstatic bool vmci_transport_stream_is_active(struct vsock_sock *vsk)\n{\n\treturn !vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle);\n}\n\nstatic int vmci_transport_notify_poll_in(\n\tstruct vsock_sock *vsk,\n\tsize_t target,\n\tbool *data_ready_now)\n{\n\treturn vmci_trans(vsk)->notify_ops->poll_in(\n\t\t\t&vsk->sk, target, data_ready_now);\n}\n\nstatic int vmci_transport_notify_poll_out(\n\tstruct vsock_sock *vsk,\n\tsize_t target,\n\tbool *space_available_now)\n{\n\treturn vmci_trans(vsk)->notify_ops->poll_out(\n\t\t\t&vsk->sk, target, space_available_now);\n}\n\nstatic int vmci_transport_notify_recv_init(\n\tstruct vsock_sock *vsk,\n\tsize_t target,\n\tstruct vsock_transport_recv_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->recv_init(\n\t\t\t&vsk->sk, target,\n\t\t\t(struct vmci_transport_recv_notify_data *)data);\n}\n\nstatic int vmci_transport_notify_recv_pre_block(\n\tstruct vsock_sock *vsk,\n\tsize_t target,\n\tstruct vsock_transport_recv_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->recv_pre_block(\n\t\t\t&vsk->sk, target,\n\t\t\t(struct vmci_transport_recv_notify_data *)data);\n}\n\nstatic int vmci_transport_notify_recv_pre_dequeue(\n\tstruct vsock_sock *vsk,\n\tsize_t target,\n\tstruct vsock_transport_recv_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->recv_pre_dequeue(\n\t\t\t&vsk->sk, target,\n\t\t\t(struct vmci_transport_recv_notify_data *)data);\n}\n\nstatic int vmci_transport_notify_recv_post_dequeue(\n\tstruct vsock_sock *vsk,\n\tsize_t target,\n\tssize_t copied,\n\tbool data_read,\n\tstruct vsock_transport_recv_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->recv_post_dequeue(\n\t\t\t&vsk->sk, target, copied, data_read,\n\t\t\t(struct vmci_transport_recv_notify_data *)data);\n}\n\nstatic int vmci_transport_notify_send_init(\n\tstruct vsock_sock *vsk,\n\tstruct vsock_transport_send_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->send_init(\n\t\t\t&vsk->sk,\n\t\t\t(struct vmci_transport_send_notify_data *)data);\n}\n\nstatic int vmci_transport_notify_send_pre_block(\n\tstruct vsock_sock *vsk,\n\tstruct vsock_transport_send_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->send_pre_block(\n\t\t\t&vsk->sk,\n\t\t\t(struct vmci_transport_send_notify_data *)data);\n}\n\nstatic int vmci_transport_notify_send_pre_enqueue(\n\tstruct vsock_sock *vsk,\n\tstruct vsock_transport_send_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->send_pre_enqueue(\n\t\t\t&vsk->sk,\n\t\t\t(struct vmci_transport_send_notify_data *)data);\n}\n\nstatic int vmci_transport_notify_send_post_enqueue(\n\tstruct vsock_sock *vsk,\n\tssize_t written,\n\tstruct vsock_transport_send_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->send_post_enqueue(\n\t\t\t&vsk->sk, written,\n\t\t\t(struct vmci_transport_send_notify_data *)data);\n}\n\nstatic bool vmci_transport_old_proto_override(bool *old_pkt_proto)\n{\n\tif (PROTOCOL_OVERRIDE != -1) {\n\t\tif (PROTOCOL_OVERRIDE == 0)\n\t\t\t*old_pkt_proto = true;\n\t\telse\n\t\t\t*old_pkt_proto = false;\n\n\t\tpr_info(\"Proto override in use\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool vmci_transport_proto_to_notify_struct(struct sock *sk,\n\t\t\t\t\t\t  u16 *proto,\n\t\t\t\t\t\t  bool old_pkt_proto)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tif (old_pkt_proto) {\n\t\tif (*proto != VSOCK_PROTO_INVALID) {\n\t\t\tpr_err(\"Can't set both an old and new protocol\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tvmci_trans(vsk)->notify_ops = &vmci_transport_notify_pkt_ops;\n\t\tgoto exit;\n\t}\n\n\tswitch (*proto) {\n\tcase VSOCK_PROTO_PKT_ON_NOTIFY:\n\t\tvmci_trans(vsk)->notify_ops =\n\t\t\t&vmci_transport_notify_pkt_q_state_ops;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown notify protocol version\\n\");\n\t\treturn false;\n\t}\n\nexit:\n\tvmci_trans(vsk)->notify_ops->socket_init(sk);\n\treturn true;\n}\n\nstatic u16 vmci_transport_new_proto_supported_versions(void)\n{\n\tif (PROTOCOL_OVERRIDE != -1)\n\t\treturn PROTOCOL_OVERRIDE;\n\n\treturn VSOCK_PROTO_ALL_SUPPORTED;\n}\n\nstatic u32 vmci_transport_get_local_cid(void)\n{\n\treturn vmci_get_context_id();\n}\n\nstatic struct vsock_transport vmci_transport = {\n\t.module = THIS_MODULE,\n\t.init = vmci_transport_socket_init,\n\t.destruct = vmci_transport_destruct,\n\t.release = vmci_transport_release,\n\t.connect = vmci_transport_connect,\n\t.dgram_bind = vmci_transport_dgram_bind,\n\t.dgram_dequeue = vmci_transport_dgram_dequeue,\n\t.dgram_enqueue = vmci_transport_dgram_enqueue,\n\t.dgram_allow = vmci_transport_dgram_allow,\n\t.stream_dequeue = vmci_transport_stream_dequeue,\n\t.stream_enqueue = vmci_transport_stream_enqueue,\n\t.stream_has_data = vmci_transport_stream_has_data,\n\t.stream_has_space = vmci_transport_stream_has_space,\n\t.stream_rcvhiwat = vmci_transport_stream_rcvhiwat,\n\t.stream_is_active = vmci_transport_stream_is_active,\n\t.stream_allow = vmci_transport_stream_allow,\n\t.notify_poll_in = vmci_transport_notify_poll_in,\n\t.notify_poll_out = vmci_transport_notify_poll_out,\n\t.notify_recv_init = vmci_transport_notify_recv_init,\n\t.notify_recv_pre_block = vmci_transport_notify_recv_pre_block,\n\t.notify_recv_pre_dequeue = vmci_transport_notify_recv_pre_dequeue,\n\t.notify_recv_post_dequeue = vmci_transport_notify_recv_post_dequeue,\n\t.notify_send_init = vmci_transport_notify_send_init,\n\t.notify_send_pre_block = vmci_transport_notify_send_pre_block,\n\t.notify_send_pre_enqueue = vmci_transport_notify_send_pre_enqueue,\n\t.notify_send_post_enqueue = vmci_transport_notify_send_post_enqueue,\n\t.shutdown = vmci_transport_shutdown,\n\t.get_local_cid = vmci_transport_get_local_cid,\n};\n\nstatic bool vmci_check_transport(struct vsock_sock *vsk)\n{\n\treturn vsk->transport == &vmci_transport;\n}\n\nstatic void vmci_vsock_transport_cb(bool is_host)\n{\n\tint features;\n\n\tif (is_host)\n\t\tfeatures = VSOCK_TRANSPORT_F_H2G;\n\telse\n\t\tfeatures = VSOCK_TRANSPORT_F_G2H;\n\n\tvsock_core_register(&vmci_transport, features);\n}\n\nstatic int __init vmci_transport_init(void)\n{\n\tint err;\n\n\t \n\terr = vmci_transport_datagram_create_hnd(VMCI_TRANSPORT_PACKET_RID,\n\t\t\t\t\t\t VMCI_FLAG_ANYCID_DG_HND,\n\t\t\t\t\t\t vmci_transport_recv_stream_cb,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t &vmci_transport_stream_handle);\n\tif (err < VMCI_SUCCESS) {\n\t\tpr_err(\"Unable to create datagram handle. (%d)\\n\", err);\n\t\treturn vmci_transport_error_to_vsock_error(err);\n\t}\n\terr = vmci_event_subscribe(VMCI_EVENT_QP_RESUMED,\n\t\t\t\t   vmci_transport_qp_resumed_cb,\n\t\t\t\t   NULL, &vmci_transport_qp_resumed_sub_id);\n\tif (err < VMCI_SUCCESS) {\n\t\tpr_err(\"Unable to subscribe to resumed event. (%d)\\n\", err);\n\t\terr = vmci_transport_error_to_vsock_error(err);\n\t\tvmci_transport_qp_resumed_sub_id = VMCI_INVALID_ID;\n\t\tgoto err_destroy_stream_handle;\n\t}\n\n\t \n\terr = vsock_core_register(&vmci_transport, VSOCK_TRANSPORT_F_DGRAM);\n\tif (err < 0)\n\t\tgoto err_unsubscribe;\n\n\terr = vmci_register_vsock_callback(vmci_vsock_transport_cb);\n\tif (err < 0)\n\t\tgoto err_unregister;\n\n\treturn 0;\n\nerr_unregister:\n\tvsock_core_unregister(&vmci_transport);\nerr_unsubscribe:\n\tvmci_event_unsubscribe(vmci_transport_qp_resumed_sub_id);\nerr_destroy_stream_handle:\n\tvmci_datagram_destroy_handle(vmci_transport_stream_handle);\n\treturn err;\n}\nmodule_init(vmci_transport_init);\n\nstatic void __exit vmci_transport_exit(void)\n{\n\tcancel_work_sync(&vmci_transport_cleanup_work);\n\tvmci_transport_free_resources(&vmci_transport_cleanup_list);\n\n\tif (!vmci_handle_is_invalid(vmci_transport_stream_handle)) {\n\t\tif (vmci_datagram_destroy_handle(\n\t\t\tvmci_transport_stream_handle) != VMCI_SUCCESS)\n\t\t\tpr_err(\"Couldn't destroy datagram handle\\n\");\n\t\tvmci_transport_stream_handle = VMCI_INVALID_HANDLE;\n\t}\n\n\tif (vmci_transport_qp_resumed_sub_id != VMCI_INVALID_ID) {\n\t\tvmci_event_unsubscribe(vmci_transport_qp_resumed_sub_id);\n\t\tvmci_transport_qp_resumed_sub_id = VMCI_INVALID_ID;\n\t}\n\n\tvmci_register_vsock_callback(NULL);\n\tvsock_core_unregister(&vmci_transport);\n}\nmodule_exit(vmci_transport_exit);\n\nMODULE_AUTHOR(\"VMware, Inc.\");\nMODULE_DESCRIPTION(\"VMCI transport for Virtual Sockets\");\nMODULE_VERSION(\"1.0.5.0-k\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"vmware_vsock\");\nMODULE_ALIAS_NETPROTO(PF_VSOCK);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}