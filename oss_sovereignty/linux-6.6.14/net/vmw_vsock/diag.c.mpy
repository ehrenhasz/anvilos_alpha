{
  "module_name": "diag.c",
  "hash_id": "29253b78a3577120c444a43c6c5150c6642710adf914ee07c5dfb66739190173",
  "original_prompt": "Ingested from linux-6.6.14/net/vmw_vsock/diag.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sock_diag.h>\n#include <linux/vm_sockets_diag.h>\n#include <net/af_vsock.h>\n\nstatic int sk_diag_fill(struct sock *sk, struct sk_buff *skb,\n\t\t\tu32 portid, u32 seq, u32 flags)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\tstruct vsock_diag_msg *rep;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, portid, seq, SOCK_DIAG_BY_FAMILY, sizeof(*rep),\n\t\t\tflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\trep = nlmsg_data(nlh);\n\trep->vdiag_family = AF_VSOCK;\n\n\t \n\trep->vdiag_type = sk->sk_type;\n\trep->vdiag_state = sk->sk_state;\n\trep->vdiag_shutdown = sk->sk_shutdown;\n\trep->vdiag_src_cid = vsk->local_addr.svm_cid;\n\trep->vdiag_src_port = vsk->local_addr.svm_port;\n\trep->vdiag_dst_cid = vsk->remote_addr.svm_cid;\n\trep->vdiag_dst_port = vsk->remote_addr.svm_port;\n\trep->vdiag_ino = sock_i_ino(sk);\n\n\tsock_diag_save_cookie(sk, rep->vdiag_cookie);\n\n\treturn 0;\n}\n\nstatic int vsock_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct vsock_diag_req *req;\n\tstruct vsock_sock *vsk;\n\tunsigned int bucket;\n\tunsigned int last_i;\n\tunsigned int table;\n\tstruct net *net;\n\tunsigned int i;\n\n\treq = nlmsg_data(cb->nlh);\n\tnet = sock_net(skb->sk);\n\n\t \n\ttable = cb->args[0];\n\tbucket = cb->args[1];\n\ti = last_i = cb->args[2];\n\n\t \n\n\tspin_lock_bh(&vsock_table_lock);\n\n\t \n\tif (table == 0) {\n\t\twhile (bucket < ARRAY_SIZE(vsock_bind_table)) {\n\t\t\tstruct list_head *head = &vsock_bind_table[bucket];\n\n\t\t\ti = 0;\n\t\t\tlist_for_each_entry(vsk, head, bound_table) {\n\t\t\t\tstruct sock *sk = sk_vsock(vsk);\n\n\t\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (i < last_i)\n\t\t\t\t\tgoto next_bind;\n\t\t\t\tif (!(req->vdiag_states & (1 << sk->sk_state)))\n\t\t\t\t\tgoto next_bind;\n\t\t\t\tif (sk_diag_fill(sk, skb,\n\t\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t NLM_F_MULTI) < 0)\n\t\t\t\t\tgoto done;\nnext_bind:\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tlast_i = 0;\n\t\t\tbucket++;\n\t\t}\n\n\t\ttable++;\n\t\tbucket = 0;\n\t}\n\n\t \n\twhile (bucket < ARRAY_SIZE(vsock_connected_table)) {\n\t\tstruct list_head *head = &vsock_connected_table[bucket];\n\n\t\ti = 0;\n\t\tlist_for_each_entry(vsk, head, connected_table) {\n\t\t\tstruct sock *sk = sk_vsock(vsk);\n\n\t\t\t \n\t\t\tif (__vsock_in_bound_table(vsk))\n\t\t\t\tcontinue;\n\n\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\tcontinue;\n\t\t\tif (i < last_i)\n\t\t\t\tgoto next_connected;\n\t\t\tif (!(req->vdiag_states & (1 << sk->sk_state)))\n\t\t\t\tgoto next_connected;\n\t\t\tif (sk_diag_fill(sk, skb,\n\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t\t NLM_F_MULTI) < 0)\n\t\t\t\tgoto done;\nnext_connected:\n\t\t\ti++;\n\t\t}\n\t\tlast_i = 0;\n\t\tbucket++;\n\t}\n\ndone:\n\tspin_unlock_bh(&vsock_table_lock);\n\n\tcb->args[0] = table;\n\tcb->args[1] = bucket;\n\tcb->args[2] = i;\n\n\treturn skb->len;\n}\n\nstatic int vsock_diag_handler_dump(struct sk_buff *skb, struct nlmsghdr *h)\n{\n\tint hdrlen = sizeof(struct vsock_diag_req);\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (nlmsg_len(h) < hdrlen)\n\t\treturn -EINVAL;\n\n\tif (h->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = vsock_diag_dump,\n\t\t};\n\t\treturn netlink_dump_start(net->diag_nlsk, skb, h, &c);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct sock_diag_handler vsock_diag_handler = {\n\t.family = AF_VSOCK,\n\t.dump = vsock_diag_handler_dump,\n};\n\nstatic int __init vsock_diag_init(void)\n{\n\treturn sock_diag_register(&vsock_diag_handler);\n}\n\nstatic void __exit vsock_diag_exit(void)\n{\n\tsock_diag_unregister(&vsock_diag_handler);\n}\n\nmodule_init(vsock_diag_init);\nmodule_exit(vsock_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG,\n\t\t\t       40  );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}