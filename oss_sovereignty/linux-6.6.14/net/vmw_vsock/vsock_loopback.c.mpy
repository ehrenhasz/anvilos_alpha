{
  "module_name": "vsock_loopback.c",
  "hash_id": "81b7ad488ff973b11fc5b87f1b43bce8678e19ca57469b4f8a2a01f3eef80894",
  "original_prompt": "Ingested from linux-6.6.14/net/vmw_vsock/vsock_loopback.c",
  "human_readable_source": "\n \n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/virtio_vsock.h>\n\nstruct vsock_loopback {\n\tstruct workqueue_struct *workqueue;\n\n\tstruct sk_buff_head pkt_queue;\n\tstruct work_struct pkt_work;\n};\n\nstatic struct vsock_loopback the_vsock_loopback;\n\nstatic u32 vsock_loopback_get_local_cid(void)\n{\n\treturn VMADDR_CID_LOCAL;\n}\n\nstatic int vsock_loopback_send_pkt(struct sk_buff *skb)\n{\n\tstruct vsock_loopback *vsock = &the_vsock_loopback;\n\tint len = skb->len;\n\n\tvirtio_vsock_skb_queue_tail(&vsock->pkt_queue, skb);\n\tqueue_work(vsock->workqueue, &vsock->pkt_work);\n\n\treturn len;\n}\n\nstatic int vsock_loopback_cancel_pkt(struct vsock_sock *vsk)\n{\n\tstruct vsock_loopback *vsock = &the_vsock_loopback;\n\n\tvirtio_transport_purge_skbs(vsk, &vsock->pkt_queue);\n\n\treturn 0;\n}\n\nstatic bool vsock_loopback_seqpacket_allow(u32 remote_cid);\n\nstatic struct virtio_transport loopback_transport = {\n\t.transport = {\n\t\t.module                   = THIS_MODULE,\n\n\t\t.get_local_cid            = vsock_loopback_get_local_cid,\n\n\t\t.init                     = virtio_transport_do_socket_init,\n\t\t.destruct                 = virtio_transport_destruct,\n\t\t.release                  = virtio_transport_release,\n\t\t.connect                  = virtio_transport_connect,\n\t\t.shutdown                 = virtio_transport_shutdown,\n\t\t.cancel_pkt               = vsock_loopback_cancel_pkt,\n\n\t\t.dgram_bind               = virtio_transport_dgram_bind,\n\t\t.dgram_dequeue            = virtio_transport_dgram_dequeue,\n\t\t.dgram_enqueue            = virtio_transport_dgram_enqueue,\n\t\t.dgram_allow              = virtio_transport_dgram_allow,\n\n\t\t.stream_dequeue           = virtio_transport_stream_dequeue,\n\t\t.stream_enqueue           = virtio_transport_stream_enqueue,\n\t\t.stream_has_data          = virtio_transport_stream_has_data,\n\t\t.stream_has_space         = virtio_transport_stream_has_space,\n\t\t.stream_rcvhiwat          = virtio_transport_stream_rcvhiwat,\n\t\t.stream_is_active         = virtio_transport_stream_is_active,\n\t\t.stream_allow             = virtio_transport_stream_allow,\n\n\t\t.seqpacket_dequeue        = virtio_transport_seqpacket_dequeue,\n\t\t.seqpacket_enqueue        = virtio_transport_seqpacket_enqueue,\n\t\t.seqpacket_allow          = vsock_loopback_seqpacket_allow,\n\t\t.seqpacket_has_data       = virtio_transport_seqpacket_has_data,\n\n\t\t.notify_poll_in           = virtio_transport_notify_poll_in,\n\t\t.notify_poll_out          = virtio_transport_notify_poll_out,\n\t\t.notify_recv_init         = virtio_transport_notify_recv_init,\n\t\t.notify_recv_pre_block    = virtio_transport_notify_recv_pre_block,\n\t\t.notify_recv_pre_dequeue  = virtio_transport_notify_recv_pre_dequeue,\n\t\t.notify_recv_post_dequeue = virtio_transport_notify_recv_post_dequeue,\n\t\t.notify_send_init         = virtio_transport_notify_send_init,\n\t\t.notify_send_pre_block    = virtio_transport_notify_send_pre_block,\n\t\t.notify_send_pre_enqueue  = virtio_transport_notify_send_pre_enqueue,\n\t\t.notify_send_post_enqueue = virtio_transport_notify_send_post_enqueue,\n\t\t.notify_buffer_size       = virtio_transport_notify_buffer_size,\n\t\t.notify_set_rcvlowat      = virtio_transport_notify_set_rcvlowat,\n\n\t\t.read_skb = virtio_transport_read_skb,\n\t},\n\n\t.send_pkt = vsock_loopback_send_pkt,\n};\n\nstatic bool vsock_loopback_seqpacket_allow(u32 remote_cid)\n{\n\treturn true;\n}\n\nstatic void vsock_loopback_work(struct work_struct *work)\n{\n\tstruct vsock_loopback *vsock =\n\t\tcontainer_of(work, struct vsock_loopback, pkt_work);\n\tstruct sk_buff_head pkts;\n\tstruct sk_buff *skb;\n\n\tskb_queue_head_init(&pkts);\n\n\tspin_lock_bh(&vsock->pkt_queue.lock);\n\tskb_queue_splice_init(&vsock->pkt_queue, &pkts);\n\tspin_unlock_bh(&vsock->pkt_queue.lock);\n\n\twhile ((skb = __skb_dequeue(&pkts))) {\n\t\tvirtio_transport_deliver_tap_pkt(skb);\n\t\tvirtio_transport_recv_pkt(&loopback_transport, skb);\n\t}\n}\n\nstatic int __init vsock_loopback_init(void)\n{\n\tstruct vsock_loopback *vsock = &the_vsock_loopback;\n\tint ret;\n\n\tvsock->workqueue = alloc_workqueue(\"vsock-loopback\", 0, 0);\n\tif (!vsock->workqueue)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&vsock->pkt_queue);\n\tINIT_WORK(&vsock->pkt_work, vsock_loopback_work);\n\n\tret = vsock_core_register(&loopback_transport.transport,\n\t\t\t\t  VSOCK_TRANSPORT_F_LOCAL);\n\tif (ret)\n\t\tgoto out_wq;\n\n\treturn 0;\n\nout_wq:\n\tdestroy_workqueue(vsock->workqueue);\n\treturn ret;\n}\n\nstatic void __exit vsock_loopback_exit(void)\n{\n\tstruct vsock_loopback *vsock = &the_vsock_loopback;\n\n\tvsock_core_unregister(&loopback_transport.transport);\n\n\tflush_work(&vsock->pkt_work);\n\n\tvirtio_vsock_skb_queue_purge(&vsock->pkt_queue);\n\n\tdestroy_workqueue(vsock->workqueue);\n}\n\nmodule_init(vsock_loopback_init);\nmodule_exit(vsock_loopback_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Stefano Garzarella <sgarzare@redhat.com>\");\nMODULE_DESCRIPTION(\"loopback transport for vsock\");\nMODULE_ALIAS_NETPROTO(PF_VSOCK);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}