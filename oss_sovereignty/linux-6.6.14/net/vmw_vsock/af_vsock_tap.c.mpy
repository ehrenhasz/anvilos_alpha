{
  "module_name": "af_vsock_tap.c",
  "hash_id": "d3d8fbcb64ebe3d4bb45cf0bf25d5d4c8699efe8c5917255b84b4252a0300a82",
  "original_prompt": "Ingested from linux-6.6.14/net/vmw_vsock/af_vsock_tap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <net/sock.h>\n#include <net/af_vsock.h>\n#include <linux/if_arp.h>\n\nstatic DEFINE_SPINLOCK(vsock_tap_lock);\nstatic struct list_head vsock_tap_all __read_mostly =\n\t\t\t\tLIST_HEAD_INIT(vsock_tap_all);\n\nint vsock_add_tap(struct vsock_tap *vt)\n{\n\tif (unlikely(vt->dev->type != ARPHRD_VSOCKMON))\n\t\treturn -EINVAL;\n\n\t__module_get(vt->module);\n\n\tspin_lock(&vsock_tap_lock);\n\tlist_add_rcu(&vt->list, &vsock_tap_all);\n\tspin_unlock(&vsock_tap_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vsock_add_tap);\n\nint vsock_remove_tap(struct vsock_tap *vt)\n{\n\tstruct vsock_tap *tmp;\n\tbool found = false;\n\n\tspin_lock(&vsock_tap_lock);\n\n\tlist_for_each_entry(tmp, &vsock_tap_all, list) {\n\t\tif (vt == tmp) {\n\t\t\tlist_del_rcu(&vt->list);\n\t\t\tfound = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpr_warn(\"vsock_remove_tap: %p not found\\n\", vt);\nout:\n\tspin_unlock(&vsock_tap_lock);\n\n\tsynchronize_net();\n\n\tif (found)\n\t\tmodule_put(vt->module);\n\n\treturn found ? 0 : -ENODEV;\n}\nEXPORT_SYMBOL_GPL(vsock_remove_tap);\n\nstatic int __vsock_deliver_tap_skb(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev)\n{\n\tint ret = 0;\n\tstruct sk_buff *nskb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (nskb) {\n\t\tdev_hold(dev);\n\n\t\tnskb->dev = dev;\n\t\tret = dev_queue_xmit(nskb);\n\t\tif (unlikely(ret > 0))\n\t\t\tret = net_xmit_errno(ret);\n\n\t\tdev_put(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void __vsock_deliver_tap(struct sk_buff *skb)\n{\n\tint ret;\n\tstruct vsock_tap *tmp;\n\n\tlist_for_each_entry_rcu(tmp, &vsock_tap_all, list) {\n\t\tret = __vsock_deliver_tap_skb(skb, tmp->dev);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t}\n}\n\nvoid vsock_deliver_tap(struct sk_buff *build_skb(void *opaque), void *opaque)\n{\n\tstruct sk_buff *skb;\n\n\trcu_read_lock();\n\n\tif (likely(list_empty(&vsock_tap_all)))\n\t\tgoto out;\n\n\tskb = build_skb(opaque);\n\tif (skb) {\n\t\t__vsock_deliver_tap(skb);\n\t\tconsume_skb(skb);\n\t}\n\nout:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(vsock_deliver_tap);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}