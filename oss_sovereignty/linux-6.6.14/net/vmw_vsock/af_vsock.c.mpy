{
  "module_name": "af_vsock.c",
  "hash_id": "0643f51d6d8d9f258e48638eb3145500198159bb57f619a26aeccbdcf3f4e516",
  "original_prompt": "Ingested from linux-6.6.14/net/vmw_vsock/af_vsock.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/cred.h>\n#include <linux/errqueue.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/kmod.h>\n#include <linux/list.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/net.h>\n#include <linux/poll.h>\n#include <linux/random.h>\n#include <linux/skbuff.h>\n#include <linux/smp.h>\n#include <linux/socket.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <net/sock.h>\n#include <net/af_vsock.h>\n#include <uapi/linux/vm_sockets.h>\n\nstatic int __vsock_bind(struct sock *sk, struct sockaddr_vm *addr);\nstatic void vsock_sk_destruct(struct sock *sk);\nstatic int vsock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);\n\n \nstruct proto vsock_proto = {\n\t.name = \"AF_VSOCK\",\n\t.owner = THIS_MODULE,\n\t.obj_size = sizeof(struct vsock_sock),\n#ifdef CONFIG_BPF_SYSCALL\n\t.psock_update_sk_prot = vsock_bpf_update_proto,\n#endif\n};\n\n \n#define VSOCK_DEFAULT_CONNECT_TIMEOUT (2 * HZ)\n\n#define VSOCK_DEFAULT_BUFFER_SIZE     (1024 * 256)\n#define VSOCK_DEFAULT_BUFFER_MAX_SIZE (1024 * 256)\n#define VSOCK_DEFAULT_BUFFER_MIN_SIZE 128\n\n \nstatic const struct vsock_transport *transport_h2g;\n \nstatic const struct vsock_transport *transport_g2h;\n \nstatic const struct vsock_transport *transport_dgram;\n \nstatic const struct vsock_transport *transport_local;\nstatic DEFINE_MUTEX(vsock_register_mutex);\n\n \n\n \n#define MAX_PORT_RETRIES        24\n\n#define VSOCK_HASH(addr)        ((addr)->svm_port % VSOCK_HASH_SIZE)\n#define vsock_bound_sockets(addr) (&vsock_bind_table[VSOCK_HASH(addr)])\n#define vsock_unbound_sockets     (&vsock_bind_table[VSOCK_HASH_SIZE])\n\n \n#define VSOCK_CONN_HASH(src, dst)\t\t\t\t\\\n\t(((src)->svm_cid ^ (dst)->svm_port) % VSOCK_HASH_SIZE)\n#define vsock_connected_sockets(src, dst)\t\t\\\n\t(&vsock_connected_table[VSOCK_CONN_HASH(src, dst)])\n#define vsock_connected_sockets_vsk(vsk)\t\t\t\t\\\n\tvsock_connected_sockets(&(vsk)->remote_addr, &(vsk)->local_addr)\n\nstruct list_head vsock_bind_table[VSOCK_HASH_SIZE + 1];\nEXPORT_SYMBOL_GPL(vsock_bind_table);\nstruct list_head vsock_connected_table[VSOCK_HASH_SIZE];\nEXPORT_SYMBOL_GPL(vsock_connected_table);\nDEFINE_SPINLOCK(vsock_table_lock);\nEXPORT_SYMBOL_GPL(vsock_table_lock);\n\n \nstatic int vsock_auto_bind(struct vsock_sock *vsk)\n{\n\tstruct sock *sk = sk_vsock(vsk);\n\tstruct sockaddr_vm local_addr;\n\n\tif (vsock_addr_bound(&vsk->local_addr))\n\t\treturn 0;\n\tvsock_addr_init(&local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\treturn __vsock_bind(sk, &local_addr);\n}\n\nstatic void vsock_init_tables(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vsock_bind_table); i++)\n\t\tINIT_LIST_HEAD(&vsock_bind_table[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(vsock_connected_table); i++)\n\t\tINIT_LIST_HEAD(&vsock_connected_table[i]);\n}\n\nstatic void __vsock_insert_bound(struct list_head *list,\n\t\t\t\t struct vsock_sock *vsk)\n{\n\tsock_hold(&vsk->sk);\n\tlist_add(&vsk->bound_table, list);\n}\n\nstatic void __vsock_insert_connected(struct list_head *list,\n\t\t\t\t     struct vsock_sock *vsk)\n{\n\tsock_hold(&vsk->sk);\n\tlist_add(&vsk->connected_table, list);\n}\n\nstatic void __vsock_remove_bound(struct vsock_sock *vsk)\n{\n\tlist_del_init(&vsk->bound_table);\n\tsock_put(&vsk->sk);\n}\n\nstatic void __vsock_remove_connected(struct vsock_sock *vsk)\n{\n\tlist_del_init(&vsk->connected_table);\n\tsock_put(&vsk->sk);\n}\n\nstatic struct sock *__vsock_find_bound_socket(struct sockaddr_vm *addr)\n{\n\tstruct vsock_sock *vsk;\n\n\tlist_for_each_entry(vsk, vsock_bound_sockets(addr), bound_table) {\n\t\tif (vsock_addr_equals_addr(addr, &vsk->local_addr))\n\t\t\treturn sk_vsock(vsk);\n\n\t\tif (addr->svm_port == vsk->local_addr.svm_port &&\n\t\t    (vsk->local_addr.svm_cid == VMADDR_CID_ANY ||\n\t\t     addr->svm_cid == VMADDR_CID_ANY))\n\t\t\treturn sk_vsock(vsk);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct sock *__vsock_find_connected_socket(struct sockaddr_vm *src,\n\t\t\t\t\t\t  struct sockaddr_vm *dst)\n{\n\tstruct vsock_sock *vsk;\n\n\tlist_for_each_entry(vsk, vsock_connected_sockets(src, dst),\n\t\t\t    connected_table) {\n\t\tif (vsock_addr_equals_addr(src, &vsk->remote_addr) &&\n\t\t    dst->svm_port == vsk->local_addr.svm_port) {\n\t\t\treturn sk_vsock(vsk);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void vsock_insert_unbound(struct vsock_sock *vsk)\n{\n\tspin_lock_bh(&vsock_table_lock);\n\t__vsock_insert_bound(vsock_unbound_sockets, vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n}\n\nvoid vsock_insert_connected(struct vsock_sock *vsk)\n{\n\tstruct list_head *list = vsock_connected_sockets(\n\t\t&vsk->remote_addr, &vsk->local_addr);\n\n\tspin_lock_bh(&vsock_table_lock);\n\t__vsock_insert_connected(list, vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n}\nEXPORT_SYMBOL_GPL(vsock_insert_connected);\n\nvoid vsock_remove_bound(struct vsock_sock *vsk)\n{\n\tspin_lock_bh(&vsock_table_lock);\n\tif (__vsock_in_bound_table(vsk))\n\t\t__vsock_remove_bound(vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n}\nEXPORT_SYMBOL_GPL(vsock_remove_bound);\n\nvoid vsock_remove_connected(struct vsock_sock *vsk)\n{\n\tspin_lock_bh(&vsock_table_lock);\n\tif (__vsock_in_connected_table(vsk))\n\t\t__vsock_remove_connected(vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n}\nEXPORT_SYMBOL_GPL(vsock_remove_connected);\n\nstruct sock *vsock_find_bound_socket(struct sockaddr_vm *addr)\n{\n\tstruct sock *sk;\n\n\tspin_lock_bh(&vsock_table_lock);\n\tsk = __vsock_find_bound_socket(addr);\n\tif (sk)\n\t\tsock_hold(sk);\n\n\tspin_unlock_bh(&vsock_table_lock);\n\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(vsock_find_bound_socket);\n\nstruct sock *vsock_find_connected_socket(struct sockaddr_vm *src,\n\t\t\t\t\t struct sockaddr_vm *dst)\n{\n\tstruct sock *sk;\n\n\tspin_lock_bh(&vsock_table_lock);\n\tsk = __vsock_find_connected_socket(src, dst);\n\tif (sk)\n\t\tsock_hold(sk);\n\n\tspin_unlock_bh(&vsock_table_lock);\n\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(vsock_find_connected_socket);\n\nvoid vsock_remove_sock(struct vsock_sock *vsk)\n{\n\tvsock_remove_bound(vsk);\n\tvsock_remove_connected(vsk);\n}\nEXPORT_SYMBOL_GPL(vsock_remove_sock);\n\nvoid vsock_for_each_connected_socket(struct vsock_transport *transport,\n\t\t\t\t     void (*fn)(struct sock *sk))\n{\n\tint i;\n\n\tspin_lock_bh(&vsock_table_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(vsock_connected_table); i++) {\n\t\tstruct vsock_sock *vsk;\n\t\tlist_for_each_entry(vsk, &vsock_connected_table[i],\n\t\t\t\t    connected_table) {\n\t\t\tif (vsk->transport != transport)\n\t\t\t\tcontinue;\n\n\t\t\tfn(sk_vsock(vsk));\n\t\t}\n\t}\n\n\tspin_unlock_bh(&vsock_table_lock);\n}\nEXPORT_SYMBOL_GPL(vsock_for_each_connected_socket);\n\nvoid vsock_add_pending(struct sock *listener, struct sock *pending)\n{\n\tstruct vsock_sock *vlistener;\n\tstruct vsock_sock *vpending;\n\n\tvlistener = vsock_sk(listener);\n\tvpending = vsock_sk(pending);\n\n\tsock_hold(pending);\n\tsock_hold(listener);\n\tlist_add_tail(&vpending->pending_links, &vlistener->pending_links);\n}\nEXPORT_SYMBOL_GPL(vsock_add_pending);\n\nvoid vsock_remove_pending(struct sock *listener, struct sock *pending)\n{\n\tstruct vsock_sock *vpending = vsock_sk(pending);\n\n\tlist_del_init(&vpending->pending_links);\n\tsock_put(listener);\n\tsock_put(pending);\n}\nEXPORT_SYMBOL_GPL(vsock_remove_pending);\n\nvoid vsock_enqueue_accept(struct sock *listener, struct sock *connected)\n{\n\tstruct vsock_sock *vlistener;\n\tstruct vsock_sock *vconnected;\n\n\tvlistener = vsock_sk(listener);\n\tvconnected = vsock_sk(connected);\n\n\tsock_hold(connected);\n\tsock_hold(listener);\n\tlist_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);\n}\nEXPORT_SYMBOL_GPL(vsock_enqueue_accept);\n\nstatic bool vsock_use_local_transport(unsigned int remote_cid)\n{\n\tif (!transport_local)\n\t\treturn false;\n\n\tif (remote_cid == VMADDR_CID_LOCAL)\n\t\treturn true;\n\n\tif (transport_g2h) {\n\t\treturn remote_cid == transport_g2h->get_local_cid();\n\t} else {\n\t\treturn remote_cid == VMADDR_CID_HOST;\n\t}\n}\n\nstatic void vsock_deassign_transport(struct vsock_sock *vsk)\n{\n\tif (!vsk->transport)\n\t\treturn;\n\n\tvsk->transport->destruct(vsk);\n\tmodule_put(vsk->transport->module);\n\tvsk->transport = NULL;\n}\n\n \nint vsock_assign_transport(struct vsock_sock *vsk, struct vsock_sock *psk)\n{\n\tconst struct vsock_transport *new_transport;\n\tstruct sock *sk = sk_vsock(vsk);\n\tunsigned int remote_cid = vsk->remote_addr.svm_cid;\n\t__u8 remote_flags;\n\tint ret;\n\n\t \n\tif (psk && vsk->local_addr.svm_cid > VMADDR_CID_HOST &&\n\t    vsk->remote_addr.svm_cid > VMADDR_CID_HOST)\n\t\tvsk->remote_addr.svm_flags |= VMADDR_FLAG_TO_HOST;\n\n\tremote_flags = vsk->remote_addr.svm_flags;\n\n\tswitch (sk->sk_type) {\n\tcase SOCK_DGRAM:\n\t\tnew_transport = transport_dgram;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\tcase SOCK_SEQPACKET:\n\t\tif (vsock_use_local_transport(remote_cid))\n\t\t\tnew_transport = transport_local;\n\t\telse if (remote_cid <= VMADDR_CID_HOST || !transport_h2g ||\n\t\t\t (remote_flags & VMADDR_FLAG_TO_HOST))\n\t\t\tnew_transport = transport_g2h;\n\t\telse\n\t\t\tnew_transport = transport_h2g;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tif (vsk->transport) {\n\t\tif (vsk->transport == new_transport)\n\t\t\treturn 0;\n\n\t\t \n\t\tvsk->transport->release(vsk);\n\t\tvsock_deassign_transport(vsk);\n\t}\n\n\t \n\tif (!new_transport || !try_module_get(new_transport->module))\n\t\treturn -ENODEV;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tif (!new_transport->seqpacket_allow ||\n\t\t    !new_transport->seqpacket_allow(remote_cid)) {\n\t\t\tmodule_put(new_transport->module);\n\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t}\n\t}\n\n\tret = new_transport->init(vsk, psk);\n\tif (ret) {\n\t\tmodule_put(new_transport->module);\n\t\treturn ret;\n\t}\n\n\tvsk->transport = new_transport;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vsock_assign_transport);\n\nbool vsock_find_cid(unsigned int cid)\n{\n\tif (transport_g2h && cid == transport_g2h->get_local_cid())\n\t\treturn true;\n\n\tif (transport_h2g && cid == VMADDR_CID_HOST)\n\t\treturn true;\n\n\tif (transport_local && cid == VMADDR_CID_LOCAL)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(vsock_find_cid);\n\nstatic struct sock *vsock_dequeue_accept(struct sock *listener)\n{\n\tstruct vsock_sock *vlistener;\n\tstruct vsock_sock *vconnected;\n\n\tvlistener = vsock_sk(listener);\n\n\tif (list_empty(&vlistener->accept_queue))\n\t\treturn NULL;\n\n\tvconnected = list_entry(vlistener->accept_queue.next,\n\t\t\t\tstruct vsock_sock, accept_queue);\n\n\tlist_del_init(&vconnected->accept_queue);\n\tsock_put(listener);\n\t \n\n\treturn sk_vsock(vconnected);\n}\n\nstatic bool vsock_is_accept_queue_empty(struct sock *sk)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\treturn list_empty(&vsk->accept_queue);\n}\n\nstatic bool vsock_is_pending(struct sock *sk)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\treturn !list_empty(&vsk->pending_links);\n}\n\nstatic int vsock_send_shutdown(struct sock *sk, int mode)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tif (!vsk->transport)\n\t\treturn -ENODEV;\n\n\treturn vsk->transport->shutdown(vsk, mode);\n}\n\nstatic void vsock_pending_work(struct work_struct *work)\n{\n\tstruct sock *sk;\n\tstruct sock *listener;\n\tstruct vsock_sock *vsk;\n\tbool cleanup;\n\n\tvsk = container_of(work, struct vsock_sock, pending_work.work);\n\tsk = sk_vsock(vsk);\n\tlistener = vsk->listener;\n\tcleanup = true;\n\n\tlock_sock(listener);\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tif (vsock_is_pending(sk)) {\n\t\tvsock_remove_pending(listener, sk);\n\n\t\tsk_acceptq_removed(listener);\n\t} else if (!vsk->rejected) {\n\t\t \n\t\tcleanup = false;\n\t\tgoto out;\n\t}\n\n\t \n\tvsock_remove_connected(vsk);\n\n\tsk->sk_state = TCP_CLOSE;\n\nout:\n\trelease_sock(sk);\n\trelease_sock(listener);\n\tif (cleanup)\n\t\tsock_put(sk);\n\n\tsock_put(sk);\n\tsock_put(listener);\n}\n\n \n\nstatic int __vsock_bind_connectible(struct vsock_sock *vsk,\n\t\t\t\t    struct sockaddr_vm *addr)\n{\n\tstatic u32 port;\n\tstruct sockaddr_vm new_addr;\n\n\tif (!port)\n\t\tport = get_random_u32_above(LAST_RESERVED_PORT);\n\n\tvsock_addr_init(&new_addr, addr->svm_cid, addr->svm_port);\n\n\tif (addr->svm_port == VMADDR_PORT_ANY) {\n\t\tbool found = false;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < MAX_PORT_RETRIES; i++) {\n\t\t\tif (port <= LAST_RESERVED_PORT)\n\t\t\t\tport = LAST_RESERVED_PORT + 1;\n\n\t\t\tnew_addr.svm_port = port++;\n\n\t\t\tif (!__vsock_find_bound_socket(&new_addr)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn -EADDRNOTAVAIL;\n\t} else {\n\t\t \n\t\tif (addr->svm_port <= LAST_RESERVED_PORT &&\n\t\t    !capable(CAP_NET_BIND_SERVICE)) {\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (__vsock_find_bound_socket(&new_addr))\n\t\t\treturn -EADDRINUSE;\n\t}\n\n\tvsock_addr_init(&vsk->local_addr, new_addr.svm_cid, new_addr.svm_port);\n\n\t \n\t__vsock_remove_bound(vsk);\n\t__vsock_insert_bound(vsock_bound_sockets(&vsk->local_addr), vsk);\n\n\treturn 0;\n}\n\nstatic int __vsock_bind_dgram(struct vsock_sock *vsk,\n\t\t\t      struct sockaddr_vm *addr)\n{\n\treturn vsk->transport->dgram_bind(vsk, addr);\n}\n\nstatic int __vsock_bind(struct sock *sk, struct sockaddr_vm *addr)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\tint retval;\n\n\t \n\tif (vsock_addr_bound(&vsk->local_addr))\n\t\treturn -EINVAL;\n\n\t \n\tif (addr->svm_cid != VMADDR_CID_ANY && !vsock_find_cid(addr->svm_cid))\n\t\treturn -EADDRNOTAVAIL;\n\n\tswitch (sk->sk_socket->type) {\n\tcase SOCK_STREAM:\n\tcase SOCK_SEQPACKET:\n\t\tspin_lock_bh(&vsock_table_lock);\n\t\tretval = __vsock_bind_connectible(vsk, addr);\n\t\tspin_unlock_bh(&vsock_table_lock);\n\t\tbreak;\n\n\tcase SOCK_DGRAM:\n\t\tretval = __vsock_bind_dgram(vsk, addr);\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\nstatic void vsock_connect_timeout(struct work_struct *work);\n\nstatic struct sock *__vsock_create(struct net *net,\n\t\t\t\t   struct socket *sock,\n\t\t\t\t   struct sock *parent,\n\t\t\t\t   gfp_t priority,\n\t\t\t\t   unsigned short type,\n\t\t\t\t   int kern)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *psk;\n\tstruct vsock_sock *vsk;\n\n\tsk = sk_alloc(net, AF_VSOCK, priority, &vsock_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\n\t \n\tif (!sock)\n\t\tsk->sk_type = type;\n\n\tvsk = vsock_sk(sk);\n\tvsock_addr_init(&vsk->local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\tvsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\n\tsk->sk_destruct = vsock_sk_destruct;\n\tsk->sk_backlog_rcv = vsock_queue_rcv_skb;\n\tsock_reset_flag(sk, SOCK_DONE);\n\n\tINIT_LIST_HEAD(&vsk->bound_table);\n\tINIT_LIST_HEAD(&vsk->connected_table);\n\tvsk->listener = NULL;\n\tINIT_LIST_HEAD(&vsk->pending_links);\n\tINIT_LIST_HEAD(&vsk->accept_queue);\n\tvsk->rejected = false;\n\tvsk->sent_request = false;\n\tvsk->ignore_connecting_rst = false;\n\tvsk->peer_shutdown = 0;\n\tINIT_DELAYED_WORK(&vsk->connect_work, vsock_connect_timeout);\n\tINIT_DELAYED_WORK(&vsk->pending_work, vsock_pending_work);\n\n\tpsk = parent ? vsock_sk(parent) : NULL;\n\tif (parent) {\n\t\tvsk->trusted = psk->trusted;\n\t\tvsk->owner = get_cred(psk->owner);\n\t\tvsk->connect_timeout = psk->connect_timeout;\n\t\tvsk->buffer_size = psk->buffer_size;\n\t\tvsk->buffer_min_size = psk->buffer_min_size;\n\t\tvsk->buffer_max_size = psk->buffer_max_size;\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tvsk->trusted = ns_capable_noaudit(&init_user_ns, CAP_NET_ADMIN);\n\t\tvsk->owner = get_current_cred();\n\t\tvsk->connect_timeout = VSOCK_DEFAULT_CONNECT_TIMEOUT;\n\t\tvsk->buffer_size = VSOCK_DEFAULT_BUFFER_SIZE;\n\t\tvsk->buffer_min_size = VSOCK_DEFAULT_BUFFER_MIN_SIZE;\n\t\tvsk->buffer_max_size = VSOCK_DEFAULT_BUFFER_MAX_SIZE;\n\t}\n\n\treturn sk;\n}\n\nstatic bool sock_type_connectible(u16 type)\n{\n\treturn (type == SOCK_STREAM) || (type == SOCK_SEQPACKET);\n}\n\nstatic void __vsock_release(struct sock *sk, int level)\n{\n\tif (sk) {\n\t\tstruct sock *pending;\n\t\tstruct vsock_sock *vsk;\n\n\t\tvsk = vsock_sk(sk);\n\t\tpending = NULL;\t \n\n\t\t \n\t\tlock_sock_nested(sk, level);\n\n\t\tif (vsk->transport)\n\t\t\tvsk->transport->release(vsk);\n\t\telse if (sock_type_connectible(sk->sk_type))\n\t\t\tvsock_remove_sock(vsk);\n\n\t\tsock_orphan(sk);\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\n\t\tskb_queue_purge(&sk->sk_receive_queue);\n\n\t\t \n\t\twhile ((pending = vsock_dequeue_accept(sk)) != NULL) {\n\t\t\t__vsock_release(pending, SINGLE_DEPTH_NESTING);\n\t\t\tsock_put(pending);\n\t\t}\n\n\t\trelease_sock(sk);\n\t\tsock_put(sk);\n\t}\n}\n\nstatic void vsock_sk_destruct(struct sock *sk)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tvsock_deassign_transport(vsk);\n\n\t \n\tvsock_addr_init(&vsk->local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\tvsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\n\tput_cred(vsk->owner);\n}\n\nstatic int vsock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\n\terr = sock_queue_rcv_skb(sk, skb);\n\tif (err)\n\t\tkfree_skb(skb);\n\n\treturn err;\n}\n\nstruct sock *vsock_create_connected(struct sock *parent)\n{\n\treturn __vsock_create(sock_net(parent), NULL, parent, GFP_KERNEL,\n\t\t\t      parent->sk_type, 0);\n}\nEXPORT_SYMBOL_GPL(vsock_create_connected);\n\ns64 vsock_stream_has_data(struct vsock_sock *vsk)\n{\n\treturn vsk->transport->stream_has_data(vsk);\n}\nEXPORT_SYMBOL_GPL(vsock_stream_has_data);\n\ns64 vsock_connectible_has_data(struct vsock_sock *vsk)\n{\n\tstruct sock *sk = sk_vsock(vsk);\n\n\tif (sk->sk_type == SOCK_SEQPACKET)\n\t\treturn vsk->transport->seqpacket_has_data(vsk);\n\telse\n\t\treturn vsock_stream_has_data(vsk);\n}\nEXPORT_SYMBOL_GPL(vsock_connectible_has_data);\n\ns64 vsock_stream_has_space(struct vsock_sock *vsk)\n{\n\treturn vsk->transport->stream_has_space(vsk);\n}\nEXPORT_SYMBOL_GPL(vsock_stream_has_space);\n\nvoid vsock_data_ready(struct sock *sk)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tif (vsock_stream_has_data(vsk) >= sk->sk_rcvlowat ||\n\t    sock_flag(sk, SOCK_DONE))\n\t\tsk->sk_data_ready(sk);\n}\nEXPORT_SYMBOL_GPL(vsock_data_ready);\n\nstatic int vsock_release(struct socket *sock)\n{\n\t__vsock_release(sock->sk, 0);\n\tsock->sk = NULL;\n\tsock->state = SS_FREE;\n\n\treturn 0;\n}\n\nstatic int\nvsock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct sockaddr_vm *vm_addr;\n\n\tsk = sock->sk;\n\n\tif (vsock_addr_cast(addr, addr_len, &vm_addr) != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\terr = __vsock_bind(sk, vm_addr);\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int vsock_getname(struct socket *sock,\n\t\t\t struct sockaddr *addr, int peer)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tstruct sockaddr_vm *vm_addr;\n\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\terr = 0;\n\n\tlock_sock(sk);\n\n\tif (peer) {\n\t\tif (sock->state != SS_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tvm_addr = &vsk->remote_addr;\n\t} else {\n\t\tvm_addr = &vsk->local_addr;\n\t}\n\n\tif (!vm_addr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tBUILD_BUG_ON(sizeof(*vm_addr) > 128);\n\tmemcpy(addr, vm_addr, sizeof(*vm_addr));\n\terr = sizeof(*vm_addr);\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int vsock_shutdown(struct socket *sock, int mode)\n{\n\tint err;\n\tstruct sock *sk;\n\n\t \n\tmode++;\n\n\tif ((mode & ~SHUTDOWN_MASK) || !mode)\n\t\treturn -EINVAL;\n\n\t \n\n\tsk = sock->sk;\n\n\tlock_sock(sk);\n\tif (sock->state == SS_UNCONNECTED) {\n\t\terr = -ENOTCONN;\n\t\tif (sock_type_connectible(sk->sk_type))\n\t\t\tgoto out;\n\t} else {\n\t\tsock->state = SS_DISCONNECTING;\n\t\terr = 0;\n\t}\n\n\t \n\tmode = mode & (RCV_SHUTDOWN | SEND_SHUTDOWN);\n\tif (mode) {\n\t\tsk->sk_shutdown |= mode;\n\t\tsk->sk_state_change(sk);\n\n\t\tif (sock_type_connectible(sk->sk_type)) {\n\t\t\tsock_reset_flag(sk, SOCK_DONE);\n\t\t\tvsock_send_shutdown(sk, mode);\n\t\t}\n\t}\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic __poll_t vsock_poll(struct file *file, struct socket *sock,\n\t\t\t       poll_table *wait)\n{\n\tstruct sock *sk;\n\t__poll_t mask;\n\tstruct vsock_sock *vsk;\n\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\n\tpoll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\n\tif (sk->sk_err)\n\t\t \n\t\tmask |= EPOLLERR;\n\n\t \n\tif ((sk->sk_shutdown == SHUTDOWN_MASK) ||\n\t    ((sk->sk_shutdown & SEND_SHUTDOWN) &&\n\t     (vsk->peer_shutdown & SEND_SHUTDOWN))) {\n\t\tmask |= EPOLLHUP;\n\t}\n\n\tif (sk->sk_shutdown & RCV_SHUTDOWN ||\n\t    vsk->peer_shutdown & SEND_SHUTDOWN) {\n\t\tmask |= EPOLLRDHUP;\n\t}\n\n\tif (sock->type == SOCK_DGRAM) {\n\t\t \n\t\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue) ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN)) {\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t\t}\n\n\t\tif (!(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;\n\n\t} else if (sock_type_connectible(sk->sk_type)) {\n\t\tconst struct vsock_transport *transport;\n\n\t\tlock_sock(sk);\n\n\t\ttransport = vsk->transport;\n\n\t\t \n\t\tif (sk->sk_state == TCP_LISTEN\n\t\t    && !vsock_is_accept_queue_empty(sk))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\t\t \n\t\tif (transport && transport->stream_is_active(vsk) &&\n\t\t    !(sk->sk_shutdown & RCV_SHUTDOWN)) {\n\t\t\tbool data_ready_now = false;\n\t\t\tint target = sock_rcvlowat(sk, 0, INT_MAX);\n\t\t\tint ret = transport->notify_poll_in(\n\t\t\t\t\tvsk, target, &data_ready_now);\n\t\t\tif (ret < 0) {\n\t\t\t\tmask |= EPOLLERR;\n\t\t\t} else {\n\t\t\t\tif (data_ready_now)\n\t\t\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN ||\n\t\t    vsk->peer_shutdown & SEND_SHUTDOWN) {\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t\t}\n\n\t\t \n\t\tif (transport && sk->sk_state == TCP_ESTABLISHED) {\n\t\t\tif (!(sk->sk_shutdown & SEND_SHUTDOWN)) {\n\t\t\t\tbool space_avail_now = false;\n\t\t\t\tint ret = transport->notify_poll_out(\n\t\t\t\t\t\tvsk, 1, &space_avail_now);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tmask |= EPOLLERR;\n\t\t\t\t} else {\n\t\t\t\t\tif (space_avail_now)\n\t\t\t\t\t\t \n\t\t\t\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (sk->sk_state == TCP_CLOSE || sk->sk_state == TCP_CLOSING) {\n\t\t\tif (!(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\t\t}\n\n\t\trelease_sock(sk);\n\t}\n\n\treturn mask;\n}\n\nstatic int vsock_read_skb(struct sock *sk, skb_read_actor_t read_actor)\n{\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\treturn vsk->transport->read_skb(vsk, read_actor);\n}\n\nstatic int vsock_dgram_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t len)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tstruct sockaddr_vm *remote_addr;\n\tconst struct vsock_transport *transport;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terr = 0;\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\n\tlock_sock(sk);\n\n\ttransport = vsk->transport;\n\n\terr = vsock_auto_bind(vsk);\n\tif (err)\n\t\tgoto out;\n\n\n\t \n\tif (msg->msg_name &&\n\t    vsock_addr_cast(msg->msg_name, msg->msg_namelen,\n\t\t\t    &remote_addr) == 0) {\n\t\t \n\n\t\tif (remote_addr->svm_cid == VMADDR_CID_ANY)\n\t\t\tremote_addr->svm_cid = transport->get_local_cid();\n\n\t\tif (!vsock_addr_bound(remote_addr)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else if (sock->state == SS_CONNECTED) {\n\t\tremote_addr = &vsk->remote_addr;\n\n\t\tif (remote_addr->svm_cid == VMADDR_CID_ANY)\n\t\t\tremote_addr->svm_cid = transport->get_local_cid();\n\n\t\t \n\t\tif (!vsock_addr_bound(&vsk->remote_addr)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!transport->dgram_allow(remote_addr->svm_cid,\n\t\t\t\t    remote_addr->svm_port)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = transport->dgram_enqueue(vsk, remote_addr, msg, len);\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int vsock_dgram_connect(struct socket *sock,\n\t\t\t       struct sockaddr *addr, int addr_len, int flags)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tstruct sockaddr_vm *remote_addr;\n\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\n\terr = vsock_addr_cast(addr, addr_len, &remote_addr);\n\tif (err == -EAFNOSUPPORT && remote_addr->svm_family == AF_UNSPEC) {\n\t\tlock_sock(sk);\n\t\tvsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY,\n\t\t\t\tVMADDR_PORT_ANY);\n\t\tsock->state = SS_UNCONNECTED;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t} else if (err != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\terr = vsock_auto_bind(vsk);\n\tif (err)\n\t\tgoto out;\n\n\tif (!vsk->transport->dgram_allow(remote_addr->svm_cid,\n\t\t\t\t\t remote_addr->svm_port)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(&vsk->remote_addr, remote_addr, sizeof(vsk->remote_addr));\n\tsock->state = SS_CONNECTED;\n\n\t \n\tsk->sk_state = TCP_ESTABLISHED;\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nint vsock_dgram_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t len, int flags)\n{\n#ifdef CONFIG_BPF_SYSCALL\n\tconst struct proto *prot;\n#endif\n\tstruct vsock_sock *vsk;\n\tstruct sock *sk;\n\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\n#ifdef CONFIG_BPF_SYSCALL\n\tprot = READ_ONCE(sk->sk_prot);\n\tif (prot != &vsock_proto)\n\t\treturn prot->recvmsg(sk, msg, len, flags, NULL);\n#endif\n\n\treturn vsk->transport->dgram_dequeue(vsk, msg, len, flags);\n}\nEXPORT_SYMBOL_GPL(vsock_dgram_recvmsg);\n\nstatic const struct proto_ops vsock_dgram_ops = {\n\t.family = PF_VSOCK,\n\t.owner = THIS_MODULE,\n\t.release = vsock_release,\n\t.bind = vsock_bind,\n\t.connect = vsock_dgram_connect,\n\t.socketpair = sock_no_socketpair,\n\t.accept = sock_no_accept,\n\t.getname = vsock_getname,\n\t.poll = vsock_poll,\n\t.ioctl = sock_no_ioctl,\n\t.listen = sock_no_listen,\n\t.shutdown = vsock_shutdown,\n\t.sendmsg = vsock_dgram_sendmsg,\n\t.recvmsg = vsock_dgram_recvmsg,\n\t.mmap = sock_no_mmap,\n\t.read_skb = vsock_read_skb,\n};\n\nstatic int vsock_transport_cancel_pkt(struct vsock_sock *vsk)\n{\n\tconst struct vsock_transport *transport = vsk->transport;\n\n\tif (!transport || !transport->cancel_pkt)\n\t\treturn -EOPNOTSUPP;\n\n\treturn transport->cancel_pkt(vsk);\n}\n\nstatic void vsock_connect_timeout(struct work_struct *work)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\n\tvsk = container_of(work, struct vsock_sock, connect_work.work);\n\tsk = sk_vsock(vsk);\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_SYN_SENT &&\n\t    (sk->sk_shutdown != SHUTDOWN_MASK)) {\n\t\tsk->sk_state = TCP_CLOSE;\n\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\tsk->sk_err = ETIMEDOUT;\n\t\tsk_error_report(sk);\n\t\tvsock_transport_cancel_pkt(vsk);\n\t}\n\trelease_sock(sk);\n\n\tsock_put(sk);\n}\n\nstatic int vsock_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len, int flags)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tconst struct vsock_transport *transport;\n\tstruct sockaddr_vm *remote_addr;\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\n\terr = 0;\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\n\tlock_sock(sk);\n\n\t \n\tswitch (sock->state) {\n\tcase SS_CONNECTED:\n\t\terr = -EISCONN;\n\t\tgoto out;\n\tcase SS_DISCONNECTING:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\tcase SS_CONNECTING:\n\t\t \n\t\terr = -EALREADY;\n\t\tif (flags & O_NONBLOCK)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tif ((sk->sk_state == TCP_LISTEN) ||\n\t\t    vsock_addr_cast(addr, addr_len, &remote_addr) != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tmemcpy(&vsk->remote_addr, remote_addr,\n\t\t       sizeof(vsk->remote_addr));\n\n\t\terr = vsock_assign_transport(vsk, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttransport = vsk->transport;\n\n\t\t \n\t\tif (!transport ||\n\t\t    !transport->stream_allow(remote_addr->svm_cid,\n\t\t\t\t\t     remote_addr->svm_port)) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = vsock_auto_bind(vsk);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tsk->sk_state = TCP_SYN_SENT;\n\n\t\terr = transport->connect(vsk);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tsock->state = SS_CONNECTING;\n\t\terr = -EINPROGRESS;\n\t}\n\n\t \n\ttimeout = vsk->connect_timeout;\n\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\twhile (sk->sk_state != TCP_ESTABLISHED && sk->sk_err == 0) {\n\t\tif (flags & O_NONBLOCK) {\n\t\t\t \n\t\t\tsock_hold(sk);\n\n\t\t\t \n\t\t\tif (mod_delayed_work(system_wq, &vsk->connect_work,\n\t\t\t\t\t     timeout))\n\t\t\t\tsock_put(sk);\n\n\t\t\t \n\t\t\tgoto out_wait;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tlock_sock(sk);\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeout);\n\t\t\tsk->sk_state = sk->sk_state == TCP_ESTABLISHED ? TCP_CLOSING : TCP_CLOSE;\n\t\t\tsock->state = SS_UNCONNECTED;\n\t\t\tvsock_transport_cancel_pkt(vsk);\n\t\t\tvsock_remove_connected(vsk);\n\t\t\tgoto out_wait;\n\t\t} else if ((sk->sk_state != TCP_ESTABLISHED) && (timeout == 0)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tsk->sk_state = TCP_CLOSE;\n\t\t\tsock->state = SS_UNCONNECTED;\n\t\t\tvsock_transport_cancel_pkt(vsk);\n\t\t\tgoto out_wait;\n\t\t}\n\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t}\n\n\tif (sk->sk_err) {\n\t\terr = -sk->sk_err;\n\t\tsk->sk_state = TCP_CLOSE;\n\t\tsock->state = SS_UNCONNECTED;\n\t} else {\n\t\terr = 0;\n\t}\n\nout_wait:\n\tfinish_wait(sk_sleep(sk), &wait);\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int vsock_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t\tbool kern)\n{\n\tstruct sock *listener;\n\tint err;\n\tstruct sock *connected;\n\tstruct vsock_sock *vconnected;\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\n\terr = 0;\n\tlistener = sock->sk;\n\n\tlock_sock(listener);\n\n\tif (!sock_type_connectible(sock->type)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (listener->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\ttimeout = sock_rcvtimeo(listener, flags & O_NONBLOCK);\n\tprepare_to_wait(sk_sleep(listener), &wait, TASK_INTERRUPTIBLE);\n\n\twhile ((connected = vsock_dequeue_accept(listener)) == NULL &&\n\t       listener->sk_err == 0) {\n\t\trelease_sock(listener);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tfinish_wait(sk_sleep(listener), &wait);\n\t\tlock_sock(listener);\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeout);\n\t\t\tgoto out;\n\t\t} else if (timeout == 0) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprepare_to_wait(sk_sleep(listener), &wait, TASK_INTERRUPTIBLE);\n\t}\n\tfinish_wait(sk_sleep(listener), &wait);\n\n\tif (listener->sk_err)\n\t\terr = -listener->sk_err;\n\n\tif (connected) {\n\t\tsk_acceptq_removed(listener);\n\n\t\tlock_sock_nested(connected, SINGLE_DEPTH_NESTING);\n\t\tvconnected = vsock_sk(connected);\n\n\t\t \n\t\tif (err) {\n\t\t\tvconnected->rejected = true;\n\t\t} else {\n\t\t\tnewsock->state = SS_CONNECTED;\n\t\t\tsock_graft(connected, newsock);\n\t\t}\n\n\t\trelease_sock(connected);\n\t\tsock_put(connected);\n\t}\n\nout:\n\trelease_sock(listener);\n\treturn err;\n}\n\nstatic int vsock_listen(struct socket *sock, int backlog)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\n\tsk = sock->sk;\n\n\tlock_sock(sk);\n\n\tif (!sock_type_connectible(sk->sk_type)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (sock->state != SS_UNCONNECTED) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tvsk = vsock_sk(sk);\n\n\tif (!vsock_addr_bound(&vsk->local_addr)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_state = TCP_LISTEN;\n\n\terr = 0;\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic void vsock_update_buffer_size(struct vsock_sock *vsk,\n\t\t\t\t     const struct vsock_transport *transport,\n\t\t\t\t     u64 val)\n{\n\tif (val > vsk->buffer_max_size)\n\t\tval = vsk->buffer_max_size;\n\n\tif (val < vsk->buffer_min_size)\n\t\tval = vsk->buffer_min_size;\n\n\tif (val != vsk->buffer_size &&\n\t    transport && transport->notify_buffer_size)\n\t\ttransport->notify_buffer_size(vsk, &val);\n\n\tvsk->buffer_size = val;\n}\n\nstatic int vsock_connectible_setsockopt(struct socket *sock,\n\t\t\t\t\tint level,\n\t\t\t\t\tint optname,\n\t\t\t\t\tsockptr_t optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tconst struct vsock_transport *transport;\n\tu64 val;\n\n\tif (level != AF_VSOCK)\n\t\treturn -ENOPROTOOPT;\n\n#define COPY_IN(_v)                                       \\\n\tdo {\t\t\t\t\t\t  \\\n\t\tif (optlen < sizeof(_v)) {\t\t  \\\n\t\t\terr = -EINVAL;\t\t\t  \\\n\t\t\tgoto exit;\t\t\t  \\\n\t\t}\t\t\t\t\t  \\\n\t\tif (copy_from_sockptr(&_v, optval, sizeof(_v)) != 0) {\t\\\n\t\t\terr = -EFAULT;\t\t\t\t\t\\\n\t\t\tgoto exit;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\terr = 0;\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\n\tlock_sock(sk);\n\n\ttransport = vsk->transport;\n\n\tswitch (optname) {\n\tcase SO_VM_SOCKETS_BUFFER_SIZE:\n\t\tCOPY_IN(val);\n\t\tvsock_update_buffer_size(vsk, transport, val);\n\t\tbreak;\n\n\tcase SO_VM_SOCKETS_BUFFER_MAX_SIZE:\n\t\tCOPY_IN(val);\n\t\tvsk->buffer_max_size = val;\n\t\tvsock_update_buffer_size(vsk, transport, vsk->buffer_size);\n\t\tbreak;\n\n\tcase SO_VM_SOCKETS_BUFFER_MIN_SIZE:\n\t\tCOPY_IN(val);\n\t\tvsk->buffer_min_size = val;\n\t\tvsock_update_buffer_size(vsk, transport, vsk->buffer_size);\n\t\tbreak;\n\n\tcase SO_VM_SOCKETS_CONNECT_TIMEOUT_NEW:\n\tcase SO_VM_SOCKETS_CONNECT_TIMEOUT_OLD: {\n\t\tstruct __kernel_sock_timeval tv;\n\n\t\terr = sock_copy_user_timeval(&tv, optval, optlen,\n\t\t\t\t\t     optname == SO_VM_SOCKETS_CONNECT_TIMEOUT_OLD);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (tv.tv_sec >= 0 && tv.tv_usec < USEC_PER_SEC &&\n\t\t    tv.tv_sec < (MAX_SCHEDULE_TIMEOUT / HZ - 1)) {\n\t\t\tvsk->connect_timeout = tv.tv_sec * HZ +\n\t\t\t\tDIV_ROUND_UP((unsigned long)tv.tv_usec, (USEC_PER_SEC / HZ));\n\t\t\tif (vsk->connect_timeout == 0)\n\t\t\t\tvsk->connect_timeout =\n\t\t\t\t    VSOCK_DEFAULT_CONNECT_TIMEOUT;\n\n\t\t} else {\n\t\t\terr = -ERANGE;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n#undef COPY_IN\n\nexit:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int vsock_connectible_getsockopt(struct socket *sock,\n\t\t\t\t\tint level, int optname,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\n\tunion {\n\t\tu64 val64;\n\t\tstruct old_timeval32 tm32;\n\t\tstruct __kernel_old_timeval tm;\n\t\tstruct  __kernel_sock_timeval stm;\n\t} v;\n\n\tint lv = sizeof(v.val64);\n\tint len;\n\n\tif (level != AF_VSOCK)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tmemset(&v, 0, sizeof(v));\n\n\tswitch (optname) {\n\tcase SO_VM_SOCKETS_BUFFER_SIZE:\n\t\tv.val64 = vsk->buffer_size;\n\t\tbreak;\n\n\tcase SO_VM_SOCKETS_BUFFER_MAX_SIZE:\n\t\tv.val64 = vsk->buffer_max_size;\n\t\tbreak;\n\n\tcase SO_VM_SOCKETS_BUFFER_MIN_SIZE:\n\t\tv.val64 = vsk->buffer_min_size;\n\t\tbreak;\n\n\tcase SO_VM_SOCKETS_CONNECT_TIMEOUT_NEW:\n\tcase SO_VM_SOCKETS_CONNECT_TIMEOUT_OLD:\n\t\tlv = sock_get_timeout(vsk->connect_timeout, &v,\n\t\t\t\t      optname == SO_VM_SOCKETS_CONNECT_TIMEOUT_OLD);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (len < lv)\n\t\treturn -EINVAL;\n\tif (len > lv)\n\t\tlen = lv;\n\tif (copy_to_user(optval, &v, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int vsock_connectible_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     size_t len)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tconst struct vsock_transport *transport;\n\tssize_t total_written;\n\tlong timeout;\n\tint err;\n\tstruct vsock_transport_send_notify_data send_data;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\ttotal_written = 0;\n\terr = 0;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\ttransport = vsk->transport;\n\n\t \n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sk->sk_shutdown & SEND_SHUTDOWN ||\n\t    vsk->peer_shutdown & RCV_SHUTDOWN) {\n\t\terr = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (!transport || sk->sk_state != TCP_ESTABLISHED ||\n\t    !vsock_addr_bound(&vsk->local_addr)) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tif (!vsock_addr_bound(&vsk->remote_addr)) {\n\t\terr = -EDESTADDRREQ;\n\t\tgoto out;\n\t}\n\n\t \n\ttimeout = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\n\terr = transport->notify_send_init(vsk, &send_data);\n\tif (err < 0)\n\t\tgoto out;\n\n\twhile (total_written < len) {\n\t\tssize_t written;\n\n\t\tadd_wait_queue(sk_sleep(sk), &wait);\n\t\twhile (vsock_stream_has_space(vsk) == 0 &&\n\t\t       sk->sk_err == 0 &&\n\t\t       !(sk->sk_shutdown & SEND_SHUTDOWN) &&\n\t\t       !(vsk->peer_shutdown & RCV_SHUTDOWN)) {\n\n\t\t\t \n\t\t\tif (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\terr = transport->notify_send_pre_block(vsk, &send_data);\n\t\t\tif (err < 0) {\n\t\t\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\trelease_sock(sk);\n\t\t\ttimeout = wait_woken(&wait, TASK_INTERRUPTIBLE, timeout);\n\t\t\tlock_sock(sk);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeout);\n\t\t\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\t\t\t\tgoto out_err;\n\t\t\t} else if (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\t\t \n\t\tif (sk->sk_err) {\n\t\t\terr = -sk->sk_err;\n\t\t\tgoto out_err;\n\t\t} else if ((sk->sk_shutdown & SEND_SHUTDOWN) ||\n\t\t\t   (vsk->peer_shutdown & RCV_SHUTDOWN)) {\n\t\t\terr = -EPIPE;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\terr = transport->notify_send_pre_enqueue(vsk, &send_data);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\n\t\t \n\n\t\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\t\twritten = transport->seqpacket_enqueue(vsk,\n\t\t\t\t\t\tmsg, len - total_written);\n\t\t} else {\n\t\t\twritten = transport->stream_enqueue(vsk,\n\t\t\t\t\tmsg, len - total_written);\n\t\t}\n\n\t\tif (written < 0) {\n\t\t\terr = written;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\ttotal_written += written;\n\n\t\terr = transport->notify_send_post_enqueue(\n\t\t\t\tvsk, written, &send_data);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\n\t}\n\nout_err:\n\tif (total_written > 0) {\n\t\t \n\t\tif (sk->sk_type == SOCK_STREAM || total_written == len)\n\t\t\terr = total_written;\n\t}\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int vsock_connectible_wait_data(struct sock *sk,\n\t\t\t\t       struct wait_queue_entry *wait,\n\t\t\t\t       long timeout,\n\t\t\t\t       struct vsock_transport_recv_notify_data *recv_data,\n\t\t\t\t       size_t target)\n{\n\tconst struct vsock_transport *transport;\n\tstruct vsock_sock *vsk;\n\ts64 data;\n\tint err;\n\n\tvsk = vsock_sk(sk);\n\terr = 0;\n\ttransport = vsk->transport;\n\n\twhile (1) {\n\t\tprepare_to_wait(sk_sleep(sk), wait, TASK_INTERRUPTIBLE);\n\t\tdata = vsock_connectible_has_data(vsk);\n\t\tif (data != 0)\n\t\t\tbreak;\n\n\t\tif (sk->sk_err != 0 ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t    (vsk->peer_shutdown & SEND_SHUTDOWN)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (timeout == 0) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (recv_data) {\n\t\t\terr = transport->notify_recv_pre_block(vsk, target, recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tlock_sock(sk);\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeout);\n\t\t\tbreak;\n\t\t} else if (timeout == 0) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(sk_sleep(sk), wait);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (data < 0)\n\t\treturn -ENOMEM;\n\n\treturn data;\n}\n\nstatic int __vsock_stream_recvmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t\t  size_t len, int flags)\n{\n\tstruct vsock_transport_recv_notify_data recv_data;\n\tconst struct vsock_transport *transport;\n\tstruct vsock_sock *vsk;\n\tssize_t copied;\n\tsize_t target;\n\tlong timeout;\n\tint err;\n\n\tDEFINE_WAIT(wait);\n\n\tvsk = vsock_sk(sk);\n\ttransport = vsk->transport;\n\n\t \n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tif (target >= transport->stream_rcvhiwat(vsk)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tcopied = 0;\n\n\terr = transport->notify_recv_init(vsk, target, &recv_data);\n\tif (err < 0)\n\t\tgoto out;\n\n\n\twhile (1) {\n\t\tssize_t read;\n\n\t\terr = vsock_connectible_wait_data(sk, &wait, timeout,\n\t\t\t\t\t\t  &recv_data, target);\n\t\tif (err <= 0)\n\t\t\tbreak;\n\n\t\terr = transport->notify_recv_pre_dequeue(vsk, target,\n\t\t\t\t\t\t\t &recv_data);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tread = transport->stream_dequeue(vsk, msg, len - copied, flags);\n\t\tif (read < 0) {\n\t\t\terr = read;\n\t\t\tbreak;\n\t\t}\n\n\t\tcopied += read;\n\n\t\terr = transport->notify_recv_post_dequeue(vsk, target, read,\n\t\t\t\t\t\t!(flags & MSG_PEEK), &recv_data);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tif (read >= target || flags & MSG_PEEK)\n\t\t\tbreak;\n\n\t\ttarget -= read;\n\t}\n\n\tif (sk->sk_err)\n\t\terr = -sk->sk_err;\n\telse if (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\terr = 0;\n\n\tif (copied > 0)\n\t\terr = copied;\n\nout:\n\treturn err;\n}\n\nstatic int __vsock_seqpacket_recvmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t\t     size_t len, int flags)\n{\n\tconst struct vsock_transport *transport;\n\tstruct vsock_sock *vsk;\n\tssize_t msg_len;\n\tlong timeout;\n\tint err = 0;\n\tDEFINE_WAIT(wait);\n\n\tvsk = vsock_sk(sk);\n\ttransport = vsk->transport;\n\n\ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\terr = vsock_connectible_wait_data(sk, &wait, timeout, NULL, 0);\n\tif (err <= 0)\n\t\tgoto out;\n\n\tmsg_len = transport->seqpacket_dequeue(vsk, msg, flags);\n\n\tif (msg_len < 0) {\n\t\terr = msg_len;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_err) {\n\t\terr = -sk->sk_err;\n\t} else if (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\terr = 0;\n\t} else {\n\t\t \n\t\tif (flags & MSG_TRUNC)\n\t\t\terr = msg_len;\n\t\telse\n\t\t\terr = len - msg_data_left(msg);\n\n\t\t \n\t\tif (msg_len > len)\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\nout:\n\treturn err;\n}\n\nint\nvsock_connectible_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t  int flags)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tconst struct vsock_transport *transport;\n#ifdef CONFIG_BPF_SYSCALL\n\tconst struct proto *prot;\n#endif\n\tint err;\n\n\tsk = sock->sk;\n\n\tif (unlikely(flags & MSG_ERRQUEUE))\n\t\treturn sock_recv_errqueue(sk, msg, len, SOL_VSOCK, VSOCK_RECVERR);\n\n\tvsk = vsock_sk(sk);\n\terr = 0;\n\n\tlock_sock(sk);\n\n\ttransport = vsk->transport;\n\n\tif (!transport || sk->sk_state != TCP_ESTABLISHED) {\n\t\t \n\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\terr = 0;\n\t\telse\n\t\t\terr = -ENOTCONN;\n\n\t\tgoto out;\n\t}\n\n\tif (flags & MSG_OOB) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!len) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_BPF_SYSCALL\n\tprot = READ_ONCE(sk->sk_prot);\n\tif (prot != &vsock_proto) {\n\t\trelease_sock(sk);\n\t\treturn prot->recvmsg(sk, msg, len, flags, NULL);\n\t}\n#endif\n\n\tif (sk->sk_type == SOCK_STREAM)\n\t\terr = __vsock_stream_recvmsg(sk, msg, len, flags);\n\telse\n\t\terr = __vsock_seqpacket_recvmsg(sk, msg, len, flags);\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vsock_connectible_recvmsg);\n\nstatic int vsock_set_rcvlowat(struct sock *sk, int val)\n{\n\tconst struct vsock_transport *transport;\n\tstruct vsock_sock *vsk;\n\n\tvsk = vsock_sk(sk);\n\n\tif (val > vsk->buffer_size)\n\t\treturn -EINVAL;\n\n\ttransport = vsk->transport;\n\n\tif (transport && transport->notify_set_rcvlowat) {\n\t\tint err;\n\n\t\terr = transport->notify_set_rcvlowat(vsk, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tWRITE_ONCE(sk->sk_rcvlowat, val ? : 1);\n\treturn 0;\n}\n\nstatic const struct proto_ops vsock_stream_ops = {\n\t.family = PF_VSOCK,\n\t.owner = THIS_MODULE,\n\t.release = vsock_release,\n\t.bind = vsock_bind,\n\t.connect = vsock_connect,\n\t.socketpair = sock_no_socketpair,\n\t.accept = vsock_accept,\n\t.getname = vsock_getname,\n\t.poll = vsock_poll,\n\t.ioctl = sock_no_ioctl,\n\t.listen = vsock_listen,\n\t.shutdown = vsock_shutdown,\n\t.setsockopt = vsock_connectible_setsockopt,\n\t.getsockopt = vsock_connectible_getsockopt,\n\t.sendmsg = vsock_connectible_sendmsg,\n\t.recvmsg = vsock_connectible_recvmsg,\n\t.mmap = sock_no_mmap,\n\t.set_rcvlowat = vsock_set_rcvlowat,\n\t.read_skb = vsock_read_skb,\n};\n\nstatic const struct proto_ops vsock_seqpacket_ops = {\n\t.family = PF_VSOCK,\n\t.owner = THIS_MODULE,\n\t.release = vsock_release,\n\t.bind = vsock_bind,\n\t.connect = vsock_connect,\n\t.socketpair = sock_no_socketpair,\n\t.accept = vsock_accept,\n\t.getname = vsock_getname,\n\t.poll = vsock_poll,\n\t.ioctl = sock_no_ioctl,\n\t.listen = vsock_listen,\n\t.shutdown = vsock_shutdown,\n\t.setsockopt = vsock_connectible_setsockopt,\n\t.getsockopt = vsock_connectible_getsockopt,\n\t.sendmsg = vsock_connectible_sendmsg,\n\t.recvmsg = vsock_connectible_recvmsg,\n\t.mmap = sock_no_mmap,\n\t.read_skb = vsock_read_skb,\n};\n\nstatic int vsock_create(struct net *net, struct socket *sock,\n\t\t\tint protocol, int kern)\n{\n\tstruct vsock_sock *vsk;\n\tstruct sock *sk;\n\tint ret;\n\n\tif (!sock)\n\t\treturn -EINVAL;\n\n\tif (protocol && protocol != PF_VSOCK)\n\t\treturn -EPROTONOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tsock->ops = &vsock_dgram_ops;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsock->ops = &vsock_stream_ops;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tsock->ops = &vsock_seqpacket_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsock->state = SS_UNCONNECTED;\n\n\tsk = __vsock_create(net, sock, NULL, GFP_KERNEL, 0, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tvsk = vsock_sk(sk);\n\n\tif (sock->type == SOCK_DGRAM) {\n\t\tret = vsock_assign_transport(vsk, NULL);\n\t\tif (ret < 0) {\n\t\t\tsock_put(sk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvsock_insert_unbound(vsk);\n\n\treturn 0;\n}\n\nstatic const struct net_proto_family vsock_family_ops = {\n\t.family = AF_VSOCK,\n\t.create = vsock_create,\n\t.owner = THIS_MODULE,\n};\n\nstatic long vsock_dev_do_ioctl(struct file *filp,\n\t\t\t       unsigned int cmd, void __user *ptr)\n{\n\tu32 __user *p = ptr;\n\tu32 cid = VMADDR_CID_ANY;\n\tint retval = 0;\n\n\tswitch (cmd) {\n\tcase IOCTL_VM_SOCKETS_GET_LOCAL_CID:\n\t\t \n\t\tif (transport_g2h)\n\t\t\tcid = transport_g2h->get_local_cid();\n\t\telse if (transport_h2g)\n\t\t\tcid = transport_h2g->get_local_cid();\n\n\t\tif (put_user(cid, p) != 0)\n\t\t\tretval = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -ENOIOCTLCMD;\n\t}\n\n\treturn retval;\n}\n\nstatic long vsock_dev_ioctl(struct file *filp,\n\t\t\t    unsigned int cmd, unsigned long arg)\n{\n\treturn vsock_dev_do_ioctl(filp, cmd, (void __user *)arg);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long vsock_dev_compat_ioctl(struct file *filp,\n\t\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\treturn vsock_dev_do_ioctl(filp, cmd, compat_ptr(arg));\n}\n#endif\n\nstatic const struct file_operations vsock_device_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= vsock_dev_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= vsock_dev_compat_ioctl,\n#endif\n\t.open\t\t= nonseekable_open,\n};\n\nstatic struct miscdevice vsock_device = {\n\t.name\t\t= \"vsock\",\n\t.fops\t\t= &vsock_device_ops,\n};\n\nstatic int __init vsock_init(void)\n{\n\tint err = 0;\n\n\tvsock_init_tables();\n\n\tvsock_proto.owner = THIS_MODULE;\n\tvsock_device.minor = MISC_DYNAMIC_MINOR;\n\terr = misc_register(&vsock_device);\n\tif (err) {\n\t\tpr_err(\"Failed to register misc device\\n\");\n\t\tgoto err_reset_transport;\n\t}\n\n\terr = proto_register(&vsock_proto, 1);\t \n\tif (err) {\n\t\tpr_err(\"Cannot register vsock protocol\\n\");\n\t\tgoto err_deregister_misc;\n\t}\n\n\terr = sock_register(&vsock_family_ops);\n\tif (err) {\n\t\tpr_err(\"could not register af_vsock (%d) address family: %d\\n\",\n\t\t       AF_VSOCK, err);\n\t\tgoto err_unregister_proto;\n\t}\n\n\tvsock_bpf_build_proto();\n\n\treturn 0;\n\nerr_unregister_proto:\n\tproto_unregister(&vsock_proto);\nerr_deregister_misc:\n\tmisc_deregister(&vsock_device);\nerr_reset_transport:\n\treturn err;\n}\n\nstatic void __exit vsock_exit(void)\n{\n\tmisc_deregister(&vsock_device);\n\tsock_unregister(AF_VSOCK);\n\tproto_unregister(&vsock_proto);\n}\n\nconst struct vsock_transport *vsock_core_get_transport(struct vsock_sock *vsk)\n{\n\treturn vsk->transport;\n}\nEXPORT_SYMBOL_GPL(vsock_core_get_transport);\n\nint vsock_core_register(const struct vsock_transport *t, int features)\n{\n\tconst struct vsock_transport *t_h2g, *t_g2h, *t_dgram, *t_local;\n\tint err = mutex_lock_interruptible(&vsock_register_mutex);\n\n\tif (err)\n\t\treturn err;\n\n\tt_h2g = transport_h2g;\n\tt_g2h = transport_g2h;\n\tt_dgram = transport_dgram;\n\tt_local = transport_local;\n\n\tif (features & VSOCK_TRANSPORT_F_H2G) {\n\t\tif (t_h2g) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto err_busy;\n\t\t}\n\t\tt_h2g = t;\n\t}\n\n\tif (features & VSOCK_TRANSPORT_F_G2H) {\n\t\tif (t_g2h) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto err_busy;\n\t\t}\n\t\tt_g2h = t;\n\t}\n\n\tif (features & VSOCK_TRANSPORT_F_DGRAM) {\n\t\tif (t_dgram) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto err_busy;\n\t\t}\n\t\tt_dgram = t;\n\t}\n\n\tif (features & VSOCK_TRANSPORT_F_LOCAL) {\n\t\tif (t_local) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto err_busy;\n\t\t}\n\t\tt_local = t;\n\t}\n\n\ttransport_h2g = t_h2g;\n\ttransport_g2h = t_g2h;\n\ttransport_dgram = t_dgram;\n\ttransport_local = t_local;\n\nerr_busy:\n\tmutex_unlock(&vsock_register_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vsock_core_register);\n\nvoid vsock_core_unregister(const struct vsock_transport *t)\n{\n\tmutex_lock(&vsock_register_mutex);\n\n\tif (transport_h2g == t)\n\t\ttransport_h2g = NULL;\n\n\tif (transport_g2h == t)\n\t\ttransport_g2h = NULL;\n\n\tif (transport_dgram == t)\n\t\ttransport_dgram = NULL;\n\n\tif (transport_local == t)\n\t\ttransport_local = NULL;\n\n\tmutex_unlock(&vsock_register_mutex);\n}\nEXPORT_SYMBOL_GPL(vsock_core_unregister);\n\nmodule_init(vsock_init);\nmodule_exit(vsock_exit);\n\nMODULE_AUTHOR(\"VMware, Inc.\");\nMODULE_DESCRIPTION(\"VMware Virtual Socket Family\");\nMODULE_VERSION(\"1.0.2.0-k\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}