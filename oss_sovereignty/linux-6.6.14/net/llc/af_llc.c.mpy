{
  "module_name": "af_llc.c",
  "hash_id": "ab32fd32ec0b9d566414c32c5cf0e3b34a50878f509c1c7194b34fb6e5b65050",
  "original_prompt": "Ingested from linux-6.6.14/net/llc/af_llc.c",
  "human_readable_source": " \n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/rtnetlink.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#include <net/llc.h>\n#include <net/llc_sap.h>\n#include <net/llc_pdu.h>\n#include <net/llc_conn.h>\n#include <net/tcp_states.h>\n\n \nstatic u16 llc_ui_sap_last_autoport = LLC_SAP_DYN_START;\nstatic u16 llc_ui_sap_link_no_max[256];\nstatic struct sockaddr_llc llc_ui_addrnull;\nstatic const struct proto_ops llc_ui_ops;\n\nstatic bool llc_ui_wait_for_conn(struct sock *sk, long timeout);\nstatic int llc_ui_wait_for_disc(struct sock *sk, long timeout);\nstatic int llc_ui_wait_for_busy_core(struct sock *sk, long timeout);\n\n#if 0\n#define dprintk(args...) printk(KERN_DEBUG args)\n#else\n#define dprintk(args...) do {} while (0)\n#endif\n\n \n#define LLC_CMSG_PKTINFO\t1\n\n\n \nstatic inline u16 llc_ui_next_link_no(int sap)\n{\n\treturn llc_ui_sap_link_no_max[sap]++;\n}\n\n \nstatic inline __be16 llc_proto_type(u16 arphrd)\n{\n\treturn htons(ETH_P_802_2);\n}\n\n \nstatic inline u8 llc_ui_addr_null(struct sockaddr_llc *addr)\n{\n\treturn !memcmp(addr, &llc_ui_addrnull, sizeof(*addr));\n}\n\n \nstatic inline u8 llc_ui_header_len(struct sock *sk, struct sockaddr_llc *addr)\n{\n\tu8 rc = LLC_PDU_LEN_U;\n\n\tif (addr->sllc_test)\n\t\trc = LLC_PDU_LEN_U;\n\telse if (addr->sllc_xid)\n\t\t \n\t\trc = LLC_PDU_LEN_U_XID;\n\telse if (sk->sk_type == SOCK_STREAM)\n\t\trc = LLC_PDU_LEN_I;\n\treturn rc;\n}\n\n \nstatic int llc_ui_send_data(struct sock* sk, struct sk_buff *skb, int noblock)\n{\n\tstruct llc_sock* llc = llc_sk(sk);\n\n\tif (unlikely(llc_data_accept_state(llc->state) ||\n\t\t     llc->remote_busy_flag ||\n\t\t     llc->p_flag)) {\n\t\tlong timeout = sock_sndtimeo(sk, noblock);\n\t\tint rc;\n\n\t\trc = llc_ui_wait_for_busy_core(sk, timeout);\n\t\tif (rc) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn llc_build_and_send_pkt(sk, skb);\n}\n\nstatic void llc_ui_sk_init(struct socket *sock, struct sock *sk)\n{\n\tsock_graft(sk, sock);\n\tsk->sk_type\t= sock->type;\n\tsock->ops\t= &llc_ui_ops;\n}\n\nstatic struct proto llc_proto = {\n\t.name\t  = \"LLC\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct llc_sock),\n\t.slab_flags = SLAB_TYPESAFE_BY_RCU,\n};\n\n \nstatic int llc_ui_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t int kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tif (likely(sock->type == SOCK_DGRAM || sock->type == SOCK_STREAM)) {\n\t\trc = -ENOMEM;\n\t\tsk = llc_sk_alloc(net, PF_LLC, GFP_KERNEL, &llc_proto, kern);\n\t\tif (sk) {\n\t\t\trc = 0;\n\t\t\tllc_ui_sk_init(sock, sk);\n\t\t}\n\t}\n\treturn rc;\n}\n\n \nstatic int llc_ui_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc;\n\n\tif (unlikely(sk == NULL))\n\t\tgoto out;\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tllc = llc_sk(sk);\n\tdprintk(\"%s: closing local(%02X) remote(%02X)\\n\", __func__,\n\t\tllc->laddr.lsap, llc->daddr.lsap);\n\tif (!llc_send_disc(sk))\n\t\tllc_ui_wait_for_disc(sk, sk->sk_rcvtimeo);\n\tif (!sock_flag(sk, SOCK_ZAPPED)) {\n\t\tstruct llc_sap *sap = llc->sap;\n\n\t\t \n\t\tllc_sap_hold(sap);\n\t\tllc_sap_remove_socket(llc->sap, sk);\n\t\trelease_sock(sk);\n\t\tllc_sap_put(sap);\n\t} else {\n\t\trelease_sock(sk);\n\t}\n\tnetdev_put(llc->dev, &llc->dev_tracker);\n\tsock_put(sk);\n\tllc_sk_free(sk);\nout:\n\treturn 0;\n}\n\n \nstatic int llc_ui_autoport(void)\n{\n\tstruct llc_sap *sap;\n\tint i, tries = 0;\n\n\twhile (tries < LLC_SAP_DYN_TRIES) {\n\t\tfor (i = llc_ui_sap_last_autoport;\n\t\t     i < LLC_SAP_DYN_STOP; i += 2) {\n\t\t\tsap = llc_sap_find(i);\n\t\t\tif (!sap) {\n\t\t\t\tllc_ui_sap_last_autoport = i + 2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tllc_sap_put(sap);\n\t\t}\n\t\tllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\n\t\ttries++;\n\t}\n\ti = 0;\nout:\n\treturn i;\n}\n\n \nstatic int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct net_device *dev = NULL;\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tdev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (dev && addr->sllc_arphrd != dev->type) {\n\t\t\tdev_put(dev);\n\t\t\tdev = NULL;\n\t\t}\n\t} else\n\t\tdev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!dev)\n\t\tgoto out;\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY;  \n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\n\t \n\tllc->dev = dev;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\tdev = NULL;\n\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\t \n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\tdev_put(dev);\n\treturn rc;\n}\n\n \nstatic int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr, int addrlen)\n{\n\tstruct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct net_device *dev = NULL;\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(!sock_flag(sk, SOCK_ZAPPED) || addrlen != sizeof(*addr)))\n\t\tgoto out;\n\trc = -EAFNOSUPPORT;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (unlikely(addr->sllc_family != AF_LLC || addr->sllc_arphrd != ARPHRD_ETHER))\n\t\tgoto out;\n\tdprintk(\"%s: binding %02X\\n\", __func__, addr->sllc_sap);\n\trc = -ENODEV;\n\trcu_read_lock();\n\tif (sk->sk_bound_dev_if) {\n\t\tdev = dev_get_by_index_rcu(&init_net, sk->sk_bound_dev_if);\n\t\tif (dev) {\n\t\t\tif (is_zero_ether_addr(addr->sllc_mac))\n\t\t\t\tmemcpy(addr->sllc_mac, dev->dev_addr,\n\t\t\t\t       IFHWADDRLEN);\n\t\t\tif (addr->sllc_arphrd != dev->type ||\n\t\t\t    !ether_addr_equal(addr->sllc_mac,\n\t\t\t\t\t      dev->dev_addr)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tdev = NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev = dev_getbyhwaddr_rcu(&init_net, addr->sllc_arphrd,\n\t\t\t\t\t   addr->sllc_mac);\n\t}\n\tdev_hold(dev);\n\trcu_read_unlock();\n\tif (!dev)\n\t\tgoto out;\n\n\tif (!addr->sllc_sap) {\n\t\trc = -EUSERS;\n\t\taddr->sllc_sap = llc_ui_autoport();\n\t\tif (!addr->sllc_sap)\n\t\t\tgoto out;\n\t}\n\tsap = llc_sap_find(addr->sllc_sap);\n\tif (!sap) {\n\t\tsap = llc_sap_open(addr->sllc_sap, NULL);\n\t\trc = -EBUSY;  \n\t\tif (!sap)\n\t\t\tgoto out;\n\t} else {\n\t\tstruct llc_addr laddr, daddr;\n\t\tstruct sock *ask;\n\n\t\tmemset(&laddr, 0, sizeof(laddr));\n\t\tmemset(&daddr, 0, sizeof(daddr));\n\t\t \n\t\tmemcpy(laddr.mac, addr->sllc_mac, IFHWADDRLEN);\n\t\tladdr.lsap = addr->sllc_sap;\n\t\trc = -EADDRINUSE;  \n\t\task = llc_lookup_established(sap, &daddr, &laddr, &init_net);\n\t\tif (ask) {\n\t\t\tsock_put(ask);\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\t \n\tllc->dev = dev;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\tdev = NULL;\n\n\tllc->laddr.lsap = addr->sllc_sap;\n\tmemcpy(llc->laddr.mac, addr->sllc_mac, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\t \n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout_put:\n\tllc_sap_put(sap);\nout:\n\tdev_put(dev);\n\trelease_sock(sk);\n\treturn rc;\n}\n\n \nstatic int llc_ui_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\tif (unlikely(sk->sk_state != TCP_ESTABLISHED))\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (how != 2)\n\t\tgoto out;\n\trc = llc_send_disc(sk);\n\tif (!rc)\n\t\trc = llc_ui_wait_for_disc(sk, sk->sk_rcvtimeo);\n\t \n\tsk->sk_state_change(sk);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n \nstatic int llc_ui_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int addrlen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(addrlen != sizeof(*addr)))\n\t\tgoto out;\n\trc = -EAFNOSUPPORT;\n\tif (unlikely(addr->sllc_family != AF_LLC))\n\t\tgoto out;\n\tif (unlikely(sk->sk_type != SOCK_STREAM))\n\t\tgoto out;\n\trc = -EALREADY;\n\tif (unlikely(sock->state == SS_CONNECTING))\n\t\tgoto out;\n\t \n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\t \n\t\trc = llc_ui_autobind(sock, addr);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\tllc->daddr.lsap = addr->sllc_sap;\n\tmemcpy(llc->daddr.mac, addr->sllc_mac, IFHWADDRLEN);\n\tsock->state = SS_CONNECTING;\n\tsk->sk_state   = TCP_SYN_SENT;\n\tllc->link   = llc_ui_next_link_no(llc->sap->laddr.lsap);\n\trc = llc_establish_connection(sk, llc->dev->dev_addr,\n\t\t\t\t      addr->sllc_mac, addr->sllc_sap);\n\tif (rc) {\n\t\tdprintk(\"%s: llc_ui_send_conn failed :-(\\n\", __func__);\n\t\tsock->state  = SS_UNCONNECTED;\n\t\tsk->sk_state = TCP_CLOSE;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tconst long timeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\n\t\tif (!timeo || !llc_ui_wait_for_conn(sk, timeo))\n\t\t\tgoto out;\n\n\t\trc = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto sock_error;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\nsock_error:\n\trc = sock_error(sk) ? : -ECONNABORTED;\n\tsock->state = SS_UNCONNECTED;\n\tgoto out;\n}\n\n \nstatic int llc_ui_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(sock->state != SS_UNCONNECTED))\n\t\tgoto out;\n\trc = -EOPNOTSUPP;\n\tif (unlikely(sk->sk_type != SOCK_STREAM))\n\t\tgoto out;\n\trc = -EAGAIN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\trc = 0;\n\tif (!(unsigned int)backlog)\t \n\t\tbacklog = 1;\n\tsk->sk_max_ack_backlog = backlog;\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tsk->sk_ack_backlog = 0;\n\t\tsk->sk_state\t   = TCP_LISTEN;\n\t}\n\tsk->sk_socket->flags |= __SO_ACCEPTCON;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int llc_ui_wait_for_disc(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint rc = 0;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk_wait_event(sk, &timeout,\n\t\t\t\t  READ_ONCE(sk->sk_state) == TCP_CLOSE, &wait))\n\t\t\tbreak;\n\t\trc = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = -EAGAIN;\n\t\tif (!timeout)\n\t\t\tbreak;\n\t\trc = 0;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\n\nstatic bool llc_ui_wait_for_conn(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk_wait_event(sk, &timeout,\n\t\t\t\t  READ_ONCE(sk->sk_state) != TCP_SYN_SENT, &wait))\n\t\t\tbreak;\n\t\tif (signal_pending(current) || !timeout)\n\t\t\tbreak;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn timeout;\n}\n\nstatic int llc_ui_wait_for_busy_core(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\trc = 0;\n\t\tif (sk_wait_event(sk, &timeout,\n\t\t\t\t  (READ_ONCE(sk->sk_shutdown) & RCV_SHUTDOWN) ||\n\t\t\t\t  (!llc_data_accept_state(llc->state) &&\n\t\t\t\t   !llc->remote_busy_flag &&\n\t\t\t\t   !llc->p_flag), &wait))\n\t\t\tbreak;\n\t\trc = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = -EAGAIN;\n\t\tif (!timeout)\n\t\t\tbreak;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\n\nstatic int llc_wait_data(struct sock *sk, long timeo)\n{\n\tint rc;\n\n\twhile (1) {\n\t\t \n\t\trc = sock_error(sk);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = 0;\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\t\trc = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trc = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tif (sk_wait_data(sk, &timeo, NULL))\n\t\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\n\tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n\t\tstruct llc_pktinfo info;\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n\t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n\t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}\n\n \nstatic int llc_ui_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t\t bool kern)\n{\n\tstruct sock *sk = sock->sk, *newsk;\n\tstruct llc_sock *llc, *newllc;\n\tstruct sk_buff *skb;\n\tint rc = -EOPNOTSUPP;\n\n\tdprintk(\"%s: accepting on %02X\\n\", __func__,\n\t\tllc_sk(sk)->laddr.lsap);\n\tlock_sock(sk);\n\tif (unlikely(sk->sk_type != SOCK_STREAM))\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (unlikely(sock->state != SS_UNCONNECTED ||\n\t\t     sk->sk_state != TCP_LISTEN))\n\t\tgoto out;\n\t \n\tif (skb_queue_empty(&sk->sk_receive_queue)) {\n\t\trc = llc_wait_data(sk, sk->sk_rcvtimeo);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\tdprintk(\"%s: got a new connection on %02X\\n\", __func__,\n\t\tllc_sk(sk)->laddr.lsap);\n\tskb = skb_dequeue(&sk->sk_receive_queue);\n\trc = -EINVAL;\n\tif (!skb->sk)\n\t\tgoto frees;\n\trc = 0;\n\tnewsk = skb->sk;\n\t \n\tllc_ui_sk_init(newsock, newsk);\n\tsock_reset_flag(newsk, SOCK_ZAPPED);\n\tnewsk->sk_state\t\t= TCP_ESTABLISHED;\n\tnewsock->state\t\t= SS_CONNECTED;\n\tllc\t\t\t= llc_sk(sk);\n\tnewllc\t\t\t= llc_sk(newsk);\n\tmemcpy(&newllc->addr, &llc->addr, sizeof(newllc->addr));\n\tnewllc->link = llc_ui_next_link_no(newllc->laddr.lsap);\n\n\t \n\tsk->sk_state = TCP_LISTEN;\n\tsk_acceptq_removed(sk);\n\tdprintk(\"%s: ok success on %02X, client on %02X\\n\", __func__,\n\t\tllc_sk(sk)->addr.sllc_sap, newllc->daddr.lsap);\nfrees:\n\tkfree_skb(skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n \nstatic int llc_ui_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t  int flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_llc *, uaddr, msg->msg_name);\n\tconst int nonblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb = NULL;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tsize_t copied = 0;\n\tu32 peek_seq = 0;\n\tu32 *seq, skb_len;\n\tunsigned long used;\n\tint target;\t \n\tlong timeo;\n\n\tlock_sock(sk);\n\tcopied = -ENOTCONN;\n\tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\n\t\tgoto out;\n\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n\n\tseq = &llc->copied_seq;\n\tif (flags & MSG_PEEK) {\n\t\tpeek_seq = llc->copied_seq;\n\t\tseq = &peek_seq;\n\t}\n\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tcopied = 0;\n\n\tdo {\n\t\tu32 offset;\n\n\t\t \n\t\tif (signal_pending(current)) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\tcopied = timeo ? sock_intr_errno(timeo) : -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb) {\n\t\t\toffset = *seq;\n\t\t\tgoto found_ok_skb;\n\t\t}\n\t\t \n\n\t\tif (copied >= target && !READ_ONCE(sk->sk_backlog.tail))\n\t\t\tbreak;\n\n\t\tif (copied) {\n\t\t\tif (sk->sk_err ||\n\t\t\t    sk->sk_state == TCP_CLOSE ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    !timeo ||\n\t\t\t    (flags & MSG_PEEK))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_err) {\n\t\t\t\tcopied = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE)) {\n\t\t\t\t\t \n\t\t\t\t\tcopied = -ENOTCONN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tcopied = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (copied >= target) {  \n\t\t\trelease_sock(sk);\n\t\t\tlock_sock(sk);\n\t\t} else\n\t\t\tsk_wait_data(sk, &timeo, NULL);\n\n\t\tif ((flags & MSG_PEEK) && peek_seq != llc->copied_seq) {\n\t\t\tnet_dbg_ratelimited(\"LLC(%s:%d): Application bug, race in MSG_PEEK\\n\",\n\t\t\t\t\t    current->comm,\n\t\t\t\t\t    task_pid_nr(current));\n\t\t\tpeek_seq = llc->copied_seq;\n\t\t}\n\t\tcontinue;\n\tfound_ok_skb:\n\t\tskb_len = skb->len;\n\t\t \n\t\tused = skb->len - offset;\n\t\tif (len < used)\n\t\t\tused = len;\n\n\t\tif (!(flags & MSG_TRUNC)) {\n\t\t\tint rc = skb_copy_datagram_msg(skb, offset, msg, used);\n\t\t\tif (rc) {\n\t\t\t\t \n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*seq += used;\n\t\tcopied += used;\n\t\tlen -= used;\n\n\t\t \n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\tgoto copy_uaddr;\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tskb_unlink(skb, &sk->sk_receive_queue);\n\t\t\tkfree_skb(skb);\n\t\t\t*seq = 0;\n\t\t}\n\n\t\t \n\t\tif (used + offset < skb_len)\n\t\t\tcontinue;\n\t} while (len > 0);\n\nout:\n\trelease_sock(sk);\n\treturn copied;\ncopy_uaddr:\n\tif (uaddr != NULL && skb != NULL) {\n\t\tmemcpy(uaddr, llc_ui_skb_cb(skb), sizeof(*uaddr));\n\t\tmsg->msg_namelen = sizeof(*uaddr);\n\t}\n\tif (llc_sk(sk)->cmsg_flags)\n\t\tllc_cmsg_rcv(msg, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tskb_unlink(skb, &sk->sk_receive_queue);\n\t\tkfree_skb(skb);\n\t\t*seq = 0;\n\t}\n\n\tgoto out;\n}\n\n \nstatic int llc_ui_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_llc *, addr, msg->msg_name);\n\tint flags = msg->msg_flags;\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb = NULL;\n\tsize_t size = 0;\n\tint rc = -EINVAL, copied = 0, hdrlen;\n\n\tdprintk(\"%s: sending from %02X to %02X\\n\", __func__,\n\t\tllc->laddr.lsap, llc->daddr.lsap);\n\tlock_sock(sk);\n\tif (addr) {\n\t\tif (msg->msg_namelen < sizeof(*addr))\n\t\t\tgoto out;\n\t} else {\n\t\tif (llc_ui_addr_null(&llc->addr))\n\t\t\tgoto out;\n\t\taddr = &llc->addr;\n\t}\n\t \n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\t \n\t\trc = llc_ui_autobind(sock, addr);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\thdrlen = llc->dev->hard_header_len + llc_ui_header_len(sk, addr);\n\tsize = hdrlen + len;\n\tif (size > llc->dev->mtu)\n\t\tsize = llc->dev->mtu;\n\tcopied = size - hdrlen;\n\trc = -EINVAL;\n\tif (copied < 0)\n\t\tgoto out;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tskb->dev      = llc->dev;\n\tskb->protocol = llc_proto_type(addr->sllc_arphrd);\n\tskb_reserve(skb, hdrlen);\n\trc = memcpy_from_msg(skb_put(skb, copied), msg, copied);\n\tif (rc)\n\t\tgoto out;\n\tif (sk->sk_type == SOCK_DGRAM || addr->sllc_ua) {\n\t\tllc_build_and_send_ui_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t  addr->sllc_sap);\n\t\tskb = NULL;\n\t\tgoto out;\n\t}\n\tif (addr->sllc_test) {\n\t\tllc_build_and_send_test_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t    addr->sllc_sap);\n\t\tskb = NULL;\n\t\tgoto out;\n\t}\n\tif (addr->sllc_xid) {\n\t\tllc_build_and_send_xid_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t   addr->sllc_sap);\n\t\tskb = NULL;\n\t\tgoto out;\n\t}\n\trc = -ENOPROTOOPT;\n\tif (!(sk->sk_type == SOCK_STREAM && !addr->sllc_ua))\n\t\tgoto out;\n\trc = llc_ui_send_data(sk, skb, noblock);\n\tskb = NULL;\nout:\n\tkfree_skb(skb);\n\tif (rc)\n\t\tdprintk(\"%s: failed sending from %02X to %02X: %d\\n\",\n\t\t\t__func__, llc->laddr.lsap, llc->daddr.lsap, rc);\n\trelease_sock(sk);\n\treturn rc ? : copied;\n}\n\n \nstatic int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = -EBADF;\n\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\n\trc = sizeof(sllc);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n \nstatic int llc_ui_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\treturn -ENOIOCTLCMD;\n}\n\n \nstatic int llc_ui_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t     sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tunsigned int opt;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC || optlen != sizeof(int)))\n\t\tgoto out;\n\trc = copy_from_sockptr(&opt, optval, sizeof(opt));\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tif (opt > LLC_OPT_MAX_RETRY)\n\t\t\tgoto out;\n\t\tllc->n2 = opt;\n\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tif (opt > LLC_OPT_MAX_SIZE)\n\t\t\tgoto out;\n\t\tllc->n1 = opt;\n\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_ACK_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->ack_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_P_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->pf_cycle_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_REJ_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->rej_sent_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_BUSY_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->busy_state_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->k = opt;\n\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->rw = opt;\n\t\tbreak;\n\tcase LLC_OPT_PKTINFO:\n\t\tif (opt)\n\t\t\tllc->cmsg_flags |= LLC_CMSG_PKTINFO;\n\t\telse\n\t\t\tllc->cmsg_flags &= ~LLC_CMSG_PKTINFO;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n \nstatic int llc_ui_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t     char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint val = 0, len = 0, rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC))\n\t\tgoto out;\n\trc = get_user(len, optlen);\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (len != sizeof(int))\n\t\tgoto out;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tval = llc->n2;\t\t\t\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tval = llc->n1;\t\t\t\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tval = llc->ack_timer.expire / HZ;\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tval = llc->pf_cycle_timer.expire / HZ;\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tval = llc->rej_sent_timer.expire / HZ;\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tval = llc->busy_state_timer.expire / HZ;\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tval = llc->k;\t\t\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tval = llc->rw;\t\t\t\tbreak;\n\tcase LLC_OPT_PKTINFO:\n\t\tval = (llc->cmsg_flags & LLC_CMSG_PKTINFO) != 0;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\trc = -EFAULT;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic const struct net_proto_family llc_ui_family_ops = {\n\t.family = PF_LLC,\n\t.create = llc_ui_create,\n\t.owner\t= THIS_MODULE,\n};\n\nstatic const struct proto_ops llc_ui_ops = {\n\t.family\t     = PF_LLC,\n\t.owner       = THIS_MODULE,\n\t.release     = llc_ui_release,\n\t.bind\t     = llc_ui_bind,\n\t.connect     = llc_ui_connect,\n\t.socketpair  = sock_no_socketpair,\n\t.accept      = llc_ui_accept,\n\t.getname     = llc_ui_getname,\n\t.poll\t     = datagram_poll,\n\t.ioctl       = llc_ui_ioctl,\n\t.listen      = llc_ui_listen,\n\t.shutdown    = llc_ui_shutdown,\n\t.setsockopt  = llc_ui_setsockopt,\n\t.getsockopt  = llc_ui_getsockopt,\n\t.sendmsg     = llc_ui_sendmsg,\n\t.recvmsg     = llc_ui_recvmsg,\n\t.mmap\t     = sock_no_mmap,\n};\n\nstatic const char llc_proc_err_msg[] __initconst =\n\tKERN_CRIT \"LLC: Unable to register the proc_fs entries\\n\";\nstatic const char llc_sysctl_err_msg[] __initconst =\n\tKERN_CRIT \"LLC: Unable to register the sysctl entries\\n\";\nstatic const char llc_sock_err_msg[] __initconst =\n\tKERN_CRIT \"LLC: Unable to register the network family\\n\";\n\nstatic int __init llc2_init(void)\n{\n\tint rc = proto_register(&llc_proto, 0);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tllc_build_offset_table();\n\tllc_station_init();\n\tllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\n\trc = llc_proc_init();\n\tif (rc != 0) {\n\t\tprintk(llc_proc_err_msg);\n\t\tgoto out_station;\n\t}\n\trc = llc_sysctl_init();\n\tif (rc) {\n\t\tprintk(llc_sysctl_err_msg);\n\t\tgoto out_proc;\n\t}\n\trc = sock_register(&llc_ui_family_ops);\n\tif (rc) {\n\t\tprintk(llc_sock_err_msg);\n\t\tgoto out_sysctl;\n\t}\n\tllc_add_pack(LLC_DEST_SAP, llc_sap_handler);\n\tllc_add_pack(LLC_DEST_CONN, llc_conn_handler);\nout:\n\treturn rc;\nout_sysctl:\n\tllc_sysctl_exit();\nout_proc:\n\tllc_proc_exit();\nout_station:\n\tllc_station_exit();\n\tproto_unregister(&llc_proto);\n\tgoto out;\n}\n\nstatic void __exit llc2_exit(void)\n{\n\tllc_station_exit();\n\tllc_remove_pack(LLC_DEST_SAP);\n\tllc_remove_pack(LLC_DEST_CONN);\n\tsock_unregister(PF_LLC);\n\tllc_proc_exit();\n\tllc_sysctl_exit();\n\tproto_unregister(&llc_proto);\n}\n\nmodule_init(llc2_init);\nmodule_exit(llc2_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Procom 1997, Jay Schullist 2001, Arnaldo C. Melo 2001-2003\");\nMODULE_DESCRIPTION(\"IEEE 802.2 PF_LLC support\");\nMODULE_ALIAS_NETPROTO(PF_LLC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}