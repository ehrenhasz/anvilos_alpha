{
  "module_name": "llc_input.c",
  "hash_id": "48acef3e45a73f8375ca6ae81b8acef3796f4fe17e4d932412128cabf1025591",
  "original_prompt": "Ingested from linux-6.6.14/net/llc/llc_input.c",
  "human_readable_source": " \n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <net/net_namespace.h>\n#include <net/llc.h>\n#include <net/llc_pdu.h>\n#include <net/llc_sap.h>\n\n#if 0\n#define dprintk(args...) printk(KERN_DEBUG args)\n#else\n#define dprintk(args...)\n#endif\n\n \nstatic void (*llc_station_handler)(struct sk_buff *skb);\n\n \nstatic void (*llc_type_handlers[2])(struct llc_sap *sap,\n\t\t\t\t    struct sk_buff *skb);\n\nvoid llc_add_pack(int type, void (*handler)(struct llc_sap *sap,\n\t\t\t\t\t    struct sk_buff *skb))\n{\n\tsmp_wmb();  \n\tif (type == LLC_DEST_SAP || type == LLC_DEST_CONN)\n\t\tllc_type_handlers[type - 1] = handler;\n}\n\nvoid llc_remove_pack(int type)\n{\n\tif (type == LLC_DEST_SAP || type == LLC_DEST_CONN)\n\t\tllc_type_handlers[type - 1] = NULL;\n\tsynchronize_net();\n}\n\nvoid llc_set_station_handler(void (*handler)(struct sk_buff *skb))\n{\n\t \n\tif (handler)\n\t\tsmp_wmb();\n\n\tllc_station_handler = handler;\n\n\tif (!handler)\n\t\tsynchronize_net();\n}\n\n \nstatic __inline__ int llc_pdu_type(struct sk_buff *skb)\n{\n\tint type = LLC_DEST_CONN;  \n\tstruct llc_pdu_sn *pdu = llc_pdu_sn_hdr(skb);\n\n\tif ((pdu->ctrl_1 & LLC_PDU_TYPE_MASK) != LLC_PDU_TYPE_U)\n\t\tgoto out;\n\tswitch (LLC_U_PDU_CMD(pdu)) {\n\tcase LLC_1_PDU_CMD_XID:\n\tcase LLC_1_PDU_CMD_UI:\n\tcase LLC_1_PDU_CMD_TEST:\n\t\ttype = LLC_DEST_SAP;\n\t\tbreak;\n\tcase LLC_2_PDU_CMD_SABME:\n\tcase LLC_2_PDU_CMD_DISC:\n\tcase LLC_2_PDU_RSP_UA:\n\tcase LLC_2_PDU_RSP_DM:\n\tcase LLC_2_PDU_RSP_FRMR:\n\t\tbreak;\n\tdefault:\n\t\ttype = LLC_DEST_INVALID;\n\t\tbreak;\n\t}\nout:\n\treturn type;\n}\n\n \nstatic inline int llc_fixup_skb(struct sk_buff *skb)\n{\n\tu8 llc_len = 2;\n\tstruct llc_pdu_un *pdu;\n\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*pdu))))\n\t\treturn 0;\n\n\tpdu = (struct llc_pdu_un *)skb->data;\n\tif ((pdu->ctrl_1 & LLC_PDU_TYPE_MASK) == LLC_PDU_TYPE_U)\n\t\tllc_len = 1;\n\tllc_len += 2;\n\n\tif (unlikely(!pskb_may_pull(skb, llc_len)))\n\t\treturn 0;\n\n\tskb->transport_header += llc_len;\n\tskb_pull(skb, llc_len);\n\tif (skb->protocol == htons(ETH_P_802_2)) {\n\t\t__be16 pdulen;\n\t\ts32 data_size;\n\n\t\tif (skb->mac_len < ETH_HLEN)\n\t\t\treturn 0;\n\n\t\tpdulen = eth_hdr(skb)->h_proto;\n\t\tdata_size = ntohs(pdulen) - llc_len;\n\n\t\tif (data_size < 0 ||\n\t\t    !pskb_may_pull(skb, data_size))\n\t\t\treturn 0;\n\t\tif (unlikely(pskb_trim_rcsum(skb, data_size)))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nint llc_rcv(struct sk_buff *skb, struct net_device *dev,\n\t    struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct llc_sap *sap;\n\tstruct llc_pdu_sn *pdu;\n\tint dest;\n\tint (*rcv)(struct sk_buff *, struct net_device *,\n\t\t   struct packet_type *, struct net_device *);\n\tvoid (*sta_handler)(struct sk_buff *skb);\n\tvoid (*sap_handler)(struct llc_sap *sap, struct sk_buff *skb);\n\n\t \n\tif (unlikely(skb->pkt_type == PACKET_OTHERHOST)) {\n\t\tdprintk(\"%s: PACKET_OTHERHOST\\n\", __func__);\n\t\tgoto drop;\n\t}\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\tgoto out;\n\tif (unlikely(!llc_fixup_skb(skb)))\n\t\tgoto drop;\n\tpdu = llc_pdu_sn_hdr(skb);\n\tif (unlikely(!pdu->dsap))  \n\t       goto handle_station;\n\tsap = llc_sap_find(pdu->dsap);\n\tif (unlikely(!sap)) { \n\t\tdprintk(\"%s: llc_sap_find(%02X) failed!\\n\", __func__,\n\t\t\tpdu->dsap);\n\t\tgoto drop;\n\t}\n\t \n\trcv = rcu_dereference(sap->rcv_func);\n\tdest = llc_pdu_type(skb);\n\tsap_handler = dest ? READ_ONCE(llc_type_handlers[dest - 1]) : NULL;\n\tif (unlikely(!sap_handler)) {\n\t\tif (rcv)\n\t\t\trcv(skb, dev, pt, orig_dev);\n\t\telse\n\t\t\tkfree_skb(skb);\n\t} else {\n\t\tif (rcv) {\n\t\t\tstruct sk_buff *cskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (cskb)\n\t\t\t\trcv(cskb, dev, pt, orig_dev);\n\t\t}\n\t\tsap_handler(sap, skb);\n\t}\n\tllc_sap_put(sap);\nout:\n\treturn 0;\ndrop:\n\tkfree_skb(skb);\n\tgoto out;\nhandle_station:\n\tsta_handler = READ_ONCE(llc_station_handler);\n\tif (!sta_handler)\n\t\tgoto drop;\n\tsta_handler(skb);\n\tgoto out;\n}\n\nEXPORT_SYMBOL(llc_add_pack);\nEXPORT_SYMBOL(llc_remove_pack);\nEXPORT_SYMBOL(llc_set_station_handler);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}