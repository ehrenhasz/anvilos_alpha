{
  "module_name": "llc_proc.c",
  "hash_id": "6f31b0ad9c323ea4e347d2d7d0ce8efea359e30466ce7bce9a99a8152d0860d6",
  "original_prompt": "Ingested from linux-6.6.14/net/llc/llc_proc.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/errno.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/llc.h>\n#include <net/llc_c_ac.h>\n#include <net/llc_c_ev.h>\n#include <net/llc_c_st.h>\n#include <net/llc_conn.h>\n\nstatic void llc_ui_format_mac(struct seq_file *seq, const u8 *addr)\n{\n\tseq_printf(seq, \"%pM\", addr);\n}\n\nstatic struct sock *llc_get_sk_idx(loff_t pos)\n{\n\tstruct llc_sap *sap;\n\tstruct sock *sk = NULL;\n\tint i;\n\n\tlist_for_each_entry_rcu(sap, &llc_sap_list, node) {\n\t\tspin_lock_bh(&sap->sk_lock);\n\t\tfor (i = 0; i < LLC_SK_LADDR_HASH_ENTRIES; i++) {\n\t\t\tstruct hlist_nulls_head *head = &sap->sk_laddr_hash[i];\n\t\t\tstruct hlist_nulls_node *node;\n\n\t\t\tsk_nulls_for_each(sk, node, head) {\n\t\t\t\tif (!pos)\n\t\t\t\t\tgoto found;  \n\t\t\t\t--pos;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&sap->sk_lock);\n\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic void *llc_seq_start(struct seq_file *seq, loff_t *pos) __acquires(RCU)\n{\n\tloff_t l = *pos;\n\n\trcu_read_lock_bh();\n\treturn l ? llc_get_sk_idx(--l) : SEQ_START_TOKEN;\n}\n\nstatic struct sock *laddr_hash_next(struct llc_sap *sap, int bucket)\n{\n\tstruct hlist_nulls_node *node;\n\tstruct sock *sk = NULL;\n\n\twhile (++bucket < LLC_SK_LADDR_HASH_ENTRIES)\n\t\tsk_nulls_for_each(sk, node, &sap->sk_laddr_hash[bucket])\n\t\t\tgoto out;\n\nout:\n\treturn sk;\n}\n\nstatic void *llc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct sock* sk, *next;\n\tstruct llc_sock *llc;\n\tstruct llc_sap *sap;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN) {\n\t\tsk = llc_get_sk_idx(0);\n\t\tgoto out;\n\t}\n\tsk = v;\n\tnext = sk_nulls_next(sk);\n\tif (next) {\n\t\tsk = next;\n\t\tgoto out;\n\t}\n\tllc = llc_sk(sk);\n\tsap = llc->sap;\n\tsk = laddr_hash_next(sap, llc_sk_laddr_hashfn(sap, &llc->laddr));\n\tif (sk)\n\t\tgoto out;\n\tspin_unlock_bh(&sap->sk_lock);\n\tlist_for_each_entry_continue_rcu(sap, &llc_sap_list, node) {\n\t\tspin_lock_bh(&sap->sk_lock);\n\t\tsk = laddr_hash_next(sap, -1);\n\t\tif (sk)\n\t\t\tbreak;  \n\t\tspin_unlock_bh(&sap->sk_lock);\n\t}\nout:\n\treturn sk;\n}\n\nstatic void llc_seq_stop(struct seq_file *seq, void *v)\n{\n\tif (v && v != SEQ_START_TOKEN) {\n\t\tstruct sock *sk = v;\n\t\tstruct llc_sock *llc = llc_sk(sk);\n\t\tstruct llc_sap *sap = llc->sap;\n\n\t\tspin_unlock_bh(&sap->sk_lock);\n\t}\n\trcu_read_unlock_bh();\n}\n\nstatic int llc_seq_socket_show(struct seq_file *seq, void *v)\n{\n\tstruct sock* sk;\n\tstruct llc_sock *llc;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"SKt Mc local_mac_sap        remote_mac_sap   \"\n\t\t\t      \"    tx_queue rx_queue st uid link\\n\");\n\t\tgoto out;\n\t}\n\tsk = v;\n\tllc = llc_sk(sk);\n\n\t \n\tseq_printf(seq, \"%2X  %2X \", sk->sk_type, 0);\n\n\tif (llc->dev)\n\t\tllc_ui_format_mac(seq, llc->dev->dev_addr);\n\telse {\n\t\tu8 addr[6] = {0,0,0,0,0,0};\n\t\tllc_ui_format_mac(seq, addr);\n\t}\n\tseq_printf(seq, \"@%02X \", llc->sap->laddr.lsap);\n\tllc_ui_format_mac(seq, llc->daddr.mac);\n\tseq_printf(seq, \"@%02X %8d %8d %2d %3u %4d\\n\", llc->daddr.lsap,\n\t\t   sk_wmem_alloc_get(sk),\n\t\t   sk_rmem_alloc_get(sk) - llc->copied_seq,\n\t\t   sk->sk_state,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sk)),\n\t\t   llc->link);\nout:\n\treturn 0;\n}\n\nstatic const char *const llc_conn_state_names[] = {\n\t[LLC_CONN_STATE_ADM] =        \"adm\",\n\t[LLC_CONN_STATE_SETUP] =      \"setup\",\n\t[LLC_CONN_STATE_NORMAL] =     \"normal\",\n\t[LLC_CONN_STATE_BUSY] =       \"busy\",\n\t[LLC_CONN_STATE_REJ] =        \"rej\",\n\t[LLC_CONN_STATE_AWAIT] =      \"await\",\n\t[LLC_CONN_STATE_AWAIT_BUSY] = \"await_busy\",\n\t[LLC_CONN_STATE_AWAIT_REJ] =  \"await_rej\",\n\t[LLC_CONN_STATE_D_CONN]\t=     \"d_conn\",\n\t[LLC_CONN_STATE_RESET] =      \"reset\",\n\t[LLC_CONN_STATE_ERROR] =      \"error\",\n\t[LLC_CONN_STATE_TEMP] =       \"temp\",\n};\n\nstatic int llc_seq_core_show(struct seq_file *seq, void *v)\n{\n\tstruct sock* sk;\n\tstruct llc_sock *llc;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Connection list:\\n\"\n\t\t\t      \"dsap state      retr txw rxw pf ff sf df rs cs \"\n\t\t\t      \"tack tpfc trs tbs blog busr\\n\");\n\t\tgoto out;\n\t}\n\tsk = v;\n\tllc = llc_sk(sk);\n\n\tseq_printf(seq, \" %02X  %-10s %3d  %3d %3d %2d %2d %2d %2d %2d %2d \"\n\t\t\t\"%4d %4d %3d %3d %4d %4d\\n\",\n\t\t   llc->daddr.lsap, llc_conn_state_names[llc->state],\n\t\t   llc->retry_count, llc->k, llc->rw, llc->p_flag, llc->f_flag,\n\t\t   llc->s_flag, llc->data_flag, llc->remote_busy_flag,\n\t\t   llc->cause_flag, timer_pending(&llc->ack_timer.timer),\n\t\t   timer_pending(&llc->pf_cycle_timer.timer),\n\t\t   timer_pending(&llc->rej_sent_timer.timer),\n\t\t   timer_pending(&llc->busy_state_timer.timer),\n\t\t   !!sk->sk_backlog.tail, sock_owned_by_user_nocheck(sk));\nout:\n\treturn 0;\n}\n\nstatic const struct seq_operations llc_seq_socket_ops = {\n\t.start  = llc_seq_start,\n\t.next   = llc_seq_next,\n\t.stop   = llc_seq_stop,\n\t.show   = llc_seq_socket_show,\n};\n\nstatic const struct seq_operations llc_seq_core_ops = {\n\t.start  = llc_seq_start,\n\t.next   = llc_seq_next,\n\t.stop   = llc_seq_stop,\n\t.show   = llc_seq_core_show,\n};\n\nstatic struct proc_dir_entry *llc_proc_dir;\n\nint __init llc_proc_init(void)\n{\n\tint rc = -ENOMEM;\n\tstruct proc_dir_entry *p;\n\n\tllc_proc_dir = proc_mkdir(\"llc\", init_net.proc_net);\n\tif (!llc_proc_dir)\n\t\tgoto out;\n\n\tp = proc_create_seq(\"socket\", 0444, llc_proc_dir, &llc_seq_socket_ops);\n\tif (!p)\n\t\tgoto out_socket;\n\n\tp = proc_create_seq(\"core\", 0444, llc_proc_dir, &llc_seq_core_ops);\n\tif (!p)\n\t\tgoto out_core;\n\n\trc = 0;\nout:\n\treturn rc;\nout_core:\n\tremove_proc_entry(\"socket\", llc_proc_dir);\nout_socket:\n\tremove_proc_entry(\"llc\", init_net.proc_net);\n\tgoto out;\n}\n\nvoid llc_proc_exit(void)\n{\n\tremove_proc_entry(\"socket\", llc_proc_dir);\n\tremove_proc_entry(\"core\", llc_proc_dir);\n\tremove_proc_entry(\"llc\", init_net.proc_net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}