{
  "module_name": "llc_conn.c",
  "hash_id": "d002f4e6326d714f3a3f0181e764b215e452643ab0fb8a4657f347dae8cbfd0c",
  "original_prompt": "Ingested from linux-6.6.14/net/llc/llc_conn.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/llc.h>\n#include <net/llc_c_ac.h>\n#include <net/llc_c_ev.h>\n#include <net/llc_c_st.h>\n#include <net/llc_conn.h>\n#include <net/llc_pdu.h>\n#include <net/llc_sap.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n\n#if 0\n#define dprintk(args...) printk(KERN_DEBUG args)\n#else\n#define dprintk(args...)\n#endif\n\nstatic int llc_find_offset(int state, int ev_type);\nstatic void llc_conn_send_pdus(struct sock *sk);\nstatic int llc_conn_service(struct sock *sk, struct sk_buff *skb);\nstatic int llc_exec_conn_trans_actions(struct sock *sk,\n\t\t\t\t       struct llc_conn_state_trans *trans,\n\t\t\t\t       struct sk_buff *ev);\nstatic struct llc_conn_state_trans *llc_qualify_conn_ev(struct sock *sk,\n\t\t\t\t\t\t\tstruct sk_buff *skb);\n\n \nstatic int llc_offset_table[NBR_CONN_STATES][NBR_CONN_EV];\n\nint sysctl_llc2_ack_timeout = LLC2_ACK_TIME * HZ;\nint sysctl_llc2_p_timeout = LLC2_P_TIME * HZ;\nint sysctl_llc2_rej_timeout = LLC2_REJ_TIME * HZ;\nint sysctl_llc2_busy_timeout = LLC2_BUSY_TIME * HZ;\n\n \nint llc_conn_state_process(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\n\tev->ind_prim = ev->cfm_prim = 0;\n\t \n\trc = llc_conn_service(skb->sk, skb);\n\tif (unlikely(rc != 0)) {\n\t\tprintk(KERN_ERR \"%s: llc_conn_service failed\\n\", __func__);\n\t\tgoto out_skb_put;\n\t}\n\n\tswitch (ev->ind_prim) {\n\tcase LLC_DATA_PRIM:\n\t\tskb_get(skb);\n\t\tllc_save_primitive(sk, skb, LLC_DATA_PRIM);\n\t\tif (unlikely(sock_queue_rcv_skb(sk, skb))) {\n\t\t\t \n\t\t\tprintk(KERN_ERR \"%s: sock_queue_rcv_skb failed!\\n\",\n\t\t\t       __func__);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\tbreak;\n\tcase LLC_CONN_PRIM:\n\t\t \n\t\tskb_get(skb);\n\t\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\tcase LLC_DISC_PRIM:\n\t\tsock_hold(sk);\n\t\tif (sk->sk_type == SOCK_STREAM &&\n\t\t    sk->sk_state == TCP_ESTABLISHED) {\n\t\t\tsk->sk_shutdown       = SHUTDOWN_MASK;\n\t\t\tsk->sk_socket->state  = SS_UNCONNECTED;\n\t\t\tsk->sk_state          = TCP_CLOSE;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t}\n\t\t}\n\t\tsock_put(sk);\n\t\tbreak;\n\tcase LLC_RESET_PRIM:\n\t\t \n\t\tprintk(KERN_INFO \"%s: received a reset ind!\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\t\tif (ev->ind_prim)\n\t\t\tprintk(KERN_INFO \"%s: received unknown %d prim!\\n\",\n\t\t\t\t__func__, ev->ind_prim);\n\t\t \n\t\tbreak;\n\t}\n\n\tswitch (ev->cfm_prim) {\n\tcase LLC_DATA_PRIM:\n\t\tif (!llc_data_accept_state(llc->state))\n\t\t\tsk->sk_write_space(sk);\n\t\telse\n\t\t\trc = llc->failed_data_req = 1;\n\t\tbreak;\n\tcase LLC_CONN_PRIM:\n\t\tif (sk->sk_type == SOCK_STREAM &&\n\t\t    sk->sk_state == TCP_SYN_SENT) {\n\t\t\tif (ev->status) {\n\t\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\t\t\tsk->sk_state         = TCP_CLOSE;\n\t\t\t} else {\n\t\t\t\tsk->sk_socket->state = SS_CONNECTED;\n\t\t\t\tsk->sk_state         = TCP_ESTABLISHED;\n\t\t\t}\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t\tbreak;\n\tcase LLC_DISC_PRIM:\n\t\tsock_hold(sk);\n\t\tif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSING) {\n\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\t\tsk->sk_state         = TCP_CLOSE;\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t\tsock_put(sk);\n\t\tbreak;\n\tcase LLC_RESET_PRIM:\n\t\t \n\t\tprintk(KERN_INFO \"%s: received a reset conf!\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\t\tif (ev->cfm_prim)\n\t\t\tprintk(KERN_INFO \"%s: received unknown %d prim!\\n\",\n\t\t\t\t\t__func__, ev->cfm_prim);\n\t\t \n\t\tbreak;\n\t}\nout_skb_put:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\nvoid llc_conn_send_pdu(struct sock *sk, struct sk_buff *skb)\n{\n\t \n\tskb_queue_tail(&sk->sk_write_queue, skb);\n\tllc_conn_send_pdus(sk);\n}\n\n \nvoid llc_conn_rtn_pdu(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\n\tev->ind_prim = LLC_DATA_PRIM;\n}\n\n \nvoid llc_conn_resend_i_pdu_as_cmd(struct sock *sk, u8 nr, u8 first_p_bit)\n{\n\tstruct sk_buff *skb;\n\tstruct llc_pdu_sn *pdu;\n\tu16 nbr_unack_pdus;\n\tstruct llc_sock *llc;\n\tu8 howmany_resend = 0;\n\n\tllc_conn_remove_acked_pdus(sk, nr, &nbr_unack_pdus);\n\tif (!nbr_unack_pdus)\n\t\tgoto out;\n\t \n\tllc = llc_sk(sk);\n\n\twhile ((skb = skb_dequeue(&llc->pdu_unack_q)) != NULL) {\n\t\tpdu = llc_pdu_sn_hdr(skb);\n\t\tllc_pdu_set_cmd_rsp(skb, LLC_PDU_CMD);\n\t\tllc_pdu_set_pf_bit(skb, first_p_bit);\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\n\t\tfirst_p_bit = 0;\n\t\tllc->vS = LLC_I_GET_NS(pdu);\n\t\thowmany_resend++;\n\t}\n\tif (howmany_resend > 0)\n\t\tllc->vS = (llc->vS + 1) % LLC_2_SEQ_NBR_MODULO;\n\t \n\tllc_conn_send_pdus(sk);\nout:;\n}\n\n \nvoid llc_conn_resend_i_pdu_as_rsp(struct sock *sk, u8 nr, u8 first_f_bit)\n{\n\tstruct sk_buff *skb;\n\tu16 nbr_unack_pdus;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tu8 howmany_resend = 0;\n\n\tllc_conn_remove_acked_pdus(sk, nr, &nbr_unack_pdus);\n\tif (!nbr_unack_pdus)\n\t\tgoto out;\n\t \n\twhile ((skb = skb_dequeue(&llc->pdu_unack_q)) != NULL) {\n\t\tstruct llc_pdu_sn *pdu = llc_pdu_sn_hdr(skb);\n\n\t\tllc_pdu_set_cmd_rsp(skb, LLC_PDU_RSP);\n\t\tllc_pdu_set_pf_bit(skb, first_f_bit);\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\n\t\tfirst_f_bit = 0;\n\t\tllc->vS = LLC_I_GET_NS(pdu);\n\t\thowmany_resend++;\n\t}\n\tif (howmany_resend > 0)\n\t\tllc->vS = (llc->vS + 1) % LLC_2_SEQ_NBR_MODULO;\n\t \n\tllc_conn_send_pdus(sk);\nout:;\n}\n\n \nint llc_conn_remove_acked_pdus(struct sock *sk, u8 nr, u16 *how_many_unacked)\n{\n\tint pdu_pos, i;\n\tstruct sk_buff *skb;\n\tstruct llc_pdu_sn *pdu;\n\tint nbr_acked = 0;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint q_len = skb_queue_len(&llc->pdu_unack_q);\n\n\tif (!q_len)\n\t\tgoto out;\n\tskb = skb_peek(&llc->pdu_unack_q);\n\tpdu = llc_pdu_sn_hdr(skb);\n\n\t \n\tpdu_pos = ((int)LLC_2_SEQ_NBR_MODULO + (int)nr -\n\t\t\t(int)LLC_I_GET_NS(pdu)) % LLC_2_SEQ_NBR_MODULO;\n\n\tfor (i = 0; i < pdu_pos && i < q_len; i++) {\n\t\tskb = skb_dequeue(&llc->pdu_unack_q);\n\t\tkfree_skb(skb);\n\t\tnbr_acked++;\n\t}\nout:\n\t*how_many_unacked = skb_queue_len(&llc->pdu_unack_q);\n\treturn nbr_acked;\n}\n\n \nstatic void llc_conn_send_pdus(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&sk->sk_write_queue)) != NULL) {\n\t\tstruct llc_pdu_sn *pdu = llc_pdu_sn_hdr(skb);\n\n\t\tif (LLC_PDU_TYPE_IS_I(pdu) &&\n\t\t    !(skb->dev->flags & IFF_LOOPBACK)) {\n\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\tskb_queue_tail(&llc_sk(sk)->pdu_unack_q, skb);\n\t\t\tif (!skb2)\n\t\t\t\tbreak;\n\t\t\tskb = skb2;\n\t\t}\n\t\tdev_queue_xmit(skb);\n\t}\n}\n\n \nstatic int llc_conn_service(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc = 1;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_conn_state_trans *trans;\n\n\tif (llc->state > NBR_CONN_STATES)\n\t\tgoto out;\n\trc = 0;\n\ttrans = llc_qualify_conn_ev(sk, skb);\n\tif (trans) {\n\t\trc = llc_exec_conn_trans_actions(sk, trans, skb);\n\t\tif (!rc && trans->next_state != NO_STATE_CHANGE) {\n\t\t\tllc->state = trans->next_state;\n\t\t\tif (!llc_data_accept_state(llc->state))\n\t\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\n \nstatic struct llc_conn_state_trans *llc_qualify_conn_ev(struct sock *sk,\n\t\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct llc_conn_state_trans **next_trans;\n\tconst llc_conn_ev_qfyr_t *next_qualifier;\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_conn_state *curr_state =\n\t\t\t\t\t&llc_conn_state_table[llc->state - 1];\n\n\t \n\tfor (next_trans = curr_state->transitions +\n\t\tllc_find_offset(llc->state - 1, ev->type);\n\t     (*next_trans)->ev; next_trans++) {\n\t\tif (!((*next_trans)->ev)(sk, skb)) {\n\t\t\t \n\t\t\tfor (next_qualifier = (*next_trans)->ev_qualifiers;\n\t\t\t     next_qualifier && *next_qualifier &&\n\t\t\t     !(*next_qualifier)(sk, skb); next_qualifier++)\n\t\t\t\t ;\n\t\t\tif (!next_qualifier || !*next_qualifier)\n\t\t\t\t \n\t\t\t\treturn *next_trans;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic int llc_exec_conn_trans_actions(struct sock *sk,\n\t\t\t\t       struct llc_conn_state_trans *trans,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tint rc = 0;\n\tconst llc_conn_action_t *next_action;\n\n\tfor (next_action = trans->ev_actions;\n\t     next_action && *next_action; next_action++) {\n\t\tint rc2 = (*next_action)(sk, skb);\n\n\t\tif (rc2 == 2) {\n\t\t\trc = rc2;\n\t\t\tbreak;\n\t\t} else if (rc2)\n\t\t\trc = 1;\n\t}\n\treturn rc;\n}\n\nstatic inline bool llc_estab_match(const struct llc_sap *sap,\n\t\t\t\t   const struct llc_addr *daddr,\n\t\t\t\t   const struct llc_addr *laddr,\n\t\t\t\t   const struct sock *sk,\n\t\t\t\t   const struct net *net)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\treturn net_eq(sock_net(sk), net) &&\n\t\tllc->laddr.lsap == laddr->lsap &&\n\t\tllc->daddr.lsap == daddr->lsap &&\n\t\tether_addr_equal(llc->laddr.mac, laddr->mac) &&\n\t\tether_addr_equal(llc->daddr.mac, daddr->mac);\n}\n\n \nstatic struct sock *__llc_lookup_established(struct llc_sap *sap,\n\t\t\t\t\t     struct llc_addr *daddr,\n\t\t\t\t\t     struct llc_addr *laddr,\n\t\t\t\t\t     const struct net *net)\n{\n\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_estab_match(sap, daddr, laddr, rc, net)) {\n\t\t\t \n\t\t\tif (unlikely(!refcount_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n\t\t\t\t     !llc_estab_match(sap, daddr, laddr, rc, net))) {\n\t\t\t\tsock_put(rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\trc = NULL;\n\t \n\tif (unlikely(get_nulls_value(node) != slot))\n\t\tgoto again;\nfound:\n\trcu_read_unlock();\n\treturn rc;\n}\n\nstruct sock *llc_lookup_established(struct llc_sap *sap,\n\t\t\t\t    struct llc_addr *daddr,\n\t\t\t\t    struct llc_addr *laddr,\n\t\t\t\t    const struct net *net)\n{\n\tstruct sock *sk;\n\n\tlocal_bh_disable();\n\tsk = __llc_lookup_established(sap, daddr, laddr, net);\n\tlocal_bh_enable();\n\treturn sk;\n}\n\nstatic inline bool llc_listener_match(const struct llc_sap *sap,\n\t\t\t\t      const struct llc_addr *laddr,\n\t\t\t\t      const struct sock *sk,\n\t\t\t\t      const struct net *net)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\treturn net_eq(sock_net(sk), net) &&\n\t\tsk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN &&\n\t\tllc->laddr.lsap == laddr->lsap &&\n\t\tether_addr_equal(llc->laddr.mac, laddr->mac);\n}\n\nstatic struct sock *__llc_lookup_listener(struct llc_sap *sap,\n\t\t\t\t\t  struct llc_addr *laddr,\n\t\t\t\t\t  const struct net *net)\n{\n\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_listener_match(sap, laddr, rc, net)) {\n\t\t\t \n\t\t\tif (unlikely(!refcount_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n\t\t\t\t     !llc_listener_match(sap, laddr, rc, net))) {\n\t\t\t\tsock_put(rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\trc = NULL;\n\t \n\tif (unlikely(get_nulls_value(node) != slot))\n\t\tgoto again;\nfound:\n\trcu_read_unlock();\n\treturn rc;\n}\n\n \nstatic struct sock *llc_lookup_listener(struct llc_sap *sap,\n\t\t\t\t\tstruct llc_addr *laddr,\n\t\t\t\t\tconst struct net *net)\n{\n\tstruct sock *rc = __llc_lookup_listener(sap, laddr, net);\n\tstatic struct llc_addr null_addr;\n\n\tif (!rc)\n\t\trc = __llc_lookup_listener(sap, &null_addr, net);\n\n\treturn rc;\n}\n\nstatic struct sock *__llc_lookup(struct llc_sap *sap,\n\t\t\t\t struct llc_addr *daddr,\n\t\t\t\t struct llc_addr *laddr,\n\t\t\t\t const struct net *net)\n{\n\tstruct sock *sk = __llc_lookup_established(sap, daddr, laddr, net);\n\n\treturn sk ? : llc_lookup_listener(sap, laddr, net);\n}\n\n \nu8 llc_data_accept_state(u8 state)\n{\n\treturn state != LLC_CONN_STATE_NORMAL && state != LLC_CONN_STATE_BUSY &&\n\t       state != LLC_CONN_STATE_REJ;\n}\n\n \nstatic u16 __init llc_find_next_offset(struct llc_conn_state *state, u16 offset)\n{\n\tu16 cnt = 0;\n\tstruct llc_conn_state_trans **next_trans;\n\n\tfor (next_trans = state->transitions + offset;\n\t     (*next_trans)->ev; next_trans++)\n\t\t++cnt;\n\treturn cnt;\n}\n\n \nvoid __init llc_build_offset_table(void)\n{\n\tstruct llc_conn_state *curr_state;\n\tint state, ev_type, next_offset;\n\n\tfor (state = 0; state < NBR_CONN_STATES; state++) {\n\t\tcurr_state = &llc_conn_state_table[state];\n\t\tnext_offset = 0;\n\t\tfor (ev_type = 0; ev_type < NBR_CONN_EV; ev_type++) {\n\t\t\tllc_offset_table[state][ev_type] = next_offset;\n\t\t\tnext_offset += llc_find_next_offset(curr_state,\n\t\t\t\t\t\t\t    next_offset) + 1;\n\t\t}\n\t}\n}\n\n \nstatic int llc_find_offset(int state, int ev_type)\n{\n\tint rc = 0;\n\t \n\tswitch (ev_type) {\n\tcase LLC_CONN_EV_TYPE_PRIM:\n\t\trc = llc_offset_table[state][0]; break;\n\tcase LLC_CONN_EV_TYPE_PDU:\n\t\trc = llc_offset_table[state][4]; break;\n\tcase LLC_CONN_EV_TYPE_SIMPLE:\n\t\trc = llc_offset_table[state][1]; break;\n\tcase LLC_CONN_EV_TYPE_P_TMR:\n\tcase LLC_CONN_EV_TYPE_ACK_TMR:\n\tcase LLC_CONN_EV_TYPE_REJ_TMR:\n\tcase LLC_CONN_EV_TYPE_BUSY_TMR:\n\t\trc = llc_offset_table[state][3]; break;\n\t}\n\treturn rc;\n}\n\n \nvoid llc_sap_add_socket(struct llc_sap *sap, struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct hlist_head *dev_hb = llc_sk_dev_hash(sap, llc->dev->ifindex);\n\tstruct hlist_nulls_head *laddr_hb = llc_sk_laddr_hash(sap, &llc->laddr);\n\n\tllc_sap_hold(sap);\n\tllc_sk(sk)->sap = sap;\n\n\tspin_lock_bh(&sap->sk_lock);\n\tsock_set_flag(sk, SOCK_RCU_FREE);\n\tsap->sk_count++;\n\tsk_nulls_add_node_rcu(sk, laddr_hb);\n\thlist_add_head(&llc->dev_hash_node, dev_hb);\n\tspin_unlock_bh(&sap->sk_lock);\n}\n\n \nvoid llc_sap_remove_socket(struct llc_sap *sap, struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tspin_lock_bh(&sap->sk_lock);\n\tsk_nulls_del_node_init_rcu(sk);\n\thlist_del(&llc->dev_hash_node);\n\tsap->sk_count--;\n\tspin_unlock_bh(&sap->sk_lock);\n\tllc_sap_put(sap);\n}\n\n \nstatic int llc_conn_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\n\tev->type   = LLC_CONN_EV_TYPE_PDU;\n\tev->reason = 0;\n\treturn llc_conn_state_process(sk, skb);\n}\n\nstatic struct sock *llc_create_incoming_sock(struct sock *sk,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     struct llc_addr *saddr,\n\t\t\t\t\t     struct llc_addr *daddr)\n{\n\tstruct sock *newsk = llc_sk_alloc(sock_net(sk), sk->sk_family, GFP_ATOMIC,\n\t\t\t\t\t  sk->sk_prot, 0);\n\tstruct llc_sock *newllc, *llc = llc_sk(sk);\n\n\tif (!newsk)\n\t\tgoto out;\n\tnewllc = llc_sk(newsk);\n\tmemcpy(&newllc->laddr, daddr, sizeof(newllc->laddr));\n\tmemcpy(&newllc->daddr, saddr, sizeof(newllc->daddr));\n\tnewllc->dev = dev;\n\tdev_hold(dev);\n\tllc_sap_add_socket(llc->sap, newsk);\n\tllc_sap_hold(llc->sap);\nout:\n\treturn newsk;\n}\n\nvoid llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr saddr, daddr;\n\tstruct sock *sk;\n\n\tllc_pdu_decode_sa(skb, saddr.mac);\n\tllc_pdu_decode_ssap(skb, &saddr.lsap);\n\tllc_pdu_decode_da(skb, daddr.mac);\n\tllc_pdu_decode_dsap(skb, &daddr.lsap);\n\n\tsk = __llc_lookup(sap, &saddr, &daddr, dev_net(skb->dev));\n\tif (!sk)\n\t\tgoto drop;\n\n\tbh_lock_sock(sk);\n\t \n\tif (unlikely(sk->sk_state == TCP_LISTEN)) {\n\t\tstruct sock *newsk = llc_create_incoming_sock(sk, skb->dev,\n\t\t\t\t\t\t\t      &saddr, &daddr);\n\t\tif (!newsk)\n\t\t\tgoto drop_unlock;\n\t\tskb_set_owner_r(skb, newsk);\n\t} else {\n\t\t \n\t\tskb_orphan(skb);\n\t\tsock_hold(sk);\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_efree;\n\t}\n\tif (!sock_owned_by_user(sk))\n\t\tllc_conn_rcv(sk, skb);\n\telse {\n\t\tdprintk(\"%s: adding to backlog...\\n\", __func__);\n\t\tllc_set_backlog_type(skb, LLC_PACKET);\n\t\tif (sk_add_backlog(sk, skb, READ_ONCE(sk->sk_rcvbuf)))\n\t\t\tgoto drop_unlock;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn;\ndrop:\n\tkfree_skb(skb);\n\treturn;\ndrop_unlock:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\n#undef LLC_REFCNT_DEBUG\n#ifdef LLC_REFCNT_DEBUG\nstatic atomic_t llc_sock_nr;\n#endif\n\n \nstatic int llc_backlog_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc = 0;\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tif (likely(llc_backlog_type(skb) == LLC_PACKET)) {\n\t\tif (likely(llc->state > 1))  \n\t\t\trc = llc_conn_rcv(sk, skb);\n\t\telse\n\t\t\tgoto out_kfree_skb;\n\t} else if (llc_backlog_type(skb) == LLC_EVENT) {\n\t\t \n\t\tif (likely(llc->state > 1))   \n\t\t\trc = llc_conn_state_process(sk, skb);\n\t\telse\n\t\t\tgoto out_kfree_skb;\n\t} else {\n\t\tprintk(KERN_ERR \"%s: invalid skb in backlog\\n\", __func__);\n\t\tgoto out_kfree_skb;\n\t}\nout:\n\treturn rc;\nout_kfree_skb:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\n \nstatic void llc_sk_init(struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tllc->state    = LLC_CONN_STATE_ADM;\n\tllc->inc_cntr = llc->dec_cntr = 2;\n\tllc->dec_step = llc->connect_step = 1;\n\n\ttimer_setup(&llc->ack_timer.timer, llc_conn_ack_tmr_cb, 0);\n\tllc->ack_timer.expire\t      = sysctl_llc2_ack_timeout;\n\n\ttimer_setup(&llc->pf_cycle_timer.timer, llc_conn_pf_cycle_tmr_cb, 0);\n\tllc->pf_cycle_timer.expire\t   = sysctl_llc2_p_timeout;\n\n\ttimer_setup(&llc->rej_sent_timer.timer, llc_conn_rej_tmr_cb, 0);\n\tllc->rej_sent_timer.expire\t   = sysctl_llc2_rej_timeout;\n\n\ttimer_setup(&llc->busy_state_timer.timer, llc_conn_busy_tmr_cb, 0);\n\tllc->busy_state_timer.expire\t     = sysctl_llc2_busy_timeout;\n\n\tllc->n2 = 2;    \n\tllc->k  = 2;    \n\tllc->rw = 128;  \n\tskb_queue_head_init(&llc->pdu_unack_q);\n\tsk->sk_backlog_rcv = llc_backlog_rcv;\n}\n\n \nstruct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)\n{\n\tstruct sock *sk = sk_alloc(net, family, priority, prot, kern);\n\n\tif (!sk)\n\t\tgoto out;\n\tllc_sk_init(sk);\n\tsock_init_data(NULL, sk);\n#ifdef LLC_REFCNT_DEBUG\n\tatomic_inc(&llc_sock_nr);\n\tprintk(KERN_DEBUG \"LLC socket %p created in %s, now we have %d alive\\n\", sk,\n\t\t__func__, atomic_read(&llc_sock_nr));\n#endif\nout:\n\treturn sk;\n}\n\nvoid llc_sk_stop_all_timers(struct sock *sk, bool sync)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tif (sync) {\n\t\tdel_timer_sync(&llc->pf_cycle_timer.timer);\n\t\tdel_timer_sync(&llc->ack_timer.timer);\n\t\tdel_timer_sync(&llc->rej_sent_timer.timer);\n\t\tdel_timer_sync(&llc->busy_state_timer.timer);\n\t} else {\n\t\tdel_timer(&llc->pf_cycle_timer.timer);\n\t\tdel_timer(&llc->ack_timer.timer);\n\t\tdel_timer(&llc->rej_sent_timer.timer);\n\t\tdel_timer(&llc->busy_state_timer.timer);\n\t}\n\n\tllc->ack_must_be_send = 0;\n\tllc->ack_pf = 0;\n}\n\n \nvoid llc_sk_free(struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tllc->state = LLC_CONN_OUT_OF_SVC;\n\t \n\tllc_sk_stop_all_timers(sk, true);\n#ifdef DEBUG_LLC_CONN_ALLOC\n\tprintk(KERN_INFO \"%s: unackq=%d, txq=%d\\n\", __func__,\n\t\tskb_queue_len(&llc->pdu_unack_q),\n\t\tskb_queue_len(&sk->sk_write_queue));\n#endif\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&llc->pdu_unack_q);\n#ifdef LLC_REFCNT_DEBUG\n\tif (refcount_read(&sk->sk_refcnt) != 1) {\n\t\tprintk(KERN_DEBUG \"Destruction of LLC sock %p delayed in %s, cnt=%d\\n\",\n\t\t\tsk, __func__, refcount_read(&sk->sk_refcnt));\n\t\tprintk(KERN_DEBUG \"%d LLC sockets are still alive\\n\",\n\t\t\tatomic_read(&llc_sock_nr));\n\t} else {\n\t\tatomic_dec(&llc_sock_nr);\n\t\tprintk(KERN_DEBUG \"LLC socket %p released in %s, %d are still alive\\n\", sk,\n\t\t\t__func__, atomic_read(&llc_sock_nr));\n\t}\n#endif\n\tsock_put(sk);\n}\n\n \nvoid llc_sk_reset(struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tllc_conn_ac_stop_all_timers(sk, NULL);\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&llc->pdu_unack_q);\n\tllc->remote_busy_flag\t= 0;\n\tllc->cause_flag\t\t= 0;\n\tllc->retry_count\t= 0;\n\tllc_conn_set_p_flag(sk, 0);\n\tllc->f_flag\t\t= 0;\n\tllc->s_flag\t\t= 0;\n\tllc->ack_pf\t\t= 0;\n\tllc->first_pdu_Ns\t= 0;\n\tllc->ack_must_be_send\t= 0;\n\tllc->dec_step\t\t= 1;\n\tllc->inc_cntr\t\t= 2;\n\tllc->dec_cntr\t\t= 2;\n\tllc->X\t\t\t= 0;\n\tllc->failed_data_req\t= 0 ;\n\tllc->last_nr\t\t= 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}