{
  "module_name": "llc_if.c",
  "hash_id": "1c937d2a64044c0a0f2a52cdea085e3345472990aea3491f0434508127e677d7",
  "original_prompt": "Ingested from linux-6.6.14/net/llc/llc_if.c",
  "human_readable_source": " \n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/errno.h>\n#include <net/llc_if.h>\n#include <net/llc_sap.h>\n#include <net/llc_s_ev.h>\n#include <net/llc_conn.h>\n#include <net/sock.h>\n#include <net/llc_c_ev.h>\n#include <net/llc_c_ac.h>\n#include <net/llc_c_st.h>\n#include <net/tcp_states.h>\n\n \nint llc_build_and_send_pkt(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct llc_conn_state_ev *ev;\n\tint rc = -ECONNABORTED;\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tif (unlikely(llc->state == LLC_CONN_STATE_ADM))\n\t\tgoto out_free;\n\trc = -EBUSY;\n\tif (unlikely(llc_data_accept_state(llc->state) ||  \n\t\t     llc->p_flag)) {\n\t\tllc->failed_data_req = 1;\n\t\tgoto out_free;\n\t}\n\tev = llc_conn_ev(skb);\n\tev->type      = LLC_CONN_EV_TYPE_PRIM;\n\tev->prim      = LLC_DATA_PRIM;\n\tev->prim_type = LLC_PRIM_TYPE_REQ;\n\tskb->dev      = llc->dev;\n\treturn llc_conn_state_process(sk, skb);\n\nout_free:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\n \nint llc_establish_connection(struct sock *sk, const u8 *lmac, u8 *dmac, u8 dsap)\n{\n\tint rc = -EISCONN;\n\tstruct llc_addr laddr, daddr;\n\tstruct sk_buff *skb;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct sock *existing;\n\n\tladdr.lsap = llc->sap->laddr.lsap;\n\tdaddr.lsap = dsap;\n\tmemcpy(daddr.mac, dmac, sizeof(daddr.mac));\n\tmemcpy(laddr.mac, lmac, sizeof(laddr.mac));\n\texisting = llc_lookup_established(llc->sap, &daddr, &laddr, sock_net(sk));\n\tif (existing) {\n\t\tif (existing->sk_state == TCP_ESTABLISHED) {\n\t\t\tsk = existing;\n\t\t\tgoto out_put;\n\t\t} else\n\t\t\tsock_put(existing);\n\t}\n\tsock_hold(sk);\n\trc = -ENOMEM;\n\tskb = alloc_skb(0, GFP_ATOMIC);\n\tif (skb) {\n\t\tstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\n\n\t\tev->type      = LLC_CONN_EV_TYPE_PRIM;\n\t\tev->prim      = LLC_CONN_PRIM;\n\t\tev->prim_type = LLC_PRIM_TYPE_REQ;\n\t\tskb_set_owner_w(skb, sk);\n\t\trc = llc_conn_state_process(sk, skb);\n\t}\nout_put:\n\tsock_put(sk);\n\treturn rc;\n}\n\n \nint llc_send_disc(struct sock *sk)\n{\n\tu16 rc = 1;\n\tstruct llc_conn_state_ev *ev;\n\tstruct sk_buff *skb;\n\n\tsock_hold(sk);\n\tif (sk->sk_type != SOCK_STREAM || sk->sk_state != TCP_ESTABLISHED ||\n\t    llc_sk(sk)->state == LLC_CONN_STATE_ADM ||\n\t    llc_sk(sk)->state == LLC_CONN_OUT_OF_SVC)\n\t\tgoto out;\n\t \n\tskb = alloc_skb(0, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out;\n\tskb_set_owner_w(skb, sk);\n\tsk->sk_state  = TCP_CLOSING;\n\tev\t      = llc_conn_ev(skb);\n\tev->type      = LLC_CONN_EV_TYPE_PRIM;\n\tev->prim      = LLC_DISC_PRIM;\n\tev->prim_type = LLC_PRIM_TYPE_REQ;\n\trc = llc_conn_state_process(sk, skb);\nout:\n\tsock_put(sk);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}