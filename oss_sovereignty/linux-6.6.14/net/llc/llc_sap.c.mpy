{
  "module_name": "llc_sap.c",
  "hash_id": "c42cbf3547b23471ba4d6f0731467d2e3be250d72523567af1388db88de99258",
  "original_prompt": "Ingested from linux-6.6.14/net/llc/llc_sap.c",
  "human_readable_source": " \n\n#include <net/llc.h>\n#include <net/llc_if.h>\n#include <net/llc_conn.h>\n#include <net/llc_pdu.h>\n#include <net/llc_sap.h>\n#include <net/llc_s_ac.h>\n#include <net/llc_s_ev.h>\n#include <net/llc_s_st.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/llc.h>\n#include <linux/slab.h>\n\nstatic int llc_mac_header_len(unsigned short devtype)\n{\n\tswitch (devtype) {\n\tcase ARPHRD_ETHER:\n\tcase ARPHRD_LOOPBACK:\n\t\treturn sizeof(struct ethhdr);\n\t}\n\treturn 0;\n}\n\n \nstruct sk_buff *llc_alloc_frame(struct sock *sk, struct net_device *dev,\n\t\t\t\tu8 type, u32 data_size)\n{\n\tint hlen = type == LLC_PDU_TYPE_U ? 3 : 4;\n\tstruct sk_buff *skb;\n\n\thlen += llc_mac_header_len(dev->type);\n\tskb = alloc_skb(hlen + data_size, GFP_ATOMIC);\n\n\tif (skb) {\n\t\tskb_reset_mac_header(skb);\n\t\tskb_reserve(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb_reset_transport_header(skb);\n\t\tskb->protocol = htons(ETH_P_802_2);\n\t\tskb->dev      = dev;\n\t\tif (sk != NULL)\n\t\t\tskb_set_owner_w(skb, sk);\n\t}\n\treturn skb;\n}\n\nvoid llc_save_primitive(struct sock *sk, struct sk_buff *skb, u8 prim)\n{\n\tstruct sockaddr_llc *addr;\n\n        \n\taddr\t\t  = llc_ui_skb_cb(skb);\n\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sllc_family = sk->sk_family;\n\taddr->sllc_arphrd = skb->dev->type;\n\taddr->sllc_test   = prim == LLC_TEST_PRIM;\n\taddr->sllc_xid    = prim == LLC_XID_PRIM;\n\taddr->sllc_ua     = prim == LLC_DATAUNIT_PRIM;\n\tllc_pdu_decode_sa(skb, addr->sllc_mac);\n\tllc_pdu_decode_ssap(skb, &addr->sllc_sap);\n}\n\n \nvoid llc_sap_rtn_pdu(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tstruct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);\n\n\tswitch (LLC_U_PDU_RSP(pdu)) {\n\tcase LLC_1_PDU_CMD_TEST:\n\t\tev->prim = LLC_TEST_PRIM;\tbreak;\n\tcase LLC_1_PDU_CMD_XID:\n\t\tev->prim = LLC_XID_PRIM;\tbreak;\n\tcase LLC_1_PDU_CMD_UI:\n\t\tev->prim = LLC_DATAUNIT_PRIM;\tbreak;\n\t}\n\tev->ind_cfm_flag = LLC_IND;\n}\n\n \nstatic struct llc_sap_state_trans *llc_find_sap_trans(struct llc_sap *sap,\n\t\t\t\t\t\t      struct sk_buff *skb)\n{\n\tint i = 0;\n\tstruct llc_sap_state_trans *rc = NULL;\n\tstruct llc_sap_state_trans **next_trans;\n\tstruct llc_sap_state *curr_state = &llc_sap_state_table[sap->state - 1];\n\t \n\tfor (next_trans = curr_state->transitions; next_trans[i]->ev; i++)\n\t\tif (!next_trans[i]->ev(sap, skb)) {\n\t\t\trc = next_trans[i];  \n\t\t\tbreak;\n\t\t}\n\treturn rc;\n}\n\n \nstatic int llc_exec_sap_trans_actions(struct llc_sap *sap,\n\t\t\t\t      struct llc_sap_state_trans *trans,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tint rc = 0;\n\tconst llc_sap_action_t *next_action = trans->ev_actions;\n\n\tfor (; next_action && *next_action; next_action++)\n\t\tif ((*next_action)(sap, skb))\n\t\t\trc = 1;\n\treturn rc;\n}\n\n \nstatic int llc_sap_next_state(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tint rc = 1;\n\tstruct llc_sap_state_trans *trans;\n\n\tif (sap->state > LLC_NR_SAP_STATES)\n\t\tgoto out;\n\ttrans = llc_find_sap_trans(sap, skb);\n\tif (!trans)\n\t\tgoto out;\n\t \n\trc = llc_exec_sap_trans_actions(sap, trans, skb);\n\tif (rc)\n\t\tgoto out;\n\t \n\tsap->state = trans->next_state;\nout:\n\treturn rc;\n}\n\n \nstatic void llc_sap_state_process(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->ind_cfm_flag = 0;\n\tllc_sap_next_state(sap, skb);\n\n\tif (ev->ind_cfm_flag == LLC_IND && skb->sk->sk_state != TCP_LISTEN) {\n\t\tllc_save_primitive(skb->sk, skb, ev->prim);\n\n\t\t \n\t\tif (sock_queue_rcv_skb(skb->sk, skb) == 0)\n\t\t\treturn;\n\t}\n\tkfree_skb(skb);\n}\n\n \nvoid llc_build_and_send_test_pkt(struct llc_sap *sap,\n\t\t\t\t struct sk_buff *skb, u8 *dmac, u8 dsap)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->saddr.lsap = sap->laddr.lsap;\n\tev->daddr.lsap = dsap;\n\tmemcpy(ev->saddr.mac, skb->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(ev->daddr.mac, dmac, IFHWADDRLEN);\n\n\tev->type      = LLC_SAP_EV_TYPE_PRIM;\n\tev->prim      = LLC_TEST_PRIM;\n\tev->prim_type = LLC_PRIM_TYPE_REQ;\n\tllc_sap_state_process(sap, skb);\n}\n\n \nvoid llc_build_and_send_xid_pkt(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\t\tu8 *dmac, u8 dsap)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->saddr.lsap = sap->laddr.lsap;\n\tev->daddr.lsap = dsap;\n\tmemcpy(ev->saddr.mac, skb->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(ev->daddr.mac, dmac, IFHWADDRLEN);\n\n\tev->type      = LLC_SAP_EV_TYPE_PRIM;\n\tev->prim      = LLC_XID_PRIM;\n\tev->prim_type = LLC_PRIM_TYPE_REQ;\n\tllc_sap_state_process(sap, skb);\n}\n\n \nstatic void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->type   = LLC_SAP_EV_TYPE_PDU;\n\tev->reason = 0;\n\tskb_orphan(skb);\n\tsock_hold(sk);\n\tskb->sk = sk;\n\tskb->destructor = sock_efree;\n\tllc_sap_state_process(sap, skb);\n}\n\nstatic inline bool llc_dgram_match(const struct llc_sap *sap,\n\t\t\t\t   const struct llc_addr *laddr,\n\t\t\t\t   const struct sock *sk,\n\t\t\t\t   const struct net *net)\n{\n     struct llc_sock *llc = llc_sk(sk);\n\n     return sk->sk_type == SOCK_DGRAM &&\n\t     net_eq(sock_net(sk), net) &&\n\t     llc->laddr.lsap == laddr->lsap &&\n\t     ether_addr_equal(llc->laddr.mac, laddr->mac);\n}\n\n \nstatic struct sock *llc_lookup_dgram(struct llc_sap *sap,\n\t\t\t\t     const struct llc_addr *laddr,\n\t\t\t\t     const struct net *net)\n{\n\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock_bh();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_dgram_match(sap, laddr, rc, net)) {\n\t\t\t \n\t\t\tif (unlikely(!refcount_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n\t\t\t\t     !llc_dgram_match(sap, laddr, rc, net))) {\n\t\t\t\tsock_put(rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\trc = NULL;\n\t \n\tif (unlikely(get_nulls_value(node) != slot))\n\t\tgoto again;\nfound:\n\trcu_read_unlock_bh();\n\treturn rc;\n}\n\nstatic inline bool llc_mcast_match(const struct llc_sap *sap,\n\t\t\t\t   const struct llc_addr *laddr,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   const struct sock *sk)\n{\n     struct llc_sock *llc = llc_sk(sk);\n\n     return sk->sk_type == SOCK_DGRAM &&\n\t  llc->laddr.lsap == laddr->lsap &&\n\t  llc->dev == skb->dev;\n}\n\nstatic void llc_do_mcast(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\t struct sock **stack, int count)\n{\n\tstruct sk_buff *skb1;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tskb1 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb1) {\n\t\t\tsock_put(stack[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tllc_sap_rcv(sap, skb1, stack[i]);\n\t\tsock_put(stack[i]);\n\t}\n}\n\n \nstatic void llc_sap_mcast(struct llc_sap *sap,\n\t\t\t  const struct llc_addr *laddr,\n\t\t\t  struct sk_buff *skb)\n{\n\tint i = 0;\n\tstruct sock *sk;\n\tstruct sock *stack[256 / sizeof(struct sock *)];\n\tstruct llc_sock *llc;\n\tstruct hlist_head *dev_hb = llc_sk_dev_hash(sap, skb->dev->ifindex);\n\n\tspin_lock_bh(&sap->sk_lock);\n\thlist_for_each_entry(llc, dev_hb, dev_hash_node) {\n\n\t\tsk = &llc->sk;\n\n\t\tif (!llc_mcast_match(sap, laddr, skb, sk))\n\t\t\tcontinue;\n\n\t\tsock_hold(sk);\n\t\tif (i < ARRAY_SIZE(stack))\n\t\t\tstack[i++] = sk;\n\t\telse {\n\t\t\tllc_do_mcast(sap, skb, stack, i);\n\t\t\ti = 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&sap->sk_lock);\n\n\tllc_do_mcast(sap, skb, stack, i);\n}\n\n\nvoid llc_sap_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr laddr;\n\n\tllc_pdu_decode_da(skb, laddr.mac);\n\tllc_pdu_decode_dsap(skb, &laddr.lsap);\n\n\tif (is_multicast_ether_addr(laddr.mac)) {\n\t\tllc_sap_mcast(sap, &laddr, skb);\n\t\tkfree_skb(skb);\n\t} else {\n\t\tstruct sock *sk = llc_lookup_dgram(sap, &laddr, dev_net(skb->dev));\n\t\tif (sk) {\n\t\t\tllc_sap_rcv(sap, skb, sk);\n\t\t\tsock_put(sk);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}