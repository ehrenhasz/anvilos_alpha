{
  "module_name": "stats.c",
  "hash_id": "93dd00d9e3595255205c28c1edb9ea190aaa1d22fcbc0be474bcb13417428bbc",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/stats.c",
  "human_readable_source": "\n\n#include \"netlink.h\"\n#include \"common.h\"\n#include \"bitset.h\"\n\nstruct stats_req_info {\n\tstruct ethnl_req_info\t\tbase;\n\tDECLARE_BITMAP(stat_mask, __ETHTOOL_STATS_CNT);\n\tenum ethtool_mac_stats_src\tsrc;\n};\n\n#define STATS_REQINFO(__req_base) \\\n\tcontainer_of(__req_base, struct stats_req_info, base)\n\nstruct stats_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tstruct_group(stats,\n\t\tstruct ethtool_eth_phy_stats\tphy_stats;\n\t\tstruct ethtool_eth_mac_stats\tmac_stats;\n\t\tstruct ethtool_eth_ctrl_stats\tctrl_stats;\n\t\tstruct ethtool_rmon_stats\trmon_stats;\n\t);\n\tconst struct ethtool_rmon_hist_range\t*rmon_ranges;\n};\n\n#define STATS_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct stats_reply_data, base)\n\nconst char stats_std_names[__ETHTOOL_STATS_CNT][ETH_GSTRING_LEN] = {\n\t[ETHTOOL_STATS_ETH_PHY]\t\t\t= \"eth-phy\",\n\t[ETHTOOL_STATS_ETH_MAC]\t\t\t= \"eth-mac\",\n\t[ETHTOOL_STATS_ETH_CTRL]\t\t= \"eth-ctrl\",\n\t[ETHTOOL_STATS_RMON]\t\t\t= \"rmon\",\n};\n\nconst char stats_eth_phy_names[__ETHTOOL_A_STATS_ETH_PHY_CNT][ETH_GSTRING_LEN] = {\n\t[ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR]\t= \"SymbolErrorDuringCarrier\",\n};\n\nconst char stats_eth_mac_names[__ETHTOOL_A_STATS_ETH_MAC_CNT][ETH_GSTRING_LEN] = {\n\t[ETHTOOL_A_STATS_ETH_MAC_2_TX_PKT]\t= \"FramesTransmittedOK\",\n\t[ETHTOOL_A_STATS_ETH_MAC_3_SINGLE_COL]\t= \"SingleCollisionFrames\",\n\t[ETHTOOL_A_STATS_ETH_MAC_4_MULTI_COL]\t= \"MultipleCollisionFrames\",\n\t[ETHTOOL_A_STATS_ETH_MAC_5_RX_PKT]\t= \"FramesReceivedOK\",\n\t[ETHTOOL_A_STATS_ETH_MAC_6_FCS_ERR]\t= \"FrameCheckSequenceErrors\",\n\t[ETHTOOL_A_STATS_ETH_MAC_7_ALIGN_ERR]\t= \"AlignmentErrors\",\n\t[ETHTOOL_A_STATS_ETH_MAC_8_TX_BYTES]\t= \"OctetsTransmittedOK\",\n\t[ETHTOOL_A_STATS_ETH_MAC_9_TX_DEFER]\t= \"FramesWithDeferredXmissions\",\n\t[ETHTOOL_A_STATS_ETH_MAC_10_LATE_COL]\t= \"LateCollisions\",\n\t[ETHTOOL_A_STATS_ETH_MAC_11_XS_COL]\t= \"FramesAbortedDueToXSColls\",\n\t[ETHTOOL_A_STATS_ETH_MAC_12_TX_INT_ERR]\t= \"FramesLostDueToIntMACXmitError\",\n\t[ETHTOOL_A_STATS_ETH_MAC_13_CS_ERR]\t= \"CarrierSenseErrors\",\n\t[ETHTOOL_A_STATS_ETH_MAC_14_RX_BYTES]\t= \"OctetsReceivedOK\",\n\t[ETHTOOL_A_STATS_ETH_MAC_15_RX_INT_ERR]\t= \"FramesLostDueToIntMACRcvError\",\n\t[ETHTOOL_A_STATS_ETH_MAC_18_TX_MCAST]\t= \"MulticastFramesXmittedOK\",\n\t[ETHTOOL_A_STATS_ETH_MAC_19_TX_BCAST]\t= \"BroadcastFramesXmittedOK\",\n\t[ETHTOOL_A_STATS_ETH_MAC_20_XS_DEFER]\t= \"FramesWithExcessiveDeferral\",\n\t[ETHTOOL_A_STATS_ETH_MAC_21_RX_MCAST]\t= \"MulticastFramesReceivedOK\",\n\t[ETHTOOL_A_STATS_ETH_MAC_22_RX_BCAST]\t= \"BroadcastFramesReceivedOK\",\n\t[ETHTOOL_A_STATS_ETH_MAC_23_IR_LEN_ERR]\t= \"InRangeLengthErrors\",\n\t[ETHTOOL_A_STATS_ETH_MAC_24_OOR_LEN]\t= \"OutOfRangeLengthField\",\n\t[ETHTOOL_A_STATS_ETH_MAC_25_TOO_LONG_ERR]\t= \"FrameTooLongErrors\",\n};\n\nconst char stats_eth_ctrl_names[__ETHTOOL_A_STATS_ETH_CTRL_CNT][ETH_GSTRING_LEN] = {\n\t[ETHTOOL_A_STATS_ETH_CTRL_3_TX]\t\t= \"MACControlFramesTransmitted\",\n\t[ETHTOOL_A_STATS_ETH_CTRL_4_RX]\t\t= \"MACControlFramesReceived\",\n\t[ETHTOOL_A_STATS_ETH_CTRL_5_RX_UNSUP]\t= \"UnsupportedOpcodesReceived\",\n};\n\nconst char stats_rmon_names[__ETHTOOL_A_STATS_RMON_CNT][ETH_GSTRING_LEN] = {\n\t[ETHTOOL_A_STATS_RMON_UNDERSIZE]\t= \"etherStatsUndersizePkts\",\n\t[ETHTOOL_A_STATS_RMON_OVERSIZE]\t\t= \"etherStatsOversizePkts\",\n\t[ETHTOOL_A_STATS_RMON_FRAG]\t\t= \"etherStatsFragments\",\n\t[ETHTOOL_A_STATS_RMON_JABBER]\t\t= \"etherStatsJabbers\",\n};\n\nconst struct nla_policy ethnl_stats_get_policy[ETHTOOL_A_STATS_SRC + 1] = {\n\t[ETHTOOL_A_STATS_HEADER]\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_STATS_GROUPS]\t= { .type = NLA_NESTED },\n\t[ETHTOOL_A_STATS_SRC]\t\t=\n\t\tNLA_POLICY_MAX(NLA_U32, ETHTOOL_MAC_STATS_SRC_PMAC),\n};\n\nstatic int stats_parse_request(struct ethnl_req_info *req_base,\n\t\t\t       struct nlattr **tb,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tenum ethtool_mac_stats_src src = ETHTOOL_MAC_STATS_SRC_AGGREGATE;\n\tstruct stats_req_info *req_info = STATS_REQINFO(req_base);\n\tbool mod = false;\n\tint err;\n\n\terr = ethnl_update_bitset(req_info->stat_mask, __ETHTOOL_STATS_CNT,\n\t\t\t\t  tb[ETHTOOL_A_STATS_GROUPS], stats_std_names,\n\t\t\t\t  extack, &mod);\n\tif (err)\n\t\treturn err;\n\n\tif (!mod) {\n\t\tNL_SET_ERR_MSG(extack, \"no stats requested\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[ETHTOOL_A_STATS_SRC])\n\t\tsrc = nla_get_u32(tb[ETHTOOL_A_STATS_SRC]);\n\n\treq_info->src = src;\n\n\treturn 0;\n}\n\nstatic int stats_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t      struct ethnl_reply_data *reply_base,\n\t\t\t      const struct genl_info *info)\n{\n\tconst struct stats_req_info *req_info = STATS_REQINFO(req_base);\n\tstruct stats_reply_data *data = STATS_REPDATA(reply_base);\n\tenum ethtool_mac_stats_src src = req_info->src;\n\tstruct net_device *dev = reply_base->dev;\n\tint ret;\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((src == ETHTOOL_MAC_STATS_SRC_EMAC ||\n\t     src == ETHTOOL_MAC_STATS_SRC_PMAC) &&\n\t    !__ethtool_dev_mm_supported(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack,\n\t\t\t\t   \"Device does not support MAC merge layer\");\n\t\tethnl_ops_complete(dev);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tmemset(&data->stats, 0xff, sizeof(data->stats));\n\n\tdata->phy_stats.src = src;\n\tdata->mac_stats.src = src;\n\tdata->ctrl_stats.src = src;\n\tdata->rmon_stats.src = src;\n\n\tif (test_bit(ETHTOOL_STATS_ETH_PHY, req_info->stat_mask) &&\n\t    dev->ethtool_ops->get_eth_phy_stats)\n\t\tdev->ethtool_ops->get_eth_phy_stats(dev, &data->phy_stats);\n\tif (test_bit(ETHTOOL_STATS_ETH_MAC, req_info->stat_mask) &&\n\t    dev->ethtool_ops->get_eth_mac_stats)\n\t\tdev->ethtool_ops->get_eth_mac_stats(dev, &data->mac_stats);\n\tif (test_bit(ETHTOOL_STATS_ETH_CTRL, req_info->stat_mask) &&\n\t    dev->ethtool_ops->get_eth_ctrl_stats)\n\t\tdev->ethtool_ops->get_eth_ctrl_stats(dev, &data->ctrl_stats);\n\tif (test_bit(ETHTOOL_STATS_RMON, req_info->stat_mask) &&\n\t    dev->ethtool_ops->get_rmon_stats)\n\t\tdev->ethtool_ops->get_rmon_stats(dev, &data->rmon_stats,\n\t\t\t\t\t\t &data->rmon_ranges);\n\n\tethnl_ops_complete(dev);\n\treturn 0;\n}\n\nstatic int stats_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t    const struct ethnl_reply_data *reply_base)\n{\n\tconst struct stats_req_info *req_info = STATS_REQINFO(req_base);\n\tunsigned int n_grps = 0, n_stats = 0;\n\tint len = 0;\n\n\tlen += nla_total_size(sizeof(u32));  \n\n\tif (test_bit(ETHTOOL_STATS_ETH_PHY, req_info->stat_mask)) {\n\t\tn_stats += sizeof(struct ethtool_eth_phy_stats) / sizeof(u64);\n\t\tn_grps++;\n\t}\n\tif (test_bit(ETHTOOL_STATS_ETH_MAC, req_info->stat_mask)) {\n\t\tn_stats += sizeof(struct ethtool_eth_mac_stats) / sizeof(u64);\n\t\tn_grps++;\n\t}\n\tif (test_bit(ETHTOOL_STATS_ETH_CTRL, req_info->stat_mask)) {\n\t\tn_stats += sizeof(struct ethtool_eth_ctrl_stats) / sizeof(u64);\n\t\tn_grps++;\n\t}\n\tif (test_bit(ETHTOOL_STATS_RMON, req_info->stat_mask)) {\n\t\tn_stats += sizeof(struct ethtool_rmon_stats) / sizeof(u64);\n\t\tn_grps++;\n\t\t \n\n\t\tlen += (nla_total_size(0) +\t \n\t\t\tnla_total_size(4) +\t \n\t\t\tnla_total_size(4)) *\t \n\t\t\tETHTOOL_RMON_HIST_MAX * 2;\n\t}\n\n\tlen += n_grps * (nla_total_size(0) +  \n\t\t\t nla_total_size(4) +  \n\t\t\t nla_total_size(4));  \n\tlen += n_stats * (nla_total_size(0) +  \n\t\t\t  nla_total_size_64bit(sizeof(u64)));\n\n\treturn len;\n}\n\nstatic int stat_put(struct sk_buff *skb, u16 attrtype, u64 val)\n{\n\tstruct nlattr *nest;\n\tint ret;\n\n\tif (val == ETHTOOL_STAT_NOT_SET)\n\t\treturn 0;\n\n\t \n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tif (!IS_ALIGNED((unsigned long)skb_tail_pointer(skb), 8))\n\t\tif (!nla_reserve(skb, ETHTOOL_A_STATS_GRP_PAD, 0))\n\t\t\treturn -EMSGSIZE;\n#endif\n\n\tnest = nla_nest_start(skb, ETHTOOL_A_STATS_GRP_STAT);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tret = nla_put_u64_64bit(skb, attrtype, val, -1  );\n\tif (ret) {\n\t\tnla_nest_cancel(skb, nest);\n\t\treturn ret;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n}\n\nstatic int stats_put_phy_stats(struct sk_buff *skb,\n\t\t\t       const struct stats_reply_data *data)\n{\n\tif (stat_put(skb, ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR,\n\t\t     data->phy_stats.SymbolErrorDuringCarrier))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int stats_put_mac_stats(struct sk_buff *skb,\n\t\t\t       const struct stats_reply_data *data)\n{\n\tif (stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_2_TX_PKT,\n\t\t     data->mac_stats.FramesTransmittedOK) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_3_SINGLE_COL,\n\t\t     data->mac_stats.SingleCollisionFrames) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_4_MULTI_COL,\n\t\t     data->mac_stats.MultipleCollisionFrames) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_5_RX_PKT,\n\t\t     data->mac_stats.FramesReceivedOK) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_6_FCS_ERR,\n\t\t     data->mac_stats.FrameCheckSequenceErrors) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_7_ALIGN_ERR,\n\t\t     data->mac_stats.AlignmentErrors) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_8_TX_BYTES,\n\t\t     data->mac_stats.OctetsTransmittedOK) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_9_TX_DEFER,\n\t\t     data->mac_stats.FramesWithDeferredXmissions) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_10_LATE_COL,\n\t\t     data->mac_stats.LateCollisions) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_11_XS_COL,\n\t\t     data->mac_stats.FramesAbortedDueToXSColls) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_12_TX_INT_ERR,\n\t\t     data->mac_stats.FramesLostDueToIntMACXmitError) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_13_CS_ERR,\n\t\t     data->mac_stats.CarrierSenseErrors) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_14_RX_BYTES,\n\t\t     data->mac_stats.OctetsReceivedOK) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_15_RX_INT_ERR,\n\t\t     data->mac_stats.FramesLostDueToIntMACRcvError) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_18_TX_MCAST,\n\t\t     data->mac_stats.MulticastFramesXmittedOK) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_19_TX_BCAST,\n\t\t     data->mac_stats.BroadcastFramesXmittedOK) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_20_XS_DEFER,\n\t\t     data->mac_stats.FramesWithExcessiveDeferral) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_21_RX_MCAST,\n\t\t     data->mac_stats.MulticastFramesReceivedOK) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_22_RX_BCAST,\n\t\t     data->mac_stats.BroadcastFramesReceivedOK) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_23_IR_LEN_ERR,\n\t\t     data->mac_stats.InRangeLengthErrors) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_24_OOR_LEN,\n\t\t     data->mac_stats.OutOfRangeLengthField) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_MAC_25_TOO_LONG_ERR,\n\t\t     data->mac_stats.FrameTooLongErrors))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int stats_put_ctrl_stats(struct sk_buff *skb,\n\t\t\t\tconst struct stats_reply_data *data)\n{\n\tif (stat_put(skb, ETHTOOL_A_STATS_ETH_CTRL_3_TX,\n\t\t     data->ctrl_stats.MACControlFramesTransmitted) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_CTRL_4_RX,\n\t\t     data->ctrl_stats.MACControlFramesReceived) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_ETH_CTRL_5_RX_UNSUP,\n\t\t     data->ctrl_stats.UnsupportedOpcodesReceived))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int stats_put_rmon_hist(struct sk_buff *skb, u32 attr, const u64 *hist,\n\t\t\t       const struct ethtool_rmon_hist_range *ranges)\n{\n\tstruct nlattr *nest;\n\tint i;\n\n\tif (!ranges)\n\t\treturn 0;\n\n\tfor (i = 0; i <\tETHTOOL_RMON_HIST_MAX; i++) {\n\t\tif (!ranges[i].low && !ranges[i].high)\n\t\t\tbreak;\n\t\tif (hist[i] == ETHTOOL_STAT_NOT_SET)\n\t\t\tcontinue;\n\n\t\tnest = nla_nest_start(skb, attr);\n\t\tif (!nest)\n\t\t\treturn -EMSGSIZE;\n\n\t\tif (nla_put_u32(skb, ETHTOOL_A_STATS_GRP_HIST_BKT_LOW,\n\t\t\t\tranges[i].low) ||\n\t\t    nla_put_u32(skb, ETHTOOL_A_STATS_GRP_HIST_BKT_HI,\n\t\t\t\tranges[i].high) ||\n\t\t    nla_put_u64_64bit(skb, ETHTOOL_A_STATS_GRP_HIST_VAL,\n\t\t\t\t      hist[i], ETHTOOL_A_STATS_GRP_PAD))\n\t\t\tgoto err_cancel_hist;\n\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\treturn 0;\n\nerr_cancel_hist:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int stats_put_rmon_stats(struct sk_buff *skb,\n\t\t\t\tconst struct stats_reply_data *data)\n{\n\tif (stats_put_rmon_hist(skb, ETHTOOL_A_STATS_GRP_HIST_RX,\n\t\t\t\tdata->rmon_stats.hist, data->rmon_ranges) ||\n\t    stats_put_rmon_hist(skb, ETHTOOL_A_STATS_GRP_HIST_TX,\n\t\t\t\tdata->rmon_stats.hist_tx, data->rmon_ranges))\n\t\treturn -EMSGSIZE;\n\n\tif (stat_put(skb, ETHTOOL_A_STATS_RMON_UNDERSIZE,\n\t\t     data->rmon_stats.undersize_pkts) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_RMON_OVERSIZE,\n\t\t     data->rmon_stats.oversize_pkts) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_RMON_FRAG,\n\t\t     data->rmon_stats.fragments) ||\n\t    stat_put(skb, ETHTOOL_A_STATS_RMON_JABBER,\n\t\t     data->rmon_stats.jabbers))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int stats_put_stats(struct sk_buff *skb,\n\t\t\t   const struct stats_reply_data *data,\n\t\t\t   u32 id, u32 ss_id,\n\t\t\t   int (*cb)(struct sk_buff *skb,\n\t\t\t\t     const struct stats_reply_data *data))\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start(skb, ETHTOOL_A_STATS_GRP);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, ETHTOOL_A_STATS_GRP_ID, id) ||\n\t    nla_put_u32(skb, ETHTOOL_A_STATS_GRP_SS_ID, ss_id))\n\t\tgoto err_cancel;\n\n\tif (cb(skb, data))\n\t\tgoto err_cancel;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nerr_cancel:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int stats_fill_reply(struct sk_buff *skb,\n\t\t\t    const struct ethnl_req_info *req_base,\n\t\t\t    const struct ethnl_reply_data *reply_base)\n{\n\tconst struct stats_req_info *req_info = STATS_REQINFO(req_base);\n\tconst struct stats_reply_data *data = STATS_REPDATA(reply_base);\n\tint ret = 0;\n\n\tif (nla_put_u32(skb, ETHTOOL_A_STATS_SRC, req_info->src))\n\t\treturn -EMSGSIZE;\n\n\tif (!ret && test_bit(ETHTOOL_STATS_ETH_PHY, req_info->stat_mask))\n\t\tret = stats_put_stats(skb, data, ETHTOOL_STATS_ETH_PHY,\n\t\t\t\t      ETH_SS_STATS_ETH_PHY,\n\t\t\t\t      stats_put_phy_stats);\n\tif (!ret && test_bit(ETHTOOL_STATS_ETH_MAC, req_info->stat_mask))\n\t\tret = stats_put_stats(skb, data, ETHTOOL_STATS_ETH_MAC,\n\t\t\t\t      ETH_SS_STATS_ETH_MAC,\n\t\t\t\t      stats_put_mac_stats);\n\tif (!ret && test_bit(ETHTOOL_STATS_ETH_CTRL, req_info->stat_mask))\n\t\tret = stats_put_stats(skb, data, ETHTOOL_STATS_ETH_CTRL,\n\t\t\t\t      ETH_SS_STATS_ETH_CTRL,\n\t\t\t\t      stats_put_ctrl_stats);\n\tif (!ret && test_bit(ETHTOOL_STATS_RMON, req_info->stat_mask))\n\t\tret = stats_put_stats(skb, data, ETHTOOL_STATS_RMON,\n\t\t\t\t      ETH_SS_STATS_RMON, stats_put_rmon_stats);\n\n\treturn ret;\n}\n\nconst struct ethnl_request_ops ethnl_stats_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_STATS_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_STATS_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_STATS_HEADER,\n\t.req_info_size\t\t= sizeof(struct stats_req_info),\n\t.reply_data_size\t= sizeof(struct stats_reply_data),\n\n\t.parse_request\t\t= stats_parse_request,\n\t.prepare_data\t\t= stats_prepare_data,\n\t.reply_size\t\t= stats_reply_size,\n\t.fill_reply\t\t= stats_fill_reply,\n};\n\nstatic u64 ethtool_stats_sum(u64 a, u64 b)\n{\n\tif (a == ETHTOOL_STAT_NOT_SET)\n\t\treturn b;\n\tif (b == ETHTOOL_STAT_NOT_SET)\n\t\treturn a;\n\treturn a + b;\n}\n\n \nstatic void ethtool_aggregate_stats(void *aggr_stats, const void *emac_stats,\n\t\t\t\t    const void *pmac_stats, size_t stats_size,\n\t\t\t\t    size_t stats_offset)\n{\n\tsize_t num_stats = stats_size / sizeof(u64);\n\tconst u64 *s1 = emac_stats + stats_offset;\n\tconst u64 *s2 = pmac_stats + stats_offset;\n\tu64 *s = aggr_stats + stats_offset;\n\tint i;\n\n\tfor (i = 0; i < num_stats; i++)\n\t\ts[i] = ethtool_stats_sum(s1[i], s2[i]);\n}\n\nvoid ethtool_aggregate_mac_stats(struct net_device *dev,\n\t\t\t\t struct ethtool_eth_mac_stats *mac_stats)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct ethtool_eth_mac_stats pmac, emac;\n\n\tmemset(&emac, 0xff, sizeof(emac));\n\tmemset(&pmac, 0xff, sizeof(pmac));\n\temac.src = ETHTOOL_MAC_STATS_SRC_EMAC;\n\tpmac.src = ETHTOOL_MAC_STATS_SRC_PMAC;\n\n\tops->get_eth_mac_stats(dev, &emac);\n\tops->get_eth_mac_stats(dev, &pmac);\n\n\tethtool_aggregate_stats(mac_stats, &emac, &pmac,\n\t\t\t\tsizeof(mac_stats->stats),\n\t\t\t\toffsetof(struct ethtool_eth_mac_stats, stats));\n}\nEXPORT_SYMBOL(ethtool_aggregate_mac_stats);\n\nvoid ethtool_aggregate_phy_stats(struct net_device *dev,\n\t\t\t\t struct ethtool_eth_phy_stats *phy_stats)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct ethtool_eth_phy_stats pmac, emac;\n\n\tmemset(&emac, 0xff, sizeof(emac));\n\tmemset(&pmac, 0xff, sizeof(pmac));\n\temac.src = ETHTOOL_MAC_STATS_SRC_EMAC;\n\tpmac.src = ETHTOOL_MAC_STATS_SRC_PMAC;\n\n\tops->get_eth_phy_stats(dev, &emac);\n\tops->get_eth_phy_stats(dev, &pmac);\n\n\tethtool_aggregate_stats(phy_stats, &emac, &pmac,\n\t\t\t\tsizeof(phy_stats->stats),\n\t\t\t\toffsetof(struct ethtool_eth_phy_stats, stats));\n}\nEXPORT_SYMBOL(ethtool_aggregate_phy_stats);\n\nvoid ethtool_aggregate_ctrl_stats(struct net_device *dev,\n\t\t\t\t  struct ethtool_eth_ctrl_stats *ctrl_stats)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct ethtool_eth_ctrl_stats pmac, emac;\n\n\tmemset(&emac, 0xff, sizeof(emac));\n\tmemset(&pmac, 0xff, sizeof(pmac));\n\temac.src = ETHTOOL_MAC_STATS_SRC_EMAC;\n\tpmac.src = ETHTOOL_MAC_STATS_SRC_PMAC;\n\n\tops->get_eth_ctrl_stats(dev, &emac);\n\tops->get_eth_ctrl_stats(dev, &pmac);\n\n\tethtool_aggregate_stats(ctrl_stats, &emac, &pmac,\n\t\t\t\tsizeof(ctrl_stats->stats),\n\t\t\t\toffsetof(struct ethtool_eth_ctrl_stats, stats));\n}\nEXPORT_SYMBOL(ethtool_aggregate_ctrl_stats);\n\nvoid ethtool_aggregate_pause_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_pause_stats *pause_stats)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct ethtool_pause_stats pmac, emac;\n\n\tmemset(&emac, 0xff, sizeof(emac));\n\tmemset(&pmac, 0xff, sizeof(pmac));\n\temac.src = ETHTOOL_MAC_STATS_SRC_EMAC;\n\tpmac.src = ETHTOOL_MAC_STATS_SRC_PMAC;\n\n\tops->get_pause_stats(dev, &emac);\n\tops->get_pause_stats(dev, &pmac);\n\n\tethtool_aggregate_stats(pause_stats, &emac, &pmac,\n\t\t\t\tsizeof(pause_stats->stats),\n\t\t\t\toffsetof(struct ethtool_pause_stats, stats));\n}\nEXPORT_SYMBOL(ethtool_aggregate_pause_stats);\n\nvoid ethtool_aggregate_rmon_stats(struct net_device *dev,\n\t\t\t\t  struct ethtool_rmon_stats *rmon_stats)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tconst struct ethtool_rmon_hist_range *dummy;\n\tstruct ethtool_rmon_stats pmac, emac;\n\n\tmemset(&emac, 0xff, sizeof(emac));\n\tmemset(&pmac, 0xff, sizeof(pmac));\n\temac.src = ETHTOOL_MAC_STATS_SRC_EMAC;\n\tpmac.src = ETHTOOL_MAC_STATS_SRC_PMAC;\n\n\tops->get_rmon_stats(dev, &emac, &dummy);\n\tops->get_rmon_stats(dev, &pmac, &dummy);\n\n\tethtool_aggregate_stats(rmon_stats, &emac, &pmac,\n\t\t\t\tsizeof(rmon_stats->stats),\n\t\t\t\toffsetof(struct ethtool_rmon_stats, stats));\n}\nEXPORT_SYMBOL(ethtool_aggregate_rmon_stats);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}