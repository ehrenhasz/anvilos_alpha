{
  "module_name": "eeprom.c",
  "hash_id": "f113ddcbb2ed08155b94b627368450c68767d133d02b5044da8b1c647cf9b31a",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/eeprom.c",
  "human_readable_source": "\n\n#include <linux/ethtool.h>\n#include <linux/sfp.h>\n#include \"netlink.h\"\n#include \"common.h\"\n\nstruct eeprom_req_info {\n\tstruct ethnl_req_info\tbase;\n\tu32\t\t\toffset;\n\tu32\t\t\tlength;\n\tu8\t\t\tpage;\n\tu8\t\t\tbank;\n\tu8\t\t\ti2c_address;\n};\n\nstruct eeprom_reply_data {\n\tstruct ethnl_reply_data base;\n\tu32\t\t\tlength;\n\tu8\t\t\t*data;\n};\n\n#define MODULE_EEPROM_REQINFO(__req_base) \\\n\tcontainer_of(__req_base, struct eeprom_req_info, base)\n\n#define MODULE_EEPROM_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct eeprom_reply_data, base)\n\nstatic int fallback_set_params(struct eeprom_req_info *request,\n\t\t\t       struct ethtool_modinfo *modinfo,\n\t\t\t       struct ethtool_eeprom *eeprom)\n{\n\tu32 offset = request->offset;\n\tu32 length = request->length;\n\n\tif (request->page)\n\t\toffset = request->page * ETH_MODULE_EEPROM_PAGE_LEN + offset;\n\n\tif (modinfo->type == ETH_MODULE_SFF_8472 &&\n\t    request->i2c_address == 0x51)\n\t\toffset += ETH_MODULE_EEPROM_PAGE_LEN * 2;\n\n\tif (offset >= modinfo->eeprom_len)\n\t\treturn -EINVAL;\n\n\teeprom->cmd = ETHTOOL_GMODULEEEPROM;\n\teeprom->len = length;\n\teeprom->offset = offset;\n\n\treturn 0;\n}\n\nstatic int eeprom_fallback(struct eeprom_req_info *request,\n\t\t\t   struct eeprom_reply_data *reply)\n{\n\tstruct net_device *dev = reply->base.dev;\n\tstruct ethtool_modinfo modinfo = {0};\n\tstruct ethtool_eeprom eeprom = {0};\n\tu8 *data;\n\tint err;\n\n\tmodinfo.cmd = ETHTOOL_GMODULEINFO;\n\terr = ethtool_get_module_info_call(dev, &modinfo);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = fallback_set_params(request, &modinfo, &eeprom);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = kmalloc(eeprom.len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\terr = ethtool_get_module_eeprom_call(dev, &eeprom, data);\n\tif (err < 0)\n\t\tgoto err_out;\n\n\treply->data = data;\n\treply->length = eeprom.len;\n\n\treturn 0;\n\nerr_out:\n\tkfree(data);\n\treturn err;\n}\n\nstatic int get_module_eeprom_by_page(struct net_device *dev,\n\t\t\t\t     struct ethtool_module_eeprom *page_data,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\n\tif (dev->sfp_bus)\n\t\treturn sfp_get_module_eeprom_by_page(dev->sfp_bus, page_data, extack);\n\n\tif (ops->get_module_eeprom_by_page)\n\t\treturn ops->get_module_eeprom_by_page(dev, page_data, extack);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int eeprom_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t       struct ethnl_reply_data *reply_base,\n\t\t\t       const struct genl_info *info)\n{\n\tstruct eeprom_reply_data *reply = MODULE_EEPROM_REPDATA(reply_base);\n\tstruct eeprom_req_info *request = MODULE_EEPROM_REQINFO(req_base);\n\tstruct ethtool_module_eeprom page_data = {0};\n\tstruct net_device *dev = reply_base->dev;\n\tint ret;\n\n\tpage_data.offset = request->offset;\n\tpage_data.length = request->length;\n\tpage_data.i2c_address = request->i2c_address;\n\tpage_data.page = request->page;\n\tpage_data.bank = request->bank;\n\tpage_data.data = kmalloc(page_data.length, GFP_KERNEL);\n\tif (!page_data.data)\n\t\treturn -ENOMEM;\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret)\n\t\tgoto err_free;\n\n\tret = get_module_eeprom_by_page(dev, &page_data, info->extack);\n\tif (ret < 0)\n\t\tgoto err_ops;\n\n\treply->length = ret;\n\treply->data = page_data.data;\n\n\tethnl_ops_complete(dev);\n\treturn 0;\n\nerr_ops:\n\tethnl_ops_complete(dev);\nerr_free:\n\tkfree(page_data.data);\n\n\tif (ret == -EOPNOTSUPP)\n\t\treturn eeprom_fallback(request, reply);\n\treturn ret;\n}\n\nstatic int eeprom_parse_request(struct ethnl_req_info *req_info, struct nlattr **tb,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct eeprom_req_info *request = MODULE_EEPROM_REQINFO(req_info);\n\n\tif (!tb[ETHTOOL_A_MODULE_EEPROM_OFFSET] ||\n\t    !tb[ETHTOOL_A_MODULE_EEPROM_LENGTH] ||\n\t    !tb[ETHTOOL_A_MODULE_EEPROM_PAGE] ||\n\t    !tb[ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS])\n\t\treturn -EINVAL;\n\n\trequest->i2c_address = nla_get_u8(tb[ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS]);\n\trequest->offset = nla_get_u32(tb[ETHTOOL_A_MODULE_EEPROM_OFFSET]);\n\trequest->length = nla_get_u32(tb[ETHTOOL_A_MODULE_EEPROM_LENGTH]);\n\n\t \n\trequest->page = nla_get_u8(tb[ETHTOOL_A_MODULE_EEPROM_PAGE]);\n\tif (request->page && request->offset < ETH_MODULE_EEPROM_PAGE_LEN) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_MODULE_EEPROM_PAGE],\n\t\t\t\t    \"reading from lower half page is allowed for page 0 only\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (request->offset < ETH_MODULE_EEPROM_PAGE_LEN &&\n\t    request->offset + request->length > ETH_MODULE_EEPROM_PAGE_LEN) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_MODULE_EEPROM_LENGTH],\n\t\t\t\t    \"reading cross half page boundary is illegal\");\n\t\treturn -EINVAL;\n\t} else if (request->offset + request->length > ETH_MODULE_EEPROM_PAGE_LEN * 2) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_MODULE_EEPROM_LENGTH],\n\t\t\t\t    \"reading cross page boundary is illegal\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[ETHTOOL_A_MODULE_EEPROM_BANK])\n\t\trequest->bank = nla_get_u8(tb[ETHTOOL_A_MODULE_EEPROM_BANK]);\n\n\treturn 0;\n}\n\nstatic int eeprom_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t     const struct ethnl_reply_data *reply_base)\n{\n\tconst struct eeprom_req_info *request = MODULE_EEPROM_REQINFO(req_base);\n\n\treturn nla_total_size(sizeof(u8) * request->length);  \n}\n\nstatic int eeprom_fill_reply(struct sk_buff *skb,\n\t\t\t     const struct ethnl_req_info *req_base,\n\t\t\t     const struct ethnl_reply_data *reply_base)\n{\n\tstruct eeprom_reply_data *reply = MODULE_EEPROM_REPDATA(reply_base);\n\n\treturn nla_put(skb, ETHTOOL_A_MODULE_EEPROM_DATA, reply->length, reply->data);\n}\n\nstatic void eeprom_cleanup_data(struct ethnl_reply_data *reply_base)\n{\n\tstruct eeprom_reply_data *reply = MODULE_EEPROM_REPDATA(reply_base);\n\n\tkfree(reply->data);\n}\n\nconst struct ethnl_request_ops ethnl_module_eeprom_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_MODULE_EEPROM_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_MODULE_EEPROM_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_MODULE_EEPROM_HEADER,\n\t.req_info_size\t\t= sizeof(struct eeprom_req_info),\n\t.reply_data_size\t= sizeof(struct eeprom_reply_data),\n\n\t.parse_request\t\t= eeprom_parse_request,\n\t.prepare_data\t\t= eeprom_prepare_data,\n\t.reply_size\t\t= eeprom_reply_size,\n\t.fill_reply\t\t= eeprom_fill_reply,\n\t.cleanup_data\t\t= eeprom_cleanup_data,\n};\n\nconst struct nla_policy ethnl_module_eeprom_get_policy[] = {\n\t[ETHTOOL_A_MODULE_EEPROM_HEADER]\t= NLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_MODULE_EEPROM_OFFSET]\t=\n\t\tNLA_POLICY_MAX(NLA_U32, ETH_MODULE_EEPROM_PAGE_LEN * 2 - 1),\n\t[ETHTOOL_A_MODULE_EEPROM_LENGTH]\t=\n\t\tNLA_POLICY_RANGE(NLA_U32, 1, ETH_MODULE_EEPROM_PAGE_LEN),\n\t[ETHTOOL_A_MODULE_EEPROM_PAGE]\t\t= { .type = NLA_U8 },\n\t[ETHTOOL_A_MODULE_EEPROM_BANK]\t\t= { .type = NLA_U8 },\n\t[ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS]\t=\n\t\tNLA_POLICY_RANGE(NLA_U8, 0, ETH_MODULE_MAX_I2C_ADDRESS),\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}