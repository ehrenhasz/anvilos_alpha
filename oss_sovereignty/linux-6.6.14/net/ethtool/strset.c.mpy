{
  "module_name": "strset.c",
  "hash_id": "52849272a15665e5c89acc209d052d5c534ab41e4e019ef8afe629b0cf8c120c",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/strset.c",
  "human_readable_source": "\n\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n#include \"netlink.h\"\n#include \"common.h\"\n\nstruct strset_info {\n\tbool per_dev;\n\tbool free_strings;\n\tunsigned int count;\n\tconst char (*strings)[ETH_GSTRING_LEN];\n};\n\nstatic const struct strset_info info_template[] = {\n\t[ETH_SS_TEST] = {\n\t\t.per_dev\t= true,\n\t},\n\t[ETH_SS_STATS] = {\n\t\t.per_dev\t= true,\n\t},\n\t[ETH_SS_PRIV_FLAGS] = {\n\t\t.per_dev\t= true,\n\t},\n\t[ETH_SS_FEATURES] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= ARRAY_SIZE(netdev_features_strings),\n\t\t.strings\t= netdev_features_strings,\n\t},\n\t[ETH_SS_RSS_HASH_FUNCS] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= ARRAY_SIZE(rss_hash_func_strings),\n\t\t.strings\t= rss_hash_func_strings,\n\t},\n\t[ETH_SS_TUNABLES] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= ARRAY_SIZE(tunable_strings),\n\t\t.strings\t= tunable_strings,\n\t},\n\t[ETH_SS_PHY_STATS] = {\n\t\t.per_dev\t= true,\n\t},\n\t[ETH_SS_PHY_TUNABLES] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= ARRAY_SIZE(phy_tunable_strings),\n\t\t.strings\t= phy_tunable_strings,\n\t},\n\t[ETH_SS_LINK_MODES] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= __ETHTOOL_LINK_MODE_MASK_NBITS,\n\t\t.strings\t= link_mode_names,\n\t},\n\t[ETH_SS_MSG_CLASSES] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= NETIF_MSG_CLASS_COUNT,\n\t\t.strings\t= netif_msg_class_names,\n\t},\n\t[ETH_SS_WOL_MODES] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= WOL_MODE_COUNT,\n\t\t.strings\t= wol_mode_names,\n\t},\n\t[ETH_SS_SOF_TIMESTAMPING] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= __SOF_TIMESTAMPING_CNT,\n\t\t.strings\t= sof_timestamping_names,\n\t},\n\t[ETH_SS_TS_TX_TYPES] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= __HWTSTAMP_TX_CNT,\n\t\t.strings\t= ts_tx_type_names,\n\t},\n\t[ETH_SS_TS_RX_FILTERS] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= __HWTSTAMP_FILTER_CNT,\n\t\t.strings\t= ts_rx_filter_names,\n\t},\n\t[ETH_SS_UDP_TUNNEL_TYPES] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= __ETHTOOL_UDP_TUNNEL_TYPE_CNT,\n\t\t.strings\t= udp_tunnel_type_names,\n\t},\n\t[ETH_SS_STATS_STD] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= __ETHTOOL_STATS_CNT,\n\t\t.strings\t= stats_std_names,\n\t},\n\t[ETH_SS_STATS_ETH_PHY] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= __ETHTOOL_A_STATS_ETH_PHY_CNT,\n\t\t.strings\t= stats_eth_phy_names,\n\t},\n\t[ETH_SS_STATS_ETH_MAC] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= __ETHTOOL_A_STATS_ETH_MAC_CNT,\n\t\t.strings\t= stats_eth_mac_names,\n\t},\n\t[ETH_SS_STATS_ETH_CTRL] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= __ETHTOOL_A_STATS_ETH_CTRL_CNT,\n\t\t.strings\t= stats_eth_ctrl_names,\n\t},\n\t[ETH_SS_STATS_RMON] = {\n\t\t.per_dev\t= false,\n\t\t.count\t\t= __ETHTOOL_A_STATS_RMON_CNT,\n\t\t.strings\t= stats_rmon_names,\n\t},\n};\n\nstruct strset_req_info {\n\tstruct ethnl_req_info\t\tbase;\n\tu32\t\t\t\treq_ids;\n\tbool\t\t\t\tcounts_only;\n};\n\n#define STRSET_REQINFO(__req_base) \\\n\tcontainer_of(__req_base, struct strset_req_info, base)\n\nstruct strset_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tstruct strset_info\t\tsets[ETH_SS_COUNT];\n};\n\n#define STRSET_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct strset_reply_data, base)\n\nconst struct nla_policy ethnl_strset_get_policy[] = {\n\t[ETHTOOL_A_STRSET_HEADER]\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_STRSET_STRINGSETS]\t= { .type = NLA_NESTED },\n\t[ETHTOOL_A_STRSET_COUNTS_ONLY]\t= { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy get_stringset_policy[] = {\n\t[ETHTOOL_A_STRINGSET_ID]\t= { .type = NLA_U32 },\n};\n\n \nstatic bool strset_include(const struct strset_req_info *info,\n\t\t\t   const struct strset_reply_data *data, u32 id)\n{\n\tbool per_dev;\n\n\tBUILD_BUG_ON(ETH_SS_COUNT >= BITS_PER_BYTE * sizeof(info->req_ids));\n\n\tif (info->req_ids)\n\t\treturn info->req_ids & (1U << id);\n\tper_dev = data->sets[id].per_dev;\n\tif (!per_dev && !data->sets[id].strings)\n\t\treturn false;\n\n\treturn data->base.dev ? per_dev : !per_dev;\n}\n\nstatic int strset_get_id(const struct nlattr *nest, u32 *val,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(get_stringset_policy)];\n\tint ret;\n\n\tret = nla_parse_nested(tb, ARRAY_SIZE(get_stringset_policy) - 1, nest,\n\t\t\t       get_stringset_policy, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (NL_REQ_ATTR_CHECK(extack, nest, tb, ETHTOOL_A_STRINGSET_ID))\n\t\treturn -EINVAL;\n\n\t*val = nla_get_u32(tb[ETHTOOL_A_STRINGSET_ID]);\n\treturn 0;\n}\n\nstatic const struct nla_policy strset_stringsets_policy[] = {\n\t[ETHTOOL_A_STRINGSETS_STRINGSET]\t= { .type = NLA_NESTED },\n};\n\nstatic int strset_parse_request(struct ethnl_req_info *req_base,\n\t\t\t\tstruct nlattr **tb,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct strset_req_info *req_info = STRSET_REQINFO(req_base);\n\tstruct nlattr *nest = tb[ETHTOOL_A_STRSET_STRINGSETS];\n\tstruct nlattr *attr;\n\tint rem, ret;\n\n\tif (!nest)\n\t\treturn 0;\n\tret = nla_validate_nested(nest,\n\t\t\t\t  ARRAY_SIZE(strset_stringsets_policy) - 1,\n\t\t\t\t  strset_stringsets_policy, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treq_info->counts_only = tb[ETHTOOL_A_STRSET_COUNTS_ONLY];\n\tnla_for_each_nested(attr, nest, rem) {\n\t\tu32 id;\n\n\t\tif (WARN_ONCE(nla_type(attr) != ETHTOOL_A_STRINGSETS_STRINGSET,\n\t\t\t      \"unexpected attrtype %u in ETHTOOL_A_STRSET_STRINGSETS\\n\",\n\t\t\t      nla_type(attr)))\n\t\t\treturn -EINVAL;\n\n\t\tret = strset_get_id(attr, &id, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (id >= ETH_SS_COUNT) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t    \"unknown string set id\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\treq_info->req_ids |= (1U << id);\n\t}\n\n\treturn 0;\n}\n\nstatic void strset_cleanup_data(struct ethnl_reply_data *reply_base)\n{\n\tstruct strset_reply_data *data = STRSET_REPDATA(reply_base);\n\tunsigned int i;\n\n\tfor (i = 0; i < ETH_SS_COUNT; i++)\n\t\tif (data->sets[i].free_strings) {\n\t\t\tkfree(data->sets[i].strings);\n\t\t\tdata->sets[i].strings = NULL;\n\t\t\tdata->sets[i].free_strings = false;\n\t\t}\n}\n\nstatic int strset_prepare_set(struct strset_info *info, struct net_device *dev,\n\t\t\t      unsigned int id, bool counts_only)\n{\n\tconst struct ethtool_phy_ops *phy_ops = ethtool_phy_ops;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tvoid *strings;\n\tint count, ret;\n\n\tif (id == ETH_SS_PHY_STATS && dev->phydev &&\n\t    !ops->get_ethtool_phy_stats && phy_ops &&\n\t    phy_ops->get_sset_count)\n\t\tret = phy_ops->get_sset_count(dev->phydev);\n\telse if (ops->get_sset_count && ops->get_strings)\n\t\tret = ops->get_sset_count(dev, id);\n\telse\n\t\tret = -EOPNOTSUPP;\n\tif (ret <= 0) {\n\t\tinfo->count = 0;\n\t\treturn 0;\n\t}\n\n\tcount = ret;\n\tif (!counts_only) {\n\t\tstrings = kcalloc(count, ETH_GSTRING_LEN, GFP_KERNEL);\n\t\tif (!strings)\n\t\t\treturn -ENOMEM;\n\t\tif (id == ETH_SS_PHY_STATS && dev->phydev &&\n\t\t    !ops->get_ethtool_phy_stats && phy_ops &&\n\t\t    phy_ops->get_strings)\n\t\t\tphy_ops->get_strings(dev->phydev, strings);\n\t\telse\n\t\t\tops->get_strings(dev, id, strings);\n\t\tinfo->strings = strings;\n\t\tinfo->free_strings = true;\n\t}\n\tinfo->count = count;\n\n\treturn 0;\n}\n\nstatic int strset_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t       struct ethnl_reply_data *reply_base,\n\t\t\t       const struct genl_info *info)\n{\n\tconst struct strset_req_info *req_info = STRSET_REQINFO(req_base);\n\tstruct strset_reply_data *data = STRSET_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tunsigned int i;\n\tint ret;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(info_template) != ETH_SS_COUNT);\n\tmemcpy(&data->sets, &info_template, sizeof(data->sets));\n\n\tif (!dev) {\n\t\tfor (i = 0; i < ETH_SS_COUNT; i++) {\n\t\t\tif ((req_info->req_ids & (1U << i)) &&\n\t\t\t    data->sets[i].per_dev) {\n\t\t\t\tif (info)\n\t\t\t\t\tGENL_SET_ERR_MSG(info, \"requested per device strings without dev\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\tgoto err_strset;\n\tfor (i = 0; i < ETH_SS_COUNT; i++) {\n\t\tif (!strset_include(req_info, data, i) ||\n\t\t    !data->sets[i].per_dev)\n\t\t\tcontinue;\n\n\t\tret = strset_prepare_set(&data->sets[i], dev, i,\n\t\t\t\t\t req_info->counts_only);\n\t\tif (ret < 0)\n\t\t\tgoto err_ops;\n\t}\n\tethnl_ops_complete(dev);\n\n\treturn 0;\nerr_ops:\n\tethnl_ops_complete(dev);\nerr_strset:\n\tstrset_cleanup_data(reply_base);\n\treturn ret;\n}\n\n \nstatic int strset_set_size(const struct strset_info *info, bool counts_only)\n{\n\tunsigned int len = 0;\n\tunsigned int i;\n\n\tif (info->count == 0)\n\t\treturn 0;\n\tif (counts_only)\n\t\treturn nla_total_size(2 * nla_total_size(sizeof(u32)));\n\n\tfor (i = 0; i < info->count; i++) {\n\t\tconst char *str = info->strings[i];\n\n\t\t \n\t\tlen += nla_total_size(nla_total_size(sizeof(u32)) +\n\t\t\t\t      ethnl_strz_size(str));\n\t}\n\t \n\tlen = 2 * nla_total_size(sizeof(u32)) + nla_total_size(len);\n\n\treturn nla_total_size(len);\n}\n\nstatic int strset_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t     const struct ethnl_reply_data *reply_base)\n{\n\tconst struct strset_req_info *req_info = STRSET_REQINFO(req_base);\n\tconst struct strset_reply_data *data = STRSET_REPDATA(reply_base);\n\tunsigned int i;\n\tint len = 0;\n\tint ret;\n\n\tlen += nla_total_size(0);  \n\n\tfor (i = 0; i < ETH_SS_COUNT; i++) {\n\t\tconst struct strset_info *set_info = &data->sets[i];\n\n\t\tif (!strset_include(req_info, data, i))\n\t\t\tcontinue;\n\n\t\tret = strset_set_size(set_info, req_info->counts_only);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tlen += ret;\n\t}\n\n\treturn len;\n}\n\n \nstatic int strset_fill_string(struct sk_buff *skb,\n\t\t\t      const struct strset_info *set_info, u32 idx)\n{\n\tstruct nlattr *string_attr;\n\tconst char *value;\n\n\tvalue = set_info->strings[idx];\n\n\tstring_attr = nla_nest_start(skb, ETHTOOL_A_STRINGS_STRING);\n\tif (!string_attr)\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u32(skb, ETHTOOL_A_STRING_INDEX, idx) ||\n\t    ethnl_put_strz(skb, ETHTOOL_A_STRING_VALUE, value))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, string_attr);\n\n\treturn 0;\nnla_put_failure:\n\tnla_nest_cancel(skb, string_attr);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int strset_fill_set(struct sk_buff *skb,\n\t\t\t   const struct strset_info *set_info, u32 id,\n\t\t\t   bool counts_only)\n{\n\tstruct nlattr *stringset_attr;\n\tstruct nlattr *strings_attr;\n\tunsigned int i;\n\n\tif (!set_info->per_dev && !set_info->strings)\n\t\treturn -EOPNOTSUPP;\n\tif (set_info->count == 0)\n\t\treturn 0;\n\tstringset_attr = nla_nest_start(skb, ETHTOOL_A_STRINGSETS_STRINGSET);\n\tif (!stringset_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, ETHTOOL_A_STRINGSET_ID, id) ||\n\t    nla_put_u32(skb, ETHTOOL_A_STRINGSET_COUNT, set_info->count))\n\t\tgoto nla_put_failure;\n\n\tif (!counts_only) {\n\t\tstrings_attr = nla_nest_start(skb, ETHTOOL_A_STRINGSET_STRINGS);\n\t\tif (!strings_attr)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < set_info->count; i++) {\n\t\t\tif (strset_fill_string(skb, set_info, i) < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, strings_attr);\n\t}\n\n\tnla_nest_end(skb, stringset_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, stringset_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int strset_fill_reply(struct sk_buff *skb,\n\t\t\t     const struct ethnl_req_info *req_base,\n\t\t\t     const struct ethnl_reply_data *reply_base)\n{\n\tconst struct strset_req_info *req_info = STRSET_REQINFO(req_base);\n\tconst struct strset_reply_data *data = STRSET_REPDATA(reply_base);\n\tstruct nlattr *nest;\n\tunsigned int i;\n\tint ret;\n\n\tnest = nla_nest_start(skb, ETHTOOL_A_STRSET_STRINGSETS);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < ETH_SS_COUNT; i++) {\n\t\tif (strset_include(req_info, data, i)) {\n\t\t\tret = strset_fill_set(skb, &data->sets[i], i,\n\t\t\t\t\t      req_info->counts_only);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn ret;\n}\n\nconst struct ethnl_request_ops ethnl_strset_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_STRSET_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_STRSET_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_STRSET_HEADER,\n\t.req_info_size\t\t= sizeof(struct strset_req_info),\n\t.reply_data_size\t= sizeof(struct strset_reply_data),\n\t.allow_nodev_do\t\t= true,\n\n\t.parse_request\t\t= strset_parse_request,\n\t.prepare_data\t\t= strset_prepare_data,\n\t.reply_size\t\t= strset_reply_size,\n\t.fill_reply\t\t= strset_fill_reply,\n\t.cleanup_data\t\t= strset_cleanup_data,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}