{
  "module_name": "ioctl.c",
  "hash_id": "84cc80b193794c8ad780decf70ca6cadb311cce620494cb41901209201bad9cb",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/phy.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/sfp.h>\n#include <linux/slab.h>\n#include <linux/rtnetlink.h>\n#include <linux/sched/signal.h>\n#include <linux/net.h>\n#include <linux/pm_runtime.h>\n#include <net/devlink.h>\n#include <net/ipv6.h>\n#include <net/xdp_sock_drv.h>\n#include <net/flow_offload.h>\n#include <linux/ethtool_netlink.h>\n#include <generated/utsrelease.h>\n#include \"common.h\"\n\n \nstruct ethtool_devlink_compat {\n\tstruct devlink *devlink;\n\tunion {\n\t\tstruct ethtool_flash efl;\n\t\tstruct ethtool_drvinfo info;\n\t};\n};\n\nstatic struct devlink *netdev_to_devlink_get(struct net_device *dev)\n{\n\tif (!dev->devlink_port)\n\t\treturn NULL;\n\treturn devlink_try_get(dev->devlink_port->devlink);\n}\n\n \n\nu32 ethtool_op_get_link(struct net_device *dev)\n{\n\treturn netif_carrier_ok(dev) ? 1 : 0;\n}\nEXPORT_SYMBOL(ethtool_op_get_link);\n\nint ethtool_op_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)\n{\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE;\n\tinfo->phc_index = -1;\n\treturn 0;\n}\nEXPORT_SYMBOL(ethtool_op_get_ts_info);\n\n \n\nstatic int ethtool_get_features(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_gfeatures cmd = {\n\t\t.cmd = ETHTOOL_GFEATURES,\n\t\t.size = ETHTOOL_DEV_FEATURE_WORDS,\n\t};\n\tstruct ethtool_get_features_block features[ETHTOOL_DEV_FEATURE_WORDS];\n\tu32 __user *sizeaddr;\n\tu32 copy_size;\n\tint i;\n\n\t \n\tBUILD_BUG_ON(ETHTOOL_DEV_FEATURE_WORDS * sizeof(u32) > sizeof(netdev_features_t));\n\n\tfor (i = 0; i < ETHTOOL_DEV_FEATURE_WORDS; ++i) {\n\t\tfeatures[i].available = (u32)(dev->hw_features >> (32 * i));\n\t\tfeatures[i].requested = (u32)(dev->wanted_features >> (32 * i));\n\t\tfeatures[i].active = (u32)(dev->features >> (32 * i));\n\t\tfeatures[i].never_changed =\n\t\t\t(u32)(NETIF_F_NEVER_CHANGE >> (32 * i));\n\t}\n\n\tsizeaddr = useraddr + offsetof(struct ethtool_gfeatures, size);\n\tif (get_user(copy_size, sizeaddr))\n\t\treturn -EFAULT;\n\n\tif (copy_size > ETHTOOL_DEV_FEATURE_WORDS)\n\t\tcopy_size = ETHTOOL_DEV_FEATURE_WORDS;\n\n\tif (copy_to_user(useraddr, &cmd, sizeof(cmd)))\n\t\treturn -EFAULT;\n\tuseraddr += sizeof(cmd);\n\tif (copy_to_user(useraddr, features,\n\t\t\t array_size(copy_size, sizeof(*features))))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ethtool_set_features(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_sfeatures cmd;\n\tstruct ethtool_set_features_block features[ETHTOOL_DEV_FEATURE_WORDS];\n\tnetdev_features_t wanted = 0, valid = 0;\n\tint i, ret = 0;\n\n\tif (copy_from_user(&cmd, useraddr, sizeof(cmd)))\n\t\treturn -EFAULT;\n\tuseraddr += sizeof(cmd);\n\n\tif (cmd.size != ETHTOOL_DEV_FEATURE_WORDS)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(features, useraddr, sizeof(features)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < ETHTOOL_DEV_FEATURE_WORDS; ++i) {\n\t\tvalid |= (netdev_features_t)features[i].valid << (32 * i);\n\t\twanted |= (netdev_features_t)features[i].requested << (32 * i);\n\t}\n\n\tif (valid & ~NETIF_F_ETHTOOL_BITS)\n\t\treturn -EINVAL;\n\n\tif (valid & ~dev->hw_features) {\n\t\tvalid &= dev->hw_features;\n\t\tret |= ETHTOOL_F_UNSUPPORTED;\n\t}\n\n\tdev->wanted_features &= ~valid;\n\tdev->wanted_features |= wanted & valid;\n\t__netdev_update_features(dev);\n\n\tif ((dev->wanted_features ^ dev->features) & valid)\n\t\tret |= ETHTOOL_F_WISH;\n\n\treturn ret;\n}\n\nstatic int __ethtool_get_sset_count(struct net_device *dev, int sset)\n{\n\tconst struct ethtool_phy_ops *phy_ops = ethtool_phy_ops;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\n\tif (sset == ETH_SS_FEATURES)\n\t\treturn ARRAY_SIZE(netdev_features_strings);\n\n\tif (sset == ETH_SS_RSS_HASH_FUNCS)\n\t\treturn ARRAY_SIZE(rss_hash_func_strings);\n\n\tif (sset == ETH_SS_TUNABLES)\n\t\treturn ARRAY_SIZE(tunable_strings);\n\n\tif (sset == ETH_SS_PHY_TUNABLES)\n\t\treturn ARRAY_SIZE(phy_tunable_strings);\n\n\tif (sset == ETH_SS_PHY_STATS && dev->phydev &&\n\t    !ops->get_ethtool_phy_stats &&\n\t    phy_ops && phy_ops->get_sset_count)\n\t\treturn phy_ops->get_sset_count(dev->phydev);\n\n\tif (sset == ETH_SS_LINK_MODES)\n\t\treturn __ETHTOOL_LINK_MODE_MASK_NBITS;\n\n\tif (ops->get_sset_count && ops->get_strings)\n\t\treturn ops->get_sset_count(dev, sset);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic void __ethtool_get_strings(struct net_device *dev,\n\tu32 stringset, u8 *data)\n{\n\tconst struct ethtool_phy_ops *phy_ops = ethtool_phy_ops;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\n\tif (stringset == ETH_SS_FEATURES)\n\t\tmemcpy(data, netdev_features_strings,\n\t\t\tsizeof(netdev_features_strings));\n\telse if (stringset == ETH_SS_RSS_HASH_FUNCS)\n\t\tmemcpy(data, rss_hash_func_strings,\n\t\t       sizeof(rss_hash_func_strings));\n\telse if (stringset == ETH_SS_TUNABLES)\n\t\tmemcpy(data, tunable_strings, sizeof(tunable_strings));\n\telse if (stringset == ETH_SS_PHY_TUNABLES)\n\t\tmemcpy(data, phy_tunable_strings, sizeof(phy_tunable_strings));\n\telse if (stringset == ETH_SS_PHY_STATS && dev->phydev &&\n\t\t !ops->get_ethtool_phy_stats && phy_ops &&\n\t\t phy_ops->get_strings)\n\t\tphy_ops->get_strings(dev->phydev, data);\n\telse if (stringset == ETH_SS_LINK_MODES)\n\t\tmemcpy(data, link_mode_names,\n\t\t       __ETHTOOL_LINK_MODE_MASK_NBITS * ETH_GSTRING_LEN);\n\telse\n\t\t \n\t\tops->get_strings(dev, stringset, data);\n}\n\nstatic netdev_features_t ethtool_get_feature_mask(u32 eth_cmd)\n{\n\t \n\n\tswitch (eth_cmd) {\n\tcase ETHTOOL_GTXCSUM:\n\tcase ETHTOOL_STXCSUM:\n\t\treturn NETIF_F_CSUM_MASK | NETIF_F_FCOE_CRC |\n\t\t       NETIF_F_SCTP_CRC;\n\tcase ETHTOOL_GRXCSUM:\n\tcase ETHTOOL_SRXCSUM:\n\t\treturn NETIF_F_RXCSUM;\n\tcase ETHTOOL_GSG:\n\tcase ETHTOOL_SSG:\n\t\treturn NETIF_F_SG | NETIF_F_FRAGLIST;\n\tcase ETHTOOL_GTSO:\n\tcase ETHTOOL_STSO:\n\t\treturn NETIF_F_ALL_TSO;\n\tcase ETHTOOL_GGSO:\n\tcase ETHTOOL_SGSO:\n\t\treturn NETIF_F_GSO;\n\tcase ETHTOOL_GGRO:\n\tcase ETHTOOL_SGRO:\n\t\treturn NETIF_F_GRO;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic int ethtool_get_one_feature(struct net_device *dev,\n\tchar __user *useraddr, u32 ethcmd)\n{\n\tnetdev_features_t mask = ethtool_get_feature_mask(ethcmd);\n\tstruct ethtool_value edata = {\n\t\t.cmd = ethcmd,\n\t\t.data = !!(dev->features & mask),\n\t};\n\n\tif (copy_to_user(useraddr, &edata, sizeof(edata)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ethtool_set_one_feature(struct net_device *dev,\n\tvoid __user *useraddr, u32 ethcmd)\n{\n\tstruct ethtool_value edata;\n\tnetdev_features_t mask;\n\n\tif (copy_from_user(&edata, useraddr, sizeof(edata)))\n\t\treturn -EFAULT;\n\n\tmask = ethtool_get_feature_mask(ethcmd);\n\tmask &= dev->hw_features;\n\tif (!mask)\n\t\treturn -EOPNOTSUPP;\n\n\tif (edata.data)\n\t\tdev->wanted_features |= mask;\n\telse\n\t\tdev->wanted_features &= ~mask;\n\n\t__netdev_update_features(dev);\n\n\treturn 0;\n}\n\n#define ETH_ALL_FLAGS    (ETH_FLAG_LRO | ETH_FLAG_RXVLAN | ETH_FLAG_TXVLAN | \\\n\t\t\t  ETH_FLAG_NTUPLE | ETH_FLAG_RXHASH)\n#define ETH_ALL_FEATURES (NETIF_F_LRO | NETIF_F_HW_VLAN_CTAG_RX | \\\n\t\t\t  NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_NTUPLE | \\\n\t\t\t  NETIF_F_RXHASH)\n\nstatic u32 __ethtool_get_flags(struct net_device *dev)\n{\n\tu32 flags = 0;\n\n\tif (dev->features & NETIF_F_LRO)\n\t\tflags |= ETH_FLAG_LRO;\n\tif (dev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tflags |= ETH_FLAG_RXVLAN;\n\tif (dev->features & NETIF_F_HW_VLAN_CTAG_TX)\n\t\tflags |= ETH_FLAG_TXVLAN;\n\tif (dev->features & NETIF_F_NTUPLE)\n\t\tflags |= ETH_FLAG_NTUPLE;\n\tif (dev->features & NETIF_F_RXHASH)\n\t\tflags |= ETH_FLAG_RXHASH;\n\n\treturn flags;\n}\n\nstatic int __ethtool_set_flags(struct net_device *dev, u32 data)\n{\n\tnetdev_features_t features = 0, changed;\n\n\tif (data & ~ETH_ALL_FLAGS)\n\t\treturn -EINVAL;\n\n\tif (data & ETH_FLAG_LRO)\n\t\tfeatures |= NETIF_F_LRO;\n\tif (data & ETH_FLAG_RXVLAN)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_RX;\n\tif (data & ETH_FLAG_TXVLAN)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\tif (data & ETH_FLAG_NTUPLE)\n\t\tfeatures |= NETIF_F_NTUPLE;\n\tif (data & ETH_FLAG_RXHASH)\n\t\tfeatures |= NETIF_F_RXHASH;\n\n\t \n\tchanged = (features ^ dev->features) & ETH_ALL_FEATURES;\n\tif (changed & ~dev->hw_features)\n\t\treturn (changed & dev->hw_features) ? -EINVAL : -EOPNOTSUPP;\n\n\tdev->wanted_features =\n\t\t(dev->wanted_features & ~changed) | (features & changed);\n\n\t__netdev_update_features(dev);\n\n\treturn 0;\n}\n\n \nvoid ethtool_intersect_link_masks(struct ethtool_link_ksettings *dst,\n\t\t\t\t  struct ethtool_link_ksettings *src)\n{\n\tunsigned int size = BITS_TO_LONGS(__ETHTOOL_LINK_MODE_MASK_NBITS);\n\tunsigned int idx = 0;\n\n\tfor (; idx < size; idx++) {\n\t\tdst->link_modes.supported[idx] &=\n\t\t\tsrc->link_modes.supported[idx];\n\t\tdst->link_modes.advertising[idx] &=\n\t\t\tsrc->link_modes.advertising[idx];\n\t}\n}\nEXPORT_SYMBOL(ethtool_intersect_link_masks);\n\nvoid ethtool_convert_legacy_u32_to_link_mode(unsigned long *dst,\n\t\t\t\t\t     u32 legacy_u32)\n{\n\tlinkmode_zero(dst);\n\tdst[0] = legacy_u32;\n}\nEXPORT_SYMBOL(ethtool_convert_legacy_u32_to_link_mode);\n\n \nbool ethtool_convert_link_mode_to_legacy_u32(u32 *legacy_u32,\n\t\t\t\t\t     const unsigned long *src)\n{\n\t*legacy_u32 = src[0];\n\treturn find_next_bit(src, __ETHTOOL_LINK_MODE_MASK_NBITS, 32) ==\n\t\t__ETHTOOL_LINK_MODE_MASK_NBITS;\n}\nEXPORT_SYMBOL(ethtool_convert_link_mode_to_legacy_u32);\n\n \nstatic bool\nconvert_link_ksettings_to_legacy_settings(\n\tstruct ethtool_cmd *legacy_settings,\n\tconst struct ethtool_link_ksettings *link_ksettings)\n{\n\tbool retval = true;\n\n\tmemset(legacy_settings, 0, sizeof(*legacy_settings));\n\t \n\n\tretval &= ethtool_convert_link_mode_to_legacy_u32(\n\t\t&legacy_settings->supported,\n\t\tlink_ksettings->link_modes.supported);\n\tretval &= ethtool_convert_link_mode_to_legacy_u32(\n\t\t&legacy_settings->advertising,\n\t\tlink_ksettings->link_modes.advertising);\n\tretval &= ethtool_convert_link_mode_to_legacy_u32(\n\t\t&legacy_settings->lp_advertising,\n\t\tlink_ksettings->link_modes.lp_advertising);\n\tethtool_cmd_speed_set(legacy_settings, link_ksettings->base.speed);\n\tlegacy_settings->duplex\n\t\t= link_ksettings->base.duplex;\n\tlegacy_settings->port\n\t\t= link_ksettings->base.port;\n\tlegacy_settings->phy_address\n\t\t= link_ksettings->base.phy_address;\n\tlegacy_settings->autoneg\n\t\t= link_ksettings->base.autoneg;\n\tlegacy_settings->mdio_support\n\t\t= link_ksettings->base.mdio_support;\n\tlegacy_settings->eth_tp_mdix\n\t\t= link_ksettings->base.eth_tp_mdix;\n\tlegacy_settings->eth_tp_mdix_ctrl\n\t\t= link_ksettings->base.eth_tp_mdix_ctrl;\n\tlegacy_settings->transceiver\n\t\t= link_ksettings->base.transceiver;\n\treturn retval;\n}\n\n \n#define __ETHTOOL_LINK_MODE_MASK_NU32\t\t\t\\\n\tDIV_ROUND_UP(__ETHTOOL_LINK_MODE_MASK_NBITS, 32)\n\n \nstruct ethtool_link_usettings {\n\tstruct ethtool_link_settings base;\n\tstruct {\n\t\t__u32 supported[__ETHTOOL_LINK_MODE_MASK_NU32];\n\t\t__u32 advertising[__ETHTOOL_LINK_MODE_MASK_NU32];\n\t\t__u32 lp_advertising[__ETHTOOL_LINK_MODE_MASK_NU32];\n\t} link_modes;\n};\n\n \nint __ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\t struct ethtool_link_ksettings *link_ksettings)\n{\n\tASSERT_RTNL();\n\n\tif (!dev->ethtool_ops->get_link_ksettings)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(link_ksettings, 0, sizeof(*link_ksettings));\n\treturn dev->ethtool_ops->get_link_ksettings(dev, link_ksettings);\n}\nEXPORT_SYMBOL(__ethtool_get_link_ksettings);\n\n \nstatic int load_link_ksettings_from_user(struct ethtool_link_ksettings *to,\n\t\t\t\t\t const void __user *from)\n{\n\tstruct ethtool_link_usettings link_usettings;\n\n\tif (copy_from_user(&link_usettings, from, sizeof(link_usettings)))\n\t\treturn -EFAULT;\n\n\tmemcpy(&to->base, &link_usettings.base, sizeof(to->base));\n\tbitmap_from_arr32(to->link_modes.supported,\n\t\t\t  link_usettings.link_modes.supported,\n\t\t\t  __ETHTOOL_LINK_MODE_MASK_NBITS);\n\tbitmap_from_arr32(to->link_modes.advertising,\n\t\t\t  link_usettings.link_modes.advertising,\n\t\t\t  __ETHTOOL_LINK_MODE_MASK_NBITS);\n\tbitmap_from_arr32(to->link_modes.lp_advertising,\n\t\t\t  link_usettings.link_modes.lp_advertising,\n\t\t\t  __ETHTOOL_LINK_MODE_MASK_NBITS);\n\n\treturn 0;\n}\n\n \nbool ethtool_virtdev_validate_cmd(const struct ethtool_link_ksettings *cmd)\n{\n\tstruct ethtool_link_settings base2 = {};\n\n\tbase2.speed = cmd->base.speed;\n\tbase2.port = PORT_OTHER;\n\tbase2.duplex = cmd->base.duplex;\n\tbase2.cmd = cmd->base.cmd;\n\tbase2.link_mode_masks_nwords = cmd->base.link_mode_masks_nwords;\n\n\treturn !memcmp(&base2, &cmd->base, sizeof(base2)) &&\n\t\tbitmap_empty(cmd->link_modes.supported,\n\t\t\t     __ETHTOOL_LINK_MODE_MASK_NBITS) &&\n\t\tbitmap_empty(cmd->link_modes.lp_advertising,\n\t\t\t     __ETHTOOL_LINK_MODE_MASK_NBITS);\n}\n\n \nstatic int\nstore_link_ksettings_for_user(void __user *to,\n\t\t\t      const struct ethtool_link_ksettings *from)\n{\n\tstruct ethtool_link_usettings link_usettings;\n\n\tmemcpy(&link_usettings, from, sizeof(link_usettings));\n\tbitmap_to_arr32(link_usettings.link_modes.supported,\n\t\t\tfrom->link_modes.supported,\n\t\t\t__ETHTOOL_LINK_MODE_MASK_NBITS);\n\tbitmap_to_arr32(link_usettings.link_modes.advertising,\n\t\t\tfrom->link_modes.advertising,\n\t\t\t__ETHTOOL_LINK_MODE_MASK_NBITS);\n\tbitmap_to_arr32(link_usettings.link_modes.lp_advertising,\n\t\t\tfrom->link_modes.lp_advertising,\n\t\t\t__ETHTOOL_LINK_MODE_MASK_NBITS);\n\n\tif (copy_to_user(to, &link_usettings, sizeof(link_usettings)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\t      void __user *useraddr)\n{\n\tint err = 0;\n\tstruct ethtool_link_ksettings link_ksettings;\n\n\tASSERT_RTNL();\n\tif (!dev->ethtool_ops->get_link_ksettings)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (copy_from_user(&link_ksettings.base, useraddr,\n\t\t\t   sizeof(link_ksettings.base)))\n\t\treturn -EFAULT;\n\n\tif (__ETHTOOL_LINK_MODE_MASK_NU32\n\t    != link_ksettings.base.link_mode_masks_nwords) {\n\t\t \n\t\tmemset(&link_ksettings, 0, sizeof(link_ksettings));\n\t\tlink_ksettings.base.cmd = ETHTOOL_GLINKSETTINGS;\n\t\t \n\t\tcompiletime_assert(__ETHTOOL_LINK_MODE_MASK_NU32 <= S8_MAX,\n\t\t\t\t   \"need too many bits for link modes!\");\n\t\tlink_ksettings.base.link_mode_masks_nwords\n\t\t\t= -((s8)__ETHTOOL_LINK_MODE_MASK_NU32);\n\n\t\t \n\t\tif (copy_to_user(useraddr, &link_ksettings.base,\n\t\t\t\t sizeof(link_ksettings.base)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\t \n\n\tmemset(&link_ksettings, 0, sizeof(link_ksettings));\n\terr = dev->ethtool_ops->get_link_ksettings(dev, &link_ksettings);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tlink_ksettings.base.cmd = ETHTOOL_GLINKSETTINGS;\n\tlink_ksettings.base.link_mode_masks_nwords\n\t\t= __ETHTOOL_LINK_MODE_MASK_NU32;\n\tlink_ksettings.base.master_slave_cfg = MASTER_SLAVE_CFG_UNSUPPORTED;\n\tlink_ksettings.base.master_slave_state = MASTER_SLAVE_STATE_UNSUPPORTED;\n\tlink_ksettings.base.rate_matching = RATE_MATCH_NONE;\n\n\treturn store_link_ksettings_for_user(useraddr, &link_ksettings);\n}\n\n \nstatic int ethtool_set_link_ksettings(struct net_device *dev,\n\t\t\t\t      void __user *useraddr)\n{\n\tstruct ethtool_link_ksettings link_ksettings = {};\n\tint err;\n\n\tASSERT_RTNL();\n\n\tif (!dev->ethtool_ops->set_link_ksettings)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (copy_from_user(&link_ksettings.base, useraddr,\n\t\t\t   sizeof(link_ksettings.base)))\n\t\treturn -EFAULT;\n\n\tif (__ETHTOOL_LINK_MODE_MASK_NU32\n\t    != link_ksettings.base.link_mode_masks_nwords)\n\t\treturn -EINVAL;\n\n\t \n\terr = load_link_ksettings_from_user(&link_ksettings, useraddr);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (__ETHTOOL_LINK_MODE_MASK_NU32\n\t    != link_ksettings.base.link_mode_masks_nwords)\n\t\treturn -EINVAL;\n\n\tif (link_ksettings.base.master_slave_cfg ||\n\t    link_ksettings.base.master_slave_state)\n\t\treturn -EINVAL;\n\n\terr = dev->ethtool_ops->set_link_ksettings(dev, &link_ksettings);\n\tif (err >= 0) {\n\t\tethtool_notify(dev, ETHTOOL_MSG_LINKINFO_NTF, NULL);\n\t\tethtool_notify(dev, ETHTOOL_MSG_LINKMODES_NTF, NULL);\n\t}\n\treturn err;\n}\n\nint ethtool_virtdev_set_link_ksettings(struct net_device *dev,\n\t\t\t\t       const struct ethtool_link_ksettings *cmd,\n\t\t\t\t       u32 *dev_speed, u8 *dev_duplex)\n{\n\tu32 speed;\n\tu8 duplex;\n\n\tspeed = cmd->base.speed;\n\tduplex = cmd->base.duplex;\n\t \n\tif (!ethtool_validate_speed(speed) ||\n\t    !ethtool_validate_duplex(duplex) ||\n\t    !ethtool_virtdev_validate_cmd(cmd))\n\t\treturn -EINVAL;\n\t*dev_speed = speed;\n\t*dev_duplex = duplex;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ethtool_virtdev_set_link_ksettings);\n\n \nstatic int ethtool_get_settings(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_link_ksettings link_ksettings;\n\tstruct ethtool_cmd cmd;\n\tint err;\n\n\tASSERT_RTNL();\n\tif (!dev->ethtool_ops->get_link_ksettings)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&link_ksettings, 0, sizeof(link_ksettings));\n\terr = dev->ethtool_ops->get_link_ksettings(dev, &link_ksettings);\n\tif (err < 0)\n\t\treturn err;\n\tconvert_link_ksettings_to_legacy_settings(&cmd, &link_ksettings);\n\n\t \n\tcmd.cmd = ETHTOOL_GSET;\n\n\tif (copy_to_user(useraddr, &cmd, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int ethtool_set_settings(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_link_ksettings link_ksettings;\n\tstruct ethtool_cmd cmd;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (copy_from_user(&cmd, useraddr, sizeof(cmd)))\n\t\treturn -EFAULT;\n\tif (!dev->ethtool_ops->set_link_ksettings)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!convert_legacy_settings_to_link_ksettings(&link_ksettings, &cmd))\n\t\treturn -EINVAL;\n\tlink_ksettings.base.link_mode_masks_nwords =\n\t\t__ETHTOOL_LINK_MODE_MASK_NU32;\n\tret = dev->ethtool_ops->set_link_ksettings(dev, &link_ksettings);\n\tif (ret >= 0) {\n\t\tethtool_notify(dev, ETHTOOL_MSG_LINKINFO_NTF, NULL);\n\t\tethtool_notify(dev, ETHTOOL_MSG_LINKMODES_NTF, NULL);\n\t}\n\treturn ret;\n}\n\nstatic int\nethtool_get_drvinfo(struct net_device *dev, struct ethtool_devlink_compat *rsp)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct device *parent = dev->dev.parent;\n\n\trsp->info.cmd = ETHTOOL_GDRVINFO;\n\tstrscpy(rsp->info.version, UTS_RELEASE, sizeof(rsp->info.version));\n\tif (ops->get_drvinfo) {\n\t\tops->get_drvinfo(dev, &rsp->info);\n\t\tif (!rsp->info.bus_info[0] && parent)\n\t\t\tstrscpy(rsp->info.bus_info, dev_name(parent),\n\t\t\t\tsizeof(rsp->info.bus_info));\n\t\tif (!rsp->info.driver[0] && parent && parent->driver)\n\t\t\tstrscpy(rsp->info.driver, parent->driver->name,\n\t\t\t\tsizeof(rsp->info.driver));\n\t} else if (parent && parent->driver) {\n\t\tstrscpy(rsp->info.bus_info, dev_name(parent),\n\t\t\tsizeof(rsp->info.bus_info));\n\t\tstrscpy(rsp->info.driver, parent->driver->name,\n\t\t\tsizeof(rsp->info.driver));\n\t} else if (dev->rtnl_link_ops) {\n\t\tstrscpy(rsp->info.driver, dev->rtnl_link_ops->kind,\n\t\t\tsizeof(rsp->info.driver));\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (ops->get_sset_count) {\n\t\tint rc;\n\n\t\trc = ops->get_sset_count(dev, ETH_SS_TEST);\n\t\tif (rc >= 0)\n\t\t\trsp->info.testinfo_len = rc;\n\t\trc = ops->get_sset_count(dev, ETH_SS_STATS);\n\t\tif (rc >= 0)\n\t\t\trsp->info.n_stats = rc;\n\t\trc = ops->get_sset_count(dev, ETH_SS_PRIV_FLAGS);\n\t\tif (rc >= 0)\n\t\t\trsp->info.n_priv_flags = rc;\n\t}\n\tif (ops->get_regs_len) {\n\t\tint ret = ops->get_regs_len(dev);\n\n\t\tif (ret > 0)\n\t\t\trsp->info.regdump_len = ret;\n\t}\n\n\tif (ops->get_eeprom_len)\n\t\trsp->info.eedump_len = ops->get_eeprom_len(dev);\n\n\tif (!rsp->info.fw_version[0])\n\t\trsp->devlink = netdev_to_devlink_get(dev);\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int ethtool_get_sset_info(struct net_device *dev,\n\t\t\t\t\t\t    void __user *useraddr)\n{\n\tstruct ethtool_sset_info info;\n\tu64 sset_mask;\n\tint i, idx = 0, n_bits = 0, ret, rc;\n\tu32 *info_buf = NULL;\n\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\n\t \n\tsset_mask = info.sset_mask;\n\tif (!sset_mask)\n\t\treturn 0;\n\n\t \n\tn_bits = hweight64(sset_mask);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.cmd = ETHTOOL_GSSET_INFO;\n\n\tinfo_buf = kcalloc(n_bits, sizeof(u32), GFP_USER);\n\tif (!info_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < 64; i++) {\n\t\tif (!(sset_mask & (1ULL << i)))\n\t\t\tcontinue;\n\n\t\trc = __ethtool_get_sset_count(dev, i);\n\t\tif (rc >= 0) {\n\t\t\tinfo.sset_mask |= (1ULL << i);\n\t\t\tinfo_buf[idx++] = rc;\n\t\t}\n\t}\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto out;\n\n\tuseraddr += offsetof(struct ethtool_sset_info, data);\n\tif (copy_to_user(useraddr, info_buf, array_size(idx, sizeof(u32))))\n\t\tgoto out;\n\n\tret = 0;\n\nout:\n\tkfree(info_buf);\n\treturn ret;\n}\n\nstatic noinline_for_stack int\nethtool_rxnfc_copy_from_compat(struct ethtool_rxnfc *rxnfc,\n\t\t\t       const struct compat_ethtool_rxnfc __user *useraddr,\n\t\t\t       size_t size)\n{\n\tstruct compat_ethtool_rxnfc crxnfc = {};\n\n\t \n\tBUILD_BUG_ON(!IS_ENABLED(CONFIG_X86_64) &&\n\t\t     sizeof(struct compat_ethtool_rxnfc) !=\n\t\t     sizeof(struct ethtool_rxnfc));\n\tBUILD_BUG_ON(offsetof(struct compat_ethtool_rxnfc, fs.m_ext) +\n\t\t     sizeof(useraddr->fs.m_ext) !=\n\t\t     offsetof(struct ethtool_rxnfc, fs.m_ext) +\n\t\t     sizeof(rxnfc->fs.m_ext));\n\tBUILD_BUG_ON(offsetof(struct compat_ethtool_rxnfc, fs.location) -\n\t\t     offsetof(struct compat_ethtool_rxnfc, fs.ring_cookie) !=\n\t\t     offsetof(struct ethtool_rxnfc, fs.location) -\n\t\t     offsetof(struct ethtool_rxnfc, fs.ring_cookie));\n\n\tif (copy_from_user(&crxnfc, useraddr, min(size, sizeof(crxnfc))))\n\t\treturn -EFAULT;\n\n\t*rxnfc = (struct ethtool_rxnfc) {\n\t\t.cmd\t\t= crxnfc.cmd,\n\t\t.flow_type\t= crxnfc.flow_type,\n\t\t.data\t\t= crxnfc.data,\n\t\t.fs\t\t= {\n\t\t\t.flow_type\t= crxnfc.fs.flow_type,\n\t\t\t.h_u\t\t= crxnfc.fs.h_u,\n\t\t\t.h_ext\t\t= crxnfc.fs.h_ext,\n\t\t\t.m_u\t\t= crxnfc.fs.m_u,\n\t\t\t.m_ext\t\t= crxnfc.fs.m_ext,\n\t\t\t.ring_cookie\t= crxnfc.fs.ring_cookie,\n\t\t\t.location\t= crxnfc.fs.location,\n\t\t},\n\t\t.rule_cnt\t= crxnfc.rule_cnt,\n\t};\n\n\treturn 0;\n}\n\nstatic int ethtool_rxnfc_copy_from_user(struct ethtool_rxnfc *rxnfc,\n\t\t\t\t\tconst void __user *useraddr,\n\t\t\t\t\tsize_t size)\n{\n\tif (compat_need_64bit_alignment_fixup())\n\t\treturn ethtool_rxnfc_copy_from_compat(rxnfc, useraddr, size);\n\n\tif (copy_from_user(rxnfc, useraddr, size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ethtool_rxnfc_copy_to_compat(void __user *useraddr,\n\t\t\t\t\tconst struct ethtool_rxnfc *rxnfc,\n\t\t\t\t\tsize_t size, const u32 *rule_buf)\n{\n\tstruct compat_ethtool_rxnfc crxnfc;\n\n\tmemset(&crxnfc, 0, sizeof(crxnfc));\n\tcrxnfc = (struct compat_ethtool_rxnfc) {\n\t\t.cmd\t\t= rxnfc->cmd,\n\t\t.flow_type\t= rxnfc->flow_type,\n\t\t.data\t\t= rxnfc->data,\n\t\t.fs\t\t= {\n\t\t\t.flow_type\t= rxnfc->fs.flow_type,\n\t\t\t.h_u\t\t= rxnfc->fs.h_u,\n\t\t\t.h_ext\t\t= rxnfc->fs.h_ext,\n\t\t\t.m_u\t\t= rxnfc->fs.m_u,\n\t\t\t.m_ext\t\t= rxnfc->fs.m_ext,\n\t\t\t.ring_cookie\t= rxnfc->fs.ring_cookie,\n\t\t\t.location\t= rxnfc->fs.location,\n\t\t},\n\t\t.rule_cnt\t= rxnfc->rule_cnt,\n\t};\n\n\tif (copy_to_user(useraddr, &crxnfc, min(size, sizeof(crxnfc))))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ethtool_rxnfc_copy_struct(u32 cmd, struct ethtool_rxnfc *info,\n\t\t\t\t     size_t *info_size, void __user *useraddr)\n{\n\t \n\tif (cmd == ETHTOOL_GRXFH || cmd == ETHTOOL_SRXFH)\n\t\t*info_size = (offsetof(struct ethtool_rxnfc, data) +\n\t\t\t      sizeof(info->data));\n\n\tif (ethtool_rxnfc_copy_from_user(info, useraddr, *info_size))\n\t\treturn -EFAULT;\n\n\tif ((cmd == ETHTOOL_GRXFH || cmd == ETHTOOL_SRXFH) && info->flow_type & FLOW_RSS) {\n\t\t*info_size = sizeof(*info);\n\t\tif (ethtool_rxnfc_copy_from_user(info, useraddr, *info_size))\n\t\t\treturn -EFAULT;\n\t\t \n\t\tif (!(info->flow_type & FLOW_RSS))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->cmd != cmd)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ethtool_rxnfc_copy_to_user(void __user *useraddr,\n\t\t\t\t      const struct ethtool_rxnfc *rxnfc,\n\t\t\t\t      size_t size, const u32 *rule_buf)\n{\n\tint ret;\n\n\tif (compat_need_64bit_alignment_fixup()) {\n\t\tret = ethtool_rxnfc_copy_to_compat(useraddr, rxnfc, size,\n\t\t\t\t\t\t   rule_buf);\n\t\tuseraddr += offsetof(struct compat_ethtool_rxnfc, rule_locs);\n\t} else {\n\t\tret = copy_to_user(useraddr, rxnfc, size);\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t}\n\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (rule_buf) {\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t rxnfc->rule_cnt * sizeof(u32)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int ethtool_set_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tu32 cmd, void __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tsize_t info_size = sizeof(info);\n\tint rc;\n\n\tif (!dev->ethtool_ops->set_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\trc = ethtool_rxnfc_copy_struct(cmd, &info, &info_size, useraddr);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dev->ethtool_ops->set_rxnfc(dev, &info);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cmd == ETHTOOL_SRXCLSRLINS &&\n\t    ethtool_rxnfc_copy_to_user(useraddr, &info, info_size, NULL))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tu32 cmd, void __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tsize_t info_size = sizeof(info);\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\tret = ethtool_rxnfc_copy_struct(cmd, &info, &info_size, useraddr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\tif (info.rule_cnt <= KMALLOC_MAX_SIZE / sizeof(u32))\n\t\t\t\trule_buf = kcalloc(info.rule_cnt, sizeof(u32),\n\t\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tret = ethtool_rxnfc_copy_to_user(useraddr, &info, info_size, rule_buf);\nerr_out:\n\tkfree(rule_buf);\n\n\treturn ret;\n}\n\nstatic int ethtool_copy_validate_indir(u32 *indir, void __user *useraddr,\n\t\t\t\t\tstruct ethtool_rxnfc *rx_rings,\n\t\t\t\t\tu32 size)\n{\n\tint i;\n\n\tif (copy_from_user(indir, useraddr, array_size(size, sizeof(indir[0]))))\n\t\treturn -EFAULT;\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tif (indir[i] >= rx_rings->data)\n\t\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nu8 netdev_rss_key[NETDEV_RSS_KEY_LEN] __read_mostly;\n\nvoid netdev_rss_key_fill(void *buffer, size_t len)\n{\n\tBUG_ON(len > sizeof(netdev_rss_key));\n\tnet_get_random_once(netdev_rss_key, sizeof(netdev_rss_key));\n\tmemcpy(buffer, netdev_rss_key, len);\n}\nEXPORT_SYMBOL(netdev_rss_key_fill);\n\nstatic noinline_for_stack int ethtool_get_rxfh_indir(struct net_device *dev,\n\t\t\t\t\t\t     void __user *useraddr)\n{\n\tu32 user_size, dev_size;\n\tu32 *indir;\n\tint ret;\n\n\tif (!dev->ethtool_ops->get_rxfh_indir_size ||\n\t    !dev->ethtool_ops->get_rxfh)\n\t\treturn -EOPNOTSUPP;\n\tdev_size = dev->ethtool_ops->get_rxfh_indir_size(dev);\n\tif (dev_size == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&user_size,\n\t\t\t   useraddr + offsetof(struct ethtool_rxfh_indir, size),\n\t\t\t   sizeof(user_size)))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(useraddr + offsetof(struct ethtool_rxfh_indir, size),\n\t\t\t &dev_size, sizeof(dev_size)))\n\t\treturn -EFAULT;\n\n\t \n\tif (user_size < dev_size)\n\t\treturn user_size == 0 ? 0 : -EINVAL;\n\n\tindir = kcalloc(dev_size, sizeof(indir[0]), GFP_USER);\n\tif (!indir)\n\t\treturn -ENOMEM;\n\n\tret = dev->ethtool_ops->get_rxfh(dev, indir, NULL, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tif (copy_to_user(useraddr +\n\t\t\t offsetof(struct ethtool_rxfh_indir, ring_index[0]),\n\t\t\t indir, dev_size * sizeof(indir[0])))\n\t\tret = -EFAULT;\n\nout:\n\tkfree(indir);\n\treturn ret;\n}\n\nstatic noinline_for_stack int ethtool_set_rxfh_indir(struct net_device *dev,\n\t\t\t\t\t\t     void __user *useraddr)\n{\n\tstruct ethtool_rxnfc rx_rings;\n\tu32 user_size, dev_size, i;\n\tu32 *indir;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tu32 ringidx_offset = offsetof(struct ethtool_rxfh_indir, ring_index[0]);\n\n\tif (!ops->get_rxfh_indir_size || !ops->set_rxfh ||\n\t    !ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\tdev_size = ops->get_rxfh_indir_size(dev);\n\tif (dev_size == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&user_size,\n\t\t\t   useraddr + offsetof(struct ethtool_rxfh_indir, size),\n\t\t\t   sizeof(user_size)))\n\t\treturn -EFAULT;\n\n\tif (user_size != 0 && user_size != dev_size)\n\t\treturn -EINVAL;\n\n\tindir = kcalloc(dev_size, sizeof(indir[0]), GFP_USER);\n\tif (!indir)\n\t\treturn -ENOMEM;\n\n\trx_rings.cmd = ETHTOOL_GRXRINGS;\n\tret = ops->get_rxnfc(dev, &rx_rings, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tif (user_size == 0) {\n\t\tfor (i = 0; i < dev_size; i++)\n\t\t\tindir[i] = ethtool_rxfh_indir_default(i, rx_rings.data);\n\t} else {\n\t\tret = ethtool_copy_validate_indir(indir,\n\t\t\t\t\t\t  useraddr + ringidx_offset,\n\t\t\t\t\t\t  &rx_rings,\n\t\t\t\t\t\t  dev_size);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = ops->set_rxfh(dev, indir, NULL, ETH_RSS_HASH_NO_CHANGE);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (user_size == 0)\n\t\tdev->priv_flags &= ~IFF_RXFH_CONFIGURED;\n\telse\n\t\tdev->priv_flags |= IFF_RXFH_CONFIGURED;\n\nout:\n\tkfree(indir);\n\treturn ret;\n}\n\nstatic noinline_for_stack int ethtool_get_rxfh(struct net_device *dev,\n\t\t\t\t\t       void __user *useraddr)\n{\n\tint ret;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tu32 user_indir_size, user_key_size;\n\tu32 dev_indir_size = 0, dev_key_size = 0;\n\tstruct ethtool_rxfh rxfh;\n\tu32 total_size;\n\tu32 indir_bytes;\n\tu32 *indir = NULL;\n\tu8 dev_hfunc = 0;\n\tu8 *hkey = NULL;\n\tu8 *rss_config;\n\n\tif (!ops->get_rxfh)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ops->get_rxfh_indir_size)\n\t\tdev_indir_size = ops->get_rxfh_indir_size(dev);\n\tif (ops->get_rxfh_key_size)\n\t\tdev_key_size = ops->get_rxfh_key_size(dev);\n\n\tif (copy_from_user(&rxfh, useraddr, sizeof(rxfh)))\n\t\treturn -EFAULT;\n\tuser_indir_size = rxfh.indir_size;\n\tuser_key_size = rxfh.key_size;\n\n\t \n\tif (rxfh.rsvd8[0] || rxfh.rsvd8[1] || rxfh.rsvd8[2] || rxfh.rsvd32)\n\t\treturn -EINVAL;\n\t \n\tif (rxfh.rss_context && !ops->get_rxfh_context)\n\t\treturn -EOPNOTSUPP;\n\n\trxfh.indir_size = dev_indir_size;\n\trxfh.key_size = dev_key_size;\n\tif (copy_to_user(useraddr, &rxfh, sizeof(rxfh)))\n\t\treturn -EFAULT;\n\n\tif ((user_indir_size && (user_indir_size != dev_indir_size)) ||\n\t    (user_key_size && (user_key_size != dev_key_size)))\n\t\treturn -EINVAL;\n\n\tindir_bytes = user_indir_size * sizeof(indir[0]);\n\ttotal_size = indir_bytes + user_key_size;\n\trss_config = kzalloc(total_size, GFP_USER);\n\tif (!rss_config)\n\t\treturn -ENOMEM;\n\n\tif (user_indir_size)\n\t\tindir = (u32 *)rss_config;\n\n\tif (user_key_size)\n\t\thkey = rss_config + indir_bytes;\n\n\tif (rxfh.rss_context)\n\t\tret = dev->ethtool_ops->get_rxfh_context(dev, indir, hkey,\n\t\t\t\t\t\t\t &dev_hfunc,\n\t\t\t\t\t\t\t rxfh.rss_context);\n\telse\n\t\tret = dev->ethtool_ops->get_rxfh(dev, indir, hkey, &dev_hfunc);\n\tif (ret)\n\t\tgoto out;\n\n\tif (copy_to_user(useraddr + offsetof(struct ethtool_rxfh, hfunc),\n\t\t\t &dev_hfunc, sizeof(rxfh.hfunc))) {\n\t\tret = -EFAULT;\n\t} else if (copy_to_user(useraddr +\n\t\t\t      offsetof(struct ethtool_rxfh, rss_config[0]),\n\t\t\t      rss_config, total_size)) {\n\t\tret = -EFAULT;\n\t}\nout:\n\tkfree(rss_config);\n\n\treturn ret;\n}\n\nstatic noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,\n\t\t\t\t\t       void __user *useraddr)\n{\n\tint ret;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct ethtool_rxnfc rx_rings;\n\tstruct ethtool_rxfh rxfh;\n\tu32 dev_indir_size = 0, dev_key_size = 0, i;\n\tu32 *indir = NULL, indir_bytes = 0;\n\tu8 *hkey = NULL;\n\tu8 *rss_config;\n\tu32 rss_cfg_offset = offsetof(struct ethtool_rxfh, rss_config[0]);\n\tbool delete = false;\n\n\tif (!ops->get_rxnfc || !ops->set_rxfh)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ops->get_rxfh_indir_size)\n\t\tdev_indir_size = ops->get_rxfh_indir_size(dev);\n\tif (ops->get_rxfh_key_size)\n\t\tdev_key_size = ops->get_rxfh_key_size(dev);\n\n\tif (copy_from_user(&rxfh, useraddr, sizeof(rxfh)))\n\t\treturn -EFAULT;\n\n\t \n\tif (rxfh.rsvd8[0] || rxfh.rsvd8[1] || rxfh.rsvd8[2] || rxfh.rsvd32)\n\t\treturn -EINVAL;\n\t \n\tif (rxfh.rss_context && !ops->set_rxfh_context)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((rxfh.indir_size &&\n\t     rxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE &&\n\t     rxfh.indir_size != dev_indir_size) ||\n\t    (rxfh.key_size && (rxfh.key_size != dev_key_size)) ||\n\t    (rxfh.indir_size == ETH_RXFH_INDIR_NO_CHANGE &&\n\t     rxfh.key_size == 0 && rxfh.hfunc == ETH_RSS_HASH_NO_CHANGE))\n\t\treturn -EINVAL;\n\n\tif (rxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE)\n\t\tindir_bytes = dev_indir_size * sizeof(indir[0]);\n\n\trss_config = kzalloc(indir_bytes + rxfh.key_size, GFP_USER);\n\tif (!rss_config)\n\t\treturn -ENOMEM;\n\n\trx_rings.cmd = ETHTOOL_GRXRINGS;\n\tret = ops->get_rxnfc(dev, &rx_rings, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (rxfh.indir_size &&\n\t    rxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE) {\n\t\tindir = (u32 *)rss_config;\n\t\tret = ethtool_copy_validate_indir(indir,\n\t\t\t\t\t\t  useraddr + rss_cfg_offset,\n\t\t\t\t\t\t  &rx_rings,\n\t\t\t\t\t\t  rxfh.indir_size);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else if (rxfh.indir_size == 0) {\n\t\tif (rxfh.rss_context == 0) {\n\t\t\tindir = (u32 *)rss_config;\n\t\t\tfor (i = 0; i < dev_indir_size; i++)\n\t\t\t\tindir[i] = ethtool_rxfh_indir_default(i, rx_rings.data);\n\t\t} else {\n\t\t\tdelete = true;\n\t\t}\n\t}\n\n\tif (rxfh.key_size) {\n\t\thkey = rss_config + indir_bytes;\n\t\tif (copy_from_user(hkey,\n\t\t\t\t   useraddr + rss_cfg_offset + indir_bytes,\n\t\t\t\t   rxfh.key_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rxfh.rss_context)\n\t\tret = ops->set_rxfh_context(dev, indir, hkey, rxfh.hfunc,\n\t\t\t\t\t    &rxfh.rss_context, delete);\n\telse\n\t\tret = ops->set_rxfh(dev, indir, hkey, rxfh.hfunc);\n\tif (ret)\n\t\tgoto out;\n\n\tif (copy_to_user(useraddr + offsetof(struct ethtool_rxfh, rss_context),\n\t\t\t &rxfh.rss_context, sizeof(rxfh.rss_context)))\n\t\tret = -EFAULT;\n\n\tif (!rxfh.rss_context) {\n\t\t \n\t\tif (rxfh.indir_size == 0)\n\t\t\tdev->priv_flags &= ~IFF_RXFH_CONFIGURED;\n\t\telse if (rxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE)\n\t\t\tdev->priv_flags |= IFF_RXFH_CONFIGURED;\n\t}\n\nout:\n\tkfree(rss_config);\n\treturn ret;\n}\n\nstatic int ethtool_get_regs(struct net_device *dev, char __user *useraddr)\n{\n\tstruct ethtool_regs regs;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tvoid *regbuf;\n\tint reglen, ret;\n\n\tif (!ops->get_regs || !ops->get_regs_len)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&regs, useraddr, sizeof(regs)))\n\t\treturn -EFAULT;\n\n\treglen = ops->get_regs_len(dev);\n\tif (reglen <= 0)\n\t\treturn reglen;\n\n\tif (regs.len > reglen)\n\t\tregs.len = reglen;\n\n\tregbuf = vzalloc(reglen);\n\tif (!regbuf)\n\t\treturn -ENOMEM;\n\n\tif (regs.len < reglen)\n\t\treglen = regs.len;\n\n\tops->get_regs(dev, &regs, regbuf);\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &regs, sizeof(regs)))\n\t\tgoto out;\n\tuseraddr += offsetof(struct ethtool_regs, data);\n\tif (copy_to_user(useraddr, regbuf, reglen))\n\t\tgoto out;\n\tret = 0;\n\n out:\n\tvfree(regbuf);\n\treturn ret;\n}\n\nstatic int ethtool_reset(struct net_device *dev, char __user *useraddr)\n{\n\tstruct ethtool_value reset;\n\tint ret;\n\n\tif (!dev->ethtool_ops->reset)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&reset, useraddr, sizeof(reset)))\n\t\treturn -EFAULT;\n\n\tret = dev->ethtool_ops->reset(dev, &reset.data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(useraddr, &reset, sizeof(reset)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ethtool_get_wol(struct net_device *dev, char __user *useraddr)\n{\n\tstruct ethtool_wolinfo wol;\n\n\tif (!dev->ethtool_ops->get_wol)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&wol, 0, sizeof(struct ethtool_wolinfo));\n\twol.cmd = ETHTOOL_GWOL;\n\tdev->ethtool_ops->get_wol(dev, &wol);\n\n\tif (copy_to_user(useraddr, &wol, sizeof(wol)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ethtool_set_wol(struct net_device *dev, char __user *useraddr)\n{\n\tstruct ethtool_wolinfo wol, cur_wol;\n\tint ret;\n\n\tif (!dev->ethtool_ops->get_wol || !dev->ethtool_ops->set_wol)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&cur_wol, 0, sizeof(struct ethtool_wolinfo));\n\tcur_wol.cmd = ETHTOOL_GWOL;\n\tdev->ethtool_ops->get_wol(dev, &cur_wol);\n\n\tif (copy_from_user(&wol, useraddr, sizeof(wol)))\n\t\treturn -EFAULT;\n\n\tif (wol.wolopts & ~cur_wol.supported)\n\t\treturn -EINVAL;\n\n\tif (wol.wolopts == cur_wol.wolopts &&\n\t    !memcmp(wol.sopass, cur_wol.sopass, sizeof(wol.sopass)))\n\t\treturn 0;\n\n\tret = dev->ethtool_ops->set_wol(dev, &wol);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->wol_enabled = !!wol.wolopts;\n\tethtool_notify(dev, ETHTOOL_MSG_WOL_NTF, NULL);\n\n\treturn 0;\n}\n\nstatic int ethtool_get_eee(struct net_device *dev, char __user *useraddr)\n{\n\tstruct ethtool_eee edata;\n\tint rc;\n\n\tif (!dev->ethtool_ops->get_eee)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&edata, 0, sizeof(struct ethtool_eee));\n\tedata.cmd = ETHTOOL_GEEE;\n\trc = dev->ethtool_ops->get_eee(dev, &edata);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (copy_to_user(useraddr, &edata, sizeof(edata)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ethtool_set_eee(struct net_device *dev, char __user *useraddr)\n{\n\tstruct ethtool_eee edata;\n\tint ret;\n\n\tif (!dev->ethtool_ops->set_eee)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&edata, useraddr, sizeof(edata)))\n\t\treturn -EFAULT;\n\n\tret = dev->ethtool_ops->set_eee(dev, &edata);\n\tif (!ret)\n\t\tethtool_notify(dev, ETHTOOL_MSG_EEE_NTF, NULL);\n\treturn ret;\n}\n\nstatic int ethtool_nway_reset(struct net_device *dev)\n{\n\tif (!dev->ethtool_ops->nway_reset)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->ethtool_ops->nway_reset(dev);\n}\n\nstatic int ethtool_get_link(struct net_device *dev, char __user *useraddr)\n{\n\tstruct ethtool_value edata = { .cmd = ETHTOOL_GLINK };\n\tint link = __ethtool_get_link(dev);\n\n\tif (link < 0)\n\t\treturn link;\n\n\tedata.data = link;\n\tif (copy_to_user(useraddr, &edata, sizeof(edata)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ethtool_get_any_eeprom(struct net_device *dev, void __user *useraddr,\n\t\t\t\t  int (*getter)(struct net_device *,\n\t\t\t\t\t\tstruct ethtool_eeprom *, u8 *),\n\t\t\t\t  u32 total_len)\n{\n\tstruct ethtool_eeprom eeprom;\n\tvoid __user *userbuf = useraddr + sizeof(eeprom);\n\tu32 bytes_remaining;\n\tu8 *data;\n\tint ret = 0;\n\n\tif (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))\n\t\treturn -EFAULT;\n\n\t \n\tif (eeprom.offset + eeprom.len <= eeprom.offset)\n\t\treturn -EINVAL;\n\n\t \n\tif (eeprom.offset + eeprom.len > total_len)\n\t\treturn -EINVAL;\n\n\tdata = kzalloc(PAGE_SIZE, GFP_USER);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tbytes_remaining = eeprom.len;\n\twhile (bytes_remaining > 0) {\n\t\teeprom.len = min(bytes_remaining, (u32)PAGE_SIZE);\n\n\t\tret = getter(dev, &eeprom, data);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!eeprom.len) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(userbuf, data, eeprom.len)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tuserbuf += eeprom.len;\n\t\teeprom.offset += eeprom.len;\n\t\tbytes_remaining -= eeprom.len;\n\t}\n\n\teeprom.len = userbuf - (useraddr + sizeof(eeprom));\n\teeprom.offset -= eeprom.len;\n\tif (copy_to_user(useraddr, &eeprom, sizeof(eeprom)))\n\t\tret = -EFAULT;\n\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int ethtool_get_eeprom(struct net_device *dev, void __user *useraddr)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\n\tif (!ops->get_eeprom || !ops->get_eeprom_len ||\n\t    !ops->get_eeprom_len(dev))\n\t\treturn -EOPNOTSUPP;\n\n\treturn ethtool_get_any_eeprom(dev, useraddr, ops->get_eeprom,\n\t\t\t\t      ops->get_eeprom_len(dev));\n}\n\nstatic int ethtool_set_eeprom(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_eeprom eeprom;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tvoid __user *userbuf = useraddr + sizeof(eeprom);\n\tu32 bytes_remaining;\n\tu8 *data;\n\tint ret = 0;\n\n\tif (!ops->set_eeprom || !ops->get_eeprom_len ||\n\t    !ops->get_eeprom_len(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))\n\t\treturn -EFAULT;\n\n\t \n\tif (eeprom.offset + eeprom.len <= eeprom.offset)\n\t\treturn -EINVAL;\n\n\t \n\tif (eeprom.offset + eeprom.len > ops->get_eeprom_len(dev))\n\t\treturn -EINVAL;\n\n\tdata = kzalloc(PAGE_SIZE, GFP_USER);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tbytes_remaining = eeprom.len;\n\twhile (bytes_remaining > 0) {\n\t\teeprom.len = min(bytes_remaining, (u32)PAGE_SIZE);\n\n\t\tif (copy_from_user(data, userbuf, eeprom.len)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = ops->set_eeprom(dev, &eeprom, data);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tuserbuf += eeprom.len;\n\t\teeprom.offset += eeprom.len;\n\t\tbytes_remaining -= eeprom.len;\n\t}\n\n\tkfree(data);\n\treturn ret;\n}\n\nstatic noinline_for_stack int ethtool_get_coalesce(struct net_device *dev,\n\t\t\t\t\t\t   void __user *useraddr)\n{\n\tstruct ethtool_coalesce coalesce = { .cmd = ETHTOOL_GCOALESCE };\n\tstruct kernel_ethtool_coalesce kernel_coalesce = {};\n\tint ret;\n\n\tif (!dev->ethtool_ops->get_coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tret = dev->ethtool_ops->get_coalesce(dev, &coalesce, &kernel_coalesce,\n\t\t\t\t\t     NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(useraddr, &coalesce, sizeof(coalesce)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic bool\nethtool_set_coalesce_supported(struct net_device *dev,\n\t\t\t       struct ethtool_coalesce *coalesce)\n{\n\tu32 supported_params = dev->ethtool_ops->supported_coalesce_params;\n\tu32 nonzero_params = 0;\n\n\tif (coalesce->rx_coalesce_usecs)\n\t\tnonzero_params |= ETHTOOL_COALESCE_RX_USECS;\n\tif (coalesce->rx_max_coalesced_frames)\n\t\tnonzero_params |= ETHTOOL_COALESCE_RX_MAX_FRAMES;\n\tif (coalesce->rx_coalesce_usecs_irq)\n\t\tnonzero_params |= ETHTOOL_COALESCE_RX_USECS_IRQ;\n\tif (coalesce->rx_max_coalesced_frames_irq)\n\t\tnonzero_params |= ETHTOOL_COALESCE_RX_MAX_FRAMES_IRQ;\n\tif (coalesce->tx_coalesce_usecs)\n\t\tnonzero_params |= ETHTOOL_COALESCE_TX_USECS;\n\tif (coalesce->tx_max_coalesced_frames)\n\t\tnonzero_params |= ETHTOOL_COALESCE_TX_MAX_FRAMES;\n\tif (coalesce->tx_coalesce_usecs_irq)\n\t\tnonzero_params |= ETHTOOL_COALESCE_TX_USECS_IRQ;\n\tif (coalesce->tx_max_coalesced_frames_irq)\n\t\tnonzero_params |= ETHTOOL_COALESCE_TX_MAX_FRAMES_IRQ;\n\tif (coalesce->stats_block_coalesce_usecs)\n\t\tnonzero_params |= ETHTOOL_COALESCE_STATS_BLOCK_USECS;\n\tif (coalesce->use_adaptive_rx_coalesce)\n\t\tnonzero_params |= ETHTOOL_COALESCE_USE_ADAPTIVE_RX;\n\tif (coalesce->use_adaptive_tx_coalesce)\n\t\tnonzero_params |= ETHTOOL_COALESCE_USE_ADAPTIVE_TX;\n\tif (coalesce->pkt_rate_low)\n\t\tnonzero_params |= ETHTOOL_COALESCE_PKT_RATE_LOW;\n\tif (coalesce->rx_coalesce_usecs_low)\n\t\tnonzero_params |= ETHTOOL_COALESCE_RX_USECS_LOW;\n\tif (coalesce->rx_max_coalesced_frames_low)\n\t\tnonzero_params |= ETHTOOL_COALESCE_RX_MAX_FRAMES_LOW;\n\tif (coalesce->tx_coalesce_usecs_low)\n\t\tnonzero_params |= ETHTOOL_COALESCE_TX_USECS_LOW;\n\tif (coalesce->tx_max_coalesced_frames_low)\n\t\tnonzero_params |= ETHTOOL_COALESCE_TX_MAX_FRAMES_LOW;\n\tif (coalesce->pkt_rate_high)\n\t\tnonzero_params |= ETHTOOL_COALESCE_PKT_RATE_HIGH;\n\tif (coalesce->rx_coalesce_usecs_high)\n\t\tnonzero_params |= ETHTOOL_COALESCE_RX_USECS_HIGH;\n\tif (coalesce->rx_max_coalesced_frames_high)\n\t\tnonzero_params |= ETHTOOL_COALESCE_RX_MAX_FRAMES_HIGH;\n\tif (coalesce->tx_coalesce_usecs_high)\n\t\tnonzero_params |= ETHTOOL_COALESCE_TX_USECS_HIGH;\n\tif (coalesce->tx_max_coalesced_frames_high)\n\t\tnonzero_params |= ETHTOOL_COALESCE_TX_MAX_FRAMES_HIGH;\n\tif (coalesce->rate_sample_interval)\n\t\tnonzero_params |= ETHTOOL_COALESCE_RATE_SAMPLE_INTERVAL;\n\n\treturn (supported_params & nonzero_params) == nonzero_params;\n}\n\nstatic noinline_for_stack int ethtool_set_coalesce(struct net_device *dev,\n\t\t\t\t\t\t   void __user *useraddr)\n{\n\tstruct kernel_ethtool_coalesce kernel_coalesce = {};\n\tstruct ethtool_coalesce coalesce;\n\tint ret;\n\n\tif (!dev->ethtool_ops->set_coalesce || !dev->ethtool_ops->get_coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tret = dev->ethtool_ops->get_coalesce(dev, &coalesce, &kernel_coalesce,\n\t\t\t\t\t     NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_from_user(&coalesce, useraddr, sizeof(coalesce)))\n\t\treturn -EFAULT;\n\n\tif (!ethtool_set_coalesce_supported(dev, &coalesce))\n\t\treturn -EOPNOTSUPP;\n\n\tret = dev->ethtool_ops->set_coalesce(dev, &coalesce, &kernel_coalesce,\n\t\t\t\t\t     NULL);\n\tif (!ret)\n\t\tethtool_notify(dev, ETHTOOL_MSG_COALESCE_NTF, NULL);\n\treturn ret;\n}\n\nstatic int ethtool_get_ringparam(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_ringparam ringparam = { .cmd = ETHTOOL_GRINGPARAM };\n\tstruct kernel_ethtool_ringparam kernel_ringparam = {};\n\n\tif (!dev->ethtool_ops->get_ringparam)\n\t\treturn -EOPNOTSUPP;\n\n\tdev->ethtool_ops->get_ringparam(dev, &ringparam,\n\t\t\t\t\t&kernel_ringparam, NULL);\n\n\tif (copy_to_user(useraddr, &ringparam, sizeof(ringparam)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ethtool_set_ringparam(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_ringparam ringparam, max = { .cmd = ETHTOOL_GRINGPARAM };\n\tstruct kernel_ethtool_ringparam kernel_ringparam;\n\tint ret;\n\n\tif (!dev->ethtool_ops->set_ringparam || !dev->ethtool_ops->get_ringparam)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&ringparam, useraddr, sizeof(ringparam)))\n\t\treturn -EFAULT;\n\n\tdev->ethtool_ops->get_ringparam(dev, &max, &kernel_ringparam, NULL);\n\n\t \n\tif (ringparam.rx_pending > max.rx_max_pending ||\n\t    ringparam.rx_mini_pending > max.rx_mini_max_pending ||\n\t    ringparam.rx_jumbo_pending > max.rx_jumbo_max_pending ||\n\t    ringparam.tx_pending > max.tx_max_pending)\n\t\treturn -EINVAL;\n\n\tret = dev->ethtool_ops->set_ringparam(dev, &ringparam,\n\t\t\t\t\t      &kernel_ringparam, NULL);\n\tif (!ret)\n\t\tethtool_notify(dev, ETHTOOL_MSG_RINGS_NTF, NULL);\n\treturn ret;\n}\n\nstatic noinline_for_stack int ethtool_get_channels(struct net_device *dev,\n\t\t\t\t\t\t   void __user *useraddr)\n{\n\tstruct ethtool_channels channels = { .cmd = ETHTOOL_GCHANNELS };\n\n\tif (!dev->ethtool_ops->get_channels)\n\t\treturn -EOPNOTSUPP;\n\n\tdev->ethtool_ops->get_channels(dev, &channels);\n\n\tif (copy_to_user(useraddr, &channels, sizeof(channels)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic noinline_for_stack int ethtool_set_channels(struct net_device *dev,\n\t\t\t\t\t\t   void __user *useraddr)\n{\n\tstruct ethtool_channels channels, curr = { .cmd = ETHTOOL_GCHANNELS };\n\tu16 from_channel, to_channel;\n\tu64 max_rxnfc_in_use;\n\tu32 max_rxfh_in_use;\n\tunsigned int i;\n\tint ret;\n\n\tif (!dev->ethtool_ops->set_channels || !dev->ethtool_ops->get_channels)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&channels, useraddr, sizeof(channels)))\n\t\treturn -EFAULT;\n\n\tdev->ethtool_ops->get_channels(dev, &curr);\n\n\tif (channels.rx_count == curr.rx_count &&\n\t    channels.tx_count == curr.tx_count &&\n\t    channels.combined_count == curr.combined_count &&\n\t    channels.other_count == curr.other_count)\n\t\treturn 0;\n\n\t \n\tif (channels.rx_count > curr.max_rx ||\n\t    channels.tx_count > curr.max_tx ||\n\t    channels.combined_count > curr.max_combined ||\n\t    channels.other_count > curr.max_other)\n\t\treturn -EINVAL;\n\n\t \n\tif (!channels.combined_count &&\n\t    (!channels.rx_count || !channels.tx_count))\n\t\treturn -EINVAL;\n\n\t \n\tif (ethtool_get_max_rxnfc_channel(dev, &max_rxnfc_in_use))\n\t\tmax_rxnfc_in_use = 0;\n\tif (!netif_is_rxfh_configured(dev) ||\n\t    ethtool_get_max_rxfh_channel(dev, &max_rxfh_in_use))\n\t\tmax_rxfh_in_use = 0;\n\tif (channels.combined_count + channels.rx_count <=\n\t    max_t(u64, max_rxnfc_in_use, max_rxfh_in_use))\n\t\treturn -EINVAL;\n\n\t \n\tfrom_channel = channels.combined_count +\n\t\tmin(channels.rx_count, channels.tx_count);\n\tto_channel = curr.combined_count + max(curr.rx_count, curr.tx_count);\n\tfor (i = from_channel; i < to_channel; i++)\n\t\tif (xsk_get_pool_from_qid(dev, i))\n\t\t\treturn -EINVAL;\n\n\tret = dev->ethtool_ops->set_channels(dev, &channels);\n\tif (!ret)\n\t\tethtool_notify(dev, ETHTOOL_MSG_CHANNELS_NTF, NULL);\n\treturn ret;\n}\n\nstatic int ethtool_get_pauseparam(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_pauseparam pauseparam = { .cmd = ETHTOOL_GPAUSEPARAM };\n\n\tif (!dev->ethtool_ops->get_pauseparam)\n\t\treturn -EOPNOTSUPP;\n\n\tdev->ethtool_ops->get_pauseparam(dev, &pauseparam);\n\n\tif (copy_to_user(useraddr, &pauseparam, sizeof(pauseparam)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ethtool_set_pauseparam(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_pauseparam pauseparam;\n\tint ret;\n\n\tif (!dev->ethtool_ops->set_pauseparam)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&pauseparam, useraddr, sizeof(pauseparam)))\n\t\treturn -EFAULT;\n\n\tret = dev->ethtool_ops->set_pauseparam(dev, &pauseparam);\n\tif (!ret)\n\t\tethtool_notify(dev, ETHTOOL_MSG_PAUSE_NTF, NULL);\n\treturn ret;\n}\n\nstatic int ethtool_self_test(struct net_device *dev, char __user *useraddr)\n{\n\tstruct ethtool_test test;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tu64 *data;\n\tint ret, test_len;\n\n\tif (!ops->self_test || !ops->get_sset_count)\n\t\treturn -EOPNOTSUPP;\n\n\ttest_len = ops->get_sset_count(dev, ETH_SS_TEST);\n\tif (test_len < 0)\n\t\treturn test_len;\n\tWARN_ON(test_len == 0);\n\n\tif (copy_from_user(&test, useraddr, sizeof(test)))\n\t\treturn -EFAULT;\n\n\ttest.len = test_len;\n\tdata = kcalloc(test_len, sizeof(u64), GFP_USER);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tnetif_testing_on(dev);\n\tops->self_test(dev, &test, data);\n\tnetif_testing_off(dev);\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &test, sizeof(test)))\n\t\tgoto out;\n\tuseraddr += sizeof(test);\n\tif (copy_to_user(useraddr, data, array_size(test.len, sizeof(u64))))\n\t\tgoto out;\n\tret = 0;\n\n out:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int ethtool_get_strings(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_gstrings gstrings;\n\tu8 *data;\n\tint ret;\n\n\tif (copy_from_user(&gstrings, useraddr, sizeof(gstrings)))\n\t\treturn -EFAULT;\n\n\tret = __ethtool_get_sset_count(dev, gstrings.string_set);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret > S32_MAX / ETH_GSTRING_LEN)\n\t\treturn -ENOMEM;\n\tWARN_ON_ONCE(!ret);\n\n\tgstrings.len = ret;\n\n\tif (gstrings.len) {\n\t\tdata = vzalloc(array_size(gstrings.len, ETH_GSTRING_LEN));\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\t__ethtool_get_strings(dev, gstrings.string_set, data);\n\t} else {\n\t\tdata = NULL;\n\t}\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &gstrings, sizeof(gstrings)))\n\t\tgoto out;\n\tuseraddr += sizeof(gstrings);\n\tif (gstrings.len &&\n\t    copy_to_user(useraddr, data,\n\t\t\t array_size(gstrings.len, ETH_GSTRING_LEN)))\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tvfree(data);\n\treturn ret;\n}\n\n__printf(2, 3) void ethtool_sprintf(u8 **data, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(*data, ETH_GSTRING_LEN, fmt, args);\n\tva_end(args);\n\n\t*data += ETH_GSTRING_LEN;\n}\nEXPORT_SYMBOL(ethtool_sprintf);\n\nstatic int ethtool_phys_id(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_value id;\n\tstatic bool busy;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tnetdevice_tracker dev_tracker;\n\tint rc;\n\n\tif (!ops->set_phys_id)\n\t\treturn -EOPNOTSUPP;\n\n\tif (busy)\n\t\treturn -EBUSY;\n\n\tif (copy_from_user(&id, useraddr, sizeof(id)))\n\t\treturn -EFAULT;\n\n\trc = ops->set_phys_id(dev, ETHTOOL_ID_ACTIVE);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tbusy = true;\n\tnetdev_hold(dev, &dev_tracker, GFP_KERNEL);\n\trtnl_unlock();\n\n\tif (rc == 0) {\n\t\t \n\t\tschedule_timeout_interruptible(\n\t\t\tid.data ? (id.data * HZ) : MAX_SCHEDULE_TIMEOUT);\n\t} else {\n\t\t \n\t\tint n = rc * 2, interval = HZ / n;\n\t\tu64 count = mul_u32_u32(n, id.data);\n\t\tu64 i = 0;\n\n\t\tdo {\n\t\t\trtnl_lock();\n\t\t\trc = ops->set_phys_id(dev,\n\t\t\t\t    (i++ & 1) ? ETHTOOL_ID_OFF : ETHTOOL_ID_ON);\n\t\t\trtnl_unlock();\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t\tschedule_timeout_interruptible(interval);\n\t\t} while (!signal_pending(current) && (!id.data || i < count));\n\t}\n\n\trtnl_lock();\n\tnetdev_put(dev, &dev_tracker);\n\tbusy = false;\n\n\t(void) ops->set_phys_id(dev, ETHTOOL_ID_INACTIVE);\n\treturn rc;\n}\n\nstatic int ethtool_get_stats(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_stats stats;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tu64 *data;\n\tint ret, n_stats;\n\n\tif (!ops->get_ethtool_stats || !ops->get_sset_count)\n\t\treturn -EOPNOTSUPP;\n\n\tn_stats = ops->get_sset_count(dev, ETH_SS_STATS);\n\tif (n_stats < 0)\n\t\treturn n_stats;\n\tif (n_stats > S32_MAX / sizeof(u64))\n\t\treturn -ENOMEM;\n\tWARN_ON_ONCE(!n_stats);\n\tif (copy_from_user(&stats, useraddr, sizeof(stats)))\n\t\treturn -EFAULT;\n\n\tstats.n_stats = n_stats;\n\n\tif (n_stats) {\n\t\tdata = vzalloc(array_size(n_stats, sizeof(u64)));\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\t\tops->get_ethtool_stats(dev, &stats, data);\n\t} else {\n\t\tdata = NULL;\n\t}\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &stats, sizeof(stats)))\n\t\tgoto out;\n\tuseraddr += sizeof(stats);\n\tif (n_stats && copy_to_user(useraddr, data, array_size(n_stats, sizeof(u64))))\n\t\tgoto out;\n\tret = 0;\n\n out:\n\tvfree(data);\n\treturn ret;\n}\n\nstatic int ethtool_vzalloc_stats_array(int n_stats, u64 **data)\n{\n\tif (n_stats < 0)\n\t\treturn n_stats;\n\tif (n_stats > S32_MAX / sizeof(u64))\n\t\treturn -ENOMEM;\n\tif (WARN_ON_ONCE(!n_stats))\n\t\treturn -EOPNOTSUPP;\n\n\t*data = vzalloc(array_size(n_stats, sizeof(u64)));\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ethtool_get_phy_stats_phydev(struct phy_device *phydev,\n\t\t\t\t\t struct ethtool_stats *stats,\n\t\t\t\t\t u64 **data)\n {\n\tconst struct ethtool_phy_ops *phy_ops = ethtool_phy_ops;\n\tint n_stats, ret;\n\n\tif (!phy_ops || !phy_ops->get_sset_count || !phy_ops->get_stats)\n\t\treturn -EOPNOTSUPP;\n\n\tn_stats = phy_ops->get_sset_count(phydev);\n\n\tret = ethtool_vzalloc_stats_array(n_stats, data);\n\tif (ret)\n\t\treturn ret;\n\n\tstats->n_stats = n_stats;\n\treturn phy_ops->get_stats(phydev, stats, *data);\n}\n\nstatic int ethtool_get_phy_stats_ethtool(struct net_device *dev,\n\t\t\t\t\t  struct ethtool_stats *stats,\n\t\t\t\t\t  u64 **data)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint n_stats, ret;\n\n\tif (!ops || !ops->get_sset_count || ops->get_ethtool_phy_stats)\n\t\treturn -EOPNOTSUPP;\n\n\tn_stats = ops->get_sset_count(dev, ETH_SS_PHY_STATS);\n\n\tret = ethtool_vzalloc_stats_array(n_stats, data);\n\tif (ret)\n\t\treturn ret;\n\n\tstats->n_stats = n_stats;\n\tops->get_ethtool_phy_stats(dev, stats, *data);\n\n\treturn 0;\n}\n\nstatic int ethtool_get_phy_stats(struct net_device *dev, void __user *useraddr)\n{\n\tstruct phy_device *phydev = dev->phydev;\n\tstruct ethtool_stats stats;\n\tu64 *data = NULL;\n\tint ret = -EOPNOTSUPP;\n\n\tif (copy_from_user(&stats, useraddr, sizeof(stats)))\n\t\treturn -EFAULT;\n\n\tif (phydev)\n\t\tret = ethtool_get_phy_stats_phydev(phydev, &stats, &data);\n\n\tif (ret == -EOPNOTSUPP)\n\t\tret = ethtool_get_phy_stats_ethtool(dev, &stats, &data);\n\n\tif (ret)\n\t\tgoto out;\n\n\tif (copy_to_user(useraddr, &stats, sizeof(stats))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tuseraddr += sizeof(stats);\n\tif (copy_to_user(useraddr, data, array_size(stats.n_stats, sizeof(u64))))\n\t\tret = -EFAULT;\n\n out:\n\tvfree(data);\n\treturn ret;\n}\n\nstatic int ethtool_get_perm_addr(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_perm_addr epaddr;\n\n\tif (copy_from_user(&epaddr, useraddr, sizeof(epaddr)))\n\t\treturn -EFAULT;\n\n\tif (epaddr.size < dev->addr_len)\n\t\treturn -ETOOSMALL;\n\tepaddr.size = dev->addr_len;\n\n\tif (copy_to_user(useraddr, &epaddr, sizeof(epaddr)))\n\t\treturn -EFAULT;\n\tuseraddr += sizeof(epaddr);\n\tif (copy_to_user(useraddr, dev->perm_addr, epaddr.size))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ethtool_get_value(struct net_device *dev, char __user *useraddr,\n\t\t\t     u32 cmd, u32 (*actor)(struct net_device *))\n{\n\tstruct ethtool_value edata = { .cmd = cmd };\n\n\tif (!actor)\n\t\treturn -EOPNOTSUPP;\n\n\tedata.data = actor(dev);\n\n\tif (copy_to_user(useraddr, &edata, sizeof(edata)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ethtool_set_value_void(struct net_device *dev, char __user *useraddr,\n\t\t\t     void (*actor)(struct net_device *, u32))\n{\n\tstruct ethtool_value edata;\n\n\tif (!actor)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&edata, useraddr, sizeof(edata)))\n\t\treturn -EFAULT;\n\n\tactor(dev, edata.data);\n\treturn 0;\n}\n\nstatic int ethtool_set_value(struct net_device *dev, char __user *useraddr,\n\t\t\t     int (*actor)(struct net_device *, u32))\n{\n\tstruct ethtool_value edata;\n\n\tif (!actor)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&edata, useraddr, sizeof(edata)))\n\t\treturn -EFAULT;\n\n\treturn actor(dev, edata.data);\n}\n\nstatic int\nethtool_flash_device(struct net_device *dev, struct ethtool_devlink_compat *req)\n{\n\tif (!dev->ethtool_ops->flash_device) {\n\t\treq->devlink = netdev_to_devlink_get(dev);\n\t\treturn 0;\n\t}\n\n\treturn dev->ethtool_ops->flash_device(dev, &req->efl);\n}\n\nstatic int ethtool_set_dump(struct net_device *dev,\n\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_dump dump;\n\n\tif (!dev->ethtool_ops->set_dump)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&dump, useraddr, sizeof(dump)))\n\t\treturn -EFAULT;\n\n\treturn dev->ethtool_ops->set_dump(dev, &dump);\n}\n\nstatic int ethtool_get_dump_flag(struct net_device *dev,\n\t\t\t\tvoid __user *useraddr)\n{\n\tint ret;\n\tstruct ethtool_dump dump;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\n\tif (!ops->get_dump_flag)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&dump, useraddr, sizeof(dump)))\n\t\treturn -EFAULT;\n\n\tret = ops->get_dump_flag(dev, &dump);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(useraddr, &dump, sizeof(dump)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ethtool_get_dump_data(struct net_device *dev,\n\t\t\t\tvoid __user *useraddr)\n{\n\tint ret;\n\t__u32 len;\n\tstruct ethtool_dump dump, tmp;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tvoid *data = NULL;\n\n\tif (!ops->get_dump_data || !ops->get_dump_flag)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&dump, useraddr, sizeof(dump)))\n\t\treturn -EFAULT;\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\ttmp.cmd = ETHTOOL_GET_DUMP_FLAG;\n\tret = ops->get_dump_flag(dev, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = min(tmp.len, dump.len);\n\tif (!len)\n\t\treturn -EFAULT;\n\n\t \n\tdump.len = len;\n\n\t \n\tdata = vzalloc(tmp.len);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tret = ops->get_dump_data(dev, &dump, data);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tWARN_ON(dump.len != len && dump.len != tmp.len);\n\tdump.len = len;\n\n\tif (copy_to_user(useraddr, &dump, sizeof(dump))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tuseraddr += offsetof(struct ethtool_dump, data);\n\tif (copy_to_user(useraddr, data, len))\n\t\tret = -EFAULT;\nout:\n\tvfree(data);\n\treturn ret;\n}\n\nstatic int ethtool_get_ts_info(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_ts_info info;\n\tint err;\n\n\terr = __ethtool_get_ts_info(dev, &info);\n\tif (err)\n\t\treturn err;\n\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nint ethtool_get_module_info_call(struct net_device *dev,\n\t\t\t\t struct ethtool_modinfo *modinfo)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct phy_device *phydev = dev->phydev;\n\n\tif (dev->sfp_bus)\n\t\treturn sfp_get_module_info(dev->sfp_bus, modinfo);\n\n\tif (phydev && phydev->drv && phydev->drv->module_info)\n\t\treturn phydev->drv->module_info(phydev, modinfo);\n\n\tif (ops->get_module_info)\n\t\treturn ops->get_module_info(dev, modinfo);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ethtool_get_module_info(struct net_device *dev,\n\t\t\t\t   void __user *useraddr)\n{\n\tint ret;\n\tstruct ethtool_modinfo modinfo;\n\n\tif (copy_from_user(&modinfo, useraddr, sizeof(modinfo)))\n\t\treturn -EFAULT;\n\n\tret = ethtool_get_module_info_call(dev, &modinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(useraddr, &modinfo, sizeof(modinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nint ethtool_get_module_eeprom_call(struct net_device *dev,\n\t\t\t\t   struct ethtool_eeprom *ee, u8 *data)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct phy_device *phydev = dev->phydev;\n\n\tif (dev->sfp_bus)\n\t\treturn sfp_get_module_eeprom(dev->sfp_bus, ee, data);\n\n\tif (phydev && phydev->drv && phydev->drv->module_eeprom)\n\t\treturn phydev->drv->module_eeprom(phydev, ee, data);\n\n\tif (ops->get_module_eeprom)\n\t\treturn ops->get_module_eeprom(dev, ee, data);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ethtool_get_module_eeprom(struct net_device *dev,\n\t\t\t\t     void __user *useraddr)\n{\n\tint ret;\n\tstruct ethtool_modinfo modinfo;\n\n\tret = ethtool_get_module_info_call(dev, &modinfo);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ethtool_get_any_eeprom(dev, useraddr,\n\t\t\t\t      ethtool_get_module_eeprom_call,\n\t\t\t\t      modinfo.eeprom_len);\n}\n\nstatic int ethtool_tunable_valid(const struct ethtool_tunable *tuna)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\tcase ETHTOOL_TX_COPYBREAK:\n\tcase ETHTOOL_TX_COPYBREAK_BUF_SIZE:\n\t\tif (tuna->len != sizeof(u32) ||\n\t\t    tuna->type_id != ETHTOOL_TUNABLE_U32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase ETHTOOL_PFC_PREVENTION_TOUT:\n\t\tif (tuna->len != sizeof(u16) ||\n\t\t    tuna->type_id != ETHTOOL_TUNABLE_U16)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ethtool_get_tunable(struct net_device *dev, void __user *useraddr)\n{\n\tint ret;\n\tstruct ethtool_tunable tuna;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tvoid *data;\n\n\tif (!ops->get_tunable)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&tuna, useraddr, sizeof(tuna)))\n\t\treturn -EFAULT;\n\tret = ethtool_tunable_valid(&tuna);\n\tif (ret)\n\t\treturn ret;\n\tdata = kzalloc(tuna.len, GFP_USER);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tret = ops->get_tunable(dev, &tuna, data);\n\tif (ret)\n\t\tgoto out;\n\tuseraddr += sizeof(tuna);\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, data, tuna.len))\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int ethtool_set_tunable(struct net_device *dev, void __user *useraddr)\n{\n\tint ret;\n\tstruct ethtool_tunable tuna;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tvoid *data;\n\n\tif (!ops->set_tunable)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&tuna, useraddr, sizeof(tuna)))\n\t\treturn -EFAULT;\n\tret = ethtool_tunable_valid(&tuna);\n\tif (ret)\n\t\treturn ret;\n\tuseraddr += sizeof(tuna);\n\tdata = memdup_user(useraddr, tuna.len);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\tret = ops->set_tunable(dev, &tuna, data);\n\n\tkfree(data);\n\treturn ret;\n}\n\nstatic noinline_for_stack int\nethtool_get_per_queue_coalesce(struct net_device *dev,\n\t\t\t       void __user *useraddr,\n\t\t\t       struct ethtool_per_queue_op *per_queue_opt)\n{\n\tu32 bit;\n\tint ret;\n\tDECLARE_BITMAP(queue_mask, MAX_NUM_QUEUE);\n\n\tif (!dev->ethtool_ops->get_per_queue_coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tuseraddr += sizeof(*per_queue_opt);\n\n\tbitmap_from_arr32(queue_mask, per_queue_opt->queue_mask,\n\t\t\t  MAX_NUM_QUEUE);\n\n\tfor_each_set_bit(bit, queue_mask, MAX_NUM_QUEUE) {\n\t\tstruct ethtool_coalesce coalesce = { .cmd = ETHTOOL_GCOALESCE };\n\n\t\tret = dev->ethtool_ops->get_per_queue_coalesce(dev, bit, &coalesce);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (copy_to_user(useraddr, &coalesce, sizeof(coalesce)))\n\t\t\treturn -EFAULT;\n\t\tuseraddr += sizeof(coalesce);\n\t}\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int\nethtool_set_per_queue_coalesce(struct net_device *dev,\n\t\t\t       void __user *useraddr,\n\t\t\t       struct ethtool_per_queue_op *per_queue_opt)\n{\n\tu32 bit;\n\tint i, ret = 0;\n\tint n_queue;\n\tstruct ethtool_coalesce *backup = NULL, *tmp = NULL;\n\tDECLARE_BITMAP(queue_mask, MAX_NUM_QUEUE);\n\n\tif ((!dev->ethtool_ops->set_per_queue_coalesce) ||\n\t    (!dev->ethtool_ops->get_per_queue_coalesce))\n\t\treturn -EOPNOTSUPP;\n\n\tuseraddr += sizeof(*per_queue_opt);\n\n\tbitmap_from_arr32(queue_mask, per_queue_opt->queue_mask, MAX_NUM_QUEUE);\n\tn_queue = bitmap_weight(queue_mask, MAX_NUM_QUEUE);\n\ttmp = backup = kmalloc_array(n_queue, sizeof(*backup), GFP_KERNEL);\n\tif (!backup)\n\t\treturn -ENOMEM;\n\n\tfor_each_set_bit(bit, queue_mask, MAX_NUM_QUEUE) {\n\t\tstruct ethtool_coalesce coalesce;\n\n\t\tret = dev->ethtool_ops->get_per_queue_coalesce(dev, bit, tmp);\n\t\tif (ret != 0)\n\t\t\tgoto roll_back;\n\n\t\ttmp++;\n\n\t\tif (copy_from_user(&coalesce, useraddr, sizeof(coalesce))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto roll_back;\n\t\t}\n\n\t\tif (!ethtool_set_coalesce_supported(dev, &coalesce)) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto roll_back;\n\t\t}\n\n\t\tret = dev->ethtool_ops->set_per_queue_coalesce(dev, bit, &coalesce);\n\t\tif (ret != 0)\n\t\t\tgoto roll_back;\n\n\t\tuseraddr += sizeof(coalesce);\n\t}\n\nroll_back:\n\tif (ret != 0) {\n\t\ttmp = backup;\n\t\tfor_each_set_bit(i, queue_mask, bit) {\n\t\t\tdev->ethtool_ops->set_per_queue_coalesce(dev, i, tmp);\n\t\t\ttmp++;\n\t\t}\n\t}\n\tkfree(backup);\n\n\treturn ret;\n}\n\nstatic int noinline_for_stack ethtool_set_per_queue(struct net_device *dev,\n\t\t\t\t void __user *useraddr, u32 sub_cmd)\n{\n\tstruct ethtool_per_queue_op per_queue_opt;\n\n\tif (copy_from_user(&per_queue_opt, useraddr, sizeof(per_queue_opt)))\n\t\treturn -EFAULT;\n\n\tif (per_queue_opt.sub_command != sub_cmd)\n\t\treturn -EINVAL;\n\n\tswitch (per_queue_opt.sub_command) {\n\tcase ETHTOOL_GCOALESCE:\n\t\treturn ethtool_get_per_queue_coalesce(dev, useraddr, &per_queue_opt);\n\tcase ETHTOOL_SCOALESCE:\n\t\treturn ethtool_set_per_queue_coalesce(dev, useraddr, &per_queue_opt);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ethtool_phy_tunable_valid(const struct ethtool_tunable *tuna)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\tcase ETHTOOL_PHY_FAST_LINK_DOWN:\n\t\tif (tuna->len != sizeof(u8) ||\n\t\t    tuna->type_id != ETHTOOL_TUNABLE_U8)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase ETHTOOL_PHY_EDPD:\n\t\tif (tuna->len != sizeof(u16) ||\n\t\t    tuna->type_id != ETHTOOL_TUNABLE_U16)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_phy_tunable(struct net_device *dev, void __user *useraddr)\n{\n\tstruct phy_device *phydev = dev->phydev;\n\tstruct ethtool_tunable tuna;\n\tbool phy_drv_tunable;\n\tvoid *data;\n\tint ret;\n\n\tphy_drv_tunable = phydev && phydev->drv && phydev->drv->get_tunable;\n\tif (!phy_drv_tunable && !dev->ethtool_ops->get_phy_tunable)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&tuna, useraddr, sizeof(tuna)))\n\t\treturn -EFAULT;\n\tret = ethtool_phy_tunable_valid(&tuna);\n\tif (ret)\n\t\treturn ret;\n\tdata = kzalloc(tuna.len, GFP_USER);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tif (phy_drv_tunable) {\n\t\tmutex_lock(&phydev->lock);\n\t\tret = phydev->drv->get_tunable(phydev, &tuna, data);\n\t\tmutex_unlock(&phydev->lock);\n\t} else {\n\t\tret = dev->ethtool_ops->get_phy_tunable(dev, &tuna, data);\n\t}\n\tif (ret)\n\t\tgoto out;\n\tuseraddr += sizeof(tuna);\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, data, tuna.len))\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int set_phy_tunable(struct net_device *dev, void __user *useraddr)\n{\n\tstruct phy_device *phydev = dev->phydev;\n\tstruct ethtool_tunable tuna;\n\tbool phy_drv_tunable;\n\tvoid *data;\n\tint ret;\n\n\tphy_drv_tunable = phydev && phydev->drv && phydev->drv->get_tunable;\n\tif (!phy_drv_tunable && !dev->ethtool_ops->set_phy_tunable)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&tuna, useraddr, sizeof(tuna)))\n\t\treturn -EFAULT;\n\tret = ethtool_phy_tunable_valid(&tuna);\n\tif (ret)\n\t\treturn ret;\n\tuseraddr += sizeof(tuna);\n\tdata = memdup_user(useraddr, tuna.len);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\tif (phy_drv_tunable) {\n\t\tmutex_lock(&phydev->lock);\n\t\tret = phydev->drv->set_tunable(phydev, &tuna, data);\n\t\tmutex_unlock(&phydev->lock);\n\t} else {\n\t\tret = dev->ethtool_ops->set_phy_tunable(dev, &tuna, data);\n\t}\n\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int ethtool_get_fecparam(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_fecparam fecparam = { .cmd = ETHTOOL_GFECPARAM };\n\tint rc;\n\n\tif (!dev->ethtool_ops->get_fecparam)\n\t\treturn -EOPNOTSUPP;\n\n\trc = dev->ethtool_ops->get_fecparam(dev, &fecparam);\n\tif (rc)\n\t\treturn rc;\n\n\tif (WARN_ON_ONCE(fecparam.reserved))\n\t\tfecparam.reserved = 0;\n\n\tif (copy_to_user(useraddr, &fecparam, sizeof(fecparam)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ethtool_set_fecparam(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_fecparam fecparam;\n\n\tif (!dev->ethtool_ops->set_fecparam)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&fecparam, useraddr, sizeof(fecparam)))\n\t\treturn -EFAULT;\n\n\tif (!fecparam.fec || fecparam.fec & ETHTOOL_FEC_NONE)\n\t\treturn -EINVAL;\n\n\tfecparam.active_fec = 0;\n\tfecparam.reserved = 0;\n\n\treturn dev->ethtool_ops->set_fecparam(dev, &fecparam);\n}\n\n \n\nstatic int\n__dev_ethtool(struct net *net, struct ifreq *ifr, void __user *useraddr,\n\t      u32 ethcmd, struct ethtool_devlink_compat *devlink_state)\n{\n\tstruct net_device *dev;\n\tu32 sub_cmd;\n\tint rc;\n\tnetdev_features_t old_features;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (ethcmd == ETHTOOL_PERQUEUE) {\n\t\tif (copy_from_user(&sub_cmd, useraddr + sizeof(ethcmd), sizeof(sub_cmd)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tsub_cmd = ethcmd;\n\t}\n\t \n\tswitch (sub_cmd) {\n\tcase ETHTOOL_GSET:\n\tcase ETHTOOL_GDRVINFO:\n\tcase ETHTOOL_GMSGLVL:\n\tcase ETHTOOL_GLINK:\n\tcase ETHTOOL_GCOALESCE:\n\tcase ETHTOOL_GRINGPARAM:\n\tcase ETHTOOL_GPAUSEPARAM:\n\tcase ETHTOOL_GRXCSUM:\n\tcase ETHTOOL_GTXCSUM:\n\tcase ETHTOOL_GSG:\n\tcase ETHTOOL_GSSET_INFO:\n\tcase ETHTOOL_GSTRINGS:\n\tcase ETHTOOL_GSTATS:\n\tcase ETHTOOL_GPHYSTATS:\n\tcase ETHTOOL_GTSO:\n\tcase ETHTOOL_GPERMADDR:\n\tcase ETHTOOL_GUFO:\n\tcase ETHTOOL_GGSO:\n\tcase ETHTOOL_GGRO:\n\tcase ETHTOOL_GFLAGS:\n\tcase ETHTOOL_GPFLAGS:\n\tcase ETHTOOL_GRXFH:\n\tcase ETHTOOL_GRXRINGS:\n\tcase ETHTOOL_GRXCLSRLCNT:\n\tcase ETHTOOL_GRXCLSRULE:\n\tcase ETHTOOL_GRXCLSRLALL:\n\tcase ETHTOOL_GRXFHINDIR:\n\tcase ETHTOOL_GRSSH:\n\tcase ETHTOOL_GFEATURES:\n\tcase ETHTOOL_GCHANNELS:\n\tcase ETHTOOL_GET_TS_INFO:\n\tcase ETHTOOL_GEEE:\n\tcase ETHTOOL_GTUNABLE:\n\tcase ETHTOOL_PHY_GTUNABLE:\n\tcase ETHTOOL_GLINKSETTINGS:\n\tcase ETHTOOL_GFECPARAM:\n\t\tbreak;\n\tdefault:\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\tif (dev->dev.parent)\n\t\tpm_runtime_get_sync(dev->dev.parent);\n\n\tif (!netif_device_present(dev)) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (dev->ethtool_ops->begin) {\n\t\trc = dev->ethtool_ops->begin(dev);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\told_features = dev->features;\n\n\tswitch (ethcmd) {\n\tcase ETHTOOL_GSET:\n\t\trc = ethtool_get_settings(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SSET:\n\t\trc = ethtool_set_settings(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GDRVINFO:\n\t\trc = ethtool_get_drvinfo(dev, devlink_state);\n\t\tbreak;\n\tcase ETHTOOL_GREGS:\n\t\trc = ethtool_get_regs(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GWOL:\n\t\trc = ethtool_get_wol(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SWOL:\n\t\trc = ethtool_set_wol(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GMSGLVL:\n\t\trc = ethtool_get_value(dev, useraddr, ethcmd,\n\t\t\t\t       dev->ethtool_ops->get_msglevel);\n\t\tbreak;\n\tcase ETHTOOL_SMSGLVL:\n\t\trc = ethtool_set_value_void(dev, useraddr,\n\t\t\t\t       dev->ethtool_ops->set_msglevel);\n\t\tif (!rc)\n\t\t\tethtool_notify(dev, ETHTOOL_MSG_DEBUG_NTF, NULL);\n\t\tbreak;\n\tcase ETHTOOL_GEEE:\n\t\trc = ethtool_get_eee(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SEEE:\n\t\trc = ethtool_set_eee(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_NWAY_RST:\n\t\trc = ethtool_nway_reset(dev);\n\t\tbreak;\n\tcase ETHTOOL_GLINK:\n\t\trc = ethtool_get_link(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GEEPROM:\n\t\trc = ethtool_get_eeprom(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SEEPROM:\n\t\trc = ethtool_set_eeprom(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GCOALESCE:\n\t\trc = ethtool_get_coalesce(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SCOALESCE:\n\t\trc = ethtool_set_coalesce(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GRINGPARAM:\n\t\trc = ethtool_get_ringparam(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SRINGPARAM:\n\t\trc = ethtool_set_ringparam(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GPAUSEPARAM:\n\t\trc = ethtool_get_pauseparam(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SPAUSEPARAM:\n\t\trc = ethtool_set_pauseparam(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_TEST:\n\t\trc = ethtool_self_test(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GSTRINGS:\n\t\trc = ethtool_get_strings(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_PHYS_ID:\n\t\trc = ethtool_phys_id(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GSTATS:\n\t\trc = ethtool_get_stats(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GPERMADDR:\n\t\trc = ethtool_get_perm_addr(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GFLAGS:\n\t\trc = ethtool_get_value(dev, useraddr, ethcmd,\n\t\t\t\t\t__ethtool_get_flags);\n\t\tbreak;\n\tcase ETHTOOL_SFLAGS:\n\t\trc = ethtool_set_value(dev, useraddr, __ethtool_set_flags);\n\t\tbreak;\n\tcase ETHTOOL_GPFLAGS:\n\t\trc = ethtool_get_value(dev, useraddr, ethcmd,\n\t\t\t\t       dev->ethtool_ops->get_priv_flags);\n\t\tif (!rc)\n\t\t\tethtool_notify(dev, ETHTOOL_MSG_PRIVFLAGS_NTF, NULL);\n\t\tbreak;\n\tcase ETHTOOL_SPFLAGS:\n\t\trc = ethtool_set_value(dev, useraddr,\n\t\t\t\t       dev->ethtool_ops->set_priv_flags);\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\tcase ETHTOOL_GRXRINGS:\n\tcase ETHTOOL_GRXCLSRLCNT:\n\tcase ETHTOOL_GRXCLSRULE:\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\trc = ethtool_get_rxnfc(dev, ethcmd, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SRXFH:\n\tcase ETHTOOL_SRXCLSRLDEL:\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\trc = ethtool_set_rxnfc(dev, ethcmd, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_FLASHDEV:\n\t\trc = ethtool_flash_device(dev, devlink_state);\n\t\tbreak;\n\tcase ETHTOOL_RESET:\n\t\trc = ethtool_reset(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GSSET_INFO:\n\t\trc = ethtool_get_sset_info(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GRXFHINDIR:\n\t\trc = ethtool_get_rxfh_indir(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SRXFHINDIR:\n\t\trc = ethtool_set_rxfh_indir(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GRSSH:\n\t\trc = ethtool_get_rxfh(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SRSSH:\n\t\trc = ethtool_set_rxfh(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GFEATURES:\n\t\trc = ethtool_get_features(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SFEATURES:\n\t\trc = ethtool_set_features(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GTXCSUM:\n\tcase ETHTOOL_GRXCSUM:\n\tcase ETHTOOL_GSG:\n\tcase ETHTOOL_GTSO:\n\tcase ETHTOOL_GGSO:\n\tcase ETHTOOL_GGRO:\n\t\trc = ethtool_get_one_feature(dev, useraddr, ethcmd);\n\t\tbreak;\n\tcase ETHTOOL_STXCSUM:\n\tcase ETHTOOL_SRXCSUM:\n\tcase ETHTOOL_SSG:\n\tcase ETHTOOL_STSO:\n\tcase ETHTOOL_SGSO:\n\tcase ETHTOOL_SGRO:\n\t\trc = ethtool_set_one_feature(dev, useraddr, ethcmd);\n\t\tbreak;\n\tcase ETHTOOL_GCHANNELS:\n\t\trc = ethtool_get_channels(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SCHANNELS:\n\t\trc = ethtool_set_channels(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SET_DUMP:\n\t\trc = ethtool_set_dump(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GET_DUMP_FLAG:\n\t\trc = ethtool_get_dump_flag(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GET_DUMP_DATA:\n\t\trc = ethtool_get_dump_data(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GET_TS_INFO:\n\t\trc = ethtool_get_ts_info(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GMODULEINFO:\n\t\trc = ethtool_get_module_info(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GMODULEEEPROM:\n\t\trc = ethtool_get_module_eeprom(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GTUNABLE:\n\t\trc = ethtool_get_tunable(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_STUNABLE:\n\t\trc = ethtool_set_tunable(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GPHYSTATS:\n\t\trc = ethtool_get_phy_stats(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_PERQUEUE:\n\t\trc = ethtool_set_per_queue(dev, useraddr, sub_cmd);\n\t\tbreak;\n\tcase ETHTOOL_GLINKSETTINGS:\n\t\trc = ethtool_get_link_ksettings(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SLINKSETTINGS:\n\t\trc = ethtool_set_link_ksettings(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_PHY_GTUNABLE:\n\t\trc = get_phy_tunable(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_PHY_STUNABLE:\n\t\trc = set_phy_tunable(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_GFECPARAM:\n\t\trc = ethtool_get_fecparam(dev, useraddr);\n\t\tbreak;\n\tcase ETHTOOL_SFECPARAM:\n\t\trc = ethtool_set_fecparam(dev, useraddr);\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tif (dev->ethtool_ops->complete)\n\t\tdev->ethtool_ops->complete(dev);\n\n\tif (old_features != dev->features)\n\t\tnetdev_features_change(dev);\nout:\n\tif (dev->dev.parent)\n\t\tpm_runtime_put(dev->dev.parent);\n\n\treturn rc;\n}\n\nint dev_ethtool(struct net *net, struct ifreq *ifr, void __user *useraddr)\n{\n\tstruct ethtool_devlink_compat *state;\n\tu32 ethcmd;\n\tint rc;\n\n\tif (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))\n\t\treturn -EFAULT;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tswitch (ethcmd) {\n\tcase ETHTOOL_FLASHDEV:\n\t\tif (copy_from_user(&state->efl, useraddr, sizeof(state->efl))) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tstate->efl.data[ETHTOOL_FLASH_MAX_FILENAME - 1] = 0;\n\t\tbreak;\n\t}\n\n\trtnl_lock();\n\trc = __dev_ethtool(net, ifr, useraddr, ethcmd, state);\n\trtnl_unlock();\n\tif (rc)\n\t\tgoto exit_free;\n\n\tswitch (ethcmd) {\n\tcase ETHTOOL_FLASHDEV:\n\t\tif (state->devlink)\n\t\t\trc = devlink_compat_flash_update(state->devlink,\n\t\t\t\t\t\t\t state->efl.data);\n\t\tbreak;\n\tcase ETHTOOL_GDRVINFO:\n\t\tif (state->devlink)\n\t\t\tdevlink_compat_running_version(state->devlink,\n\t\t\t\t\t\t       state->info.fw_version,\n\t\t\t\t\t\t       sizeof(state->info.fw_version));\n\t\tif (copy_to_user(useraddr, &state->info, sizeof(state->info))) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tbreak;\n\t}\n\nexit_free:\n\tif (state->devlink)\n\t\tdevlink_put(state->devlink);\n\tkfree(state);\n\treturn rc;\n}\n\nstruct ethtool_rx_flow_key {\n\tstruct flow_dissector_key_basic\t\t\tbasic;\n\tunion {\n\t\tstruct flow_dissector_key_ipv4_addrs\tipv4;\n\t\tstruct flow_dissector_key_ipv6_addrs\tipv6;\n\t};\n\tstruct flow_dissector_key_ports\t\t\ttp;\n\tstruct flow_dissector_key_ip\t\t\tip;\n\tstruct flow_dissector_key_vlan\t\t\tvlan;\n\tstruct flow_dissector_key_eth_addrs\t\teth_addrs;\n} __aligned(BITS_PER_LONG / 8);  \n\nstruct ethtool_rx_flow_match {\n\tstruct flow_dissector\t\tdissector;\n\tstruct ethtool_rx_flow_key\tkey;\n\tstruct ethtool_rx_flow_key\tmask;\n};\n\nstruct ethtool_rx_flow_rule *\nethtool_rx_flow_rule_create(const struct ethtool_rx_flow_spec_input *input)\n{\n\tconst struct ethtool_rx_flow_spec *fs = input->fs;\n\tstruct ethtool_rx_flow_match *match;\n\tstruct ethtool_rx_flow_rule *flow;\n\tstruct flow_action_entry *act;\n\n\tflow = kzalloc(sizeof(struct ethtool_rx_flow_rule) +\n\t\t       sizeof(struct ethtool_rx_flow_match), GFP_KERNEL);\n\tif (!flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tflow->rule = flow_rule_alloc(1);\n\tif (!flow->rule) {\n\t\tkfree(flow);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmatch = (struct ethtool_rx_flow_match *)flow->priv;\n\tflow->rule->match.dissector\t= &match->dissector;\n\tflow->rule->match.mask\t\t= &match->mask;\n\tflow->rule->match.key\t\t= &match->key;\n\n\tmatch->mask.basic.n_proto = htons(0xffff);\n\n\tswitch (fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT | FLOW_RSS)) {\n\tcase ETHER_FLOW: {\n\t\tconst struct ethhdr *ether_spec, *ether_m_spec;\n\n\t\tether_spec = &fs->h_u.ether_spec;\n\t\tether_m_spec = &fs->m_u.ether_spec;\n\n\t\tif (!is_zero_ether_addr(ether_m_spec->h_source)) {\n\t\t\tether_addr_copy(match->key.eth_addrs.src,\n\t\t\t\t\tether_spec->h_source);\n\t\t\tether_addr_copy(match->mask.eth_addrs.src,\n\t\t\t\t\tether_m_spec->h_source);\n\t\t}\n\t\tif (!is_zero_ether_addr(ether_m_spec->h_dest)) {\n\t\t\tether_addr_copy(match->key.eth_addrs.dst,\n\t\t\t\t\tether_spec->h_dest);\n\t\t\tether_addr_copy(match->mask.eth_addrs.dst,\n\t\t\t\t\tether_m_spec->h_dest);\n\t\t}\n\t\tif (ether_m_spec->h_proto) {\n\t\t\tmatch->key.basic.n_proto = ether_spec->h_proto;\n\t\t\tmatch->mask.basic.n_proto = ether_m_spec->h_proto;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW: {\n\t\tconst struct ethtool_tcpip4_spec *v4_spec, *v4_m_spec;\n\n\t\tmatch->key.basic.n_proto = htons(ETH_P_IP);\n\n\t\tv4_spec = &fs->h_u.tcp_ip4_spec;\n\t\tv4_m_spec = &fs->m_u.tcp_ip4_spec;\n\n\t\tif (v4_m_spec->ip4src) {\n\t\t\tmatch->key.ipv4.src = v4_spec->ip4src;\n\t\t\tmatch->mask.ipv4.src = v4_m_spec->ip4src;\n\t\t}\n\t\tif (v4_m_spec->ip4dst) {\n\t\t\tmatch->key.ipv4.dst = v4_spec->ip4dst;\n\t\t\tmatch->mask.ipv4.dst = v4_m_spec->ip4dst;\n\t\t}\n\t\tif (v4_m_spec->ip4src ||\n\t\t    v4_m_spec->ip4dst) {\n\t\t\tmatch->dissector.used_keys |=\n\t\t\t\tBIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS);\n\t\t\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_IPV4_ADDRS] =\n\t\t\t\toffsetof(struct ethtool_rx_flow_key, ipv4);\n\t\t}\n\t\tif (v4_m_spec->psrc) {\n\t\t\tmatch->key.tp.src = v4_spec->psrc;\n\t\t\tmatch->mask.tp.src = v4_m_spec->psrc;\n\t\t}\n\t\tif (v4_m_spec->pdst) {\n\t\t\tmatch->key.tp.dst = v4_spec->pdst;\n\t\t\tmatch->mask.tp.dst = v4_m_spec->pdst;\n\t\t}\n\t\tif (v4_m_spec->psrc ||\n\t\t    v4_m_spec->pdst) {\n\t\t\tmatch->dissector.used_keys |=\n\t\t\t\tBIT_ULL(FLOW_DISSECTOR_KEY_PORTS);\n\t\t\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_PORTS] =\n\t\t\t\toffsetof(struct ethtool_rx_flow_key, tp);\n\t\t}\n\t\tif (v4_m_spec->tos) {\n\t\t\tmatch->key.ip.tos = v4_spec->tos;\n\t\t\tmatch->mask.ip.tos = v4_m_spec->tos;\n\t\t\tmatch->dissector.used_keys |=\n\t\t\t\tBIT(FLOW_DISSECTOR_KEY_IP);\n\t\t\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_IP] =\n\t\t\t\toffsetof(struct ethtool_rx_flow_key, ip);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW: {\n\t\tconst struct ethtool_tcpip6_spec *v6_spec, *v6_m_spec;\n\n\t\tmatch->key.basic.n_proto = htons(ETH_P_IPV6);\n\n\t\tv6_spec = &fs->h_u.tcp_ip6_spec;\n\t\tv6_m_spec = &fs->m_u.tcp_ip6_spec;\n\t\tif (!ipv6_addr_any((struct in6_addr *)v6_m_spec->ip6src)) {\n\t\t\tmemcpy(&match->key.ipv6.src, v6_spec->ip6src,\n\t\t\t       sizeof(match->key.ipv6.src));\n\t\t\tmemcpy(&match->mask.ipv6.src, v6_m_spec->ip6src,\n\t\t\t       sizeof(match->mask.ipv6.src));\n\t\t}\n\t\tif (!ipv6_addr_any((struct in6_addr *)v6_m_spec->ip6dst)) {\n\t\t\tmemcpy(&match->key.ipv6.dst, v6_spec->ip6dst,\n\t\t\t       sizeof(match->key.ipv6.dst));\n\t\t\tmemcpy(&match->mask.ipv6.dst, v6_m_spec->ip6dst,\n\t\t\t       sizeof(match->mask.ipv6.dst));\n\t\t}\n\t\tif (!ipv6_addr_any((struct in6_addr *)v6_m_spec->ip6src) ||\n\t\t    !ipv6_addr_any((struct in6_addr *)v6_m_spec->ip6dst)) {\n\t\t\tmatch->dissector.used_keys |=\n\t\t\t\tBIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS);\n\t\t\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_IPV6_ADDRS] =\n\t\t\t\toffsetof(struct ethtool_rx_flow_key, ipv6);\n\t\t}\n\t\tif (v6_m_spec->psrc) {\n\t\t\tmatch->key.tp.src = v6_spec->psrc;\n\t\t\tmatch->mask.tp.src = v6_m_spec->psrc;\n\t\t}\n\t\tif (v6_m_spec->pdst) {\n\t\t\tmatch->key.tp.dst = v6_spec->pdst;\n\t\t\tmatch->mask.tp.dst = v6_m_spec->pdst;\n\t\t}\n\t\tif (v6_m_spec->psrc ||\n\t\t    v6_m_spec->pdst) {\n\t\t\tmatch->dissector.used_keys |=\n\t\t\t\tBIT_ULL(FLOW_DISSECTOR_KEY_PORTS);\n\t\t\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_PORTS] =\n\t\t\t\toffsetof(struct ethtool_rx_flow_key, tp);\n\t\t}\n\t\tif (v6_m_spec->tclass) {\n\t\t\tmatch->key.ip.tos = v6_spec->tclass;\n\t\t\tmatch->mask.ip.tos = v6_m_spec->tclass;\n\t\t\tmatch->dissector.used_keys |=\n\t\t\t\tBIT_ULL(FLOW_DISSECTOR_KEY_IP);\n\t\t\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_IP] =\n\t\t\t\toffsetof(struct ethtool_rx_flow_key, ip);\n\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tethtool_rx_flow_rule_destroy(flow);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tswitch (fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT | FLOW_RSS)) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tmatch->key.basic.ip_proto = IPPROTO_TCP;\n\t\tmatch->mask.basic.ip_proto = 0xff;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tmatch->key.basic.ip_proto = IPPROTO_UDP;\n\t\tmatch->mask.basic.ip_proto = 0xff;\n\t\tbreak;\n\t}\n\n\tmatch->dissector.used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_BASIC);\n\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_BASIC] =\n\t\toffsetof(struct ethtool_rx_flow_key, basic);\n\n\tif (fs->flow_type & FLOW_EXT) {\n\t\tconst struct ethtool_flow_ext *ext_h_spec = &fs->h_ext;\n\t\tconst struct ethtool_flow_ext *ext_m_spec = &fs->m_ext;\n\n\t\tif (ext_m_spec->vlan_etype) {\n\t\t\tmatch->key.vlan.vlan_tpid = ext_h_spec->vlan_etype;\n\t\t\tmatch->mask.vlan.vlan_tpid = ext_m_spec->vlan_etype;\n\t\t}\n\n\t\tif (ext_m_spec->vlan_tci) {\n\t\t\tmatch->key.vlan.vlan_id =\n\t\t\t\tntohs(ext_h_spec->vlan_tci) & 0x0fff;\n\t\t\tmatch->mask.vlan.vlan_id =\n\t\t\t\tntohs(ext_m_spec->vlan_tci) & 0x0fff;\n\n\t\t\tmatch->key.vlan.vlan_dei =\n\t\t\t\t!!(ext_h_spec->vlan_tci & htons(0x1000));\n\t\t\tmatch->mask.vlan.vlan_dei =\n\t\t\t\t!!(ext_m_spec->vlan_tci & htons(0x1000));\n\n\t\t\tmatch->key.vlan.vlan_priority =\n\t\t\t\t(ntohs(ext_h_spec->vlan_tci) & 0xe000) >> 13;\n\t\t\tmatch->mask.vlan.vlan_priority =\n\t\t\t\t(ntohs(ext_m_spec->vlan_tci) & 0xe000) >> 13;\n\t\t}\n\n\t\tif (ext_m_spec->vlan_etype ||\n\t\t    ext_m_spec->vlan_tci) {\n\t\t\tmatch->dissector.used_keys |=\n\t\t\t\tBIT_ULL(FLOW_DISSECTOR_KEY_VLAN);\n\t\t\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_VLAN] =\n\t\t\t\toffsetof(struct ethtool_rx_flow_key, vlan);\n\t\t}\n\t}\n\tif (fs->flow_type & FLOW_MAC_EXT) {\n\t\tconst struct ethtool_flow_ext *ext_h_spec = &fs->h_ext;\n\t\tconst struct ethtool_flow_ext *ext_m_spec = &fs->m_ext;\n\n\t\tmemcpy(match->key.eth_addrs.dst, ext_h_spec->h_dest,\n\t\t       ETH_ALEN);\n\t\tmemcpy(match->mask.eth_addrs.dst, ext_m_spec->h_dest,\n\t\t       ETH_ALEN);\n\n\t\tmatch->dissector.used_keys |=\n\t\t\tBIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS);\n\t\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_ETH_ADDRS] =\n\t\t\toffsetof(struct ethtool_rx_flow_key, eth_addrs);\n\t}\n\n\tact = &flow->rule->action.entries[0];\n\tswitch (fs->ring_cookie) {\n\tcase RX_CLS_FLOW_DISC:\n\t\tact->id = FLOW_ACTION_DROP;\n\t\tbreak;\n\tcase RX_CLS_FLOW_WAKE:\n\t\tact->id = FLOW_ACTION_WAKE;\n\t\tbreak;\n\tdefault:\n\t\tact->id = FLOW_ACTION_QUEUE;\n\t\tif (fs->flow_type & FLOW_RSS)\n\t\t\tact->queue.ctx = input->rss_ctx;\n\n\t\tact->queue.vf = ethtool_get_flow_spec_ring_vf(fs->ring_cookie);\n\t\tact->queue.index = ethtool_get_flow_spec_ring(fs->ring_cookie);\n\t\tbreak;\n\t}\n\n\treturn flow;\n}\nEXPORT_SYMBOL(ethtool_rx_flow_rule_create);\n\nvoid ethtool_rx_flow_rule_destroy(struct ethtool_rx_flow_rule *flow)\n{\n\tkfree(flow->rule);\n\tkfree(flow);\n}\nEXPORT_SYMBOL(ethtool_rx_flow_rule_destroy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}