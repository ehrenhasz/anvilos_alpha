{
  "module_name": "rss.c",
  "hash_id": "173b6f3d7f159866fd7ba11765d21134e405fa7f2afc28332774dfeba0aae271",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/rss.c",
  "human_readable_source": "\n\n#include \"netlink.h\"\n#include \"common.h\"\n\nstruct rss_req_info {\n\tstruct ethnl_req_info\t\tbase;\n\tu32\t\t\t\trss_context;\n};\n\nstruct rss_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tu32\t\t\t\tindir_size;\n\tu32\t\t\t\thkey_size;\n\tu32\t\t\t\thfunc;\n\tu32\t\t\t\t*indir_table;\n\tu8\t\t\t\t*hkey;\n};\n\n#define RSS_REQINFO(__req_base) \\\n\tcontainer_of(__req_base, struct rss_req_info, base)\n\n#define RSS_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct rss_reply_data, base)\n\nconst struct nla_policy ethnl_rss_get_policy[] = {\n\t[ETHTOOL_A_RSS_HEADER] = NLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_RSS_CONTEXT] = { .type = NLA_U32 },\n};\n\nstatic int\nrss_parse_request(struct ethnl_req_info *req_info, struct nlattr **tb,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct rss_req_info *request = RSS_REQINFO(req_info);\n\n\tif (tb[ETHTOOL_A_RSS_CONTEXT])\n\t\trequest->rss_context = nla_get_u32(tb[ETHTOOL_A_RSS_CONTEXT]);\n\n\treturn 0;\n}\n\nstatic int\nrss_prepare_data(const struct ethnl_req_info *req_base,\n\t\t struct ethnl_reply_data *reply_base,\n\t\t const struct genl_info *info)\n{\n\tstruct rss_reply_data *data = RSS_REPDATA(reply_base);\n\tstruct rss_req_info *request = RSS_REQINFO(req_base);\n\tstruct net_device *dev = reply_base->dev;\n\tconst struct ethtool_ops *ops;\n\tu32 total_size, indir_bytes;\n\tu8 dev_hfunc = 0;\n\tu8 *rss_config;\n\tint ret;\n\n\tops = dev->ethtool_ops;\n\tif (!ops->get_rxfh)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (request->rss_context && !ops->get_rxfh_context)\n\t\treturn -EOPNOTSUPP;\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->indir_size = 0;\n\tdata->hkey_size = 0;\n\tif (ops->get_rxfh_indir_size)\n\t\tdata->indir_size = ops->get_rxfh_indir_size(dev);\n\tif (ops->get_rxfh_key_size)\n\t\tdata->hkey_size = ops->get_rxfh_key_size(dev);\n\n\tindir_bytes = data->indir_size * sizeof(u32);\n\ttotal_size = indir_bytes + data->hkey_size;\n\trss_config = kzalloc(total_size, GFP_KERNEL);\n\tif (!rss_config) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ops;\n\t}\n\n\tif (data->indir_size)\n\t\tdata->indir_table = (u32 *)rss_config;\n\n\tif (data->hkey_size)\n\t\tdata->hkey = rss_config + indir_bytes;\n\n\tif (request->rss_context)\n\t\tret = ops->get_rxfh_context(dev, data->indir_table, data->hkey,\n\t\t\t\t\t    &dev_hfunc, request->rss_context);\n\telse\n\t\tret = ops->get_rxfh(dev, data->indir_table, data->hkey,\n\t\t\t\t    &dev_hfunc);\n\n\tif (ret)\n\t\tgoto out_ops;\n\n\tdata->hfunc = dev_hfunc;\nout_ops:\n\tethnl_ops_complete(dev);\n\treturn ret;\n}\n\nstatic int\nrss_reply_size(const struct ethnl_req_info *req_base,\n\t       const struct ethnl_reply_data *reply_base)\n{\n\tconst struct rss_reply_data *data = RSS_REPDATA(reply_base);\n\tint len;\n\n\tlen = nla_total_size(sizeof(u32)) +\t \n\t      nla_total_size(sizeof(u32) * data->indir_size) +  \n\t      nla_total_size(data->hkey_size);\t \n\n\treturn len;\n}\n\nstatic int\nrss_fill_reply(struct sk_buff *skb, const struct ethnl_req_info *req_base,\n\t       const struct ethnl_reply_data *reply_base)\n{\n\tconst struct rss_reply_data *data = RSS_REPDATA(reply_base);\n\n\tif ((data->hfunc &&\n\t     nla_put_u32(skb, ETHTOOL_A_RSS_HFUNC, data->hfunc)) ||\n\t    (data->indir_size &&\n\t     nla_put(skb, ETHTOOL_A_RSS_INDIR,\n\t\t     sizeof(u32) * data->indir_size, data->indir_table)) ||\n\t    (data->hkey_size &&\n\t     nla_put(skb, ETHTOOL_A_RSS_HKEY, data->hkey_size, data->hkey)))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic void rss_cleanup_data(struct ethnl_reply_data *reply_base)\n{\n\tconst struct rss_reply_data *data = RSS_REPDATA(reply_base);\n\n\tkfree(data->indir_table);\n}\n\nconst struct ethnl_request_ops ethnl_rss_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_RSS_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_RSS_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_RSS_HEADER,\n\t.req_info_size\t\t= sizeof(struct rss_req_info),\n\t.reply_data_size\t= sizeof(struct rss_reply_data),\n\n\t.parse_request\t\t= rss_parse_request,\n\t.prepare_data\t\t= rss_prepare_data,\n\t.reply_size\t\t= rss_reply_size,\n\t.fill_reply\t\t= rss_fill_reply,\n\t.cleanup_data\t\t= rss_cleanup_data,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}