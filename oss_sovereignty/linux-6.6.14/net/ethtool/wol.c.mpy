{
  "module_name": "wol.c",
  "hash_id": "75a8af74721bddb0ebcdc25b97795ab2fbd3e33e019809537b6df482b89b4b60",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/wol.c",
  "human_readable_source": "\n\n#include \"netlink.h\"\n#include \"common.h\"\n#include \"bitset.h\"\n\nstruct wol_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstruct wol_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tstruct ethtool_wolinfo\t\twol;\n\tbool\t\t\t\tshow_sopass;\n};\n\n#define WOL_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct wol_reply_data, base)\n\nconst struct nla_policy ethnl_wol_get_policy[] = {\n\t[ETHTOOL_A_WOL_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic int wol_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t    struct ethnl_reply_data *reply_base,\n\t\t\t    const struct genl_info *info)\n{\n\tstruct wol_reply_data *data = WOL_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tint ret;\n\n\tif (!dev->ethtool_ops->get_wol)\n\t\treturn -EOPNOTSUPP;\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev->ethtool_ops->get_wol(dev, &data->wol);\n\tethnl_ops_complete(dev);\n\t \n\tdata->show_sopass = !genl_info_is_ntf(info) &&\n\t\t(data->wol.supported & WAKE_MAGICSECURE);\n\n\treturn 0;\n}\n\nstatic int wol_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t  const struct ethnl_reply_data *reply_base)\n{\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tconst struct wol_reply_data *data = WOL_REPDATA(reply_base);\n\tint len;\n\n\tlen = ethnl_bitset32_size(&data->wol.wolopts, &data->wol.supported,\n\t\t\t\t  WOL_MODE_COUNT, wol_mode_names, compact);\n\tif (len < 0)\n\t\treturn len;\n\tif (data->show_sopass)\n\t\tlen += nla_total_size(sizeof(data->wol.sopass));\n\n\treturn len;\n}\n\nstatic int wol_fill_reply(struct sk_buff *skb,\n\t\t\t  const struct ethnl_req_info *req_base,\n\t\t\t  const struct ethnl_reply_data *reply_base)\n{\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tconst struct wol_reply_data *data = WOL_REPDATA(reply_base);\n\tint ret;\n\n\tret = ethnl_put_bitset32(skb, ETHTOOL_A_WOL_MODES, &data->wol.wolopts,\n\t\t\t\t &data->wol.supported, WOL_MODE_COUNT,\n\t\t\t\t wol_mode_names, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (data->show_sopass &&\n\t    nla_put(skb, ETHTOOL_A_WOL_SOPASS, sizeof(data->wol.sopass),\n\t\t    data->wol.sopass))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\n \n\nconst struct nla_policy ethnl_wol_set_policy[] = {\n\t[ETHTOOL_A_WOL_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_WOL_MODES]\t\t= { .type = NLA_NESTED },\n\t[ETHTOOL_A_WOL_SOPASS]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = SOPASS_MAX },\n};\n\nstatic int\nethnl_set_wol_validate(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tconst struct ethtool_ops *ops = req_info->dev->ethtool_ops;\n\n\treturn ops->get_wol && ops->set_wol ? 1 : -EOPNOTSUPP;\n}\n\nstatic int\nethnl_set_wol(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tstruct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };\n\tstruct net_device *dev = req_info->dev;\n\tstruct nlattr **tb = info->attrs;\n\tbool mod = false;\n\tint ret;\n\n\tdev->ethtool_ops->get_wol(dev, &wol);\n\tret = ethnl_update_bitset32(&wol.wolopts, WOL_MODE_COUNT,\n\t\t\t\t    tb[ETHTOOL_A_WOL_MODES], wol_mode_names,\n\t\t\t\t    info->extack, &mod);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (wol.wolopts & ~wol.supported) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, tb[ETHTOOL_A_WOL_MODES],\n\t\t\t\t    \"cannot enable unsupported WoL mode\");\n\t\treturn -EINVAL;\n\t}\n\tif (tb[ETHTOOL_A_WOL_SOPASS]) {\n\t\tif (!(wol.supported & WAKE_MAGICSECURE)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    tb[ETHTOOL_A_WOL_SOPASS],\n\t\t\t\t\t    \"magicsecure not supported, cannot set password\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tethnl_update_binary(wol.sopass, sizeof(wol.sopass),\n\t\t\t\t    tb[ETHTOOL_A_WOL_SOPASS], &mod);\n\t}\n\n\tif (!mod)\n\t\treturn 0;\n\tret = dev->ethtool_ops->set_wol(dev, &wol);\n\tif (ret)\n\t\treturn ret;\n\tdev->wol_enabled = !!wol.wolopts;\n\treturn 1;\n}\n\nconst struct ethnl_request_ops ethnl_wol_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_WOL_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_WOL_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_WOL_HEADER,\n\t.req_info_size\t\t= sizeof(struct wol_req_info),\n\t.reply_data_size\t= sizeof(struct wol_reply_data),\n\n\t.prepare_data\t\t= wol_prepare_data,\n\t.reply_size\t\t= wol_reply_size,\n\t.fill_reply\t\t= wol_fill_reply,\n\n\t.set_validate\t\t= ethnl_set_wol_validate,\n\t.set\t\t\t= ethnl_set_wol,\n\t.set_ntf_cmd\t\t= ETHTOOL_MSG_WOL_NTF,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}