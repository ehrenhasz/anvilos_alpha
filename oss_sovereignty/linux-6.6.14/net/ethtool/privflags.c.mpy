{
  "module_name": "privflags.c",
  "hash_id": "ee12e60f7c276554d303ac4ffbe86dbc6cd8a0b0682d4c53116bde1f2773603a",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/privflags.c",
  "human_readable_source": "\n\n#include \"netlink.h\"\n#include \"common.h\"\n#include \"bitset.h\"\n\nstruct privflags_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstruct privflags_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tconst char\t\t\t(*priv_flag_names)[ETH_GSTRING_LEN];\n\tunsigned int\t\t\tn_priv_flags;\n\tu32\t\t\t\tpriv_flags;\n};\n\n#define PRIVFLAGS_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct privflags_reply_data, base)\n\nconst struct nla_policy ethnl_privflags_get_policy[] = {\n\t[ETHTOOL_A_PRIVFLAGS_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic int ethnl_get_priv_flags_info(struct net_device *dev,\n\t\t\t\t     unsigned int *count,\n\t\t\t\t     const char (**names)[ETH_GSTRING_LEN])\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint nflags;\n\n\tnflags = ops->get_sset_count(dev, ETH_SS_PRIV_FLAGS);\n\tif (nflags < 0)\n\t\treturn nflags;\n\n\tif (names) {\n\t\t*names = kcalloc(nflags, ETH_GSTRING_LEN, GFP_KERNEL);\n\t\tif (!*names)\n\t\t\treturn -ENOMEM;\n\t\tops->get_strings(dev, ETH_SS_PRIV_FLAGS, (u8 *)*names);\n\t}\n\n\t \n\tif (WARN_ONCE(nflags > 32,\n\t\t      \"device %s reports more than 32 private flags (%d)\\n\",\n\t\t      netdev_name(dev), nflags))\n\t\tnflags = 32;\n\t*count = nflags;\n\n\treturn 0;\n}\n\nstatic int privflags_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t\t  struct ethnl_reply_data *reply_base,\n\t\t\t\t  const struct genl_info *info)\n{\n\tstruct privflags_reply_data *data = PRIVFLAGS_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tconst char (*names)[ETH_GSTRING_LEN];\n\tconst struct ethtool_ops *ops;\n\tunsigned int nflags;\n\tint ret;\n\n\tops = dev->ethtool_ops;\n\tif (!ops->get_priv_flags || !ops->get_sset_count || !ops->get_strings)\n\t\treturn -EOPNOTSUPP;\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ethnl_get_priv_flags_info(dev, &nflags, &names);\n\tif (ret < 0)\n\t\tgoto out_ops;\n\tdata->priv_flags = ops->get_priv_flags(dev);\n\tdata->priv_flag_names = names;\n\tdata->n_priv_flags = nflags;\n\nout_ops:\n\tethnl_ops_complete(dev);\n\treturn ret;\n}\n\nstatic int privflags_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t\tconst struct ethnl_reply_data *reply_base)\n{\n\tconst struct privflags_reply_data *data = PRIVFLAGS_REPDATA(reply_base);\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tconst u32 all_flags = ~(u32)0 >> (32 - data->n_priv_flags);\n\n\treturn ethnl_bitset32_size(&data->priv_flags, &all_flags,\n\t\t\t\t   data->n_priv_flags,\n\t\t\t\t   data->priv_flag_names, compact);\n}\n\nstatic int privflags_fill_reply(struct sk_buff *skb,\n\t\t\t\tconst struct ethnl_req_info *req_base,\n\t\t\t\tconst struct ethnl_reply_data *reply_base)\n{\n\tconst struct privflags_reply_data *data = PRIVFLAGS_REPDATA(reply_base);\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tconst u32 all_flags = ~(u32)0 >> (32 - data->n_priv_flags);\n\n\treturn ethnl_put_bitset32(skb, ETHTOOL_A_PRIVFLAGS_FLAGS,\n\t\t\t\t  &data->priv_flags, &all_flags,\n\t\t\t\t  data->n_priv_flags, data->priv_flag_names,\n\t\t\t\t  compact);\n}\n\nstatic void privflags_cleanup_data(struct ethnl_reply_data *reply_data)\n{\n\tstruct privflags_reply_data *data = PRIVFLAGS_REPDATA(reply_data);\n\n\tkfree(data->priv_flag_names);\n}\n\n \n\nconst struct nla_policy ethnl_privflags_set_policy[] = {\n\t[ETHTOOL_A_PRIVFLAGS_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_PRIVFLAGS_FLAGS]\t\t= { .type = NLA_NESTED },\n};\n\nstatic int\nethnl_set_privflags_validate(struct ethnl_req_info *req_info,\n\t\t\t     struct genl_info *info)\n{\n\tconst struct ethtool_ops *ops = req_info->dev->ethtool_ops;\n\n\tif (!info->attrs[ETHTOOL_A_PRIVFLAGS_FLAGS])\n\t\treturn -EINVAL;\n\n\tif (!ops->get_priv_flags || !ops->set_priv_flags ||\n\t    !ops->get_sset_count || !ops->get_strings)\n\t\treturn -EOPNOTSUPP;\n\treturn 1;\n}\n\nstatic int\nethnl_set_privflags(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tconst char (*names)[ETH_GSTRING_LEN] = NULL;\n\tstruct net_device *dev = req_info->dev;\n\tstruct nlattr **tb = info->attrs;\n\tunsigned int nflags;\n\tbool mod = false;\n\tbool compact;\n\tu32 flags;\n\tint ret;\n\n\tret = ethnl_bitset_is_compact(tb[ETHTOOL_A_PRIVFLAGS_FLAGS], &compact);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ethnl_get_priv_flags_info(dev, &nflags, compact ? NULL : &names);\n\tif (ret < 0)\n\t\treturn ret;\n\tflags = dev->ethtool_ops->get_priv_flags(dev);\n\n\tret = ethnl_update_bitset32(&flags, nflags,\n\t\t\t\t    tb[ETHTOOL_A_PRIVFLAGS_FLAGS], names,\n\t\t\t\t    info->extack, &mod);\n\tif (ret < 0 || !mod)\n\t\tgoto out_free;\n\tret = dev->ethtool_ops->set_priv_flags(dev, flags);\n\tif (ret < 0)\n\t\tgoto out_free;\n\tret = 1;\n\nout_free:\n\tkfree(names);\n\treturn ret;\n}\n\nconst struct ethnl_request_ops ethnl_privflags_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_PRIVFLAGS_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_PRIVFLAGS_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_PRIVFLAGS_HEADER,\n\t.req_info_size\t\t= sizeof(struct privflags_req_info),\n\t.reply_data_size\t= sizeof(struct privflags_reply_data),\n\n\t.prepare_data\t\t= privflags_prepare_data,\n\t.reply_size\t\t= privflags_reply_size,\n\t.fill_reply\t\t= privflags_fill_reply,\n\t.cleanup_data\t\t= privflags_cleanup_data,\n\n\t.set_validate\t\t= ethnl_set_privflags_validate,\n\t.set\t\t\t= ethnl_set_privflags,\n\t.set_ntf_cmd\t\t= ETHTOOL_MSG_PRIVFLAGS_NTF,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}