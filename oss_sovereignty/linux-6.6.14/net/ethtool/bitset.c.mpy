{
  "module_name": "bitset.c",
  "hash_id": "d7846e8eca4f7d388b7a536b6e308cc6f298dce90a0fc42966470985187b7e7e",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/bitset.c",
  "human_readable_source": "\n\n#include <linux/ethtool_netlink.h>\n#include <linux/bitmap.h>\n#include \"netlink.h\"\n#include \"bitset.h\"\n\n \n\nstatic u32 ethnl_lower_bits(unsigned int n)\n{\n\treturn ~(u32)0 >> (32 - n % 32);\n}\n\nstatic u32 ethnl_upper_bits(unsigned int n)\n{\n\treturn ~(u32)0 << (n % 32);\n}\n\n \nstatic void ethnl_bitmap32_clear(u32 *dst, unsigned int start, unsigned int end,\n\t\t\t\t bool *mod)\n{\n\tunsigned int start_word = start / 32;\n\tunsigned int end_word = end / 32;\n\tunsigned int i;\n\tu32 mask;\n\n\tif (end <= start)\n\t\treturn;\n\n\tif (start % 32) {\n\t\tmask = ethnl_upper_bits(start);\n\t\tif (end_word == start_word) {\n\t\t\tmask &= ethnl_lower_bits(end);\n\t\t\tif (dst[start_word] & mask) {\n\t\t\t\tdst[start_word] &= ~mask;\n\t\t\t\t*mod = true;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (dst[start_word] & mask) {\n\t\t\tdst[start_word] &= ~mask;\n\t\t\t*mod = true;\n\t\t}\n\t\tstart_word++;\n\t}\n\n\tfor (i = start_word; i < end_word; i++) {\n\t\tif (dst[i]) {\n\t\t\tdst[i] = 0;\n\t\t\t*mod = true;\n\t\t}\n\t}\n\tif (end % 32) {\n\t\tmask = ethnl_lower_bits(end);\n\t\tif (dst[end_word] & mask) {\n\t\t\tdst[end_word] &= ~mask;\n\t\t\t*mod = true;\n\t\t}\n\t}\n}\n\n \nstatic bool ethnl_bitmap32_not_zero(const u32 *map, unsigned int start,\n\t\t\t\t    unsigned int end)\n{\n\tunsigned int start_word = start / 32;\n\tunsigned int end_word = end / 32;\n\tu32 mask;\n\n\tif (end <= start)\n\t\treturn true;\n\n\tif (start % 32) {\n\t\tmask = ethnl_upper_bits(start);\n\t\tif (end_word == start_word) {\n\t\t\tmask &= ethnl_lower_bits(end);\n\t\t\treturn map[start_word] & mask;\n\t\t}\n\t\tif (map[start_word] & mask)\n\t\t\treturn true;\n\t\tstart_word++;\n\t}\n\n\tif (!memchr_inv(map + start_word, '\\0',\n\t\t\t(end_word - start_word) * sizeof(u32)))\n\t\treturn true;\n\tif (end % 32 == 0)\n\t\treturn true;\n\treturn map[end_word] & ethnl_lower_bits(end);\n}\n\n \nstatic void ethnl_bitmap32_update(u32 *dst, unsigned int nbits,\n\t\t\t\t  const u32 *value, const u32 *mask, bool *mod)\n{\n\twhile (nbits > 0) {\n\t\tu32 real_mask = mask ? *mask : ~(u32)0;\n\t\tu32 new_value;\n\n\t\tif (nbits < 32)\n\t\t\treal_mask &= ethnl_lower_bits(nbits);\n\t\tnew_value = (*dst & ~real_mask) | (*value & real_mask);\n\t\tif (new_value != *dst) {\n\t\t\t*dst = new_value;\n\t\t\t*mod = true;\n\t\t}\n\n\t\tif (nbits <= 32)\n\t\t\tbreak;\n\t\tdst++;\n\t\tnbits -= 32;\n\t\tvalue++;\n\t\tif (mask)\n\t\t\tmask++;\n\t}\n}\n\nstatic bool ethnl_bitmap32_test_bit(const u32 *map, unsigned int index)\n{\n\treturn map[index / 32] & (1U << (index % 32));\n}\n\n \nint ethnl_bitset32_size(const u32 *val, const u32 *mask, unsigned int nbits,\n\t\t\tethnl_string_array_t names, bool compact)\n{\n\tunsigned int len = 0;\n\n\t \n\tif (!mask)\n\t\tlen += nla_total_size(sizeof(u32));\n\t \n\tlen += nla_total_size(sizeof(u32));\n\n\tif (compact) {\n\t\tunsigned int nwords = DIV_ROUND_UP(nbits, 32);\n\n\t\t \n\t\tlen += (mask ? 2 : 1) * nla_total_size(nwords * sizeof(u32));\n\t} else {\n\t\tunsigned int bits_len = 0;\n\t\tunsigned int bit_len, i;\n\n\t\tfor (i = 0; i < nbits; i++) {\n\t\t\tconst char *name = names ? names[i] : NULL;\n\n\t\t\tif (!ethnl_bitmap32_test_bit(mask ?: val, i))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tbit_len = nla_total_size(sizeof(u32));\n\t\t\t \n\t\t\tif (name)\n\t\t\t\tbit_len += ethnl_strz_size(name);\n\t\t\t \n\t\t\tif (mask && ethnl_bitmap32_test_bit(val, i))\n\t\t\t\tbit_len += nla_total_size(0);\n\n\t\t\t \n\t\t\tbits_len += nla_total_size(bit_len);\n\t\t}\n\t\t \n\t\tlen += nla_total_size(bits_len);\n\t}\n\n\t \n\treturn nla_total_size(len);\n}\n\n \nint ethnl_put_bitset32(struct sk_buff *skb, int attrtype, const u32 *val,\n\t\t       const u32 *mask, unsigned int nbits,\n\t\t       ethnl_string_array_t names, bool compact)\n{\n\tstruct nlattr *nest;\n\tstruct nlattr *attr;\n\n\tnest = nla_nest_start(skb, attrtype);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (!mask && nla_put_flag(skb, ETHTOOL_A_BITSET_NOMASK))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, ETHTOOL_A_BITSET_SIZE, nbits))\n\t\tgoto nla_put_failure;\n\tif (compact) {\n\t\tunsigned int nwords = DIV_ROUND_UP(nbits, 32);\n\t\tunsigned int nbytes = nwords * sizeof(u32);\n\t\tu32 *dst;\n\n\t\tattr = nla_reserve(skb, ETHTOOL_A_BITSET_VALUE, nbytes);\n\t\tif (!attr)\n\t\t\tgoto nla_put_failure;\n\t\tdst = nla_data(attr);\n\t\tmemcpy(dst, val, nbytes);\n\t\tif (nbits % 32)\n\t\t\tdst[nwords - 1] &= ethnl_lower_bits(nbits);\n\n\t\tif (mask) {\n\t\t\tattr = nla_reserve(skb, ETHTOOL_A_BITSET_MASK, nbytes);\n\t\t\tif (!attr)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tdst = nla_data(attr);\n\t\t\tmemcpy(dst, mask, nbytes);\n\t\t\tif (nbits % 32)\n\t\t\t\tdst[nwords - 1] &= ethnl_lower_bits(nbits);\n\t\t}\n\t} else {\n\t\tstruct nlattr *bits;\n\t\tunsigned int i;\n\n\t\tbits = nla_nest_start(skb, ETHTOOL_A_BITSET_BITS);\n\t\tif (!bits)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < nbits; i++) {\n\t\t\tconst char *name = names ? names[i] : NULL;\n\n\t\t\tif (!ethnl_bitmap32_test_bit(mask ?: val, i))\n\t\t\t\tcontinue;\n\t\t\tattr = nla_nest_start(skb, ETHTOOL_A_BITSET_BITS_BIT);\n\t\t\tif (!attr)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(skb, ETHTOOL_A_BITSET_BIT_INDEX, i))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (name &&\n\t\t\t    ethnl_put_strz(skb, ETHTOOL_A_BITSET_BIT_NAME, name))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (mask && ethnl_bitmap32_test_bit(val, i) &&\n\t\t\t    nla_put_flag(skb, ETHTOOL_A_BITSET_BIT_VALUE))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(skb, attr);\n\t\t}\n\t\tnla_nest_end(skb, bits);\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy bitset_policy[] = {\n\t[ETHTOOL_A_BITSET_NOMASK]\t= { .type = NLA_FLAG },\n\t[ETHTOOL_A_BITSET_SIZE]\t\t= NLA_POLICY_MAX(NLA_U32,\n\t\t\t\t\t\t\t ETHNL_MAX_BITSET_SIZE),\n\t[ETHTOOL_A_BITSET_BITS]\t\t= { .type = NLA_NESTED },\n\t[ETHTOOL_A_BITSET_VALUE]\t= { .type = NLA_BINARY },\n\t[ETHTOOL_A_BITSET_MASK]\t\t= { .type = NLA_BINARY },\n};\n\nstatic const struct nla_policy bit_policy[] = {\n\t[ETHTOOL_A_BITSET_BIT_INDEX]\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_BITSET_BIT_NAME]\t= { .type = NLA_NUL_STRING },\n\t[ETHTOOL_A_BITSET_BIT_VALUE]\t= { .type = NLA_FLAG },\n};\n\n \nint ethnl_bitset_is_compact(const struct nlattr *bitset, bool *compact)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(bitset_policy)];\n\tint ret;\n\n\tret = nla_parse_nested(tb, ARRAY_SIZE(bitset_policy) - 1, bitset,\n\t\t\t       bitset_policy, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tb[ETHTOOL_A_BITSET_BITS]) {\n\t\tif (tb[ETHTOOL_A_BITSET_VALUE] || tb[ETHTOOL_A_BITSET_MASK])\n\t\t\treturn -EINVAL;\n\t\t*compact = false;\n\t\treturn 0;\n\t}\n\tif (!tb[ETHTOOL_A_BITSET_SIZE] || !tb[ETHTOOL_A_BITSET_VALUE])\n\t\treturn -EINVAL;\n\n\t*compact = true;\n\treturn 0;\n}\n\n \nstatic int ethnl_name_to_idx(ethnl_string_array_t names, unsigned int n_names,\n\t\t\t     const char *name)\n{\n\tunsigned int i;\n\n\tif (!names)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < n_names; i++) {\n\t\t \n\t\tif (!strncmp(names[i], name, ETH_GSTRING_LEN) &&\n\t\t    strlen(name) <= ETH_GSTRING_LEN)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int ethnl_parse_bit(unsigned int *index, bool *val, unsigned int nbits,\n\t\t\t   const struct nlattr *bit_attr, bool no_mask,\n\t\t\t   ethnl_string_array_t names,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(bit_policy)];\n\tint ret, idx;\n\n\tret = nla_parse_nested(tb, ARRAY_SIZE(bit_policy) - 1, bit_attr,\n\t\t\t       bit_policy, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tb[ETHTOOL_A_BITSET_BIT_INDEX]) {\n\t\tconst char *name;\n\n\t\tidx = nla_get_u32(tb[ETHTOOL_A_BITSET_BIT_INDEX]);\n\t\tif (idx >= nbits) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[ETHTOOL_A_BITSET_BIT_INDEX],\n\t\t\t\t\t    \"bit index too high\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tname = names ? names[idx] : NULL;\n\t\tif (tb[ETHTOOL_A_BITSET_BIT_NAME] && name &&\n\t\t    strncmp(nla_data(tb[ETHTOOL_A_BITSET_BIT_NAME]), name,\n\t\t\t    nla_len(tb[ETHTOOL_A_BITSET_BIT_NAME]))) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, bit_attr,\n\t\t\t\t\t    \"bit index and name mismatch\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (tb[ETHTOOL_A_BITSET_BIT_NAME]) {\n\t\tidx = ethnl_name_to_idx(names, nbits,\n\t\t\t\t\tnla_data(tb[ETHTOOL_A_BITSET_BIT_NAME]));\n\t\tif (idx < 0) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    tb[ETHTOOL_A_BITSET_BIT_NAME],\n\t\t\t\t\t    \"bit name not found\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tNL_SET_ERR_MSG_ATTR(extack, bit_attr,\n\t\t\t\t    \"neither bit index nor name specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*index = idx;\n\t*val = no_mask || tb[ETHTOOL_A_BITSET_BIT_VALUE];\n\treturn 0;\n}\n\nstatic int\nethnl_update_bitset32_verbose(u32 *bitmap, unsigned int nbits,\n\t\t\t      const struct nlattr *attr, struct nlattr **tb,\n\t\t\t      ethnl_string_array_t names,\n\t\t\t      struct netlink_ext_ack *extack, bool *mod)\n{\n\tstruct nlattr *bit_attr;\n\tbool no_mask;\n\tint rem;\n\tint ret;\n\n\tif (tb[ETHTOOL_A_BITSET_VALUE]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_BITSET_VALUE],\n\t\t\t\t    \"value only allowed in compact bitset\");\n\t\treturn -EINVAL;\n\t}\n\tif (tb[ETHTOOL_A_BITSET_MASK]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_BITSET_MASK],\n\t\t\t\t    \"mask only allowed in compact bitset\");\n\t\treturn -EINVAL;\n\t}\n\n\tno_mask = tb[ETHTOOL_A_BITSET_NOMASK];\n\tif (no_mask)\n\t\tethnl_bitmap32_clear(bitmap, 0, nbits, mod);\n\n\tnla_for_each_nested(bit_attr, tb[ETHTOOL_A_BITSET_BITS], rem) {\n\t\tbool old_val, new_val;\n\t\tunsigned int idx;\n\n\t\tif (nla_type(bit_attr) != ETHTOOL_A_BITSET_BITS_BIT) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, bit_attr,\n\t\t\t\t\t    \"only ETHTOOL_A_BITSET_BITS_BIT allowed in ETHTOOL_A_BITSET_BITS\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = ethnl_parse_bit(&idx, &new_val, nbits, bit_attr, no_mask,\n\t\t\t\t      names, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\told_val = bitmap[idx / 32] & ((u32)1 << (idx % 32));\n\t\tif (new_val != old_val) {\n\t\t\tif (new_val)\n\t\t\t\tbitmap[idx / 32] |= ((u32)1 << (idx % 32));\n\t\t\telse\n\t\t\t\tbitmap[idx / 32] &= ~((u32)1 << (idx % 32));\n\t\t\t*mod = true;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ethnl_compact_sanity_checks(unsigned int nbits,\n\t\t\t\t       const struct nlattr *nest,\n\t\t\t\t       struct nlattr **tb,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tbool no_mask = tb[ETHTOOL_A_BITSET_NOMASK];\n\tunsigned int attr_nbits, attr_nwords;\n\tconst struct nlattr *test_attr;\n\n\tif (no_mask && tb[ETHTOOL_A_BITSET_MASK]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_BITSET_MASK],\n\t\t\t\t    \"mask not allowed in list bitset\");\n\t\treturn -EINVAL;\n\t}\n\tif (!tb[ETHTOOL_A_BITSET_SIZE]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nest,\n\t\t\t\t    \"missing size in compact bitset\");\n\t\treturn -EINVAL;\n\t}\n\tif (!tb[ETHTOOL_A_BITSET_VALUE]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nest,\n\t\t\t\t    \"missing value in compact bitset\");\n\t\treturn -EINVAL;\n\t}\n\tif (!no_mask && !tb[ETHTOOL_A_BITSET_MASK]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nest,\n\t\t\t\t    \"missing mask in compact nonlist bitset\");\n\t\treturn -EINVAL;\n\t}\n\n\tattr_nbits = nla_get_u32(tb[ETHTOOL_A_BITSET_SIZE]);\n\tattr_nwords = DIV_ROUND_UP(attr_nbits, 32);\n\tif (nla_len(tb[ETHTOOL_A_BITSET_VALUE]) != attr_nwords * sizeof(u32)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_BITSET_VALUE],\n\t\t\t\t    \"bitset value length does not match size\");\n\t\treturn -EINVAL;\n\t}\n\tif (tb[ETHTOOL_A_BITSET_MASK] &&\n\t    nla_len(tb[ETHTOOL_A_BITSET_MASK]) != attr_nwords * sizeof(u32)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_BITSET_MASK],\n\t\t\t\t    \"bitset mask length does not match size\");\n\t\treturn -EINVAL;\n\t}\n\tif (attr_nbits <= nbits)\n\t\treturn 0;\n\n\ttest_attr = no_mask ? tb[ETHTOOL_A_BITSET_VALUE] :\n\t\t\t      tb[ETHTOOL_A_BITSET_MASK];\n\tif (ethnl_bitmap32_not_zero(nla_data(test_attr), nbits, attr_nbits)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, test_attr,\n\t\t\t\t    \"cannot modify bits past kernel bitset size\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nint ethnl_update_bitset32(u32 *bitmap, unsigned int nbits,\n\t\t\t  const struct nlattr *attr, ethnl_string_array_t names,\n\t\t\t  struct netlink_ext_ack *extack, bool *mod)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(bitset_policy)];\n\tunsigned int change_bits;\n\tbool no_mask;\n\tint ret;\n\n\tif (!attr)\n\t\treturn 0;\n\tret = nla_parse_nested(tb, ARRAY_SIZE(bitset_policy) - 1, attr,\n\t\t\t       bitset_policy, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tb[ETHTOOL_A_BITSET_BITS])\n\t\treturn ethnl_update_bitset32_verbose(bitmap, nbits, attr, tb,\n\t\t\t\t\t\t     names, extack, mod);\n\tret = ethnl_compact_sanity_checks(nbits, attr, tb, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tno_mask = tb[ETHTOOL_A_BITSET_NOMASK];\n\tchange_bits = min_t(unsigned int,\n\t\t\t    nla_get_u32(tb[ETHTOOL_A_BITSET_SIZE]), nbits);\n\tethnl_bitmap32_update(bitmap, change_bits,\n\t\t\t      nla_data(tb[ETHTOOL_A_BITSET_VALUE]),\n\t\t\t      no_mask ? NULL :\n\t\t\t\t\tnla_data(tb[ETHTOOL_A_BITSET_MASK]),\n\t\t\t      mod);\n\tif (no_mask && change_bits < nbits)\n\t\tethnl_bitmap32_clear(bitmap, change_bits, nbits, mod);\n\n\treturn 0;\n}\n\n \nint ethnl_parse_bitset(unsigned long *val, unsigned long *mask,\n\t\t       unsigned int nbits, const struct nlattr *attr,\n\t\t       ethnl_string_array_t names,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(bitset_policy)];\n\tconst struct nlattr *bit_attr;\n\tbool no_mask;\n\tint rem;\n\tint ret;\n\n\tif (!attr)\n\t\treturn 0;\n\tret = nla_parse_nested(tb, ARRAY_SIZE(bitset_policy) - 1, attr,\n\t\t\t       bitset_policy, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\tno_mask = tb[ETHTOOL_A_BITSET_NOMASK];\n\n\tif (!tb[ETHTOOL_A_BITSET_BITS]) {\n\t\tunsigned int change_bits;\n\n\t\tret = ethnl_compact_sanity_checks(nbits, attr, tb, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tchange_bits = nla_get_u32(tb[ETHTOOL_A_BITSET_SIZE]);\n\t\tif (change_bits > nbits)\n\t\t\tchange_bits = nbits;\n\t\tbitmap_from_arr32(val, nla_data(tb[ETHTOOL_A_BITSET_VALUE]),\n\t\t\t\t  change_bits);\n\t\tif (change_bits < nbits)\n\t\t\tbitmap_clear(val, change_bits, nbits - change_bits);\n\t\tif (no_mask) {\n\t\t\tbitmap_fill(mask, nbits);\n\t\t} else {\n\t\t\tbitmap_from_arr32(mask,\n\t\t\t\t\t  nla_data(tb[ETHTOOL_A_BITSET_MASK]),\n\t\t\t\t\t  change_bits);\n\t\t\tif (change_bits < nbits)\n\t\t\t\tbitmap_clear(mask, change_bits,\n\t\t\t\t\t     nbits - change_bits);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (tb[ETHTOOL_A_BITSET_VALUE]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_BITSET_VALUE],\n\t\t\t\t    \"value only allowed in compact bitset\");\n\t\treturn -EINVAL;\n\t}\n\tif (tb[ETHTOOL_A_BITSET_MASK]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_BITSET_MASK],\n\t\t\t\t    \"mask only allowed in compact bitset\");\n\t\treturn -EINVAL;\n\t}\n\n\tbitmap_zero(val, nbits);\n\tif (no_mask)\n\t\tbitmap_fill(mask, nbits);\n\telse\n\t\tbitmap_zero(mask, nbits);\n\n\tnla_for_each_nested(bit_attr, tb[ETHTOOL_A_BITSET_BITS], rem) {\n\t\tunsigned int idx;\n\t\tbool bit_val;\n\n\t\tret = ethnl_parse_bit(&idx, &bit_val, nbits, bit_attr, no_mask,\n\t\t\t\t      names, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (bit_val)\n\t\t\t__set_bit(idx, val);\n\t\tif (!no_mask)\n\t\t\t__set_bit(idx, mask);\n\t}\n\n\treturn 0;\n}\n\n#if BITS_PER_LONG == 64 && defined(__BIG_ENDIAN)\n\n \n#define ETHNL_SMALL_BITMAP_BITS 128\n#define ETHNL_SMALL_BITMAP_WORDS DIV_ROUND_UP(ETHNL_SMALL_BITMAP_BITS, 32)\n\nint ethnl_bitset_size(const unsigned long *val, const unsigned long *mask,\n\t\t      unsigned int nbits, ethnl_string_array_t names,\n\t\t      bool compact)\n{\n\tu32 small_mask32[ETHNL_SMALL_BITMAP_WORDS];\n\tu32 small_val32[ETHNL_SMALL_BITMAP_WORDS];\n\tu32 *mask32;\n\tu32 *val32;\n\tint ret;\n\n\tif (nbits > ETHNL_SMALL_BITMAP_BITS) {\n\t\tunsigned int nwords = DIV_ROUND_UP(nbits, 32);\n\n\t\tval32 = kmalloc_array(2 * nwords, sizeof(u32), GFP_KERNEL);\n\t\tif (!val32)\n\t\t\treturn -ENOMEM;\n\t\tmask32 = val32 + nwords;\n\t} else {\n\t\tval32 = small_val32;\n\t\tmask32 = small_mask32;\n\t}\n\n\tbitmap_to_arr32(val32, val, nbits);\n\tif (mask)\n\t\tbitmap_to_arr32(mask32, mask, nbits);\n\telse\n\t\tmask32 = NULL;\n\tret = ethnl_bitset32_size(val32, mask32, nbits, names, compact);\n\n\tif (nbits > ETHNL_SMALL_BITMAP_BITS)\n\t\tkfree(val32);\n\n\treturn ret;\n}\n\nint ethnl_put_bitset(struct sk_buff *skb, int attrtype,\n\t\t     const unsigned long *val, const unsigned long *mask,\n\t\t     unsigned int nbits, ethnl_string_array_t names,\n\t\t     bool compact)\n{\n\tu32 small_mask32[ETHNL_SMALL_BITMAP_WORDS];\n\tu32 small_val32[ETHNL_SMALL_BITMAP_WORDS];\n\tu32 *mask32;\n\tu32 *val32;\n\tint ret;\n\n\tif (nbits > ETHNL_SMALL_BITMAP_BITS) {\n\t\tunsigned int nwords = DIV_ROUND_UP(nbits, 32);\n\n\t\tval32 = kmalloc_array(2 * nwords, sizeof(u32), GFP_KERNEL);\n\t\tif (!val32)\n\t\t\treturn -ENOMEM;\n\t\tmask32 = val32 + nwords;\n\t} else {\n\t\tval32 = small_val32;\n\t\tmask32 = small_mask32;\n\t}\n\n\tbitmap_to_arr32(val32, val, nbits);\n\tif (mask)\n\t\tbitmap_to_arr32(mask32, mask, nbits);\n\telse\n\t\tmask32 = NULL;\n\tret = ethnl_put_bitset32(skb, attrtype, val32, mask32, nbits, names,\n\t\t\t\t compact);\n\n\tif (nbits > ETHNL_SMALL_BITMAP_BITS)\n\t\tkfree(val32);\n\n\treturn ret;\n}\n\nint ethnl_update_bitset(unsigned long *bitmap, unsigned int nbits,\n\t\t\tconst struct nlattr *attr, ethnl_string_array_t names,\n\t\t\tstruct netlink_ext_ack *extack, bool *mod)\n{\n\tu32 small_bitmap32[ETHNL_SMALL_BITMAP_WORDS];\n\tu32 *bitmap32 = small_bitmap32;\n\tbool u32_mod = false;\n\tint ret;\n\n\tif (nbits > ETHNL_SMALL_BITMAP_BITS) {\n\t\tunsigned int dst_words = DIV_ROUND_UP(nbits, 32);\n\n\t\tbitmap32 = kmalloc_array(dst_words, sizeof(u32), GFP_KERNEL);\n\t\tif (!bitmap32)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tbitmap_to_arr32(bitmap32, bitmap, nbits);\n\tret = ethnl_update_bitset32(bitmap32, nbits, attr, names, extack,\n\t\t\t\t    &u32_mod);\n\tif (u32_mod) {\n\t\tbitmap_from_arr32(bitmap, bitmap32, nbits);\n\t\t*mod = true;\n\t}\n\n\tif (nbits > ETHNL_SMALL_BITMAP_BITS)\n\t\tkfree(bitmap32);\n\n\treturn ret;\n}\n\n#else\n\n \n\nint ethnl_bitset_size(const unsigned long *val, const unsigned long *mask,\n\t\t      unsigned int nbits, ethnl_string_array_t names,\n\t\t      bool compact)\n{\n\treturn ethnl_bitset32_size((const u32 *)val, (const u32 *)mask, nbits,\n\t\t\t\t   names, compact);\n}\n\nint ethnl_put_bitset(struct sk_buff *skb, int attrtype,\n\t\t     const unsigned long *val, const unsigned long *mask,\n\t\t     unsigned int nbits, ethnl_string_array_t names,\n\t\t     bool compact)\n{\n\treturn ethnl_put_bitset32(skb, attrtype, (const u32 *)val,\n\t\t\t\t  (const u32 *)mask, nbits, names, compact);\n}\n\nint ethnl_update_bitset(unsigned long *bitmap, unsigned int nbits,\n\t\t\tconst struct nlattr *attr, ethnl_string_array_t names,\n\t\t\tstruct netlink_ext_ack *extack, bool *mod)\n{\n\treturn ethnl_update_bitset32((u32 *)bitmap, nbits, attr, names, extack,\n\t\t\t\t     mod);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}