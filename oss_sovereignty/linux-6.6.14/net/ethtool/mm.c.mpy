{
  "module_name": "mm.c",
  "hash_id": "42fd24de1dc50b8d88a6ba9f0850add659844be71975741f28c175b3b4786266",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/mm.c",
  "human_readable_source": "\n \n#include \"common.h\"\n#include \"netlink.h\"\n\nstruct mm_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstruct mm_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tstruct ethtool_mm_state\t\tstate;\n\tstruct ethtool_mm_stats\t\tstats;\n};\n\n#define MM_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct mm_reply_data, base)\n\n#define ETHTOOL_MM_STAT_CNT \\\n\t(__ETHTOOL_A_MM_STAT_CNT - (ETHTOOL_A_MM_STAT_PAD + 1))\n\nconst struct nla_policy ethnl_mm_get_policy[ETHTOOL_A_MM_HEADER + 1] = {\n\t[ETHTOOL_A_MM_HEADER] = NLA_POLICY_NESTED(ethnl_header_policy_stats),\n};\n\nstatic int mm_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t   struct ethnl_reply_data *reply_base,\n\t\t\t   const struct genl_info *info)\n{\n\tstruct mm_reply_data *data = MM_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tconst struct ethtool_ops *ops;\n\tint ret;\n\n\tops = dev->ethtool_ops;\n\n\tif (!ops->get_mm)\n\t\treturn -EOPNOTSUPP;\n\n\tethtool_stats_init((u64 *)&data->stats,\n\t\t\t   sizeof(data->stats) / sizeof(u64));\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ops->get_mm(dev, &data->state);\n\tif (ret)\n\t\tgoto out_complete;\n\n\tif (ops->get_mm_stats && (req_base->flags & ETHTOOL_FLAG_STATS))\n\t\tops->get_mm_stats(dev, &data->stats);\n\nout_complete:\n\tethnl_ops_complete(dev);\n\n\treturn ret;\n}\n\nstatic int mm_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t const struct ethnl_reply_data *reply_base)\n{\n\tint len = 0;\n\n\tlen += nla_total_size(sizeof(u8));  \n\tlen += nla_total_size(sizeof(u8));  \n\tlen += nla_total_size(sizeof(u8));  \n\tlen += nla_total_size(sizeof(u8));  \n\tlen += nla_total_size(sizeof(u8));  \n\tlen += nla_total_size(sizeof(u32));  \n\tlen += nla_total_size(sizeof(u32));  \n\tlen += nla_total_size(sizeof(u32));  \n\tlen += nla_total_size(sizeof(u32));  \n\n\tif (req_base->flags & ETHTOOL_FLAG_STATS)\n\t\tlen += nla_total_size(0) +  \n\t\t       nla_total_size_64bit(sizeof(u64)) * ETHTOOL_MM_STAT_CNT;\n\n\treturn len;\n}\n\nstatic int mm_put_stat(struct sk_buff *skb, u64 val, u16 attrtype)\n{\n\tif (val == ETHTOOL_STAT_NOT_SET)\n\t\treturn 0;\n\tif (nla_put_u64_64bit(skb, attrtype, val, ETHTOOL_A_MM_STAT_PAD))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int mm_put_stats(struct sk_buff *skb,\n\t\t\tconst struct ethtool_mm_stats *stats)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start(skb, ETHTOOL_A_MM_STATS);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (mm_put_stat(skb, stats->MACMergeFrameAssErrorCount,\n\t\t\tETHTOOL_A_MM_STAT_REASSEMBLY_ERRORS) ||\n\t    mm_put_stat(skb, stats->MACMergeFrameSmdErrorCount,\n\t\t\tETHTOOL_A_MM_STAT_SMD_ERRORS) ||\n\t    mm_put_stat(skb, stats->MACMergeFrameAssOkCount,\n\t\t\tETHTOOL_A_MM_STAT_REASSEMBLY_OK) ||\n\t    mm_put_stat(skb, stats->MACMergeFragCountRx,\n\t\t\tETHTOOL_A_MM_STAT_RX_FRAG_COUNT) ||\n\t    mm_put_stat(skb, stats->MACMergeFragCountTx,\n\t\t\tETHTOOL_A_MM_STAT_TX_FRAG_COUNT) ||\n\t    mm_put_stat(skb, stats->MACMergeHoldCount,\n\t\t\tETHTOOL_A_MM_STAT_HOLD_COUNT))\n\t\tgoto err_cancel;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nerr_cancel:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int mm_fill_reply(struct sk_buff *skb,\n\t\t\t const struct ethnl_req_info *req_base,\n\t\t\t const struct ethnl_reply_data *reply_base)\n{\n\tconst struct mm_reply_data *data = MM_REPDATA(reply_base);\n\tconst struct ethtool_mm_state *state = &data->state;\n\n\tif (nla_put_u8(skb, ETHTOOL_A_MM_TX_ENABLED, state->tx_enabled) ||\n\t    nla_put_u8(skb, ETHTOOL_A_MM_TX_ACTIVE, state->tx_active) ||\n\t    nla_put_u8(skb, ETHTOOL_A_MM_PMAC_ENABLED, state->pmac_enabled) ||\n\t    nla_put_u8(skb, ETHTOOL_A_MM_VERIFY_ENABLED, state->verify_enabled) ||\n\t    nla_put_u8(skb, ETHTOOL_A_MM_VERIFY_STATUS, state->verify_status) ||\n\t    nla_put_u32(skb, ETHTOOL_A_MM_VERIFY_TIME, state->verify_time) ||\n\t    nla_put_u32(skb, ETHTOOL_A_MM_MAX_VERIFY_TIME, state->max_verify_time) ||\n\t    nla_put_u32(skb, ETHTOOL_A_MM_TX_MIN_FRAG_SIZE, state->tx_min_frag_size) ||\n\t    nla_put_u32(skb, ETHTOOL_A_MM_RX_MIN_FRAG_SIZE, state->rx_min_frag_size))\n\t\treturn -EMSGSIZE;\n\n\tif (req_base->flags & ETHTOOL_FLAG_STATS &&\n\t    mm_put_stats(skb, &data->stats))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nconst struct nla_policy ethnl_mm_set_policy[ETHTOOL_A_MM_MAX + 1] = {\n\t[ETHTOOL_A_MM_HEADER]\t\t= NLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_MM_VERIFY_ENABLED]\t= NLA_POLICY_MAX(NLA_U8, 1),\n\t[ETHTOOL_A_MM_VERIFY_TIME]\t= NLA_POLICY_RANGE(NLA_U32, 1, 128),\n\t[ETHTOOL_A_MM_TX_ENABLED]\t= NLA_POLICY_MAX(NLA_U8, 1),\n\t[ETHTOOL_A_MM_PMAC_ENABLED]\t= NLA_POLICY_MAX(NLA_U8, 1),\n\t[ETHTOOL_A_MM_TX_MIN_FRAG_SIZE]\t= NLA_POLICY_RANGE(NLA_U32, 60, 252),\n};\n\nstatic void mm_state_to_cfg(const struct ethtool_mm_state *state,\n\t\t\t    struct ethtool_mm_cfg *cfg)\n{\n\t \n\tcfg->verify_enabled = state->verify_enabled;\n\tcfg->verify_time = state->verify_time;\n\tcfg->tx_enabled = state->tx_enabled;\n\tcfg->pmac_enabled = state->pmac_enabled;\n\tcfg->tx_min_frag_size = state->tx_min_frag_size;\n}\n\nstatic int\nethnl_set_mm_validate(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tconst struct ethtool_ops *ops = req_info->dev->ethtool_ops;\n\n\treturn ops->get_mm && ops->set_mm ? 1 : -EOPNOTSUPP;\n}\n\nstatic int ethnl_set_mm(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct net_device *dev = req_info->dev;\n\tstruct ethtool_mm_state state = {};\n\tstruct nlattr **tb = info->attrs;\n\tstruct ethtool_mm_cfg cfg = {};\n\tbool mod = false;\n\tint ret;\n\n\tret = dev->ethtool_ops->get_mm(dev, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tmm_state_to_cfg(&state, &cfg);\n\n\tethnl_update_bool(&cfg.verify_enabled, tb[ETHTOOL_A_MM_VERIFY_ENABLED],\n\t\t\t  &mod);\n\tethnl_update_u32(&cfg.verify_time, tb[ETHTOOL_A_MM_VERIFY_TIME], &mod);\n\tethnl_update_bool(&cfg.tx_enabled, tb[ETHTOOL_A_MM_TX_ENABLED], &mod);\n\tethnl_update_bool(&cfg.pmac_enabled, tb[ETHTOOL_A_MM_PMAC_ENABLED],\n\t\t\t  &mod);\n\tethnl_update_u32(&cfg.tx_min_frag_size,\n\t\t\t tb[ETHTOOL_A_MM_TX_MIN_FRAG_SIZE], &mod);\n\n\tif (!mod)\n\t\treturn 0;\n\n\tif (cfg.verify_time > state.max_verify_time) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_MM_VERIFY_TIME],\n\t\t\t\t    \"verifyTime exceeds device maximum\");\n\t\treturn -ERANGE;\n\t}\n\n\tif (cfg.verify_enabled && !cfg.tx_enabled) {\n\t\tNL_SET_ERR_MSG(extack, \"Verification requires TX enabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg.tx_enabled && !cfg.pmac_enabled) {\n\t\tNL_SET_ERR_MSG(extack, \"TX enabled requires pMAC enabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = dev->ethtool_ops->set_mm(dev, &cfg, extack);\n\treturn ret < 0 ? ret : 1;\n}\n\nconst struct ethnl_request_ops ethnl_mm_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_MM_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_MM_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_MM_HEADER,\n\t.req_info_size\t\t= sizeof(struct mm_req_info),\n\t.reply_data_size\t= sizeof(struct mm_reply_data),\n\n\t.prepare_data\t\t= mm_prepare_data,\n\t.reply_size\t\t= mm_reply_size,\n\t.fill_reply\t\t= mm_fill_reply,\n\n\t.set_validate\t\t= ethnl_set_mm_validate,\n\t.set\t\t\t= ethnl_set_mm,\n\t.set_ntf_cmd\t\t= ETHTOOL_MSG_MM_NTF,\n};\n\n \nbool __ethtool_dev_mm_supported(struct net_device *dev)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct ethtool_mm_state state = {};\n\tint ret = -EOPNOTSUPP;\n\n\tif (ops && ops->get_mm)\n\t\tret = ops->get_mm(dev, &state);\n\n\treturn !ret;\n}\n\nbool ethtool_dev_mm_supported(struct net_device *dev)\n{\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tbool supported;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (!ops)\n\t\treturn false;\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn false;\n\n\tsupported = __ethtool_dev_mm_supported(dev);\n\n\tethnl_ops_complete(dev);\n\n\treturn supported;\n}\nEXPORT_SYMBOL_GPL(ethtool_dev_mm_supported);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}