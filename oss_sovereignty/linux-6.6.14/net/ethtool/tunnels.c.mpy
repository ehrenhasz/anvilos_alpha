{
  "module_name": "tunnels.c",
  "hash_id": "59d08045d4fbb5f08ed50b8aee5634da427ce046ae513668bdeba3430cd238a2",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/tunnels.c",
  "human_readable_source": "\n\n#include <linux/ethtool_netlink.h>\n#include <net/udp_tunnel.h>\n#include <net/vxlan.h>\n\n#include \"bitset.h\"\n#include \"common.h\"\n#include \"netlink.h\"\n\nconst struct nla_policy ethnl_tunnel_info_get_policy[] = {\n\t[ETHTOOL_A_TUNNEL_INFO_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic_assert(ETHTOOL_UDP_TUNNEL_TYPE_VXLAN == ilog2(UDP_TUNNEL_TYPE_VXLAN));\nstatic_assert(ETHTOOL_UDP_TUNNEL_TYPE_GENEVE == ilog2(UDP_TUNNEL_TYPE_GENEVE));\nstatic_assert(ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE ==\n\t      ilog2(UDP_TUNNEL_TYPE_VXLAN_GPE));\n\nstatic ssize_t ethnl_udp_table_reply_size(unsigned int types, bool compact)\n{\n\tssize_t size;\n\n\tsize = ethnl_bitset32_size(&types, NULL, __ETHTOOL_UDP_TUNNEL_TYPE_CNT,\n\t\t\t\t   udp_tunnel_type_names, compact);\n\tif (size < 0)\n\t\treturn size;\n\n\treturn size +\n\t\tnla_total_size(0) +  \n\t\tnla_total_size(sizeof(u32));  \n}\n\nstatic ssize_t\nethnl_tunnel_info_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tconst struct udp_tunnel_nic_info *info;\n\tunsigned int i;\n\tssize_t ret;\n\tsize_t size;\n\n\tinfo = req_base->dev->udp_tunnel_nic_info;\n\tif (!info) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"device does not report tunnel offload info\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tsize =\tnla_total_size(0);  \n\n\tfor (i = 0; i < UDP_TUNNEL_NIC_MAX_TABLES; i++) {\n\t\tif (!info->tables[i].n_entries)\n\t\t\tbreak;\n\n\t\tret = ethnl_udp_table_reply_size(info->tables[i].tunnel_types,\n\t\t\t\t\t\t compact);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize += ret;\n\n\t\tsize += udp_tunnel_nic_dump_size(req_base->dev, i);\n\t}\n\n\tif (info->flags & UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN) {\n\t\tret = ethnl_udp_table_reply_size(0, compact);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize += ret;\n\n\t\tsize += nla_total_size(0) +\t\t  \n\t\t\tnla_total_size(sizeof(__be16)) +  \n\t\t\tnla_total_size(sizeof(u32));\t  \n\t}\n\n\treturn size;\n}\n\nstatic int\nethnl_tunnel_info_fill_reply(const struct ethnl_req_info *req_base,\n\t\t\t     struct sk_buff *skb)\n{\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tconst struct udp_tunnel_nic_info *info;\n\tstruct nlattr *ports, *table, *entry;\n\tunsigned int i;\n\n\tinfo = req_base->dev->udp_tunnel_nic_info;\n\tif (!info)\n\t\treturn -EOPNOTSUPP;\n\n\tports = nla_nest_start(skb, ETHTOOL_A_TUNNEL_INFO_UDP_PORTS);\n\tif (!ports)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < UDP_TUNNEL_NIC_MAX_TABLES; i++) {\n\t\tif (!info->tables[i].n_entries)\n\t\t\tbreak;\n\n\t\ttable = nla_nest_start(skb, ETHTOOL_A_TUNNEL_UDP_TABLE);\n\t\tif (!table)\n\t\t\tgoto err_cancel_ports;\n\n\t\tif (nla_put_u32(skb, ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE,\n\t\t\t\tinfo->tables[i].n_entries))\n\t\t\tgoto err_cancel_table;\n\n\t\tif (ethnl_put_bitset32(skb, ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES,\n\t\t\t\t       &info->tables[i].tunnel_types, NULL,\n\t\t\t\t       __ETHTOOL_UDP_TUNNEL_TYPE_CNT,\n\t\t\t\t       udp_tunnel_type_names, compact))\n\t\t\tgoto err_cancel_table;\n\n\t\tif (udp_tunnel_nic_dump_write(req_base->dev, i, skb))\n\t\t\tgoto err_cancel_table;\n\n\t\tnla_nest_end(skb, table);\n\t}\n\n\tif (info->flags & UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN) {\n\t\tu32 zero = 0;\n\n\t\ttable = nla_nest_start(skb, ETHTOOL_A_TUNNEL_UDP_TABLE);\n\t\tif (!table)\n\t\t\tgoto err_cancel_ports;\n\n\t\tif (nla_put_u32(skb, ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE, 1))\n\t\t\tgoto err_cancel_table;\n\n\t\tif (ethnl_put_bitset32(skb, ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES,\n\t\t\t\t       &zero, NULL,\n\t\t\t\t       __ETHTOOL_UDP_TUNNEL_TYPE_CNT,\n\t\t\t\t       udp_tunnel_type_names, compact))\n\t\t\tgoto err_cancel_table;\n\n\t\tentry = nla_nest_start(skb, ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY);\n\t\tif (!entry)\n\t\t\tgoto err_cancel_entry;\n\n\t\tif (nla_put_be16(skb, ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT,\n\t\t\t\t htons(IANA_VXLAN_UDP_PORT)) ||\n\t\t    nla_put_u32(skb, ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE,\n\t\t\t\tilog2(UDP_TUNNEL_TYPE_VXLAN)))\n\t\t\tgoto err_cancel_entry;\n\n\t\tnla_nest_end(skb, entry);\n\t\tnla_nest_end(skb, table);\n\t}\n\n\tnla_nest_end(skb, ports);\n\n\treturn 0;\n\nerr_cancel_entry:\n\tnla_nest_cancel(skb, entry);\nerr_cancel_table:\n\tnla_nest_cancel(skb, table);\nerr_cancel_ports:\n\tnla_nest_cancel(skb, ports);\n\treturn -EMSGSIZE;\n}\n\nint ethnl_tunnel_info_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ethnl_req_info req_info = {};\n\tstruct nlattr **tb = info->attrs;\n\tstruct sk_buff *rskb;\n\tvoid *reply_payload;\n\tint reply_len;\n\tint ret;\n\n\tret = ethnl_parse_header_dev_get(&req_info,\n\t\t\t\t\t tb[ETHTOOL_A_TUNNEL_INFO_HEADER],\n\t\t\t\t\t genl_info_net(info), info->extack,\n\t\t\t\t\t true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trtnl_lock();\n\tret = ethnl_tunnel_info_reply_size(&req_info, info->extack);\n\tif (ret < 0)\n\t\tgoto err_unlock_rtnl;\n\treply_len = ret + ethnl_reply_header_size();\n\n\trskb = ethnl_reply_init(reply_len, req_info.dev,\n\t\t\t\tETHTOOL_MSG_TUNNEL_INFO_GET_REPLY,\n\t\t\t\tETHTOOL_A_TUNNEL_INFO_HEADER,\n\t\t\t\tinfo, &reply_payload);\n\tif (!rskb) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock_rtnl;\n\t}\n\n\tret = ethnl_tunnel_info_fill_reply(&req_info, rskb);\n\tif (ret)\n\t\tgoto err_free_msg;\n\trtnl_unlock();\n\tethnl_parse_header_dev_put(&req_info);\n\tgenlmsg_end(rskb, reply_payload);\n\n\treturn genlmsg_reply(rskb, info);\n\nerr_free_msg:\n\tnlmsg_free(rskb);\nerr_unlock_rtnl:\n\trtnl_unlock();\n\tethnl_parse_header_dev_put(&req_info);\n\treturn ret;\n}\n\nstruct ethnl_tunnel_info_dump_ctx {\n\tstruct ethnl_req_info\treq_info;\n\tunsigned long\t\tifindex;\n};\n\nint ethnl_tunnel_info_start(struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct ethnl_tunnel_info_dump_ctx *ctx = (void *)cb->ctx;\n\tstruct nlattr **tb = info->info.attrs;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(*ctx) > sizeof(cb->ctx));\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\n\tret = ethnl_parse_header_dev_get(&ctx->req_info,\n\t\t\t\t\t tb[ETHTOOL_A_TUNNEL_INFO_HEADER],\n\t\t\t\t\t sock_net(cb->skb->sk), cb->extack,\n\t\t\t\t\t false);\n\tif (ctx->req_info.dev) {\n\t\tethnl_parse_header_dev_put(&ctx->req_info);\n\t\tctx->req_info.dev = NULL;\n\t}\n\n\treturn ret;\n}\n\nint ethnl_tunnel_info_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct ethnl_tunnel_info_dump_ctx *ctx = (void *)cb->ctx;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tint ret = 0;\n\tvoid *ehdr;\n\n\trtnl_lock();\n\tfor_each_netdev_dump(net, dev, ctx->ifindex) {\n\t\tehdr = ethnl_dump_put(skb, cb,\n\t\t\t\t      ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY);\n\t\tif (!ehdr) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ethnl_fill_reply_header(skb, dev,\n\t\t\t\t\t      ETHTOOL_A_TUNNEL_INFO_HEADER);\n\t\tif (ret < 0) {\n\t\t\tgenlmsg_cancel(skb, ehdr);\n\t\t\tbreak;\n\t\t}\n\n\t\tctx->req_info.dev = dev;\n\t\tret = ethnl_tunnel_info_fill_reply(&ctx->req_info, skb);\n\t\tctx->req_info.dev = NULL;\n\t\tif (ret < 0) {\n\t\t\tgenlmsg_cancel(skb, ehdr);\n\t\t\tif (ret == -EOPNOTSUPP)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tgenlmsg_end(skb, ehdr);\n\t}\n\trtnl_unlock();\n\n\tif (ret == -EMSGSIZE && skb->len)\n\t\treturn skb->len;\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}