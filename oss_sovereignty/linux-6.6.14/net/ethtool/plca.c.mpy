{
  "module_name": "plca.c",
  "hash_id": "09c5155ce2878232df188a71f456060358a49aefbd36ae964d13fa6c1fcbfd2c",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/plca.c",
  "human_readable_source": "\n\n#include <linux/phy.h>\n#include <linux/ethtool_netlink.h>\n\n#include \"netlink.h\"\n#include \"common.h\"\n\nstruct plca_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstruct plca_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tstruct phy_plca_cfg\t\tplca_cfg;\n\tstruct phy_plca_status\t\tplca_st;\n};\n\n\n\n#define PLCA_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct plca_reply_data, base)\n\n\n\nconst struct nla_policy ethnl_plca_get_cfg_policy[] = {\n\t[ETHTOOL_A_PLCA_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic void plca_update_sint(int *dst, struct nlattr **tb, u32 attrid,\n\t\t\t     bool *mod)\n{\n\tconst struct nlattr *attr = tb[attrid];\n\n\tif (!attr ||\n\t    WARN_ON_ONCE(attrid >= ARRAY_SIZE(ethnl_plca_set_cfg_policy)))\n\t\treturn;\n\n\tswitch (ethnl_plca_set_cfg_policy[attrid].type) {\n\tcase NLA_U8:\n\t\t*dst = nla_get_u8(attr);\n\t\tbreak;\n\tcase NLA_U32:\n\t\t*dst = nla_get_u32(attr);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t*mod = true;\n}\n\nstatic int plca_get_cfg_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t\t     struct ethnl_reply_data *reply_base,\n\t\t\t\t     const struct genl_info *info)\n{\n\tstruct plca_reply_data *data = PLCA_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tconst struct ethtool_phy_ops *ops;\n\tint ret;\n\n\t\n\tif (!dev->phydev) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t\n\tops = ethtool_phy_ops;\n\tif (!ops || !ops->get_plca_cfg) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmemset(&data->plca_cfg, 0xff,\n\t       sizeof_field(struct plca_reply_data, plca_cfg));\n\n\tret = ops->get_plca_cfg(dev->phydev, &data->plca_cfg);\n\tethnl_ops_complete(dev);\n\nout:\n\treturn ret;\n}\n\nstatic int plca_get_cfg_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t\t   const struct ethnl_reply_data *reply_base)\n{\n\treturn nla_total_size(sizeof(u16)) +\t \n\t       nla_total_size(sizeof(u8)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32));\t \n}\n\nstatic int plca_get_cfg_fill_reply(struct sk_buff *skb,\n\t\t\t\t   const struct ethnl_req_info *req_base,\n\t\t\t\t   const struct ethnl_reply_data *reply_base)\n{\n\tconst struct plca_reply_data *data = PLCA_REPDATA(reply_base);\n\tconst struct phy_plca_cfg *plca = &data->plca_cfg;\n\n\tif ((plca->version >= 0 &&\n\t     nla_put_u16(skb, ETHTOOL_A_PLCA_VERSION, plca->version)) ||\n\t    (plca->enabled >= 0 &&\n\t     nla_put_u8(skb, ETHTOOL_A_PLCA_ENABLED, !!plca->enabled)) ||\n\t    (plca->node_id >= 0 &&\n\t     nla_put_u32(skb, ETHTOOL_A_PLCA_NODE_ID, plca->node_id)) ||\n\t    (plca->node_cnt >= 0 &&\n\t     nla_put_u32(skb, ETHTOOL_A_PLCA_NODE_CNT, plca->node_cnt)) ||\n\t    (plca->to_tmr >= 0 &&\n\t     nla_put_u32(skb, ETHTOOL_A_PLCA_TO_TMR, plca->to_tmr)) ||\n\t    (plca->burst_cnt >= 0 &&\n\t     nla_put_u32(skb, ETHTOOL_A_PLCA_BURST_CNT, plca->burst_cnt)) ||\n\t    (plca->burst_tmr >= 0 &&\n\t     nla_put_u32(skb, ETHTOOL_A_PLCA_BURST_TMR, plca->burst_tmr)))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n};\n\n\n\nconst struct nla_policy ethnl_plca_set_cfg_policy[] = {\n\t[ETHTOOL_A_PLCA_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_PLCA_ENABLED]\t= NLA_POLICY_MAX(NLA_U8, 1),\n\t[ETHTOOL_A_PLCA_NODE_ID]\t= NLA_POLICY_MAX(NLA_U32, 255),\n\t[ETHTOOL_A_PLCA_NODE_CNT]\t= NLA_POLICY_RANGE(NLA_U32, 1, 255),\n\t[ETHTOOL_A_PLCA_TO_TMR]\t\t= NLA_POLICY_MAX(NLA_U32, 255),\n\t[ETHTOOL_A_PLCA_BURST_CNT]\t= NLA_POLICY_MAX(NLA_U32, 255),\n\t[ETHTOOL_A_PLCA_BURST_TMR]\t= NLA_POLICY_MAX(NLA_U32, 255),\n};\n\nstatic int\nethnl_set_plca(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tstruct net_device *dev = req_info->dev;\n\tconst struct ethtool_phy_ops *ops;\n\tstruct nlattr **tb = info->attrs;\n\tstruct phy_plca_cfg plca_cfg;\n\tbool mod = false;\n\tint ret;\n\n\t\n\tif (!dev->phydev)\n\t\treturn -EOPNOTSUPP;\n\n\tops = ethtool_phy_ops;\n\tif (!ops || !ops->set_plca_cfg)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&plca_cfg, 0xff, sizeof(plca_cfg));\n\tplca_update_sint(&plca_cfg.enabled, tb, ETHTOOL_A_PLCA_ENABLED, &mod);\n\tplca_update_sint(&plca_cfg.node_id, tb, ETHTOOL_A_PLCA_NODE_ID, &mod);\n\tplca_update_sint(&plca_cfg.node_cnt, tb, ETHTOOL_A_PLCA_NODE_CNT, &mod);\n\tplca_update_sint(&plca_cfg.to_tmr, tb, ETHTOOL_A_PLCA_TO_TMR, &mod);\n\tplca_update_sint(&plca_cfg.burst_cnt, tb, ETHTOOL_A_PLCA_BURST_CNT,\n\t\t\t &mod);\n\tplca_update_sint(&plca_cfg.burst_tmr, tb, ETHTOOL_A_PLCA_BURST_TMR,\n\t\t\t &mod);\n\tif (!mod)\n\t\treturn 0;\n\n\tret = ops->set_plca_cfg(dev->phydev, &plca_cfg, info->extack);\n\treturn ret < 0 ? ret : 1;\n}\n\nconst struct ethnl_request_ops ethnl_plca_cfg_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_PLCA_GET_CFG,\n\t.reply_cmd\t\t= ETHTOOL_MSG_PLCA_GET_CFG_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_PLCA_HEADER,\n\t.req_info_size\t\t= sizeof(struct plca_req_info),\n\t.reply_data_size\t= sizeof(struct plca_reply_data),\n\n\t.prepare_data\t\t= plca_get_cfg_prepare_data,\n\t.reply_size\t\t= plca_get_cfg_reply_size,\n\t.fill_reply\t\t= plca_get_cfg_fill_reply,\n\n\t.set\t\t\t= ethnl_set_plca,\n\t.set_ntf_cmd\t\t= ETHTOOL_MSG_PLCA_NTF,\n};\n\n\n\nconst struct nla_policy ethnl_plca_get_status_policy[] = {\n\t[ETHTOOL_A_PLCA_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic int plca_get_status_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t\t\tstruct ethnl_reply_data *reply_base,\n\t\t\t\t\tconst struct genl_info *info)\n{\n\tstruct plca_reply_data *data = PLCA_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tconst struct ethtool_phy_ops *ops;\n\tint ret;\n\n\t\n\tif (!dev->phydev) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t\n\tops = ethtool_phy_ops;\n\tif (!ops || !ops->get_plca_status) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmemset(&data->plca_st, 0xff,\n\t       sizeof_field(struct plca_reply_data, plca_st));\n\n\tret = ops->get_plca_status(dev->phydev, &data->plca_st);\n\tethnl_ops_complete(dev);\nout:\n\treturn ret;\n}\n\nstatic int plca_get_status_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t\t      const struct ethnl_reply_data *reply_base)\n{\n\treturn nla_total_size(sizeof(u8));\t \n}\n\nstatic int plca_get_status_fill_reply(struct sk_buff *skb,\n\t\t\t\t      const struct ethnl_req_info *req_base,\n\t\t\t\t      const struct ethnl_reply_data *reply_base)\n{\n\tconst struct plca_reply_data *data = PLCA_REPDATA(reply_base);\n\tconst u8 status = data->plca_st.pst;\n\n\tif (nla_put_u8(skb, ETHTOOL_A_PLCA_STATUS, !!status))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n};\n\nconst struct ethnl_request_ops ethnl_plca_status_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_PLCA_GET_STATUS,\n\t.reply_cmd\t\t= ETHTOOL_MSG_PLCA_GET_STATUS_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_PLCA_HEADER,\n\t.req_info_size\t\t= sizeof(struct plca_req_info),\n\t.reply_data_size\t= sizeof(struct plca_reply_data),\n\n\t.prepare_data\t\t= plca_get_status_prepare_data,\n\t.reply_size\t\t= plca_get_status_reply_size,\n\t.fill_reply\t\t= plca_get_status_fill_reply,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}