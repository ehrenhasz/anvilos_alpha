{
  "module_name": "cabletest.c",
  "hash_id": "fbc4d2b802b2d2a470ca40fd185a514030414179b5e59bc529cbd46d92b2b7b9",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/cabletest.c",
  "human_readable_source": "\n\n#include <linux/phy.h>\n#include <linux/ethtool_netlink.h>\n#include \"netlink.h\"\n#include \"common.h\"\n\n \n#define MAX_CABLE_LENGTH_CM (150 * 100)\n\nconst struct nla_policy ethnl_cable_test_act_policy[] = {\n\t[ETHTOOL_A_CABLE_TEST_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic int ethnl_cable_test_started(struct phy_device *phydev, u8 cmd)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tvoid *ehdr;\n\n\tskb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto out;\n\n\tehdr = ethnl_bcastmsg_put(skb, cmd);\n\tif (!ehdr) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\terr = ethnl_fill_reply_header(skb, phydev->attached_dev,\n\t\t\t\t      ETHTOOL_A_CABLE_TEST_NTF_HEADER);\n\tif (err)\n\t\tgoto out;\n\n\terr = nla_put_u8(skb, ETHTOOL_A_CABLE_TEST_NTF_STATUS,\n\t\t\t ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED);\n\tif (err)\n\t\tgoto out;\n\n\tgenlmsg_end(skb, ehdr);\n\n\treturn ethnl_multicast(skb, phydev->attached_dev);\n\nout:\n\tnlmsg_free(skb);\n\tphydev_err(phydev, \"%s: Error %pe\\n\", __func__, ERR_PTR(err));\n\n\treturn err;\n}\n\nint ethnl_act_cable_test(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ethnl_req_info req_info = {};\n\tconst struct ethtool_phy_ops *ops;\n\tstruct nlattr **tb = info->attrs;\n\tstruct net_device *dev;\n\tint ret;\n\n\tret = ethnl_parse_header_dev_get(&req_info,\n\t\t\t\t\t tb[ETHTOOL_A_CABLE_TEST_HEADER],\n\t\t\t\t\t genl_info_net(info), info->extack,\n\t\t\t\t\t true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev = req_info.dev;\n\tif (!dev->phydev) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_dev_put;\n\t}\n\n\trtnl_lock();\n\tops = ethtool_phy_ops;\n\tif (!ops || !ops->start_cable_test) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_rtnl;\n\t}\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\tgoto out_rtnl;\n\n\tret = ops->start_cable_test(dev->phydev, info->extack);\n\n\tethnl_ops_complete(dev);\n\n\tif (!ret)\n\t\tethnl_cable_test_started(dev->phydev,\n\t\t\t\t\t ETHTOOL_MSG_CABLE_TEST_NTF);\n\nout_rtnl:\n\trtnl_unlock();\nout_dev_put:\n\tethnl_parse_header_dev_put(&req_info);\n\treturn ret;\n}\n\nint ethnl_cable_test_alloc(struct phy_device *phydev, u8 cmd)\n{\n\tint err = -ENOMEM;\n\n\t \n\tphydev->skb = genlmsg_new(SZ_16K, GFP_KERNEL);\n\tif (!phydev->skb)\n\t\tgoto out;\n\n\tphydev->ehdr = ethnl_bcastmsg_put(phydev->skb, cmd);\n\tif (!phydev->ehdr) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\terr = ethnl_fill_reply_header(phydev->skb, phydev->attached_dev,\n\t\t\t\t      ETHTOOL_A_CABLE_TEST_NTF_HEADER);\n\tif (err)\n\t\tgoto out;\n\n\terr = nla_put_u8(phydev->skb, ETHTOOL_A_CABLE_TEST_NTF_STATUS,\n\t\t\t ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED);\n\tif (err)\n\t\tgoto out;\n\n\tphydev->nest = nla_nest_start(phydev->skb,\n\t\t\t\t      ETHTOOL_A_CABLE_TEST_NTF_NEST);\n\tif (!phydev->nest) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tnlmsg_free(phydev->skb);\n\tphydev->skb = NULL;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ethnl_cable_test_alloc);\n\nvoid ethnl_cable_test_free(struct phy_device *phydev)\n{\n\tnlmsg_free(phydev->skb);\n\tphydev->skb = NULL;\n}\nEXPORT_SYMBOL_GPL(ethnl_cable_test_free);\n\nvoid ethnl_cable_test_finished(struct phy_device *phydev)\n{\n\tnla_nest_end(phydev->skb, phydev->nest);\n\n\tgenlmsg_end(phydev->skb, phydev->ehdr);\n\n\tethnl_multicast(phydev->skb, phydev->attached_dev);\n}\nEXPORT_SYMBOL_GPL(ethnl_cable_test_finished);\n\nint ethnl_cable_test_result(struct phy_device *phydev, u8 pair, u8 result)\n{\n\tstruct nlattr *nest;\n\tint ret = -EMSGSIZE;\n\n\tnest = nla_nest_start(phydev->skb, ETHTOOL_A_CABLE_NEST_RESULT);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(phydev->skb, ETHTOOL_A_CABLE_RESULT_PAIR, pair))\n\t\tgoto err;\n\tif (nla_put_u8(phydev->skb, ETHTOOL_A_CABLE_RESULT_CODE, result))\n\t\tgoto err;\n\n\tnla_nest_end(phydev->skb, nest);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(phydev->skb, nest);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ethnl_cable_test_result);\n\nint ethnl_cable_test_fault_length(struct phy_device *phydev, u8 pair, u32 cm)\n{\n\tstruct nlattr *nest;\n\tint ret = -EMSGSIZE;\n\n\tnest = nla_nest_start(phydev->skb,\n\t\t\t      ETHTOOL_A_CABLE_NEST_FAULT_LENGTH);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(phydev->skb, ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR, pair))\n\t\tgoto err;\n\tif (nla_put_u32(phydev->skb, ETHTOOL_A_CABLE_FAULT_LENGTH_CM, cm))\n\t\tgoto err;\n\n\tnla_nest_end(phydev->skb, nest);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(phydev->skb, nest);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ethnl_cable_test_fault_length);\n\nstruct cable_test_tdr_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstatic const struct nla_policy cable_test_tdr_act_cfg_policy[] = {\n\t[ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST]\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST]\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP]\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR]\t= { .type = NLA_U8 },\n};\n\nconst struct nla_policy ethnl_cable_test_tdr_act_policy[] = {\n\t[ETHTOOL_A_CABLE_TEST_TDR_HEADER]\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_CABLE_TEST_TDR_CFG]\t\t= { .type = NLA_NESTED },\n};\n\n \nstatic int ethnl_act_cable_test_tdr_cfg(const struct nlattr *nest,\n\t\t\t\t\tstruct genl_info *info,\n\t\t\t\t\tstruct phy_tdr_config *cfg)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(cable_test_tdr_act_cfg_policy)];\n\tint ret;\n\n\tcfg->first = 100;\n\tcfg->step = 100;\n\tcfg->last = MAX_CABLE_LENGTH_CM;\n\tcfg->pair = PHY_PAIR_ALL;\n\n\tif (!nest)\n\t\treturn 0;\n\n\tret = nla_parse_nested(tb,\n\t\t\t       ARRAY_SIZE(cable_test_tdr_act_cfg_policy) - 1,\n\t\t\t       nest, cable_test_tdr_act_cfg_policy,\n\t\t\t       info->extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST])\n\t\tcfg->first = nla_get_u32(\n\t\t\ttb[ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST]);\n\n\tif (tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST])\n\t\tcfg->last = nla_get_u32(tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST]);\n\n\tif (tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP])\n\t\tcfg->step = nla_get_u32(tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP]);\n\n\tif (tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR]) {\n\t\tcfg->pair = nla_get_u8(tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR]);\n\t\tif (cfg->pair > ETHTOOL_A_CABLE_PAIR_D) {\n\t\t\tNL_SET_ERR_MSG_ATTR(\n\t\t\t\tinfo->extack,\n\t\t\t\ttb[ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR],\n\t\t\t\t\"invalid pair parameter\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (cfg->first > MAX_CABLE_LENGTH_CM) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST],\n\t\t\t\t    \"invalid first parameter\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->last > MAX_CABLE_LENGTH_CM) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST],\n\t\t\t\t    \"invalid last parameter\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->first > cfg->last) {\n\t\tNL_SET_ERR_MSG(info->extack, \"invalid first/last parameter\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cfg->step) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP],\n\t\t\t\t    \"invalid step parameter\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->step > (cfg->last - cfg->first)) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP],\n\t\t\t\t    \"step parameter too big\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint ethnl_act_cable_test_tdr(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ethnl_req_info req_info = {};\n\tconst struct ethtool_phy_ops *ops;\n\tstruct nlattr **tb = info->attrs;\n\tstruct phy_tdr_config cfg;\n\tstruct net_device *dev;\n\tint ret;\n\n\tret = ethnl_parse_header_dev_get(&req_info,\n\t\t\t\t\t tb[ETHTOOL_A_CABLE_TEST_TDR_HEADER],\n\t\t\t\t\t genl_info_net(info), info->extack,\n\t\t\t\t\t true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev = req_info.dev;\n\tif (!dev->phydev) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_dev_put;\n\t}\n\n\tret = ethnl_act_cable_test_tdr_cfg(tb[ETHTOOL_A_CABLE_TEST_TDR_CFG],\n\t\t\t\t\t   info, &cfg);\n\tif (ret)\n\t\tgoto out_dev_put;\n\n\trtnl_lock();\n\tops = ethtool_phy_ops;\n\tif (!ops || !ops->start_cable_test_tdr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_rtnl;\n\t}\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\tgoto out_rtnl;\n\n\tret = ops->start_cable_test_tdr(dev->phydev, info->extack, &cfg);\n\n\tethnl_ops_complete(dev);\n\n\tif (!ret)\n\t\tethnl_cable_test_started(dev->phydev,\n\t\t\t\t\t ETHTOOL_MSG_CABLE_TEST_TDR_NTF);\n\nout_rtnl:\n\trtnl_unlock();\nout_dev_put:\n\tethnl_parse_header_dev_put(&req_info);\n\treturn ret;\n}\n\nint ethnl_cable_test_amplitude(struct phy_device *phydev,\n\t\t\t       u8 pair, s16 mV)\n{\n\tstruct nlattr *nest;\n\tint ret = -EMSGSIZE;\n\n\tnest = nla_nest_start(phydev->skb,\n\t\t\t      ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(phydev->skb, ETHTOOL_A_CABLE_AMPLITUDE_PAIR, pair))\n\t\tgoto err;\n\tif (nla_put_u16(phydev->skb, ETHTOOL_A_CABLE_AMPLITUDE_mV, mV))\n\t\tgoto err;\n\n\tnla_nest_end(phydev->skb, nest);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(phydev->skb, nest);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ethnl_cable_test_amplitude);\n\nint ethnl_cable_test_pulse(struct phy_device *phydev, u16 mV)\n{\n\tstruct nlattr *nest;\n\tint ret = -EMSGSIZE;\n\n\tnest = nla_nest_start(phydev->skb, ETHTOOL_A_CABLE_TDR_NEST_PULSE);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u16(phydev->skb, ETHTOOL_A_CABLE_PULSE_mV, mV))\n\t\tgoto err;\n\n\tnla_nest_end(phydev->skb, nest);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(phydev->skb, nest);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ethnl_cable_test_pulse);\n\nint ethnl_cable_test_step(struct phy_device *phydev, u32 first, u32 last,\n\t\t\t  u32 step)\n{\n\tstruct nlattr *nest;\n\tint ret = -EMSGSIZE;\n\n\tnest = nla_nest_start(phydev->skb, ETHTOOL_A_CABLE_TDR_NEST_STEP);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(phydev->skb, ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE,\n\t\t\tfirst))\n\t\tgoto err;\n\n\tif (nla_put_u32(phydev->skb, ETHTOOL_A_CABLE_STEP_LAST_DISTANCE, last))\n\t\tgoto err;\n\n\tif (nla_put_u32(phydev->skb, ETHTOOL_A_CABLE_STEP_STEP_DISTANCE, step))\n\t\tgoto err;\n\n\tnla_nest_end(phydev->skb, nest);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(phydev->skb, nest);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ethnl_cable_test_step);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}