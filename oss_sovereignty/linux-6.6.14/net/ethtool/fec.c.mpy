{
  "module_name": "fec.c",
  "hash_id": "6e5abd6c6ed9729f56862450eb94164e2882e3fa9af06ae64b329483ec1e42a6",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/fec.c",
  "human_readable_source": "\n\n#include \"netlink.h\"\n#include \"common.h\"\n#include \"bitset.h\"\n\nstruct fec_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstruct fec_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(fec_link_modes);\n\tu32 active_fec;\n\tu8 fec_auto;\n\tstruct fec_stat_grp {\n\t\tu64 stats[1 + ETHTOOL_MAX_LANES];\n\t\tu8 cnt;\n\t} corr, uncorr, corr_bits;\n};\n\n#define FEC_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct fec_reply_data, base)\n\n#define ETHTOOL_FEC_MASK\t((ETHTOOL_FEC_LLRS << 1) - 1)\n\nconst struct nla_policy ethnl_fec_get_policy[ETHTOOL_A_FEC_HEADER + 1] = {\n\t[ETHTOOL_A_FEC_HEADER]\t= NLA_POLICY_NESTED(ethnl_header_policy_stats),\n};\n\nstatic void\nethtool_fec_to_link_modes(u32 fec, unsigned long *link_modes, u8 *fec_auto)\n{\n\tif (fec_auto)\n\t\t*fec_auto = !!(fec & ETHTOOL_FEC_AUTO);\n\n\tif (fec & ETHTOOL_FEC_OFF)\n\t\t__set_bit(ETHTOOL_LINK_MODE_FEC_NONE_BIT, link_modes);\n\tif (fec & ETHTOOL_FEC_RS)\n\t\t__set_bit(ETHTOOL_LINK_MODE_FEC_RS_BIT, link_modes);\n\tif (fec & ETHTOOL_FEC_BASER)\n\t\t__set_bit(ETHTOOL_LINK_MODE_FEC_BASER_BIT, link_modes);\n\tif (fec & ETHTOOL_FEC_LLRS)\n\t\t__set_bit(ETHTOOL_LINK_MODE_FEC_LLRS_BIT, link_modes);\n}\n\nstatic int\nethtool_link_modes_to_fecparam(struct ethtool_fecparam *fec,\n\t\t\t       unsigned long *link_modes, u8 fec_auto)\n{\n\tmemset(fec, 0, sizeof(*fec));\n\n\tif (fec_auto)\n\t\tfec->fec |= ETHTOOL_FEC_AUTO;\n\n\tif (__test_and_clear_bit(ETHTOOL_LINK_MODE_FEC_NONE_BIT, link_modes))\n\t\tfec->fec |= ETHTOOL_FEC_OFF;\n\tif (__test_and_clear_bit(ETHTOOL_LINK_MODE_FEC_RS_BIT, link_modes))\n\t\tfec->fec |= ETHTOOL_FEC_RS;\n\tif (__test_and_clear_bit(ETHTOOL_LINK_MODE_FEC_BASER_BIT, link_modes))\n\t\tfec->fec |= ETHTOOL_FEC_BASER;\n\tif (__test_and_clear_bit(ETHTOOL_LINK_MODE_FEC_LLRS_BIT, link_modes))\n\t\tfec->fec |= ETHTOOL_FEC_LLRS;\n\n\tif (!bitmap_empty(link_modes, __ETHTOOL_LINK_MODE_MASK_NBITS))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void\nfec_stats_recalc(struct fec_stat_grp *grp, struct ethtool_fec_stat *stats)\n{\n\tint i;\n\n\tif (stats->lanes[0] == ETHTOOL_STAT_NOT_SET) {\n\t\tgrp->stats[0] = stats->total;\n\t\tgrp->cnt = stats->total != ETHTOOL_STAT_NOT_SET;\n\t\treturn;\n\t}\n\n\tgrp->cnt = 1;\n\tgrp->stats[0] = 0;\n\tfor (i = 0; i < ETHTOOL_MAX_LANES; i++) {\n\t\tif (stats->lanes[i] == ETHTOOL_STAT_NOT_SET)\n\t\t\tbreak;\n\n\t\tgrp->stats[0] += stats->lanes[i];\n\t\tgrp->stats[grp->cnt++] = stats->lanes[i];\n\t}\n}\n\nstatic int fec_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t    struct ethnl_reply_data *reply_base,\n\t\t\t    const struct genl_info *info)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(active_fec_modes) = {};\n\tstruct fec_reply_data *data = FEC_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tstruct ethtool_fecparam fec = {};\n\tint ret;\n\n\tif (!dev->ethtool_ops->get_fecparam)\n\t\treturn -EOPNOTSUPP;\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = dev->ethtool_ops->get_fecparam(dev, &fec);\n\tif (ret)\n\t\tgoto out_complete;\n\tif (req_base->flags & ETHTOOL_FLAG_STATS &&\n\t    dev->ethtool_ops->get_fec_stats) {\n\t\tstruct ethtool_fec_stats stats;\n\n\t\tethtool_stats_init((u64 *)&stats, sizeof(stats) / 8);\n\t\tdev->ethtool_ops->get_fec_stats(dev, &stats);\n\n\t\tfec_stats_recalc(&data->corr, &stats.corrected_blocks);\n\t\tfec_stats_recalc(&data->uncorr, &stats.uncorrectable_blocks);\n\t\tfec_stats_recalc(&data->corr_bits, &stats.corrected_bits);\n\t}\n\n\tWARN_ON_ONCE(fec.reserved);\n\n\tethtool_fec_to_link_modes(fec.fec, data->fec_link_modes,\n\t\t\t\t  &data->fec_auto);\n\n\tethtool_fec_to_link_modes(fec.active_fec, active_fec_modes, NULL);\n\tdata->active_fec = find_first_bit(active_fec_modes,\n\t\t\t\t\t  __ETHTOOL_LINK_MODE_MASK_NBITS);\n\t \n\tif (data->active_fec == __ETHTOOL_LINK_MODE_MASK_NBITS)\n\t\tdata->active_fec = 0;\n\nout_complete:\n\tethnl_ops_complete(dev);\n\treturn ret;\n}\n\nstatic int fec_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t  const struct ethnl_reply_data *reply_base)\n{\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tconst struct fec_reply_data *data = FEC_REPDATA(reply_base);\n\tint len = 0;\n\tint ret;\n\n\tret = ethnl_bitset_size(data->fec_link_modes, NULL,\n\t\t\t\t__ETHTOOL_LINK_MODE_MASK_NBITS,\n\t\t\t\tlink_mode_names, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tlen += ret;\n\n\tlen += nla_total_size(sizeof(u8)) +\t \n\t       nla_total_size(sizeof(u32));\t \n\n\tif (req_base->flags & ETHTOOL_FLAG_STATS)\n\t\tlen += 3 * nla_total_size_64bit(sizeof(u64) *\n\t\t\t\t\t\t(1 + ETHTOOL_MAX_LANES));\n\n\treturn len;\n}\n\nstatic int fec_put_stats(struct sk_buff *skb, const struct fec_reply_data *data)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start(skb, ETHTOOL_A_FEC_STATS);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_64bit(skb, ETHTOOL_A_FEC_STAT_CORRECTED,\n\t\t\t  sizeof(u64) * data->corr.cnt,\n\t\t\t  data->corr.stats, ETHTOOL_A_FEC_STAT_PAD) ||\n\t    nla_put_64bit(skb, ETHTOOL_A_FEC_STAT_UNCORR,\n\t\t\t  sizeof(u64) * data->uncorr.cnt,\n\t\t\t  data->uncorr.stats, ETHTOOL_A_FEC_STAT_PAD) ||\n\t    nla_put_64bit(skb, ETHTOOL_A_FEC_STAT_CORR_BITS,\n\t\t\t  sizeof(u64) * data->corr_bits.cnt,\n\t\t\t  data->corr_bits.stats, ETHTOOL_A_FEC_STAT_PAD))\n\t\tgoto err_cancel;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nerr_cancel:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int fec_fill_reply(struct sk_buff *skb,\n\t\t\t  const struct ethnl_req_info *req_base,\n\t\t\t  const struct ethnl_reply_data *reply_base)\n{\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tconst struct fec_reply_data *data = FEC_REPDATA(reply_base);\n\tint ret;\n\n\tret = ethnl_put_bitset(skb, ETHTOOL_A_FEC_MODES,\n\t\t\t       data->fec_link_modes, NULL,\n\t\t\t       __ETHTOOL_LINK_MODE_MASK_NBITS,\n\t\t\t       link_mode_names, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (nla_put_u8(skb, ETHTOOL_A_FEC_AUTO, data->fec_auto) ||\n\t    (data->active_fec &&\n\t     nla_put_u32(skb, ETHTOOL_A_FEC_ACTIVE, data->active_fec)))\n\t\treturn -EMSGSIZE;\n\n\tif (req_base->flags & ETHTOOL_FLAG_STATS && fec_put_stats(skb, data))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\n \n\nconst struct nla_policy ethnl_fec_set_policy[ETHTOOL_A_FEC_AUTO + 1] = {\n\t[ETHTOOL_A_FEC_HEADER]\t= NLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_FEC_MODES]\t= { .type = NLA_NESTED },\n\t[ETHTOOL_A_FEC_AUTO]\t= NLA_POLICY_MAX(NLA_U8, 1),\n};\n\nstatic int\nethnl_set_fec_validate(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tconst struct ethtool_ops *ops = req_info->dev->ethtool_ops;\n\n\treturn ops->get_fecparam && ops->set_fecparam ? 1 : -EOPNOTSUPP;\n}\n\nstatic int\nethnl_set_fec(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(fec_link_modes) = {};\n\tstruct net_device *dev = req_info->dev;\n\tstruct nlattr **tb = info->attrs;\n\tstruct ethtool_fecparam fec = {};\n\tbool mod = false;\n\tu8 fec_auto;\n\tint ret;\n\n\tret = dev->ethtool_ops->get_fecparam(dev, &fec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tethtool_fec_to_link_modes(fec.fec, fec_link_modes, &fec_auto);\n\n\tret = ethnl_update_bitset(fec_link_modes,\n\t\t\t\t  __ETHTOOL_LINK_MODE_MASK_NBITS,\n\t\t\t\t  tb[ETHTOOL_A_FEC_MODES],\n\t\t\t\t  link_mode_names, info->extack, &mod);\n\tif (ret < 0)\n\t\treturn ret;\n\tethnl_update_u8(&fec_auto, tb[ETHTOOL_A_FEC_AUTO], &mod);\n\tif (!mod)\n\t\treturn 0;\n\n\tret = ethtool_link_modes_to_fecparam(&fec, fec_link_modes, fec_auto);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, tb[ETHTOOL_A_FEC_MODES],\n\t\t\t\t    \"invalid FEC modes requested\");\n\t\treturn ret;\n\t}\n\tif (!fec.fec) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, tb[ETHTOOL_A_FEC_MODES],\n\t\t\t\t    \"no FEC modes set\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = dev->ethtool_ops->set_fecparam(dev, &fec);\n\treturn ret < 0 ? ret : 1;\n}\n\nconst struct ethnl_request_ops ethnl_fec_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_FEC_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_FEC_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_FEC_HEADER,\n\t.req_info_size\t\t= sizeof(struct fec_req_info),\n\t.reply_data_size\t= sizeof(struct fec_reply_data),\n\n\t.prepare_data\t\t= fec_prepare_data,\n\t.reply_size\t\t= fec_reply_size,\n\t.fill_reply\t\t= fec_fill_reply,\n\n\t.set_validate\t\t= ethnl_set_fec_validate,\n\t.set\t\t\t= ethnl_set_fec,\n\t.set_ntf_cmd\t\t= ETHTOOL_MSG_FEC_NTF,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}