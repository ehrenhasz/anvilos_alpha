{
  "module_name": "linkmodes.c",
  "hash_id": "ca5aa617cd8e15f9bfb0753e45fe450a40631c5c328adb853b266b3ef8d791ee",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/linkmodes.c",
  "human_readable_source": "\n\n#include \"netlink.h\"\n#include \"common.h\"\n#include \"bitset.h\"\n\n \n\nstruct linkmodes_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstruct linkmodes_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tstruct ethtool_link_ksettings\tksettings;\n\tstruct ethtool_link_settings\t*lsettings;\n\tbool\t\t\t\tpeer_empty;\n};\n\n#define LINKMODES_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct linkmodes_reply_data, base)\n\nconst struct nla_policy ethnl_linkmodes_get_policy[] = {\n\t[ETHTOOL_A_LINKMODES_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic int linkmodes_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t\t  struct ethnl_reply_data *reply_base,\n\t\t\t\t  const struct genl_info *info)\n{\n\tstruct linkmodes_reply_data *data = LINKMODES_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tint ret;\n\n\tdata->lsettings = &data->ksettings.base;\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = __ethtool_get_link_ksettings(dev, &data->ksettings);\n\tif (ret < 0 && info) {\n\t\tGENL_SET_ERR_MSG(info, \"failed to retrieve link settings\");\n\t\tgoto out;\n\t}\n\n\tif (!dev->ethtool_ops->cap_link_lanes_supported)\n\t\tdata->ksettings.lanes = 0;\n\n\tdata->peer_empty =\n\t\tbitmap_empty(data->ksettings.link_modes.lp_advertising,\n\t\t\t     __ETHTOOL_LINK_MODE_MASK_NBITS);\n\nout:\n\tethnl_ops_complete(dev);\n\treturn ret;\n}\n\nstatic int linkmodes_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t\tconst struct ethnl_reply_data *reply_base)\n{\n\tconst struct linkmodes_reply_data *data = LINKMODES_REPDATA(reply_base);\n\tconst struct ethtool_link_ksettings *ksettings = &data->ksettings;\n\tconst struct ethtool_link_settings *lsettings = &ksettings->base;\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tint len, ret;\n\n\tlen = nla_total_size(sizeof(u8))  \n\t\t+ nla_total_size(sizeof(u32))  \n\t\t+ nla_total_size(sizeof(u32))  \n\t\t+ nla_total_size(sizeof(u8))  \n\t\t+ nla_total_size(sizeof(u8))  \n\t\t+ 0;\n\tret = ethnl_bitset_size(ksettings->link_modes.advertising,\n\t\t\t\tksettings->link_modes.supported,\n\t\t\t\t__ETHTOOL_LINK_MODE_MASK_NBITS,\n\t\t\t\tlink_mode_names, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tlen += ret;\n\tif (!data->peer_empty) {\n\t\tret = ethnl_bitset_size(ksettings->link_modes.lp_advertising,\n\t\t\t\t\tNULL, __ETHTOOL_LINK_MODE_MASK_NBITS,\n\t\t\t\t\tlink_mode_names, compact);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tlen += ret;\n\t}\n\n\tif (lsettings->master_slave_cfg != MASTER_SLAVE_CFG_UNSUPPORTED)\n\t\tlen += nla_total_size(sizeof(u8));\n\n\tif (lsettings->master_slave_state != MASTER_SLAVE_STATE_UNSUPPORTED)\n\t\tlen += nla_total_size(sizeof(u8));\n\n\treturn len;\n}\n\nstatic int linkmodes_fill_reply(struct sk_buff *skb,\n\t\t\t\tconst struct ethnl_req_info *req_base,\n\t\t\t\tconst struct ethnl_reply_data *reply_base)\n{\n\tconst struct linkmodes_reply_data *data = LINKMODES_REPDATA(reply_base);\n\tconst struct ethtool_link_ksettings *ksettings = &data->ksettings;\n\tconst struct ethtool_link_settings *lsettings = &ksettings->base;\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tint ret;\n\n\tif (nla_put_u8(skb, ETHTOOL_A_LINKMODES_AUTONEG, lsettings->autoneg))\n\t\treturn -EMSGSIZE;\n\n\tret = ethnl_put_bitset(skb, ETHTOOL_A_LINKMODES_OURS,\n\t\t\t       ksettings->link_modes.advertising,\n\t\t\t       ksettings->link_modes.supported,\n\t\t\t       __ETHTOOL_LINK_MODE_MASK_NBITS, link_mode_names,\n\t\t\t       compact);\n\tif (ret < 0)\n\t\treturn -EMSGSIZE;\n\tif (!data->peer_empty) {\n\t\tret = ethnl_put_bitset(skb, ETHTOOL_A_LINKMODES_PEER,\n\t\t\t\t       ksettings->link_modes.lp_advertising,\n\t\t\t\t       NULL, __ETHTOOL_LINK_MODE_MASK_NBITS,\n\t\t\t\t       link_mode_names, compact);\n\t\tif (ret < 0)\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (nla_put_u32(skb, ETHTOOL_A_LINKMODES_SPEED, lsettings->speed) ||\n\t    nla_put_u8(skb, ETHTOOL_A_LINKMODES_DUPLEX, lsettings->duplex))\n\t\treturn -EMSGSIZE;\n\n\tif (ksettings->lanes &&\n\t    nla_put_u32(skb, ETHTOOL_A_LINKMODES_LANES, ksettings->lanes))\n\t\treturn -EMSGSIZE;\n\n\tif (lsettings->master_slave_cfg != MASTER_SLAVE_CFG_UNSUPPORTED &&\n\t    nla_put_u8(skb, ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG,\n\t\t       lsettings->master_slave_cfg))\n\t\treturn -EMSGSIZE;\n\n\tif (lsettings->master_slave_state != MASTER_SLAVE_STATE_UNSUPPORTED &&\n\t    nla_put_u8(skb, ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE,\n\t\t       lsettings->master_slave_state))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(skb, ETHTOOL_A_LINKMODES_RATE_MATCHING,\n\t\t       lsettings->rate_matching))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\n \n\nconst struct nla_policy ethnl_linkmodes_set_policy[] = {\n\t[ETHTOOL_A_LINKMODES_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_LINKMODES_AUTONEG]\t\t= { .type = NLA_U8 },\n\t[ETHTOOL_A_LINKMODES_OURS]\t\t= { .type = NLA_NESTED },\n\t[ETHTOOL_A_LINKMODES_SPEED]\t\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_LINKMODES_DUPLEX]\t\t= { .type = NLA_U8 },\n\t[ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG]\t= { .type = NLA_U8 },\n\t[ETHTOOL_A_LINKMODES_LANES]\t\t= NLA_POLICY_RANGE(NLA_U32, 1, 8),\n};\n\n \nstatic bool ethnl_auto_linkmodes(struct ethtool_link_ksettings *ksettings,\n\t\t\t\t bool req_speed, bool req_lanes, bool req_duplex)\n{\n\tunsigned long *advertising = ksettings->link_modes.advertising;\n\tunsigned long *supported = ksettings->link_modes.supported;\n\tDECLARE_BITMAP(old_adv, __ETHTOOL_LINK_MODE_MASK_NBITS);\n\tunsigned int i;\n\n\tbitmap_copy(old_adv, advertising, __ETHTOOL_LINK_MODE_MASK_NBITS);\n\n\tfor (i = 0; i < __ETHTOOL_LINK_MODE_MASK_NBITS; i++) {\n\t\tconst struct link_mode_info *info = &link_mode_params[i];\n\n\t\tif (info->speed == SPEED_UNKNOWN)\n\t\t\tcontinue;\n\t\tif (test_bit(i, supported) &&\n\t\t    (!req_speed || info->speed == ksettings->base.speed) &&\n\t\t    (!req_lanes || info->lanes == ksettings->lanes) &&\n\t\t    (!req_duplex || info->duplex == ksettings->base.duplex))\n\t\t\tset_bit(i, advertising);\n\t\telse\n\t\t\tclear_bit(i, advertising);\n\t}\n\n\treturn !bitmap_equal(old_adv, advertising,\n\t\t\t     __ETHTOOL_LINK_MODE_MASK_NBITS);\n}\n\nstatic bool ethnl_validate_master_slave_cfg(u8 cfg)\n{\n\tswitch (cfg) {\n\tcase MASTER_SLAVE_CFG_MASTER_PREFERRED:\n\tcase MASTER_SLAVE_CFG_SLAVE_PREFERRED:\n\tcase MASTER_SLAVE_CFG_MASTER_FORCE:\n\tcase MASTER_SLAVE_CFG_SLAVE_FORCE:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int ethnl_check_linkmodes(struct genl_info *info, struct nlattr **tb)\n{\n\tconst struct nlattr *master_slave_cfg, *lanes_cfg;\n\n\tmaster_slave_cfg = tb[ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG];\n\tif (master_slave_cfg &&\n\t    !ethnl_validate_master_slave_cfg(nla_get_u8(master_slave_cfg))) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, master_slave_cfg,\n\t\t\t\t    \"master/slave value is invalid\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tlanes_cfg = tb[ETHTOOL_A_LINKMODES_LANES];\n\tif (lanes_cfg && !is_power_of_2(nla_get_u32(lanes_cfg))) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, lanes_cfg,\n\t\t\t\t    \"lanes value is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ethnl_update_linkmodes(struct genl_info *info, struct nlattr **tb,\n\t\t\t\t  struct ethtool_link_ksettings *ksettings,\n\t\t\t\t  bool *mod, const struct net_device *dev)\n{\n\tstruct ethtool_link_settings *lsettings = &ksettings->base;\n\tbool req_speed, req_lanes, req_duplex;\n\tconst struct nlattr *master_slave_cfg, *lanes_cfg;\n\tint ret;\n\n\tmaster_slave_cfg = tb[ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG];\n\tif (master_slave_cfg) {\n\t\tif (lsettings->master_slave_cfg == MASTER_SLAVE_CFG_UNSUPPORTED) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack, master_slave_cfg,\n\t\t\t\t\t    \"master/slave configuration not supported by device\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\t*mod = false;\n\treq_speed = tb[ETHTOOL_A_LINKMODES_SPEED];\n\treq_lanes = tb[ETHTOOL_A_LINKMODES_LANES];\n\treq_duplex = tb[ETHTOOL_A_LINKMODES_DUPLEX];\n\n\tethnl_update_u8(&lsettings->autoneg, tb[ETHTOOL_A_LINKMODES_AUTONEG],\n\t\t\tmod);\n\n\tlanes_cfg = tb[ETHTOOL_A_LINKMODES_LANES];\n\tif (lanes_cfg) {\n\t\t \n\t\tif (!lsettings->autoneg &&\n\t\t    !dev->ethtool_ops->cap_link_lanes_supported) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack, lanes_cfg,\n\t\t\t\t\t    \"lanes configuration not supported by device\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else if (!lsettings->autoneg && ksettings->lanes) {\n\t\t \n\t\tksettings->lanes = 0;\n\t\t*mod = true;\n\t}\n\n\tret = ethnl_update_bitset(ksettings->link_modes.advertising,\n\t\t\t\t  __ETHTOOL_LINK_MODE_MASK_NBITS,\n\t\t\t\t  tb[ETHTOOL_A_LINKMODES_OURS], link_mode_names,\n\t\t\t\t  info->extack, mod);\n\tif (ret < 0)\n\t\treturn ret;\n\tethnl_update_u32(&lsettings->speed, tb[ETHTOOL_A_LINKMODES_SPEED],\n\t\t\t mod);\n\tethnl_update_u32(&ksettings->lanes, lanes_cfg, mod);\n\tethnl_update_u8(&lsettings->duplex, tb[ETHTOOL_A_LINKMODES_DUPLEX],\n\t\t\tmod);\n\tethnl_update_u8(&lsettings->master_slave_cfg, master_slave_cfg, mod);\n\n\tif (!tb[ETHTOOL_A_LINKMODES_OURS] && lsettings->autoneg &&\n\t    (req_speed || req_lanes || req_duplex) &&\n\t    ethnl_auto_linkmodes(ksettings, req_speed, req_lanes, req_duplex))\n\t\t*mod = true;\n\n\treturn 0;\n}\n\nstatic int\nethnl_set_linkmodes_validate(struct ethnl_req_info *req_info,\n\t\t\t     struct genl_info *info)\n{\n\tconst struct ethtool_ops *ops = req_info->dev->ethtool_ops;\n\tint ret;\n\n\tret = ethnl_check_linkmodes(info, info->attrs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!ops->get_link_ksettings || !ops->set_link_ksettings)\n\t\treturn -EOPNOTSUPP;\n\treturn 1;\n}\n\nstatic int\nethnl_set_linkmodes(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tstruct ethtool_link_ksettings ksettings = {};\n\tstruct net_device *dev = req_info->dev;\n\tstruct nlattr **tb = info->attrs;\n\tbool mod = false;\n\tint ret;\n\n\tret = __ethtool_get_link_ksettings(dev, &ksettings);\n\tif (ret < 0) {\n\t\tGENL_SET_ERR_MSG(info, \"failed to retrieve link settings\");\n\t\treturn ret;\n\t}\n\n\tret = ethnl_update_linkmodes(info, tb, &ksettings, &mod, dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!mod)\n\t\treturn 0;\n\n\tret = dev->ethtool_ops->set_link_ksettings(dev, &ksettings);\n\tif (ret < 0) {\n\t\tGENL_SET_ERR_MSG(info, \"link settings update failed\");\n\t\treturn ret;\n\t}\n\n\treturn 1;\n}\n\nconst struct ethnl_request_ops ethnl_linkmodes_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_LINKMODES_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_LINKMODES_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_LINKMODES_HEADER,\n\t.req_info_size\t\t= sizeof(struct linkmodes_req_info),\n\t.reply_data_size\t= sizeof(struct linkmodes_reply_data),\n\n\t.prepare_data\t\t= linkmodes_prepare_data,\n\t.reply_size\t\t= linkmodes_reply_size,\n\t.fill_reply\t\t= linkmodes_fill_reply,\n\n\t.set_validate\t\t= ethnl_set_linkmodes_validate,\n\t.set\t\t\t= ethnl_set_linkmodes,\n\t.set_ntf_cmd\t\t= ETHTOOL_MSG_LINKMODES_NTF,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}