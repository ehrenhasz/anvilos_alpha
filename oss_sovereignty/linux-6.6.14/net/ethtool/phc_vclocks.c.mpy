{
  "module_name": "phc_vclocks.c",
  "hash_id": "3034e57418f5d48b29422b3bc26d1aa87b9b8ad9ef51c29648d1677a2f64f3ab",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/phc_vclocks.c",
  "human_readable_source": "\n \n#include \"netlink.h\"\n#include \"common.h\"\n\nstruct phc_vclocks_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstruct phc_vclocks_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tint\t\t\t\tnum;\n\tint\t\t\t\t*index;\n};\n\n#define PHC_VCLOCKS_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct phc_vclocks_reply_data, base)\n\nconst struct nla_policy ethnl_phc_vclocks_get_policy[] = {\n\t[ETHTOOL_A_PHC_VCLOCKS_HEADER] = NLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic int phc_vclocks_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t\t    struct ethnl_reply_data *reply_base,\n\t\t\t\t    const struct genl_info *info)\n{\n\tstruct phc_vclocks_reply_data *data = PHC_VCLOCKS_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tint ret;\n\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->num = ethtool_get_phc_vclocks(dev, &data->index);\n\tethnl_ops_complete(dev);\n\n\treturn ret;\n}\n\nstatic int phc_vclocks_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t\t  const struct ethnl_reply_data *reply_base)\n{\n\tconst struct phc_vclocks_reply_data *data =\n\t\tPHC_VCLOCKS_REPDATA(reply_base);\n\tint len = 0;\n\n\tif (data->num > 0) {\n\t\tlen += nla_total_size(sizeof(u32));\n\t\tlen += nla_total_size(sizeof(s32) * data->num);\n\t}\n\n\treturn len;\n}\n\nstatic int phc_vclocks_fill_reply(struct sk_buff *skb,\n\t\t\t\t  const struct ethnl_req_info *req_base,\n\t\t\t\t  const struct ethnl_reply_data *reply_base)\n{\n\tconst struct phc_vclocks_reply_data *data =\n\t\tPHC_VCLOCKS_REPDATA(reply_base);\n\n\tif (data->num <= 0)\n\t\treturn 0;\n\n\tif (nla_put_u32(skb, ETHTOOL_A_PHC_VCLOCKS_NUM, data->num) ||\n\t    nla_put(skb, ETHTOOL_A_PHC_VCLOCKS_INDEX,\n\t\t    sizeof(s32) * data->num, data->index))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic void phc_vclocks_cleanup_data(struct ethnl_reply_data *reply_base)\n{\n\tconst struct phc_vclocks_reply_data *data =\n\t\tPHC_VCLOCKS_REPDATA(reply_base);\n\n\tkfree(data->index);\n}\n\nconst struct ethnl_request_ops ethnl_phc_vclocks_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_PHC_VCLOCKS_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_PHC_VCLOCKS_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_PHC_VCLOCKS_HEADER,\n\t.req_info_size\t\t= sizeof(struct phc_vclocks_req_info),\n\t.reply_data_size\t= sizeof(struct phc_vclocks_reply_data),\n\n\t.prepare_data\t\t= phc_vclocks_prepare_data,\n\t.reply_size\t\t= phc_vclocks_reply_size,\n\t.fill_reply\t\t= phc_vclocks_fill_reply,\n\t.cleanup_data\t\t= phc_vclocks_cleanup_data,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}