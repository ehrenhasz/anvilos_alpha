{
  "module_name": "features.c",
  "hash_id": "8992d601d625357c5a620be2d6f37465c0382328bee54c04f2ea04ee8dc1373a",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/features.c",
  "human_readable_source": "\n\n#include \"netlink.h\"\n#include \"common.h\"\n#include \"bitset.h\"\n\nstruct features_req_info {\n\tstruct ethnl_req_info\tbase;\n};\n\nstruct features_reply_data {\n\tstruct ethnl_reply_data\tbase;\n\tu32\t\t\thw[ETHTOOL_DEV_FEATURE_WORDS];\n\tu32\t\t\twanted[ETHTOOL_DEV_FEATURE_WORDS];\n\tu32\t\t\tactive[ETHTOOL_DEV_FEATURE_WORDS];\n\tu32\t\t\tnochange[ETHTOOL_DEV_FEATURE_WORDS];\n\tu32\t\t\tall[ETHTOOL_DEV_FEATURE_WORDS];\n};\n\n#define FEATURES_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct features_reply_data, base)\n\nconst struct nla_policy ethnl_features_get_policy[] = {\n\t[ETHTOOL_A_FEATURES_HEADER]\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic void ethnl_features_to_bitmap32(u32 *dest, netdev_features_t src)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ETHTOOL_DEV_FEATURE_WORDS; i++)\n\t\tdest[i] = src >> (32 * i);\n}\n\nstatic int features_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t\t struct ethnl_reply_data *reply_base,\n\t\t\t\t const struct genl_info *info)\n{\n\tstruct features_reply_data *data = FEATURES_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tnetdev_features_t all_features;\n\n\tethnl_features_to_bitmap32(data->hw, dev->hw_features);\n\tethnl_features_to_bitmap32(data->wanted, dev->wanted_features);\n\tethnl_features_to_bitmap32(data->active, dev->features);\n\tethnl_features_to_bitmap32(data->nochange, NETIF_F_NEVER_CHANGE);\n\tall_features = GENMASK_ULL(NETDEV_FEATURE_COUNT - 1, 0);\n\tethnl_features_to_bitmap32(data->all, all_features);\n\n\treturn 0;\n}\n\nstatic int features_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t       const struct ethnl_reply_data *reply_base)\n{\n\tconst struct features_reply_data *data = FEATURES_REPDATA(reply_base);\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tunsigned int len = 0;\n\tint ret;\n\n\tret = ethnl_bitset32_size(data->hw, data->all, NETDEV_FEATURE_COUNT,\n\t\t\t\t  netdev_features_strings, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tlen += ret;\n\tret = ethnl_bitset32_size(data->wanted, NULL, NETDEV_FEATURE_COUNT,\n\t\t\t\t  netdev_features_strings, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tlen += ret;\n\tret = ethnl_bitset32_size(data->active, NULL, NETDEV_FEATURE_COUNT,\n\t\t\t\t  netdev_features_strings, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tlen += ret;\n\tret = ethnl_bitset32_size(data->nochange, NULL, NETDEV_FEATURE_COUNT,\n\t\t\t\t  netdev_features_strings, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tlen += ret;\n\n\treturn len;\n}\n\nstatic int features_fill_reply(struct sk_buff *skb,\n\t\t\t       const struct ethnl_req_info *req_base,\n\t\t\t       const struct ethnl_reply_data *reply_base)\n{\n\tconst struct features_reply_data *data = FEATURES_REPDATA(reply_base);\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tint ret;\n\n\tret = ethnl_put_bitset32(skb, ETHTOOL_A_FEATURES_HW, data->hw,\n\t\t\t\t data->all, NETDEV_FEATURE_COUNT,\n\t\t\t\t netdev_features_strings, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ethnl_put_bitset32(skb, ETHTOOL_A_FEATURES_WANTED, data->wanted,\n\t\t\t\t NULL, NETDEV_FEATURE_COUNT,\n\t\t\t\t netdev_features_strings, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ethnl_put_bitset32(skb, ETHTOOL_A_FEATURES_ACTIVE, data->active,\n\t\t\t\t NULL, NETDEV_FEATURE_COUNT,\n\t\t\t\t netdev_features_strings, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn ethnl_put_bitset32(skb, ETHTOOL_A_FEATURES_NOCHANGE,\n\t\t\t\t  data->nochange, NULL, NETDEV_FEATURE_COUNT,\n\t\t\t\t  netdev_features_strings, compact);\n}\n\nconst struct ethnl_request_ops ethnl_features_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_FEATURES_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_FEATURES_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_FEATURES_HEADER,\n\t.req_info_size\t\t= sizeof(struct features_req_info),\n\t.reply_data_size\t= sizeof(struct features_reply_data),\n\n\t.prepare_data\t\t= features_prepare_data,\n\t.reply_size\t\t= features_reply_size,\n\t.fill_reply\t\t= features_fill_reply,\n};\n\n \n\nconst struct nla_policy ethnl_features_set_policy[] = {\n\t[ETHTOOL_A_FEATURES_HEADER]\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_FEATURES_WANTED]\t= { .type = NLA_NESTED },\n};\n\nstatic void ethnl_features_to_bitmap(unsigned long *dest, netdev_features_t val)\n{\n\tconst unsigned int words = BITS_TO_LONGS(NETDEV_FEATURE_COUNT);\n\tunsigned int i;\n\n\tfor (i = 0; i < words; i++)\n\t\tdest[i] = (unsigned long)(val >> (i * BITS_PER_LONG));\n}\n\nstatic netdev_features_t ethnl_bitmap_to_features(unsigned long *src)\n{\n\tconst unsigned int nft_bits = sizeof(netdev_features_t) * BITS_PER_BYTE;\n\tconst unsigned int words = BITS_TO_LONGS(NETDEV_FEATURE_COUNT);\n\tnetdev_features_t ret = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < words; i++)\n\t\tret |= (netdev_features_t)(src[i]) << (i * BITS_PER_LONG);\n\tret &= ~(netdev_features_t)0 >> (nft_bits - NETDEV_FEATURE_COUNT);\n\treturn ret;\n}\n\nstatic int features_send_reply(struct net_device *dev, struct genl_info *info,\n\t\t\t       const unsigned long *wanted,\n\t\t\t       const unsigned long *wanted_mask,\n\t\t\t       const unsigned long *active,\n\t\t\t       const unsigned long *active_mask, bool compact)\n{\n\tstruct sk_buff *rskb;\n\tvoid *reply_payload;\n\tint reply_len = 0;\n\tint ret;\n\n\treply_len = ethnl_reply_header_size();\n\tret = ethnl_bitset_size(wanted, wanted_mask, NETDEV_FEATURE_COUNT,\n\t\t\t\tnetdev_features_strings, compact);\n\tif (ret < 0)\n\t\tgoto err;\n\treply_len += ret;\n\tret = ethnl_bitset_size(active, active_mask, NETDEV_FEATURE_COUNT,\n\t\t\t\tnetdev_features_strings, compact);\n\tif (ret < 0)\n\t\tgoto err;\n\treply_len += ret;\n\n\tret = -ENOMEM;\n\trskb = ethnl_reply_init(reply_len, dev, ETHTOOL_MSG_FEATURES_SET_REPLY,\n\t\t\t\tETHTOOL_A_FEATURES_HEADER, info,\n\t\t\t\t&reply_payload);\n\tif (!rskb)\n\t\tgoto err;\n\n\tret = ethnl_put_bitset(rskb, ETHTOOL_A_FEATURES_WANTED, wanted,\n\t\t\t       wanted_mask, NETDEV_FEATURE_COUNT,\n\t\t\t       netdev_features_strings, compact);\n\tif (ret < 0)\n\t\tgoto nla_put_failure;\n\tret = ethnl_put_bitset(rskb, ETHTOOL_A_FEATURES_ACTIVE, active,\n\t\t\t       active_mask, NETDEV_FEATURE_COUNT,\n\t\t\t       netdev_features_strings, compact);\n\tif (ret < 0)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(rskb, reply_payload);\n\tret = genlmsg_reply(rskb, info);\n\treturn ret;\n\nnla_put_failure:\n\tnlmsg_free(rskb);\n\tWARN_ONCE(1, \"calculated message payload length (%d) not sufficient\\n\",\n\t\t  reply_len);\nerr:\n\tGENL_SET_ERR_MSG(info, \"failed to send reply message\");\n\treturn ret;\n}\n\nint ethnl_set_features(struct sk_buff *skb, struct genl_info *info)\n{\n\tDECLARE_BITMAP(wanted_diff_mask, NETDEV_FEATURE_COUNT);\n\tDECLARE_BITMAP(active_diff_mask, NETDEV_FEATURE_COUNT);\n\tDECLARE_BITMAP(old_active, NETDEV_FEATURE_COUNT);\n\tDECLARE_BITMAP(old_wanted, NETDEV_FEATURE_COUNT);\n\tDECLARE_BITMAP(new_active, NETDEV_FEATURE_COUNT);\n\tDECLARE_BITMAP(new_wanted, NETDEV_FEATURE_COUNT);\n\tDECLARE_BITMAP(req_wanted, NETDEV_FEATURE_COUNT);\n\tDECLARE_BITMAP(req_mask, NETDEV_FEATURE_COUNT);\n\tstruct ethnl_req_info req_info = {};\n\tstruct nlattr **tb = info->attrs;\n\tstruct net_device *dev;\n\tbool mod;\n\tint ret;\n\n\tif (!tb[ETHTOOL_A_FEATURES_WANTED])\n\t\treturn -EINVAL;\n\tret = ethnl_parse_header_dev_get(&req_info,\n\t\t\t\t\t tb[ETHTOOL_A_FEATURES_HEADER],\n\t\t\t\t\t genl_info_net(info), info->extack,\n\t\t\t\t\t true);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev = req_info.dev;\n\n\trtnl_lock();\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\tgoto out_rtnl;\n\tethnl_features_to_bitmap(old_active, dev->features);\n\tethnl_features_to_bitmap(old_wanted, dev->wanted_features);\n\tret = ethnl_parse_bitset(req_wanted, req_mask, NETDEV_FEATURE_COUNT,\n\t\t\t\t tb[ETHTOOL_A_FEATURES_WANTED],\n\t\t\t\t netdev_features_strings, info->extack);\n\tif (ret < 0)\n\t\tgoto out_ops;\n\tif (ethnl_bitmap_to_features(req_mask) & ~NETIF_F_ETHTOOL_BITS) {\n\t\tGENL_SET_ERR_MSG(info, \"attempt to change non-ethtool features\");\n\t\tret = -EINVAL;\n\t\tgoto out_ops;\n\t}\n\n\t \n\tbitmap_and(req_wanted, req_wanted, req_mask, NETDEV_FEATURE_COUNT);\n\tbitmap_andnot(new_wanted, old_wanted, req_mask, NETDEV_FEATURE_COUNT);\n\tbitmap_or(req_wanted, new_wanted, req_wanted, NETDEV_FEATURE_COUNT);\n\tif (!bitmap_equal(req_wanted, old_wanted, NETDEV_FEATURE_COUNT)) {\n\t\tdev->wanted_features &= ~dev->hw_features;\n\t\tdev->wanted_features |= ethnl_bitmap_to_features(req_wanted) & dev->hw_features;\n\t\t__netdev_update_features(dev);\n\t}\n\tethnl_features_to_bitmap(new_active, dev->features);\n\tmod = !bitmap_equal(old_active, new_active, NETDEV_FEATURE_COUNT);\n\n\tret = 0;\n\tif (!(req_info.flags & ETHTOOL_FLAG_OMIT_REPLY)) {\n\t\tbool compact = req_info.flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\n\t\tbitmap_xor(wanted_diff_mask, req_wanted, new_active,\n\t\t\t   NETDEV_FEATURE_COUNT);\n\t\tbitmap_xor(active_diff_mask, old_active, new_active,\n\t\t\t   NETDEV_FEATURE_COUNT);\n\t\tbitmap_and(wanted_diff_mask, wanted_diff_mask, req_mask,\n\t\t\t   NETDEV_FEATURE_COUNT);\n\t\tbitmap_and(req_wanted, req_wanted, wanted_diff_mask,\n\t\t\t   NETDEV_FEATURE_COUNT);\n\t\tbitmap_and(new_active, new_active, active_diff_mask,\n\t\t\t   NETDEV_FEATURE_COUNT);\n\n\t\tret = features_send_reply(dev, info, req_wanted,\n\t\t\t\t\t  wanted_diff_mask, new_active,\n\t\t\t\t\t  active_diff_mask, compact);\n\t}\n\tif (mod)\n\t\tnetdev_features_change(dev);\n\nout_ops:\n\tethnl_ops_complete(dev);\nout_rtnl:\n\trtnl_unlock();\n\tethnl_parse_header_dev_put(&req_info);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}