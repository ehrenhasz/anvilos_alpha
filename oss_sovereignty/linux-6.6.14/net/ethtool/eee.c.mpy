{
  "module_name": "eee.c",
  "hash_id": "1f3c157ff5785d51095c8293bf060bee167b6bc01df972bee1dc9b740bbdc821",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/eee.c",
  "human_readable_source": "\n\n#include \"netlink.h\"\n#include \"common.h\"\n#include \"bitset.h\"\n\n#define EEE_MODES_COUNT \\\n\t(sizeof_field(struct ethtool_eee, supported) * BITS_PER_BYTE)\n\nstruct eee_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstruct eee_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tstruct ethtool_eee\t\teee;\n};\n\n#define EEE_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct eee_reply_data, base)\n\nconst struct nla_policy ethnl_eee_get_policy[] = {\n\t[ETHTOOL_A_EEE_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic int eee_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t    struct ethnl_reply_data *reply_base,\n\t\t\t    const struct genl_info *info)\n{\n\tstruct eee_reply_data *data = EEE_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tint ret;\n\n\tif (!dev->ethtool_ops->get_eee)\n\t\treturn -EOPNOTSUPP;\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = dev->ethtool_ops->get_eee(dev, &data->eee);\n\tethnl_ops_complete(dev);\n\n\treturn ret;\n}\n\nstatic int eee_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t  const struct ethnl_reply_data *reply_base)\n{\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tconst struct eee_reply_data *data = EEE_REPDATA(reply_base);\n\tconst struct ethtool_eee *eee = &data->eee;\n\tint len = 0;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(eee->advertised) * BITS_PER_BYTE !=\n\t\t     EEE_MODES_COUNT);\n\tBUILD_BUG_ON(sizeof(eee->lp_advertised) * BITS_PER_BYTE !=\n\t\t     EEE_MODES_COUNT);\n\n\t \n\tret = ethnl_bitset32_size(&eee->advertised, &eee->supported,\n\t\t\t\t  EEE_MODES_COUNT, link_mode_names, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tlen += ret;\n\t \n\tret = ethnl_bitset32_size(&eee->lp_advertised, NULL,\n\t\t\t\t  EEE_MODES_COUNT, link_mode_names, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tlen += ret;\n\n\tlen += nla_total_size(sizeof(u8)) +\t \n\t       nla_total_size(sizeof(u8)) +\t \n\t       nla_total_size(sizeof(u8)) +\t \n\t       nla_total_size(sizeof(u32));\t \n\n\treturn len;\n}\n\nstatic int eee_fill_reply(struct sk_buff *skb,\n\t\t\t  const struct ethnl_req_info *req_base,\n\t\t\t  const struct ethnl_reply_data *reply_base)\n{\n\tbool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;\n\tconst struct eee_reply_data *data = EEE_REPDATA(reply_base);\n\tconst struct ethtool_eee *eee = &data->eee;\n\tint ret;\n\n\tret = ethnl_put_bitset32(skb, ETHTOOL_A_EEE_MODES_OURS,\n\t\t\t\t &eee->advertised, &eee->supported,\n\t\t\t\t EEE_MODES_COUNT, link_mode_names, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ethnl_put_bitset32(skb, ETHTOOL_A_EEE_MODES_PEER,\n\t\t\t\t &eee->lp_advertised, NULL, EEE_MODES_COUNT,\n\t\t\t\t link_mode_names, compact);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (nla_put_u8(skb, ETHTOOL_A_EEE_ACTIVE, !!eee->eee_active) ||\n\t    nla_put_u8(skb, ETHTOOL_A_EEE_ENABLED, !!eee->eee_enabled) ||\n\t    nla_put_u8(skb, ETHTOOL_A_EEE_TX_LPI_ENABLED,\n\t\t       !!eee->tx_lpi_enabled) ||\n\t    nla_put_u32(skb, ETHTOOL_A_EEE_TX_LPI_TIMER, eee->tx_lpi_timer))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\n \n\nconst struct nla_policy ethnl_eee_set_policy[] = {\n\t[ETHTOOL_A_EEE_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_EEE_MODES_OURS]\t= { .type = NLA_NESTED },\n\t[ETHTOOL_A_EEE_ENABLED]\t\t= { .type = NLA_U8 },\n\t[ETHTOOL_A_EEE_TX_LPI_ENABLED]\t= { .type = NLA_U8 },\n\t[ETHTOOL_A_EEE_TX_LPI_TIMER]\t= { .type = NLA_U32 },\n};\n\nstatic int\nethnl_set_eee_validate(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tconst struct ethtool_ops *ops = req_info->dev->ethtool_ops;\n\n\treturn ops->get_eee && ops->set_eee ? 1 : -EOPNOTSUPP;\n}\n\nstatic int\nethnl_set_eee(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tstruct net_device *dev = req_info->dev;\n\tstruct nlattr **tb = info->attrs;\n\tstruct ethtool_eee eee = {};\n\tbool mod = false;\n\tint ret;\n\n\tret = dev->ethtool_ops->get_eee(dev, &eee);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ethnl_update_bitset32(&eee.advertised, EEE_MODES_COUNT,\n\t\t\t\t    tb[ETHTOOL_A_EEE_MODES_OURS],\n\t\t\t\t    link_mode_names, info->extack, &mod);\n\tif (ret < 0)\n\t\treturn ret;\n\tethnl_update_bool32(&eee.eee_enabled, tb[ETHTOOL_A_EEE_ENABLED], &mod);\n\tethnl_update_bool32(&eee.tx_lpi_enabled,\n\t\t\t    tb[ETHTOOL_A_EEE_TX_LPI_ENABLED], &mod);\n\tethnl_update_u32(&eee.tx_lpi_timer, tb[ETHTOOL_A_EEE_TX_LPI_TIMER],\n\t\t\t &mod);\n\tif (!mod)\n\t\treturn 0;\n\n\tret = dev->ethtool_ops->set_eee(dev, &eee);\n\treturn ret < 0 ? ret : 1;\n}\n\nconst struct ethnl_request_ops ethnl_eee_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_EEE_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_EEE_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_EEE_HEADER,\n\t.req_info_size\t\t= sizeof(struct eee_req_info),\n\t.reply_data_size\t= sizeof(struct eee_reply_data),\n\n\t.prepare_data\t\t= eee_prepare_data,\n\t.reply_size\t\t= eee_reply_size,\n\t.fill_reply\t\t= eee_fill_reply,\n\n\t.set_validate\t\t= ethnl_set_eee_validate,\n\t.set\t\t\t= ethnl_set_eee,\n\t.set_ntf_cmd\t\t= ETHTOOL_MSG_EEE_NTF,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}