{
  "module_name": "channels.c",
  "hash_id": "961e68e4d1090168826dce0d4c7b137d1cdb452aee034f0a455b5b2da9f5d97c",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/channels.c",
  "human_readable_source": "\n\n#include <net/xdp_sock_drv.h>\n\n#include \"netlink.h\"\n#include \"common.h\"\n\nstruct channels_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstruct channels_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tstruct ethtool_channels\t\tchannels;\n};\n\n#define CHANNELS_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct channels_reply_data, base)\n\nconst struct nla_policy ethnl_channels_get_policy[] = {\n\t[ETHTOOL_A_CHANNELS_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic int channels_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t\t struct ethnl_reply_data *reply_base,\n\t\t\t\t const struct genl_info *info)\n{\n\tstruct channels_reply_data *data = CHANNELS_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tint ret;\n\n\tif (!dev->ethtool_ops->get_channels)\n\t\treturn -EOPNOTSUPP;\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev->ethtool_ops->get_channels(dev, &data->channels);\n\tethnl_ops_complete(dev);\n\n\treturn 0;\n}\n\nstatic int channels_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t       const struct ethnl_reply_data *reply_base)\n{\n\treturn nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32));\t \n}\n\nstatic int channels_fill_reply(struct sk_buff *skb,\n\t\t\t       const struct ethnl_req_info *req_base,\n\t\t\t       const struct ethnl_reply_data *reply_base)\n{\n\tconst struct channels_reply_data *data = CHANNELS_REPDATA(reply_base);\n\tconst struct ethtool_channels *channels = &data->channels;\n\n\tif ((channels->max_rx &&\n\t     (nla_put_u32(skb, ETHTOOL_A_CHANNELS_RX_MAX,\n\t\t\t  channels->max_rx) ||\n\t      nla_put_u32(skb, ETHTOOL_A_CHANNELS_RX_COUNT,\n\t\t\t  channels->rx_count))) ||\n\t    (channels->max_tx &&\n\t     (nla_put_u32(skb, ETHTOOL_A_CHANNELS_TX_MAX,\n\t\t\t  channels->max_tx) ||\n\t      nla_put_u32(skb, ETHTOOL_A_CHANNELS_TX_COUNT,\n\t\t\t  channels->tx_count))) ||\n\t    (channels->max_other &&\n\t     (nla_put_u32(skb, ETHTOOL_A_CHANNELS_OTHER_MAX,\n\t\t\t  channels->max_other) ||\n\t      nla_put_u32(skb, ETHTOOL_A_CHANNELS_OTHER_COUNT,\n\t\t\t  channels->other_count))) ||\n\t    (channels->max_combined &&\n\t     (nla_put_u32(skb, ETHTOOL_A_CHANNELS_COMBINED_MAX,\n\t\t\t  channels->max_combined) ||\n\t      nla_put_u32(skb, ETHTOOL_A_CHANNELS_COMBINED_COUNT,\n\t\t\t  channels->combined_count))))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\n \n\nconst struct nla_policy ethnl_channels_set_policy[] = {\n\t[ETHTOOL_A_CHANNELS_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_CHANNELS_RX_COUNT]\t\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_CHANNELS_TX_COUNT]\t\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_CHANNELS_OTHER_COUNT]\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_CHANNELS_COMBINED_COUNT]\t= { .type = NLA_U32 },\n};\n\nstatic int\nethnl_set_channels_validate(struct ethnl_req_info *req_info,\n\t\t\t    struct genl_info *info)\n{\n\tconst struct ethtool_ops *ops = req_info->dev->ethtool_ops;\n\n\treturn ops->get_channels && ops->set_channels ? 1 : -EOPNOTSUPP;\n}\n\nstatic int\nethnl_set_channels(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tunsigned int from_channel, old_total, i;\n\tbool mod = false, mod_combined = false;\n\tstruct net_device *dev = req_info->dev;\n\tstruct ethtool_channels channels = {};\n\tstruct nlattr **tb = info->attrs;\n\tu32 err_attr, max_rxfh_in_use;\n\tu64 max_rxnfc_in_use;\n\tint ret;\n\n\tdev->ethtool_ops->get_channels(dev, &channels);\n\told_total = channels.combined_count +\n\t\t    max(channels.rx_count, channels.tx_count);\n\n\tethnl_update_u32(&channels.rx_count, tb[ETHTOOL_A_CHANNELS_RX_COUNT],\n\t\t\t &mod);\n\tethnl_update_u32(&channels.tx_count, tb[ETHTOOL_A_CHANNELS_TX_COUNT],\n\t\t\t &mod);\n\tethnl_update_u32(&channels.other_count,\n\t\t\t tb[ETHTOOL_A_CHANNELS_OTHER_COUNT], &mod);\n\tethnl_update_u32(&channels.combined_count,\n\t\t\t tb[ETHTOOL_A_CHANNELS_COMBINED_COUNT], &mod_combined);\n\tmod |= mod_combined;\n\tif (!mod)\n\t\treturn 0;\n\n\t \n\tif (channels.rx_count > channels.max_rx)\n\t\terr_attr = ETHTOOL_A_CHANNELS_RX_COUNT;\n\telse if (channels.tx_count > channels.max_tx)\n\t\terr_attr = ETHTOOL_A_CHANNELS_TX_COUNT;\n\telse if (channels.other_count > channels.max_other)\n\t\terr_attr = ETHTOOL_A_CHANNELS_OTHER_COUNT;\n\telse if (channels.combined_count > channels.max_combined)\n\t\terr_attr = ETHTOOL_A_CHANNELS_COMBINED_COUNT;\n\telse\n\t\terr_attr = 0;\n\tif (err_attr) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, tb[err_attr],\n\t\t\t\t    \"requested channel count exceeds maximum\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!channels.combined_count && !channels.rx_count)\n\t\terr_attr = ETHTOOL_A_CHANNELS_RX_COUNT;\n\telse if (!channels.combined_count && !channels.tx_count)\n\t\terr_attr = ETHTOOL_A_CHANNELS_TX_COUNT;\n\telse\n\t\terr_attr = 0;\n\tif (err_attr) {\n\t\tif (mod_combined)\n\t\t\terr_attr = ETHTOOL_A_CHANNELS_COMBINED_COUNT;\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, tb[err_attr],\n\t\t\t\t    \"requested channel counts would result in no RX or TX channel being configured\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ethtool_get_max_rxnfc_channel(dev, &max_rxnfc_in_use))\n\t\tmax_rxnfc_in_use = 0;\n\tif (!netif_is_rxfh_configured(dev) ||\n\t    ethtool_get_max_rxfh_channel(dev, &max_rxfh_in_use))\n\t\tmax_rxfh_in_use = 0;\n\tif (channels.combined_count + channels.rx_count <= max_rxfh_in_use) {\n\t\tGENL_SET_ERR_MSG(info, \"requested channel counts are too low for existing indirection table settings\");\n\t\treturn -EINVAL;\n\t}\n\tif (channels.combined_count + channels.rx_count <= max_rxnfc_in_use) {\n\t\tGENL_SET_ERR_MSG(info, \"requested channel counts are too low for existing ntuple filter settings\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfrom_channel = channels.combined_count +\n\t\t       min(channels.rx_count, channels.tx_count);\n\tfor (i = from_channel; i < old_total; i++)\n\t\tif (xsk_get_pool_from_qid(dev, i)) {\n\t\t\tGENL_SET_ERR_MSG(info, \"requested channel counts are too low for existing zerocopy AF_XDP sockets\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tret = dev->ethtool_ops->set_channels(dev, &channels);\n\treturn ret < 0 ? ret : 1;\n}\n\nconst struct ethnl_request_ops ethnl_channels_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_CHANNELS_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_CHANNELS_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_CHANNELS_HEADER,\n\t.req_info_size\t\t= sizeof(struct channels_req_info),\n\t.reply_data_size\t= sizeof(struct channels_reply_data),\n\n\t.prepare_data\t\t= channels_prepare_data,\n\t.reply_size\t\t= channels_reply_size,\n\t.fill_reply\t\t= channels_fill_reply,\n\n\t.set_validate\t\t= ethnl_set_channels_validate,\n\t.set\t\t\t= ethnl_set_channels,\n\t.set_ntf_cmd\t\t= ETHTOOL_MSG_CHANNELS_NTF,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}