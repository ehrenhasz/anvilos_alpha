{
  "module_name": "rings.c",
  "hash_id": "a58f59d1d51db52f24f7e1229ad65c3b0b56bf237e1f686f41b1a2da7ce2385d",
  "original_prompt": "Ingested from linux-6.6.14/net/ethtool/rings.c",
  "human_readable_source": "\n\n#include \"netlink.h\"\n#include \"common.h\"\n\nstruct rings_req_info {\n\tstruct ethnl_req_info\t\tbase;\n};\n\nstruct rings_reply_data {\n\tstruct ethnl_reply_data\t\tbase;\n\tstruct ethtool_ringparam\tringparam;\n\tstruct kernel_ethtool_ringparam\tkernel_ringparam;\n\tu32\t\t\t\tsupported_ring_params;\n};\n\n#define RINGS_REPDATA(__reply_base) \\\n\tcontainer_of(__reply_base, struct rings_reply_data, base)\n\nconst struct nla_policy ethnl_rings_get_policy[] = {\n\t[ETHTOOL_A_RINGS_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n};\n\nstatic int rings_prepare_data(const struct ethnl_req_info *req_base,\n\t\t\t      struct ethnl_reply_data *reply_base,\n\t\t\t      const struct genl_info *info)\n{\n\tstruct rings_reply_data *data = RINGS_REPDATA(reply_base);\n\tstruct net_device *dev = reply_base->dev;\n\tint ret;\n\n\tif (!dev->ethtool_ops->get_ringparam)\n\t\treturn -EOPNOTSUPP;\n\n\tdata->supported_ring_params = dev->ethtool_ops->supported_ring_params;\n\tret = ethnl_ops_begin(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev->ethtool_ops->get_ringparam(dev, &data->ringparam,\n\t\t\t\t\t&data->kernel_ringparam, info->extack);\n\tethnl_ops_complete(dev);\n\n\treturn 0;\n}\n\nstatic int rings_reply_size(const struct ethnl_req_info *req_base,\n\t\t\t    const struct ethnl_reply_data *reply_base)\n{\n\treturn nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u8))  +\t \n\t       nla_total_size(sizeof(u32)  +\t \n\t       nla_total_size(sizeof(u8))  +\t \n\t       nla_total_size(sizeof(u8))) +\t \n\t       nla_total_size(sizeof(u32)) +\t \n\t       nla_total_size(sizeof(u32));\t \n}\n\nstatic int rings_fill_reply(struct sk_buff *skb,\n\t\t\t    const struct ethnl_req_info *req_base,\n\t\t\t    const struct ethnl_reply_data *reply_base)\n{\n\tconst struct rings_reply_data *data = RINGS_REPDATA(reply_base);\n\tconst struct kernel_ethtool_ringparam *kr = &data->kernel_ringparam;\n\tconst struct ethtool_ringparam *ringparam = &data->ringparam;\n\tu32 supported_ring_params = data->supported_ring_params;\n\n\tWARN_ON(kr->tcp_data_split > ETHTOOL_TCP_DATA_SPLIT_ENABLED);\n\n\tif ((ringparam->rx_max_pending &&\n\t     (nla_put_u32(skb, ETHTOOL_A_RINGS_RX_MAX,\n\t\t\t  ringparam->rx_max_pending) ||\n\t      nla_put_u32(skb, ETHTOOL_A_RINGS_RX,\n\t\t\t  ringparam->rx_pending))) ||\n\t    (ringparam->rx_mini_max_pending &&\n\t     (nla_put_u32(skb, ETHTOOL_A_RINGS_RX_MINI_MAX,\n\t\t\t  ringparam->rx_mini_max_pending) ||\n\t      nla_put_u32(skb, ETHTOOL_A_RINGS_RX_MINI,\n\t\t\t  ringparam->rx_mini_pending))) ||\n\t    (ringparam->rx_jumbo_max_pending &&\n\t     (nla_put_u32(skb, ETHTOOL_A_RINGS_RX_JUMBO_MAX,\n\t\t\t  ringparam->rx_jumbo_max_pending) ||\n\t      nla_put_u32(skb, ETHTOOL_A_RINGS_RX_JUMBO,\n\t\t\t  ringparam->rx_jumbo_pending))) ||\n\t    (ringparam->tx_max_pending &&\n\t     (nla_put_u32(skb, ETHTOOL_A_RINGS_TX_MAX,\n\t\t\t  ringparam->tx_max_pending) ||\n\t      nla_put_u32(skb, ETHTOOL_A_RINGS_TX,\n\t\t\t  ringparam->tx_pending)))  ||\n\t    (kr->rx_buf_len &&\n\t     (nla_put_u32(skb, ETHTOOL_A_RINGS_RX_BUF_LEN, kr->rx_buf_len))) ||\n\t    (kr->tcp_data_split &&\n\t     (nla_put_u8(skb, ETHTOOL_A_RINGS_TCP_DATA_SPLIT,\n\t\t\t kr->tcp_data_split))) ||\n\t    (kr->cqe_size &&\n\t     (nla_put_u32(skb, ETHTOOL_A_RINGS_CQE_SIZE, kr->cqe_size))) ||\n\t    nla_put_u8(skb, ETHTOOL_A_RINGS_TX_PUSH, !!kr->tx_push) ||\n\t    nla_put_u8(skb, ETHTOOL_A_RINGS_RX_PUSH, !!kr->rx_push) ||\n\t    ((supported_ring_params & ETHTOOL_RING_USE_TX_PUSH_BUF_LEN) &&\n\t     (nla_put_u32(skb, ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN_MAX,\n\t\t\t  kr->tx_push_buf_max_len) ||\n\t      nla_put_u32(skb, ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN,\n\t\t\t  kr->tx_push_buf_len))))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\n \n\nconst struct nla_policy ethnl_rings_set_policy[] = {\n\t[ETHTOOL_A_RINGS_HEADER]\t\t=\n\t\tNLA_POLICY_NESTED(ethnl_header_policy),\n\t[ETHTOOL_A_RINGS_RX]\t\t\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_RINGS_RX_MINI]\t\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_RINGS_RX_JUMBO]\t\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_RINGS_TX]\t\t\t= { .type = NLA_U32 },\n\t[ETHTOOL_A_RINGS_RX_BUF_LEN]            = NLA_POLICY_MIN(NLA_U32, 1),\n\t[ETHTOOL_A_RINGS_CQE_SIZE]\t\t= NLA_POLICY_MIN(NLA_U32, 1),\n\t[ETHTOOL_A_RINGS_TX_PUSH]\t\t= NLA_POLICY_MAX(NLA_U8, 1),\n\t[ETHTOOL_A_RINGS_RX_PUSH]\t\t= NLA_POLICY_MAX(NLA_U8, 1),\n\t[ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN]\t= { .type = NLA_U32 },\n};\n\nstatic int\nethnl_set_rings_validate(struct ethnl_req_info *req_info,\n\t\t\t struct genl_info *info)\n{\n\tconst struct ethtool_ops *ops = req_info->dev->ethtool_ops;\n\tstruct nlattr **tb = info->attrs;\n\n\tif (tb[ETHTOOL_A_RINGS_RX_BUF_LEN] &&\n\t    !(ops->supported_ring_params & ETHTOOL_RING_USE_RX_BUF_LEN)) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[ETHTOOL_A_RINGS_RX_BUF_LEN],\n\t\t\t\t    \"setting rx buf len not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[ETHTOOL_A_RINGS_CQE_SIZE] &&\n\t    !(ops->supported_ring_params & ETHTOOL_RING_USE_CQE_SIZE)) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[ETHTOOL_A_RINGS_CQE_SIZE],\n\t\t\t\t    \"setting cqe size not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[ETHTOOL_A_RINGS_TX_PUSH] &&\n\t    !(ops->supported_ring_params & ETHTOOL_RING_USE_TX_PUSH)) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[ETHTOOL_A_RINGS_TX_PUSH],\n\t\t\t\t    \"setting tx push not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[ETHTOOL_A_RINGS_RX_PUSH] &&\n\t    !(ops->supported_ring_params & ETHTOOL_RING_USE_RX_PUSH)) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[ETHTOOL_A_RINGS_RX_PUSH],\n\t\t\t\t    \"setting rx push not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN] &&\n\t    !(ops->supported_ring_params & ETHTOOL_RING_USE_TX_PUSH_BUF_LEN)) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN],\n\t\t\t\t    \"setting tx push buf len is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ops->get_ringparam && ops->set_ringparam ? 1 : -EOPNOTSUPP;\n}\n\nstatic int\nethnl_set_rings(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tstruct kernel_ethtool_ringparam kernel_ringparam = {};\n\tstruct ethtool_ringparam ringparam = {};\n\tstruct net_device *dev = req_info->dev;\n\tstruct nlattr **tb = info->attrs;\n\tconst struct nlattr *err_attr;\n\tbool mod = false;\n\tint ret;\n\n\tdev->ethtool_ops->get_ringparam(dev, &ringparam,\n\t\t\t\t\t&kernel_ringparam, info->extack);\n\n\tethnl_update_u32(&ringparam.rx_pending, tb[ETHTOOL_A_RINGS_RX], &mod);\n\tethnl_update_u32(&ringparam.rx_mini_pending,\n\t\t\t tb[ETHTOOL_A_RINGS_RX_MINI], &mod);\n\tethnl_update_u32(&ringparam.rx_jumbo_pending,\n\t\t\t tb[ETHTOOL_A_RINGS_RX_JUMBO], &mod);\n\tethnl_update_u32(&ringparam.tx_pending, tb[ETHTOOL_A_RINGS_TX], &mod);\n\tethnl_update_u32(&kernel_ringparam.rx_buf_len,\n\t\t\t tb[ETHTOOL_A_RINGS_RX_BUF_LEN], &mod);\n\tethnl_update_u32(&kernel_ringparam.cqe_size,\n\t\t\t tb[ETHTOOL_A_RINGS_CQE_SIZE], &mod);\n\tethnl_update_u8(&kernel_ringparam.tx_push,\n\t\t\ttb[ETHTOOL_A_RINGS_TX_PUSH], &mod);\n\tethnl_update_u8(&kernel_ringparam.rx_push,\n\t\t\ttb[ETHTOOL_A_RINGS_RX_PUSH], &mod);\n\tethnl_update_u32(&kernel_ringparam.tx_push_buf_len,\n\t\t\t tb[ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN], &mod);\n\tif (!mod)\n\t\treturn 0;\n\n\t \n\tif (ringparam.rx_pending > ringparam.rx_max_pending)\n\t\terr_attr = tb[ETHTOOL_A_RINGS_RX];\n\telse if (ringparam.rx_mini_pending > ringparam.rx_mini_max_pending)\n\t\terr_attr = tb[ETHTOOL_A_RINGS_RX_MINI];\n\telse if (ringparam.rx_jumbo_pending > ringparam.rx_jumbo_max_pending)\n\t\terr_attr = tb[ETHTOOL_A_RINGS_RX_JUMBO];\n\telse if (ringparam.tx_pending > ringparam.tx_max_pending)\n\t\terr_attr = tb[ETHTOOL_A_RINGS_TX];\n\telse\n\t\terr_attr = NULL;\n\tif (err_attr) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, err_attr,\n\t\t\t\t    \"requested ring size exceeds maximum\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (kernel_ringparam.tx_push_buf_len > kernel_ringparam.tx_push_buf_max_len) {\n\t\tNL_SET_ERR_MSG_ATTR_FMT(info->extack, tb[ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN],\n\t\t\t\t\t\"Requested TX push buffer exceeds the maximum of %u\",\n\t\t\t\t\tkernel_ringparam.tx_push_buf_max_len);\n\n\t\treturn -EINVAL;\n\t}\n\n\tret = dev->ethtool_ops->set_ringparam(dev, &ringparam,\n\t\t\t\t\t      &kernel_ringparam, info->extack);\n\treturn ret < 0 ? ret : 1;\n}\n\nconst struct ethnl_request_ops ethnl_rings_request_ops = {\n\t.request_cmd\t\t= ETHTOOL_MSG_RINGS_GET,\n\t.reply_cmd\t\t= ETHTOOL_MSG_RINGS_GET_REPLY,\n\t.hdr_attr\t\t= ETHTOOL_A_RINGS_HEADER,\n\t.req_info_size\t\t= sizeof(struct rings_req_info),\n\t.reply_data_size\t= sizeof(struct rings_reply_data),\n\n\t.prepare_data\t\t= rings_prepare_data,\n\t.reply_size\t\t= rings_reply_size,\n\t.fill_reply\t\t= rings_fill_reply,\n\n\t.set_validate\t\t= ethnl_set_rings_validate,\n\t.set\t\t\t= ethnl_set_rings,\n\t.set_ntf_cmd\t\t= ETHTOOL_MSG_RINGS_NTF,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}