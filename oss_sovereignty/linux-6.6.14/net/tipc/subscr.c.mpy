{
  "module_name": "subscr.c",
  "hash_id": "0c7fe03521c657066dbc29dd05b656bbe5b114aacff3ff6e6377d7d9662f42a1",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/subscr.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"name_table.h\"\n#include \"subscr.h\"\n\nstatic void tipc_sub_send_event(struct tipc_subscription *sub,\n\t\t\t\tstruct publication *p,\n\t\t\t\tu32 event)\n{\n\tstruct tipc_subscr *s = &sub->evt.s;\n\tstruct tipc_event *evt = &sub->evt;\n\n\tif (sub->inactive)\n\t\treturn;\n\ttipc_evt_write(evt, event, event);\n\tif (p) {\n\t\ttipc_evt_write(evt, found_lower, p->sr.lower);\n\t\ttipc_evt_write(evt, found_upper, p->sr.upper);\n\t\ttipc_evt_write(evt, port.ref, p->sk.ref);\n\t\ttipc_evt_write(evt, port.node, p->sk.node);\n\t} else {\n\t\ttipc_evt_write(evt, found_lower, s->seq.lower);\n\t\ttipc_evt_write(evt, found_upper, s->seq.upper);\n\t\ttipc_evt_write(evt, port.ref, 0);\n\t\ttipc_evt_write(evt, port.node, 0);\n\t}\n\ttipc_topsrv_queue_evt(sub->net, sub->conid, event, evt);\n}\n\n \nstatic bool tipc_sub_check_overlap(struct tipc_service_range *subscribed,\n\t\t\t\t   struct tipc_service_range *found)\n{\n\tu32 found_lower = found->lower;\n\tu32 found_upper = found->upper;\n\n\tif (found_lower < subscribed->lower)\n\t\tfound_lower = subscribed->lower;\n\tif (found_upper > subscribed->upper)\n\t\tfound_upper = subscribed->upper;\n\treturn found_lower <= found_upper;\n}\n\nvoid tipc_sub_report_overlap(struct tipc_subscription *sub,\n\t\t\t     struct publication *p,\n\t\t\t     u32 event, bool must)\n{\n\tstruct tipc_service_range *sr = &sub->s.seq;\n\tu32 filter = sub->s.filter;\n\n\tif (!tipc_sub_check_overlap(sr, &p->sr))\n\t\treturn;\n\tif (!must && !(filter & TIPC_SUB_PORTS))\n\t\treturn;\n\tif (filter & TIPC_SUB_CLUSTER_SCOPE && p->scope == TIPC_NODE_SCOPE)\n\t\treturn;\n\tif (filter & TIPC_SUB_NODE_SCOPE && p->scope != TIPC_NODE_SCOPE)\n\t\treturn;\n\tspin_lock(&sub->lock);\n\ttipc_sub_send_event(sub, p, event);\n\tspin_unlock(&sub->lock);\n}\n\nstatic void tipc_sub_timeout(struct timer_list *t)\n{\n\tstruct tipc_subscription *sub = from_timer(sub, t, timer);\n\n\tspin_lock(&sub->lock);\n\ttipc_sub_send_event(sub, NULL, TIPC_SUBSCR_TIMEOUT);\n\tsub->inactive = true;\n\tspin_unlock(&sub->lock);\n}\n\nstatic void tipc_sub_kref_release(struct kref *kref)\n{\n\tkfree(container_of(kref, struct tipc_subscription, kref));\n}\n\nvoid tipc_sub_put(struct tipc_subscription *subscription)\n{\n\tkref_put(&subscription->kref, tipc_sub_kref_release);\n}\n\nvoid tipc_sub_get(struct tipc_subscription *subscription)\n{\n\tkref_get(&subscription->kref);\n}\n\nstruct tipc_subscription *tipc_sub_subscribe(struct net *net,\n\t\t\t\t\t     struct tipc_subscr *s,\n\t\t\t\t\t     int conid)\n{\n\tu32 lower = tipc_sub_read(s, seq.lower);\n\tu32 upper = tipc_sub_read(s, seq.upper);\n\tu32 filter = tipc_sub_read(s, filter);\n\tstruct tipc_subscription *sub;\n\tu32 timeout;\n\n\tif ((filter & TIPC_SUB_PORTS && filter & TIPC_SUB_SERVICE) ||\n\t    lower > upper) {\n\t\tpr_warn(\"Subscription rejected, illegal request\\n\");\n\t\treturn NULL;\n\t}\n\tsub = kmalloc(sizeof(*sub), GFP_ATOMIC);\n\tif (!sub) {\n\t\tpr_warn(\"Subscription rejected, no memory\\n\");\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&sub->service_list);\n\tINIT_LIST_HEAD(&sub->sub_list);\n\tsub->net = net;\n\tsub->conid = conid;\n\tsub->inactive = false;\n\tmemcpy(&sub->evt.s, s, sizeof(*s));\n\tsub->s.seq.type = tipc_sub_read(s, seq.type);\n\tsub->s.seq.lower = lower;\n\tsub->s.seq.upper = upper;\n\tsub->s.filter = filter;\n\tsub->s.timeout = tipc_sub_read(s, timeout);\n\tmemcpy(sub->s.usr_handle, s->usr_handle, 8);\n\tspin_lock_init(&sub->lock);\n\tkref_init(&sub->kref);\n\tif (!tipc_nametbl_subscribe(sub)) {\n\t\tkfree(sub);\n\t\treturn NULL;\n\t}\n\ttimer_setup(&sub->timer, tipc_sub_timeout, 0);\n\ttimeout = tipc_sub_read(&sub->evt.s, timeout);\n\tif (timeout != TIPC_WAIT_FOREVER)\n\t\tmod_timer(&sub->timer, jiffies + msecs_to_jiffies(timeout));\n\treturn sub;\n}\n\nvoid tipc_sub_unsubscribe(struct tipc_subscription *sub)\n{\n\ttipc_nametbl_unsubscribe(sub);\n\tif (sub->evt.s.timeout != TIPC_WAIT_FOREVER)\n\t\tdel_timer_sync(&sub->timer);\n\tlist_del(&sub->sub_list);\n\ttipc_sub_put(sub);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}