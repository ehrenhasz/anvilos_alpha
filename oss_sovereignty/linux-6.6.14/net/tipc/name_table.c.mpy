{
  "module_name": "name_table.c",
  "hash_id": "d9a40afb593d831ed51d58a4dabfe0bbf46fd59c96863709163bb5513f0ad465",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/name_table.c",
  "human_readable_source": " \n\n#include <net/sock.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree_augmented.h>\n#include \"core.h\"\n#include \"netlink.h\"\n#include \"name_table.h\"\n#include \"name_distr.h\"\n#include \"subscr.h\"\n#include \"bcast.h\"\n#include \"addr.h\"\n#include \"node.h\"\n#include \"group.h\"\n\n \nstruct service_range {\n\tu32 lower;\n\tu32 upper;\n\tstruct rb_node tree_node;\n\tu32 max;\n\tstruct list_head local_publ;\n\tstruct list_head all_publ;\n};\n\n \nstruct tipc_service {\n\tu32 type;\n\tu32 publ_cnt;\n\tstruct rb_root ranges;\n\tstruct hlist_node service_list;\n\tstruct list_head subscriptions;\n\tspinlock_t lock;  \n\tstruct rcu_head rcu;\n};\n\n#define service_range_upper(sr) ((sr)->upper)\nRB_DECLARE_CALLBACKS_MAX(static, sr_callbacks,\n\t\t\t struct service_range, tree_node, u32, max,\n\t\t\t service_range_upper)\n\n#define service_range_entry(rbtree_node)\t\t\t\t\\\n\t(container_of(rbtree_node, struct service_range, tree_node))\n\n#define service_range_overlap(sr, start, end)\t\t\t\t\\\n\t((sr)->lower <= (end) && (sr)->upper >= (start))\n\n \n#define service_range_foreach_match(sr, sc, start, end)\t\t\t\\\n\tfor (sr = service_range_match_first((sc)->ranges.rb_node,\t\\\n\t\t\t\t\t    start,\t\t\t\\\n\t\t\t\t\t    end);\t\t\t\\\n\t     sr;\t\t\t\t\t\t\t\\\n\t     sr = service_range_match_next(&(sr)->tree_node,\t\t\\\n\t\t\t\t\t   start,\t\t\t\\\n\t\t\t\t\t   end))\n\n \nstatic struct service_range *service_range_match_first(struct rb_node *n,\n\t\t\t\t\t\t       u32 start, u32 end)\n{\n\tstruct service_range *sr;\n\tstruct rb_node *l, *r;\n\n\t \n\tif (!n || service_range_entry(n)->max < start)\n\t\treturn NULL;\n\n\twhile (n) {\n\t\tl = n->rb_left;\n\t\tif (l && service_range_entry(l)->max >= start) {\n\t\t\t \n\t\t\tn = l;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tsr = service_range_entry(n);\n\t\tif (service_range_overlap(sr, start, end))\n\t\t\treturn sr;\n\n\t\t \n\t\tr = n->rb_right;\n\t\tif (sr->lower <= end &&\n\t\t    r && service_range_entry(r)->max >= start) {\n\t\t\tn = r;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct service_range *service_range_match_next(struct rb_node *n,\n\t\t\t\t\t\t      u32 start, u32 end)\n{\n\tstruct service_range *sr;\n\tstruct rb_node *p, *r;\n\n\twhile (n) {\n\t\tr = n->rb_right;\n\t\tif (r && service_range_entry(r)->max >= start)\n\t\t\t \n\t\t\treturn service_range_match_first(r, start, end);\n\n\t\t \n\t\twhile ((p = rb_parent(n)) && n == p->rb_right)\n\t\t\tn = p;\n\t\tif (!p)\n\t\t\tbreak;\n\n\t\t \n\t\tsr = service_range_entry(p);\n\t\tif (service_range_overlap(sr, start, end))\n\t\t\treturn sr;\n\n\t\t \n\t\tif (sr->lower <= end) {\n\t\t\tn = p;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic int hash(int x)\n{\n\treturn x & (TIPC_NAMETBL_SIZE - 1);\n}\n\n \nstatic struct publication *tipc_publ_create(struct tipc_uaddr *ua,\n\t\t\t\t\t    struct tipc_socket_addr *sk,\n\t\t\t\t\t    u32 key)\n{\n\tstruct publication *p = kzalloc(sizeof(*p), GFP_ATOMIC);\n\n\tif (!p)\n\t\treturn NULL;\n\n\tp->sr = ua->sr;\n\tp->sk = *sk;\n\tp->scope = ua->scope;\n\tp->key = key;\n\tINIT_LIST_HEAD(&p->binding_sock);\n\tINIT_LIST_HEAD(&p->binding_node);\n\tINIT_LIST_HEAD(&p->local_publ);\n\tINIT_LIST_HEAD(&p->all_publ);\n\tINIT_LIST_HEAD(&p->list);\n\treturn p;\n}\n\n \nstatic struct tipc_service *tipc_service_create(struct net *net,\n\t\t\t\t\t\tstruct tipc_uaddr *ua)\n{\n\tstruct name_table *nt = tipc_name_table(net);\n\tstruct tipc_service *service;\n\tstruct hlist_head *hd;\n\n\tservice = kzalloc(sizeof(*service), GFP_ATOMIC);\n\tif (!service) {\n\t\tpr_warn(\"Service creation failed, no memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&service->lock);\n\tservice->type = ua->sr.type;\n\tservice->ranges = RB_ROOT;\n\tINIT_HLIST_NODE(&service->service_list);\n\tINIT_LIST_HEAD(&service->subscriptions);\n\thd = &nt->services[hash(ua->sr.type)];\n\thlist_add_head_rcu(&service->service_list, hd);\n\treturn service;\n}\n\n \nstatic struct service_range *tipc_service_find_range(struct tipc_service *sc,\n\t\t\t\t\t\t     struct tipc_uaddr *ua)\n{\n\tstruct service_range *sr;\n\n\tservice_range_foreach_match(sr, sc, ua->sr.lower, ua->sr.upper) {\n\t\t \n\t\tif (sr->lower == ua->sr.lower && sr->upper == ua->sr.upper)\n\t\t\treturn sr;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct service_range *tipc_service_create_range(struct tipc_service *sc,\n\t\t\t\t\t\t       struct publication *p)\n{\n\tstruct rb_node **n, *parent = NULL;\n\tstruct service_range *sr;\n\tu32 lower = p->sr.lower;\n\tu32 upper = p->sr.upper;\n\n\tn = &sc->ranges.rb_node;\n\twhile (*n) {\n\t\tparent = *n;\n\t\tsr = service_range_entry(parent);\n\t\tif (lower == sr->lower && upper == sr->upper)\n\t\t\treturn sr;\n\t\tif (sr->max < upper)\n\t\t\tsr->max = upper;\n\t\tif (lower <= sr->lower)\n\t\t\tn = &parent->rb_left;\n\t\telse\n\t\t\tn = &parent->rb_right;\n\t}\n\tsr = kzalloc(sizeof(*sr), GFP_ATOMIC);\n\tif (!sr)\n\t\treturn NULL;\n\tsr->lower = lower;\n\tsr->upper = upper;\n\tsr->max = upper;\n\tINIT_LIST_HEAD(&sr->local_publ);\n\tINIT_LIST_HEAD(&sr->all_publ);\n\trb_link_node(&sr->tree_node, parent, n);\n\trb_insert_augmented(&sr->tree_node, &sc->ranges, &sr_callbacks);\n\treturn sr;\n}\n\nstatic bool tipc_service_insert_publ(struct net *net,\n\t\t\t\t     struct tipc_service *sc,\n\t\t\t\t     struct publication *p)\n{\n\tstruct tipc_subscription *sub, *tmp;\n\tstruct service_range *sr;\n\tstruct publication *_p;\n\tu32 node = p->sk.node;\n\tbool first = false;\n\tbool res = false;\n\tu32 key = p->key;\n\n\tspin_lock_bh(&sc->lock);\n\tsr = tipc_service_create_range(sc, p);\n\tif (!sr)\n\t\tgoto  exit;\n\n\tfirst = list_empty(&sr->all_publ);\n\n\t \n\tlist_for_each_entry(_p, &sr->all_publ, all_publ) {\n\t\tif (_p->key == key && (!_p->sk.node || _p->sk.node == node)) {\n\t\t\tpr_debug(\"Failed to bind duplicate %u,%u,%u/%u:%u/%u\\n\",\n\t\t\t\t p->sr.type, p->sr.lower, p->sr.upper,\n\t\t\t\t node, p->sk.ref, key);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (in_own_node(net, p->sk.node))\n\t\tlist_add(&p->local_publ, &sr->local_publ);\n\tlist_add(&p->all_publ, &sr->all_publ);\n\tp->id = sc->publ_cnt++;\n\n\t \n\tlist_for_each_entry_safe(sub, tmp, &sc->subscriptions, service_list) {\n\t\ttipc_sub_report_overlap(sub, p, TIPC_PUBLISHED, first);\n\t}\n\tres = true;\nexit:\n\tif (!res)\n\t\tpr_warn(\"Failed to bind to %u,%u,%u\\n\",\n\t\t\tp->sr.type, p->sr.lower, p->sr.upper);\n\tspin_unlock_bh(&sc->lock);\n\treturn res;\n}\n\n \nstatic struct publication *tipc_service_remove_publ(struct service_range *r,\n\t\t\t\t\t\t    struct tipc_socket_addr *sk,\n\t\t\t\t\t\t    u32 key)\n{\n\tstruct publication *p;\n\tu32 node = sk->node;\n\n\tlist_for_each_entry(p, &r->all_publ, all_publ) {\n\t\tif (p->key != key || (node && node != p->sk.node))\n\t\t\tcontinue;\n\t\tlist_del(&p->all_publ);\n\t\tlist_del(&p->local_publ);\n\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n \n#define publication_after(pa, pb) time_after32((pa)->id, (pb)->id)\nstatic int tipc_publ_sort(void *priv, const struct list_head *a,\n\t\t\t  const struct list_head *b)\n{\n\tstruct publication *pa, *pb;\n\n\tpa = container_of(a, struct publication, list);\n\tpb = container_of(b, struct publication, list);\n\treturn publication_after(pa, pb);\n}\n\n \nstatic void tipc_service_subscribe(struct tipc_service *service,\n\t\t\t\t   struct tipc_subscription *sub)\n{\n\tstruct publication *p, *first, *tmp;\n\tstruct list_head publ_list;\n\tstruct service_range *sr;\n\tu32 filter, lower, upper;\n\n\tfilter = sub->s.filter;\n\tlower = sub->s.seq.lower;\n\tupper = sub->s.seq.upper;\n\n\ttipc_sub_get(sub);\n\tlist_add(&sub->service_list, &service->subscriptions);\n\n\tif (filter & TIPC_SUB_NO_STATUS)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&publ_list);\n\tservice_range_foreach_match(sr, service, lower, upper) {\n\t\tfirst = NULL;\n\t\tlist_for_each_entry(p, &sr->all_publ, all_publ) {\n\t\t\tif (filter & TIPC_SUB_PORTS)\n\t\t\t\tlist_add_tail(&p->list, &publ_list);\n\t\t\telse if (!first || publication_after(first, p))\n\t\t\t\t \n\t\t\t\tfirst = p;\n\t\t}\n\t\tif (first)\n\t\t\tlist_add_tail(&first->list, &publ_list);\n\t}\n\n\t \n\tlist_sort(NULL, &publ_list, tipc_publ_sort);\n\tlist_for_each_entry_safe(p, tmp, &publ_list, list) {\n\t\ttipc_sub_report_overlap(sub, p, TIPC_PUBLISHED, true);\n\t\tlist_del_init(&p->list);\n\t}\n}\n\nstatic struct tipc_service *tipc_service_find(struct net *net,\n\t\t\t\t\t      struct tipc_uaddr *ua)\n{\n\tstruct name_table *nt = tipc_name_table(net);\n\tstruct hlist_head *service_head;\n\tstruct tipc_service *service;\n\n\tservice_head = &nt->services[hash(ua->sr.type)];\n\thlist_for_each_entry_rcu(service, service_head, service_list) {\n\t\tif (service->type == ua->sr.type)\n\t\t\treturn service;\n\t}\n\treturn NULL;\n};\n\nstruct publication *tipc_nametbl_insert_publ(struct net *net,\n\t\t\t\t\t     struct tipc_uaddr *ua,\n\t\t\t\t\t     struct tipc_socket_addr *sk,\n\t\t\t\t\t     u32 key)\n{\n\tstruct tipc_service *sc;\n\tstruct publication *p;\n\n\tp = tipc_publ_create(ua, sk, key);\n\tif (!p)\n\t\treturn NULL;\n\n\tsc = tipc_service_find(net, ua);\n\tif (!sc)\n\t\tsc = tipc_service_create(net, ua);\n\tif (sc && tipc_service_insert_publ(net, sc, p))\n\t\treturn p;\n\tkfree(p);\n\treturn NULL;\n}\n\nstruct publication *tipc_nametbl_remove_publ(struct net *net,\n\t\t\t\t\t     struct tipc_uaddr *ua,\n\t\t\t\t\t     struct tipc_socket_addr *sk,\n\t\t\t\t\t     u32 key)\n{\n\tstruct tipc_subscription *sub, *tmp;\n\tstruct publication *p = NULL;\n\tstruct service_range *sr;\n\tstruct tipc_service *sc;\n\tbool last;\n\n\tsc = tipc_service_find(net, ua);\n\tif (!sc)\n\t\tgoto exit;\n\n\tspin_lock_bh(&sc->lock);\n\tsr = tipc_service_find_range(sc, ua);\n\tif (!sr)\n\t\tgoto unlock;\n\tp = tipc_service_remove_publ(sr, sk, key);\n\tif (!p)\n\t\tgoto unlock;\n\n\t \n\tlast = list_empty(&sr->all_publ);\n\tlist_for_each_entry_safe(sub, tmp, &sc->subscriptions, service_list) {\n\t\ttipc_sub_report_overlap(sub, p, TIPC_WITHDRAWN, last);\n\t}\n\n\t \n\tif (list_empty(&sr->all_publ)) {\n\t\trb_erase_augmented(&sr->tree_node, &sc->ranges, &sr_callbacks);\n\t\tkfree(sr);\n\t}\n\n\t \n\tif (RB_EMPTY_ROOT(&sc->ranges) && list_empty(&sc->subscriptions)) {\n\t\thlist_del_init_rcu(&sc->service_list);\n\t\tkfree_rcu(sc, rcu);\n\t}\nunlock:\n\tspin_unlock_bh(&sc->lock);\nexit:\n\tif (!p) {\n\t\tpr_err(\"Failed to remove unknown binding: %u,%u,%u/%u:%u/%u\\n\",\n\t\t       ua->sr.type, ua->sr.lower, ua->sr.upper,\n\t\t       sk->node, sk->ref, key);\n\t}\n\treturn p;\n}\n\n \nbool tipc_nametbl_lookup_anycast(struct net *net,\n\t\t\t\t struct tipc_uaddr *ua,\n\t\t\t\t struct tipc_socket_addr *sk)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tbool legacy = tn->legacy_addr_format;\n\tu32 self = tipc_own_addr(net);\n\tu32 inst = ua->sa.instance;\n\tstruct service_range *r;\n\tstruct tipc_service *sc;\n\tstruct publication *p;\n\tstruct list_head *l;\n\tbool res = false;\n\n\tif (!tipc_in_scope(legacy, sk->node, self))\n\t\treturn true;\n\n\trcu_read_lock();\n\tsc = tipc_service_find(net, ua);\n\tif (unlikely(!sc))\n\t\tgoto exit;\n\n\tspin_lock_bh(&sc->lock);\n\tservice_range_foreach_match(r, sc, inst, inst) {\n\t\t \n\t\tif (sk->node == self) {\n\t\t\tl = &r->local_publ;\n\t\t\tif (list_empty(l))\n\t\t\t\tcontinue;\n\t\t\tp = list_first_entry(l, struct publication, local_publ);\n\t\t\tlist_move_tail(&p->local_publ, &r->local_publ);\n\t\t} else if (legacy && !sk->node && !list_empty(&r->local_publ)) {\n\t\t\tl = &r->local_publ;\n\t\t\tp = list_first_entry(l, struct publication, local_publ);\n\t\t\tlist_move_tail(&p->local_publ, &r->local_publ);\n\t\t} else {\n\t\t\tl = &r->all_publ;\n\t\t\tp = list_first_entry(l, struct publication, all_publ);\n\t\t\tlist_move_tail(&p->all_publ, &r->all_publ);\n\t\t}\n\t\t*sk = p->sk;\n\t\tres = true;\n\t\t \n\t\tbreak;\n\t}\n\tspin_unlock_bh(&sc->lock);\n\nexit:\n\trcu_read_unlock();\n\treturn res;\n}\n\n \nbool tipc_nametbl_lookup_group(struct net *net, struct tipc_uaddr *ua,\n\t\t\t       struct list_head *dsts, int *dstcnt,\n\t\t\t       u32 exclude, bool mcast)\n{\n\tu32 self = tipc_own_addr(net);\n\tu32 inst = ua->sa.instance;\n\tstruct service_range *sr;\n\tstruct tipc_service *sc;\n\tstruct publication *p;\n\n\t*dstcnt = 0;\n\trcu_read_lock();\n\tsc = tipc_service_find(net, ua);\n\tif (unlikely(!sc))\n\t\tgoto exit;\n\n\tspin_lock_bh(&sc->lock);\n\n\t \n\tsr = service_range_match_first(sc->ranges.rb_node, inst, inst);\n\tif (!sr)\n\t\tgoto no_match;\n\n\tlist_for_each_entry(p, &sr->all_publ, all_publ) {\n\t\tif (p->scope != ua->scope)\n\t\t\tcontinue;\n\t\tif (p->sk.ref == exclude && p->sk.node == self)\n\t\t\tcontinue;\n\t\ttipc_dest_push(dsts, p->sk.node, p->sk.ref);\n\t\t(*dstcnt)++;\n\t\tif (mcast)\n\t\t\tcontinue;\n\t\tlist_move_tail(&p->all_publ, &sr->all_publ);\n\t\tbreak;\n\t}\nno_match:\n\tspin_unlock_bh(&sc->lock);\nexit:\n\trcu_read_unlock();\n\treturn !list_empty(dsts);\n}\n\n \nvoid tipc_nametbl_lookup_mcast_sockets(struct net *net, struct tipc_uaddr *ua,\n\t\t\t\t       struct list_head *dports)\n{\n\tstruct service_range *sr;\n\tstruct tipc_service *sc;\n\tstruct publication *p;\n\tu8 scope = ua->scope;\n\n\trcu_read_lock();\n\tsc = tipc_service_find(net, ua);\n\tif (!sc)\n\t\tgoto exit;\n\n\tspin_lock_bh(&sc->lock);\n\tservice_range_foreach_match(sr, sc, ua->sr.lower, ua->sr.upper) {\n\t\tlist_for_each_entry(p, &sr->local_publ, local_publ) {\n\t\t\tif (scope == p->scope || scope == TIPC_ANY_SCOPE)\n\t\t\t\ttipc_dest_push(dports, 0, p->sk.ref);\n\t\t}\n\t}\n\tspin_unlock_bh(&sc->lock);\nexit:\n\trcu_read_unlock();\n}\n\n \nvoid tipc_nametbl_lookup_mcast_nodes(struct net *net, struct tipc_uaddr *ua,\n\t\t\t\t     struct tipc_nlist *nodes)\n{\n\tstruct service_range *sr;\n\tstruct tipc_service *sc;\n\tstruct publication *p;\n\n\trcu_read_lock();\n\tsc = tipc_service_find(net, ua);\n\tif (!sc)\n\t\tgoto exit;\n\n\tspin_lock_bh(&sc->lock);\n\tservice_range_foreach_match(sr, sc, ua->sr.lower, ua->sr.upper) {\n\t\tlist_for_each_entry(p, &sr->all_publ, all_publ) {\n\t\t\ttipc_nlist_add(nodes, p->sk.node);\n\t\t}\n\t}\n\tspin_unlock_bh(&sc->lock);\nexit:\n\trcu_read_unlock();\n}\n\n \nvoid tipc_nametbl_build_group(struct net *net, struct tipc_group *grp,\n\t\t\t      struct tipc_uaddr *ua)\n{\n\tstruct service_range *sr;\n\tstruct tipc_service *sc;\n\tstruct publication *p;\n\tstruct rb_node *n;\n\n\trcu_read_lock();\n\tsc = tipc_service_find(net, ua);\n\tif (!sc)\n\t\tgoto exit;\n\n\tspin_lock_bh(&sc->lock);\n\tfor (n = rb_first(&sc->ranges); n; n = rb_next(n)) {\n\t\tsr = container_of(n, struct service_range, tree_node);\n\t\tlist_for_each_entry(p, &sr->all_publ, all_publ) {\n\t\t\tif (p->scope != ua->scope)\n\t\t\t\tcontinue;\n\t\t\ttipc_group_add_member(grp, p->sk.node, p->sk.ref,\n\t\t\t\t\t      p->sr.lower);\n\t\t}\n\t}\n\tspin_unlock_bh(&sc->lock);\nexit:\n\trcu_read_unlock();\n}\n\n \nstruct publication *tipc_nametbl_publish(struct net *net, struct tipc_uaddr *ua,\n\t\t\t\t\t struct tipc_socket_addr *sk, u32 key)\n{\n\tstruct name_table *nt = tipc_name_table(net);\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct publication *p = NULL;\n\tstruct sk_buff *skb = NULL;\n\tu32 rc_dests;\n\n\tspin_lock_bh(&tn->nametbl_lock);\n\n\tif (nt->local_publ_count >= TIPC_MAX_PUBL) {\n\t\tpr_warn(\"Bind failed, max limit %u reached\\n\", TIPC_MAX_PUBL);\n\t\tgoto exit;\n\t}\n\n\tp = tipc_nametbl_insert_publ(net, ua, sk, key);\n\tif (p) {\n\t\tnt->local_publ_count++;\n\t\tskb = tipc_named_publish(net, p);\n\t}\n\trc_dests = nt->rc_dests;\nexit:\n\tspin_unlock_bh(&tn->nametbl_lock);\n\n\tif (skb)\n\t\ttipc_node_broadcast(net, skb, rc_dests);\n\treturn p;\n\n}\n\n \nvoid tipc_nametbl_withdraw(struct net *net, struct tipc_uaddr *ua,\n\t\t\t   struct tipc_socket_addr *sk, u32 key)\n{\n\tstruct name_table *nt = tipc_name_table(net);\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct sk_buff *skb = NULL;\n\tstruct publication *p;\n\tu32 rc_dests;\n\n\tspin_lock_bh(&tn->nametbl_lock);\n\n\tp = tipc_nametbl_remove_publ(net, ua, sk, key);\n\tif (p) {\n\t\tnt->local_publ_count--;\n\t\tskb = tipc_named_withdraw(net, p);\n\t\tlist_del_init(&p->binding_sock);\n\t\tkfree_rcu(p, rcu);\n\t}\n\trc_dests = nt->rc_dests;\n\tspin_unlock_bh(&tn->nametbl_lock);\n\n\tif (skb)\n\t\ttipc_node_broadcast(net, skb, rc_dests);\n}\n\n \nbool tipc_nametbl_subscribe(struct tipc_subscription *sub)\n{\n\tstruct tipc_net *tn = tipc_net(sub->net);\n\tu32 type = sub->s.seq.type;\n\tstruct tipc_service *sc;\n\tstruct tipc_uaddr ua;\n\tbool res = true;\n\n\ttipc_uaddr(&ua, TIPC_SERVICE_RANGE, TIPC_NODE_SCOPE, type,\n\t\t   sub->s.seq.lower, sub->s.seq.upper);\n\tspin_lock_bh(&tn->nametbl_lock);\n\tsc = tipc_service_find(sub->net, &ua);\n\tif (!sc)\n\t\tsc = tipc_service_create(sub->net, &ua);\n\tif (sc) {\n\t\tspin_lock_bh(&sc->lock);\n\t\ttipc_service_subscribe(sc, sub);\n\t\tspin_unlock_bh(&sc->lock);\n\t} else {\n\t\tpr_warn(\"Failed to subscribe for {%u,%u,%u}\\n\",\n\t\t\ttype, sub->s.seq.lower, sub->s.seq.upper);\n\t\tres = false;\n\t}\n\tspin_unlock_bh(&tn->nametbl_lock);\n\treturn res;\n}\n\n \nvoid tipc_nametbl_unsubscribe(struct tipc_subscription *sub)\n{\n\tstruct tipc_net *tn = tipc_net(sub->net);\n\tstruct tipc_service *sc;\n\tstruct tipc_uaddr ua;\n\n\ttipc_uaddr(&ua, TIPC_SERVICE_RANGE, TIPC_NODE_SCOPE,\n\t\t   sub->s.seq.type, sub->s.seq.lower, sub->s.seq.upper);\n\tspin_lock_bh(&tn->nametbl_lock);\n\tsc = tipc_service_find(sub->net, &ua);\n\tif (!sc)\n\t\tgoto exit;\n\n\tspin_lock_bh(&sc->lock);\n\tlist_del_init(&sub->service_list);\n\ttipc_sub_put(sub);\n\n\t \n\tif (RB_EMPTY_ROOT(&sc->ranges) && list_empty(&sc->subscriptions)) {\n\t\thlist_del_init_rcu(&sc->service_list);\n\t\tkfree_rcu(sc, rcu);\n\t}\n\tspin_unlock_bh(&sc->lock);\nexit:\n\tspin_unlock_bh(&tn->nametbl_lock);\n}\n\nint tipc_nametbl_init(struct net *net)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct name_table *nt;\n\tint i;\n\n\tnt = kzalloc(sizeof(*nt), GFP_KERNEL);\n\tif (!nt)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < TIPC_NAMETBL_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&nt->services[i]);\n\n\tINIT_LIST_HEAD(&nt->node_scope);\n\tINIT_LIST_HEAD(&nt->cluster_scope);\n\trwlock_init(&nt->cluster_scope_lock);\n\ttn->nametbl = nt;\n\tspin_lock_init(&tn->nametbl_lock);\n\treturn 0;\n}\n\n \nstatic void tipc_service_delete(struct net *net, struct tipc_service *sc)\n{\n\tstruct service_range *sr, *tmpr;\n\tstruct publication *p, *tmp;\n\n\tspin_lock_bh(&sc->lock);\n\trbtree_postorder_for_each_entry_safe(sr, tmpr, &sc->ranges, tree_node) {\n\t\tlist_for_each_entry_safe(p, tmp, &sr->all_publ, all_publ) {\n\t\t\ttipc_service_remove_publ(sr, &p->sk, p->key);\n\t\t\tkfree_rcu(p, rcu);\n\t\t}\n\t\trb_erase_augmented(&sr->tree_node, &sc->ranges, &sr_callbacks);\n\t\tkfree(sr);\n\t}\n\thlist_del_init_rcu(&sc->service_list);\n\tspin_unlock_bh(&sc->lock);\n\tkfree_rcu(sc, rcu);\n}\n\nvoid tipc_nametbl_stop(struct net *net)\n{\n\tstruct name_table *nt = tipc_name_table(net);\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct hlist_head *service_head;\n\tstruct tipc_service *service;\n\tu32 i;\n\n\t \n\tspin_lock_bh(&tn->nametbl_lock);\n\tfor (i = 0; i < TIPC_NAMETBL_SIZE; i++) {\n\t\tif (hlist_empty(&nt->services[i]))\n\t\t\tcontinue;\n\t\tservice_head = &nt->services[i];\n\t\thlist_for_each_entry_rcu(service, service_head, service_list) {\n\t\t\ttipc_service_delete(net, service);\n\t\t}\n\t}\n\tspin_unlock_bh(&tn->nametbl_lock);\n\n\tsynchronize_net();\n\tkfree(nt);\n}\n\nstatic int __tipc_nl_add_nametable_publ(struct tipc_nl_msg *msg,\n\t\t\t\t\tstruct tipc_service *service,\n\t\t\t\t\tstruct service_range *sr,\n\t\t\t\t\tu32 *last_key)\n{\n\tstruct publication *p;\n\tstruct nlattr *attrs;\n\tstruct nlattr *b;\n\tvoid *hdr;\n\n\tif (*last_key) {\n\t\tlist_for_each_entry(p, &sr->all_publ, all_publ)\n\t\t\tif (p->key == *last_key)\n\t\t\t\tbreak;\n\t\tif (list_entry_is_head(p, &sr->all_publ, all_publ))\n\t\t\treturn -EPIPE;\n\t} else {\n\t\tp = list_first_entry(&sr->all_publ,\n\t\t\t\t     struct publication,\n\t\t\t\t     all_publ);\n\t}\n\n\tlist_for_each_entry_from(p, &sr->all_publ, all_publ) {\n\t\t*last_key = p->key;\n\n\t\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq,\n\t\t\t\t  &tipc_genl_family, NLM_F_MULTI,\n\t\t\t\t  TIPC_NL_NAME_TABLE_GET);\n\t\tif (!hdr)\n\t\t\treturn -EMSGSIZE;\n\n\t\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_NAME_TABLE);\n\t\tif (!attrs)\n\t\t\tgoto msg_full;\n\n\t\tb = nla_nest_start_noflag(msg->skb, TIPC_NLA_NAME_TABLE_PUBL);\n\t\tif (!b)\n\t\t\tgoto attr_msg_full;\n\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_TYPE, service->type))\n\t\t\tgoto publ_msg_full;\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_LOWER, sr->lower))\n\t\t\tgoto publ_msg_full;\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_UPPER, sr->upper))\n\t\t\tgoto publ_msg_full;\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_SCOPE, p->scope))\n\t\t\tgoto publ_msg_full;\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_NODE, p->sk.node))\n\t\t\tgoto publ_msg_full;\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_REF, p->sk.ref))\n\t\t\tgoto publ_msg_full;\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_KEY, p->key))\n\t\t\tgoto publ_msg_full;\n\n\t\tnla_nest_end(msg->skb, b);\n\t\tnla_nest_end(msg->skb, attrs);\n\t\tgenlmsg_end(msg->skb, hdr);\n\t}\n\t*last_key = 0;\n\n\treturn 0;\n\npubl_msg_full:\n\tnla_nest_cancel(msg->skb, b);\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nstatic int __tipc_nl_service_range_list(struct tipc_nl_msg *msg,\n\t\t\t\t\tstruct tipc_service *sc,\n\t\t\t\t\tu32 *last_lower, u32 *last_key)\n{\n\tstruct service_range *sr;\n\tstruct rb_node *n;\n\tint err;\n\n\tfor (n = rb_first(&sc->ranges); n; n = rb_next(n)) {\n\t\tsr = container_of(n, struct service_range, tree_node);\n\t\tif (sr->lower < *last_lower)\n\t\t\tcontinue;\n\t\terr = __tipc_nl_add_nametable_publ(msg, sc, sr, last_key);\n\t\tif (err) {\n\t\t\t*last_lower = sr->lower;\n\t\t\treturn err;\n\t\t}\n\t}\n\t*last_lower = 0;\n\treturn 0;\n}\n\nstatic int tipc_nl_service_list(struct net *net, struct tipc_nl_msg *msg,\n\t\t\t\tu32 *last_type, u32 *last_lower, u32 *last_key)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_service *service = NULL;\n\tstruct hlist_head *head;\n\tstruct tipc_uaddr ua;\n\tint err;\n\tint i;\n\n\tif (*last_type)\n\t\ti = hash(*last_type);\n\telse\n\t\ti = 0;\n\n\tfor (; i < TIPC_NAMETBL_SIZE; i++) {\n\t\thead = &tn->nametbl->services[i];\n\n\t\tif (*last_type ||\n\t\t    (!i && *last_key && (*last_lower == *last_key))) {\n\t\t\ttipc_uaddr(&ua, TIPC_SERVICE_RANGE, TIPC_NODE_SCOPE,\n\t\t\t\t   *last_type, *last_lower, *last_lower);\n\t\t\tservice = tipc_service_find(net, &ua);\n\t\t\tif (!service)\n\t\t\t\treturn -EPIPE;\n\t\t} else {\n\t\t\thlist_for_each_entry_rcu(service, head, service_list)\n\t\t\t\tbreak;\n\t\t\tif (!service)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\thlist_for_each_entry_from_rcu(service, service_list) {\n\t\t\tspin_lock_bh(&service->lock);\n\t\t\terr = __tipc_nl_service_range_list(msg, service,\n\t\t\t\t\t\t\t   last_lower,\n\t\t\t\t\t\t\t   last_key);\n\n\t\t\tif (err) {\n\t\t\t\t*last_type = service->type;\n\t\t\t\tspin_unlock_bh(&service->lock);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tspin_unlock_bh(&service->lock);\n\t\t}\n\t\t*last_type = 0;\n\t}\n\treturn 0;\n}\n\nint tipc_nl_name_table_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tu32 last_type = cb->args[0];\n\tu32 last_lower = cb->args[1];\n\tu32 last_key = cb->args[2];\n\tint done = cb->args[3];\n\tstruct tipc_nl_msg msg;\n\tint err;\n\n\tif (done)\n\t\treturn 0;\n\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\n\trcu_read_lock();\n\terr = tipc_nl_service_list(net, &msg, &last_type,\n\t\t\t\t   &last_lower, &last_key);\n\tif (!err) {\n\t\tdone = 1;\n\t} else if (err != -EMSGSIZE) {\n\t\t \n\t\tcb->prev_seq = 1;\n\t}\n\trcu_read_unlock();\n\n\tcb->args[0] = last_type;\n\tcb->args[1] = last_lower;\n\tcb->args[2] = last_key;\n\tcb->args[3] = done;\n\n\treturn skb->len;\n}\n\nstruct tipc_dest *tipc_dest_find(struct list_head *l, u32 node, u32 port)\n{\n\tstruct tipc_dest *dst;\n\n\tlist_for_each_entry(dst, l, list) {\n\t\tif (dst->node == node && dst->port == port)\n\t\t\treturn dst;\n\t}\n\treturn NULL;\n}\n\nbool tipc_dest_push(struct list_head *l, u32 node, u32 port)\n{\n\tstruct tipc_dest *dst;\n\n\tif (tipc_dest_find(l, node, port))\n\t\treturn false;\n\n\tdst = kmalloc(sizeof(*dst), GFP_ATOMIC);\n\tif (unlikely(!dst))\n\t\treturn false;\n\tdst->node = node;\n\tdst->port = port;\n\tlist_add(&dst->list, l);\n\treturn true;\n}\n\nbool tipc_dest_pop(struct list_head *l, u32 *node, u32 *port)\n{\n\tstruct tipc_dest *dst;\n\n\tif (list_empty(l))\n\t\treturn false;\n\tdst = list_first_entry(l, typeof(*dst), list);\n\tif (port)\n\t\t*port = dst->port;\n\tif (node)\n\t\t*node = dst->node;\n\tlist_del(&dst->list);\n\tkfree(dst);\n\treturn true;\n}\n\nbool tipc_dest_del(struct list_head *l, u32 node, u32 port)\n{\n\tstruct tipc_dest *dst;\n\n\tdst = tipc_dest_find(l, node, port);\n\tif (!dst)\n\t\treturn false;\n\tlist_del(&dst->list);\n\tkfree(dst);\n\treturn true;\n}\n\nvoid tipc_dest_list_purge(struct list_head *l)\n{\n\tstruct tipc_dest *dst, *tmp;\n\n\tlist_for_each_entry_safe(dst, tmp, l, list) {\n\t\tlist_del(&dst->list);\n\t\tkfree(dst);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}