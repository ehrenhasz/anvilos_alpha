{
  "module_name": "group.c",
  "hash_id": "804cd50ac4535f83e30a8c32a1086c166a73885e81d2abfff51caa6d14393c14",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/group.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"addr.h\"\n#include \"group.h\"\n#include \"bcast.h\"\n#include \"topsrv.h\"\n#include \"msg.h\"\n#include \"socket.h\"\n#include \"node.h\"\n#include \"name_table.h\"\n#include \"subscr.h\"\n\n#define ADV_UNIT (((MAX_MSG_SIZE + MAX_H_SIZE) / FLOWCTL_BLK_SZ) + 1)\n#define ADV_IDLE ADV_UNIT\n#define ADV_ACTIVE (ADV_UNIT * 12)\n\nenum mbr_state {\n\tMBR_JOINING,\n\tMBR_PUBLISHED,\n\tMBR_JOINED,\n\tMBR_PENDING,\n\tMBR_ACTIVE,\n\tMBR_RECLAIMING,\n\tMBR_REMITTED,\n\tMBR_LEAVING\n};\n\nstruct tipc_member {\n\tstruct rb_node tree_node;\n\tstruct list_head list;\n\tstruct list_head small_win;\n\tstruct sk_buff_head deferredq;\n\tstruct tipc_group *group;\n\tu32 node;\n\tu32 port;\n\tu32 instance;\n\tenum mbr_state state;\n\tu16 advertised;\n\tu16 window;\n\tu16 bc_rcv_nxt;\n\tu16 bc_syncpt;\n\tu16 bc_acked;\n};\n\nstruct tipc_group {\n\tstruct rb_root members;\n\tstruct list_head small_win;\n\tstruct list_head pending;\n\tstruct list_head active;\n\tstruct tipc_nlist dests;\n\tstruct net *net;\n\tint subid;\n\tu32 type;\n\tu32 instance;\n\tu32 scope;\n\tu32 portid;\n\tu16 member_cnt;\n\tu16 active_cnt;\n\tu16 max_active;\n\tu16 bc_snd_nxt;\n\tu16 bc_ackers;\n\tbool *open;\n\tbool loopback;\n\tbool events;\n};\n\nstatic void tipc_group_proto_xmit(struct tipc_group *grp, struct tipc_member *m,\n\t\t\t\t  int mtyp, struct sk_buff_head *xmitq);\n\nstatic void tipc_group_open(struct tipc_member *m, bool *wakeup)\n{\n\t*wakeup = false;\n\tif (list_empty(&m->small_win))\n\t\treturn;\n\tlist_del_init(&m->small_win);\n\t*m->group->open = true;\n\t*wakeup = true;\n}\n\nstatic void tipc_group_decr_active(struct tipc_group *grp,\n\t\t\t\t   struct tipc_member *m)\n{\n\tif (m->state == MBR_ACTIVE || m->state == MBR_RECLAIMING ||\n\t    m->state == MBR_REMITTED)\n\t\tgrp->active_cnt--;\n}\n\nstatic int tipc_group_rcvbuf_limit(struct tipc_group *grp)\n{\n\tint max_active, active_pool, idle_pool;\n\tint mcnt = grp->member_cnt + 1;\n\n\t \n\tmax_active = min(mcnt / 8, 64);\n\tmax_active = max(max_active, 16);\n\tgrp->max_active = max_active;\n\n\t \n\tactive_pool = max_active * ADV_ACTIVE;\n\tidle_pool = (mcnt - max_active) * ADV_IDLE;\n\n\t \n\treturn (active_pool + idle_pool) * FLOWCTL_BLK_SZ * 4;\n}\n\nu16 tipc_group_bc_snd_nxt(struct tipc_group *grp)\n{\n\treturn grp->bc_snd_nxt;\n}\n\nstatic bool tipc_group_is_receiver(struct tipc_member *m)\n{\n\treturn m && m->state != MBR_JOINING && m->state != MBR_LEAVING;\n}\n\nstatic bool tipc_group_is_sender(struct tipc_member *m)\n{\n\treturn m && m->state != MBR_JOINING && m->state != MBR_PUBLISHED;\n}\n\nu32 tipc_group_exclude(struct tipc_group *grp)\n{\n\tif (!grp->loopback)\n\t\treturn grp->portid;\n\treturn 0;\n}\n\nstruct tipc_group *tipc_group_create(struct net *net, u32 portid,\n\t\t\t\t     struct tipc_group_req *mreq,\n\t\t\t\t     bool *group_is_open)\n{\n\tu32 filter = TIPC_SUB_PORTS | TIPC_SUB_NO_STATUS;\n\tbool global = mreq->scope != TIPC_NODE_SCOPE;\n\tstruct tipc_group *grp;\n\tu32 type = mreq->type;\n\n\tgrp = kzalloc(sizeof(*grp), GFP_ATOMIC);\n\tif (!grp)\n\t\treturn NULL;\n\ttipc_nlist_init(&grp->dests, tipc_own_addr(net));\n\tINIT_LIST_HEAD(&grp->small_win);\n\tINIT_LIST_HEAD(&grp->active);\n\tINIT_LIST_HEAD(&grp->pending);\n\tgrp->members = RB_ROOT;\n\tgrp->net = net;\n\tgrp->portid = portid;\n\tgrp->type = type;\n\tgrp->instance = mreq->instance;\n\tgrp->scope = mreq->scope;\n\tgrp->loopback = mreq->flags & TIPC_GROUP_LOOPBACK;\n\tgrp->events = mreq->flags & TIPC_GROUP_MEMBER_EVTS;\n\tgrp->open = group_is_open;\n\t*grp->open = false;\n\tfilter |= global ? TIPC_SUB_CLUSTER_SCOPE : TIPC_SUB_NODE_SCOPE;\n\tif (tipc_topsrv_kern_subscr(net, portid, type, 0, ~0,\n\t\t\t\t    filter, &grp->subid))\n\t\treturn grp;\n\tkfree(grp);\n\treturn NULL;\n}\n\nvoid tipc_group_join(struct net *net, struct tipc_group *grp, int *sk_rcvbuf)\n{\n\tstruct rb_root *tree = &grp->members;\n\tstruct tipc_member *m, *tmp;\n\tstruct sk_buff_head xmitq;\n\n\t__skb_queue_head_init(&xmitq);\n\trbtree_postorder_for_each_entry_safe(m, tmp, tree, tree_node) {\n\t\ttipc_group_proto_xmit(grp, m, GRP_JOIN_MSG, &xmitq);\n\t\ttipc_group_update_member(m, 0);\n\t}\n\ttipc_node_distr_xmit(net, &xmitq);\n\t*sk_rcvbuf = tipc_group_rcvbuf_limit(grp);\n}\n\nvoid tipc_group_delete(struct net *net, struct tipc_group *grp)\n{\n\tstruct rb_root *tree = &grp->members;\n\tstruct tipc_member *m, *tmp;\n\tstruct sk_buff_head xmitq;\n\n\t__skb_queue_head_init(&xmitq);\n\n\trbtree_postorder_for_each_entry_safe(m, tmp, tree, tree_node) {\n\t\ttipc_group_proto_xmit(grp, m, GRP_LEAVE_MSG, &xmitq);\n\t\t__skb_queue_purge(&m->deferredq);\n\t\tlist_del(&m->list);\n\t\tkfree(m);\n\t}\n\ttipc_node_distr_xmit(net, &xmitq);\n\ttipc_nlist_purge(&grp->dests);\n\ttipc_topsrv_kern_unsubscr(net, grp->subid);\n\tkfree(grp);\n}\n\nstatic struct tipc_member *tipc_group_find_member(struct tipc_group *grp,\n\t\t\t\t\t\t  u32 node, u32 port)\n{\n\tstruct rb_node *n = grp->members.rb_node;\n\tu64 nkey, key = (u64)node << 32 | port;\n\tstruct tipc_member *m;\n\n\twhile (n) {\n\t\tm = container_of(n, struct tipc_member, tree_node);\n\t\tnkey = (u64)m->node << 32 | m->port;\n\t\tif (key < nkey)\n\t\t\tn = n->rb_left;\n\t\telse if (key > nkey)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn m;\n\t}\n\treturn NULL;\n}\n\nstatic struct tipc_member *tipc_group_find_dest(struct tipc_group *grp,\n\t\t\t\t\t\tu32 node, u32 port)\n{\n\tstruct tipc_member *m;\n\n\tm = tipc_group_find_member(grp, node, port);\n\tif (m && tipc_group_is_receiver(m))\n\t\treturn m;\n\treturn NULL;\n}\n\nstatic struct tipc_member *tipc_group_find_node(struct tipc_group *grp,\n\t\t\t\t\t\tu32 node)\n{\n\tstruct tipc_member *m;\n\tstruct rb_node *n;\n\n\tfor (n = rb_first(&grp->members); n; n = rb_next(n)) {\n\t\tm = container_of(n, struct tipc_member, tree_node);\n\t\tif (m->node == node)\n\t\t\treturn m;\n\t}\n\treturn NULL;\n}\n\nstatic int tipc_group_add_to_tree(struct tipc_group *grp,\n\t\t\t\t  struct tipc_member *m)\n{\n\tu64 nkey, key = (u64)m->node << 32 | m->port;\n\tstruct rb_node **n, *parent = NULL;\n\tstruct tipc_member *tmp;\n\n\tn = &grp->members.rb_node;\n\twhile (*n) {\n\t\ttmp = container_of(*n, struct tipc_member, tree_node);\n\t\tparent = *n;\n\t\ttmp = container_of(parent, struct tipc_member, tree_node);\n\t\tnkey = (u64)tmp->node << 32 | tmp->port;\n\t\tif (key < nkey)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (key > nkey)\n\t\t\tn = &(*n)->rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\trb_link_node(&m->tree_node, parent, n);\n\trb_insert_color(&m->tree_node, &grp->members);\n\treturn 0;\n}\n\nstatic struct tipc_member *tipc_group_create_member(struct tipc_group *grp,\n\t\t\t\t\t\t    u32 node, u32 port,\n\t\t\t\t\t\t    u32 instance, int state)\n{\n\tstruct tipc_member *m;\n\tint ret;\n\n\tm = kzalloc(sizeof(*m), GFP_ATOMIC);\n\tif (!m)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&m->list);\n\tINIT_LIST_HEAD(&m->small_win);\n\t__skb_queue_head_init(&m->deferredq);\n\tm->group = grp;\n\tm->node = node;\n\tm->port = port;\n\tm->instance = instance;\n\tm->bc_acked = grp->bc_snd_nxt - 1;\n\tret = tipc_group_add_to_tree(grp, m);\n\tif (ret < 0) {\n\t\tkfree(m);\n\t\treturn NULL;\n\t}\n\tgrp->member_cnt++;\n\ttipc_nlist_add(&grp->dests, m->node);\n\tm->state = state;\n\treturn m;\n}\n\nvoid tipc_group_add_member(struct tipc_group *grp, u32 node,\n\t\t\t   u32 port, u32 instance)\n{\n\ttipc_group_create_member(grp, node, port, instance, MBR_PUBLISHED);\n}\n\nstatic void tipc_group_delete_member(struct tipc_group *grp,\n\t\t\t\t     struct tipc_member *m)\n{\n\trb_erase(&m->tree_node, &grp->members);\n\tgrp->member_cnt--;\n\n\t \n\tif (grp->bc_ackers && less(m->bc_acked, grp->bc_snd_nxt - 1))\n\t\tgrp->bc_ackers--;\n\n\tlist_del_init(&m->list);\n\tlist_del_init(&m->small_win);\n\ttipc_group_decr_active(grp, m);\n\n\t \n\tif (!tipc_group_find_node(grp, m->node))\n\t\ttipc_nlist_del(&grp->dests, m->node);\n\n\tkfree(m);\n}\n\nstruct tipc_nlist *tipc_group_dests(struct tipc_group *grp)\n{\n\treturn &grp->dests;\n}\n\nvoid tipc_group_self(struct tipc_group *grp, struct tipc_service_range *seq,\n\t\t     int *scope)\n{\n\tseq->type = grp->type;\n\tseq->lower = grp->instance;\n\tseq->upper = grp->instance;\n\t*scope = grp->scope;\n}\n\nvoid tipc_group_update_member(struct tipc_member *m, int len)\n{\n\tstruct tipc_group *grp = m->group;\n\tstruct tipc_member *_m, *tmp;\n\n\tif (!tipc_group_is_receiver(m))\n\t\treturn;\n\n\tm->window -= len;\n\n\tif (m->window >= ADV_IDLE)\n\t\treturn;\n\n\tlist_del_init(&m->small_win);\n\n\t \n\tlist_for_each_entry_safe(_m, tmp, &grp->small_win, small_win) {\n\t\tif (_m->window > m->window)\n\t\t\tbreak;\n\t}\n\tlist_add_tail(&m->small_win, &_m->small_win);\n}\n\nvoid tipc_group_update_bc_members(struct tipc_group *grp, int len, bool ack)\n{\n\tu16 prev = grp->bc_snd_nxt - 1;\n\tstruct tipc_member *m;\n\tstruct rb_node *n;\n\tu16 ackers = 0;\n\n\tfor (n = rb_first(&grp->members); n; n = rb_next(n)) {\n\t\tm = container_of(n, struct tipc_member, tree_node);\n\t\tif (tipc_group_is_receiver(m)) {\n\t\t\ttipc_group_update_member(m, len);\n\t\t\tm->bc_acked = prev;\n\t\t\tackers++;\n\t\t}\n\t}\n\n\t \n\tif (ack)\n\t\tgrp->bc_ackers = ackers;\n\tgrp->bc_snd_nxt++;\n}\n\nbool tipc_group_cong(struct tipc_group *grp, u32 dnode, u32 dport,\n\t\t     int len, struct tipc_member **mbr)\n{\n\tstruct sk_buff_head xmitq;\n\tstruct tipc_member *m;\n\tint adv, state;\n\n\tm = tipc_group_find_dest(grp, dnode, dport);\n\tif (!tipc_group_is_receiver(m)) {\n\t\t*mbr = NULL;\n\t\treturn false;\n\t}\n\t*mbr = m;\n\n\tif (m->window >= len)\n\t\treturn false;\n\n\t*grp->open = false;\n\n\t \n\tadv = m->advertised;\n\tstate = m->state;\n\tif (state == MBR_JOINED && adv == ADV_IDLE)\n\t\treturn true;\n\tif (state == MBR_ACTIVE && adv == ADV_ACTIVE)\n\t\treturn true;\n\tif (state == MBR_PENDING && adv == ADV_IDLE)\n\t\treturn true;\n\t__skb_queue_head_init(&xmitq);\n\ttipc_group_proto_xmit(grp, m, GRP_ADV_MSG, &xmitq);\n\ttipc_node_distr_xmit(grp->net, &xmitq);\n\treturn true;\n}\n\nbool tipc_group_bc_cong(struct tipc_group *grp, int len)\n{\n\tstruct tipc_member *m = NULL;\n\n\t \n\tif (grp->bc_ackers) {\n\t\t*grp->open = false;\n\t\treturn true;\n\t}\n\tif (list_empty(&grp->small_win))\n\t\treturn false;\n\n\tm = list_first_entry(&grp->small_win, struct tipc_member, small_win);\n\tif (m->window >= len)\n\t\treturn false;\n\n\treturn tipc_group_cong(grp, m->node, m->port, len, &m);\n}\n\n \nstatic void tipc_group_sort_msg(struct sk_buff *skb, struct sk_buff_head *defq)\n{\n\tstruct tipc_msg *_hdr, *hdr = buf_msg(skb);\n\tu16 bc_seqno = msg_grp_bc_seqno(hdr);\n\tstruct sk_buff *_skb, *tmp;\n\tint mtyp = msg_type(hdr);\n\n\t \n\tif (mtyp == TIPC_GRP_BCAST_MSG || mtyp == TIPC_GRP_MCAST_MSG) {\n\t\tskb_queue_walk_safe(defq, _skb, tmp) {\n\t\t\t_hdr = buf_msg(_skb);\n\t\t\tif (!less(bc_seqno, msg_grp_bc_seqno(_hdr)))\n\t\t\t\tcontinue;\n\t\t\t__skb_queue_before(defq, _skb, skb);\n\t\t\treturn;\n\t\t}\n\t\t \n\t}\n\t \n\t__skb_queue_tail(defq, skb);\n}\n\n \nvoid tipc_group_filter_msg(struct tipc_group *grp, struct sk_buff_head *inputq,\n\t\t\t   struct sk_buff_head *xmitq)\n{\n\tstruct sk_buff *skb = __skb_dequeue(inputq);\n\tbool ack, deliver, update, leave = false;\n\tstruct sk_buff_head *defq;\n\tstruct tipc_member *m;\n\tstruct tipc_msg *hdr;\n\tu32 node, port;\n\tint mtyp, blks;\n\n\tif (!skb)\n\t\treturn;\n\n\thdr = buf_msg(skb);\n\tnode =  msg_orignode(hdr);\n\tport = msg_origport(hdr);\n\n\tif (!msg_in_group(hdr))\n\t\tgoto drop;\n\n\tm = tipc_group_find_member(grp, node, port);\n\tif (!tipc_group_is_sender(m))\n\t\tgoto drop;\n\n\tif (less(msg_grp_bc_seqno(hdr), m->bc_rcv_nxt))\n\t\tgoto drop;\n\n\tTIPC_SKB_CB(skb)->orig_member = m->instance;\n\tdefq = &m->deferredq;\n\ttipc_group_sort_msg(skb, defq);\n\n\twhile ((skb = skb_peek(defq))) {\n\t\thdr = buf_msg(skb);\n\t\tmtyp = msg_type(hdr);\n\t\tblks = msg_blocks(hdr);\n\t\tdeliver = true;\n\t\tack = false;\n\t\tupdate = false;\n\n\t\tif (more(msg_grp_bc_seqno(hdr), m->bc_rcv_nxt))\n\t\t\tbreak;\n\n\t\t \n\t\tswitch (mtyp) {\n\t\tcase TIPC_GRP_MCAST_MSG:\n\t\t\tif (msg_nameinst(hdr) != grp->instance) {\n\t\t\t\tupdate = true;\n\t\t\t\tdeliver = false;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase TIPC_GRP_BCAST_MSG:\n\t\t\tm->bc_rcv_nxt++;\n\t\t\tack = msg_grp_bc_ack_req(hdr);\n\t\t\tbreak;\n\t\tcase TIPC_GRP_UCAST_MSG:\n\t\t\tbreak;\n\t\tcase TIPC_GRP_MEMBER_EVT:\n\t\t\tif (m->state == MBR_LEAVING)\n\t\t\t\tleave = true;\n\t\t\tif (!grp->events)\n\t\t\t\tdeliver = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t__skb_dequeue(defq);\n\t\tif (deliver)\n\t\t\t__skb_queue_tail(inputq, skb);\n\t\telse\n\t\t\tkfree_skb(skb);\n\n\t\tif (ack)\n\t\t\ttipc_group_proto_xmit(grp, m, GRP_ACK_MSG, xmitq);\n\n\t\tif (leave) {\n\t\t\t__skb_queue_purge(defq);\n\t\t\ttipc_group_delete_member(grp, m);\n\t\t\tbreak;\n\t\t}\n\t\tif (!update)\n\t\t\tcontinue;\n\n\t\ttipc_group_update_rcv_win(grp, blks, node, port, xmitq);\n\t}\n\treturn;\ndrop:\n\tkfree_skb(skb);\n}\n\nvoid tipc_group_update_rcv_win(struct tipc_group *grp, int blks, u32 node,\n\t\t\t       u32 port, struct sk_buff_head *xmitq)\n{\n\tstruct list_head *active = &grp->active;\n\tint max_active = grp->max_active;\n\tint reclaim_limit = max_active * 3 / 4;\n\tint active_cnt = grp->active_cnt;\n\tstruct tipc_member *m, *rm, *pm;\n\n\tm = tipc_group_find_member(grp, node, port);\n\tif (!m)\n\t\treturn;\n\n\tm->advertised -= blks;\n\n\tswitch (m->state) {\n\tcase MBR_JOINED:\n\t\t \n\t\tif (active_cnt <= max_active) {\n\t\t\tm->state = MBR_ACTIVE;\n\t\t\tlist_add_tail(&m->list, active);\n\t\t\tgrp->active_cnt++;\n\t\t\ttipc_group_proto_xmit(grp, m, GRP_ADV_MSG, xmitq);\n\t\t} else {\n\t\t\tm->state = MBR_PENDING;\n\t\t\tlist_add_tail(&m->list, &grp->pending);\n\t\t}\n\n\t\tif (active_cnt < reclaim_limit)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!list_empty(active)) {\n\t\t\trm = list_first_entry(active, struct tipc_member, list);\n\t\t\trm->state = MBR_RECLAIMING;\n\t\t\tlist_del_init(&rm->list);\n\t\t\ttipc_group_proto_xmit(grp, rm, GRP_RECLAIM_MSG, xmitq);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tpm = list_first_entry(&grp->pending, struct tipc_member, list);\n\t\tlist_del_init(&pm->list);\n\t\tpm->state = MBR_JOINED;\n\t\ttipc_group_proto_xmit(grp, pm, GRP_ADV_MSG, xmitq);\n\t\tbreak;\n\tcase MBR_ACTIVE:\n\t\tif (!list_is_last(&m->list, &grp->active))\n\t\t\tlist_move_tail(&m->list, &grp->active);\n\t\tif (m->advertised > (ADV_ACTIVE * 3 / 4))\n\t\t\tbreak;\n\t\ttipc_group_proto_xmit(grp, m, GRP_ADV_MSG, xmitq);\n\t\tbreak;\n\tcase MBR_REMITTED:\n\t\tif (m->advertised > ADV_IDLE)\n\t\t\tbreak;\n\t\tm->state = MBR_JOINED;\n\t\tgrp->active_cnt--;\n\t\tif (m->advertised < ADV_IDLE) {\n\t\t\tpr_warn_ratelimited(\"Rcv unexpected msg after REMIT\\n\");\n\t\t\ttipc_group_proto_xmit(grp, m, GRP_ADV_MSG, xmitq);\n\t\t}\n\n\t\tif (list_empty(&grp->pending))\n\t\t\treturn;\n\n\t\t \n\t\tpm = list_first_entry(&grp->pending, struct tipc_member, list);\n\t\tpm->state = MBR_ACTIVE;\n\t\tlist_move_tail(&pm->list, &grp->active);\n\t\tgrp->active_cnt++;\n\t\ttipc_group_proto_xmit(grp, pm, GRP_ADV_MSG, xmitq);\n\t\tbreak;\n\tcase MBR_RECLAIMING:\n\tcase MBR_JOINING:\n\tcase MBR_LEAVING:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void tipc_group_create_event(struct tipc_group *grp,\n\t\t\t\t    struct tipc_member *m,\n\t\t\t\t    u32 event, u16 seqno,\n\t\t\t\t    struct sk_buff_head *inputq)\n{\tu32 dnode = tipc_own_addr(grp->net);\n\tstruct tipc_event evt;\n\tstruct sk_buff *skb;\n\tstruct tipc_msg *hdr;\n\n\tmemset(&evt, 0, sizeof(evt));\n\tevt.event = event;\n\tevt.found_lower = m->instance;\n\tevt.found_upper = m->instance;\n\tevt.port.ref = m->port;\n\tevt.port.node = m->node;\n\tevt.s.seq.type = grp->type;\n\tevt.s.seq.lower = m->instance;\n\tevt.s.seq.upper = m->instance;\n\n\tskb = tipc_msg_create(TIPC_CRITICAL_IMPORTANCE, TIPC_GRP_MEMBER_EVT,\n\t\t\t      GROUP_H_SIZE, sizeof(evt), dnode, m->node,\n\t\t\t      grp->portid, m->port, 0);\n\tif (!skb)\n\t\treturn;\n\n\thdr = buf_msg(skb);\n\tmsg_set_nametype(hdr, grp->type);\n\tmsg_set_grp_evt(hdr, event);\n\tmsg_set_dest_droppable(hdr, true);\n\tmsg_set_grp_bc_seqno(hdr, seqno);\n\tmemcpy(msg_data(hdr), &evt, sizeof(evt));\n\tTIPC_SKB_CB(skb)->orig_member = m->instance;\n\t__skb_queue_tail(inputq, skb);\n}\n\nstatic void tipc_group_proto_xmit(struct tipc_group *grp, struct tipc_member *m,\n\t\t\t\t  int mtyp, struct sk_buff_head *xmitq)\n{\n\tstruct tipc_msg *hdr;\n\tstruct sk_buff *skb;\n\tint adv = 0;\n\n\tskb = tipc_msg_create(GROUP_PROTOCOL, mtyp, INT_H_SIZE, 0,\n\t\t\t      m->node, tipc_own_addr(grp->net),\n\t\t\t      m->port, grp->portid, 0);\n\tif (!skb)\n\t\treturn;\n\n\tif (m->state == MBR_ACTIVE)\n\t\tadv = ADV_ACTIVE - m->advertised;\n\telse if (m->state == MBR_JOINED || m->state == MBR_PENDING)\n\t\tadv = ADV_IDLE - m->advertised;\n\n\thdr = buf_msg(skb);\n\n\tif (mtyp == GRP_JOIN_MSG) {\n\t\tmsg_set_grp_bc_syncpt(hdr, grp->bc_snd_nxt);\n\t\tmsg_set_adv_win(hdr, adv);\n\t\tm->advertised += adv;\n\t} else if (mtyp == GRP_LEAVE_MSG) {\n\t\tmsg_set_grp_bc_syncpt(hdr, grp->bc_snd_nxt);\n\t} else if (mtyp == GRP_ADV_MSG) {\n\t\tmsg_set_adv_win(hdr, adv);\n\t\tm->advertised += adv;\n\t} else if (mtyp == GRP_ACK_MSG) {\n\t\tmsg_set_grp_bc_acked(hdr, m->bc_rcv_nxt);\n\t} else if (mtyp == GRP_REMIT_MSG) {\n\t\tmsg_set_grp_remitted(hdr, m->window);\n\t}\n\tmsg_set_dest_droppable(hdr, true);\n\t__skb_queue_tail(xmitq, skb);\n}\n\nvoid tipc_group_proto_rcv(struct tipc_group *grp, bool *usr_wakeup,\n\t\t\t  struct tipc_msg *hdr, struct sk_buff_head *inputq,\n\t\t\t  struct sk_buff_head *xmitq)\n{\n\tu32 node = msg_orignode(hdr);\n\tu32 port = msg_origport(hdr);\n\tstruct tipc_member *m, *pm;\n\tu16 remitted, in_flight;\n\n\tif (!grp)\n\t\treturn;\n\n\tif (grp->scope == TIPC_NODE_SCOPE && node != tipc_own_addr(grp->net))\n\t\treturn;\n\n\tm = tipc_group_find_member(grp, node, port);\n\n\tswitch (msg_type(hdr)) {\n\tcase GRP_JOIN_MSG:\n\t\tif (!m)\n\t\t\tm = tipc_group_create_member(grp, node, port,\n\t\t\t\t\t\t     0, MBR_JOINING);\n\t\tif (!m)\n\t\t\treturn;\n\t\tm->bc_syncpt = msg_grp_bc_syncpt(hdr);\n\t\tm->bc_rcv_nxt = m->bc_syncpt;\n\t\tm->window += msg_adv_win(hdr);\n\n\t\t \n\t\tif (m->state != MBR_PUBLISHED)\n\t\t\treturn;\n\n\t\t \n\t\tm->state = MBR_JOINED;\n\t\ttipc_group_open(m, usr_wakeup);\n\t\ttipc_group_update_member(m, 0);\n\t\ttipc_group_proto_xmit(grp, m, GRP_ADV_MSG, xmitq);\n\t\ttipc_group_create_event(grp, m, TIPC_PUBLISHED,\n\t\t\t\t\tm->bc_syncpt, inputq);\n\t\treturn;\n\tcase GRP_LEAVE_MSG:\n\t\tif (!m)\n\t\t\treturn;\n\t\tm->bc_syncpt = msg_grp_bc_syncpt(hdr);\n\t\tlist_del_init(&m->list);\n\t\ttipc_group_open(m, usr_wakeup);\n\t\ttipc_group_decr_active(grp, m);\n\t\tm->state = MBR_LEAVING;\n\t\ttipc_group_create_event(grp, m, TIPC_WITHDRAWN,\n\t\t\t\t\tm->bc_syncpt, inputq);\n\t\treturn;\n\tcase GRP_ADV_MSG:\n\t\tif (!m)\n\t\t\treturn;\n\t\tm->window += msg_adv_win(hdr);\n\t\ttipc_group_open(m, usr_wakeup);\n\t\treturn;\n\tcase GRP_ACK_MSG:\n\t\tif (!m)\n\t\t\treturn;\n\t\tm->bc_acked = msg_grp_bc_acked(hdr);\n\t\tif (--grp->bc_ackers)\n\t\t\treturn;\n\t\tlist_del_init(&m->small_win);\n\t\t*m->group->open = true;\n\t\t*usr_wakeup = true;\n\t\ttipc_group_update_member(m, 0);\n\t\treturn;\n\tcase GRP_RECLAIM_MSG:\n\t\tif (!m)\n\t\t\treturn;\n\t\ttipc_group_proto_xmit(grp, m, GRP_REMIT_MSG, xmitq);\n\t\tm->window = ADV_IDLE;\n\t\ttipc_group_open(m, usr_wakeup);\n\t\treturn;\n\tcase GRP_REMIT_MSG:\n\t\tif (!m || m->state != MBR_RECLAIMING)\n\t\t\treturn;\n\n\t\tremitted = msg_grp_remitted(hdr);\n\n\t\t \n\t\tif (m->advertised > remitted) {\n\t\t\tm->state = MBR_REMITTED;\n\t\t\tin_flight = m->advertised - remitted;\n\t\t\tm->advertised = ADV_IDLE + in_flight;\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (m->advertised < remitted)\n\t\t\tpr_warn_ratelimited(\"Unexpected REMIT msg\\n\");\n\n\t\t \n\t\tm->state = MBR_JOINED;\n\t\tgrp->active_cnt--;\n\t\tm->advertised = ADV_IDLE;\n\n\t\t \n\t\tif (list_empty(&grp->pending))\n\t\t\treturn;\n\t\tpm = list_first_entry(&grp->pending, struct tipc_member, list);\n\t\tpm->state = MBR_ACTIVE;\n\t\tlist_move_tail(&pm->list, &grp->active);\n\t\tgrp->active_cnt++;\n\t\tif (pm->advertised <= (ADV_ACTIVE * 3 / 4))\n\t\t\ttipc_group_proto_xmit(grp, pm, GRP_ADV_MSG, xmitq);\n\t\treturn;\n\tdefault:\n\t\tpr_warn(\"Received unknown GROUP_PROTO message\\n\");\n\t}\n}\n\n \nvoid tipc_group_member_evt(struct tipc_group *grp,\n\t\t\t   bool *usr_wakeup,\n\t\t\t   int *sk_rcvbuf,\n\t\t\t   struct tipc_msg *hdr,\n\t\t\t   struct sk_buff_head *inputq,\n\t\t\t   struct sk_buff_head *xmitq)\n{\n\tstruct tipc_event *evt = (void *)msg_data(hdr);\n\tu32 instance = evt->found_lower;\n\tu32 node = evt->port.node;\n\tu32 port = evt->port.ref;\n\tint event = evt->event;\n\tstruct tipc_member *m;\n\tstruct net *net;\n\tu32 self;\n\n\tif (!grp)\n\t\treturn;\n\n\tnet = grp->net;\n\tself = tipc_own_addr(net);\n\tif (!grp->loopback && node == self && port == grp->portid)\n\t\treturn;\n\n\tm = tipc_group_find_member(grp, node, port);\n\n\tswitch (event) {\n\tcase TIPC_PUBLISHED:\n\t\t \n\t\tif (!m) {\n\t\t\tm = tipc_group_create_member(grp, node, port, instance,\n\t\t\t\t\t\t     MBR_PUBLISHED);\n\t\t\tif (!m)\n\t\t\t\tbreak;\n\t\t\ttipc_group_update_member(m, 0);\n\t\t\ttipc_group_proto_xmit(grp, m, GRP_JOIN_MSG, xmitq);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->state != MBR_JOINING)\n\t\t\tbreak;\n\n\t\t \n\t\tm->instance = instance;\n\t\tm->state = MBR_JOINED;\n\t\ttipc_group_open(m, usr_wakeup);\n\t\ttipc_group_update_member(m, 0);\n\t\ttipc_group_proto_xmit(grp, m, GRP_JOIN_MSG, xmitq);\n\t\ttipc_group_create_event(grp, m, TIPC_PUBLISHED,\n\t\t\t\t\tm->bc_syncpt, inputq);\n\t\tbreak;\n\tcase TIPC_WITHDRAWN:\n\t\tif (!m)\n\t\t\tbreak;\n\n\t\ttipc_group_decr_active(grp, m);\n\t\tm->state = MBR_LEAVING;\n\t\tlist_del_init(&m->list);\n\t\ttipc_group_open(m, usr_wakeup);\n\n\t\t \n\t\tif (!tipc_node_is_up(net, node))\n\t\t\ttipc_group_create_event(grp, m, TIPC_WITHDRAWN,\n\t\t\t\t\t\tm->bc_rcv_nxt, inputq);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t*sk_rcvbuf = tipc_group_rcvbuf_limit(grp);\n}\n\nint tipc_group_fill_sock_diag(struct tipc_group *grp, struct sk_buff *skb)\n{\n\tstruct nlattr *group = nla_nest_start_noflag(skb, TIPC_NLA_SOCK_GROUP);\n\n\tif (!group)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, TIPC_NLA_SOCK_GROUP_ID,\n\t\t\tgrp->type) ||\n\t    nla_put_u32(skb, TIPC_NLA_SOCK_GROUP_INSTANCE,\n\t\t\tgrp->instance) ||\n\t    nla_put_u32(skb, TIPC_NLA_SOCK_GROUP_BC_SEND_NEXT,\n\t\t\tgrp->bc_snd_nxt))\n\t\tgoto group_msg_cancel;\n\n\tif (grp->scope == TIPC_NODE_SCOPE)\n\t\tif (nla_put_flag(skb, TIPC_NLA_SOCK_GROUP_NODE_SCOPE))\n\t\t\tgoto group_msg_cancel;\n\n\tif (grp->scope == TIPC_CLUSTER_SCOPE)\n\t\tif (nla_put_flag(skb, TIPC_NLA_SOCK_GROUP_CLUSTER_SCOPE))\n\t\t\tgoto group_msg_cancel;\n\n\tif (*grp->open)\n\t\tif (nla_put_flag(skb, TIPC_NLA_SOCK_GROUP_OPEN))\n\t\t\tgoto group_msg_cancel;\n\n\tnla_nest_end(skb, group);\n\treturn 0;\n\ngroup_msg_cancel:\n\tnla_nest_cancel(skb, group);\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}