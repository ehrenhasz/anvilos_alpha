{
  "module_name": "monitor.c",
  "hash_id": "a078df598c9601f50172ab1ef6a78194274d64af80042975acb34a210e0c2a17",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/monitor.c",
  "human_readable_source": " \n\n#include <net/genetlink.h>\n#include \"core.h\"\n#include \"addr.h\"\n#include \"monitor.h\"\n#include \"bearer.h\"\n\n#define MAX_MON_DOMAIN       64\n#define MON_TIMEOUT          120000\n#define MAX_PEER_DOWN_EVENTS 4\n\n \nstruct tipc_mon_domain {\n\tu16 len;\n\tu16 gen;\n\tu16 ack_gen;\n\tu16 member_cnt;\n\tu64 up_map;\n\tu32 members[MAX_MON_DOMAIN];\n};\n\n \nstruct tipc_peer {\n\tu32 addr;\n\tstruct tipc_mon_domain *domain;\n\tstruct hlist_node hash;\n\tstruct list_head list;\n\tu8 applied;\n\tu8 down_cnt;\n\tbool is_up;\n\tbool is_head;\n\tbool is_local;\n};\n\nstruct tipc_monitor {\n\tstruct hlist_head peers[NODE_HTABLE_SIZE];\n\tint peer_cnt;\n\tstruct tipc_peer *self;\n\trwlock_t lock;\n\tstruct tipc_mon_domain cache;\n\tu16 list_gen;\n\tu16 dom_gen;\n\tstruct net *net;\n\tstruct timer_list timer;\n\tunsigned long timer_intv;\n};\n\nstatic struct tipc_monitor *tipc_monitor(struct net *net, int bearer_id)\n{\n\treturn tipc_net(net)->monitors[bearer_id];\n}\n\nconst int tipc_max_domain_size = sizeof(struct tipc_mon_domain);\n\nstatic inline u16 mon_cpu_to_le16(u16 val)\n{\n\treturn (__force __u16)htons(val);\n}\n\nstatic inline u32 mon_cpu_to_le32(u32 val)\n{\n\treturn (__force __u32)htonl(val);\n}\n\nstatic inline u64 mon_cpu_to_le64(u64 val)\n{\n\treturn (__force __u64)cpu_to_be64(val);\n}\n\nstatic inline u16 mon_le16_to_cpu(u16 val)\n{\n\treturn ntohs((__force __be16)val);\n}\n\nstatic inline u32 mon_le32_to_cpu(u32 val)\n{\n\treturn ntohl((__force __be32)val);\n}\n\nstatic inline u64 mon_le64_to_cpu(u64 val)\n{\n\treturn be64_to_cpu((__force __be64)val);\n}\n\n \nstatic int dom_rec_len(struct tipc_mon_domain *dom, u16 mcnt)\n{\n\treturn (offsetof(struct tipc_mon_domain, members)) + (mcnt * sizeof(u32));\n}\n\n \nstatic int dom_size(int peers)\n{\n\tint i = 0;\n\n\twhile ((i * i) < peers)\n\t\ti++;\n\treturn i < MAX_MON_DOMAIN ? i : MAX_MON_DOMAIN;\n}\n\nstatic void map_set(u64 *up_map, int i, unsigned int v)\n{\n\t*up_map &= ~(1ULL << i);\n\t*up_map |= ((u64)v << i);\n}\n\nstatic int map_get(u64 up_map, int i)\n{\n\treturn (up_map & (1ULL << i)) >> i;\n}\n\nstatic struct tipc_peer *peer_prev(struct tipc_peer *peer)\n{\n\treturn list_last_entry(&peer->list, struct tipc_peer, list);\n}\n\nstatic struct tipc_peer *peer_nxt(struct tipc_peer *peer)\n{\n\treturn list_first_entry(&peer->list, struct tipc_peer, list);\n}\n\nstatic struct tipc_peer *peer_head(struct tipc_peer *peer)\n{\n\twhile (!peer->is_head)\n\t\tpeer = peer_prev(peer);\n\treturn peer;\n}\n\nstatic struct tipc_peer *get_peer(struct tipc_monitor *mon, u32 addr)\n{\n\tstruct tipc_peer *peer;\n\tunsigned int thash = tipc_hashfn(addr);\n\n\thlist_for_each_entry(peer, &mon->peers[thash], hash) {\n\t\tif (peer->addr == addr)\n\t\t\treturn peer;\n\t}\n\treturn NULL;\n}\n\nstatic struct tipc_peer *get_self(struct net *net, int bearer_id)\n{\n\tstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\n\n\treturn mon->self;\n}\n\nstatic inline bool tipc_mon_is_active(struct net *net, struct tipc_monitor *mon)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\n\treturn mon->peer_cnt > tn->mon_threshold;\n}\n\n \nstatic void mon_identify_lost_members(struct tipc_peer *peer,\n\t\t\t\t      struct tipc_mon_domain *dom_bef,\n\t\t\t\t      int applied_bef)\n{\n\tstruct tipc_peer *member = peer;\n\tstruct tipc_mon_domain *dom_aft = peer->domain;\n\tint applied_aft = peer->applied;\n\tint i;\n\n\tfor (i = 0; i < applied_bef; i++) {\n\t\tmember = peer_nxt(member);\n\n\t\t \n\t\tif (!member->is_up || !map_get(dom_bef->up_map, i))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (member->is_local)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!applied_aft || (applied_aft < i)) {\n\t\t\tmember->down_cnt = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!map_get(dom_aft->up_map, i))\n\t\t\tmember->down_cnt++;\n\t}\n}\n\n \nstatic void mon_apply_domain(struct tipc_monitor *mon,\n\t\t\t     struct tipc_peer *peer)\n{\n\tstruct tipc_mon_domain *dom = peer->domain;\n\tstruct tipc_peer *member;\n\tu32 addr;\n\tint i;\n\n\tif (!dom || !peer->is_up)\n\t\treturn;\n\n\t \n\tpeer->applied = 0;\n\tmember = peer_nxt(peer);\n\tfor (i = 0; i < dom->member_cnt; i++) {\n\t\taddr = dom->members[i];\n\t\tif (addr != member->addr)\n\t\t\treturn;\n\t\tpeer->applied++;\n\t\tmember = peer_nxt(member);\n\t}\n}\n\n \nstatic void mon_update_local_domain(struct tipc_monitor *mon)\n{\n\tstruct tipc_peer *self = mon->self;\n\tstruct tipc_mon_domain *cache = &mon->cache;\n\tstruct tipc_mon_domain *dom = self->domain;\n\tstruct tipc_peer *peer = self;\n\tu64 prev_up_map = dom->up_map;\n\tu16 member_cnt, i;\n\tbool diff;\n\n\t \n\tmember_cnt = dom_size(mon->peer_cnt) - 1;\n\tself->applied = member_cnt;\n\n\t \n\tdom->len = dom_rec_len(dom, member_cnt);\n\tdiff = dom->member_cnt != member_cnt;\n\tdom->member_cnt = member_cnt;\n\tfor (i = 0; i < member_cnt; i++) {\n\t\tpeer = peer_nxt(peer);\n\t\tdiff |= dom->members[i] != peer->addr;\n\t\tdom->members[i] = peer->addr;\n\t\tmap_set(&dom->up_map, i, peer->is_up);\n\t\tcache->members[i] = mon_cpu_to_le32(peer->addr);\n\t}\n\tdiff |= dom->up_map != prev_up_map;\n\tif (!diff)\n\t\treturn;\n\tdom->gen = ++mon->dom_gen;\n\tcache->len = mon_cpu_to_le16(dom->len);\n\tcache->gen = mon_cpu_to_le16(dom->gen);\n\tcache->member_cnt = mon_cpu_to_le16(member_cnt);\n\tcache->up_map = mon_cpu_to_le64(dom->up_map);\n\tmon_apply_domain(mon, self);\n}\n\n \nstatic void mon_update_neighbors(struct tipc_monitor *mon,\n\t\t\t\t struct tipc_peer *peer)\n{\n\tint dz, i;\n\n\tdz = dom_size(mon->peer_cnt);\n\tfor (i = 0; i < dz; i++) {\n\t\tmon_apply_domain(mon, peer);\n\t\tpeer = peer_prev(peer);\n\t}\n}\n\n \nstatic void mon_assign_roles(struct tipc_monitor *mon, struct tipc_peer *head)\n{\n\tstruct tipc_peer *peer = peer_nxt(head);\n\tstruct tipc_peer *self = mon->self;\n\tint i = 0;\n\n\tfor (; peer != self; peer = peer_nxt(peer)) {\n\t\tpeer->is_local = false;\n\n\t\t \n\t\tif (i++ < head->applied) {\n\t\t\tpeer->is_head = false;\n\t\t\tif (head == self)\n\t\t\t\tpeer->is_local = true;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (!peer->is_up)\n\t\t\tcontinue;\n\t\tif (peer->is_head)\n\t\t\tbreak;\n\t\thead = peer;\n\t\thead->is_head = true;\n\t\ti = 0;\n\t}\n\tmon->list_gen++;\n}\n\nvoid tipc_mon_remove_peer(struct net *net, u32 addr, int bearer_id)\n{\n\tstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\n\tstruct tipc_peer *self;\n\tstruct tipc_peer *peer, *prev, *head;\n\n\tif (!mon)\n\t\treturn;\n\n\tself = get_self(net, bearer_id);\n\twrite_lock_bh(&mon->lock);\n\tpeer = get_peer(mon, addr);\n\tif (!peer)\n\t\tgoto exit;\n\tprev = peer_prev(peer);\n\tlist_del(&peer->list);\n\thlist_del(&peer->hash);\n\tkfree(peer->domain);\n\tkfree(peer);\n\tmon->peer_cnt--;\n\thead = peer_head(prev);\n\tif (head == self)\n\t\tmon_update_local_domain(mon);\n\tmon_update_neighbors(mon, prev);\n\n\t \n\tif (!tipc_mon_is_active(net, mon)) {\n\t\tlist_for_each_entry(peer, &self->list, list) {\n\t\t\tkfree(peer->domain);\n\t\t\tpeer->domain = NULL;\n\t\t\tpeer->applied = 0;\n\t\t}\n\t}\n\tmon_assign_roles(mon, head);\nexit:\n\twrite_unlock_bh(&mon->lock);\n}\n\nstatic bool tipc_mon_add_peer(struct tipc_monitor *mon, u32 addr,\n\t\t\t      struct tipc_peer **peer)\n{\n\tstruct tipc_peer *self = mon->self;\n\tstruct tipc_peer *cur, *prev, *p;\n\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\t*peer = p;\n\tif (!p)\n\t\treturn false;\n\tp->addr = addr;\n\n\t \n\tINIT_LIST_HEAD(&p->list);\n\thlist_add_head(&p->hash, &mon->peers[tipc_hashfn(addr)]);\n\n\t \n\tprev = self;\n\tlist_for_each_entry(cur, &self->list, list) {\n\t\tif ((addr > prev->addr) && (addr < cur->addr))\n\t\t\tbreak;\n\t\tif (((addr < cur->addr) || (addr > prev->addr)) &&\n\t\t    (prev->addr > cur->addr))\n\t\t\tbreak;\n\t\tprev = cur;\n\t}\n\tlist_add_tail(&p->list, &cur->list);\n\tmon->peer_cnt++;\n\tmon_update_neighbors(mon, p);\n\treturn true;\n}\n\nvoid tipc_mon_peer_up(struct net *net, u32 addr, int bearer_id)\n{\n\tstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\n\tstruct tipc_peer *self = get_self(net, bearer_id);\n\tstruct tipc_peer *peer, *head;\n\n\twrite_lock_bh(&mon->lock);\n\tpeer = get_peer(mon, addr);\n\tif (!peer && !tipc_mon_add_peer(mon, addr, &peer))\n\t\tgoto exit;\n\tpeer->is_up = true;\n\thead = peer_head(peer);\n\tif (head == self)\n\t\tmon_update_local_domain(mon);\n\tmon_assign_roles(mon, head);\nexit:\n\twrite_unlock_bh(&mon->lock);\n}\n\nvoid tipc_mon_peer_down(struct net *net, u32 addr, int bearer_id)\n{\n\tstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\n\tstruct tipc_peer *self;\n\tstruct tipc_peer *peer, *head;\n\tstruct tipc_mon_domain *dom;\n\tint applied;\n\n\tif (!mon)\n\t\treturn;\n\n\tself = get_self(net, bearer_id);\n\twrite_lock_bh(&mon->lock);\n\tpeer = get_peer(mon, addr);\n\tif (!peer) {\n\t\tpr_warn(\"Mon: unknown link %x/%u DOWN\\n\", addr, bearer_id);\n\t\tgoto exit;\n\t}\n\tapplied = peer->applied;\n\tpeer->applied = 0;\n\tdom = peer->domain;\n\tpeer->domain = NULL;\n\tif (peer->is_head)\n\t\tmon_identify_lost_members(peer, dom, applied);\n\tkfree(dom);\n\tpeer->is_up = false;\n\tpeer->is_head = false;\n\tpeer->is_local = false;\n\tpeer->down_cnt = 0;\n\thead = peer_head(peer);\n\tif (head == self)\n\t\tmon_update_local_domain(mon);\n\tmon_assign_roles(mon, head);\nexit:\n\twrite_unlock_bh(&mon->lock);\n}\n\n \nvoid tipc_mon_rcv(struct net *net, void *data, u16 dlen, u32 addr,\n\t\t  struct tipc_mon_state *state, int bearer_id)\n{\n\tstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\n\tstruct tipc_mon_domain *arrv_dom = data;\n\tstruct tipc_mon_domain dom_bef;\n\tstruct tipc_mon_domain *dom;\n\tstruct tipc_peer *peer;\n\tu16 new_member_cnt = mon_le16_to_cpu(arrv_dom->member_cnt);\n\tint new_dlen = dom_rec_len(arrv_dom, new_member_cnt);\n\tu16 new_gen = mon_le16_to_cpu(arrv_dom->gen);\n\tu16 acked_gen = mon_le16_to_cpu(arrv_dom->ack_gen);\n\tu16 arrv_dlen = mon_le16_to_cpu(arrv_dom->len);\n\tbool probing = state->probing;\n\tint i, applied_bef;\n\n\tstate->probing = false;\n\n\t \n\tif (new_member_cnt > MAX_MON_DOMAIN)\n\t\treturn;\n\tif (dlen < dom_rec_len(arrv_dom, 0))\n\t\treturn;\n\tif (dlen != dom_rec_len(arrv_dom, new_member_cnt))\n\t\treturn;\n\tif (dlen < new_dlen || arrv_dlen != new_dlen)\n\t\treturn;\n\n\t \n\tif (!state->synched) {\n\t\tstate->peer_gen = new_gen - 1;\n\t\tstate->acked_gen = acked_gen;\n\t\tstate->synched = true;\n\t}\n\n\tif (more(acked_gen, state->acked_gen))\n\t\tstate->acked_gen = acked_gen;\n\n\t \n\tif (!more(new_gen, state->peer_gen) && !probing)\n\t\treturn;\n\n\twrite_lock_bh(&mon->lock);\n\tpeer = get_peer(mon, addr);\n\tif (!peer || !peer->is_up)\n\t\tgoto exit;\n\n\t \n\tpeer->down_cnt = 0;\n\n\t \n\tif (!more(new_gen, state->peer_gen))\n\t\tgoto exit;\n\n\tstate->peer_gen = new_gen;\n\n\t \n\tdom_bef.member_cnt = 0;\n\tdom = peer->domain;\n\tif (dom)\n\t\tmemcpy(&dom_bef, dom, dom->len);\n\n\t \n\tif (!dom || (dom->len < new_dlen)) {\n\t\tkfree(dom);\n\t\tdom = kmalloc(new_dlen, GFP_ATOMIC);\n\t\tpeer->domain = dom;\n\t\tif (!dom)\n\t\t\tgoto exit;\n\t}\n\tdom->len = new_dlen;\n\tdom->gen = new_gen;\n\tdom->member_cnt = new_member_cnt;\n\tdom->up_map = mon_le64_to_cpu(arrv_dom->up_map);\n\tfor (i = 0; i < new_member_cnt; i++)\n\t\tdom->members[i] = mon_le32_to_cpu(arrv_dom->members[i]);\n\n\t \n\tapplied_bef = peer->applied;\n\tmon_apply_domain(mon, peer);\n\tmon_identify_lost_members(peer, &dom_bef, applied_bef);\n\tmon_assign_roles(mon, peer_head(peer));\nexit:\n\twrite_unlock_bh(&mon->lock);\n}\n\nvoid tipc_mon_prep(struct net *net, void *data, int *dlen,\n\t\t   struct tipc_mon_state *state, int bearer_id)\n{\n\tstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\n\tstruct tipc_mon_domain *dom = data;\n\tu16 gen = mon->dom_gen;\n\tu16 len;\n\n\t \n\tif (!tipc_mon_is_active(net, mon)) {\n\t\tdom->len = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (likely(state->acked_gen == gen)) {\n\t\tlen = dom_rec_len(dom, 0);\n\t\t*dlen = len;\n\t\tdom->len = mon_cpu_to_le16(len);\n\t\tdom->gen = mon_cpu_to_le16(gen);\n\t\tdom->ack_gen = mon_cpu_to_le16(state->peer_gen);\n\t\tdom->member_cnt = 0;\n\t\treturn;\n\t}\n\t \n\tread_lock_bh(&mon->lock);\n\tlen = mon_le16_to_cpu(mon->cache.len);\n\t*dlen = len;\n\tmemcpy(data, &mon->cache, len);\n\tread_unlock_bh(&mon->lock);\n\tdom->ack_gen = mon_cpu_to_le16(state->peer_gen);\n}\n\nvoid tipc_mon_get_state(struct net *net, u32 addr,\n\t\t\tstruct tipc_mon_state *state,\n\t\t\tint bearer_id)\n{\n\tstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\n\tstruct tipc_peer *peer;\n\n\tif (!tipc_mon_is_active(net, mon)) {\n\t\tstate->probing = false;\n\t\tstate->monitoring = true;\n\t\treturn;\n\t}\n\n\t \n\tif (!state->probing &&\n\t    (state->list_gen == mon->list_gen) &&\n\t    (state->acked_gen == mon->dom_gen))\n\t\treturn;\n\n\tread_lock_bh(&mon->lock);\n\tpeer = get_peer(mon, addr);\n\tif (peer) {\n\t\tstate->probing = state->acked_gen != mon->dom_gen;\n\t\tstate->probing |= peer->down_cnt;\n\t\tstate->reset |= peer->down_cnt >= MAX_PEER_DOWN_EVENTS;\n\t\tstate->monitoring = peer->is_local;\n\t\tstate->monitoring |= peer->is_head;\n\t\tstate->list_gen = mon->list_gen;\n\t}\n\tread_unlock_bh(&mon->lock);\n}\n\nstatic void mon_timeout(struct timer_list *t)\n{\n\tstruct tipc_monitor *mon = from_timer(mon, t, timer);\n\tstruct tipc_peer *self;\n\tint best_member_cnt = dom_size(mon->peer_cnt) - 1;\n\n\twrite_lock_bh(&mon->lock);\n\tself = mon->self;\n\tif (self && (best_member_cnt != self->applied)) {\n\t\tmon_update_local_domain(mon);\n\t\tmon_assign_roles(mon, self);\n\t}\n\twrite_unlock_bh(&mon->lock);\n\tmod_timer(&mon->timer, jiffies + mon->timer_intv);\n}\n\nint tipc_mon_create(struct net *net, int bearer_id)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_monitor *mon;\n\tstruct tipc_peer *self;\n\tstruct tipc_mon_domain *dom;\n\n\tif (tn->monitors[bearer_id])\n\t\treturn 0;\n\n\tmon = kzalloc(sizeof(*mon), GFP_ATOMIC);\n\tself = kzalloc(sizeof(*self), GFP_ATOMIC);\n\tdom = kzalloc(sizeof(*dom), GFP_ATOMIC);\n\tif (!mon || !self || !dom) {\n\t\tkfree(mon);\n\t\tkfree(self);\n\t\tkfree(dom);\n\t\treturn -ENOMEM;\n\t}\n\ttn->monitors[bearer_id] = mon;\n\trwlock_init(&mon->lock);\n\tmon->net = net;\n\tmon->peer_cnt = 1;\n\tmon->self = self;\n\tself->domain = dom;\n\tself->addr = tipc_own_addr(net);\n\tself->is_up = true;\n\tself->is_head = true;\n\tINIT_LIST_HEAD(&self->list);\n\ttimer_setup(&mon->timer, mon_timeout, 0);\n\tmon->timer_intv = msecs_to_jiffies(MON_TIMEOUT + (tn->random & 0xffff));\n\tmod_timer(&mon->timer, jiffies + mon->timer_intv);\n\treturn 0;\n}\n\nvoid tipc_mon_delete(struct net *net, int bearer_id)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\n\tstruct tipc_peer *self;\n\tstruct tipc_peer *peer, *tmp;\n\n\tif (!mon)\n\t\treturn;\n\n\tself = get_self(net, bearer_id);\n\twrite_lock_bh(&mon->lock);\n\ttn->monitors[bearer_id] = NULL;\n\tlist_for_each_entry_safe(peer, tmp, &self->list, list) {\n\t\tlist_del(&peer->list);\n\t\thlist_del(&peer->hash);\n\t\tkfree(peer->domain);\n\t\tkfree(peer);\n\t}\n\tmon->self = NULL;\n\twrite_unlock_bh(&mon->lock);\n\ttimer_shutdown_sync(&mon->timer);\n\tkfree(self->domain);\n\tkfree(self);\n\tkfree(mon);\n}\n\nvoid tipc_mon_reinit_self(struct net *net)\n{\n\tstruct tipc_monitor *mon;\n\tint bearer_id;\n\n\tfor (bearer_id = 0; bearer_id < MAX_BEARERS; bearer_id++) {\n\t\tmon = tipc_monitor(net, bearer_id);\n\t\tif (!mon)\n\t\t\tcontinue;\n\t\twrite_lock_bh(&mon->lock);\n\t\tmon->self->addr = tipc_own_addr(net);\n\t\twrite_unlock_bh(&mon->lock);\n\t}\n}\n\nint tipc_nl_monitor_set_threshold(struct net *net, u32 cluster_size)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\n\tif (cluster_size > TIPC_CLUSTER_SIZE)\n\t\treturn -EINVAL;\n\n\ttn->mon_threshold = cluster_size;\n\n\treturn 0;\n}\n\nint tipc_nl_monitor_get_threshold(struct net *net)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\n\treturn tn->mon_threshold;\n}\n\nstatic int __tipc_nl_add_monitor_peer(struct tipc_peer *peer,\n\t\t\t\t      struct tipc_nl_msg *msg)\n{\n\tstruct tipc_mon_domain *dom = peer->domain;\n\tstruct nlattr *attrs;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  NLM_F_MULTI, TIPC_NL_MON_PEER_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_MON_PEER);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\tif (nla_put_u32(msg->skb, TIPC_NLA_MON_PEER_ADDR, peer->addr))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_MON_PEER_APPLIED, peer->applied))\n\t\tgoto attr_msg_full;\n\n\tif (peer->is_up)\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_MON_PEER_UP))\n\t\t\tgoto attr_msg_full;\n\tif (peer->is_local)\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_MON_PEER_LOCAL))\n\t\t\tgoto attr_msg_full;\n\tif (peer->is_head)\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_MON_PEER_HEAD))\n\t\t\tgoto attr_msg_full;\n\n\tif (dom) {\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_MON_PEER_DOMGEN, dom->gen))\n\t\t\tgoto attr_msg_full;\n\t\tif (nla_put_u64_64bit(msg->skb, TIPC_NLA_MON_PEER_UPMAP,\n\t\t\t\t      dom->up_map, TIPC_NLA_MON_PEER_PAD))\n\t\t\tgoto attr_msg_full;\n\t\tif (nla_put(msg->skb, TIPC_NLA_MON_PEER_MEMBERS,\n\t\t\t    dom->member_cnt * sizeof(u32), &dom->members))\n\t\t\tgoto attr_msg_full;\n\t}\n\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\treturn 0;\n\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nint tipc_nl_add_monitor_peer(struct net *net, struct tipc_nl_msg *msg,\n\t\t\t     u32 bearer_id, u32 *prev_node)\n{\n\tstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\n\tstruct tipc_peer *peer;\n\n\tif (!mon)\n\t\treturn -EINVAL;\n\n\tread_lock_bh(&mon->lock);\n\tpeer = mon->self;\n\tdo {\n\t\tif (*prev_node) {\n\t\t\tif (peer->addr == *prev_node)\n\t\t\t\t*prev_node = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (__tipc_nl_add_monitor_peer(peer, msg)) {\n\t\t\t*prev_node = peer->addr;\n\t\t\tread_unlock_bh(&mon->lock);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t} while ((peer = peer_nxt(peer)) != mon->self);\n\tread_unlock_bh(&mon->lock);\n\n\treturn 0;\n}\n\nint __tipc_nl_add_monitor(struct net *net, struct tipc_nl_msg *msg,\n\t\t\t  u32 bearer_id)\n{\n\tstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\n\tchar bearer_name[TIPC_MAX_BEARER_NAME];\n\tstruct nlattr *attrs;\n\tvoid *hdr;\n\tint ret;\n\n\tret = tipc_bearer_get_name(net, bearer_name, bearer_id);\n\tif (ret || !mon)\n\t\treturn 0;\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  NLM_F_MULTI, TIPC_NL_MON_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_MON);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\tread_lock_bh(&mon->lock);\n\tif (nla_put_u32(msg->skb, TIPC_NLA_MON_REF, bearer_id))\n\t\tgoto attr_msg_full;\n\tif (tipc_mon_is_active(net, mon))\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_MON_ACTIVE))\n\t\t\tgoto attr_msg_full;\n\tif (nla_put_string(msg->skb, TIPC_NLA_MON_BEARER_NAME, bearer_name))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_MON_PEERCNT, mon->peer_cnt))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_MON_LISTGEN, mon->list_gen))\n\t\tgoto attr_msg_full;\n\n\tread_unlock_bh(&mon->lock);\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nattr_msg_full:\n\tread_unlock_bh(&mon->lock);\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}