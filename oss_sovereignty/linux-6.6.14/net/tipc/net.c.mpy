{
  "module_name": "net.c",
  "hash_id": "7622568e2b7736a8ab8de1fbcf1cb79a179eaa5db5d1ff374593debae90a821a",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/net.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"net.h\"\n#include \"name_distr.h\"\n#include \"subscr.h\"\n#include \"socket.h\"\n#include \"node.h\"\n#include \"bcast.h\"\n#include \"link.h\"\n#include \"netlink.h\"\n#include \"monitor.h\"\n\n \n\nstatic void tipc_net_finalize(struct net *net, u32 addr);\n\nint tipc_net_init(struct net *net, u8 *node_id, u32 addr)\n{\n\tif (tipc_own_id(net)) {\n\t\tpr_info(\"Cannot configure node identity twice\\n\");\n\t\treturn -1;\n\t}\n\tpr_info(\"Started in network mode\\n\");\n\n\tif (node_id)\n\t\ttipc_set_node_id(net, node_id);\n\tif (addr)\n\t\ttipc_net_finalize(net, addr);\n\treturn 0;\n}\n\nstatic void tipc_net_finalize(struct net *net, u32 addr)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_socket_addr sk = {0, addr};\n\tstruct tipc_uaddr ua;\n\n\ttipc_uaddr(&ua, TIPC_SERVICE_RANGE, TIPC_CLUSTER_SCOPE,\n\t\t   TIPC_NODE_STATE, addr, addr);\n\n\tif (cmpxchg(&tn->node_addr, 0, addr))\n\t\treturn;\n\ttipc_set_node_addr(net, addr);\n\ttipc_named_reinit(net);\n\ttipc_sk_reinit(net);\n\ttipc_mon_reinit_self(net);\n\ttipc_nametbl_publish(net, &ua, &sk, addr);\n}\n\nvoid tipc_net_finalize_work(struct work_struct *work)\n{\n\tstruct tipc_net *tn = container_of(work, struct tipc_net, work);\n\n\ttipc_net_finalize(tipc_link_net(tn->bcl), tn->trial_addr);\n}\n\nvoid tipc_net_stop(struct net *net)\n{\n\tif (!tipc_own_id(net))\n\t\treturn;\n\n\trtnl_lock();\n\ttipc_bearer_stop(net);\n\ttipc_node_stop(net);\n\trtnl_unlock();\n\n\tpr_info(\"Left network mode\\n\");\n}\n\nstatic int __tipc_nl_add_net(struct net *net, struct tipc_nl_msg *msg)\n{\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tu64 *w0 = (u64 *)&tn->node_id[0];\n\tu64 *w1 = (u64 *)&tn->node_id[8];\n\tstruct nlattr *attrs;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  NLM_F_MULTI, TIPC_NL_NET_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_NET);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\tif (nla_put_u32(msg->skb, TIPC_NLA_NET_ID, tn->net_id))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u64_64bit(msg->skb, TIPC_NLA_NET_NODEID, *w0, 0))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u64_64bit(msg->skb, TIPC_NLA_NET_NODEID_W1, *w1, 0))\n\t\tgoto attr_msg_full;\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nint tipc_nl_net_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint err;\n\tint done = cb->args[0];\n\tstruct tipc_nl_msg msg;\n\n\tif (done)\n\t\treturn 0;\n\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\n\terr = __tipc_nl_add_net(net, &msg);\n\tif (err)\n\t\tgoto out;\n\n\tdone = 1;\nout:\n\tcb->args[0] = done;\n\n\treturn skb->len;\n}\n\nint __tipc_nl_net_set(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attrs[TIPC_NLA_NET_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_net *tn = tipc_net(net);\n\tint err;\n\n\tif (!info->attrs[TIPC_NLA_NET])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_NET_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_NET],\n\t\t\t\t\t  tipc_nl_net_policy, info->extack);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (tipc_own_addr(net))\n\t\treturn -EPERM;\n\n\tif (attrs[TIPC_NLA_NET_ID]) {\n\t\tu32 val;\n\n\t\tval = nla_get_u32(attrs[TIPC_NLA_NET_ID]);\n\t\tif (val < 1 || val > 9999)\n\t\t\treturn -EINVAL;\n\n\t\ttn->net_id = val;\n\t}\n\n\tif (attrs[TIPC_NLA_NET_ADDR]) {\n\t\tu32 addr;\n\n\t\taddr = nla_get_u32(attrs[TIPC_NLA_NET_ADDR]);\n\t\tif (!addr)\n\t\t\treturn -EINVAL;\n\t\ttn->legacy_addr_format = true;\n\t\ttipc_net_init(net, NULL, addr);\n\t}\n\n\tif (attrs[TIPC_NLA_NET_NODEID]) {\n\t\tu8 node_id[NODE_ID_LEN];\n\t\tu64 *w0 = (u64 *)&node_id[0];\n\t\tu64 *w1 = (u64 *)&node_id[8];\n\n\t\tif (!attrs[TIPC_NLA_NET_NODEID_W1])\n\t\t\treturn -EINVAL;\n\t\t*w0 = nla_get_u64(attrs[TIPC_NLA_NET_NODEID]);\n\t\t*w1 = nla_get_u64(attrs[TIPC_NLA_NET_NODEID_W1]);\n\t\ttipc_net_init(net, node_id, 0);\n\t}\n\treturn 0;\n}\n\nint tipc_nl_net_set(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __tipc_nl_net_set(skb, info);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic int __tipc_nl_addr_legacy_get(struct net *net, struct tipc_nl_msg *msg)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct nlattr *attrs;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  0, TIPC_NL_ADDR_LEGACY_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tattrs = nla_nest_start(msg->skb, TIPC_NLA_NET);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\tif (tn->legacy_addr_format)\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_NET_ADDR_LEGACY))\n\t\t\tgoto attr_msg_full;\n\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nint tipc_nl_net_addr_legacy_get(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_nl_msg msg;\n\tstruct sk_buff *rep;\n\tint err;\n\n\trep = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!rep)\n\t\treturn -ENOMEM;\n\n\tmsg.skb = rep;\n\tmsg.portid = info->snd_portid;\n\tmsg.seq = info->snd_seq;\n\n\terr = __tipc_nl_addr_legacy_get(net, &msg);\n\tif (err) {\n\t\tnlmsg_free(msg.skb);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg.skb, info);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}