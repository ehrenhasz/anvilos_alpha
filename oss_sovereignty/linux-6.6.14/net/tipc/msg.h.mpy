{
  "module_name": "msg.h",
  "hash_id": "fb71e19a2eb5f1f180446dc33b424947526f1fe87093a5c0c6cfc3f3d93e63aa",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/msg.h",
  "human_readable_source": " \n\n#ifndef _TIPC_MSG_H\n#define _TIPC_MSG_H\n\n#include <linux/tipc.h>\n#include \"core.h\"\n\n \n#define TIPC_VERSION              2\nstruct plist;\n\n \n#define TIPC_SYSTEM_IMPORTANCE\t4\n\n\n \n#define TIPC_CONN_MSG           0\n#define TIPC_MCAST_MSG          1\n#define TIPC_NAMED_MSG          2\n#define TIPC_DIRECT_MSG         3\n#define TIPC_GRP_MEMBER_EVT     4\n#define TIPC_GRP_BCAST_MSG      5\n#define TIPC_GRP_MCAST_MSG      6\n#define TIPC_GRP_UCAST_MSG      7\n\n \n#define  BCAST_PROTOCOL       5\n#define  MSG_BUNDLER          6\n#define  LINK_PROTOCOL        7\n#define  CONN_MANAGER         8\n#define  GROUP_PROTOCOL       9\n#define  TUNNEL_PROTOCOL      10\n#define  NAME_DISTRIBUTOR     11\n#define  MSG_FRAGMENTER       12\n#define  LINK_CONFIG          13\n#define  MSG_CRYPTO           14\n#define  SOCK_WAKEUP          14        \n#define  TOP_SRV              15        \n\n \n#define SHORT_H_SIZE              24\t \n#define BASIC_H_SIZE              32\t \n#define NAMED_H_SIZE              40\t \n#define MCAST_H_SIZE              44\t \n#define GROUP_H_SIZE              44\t \n#define INT_H_SIZE                40\t \n#define MIN_H_SIZE                24\t \n#define MAX_H_SIZE                60\t \n\n#define MAX_MSG_SIZE (MAX_H_SIZE + TIPC_MAX_USER_MSG_SIZE)\n#define TIPC_MEDIA_INFO_OFFSET\t5\n\nextern const int one_page_mtu;\n\nstruct tipc_skb_cb {\n\tunion {\n\t\tstruct {\n\t\t\tstruct sk_buff *tail;\n\t\t\tunsigned long nxt_retr;\n\t\t\tunsigned long retr_stamp;\n\t\t\tu32 bytes_read;\n\t\t\tu32 orig_member;\n\t\t\tu16 chain_imp;\n\t\t\tu16 ackers;\n\t\t\tu16 retr_cnt;\n\t\t} __packed;\n#ifdef CONFIG_TIPC_CRYPTO\n\t\tstruct {\n\t\t\tstruct tipc_crypto *rx;\n\t\t\tstruct tipc_aead *last;\n\t\t\tu8 recurs;\n\t\t} tx_clone_ctx __packed;\n#endif\n\t} __packed;\n\tunion {\n\t\tstruct {\n\t\t\tu8 validated:1;\n#ifdef CONFIG_TIPC_CRYPTO\n\t\t\tu8 encrypted:1;\n\t\t\tu8 decrypted:1;\n#define SKB_PROBING\t1\n#define SKB_GRACING\t2\n\t\t\tu8 xmit_type:2;\n\t\t\tu8 tx_clone_deferred:1;\n#endif\n\t\t};\n\t\tu8 flags;\n\t};\n\tu8 reserved;\n#ifdef CONFIG_TIPC_CRYPTO\n\tvoid *crypto_ctx;\n#endif\n} __packed;\n\n#define TIPC_SKB_CB(__skb) ((struct tipc_skb_cb *)&((__skb)->cb[0]))\n\nstruct tipc_msg {\n\t__be32 hdr[15];\n};\n\n \nstruct tipc_gap_ack {\n\t__be16 ack;\n\t__be16 gap;\n};\n\n \nstruct tipc_gap_ack_blks {\n\t__be16 len;\n\tunion {\n\t\tu8 ugack_cnt;\n\t\tu8 start_index;\n\t};\n\tu8 bgack_cnt;\n\tstruct tipc_gap_ack gacks[];\n};\n\n#define MAX_GAP_ACK_BLKS\t128\n#define MAX_GAP_ACK_BLKS_SZ\t(sizeof(struct tipc_gap_ack_blks) + \\\n\t\t\t\t sizeof(struct tipc_gap_ack) * MAX_GAP_ACK_BLKS)\n\nstatic inline struct tipc_msg *buf_msg(struct sk_buff *skb)\n{\n\treturn (struct tipc_msg *)skb->data;\n}\n\nstatic inline u32 msg_word(struct tipc_msg *m, u32 pos)\n{\n\treturn ntohl(m->hdr[pos]);\n}\n\nstatic inline void msg_set_word(struct tipc_msg *m, u32 w, u32 val)\n{\n\tm->hdr[w] = htonl(val);\n}\n\nstatic inline u32 msg_bits(struct tipc_msg *m, u32 w, u32 pos, u32 mask)\n{\n\treturn (msg_word(m, w) >> pos) & mask;\n}\n\nstatic inline void msg_set_bits(struct tipc_msg *m, u32 w,\n\t\t\t\tu32 pos, u32 mask, u32 val)\n{\n\tval = (val & mask) << pos;\n\tmask = mask << pos;\n\tm->hdr[w] &= ~htonl(mask);\n\tm->hdr[w] |= htonl(val);\n}\n\n \nstatic inline u32 msg_version(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 29, 7);\n}\n\nstatic inline void msg_set_version(struct tipc_msg *m)\n{\n\tmsg_set_bits(m, 0, 29, 7, TIPC_VERSION);\n}\n\nstatic inline u32 msg_user(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 25, 0xf);\n}\n\nstatic inline u32 msg_isdata(struct tipc_msg *m)\n{\n\treturn msg_user(m) <= TIPC_CRITICAL_IMPORTANCE;\n}\n\nstatic inline void msg_set_user(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 0, 25, 0xf, n);\n}\n\nstatic inline u32 msg_hdr_sz(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 21, 0xf) << 2;\n}\n\nstatic inline void msg_set_hdr_sz(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 0, 21, 0xf, n>>2);\n}\n\nstatic inline u32 msg_size(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 0, 0x1ffff);\n}\n\nstatic inline u32 msg_blocks(struct tipc_msg *m)\n{\n\treturn (msg_size(m) / 1024) + 1;\n}\n\nstatic inline u32 msg_data_sz(struct tipc_msg *m)\n{\n\treturn msg_size(m) - msg_hdr_sz(m);\n}\n\nstatic inline int msg_non_seq(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 20, 1);\n}\n\nstatic inline void msg_set_non_seq(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 0, 20, 1, n);\n}\n\nstatic inline int msg_is_syn(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 17, 1);\n}\n\nstatic inline void msg_set_syn(struct tipc_msg *m, u32 d)\n{\n\tmsg_set_bits(m, 0, 17, 1, d);\n}\n\nstatic inline int msg_dest_droppable(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 19, 1);\n}\n\nstatic inline void msg_set_dest_droppable(struct tipc_msg *m, u32 d)\n{\n\tmsg_set_bits(m, 0, 19, 1, d);\n}\n\nstatic inline int msg_is_keepalive(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 19, 1);\n}\n\nstatic inline void msg_set_is_keepalive(struct tipc_msg *m, u32 d)\n{\n\tmsg_set_bits(m, 0, 19, 1, d);\n}\n\nstatic inline int msg_src_droppable(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 18, 1);\n}\n\nstatic inline void msg_set_src_droppable(struct tipc_msg *m, u32 d)\n{\n\tmsg_set_bits(m, 0, 18, 1, d);\n}\n\nstatic inline int msg_ack_required(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 18, 1);\n}\n\nstatic inline void msg_set_ack_required(struct tipc_msg *m)\n{\n\tmsg_set_bits(m, 0, 18, 1, 1);\n}\n\nstatic inline int msg_nagle_ack(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 18, 1);\n}\n\nstatic inline void msg_set_nagle_ack(struct tipc_msg *m)\n{\n\tmsg_set_bits(m, 0, 18, 1, 1);\n}\n\nstatic inline bool msg_is_rcast(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 0, 18, 0x1);\n}\n\nstatic inline void msg_set_is_rcast(struct tipc_msg *m, bool d)\n{\n\tmsg_set_bits(m, 0, 18, 0x1, d);\n}\n\nstatic inline void msg_set_size(struct tipc_msg *m, u32 sz)\n{\n\tm->hdr[0] = htonl((msg_word(m, 0) & ~0x1ffff) | sz);\n}\n\nstatic inline unchar *msg_data(struct tipc_msg *m)\n{\n\treturn ((unchar *)m) + msg_hdr_sz(m);\n}\n\nstatic inline struct tipc_msg *msg_inner_hdr(struct tipc_msg *m)\n{\n\treturn (struct tipc_msg *)msg_data(m);\n}\n\n \nstatic inline u32 msg_type(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 29, 0x7);\n}\n\nstatic inline void msg_set_type(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 1, 29, 0x7, n);\n}\n\nstatic inline int msg_in_group(struct tipc_msg *m)\n{\n\tint mtyp = msg_type(m);\n\n\treturn mtyp >= TIPC_GRP_MEMBER_EVT && mtyp <= TIPC_GRP_UCAST_MSG;\n}\n\nstatic inline bool msg_is_grp_evt(struct tipc_msg *m)\n{\n\treturn msg_type(m) == TIPC_GRP_MEMBER_EVT;\n}\n\nstatic inline u32 msg_named(struct tipc_msg *m)\n{\n\treturn msg_type(m) == TIPC_NAMED_MSG;\n}\n\nstatic inline u32 msg_mcast(struct tipc_msg *m)\n{\n\tint mtyp = msg_type(m);\n\n\treturn ((mtyp == TIPC_MCAST_MSG) || (mtyp == TIPC_GRP_BCAST_MSG) ||\n\t\t(mtyp == TIPC_GRP_MCAST_MSG));\n}\n\nstatic inline u32 msg_connected(struct tipc_msg *m)\n{\n\treturn msg_type(m) == TIPC_CONN_MSG;\n}\n\nstatic inline u32 msg_direct(struct tipc_msg *m)\n{\n\treturn msg_type(m) == TIPC_DIRECT_MSG;\n}\n\nstatic inline u32 msg_errcode(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 25, 0xf);\n}\n\nstatic inline void msg_set_errcode(struct tipc_msg *m, u32 err)\n{\n\tmsg_set_bits(m, 1, 25, 0xf, err);\n}\n\nstatic inline void msg_set_bulk(struct tipc_msg *m)\n{\n\tmsg_set_bits(m, 1, 28, 0x1, 1);\n}\n\nstatic inline u32 msg_is_bulk(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 28, 0x1);\n}\n\nstatic inline void msg_set_last_bulk(struct tipc_msg *m)\n{\n\tmsg_set_bits(m, 1, 27, 0x1, 1);\n}\n\nstatic inline u32 msg_is_last_bulk(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 27, 0x1);\n}\n\nstatic inline void msg_set_non_legacy(struct tipc_msg *m)\n{\n\tmsg_set_bits(m, 1, 26, 0x1, 1);\n}\n\nstatic inline u32 msg_is_legacy(struct tipc_msg *m)\n{\n\treturn !msg_bits(m, 1, 26, 0x1);\n}\n\nstatic inline u32 msg_reroute_cnt(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 21, 0xf);\n}\n\nstatic inline void msg_incr_reroute_cnt(struct tipc_msg *m)\n{\n\tmsg_set_bits(m, 1, 21, 0xf, msg_reroute_cnt(m) + 1);\n}\n\nstatic inline u32 msg_lookup_scope(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 19, 0x3);\n}\n\nstatic inline void msg_set_lookup_scope(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 1, 19, 0x3, n);\n}\n\nstatic inline u16 msg_bcast_ack(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 0, 0xffff);\n}\n\nstatic inline void msg_set_bcast_ack(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 1, 0, 0xffff, n);\n}\n\n \nstatic inline bool msg_dest_session_valid(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 16, 0x1);\n}\n\nstatic inline void msg_set_dest_session_valid(struct tipc_msg *m, bool valid)\n{\n\tmsg_set_bits(m, 1, 16, 0x1, valid);\n}\n\nstatic inline u16 msg_dest_session(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 0, 0xffff);\n}\n\nstatic inline void msg_set_dest_session(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 1, 0, 0xffff, n);\n}\n\n \nstatic inline u16 msg_ack(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 2, 16, 0xffff);\n}\n\nstatic inline void msg_set_ack(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 2, 16, 0xffff, n);\n}\n\nstatic inline u16 msg_seqno(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 2, 0, 0xffff);\n}\n\nstatic inline void msg_set_seqno(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 2, 0, 0xffff, n);\n}\n\n \nstatic inline u32 msg_importance(struct tipc_msg *m)\n{\n\tint usr = msg_user(m);\n\n\tif (likely((usr <= TIPC_CRITICAL_IMPORTANCE) && !msg_errcode(m)))\n\t\treturn usr;\n\tif ((usr == MSG_FRAGMENTER) || (usr == MSG_BUNDLER))\n\t\treturn msg_bits(m, 9, 0, 0x7);\n\treturn TIPC_SYSTEM_IMPORTANCE;\n}\n\nstatic inline void msg_set_importance(struct tipc_msg *m, u32 i)\n{\n\tint usr = msg_user(m);\n\n\tif (likely((usr == MSG_FRAGMENTER) || (usr == MSG_BUNDLER)))\n\t\tmsg_set_bits(m, 9, 0, 0x7, i);\n\telse if (i < TIPC_SYSTEM_IMPORTANCE)\n\t\tmsg_set_user(m, i);\n\telse\n\t\tpr_warn(\"Trying to set illegal importance in message\\n\");\n}\n\nstatic inline u32 msg_prevnode(struct tipc_msg *m)\n{\n\treturn msg_word(m, 3);\n}\n\nstatic inline void msg_set_prevnode(struct tipc_msg *m, u32 a)\n{\n\tmsg_set_word(m, 3, a);\n}\n\nstatic inline u32 msg_origport(struct tipc_msg *m)\n{\n\tif (msg_user(m) == MSG_FRAGMENTER)\n\t\tm = msg_inner_hdr(m);\n\treturn msg_word(m, 4);\n}\n\nstatic inline void msg_set_origport(struct tipc_msg *m, u32 p)\n{\n\tmsg_set_word(m, 4, p);\n}\n\nstatic inline u16 msg_named_seqno(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 4, 0, 0xffff);\n}\n\nstatic inline void msg_set_named_seqno(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 4, 0, 0xffff, n);\n}\n\nstatic inline u32 msg_destport(struct tipc_msg *m)\n{\n\treturn msg_word(m, 5);\n}\n\nstatic inline void msg_set_destport(struct tipc_msg *m, u32 p)\n{\n\tmsg_set_word(m, 5, p);\n}\n\nstatic inline u32 msg_mc_netid(struct tipc_msg *m)\n{\n\treturn msg_word(m, 5);\n}\n\nstatic inline void msg_set_mc_netid(struct tipc_msg *m, u32 p)\n{\n\tmsg_set_word(m, 5, p);\n}\n\nstatic inline int msg_short(struct tipc_msg *m)\n{\n\treturn msg_hdr_sz(m) == SHORT_H_SIZE;\n}\n\nstatic inline u32 msg_orignode(struct tipc_msg *m)\n{\n\tif (likely(msg_short(m)))\n\t\treturn msg_prevnode(m);\n\treturn msg_word(m, 6);\n}\n\nstatic inline void msg_set_orignode(struct tipc_msg *m, u32 a)\n{\n\tmsg_set_word(m, 6, a);\n}\n\nstatic inline u32 msg_destnode(struct tipc_msg *m)\n{\n\treturn msg_word(m, 7);\n}\n\nstatic inline void msg_set_destnode(struct tipc_msg *m, u32 a)\n{\n\tmsg_set_word(m, 7, a);\n}\n\nstatic inline u32 msg_nametype(struct tipc_msg *m)\n{\n\treturn msg_word(m, 8);\n}\n\nstatic inline void msg_set_nametype(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_word(m, 8, n);\n}\n\nstatic inline u32 msg_nameinst(struct tipc_msg *m)\n{\n\treturn msg_word(m, 9);\n}\n\nstatic inline u32 msg_namelower(struct tipc_msg *m)\n{\n\treturn msg_nameinst(m);\n}\n\nstatic inline void msg_set_namelower(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_word(m, 9, n);\n}\n\nstatic inline void msg_set_nameinst(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_namelower(m, n);\n}\n\nstatic inline u32 msg_nameupper(struct tipc_msg *m)\n{\n\treturn msg_word(m, 10);\n}\n\nstatic inline void msg_set_nameupper(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_word(m, 10, n);\n}\n\n \n\n \n#define CONN_PROBE        0\n#define CONN_PROBE_REPLY  1\n#define CONN_ACK          2\n\n \n#define PUBLICATION       0\n#define WITHDRAWAL        1\n\n \n#define FIRST_FRAGMENT\t\t0\n#define FRAGMENT\t\t1\n#define LAST_FRAGMENT\t\t2\n\n \n#define STATE_MSG\t\t0\n#define RESET_MSG\t\t1\n#define ACTIVATE_MSG\t\t2\n\n \n#define SYNCH_MSG\t\t0\n#define FAILOVER_MSG\t\t1\n\n \n#define DSC_REQ_MSG\t\t0\n#define DSC_RESP_MSG\t\t1\n#define DSC_TRIAL_MSG\t\t2\n#define DSC_TRIAL_FAIL_MSG\t3\n\n \n#define GRP_JOIN_MSG         0\n#define GRP_LEAVE_MSG        1\n#define GRP_ADV_MSG          2\n#define GRP_ACK_MSG          3\n#define GRP_RECLAIM_MSG      4\n#define GRP_REMIT_MSG        5\n\n \n#define KEY_DISTR_MSG\t\t0\n\n \nstatic inline u32 msg_seq_gap(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 16, 0x1fff);\n}\n\nstatic inline void msg_set_seq_gap(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 1, 16, 0x1fff, n);\n}\n\nstatic inline u32 msg_node_sig(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 0, 0xffff);\n}\n\nstatic inline void msg_set_node_sig(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 1, 0, 0xffff, n);\n}\n\nstatic inline u32 msg_node_capabilities(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 1, 15, 0x1fff);\n}\n\nstatic inline void msg_set_node_capabilities(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 1, 15, 0x1fff, n);\n}\n\n \nstatic inline u32 msg_dest_domain(struct tipc_msg *m)\n{\n\treturn msg_word(m, 2);\n}\n\nstatic inline void msg_set_dest_domain(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_word(m, 2, n);\n}\n\nstatic inline void msg_set_bcgap_after(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 2, 16, 0xffff, n);\n}\n\nstatic inline u32 msg_bcgap_to(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 2, 0, 0xffff);\n}\n\nstatic inline void msg_set_bcgap_to(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 2, 0, 0xffff, n);\n}\n\n \nstatic inline u32 msg_last_bcast(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 4, 16, 0xffff);\n}\n\nstatic inline u32 msg_bc_snd_nxt(struct tipc_msg *m)\n{\n\treturn msg_last_bcast(m) + 1;\n}\n\nstatic inline void msg_set_last_bcast(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 4, 16, 0xffff, n);\n}\n\nstatic inline u32 msg_nof_fragms(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 4, 0, 0xffff);\n}\n\nstatic inline void msg_set_nof_fragms(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 4, 0, 0xffff, n);\n}\n\nstatic inline u32 msg_fragm_no(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 4, 16, 0xffff);\n}\n\nstatic inline void msg_set_fragm_no(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 4, 16, 0xffff, n);\n}\n\nstatic inline u16 msg_next_sent(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 4, 0, 0xffff);\n}\n\nstatic inline void msg_set_next_sent(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 4, 0, 0xffff, n);\n}\n\nstatic inline u32 msg_bc_netid(struct tipc_msg *m)\n{\n\treturn msg_word(m, 4);\n}\n\nstatic inline void msg_set_bc_netid(struct tipc_msg *m, u32 id)\n{\n\tmsg_set_word(m, 4, id);\n}\n\nstatic inline u32 msg_link_selector(struct tipc_msg *m)\n{\n\tif (msg_user(m) == MSG_FRAGMENTER)\n\t\tm = (void *)msg_data(m);\n\treturn msg_bits(m, 4, 0, 1);\n}\n\n \nstatic inline u16 msg_session(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 5, 16, 0xffff);\n}\n\nstatic inline void msg_set_session(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 5, 16, 0xffff, n);\n}\n\nstatic inline u32 msg_probe(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 5, 0, 1);\n}\n\nstatic inline void msg_set_probe(struct tipc_msg *m, u32 val)\n{\n\tmsg_set_bits(m, 5, 0, 1, val);\n}\n\nstatic inline char msg_net_plane(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 5, 1, 7) + 'A';\n}\n\nstatic inline void msg_set_net_plane(struct tipc_msg *m, char n)\n{\n\tmsg_set_bits(m, 5, 1, 7, (n - 'A'));\n}\n\nstatic inline u32 msg_linkprio(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 5, 4, 0x1f);\n}\n\nstatic inline void msg_set_linkprio(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 5, 4, 0x1f, n);\n}\n\nstatic inline u32 msg_bearer_id(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 5, 9, 0x7);\n}\n\nstatic inline void msg_set_bearer_id(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 5, 9, 0x7, n);\n}\n\nstatic inline u32 msg_redundant_link(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 5, 12, 0x1);\n}\n\nstatic inline void msg_set_redundant_link(struct tipc_msg *m, u32 r)\n{\n\tmsg_set_bits(m, 5, 12, 0x1, r);\n}\n\nstatic inline u32 msg_peer_stopping(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 5, 13, 0x1);\n}\n\nstatic inline void msg_set_peer_stopping(struct tipc_msg *m, u32 s)\n{\n\tmsg_set_bits(m, 5, 13, 0x1, s);\n}\n\nstatic inline bool msg_bc_ack_invalid(struct tipc_msg *m)\n{\n\tswitch (msg_user(m)) {\n\tcase BCAST_PROTOCOL:\n\tcase NAME_DISTRIBUTOR:\n\tcase LINK_PROTOCOL:\n\t\treturn msg_bits(m, 5, 14, 0x1);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline void msg_set_bc_ack_invalid(struct tipc_msg *m, bool invalid)\n{\n\tmsg_set_bits(m, 5, 14, 0x1, invalid);\n}\n\nstatic inline char *msg_media_addr(struct tipc_msg *m)\n{\n\treturn (char *)&m->hdr[TIPC_MEDIA_INFO_OFFSET];\n}\n\nstatic inline u32 msg_bc_gap(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 8, 0, 0x3ff);\n}\n\nstatic inline void msg_set_bc_gap(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 8, 0, 0x3ff, n);\n}\n\n \nstatic inline u16 msg_msgcnt(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 9, 16, 0xffff);\n}\n\nstatic inline void msg_set_msgcnt(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 9, 16, 0xffff, n);\n}\n\nstatic inline u16 msg_syncpt(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 9, 16, 0xffff);\n}\n\nstatic inline void msg_set_syncpt(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 9, 16, 0xffff, n);\n}\n\nstatic inline u32 msg_conn_ack(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 9, 16, 0xffff);\n}\n\nstatic inline void msg_set_conn_ack(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 9, 16, 0xffff, n);\n}\n\nstatic inline u16 msg_adv_win(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 9, 0, 0xffff);\n}\n\nstatic inline void msg_set_adv_win(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 9, 0, 0xffff, n);\n}\n\nstatic inline u32 msg_max_pkt(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 9, 16, 0xffff) * 4;\n}\n\nstatic inline void msg_set_max_pkt(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 9, 16, 0xffff, (n / 4));\n}\n\nstatic inline u32 msg_link_tolerance(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 9, 0, 0xffff);\n}\n\nstatic inline void msg_set_link_tolerance(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 9, 0, 0xffff, n);\n}\n\nstatic inline u16 msg_grp_bc_syncpt(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 9, 16, 0xffff);\n}\n\nstatic inline void msg_set_grp_bc_syncpt(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 9, 16, 0xffff, n);\n}\n\nstatic inline u16 msg_grp_bc_acked(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 9, 16, 0xffff);\n}\n\nstatic inline void msg_set_grp_bc_acked(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 9, 16, 0xffff, n);\n}\n\nstatic inline u16 msg_grp_remitted(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 9, 16, 0xffff);\n}\n\nstatic inline void msg_set_grp_remitted(struct tipc_msg *m, u16 n)\n{\n\tmsg_set_bits(m, 9, 16, 0xffff, n);\n}\n\n \nstatic inline u16 msg_grp_evt(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 10, 0, 0x3);\n}\n\nstatic inline void msg_set_grp_evt(struct tipc_msg *m, int n)\n{\n\tmsg_set_bits(m, 10, 0, 0x3, n);\n}\n\nstatic inline u16 msg_grp_bc_ack_req(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 10, 0, 0x1);\n}\n\nstatic inline void msg_set_grp_bc_ack_req(struct tipc_msg *m, bool n)\n{\n\tmsg_set_bits(m, 10, 0, 0x1, n);\n}\n\nstatic inline u16 msg_grp_bc_seqno(struct tipc_msg *m)\n{\n\treturn msg_bits(m, 10, 16, 0xffff);\n}\n\nstatic inline void msg_set_grp_bc_seqno(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_bits(m, 10, 16, 0xffff, n);\n}\n\nstatic inline bool msg_peer_link_is_up(struct tipc_msg *m)\n{\n\tif (likely(msg_user(m) != LINK_PROTOCOL))\n\t\treturn true;\n\tif (msg_type(m) == STATE_MSG)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool msg_peer_node_is_up(struct tipc_msg *m)\n{\n\tif (msg_peer_link_is_up(m))\n\t\treturn true;\n\treturn msg_redundant_link(m);\n}\n\nstatic inline bool msg_is_reset(struct tipc_msg *hdr)\n{\n\treturn (msg_user(hdr) == LINK_PROTOCOL) && (msg_type(hdr) == RESET_MSG);\n}\n\n \nstatic inline void msg_set_peer_net_hash(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_word(m, 13, n);\n}\n\nstatic inline u32 msg_peer_net_hash(struct tipc_msg *m)\n{\n\treturn msg_word(m, 13);\n}\n\n \nstatic inline u32 msg_sugg_node_addr(struct tipc_msg *m)\n{\n\treturn msg_word(m, 14);\n}\n\nstatic inline void msg_set_sugg_node_addr(struct tipc_msg *m, u32 n)\n{\n\tmsg_set_word(m, 14, n);\n}\n\nstatic inline void msg_set_node_id(struct tipc_msg *hdr, u8 *id)\n{\n\tmemcpy(msg_data(hdr), id, 16);\n}\n\nstatic inline u8 *msg_node_id(struct tipc_msg *hdr)\n{\n\treturn (u8 *)msg_data(hdr);\n}\n\nstruct sk_buff *tipc_buf_acquire(u32 size, gfp_t gfp);\nbool tipc_msg_validate(struct sk_buff **_skb);\nbool tipc_msg_reverse(u32 own_addr, struct sk_buff **skb, int err);\nvoid tipc_skb_reject(struct net *net, int err, struct sk_buff *skb,\n\t\t     struct sk_buff_head *xmitq);\nvoid tipc_msg_init(u32 own_addr, struct tipc_msg *m, u32 user, u32 type,\n\t\t   u32 hsize, u32 destnode);\nstruct sk_buff *tipc_msg_create(uint user, uint type, uint hdr_sz,\n\t\t\t\tuint data_sz, u32 dnode, u32 onode,\n\t\t\t\tu32 dport, u32 oport, int errcode);\nint tipc_buf_append(struct sk_buff **headbuf, struct sk_buff **buf);\nbool tipc_msg_try_bundle(struct sk_buff *tskb, struct sk_buff **skb, u32 mss,\n\t\t\t u32 dnode, bool *new_bundle);\nbool tipc_msg_extract(struct sk_buff *skb, struct sk_buff **iskb, int *pos);\nint tipc_msg_fragment(struct sk_buff *skb, const struct tipc_msg *hdr,\n\t\t      int pktmax, struct sk_buff_head *frags);\nint tipc_msg_build(struct tipc_msg *mhdr, struct msghdr *m,\n\t\t   int offset, int dsz, int mtu, struct sk_buff_head *list);\nint tipc_msg_append(struct tipc_msg *hdr, struct msghdr *m, int dlen,\n\t\t    int mss, struct sk_buff_head *txq);\nbool tipc_msg_lookup_dest(struct net *net, struct sk_buff *skb, int *err);\nbool tipc_msg_assemble(struct sk_buff_head *list);\nbool tipc_msg_reassemble(struct sk_buff_head *list, struct sk_buff_head *rcvq);\nbool tipc_msg_pskb_copy(u32 dst, struct sk_buff_head *msg,\n\t\t\tstruct sk_buff_head *cpy);\nbool __tipc_skb_queue_sorted(struct sk_buff_head *list, u16 seqno,\n\t\t\t     struct sk_buff *skb);\nbool tipc_msg_skb_clone(struct sk_buff_head *msg, struct sk_buff_head *cpy);\n\nstatic inline u16 buf_seqno(struct sk_buff *skb)\n{\n\treturn msg_seqno(buf_msg(skb));\n}\n\nstatic inline int buf_roundup_len(struct sk_buff *skb)\n{\n\treturn (skb->len / 1024 + 1) * 1024;\n}\n\n \nstatic inline struct sk_buff *tipc_skb_peek(struct sk_buff_head *list,\n\t\t\t\t\t    spinlock_t *lock)\n{\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(lock);\n\tskb = skb_peek(list);\n\tif (skb)\n\t\tskb_get(skb);\n\tspin_unlock_bh(lock);\n\treturn skb;\n}\n\n \nstatic inline u32 tipc_skb_peek_port(struct sk_buff_head *list, u32 filter)\n{\n\tstruct sk_buff *skb;\n\tu32 dport = 0;\n\tbool ignore = true;\n\n\tspin_lock_bh(&list->lock);\n\tskb_queue_walk(list, skb) {\n\t\tdport = msg_destport(buf_msg(skb));\n\t\tif (!filter || skb_queue_is_last(list, skb))\n\t\t\tbreak;\n\t\tif (dport == filter)\n\t\t\tignore = false;\n\t\telse if (!ignore)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&list->lock);\n\treturn dport;\n}\n\n \nstatic inline struct sk_buff *tipc_skb_dequeue(struct sk_buff_head *list,\n\t\t\t\t\t       u32 dport)\n{\n\tstruct sk_buff *_skb, *tmp, *skb = NULL;\n\n\tspin_lock_bh(&list->lock);\n\tskb_queue_walk_safe(list, _skb, tmp) {\n\t\tif (msg_destport(buf_msg(_skb)) == dport) {\n\t\t\t__skb_unlink(_skb, list);\n\t\t\tskb = _skb;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&list->lock);\n\treturn skb;\n}\n\n \nstatic inline void tipc_skb_queue_splice_tail(struct sk_buff_head *list,\n\t\t\t\t\t      struct sk_buff_head *head)\n{\n\tspin_lock_bh(&head->lock);\n\tskb_queue_splice_tail(list, head);\n\tspin_unlock_bh(&head->lock);\n}\n\n \nstatic inline void tipc_skb_queue_splice_tail_init(struct sk_buff_head *list,\n\t\t\t\t\t\t   struct sk_buff_head *head)\n{\n\tstruct sk_buff_head tmp;\n\n\t__skb_queue_head_init(&tmp);\n\n\tspin_lock_bh(&list->lock);\n\tskb_queue_splice_tail_init(list, &tmp);\n\tspin_unlock_bh(&list->lock);\n\ttipc_skb_queue_splice_tail(&tmp, head);\n}\n\n \nstatic inline struct sk_buff *__tipc_skb_dequeue(struct sk_buff_head *list,\n\t\t\t\t\t\t u16 seqno)\n{\n\tstruct sk_buff *skb = skb_peek(list);\n\n\tif (skb && less_eq(buf_seqno(skb), seqno)) {\n\t\t__skb_unlink(skb, list);\n\t\treturn skb;\n\t}\n\treturn NULL;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}