{
  "module_name": "bearer.c",
  "hash_id": "128fcdd126f70a15b562fca2d9eb73a5451494352d95a4f27db210244ec5d615",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/bearer.c",
  "human_readable_source": " \n\n#include <net/sock.h>\n#include \"core.h\"\n#include \"bearer.h\"\n#include \"link.h\"\n#include \"discover.h\"\n#include \"monitor.h\"\n#include \"bcast.h\"\n#include \"netlink.h\"\n#include \"udp_media.h\"\n#include \"trace.h\"\n#include \"crypto.h\"\n\n#define MAX_ADDR_STR 60\n\nstatic struct tipc_media * const media_info_array[] = {\n\t&eth_media_info,\n#ifdef CONFIG_TIPC_MEDIA_IB\n\t&ib_media_info,\n#endif\n#ifdef CONFIG_TIPC_MEDIA_UDP\n\t&udp_media_info,\n#endif\n\tNULL\n};\n\nstatic struct tipc_bearer *bearer_get(struct net *net, int bearer_id)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\n\treturn rcu_dereference(tn->bearer_list[bearer_id]);\n}\n\nstatic void bearer_disable(struct net *net, struct tipc_bearer *b);\nstatic int tipc_l2_rcv_msg(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct packet_type *pt, struct net_device *orig_dev);\n\n \nstruct tipc_media *tipc_media_find(const char *name)\n{\n\tu32 i;\n\n\tfor (i = 0; media_info_array[i] != NULL; i++) {\n\t\tif (!strcmp(media_info_array[i]->name, name))\n\t\t\tbreak;\n\t}\n\treturn media_info_array[i];\n}\n\n \nstatic struct tipc_media *media_find_id(u8 type)\n{\n\tu32 i;\n\n\tfor (i = 0; media_info_array[i] != NULL; i++) {\n\t\tif (media_info_array[i]->type_id == type)\n\t\t\tbreak;\n\t}\n\treturn media_info_array[i];\n}\n\n \nint tipc_media_addr_printf(char *buf, int len, struct tipc_media_addr *a)\n{\n\tchar addr_str[MAX_ADDR_STR];\n\tstruct tipc_media *m;\n\tint ret;\n\n\tm = media_find_id(a->media_id);\n\n\tif (m && !m->addr2str(a, addr_str, sizeof(addr_str)))\n\t\tret = scnprintf(buf, len, \"%s(%s)\", m->name, addr_str);\n\telse {\n\t\tu32 i;\n\n\t\tret = scnprintf(buf, len, \"UNKNOWN(%u)\", a->media_id);\n\t\tfor (i = 0; i < sizeof(a->value); i++)\n\t\t\tret += scnprintf(buf + ret, len - ret,\n\t\t\t\t\t    \"-%x\", a->value[i]);\n\t}\n\treturn ret;\n}\n\n \nstatic int bearer_name_validate(const char *name,\n\t\t\t\tstruct tipc_bearer_names *name_parts)\n{\n\tchar name_copy[TIPC_MAX_BEARER_NAME];\n\tchar *media_name;\n\tchar *if_name;\n\tu32 media_len;\n\tu32 if_len;\n\n\t \n\tif (strscpy(name_copy, name, TIPC_MAX_BEARER_NAME) < 0)\n\t\treturn 0;\n\n\t \n\tmedia_name = name_copy;\n\tif_name = strchr(media_name, ':');\n\tif (if_name == NULL)\n\t\treturn 0;\n\t*(if_name++) = 0;\n\tmedia_len = if_name - media_name;\n\tif_len = strlen(if_name) + 1;\n\n\t \n\tif ((media_len <= 1) || (media_len > TIPC_MAX_MEDIA_NAME) ||\n\t    (if_len <= 1) || (if_len > TIPC_MAX_IF_NAME))\n\t\treturn 0;\n\n\t \n\tif (name_parts) {\n\t\tstrcpy(name_parts->media_name, media_name);\n\t\tstrcpy(name_parts->if_name, if_name);\n\t}\n\treturn 1;\n}\n\n \nstruct tipc_bearer *tipc_bearer_find(struct net *net, const char *name)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_bearer *b;\n\tu32 i;\n\n\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\tb = rtnl_dereference(tn->bearer_list[i]);\n\t\tif (b && (!strcmp(b->name, name)))\n\t\t\treturn b;\n\t}\n\treturn NULL;\n}\n\n \nint tipc_bearer_get_name(struct net *net, char *name, u32 bearer_id)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_bearer *b;\n\n\tif (bearer_id >= MAX_BEARERS)\n\t\treturn -EINVAL;\n\n\tb = rtnl_dereference(tn->bearer_list[bearer_id]);\n\tif (!b)\n\t\treturn -EINVAL;\n\n\tstrcpy(name, b->name);\n\treturn 0;\n}\n\nvoid tipc_bearer_add_dest(struct net *net, u32 bearer_id, u32 dest)\n{\n\tstruct tipc_bearer *b;\n\n\trcu_read_lock();\n\tb = bearer_get(net, bearer_id);\n\tif (b)\n\t\ttipc_disc_add_dest(b->disc);\n\trcu_read_unlock();\n}\n\nvoid tipc_bearer_remove_dest(struct net *net, u32 bearer_id, u32 dest)\n{\n\tstruct tipc_bearer *b;\n\n\trcu_read_lock();\n\tb = bearer_get(net, bearer_id);\n\tif (b)\n\t\ttipc_disc_remove_dest(b->disc);\n\trcu_read_unlock();\n}\n\n \nstatic int tipc_enable_bearer(struct net *net, const char *name,\n\t\t\t      u32 disc_domain, u32 prio,\n\t\t\t      struct nlattr *attr[],\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_bearer_names b_names;\n\tint with_this_prio = 1;\n\tstruct tipc_bearer *b;\n\tstruct tipc_media *m;\n\tstruct sk_buff *skb;\n\tint bearer_id = 0;\n\tint res = -EINVAL;\n\tchar *errstr = \"\";\n\tu32 i;\n\n\tif (!bearer_name_validate(name, &b_names)) {\n\t\tNL_SET_ERR_MSG(extack, \"Illegal name\");\n\t\treturn res;\n\t}\n\n\tif (prio > TIPC_MAX_LINK_PRI && prio != TIPC_MEDIA_LINK_PRI) {\n\t\terrstr = \"illegal priority\";\n\t\tNL_SET_ERR_MSG(extack, \"Illegal priority\");\n\t\tgoto rejected;\n\t}\n\n\tm = tipc_media_find(b_names.media_name);\n\tif (!m) {\n\t\terrstr = \"media not registered\";\n\t\tNL_SET_ERR_MSG(extack, \"Media not registered\");\n\t\tgoto rejected;\n\t}\n\n\tif (prio == TIPC_MEDIA_LINK_PRI)\n\t\tprio = m->priority;\n\n\t \n\tbearer_id = MAX_BEARERS;\n\ti = MAX_BEARERS;\n\twhile (i-- != 0) {\n\t\tb = rtnl_dereference(tn->bearer_list[i]);\n\t\tif (!b) {\n\t\t\tbearer_id = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(name, b->name)) {\n\t\t\terrstr = \"already enabled\";\n\t\t\tNL_SET_ERR_MSG(extack, \"Already enabled\");\n\t\t\tgoto rejected;\n\t\t}\n\n\t\tif (b->priority == prio &&\n\t\t    (++with_this_prio > 2)) {\n\t\t\tpr_warn(\"Bearer <%s>: already 2 bearers with priority %u\\n\",\n\t\t\t\tname, prio);\n\n\t\t\tif (prio == TIPC_MIN_LINK_PRI) {\n\t\t\t\terrstr = \"cannot adjust to lower\";\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Cannot adjust to lower\");\n\t\t\t\tgoto rejected;\n\t\t\t}\n\n\t\t\tpr_warn(\"Bearer <%s>: trying with adjusted priority\\n\",\n\t\t\t\tname);\n\t\t\tprio--;\n\t\t\tbearer_id = MAX_BEARERS;\n\t\t\ti = MAX_BEARERS;\n\t\t\twith_this_prio = 1;\n\t\t}\n\t}\n\n\tif (bearer_id >= MAX_BEARERS) {\n\t\terrstr = \"max 3 bearers permitted\";\n\t\tNL_SET_ERR_MSG(extack, \"Max 3 bearers permitted\");\n\t\tgoto rejected;\n\t}\n\n\tb = kzalloc(sizeof(*b), GFP_ATOMIC);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tstrcpy(b->name, name);\n\tb->media = m;\n\tres = m->enable_media(net, b, attr);\n\tif (res) {\n\t\tkfree(b);\n\t\terrstr = \"failed to enable media\";\n\t\tNL_SET_ERR_MSG(extack, \"Failed to enable media\");\n\t\tgoto rejected;\n\t}\n\n\tb->identity = bearer_id;\n\tb->tolerance = m->tolerance;\n\tb->min_win = m->min_win;\n\tb->max_win = m->max_win;\n\tb->domain = disc_domain;\n\tb->net_plane = bearer_id + 'A';\n\tb->priority = prio;\n\trefcount_set(&b->refcnt, 1);\n\n\tres = tipc_disc_create(net, b, &b->bcast_addr, &skb);\n\tif (res) {\n\t\tbearer_disable(net, b);\n\t\terrstr = \"failed to create discoverer\";\n\t\tNL_SET_ERR_MSG(extack, \"Failed to create discoverer\");\n\t\tgoto rejected;\n\t}\n\n\t \n\tif (tipc_mon_create(net, bearer_id)) {\n\t\tbearer_disable(net, b);\n\t\tkfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\ttest_and_set_bit_lock(0, &b->up);\n\trcu_assign_pointer(tn->bearer_list[bearer_id], b);\n\tif (skb)\n\t\ttipc_bearer_xmit_skb(net, bearer_id, skb, &b->bcast_addr);\n\n\tpr_info(\"Enabled bearer <%s>, priority %u\\n\", name, prio);\n\n\treturn res;\nrejected:\n\tpr_warn(\"Enabling of bearer <%s> rejected, %s\\n\", name, errstr);\n\treturn res;\n}\n\n \nstatic int tipc_reset_bearer(struct net *net, struct tipc_bearer *b)\n{\n\tpr_info(\"Resetting bearer <%s>\\n\", b->name);\n\ttipc_node_delete_links(net, b->identity);\n\ttipc_disc_reset(net, b);\n\treturn 0;\n}\n\nbool tipc_bearer_hold(struct tipc_bearer *b)\n{\n\treturn (b && refcount_inc_not_zero(&b->refcnt));\n}\n\nvoid tipc_bearer_put(struct tipc_bearer *b)\n{\n\tif (b && refcount_dec_and_test(&b->refcnt))\n\t\tkfree_rcu(b, rcu);\n}\n\n \nstatic void bearer_disable(struct net *net, struct tipc_bearer *b)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tint bearer_id = b->identity;\n\n\tpr_info(\"Disabling bearer <%s>\\n\", b->name);\n\tclear_bit_unlock(0, &b->up);\n\ttipc_node_delete_links(net, bearer_id);\n\tb->media->disable_media(b);\n\tRCU_INIT_POINTER(b->media_ptr, NULL);\n\tif (b->disc)\n\t\ttipc_disc_delete(b->disc);\n\tRCU_INIT_POINTER(tn->bearer_list[bearer_id], NULL);\n\ttipc_bearer_put(b);\n\ttipc_mon_delete(net, bearer_id);\n}\n\nint tipc_enable_l2_media(struct net *net, struct tipc_bearer *b,\n\t\t\t struct nlattr *attr[])\n{\n\tchar *dev_name = strchr((const char *)b->name, ':') + 1;\n\tint hwaddr_len = b->media->hwaddr_len;\n\tu8 node_id[NODE_ID_LEN] = {0,};\n\tstruct net_device *dev;\n\n\t \n\tdev = dev_get_by_name(net, dev_name);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tif (tipc_mtu_bad(dev)) {\n\t\tdev_put(dev);\n\t\treturn -EINVAL;\n\t}\n\tif (dev == net->loopback_dev) {\n\t\tdev_put(dev);\n\t\tpr_info(\"Enabling <%s> not permitted\\n\", b->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!tipc_own_id(net) && hwaddr_len <= NODE_ID_LEN) {\n\t\tmemcpy(node_id, dev->dev_addr, hwaddr_len);\n\t\ttipc_net_init(net, node_id, 0);\n\t}\n\tif (!tipc_own_id(net)) {\n\t\tdev_put(dev);\n\t\tpr_warn(\"Failed to obtain node identity\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trcu_assign_pointer(b->media_ptr, dev);\n\tb->pt.dev = dev;\n\tb->pt.type = htons(ETH_P_TIPC);\n\tb->pt.func = tipc_l2_rcv_msg;\n\tdev_add_pack(&b->pt);\n\tmemset(&b->bcast_addr, 0, sizeof(b->bcast_addr));\n\tmemcpy(b->bcast_addr.value, dev->broadcast, hwaddr_len);\n\tb->bcast_addr.media_id = b->media->type_id;\n\tb->bcast_addr.broadcast = TIPC_BROADCAST_SUPPORT;\n\tb->mtu = dev->mtu;\n\tb->media->raw2addr(b, &b->addr, (const char *)dev->dev_addr);\n\trcu_assign_pointer(dev->tipc_ptr, b);\n\treturn 0;\n}\n\n \nvoid tipc_disable_l2_media(struct tipc_bearer *b)\n{\n\tstruct net_device *dev;\n\n\tdev = (struct net_device *)rtnl_dereference(b->media_ptr);\n\tdev_remove_pack(&b->pt);\n\tRCU_INIT_POINTER(dev->tipc_ptr, NULL);\n\tsynchronize_net();\n\tdev_put(dev);\n}\n\n \nint tipc_l2_send_msg(struct net *net, struct sk_buff *skb,\n\t\t     struct tipc_bearer *b, struct tipc_media_addr *dest)\n{\n\tstruct net_device *dev;\n\tint delta;\n\n\tdev = (struct net_device *)rcu_dereference(b->media_ptr);\n\tif (!dev)\n\t\treturn 0;\n\n\tdelta = SKB_DATA_ALIGN(dev->hard_header_len - skb_headroom(skb));\n\tif ((delta > 0) && pskb_expand_head(skb, delta, 0, GFP_ATOMIC)) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\tskb_reset_network_header(skb);\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_TIPC);\n\tdev_hard_header(skb, dev, ETH_P_TIPC, dest->value,\n\t\t\tdev->dev_addr, skb->len);\n\tdev_queue_xmit(skb);\n\treturn 0;\n}\n\nbool tipc_bearer_bcast_support(struct net *net, u32 bearer_id)\n{\n\tbool supp = false;\n\tstruct tipc_bearer *b;\n\n\trcu_read_lock();\n\tb = bearer_get(net, bearer_id);\n\tif (b)\n\t\tsupp = (b->bcast_addr.broadcast == TIPC_BROADCAST_SUPPORT);\n\trcu_read_unlock();\n\treturn supp;\n}\n\nint tipc_bearer_mtu(struct net *net, u32 bearer_id)\n{\n\tint mtu = 0;\n\tstruct tipc_bearer *b;\n\n\trcu_read_lock();\n\tb = bearer_get(net, bearer_id);\n\tif (b)\n\t\tmtu = b->mtu;\n\trcu_read_unlock();\n\treturn mtu;\n}\n\nint tipc_bearer_min_mtu(struct net *net, u32 bearer_id)\n{\n\tint mtu = TIPC_MIN_BEARER_MTU;\n\tstruct tipc_bearer *b;\n\n\trcu_read_lock();\n\tb = bearer_get(net, bearer_id);\n\tif (b)\n\t\tmtu += b->encap_hlen;\n\trcu_read_unlock();\n\treturn mtu;\n}\n\n \nvoid tipc_bearer_xmit_skb(struct net *net, u32 bearer_id,\n\t\t\t  struct sk_buff *skb,\n\t\t\t  struct tipc_media_addr *dest)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tstruct tipc_bearer *b;\n\n\trcu_read_lock();\n\tb = bearer_get(net, bearer_id);\n\tif (likely(b && (test_bit(0, &b->up) || msg_is_reset(hdr)))) {\n#ifdef CONFIG_TIPC_CRYPTO\n\t\ttipc_crypto_xmit(net, &skb, b, dest, NULL);\n\t\tif (skb)\n#endif\n\t\t\tb->media->send_msg(net, skb, b, dest);\n\t} else {\n\t\tkfree_skb(skb);\n\t}\n\trcu_read_unlock();\n}\n\n \nvoid tipc_bearer_xmit(struct net *net, u32 bearer_id,\n\t\t      struct sk_buff_head *xmitq,\n\t\t      struct tipc_media_addr *dst,\n\t\t      struct tipc_node *__dnode)\n{\n\tstruct tipc_bearer *b;\n\tstruct sk_buff *skb, *tmp;\n\n\tif (skb_queue_empty(xmitq))\n\t\treturn;\n\n\trcu_read_lock();\n\tb = bearer_get(net, bearer_id);\n\tif (unlikely(!b))\n\t\t__skb_queue_purge(xmitq);\n\tskb_queue_walk_safe(xmitq, skb, tmp) {\n\t\t__skb_dequeue(xmitq);\n\t\tif (likely(test_bit(0, &b->up) || msg_is_reset(buf_msg(skb)))) {\n#ifdef CONFIG_TIPC_CRYPTO\n\t\t\ttipc_crypto_xmit(net, &skb, b, dst, __dnode);\n\t\t\tif (skb)\n#endif\n\t\t\t\tb->media->send_msg(net, skb, b, dst);\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n \nvoid tipc_bearer_bc_xmit(struct net *net, u32 bearer_id,\n\t\t\t struct sk_buff_head *xmitq)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_media_addr *dst;\n\tint net_id = tn->net_id;\n\tstruct tipc_bearer *b;\n\tstruct sk_buff *skb, *tmp;\n\tstruct tipc_msg *hdr;\n\n\trcu_read_lock();\n\tb = bearer_get(net, bearer_id);\n\tif (unlikely(!b || !test_bit(0, &b->up)))\n\t\t__skb_queue_purge(xmitq);\n\tskb_queue_walk_safe(xmitq, skb, tmp) {\n\t\thdr = buf_msg(skb);\n\t\tmsg_set_non_seq(hdr, 1);\n\t\tmsg_set_mc_netid(hdr, net_id);\n\t\t__skb_dequeue(xmitq);\n\t\tdst = &b->bcast_addr;\n#ifdef CONFIG_TIPC_CRYPTO\n\t\ttipc_crypto_xmit(net, &skb, b, dst, NULL);\n\t\tif (skb)\n#endif\n\t\t\tb->media->send_msg(net, skb, b, dst);\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic int tipc_l2_rcv_msg(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct tipc_bearer *b;\n\n\trcu_read_lock();\n\tb = rcu_dereference(dev->tipc_ptr) ?:\n\t\trcu_dereference(orig_dev->tipc_ptr);\n\tif (likely(b && test_bit(0, &b->up) &&\n\t\t   (skb->pkt_type <= PACKET_MULTICAST))) {\n\t\tskb_mark_not_on_list(skb);\n\t\tTIPC_SKB_CB(skb)->flags = 0;\n\t\ttipc_rcv(dev_net(b->pt.dev), skb, b);\n\t\trcu_read_unlock();\n\t\treturn NET_RX_SUCCESS;\n\t}\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\n \nstatic int tipc_l2_device_event(struct notifier_block *nb, unsigned long evt,\n\t\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\tstruct tipc_bearer *b;\n\n\tb = rtnl_dereference(dev->tipc_ptr);\n\tif (!b)\n\t\treturn NOTIFY_DONE;\n\n\ttrace_tipc_l2_device_event(dev, b, evt);\n\tswitch (evt) {\n\tcase NETDEV_CHANGE:\n\t\tif (netif_carrier_ok(dev) && netif_oper_up(dev)) {\n\t\t\ttest_and_set_bit_lock(0, &b->up);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase NETDEV_GOING_DOWN:\n\t\tclear_bit_unlock(0, &b->up);\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\ttest_and_set_bit_lock(0, &b->up);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (tipc_mtu_bad(dev)) {\n\t\t\tbearer_disable(net, b);\n\t\t\tbreak;\n\t\t}\n\t\tb->mtu = dev->mtu;\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_CHANGEADDR:\n\t\tb->media->raw2addr(b, &b->addr,\n\t\t\t\t   (const char *)dev->dev_addr);\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\tcase NETDEV_CHANGENAME:\n\t\tbearer_disable(net, b);\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block notifier = {\n\t.notifier_call  = tipc_l2_device_event,\n\t.priority\t= 0,\n};\n\nint tipc_bearer_setup(void)\n{\n\treturn register_netdevice_notifier(&notifier);\n}\n\nvoid tipc_bearer_cleanup(void)\n{\n\tunregister_netdevice_notifier(&notifier);\n}\n\nvoid tipc_bearer_stop(struct net *net)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_bearer *b;\n\tu32 i;\n\n\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\tb = rtnl_dereference(tn->bearer_list[i]);\n\t\tif (b) {\n\t\t\tbearer_disable(net, b);\n\t\t\ttn->bearer_list[i] = NULL;\n\t\t}\n\t}\n}\n\nvoid tipc_clone_to_loopback(struct net *net, struct sk_buff_head *pkts)\n{\n\tstruct net_device *dev = net->loopback_dev;\n\tstruct sk_buff *skb, *_skb;\n\tint exp;\n\n\tskb_queue_walk(pkts, _skb) {\n\t\tskb = pskb_copy(_skb, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\texp = SKB_DATA_ALIGN(dev->hard_header_len - skb_headroom(skb));\n\t\tif (exp > 0 && pskb_expand_head(skb, exp, 0, GFP_ATOMIC)) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb_reset_network_header(skb);\n\t\tdev_hard_header(skb, dev, ETH_P_TIPC, dev->dev_addr,\n\t\t\t\tdev->dev_addr, skb->len);\n\t\tskb->dev = dev;\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic int tipc_loopback_rcv_pkt(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t struct packet_type *pt, struct net_device *od)\n{\n\tconsume_skb(skb);\n\treturn NET_RX_SUCCESS;\n}\n\nint tipc_attach_loopback(struct net *net)\n{\n\tstruct net_device *dev = net->loopback_dev;\n\tstruct tipc_net *tn = tipc_net(net);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tnetdev_hold(dev, &tn->loopback_pt.dev_tracker, GFP_KERNEL);\n\ttn->loopback_pt.dev = dev;\n\ttn->loopback_pt.type = htons(ETH_P_TIPC);\n\ttn->loopback_pt.func = tipc_loopback_rcv_pkt;\n\tdev_add_pack(&tn->loopback_pt);\n\treturn 0;\n}\n\nvoid tipc_detach_loopback(struct net *net)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\n\tdev_remove_pack(&tn->loopback_pt);\n\tnetdev_put(net->loopback_dev, &tn->loopback_pt.dev_tracker);\n}\n\n \nstatic int __tipc_nl_add_bearer(struct tipc_nl_msg *msg,\n\t\t\t\tstruct tipc_bearer *bearer, int nlflags)\n{\n\tvoid *hdr;\n\tstruct nlattr *attrs;\n\tstruct nlattr *prop;\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  nlflags, TIPC_NL_BEARER_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_BEARER);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\tif (nla_put_string(msg->skb, TIPC_NLA_BEARER_NAME, bearer->name))\n\t\tgoto attr_msg_full;\n\n\tprop = nla_nest_start_noflag(msg->skb, TIPC_NLA_BEARER_PROP);\n\tif (!prop)\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_PRIO, bearer->priority))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_TOL, bearer->tolerance))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_WIN, bearer->max_win))\n\t\tgoto prop_msg_full;\n\tif (bearer->media->type_id == TIPC_MEDIA_TYPE_UDP)\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_MTU, bearer->mtu))\n\t\t\tgoto prop_msg_full;\n\n\tnla_nest_end(msg->skb, prop);\n\n#ifdef CONFIG_TIPC_MEDIA_UDP\n\tif (bearer->media->type_id == TIPC_MEDIA_TYPE_UDP) {\n\t\tif (tipc_udp_nl_add_bearer_data(msg, bearer))\n\t\t\tgoto attr_msg_full;\n\t}\n#endif\n\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nprop_msg_full:\n\tnla_nest_cancel(msg->skb, prop);\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nint tipc_nl_bearer_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tint i = cb->args[0];\n\tstruct tipc_bearer *bearer;\n\tstruct tipc_nl_msg msg;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_net *tn = tipc_net(net);\n\n\tif (i == MAX_BEARERS)\n\t\treturn 0;\n\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\n\trtnl_lock();\n\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\tbearer = rtnl_dereference(tn->bearer_list[i]);\n\t\tif (!bearer)\n\t\t\tcontinue;\n\n\t\terr = __tipc_nl_add_bearer(&msg, bearer, NLM_F_MULTI);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tcb->args[0] = i;\n\treturn skb->len;\n}\n\nint tipc_nl_bearer_get(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\tchar *name;\n\tstruct sk_buff *rep;\n\tstruct tipc_bearer *bearer;\n\tstruct tipc_nl_msg msg;\n\tstruct nlattr *attrs[TIPC_NLA_BEARER_MAX + 1];\n\tstruct net *net = genl_info_net(info);\n\n\tif (!info->attrs[TIPC_NLA_BEARER])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_BEARER_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_BEARER],\n\t\t\t\t\t  tipc_nl_bearer_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!attrs[TIPC_NLA_BEARER_NAME])\n\t\treturn -EINVAL;\n\tname = nla_data(attrs[TIPC_NLA_BEARER_NAME]);\n\n\trep = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!rep)\n\t\treturn -ENOMEM;\n\n\tmsg.skb = rep;\n\tmsg.portid = info->snd_portid;\n\tmsg.seq = info->snd_seq;\n\n\trtnl_lock();\n\tbearer = tipc_bearer_find(net, name);\n\tif (!bearer) {\n\t\terr = -EINVAL;\n\t\tNL_SET_ERR_MSG(info->extack, \"Bearer not found\");\n\t\tgoto err_out;\n\t}\n\n\terr = __tipc_nl_add_bearer(&msg, bearer, 0);\n\tif (err)\n\t\tgoto err_out;\n\trtnl_unlock();\n\n\treturn genlmsg_reply(rep, info);\nerr_out:\n\trtnl_unlock();\n\tnlmsg_free(rep);\n\n\treturn err;\n}\n\nint __tipc_nl_bearer_disable(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\tchar *name;\n\tstruct tipc_bearer *bearer;\n\tstruct nlattr *attrs[TIPC_NLA_BEARER_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (!info->attrs[TIPC_NLA_BEARER])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_BEARER_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_BEARER],\n\t\t\t\t\t  tipc_nl_bearer_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!attrs[TIPC_NLA_BEARER_NAME])\n\t\treturn -EINVAL;\n\n\tname = nla_data(attrs[TIPC_NLA_BEARER_NAME]);\n\n\tbearer = tipc_bearer_find(net, name);\n\tif (!bearer) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Bearer not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tbearer_disable(net, bearer);\n\n\treturn 0;\n}\n\nint tipc_nl_bearer_disable(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __tipc_nl_bearer_disable(skb, info);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nint __tipc_nl_bearer_enable(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\tchar *bearer;\n\tstruct nlattr *attrs[TIPC_NLA_BEARER_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\tu32 domain = 0;\n\tu32 prio;\n\n\tprio = TIPC_MEDIA_LINK_PRI;\n\n\tif (!info->attrs[TIPC_NLA_BEARER])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_BEARER_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_BEARER],\n\t\t\t\t\t  tipc_nl_bearer_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!attrs[TIPC_NLA_BEARER_NAME])\n\t\treturn -EINVAL;\n\n\tbearer = nla_data(attrs[TIPC_NLA_BEARER_NAME]);\n\n\tif (attrs[TIPC_NLA_BEARER_DOMAIN])\n\t\tdomain = nla_get_u32(attrs[TIPC_NLA_BEARER_DOMAIN]);\n\n\tif (attrs[TIPC_NLA_BEARER_PROP]) {\n\t\tstruct nlattr *props[TIPC_NLA_PROP_MAX + 1];\n\n\t\terr = tipc_nl_parse_link_prop(attrs[TIPC_NLA_BEARER_PROP],\n\t\t\t\t\t      props);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (props[TIPC_NLA_PROP_PRIO])\n\t\t\tprio = nla_get_u32(props[TIPC_NLA_PROP_PRIO]);\n\t}\n\n\treturn tipc_enable_bearer(net, bearer, domain, prio, attrs,\n\t\t\t\t  info->extack);\n}\n\nint tipc_nl_bearer_enable(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __tipc_nl_bearer_enable(skb, info);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nint tipc_nl_bearer_add(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\tchar *name;\n\tstruct tipc_bearer *b;\n\tstruct nlattr *attrs[TIPC_NLA_BEARER_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (!info->attrs[TIPC_NLA_BEARER])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_BEARER_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_BEARER],\n\t\t\t\t\t  tipc_nl_bearer_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!attrs[TIPC_NLA_BEARER_NAME])\n\t\treturn -EINVAL;\n\tname = nla_data(attrs[TIPC_NLA_BEARER_NAME]);\n\n\trtnl_lock();\n\tb = tipc_bearer_find(net, name);\n\tif (!b) {\n\t\trtnl_unlock();\n\t\tNL_SET_ERR_MSG(info->extack, \"Bearer not found\");\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_TIPC_MEDIA_UDP\n\tif (attrs[TIPC_NLA_BEARER_UDP_OPTS]) {\n\t\terr = tipc_udp_nl_bearer_add(b,\n\t\t\t\t\t     attrs[TIPC_NLA_BEARER_UDP_OPTS]);\n\t\tif (err) {\n\t\t\trtnl_unlock();\n\t\t\treturn err;\n\t\t}\n\t}\n#endif\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nint __tipc_nl_bearer_set(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct tipc_bearer *b;\n\tstruct nlattr *attrs[TIPC_NLA_BEARER_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\tchar *name;\n\tint err;\n\n\tif (!info->attrs[TIPC_NLA_BEARER])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_BEARER_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_BEARER],\n\t\t\t\t\t  tipc_nl_bearer_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!attrs[TIPC_NLA_BEARER_NAME])\n\t\treturn -EINVAL;\n\tname = nla_data(attrs[TIPC_NLA_BEARER_NAME]);\n\n\tb = tipc_bearer_find(net, name);\n\tif (!b) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Bearer not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[TIPC_NLA_BEARER_PROP]) {\n\t\tstruct nlattr *props[TIPC_NLA_PROP_MAX + 1];\n\n\t\terr = tipc_nl_parse_link_prop(attrs[TIPC_NLA_BEARER_PROP],\n\t\t\t\t\t      props);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (props[TIPC_NLA_PROP_TOL]) {\n\t\t\tb->tolerance = nla_get_u32(props[TIPC_NLA_PROP_TOL]);\n\t\t\ttipc_node_apply_property(net, b, TIPC_NLA_PROP_TOL);\n\t\t}\n\t\tif (props[TIPC_NLA_PROP_PRIO])\n\t\t\tb->priority = nla_get_u32(props[TIPC_NLA_PROP_PRIO]);\n\t\tif (props[TIPC_NLA_PROP_WIN])\n\t\t\tb->max_win = nla_get_u32(props[TIPC_NLA_PROP_WIN]);\n\t\tif (props[TIPC_NLA_PROP_MTU]) {\n\t\t\tif (b->media->type_id != TIPC_MEDIA_TYPE_UDP) {\n\t\t\t\tNL_SET_ERR_MSG(info->extack,\n\t\t\t\t\t       \"MTU property is unsupported\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n#ifdef CONFIG_TIPC_MEDIA_UDP\n\t\t\tif (nla_get_u32(props[TIPC_NLA_PROP_MTU]) <\n\t\t\t    b->encap_hlen + TIPC_MIN_BEARER_MTU) {\n\t\t\t\tNL_SET_ERR_MSG(info->extack,\n\t\t\t\t\t       \"MTU value is out-of-range\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tb->mtu = nla_get_u32(props[TIPC_NLA_PROP_MTU]);\n\t\t\ttipc_node_apply_property(net, b, TIPC_NLA_PROP_MTU);\n#endif\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint tipc_nl_bearer_set(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __tipc_nl_bearer_set(skb, info);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic int __tipc_nl_add_media(struct tipc_nl_msg *msg,\n\t\t\t       struct tipc_media *media, int nlflags)\n{\n\tvoid *hdr;\n\tstruct nlattr *attrs;\n\tstruct nlattr *prop;\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  nlflags, TIPC_NL_MEDIA_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_MEDIA);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\tif (nla_put_string(msg->skb, TIPC_NLA_MEDIA_NAME, media->name))\n\t\tgoto attr_msg_full;\n\n\tprop = nla_nest_start_noflag(msg->skb, TIPC_NLA_MEDIA_PROP);\n\tif (!prop)\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_PRIO, media->priority))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_TOL, media->tolerance))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_WIN, media->max_win))\n\t\tgoto prop_msg_full;\n\tif (media->type_id == TIPC_MEDIA_TYPE_UDP)\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_MTU, media->mtu))\n\t\t\tgoto prop_msg_full;\n\n\tnla_nest_end(msg->skb, prop);\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nprop_msg_full:\n\tnla_nest_cancel(msg->skb, prop);\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nint tipc_nl_media_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tint i = cb->args[0];\n\tstruct tipc_nl_msg msg;\n\n\tif (i == MAX_MEDIA)\n\t\treturn 0;\n\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\n\trtnl_lock();\n\tfor (; media_info_array[i] != NULL; i++) {\n\t\terr = __tipc_nl_add_media(&msg, media_info_array[i],\n\t\t\t\t\t  NLM_F_MULTI);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tcb->args[0] = i;\n\treturn skb->len;\n}\n\nint tipc_nl_media_get(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\tchar *name;\n\tstruct tipc_nl_msg msg;\n\tstruct tipc_media *media;\n\tstruct sk_buff *rep;\n\tstruct nlattr *attrs[TIPC_NLA_MEDIA_MAX + 1];\n\n\tif (!info->attrs[TIPC_NLA_MEDIA])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_MEDIA_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_MEDIA],\n\t\t\t\t\t  tipc_nl_media_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!attrs[TIPC_NLA_MEDIA_NAME])\n\t\treturn -EINVAL;\n\tname = nla_data(attrs[TIPC_NLA_MEDIA_NAME]);\n\n\trep = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!rep)\n\t\treturn -ENOMEM;\n\n\tmsg.skb = rep;\n\tmsg.portid = info->snd_portid;\n\tmsg.seq = info->snd_seq;\n\n\trtnl_lock();\n\tmedia = tipc_media_find(name);\n\tif (!media) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Media not found\");\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\terr = __tipc_nl_add_media(&msg, media, 0);\n\tif (err)\n\t\tgoto err_out;\n\trtnl_unlock();\n\n\treturn genlmsg_reply(rep, info);\nerr_out:\n\trtnl_unlock();\n\tnlmsg_free(rep);\n\n\treturn err;\n}\n\nint __tipc_nl_media_set(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\tchar *name;\n\tstruct tipc_media *m;\n\tstruct nlattr *attrs[TIPC_NLA_MEDIA_MAX + 1];\n\n\tif (!info->attrs[TIPC_NLA_MEDIA])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_MEDIA_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_MEDIA],\n\t\t\t\t\t  tipc_nl_media_policy, info->extack);\n\n\tif (!attrs[TIPC_NLA_MEDIA_NAME])\n\t\treturn -EINVAL;\n\tname = nla_data(attrs[TIPC_NLA_MEDIA_NAME]);\n\n\tm = tipc_media_find(name);\n\tif (!m) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Media not found\");\n\t\treturn -EINVAL;\n\t}\n\tif (attrs[TIPC_NLA_MEDIA_PROP]) {\n\t\tstruct nlattr *props[TIPC_NLA_PROP_MAX + 1];\n\n\t\terr = tipc_nl_parse_link_prop(attrs[TIPC_NLA_MEDIA_PROP],\n\t\t\t\t\t      props);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (props[TIPC_NLA_PROP_TOL])\n\t\t\tm->tolerance = nla_get_u32(props[TIPC_NLA_PROP_TOL]);\n\t\tif (props[TIPC_NLA_PROP_PRIO])\n\t\t\tm->priority = nla_get_u32(props[TIPC_NLA_PROP_PRIO]);\n\t\tif (props[TIPC_NLA_PROP_WIN])\n\t\t\tm->max_win = nla_get_u32(props[TIPC_NLA_PROP_WIN]);\n\t\tif (props[TIPC_NLA_PROP_MTU]) {\n\t\t\tif (m->type_id != TIPC_MEDIA_TYPE_UDP) {\n\t\t\t\tNL_SET_ERR_MSG(info->extack,\n\t\t\t\t\t       \"MTU property is unsupported\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n#ifdef CONFIG_TIPC_MEDIA_UDP\n\t\t\tif (tipc_udp_mtu_bad(nla_get_u32\n\t\t\t\t\t     (props[TIPC_NLA_PROP_MTU]))) {\n\t\t\t\tNL_SET_ERR_MSG(info->extack,\n\t\t\t\t\t       \"MTU value is out-of-range\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tm->mtu = nla_get_u32(props[TIPC_NLA_PROP_MTU]);\n#endif\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint tipc_nl_media_set(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __tipc_nl_media_set(skb, info);\n\trtnl_unlock();\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}