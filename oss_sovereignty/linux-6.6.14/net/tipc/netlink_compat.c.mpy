{
  "module_name": "netlink_compat.c",
  "hash_id": "eca6efe95b0507271a225f69f4d9b3a40f09cb69cad347d69ce22fee367f16e7",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/netlink_compat.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"bearer.h\"\n#include \"link.h\"\n#include \"name_table.h\"\n#include \"socket.h\"\n#include \"node.h\"\n#include \"net.h\"\n#include <net/genetlink.h>\n#include <linux/string_helpers.h>\n#include <linux/tipc_config.h>\n\n \n#define ULTRA_STRING_MAX_LEN 32768\n\n#define TIPC_SKB_MAX TLV_SPACE(ULTRA_STRING_MAX_LEN)\n\n#define REPLY_TRUNCATED \"<truncated>\\n\"\n\nstruct tipc_nl_compat_msg {\n\tu16 cmd;\n\tint rep_type;\n\tint rep_size;\n\tint req_type;\n\tint req_size;\n\tstruct net *net;\n\tstruct sk_buff *rep;\n\tstruct tlv_desc *req;\n\tstruct sock *dst_sk;\n};\n\nstruct tipc_nl_compat_cmd_dump {\n\tint (*header)(struct tipc_nl_compat_msg *);\n\tint (*dumpit)(struct sk_buff *, struct netlink_callback *);\n\tint (*format)(struct tipc_nl_compat_msg *msg, struct nlattr **attrs);\n};\n\nstruct tipc_nl_compat_cmd_doit {\n\tint (*doit)(struct sk_buff *skb, struct genl_info *info);\n\tint (*transcode)(struct tipc_nl_compat_cmd_doit *cmd,\n\t\t\t struct sk_buff *skb, struct tipc_nl_compat_msg *msg);\n};\n\nstatic int tipc_skb_tailroom(struct sk_buff *skb)\n{\n\tint tailroom;\n\tint limit;\n\n\ttailroom = skb_tailroom(skb);\n\tlimit = TIPC_SKB_MAX - skb->len;\n\n\tif (tailroom < limit)\n\t\treturn tailroom;\n\n\treturn limit;\n}\n\nstatic inline int TLV_GET_DATA_LEN(struct tlv_desc *tlv)\n{\n\treturn TLV_GET_LEN(tlv) - TLV_SPACE(0);\n}\n\nstatic int tipc_add_tlv(struct sk_buff *skb, u16 type, void *data, u16 len)\n{\n\tstruct tlv_desc *tlv = (struct tlv_desc *)skb_tail_pointer(skb);\n\n\tif (tipc_skb_tailroom(skb) < TLV_SPACE(len))\n\t\treturn -EMSGSIZE;\n\n\tskb_put(skb, TLV_SPACE(len));\n\tmemset(tlv, 0, TLV_SPACE(len));\n\ttlv->tlv_type = htons(type);\n\ttlv->tlv_len = htons(TLV_LENGTH(len));\n\tif (len && data)\n\t\tmemcpy(TLV_DATA(tlv), data, len);\n\n\treturn 0;\n}\n\nstatic void tipc_tlv_init(struct sk_buff *skb, u16 type)\n{\n\tstruct tlv_desc *tlv = (struct tlv_desc *)skb->data;\n\n\tTLV_SET_LEN(tlv, 0);\n\tTLV_SET_TYPE(tlv, type);\n\tskb_put(skb, sizeof(struct tlv_desc));\n}\n\nstatic __printf(2, 3) int tipc_tlv_sprintf(struct sk_buff *skb,\n\t\t\t\t\t   const char *fmt, ...)\n{\n\tint n;\n\tu16 len;\n\tu32 rem;\n\tchar *buf;\n\tstruct tlv_desc *tlv;\n\tva_list args;\n\n\trem = tipc_skb_tailroom(skb);\n\n\ttlv = (struct tlv_desc *)skb->data;\n\tlen = TLV_GET_LEN(tlv);\n\tbuf = TLV_DATA(tlv) + len;\n\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, rem, fmt, args);\n\tva_end(args);\n\n\tTLV_SET_LEN(tlv, n + len);\n\tskb_put(skb, n);\n\n\treturn n;\n}\n\nstatic struct sk_buff *tipc_tlv_alloc(int size)\n{\n\tint hdr_len;\n\tstruct sk_buff *buf;\n\n\tsize = TLV_SPACE(size);\n\thdr_len = nlmsg_total_size(GENL_HDRLEN + TIPC_GENL_HDRLEN);\n\n\tbuf = alloc_skb(hdr_len + size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tskb_reserve(buf, hdr_len);\n\n\treturn buf;\n}\n\nstatic struct sk_buff *tipc_get_err_tlv(char *str)\n{\n\tint str_len = strlen(str) + 1;\n\tstruct sk_buff *buf;\n\n\tbuf = tipc_tlv_alloc(TLV_SPACE(str_len));\n\tif (buf)\n\t\ttipc_add_tlv(buf, TIPC_TLV_ERROR_STRING, str, str_len);\n\n\treturn buf;\n}\n\nstatic int __tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump *cmd,\n\t\t\t\t   struct tipc_nl_compat_msg *msg,\n\t\t\t\t   struct sk_buff *arg)\n{\n\tstruct genl_dumpit_info info;\n\tint len = 0;\n\tint err;\n\tstruct sk_buff *buf;\n\tstruct nlmsghdr *nlmsg;\n\tstruct netlink_callback cb;\n\tstruct nlattr **attrbuf;\n\n\tmemset(&cb, 0, sizeof(cb));\n\tcb.nlh = (struct nlmsghdr *)arg->data;\n\tcb.skb = arg;\n\tcb.data = &info;\n\n\tbuf = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->sk = msg->dst_sk;\n\tif (__tipc_dump_start(&cb, msg->net)) {\n\t\tkfree_skb(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\tattrbuf = kcalloc(tipc_genl_family.maxattr + 1,\n\t\t\t  sizeof(struct nlattr *), GFP_KERNEL);\n\tif (!attrbuf) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tinfo.info.attrs = attrbuf;\n\n\tif (nlmsg_len(cb.nlh) > 0) {\n\t\terr = nlmsg_parse_deprecated(cb.nlh, GENL_HDRLEN, attrbuf,\n\t\t\t\t\t     tipc_genl_family.maxattr,\n\t\t\t\t\t     tipc_genl_family.policy, NULL);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\tdo {\n\t\tint rem;\n\n\t\tlen = (*cmd->dumpit)(buf, &cb);\n\n\t\tnlmsg_for_each_msg(nlmsg, nlmsg_hdr(buf), len, rem) {\n\t\t\terr = nlmsg_parse_deprecated(nlmsg, GENL_HDRLEN,\n\t\t\t\t\t\t     attrbuf,\n\t\t\t\t\t\t     tipc_genl_family.maxattr,\n\t\t\t\t\t\t     tipc_genl_family.policy,\n\t\t\t\t\t\t     NULL);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\n\t\t\terr = (*cmd->format)(msg, attrbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\n\t\t\tif (tipc_skb_tailroom(msg->rep) <= 1) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\n\t\tskb_reset_tail_pointer(buf);\n\t\tbuf->len = 0;\n\n\t} while (len);\n\n\terr = 0;\n\nerr_out:\n\tkfree(attrbuf);\n\ttipc_dump_done(&cb);\n\tkfree_skb(buf);\n\n\tif (err == -EMSGSIZE) {\n\t\t \n\t\tif ((TIPC_SKB_MAX - msg->rep->len) <= 1) {\n\t\t\tchar *tail = skb_tail_pointer(msg->rep);\n\n\t\t\tif (*tail != '\\0')\n\t\t\t\tsprintf(tail - sizeof(REPLY_TRUNCATED) - 1,\n\t\t\t\t\tREPLY_TRUNCATED);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\treturn err;\n}\n\nstatic int tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump *cmd,\n\t\t\t\t struct tipc_nl_compat_msg *msg)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *arg;\n\tint err;\n\n\tif (msg->req_type && (!msg->req_size ||\n\t\t\t      !TLV_CHECK_TYPE(msg->req, msg->req_type)))\n\t\treturn -EINVAL;\n\n\tmsg->rep = tipc_tlv_alloc(msg->rep_size);\n\tif (!msg->rep)\n\t\treturn -ENOMEM;\n\n\tif (msg->rep_type)\n\t\ttipc_tlv_init(msg->rep, msg->rep_type);\n\n\tif (cmd->header) {\n\t\terr = (*cmd->header)(msg);\n\t\tif (err) {\n\t\t\tkfree_skb(msg->rep);\n\t\t\tmsg->rep = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\targ = nlmsg_new(0, GFP_KERNEL);\n\tif (!arg) {\n\t\tkfree_skb(msg->rep);\n\t\tmsg->rep = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tnlh = nlmsg_put(arg, 0, 0, tipc_genl_family.id, 0, NLM_F_MULTI);\n\tif (!nlh) {\n\t\tkfree_skb(arg);\n\t\tkfree_skb(msg->rep);\n\t\tmsg->rep = NULL;\n\t\treturn -EMSGSIZE;\n\t}\n\tnlmsg_end(arg, nlh);\n\n\terr = __tipc_nl_compat_dumpit(cmd, msg, arg);\n\tif (err) {\n\t\tkfree_skb(msg->rep);\n\t\tmsg->rep = NULL;\n\t}\n\tkfree_skb(arg);\n\n\treturn err;\n}\n\nstatic int __tipc_nl_compat_doit(struct tipc_nl_compat_cmd_doit *cmd,\n\t\t\t\t struct tipc_nl_compat_msg *msg)\n{\n\tint err;\n\tstruct sk_buff *doit_buf;\n\tstruct sk_buff *trans_buf;\n\tstruct nlattr **attrbuf;\n\tstruct genl_info info;\n\n\ttrans_buf = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!trans_buf)\n\t\treturn -ENOMEM;\n\n\tattrbuf = kmalloc_array(tipc_genl_family.maxattr + 1,\n\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\tGFP_KERNEL);\n\tif (!attrbuf) {\n\t\terr = -ENOMEM;\n\t\tgoto trans_out;\n\t}\n\n\tdoit_buf = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!doit_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto attrbuf_out;\n\t}\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.attrs = attrbuf;\n\n\trtnl_lock();\n\terr = (*cmd->transcode)(cmd, trans_buf, msg);\n\tif (err)\n\t\tgoto doit_out;\n\n\terr = nla_parse_deprecated(attrbuf, tipc_genl_family.maxattr,\n\t\t\t\t   (const struct nlattr *)trans_buf->data,\n\t\t\t\t   trans_buf->len, NULL, NULL);\n\tif (err)\n\t\tgoto doit_out;\n\n\tdoit_buf->sk = msg->dst_sk;\n\n\terr = (*cmd->doit)(doit_buf, &info);\ndoit_out:\n\trtnl_unlock();\n\n\tkfree_skb(doit_buf);\nattrbuf_out:\n\tkfree(attrbuf);\ntrans_out:\n\tkfree_skb(trans_buf);\n\n\treturn err;\n}\n\nstatic int tipc_nl_compat_doit(struct tipc_nl_compat_cmd_doit *cmd,\n\t\t\t       struct tipc_nl_compat_msg *msg)\n{\n\tint err;\n\n\tif (msg->req_type && (!msg->req_size ||\n\t\t\t      !TLV_CHECK_TYPE(msg->req, msg->req_type)))\n\t\treturn -EINVAL;\n\n\terr = __tipc_nl_compat_doit(cmd, msg);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmsg->rep = tipc_tlv_alloc(0);\n\tif (!msg->rep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_bearer_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t      struct nlattr **attrs)\n{\n\tstruct nlattr *bearer[TIPC_NLA_BEARER_MAX + 1];\n\tint err;\n\n\tif (!attrs[TIPC_NLA_BEARER])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(bearer, TIPC_NLA_BEARER_MAX,\n\t\t\t\t\t  attrs[TIPC_NLA_BEARER], NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_BEARER_NAME,\n\t\t\t    nla_data(bearer[TIPC_NLA_BEARER_NAME]),\n\t\t\t    nla_len(bearer[TIPC_NLA_BEARER_NAME]));\n}\n\nstatic int tipc_nl_compat_bearer_enable(struct tipc_nl_compat_cmd_doit *cmd,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tstruct tipc_nl_compat_msg *msg)\n{\n\tstruct nlattr *prop;\n\tstruct nlattr *bearer;\n\tstruct tipc_bearer_config *b;\n\tint len;\n\n\tb = (struct tipc_bearer_config *)TLV_DATA(msg->req);\n\n\tbearer = nla_nest_start_noflag(skb, TIPC_NLA_BEARER);\n\tif (!bearer)\n\t\treturn -EMSGSIZE;\n\n\tlen = TLV_GET_DATA_LEN(msg->req);\n\tlen -= offsetof(struct tipc_bearer_config, name);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\tlen = min_t(int, len, TIPC_MAX_BEARER_NAME);\n\tif (!string_is_terminated(b->name, len))\n\t\treturn -EINVAL;\n\n\tif (nla_put_string(skb, TIPC_NLA_BEARER_NAME, b->name))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, TIPC_NLA_BEARER_DOMAIN, ntohl(b->disc_domain)))\n\t\treturn -EMSGSIZE;\n\n\tif (ntohl(b->priority) <= TIPC_MAX_LINK_PRI) {\n\t\tprop = nla_nest_start_noflag(skb, TIPC_NLA_BEARER_PROP);\n\t\tif (!prop)\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_u32(skb, TIPC_NLA_PROP_PRIO, ntohl(b->priority)))\n\t\t\treturn -EMSGSIZE;\n\t\tnla_nest_end(skb, prop);\n\t}\n\tnla_nest_end(skb, bearer);\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_bearer_disable(struct tipc_nl_compat_cmd_doit *cmd,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t struct tipc_nl_compat_msg *msg)\n{\n\tchar *name;\n\tstruct nlattr *bearer;\n\tint len;\n\n\tname = (char *)TLV_DATA(msg->req);\n\n\tbearer = nla_nest_start_noflag(skb, TIPC_NLA_BEARER);\n\tif (!bearer)\n\t\treturn -EMSGSIZE;\n\n\tlen = TLV_GET_DATA_LEN(msg->req);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\tlen = min_t(int, len, TIPC_MAX_BEARER_NAME);\n\tif (!string_is_terminated(name, len))\n\t\treturn -EINVAL;\n\n\tif (nla_put_string(skb, TIPC_NLA_BEARER_NAME, name))\n\t\treturn -EMSGSIZE;\n\n\tnla_nest_end(skb, bearer);\n\n\treturn 0;\n}\n\nstatic inline u32 perc(u32 count, u32 total)\n{\n\treturn (count * 100 + (total / 2)) / total;\n}\n\nstatic void __fill_bc_link_stat(struct tipc_nl_compat_msg *msg,\n\t\t\t\tstruct nlattr *prop[], struct nlattr *stats[])\n{\n\ttipc_tlv_sprintf(msg->rep, \"  Window:%u packets\\n\",\n\t\t\t nla_get_u32(prop[TIPC_NLA_PROP_WIN]));\n\n\ttipc_tlv_sprintf(msg->rep,\n\t\t\t \"  RX packets:%u fragments:%u/%u bundles:%u/%u\\n\",\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_INFO]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_FRAGMENTS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_FRAGMENTED]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_BUNDLES]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_BUNDLED]));\n\n\ttipc_tlv_sprintf(msg->rep,\n\t\t\t \"  TX packets:%u fragments:%u/%u bundles:%u/%u\\n\",\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_INFO]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_FRAGMENTS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_FRAGMENTED]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_BUNDLES]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_BUNDLED]));\n\n\ttipc_tlv_sprintf(msg->rep, \"  RX naks:%u defs:%u dups:%u\\n\",\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_NACKS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_DEFERRED]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_DUPLICATES]));\n\n\ttipc_tlv_sprintf(msg->rep, \"  TX naks:%u acks:%u dups:%u\\n\",\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_NACKS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_ACKS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RETRANSMITTED]));\n\n\ttipc_tlv_sprintf(msg->rep,\n\t\t\t \"  Congestion link:%u  Send queue max:%u avg:%u\",\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_LINK_CONGS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_MAX_QUEUE]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_AVG_QUEUE]));\n}\n\nstatic int tipc_nl_compat_link_stat_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t\t struct nlattr **attrs)\n{\n\tchar *name;\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct nlattr *prop[TIPC_NLA_PROP_MAX + 1];\n\tstruct nlattr *stats[TIPC_NLA_STATS_MAX + 1];\n\tint err;\n\tint len;\n\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(link, TIPC_NLA_LINK_MAX,\n\t\t\t\t\t  attrs[TIPC_NLA_LINK], NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!link[TIPC_NLA_LINK_PROP])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(prop, TIPC_NLA_PROP_MAX,\n\t\t\t\t\t  link[TIPC_NLA_LINK_PROP], NULL,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!link[TIPC_NLA_LINK_STATS])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(stats, TIPC_NLA_STATS_MAX,\n\t\t\t\t\t  link[TIPC_NLA_LINK_STATS], NULL,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\treturn err;\n\n\tname = (char *)TLV_DATA(msg->req);\n\n\tlen = TLV_GET_DATA_LEN(msg->req);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\tlen = min_t(int, len, TIPC_MAX_LINK_NAME);\n\tif (!string_is_terminated(name, len))\n\t\treturn -EINVAL;\n\n\tif (strcmp(name, nla_data(link[TIPC_NLA_LINK_NAME])) != 0)\n\t\treturn 0;\n\n\ttipc_tlv_sprintf(msg->rep, \"\\nLink <%s>\\n\",\n\t\t\t (char *)nla_data(link[TIPC_NLA_LINK_NAME]));\n\n\tif (link[TIPC_NLA_LINK_BROADCAST]) {\n\t\t__fill_bc_link_stat(msg, prop, stats);\n\t\treturn 0;\n\t}\n\n\tif (link[TIPC_NLA_LINK_ACTIVE])\n\t\ttipc_tlv_sprintf(msg->rep, \"  ACTIVE\");\n\telse if (link[TIPC_NLA_LINK_UP])\n\t\ttipc_tlv_sprintf(msg->rep, \"  STANDBY\");\n\telse\n\t\ttipc_tlv_sprintf(msg->rep, \"  DEFUNCT\");\n\n\ttipc_tlv_sprintf(msg->rep, \"  MTU:%u  Priority:%u\",\n\t\t\t nla_get_u32(link[TIPC_NLA_LINK_MTU]),\n\t\t\t nla_get_u32(prop[TIPC_NLA_PROP_PRIO]));\n\n\ttipc_tlv_sprintf(msg->rep, \"  Tolerance:%u ms  Window:%u packets\\n\",\n\t\t\t nla_get_u32(prop[TIPC_NLA_PROP_TOL]),\n\t\t\t nla_get_u32(prop[TIPC_NLA_PROP_WIN]));\n\n\ttipc_tlv_sprintf(msg->rep,\n\t\t\t \"  RX packets:%u fragments:%u/%u bundles:%u/%u\\n\",\n\t\t\t nla_get_u32(link[TIPC_NLA_LINK_RX]) -\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_INFO]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_FRAGMENTS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_FRAGMENTED]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_BUNDLES]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_BUNDLED]));\n\n\ttipc_tlv_sprintf(msg->rep,\n\t\t\t \"  TX packets:%u fragments:%u/%u bundles:%u/%u\\n\",\n\t\t\t nla_get_u32(link[TIPC_NLA_LINK_TX]) -\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_INFO]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_FRAGMENTS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_FRAGMENTED]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_BUNDLES]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_BUNDLED]));\n\n\ttipc_tlv_sprintf(msg->rep,\n\t\t\t \"  TX profile sample:%u packets  average:%u octets\\n\",\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_CNT]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_TOT]) /\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT]));\n\n\ttipc_tlv_sprintf(msg->rep,\n\t\t\t \"  0-64:%u%% -256:%u%% -1024:%u%% -4096:%u%% \",\n\t\t\t perc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P0]),\n\t\t\t      nla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])),\n\t\t\t perc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P1]),\n\t\t\t      nla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])),\n\t\t\t perc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P2]),\n\t\t\t      nla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])),\n\t\t\t perc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P3]),\n\t\t\t      nla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])));\n\n\ttipc_tlv_sprintf(msg->rep, \"-16384:%u%% -32768:%u%% -66000:%u%%\\n\",\n\t\t\t perc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P4]),\n\t\t\t      nla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])),\n\t\t\t perc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P5]),\n\t\t\t      nla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])),\n\t\t\t perc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P6]),\n\t\t\t      nla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])));\n\n\ttipc_tlv_sprintf(msg->rep,\n\t\t\t \"  RX states:%u probes:%u naks:%u defs:%u dups:%u\\n\",\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_STATES]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_PROBES]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_NACKS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RX_DEFERRED]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_DUPLICATES]));\n\n\ttipc_tlv_sprintf(msg->rep,\n\t\t\t \"  TX states:%u probes:%u naks:%u acks:%u dups:%u\\n\",\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_STATES]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_PROBES]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_NACKS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_TX_ACKS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_RETRANSMITTED]));\n\n\ttipc_tlv_sprintf(msg->rep,\n\t\t\t \"  Congestion link:%u  Send queue max:%u avg:%u\",\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_LINK_CONGS]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_MAX_QUEUE]),\n\t\t\t nla_get_u32(stats[TIPC_NLA_STATS_AVG_QUEUE]));\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(link, TIPC_NLA_LINK_MAX,\n\t\t\t\t\t  attrs[TIPC_NLA_LINK], NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\tlink_info.dest = htonl(nla_get_flag(link[TIPC_NLA_LINK_DEST]));\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tnla_strscpy(link_info.str, link[TIPC_NLA_LINK_NAME],\n\t\t    TIPC_MAX_LINK_NAME);\n\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}\n\nstatic int __tipc_add_link_prop(struct sk_buff *skb,\n\t\t\t\tstruct tipc_nl_compat_msg *msg,\n\t\t\t\tstruct tipc_link_config *lc)\n{\n\tswitch (msg->cmd) {\n\tcase TIPC_CMD_SET_LINK_PRI:\n\t\treturn nla_put_u32(skb, TIPC_NLA_PROP_PRIO, ntohl(lc->value));\n\tcase TIPC_CMD_SET_LINK_TOL:\n\t\treturn nla_put_u32(skb, TIPC_NLA_PROP_TOL, ntohl(lc->value));\n\tcase TIPC_CMD_SET_LINK_WINDOW:\n\t\treturn nla_put_u32(skb, TIPC_NLA_PROP_WIN, ntohl(lc->value));\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tipc_nl_compat_media_set(struct sk_buff *skb,\n\t\t\t\t    struct tipc_nl_compat_msg *msg)\n{\n\tstruct nlattr *prop;\n\tstruct nlattr *media;\n\tstruct tipc_link_config *lc;\n\n\tlc = (struct tipc_link_config *)TLV_DATA(msg->req);\n\n\tmedia = nla_nest_start_noflag(skb, TIPC_NLA_MEDIA);\n\tif (!media)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, TIPC_NLA_MEDIA_NAME, lc->name))\n\t\treturn -EMSGSIZE;\n\n\tprop = nla_nest_start_noflag(skb, TIPC_NLA_MEDIA_PROP);\n\tif (!prop)\n\t\treturn -EMSGSIZE;\n\n\t__tipc_add_link_prop(skb, msg, lc);\n\tnla_nest_end(skb, prop);\n\tnla_nest_end(skb, media);\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_bearer_set(struct sk_buff *skb,\n\t\t\t\t     struct tipc_nl_compat_msg *msg)\n{\n\tstruct nlattr *prop;\n\tstruct nlattr *bearer;\n\tstruct tipc_link_config *lc;\n\n\tlc = (struct tipc_link_config *)TLV_DATA(msg->req);\n\n\tbearer = nla_nest_start_noflag(skb, TIPC_NLA_BEARER);\n\tif (!bearer)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))\n\t\treturn -EMSGSIZE;\n\n\tprop = nla_nest_start_noflag(skb, TIPC_NLA_BEARER_PROP);\n\tif (!prop)\n\t\treturn -EMSGSIZE;\n\n\t__tipc_add_link_prop(skb, msg, lc);\n\tnla_nest_end(skb, prop);\n\tnla_nest_end(skb, bearer);\n\n\treturn 0;\n}\n\nstatic int __tipc_nl_compat_link_set(struct sk_buff *skb,\n\t\t\t\t     struct tipc_nl_compat_msg *msg)\n{\n\tstruct nlattr *prop;\n\tstruct nlattr *link;\n\tstruct tipc_link_config *lc;\n\n\tlc = (struct tipc_link_config *)TLV_DATA(msg->req);\n\n\tlink = nla_nest_start_noflag(skb, TIPC_NLA_LINK);\n\tif (!link)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, TIPC_NLA_LINK_NAME, lc->name))\n\t\treturn -EMSGSIZE;\n\n\tprop = nla_nest_start_noflag(skb, TIPC_NLA_LINK_PROP);\n\tif (!prop)\n\t\treturn -EMSGSIZE;\n\n\t__tipc_add_link_prop(skb, msg, lc);\n\tnla_nest_end(skb, prop);\n\tnla_nest_end(skb, link);\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_link_set(struct tipc_nl_compat_cmd_doit *cmd,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct tipc_nl_compat_msg *msg)\n{\n\tstruct tipc_link_config *lc;\n\tstruct tipc_bearer *bearer;\n\tstruct tipc_media *media;\n\tint len;\n\n\tlc = (struct tipc_link_config *)TLV_DATA(msg->req);\n\n\tlen = TLV_GET_DATA_LEN(msg->req);\n\tlen -= offsetof(struct tipc_link_config, name);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\tlen = min_t(int, len, TIPC_MAX_LINK_NAME);\n\tif (!string_is_terminated(lc->name, len))\n\t\treturn -EINVAL;\n\n\tmedia = tipc_media_find(lc->name);\n\tif (media) {\n\t\tcmd->doit = &__tipc_nl_media_set;\n\t\treturn tipc_nl_compat_media_set(skb, msg);\n\t}\n\n\tbearer = tipc_bearer_find(msg->net, lc->name);\n\tif (bearer) {\n\t\tcmd->doit = &__tipc_nl_bearer_set;\n\t\treturn tipc_nl_compat_bearer_set(skb, msg);\n\t}\n\n\treturn __tipc_nl_compat_link_set(skb, msg);\n}\n\nstatic int tipc_nl_compat_link_reset_stats(struct tipc_nl_compat_cmd_doit *cmd,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   struct tipc_nl_compat_msg *msg)\n{\n\tchar *name;\n\tstruct nlattr *link;\n\tint len;\n\n\tname = (char *)TLV_DATA(msg->req);\n\n\tlink = nla_nest_start_noflag(skb, TIPC_NLA_LINK);\n\tif (!link)\n\t\treturn -EMSGSIZE;\n\n\tlen = TLV_GET_DATA_LEN(msg->req);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\tlen = min_t(int, len, TIPC_MAX_LINK_NAME);\n\tif (!string_is_terminated(name, len))\n\t\treturn -EINVAL;\n\n\tif (nla_put_string(skb, TIPC_NLA_LINK_NAME, name))\n\t\treturn -EMSGSIZE;\n\n\tnla_nest_end(skb, link);\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_name_table_dump_header(struct tipc_nl_compat_msg *msg)\n{\n\tint i;\n\tu32 depth;\n\tstruct tipc_name_table_query *ntq;\n\tstatic const char * const header[] = {\n\t\t\"Type       \",\n\t\t\"Lower      Upper      \",\n\t\t\"Port Identity              \",\n\t\t\"Publication Scope\"\n\t};\n\n\tntq = (struct tipc_name_table_query *)TLV_DATA(msg->req);\n\tif (TLV_GET_DATA_LEN(msg->req) < (int)sizeof(struct tipc_name_table_query))\n\t\treturn -EINVAL;\n\n\tdepth = ntohl(ntq->depth);\n\n\tif (depth > 4)\n\t\tdepth = 4;\n\tfor (i = 0; i < depth; i++)\n\t\ttipc_tlv_sprintf(msg->rep, header[i]);\n\ttipc_tlv_sprintf(msg->rep, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_name_table_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t\t  struct nlattr **attrs)\n{\n\tchar port_str[27];\n\tstruct tipc_name_table_query *ntq;\n\tstruct nlattr *nt[TIPC_NLA_NAME_TABLE_MAX + 1];\n\tstruct nlattr *publ[TIPC_NLA_PUBL_MAX + 1];\n\tu32 node, depth, type, lowbound, upbound;\n\tstatic const char * const scope_str[] = {\"\", \" zone\", \" cluster\",\n\t\t\t\t\t\t \" node\"};\n\tint err;\n\n\tif (!attrs[TIPC_NLA_NAME_TABLE])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(nt, TIPC_NLA_NAME_TABLE_MAX,\n\t\t\t\t\t  attrs[TIPC_NLA_NAME_TABLE], NULL,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!nt[TIPC_NLA_NAME_TABLE_PUBL])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(publ, TIPC_NLA_PUBL_MAX,\n\t\t\t\t\t  nt[TIPC_NLA_NAME_TABLE_PUBL], NULL,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\treturn err;\n\n\tntq = (struct tipc_name_table_query *)TLV_DATA(msg->req);\n\n\tdepth = ntohl(ntq->depth);\n\ttype = ntohl(ntq->type);\n\tlowbound = ntohl(ntq->lowbound);\n\tupbound = ntohl(ntq->upbound);\n\n\tif (!(depth & TIPC_NTQ_ALLTYPES) &&\n\t    (type != nla_get_u32(publ[TIPC_NLA_PUBL_TYPE])))\n\t\treturn 0;\n\tif (lowbound && (lowbound > nla_get_u32(publ[TIPC_NLA_PUBL_UPPER])))\n\t\treturn 0;\n\tif (upbound && (upbound < nla_get_u32(publ[TIPC_NLA_PUBL_LOWER])))\n\t\treturn 0;\n\n\ttipc_tlv_sprintf(msg->rep, \"%-10u \",\n\t\t\t nla_get_u32(publ[TIPC_NLA_PUBL_TYPE]));\n\n\tif (depth == 1)\n\t\tgoto out;\n\n\ttipc_tlv_sprintf(msg->rep, \"%-10u %-10u \",\n\t\t\t nla_get_u32(publ[TIPC_NLA_PUBL_LOWER]),\n\t\t\t nla_get_u32(publ[TIPC_NLA_PUBL_UPPER]));\n\n\tif (depth == 2)\n\t\tgoto out;\n\n\tnode = nla_get_u32(publ[TIPC_NLA_PUBL_NODE]);\n\tsprintf(port_str, \"<%u.%u.%u:%u>\", tipc_zone(node), tipc_cluster(node),\n\t\ttipc_node(node), nla_get_u32(publ[TIPC_NLA_PUBL_REF]));\n\ttipc_tlv_sprintf(msg->rep, \"%-26s \", port_str);\n\n\tif (depth == 3)\n\t\tgoto out;\n\n\ttipc_tlv_sprintf(msg->rep, \"%-10u %s\",\n\t\t\t nla_get_u32(publ[TIPC_NLA_PUBL_KEY]),\n\t\t\t scope_str[nla_get_u32(publ[TIPC_NLA_PUBL_SCOPE])]);\nout:\n\ttipc_tlv_sprintf(msg->rep, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int __tipc_nl_compat_publ_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t      struct nlattr **attrs)\n{\n\tu32 type, lower, upper;\n\tstruct nlattr *publ[TIPC_NLA_PUBL_MAX + 1];\n\tint err;\n\n\tif (!attrs[TIPC_NLA_PUBL])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(publ, TIPC_NLA_PUBL_MAX,\n\t\t\t\t\t  attrs[TIPC_NLA_PUBL], NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\ttype = nla_get_u32(publ[TIPC_NLA_PUBL_TYPE]);\n\tlower = nla_get_u32(publ[TIPC_NLA_PUBL_LOWER]);\n\tupper = nla_get_u32(publ[TIPC_NLA_PUBL_UPPER]);\n\n\tif (lower == upper)\n\t\ttipc_tlv_sprintf(msg->rep, \" {%u,%u}\", type, lower);\n\telse\n\t\ttipc_tlv_sprintf(msg->rep, \" {%u,%u,%u}\", type, lower, upper);\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_publ_dump(struct tipc_nl_compat_msg *msg, u32 sock)\n{\n\tint err;\n\tvoid *hdr;\n\tstruct nlattr *nest;\n\tstruct sk_buff *args;\n\tstruct tipc_nl_compat_cmd_dump dump;\n\n\targs = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(args, 0, 0, &tipc_genl_family, NLM_F_MULTI,\n\t\t\t  TIPC_NL_PUBL_GET);\n\tif (!hdr) {\n\t\tkfree_skb(args);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnest = nla_nest_start_noflag(args, TIPC_NLA_SOCK);\n\tif (!nest) {\n\t\tkfree_skb(args);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (nla_put_u32(args, TIPC_NLA_SOCK_REF, sock)) {\n\t\tkfree_skb(args);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnla_nest_end(args, nest);\n\tgenlmsg_end(args, hdr);\n\n\tdump.dumpit = tipc_nl_publ_dump;\n\tdump.format = __tipc_nl_compat_publ_dump;\n\n\terr = __tipc_nl_compat_dumpit(&dump, msg, args);\n\n\tkfree_skb(args);\n\n\treturn err;\n}\n\nstatic int tipc_nl_compat_sk_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t  struct nlattr **attrs)\n{\n\tint err;\n\tu32 sock_ref;\n\tstruct nlattr *sock[TIPC_NLA_SOCK_MAX + 1];\n\n\tif (!attrs[TIPC_NLA_SOCK])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(sock, TIPC_NLA_SOCK_MAX,\n\t\t\t\t\t  attrs[TIPC_NLA_SOCK], NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\tsock_ref = nla_get_u32(sock[TIPC_NLA_SOCK_REF]);\n\ttipc_tlv_sprintf(msg->rep, \"%u:\", sock_ref);\n\n\tif (sock[TIPC_NLA_SOCK_CON]) {\n\t\tu32 node;\n\t\tstruct nlattr *con[TIPC_NLA_CON_MAX + 1];\n\n\t\terr = nla_parse_nested_deprecated(con, TIPC_NLA_CON_MAX,\n\t\t\t\t\t\t  sock[TIPC_NLA_SOCK_CON],\n\t\t\t\t\t\t  NULL, NULL);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnode = nla_get_u32(con[TIPC_NLA_CON_NODE]);\n\t\ttipc_tlv_sprintf(msg->rep, \"  connected to <%u.%u.%u:%u>\",\n\t\t\t\t tipc_zone(node),\n\t\t\t\t tipc_cluster(node),\n\t\t\t\t tipc_node(node),\n\t\t\t\t nla_get_u32(con[TIPC_NLA_CON_SOCK]));\n\n\t\tif (con[TIPC_NLA_CON_FLAG])\n\t\t\ttipc_tlv_sprintf(msg->rep, \" via {%u,%u}\\n\",\n\t\t\t\t\t nla_get_u32(con[TIPC_NLA_CON_TYPE]),\n\t\t\t\t\t nla_get_u32(con[TIPC_NLA_CON_INST]));\n\t\telse\n\t\t\ttipc_tlv_sprintf(msg->rep, \"\\n\");\n\t} else if (sock[TIPC_NLA_SOCK_HAS_PUBL]) {\n\t\ttipc_tlv_sprintf(msg->rep, \" bound to\");\n\n\t\terr = tipc_nl_compat_publ_dump(msg, sock_ref);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\ttipc_tlv_sprintf(msg->rep, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_media_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t     struct nlattr **attrs)\n{\n\tstruct nlattr *media[TIPC_NLA_MEDIA_MAX + 1];\n\tint err;\n\n\tif (!attrs[TIPC_NLA_MEDIA])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(media, TIPC_NLA_MEDIA_MAX,\n\t\t\t\t\t  attrs[TIPC_NLA_MEDIA], NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_MEDIA_NAME,\n\t\t\t    nla_data(media[TIPC_NLA_MEDIA_NAME]),\n\t\t\t    nla_len(media[TIPC_NLA_MEDIA_NAME]));\n}\n\nstatic int tipc_nl_compat_node_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct tipc_node_info node_info;\n\tstruct nlattr *node[TIPC_NLA_NODE_MAX + 1];\n\tint err;\n\n\tif (!attrs[TIPC_NLA_NODE])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(node, TIPC_NLA_NODE_MAX,\n\t\t\t\t\t  attrs[TIPC_NLA_NODE], NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\tnode_info.addr = htonl(nla_get_u32(node[TIPC_NLA_NODE_ADDR]));\n\tnode_info.up = htonl(nla_get_flag(node[TIPC_NLA_NODE_UP]));\n\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_NODE_INFO, &node_info,\n\t\t\t    sizeof(node_info));\n}\n\nstatic int tipc_nl_compat_net_set(struct tipc_nl_compat_cmd_doit *cmd,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct tipc_nl_compat_msg *msg)\n{\n\tu32 val;\n\tstruct nlattr *net;\n\n\tval = ntohl(*(__be32 *)TLV_DATA(msg->req));\n\n\tnet = nla_nest_start_noflag(skb, TIPC_NLA_NET);\n\tif (!net)\n\t\treturn -EMSGSIZE;\n\n\tif (msg->cmd == TIPC_CMD_SET_NODE_ADDR) {\n\t\tif (nla_put_u32(skb, TIPC_NLA_NET_ADDR, val))\n\t\t\treturn -EMSGSIZE;\n\t} else if (msg->cmd == TIPC_CMD_SET_NETID) {\n\t\tif (nla_put_u32(skb, TIPC_NLA_NET_ID, val))\n\t\t\treturn -EMSGSIZE;\n\t}\n\tnla_nest_end(skb, net);\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_net_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t   struct nlattr **attrs)\n{\n\t__be32 id;\n\tstruct nlattr *net[TIPC_NLA_NET_MAX + 1];\n\tint err;\n\n\tif (!attrs[TIPC_NLA_NET])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(net, TIPC_NLA_NET_MAX,\n\t\t\t\t\t  attrs[TIPC_NLA_NET], NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\tid = htonl(nla_get_u32(net[TIPC_NLA_NET_ID]));\n\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_UNSIGNED, &id, sizeof(id));\n}\n\nstatic int tipc_cmd_show_stats_compat(struct tipc_nl_compat_msg *msg)\n{\n\tmsg->rep = tipc_tlv_alloc(ULTRA_STRING_MAX_LEN);\n\tif (!msg->rep)\n\t\treturn -ENOMEM;\n\n\ttipc_tlv_init(msg->rep, TIPC_TLV_ULTRA_STRING);\n\ttipc_tlv_sprintf(msg->rep, \"TIPC version \" TIPC_MOD_VER \"\\n\");\n\n\treturn 0;\n}\n\nstatic int tipc_nl_compat_handle(struct tipc_nl_compat_msg *msg)\n{\n\tstruct tipc_nl_compat_cmd_dump dump;\n\tstruct tipc_nl_compat_cmd_doit doit;\n\n\tmemset(&dump, 0, sizeof(dump));\n\tmemset(&doit, 0, sizeof(doit));\n\n\tswitch (msg->cmd) {\n\tcase TIPC_CMD_NOOP:\n\t\tmsg->rep = tipc_tlv_alloc(0);\n\t\tif (!msg->rep)\n\t\t\treturn -ENOMEM;\n\t\treturn 0;\n\tcase TIPC_CMD_GET_BEARER_NAMES:\n\t\tmsg->rep_size = MAX_BEARERS * TLV_SPACE(TIPC_MAX_BEARER_NAME);\n\t\tdump.dumpit = tipc_nl_bearer_dump;\n\t\tdump.format = tipc_nl_compat_bearer_dump;\n\t\treturn tipc_nl_compat_dumpit(&dump, msg);\n\tcase TIPC_CMD_ENABLE_BEARER:\n\t\tmsg->req_type = TIPC_TLV_BEARER_CONFIG;\n\t\tdoit.doit = __tipc_nl_bearer_enable;\n\t\tdoit.transcode = tipc_nl_compat_bearer_enable;\n\t\treturn tipc_nl_compat_doit(&doit, msg);\n\tcase TIPC_CMD_DISABLE_BEARER:\n\t\tmsg->req_type = TIPC_TLV_BEARER_NAME;\n\t\tdoit.doit = __tipc_nl_bearer_disable;\n\t\tdoit.transcode = tipc_nl_compat_bearer_disable;\n\t\treturn tipc_nl_compat_doit(&doit, msg);\n\tcase TIPC_CMD_SHOW_LINK_STATS:\n\t\tmsg->req_type = TIPC_TLV_LINK_NAME;\n\t\tmsg->rep_size = ULTRA_STRING_MAX_LEN;\n\t\tmsg->rep_type = TIPC_TLV_ULTRA_STRING;\n\t\tdump.dumpit = tipc_nl_node_dump_link;\n\t\tdump.format = tipc_nl_compat_link_stat_dump;\n\t\treturn tipc_nl_compat_dumpit(&dump, msg);\n\tcase TIPC_CMD_GET_LINKS:\n\t\tmsg->req_type = TIPC_TLV_NET_ADDR;\n\t\tmsg->rep_size = ULTRA_STRING_MAX_LEN;\n\t\tdump.dumpit = tipc_nl_node_dump_link;\n\t\tdump.format = tipc_nl_compat_link_dump;\n\t\treturn tipc_nl_compat_dumpit(&dump, msg);\n\tcase TIPC_CMD_SET_LINK_TOL:\n\tcase TIPC_CMD_SET_LINK_PRI:\n\tcase TIPC_CMD_SET_LINK_WINDOW:\n\t\tmsg->req_type =  TIPC_TLV_LINK_CONFIG;\n\t\tdoit.doit = tipc_nl_node_set_link;\n\t\tdoit.transcode = tipc_nl_compat_link_set;\n\t\treturn tipc_nl_compat_doit(&doit, msg);\n\tcase TIPC_CMD_RESET_LINK_STATS:\n\t\tmsg->req_type = TIPC_TLV_LINK_NAME;\n\t\tdoit.doit = tipc_nl_node_reset_link_stats;\n\t\tdoit.transcode = tipc_nl_compat_link_reset_stats;\n\t\treturn tipc_nl_compat_doit(&doit, msg);\n\tcase TIPC_CMD_SHOW_NAME_TABLE:\n\t\tmsg->req_type = TIPC_TLV_NAME_TBL_QUERY;\n\t\tmsg->rep_size = ULTRA_STRING_MAX_LEN;\n\t\tmsg->rep_type = TIPC_TLV_ULTRA_STRING;\n\t\tdump.header = tipc_nl_compat_name_table_dump_header;\n\t\tdump.dumpit = tipc_nl_name_table_dump;\n\t\tdump.format = tipc_nl_compat_name_table_dump;\n\t\treturn tipc_nl_compat_dumpit(&dump, msg);\n\tcase TIPC_CMD_SHOW_PORTS:\n\t\tmsg->rep_size = ULTRA_STRING_MAX_LEN;\n\t\tmsg->rep_type = TIPC_TLV_ULTRA_STRING;\n\t\tdump.dumpit = tipc_nl_sk_dump;\n\t\tdump.format = tipc_nl_compat_sk_dump;\n\t\treturn tipc_nl_compat_dumpit(&dump, msg);\n\tcase TIPC_CMD_GET_MEDIA_NAMES:\n\t\tmsg->rep_size = MAX_MEDIA * TLV_SPACE(TIPC_MAX_MEDIA_NAME);\n\t\tdump.dumpit = tipc_nl_media_dump;\n\t\tdump.format = tipc_nl_compat_media_dump;\n\t\treturn tipc_nl_compat_dumpit(&dump, msg);\n\tcase TIPC_CMD_GET_NODES:\n\t\tmsg->rep_size = ULTRA_STRING_MAX_LEN;\n\t\tdump.dumpit = tipc_nl_node_dump;\n\t\tdump.format = tipc_nl_compat_node_dump;\n\t\treturn tipc_nl_compat_dumpit(&dump, msg);\n\tcase TIPC_CMD_SET_NODE_ADDR:\n\t\tmsg->req_type = TIPC_TLV_NET_ADDR;\n\t\tdoit.doit = __tipc_nl_net_set;\n\t\tdoit.transcode = tipc_nl_compat_net_set;\n\t\treturn tipc_nl_compat_doit(&doit, msg);\n\tcase TIPC_CMD_SET_NETID:\n\t\tmsg->req_type = TIPC_TLV_UNSIGNED;\n\t\tdoit.doit = __tipc_nl_net_set;\n\t\tdoit.transcode = tipc_nl_compat_net_set;\n\t\treturn tipc_nl_compat_doit(&doit, msg);\n\tcase TIPC_CMD_GET_NETID:\n\t\tmsg->rep_size = sizeof(u32);\n\t\tdump.dumpit = tipc_nl_net_dump;\n\t\tdump.format = tipc_nl_compat_net_dump;\n\t\treturn tipc_nl_compat_dumpit(&dump, msg);\n\tcase TIPC_CMD_SHOW_STATS:\n\t\treturn tipc_cmd_show_stats_compat(msg);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int tipc_nl_compat_recv(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\tint len;\n\tstruct tipc_nl_compat_msg msg;\n\tstruct nlmsghdr *req_nlh;\n\tstruct nlmsghdr *rep_nlh;\n\tstruct tipc_genlmsghdr *req_userhdr = genl_info_userhdr(info);\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\treq_nlh = (struct nlmsghdr *)skb->data;\n\tmsg.req = nlmsg_data(req_nlh) + GENL_HDRLEN + TIPC_GENL_HDRLEN;\n\tmsg.cmd = req_userhdr->cmd;\n\tmsg.net = genl_info_net(info);\n\tmsg.dst_sk = skb->sk;\n\n\tif ((msg.cmd & 0xC000) && (!netlink_net_capable(skb, CAP_NET_ADMIN))) {\n\t\tmsg.rep = tipc_get_err_tlv(TIPC_CFG_NOT_NET_ADMIN);\n\t\terr = -EACCES;\n\t\tgoto send;\n\t}\n\n\tmsg.req_size = nlmsg_attrlen(req_nlh, GENL_HDRLEN + TIPC_GENL_HDRLEN);\n\tif (msg.req_size && !TLV_OK(msg.req, msg.req_size)) {\n\t\tmsg.rep = tipc_get_err_tlv(TIPC_CFG_NOT_SUPPORTED);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto send;\n\t}\n\n\terr = tipc_nl_compat_handle(&msg);\n\tif ((err == -EOPNOTSUPP) || (err == -EPERM))\n\t\tmsg.rep = tipc_get_err_tlv(TIPC_CFG_NOT_SUPPORTED);\n\telse if (err == -EINVAL)\n\t\tmsg.rep = tipc_get_err_tlv(TIPC_CFG_TLV_ERROR);\nsend:\n\tif (!msg.rep)\n\t\treturn err;\n\n\tlen = nlmsg_total_size(GENL_HDRLEN + TIPC_GENL_HDRLEN);\n\tskb_push(msg.rep, len);\n\trep_nlh = nlmsg_hdr(msg.rep);\n\tmemcpy(rep_nlh, info->nlhdr, len);\n\trep_nlh->nlmsg_len = msg.rep->len;\n\tgenlmsg_unicast(msg.net, msg.rep, NETLINK_CB(skb).portid);\n\n\treturn err;\n}\n\nstatic const struct genl_small_ops tipc_genl_compat_ops[] = {\n\t{\n\t\t.cmd\t\t= TIPC_GENL_CMD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t\t= tipc_nl_compat_recv,\n\t},\n};\n\nstatic struct genl_family tipc_genl_compat_family __ro_after_init = {\n\t.name\t\t= TIPC_GENL_NAME,\n\t.version\t= TIPC_GENL_VERSION,\n\t.hdrsize\t= TIPC_GENL_HDRLEN,\n\t.maxattr\t= 0,\n\t.netnsok\t= true,\n\t.module\t\t= THIS_MODULE,\n\t.small_ops\t= tipc_genl_compat_ops,\n\t.n_small_ops\t= ARRAY_SIZE(tipc_genl_compat_ops),\n\t.resv_start_op\t= TIPC_GENL_CMD + 1,\n};\n\nint __init tipc_netlink_compat_start(void)\n{\n\tint res;\n\n\tres = genl_register_family(&tipc_genl_compat_family);\n\tif (res) {\n\t\tpr_err(\"Failed to register legacy compat interface\\n\");\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nvoid tipc_netlink_compat_stop(void)\n{\n\tgenl_unregister_family(&tipc_genl_compat_family);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}