{
  "module_name": "name_distr.c",
  "hash_id": "d3e534b5ad31c9da8ac33b891218e18b8101a5cc791f432d10c52b476c8c4cd5",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/name_distr.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"link.h\"\n#include \"name_distr.h\"\n\nint sysctl_tipc_named_timeout __read_mostly = 2000;\n\n \nstatic void publ_to_item(struct distr_item *i, struct publication *p)\n{\n\ti->type = htonl(p->sr.type);\n\ti->lower = htonl(p->sr.lower);\n\ti->upper = htonl(p->sr.upper);\n\ti->port = htonl(p->sk.ref);\n\ti->key = htonl(p->key);\n}\n\n \nstatic struct sk_buff *named_prepare_buf(struct net *net, u32 type, u32 size,\n\t\t\t\t\t u32 dest)\n{\n\tstruct sk_buff *buf = tipc_buf_acquire(INT_H_SIZE + size, GFP_ATOMIC);\n\tu32 self = tipc_own_addr(net);\n\tstruct tipc_msg *msg;\n\n\tif (buf != NULL) {\n\t\tmsg = buf_msg(buf);\n\t\ttipc_msg_init(self, msg, NAME_DISTRIBUTOR,\n\t\t\t      type, INT_H_SIZE, dest);\n\t\tmsg_set_size(msg, INT_H_SIZE + size);\n\t}\n\treturn buf;\n}\n\n \nstruct sk_buff *tipc_named_publish(struct net *net, struct publication *p)\n{\n\tstruct name_table *nt = tipc_name_table(net);\n\tstruct distr_item *item;\n\tstruct sk_buff *skb;\n\n\tif (p->scope == TIPC_NODE_SCOPE) {\n\t\tlist_add_tail_rcu(&p->binding_node, &nt->node_scope);\n\t\treturn NULL;\n\t}\n\twrite_lock_bh(&nt->cluster_scope_lock);\n\tlist_add_tail(&p->binding_node, &nt->cluster_scope);\n\twrite_unlock_bh(&nt->cluster_scope_lock);\n\tskb = named_prepare_buf(net, PUBLICATION, ITEM_SIZE, 0);\n\tif (!skb) {\n\t\tpr_warn(\"Publication distribution failure\\n\");\n\t\treturn NULL;\n\t}\n\tmsg_set_named_seqno(buf_msg(skb), nt->snd_nxt++);\n\tmsg_set_non_legacy(buf_msg(skb));\n\titem = (struct distr_item *)msg_data(buf_msg(skb));\n\tpubl_to_item(item, p);\n\treturn skb;\n}\n\n \nstruct sk_buff *tipc_named_withdraw(struct net *net, struct publication *p)\n{\n\tstruct name_table *nt = tipc_name_table(net);\n\tstruct distr_item *item;\n\tstruct sk_buff *skb;\n\n\twrite_lock_bh(&nt->cluster_scope_lock);\n\tlist_del(&p->binding_node);\n\twrite_unlock_bh(&nt->cluster_scope_lock);\n\tif (p->scope == TIPC_NODE_SCOPE)\n\t\treturn NULL;\n\n\tskb = named_prepare_buf(net, WITHDRAWAL, ITEM_SIZE, 0);\n\tif (!skb) {\n\t\tpr_warn(\"Withdrawal distribution failure\\n\");\n\t\treturn NULL;\n\t}\n\tmsg_set_named_seqno(buf_msg(skb), nt->snd_nxt++);\n\tmsg_set_non_legacy(buf_msg(skb));\n\titem = (struct distr_item *)msg_data(buf_msg(skb));\n\tpubl_to_item(item, p);\n\treturn skb;\n}\n\n \nstatic void named_distribute(struct net *net, struct sk_buff_head *list,\n\t\t\t     u32 dnode, struct list_head *pls, u16 seqno)\n{\n\tstruct publication *publ;\n\tstruct sk_buff *skb = NULL;\n\tstruct distr_item *item = NULL;\n\tu32 msg_dsz = ((tipc_node_get_mtu(net, dnode, 0, false) - INT_H_SIZE) /\n\t\t\tITEM_SIZE) * ITEM_SIZE;\n\tu32 msg_rem = msg_dsz;\n\tstruct tipc_msg *hdr;\n\n\tlist_for_each_entry(publ, pls, binding_node) {\n\t\t \n\t\tif (!skb) {\n\t\t\tskb = named_prepare_buf(net, PUBLICATION, msg_rem,\n\t\t\t\t\t\tdnode);\n\t\t\tif (!skb) {\n\t\t\t\tpr_warn(\"Bulk publication failure\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\thdr = buf_msg(skb);\n\t\t\tmsg_set_bc_ack_invalid(hdr, true);\n\t\t\tmsg_set_bulk(hdr);\n\t\t\tmsg_set_non_legacy(hdr);\n\t\t\titem = (struct distr_item *)msg_data(hdr);\n\t\t}\n\n\t\t \n\t\tpubl_to_item(item, publ);\n\t\titem++;\n\t\tmsg_rem -= ITEM_SIZE;\n\n\t\t \n\t\tif (!msg_rem) {\n\t\t\t__skb_queue_tail(list, skb);\n\t\t\tskb = NULL;\n\t\t\tmsg_rem = msg_dsz;\n\t\t}\n\t}\n\tif (skb) {\n\t\thdr = buf_msg(skb);\n\t\tmsg_set_size(hdr, INT_H_SIZE + (msg_dsz - msg_rem));\n\t\tskb_trim(skb, INT_H_SIZE + (msg_dsz - msg_rem));\n\t\t__skb_queue_tail(list, skb);\n\t}\n\thdr = buf_msg(skb_peek_tail(list));\n\tmsg_set_last_bulk(hdr);\n\tmsg_set_named_seqno(hdr, seqno);\n}\n\n \nvoid tipc_named_node_up(struct net *net, u32 dnode, u16 capabilities)\n{\n\tstruct name_table *nt = tipc_name_table(net);\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct sk_buff_head head;\n\tu16 seqno;\n\n\t__skb_queue_head_init(&head);\n\tspin_lock_bh(&tn->nametbl_lock);\n\tif (!(capabilities & TIPC_NAMED_BCAST))\n\t\tnt->rc_dests++;\n\tseqno = nt->snd_nxt;\n\tspin_unlock_bh(&tn->nametbl_lock);\n\n\tread_lock_bh(&nt->cluster_scope_lock);\n\tnamed_distribute(net, &head, dnode, &nt->cluster_scope, seqno);\n\ttipc_node_xmit(net, &head, dnode, 0);\n\tread_unlock_bh(&nt->cluster_scope_lock);\n}\n\n \nstatic void tipc_publ_purge(struct net *net, struct publication *p, u32 addr)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct publication *_p;\n\tstruct tipc_uaddr ua;\n\n\ttipc_uaddr(&ua, TIPC_SERVICE_RANGE, p->scope, p->sr.type,\n\t\t   p->sr.lower, p->sr.upper);\n\tspin_lock_bh(&tn->nametbl_lock);\n\t_p = tipc_nametbl_remove_publ(net, &ua, &p->sk, p->key);\n\tif (_p)\n\t\ttipc_node_unsubscribe(net, &_p->binding_node, addr);\n\tspin_unlock_bh(&tn->nametbl_lock);\n\tif (_p)\n\t\tkfree_rcu(_p, rcu);\n}\n\nvoid tipc_publ_notify(struct net *net, struct list_head *nsub_list,\n\t\t      u32 addr, u16 capabilities)\n{\n\tstruct name_table *nt = tipc_name_table(net);\n\tstruct tipc_net *tn = tipc_net(net);\n\n\tstruct publication *publ, *tmp;\n\n\tlist_for_each_entry_safe(publ, tmp, nsub_list, binding_node)\n\t\ttipc_publ_purge(net, publ, addr);\n\tspin_lock_bh(&tn->nametbl_lock);\n\tif (!(capabilities & TIPC_NAMED_BCAST))\n\t\tnt->rc_dests--;\n\tspin_unlock_bh(&tn->nametbl_lock);\n}\n\n \nstatic bool tipc_update_nametbl(struct net *net, struct distr_item *i,\n\t\t\t\tu32 node, u32 dtype)\n{\n\tstruct publication *p = NULL;\n\tstruct tipc_socket_addr sk;\n\tstruct tipc_uaddr ua;\n\tu32 key = ntohl(i->key);\n\n\ttipc_uaddr(&ua, TIPC_SERVICE_RANGE, TIPC_CLUSTER_SCOPE,\n\t\t   ntohl(i->type), ntohl(i->lower), ntohl(i->upper));\n\tsk.ref = ntohl(i->port);\n\tsk.node = node;\n\n\tif (dtype == PUBLICATION) {\n\t\tp = tipc_nametbl_insert_publ(net, &ua, &sk, key);\n\t\tif (p) {\n\t\t\ttipc_node_subscribe(net, &p->binding_node, node);\n\t\t\treturn true;\n\t\t}\n\t} else if (dtype == WITHDRAWAL) {\n\t\tp = tipc_nametbl_remove_publ(net, &ua, &sk, key);\n\t\tif (p) {\n\t\t\ttipc_node_unsubscribe(net, &p->binding_node, node);\n\t\t\tkfree_rcu(p, rcu);\n\t\t\treturn true;\n\t\t}\n\t\tpr_warn_ratelimited(\"Failed to remove binding %u,%u from %u\\n\",\n\t\t\t\t    ua.sr.type, ua.sr.lower, node);\n\t} else {\n\t\tpr_warn_ratelimited(\"Unknown name table message received\\n\");\n\t}\n\treturn false;\n}\n\nstatic struct sk_buff *tipc_named_dequeue(struct sk_buff_head *namedq,\n\t\t\t\t\t  u16 *rcv_nxt, bool *open)\n{\n\tstruct sk_buff *skb, *tmp;\n\tstruct tipc_msg *hdr;\n\tu16 seqno;\n\n\tspin_lock_bh(&namedq->lock);\n\tskb_queue_walk_safe(namedq, skb, tmp) {\n\t\tif (unlikely(skb_linearize(skb))) {\n\t\t\t__skb_unlink(skb, namedq);\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\thdr = buf_msg(skb);\n\t\tseqno = msg_named_seqno(hdr);\n\t\tif (msg_is_last_bulk(hdr)) {\n\t\t\t*rcv_nxt = seqno;\n\t\t\t*open = true;\n\t\t}\n\n\t\tif (msg_is_bulk(hdr) || msg_is_legacy(hdr)) {\n\t\t\t__skb_unlink(skb, namedq);\n\t\t\tspin_unlock_bh(&namedq->lock);\n\t\t\treturn skb;\n\t\t}\n\n\t\tif (*open && (*rcv_nxt == seqno)) {\n\t\t\t(*rcv_nxt)++;\n\t\t\t__skb_unlink(skb, namedq);\n\t\t\tspin_unlock_bh(&namedq->lock);\n\t\t\treturn skb;\n\t\t}\n\n\t\tif (less(seqno, *rcv_nxt)) {\n\t\t\t__skb_unlink(skb, namedq);\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tspin_unlock_bh(&namedq->lock);\n\treturn NULL;\n}\n\n \nvoid tipc_named_rcv(struct net *net, struct sk_buff_head *namedq,\n\t\t    u16 *rcv_nxt, bool *open)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct distr_item *item;\n\tstruct tipc_msg *hdr;\n\tstruct sk_buff *skb;\n\tu32 count, node;\n\n\tspin_lock_bh(&tn->nametbl_lock);\n\twhile ((skb = tipc_named_dequeue(namedq, rcv_nxt, open))) {\n\t\thdr = buf_msg(skb);\n\t\tnode = msg_orignode(hdr);\n\t\titem = (struct distr_item *)msg_data(hdr);\n\t\tcount = msg_data_sz(hdr) / ITEM_SIZE;\n\t\twhile (count--) {\n\t\t\ttipc_update_nametbl(net, item, node, msg_type(hdr));\n\t\t\titem++;\n\t\t}\n\t\tkfree_skb(skb);\n\t}\n\tspin_unlock_bh(&tn->nametbl_lock);\n}\n\n \nvoid tipc_named_reinit(struct net *net)\n{\n\tstruct name_table *nt = tipc_name_table(net);\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct publication *p;\n\tu32 self = tipc_own_addr(net);\n\n\tspin_lock_bh(&tn->nametbl_lock);\n\n\tlist_for_each_entry_rcu(p, &nt->node_scope, binding_node)\n\t\tp->sk.node = self;\n\tlist_for_each_entry_rcu(p, &nt->cluster_scope, binding_node)\n\t\tp->sk.node = self;\n\tnt->rc_dests = 0;\n\tspin_unlock_bh(&tn->nametbl_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}