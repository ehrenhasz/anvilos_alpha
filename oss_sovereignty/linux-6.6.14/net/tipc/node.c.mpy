{
  "module_name": "node.c",
  "hash_id": "8360131d279f0abb9bb84f44557c56a136ed26beb65e0c7cbae1ca6e278f63a4",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/node.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"link.h\"\n#include \"node.h\"\n#include \"name_distr.h\"\n#include \"socket.h\"\n#include \"bcast.h\"\n#include \"monitor.h\"\n#include \"discover.h\"\n#include \"netlink.h\"\n#include \"trace.h\"\n#include \"crypto.h\"\n\n#define INVALID_NODE_SIG\t0x10000\n#define NODE_CLEANUP_AFTER\t300000\n\n \nenum {\n\tTIPC_NOTIFY_NODE_DOWN\t\t= (1 << 3),\n\tTIPC_NOTIFY_NODE_UP\t\t= (1 << 4),\n\tTIPC_NOTIFY_LINK_UP\t\t= (1 << 6),\n\tTIPC_NOTIFY_LINK_DOWN\t\t= (1 << 7)\n};\n\nstruct tipc_link_entry {\n\tstruct tipc_link *link;\n\tspinlock_t lock;  \n\tu32 mtu;\n\tstruct sk_buff_head inputq;\n\tstruct tipc_media_addr maddr;\n};\n\nstruct tipc_bclink_entry {\n\tstruct tipc_link *link;\n\tstruct sk_buff_head inputq1;\n\tstruct sk_buff_head arrvq;\n\tstruct sk_buff_head inputq2;\n\tstruct sk_buff_head namedq;\n\tu16 named_rcv_nxt;\n\tbool named_open;\n};\n\n \nstruct tipc_node {\n\tu32 addr;\n\tstruct kref kref;\n\trwlock_t lock;\n\tstruct net *net;\n\tstruct hlist_node hash;\n\tint active_links[2];\n\tstruct tipc_link_entry links[MAX_BEARERS];\n\tstruct tipc_bclink_entry bc_entry;\n\tint action_flags;\n\tstruct list_head list;\n\tint state;\n\tbool preliminary;\n\tbool failover_sent;\n\tu16 sync_point;\n\tint link_cnt;\n\tu16 working_links;\n\tu16 capabilities;\n\tu32 signature;\n\tu32 link_id;\n\tu8 peer_id[16];\n\tchar peer_id_string[NODE_ID_STR_LEN];\n\tstruct list_head publ_list;\n\tstruct list_head conn_sks;\n\tunsigned long keepalive_intv;\n\tstruct timer_list timer;\n\tstruct rcu_head rcu;\n\tunsigned long delete_at;\n\tstruct net *peer_net;\n\tu32 peer_hash_mix;\n#ifdef CONFIG_TIPC_CRYPTO\n\tstruct tipc_crypto *crypto_rx;\n#endif\n};\n\n \nenum {\n\tSELF_DOWN_PEER_DOWN    = 0xdd,\n\tSELF_UP_PEER_UP        = 0xaa,\n\tSELF_DOWN_PEER_LEAVING = 0xd1,\n\tSELF_UP_PEER_COMING    = 0xac,\n\tSELF_COMING_PEER_UP    = 0xca,\n\tSELF_LEAVING_PEER_DOWN = 0x1d,\n\tNODE_FAILINGOVER       = 0xf0,\n\tNODE_SYNCHING          = 0xcc\n};\n\nenum {\n\tSELF_ESTABL_CONTACT_EVT = 0xece,\n\tSELF_LOST_CONTACT_EVT   = 0x1ce,\n\tPEER_ESTABL_CONTACT_EVT = 0x9ece,\n\tPEER_LOST_CONTACT_EVT   = 0x91ce,\n\tNODE_FAILOVER_BEGIN_EVT = 0xfbe,\n\tNODE_FAILOVER_END_EVT   = 0xfee,\n\tNODE_SYNCH_BEGIN_EVT    = 0xcbe,\n\tNODE_SYNCH_END_EVT      = 0xcee\n};\n\nstatic void __tipc_node_link_down(struct tipc_node *n, int *bearer_id,\n\t\t\t\t  struct sk_buff_head *xmitq,\n\t\t\t\t  struct tipc_media_addr **maddr);\nstatic void tipc_node_link_down(struct tipc_node *n, int bearer_id,\n\t\t\t\tbool delete);\nstatic void node_lost_contact(struct tipc_node *n, struct sk_buff_head *inputq);\nstatic void tipc_node_delete(struct tipc_node *node);\nstatic void tipc_node_timeout(struct timer_list *t);\nstatic void tipc_node_fsm_evt(struct tipc_node *n, int evt);\nstatic struct tipc_node *tipc_node_find(struct net *net, u32 addr);\nstatic struct tipc_node *tipc_node_find_by_id(struct net *net, u8 *id);\nstatic bool node_is_up(struct tipc_node *n);\nstatic void tipc_node_delete_from_list(struct tipc_node *node);\n\nstruct tipc_sock_conn {\n\tu32 port;\n\tu32 peer_port;\n\tu32 peer_node;\n\tstruct list_head list;\n};\n\nstatic struct tipc_link *node_active_link(struct tipc_node *n, int sel)\n{\n\tint bearer_id = n->active_links[sel & 1];\n\n\tif (unlikely(bearer_id == INVALID_BEARER_ID))\n\t\treturn NULL;\n\n\treturn n->links[bearer_id].link;\n}\n\nint tipc_node_get_mtu(struct net *net, u32 addr, u32 sel, bool connected)\n{\n\tstruct tipc_node *n;\n\tint bearer_id;\n\tunsigned int mtu = MAX_MSG_SIZE;\n\n\tn = tipc_node_find(net, addr);\n\tif (unlikely(!n))\n\t\treturn mtu;\n\n\t \n\tif (n->peer_net && connected) {\n\t\ttipc_node_put(n);\n\t\treturn mtu;\n\t}\n\n\tbearer_id = n->active_links[sel & 1];\n\tif (likely(bearer_id != INVALID_BEARER_ID))\n\t\tmtu = n->links[bearer_id].mtu;\n\ttipc_node_put(n);\n\treturn mtu;\n}\n\nbool tipc_node_get_id(struct net *net, u32 addr, u8 *id)\n{\n\tu8 *own_id = tipc_own_id(net);\n\tstruct tipc_node *n;\n\n\tif (!own_id)\n\t\treturn true;\n\n\tif (addr == tipc_own_addr(net)) {\n\t\tmemcpy(id, own_id, TIPC_NODEID_LEN);\n\t\treturn true;\n\t}\n\tn = tipc_node_find(net, addr);\n\tif (!n)\n\t\treturn false;\n\n\tmemcpy(id, &n->peer_id, TIPC_NODEID_LEN);\n\ttipc_node_put(n);\n\treturn true;\n}\n\nu16 tipc_node_get_capabilities(struct net *net, u32 addr)\n{\n\tstruct tipc_node *n;\n\tu16 caps;\n\n\tn = tipc_node_find(net, addr);\n\tif (unlikely(!n))\n\t\treturn TIPC_NODE_CAPABILITIES;\n\tcaps = n->capabilities;\n\ttipc_node_put(n);\n\treturn caps;\n}\n\nu32 tipc_node_get_addr(struct tipc_node *node)\n{\n\treturn (node) ? node->addr : 0;\n}\n\nchar *tipc_node_get_id_str(struct tipc_node *node)\n{\n\treturn node->peer_id_string;\n}\n\n#ifdef CONFIG_TIPC_CRYPTO\n \nstruct tipc_crypto *tipc_node_crypto_rx(struct tipc_node *__n)\n{\n\treturn (__n) ? __n->crypto_rx : NULL;\n}\n\nstruct tipc_crypto *tipc_node_crypto_rx_by_list(struct list_head *pos)\n{\n\treturn container_of(pos, struct tipc_node, list)->crypto_rx;\n}\n\nstruct tipc_crypto *tipc_node_crypto_rx_by_addr(struct net *net, u32 addr)\n{\n\tstruct tipc_node *n;\n\n\tn = tipc_node_find(net, addr);\n\treturn (n) ? n->crypto_rx : NULL;\n}\n#endif\n\nstatic void tipc_node_free(struct rcu_head *rp)\n{\n\tstruct tipc_node *n = container_of(rp, struct tipc_node, rcu);\n\n#ifdef CONFIG_TIPC_CRYPTO\n\ttipc_crypto_stop(&n->crypto_rx);\n#endif\n\tkfree(n);\n}\n\nstatic void tipc_node_kref_release(struct kref *kref)\n{\n\tstruct tipc_node *n = container_of(kref, struct tipc_node, kref);\n\n\tkfree(n->bc_entry.link);\n\tcall_rcu(&n->rcu, tipc_node_free);\n}\n\nvoid tipc_node_put(struct tipc_node *node)\n{\n\tkref_put(&node->kref, tipc_node_kref_release);\n}\n\nvoid tipc_node_get(struct tipc_node *node)\n{\n\tkref_get(&node->kref);\n}\n\n \nstatic struct tipc_node *tipc_node_find(struct net *net, u32 addr)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_node *node;\n\tunsigned int thash = tipc_hashfn(addr);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(node, &tn->node_htable[thash], hash) {\n\t\tif (node->addr != addr || node->preliminary)\n\t\t\tcontinue;\n\t\tif (!kref_get_unless_zero(&node->kref))\n\t\t\tnode = NULL;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn node;\n}\n\n \nstatic struct tipc_node *tipc_node_find_by_id(struct net *net, u8 *id)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_node *n;\n\tbool found = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\tread_lock_bh(&n->lock);\n\t\tif (!memcmp(id, n->peer_id, 16) &&\n\t\t    kref_get_unless_zero(&n->kref))\n\t\t\tfound = true;\n\t\tread_unlock_bh(&n->lock);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn found ? n : NULL;\n}\n\nstatic void tipc_node_read_lock(struct tipc_node *n)\n\t__acquires(n->lock)\n{\n\tread_lock_bh(&n->lock);\n}\n\nstatic void tipc_node_read_unlock(struct tipc_node *n)\n\t__releases(n->lock)\n{\n\tread_unlock_bh(&n->lock);\n}\n\nstatic void tipc_node_write_lock(struct tipc_node *n)\n\t__acquires(n->lock)\n{\n\twrite_lock_bh(&n->lock);\n}\n\nstatic void tipc_node_write_unlock_fast(struct tipc_node *n)\n\t__releases(n->lock)\n{\n\twrite_unlock_bh(&n->lock);\n}\n\nstatic void tipc_node_write_unlock(struct tipc_node *n)\n\t__releases(n->lock)\n{\n\tstruct tipc_socket_addr sk;\n\tstruct net *net = n->net;\n\tu32 flags = n->action_flags;\n\tstruct list_head *publ_list;\n\tstruct tipc_uaddr ua;\n\tu32 bearer_id, node;\n\n\tif (likely(!flags)) {\n\t\twrite_unlock_bh(&n->lock);\n\t\treturn;\n\t}\n\n\ttipc_uaddr(&ua, TIPC_SERVICE_RANGE, TIPC_NODE_SCOPE,\n\t\t   TIPC_LINK_STATE, n->addr, n->addr);\n\tsk.ref = n->link_id;\n\tsk.node = tipc_own_addr(net);\n\tnode = n->addr;\n\tbearer_id = n->link_id & 0xffff;\n\tpubl_list = &n->publ_list;\n\n\tn->action_flags &= ~(TIPC_NOTIFY_NODE_DOWN | TIPC_NOTIFY_NODE_UP |\n\t\t\t     TIPC_NOTIFY_LINK_DOWN | TIPC_NOTIFY_LINK_UP);\n\n\twrite_unlock_bh(&n->lock);\n\n\tif (flags & TIPC_NOTIFY_NODE_DOWN)\n\t\ttipc_publ_notify(net, publ_list, node, n->capabilities);\n\n\tif (flags & TIPC_NOTIFY_NODE_UP)\n\t\ttipc_named_node_up(net, node, n->capabilities);\n\n\tif (flags & TIPC_NOTIFY_LINK_UP) {\n\t\ttipc_mon_peer_up(net, node, bearer_id);\n\t\ttipc_nametbl_publish(net, &ua, &sk, sk.ref);\n\t}\n\tif (flags & TIPC_NOTIFY_LINK_DOWN) {\n\t\ttipc_mon_peer_down(net, node, bearer_id);\n\t\ttipc_nametbl_withdraw(net, &ua, &sk, sk.ref);\n\t}\n}\n\nstatic void tipc_node_assign_peer_net(struct tipc_node *n, u32 hash_mixes)\n{\n\tint net_id = tipc_netid(n->net);\n\tstruct tipc_net *tn_peer;\n\tstruct net *tmp;\n\tu32 hash_chk;\n\n\tif (n->peer_net)\n\t\treturn;\n\n\tfor_each_net_rcu(tmp) {\n\t\ttn_peer = tipc_net(tmp);\n\t\tif (!tn_peer)\n\t\t\tcontinue;\n\t\t \n\t\tif (tn_peer->net_id != net_id)\n\t\t\tcontinue;\n\t\tif (memcmp(n->peer_id, tn_peer->node_id, NODE_ID_LEN))\n\t\t\tcontinue;\n\t\thash_chk = tipc_net_hash_mixes(tmp, tn_peer->random);\n\t\tif (hash_mixes ^ hash_chk)\n\t\t\tcontinue;\n\t\tn->peer_net = tmp;\n\t\tn->peer_hash_mix = hash_mixes;\n\t\tbreak;\n\t}\n}\n\nstruct tipc_node *tipc_node_create(struct net *net, u32 addr, u8 *peer_id,\n\t\t\t\t   u16 capabilities, u32 hash_mixes,\n\t\t\t\t   bool preliminary)\n{\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tstruct tipc_link *l, *snd_l = tipc_bc_sndlink(net);\n\tstruct tipc_node *n, *temp_node;\n\tunsigned long intv;\n\tint bearer_id;\n\tint i;\n\n\tspin_lock_bh(&tn->node_list_lock);\n\tn = tipc_node_find(net, addr) ?:\n\t\ttipc_node_find_by_id(net, peer_id);\n\tif (n) {\n\t\tif (!n->preliminary)\n\t\t\tgoto update;\n\t\tif (preliminary)\n\t\t\tgoto exit;\n\t\t \n\t\ttipc_node_write_lock(n);\n\t\tif (!tipc_link_bc_create(net, tipc_own_addr(net), addr, peer_id, U16_MAX,\n\t\t\t\t\t tipc_link_min_win(snd_l), tipc_link_max_win(snd_l),\n\t\t\t\t\t n->capabilities, &n->bc_entry.inputq1,\n\t\t\t\t\t &n->bc_entry.namedq, snd_l, &n->bc_entry.link)) {\n\t\t\tpr_warn(\"Broadcast rcv link refresh failed, no memory\\n\");\n\t\t\ttipc_node_write_unlock_fast(n);\n\t\t\ttipc_node_put(n);\n\t\t\tn = NULL;\n\t\t\tgoto exit;\n\t\t}\n\t\tn->preliminary = false;\n\t\tn->addr = addr;\n\t\thlist_del_rcu(&n->hash);\n\t\thlist_add_head_rcu(&n->hash,\n\t\t\t\t   &tn->node_htable[tipc_hashfn(addr)]);\n\t\tlist_del_rcu(&n->list);\n\t\tlist_for_each_entry_rcu(temp_node, &tn->node_list, list) {\n\t\t\tif (n->addr < temp_node->addr)\n\t\t\t\tbreak;\n\t\t}\n\t\tlist_add_tail_rcu(&n->list, &temp_node->list);\n\t\ttipc_node_write_unlock_fast(n);\n\nupdate:\n\t\tif (n->peer_hash_mix ^ hash_mixes)\n\t\t\ttipc_node_assign_peer_net(n, hash_mixes);\n\t\tif (n->capabilities == capabilities)\n\t\t\tgoto exit;\n\t\t \n\t\ttipc_node_write_lock(n);\n\t\tn->capabilities = capabilities;\n\t\tfor (bearer_id = 0; bearer_id < MAX_BEARERS; bearer_id++) {\n\t\t\tl = n->links[bearer_id].link;\n\t\t\tif (l)\n\t\t\t\ttipc_link_update_caps(l, capabilities);\n\t\t}\n\t\ttipc_node_write_unlock_fast(n);\n\n\t\t \n\t\ttn->capabilities = TIPC_NODE_CAPABILITIES;\n\t\tlist_for_each_entry_rcu(temp_node, &tn->node_list, list) {\n\t\t\ttn->capabilities &= temp_node->capabilities;\n\t\t}\n\n\t\ttipc_bcast_toggle_rcast(net,\n\t\t\t\t\t(tn->capabilities & TIPC_BCAST_RCAST));\n\n\t\tgoto exit;\n\t}\n\tn = kzalloc(sizeof(*n), GFP_ATOMIC);\n\tif (!n) {\n\t\tpr_warn(\"Node creation failed, no memory\\n\");\n\t\tgoto exit;\n\t}\n\ttipc_nodeid2string(n->peer_id_string, peer_id);\n#ifdef CONFIG_TIPC_CRYPTO\n\tif (unlikely(tipc_crypto_start(&n->crypto_rx, net, n))) {\n\t\tpr_warn(\"Failed to start crypto RX(%s)!\\n\", n->peer_id_string);\n\t\tkfree(n);\n\t\tn = NULL;\n\t\tgoto exit;\n\t}\n#endif\n\tn->addr = addr;\n\tn->preliminary = preliminary;\n\tmemcpy(&n->peer_id, peer_id, 16);\n\tn->net = net;\n\tn->peer_net = NULL;\n\tn->peer_hash_mix = 0;\n\t \n\ttipc_node_assign_peer_net(n, hash_mixes);\n\tn->capabilities = capabilities;\n\tkref_init(&n->kref);\n\trwlock_init(&n->lock);\n\tINIT_HLIST_NODE(&n->hash);\n\tINIT_LIST_HEAD(&n->list);\n\tINIT_LIST_HEAD(&n->publ_list);\n\tINIT_LIST_HEAD(&n->conn_sks);\n\tskb_queue_head_init(&n->bc_entry.namedq);\n\tskb_queue_head_init(&n->bc_entry.inputq1);\n\t__skb_queue_head_init(&n->bc_entry.arrvq);\n\tskb_queue_head_init(&n->bc_entry.inputq2);\n\tfor (i = 0; i < MAX_BEARERS; i++)\n\t\tspin_lock_init(&n->links[i].lock);\n\tn->state = SELF_DOWN_PEER_LEAVING;\n\tn->delete_at = jiffies + msecs_to_jiffies(NODE_CLEANUP_AFTER);\n\tn->signature = INVALID_NODE_SIG;\n\tn->active_links[0] = INVALID_BEARER_ID;\n\tn->active_links[1] = INVALID_BEARER_ID;\n\tif (!preliminary &&\n\t    !tipc_link_bc_create(net, tipc_own_addr(net), addr, peer_id, U16_MAX,\n\t\t\t\t tipc_link_min_win(snd_l), tipc_link_max_win(snd_l),\n\t\t\t\t n->capabilities, &n->bc_entry.inputq1,\n\t\t\t\t &n->bc_entry.namedq, snd_l, &n->bc_entry.link)) {\n\t\tpr_warn(\"Broadcast rcv link creation failed, no memory\\n\");\n\t\ttipc_node_put(n);\n\t\tn = NULL;\n\t\tgoto exit;\n\t}\n\ttipc_node_get(n);\n\ttimer_setup(&n->timer, tipc_node_timeout, 0);\n\t \n\tn->keepalive_intv = 10000;\n\tintv = jiffies + msecs_to_jiffies(n->keepalive_intv);\n\tif (!mod_timer(&n->timer, intv))\n\t\ttipc_node_get(n);\n\thlist_add_head_rcu(&n->hash, &tn->node_htable[tipc_hashfn(addr)]);\n\tlist_for_each_entry_rcu(temp_node, &tn->node_list, list) {\n\t\tif (n->addr < temp_node->addr)\n\t\t\tbreak;\n\t}\n\tlist_add_tail_rcu(&n->list, &temp_node->list);\n\t \n\ttn->capabilities = TIPC_NODE_CAPABILITIES;\n\tlist_for_each_entry_rcu(temp_node, &tn->node_list, list) {\n\t\ttn->capabilities &= temp_node->capabilities;\n\t}\n\ttipc_bcast_toggle_rcast(net, (tn->capabilities & TIPC_BCAST_RCAST));\n\ttrace_tipc_node_create(n, true, \" \");\nexit:\n\tspin_unlock_bh(&tn->node_list_lock);\n\treturn n;\n}\n\nstatic void tipc_node_calculate_timer(struct tipc_node *n, struct tipc_link *l)\n{\n\tunsigned long tol = tipc_link_tolerance(l);\n\tunsigned long intv = ((tol / 4) > 500) ? 500 : tol / 4;\n\n\t \n\tif (intv < n->keepalive_intv)\n\t\tn->keepalive_intv = intv;\n\n\t \n\ttipc_link_set_abort_limit(l, tol / n->keepalive_intv);\n}\n\nstatic void tipc_node_delete_from_list(struct tipc_node *node)\n{\n#ifdef CONFIG_TIPC_CRYPTO\n\ttipc_crypto_key_flush(node->crypto_rx);\n#endif\n\tlist_del_rcu(&node->list);\n\thlist_del_rcu(&node->hash);\n\ttipc_node_put(node);\n}\n\nstatic void tipc_node_delete(struct tipc_node *node)\n{\n\ttrace_tipc_node_delete(node, true, \" \");\n\ttipc_node_delete_from_list(node);\n\n\tdel_timer_sync(&node->timer);\n\ttipc_node_put(node);\n}\n\nvoid tipc_node_stop(struct net *net)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_node *node, *t_node;\n\n\tspin_lock_bh(&tn->node_list_lock);\n\tlist_for_each_entry_safe(node, t_node, &tn->node_list, list)\n\t\ttipc_node_delete(node);\n\tspin_unlock_bh(&tn->node_list_lock);\n}\n\nvoid tipc_node_subscribe(struct net *net, struct list_head *subscr, u32 addr)\n{\n\tstruct tipc_node *n;\n\n\tif (in_own_node(net, addr))\n\t\treturn;\n\n\tn = tipc_node_find(net, addr);\n\tif (!n) {\n\t\tpr_warn(\"Node subscribe rejected, unknown node 0x%x\\n\", addr);\n\t\treturn;\n\t}\n\ttipc_node_write_lock(n);\n\tlist_add_tail(subscr, &n->publ_list);\n\ttipc_node_write_unlock_fast(n);\n\ttipc_node_put(n);\n}\n\nvoid tipc_node_unsubscribe(struct net *net, struct list_head *subscr, u32 addr)\n{\n\tstruct tipc_node *n;\n\n\tif (in_own_node(net, addr))\n\t\treturn;\n\n\tn = tipc_node_find(net, addr);\n\tif (!n) {\n\t\tpr_warn(\"Node unsubscribe rejected, unknown node 0x%x\\n\", addr);\n\t\treturn;\n\t}\n\ttipc_node_write_lock(n);\n\tlist_del_init(subscr);\n\ttipc_node_write_unlock_fast(n);\n\ttipc_node_put(n);\n}\n\nint tipc_node_add_conn(struct net *net, u32 dnode, u32 port, u32 peer_port)\n{\n\tstruct tipc_node *node;\n\tstruct tipc_sock_conn *conn;\n\tint err = 0;\n\n\tif (in_own_node(net, dnode))\n\t\treturn 0;\n\n\tnode = tipc_node_find(net, dnode);\n\tif (!node) {\n\t\tpr_warn(\"Connecting sock to node 0x%x failed\\n\", dnode);\n\t\treturn -EHOSTUNREACH;\n\t}\n\tconn = kmalloc(sizeof(*conn), GFP_ATOMIC);\n\tif (!conn) {\n\t\terr = -EHOSTUNREACH;\n\t\tgoto exit;\n\t}\n\tconn->peer_node = dnode;\n\tconn->port = port;\n\tconn->peer_port = peer_port;\n\n\ttipc_node_write_lock(node);\n\tlist_add_tail(&conn->list, &node->conn_sks);\n\ttipc_node_write_unlock(node);\nexit:\n\ttipc_node_put(node);\n\treturn err;\n}\n\nvoid tipc_node_remove_conn(struct net *net, u32 dnode, u32 port)\n{\n\tstruct tipc_node *node;\n\tstruct tipc_sock_conn *conn, *safe;\n\n\tif (in_own_node(net, dnode))\n\t\treturn;\n\n\tnode = tipc_node_find(net, dnode);\n\tif (!node)\n\t\treturn;\n\n\ttipc_node_write_lock(node);\n\tlist_for_each_entry_safe(conn, safe, &node->conn_sks, list) {\n\t\tif (port != conn->port)\n\t\t\tcontinue;\n\t\tlist_del(&conn->list);\n\t\tkfree(conn);\n\t}\n\ttipc_node_write_unlock(node);\n\ttipc_node_put(node);\n}\n\nstatic void  tipc_node_clear_links(struct tipc_node *node)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\tstruct tipc_link_entry *le = &node->links[i];\n\n\t\tif (le->link) {\n\t\t\tkfree(le->link);\n\t\t\tle->link = NULL;\n\t\t\tnode->link_cnt--;\n\t\t}\n\t}\n}\n\n \nstatic bool tipc_node_cleanup(struct tipc_node *peer)\n{\n\tstruct tipc_node *temp_node;\n\tstruct tipc_net *tn = tipc_net(peer->net);\n\tbool deleted = false;\n\n\t \n\tif (!spin_trylock_bh(&tn->node_list_lock))\n\t\treturn false;\n\n\ttipc_node_write_lock(peer);\n\n\tif (!node_is_up(peer) && time_after(jiffies, peer->delete_at)) {\n\t\ttipc_node_clear_links(peer);\n\t\ttipc_node_delete_from_list(peer);\n\t\tdeleted = true;\n\t}\n\ttipc_node_write_unlock(peer);\n\n\tif (!deleted) {\n\t\tspin_unlock_bh(&tn->node_list_lock);\n\t\treturn deleted;\n\t}\n\n\t \n\ttn->capabilities = TIPC_NODE_CAPABILITIES;\n\tlist_for_each_entry_rcu(temp_node, &tn->node_list, list) {\n\t\ttn->capabilities &= temp_node->capabilities;\n\t}\n\ttipc_bcast_toggle_rcast(peer->net,\n\t\t\t\t(tn->capabilities & TIPC_BCAST_RCAST));\n\tspin_unlock_bh(&tn->node_list_lock);\n\treturn deleted;\n}\n\n \nstatic void tipc_node_timeout(struct timer_list *t)\n{\n\tstruct tipc_node *n = from_timer(n, t, timer);\n\tstruct tipc_link_entry *le;\n\tstruct sk_buff_head xmitq;\n\tint remains = n->link_cnt;\n\tint bearer_id;\n\tint rc = 0;\n\n\ttrace_tipc_node_timeout(n, false, \" \");\n\tif (!node_is_up(n) && tipc_node_cleanup(n)) {\n\t\t \n\t\ttipc_node_put(n);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_TIPC_CRYPTO\n\t \n\ttipc_crypto_timeout(n->crypto_rx);\n#endif\n\t__skb_queue_head_init(&xmitq);\n\n\t \n\ttipc_node_read_lock(n);\n\tn->keepalive_intv = 10000;\n\ttipc_node_read_unlock(n);\n\tfor (bearer_id = 0; remains && (bearer_id < MAX_BEARERS); bearer_id++) {\n\t\ttipc_node_read_lock(n);\n\t\tle = &n->links[bearer_id];\n\t\tif (le->link) {\n\t\t\tspin_lock_bh(&le->lock);\n\t\t\t \n\t\t\ttipc_node_calculate_timer(n, le->link);\n\t\t\trc = tipc_link_timeout(le->link, &xmitq);\n\t\t\tspin_unlock_bh(&le->lock);\n\t\t\tremains--;\n\t\t}\n\t\ttipc_node_read_unlock(n);\n\t\ttipc_bearer_xmit(n->net, bearer_id, &xmitq, &le->maddr, n);\n\t\tif (rc & TIPC_LINK_DOWN_EVT)\n\t\t\ttipc_node_link_down(n, bearer_id, false);\n\t}\n\tmod_timer(&n->timer, jiffies + msecs_to_jiffies(n->keepalive_intv));\n}\n\n \nstatic void __tipc_node_link_up(struct tipc_node *n, int bearer_id,\n\t\t\t\tstruct sk_buff_head *xmitq)\n{\n\tint *slot0 = &n->active_links[0];\n\tint *slot1 = &n->active_links[1];\n\tstruct tipc_link *ol = node_active_link(n, 0);\n\tstruct tipc_link *nl = n->links[bearer_id].link;\n\n\tif (!nl || tipc_link_is_up(nl))\n\t\treturn;\n\n\ttipc_link_fsm_evt(nl, LINK_ESTABLISH_EVT);\n\tif (!tipc_link_is_up(nl))\n\t\treturn;\n\n\tn->working_links++;\n\tn->action_flags |= TIPC_NOTIFY_LINK_UP;\n\tn->link_id = tipc_link_id(nl);\n\n\t \n\tn->links[bearer_id].mtu = tipc_link_mss(nl);\n\n\ttipc_bearer_add_dest(n->net, bearer_id, n->addr);\n\ttipc_bcast_inc_bearer_dst_cnt(n->net, bearer_id);\n\n\tpr_debug(\"Established link <%s> on network plane %c\\n\",\n\t\t tipc_link_name(nl), tipc_link_plane(nl));\n\ttrace_tipc_node_link_up(n, true, \" \");\n\n\t \n\ttipc_link_build_state_msg(nl, xmitq);\n\n\t \n\tif (!ol) {\n\t\t*slot0 = bearer_id;\n\t\t*slot1 = bearer_id;\n\t\ttipc_node_fsm_evt(n, SELF_ESTABL_CONTACT_EVT);\n\t\tn->action_flags |= TIPC_NOTIFY_NODE_UP;\n\t\ttipc_link_set_active(nl, true);\n\t\ttipc_bcast_add_peer(n->net, nl, xmitq);\n\t\treturn;\n\t}\n\n\t \n\tif (tipc_link_prio(nl) > tipc_link_prio(ol)) {\n\t\tpr_debug(\"Old link <%s> becomes standby\\n\", tipc_link_name(ol));\n\t\t*slot0 = bearer_id;\n\t\t*slot1 = bearer_id;\n\t\ttipc_link_set_active(nl, true);\n\t\ttipc_link_set_active(ol, false);\n\t} else if (tipc_link_prio(nl) == tipc_link_prio(ol)) {\n\t\ttipc_link_set_active(nl, true);\n\t\t*slot1 = bearer_id;\n\t} else {\n\t\tpr_debug(\"New link <%s> is standby\\n\", tipc_link_name(nl));\n\t}\n\n\t \n\ttipc_link_tnl_prepare(ol, nl, SYNCH_MSG, xmitq);\n}\n\n \nstatic void tipc_node_link_up(struct tipc_node *n, int bearer_id,\n\t\t\t      struct sk_buff_head *xmitq)\n{\n\tstruct tipc_media_addr *maddr;\n\n\ttipc_node_write_lock(n);\n\t__tipc_node_link_up(n, bearer_id, xmitq);\n\tmaddr = &n->links[bearer_id].maddr;\n\ttipc_bearer_xmit(n->net, bearer_id, xmitq, maddr, n);\n\ttipc_node_write_unlock(n);\n}\n\n \nstatic void tipc_node_link_failover(struct tipc_node *n, struct tipc_link *l,\n\t\t\t\t    struct tipc_link *tnl,\n\t\t\t\t    struct sk_buff_head *xmitq)\n{\n\t \n\tif (!tipc_link_is_up(tnl))\n\t\treturn;\n\n\t \n\tif (l && !tipc_link_is_reset(l))\n\t\treturn;\n\n\ttipc_link_fsm_evt(tnl, LINK_SYNCH_END_EVT);\n\ttipc_node_fsm_evt(n, NODE_SYNCH_END_EVT);\n\n\tn->sync_point = tipc_link_rcv_nxt(tnl) + (U16_MAX / 2 - 1);\n\ttipc_link_failover_prepare(l, tnl, xmitq);\n\n\tif (l)\n\t\ttipc_link_fsm_evt(l, LINK_FAILOVER_BEGIN_EVT);\n\ttipc_node_fsm_evt(n, NODE_FAILOVER_BEGIN_EVT);\n}\n\n \nstatic void __tipc_node_link_down(struct tipc_node *n, int *bearer_id,\n\t\t\t\t  struct sk_buff_head *xmitq,\n\t\t\t\t  struct tipc_media_addr **maddr)\n{\n\tstruct tipc_link_entry *le = &n->links[*bearer_id];\n\tint *slot0 = &n->active_links[0];\n\tint *slot1 = &n->active_links[1];\n\tint i, highest = 0, prio;\n\tstruct tipc_link *l, *_l, *tnl;\n\n\tl = n->links[*bearer_id].link;\n\tif (!l || tipc_link_is_reset(l))\n\t\treturn;\n\n\tn->working_links--;\n\tn->action_flags |= TIPC_NOTIFY_LINK_DOWN;\n\tn->link_id = tipc_link_id(l);\n\n\ttipc_bearer_remove_dest(n->net, *bearer_id, n->addr);\n\n\tpr_debug(\"Lost link <%s> on network plane %c\\n\",\n\t\t tipc_link_name(l), tipc_link_plane(l));\n\n\t \n\t*slot0 = INVALID_BEARER_ID;\n\t*slot1 = INVALID_BEARER_ID;\n\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\t_l = n->links[i].link;\n\t\tif (!_l || !tipc_link_is_up(_l))\n\t\t\tcontinue;\n\t\tif (_l == l)\n\t\t\tcontinue;\n\t\tprio = tipc_link_prio(_l);\n\t\tif (prio < highest)\n\t\t\tcontinue;\n\t\tif (prio > highest) {\n\t\t\thighest = prio;\n\t\t\t*slot0 = i;\n\t\t\t*slot1 = i;\n\t\t\tcontinue;\n\t\t}\n\t\t*slot1 = i;\n\t}\n\n\tif (!node_is_up(n)) {\n\t\tif (tipc_link_peer_is_down(l))\n\t\t\ttipc_node_fsm_evt(n, PEER_LOST_CONTACT_EVT);\n\t\ttipc_node_fsm_evt(n, SELF_LOST_CONTACT_EVT);\n\t\ttrace_tipc_link_reset(l, TIPC_DUMP_ALL, \"link down!\");\n\t\ttipc_link_fsm_evt(l, LINK_RESET_EVT);\n\t\ttipc_link_reset(l);\n\t\ttipc_link_build_reset_msg(l, xmitq);\n\t\t*maddr = &n->links[*bearer_id].maddr;\n\t\tnode_lost_contact(n, &le->inputq);\n\t\ttipc_bcast_dec_bearer_dst_cnt(n->net, *bearer_id);\n\t\treturn;\n\t}\n\ttipc_bcast_dec_bearer_dst_cnt(n->net, *bearer_id);\n\n\t \n\t*bearer_id = n->active_links[0];\n\ttnl = n->links[*bearer_id].link;\n\ttipc_link_fsm_evt(tnl, LINK_SYNCH_END_EVT);\n\ttipc_node_fsm_evt(n, NODE_SYNCH_END_EVT);\n\tn->sync_point = tipc_link_rcv_nxt(tnl) + (U16_MAX / 2 - 1);\n\ttipc_link_tnl_prepare(l, tnl, FAILOVER_MSG, xmitq);\n\ttrace_tipc_link_reset(l, TIPC_DUMP_ALL, \"link down -> failover!\");\n\ttipc_link_reset(l);\n\ttipc_link_fsm_evt(l, LINK_RESET_EVT);\n\ttipc_link_fsm_evt(l, LINK_FAILOVER_BEGIN_EVT);\n\ttipc_node_fsm_evt(n, NODE_FAILOVER_BEGIN_EVT);\n\t*maddr = &n->links[*bearer_id].maddr;\n}\n\nstatic void tipc_node_link_down(struct tipc_node *n, int bearer_id, bool delete)\n{\n\tstruct tipc_link_entry *le = &n->links[bearer_id];\n\tstruct tipc_media_addr *maddr = NULL;\n\tstruct tipc_link *l = le->link;\n\tint old_bearer_id = bearer_id;\n\tstruct sk_buff_head xmitq;\n\n\tif (!l)\n\t\treturn;\n\n\t__skb_queue_head_init(&xmitq);\n\n\ttipc_node_write_lock(n);\n\tif (!tipc_link_is_establishing(l)) {\n\t\t__tipc_node_link_down(n, &bearer_id, &xmitq, &maddr);\n\t} else {\n\t\t \n\t\ttipc_link_reset(l);\n\t\ttipc_link_fsm_evt(l, LINK_RESET_EVT);\n\t}\n\tif (delete) {\n\t\tkfree(l);\n\t\tle->link = NULL;\n\t\tn->link_cnt--;\n\t}\n\ttrace_tipc_node_link_down(n, true, \"node link down or deleted!\");\n\ttipc_node_write_unlock(n);\n\tif (delete)\n\t\ttipc_mon_remove_peer(n->net, n->addr, old_bearer_id);\n\tif (!skb_queue_empty(&xmitq))\n\t\ttipc_bearer_xmit(n->net, bearer_id, &xmitq, maddr, n);\n\ttipc_sk_rcv(n->net, &le->inputq);\n}\n\nstatic bool node_is_up(struct tipc_node *n)\n{\n\treturn n->active_links[0] != INVALID_BEARER_ID;\n}\n\nbool tipc_node_is_up(struct net *net, u32 addr)\n{\n\tstruct tipc_node *n;\n\tbool retval = false;\n\n\tif (in_own_node(net, addr))\n\t\treturn true;\n\n\tn = tipc_node_find(net, addr);\n\tif (!n)\n\t\treturn false;\n\tretval = node_is_up(n);\n\ttipc_node_put(n);\n\treturn retval;\n}\n\nstatic u32 tipc_node_suggest_addr(struct net *net, u32 addr)\n{\n\tstruct tipc_node *n;\n\n\taddr ^= tipc_net(net)->random;\n\twhile ((n = tipc_node_find(net, addr))) {\n\t\ttipc_node_put(n);\n\t\taddr++;\n\t}\n\treturn addr;\n}\n\n \nu32 tipc_node_try_addr(struct net *net, u8 *id, u32 addr)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_node *n;\n\tbool preliminary;\n\tu32 sugg_addr;\n\n\t \n\tn = tipc_node_find(net, addr);\n\tif (n) {\n\t\tif (!memcmp(n->peer_id, id, NODE_ID_LEN))\n\t\t\taddr = 0;\n\t\ttipc_node_put(n);\n\t\tif (!addr)\n\t\t\treturn 0;\n\t\treturn tipc_node_suggest_addr(net, addr);\n\t}\n\n\t \n\tn = tipc_node_find_by_id(net, id);\n\tif (n) {\n\t\tsugg_addr = n->addr;\n\t\tpreliminary = n->preliminary;\n\t\ttipc_node_put(n);\n\t\tif (!preliminary)\n\t\t\treturn sugg_addr;\n\t}\n\n\t \n\tif (tn->trial_addr == addr)\n\t\treturn tipc_node_suggest_addr(net, addr);\n\n\treturn 0;\n}\n\nvoid tipc_node_check_dest(struct net *net, u32 addr,\n\t\t\t  u8 *peer_id, struct tipc_bearer *b,\n\t\t\t  u16 capabilities, u32 signature, u32 hash_mixes,\n\t\t\t  struct tipc_media_addr *maddr,\n\t\t\t  bool *respond, bool *dupl_addr)\n{\n\tstruct tipc_node *n;\n\tstruct tipc_link *l;\n\tstruct tipc_link_entry *le;\n\tbool addr_match = false;\n\tbool sign_match = false;\n\tbool link_up = false;\n\tbool link_is_reset = false;\n\tbool accept_addr = false;\n\tbool reset = false;\n\tchar *if_name;\n\tunsigned long intv;\n\tu16 session;\n\n\t*dupl_addr = false;\n\t*respond = false;\n\n\tn = tipc_node_create(net, addr, peer_id, capabilities, hash_mixes,\n\t\t\t     false);\n\tif (!n)\n\t\treturn;\n\n\ttipc_node_write_lock(n);\n\n\tle = &n->links[b->identity];\n\n\t \n\tl = le->link;\n\tlink_up = l && tipc_link_is_up(l);\n\tlink_is_reset = l && tipc_link_is_reset(l);\n\taddr_match = l && !memcmp(&le->maddr, maddr, sizeof(*maddr));\n\tsign_match = (signature == n->signature);\n\n\t \n\n\tif (sign_match && addr_match && link_up) {\n\t\t \n\t\t \n\t\tif (!n->peer_hash_mix)\n\t\t\tn->peer_hash_mix = hash_mixes;\n\t} else if (sign_match && addr_match && !link_up) {\n\t\t \n\t\t*respond = true;\n\t} else if (sign_match && !addr_match && link_up) {\n\t\t \n\t\t*dupl_addr = true;\n\t} else if (sign_match && !addr_match && !link_up) {\n\t\t \n\t\taccept_addr = true;\n\t\t*respond = true;\n\t\treset = true;\n\t} else if (!sign_match && addr_match && link_up) {\n\t\t \n\t\tn->signature = signature;\n\t} else if (!sign_match && addr_match && !link_up) {\n\t\t \n\t\tn->signature = signature;\n\t\t*respond = true;\n\t} else if (!sign_match && !addr_match && link_up) {\n\t\t \n\t\t*dupl_addr = true;\n\t} else if (!sign_match && !addr_match && !link_up) {\n\t\t \n\t\tn->signature = signature;\n\t\taccept_addr = true;\n\t\t*respond = true;\n\t\treset = true;\n\t}\n\n\tif (!accept_addr)\n\t\tgoto exit;\n\n\t \n\tif (!l) {\n\t\tif (n->link_cnt == 2)\n\t\t\tgoto exit;\n\n\t\tif_name = strchr(b->name, ':') + 1;\n\t\tget_random_bytes(&session, sizeof(u16));\n\t\tif (!tipc_link_create(net, if_name, b->identity, b->tolerance,\n\t\t\t\t      b->net_plane, b->mtu, b->priority,\n\t\t\t\t      b->min_win, b->max_win, session,\n\t\t\t\t      tipc_own_addr(net), addr, peer_id,\n\t\t\t\t      n->capabilities,\n\t\t\t\t      tipc_bc_sndlink(n->net), n->bc_entry.link,\n\t\t\t\t      &le->inputq,\n\t\t\t\t      &n->bc_entry.namedq, &l)) {\n\t\t\t*respond = false;\n\t\t\tgoto exit;\n\t\t}\n\t\ttrace_tipc_link_reset(l, TIPC_DUMP_ALL, \"link created!\");\n\t\ttipc_link_reset(l);\n\t\ttipc_link_fsm_evt(l, LINK_RESET_EVT);\n\t\tif (n->state == NODE_FAILINGOVER)\n\t\t\ttipc_link_fsm_evt(l, LINK_FAILOVER_BEGIN_EVT);\n\t\tlink_is_reset = tipc_link_is_reset(l);\n\t\tle->link = l;\n\t\tn->link_cnt++;\n\t\ttipc_node_calculate_timer(n, l);\n\t\tif (n->link_cnt == 1) {\n\t\t\tintv = jiffies + msecs_to_jiffies(n->keepalive_intv);\n\t\t\tif (!mod_timer(&n->timer, intv))\n\t\t\t\ttipc_node_get(n);\n\t\t}\n\t}\n\tmemcpy(&le->maddr, maddr, sizeof(*maddr));\nexit:\n\ttipc_node_write_unlock(n);\n\tif (reset && !link_is_reset)\n\t\ttipc_node_link_down(n, b->identity, false);\n\ttipc_node_put(n);\n}\n\nvoid tipc_node_delete_links(struct net *net, int bearer_id)\n{\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tstruct tipc_node *n;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\ttipc_node_link_down(n, bearer_id, true);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void tipc_node_reset_links(struct tipc_node *n)\n{\n\tint i;\n\n\tpr_warn(\"Resetting all links to %x\\n\", n->addr);\n\n\ttrace_tipc_node_reset_links(n, true, \" \");\n\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\ttipc_node_link_down(n, i, false);\n\t}\n}\n\n \nstatic void tipc_node_fsm_evt(struct tipc_node *n, int evt)\n{\n\tint state = n->state;\n\n\tswitch (state) {\n\tcase SELF_DOWN_PEER_DOWN:\n\t\tswitch (evt) {\n\t\tcase SELF_ESTABL_CONTACT_EVT:\n\t\t\tstate = SELF_UP_PEER_COMING;\n\t\t\tbreak;\n\t\tcase PEER_ESTABL_CONTACT_EVT:\n\t\t\tstate = SELF_COMING_PEER_UP;\n\t\t\tbreak;\n\t\tcase SELF_LOST_CONTACT_EVT:\n\t\tcase PEER_LOST_CONTACT_EVT:\n\t\t\tbreak;\n\t\tcase NODE_SYNCH_END_EVT:\n\t\tcase NODE_SYNCH_BEGIN_EVT:\n\t\tcase NODE_FAILOVER_BEGIN_EVT:\n\t\tcase NODE_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase SELF_UP_PEER_UP:\n\t\tswitch (evt) {\n\t\tcase SELF_LOST_CONTACT_EVT:\n\t\t\tstate = SELF_DOWN_PEER_LEAVING;\n\t\t\tbreak;\n\t\tcase PEER_LOST_CONTACT_EVT:\n\t\t\tstate = SELF_LEAVING_PEER_DOWN;\n\t\t\tbreak;\n\t\tcase NODE_SYNCH_BEGIN_EVT:\n\t\t\tstate = NODE_SYNCHING;\n\t\t\tbreak;\n\t\tcase NODE_FAILOVER_BEGIN_EVT:\n\t\t\tstate = NODE_FAILINGOVER;\n\t\t\tbreak;\n\t\tcase SELF_ESTABL_CONTACT_EVT:\n\t\tcase PEER_ESTABL_CONTACT_EVT:\n\t\tcase NODE_SYNCH_END_EVT:\n\t\tcase NODE_FAILOVER_END_EVT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase SELF_DOWN_PEER_LEAVING:\n\t\tswitch (evt) {\n\t\tcase PEER_LOST_CONTACT_EVT:\n\t\t\tstate = SELF_DOWN_PEER_DOWN;\n\t\t\tbreak;\n\t\tcase SELF_ESTABL_CONTACT_EVT:\n\t\tcase PEER_ESTABL_CONTACT_EVT:\n\t\tcase SELF_LOST_CONTACT_EVT:\n\t\t\tbreak;\n\t\tcase NODE_SYNCH_END_EVT:\n\t\tcase NODE_SYNCH_BEGIN_EVT:\n\t\tcase NODE_FAILOVER_BEGIN_EVT:\n\t\tcase NODE_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase SELF_UP_PEER_COMING:\n\t\tswitch (evt) {\n\t\tcase PEER_ESTABL_CONTACT_EVT:\n\t\t\tstate = SELF_UP_PEER_UP;\n\t\t\tbreak;\n\t\tcase SELF_LOST_CONTACT_EVT:\n\t\t\tstate = SELF_DOWN_PEER_DOWN;\n\t\t\tbreak;\n\t\tcase SELF_ESTABL_CONTACT_EVT:\n\t\tcase PEER_LOST_CONTACT_EVT:\n\t\tcase NODE_SYNCH_END_EVT:\n\t\tcase NODE_FAILOVER_BEGIN_EVT:\n\t\t\tbreak;\n\t\tcase NODE_SYNCH_BEGIN_EVT:\n\t\tcase NODE_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase SELF_COMING_PEER_UP:\n\t\tswitch (evt) {\n\t\tcase SELF_ESTABL_CONTACT_EVT:\n\t\t\tstate = SELF_UP_PEER_UP;\n\t\t\tbreak;\n\t\tcase PEER_LOST_CONTACT_EVT:\n\t\t\tstate = SELF_DOWN_PEER_DOWN;\n\t\t\tbreak;\n\t\tcase SELF_LOST_CONTACT_EVT:\n\t\tcase PEER_ESTABL_CONTACT_EVT:\n\t\t\tbreak;\n\t\tcase NODE_SYNCH_END_EVT:\n\t\tcase NODE_SYNCH_BEGIN_EVT:\n\t\tcase NODE_FAILOVER_BEGIN_EVT:\n\t\tcase NODE_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase SELF_LEAVING_PEER_DOWN:\n\t\tswitch (evt) {\n\t\tcase SELF_LOST_CONTACT_EVT:\n\t\t\tstate = SELF_DOWN_PEER_DOWN;\n\t\t\tbreak;\n\t\tcase SELF_ESTABL_CONTACT_EVT:\n\t\tcase PEER_ESTABL_CONTACT_EVT:\n\t\tcase PEER_LOST_CONTACT_EVT:\n\t\t\tbreak;\n\t\tcase NODE_SYNCH_END_EVT:\n\t\tcase NODE_SYNCH_BEGIN_EVT:\n\t\tcase NODE_FAILOVER_BEGIN_EVT:\n\t\tcase NODE_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase NODE_FAILINGOVER:\n\t\tswitch (evt) {\n\t\tcase SELF_LOST_CONTACT_EVT:\n\t\t\tstate = SELF_DOWN_PEER_LEAVING;\n\t\t\tbreak;\n\t\tcase PEER_LOST_CONTACT_EVT:\n\t\t\tstate = SELF_LEAVING_PEER_DOWN;\n\t\t\tbreak;\n\t\tcase NODE_FAILOVER_END_EVT:\n\t\t\tstate = SELF_UP_PEER_UP;\n\t\t\tbreak;\n\t\tcase NODE_FAILOVER_BEGIN_EVT:\n\t\tcase SELF_ESTABL_CONTACT_EVT:\n\t\tcase PEER_ESTABL_CONTACT_EVT:\n\t\t\tbreak;\n\t\tcase NODE_SYNCH_BEGIN_EVT:\n\t\tcase NODE_SYNCH_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase NODE_SYNCHING:\n\t\tswitch (evt) {\n\t\tcase SELF_LOST_CONTACT_EVT:\n\t\t\tstate = SELF_DOWN_PEER_LEAVING;\n\t\t\tbreak;\n\t\tcase PEER_LOST_CONTACT_EVT:\n\t\t\tstate = SELF_LEAVING_PEER_DOWN;\n\t\t\tbreak;\n\t\tcase NODE_SYNCH_END_EVT:\n\t\t\tstate = SELF_UP_PEER_UP;\n\t\t\tbreak;\n\t\tcase NODE_FAILOVER_BEGIN_EVT:\n\t\t\tstate = NODE_FAILINGOVER;\n\t\t\tbreak;\n\t\tcase NODE_SYNCH_BEGIN_EVT:\n\t\tcase SELF_ESTABL_CONTACT_EVT:\n\t\tcase PEER_ESTABL_CONTACT_EVT:\n\t\t\tbreak;\n\t\tcase NODE_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown node fsm state %x\\n\", state);\n\t\tbreak;\n\t}\n\ttrace_tipc_node_fsm(n->peer_id, n->state, state, evt);\n\tn->state = state;\n\treturn;\n\nillegal_evt:\n\tpr_err(\"Illegal node fsm evt %x in state %x\\n\", evt, state);\n\ttrace_tipc_node_fsm(n->peer_id, n->state, state, evt);\n}\n\nstatic void node_lost_contact(struct tipc_node *n,\n\t\t\t      struct sk_buff_head *inputq)\n{\n\tstruct tipc_sock_conn *conn, *safe;\n\tstruct tipc_link *l;\n\tstruct list_head *conns = &n->conn_sks;\n\tstruct sk_buff *skb;\n\tuint i;\n\n\tpr_debug(\"Lost contact with %x\\n\", n->addr);\n\tn->delete_at = jiffies + msecs_to_jiffies(NODE_CLEANUP_AFTER);\n\ttrace_tipc_node_lost_contact(n, true, \" \");\n\n\t \n\ttipc_bcast_remove_peer(n->net, n->bc_entry.link);\n\tskb_queue_purge(&n->bc_entry.namedq);\n\n\t \n\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\tl = n->links[i].link;\n\t\tif (l)\n\t\t\ttipc_link_fsm_evt(l, LINK_FAILOVER_END_EVT);\n\t}\n\n\t \n\tn->action_flags |= TIPC_NOTIFY_NODE_DOWN;\n\tn->peer_net = NULL;\n\tn->peer_hash_mix = 0;\n\t \n\tlist_for_each_entry_safe(conn, safe, conns, list) {\n\t\tskb = tipc_msg_create(TIPC_CRITICAL_IMPORTANCE, TIPC_CONN_MSG,\n\t\t\t\t      SHORT_H_SIZE, 0, tipc_own_addr(n->net),\n\t\t\t\t      conn->peer_node, conn->port,\n\t\t\t\t      conn->peer_port, TIPC_ERR_NO_NODE);\n\t\tif (likely(skb))\n\t\t\tskb_queue_tail(inputq, skb);\n\t\tlist_del(&conn->list);\n\t\tkfree(conn);\n\t}\n}\n\n \nint tipc_node_get_linkname(struct net *net, u32 bearer_id, u32 addr,\n\t\t\t   char *linkname, size_t len)\n{\n\tstruct tipc_link *link;\n\tint err = -EINVAL;\n\tstruct tipc_node *node = tipc_node_find(net, addr);\n\n\tif (!node)\n\t\treturn err;\n\n\tif (bearer_id >= MAX_BEARERS)\n\t\tgoto exit;\n\n\ttipc_node_read_lock(node);\n\tlink = node->links[bearer_id].link;\n\tif (link) {\n\t\tstrncpy(linkname, tipc_link_name(link), len);\n\t\terr = 0;\n\t}\n\ttipc_node_read_unlock(node);\nexit:\n\ttipc_node_put(node);\n\treturn err;\n}\n\n \nstatic int __tipc_nl_add_node(struct tipc_nl_msg *msg, struct tipc_node *node)\n{\n\tvoid *hdr;\n\tstruct nlattr *attrs;\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  NLM_F_MULTI, TIPC_NL_NODE_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_NODE);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\tif (nla_put_u32(msg->skb, TIPC_NLA_NODE_ADDR, node->addr))\n\t\tgoto attr_msg_full;\n\tif (node_is_up(node))\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_NODE_UP))\n\t\t\tgoto attr_msg_full;\n\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nstatic void tipc_lxc_xmit(struct net *peer_net, struct sk_buff_head *list)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb_peek(list));\n\tstruct sk_buff_head inputq;\n\n\tswitch (msg_user(hdr)) {\n\tcase TIPC_LOW_IMPORTANCE:\n\tcase TIPC_MEDIUM_IMPORTANCE:\n\tcase TIPC_HIGH_IMPORTANCE:\n\tcase TIPC_CRITICAL_IMPORTANCE:\n\t\tif (msg_connected(hdr) || msg_named(hdr) ||\n\t\t    msg_direct(hdr)) {\n\t\t\ttipc_loopback_trace(peer_net, list);\n\t\t\tspin_lock_init(&list->lock);\n\t\t\ttipc_sk_rcv(peer_net, list);\n\t\t\treturn;\n\t\t}\n\t\tif (msg_mcast(hdr)) {\n\t\t\ttipc_loopback_trace(peer_net, list);\n\t\t\tskb_queue_head_init(&inputq);\n\t\t\ttipc_sk_mcast_rcv(peer_net, list, &inputq);\n\t\t\t__skb_queue_purge(list);\n\t\t\tskb_queue_purge(&inputq);\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\tcase MSG_FRAGMENTER:\n\t\tif (tipc_msg_assemble(list)) {\n\t\t\ttipc_loopback_trace(peer_net, list);\n\t\t\tskb_queue_head_init(&inputq);\n\t\t\ttipc_sk_mcast_rcv(peer_net, list, &inputq);\n\t\t\t__skb_queue_purge(list);\n\t\t\tskb_queue_purge(&inputq);\n\t\t}\n\t\treturn;\n\tcase GROUP_PROTOCOL:\n\tcase CONN_MANAGER:\n\t\ttipc_loopback_trace(peer_net, list);\n\t\tspin_lock_init(&list->lock);\n\t\ttipc_sk_rcv(peer_net, list);\n\t\treturn;\n\tcase LINK_PROTOCOL:\n\tcase NAME_DISTRIBUTOR:\n\tcase TUNNEL_PROTOCOL:\n\tcase BCAST_PROTOCOL:\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nint tipc_node_xmit(struct net *net, struct sk_buff_head *list,\n\t\t   u32 dnode, int selector)\n{\n\tstruct tipc_link_entry *le = NULL;\n\tstruct tipc_node *n;\n\tstruct sk_buff_head xmitq;\n\tbool node_up = false;\n\tstruct net *peer_net;\n\tint bearer_id;\n\tint rc;\n\n\tif (in_own_node(net, dnode)) {\n\t\ttipc_loopback_trace(net, list);\n\t\tspin_lock_init(&list->lock);\n\t\ttipc_sk_rcv(net, list);\n\t\treturn 0;\n\t}\n\n\tn = tipc_node_find(net, dnode);\n\tif (unlikely(!n)) {\n\t\t__skb_queue_purge(list);\n\t\treturn -EHOSTUNREACH;\n\t}\n\n\trcu_read_lock();\n\ttipc_node_read_lock(n);\n\tnode_up = node_is_up(n);\n\tpeer_net = n->peer_net;\n\ttipc_node_read_unlock(n);\n\tif (node_up && peer_net && check_net(peer_net)) {\n\t\t \n\t\ttipc_lxc_xmit(peer_net, list);\n\t\tif (likely(skb_queue_empty(list))) {\n\t\t\trcu_read_unlock();\n\t\t\ttipc_node_put(n);\n\t\t\treturn 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\ttipc_node_read_lock(n);\n\tbearer_id = n->active_links[selector & 1];\n\tif (unlikely(bearer_id == INVALID_BEARER_ID)) {\n\t\ttipc_node_read_unlock(n);\n\t\ttipc_node_put(n);\n\t\t__skb_queue_purge(list);\n\t\treturn -EHOSTUNREACH;\n\t}\n\n\t__skb_queue_head_init(&xmitq);\n\tle = &n->links[bearer_id];\n\tspin_lock_bh(&le->lock);\n\trc = tipc_link_xmit(le->link, list, &xmitq);\n\tspin_unlock_bh(&le->lock);\n\ttipc_node_read_unlock(n);\n\n\tif (unlikely(rc == -ENOBUFS))\n\t\ttipc_node_link_down(n, bearer_id, false);\n\telse\n\t\ttipc_bearer_xmit(net, bearer_id, &xmitq, &le->maddr, n);\n\n\ttipc_node_put(n);\n\n\treturn rc;\n}\n\n \nint tipc_node_xmit_skb(struct net *net, struct sk_buff *skb, u32 dnode,\n\t\t       u32 selector)\n{\n\tstruct sk_buff_head head;\n\n\t__skb_queue_head_init(&head);\n\t__skb_queue_tail(&head, skb);\n\ttipc_node_xmit(net, &head, dnode, selector);\n\treturn 0;\n}\n\n \nint tipc_node_distr_xmit(struct net *net, struct sk_buff_head *xmitq)\n{\n\tstruct sk_buff *skb;\n\tu32 selector, dnode;\n\n\twhile ((skb = __skb_dequeue(xmitq))) {\n\t\tselector = msg_origport(buf_msg(skb));\n\t\tdnode = msg_destnode(buf_msg(skb));\n\t\ttipc_node_xmit_skb(net, skb, dnode, selector);\n\t}\n\treturn 0;\n}\n\nvoid tipc_node_broadcast(struct net *net, struct sk_buff *skb, int rc_dests)\n{\n\tstruct sk_buff_head xmitq;\n\tstruct sk_buff *txskb;\n\tstruct tipc_node *n;\n\tu16 dummy;\n\tu32 dst;\n\n\t \n\tif (!rc_dests && tipc_bcast_get_mode(net) != BCLINK_MODE_RCAST) {\n\t\t__skb_queue_head_init(&xmitq);\n\t\t__skb_queue_tail(&xmitq, skb);\n\t\ttipc_bcast_xmit(net, &xmitq, &dummy);\n\t\treturn;\n\t}\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, tipc_nodes(net), list) {\n\t\tdst = n->addr;\n\t\tif (in_own_node(net, dst))\n\t\t\tcontinue;\n\t\tif (!node_is_up(n))\n\t\t\tcontinue;\n\t\ttxskb = pskb_copy(skb, GFP_ATOMIC);\n\t\tif (!txskb)\n\t\t\tbreak;\n\t\tmsg_set_destnode(buf_msg(txskb), dst);\n\t\ttipc_node_xmit_skb(net, txskb, dst, 0);\n\t}\n\trcu_read_unlock();\n\tkfree_skb(skb);\n}\n\nstatic void tipc_node_mcast_rcv(struct tipc_node *n)\n{\n\tstruct tipc_bclink_entry *be = &n->bc_entry;\n\n\t \n\tspin_lock_bh(&be->inputq2.lock);\n\tspin_lock_bh(&be->inputq1.lock);\n\tskb_queue_splice_tail_init(&be->inputq1, &be->arrvq);\n\tspin_unlock_bh(&be->inputq1.lock);\n\tspin_unlock_bh(&be->inputq2.lock);\n\ttipc_sk_mcast_rcv(n->net, &be->arrvq, &be->inputq2);\n}\n\nstatic void tipc_node_bc_sync_rcv(struct tipc_node *n, struct tipc_msg *hdr,\n\t\t\t\t  int bearer_id, struct sk_buff_head *xmitq)\n{\n\tstruct tipc_link *ucl;\n\tint rc;\n\n\trc = tipc_bcast_sync_rcv(n->net, n->bc_entry.link, hdr, xmitq);\n\n\tif (rc & TIPC_LINK_DOWN_EVT) {\n\t\ttipc_node_reset_links(n);\n\t\treturn;\n\t}\n\n\tif (!(rc & TIPC_LINK_SND_STATE))\n\t\treturn;\n\n\t \n\tif (msg_probe(hdr))\n\t\treturn;\n\n\t \n\ttipc_node_read_lock(n);\n\tucl = n->links[bearer_id].link;\n\tif (ucl)\n\t\ttipc_link_build_state_msg(ucl, xmitq);\n\ttipc_node_read_unlock(n);\n}\n\n \nstatic void tipc_node_bc_rcv(struct net *net, struct sk_buff *skb, int bearer_id)\n{\n\tint rc;\n\tstruct sk_buff_head xmitq;\n\tstruct tipc_bclink_entry *be;\n\tstruct tipc_link_entry *le;\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tint usr = msg_user(hdr);\n\tu32 dnode = msg_destnode(hdr);\n\tstruct tipc_node *n;\n\n\t__skb_queue_head_init(&xmitq);\n\n\t \n\tif ((usr == BCAST_PROTOCOL) && (dnode != tipc_own_addr(net)))\n\t\tn = tipc_node_find(net, dnode);\n\telse\n\t\tn = tipc_node_find(net, msg_prevnode(hdr));\n\tif (!n) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tbe = &n->bc_entry;\n\tle = &n->links[bearer_id];\n\n\trc = tipc_bcast_rcv(net, be->link, skb);\n\n\t \n\tif (rc & TIPC_LINK_SND_STATE) {\n\t\ttipc_node_read_lock(n);\n\t\ttipc_link_build_state_msg(le->link, &xmitq);\n\t\ttipc_node_read_unlock(n);\n\t}\n\n\tif (!skb_queue_empty(&xmitq))\n\t\ttipc_bearer_xmit(net, bearer_id, &xmitq, &le->maddr, n);\n\n\tif (!skb_queue_empty(&be->inputq1))\n\t\ttipc_node_mcast_rcv(n);\n\n\t \n\tif (!skb_queue_empty(&n->bc_entry.namedq))\n\t\ttipc_named_rcv(net, &n->bc_entry.namedq,\n\t\t\t       &n->bc_entry.named_rcv_nxt,\n\t\t\t       &n->bc_entry.named_open);\n\n\t \n\tif (rc & TIPC_LINK_DOWN_EVT)\n\t\ttipc_node_reset_links(n);\n\n\ttipc_node_put(n);\n}\n\n \nstatic bool tipc_node_check_state(struct tipc_node *n, struct sk_buff *skb,\n\t\t\t\t  int bearer_id, struct sk_buff_head *xmitq)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tint usr = msg_user(hdr);\n\tint mtyp = msg_type(hdr);\n\tu16 oseqno = msg_seqno(hdr);\n\tu16 exp_pkts = msg_msgcnt(hdr);\n\tu16 rcv_nxt, syncpt, dlv_nxt, inputq_len;\n\tint state = n->state;\n\tstruct tipc_link *l, *tnl, *pl = NULL;\n\tstruct tipc_media_addr *maddr;\n\tint pb_id;\n\n\tif (trace_tipc_node_check_state_enabled()) {\n\t\ttrace_tipc_skb_dump(skb, false, \"skb for node state check\");\n\t\ttrace_tipc_node_check_state(n, true, \" \");\n\t}\n\tl = n->links[bearer_id].link;\n\tif (!l)\n\t\treturn false;\n\trcv_nxt = tipc_link_rcv_nxt(l);\n\n\n\tif (likely((state == SELF_UP_PEER_UP) && (usr != TUNNEL_PROTOCOL)))\n\t\treturn true;\n\n\t \n\tfor (pb_id = 0; pb_id < MAX_BEARERS; pb_id++) {\n\t\tif ((pb_id != bearer_id) && n->links[pb_id].link) {\n\t\t\tpl = n->links[pb_id].link;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!tipc_link_validate_msg(l, hdr)) {\n\t\ttrace_tipc_skb_dump(skb, false, \"PROTO invalid (2)!\");\n\t\ttrace_tipc_link_dump(l, TIPC_DUMP_NONE, \"PROTO invalid (2)!\");\n\t\treturn false;\n\t}\n\n\t \n\tif (state == SELF_UP_PEER_COMING) {\n\t\tif (!tipc_link_is_up(l))\n\t\t\treturn true;\n\t\tif (!msg_peer_link_is_up(hdr))\n\t\t\treturn true;\n\t\ttipc_node_fsm_evt(n, PEER_ESTABL_CONTACT_EVT);\n\t}\n\n\tif (state == SELF_DOWN_PEER_LEAVING) {\n\t\tif (msg_peer_node_is_up(hdr))\n\t\t\treturn false;\n\t\ttipc_node_fsm_evt(n, PEER_LOST_CONTACT_EVT);\n\t\treturn true;\n\t}\n\n\tif (state == SELF_LEAVING_PEER_DOWN)\n\t\treturn false;\n\n\t \n\tif ((usr != LINK_PROTOCOL) && less(oseqno, rcv_nxt))\n\t\treturn true;\n\n\t \n\tif ((usr == TUNNEL_PROTOCOL) && (mtyp == FAILOVER_MSG)) {\n\t\tsyncpt = oseqno + exp_pkts - 1;\n\t\tif (pl && !tipc_link_is_reset(pl)) {\n\t\t\t__tipc_node_link_down(n, &pb_id, xmitq, &maddr);\n\t\t\ttrace_tipc_node_link_down(n, true,\n\t\t\t\t\t\t  \"node link down <- failover!\");\n\t\t\ttipc_skb_queue_splice_tail_init(tipc_link_inputq(pl),\n\t\t\t\t\t\t\ttipc_link_inputq(l));\n\t\t}\n\n\t\t \n\t\tif (n->state != NODE_FAILINGOVER)\n\t\t\ttipc_node_link_failover(n, pl, l, xmitq);\n\n\t\t \n\t\tif (less(syncpt, n->sync_point))\n\t\t\tn->sync_point = syncpt;\n\t}\n\n\t \n\tif ((n->state == NODE_FAILINGOVER) && tipc_link_is_up(l)) {\n\t\tif (!more(rcv_nxt, n->sync_point))\n\t\t\treturn true;\n\t\ttipc_node_fsm_evt(n, NODE_FAILOVER_END_EVT);\n\t\tif (pl)\n\t\t\ttipc_link_fsm_evt(pl, LINK_FAILOVER_END_EVT);\n\t\treturn true;\n\t}\n\n\t \n\tif (!pl || !tipc_link_is_up(pl))\n\t\treturn true;\n\n\t \n\tif ((usr == TUNNEL_PROTOCOL) && (mtyp == SYNCH_MSG) && (oseqno == 1)) {\n\t\tif (n->capabilities & TIPC_TUNNEL_ENHANCED)\n\t\t\tsyncpt = msg_syncpt(hdr);\n\t\telse\n\t\t\tsyncpt = msg_seqno(msg_inner_hdr(hdr)) + exp_pkts - 1;\n\t\tif (!tipc_link_is_up(l))\n\t\t\t__tipc_node_link_up(n, bearer_id, xmitq);\n\t\tif (n->state == SELF_UP_PEER_UP) {\n\t\t\tn->sync_point = syncpt;\n\t\t\ttipc_link_fsm_evt(l, LINK_SYNCH_BEGIN_EVT);\n\t\t\ttipc_node_fsm_evt(n, NODE_SYNCH_BEGIN_EVT);\n\t\t}\n\t}\n\n\t \n\tif (n->state == NODE_SYNCHING) {\n\t\tif (tipc_link_is_synching(l)) {\n\t\t\ttnl = l;\n\t\t} else {\n\t\t\ttnl = pl;\n\t\t\tpl = l;\n\t\t}\n\t\tinputq_len = skb_queue_len(tipc_link_inputq(pl));\n\t\tdlv_nxt = tipc_link_rcv_nxt(pl) - inputq_len;\n\t\tif (more(dlv_nxt, n->sync_point)) {\n\t\t\ttipc_link_fsm_evt(tnl, LINK_SYNCH_END_EVT);\n\t\t\ttipc_node_fsm_evt(n, NODE_SYNCH_END_EVT);\n\t\t\treturn true;\n\t\t}\n\t\tif (l == pl)\n\t\t\treturn true;\n\t\tif ((usr == TUNNEL_PROTOCOL) && (mtyp == SYNCH_MSG))\n\t\t\treturn true;\n\t\tif (usr == LINK_PROTOCOL)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nvoid tipc_rcv(struct net *net, struct sk_buff *skb, struct tipc_bearer *b)\n{\n\tstruct sk_buff_head xmitq;\n\tstruct tipc_link_entry *le;\n\tstruct tipc_msg *hdr;\n\tstruct tipc_node *n;\n\tint bearer_id = b->identity;\n\tu32 self = tipc_own_addr(net);\n\tint usr, rc = 0;\n\tu16 bc_ack;\n#ifdef CONFIG_TIPC_CRYPTO\n\tstruct tipc_ehdr *ehdr;\n\n\t \n\tif (TIPC_SKB_CB(skb)->decrypted || !tipc_ehdr_validate(skb))\n\t\tgoto rcv;\n\n\tehdr = (struct tipc_ehdr *)skb->data;\n\tif (likely(ehdr->user != LINK_CONFIG)) {\n\t\tn = tipc_node_find(net, ntohl(ehdr->addr));\n\t\tif (unlikely(!n))\n\t\t\tgoto discard;\n\t} else {\n\t\tn = tipc_node_find_by_id(net, ehdr->id);\n\t}\n\ttipc_crypto_rcv(net, (n) ? n->crypto_rx : NULL, &skb, b);\n\tif (!skb)\n\t\treturn;\n\nrcv:\n#endif\n\t \n\tif (unlikely(!tipc_msg_validate(&skb)))\n\t\tgoto discard;\n\t__skb_queue_head_init(&xmitq);\n\thdr = buf_msg(skb);\n\tusr = msg_user(hdr);\n\tbc_ack = msg_bcast_ack(hdr);\n\n\t \n\tif (unlikely(msg_non_seq(hdr))) {\n\t\tif (unlikely(usr == LINK_CONFIG))\n\t\t\treturn tipc_disc_rcv(net, skb, b);\n\t\telse\n\t\t\treturn tipc_node_bc_rcv(net, skb, bearer_id);\n\t}\n\n\t \n\tif (unlikely(!msg_short(hdr) && (msg_destnode(hdr) != self)))\n\t\tgoto discard;\n\n\t \n\tn = tipc_node_find(net, msg_prevnode(hdr));\n\tif (unlikely(!n))\n\t\tgoto discard;\n\tle = &n->links[bearer_id];\n\n\t \n\tif (unlikely(usr == LINK_PROTOCOL)) {\n\t\tif (unlikely(skb_linearize(skb))) {\n\t\t\ttipc_node_put(n);\n\t\t\tgoto discard;\n\t\t}\n\t\thdr = buf_msg(skb);\n\t\ttipc_node_bc_sync_rcv(n, hdr, bearer_id, &xmitq);\n\t} else if (unlikely(tipc_link_acked(n->bc_entry.link) != bc_ack)) {\n\t\ttipc_bcast_ack_rcv(net, n->bc_entry.link, hdr);\n\t}\n\n\t \n\ttipc_node_read_lock(n);\n\tif (likely((n->state == SELF_UP_PEER_UP) && (usr != TUNNEL_PROTOCOL))) {\n\t\tspin_lock_bh(&le->lock);\n\t\tif (le->link) {\n\t\t\trc = tipc_link_rcv(le->link, skb, &xmitq);\n\t\t\tskb = NULL;\n\t\t}\n\t\tspin_unlock_bh(&le->lock);\n\t}\n\ttipc_node_read_unlock(n);\n\n\t \n\tif (unlikely(skb)) {\n\t\tif (unlikely(skb_linearize(skb)))\n\t\t\tgoto out_node_put;\n\t\ttipc_node_write_lock(n);\n\t\tif (tipc_node_check_state(n, skb, bearer_id, &xmitq)) {\n\t\t\tif (le->link) {\n\t\t\t\trc = tipc_link_rcv(le->link, skb, &xmitq);\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t}\n\t\ttipc_node_write_unlock(n);\n\t}\n\n\tif (unlikely(rc & TIPC_LINK_UP_EVT))\n\t\ttipc_node_link_up(n, bearer_id, &xmitq);\n\n\tif (unlikely(rc & TIPC_LINK_DOWN_EVT))\n\t\ttipc_node_link_down(n, bearer_id, false);\n\n\tif (unlikely(!skb_queue_empty(&n->bc_entry.namedq)))\n\t\ttipc_named_rcv(net, &n->bc_entry.namedq,\n\t\t\t       &n->bc_entry.named_rcv_nxt,\n\t\t\t       &n->bc_entry.named_open);\n\n\tif (unlikely(!skb_queue_empty(&n->bc_entry.inputq1)))\n\t\ttipc_node_mcast_rcv(n);\n\n\tif (!skb_queue_empty(&le->inputq))\n\t\ttipc_sk_rcv(net, &le->inputq);\n\n\tif (!skb_queue_empty(&xmitq))\n\t\ttipc_bearer_xmit(net, bearer_id, &xmitq, &le->maddr, n);\n\nout_node_put:\n\ttipc_node_put(n);\ndiscard:\n\tkfree_skb(skb);\n}\n\nvoid tipc_node_apply_property(struct net *net, struct tipc_bearer *b,\n\t\t\t      int prop)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tint bearer_id = b->identity;\n\tstruct sk_buff_head xmitq;\n\tstruct tipc_link_entry *e;\n\tstruct tipc_node *n;\n\n\t__skb_queue_head_init(&xmitq);\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\ttipc_node_write_lock(n);\n\t\te = &n->links[bearer_id];\n\t\tif (e->link) {\n\t\t\tif (prop == TIPC_NLA_PROP_TOL)\n\t\t\t\ttipc_link_set_tolerance(e->link, b->tolerance,\n\t\t\t\t\t\t\t&xmitq);\n\t\t\telse if (prop == TIPC_NLA_PROP_MTU)\n\t\t\t\ttipc_link_set_mtu(e->link, b->mtu);\n\n\t\t\t \n\t\t\te->mtu = tipc_link_mss(e->link);\n\t\t}\n\n\t\ttipc_node_write_unlock(n);\n\t\ttipc_bearer_xmit(net, bearer_id, &xmitq, &e->maddr, NULL);\n\t}\n\n\trcu_read_unlock();\n}\n\nint tipc_nl_peer_rm(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tstruct nlattr *attrs[TIPC_NLA_NET_MAX + 1];\n\tstruct tipc_node *peer, *temp_node;\n\tu8 node_id[NODE_ID_LEN];\n\tu64 *w0 = (u64 *)&node_id[0];\n\tu64 *w1 = (u64 *)&node_id[8];\n\tu32 addr;\n\tint err;\n\n\t \n\tif (!info->attrs[TIPC_NLA_NET])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_NET_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_NET],\n\t\t\t\t\t  tipc_nl_net_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (attrs[TIPC_NLA_NET_ADDR]) {\n\t\taddr = nla_get_u32(attrs[TIPC_NLA_NET_ADDR]);\n\t\tif (!addr)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[TIPC_NLA_NET_NODEID]) {\n\t\tif (!attrs[TIPC_NLA_NET_NODEID_W1])\n\t\t\treturn -EINVAL;\n\t\t*w0 = nla_get_u64(attrs[TIPC_NLA_NET_NODEID]);\n\t\t*w1 = nla_get_u64(attrs[TIPC_NLA_NET_NODEID_W1]);\n\t\taddr = hash128to32(node_id);\n\t}\n\n\tif (in_own_node(net, addr))\n\t\treturn -ENOTSUPP;\n\n\tspin_lock_bh(&tn->node_list_lock);\n\tpeer = tipc_node_find(net, addr);\n\tif (!peer) {\n\t\tspin_unlock_bh(&tn->node_list_lock);\n\t\treturn -ENXIO;\n\t}\n\n\ttipc_node_write_lock(peer);\n\tif (peer->state != SELF_DOWN_PEER_DOWN &&\n\t    peer->state != SELF_DOWN_PEER_LEAVING) {\n\t\ttipc_node_write_unlock(peer);\n\t\terr = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\ttipc_node_clear_links(peer);\n\ttipc_node_write_unlock(peer);\n\ttipc_node_delete(peer);\n\n\t \n\ttn->capabilities = TIPC_NODE_CAPABILITIES;\n\tlist_for_each_entry_rcu(temp_node, &tn->node_list, list) {\n\t\ttn->capabilities &= temp_node->capabilities;\n\t}\n\ttipc_bcast_toggle_rcast(net, (tn->capabilities & TIPC_BCAST_RCAST));\n\terr = 0;\nerr_out:\n\ttipc_node_put(peer);\n\tspin_unlock_bh(&tn->node_list_lock);\n\n\treturn err;\n}\n\nint tipc_nl_node_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tint done = cb->args[0];\n\tint last_addr = cb->args[1];\n\tstruct tipc_node *node;\n\tstruct tipc_nl_msg msg;\n\n\tif (done)\n\t\treturn 0;\n\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\n\trcu_read_lock();\n\tif (last_addr) {\n\t\tnode = tipc_node_find(net, last_addr);\n\t\tif (!node) {\n\t\t\trcu_read_unlock();\n\t\t\t \n\t\t\tcb->prev_seq = 1;\n\t\t\treturn -EPIPE;\n\t\t}\n\t\ttipc_node_put(node);\n\t}\n\n\tlist_for_each_entry_rcu(node, &tn->node_list, list) {\n\t\tif (node->preliminary)\n\t\t\tcontinue;\n\t\tif (last_addr) {\n\t\t\tif (node->addr == last_addr)\n\t\t\t\tlast_addr = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttipc_node_read_lock(node);\n\t\terr = __tipc_nl_add_node(&msg, node);\n\t\tif (err) {\n\t\t\tlast_addr = node->addr;\n\t\t\ttipc_node_read_unlock(node);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttipc_node_read_unlock(node);\n\t}\n\tdone = 1;\nout:\n\tcb->args[0] = done;\n\tcb->args[1] = last_addr;\n\trcu_read_unlock();\n\n\treturn skb->len;\n}\n\n \nstatic struct tipc_node *tipc_node_find_by_name(struct net *net,\n\t\t\t\t\t\tconst char *link_name,\n\t\t\t\t\t\tunsigned int *bearer_id)\n{\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tstruct tipc_link *l;\n\tstruct tipc_node *n;\n\tstruct tipc_node *found_node = NULL;\n\tint i;\n\n\t*bearer_id = 0;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\ttipc_node_read_lock(n);\n\t\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\t\tl = n->links[i].link;\n\t\t\tif (l && !strcmp(tipc_link_name(l), link_name)) {\n\t\t\t\t*bearer_id = i;\n\t\t\t\tfound_node = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttipc_node_read_unlock(n);\n\t\tif (found_node)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn found_node;\n}\n\nint tipc_nl_node_set_link(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\tint res = 0;\n\tint bearer_id;\n\tchar *name;\n\tstruct tipc_link *link;\n\tstruct tipc_node *node;\n\tstruct sk_buff_head xmitq;\n\tstruct nlattr *attrs[TIPC_NLA_LINK_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\n\t__skb_queue_head_init(&xmitq);\n\n\tif (!info->attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_LINK_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_LINK],\n\t\t\t\t\t  tipc_nl_link_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!attrs[TIPC_NLA_LINK_NAME])\n\t\treturn -EINVAL;\n\n\tname = nla_data(attrs[TIPC_NLA_LINK_NAME]);\n\n\tif (strcmp(name, tipc_bclink_name) == 0)\n\t\treturn tipc_nl_bc_link_set(net, attrs);\n\n\tnode = tipc_node_find_by_name(net, name, &bearer_id);\n\tif (!node)\n\t\treturn -EINVAL;\n\n\ttipc_node_read_lock(node);\n\n\tlink = node->links[bearer_id].link;\n\tif (!link) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (attrs[TIPC_NLA_LINK_PROP]) {\n\t\tstruct nlattr *props[TIPC_NLA_PROP_MAX + 1];\n\n\t\terr = tipc_nl_parse_link_prop(attrs[TIPC_NLA_LINK_PROP], props);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (props[TIPC_NLA_PROP_TOL]) {\n\t\t\tu32 tol;\n\n\t\t\ttol = nla_get_u32(props[TIPC_NLA_PROP_TOL]);\n\t\t\ttipc_link_set_tolerance(link, tol, &xmitq);\n\t\t}\n\t\tif (props[TIPC_NLA_PROP_PRIO]) {\n\t\t\tu32 prio;\n\n\t\t\tprio = nla_get_u32(props[TIPC_NLA_PROP_PRIO]);\n\t\t\ttipc_link_set_prio(link, prio, &xmitq);\n\t\t}\n\t\tif (props[TIPC_NLA_PROP_WIN]) {\n\t\t\tu32 max_win;\n\n\t\t\tmax_win = nla_get_u32(props[TIPC_NLA_PROP_WIN]);\n\t\t\ttipc_link_set_queue_limits(link,\n\t\t\t\t\t\t   tipc_link_min_win(link),\n\t\t\t\t\t\t   max_win);\n\t\t}\n\t}\n\nout:\n\ttipc_node_read_unlock(node);\n\ttipc_bearer_xmit(net, bearer_id, &xmitq, &node->links[bearer_id].maddr,\n\t\t\t NULL);\n\treturn res;\n}\n\nint tipc_nl_node_get_link(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct nlattr *attrs[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_nl_msg msg;\n\tchar *name;\n\tint err;\n\n\tmsg.portid = info->snd_portid;\n\tmsg.seq = info->snd_seq;\n\n\tif (!info->attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_LINK_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_LINK],\n\t\t\t\t\t  tipc_nl_link_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!attrs[TIPC_NLA_LINK_NAME])\n\t\treturn -EINVAL;\n\n\tname = nla_data(attrs[TIPC_NLA_LINK_NAME]);\n\n\tmsg.skb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!msg.skb)\n\t\treturn -ENOMEM;\n\n\tif (strcmp(name, tipc_bclink_name) == 0) {\n\t\terr = tipc_nl_add_bc_link(net, &msg, tipc_net(net)->bcl);\n\t\tif (err)\n\t\t\tgoto err_free;\n\t} else {\n\t\tint bearer_id;\n\t\tstruct tipc_node *node;\n\t\tstruct tipc_link *link;\n\n\t\tnode = tipc_node_find_by_name(net, name, &bearer_id);\n\t\tif (!node) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\ttipc_node_read_lock(node);\n\t\tlink = node->links[bearer_id].link;\n\t\tif (!link) {\n\t\t\ttipc_node_read_unlock(node);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\terr = __tipc_nl_add_link(net, &msg, link, 0);\n\t\ttipc_node_read_unlock(node);\n\t\tif (err)\n\t\t\tgoto err_free;\n\t}\n\n\treturn genlmsg_reply(msg.skb, info);\n\nerr_free:\n\tnlmsg_free(msg.skb);\n\treturn err;\n}\n\nint tipc_nl_node_reset_link_stats(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\tchar *link_name;\n\tunsigned int bearer_id;\n\tstruct tipc_link *link;\n\tstruct tipc_node *node;\n\tstruct nlattr *attrs[TIPC_NLA_LINK_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_link_entry *le;\n\n\tif (!info->attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_LINK_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_LINK],\n\t\t\t\t\t  tipc_nl_link_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!attrs[TIPC_NLA_LINK_NAME])\n\t\treturn -EINVAL;\n\n\tlink_name = nla_data(attrs[TIPC_NLA_LINK_NAME]);\n\n\terr = -EINVAL;\n\tif (!strcmp(link_name, tipc_bclink_name)) {\n\t\terr = tipc_bclink_reset_stats(net, tipc_bc_sndlink(net));\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn 0;\n\t} else if (strstr(link_name, tipc_bclink_name)) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(node, &tn->node_list, list) {\n\t\t\ttipc_node_read_lock(node);\n\t\t\tlink = node->bc_entry.link;\n\t\t\tif (link && !strcmp(link_name, tipc_link_name(link))) {\n\t\t\t\terr = tipc_bclink_reset_stats(net, link);\n\t\t\t\ttipc_node_read_unlock(node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttipc_node_read_unlock(node);\n\t\t}\n\t\trcu_read_unlock();\n\t\treturn err;\n\t}\n\n\tnode = tipc_node_find_by_name(net, link_name, &bearer_id);\n\tif (!node)\n\t\treturn -EINVAL;\n\n\tle = &node->links[bearer_id];\n\ttipc_node_read_lock(node);\n\tspin_lock_bh(&le->lock);\n\tlink = node->links[bearer_id].link;\n\tif (!link) {\n\t\tspin_unlock_bh(&le->lock);\n\t\ttipc_node_read_unlock(node);\n\t\treturn -EINVAL;\n\t}\n\ttipc_link_reset_stats(link);\n\tspin_unlock_bh(&le->lock);\n\ttipc_node_read_unlock(node);\n\treturn 0;\n}\n\n \nstatic int __tipc_nl_add_node_links(struct net *net, struct tipc_nl_msg *msg,\n\t\t\t\t    struct tipc_node *node, u32 *prev_link,\n\t\t\t\t    bool bc_link)\n{\n\tu32 i;\n\tint err;\n\n\tfor (i = *prev_link; i < MAX_BEARERS; i++) {\n\t\t*prev_link = i;\n\n\t\tif (!node->links[i].link)\n\t\t\tcontinue;\n\n\t\terr = __tipc_nl_add_link(net, msg,\n\t\t\t\t\t node->links[i].link, NLM_F_MULTI);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (bc_link) {\n\t\t*prev_link = i;\n\t\terr = tipc_nl_add_bc_link(net, msg, node->bc_entry.link);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t*prev_link = 0;\n\n\treturn 0;\n}\n\nint tipc_nl_node_dump_link(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr **attrs = genl_dumpit_info(cb)->info.attrs;\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tstruct tipc_node *node;\n\tstruct tipc_nl_msg msg;\n\tu32 prev_node = cb->args[0];\n\tu32 prev_link = cb->args[1];\n\tint done = cb->args[2];\n\tbool bc_link = cb->args[3];\n\tint err;\n\n\tif (done)\n\t\treturn 0;\n\n\tif (!prev_node) {\n\t\t \n\t\tif (attrs && attrs[TIPC_NLA_LINK]) {\n\t\t\terr = nla_parse_nested_deprecated(link,\n\t\t\t\t\t\t\t  TIPC_NLA_LINK_MAX,\n\t\t\t\t\t\t\t  attrs[TIPC_NLA_LINK],\n\t\t\t\t\t\t\t  tipc_nl_link_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (unlikely(err))\n\t\t\t\treturn err;\n\t\t\tif (unlikely(!link[TIPC_NLA_LINK_BROADCAST]))\n\t\t\t\treturn -EINVAL;\n\t\t\tbc_link = true;\n\t\t}\n\t}\n\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\n\trcu_read_lock();\n\tif (prev_node) {\n\t\tnode = tipc_node_find(net, prev_node);\n\t\tif (!node) {\n\t\t\t \n\t\t\tcb->prev_seq = 1;\n\t\t\tgoto out;\n\t\t}\n\t\ttipc_node_put(node);\n\n\t\tlist_for_each_entry_continue_rcu(node, &tn->node_list,\n\t\t\t\t\t\t list) {\n\t\t\ttipc_node_read_lock(node);\n\t\t\terr = __tipc_nl_add_node_links(net, &msg, node,\n\t\t\t\t\t\t       &prev_link, bc_link);\n\t\t\ttipc_node_read_unlock(node);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tprev_node = node->addr;\n\t\t}\n\t} else {\n\t\terr = tipc_nl_add_bc_link(net, &msg, tn->bcl);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tlist_for_each_entry_rcu(node, &tn->node_list, list) {\n\t\t\ttipc_node_read_lock(node);\n\t\t\terr = __tipc_nl_add_node_links(net, &msg, node,\n\t\t\t\t\t\t       &prev_link, bc_link);\n\t\t\ttipc_node_read_unlock(node);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tprev_node = node->addr;\n\t\t}\n\t}\n\tdone = 1;\nout:\n\trcu_read_unlock();\n\n\tcb->args[0] = prev_node;\n\tcb->args[1] = prev_link;\n\tcb->args[2] = done;\n\tcb->args[3] = bc_link;\n\n\treturn skb->len;\n}\n\nint tipc_nl_node_set_monitor(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attrs[TIPC_NLA_MON_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\tint err;\n\n\tif (!info->attrs[TIPC_NLA_MON])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, TIPC_NLA_MON_MAX,\n\t\t\t\t\t  info->attrs[TIPC_NLA_MON],\n\t\t\t\t\t  tipc_nl_monitor_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (attrs[TIPC_NLA_MON_ACTIVATION_THRESHOLD]) {\n\t\tu32 val;\n\n\t\tval = nla_get_u32(attrs[TIPC_NLA_MON_ACTIVATION_THRESHOLD]);\n\t\terr = tipc_nl_monitor_set_threshold(net, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __tipc_nl_add_monitor_prop(struct net *net, struct tipc_nl_msg *msg)\n{\n\tstruct nlattr *attrs;\n\tvoid *hdr;\n\tu32 val;\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  0, TIPC_NL_MON_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_MON);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\tval = tipc_nl_monitor_get_threshold(net);\n\n\tif (nla_put_u32(msg->skb, TIPC_NLA_MON_ACTIVATION_THRESHOLD, val))\n\t\tgoto attr_msg_full;\n\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nint tipc_nl_node_get_monitor(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_nl_msg msg;\n\tint err;\n\n\tmsg.skb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!msg.skb)\n\t\treturn -ENOMEM;\n\tmsg.portid = info->snd_portid;\n\tmsg.seq = info->snd_seq;\n\n\terr = __tipc_nl_add_monitor_prop(net, &msg);\n\tif (err) {\n\t\tnlmsg_free(msg.skb);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg.skb, info);\n}\n\nint tipc_nl_node_dump_monitor(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tu32 prev_bearer = cb->args[0];\n\tstruct tipc_nl_msg msg;\n\tint bearer_id;\n\tint err;\n\n\tif (prev_bearer == MAX_BEARERS)\n\t\treturn 0;\n\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\n\trtnl_lock();\n\tfor (bearer_id = prev_bearer; bearer_id < MAX_BEARERS; bearer_id++) {\n\t\terr = __tipc_nl_add_monitor(net, &msg, bearer_id);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\trtnl_unlock();\n\tcb->args[0] = bearer_id;\n\n\treturn skb->len;\n}\n\nint tipc_nl_node_dump_monitor_peer(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tu32 prev_node = cb->args[1];\n\tu32 bearer_id = cb->args[2];\n\tint done = cb->args[0];\n\tstruct tipc_nl_msg msg;\n\tint err;\n\n\tif (!prev_node) {\n\t\tstruct nlattr **attrs = genl_dumpit_info(cb)->info.attrs;\n\t\tstruct nlattr *mon[TIPC_NLA_MON_MAX + 1];\n\n\t\tif (!attrs[TIPC_NLA_MON])\n\t\t\treturn -EINVAL;\n\n\t\terr = nla_parse_nested_deprecated(mon, TIPC_NLA_MON_MAX,\n\t\t\t\t\t\t  attrs[TIPC_NLA_MON],\n\t\t\t\t\t\t  tipc_nl_monitor_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!mon[TIPC_NLA_MON_REF])\n\t\t\treturn -EINVAL;\n\n\t\tbearer_id = nla_get_u32(mon[TIPC_NLA_MON_REF]);\n\n\t\tif (bearer_id >= MAX_BEARERS)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (done)\n\t\treturn 0;\n\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\n\trtnl_lock();\n\terr = tipc_nl_add_monitor_peer(net, &msg, bearer_id, &prev_node);\n\tif (!err)\n\t\tdone = 1;\n\n\trtnl_unlock();\n\tcb->args[0] = done;\n\tcb->args[1] = prev_node;\n\tcb->args[2] = bearer_id;\n\n\treturn skb->len;\n}\n\n#ifdef CONFIG_TIPC_CRYPTO\nstatic int tipc_nl_retrieve_key(struct nlattr **attrs,\n\t\t\t\tstruct tipc_aead_key **pkey)\n{\n\tstruct nlattr *attr = attrs[TIPC_NLA_NODE_KEY];\n\tstruct tipc_aead_key *key;\n\n\tif (!attr)\n\t\treturn -ENODATA;\n\n\tif (nla_len(attr) < sizeof(*key))\n\t\treturn -EINVAL;\n\tkey = (struct tipc_aead_key *)nla_data(attr);\n\tif (key->keylen > TIPC_AEAD_KEYLEN_MAX ||\n\t    nla_len(attr) < tipc_aead_key_size(key))\n\t\treturn -EINVAL;\n\n\t*pkey = key;\n\treturn 0;\n}\n\nstatic int tipc_nl_retrieve_nodeid(struct nlattr **attrs, u8 **node_id)\n{\n\tstruct nlattr *attr = attrs[TIPC_NLA_NODE_ID];\n\n\tif (!attr)\n\t\treturn -ENODATA;\n\n\tif (nla_len(attr) < TIPC_NODEID_LEN)\n\t\treturn -EINVAL;\n\n\t*node_id = (u8 *)nla_data(attr);\n\treturn 0;\n}\n\nstatic int tipc_nl_retrieve_rekeying(struct nlattr **attrs, u32 *intv)\n{\n\tstruct nlattr *attr = attrs[TIPC_NLA_NODE_REKEYING];\n\n\tif (!attr)\n\t\treturn -ENODATA;\n\n\t*intv = nla_get_u32(attr);\n\treturn 0;\n}\n\nstatic int __tipc_nl_node_set_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attrs[TIPC_NLA_NODE_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_crypto *tx = tipc_net(net)->crypto_tx, *c = tx;\n\tstruct tipc_node *n = NULL;\n\tstruct tipc_aead_key *ukey;\n\tbool rekeying = true, master_key = false;\n\tu8 *id, *own_id, mode;\n\tu32 intv = 0;\n\tint rc = 0;\n\n\tif (!info->attrs[TIPC_NLA_NODE])\n\t\treturn -EINVAL;\n\n\trc = nla_parse_nested(attrs, TIPC_NLA_NODE_MAX,\n\t\t\t      info->attrs[TIPC_NLA_NODE],\n\t\t\t      tipc_nl_node_policy, info->extack);\n\tif (rc)\n\t\treturn rc;\n\n\town_id = tipc_own_id(net);\n\tif (!own_id) {\n\t\tGENL_SET_ERR_MSG(info, \"not found own node identity (set id?)\");\n\t\treturn -EPERM;\n\t}\n\n\trc = tipc_nl_retrieve_rekeying(attrs, &intv);\n\tif (rc == -ENODATA)\n\t\trekeying = false;\n\n\trc = tipc_nl_retrieve_key(attrs, &ukey);\n\tif (rc == -ENODATA && rekeying)\n\t\tgoto rekeying;\n\telse if (rc)\n\t\treturn rc;\n\n\trc = tipc_aead_key_validate(ukey, info);\n\tif (rc)\n\t\treturn rc;\n\n\trc = tipc_nl_retrieve_nodeid(attrs, &id);\n\tswitch (rc) {\n\tcase -ENODATA:\n\t\tmode = CLUSTER_KEY;\n\t\tmaster_key = !!(attrs[TIPC_NLA_NODE_KEY_MASTER]);\n\t\tbreak;\n\tcase 0:\n\t\tmode = PER_NODE_KEY;\n\t\tif (memcmp(id, own_id, NODE_ID_LEN)) {\n\t\t\tn = tipc_node_find_by_id(net, id) ?:\n\t\t\t\ttipc_node_create(net, 0, id, 0xffffu, 0, true);\n\t\t\tif (unlikely(!n))\n\t\t\t\treturn -ENOMEM;\n\t\t\tc = n->crypto_rx;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn rc;\n\t}\n\n\t \n\trc = tipc_crypto_key_init(c, ukey, mode, master_key);\n\tif (n)\n\t\ttipc_node_put(n);\n\n\tif (unlikely(rc < 0)) {\n\t\tGENL_SET_ERR_MSG(info, \"unable to initiate or attach new key\");\n\t\treturn rc;\n\t} else if (c == tx) {\n\t\t \n\t\tif (!master_key && tipc_crypto_key_distr(tx, rc, NULL))\n\t\t\tGENL_SET_ERR_MSG(info, \"failed to replicate new key\");\nrekeying:\n\t\t \n\t\ttipc_crypto_rekeying_sched(tx, rekeying, intv);\n\t}\n\n\treturn 0;\n}\n\nint tipc_nl_node_set_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __tipc_nl_node_set_key(skb, info);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic int __tipc_nl_node_flush_key(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_node *n;\n\n\ttipc_crypto_key_flush(tn->crypto_tx);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, &tn->node_list, list)\n\t\ttipc_crypto_key_flush(n->crypto_rx);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nint tipc_nl_node_flush_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __tipc_nl_node_flush_key(skb, info);\n\trtnl_unlock();\n\n\treturn err;\n}\n#endif\n\n \nint tipc_node_dump(struct tipc_node *n, bool more, char *buf)\n{\n\tint i = 0;\n\tsize_t sz = (more) ? NODE_LMAX : NODE_LMIN;\n\n\tif (!n) {\n\t\ti += scnprintf(buf, sz, \"node data: (null)\\n\");\n\t\treturn i;\n\t}\n\n\ti += scnprintf(buf, sz, \"node data: %x\", n->addr);\n\ti += scnprintf(buf + i, sz - i, \" %x\", n->state);\n\ti += scnprintf(buf + i, sz - i, \" %d\", n->active_links[0]);\n\ti += scnprintf(buf + i, sz - i, \" %d\", n->active_links[1]);\n\ti += scnprintf(buf + i, sz - i, \" %x\", n->action_flags);\n\ti += scnprintf(buf + i, sz - i, \" %u\", n->failover_sent);\n\ti += scnprintf(buf + i, sz - i, \" %u\", n->sync_point);\n\ti += scnprintf(buf + i, sz - i, \" %d\", n->link_cnt);\n\ti += scnprintf(buf + i, sz - i, \" %u\", n->working_links);\n\ti += scnprintf(buf + i, sz - i, \" %x\", n->capabilities);\n\ti += scnprintf(buf + i, sz - i, \" %lu\\n\", n->keepalive_intv);\n\n\tif (!more)\n\t\treturn i;\n\n\ti += scnprintf(buf + i, sz - i, \"link_entry[0]:\\n\");\n\ti += scnprintf(buf + i, sz - i, \" mtu: %u\\n\", n->links[0].mtu);\n\ti += scnprintf(buf + i, sz - i, \" media: \");\n\ti += tipc_media_addr_printf(buf + i, sz - i, &n->links[0].maddr);\n\ti += scnprintf(buf + i, sz - i, \"\\n\");\n\ti += tipc_link_dump(n->links[0].link, TIPC_DUMP_NONE, buf + i);\n\ti += scnprintf(buf + i, sz - i, \" inputq: \");\n\ti += tipc_list_dump(&n->links[0].inputq, false, buf + i);\n\n\ti += scnprintf(buf + i, sz - i, \"link_entry[1]:\\n\");\n\ti += scnprintf(buf + i, sz - i, \" mtu: %u\\n\", n->links[1].mtu);\n\ti += scnprintf(buf + i, sz - i, \" media: \");\n\ti += tipc_media_addr_printf(buf + i, sz - i, &n->links[1].maddr);\n\ti += scnprintf(buf + i, sz - i, \"\\n\");\n\ti += tipc_link_dump(n->links[1].link, TIPC_DUMP_NONE, buf + i);\n\ti += scnprintf(buf + i, sz - i, \" inputq: \");\n\ti += tipc_list_dump(&n->links[1].inputq, false, buf + i);\n\n\ti += scnprintf(buf + i, sz - i, \"bclink:\\n \");\n\ti += tipc_link_dump(n->bc_entry.link, TIPC_DUMP_NONE, buf + i);\n\n\treturn i;\n}\n\nvoid tipc_node_pre_cleanup_net(struct net *exit_net)\n{\n\tstruct tipc_node *n;\n\tstruct tipc_net *tn;\n\tstruct net *tmp;\n\n\trcu_read_lock();\n\tfor_each_net_rcu(tmp) {\n\t\tif (tmp == exit_net)\n\t\t\tcontinue;\n\t\ttn = tipc_net(tmp);\n\t\tif (!tn)\n\t\t\tcontinue;\n\t\tspin_lock_bh(&tn->node_list_lock);\n\t\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\t\tif (!n->peer_net)\n\t\t\t\tcontinue;\n\t\t\tif (n->peer_net != exit_net)\n\t\t\t\tcontinue;\n\t\t\ttipc_node_write_lock(n);\n\t\t\tn->peer_net = NULL;\n\t\t\tn->peer_hash_mix = 0;\n\t\t\ttipc_node_write_unlock_fast(n);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_bh(&tn->node_list_lock);\n\t}\n\trcu_read_unlock();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}