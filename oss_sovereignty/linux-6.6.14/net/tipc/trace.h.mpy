{
  "module_name": "trace.h",
  "hash_id": "639c138ce6223ab9f8340870a6c5b94bcdd75e972cc76c2a63ef5179bd6ad511",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/trace.h",
  "human_readable_source": " \n\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM tipc\n\n#if !defined(_TIPC_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TIPC_TRACE_H\n\n#include <linux/tracepoint.h>\n#include \"core.h\"\n#include \"link.h\"\n#include \"socket.h\"\n#include \"node.h\"\n\n#define SKB_LMIN\t(100)\n#define SKB_LMAX\t(SKB_LMIN * 2)\n#define LIST_LMIN\t(SKB_LMIN * 3)\n#define LIST_LMAX\t(SKB_LMIN * 11)\n#define SK_LMIN\t\t(SKB_LMIN * 2)\n#define SK_LMAX\t\t(SKB_LMIN * 11)\n#define LINK_LMIN\t(SKB_LMIN)\n#define LINK_LMAX\t(SKB_LMIN * 16)\n#define NODE_LMIN\t(SKB_LMIN)\n#define NODE_LMAX\t(SKB_LMIN * 11)\n\n#ifndef __TIPC_TRACE_ENUM\n#define __TIPC_TRACE_ENUM\nenum {\n\tTIPC_DUMP_NONE\t\t= 0,\n\n\tTIPC_DUMP_TRANSMQ\t= 1,\n\tTIPC_DUMP_BACKLOGQ\t= (1 << 1),\n\tTIPC_DUMP_DEFERDQ\t= (1 << 2),\n\tTIPC_DUMP_INPUTQ\t= (1 << 3),\n\tTIPC_DUMP_WAKEUP        = (1 << 4),\n\n\tTIPC_DUMP_SK_SNDQ\t= (1 << 8),\n\tTIPC_DUMP_SK_RCVQ\t= (1 << 9),\n\tTIPC_DUMP_SK_BKLGQ\t= (1 << 10),\n\tTIPC_DUMP_ALL\t\t= 0xffffu\n};\n#endif\n\n \n#define state_sym(val)\t\t\t\t\t\t\t  \\\n\t__print_symbolic(val,\t\t\t\t\t\t  \\\n\t\t\t{(0xe),\t\t\"ESTABLISHED\"\t\t\t},\\\n\t\t\t{(0xe << 4),\t\"ESTABLISHING\"\t\t\t},\\\n\t\t\t{(0x1 << 8),\t\"RESET\"\t\t\t\t},\\\n\t\t\t{(0x2 << 12),\t\"RESETTING\"\t\t\t},\\\n\t\t\t{(0xd << 16),\t\"PEER_RESET\"\t\t\t},\\\n\t\t\t{(0xf << 20),\t\"FAILINGOVER\"\t\t\t},\\\n\t\t\t{(0xc << 24),\t\"SYNCHING\"\t\t\t},\\\n\t\t\t{(0xdd),\t\"SELF_DOWN_PEER_DOWN\"\t\t},\\\n\t\t\t{(0xaa),\t\"SELF_UP_PEER_UP\"\t\t},\\\n\t\t\t{(0xd1),\t\"SELF_DOWN_PEER_LEAVING\"\t},\\\n\t\t\t{(0xac),\t\"SELF_UP_PEER_COMING\"\t\t},\\\n\t\t\t{(0xca),\t\"SELF_COMING_PEER_UP\"\t\t},\\\n\t\t\t{(0x1d),\t\"SELF_LEAVING_PEER_DOWN\"\t},\\\n\t\t\t{(0xf0),\t\"FAILINGOVER\"\t\t\t},\\\n\t\t\t{(0xcc),\t\"SYNCHING\"\t\t\t})\n\n \n#define evt_sym(val)\t\t\t\t\t\t\t  \\\n\t__print_symbolic(val,\t\t\t\t\t\t  \\\n\t\t\t{(0xec1ab1e),\t\"ESTABLISH_EVT\"\t\t\t},\\\n\t\t\t{(0x9eed0e),\t\"PEER_RESET_EVT\"\t\t},\\\n\t\t\t{(0xfa110e),\t\"FAILURE_EVT\"\t\t\t},\\\n\t\t\t{(0x10ca1d0e),\t\"RESET_EVT\"\t\t\t},\\\n\t\t\t{(0xfa110bee),\t\"FAILOVER_BEGIN_EVT\"\t\t},\\\n\t\t\t{(0xfa110ede),\t\"FAILOVER_END_EVT\"\t\t},\\\n\t\t\t{(0xc1ccbee),\t\"SYNCH_BEGIN_EVT\"\t\t},\\\n\t\t\t{(0xc1ccede),\t\"SYNCH_END_EVT\"\t\t\t},\\\n\t\t\t{(0xece),\t\"SELF_ESTABL_CONTACT_EVT\"\t},\\\n\t\t\t{(0x1ce),\t\"SELF_LOST_CONTACT_EVT\"\t\t},\\\n\t\t\t{(0x9ece),\t\"PEER_ESTABL_CONTACT_EVT\"\t},\\\n\t\t\t{(0x91ce),\t\"PEER_LOST_CONTACT_EVT\"\t\t},\\\n\t\t\t{(0xfbe),\t\"FAILOVER_BEGIN_EVT\"\t\t},\\\n\t\t\t{(0xfee),\t\"FAILOVER_END_EVT\"\t\t},\\\n\t\t\t{(0xcbe),\t\"SYNCH_BEGIN_EVT\"\t\t},\\\n\t\t\t{(0xcee),\t\"SYNCH_END_EVT\"\t\t\t})\n\n \n#define dev_evt_sym(val)\t\t\t\t\t\t  \\\n\t__print_symbolic(val,\t\t\t\t\t\t  \\\n\t\t\t{(NETDEV_CHANGE),\t\"NETDEV_CHANGE\"\t\t},\\\n\t\t\t{(NETDEV_GOING_DOWN),\t\"NETDEV_GOING_DOWN\"\t},\\\n\t\t\t{(NETDEV_UP),\t\t\"NETDEV_UP\"\t\t},\\\n\t\t\t{(NETDEV_CHANGEMTU),\t\"NETDEV_CHANGEMTU\"\t},\\\n\t\t\t{(NETDEV_CHANGEADDR),\t\"NETDEV_CHANGEADDR\"\t},\\\n\t\t\t{(NETDEV_UNREGISTER),\t\"NETDEV_UNREGISTER\"\t},\\\n\t\t\t{(NETDEV_CHANGENAME),\t\"NETDEV_CHANGENAME\"\t})\n\nextern unsigned long sysctl_tipc_sk_filter[5] __read_mostly;\n\nint tipc_skb_dump(struct sk_buff *skb, bool more, char *buf);\nint tipc_list_dump(struct sk_buff_head *list, bool more, char *buf);\nint tipc_sk_dump(struct sock *sk, u16 dqueues, char *buf);\nint tipc_link_dump(struct tipc_link *l, u16 dqueues, char *buf);\nint tipc_node_dump(struct tipc_node *n, bool more, char *buf);\nbool tipc_sk_filtering(struct sock *sk);\n\nDECLARE_EVENT_CLASS(tipc_skb_class,\n\n\tTP_PROTO(struct sk_buff *skb, bool more, const char *header),\n\n\tTP_ARGS(skb, more, header),\n\n\tTP_STRUCT__entry(\n\t\t__string(header, header)\n\t\t__dynamic_array(char, buf, (more) ? SKB_LMAX : SKB_LMIN)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(header, header);\n\t\ttipc_skb_dump(skb, more, __get_str(buf));\n\t),\n\n\tTP_printk(\"%s\\n%s\", __get_str(header), __get_str(buf))\n)\n\n#define DEFINE_SKB_EVENT(name) \\\nDEFINE_EVENT(tipc_skb_class, name, \\\n\tTP_PROTO(struct sk_buff *skb, bool more, const char *header), \\\n\tTP_ARGS(skb, more, header))\nDEFINE_SKB_EVENT(tipc_skb_dump);\nDEFINE_SKB_EVENT(tipc_proto_build);\nDEFINE_SKB_EVENT(tipc_proto_rcv);\n\nDECLARE_EVENT_CLASS(tipc_list_class,\n\n\tTP_PROTO(struct sk_buff_head *list, bool more, const char *header),\n\n\tTP_ARGS(list, more, header),\n\n\tTP_STRUCT__entry(\n\t\t__string(header, header)\n\t\t__dynamic_array(char, buf, (more) ? LIST_LMAX : LIST_LMIN)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(header, header);\n\t\ttipc_list_dump(list, more, __get_str(buf));\n\t),\n\n\tTP_printk(\"%s\\n%s\", __get_str(header), __get_str(buf))\n);\n\n#define DEFINE_LIST_EVENT(name) \\\nDEFINE_EVENT(tipc_list_class, name, \\\n\tTP_PROTO(struct sk_buff_head *list, bool more, const char *header), \\\n\tTP_ARGS(list, more, header))\nDEFINE_LIST_EVENT(tipc_list_dump);\n\nDECLARE_EVENT_CLASS(tipc_sk_class,\n\n\tTP_PROTO(struct sock *sk, struct sk_buff *skb, u16 dqueues,\n\t\t const char *header),\n\n\tTP_ARGS(sk, skb, dqueues, header),\n\n\tTP_STRUCT__entry(\n\t\t__string(header, header)\n\t\t__field(u32, portid)\n\t\t__dynamic_array(char, buf, (dqueues) ? SK_LMAX : SK_LMIN)\n\t\t__dynamic_array(char, skb_buf, (skb) ? SKB_LMIN : 1)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(header, header);\n\t\t__entry->portid = tipc_sock_get_portid(sk);\n\t\ttipc_sk_dump(sk, dqueues, __get_str(buf));\n\t\tif (skb)\n\t\t\ttipc_skb_dump(skb, false, __get_str(skb_buf));\n\t\telse\n\t\t\t*(__get_str(skb_buf)) = '\\0';\n\t),\n\n\tTP_printk(\"<%u> %s\\n%s%s\", __entry->portid, __get_str(header),\n\t\t  __get_str(skb_buf), __get_str(buf))\n);\n\n#define DEFINE_SK_EVENT_FILTER(name) \\\nDEFINE_EVENT_CONDITION(tipc_sk_class, name, \\\n\tTP_PROTO(struct sock *sk, struct sk_buff *skb, u16 dqueues, \\\n\t\t const char *header), \\\n\tTP_ARGS(sk, skb, dqueues, header), \\\n\tTP_CONDITION(tipc_sk_filtering(sk)))\nDEFINE_SK_EVENT_FILTER(tipc_sk_dump);\nDEFINE_SK_EVENT_FILTER(tipc_sk_create);\nDEFINE_SK_EVENT_FILTER(tipc_sk_sendmcast);\nDEFINE_SK_EVENT_FILTER(tipc_sk_sendmsg);\nDEFINE_SK_EVENT_FILTER(tipc_sk_sendstream);\nDEFINE_SK_EVENT_FILTER(tipc_sk_poll);\nDEFINE_SK_EVENT_FILTER(tipc_sk_filter_rcv);\nDEFINE_SK_EVENT_FILTER(tipc_sk_advance_rx);\nDEFINE_SK_EVENT_FILTER(tipc_sk_rej_msg);\nDEFINE_SK_EVENT_FILTER(tipc_sk_drop_msg);\nDEFINE_SK_EVENT_FILTER(tipc_sk_release);\nDEFINE_SK_EVENT_FILTER(tipc_sk_shutdown);\n\n#define DEFINE_SK_EVENT_FILTER_COND(name, cond) \\\nDEFINE_EVENT_CONDITION(tipc_sk_class, name, \\\n\tTP_PROTO(struct sock *sk, struct sk_buff *skb, u16 dqueues, \\\n\t\t const char *header), \\\n\tTP_ARGS(sk, skb, dqueues, header), \\\n\tTP_CONDITION(tipc_sk_filtering(sk) && (cond)))\nDEFINE_SK_EVENT_FILTER_COND(tipc_sk_overlimit1, tipc_sk_overlimit1(sk, skb));\nDEFINE_SK_EVENT_FILTER_COND(tipc_sk_overlimit2, tipc_sk_overlimit2(sk, skb));\n\nDECLARE_EVENT_CLASS(tipc_link_class,\n\n\tTP_PROTO(struct tipc_link *l, u16 dqueues, const char *header),\n\n\tTP_ARGS(l, dqueues, header),\n\n\tTP_STRUCT__entry(\n\t\t__string(header, header)\n\t\t__array(char, name, TIPC_MAX_LINK_NAME)\n\t\t__dynamic_array(char, buf, (dqueues) ? LINK_LMAX : LINK_LMIN)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(header, header);\n\t\tmemcpy(__entry->name, tipc_link_name(l), TIPC_MAX_LINK_NAME);\n\t\ttipc_link_dump(l, dqueues, __get_str(buf));\n\t),\n\n\tTP_printk(\"<%s> %s\\n%s\", __entry->name, __get_str(header),\n\t\t  __get_str(buf))\n);\n\n#define DEFINE_LINK_EVENT(name) \\\nDEFINE_EVENT(tipc_link_class, name, \\\n\tTP_PROTO(struct tipc_link *l, u16 dqueues, const char *header), \\\n\tTP_ARGS(l, dqueues, header))\nDEFINE_LINK_EVENT(tipc_link_dump);\nDEFINE_LINK_EVENT(tipc_link_conges);\nDEFINE_LINK_EVENT(tipc_link_timeout);\nDEFINE_LINK_EVENT(tipc_link_reset);\n\n#define DEFINE_LINK_EVENT_COND(name, cond) \\\nDEFINE_EVENT_CONDITION(tipc_link_class, name, \\\n\tTP_PROTO(struct tipc_link *l, u16 dqueues, const char *header), \\\n\tTP_ARGS(l, dqueues, header), \\\n\tTP_CONDITION(cond))\nDEFINE_LINK_EVENT_COND(tipc_link_too_silent, tipc_link_too_silent(l));\n\nDECLARE_EVENT_CLASS(tipc_link_transmq_class,\n\n\tTP_PROTO(struct tipc_link *r, u16 f, u16 t, struct sk_buff_head *tq),\n\n\tTP_ARGS(r, f, t, tq),\n\n\tTP_STRUCT__entry(\n\t\t__array(char, name, TIPC_MAX_LINK_NAME)\n\t\t__field(u16, from)\n\t\t__field(u16, to)\n\t\t__field(u32, len)\n\t\t__field(u16, fseqno)\n\t\t__field(u16, lseqno)\n\t),\n\n\tTP_fast_assign(\n\t\tmemcpy(__entry->name, tipc_link_name(r), TIPC_MAX_LINK_NAME);\n\t\t__entry->from = f;\n\t\t__entry->to = t;\n\t\t__entry->len = skb_queue_len(tq);\n\t\t__entry->fseqno = __entry->len ?\n\t\t\t\t  msg_seqno(buf_msg(skb_peek(tq))) : 0;\n\t\t__entry->lseqno = __entry->len ?\n\t\t\t\t  msg_seqno(buf_msg(skb_peek_tail(tq))) : 0;\n\t),\n\n\tTP_printk(\"<%s> retrans req: [%u-%u] transmq: %u [%u-%u]\\n\",\n\t\t  __entry->name, __entry->from, __entry->to,\n\t\t  __entry->len, __entry->fseqno, __entry->lseqno)\n);\n\nDEFINE_EVENT_CONDITION(tipc_link_transmq_class, tipc_link_retrans,\n\tTP_PROTO(struct tipc_link *r, u16 f, u16 t, struct sk_buff_head *tq),\n\tTP_ARGS(r, f, t, tq),\n\tTP_CONDITION(less_eq(f, t))\n);\n\nDEFINE_EVENT_PRINT(tipc_link_transmq_class, tipc_link_bc_ack,\n\tTP_PROTO(struct tipc_link *r, u16 f, u16 t, struct sk_buff_head *tq),\n\tTP_ARGS(r, f, t, tq),\n\tTP_printk(\"<%s> acked: %u gap: %u transmq: %u [%u-%u]\\n\",\n\t\t  __entry->name, __entry->from, __entry->to,\n\t\t  __entry->len, __entry->fseqno, __entry->lseqno)\n);\n\nDECLARE_EVENT_CLASS(tipc_node_class,\n\n\tTP_PROTO(struct tipc_node *n, bool more, const char *header),\n\n\tTP_ARGS(n, more, header),\n\n\tTP_STRUCT__entry(\n\t\t__string(header, header)\n\t\t__field(u32, addr)\n\t\t__dynamic_array(char, buf, (more) ? NODE_LMAX : NODE_LMIN)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(header, header);\n\t\t__entry->addr = tipc_node_get_addr(n);\n\t\ttipc_node_dump(n, more, __get_str(buf));\n\t),\n\n\tTP_printk(\"<%x> %s\\n%s\", __entry->addr, __get_str(header),\n\t\t  __get_str(buf))\n);\n\n#define DEFINE_NODE_EVENT(name) \\\nDEFINE_EVENT(tipc_node_class, name, \\\n\tTP_PROTO(struct tipc_node *n, bool more, const char *header), \\\n\tTP_ARGS(n, more, header))\nDEFINE_NODE_EVENT(tipc_node_dump);\nDEFINE_NODE_EVENT(tipc_node_create);\nDEFINE_NODE_EVENT(tipc_node_delete);\nDEFINE_NODE_EVENT(tipc_node_lost_contact);\nDEFINE_NODE_EVENT(tipc_node_timeout);\nDEFINE_NODE_EVENT(tipc_node_link_up);\nDEFINE_NODE_EVENT(tipc_node_link_down);\nDEFINE_NODE_EVENT(tipc_node_reset_links);\nDEFINE_NODE_EVENT(tipc_node_check_state);\n\nDECLARE_EVENT_CLASS(tipc_fsm_class,\n\n\tTP_PROTO(const char *name, u32 os, u32 ns, int evt),\n\n\tTP_ARGS(name, os, ns, evt),\n\n\tTP_STRUCT__entry(\n\t\t__string(name, name)\n\t\t__field(u32, os)\n\t\t__field(u32, ns)\n\t\t__field(u32, evt)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(name, name);\n\t\t__entry->os = os;\n\t\t__entry->ns = ns;\n\t\t__entry->evt = evt;\n\t),\n\n\tTP_printk(\"<%s> %s--(%s)->%s\\n\", __get_str(name),\n\t\t  state_sym(__entry->os), evt_sym(__entry->evt),\n\t\t  state_sym(__entry->ns))\n);\n\n#define DEFINE_FSM_EVENT(fsm_name) \\\nDEFINE_EVENT(tipc_fsm_class, fsm_name, \\\n\tTP_PROTO(const char *name, u32 os, u32 ns, int evt), \\\n\tTP_ARGS(name, os, ns, evt))\nDEFINE_FSM_EVENT(tipc_link_fsm);\nDEFINE_FSM_EVENT(tipc_node_fsm);\n\nTRACE_EVENT(tipc_l2_device_event,\n\n\tTP_PROTO(struct net_device *dev, struct tipc_bearer *b,\n\t\t unsigned long evt),\n\n\tTP_ARGS(dev, b, evt),\n\n\tTP_STRUCT__entry(\n\t\t__string(dev_name, dev->name)\n\t\t__string(b_name, b->name)\n\t\t__field(unsigned long, evt)\n\t\t__field(u8, b_up)\n\t\t__field(u8, carrier)\n\t\t__field(u8, oper)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(dev_name, dev->name);\n\t\t__assign_str(b_name, b->name);\n\t\t__entry->evt = evt;\n\t\t__entry->b_up = test_bit(0, &b->up);\n\t\t__entry->carrier = netif_carrier_ok(dev);\n\t\t__entry->oper = netif_oper_up(dev);\n\t),\n\n\tTP_printk(\"%s on: <%s>/<%s> oper: %s carrier: %s bearer: %s\\n\",\n\t\t  dev_evt_sym(__entry->evt), __get_str(dev_name),\n\t\t  __get_str(b_name), (__entry->oper) ? \"up\" : \"down\",\n\t\t  (__entry->carrier) ? \"ok\" : \"notok\",\n\t\t  (__entry->b_up) ? \"up\" : \"down\")\n);\n\n#endif  \n\n \n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH .\n#undef TRACE_INCLUDE_FILE\n#define TRACE_INCLUDE_FILE trace\n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}