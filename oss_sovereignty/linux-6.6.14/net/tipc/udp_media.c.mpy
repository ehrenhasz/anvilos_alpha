{
  "module_name": "udp_media.c",
  "hash_id": "0fa33fe2a2161d09108ae61f54a1710a78265363b7bb65232435e051642898e7",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/udp_media.c",
  "human_readable_source": " \n\n#include <linux/socket.h>\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/list.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/udp_tunnel.h>\n#include <net/ipv6_stubs.h>\n#include <linux/tipc_netlink.h>\n#include \"core.h\"\n#include \"addr.h\"\n#include \"net.h\"\n#include \"bearer.h\"\n#include \"netlink.h\"\n#include \"msg.h\"\n#include \"udp_media.h\"\n\n \n#define UDP_PORT_DEFAULT\t6118\n\n#define UDP_MIN_HEADROOM        48\n\n \nstruct udp_media_addr {\n\t__be16\tproto;\n\t__be16\tport;\n\tunion {\n\t\tstruct in_addr ipv4;\n\t\tstruct in6_addr ipv6;\n\t};\n};\n\n \nstruct udp_replicast {\n\tstruct udp_media_addr addr;\n\tstruct dst_cache dst_cache;\n\tstruct rcu_head rcu;\n\tstruct list_head list;\n};\n\n \nstruct udp_bearer {\n\tstruct tipc_bearer __rcu *bearer;\n\tstruct socket *ubsock;\n\tu32 ifindex;\n\tstruct work_struct work;\n\tstruct udp_replicast rcast;\n};\n\nstatic int tipc_udp_is_mcast_addr(struct udp_media_addr *addr)\n{\n\tif (ntohs(addr->proto) == ETH_P_IP)\n\t\treturn ipv4_is_multicast(addr->ipv4.s_addr);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\treturn ipv6_addr_is_multicast(&addr->ipv6);\n#endif\n\treturn 0;\n}\n\n \nstatic void tipc_udp_media_addr_set(struct tipc_media_addr *addr,\n\t\t\t\t    struct udp_media_addr *ua)\n{\n\tmemset(addr, 0, sizeof(struct tipc_media_addr));\n\taddr->media_id = TIPC_MEDIA_TYPE_UDP;\n\tmemcpy(addr->value, ua, sizeof(struct udp_media_addr));\n\n\tif (tipc_udp_is_mcast_addr(ua))\n\t\taddr->broadcast = TIPC_BROADCAST_SUPPORT;\n}\n\n \nstatic int tipc_udp_addr2str(struct tipc_media_addr *a, char *buf, int size)\n{\n\tstruct udp_media_addr *ua = (struct udp_media_addr *)&a->value;\n\n\tif (ntohs(ua->proto) == ETH_P_IP)\n\t\tsnprintf(buf, size, \"%pI4:%u\", &ua->ipv4, ntohs(ua->port));\n\telse if (ntohs(ua->proto) == ETH_P_IPV6)\n\t\tsnprintf(buf, size, \"%pI6:%u\", &ua->ipv6, ntohs(ua->port));\n\telse\n\t\tpr_err(\"Invalid UDP media address\\n\");\n\treturn 0;\n}\n\n \nstatic int tipc_udp_msg2addr(struct tipc_bearer *b, struct tipc_media_addr *a,\n\t\t\t     char *msg)\n{\n\tstruct udp_media_addr *ua;\n\n\tua = (struct udp_media_addr *) (msg + TIPC_MEDIA_ADDR_OFFSET);\n\tif (msg[TIPC_MEDIA_TYPE_OFFSET] != TIPC_MEDIA_TYPE_UDP)\n\t\treturn -EINVAL;\n\ttipc_udp_media_addr_set(a, ua);\n\treturn 0;\n}\n\n \nstatic int tipc_udp_addr2msg(char *msg, struct tipc_media_addr *a)\n{\n\tmemset(msg, 0, TIPC_MEDIA_INFO_SIZE);\n\tmsg[TIPC_MEDIA_TYPE_OFFSET] = TIPC_MEDIA_TYPE_UDP;\n\tmemcpy(msg + TIPC_MEDIA_ADDR_OFFSET, a->value,\n\t       sizeof(struct udp_media_addr));\n\treturn 0;\n}\n\n \nstatic int tipc_udp_xmit(struct net *net, struct sk_buff *skb,\n\t\t\t struct udp_bearer *ub, struct udp_media_addr *src,\n\t\t\t struct udp_media_addr *dst, struct dst_cache *cache)\n{\n\tstruct dst_entry *ndst;\n\tint ttl, err = 0;\n\n\tlocal_bh_disable();\n\tndst = dst_cache_get(cache);\n\tif (dst->proto == htons(ETH_P_IP)) {\n\t\tstruct rtable *rt = (struct rtable *)ndst;\n\n\t\tif (!rt) {\n\t\t\tstruct flowi4 fl = {\n\t\t\t\t.daddr = dst->ipv4.s_addr,\n\t\t\t\t.saddr = src->ipv4.s_addr,\n\t\t\t\t.flowi4_mark = skb->mark,\n\t\t\t\t.flowi4_proto = IPPROTO_UDP\n\t\t\t};\n\t\t\trt = ip_route_output_key(net, &fl);\n\t\t\tif (IS_ERR(rt)) {\n\t\t\t\terr = PTR_ERR(rt);\n\t\t\t\tgoto tx_error;\n\t\t\t}\n\t\t\tdst_cache_set_ip4(cache, &rt->dst, fl.saddr);\n\t\t}\n\n\t\tttl = ip4_dst_hoplimit(&rt->dst);\n\t\tudp_tunnel_xmit_skb(rt, ub->ubsock->sk, skb, src->ipv4.s_addr,\n\t\t\t\t    dst->ipv4.s_addr, 0, ttl, 0, src->port,\n\t\t\t\t    dst->port, false, true);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tif (!ndst) {\n\t\t\tstruct flowi6 fl6 = {\n\t\t\t\t.flowi6_oif = ub->ifindex,\n\t\t\t\t.daddr = dst->ipv6,\n\t\t\t\t.saddr = src->ipv6,\n\t\t\t\t.flowi6_proto = IPPROTO_UDP\n\t\t\t};\n\t\t\tndst = ipv6_stub->ipv6_dst_lookup_flow(net,\n\t\t\t\t\t\t\t       ub->ubsock->sk,\n\t\t\t\t\t\t\t       &fl6, NULL);\n\t\t\tif (IS_ERR(ndst)) {\n\t\t\t\terr = PTR_ERR(ndst);\n\t\t\t\tgoto tx_error;\n\t\t\t}\n\t\t\tdst_cache_set_ip6(cache, ndst, &fl6.saddr);\n\t\t}\n\t\tttl = ip6_dst_hoplimit(ndst);\n\t\terr = udp_tunnel6_xmit_skb(ndst, ub->ubsock->sk, skb, NULL,\n\t\t\t\t\t   &src->ipv6, &dst->ipv6, 0, ttl, 0,\n\t\t\t\t\t   src->port, dst->port, false);\n#endif\n\t}\n\tlocal_bh_enable();\n\treturn err;\n\ntx_error:\n\tlocal_bh_enable();\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int tipc_udp_send_msg(struct net *net, struct sk_buff *skb,\n\t\t\t     struct tipc_bearer *b,\n\t\t\t     struct tipc_media_addr *addr)\n{\n\tstruct udp_media_addr *src = (struct udp_media_addr *)&b->addr.value;\n\tstruct udp_media_addr *dst = (struct udp_media_addr *)&addr->value;\n\tstruct udp_replicast *rcast;\n\tstruct udp_bearer *ub;\n\tint err = 0;\n\n\tif (skb_headroom(skb) < UDP_MIN_HEADROOM) {\n\t\terr = pskb_expand_head(skb, UDP_MIN_HEADROOM, 0, GFP_ATOMIC);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tskb_set_inner_protocol(skb, htons(ETH_P_TIPC));\n\tub = rcu_dereference(b->media_ptr);\n\tif (!ub) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (addr->broadcast != TIPC_REPLICAST_SUPPORT)\n\t\treturn tipc_udp_xmit(net, skb, ub, src, dst,\n\t\t\t\t     &ub->rcast.dst_cache);\n\n\t \n\tlist_for_each_entry_rcu(rcast, &ub->rcast.list, list) {\n\t\tstruct sk_buff *_skb;\n\n\t\t_skb = pskb_copy(skb, GFP_ATOMIC);\n\t\tif (!_skb) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = tipc_udp_xmit(net, _skb, ub, src, &rcast->addr,\n\t\t\t\t    &rcast->dst_cache);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = 0;\nout:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic bool tipc_udp_is_known_peer(struct tipc_bearer *b,\n\t\t\t\t   struct udp_media_addr *addr)\n{\n\tstruct udp_replicast *rcast, *tmp;\n\tstruct udp_bearer *ub;\n\n\tub = rcu_dereference_rtnl(b->media_ptr);\n\tif (!ub) {\n\t\tpr_err_ratelimited(\"UDP bearer instance not found\\n\");\n\t\treturn false;\n\t}\n\n\tlist_for_each_entry_safe(rcast, tmp, &ub->rcast.list, list) {\n\t\tif (!memcmp(&rcast->addr, addr, sizeof(struct udp_media_addr)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int tipc_udp_rcast_add(struct tipc_bearer *b,\n\t\t\t      struct udp_media_addr *addr)\n{\n\tstruct udp_replicast *rcast;\n\tstruct udp_bearer *ub;\n\n\tub = rcu_dereference_rtnl(b->media_ptr);\n\tif (!ub)\n\t\treturn -ENODEV;\n\n\trcast = kmalloc(sizeof(*rcast), GFP_ATOMIC);\n\tif (!rcast)\n\t\treturn -ENOMEM;\n\n\tif (dst_cache_init(&rcast->dst_cache, GFP_ATOMIC)) {\n\t\tkfree(rcast);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&rcast->addr, addr, sizeof(struct udp_media_addr));\n\n\tif (ntohs(addr->proto) == ETH_P_IP)\n\t\tpr_info(\"New replicast peer: %pI4\\n\", &rcast->addr.ipv4);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (ntohs(addr->proto) == ETH_P_IPV6)\n\t\tpr_info(\"New replicast peer: %pI6\\n\", &rcast->addr.ipv6);\n#endif\n\tb->bcast_addr.broadcast = TIPC_REPLICAST_SUPPORT;\n\tlist_add_rcu(&rcast->list, &ub->rcast.list);\n\treturn 0;\n}\n\nstatic int tipc_udp_rcast_disc(struct tipc_bearer *b, struct sk_buff *skb)\n{\n\tstruct udp_media_addr src = {0};\n\tstruct udp_media_addr *dst;\n\n\tdst = (struct udp_media_addr *)&b->bcast_addr.value;\n\tif (tipc_udp_is_mcast_addr(dst))\n\t\treturn 0;\n\n\tsrc.port = udp_hdr(skb)->source;\n\n\tif (ip_hdr(skb)->version == 4) {\n\t\tstruct iphdr *iphdr = ip_hdr(skb);\n\n\t\tsrc.proto = htons(ETH_P_IP);\n\t\tsrc.ipv4.s_addr = iphdr->saddr;\n\t\tif (ipv4_is_multicast(iphdr->daddr))\n\t\t\treturn 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (ip_hdr(skb)->version == 6) {\n\t\tstruct ipv6hdr *iphdr = ipv6_hdr(skb);\n\n\t\tsrc.proto = htons(ETH_P_IPV6);\n\t\tsrc.ipv6 = iphdr->saddr;\n\t\tif (ipv6_addr_is_multicast(&iphdr->daddr))\n\t\t\treturn 0;\n#endif\n\t} else {\n\t\treturn 0;\n\t}\n\n\tif (likely(tipc_udp_is_known_peer(b, &src)))\n\t\treturn 0;\n\n\treturn tipc_udp_rcast_add(b, &src);\n}\n\n \nstatic int tipc_udp_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct udp_bearer *ub;\n\tstruct tipc_bearer *b;\n\tstruct tipc_msg *hdr;\n\tint err;\n\n\tub = rcu_dereference_sk_user_data(sk);\n\tif (!ub) {\n\t\tpr_err_ratelimited(\"Failed to get UDP bearer reference\");\n\t\tgoto out;\n\t}\n\tskb_pull(skb, sizeof(struct udphdr));\n\thdr = buf_msg(skb);\n\n\tb = rcu_dereference(ub->bearer);\n\tif (!b)\n\t\tgoto out;\n\n\tif (b && test_bit(0, &b->up)) {\n\t\tTIPC_SKB_CB(skb)->flags = 0;\n\t\ttipc_rcv(sock_net(sk), skb, b);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(msg_user(hdr) == LINK_CONFIG)) {\n\t\terr = tipc_udp_rcast_disc(b, skb);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int enable_mcast(struct udp_bearer *ub, struct udp_media_addr *remote)\n{\n\tint err = 0;\n\tstruct ip_mreqn mreqn;\n\tstruct sock *sk = ub->ubsock->sk;\n\n\tif (ntohs(remote->proto) == ETH_P_IP) {\n\t\tmreqn.imr_multiaddr = remote->ipv4;\n\t\tmreqn.imr_ifindex = ub->ifindex;\n\t\terr = ip_mc_join_group(sk, &mreqn);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tlock_sock(sk);\n\t\terr = ipv6_stub->ipv6_sock_mc_join(sk, ub->ifindex,\n\t\t\t\t\t\t   &remote->ipv6);\n\t\trelease_sock(sk);\n#endif\n\t}\n\treturn err;\n}\n\nstatic int __tipc_nl_add_udp_addr(struct sk_buff *skb,\n\t\t\t\t  struct udp_media_addr *addr, int nla_t)\n{\n\tif (ntohs(addr->proto) == ETH_P_IP) {\n\t\tstruct sockaddr_in ip4;\n\n\t\tmemset(&ip4, 0, sizeof(ip4));\n\t\tip4.sin_family = AF_INET;\n\t\tip4.sin_port = addr->port;\n\t\tip4.sin_addr.s_addr = addr->ipv4.s_addr;\n\t\tif (nla_put(skb, nla_t, sizeof(ip4), &ip4))\n\t\t\treturn -EMSGSIZE;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (ntohs(addr->proto) == ETH_P_IPV6) {\n\t\tstruct sockaddr_in6 ip6;\n\n\t\tmemset(&ip6, 0, sizeof(ip6));\n\t\tip6.sin6_family = AF_INET6;\n\t\tip6.sin6_port  = addr->port;\n\t\tmemcpy(&ip6.sin6_addr, &addr->ipv6, sizeof(struct in6_addr));\n\t\tif (nla_put(skb, nla_t, sizeof(ip6), &ip6))\n\t\t\treturn -EMSGSIZE;\n#endif\n\t}\n\n\treturn 0;\n}\n\nint tipc_udp_nl_dump_remoteip(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tu32 bid = cb->args[0];\n\tu32 skip_cnt = cb->args[1];\n\tu32 portid = NETLINK_CB(cb->skb).portid;\n\tstruct udp_replicast *rcast, *tmp;\n\tstruct tipc_bearer *b;\n\tstruct udp_bearer *ub;\n\tvoid *hdr;\n\tint err;\n\tint i;\n\n\tif (!bid && !skip_cnt) {\n\t\tstruct nlattr **attrs = genl_dumpit_info(cb)->info.attrs;\n\t\tstruct net *net = sock_net(skb->sk);\n\t\tstruct nlattr *battrs[TIPC_NLA_BEARER_MAX + 1];\n\t\tchar *bname;\n\n\t\tif (!attrs[TIPC_NLA_BEARER])\n\t\t\treturn -EINVAL;\n\n\t\terr = nla_parse_nested_deprecated(battrs, TIPC_NLA_BEARER_MAX,\n\t\t\t\t\t\t  attrs[TIPC_NLA_BEARER],\n\t\t\t\t\t\t  tipc_nl_bearer_policy, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!battrs[TIPC_NLA_BEARER_NAME])\n\t\t\treturn -EINVAL;\n\n\t\tbname = nla_data(battrs[TIPC_NLA_BEARER_NAME]);\n\n\t\trtnl_lock();\n\t\tb = tipc_bearer_find(net, bname);\n\t\tif (!b) {\n\t\t\trtnl_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbid = b->identity;\n\t} else {\n\t\tstruct net *net = sock_net(skb->sk);\n\t\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\n\t\trtnl_lock();\n\t\tb = rtnl_dereference(tn->bearer_list[bid]);\n\t\tif (!b) {\n\t\t\trtnl_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tub = rtnl_dereference(b->media_ptr);\n\tif (!ub) {\n\t\trtnl_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\ti = 0;\n\tlist_for_each_entry_safe(rcast, tmp, &ub->rcast.list, list) {\n\t\tif (i < skip_cnt)\n\t\t\tgoto count;\n\n\t\thdr = genlmsg_put(skb, portid, cb->nlh->nlmsg_seq,\n\t\t\t\t  &tipc_genl_family, NLM_F_MULTI,\n\t\t\t\t  TIPC_NL_BEARER_GET);\n\t\tif (!hdr)\n\t\t\tgoto done;\n\n\t\terr = __tipc_nl_add_udp_addr(skb, &rcast->addr,\n\t\t\t\t\t     TIPC_NLA_UDP_REMOTE);\n\t\tif (err) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto done;\n\t\t}\n\t\tgenlmsg_end(skb, hdr);\ncount:\n\t\ti++;\n\t}\ndone:\n\trtnl_unlock();\n\tcb->args[0] = bid;\n\tcb->args[1] = i;\n\n\treturn skb->len;\n}\n\nint tipc_udp_nl_add_bearer_data(struct tipc_nl_msg *msg, struct tipc_bearer *b)\n{\n\tstruct udp_media_addr *src = (struct udp_media_addr *)&b->addr.value;\n\tstruct udp_media_addr *dst;\n\tstruct udp_bearer *ub;\n\tstruct nlattr *nest;\n\n\tub = rtnl_dereference(b->media_ptr);\n\tif (!ub)\n\t\treturn -ENODEV;\n\n\tnest = nla_nest_start_noflag(msg->skb, TIPC_NLA_BEARER_UDP_OPTS);\n\tif (!nest)\n\t\tgoto msg_full;\n\n\tif (__tipc_nl_add_udp_addr(msg->skb, src, TIPC_NLA_UDP_LOCAL))\n\t\tgoto msg_full;\n\n\tdst = (struct udp_media_addr *)&b->bcast_addr.value;\n\tif (__tipc_nl_add_udp_addr(msg->skb, dst, TIPC_NLA_UDP_REMOTE))\n\t\tgoto msg_full;\n\n\tif (!list_empty(&ub->rcast.list)) {\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_UDP_MULTI_REMOTEIP))\n\t\t\tgoto msg_full;\n\t}\n\n\tnla_nest_end(msg->skb, nest);\n\treturn 0;\nmsg_full:\n\tnla_nest_cancel(msg->skb, nest);\n\treturn -EMSGSIZE;\n}\n\n \n\nstatic int tipc_parse_udp_addr(struct nlattr *nla, struct udp_media_addr *addr,\n\t\t\t       u32 *scope_id)\n{\n\tstruct sockaddr_storage sa;\n\n\tnla_memcpy(&sa, nla, sizeof(sa));\n\tif (sa.ss_family == AF_INET) {\n\t\tstruct sockaddr_in *ip4 = (struct sockaddr_in *)&sa;\n\n\t\taddr->proto = htons(ETH_P_IP);\n\t\taddr->port = ip4->sin_port;\n\t\taddr->ipv4.s_addr = ip4->sin_addr.s_addr;\n\t\treturn 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (sa.ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *ip6 = (struct sockaddr_in6 *)&sa;\n\n\t\taddr->proto = htons(ETH_P_IPV6);\n\t\taddr->port = ip6->sin6_port;\n\t\tmemcpy(&addr->ipv6, &ip6->sin6_addr, sizeof(struct in6_addr));\n\n\t\t \n\t\tif (scope_id) {\n\t\t\tint atype;\n\n\t\t\tatype = ipv6_addr_type(&ip6->sin6_addr);\n\t\t\tif (__ipv6_addr_needs_scope_id(atype) &&\n\t\t\t    !ip6->sin6_scope_id) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t*scope_id = ip6->sin6_scope_id ? : 0;\n\t\t}\n\n\t\treturn 0;\n#endif\n\t}\n\treturn -EADDRNOTAVAIL;\n}\n\nint tipc_udp_nl_bearer_add(struct tipc_bearer *b, struct nlattr *attr)\n{\n\tint err;\n\tstruct udp_media_addr addr = {0};\n\tstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\n\tstruct udp_media_addr *dst;\n\n\tif (nla_parse_nested_deprecated(opts, TIPC_NLA_UDP_MAX, attr, tipc_nl_udp_policy, NULL))\n\t\treturn -EINVAL;\n\n\tif (!opts[TIPC_NLA_UDP_REMOTE])\n\t\treturn -EINVAL;\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_REMOTE], &addr, NULL);\n\tif (err)\n\t\treturn err;\n\n\tdst = (struct udp_media_addr *)&b->bcast_addr.value;\n\tif (tipc_udp_is_mcast_addr(dst)) {\n\t\tpr_err(\"Can't add remote ip to TIPC UDP multicast bearer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tipc_udp_is_known_peer(b, &addr))\n\t\treturn 0;\n\n\treturn tipc_udp_rcast_add(b, &addr);\n}\n\n \nstatic int tipc_udp_enable(struct net *net, struct tipc_bearer *b,\n\t\t\t   struct nlattr *attrs[])\n{\n\tint err = -EINVAL;\n\tstruct udp_bearer *ub;\n\tstruct udp_media_addr remote = {0};\n\tstruct udp_media_addr local = {0};\n\tstruct udp_port_cfg udp_conf = {0};\n\tstruct udp_tunnel_sock_cfg tuncfg = {NULL};\n\tstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\n\tu8 node_id[NODE_ID_LEN] = {0,};\n\tstruct net_device *dev;\n\tint rmcast = 0;\n\n\tub = kzalloc(sizeof(*ub), GFP_ATOMIC);\n\tif (!ub)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ub->rcast.list);\n\n\tif (!attrs[TIPC_NLA_BEARER_UDP_OPTS])\n\t\tgoto err;\n\n\tif (nla_parse_nested_deprecated(opts, TIPC_NLA_UDP_MAX, attrs[TIPC_NLA_BEARER_UDP_OPTS], tipc_nl_udp_policy, NULL))\n\t\tgoto err;\n\n\tif (!opts[TIPC_NLA_UDP_LOCAL] || !opts[TIPC_NLA_UDP_REMOTE]) {\n\t\tpr_err(\"Invalid UDP bearer configuration\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_LOCAL], &local,\n\t\t\t\t  &ub->ifindex);\n\tif (err)\n\t\tgoto err;\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_REMOTE], &remote, NULL);\n\tif (err)\n\t\tgoto err;\n\n\tif (remote.proto != local.proto) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\trmcast = tipc_udp_is_mcast_addr(&remote);\n\n\t \n\tif (!tipc_own_id(net)) {\n\t\tmemcpy(node_id, local.ipv6.in6_u.u6_addr8, 16);\n\t\ttipc_net_init(net, node_id, 0);\n\t}\n\tif (!tipc_own_id(net)) {\n\t\tpr_warn(\"Failed to set node id, please configure manually\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tb->bcast_addr.media_id = TIPC_MEDIA_TYPE_UDP;\n\tb->bcast_addr.broadcast = TIPC_BROADCAST_SUPPORT;\n\trcu_assign_pointer(b->media_ptr, ub);\n\trcu_assign_pointer(ub->bearer, b);\n\ttipc_udp_media_addr_set(&b->addr, &local);\n\tif (local.proto == htons(ETH_P_IP)) {\n\t\tdev = __ip_dev_find(net, local.ipv4.s_addr, false);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tudp_conf.family = AF_INET;\n\n\t\t \n\t\tif (rmcast)\n\t\t\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n\t\telse\n\t\t\tudp_conf.local_ip.s_addr = local.ipv4.s_addr;\n\t\tudp_conf.use_udp_checksums = false;\n\t\tub->ifindex = dev->ifindex;\n\t\tb->encap_hlen = sizeof(struct iphdr) + sizeof(struct udphdr);\n\t\tb->mtu = b->media->mtu;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (local.proto == htons(ETH_P_IPV6)) {\n\t\tdev = ub->ifindex ? __dev_get_by_index(net, ub->ifindex) : NULL;\n\t\tdev = ipv6_dev_find(net, &local.ipv6, dev);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tudp_conf.family = AF_INET6;\n\t\tudp_conf.use_udp6_tx_checksums = true;\n\t\tudp_conf.use_udp6_rx_checksums = true;\n\t\tif (rmcast)\n\t\t\tudp_conf.local_ip6 = in6addr_any;\n\t\telse\n\t\t\tudp_conf.local_ip6 = local.ipv6;\n\t\tub->ifindex = dev->ifindex;\n\t\tb->encap_hlen = sizeof(struct ipv6hdr) + sizeof(struct udphdr);\n\t\tb->mtu = 1280;\n#endif\n\t} else {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto err;\n\t}\n\tudp_conf.local_udp_port = local.port;\n\terr = udp_sock_create(net, &udp_conf, &ub->ubsock);\n\tif (err)\n\t\tgoto err;\n\ttuncfg.sk_user_data = ub;\n\ttuncfg.encap_type = 1;\n\ttuncfg.encap_rcv = tipc_udp_recv;\n\ttuncfg.encap_destroy = NULL;\n\tsetup_udp_tunnel_sock(net, ub->ubsock, &tuncfg);\n\n\terr = dst_cache_init(&ub->rcast.dst_cache, GFP_ATOMIC);\n\tif (err)\n\t\tgoto free;\n\n\t \n\tmemcpy(&b->bcast_addr.value, &remote, sizeof(remote));\n\tif (rmcast)\n\t\terr = enable_mcast(ub, &remote);\n\telse\n\t\terr = tipc_udp_rcast_add(b, &remote);\n\tif (err)\n\t\tgoto free;\n\n\treturn 0;\n\nfree:\n\tdst_cache_destroy(&ub->rcast.dst_cache);\n\tudp_tunnel_sock_release(ub->ubsock);\nerr:\n\tkfree(ub);\n\treturn err;\n}\n\n \nstatic void cleanup_bearer(struct work_struct *work)\n{\n\tstruct udp_bearer *ub = container_of(work, struct udp_bearer, work);\n\tstruct udp_replicast *rcast, *tmp;\n\n\tlist_for_each_entry_safe(rcast, tmp, &ub->rcast.list, list) {\n\t\tdst_cache_destroy(&rcast->dst_cache);\n\t\tlist_del_rcu(&rcast->list);\n\t\tkfree_rcu(rcast, rcu);\n\t}\n\n\tatomic_dec(&tipc_net(sock_net(ub->ubsock->sk))->wq_count);\n\tdst_cache_destroy(&ub->rcast.dst_cache);\n\tudp_tunnel_sock_release(ub->ubsock);\n\tsynchronize_net();\n\tkfree(ub);\n}\n\n \nstatic void tipc_udp_disable(struct tipc_bearer *b)\n{\n\tstruct udp_bearer *ub;\n\n\tub = rtnl_dereference(b->media_ptr);\n\tif (!ub) {\n\t\tpr_err(\"UDP bearer instance not found\\n\");\n\t\treturn;\n\t}\n\tsock_set_flag(ub->ubsock->sk, SOCK_DEAD);\n\tRCU_INIT_POINTER(ub->bearer, NULL);\n\n\t \n\tatomic_inc(&tipc_net(sock_net(ub->ubsock->sk))->wq_count);\n\tINIT_WORK(&ub->work, cleanup_bearer);\n\tschedule_work(&ub->work);\n}\n\nstruct tipc_media udp_media_info = {\n\t.send_msg\t= tipc_udp_send_msg,\n\t.enable_media\t= tipc_udp_enable,\n\t.disable_media\t= tipc_udp_disable,\n\t.addr2str\t= tipc_udp_addr2str,\n\t.addr2msg\t= tipc_udp_addr2msg,\n\t.msg2addr\t= tipc_udp_msg2addr,\n\t.priority\t= TIPC_DEF_LINK_PRI,\n\t.tolerance\t= TIPC_DEF_LINK_TOL,\n\t.min_win\t= TIPC_DEF_LINK_WIN,\n\t.max_win\t= TIPC_DEF_LINK_WIN,\n\t.mtu\t\t= TIPC_DEF_LINK_UDP_MTU,\n\t.type_id\t= TIPC_MEDIA_TYPE_UDP,\n\t.hwaddr_len\t= 0,\n\t.name\t\t= \"udp\"\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}