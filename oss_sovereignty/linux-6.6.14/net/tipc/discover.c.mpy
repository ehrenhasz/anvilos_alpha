{
  "module_name": "discover.c",
  "hash_id": "625ef5329eeace73a722bff567b7bd0b17fc4c30f4fee70ae24f4774d64239fb",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/discover.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"node.h\"\n#include \"discover.h\"\n\n \n#define TIPC_DISC_INIT\tmsecs_to_jiffies(125)\n \n#define TIPC_DISC_FAST\tmsecs_to_jiffies(1000)\n \n#define TIPC_DISC_SLOW\tmsecs_to_jiffies(60000)\n \n#define TIPC_DISC_INACTIVE\t0xffffffff\n\n \nstruct tipc_discoverer {\n\tu32 bearer_id;\n\tstruct tipc_media_addr dest;\n\tstruct net *net;\n\tu32 domain;\n\tint num_nodes;\n\tspinlock_t lock;\n\tstruct sk_buff *skb;\n\tstruct timer_list timer;\n\tunsigned long timer_intv;\n};\n\n \nstatic void tipc_disc_init_msg(struct net *net, struct sk_buff *skb,\n\t\t\t       u32 mtyp,  struct tipc_bearer *b)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tu32 dest_domain = b->domain;\n\tstruct tipc_msg *hdr;\n\n\thdr = buf_msg(skb);\n\ttipc_msg_init(tn->trial_addr, hdr, LINK_CONFIG, mtyp,\n\t\t      MAX_H_SIZE, dest_domain);\n\tmsg_set_size(hdr, MAX_H_SIZE + NODE_ID_LEN);\n\tmsg_set_non_seq(hdr, 1);\n\tmsg_set_node_sig(hdr, tn->random);\n\tmsg_set_node_capabilities(hdr, TIPC_NODE_CAPABILITIES);\n\tmsg_set_dest_domain(hdr, dest_domain);\n\tmsg_set_bc_netid(hdr, tn->net_id);\n\tb->media->addr2msg(msg_media_addr(hdr), &b->addr);\n\tmsg_set_peer_net_hash(hdr, tipc_net_hash_mixes(net, tn->random));\n\tmsg_set_node_id(hdr, tipc_own_id(net));\n}\n\nstatic void tipc_disc_msg_xmit(struct net *net, u32 mtyp, u32 dst,\n\t\t\t       u32 src, u32 sugg_addr,\n\t\t\t       struct tipc_media_addr *maddr,\n\t\t\t       struct tipc_bearer *b)\n{\n\tstruct tipc_msg *hdr;\n\tstruct sk_buff *skb;\n\n\tskb = tipc_buf_acquire(MAX_H_SIZE + NODE_ID_LEN, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\thdr = buf_msg(skb);\n\ttipc_disc_init_msg(net, skb, mtyp, b);\n\tmsg_set_sugg_node_addr(hdr, sugg_addr);\n\tmsg_set_dest_domain(hdr, dst);\n\ttipc_bearer_xmit_skb(net, b->identity, skb, maddr);\n}\n\n \nstatic void disc_dupl_alert(struct tipc_bearer *b, u32 node_addr,\n\t\t\t    struct tipc_media_addr *media_addr)\n{\n\tchar media_addr_str[64];\n\n\ttipc_media_addr_printf(media_addr_str, sizeof(media_addr_str),\n\t\t\t       media_addr);\n\tpr_warn(\"Duplicate %x using %s seen on <%s>\\n\", node_addr,\n\t\tmedia_addr_str, b->name);\n}\n\n \nstatic bool tipc_disc_addr_trial_msg(struct tipc_discoverer *d,\n\t\t\t\t     struct tipc_media_addr *maddr,\n\t\t\t\t     struct tipc_bearer *b,\n\t\t\t\t     u32 dst, u32 src,\n\t\t\t\t     u32 sugg_addr,\n\t\t\t\t     u8 *peer_id,\n\t\t\t\t     int mtyp)\n{\n\tstruct net *net = d->net;\n\tstruct tipc_net *tn = tipc_net(net);\n\tu32 self = tipc_own_addr(net);\n\tbool trial = time_before(jiffies, tn->addr_trial_end) && !self;\n\n\tif (mtyp == DSC_TRIAL_FAIL_MSG) {\n\t\tif (!trial)\n\t\t\treturn true;\n\n\t\t \n\t\tif (dst != tn->trial_addr)\n\t\t\treturn true;\n\n\t\t \n\t\ttn->trial_addr = sugg_addr;\n\t\tmsg_set_prevnode(buf_msg(d->skb), sugg_addr);\n\t\ttn->addr_trial_end = jiffies + msecs_to_jiffies(1000);\n\t\treturn true;\n\t}\n\n\t \n\tif (!trial && !self) {\n\t\tschedule_work(&tn->work);\n\t\tmsg_set_prevnode(buf_msg(d->skb), tn->trial_addr);\n\t\tmsg_set_type(buf_msg(d->skb), DSC_REQ_MSG);\n\t}\n\n\t \n\tif (mtyp != DSC_TRIAL_MSG)\n\t\treturn trial;\n\n\tsugg_addr = tipc_node_try_addr(net, peer_id, src);\n\tif (sugg_addr)\n\t\ttipc_disc_msg_xmit(net, DSC_TRIAL_FAIL_MSG, src,\n\t\t\t\t   self, sugg_addr, maddr, b);\n\treturn true;\n}\n\n \nvoid tipc_disc_rcv(struct net *net, struct sk_buff *skb,\n\t\t   struct tipc_bearer *b)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tu32 pnet_hash = msg_peer_net_hash(hdr);\n\tu16 caps = msg_node_capabilities(hdr);\n\tbool legacy = tn->legacy_addr_format;\n\tu32 sugg = msg_sugg_node_addr(hdr);\n\tu32 signature = msg_node_sig(hdr);\n\tu8 peer_id[NODE_ID_LEN] = {0,};\n\tu32 dst = msg_dest_domain(hdr);\n\tu32 net_id = msg_bc_netid(hdr);\n\tstruct tipc_media_addr maddr;\n\tu32 src = msg_prevnode(hdr);\n\tu32 mtyp = msg_type(hdr);\n\tbool dupl_addr = false;\n\tbool respond = false;\n\tu32 self;\n\tint err;\n\n\tif (skb_linearize(skb)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\thdr = buf_msg(skb);\n\n\tif (caps & TIPC_NODE_ID128)\n\t\tmemcpy(peer_id, msg_node_id(hdr), NODE_ID_LEN);\n\telse\n\t\tsprintf(peer_id, \"%x\", src);\n\n\terr = b->media->msg2addr(b, &maddr, msg_media_addr(hdr));\n\tkfree_skb(skb);\n\tif (err || maddr.broadcast) {\n\t\tpr_warn_ratelimited(\"Rcv corrupt discovery message\\n\");\n\t\treturn;\n\t}\n\t \n\tif (!memcmp(&maddr, &b->addr, sizeof(maddr)))\n\t\treturn;\n\tif (net_id != tn->net_id)\n\t\treturn;\n\tif (tipc_disc_addr_trial_msg(b->disc, &maddr, b, dst,\n\t\t\t\t     src, sugg, peer_id, mtyp))\n\t\treturn;\n\tself = tipc_own_addr(net);\n\n\t \n\tif (in_own_node(net, src)) {\n\t\tdisc_dupl_alert(b, self, &maddr);\n\t\treturn;\n\t}\n\tif (!tipc_in_scope(legacy, dst, self))\n\t\treturn;\n\tif (!tipc_in_scope(legacy, b->domain, src))\n\t\treturn;\n\ttipc_node_check_dest(net, src, peer_id, b, caps, signature, pnet_hash,\n\t\t\t     &maddr, &respond, &dupl_addr);\n\tif (dupl_addr)\n\t\tdisc_dupl_alert(b, src, &maddr);\n\tif (!respond)\n\t\treturn;\n\tif (mtyp != DSC_REQ_MSG)\n\t\treturn;\n\ttipc_disc_msg_xmit(net, DSC_RESP_MSG, src, self, 0, &maddr, b);\n}\n\n \nvoid tipc_disc_add_dest(struct tipc_discoverer *d)\n{\n\tspin_lock_bh(&d->lock);\n\td->num_nodes++;\n\tspin_unlock_bh(&d->lock);\n}\n\n \nvoid tipc_disc_remove_dest(struct tipc_discoverer *d)\n{\n\tint intv, num;\n\n\tspin_lock_bh(&d->lock);\n\td->num_nodes--;\n\tnum = d->num_nodes;\n\tintv = d->timer_intv;\n\tif (!num && (intv == TIPC_DISC_INACTIVE || intv > TIPC_DISC_FAST))  {\n\t\td->timer_intv = TIPC_DISC_INIT;\n\t\tmod_timer(&d->timer, jiffies + d->timer_intv);\n\t}\n\tspin_unlock_bh(&d->lock);\n}\n\n \nstatic void tipc_disc_timeout(struct timer_list *t)\n{\n\tstruct tipc_discoverer *d = from_timer(d, t, timer);\n\tstruct tipc_net *tn = tipc_net(d->net);\n\tstruct tipc_media_addr maddr;\n\tstruct sk_buff *skb = NULL;\n\tstruct net *net = d->net;\n\tu32 bearer_id;\n\n\tspin_lock_bh(&d->lock);\n\n\t \n\tif (tipc_node(d->domain) && d->num_nodes) {\n\t\td->timer_intv = TIPC_DISC_INACTIVE;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (!time_before(jiffies, tn->addr_trial_end) && !tipc_own_addr(net)) {\n\t\tmod_timer(&d->timer, jiffies + TIPC_DISC_INIT);\n\t\tspin_unlock_bh(&d->lock);\n\t\tschedule_work(&tn->work);\n\t\treturn;\n\t}\n\n\t \n\tif (time_before(jiffies, tn->addr_trial_end)) {\n\t\td->timer_intv = TIPC_DISC_INIT;\n\t} else {\n\t\td->timer_intv *= 2;\n\t\tif (d->num_nodes && d->timer_intv > TIPC_DISC_SLOW)\n\t\t\td->timer_intv = TIPC_DISC_SLOW;\n\t\telse if (!d->num_nodes && d->timer_intv > TIPC_DISC_FAST)\n\t\t\td->timer_intv = TIPC_DISC_FAST;\n\t\tmsg_set_type(buf_msg(d->skb), DSC_REQ_MSG);\n\t\tmsg_set_prevnode(buf_msg(d->skb), tn->trial_addr);\n\t}\n\n\tmod_timer(&d->timer, jiffies + d->timer_intv);\n\tmemcpy(&maddr, &d->dest, sizeof(maddr));\n\tskb = skb_clone(d->skb, GFP_ATOMIC);\n\tbearer_id = d->bearer_id;\nexit:\n\tspin_unlock_bh(&d->lock);\n\tif (skb)\n\t\ttipc_bearer_xmit_skb(net, bearer_id, skb, &maddr);\n}\n\n \nint tipc_disc_create(struct net *net, struct tipc_bearer *b,\n\t\t     struct tipc_media_addr *dest, struct sk_buff **skb)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_discoverer *d;\n\n\td = kmalloc(sizeof(*d), GFP_ATOMIC);\n\tif (!d)\n\t\treturn -ENOMEM;\n\td->skb = tipc_buf_acquire(MAX_H_SIZE + NODE_ID_LEN, GFP_ATOMIC);\n\tif (!d->skb) {\n\t\tkfree(d);\n\t\treturn -ENOMEM;\n\t}\n\ttipc_disc_init_msg(net, d->skb, DSC_REQ_MSG, b);\n\n\t \n\tif (!tipc_own_addr(net)) {\n\t\ttn->addr_trial_end = jiffies + msecs_to_jiffies(1000);\n\t\tmsg_set_type(buf_msg(d->skb), DSC_TRIAL_MSG);\n\t}\n\tmemcpy(&d->dest, dest, sizeof(*dest));\n\td->net = net;\n\td->bearer_id = b->identity;\n\td->domain = b->domain;\n\td->num_nodes = 0;\n\td->timer_intv = TIPC_DISC_INIT;\n\tspin_lock_init(&d->lock);\n\ttimer_setup(&d->timer, tipc_disc_timeout, 0);\n\tmod_timer(&d->timer, jiffies + d->timer_intv);\n\tb->disc = d;\n\t*skb = skb_clone(d->skb, GFP_ATOMIC);\n\treturn 0;\n}\n\n \nvoid tipc_disc_delete(struct tipc_discoverer *d)\n{\n\ttimer_shutdown_sync(&d->timer);\n\tkfree_skb(d->skb);\n\tkfree(d);\n}\n\n \nvoid tipc_disc_reset(struct net *net, struct tipc_bearer *b)\n{\n\tstruct tipc_discoverer *d = b->disc;\n\tstruct tipc_media_addr maddr;\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&d->lock);\n\ttipc_disc_init_msg(net, d->skb, DSC_REQ_MSG, b);\n\td->net = net;\n\td->bearer_id = b->identity;\n\td->domain = b->domain;\n\td->num_nodes = 0;\n\td->timer_intv = TIPC_DISC_INIT;\n\tmemcpy(&maddr, &d->dest, sizeof(maddr));\n\tmod_timer(&d->timer, jiffies + d->timer_intv);\n\tskb = skb_clone(d->skb, GFP_ATOMIC);\n\tspin_unlock_bh(&d->lock);\n\tif (skb)\n\t\ttipc_bearer_xmit_skb(net, b->identity, skb, &maddr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}