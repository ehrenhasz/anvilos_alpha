{
  "module_name": "topsrv.c",
  "hash_id": "3ce66503c1551bc090c0ec36b70b6c44deae3e35acd3fb322bfda1c3380a5822",
  "original_prompt": "Ingested from linux-6.6.14/net/tipc/topsrv.c",
  "human_readable_source": " \n\n#include \"subscr.h\"\n#include \"topsrv.h\"\n#include \"core.h\"\n#include \"socket.h\"\n#include \"addr.h\"\n#include \"msg.h\"\n#include \"bearer.h\"\n#include <net/sock.h>\n#include <linux/module.h>\n#include <trace/events/sock.h>\n\n \n#define MAX_SEND_MSG_COUNT\t25\n#define MAX_RECV_MSG_COUNT\t25\n#define CF_CONNECTED\t\t1\n\n#define TIPC_SERVER_NAME_LEN\t32\n\n \nstruct tipc_topsrv {\n\tstruct idr conn_idr;\n\tspinlock_t idr_lock;  \n\tint idr_in_use;\n\tstruct net *net;\n\tstruct work_struct awork;\n\tstruct workqueue_struct *rcv_wq;\n\tstruct workqueue_struct *send_wq;\n\tstruct socket *listener;\n\tchar name[TIPC_SERVER_NAME_LEN];\n};\n\n \nstruct tipc_conn {\n\tstruct kref kref;\n\tint conid;\n\tstruct socket *sock;\n\tunsigned long flags;\n\tstruct tipc_topsrv *server;\n\tstruct list_head sub_list;\n\tspinlock_t sub_lock;  \n\tstruct work_struct rwork;\n\tstruct list_head outqueue;\n\tspinlock_t outqueue_lock;  \n\tstruct work_struct swork;\n};\n\n \nstruct outqueue_entry {\n\tbool inactive;\n\tstruct tipc_event evt;\n\tstruct list_head list;\n};\n\nstatic void tipc_conn_recv_work(struct work_struct *work);\nstatic void tipc_conn_send_work(struct work_struct *work);\nstatic void tipc_topsrv_kern_evt(struct net *net, struct tipc_event *evt);\nstatic void tipc_conn_delete_sub(struct tipc_conn *con, struct tipc_subscr *s);\n\nstatic bool connected(struct tipc_conn *con)\n{\n\treturn con && test_bit(CF_CONNECTED, &con->flags);\n}\n\nstatic void tipc_conn_kref_release(struct kref *kref)\n{\n\tstruct tipc_conn *con = container_of(kref, struct tipc_conn, kref);\n\tstruct tipc_topsrv *s = con->server;\n\tstruct outqueue_entry *e, *safe;\n\n\tspin_lock_bh(&s->idr_lock);\n\tidr_remove(&s->conn_idr, con->conid);\n\ts->idr_in_use--;\n\tspin_unlock_bh(&s->idr_lock);\n\tif (con->sock)\n\t\tsock_release(con->sock);\n\n\tspin_lock_bh(&con->outqueue_lock);\n\tlist_for_each_entry_safe(e, safe, &con->outqueue, list) {\n\t\tlist_del(&e->list);\n\t\tkfree(e);\n\t}\n\tspin_unlock_bh(&con->outqueue_lock);\n\tkfree(con);\n}\n\nstatic void conn_put(struct tipc_conn *con)\n{\n\tkref_put(&con->kref, tipc_conn_kref_release);\n}\n\nstatic void conn_get(struct tipc_conn *con)\n{\n\tkref_get(&con->kref);\n}\n\nstatic void tipc_conn_close(struct tipc_conn *con)\n{\n\tstruct sock *sk = con->sock->sk;\n\tbool disconnect = false;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tdisconnect = test_and_clear_bit(CF_CONNECTED, &con->flags);\n\n\tif (disconnect) {\n\t\tsk->sk_user_data = NULL;\n\t\ttipc_conn_delete_sub(con, NULL);\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\t \n\tif (!disconnect)\n\t\treturn;\n\n\t \n\tkernel_sock_shutdown(con->sock, SHUT_RDWR);\n\n\tconn_put(con);\n}\n\nstatic struct tipc_conn *tipc_conn_alloc(struct tipc_topsrv *s, struct socket *sock)\n{\n\tstruct tipc_conn *con;\n\tint ret;\n\n\tcon = kzalloc(sizeof(*con), GFP_ATOMIC);\n\tif (!con)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkref_init(&con->kref);\n\tINIT_LIST_HEAD(&con->outqueue);\n\tINIT_LIST_HEAD(&con->sub_list);\n\tspin_lock_init(&con->outqueue_lock);\n\tspin_lock_init(&con->sub_lock);\n\tINIT_WORK(&con->swork, tipc_conn_send_work);\n\tINIT_WORK(&con->rwork, tipc_conn_recv_work);\n\n\tspin_lock_bh(&s->idr_lock);\n\tret = idr_alloc(&s->conn_idr, con, 0, 0, GFP_ATOMIC);\n\tif (ret < 0) {\n\t\tkfree(con);\n\t\tspin_unlock_bh(&s->idr_lock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tcon->conid = ret;\n\ts->idr_in_use++;\n\n\tset_bit(CF_CONNECTED, &con->flags);\n\tcon->server = s;\n\tcon->sock = sock;\n\tconn_get(con);\n\tspin_unlock_bh(&s->idr_lock);\n\n\treturn con;\n}\n\nstatic struct tipc_conn *tipc_conn_lookup(struct tipc_topsrv *s, int conid)\n{\n\tstruct tipc_conn *con;\n\n\tspin_lock_bh(&s->idr_lock);\n\tcon = idr_find(&s->conn_idr, conid);\n\tif (!connected(con) || !kref_get_unless_zero(&con->kref))\n\t\tcon = NULL;\n\tspin_unlock_bh(&s->idr_lock);\n\treturn con;\n}\n\n \nstatic void tipc_conn_delete_sub(struct tipc_conn *con, struct tipc_subscr *s)\n{\n\tstruct tipc_net *tn = tipc_net(con->server->net);\n\tstruct list_head *sub_list = &con->sub_list;\n\tstruct tipc_subscription *sub, *tmp;\n\n\tspin_lock_bh(&con->sub_lock);\n\tlist_for_each_entry_safe(sub, tmp, sub_list, sub_list) {\n\t\tif (!s || !memcmp(s, &sub->evt.s, sizeof(*s))) {\n\t\t\ttipc_sub_unsubscribe(sub);\n\t\t\tatomic_dec(&tn->subscription_count);\n\t\t\tif (s)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&con->sub_lock);\n}\n\nstatic void tipc_conn_send_to_sock(struct tipc_conn *con)\n{\n\tstruct list_head *queue = &con->outqueue;\n\tstruct tipc_topsrv *srv = con->server;\n\tstruct outqueue_entry *e;\n\tstruct tipc_event *evt;\n\tstruct msghdr msg;\n\tstruct kvec iov;\n\tint count = 0;\n\tint ret;\n\n\tspin_lock_bh(&con->outqueue_lock);\n\n\twhile (!list_empty(queue)) {\n\t\te = list_first_entry(queue, struct outqueue_entry, list);\n\t\tevt = &e->evt;\n\t\tspin_unlock_bh(&con->outqueue_lock);\n\n\t\tif (e->inactive)\n\t\t\ttipc_conn_delete_sub(con, &evt->s);\n\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.msg_flags = MSG_DONTWAIT;\n\t\tiov.iov_base = evt;\n\t\tiov.iov_len = sizeof(*evt);\n\t\tmsg.msg_name = NULL;\n\n\t\tif (con->sock) {\n\t\t\tret = kernel_sendmsg(con->sock, &msg, &iov,\n\t\t\t\t\t     1, sizeof(*evt));\n\t\t\tif (ret == -EWOULDBLOCK || ret == 0) {\n\t\t\t\tcond_resched();\n\t\t\t\treturn;\n\t\t\t} else if (ret < 0) {\n\t\t\t\treturn tipc_conn_close(con);\n\t\t\t}\n\t\t} else {\n\t\t\ttipc_topsrv_kern_evt(srv->net, evt);\n\t\t}\n\n\t\t \n\t\tif (++count >= MAX_SEND_MSG_COUNT) {\n\t\t\tcond_resched();\n\t\t\tcount = 0;\n\t\t}\n\t\tspin_lock_bh(&con->outqueue_lock);\n\t\tlist_del(&e->list);\n\t\tkfree(e);\n\t}\n\tspin_unlock_bh(&con->outqueue_lock);\n}\n\nstatic void tipc_conn_send_work(struct work_struct *work)\n{\n\tstruct tipc_conn *con = container_of(work, struct tipc_conn, swork);\n\n\tif (connected(con))\n\t\ttipc_conn_send_to_sock(con);\n\n\tconn_put(con);\n}\n\n \nvoid tipc_topsrv_queue_evt(struct net *net, int conid,\n\t\t\t   u32 event, struct tipc_event *evt)\n{\n\tstruct tipc_topsrv *srv = tipc_topsrv(net);\n\tstruct outqueue_entry *e;\n\tstruct tipc_conn *con;\n\n\tcon = tipc_conn_lookup(srv, conid);\n\tif (!con)\n\t\treturn;\n\n\tif (!connected(con))\n\t\tgoto err;\n\n\te = kmalloc(sizeof(*e), GFP_ATOMIC);\n\tif (!e)\n\t\tgoto err;\n\te->inactive = (event == TIPC_SUBSCR_TIMEOUT);\n\tmemcpy(&e->evt, evt, sizeof(*evt));\n\tspin_lock_bh(&con->outqueue_lock);\n\tlist_add_tail(&e->list, &con->outqueue);\n\tspin_unlock_bh(&con->outqueue_lock);\n\n\tif (queue_work(srv->send_wq, &con->swork))\n\t\treturn;\nerr:\n\tconn_put(con);\n}\n\n \nstatic void tipc_conn_write_space(struct sock *sk)\n{\n\tstruct tipc_conn *con;\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tcon = sk->sk_user_data;\n\tif (connected(con)) {\n\t\tconn_get(con);\n\t\tif (!queue_work(con->server->send_wq, &con->swork))\n\t\t\tconn_put(con);\n\t}\n\tread_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic int tipc_conn_rcv_sub(struct tipc_topsrv *srv,\n\t\t\t     struct tipc_conn *con,\n\t\t\t     struct tipc_subscr *s)\n{\n\tstruct tipc_net *tn = tipc_net(srv->net);\n\tstruct tipc_subscription *sub;\n\tu32 s_filter = tipc_sub_read(s, filter);\n\n\tif (s_filter & TIPC_SUB_CANCEL) {\n\t\ttipc_sub_write(s, filter, s_filter & ~TIPC_SUB_CANCEL);\n\t\ttipc_conn_delete_sub(con, s);\n\t\treturn 0;\n\t}\n\tif (atomic_read(&tn->subscription_count) >= TIPC_MAX_SUBSCR) {\n\t\tpr_warn(\"Subscription rejected, max (%u)\\n\", TIPC_MAX_SUBSCR);\n\t\treturn -1;\n\t}\n\tsub = tipc_sub_subscribe(srv->net, s, con->conid);\n\tif (!sub)\n\t\treturn -1;\n\tatomic_inc(&tn->subscription_count);\n\tspin_lock_bh(&con->sub_lock);\n\tlist_add(&sub->sub_list, &con->sub_list);\n\tspin_unlock_bh(&con->sub_lock);\n\treturn 0;\n}\n\nstatic int tipc_conn_rcv_from_sock(struct tipc_conn *con)\n{\n\tstruct tipc_topsrv *srv = con->server;\n\tstruct sock *sk = con->sock->sk;\n\tstruct msghdr msg = {};\n\tstruct tipc_subscr s;\n\tstruct kvec iov;\n\tint ret;\n\n\tiov.iov_base = &s;\n\tiov.iov_len = sizeof(s);\n\tmsg.msg_name = NULL;\n\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, &iov, 1, iov.iov_len);\n\tret = sock_recvmsg(con->sock, &msg, MSG_DONTWAIT);\n\tif (ret == -EWOULDBLOCK)\n\t\treturn -EWOULDBLOCK;\n\tif (ret == sizeof(s)) {\n\t\tread_lock_bh(&sk->sk_callback_lock);\n\t\t \n\t\tif (likely(connected(con)))\n\t\t\tret = tipc_conn_rcv_sub(srv, con, &s);\n\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\ttipc_conn_close(con);\n\treturn ret;\n}\n\nstatic void tipc_conn_recv_work(struct work_struct *work)\n{\n\tstruct tipc_conn *con = container_of(work, struct tipc_conn, rwork);\n\tint count = 0;\n\n\twhile (connected(con)) {\n\t\tif (tipc_conn_rcv_from_sock(con))\n\t\t\tbreak;\n\n\t\t \n\t\tif (++count >= MAX_RECV_MSG_COUNT) {\n\t\t\tcond_resched();\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tconn_put(con);\n}\n\n \nstatic void tipc_conn_data_ready(struct sock *sk)\n{\n\tstruct tipc_conn *con;\n\n\ttrace_sk_data_ready(sk);\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tcon = sk->sk_user_data;\n\tif (connected(con)) {\n\t\tconn_get(con);\n\t\tif (!queue_work(con->server->rcv_wq, &con->rwork))\n\t\t\tconn_put(con);\n\t}\n\tread_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic void tipc_topsrv_accept(struct work_struct *work)\n{\n\tstruct tipc_topsrv *srv = container_of(work, struct tipc_topsrv, awork);\n\tstruct socket *newsock, *lsock;\n\tstruct tipc_conn *con;\n\tstruct sock *newsk;\n\tint ret;\n\n\tspin_lock_bh(&srv->idr_lock);\n\tif (!srv->listener) {\n\t\tspin_unlock_bh(&srv->idr_lock);\n\t\treturn;\n\t}\n\tlsock = srv->listener;\n\tspin_unlock_bh(&srv->idr_lock);\n\n\twhile (1) {\n\t\tret = kernel_accept(lsock, &newsock, O_NONBLOCK);\n\t\tif (ret < 0)\n\t\t\treturn;\n\t\tcon = tipc_conn_alloc(srv, newsock);\n\t\tif (IS_ERR(con)) {\n\t\t\tret = PTR_ERR(con);\n\t\t\tsock_release(newsock);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tnewsk = newsock->sk;\n\t\twrite_lock_bh(&newsk->sk_callback_lock);\n\t\tnewsk->sk_data_ready = tipc_conn_data_ready;\n\t\tnewsk->sk_write_space = tipc_conn_write_space;\n\t\tnewsk->sk_user_data = con;\n\t\twrite_unlock_bh(&newsk->sk_callback_lock);\n\n\t\t \n\t\tnewsk->sk_data_ready(newsk);\n\t\tconn_put(con);\n\t}\n}\n\n \nstatic void tipc_topsrv_listener_data_ready(struct sock *sk)\n{\n\tstruct tipc_topsrv *srv;\n\n\ttrace_sk_data_ready(sk);\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tsrv = sk->sk_user_data;\n\tif (srv)\n\t\tqueue_work(srv->rcv_wq, &srv->awork);\n\tread_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic int tipc_topsrv_create_listener(struct tipc_topsrv *srv)\n{\n\tstruct socket *lsock = NULL;\n\tstruct sockaddr_tipc saddr;\n\tstruct sock *sk;\n\tint rc;\n\n\trc = sock_create_kern(srv->net, AF_TIPC, SOCK_SEQPACKET, 0, &lsock);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tsrv->listener = lsock;\n\tsk = lsock->sk;\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk->sk_data_ready = tipc_topsrv_listener_data_ready;\n\tsk->sk_user_data = srv;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\tlock_sock(sk);\n\trc = tsk_set_importance(sk, TIPC_CRITICAL_IMPORTANCE);\n\trelease_sock(sk);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tsaddr.family\t                = AF_TIPC;\n\tsaddr.addrtype\t\t        = TIPC_SERVICE_RANGE;\n\tsaddr.addr.nameseq.type\t= TIPC_TOP_SRV;\n\tsaddr.addr.nameseq.lower\t= TIPC_TOP_SRV;\n\tsaddr.addr.nameseq.upper\t= TIPC_TOP_SRV;\n\tsaddr.scope\t\t\t= TIPC_NODE_SCOPE;\n\n\trc = tipc_sk_bind(lsock, (struct sockaddr *)&saddr, sizeof(saddr));\n\tif (rc < 0)\n\t\tgoto err;\n\trc = kernel_listen(lsock, 0);\n\tif (rc < 0)\n\t\tgoto err;\n\n\t \n\tmodule_put(lsock->ops->owner);\n\tmodule_put(sk->sk_prot_creator->owner);\n\n\treturn 0;\nerr:\n\tsock_release(lsock);\n\treturn -EINVAL;\n}\n\nbool tipc_topsrv_kern_subscr(struct net *net, u32 port, u32 type, u32 lower,\n\t\t\t     u32 upper, u32 filter, int *conid)\n{\n\tstruct tipc_subscr sub;\n\tstruct tipc_conn *con;\n\tint rc;\n\n\tsub.seq.type = type;\n\tsub.seq.lower = lower;\n\tsub.seq.upper = upper;\n\tsub.timeout = TIPC_WAIT_FOREVER;\n\tsub.filter = filter;\n\t*(u64 *)&sub.usr_handle = (u64)port;\n\n\tcon = tipc_conn_alloc(tipc_topsrv(net), NULL);\n\tif (IS_ERR(con))\n\t\treturn false;\n\n\t*conid = con->conid;\n\trc = tipc_conn_rcv_sub(tipc_topsrv(net), con, &sub);\n\tif (rc)\n\t\tconn_put(con);\n\n\tconn_put(con);\n\treturn !rc;\n}\n\nvoid tipc_topsrv_kern_unsubscr(struct net *net, int conid)\n{\n\tstruct tipc_conn *con;\n\n\tcon = tipc_conn_lookup(tipc_topsrv(net), conid);\n\tif (!con)\n\t\treturn;\n\n\ttest_and_clear_bit(CF_CONNECTED, &con->flags);\n\ttipc_conn_delete_sub(con, NULL);\n\tconn_put(con);\n\tconn_put(con);\n}\n\nstatic void tipc_topsrv_kern_evt(struct net *net, struct tipc_event *evt)\n{\n\tu32 port = *(u32 *)&evt->s.usr_handle;\n\tu32 self = tipc_own_addr(net);\n\tstruct sk_buff_head evtq;\n\tstruct sk_buff *skb;\n\n\tskb = tipc_msg_create(TOP_SRV, 0, INT_H_SIZE, sizeof(*evt),\n\t\t\t      self, self, port, port, 0);\n\tif (!skb)\n\t\treturn;\n\tmsg_set_dest_droppable(buf_msg(skb), true);\n\tmemcpy(msg_data(buf_msg(skb)), evt, sizeof(*evt));\n\tskb_queue_head_init(&evtq);\n\t__skb_queue_tail(&evtq, skb);\n\ttipc_loopback_trace(net, &evtq);\n\ttipc_sk_rcv(net, &evtq);\n}\n\nstatic int tipc_topsrv_work_start(struct tipc_topsrv *s)\n{\n\ts->rcv_wq = alloc_ordered_workqueue(\"tipc_rcv\", 0);\n\tif (!s->rcv_wq) {\n\t\tpr_err(\"can't start tipc receive workqueue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ts->send_wq = alloc_ordered_workqueue(\"tipc_send\", 0);\n\tif (!s->send_wq) {\n\t\tpr_err(\"can't start tipc send workqueue\\n\");\n\t\tdestroy_workqueue(s->rcv_wq);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void tipc_topsrv_work_stop(struct tipc_topsrv *s)\n{\n\tdestroy_workqueue(s->rcv_wq);\n\tdestroy_workqueue(s->send_wq);\n}\n\nstatic int tipc_topsrv_start(struct net *net)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tconst char name[] = \"topology_server\";\n\tstruct tipc_topsrv *srv;\n\tint ret;\n\n\tsrv = kzalloc(sizeof(*srv), GFP_ATOMIC);\n\tif (!srv)\n\t\treturn -ENOMEM;\n\n\tsrv->net = net;\n\tINIT_WORK(&srv->awork, tipc_topsrv_accept);\n\n\tstrscpy(srv->name, name, sizeof(srv->name));\n\ttn->topsrv = srv;\n\tatomic_set(&tn->subscription_count, 0);\n\n\tspin_lock_init(&srv->idr_lock);\n\tidr_init(&srv->conn_idr);\n\tsrv->idr_in_use = 0;\n\n\tret = tipc_topsrv_work_start(srv);\n\tif (ret < 0)\n\t\tgoto err_start;\n\n\tret = tipc_topsrv_create_listener(srv);\n\tif (ret < 0)\n\t\tgoto err_create;\n\n\treturn 0;\n\nerr_create:\n\ttipc_topsrv_work_stop(srv);\nerr_start:\n\tkfree(srv);\n\treturn ret;\n}\n\nstatic void tipc_topsrv_stop(struct net *net)\n{\n\tstruct tipc_topsrv *srv = tipc_topsrv(net);\n\tstruct socket *lsock = srv->listener;\n\tstruct tipc_conn *con;\n\tint id;\n\n\tspin_lock_bh(&srv->idr_lock);\n\tfor (id = 0; srv->idr_in_use; id++) {\n\t\tcon = idr_find(&srv->conn_idr, id);\n\t\tif (con) {\n\t\t\tspin_unlock_bh(&srv->idr_lock);\n\t\t\ttipc_conn_close(con);\n\t\t\tspin_lock_bh(&srv->idr_lock);\n\t\t}\n\t}\n\t__module_get(lsock->ops->owner);\n\t__module_get(lsock->sk->sk_prot_creator->owner);\n\tsrv->listener = NULL;\n\tspin_unlock_bh(&srv->idr_lock);\n\n\ttipc_topsrv_work_stop(srv);\n\tsock_release(lsock);\n\tidr_destroy(&srv->conn_idr);\n\tkfree(srv);\n}\n\nint __net_init tipc_topsrv_init_net(struct net *net)\n{\n\treturn tipc_topsrv_start(net);\n}\n\nvoid __net_exit tipc_topsrv_exit_net(struct net *net)\n{\n\ttipc_topsrv_stop(net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}