{
  "module_name": "fddi.c",
  "hash_id": "f0d382296dd953600143c1cb6eac3986fc75fd141bf3859517fa244e3de424bc",
  "original_prompt": "Ingested from linux-6.6.14/net/802/fddi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/fddidevice.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <net/arp.h>\n#include <net/sock.h>\n\n \n\nstatic int fddi_header(struct sk_buff *skb, struct net_device *dev,\n\t\t       unsigned short type,\n\t\t       const void *daddr, const void *saddr, unsigned int len)\n{\n\tint hl = FDDI_K_SNAP_HLEN;\n\tstruct fddihdr *fddi;\n\n\tif(type != ETH_P_IP && type != ETH_P_IPV6 && type != ETH_P_ARP)\n\t\thl=FDDI_K_8022_HLEN-3;\n\tfddi = skb_push(skb, hl);\n\tfddi->fc\t\t\t = FDDI_FC_K_ASYNC_LLC_DEF;\n\tif(type == ETH_P_IP || type == ETH_P_IPV6 || type == ETH_P_ARP)\n\t{\n\t\tfddi->hdr.llc_snap.dsap\t\t = FDDI_EXTENDED_SAP;\n\t\tfddi->hdr.llc_snap.ssap\t\t = FDDI_EXTENDED_SAP;\n\t\tfddi->hdr.llc_snap.ctrl\t\t = FDDI_UI_CMD;\n\t\tfddi->hdr.llc_snap.oui[0]\t = 0x00;\n\t\tfddi->hdr.llc_snap.oui[1]\t = 0x00;\n\t\tfddi->hdr.llc_snap.oui[2]\t = 0x00;\n\t\tfddi->hdr.llc_snap.ethertype\t = htons(type);\n\t}\n\n\t \n\n\tif (saddr != NULL)\n\t\tmemcpy(fddi->saddr, saddr, dev->addr_len);\n\telse\n\t\tmemcpy(fddi->saddr, dev->dev_addr, dev->addr_len);\n\n\tif (daddr != NULL)\n\t{\n\t\tmemcpy(fddi->daddr, daddr, dev->addr_len);\n\t\treturn hl;\n\t}\n\n\treturn -hl;\n}\n\n \n\n__be16 fddi_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct fddihdr *fddi = (struct fddihdr *)skb->data;\n\t__be16 type;\n\n\t \n\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\t \n\n\tif(fddi->hdr.llc_8022_1.dsap==0xe0)\n\t{\n\t\tskb_pull(skb, FDDI_K_8022_HLEN-3);\n\t\ttype = htons(ETH_P_802_2);\n\t}\n\telse\n\t{\n\t\tskb_pull(skb, FDDI_K_SNAP_HLEN);\t\t \n\t\ttype=fddi->hdr.llc_snap.ethertype;\n\t}\n\n\t \n\n\tif (*fddi->daddr & 0x01)\n\t{\n\t\tif (memcmp(fddi->daddr, dev->broadcast, FDDI_K_ALEN) == 0)\n\t\t\tskb->pkt_type = PACKET_BROADCAST;\n\t\telse\n\t\t\tskb->pkt_type = PACKET_MULTICAST;\n\t}\n\n\telse if (dev->flags & IFF_PROMISC)\n\t{\n\t\tif (memcmp(fddi->daddr, dev->dev_addr, FDDI_K_ALEN))\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t}\n\n\t \n\n\treturn type;\n}\n\nEXPORT_SYMBOL(fddi_type_trans);\n\nstatic const struct header_ops fddi_header_ops = {\n\t.create\t\t= fddi_header,\n};\n\n\nstatic void fddi_setup(struct net_device *dev)\n{\n\tdev->header_ops\t\t= &fddi_header_ops;\n\tdev->type\t\t= ARPHRD_FDDI;\n\tdev->hard_header_len\t= FDDI_K_SNAP_HLEN+3;\t \n\tdev->mtu\t\t= FDDI_K_SNAP_DLEN;\t \n\tdev->min_mtu\t\t= FDDI_K_SNAP_HLEN;\n\tdev->max_mtu\t\t= FDDI_K_SNAP_DLEN;\n\tdev->addr_len\t\t= FDDI_K_ALEN;\n\tdev->tx_queue_len\t= 100;\t\t\t \n\tdev->flags\t\t= IFF_BROADCAST | IFF_MULTICAST;\n\n\tmemset(dev->broadcast, 0xFF, FDDI_K_ALEN);\n}\n\n \nstruct net_device *alloc_fddidev(int sizeof_priv)\n{\n\treturn alloc_netdev(sizeof_priv, \"fddi%d\", NET_NAME_UNKNOWN,\n\t\t\t    fddi_setup);\n}\nEXPORT_SYMBOL(alloc_fddidev);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}