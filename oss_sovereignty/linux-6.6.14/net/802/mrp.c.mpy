{
  "module_name": "mrp.c",
  "hash_id": "fc474a382e4251859a223ea27e972d2df5f81348d029b4734e149e3e8ab9e157",
  "original_prompt": "Ingested from linux-6.6.14/net/802/mrp.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <net/mrp.h>\n#include <asm/unaligned.h>\n\nstatic unsigned int mrp_join_time __read_mostly = 200;\nmodule_param(mrp_join_time, uint, 0644);\nMODULE_PARM_DESC(mrp_join_time, \"Join time in ms (default 200ms)\");\n\nstatic unsigned int mrp_periodic_time __read_mostly = 1000;\nmodule_param(mrp_periodic_time, uint, 0644);\nMODULE_PARM_DESC(mrp_periodic_time, \"Periodic time in ms (default 1s)\");\n\nMODULE_LICENSE(\"GPL\");\n\nstatic const u8\nmrp_applicant_state_table[MRP_APPLICANT_MAX + 1][MRP_EVENT_MAX + 1] = {\n\t[MRP_APPLICANT_VO] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_AO,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_VO,\n\t},\n\t[MRP_APPLICANT_VP] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_AA,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_AP,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_VP,\n\t},\n\t[MRP_APPLICANT_VN] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_AN,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_VN,\n\t},\n\t[MRP_APPLICANT_AN] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_AN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_AN,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_QA,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_AN,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_AN,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_AN,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_AN,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_AN,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_AN,\n\t},\n\t[MRP_APPLICANT_AA] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_AA,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_QA,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_AA,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_QA,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_AA,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_AA,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_AA,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_AA,\n\t},\n\t[MRP_APPLICANT_QA] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_QA,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_QA,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_QA,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_QA,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_QA,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_AA,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_AA,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_AA,\n\t},\n\t[MRP_APPLICANT_LA] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_AA,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_LA,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_LA,\n\t},\n\t[MRP_APPLICANT_AO] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_AP,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_AO,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_AO,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_AO,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_QO,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_AO,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_AO,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_AO,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_AO,\n\t},\n\t[MRP_APPLICANT_QO] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_QP,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_QO,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_QO,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_QO,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_QO,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_QO,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_AO,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_AO,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_VO,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_QO,\n\t},\n\t[MRP_APPLICANT_AP] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_AP,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_AO,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_QA,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_AP,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_QP,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_AP,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_AP,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_AP,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_AP,\n\t},\n\t[MRP_APPLICANT_QP] = {\n\t\t[MRP_EVENT_NEW]\t\t= MRP_APPLICANT_VN,\n\t\t[MRP_EVENT_JOIN]\t= MRP_APPLICANT_QP,\n\t\t[MRP_EVENT_LV]\t\t= MRP_APPLICANT_QO,\n\t\t[MRP_EVENT_TX]\t\t= MRP_APPLICANT_QP,\n\t\t[MRP_EVENT_R_NEW]\t= MRP_APPLICANT_QP,\n\t\t[MRP_EVENT_R_JOIN_IN]\t= MRP_APPLICANT_QP,\n\t\t[MRP_EVENT_R_IN]\t= MRP_APPLICANT_QP,\n\t\t[MRP_EVENT_R_JOIN_MT]\t= MRP_APPLICANT_AP,\n\t\t[MRP_EVENT_R_MT]\t= MRP_APPLICANT_AP,\n\t\t[MRP_EVENT_R_LV]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_R_LA]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_REDECLARE]\t= MRP_APPLICANT_VP,\n\t\t[MRP_EVENT_PERIODIC]\t= MRP_APPLICANT_AP,\n\t},\n};\n\nstatic const u8\nmrp_tx_action_table[MRP_APPLICANT_MAX + 1] = {\n\t[MRP_APPLICANT_VO] = MRP_TX_ACTION_S_IN_OPTIONAL,\n\t[MRP_APPLICANT_VP] = MRP_TX_ACTION_S_JOIN_IN,\n\t[MRP_APPLICANT_VN] = MRP_TX_ACTION_S_NEW,\n\t[MRP_APPLICANT_AN] = MRP_TX_ACTION_S_NEW,\n\t[MRP_APPLICANT_AA] = MRP_TX_ACTION_S_JOIN_IN,\n\t[MRP_APPLICANT_QA] = MRP_TX_ACTION_S_JOIN_IN_OPTIONAL,\n\t[MRP_APPLICANT_LA] = MRP_TX_ACTION_S_LV,\n\t[MRP_APPLICANT_AO] = MRP_TX_ACTION_S_IN_OPTIONAL,\n\t[MRP_APPLICANT_QO] = MRP_TX_ACTION_S_IN_OPTIONAL,\n\t[MRP_APPLICANT_AP] = MRP_TX_ACTION_S_JOIN_IN,\n\t[MRP_APPLICANT_QP] = MRP_TX_ACTION_S_IN_OPTIONAL,\n};\n\nstatic void mrp_attrvalue_inc(void *value, u8 len)\n{\n\tu8 *v = (u8 *)value;\n\n\t \n\twhile (len > 0 && !++v[--len])\n\t\t;\n}\n\nstatic int mrp_attr_cmp(const struct mrp_attr *attr,\n\t\t\t const void *value, u8 len, u8 type)\n{\n\tif (attr->type != type)\n\t\treturn attr->type - type;\n\tif (attr->len != len)\n\t\treturn attr->len - len;\n\treturn memcmp(attr->value, value, len);\n}\n\nstatic struct mrp_attr *mrp_attr_lookup(const struct mrp_applicant *app,\n\t\t\t\t\tconst void *value, u8 len, u8 type)\n{\n\tstruct rb_node *parent = app->mad.rb_node;\n\tstruct mrp_attr *attr;\n\tint d;\n\n\twhile (parent) {\n\t\tattr = rb_entry(parent, struct mrp_attr, node);\n\t\td = mrp_attr_cmp(attr, value, len, type);\n\t\tif (d > 0)\n\t\t\tparent = parent->rb_left;\n\t\telse if (d < 0)\n\t\t\tparent = parent->rb_right;\n\t\telse\n\t\t\treturn attr;\n\t}\n\treturn NULL;\n}\n\nstatic struct mrp_attr *mrp_attr_create(struct mrp_applicant *app,\n\t\t\t\t\tconst void *value, u8 len, u8 type)\n{\n\tstruct rb_node *parent = NULL, **p = &app->mad.rb_node;\n\tstruct mrp_attr *attr;\n\tint d;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tattr = rb_entry(parent, struct mrp_attr, node);\n\t\td = mrp_attr_cmp(attr, value, len, type);\n\t\tif (d > 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (d < 0)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\t \n\t\t\treturn attr;\n\t\t}\n\t}\n\tattr = kmalloc(sizeof(*attr) + len, GFP_ATOMIC);\n\tif (!attr)\n\t\treturn attr;\n\tattr->state = MRP_APPLICANT_VO;\n\tattr->type  = type;\n\tattr->len   = len;\n\tmemcpy(attr->value, value, len);\n\n\trb_link_node(&attr->node, parent, p);\n\trb_insert_color(&attr->node, &app->mad);\n\treturn attr;\n}\n\nstatic void mrp_attr_destroy(struct mrp_applicant *app, struct mrp_attr *attr)\n{\n\trb_erase(&attr->node, &app->mad);\n\tkfree(attr);\n}\n\nstatic void mrp_attr_destroy_all(struct mrp_applicant *app)\n{\n\tstruct rb_node *node, *next;\n\tstruct mrp_attr *attr;\n\n\tfor (node = rb_first(&app->mad);\n\t     next = node ? rb_next(node) : NULL, node != NULL;\n\t     node = next) {\n\t\tattr = rb_entry(node, struct mrp_attr, node);\n\t\tmrp_attr_destroy(app, attr);\n\t}\n}\n\nstatic int mrp_pdu_init(struct mrp_applicant *app)\n{\n\tstruct sk_buff *skb;\n\tstruct mrp_pdu_hdr *ph;\n\n\tskb = alloc_skb(app->dev->mtu + LL_RESERVED_SPACE(app->dev),\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb->dev = app->dev;\n\tskb->protocol = app->app->pkttype.type;\n\tskb_reserve(skb, LL_RESERVED_SPACE(app->dev));\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\n\tph = __skb_put(skb, sizeof(*ph));\n\tph->version = app->app->version;\n\n\tapp->pdu = skb;\n\treturn 0;\n}\n\nstatic int mrp_pdu_append_end_mark(struct mrp_applicant *app)\n{\n\t__be16 *endmark;\n\n\tif (skb_tailroom(app->pdu) < sizeof(*endmark))\n\t\treturn -1;\n\tendmark = __skb_put(app->pdu, sizeof(*endmark));\n\tput_unaligned(MRP_END_MARK, endmark);\n\treturn 0;\n}\n\nstatic void mrp_pdu_queue(struct mrp_applicant *app)\n{\n\tif (!app->pdu)\n\t\treturn;\n\n\tif (mrp_cb(app->pdu)->mh)\n\t\tmrp_pdu_append_end_mark(app);\n\tmrp_pdu_append_end_mark(app);\n\n\tdev_hard_header(app->pdu, app->dev, ntohs(app->app->pkttype.type),\n\t\t\tapp->app->group_address, app->dev->dev_addr,\n\t\t\tapp->pdu->len);\n\n\tskb_queue_tail(&app->queue, app->pdu);\n\tapp->pdu = NULL;\n}\n\nstatic void mrp_queue_xmit(struct mrp_applicant *app)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&app->queue)))\n\t\tdev_queue_xmit(skb);\n}\n\nstatic int mrp_pdu_append_msg_hdr(struct mrp_applicant *app,\n\t\t\t\t  u8 attrtype, u8 attrlen)\n{\n\tstruct mrp_msg_hdr *mh;\n\n\tif (mrp_cb(app->pdu)->mh) {\n\t\tif (mrp_pdu_append_end_mark(app) < 0)\n\t\t\treturn -1;\n\t\tmrp_cb(app->pdu)->mh = NULL;\n\t\tmrp_cb(app->pdu)->vah = NULL;\n\t}\n\n\tif (skb_tailroom(app->pdu) < sizeof(*mh))\n\t\treturn -1;\n\tmh = __skb_put(app->pdu, sizeof(*mh));\n\tmh->attrtype = attrtype;\n\tmh->attrlen = attrlen;\n\tmrp_cb(app->pdu)->mh = mh;\n\treturn 0;\n}\n\nstatic int mrp_pdu_append_vecattr_hdr(struct mrp_applicant *app,\n\t\t\t\t      const void *firstattrvalue, u8 attrlen)\n{\n\tstruct mrp_vecattr_hdr *vah;\n\n\tif (skb_tailroom(app->pdu) < sizeof(*vah) + attrlen)\n\t\treturn -1;\n\tvah = __skb_put(app->pdu, sizeof(*vah) + attrlen);\n\tput_unaligned(0, &vah->lenflags);\n\tmemcpy(vah->firstattrvalue, firstattrvalue, attrlen);\n\tmrp_cb(app->pdu)->vah = vah;\n\tmemcpy(mrp_cb(app->pdu)->attrvalue, firstattrvalue, attrlen);\n\treturn 0;\n}\n\nstatic int mrp_pdu_append_vecattr_event(struct mrp_applicant *app,\n\t\t\t\t\tconst struct mrp_attr *attr,\n\t\t\t\t\tenum mrp_vecattr_event vaevent)\n{\n\tu16 len, pos;\n\tu8 *vaevents;\n\tint err;\nagain:\n\tif (!app->pdu) {\n\t\terr = mrp_pdu_init(app);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!mrp_cb(app->pdu)->mh ||\n\t    mrp_cb(app->pdu)->mh->attrtype != attr->type ||\n\t    mrp_cb(app->pdu)->mh->attrlen != attr->len) {\n\t\tif (mrp_pdu_append_msg_hdr(app, attr->type, attr->len) < 0)\n\t\t\tgoto queue;\n\t}\n\n\t \n\tif (!mrp_cb(app->pdu)->vah ||\n\t    memcmp(mrp_cb(app->pdu)->attrvalue, attr->value, attr->len)) {\n\t\tif (mrp_pdu_append_vecattr_hdr(app, attr->value, attr->len) < 0)\n\t\t\tgoto queue;\n\t}\n\n\tlen = be16_to_cpu(get_unaligned(&mrp_cb(app->pdu)->vah->lenflags));\n\tpos = len % 3;\n\n\t \n\tif (!pos) {\n\t\tif (skb_tailroom(app->pdu) < sizeof(u8))\n\t\t\tgoto queue;\n\t\tvaevents = __skb_put(app->pdu, sizeof(u8));\n\t} else {\n\t\tvaevents = (u8 *)(skb_tail_pointer(app->pdu) - sizeof(u8));\n\t}\n\n\tswitch (pos) {\n\tcase 0:\n\t\t*vaevents = vaevent * (__MRP_VECATTR_EVENT_MAX *\n\t\t\t\t       __MRP_VECATTR_EVENT_MAX);\n\t\tbreak;\n\tcase 1:\n\t\t*vaevents += vaevent * __MRP_VECATTR_EVENT_MAX;\n\t\tbreak;\n\tcase 2:\n\t\t*vaevents += vaevent;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\t \n\tput_unaligned(cpu_to_be16(++len), &mrp_cb(app->pdu)->vah->lenflags);\n\tmrp_attrvalue_inc(mrp_cb(app->pdu)->attrvalue, attr->len);\n\n\treturn 0;\n\nqueue:\n\tmrp_pdu_queue(app);\n\tgoto again;\n}\n\nstatic void mrp_attr_event(struct mrp_applicant *app,\n\t\t\t   struct mrp_attr *attr, enum mrp_event event)\n{\n\tenum mrp_applicant_state state;\n\n\tstate = mrp_applicant_state_table[attr->state][event];\n\tif (state == MRP_APPLICANT_INVALID) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (event == MRP_EVENT_TX) {\n\t\t \n\n\t\tswitch (mrp_tx_action_table[attr->state]) {\n\t\tcase MRP_TX_ACTION_NONE:\n\t\tcase MRP_TX_ACTION_S_JOIN_IN_OPTIONAL:\n\t\tcase MRP_TX_ACTION_S_IN_OPTIONAL:\n\t\t\tbreak;\n\t\tcase MRP_TX_ACTION_S_NEW:\n\t\t\tif (mrp_pdu_append_vecattr_event(\n\t\t\t\t    app, attr, MRP_VECATTR_EVENT_NEW) < 0)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase MRP_TX_ACTION_S_JOIN_IN:\n\t\t\tif (mrp_pdu_append_vecattr_event(\n\t\t\t\t    app, attr, MRP_VECATTR_EVENT_JOIN_IN) < 0)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase MRP_TX_ACTION_S_LV:\n\t\t\tif (mrp_pdu_append_vecattr_event(\n\t\t\t\t    app, attr, MRP_VECATTR_EVENT_LV) < 0)\n\t\t\t\treturn;\n\t\t\t \n\t\t\tmrp_attr_destroy(app, attr);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\n\tattr->state = state;\n}\n\nint mrp_request_join(const struct net_device *dev,\n\t\t     const struct mrp_application *appl,\n\t\t     const void *value, u8 len, u8 type)\n{\n\tstruct mrp_port *port = rtnl_dereference(dev->mrp_port);\n\tstruct mrp_applicant *app = rtnl_dereference(\n\t\tport->applicants[appl->type]);\n\tstruct mrp_attr *attr;\n\n\tif (sizeof(struct mrp_skb_cb) + len >\n\t    sizeof_field(struct sk_buff, cb))\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&app->lock);\n\tattr = mrp_attr_create(app, value, len, type);\n\tif (!attr) {\n\t\tspin_unlock_bh(&app->lock);\n\t\treturn -ENOMEM;\n\t}\n\tmrp_attr_event(app, attr, MRP_EVENT_JOIN);\n\tspin_unlock_bh(&app->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mrp_request_join);\n\nvoid mrp_request_leave(const struct net_device *dev,\n\t\t       const struct mrp_application *appl,\n\t\t       const void *value, u8 len, u8 type)\n{\n\tstruct mrp_port *port = rtnl_dereference(dev->mrp_port);\n\tstruct mrp_applicant *app = rtnl_dereference(\n\t\tport->applicants[appl->type]);\n\tstruct mrp_attr *attr;\n\n\tif (sizeof(struct mrp_skb_cb) + len >\n\t    sizeof_field(struct sk_buff, cb))\n\t\treturn;\n\n\tspin_lock_bh(&app->lock);\n\tattr = mrp_attr_lookup(app, value, len, type);\n\tif (!attr) {\n\t\tspin_unlock_bh(&app->lock);\n\t\treturn;\n\t}\n\tmrp_attr_event(app, attr, MRP_EVENT_LV);\n\tspin_unlock_bh(&app->lock);\n}\nEXPORT_SYMBOL_GPL(mrp_request_leave);\n\nstatic void mrp_mad_event(struct mrp_applicant *app, enum mrp_event event)\n{\n\tstruct rb_node *node, *next;\n\tstruct mrp_attr *attr;\n\n\tfor (node = rb_first(&app->mad);\n\t     next = node ? rb_next(node) : NULL, node != NULL;\n\t     node = next) {\n\t\tattr = rb_entry(node, struct mrp_attr, node);\n\t\tmrp_attr_event(app, attr, event);\n\t}\n}\n\nstatic void mrp_join_timer_arm(struct mrp_applicant *app)\n{\n\tunsigned long delay;\n\n\tdelay = get_random_u32_below(msecs_to_jiffies(mrp_join_time));\n\tmod_timer(&app->join_timer, jiffies + delay);\n}\n\nstatic void mrp_join_timer(struct timer_list *t)\n{\n\tstruct mrp_applicant *app = from_timer(app, t, join_timer);\n\n\tspin_lock(&app->lock);\n\tmrp_mad_event(app, MRP_EVENT_TX);\n\tmrp_pdu_queue(app);\n\tspin_unlock(&app->lock);\n\n\tmrp_queue_xmit(app);\n\tspin_lock(&app->lock);\n\tif (likely(app->active))\n\t\tmrp_join_timer_arm(app);\n\tspin_unlock(&app->lock);\n}\n\nstatic void mrp_periodic_timer_arm(struct mrp_applicant *app)\n{\n\tmod_timer(&app->periodic_timer,\n\t\t  jiffies + msecs_to_jiffies(mrp_periodic_time));\n}\n\nstatic void mrp_periodic_timer(struct timer_list *t)\n{\n\tstruct mrp_applicant *app = from_timer(app, t, periodic_timer);\n\n\tspin_lock(&app->lock);\n\tif (likely(app->active)) {\n\t\tmrp_mad_event(app, MRP_EVENT_PERIODIC);\n\t\tmrp_pdu_queue(app);\n\t\tmrp_periodic_timer_arm(app);\n\t}\n\tspin_unlock(&app->lock);\n}\n\nstatic int mrp_pdu_parse_end_mark(struct sk_buff *skb, int *offset)\n{\n\t__be16 endmark;\n\n\tif (skb_copy_bits(skb, *offset, &endmark, sizeof(endmark)) < 0)\n\t\treturn -1;\n\tif (endmark == MRP_END_MARK) {\n\t\t*offset += sizeof(endmark);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void mrp_pdu_parse_vecattr_event(struct mrp_applicant *app,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tenum mrp_vecattr_event vaevent)\n{\n\tstruct mrp_attr *attr;\n\tenum mrp_event event;\n\n\tattr = mrp_attr_lookup(app, mrp_cb(skb)->attrvalue,\n\t\t\t       mrp_cb(skb)->mh->attrlen,\n\t\t\t       mrp_cb(skb)->mh->attrtype);\n\tif (attr == NULL)\n\t\treturn;\n\n\tswitch (vaevent) {\n\tcase MRP_VECATTR_EVENT_NEW:\n\t\tevent = MRP_EVENT_R_NEW;\n\t\tbreak;\n\tcase MRP_VECATTR_EVENT_JOIN_IN:\n\t\tevent = MRP_EVENT_R_JOIN_IN;\n\t\tbreak;\n\tcase MRP_VECATTR_EVENT_IN:\n\t\tevent = MRP_EVENT_R_IN;\n\t\tbreak;\n\tcase MRP_VECATTR_EVENT_JOIN_MT:\n\t\tevent = MRP_EVENT_R_JOIN_MT;\n\t\tbreak;\n\tcase MRP_VECATTR_EVENT_MT:\n\t\tevent = MRP_EVENT_R_MT;\n\t\tbreak;\n\tcase MRP_VECATTR_EVENT_LV:\n\t\tevent = MRP_EVENT_R_LV;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tmrp_attr_event(app, attr, event);\n}\n\nstatic int mrp_pdu_parse_vecattr(struct mrp_applicant *app,\n\t\t\t\t struct sk_buff *skb, int *offset)\n{\n\tstruct mrp_vecattr_hdr _vah;\n\tu16 valen;\n\tu8 vaevents, vaevent;\n\n\tmrp_cb(skb)->vah = skb_header_pointer(skb, *offset, sizeof(_vah),\n\t\t\t\t\t      &_vah);\n\tif (!mrp_cb(skb)->vah)\n\t\treturn -1;\n\t*offset += sizeof(_vah);\n\n\tif (get_unaligned(&mrp_cb(skb)->vah->lenflags) &\n\t    MRP_VECATTR_HDR_FLAG_LA)\n\t\tmrp_mad_event(app, MRP_EVENT_R_LA);\n\tvalen = be16_to_cpu(get_unaligned(&mrp_cb(skb)->vah->lenflags) &\n\t\t\t    MRP_VECATTR_HDR_LEN_MASK);\n\n\t \n\tif (sizeof(struct mrp_skb_cb) + mrp_cb(skb)->mh->attrlen >\n\t    sizeof_field(struct sk_buff, cb))\n\t\treturn -1;\n\tif (skb_copy_bits(skb, *offset, mrp_cb(skb)->attrvalue,\n\t\t\t  mrp_cb(skb)->mh->attrlen) < 0)\n\t\treturn -1;\n\t*offset += mrp_cb(skb)->mh->attrlen;\n\n\t \n\twhile (valen > 0) {\n\t\tif (skb_copy_bits(skb, *offset, &vaevents,\n\t\t\t\t  sizeof(vaevents)) < 0)\n\t\t\treturn -1;\n\t\t*offset += sizeof(vaevents);\n\n\t\t \n\t\tvaevent = vaevents / (__MRP_VECATTR_EVENT_MAX *\n\t\t\t\t      __MRP_VECATTR_EVENT_MAX);\n\t\tif (vaevent >= __MRP_VECATTR_EVENT_MAX) {\n\t\t\t \n\t\t\treturn -1;\n\t\t}\n\t\tmrp_pdu_parse_vecattr_event(app, skb, vaevent);\n\n\t\t \n\t\tif (!--valen)\n\t\t\tbreak;\n\t\tmrp_attrvalue_inc(mrp_cb(skb)->attrvalue,\n\t\t\t\t  mrp_cb(skb)->mh->attrlen);\n\t\tvaevents %= (__MRP_VECATTR_EVENT_MAX *\n\t\t\t     __MRP_VECATTR_EVENT_MAX);\n\t\tvaevent = vaevents / __MRP_VECATTR_EVENT_MAX;\n\t\tmrp_pdu_parse_vecattr_event(app, skb, vaevent);\n\n\t\t \n\t\tif (!--valen)\n\t\t\tbreak;\n\t\tmrp_attrvalue_inc(mrp_cb(skb)->attrvalue,\n\t\t\t\t  mrp_cb(skb)->mh->attrlen);\n\t\tvaevents %= __MRP_VECATTR_EVENT_MAX;\n\t\tvaevent = vaevents;\n\t\tmrp_pdu_parse_vecattr_event(app, skb, vaevent);\n\t}\n\treturn 0;\n}\n\nstatic int mrp_pdu_parse_msg(struct mrp_applicant *app, struct sk_buff *skb,\n\t\t\t     int *offset)\n{\n\tstruct mrp_msg_hdr _mh;\n\n\tmrp_cb(skb)->mh = skb_header_pointer(skb, *offset, sizeof(_mh), &_mh);\n\tif (!mrp_cb(skb)->mh)\n\t\treturn -1;\n\t*offset += sizeof(_mh);\n\n\tif (mrp_cb(skb)->mh->attrtype == 0 ||\n\t    mrp_cb(skb)->mh->attrtype > app->app->maxattr ||\n\t    mrp_cb(skb)->mh->attrlen == 0)\n\t\treturn -1;\n\n\twhile (skb->len > *offset) {\n\t\tif (mrp_pdu_parse_end_mark(skb, offset) < 0)\n\t\t\tbreak;\n\t\tif (mrp_pdu_parse_vecattr(app, skb, offset) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int mrp_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t   struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct mrp_application *appl = container_of(pt, struct mrp_application,\n\t\t\t\t\t\t    pkttype);\n\tstruct mrp_port *port;\n\tstruct mrp_applicant *app;\n\tstruct mrp_pdu_hdr _ph;\n\tconst struct mrp_pdu_hdr *ph;\n\tint offset = skb_network_offset(skb);\n\n\t \n\tif (unlikely(skb->pkt_type == PACKET_OTHERHOST))\n\t\tgoto out;\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\tgoto out;\n\tport = rcu_dereference(dev->mrp_port);\n\tif (unlikely(!port))\n\t\tgoto out;\n\tapp = rcu_dereference(port->applicants[appl->type]);\n\tif (unlikely(!app))\n\t\tgoto out;\n\n\tph = skb_header_pointer(skb, offset, sizeof(_ph), &_ph);\n\tif (!ph)\n\t\tgoto out;\n\toffset += sizeof(_ph);\n\n\tif (ph->version != app->app->version)\n\t\tgoto out;\n\n\tspin_lock(&app->lock);\n\twhile (skb->len > offset) {\n\t\tif (mrp_pdu_parse_end_mark(skb, &offset) < 0)\n\t\t\tbreak;\n\t\tif (mrp_pdu_parse_msg(app, skb, &offset) < 0)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&app->lock);\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int mrp_init_port(struct net_device *dev)\n{\n\tstruct mrp_port *port;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(dev->mrp_port, port);\n\treturn 0;\n}\n\nstatic void mrp_release_port(struct net_device *dev)\n{\n\tstruct mrp_port *port = rtnl_dereference(dev->mrp_port);\n\tunsigned int i;\n\n\tfor (i = 0; i <= MRP_APPLICATION_MAX; i++) {\n\t\tif (rtnl_dereference(port->applicants[i]))\n\t\t\treturn;\n\t}\n\tRCU_INIT_POINTER(dev->mrp_port, NULL);\n\tkfree_rcu(port, rcu);\n}\n\nint mrp_init_applicant(struct net_device *dev, struct mrp_application *appl)\n{\n\tstruct mrp_applicant *app;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tif (!rtnl_dereference(dev->mrp_port)) {\n\t\terr = mrp_init_port(dev);\n\t\tif (err < 0)\n\t\t\tgoto err1;\n\t}\n\n\terr = -ENOMEM;\n\tapp = kzalloc(sizeof(*app), GFP_KERNEL);\n\tif (!app)\n\t\tgoto err2;\n\n\terr = dev_mc_add(dev, appl->group_address);\n\tif (err < 0)\n\t\tgoto err3;\n\n\tapp->dev = dev;\n\tapp->app = appl;\n\tapp->mad = RB_ROOT;\n\tapp->active = true;\n\tspin_lock_init(&app->lock);\n\tskb_queue_head_init(&app->queue);\n\trcu_assign_pointer(dev->mrp_port->applicants[appl->type], app);\n\ttimer_setup(&app->join_timer, mrp_join_timer, 0);\n\tmrp_join_timer_arm(app);\n\ttimer_setup(&app->periodic_timer, mrp_periodic_timer, 0);\n\tmrp_periodic_timer_arm(app);\n\treturn 0;\n\nerr3:\n\tkfree(app);\nerr2:\n\tmrp_release_port(dev);\nerr1:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mrp_init_applicant);\n\nvoid mrp_uninit_applicant(struct net_device *dev, struct mrp_application *appl)\n{\n\tstruct mrp_port *port = rtnl_dereference(dev->mrp_port);\n\tstruct mrp_applicant *app = rtnl_dereference(\n\t\tport->applicants[appl->type]);\n\n\tASSERT_RTNL();\n\n\tRCU_INIT_POINTER(port->applicants[appl->type], NULL);\n\n\tspin_lock_bh(&app->lock);\n\tapp->active = false;\n\tspin_unlock_bh(&app->lock);\n\t \n\ttimer_shutdown_sync(&app->join_timer);\n\ttimer_shutdown_sync(&app->periodic_timer);\n\n\tspin_lock_bh(&app->lock);\n\tmrp_mad_event(app, MRP_EVENT_TX);\n\tmrp_attr_destroy_all(app);\n\tmrp_pdu_queue(app);\n\tspin_unlock_bh(&app->lock);\n\n\tmrp_queue_xmit(app);\n\n\tdev_mc_del(dev, appl->group_address);\n\tkfree_rcu(app, rcu);\n\tmrp_release_port(dev);\n}\nEXPORT_SYMBOL_GPL(mrp_uninit_applicant);\n\nint mrp_register_application(struct mrp_application *appl)\n{\n\tappl->pkttype.func = mrp_rcv;\n\tdev_add_pack(&appl->pkttype);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mrp_register_application);\n\nvoid mrp_unregister_application(struct mrp_application *appl)\n{\n\tdev_remove_pack(&appl->pkttype);\n}\nEXPORT_SYMBOL_GPL(mrp_unregister_application);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}