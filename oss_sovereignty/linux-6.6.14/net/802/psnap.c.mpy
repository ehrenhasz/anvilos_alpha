{
  "module_name": "psnap.c",
  "hash_id": "46a691d932da244ddd85dd1b5e505b3b7921d9ac8064205be911c8f95f1a8226",
  "original_prompt": "Ingested from linux-6.6.14/net/802/psnap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/datalink.h>\n#include <net/llc.h>\n#include <net/psnap.h>\n#include <linux/mm.h>\n#include <linux/in.h>\n#include <linux/init.h>\n#include <linux/rculist.h>\n\nstatic LIST_HEAD(snap_list);\nstatic DEFINE_SPINLOCK(snap_lock);\nstatic struct llc_sap *snap_sap;\n\n \nstatic struct datalink_proto *find_snap_client(const unsigned char *desc)\n{\n\tstruct datalink_proto *proto = NULL, *p;\n\n\tlist_for_each_entry_rcu(p, &snap_list, node, lockdep_is_held(&snap_lock)) {\n\t\tif (!memcmp(p->type, desc, 5)) {\n\t\t\tproto = p;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn proto;\n}\n\n \nstatic int snap_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t    struct packet_type *pt, struct net_device *orig_dev)\n{\n\tint rc = 1;\n\tstruct datalink_proto *proto;\n\tstatic struct packet_type snap_packet_type = {\n\t\t.type = cpu_to_be16(ETH_P_SNAP),\n\t};\n\n\tif (unlikely(!pskb_may_pull(skb, 5)))\n\t\tgoto drop;\n\n\trcu_read_lock();\n\tproto = find_snap_client(skb_transport_header(skb));\n\tif (proto) {\n\t\t \n\t\tskb->transport_header += 5;\n\t\tskb_pull_rcsum(skb, 5);\n\t\trc = proto->rcvfunc(skb, dev, &snap_packet_type, orig_dev);\n\t}\n\trcu_read_unlock();\n\n\tif (unlikely(!proto))\n\t\tgoto drop;\n\nout:\n\treturn rc;\n\ndrop:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\n \nstatic int snap_request(struct datalink_proto *dl,\n\t\t\tstruct sk_buff *skb, const u8 *dest)\n{\n\tmemcpy(skb_push(skb, 5), dl->type, 5);\n\tllc_build_and_send_ui_pkt(snap_sap, skb, dest, snap_sap->laddr.lsap);\n\treturn 0;\n}\n\n \nEXPORT_SYMBOL(register_snap_client);\nEXPORT_SYMBOL(unregister_snap_client);\n\nstatic const char snap_err_msg[] __initconst =\n\tKERN_CRIT \"SNAP - unable to register with 802.2\\n\";\n\nstatic int __init snap_init(void)\n{\n\tsnap_sap = llc_sap_open(0xAA, snap_rcv);\n\tif (!snap_sap) {\n\t\tprintk(snap_err_msg);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nmodule_init(snap_init);\n\nstatic void __exit snap_exit(void)\n{\n\tllc_sap_put(snap_sap);\n}\n\nmodule_exit(snap_exit);\n\n\n \nstruct datalink_proto *register_snap_client(const unsigned char *desc,\n\t\t\t\t\t    int (*rcvfunc)(struct sk_buff *,\n\t\t\t\t\t\t\t   struct net_device *,\n\t\t\t\t\t\t\t   struct packet_type *,\n\t\t\t\t\t\t\t   struct net_device *))\n{\n\tstruct datalink_proto *proto = NULL;\n\n\tspin_lock_bh(&snap_lock);\n\n\tif (find_snap_client(desc))\n\t\tgoto out;\n\n\tproto = kmalloc(sizeof(*proto), GFP_ATOMIC);\n\tif (proto) {\n\t\tmemcpy(proto->type, desc, 5);\n\t\tproto->rcvfunc\t\t= rcvfunc;\n\t\tproto->header_length\t= 5 + 3;  \n\t\tproto->request\t\t= snap_request;\n\t\tlist_add_rcu(&proto->node, &snap_list);\n\t}\nout:\n\tspin_unlock_bh(&snap_lock);\n\n\treturn proto;\n}\n\n \nvoid unregister_snap_client(struct datalink_proto *proto)\n{\n\tspin_lock_bh(&snap_lock);\n\tlist_del_rcu(&proto->node);\n\tspin_unlock_bh(&snap_lock);\n\n\tsynchronize_net();\n\n\tkfree(proto);\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}