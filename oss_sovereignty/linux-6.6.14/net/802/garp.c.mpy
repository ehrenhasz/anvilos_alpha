{
  "module_name": "garp.c",
  "hash_id": "379a08a9859916370e9c64904a27f42f1af461fd55ab7af8a87e37a7f1f9cb50",
  "original_prompt": "Ingested from linux-6.6.14/net/802/garp.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/llc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <net/llc.h>\n#include <net/llc_pdu.h>\n#include <net/garp.h>\n#include <asm/unaligned.h>\n\nstatic unsigned int garp_join_time __read_mostly = 200;\nmodule_param(garp_join_time, uint, 0644);\nMODULE_PARM_DESC(garp_join_time, \"Join time in ms (default 200ms)\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct garp_state_trans {\n\tu8\tstate;\n\tu8\taction;\n} garp_applicant_state_table[GARP_APPLICANT_MAX + 1][GARP_EVENT_MAX + 1] = {\n\t[GARP_APPLICANT_VA] = {\n\t\t[GARP_EVENT_TRANSMIT_PDU]\t= { .state = GARP_APPLICANT_AA,\n\t\t\t\t\t\t    .action = GARP_ACTION_S_JOIN_IN },\n\t\t[GARP_EVENT_R_JOIN_IN]\t\t= { .state = GARP_APPLICANT_AA },\n\t\t[GARP_EVENT_R_JOIN_EMPTY]\t= { .state = GARP_APPLICANT_VA },\n\t\t[GARP_EVENT_R_EMPTY]\t\t= { .state = GARP_APPLICANT_VA },\n\t\t[GARP_EVENT_R_LEAVE_IN]\t\t= { .state = GARP_APPLICANT_VA },\n\t\t[GARP_EVENT_R_LEAVE_EMPTY]\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_REQ_JOIN]\t\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_REQ_LEAVE]\t\t= { .state = GARP_APPLICANT_LA },\n\t},\n\t[GARP_APPLICANT_AA] = {\n\t\t[GARP_EVENT_TRANSMIT_PDU]\t= { .state = GARP_APPLICANT_QA,\n\t\t\t\t\t\t    .action = GARP_ACTION_S_JOIN_IN },\n\t\t[GARP_EVENT_R_JOIN_IN]\t\t= { .state = GARP_APPLICANT_QA },\n\t\t[GARP_EVENT_R_JOIN_EMPTY]\t= { .state = GARP_APPLICANT_VA },\n\t\t[GARP_EVENT_R_EMPTY]\t\t= { .state = GARP_APPLICANT_VA },\n\t\t[GARP_EVENT_R_LEAVE_IN]\t\t= { .state = GARP_APPLICANT_VA },\n\t\t[GARP_EVENT_R_LEAVE_EMPTY]\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_REQ_JOIN]\t\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_REQ_LEAVE]\t\t= { .state = GARP_APPLICANT_LA },\n\t},\n\t[GARP_APPLICANT_QA] = {\n\t\t[GARP_EVENT_TRANSMIT_PDU]\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_R_JOIN_IN]\t\t= { .state = GARP_APPLICANT_QA },\n\t\t[GARP_EVENT_R_JOIN_EMPTY]\t= { .state = GARP_APPLICANT_VA },\n\t\t[GARP_EVENT_R_EMPTY]\t\t= { .state = GARP_APPLICANT_VA },\n\t\t[GARP_EVENT_R_LEAVE_IN]\t\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_R_LEAVE_EMPTY]\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_REQ_JOIN]\t\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_REQ_LEAVE]\t\t= { .state = GARP_APPLICANT_LA },\n\t},\n\t[GARP_APPLICANT_LA] = {\n\t\t[GARP_EVENT_TRANSMIT_PDU]\t= { .state = GARP_APPLICANT_VO,\n\t\t\t\t\t\t    .action = GARP_ACTION_S_LEAVE_EMPTY },\n\t\t[GARP_EVENT_R_JOIN_IN]\t\t= { .state = GARP_APPLICANT_LA },\n\t\t[GARP_EVENT_R_JOIN_EMPTY]\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_R_EMPTY]\t\t= { .state = GARP_APPLICANT_LA },\n\t\t[GARP_EVENT_R_LEAVE_IN]\t\t= { .state = GARP_APPLICANT_LA },\n\t\t[GARP_EVENT_R_LEAVE_EMPTY]\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_REQ_JOIN]\t\t= { .state = GARP_APPLICANT_VA },\n\t\t[GARP_EVENT_REQ_LEAVE]\t\t= { .state = GARP_APPLICANT_INVALID },\n\t},\n\t[GARP_APPLICANT_VP] = {\n\t\t[GARP_EVENT_TRANSMIT_PDU]\t= { .state = GARP_APPLICANT_AA,\n\t\t\t\t\t\t    .action = GARP_ACTION_S_JOIN_IN },\n\t\t[GARP_EVENT_R_JOIN_IN]\t\t= { .state = GARP_APPLICANT_AP },\n\t\t[GARP_EVENT_R_JOIN_EMPTY]\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_R_EMPTY]\t\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_R_LEAVE_IN]\t\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_R_LEAVE_EMPTY]\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_REQ_JOIN]\t\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_REQ_LEAVE]\t\t= { .state = GARP_APPLICANT_VO },\n\t},\n\t[GARP_APPLICANT_AP] = {\n\t\t[GARP_EVENT_TRANSMIT_PDU]\t= { .state = GARP_APPLICANT_QA,\n\t\t\t\t\t\t    .action = GARP_ACTION_S_JOIN_IN },\n\t\t[GARP_EVENT_R_JOIN_IN]\t\t= { .state = GARP_APPLICANT_QP },\n\t\t[GARP_EVENT_R_JOIN_EMPTY]\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_R_EMPTY]\t\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_R_LEAVE_IN]\t\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_R_LEAVE_EMPTY]\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_REQ_JOIN]\t\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_REQ_LEAVE]\t\t= { .state = GARP_APPLICANT_AO },\n\t},\n\t[GARP_APPLICANT_QP] = {\n\t\t[GARP_EVENT_TRANSMIT_PDU]\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_R_JOIN_IN]\t\t= { .state = GARP_APPLICANT_QP },\n\t\t[GARP_EVENT_R_JOIN_EMPTY]\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_R_EMPTY]\t\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_R_LEAVE_IN]\t\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_R_LEAVE_EMPTY]\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_REQ_JOIN]\t\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_REQ_LEAVE]\t\t= { .state = GARP_APPLICANT_QO },\n\t},\n\t[GARP_APPLICANT_VO] = {\n\t\t[GARP_EVENT_TRANSMIT_PDU]\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_R_JOIN_IN]\t\t= { .state = GARP_APPLICANT_AO },\n\t\t[GARP_EVENT_R_JOIN_EMPTY]\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_R_EMPTY]\t\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_R_LEAVE_IN]\t\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_R_LEAVE_EMPTY]\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_REQ_JOIN]\t\t= { .state = GARP_APPLICANT_VP },\n\t\t[GARP_EVENT_REQ_LEAVE]\t\t= { .state = GARP_APPLICANT_INVALID },\n\t},\n\t[GARP_APPLICANT_AO] = {\n\t\t[GARP_EVENT_TRANSMIT_PDU]\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_R_JOIN_IN]\t\t= { .state = GARP_APPLICANT_QO },\n\t\t[GARP_EVENT_R_JOIN_EMPTY]\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_R_EMPTY]\t\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_R_LEAVE_IN]\t\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_R_LEAVE_EMPTY]\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_REQ_JOIN]\t\t= { .state = GARP_APPLICANT_AP },\n\t\t[GARP_EVENT_REQ_LEAVE]\t\t= { .state = GARP_APPLICANT_INVALID },\n\t},\n\t[GARP_APPLICANT_QO] = {\n\t\t[GARP_EVENT_TRANSMIT_PDU]\t= { .state = GARP_APPLICANT_INVALID },\n\t\t[GARP_EVENT_R_JOIN_IN]\t\t= { .state = GARP_APPLICANT_QO },\n\t\t[GARP_EVENT_R_JOIN_EMPTY]\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_R_EMPTY]\t\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_R_LEAVE_IN]\t\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_R_LEAVE_EMPTY]\t= { .state = GARP_APPLICANT_VO },\n\t\t[GARP_EVENT_REQ_JOIN]\t\t= { .state = GARP_APPLICANT_QP },\n\t\t[GARP_EVENT_REQ_LEAVE]\t\t= { .state = GARP_APPLICANT_INVALID },\n\t},\n};\n\nstatic int garp_attr_cmp(const struct garp_attr *attr,\n\t\t\t const void *data, u8 len, u8 type)\n{\n\tif (attr->type != type)\n\t\treturn attr->type - type;\n\tif (attr->dlen != len)\n\t\treturn attr->dlen - len;\n\treturn memcmp(attr->data, data, len);\n}\n\nstatic struct garp_attr *garp_attr_lookup(const struct garp_applicant *app,\n\t\t\t\t\t  const void *data, u8 len, u8 type)\n{\n\tstruct rb_node *parent = app->gid.rb_node;\n\tstruct garp_attr *attr;\n\tint d;\n\n\twhile (parent) {\n\t\tattr = rb_entry(parent, struct garp_attr, node);\n\t\td = garp_attr_cmp(attr, data, len, type);\n\t\tif (d > 0)\n\t\t\tparent = parent->rb_left;\n\t\telse if (d < 0)\n\t\t\tparent = parent->rb_right;\n\t\telse\n\t\t\treturn attr;\n\t}\n\treturn NULL;\n}\n\nstatic struct garp_attr *garp_attr_create(struct garp_applicant *app,\n\t\t\t\t\t  const void *data, u8 len, u8 type)\n{\n\tstruct rb_node *parent = NULL, **p = &app->gid.rb_node;\n\tstruct garp_attr *attr;\n\tint d;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tattr = rb_entry(parent, struct garp_attr, node);\n\t\td = garp_attr_cmp(attr, data, len, type);\n\t\tif (d > 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (d < 0)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\t \n\t\t\treturn attr;\n\t\t}\n\t}\n\tattr = kmalloc(sizeof(*attr) + len, GFP_ATOMIC);\n\tif (!attr)\n\t\treturn attr;\n\tattr->state = GARP_APPLICANT_VO;\n\tattr->type  = type;\n\tattr->dlen  = len;\n\tmemcpy(attr->data, data, len);\n\n\trb_link_node(&attr->node, parent, p);\n\trb_insert_color(&attr->node, &app->gid);\n\treturn attr;\n}\n\nstatic void garp_attr_destroy(struct garp_applicant *app, struct garp_attr *attr)\n{\n\trb_erase(&attr->node, &app->gid);\n\tkfree(attr);\n}\n\nstatic void garp_attr_destroy_all(struct garp_applicant *app)\n{\n\tstruct rb_node *node, *next;\n\tstruct garp_attr *attr;\n\n\tfor (node = rb_first(&app->gid);\n\t     next = node ? rb_next(node) : NULL, node != NULL;\n\t     node = next) {\n\t\tattr = rb_entry(node, struct garp_attr, node);\n\t\tgarp_attr_destroy(app, attr);\n\t}\n}\n\nstatic int garp_pdu_init(struct garp_applicant *app)\n{\n\tstruct sk_buff *skb;\n\tstruct garp_pdu_hdr *gp;\n\n#define LLC_RESERVE\tsizeof(struct llc_pdu_un)\n\tskb = alloc_skb(app->dev->mtu + LL_RESERVED_SPACE(app->dev),\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb->dev = app->dev;\n\tskb->protocol = htons(ETH_P_802_2);\n\tskb_reserve(skb, LL_RESERVED_SPACE(app->dev) + LLC_RESERVE);\n\n\tgp = __skb_put(skb, sizeof(*gp));\n\tput_unaligned(htons(GARP_PROTOCOL_ID), &gp->protocol);\n\n\tapp->pdu = skb;\n\treturn 0;\n}\n\nstatic int garp_pdu_append_end_mark(struct garp_applicant *app)\n{\n\tif (skb_tailroom(app->pdu) < sizeof(u8))\n\t\treturn -1;\n\t__skb_put_u8(app->pdu, GARP_END_MARK);\n\treturn 0;\n}\n\nstatic void garp_pdu_queue(struct garp_applicant *app)\n{\n\tif (!app->pdu)\n\t\treturn;\n\n\tgarp_pdu_append_end_mark(app);\n\tgarp_pdu_append_end_mark(app);\n\n\tllc_pdu_header_init(app->pdu, LLC_PDU_TYPE_U, LLC_SAP_BSPAN,\n\t\t\t    LLC_SAP_BSPAN, LLC_PDU_CMD);\n\tllc_pdu_init_as_ui_cmd(app->pdu);\n\tllc_mac_hdr_init(app->pdu, app->dev->dev_addr,\n\t\t\t app->app->proto.group_address);\n\n\tskb_queue_tail(&app->queue, app->pdu);\n\tapp->pdu = NULL;\n}\n\nstatic void garp_queue_xmit(struct garp_applicant *app)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&app->queue)))\n\t\tdev_queue_xmit(skb);\n}\n\nstatic int garp_pdu_append_msg(struct garp_applicant *app, u8 attrtype)\n{\n\tstruct garp_msg_hdr *gm;\n\n\tif (skb_tailroom(app->pdu) < sizeof(*gm))\n\t\treturn -1;\n\tgm = __skb_put(app->pdu, sizeof(*gm));\n\tgm->attrtype = attrtype;\n\tgarp_cb(app->pdu)->cur_type = attrtype;\n\treturn 0;\n}\n\nstatic int garp_pdu_append_attr(struct garp_applicant *app,\n\t\t\t\tconst struct garp_attr *attr,\n\t\t\t\tenum garp_attr_event event)\n{\n\tstruct garp_attr_hdr *ga;\n\tunsigned int len;\n\tint err;\nagain:\n\tif (!app->pdu) {\n\t\terr = garp_pdu_init(app);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (garp_cb(app->pdu)->cur_type != attr->type) {\n\t\tif (garp_cb(app->pdu)->cur_type &&\n\t\t    garp_pdu_append_end_mark(app) < 0)\n\t\t\tgoto queue;\n\t\tif (garp_pdu_append_msg(app, attr->type) < 0)\n\t\t\tgoto queue;\n\t}\n\n\tlen = sizeof(*ga) + attr->dlen;\n\tif (skb_tailroom(app->pdu) < len)\n\t\tgoto queue;\n\tga = __skb_put(app->pdu, len);\n\tga->len   = len;\n\tga->event = event;\n\tmemcpy(ga->data, attr->data, attr->dlen);\n\treturn 0;\n\nqueue:\n\tgarp_pdu_queue(app);\n\tgoto again;\n}\n\nstatic void garp_attr_event(struct garp_applicant *app,\n\t\t\t    struct garp_attr *attr, enum garp_event event)\n{\n\tenum garp_applicant_state state;\n\n\tstate = garp_applicant_state_table[attr->state][event].state;\n\tif (state == GARP_APPLICANT_INVALID)\n\t\treturn;\n\n\tswitch (garp_applicant_state_table[attr->state][event].action) {\n\tcase GARP_ACTION_NONE:\n\t\tbreak;\n\tcase GARP_ACTION_S_JOIN_IN:\n\t\t \n\t\tif (garp_pdu_append_attr(app, attr, GARP_JOIN_IN) < 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase GARP_ACTION_S_LEAVE_EMPTY:\n\t\tgarp_pdu_append_attr(app, attr, GARP_LEAVE_EMPTY);\n\t\t \n\t\tgarp_attr_destroy(app, attr);\n\t\treturn;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tattr->state = state;\n}\n\nint garp_request_join(const struct net_device *dev,\n\t\t      const struct garp_application *appl,\n\t\t      const void *data, u8 len, u8 type)\n{\n\tstruct garp_port *port = rtnl_dereference(dev->garp_port);\n\tstruct garp_applicant *app = rtnl_dereference(port->applicants[appl->type]);\n\tstruct garp_attr *attr;\n\n\tspin_lock_bh(&app->lock);\n\tattr = garp_attr_create(app, data, len, type);\n\tif (!attr) {\n\t\tspin_unlock_bh(&app->lock);\n\t\treturn -ENOMEM;\n\t}\n\tgarp_attr_event(app, attr, GARP_EVENT_REQ_JOIN);\n\tspin_unlock_bh(&app->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(garp_request_join);\n\nvoid garp_request_leave(const struct net_device *dev,\n\t\t\tconst struct garp_application *appl,\n\t\t\tconst void *data, u8 len, u8 type)\n{\n\tstruct garp_port *port = rtnl_dereference(dev->garp_port);\n\tstruct garp_applicant *app = rtnl_dereference(port->applicants[appl->type]);\n\tstruct garp_attr *attr;\n\n\tspin_lock_bh(&app->lock);\n\tattr = garp_attr_lookup(app, data, len, type);\n\tif (!attr) {\n\t\tspin_unlock_bh(&app->lock);\n\t\treturn;\n\t}\n\tgarp_attr_event(app, attr, GARP_EVENT_REQ_LEAVE);\n\tspin_unlock_bh(&app->lock);\n}\nEXPORT_SYMBOL_GPL(garp_request_leave);\n\nstatic void garp_gid_event(struct garp_applicant *app, enum garp_event event)\n{\n\tstruct rb_node *node, *next;\n\tstruct garp_attr *attr;\n\n\tfor (node = rb_first(&app->gid);\n\t     next = node ? rb_next(node) : NULL, node != NULL;\n\t     node = next) {\n\t\tattr = rb_entry(node, struct garp_attr, node);\n\t\tgarp_attr_event(app, attr, event);\n\t}\n}\n\nstatic void garp_join_timer_arm(struct garp_applicant *app)\n{\n\tunsigned long delay;\n\n\tdelay = get_random_u32_below(msecs_to_jiffies(garp_join_time));\n\tmod_timer(&app->join_timer, jiffies + delay);\n}\n\nstatic void garp_join_timer(struct timer_list *t)\n{\n\tstruct garp_applicant *app = from_timer(app, t, join_timer);\n\n\tspin_lock(&app->lock);\n\tgarp_gid_event(app, GARP_EVENT_TRANSMIT_PDU);\n\tgarp_pdu_queue(app);\n\tspin_unlock(&app->lock);\n\n\tgarp_queue_xmit(app);\n\tgarp_join_timer_arm(app);\n}\n\nstatic int garp_pdu_parse_end_mark(struct sk_buff *skb)\n{\n\tif (!pskb_may_pull(skb, sizeof(u8)))\n\t\treturn -1;\n\tif (*skb->data == GARP_END_MARK) {\n\t\tskb_pull(skb, sizeof(u8));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int garp_pdu_parse_attr(struct garp_applicant *app, struct sk_buff *skb,\n\t\t\t       u8 attrtype)\n{\n\tconst struct garp_attr_hdr *ga;\n\tstruct garp_attr *attr;\n\tenum garp_event event;\n\tunsigned int dlen;\n\n\tif (!pskb_may_pull(skb, sizeof(*ga)))\n\t\treturn -1;\n\tga = (struct garp_attr_hdr *)skb->data;\n\tif (ga->len < sizeof(*ga))\n\t\treturn -1;\n\n\tif (!pskb_may_pull(skb, ga->len))\n\t\treturn -1;\n\tskb_pull(skb, ga->len);\n\tdlen = sizeof(*ga) - ga->len;\n\n\tif (attrtype > app->app->maxattr)\n\t\treturn 0;\n\n\tswitch (ga->event) {\n\tcase GARP_LEAVE_ALL:\n\t\tif (dlen != 0)\n\t\t\treturn -1;\n\t\tgarp_gid_event(app, GARP_EVENT_R_LEAVE_EMPTY);\n\t\treturn 0;\n\tcase GARP_JOIN_EMPTY:\n\t\tevent = GARP_EVENT_R_JOIN_EMPTY;\n\t\tbreak;\n\tcase GARP_JOIN_IN:\n\t\tevent = GARP_EVENT_R_JOIN_IN;\n\t\tbreak;\n\tcase GARP_LEAVE_EMPTY:\n\t\tevent = GARP_EVENT_R_LEAVE_EMPTY;\n\t\tbreak;\n\tcase GARP_EMPTY:\n\t\tevent = GARP_EVENT_R_EMPTY;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (dlen == 0)\n\t\treturn -1;\n\tattr = garp_attr_lookup(app, ga->data, dlen, attrtype);\n\tif (attr == NULL)\n\t\treturn 0;\n\tgarp_attr_event(app, attr, event);\n\treturn 0;\n}\n\nstatic int garp_pdu_parse_msg(struct garp_applicant *app, struct sk_buff *skb)\n{\n\tconst struct garp_msg_hdr *gm;\n\n\tif (!pskb_may_pull(skb, sizeof(*gm)))\n\t\treturn -1;\n\tgm = (struct garp_msg_hdr *)skb->data;\n\tif (gm->attrtype == 0)\n\t\treturn -1;\n\tskb_pull(skb, sizeof(*gm));\n\n\twhile (skb->len > 0) {\n\t\tif (garp_pdu_parse_attr(app, skb, gm->attrtype) < 0)\n\t\t\treturn -1;\n\t\tif (garp_pdu_parse_end_mark(skb) < 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void garp_pdu_rcv(const struct stp_proto *proto, struct sk_buff *skb,\n\t\t\t struct net_device *dev)\n{\n\tstruct garp_application *appl = proto->data;\n\tstruct garp_port *port;\n\tstruct garp_applicant *app;\n\tconst struct garp_pdu_hdr *gp;\n\n\tport = rcu_dereference(dev->garp_port);\n\tif (!port)\n\t\tgoto err;\n\tapp = rcu_dereference(port->applicants[appl->type]);\n\tif (!app)\n\t\tgoto err;\n\n\tif (!pskb_may_pull(skb, sizeof(*gp)))\n\t\tgoto err;\n\tgp = (struct garp_pdu_hdr *)skb->data;\n\tif (get_unaligned(&gp->protocol) != htons(GARP_PROTOCOL_ID))\n\t\tgoto err;\n\tskb_pull(skb, sizeof(*gp));\n\n\tspin_lock(&app->lock);\n\twhile (skb->len > 0) {\n\t\tif (garp_pdu_parse_msg(app, skb) < 0)\n\t\t\tbreak;\n\t\tif (garp_pdu_parse_end_mark(skb) < 0)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&app->lock);\nerr:\n\tkfree_skb(skb);\n}\n\nstatic int garp_init_port(struct net_device *dev)\n{\n\tstruct garp_port *port;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(dev->garp_port, port);\n\treturn 0;\n}\n\nstatic void garp_release_port(struct net_device *dev)\n{\n\tstruct garp_port *port = rtnl_dereference(dev->garp_port);\n\tunsigned int i;\n\n\tfor (i = 0; i <= GARP_APPLICATION_MAX; i++) {\n\t\tif (rtnl_dereference(port->applicants[i]))\n\t\t\treturn;\n\t}\n\tRCU_INIT_POINTER(dev->garp_port, NULL);\n\tkfree_rcu(port, rcu);\n}\n\nint garp_init_applicant(struct net_device *dev, struct garp_application *appl)\n{\n\tstruct garp_applicant *app;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tif (!rtnl_dereference(dev->garp_port)) {\n\t\terr = garp_init_port(dev);\n\t\tif (err < 0)\n\t\t\tgoto err1;\n\t}\n\n\terr = -ENOMEM;\n\tapp = kzalloc(sizeof(*app), GFP_KERNEL);\n\tif (!app)\n\t\tgoto err2;\n\n\terr = dev_mc_add(dev, appl->proto.group_address);\n\tif (err < 0)\n\t\tgoto err3;\n\n\tapp->dev = dev;\n\tapp->app = appl;\n\tapp->gid = RB_ROOT;\n\tspin_lock_init(&app->lock);\n\tskb_queue_head_init(&app->queue);\n\trcu_assign_pointer(dev->garp_port->applicants[appl->type], app);\n\ttimer_setup(&app->join_timer, garp_join_timer, 0);\n\tgarp_join_timer_arm(app);\n\treturn 0;\n\nerr3:\n\tkfree(app);\nerr2:\n\tgarp_release_port(dev);\nerr1:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(garp_init_applicant);\n\nvoid garp_uninit_applicant(struct net_device *dev, struct garp_application *appl)\n{\n\tstruct garp_port *port = rtnl_dereference(dev->garp_port);\n\tstruct garp_applicant *app = rtnl_dereference(port->applicants[appl->type]);\n\n\tASSERT_RTNL();\n\n\tRCU_INIT_POINTER(port->applicants[appl->type], NULL);\n\n\t \n\ttimer_shutdown_sync(&app->join_timer);\n\n\tspin_lock_bh(&app->lock);\n\tgarp_gid_event(app, GARP_EVENT_TRANSMIT_PDU);\n\tgarp_attr_destroy_all(app);\n\tgarp_pdu_queue(app);\n\tspin_unlock_bh(&app->lock);\n\n\tgarp_queue_xmit(app);\n\n\tdev_mc_del(dev, appl->proto.group_address);\n\tkfree_rcu(app, rcu);\n\tgarp_release_port(dev);\n}\nEXPORT_SYMBOL_GPL(garp_uninit_applicant);\n\nint garp_register_application(struct garp_application *appl)\n{\n\tappl->proto.rcv = garp_pdu_rcv;\n\tappl->proto.data = appl;\n\treturn stp_proto_register(&appl->proto);\n}\nEXPORT_SYMBOL_GPL(garp_register_application);\n\nvoid garp_unregister_application(struct garp_application *appl)\n{\n\tstp_proto_unregister(&appl->proto);\n}\nEXPORT_SYMBOL_GPL(garp_unregister_application);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}