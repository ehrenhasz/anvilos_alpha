{
  "module_name": "sysctl_net_ax25.c",
  "hash_id": "1a09cdab7eddc06e295ae7ed2b35efe292e44ae6ebb867d6064c293b2718567f",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/sysctl_net_ax25.c",
  "human_readable_source": "\n \n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/spinlock.h>\n#include <net/ax25.h>\n\nstatic int min_ipdefmode[1],    \tmax_ipdefmode[] = {1};\nstatic int min_axdefmode[1],            max_axdefmode[] = {1};\nstatic int min_backoff[1],\t\tmax_backoff[] = {2};\nstatic int min_conmode[1],\t\tmax_conmode[] = {2};\nstatic int min_window[] = {1},\t\tmax_window[] = {7};\nstatic int min_ewindow[] = {1},\t\tmax_ewindow[] = {63};\nstatic int min_t1[] = {1},\t\tmax_t1[] = {30000};\nstatic int min_t2[] = {1},\t\tmax_t2[] = {20000};\nstatic int min_t3[1],\t\t\tmax_t3[] = {3600000};\nstatic int min_idle[1],\t\t\tmax_idle[] = {65535000};\nstatic int min_n2[] = {1},\t\tmax_n2[] = {31};\nstatic int min_paclen[] = {1},\t\tmax_paclen[] = {512};\nstatic int min_proto[1],\t\tmax_proto[] = { AX25_PROTO_MAX };\n#ifdef CONFIG_AX25_DAMA_SLAVE\nstatic int min_ds_timeout[1],\t\tmax_ds_timeout[] = {65535000};\n#endif\n\nstatic const struct ctl_table ax25_param_table[] = {\n\t{\n\t\t.procname\t= \"ip_default_mode\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_ipdefmode,\n\t\t.extra2\t\t= &max_ipdefmode\n\t},\n\t{\n\t\t.procname\t= \"ax25_default_mode\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_axdefmode,\n\t\t.extra2\t\t= &max_axdefmode\n\t},\n\t{\n\t\t.procname\t= \"backoff_type\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_backoff,\n\t\t.extra2\t\t= &max_backoff\n\t},\n\t{\n\t\t.procname\t= \"connect_mode\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_conmode,\n\t\t.extra2\t\t= &max_conmode\n\t},\n\t{\n\t\t.procname\t= \"standard_window_size\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_window,\n\t\t.extra2\t\t= &max_window\n\t},\n\t{\n\t\t.procname\t= \"extended_window_size\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_ewindow,\n\t\t.extra2\t\t= &max_ewindow\n\t},\n\t{\n\t\t.procname\t= \"t1_timeout\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_t1,\n\t\t.extra2\t\t= &max_t1\n\t},\n\t{\n\t\t.procname\t= \"t2_timeout\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_t2,\n\t\t.extra2\t\t= &max_t2\n\t},\n\t{\n\t\t.procname\t= \"t3_timeout\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_t3,\n\t\t.extra2\t\t= &max_t3\n\t},\n\t{\n\t\t.procname\t= \"idle_timeout\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_idle,\n\t\t.extra2\t\t= &max_idle\n\t},\n\t{\n\t\t.procname\t= \"maximum_retry_count\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_n2,\n\t\t.extra2\t\t= &max_n2\n\t},\n\t{\n\t\t.procname\t= \"maximum_packet_length\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_paclen,\n\t\t.extra2\t\t= &max_paclen\n\t},\n\t{\n\t\t.procname\t= \"protocol\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_proto,\n\t\t.extra2\t\t= &max_proto\n\t},\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t{\n\t\t.procname\t= \"dama_slave_timeout\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_ds_timeout,\n\t\t.extra2\t\t= &max_ds_timeout\n\t},\n#endif\n\n\t{ }\t \n};\n\nint ax25_register_dev_sysctl(ax25_dev *ax25_dev)\n{\n\tchar path[sizeof(\"net/ax25/\") + IFNAMSIZ];\n\tint k;\n\tstruct ctl_table *table;\n\n\ttable = kmemdup(ax25_param_table, sizeof(ax25_param_table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tfor (k = 0; k < AX25_MAX_VALUES; k++)\n\t\ttable[k].data = &ax25_dev->values[k];\n\n\tsnprintf(path, sizeof(path), \"net/ax25/%s\", ax25_dev->dev->name);\n\tax25_dev->sysheader = register_net_sysctl_sz(&init_net, path, table,\n\t\t\t\t\t\t     ARRAY_SIZE(ax25_param_table));\n\tif (!ax25_dev->sysheader) {\n\t\tkfree(table);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid ax25_unregister_dev_sysctl(ax25_dev *ax25_dev)\n{\n\tstruct ctl_table_header *header = ax25_dev->sysheader;\n\tstruct ctl_table *table;\n\n\tif (header) {\n\t\tax25_dev->sysheader = NULL;\n\t\ttable = header->ctl_table_arg;\n\t\tunregister_net_sysctl_table(header);\n\t\tkfree(table);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}