{
  "module_name": "ax25_subr.c",
  "hash_id": "55c4d876d1738c8e4d539888b0c3cf9a1c5b86d172a007749266df672a72c94d",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_subr.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n\n \nvoid ax25_clear_queues(ax25_cb *ax25)\n{\n\tskb_queue_purge(&ax25->write_queue);\n\tskb_queue_purge(&ax25->ack_queue);\n\tskb_queue_purge(&ax25->reseq_queue);\n\tskb_queue_purge(&ax25->frag_queue);\n}\n\n \nvoid ax25_frames_acked(ax25_cb *ax25, unsigned short nr)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tif (ax25->va != nr) {\n\t\twhile (skb_peek(&ax25->ack_queue) != NULL && ax25->va != nr) {\n\t\t\tskb = skb_dequeue(&ax25->ack_queue);\n\t\t\tkfree_skb(skb);\n\t\t\tax25->va = (ax25->va + 1) % ax25->modulus;\n\t\t}\n\t}\n}\n\nvoid ax25_requeue_frames(ax25_cb *ax25)\n{\n\tstruct sk_buff *skb;\n\n\t \n\twhile ((skb = skb_dequeue_tail(&ax25->ack_queue)) != NULL)\n\t\tskb_queue_head(&ax25->write_queue, skb);\n}\n\n \nint ax25_validate_nr(ax25_cb *ax25, unsigned short nr)\n{\n\tunsigned short vc = ax25->va;\n\n\twhile (vc != ax25->vs) {\n\t\tif (nr == vc) return 1;\n\t\tvc = (vc + 1) % ax25->modulus;\n\t}\n\n\tif (nr == ax25->vs) return 1;\n\n\treturn 0;\n}\n\n \nint ax25_decode(ax25_cb *ax25, struct sk_buff *skb, int *ns, int *nr, int *pf)\n{\n\tunsigned char *frame;\n\tint frametype = AX25_ILLEGAL;\n\n\tframe = skb->data;\n\t*ns = *nr = *pf = 0;\n\n\tif (ax25->modulus == AX25_MODULUS) {\n\t\tif ((frame[0] & AX25_S) == 0) {\n\t\t\tframetype = AX25_I;\t\t\t \n\t\t\t*ns = (frame[0] >> 1) & 0x07;\n\t\t\t*nr = (frame[0] >> 5) & 0x07;\n\t\t\t*pf = frame[0] & AX25_PF;\n\t\t} else if ((frame[0] & AX25_U) == 1) { \t \n\t\t\tframetype = frame[0] & 0x0F;\n\t\t\t*nr = (frame[0] >> 5) & 0x07;\n\t\t\t*pf = frame[0] & AX25_PF;\n\t\t} else if ((frame[0] & AX25_U) == 3) { \t \n\t\t\tframetype = frame[0] & ~AX25_PF;\n\t\t\t*pf = frame[0] & AX25_PF;\n\t\t}\n\t\tskb_pull(skb, 1);\n\t} else {\n\t\tif ((frame[0] & AX25_S) == 0) {\n\t\t\tframetype = AX25_I;\t\t\t \n\t\t\t*ns = (frame[0] >> 1) & 0x7F;\n\t\t\t*nr = (frame[1] >> 1) & 0x7F;\n\t\t\t*pf = frame[1] & AX25_EPF;\n\t\t\tskb_pull(skb, 2);\n\t\t} else if ((frame[0] & AX25_U) == 1) { \t \n\t\t\tframetype = frame[0] & 0x0F;\n\t\t\t*nr = (frame[1] >> 1) & 0x7F;\n\t\t\t*pf = frame[1] & AX25_EPF;\n\t\t\tskb_pull(skb, 2);\n\t\t} else if ((frame[0] & AX25_U) == 3) { \t \n\t\t\tframetype = frame[0] & ~AX25_PF;\n\t\t\t*pf = frame[0] & AX25_PF;\n\t\t\tskb_pull(skb, 1);\n\t\t}\n\t}\n\n\treturn frametype;\n}\n\n \nvoid ax25_send_control(ax25_cb *ax25, int frametype, int poll_bit, int type)\n{\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\n\tif ((skb = alloc_skb(ax25->ax25_dev->dev->hard_header_len + 2, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\tskb_reserve(skb, ax25->ax25_dev->dev->hard_header_len);\n\n\tskb_reset_network_header(skb);\n\n\t \n\tif (ax25->modulus == AX25_MODULUS) {\n\t\tdptr = skb_put(skb, 1);\n\t\t*dptr = frametype;\n\t\t*dptr |= (poll_bit) ? AX25_PF : 0;\n\t\tif ((frametype & AX25_U) == AX25_S)\t\t \n\t\t\t*dptr |= (ax25->vr << 5);\n\t} else {\n\t\tif ((frametype & AX25_U) == AX25_U) {\n\t\t\tdptr = skb_put(skb, 1);\n\t\t\t*dptr = frametype;\n\t\t\t*dptr |= (poll_bit) ? AX25_PF : 0;\n\t\t} else {\n\t\t\tdptr = skb_put(skb, 2);\n\t\t\tdptr[0] = frametype;\n\t\t\tdptr[1] = (ax25->vr << 1);\n\t\t\tdptr[1] |= (poll_bit) ? AX25_EPF : 0;\n\t\t}\n\t}\n\n\tax25_transmit_buffer(ax25, skb, type);\n}\n\n \nvoid ax25_return_dm(struct net_device *dev, ax25_address *src, ax25_address *dest, ax25_digi *digi)\n{\n\tstruct sk_buff *skb;\n\tchar *dptr;\n\tax25_digi retdigi;\n\n\tif (dev == NULL)\n\t\treturn;\n\n\tif ((skb = alloc_skb(dev->hard_header_len + 1, GFP_ATOMIC)) == NULL)\n\t\treturn;\t \n\n\tskb_reserve(skb, dev->hard_header_len);\n\tskb_reset_network_header(skb);\n\n\tax25_digi_invert(digi, &retdigi);\n\n\tdptr = skb_put(skb, 1);\n\n\t*dptr = AX25_DM | AX25_PF;\n\n\t \n\tdptr  = skb_push(skb, ax25_addr_size(digi));\n\tdptr += ax25_addr_build(dptr, dest, src, &retdigi, AX25_RESPONSE, AX25_MODULUS);\n\n\tax25_queue_xmit(skb, dev);\n}\n\n \nvoid ax25_calculate_t1(ax25_cb *ax25)\n{\n\tint n, t = 2;\n\n\tswitch (ax25->backoff) {\n\tcase 0:\n\t\tbreak;\n\n\tcase 1:\n\t\tt += 2 * ax25->n2count;\n\t\tbreak;\n\n\tcase 2:\n\t\tfor (n = 0; n < ax25->n2count; n++)\n\t\t\tt *= 2;\n\t\tif (t > 8) t = 8;\n\t\tbreak;\n\t}\n\n\tax25->t1 = t * ax25->rtt;\n}\n\n \nvoid ax25_calculate_rtt(ax25_cb *ax25)\n{\n\tif (ax25->backoff == 0)\n\t\treturn;\n\n\tif (ax25_t1timer_running(ax25) && ax25->n2count == 0)\n\t\tax25->rtt = (9 * ax25->rtt + ax25->t1 - ax25_display_timer(&ax25->t1timer)) / 10;\n\n\tif (ax25->rtt < AX25_T1CLAMPLO)\n\t\tax25->rtt = AX25_T1CLAMPLO;\n\n\tif (ax25->rtt > AX25_T1CLAMPHI)\n\t\tax25->rtt = AX25_T1CLAMPHI;\n}\n\nvoid ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\n\tif (reason == ENETUNREACH) {\n\t\tdel_timer_sync(&ax25->timer);\n\t\tdel_timer_sync(&ax25->t1timer);\n\t\tdel_timer_sync(&ax25->t2timer);\n\t\tdel_timer_sync(&ax25->t3timer);\n\t\tdel_timer_sync(&ax25->idletimer);\n\t} else {\n\t\tif (ax25->sk && !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\tax25_stop_heartbeat(ax25);\n\t\tax25_stop_t1timer(ax25);\n\t\tax25_stop_t2timer(ax25);\n\t\tax25_stop_t3timer(ax25);\n\t\tax25_stop_idletimer(ax25);\n\t}\n\n\tax25->state = AX25_STATE_0;\n\n\tax25_link_failed(ax25, reason);\n\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}