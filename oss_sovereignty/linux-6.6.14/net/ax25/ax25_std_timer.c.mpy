{
  "module_name": "ax25_std_timer.c",
  "hash_id": "6b22939d471fd19dae9290f81996454a9dd432983079d438377cb322d0ee60bc",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_std_timer.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n\nvoid ax25_std_heartbeat_expiry(ax25_cb *ax25)\n{\n\tstruct sock *sk = ax25->sk;\n\n\tif (sk)\n\t\tbh_lock_sock(sk);\n\n\tswitch (ax25->state) {\n\tcase AX25_STATE_0:\n\tcase AX25_STATE_2:\n\t\t \n\t\tif (!sk || sock_flag(sk, SOCK_DESTROY) ||\n\t\t    (sk->sk_state == TCP_LISTEN &&\n\t\t     sock_flag(sk, SOCK_DEAD))) {\n\t\t\tif (sk) {\n\t\t\t\tsock_hold(sk);\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\t\tbh_unlock_sock(sk);\n\t\t\t\t \n\t\t\t\tsock_put(sk);\n\t\t\t} else\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase AX25_STATE_3:\n\tcase AX25_STATE_4:\n\t\t \n\t\tif (sk != NULL) {\n\t\t\tif (atomic_read(&sk->sk_rmem_alloc) <\n\t\t\t    (sk->sk_rcvbuf >> 1) &&\n\t\t\t    (ax25->condition & AX25_COND_OWN_RX_BUSY)) {\n\t\t\t\tax25->condition &= ~AX25_COND_OWN_RX_BUSY;\n\t\t\t\tax25->condition &= ~AX25_COND_ACK_PENDING;\n\t\t\t\tax25_send_control(ax25, AX25_RR, AX25_POLLOFF, AX25_RESPONSE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sk)\n\t\tbh_unlock_sock(sk);\n\n\tax25_start_heartbeat(ax25);\n}\n\nvoid ax25_std_t2timer_expiry(ax25_cb *ax25)\n{\n\tif (ax25->condition & AX25_COND_ACK_PENDING) {\n\t\tax25->condition &= ~AX25_COND_ACK_PENDING;\n\t\tax25_std_timeout_response(ax25);\n\t}\n}\n\nvoid ax25_std_t3timer_expiry(ax25_cb *ax25)\n{\n\tax25->n2count = 0;\n\tax25_std_transmit_enquiry(ax25);\n\tax25->state   = AX25_STATE_4;\n}\n\nvoid ax25_std_idletimer_expiry(ax25_cb *ax25)\n{\n\tax25_clear_queues(ax25);\n\n\tax25->n2count = 0;\n\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\tax25->state   = AX25_STATE_2;\n\n\tax25_calculate_t1(ax25);\n\tax25_start_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\n\tif (ax25->sk != NULL) {\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = 0;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t}\n}\n\nvoid ax25_std_t1timer_expiry(ax25_cb *ax25)\n{\n\tswitch (ax25->state) {\n\tcase AX25_STATE_1:\n\t\tif (ax25->n2count == ax25->n2) {\n\t\t\tif (ax25->modulus == AX25_MODULUS) {\n\t\t\t\tax25_disconnect(ax25, ETIMEDOUT);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tax25->modulus = AX25_MODULUS;\n\t\t\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\n\t\t\t\tax25->n2count = 0;\n\t\t\t\tax25_send_control(ax25, AX25_SABM, AX25_POLLON, AX25_COMMAND);\n\t\t\t}\n\t\t} else {\n\t\t\tax25->n2count++;\n\t\t\tif (ax25->modulus == AX25_MODULUS)\n\t\t\t\tax25_send_control(ax25, AX25_SABM, AX25_POLLON, AX25_COMMAND);\n\t\t\telse\n\t\t\t\tax25_send_control(ax25, AX25_SABME, AX25_POLLON, AX25_COMMAND);\n\t\t}\n\t\tbreak;\n\n\tcase AX25_STATE_2:\n\t\tif (ax25->n2count == ax25->n2) {\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_disconnect(ax25, ETIMEDOUT);\n\t\t\treturn;\n\t\t} else {\n\t\t\tax25->n2count++;\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t}\n\t\tbreak;\n\n\tcase AX25_STATE_3:\n\t\tax25->n2count = 1;\n\t\tax25_std_transmit_enquiry(ax25);\n\t\tax25->state   = AX25_STATE_4;\n\t\tbreak;\n\n\tcase AX25_STATE_4:\n\t\tif (ax25->n2count == ax25->n2) {\n\t\t\tax25_send_control(ax25, AX25_DM, AX25_POLLON, AX25_RESPONSE);\n\t\t\tax25_disconnect(ax25, ETIMEDOUT);\n\t\t\treturn;\n\t\t} else {\n\t\t\tax25->n2count++;\n\t\t\tax25_std_transmit_enquiry(ax25);\n\t\t}\n\t\tbreak;\n\t}\n\n\tax25_calculate_t1(ax25);\n\tax25_start_t1timer(ax25);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}