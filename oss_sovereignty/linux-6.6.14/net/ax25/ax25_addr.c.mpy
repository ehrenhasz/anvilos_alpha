{
  "module_name": "ax25_addr.c",
  "hash_id": "48409edf3baca2dc9e5b24f8c41da8d9fd3d5c56d29051abe486241aa012fa42",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_addr.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n\n \n\nconst ax25_address ax25_bcast =\n\t{{'Q' << 1, 'S' << 1, 'T' << 1, ' ' << 1, ' ' << 1, ' ' << 1, 0 << 1}};\nconst ax25_address ax25_defaddr =\n\t{{'L' << 1, 'I' << 1, 'N' << 1, 'U' << 1, 'X' << 1, ' ' << 1, 1 << 1}};\nconst ax25_address null_ax25_address =\n\t{{' ' << 1, ' ' << 1, ' ' << 1, ' ' << 1, ' ' << 1, ' ' << 1, 0 << 1}};\n\nEXPORT_SYMBOL_GPL(ax25_bcast);\nEXPORT_SYMBOL_GPL(ax25_defaddr);\nEXPORT_SYMBOL(null_ax25_address);\n\n \nchar *ax2asc(char *buf, const ax25_address *a)\n{\n\tchar c, *s;\n\tint n;\n\n\tfor (n = 0, s = buf; n < 6; n++) {\n\t\tc = (a->ax25_call[n] >> 1) & 0x7F;\n\n\t\tif (c != ' ') *s++ = c;\n\t}\n\n\t*s++ = '-';\n\n\tif ((n = ((a->ax25_call[6] >> 1) & 0x0F)) > 9) {\n\t\t*s++ = '1';\n\t\tn -= 10;\n\t}\n\n\t*s++ = n + '0';\n\t*s++ = '\\0';\n\n\tif (*buf == '\\0' || *buf == '-')\n\t   return \"*\";\n\n\treturn buf;\n\n}\n\nEXPORT_SYMBOL(ax2asc);\n\n \nvoid asc2ax(ax25_address *addr, const char *callsign)\n{\n\tconst char *s;\n\tint n;\n\n\tfor (s = callsign, n = 0; n < 6; n++) {\n\t\tif (*s != '\\0' && *s != '-')\n\t\t\taddr->ax25_call[n] = *s++;\n\t\telse\n\t\t\taddr->ax25_call[n] = ' ';\n\t\taddr->ax25_call[n] <<= 1;\n\t\taddr->ax25_call[n] &= 0xFE;\n\t}\n\n\tif (*s++ == '\\0') {\n\t\taddr->ax25_call[6] = 0x00;\n\t\treturn;\n\t}\n\n\taddr->ax25_call[6] = *s++ - '0';\n\n\tif (*s != '\\0') {\n\t\taddr->ax25_call[6] *= 10;\n\t\taddr->ax25_call[6] += *s++ - '0';\n\t}\n\n\taddr->ax25_call[6] <<= 1;\n\taddr->ax25_call[6] &= 0x1E;\n}\n\nEXPORT_SYMBOL(asc2ax);\n\n \nint ax25cmp(const ax25_address *a, const ax25_address *b)\n{\n\tint ct = 0;\n\n\twhile (ct < 6) {\n\t\tif ((a->ax25_call[ct] & 0xFE) != (b->ax25_call[ct] & 0xFE))\t \n\t\t\treturn 1;\n\t\tct++;\n\t}\n\n\tif ((a->ax25_call[ct] & 0x1E) == (b->ax25_call[ct] & 0x1E))\t \n\t\treturn 0;\n\n\treturn 2;\t\t\t \n}\n\nEXPORT_SYMBOL(ax25cmp);\n\n \nint ax25digicmp(const ax25_digi *digi1, const ax25_digi *digi2)\n{\n\tint i;\n\n\tif (digi1->ndigi != digi2->ndigi)\n\t\treturn 1;\n\n\tif (digi1->lastrepeat != digi2->lastrepeat)\n\t\treturn 1;\n\n\tfor (i = 0; i < digi1->ndigi; i++)\n\t\tif (ax25cmp(&digi1->calls[i], &digi2->calls[i]) != 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n \nconst unsigned char *ax25_addr_parse(const unsigned char *buf, int len,\n\tax25_address *src, ax25_address *dest, ax25_digi *digi, int *flags,\n\tint *dama)\n{\n\tint d = 0;\n\n\tif (len < 14) return NULL;\n\n\tif (flags != NULL) {\n\t\t*flags = 0;\n\n\t\tif (buf[6] & AX25_CBIT)\n\t\t\t*flags = AX25_COMMAND;\n\t\tif (buf[13] & AX25_CBIT)\n\t\t\t*flags = AX25_RESPONSE;\n\t}\n\n\tif (dama != NULL)\n\t\t*dama = ~buf[13] & AX25_DAMA_FLAG;\n\n\t \n\tif (dest != NULL)\n\t\tmemcpy(dest, buf + 0, AX25_ADDR_LEN);\n\tif (src != NULL)\n\t\tmemcpy(src,  buf + 7, AX25_ADDR_LEN);\n\n\tbuf += 2 * AX25_ADDR_LEN;\n\tlen -= 2 * AX25_ADDR_LEN;\n\n\tdigi->lastrepeat = -1;\n\tdigi->ndigi      = 0;\n\n\twhile (!(buf[-1] & AX25_EBIT)) {\n\t\tif (d >= AX25_MAX_DIGIS)\n\t\t\treturn NULL;\n\t\tif (len < AX25_ADDR_LEN)\n\t\t\treturn NULL;\n\n\t\tmemcpy(&digi->calls[d], buf, AX25_ADDR_LEN);\n\t\tdigi->ndigi = d + 1;\n\n\t\tif (buf[6] & AX25_HBIT) {\n\t\t\tdigi->repeated[d] = 1;\n\t\t\tdigi->lastrepeat  = d;\n\t\t} else {\n\t\t\tdigi->repeated[d] = 0;\n\t\t}\n\n\t\tbuf += AX25_ADDR_LEN;\n\t\tlen -= AX25_ADDR_LEN;\n\t\td++;\n\t}\n\n\treturn buf;\n}\n\n \nint ax25_addr_build(unsigned char *buf, const ax25_address *src,\n\tconst ax25_address *dest, const ax25_digi *d, int flag, int modulus)\n{\n\tint len = 0;\n\tint ct  = 0;\n\n\tmemcpy(buf, dest, AX25_ADDR_LEN);\n\tbuf[6] &= ~(AX25_EBIT | AX25_CBIT);\n\tbuf[6] |= AX25_SSSID_SPARE;\n\n\tif (flag == AX25_COMMAND) buf[6] |= AX25_CBIT;\n\n\tbuf += AX25_ADDR_LEN;\n\tlen += AX25_ADDR_LEN;\n\n\tmemcpy(buf, src, AX25_ADDR_LEN);\n\tbuf[6] &= ~(AX25_EBIT | AX25_CBIT);\n\tbuf[6] &= ~AX25_SSSID_SPARE;\n\n\tif (modulus == AX25_MODULUS)\n\t\tbuf[6] |= AX25_SSSID_SPARE;\n\telse\n\t\tbuf[6] |= AX25_ESSID_SPARE;\n\n\tif (flag == AX25_RESPONSE) buf[6] |= AX25_CBIT;\n\n\t \n\tif (d == NULL || d->ndigi == 0) {\n\t\tbuf[6] |= AX25_EBIT;\n\t\treturn 2 * AX25_ADDR_LEN;\n\t}\n\n\tbuf += AX25_ADDR_LEN;\n\tlen += AX25_ADDR_LEN;\n\n\twhile (ct < d->ndigi) {\n\t\tmemcpy(buf, &d->calls[ct], AX25_ADDR_LEN);\n\n\t\tif (d->repeated[ct])\n\t\t\tbuf[6] |= AX25_HBIT;\n\t\telse\n\t\t\tbuf[6] &= ~AX25_HBIT;\n\n\t\tbuf[6] &= ~AX25_EBIT;\n\t\tbuf[6] |= AX25_SSSID_SPARE;\n\n\t\tbuf += AX25_ADDR_LEN;\n\t\tlen += AX25_ADDR_LEN;\n\t\tct++;\n\t}\n\n\tbuf[-1] |= AX25_EBIT;\n\n\treturn len;\n}\n\nint ax25_addr_size(const ax25_digi *dp)\n{\n\tif (dp == NULL)\n\t\treturn 2 * AX25_ADDR_LEN;\n\n\treturn AX25_ADDR_LEN * (2 + dp->ndigi);\n}\n\n \nvoid ax25_digi_invert(const ax25_digi *in, ax25_digi *out)\n{\n\tint ct;\n\n\tout->ndigi      = in->ndigi;\n\tout->lastrepeat = in->ndigi - in->lastrepeat - 2;\n\n\t \n\tfor (ct = 0; ct < in->ndigi; ct++) {\n\t\tout->calls[ct] = in->calls[in->ndigi - ct - 1];\n\n\t\tif (ct <= out->lastrepeat) {\n\t\t\tout->calls[ct].ax25_call[6] |= AX25_HBIT;\n\t\t\tout->repeated[ct]            = 1;\n\t\t} else {\n\t\t\tout->calls[ct].ax25_call[6] &= ~AX25_HBIT;\n\t\t\tout->repeated[ct]            = 0;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}