{
  "module_name": "ax25_ds_subr.c",
  "hash_id": "5edf8434cc2cfb1a4715805e24df49b9838b761232797c60328de5a93bb5f914",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_ds_subr.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/spinlock.h>\n#include <linux/net.h>\n#include <linux/gfp.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n\nvoid ax25_ds_nr_error_recovery(ax25_cb *ax25)\n{\n\tax25_ds_establish_data_link(ax25);\n}\n\n \nvoid ax25_ds_enquiry_response(ax25_cb *ax25)\n{\n\tax25_cb *ax25o;\n\n\t \n\n\tax25_std_enquiry_response(ax25);\n\n\tif (!(ax25->condition & AX25_COND_PEER_RX_BUSY)) {\n\t\tax25_requeue_frames(ax25);\n\t\tax25_kick(ax25);\n\t}\n\n\tif (ax25->state == AX25_STATE_1 || ax25->state == AX25_STATE_2 || skb_peek(&ax25->ack_queue) != NULL)\n\t\tax25_ds_t1_timeout(ax25);\n\telse\n\t\tax25->n2count = 0;\n\n\tax25_start_t3timer(ax25);\n\tax25_ds_set_timer(ax25->ax25_dev);\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(ax25o, &ax25_list) {\n\t\tif (ax25o == ax25)\n\t\t\tcontinue;\n\n\t\tif (ax25o->ax25_dev != ax25->ax25_dev)\n\t\t\tcontinue;\n\n\t\tif (ax25o->state == AX25_STATE_1 || ax25o->state == AX25_STATE_2) {\n\t\t\tax25_ds_t1_timeout(ax25o);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(ax25o->condition & AX25_COND_PEER_RX_BUSY) && ax25o->state == AX25_STATE_3) {\n\t\t\tax25_requeue_frames(ax25o);\n\t\t\tax25_kick(ax25o);\n\t\t}\n\n\t\tif (ax25o->state == AX25_STATE_1 || ax25o->state == AX25_STATE_2 || skb_peek(&ax25o->ack_queue) != NULL)\n\t\t\tax25_ds_t1_timeout(ax25o);\n\n\t\t \n\n\t\tif (ax25o->state != AX25_STATE_0)\n\t\t\tax25_start_t3timer(ax25o);\n\t}\n\tspin_unlock(&ax25_list_lock);\n}\n\nvoid ax25_ds_establish_data_link(ax25_cb *ax25)\n{\n\tax25->condition &= AX25_COND_DAMA_MODE;\n\tax25->n2count    = 0;\n\tax25_calculate_t1(ax25);\n\tax25_start_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_start_t3timer(ax25);\n}\n\n \nstatic void ax25_kiss_cmd(ax25_dev *ax25_dev, unsigned char cmd, unsigned char param)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *p;\n\n\tif (ax25_dev->dev == NULL)\n\t\treturn;\n\n\tif ((skb = alloc_skb(2, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\tskb_reset_network_header(skb);\n\tp = skb_put(skb, 2);\n\n\t*p++ = cmd;\n\t*p++ = param;\n\n\tskb->protocol = ax25_type_trans(skb, ax25_dev->dev);\n\n\tdev_queue_xmit(skb);\n}\n\n \nstatic int ax25_check_dama_slave(ax25_dev *ax25_dev)\n{\n\tax25_cb *ax25;\n\tint res = 0;\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(ax25, &ax25_list)\n\t\tif (ax25->ax25_dev == ax25_dev && (ax25->condition & AX25_COND_DAMA_MODE) && ax25->state > AX25_STATE_1) {\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&ax25_list_lock);\n\n\treturn res;\n}\n\nstatic void ax25_dev_dama_on(ax25_dev *ax25_dev)\n{\n\tif (ax25_dev == NULL)\n\t\treturn;\n\n\tif (ax25_dev->dama.slave == 0)\n\t\tax25_kiss_cmd(ax25_dev, 5, 1);\n\n\tax25_dev->dama.slave = 1;\n\tax25_ds_set_timer(ax25_dev);\n}\n\nvoid ax25_dev_dama_off(ax25_dev *ax25_dev)\n{\n\tif (ax25_dev == NULL)\n\t\treturn;\n\n\tif (ax25_dev->dama.slave && !ax25_check_dama_slave(ax25_dev)) {\n\t\tax25_kiss_cmd(ax25_dev, 5, 0);\n\t\tax25_dev->dama.slave = 0;\n\t\tax25_ds_del_timer(ax25_dev);\n\t}\n}\n\nvoid ax25_dama_on(ax25_cb *ax25)\n{\n\tax25_dev_dama_on(ax25->ax25_dev);\n\tax25->condition |= AX25_COND_DAMA_MODE;\n}\n\nvoid ax25_dama_off(ax25_cb *ax25)\n{\n\tax25->condition &= ~AX25_COND_DAMA_MODE;\n\tax25_dev_dama_off(ax25->ax25_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}