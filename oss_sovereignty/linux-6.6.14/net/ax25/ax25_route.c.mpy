{
  "module_name": "ax25_route.c",
  "hash_id": "e842673790e40ef9f08e3d17e43a4aa652c88aa110a9acac1ec935c959b86a80",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_route.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/timer.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n\nstatic ax25_route *ax25_route_list;\nDEFINE_RWLOCK(ax25_route_lock);\n\nvoid ax25_rt_device_down(struct net_device *dev)\n{\n\tax25_route *s, *t, *ax25_rt;\n\n\twrite_lock_bh(&ax25_route_lock);\n\tax25_rt = ax25_route_list;\n\twhile (ax25_rt != NULL) {\n\t\ts       = ax25_rt;\n\t\tax25_rt = ax25_rt->next;\n\n\t\tif (s->dev == dev) {\n\t\t\tif (ax25_route_list == s) {\n\t\t\t\tax25_route_list = s->next;\n\t\t\t\tkfree(s->digipeat);\n\t\t\t\tkfree(s);\n\t\t\t} else {\n\t\t\t\tfor (t = ax25_route_list; t != NULL; t = t->next) {\n\t\t\t\t\tif (t->next == s) {\n\t\t\t\t\t\tt->next = s->next;\n\t\t\t\t\t\tkfree(s->digipeat);\n\t\t\t\t\t\tkfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twrite_unlock_bh(&ax25_route_lock);\n}\n\nstatic int __must_check ax25_rt_add(struct ax25_routes_struct *route)\n{\n\tax25_route *ax25_rt;\n\tax25_dev *ax25_dev;\n\tint i;\n\n\tif (route->digi_count > AX25_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tax25_dev = ax25_addr_ax25dev(&route->port_addr);\n\tif (!ax25_dev)\n\t\treturn -EINVAL;\n\n\twrite_lock_bh(&ax25_route_lock);\n\n\tax25_rt = ax25_route_list;\n\twhile (ax25_rt != NULL) {\n\t\tif (ax25cmp(&ax25_rt->callsign, &route->dest_addr) == 0 &&\n\t\t\t    ax25_rt->dev == ax25_dev->dev) {\n\t\t\tkfree(ax25_rt->digipeat);\n\t\t\tax25_rt->digipeat = NULL;\n\t\t\tif (route->digi_count != 0) {\n\t\t\t\tif ((ax25_rt->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {\n\t\t\t\t\twrite_unlock_bh(&ax25_route_lock);\n\t\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tax25_rt->digipeat->lastrepeat = -1;\n\t\t\t\tax25_rt->digipeat->ndigi      = route->digi_count;\n\t\t\t\tfor (i = 0; i < route->digi_count; i++) {\n\t\t\t\t\tax25_rt->digipeat->repeated[i] = 0;\n\t\t\t\t\tax25_rt->digipeat->calls[i]    = route->digi_addr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_unlock_bh(&ax25_route_lock);\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\treturn 0;\n\t\t}\n\t\tax25_rt = ax25_rt->next;\n\t}\n\n\tif ((ax25_rt = kmalloc(sizeof(ax25_route), GFP_ATOMIC)) == NULL) {\n\t\twrite_unlock_bh(&ax25_route_lock);\n\t\tax25_dev_put(ax25_dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tax25_rt->callsign     = route->dest_addr;\n\tax25_rt->dev          = ax25_dev->dev;\n\tax25_rt->digipeat     = NULL;\n\tax25_rt->ip_mode      = ' ';\n\tif (route->digi_count != 0) {\n\t\tif ((ax25_rt->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {\n\t\t\twrite_unlock_bh(&ax25_route_lock);\n\t\t\tkfree(ax25_rt);\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tax25_rt->digipeat->lastrepeat = -1;\n\t\tax25_rt->digipeat->ndigi      = route->digi_count;\n\t\tfor (i = 0; i < route->digi_count; i++) {\n\t\t\tax25_rt->digipeat->repeated[i] = 0;\n\t\t\tax25_rt->digipeat->calls[i]    = route->digi_addr[i];\n\t\t}\n\t}\n\tax25_rt->next   = ax25_route_list;\n\tax25_route_list = ax25_rt;\n\twrite_unlock_bh(&ax25_route_lock);\n\tax25_dev_put(ax25_dev);\n\n\treturn 0;\n}\n\nvoid __ax25_put_route(ax25_route *ax25_rt)\n{\n\tkfree(ax25_rt->digipeat);\n\tkfree(ax25_rt);\n}\n\nstatic int ax25_rt_del(struct ax25_routes_struct *route)\n{\n\tax25_route *s, *t, *ax25_rt;\n\tax25_dev *ax25_dev;\n\n\tif ((ax25_dev = ax25_addr_ax25dev(&route->port_addr)) == NULL)\n\t\treturn -EINVAL;\n\n\twrite_lock_bh(&ax25_route_lock);\n\n\tax25_rt = ax25_route_list;\n\twhile (ax25_rt != NULL) {\n\t\ts       = ax25_rt;\n\t\tax25_rt = ax25_rt->next;\n\t\tif (s->dev == ax25_dev->dev &&\n\t\t    ax25cmp(&route->dest_addr, &s->callsign) == 0) {\n\t\t\tif (ax25_route_list == s) {\n\t\t\t\tax25_route_list = s->next;\n\t\t\t\t__ax25_put_route(s);\n\t\t\t} else {\n\t\t\t\tfor (t = ax25_route_list; t != NULL; t = t->next) {\n\t\t\t\t\tif (t->next == s) {\n\t\t\t\t\t\tt->next = s->next;\n\t\t\t\t\t\t__ax25_put_route(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twrite_unlock_bh(&ax25_route_lock);\n\tax25_dev_put(ax25_dev);\n\n\treturn 0;\n}\n\nstatic int ax25_rt_opt(struct ax25_route_opt_struct *rt_option)\n{\n\tax25_route *ax25_rt;\n\tax25_dev *ax25_dev;\n\tint err = 0;\n\n\tif ((ax25_dev = ax25_addr_ax25dev(&rt_option->port_addr)) == NULL)\n\t\treturn -EINVAL;\n\n\twrite_lock_bh(&ax25_route_lock);\n\n\tax25_rt = ax25_route_list;\n\twhile (ax25_rt != NULL) {\n\t\tif (ax25_rt->dev == ax25_dev->dev &&\n\t\t    ax25cmp(&rt_option->dest_addr, &ax25_rt->callsign) == 0) {\n\t\t\tswitch (rt_option->cmd) {\n\t\t\tcase AX25_SET_RT_IPMODE:\n\t\t\t\tswitch (rt_option->arg) {\n\t\t\t\tcase ' ':\n\t\t\t\tcase 'D':\n\t\t\t\tcase 'V':\n\t\t\t\t\tax25_rt->ip_mode = rt_option->arg;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tax25_rt = ax25_rt->next;\n\t}\n\nout:\n\twrite_unlock_bh(&ax25_route_lock);\n\tax25_dev_put(ax25_dev);\n\treturn err;\n}\n\nint ax25_rt_ioctl(unsigned int cmd, void __user *arg)\n{\n\tstruct ax25_route_opt_struct rt_option;\n\tstruct ax25_routes_struct route;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\t\tif (copy_from_user(&route, arg, sizeof(route)))\n\t\t\treturn -EFAULT;\n\t\treturn ax25_rt_add(&route);\n\n\tcase SIOCDELRT:\n\t\tif (copy_from_user(&route, arg, sizeof(route)))\n\t\t\treturn -EFAULT;\n\t\treturn ax25_rt_del(&route);\n\n\tcase SIOCAX25OPTRT:\n\t\tif (copy_from_user(&rt_option, arg, sizeof(rt_option)))\n\t\t\treturn -EFAULT;\n\t\treturn ax25_rt_opt(&rt_option);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *ax25_rt_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(ax25_route_lock)\n{\n\tstruct ax25_route *ax25_rt;\n\tint i = 1;\n\n\tread_lock(&ax25_route_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (ax25_rt = ax25_route_list; ax25_rt != NULL; ax25_rt = ax25_rt->next) {\n\t\tif (i == *pos)\n\t\t\treturn ax25_rt;\n\t\t++i;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *ax25_rt_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn (v == SEQ_START_TOKEN) ? ax25_route_list :\n\t\t((struct ax25_route *) v)->next;\n}\n\nstatic void ax25_rt_seq_stop(struct seq_file *seq, void *v)\n\t__releases(ax25_route_lock)\n{\n\tread_unlock(&ax25_route_lock);\n}\n\nstatic int ax25_rt_seq_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"callsign  dev  mode digipeaters\\n\");\n\telse {\n\t\tstruct ax25_route *ax25_rt = v;\n\t\tconst char *callsign;\n\t\tint i;\n\n\t\tif (ax25cmp(&ax25_rt->callsign, &null_ax25_address) == 0)\n\t\t\tcallsign = \"default\";\n\t\telse\n\t\t\tcallsign = ax2asc(buf, &ax25_rt->callsign);\n\n\t\tseq_printf(seq, \"%-9s %-4s\",\n\t\t\tcallsign,\n\t\t\tax25_rt->dev ? ax25_rt->dev->name : \"???\");\n\n\t\tswitch (ax25_rt->ip_mode) {\n\t\tcase 'V':\n\t\t\tseq_puts(seq, \"   vc\");\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tseq_puts(seq, \"   dg\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_puts(seq, \"    *\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ax25_rt->digipeat != NULL)\n\t\t\tfor (i = 0; i < ax25_rt->digipeat->ndigi; i++)\n\t\t\t\tseq_printf(seq, \" %s\",\n\t\t\t\t     ax2asc(buf, &ax25_rt->digipeat->calls[i]));\n\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\treturn 0;\n}\n\nconst struct seq_operations ax25_rt_seqops = {\n\t.start = ax25_rt_seq_start,\n\t.next = ax25_rt_seq_next,\n\t.stop = ax25_rt_seq_stop,\n\t.show = ax25_rt_seq_show,\n};\n#endif\n\n \nax25_route *ax25_get_route(ax25_address *addr, struct net_device *dev)\n{\n\tax25_route *ax25_spe_rt = NULL;\n\tax25_route *ax25_def_rt = NULL;\n\tax25_route *ax25_rt;\n\n\t \n\tfor (ax25_rt = ax25_route_list; ax25_rt != NULL; ax25_rt = ax25_rt->next) {\n\t\tif (dev == NULL) {\n\t\t\tif (ax25cmp(&ax25_rt->callsign, addr) == 0 && ax25_rt->dev != NULL)\n\t\t\t\tax25_spe_rt = ax25_rt;\n\t\t\tif (ax25cmp(&ax25_rt->callsign, &null_ax25_address) == 0 && ax25_rt->dev != NULL)\n\t\t\t\tax25_def_rt = ax25_rt;\n\t\t} else {\n\t\t\tif (ax25cmp(&ax25_rt->callsign, addr) == 0 && ax25_rt->dev == dev)\n\t\t\t\tax25_spe_rt = ax25_rt;\n\t\t\tif (ax25cmp(&ax25_rt->callsign, &null_ax25_address) == 0 && ax25_rt->dev == dev)\n\t\t\t\tax25_def_rt = ax25_rt;\n\t\t}\n\t}\n\n\tax25_rt = ax25_def_rt;\n\tif (ax25_spe_rt != NULL)\n\t\tax25_rt = ax25_spe_rt;\n\n\treturn ax25_rt;\n}\n\n \nstatic inline void ax25_adjust_path(ax25_address *addr, ax25_digi *digipeat)\n{\n\tint k;\n\n\tfor (k = 0; k < digipeat->ndigi; k++) {\n\t\tif (ax25cmp(addr, &digipeat->calls[k]) == 0)\n\t\t\tbreak;\n\t}\n\n\tdigipeat->ndigi = k;\n}\n\n\n \nint ax25_rt_autobind(ax25_cb *ax25, ax25_address *addr)\n{\n\tax25_uid_assoc *user;\n\tax25_route *ax25_rt;\n\tint err = 0;\n\n\tax25_route_lock_use();\n\tax25_rt = ax25_get_route(addr, NULL);\n\tif (!ax25_rt) {\n\t\tax25_route_lock_unuse();\n\t\treturn -EHOSTUNREACH;\n\t}\n\tif ((ax25->ax25_dev = ax25_dev_ax25dev(ax25_rt->dev)) == NULL) {\n\t\terr = -EHOSTUNREACH;\n\t\tgoto put;\n\t}\n\n\tuser = ax25_findbyuid(current_euid());\n\tif (user) {\n\t\tax25->source_addr = user->call;\n\t\tax25_uid_put(user);\n\t} else {\n\t\tif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto put;\n\t\t}\n\t\tax25->source_addr = *(ax25_address *)ax25->ax25_dev->dev->dev_addr;\n\t}\n\n\tif (ax25_rt->digipeat != NULL) {\n\t\tax25->digipeat = kmemdup(ax25_rt->digipeat, sizeof(ax25_digi),\n\t\t\t\t\t GFP_ATOMIC);\n\t\tif (ax25->digipeat == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto put;\n\t\t}\n\t\tax25_adjust_path(addr, ax25->digipeat);\n\t}\n\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tsock_reset_flag(ax25->sk, SOCK_ZAPPED);\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n\nput:\n\tax25_route_lock_unuse();\n\treturn err;\n}\n\nstruct sk_buff *ax25_rt_build_path(struct sk_buff *skb, ax25_address *src,\n\tax25_address *dest, ax25_digi *digi)\n{\n\tunsigned char *bp;\n\tint len;\n\n\tlen = digi->ndigi * AX25_ADDR_LEN;\n\n\tif (unlikely(skb_headroom(skb) < len)) {\n\t\tskb = skb_expand_head(skb, len);\n\t\tif (!skb) {\n\t\t\tprintk(KERN_CRIT \"AX.25: ax25_dg_build_path - out of memory\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbp = skb_push(skb, len);\n\n\tax25_addr_build(bp, src, dest, digi, AX25_COMMAND, AX25_MODULUS);\n\n\treturn skb;\n}\n\n \nvoid __exit ax25_rt_free(void)\n{\n\tax25_route *s, *ax25_rt = ax25_route_list;\n\n\twrite_lock_bh(&ax25_route_lock);\n\twhile (ax25_rt != NULL) {\n\t\ts       = ax25_rt;\n\t\tax25_rt = ax25_rt->next;\n\n\t\tkfree(s->digipeat);\n\t\tkfree(s);\n\t}\n\twrite_unlock_bh(&ax25_route_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}