{
  "module_name": "ax25_ip.c",
  "hash_id": "06e4546e13f0b27049842189784b3b34db1da2f53478520acb56098137b1d042",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_ip.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t \n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/sysctl.h>\n#include <net/ip.h>\n#include <net/arp.h>\n\n \n\n \n\n#ifdef CONFIG_INET\n\nstatic int ax25_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t    unsigned short type, const void *daddr,\n\t\t\t    const void *saddr, unsigned int len)\n{\n\tunsigned char *buff;\n\n\t \n\tif (type == ETH_P_AX25)\n\t\treturn 0;\n\n\t \n\tbuff = skb_push(skb, AX25_HEADER_LEN);\n\t*buff++ = 0x00;\t \n\n\tif (daddr != NULL)\n\t\tmemcpy(buff, daddr, dev->addr_len);\t \n\n\tbuff[6] &= ~AX25_CBIT;\n\tbuff[6] &= ~AX25_EBIT;\n\tbuff[6] |= AX25_SSSID_SPARE;\n\tbuff    += AX25_ADDR_LEN;\n\n\tif (saddr != NULL)\n\t\tmemcpy(buff, saddr, dev->addr_len);\n\telse\n\t\tmemcpy(buff, dev->dev_addr, dev->addr_len);\n\n\tbuff[6] &= ~AX25_CBIT;\n\tbuff[6] |= AX25_EBIT;\n\tbuff[6] |= AX25_SSSID_SPARE;\n\tbuff    += AX25_ADDR_LEN;\n\n\t*buff++  = AX25_UI;\t \n\n\t \n\tswitch (type) {\n\tcase ETH_P_IP:\n\t\t*buff++ = AX25_P_IP;\n\t\tbreak;\n\tcase ETH_P_ARP:\n\t\t*buff++ = AX25_P_ARP;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"AX.25: ax25_hard_header - wrong protocol type 0x%2.2x\\n\", type);\n\t\t*buff++ = 0;\n\t\tbreak;\n\t}\n\n\tif (daddr != NULL)\n\t\treturn AX25_HEADER_LEN;\n\n\treturn -AX25_HEADER_LEN;\t \n}\n\nnetdev_tx_t ax25_ip_xmit(struct sk_buff *skb)\n{\n\tstruct sk_buff *ourskb;\n\tunsigned char *bp  = skb->data;\n\tax25_route *route;\n\tstruct net_device *dev = NULL;\n\tax25_address *src, *dst;\n\tax25_digi *digipeat = NULL;\n\tax25_dev *ax25_dev;\n\tax25_cb *ax25;\n\tchar ip_mode = ' ';\n\n\tdst = (ax25_address *)(bp + 1);\n\tsrc = (ax25_address *)(bp + 8);\n\n\tax25_route_lock_use();\n\troute = ax25_get_route(dst, NULL);\n\tif (route) {\n\t\tdigipeat = route->digipeat;\n\t\tdev = route->dev;\n\t\tip_mode = route->ip_mode;\n\t}\n\n\tif (dev == NULL)\n\t\tdev = skb->dev;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL) {\n\t\tkfree_skb(skb);\n\t\tgoto put;\n\t}\n\n\tif (bp[16] == AX25_P_IP) {\n\t\tif (ip_mode == 'V' || (ip_mode == ' ' && ax25_dev->values[AX25_VALUES_IPDEFMODE])) {\n\t\t\t \n\n\t\t\tax25_address src_c;\n\t\t\tax25_address dst_c;\n\n\t\t\tif ((ourskb = skb_copy(skb, GFP_ATOMIC)) == NULL) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto put;\n\t\t\t}\n\n\t\t\tif (skb->sk != NULL)\n\t\t\t\tskb_set_owner_w(ourskb, skb->sk);\n\n\t\t\tkfree_skb(skb);\n\t\t\t \n\t\t\tbp  = ourskb->data;\n\t\t\tdst_c = *(ax25_address *)(bp + 1);\n\t\t\tsrc_c = *(ax25_address *)(bp + 8);\n\n\t\t\tskb_pull(ourskb, AX25_HEADER_LEN - 1);\t \n\t\t\tskb_reset_network_header(ourskb);\n\n\t\t\tax25=ax25_send_frame(\n\t\t\t    ourskb,\n\t\t\t    ax25_dev->values[AX25_VALUES_PACLEN],\n\t\t\t    &src_c,\n\t\t\t    &dst_c, digipeat, dev);\n\t\t\tif (ax25) {\n\t\t\t\tax25_cb_put(ax25);\n\t\t\t}\n\t\t\tgoto put;\n\t\t}\n\t}\n\n\tbp[7]  &= ~AX25_CBIT;\n\tbp[7]  &= ~AX25_EBIT;\n\tbp[7]  |= AX25_SSSID_SPARE;\n\n\tbp[14] &= ~AX25_CBIT;\n\tbp[14] |= AX25_EBIT;\n\tbp[14] |= AX25_SSSID_SPARE;\n\n\tskb_pull(skb, AX25_KISS_HEADER_LEN);\n\n\tif (digipeat != NULL) {\n\t\tif ((ourskb = ax25_rt_build_path(skb, src, dst, route->digipeat)) == NULL)\n\t\t\tgoto put;\n\n\t\tskb = ourskb;\n\t}\n\n\tax25_queue_xmit(skb, dev);\n\nput:\n\n\tax25_route_lock_unuse();\n\treturn NETDEV_TX_OK;\n}\n\n#else\t \n\nstatic int ax25_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t    unsigned short type, const void *daddr,\n\t\t\t    const void *saddr, unsigned int len)\n{\n\treturn -AX25_HEADER_LEN;\n}\n\nnetdev_tx_t ax25_ip_xmit(struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n#endif\n\nstatic bool ax25_validate_header(const char *header, unsigned int len)\n{\n\tax25_digi digi;\n\n\tif (!len)\n\t\treturn false;\n\n\tif (header[0])\n\t\treturn true;\n\n\treturn ax25_addr_parse(header + 1, len - 1, NULL, NULL, &digi, NULL,\n\t\t\t       NULL);\n}\n\nconst struct header_ops ax25_header_ops = {\n\t.create = ax25_hard_header,\n\t.validate = ax25_validate_header,\n};\n\nEXPORT_SYMBOL(ax25_header_ops);\nEXPORT_SYMBOL(ax25_ip_xmit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}