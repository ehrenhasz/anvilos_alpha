{
  "module_name": "ax25_uid.c",
  "hash_id": "9a005a3b676ca569c779d17618f1256cf816cadf50eae23b925706c25d5bdb99",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_uid.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/notifier.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/stat.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <net/ip.h>\n#include <net/arp.h>\n\n \n\nstatic HLIST_HEAD(ax25_uid_list);\nstatic DEFINE_RWLOCK(ax25_uid_lock);\n\nint ax25_uid_policy;\n\nEXPORT_SYMBOL(ax25_uid_policy);\n\nax25_uid_assoc *ax25_findbyuid(kuid_t uid)\n{\n\tax25_uid_assoc *ax25_uid, *res = NULL;\n\n\tread_lock(&ax25_uid_lock);\n\tax25_uid_for_each(ax25_uid, &ax25_uid_list) {\n\t\tif (uid_eq(ax25_uid->uid, uid)) {\n\t\t\tax25_uid_hold(ax25_uid);\n\t\t\tres = ax25_uid;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&ax25_uid_lock);\n\n\treturn res;\n}\n\nEXPORT_SYMBOL(ax25_findbyuid);\n\nint ax25_uid_ioctl(int cmd, struct sockaddr_ax25 *sax)\n{\n\tax25_uid_assoc *ax25_uid;\n\tax25_uid_assoc *user;\n\tunsigned long res;\n\n\tswitch (cmd) {\n\tcase SIOCAX25GETUID:\n\t\tres = -ENOENT;\n\t\tread_lock(&ax25_uid_lock);\n\t\tax25_uid_for_each(ax25_uid, &ax25_uid_list) {\n\t\t\tif (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0) {\n\t\t\t\tres = from_kuid_munged(current_user_ns(), ax25_uid->uid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tread_unlock(&ax25_uid_lock);\n\n\t\treturn res;\n\n\tcase SIOCAX25ADDUID:\n\t{\n\t\tkuid_t sax25_kuid;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tsax25_kuid = make_kuid(current_user_ns(), sax->sax25_uid);\n\t\tif (!uid_valid(sax25_kuid))\n\t\t\treturn -EINVAL;\n\t\tuser = ax25_findbyuid(sax25_kuid);\n\t\tif (user) {\n\t\t\tax25_uid_put(user);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (sax->sax25_uid == 0)\n\t\t\treturn -EINVAL;\n\t\tif ((ax25_uid = kmalloc(sizeof(*ax25_uid), GFP_KERNEL)) == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\trefcount_set(&ax25_uid->refcount, 1);\n\t\tax25_uid->uid  = sax25_kuid;\n\t\tax25_uid->call = sax->sax25_call;\n\n\t\twrite_lock(&ax25_uid_lock);\n\t\thlist_add_head(&ax25_uid->uid_node, &ax25_uid_list);\n\t\twrite_unlock(&ax25_uid_lock);\n\n\t\treturn 0;\n\t}\n\tcase SIOCAX25DELUID:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tax25_uid = NULL;\n\t\twrite_lock(&ax25_uid_lock);\n\t\tax25_uid_for_each(ax25_uid, &ax25_uid_list) {\n\t\t\tif (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ax25_uid == NULL) {\n\t\t\twrite_unlock(&ax25_uid_lock);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\thlist_del_init(&ax25_uid->uid_node);\n\t\tax25_uid_put(ax25_uid);\n\t\twrite_unlock(&ax25_uid_lock);\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\t \n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *ax25_uid_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(ax25_uid_lock)\n{\n\tread_lock(&ax25_uid_lock);\n\treturn seq_hlist_start_head(&ax25_uid_list, *pos);\n}\n\nstatic void *ax25_uid_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &ax25_uid_list, pos);\n}\n\nstatic void ax25_uid_seq_stop(struct seq_file *seq, void *v)\n\t__releases(ax25_uid_lock)\n{\n\tread_unlock(&ax25_uid_lock);\n}\n\nstatic int ax25_uid_seq_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq, \"Policy: %d\\n\", ax25_uid_policy);\n\telse {\n\t\tstruct ax25_uid_assoc *pt;\n\n\t\tpt = hlist_entry(v, struct ax25_uid_assoc, uid_node);\n\t\tseq_printf(seq, \"%6d %s\\n\",\n\t\t\tfrom_kuid_munged(seq_user_ns(seq), pt->uid),\n\t\t\tax2asc(buf, &pt->call));\n\t}\n\treturn 0;\n}\n\nconst struct seq_operations ax25_uid_seqops = {\n\t.start = ax25_uid_seq_start,\n\t.next = ax25_uid_seq_next,\n\t.stop = ax25_uid_seq_stop,\n\t.show = ax25_uid_seq_show,\n};\n#endif\n\n \nvoid __exit ax25_uid_free(void)\n{\n\tax25_uid_assoc *ax25_uid;\n\n\twrite_lock(&ax25_uid_lock);\nagain:\n\tax25_uid_for_each(ax25_uid, &ax25_uid_list) {\n\t\thlist_del_init(&ax25_uid->uid_node);\n\t\tax25_uid_put(ax25_uid);\n\t\tgoto again;\n\t}\n\twrite_unlock(&ax25_uid_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}