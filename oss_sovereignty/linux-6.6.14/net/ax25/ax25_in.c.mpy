{
  "module_name": "ax25_in.c",
  "hash_id": "7bf1685fb8c743a5873d5dae341eec514ca049ea88283ddffdd77eb6fa3b2962",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_in.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n\n \nstatic int ax25_rx_fragment(ax25_cb *ax25, struct sk_buff *skb)\n{\n\tstruct sk_buff *skbn, *skbo;\n\n\tif (ax25->fragno != 0) {\n\t\tif (!(*skb->data & AX25_SEG_FIRST)) {\n\t\t\tif ((ax25->fragno - 1) == (*skb->data & AX25_SEG_REM)) {\n\t\t\t\t \n\t\t\t\tax25->fragno = *skb->data & AX25_SEG_REM;\n\t\t\t\tskb_pull(skb, 1);\t \n\t\t\t\tax25->fraglen += skb->len;\n\t\t\t\tskb_queue_tail(&ax25->frag_queue, skb);\n\n\t\t\t\t \n\t\t\t\tif (ax25->fragno == 0) {\n\t\t\t\t\tskbn = alloc_skb(AX25_MAX_HEADER_LEN +\n\t\t\t\t\t\t\t ax25->fraglen,\n\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\t\t\tif (!skbn) {\n\t\t\t\t\t\tskb_queue_purge(&ax25->frag_queue);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tskb_reserve(skbn, AX25_MAX_HEADER_LEN);\n\n\t\t\t\t\tskbn->dev   = ax25->ax25_dev->dev;\n\t\t\t\t\tskb_reset_network_header(skbn);\n\t\t\t\t\tskb_reset_transport_header(skbn);\n\n\t\t\t\t\t \n\t\t\t\t\twhile ((skbo = skb_dequeue(&ax25->frag_queue)) != NULL) {\n\t\t\t\t\t\tskb_copy_from_linear_data(skbo,\n\t\t\t\t\t\t\t  skb_put(skbn, skbo->len),\n\t\t\t\t\t\t\t\t\t  skbo->len);\n\t\t\t\t\t\tkfree_skb(skbo);\n\t\t\t\t\t}\n\n\t\t\t\t\tax25->fraglen = 0;\n\n\t\t\t\t\tif (ax25_rx_iframe(ax25, skbn) == 0)\n\t\t\t\t\t\tkfree_skb(skbn);\n\t\t\t\t}\n\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (*skb->data & AX25_SEG_FIRST) {\n\t\t\tskb_queue_purge(&ax25->frag_queue);\n\t\t\tax25->fragno = *skb->data & AX25_SEG_REM;\n\t\t\tskb_pull(skb, 1);\t\t \n\t\t\tax25->fraglen = skb->len;\n\t\t\tskb_queue_tail(&ax25->frag_queue, skb);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint ax25_rx_iframe(ax25_cb *ax25, struct sk_buff *skb)\n{\n\tint (*func)(struct sk_buff *, ax25_cb *);\n\tunsigned char pid;\n\tint queued = 0;\n\n\tif (skb == NULL) return 0;\n\n\tax25_start_idletimer(ax25);\n\n\tpid = *skb->data;\n\n\tif (pid == AX25_P_IP) {\n\t\t \n\t\tstruct sk_buff *skbn = skb_copy(skb, GFP_ATOMIC);\n\t\tif (skbn != NULL) {\n\t\t\tkfree_skb(skb);\n\t\t\tskb = skbn;\n\t\t}\n\n\t\tskb_pull(skb, 1);\t \n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tskb->dev      = ax25->ax25_dev->dev;\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\tnetif_rx(skb);\n\t\treturn 1;\n\t}\n\tif (pid == AX25_P_SEGMENT) {\n\t\tskb_pull(skb, 1);\t \n\t\treturn ax25_rx_fragment(ax25, skb);\n\t}\n\n\tif ((func = ax25_protocol_function(pid)) != NULL) {\n\t\tskb_pull(skb, 1);\t \n\t\treturn (*func)(skb, ax25);\n\t}\n\n\tif (ax25->sk != NULL && ax25->ax25_dev->values[AX25_VALUES_CONMODE] == 2) {\n\t\tif ((!ax25->pidincl && ax25->sk->sk_protocol == pid) ||\n\t\t    ax25->pidincl) {\n\t\t\tif (sock_queue_rcv_skb(ax25->sk, skb) == 0)\n\t\t\t\tqueued = 1;\n\t\t\telse\n\t\t\t\tax25->condition |= AX25_COND_OWN_RX_BUSY;\n\t\t}\n\t}\n\n\treturn queued;\n}\n\n \nstatic int ax25_process_rx_frame(ax25_cb *ax25, struct sk_buff *skb, int type, int dama)\n{\n\tint queued = 0;\n\n\tif (ax25->state == AX25_STATE_0)\n\t\treturn 0;\n\n\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\tcase AX25_PROTO_STD_SIMPLEX:\n\tcase AX25_PROTO_STD_DUPLEX:\n\t\tqueued = ax25_std_frame_in(ax25, skb, type);\n\t\tbreak;\n\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\tcase AX25_PROTO_DAMA_SLAVE:\n\t\tif (dama || ax25->ax25_dev->dama.slave)\n\t\t\tqueued = ax25_ds_frame_in(ax25, skb, type);\n\t\telse\n\t\t\tqueued = ax25_std_frame_in(ax25, skb, type);\n\t\tbreak;\n#endif\n\t}\n\n\treturn queued;\n}\n\nstatic int ax25_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t    const ax25_address *dev_addr, struct packet_type *ptype)\n{\n\tax25_address src, dest, *next_digi = NULL;\n\tint type = 0, mine = 0, dama;\n\tstruct sock *make, *sk;\n\tax25_digi dp, reverse_dp;\n\tax25_cb *ax25;\n\tax25_dev *ax25_dev;\n\n\t \n\n\tskb_reset_transport_header(skb);\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\tgoto free;\n\n\t \n\n\tif (ax25_addr_parse(skb->data, skb->len, &src, &dest, &dp, &type, &dama) == NULL)\n\t\tgoto free;\n\n\t \n\tif (dp.lastrepeat + 1 < dp.ndigi)\t\t \n\t\tnext_digi = &dp.calls[dp.lastrepeat + 1];\n\n\t \n\tskb_pull(skb, ax25_addr_size(&dp));\n\n\t \n\tif (ax25cmp(&dest, dev_addr) == 0 && dp.lastrepeat + 1 == dp.ndigi)\n\t\tmine = 1;\n\n\t \n\tif (!mine && ax25_listen_mine(&dest, dev) && dp.lastrepeat + 1 == dp.ndigi)\n\t\tmine = 1;\n\n\t \n\tif ((*skb->data & ~0x10) == AX25_UI && dp.lastrepeat + 1 == dp.ndigi) {\n\t\tskb_set_transport_header(skb, 2);  \n\n\t\tax25_send_to_raw(&dest, skb, skb->data[1]);\n\n\t\tif (!mine && ax25cmp(&dest, (ax25_address *)dev->broadcast) != 0)\n\t\t\tgoto free;\n\n\t\t \n\t\tswitch (skb->data[1]) {\n\t\tcase AX25_P_IP:\n\t\t\tskb_pull(skb,2);\t\t \n\t\t\tskb_reset_transport_header(skb);\n\t\t\tskb_reset_network_header(skb);\n\t\t\tskb->dev      = dev;\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t\tskb->protocol = htons(ETH_P_IP);\n\t\t\tnetif_rx(skb);\n\t\t\tbreak;\n\n\t\tcase AX25_P_ARP:\n\t\t\tskb_pull(skb,2);\n\t\t\tskb_reset_transport_header(skb);\n\t\t\tskb_reset_network_header(skb);\n\t\t\tskb->dev      = dev;\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t\tskb->protocol = htons(ETH_P_ARP);\n\t\t\tnetif_rx(skb);\n\t\t\tbreak;\n\t\tcase AX25_P_TEXT:\n\t\t\t \n\t\t\tsk = ax25_get_socket(&dest, &src, SOCK_DGRAM);\n\t\t\tif (sk != NULL) {\n\t\t\t\tbh_lock_sock(sk);\n\t\t\t\tif (atomic_read(&sk->sk_rmem_alloc) >=\n\t\t\t\t    sk->sk_rcvbuf) {\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tskb_pull(skb, 2);\n\t\t\t\t\tif (sock_queue_rcv_skb(sk, skb) != 0)\n\t\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t}\n\t\t\t\tbh_unlock_sock(sk);\n\t\t\t\tsock_put(sk);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tkfree_skb(skb);\t \n\t\t\tbreak;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (ax25_dev->values[AX25_VALUES_CONMODE] == 0)\n\t\tgoto free;\n\n\t \n\n\t \n\n\tax25_digi_invert(&dp, &reverse_dp);\n\n\tif ((ax25 = ax25_find_cb(&dest, &src, &reverse_dp, dev)) != NULL) {\n\t\t \n\t\tif (ax25_process_rx_frame(ax25, skb, type, dama) == 0)\n\t\t\tkfree_skb(skb);\n\n\t\tax25_cb_put(ax25);\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\n\tif ((*skb->data & ~AX25_PF) != AX25_SABM &&\n\t    (*skb->data & ~AX25_PF) != AX25_SABME) {\n\t\t \n\t\tif ((*skb->data & ~AX25_PF) != AX25_DM && mine)\n\t\t\tax25_return_dm(dev, &src, &dest, &dp);\n\n\t\tgoto free;\n\t}\n\n\t \n\n\tif (dp.lastrepeat + 1 == dp.ndigi)\n\t\tsk = ax25_find_listener(&dest, 0, dev, SOCK_SEQPACKET);\n\telse\n\t\tsk = ax25_find_listener(next_digi, 1, dev, SOCK_SEQPACKET);\n\n\tif (sk != NULL) {\n\t\tbh_lock_sock(sk);\n\t\tif (sk_acceptq_is_full(sk) ||\n\t\t    (make = ax25_make_new(sk, ax25_dev)) == NULL) {\n\t\t\tif (mine)\n\t\t\t\tax25_return_dm(dev, &src, &dest, &dp);\n\t\t\tkfree_skb(skb);\n\t\t\tbh_unlock_sock(sk);\n\t\t\tsock_put(sk);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tax25 = sk_to_ax25(make);\n\t\tskb_set_owner_r(skb, make);\n\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\t\tmake->sk_state = TCP_ESTABLISHED;\n\n\t\tsk_acceptq_added(sk);\n\t\tbh_unlock_sock(sk);\n\t} else {\n\t\tif (!mine)\n\t\t\tgoto free;\n\n\t\tif ((ax25 = ax25_create_cb()) == NULL) {\n\t\t\tax25_return_dm(dev, &src, &dest, &dp);\n\t\t\tgoto free;\n\t\t}\n\n\t\tax25_fillin_cb(ax25, ax25_dev);\n\t}\n\n\tax25->source_addr = dest;\n\tax25->dest_addr   = src;\n\n\t \n\tif (dp.ndigi && !ax25->digipeat &&\n\t    (ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {\n\t\tkfree_skb(skb);\n\t\tax25_destroy_socket(ax25);\n\t\tif (sk)\n\t\t\tsock_put(sk);\n\t\treturn 0;\n\t}\n\n\tif (dp.ndigi == 0) {\n\t\tkfree(ax25->digipeat);\n\t\tax25->digipeat = NULL;\n\t} else {\n\t\t \n\t\tmemcpy(ax25->digipeat, &reverse_dp, sizeof(ax25_digi));\n\t}\n\n\tif ((*skb->data & ~AX25_PF) == AX25_SABME) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = ax25_dev->values[AX25_VALUES_EWINDOW];\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = ax25_dev->values[AX25_VALUES_WINDOW];\n\t}\n\n\tax25_send_control(ax25, AX25_UA, AX25_POLLON, AX25_RESPONSE);\n\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\tif (dama && ax25->ax25_dev->values[AX25_VALUES_PROTOCOL] == AX25_PROTO_DAMA_SLAVE)\n\t\tax25_dama_on(ax25);\n#endif\n\n\tax25->state = AX25_STATE_3;\n\n\tax25_cb_add(ax25);\n\n\tax25_start_heartbeat(ax25);\n\tax25_start_t3timer(ax25);\n\tax25_start_idletimer(ax25);\n\n\tif (sk) {\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_data_ready(sk);\n\t\tsock_put(sk);\n\t} else {\nfree:\n\t\tkfree_skb(skb);\n\t}\n\treturn 0;\n}\n\n \nint ax25_kiss_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t  struct packet_type *ptype, struct net_device *orig_dev)\n{\n\tskb_orphan(skb);\n\n\tif (!net_eq(dev_net(dev), &init_net)) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif ((*skb->data & 0x0F) != 0) {\n\t\tkfree_skb(skb);\t \n\t\treturn 0;\n\t}\n\n\tskb_pull(skb, AX25_KISS_HEADER_LEN);\t \n\n\treturn ax25_rcv(skb, dev, (const ax25_address *)dev->dev_addr, ptype);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}