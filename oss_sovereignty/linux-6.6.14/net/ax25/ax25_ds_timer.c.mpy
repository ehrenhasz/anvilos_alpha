{
  "module_name": "ax25_ds_timer.c",
  "hash_id": "d0a2b7671cc94a6b89b4b33a37cb82e012c7a9cbc8bf05ce3edead605574f190",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_ds_timer.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <net/tcp_states.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n\nstatic void ax25_ds_timeout(struct timer_list *);\n\n \n\nvoid ax25_ds_setup_timer(ax25_dev *ax25_dev)\n{\n\ttimer_setup(&ax25_dev->dama.slave_timer, ax25_ds_timeout, 0);\n}\n\nvoid ax25_ds_del_timer(ax25_dev *ax25_dev)\n{\n\tif (ax25_dev)\n\t\tdel_timer(&ax25_dev->dama.slave_timer);\n}\n\nvoid ax25_ds_set_timer(ax25_dev *ax25_dev)\n{\n\tif (ax25_dev == NULL)\t\t \n\t\treturn;\n\n\tax25_dev->dama.slave_timeout =\n\t\tmsecs_to_jiffies(ax25_dev->values[AX25_VALUES_DS_TIMEOUT]) / 10;\n\tmod_timer(&ax25_dev->dama.slave_timer, jiffies + HZ);\n}\n\n \n\nstatic void ax25_ds_timeout(struct timer_list *t)\n{\n\tax25_dev *ax25_dev = from_timer(ax25_dev, t, dama.slave_timer);\n\tax25_cb *ax25;\n\n\tif (ax25_dev == NULL || !ax25_dev->dama.slave)\n\t\treturn;\t\t\t \n\n\tif (!ax25_dev->dama.slave_timeout || --ax25_dev->dama.slave_timeout) {\n\t\tax25_ds_set_timer(ax25_dev);\n\t\treturn;\n\t}\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(ax25, &ax25_list) {\n\t\tif (ax25->ax25_dev != ax25_dev || !(ax25->condition & AX25_COND_DAMA_MODE))\n\t\t\tcontinue;\n\n\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\tax25_disconnect(ax25, ETIMEDOUT);\n\t}\n\tspin_unlock(&ax25_list_lock);\n\n\tax25_dev_dama_off(ax25_dev);\n}\n\nvoid ax25_ds_heartbeat_expiry(ax25_cb *ax25)\n{\n\tstruct sock *sk=ax25->sk;\n\n\tif (sk)\n\t\tbh_lock_sock(sk);\n\n\tswitch (ax25->state) {\n\n\tcase AX25_STATE_0:\n\tcase AX25_STATE_2:\n\t\t \n\t\tif (!sk || sock_flag(sk, SOCK_DESTROY) ||\n\t\t    (sk->sk_state == TCP_LISTEN &&\n\t\t     sock_flag(sk, SOCK_DEAD))) {\n\t\t\tif (sk) {\n\t\t\t\tsock_hold(sk);\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\t\tbh_unlock_sock(sk);\n\t\t\t\t \n\t\t\t\tsock_put(sk);\n\t\t\t} else\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase AX25_STATE_3:\n\t\t \n\t\tif (sk != NULL) {\n\t\t\tif (atomic_read(&sk->sk_rmem_alloc) <\n\t\t\t    (sk->sk_rcvbuf >> 1) &&\n\t\t\t    (ax25->condition & AX25_COND_OWN_RX_BUSY)) {\n\t\t\t\tax25->condition &= ~AX25_COND_OWN_RX_BUSY;\n\t\t\t\tax25->condition &= ~AX25_COND_ACK_PENDING;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (sk)\n\t\tbh_unlock_sock(sk);\n\n\tax25_start_heartbeat(ax25);\n}\n\n \nvoid ax25_ds_t3timer_expiry(ax25_cb *ax25)\n{\n\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\tax25_dama_off(ax25);\n\tax25_disconnect(ax25, ETIMEDOUT);\n}\n\n \nvoid ax25_ds_idletimer_expiry(ax25_cb *ax25)\n{\n\tax25_clear_queues(ax25);\n\n\tax25->n2count = 0;\n\tax25->state = AX25_STATE_2;\n\n\tax25_calculate_t1(ax25);\n\tax25_start_t1timer(ax25);\n\tax25_stop_t3timer(ax25);\n\n\tif (ax25->sk != NULL) {\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = 0;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t}\n}\n\n \nvoid ax25_ds_t1_timeout(ax25_cb *ax25)\n{\n\tswitch (ax25->state) {\n\tcase AX25_STATE_1:\n\t\tif (ax25->n2count == ax25->n2) {\n\t\t\tif (ax25->modulus == AX25_MODULUS) {\n\t\t\t\tax25_disconnect(ax25, ETIMEDOUT);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tax25->modulus = AX25_MODULUS;\n\t\t\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\n\t\t\t\tax25->n2count = 0;\n\t\t\t\tax25_send_control(ax25, AX25_SABM, AX25_POLLOFF, AX25_COMMAND);\n\t\t\t}\n\t\t} else {\n\t\t\tax25->n2count++;\n\t\t\tif (ax25->modulus == AX25_MODULUS)\n\t\t\t\tax25_send_control(ax25, AX25_SABM, AX25_POLLOFF, AX25_COMMAND);\n\t\t\telse\n\t\t\t\tax25_send_control(ax25, AX25_SABME, AX25_POLLOFF, AX25_COMMAND);\n\t\t}\n\t\tbreak;\n\n\tcase AX25_STATE_2:\n\t\tif (ax25->n2count == ax25->n2) {\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_disconnect(ax25, ETIMEDOUT);\n\t\t\treturn;\n\t\t} else {\n\t\t\tax25->n2count++;\n\t\t}\n\t\tbreak;\n\n\tcase AX25_STATE_3:\n\t\tif (ax25->n2count == ax25->n2) {\n\t\t\tax25_send_control(ax25, AX25_DM, AX25_POLLON, AX25_RESPONSE);\n\t\t\tax25_disconnect(ax25, ETIMEDOUT);\n\t\t\treturn;\n\t\t} else {\n\t\t\tax25->n2count++;\n\t\t}\n\t\tbreak;\n\t}\n\n\tax25_calculate_t1(ax25);\n\tax25_start_t1timer(ax25);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}