{
  "module_name": "ax25_std_in.c",
  "hash_id": "64ff2ac68c4abf715cdc82c5106d923689a260d4dc1b07eb17e2480085093120",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_std_in.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n\n \nstatic int ax25_std_state1_machine(ax25_cb *ax25, struct sk_buff *skb, int frametype, int pf, int type)\n{\n\tswitch (frametype) {\n\tcase AX25_SABM:\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\n\t\tax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\n\t\tbreak;\n\n\tcase AX25_SABME:\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_EWINDOW];\n\t\tax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\n\t\tbreak;\n\n\tcase AX25_DISC:\n\t\tax25_send_control(ax25, AX25_DM, pf, AX25_RESPONSE);\n\t\tbreak;\n\n\tcase AX25_UA:\n\t\tif (pf) {\n\t\t\tax25_calculate_rtt(ax25);\n\t\t\tax25_stop_t1timer(ax25);\n\t\t\tax25_start_t3timer(ax25);\n\t\t\tax25_start_idletimer(ax25);\n\t\t\tax25->vs      = 0;\n\t\t\tax25->va      = 0;\n\t\t\tax25->vr      = 0;\n\t\t\tax25->state   = AX25_STATE_3;\n\t\t\tax25->n2count = 0;\n\t\t\tif (ax25->sk != NULL) {\n\t\t\t\tbh_lock_sock(ax25->sk);\n\t\t\t\tax25->sk->sk_state = TCP_ESTABLISHED;\n\t\t\t\t \n\t\t\t\tif (!sock_flag(ax25->sk, SOCK_DEAD))\n\t\t\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\t\tbh_unlock_sock(ax25->sk);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase AX25_DM:\n\t\tif (pf) {\n\t\t\tif (ax25->modulus == AX25_MODULUS) {\n\t\t\t\tax25_disconnect(ax25, ECONNREFUSED);\n\t\t\t} else {\n\t\t\t\tax25->modulus = AX25_MODULUS;\n\t\t\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ax25_std_state2_machine(ax25_cb *ax25, struct sk_buff *skb, int frametype, int pf, int type)\n{\n\tswitch (frametype) {\n\tcase AX25_SABM:\n\tcase AX25_SABME:\n\t\tax25_send_control(ax25, AX25_DM, pf, AX25_RESPONSE);\n\t\tbreak;\n\n\tcase AX25_DISC:\n\t\tax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\n\t\tax25_disconnect(ax25, 0);\n\t\tbreak;\n\n\tcase AX25_DM:\n\tcase AX25_UA:\n\t\tif (pf)\n\t\t\tax25_disconnect(ax25, 0);\n\t\tbreak;\n\n\tcase AX25_I:\n\tcase AX25_REJ:\n\tcase AX25_RNR:\n\tcase AX25_RR:\n\t\tif (pf) ax25_send_control(ax25, AX25_DM, AX25_POLLON, AX25_RESPONSE);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ax25_std_state3_machine(ax25_cb *ax25, struct sk_buff *skb, int frametype, int ns, int nr, int pf, int type)\n{\n\tint queued = 0;\n\n\tswitch (frametype) {\n\tcase AX25_SABM:\n\tcase AX25_SABME:\n\t\tif (frametype == AX25_SABM) {\n\t\t\tax25->modulus = AX25_MODULUS;\n\t\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\n\t\t} else {\n\t\t\tax25->modulus = AX25_EMODULUS;\n\t\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_EWINDOW];\n\t\t}\n\t\tax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\n\t\tax25_stop_t1timer(ax25);\n\t\tax25_stop_t2timer(ax25);\n\t\tax25_start_t3timer(ax25);\n\t\tax25_start_idletimer(ax25);\n\t\tax25->condition = 0x00;\n\t\tax25->vs        = 0;\n\t\tax25->va        = 0;\n\t\tax25->vr        = 0;\n\t\tax25_requeue_frames(ax25);\n\t\tbreak;\n\n\tcase AX25_DISC:\n\t\tax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\n\t\tax25_disconnect(ax25, 0);\n\t\tbreak;\n\n\tcase AX25_DM:\n\t\tax25_disconnect(ax25, ECONNRESET);\n\t\tbreak;\n\n\tcase AX25_RR:\n\tcase AX25_RNR:\n\t\tif (frametype == AX25_RR)\n\t\t\tax25->condition &= ~AX25_COND_PEER_RX_BUSY;\n\t\telse\n\t\t\tax25->condition |= AX25_COND_PEER_RX_BUSY;\n\t\tif (type == AX25_COMMAND && pf)\n\t\t\tax25_std_enquiry_response(ax25);\n\t\tif (ax25_validate_nr(ax25, nr)) {\n\t\t\tax25_check_iframes_acked(ax25, nr);\n\t\t} else {\n\t\t\tax25_std_nr_error_recovery(ax25);\n\t\t\tax25->state = AX25_STATE_1;\n\t\t}\n\t\tbreak;\n\n\tcase AX25_REJ:\n\t\tax25->condition &= ~AX25_COND_PEER_RX_BUSY;\n\t\tif (type == AX25_COMMAND && pf)\n\t\t\tax25_std_enquiry_response(ax25);\n\t\tif (ax25_validate_nr(ax25, nr)) {\n\t\t\tax25_frames_acked(ax25, nr);\n\t\t\tax25_calculate_rtt(ax25);\n\t\t\tax25_stop_t1timer(ax25);\n\t\t\tax25_start_t3timer(ax25);\n\t\t\tax25_requeue_frames(ax25);\n\t\t} else {\n\t\t\tax25_std_nr_error_recovery(ax25);\n\t\t\tax25->state = AX25_STATE_1;\n\t\t}\n\t\tbreak;\n\n\tcase AX25_I:\n\t\tif (!ax25_validate_nr(ax25, nr)) {\n\t\t\tax25_std_nr_error_recovery(ax25);\n\t\t\tax25->state = AX25_STATE_1;\n\t\t\tbreak;\n\t\t}\n\t\tif (ax25->condition & AX25_COND_PEER_RX_BUSY) {\n\t\t\tax25_frames_acked(ax25, nr);\n\t\t} else {\n\t\t\tax25_check_iframes_acked(ax25, nr);\n\t\t}\n\t\tif (ax25->condition & AX25_COND_OWN_RX_BUSY) {\n\t\t\tif (pf) ax25_std_enquiry_response(ax25);\n\t\t\tbreak;\n\t\t}\n\t\tif (ns == ax25->vr) {\n\t\t\tax25->vr = (ax25->vr + 1) % ax25->modulus;\n\t\t\tqueued = ax25_rx_iframe(ax25, skb);\n\t\t\tif (ax25->condition & AX25_COND_OWN_RX_BUSY)\n\t\t\t\tax25->vr = ns;\t \n\t\t\tax25->condition &= ~AX25_COND_REJECT;\n\t\t\tif (pf) {\n\t\t\t\tax25_std_enquiry_response(ax25);\n\t\t\t} else {\n\t\t\t\tif (!(ax25->condition & AX25_COND_ACK_PENDING)) {\n\t\t\t\t\tax25->condition |= AX25_COND_ACK_PENDING;\n\t\t\t\t\tax25_start_t2timer(ax25);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (ax25->condition & AX25_COND_REJECT) {\n\t\t\t\tif (pf) ax25_std_enquiry_response(ax25);\n\t\t\t} else {\n\t\t\t\tax25->condition |= AX25_COND_REJECT;\n\t\t\t\tax25_send_control(ax25, AX25_REJ, pf, AX25_RESPONSE);\n\t\t\t\tax25->condition &= ~AX25_COND_ACK_PENDING;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase AX25_FRMR:\n\tcase AX25_ILLEGAL:\n\t\tax25_std_establish_data_link(ax25);\n\t\tax25->state = AX25_STATE_1;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn queued;\n}\n\n \nstatic int ax25_std_state4_machine(ax25_cb *ax25, struct sk_buff *skb, int frametype, int ns, int nr, int pf, int type)\n{\n\tint queued = 0;\n\n\tswitch (frametype) {\n\tcase AX25_SABM:\n\tcase AX25_SABME:\n\t\tif (frametype == AX25_SABM) {\n\t\t\tax25->modulus = AX25_MODULUS;\n\t\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\n\t\t} else {\n\t\t\tax25->modulus = AX25_EMODULUS;\n\t\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_EWINDOW];\n\t\t}\n\t\tax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\n\t\tax25_stop_t1timer(ax25);\n\t\tax25_stop_t2timer(ax25);\n\t\tax25_start_t3timer(ax25);\n\t\tax25_start_idletimer(ax25);\n\t\tax25->condition = 0x00;\n\t\tax25->vs        = 0;\n\t\tax25->va        = 0;\n\t\tax25->vr        = 0;\n\t\tax25->state     = AX25_STATE_3;\n\t\tax25->n2count   = 0;\n\t\tax25_requeue_frames(ax25);\n\t\tbreak;\n\n\tcase AX25_DISC:\n\t\tax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\n\t\tax25_disconnect(ax25, 0);\n\t\tbreak;\n\n\tcase AX25_DM:\n\t\tax25_disconnect(ax25, ECONNRESET);\n\t\tbreak;\n\n\tcase AX25_RR:\n\tcase AX25_RNR:\n\t\tif (frametype == AX25_RR)\n\t\t\tax25->condition &= ~AX25_COND_PEER_RX_BUSY;\n\t\telse\n\t\t\tax25->condition |= AX25_COND_PEER_RX_BUSY;\n\t\tif (type == AX25_RESPONSE && pf) {\n\t\t\tax25_stop_t1timer(ax25);\n\t\t\tax25->n2count = 0;\n\t\t\tif (ax25_validate_nr(ax25, nr)) {\n\t\t\t\tax25_frames_acked(ax25, nr);\n\t\t\t\tif (ax25->vs == ax25->va) {\n\t\t\t\t\tax25_start_t3timer(ax25);\n\t\t\t\t\tax25->state   = AX25_STATE_3;\n\t\t\t\t} else {\n\t\t\t\t\tax25_requeue_frames(ax25);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tax25_std_nr_error_recovery(ax25);\n\t\t\t\tax25->state = AX25_STATE_1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (type == AX25_COMMAND && pf)\n\t\t\tax25_std_enquiry_response(ax25);\n\t\tif (ax25_validate_nr(ax25, nr)) {\n\t\t\tax25_frames_acked(ax25, nr);\n\t\t} else {\n\t\t\tax25_std_nr_error_recovery(ax25);\n\t\t\tax25->state = AX25_STATE_1;\n\t\t}\n\t\tbreak;\n\n\tcase AX25_REJ:\n\t\tax25->condition &= ~AX25_COND_PEER_RX_BUSY;\n\t\tif (pf && type == AX25_RESPONSE) {\n\t\t\tax25_stop_t1timer(ax25);\n\t\t\tax25->n2count = 0;\n\t\t\tif (ax25_validate_nr(ax25, nr)) {\n\t\t\t\tax25_frames_acked(ax25, nr);\n\t\t\t\tif (ax25->vs == ax25->va) {\n\t\t\t\t\tax25_start_t3timer(ax25);\n\t\t\t\t\tax25->state   = AX25_STATE_3;\n\t\t\t\t} else {\n\t\t\t\t\tax25_requeue_frames(ax25);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tax25_std_nr_error_recovery(ax25);\n\t\t\t\tax25->state = AX25_STATE_1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (type == AX25_COMMAND && pf)\n\t\t\tax25_std_enquiry_response(ax25);\n\t\tif (ax25_validate_nr(ax25, nr)) {\n\t\t\tax25_frames_acked(ax25, nr);\n\t\t\tax25_requeue_frames(ax25);\n\t\t} else {\n\t\t\tax25_std_nr_error_recovery(ax25);\n\t\t\tax25->state = AX25_STATE_1;\n\t\t}\n\t\tbreak;\n\n\tcase AX25_I:\n\t\tif (!ax25_validate_nr(ax25, nr)) {\n\t\t\tax25_std_nr_error_recovery(ax25);\n\t\t\tax25->state = AX25_STATE_1;\n\t\t\tbreak;\n\t\t}\n\t\tax25_frames_acked(ax25, nr);\n\t\tif (ax25->condition & AX25_COND_OWN_RX_BUSY) {\n\t\t\tif (pf)\n\t\t\t\tax25_std_enquiry_response(ax25);\n\t\t\tbreak;\n\t\t}\n\t\tif (ns == ax25->vr) {\n\t\t\tax25->vr = (ax25->vr + 1) % ax25->modulus;\n\t\t\tqueued = ax25_rx_iframe(ax25, skb);\n\t\t\tif (ax25->condition & AX25_COND_OWN_RX_BUSY)\n\t\t\t\tax25->vr = ns;\t \n\t\t\tax25->condition &= ~AX25_COND_REJECT;\n\t\t\tif (pf) {\n\t\t\t\tax25_std_enquiry_response(ax25);\n\t\t\t} else {\n\t\t\t\tif (!(ax25->condition & AX25_COND_ACK_PENDING)) {\n\t\t\t\t\tax25->condition |= AX25_COND_ACK_PENDING;\n\t\t\t\t\tax25_start_t2timer(ax25);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (ax25->condition & AX25_COND_REJECT) {\n\t\t\t\tif (pf) ax25_std_enquiry_response(ax25);\n\t\t\t} else {\n\t\t\t\tax25->condition |= AX25_COND_REJECT;\n\t\t\t\tax25_send_control(ax25, AX25_REJ, pf, AX25_RESPONSE);\n\t\t\t\tax25->condition &= ~AX25_COND_ACK_PENDING;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase AX25_FRMR:\n\tcase AX25_ILLEGAL:\n\t\tax25_std_establish_data_link(ax25);\n\t\tax25->state = AX25_STATE_1;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn queued;\n}\n\n \nint ax25_std_frame_in(ax25_cb *ax25, struct sk_buff *skb, int type)\n{\n\tint queued = 0, frametype, ns, nr, pf;\n\n\tframetype = ax25_decode(ax25, skb, &ns, &nr, &pf);\n\n\tswitch (ax25->state) {\n\tcase AX25_STATE_1:\n\t\tqueued = ax25_std_state1_machine(ax25, skb, frametype, pf, type);\n\t\tbreak;\n\tcase AX25_STATE_2:\n\t\tqueued = ax25_std_state2_machine(ax25, skb, frametype, pf, type);\n\t\tbreak;\n\tcase AX25_STATE_3:\n\t\tqueued = ax25_std_state3_machine(ax25, skb, frametype, ns, nr, pf, type);\n\t\tbreak;\n\tcase AX25_STATE_4:\n\t\tqueued = ax25_std_state4_machine(ax25, skb, frametype, ns, nr, pf, type);\n\t\tbreak;\n\t}\n\n\tax25_kick(ax25);\n\n\treturn queued;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}