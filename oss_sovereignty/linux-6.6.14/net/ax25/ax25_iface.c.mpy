{
  "module_name": "ax25_iface.c",
  "hash_id": "d062d17fa21d732d22eb8d64b7280312bf6f89e63068fbe24b81e66b5856d9dc",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_iface.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n\nstatic struct ax25_protocol *protocol_list;\nstatic DEFINE_RWLOCK(protocol_list_lock);\n\nstatic HLIST_HEAD(ax25_linkfail_list);\nstatic DEFINE_SPINLOCK(linkfail_lock);\n\nstatic struct listen_struct {\n\tstruct listen_struct *next;\n\tax25_address  callsign;\n\tstruct net_device *dev;\n} *listen_list = NULL;\nstatic DEFINE_SPINLOCK(listen_lock);\n\n \nvoid ax25_register_pid(struct ax25_protocol *ap)\n{\n\twrite_lock_bh(&protocol_list_lock);\n\tap->next = protocol_list;\n\tprotocol_list = ap;\n\twrite_unlock_bh(&protocol_list_lock);\n}\n\nEXPORT_SYMBOL_GPL(ax25_register_pid);\n\nvoid ax25_protocol_release(unsigned int pid)\n{\n\tstruct ax25_protocol *protocol;\n\n\twrite_lock_bh(&protocol_list_lock);\n\tprotocol = protocol_list;\n\tif (protocol == NULL)\n\t\tgoto out;\n\n\tif (protocol->pid == pid) {\n\t\tprotocol_list = protocol->next;\n\t\tgoto out;\n\t}\n\n\twhile (protocol != NULL && protocol->next != NULL) {\n\t\tif (protocol->next->pid == pid) {\n\t\t\tprotocol->next = protocol->next->next;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprotocol = protocol->next;\n\t}\nout:\n\twrite_unlock_bh(&protocol_list_lock);\n}\n\nEXPORT_SYMBOL(ax25_protocol_release);\n\nvoid ax25_linkfail_register(struct ax25_linkfail *lf)\n{\n\tspin_lock_bh(&linkfail_lock);\n\thlist_add_head(&lf->lf_node, &ax25_linkfail_list);\n\tspin_unlock_bh(&linkfail_lock);\n}\n\nEXPORT_SYMBOL(ax25_linkfail_register);\n\nvoid ax25_linkfail_release(struct ax25_linkfail *lf)\n{\n\tspin_lock_bh(&linkfail_lock);\n\thlist_del_init(&lf->lf_node);\n\tspin_unlock_bh(&linkfail_lock);\n}\n\nEXPORT_SYMBOL(ax25_linkfail_release);\n\nint ax25_listen_register(const ax25_address *callsign, struct net_device *dev)\n{\n\tstruct listen_struct *listen;\n\n\tif (ax25_listen_mine(callsign, dev))\n\t\treturn 0;\n\n\tif ((listen = kmalloc(sizeof(*listen), GFP_ATOMIC)) == NULL)\n\t\treturn -ENOMEM;\n\n\tlisten->callsign = *callsign;\n\tlisten->dev      = dev;\n\n\tspin_lock_bh(&listen_lock);\n\tlisten->next = listen_list;\n\tlisten_list  = listen;\n\tspin_unlock_bh(&listen_lock);\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL(ax25_listen_register);\n\nvoid ax25_listen_release(const ax25_address *callsign, struct net_device *dev)\n{\n\tstruct listen_struct *s, *listen;\n\n\tspin_lock_bh(&listen_lock);\n\tlisten = listen_list;\n\tif (listen == NULL) {\n\t\tspin_unlock_bh(&listen_lock);\n\t\treturn;\n\t}\n\n\tif (ax25cmp(&listen->callsign, callsign) == 0 && listen->dev == dev) {\n\t\tlisten_list = listen->next;\n\t\tspin_unlock_bh(&listen_lock);\n\t\tkfree(listen);\n\t\treturn;\n\t}\n\n\twhile (listen != NULL && listen->next != NULL) {\n\t\tif (ax25cmp(&listen->next->callsign, callsign) == 0 && listen->next->dev == dev) {\n\t\t\ts = listen->next;\n\t\t\tlisten->next = listen->next->next;\n\t\t\tspin_unlock_bh(&listen_lock);\n\t\t\tkfree(s);\n\t\t\treturn;\n\t\t}\n\n\t\tlisten = listen->next;\n\t}\n\tspin_unlock_bh(&listen_lock);\n}\n\nEXPORT_SYMBOL(ax25_listen_release);\n\nint (*ax25_protocol_function(unsigned int pid))(struct sk_buff *, ax25_cb *)\n{\n\tint (*res)(struct sk_buff *, ax25_cb *) = NULL;\n\tstruct ax25_protocol *protocol;\n\n\tread_lock(&protocol_list_lock);\n\tfor (protocol = protocol_list; protocol != NULL; protocol = protocol->next)\n\t\tif (protocol->pid == pid) {\n\t\t\tres = protocol->func;\n\t\t\tbreak;\n\t\t}\n\tread_unlock(&protocol_list_lock);\n\n\treturn res;\n}\n\nint ax25_listen_mine(const ax25_address *callsign, struct net_device *dev)\n{\n\tstruct listen_struct *listen;\n\n\tspin_lock_bh(&listen_lock);\n\tfor (listen = listen_list; listen != NULL; listen = listen->next)\n\t\tif (ax25cmp(&listen->callsign, callsign) == 0 &&\n\t\t    (listen->dev == dev || listen->dev == NULL)) {\n\t\t\tspin_unlock_bh(&listen_lock);\n\t\t\treturn 1;\n\t}\n\tspin_unlock_bh(&listen_lock);\n\n\treturn 0;\n}\n\nvoid ax25_link_failed(ax25_cb *ax25, int reason)\n{\n\tstruct ax25_linkfail *lf;\n\n\tspin_lock_bh(&linkfail_lock);\n\thlist_for_each_entry(lf, &ax25_linkfail_list, lf_node)\n\t\tlf->func(ax25, reason);\n\tspin_unlock_bh(&linkfail_lock);\n}\n\nint ax25_protocol_is_registered(unsigned int pid)\n{\n\tstruct ax25_protocol *protocol;\n\tint res = 0;\n\n\tread_lock_bh(&protocol_list_lock);\n\tfor (protocol = protocol_list; protocol != NULL; protocol = protocol->next)\n\t\tif (protocol->pid == pid) {\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\tread_unlock_bh(&protocol_list_lock);\n\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}