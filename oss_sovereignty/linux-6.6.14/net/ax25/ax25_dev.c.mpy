{
  "module_name": "ax25_dev.c",
  "hash_id": "1d8d331ac9bc148fd4e73e34c587596d097a89d1ef63780fd9bc60c0389a8057",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_dev.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/spinlock.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n\nax25_dev *ax25_dev_list;\nDEFINE_SPINLOCK(ax25_dev_lock);\n\nax25_dev *ax25_addr_ax25dev(ax25_address *addr)\n{\n\tax25_dev *ax25_dev, *res = NULL;\n\n\tspin_lock_bh(&ax25_dev_lock);\n\tfor (ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next)\n\t\tif (ax25cmp(addr, (const ax25_address *)ax25_dev->dev->dev_addr) == 0) {\n\t\t\tres = ax25_dev;\n\t\t\tax25_dev_hold(ax25_dev);\n\t\t}\n\tspin_unlock_bh(&ax25_dev_lock);\n\n\treturn res;\n}\n\n \nvoid ax25_dev_device_up(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\n\tax25_dev = kzalloc(sizeof(*ax25_dev), GFP_KERNEL);\n\tif (!ax25_dev) {\n\t\tprintk(KERN_ERR \"AX.25: ax25_dev_device_up - out of memory\\n\");\n\t\treturn;\n\t}\n\n\trefcount_set(&ax25_dev->refcount, 1);\n\tdev->ax25_ptr     = ax25_dev;\n\tax25_dev->dev     = dev;\n\tnetdev_hold(dev, &ax25_dev->dev_tracker, GFP_KERNEL);\n\tax25_dev->forward = NULL;\n\tax25_dev->device_up = true;\n\n\tax25_dev->values[AX25_VALUES_IPDEFMODE] = AX25_DEF_IPDEFMODE;\n\tax25_dev->values[AX25_VALUES_AXDEFMODE] = AX25_DEF_AXDEFMODE;\n\tax25_dev->values[AX25_VALUES_BACKOFF]   = AX25_DEF_BACKOFF;\n\tax25_dev->values[AX25_VALUES_CONMODE]   = AX25_DEF_CONMODE;\n\tax25_dev->values[AX25_VALUES_WINDOW]    = AX25_DEF_WINDOW;\n\tax25_dev->values[AX25_VALUES_EWINDOW]   = AX25_DEF_EWINDOW;\n\tax25_dev->values[AX25_VALUES_T1]        = AX25_DEF_T1;\n\tax25_dev->values[AX25_VALUES_T2]        = AX25_DEF_T2;\n\tax25_dev->values[AX25_VALUES_T3]        = AX25_DEF_T3;\n\tax25_dev->values[AX25_VALUES_IDLE]\t= AX25_DEF_IDLE;\n\tax25_dev->values[AX25_VALUES_N2]        = AX25_DEF_N2;\n\tax25_dev->values[AX25_VALUES_PACLEN]\t= AX25_DEF_PACLEN;\n\tax25_dev->values[AX25_VALUES_PROTOCOL]  = AX25_DEF_PROTOCOL;\n\tax25_dev->values[AX25_VALUES_DS_TIMEOUT]= AX25_DEF_DS_TIMEOUT;\n\n#if defined(CONFIG_AX25_DAMA_SLAVE) || defined(CONFIG_AX25_DAMA_MASTER)\n\tax25_ds_setup_timer(ax25_dev);\n#endif\n\n\tspin_lock_bh(&ax25_dev_lock);\n\tax25_dev->next = ax25_dev_list;\n\tax25_dev_list  = ax25_dev;\n\tspin_unlock_bh(&ax25_dev_lock);\n\tax25_dev_hold(ax25_dev);\n\n\tax25_register_dev_sysctl(ax25_dev);\n}\n\nvoid ax25_dev_device_down(struct net_device *dev)\n{\n\tax25_dev *s, *ax25_dev;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tax25_unregister_dev_sysctl(ax25_dev);\n\n\tspin_lock_bh(&ax25_dev_lock);\n\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\tax25_ds_del_timer(ax25_dev);\n#endif\n\n\t \n\tfor (s = ax25_dev_list; s != NULL; s = s->next)\n\t\tif (s->forward == dev)\n\t\t\ts->forward = NULL;\n\n\tif ((s = ax25_dev_list) == ax25_dev) {\n\t\tax25_dev_list = s->next;\n\t\tgoto unlock_put;\n\t}\n\n\twhile (s != NULL && s->next != NULL) {\n\t\tif (s->next == ax25_dev) {\n\t\t\ts->next = ax25_dev->next;\n\t\t\tgoto unlock_put;\n\t\t}\n\n\t\ts = s->next;\n\t}\n\tspin_unlock_bh(&ax25_dev_lock);\n\tdev->ax25_ptr = NULL;\n\tax25_dev_put(ax25_dev);\n\treturn;\n\nunlock_put:\n\tspin_unlock_bh(&ax25_dev_lock);\n\tax25_dev_put(ax25_dev);\n\tdev->ax25_ptr = NULL;\n\tnetdev_put(dev, &ax25_dev->dev_tracker);\n\tax25_dev_put(ax25_dev);\n}\n\nint ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)\n{\n\tax25_dev *ax25_dev, *fwd_dev;\n\n\tif ((ax25_dev = ax25_addr_ax25dev(&fwd->port_from)) == NULL)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCAX25ADDFWD:\n\t\tfwd_dev = ax25_addr_ax25dev(&fwd->port_to);\n\t\tif (!fwd_dev) {\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ax25_dev->forward) {\n\t\t\tax25_dev_put(fwd_dev);\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tax25_dev->forward = fwd_dev->dev;\n\t\tax25_dev_put(fwd_dev);\n\t\tax25_dev_put(ax25_dev);\n\t\tbreak;\n\n\tcase SIOCAX25DELFWD:\n\t\tif (!ax25_dev->forward) {\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tax25_dev->forward = NULL;\n\t\tax25_dev_put(ax25_dev);\n\t\tbreak;\n\n\tdefault:\n\t\tax25_dev_put(ax25_dev);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct net_device *ax25_fwd_dev(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn dev;\n\n\tif (ax25_dev->forward == NULL)\n\t\treturn dev;\n\n\treturn ax25_dev->forward;\n}\n\n \nvoid __exit ax25_dev_free(void)\n{\n\tax25_dev *s, *ax25_dev;\n\n\tspin_lock_bh(&ax25_dev_lock);\n\tax25_dev = ax25_dev_list;\n\twhile (ax25_dev != NULL) {\n\t\ts        = ax25_dev;\n\t\tnetdev_put(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\tax25_dev = ax25_dev->next;\n\t\tkfree(s);\n\t}\n\tax25_dev_list = NULL;\n\tspin_unlock_bh(&ax25_dev_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}