{
  "module_name": "af_ax25.c",
  "hash_id": "923e88b565434aaa39ee09fcb7bb81e34e377a3a938fa2565e2d5f076f9afba5",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/af_ax25.c",
  "human_readable_source": "\n \n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t \n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <net/net_namespace.h>\n#include <net/tcp_states.h>\n#include <net/ip.h>\n#include <net/arp.h>\n\n\n\nHLIST_HEAD(ax25_list);\nDEFINE_SPINLOCK(ax25_list_lock);\n\nstatic const struct proto_ops ax25_proto_ops;\n\nstatic void ax25_free_sock(struct sock *sk)\n{\n\tax25_cb_put(sk_to_ax25(sk));\n}\n\n \nstatic void ax25_cb_del(ax25_cb *ax25)\n{\n\tspin_lock_bh(&ax25_list_lock);\n\tif (!hlist_unhashed(&ax25->ax25_node)) {\n\t\thlist_del_init(&ax25->ax25_node);\n\t\tax25_cb_put(ax25);\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}\n\n \nstatic void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tax25_dev->device_up = false;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tif (!sk) {\n\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\t\ts->ax25_dev = NULL;\n\t\t\t\tax25_cb_del(s);\n\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tif (sk->sk_socket) {\n\t\t\t\tnetdev_put(ax25_dev->dev,\n\t\t\t\t\t   &ax25_dev->dev_tracker);\n\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t}\n\t\t\tax25_cb_del(s);\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\t \n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}\n\n \nstatic int ax25_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (dev->type != ARPHRD_AX25)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tax25_dev_device_up(dev);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tax25_kill_by_device(dev);\n\t\tax25_rt_device_down(dev);\n\t\tax25_dev_device_down(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nvoid ax25_cb_add(ax25_cb *ax25)\n{\n\tspin_lock_bh(&ax25_list_lock);\n\tax25_cb_hold(ax25);\n\thlist_add_head(&ax25->ax25_node, &ax25_list);\n\tspin_unlock_bh(&ax25_list_lock);\n}\n\n \nstruct sock *ax25_find_listener(ax25_address *addr, int digi,\n\tstruct net_device *dev, int type)\n{\n\tax25_cb *s;\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif ((s->iamdigi && !digi) || (!s->iamdigi && digi))\n\t\t\tcontinue;\n\t\tif (s->sk && !ax25cmp(&s->source_addr, addr) &&\n\t\t    s->sk->sk_type == type && s->sk->sk_state == TCP_LISTEN) {\n\t\t\t \n\t\t\tif (s->ax25_dev == NULL || s->ax25_dev->dev == dev) {\n\t\t\t\tsock_hold(s->sk);\n\t\t\t\tspin_unlock(&ax25_list_lock);\n\t\t\t\treturn s->sk;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&ax25_list_lock);\n\n\treturn NULL;\n}\n\n \nstruct sock *ax25_get_socket(ax25_address *my_addr, ax25_address *dest_addr,\n\tint type)\n{\n\tstruct sock *sk = NULL;\n\tax25_cb *s;\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk && !ax25cmp(&s->source_addr, my_addr) &&\n\t\t    !ax25cmp(&s->dest_addr, dest_addr) &&\n\t\t    s->sk->sk_type == type) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&ax25_list_lock);\n\n\treturn sk;\n}\n\n \nax25_cb *ax25_find_cb(const ax25_address *src_addr, ax25_address *dest_addr,\n\tax25_digi *digi, struct net_device *dev)\n{\n\tax25_cb *s;\n\n\tspin_lock_bh(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk && s->sk->sk_type != SOCK_SEQPACKET)\n\t\t\tcontinue;\n\t\tif (s->ax25_dev == NULL)\n\t\t\tcontinue;\n\t\tif (ax25cmp(&s->source_addr, src_addr) == 0 && ax25cmp(&s->dest_addr, dest_addr) == 0 && s->ax25_dev->dev == dev) {\n\t\t\tif (digi != NULL && digi->ndigi != 0) {\n\t\t\t\tif (s->digipeat == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ax25digicmp(s->digipeat, digi) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (s->digipeat != NULL && s->digipeat->ndigi != 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tax25_cb_hold(s);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\n\t\t\treturn s;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(ax25_find_cb);\n\nvoid ax25_send_to_raw(ax25_address *addr, struct sk_buff *skb, int proto)\n{\n\tax25_cb *s;\n\tstruct sk_buff *copy;\n\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk != NULL && ax25cmp(&s->source_addr, addr) == 0 &&\n\t\t    s->sk->sk_type == SOCK_RAW &&\n\t\t    s->sk->sk_protocol == proto &&\n\t\t    s->ax25_dev->dev == skb->dev &&\n\t\t    atomic_read(&s->sk->sk_rmem_alloc) <= s->sk->sk_rcvbuf) {\n\t\t\tif ((copy = skb_clone(skb, GFP_ATOMIC)) == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (sock_queue_rcv_skb(s->sk, copy) != 0)\n\t\t\t\tkfree_skb(copy);\n\t\t}\n\t}\n\tspin_unlock(&ax25_list_lock);\n}\n\n \nvoid ax25_destroy_socket(ax25_cb *);\n\n \nstatic void ax25_destroy_timer(struct timer_list *t)\n{\n\tax25_cb *ax25 = from_timer(ax25, t, dtimer);\n\tstruct sock *sk;\n\n\tsk=ax25->sk;\n\n\tbh_lock_sock(sk);\n\tsock_hold(sk);\n\tax25_destroy_socket(ax25);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n \nvoid ax25_destroy_socket(ax25_cb *ax25)\n{\n\tstruct sk_buff *skb;\n\n\tax25_cb_del(ax25);\n\n\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\n\tax25_clear_queues(ax25);\t \n\n\tif (ax25->sk != NULL) {\n\t\twhile ((skb = skb_dequeue(&ax25->sk->sk_receive_queue)) != NULL) {\n\t\t\tif (skb->sk != ax25->sk) {\n\t\t\t\t \n\t\t\t\tax25_cb *sax25 = sk_to_ax25(skb->sk);\n\n\t\t\t\t \n\t\t\t\tsock_orphan(skb->sk);\n\n\t\t\t\t \n\t\t\t\tskb->sk->sk_state = TCP_LISTEN;\n\n\t\t\t\tax25_start_heartbeat(sax25);\n\t\t\t\tsax25->state = AX25_STATE_0;\n\t\t\t}\n\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\tskb_queue_purge(&ax25->sk->sk_write_queue);\n\t}\n\n\tif (ax25->sk != NULL) {\n\t\tif (sk_has_allocations(ax25->sk)) {\n\t\t\t \n\t\t\ttimer_setup(&ax25->dtimer, ax25_destroy_timer, 0);\n\t\t\tax25->dtimer.expires  = jiffies + 2 * HZ;\n\t\t\tadd_timer(&ax25->dtimer);\n\t\t} else {\n\t\t\tstruct sock *sk=ax25->sk;\n\t\t\tax25->sk=NULL;\n\t\t\tsock_put(sk);\n\t\t}\n\t} else {\n\t\tax25_cb_put(ax25);\n\t}\n}\n\n \nstatic int ax25_ctl_ioctl(const unsigned int cmd, void __user *arg)\n{\n\tstruct ax25_ctl_struct ax25_ctl;\n\tax25_digi digi;\n\tax25_dev *ax25_dev;\n\tax25_cb *ax25;\n\tunsigned int k;\n\tint ret = 0;\n\n\tif (copy_from_user(&ax25_ctl, arg, sizeof(ax25_ctl)))\n\t\treturn -EFAULT;\n\n\tif (ax25_ctl.digi_count > AX25_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tif (ax25_ctl.arg > ULONG_MAX / HZ && ax25_ctl.cmd != AX25_KILL)\n\t\treturn -EINVAL;\n\n\tax25_dev = ax25_addr_ax25dev(&ax25_ctl.port_addr);\n\tif (!ax25_dev)\n\t\treturn -ENODEV;\n\n\tdigi.ndigi = ax25_ctl.digi_count;\n\tfor (k = 0; k < digi.ndigi; k++)\n\t\tdigi.calls[k] = ax25_ctl.digi_addr[k];\n\n\tax25 = ax25_find_cb(&ax25_ctl.source_addr, &ax25_ctl.dest_addr, &digi, ax25_dev->dev);\n\tif (!ax25) {\n\t\tax25_dev_put(ax25_dev);\n\t\treturn -ENOTCONN;\n\t}\n\n\tswitch (ax25_ctl.cmd) {\n\tcase AX25_KILL:\n\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\tif (ax25_dev->dama.slave && ax25->ax25_dev->values[AX25_VALUES_PROTOCOL] == AX25_PROTO_DAMA_SLAVE)\n\t\t\tax25_dama_off(ax25);\n#endif\n\t\tax25_disconnect(ax25, ENETRESET);\n\t\tbreak;\n\n\tcase AX25_WINDOW:\n\t\tif (ax25->modulus == AX25_MODULUS) {\n\t\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > 7)\n\t\t\t\tgoto einval_put;\n\t\t} else {\n\t\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > 63)\n\t\t\t\tgoto einval_put;\n\t\t}\n\t\tax25->window = ax25_ctl.arg;\n\t\tbreak;\n\n\tcase AX25_T1:\n\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > ULONG_MAX / HZ)\n\t\t\tgoto einval_put;\n\t\tax25->rtt = (ax25_ctl.arg * HZ) / 2;\n\t\tax25->t1  = ax25_ctl.arg * HZ;\n\t\tbreak;\n\n\tcase AX25_T2:\n\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > ULONG_MAX / HZ)\n\t\t\tgoto einval_put;\n\t\tax25->t2 = ax25_ctl.arg * HZ;\n\t\tbreak;\n\n\tcase AX25_N2:\n\t\tif (ax25_ctl.arg < 1 || ax25_ctl.arg > 31)\n\t\t\tgoto einval_put;\n\t\tax25->n2count = 0;\n\t\tax25->n2 = ax25_ctl.arg;\n\t\tbreak;\n\n\tcase AX25_T3:\n\t\tif (ax25_ctl.arg > ULONG_MAX / HZ)\n\t\t\tgoto einval_put;\n\t\tax25->t3 = ax25_ctl.arg * HZ;\n\t\tbreak;\n\n\tcase AX25_IDLE:\n\t\tif (ax25_ctl.arg > ULONG_MAX / (60 * HZ))\n\t\t\tgoto einval_put;\n\n\t\tax25->idle = ax25_ctl.arg * 60 * HZ;\n\t\tbreak;\n\n\tcase AX25_PACLEN:\n\t\tif (ax25_ctl.arg < 16 || ax25_ctl.arg > 65535)\n\t\t\tgoto einval_put;\n\t\tax25->paclen = ax25_ctl.arg;\n\t\tbreak;\n\n\tdefault:\n\t\tgoto einval_put;\n\t  }\n\nout_put:\n\tax25_dev_put(ax25_dev);\n\tax25_cb_put(ax25);\n\treturn ret;\n\neinval_put:\n\tret = -EINVAL;\n\tgoto out_put;\n}\n\nstatic void ax25_fillin_cb_from_dev(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->rtt     = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T1]) / 2;\n\tax25->t1      = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T1]);\n\tax25->t2      = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T2]);\n\tax25->t3      = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T3]);\n\tax25->n2      = ax25_dev->values[AX25_VALUES_N2];\n\tax25->paclen  = ax25_dev->values[AX25_VALUES_PACLEN];\n\tax25->idle    = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_IDLE]);\n\tax25->backoff = ax25_dev->values[AX25_VALUES_BACKOFF];\n\n\tif (ax25_dev->values[AX25_VALUES_AXDEFMODE]) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = ax25_dev->values[AX25_VALUES_EWINDOW];\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = ax25_dev->values[AX25_VALUES_WINDOW];\n\t}\n}\n\n \nvoid ax25_fillin_cb(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->ax25_dev = ax25_dev;\n\n\tif (ax25->ax25_dev != NULL) {\n\t\tax25_fillin_cb_from_dev(ax25, ax25_dev);\n\t\treturn;\n\t}\n\n\t \n\tax25->rtt     = msecs_to_jiffies(AX25_DEF_T1) / 2;\n\tax25->t1      = msecs_to_jiffies(AX25_DEF_T1);\n\tax25->t2      = msecs_to_jiffies(AX25_DEF_T2);\n\tax25->t3      = msecs_to_jiffies(AX25_DEF_T3);\n\tax25->n2      = AX25_DEF_N2;\n\tax25->paclen  = AX25_DEF_PACLEN;\n\tax25->idle    = msecs_to_jiffies(AX25_DEF_IDLE);\n\tax25->backoff = AX25_DEF_BACKOFF;\n\n\tif (AX25_DEF_AXDEFMODE) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = AX25_DEF_EWINDOW;\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = AX25_DEF_WINDOW;\n\t}\n}\n\n \nax25_cb *ax25_create_cb(void)\n{\n\tax25_cb *ax25;\n\n\tif ((ax25 = kzalloc(sizeof(*ax25), GFP_ATOMIC)) == NULL)\n\t\treturn NULL;\n\n\trefcount_set(&ax25->refcount, 1);\n\n\tskb_queue_head_init(&ax25->write_queue);\n\tskb_queue_head_init(&ax25->frag_queue);\n\tskb_queue_head_init(&ax25->ack_queue);\n\tskb_queue_head_init(&ax25->reseq_queue);\n\n\tax25_setup_timers(ax25);\n\n\tax25_fillin_cb(ax25, NULL);\n\n\tax25->state = AX25_STATE_0;\n\n\treturn ax25;\n}\n\n \n\nstatic int ax25_setsockopt(struct socket *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tstruct net_device *dev;\n\tchar devname[IFNAMSIZ];\n\tunsigned int opt;\n\tint res = 0;\n\n\tif (level != SOL_AX25)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optlen < sizeof(unsigned int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&opt, optval, sizeof(unsigned int)))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tswitch (optname) {\n\tcase AX25_WINDOW:\n\t\tif (ax25->modulus == AX25_MODULUS) {\n\t\t\tif (opt < 1 || opt > 7) {\n\t\t\t\tres = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (opt < 1 || opt > 63) {\n\t\t\t\tres = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tax25->window = opt;\n\t\tbreak;\n\n\tcase AX25_T1:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->rtt = (opt * HZ) >> 1;\n\t\tax25->t1  = opt * HZ;\n\t\tbreak;\n\n\tcase AX25_T2:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->t2 = opt * HZ;\n\t\tbreak;\n\n\tcase AX25_N2:\n\t\tif (opt < 1 || opt > 31) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->n2 = opt;\n\t\tbreak;\n\n\tcase AX25_T3:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->t3 = opt * HZ;\n\t\tbreak;\n\n\tcase AX25_IDLE:\n\t\tif (opt > UINT_MAX / (60 * HZ)) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->idle = opt * 60 * HZ;\n\t\tbreak;\n\n\tcase AX25_BACKOFF:\n\t\tif (opt > 2) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->backoff = opt;\n\t\tbreak;\n\n\tcase AX25_EXTSEQ:\n\t\tax25->modulus = opt ? AX25_EMODULUS : AX25_MODULUS;\n\t\tbreak;\n\n\tcase AX25_PIDINCL:\n\t\tax25->pidincl = opt ? 1 : 0;\n\t\tbreak;\n\n\tcase AX25_IAMDIGI:\n\t\tax25->iamdigi = opt ? 1 : 0;\n\t\tbreak;\n\n\tcase AX25_PACLEN:\n\t\tif (opt < 16 || opt > 65535) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25->paclen = opt;\n\t\tbreak;\n\n\tcase SO_BINDTODEVICE:\n\t\tif (optlen > IFNAMSIZ - 1)\n\t\t\toptlen = IFNAMSIZ - 1;\n\n\t\tmemset(devname, 0, sizeof(devname));\n\n\t\tif (copy_from_sockptr(devname, optval, optlen)) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_type == SOCK_SEQPACKET &&\n\t\t   (sock->state != SS_UNCONNECTED ||\n\t\t    sk->sk_state == TCP_LISTEN)) {\n\t\t\tres = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\trtnl_lock();\n\t\tdev = __dev_get_by_name(&init_net, devname);\n\t\tif (!dev) {\n\t\t\trtnl_unlock();\n\t\t\tres = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tax25->ax25_dev = ax25_dev_ax25dev(dev);\n\t\tif (!ax25->ax25_dev) {\n\t\t\trtnl_unlock();\n\t\t\tres = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tax25_fillin_cb(ax25, ax25->ax25_dev);\n\t\trtnl_unlock();\n\t\tbreak;\n\n\tdefault:\n\t\tres = -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\treturn res;\n}\n\nstatic int ax25_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tstruct ax25_dev *ax25_dev;\n\tchar devname[IFNAMSIZ];\n\tvoid *valptr;\n\tint val = 0;\n\tint maxlen, length;\n\n\tif (level != SOL_AX25)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(maxlen, optlen))\n\t\treturn -EFAULT;\n\n\tif (maxlen < 1)\n\t\treturn -EFAULT;\n\n\tvalptr = &val;\n\tlength = min_t(unsigned int, maxlen, sizeof(int));\n\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tswitch (optname) {\n\tcase AX25_WINDOW:\n\t\tval = ax25->window;\n\t\tbreak;\n\n\tcase AX25_T1:\n\t\tval = ax25->t1 / HZ;\n\t\tbreak;\n\n\tcase AX25_T2:\n\t\tval = ax25->t2 / HZ;\n\t\tbreak;\n\n\tcase AX25_N2:\n\t\tval = ax25->n2;\n\t\tbreak;\n\n\tcase AX25_T3:\n\t\tval = ax25->t3 / HZ;\n\t\tbreak;\n\n\tcase AX25_IDLE:\n\t\tval = ax25->idle / (60 * HZ);\n\t\tbreak;\n\n\tcase AX25_BACKOFF:\n\t\tval = ax25->backoff;\n\t\tbreak;\n\n\tcase AX25_EXTSEQ:\n\t\tval = (ax25->modulus == AX25_EMODULUS);\n\t\tbreak;\n\n\tcase AX25_PIDINCL:\n\t\tval = ax25->pidincl;\n\t\tbreak;\n\n\tcase AX25_IAMDIGI:\n\t\tval = ax25->iamdigi;\n\t\tbreak;\n\n\tcase AX25_PACLEN:\n\t\tval = ax25->paclen;\n\t\tbreak;\n\n\tcase SO_BINDTODEVICE:\n\t\tax25_dev = ax25->ax25_dev;\n\n\t\tif (ax25_dev != NULL && ax25_dev->dev != NULL) {\n\t\t\tstrscpy(devname, ax25_dev->dev->name, sizeof(devname));\n\t\t\tlength = strlen(devname) + 1;\n\t\t} else {\n\t\t\t*devname = '\\0';\n\t\t\tlength = 1;\n\t\t}\n\n\t\tvalptr = devname;\n\t\tbreak;\n\n\tdefault:\n\t\trelease_sock(sk);\n\t\treturn -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\tif (put_user(length, optlen))\n\t\treturn -EFAULT;\n\n\treturn copy_to_user(optval, valptr, length) ? -EFAULT : 0;\n}\n\nstatic int ax25_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint res = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_LISTEN) {\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\tgoto out;\n\t}\n\tres = -EOPNOTSUPP;\n\nout:\n\trelease_sock(sk);\n\n\treturn res;\n}\n\n \nstatic struct proto ax25_proto = {\n\t.name\t  = \"AX25\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct ax25_sock),\n};\n\nstatic int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > U8_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t \n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}\n\nstruct sock *ax25_make_new(struct sock *osk, struct ax25_dev *ax25_dev)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25, *oax25;\n\n\tsk = sk_alloc(sock_net(osk), PF_AX25, GFP_ATOMIC, osk->sk_prot, 0);\n\tif (sk == NULL)\n\t\treturn NULL;\n\n\tif ((ax25 = ax25_create_cb()) == NULL) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\tswitch (osk->sk_type) {\n\tcase SOCK_DGRAM:\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tbreak;\n\tdefault:\n\t\tsk_free(sk);\n\t\tax25_cb_put(ax25);\n\t\treturn NULL;\n\t}\n\n\tsock_init_data(NULL, sk);\n\n\tsk->sk_type     = osk->sk_type;\n\tsk->sk_priority = osk->sk_priority;\n\tsk->sk_protocol = osk->sk_protocol;\n\tsk->sk_rcvbuf   = osk->sk_rcvbuf;\n\tsk->sk_sndbuf   = osk->sk_sndbuf;\n\tsk->sk_state    = TCP_ESTABLISHED;\n\tsock_copy_flags(sk, osk);\n\n\toax25 = sk_to_ax25(osk);\n\n\tax25->modulus = oax25->modulus;\n\tax25->backoff = oax25->backoff;\n\tax25->pidincl = oax25->pidincl;\n\tax25->iamdigi = oax25->iamdigi;\n\tax25->rtt     = oax25->rtt;\n\tax25->t1      = oax25->t1;\n\tax25->t2      = oax25->t2;\n\tax25->t3      = oax25->t3;\n\tax25->n2      = oax25->n2;\n\tax25->idle    = oax25->idle;\n\tax25->paclen  = oax25->paclen;\n\tax25->window  = oax25->window;\n\n\tax25->ax25_dev    = ax25_dev;\n\tax25->source_addr = oax25->source_addr;\n\n\tif (oax25->digipeat != NULL) {\n\t\tax25->digipeat = kmemdup(oax25->digipeat, sizeof(ax25_digi),\n\t\t\t\t\t GFP_ATOMIC);\n\t\tif (ax25->digipeat == NULL) {\n\t\t\tsk_free(sk);\n\t\t\tax25_cb_put(ax25);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tax25_sk(sk)->cb = ax25;\n\tsk->sk_destruct = ax25_free_sock;\n\tax25->sk    = sk;\n\n\treturn sk;\n}\n\nstatic int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tax25_dev *ax25_dev;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tsock_orphan(sk);\n\tax25 = sk_to_ax25(sk);\n\tax25_dev = ax25->ax25_dev;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tax25_disconnect(ax25, 0);\n\t\t\t\tlock_sock(sk);\n\t\t\t}\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\tif (ax25_dev) {\n\t\tif (!ax25_dev->device_up) {\n\t\t\tdel_timer_sync(&ax25->timer);\n\t\t\tdel_timer_sync(&ax25->t1timer);\n\t\t\tdel_timer_sync(&ax25->t2timer);\n\t\t\tdel_timer_sync(&ax25->t3timer);\n\t\t\tdel_timer_sync(&ax25->idletimer);\n\t\t}\n\t\tnetdev_put(ax25_dev->dev, &ax25->dev_tracker);\n\t\tax25_dev_put(ax25_dev);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\n \nstatic int ax25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct full_sockaddr_ax25 *addr = (struct full_sockaddr_ax25 *)uaddr;\n\tax25_dev *ax25_dev = NULL;\n\tax25_uid_assoc *user;\n\tax25_address call;\n\tax25_cb *ax25;\n\tint err = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_ax25) &&\n\t    addr_len != sizeof(struct full_sockaddr_ax25))\n\t\t \n\t\tif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\n\t\t    (addr_len > sizeof(struct full_sockaddr_ax25)))\n\t\t\treturn -EINVAL;\n\n\tif (addr->fsa_ax25.sax25_family != AF_AX25)\n\t\treturn -EINVAL;\n\n\tuser = ax25_findbyuid(current_euid());\n\tif (user) {\n\t\tcall = user->call;\n\t\tax25_uid_put(user);\n\t} else {\n\t\tif (ax25_uid_policy && !capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tcall = addr->fsa_ax25.sax25_call;\n\t}\n\n\tlock_sock(sk);\n\n\tax25 = sk_to_ax25(sk);\n\tif (!sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tax25->source_addr = call;\n\n\t \n\tif (ax25->ax25_dev != NULL)\n\t\tgoto done;\n\n\tif (addr_len > sizeof(struct sockaddr_ax25) && addr->fsa_ax25.sax25_ndigis == 1) {\n\t\tif (ax25cmp(&addr->fsa_digipeater[0], &null_ax25_address) != 0 &&\n\t\t    (ax25_dev = ax25_addr_ax25dev(&addr->fsa_digipeater[0])) == NULL) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((ax25_dev = ax25_addr_ax25dev(&addr->fsa_ax25.sax25_call)) == NULL) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ax25_dev) {\n\t\tax25_fillin_cb(ax25, ax25_dev);\n\t\tnetdev_hold(ax25_dev->dev, &ax25->dev_tracker, GFP_ATOMIC);\n\t}\n\ndone:\n\tax25_cb_add(ax25);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\n \nstatic int __must_check ax25_connect(struct socket *sock,\n\tstruct sockaddr *uaddr, int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25 = sk_to_ax25(sk), *ax25t;\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tax25_digi *digi = NULL;\n\tint ct = 0, err = 0;\n\n\t \n\n\tif (addr_len == sizeof(struct sockaddr_ax25))\n\t\t \n\t\t;\n\telse if (addr_len != sizeof(struct full_sockaddr_ax25))\n\t\t \n\t\tif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\n\t\t    (addr_len > sizeof(struct full_sockaddr_ax25)))\n\t\t\treturn -EINVAL;\n\n\n\tif (fsa->fsa_ax25.sax25_family != AF_AX25)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\t \n\tif (sock->state == SS_CONNECTING) {\n\t\tswitch (sk->sk_state) {\n\t\tcase TCP_SYN_SENT:  \n\t\t\terr = -EINPROGRESS;\n\t\t\tgoto out_release;\n\n\t\tcase TCP_ESTABLISHED:  \n\t\t\tsock->state = SS_CONNECTED;\n\t\t\tgoto out_release;\n\n\t\tcase TCP_CLOSE:  \n\t\t\tsock->state = SS_UNCONNECTED;\n\t\t\terr = -ECONNREFUSED;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED && sk->sk_type == SOCK_SEQPACKET) {\n\t\terr = -EISCONN;\t \n\t\tgoto out_release;\n\t}\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\tkfree(ax25->digipeat);\n\tax25->digipeat = NULL;\n\n\t \n\tif (addr_len > sizeof(struct sockaddr_ax25) &&\n\t    fsa->fsa_ax25.sax25_ndigis != 0) {\n\t\t \n\t\tif (fsa->fsa_ax25.sax25_ndigis < 1 ||\n\t\t    fsa->fsa_ax25.sax25_ndigis > AX25_MAX_DIGIS ||\n\t\t    addr_len < sizeof(struct sockaddr_ax25) +\n\t\t    sizeof(ax25_address) * fsa->fsa_ax25.sax25_ndigis) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tif ((digi = kmalloc(sizeof(ax25_digi), GFP_KERNEL)) == NULL) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tdigi->ndigi      = fsa->fsa_ax25.sax25_ndigis;\n\t\tdigi->lastrepeat = -1;\n\n\t\twhile (ct < fsa->fsa_ax25.sax25_ndigis) {\n\t\t\tif ((fsa->fsa_digipeater[ct].ax25_call[6] &\n\t\t\t     AX25_HBIT) && ax25->iamdigi) {\n\t\t\t\tdigi->repeated[ct] = 1;\n\t\t\t\tdigi->lastrepeat   = ct;\n\t\t\t} else {\n\t\t\t\tdigi->repeated[ct] = 0;\n\t\t\t}\n\t\t\tdigi->calls[ct] = fsa->fsa_digipeater[ct];\n\t\t\tct++;\n\t\t}\n\t}\n\n\t \n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\t \n\t\tprintk(KERN_WARNING \"ax25_connect(): %s uses autobind, please contact jreuter@yaina.de\\n\",\n\t\t\tcurrent->comm);\n\t\tif ((err = ax25_rt_autobind(ax25, &fsa->fsa_ax25.sax25_call)) < 0) {\n\t\t\tkfree(digi);\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tax25_fillin_cb(ax25, ax25->ax25_dev);\n\t\tax25_cb_add(ax25);\n\t} else {\n\t\tif (ax25->ax25_dev == NULL) {\n\t\t\tkfree(digi);\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tif (sk->sk_type == SOCK_SEQPACKET &&\n\t    (ax25t=ax25_find_cb(&ax25->source_addr, &fsa->fsa_ax25.sax25_call, digi,\n\t\t\t ax25->ax25_dev->dev))) {\n\t\tkfree(digi);\n\t\terr = -EADDRINUSE;\t\t \n\t\tax25_cb_put(ax25t);\n\t\tgoto out_release;\n\t}\n\n\tax25->dest_addr = fsa->fsa_ax25.sax25_call;\n\tax25->digipeat  = digi;\n\n\t \n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\tsock->state = SS_CONNECTED;\n\t\tsk->sk_state   = TCP_ESTABLISHED;\n\t\tgoto out_release;\n\t}\n\n\t \n\tsock->state        = SS_CONNECTING;\n\tsk->sk_state          = TCP_SYN_SENT;\n\n\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\tcase AX25_PROTO_STD_SIMPLEX:\n\tcase AX25_PROTO_STD_DUPLEX:\n\t\tax25_std_establish_data_link(ax25);\n\t\tbreak;\n\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\tcase AX25_PROTO_DAMA_SLAVE:\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\n\t\tif (ax25->ax25_dev->dama.slave)\n\t\t\tax25_ds_establish_data_link(ax25);\n\t\telse\n\t\t\tax25_std_establish_data_link(ax25);\n\t\tbreak;\n#endif\n\t}\n\n\tax25->state = AX25_STATE_1;\n\n\tax25_start_heartbeat(ax25);\n\n\t \n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\t\tbreak;\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tschedule();\n\t\t\t\tlock_sock(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t \n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = sock_error(sk);\t \n\t\tgoto out_release;\n\t}\n\n\tsock->state = SS_CONNECTED;\n\n\terr = 0;\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t       bool kern)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *newsk;\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk;\n\tint err = 0;\n\n\tif (sock->state != SS_UNCONNECTED)\n\t\treturn -EINVAL;\n\n\tif ((sk = sock->sk) == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tbreak;\n\n\t\tif (flags & O_NONBLOCK) {\n\t\t\terr = -EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto out;\n\n\tnewsk\t\t = skb->sk;\n\tsock_graft(newsk, newsock);\n\n\t \n\tkfree_skb(skb);\n\tsk_acceptq_removed(sk);\n\tnewsock->state = SS_CONNECTED;\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\terr = sizeof (struct full_sockaddr_ax25);\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_ax25 *, usax, msg->msg_name);\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 sax;\n\tstruct sk_buff *skb;\n\tax25_digi dtmp, *dp;\n\tax25_cb *ax25;\n\tsize_t size;\n\tint lv, err, addr_len = msg->msg_namelen;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\terr = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (ax25->ax25_dev == NULL) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out;\n\t}\n\n\tif (len > ax25->ax25_dev->dev->mtu) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tif (usax != NULL) {\n\t\tif (usax->sax25_family != AF_AX25) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (addr_len == sizeof(struct sockaddr_ax25))\n\t\t\t \n\t\t\t;\n\t\telse if (addr_len != sizeof(struct full_sockaddr_ax25))\n\t\t\t \n\t\t\tif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\n\t\t\t    (addr_len > sizeof(struct full_sockaddr_ax25))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\tif (addr_len > sizeof(struct sockaddr_ax25) && usax->sax25_ndigis != 0) {\n\t\t\tint ct           = 0;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)usax;\n\n\t\t\t \n\t\t\tif (usax->sax25_ndigis < 1 ||\n\t\t\t    usax->sax25_ndigis > AX25_MAX_DIGIS ||\n\t\t\t    addr_len < sizeof(struct sockaddr_ax25) +\n\t\t\t    sizeof(ax25_address) * usax->sax25_ndigis) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdtmp.ndigi      = usax->sax25_ndigis;\n\n\t\t\twhile (ct < usax->sax25_ndigis) {\n\t\t\t\tdtmp.repeated[ct] = 0;\n\t\t\t\tdtmp.calls[ct]    = fsa->fsa_digipeater[ct];\n\t\t\t\tct++;\n\t\t\t}\n\n\t\t\tdtmp.lastrepeat = 0;\n\t\t}\n\n\t\tsax = *usax;\n\t\tif (sk->sk_type == SOCK_SEQPACKET &&\n\t\t    ax25cmp(&ax25->dest_addr, &sax.sax25_call)) {\n\t\t\terr = -EISCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (usax->sax25_ndigis == 0)\n\t\t\tdp = NULL;\n\t\telse\n\t\t\tdp = &dtmp;\n\t} else {\n\t\t \n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tsax.sax25_family = AF_AX25;\n\t\tsax.sax25_call   = ax25->dest_addr;\n\t\tdp = ax25->digipeat;\n\t}\n\n\t \n\t \n\tsize = len + ax25->ax25_dev->dev->hard_header_len;\n\n\tskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tskb_reserve(skb, size - len);\n\n\t \n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\terr = -EFAULT;\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tskb_reset_network_header(skb);\n\n\t \n\tif (!ax25->pidincl)\n\t\t*(u8 *)skb_push(skb, 1) = sk->sk_protocol;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\t \n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\tkfree_skb(skb);\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tax25_output(ax25, ax25->paclen, skb);\n\n\t\terr = len;\n\t\tgoto out;\n\t}\n\n\tskb_push(skb, 1 + ax25_addr_size(dp));\n\n\t \n\n\t \n\tlv = ax25_addr_build(skb->data, &ax25->source_addr, &sax.sax25_call,\n\t\t\t     dp, AX25_COMMAND, AX25_MODULUS);\n\n\tskb_set_transport_header(skb, lv);\n\n\t*skb_transport_header(skb) = AX25_UI;\n\n\t \n\tax25_queue_xmit(skb, ax25->ax25_dev->dev);\n\n\terr = len;\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int ax25_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t\tint flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb, *last;\n\tstruct sk_buff_head *sk_queue;\n\tint copied;\n\tint err = 0;\n\tint off = 0;\n\tlong timeo;\n\n\tlock_sock(sk);\n\t \n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\t \n\tsk_queue = &sk->sk_receive_queue;\n\tskb = __skb_try_recv_datagram(sk, sk_queue, flags, &off, &err, &last);\n\t \n\tif (!skb) {\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t\trelease_sock(sk);\n\t\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\t\twhile (timeo && !__skb_wait_for_more_packets(sk, sk_queue, &err,\n\t\t\t\t\t\t\t     &timeo, last)) {\n\t\t\tskb = __skb_try_recv_datagram(sk, sk_queue, flags, &off,\n\t\t\t\t\t\t      &err, &last);\n\t\t\tif (skb)\n\t\t\t\tbreak;\n\n\t\t\tif (err != -EAGAIN)\n\t\t\t\tgoto done;\n\t\t}\n\t\tif (!skb)\n\t\t\tgoto done;\n\t\tlock_sock(sk);\n\t}\n\n\tif (!sk_to_ax25(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t \n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tif (msg->msg_name) {\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tDECLARE_SOCKADDR(struct sockaddr_ax25 *, sax, msg->msg_name);\n\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\t \n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\terr = copied;\n\nout:\n\trelease_sock(sk);\n\ndone:\n\treturn err;\n}\n\nstatic int ax25_shutdown(struct socket *sk, int how)\n{\n\t \n\treturn -EOPNOTSUPP;\n}\n\nstatic int ax25_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tint res = 0;\n\n\tlock_sock(sk);\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount;\n\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\tres = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0L;\n\t\t \n\t\tif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\n\t\t\tamount = skb->len;\n\t\tres = put_user(amount, (int __user *) argp);\n\t\tbreak;\n\t}\n\n\tcase SIOCAX25ADDUID:\t \n\tcase SIOCAX25DELUID:\t \n\tcase SIOCAX25GETUID: {\n\t\tstruct sockaddr_ax25 sax25;\n\t\tif (copy_from_user(&sax25, argp, sizeof(sax25))) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_uid_ioctl(cmd, &sax25);\n\t\tbreak;\n\t}\n\n\tcase SIOCAX25NOUID: {\t \n\t\tlong amount;\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (get_user(amount, (long __user *)argp)) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (amount < 0 || amount > AX25_NOUID_BLOCK) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tax25_uid_policy = amount;\n\t\tres = 0;\n\t\tbreak;\n\t}\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\tcase SIOCAX25OPTRT:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_rt_ioctl(cmd, argp);\n\t\tbreak;\n\n\tcase SIOCAX25CTLCON:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_ctl_ioctl(cmd, argp);\n\t\tbreak;\n\n\tcase SIOCAX25GETINFO:\n\tcase SIOCAX25GETINFOOLD: {\n\t\tax25_cb *ax25 = sk_to_ax25(sk);\n\t\tstruct ax25_info_struct ax25_info;\n\n\t\tax25_info.t1        = ax25->t1   / HZ;\n\t\tax25_info.t2        = ax25->t2   / HZ;\n\t\tax25_info.t3        = ax25->t3   / HZ;\n\t\tax25_info.idle      = ax25->idle / (60 * HZ);\n\t\tax25_info.n2        = ax25->n2;\n\t\tax25_info.t1timer   = ax25_display_timer(&ax25->t1timer)   / HZ;\n\t\tax25_info.t2timer   = ax25_display_timer(&ax25->t2timer)   / HZ;\n\t\tax25_info.t3timer   = ax25_display_timer(&ax25->t3timer)   / HZ;\n\t\tax25_info.idletimer = ax25_display_timer(&ax25->idletimer) / (60 * HZ);\n\t\tax25_info.n2count   = ax25->n2count;\n\t\tax25_info.state     = ax25->state;\n\t\tax25_info.rcv_q     = sk_rmem_alloc_get(sk);\n\t\tax25_info.snd_q     = sk_wmem_alloc_get(sk);\n\t\tax25_info.vs        = ax25->vs;\n\t\tax25_info.vr        = ax25->vr;\n\t\tax25_info.va        = ax25->va;\n\t\tax25_info.vs_max    = ax25->vs;  \n\t\tax25_info.paclen    = ax25->paclen;\n\t\tax25_info.window    = ax25->window;\n\n\t\t \n\t\tif (cmd == SIOCAX25GETINFOOLD) {\n\t\t\tstatic int warned = 0;\n\t\t\tif (!warned) {\n\t\t\t\tprintk(KERN_INFO \"%s uses old SIOCAX25GETINFO\\n\",\n\t\t\t\t\tcurrent->comm);\n\t\t\t\twarned=1;\n\t\t\t}\n\n\t\t\tif (copy_to_user(argp, &ax25_info, sizeof(struct ax25_info_struct_deprecated))) {\n\t\t\t\tres = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (copy_to_user(argp, &ax25_info, sizeof(struct ax25_info_struct))) {\n\t\t\t\tres = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = 0;\n\t\tbreak;\n\t}\n\n\tcase SIOCAX25ADDFWD:\n\tcase SIOCAX25DELFWD: {\n\t\tstruct ax25_fwd_struct ax25_fwd;\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ax25_fwd, argp, sizeof(ax25_fwd))) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tres = ax25_fwd_ioctl(cmd, &ax25_fwd);\n\t\tbreak;\n\t}\n\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\tres = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\tres = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\treturn res;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *ax25_info_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(ax25_list_lock)\n{\n\tspin_lock_bh(&ax25_list_lock);\n\treturn seq_hlist_start(&ax25_list, *pos);\n}\n\nstatic void *ax25_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &ax25_list, pos);\n}\n\nstatic void ax25_info_stop(struct seq_file *seq, void *v)\n\t__releases(ax25_list_lock)\n{\n\tspin_unlock_bh(&ax25_list_lock);\n}\n\nstatic int ax25_info_show(struct seq_file *seq, void *v)\n{\n\tax25_cb *ax25 = hlist_entry(v, struct ax25_cb, ax25_node);\n\tchar buf[11];\n\tint k;\n\n\n\t \n\n\tseq_printf(seq, \"%p %s %s%s \",\n\t\t   ax25,\n\t\t   ax25->ax25_dev == NULL? \"???\" : ax25->ax25_dev->dev->name,\n\t\t   ax2asc(buf, &ax25->source_addr),\n\t\t   ax25->iamdigi? \"*\":\"\");\n\tseq_printf(seq, \"%s\", ax2asc(buf, &ax25->dest_addr));\n\n\tfor (k=0; (ax25->digipeat != NULL) && (k < ax25->digipeat->ndigi); k++) {\n\t\tseq_printf(seq, \",%s%s\",\n\t\t\t   ax2asc(buf, &ax25->digipeat->calls[k]),\n\t\t\t   ax25->digipeat->repeated[k]? \"*\":\"\");\n\t}\n\n\tseq_printf(seq, \" %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %lu %d %d %lu %d %d\",\n\t\t   ax25->state,\n\t\t   ax25->vs, ax25->vr, ax25->va,\n\t\t   ax25_display_timer(&ax25->t1timer) / HZ, ax25->t1 / HZ,\n\t\t   ax25_display_timer(&ax25->t2timer) / HZ, ax25->t2 / HZ,\n\t\t   ax25_display_timer(&ax25->t3timer) / HZ, ax25->t3 / HZ,\n\t\t   ax25_display_timer(&ax25->idletimer) / (60 * HZ),\n\t\t   ax25->idle / (60 * HZ),\n\t\t   ax25->n2count, ax25->n2,\n\t\t   ax25->rtt / HZ,\n\t\t   ax25->window,\n\t\t   ax25->paclen);\n\n\tif (ax25->sk != NULL) {\n\t\tseq_printf(seq, \" %d %d %lu\\n\",\n\t\t\t   sk_wmem_alloc_get(ax25->sk),\n\t\t\t   sk_rmem_alloc_get(ax25->sk),\n\t\t\t   sock_i_ino(ax25->sk));\n\t} else {\n\t\tseq_puts(seq, \" * * *\\n\");\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ax25_info_seqops = {\n\t.start = ax25_info_start,\n\t.next = ax25_info_next,\n\t.stop = ax25_info_stop,\n\t.show = ax25_info_show,\n};\n#endif\n\nstatic const struct net_proto_family ax25_family_ops = {\n\t.family =\tPF_AX25,\n\t.create =\tax25_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\nstatic const struct proto_ops ax25_proto_ops = {\n\t.family\t\t= PF_AX25,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= ax25_release,\n\t.bind\t\t= ax25_bind,\n\t.connect\t= ax25_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= ax25_accept,\n\t.getname\t= ax25_getname,\n\t.poll\t\t= datagram_poll,\n\t.ioctl\t\t= ax25_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.listen\t\t= ax25_listen,\n\t.shutdown\t= ax25_shutdown,\n\t.setsockopt\t= ax25_setsockopt,\n\t.getsockopt\t= ax25_getsockopt,\n\t.sendmsg\t= ax25_sendmsg,\n\t.recvmsg\t= ax25_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n};\n\n \nstatic struct packet_type ax25_packet_type __read_mostly = {\n\t.type\t=\tcpu_to_be16(ETH_P_AX25),\n\t.func\t=\tax25_kiss_rcv,\n};\n\nstatic struct notifier_block ax25_dev_notifier = {\n\t.notifier_call = ax25_device_event,\n};\n\nstatic int __init ax25_init(void)\n{\n\tint rc = proto_register(&ax25_proto, 0);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tsock_register(&ax25_family_ops);\n\tdev_add_pack(&ax25_packet_type);\n\tregister_netdevice_notifier(&ax25_dev_notifier);\n\n\tproc_create_seq(\"ax25_route\", 0444, init_net.proc_net, &ax25_rt_seqops);\n\tproc_create_seq(\"ax25\", 0444, init_net.proc_net, &ax25_info_seqops);\n\tproc_create_seq(\"ax25_calls\", 0444, init_net.proc_net,\n\t\t\t&ax25_uid_seqops);\nout:\n\treturn rc;\n}\nmodule_init(ax25_init);\n\n\nMODULE_AUTHOR(\"Jonathan Naylor G4KLX <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The amateur radio AX.25 link layer protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_AX25);\n\nstatic void __exit ax25_exit(void)\n{\n\tremove_proc_entry(\"ax25_route\", init_net.proc_net);\n\tremove_proc_entry(\"ax25\", init_net.proc_net);\n\tremove_proc_entry(\"ax25_calls\", init_net.proc_net);\n\n\tunregister_netdevice_notifier(&ax25_dev_notifier);\n\n\tdev_remove_pack(&ax25_packet_type);\n\n\tsock_unregister(PF_AX25);\n\tproto_unregister(&ax25_proto);\n\n\tax25_rt_free();\n\tax25_uid_free();\n\tax25_dev_free();\n}\nmodule_exit(ax25_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}