{
  "module_name": "ax25_out.c",
  "hash_id": "25bb16dde74b40d51bd459d3e048969748c1c43df9f887e84233832bf6349e6c",
  "original_prompt": "Ingested from linux-6.6.14/net/ax25/ax25_out.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/spinlock.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(ax25_frag_lock);\n\nax25_cb *ax25_send_frame(struct sk_buff *skb, int paclen, const ax25_address *src, ax25_address *dest, ax25_digi *digi, struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *ax25;\n\n\t \n\tif (paclen == 0) {\n\t\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\t\treturn NULL;\n\n\t\tpaclen = ax25_dev->values[AX25_VALUES_PACLEN];\n\t}\n\n\t \n\tif ((ax25 = ax25_find_cb(src, dest, digi, dev)) != NULL) {\n\t\tax25_output(ax25, paclen, skb);\n\t\treturn ax25;\t\t \n\t}\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn NULL;\n\n\tif ((ax25 = ax25_create_cb()) == NULL)\n\t\treturn NULL;\n\n\tax25_fillin_cb(ax25, ax25_dev);\n\n\tax25->source_addr = *src;\n\tax25->dest_addr   = *dest;\n\n\tif (digi != NULL) {\n\t\tax25->digipeat = kmemdup(digi, sizeof(*digi), GFP_ATOMIC);\n\t\tif (ax25->digipeat == NULL) {\n\t\t\tax25_cb_put(ax25);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\tcase AX25_PROTO_STD_SIMPLEX:\n\tcase AX25_PROTO_STD_DUPLEX:\n\t\tax25_std_establish_data_link(ax25);\n\t\tbreak;\n\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\tcase AX25_PROTO_DAMA_SLAVE:\n\t\tif (ax25_dev->dama.slave)\n\t\t\tax25_ds_establish_data_link(ax25);\n\t\telse\n\t\t\tax25_std_establish_data_link(ax25);\n\t\tbreak;\n#endif\n\t}\n\n\t \n\tax25_cb_hold(ax25);\n\n\tax25_cb_add(ax25);\n\n\tax25->state = AX25_STATE_1;\n\n\tax25_start_heartbeat(ax25);\n\n\tax25_output(ax25, paclen, skb);\n\n\treturn ax25;\t\t\t \n}\n\nEXPORT_SYMBOL(ax25_send_frame);\n\n \nvoid ax25_output(ax25_cb *ax25, int paclen, struct sk_buff *skb)\n{\n\tstruct sk_buff *skbn;\n\tunsigned char *p;\n\tint frontlen, len, fragno, ka9qfrag, first = 1;\n\n\tif (paclen < 16) {\n\t\tWARN_ON_ONCE(1);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif ((skb->len - 1) > paclen) {\n\t\tif (*skb->data == AX25_P_TEXT) {\n\t\t\tskb_pull(skb, 1);  \n\t\t\tka9qfrag = 0;\n\t\t} else {\n\t\t\tpaclen -= 2;\t \n\t\t\tka9qfrag = 1;\n\t\t}\n\n\t\tfragno = skb->len / paclen;\n\t\tif (skb->len % paclen == 0) fragno--;\n\n\t\tfrontlen = skb_headroom(skb);\t \n\n\t\twhile (skb->len > 0) {\n\t\t\tspin_lock_bh(&ax25_frag_lock);\n\t\t\tif ((skbn = alloc_skb(paclen + 2 + frontlen, GFP_ATOMIC)) == NULL) {\n\t\t\t\tspin_unlock_bh(&ax25_frag_lock);\n\t\t\t\tprintk(KERN_CRIT \"AX.25: ax25_output - out of memory\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (skb->sk != NULL)\n\t\t\t\tskb_set_owner_w(skbn, skb->sk);\n\n\t\t\tspin_unlock_bh(&ax25_frag_lock);\n\n\t\t\tlen = (paclen > skb->len) ? skb->len : paclen;\n\n\t\t\tif (ka9qfrag == 1) {\n\t\t\t\tskb_reserve(skbn, frontlen + 2);\n\t\t\t\tskb_set_network_header(skbn,\n\t\t\t\t\t\t      skb_network_offset(skb));\n\t\t\t\tskb_copy_from_linear_data(skb, skb_put(skbn, len), len);\n\t\t\t\tp = skb_push(skbn, 2);\n\n\t\t\t\t*p++ = AX25_P_SEGMENT;\n\n\t\t\t\t*p = fragno--;\n\t\t\t\tif (first) {\n\t\t\t\t\t*p |= AX25_SEG_FIRST;\n\t\t\t\t\tfirst = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskb_reserve(skbn, frontlen + 1);\n\t\t\t\tskb_set_network_header(skbn,\n\t\t\t\t\t\t      skb_network_offset(skb));\n\t\t\t\tskb_copy_from_linear_data(skb, skb_put(skbn, len), len);\n\t\t\t\tp = skb_push(skbn, 1);\n\t\t\t\t*p = AX25_P_TEXT;\n\t\t\t}\n\n\t\t\tskb_pull(skb, len);\n\t\t\tskb_queue_tail(&ax25->write_queue, skbn);  \n\t\t}\n\n\t\tkfree_skb(skb);\n\t} else {\n\t\tskb_queue_tail(&ax25->write_queue, skb);\t   \n\t}\n\n\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\tcase AX25_PROTO_STD_SIMPLEX:\n\tcase AX25_PROTO_STD_DUPLEX:\n\t\tax25_kick(ax25);\n\t\tbreak;\n\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t \n\tcase AX25_PROTO_DAMA_SLAVE:\n\t\tif (!ax25->ax25_dev->dama.slave) ax25_kick(ax25);\n\t\tbreak;\n#endif\n\t}\n}\n\n \nstatic void ax25_send_iframe(ax25_cb *ax25, struct sk_buff *skb, int poll_bit)\n{\n\tunsigned char *frame;\n\n\tif (skb == NULL)\n\t\treturn;\n\n\tskb_reset_network_header(skb);\n\n\tif (ax25->modulus == AX25_MODULUS) {\n\t\tframe = skb_push(skb, 1);\n\n\t\t*frame = AX25_I;\n\t\t*frame |= (poll_bit) ? AX25_PF : 0;\n\t\t*frame |= (ax25->vr << 5);\n\t\t*frame |= (ax25->vs << 1);\n\t} else {\n\t\tframe = skb_push(skb, 2);\n\n\t\tframe[0] = AX25_I;\n\t\tframe[0] |= (ax25->vs << 1);\n\t\tframe[1] = (poll_bit) ? AX25_EPF : 0;\n\t\tframe[1] |= (ax25->vr << 1);\n\t}\n\n\tax25_start_idletimer(ax25);\n\n\tax25_transmit_buffer(ax25, skb, AX25_COMMAND);\n}\n\nvoid ax25_kick(ax25_cb *ax25)\n{\n\tstruct sk_buff *skb, *skbn;\n\tint last = 1;\n\tunsigned short start, end, next;\n\n\tif (ax25->state != AX25_STATE_3 && ax25->state != AX25_STATE_4)\n\t\treturn;\n\n\tif (ax25->condition & AX25_COND_PEER_RX_BUSY)\n\t\treturn;\n\n\tif (skb_peek(&ax25->write_queue) == NULL)\n\t\treturn;\n\n\tstart = (skb_peek(&ax25->ack_queue) == NULL) ? ax25->va : ax25->vs;\n\tend   = (ax25->va + ax25->window) % ax25->modulus;\n\n\tif (start == end)\n\t\treturn;\n\n\t \n\n\t \n\tskb  = skb_dequeue(&ax25->write_queue);\n\tif (!skb)\n\t\treturn;\n\n\tax25->vs = start;\n\n\tdo {\n\t\tif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {\n\t\t\tskb_queue_head(&ax25->write_queue, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->sk != NULL)\n\t\t\tskb_set_owner_w(skbn, skb->sk);\n\n\t\tnext = (ax25->vs + 1) % ax25->modulus;\n\t\tlast = (next == end);\n\n\t\t \n\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\tax25_send_iframe(ax25, skbn, (last) ? AX25_POLLON : AX25_POLLOFF);\n\t\t\tbreak;\n\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\tax25_send_iframe(ax25, skbn, AX25_POLLOFF);\n\t\t\tbreak;\n#endif\n\t\t}\n\n\t\tax25->vs = next;\n\n\t\t \n\t\tskb_queue_tail(&ax25->ack_queue, skb);\n\n\t} while (!last && (skb = skb_dequeue(&ax25->write_queue)) != NULL);\n\n\tax25->condition &= ~AX25_COND_ACK_PENDING;\n\n\tif (!ax25_t1timer_running(ax25)) {\n\t\tax25_stop_t3timer(ax25);\n\t\tax25_calculate_t1(ax25);\n\t\tax25_start_t1timer(ax25);\n\t}\n}\n\nvoid ax25_transmit_buffer(ax25_cb *ax25, struct sk_buff *skb, int type)\n{\n\tunsigned char *ptr;\n\tint headroom;\n\n\tif (ax25->ax25_dev == NULL) {\n\t\tax25_disconnect(ax25, ENETUNREACH);\n\t\treturn;\n\t}\n\n\theadroom = ax25_addr_size(ax25->digipeat);\n\n\tif (unlikely(skb_headroom(skb) < headroom)) {\n\t\tskb = skb_expand_head(skb, headroom);\n\t\tif (!skb) {\n\t\t\tprintk(KERN_CRIT \"AX.25: ax25_transmit_buffer - out of memory\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tptr = skb_push(skb, headroom);\n\n\tax25_addr_build(ptr, &ax25->source_addr, &ax25->dest_addr, ax25->digipeat, type, ax25->modulus);\n\n\tax25_queue_xmit(skb, ax25->ax25_dev->dev);\n}\n\n \nvoid ax25_queue_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tunsigned char *ptr;\n\n\tskb->protocol = ax25_type_trans(skb, ax25_fwd_dev(dev));\n\n\tptr  = skb_push(skb, 1);\n\t*ptr = 0x00;\t\t\t \n\n\tdev_queue_xmit(skb);\n}\n\nint ax25_check_iframes_acked(ax25_cb *ax25, unsigned short nr)\n{\n\tif (ax25->vs == nr) {\n\t\tax25_frames_acked(ax25, nr);\n\t\tax25_calculate_rtt(ax25);\n\t\tax25_stop_t1timer(ax25);\n\t\tax25_start_t3timer(ax25);\n\t\treturn 1;\n\t} else {\n\t\tif (ax25->va != nr) {\n\t\t\tax25_frames_acked(ax25, nr);\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}