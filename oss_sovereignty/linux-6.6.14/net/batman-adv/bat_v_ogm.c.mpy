{
  "module_name": "bat_v_ogm.c",
  "hash_id": "8b93065e5c247303e1def563b8dc54121c28a8f0fb638f275b7b3fb62e204b9b",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/bat_v_ogm.c",
  "human_readable_source": "\n \n\n#include \"bat_v_ogm.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/byteorder/generic.h>\n#include <linux/container_of.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/minmax.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <uapi/linux/batadv_packet.h>\n\n#include \"bat_algo.h\"\n#include \"hard-interface.h\"\n#include \"hash.h\"\n#include \"log.h\"\n#include \"originator.h\"\n#include \"routing.h\"\n#include \"send.h\"\n#include \"translation-table.h\"\n#include \"tvlv.h\"\n\n \nstruct batadv_orig_node *batadv_v_ogm_orig_get(struct batadv_priv *bat_priv,\n\t\t\t\t\t       const u8 *addr)\n{\n\tstruct batadv_orig_node *orig_node;\n\tint hash_added;\n\n\torig_node = batadv_orig_hash_find(bat_priv, addr);\n\tif (orig_node)\n\t\treturn orig_node;\n\n\torig_node = batadv_orig_node_new(bat_priv, addr);\n\tif (!orig_node)\n\t\treturn NULL;\n\n\tkref_get(&orig_node->refcount);\n\thash_added = batadv_hash_add(bat_priv->orig_hash, batadv_compare_orig,\n\t\t\t\t     batadv_choose_orig, orig_node,\n\t\t\t\t     &orig_node->hash_entry);\n\tif (hash_added != 0) {\n\t\t \n\t\tbatadv_orig_node_put(orig_node);\n\t\tbatadv_orig_node_put(orig_node);\n\t\torig_node = NULL;\n\t}\n\n\treturn orig_node;\n}\n\n \nstatic void batadv_v_ogm_start_queue_timer(struct batadv_hard_iface *hard_iface)\n{\n\tunsigned int msecs = BATADV_MAX_AGGREGATION_MS * 1000;\n\n\t \n\tmsecs += get_random_u32_below(msecs / 5) - (msecs / 10);\n\tqueue_delayed_work(batadv_event_workqueue, &hard_iface->bat_v.aggr_wq,\n\t\t\t   msecs_to_jiffies(msecs / 1000));\n}\n\n \nstatic void batadv_v_ogm_start_timer(struct batadv_priv *bat_priv)\n{\n\tunsigned long msecs;\n\t \n\tif (delayed_work_pending(&bat_priv->bat_v.ogm_wq))\n\t\treturn;\n\n\tmsecs = atomic_read(&bat_priv->orig_interval) - BATADV_JITTER;\n\tmsecs += get_random_u32_below(2 * BATADV_JITTER);\n\tqueue_delayed_work(batadv_event_workqueue, &bat_priv->bat_v.ogm_wq,\n\t\t\t   msecs_to_jiffies(msecs));\n}\n\n \nstatic void batadv_v_ogm_send_to_if(struct sk_buff *skb,\n\t\t\t\t    struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\n\tif (hard_iface->if_status != BATADV_IF_ACTIVE) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_MGMT_TX);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_MGMT_TX_BYTES,\n\t\t\t   skb->len + ETH_HLEN);\n\n\tbatadv_send_broadcast_skb(skb, hard_iface);\n}\n\n \nstatic unsigned int batadv_v_ogm_len(struct sk_buff *skb)\n{\n\tstruct batadv_ogm2_packet *ogm_packet;\n\n\togm_packet = (struct batadv_ogm2_packet *)skb->data;\n\treturn BATADV_OGM2_HLEN + ntohs(ogm_packet->tvlv_len);\n}\n\n \nstatic bool batadv_v_ogm_queue_left(struct sk_buff *skb,\n\t\t\t\t    struct batadv_hard_iface *hard_iface)\n{\n\tunsigned int max = min_t(unsigned int, hard_iface->net_dev->mtu,\n\t\t\t\t BATADV_MAX_AGGREGATION_BYTES);\n\tunsigned int ogm_len = batadv_v_ogm_len(skb);\n\n\tlockdep_assert_held(&hard_iface->bat_v.aggr_list.lock);\n\n\treturn hard_iface->bat_v.aggr_len + ogm_len <= max;\n}\n\n \nstatic void batadv_v_ogm_aggr_list_free(struct batadv_hard_iface *hard_iface)\n{\n\tlockdep_assert_held(&hard_iface->bat_v.aggr_list.lock);\n\n\t__skb_queue_purge(&hard_iface->bat_v.aggr_list);\n\thard_iface->bat_v.aggr_len = 0;\n}\n\n \nstatic void batadv_v_ogm_aggr_send(struct batadv_hard_iface *hard_iface)\n{\n\tunsigned int aggr_len = hard_iface->bat_v.aggr_len;\n\tstruct sk_buff *skb_aggr;\n\tunsigned int ogm_len;\n\tstruct sk_buff *skb;\n\n\tlockdep_assert_held(&hard_iface->bat_v.aggr_list.lock);\n\n\tif (!aggr_len)\n\t\treturn;\n\n\tskb_aggr = dev_alloc_skb(aggr_len + ETH_HLEN + NET_IP_ALIGN);\n\tif (!skb_aggr) {\n\t\tbatadv_v_ogm_aggr_list_free(hard_iface);\n\t\treturn;\n\t}\n\n\tskb_reserve(skb_aggr, ETH_HLEN + NET_IP_ALIGN);\n\tskb_reset_network_header(skb_aggr);\n\n\twhile ((skb = __skb_dequeue(&hard_iface->bat_v.aggr_list))) {\n\t\thard_iface->bat_v.aggr_len -= batadv_v_ogm_len(skb);\n\n\t\togm_len = batadv_v_ogm_len(skb);\n\t\tskb_put_data(skb_aggr, skb->data, ogm_len);\n\n\t\tconsume_skb(skb);\n\t}\n\n\tbatadv_v_ogm_send_to_if(skb_aggr, hard_iface);\n}\n\n \nstatic void batadv_v_ogm_queue_on_if(struct sk_buff *skb,\n\t\t\t\t     struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\n\tif (!atomic_read(&bat_priv->aggregated_ogms)) {\n\t\tbatadv_v_ogm_send_to_if(skb, hard_iface);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&hard_iface->bat_v.aggr_list.lock);\n\tif (!batadv_v_ogm_queue_left(skb, hard_iface))\n\t\tbatadv_v_ogm_aggr_send(hard_iface);\n\n\thard_iface->bat_v.aggr_len += batadv_v_ogm_len(skb);\n\t__skb_queue_tail(&hard_iface->bat_v.aggr_list, skb);\n\tspin_unlock_bh(&hard_iface->bat_v.aggr_list.lock);\n}\n\n \nstatic void batadv_v_ogm_send_softif(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_ogm2_packet *ogm_packet;\n\tstruct sk_buff *skb, *skb_tmp;\n\tunsigned char *ogm_buff;\n\tint ogm_buff_len;\n\tu16 tvlv_len = 0;\n\tint ret;\n\n\tlockdep_assert_held(&bat_priv->bat_v.ogm_buff_mutex);\n\n\tif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING)\n\t\tgoto out;\n\n\togm_buff = bat_priv->bat_v.ogm_buff;\n\togm_buff_len = bat_priv->bat_v.ogm_buff_len;\n\t \n\tbatadv_tt_local_commit_changes(bat_priv);\n\ttvlv_len = batadv_tvlv_container_ogm_append(bat_priv, &ogm_buff,\n\t\t\t\t\t\t    &ogm_buff_len,\n\t\t\t\t\t\t    BATADV_OGM2_HLEN);\n\n\tbat_priv->bat_v.ogm_buff = ogm_buff;\n\tbat_priv->bat_v.ogm_buff_len = ogm_buff_len;\n\n\tskb = netdev_alloc_skb_ip_align(NULL, ETH_HLEN + ogm_buff_len);\n\tif (!skb)\n\t\tgoto reschedule;\n\n\tskb_reserve(skb, ETH_HLEN);\n\tskb_put_data(skb, ogm_buff, ogm_buff_len);\n\n\togm_packet = (struct batadv_ogm2_packet *)skb->data;\n\togm_packet->seqno = htonl(atomic_read(&bat_priv->bat_v.ogm_seqno));\n\tatomic_inc(&bat_priv->bat_v.ogm_seqno);\n\togm_packet->tvlv_len = htons(tvlv_len);\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->soft_iface != bat_priv->soft_iface)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&hard_iface->refcount))\n\t\t\tcontinue;\n\n\t\tret = batadv_hardif_no_broadcast(hard_iface, NULL, NULL);\n\t\tif (ret) {\n\t\t\tchar *type;\n\n\t\t\tswitch (ret) {\n\t\t\tcase BATADV_HARDIF_BCAST_NORECIPIENT:\n\t\t\t\ttype = \"no neighbor\";\n\t\t\t\tbreak;\n\t\t\tcase BATADV_HARDIF_BCAST_DUPFWD:\n\t\t\t\ttype = \"single neighbor is source\";\n\t\t\t\tbreak;\n\t\t\tcase BATADV_HARDIF_BCAST_DUPORIG:\n\t\t\t\ttype = \"single neighbor is originator\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttype = \"unknown\";\n\t\t\t}\n\n\t\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv, \"OGM2 from ourselves on %s suppressed: %s\\n\",\n\t\t\t\t   hard_iface->net_dev->name, type);\n\n\t\t\tbatadv_hardif_put(hard_iface);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Sending own OGM2 packet (originator %pM, seqno %u, throughput %u, TTL %d) on interface %s [%pM]\\n\",\n\t\t\t   ogm_packet->orig, ntohl(ogm_packet->seqno),\n\t\t\t   ntohl(ogm_packet->throughput), ogm_packet->ttl,\n\t\t\t   hard_iface->net_dev->name,\n\t\t\t   hard_iface->net_dev->dev_addr);\n\n\t\t \n\t\tskb_tmp = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb_tmp) {\n\t\t\tbatadv_hardif_put(hard_iface);\n\t\t\tbreak;\n\t\t}\n\n\t\tbatadv_v_ogm_queue_on_if(skb_tmp, hard_iface);\n\t\tbatadv_hardif_put(hard_iface);\n\t}\n\trcu_read_unlock();\n\n\tconsume_skb(skb);\n\nreschedule:\n\tbatadv_v_ogm_start_timer(bat_priv);\nout:\n\treturn;\n}\n\n \nstatic void batadv_v_ogm_send(struct work_struct *work)\n{\n\tstruct batadv_priv_bat_v *bat_v;\n\tstruct batadv_priv *bat_priv;\n\n\tbat_v = container_of(work, struct batadv_priv_bat_v, ogm_wq.work);\n\tbat_priv = container_of(bat_v, struct batadv_priv, bat_v);\n\n\tmutex_lock(&bat_priv->bat_v.ogm_buff_mutex);\n\tbatadv_v_ogm_send_softif(bat_priv);\n\tmutex_unlock(&bat_priv->bat_v.ogm_buff_mutex);\n}\n\n \nvoid batadv_v_ogm_aggr_work(struct work_struct *work)\n{\n\tstruct batadv_hard_iface_bat_v *batv;\n\tstruct batadv_hard_iface *hard_iface;\n\n\tbatv = container_of(work, struct batadv_hard_iface_bat_v, aggr_wq.work);\n\thard_iface = container_of(batv, struct batadv_hard_iface, bat_v);\n\n\tspin_lock_bh(&hard_iface->bat_v.aggr_list.lock);\n\tbatadv_v_ogm_aggr_send(hard_iface);\n\tspin_unlock_bh(&hard_iface->bat_v.aggr_list.lock);\n\n\tbatadv_v_ogm_start_queue_timer(hard_iface);\n}\n\n \nint batadv_v_ogm_iface_enable(struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\n\tbatadv_v_ogm_start_queue_timer(hard_iface);\n\tbatadv_v_ogm_start_timer(bat_priv);\n\n\treturn 0;\n}\n\n \nvoid batadv_v_ogm_iface_disable(struct batadv_hard_iface *hard_iface)\n{\n\tcancel_delayed_work_sync(&hard_iface->bat_v.aggr_wq);\n\n\tspin_lock_bh(&hard_iface->bat_v.aggr_list.lock);\n\tbatadv_v_ogm_aggr_list_free(hard_iface);\n\tspin_unlock_bh(&hard_iface->bat_v.aggr_list.lock);\n}\n\n \nvoid batadv_v_ogm_primary_iface_set(struct batadv_hard_iface *primary_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(primary_iface->soft_iface);\n\tstruct batadv_ogm2_packet *ogm_packet;\n\n\tmutex_lock(&bat_priv->bat_v.ogm_buff_mutex);\n\tif (!bat_priv->bat_v.ogm_buff)\n\t\tgoto unlock;\n\n\togm_packet = (struct batadv_ogm2_packet *)bat_priv->bat_v.ogm_buff;\n\tether_addr_copy(ogm_packet->orig, primary_iface->net_dev->dev_addr);\n\nunlock:\n\tmutex_unlock(&bat_priv->bat_v.ogm_buff_mutex);\n}\n\n \nstatic u32 batadv_v_forward_penalty(struct batadv_priv *bat_priv,\n\t\t\t\t    struct batadv_hard_iface *if_incoming,\n\t\t\t\t    struct batadv_hard_iface *if_outgoing,\n\t\t\t\t    u32 throughput)\n{\n\tint if_hop_penalty = atomic_read(&if_incoming->hop_penalty);\n\tint hop_penalty = atomic_read(&bat_priv->hop_penalty);\n\tint hop_penalty_max = BATADV_TQ_MAX_VALUE;\n\n\t \n\tthroughput = throughput * (hop_penalty_max - if_hop_penalty) /\n\t\t     hop_penalty_max;\n\n\t \n\tif (if_outgoing == BATADV_IF_DEFAULT)\n\t\treturn throughput;\n\n\t \n\tif (throughput > 10 &&\n\t    if_incoming == if_outgoing &&\n\t    !(if_incoming->bat_v.flags & BATADV_FULL_DUPLEX))\n\t\treturn throughput / 2;\n\n\t \n\treturn throughput * (hop_penalty_max - hop_penalty) / hop_penalty_max;\n}\n\n \nstatic void batadv_v_ogm_forward(struct batadv_priv *bat_priv,\n\t\t\t\t const struct batadv_ogm2_packet *ogm_received,\n\t\t\t\t struct batadv_orig_node *orig_node,\n\t\t\t\t struct batadv_neigh_node *neigh_node,\n\t\t\t\t struct batadv_hard_iface *if_incoming,\n\t\t\t\t struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_neigh_ifinfo *neigh_ifinfo = NULL;\n\tstruct batadv_orig_ifinfo *orig_ifinfo = NULL;\n\tstruct batadv_neigh_node *router = NULL;\n\tstruct batadv_ogm2_packet *ogm_forward;\n\tunsigned char *skb_buff;\n\tstruct sk_buff *skb;\n\tsize_t packet_len;\n\tu16 tvlv_len;\n\n\t \n\tif (if_outgoing == BATADV_IF_DEFAULT)\n\t\tgoto out;\n\n\torig_ifinfo = batadv_orig_ifinfo_new(orig_node, if_outgoing);\n\tif (!orig_ifinfo)\n\t\tgoto out;\n\n\t \n\trouter = batadv_orig_router_get(orig_node, if_outgoing);\n\n\t \n\tif (neigh_node != router)\n\t\tgoto out;\n\n\t \n\tif (orig_ifinfo->last_seqno_forwarded == ntohl(ogm_received->seqno))\n\t\tgoto out;\n\n\torig_ifinfo->last_seqno_forwarded = ntohl(ogm_received->seqno);\n\n\tif (ogm_received->ttl <= 1) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv, \"ttl exceeded\\n\");\n\t\tgoto out;\n\t}\n\n\tneigh_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);\n\tif (!neigh_ifinfo)\n\t\tgoto out;\n\n\ttvlv_len = ntohs(ogm_received->tvlv_len);\n\n\tpacket_len = BATADV_OGM2_HLEN + tvlv_len;\n\tskb = netdev_alloc_skb_ip_align(if_outgoing->net_dev,\n\t\t\t\t\tETH_HLEN + packet_len);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb_reserve(skb, ETH_HLEN);\n\tskb_buff = skb_put_data(skb, ogm_received, packet_len);\n\n\t \n\togm_forward = (struct batadv_ogm2_packet *)skb_buff;\n\togm_forward->throughput = htonl(neigh_ifinfo->bat_v.throughput);\n\togm_forward->ttl--;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Forwarding OGM2 packet on %s: throughput %u, ttl %u, received via %s\\n\",\n\t\t   if_outgoing->net_dev->name, ntohl(ogm_forward->throughput),\n\t\t   ogm_forward->ttl, if_incoming->net_dev->name);\n\n\tbatadv_v_ogm_queue_on_if(skb, if_outgoing);\n\nout:\n\tbatadv_orig_ifinfo_put(orig_ifinfo);\n\tbatadv_neigh_node_put(router);\n\tbatadv_neigh_ifinfo_put(neigh_ifinfo);\n}\n\n \nstatic int batadv_v_ogm_metric_update(struct batadv_priv *bat_priv,\n\t\t\t\t      const struct batadv_ogm2_packet *ogm2,\n\t\t\t\t      struct batadv_orig_node *orig_node,\n\t\t\t\t      struct batadv_neigh_node *neigh_node,\n\t\t\t\t      struct batadv_hard_iface *if_incoming,\n\t\t\t\t      struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tstruct batadv_neigh_ifinfo *neigh_ifinfo = NULL;\n\tbool protection_started = false;\n\tint ret = -EINVAL;\n\tu32 path_throughput;\n\ts32 seq_diff;\n\n\torig_ifinfo = batadv_orig_ifinfo_new(orig_node, if_outgoing);\n\tif (!orig_ifinfo)\n\t\tgoto out;\n\n\tseq_diff = ntohl(ogm2->seqno) - orig_ifinfo->last_real_seqno;\n\n\tif (!hlist_empty(&orig_node->neigh_list) &&\n\t    batadv_window_protected(bat_priv, seq_diff,\n\t\t\t\t    BATADV_OGM_MAX_AGE,\n\t\t\t\t    &orig_ifinfo->batman_seqno_reset,\n\t\t\t\t    &protection_started)) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: packet within window protection time from %pM\\n\",\n\t\t\t   ogm2->orig);\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Last reset: %ld, %ld\\n\",\n\t\t\t   orig_ifinfo->batman_seqno_reset, jiffies);\n\t\tgoto out;\n\t}\n\n\t \n\tif (seq_diff < 0 && !protection_started)\n\t\tgoto out;\n\n\tneigh_node->last_seen = jiffies;\n\n\torig_node->last_seen = jiffies;\n\n\torig_ifinfo->last_real_seqno = ntohl(ogm2->seqno);\n\torig_ifinfo->last_ttl = ogm2->ttl;\n\n\tneigh_ifinfo = batadv_neigh_ifinfo_new(neigh_node, if_outgoing);\n\tif (!neigh_ifinfo)\n\t\tgoto out;\n\n\tpath_throughput = batadv_v_forward_penalty(bat_priv, if_incoming,\n\t\t\t\t\t\t   if_outgoing,\n\t\t\t\t\t\t   ntohl(ogm2->throughput));\n\tneigh_ifinfo->bat_v.throughput = path_throughput;\n\tneigh_ifinfo->bat_v.last_seqno = ntohl(ogm2->seqno);\n\tneigh_ifinfo->last_ttl = ogm2->ttl;\n\n\tif (seq_diff > 0 || protection_started)\n\t\tret = 1;\n\telse\n\t\tret = 0;\nout:\n\tbatadv_orig_ifinfo_put(orig_ifinfo);\n\tbatadv_neigh_ifinfo_put(neigh_ifinfo);\n\n\treturn ret;\n}\n\n \nstatic bool batadv_v_ogm_route_update(struct batadv_priv *bat_priv,\n\t\t\t\t      const struct ethhdr *ethhdr,\n\t\t\t\t      const struct batadv_ogm2_packet *ogm2,\n\t\t\t\t      struct batadv_orig_node *orig_node,\n\t\t\t\t      struct batadv_neigh_node *neigh_node,\n\t\t\t\t      struct batadv_hard_iface *if_incoming,\n\t\t\t\t      struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_neigh_node *router = NULL;\n\tstruct batadv_orig_node *orig_neigh_node;\n\tstruct batadv_neigh_node *orig_neigh_router = NULL;\n\tstruct batadv_neigh_ifinfo *router_ifinfo = NULL, *neigh_ifinfo = NULL;\n\tu32 router_throughput, neigh_throughput;\n\tu32 router_last_seqno;\n\tu32 neigh_last_seqno;\n\ts32 neigh_seq_diff;\n\tbool forward = false;\n\n\torig_neigh_node = batadv_v_ogm_orig_get(bat_priv, ethhdr->h_source);\n\tif (!orig_neigh_node)\n\t\tgoto out;\n\n\torig_neigh_router = batadv_orig_router_get(orig_neigh_node,\n\t\t\t\t\t\t   if_outgoing);\n\n\t \n\trouter = batadv_orig_router_get(orig_node, if_outgoing);\n\tif (router && router->orig_node != orig_node && !orig_neigh_router) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: OGM via unknown neighbor!\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tforward = true;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Searching and updating originator entry of received packet\\n\");\n\n\t \n\tif (router == neigh_node)\n\t\tgoto out;\n\n\t \n\tif (router) {\n\t\trouter_ifinfo = batadv_neigh_ifinfo_get(router, if_outgoing);\n\t\tneigh_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);\n\n\t\t \n\t\tif (!router_ifinfo || !neigh_ifinfo)\n\t\t\tgoto out;\n\n\t\tneigh_last_seqno = neigh_ifinfo->bat_v.last_seqno;\n\t\trouter_last_seqno = router_ifinfo->bat_v.last_seqno;\n\t\tneigh_seq_diff = neigh_last_seqno - router_last_seqno;\n\t\trouter_throughput = router_ifinfo->bat_v.throughput;\n\t\tneigh_throughput = neigh_ifinfo->bat_v.throughput;\n\n\t\tif (neigh_seq_diff < BATADV_OGM_MAX_ORIGDIFF &&\n\t\t    router_throughput >= neigh_throughput)\n\t\t\tgoto out;\n\t}\n\n\tbatadv_update_route(bat_priv, orig_node, if_outgoing, neigh_node);\nout:\n\tbatadv_neigh_node_put(router);\n\tbatadv_neigh_node_put(orig_neigh_router);\n\tbatadv_orig_node_put(orig_neigh_node);\n\tbatadv_neigh_ifinfo_put(router_ifinfo);\n\tbatadv_neigh_ifinfo_put(neigh_ifinfo);\n\n\treturn forward;\n}\n\n \nstatic void\nbatadv_v_ogm_process_per_outif(struct batadv_priv *bat_priv,\n\t\t\t       const struct ethhdr *ethhdr,\n\t\t\t       const struct batadv_ogm2_packet *ogm2,\n\t\t\t       struct batadv_orig_node *orig_node,\n\t\t\t       struct batadv_neigh_node *neigh_node,\n\t\t\t       struct batadv_hard_iface *if_incoming,\n\t\t\t       struct batadv_hard_iface *if_outgoing)\n{\n\tint seqno_age;\n\tbool forward;\n\n\t \n\tseqno_age = batadv_v_ogm_metric_update(bat_priv, ogm2, orig_node,\n\t\t\t\t\t       neigh_node, if_incoming,\n\t\t\t\t\t       if_outgoing);\n\n\t \n\tif (seqno_age < 0)\n\t\treturn;\n\n\t \n\tif (seqno_age > 0 && if_outgoing == BATADV_IF_DEFAULT)\n\t\tbatadv_tvlv_containers_process(bat_priv, BATADV_OGM2, orig_node,\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       (unsigned char *)(ogm2 + 1),\n\t\t\t\t\t       ntohs(ogm2->tvlv_len));\n\n\t \n\tforward = batadv_v_ogm_route_update(bat_priv, ethhdr, ogm2, orig_node,\n\t\t\t\t\t    neigh_node, if_incoming,\n\t\t\t\t\t    if_outgoing);\n\n\t \n\tif (forward)\n\t\tbatadv_v_ogm_forward(bat_priv, ogm2, orig_node, neigh_node,\n\t\t\t\t     if_incoming, if_outgoing);\n}\n\n \nstatic bool\nbatadv_v_ogm_aggr_packet(int buff_pos, int packet_len,\n\t\t\t const struct batadv_ogm2_packet *ogm2_packet)\n{\n\tint next_buff_pos = 0;\n\n\t \n\tnext_buff_pos += buff_pos + sizeof(*ogm2_packet);\n\tif (next_buff_pos > packet_len)\n\t\treturn false;\n\n\t \n\tnext_buff_pos += ntohs(ogm2_packet->tvlv_len);\n\n\treturn (next_buff_pos <= packet_len) &&\n\t       (next_buff_pos <= BATADV_MAX_AGGREGATION_BYTES);\n}\n\n \nstatic void batadv_v_ogm_process(const struct sk_buff *skb, int ogm_offset,\n\t\t\t\t struct batadv_hard_iface *if_incoming)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\n\tstruct ethhdr *ethhdr;\n\tstruct batadv_orig_node *orig_node = NULL;\n\tstruct batadv_hardif_neigh_node *hardif_neigh = NULL;\n\tstruct batadv_neigh_node *neigh_node = NULL;\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_ogm2_packet *ogm_packet;\n\tu32 ogm_throughput, link_throughput, path_throughput;\n\tint ret;\n\n\tethhdr = eth_hdr(skb);\n\togm_packet = (struct batadv_ogm2_packet *)(skb->data + ogm_offset);\n\n\togm_throughput = ntohl(ogm_packet->throughput);\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Received OGM2 packet via NB: %pM, IF: %s [%pM] (from OG: %pM, seqno %u, throughput %u, TTL %u, V %u, tvlv_len %u)\\n\",\n\t\t   ethhdr->h_source, if_incoming->net_dev->name,\n\t\t   if_incoming->net_dev->dev_addr, ogm_packet->orig,\n\t\t   ntohl(ogm_packet->seqno), ogm_throughput, ogm_packet->ttl,\n\t\t   ogm_packet->version, ntohs(ogm_packet->tvlv_len));\n\n\tif (batadv_is_my_mac(bat_priv, ogm_packet->orig)) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: originator packet from ourself\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (ogm_throughput == 0) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: originator packet with throughput metric of 0\\n\");\n\t\treturn;\n\t}\n\n\t \n\thardif_neigh = batadv_hardif_neigh_get(if_incoming, ethhdr->h_source);\n\tif (!hardif_neigh) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: OGM via unknown neighbor!\\n\");\n\t\tgoto out;\n\t}\n\n\torig_node = batadv_v_ogm_orig_get(bat_priv, ogm_packet->orig);\n\tif (!orig_node)\n\t\tgoto out;\n\n\tneigh_node = batadv_neigh_node_get_or_create(orig_node, if_incoming,\n\t\t\t\t\t\t     ethhdr->h_source);\n\tif (!neigh_node)\n\t\tgoto out;\n\n\t \n\tlink_throughput = ewma_throughput_read(&hardif_neigh->bat_v.throughput);\n\tpath_throughput = min_t(u32, link_throughput, ogm_throughput);\n\togm_packet->throughput = htonl(path_throughput);\n\n\tbatadv_v_ogm_process_per_outif(bat_priv, ethhdr, ogm_packet, orig_node,\n\t\t\t\t       neigh_node, if_incoming,\n\t\t\t\t       BATADV_IF_DEFAULT);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->if_status != BATADV_IF_ACTIVE)\n\t\t\tcontinue;\n\n\t\tif (hard_iface->soft_iface != bat_priv->soft_iface)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&hard_iface->refcount))\n\t\t\tcontinue;\n\n\t\tret = batadv_hardif_no_broadcast(hard_iface,\n\t\t\t\t\t\t ogm_packet->orig,\n\t\t\t\t\t\t hardif_neigh->orig);\n\n\t\tif (ret) {\n\t\t\tchar *type;\n\n\t\t\tswitch (ret) {\n\t\t\tcase BATADV_HARDIF_BCAST_NORECIPIENT:\n\t\t\t\ttype = \"no neighbor\";\n\t\t\t\tbreak;\n\t\t\tcase BATADV_HARDIF_BCAST_DUPFWD:\n\t\t\t\ttype = \"single neighbor is source\";\n\t\t\t\tbreak;\n\t\t\tcase BATADV_HARDIF_BCAST_DUPORIG:\n\t\t\t\ttype = \"single neighbor is originator\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttype = \"unknown\";\n\t\t\t}\n\n\t\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv, \"OGM2 packet from %pM on %s suppressed: %s\\n\",\n\t\t\t\t   ogm_packet->orig, hard_iface->net_dev->name,\n\t\t\t\t   type);\n\n\t\t\tbatadv_hardif_put(hard_iface);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbatadv_v_ogm_process_per_outif(bat_priv, ethhdr, ogm_packet,\n\t\t\t\t\t       orig_node, neigh_node,\n\t\t\t\t\t       if_incoming, hard_iface);\n\n\t\tbatadv_hardif_put(hard_iface);\n\t}\n\trcu_read_unlock();\nout:\n\tbatadv_orig_node_put(orig_node);\n\tbatadv_neigh_node_put(neigh_node);\n\tbatadv_hardif_neigh_put(hardif_neigh);\n}\n\n \nint batadv_v_ogm_packet_recv(struct sk_buff *skb,\n\t\t\t     struct batadv_hard_iface *if_incoming)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\n\tstruct batadv_ogm2_packet *ogm_packet;\n\tstruct ethhdr *ethhdr;\n\tint ogm_offset;\n\tu8 *packet_pos;\n\tint ret = NET_RX_DROP;\n\n\t \n\tif (strcmp(bat_priv->algo_ops->name, \"BATMAN_V\") != 0)\n\t\tgoto free_skb;\n\n\tif (!batadv_check_management_packet(skb, if_incoming, BATADV_OGM2_HLEN))\n\t\tgoto free_skb;\n\n\tethhdr = eth_hdr(skb);\n\tif (batadv_is_my_mac(bat_priv, ethhdr->h_source))\n\t\tgoto free_skb;\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_MGMT_RX);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_MGMT_RX_BYTES,\n\t\t\t   skb->len + ETH_HLEN);\n\n\togm_offset = 0;\n\togm_packet = (struct batadv_ogm2_packet *)skb->data;\n\n\twhile (batadv_v_ogm_aggr_packet(ogm_offset, skb_headlen(skb),\n\t\t\t\t\togm_packet)) {\n\t\tbatadv_v_ogm_process(skb, ogm_offset, if_incoming);\n\n\t\togm_offset += BATADV_OGM2_HLEN;\n\t\togm_offset += ntohs(ogm_packet->tvlv_len);\n\n\t\tpacket_pos = skb->data + ogm_offset;\n\t\togm_packet = (struct batadv_ogm2_packet *)packet_pos;\n\t}\n\n\tret = NET_RX_SUCCESS;\n\nfree_skb:\n\tif (ret == NET_RX_SUCCESS)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\n\treturn ret;\n}\n\n \nint batadv_v_ogm_init(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_ogm2_packet *ogm_packet;\n\tunsigned char *ogm_buff;\n\tu32 random_seqno;\n\n\tbat_priv->bat_v.ogm_buff_len = BATADV_OGM2_HLEN;\n\togm_buff = kzalloc(bat_priv->bat_v.ogm_buff_len, GFP_ATOMIC);\n\tif (!ogm_buff)\n\t\treturn -ENOMEM;\n\n\tbat_priv->bat_v.ogm_buff = ogm_buff;\n\togm_packet = (struct batadv_ogm2_packet *)ogm_buff;\n\togm_packet->packet_type = BATADV_OGM2;\n\togm_packet->version = BATADV_COMPAT_VERSION;\n\togm_packet->ttl = BATADV_TTL;\n\togm_packet->flags = BATADV_NO_FLAGS;\n\togm_packet->throughput = htonl(BATADV_THROUGHPUT_MAX_VALUE);\n\n\t \n\tget_random_bytes(&random_seqno, sizeof(random_seqno));\n\tatomic_set(&bat_priv->bat_v.ogm_seqno, random_seqno);\n\tINIT_DELAYED_WORK(&bat_priv->bat_v.ogm_wq, batadv_v_ogm_send);\n\n\tmutex_init(&bat_priv->bat_v.ogm_buff_mutex);\n\n\treturn 0;\n}\n\n \nvoid batadv_v_ogm_free(struct batadv_priv *bat_priv)\n{\n\tcancel_delayed_work_sync(&bat_priv->bat_v.ogm_wq);\n\n\tmutex_lock(&bat_priv->bat_v.ogm_buff_mutex);\n\n\tkfree(bat_priv->bat_v.ogm_buff);\n\tbat_priv->bat_v.ogm_buff = NULL;\n\tbat_priv->bat_v.ogm_buff_len = 0;\n\n\tmutex_unlock(&bat_priv->bat_v.ogm_buff_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}