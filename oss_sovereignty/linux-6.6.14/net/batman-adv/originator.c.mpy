{
  "module_name": "originator.c",
  "hash_id": "f0701d3923c41458dffba22495f6d5462fbdf2f9987b4a7972f58405564c18a9",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/originator.c",
  "human_readable_source": "\n \n\n#include \"originator.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/container_of.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/workqueue.h>\n#include <net/sock.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"bat_algo.h\"\n#include \"distributed-arp-table.h\"\n#include \"fragmentation.h\"\n#include \"gateway_client.h\"\n#include \"hard-interface.h\"\n#include \"hash.h\"\n#include \"log.h\"\n#include \"multicast.h\"\n#include \"netlink.h\"\n#include \"network-coding.h\"\n#include \"routing.h\"\n#include \"soft-interface.h\"\n#include \"translation-table.h\"\n\n \nstatic struct lock_class_key batadv_orig_hash_lock_class_key;\n\n \nstruct batadv_orig_node *\nbatadv_orig_hash_find(struct batadv_priv *bat_priv, const void *data)\n{\n\tstruct batadv_hashtable *hash = bat_priv->orig_hash;\n\tstruct hlist_head *head;\n\tstruct batadv_orig_node *orig_node, *orig_node_tmp = NULL;\n\tint index;\n\n\tif (!hash)\n\t\treturn NULL;\n\n\tindex = batadv_choose_orig(data, hash->size);\n\thead = &hash->table[index];\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(orig_node, head, hash_entry) {\n\t\tif (!batadv_compare_eth(orig_node, data))\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&orig_node->refcount))\n\t\t\tcontinue;\n\n\t\torig_node_tmp = orig_node;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn orig_node_tmp;\n}\n\nstatic void batadv_purge_orig(struct work_struct *work);\n\n \nbool batadv_compare_orig(const struct hlist_node *node, const void *data2)\n{\n\tconst void *data1 = container_of(node, struct batadv_orig_node,\n\t\t\t\t\t hash_entry);\n\n\treturn batadv_compare_eth(data1, data2);\n}\n\n \nstruct batadv_orig_node_vlan *\nbatadv_orig_node_vlan_get(struct batadv_orig_node *orig_node,\n\t\t\t  unsigned short vid)\n{\n\tstruct batadv_orig_node_vlan *vlan = NULL, *tmp;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(tmp, &orig_node->vlan_list, list) {\n\t\tif (tmp->vid != vid)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&tmp->refcount))\n\t\t\tcontinue;\n\n\t\tvlan = tmp;\n\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn vlan;\n}\n\n \nstruct batadv_orig_node_vlan *\nbatadv_orig_node_vlan_new(struct batadv_orig_node *orig_node,\n\t\t\t  unsigned short vid)\n{\n\tstruct batadv_orig_node_vlan *vlan;\n\n\tspin_lock_bh(&orig_node->vlan_list_lock);\n\n\t \n\tvlan = batadv_orig_node_vlan_get(orig_node, vid);\n\tif (vlan)\n\t\tgoto out;\n\n\tvlan = kzalloc(sizeof(*vlan), GFP_ATOMIC);\n\tif (!vlan)\n\t\tgoto out;\n\n\tkref_init(&vlan->refcount);\n\tvlan->vid = vid;\n\n\tkref_get(&vlan->refcount);\n\thlist_add_head_rcu(&vlan->list, &orig_node->vlan_list);\n\nout:\n\tspin_unlock_bh(&orig_node->vlan_list_lock);\n\n\treturn vlan;\n}\n\n \nvoid batadv_orig_node_vlan_release(struct kref *ref)\n{\n\tstruct batadv_orig_node_vlan *orig_vlan;\n\n\torig_vlan = container_of(ref, struct batadv_orig_node_vlan, refcount);\n\n\tkfree_rcu(orig_vlan, rcu);\n}\n\n \nint batadv_originator_init(struct batadv_priv *bat_priv)\n{\n\tif (bat_priv->orig_hash)\n\t\treturn 0;\n\n\tbat_priv->orig_hash = batadv_hash_new(1024);\n\n\tif (!bat_priv->orig_hash)\n\t\tgoto err;\n\n\tbatadv_hash_set_lock_class(bat_priv->orig_hash,\n\t\t\t\t   &batadv_orig_hash_lock_class_key);\n\n\tINIT_DELAYED_WORK(&bat_priv->orig_work, batadv_purge_orig);\n\tqueue_delayed_work(batadv_event_workqueue,\n\t\t\t   &bat_priv->orig_work,\n\t\t\t   msecs_to_jiffies(BATADV_ORIG_WORK_PERIOD));\n\n\treturn 0;\n\nerr:\n\treturn -ENOMEM;\n}\n\n \nvoid batadv_neigh_ifinfo_release(struct kref *ref)\n{\n\tstruct batadv_neigh_ifinfo *neigh_ifinfo;\n\n\tneigh_ifinfo = container_of(ref, struct batadv_neigh_ifinfo, refcount);\n\n\tif (neigh_ifinfo->if_outgoing != BATADV_IF_DEFAULT)\n\t\tbatadv_hardif_put(neigh_ifinfo->if_outgoing);\n\n\tkfree_rcu(neigh_ifinfo, rcu);\n}\n\n \nvoid batadv_hardif_neigh_release(struct kref *ref)\n{\n\tstruct batadv_hardif_neigh_node *hardif_neigh;\n\n\thardif_neigh = container_of(ref, struct batadv_hardif_neigh_node,\n\t\t\t\t    refcount);\n\n\tspin_lock_bh(&hardif_neigh->if_incoming->neigh_list_lock);\n\thlist_del_init_rcu(&hardif_neigh->list);\n\tspin_unlock_bh(&hardif_neigh->if_incoming->neigh_list_lock);\n\n\tbatadv_hardif_put(hardif_neigh->if_incoming);\n\tkfree_rcu(hardif_neigh, rcu);\n}\n\n \nvoid batadv_neigh_node_release(struct kref *ref)\n{\n\tstruct hlist_node *node_tmp;\n\tstruct batadv_neigh_node *neigh_node;\n\tstruct batadv_neigh_ifinfo *neigh_ifinfo;\n\n\tneigh_node = container_of(ref, struct batadv_neigh_node, refcount);\n\n\thlist_for_each_entry_safe(neigh_ifinfo, node_tmp,\n\t\t\t\t  &neigh_node->ifinfo_list, list) {\n\t\tbatadv_neigh_ifinfo_put(neigh_ifinfo);\n\t}\n\n\tbatadv_hardif_neigh_put(neigh_node->hardif_neigh);\n\n\tbatadv_hardif_put(neigh_node->if_incoming);\n\n\tkfree_rcu(neigh_node, rcu);\n}\n\n \nstruct batadv_neigh_node *\nbatadv_orig_router_get(struct batadv_orig_node *orig_node,\n\t\t       const struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tstruct batadv_neigh_node *router = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(orig_ifinfo, &orig_node->ifinfo_list, list) {\n\t\tif (orig_ifinfo->if_outgoing != if_outgoing)\n\t\t\tcontinue;\n\n\t\trouter = rcu_dereference(orig_ifinfo->router);\n\t\tbreak;\n\t}\n\n\tif (router && !kref_get_unless_zero(&router->refcount))\n\t\trouter = NULL;\n\n\trcu_read_unlock();\n\treturn router;\n}\n\n \nstruct batadv_orig_ifinfo *\nbatadv_orig_ifinfo_get(struct batadv_orig_node *orig_node,\n\t\t       struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_orig_ifinfo *tmp, *orig_ifinfo = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(tmp, &orig_node->ifinfo_list,\n\t\t\t\t list) {\n\t\tif (tmp->if_outgoing != if_outgoing)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&tmp->refcount))\n\t\t\tcontinue;\n\n\t\torig_ifinfo = tmp;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn orig_ifinfo;\n}\n\n \nstruct batadv_orig_ifinfo *\nbatadv_orig_ifinfo_new(struct batadv_orig_node *orig_node,\n\t\t       struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tunsigned long reset_time;\n\n\tspin_lock_bh(&orig_node->neigh_list_lock);\n\n\torig_ifinfo = batadv_orig_ifinfo_get(orig_node, if_outgoing);\n\tif (orig_ifinfo)\n\t\tgoto out;\n\n\torig_ifinfo = kzalloc(sizeof(*orig_ifinfo), GFP_ATOMIC);\n\tif (!orig_ifinfo)\n\t\tgoto out;\n\n\tif (if_outgoing != BATADV_IF_DEFAULT)\n\t\tkref_get(&if_outgoing->refcount);\n\n\treset_time = jiffies - 1;\n\treset_time -= msecs_to_jiffies(BATADV_RESET_PROTECTION_MS);\n\torig_ifinfo->batman_seqno_reset = reset_time;\n\torig_ifinfo->if_outgoing = if_outgoing;\n\tINIT_HLIST_NODE(&orig_ifinfo->list);\n\tkref_init(&orig_ifinfo->refcount);\n\n\tkref_get(&orig_ifinfo->refcount);\n\thlist_add_head_rcu(&orig_ifinfo->list,\n\t\t\t   &orig_node->ifinfo_list);\nout:\n\tspin_unlock_bh(&orig_node->neigh_list_lock);\n\treturn orig_ifinfo;\n}\n\n \nstruct batadv_neigh_ifinfo *\nbatadv_neigh_ifinfo_get(struct batadv_neigh_node *neigh,\n\t\t\tstruct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_neigh_ifinfo *neigh_ifinfo = NULL,\n\t\t\t\t   *tmp_neigh_ifinfo;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(tmp_neigh_ifinfo, &neigh->ifinfo_list,\n\t\t\t\t list) {\n\t\tif (tmp_neigh_ifinfo->if_outgoing != if_outgoing)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&tmp_neigh_ifinfo->refcount))\n\t\t\tcontinue;\n\n\t\tneigh_ifinfo = tmp_neigh_ifinfo;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn neigh_ifinfo;\n}\n\n \nstruct batadv_neigh_ifinfo *\nbatadv_neigh_ifinfo_new(struct batadv_neigh_node *neigh,\n\t\t\tstruct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_neigh_ifinfo *neigh_ifinfo;\n\n\tspin_lock_bh(&neigh->ifinfo_lock);\n\n\tneigh_ifinfo = batadv_neigh_ifinfo_get(neigh, if_outgoing);\n\tif (neigh_ifinfo)\n\t\tgoto out;\n\n\tneigh_ifinfo = kzalloc(sizeof(*neigh_ifinfo), GFP_ATOMIC);\n\tif (!neigh_ifinfo)\n\t\tgoto out;\n\n\tif (if_outgoing)\n\t\tkref_get(&if_outgoing->refcount);\n\n\tINIT_HLIST_NODE(&neigh_ifinfo->list);\n\tkref_init(&neigh_ifinfo->refcount);\n\tneigh_ifinfo->if_outgoing = if_outgoing;\n\n\tkref_get(&neigh_ifinfo->refcount);\n\thlist_add_head_rcu(&neigh_ifinfo->list, &neigh->ifinfo_list);\n\nout:\n\tspin_unlock_bh(&neigh->ifinfo_lock);\n\n\treturn neigh_ifinfo;\n}\n\n \nstatic struct batadv_neigh_node *\nbatadv_neigh_node_get(const struct batadv_orig_node *orig_node,\n\t\t      const struct batadv_hard_iface *hard_iface,\n\t\t      const u8 *addr)\n{\n\tstruct batadv_neigh_node *tmp_neigh_node, *res = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(tmp_neigh_node, &orig_node->neigh_list, list) {\n\t\tif (!batadv_compare_eth(tmp_neigh_node->addr, addr))\n\t\t\tcontinue;\n\n\t\tif (tmp_neigh_node->if_incoming != hard_iface)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&tmp_neigh_node->refcount))\n\t\t\tcontinue;\n\n\t\tres = tmp_neigh_node;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn res;\n}\n\n \nstatic struct batadv_hardif_neigh_node *\nbatadv_hardif_neigh_create(struct batadv_hard_iface *hard_iface,\n\t\t\t   const u8 *neigh_addr,\n\t\t\t   struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\tstruct batadv_hardif_neigh_node *hardif_neigh;\n\n\tspin_lock_bh(&hard_iface->neigh_list_lock);\n\n\t \n\thardif_neigh = batadv_hardif_neigh_get(hard_iface, neigh_addr);\n\tif (hardif_neigh)\n\t\tgoto out;\n\n\thardif_neigh = kzalloc(sizeof(*hardif_neigh), GFP_ATOMIC);\n\tif (!hardif_neigh)\n\t\tgoto out;\n\n\tkref_get(&hard_iface->refcount);\n\tINIT_HLIST_NODE(&hardif_neigh->list);\n\tether_addr_copy(hardif_neigh->addr, neigh_addr);\n\tether_addr_copy(hardif_neigh->orig, orig_node->orig);\n\thardif_neigh->if_incoming = hard_iface;\n\thardif_neigh->last_seen = jiffies;\n\n\tkref_init(&hardif_neigh->refcount);\n\n\tif (bat_priv->algo_ops->neigh.hardif_init)\n\t\tbat_priv->algo_ops->neigh.hardif_init(hardif_neigh);\n\n\thlist_add_head_rcu(&hardif_neigh->list, &hard_iface->neigh_list);\n\nout:\n\tspin_unlock_bh(&hard_iface->neigh_list_lock);\n\treturn hardif_neigh;\n}\n\n \nstatic struct batadv_hardif_neigh_node *\nbatadv_hardif_neigh_get_or_create(struct batadv_hard_iface *hard_iface,\n\t\t\t\t  const u8 *neigh_addr,\n\t\t\t\t  struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_hardif_neigh_node *hardif_neigh;\n\n\t \n\thardif_neigh = batadv_hardif_neigh_get(hard_iface, neigh_addr);\n\tif (hardif_neigh)\n\t\treturn hardif_neigh;\n\n\treturn batadv_hardif_neigh_create(hard_iface, neigh_addr, orig_node);\n}\n\n \nstruct batadv_hardif_neigh_node *\nbatadv_hardif_neigh_get(const struct batadv_hard_iface *hard_iface,\n\t\t\tconst u8 *neigh_addr)\n{\n\tstruct batadv_hardif_neigh_node *tmp_hardif_neigh, *hardif_neigh = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(tmp_hardif_neigh,\n\t\t\t\t &hard_iface->neigh_list, list) {\n\t\tif (!batadv_compare_eth(tmp_hardif_neigh->addr, neigh_addr))\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&tmp_hardif_neigh->refcount))\n\t\t\tcontinue;\n\n\t\thardif_neigh = tmp_hardif_neigh;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn hardif_neigh;\n}\n\n \nstatic struct batadv_neigh_node *\nbatadv_neigh_node_create(struct batadv_orig_node *orig_node,\n\t\t\t struct batadv_hard_iface *hard_iface,\n\t\t\t const u8 *neigh_addr)\n{\n\tstruct batadv_neigh_node *neigh_node;\n\tstruct batadv_hardif_neigh_node *hardif_neigh = NULL;\n\n\tspin_lock_bh(&orig_node->neigh_list_lock);\n\n\tneigh_node = batadv_neigh_node_get(orig_node, hard_iface, neigh_addr);\n\tif (neigh_node)\n\t\tgoto out;\n\n\thardif_neigh = batadv_hardif_neigh_get_or_create(hard_iface,\n\t\t\t\t\t\t\t neigh_addr, orig_node);\n\tif (!hardif_neigh)\n\t\tgoto out;\n\n\tneigh_node = kzalloc(sizeof(*neigh_node), GFP_ATOMIC);\n\tif (!neigh_node)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&neigh_node->list);\n\tINIT_HLIST_HEAD(&neigh_node->ifinfo_list);\n\tspin_lock_init(&neigh_node->ifinfo_lock);\n\n\tkref_get(&hard_iface->refcount);\n\tether_addr_copy(neigh_node->addr, neigh_addr);\n\tneigh_node->if_incoming = hard_iface;\n\tneigh_node->orig_node = orig_node;\n\tneigh_node->last_seen = jiffies;\n\n\t \n\tkref_get(&hardif_neigh->refcount);\n\tneigh_node->hardif_neigh = hardif_neigh;\n\n\t \n\tkref_init(&neigh_node->refcount);\n\n\tkref_get(&neigh_node->refcount);\n\thlist_add_head_rcu(&neigh_node->list, &orig_node->neigh_list);\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, orig_node->bat_priv,\n\t\t   \"Creating new neighbor %pM for orig_node %pM on interface %s\\n\",\n\t\t   neigh_addr, orig_node->orig, hard_iface->net_dev->name);\n\nout:\n\tspin_unlock_bh(&orig_node->neigh_list_lock);\n\n\tbatadv_hardif_neigh_put(hardif_neigh);\n\treturn neigh_node;\n}\n\n \nstruct batadv_neigh_node *\nbatadv_neigh_node_get_or_create(struct batadv_orig_node *orig_node,\n\t\t\t\tstruct batadv_hard_iface *hard_iface,\n\t\t\t\tconst u8 *neigh_addr)\n{\n\tstruct batadv_neigh_node *neigh_node;\n\n\t \n\tneigh_node = batadv_neigh_node_get(orig_node, hard_iface, neigh_addr);\n\tif (neigh_node)\n\t\treturn neigh_node;\n\n\treturn batadv_neigh_node_create(orig_node, hard_iface, neigh_addr);\n}\n\n \nint batadv_hardif_neigh_dump(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct net_device *soft_iface;\n\tstruct net_device *hard_iface = NULL;\n\tstruct batadv_hard_iface *hardif = BATADV_IF_DEFAULT;\n\tstruct batadv_priv *bat_priv;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tint ret;\n\tint ifindex, hard_ifindex;\n\n\tifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);\n\tif (!ifindex)\n\t\treturn -EINVAL;\n\n\tsoft_iface = dev_get_by_index(net, ifindex);\n\tif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tbat_priv = netdev_priv(soft_iface);\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\thard_ifindex = batadv_netlink_get_ifindex(cb->nlh,\n\t\t\t\t\t\t  BATADV_ATTR_HARD_IFINDEX);\n\tif (hard_ifindex) {\n\t\thard_iface = dev_get_by_index(net, hard_ifindex);\n\t\tif (hard_iface)\n\t\t\thardif = batadv_hardif_get_by_netdev(hard_iface);\n\n\t\tif (!hardif) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (hardif->soft_iface != soft_iface) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!bat_priv->algo_ops->neigh.dump) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tbat_priv->algo_ops->neigh.dump(msg, cb, bat_priv, hardif);\n\n\tret = msg->len;\n\n out:\n\tbatadv_hardif_put(hardif);\n\tdev_put(hard_iface);\n\tbatadv_hardif_put(primary_if);\n\tdev_put(soft_iface);\n\n\treturn ret;\n}\n\n \nvoid batadv_orig_ifinfo_release(struct kref *ref)\n{\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tstruct batadv_neigh_node *router;\n\n\torig_ifinfo = container_of(ref, struct batadv_orig_ifinfo, refcount);\n\n\tif (orig_ifinfo->if_outgoing != BATADV_IF_DEFAULT)\n\t\tbatadv_hardif_put(orig_ifinfo->if_outgoing);\n\n\t \n\trouter = rcu_dereference_protected(orig_ifinfo->router, true);\n\tbatadv_neigh_node_put(router);\n\n\tkfree_rcu(orig_ifinfo, rcu);\n}\n\n \nstatic void batadv_orig_node_free_rcu(struct rcu_head *rcu)\n{\n\tstruct batadv_orig_node *orig_node;\n\n\torig_node = container_of(rcu, struct batadv_orig_node, rcu);\n\n\tbatadv_mcast_purge_orig(orig_node);\n\n\tbatadv_frag_purge_orig(orig_node, NULL);\n\n\tkfree(orig_node->tt_buff);\n\tkfree(orig_node);\n}\n\n \nvoid batadv_orig_node_release(struct kref *ref)\n{\n\tstruct hlist_node *node_tmp;\n\tstruct batadv_neigh_node *neigh_node;\n\tstruct batadv_orig_node *orig_node;\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tstruct batadv_orig_node_vlan *vlan;\n\tstruct batadv_orig_ifinfo *last_candidate;\n\n\torig_node = container_of(ref, struct batadv_orig_node, refcount);\n\n\tspin_lock_bh(&orig_node->neigh_list_lock);\n\n\t \n\thlist_for_each_entry_safe(neigh_node, node_tmp,\n\t\t\t\t  &orig_node->neigh_list, list) {\n\t\thlist_del_rcu(&neigh_node->list);\n\t\tbatadv_neigh_node_put(neigh_node);\n\t}\n\n\thlist_for_each_entry_safe(orig_ifinfo, node_tmp,\n\t\t\t\t  &orig_node->ifinfo_list, list) {\n\t\thlist_del_rcu(&orig_ifinfo->list);\n\t\tbatadv_orig_ifinfo_put(orig_ifinfo);\n\t}\n\n\tlast_candidate = orig_node->last_bonding_candidate;\n\torig_node->last_bonding_candidate = NULL;\n\tspin_unlock_bh(&orig_node->neigh_list_lock);\n\n\tbatadv_orig_ifinfo_put(last_candidate);\n\n\tspin_lock_bh(&orig_node->vlan_list_lock);\n\thlist_for_each_entry_safe(vlan, node_tmp, &orig_node->vlan_list, list) {\n\t\thlist_del_rcu(&vlan->list);\n\t\tbatadv_orig_node_vlan_put(vlan);\n\t}\n\tspin_unlock_bh(&orig_node->vlan_list_lock);\n\n\t \n\tbatadv_nc_purge_orig(orig_node->bat_priv, orig_node, NULL);\n\n\tcall_rcu(&orig_node->rcu, batadv_orig_node_free_rcu);\n}\n\n \nvoid batadv_originator_free(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_hashtable *hash = bat_priv->orig_hash;\n\tstruct hlist_node *node_tmp;\n\tstruct hlist_head *head;\n\tspinlock_t *list_lock;  \n\tstruct batadv_orig_node *orig_node;\n\tu32 i;\n\n\tif (!hash)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&bat_priv->orig_work);\n\n\tbat_priv->orig_hash = NULL;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\t\tlist_lock = &hash->list_locks[i];\n\n\t\tspin_lock_bh(list_lock);\n\t\thlist_for_each_entry_safe(orig_node, node_tmp,\n\t\t\t\t\t  head, hash_entry) {\n\t\t\thlist_del_rcu(&orig_node->hash_entry);\n\t\t\tbatadv_orig_node_put(orig_node);\n\t\t}\n\t\tspin_unlock_bh(list_lock);\n\t}\n\n\tbatadv_hash_destroy(hash);\n}\n\n \nstruct batadv_orig_node *batadv_orig_node_new(struct batadv_priv *bat_priv,\n\t\t\t\t\t      const u8 *addr)\n{\n\tstruct batadv_orig_node *orig_node;\n\tstruct batadv_orig_node_vlan *vlan;\n\tunsigned long reset_time;\n\tint i;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Creating new originator: %pM\\n\", addr);\n\n\torig_node = kzalloc(sizeof(*orig_node), GFP_ATOMIC);\n\tif (!orig_node)\n\t\treturn NULL;\n\n\tINIT_HLIST_HEAD(&orig_node->neigh_list);\n\tINIT_HLIST_HEAD(&orig_node->vlan_list);\n\tINIT_HLIST_HEAD(&orig_node->ifinfo_list);\n\tspin_lock_init(&orig_node->bcast_seqno_lock);\n\tspin_lock_init(&orig_node->neigh_list_lock);\n\tspin_lock_init(&orig_node->tt_buff_lock);\n\tspin_lock_init(&orig_node->tt_lock);\n\tspin_lock_init(&orig_node->vlan_list_lock);\n\n\tbatadv_nc_init_orig(orig_node);\n\n\t \n\tkref_init(&orig_node->refcount);\n\n\torig_node->bat_priv = bat_priv;\n\tether_addr_copy(orig_node->orig, addr);\n\tbatadv_dat_init_orig_node_addr(orig_node);\n\tatomic_set(&orig_node->last_ttvn, 0);\n\torig_node->tt_buff = NULL;\n\torig_node->tt_buff_len = 0;\n\torig_node->last_seen = jiffies;\n\treset_time = jiffies - 1 - msecs_to_jiffies(BATADV_RESET_PROTECTION_MS);\n\torig_node->bcast_seqno_reset = reset_time;\n\n#ifdef CONFIG_BATMAN_ADV_MCAST\n\torig_node->mcast_flags = BATADV_MCAST_WANT_NO_RTR4;\n\torig_node->mcast_flags |= BATADV_MCAST_WANT_NO_RTR6;\n\tINIT_HLIST_NODE(&orig_node->mcast_want_all_unsnoopables_node);\n\tINIT_HLIST_NODE(&orig_node->mcast_want_all_ipv4_node);\n\tINIT_HLIST_NODE(&orig_node->mcast_want_all_ipv6_node);\n\tspin_lock_init(&orig_node->mcast_handler_lock);\n#endif\n\n\t \n\tvlan = batadv_orig_node_vlan_new(orig_node, BATADV_NO_FLAGS);\n\tif (!vlan)\n\t\tgoto free_orig_node;\n\t \n\tbatadv_orig_node_vlan_put(vlan);\n\n\tfor (i = 0; i < BATADV_FRAG_BUFFER_COUNT; i++) {\n\t\tINIT_HLIST_HEAD(&orig_node->fragments[i].fragment_list);\n\t\tspin_lock_init(&orig_node->fragments[i].lock);\n\t\torig_node->fragments[i].size = 0;\n\t}\n\n\treturn orig_node;\nfree_orig_node:\n\tkfree(orig_node);\n\treturn NULL;\n}\n\n \nstatic void\nbatadv_purge_neigh_ifinfo(struct batadv_priv *bat_priv,\n\t\t\t  struct batadv_neigh_node *neigh)\n{\n\tstruct batadv_neigh_ifinfo *neigh_ifinfo;\n\tstruct batadv_hard_iface *if_outgoing;\n\tstruct hlist_node *node_tmp;\n\n\tspin_lock_bh(&neigh->ifinfo_lock);\n\n\t \n\thlist_for_each_entry_safe(neigh_ifinfo, node_tmp,\n\t\t\t\t  &neigh->ifinfo_list, list) {\n\t\tif_outgoing = neigh_ifinfo->if_outgoing;\n\n\t\t \n\t\tif (if_outgoing == BATADV_IF_DEFAULT)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (if_outgoing->if_status != BATADV_IF_INACTIVE &&\n\t\t    if_outgoing->if_status != BATADV_IF_NOT_IN_USE &&\n\t\t    if_outgoing->if_status != BATADV_IF_TO_BE_REMOVED)\n\t\t\tcontinue;\n\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"neighbor/ifinfo purge: neighbor %pM, iface: %s\\n\",\n\t\t\t   neigh->addr, if_outgoing->net_dev->name);\n\n\t\thlist_del_rcu(&neigh_ifinfo->list);\n\t\tbatadv_neigh_ifinfo_put(neigh_ifinfo);\n\t}\n\n\tspin_unlock_bh(&neigh->ifinfo_lock);\n}\n\n \nstatic bool\nbatadv_purge_orig_ifinfo(struct batadv_priv *bat_priv,\n\t\t\t struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tstruct batadv_hard_iface *if_outgoing;\n\tstruct hlist_node *node_tmp;\n\tbool ifinfo_purged = false;\n\n\tspin_lock_bh(&orig_node->neigh_list_lock);\n\n\t \n\thlist_for_each_entry_safe(orig_ifinfo, node_tmp,\n\t\t\t\t  &orig_node->ifinfo_list, list) {\n\t\tif_outgoing = orig_ifinfo->if_outgoing;\n\n\t\t \n\t\tif (if_outgoing == BATADV_IF_DEFAULT)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (if_outgoing->if_status != BATADV_IF_INACTIVE &&\n\t\t    if_outgoing->if_status != BATADV_IF_NOT_IN_USE &&\n\t\t    if_outgoing->if_status != BATADV_IF_TO_BE_REMOVED)\n\t\t\tcontinue;\n\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"router/ifinfo purge: originator %pM, iface: %s\\n\",\n\t\t\t   orig_node->orig, if_outgoing->net_dev->name);\n\n\t\tifinfo_purged = true;\n\n\t\thlist_del_rcu(&orig_ifinfo->list);\n\t\tbatadv_orig_ifinfo_put(orig_ifinfo);\n\t\tif (orig_node->last_bonding_candidate == orig_ifinfo) {\n\t\t\torig_node->last_bonding_candidate = NULL;\n\t\t\tbatadv_orig_ifinfo_put(orig_ifinfo);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&orig_node->neigh_list_lock);\n\n\treturn ifinfo_purged;\n}\n\n \nstatic bool\nbatadv_purge_orig_neighbors(struct batadv_priv *bat_priv,\n\t\t\t    struct batadv_orig_node *orig_node)\n{\n\tstruct hlist_node *node_tmp;\n\tstruct batadv_neigh_node *neigh_node;\n\tbool neigh_purged = false;\n\tunsigned long last_seen;\n\tstruct batadv_hard_iface *if_incoming;\n\n\tspin_lock_bh(&orig_node->neigh_list_lock);\n\n\t \n\thlist_for_each_entry_safe(neigh_node, node_tmp,\n\t\t\t\t  &orig_node->neigh_list, list) {\n\t\tlast_seen = neigh_node->last_seen;\n\t\tif_incoming = neigh_node->if_incoming;\n\n\t\tif (batadv_has_timed_out(last_seen, BATADV_PURGE_TIMEOUT) ||\n\t\t    if_incoming->if_status == BATADV_IF_INACTIVE ||\n\t\t    if_incoming->if_status == BATADV_IF_NOT_IN_USE ||\n\t\t    if_incoming->if_status == BATADV_IF_TO_BE_REMOVED) {\n\t\t\tif (if_incoming->if_status == BATADV_IF_INACTIVE ||\n\t\t\t    if_incoming->if_status == BATADV_IF_NOT_IN_USE ||\n\t\t\t    if_incoming->if_status == BATADV_IF_TO_BE_REMOVED)\n\t\t\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t\t\t   \"neighbor purge: originator %pM, neighbor: %pM, iface: %s\\n\",\n\t\t\t\t\t   orig_node->orig, neigh_node->addr,\n\t\t\t\t\t   if_incoming->net_dev->name);\n\t\t\telse\n\t\t\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t\t\t   \"neighbor timeout: originator %pM, neighbor: %pM, last_seen: %u\\n\",\n\t\t\t\t\t   orig_node->orig, neigh_node->addr,\n\t\t\t\t\t   jiffies_to_msecs(last_seen));\n\n\t\t\tneigh_purged = true;\n\n\t\t\thlist_del_rcu(&neigh_node->list);\n\t\t\tbatadv_neigh_node_put(neigh_node);\n\t\t} else {\n\t\t\t \n\t\t\tbatadv_purge_neigh_ifinfo(bat_priv, neigh_node);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&orig_node->neigh_list_lock);\n\treturn neigh_purged;\n}\n\n \nstatic struct batadv_neigh_node *\nbatadv_find_best_neighbor(struct batadv_priv *bat_priv,\n\t\t\t  struct batadv_orig_node *orig_node,\n\t\t\t  struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_neigh_node *best = NULL, *neigh;\n\tstruct batadv_algo_ops *bao = bat_priv->algo_ops;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(neigh, &orig_node->neigh_list, list) {\n\t\tif (best && (bao->neigh.cmp(neigh, if_outgoing, best,\n\t\t\t\t\t    if_outgoing) <= 0))\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&neigh->refcount))\n\t\t\tcontinue;\n\n\t\tbatadv_neigh_node_put(best);\n\n\t\tbest = neigh;\n\t}\n\trcu_read_unlock();\n\n\treturn best;\n}\n\n \nstatic bool batadv_purge_orig_node(struct batadv_priv *bat_priv,\n\t\t\t\t   struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_neigh_node *best_neigh_node;\n\tstruct batadv_hard_iface *hard_iface;\n\tbool changed_ifinfo, changed_neigh;\n\n\tif (batadv_has_timed_out(orig_node->last_seen,\n\t\t\t\t 2 * BATADV_PURGE_TIMEOUT)) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Originator timeout: originator %pM, last_seen %u\\n\",\n\t\t\t   orig_node->orig,\n\t\t\t   jiffies_to_msecs(orig_node->last_seen));\n\t\treturn true;\n\t}\n\tchanged_ifinfo = batadv_purge_orig_ifinfo(bat_priv, orig_node);\n\tchanged_neigh = batadv_purge_orig_neighbors(bat_priv, orig_node);\n\n\tif (!changed_ifinfo && !changed_neigh)\n\t\treturn false;\n\n\t \n\tbest_neigh_node = batadv_find_best_neighbor(bat_priv, orig_node,\n\t\t\t\t\t\t    BATADV_IF_DEFAULT);\n\tbatadv_update_route(bat_priv, orig_node, BATADV_IF_DEFAULT,\n\t\t\t    best_neigh_node);\n\tbatadv_neigh_node_put(best_neigh_node);\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->if_status != BATADV_IF_ACTIVE)\n\t\t\tcontinue;\n\n\t\tif (hard_iface->soft_iface != bat_priv->soft_iface)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&hard_iface->refcount))\n\t\t\tcontinue;\n\n\t\tbest_neigh_node = batadv_find_best_neighbor(bat_priv,\n\t\t\t\t\t\t\t    orig_node,\n\t\t\t\t\t\t\t    hard_iface);\n\t\tbatadv_update_route(bat_priv, orig_node, hard_iface,\n\t\t\t\t    best_neigh_node);\n\t\tbatadv_neigh_node_put(best_neigh_node);\n\n\t\tbatadv_hardif_put(hard_iface);\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}\n\n \nvoid batadv_purge_orig_ref(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_hashtable *hash = bat_priv->orig_hash;\n\tstruct hlist_node *node_tmp;\n\tstruct hlist_head *head;\n\tspinlock_t *list_lock;  \n\tstruct batadv_orig_node *orig_node;\n\tu32 i;\n\n\tif (!hash)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\t\tlist_lock = &hash->list_locks[i];\n\n\t\tspin_lock_bh(list_lock);\n\t\thlist_for_each_entry_safe(orig_node, node_tmp,\n\t\t\t\t\t  head, hash_entry) {\n\t\t\tif (batadv_purge_orig_node(bat_priv, orig_node)) {\n\t\t\t\tbatadv_gw_node_delete(bat_priv, orig_node);\n\t\t\t\thlist_del_rcu(&orig_node->hash_entry);\n\t\t\t\tbatadv_tt_global_del_orig(orig_node->bat_priv,\n\t\t\t\t\t\t\t  orig_node, -1,\n\t\t\t\t\t\t\t  \"originator timed out\");\n\t\t\t\tbatadv_orig_node_put(orig_node);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbatadv_frag_purge_orig(orig_node,\n\t\t\t\t\t       batadv_frag_check_entry);\n\t\t}\n\t\tspin_unlock_bh(list_lock);\n\t}\n\n\tbatadv_gw_election(bat_priv);\n}\n\nstatic void batadv_purge_orig(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work;\n\tstruct batadv_priv *bat_priv;\n\n\tdelayed_work = to_delayed_work(work);\n\tbat_priv = container_of(delayed_work, struct batadv_priv, orig_work);\n\tbatadv_purge_orig_ref(bat_priv);\n\tqueue_delayed_work(batadv_event_workqueue,\n\t\t\t   &bat_priv->orig_work,\n\t\t\t   msecs_to_jiffies(BATADV_ORIG_WORK_PERIOD));\n}\n\n \nint batadv_orig_dump(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct net_device *soft_iface;\n\tstruct net_device *hard_iface = NULL;\n\tstruct batadv_hard_iface *hardif = BATADV_IF_DEFAULT;\n\tstruct batadv_priv *bat_priv;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tint ret;\n\tint ifindex, hard_ifindex;\n\n\tifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);\n\tif (!ifindex)\n\t\treturn -EINVAL;\n\n\tsoft_iface = dev_get_by_index(net, ifindex);\n\tif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tbat_priv = netdev_priv(soft_iface);\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\thard_ifindex = batadv_netlink_get_ifindex(cb->nlh,\n\t\t\t\t\t\t  BATADV_ATTR_HARD_IFINDEX);\n\tif (hard_ifindex) {\n\t\thard_iface = dev_get_by_index(net, hard_ifindex);\n\t\tif (hard_iface)\n\t\t\thardif = batadv_hardif_get_by_netdev(hard_iface);\n\n\t\tif (!hardif) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (hardif->soft_iface != soft_iface) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!bat_priv->algo_ops->orig.dump) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tbat_priv->algo_ops->orig.dump(msg, cb, bat_priv, hardif);\n\n\tret = msg->len;\n\n out:\n\tbatadv_hardif_put(hardif);\n\tdev_put(hard_iface);\n\tbatadv_hardif_put(primary_if);\n\tdev_put(soft_iface);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}