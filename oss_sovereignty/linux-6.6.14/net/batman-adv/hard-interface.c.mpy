{
  "module_name": "hard-interface.c",
  "hash_id": "ea66141f1d610695338f411812438cd17ff97b58f0fe6332dd77ae905b1b92a8",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/hard-interface.c",
  "human_readable_source": "\n \n\n#include \"hard-interface.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/byteorder/generic.h>\n#include <linux/compiler.h>\n#include <linux/container_of.h>\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/if.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/kref.h>\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/minmax.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/printk.h>\n#include <linux/rculist.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <net/net_namespace.h>\n#include <net/rtnetlink.h>\n#include <uapi/linux/batadv_packet.h>\n\n#include \"bat_v.h\"\n#include \"bridge_loop_avoidance.h\"\n#include \"distributed-arp-table.h\"\n#include \"gateway_client.h\"\n#include \"log.h\"\n#include \"originator.h\"\n#include \"send.h\"\n#include \"soft-interface.h\"\n#include \"translation-table.h\"\n\n \nvoid batadv_hardif_release(struct kref *ref)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\n\thard_iface = container_of(ref, struct batadv_hard_iface, refcount);\n\tdev_put(hard_iface->net_dev);\n\n\tkfree_rcu(hard_iface, rcu);\n}\n\n \nstruct batadv_hard_iface *\nbatadv_hardif_get_by_netdev(const struct net_device *net_dev)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->net_dev == net_dev &&\n\t\t    kref_get_unless_zero(&hard_iface->refcount))\n\t\t\tgoto out;\n\t}\n\n\thard_iface = NULL;\n\nout:\n\trcu_read_unlock();\n\treturn hard_iface;\n}\n\n \nstatic struct net *batadv_getlink_net(const struct net_device *netdev,\n\t\t\t\t      struct net *fallback_net)\n{\n\tif (!netdev->rtnl_link_ops)\n\t\treturn fallback_net;\n\n\tif (!netdev->rtnl_link_ops->get_link_net)\n\t\treturn fallback_net;\n\n\treturn netdev->rtnl_link_ops->get_link_net(netdev);\n}\n\n \nstatic bool batadv_mutual_parents(const struct net_device *dev1,\n\t\t\t\t  struct net *net1,\n\t\t\t\t  const struct net_device *dev2,\n\t\t\t\t  struct net *net2)\n{\n\tint dev1_parent_iflink = dev_get_iflink(dev1);\n\tint dev2_parent_iflink = dev_get_iflink(dev2);\n\tconst struct net *dev1_parent_net;\n\tconst struct net *dev2_parent_net;\n\n\tdev1_parent_net = batadv_getlink_net(dev1, net1);\n\tdev2_parent_net = batadv_getlink_net(dev2, net2);\n\n\tif (!dev1_parent_iflink || !dev2_parent_iflink)\n\t\treturn false;\n\n\treturn (dev1_parent_iflink == dev2->ifindex) &&\n\t       (dev2_parent_iflink == dev1->ifindex) &&\n\t       net_eq(dev1_parent_net, net2) &&\n\t       net_eq(dev2_parent_net, net1);\n}\n\n \nstatic bool batadv_is_on_batman_iface(const struct net_device *net_dev)\n{\n\tstruct net *net = dev_net(net_dev);\n\tstruct net_device *parent_dev;\n\tstruct net *parent_net;\n\tint iflink;\n\tbool ret;\n\n\t \n\tif (batadv_softif_is_valid(net_dev))\n\t\treturn true;\n\n\tiflink = dev_get_iflink(net_dev);\n\tif (iflink == 0)\n\t\treturn false;\n\n\tparent_net = batadv_getlink_net(net_dev, net);\n\n\t \n\tif (net == parent_net && iflink == net_dev->ifindex)\n\t\treturn false;\n\n\t \n\tparent_dev = __dev_get_by_index((struct net *)parent_net, iflink);\n\tif (!parent_dev) {\n\t\tpr_warn(\"Cannot find parent device. Skipping batadv-on-batadv check for %s\\n\",\n\t\t\tnet_dev->name);\n\t\treturn false;\n\t}\n\n\tif (batadv_mutual_parents(net_dev, net, parent_dev, parent_net))\n\t\treturn false;\n\n\tret = batadv_is_on_batman_iface(parent_dev);\n\n\treturn ret;\n}\n\nstatic bool batadv_is_valid_iface(const struct net_device *net_dev)\n{\n\tif (net_dev->flags & IFF_LOOPBACK)\n\t\treturn false;\n\n\tif (net_dev->type != ARPHRD_ETHER)\n\t\treturn false;\n\n\tif (net_dev->addr_len != ETH_ALEN)\n\t\treturn false;\n\n\t \n\tif (batadv_is_on_batman_iface(net_dev))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic struct net_device *batadv_get_real_netdevice(struct net_device *netdev)\n{\n\tstruct batadv_hard_iface *hard_iface = NULL;\n\tstruct net_device *real_netdev = NULL;\n\tstruct net *real_net;\n\tstruct net *net;\n\tint iflink;\n\n\tASSERT_RTNL();\n\n\tif (!netdev)\n\t\treturn NULL;\n\n\tiflink = dev_get_iflink(netdev);\n\tif (iflink == 0) {\n\t\tdev_hold(netdev);\n\t\treturn netdev;\n\t}\n\n\thard_iface = batadv_hardif_get_by_netdev(netdev);\n\tif (!hard_iface || !hard_iface->soft_iface)\n\t\tgoto out;\n\n\tnet = dev_net(hard_iface->soft_iface);\n\treal_net = batadv_getlink_net(netdev, net);\n\n\t \n\tif (net == real_net && netdev->ifindex == iflink) {\n\t\treal_netdev = netdev;\n\t\tdev_hold(real_netdev);\n\t\tgoto out;\n\t}\n\n\treal_netdev = dev_get_by_index(real_net, iflink);\n\nout:\n\tbatadv_hardif_put(hard_iface);\n\treturn real_netdev;\n}\n\n \nstruct net_device *batadv_get_real_netdev(struct net_device *net_device)\n{\n\tstruct net_device *real_netdev;\n\n\trtnl_lock();\n\treal_netdev = batadv_get_real_netdevice(net_device);\n\trtnl_unlock();\n\n\treturn real_netdev;\n}\n\n \nstatic bool batadv_is_wext_netdev(struct net_device *net_device)\n{\n\tif (!net_device)\n\t\treturn false;\n\n#ifdef CONFIG_WIRELESS_EXT\n\t \n\tif (net_device->wireless_handlers)\n\t\treturn true;\n#endif\n\n\treturn false;\n}\n\n \nstatic bool batadv_is_cfg80211_netdev(struct net_device *net_device)\n{\n\tif (!net_device)\n\t\treturn false;\n\n#if IS_ENABLED(CONFIG_CFG80211)\n\t \n\tif (net_device->ieee80211_ptr)\n\t\treturn true;\n#endif\n\n\treturn false;\n}\n\n \nstatic u32 batadv_wifi_flags_evaluate(struct net_device *net_device)\n{\n\tu32 wifi_flags = 0;\n\tstruct net_device *real_netdev;\n\n\tif (batadv_is_wext_netdev(net_device))\n\t\twifi_flags |= BATADV_HARDIF_WIFI_WEXT_DIRECT;\n\n\tif (batadv_is_cfg80211_netdev(net_device))\n\t\twifi_flags |= BATADV_HARDIF_WIFI_CFG80211_DIRECT;\n\n\treal_netdev = batadv_get_real_netdevice(net_device);\n\tif (!real_netdev)\n\t\treturn wifi_flags;\n\n\tif (real_netdev == net_device)\n\t\tgoto out;\n\n\tif (batadv_is_wext_netdev(real_netdev))\n\t\twifi_flags |= BATADV_HARDIF_WIFI_WEXT_INDIRECT;\n\n\tif (batadv_is_cfg80211_netdev(real_netdev))\n\t\twifi_flags |= BATADV_HARDIF_WIFI_CFG80211_INDIRECT;\n\nout:\n\tdev_put(real_netdev);\n\treturn wifi_flags;\n}\n\n \nbool batadv_is_cfg80211_hardif(struct batadv_hard_iface *hard_iface)\n{\n\tu32 allowed_flags = 0;\n\n\tallowed_flags |= BATADV_HARDIF_WIFI_CFG80211_DIRECT;\n\tallowed_flags |= BATADV_HARDIF_WIFI_CFG80211_INDIRECT;\n\n\treturn !!(hard_iface->wifi_flags & allowed_flags);\n}\n\n \nbool batadv_is_wifi_hardif(struct batadv_hard_iface *hard_iface)\n{\n\tif (!hard_iface)\n\t\treturn false;\n\n\treturn hard_iface->wifi_flags != 0;\n}\n\n \nint batadv_hardif_no_broadcast(struct batadv_hard_iface *if_outgoing,\n\t\t\t       u8 *orig_addr, u8 *orig_neigh)\n{\n\tstruct batadv_hardif_neigh_node *hardif_neigh;\n\tstruct hlist_node *first;\n\tint ret = BATADV_HARDIF_BCAST_OK;\n\n\trcu_read_lock();\n\n\t \n\tfirst = rcu_dereference(hlist_first_rcu(&if_outgoing->neigh_list));\n\tif (!first) {\n\t\tret = BATADV_HARDIF_BCAST_NORECIPIENT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rcu_dereference(hlist_next_rcu(first)))\n\t\tgoto out;\n\n\thardif_neigh = hlist_entry(first, struct batadv_hardif_neigh_node,\n\t\t\t\t   list);\n\n\t \n\tif (orig_addr && batadv_compare_eth(hardif_neigh->orig, orig_addr)) {\n\t\tret = BATADV_HARDIF_BCAST_DUPORIG;\n\t \n\t} else if (orig_neigh &&\n\t\t   batadv_compare_eth(hardif_neigh->orig, orig_neigh)) {\n\t\tret = BATADV_HARDIF_BCAST_DUPFWD;\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct batadv_hard_iface *\nbatadv_hardif_get_active(const struct net_device *soft_iface)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->soft_iface != soft_iface)\n\t\t\tcontinue;\n\n\t\tif (hard_iface->if_status == BATADV_IF_ACTIVE &&\n\t\t    kref_get_unless_zero(&hard_iface->refcount))\n\t\t\tgoto out;\n\t}\n\n\thard_iface = NULL;\n\nout:\n\trcu_read_unlock();\n\treturn hard_iface;\n}\n\nstatic void batadv_primary_if_update_addr(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_hard_iface *oldif)\n{\n\tstruct batadv_hard_iface *primary_if;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\tgoto out;\n\n\tbatadv_dat_init_own_addr(bat_priv, primary_if);\n\tbatadv_bla_update_orig_address(bat_priv, primary_if, oldif);\nout:\n\tbatadv_hardif_put(primary_if);\n}\n\nstatic void batadv_primary_if_select(struct batadv_priv *bat_priv,\n\t\t\t\t     struct batadv_hard_iface *new_hard_iface)\n{\n\tstruct batadv_hard_iface *curr_hard_iface;\n\n\tASSERT_RTNL();\n\n\tif (new_hard_iface)\n\t\tkref_get(&new_hard_iface->refcount);\n\n\tcurr_hard_iface = rcu_replace_pointer(bat_priv->primary_if,\n\t\t\t\t\t      new_hard_iface, 1);\n\n\tif (!new_hard_iface)\n\t\tgoto out;\n\n\tbat_priv->algo_ops->iface.primary_set(new_hard_iface);\n\tbatadv_primary_if_update_addr(bat_priv, curr_hard_iface);\n\nout:\n\tbatadv_hardif_put(curr_hard_iface);\n}\n\nstatic bool\nbatadv_hardif_is_iface_up(const struct batadv_hard_iface *hard_iface)\n{\n\tif (hard_iface->net_dev->flags & IFF_UP)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void batadv_check_known_mac_addr(const struct net_device *net_dev)\n{\n\tconst struct batadv_hard_iface *hard_iface;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->if_status != BATADV_IF_ACTIVE &&\n\t\t    hard_iface->if_status != BATADV_IF_TO_BE_ACTIVATED)\n\t\t\tcontinue;\n\n\t\tif (hard_iface->net_dev == net_dev)\n\t\t\tcontinue;\n\n\t\tif (!batadv_compare_eth(hard_iface->net_dev->dev_addr,\n\t\t\t\t\tnet_dev->dev_addr))\n\t\t\tcontinue;\n\n\t\tpr_warn(\"The newly added mac address (%pM) already exists on: %s\\n\",\n\t\t\tnet_dev->dev_addr, hard_iface->net_dev->name);\n\t\tpr_warn(\"It is strongly recommended to keep mac addresses unique to avoid problems!\\n\");\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void batadv_hardif_recalc_extra_skbroom(struct net_device *soft_iface)\n{\n\tconst struct batadv_hard_iface *hard_iface;\n\tunsigned short lower_header_len = ETH_HLEN;\n\tunsigned short lower_headroom = 0;\n\tunsigned short lower_tailroom = 0;\n\tunsigned short needed_headroom;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->if_status == BATADV_IF_NOT_IN_USE)\n\t\t\tcontinue;\n\n\t\tif (hard_iface->soft_iface != soft_iface)\n\t\t\tcontinue;\n\n\t\tlower_header_len = max_t(unsigned short, lower_header_len,\n\t\t\t\t\t hard_iface->net_dev->hard_header_len);\n\n\t\tlower_headroom = max_t(unsigned short, lower_headroom,\n\t\t\t\t       hard_iface->net_dev->needed_headroom);\n\n\t\tlower_tailroom = max_t(unsigned short, lower_tailroom,\n\t\t\t\t       hard_iface->net_dev->needed_tailroom);\n\t}\n\trcu_read_unlock();\n\n\tneeded_headroom = lower_headroom + (lower_header_len - ETH_HLEN);\n\tneeded_headroom += batadv_max_header_len();\n\n\t \n\tneeded_headroom += sizeof(struct batadv_frag_packet);\n\n\tsoft_iface->needed_headroom = needed_headroom;\n\tsoft_iface->needed_tailroom = lower_tailroom;\n}\n\n \nint batadv_hardif_min_mtu(struct net_device *soft_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\n\tconst struct batadv_hard_iface *hard_iface;\n\tint min_mtu = INT_MAX;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->if_status != BATADV_IF_ACTIVE &&\n\t\t    hard_iface->if_status != BATADV_IF_TO_BE_ACTIVATED)\n\t\t\tcontinue;\n\n\t\tif (hard_iface->soft_iface != soft_iface)\n\t\t\tcontinue;\n\n\t\tmin_mtu = min_t(int, hard_iface->net_dev->mtu, min_mtu);\n\t}\n\trcu_read_unlock();\n\n\tif (atomic_read(&bat_priv->fragmentation) == 0)\n\t\tgoto out;\n\n\t \n\tmin_mtu = min_t(int, min_mtu, BATADV_FRAG_MAX_FRAG_SIZE);\n\tmin_mtu -= sizeof(struct batadv_frag_packet);\n\tmin_mtu *= BATADV_FRAG_MAX_FRAGMENTS;\n\nout:\n\t \n\tatomic_set(&bat_priv->packet_size_max, min_mtu);\n\n\t \n\treturn min_t(int, min_mtu - batadv_max_header_len(), ETH_DATA_LEN);\n}\n\n \nvoid batadv_update_min_mtu(struct net_device *soft_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\n\tint limit_mtu;\n\tint mtu;\n\n\tmtu = batadv_hardif_min_mtu(soft_iface);\n\n\tif (bat_priv->mtu_set_by_user)\n\t\tlimit_mtu = bat_priv->mtu_set_by_user;\n\telse\n\t\tlimit_mtu = ETH_DATA_LEN;\n\n\tmtu = min(mtu, limit_mtu);\n\tdev_set_mtu(soft_iface, mtu);\n\n\t \n\tbatadv_tt_local_resize_to_mtu(soft_iface);\n}\n\nstatic void\nbatadv_hardif_activate_interface(struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_priv *bat_priv;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\n\tif (hard_iface->if_status != BATADV_IF_INACTIVE)\n\t\tgoto out;\n\n\tbat_priv = netdev_priv(hard_iface->soft_iface);\n\n\tbat_priv->algo_ops->iface.update_mac(hard_iface);\n\thard_iface->if_status = BATADV_IF_TO_BE_ACTIVATED;\n\n\t \n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\tbatadv_primary_if_select(bat_priv, hard_iface);\n\n\tbatadv_info(hard_iface->soft_iface, \"Interface activated: %s\\n\",\n\t\t    hard_iface->net_dev->name);\n\n\tbatadv_update_min_mtu(hard_iface->soft_iface);\n\n\tif (bat_priv->algo_ops->iface.activate)\n\t\tbat_priv->algo_ops->iface.activate(hard_iface);\n\nout:\n\tbatadv_hardif_put(primary_if);\n}\n\nstatic void\nbatadv_hardif_deactivate_interface(struct batadv_hard_iface *hard_iface)\n{\n\tif (hard_iface->if_status != BATADV_IF_ACTIVE &&\n\t    hard_iface->if_status != BATADV_IF_TO_BE_ACTIVATED)\n\t\treturn;\n\n\thard_iface->if_status = BATADV_IF_INACTIVE;\n\n\tbatadv_info(hard_iface->soft_iface, \"Interface deactivated: %s\\n\",\n\t\t    hard_iface->net_dev->name);\n\n\tbatadv_update_min_mtu(hard_iface->soft_iface);\n}\n\n \nint batadv_hardif_enable_interface(struct batadv_hard_iface *hard_iface,\n\t\t\t\t   struct net_device *soft_iface)\n{\n\tstruct batadv_priv *bat_priv;\n\t__be16 ethertype = htons(ETH_P_BATMAN);\n\tint max_header_len = batadv_max_header_len();\n\tunsigned int required_mtu;\n\tunsigned int hardif_mtu;\n\tint ret;\n\n\thardif_mtu = READ_ONCE(hard_iface->net_dev->mtu);\n\trequired_mtu = READ_ONCE(soft_iface->mtu) + max_header_len;\n\n\tif (hardif_mtu < ETH_MIN_MTU + max_header_len)\n\t\treturn -EINVAL;\n\n\tif (hard_iface->if_status != BATADV_IF_NOT_IN_USE)\n\t\tgoto out;\n\n\tkref_get(&hard_iface->refcount);\n\n\tdev_hold(soft_iface);\n\thard_iface->soft_iface = soft_iface;\n\tbat_priv = netdev_priv(hard_iface->soft_iface);\n\n\tret = netdev_master_upper_dev_link(hard_iface->net_dev,\n\t\t\t\t\t   soft_iface, NULL, NULL, NULL);\n\tif (ret)\n\t\tgoto err_dev;\n\n\tret = bat_priv->algo_ops->iface.enable(hard_iface);\n\tif (ret < 0)\n\t\tgoto err_upper;\n\n\thard_iface->if_status = BATADV_IF_INACTIVE;\n\n\tkref_get(&hard_iface->refcount);\n\thard_iface->batman_adv_ptype.type = ethertype;\n\thard_iface->batman_adv_ptype.func = batadv_batman_skb_recv;\n\thard_iface->batman_adv_ptype.dev = hard_iface->net_dev;\n\tdev_add_pack(&hard_iface->batman_adv_ptype);\n\n\tbatadv_info(hard_iface->soft_iface, \"Adding interface: %s\\n\",\n\t\t    hard_iface->net_dev->name);\n\n\tif (atomic_read(&bat_priv->fragmentation) &&\n\t    hardif_mtu < required_mtu)\n\t\tbatadv_info(hard_iface->soft_iface,\n\t\t\t    \"The MTU of interface %s is too small (%i) to handle the transport of batman-adv packets. Packets going over this interface will be fragmented on layer2 which could impact the performance. Setting the MTU to %i would solve the problem.\\n\",\n\t\t\t    hard_iface->net_dev->name, hardif_mtu,\n\t\t\t    required_mtu);\n\n\tif (!atomic_read(&bat_priv->fragmentation) &&\n\t    hardif_mtu < required_mtu)\n\t\tbatadv_info(hard_iface->soft_iface,\n\t\t\t    \"The MTU of interface %s is too small (%i) to handle the transport of batman-adv packets. If you experience problems getting traffic through try increasing the MTU to %i.\\n\",\n\t\t\t    hard_iface->net_dev->name, hardif_mtu,\n\t\t\t    required_mtu);\n\n\tif (batadv_hardif_is_iface_up(hard_iface))\n\t\tbatadv_hardif_activate_interface(hard_iface);\n\telse\n\t\tbatadv_err(hard_iface->soft_iface,\n\t\t\t   \"Not using interface %s (retrying later): interface not active\\n\",\n\t\t\t   hard_iface->net_dev->name);\n\n\tbatadv_hardif_recalc_extra_skbroom(soft_iface);\n\n\tif (bat_priv->algo_ops->iface.enabled)\n\t\tbat_priv->algo_ops->iface.enabled(hard_iface);\n\nout:\n\treturn 0;\n\nerr_upper:\n\tnetdev_upper_dev_unlink(hard_iface->net_dev, soft_iface);\nerr_dev:\n\thard_iface->soft_iface = NULL;\n\tdev_put(soft_iface);\n\tbatadv_hardif_put(hard_iface);\n\treturn ret;\n}\n\n \nstatic size_t batadv_hardif_cnt(const struct net_device *soft_iface)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\tsize_t count = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->soft_iface != soft_iface)\n\t\t\tcontinue;\n\n\t\tcount++;\n\t}\n\trcu_read_unlock();\n\n\treturn count;\n}\n\n \nvoid batadv_hardif_disable_interface(struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\tstruct batadv_hard_iface *primary_if = NULL;\n\n\tbatadv_hardif_deactivate_interface(hard_iface);\n\n\tif (hard_iface->if_status != BATADV_IF_INACTIVE)\n\t\tgoto out;\n\n\tbatadv_info(hard_iface->soft_iface, \"Removing interface: %s\\n\",\n\t\t    hard_iface->net_dev->name);\n\tdev_remove_pack(&hard_iface->batman_adv_ptype);\n\tbatadv_hardif_put(hard_iface);\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (hard_iface == primary_if) {\n\t\tstruct batadv_hard_iface *new_if;\n\n\t\tnew_if = batadv_hardif_get_active(hard_iface->soft_iface);\n\t\tbatadv_primary_if_select(bat_priv, new_if);\n\n\t\tbatadv_hardif_put(new_if);\n\t}\n\n\tbat_priv->algo_ops->iface.disable(hard_iface);\n\thard_iface->if_status = BATADV_IF_NOT_IN_USE;\n\n\t \n\tbatadv_purge_orig_ref(bat_priv);\n\tbatadv_purge_outstanding_packets(bat_priv, hard_iface);\n\tdev_put(hard_iface->soft_iface);\n\n\tnetdev_upper_dev_unlink(hard_iface->net_dev, hard_iface->soft_iface);\n\tbatadv_hardif_recalc_extra_skbroom(hard_iface->soft_iface);\n\n\t \n\tif (batadv_hardif_cnt(hard_iface->soft_iface) <= 1)\n\t\tbatadv_gw_check_client_stop(bat_priv);\n\n\thard_iface->soft_iface = NULL;\n\tbatadv_hardif_put(hard_iface);\n\nout:\n\tbatadv_hardif_put(primary_if);\n}\n\nstatic struct batadv_hard_iface *\nbatadv_hardif_add_interface(struct net_device *net_dev)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\n\tASSERT_RTNL();\n\n\tif (!batadv_is_valid_iface(net_dev))\n\t\tgoto out;\n\n\tdev_hold(net_dev);\n\n\thard_iface = kzalloc(sizeof(*hard_iface), GFP_ATOMIC);\n\tif (!hard_iface)\n\t\tgoto release_dev;\n\n\thard_iface->net_dev = net_dev;\n\thard_iface->soft_iface = NULL;\n\thard_iface->if_status = BATADV_IF_NOT_IN_USE;\n\n\tINIT_LIST_HEAD(&hard_iface->list);\n\tINIT_HLIST_HEAD(&hard_iface->neigh_list);\n\n\tmutex_init(&hard_iface->bat_iv.ogm_buff_mutex);\n\tspin_lock_init(&hard_iface->neigh_list_lock);\n\tkref_init(&hard_iface->refcount);\n\n\thard_iface->num_bcasts = BATADV_NUM_BCASTS_DEFAULT;\n\thard_iface->wifi_flags = batadv_wifi_flags_evaluate(net_dev);\n\tif (batadv_is_wifi_hardif(hard_iface))\n\t\thard_iface->num_bcasts = BATADV_NUM_BCASTS_WIRELESS;\n\n\tatomic_set(&hard_iface->hop_penalty, 0);\n\n\tbatadv_v_hardif_init(hard_iface);\n\n\tbatadv_check_known_mac_addr(hard_iface->net_dev);\n\tkref_get(&hard_iface->refcount);\n\tlist_add_tail_rcu(&hard_iface->list, &batadv_hardif_list);\n\tbatadv_hardif_generation++;\n\n\treturn hard_iface;\n\nrelease_dev:\n\tdev_put(net_dev);\nout:\n\treturn NULL;\n}\n\nstatic void batadv_hardif_remove_interface(struct batadv_hard_iface *hard_iface)\n{\n\tASSERT_RTNL();\n\n\t \n\tif (hard_iface->if_status != BATADV_IF_NOT_IN_USE)\n\t\tbatadv_hardif_disable_interface(hard_iface);\n\n\tif (hard_iface->if_status != BATADV_IF_NOT_IN_USE)\n\t\treturn;\n\n\thard_iface->if_status = BATADV_IF_TO_BE_REMOVED;\n\tbatadv_hardif_put(hard_iface);\n}\n\n \nstatic int batadv_hard_if_event_softif(unsigned long event,\n\t\t\t\t       struct net_device *net_dev)\n{\n\tstruct batadv_priv *bat_priv;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\tbat_priv = netdev_priv(net_dev);\n\t\tbatadv_softif_create_vlan(bat_priv, BATADV_NO_FLAGS);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int batadv_hard_if_event(struct notifier_block *this,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *net_dev = netdev_notifier_info_to_dev(ptr);\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_priv *bat_priv;\n\n\tif (batadv_softif_is_valid(net_dev))\n\t\treturn batadv_hard_if_event_softif(event, net_dev);\n\n\thard_iface = batadv_hardif_get_by_netdev(net_dev);\n\tif (!hard_iface && (event == NETDEV_REGISTER ||\n\t\t\t    event == NETDEV_POST_TYPE_CHANGE))\n\t\thard_iface = batadv_hardif_add_interface(net_dev);\n\n\tif (!hard_iface)\n\t\tgoto out;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tbatadv_hardif_activate_interface(hard_iface);\n\t\tbreak;\n\tcase NETDEV_GOING_DOWN:\n\tcase NETDEV_DOWN:\n\t\tbatadv_hardif_deactivate_interface(hard_iface);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\tlist_del_rcu(&hard_iface->list);\n\t\tbatadv_hardif_generation++;\n\n\t\tbatadv_hardif_remove_interface(hard_iface);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (hard_iface->soft_iface)\n\t\t\tbatadv_update_min_mtu(hard_iface->soft_iface);\n\t\tbreak;\n\tcase NETDEV_CHANGEADDR:\n\t\tif (hard_iface->if_status == BATADV_IF_NOT_IN_USE)\n\t\t\tgoto hardif_put;\n\n\t\tbatadv_check_known_mac_addr(hard_iface->net_dev);\n\n\t\tbat_priv = netdev_priv(hard_iface->soft_iface);\n\t\tbat_priv->algo_ops->iface.update_mac(hard_iface);\n\n\t\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\t\tif (!primary_if)\n\t\t\tgoto hardif_put;\n\n\t\tif (hard_iface == primary_if)\n\t\t\tbatadv_primary_if_update_addr(bat_priv, NULL);\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\thard_iface->wifi_flags = batadv_wifi_flags_evaluate(net_dev);\n\t\tif (batadv_is_wifi_hardif(hard_iface))\n\t\t\thard_iface->num_bcasts = BATADV_NUM_BCASTS_WIRELESS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nhardif_put:\n\tbatadv_hardif_put(hard_iface);\nout:\n\tbatadv_hardif_put(primary_if);\n\treturn NOTIFY_DONE;\n}\n\nstruct notifier_block batadv_hard_if_notifier = {\n\t.notifier_call = batadv_hard_if_event,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}