{
  "module_name": "bat_v_elp.c",
  "hash_id": "26273308610a3b840288fd2e821ef5fdccccb301e86ae6678ee499db4a5749ba",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/bat_v_elp.c",
  "human_readable_source": "\n \n\n#include \"bat_v_elp.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/byteorder/generic.h>\n#include <linux/container_of.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/minmax.h>\n#include <linux/netdevice.h>\n#include <linux/nl80211.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <net/cfg80211.h>\n#include <uapi/linux/batadv_packet.h>\n\n#include \"bat_algo.h\"\n#include \"bat_v_ogm.h\"\n#include \"hard-interface.h\"\n#include \"log.h\"\n#include \"originator.h\"\n#include \"routing.h\"\n#include \"send.h\"\n\n \nstatic void batadv_v_elp_start_timer(struct batadv_hard_iface *hard_iface)\n{\n\tunsigned int msecs;\n\n\tmsecs = atomic_read(&hard_iface->bat_v.elp_interval) - BATADV_JITTER;\n\tmsecs += get_random_u32_below(2 * BATADV_JITTER);\n\n\tqueue_delayed_work(batadv_event_workqueue, &hard_iface->bat_v.elp_wq,\n\t\t\t   msecs_to_jiffies(msecs));\n}\n\n \nstatic u32 batadv_v_elp_get_throughput(struct batadv_hardif_neigh_node *neigh)\n{\n\tstruct batadv_hard_iface *hard_iface = neigh->if_incoming;\n\tstruct ethtool_link_ksettings link_settings;\n\tstruct net_device *real_netdev;\n\tstruct station_info sinfo;\n\tu32 throughput;\n\tint ret;\n\n\t \n\tthroughput =  atomic_read(&hard_iface->bat_v.throughput_override);\n\tif (throughput != 0)\n\t\treturn throughput;\n\n\t \n\tif (batadv_is_wifi_hardif(hard_iface)) {\n\t\tif (!batadv_is_cfg80211_hardif(hard_iface))\n\t\t\t \n\t\t\tgoto default_throughput;\n\n\t\treal_netdev = batadv_get_real_netdev(hard_iface->net_dev);\n\t\tif (!real_netdev)\n\t\t\tgoto default_throughput;\n\n\t\tret = cfg80211_get_station(real_netdev, neigh->addr, &sinfo);\n\n\t\tif (!ret) {\n\t\t\t \n\t\t\tcfg80211_sinfo_release_content(&sinfo);\n\t\t}\n\n\t\tdev_put(real_netdev);\n\t\tif (ret == -ENOENT) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tif (ret)\n\t\t\tgoto default_throughput;\n\n\t\tif (sinfo.filled & BIT(NL80211_STA_INFO_EXPECTED_THROUGHPUT))\n\t\t\treturn sinfo.expected_throughput / 100;\n\n\t\t \n\t\tif (sinfo.filled & BIT(NL80211_STA_INFO_TX_BITRATE))\n\t\t\treturn cfg80211_calculate_bitrate(&sinfo.txrate) / 3;\n\n\t\tgoto default_throughput;\n\t}\n\n\t \n\trtnl_lock();\n\tret = __ethtool_get_link_ksettings(hard_iface->net_dev, &link_settings);\n\trtnl_unlock();\n\tif (ret == 0) {\n\t\t \n\t\tif (link_settings.base.duplex == DUPLEX_FULL)\n\t\t\thard_iface->bat_v.flags |= BATADV_FULL_DUPLEX;\n\t\telse\n\t\t\thard_iface->bat_v.flags &= ~BATADV_FULL_DUPLEX;\n\n\t\tthroughput = link_settings.base.speed;\n\t\tif (throughput && throughput != SPEED_UNKNOWN)\n\t\t\treturn throughput * 10;\n\t}\n\ndefault_throughput:\n\tif (!(hard_iface->bat_v.flags & BATADV_WARNING_DEFAULT)) {\n\t\tbatadv_info(hard_iface->soft_iface,\n\t\t\t    \"WiFi driver or ethtool info does not provide information about link speeds on interface %s, therefore defaulting to hardcoded throughput values of %u.%1u Mbps. Consider overriding the throughput manually or checking your driver.\\n\",\n\t\t\t    hard_iface->net_dev->name,\n\t\t\t    BATADV_THROUGHPUT_DEFAULT_VALUE / 10,\n\t\t\t    BATADV_THROUGHPUT_DEFAULT_VALUE % 10);\n\t\thard_iface->bat_v.flags |= BATADV_WARNING_DEFAULT;\n\t}\n\n\t \n\treturn BATADV_THROUGHPUT_DEFAULT_VALUE;\n}\n\n \nvoid batadv_v_elp_throughput_metric_update(struct work_struct *work)\n{\n\tstruct batadv_hardif_neigh_node_bat_v *neigh_bat_v;\n\tstruct batadv_hardif_neigh_node *neigh;\n\n\tneigh_bat_v = container_of(work, struct batadv_hardif_neigh_node_bat_v,\n\t\t\t\t   metric_work);\n\tneigh = container_of(neigh_bat_v, struct batadv_hardif_neigh_node,\n\t\t\t     bat_v);\n\n\tewma_throughput_add(&neigh->bat_v.throughput,\n\t\t\t    batadv_v_elp_get_throughput(neigh));\n\n\t \n\tbatadv_hardif_neigh_put(neigh);\n}\n\n \nstatic bool\nbatadv_v_elp_wifi_neigh_probe(struct batadv_hardif_neigh_node *neigh)\n{\n\tstruct batadv_hard_iface *hard_iface = neigh->if_incoming;\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\tunsigned long last_tx_diff;\n\tstruct sk_buff *skb;\n\tint probe_len, i;\n\tint elp_skb_len;\n\n\t \n\tif (!batadv_is_wifi_hardif(hard_iface))\n\t\treturn true;\n\n\t \n\tlast_tx_diff = jiffies_to_msecs(jiffies - neigh->bat_v.last_unicast_tx);\n\tif (last_tx_diff <= BATADV_ELP_PROBE_MAX_TX_DIFF)\n\t\treturn true;\n\n\tprobe_len = max_t(int, sizeof(struct batadv_elp_packet),\n\t\t\t  BATADV_ELP_MIN_PROBE_SIZE);\n\n\tfor (i = 0; i < BATADV_ELP_PROBES_PER_NODE; i++) {\n\t\telp_skb_len = hard_iface->bat_v.elp_skb->len;\n\t\tskb = skb_copy_expand(hard_iface->bat_v.elp_skb, 0,\n\t\t\t\t      probe_len - elp_skb_len,\n\t\t\t\t      GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn false;\n\n\t\t \n\t\tskb_put_zero(skb, probe_len - hard_iface->bat_v.elp_skb->len);\n\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Sending unicast (probe) ELP packet on interface %s to %pM\\n\",\n\t\t\t   hard_iface->net_dev->name, neigh->addr);\n\n\t\tbatadv_send_skb_packet(skb, hard_iface, neigh->addr);\n\t}\n\n\treturn true;\n}\n\n \nstatic void batadv_v_elp_periodic_work(struct work_struct *work)\n{\n\tstruct batadv_hardif_neigh_node *hardif_neigh;\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_hard_iface_bat_v *bat_v;\n\tstruct batadv_elp_packet *elp_packet;\n\tstruct batadv_priv *bat_priv;\n\tstruct sk_buff *skb;\n\tu32 elp_interval;\n\tbool ret;\n\n\tbat_v = container_of(work, struct batadv_hard_iface_bat_v, elp_wq.work);\n\thard_iface = container_of(bat_v, struct batadv_hard_iface, bat_v);\n\tbat_priv = netdev_priv(hard_iface->soft_iface);\n\n\tif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING)\n\t\tgoto out;\n\n\t \n\tif (hard_iface->if_status == BATADV_IF_NOT_IN_USE ||\n\t    hard_iface->if_status == BATADV_IF_TO_BE_REMOVED)\n\t\tgoto out;\n\n\t \n\tif (hard_iface->if_status != BATADV_IF_ACTIVE)\n\t\tgoto restart_timer;\n\n\tskb = skb_copy(hard_iface->bat_v.elp_skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto restart_timer;\n\n\telp_packet = (struct batadv_elp_packet *)skb->data;\n\telp_packet->seqno = htonl(atomic_read(&hard_iface->bat_v.elp_seqno));\n\telp_interval = atomic_read(&hard_iface->bat_v.elp_interval);\n\telp_packet->elp_interval = htonl(elp_interval);\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Sending broadcast ELP packet on interface %s, seqno %u\\n\",\n\t\t   hard_iface->net_dev->name,\n\t\t   atomic_read(&hard_iface->bat_v.elp_seqno));\n\n\tbatadv_send_broadcast_skb(skb, hard_iface);\n\n\tatomic_inc(&hard_iface->bat_v.elp_seqno);\n\n\t \n\trcu_read_lock();\n\thlist_for_each_entry_rcu(hardif_neigh, &hard_iface->neigh_list, list) {\n\t\tif (!batadv_v_elp_wifi_neigh_probe(hardif_neigh))\n\t\t\t \n\t\t\tbreak;\n\n\t\tif (!kref_get_unless_zero(&hardif_neigh->refcount))\n\t\t\tcontinue;\n\n\t\t \n\t\tret = queue_work(batadv_event_workqueue,\n\t\t\t\t &hardif_neigh->bat_v.metric_work);\n\n\t\tif (!ret)\n\t\t\tbatadv_hardif_neigh_put(hardif_neigh);\n\t}\n\trcu_read_unlock();\n\nrestart_timer:\n\tbatadv_v_elp_start_timer(hard_iface);\nout:\n\treturn;\n}\n\n \nint batadv_v_elp_iface_enable(struct batadv_hard_iface *hard_iface)\n{\n\tstatic const size_t tvlv_padding = sizeof(__be32);\n\tstruct batadv_elp_packet *elp_packet;\n\tunsigned char *elp_buff;\n\tu32 random_seqno;\n\tsize_t size;\n\tint res = -ENOMEM;\n\n\tsize = ETH_HLEN + NET_IP_ALIGN + BATADV_ELP_HLEN + tvlv_padding;\n\thard_iface->bat_v.elp_skb = dev_alloc_skb(size);\n\tif (!hard_iface->bat_v.elp_skb)\n\t\tgoto out;\n\n\tskb_reserve(hard_iface->bat_v.elp_skb, ETH_HLEN + NET_IP_ALIGN);\n\telp_buff = skb_put_zero(hard_iface->bat_v.elp_skb,\n\t\t\t\tBATADV_ELP_HLEN + tvlv_padding);\n\telp_packet = (struct batadv_elp_packet *)elp_buff;\n\n\telp_packet->packet_type = BATADV_ELP;\n\telp_packet->version = BATADV_COMPAT_VERSION;\n\n\t \n\tget_random_bytes(&random_seqno, sizeof(random_seqno));\n\tatomic_set(&hard_iface->bat_v.elp_seqno, random_seqno);\n\n\t \n\thard_iface->bat_v.flags |= BATADV_FULL_DUPLEX;\n\n\t \n\thard_iface->bat_v.flags &= ~BATADV_WARNING_DEFAULT;\n\n\tif (batadv_is_wifi_hardif(hard_iface))\n\t\thard_iface->bat_v.flags &= ~BATADV_FULL_DUPLEX;\n\n\tINIT_DELAYED_WORK(&hard_iface->bat_v.elp_wq,\n\t\t\t  batadv_v_elp_periodic_work);\n\tbatadv_v_elp_start_timer(hard_iface);\n\tres = 0;\n\nout:\n\treturn res;\n}\n\n \nvoid batadv_v_elp_iface_disable(struct batadv_hard_iface *hard_iface)\n{\n\tcancel_delayed_work_sync(&hard_iface->bat_v.elp_wq);\n\n\tdev_kfree_skb(hard_iface->bat_v.elp_skb);\n\thard_iface->bat_v.elp_skb = NULL;\n}\n\n \nvoid batadv_v_elp_iface_activate(struct batadv_hard_iface *primary_iface,\n\t\t\t\t struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_elp_packet *elp_packet;\n\tstruct sk_buff *skb;\n\n\tif (!hard_iface->bat_v.elp_skb)\n\t\treturn;\n\n\tskb = hard_iface->bat_v.elp_skb;\n\telp_packet = (struct batadv_elp_packet *)skb->data;\n\tether_addr_copy(elp_packet->orig,\n\t\t\tprimary_iface->net_dev->dev_addr);\n}\n\n \nvoid batadv_v_elp_primary_iface_set(struct batadv_hard_iface *primary_iface)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (primary_iface->soft_iface != hard_iface->soft_iface)\n\t\t\tcontinue;\n\n\t\tbatadv_v_elp_iface_activate(primary_iface, hard_iface);\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void batadv_v_elp_neigh_update(struct batadv_priv *bat_priv,\n\t\t\t\t      u8 *neigh_addr,\n\t\t\t\t      struct batadv_hard_iface *if_incoming,\n\t\t\t\t      struct batadv_elp_packet *elp_packet)\n\n{\n\tstruct batadv_neigh_node *neigh;\n\tstruct batadv_orig_node *orig_neigh;\n\tstruct batadv_hardif_neigh_node *hardif_neigh;\n\ts32 seqno_diff;\n\ts32 elp_latest_seqno;\n\n\torig_neigh = batadv_v_ogm_orig_get(bat_priv, elp_packet->orig);\n\tif (!orig_neigh)\n\t\treturn;\n\n\tneigh = batadv_neigh_node_get_or_create(orig_neigh,\n\t\t\t\t\t\tif_incoming, neigh_addr);\n\tif (!neigh)\n\t\tgoto orig_free;\n\n\thardif_neigh = batadv_hardif_neigh_get(if_incoming, neigh_addr);\n\tif (!hardif_neigh)\n\t\tgoto neigh_free;\n\n\telp_latest_seqno = hardif_neigh->bat_v.elp_latest_seqno;\n\tseqno_diff = ntohl(elp_packet->seqno) - elp_latest_seqno;\n\n\t \n\tif (seqno_diff < 1 && seqno_diff > -BATADV_ELP_MAX_AGE)\n\t\tgoto hardif_free;\n\n\tneigh->last_seen = jiffies;\n\thardif_neigh->last_seen = jiffies;\n\thardif_neigh->bat_v.elp_latest_seqno = ntohl(elp_packet->seqno);\n\thardif_neigh->bat_v.elp_interval = ntohl(elp_packet->elp_interval);\n\nhardif_free:\n\tbatadv_hardif_neigh_put(hardif_neigh);\nneigh_free:\n\tbatadv_neigh_node_put(neigh);\norig_free:\n\tbatadv_orig_node_put(orig_neigh);\n}\n\n \nint batadv_v_elp_packet_recv(struct sk_buff *skb,\n\t\t\t     struct batadv_hard_iface *if_incoming)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\n\tstruct batadv_elp_packet *elp_packet;\n\tstruct batadv_hard_iface *primary_if;\n\tstruct ethhdr *ethhdr;\n\tbool res;\n\tint ret = NET_RX_DROP;\n\n\tres = batadv_check_management_packet(skb, if_incoming, BATADV_ELP_HLEN);\n\tif (!res)\n\t\tgoto free_skb;\n\n\tethhdr = eth_hdr(skb);\n\tif (batadv_is_my_mac(bat_priv, ethhdr->h_source))\n\t\tgoto free_skb;\n\n\t \n\tif (strcmp(bat_priv->algo_ops->name, \"BATMAN_V\") != 0)\n\t\tgoto free_skb;\n\n\telp_packet = (struct batadv_elp_packet *)skb->data;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Received ELP packet from %pM seqno %u ORIG: %pM\\n\",\n\t\t   ethhdr->h_source, ntohl(elp_packet->seqno),\n\t\t   elp_packet->orig);\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\tgoto free_skb;\n\n\tbatadv_v_elp_neigh_update(bat_priv, ethhdr->h_source, if_incoming,\n\t\t\t\t  elp_packet);\n\n\tret = NET_RX_SUCCESS;\n\tbatadv_hardif_put(primary_if);\n\nfree_skb:\n\tif (ret == NET_RX_SUCCESS)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}