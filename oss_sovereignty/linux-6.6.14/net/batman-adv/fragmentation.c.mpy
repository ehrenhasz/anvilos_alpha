{
  "module_name": "fragmentation.c",
  "hash_id": "dd90c89acd3b8b8b632fe129151c1772846c2cabe79d4ee9067208a1c847363b",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/fragmentation.c",
  "human_readable_source": "\n \n\n#include \"fragmentation.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/byteorder/generic.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/jiffies.h>\n#include <linux/lockdep.h>\n#include <linux/minmax.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <uapi/linux/batadv_packet.h>\n\n#include \"hard-interface.h\"\n#include \"originator.h\"\n#include \"routing.h\"\n#include \"send.h\"\n\n \nstatic void batadv_frag_clear_chain(struct hlist_head *head, bool dropped)\n{\n\tstruct batadv_frag_list_entry *entry;\n\tstruct hlist_node *node;\n\n\thlist_for_each_entry_safe(entry, node, head, list) {\n\t\thlist_del(&entry->list);\n\n\t\tif (dropped)\n\t\t\tkfree_skb(entry->skb);\n\t\telse\n\t\t\tconsume_skb(entry->skb);\n\n\t\tkfree(entry);\n\t}\n}\n\n \nvoid batadv_frag_purge_orig(struct batadv_orig_node *orig_node,\n\t\t\t    bool (*check_cb)(struct batadv_frag_table_entry *))\n{\n\tstruct batadv_frag_table_entry *chain;\n\tu8 i;\n\n\tfor (i = 0; i < BATADV_FRAG_BUFFER_COUNT; i++) {\n\t\tchain = &orig_node->fragments[i];\n\t\tspin_lock_bh(&chain->lock);\n\n\t\tif (!check_cb || check_cb(chain)) {\n\t\t\tbatadv_frag_clear_chain(&chain->fragment_list, true);\n\t\t\tchain->size = 0;\n\t\t}\n\n\t\tspin_unlock_bh(&chain->lock);\n\t}\n}\n\n \nstatic int batadv_frag_size_limit(void)\n{\n\tint limit = BATADV_FRAG_MAX_FRAG_SIZE;\n\n\tlimit -= sizeof(struct batadv_frag_packet);\n\tlimit *= BATADV_FRAG_MAX_FRAGMENTS;\n\n\treturn limit;\n}\n\n \nstatic bool batadv_frag_init_chain(struct batadv_frag_table_entry *chain,\n\t\t\t\t   u16 seqno)\n{\n\tlockdep_assert_held(&chain->lock);\n\n\tif (chain->seqno == seqno)\n\t\treturn false;\n\n\tif (!hlist_empty(&chain->fragment_list))\n\t\tbatadv_frag_clear_chain(&chain->fragment_list, true);\n\n\tchain->size = 0;\n\tchain->seqno = seqno;\n\n\treturn true;\n}\n\n \nstatic bool batadv_frag_insert_packet(struct batadv_orig_node *orig_node,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct hlist_head *chain_out)\n{\n\tstruct batadv_frag_table_entry *chain;\n\tstruct batadv_frag_list_entry *frag_entry_new = NULL, *frag_entry_curr;\n\tstruct batadv_frag_list_entry *frag_entry_last = NULL;\n\tstruct batadv_frag_packet *frag_packet;\n\tu8 bucket;\n\tu16 seqno, hdr_size = sizeof(struct batadv_frag_packet);\n\tbool ret = false;\n\n\t \n\tif (skb_linearize(skb) < 0)\n\t\tgoto err;\n\n\tfrag_packet = (struct batadv_frag_packet *)skb->data;\n\tseqno = ntohs(frag_packet->seqno);\n\tbucket = seqno % BATADV_FRAG_BUFFER_COUNT;\n\n\tfrag_entry_new = kmalloc(sizeof(*frag_entry_new), GFP_ATOMIC);\n\tif (!frag_entry_new)\n\t\tgoto err;\n\n\tfrag_entry_new->skb = skb;\n\tfrag_entry_new->no = frag_packet->no;\n\n\t \n\tchain = &orig_node->fragments[bucket];\n\tspin_lock_bh(&chain->lock);\n\tif (batadv_frag_init_chain(chain, seqno)) {\n\t\thlist_add_head(&frag_entry_new->list, &chain->fragment_list);\n\t\tchain->size = skb->len - hdr_size;\n\t\tchain->timestamp = jiffies;\n\t\tchain->total_size = ntohs(frag_packet->total_size);\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t \n\thlist_for_each_entry(frag_entry_curr, &chain->fragment_list, list) {\n\t\t \n\t\tif (frag_entry_curr->no == frag_entry_new->no)\n\t\t\tgoto err_unlock;\n\n\t\t \n\t\tif (frag_entry_curr->no < frag_entry_new->no) {\n\t\t\thlist_add_before(&frag_entry_new->list,\n\t\t\t\t\t &frag_entry_curr->list);\n\t\t\tchain->size += skb->len - hdr_size;\n\t\t\tchain->timestamp = jiffies;\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tfrag_entry_last = frag_entry_curr;\n\t}\n\n\t \n\tif (likely(frag_entry_last)) {\n\t\thlist_add_behind(&frag_entry_new->list, &frag_entry_last->list);\n\t\tchain->size += skb->len - hdr_size;\n\t\tchain->timestamp = jiffies;\n\t\tret = true;\n\t}\n\nout:\n\tif (chain->size > batadv_frag_size_limit() ||\n\t    chain->total_size != ntohs(frag_packet->total_size) ||\n\t    chain->total_size > batadv_frag_size_limit()) {\n\t\t \n\t\tbatadv_frag_clear_chain(&chain->fragment_list, true);\n\t\tchain->size = 0;\n\t} else if (ntohs(frag_packet->total_size) == chain->size) {\n\t\t \n\t\thlist_move_list(&chain->fragment_list, chain_out);\n\t\tchain->size = 0;\n\t}\n\nerr_unlock:\n\tspin_unlock_bh(&chain->lock);\n\nerr:\n\tif (!ret) {\n\t\tkfree(frag_entry_new);\n\t\tkfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct sk_buff *\nbatadv_frag_merge_packets(struct hlist_head *chain)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\tbool dropped = false;\n\n\t \n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n\tkfree(entry);\n\n\tpacket = (struct batadv_frag_packet *)skb_out->data;\n\tsize = ntohs(packet->total_size) + hdr_size;\n\n\t \n\tif (pskb_expand_head(skb_out, 0, size - skb_out->len, GFP_ATOMIC) < 0) {\n\t\tkfree_skb(skb_out);\n\t\tskb_out = NULL;\n\t\tdropped = true;\n\t\tgoto free;\n\t}\n\n\t \n\tskb_pull(skb_out, hdr_size);\n\tskb_out->ip_summed = CHECKSUM_NONE;\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\n\t \n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tskb_put_data(skb_out, entry->skb->data + hdr_size, size);\n\t}\n\nfree:\n\t \n\tbatadv_frag_clear_chain(chain, dropped);\n\treturn skb_out;\n}\n\n \nbool batadv_frag_skb_buffer(struct sk_buff **skb,\n\t\t\t    struct batadv_orig_node *orig_node_src)\n{\n\tstruct sk_buff *skb_out = NULL;\n\tstruct hlist_head head = HLIST_HEAD_INIT;\n\tbool ret = false;\n\n\t \n\tif (!batadv_frag_insert_packet(orig_node_src, *skb, &head))\n\t\tgoto out_err;\n\n\t \n\tif (hlist_empty(&head))\n\t\tgoto out;\n\n\tskb_out = batadv_frag_merge_packets(&head);\n\tif (!skb_out)\n\t\tgoto out_err;\n\nout:\n\tret = true;\nout_err:\n\t*skb = skb_out;\n\treturn ret;\n}\n\n \nbool batadv_frag_skb_fwd(struct sk_buff *skb,\n\t\t\t struct batadv_hard_iface *recv_if,\n\t\t\t struct batadv_orig_node *orig_node_src)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tstruct batadv_orig_node *orig_node_dst;\n\tstruct batadv_neigh_node *neigh_node = NULL;\n\tstruct batadv_frag_packet *packet;\n\tu16 total_size;\n\tbool ret = false;\n\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\torig_node_dst = batadv_orig_hash_find(bat_priv, packet->dest);\n\tif (!orig_node_dst)\n\t\tgoto out;\n\n\tneigh_node = batadv_find_router(bat_priv, orig_node_dst, recv_if);\n\tif (!neigh_node)\n\t\tgoto out;\n\n\t \n\ttotal_size = ntohs(packet->total_size);\n\tif (total_size > neigh_node->if_incoming->net_dev->mtu) {\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_FWD);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_FWD_BYTES,\n\t\t\t\t   skb->len + ETH_HLEN);\n\n\t\tpacket->ttl--;\n\t\tbatadv_send_unicast_skb(skb, neigh_node);\n\t\tret = true;\n\t}\n\nout:\n\tbatadv_orig_node_put(orig_node_dst);\n\tbatadv_neigh_node_put(neigh_node);\n\treturn ret;\n}\n\n \nstatic struct sk_buff *batadv_frag_create(struct net_device *net_dev,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct batadv_frag_packet *frag_head,\n\t\t\t\t\t  unsigned int fragment_size)\n{\n\tunsigned int ll_reserved = LL_RESERVED_SPACE(net_dev);\n\tunsigned int tailroom = net_dev->needed_tailroom;\n\tstruct sk_buff *skb_fragment;\n\tunsigned int header_size = sizeof(*frag_head);\n\tunsigned int mtu = fragment_size + header_size;\n\n\tskb_fragment = dev_alloc_skb(ll_reserved + mtu + tailroom);\n\tif (!skb_fragment)\n\t\tgoto err;\n\n\tskb_fragment->priority = skb->priority;\n\n\t \n\tskb_reserve(skb_fragment, ll_reserved + header_size);\n\tskb_split(skb, skb_fragment, skb->len - fragment_size);\n\n\t \n\tskb_push(skb_fragment, header_size);\n\tmemcpy(skb_fragment->data, frag_head, header_size);\n\nerr:\n\treturn skb_fragment;\n}\n\n \nint batadv_frag_send_packet(struct sk_buff *skb,\n\t\t\t    struct batadv_orig_node *orig_node,\n\t\t\t    struct batadv_neigh_node *neigh_node)\n{\n\tstruct net_device *net_dev = neigh_node->if_incoming->net_dev;\n\tstruct batadv_priv *bat_priv;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_frag_packet frag_header;\n\tstruct sk_buff *skb_fragment;\n\tunsigned int mtu = net_dev->mtu;\n\tunsigned int header_size = sizeof(frag_header);\n\tunsigned int max_fragment_size, num_fragments;\n\tint ret;\n\n\t \n\tmtu = min_t(unsigned int, mtu, BATADV_FRAG_MAX_FRAG_SIZE);\n\tmax_fragment_size = mtu - header_size;\n\n\tif (skb->len == 0 || max_fragment_size == 0)\n\t\treturn -EINVAL;\n\n\tnum_fragments = (skb->len - 1) / max_fragment_size + 1;\n\tmax_fragment_size = (skb->len - 1) / num_fragments + 1;\n\n\t \n\tif (num_fragments > BATADV_FRAG_MAX_FRAGMENTS) {\n\t\tret = -EAGAIN;\n\t\tgoto free_skb;\n\t}\n\n\tbat_priv = orig_node->bat_priv;\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if) {\n\t\tret = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\n\t \n\tif (skb_has_frag_list(skb) && __skb_linearize(skb)) {\n\t\tret = -ENOMEM;\n\t\tgoto free_skb;\n\t}\n\n\t \n\tfrag_header.packet_type = BATADV_UNICAST_FRAG;\n\tfrag_header.version = BATADV_COMPAT_VERSION;\n\tfrag_header.ttl = BATADV_TTL;\n\tfrag_header.seqno = htons(atomic_inc_return(&bat_priv->frag_seqno));\n\tfrag_header.reserved = 0;\n\tfrag_header.no = 0;\n\tfrag_header.total_size = htons(skb->len);\n\n\t \n\tif (skb->priority >= 256 && skb->priority <= 263)\n\t\tfrag_header.priority = skb->priority - 256;\n\telse\n\t\tfrag_header.priority = 0;\n\n\tether_addr_copy(frag_header.orig, primary_if->net_dev->dev_addr);\n\tether_addr_copy(frag_header.dest, orig_node->orig);\n\n\t \n\twhile (skb->len > max_fragment_size) {\n\t\t \n\t\tif (unlikely(frag_header.no == BATADV_FRAG_MAX_FRAGMENTS - 1)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_primary_if;\n\t\t}\n\n\t\tskb_fragment = batadv_frag_create(net_dev, skb, &frag_header,\n\t\t\t\t\t\t  max_fragment_size);\n\t\tif (!skb_fragment) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_primary_if;\n\t\t}\n\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_TX);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_TX_BYTES,\n\t\t\t\t   skb_fragment->len + ETH_HLEN);\n\t\tret = batadv_send_unicast_skb(skb_fragment, neigh_node);\n\t\tif (ret != NET_XMIT_SUCCESS) {\n\t\t\tret = NET_XMIT_DROP;\n\t\t\tgoto put_primary_if;\n\t\t}\n\n\t\tfrag_header.no++;\n\t}\n\n\t \n\tret = skb_cow_head(skb, ETH_HLEN + header_size);\n\tif (ret < 0)\n\t\tgoto put_primary_if;\n\n\tskb_push(skb, header_size);\n\tmemcpy(skb->data, &frag_header, header_size);\n\n\t \n\tbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_TX);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_TX_BYTES,\n\t\t\t   skb->len + ETH_HLEN);\n\tret = batadv_send_unicast_skb(skb, neigh_node);\n\t \n\tskb = NULL;\n\nput_primary_if:\n\tbatadv_hardif_put(primary_if);\nfree_skb:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}