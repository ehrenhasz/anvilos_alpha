{
  "module_name": "translation-table.c",
  "hash_id": "8b10d28d7da446c555d59b581ab3377aaa68b48765ab03defb711631bddaa1f9",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/translation-table.c",
  "human_readable_source": "\n \n\n#include \"translation-table.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/build_bug.h>\n#include <linux/byteorder/generic.h>\n#include <linux/cache.h>\n#include <linux/compiler.h>\n#include <linux/container_of.h>\n#include <linux/crc32c.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <net/genetlink.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"bridge_loop_avoidance.h\"\n#include \"hard-interface.h\"\n#include \"hash.h\"\n#include \"log.h\"\n#include \"netlink.h\"\n#include \"originator.h\"\n#include \"soft-interface.h\"\n#include \"tvlv.h\"\n\nstatic struct kmem_cache *batadv_tl_cache __read_mostly;\nstatic struct kmem_cache *batadv_tg_cache __read_mostly;\nstatic struct kmem_cache *batadv_tt_orig_cache __read_mostly;\nstatic struct kmem_cache *batadv_tt_change_cache __read_mostly;\nstatic struct kmem_cache *batadv_tt_req_cache __read_mostly;\nstatic struct kmem_cache *batadv_tt_roam_cache __read_mostly;\n\n \nstatic struct lock_class_key batadv_tt_local_hash_lock_class_key;\nstatic struct lock_class_key batadv_tt_global_hash_lock_class_key;\n\nstatic void batadv_send_roam_adv(struct batadv_priv *bat_priv, u8 *client,\n\t\t\t\t unsigned short vid,\n\t\t\t\t struct batadv_orig_node *orig_node);\nstatic void batadv_tt_purge(struct work_struct *work);\nstatic void\nbatadv_tt_global_del_orig_list(struct batadv_tt_global_entry *tt_global_entry);\nstatic void batadv_tt_global_del(struct batadv_priv *bat_priv,\n\t\t\t\t struct batadv_orig_node *orig_node,\n\t\t\t\t const unsigned char *addr,\n\t\t\t\t unsigned short vid, const char *message,\n\t\t\t\t bool roaming);\n\n \nstatic bool batadv_compare_tt(const struct hlist_node *node, const void *data2)\n{\n\tconst void *data1 = container_of(node, struct batadv_tt_common_entry,\n\t\t\t\t\t hash_entry);\n\tconst struct batadv_tt_common_entry *tt1 = data1;\n\tconst struct batadv_tt_common_entry *tt2 = data2;\n\n\treturn (tt1->vid == tt2->vid) && batadv_compare_eth(data1, data2);\n}\n\n \nstatic inline u32 batadv_choose_tt(const void *data, u32 size)\n{\n\tconst struct batadv_tt_common_entry *tt;\n\tu32 hash = 0;\n\n\ttt = data;\n\thash = jhash(&tt->addr, ETH_ALEN, hash);\n\thash = jhash(&tt->vid, sizeof(tt->vid), hash);\n\n\treturn hash % size;\n}\n\n \nstatic struct batadv_tt_common_entry *\nbatadv_tt_hash_find(struct batadv_hashtable *hash, const u8 *addr,\n\t\t    unsigned short vid)\n{\n\tstruct hlist_head *head;\n\tstruct batadv_tt_common_entry to_search, *tt, *tt_tmp = NULL;\n\tu32 index;\n\n\tif (!hash)\n\t\treturn NULL;\n\n\tether_addr_copy(to_search.addr, addr);\n\tto_search.vid = vid;\n\n\tindex = batadv_choose_tt(&to_search, hash->size);\n\thead = &hash->table[index];\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(tt, head, hash_entry) {\n\t\tif (!batadv_compare_eth(tt, addr))\n\t\t\tcontinue;\n\n\t\tif (tt->vid != vid)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&tt->refcount))\n\t\t\tcontinue;\n\n\t\ttt_tmp = tt;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn tt_tmp;\n}\n\n \nstatic struct batadv_tt_local_entry *\nbatadv_tt_local_hash_find(struct batadv_priv *bat_priv, const u8 *addr,\n\t\t\t  unsigned short vid)\n{\n\tstruct batadv_tt_common_entry *tt_common_entry;\n\tstruct batadv_tt_local_entry *tt_local_entry = NULL;\n\n\ttt_common_entry = batadv_tt_hash_find(bat_priv->tt.local_hash, addr,\n\t\t\t\t\t      vid);\n\tif (tt_common_entry)\n\t\ttt_local_entry = container_of(tt_common_entry,\n\t\t\t\t\t      struct batadv_tt_local_entry,\n\t\t\t\t\t      common);\n\treturn tt_local_entry;\n}\n\n \nstruct batadv_tt_global_entry *\nbatadv_tt_global_hash_find(struct batadv_priv *bat_priv, const u8 *addr,\n\t\t\t   unsigned short vid)\n{\n\tstruct batadv_tt_common_entry *tt_common_entry;\n\tstruct batadv_tt_global_entry *tt_global_entry = NULL;\n\n\ttt_common_entry = batadv_tt_hash_find(bat_priv->tt.global_hash, addr,\n\t\t\t\t\t      vid);\n\tif (tt_common_entry)\n\t\ttt_global_entry = container_of(tt_common_entry,\n\t\t\t\t\t       struct batadv_tt_global_entry,\n\t\t\t\t\t       common);\n\treturn tt_global_entry;\n}\n\n \nstatic void batadv_tt_local_entry_free_rcu(struct rcu_head *rcu)\n{\n\tstruct batadv_tt_local_entry *tt_local_entry;\n\n\ttt_local_entry = container_of(rcu, struct batadv_tt_local_entry,\n\t\t\t\t      common.rcu);\n\n\tkmem_cache_free(batadv_tl_cache, tt_local_entry);\n}\n\n \nstatic void batadv_tt_local_entry_release(struct kref *ref)\n{\n\tstruct batadv_tt_local_entry *tt_local_entry;\n\n\ttt_local_entry = container_of(ref, struct batadv_tt_local_entry,\n\t\t\t\t      common.refcount);\n\n\tbatadv_softif_vlan_put(tt_local_entry->vlan);\n\n\tcall_rcu(&tt_local_entry->common.rcu, batadv_tt_local_entry_free_rcu);\n}\n\n \nstatic void\nbatadv_tt_local_entry_put(struct batadv_tt_local_entry *tt_local_entry)\n{\n\tif (!tt_local_entry)\n\t\treturn;\n\n\tkref_put(&tt_local_entry->common.refcount,\n\t\t batadv_tt_local_entry_release);\n}\n\n \nstatic void batadv_tt_global_entry_free_rcu(struct rcu_head *rcu)\n{\n\tstruct batadv_tt_global_entry *tt_global_entry;\n\n\ttt_global_entry = container_of(rcu, struct batadv_tt_global_entry,\n\t\t\t\t       common.rcu);\n\n\tkmem_cache_free(batadv_tg_cache, tt_global_entry);\n}\n\n \nvoid batadv_tt_global_entry_release(struct kref *ref)\n{\n\tstruct batadv_tt_global_entry *tt_global_entry;\n\n\ttt_global_entry = container_of(ref, struct batadv_tt_global_entry,\n\t\t\t\t       common.refcount);\n\n\tbatadv_tt_global_del_orig_list(tt_global_entry);\n\n\tcall_rcu(&tt_global_entry->common.rcu, batadv_tt_global_entry_free_rcu);\n}\n\n \nint batadv_tt_global_hash_count(struct batadv_priv *bat_priv,\n\t\t\t\tconst u8 *addr, unsigned short vid)\n{\n\tstruct batadv_tt_global_entry *tt_global_entry;\n\tint count;\n\n\ttt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\n\tif (!tt_global_entry)\n\t\treturn 0;\n\n\tcount = atomic_read(&tt_global_entry->orig_list_count);\n\tbatadv_tt_global_entry_put(tt_global_entry);\n\n\treturn count;\n}\n\n \nstatic void batadv_tt_local_size_mod(struct batadv_priv *bat_priv,\n\t\t\t\t     unsigned short vid, int v)\n{\n\tstruct batadv_softif_vlan *vlan;\n\n\tvlan = batadv_softif_vlan_get(bat_priv, vid);\n\tif (!vlan)\n\t\treturn;\n\n\tatomic_add(v, &vlan->tt.num_entries);\n\n\tbatadv_softif_vlan_put(vlan);\n}\n\n \nstatic void batadv_tt_local_size_inc(struct batadv_priv *bat_priv,\n\t\t\t\t     unsigned short vid)\n{\n\tbatadv_tt_local_size_mod(bat_priv, vid, 1);\n}\n\n \nstatic void batadv_tt_local_size_dec(struct batadv_priv *bat_priv,\n\t\t\t\t     unsigned short vid)\n{\n\tbatadv_tt_local_size_mod(bat_priv, vid, -1);\n}\n\n \nstatic void batadv_tt_global_size_mod(struct batadv_orig_node *orig_node,\n\t\t\t\t      unsigned short vid, int v)\n{\n\tstruct batadv_orig_node_vlan *vlan;\n\n\tvlan = batadv_orig_node_vlan_new(orig_node, vid);\n\tif (!vlan)\n\t\treturn;\n\n\tif (atomic_add_return(v, &vlan->tt.num_entries) == 0) {\n\t\tspin_lock_bh(&orig_node->vlan_list_lock);\n\t\tif (!hlist_unhashed(&vlan->list)) {\n\t\t\thlist_del_init_rcu(&vlan->list);\n\t\t\tbatadv_orig_node_vlan_put(vlan);\n\t\t}\n\t\tspin_unlock_bh(&orig_node->vlan_list_lock);\n\t}\n\n\tbatadv_orig_node_vlan_put(vlan);\n}\n\n \nstatic void batadv_tt_global_size_inc(struct batadv_orig_node *orig_node,\n\t\t\t\t      unsigned short vid)\n{\n\tbatadv_tt_global_size_mod(orig_node, vid, 1);\n}\n\n \nstatic void batadv_tt_global_size_dec(struct batadv_orig_node *orig_node,\n\t\t\t\t      unsigned short vid)\n{\n\tbatadv_tt_global_size_mod(orig_node, vid, -1);\n}\n\n \nstatic void batadv_tt_orig_list_entry_free_rcu(struct rcu_head *rcu)\n{\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\n\torig_entry = container_of(rcu, struct batadv_tt_orig_list_entry, rcu);\n\n\tkmem_cache_free(batadv_tt_orig_cache, orig_entry);\n}\n\n \nstatic void batadv_tt_orig_list_entry_release(struct kref *ref)\n{\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\n\torig_entry = container_of(ref, struct batadv_tt_orig_list_entry,\n\t\t\t\t  refcount);\n\n\tbatadv_orig_node_put(orig_entry->orig_node);\n\tcall_rcu(&orig_entry->rcu, batadv_tt_orig_list_entry_free_rcu);\n}\n\n \nstatic void\nbatadv_tt_orig_list_entry_put(struct batadv_tt_orig_list_entry *orig_entry)\n{\n\tif (!orig_entry)\n\t\treturn;\n\n\tkref_put(&orig_entry->refcount, batadv_tt_orig_list_entry_release);\n}\n\n \nstatic void batadv_tt_local_event(struct batadv_priv *bat_priv,\n\t\t\t\t  struct batadv_tt_local_entry *tt_local_entry,\n\t\t\t\t  u8 event_flags)\n{\n\tstruct batadv_tt_change_node *tt_change_node, *entry, *safe;\n\tstruct batadv_tt_common_entry *common = &tt_local_entry->common;\n\tu8 flags = common->flags | event_flags;\n\tbool event_removed = false;\n\tbool del_op_requested, del_op_entry;\n\n\ttt_change_node = kmem_cache_alloc(batadv_tt_change_cache, GFP_ATOMIC);\n\tif (!tt_change_node)\n\t\treturn;\n\n\ttt_change_node->change.flags = flags;\n\tmemset(tt_change_node->change.reserved, 0,\n\t       sizeof(tt_change_node->change.reserved));\n\tether_addr_copy(tt_change_node->change.addr, common->addr);\n\ttt_change_node->change.vid = htons(common->vid);\n\n\tdel_op_requested = flags & BATADV_TT_CLIENT_DEL;\n\n\t \n\tspin_lock_bh(&bat_priv->tt.changes_list_lock);\n\tlist_for_each_entry_safe(entry, safe, &bat_priv->tt.changes_list,\n\t\t\t\t list) {\n\t\tif (!batadv_compare_eth(entry->change.addr, common->addr))\n\t\t\tcontinue;\n\n\t\t \n\t\tdel_op_entry = entry->change.flags & BATADV_TT_CLIENT_DEL;\n\t\tif (!del_op_requested && del_op_entry)\n\t\t\tgoto del;\n\t\tif (del_op_requested && !del_op_entry)\n\t\t\tgoto del;\n\n\t\t \n\t\tif (!del_op_requested && !del_op_entry)\n\t\t\tentry->change.flags = flags;\n\n\t\tcontinue;\ndel:\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(batadv_tt_change_cache, entry);\n\t\tkmem_cache_free(batadv_tt_change_cache, tt_change_node);\n\t\tevent_removed = true;\n\t\tgoto unlock;\n\t}\n\n\t \n\tlist_add_tail(&tt_change_node->list, &bat_priv->tt.changes_list);\n\nunlock:\n\tspin_unlock_bh(&bat_priv->tt.changes_list_lock);\n\n\tif (event_removed)\n\t\tatomic_dec(&bat_priv->tt.local_changes);\n\telse\n\t\tatomic_inc(&bat_priv->tt.local_changes);\n}\n\n \nstatic int batadv_tt_len(int changes_num)\n{\n\treturn changes_num * sizeof(struct batadv_tvlv_tt_change);\n}\n\n \nstatic u16 batadv_tt_entries(u16 tt_len)\n{\n\treturn tt_len / batadv_tt_len(1);\n}\n\n \nstatic int batadv_tt_local_table_transmit_size(struct batadv_priv *bat_priv)\n{\n\tu16 num_vlan = 0;\n\tu16 tt_local_entries = 0;\n\tstruct batadv_softif_vlan *vlan;\n\tint hdr_size;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\n\t\tnum_vlan++;\n\t\ttt_local_entries += atomic_read(&vlan->tt.num_entries);\n\t}\n\trcu_read_unlock();\n\n\t \n\thdr_size = sizeof(struct batadv_unicast_tvlv_packet);\n\thdr_size += sizeof(struct batadv_tvlv_hdr);\n\thdr_size += sizeof(struct batadv_tvlv_tt_data);\n\thdr_size += num_vlan * sizeof(struct batadv_tvlv_tt_vlan_data);\n\n\treturn hdr_size + batadv_tt_len(tt_local_entries);\n}\n\nstatic int batadv_tt_local_init(struct batadv_priv *bat_priv)\n{\n\tif (bat_priv->tt.local_hash)\n\t\treturn 0;\n\n\tbat_priv->tt.local_hash = batadv_hash_new(1024);\n\n\tif (!bat_priv->tt.local_hash)\n\t\treturn -ENOMEM;\n\n\tbatadv_hash_set_lock_class(bat_priv->tt.local_hash,\n\t\t\t\t   &batadv_tt_local_hash_lock_class_key);\n\n\treturn 0;\n}\n\nstatic void batadv_tt_global_free(struct batadv_priv *bat_priv,\n\t\t\t\t  struct batadv_tt_global_entry *tt_global,\n\t\t\t\t  const char *message)\n{\n\tstruct batadv_tt_global_entry *tt_removed_entry;\n\tstruct hlist_node *tt_removed_node;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Deleting global tt entry %pM (vid: %d): %s\\n\",\n\t\t   tt_global->common.addr,\n\t\t   batadv_print_vid(tt_global->common.vid), message);\n\n\ttt_removed_node = batadv_hash_remove(bat_priv->tt.global_hash,\n\t\t\t\t\t     batadv_compare_tt,\n\t\t\t\t\t     batadv_choose_tt,\n\t\t\t\t\t     &tt_global->common);\n\tif (!tt_removed_node)\n\t\treturn;\n\n\t \n\ttt_removed_entry = hlist_entry(tt_removed_node,\n\t\t\t\t       struct batadv_tt_global_entry,\n\t\t\t\t       common.hash_entry);\n\tbatadv_tt_global_entry_put(tt_removed_entry);\n}\n\n \nbool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,\n\t\t\t unsigned short vid, int ifindex, u32 mark)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\n\tstruct batadv_tt_local_entry *tt_local;\n\tstruct batadv_tt_global_entry *tt_global = NULL;\n\tstruct net *net = dev_net(soft_iface);\n\tstruct batadv_softif_vlan *vlan;\n\tstruct net_device *in_dev = NULL;\n\tstruct batadv_hard_iface *in_hardif = NULL;\n\tstruct hlist_head *head;\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\tint hash_added, table_size, packet_size_max;\n\tbool ret = false;\n\tbool roamed_back = false;\n\tu8 remote_flags;\n\tu32 match_mark;\n\n\tif (ifindex != BATADV_NULL_IFINDEX)\n\t\tin_dev = dev_get_by_index(net, ifindex);\n\n\tif (in_dev)\n\t\tin_hardif = batadv_hardif_get_by_netdev(in_dev);\n\n\ttt_local = batadv_tt_local_hash_find(bat_priv, addr, vid);\n\n\tif (!is_multicast_ether_addr(addr))\n\t\ttt_global = batadv_tt_global_hash_find(bat_priv, addr, vid);\n\n\tif (tt_local) {\n\t\ttt_local->last_seen = jiffies;\n\t\tif (tt_local->common.flags & BATADV_TT_CLIENT_PENDING) {\n\t\t\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t\t\t   \"Re-adding pending client %pM (vid: %d)\\n\",\n\t\t\t\t   addr, batadv_print_vid(vid));\n\t\t\t \n\t\t\ttt_local->common.flags &= ~BATADV_TT_CLIENT_PENDING;\n\t\t\tgoto add_event;\n\t\t}\n\n\t\tif (tt_local->common.flags & BATADV_TT_CLIENT_ROAM) {\n\t\t\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t\t\t   \"Roaming client %pM (vid: %d) came back to its original location\\n\",\n\t\t\t\t   addr, batadv_print_vid(vid));\n\t\t\t \n\t\t\ttt_local->common.flags &= ~BATADV_TT_CLIENT_ROAM;\n\t\t\troamed_back = true;\n\t\t}\n\t\tgoto check_roaming;\n\t}\n\n\t \n\ttable_size = batadv_tt_local_table_transmit_size(bat_priv);\n\ttable_size += batadv_tt_len(1);\n\tpacket_size_max = atomic_read(&bat_priv->packet_size_max);\n\tif (table_size > packet_size_max) {\n\t\tnet_ratelimited_function(batadv_info, soft_iface,\n\t\t\t\t\t \"Local translation table size (%i) exceeds maximum packet size (%i); Ignoring new local tt entry: %pM\\n\",\n\t\t\t\t\t table_size, packet_size_max, addr);\n\t\tgoto out;\n\t}\n\n\ttt_local = kmem_cache_alloc(batadv_tl_cache, GFP_ATOMIC);\n\tif (!tt_local)\n\t\tgoto out;\n\n\t \n\tvlan = batadv_softif_vlan_get(bat_priv, vid);\n\tif (!vlan) {\n\t\tnet_ratelimited_function(batadv_info, soft_iface,\n\t\t\t\t\t \"adding TT local entry %pM to non-existent VLAN %d\\n\",\n\t\t\t\t\t addr, batadv_print_vid(vid));\n\t\tkmem_cache_free(batadv_tl_cache, tt_local);\n\t\ttt_local = NULL;\n\t\tgoto out;\n\t}\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Creating new local tt entry: %pM (vid: %d, ttvn: %d)\\n\",\n\t\t   addr, batadv_print_vid(vid),\n\t\t   (u8)atomic_read(&bat_priv->tt.vn));\n\n\tether_addr_copy(tt_local->common.addr, addr);\n\t \n\ttt_local->common.flags = BATADV_TT_CLIENT_NEW;\n\ttt_local->common.vid = vid;\n\tif (batadv_is_wifi_hardif(in_hardif))\n\t\ttt_local->common.flags |= BATADV_TT_CLIENT_WIFI;\n\tkref_init(&tt_local->common.refcount);\n\ttt_local->last_seen = jiffies;\n\ttt_local->common.added_at = tt_local->last_seen;\n\ttt_local->vlan = vlan;\n\n\t \n\tif (batadv_compare_eth(addr, soft_iface->dev_addr) ||\n\t    is_multicast_ether_addr(addr))\n\t\ttt_local->common.flags |= BATADV_TT_CLIENT_NOPURGE;\n\n\tkref_get(&tt_local->common.refcount);\n\thash_added = batadv_hash_add(bat_priv->tt.local_hash, batadv_compare_tt,\n\t\t\t\t     batadv_choose_tt, &tt_local->common,\n\t\t\t\t     &tt_local->common.hash_entry);\n\n\tif (unlikely(hash_added != 0)) {\n\t\t \n\t\tbatadv_tt_local_entry_put(tt_local);\n\t\tgoto out;\n\t}\n\nadd_event:\n\tbatadv_tt_local_event(bat_priv, tt_local, BATADV_NO_FLAGS);\n\ncheck_roaming:\n\t \n\tif (tt_global && !(tt_global->common.flags & BATADV_TT_CLIENT_ROAM)) {\n\t\t \n\t\thead = &tt_global->orig_list;\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(orig_entry, head, list) {\n\t\t\tbatadv_send_roam_adv(bat_priv, tt_global->common.addr,\n\t\t\t\t\t     tt_global->common.vid,\n\t\t\t\t\t     orig_entry->orig_node);\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (roamed_back) {\n\t\t\tbatadv_tt_global_free(bat_priv, tt_global,\n\t\t\t\t\t      \"Roaming canceled\");\n\t\t} else {\n\t\t\t \n\t\t\ttt_global->common.flags |= BATADV_TT_CLIENT_ROAM;\n\t\t\ttt_global->roam_at = jiffies;\n\t\t}\n\t}\n\n\t \n\tremote_flags = tt_local->common.flags & BATADV_TT_REMOTE_MASK;\n\n\tif (batadv_is_wifi_hardif(in_hardif))\n\t\ttt_local->common.flags |= BATADV_TT_CLIENT_WIFI;\n\telse\n\t\ttt_local->common.flags &= ~BATADV_TT_CLIENT_WIFI;\n\n\t \n\tmatch_mark = (mark & bat_priv->isolation_mark_mask);\n\tif (bat_priv->isolation_mark_mask &&\n\t    match_mark == bat_priv->isolation_mark)\n\t\ttt_local->common.flags |= BATADV_TT_CLIENT_ISOLA;\n\telse\n\t\ttt_local->common.flags &= ~BATADV_TT_CLIENT_ISOLA;\n\n\t \n\tif (remote_flags ^ (tt_local->common.flags & BATADV_TT_REMOTE_MASK))\n\t\tbatadv_tt_local_event(bat_priv, tt_local, BATADV_NO_FLAGS);\n\n\tret = true;\nout:\n\tbatadv_hardif_put(in_hardif);\n\tdev_put(in_dev);\n\tbatadv_tt_local_entry_put(tt_local);\n\tbatadv_tt_global_entry_put(tt_global);\n\treturn ret;\n}\n\n \nstatic u16\nbatadv_tt_prepare_tvlv_global_data(struct batadv_orig_node *orig_node,\n\t\t\t\t   struct batadv_tvlv_tt_data **tt_data,\n\t\t\t\t   struct batadv_tvlv_tt_change **tt_change,\n\t\t\t\t   s32 *tt_len)\n{\n\tu16 num_vlan = 0;\n\tu16 num_entries = 0;\n\tu16 change_offset;\n\tu16 tvlv_len;\n\tstruct batadv_tvlv_tt_vlan_data *tt_vlan;\n\tstruct batadv_orig_node_vlan *vlan;\n\tu8 *tt_change_ptr;\n\n\tspin_lock_bh(&orig_node->vlan_list_lock);\n\thlist_for_each_entry(vlan, &orig_node->vlan_list, list) {\n\t\tnum_vlan++;\n\t\tnum_entries += atomic_read(&vlan->tt.num_entries);\n\t}\n\n\tchange_offset = sizeof(**tt_data);\n\tchange_offset += num_vlan * sizeof(*tt_vlan);\n\n\t \n\tif (*tt_len < 0)\n\t\t*tt_len = batadv_tt_len(num_entries);\n\n\ttvlv_len = *tt_len;\n\ttvlv_len += change_offset;\n\n\t*tt_data = kmalloc(tvlv_len, GFP_ATOMIC);\n\tif (!*tt_data) {\n\t\t*tt_len = 0;\n\t\tgoto out;\n\t}\n\n\t(*tt_data)->flags = BATADV_NO_FLAGS;\n\t(*tt_data)->ttvn = atomic_read(&orig_node->last_ttvn);\n\t(*tt_data)->num_vlan = htons(num_vlan);\n\n\ttt_vlan = (struct batadv_tvlv_tt_vlan_data *)(*tt_data + 1);\n\thlist_for_each_entry(vlan, &orig_node->vlan_list, list) {\n\t\ttt_vlan->vid = htons(vlan->vid);\n\t\ttt_vlan->crc = htonl(vlan->tt.crc);\n\t\ttt_vlan->reserved = 0;\n\n\t\ttt_vlan++;\n\t}\n\n\ttt_change_ptr = (u8 *)*tt_data + change_offset;\n\t*tt_change = (struct batadv_tvlv_tt_change *)tt_change_ptr;\n\nout:\n\tspin_unlock_bh(&orig_node->vlan_list_lock);\n\treturn tvlv_len;\n}\n\n \nstatic u16\nbatadv_tt_prepare_tvlv_local_data(struct batadv_priv *bat_priv,\n\t\t\t\t  struct batadv_tvlv_tt_data **tt_data,\n\t\t\t\t  struct batadv_tvlv_tt_change **tt_change,\n\t\t\t\t  s32 *tt_len)\n{\n\tstruct batadv_tvlv_tt_vlan_data *tt_vlan;\n\tstruct batadv_softif_vlan *vlan;\n\tu16 num_vlan = 0;\n\tu16 vlan_entries = 0;\n\tu16 total_entries = 0;\n\tu16 tvlv_len;\n\tu8 *tt_change_ptr;\n\tint change_offset;\n\n\tspin_lock_bh(&bat_priv->softif_vlan_list_lock);\n\thlist_for_each_entry(vlan, &bat_priv->softif_vlan_list, list) {\n\t\tvlan_entries = atomic_read(&vlan->tt.num_entries);\n\t\tif (vlan_entries < 1)\n\t\t\tcontinue;\n\n\t\tnum_vlan++;\n\t\ttotal_entries += vlan_entries;\n\t}\n\n\tchange_offset = sizeof(**tt_data);\n\tchange_offset += num_vlan * sizeof(*tt_vlan);\n\n\t \n\tif (*tt_len < 0)\n\t\t*tt_len = batadv_tt_len(total_entries);\n\n\ttvlv_len = *tt_len;\n\ttvlv_len += change_offset;\n\n\t*tt_data = kmalloc(tvlv_len, GFP_ATOMIC);\n\tif (!*tt_data) {\n\t\ttvlv_len = 0;\n\t\tgoto out;\n\t}\n\n\t(*tt_data)->flags = BATADV_NO_FLAGS;\n\t(*tt_data)->ttvn = atomic_read(&bat_priv->tt.vn);\n\t(*tt_data)->num_vlan = htons(num_vlan);\n\n\ttt_vlan = (struct batadv_tvlv_tt_vlan_data *)(*tt_data + 1);\n\thlist_for_each_entry(vlan, &bat_priv->softif_vlan_list, list) {\n\t\tvlan_entries = atomic_read(&vlan->tt.num_entries);\n\t\tif (vlan_entries < 1)\n\t\t\tcontinue;\n\n\t\ttt_vlan->vid = htons(vlan->vid);\n\t\ttt_vlan->crc = htonl(vlan->tt.crc);\n\t\ttt_vlan->reserved = 0;\n\n\t\ttt_vlan++;\n\t}\n\n\ttt_change_ptr = (u8 *)*tt_data + change_offset;\n\t*tt_change = (struct batadv_tvlv_tt_change *)tt_change_ptr;\n\nout:\n\tspin_unlock_bh(&bat_priv->softif_vlan_list_lock);\n\treturn tvlv_len;\n}\n\n \nstatic void batadv_tt_tvlv_container_update(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_tt_change_node *entry, *safe;\n\tstruct batadv_tvlv_tt_data *tt_data;\n\tstruct batadv_tvlv_tt_change *tt_change;\n\tint tt_diff_len, tt_change_len = 0;\n\tint tt_diff_entries_num = 0;\n\tint tt_diff_entries_count = 0;\n\tu16 tvlv_len;\n\n\ttt_diff_entries_num = atomic_read(&bat_priv->tt.local_changes);\n\ttt_diff_len = batadv_tt_len(tt_diff_entries_num);\n\n\t \n\tif (tt_diff_len > bat_priv->soft_iface->mtu)\n\t\ttt_diff_len = 0;\n\n\ttvlv_len = batadv_tt_prepare_tvlv_local_data(bat_priv, &tt_data,\n\t\t\t\t\t\t     &tt_change, &tt_diff_len);\n\tif (!tvlv_len)\n\t\treturn;\n\n\ttt_data->flags = BATADV_TT_OGM_DIFF;\n\n\tif (tt_diff_len == 0)\n\t\tgoto container_register;\n\n\tspin_lock_bh(&bat_priv->tt.changes_list_lock);\n\tatomic_set(&bat_priv->tt.local_changes, 0);\n\n\tlist_for_each_entry_safe(entry, safe, &bat_priv->tt.changes_list,\n\t\t\t\t list) {\n\t\tif (tt_diff_entries_count < tt_diff_entries_num) {\n\t\t\tmemcpy(tt_change + tt_diff_entries_count,\n\t\t\t       &entry->change,\n\t\t\t       sizeof(struct batadv_tvlv_tt_change));\n\t\t\ttt_diff_entries_count++;\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(batadv_tt_change_cache, entry);\n\t}\n\tspin_unlock_bh(&bat_priv->tt.changes_list_lock);\n\n\t \n\tspin_lock_bh(&bat_priv->tt.last_changeset_lock);\n\tkfree(bat_priv->tt.last_changeset);\n\tbat_priv->tt.last_changeset_len = 0;\n\tbat_priv->tt.last_changeset = NULL;\n\ttt_change_len = batadv_tt_len(tt_diff_entries_count);\n\t \n\tif (tt_diff_entries_count > 0) {\n\t\t \n\t\tbat_priv->tt.last_changeset = kzalloc(tt_diff_len, GFP_ATOMIC);\n\t\tif (bat_priv->tt.last_changeset) {\n\t\t\tmemcpy(bat_priv->tt.last_changeset,\n\t\t\t       tt_change, tt_change_len);\n\t\t\tbat_priv->tt.last_changeset_len = tt_diff_len;\n\t\t}\n\t}\n\tspin_unlock_bh(&bat_priv->tt.last_changeset_lock);\n\ncontainer_register:\n\tbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_TT, 1, tt_data,\n\t\t\t\t       tvlv_len);\n\tkfree(tt_data);\n}\n\n \nstatic int\nbatadv_tt_local_dump_entry(struct sk_buff *msg, u32 portid,\n\t\t\t   struct netlink_callback *cb,\n\t\t\t   struct batadv_priv *bat_priv,\n\t\t\t   struct batadv_tt_common_entry *common)\n{\n\tvoid *hdr;\n\tstruct batadv_softif_vlan *vlan;\n\tstruct batadv_tt_local_entry *local;\n\tunsigned int last_seen_msecs;\n\tu32 crc;\n\n\tlocal = container_of(common, struct batadv_tt_local_entry, common);\n\tlast_seen_msecs = jiffies_to_msecs(jiffies - local->last_seen);\n\n\tvlan = batadv_softif_vlan_get(bat_priv, common->vid);\n\tif (!vlan)\n\t\treturn 0;\n\n\tcrc = vlan->tt.crc;\n\n\tbatadv_softif_vlan_put(vlan);\n\n\thdr = genlmsg_put(msg, portid, cb->nlh->nlmsg_seq,\n\t\t\t  &batadv_netlink_family,  NLM_F_MULTI,\n\t\t\t  BATADV_CMD_GET_TRANSTABLE_LOCAL);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put(msg, BATADV_ATTR_TT_ADDRESS, ETH_ALEN, common->addr) ||\n\t    nla_put_u32(msg, BATADV_ATTR_TT_CRC32, crc) ||\n\t    nla_put_u16(msg, BATADV_ATTR_TT_VID, common->vid) ||\n\t    nla_put_u32(msg, BATADV_ATTR_TT_FLAGS, common->flags))\n\t\tgoto nla_put_failure;\n\n\tif (!(common->flags & BATADV_TT_CLIENT_NOPURGE) &&\n\t    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS, last_seen_msecs))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int\nbatadv_tt_local_dump_bucket(struct sk_buff *msg, u32 portid,\n\t\t\t    struct netlink_callback *cb,\n\t\t\t    struct batadv_priv *bat_priv,\n\t\t\t    struct batadv_hashtable *hash, unsigned int bucket,\n\t\t\t    int *idx_s)\n{\n\tstruct batadv_tt_common_entry *common;\n\tint idx = 0;\n\n\tspin_lock_bh(&hash->list_locks[bucket]);\n\tcb->seq = atomic_read(&hash->generation) << 1 | 1;\n\n\thlist_for_each_entry(common, &hash->table[bucket], hash_entry) {\n\t\tif (idx++ < *idx_s)\n\t\t\tcontinue;\n\n\t\tif (batadv_tt_local_dump_entry(msg, portid, cb, bat_priv,\n\t\t\t\t\t       common)) {\n\t\t\tspin_unlock_bh(&hash->list_locks[bucket]);\n\t\t\t*idx_s = idx - 1;\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\tspin_unlock_bh(&hash->list_locks[bucket]);\n\n\t*idx_s = 0;\n\treturn 0;\n}\n\n \nint batadv_tt_local_dump(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct net_device *soft_iface;\n\tstruct batadv_priv *bat_priv;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_hashtable *hash;\n\tint ret;\n\tint ifindex;\n\tint bucket = cb->args[0];\n\tint idx = cb->args[1];\n\tint portid = NETLINK_CB(cb->skb).portid;\n\n\tifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);\n\tif (!ifindex)\n\t\treturn -EINVAL;\n\n\tsoft_iface = dev_get_by_index(net, ifindex);\n\tif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tbat_priv = netdev_priv(soft_iface);\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\thash = bat_priv->tt.local_hash;\n\n\twhile (bucket < hash->size) {\n\t\tif (batadv_tt_local_dump_bucket(msg, portid, cb, bat_priv,\n\t\t\t\t\t\thash, bucket, &idx))\n\t\t\tbreak;\n\n\t\tbucket++;\n\t}\n\n\tret = msg->len;\n\n out:\n\tbatadv_hardif_put(primary_if);\n\tdev_put(soft_iface);\n\n\tcb->args[0] = bucket;\n\tcb->args[1] = idx;\n\n\treturn ret;\n}\n\nstatic void\nbatadv_tt_local_set_pending(struct batadv_priv *bat_priv,\n\t\t\t    struct batadv_tt_local_entry *tt_local_entry,\n\t\t\t    u16 flags, const char *message)\n{\n\tbatadv_tt_local_event(bat_priv, tt_local_entry, flags);\n\n\t \n\ttt_local_entry->common.flags |= BATADV_TT_CLIENT_PENDING;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Local tt entry (%pM, vid: %d) pending to be removed: %s\\n\",\n\t\t   tt_local_entry->common.addr,\n\t\t   batadv_print_vid(tt_local_entry->common.vid), message);\n}\n\n \nu16 batadv_tt_local_remove(struct batadv_priv *bat_priv, const u8 *addr,\n\t\t\t   unsigned short vid, const char *message,\n\t\t\t   bool roaming)\n{\n\tstruct batadv_tt_local_entry *tt_removed_entry;\n\tstruct batadv_tt_local_entry *tt_local_entry;\n\tu16 flags, curr_flags = BATADV_NO_FLAGS;\n\tstruct hlist_node *tt_removed_node;\n\n\ttt_local_entry = batadv_tt_local_hash_find(bat_priv, addr, vid);\n\tif (!tt_local_entry)\n\t\tgoto out;\n\n\tcurr_flags = tt_local_entry->common.flags;\n\n\tflags = BATADV_TT_CLIENT_DEL;\n\t \n\tif (roaming) {\n\t\tflags |= BATADV_TT_CLIENT_ROAM;\n\t\t \n\t\ttt_local_entry->common.flags |= BATADV_TT_CLIENT_ROAM;\n\t}\n\n\tif (!(tt_local_entry->common.flags & BATADV_TT_CLIENT_NEW)) {\n\t\tbatadv_tt_local_set_pending(bat_priv, tt_local_entry, flags,\n\t\t\t\t\t    message);\n\t\tgoto out;\n\t}\n\t \n\tbatadv_tt_local_event(bat_priv, tt_local_entry, BATADV_TT_CLIENT_DEL);\n\n\ttt_removed_node = batadv_hash_remove(bat_priv->tt.local_hash,\n\t\t\t\t\t     batadv_compare_tt,\n\t\t\t\t\t     batadv_choose_tt,\n\t\t\t\t\t     &tt_local_entry->common);\n\tif (!tt_removed_node)\n\t\tgoto out;\n\n\t \n\ttt_removed_entry = hlist_entry(tt_removed_node,\n\t\t\t\t       struct batadv_tt_local_entry,\n\t\t\t\t       common.hash_entry);\n\tbatadv_tt_local_entry_put(tt_removed_entry);\n\nout:\n\tbatadv_tt_local_entry_put(tt_local_entry);\n\n\treturn curr_flags;\n}\n\n \nstatic void batadv_tt_local_purge_list(struct batadv_priv *bat_priv,\n\t\t\t\t       struct hlist_head *head,\n\t\t\t\t       int timeout)\n{\n\tstruct batadv_tt_local_entry *tt_local_entry;\n\tstruct batadv_tt_common_entry *tt_common_entry;\n\tstruct hlist_node *node_tmp;\n\n\thlist_for_each_entry_safe(tt_common_entry, node_tmp, head,\n\t\t\t\t  hash_entry) {\n\t\ttt_local_entry = container_of(tt_common_entry,\n\t\t\t\t\t      struct batadv_tt_local_entry,\n\t\t\t\t\t      common);\n\t\tif (tt_local_entry->common.flags & BATADV_TT_CLIENT_NOPURGE)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (tt_local_entry->common.flags & BATADV_TT_CLIENT_PENDING)\n\t\t\tcontinue;\n\n\t\tif (!batadv_has_timed_out(tt_local_entry->last_seen, timeout))\n\t\t\tcontinue;\n\n\t\tbatadv_tt_local_set_pending(bat_priv, tt_local_entry,\n\t\t\t\t\t    BATADV_TT_CLIENT_DEL, \"timed out\");\n\t}\n}\n\n \nstatic void batadv_tt_local_purge(struct batadv_priv *bat_priv,\n\t\t\t\t  int timeout)\n{\n\tstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\n\tstruct hlist_head *head;\n\tspinlock_t *list_lock;  \n\tu32 i;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\t\tlist_lock = &hash->list_locks[i];\n\n\t\tspin_lock_bh(list_lock);\n\t\tbatadv_tt_local_purge_list(bat_priv, head, timeout);\n\t\tspin_unlock_bh(list_lock);\n\t}\n}\n\nstatic void batadv_tt_local_table_free(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_hashtable *hash;\n\tspinlock_t *list_lock;  \n\tstruct batadv_tt_common_entry *tt_common_entry;\n\tstruct batadv_tt_local_entry *tt_local;\n\tstruct hlist_node *node_tmp;\n\tstruct hlist_head *head;\n\tu32 i;\n\n\tif (!bat_priv->tt.local_hash)\n\t\treturn;\n\n\thash = bat_priv->tt.local_hash;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\t\tlist_lock = &hash->list_locks[i];\n\n\t\tspin_lock_bh(list_lock);\n\t\thlist_for_each_entry_safe(tt_common_entry, node_tmp,\n\t\t\t\t\t  head, hash_entry) {\n\t\t\thlist_del_rcu(&tt_common_entry->hash_entry);\n\t\t\ttt_local = container_of(tt_common_entry,\n\t\t\t\t\t\tstruct batadv_tt_local_entry,\n\t\t\t\t\t\tcommon);\n\n\t\t\tbatadv_tt_local_entry_put(tt_local);\n\t\t}\n\t\tspin_unlock_bh(list_lock);\n\t}\n\n\tbatadv_hash_destroy(hash);\n\n\tbat_priv->tt.local_hash = NULL;\n}\n\nstatic int batadv_tt_global_init(struct batadv_priv *bat_priv)\n{\n\tif (bat_priv->tt.global_hash)\n\t\treturn 0;\n\n\tbat_priv->tt.global_hash = batadv_hash_new(1024);\n\n\tif (!bat_priv->tt.global_hash)\n\t\treturn -ENOMEM;\n\n\tbatadv_hash_set_lock_class(bat_priv->tt.global_hash,\n\t\t\t\t   &batadv_tt_global_hash_lock_class_key);\n\n\treturn 0;\n}\n\nstatic void batadv_tt_changes_list_free(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_tt_change_node *entry, *safe;\n\n\tspin_lock_bh(&bat_priv->tt.changes_list_lock);\n\n\tlist_for_each_entry_safe(entry, safe, &bat_priv->tt.changes_list,\n\t\t\t\t list) {\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(batadv_tt_change_cache, entry);\n\t}\n\n\tatomic_set(&bat_priv->tt.local_changes, 0);\n\tspin_unlock_bh(&bat_priv->tt.changes_list_lock);\n}\n\n \nstatic struct batadv_tt_orig_list_entry *\nbatadv_tt_global_orig_entry_find(const struct batadv_tt_global_entry *entry,\n\t\t\t\t const struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_tt_orig_list_entry *tmp_orig_entry, *orig_entry = NULL;\n\tconst struct hlist_head *head;\n\n\trcu_read_lock();\n\thead = &entry->orig_list;\n\thlist_for_each_entry_rcu(tmp_orig_entry, head, list) {\n\t\tif (tmp_orig_entry->orig_node != orig_node)\n\t\t\tcontinue;\n\t\tif (!kref_get_unless_zero(&tmp_orig_entry->refcount))\n\t\t\tcontinue;\n\n\t\torig_entry = tmp_orig_entry;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn orig_entry;\n}\n\n \nstatic bool\nbatadv_tt_global_entry_has_orig(const struct batadv_tt_global_entry *entry,\n\t\t\t\tconst struct batadv_orig_node *orig_node,\n\t\t\t\tu8 *flags)\n{\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\tbool found = false;\n\n\torig_entry = batadv_tt_global_orig_entry_find(entry, orig_node);\n\tif (orig_entry) {\n\t\tfound = true;\n\n\t\tif (flags)\n\t\t\t*flags = orig_entry->flags;\n\n\t\tbatadv_tt_orig_list_entry_put(orig_entry);\n\t}\n\n\treturn found;\n}\n\n \nstatic void\nbatadv_tt_global_sync_flags(struct batadv_tt_global_entry *tt_global)\n{\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\tconst struct hlist_head *head;\n\tu16 flags = BATADV_NO_FLAGS;\n\n\trcu_read_lock();\n\thead = &tt_global->orig_list;\n\thlist_for_each_entry_rcu(orig_entry, head, list)\n\t\tflags |= orig_entry->flags;\n\trcu_read_unlock();\n\n\tflags |= tt_global->common.flags & (~BATADV_TT_SYNC_MASK);\n\ttt_global->common.flags = flags;\n}\n\n \nstatic void\nbatadv_tt_global_orig_entry_add(struct batadv_tt_global_entry *tt_global,\n\t\t\t\tstruct batadv_orig_node *orig_node, int ttvn,\n\t\t\t\tu8 flags)\n{\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\n\tspin_lock_bh(&tt_global->list_lock);\n\n\torig_entry = batadv_tt_global_orig_entry_find(tt_global, orig_node);\n\tif (orig_entry) {\n\t\t \n\t\torig_entry->ttvn = ttvn;\n\t\torig_entry->flags = flags;\n\t\tgoto sync_flags;\n\t}\n\n\torig_entry = kmem_cache_zalloc(batadv_tt_orig_cache, GFP_ATOMIC);\n\tif (!orig_entry)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&orig_entry->list);\n\tkref_get(&orig_node->refcount);\n\tbatadv_tt_global_size_inc(orig_node, tt_global->common.vid);\n\torig_entry->orig_node = orig_node;\n\torig_entry->ttvn = ttvn;\n\torig_entry->flags = flags;\n\tkref_init(&orig_entry->refcount);\n\n\tkref_get(&orig_entry->refcount);\n\thlist_add_head_rcu(&orig_entry->list,\n\t\t\t   &tt_global->orig_list);\n\tatomic_inc(&tt_global->orig_list_count);\n\nsync_flags:\n\tbatadv_tt_global_sync_flags(tt_global);\nout:\n\tbatadv_tt_orig_list_entry_put(orig_entry);\n\n\tspin_unlock_bh(&tt_global->list_lock);\n}\n\n \nstatic bool batadv_tt_global_add(struct batadv_priv *bat_priv,\n\t\t\t\t struct batadv_orig_node *orig_node,\n\t\t\t\t const unsigned char *tt_addr,\n\t\t\t\t unsigned short vid, u16 flags, u8 ttvn)\n{\n\tstruct batadv_tt_global_entry *tt_global_entry;\n\tstruct batadv_tt_local_entry *tt_local_entry;\n\tbool ret = false;\n\tint hash_added;\n\tstruct batadv_tt_common_entry *common;\n\tu16 local_flags;\n\n\t \n\tif (batadv_bla_is_backbone_gw_orig(bat_priv, orig_node->orig, vid))\n\t\treturn true;\n\n\ttt_global_entry = batadv_tt_global_hash_find(bat_priv, tt_addr, vid);\n\ttt_local_entry = batadv_tt_local_hash_find(bat_priv, tt_addr, vid);\n\n\t \n\tif ((flags & BATADV_TT_CLIENT_TEMP) && tt_local_entry &&\n\t    !(tt_local_entry->common.flags & BATADV_TT_CLIENT_NEW))\n\t\tgoto out;\n\n\tif (!tt_global_entry) {\n\t\ttt_global_entry = kmem_cache_zalloc(batadv_tg_cache,\n\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!tt_global_entry)\n\t\t\tgoto out;\n\n\t\tcommon = &tt_global_entry->common;\n\t\tether_addr_copy(common->addr, tt_addr);\n\t\tcommon->vid = vid;\n\n\t\tif (!is_multicast_ether_addr(common->addr))\n\t\t\tcommon->flags = flags & (~BATADV_TT_SYNC_MASK);\n\n\t\ttt_global_entry->roam_at = 0;\n\t\t \n\t\tif (flags & BATADV_TT_CLIENT_ROAM)\n\t\t\ttt_global_entry->roam_at = jiffies;\n\t\tkref_init(&common->refcount);\n\t\tcommon->added_at = jiffies;\n\n\t\tINIT_HLIST_HEAD(&tt_global_entry->orig_list);\n\t\tatomic_set(&tt_global_entry->orig_list_count, 0);\n\t\tspin_lock_init(&tt_global_entry->list_lock);\n\n\t\tkref_get(&common->refcount);\n\t\thash_added = batadv_hash_add(bat_priv->tt.global_hash,\n\t\t\t\t\t     batadv_compare_tt,\n\t\t\t\t\t     batadv_choose_tt, common,\n\t\t\t\t\t     &common->hash_entry);\n\n\t\tif (unlikely(hash_added != 0)) {\n\t\t\t \n\t\t\tbatadv_tt_global_entry_put(tt_global_entry);\n\t\t\tgoto out_remove;\n\t\t}\n\t} else {\n\t\tcommon = &tt_global_entry->common;\n\t\t \n\t\tif (flags & BATADV_TT_CLIENT_TEMP) {\n\t\t\tif (!(common->flags & BATADV_TT_CLIENT_TEMP))\n\t\t\t\tgoto out;\n\t\t\tif (batadv_tt_global_entry_has_orig(tt_global_entry,\n\t\t\t\t\t\t\t    orig_node, NULL))\n\t\t\t\tgoto out_remove;\n\t\t\tbatadv_tt_global_del_orig_list(tt_global_entry);\n\t\t\tgoto add_orig_entry;\n\t\t}\n\n\t\t \n\t\tif (common->flags & BATADV_TT_CLIENT_TEMP) {\n\t\t\tbatadv_tt_global_del_orig_list(tt_global_entry);\n\t\t\tcommon->flags &= ~BATADV_TT_CLIENT_TEMP;\n\t\t}\n\n\t\t \n\t\tif (!is_multicast_ether_addr(common->addr))\n\t\t\tcommon->flags |= flags & (~BATADV_TT_SYNC_MASK);\n\n\t\t \n\t\tif (common->flags & BATADV_TT_CLIENT_ROAM) {\n\t\t\tbatadv_tt_global_del_orig_list(tt_global_entry);\n\t\t\tcommon->flags &= ~BATADV_TT_CLIENT_ROAM;\n\t\t\ttt_global_entry->roam_at = 0;\n\t\t}\n\t}\nadd_orig_entry:\n\t \n\tbatadv_tt_global_orig_entry_add(tt_global_entry, orig_node, ttvn,\n\t\t\t\t\tflags & BATADV_TT_SYNC_MASK);\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Creating new global tt entry: %pM (vid: %d, via %pM)\\n\",\n\t\t   common->addr, batadv_print_vid(common->vid),\n\t\t   orig_node->orig);\n\tret = true;\n\nout_remove:\n\t \n\tif (is_multicast_ether_addr(tt_addr))\n\t\tgoto out;\n\n\t \n\tlocal_flags = batadv_tt_local_remove(bat_priv, tt_addr, vid,\n\t\t\t\t\t     \"global tt received\",\n\t\t\t\t\t     flags & BATADV_TT_CLIENT_ROAM);\n\ttt_global_entry->common.flags |= local_flags & BATADV_TT_CLIENT_WIFI;\n\n\tif (!(flags & BATADV_TT_CLIENT_ROAM))\n\t\t \n\t\ttt_global_entry->common.flags &= ~BATADV_TT_CLIENT_ROAM;\n\nout:\n\tbatadv_tt_global_entry_put(tt_global_entry);\n\tbatadv_tt_local_entry_put(tt_local_entry);\n\treturn ret;\n}\n\n \nstatic struct batadv_tt_orig_list_entry *\nbatadv_transtable_best_orig(struct batadv_priv *bat_priv,\n\t\t\t    struct batadv_tt_global_entry *tt_global_entry)\n{\n\tstruct batadv_neigh_node *router, *best_router = NULL;\n\tstruct batadv_algo_ops *bao = bat_priv->algo_ops;\n\tstruct hlist_head *head;\n\tstruct batadv_tt_orig_list_entry *orig_entry, *best_entry = NULL;\n\n\thead = &tt_global_entry->orig_list;\n\thlist_for_each_entry_rcu(orig_entry, head, list) {\n\t\trouter = batadv_orig_router_get(orig_entry->orig_node,\n\t\t\t\t\t\tBATADV_IF_DEFAULT);\n\t\tif (!router)\n\t\t\tcontinue;\n\n\t\tif (best_router &&\n\t\t    bao->neigh.cmp(router, BATADV_IF_DEFAULT, best_router,\n\t\t\t\t   BATADV_IF_DEFAULT) <= 0) {\n\t\t\tbatadv_neigh_node_put(router);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbatadv_neigh_node_put(best_router);\n\n\t\tbest_entry = orig_entry;\n\t\tbest_router = router;\n\t}\n\n\tbatadv_neigh_node_put(best_router);\n\n\treturn best_entry;\n}\n\n \nstatic int\nbatadv_tt_global_dump_subentry(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t       struct batadv_tt_common_entry *common,\n\t\t\t       struct batadv_tt_orig_list_entry *orig,\n\t\t\t       bool best)\n{\n\tu16 flags = (common->flags & (~BATADV_TT_SYNC_MASK)) | orig->flags;\n\tvoid *hdr;\n\tstruct batadv_orig_node_vlan *vlan;\n\tu8 last_ttvn;\n\tu32 crc;\n\n\tvlan = batadv_orig_node_vlan_get(orig->orig_node,\n\t\t\t\t\t common->vid);\n\tif (!vlan)\n\t\treturn 0;\n\n\tcrc = vlan->tt.crc;\n\n\tbatadv_orig_node_vlan_put(vlan);\n\n\thdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,\n\t\t\t  NLM_F_MULTI,\n\t\t\t  BATADV_CMD_GET_TRANSTABLE_GLOBAL);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tlast_ttvn = atomic_read(&orig->orig_node->last_ttvn);\n\n\tif (nla_put(msg, BATADV_ATTR_TT_ADDRESS, ETH_ALEN, common->addr) ||\n\t    nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,\n\t\t    orig->orig_node->orig) ||\n\t    nla_put_u8(msg, BATADV_ATTR_TT_TTVN, orig->ttvn) ||\n\t    nla_put_u8(msg, BATADV_ATTR_TT_LAST_TTVN, last_ttvn) ||\n\t    nla_put_u32(msg, BATADV_ATTR_TT_CRC32, crc) ||\n\t    nla_put_u16(msg, BATADV_ATTR_TT_VID, common->vid) ||\n\t    nla_put_u32(msg, BATADV_ATTR_TT_FLAGS, flags))\n\t\tgoto nla_put_failure;\n\n\tif (best && nla_put_flag(msg, BATADV_ATTR_FLAG_BEST))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int\nbatadv_tt_global_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t    struct batadv_priv *bat_priv,\n\t\t\t    struct batadv_tt_common_entry *common, int *sub_s)\n{\n\tstruct batadv_tt_orig_list_entry *orig_entry, *best_entry;\n\tstruct batadv_tt_global_entry *global;\n\tstruct hlist_head *head;\n\tint sub = 0;\n\tbool best;\n\n\tglobal = container_of(common, struct batadv_tt_global_entry, common);\n\tbest_entry = batadv_transtable_best_orig(bat_priv, global);\n\thead = &global->orig_list;\n\n\thlist_for_each_entry_rcu(orig_entry, head, list) {\n\t\tif (sub++ < *sub_s)\n\t\t\tcontinue;\n\n\t\tbest = (orig_entry == best_entry);\n\n\t\tif (batadv_tt_global_dump_subentry(msg, portid, seq, common,\n\t\t\t\t\t\t   orig_entry, best)) {\n\t\t\t*sub_s = sub - 1;\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t*sub_s = 0;\n\treturn 0;\n}\n\n \nstatic int\nbatadv_tt_global_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t     struct batadv_priv *bat_priv,\n\t\t\t     struct hlist_head *head, int *idx_s, int *sub)\n{\n\tstruct batadv_tt_common_entry *common;\n\tint idx = 0;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(common, head, hash_entry) {\n\t\tif (idx++ < *idx_s)\n\t\t\tcontinue;\n\n\t\tif (batadv_tt_global_dump_entry(msg, portid, seq, bat_priv,\n\t\t\t\t\t\tcommon, sub)) {\n\t\t\trcu_read_unlock();\n\t\t\t*idx_s = idx - 1;\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t*idx_s = 0;\n\t*sub = 0;\n\treturn 0;\n}\n\n \nint batadv_tt_global_dump(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct net_device *soft_iface;\n\tstruct batadv_priv *bat_priv;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_hashtable *hash;\n\tstruct hlist_head *head;\n\tint ret;\n\tint ifindex;\n\tint bucket = cb->args[0];\n\tint idx = cb->args[1];\n\tint sub = cb->args[2];\n\tint portid = NETLINK_CB(cb->skb).portid;\n\n\tifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);\n\tif (!ifindex)\n\t\treturn -EINVAL;\n\n\tsoft_iface = dev_get_by_index(net, ifindex);\n\tif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tbat_priv = netdev_priv(soft_iface);\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\thash = bat_priv->tt.global_hash;\n\n\twhile (bucket < hash->size) {\n\t\thead = &hash->table[bucket];\n\n\t\tif (batadv_tt_global_dump_bucket(msg, portid,\n\t\t\t\t\t\t cb->nlh->nlmsg_seq, bat_priv,\n\t\t\t\t\t\t head, &idx, &sub))\n\t\t\tbreak;\n\n\t\tbucket++;\n\t}\n\n\tret = msg->len;\n\n out:\n\tbatadv_hardif_put(primary_if);\n\tdev_put(soft_iface);\n\n\tcb->args[0] = bucket;\n\tcb->args[1] = idx;\n\tcb->args[2] = sub;\n\n\treturn ret;\n}\n\n \nstatic void\n_batadv_tt_global_del_orig_entry(struct batadv_tt_global_entry *tt_global_entry,\n\t\t\t\t struct batadv_tt_orig_list_entry *orig_entry)\n{\n\tlockdep_assert_held(&tt_global_entry->list_lock);\n\n\tbatadv_tt_global_size_dec(orig_entry->orig_node,\n\t\t\t\t  tt_global_entry->common.vid);\n\tatomic_dec(&tt_global_entry->orig_list_count);\n\t \n\thlist_del_rcu(&orig_entry->list);\n\tbatadv_tt_orig_list_entry_put(orig_entry);\n}\n\n \nstatic void\nbatadv_tt_global_del_orig_list(struct batadv_tt_global_entry *tt_global_entry)\n{\n\tstruct hlist_head *head;\n\tstruct hlist_node *safe;\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\n\tspin_lock_bh(&tt_global_entry->list_lock);\n\thead = &tt_global_entry->orig_list;\n\thlist_for_each_entry_safe(orig_entry, safe, head, list)\n\t\t_batadv_tt_global_del_orig_entry(tt_global_entry, orig_entry);\n\tspin_unlock_bh(&tt_global_entry->list_lock);\n}\n\n \nstatic void\nbatadv_tt_global_del_orig_node(struct batadv_priv *bat_priv,\n\t\t\t       struct batadv_tt_global_entry *tt_global_entry,\n\t\t\t       struct batadv_orig_node *orig_node,\n\t\t\t       const char *message)\n{\n\tstruct hlist_head *head;\n\tstruct hlist_node *safe;\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\tunsigned short vid;\n\n\tspin_lock_bh(&tt_global_entry->list_lock);\n\thead = &tt_global_entry->orig_list;\n\thlist_for_each_entry_safe(orig_entry, safe, head, list) {\n\t\tif (orig_entry->orig_node == orig_node) {\n\t\t\tvid = tt_global_entry->common.vid;\n\t\t\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t\t\t   \"Deleting %pM from global tt entry %pM (vid: %d): %s\\n\",\n\t\t\t\t   orig_node->orig,\n\t\t\t\t   tt_global_entry->common.addr,\n\t\t\t\t   batadv_print_vid(vid), message);\n\t\t\t_batadv_tt_global_del_orig_entry(tt_global_entry,\n\t\t\t\t\t\t\t orig_entry);\n\t\t}\n\t}\n\tspin_unlock_bh(&tt_global_entry->list_lock);\n}\n\n \nstatic void\nbatadv_tt_global_del_roaming(struct batadv_priv *bat_priv,\n\t\t\t     struct batadv_tt_global_entry *tt_global_entry,\n\t\t\t     struct batadv_orig_node *orig_node,\n\t\t\t     const char *message)\n{\n\tbool last_entry = true;\n\tstruct hlist_head *head;\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\n\t \n\n\trcu_read_lock();\n\thead = &tt_global_entry->orig_list;\n\thlist_for_each_entry_rcu(orig_entry, head, list) {\n\t\tif (orig_entry->orig_node != orig_node) {\n\t\t\tlast_entry = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (last_entry) {\n\t\t \n\t\ttt_global_entry->common.flags |= BATADV_TT_CLIENT_ROAM;\n\t\ttt_global_entry->roam_at = jiffies;\n\t} else {\n\t\t \n\t\tbatadv_tt_global_del_orig_node(bat_priv, tt_global_entry,\n\t\t\t\t\t       orig_node, message);\n\t}\n}\n\n \nstatic void batadv_tt_global_del(struct batadv_priv *bat_priv,\n\t\t\t\t struct batadv_orig_node *orig_node,\n\t\t\t\t const unsigned char *addr, unsigned short vid,\n\t\t\t\t const char *message, bool roaming)\n{\n\tstruct batadv_tt_global_entry *tt_global_entry;\n\tstruct batadv_tt_local_entry *local_entry = NULL;\n\n\ttt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\n\tif (!tt_global_entry)\n\t\tgoto out;\n\n\tif (!roaming) {\n\t\tbatadv_tt_global_del_orig_node(bat_priv, tt_global_entry,\n\t\t\t\t\t       orig_node, message);\n\n\t\tif (hlist_empty(&tt_global_entry->orig_list))\n\t\t\tbatadv_tt_global_free(bat_priv, tt_global_entry,\n\t\t\t\t\t      message);\n\n\t\tgoto out;\n\t}\n\n\t \n\tlocal_entry = batadv_tt_local_hash_find(bat_priv,\n\t\t\t\t\t\ttt_global_entry->common.addr,\n\t\t\t\t\t\tvid);\n\tif (local_entry) {\n\t\t \n\t\tbatadv_tt_global_del_orig_list(tt_global_entry);\n\t\tbatadv_tt_global_free(bat_priv, tt_global_entry, message);\n\t} else {\n\t\t \n\t\tbatadv_tt_global_del_roaming(bat_priv, tt_global_entry,\n\t\t\t\t\t     orig_node, message);\n\t}\n\nout:\n\tbatadv_tt_global_entry_put(tt_global_entry);\n\tbatadv_tt_local_entry_put(local_entry);\n}\n\n \nvoid batadv_tt_global_del_orig(struct batadv_priv *bat_priv,\n\t\t\t       struct batadv_orig_node *orig_node,\n\t\t\t       s32 match_vid,\n\t\t\t       const char *message)\n{\n\tstruct batadv_tt_global_entry *tt_global;\n\tstruct batadv_tt_common_entry *tt_common_entry;\n\tu32 i;\n\tstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\n\tstruct hlist_node *safe;\n\tstruct hlist_head *head;\n\tspinlock_t *list_lock;  \n\tunsigned short vid;\n\n\tif (!hash)\n\t\treturn;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\t\tlist_lock = &hash->list_locks[i];\n\n\t\tspin_lock_bh(list_lock);\n\t\thlist_for_each_entry_safe(tt_common_entry, safe,\n\t\t\t\t\t  head, hash_entry) {\n\t\t\t \n\t\t\tif (match_vid >= 0 && tt_common_entry->vid != match_vid)\n\t\t\t\tcontinue;\n\n\t\t\ttt_global = container_of(tt_common_entry,\n\t\t\t\t\t\t struct batadv_tt_global_entry,\n\t\t\t\t\t\t common);\n\n\t\t\tbatadv_tt_global_del_orig_node(bat_priv, tt_global,\n\t\t\t\t\t\t       orig_node, message);\n\n\t\t\tif (hlist_empty(&tt_global->orig_list)) {\n\t\t\t\tvid = tt_global->common.vid;\n\t\t\t\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t\t\t\t   \"Deleting global tt entry %pM (vid: %d): %s\\n\",\n\t\t\t\t\t   tt_global->common.addr,\n\t\t\t\t\t   batadv_print_vid(vid), message);\n\t\t\t\thlist_del_rcu(&tt_common_entry->hash_entry);\n\t\t\t\tbatadv_tt_global_entry_put(tt_global);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(list_lock);\n\t}\n\tclear_bit(BATADV_ORIG_CAPA_HAS_TT, &orig_node->capa_initialized);\n}\n\nstatic bool batadv_tt_global_to_purge(struct batadv_tt_global_entry *tt_global,\n\t\t\t\t      char **msg)\n{\n\tbool purge = false;\n\tunsigned long roam_timeout = BATADV_TT_CLIENT_ROAM_TIMEOUT;\n\tunsigned long temp_timeout = BATADV_TT_CLIENT_TEMP_TIMEOUT;\n\n\tif ((tt_global->common.flags & BATADV_TT_CLIENT_ROAM) &&\n\t    batadv_has_timed_out(tt_global->roam_at, roam_timeout)) {\n\t\tpurge = true;\n\t\t*msg = \"Roaming timeout\\n\";\n\t}\n\n\tif ((tt_global->common.flags & BATADV_TT_CLIENT_TEMP) &&\n\t    batadv_has_timed_out(tt_global->common.added_at, temp_timeout)) {\n\t\tpurge = true;\n\t\t*msg = \"Temporary client timeout\\n\";\n\t}\n\n\treturn purge;\n}\n\nstatic void batadv_tt_global_purge(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\n\tstruct hlist_head *head;\n\tstruct hlist_node *node_tmp;\n\tspinlock_t *list_lock;  \n\tu32 i;\n\tchar *msg = NULL;\n\tstruct batadv_tt_common_entry *tt_common;\n\tstruct batadv_tt_global_entry *tt_global;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\t\tlist_lock = &hash->list_locks[i];\n\n\t\tspin_lock_bh(list_lock);\n\t\thlist_for_each_entry_safe(tt_common, node_tmp, head,\n\t\t\t\t\t  hash_entry) {\n\t\t\ttt_global = container_of(tt_common,\n\t\t\t\t\t\t struct batadv_tt_global_entry,\n\t\t\t\t\t\t common);\n\n\t\t\tif (!batadv_tt_global_to_purge(tt_global, &msg))\n\t\t\t\tcontinue;\n\n\t\t\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t\t\t   \"Deleting global tt entry %pM (vid: %d): %s\\n\",\n\t\t\t\t   tt_global->common.addr,\n\t\t\t\t   batadv_print_vid(tt_global->common.vid),\n\t\t\t\t   msg);\n\n\t\t\thlist_del_rcu(&tt_common->hash_entry);\n\n\t\t\tbatadv_tt_global_entry_put(tt_global);\n\t\t}\n\t\tspin_unlock_bh(list_lock);\n\t}\n}\n\nstatic void batadv_tt_global_table_free(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_hashtable *hash;\n\tspinlock_t *list_lock;  \n\tstruct batadv_tt_common_entry *tt_common_entry;\n\tstruct batadv_tt_global_entry *tt_global;\n\tstruct hlist_node *node_tmp;\n\tstruct hlist_head *head;\n\tu32 i;\n\n\tif (!bat_priv->tt.global_hash)\n\t\treturn;\n\n\thash = bat_priv->tt.global_hash;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\t\tlist_lock = &hash->list_locks[i];\n\n\t\tspin_lock_bh(list_lock);\n\t\thlist_for_each_entry_safe(tt_common_entry, node_tmp,\n\t\t\t\t\t  head, hash_entry) {\n\t\t\thlist_del_rcu(&tt_common_entry->hash_entry);\n\t\t\ttt_global = container_of(tt_common_entry,\n\t\t\t\t\t\t struct batadv_tt_global_entry,\n\t\t\t\t\t\t common);\n\t\t\tbatadv_tt_global_entry_put(tt_global);\n\t\t}\n\t\tspin_unlock_bh(list_lock);\n\t}\n\n\tbatadv_hash_destroy(hash);\n\n\tbat_priv->tt.global_hash = NULL;\n}\n\nstatic bool\n_batadv_is_ap_isolated(struct batadv_tt_local_entry *tt_local_entry,\n\t\t       struct batadv_tt_global_entry *tt_global_entry)\n{\n\tif (tt_local_entry->common.flags & BATADV_TT_CLIENT_WIFI &&\n\t    tt_global_entry->common.flags & BATADV_TT_CLIENT_WIFI)\n\t\treturn true;\n\n\t \n\tif (tt_local_entry->common.flags & BATADV_TT_CLIENT_ISOLA &&\n\t    tt_global_entry->common.flags & BATADV_TT_CLIENT_ISOLA)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstruct batadv_orig_node *batadv_transtable_search(struct batadv_priv *bat_priv,\n\t\t\t\t\t\t  const u8 *src,\n\t\t\t\t\t\t  const u8 *addr,\n\t\t\t\t\t\t  unsigned short vid)\n{\n\tstruct batadv_tt_local_entry *tt_local_entry = NULL;\n\tstruct batadv_tt_global_entry *tt_global_entry = NULL;\n\tstruct batadv_orig_node *orig_node = NULL;\n\tstruct batadv_tt_orig_list_entry *best_entry;\n\n\tif (src && batadv_vlan_ap_isola_get(bat_priv, vid)) {\n\t\ttt_local_entry = batadv_tt_local_hash_find(bat_priv, src, vid);\n\t\tif (!tt_local_entry ||\n\t\t    (tt_local_entry->common.flags & BATADV_TT_CLIENT_PENDING))\n\t\t\tgoto out;\n\t}\n\n\ttt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\n\tif (!tt_global_entry)\n\t\tgoto out;\n\n\t \n\tif (tt_local_entry &&\n\t    _batadv_is_ap_isolated(tt_local_entry, tt_global_entry))\n\t\tgoto out;\n\n\trcu_read_lock();\n\tbest_entry = batadv_transtable_best_orig(bat_priv, tt_global_entry);\n\t \n\tif (best_entry)\n\t\torig_node = best_entry->orig_node;\n\tif (orig_node && !kref_get_unless_zero(&orig_node->refcount))\n\t\torig_node = NULL;\n\trcu_read_unlock();\n\nout:\n\tbatadv_tt_global_entry_put(tt_global_entry);\n\tbatadv_tt_local_entry_put(tt_local_entry);\n\n\treturn orig_node;\n}\n\n \nstatic u32 batadv_tt_global_crc(struct batadv_priv *bat_priv,\n\t\t\t\tstruct batadv_orig_node *orig_node,\n\t\t\t\tunsigned short vid)\n{\n\tstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\n\tstruct batadv_tt_orig_list_entry *tt_orig;\n\tstruct batadv_tt_common_entry *tt_common;\n\tstruct batadv_tt_global_entry *tt_global;\n\tstruct hlist_head *head;\n\tu32 i, crc_tmp, crc = 0;\n\tu8 flags;\n\t__be16 tmp_vid;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(tt_common, head, hash_entry) {\n\t\t\ttt_global = container_of(tt_common,\n\t\t\t\t\t\t struct batadv_tt_global_entry,\n\t\t\t\t\t\t common);\n\t\t\t \n\t\t\tif (tt_common->vid != vid)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (tt_common->flags & BATADV_TT_CLIENT_ROAM)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (tt_common->flags & BATADV_TT_CLIENT_TEMP)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttt_orig = batadv_tt_global_orig_entry_find(tt_global,\n\t\t\t\t\t\t\t\t   orig_node);\n\t\t\tif (!tt_orig)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttmp_vid = htons(tt_common->vid);\n\t\t\tcrc_tmp = crc32c(0, &tmp_vid, sizeof(tmp_vid));\n\n\t\t\t \n\t\t\tflags = tt_orig->flags;\n\t\t\tcrc_tmp = crc32c(crc_tmp, &flags, sizeof(flags));\n\n\t\t\tcrc ^= crc32c(crc_tmp, tt_common->addr, ETH_ALEN);\n\n\t\t\tbatadv_tt_orig_list_entry_put(tt_orig);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\treturn crc;\n}\n\n \nstatic u32 batadv_tt_local_crc(struct batadv_priv *bat_priv,\n\t\t\t       unsigned short vid)\n{\n\tstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\n\tstruct batadv_tt_common_entry *tt_common;\n\tstruct hlist_head *head;\n\tu32 i, crc_tmp, crc = 0;\n\tu8 flags;\n\t__be16 tmp_vid;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(tt_common, head, hash_entry) {\n\t\t\t \n\t\t\tif (tt_common->vid != vid)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (tt_common->flags & BATADV_TT_CLIENT_NEW)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttmp_vid = htons(tt_common->vid);\n\t\t\tcrc_tmp = crc32c(0, &tmp_vid, sizeof(tmp_vid));\n\n\t\t\t \n\t\t\tflags = tt_common->flags & BATADV_TT_SYNC_MASK;\n\t\t\tcrc_tmp = crc32c(crc_tmp, &flags, sizeof(flags));\n\n\t\t\tcrc ^= crc32c(crc_tmp, tt_common->addr, ETH_ALEN);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\treturn crc;\n}\n\n \nstatic void batadv_tt_req_node_release(struct kref *ref)\n{\n\tstruct batadv_tt_req_node *tt_req_node;\n\n\ttt_req_node = container_of(ref, struct batadv_tt_req_node, refcount);\n\n\tkmem_cache_free(batadv_tt_req_cache, tt_req_node);\n}\n\n \nstatic void batadv_tt_req_node_put(struct batadv_tt_req_node *tt_req_node)\n{\n\tif (!tt_req_node)\n\t\treturn;\n\n\tkref_put(&tt_req_node->refcount, batadv_tt_req_node_release);\n}\n\nstatic void batadv_tt_req_list_free(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_tt_req_node *node;\n\tstruct hlist_node *safe;\n\n\tspin_lock_bh(&bat_priv->tt.req_list_lock);\n\n\thlist_for_each_entry_safe(node, safe, &bat_priv->tt.req_list, list) {\n\t\thlist_del_init(&node->list);\n\t\tbatadv_tt_req_node_put(node);\n\t}\n\n\tspin_unlock_bh(&bat_priv->tt.req_list_lock);\n}\n\nstatic void batadv_tt_save_orig_buffer(struct batadv_priv *bat_priv,\n\t\t\t\t       struct batadv_orig_node *orig_node,\n\t\t\t\t       const void *tt_buff,\n\t\t\t\t       u16 tt_buff_len)\n{\n\t \n\tspin_lock_bh(&orig_node->tt_buff_lock);\n\tif (tt_buff_len > 0) {\n\t\tkfree(orig_node->tt_buff);\n\t\torig_node->tt_buff_len = 0;\n\t\torig_node->tt_buff = kmalloc(tt_buff_len, GFP_ATOMIC);\n\t\tif (orig_node->tt_buff) {\n\t\t\tmemcpy(orig_node->tt_buff, tt_buff, tt_buff_len);\n\t\t\torig_node->tt_buff_len = tt_buff_len;\n\t\t}\n\t}\n\tspin_unlock_bh(&orig_node->tt_buff_lock);\n}\n\nstatic void batadv_tt_req_purge(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_tt_req_node *node;\n\tstruct hlist_node *safe;\n\n\tspin_lock_bh(&bat_priv->tt.req_list_lock);\n\thlist_for_each_entry_safe(node, safe, &bat_priv->tt.req_list, list) {\n\t\tif (batadv_has_timed_out(node->issued_at,\n\t\t\t\t\t BATADV_TT_REQUEST_TIMEOUT)) {\n\t\t\thlist_del_init(&node->list);\n\t\t\tbatadv_tt_req_node_put(node);\n\t\t}\n\t}\n\tspin_unlock_bh(&bat_priv->tt.req_list_lock);\n}\n\n \nstatic struct batadv_tt_req_node *\nbatadv_tt_req_node_new(struct batadv_priv *bat_priv,\n\t\t       struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_tt_req_node *tt_req_node_tmp, *tt_req_node = NULL;\n\n\tspin_lock_bh(&bat_priv->tt.req_list_lock);\n\thlist_for_each_entry(tt_req_node_tmp, &bat_priv->tt.req_list, list) {\n\t\tif (batadv_compare_eth(tt_req_node_tmp, orig_node) &&\n\t\t    !batadv_has_timed_out(tt_req_node_tmp->issued_at,\n\t\t\t\t\t  BATADV_TT_REQUEST_TIMEOUT))\n\t\t\tgoto unlock;\n\t}\n\n\ttt_req_node = kmem_cache_alloc(batadv_tt_req_cache, GFP_ATOMIC);\n\tif (!tt_req_node)\n\t\tgoto unlock;\n\n\tkref_init(&tt_req_node->refcount);\n\tether_addr_copy(tt_req_node->addr, orig_node->orig);\n\ttt_req_node->issued_at = jiffies;\n\n\tkref_get(&tt_req_node->refcount);\n\thlist_add_head(&tt_req_node->list, &bat_priv->tt.req_list);\nunlock:\n\tspin_unlock_bh(&bat_priv->tt.req_list_lock);\n\treturn tt_req_node;\n}\n\n \nstatic bool batadv_tt_local_valid(const void *entry_ptr,\n\t\t\t\t  const void *data_ptr,\n\t\t\t\t  u8 *flags)\n{\n\tconst struct batadv_tt_common_entry *tt_common_entry = entry_ptr;\n\n\tif (tt_common_entry->flags & BATADV_TT_CLIENT_NEW)\n\t\treturn false;\n\n\tif (flags)\n\t\t*flags = tt_common_entry->flags;\n\n\treturn true;\n}\n\n \nstatic bool batadv_tt_global_valid(const void *entry_ptr,\n\t\t\t\t   const void *data_ptr,\n\t\t\t\t   u8 *flags)\n{\n\tconst struct batadv_tt_common_entry *tt_common_entry = entry_ptr;\n\tconst struct batadv_tt_global_entry *tt_global_entry;\n\tconst struct batadv_orig_node *orig_node = data_ptr;\n\n\tif (tt_common_entry->flags & BATADV_TT_CLIENT_ROAM ||\n\t    tt_common_entry->flags & BATADV_TT_CLIENT_TEMP)\n\t\treturn false;\n\n\ttt_global_entry = container_of(tt_common_entry,\n\t\t\t\t       struct batadv_tt_global_entry,\n\t\t\t\t       common);\n\n\treturn batadv_tt_global_entry_has_orig(tt_global_entry, orig_node,\n\t\t\t\t\t       flags);\n}\n\n \nstatic void batadv_tt_tvlv_generate(struct batadv_priv *bat_priv,\n\t\t\t\t    struct batadv_hashtable *hash,\n\t\t\t\t    void *tvlv_buff, u16 tt_len,\n\t\t\t\t    bool (*valid_cb)(const void *,\n\t\t\t\t\t\t     const void *,\n\t\t\t\t\t\t     u8 *flags),\n\t\t\t\t    void *cb_data)\n{\n\tstruct batadv_tt_common_entry *tt_common_entry;\n\tstruct batadv_tvlv_tt_change *tt_change;\n\tstruct hlist_head *head;\n\tu16 tt_tot, tt_num_entries = 0;\n\tu8 flags;\n\tbool ret;\n\tu32 i;\n\n\ttt_tot = batadv_tt_entries(tt_len);\n\ttt_change = tvlv_buff;\n\n\tif (!valid_cb)\n\t\treturn;\n\n\trcu_read_lock();\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\n\t\thlist_for_each_entry_rcu(tt_common_entry,\n\t\t\t\t\t head, hash_entry) {\n\t\t\tif (tt_tot == tt_num_entries)\n\t\t\t\tbreak;\n\n\t\t\tret = valid_cb(tt_common_entry, cb_data, &flags);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\n\t\t\tether_addr_copy(tt_change->addr, tt_common_entry->addr);\n\t\t\ttt_change->flags = flags;\n\t\t\ttt_change->vid = htons(tt_common_entry->vid);\n\t\t\tmemset(tt_change->reserved, 0,\n\t\t\t       sizeof(tt_change->reserved));\n\n\t\t\ttt_num_entries++;\n\t\t\ttt_change++;\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic bool batadv_tt_global_check_crc(struct batadv_orig_node *orig_node,\n\t\t\t\t       struct batadv_tvlv_tt_vlan_data *tt_vlan,\n\t\t\t\t       u16 num_vlan)\n{\n\tstruct batadv_tvlv_tt_vlan_data *tt_vlan_tmp;\n\tstruct batadv_orig_node_vlan *vlan;\n\tint i, orig_num_vlan;\n\tu32 crc;\n\n\t \n\tfor (i = 0; i < num_vlan; i++) {\n\t\ttt_vlan_tmp = tt_vlan + i;\n\n\t\t \n\t\tif (batadv_bla_is_backbone_gw_orig(orig_node->bat_priv,\n\t\t\t\t\t\t   orig_node->orig,\n\t\t\t\t\t\t   ntohs(tt_vlan_tmp->vid)))\n\t\t\tcontinue;\n\n\t\tvlan = batadv_orig_node_vlan_get(orig_node,\n\t\t\t\t\t\t ntohs(tt_vlan_tmp->vid));\n\t\tif (!vlan)\n\t\t\treturn false;\n\n\t\tcrc = vlan->tt.crc;\n\t\tbatadv_orig_node_vlan_put(vlan);\n\n\t\tif (crc != ntohl(tt_vlan_tmp->crc))\n\t\t\treturn false;\n\t}\n\n\t \n\trcu_read_lock();\n\torig_num_vlan = 0;\n\thlist_for_each_entry_rcu(vlan, &orig_node->vlan_list, list)\n\t\torig_num_vlan++;\n\trcu_read_unlock();\n\n\tif (orig_num_vlan > num_vlan)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void batadv_tt_local_update_crc(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_softif_vlan *vlan;\n\n\t \n\trcu_read_lock();\n\thlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\n\t\tvlan->tt.crc = batadv_tt_local_crc(bat_priv, vlan->vid);\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void batadv_tt_global_update_crc(struct batadv_priv *bat_priv,\n\t\t\t\t\tstruct batadv_orig_node *orig_node)\n{\n\tstruct batadv_orig_node_vlan *vlan;\n\tu32 crc;\n\n\t \n\trcu_read_lock();\n\thlist_for_each_entry_rcu(vlan, &orig_node->vlan_list, list) {\n\t\t \n\t\tif (batadv_bla_is_backbone_gw_orig(bat_priv, orig_node->orig,\n\t\t\t\t\t\t   vlan->vid))\n\t\t\tcontinue;\n\n\t\tcrc = batadv_tt_global_crc(bat_priv, orig_node, vlan->vid);\n\t\tvlan->tt.crc = crc;\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic bool batadv_send_tt_request(struct batadv_priv *bat_priv,\n\t\t\t\t   struct batadv_orig_node *dst_orig_node,\n\t\t\t\t   u8 ttvn,\n\t\t\t\t   struct batadv_tvlv_tt_vlan_data *tt_vlan,\n\t\t\t\t   u16 num_vlan, bool full_table)\n{\n\tstruct batadv_tvlv_tt_data *tvlv_tt_data = NULL;\n\tstruct batadv_tt_req_node *tt_req_node = NULL;\n\tstruct batadv_tvlv_tt_vlan_data *tt_vlan_req;\n\tstruct batadv_hard_iface *primary_if;\n\tbool ret = false;\n\tint i, size;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\tgoto out;\n\n\t \n\ttt_req_node = batadv_tt_req_node_new(bat_priv, dst_orig_node);\n\tif (!tt_req_node)\n\t\tgoto out;\n\n\tsize = sizeof(*tvlv_tt_data) + sizeof(*tt_vlan_req) * num_vlan;\n\ttvlv_tt_data = kzalloc(size, GFP_ATOMIC);\n\tif (!tvlv_tt_data)\n\t\tgoto out;\n\n\ttvlv_tt_data->flags = BATADV_TT_REQUEST;\n\ttvlv_tt_data->ttvn = ttvn;\n\ttvlv_tt_data->num_vlan = htons(num_vlan);\n\n\t \n\ttt_vlan_req = (struct batadv_tvlv_tt_vlan_data *)(tvlv_tt_data + 1);\n\tfor (i = 0; i < num_vlan; i++) {\n\t\ttt_vlan_req->vid = tt_vlan->vid;\n\t\ttt_vlan_req->crc = tt_vlan->crc;\n\n\t\ttt_vlan_req++;\n\t\ttt_vlan++;\n\t}\n\n\tif (full_table)\n\t\ttvlv_tt_data->flags |= BATADV_TT_FULL_TABLE;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv, \"Sending TT_REQUEST to %pM [%c]\\n\",\n\t\t   dst_orig_node->orig, full_table ? 'F' : '.');\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_TT_REQUEST_TX);\n\tbatadv_tvlv_unicast_send(bat_priv, primary_if->net_dev->dev_addr,\n\t\t\t\t dst_orig_node->orig, BATADV_TVLV_TT, 1,\n\t\t\t\t tvlv_tt_data, size);\n\tret = true;\n\nout:\n\tbatadv_hardif_put(primary_if);\n\n\tif (ret && tt_req_node) {\n\t\tspin_lock_bh(&bat_priv->tt.req_list_lock);\n\t\tif (!hlist_unhashed(&tt_req_node->list)) {\n\t\t\thlist_del_init(&tt_req_node->list);\n\t\t\tbatadv_tt_req_node_put(tt_req_node);\n\t\t}\n\t\tspin_unlock_bh(&bat_priv->tt.req_list_lock);\n\t}\n\n\tbatadv_tt_req_node_put(tt_req_node);\n\n\tkfree(tvlv_tt_data);\n\treturn ret;\n}\n\n \nstatic bool batadv_send_other_tt_response(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_tvlv_tt_data *tt_data,\n\t\t\t\t\t  u8 *req_src, u8 *req_dst)\n{\n\tstruct batadv_orig_node *req_dst_orig_node;\n\tstruct batadv_orig_node *res_dst_orig_node = NULL;\n\tstruct batadv_tvlv_tt_change *tt_change;\n\tstruct batadv_tvlv_tt_data *tvlv_tt_data = NULL;\n\tstruct batadv_tvlv_tt_vlan_data *tt_vlan;\n\tbool ret = false, full_table;\n\tu8 orig_ttvn, req_ttvn;\n\tu16 tvlv_len;\n\ts32 tt_len;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Received TT_REQUEST from %pM for ttvn: %u (%pM) [%c]\\n\",\n\t\t   req_src, tt_data->ttvn, req_dst,\n\t\t   ((tt_data->flags & BATADV_TT_FULL_TABLE) ? 'F' : '.'));\n\n\t \n\treq_dst_orig_node = batadv_orig_hash_find(bat_priv, req_dst);\n\tif (!req_dst_orig_node)\n\t\tgoto out;\n\n\tres_dst_orig_node = batadv_orig_hash_find(bat_priv, req_src);\n\tif (!res_dst_orig_node)\n\t\tgoto out;\n\n\torig_ttvn = (u8)atomic_read(&req_dst_orig_node->last_ttvn);\n\treq_ttvn = tt_data->ttvn;\n\n\ttt_vlan = (struct batadv_tvlv_tt_vlan_data *)(tt_data + 1);\n\t \n\tif (orig_ttvn != req_ttvn ||\n\t    !batadv_tt_global_check_crc(req_dst_orig_node, tt_vlan,\n\t\t\t\t\tntohs(tt_data->num_vlan)))\n\t\tgoto out;\n\n\t \n\tif (tt_data->flags & BATADV_TT_FULL_TABLE ||\n\t    !req_dst_orig_node->tt_buff)\n\t\tfull_table = true;\n\telse\n\t\tfull_table = false;\n\n\t \n\tif (!full_table) {\n\t\tspin_lock_bh(&req_dst_orig_node->tt_buff_lock);\n\t\ttt_len = req_dst_orig_node->tt_buff_len;\n\n\t\ttvlv_len = batadv_tt_prepare_tvlv_global_data(req_dst_orig_node,\n\t\t\t\t\t\t\t      &tvlv_tt_data,\n\t\t\t\t\t\t\t      &tt_change,\n\t\t\t\t\t\t\t      &tt_len);\n\t\tif (!tt_len)\n\t\t\tgoto unlock;\n\n\t\t \n\t\tmemcpy(tt_change, req_dst_orig_node->tt_buff,\n\t\t       req_dst_orig_node->tt_buff_len);\n\t\tspin_unlock_bh(&req_dst_orig_node->tt_buff_lock);\n\t} else {\n\t\t \n\t\ttt_len = -1;\n\t\ttvlv_len = batadv_tt_prepare_tvlv_global_data(req_dst_orig_node,\n\t\t\t\t\t\t\t      &tvlv_tt_data,\n\t\t\t\t\t\t\t      &tt_change,\n\t\t\t\t\t\t\t      &tt_len);\n\t\tif (!tt_len)\n\t\t\tgoto out;\n\n\t\t \n\t\tbatadv_tt_tvlv_generate(bat_priv, bat_priv->tt.global_hash,\n\t\t\t\t\ttt_change, tt_len,\n\t\t\t\t\tbatadv_tt_global_valid,\n\t\t\t\t\treq_dst_orig_node);\n\t}\n\n\t \n\ttt_len = sizeof(struct batadv_unicast_tvlv_packet) + tvlv_len;\n\tif (tt_len > atomic_read(&bat_priv->packet_size_max)) {\n\t\tnet_ratelimited_function(batadv_info, bat_priv->soft_iface,\n\t\t\t\t\t \"Ignoring TT_REQUEST from %pM; Response size exceeds max packet size.\\n\",\n\t\t\t\t\t res_dst_orig_node->orig);\n\t\tgoto out;\n\t}\n\n\ttvlv_tt_data->flags = BATADV_TT_RESPONSE;\n\ttvlv_tt_data->ttvn = req_ttvn;\n\n\tif (full_table)\n\t\ttvlv_tt_data->flags |= BATADV_TT_FULL_TABLE;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Sending TT_RESPONSE %pM for %pM [%c] (ttvn: %u)\\n\",\n\t\t   res_dst_orig_node->orig, req_dst_orig_node->orig,\n\t\t   full_table ? 'F' : '.', req_ttvn);\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_TT_RESPONSE_TX);\n\n\tbatadv_tvlv_unicast_send(bat_priv, req_dst_orig_node->orig,\n\t\t\t\t req_src, BATADV_TVLV_TT, 1, tvlv_tt_data,\n\t\t\t\t tvlv_len);\n\n\tret = true;\n\tgoto out;\n\nunlock:\n\tspin_unlock_bh(&req_dst_orig_node->tt_buff_lock);\n\nout:\n\tbatadv_orig_node_put(res_dst_orig_node);\n\tbatadv_orig_node_put(req_dst_orig_node);\n\tkfree(tvlv_tt_data);\n\treturn ret;\n}\n\n \nstatic bool batadv_send_my_tt_response(struct batadv_priv *bat_priv,\n\t\t\t\t       struct batadv_tvlv_tt_data *tt_data,\n\t\t\t\t       u8 *req_src)\n{\n\tstruct batadv_tvlv_tt_data *tvlv_tt_data = NULL;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_tvlv_tt_change *tt_change;\n\tstruct batadv_orig_node *orig_node;\n\tu8 my_ttvn, req_ttvn;\n\tu16 tvlv_len;\n\tbool full_table;\n\ts32 tt_len;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Received TT_REQUEST from %pM for ttvn: %u (me) [%c]\\n\",\n\t\t   req_src, tt_data->ttvn,\n\t\t   ((tt_data->flags & BATADV_TT_FULL_TABLE) ? 'F' : '.'));\n\n\tspin_lock_bh(&bat_priv->tt.commit_lock);\n\n\tmy_ttvn = (u8)atomic_read(&bat_priv->tt.vn);\n\treq_ttvn = tt_data->ttvn;\n\n\torig_node = batadv_orig_hash_find(bat_priv, req_src);\n\tif (!orig_node)\n\t\tgoto out;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\tgoto out;\n\n\t \n\tif (tt_data->flags & BATADV_TT_FULL_TABLE || my_ttvn != req_ttvn ||\n\t    !bat_priv->tt.last_changeset)\n\t\tfull_table = true;\n\telse\n\t\tfull_table = false;\n\n\t \n\tif (!full_table) {\n\t\tspin_lock_bh(&bat_priv->tt.last_changeset_lock);\n\n\t\ttt_len = bat_priv->tt.last_changeset_len;\n\t\ttvlv_len = batadv_tt_prepare_tvlv_local_data(bat_priv,\n\t\t\t\t\t\t\t     &tvlv_tt_data,\n\t\t\t\t\t\t\t     &tt_change,\n\t\t\t\t\t\t\t     &tt_len);\n\t\tif (!tt_len || !tvlv_len)\n\t\t\tgoto unlock;\n\n\t\t \n\t\tmemcpy(tt_change, bat_priv->tt.last_changeset,\n\t\t       bat_priv->tt.last_changeset_len);\n\t\tspin_unlock_bh(&bat_priv->tt.last_changeset_lock);\n\t} else {\n\t\treq_ttvn = (u8)atomic_read(&bat_priv->tt.vn);\n\n\t\t \n\t\ttt_len = -1;\n\t\ttvlv_len = batadv_tt_prepare_tvlv_local_data(bat_priv,\n\t\t\t\t\t\t\t     &tvlv_tt_data,\n\t\t\t\t\t\t\t     &tt_change,\n\t\t\t\t\t\t\t     &tt_len);\n\t\tif (!tt_len || !tvlv_len)\n\t\t\tgoto out;\n\n\t\t \n\t\tbatadv_tt_tvlv_generate(bat_priv, bat_priv->tt.local_hash,\n\t\t\t\t\ttt_change, tt_len,\n\t\t\t\t\tbatadv_tt_local_valid, NULL);\n\t}\n\n\ttvlv_tt_data->flags = BATADV_TT_RESPONSE;\n\ttvlv_tt_data->ttvn = req_ttvn;\n\n\tif (full_table)\n\t\ttvlv_tt_data->flags |= BATADV_TT_FULL_TABLE;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Sending TT_RESPONSE to %pM [%c] (ttvn: %u)\\n\",\n\t\t   orig_node->orig, full_table ? 'F' : '.', req_ttvn);\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_TT_RESPONSE_TX);\n\n\tbatadv_tvlv_unicast_send(bat_priv, primary_if->net_dev->dev_addr,\n\t\t\t\t req_src, BATADV_TVLV_TT, 1, tvlv_tt_data,\n\t\t\t\t tvlv_len);\n\n\tgoto out;\n\nunlock:\n\tspin_unlock_bh(&bat_priv->tt.last_changeset_lock);\nout:\n\tspin_unlock_bh(&bat_priv->tt.commit_lock);\n\tbatadv_orig_node_put(orig_node);\n\tbatadv_hardif_put(primary_if);\n\tkfree(tvlv_tt_data);\n\t \n\treturn true;\n}\n\n \nstatic bool batadv_send_tt_response(struct batadv_priv *bat_priv,\n\t\t\t\t    struct batadv_tvlv_tt_data *tt_data,\n\t\t\t\t    u8 *req_src, u8 *req_dst)\n{\n\tif (batadv_is_my_mac(bat_priv, req_dst))\n\t\treturn batadv_send_my_tt_response(bat_priv, tt_data, req_src);\n\treturn batadv_send_other_tt_response(bat_priv, tt_data, req_src,\n\t\t\t\t\t     req_dst);\n}\n\nstatic void _batadv_tt_update_changes(struct batadv_priv *bat_priv,\n\t\t\t\t      struct batadv_orig_node *orig_node,\n\t\t\t\t      struct batadv_tvlv_tt_change *tt_change,\n\t\t\t\t      u16 tt_num_changes, u8 ttvn)\n{\n\tint i;\n\tint roams;\n\n\tfor (i = 0; i < tt_num_changes; i++) {\n\t\tif ((tt_change + i)->flags & BATADV_TT_CLIENT_DEL) {\n\t\t\troams = (tt_change + i)->flags & BATADV_TT_CLIENT_ROAM;\n\t\t\tbatadv_tt_global_del(bat_priv, orig_node,\n\t\t\t\t\t     (tt_change + i)->addr,\n\t\t\t\t\t     ntohs((tt_change + i)->vid),\n\t\t\t\t\t     \"tt removed by changes\",\n\t\t\t\t\t     roams);\n\t\t} else {\n\t\t\tif (!batadv_tt_global_add(bat_priv, orig_node,\n\t\t\t\t\t\t  (tt_change + i)->addr,\n\t\t\t\t\t\t  ntohs((tt_change + i)->vid),\n\t\t\t\t\t\t  (tt_change + i)->flags, ttvn))\n\t\t\t\t \n\t\t\t\treturn;\n\t\t}\n\t}\n\tset_bit(BATADV_ORIG_CAPA_HAS_TT, &orig_node->capa_initialized);\n}\n\nstatic void batadv_tt_fill_gtable(struct batadv_priv *bat_priv,\n\t\t\t\t  struct batadv_tvlv_tt_change *tt_change,\n\t\t\t\t  u8 ttvn, u8 *resp_src,\n\t\t\t\t  u16 num_entries)\n{\n\tstruct batadv_orig_node *orig_node;\n\n\torig_node = batadv_orig_hash_find(bat_priv, resp_src);\n\tif (!orig_node)\n\t\tgoto out;\n\n\t \n\tbatadv_tt_global_del_orig(bat_priv, orig_node, -1,\n\t\t\t\t  \"Received full table\");\n\n\t_batadv_tt_update_changes(bat_priv, orig_node, tt_change, num_entries,\n\t\t\t\t  ttvn);\n\n\tspin_lock_bh(&orig_node->tt_buff_lock);\n\tkfree(orig_node->tt_buff);\n\torig_node->tt_buff_len = 0;\n\torig_node->tt_buff = NULL;\n\tspin_unlock_bh(&orig_node->tt_buff_lock);\n\n\tatomic_set(&orig_node->last_ttvn, ttvn);\n\nout:\n\tbatadv_orig_node_put(orig_node);\n}\n\nstatic void batadv_tt_update_changes(struct batadv_priv *bat_priv,\n\t\t\t\t     struct batadv_orig_node *orig_node,\n\t\t\t\t     u16 tt_num_changes, u8 ttvn,\n\t\t\t\t     struct batadv_tvlv_tt_change *tt_change)\n{\n\t_batadv_tt_update_changes(bat_priv, orig_node, tt_change,\n\t\t\t\t  tt_num_changes, ttvn);\n\n\tbatadv_tt_save_orig_buffer(bat_priv, orig_node, tt_change,\n\t\t\t\t   batadv_tt_len(tt_num_changes));\n\tatomic_set(&orig_node->last_ttvn, ttvn);\n}\n\n \nbool batadv_is_my_client(struct batadv_priv *bat_priv, const u8 *addr,\n\t\t\t unsigned short vid)\n{\n\tstruct batadv_tt_local_entry *tt_local_entry;\n\tbool ret = false;\n\n\ttt_local_entry = batadv_tt_local_hash_find(bat_priv, addr, vid);\n\tif (!tt_local_entry)\n\t\tgoto out;\n\t \n\tif ((tt_local_entry->common.flags & BATADV_TT_CLIENT_PENDING) ||\n\t    (tt_local_entry->common.flags & BATADV_TT_CLIENT_ROAM))\n\t\tgoto out;\n\tret = true;\nout:\n\tbatadv_tt_local_entry_put(tt_local_entry);\n\treturn ret;\n}\n\n \nstatic void batadv_handle_tt_response(struct batadv_priv *bat_priv,\n\t\t\t\t      struct batadv_tvlv_tt_data *tt_data,\n\t\t\t\t      u8 *resp_src, u16 num_entries)\n{\n\tstruct batadv_tt_req_node *node;\n\tstruct hlist_node *safe;\n\tstruct batadv_orig_node *orig_node = NULL;\n\tstruct batadv_tvlv_tt_change *tt_change;\n\tu8 *tvlv_ptr = (u8 *)tt_data;\n\tu16 change_offset;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Received TT_RESPONSE from %pM for ttvn %d t_size: %d [%c]\\n\",\n\t\t   resp_src, tt_data->ttvn, num_entries,\n\t\t   ((tt_data->flags & BATADV_TT_FULL_TABLE) ? 'F' : '.'));\n\n\torig_node = batadv_orig_hash_find(bat_priv, resp_src);\n\tif (!orig_node)\n\t\tgoto out;\n\n\tspin_lock_bh(&orig_node->tt_lock);\n\n\tchange_offset = sizeof(struct batadv_tvlv_tt_vlan_data);\n\tchange_offset *= ntohs(tt_data->num_vlan);\n\tchange_offset += sizeof(*tt_data);\n\ttvlv_ptr += change_offset;\n\n\ttt_change = (struct batadv_tvlv_tt_change *)tvlv_ptr;\n\tif (tt_data->flags & BATADV_TT_FULL_TABLE) {\n\t\tbatadv_tt_fill_gtable(bat_priv, tt_change, tt_data->ttvn,\n\t\t\t\t      resp_src, num_entries);\n\t} else {\n\t\tbatadv_tt_update_changes(bat_priv, orig_node, num_entries,\n\t\t\t\t\t tt_data->ttvn, tt_change);\n\t}\n\n\t \n\tbatadv_tt_global_update_crc(bat_priv, orig_node);\n\n\tspin_unlock_bh(&orig_node->tt_lock);\n\n\t \n\tspin_lock_bh(&bat_priv->tt.req_list_lock);\n\thlist_for_each_entry_safe(node, safe, &bat_priv->tt.req_list, list) {\n\t\tif (!batadv_compare_eth(node->addr, resp_src))\n\t\t\tcontinue;\n\t\thlist_del_init(&node->list);\n\t\tbatadv_tt_req_node_put(node);\n\t}\n\n\tspin_unlock_bh(&bat_priv->tt.req_list_lock);\nout:\n\tbatadv_orig_node_put(orig_node);\n}\n\nstatic void batadv_tt_roam_list_free(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_tt_roam_node *node, *safe;\n\n\tspin_lock_bh(&bat_priv->tt.roam_list_lock);\n\n\tlist_for_each_entry_safe(node, safe, &bat_priv->tt.roam_list, list) {\n\t\tlist_del(&node->list);\n\t\tkmem_cache_free(batadv_tt_roam_cache, node);\n\t}\n\n\tspin_unlock_bh(&bat_priv->tt.roam_list_lock);\n}\n\nstatic void batadv_tt_roam_purge(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_tt_roam_node *node, *safe;\n\n\tspin_lock_bh(&bat_priv->tt.roam_list_lock);\n\tlist_for_each_entry_safe(node, safe, &bat_priv->tt.roam_list, list) {\n\t\tif (!batadv_has_timed_out(node->first_time,\n\t\t\t\t\t  BATADV_ROAMING_MAX_TIME))\n\t\t\tcontinue;\n\n\t\tlist_del(&node->list);\n\t\tkmem_cache_free(batadv_tt_roam_cache, node);\n\t}\n\tspin_unlock_bh(&bat_priv->tt.roam_list_lock);\n}\n\n \nstatic bool batadv_tt_check_roam_count(struct batadv_priv *bat_priv, u8 *client)\n{\n\tstruct batadv_tt_roam_node *tt_roam_node;\n\tbool ret = false;\n\n\tspin_lock_bh(&bat_priv->tt.roam_list_lock);\n\t \n\tlist_for_each_entry(tt_roam_node, &bat_priv->tt.roam_list, list) {\n\t\tif (!batadv_compare_eth(tt_roam_node->addr, client))\n\t\t\tcontinue;\n\n\t\tif (batadv_has_timed_out(tt_roam_node->first_time,\n\t\t\t\t\t BATADV_ROAMING_MAX_TIME))\n\t\t\tcontinue;\n\n\t\tif (!batadv_atomic_dec_not_zero(&tt_roam_node->counter))\n\t\t\t \n\t\t\tgoto unlock;\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\ttt_roam_node = kmem_cache_alloc(batadv_tt_roam_cache,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!tt_roam_node)\n\t\t\tgoto unlock;\n\n\t\ttt_roam_node->first_time = jiffies;\n\t\tatomic_set(&tt_roam_node->counter,\n\t\t\t   BATADV_ROAMING_MAX_COUNT - 1);\n\t\tether_addr_copy(tt_roam_node->addr, client);\n\n\t\tlist_add(&tt_roam_node->list, &bat_priv->tt.roam_list);\n\t\tret = true;\n\t}\n\nunlock:\n\tspin_unlock_bh(&bat_priv->tt.roam_list_lock);\n\treturn ret;\n}\n\n \nstatic void batadv_send_roam_adv(struct batadv_priv *bat_priv, u8 *client,\n\t\t\t\t unsigned short vid,\n\t\t\t\t struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_hard_iface *primary_if;\n\tstruct batadv_tvlv_roam_adv tvlv_roam;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\tgoto out;\n\n\t \n\tif (!batadv_tt_check_roam_count(bat_priv, client))\n\t\tgoto out;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Sending ROAMING_ADV to %pM (client %pM, vid: %d)\\n\",\n\t\t   orig_node->orig, client, batadv_print_vid(vid));\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_TT_ROAM_ADV_TX);\n\n\tmemcpy(tvlv_roam.client, client, sizeof(tvlv_roam.client));\n\ttvlv_roam.vid = htons(vid);\n\n\tbatadv_tvlv_unicast_send(bat_priv, primary_if->net_dev->dev_addr,\n\t\t\t\t orig_node->orig, BATADV_TVLV_ROAM, 1,\n\t\t\t\t &tvlv_roam, sizeof(tvlv_roam));\n\nout:\n\tbatadv_hardif_put(primary_if);\n}\n\nstatic void batadv_tt_purge(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work;\n\tstruct batadv_priv_tt *priv_tt;\n\tstruct batadv_priv *bat_priv;\n\n\tdelayed_work = to_delayed_work(work);\n\tpriv_tt = container_of(delayed_work, struct batadv_priv_tt, work);\n\tbat_priv = container_of(priv_tt, struct batadv_priv, tt);\n\n\tbatadv_tt_local_purge(bat_priv, BATADV_TT_LOCAL_TIMEOUT);\n\tbatadv_tt_global_purge(bat_priv);\n\tbatadv_tt_req_purge(bat_priv);\n\tbatadv_tt_roam_purge(bat_priv);\n\n\tqueue_delayed_work(batadv_event_workqueue, &bat_priv->tt.work,\n\t\t\t   msecs_to_jiffies(BATADV_TT_WORK_PERIOD));\n}\n\n \nvoid batadv_tt_free(struct batadv_priv *bat_priv)\n{\n\tbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_ROAM, 1);\n\n\tbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_TT, 1);\n\tbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_TT, 1);\n\n\tcancel_delayed_work_sync(&bat_priv->tt.work);\n\n\tbatadv_tt_local_table_free(bat_priv);\n\tbatadv_tt_global_table_free(bat_priv);\n\tbatadv_tt_req_list_free(bat_priv);\n\tbatadv_tt_changes_list_free(bat_priv);\n\tbatadv_tt_roam_list_free(bat_priv);\n\n\tkfree(bat_priv->tt.last_changeset);\n}\n\n \nstatic void batadv_tt_local_set_flags(struct batadv_priv *bat_priv, u16 flags,\n\t\t\t\t      bool enable, bool count)\n{\n\tstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\n\tstruct batadv_tt_common_entry *tt_common_entry;\n\tstruct hlist_head *head;\n\tu32 i;\n\n\tif (!hash)\n\t\treturn;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(tt_common_entry,\n\t\t\t\t\t head, hash_entry) {\n\t\t\tif (enable) {\n\t\t\t\tif ((tt_common_entry->flags & flags) == flags)\n\t\t\t\t\tcontinue;\n\t\t\t\ttt_common_entry->flags |= flags;\n\t\t\t} else {\n\t\t\t\tif (!(tt_common_entry->flags & flags))\n\t\t\t\t\tcontinue;\n\t\t\t\ttt_common_entry->flags &= ~flags;\n\t\t\t}\n\n\t\t\tif (!count)\n\t\t\t\tcontinue;\n\n\t\t\tbatadv_tt_local_size_inc(bat_priv,\n\t\t\t\t\t\t tt_common_entry->vid);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\n \nstatic void batadv_tt_local_purge_pending_clients(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\n\tstruct batadv_tt_common_entry *tt_common;\n\tstruct batadv_tt_local_entry *tt_local;\n\tstruct hlist_node *node_tmp;\n\tstruct hlist_head *head;\n\tspinlock_t *list_lock;  \n\tu32 i;\n\n\tif (!hash)\n\t\treturn;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\t\tlist_lock = &hash->list_locks[i];\n\n\t\tspin_lock_bh(list_lock);\n\t\thlist_for_each_entry_safe(tt_common, node_tmp, head,\n\t\t\t\t\t  hash_entry) {\n\t\t\tif (!(tt_common->flags & BATADV_TT_CLIENT_PENDING))\n\t\t\t\tcontinue;\n\n\t\t\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t\t\t   \"Deleting local tt entry (%pM, vid: %d): pending\\n\",\n\t\t\t\t   tt_common->addr,\n\t\t\t\t   batadv_print_vid(tt_common->vid));\n\n\t\t\tbatadv_tt_local_size_dec(bat_priv, tt_common->vid);\n\t\t\thlist_del_rcu(&tt_common->hash_entry);\n\t\t\ttt_local = container_of(tt_common,\n\t\t\t\t\t\tstruct batadv_tt_local_entry,\n\t\t\t\t\t\tcommon);\n\n\t\t\tbatadv_tt_local_entry_put(tt_local);\n\t\t}\n\t\tspin_unlock_bh(list_lock);\n\t}\n}\n\n \nstatic void batadv_tt_local_commit_changes_nolock(struct batadv_priv *bat_priv)\n{\n\tlockdep_assert_held(&bat_priv->tt.commit_lock);\n\n\tif (atomic_read(&bat_priv->tt.local_changes) < 1) {\n\t\tif (!batadv_atomic_dec_not_zero(&bat_priv->tt.ogm_append_cnt))\n\t\t\tbatadv_tt_tvlv_container_update(bat_priv);\n\t\treturn;\n\t}\n\n\tbatadv_tt_local_set_flags(bat_priv, BATADV_TT_CLIENT_NEW, false, true);\n\n\tbatadv_tt_local_purge_pending_clients(bat_priv);\n\tbatadv_tt_local_update_crc(bat_priv);\n\n\t \n\tatomic_inc(&bat_priv->tt.vn);\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Local changes committed, updating to ttvn %u\\n\",\n\t\t   (u8)atomic_read(&bat_priv->tt.vn));\n\n\t \n\tatomic_set(&bat_priv->tt.ogm_append_cnt, BATADV_TT_OGM_APPEND_MAX);\n\tbatadv_tt_tvlv_container_update(bat_priv);\n}\n\n \nvoid batadv_tt_local_commit_changes(struct batadv_priv *bat_priv)\n{\n\tspin_lock_bh(&bat_priv->tt.commit_lock);\n\tbatadv_tt_local_commit_changes_nolock(bat_priv);\n\tspin_unlock_bh(&bat_priv->tt.commit_lock);\n}\n\n \nbool batadv_is_ap_isolated(struct batadv_priv *bat_priv, u8 *src, u8 *dst,\n\t\t\t   unsigned short vid)\n{\n\tstruct batadv_tt_local_entry *tt_local_entry;\n\tstruct batadv_tt_global_entry *tt_global_entry;\n\tstruct batadv_softif_vlan *vlan;\n\tbool ret = false;\n\n\tvlan = batadv_softif_vlan_get(bat_priv, vid);\n\tif (!vlan)\n\t\treturn false;\n\n\tif (!atomic_read(&vlan->ap_isolation))\n\t\tgoto vlan_put;\n\n\ttt_local_entry = batadv_tt_local_hash_find(bat_priv, dst, vid);\n\tif (!tt_local_entry)\n\t\tgoto vlan_put;\n\n\ttt_global_entry = batadv_tt_global_hash_find(bat_priv, src, vid);\n\tif (!tt_global_entry)\n\t\tgoto local_entry_put;\n\n\tif (_batadv_is_ap_isolated(tt_local_entry, tt_global_entry))\n\t\tret = true;\n\n\tbatadv_tt_global_entry_put(tt_global_entry);\nlocal_entry_put:\n\tbatadv_tt_local_entry_put(tt_local_entry);\nvlan_put:\n\tbatadv_softif_vlan_put(vlan);\n\treturn ret;\n}\n\n \nstatic void batadv_tt_update_orig(struct batadv_priv *bat_priv,\n\t\t\t\t  struct batadv_orig_node *orig_node,\n\t\t\t\t  const void *tt_buff, u16 tt_num_vlan,\n\t\t\t\t  struct batadv_tvlv_tt_change *tt_change,\n\t\t\t\t  u16 tt_num_changes, u8 ttvn)\n{\n\tu8 orig_ttvn = (u8)atomic_read(&orig_node->last_ttvn);\n\tstruct batadv_tvlv_tt_vlan_data *tt_vlan;\n\tbool full_table = true;\n\tbool has_tt_init;\n\n\ttt_vlan = (struct batadv_tvlv_tt_vlan_data *)tt_buff;\n\thas_tt_init = test_bit(BATADV_ORIG_CAPA_HAS_TT,\n\t\t\t       &orig_node->capa_initialized);\n\n\t \n\tif ((!has_tt_init && ttvn == 1) || ttvn - orig_ttvn == 1) {\n\t\t \n\t\tif (!tt_num_changes) {\n\t\t\tfull_table = false;\n\t\t\tgoto request_table;\n\t\t}\n\n\t\tspin_lock_bh(&orig_node->tt_lock);\n\n\t\tbatadv_tt_update_changes(bat_priv, orig_node, tt_num_changes,\n\t\t\t\t\t ttvn, tt_change);\n\n\t\t \n\t\tbatadv_tt_global_update_crc(bat_priv, orig_node);\n\n\t\tspin_unlock_bh(&orig_node->tt_lock);\n\n\t\t \n\t\tif (!batadv_tt_global_check_crc(orig_node, tt_vlan,\n\t\t\t\t\t\ttt_num_vlan))\n\t\t\tgoto request_table;\n\t} else {\n\t\t \n\t\tif (!has_tt_init || ttvn != orig_ttvn ||\n\t\t    !batadv_tt_global_check_crc(orig_node, tt_vlan,\n\t\t\t\t\t\ttt_num_vlan)) {\nrequest_table:\n\t\t\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t\t\t   \"TT inconsistency for %pM. Need to retrieve the correct information (ttvn: %u last_ttvn: %u num_changes: %u)\\n\",\n\t\t\t\t   orig_node->orig, ttvn, orig_ttvn,\n\t\t\t\t   tt_num_changes);\n\t\t\tbatadv_send_tt_request(bat_priv, orig_node, ttvn,\n\t\t\t\t\t       tt_vlan, tt_num_vlan,\n\t\t\t\t\t       full_table);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nbool batadv_tt_global_client_is_roaming(struct batadv_priv *bat_priv,\n\t\t\t\t\tu8 *addr, unsigned short vid)\n{\n\tstruct batadv_tt_global_entry *tt_global_entry;\n\tbool ret = false;\n\n\ttt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\n\tif (!tt_global_entry)\n\t\tgoto out;\n\n\tret = tt_global_entry->common.flags & BATADV_TT_CLIENT_ROAM;\n\tbatadv_tt_global_entry_put(tt_global_entry);\nout:\n\treturn ret;\n}\n\n \nbool batadv_tt_local_client_is_roaming(struct batadv_priv *bat_priv,\n\t\t\t\t       u8 *addr, unsigned short vid)\n{\n\tstruct batadv_tt_local_entry *tt_local_entry;\n\tbool ret = false;\n\n\ttt_local_entry = batadv_tt_local_hash_find(bat_priv, addr, vid);\n\tif (!tt_local_entry)\n\t\tgoto out;\n\n\tret = tt_local_entry->common.flags & BATADV_TT_CLIENT_ROAM;\n\tbatadv_tt_local_entry_put(tt_local_entry);\nout:\n\treturn ret;\n}\n\n \nbool batadv_tt_add_temporary_global_entry(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_orig_node *orig_node,\n\t\t\t\t\t  const unsigned char *addr,\n\t\t\t\t\t  unsigned short vid)\n{\n\t \n\tif (batadv_bla_is_loopdetect_mac(addr))\n\t\treturn false;\n\n\tif (!batadv_tt_global_add(bat_priv, orig_node, addr, vid,\n\t\t\t\t  BATADV_TT_CLIENT_TEMP,\n\t\t\t\t  atomic_read(&orig_node->last_ttvn)))\n\t\treturn false;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Added temporary global client (addr: %pM, vid: %d, orig: %pM)\\n\",\n\t\t   addr, batadv_print_vid(vid), orig_node->orig);\n\n\treturn true;\n}\n\n \nvoid batadv_tt_local_resize_to_mtu(struct net_device *soft_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\n\tint packet_size_max = atomic_read(&bat_priv->packet_size_max);\n\tint table_size, timeout = BATADV_TT_LOCAL_TIMEOUT / 2;\n\tbool reduced = false;\n\n\tspin_lock_bh(&bat_priv->tt.commit_lock);\n\n\twhile (true) {\n\t\ttable_size = batadv_tt_local_table_transmit_size(bat_priv);\n\t\tif (packet_size_max >= table_size)\n\t\t\tbreak;\n\n\t\tbatadv_tt_local_purge(bat_priv, timeout);\n\t\tbatadv_tt_local_purge_pending_clients(bat_priv);\n\n\t\ttimeout /= 2;\n\t\treduced = true;\n\t\tnet_ratelimited_function(batadv_info, soft_iface,\n\t\t\t\t\t \"Forced to purge local tt entries to fit new maximum fragment MTU (%i)\\n\",\n\t\t\t\t\t packet_size_max);\n\t}\n\n\t \n\tif (reduced)\n\t\tbatadv_tt_local_commit_changes_nolock(bat_priv);\n\n\tspin_unlock_bh(&bat_priv->tt.commit_lock);\n}\n\n \nstatic void batadv_tt_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_orig_node *orig,\n\t\t\t\t\t  u8 flags, void *tvlv_value,\n\t\t\t\t\t  u16 tvlv_value_len)\n{\n\tstruct batadv_tvlv_tt_vlan_data *tt_vlan;\n\tstruct batadv_tvlv_tt_change *tt_change;\n\tstruct batadv_tvlv_tt_data *tt_data;\n\tu16 num_entries, num_vlan;\n\n\tif (tvlv_value_len < sizeof(*tt_data))\n\t\treturn;\n\n\ttt_data = tvlv_value;\n\ttvlv_value_len -= sizeof(*tt_data);\n\n\tnum_vlan = ntohs(tt_data->num_vlan);\n\n\tif (tvlv_value_len < sizeof(*tt_vlan) * num_vlan)\n\t\treturn;\n\n\ttt_vlan = (struct batadv_tvlv_tt_vlan_data *)(tt_data + 1);\n\ttt_change = (struct batadv_tvlv_tt_change *)(tt_vlan + num_vlan);\n\ttvlv_value_len -= sizeof(*tt_vlan) * num_vlan;\n\n\tnum_entries = batadv_tt_entries(tvlv_value_len);\n\n\tbatadv_tt_update_orig(bat_priv, orig, tt_vlan, num_vlan, tt_change,\n\t\t\t      num_entries, tt_data->ttvn);\n}\n\n \nstatic int batadv_tt_tvlv_unicast_handler_v1(struct batadv_priv *bat_priv,\n\t\t\t\t\t     u8 *src, u8 *dst,\n\t\t\t\t\t     void *tvlv_value,\n\t\t\t\t\t     u16 tvlv_value_len)\n{\n\tstruct batadv_tvlv_tt_data *tt_data;\n\tu16 tt_vlan_len, tt_num_entries;\n\tchar tt_flag;\n\tbool ret;\n\n\tif (tvlv_value_len < sizeof(*tt_data))\n\t\treturn NET_RX_SUCCESS;\n\n\ttt_data = tvlv_value;\n\ttvlv_value_len -= sizeof(*tt_data);\n\n\ttt_vlan_len = sizeof(struct batadv_tvlv_tt_vlan_data);\n\ttt_vlan_len *= ntohs(tt_data->num_vlan);\n\n\tif (tvlv_value_len < tt_vlan_len)\n\t\treturn NET_RX_SUCCESS;\n\n\ttvlv_value_len -= tt_vlan_len;\n\ttt_num_entries = batadv_tt_entries(tvlv_value_len);\n\n\tswitch (tt_data->flags & BATADV_TT_DATA_TYPE_MASK) {\n\tcase BATADV_TT_REQUEST:\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_TT_REQUEST_RX);\n\n\t\t \n\t\tret = batadv_send_tt_response(bat_priv, tt_data, src, dst);\n\t\tif (!ret) {\n\t\t\tif (tt_data->flags & BATADV_TT_FULL_TABLE)\n\t\t\t\ttt_flag = 'F';\n\t\t\telse\n\t\t\t\ttt_flag = '.';\n\n\t\t\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t\t\t   \"Routing TT_REQUEST to %pM [%c]\\n\",\n\t\t\t\t   dst, tt_flag);\n\t\t\t \n\t\t\treturn NET_RX_DROP;\n\t\t}\n\t\tbreak;\n\tcase BATADV_TT_RESPONSE:\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_TT_RESPONSE_RX);\n\n\t\tif (batadv_is_my_mac(bat_priv, dst)) {\n\t\t\tbatadv_handle_tt_response(bat_priv, tt_data,\n\t\t\t\t\t\t  src, tt_num_entries);\n\t\t\treturn NET_RX_SUCCESS;\n\t\t}\n\n\t\tif (tt_data->flags & BATADV_TT_FULL_TABLE)\n\t\t\ttt_flag =  'F';\n\t\telse\n\t\t\ttt_flag = '.';\n\n\t\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t\t   \"Routing TT_RESPONSE to %pM [%c]\\n\", dst, tt_flag);\n\n\t\t \n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn NET_RX_SUCCESS;\n}\n\n \nstatic int batadv_roam_tvlv_unicast_handler_v1(struct batadv_priv *bat_priv,\n\t\t\t\t\t       u8 *src, u8 *dst,\n\t\t\t\t\t       void *tvlv_value,\n\t\t\t\t\t       u16 tvlv_value_len)\n{\n\tstruct batadv_tvlv_roam_adv *roaming_adv;\n\tstruct batadv_orig_node *orig_node = NULL;\n\n\t \n\tif (!batadv_is_my_mac(bat_priv, dst))\n\t\treturn NET_RX_DROP;\n\n\tif (tvlv_value_len < sizeof(*roaming_adv))\n\t\tgoto out;\n\n\torig_node = batadv_orig_hash_find(bat_priv, src);\n\tif (!orig_node)\n\t\tgoto out;\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_TT_ROAM_ADV_RX);\n\troaming_adv = tvlv_value;\n\n\tbatadv_dbg(BATADV_DBG_TT, bat_priv,\n\t\t   \"Received ROAMING_ADV from %pM (client %pM)\\n\",\n\t\t   src, roaming_adv->client);\n\n\tbatadv_tt_global_add(bat_priv, orig_node, roaming_adv->client,\n\t\t\t     ntohs(roaming_adv->vid), BATADV_TT_CLIENT_ROAM,\n\t\t\t     atomic_read(&orig_node->last_ttvn) + 1);\n\nout:\n\tbatadv_orig_node_put(orig_node);\n\treturn NET_RX_SUCCESS;\n}\n\n \nint batadv_tt_init(struct batadv_priv *bat_priv)\n{\n\tint ret;\n\n\t \n\tBUILD_BUG_ON(!(BATADV_TT_SYNC_MASK & BATADV_TT_REMOTE_MASK));\n\n\tret = batadv_tt_local_init(bat_priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = batadv_tt_global_init(bat_priv);\n\tif (ret < 0) {\n\t\tbatadv_tt_local_table_free(bat_priv);\n\t\treturn ret;\n\t}\n\n\tbatadv_tvlv_handler_register(bat_priv, batadv_tt_tvlv_ogm_handler_v1,\n\t\t\t\t     batadv_tt_tvlv_unicast_handler_v1, NULL,\n\t\t\t\t     BATADV_TVLV_TT, 1, BATADV_NO_FLAGS);\n\n\tbatadv_tvlv_handler_register(bat_priv, NULL,\n\t\t\t\t     batadv_roam_tvlv_unicast_handler_v1, NULL,\n\t\t\t\t     BATADV_TVLV_ROAM, 1, BATADV_NO_FLAGS);\n\n\tINIT_DELAYED_WORK(&bat_priv->tt.work, batadv_tt_purge);\n\tqueue_delayed_work(batadv_event_workqueue, &bat_priv->tt.work,\n\t\t\t   msecs_to_jiffies(BATADV_TT_WORK_PERIOD));\n\n\treturn 1;\n}\n\n \nbool batadv_tt_global_is_isolated(struct batadv_priv *bat_priv,\n\t\t\t\t  const u8 *addr, unsigned short vid)\n{\n\tstruct batadv_tt_global_entry *tt;\n\tbool ret;\n\n\ttt = batadv_tt_global_hash_find(bat_priv, addr, vid);\n\tif (!tt)\n\t\treturn false;\n\n\tret = tt->common.flags & BATADV_TT_CLIENT_ISOLA;\n\n\tbatadv_tt_global_entry_put(tt);\n\n\treturn ret;\n}\n\n \nint __init batadv_tt_cache_init(void)\n{\n\tsize_t tl_size = sizeof(struct batadv_tt_local_entry);\n\tsize_t tg_size = sizeof(struct batadv_tt_global_entry);\n\tsize_t tt_orig_size = sizeof(struct batadv_tt_orig_list_entry);\n\tsize_t tt_change_size = sizeof(struct batadv_tt_change_node);\n\tsize_t tt_req_size = sizeof(struct batadv_tt_req_node);\n\tsize_t tt_roam_size = sizeof(struct batadv_tt_roam_node);\n\n\tbatadv_tl_cache = kmem_cache_create(\"batadv_tl_cache\", tl_size, 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (!batadv_tl_cache)\n\t\treturn -ENOMEM;\n\n\tbatadv_tg_cache = kmem_cache_create(\"batadv_tg_cache\", tg_size, 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (!batadv_tg_cache)\n\t\tgoto err_tt_tl_destroy;\n\n\tbatadv_tt_orig_cache = kmem_cache_create(\"batadv_tt_orig_cache\",\n\t\t\t\t\t\t tt_orig_size, 0,\n\t\t\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\tif (!batadv_tt_orig_cache)\n\t\tgoto err_tt_tg_destroy;\n\n\tbatadv_tt_change_cache = kmem_cache_create(\"batadv_tt_change_cache\",\n\t\t\t\t\t\t   tt_change_size, 0,\n\t\t\t\t\t\t   SLAB_HWCACHE_ALIGN, NULL);\n\tif (!batadv_tt_change_cache)\n\t\tgoto err_tt_orig_destroy;\n\n\tbatadv_tt_req_cache = kmem_cache_create(\"batadv_tt_req_cache\",\n\t\t\t\t\t\ttt_req_size, 0,\n\t\t\t\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!batadv_tt_req_cache)\n\t\tgoto err_tt_change_destroy;\n\n\tbatadv_tt_roam_cache = kmem_cache_create(\"batadv_tt_roam_cache\",\n\t\t\t\t\t\t tt_roam_size, 0,\n\t\t\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\tif (!batadv_tt_roam_cache)\n\t\tgoto err_tt_req_destroy;\n\n\treturn 0;\n\nerr_tt_req_destroy:\n\tkmem_cache_destroy(batadv_tt_req_cache);\n\tbatadv_tt_req_cache = NULL;\nerr_tt_change_destroy:\n\tkmem_cache_destroy(batadv_tt_change_cache);\n\tbatadv_tt_change_cache = NULL;\nerr_tt_orig_destroy:\n\tkmem_cache_destroy(batadv_tt_orig_cache);\n\tbatadv_tt_orig_cache = NULL;\nerr_tt_tg_destroy:\n\tkmem_cache_destroy(batadv_tg_cache);\n\tbatadv_tg_cache = NULL;\nerr_tt_tl_destroy:\n\tkmem_cache_destroy(batadv_tl_cache);\n\tbatadv_tl_cache = NULL;\n\n\treturn -ENOMEM;\n}\n\n \nvoid batadv_tt_cache_destroy(void)\n{\n\tkmem_cache_destroy(batadv_tl_cache);\n\tkmem_cache_destroy(batadv_tg_cache);\n\tkmem_cache_destroy(batadv_tt_orig_cache);\n\tkmem_cache_destroy(batadv_tt_change_cache);\n\tkmem_cache_destroy(batadv_tt_req_cache);\n\tkmem_cache_destroy(batadv_tt_roam_cache);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}