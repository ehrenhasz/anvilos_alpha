{
  "module_name": "tvlv.c",
  "hash_id": "a094b34d3282bfe95483085198807ac94de3259de1d0ef081508d330dada23a1",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/tvlv.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n\n#include <linux/byteorder/generic.h>\n#include <linux/container_of.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/netdevice.h>\n#include <linux/pkt_sched.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <uapi/linux/batadv_packet.h>\n\n#include \"originator.h\"\n#include \"send.h\"\n#include \"tvlv.h\"\n\n \nstatic void batadv_tvlv_handler_release(struct kref *ref)\n{\n\tstruct batadv_tvlv_handler *tvlv_handler;\n\n\ttvlv_handler = container_of(ref, struct batadv_tvlv_handler, refcount);\n\tkfree_rcu(tvlv_handler, rcu);\n}\n\n \nstatic void batadv_tvlv_handler_put(struct batadv_tvlv_handler *tvlv_handler)\n{\n\tif (!tvlv_handler)\n\t\treturn;\n\n\tkref_put(&tvlv_handler->refcount, batadv_tvlv_handler_release);\n}\n\n \nstatic struct batadv_tvlv_handler *\nbatadv_tvlv_handler_get(struct batadv_priv *bat_priv, u8 type, u8 version)\n{\n\tstruct batadv_tvlv_handler *tvlv_handler_tmp, *tvlv_handler = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(tvlv_handler_tmp,\n\t\t\t\t &bat_priv->tvlv.handler_list, list) {\n\t\tif (tvlv_handler_tmp->type != type)\n\t\t\tcontinue;\n\n\t\tif (tvlv_handler_tmp->version != version)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&tvlv_handler_tmp->refcount))\n\t\t\tcontinue;\n\n\t\ttvlv_handler = tvlv_handler_tmp;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn tvlv_handler;\n}\n\n \nstatic void batadv_tvlv_container_release(struct kref *ref)\n{\n\tstruct batadv_tvlv_container *tvlv;\n\n\ttvlv = container_of(ref, struct batadv_tvlv_container, refcount);\n\tkfree(tvlv);\n}\n\n \nstatic void batadv_tvlv_container_put(struct batadv_tvlv_container *tvlv)\n{\n\tif (!tvlv)\n\t\treturn;\n\n\tkref_put(&tvlv->refcount, batadv_tvlv_container_release);\n}\n\n \nstatic struct batadv_tvlv_container *\nbatadv_tvlv_container_get(struct batadv_priv *bat_priv, u8 type, u8 version)\n{\n\tstruct batadv_tvlv_container *tvlv_tmp, *tvlv = NULL;\n\n\tlockdep_assert_held(&bat_priv->tvlv.container_list_lock);\n\n\thlist_for_each_entry(tvlv_tmp, &bat_priv->tvlv.container_list, list) {\n\t\tif (tvlv_tmp->tvlv_hdr.type != type)\n\t\t\tcontinue;\n\n\t\tif (tvlv_tmp->tvlv_hdr.version != version)\n\t\t\tcontinue;\n\n\t\tkref_get(&tvlv_tmp->refcount);\n\t\ttvlv = tvlv_tmp;\n\t\tbreak;\n\t}\n\n\treturn tvlv;\n}\n\n \nstatic u16 batadv_tvlv_container_list_size(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_tvlv_container *tvlv;\n\tu16 tvlv_len = 0;\n\n\tlockdep_assert_held(&bat_priv->tvlv.container_list_lock);\n\n\thlist_for_each_entry(tvlv, &bat_priv->tvlv.container_list, list) {\n\t\ttvlv_len += sizeof(struct batadv_tvlv_hdr);\n\t\ttvlv_len += ntohs(tvlv->tvlv_hdr.len);\n\t}\n\n\treturn tvlv_len;\n}\n\n \nstatic void batadv_tvlv_container_remove(struct batadv_priv *bat_priv,\n\t\t\t\t\t struct batadv_tvlv_container *tvlv)\n{\n\tlockdep_assert_held(&bat_priv->tvlv.container_list_lock);\n\n\tif (!tvlv)\n\t\treturn;\n\n\thlist_del(&tvlv->list);\n\n\t \n\tbatadv_tvlv_container_put(tvlv);\n\tbatadv_tvlv_container_put(tvlv);\n}\n\n \nvoid batadv_tvlv_container_unregister(struct batadv_priv *bat_priv,\n\t\t\t\t      u8 type, u8 version)\n{\n\tstruct batadv_tvlv_container *tvlv;\n\n\tspin_lock_bh(&bat_priv->tvlv.container_list_lock);\n\ttvlv = batadv_tvlv_container_get(bat_priv, type, version);\n\tbatadv_tvlv_container_remove(bat_priv, tvlv);\n\tspin_unlock_bh(&bat_priv->tvlv.container_list_lock);\n}\n\n \nvoid batadv_tvlv_container_register(struct batadv_priv *bat_priv,\n\t\t\t\t    u8 type, u8 version,\n\t\t\t\t    void *tvlv_value, u16 tvlv_value_len)\n{\n\tstruct batadv_tvlv_container *tvlv_old, *tvlv_new;\n\n\tif (!tvlv_value)\n\t\ttvlv_value_len = 0;\n\n\ttvlv_new = kzalloc(sizeof(*tvlv_new) + tvlv_value_len, GFP_ATOMIC);\n\tif (!tvlv_new)\n\t\treturn;\n\n\ttvlv_new->tvlv_hdr.version = version;\n\ttvlv_new->tvlv_hdr.type = type;\n\ttvlv_new->tvlv_hdr.len = htons(tvlv_value_len);\n\n\tmemcpy(tvlv_new + 1, tvlv_value, ntohs(tvlv_new->tvlv_hdr.len));\n\tINIT_HLIST_NODE(&tvlv_new->list);\n\tkref_init(&tvlv_new->refcount);\n\n\tspin_lock_bh(&bat_priv->tvlv.container_list_lock);\n\ttvlv_old = batadv_tvlv_container_get(bat_priv, type, version);\n\tbatadv_tvlv_container_remove(bat_priv, tvlv_old);\n\n\tkref_get(&tvlv_new->refcount);\n\thlist_add_head(&tvlv_new->list, &bat_priv->tvlv.container_list);\n\tspin_unlock_bh(&bat_priv->tvlv.container_list_lock);\n\n\t \n\tbatadv_tvlv_container_put(tvlv_new);\n}\n\n \nstatic bool batadv_tvlv_realloc_packet_buff(unsigned char **packet_buff,\n\t\t\t\t\t    int *packet_buff_len,\n\t\t\t\t\t    int min_packet_len,\n\t\t\t\t\t    int additional_packet_len)\n{\n\tunsigned char *new_buff;\n\n\tnew_buff = kmalloc(min_packet_len + additional_packet_len, GFP_ATOMIC);\n\n\t \n\tif (!new_buff)\n\t\treturn false;\n\n\tmemcpy(new_buff, *packet_buff, min_packet_len);\n\tkfree(*packet_buff);\n\t*packet_buff = new_buff;\n\t*packet_buff_len = min_packet_len + additional_packet_len;\n\n\treturn true;\n}\n\n \nu16 batadv_tvlv_container_ogm_append(struct batadv_priv *bat_priv,\n\t\t\t\t     unsigned char **packet_buff,\n\t\t\t\t     int *packet_buff_len, int packet_min_len)\n{\n\tstruct batadv_tvlv_container *tvlv;\n\tstruct batadv_tvlv_hdr *tvlv_hdr;\n\tu16 tvlv_value_len;\n\tvoid *tvlv_value;\n\tbool ret;\n\n\tspin_lock_bh(&bat_priv->tvlv.container_list_lock);\n\ttvlv_value_len = batadv_tvlv_container_list_size(bat_priv);\n\n\tret = batadv_tvlv_realloc_packet_buff(packet_buff, packet_buff_len,\n\t\t\t\t\t      packet_min_len, tvlv_value_len);\n\n\tif (!ret)\n\t\tgoto end;\n\n\tif (!tvlv_value_len)\n\t\tgoto end;\n\n\ttvlv_value = (*packet_buff) + packet_min_len;\n\n\thlist_for_each_entry(tvlv, &bat_priv->tvlv.container_list, list) {\n\t\ttvlv_hdr = tvlv_value;\n\t\ttvlv_hdr->type = tvlv->tvlv_hdr.type;\n\t\ttvlv_hdr->version = tvlv->tvlv_hdr.version;\n\t\ttvlv_hdr->len = tvlv->tvlv_hdr.len;\n\t\ttvlv_value = tvlv_hdr + 1;\n\t\tmemcpy(tvlv_value, tvlv + 1, ntohs(tvlv->tvlv_hdr.len));\n\t\ttvlv_value = (u8 *)tvlv_value + ntohs(tvlv->tvlv_hdr.len);\n\t}\n\nend:\n\tspin_unlock_bh(&bat_priv->tvlv.container_list_lock);\n\treturn tvlv_value_len;\n}\n\n \nstatic int batadv_tvlv_call_handler(struct batadv_priv *bat_priv,\n\t\t\t\t    struct batadv_tvlv_handler *tvlv_handler,\n\t\t\t\t    u8 packet_type,\n\t\t\t\t    struct batadv_orig_node *orig_node,\n\t\t\t\t    struct sk_buff *skb, void *tvlv_value,\n\t\t\t\t    u16 tvlv_value_len)\n{\n\tunsigned int tvlv_offset;\n\tu8 *src, *dst;\n\n\tif (!tvlv_handler)\n\t\treturn NET_RX_SUCCESS;\n\n\tswitch (packet_type) {\n\tcase BATADV_IV_OGM:\n\tcase BATADV_OGM2:\n\t\tif (!tvlv_handler->ogm_handler)\n\t\t\treturn NET_RX_SUCCESS;\n\n\t\tif (!orig_node)\n\t\t\treturn NET_RX_SUCCESS;\n\n\t\ttvlv_handler->ogm_handler(bat_priv, orig_node,\n\t\t\t\t\t  BATADV_NO_FLAGS,\n\t\t\t\t\t  tvlv_value, tvlv_value_len);\n\t\ttvlv_handler->flags |= BATADV_TVLV_HANDLER_OGM_CALLED;\n\t\tbreak;\n\tcase BATADV_UNICAST_TVLV:\n\t\tif (!skb)\n\t\t\treturn NET_RX_SUCCESS;\n\n\t\tif (!tvlv_handler->unicast_handler)\n\t\t\treturn NET_RX_SUCCESS;\n\n\t\tsrc = ((struct batadv_unicast_tvlv_packet *)skb->data)->src;\n\t\tdst = ((struct batadv_unicast_tvlv_packet *)skb->data)->dst;\n\n\t\treturn tvlv_handler->unicast_handler(bat_priv, src,\n\t\t\t\t\t\t     dst, tvlv_value,\n\t\t\t\t\t\t     tvlv_value_len);\n\tcase BATADV_MCAST:\n\t\tif (!skb)\n\t\t\treturn NET_RX_SUCCESS;\n\n\t\tif (!tvlv_handler->mcast_handler)\n\t\t\treturn NET_RX_SUCCESS;\n\n\t\ttvlv_offset = (unsigned char *)tvlv_value - skb->data;\n\t\tskb_set_network_header(skb, tvlv_offset);\n\t\tskb_set_transport_header(skb, tvlv_offset + tvlv_value_len);\n\n\t\treturn tvlv_handler->mcast_handler(bat_priv, skb);\n\t}\n\n\treturn NET_RX_SUCCESS;\n}\n\n \nint batadv_tvlv_containers_process(struct batadv_priv *bat_priv,\n\t\t\t\t   u8 packet_type,\n\t\t\t\t   struct batadv_orig_node *orig_node,\n\t\t\t\t   struct sk_buff *skb, void *tvlv_value,\n\t\t\t\t   u16 tvlv_value_len)\n{\n\tstruct batadv_tvlv_handler *tvlv_handler;\n\tstruct batadv_tvlv_hdr *tvlv_hdr;\n\tu16 tvlv_value_cont_len;\n\tu8 cifnotfound = BATADV_TVLV_HANDLER_OGM_CIFNOTFND;\n\tint ret = NET_RX_SUCCESS;\n\n\twhile (tvlv_value_len >= sizeof(*tvlv_hdr)) {\n\t\ttvlv_hdr = tvlv_value;\n\t\ttvlv_value_cont_len = ntohs(tvlv_hdr->len);\n\t\ttvlv_value = tvlv_hdr + 1;\n\t\ttvlv_value_len -= sizeof(*tvlv_hdr);\n\n\t\tif (tvlv_value_cont_len > tvlv_value_len)\n\t\t\tbreak;\n\n\t\ttvlv_handler = batadv_tvlv_handler_get(bat_priv,\n\t\t\t\t\t\t       tvlv_hdr->type,\n\t\t\t\t\t\t       tvlv_hdr->version);\n\n\t\tret |= batadv_tvlv_call_handler(bat_priv, tvlv_handler,\n\t\t\t\t\t\tpacket_type, orig_node, skb,\n\t\t\t\t\t\ttvlv_value,\n\t\t\t\t\t\ttvlv_value_cont_len);\n\t\tbatadv_tvlv_handler_put(tvlv_handler);\n\t\ttvlv_value = (u8 *)tvlv_value + tvlv_value_cont_len;\n\t\ttvlv_value_len -= tvlv_value_cont_len;\n\t}\n\n\tif (packet_type != BATADV_IV_OGM &&\n\t    packet_type != BATADV_OGM2)\n\t\treturn ret;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(tvlv_handler,\n\t\t\t\t &bat_priv->tvlv.handler_list, list) {\n\t\tif (!tvlv_handler->ogm_handler)\n\t\t\tcontinue;\n\n\t\tif ((tvlv_handler->flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND) &&\n\t\t    !(tvlv_handler->flags & BATADV_TVLV_HANDLER_OGM_CALLED))\n\t\t\ttvlv_handler->ogm_handler(bat_priv, orig_node,\n\t\t\t\t\t\t  cifnotfound, NULL, 0);\n\n\t\ttvlv_handler->flags &= ~BATADV_TVLV_HANDLER_OGM_CALLED;\n\t}\n\trcu_read_unlock();\n\n\treturn NET_RX_SUCCESS;\n}\n\n \nvoid batadv_tvlv_ogm_receive(struct batadv_priv *bat_priv,\n\t\t\t     struct batadv_ogm_packet *batadv_ogm_packet,\n\t\t\t     struct batadv_orig_node *orig_node)\n{\n\tvoid *tvlv_value;\n\tu16 tvlv_value_len;\n\n\tif (!batadv_ogm_packet)\n\t\treturn;\n\n\ttvlv_value_len = ntohs(batadv_ogm_packet->tvlv_len);\n\tif (!tvlv_value_len)\n\t\treturn;\n\n\ttvlv_value = batadv_ogm_packet + 1;\n\n\tbatadv_tvlv_containers_process(bat_priv, BATADV_IV_OGM, orig_node, NULL,\n\t\t\t\t       tvlv_value, tvlv_value_len);\n}\n\n \nvoid batadv_tvlv_handler_register(struct batadv_priv *bat_priv,\n\t\t\t\t  void (*optr)(struct batadv_priv *bat_priv,\n\t\t\t\t\t       struct batadv_orig_node *orig,\n\t\t\t\t\t       u8 flags,\n\t\t\t\t\t       void *tvlv_value,\n\t\t\t\t\t       u16 tvlv_value_len),\n\t\t\t\t  int (*uptr)(struct batadv_priv *bat_priv,\n\t\t\t\t\t      u8 *src, u8 *dst,\n\t\t\t\t\t      void *tvlv_value,\n\t\t\t\t\t      u16 tvlv_value_len),\n\t\t\t\t  int (*mptr)(struct batadv_priv *bat_priv,\n\t\t\t\t\t      struct sk_buff *skb),\n\t\t\t\t  u8 type, u8 version, u8 flags)\n{\n\tstruct batadv_tvlv_handler *tvlv_handler;\n\n\tspin_lock_bh(&bat_priv->tvlv.handler_list_lock);\n\n\ttvlv_handler = batadv_tvlv_handler_get(bat_priv, type, version);\n\tif (tvlv_handler) {\n\t\tspin_unlock_bh(&bat_priv->tvlv.handler_list_lock);\n\t\tbatadv_tvlv_handler_put(tvlv_handler);\n\t\treturn;\n\t}\n\n\ttvlv_handler = kzalloc(sizeof(*tvlv_handler), GFP_ATOMIC);\n\tif (!tvlv_handler) {\n\t\tspin_unlock_bh(&bat_priv->tvlv.handler_list_lock);\n\t\treturn;\n\t}\n\n\ttvlv_handler->ogm_handler = optr;\n\ttvlv_handler->unicast_handler = uptr;\n\ttvlv_handler->mcast_handler = mptr;\n\ttvlv_handler->type = type;\n\ttvlv_handler->version = version;\n\ttvlv_handler->flags = flags;\n\tkref_init(&tvlv_handler->refcount);\n\tINIT_HLIST_NODE(&tvlv_handler->list);\n\n\tkref_get(&tvlv_handler->refcount);\n\thlist_add_head_rcu(&tvlv_handler->list, &bat_priv->tvlv.handler_list);\n\tspin_unlock_bh(&bat_priv->tvlv.handler_list_lock);\n\n\t \n\tbatadv_tvlv_handler_put(tvlv_handler);\n}\n\n \nvoid batadv_tvlv_handler_unregister(struct batadv_priv *bat_priv,\n\t\t\t\t    u8 type, u8 version)\n{\n\tstruct batadv_tvlv_handler *tvlv_handler;\n\n\ttvlv_handler = batadv_tvlv_handler_get(bat_priv, type, version);\n\tif (!tvlv_handler)\n\t\treturn;\n\n\tbatadv_tvlv_handler_put(tvlv_handler);\n\tspin_lock_bh(&bat_priv->tvlv.handler_list_lock);\n\thlist_del_rcu(&tvlv_handler->list);\n\tspin_unlock_bh(&bat_priv->tvlv.handler_list_lock);\n\tbatadv_tvlv_handler_put(tvlv_handler);\n}\n\n \nvoid batadv_tvlv_unicast_send(struct batadv_priv *bat_priv, const u8 *src,\n\t\t\t      const u8 *dst, u8 type, u8 version,\n\t\t\t      void *tvlv_value, u16 tvlv_value_len)\n{\n\tstruct batadv_unicast_tvlv_packet *unicast_tvlv_packet;\n\tstruct batadv_tvlv_hdr *tvlv_hdr;\n\tstruct batadv_orig_node *orig_node;\n\tstruct sk_buff *skb;\n\tunsigned char *tvlv_buff;\n\tunsigned int tvlv_len;\n\tssize_t hdr_len = sizeof(*unicast_tvlv_packet);\n\n\torig_node = batadv_orig_hash_find(bat_priv, dst);\n\tif (!orig_node)\n\t\treturn;\n\n\ttvlv_len = sizeof(*tvlv_hdr) + tvlv_value_len;\n\n\tskb = netdev_alloc_skb_ip_align(NULL, ETH_HLEN + hdr_len + tvlv_len);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb_reserve(skb, ETH_HLEN);\n\ttvlv_buff = skb_put(skb, sizeof(*unicast_tvlv_packet) + tvlv_len);\n\tunicast_tvlv_packet = (struct batadv_unicast_tvlv_packet *)tvlv_buff;\n\tunicast_tvlv_packet->packet_type = BATADV_UNICAST_TVLV;\n\tunicast_tvlv_packet->version = BATADV_COMPAT_VERSION;\n\tunicast_tvlv_packet->ttl = BATADV_TTL;\n\tunicast_tvlv_packet->reserved = 0;\n\tunicast_tvlv_packet->tvlv_len = htons(tvlv_len);\n\tunicast_tvlv_packet->align = 0;\n\tether_addr_copy(unicast_tvlv_packet->src, src);\n\tether_addr_copy(unicast_tvlv_packet->dst, dst);\n\n\ttvlv_buff = (unsigned char *)(unicast_tvlv_packet + 1);\n\ttvlv_hdr = (struct batadv_tvlv_hdr *)tvlv_buff;\n\ttvlv_hdr->version = version;\n\ttvlv_hdr->type = type;\n\ttvlv_hdr->len = htons(tvlv_value_len);\n\ttvlv_buff += sizeof(*tvlv_hdr);\n\tmemcpy(tvlv_buff, tvlv_value, tvlv_value_len);\n\n\tbatadv_send_skb_to_orig(skb, orig_node, NULL);\nout:\n\tbatadv_orig_node_put(orig_node);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}