{
  "module_name": "distributed-arp-table.c",
  "hash_id": "c9ac545f497a9709ace19bff97a11fc75b5535be7ce767456cff51330b375634",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/distributed-arp-table.c",
  "human_readable_source": "\n \n\n#include \"distributed-arp-table.h\"\n#include \"main.h\"\n\n#include <asm/unaligned.h>\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/byteorder/generic.h>\n#include <linux/container_of.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/netlink.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/udp.h>\n#include <linux/workqueue.h>\n#include <net/arp.h>\n#include <net/genetlink.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"bridge_loop_avoidance.h\"\n#include \"hard-interface.h\"\n#include \"hash.h\"\n#include \"log.h\"\n#include \"netlink.h\"\n#include \"originator.h\"\n#include \"send.h\"\n#include \"soft-interface.h\"\n#include \"translation-table.h\"\n#include \"tvlv.h\"\n\nenum batadv_bootpop {\n\tBATADV_BOOTREPLY\t= 2,\n};\n\nenum batadv_boothtype {\n\tBATADV_HTYPE_ETHERNET\t= 1,\n};\n\nenum batadv_dhcpoptioncode {\n\tBATADV_DHCP_OPT_PAD\t\t= 0,\n\tBATADV_DHCP_OPT_MSG_TYPE\t= 53,\n\tBATADV_DHCP_OPT_END\t\t= 255,\n};\n\nenum batadv_dhcptype {\n\tBATADV_DHCPACK\t\t= 5,\n};\n\n \n#define BATADV_DHCP_MAGIC 1669485411\n\nstruct batadv_dhcp_packet {\n\t__u8 op;\n\t__u8 htype;\n\t__u8 hlen;\n\t__u8 hops;\n\t__be32 xid;\n\t__be16 secs;\n\t__be16 flags;\n\t__be32 ciaddr;\n\t__be32 yiaddr;\n\t__be32 siaddr;\n\t__be32 giaddr;\n\t__u8 chaddr[16];\n\t__u8 sname[64];\n\t__u8 file[128];\n\t__be32 magic;\n\t \n};\n\n#define BATADV_DHCP_YIADDR_LEN sizeof(((struct batadv_dhcp_packet *)0)->yiaddr)\n#define BATADV_DHCP_CHADDR_LEN sizeof(((struct batadv_dhcp_packet *)0)->chaddr)\n\nstatic void batadv_dat_purge(struct work_struct *work);\n\n \nstatic void batadv_dat_start_timer(struct batadv_priv *bat_priv)\n{\n\tqueue_delayed_work(batadv_event_workqueue, &bat_priv->dat.work,\n\t\t\t   msecs_to_jiffies(10000));\n}\n\n \nstatic void batadv_dat_entry_release(struct kref *ref)\n{\n\tstruct batadv_dat_entry *dat_entry;\n\n\tdat_entry = container_of(ref, struct batadv_dat_entry, refcount);\n\n\tkfree_rcu(dat_entry, rcu);\n}\n\n \nstatic void batadv_dat_entry_put(struct batadv_dat_entry *dat_entry)\n{\n\tif (!dat_entry)\n\t\treturn;\n\n\tkref_put(&dat_entry->refcount, batadv_dat_entry_release);\n}\n\n \nstatic bool batadv_dat_to_purge(struct batadv_dat_entry *dat_entry)\n{\n\treturn batadv_has_timed_out(dat_entry->last_update,\n\t\t\t\t    BATADV_DAT_ENTRY_TIMEOUT);\n}\n\n \nstatic void __batadv_dat_purge(struct batadv_priv *bat_priv,\n\t\t\t       bool (*to_purge)(struct batadv_dat_entry *))\n{\n\tspinlock_t *list_lock;  \n\tstruct batadv_dat_entry *dat_entry;\n\tstruct hlist_node *node_tmp;\n\tstruct hlist_head *head;\n\tu32 i;\n\n\tif (!bat_priv->dat.hash)\n\t\treturn;\n\n\tfor (i = 0; i < bat_priv->dat.hash->size; i++) {\n\t\thead = &bat_priv->dat.hash->table[i];\n\t\tlist_lock = &bat_priv->dat.hash->list_locks[i];\n\n\t\tspin_lock_bh(list_lock);\n\t\thlist_for_each_entry_safe(dat_entry, node_tmp, head,\n\t\t\t\t\t  hash_entry) {\n\t\t\t \n\t\t\tif (to_purge && !to_purge(dat_entry))\n\t\t\t\tcontinue;\n\n\t\t\thlist_del_rcu(&dat_entry->hash_entry);\n\t\t\tbatadv_dat_entry_put(dat_entry);\n\t\t}\n\t\tspin_unlock_bh(list_lock);\n\t}\n}\n\n \nstatic void batadv_dat_purge(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work;\n\tstruct batadv_priv_dat *priv_dat;\n\tstruct batadv_priv *bat_priv;\n\n\tdelayed_work = to_delayed_work(work);\n\tpriv_dat = container_of(delayed_work, struct batadv_priv_dat, work);\n\tbat_priv = container_of(priv_dat, struct batadv_priv, dat);\n\n\t__batadv_dat_purge(bat_priv, batadv_dat_to_purge);\n\tbatadv_dat_start_timer(bat_priv);\n}\n\n \nstatic bool batadv_compare_dat(const struct hlist_node *node, const void *data2)\n{\n\tconst void *data1 = container_of(node, struct batadv_dat_entry,\n\t\t\t\t\t hash_entry);\n\n\treturn memcmp(data1, data2, sizeof(__be32)) == 0;\n}\n\n \nstatic u8 *batadv_arp_hw_src(struct sk_buff *skb, int hdr_size)\n{\n\tu8 *addr;\n\n\taddr = (u8 *)(skb->data + hdr_size);\n\taddr += ETH_HLEN + sizeof(struct arphdr);\n\n\treturn addr;\n}\n\n \nstatic __be32 batadv_arp_ip_src(struct sk_buff *skb, int hdr_size)\n{\n\treturn *(__force __be32 *)(batadv_arp_hw_src(skb, hdr_size) + ETH_ALEN);\n}\n\n \nstatic u8 *batadv_arp_hw_dst(struct sk_buff *skb, int hdr_size)\n{\n\treturn batadv_arp_hw_src(skb, hdr_size) + ETH_ALEN + 4;\n}\n\n \nstatic __be32 batadv_arp_ip_dst(struct sk_buff *skb, int hdr_size)\n{\n\tu8 *dst = batadv_arp_hw_src(skb, hdr_size) + ETH_ALEN * 2 + 4;\n\n\treturn *(__force __be32 *)dst;\n}\n\n \nstatic u32 batadv_hash_dat(const void *data, u32 size)\n{\n\tu32 hash = 0;\n\tconst struct batadv_dat_entry *dat = data;\n\tconst unsigned char *key;\n\t__be16 vid;\n\tu32 i;\n\n\tkey = (__force const unsigned char *)&dat->ip;\n\tfor (i = 0; i < sizeof(dat->ip); i++) {\n\t\thash += key[i];\n\t\thash += (hash << 10);\n\t\thash ^= (hash >> 6);\n\t}\n\n\tvid = htons(dat->vid);\n\tkey = (__force const unsigned char *)&vid;\n\tfor (i = 0; i < sizeof(dat->vid); i++) {\n\t\thash += key[i];\n\t\thash += (hash << 10);\n\t\thash ^= (hash >> 6);\n\t}\n\n\thash += (hash << 3);\n\thash ^= (hash >> 11);\n\thash += (hash << 15);\n\n\treturn hash % size;\n}\n\n \nstatic struct batadv_dat_entry *\nbatadv_dat_entry_hash_find(struct batadv_priv *bat_priv, __be32 ip,\n\t\t\t   unsigned short vid)\n{\n\tstruct hlist_head *head;\n\tstruct batadv_dat_entry to_find, *dat_entry, *dat_entry_tmp = NULL;\n\tstruct batadv_hashtable *hash = bat_priv->dat.hash;\n\tu32 index;\n\n\tif (!hash)\n\t\treturn NULL;\n\n\tto_find.ip = ip;\n\tto_find.vid = vid;\n\n\tindex = batadv_hash_dat(&to_find, hash->size);\n\thead = &hash->table[index];\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(dat_entry, head, hash_entry) {\n\t\tif (dat_entry->ip != ip)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&dat_entry->refcount))\n\t\t\tcontinue;\n\n\t\tdat_entry_tmp = dat_entry;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn dat_entry_tmp;\n}\n\n \nstatic void batadv_dat_entry_add(struct batadv_priv *bat_priv, __be32 ip,\n\t\t\t\t u8 *mac_addr, unsigned short vid)\n{\n\tstruct batadv_dat_entry *dat_entry;\n\tint hash_added;\n\n\tdat_entry = batadv_dat_entry_hash_find(bat_priv, ip, vid);\n\t \n\tif (dat_entry) {\n\t\tif (!batadv_compare_eth(dat_entry->mac_addr, mac_addr))\n\t\t\tether_addr_copy(dat_entry->mac_addr, mac_addr);\n\t\tdat_entry->last_update = jiffies;\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t\t   \"Entry updated: %pI4 %pM (vid: %d)\\n\",\n\t\t\t   &dat_entry->ip, dat_entry->mac_addr,\n\t\t\t   batadv_print_vid(vid));\n\t\tgoto out;\n\t}\n\n\tdat_entry = kmalloc(sizeof(*dat_entry), GFP_ATOMIC);\n\tif (!dat_entry)\n\t\tgoto out;\n\n\tdat_entry->ip = ip;\n\tdat_entry->vid = vid;\n\tether_addr_copy(dat_entry->mac_addr, mac_addr);\n\tdat_entry->last_update = jiffies;\n\tkref_init(&dat_entry->refcount);\n\n\tkref_get(&dat_entry->refcount);\n\thash_added = batadv_hash_add(bat_priv->dat.hash, batadv_compare_dat,\n\t\t\t\t     batadv_hash_dat, dat_entry,\n\t\t\t\t     &dat_entry->hash_entry);\n\n\tif (unlikely(hash_added != 0)) {\n\t\t \n\t\tbatadv_dat_entry_put(dat_entry);\n\t\tgoto out;\n\t}\n\n\tbatadv_dbg(BATADV_DBG_DAT, bat_priv, \"New entry added: %pI4 %pM (vid: %d)\\n\",\n\t\t   &dat_entry->ip, dat_entry->mac_addr, batadv_print_vid(vid));\n\nout:\n\tbatadv_dat_entry_put(dat_entry);\n}\n\n#ifdef CONFIG_BATMAN_ADV_DEBUG\n\n \nstatic void batadv_dbg_arp(struct batadv_priv *bat_priv, struct sk_buff *skb,\n\t\t\t   int hdr_size, char *msg)\n{\n\tstruct batadv_unicast_4addr_packet *unicast_4addr_packet;\n\tstruct batadv_bcast_packet *bcast_pkt;\n\tu8 *orig_addr;\n\t__be32 ip_src, ip_dst;\n\n\tif (msg)\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv, \"%s\\n\", msg);\n\n\tip_src = batadv_arp_ip_src(skb, hdr_size);\n\tip_dst = batadv_arp_ip_dst(skb, hdr_size);\n\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t   \"ARP MSG = [src: %pM-%pI4 dst: %pM-%pI4]\\n\",\n\t\t   batadv_arp_hw_src(skb, hdr_size), &ip_src,\n\t\t   batadv_arp_hw_dst(skb, hdr_size), &ip_dst);\n\n\tif (hdr_size < sizeof(struct batadv_unicast_packet))\n\t\treturn;\n\n\tunicast_4addr_packet = (struct batadv_unicast_4addr_packet *)skb->data;\n\n\tswitch (unicast_4addr_packet->u.packet_type) {\n\tcase BATADV_UNICAST:\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t\t   \"* encapsulated within a UNICAST packet\\n\");\n\t\tbreak;\n\tcase BATADV_UNICAST_4ADDR:\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t\t   \"* encapsulated within a UNICAST_4ADDR packet (src: %pM)\\n\",\n\t\t\t   unicast_4addr_packet->src);\n\t\tswitch (unicast_4addr_packet->subtype) {\n\t\tcase BATADV_P_DAT_DHT_PUT:\n\t\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv, \"* type: DAT_DHT_PUT\\n\");\n\t\t\tbreak;\n\t\tcase BATADV_P_DAT_DHT_GET:\n\t\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv, \"* type: DAT_DHT_GET\\n\");\n\t\t\tbreak;\n\t\tcase BATADV_P_DAT_CACHE_REPLY:\n\t\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t\t\t   \"* type: DAT_CACHE_REPLY\\n\");\n\t\t\tbreak;\n\t\tcase BATADV_P_DATA:\n\t\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv, \"* type: DATA\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv, \"* type: Unknown (%u)!\\n\",\n\t\t\t\t   unicast_4addr_packet->u.packet_type);\n\t\t}\n\t\tbreak;\n\tcase BATADV_BCAST:\n\t\tbcast_pkt = (struct batadv_bcast_packet *)unicast_4addr_packet;\n\t\torig_addr = bcast_pkt->orig;\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t\t   \"* encapsulated within a BCAST packet (src: %pM)\\n\",\n\t\t\t   orig_addr);\n\t\tbreak;\n\tdefault:\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t\t   \"* encapsulated within an unknown packet type (0x%x)\\n\",\n\t\t\t   unicast_4addr_packet->u.packet_type);\n\t}\n}\n\n#else\n\nstatic void batadv_dbg_arp(struct batadv_priv *bat_priv, struct sk_buff *skb,\n\t\t\t   int hdr_size, char *msg)\n{\n}\n\n#endif  \n\n \nstatic bool batadv_is_orig_node_eligible(struct batadv_dat_candidate *res,\n\t\t\t\t\t int select, batadv_dat_addr_t tmp_max,\n\t\t\t\t\t batadv_dat_addr_t max,\n\t\t\t\t\t batadv_dat_addr_t last_max,\n\t\t\t\t\t struct batadv_orig_node *candidate,\n\t\t\t\t\t struct batadv_orig_node *max_orig_node)\n{\n\tbool ret = false;\n\tint j;\n\n\t \n\tif (!test_bit(BATADV_ORIG_CAPA_HAS_DAT, &candidate->capabilities))\n\t\tgoto out;\n\n\t \n\tfor (j = 0; j < select; j++)\n\t\tif (res[j].orig_node == candidate)\n\t\t\tbreak;\n\t \n\tif (j < select)\n\t\tgoto out;\n\t \n\tif (tmp_max > last_max)\n\t\tgoto out;\n\t \n\tif (tmp_max < max)\n\t\tgoto out;\n\t \n\tif (tmp_max == max && max_orig_node &&\n\t    batadv_compare_eth(candidate->orig, max_orig_node->orig))\n\t\tgoto out;\n\n\tret = true;\nout:\n\treturn ret;\n}\n\n \nstatic void batadv_choose_next_candidate(struct batadv_priv *bat_priv,\n\t\t\t\t\t struct batadv_dat_candidate *cands,\n\t\t\t\t\t int select, batadv_dat_addr_t ip_key,\n\t\t\t\t\t batadv_dat_addr_t *last_max)\n{\n\tbatadv_dat_addr_t max = 0;\n\tbatadv_dat_addr_t tmp_max = 0;\n\tstruct batadv_orig_node *orig_node, *max_orig_node = NULL;\n\tstruct batadv_hashtable *hash = bat_priv->orig_hash;\n\tstruct hlist_head *head;\n\tint i;\n\n\t \n\tcands[select].type = BATADV_DAT_CANDIDATE_NOT_FOUND;\n\n\t \n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(orig_node, head, hash_entry) {\n\t\t\t \n\t\t\ttmp_max = BATADV_DAT_ADDR_MAX - orig_node->dat_addr +\n\t\t\t\t  ip_key;\n\n\t\t\tif (!batadv_is_orig_node_eligible(cands, select,\n\t\t\t\t\t\t\t  tmp_max, max,\n\t\t\t\t\t\t\t  *last_max, orig_node,\n\t\t\t\t\t\t\t  max_orig_node))\n\t\t\t\tcontinue;\n\n\t\t\tif (!kref_get_unless_zero(&orig_node->refcount))\n\t\t\t\tcontinue;\n\n\t\t\tmax = tmp_max;\n\t\t\tbatadv_orig_node_put(max_orig_node);\n\t\t\tmax_orig_node = orig_node;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (max_orig_node) {\n\t\tcands[select].type = BATADV_DAT_CANDIDATE_ORIG;\n\t\tcands[select].orig_node = max_orig_node;\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t\t   \"dat_select_candidates() %d: selected %pM addr=%u dist=%u\\n\",\n\t\t\t   select, max_orig_node->orig, max_orig_node->dat_addr,\n\t\t\t   max);\n\t}\n\t*last_max = max;\n}\n\n \nstatic struct batadv_dat_candidate *\nbatadv_dat_select_candidates(struct batadv_priv *bat_priv, __be32 ip_dst,\n\t\t\t     unsigned short vid)\n{\n\tint select;\n\tbatadv_dat_addr_t last_max = BATADV_DAT_ADDR_MAX, ip_key;\n\tstruct batadv_dat_candidate *res;\n\tstruct batadv_dat_entry dat;\n\n\tif (!bat_priv->orig_hash)\n\t\treturn NULL;\n\n\tres = kmalloc_array(BATADV_DAT_CANDIDATES_NUM, sizeof(*res),\n\t\t\t    GFP_ATOMIC);\n\tif (!res)\n\t\treturn NULL;\n\n\tdat.ip = ip_dst;\n\tdat.vid = vid;\n\tip_key = (batadv_dat_addr_t)batadv_hash_dat(&dat,\n\t\t\t\t\t\t    BATADV_DAT_ADDR_MAX);\n\n\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t   \"%s(): IP=%pI4 hash(IP)=%u\\n\", __func__, &ip_dst,\n\t\t   ip_key);\n\n\tfor (select = 0; select < BATADV_DAT_CANDIDATES_NUM; select++)\n\t\tbatadv_choose_next_candidate(bat_priv, res, select, ip_key,\n\t\t\t\t\t     &last_max);\n\n\treturn res;\n}\n\n \nstatic bool batadv_dat_forward_data(struct batadv_priv *bat_priv,\n\t\t\t\t    struct sk_buff *skb, __be32 ip,\n\t\t\t\t    unsigned short vid, int packet_subtype)\n{\n\tint i;\n\tbool ret = false;\n\tint send_status;\n\tstruct batadv_neigh_node *neigh_node = NULL;\n\tstruct sk_buff *tmp_skb;\n\tstruct batadv_dat_candidate *cand;\n\n\tcand = batadv_dat_select_candidates(bat_priv, ip, vid);\n\tif (!cand)\n\t\tgoto out;\n\n\tbatadv_dbg(BATADV_DBG_DAT, bat_priv, \"DHT_SEND for %pI4\\n\", &ip);\n\n\tfor (i = 0; i < BATADV_DAT_CANDIDATES_NUM; i++) {\n\t\tif (cand[i].type == BATADV_DAT_CANDIDATE_NOT_FOUND)\n\t\t\tcontinue;\n\n\t\tneigh_node = batadv_orig_router_get(cand[i].orig_node,\n\t\t\t\t\t\t    BATADV_IF_DEFAULT);\n\t\tif (!neigh_node)\n\t\t\tgoto free_orig;\n\n\t\ttmp_skb = pskb_copy_for_clone(skb, GFP_ATOMIC);\n\t\tif (!batadv_send_skb_prepare_unicast_4addr(bat_priv, tmp_skb,\n\t\t\t\t\t\t\t   cand[i].orig_node,\n\t\t\t\t\t\t\t   packet_subtype)) {\n\t\t\tkfree_skb(tmp_skb);\n\t\t\tgoto free_neigh;\n\t\t}\n\n\t\tsend_status = batadv_send_unicast_skb(tmp_skb, neigh_node);\n\t\tif (send_status == NET_XMIT_SUCCESS) {\n\t\t\t \n\t\t\tswitch (packet_subtype) {\n\t\t\tcase BATADV_P_DAT_DHT_GET:\n\t\t\t\tbatadv_inc_counter(bat_priv,\n\t\t\t\t\t\t   BATADV_CNT_DAT_GET_TX);\n\t\t\t\tbreak;\n\t\t\tcase BATADV_P_DAT_DHT_PUT:\n\t\t\t\tbatadv_inc_counter(bat_priv,\n\t\t\t\t\t\t   BATADV_CNT_DAT_PUT_TX);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = true;\n\t\t}\nfree_neigh:\n\t\tbatadv_neigh_node_put(neigh_node);\nfree_orig:\n\t\tbatadv_orig_node_put(cand[i].orig_node);\n\t}\n\nout:\n\tkfree(cand);\n\treturn ret;\n}\n\n \nstatic void batadv_dat_tvlv_container_update(struct batadv_priv *bat_priv)\n{\n\tchar dat_mode;\n\n\tdat_mode = atomic_read(&bat_priv->distributed_arp_table);\n\n\tswitch (dat_mode) {\n\tcase 0:\n\t\tbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_DAT, 1);\n\t\tbreak;\n\tcase 1:\n\t\tbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_DAT, 1,\n\t\t\t\t\t       NULL, 0);\n\t\tbreak;\n\t}\n}\n\n \nvoid batadv_dat_status_update(struct net_device *net_dev)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(net_dev);\n\n\tbatadv_dat_tvlv_container_update(bat_priv);\n}\n\n \nstatic void batadv_dat_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,\n\t\t\t\t\t   struct batadv_orig_node *orig,\n\t\t\t\t\t   u8 flags,\n\t\t\t\t\t   void *tvlv_value, u16 tvlv_value_len)\n{\n\tif (flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND)\n\t\tclear_bit(BATADV_ORIG_CAPA_HAS_DAT, &orig->capabilities);\n\telse\n\t\tset_bit(BATADV_ORIG_CAPA_HAS_DAT, &orig->capabilities);\n}\n\n \nstatic void batadv_dat_hash_free(struct batadv_priv *bat_priv)\n{\n\tif (!bat_priv->dat.hash)\n\t\treturn;\n\n\t__batadv_dat_purge(bat_priv, NULL);\n\n\tbatadv_hash_destroy(bat_priv->dat.hash);\n\n\tbat_priv->dat.hash = NULL;\n}\n\n \nint batadv_dat_init(struct batadv_priv *bat_priv)\n{\n\tif (bat_priv->dat.hash)\n\t\treturn 0;\n\n\tbat_priv->dat.hash = batadv_hash_new(1024);\n\n\tif (!bat_priv->dat.hash)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&bat_priv->dat.work, batadv_dat_purge);\n\tbatadv_dat_start_timer(bat_priv);\n\n\tbatadv_tvlv_handler_register(bat_priv, batadv_dat_tvlv_ogm_handler_v1,\n\t\t\t\t     NULL, NULL, BATADV_TVLV_DAT, 1,\n\t\t\t\t     BATADV_TVLV_HANDLER_OGM_CIFNOTFND);\n\tbatadv_dat_tvlv_container_update(bat_priv);\n\treturn 0;\n}\n\n \nvoid batadv_dat_free(struct batadv_priv *bat_priv)\n{\n\tbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_DAT, 1);\n\tbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_DAT, 1);\n\n\tcancel_delayed_work_sync(&bat_priv->dat.work);\n\n\tbatadv_dat_hash_free(bat_priv);\n}\n\n \nstatic int\nbatadv_dat_cache_dump_entry(struct sk_buff *msg, u32 portid,\n\t\t\t    struct netlink_callback *cb,\n\t\t\t    struct batadv_dat_entry *dat_entry)\n{\n\tint msecs;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, cb->nlh->nlmsg_seq,\n\t\t\t  &batadv_netlink_family, NLM_F_MULTI,\n\t\t\t  BATADV_CMD_GET_DAT_CACHE);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tmsecs = jiffies_to_msecs(jiffies - dat_entry->last_update);\n\n\tif (nla_put_in_addr(msg, BATADV_ATTR_DAT_CACHE_IP4ADDRESS,\n\t\t\t    dat_entry->ip) ||\n\t    nla_put(msg, BATADV_ATTR_DAT_CACHE_HWADDRESS, ETH_ALEN,\n\t\t    dat_entry->mac_addr) ||\n\t    nla_put_u16(msg, BATADV_ATTR_DAT_CACHE_VID, dat_entry->vid) ||\n\t    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS, msecs)) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n}\n\n \nstatic int\nbatadv_dat_cache_dump_bucket(struct sk_buff *msg, u32 portid,\n\t\t\t     struct netlink_callback *cb,\n\t\t\t     struct batadv_hashtable *hash, unsigned int bucket,\n\t\t\t     int *idx_skip)\n{\n\tstruct batadv_dat_entry *dat_entry;\n\tint idx = 0;\n\n\tspin_lock_bh(&hash->list_locks[bucket]);\n\tcb->seq = atomic_read(&hash->generation) << 1 | 1;\n\n\thlist_for_each_entry(dat_entry, &hash->table[bucket], hash_entry) {\n\t\tif (idx < *idx_skip)\n\t\t\tgoto skip;\n\n\t\tif (batadv_dat_cache_dump_entry(msg, portid, cb, dat_entry)) {\n\t\t\tspin_unlock_bh(&hash->list_locks[bucket]);\n\t\t\t*idx_skip = idx;\n\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\nskip:\n\t\tidx++;\n\t}\n\tspin_unlock_bh(&hash->list_locks[bucket]);\n\n\treturn 0;\n}\n\n \nint batadv_dat_cache_dump(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tint portid = NETLINK_CB(cb->skb).portid;\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct net_device *soft_iface;\n\tstruct batadv_hashtable *hash;\n\tstruct batadv_priv *bat_priv;\n\tint bucket = cb->args[0];\n\tint idx = cb->args[1];\n\tint ifindex;\n\tint ret = 0;\n\n\tifindex = batadv_netlink_get_ifindex(cb->nlh,\n\t\t\t\t\t     BATADV_ATTR_MESH_IFINDEX);\n\tif (!ifindex)\n\t\treturn -EINVAL;\n\n\tsoft_iface = dev_get_by_index(net, ifindex);\n\tif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tbat_priv = netdev_priv(soft_iface);\n\thash = bat_priv->dat.hash;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\twhile (bucket < hash->size) {\n\t\tif (batadv_dat_cache_dump_bucket(msg, portid, cb, hash, bucket,\n\t\t\t\t\t\t &idx))\n\t\t\tbreak;\n\n\t\tbucket++;\n\t\tidx = 0;\n\t}\n\n\tcb->args[0] = bucket;\n\tcb->args[1] = idx;\n\n\tret = msg->len;\n\nout:\n\tbatadv_hardif_put(primary_if);\n\n\tdev_put(soft_iface);\n\n\treturn ret;\n}\n\n \nstatic u16 batadv_arp_get_type(struct batadv_priv *bat_priv,\n\t\t\t       struct sk_buff *skb, int hdr_size)\n{\n\tstruct arphdr *arphdr;\n\tstruct ethhdr *ethhdr;\n\t__be32 ip_src, ip_dst;\n\tu8 *hw_src, *hw_dst;\n\tu16 type = 0;\n\n\t \n\tif (unlikely(!pskb_may_pull(skb, hdr_size + ETH_HLEN)))\n\t\tgoto out;\n\n\tethhdr = (struct ethhdr *)(skb->data + hdr_size);\n\n\tif (ethhdr->h_proto != htons(ETH_P_ARP))\n\t\tgoto out;\n\n\t \n\tif (unlikely(!pskb_may_pull(skb, hdr_size + ETH_HLEN +\n\t\t\t\t    arp_hdr_len(skb->dev))))\n\t\tgoto out;\n\n\tarphdr = (struct arphdr *)(skb->data + hdr_size + ETH_HLEN);\n\n\t \n\tif (arphdr->ar_hrd != htons(ARPHRD_ETHER))\n\t\tgoto out;\n\n\tif (arphdr->ar_pro != htons(ETH_P_IP))\n\t\tgoto out;\n\n\tif (arphdr->ar_hln != ETH_ALEN)\n\t\tgoto out;\n\n\tif (arphdr->ar_pln != 4)\n\t\tgoto out;\n\n\t \n\tip_src = batadv_arp_ip_src(skb, hdr_size);\n\tip_dst = batadv_arp_ip_dst(skb, hdr_size);\n\tif (ipv4_is_loopback(ip_src) || ipv4_is_multicast(ip_src) ||\n\t    ipv4_is_loopback(ip_dst) || ipv4_is_multicast(ip_dst) ||\n\t    ipv4_is_zeronet(ip_src) || ipv4_is_lbcast(ip_src) ||\n\t    ipv4_is_zeronet(ip_dst) || ipv4_is_lbcast(ip_dst))\n\t\tgoto out;\n\n\thw_src = batadv_arp_hw_src(skb, hdr_size);\n\tif (is_zero_ether_addr(hw_src) || is_multicast_ether_addr(hw_src))\n\t\tgoto out;\n\n\t \n\tif (arphdr->ar_op != htons(ARPOP_REQUEST)) {\n\t\thw_dst = batadv_arp_hw_dst(skb, hdr_size);\n\t\tif (is_zero_ether_addr(hw_dst) ||\n\t\t    is_multicast_ether_addr(hw_dst))\n\t\t\tgoto out;\n\t}\n\n\ttype = ntohs(arphdr->ar_op);\nout:\n\treturn type;\n}\n\n \nstatic unsigned short batadv_dat_get_vid(struct sk_buff *skb, int *hdr_size)\n{\n\tunsigned short vid;\n\n\tvid = batadv_get_vid(skb, *hdr_size);\n\n\t \n\tif (vid & BATADV_VLAN_HAS_TAG)\n\t\t*hdr_size += VLAN_HLEN;\n\n\treturn vid;\n}\n\n \nstatic struct sk_buff *\nbatadv_dat_arp_create_reply(struct batadv_priv *bat_priv, __be32 ip_src,\n\t\t\t    __be32 ip_dst, u8 *hw_src, u8 *hw_dst,\n\t\t\t    unsigned short vid)\n{\n\tstruct sk_buff *skb;\n\n\tskb = arp_create(ARPOP_REPLY, ETH_P_ARP, ip_dst, bat_priv->soft_iface,\n\t\t\t ip_src, hw_dst, hw_src, hw_dst);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reset_mac_header(skb);\n\n\tif (vid & BATADV_VLAN_HAS_TAG)\n\t\tskb = vlan_insert_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t      vid & VLAN_VID_MASK);\n\n\treturn skb;\n}\n\n \nbool batadv_dat_snoop_outgoing_arp_request(struct batadv_priv *bat_priv,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tu16 type = 0;\n\t__be32 ip_dst, ip_src;\n\tu8 *hw_src;\n\tbool ret = false;\n\tstruct batadv_dat_entry *dat_entry = NULL;\n\tstruct sk_buff *skb_new;\n\tstruct net_device *soft_iface = bat_priv->soft_iface;\n\tint hdr_size = 0;\n\tunsigned short vid;\n\n\tif (!atomic_read(&bat_priv->distributed_arp_table))\n\t\tgoto out;\n\n\tvid = batadv_dat_get_vid(skb, &hdr_size);\n\n\ttype = batadv_arp_get_type(bat_priv, skb, hdr_size);\n\t \n\tif (type != ARPOP_REQUEST)\n\t\tgoto out;\n\n\tbatadv_dbg_arp(bat_priv, skb, hdr_size, \"Parsing outgoing ARP REQUEST\");\n\n\tip_src = batadv_arp_ip_src(skb, hdr_size);\n\thw_src = batadv_arp_hw_src(skb, hdr_size);\n\tip_dst = batadv_arp_ip_dst(skb, hdr_size);\n\n\tbatadv_dat_entry_add(bat_priv, ip_src, hw_src, vid);\n\n\tdat_entry = batadv_dat_entry_hash_find(bat_priv, ip_dst, vid);\n\tif (dat_entry) {\n\t\t \n\t\tif (batadv_is_my_client(bat_priv, dat_entry->mac_addr, vid)) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (!batadv_bla_check_claim(bat_priv,\n\t\t\t\t\t    dat_entry->mac_addr, vid)) {\n\t\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t\t\t   \"Device %pM claimed by another backbone gw. Don't send ARP reply!\",\n\t\t\t\t   dat_entry->mac_addr);\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\tskb_new = batadv_dat_arp_create_reply(bat_priv, ip_dst, ip_src,\n\t\t\t\t\t\t      dat_entry->mac_addr,\n\t\t\t\t\t\t      hw_src, vid);\n\t\tif (!skb_new)\n\t\t\tgoto out;\n\n\t\tskb_new->protocol = eth_type_trans(skb_new, soft_iface);\n\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_RX);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_RX_BYTES,\n\t\t\t\t   skb->len + ETH_HLEN + hdr_size);\n\n\t\tnetif_rx(skb_new);\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv, \"ARP request replied locally\\n\");\n\t\tret = true;\n\t} else {\n\t\t \n\t\tret = batadv_dat_forward_data(bat_priv, skb, ip_dst, vid,\n\t\t\t\t\t      BATADV_P_DAT_DHT_GET);\n\t}\nout:\n\tbatadv_dat_entry_put(dat_entry);\n\treturn ret;\n}\n\n \nbool batadv_dat_snoop_incoming_arp_request(struct batadv_priv *bat_priv,\n\t\t\t\t\t   struct sk_buff *skb, int hdr_size)\n{\n\tu16 type;\n\t__be32 ip_src, ip_dst;\n\tu8 *hw_src;\n\tstruct sk_buff *skb_new;\n\tstruct batadv_dat_entry *dat_entry = NULL;\n\tbool ret = false;\n\tunsigned short vid;\n\tint err;\n\n\tif (!atomic_read(&bat_priv->distributed_arp_table))\n\t\tgoto out;\n\n\tvid = batadv_dat_get_vid(skb, &hdr_size);\n\n\ttype = batadv_arp_get_type(bat_priv, skb, hdr_size);\n\tif (type != ARPOP_REQUEST)\n\t\tgoto out;\n\n\thw_src = batadv_arp_hw_src(skb, hdr_size);\n\tip_src = batadv_arp_ip_src(skb, hdr_size);\n\tip_dst = batadv_arp_ip_dst(skb, hdr_size);\n\n\tbatadv_dbg_arp(bat_priv, skb, hdr_size, \"Parsing incoming ARP REQUEST\");\n\n\tbatadv_dat_entry_add(bat_priv, ip_src, hw_src, vid);\n\n\tdat_entry = batadv_dat_entry_hash_find(bat_priv, ip_dst, vid);\n\tif (!dat_entry)\n\t\tgoto out;\n\n\tskb_new = batadv_dat_arp_create_reply(bat_priv, ip_dst, ip_src,\n\t\t\t\t\t      dat_entry->mac_addr, hw_src, vid);\n\tif (!skb_new)\n\t\tgoto out;\n\n\t \n\tif (hdr_size == sizeof(struct batadv_unicast_4addr_packet))\n\t\terr = batadv_send_skb_via_tt_4addr(bat_priv, skb_new,\n\t\t\t\t\t\t   BATADV_P_DAT_CACHE_REPLY,\n\t\t\t\t\t\t   NULL, vid);\n\telse\n\t\terr = batadv_send_skb_via_tt(bat_priv, skb_new, NULL, vid);\n\n\tif (err != NET_XMIT_DROP) {\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_DAT_CACHED_REPLY_TX);\n\t\tret = true;\n\t}\nout:\n\tbatadv_dat_entry_put(dat_entry);\n\tif (ret)\n\t\tkfree_skb(skb);\n\treturn ret;\n}\n\n \nvoid batadv_dat_snoop_outgoing_arp_reply(struct batadv_priv *bat_priv,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tu16 type;\n\t__be32 ip_src, ip_dst;\n\tu8 *hw_src, *hw_dst;\n\tint hdr_size = 0;\n\tunsigned short vid;\n\n\tif (!atomic_read(&bat_priv->distributed_arp_table))\n\t\treturn;\n\n\tvid = batadv_dat_get_vid(skb, &hdr_size);\n\n\ttype = batadv_arp_get_type(bat_priv, skb, hdr_size);\n\tif (type != ARPOP_REPLY)\n\t\treturn;\n\n\tbatadv_dbg_arp(bat_priv, skb, hdr_size, \"Parsing outgoing ARP REPLY\");\n\n\thw_src = batadv_arp_hw_src(skb, hdr_size);\n\tip_src = batadv_arp_ip_src(skb, hdr_size);\n\thw_dst = batadv_arp_hw_dst(skb, hdr_size);\n\tip_dst = batadv_arp_ip_dst(skb, hdr_size);\n\n\tbatadv_dat_entry_add(bat_priv, ip_src, hw_src, vid);\n\tbatadv_dat_entry_add(bat_priv, ip_dst, hw_dst, vid);\n\n\t \n\tbatadv_dat_forward_data(bat_priv, skb, ip_src, vid,\n\t\t\t\tBATADV_P_DAT_DHT_PUT);\n\tbatadv_dat_forward_data(bat_priv, skb, ip_dst, vid,\n\t\t\t\tBATADV_P_DAT_DHT_PUT);\n}\n\n \nbool batadv_dat_snoop_incoming_arp_reply(struct batadv_priv *bat_priv,\n\t\t\t\t\t struct sk_buff *skb, int hdr_size)\n{\n\tstruct batadv_dat_entry *dat_entry = NULL;\n\tu16 type;\n\t__be32 ip_src, ip_dst;\n\tu8 *hw_src, *hw_dst;\n\tbool dropped = false;\n\tunsigned short vid;\n\n\tif (!atomic_read(&bat_priv->distributed_arp_table))\n\t\tgoto out;\n\n\tvid = batadv_dat_get_vid(skb, &hdr_size);\n\n\ttype = batadv_arp_get_type(bat_priv, skb, hdr_size);\n\tif (type != ARPOP_REPLY)\n\t\tgoto out;\n\n\tbatadv_dbg_arp(bat_priv, skb, hdr_size, \"Parsing incoming ARP REPLY\");\n\n\thw_src = batadv_arp_hw_src(skb, hdr_size);\n\tip_src = batadv_arp_ip_src(skb, hdr_size);\n\thw_dst = batadv_arp_hw_dst(skb, hdr_size);\n\tip_dst = batadv_arp_ip_dst(skb, hdr_size);\n\n\t \n\tdat_entry = batadv_dat_entry_hash_find(bat_priv, ip_src, vid);\n\tif (dat_entry && batadv_compare_eth(hw_src, dat_entry->mac_addr)) {\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv, \"Doubled ARP reply removed: ARP MSG = [src: %pM-%pI4 dst: %pM-%pI4]; dat_entry: %pM-%pI4\\n\",\n\t\t\t   hw_src, &ip_src, hw_dst, &ip_dst,\n\t\t\t   dat_entry->mac_addr,\t&dat_entry->ip);\n\t\tdropped = true;\n\t}\n\n\t \n\tbatadv_dat_entry_add(bat_priv, ip_src, hw_src, vid);\n\tbatadv_dat_entry_add(bat_priv, ip_dst, hw_dst, vid);\n\n\tif (dropped)\n\t\tgoto out;\n\n\t \n\tif (!batadv_bla_check_claim(bat_priv, hw_src, vid)) {\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t\t   \"Device %pM claimed by another backbone gw. Drop ARP reply.\\n\",\n\t\t\t   hw_src);\n\t\tdropped = true;\n\t\tgoto out;\n\t}\n\n\t \n\tdropped = !batadv_is_my_client(bat_priv, hw_dst, vid);\n\n\t \n\tdropped |= batadv_is_my_client(bat_priv, hw_src, vid);\nout:\n\tif (dropped)\n\t\tkfree_skb(skb);\n\tbatadv_dat_entry_put(dat_entry);\n\t \n\treturn dropped;\n}\n\n \nstatic bool\nbatadv_dat_check_dhcp_ipudp(struct sk_buff *skb, __be32 *ip_src)\n{\n\tunsigned int offset = skb_network_offset(skb);\n\tstruct udphdr *udphdr, _udphdr;\n\tstruct iphdr *iphdr, _iphdr;\n\n\tiphdr = skb_header_pointer(skb, offset, sizeof(_iphdr), &_iphdr);\n\tif (!iphdr || iphdr->version != 4 || iphdr->ihl * 4 < sizeof(_iphdr))\n\t\treturn false;\n\n\tif (iphdr->protocol != IPPROTO_UDP)\n\t\treturn false;\n\n\toffset += iphdr->ihl * 4;\n\tskb_set_transport_header(skb, offset);\n\n\tudphdr = skb_header_pointer(skb, offset, sizeof(_udphdr), &_udphdr);\n\tif (!udphdr || udphdr->source != htons(67))\n\t\treturn false;\n\n\t*ip_src = get_unaligned(&iphdr->saddr);\n\n\treturn true;\n}\n\n \nstatic int\nbatadv_dat_check_dhcp(struct sk_buff *skb, __be16 proto, __be32 *ip_src)\n{\n\t__be32 *magic, _magic;\n\tunsigned int offset;\n\tstruct {\n\t\t__u8 op;\n\t\t__u8 htype;\n\t\t__u8 hlen;\n\t\t__u8 hops;\n\t} *dhcp_h, _dhcp_h;\n\n\tif (proto != htons(ETH_P_IP))\n\t\treturn -EINVAL;\n\n\tif (!batadv_dat_check_dhcp_ipudp(skb, ip_src))\n\t\treturn -EINVAL;\n\n\toffset = skb_transport_offset(skb) + sizeof(struct udphdr);\n\tif (skb->len < offset + sizeof(struct batadv_dhcp_packet))\n\t\treturn -EINVAL;\n\n\tdhcp_h = skb_header_pointer(skb, offset, sizeof(_dhcp_h), &_dhcp_h);\n\tif (!dhcp_h || dhcp_h->htype != BATADV_HTYPE_ETHERNET ||\n\t    dhcp_h->hlen != ETH_ALEN)\n\t\treturn -EINVAL;\n\n\toffset += offsetof(struct batadv_dhcp_packet, magic);\n\n\tmagic = skb_header_pointer(skb, offset, sizeof(_magic), &_magic);\n\tif (!magic || get_unaligned(magic) != htonl(BATADV_DHCP_MAGIC))\n\t\treturn -EINVAL;\n\n\treturn dhcp_h->op;\n}\n\n \nstatic int batadv_dat_get_dhcp_message_type(struct sk_buff *skb)\n{\n\tunsigned int offset = skb_transport_offset(skb) + sizeof(struct udphdr);\n\tu8 *type, _type;\n\tstruct {\n\t\tu8 type;\n\t\tu8 len;\n\t} *tl, _tl;\n\n\toffset += sizeof(struct batadv_dhcp_packet);\n\n\twhile ((tl = skb_header_pointer(skb, offset, sizeof(_tl), &_tl))) {\n\t\tif (tl->type == BATADV_DHCP_OPT_MSG_TYPE)\n\t\t\tbreak;\n\n\t\tif (tl->type == BATADV_DHCP_OPT_END)\n\t\t\tbreak;\n\n\t\tif (tl->type == BATADV_DHCP_OPT_PAD)\n\t\t\toffset++;\n\t\telse\n\t\t\toffset += tl->len + sizeof(_tl);\n\t}\n\n\t \n\tif (!tl || tl->type != BATADV_DHCP_OPT_MSG_TYPE ||\n\t    tl->len != sizeof(_type))\n\t\treturn -EINVAL;\n\n\toffset += sizeof(_tl);\n\n\ttype = skb_header_pointer(skb, offset, sizeof(_type), &_type);\n\tif (!type)\n\t\treturn -EINVAL;\n\n\treturn *type;\n}\n\n \nstatic bool batadv_dat_dhcp_get_yiaddr(struct sk_buff *skb, __be32 *buf)\n{\n\tunsigned int offset = skb_transport_offset(skb) + sizeof(struct udphdr);\n\t__be32 *yiaddr;\n\n\toffset += offsetof(struct batadv_dhcp_packet, yiaddr);\n\tyiaddr = skb_header_pointer(skb, offset, BATADV_DHCP_YIADDR_LEN, buf);\n\n\tif (!yiaddr)\n\t\treturn false;\n\n\tif (yiaddr != buf)\n\t\t*buf = get_unaligned(yiaddr);\n\n\treturn true;\n}\n\n \nstatic bool batadv_dat_get_dhcp_chaddr(struct sk_buff *skb, u8 *buf)\n{\n\tunsigned int offset = skb_transport_offset(skb) + sizeof(struct udphdr);\n\tu8 *chaddr;\n\n\toffset += offsetof(struct batadv_dhcp_packet, chaddr);\n\tchaddr = skb_header_pointer(skb, offset, BATADV_DHCP_CHADDR_LEN, buf);\n\n\tif (!chaddr)\n\t\treturn false;\n\n\tif (chaddr != buf)\n\t\tmemcpy(buf, chaddr, BATADV_DHCP_CHADDR_LEN);\n\n\treturn true;\n}\n\n \nstatic void batadv_dat_put_dhcp(struct batadv_priv *bat_priv, u8 *chaddr,\n\t\t\t\t__be32 yiaddr, u8 *hw_dst, __be32 ip_dst,\n\t\t\t\tunsigned short vid)\n{\n\tstruct sk_buff *skb;\n\n\tskb = batadv_dat_arp_create_reply(bat_priv, yiaddr, ip_dst, chaddr,\n\t\t\t\t\t  hw_dst, vid);\n\tif (!skb)\n\t\treturn;\n\n\tskb_set_network_header(skb, ETH_HLEN);\n\n\tbatadv_dat_entry_add(bat_priv, yiaddr, chaddr, vid);\n\tbatadv_dat_entry_add(bat_priv, ip_dst, hw_dst, vid);\n\n\tbatadv_dat_forward_data(bat_priv, skb, yiaddr, vid,\n\t\t\t\tBATADV_P_DAT_DHT_PUT);\n\tbatadv_dat_forward_data(bat_priv, skb, ip_dst, vid,\n\t\t\t\tBATADV_P_DAT_DHT_PUT);\n\n\tconsume_skb(skb);\n\n\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t   \"Snooped from outgoing DHCPACK (server address): %pI4, %pM (vid: %i)\\n\",\n\t\t   &ip_dst, hw_dst, batadv_print_vid(vid));\n\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t   \"Snooped from outgoing DHCPACK (client address): %pI4, %pM (vid: %i)\\n\",\n\t\t   &yiaddr, chaddr, batadv_print_vid(vid));\n}\n\n \nstatic bool\nbatadv_dat_check_dhcp_ack(struct sk_buff *skb, __be16 proto, __be32 *ip_src,\n\t\t\t  u8 *chaddr, __be32 *yiaddr)\n{\n\tint type;\n\n\ttype = batadv_dat_check_dhcp(skb, proto, ip_src);\n\tif (type != BATADV_BOOTREPLY)\n\t\treturn false;\n\n\ttype = batadv_dat_get_dhcp_message_type(skb);\n\tif (type != BATADV_DHCPACK)\n\t\treturn false;\n\n\tif (!batadv_dat_dhcp_get_yiaddr(skb, yiaddr))\n\t\treturn false;\n\n\tif (!batadv_dat_get_dhcp_chaddr(skb, chaddr))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nvoid batadv_dat_snoop_outgoing_dhcp_ack(struct batadv_priv *bat_priv,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t__be16 proto,\n\t\t\t\t\tunsigned short vid)\n{\n\tu8 chaddr[BATADV_DHCP_CHADDR_LEN];\n\t__be32 ip_src, yiaddr;\n\n\tif (!atomic_read(&bat_priv->distributed_arp_table))\n\t\treturn;\n\n\tif (!batadv_dat_check_dhcp_ack(skb, proto, &ip_src, chaddr, &yiaddr))\n\t\treturn;\n\n\tbatadv_dat_put_dhcp(bat_priv, chaddr, yiaddr, eth_hdr(skb)->h_source,\n\t\t\t    ip_src, vid);\n}\n\n \nvoid batadv_dat_snoop_incoming_dhcp_ack(struct batadv_priv *bat_priv,\n\t\t\t\t\tstruct sk_buff *skb, int hdr_size)\n{\n\tu8 chaddr[BATADV_DHCP_CHADDR_LEN];\n\tstruct ethhdr *ethhdr;\n\t__be32 ip_src, yiaddr;\n\tunsigned short vid;\n\t__be16 proto;\n\tu8 *hw_src;\n\n\tif (!atomic_read(&bat_priv->distributed_arp_table))\n\t\treturn;\n\n\tif (unlikely(!pskb_may_pull(skb, hdr_size + ETH_HLEN)))\n\t\treturn;\n\n\tethhdr = (struct ethhdr *)(skb->data + hdr_size);\n\tskb_set_network_header(skb, hdr_size + ETH_HLEN);\n\tproto = ethhdr->h_proto;\n\n\tif (!batadv_dat_check_dhcp_ack(skb, proto, &ip_src, chaddr, &yiaddr))\n\t\treturn;\n\n\thw_src = ethhdr->h_source;\n\tvid = batadv_dat_get_vid(skb, &hdr_size);\n\n\tbatadv_dat_entry_add(bat_priv, yiaddr, chaddr, vid);\n\tbatadv_dat_entry_add(bat_priv, ip_src, hw_src, vid);\n\n\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t   \"Snooped from incoming DHCPACK (server address): %pI4, %pM (vid: %i)\\n\",\n\t\t   &ip_src, hw_src, batadv_print_vid(vid));\n\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t   \"Snooped from incoming DHCPACK (client address): %pI4, %pM (vid: %i)\\n\",\n\t\t   &yiaddr, chaddr, batadv_print_vid(vid));\n}\n\n \nbool batadv_dat_drop_broadcast_packet(struct batadv_priv *bat_priv,\n\t\t\t\t      struct batadv_forw_packet *forw_packet)\n{\n\tu16 type;\n\t__be32 ip_dst;\n\tstruct batadv_dat_entry *dat_entry = NULL;\n\tbool ret = false;\n\tint hdr_size = sizeof(struct batadv_bcast_packet);\n\tunsigned short vid;\n\n\tif (!atomic_read(&bat_priv->distributed_arp_table))\n\t\tgoto out;\n\n\t \n\tif (batadv_forw_packet_is_rebroadcast(forw_packet))\n\t\tgoto out;\n\n\tvid = batadv_dat_get_vid(forw_packet->skb, &hdr_size);\n\n\ttype = batadv_arp_get_type(bat_priv, forw_packet->skb, hdr_size);\n\tif (type != ARPOP_REQUEST)\n\t\tgoto out;\n\n\tip_dst = batadv_arp_ip_dst(forw_packet->skb, hdr_size);\n\tdat_entry = batadv_dat_entry_hash_find(bat_priv, ip_dst, vid);\n\t \n\tif (!dat_entry) {\n\t\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t\t   \"ARP Request for %pI4: fallback\\n\", &ip_dst);\n\t\tgoto out;\n\t}\n\n\tbatadv_dbg(BATADV_DBG_DAT, bat_priv,\n\t\t   \"ARP Request for %pI4: fallback prevented\\n\", &ip_dst);\n\tret = true;\n\nout:\n\tbatadv_dat_entry_put(dat_entry);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}