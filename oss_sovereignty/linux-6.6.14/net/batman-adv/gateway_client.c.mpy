{
  "module_name": "gateway_client.c",
  "hash_id": "c650bf2db87eb64ab43ccd1d8add5a99e8bcab0ad9ce757943f32aca0f448739",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/gateway_client.c",
  "human_readable_source": "\n \n\n#include \"gateway_client.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/byteorder/generic.h>\n#include <linux/container_of.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/udp.h>\n#include <net/sock.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"hard-interface.h\"\n#include \"log.h\"\n#include \"netlink.h\"\n#include \"originator.h\"\n#include \"routing.h\"\n#include \"soft-interface.h\"\n#include \"translation-table.h\"\n\n \n#define BATADV_DHCP_HTYPE_OFFSET\t1\n#define BATADV_DHCP_HLEN_OFFSET\t\t2\n \n#define BATADV_DHCP_HTYPE_ETHERNET\t0x01\n \n#define BATADV_DHCP_CHADDR_OFFSET\t28\n\n \nvoid batadv_gw_node_release(struct kref *ref)\n{\n\tstruct batadv_gw_node *gw_node;\n\n\tgw_node = container_of(ref, struct batadv_gw_node, refcount);\n\n\tbatadv_orig_node_put(gw_node->orig_node);\n\tkfree_rcu(gw_node, rcu);\n}\n\n \nstruct batadv_gw_node *\nbatadv_gw_get_selected_gw_node(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_gw_node *gw_node;\n\n\trcu_read_lock();\n\tgw_node = rcu_dereference(bat_priv->gw.curr_gw);\n\tif (!gw_node)\n\t\tgoto out;\n\n\tif (!kref_get_unless_zero(&gw_node->refcount))\n\t\tgw_node = NULL;\n\nout:\n\trcu_read_unlock();\n\treturn gw_node;\n}\n\n \nstruct batadv_orig_node *\nbatadv_gw_get_selected_orig(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_gw_node *gw_node;\n\tstruct batadv_orig_node *orig_node = NULL;\n\n\tgw_node = batadv_gw_get_selected_gw_node(bat_priv);\n\tif (!gw_node)\n\t\tgoto out;\n\n\trcu_read_lock();\n\torig_node = gw_node->orig_node;\n\tif (!orig_node)\n\t\tgoto unlock;\n\n\tif (!kref_get_unless_zero(&orig_node->refcount))\n\t\torig_node = NULL;\n\nunlock:\n\trcu_read_unlock();\nout:\n\tbatadv_gw_node_put(gw_node);\n\treturn orig_node;\n}\n\nstatic void batadv_gw_select(struct batadv_priv *bat_priv,\n\t\t\t     struct batadv_gw_node *new_gw_node)\n{\n\tstruct batadv_gw_node *curr_gw_node;\n\n\tspin_lock_bh(&bat_priv->gw.list_lock);\n\n\tif (new_gw_node)\n\t\tkref_get(&new_gw_node->refcount);\n\n\tcurr_gw_node = rcu_replace_pointer(bat_priv->gw.curr_gw, new_gw_node,\n\t\t\t\t\t   true);\n\n\tbatadv_gw_node_put(curr_gw_node);\n\n\tspin_unlock_bh(&bat_priv->gw.list_lock);\n}\n\n \nvoid batadv_gw_reselect(struct batadv_priv *bat_priv)\n{\n\tatomic_set(&bat_priv->gw.reselect, 1);\n}\n\n \nvoid batadv_gw_check_client_stop(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_gw_node *curr_gw;\n\n\tif (atomic_read(&bat_priv->gw.mode) != BATADV_GW_MODE_CLIENT)\n\t\treturn;\n\n\tcurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\n\tif (!curr_gw)\n\t\treturn;\n\n\t \n\tbatadv_gw_select(bat_priv, NULL);\n\n\t \n\tbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_DEL, NULL);\n\n\tbatadv_gw_node_put(curr_gw);\n}\n\n \nvoid batadv_gw_election(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_gw_node *curr_gw = NULL;\n\tstruct batadv_gw_node *next_gw = NULL;\n\tstruct batadv_neigh_node *router = NULL;\n\tstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\n\tchar gw_addr[18] = { '\\0' };\n\n\tif (atomic_read(&bat_priv->gw.mode) != BATADV_GW_MODE_CLIENT)\n\t\tgoto out;\n\n\tif (!bat_priv->algo_ops->gw.get_best_gw_node)\n\t\tgoto out;\n\n\tcurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\n\n\tif (!batadv_atomic_dec_not_zero(&bat_priv->gw.reselect) && curr_gw)\n\t\tgoto out;\n\n\t \n\tnext_gw = bat_priv->algo_ops->gw.get_best_gw_node(bat_priv);\n\n\tif (curr_gw == next_gw)\n\t\tgoto out;\n\n\tif (next_gw) {\n\t\tsprintf(gw_addr, \"%pM\", next_gw->orig_node->orig);\n\n\t\trouter = batadv_orig_router_get(next_gw->orig_node,\n\t\t\t\t\t\tBATADV_IF_DEFAULT);\n\t\tif (!router) {\n\t\t\tbatadv_gw_reselect(bat_priv);\n\t\t\tgoto out;\n\t\t}\n\n\t\trouter_ifinfo = batadv_neigh_ifinfo_get(router,\n\t\t\t\t\t\t\tBATADV_IF_DEFAULT);\n\t\tif (!router_ifinfo) {\n\t\t\tbatadv_gw_reselect(bat_priv);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (curr_gw && !next_gw) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Removing selected gateway - no gateway in range\\n\");\n\t\tbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_DEL,\n\t\t\t\t    NULL);\n\t} else if (!curr_gw && next_gw) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Adding route to gateway %pM (bandwidth: %u.%u/%u.%u MBit, tq: %i)\\n\",\n\t\t\t   next_gw->orig_node->orig,\n\t\t\t   next_gw->bandwidth_down / 10,\n\t\t\t   next_gw->bandwidth_down % 10,\n\t\t\t   next_gw->bandwidth_up / 10,\n\t\t\t   next_gw->bandwidth_up % 10,\n\t\t\t   router_ifinfo->bat_iv.tq_avg);\n\t\tbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_ADD,\n\t\t\t\t    gw_addr);\n\t} else {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Changing route to gateway %pM (bandwidth: %u.%u/%u.%u MBit, tq: %i)\\n\",\n\t\t\t   next_gw->orig_node->orig,\n\t\t\t   next_gw->bandwidth_down / 10,\n\t\t\t   next_gw->bandwidth_down % 10,\n\t\t\t   next_gw->bandwidth_up / 10,\n\t\t\t   next_gw->bandwidth_up % 10,\n\t\t\t   router_ifinfo->bat_iv.tq_avg);\n\t\tbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_CHANGE,\n\t\t\t\t    gw_addr);\n\t}\n\n\tbatadv_gw_select(bat_priv, next_gw);\n\nout:\n\tbatadv_gw_node_put(curr_gw);\n\tbatadv_gw_node_put(next_gw);\n\tbatadv_neigh_node_put(router);\n\tbatadv_neigh_ifinfo_put(router_ifinfo);\n}\n\n \nvoid batadv_gw_check_election(struct batadv_priv *bat_priv,\n\t\t\t      struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_orig_node *curr_gw_orig;\n\n\t \n\tif (!bat_priv->algo_ops->gw.is_eligible)\n\t\treturn;\n\n\tcurr_gw_orig = batadv_gw_get_selected_orig(bat_priv);\n\tif (!curr_gw_orig)\n\t\tgoto reselect;\n\n\t \n\tif (curr_gw_orig == orig_node)\n\t\tgoto out;\n\n\tif (!bat_priv->algo_ops->gw.is_eligible(bat_priv, curr_gw_orig,\n\t\t\t\t\t\torig_node))\n\t\tgoto out;\n\nreselect:\n\tbatadv_gw_reselect(bat_priv);\nout:\n\tbatadv_orig_node_put(curr_gw_orig);\n}\n\n \nstatic void batadv_gw_node_add(struct batadv_priv *bat_priv,\n\t\t\t       struct batadv_orig_node *orig_node,\n\t\t\t       struct batadv_tvlv_gateway_data *gateway)\n{\n\tstruct batadv_gw_node *gw_node;\n\n\tlockdep_assert_held(&bat_priv->gw.list_lock);\n\n\tif (gateway->bandwidth_down == 0)\n\t\treturn;\n\n\tgw_node = kzalloc(sizeof(*gw_node), GFP_ATOMIC);\n\tif (!gw_node)\n\t\treturn;\n\n\tkref_init(&gw_node->refcount);\n\tINIT_HLIST_NODE(&gw_node->list);\n\tkref_get(&orig_node->refcount);\n\tgw_node->orig_node = orig_node;\n\tgw_node->bandwidth_down = ntohl(gateway->bandwidth_down);\n\tgw_node->bandwidth_up = ntohl(gateway->bandwidth_up);\n\n\tkref_get(&gw_node->refcount);\n\thlist_add_head_rcu(&gw_node->list, &bat_priv->gw.gateway_list);\n\tbat_priv->gw.generation++;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Found new gateway %pM -> gw bandwidth: %u.%u/%u.%u MBit\\n\",\n\t\t   orig_node->orig,\n\t\t   ntohl(gateway->bandwidth_down) / 10,\n\t\t   ntohl(gateway->bandwidth_down) % 10,\n\t\t   ntohl(gateway->bandwidth_up) / 10,\n\t\t   ntohl(gateway->bandwidth_up) % 10);\n\n\t \n\tbatadv_gw_node_put(gw_node);\n}\n\n \nstruct batadv_gw_node *batadv_gw_node_get(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_gw_node *gw_node_tmp, *gw_node = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(gw_node_tmp, &bat_priv->gw.gateway_list,\n\t\t\t\t list) {\n\t\tif (gw_node_tmp->orig_node != orig_node)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&gw_node_tmp->refcount))\n\t\t\tcontinue;\n\n\t\tgw_node = gw_node_tmp;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn gw_node;\n}\n\n \nvoid batadv_gw_node_update(struct batadv_priv *bat_priv,\n\t\t\t   struct batadv_orig_node *orig_node,\n\t\t\t   struct batadv_tvlv_gateway_data *gateway)\n{\n\tstruct batadv_gw_node *gw_node, *curr_gw = NULL;\n\n\tspin_lock_bh(&bat_priv->gw.list_lock);\n\tgw_node = batadv_gw_node_get(bat_priv, orig_node);\n\tif (!gw_node) {\n\t\tbatadv_gw_node_add(bat_priv, orig_node, gateway);\n\t\tspin_unlock_bh(&bat_priv->gw.list_lock);\n\t\tgoto out;\n\t}\n\tspin_unlock_bh(&bat_priv->gw.list_lock);\n\n\tif (gw_node->bandwidth_down == ntohl(gateway->bandwidth_down) &&\n\t    gw_node->bandwidth_up == ntohl(gateway->bandwidth_up))\n\t\tgoto out;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Gateway bandwidth of originator %pM changed from %u.%u/%u.%u MBit to %u.%u/%u.%u MBit\\n\",\n\t\t   orig_node->orig,\n\t\t   gw_node->bandwidth_down / 10,\n\t\t   gw_node->bandwidth_down % 10,\n\t\t   gw_node->bandwidth_up / 10,\n\t\t   gw_node->bandwidth_up % 10,\n\t\t   ntohl(gateway->bandwidth_down) / 10,\n\t\t   ntohl(gateway->bandwidth_down) % 10,\n\t\t   ntohl(gateway->bandwidth_up) / 10,\n\t\t   ntohl(gateway->bandwidth_up) % 10);\n\n\tgw_node->bandwidth_down = ntohl(gateway->bandwidth_down);\n\tgw_node->bandwidth_up = ntohl(gateway->bandwidth_up);\n\n\tif (ntohl(gateway->bandwidth_down) == 0) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Gateway %pM removed from gateway list\\n\",\n\t\t\t   orig_node->orig);\n\n\t\t \n\t\tspin_lock_bh(&bat_priv->gw.list_lock);\n\t\tif (!hlist_unhashed(&gw_node->list)) {\n\t\t\thlist_del_init_rcu(&gw_node->list);\n\t\t\tbatadv_gw_node_put(gw_node);\n\t\t\tbat_priv->gw.generation++;\n\t\t}\n\t\tspin_unlock_bh(&bat_priv->gw.list_lock);\n\n\t\tcurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\n\t\tif (gw_node == curr_gw)\n\t\t\tbatadv_gw_reselect(bat_priv);\n\n\t\tbatadv_gw_node_put(curr_gw);\n\t}\n\nout:\n\tbatadv_gw_node_put(gw_node);\n}\n\n \nvoid batadv_gw_node_delete(struct batadv_priv *bat_priv,\n\t\t\t   struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_tvlv_gateway_data gateway;\n\n\tgateway.bandwidth_down = 0;\n\tgateway.bandwidth_up = 0;\n\n\tbatadv_gw_node_update(bat_priv, orig_node, &gateway);\n}\n\n \nvoid batadv_gw_node_free(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_gw_node *gw_node;\n\tstruct hlist_node *node_tmp;\n\n\tspin_lock_bh(&bat_priv->gw.list_lock);\n\thlist_for_each_entry_safe(gw_node, node_tmp,\n\t\t\t\t  &bat_priv->gw.gateway_list, list) {\n\t\thlist_del_init_rcu(&gw_node->list);\n\t\tbatadv_gw_node_put(gw_node);\n\t\tbat_priv->gw.generation++;\n\t}\n\tspin_unlock_bh(&bat_priv->gw.list_lock);\n}\n\n \nint batadv_gw_dump(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct net_device *soft_iface;\n\tstruct batadv_priv *bat_priv;\n\tint ifindex;\n\tint ret;\n\n\tifindex = batadv_netlink_get_ifindex(cb->nlh,\n\t\t\t\t\t     BATADV_ATTR_MESH_IFINDEX);\n\tif (!ifindex)\n\t\treturn -EINVAL;\n\n\tsoft_iface = dev_get_by_index(net, ifindex);\n\tif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tbat_priv = netdev_priv(soft_iface);\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!bat_priv->algo_ops->gw.dump) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tbat_priv->algo_ops->gw.dump(msg, cb, bat_priv);\n\n\tret = msg->len;\n\nout:\n\tbatadv_hardif_put(primary_if);\n\tdev_put(soft_iface);\n\n\treturn ret;\n}\n\n \nenum batadv_dhcp_recipient\nbatadv_gw_dhcp_recipient_get(struct sk_buff *skb, unsigned int *header_len,\n\t\t\t     u8 *chaddr)\n{\n\tenum batadv_dhcp_recipient ret = BATADV_DHCP_NO;\n\tstruct ethhdr *ethhdr;\n\tstruct iphdr *iphdr;\n\tstruct ipv6hdr *ipv6hdr;\n\tstruct udphdr *udphdr;\n\tstruct vlan_ethhdr *vhdr;\n\tint chaddr_offset;\n\t__be16 proto;\n\tu8 *p;\n\n\t \n\tif (!pskb_may_pull(skb, *header_len + ETH_HLEN))\n\t\treturn BATADV_DHCP_NO;\n\n\tethhdr = eth_hdr(skb);\n\tproto = ethhdr->h_proto;\n\t*header_len += ETH_HLEN;\n\n\t \n\tif (proto == htons(ETH_P_8021Q)) {\n\t\tif (!pskb_may_pull(skb, *header_len + VLAN_HLEN))\n\t\t\treturn BATADV_DHCP_NO;\n\n\t\tvhdr = vlan_eth_hdr(skb);\n\t\tproto = vhdr->h_vlan_encapsulated_proto;\n\t\t*header_len += VLAN_HLEN;\n\t}\n\n\t \n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\tif (!pskb_may_pull(skb, *header_len + sizeof(*iphdr)))\n\t\t\treturn BATADV_DHCP_NO;\n\n\t\tiphdr = (struct iphdr *)(skb->data + *header_len);\n\t\t*header_len += iphdr->ihl * 4;\n\n\t\t \n\t\tif (iphdr->protocol != IPPROTO_UDP)\n\t\t\treturn BATADV_DHCP_NO;\n\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tif (!pskb_may_pull(skb, *header_len + sizeof(*ipv6hdr)))\n\t\t\treturn BATADV_DHCP_NO;\n\n\t\tipv6hdr = (struct ipv6hdr *)(skb->data + *header_len);\n\t\t*header_len += sizeof(*ipv6hdr);\n\n\t\t \n\t\tif (ipv6hdr->nexthdr != IPPROTO_UDP)\n\t\t\treturn BATADV_DHCP_NO;\n\n\t\tbreak;\n\tdefault:\n\t\treturn BATADV_DHCP_NO;\n\t}\n\n\tif (!pskb_may_pull(skb, *header_len + sizeof(*udphdr)))\n\t\treturn BATADV_DHCP_NO;\n\n\tudphdr = (struct udphdr *)(skb->data + *header_len);\n\t*header_len += sizeof(*udphdr);\n\n\t \n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\tif (udphdr->dest == htons(67))\n\t\t\tret = BATADV_DHCP_TO_SERVER;\n\t\telse if (udphdr->source == htons(67))\n\t\t\tret = BATADV_DHCP_TO_CLIENT;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tif (udphdr->dest == htons(547))\n\t\t\tret = BATADV_DHCP_TO_SERVER;\n\t\telse if (udphdr->source == htons(547))\n\t\t\tret = BATADV_DHCP_TO_CLIENT;\n\t\tbreak;\n\t}\n\n\tchaddr_offset = *header_len + BATADV_DHCP_CHADDR_OFFSET;\n\t \n\tif (ret == BATADV_DHCP_TO_CLIENT) {\n\t\tif (!pskb_may_pull(skb, chaddr_offset + ETH_ALEN))\n\t\t\treturn BATADV_DHCP_NO;\n\n\t\t \n\t\tp = skb->data + *header_len + BATADV_DHCP_HTYPE_OFFSET;\n\t\tif (*p != BATADV_DHCP_HTYPE_ETHERNET)\n\t\t\treturn BATADV_DHCP_NO;\n\n\t\t \n\t\tp = skb->data + *header_len + BATADV_DHCP_HLEN_OFFSET;\n\t\tif (*p != ETH_ALEN)\n\t\t\treturn BATADV_DHCP_NO;\n\n\t\tether_addr_copy(chaddr, skb->data + chaddr_offset);\n\t}\n\n\treturn ret;\n}\n\n \nbool batadv_gw_out_of_range(struct batadv_priv *bat_priv,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct batadv_neigh_node *neigh_curr = NULL;\n\tstruct batadv_neigh_node *neigh_old = NULL;\n\tstruct batadv_orig_node *orig_dst_node = NULL;\n\tstruct batadv_gw_node *gw_node = NULL;\n\tstruct batadv_gw_node *curr_gw = NULL;\n\tstruct batadv_neigh_ifinfo *curr_ifinfo, *old_ifinfo;\n\tstruct ethhdr *ethhdr = (struct ethhdr *)skb->data;\n\tbool out_of_range = false;\n\tu8 curr_tq_avg;\n\tunsigned short vid;\n\n\tvid = batadv_get_vid(skb, 0);\n\n\tif (is_multicast_ether_addr(ethhdr->h_dest))\n\t\tgoto out;\n\n\torig_dst_node = batadv_transtable_search(bat_priv, ethhdr->h_source,\n\t\t\t\t\t\t ethhdr->h_dest, vid);\n\tif (!orig_dst_node)\n\t\tgoto out;\n\n\tgw_node = batadv_gw_node_get(bat_priv, orig_dst_node);\n\tif (!gw_node)\n\t\tgoto out;\n\n\tswitch (atomic_read(&bat_priv->gw.mode)) {\n\tcase BATADV_GW_MODE_SERVER:\n\t\t \n\t\tcurr_tq_avg = BATADV_TQ_MAX_VALUE;\n\t\tbreak;\n\tcase BATADV_GW_MODE_CLIENT:\n\t\tcurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\n\t\tif (!curr_gw)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (curr_gw->orig_node == orig_dst_node)\n\t\t\tgoto out;\n\n\t\t \n\t\tneigh_curr = batadv_find_router(bat_priv, curr_gw->orig_node,\n\t\t\t\t\t\tNULL);\n\t\tif (!neigh_curr)\n\t\t\tgoto out;\n\n\t\tcurr_ifinfo = batadv_neigh_ifinfo_get(neigh_curr,\n\t\t\t\t\t\t      BATADV_IF_DEFAULT);\n\t\tif (!curr_ifinfo)\n\t\t\tgoto out;\n\n\t\tcurr_tq_avg = curr_ifinfo->bat_iv.tq_avg;\n\t\tbatadv_neigh_ifinfo_put(curr_ifinfo);\n\n\t\tbreak;\n\tcase BATADV_GW_MODE_OFF:\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tneigh_old = batadv_find_router(bat_priv, orig_dst_node, NULL);\n\tif (!neigh_old)\n\t\tgoto out;\n\n\told_ifinfo = batadv_neigh_ifinfo_get(neigh_old, BATADV_IF_DEFAULT);\n\tif (!old_ifinfo)\n\t\tgoto out;\n\n\tif ((curr_tq_avg - old_ifinfo->bat_iv.tq_avg) > BATADV_GW_THRESHOLD)\n\t\tout_of_range = true;\n\tbatadv_neigh_ifinfo_put(old_ifinfo);\n\nout:\n\tbatadv_orig_node_put(orig_dst_node);\n\tbatadv_gw_node_put(curr_gw);\n\tbatadv_gw_node_put(gw_node);\n\tbatadv_neigh_node_put(neigh_old);\n\tbatadv_neigh_node_put(neigh_curr);\n\treturn out_of_range;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}