{
  "module_name": "netlink.c",
  "hash_id": "b216324fa29ccb3364fdac5c83aa1f2ea3a6f0ec6a1df013f5c64648458d03b0",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/netlink.c",
  "human_readable_source": "\n \n\n#include \"netlink.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/bug.h>\n#include <linux/byteorder/generic.h>\n#include <linux/cache.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/genetlink.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/minmax.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/printk.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <net/genetlink.h>\n#include <net/net_namespace.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"bat_algo.h\"\n#include \"bridge_loop_avoidance.h\"\n#include \"distributed-arp-table.h\"\n#include \"gateway_client.h\"\n#include \"gateway_common.h\"\n#include \"hard-interface.h\"\n#include \"log.h\"\n#include \"multicast.h\"\n#include \"network-coding.h\"\n#include \"originator.h\"\n#include \"soft-interface.h\"\n#include \"tp_meter.h\"\n#include \"translation-table.h\"\n\nstruct genl_family batadv_netlink_family;\n\n \nenum batadv_netlink_multicast_groups {\n\tBATADV_NL_MCGRP_CONFIG,\n\tBATADV_NL_MCGRP_TPMETER,\n};\n\n \nenum batadv_genl_ops_flags {\n\t \n\tBATADV_FLAG_NEED_MESH = BIT(0),\n\n\t \n\tBATADV_FLAG_NEED_HARDIF = BIT(1),\n\n\t \n\tBATADV_FLAG_NEED_VLAN = BIT(2),\n};\n\nstatic const struct genl_multicast_group batadv_netlink_mcgrps[] = {\n\t[BATADV_NL_MCGRP_CONFIG] = { .name = BATADV_NL_MCAST_GROUP_CONFIG },\n\t[BATADV_NL_MCGRP_TPMETER] = { .name = BATADV_NL_MCAST_GROUP_TPMETER },\n};\n\nstatic const struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {\n\t[BATADV_ATTR_VERSION]\t\t\t= { .type = NLA_STRING },\n\t[BATADV_ATTR_ALGO_NAME]\t\t\t= { .type = NLA_STRING },\n\t[BATADV_ATTR_MESH_IFINDEX]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_MESH_IFNAME]\t\t= { .type = NLA_STRING },\n\t[BATADV_ATTR_MESH_ADDRESS]\t\t= { .len = ETH_ALEN },\n\t[BATADV_ATTR_HARD_IFINDEX]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_HARD_IFNAME]\t\t= { .type = NLA_STRING },\n\t[BATADV_ATTR_HARD_ADDRESS]\t\t= { .len = ETH_ALEN },\n\t[BATADV_ATTR_ORIG_ADDRESS]\t\t= { .len = ETH_ALEN },\n\t[BATADV_ATTR_TPMETER_RESULT]\t\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_TPMETER_TEST_TIME]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_TPMETER_BYTES]\t\t= { .type = NLA_U64 },\n\t[BATADV_ATTR_TPMETER_COOKIE]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_ACTIVE]\t\t\t= { .type = NLA_FLAG },\n\t[BATADV_ATTR_TT_ADDRESS]\t\t= { .len = ETH_ALEN },\n\t[BATADV_ATTR_TT_TTVN]\t\t\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_TT_LAST_TTVN]\t\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_TT_CRC32]\t\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_TT_VID]\t\t\t= { .type = NLA_U16 },\n\t[BATADV_ATTR_TT_FLAGS]\t\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_FLAG_BEST]\t\t\t= { .type = NLA_FLAG },\n\t[BATADV_ATTR_LAST_SEEN_MSECS]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_NEIGH_ADDRESS]\t\t= { .len = ETH_ALEN },\n\t[BATADV_ATTR_TQ]\t\t\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_THROUGHPUT]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_BANDWIDTH_UP]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_BANDWIDTH_DOWN]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_ROUTER]\t\t\t= { .len = ETH_ALEN },\n\t[BATADV_ATTR_BLA_OWN]\t\t\t= { .type = NLA_FLAG },\n\t[BATADV_ATTR_BLA_ADDRESS]\t\t= { .len = ETH_ALEN },\n\t[BATADV_ATTR_BLA_VID]\t\t\t= { .type = NLA_U16 },\n\t[BATADV_ATTR_BLA_BACKBONE]\t\t= { .len = ETH_ALEN },\n\t[BATADV_ATTR_BLA_CRC]\t\t\t= { .type = NLA_U16 },\n\t[BATADV_ATTR_DAT_CACHE_IP4ADDRESS]\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_DAT_CACHE_HWADDRESS]\t= { .len = ETH_ALEN },\n\t[BATADV_ATTR_DAT_CACHE_VID]\t\t= { .type = NLA_U16 },\n\t[BATADV_ATTR_MCAST_FLAGS]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_MCAST_FLAGS_PRIV]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_VLANID]\t\t\t= { .type = NLA_U16 },\n\t[BATADV_ATTR_AGGREGATED_OGMS_ENABLED]\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_AP_ISOLATION_ENABLED]\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_ISOLATION_MARK]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_ISOLATION_MASK]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_BONDING_ENABLED]\t\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_BRIDGE_LOOP_AVOIDANCE_ENABLED]\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_DISTRIBUTED_ARP_TABLE_ENABLED]\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_FRAGMENTATION_ENABLED]\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_GW_BANDWIDTH_DOWN]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_GW_BANDWIDTH_UP]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_GW_MODE]\t\t\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_GW_SEL_CLASS]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_HOP_PENALTY]\t\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_LOG_LEVEL]\t\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_MULTICAST_FORCEFLOOD_ENABLED]\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_MULTICAST_FANOUT]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_NETWORK_CODING_ENABLED]\t= { .type = NLA_U8 },\n\t[BATADV_ATTR_ORIG_INTERVAL]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_ELP_INTERVAL]\t\t= { .type = NLA_U32 },\n\t[BATADV_ATTR_THROUGHPUT_OVERRIDE]\t= { .type = NLA_U32 },\n};\n\n \nint\nbatadv_netlink_get_ifindex(const struct nlmsghdr *nlh, int attrtype)\n{\n\tstruct nlattr *attr = nlmsg_find_attr(nlh, GENL_HDRLEN, attrtype);\n\n\treturn (attr && nla_len(attr) == sizeof(u32)) ? nla_get_u32(attr) : 0;\n}\n\n \nstatic int batadv_netlink_mesh_fill_ap_isolation(struct sk_buff *msg,\n\t\t\t\t\t\t struct batadv_priv *bat_priv)\n{\n\tstruct batadv_softif_vlan *vlan;\n\tu8 ap_isolation;\n\n\tvlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);\n\tif (!vlan)\n\t\treturn 0;\n\n\tap_isolation = atomic_read(&vlan->ap_isolation);\n\tbatadv_softif_vlan_put(vlan);\n\n\treturn nla_put_u8(msg, BATADV_ATTR_AP_ISOLATION_ENABLED,\n\t\t\t  !!ap_isolation);\n}\n\n \nstatic int batadv_netlink_set_mesh_ap_isolation(struct nlattr *attr,\n\t\t\t\t\t\tstruct batadv_priv *bat_priv)\n{\n\tstruct batadv_softif_vlan *vlan;\n\n\tvlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);\n\tif (!vlan)\n\t\treturn -ENOENT;\n\n\tatomic_set(&vlan->ap_isolation, !!nla_get_u8(attr));\n\tbatadv_softif_vlan_put(vlan);\n\n\treturn 0;\n}\n\n \nstatic int batadv_netlink_mesh_fill(struct sk_buff *msg,\n\t\t\t\t    struct batadv_priv *bat_priv,\n\t\t\t\t    enum batadv_nl_commands cmd,\n\t\t\t\t    u32 portid, u32 seq, int flags)\n{\n\tstruct net_device *soft_iface = bat_priv->soft_iface;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct net_device *hard_iface;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_string(msg, BATADV_ATTR_VERSION, BATADV_SOURCE_VERSION) ||\n\t    nla_put_string(msg, BATADV_ATTR_ALGO_NAME,\n\t\t\t   bat_priv->algo_ops->name) ||\n\t    nla_put_u32(msg, BATADV_ATTR_MESH_IFINDEX, soft_iface->ifindex) ||\n\t    nla_put_string(msg, BATADV_ATTR_MESH_IFNAME, soft_iface->name) ||\n\t    nla_put(msg, BATADV_ATTR_MESH_ADDRESS, ETH_ALEN,\n\t\t    soft_iface->dev_addr) ||\n\t    nla_put_u8(msg, BATADV_ATTR_TT_TTVN,\n\t\t       (u8)atomic_read(&bat_priv->tt.vn)))\n\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_BATMAN_ADV_BLA\n\tif (nla_put_u16(msg, BATADV_ATTR_BLA_CRC,\n\t\t\tntohs(bat_priv->bla.claim_dest.group)))\n\t\tgoto nla_put_failure;\n#endif\n\n\tif (batadv_mcast_mesh_info_put(msg, bat_priv))\n\t\tgoto nla_put_failure;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (primary_if && primary_if->if_status == BATADV_IF_ACTIVE) {\n\t\thard_iface = primary_if->net_dev;\n\n\t\tif (nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\n\t\t\t\thard_iface->ifindex) ||\n\t\t    nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\n\t\t\t\t   hard_iface->name) ||\n\t\t    nla_put(msg, BATADV_ATTR_HARD_ADDRESS, ETH_ALEN,\n\t\t\t    hard_iface->dev_addr))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u8(msg, BATADV_ATTR_AGGREGATED_OGMS_ENABLED,\n\t\t       !!atomic_read(&bat_priv->aggregated_ogms)))\n\t\tgoto nla_put_failure;\n\n\tif (batadv_netlink_mesh_fill_ap_isolation(msg, bat_priv))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, BATADV_ATTR_ISOLATION_MARK,\n\t\t\tbat_priv->isolation_mark))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, BATADV_ATTR_ISOLATION_MASK,\n\t\t\tbat_priv->isolation_mark_mask))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, BATADV_ATTR_BONDING_ENABLED,\n\t\t       !!atomic_read(&bat_priv->bonding)))\n\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_BATMAN_ADV_BLA\n\tif (nla_put_u8(msg, BATADV_ATTR_BRIDGE_LOOP_AVOIDANCE_ENABLED,\n\t\t       !!atomic_read(&bat_priv->bridge_loop_avoidance)))\n\t\tgoto nla_put_failure;\n#endif  \n\n#ifdef CONFIG_BATMAN_ADV_DAT\n\tif (nla_put_u8(msg, BATADV_ATTR_DISTRIBUTED_ARP_TABLE_ENABLED,\n\t\t       !!atomic_read(&bat_priv->distributed_arp_table)))\n\t\tgoto nla_put_failure;\n#endif  \n\n\tif (nla_put_u8(msg, BATADV_ATTR_FRAGMENTATION_ENABLED,\n\t\t       !!atomic_read(&bat_priv->fragmentation)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, BATADV_ATTR_GW_BANDWIDTH_DOWN,\n\t\t\tatomic_read(&bat_priv->gw.bandwidth_down)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, BATADV_ATTR_GW_BANDWIDTH_UP,\n\t\t\tatomic_read(&bat_priv->gw.bandwidth_up)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, BATADV_ATTR_GW_MODE,\n\t\t       atomic_read(&bat_priv->gw.mode)))\n\t\tgoto nla_put_failure;\n\n\tif (bat_priv->algo_ops->gw.get_best_gw_node &&\n\t    bat_priv->algo_ops->gw.is_eligible) {\n\t\t \n\t\tif (nla_put_u32(msg, BATADV_ATTR_GW_SEL_CLASS,\n\t\t\t\tatomic_read(&bat_priv->gw.sel_class)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u8(msg, BATADV_ATTR_HOP_PENALTY,\n\t\t       atomic_read(&bat_priv->hop_penalty)))\n\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_BATMAN_ADV_DEBUG\n\tif (nla_put_u32(msg, BATADV_ATTR_LOG_LEVEL,\n\t\t\tatomic_read(&bat_priv->log_level)))\n\t\tgoto nla_put_failure;\n#endif  \n\n#ifdef CONFIG_BATMAN_ADV_MCAST\n\tif (nla_put_u8(msg, BATADV_ATTR_MULTICAST_FORCEFLOOD_ENABLED,\n\t\t       !atomic_read(&bat_priv->multicast_mode)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, BATADV_ATTR_MULTICAST_FANOUT,\n\t\t\tatomic_read(&bat_priv->multicast_fanout)))\n\t\tgoto nla_put_failure;\n#endif  \n\n#ifdef CONFIG_BATMAN_ADV_NC\n\tif (nla_put_u8(msg, BATADV_ATTR_NETWORK_CODING_ENABLED,\n\t\t       !!atomic_read(&bat_priv->network_coding)))\n\t\tgoto nla_put_failure;\n#endif  \n\n\tif (nla_put_u32(msg, BATADV_ATTR_ORIG_INTERVAL,\n\t\t\tatomic_read(&bat_priv->orig_interval)))\n\t\tgoto nla_put_failure;\n\n\tbatadv_hardif_put(primary_if);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tbatadv_hardif_put(primary_if);\n\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int batadv_netlink_notify_mesh(struct batadv_priv *bat_priv)\n{\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = batadv_netlink_mesh_fill(msg, bat_priv, BATADV_CMD_SET_MESH,\n\t\t\t\t       0, 0, 0);\n\tif (ret < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn ret;\n\t}\n\n\tgenlmsg_multicast_netns(&batadv_netlink_family,\n\t\t\t\tdev_net(bat_priv->soft_iface), msg, 0,\n\t\t\t\tBATADV_NL_MCGRP_CONFIG, GFP_KERNEL);\n\n\treturn 0;\n}\n\n \nstatic int batadv_netlink_get_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct batadv_priv *bat_priv = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = batadv_netlink_mesh_fill(msg, bat_priv, BATADV_CMD_GET_MESH,\n\t\t\t\t       info->snd_portid, info->snd_seq, 0);\n\tif (ret < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn ret;\n\t}\n\n\tret = genlmsg_reply(msg, info);\n\n\treturn ret;\n}\n\n \nstatic int batadv_netlink_set_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct batadv_priv *bat_priv = info->user_ptr[0];\n\tstruct nlattr *attr;\n\n\tif (info->attrs[BATADV_ATTR_AGGREGATED_OGMS_ENABLED]) {\n\t\tattr = info->attrs[BATADV_ATTR_AGGREGATED_OGMS_ENABLED];\n\n\t\tatomic_set(&bat_priv->aggregated_ogms, !!nla_get_u8(attr));\n\t}\n\n\tif (info->attrs[BATADV_ATTR_AP_ISOLATION_ENABLED]) {\n\t\tattr = info->attrs[BATADV_ATTR_AP_ISOLATION_ENABLED];\n\n\t\tbatadv_netlink_set_mesh_ap_isolation(attr, bat_priv);\n\t}\n\n\tif (info->attrs[BATADV_ATTR_ISOLATION_MARK]) {\n\t\tattr = info->attrs[BATADV_ATTR_ISOLATION_MARK];\n\n\t\tbat_priv->isolation_mark = nla_get_u32(attr);\n\t}\n\n\tif (info->attrs[BATADV_ATTR_ISOLATION_MASK]) {\n\t\tattr = info->attrs[BATADV_ATTR_ISOLATION_MASK];\n\n\t\tbat_priv->isolation_mark_mask = nla_get_u32(attr);\n\t}\n\n\tif (info->attrs[BATADV_ATTR_BONDING_ENABLED]) {\n\t\tattr = info->attrs[BATADV_ATTR_BONDING_ENABLED];\n\n\t\tatomic_set(&bat_priv->bonding, !!nla_get_u8(attr));\n\t}\n\n#ifdef CONFIG_BATMAN_ADV_BLA\n\tif (info->attrs[BATADV_ATTR_BRIDGE_LOOP_AVOIDANCE_ENABLED]) {\n\t\tattr = info->attrs[BATADV_ATTR_BRIDGE_LOOP_AVOIDANCE_ENABLED];\n\n\t\tatomic_set(&bat_priv->bridge_loop_avoidance,\n\t\t\t   !!nla_get_u8(attr));\n\t\tbatadv_bla_status_update(bat_priv->soft_iface);\n\t}\n#endif  \n\n#ifdef CONFIG_BATMAN_ADV_DAT\n\tif (info->attrs[BATADV_ATTR_DISTRIBUTED_ARP_TABLE_ENABLED]) {\n\t\tattr = info->attrs[BATADV_ATTR_DISTRIBUTED_ARP_TABLE_ENABLED];\n\n\t\tatomic_set(&bat_priv->distributed_arp_table,\n\t\t\t   !!nla_get_u8(attr));\n\t\tbatadv_dat_status_update(bat_priv->soft_iface);\n\t}\n#endif  \n\n\tif (info->attrs[BATADV_ATTR_FRAGMENTATION_ENABLED]) {\n\t\tattr = info->attrs[BATADV_ATTR_FRAGMENTATION_ENABLED];\n\n\t\tatomic_set(&bat_priv->fragmentation, !!nla_get_u8(attr));\n\n\t\trtnl_lock();\n\t\tbatadv_update_min_mtu(bat_priv->soft_iface);\n\t\trtnl_unlock();\n\t}\n\n\tif (info->attrs[BATADV_ATTR_GW_BANDWIDTH_DOWN]) {\n\t\tattr = info->attrs[BATADV_ATTR_GW_BANDWIDTH_DOWN];\n\n\t\tatomic_set(&bat_priv->gw.bandwidth_down, nla_get_u32(attr));\n\t\tbatadv_gw_tvlv_container_update(bat_priv);\n\t}\n\n\tif (info->attrs[BATADV_ATTR_GW_BANDWIDTH_UP]) {\n\t\tattr = info->attrs[BATADV_ATTR_GW_BANDWIDTH_UP];\n\n\t\tatomic_set(&bat_priv->gw.bandwidth_up, nla_get_u32(attr));\n\t\tbatadv_gw_tvlv_container_update(bat_priv);\n\t}\n\n\tif (info->attrs[BATADV_ATTR_GW_MODE]) {\n\t\tu8 gw_mode;\n\n\t\tattr = info->attrs[BATADV_ATTR_GW_MODE];\n\t\tgw_mode = nla_get_u8(attr);\n\n\t\tif (gw_mode <= BATADV_GW_MODE_SERVER) {\n\t\t\t \n\t\t\tbatadv_gw_reselect(bat_priv);\n\n\t\t\t \n\t\t\tbatadv_gw_check_client_stop(bat_priv);\n\t\t\tatomic_set(&bat_priv->gw.mode, gw_mode);\n\t\t\tbatadv_gw_tvlv_container_update(bat_priv);\n\t\t}\n\t}\n\n\tif (info->attrs[BATADV_ATTR_GW_SEL_CLASS] &&\n\t    bat_priv->algo_ops->gw.get_best_gw_node &&\n\t    bat_priv->algo_ops->gw.is_eligible) {\n\t\t \n\n\t\tu32 sel_class_max = bat_priv->algo_ops->gw.sel_class_max;\n\t\tu32 sel_class;\n\n\t\tattr = info->attrs[BATADV_ATTR_GW_SEL_CLASS];\n\t\tsel_class = nla_get_u32(attr);\n\n\t\tif (sel_class >= 1 && sel_class <= sel_class_max) {\n\t\t\tatomic_set(&bat_priv->gw.sel_class, sel_class);\n\t\t\tbatadv_gw_reselect(bat_priv);\n\t\t}\n\t}\n\n\tif (info->attrs[BATADV_ATTR_HOP_PENALTY]) {\n\t\tattr = info->attrs[BATADV_ATTR_HOP_PENALTY];\n\n\t\tatomic_set(&bat_priv->hop_penalty, nla_get_u8(attr));\n\t}\n\n#ifdef CONFIG_BATMAN_ADV_DEBUG\n\tif (info->attrs[BATADV_ATTR_LOG_LEVEL]) {\n\t\tattr = info->attrs[BATADV_ATTR_LOG_LEVEL];\n\n\t\tatomic_set(&bat_priv->log_level,\n\t\t\t   nla_get_u32(attr) & BATADV_DBG_ALL);\n\t}\n#endif  \n\n#ifdef CONFIG_BATMAN_ADV_MCAST\n\tif (info->attrs[BATADV_ATTR_MULTICAST_FORCEFLOOD_ENABLED]) {\n\t\tattr = info->attrs[BATADV_ATTR_MULTICAST_FORCEFLOOD_ENABLED];\n\n\t\tatomic_set(&bat_priv->multicast_mode, !nla_get_u8(attr));\n\t}\n\n\tif (info->attrs[BATADV_ATTR_MULTICAST_FANOUT]) {\n\t\tattr = info->attrs[BATADV_ATTR_MULTICAST_FANOUT];\n\n\t\tatomic_set(&bat_priv->multicast_fanout, nla_get_u32(attr));\n\t}\n#endif  \n\n#ifdef CONFIG_BATMAN_ADV_NC\n\tif (info->attrs[BATADV_ATTR_NETWORK_CODING_ENABLED]) {\n\t\tattr = info->attrs[BATADV_ATTR_NETWORK_CODING_ENABLED];\n\n\t\tatomic_set(&bat_priv->network_coding, !!nla_get_u8(attr));\n\t\tbatadv_nc_status_update(bat_priv->soft_iface);\n\t}\n#endif  \n\n\tif (info->attrs[BATADV_ATTR_ORIG_INTERVAL]) {\n\t\tu32 orig_interval;\n\n\t\tattr = info->attrs[BATADV_ATTR_ORIG_INTERVAL];\n\t\torig_interval = nla_get_u32(attr);\n\n\t\torig_interval = min_t(u32, orig_interval, INT_MAX);\n\t\torig_interval = max_t(u32, orig_interval, 2 * BATADV_JITTER);\n\n\t\tatomic_set(&bat_priv->orig_interval, orig_interval);\n\t}\n\n\tbatadv_netlink_notify_mesh(bat_priv);\n\n\treturn 0;\n}\n\n \nstatic int\nbatadv_netlink_tp_meter_put(struct sk_buff *msg, u32 cookie)\n{\n\tif (nla_put_u32(msg, BATADV_ATTR_TPMETER_COOKIE, cookie))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\n \nint batadv_netlink_tpmeter_notify(struct batadv_priv *bat_priv, const u8 *dst,\n\t\t\t\t  u8 result, u32 test_time, u64 total_bytes,\n\t\t\t\t  u32 cookie)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &batadv_netlink_family, 0,\n\t\t\t  BATADV_CMD_TP_METER);\n\tif (!hdr) {\n\t\tret = -ENOBUFS;\n\t\tgoto err_genlmsg;\n\t}\n\n\tif (nla_put_u32(msg, BATADV_ATTR_TPMETER_COOKIE, cookie))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, BATADV_ATTR_TPMETER_TEST_TIME, test_time))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, BATADV_ATTR_TPMETER_BYTES, total_bytes,\n\t\t\t      BATADV_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, BATADV_ATTR_TPMETER_RESULT, result))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN, dst))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&batadv_netlink_family,\n\t\t\t\tdev_net(bat_priv->soft_iface), msg, 0,\n\t\t\t\tBATADV_NL_MCGRP_TPMETER, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tret = -EMSGSIZE;\n\nerr_genlmsg:\n\tnlmsg_free(msg);\n\treturn ret;\n}\n\n \nstatic int\nbatadv_netlink_tp_meter_start(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct batadv_priv *bat_priv = info->user_ptr[0];\n\tstruct sk_buff *msg = NULL;\n\tu32 test_length;\n\tvoid *msg_head;\n\tu32 cookie;\n\tu8 *dst;\n\tint ret;\n\n\tif (!info->attrs[BATADV_ATTR_ORIG_ADDRESS])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[BATADV_ATTR_TPMETER_TEST_TIME])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[BATADV_ATTR_ORIG_ADDRESS]);\n\n\ttest_length = nla_get_u32(info->attrs[BATADV_ATTR_TPMETER_TEST_TIME]);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg_head = genlmsg_put(msg, info->snd_portid, info->snd_seq,\n\t\t\t       &batadv_netlink_family, 0,\n\t\t\t       BATADV_CMD_TP_METER);\n\tif (!msg_head) {\n\t\tret = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tbatadv_tp_start(bat_priv, dst, test_length, &cookie);\n\n\tret = batadv_netlink_tp_meter_put(msg, cookie);\n\n out:\n\tif (ret) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\t\treturn ret;\n\t}\n\n\tgenlmsg_end(msg, msg_head);\n\treturn genlmsg_reply(msg, info);\n}\n\n \nstatic int\nbatadv_netlink_tp_meter_cancel(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct batadv_priv *bat_priv = info->user_ptr[0];\n\tu8 *dst;\n\tint ret = 0;\n\n\tif (!info->attrs[BATADV_ATTR_ORIG_ADDRESS])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[BATADV_ATTR_ORIG_ADDRESS]);\n\n\tbatadv_tp_stop(bat_priv, dst, BATADV_TP_REASON_CANCEL);\n\n\treturn ret;\n}\n\n \nstatic int batadv_netlink_hardif_fill(struct sk_buff *msg,\n\t\t\t\t      struct batadv_priv *bat_priv,\n\t\t\t\t      struct batadv_hard_iface *hard_iface,\n\t\t\t\t      enum batadv_nl_commands cmd,\n\t\t\t\t      u32 portid, u32 seq, int flags,\n\t\t\t\t      struct netlink_callback *cb)\n{\n\tstruct net_device *net_dev = hard_iface->net_dev;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (cb)\n\t\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(msg, BATADV_ATTR_MESH_IFINDEX,\n\t\t\tbat_priv->soft_iface->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(msg, BATADV_ATTR_MESH_IFNAME,\n\t\t\t   bat_priv->soft_iface->name))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\n\t\t\tnet_dev->ifindex) ||\n\t    nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\n\t\t\t   net_dev->name) ||\n\t    nla_put(msg, BATADV_ATTR_HARD_ADDRESS, ETH_ALEN,\n\t\t    net_dev->dev_addr))\n\t\tgoto nla_put_failure;\n\n\tif (hard_iface->if_status == BATADV_IF_ACTIVE) {\n\t\tif (nla_put_flag(msg, BATADV_ATTR_ACTIVE))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u8(msg, BATADV_ATTR_HOP_PENALTY,\n\t\t       atomic_read(&hard_iface->hop_penalty)))\n\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_BATMAN_ADV_BATMAN_V\n\tif (nla_put_u32(msg, BATADV_ATTR_ELP_INTERVAL,\n\t\t\tatomic_read(&hard_iface->bat_v.elp_interval)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, BATADV_ATTR_THROUGHPUT_OVERRIDE,\n\t\t\tatomic_read(&hard_iface->bat_v.throughput_override)))\n\t\tgoto nla_put_failure;\n#endif  \n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int batadv_netlink_notify_hardif(struct batadv_priv *bat_priv,\n\t\t\t\t\tstruct batadv_hard_iface *hard_iface)\n{\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = batadv_netlink_hardif_fill(msg, bat_priv, hard_iface,\n\t\t\t\t\t BATADV_CMD_SET_HARDIF, 0, 0, 0, NULL);\n\tif (ret < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn ret;\n\t}\n\n\tgenlmsg_multicast_netns(&batadv_netlink_family,\n\t\t\t\tdev_net(bat_priv->soft_iface), msg, 0,\n\t\t\t\tBATADV_NL_MCGRP_CONFIG, GFP_KERNEL);\n\n\treturn 0;\n}\n\n \nstatic int batadv_netlink_get_hardif(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct batadv_hard_iface *hard_iface = info->user_ptr[1];\n\tstruct batadv_priv *bat_priv = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = batadv_netlink_hardif_fill(msg, bat_priv, hard_iface,\n\t\t\t\t\t BATADV_CMD_GET_HARDIF,\n\t\t\t\t\t info->snd_portid, info->snd_seq, 0,\n\t\t\t\t\t NULL);\n\tif (ret < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn ret;\n\t}\n\n\tret = genlmsg_reply(msg, info);\n\n\treturn ret;\n}\n\n \nstatic int batadv_netlink_set_hardif(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct batadv_hard_iface *hard_iface = info->user_ptr[1];\n\tstruct batadv_priv *bat_priv = info->user_ptr[0];\n\tstruct nlattr *attr;\n\n\tif (info->attrs[BATADV_ATTR_HOP_PENALTY]) {\n\t\tattr = info->attrs[BATADV_ATTR_HOP_PENALTY];\n\n\t\tatomic_set(&hard_iface->hop_penalty, nla_get_u8(attr));\n\t}\n\n#ifdef CONFIG_BATMAN_ADV_BATMAN_V\n\n\tif (info->attrs[BATADV_ATTR_ELP_INTERVAL]) {\n\t\tattr = info->attrs[BATADV_ATTR_ELP_INTERVAL];\n\n\t\tatomic_set(&hard_iface->bat_v.elp_interval, nla_get_u32(attr));\n\t}\n\n\tif (info->attrs[BATADV_ATTR_THROUGHPUT_OVERRIDE]) {\n\t\tattr = info->attrs[BATADV_ATTR_THROUGHPUT_OVERRIDE];\n\n\t\tatomic_set(&hard_iface->bat_v.throughput_override,\n\t\t\t   nla_get_u32(attr));\n\t}\n#endif  \n\n\tbatadv_netlink_notify_hardif(bat_priv, hard_iface);\n\n\treturn 0;\n}\n\n \nstatic int\nbatadv_netlink_dump_hardif(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct net_device *soft_iface;\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_priv *bat_priv;\n\tint ifindex;\n\tint portid = NETLINK_CB(cb->skb).portid;\n\tint skip = cb->args[0];\n\tint i = 0;\n\n\tifindex = batadv_netlink_get_ifindex(cb->nlh,\n\t\t\t\t\t     BATADV_ATTR_MESH_IFINDEX);\n\tif (!ifindex)\n\t\treturn -EINVAL;\n\n\tsoft_iface = dev_get_by_index(net, ifindex);\n\tif (!soft_iface)\n\t\treturn -ENODEV;\n\n\tif (!batadv_softif_is_valid(soft_iface)) {\n\t\tdev_put(soft_iface);\n\t\treturn -ENODEV;\n\t}\n\n\tbat_priv = netdev_priv(soft_iface);\n\n\trtnl_lock();\n\tcb->seq = batadv_hardif_generation << 1 | 1;\n\n\tlist_for_each_entry(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->soft_iface != soft_iface)\n\t\t\tcontinue;\n\n\t\tif (i++ < skip)\n\t\t\tcontinue;\n\n\t\tif (batadv_netlink_hardif_fill(msg, bat_priv, hard_iface,\n\t\t\t\t\t       BATADV_CMD_GET_HARDIF,\n\t\t\t\t\t       portid, cb->nlh->nlmsg_seq,\n\t\t\t\t\t       NLM_F_MULTI, cb)) {\n\t\t\ti--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trtnl_unlock();\n\n\tdev_put(soft_iface);\n\n\tcb->args[0] = i;\n\n\treturn msg->len;\n}\n\n \nstatic int batadv_netlink_vlan_fill(struct sk_buff *msg,\n\t\t\t\t    struct batadv_priv *bat_priv,\n\t\t\t\t    struct batadv_softif_vlan *vlan,\n\t\t\t\t    enum batadv_nl_commands cmd,\n\t\t\t\t    u32 portid, u32 seq, int flags)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, BATADV_ATTR_MESH_IFINDEX,\n\t\t\tbat_priv->soft_iface->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(msg, BATADV_ATTR_MESH_IFNAME,\n\t\t\t   bat_priv->soft_iface->name))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, BATADV_ATTR_VLANID, vlan->vid & VLAN_VID_MASK))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, BATADV_ATTR_AP_ISOLATION_ENABLED,\n\t\t       !!atomic_read(&vlan->ap_isolation)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int batadv_netlink_notify_vlan(struct batadv_priv *bat_priv,\n\t\t\t\t      struct batadv_softif_vlan *vlan)\n{\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = batadv_netlink_vlan_fill(msg, bat_priv, vlan,\n\t\t\t\t       BATADV_CMD_SET_VLAN, 0, 0, 0);\n\tif (ret < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn ret;\n\t}\n\n\tgenlmsg_multicast_netns(&batadv_netlink_family,\n\t\t\t\tdev_net(bat_priv->soft_iface), msg, 0,\n\t\t\t\tBATADV_NL_MCGRP_CONFIG, GFP_KERNEL);\n\n\treturn 0;\n}\n\n \nstatic int batadv_netlink_get_vlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct batadv_softif_vlan *vlan = info->user_ptr[1];\n\tstruct batadv_priv *bat_priv = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = batadv_netlink_vlan_fill(msg, bat_priv, vlan, BATADV_CMD_GET_VLAN,\n\t\t\t\t       info->snd_portid, info->snd_seq, 0);\n\tif (ret < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn ret;\n\t}\n\n\tret = genlmsg_reply(msg, info);\n\n\treturn ret;\n}\n\n \nstatic int batadv_netlink_set_vlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct batadv_softif_vlan *vlan = info->user_ptr[1];\n\tstruct batadv_priv *bat_priv = info->user_ptr[0];\n\tstruct nlattr *attr;\n\n\tif (info->attrs[BATADV_ATTR_AP_ISOLATION_ENABLED]) {\n\t\tattr = info->attrs[BATADV_ATTR_AP_ISOLATION_ENABLED];\n\n\t\tatomic_set(&vlan->ap_isolation, !!nla_get_u8(attr));\n\t}\n\n\tbatadv_netlink_notify_vlan(bat_priv, vlan);\n\n\treturn 0;\n}\n\n \nstatic struct net_device *\nbatadv_get_softif_from_info(struct net *net, struct genl_info *info)\n{\n\tstruct net_device *soft_iface;\n\tint ifindex;\n\n\tif (!info->attrs[BATADV_ATTR_MESH_IFINDEX])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tifindex = nla_get_u32(info->attrs[BATADV_ATTR_MESH_IFINDEX]);\n\n\tsoft_iface = dev_get_by_index(net, ifindex);\n\tif (!soft_iface)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (!batadv_softif_is_valid(soft_iface))\n\t\tgoto err_put_softif;\n\n\treturn soft_iface;\n\nerr_put_softif:\n\tdev_put(soft_iface);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstatic struct batadv_hard_iface *\nbatadv_get_hardif_from_info(struct batadv_priv *bat_priv, struct net *net,\n\t\t\t    struct genl_info *info)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct net_device *hard_dev;\n\tunsigned int hardif_index;\n\n\tif (!info->attrs[BATADV_ATTR_HARD_IFINDEX])\n\t\treturn ERR_PTR(-EINVAL);\n\n\thardif_index = nla_get_u32(info->attrs[BATADV_ATTR_HARD_IFINDEX]);\n\n\thard_dev = dev_get_by_index(net, hardif_index);\n\tif (!hard_dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\thard_iface = batadv_hardif_get_by_netdev(hard_dev);\n\tif (!hard_iface)\n\t\tgoto err_put_harddev;\n\n\tif (hard_iface->soft_iface != bat_priv->soft_iface)\n\t\tgoto err_put_hardif;\n\n\t \n\tdev_put(hard_dev);\n\n\treturn hard_iface;\n\nerr_put_hardif:\n\tbatadv_hardif_put(hard_iface);\nerr_put_harddev:\n\tdev_put(hard_dev);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstatic struct batadv_softif_vlan *\nbatadv_get_vlan_from_info(struct batadv_priv *bat_priv, struct net *net,\n\t\t\t  struct genl_info *info)\n{\n\tstruct batadv_softif_vlan *vlan;\n\tu16 vid;\n\n\tif (!info->attrs[BATADV_ATTR_VLANID])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tvid = nla_get_u16(info->attrs[BATADV_ATTR_VLANID]);\n\n\tvlan = batadv_softif_vlan_get(bat_priv, vid | BATADV_VLAN_HAS_TAG);\n\tif (!vlan)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn vlan;\n}\n\n \nstatic int batadv_pre_doit(const struct genl_split_ops *ops,\n\t\t\t   struct sk_buff *skb,\n\t\t\t   struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_priv *bat_priv = NULL;\n\tstruct batadv_softif_vlan *vlan;\n\tstruct net_device *soft_iface;\n\tu8 user_ptr1_flags;\n\tu8 mesh_dep_flags;\n\tint ret;\n\n\tuser_ptr1_flags = BATADV_FLAG_NEED_HARDIF | BATADV_FLAG_NEED_VLAN;\n\tif (WARN_ON(hweight8(ops->internal_flags & user_ptr1_flags) > 1))\n\t\treturn -EINVAL;\n\n\tmesh_dep_flags = BATADV_FLAG_NEED_HARDIF | BATADV_FLAG_NEED_VLAN;\n\tif (WARN_ON((ops->internal_flags & mesh_dep_flags) &&\n\t\t    (~ops->internal_flags & BATADV_FLAG_NEED_MESH)))\n\t\treturn -EINVAL;\n\n\tif (ops->internal_flags & BATADV_FLAG_NEED_MESH) {\n\t\tsoft_iface = batadv_get_softif_from_info(net, info);\n\t\tif (IS_ERR(soft_iface))\n\t\t\treturn PTR_ERR(soft_iface);\n\n\t\tbat_priv = netdev_priv(soft_iface);\n\t\tinfo->user_ptr[0] = bat_priv;\n\t}\n\n\tif (ops->internal_flags & BATADV_FLAG_NEED_HARDIF) {\n\t\thard_iface = batadv_get_hardif_from_info(bat_priv, net, info);\n\t\tif (IS_ERR(hard_iface)) {\n\t\t\tret = PTR_ERR(hard_iface);\n\t\t\tgoto err_put_softif;\n\t\t}\n\n\t\tinfo->user_ptr[1] = hard_iface;\n\t}\n\n\tif (ops->internal_flags & BATADV_FLAG_NEED_VLAN) {\n\t\tvlan = batadv_get_vlan_from_info(bat_priv, net, info);\n\t\tif (IS_ERR(vlan)) {\n\t\t\tret = PTR_ERR(vlan);\n\t\t\tgoto err_put_softif;\n\t\t}\n\n\t\tinfo->user_ptr[1] = vlan;\n\t}\n\n\treturn 0;\n\nerr_put_softif:\n\tif (bat_priv)\n\t\tdev_put(bat_priv->soft_iface);\n\n\treturn ret;\n}\n\n \nstatic void batadv_post_doit(const struct genl_split_ops *ops,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct genl_info *info)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_softif_vlan *vlan;\n\tstruct batadv_priv *bat_priv;\n\n\tif (ops->internal_flags & BATADV_FLAG_NEED_HARDIF &&\n\t    info->user_ptr[1]) {\n\t\thard_iface = info->user_ptr[1];\n\n\t\tbatadv_hardif_put(hard_iface);\n\t}\n\n\tif (ops->internal_flags & BATADV_FLAG_NEED_VLAN && info->user_ptr[1]) {\n\t\tvlan = info->user_ptr[1];\n\t\tbatadv_softif_vlan_put(vlan);\n\t}\n\n\tif (ops->internal_flags & BATADV_FLAG_NEED_MESH && info->user_ptr[0]) {\n\t\tbat_priv = info->user_ptr[0];\n\t\tdev_put(bat_priv->soft_iface);\n\t}\n}\n\nstatic const struct genl_small_ops batadv_netlink_ops[] = {\n\t{\n\t\t.cmd = BATADV_CMD_GET_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t \n\t\t.doit = batadv_netlink_get_mesh,\n\t\t.internal_flags = BATADV_FLAG_NEED_MESH,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_TP_METER,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = batadv_netlink_tp_meter_start,\n\t\t.internal_flags = BATADV_FLAG_NEED_MESH,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_TP_METER_CANCEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = batadv_netlink_tp_meter_cancel,\n\t\t.internal_flags = BATADV_FLAG_NEED_MESH,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_ROUTING_ALGOS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.dumpit = batadv_algo_dump,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_HARDIF,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t \n\t\t.dumpit = batadv_netlink_dump_hardif,\n\t\t.doit = batadv_netlink_get_hardif,\n\t\t.internal_flags = BATADV_FLAG_NEED_MESH |\n\t\t\t\t  BATADV_FLAG_NEED_HARDIF,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_TRANSTABLE_LOCAL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.dumpit = batadv_tt_local_dump,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_TRANSTABLE_GLOBAL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.dumpit = batadv_tt_global_dump,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_ORIGINATORS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.dumpit = batadv_orig_dump,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_NEIGHBORS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.dumpit = batadv_hardif_neigh_dump,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_GATEWAYS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.dumpit = batadv_gw_dump,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_BLA_CLAIM,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.dumpit = batadv_bla_claim_dump,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_BLA_BACKBONE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.dumpit = batadv_bla_backbone_dump,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_DAT_CACHE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.dumpit = batadv_dat_cache_dump,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_MCAST_FLAGS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.dumpit = batadv_mcast_flags_dump,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_SET_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = batadv_netlink_set_mesh,\n\t\t.internal_flags = BATADV_FLAG_NEED_MESH,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_SET_HARDIF,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = batadv_netlink_set_hardif,\n\t\t.internal_flags = BATADV_FLAG_NEED_MESH |\n\t\t\t\t  BATADV_FLAG_NEED_HARDIF,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_GET_VLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t \n\t\t.doit = batadv_netlink_get_vlan,\n\t\t.internal_flags = BATADV_FLAG_NEED_MESH |\n\t\t\t\t  BATADV_FLAG_NEED_VLAN,\n\t},\n\t{\n\t\t.cmd = BATADV_CMD_SET_VLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = batadv_netlink_set_vlan,\n\t\t.internal_flags = BATADV_FLAG_NEED_MESH |\n\t\t\t\t  BATADV_FLAG_NEED_VLAN,\n\t},\n};\n\nstruct genl_family batadv_netlink_family __ro_after_init = {\n\t.hdrsize = 0,\n\t.name = BATADV_NL_NAME,\n\t.version = 1,\n\t.maxattr = BATADV_ATTR_MAX,\n\t.policy = batadv_netlink_policy,\n\t.netnsok = true,\n\t.pre_doit = batadv_pre_doit,\n\t.post_doit = batadv_post_doit,\n\t.module = THIS_MODULE,\n\t.small_ops = batadv_netlink_ops,\n\t.n_small_ops = ARRAY_SIZE(batadv_netlink_ops),\n\t.resv_start_op = BATADV_CMD_SET_VLAN + 1,\n\t.mcgrps = batadv_netlink_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(batadv_netlink_mcgrps),\n};\n\n \nvoid __init batadv_netlink_register(void)\n{\n\tint ret;\n\n\tret = genl_register_family(&batadv_netlink_family);\n\tif (ret)\n\t\tpr_warn(\"unable to register netlink family\");\n}\n\n \nvoid batadv_netlink_unregister(void)\n{\n\tgenl_unregister_family(&batadv_netlink_family);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}