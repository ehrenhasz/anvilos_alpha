{
  "module_name": "multicast.c",
  "hash_id": "0f72156f0e9d33619c4d40f929377c5083da22601078776929d9c74dee4970e0",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/multicast.c",
  "human_readable_source": "\n \n\n#include \"multicast.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/bug.h>\n#include <linux/byteorder/generic.h>\n#include <linux/container_of.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/icmpv6.h>\n#include <linux/if_bridge.h>\n#include <linux/if_ether.h>\n#include <linux/igmp.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/inetdevice.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/printk.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <net/addrconf.h>\n#include <net/genetlink.h>\n#include <net/if_inet6.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"bridge_loop_avoidance.h\"\n#include \"hard-interface.h\"\n#include \"hash.h\"\n#include \"log.h\"\n#include \"netlink.h\"\n#include \"send.h\"\n#include \"soft-interface.h\"\n#include \"translation-table.h\"\n#include \"tvlv.h\"\n\nstatic void batadv_mcast_mla_update(struct work_struct *work);\n\n \nstatic void batadv_mcast_start_timer(struct batadv_priv *bat_priv)\n{\n\tqueue_delayed_work(batadv_event_workqueue, &bat_priv->mcast.work,\n\t\t\t   msecs_to_jiffies(BATADV_MCAST_WORK_PERIOD));\n}\n\n \nstatic struct net_device *batadv_mcast_get_bridge(struct net_device *soft_iface)\n{\n\tstruct net_device *upper = soft_iface;\n\n\trcu_read_lock();\n\tdo {\n\t\tupper = netdev_master_upper_dev_get_rcu(upper);\n\t} while (upper && !netif_is_bridge_master(upper));\n\n\tdev_hold(upper);\n\trcu_read_unlock();\n\n\treturn upper;\n}\n\n \nstatic u8 batadv_mcast_mla_rtr_flags_softif_get_ipv4(struct net_device *dev)\n{\n\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\n\tif (in_dev && IN_DEV_MFORWARD(in_dev))\n\t\treturn BATADV_NO_FLAGS;\n\telse\n\t\treturn BATADV_MCAST_WANT_NO_RTR4;\n}\n\n \n#if IS_ENABLED(CONFIG_IPV6_MROUTE)\nstatic u8 batadv_mcast_mla_rtr_flags_softif_get_ipv6(struct net_device *dev)\n{\n\tstruct inet6_dev *in6_dev = __in6_dev_get(dev);\n\n\tif (in6_dev && atomic_read(&in6_dev->cnf.mc_forwarding))\n\t\treturn BATADV_NO_FLAGS;\n\telse\n\t\treturn BATADV_MCAST_WANT_NO_RTR6;\n}\n#else\nstatic inline u8\nbatadv_mcast_mla_rtr_flags_softif_get_ipv6(struct net_device *dev)\n{\n\treturn BATADV_MCAST_WANT_NO_RTR6;\n}\n#endif\n\n \nstatic u8 batadv_mcast_mla_rtr_flags_softif_get(struct batadv_priv *bat_priv,\n\t\t\t\t\t\tstruct net_device *bridge)\n{\n\tstruct net_device *dev = bridge ? bridge : bat_priv->soft_iface;\n\tu8 flags = BATADV_NO_FLAGS;\n\n\trcu_read_lock();\n\n\tflags |= batadv_mcast_mla_rtr_flags_softif_get_ipv4(dev);\n\tflags |= batadv_mcast_mla_rtr_flags_softif_get_ipv6(dev);\n\n\trcu_read_unlock();\n\n\treturn flags;\n}\n\n \nstatic u8 batadv_mcast_mla_rtr_flags_bridge_get(struct batadv_priv *bat_priv,\n\t\t\t\t\t\tstruct net_device *bridge)\n{\n\tstruct net_device *dev = bat_priv->soft_iface;\n\tu8 flags = BATADV_NO_FLAGS;\n\n\tif (!bridge)\n\t\treturn BATADV_MCAST_WANT_NO_RTR4 | BATADV_MCAST_WANT_NO_RTR6;\n\n\tif (!br_multicast_has_router_adjacent(dev, ETH_P_IP))\n\t\tflags |= BATADV_MCAST_WANT_NO_RTR4;\n\tif (!br_multicast_has_router_adjacent(dev, ETH_P_IPV6))\n\t\tflags |= BATADV_MCAST_WANT_NO_RTR6;\n\n\treturn flags;\n}\n\n \nstatic u8 batadv_mcast_mla_rtr_flags_get(struct batadv_priv *bat_priv,\n\t\t\t\t\t struct net_device *bridge)\n{\n\tu8 flags = BATADV_MCAST_WANT_NO_RTR4 | BATADV_MCAST_WANT_NO_RTR6;\n\n\tflags &= batadv_mcast_mla_rtr_flags_softif_get(bat_priv, bridge);\n\tflags &= batadv_mcast_mla_rtr_flags_bridge_get(bat_priv, bridge);\n\n\treturn flags;\n}\n\n \nstatic struct batadv_mcast_mla_flags\nbatadv_mcast_mla_flags_get(struct batadv_priv *bat_priv)\n{\n\tstruct net_device *dev = bat_priv->soft_iface;\n\tstruct batadv_mcast_querier_state *qr4, *qr6;\n\tstruct batadv_mcast_mla_flags mla_flags;\n\tstruct net_device *bridge;\n\n\tbridge = batadv_mcast_get_bridge(dev);\n\n\tmemset(&mla_flags, 0, sizeof(mla_flags));\n\tmla_flags.enabled = 1;\n\tmla_flags.tvlv_flags |= batadv_mcast_mla_rtr_flags_get(bat_priv,\n\t\t\t\t\t\t\t       bridge);\n\n\tif (!bridge)\n\t\treturn mla_flags;\n\n\tdev_put(bridge);\n\n\tmla_flags.bridged = 1;\n\tqr4 = &mla_flags.querier_ipv4;\n\tqr6 = &mla_flags.querier_ipv6;\n\n\tif (!IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING))\n\t\tpr_warn_once(\"No bridge IGMP snooping compiled - multicast optimizations disabled\\n\");\n\n\tqr4->exists = br_multicast_has_querier_anywhere(dev, ETH_P_IP);\n\tqr4->shadowing = br_multicast_has_querier_adjacent(dev, ETH_P_IP);\n\n\tqr6->exists = br_multicast_has_querier_anywhere(dev, ETH_P_IPV6);\n\tqr6->shadowing = br_multicast_has_querier_adjacent(dev, ETH_P_IPV6);\n\n\tmla_flags.tvlv_flags |= BATADV_MCAST_WANT_ALL_UNSNOOPABLES;\n\n\t \n\tif (!qr4->exists || qr4->shadowing) {\n\t\tmla_flags.tvlv_flags |= BATADV_MCAST_WANT_ALL_IPV4;\n\t\tmla_flags.tvlv_flags &= ~BATADV_MCAST_WANT_NO_RTR4;\n\t}\n\n\tif (!qr6->exists || qr6->shadowing) {\n\t\tmla_flags.tvlv_flags |= BATADV_MCAST_WANT_ALL_IPV6;\n\t\tmla_flags.tvlv_flags &= ~BATADV_MCAST_WANT_NO_RTR6;\n\t}\n\n\treturn mla_flags;\n}\n\n \nstatic bool batadv_mcast_mla_is_duplicate(u8 *mcast_addr,\n\t\t\t\t\t  struct hlist_head *mcast_list)\n{\n\tstruct batadv_hw_addr *mcast_entry;\n\n\thlist_for_each_entry(mcast_entry, mcast_list, list)\n\t\tif (batadv_compare_eth(mcast_entry->addr, mcast_addr))\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int\nbatadv_mcast_mla_softif_get_ipv4(struct net_device *dev,\n\t\t\t\t struct hlist_head *mcast_list,\n\t\t\t\t struct batadv_mcast_mla_flags *flags)\n{\n\tstruct batadv_hw_addr *new;\n\tstruct in_device *in_dev;\n\tu8 mcast_addr[ETH_ALEN];\n\tstruct ip_mc_list *pmc;\n\tint ret = 0;\n\n\tif (flags->tvlv_flags & BATADV_MCAST_WANT_ALL_IPV4)\n\t\treturn 0;\n\n\trcu_read_lock();\n\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (!in_dev) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tfor (pmc = rcu_dereference(in_dev->mc_list); pmc;\n\t     pmc = rcu_dereference(pmc->next_rcu)) {\n\t\tif (flags->tvlv_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES &&\n\t\t    ipv4_is_local_multicast(pmc->multiaddr))\n\t\t\tcontinue;\n\n\t\tif (!(flags->tvlv_flags & BATADV_MCAST_WANT_NO_RTR4) &&\n\t\t    !ipv4_is_local_multicast(pmc->multiaddr))\n\t\t\tcontinue;\n\n\t\tip_eth_mc_map(pmc->multiaddr, mcast_addr);\n\n\t\tif (batadv_mcast_mla_is_duplicate(mcast_addr, mcast_list))\n\t\t\tcontinue;\n\n\t\tnew = kmalloc(sizeof(*new), GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tether_addr_copy(new->addr, mcast_addr);\n\t\thlist_add_head(&new->list, mcast_list);\n\t\tret++;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n \n#if IS_ENABLED(CONFIG_IPV6)\nstatic int\nbatadv_mcast_mla_softif_get_ipv6(struct net_device *dev,\n\t\t\t\t struct hlist_head *mcast_list,\n\t\t\t\t struct batadv_mcast_mla_flags *flags)\n{\n\tstruct batadv_hw_addr *new;\n\tstruct inet6_dev *in6_dev;\n\tu8 mcast_addr[ETH_ALEN];\n\tstruct ifmcaddr6 *pmc6;\n\tint ret = 0;\n\n\tif (flags->tvlv_flags & BATADV_MCAST_WANT_ALL_IPV6)\n\t\treturn 0;\n\n\trcu_read_lock();\n\n\tin6_dev = __in6_dev_get(dev);\n\tif (!in6_dev) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tfor (pmc6 = rcu_dereference(in6_dev->mc_list);\n\t     pmc6;\n\t     pmc6 = rcu_dereference(pmc6->next)) {\n\t\tif (IPV6_ADDR_MC_SCOPE(&pmc6->mca_addr) <\n\t\t    IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\t\tcontinue;\n\n\t\tif (flags->tvlv_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES &&\n\t\t    ipv6_addr_is_ll_all_nodes(&pmc6->mca_addr))\n\t\t\tcontinue;\n\n\t\tif (!(flags->tvlv_flags & BATADV_MCAST_WANT_NO_RTR6) &&\n\t\t    IPV6_ADDR_MC_SCOPE(&pmc6->mca_addr) >\n\t\t    IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\t\tcontinue;\n\n\t\tipv6_eth_mc_map(&pmc6->mca_addr, mcast_addr);\n\n\t\tif (batadv_mcast_mla_is_duplicate(mcast_addr, mcast_list))\n\t\t\tcontinue;\n\n\t\tnew = kmalloc(sizeof(*new), GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tether_addr_copy(new->addr, mcast_addr);\n\t\thlist_add_head(&new->list, mcast_list);\n\t\tret++;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n#else\nstatic inline int\nbatadv_mcast_mla_softif_get_ipv6(struct net_device *dev,\n\t\t\t\t struct hlist_head *mcast_list,\n\t\t\t\t struct batadv_mcast_mla_flags *flags)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic int\nbatadv_mcast_mla_softif_get(struct net_device *dev,\n\t\t\t    struct hlist_head *mcast_list,\n\t\t\t    struct batadv_mcast_mla_flags *flags)\n{\n\tstruct net_device *bridge = batadv_mcast_get_bridge(dev);\n\tint ret4, ret6 = 0;\n\n\tif (bridge)\n\t\tdev = bridge;\n\n\tret4 = batadv_mcast_mla_softif_get_ipv4(dev, mcast_list, flags);\n\tif (ret4 < 0)\n\t\tgoto out;\n\n\tret6 = batadv_mcast_mla_softif_get_ipv6(dev, mcast_list, flags);\n\tif (ret6 < 0) {\n\t\tret4 = 0;\n\t\tgoto out;\n\t}\n\nout:\n\tdev_put(bridge);\n\n\treturn ret4 + ret6;\n}\n\n \nstatic void batadv_mcast_mla_br_addr_cpy(char *dst, const struct br_ip *src)\n{\n\tif (src->proto == htons(ETH_P_IP))\n\t\tip_eth_mc_map(src->dst.ip4, dst);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (src->proto == htons(ETH_P_IPV6))\n\t\tipv6_eth_mc_map(&src->dst.ip6, dst);\n#endif\n\telse\n\t\teth_zero_addr(dst);\n}\n\n \nstatic int batadv_mcast_mla_bridge_get(struct net_device *dev,\n\t\t\t\t       struct hlist_head *mcast_list,\n\t\t\t\t       struct batadv_mcast_mla_flags *flags)\n{\n\tstruct list_head bridge_mcast_list = LIST_HEAD_INIT(bridge_mcast_list);\n\tstruct br_ip_list *br_ip_entry, *tmp;\n\tu8 tvlv_flags = flags->tvlv_flags;\n\tstruct batadv_hw_addr *new;\n\tu8 mcast_addr[ETH_ALEN];\n\tint ret;\n\n\t \n\tret = br_multicast_list_adjacent(dev, &bridge_mcast_list);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlist_for_each_entry(br_ip_entry, &bridge_mcast_list, list) {\n\t\tif (br_ip_entry->addr.proto == htons(ETH_P_IP)) {\n\t\t\tif (tvlv_flags & BATADV_MCAST_WANT_ALL_IPV4)\n\t\t\t\tcontinue;\n\n\t\t\tif (tvlv_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES &&\n\t\t\t    ipv4_is_local_multicast(br_ip_entry->addr.dst.ip4))\n\t\t\t\tcontinue;\n\n\t\t\tif (!(tvlv_flags & BATADV_MCAST_WANT_NO_RTR4) &&\n\t\t\t    !ipv4_is_local_multicast(br_ip_entry->addr.dst.ip4))\n\t\t\t\tcontinue;\n\t\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (br_ip_entry->addr.proto == htons(ETH_P_IPV6)) {\n\t\t\tif (tvlv_flags & BATADV_MCAST_WANT_ALL_IPV6)\n\t\t\t\tcontinue;\n\n\t\t\tif (tvlv_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES &&\n\t\t\t    ipv6_addr_is_ll_all_nodes(&br_ip_entry->addr.dst.ip6))\n\t\t\t\tcontinue;\n\n\t\t\tif (!(tvlv_flags & BATADV_MCAST_WANT_NO_RTR6) &&\n\t\t\t    IPV6_ADDR_MC_SCOPE(&br_ip_entry->addr.dst.ip6) >\n\t\t\t    IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tbatadv_mcast_mla_br_addr_cpy(mcast_addr, &br_ip_entry->addr);\n\t\tif (batadv_mcast_mla_is_duplicate(mcast_addr, mcast_list))\n\t\t\tcontinue;\n\n\t\tnew = kmalloc(sizeof(*new), GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tether_addr_copy(new->addr, mcast_addr);\n\t\thlist_add_head(&new->list, mcast_list);\n\t}\n\nout:\n\tlist_for_each_entry_safe(br_ip_entry, tmp, &bridge_mcast_list, list) {\n\t\tlist_del(&br_ip_entry->list);\n\t\tkfree(br_ip_entry);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void batadv_mcast_mla_list_free(struct hlist_head *mcast_list)\n{\n\tstruct batadv_hw_addr *mcast_entry;\n\tstruct hlist_node *tmp;\n\n\thlist_for_each_entry_safe(mcast_entry, tmp, mcast_list, list) {\n\t\thlist_del(&mcast_entry->list);\n\t\tkfree(mcast_entry);\n\t}\n}\n\n \nstatic void batadv_mcast_mla_tt_retract(struct batadv_priv *bat_priv,\n\t\t\t\t\tstruct hlist_head *mcast_list)\n{\n\tstruct batadv_hw_addr *mcast_entry;\n\tstruct hlist_node *tmp;\n\n\thlist_for_each_entry_safe(mcast_entry, tmp, &bat_priv->mcast.mla_list,\n\t\t\t\t  list) {\n\t\tif (mcast_list &&\n\t\t    batadv_mcast_mla_is_duplicate(mcast_entry->addr,\n\t\t\t\t\t\t  mcast_list))\n\t\t\tcontinue;\n\n\t\tbatadv_tt_local_remove(bat_priv, mcast_entry->addr,\n\t\t\t\t       BATADV_NO_FLAGS,\n\t\t\t\t       \"mcast TT outdated\", false);\n\n\t\thlist_del(&mcast_entry->list);\n\t\tkfree(mcast_entry);\n\t}\n}\n\n \nstatic void batadv_mcast_mla_tt_add(struct batadv_priv *bat_priv,\n\t\t\t\t    struct hlist_head *mcast_list)\n{\n\tstruct batadv_hw_addr *mcast_entry;\n\tstruct hlist_node *tmp;\n\n\tif (!mcast_list)\n\t\treturn;\n\n\thlist_for_each_entry_safe(mcast_entry, tmp, mcast_list, list) {\n\t\tif (batadv_mcast_mla_is_duplicate(mcast_entry->addr,\n\t\t\t\t\t\t  &bat_priv->mcast.mla_list))\n\t\t\tcontinue;\n\n\t\tif (!batadv_tt_local_add(bat_priv->soft_iface,\n\t\t\t\t\t mcast_entry->addr, BATADV_NO_FLAGS,\n\t\t\t\t\t BATADV_NULL_IFINDEX, BATADV_NO_MARK))\n\t\t\tcontinue;\n\n\t\thlist_del(&mcast_entry->list);\n\t\thlist_add_head(&mcast_entry->list, &bat_priv->mcast.mla_list);\n\t}\n}\n\n \nstatic void\nbatadv_mcast_querier_log(struct batadv_priv *bat_priv, char *str_proto,\n\t\t\t struct batadv_mcast_querier_state *old_state,\n\t\t\t struct batadv_mcast_querier_state *new_state)\n{\n\tif (!old_state->exists && new_state->exists)\n\t\tbatadv_info(bat_priv->soft_iface, \"%s Querier appeared\\n\",\n\t\t\t    str_proto);\n\telse if (old_state->exists && !new_state->exists)\n\t\tbatadv_info(bat_priv->soft_iface,\n\t\t\t    \"%s Querier disappeared - multicast optimizations disabled\\n\",\n\t\t\t    str_proto);\n\telse if (!bat_priv->mcast.mla_flags.bridged && !new_state->exists)\n\t\tbatadv_info(bat_priv->soft_iface,\n\t\t\t    \"No %s Querier present - multicast optimizations disabled\\n\",\n\t\t\t    str_proto);\n\n\tif (new_state->exists) {\n\t\tif ((!old_state->shadowing && new_state->shadowing) ||\n\t\t    (!old_state->exists && new_state->shadowing))\n\t\t\tbatadv_dbg(BATADV_DBG_MCAST, bat_priv,\n\t\t\t\t   \"%s Querier is behind our bridged segment: Might shadow listeners\\n\",\n\t\t\t\t   str_proto);\n\t\telse if (old_state->shadowing && !new_state->shadowing)\n\t\t\tbatadv_dbg(BATADV_DBG_MCAST, bat_priv,\n\t\t\t\t   \"%s Querier is not behind our bridged segment\\n\",\n\t\t\t\t   str_proto);\n\t}\n}\n\n \nstatic void\nbatadv_mcast_bridge_log(struct batadv_priv *bat_priv,\n\t\t\tstruct batadv_mcast_mla_flags *new_flags)\n{\n\tstruct batadv_mcast_mla_flags *old_flags = &bat_priv->mcast.mla_flags;\n\n\tif (!old_flags->bridged && new_flags->bridged)\n\t\tbatadv_dbg(BATADV_DBG_MCAST, bat_priv,\n\t\t\t   \"Bridge added: Setting Unsnoopables(U)-flag\\n\");\n\telse if (old_flags->bridged && !new_flags->bridged)\n\t\tbatadv_dbg(BATADV_DBG_MCAST, bat_priv,\n\t\t\t   \"Bridge removed: Unsetting Unsnoopables(U)-flag\\n\");\n\n\tif (new_flags->bridged) {\n\t\tbatadv_mcast_querier_log(bat_priv, \"IGMP\",\n\t\t\t\t\t &old_flags->querier_ipv4,\n\t\t\t\t\t &new_flags->querier_ipv4);\n\t\tbatadv_mcast_querier_log(bat_priv, \"MLD\",\n\t\t\t\t\t &old_flags->querier_ipv6,\n\t\t\t\t\t &new_flags->querier_ipv6);\n\t}\n}\n\n \nstatic void batadv_mcast_flags_log(struct batadv_priv *bat_priv, u8 flags)\n{\n\tbool old_enabled = bat_priv->mcast.mla_flags.enabled;\n\tu8 old_flags = bat_priv->mcast.mla_flags.tvlv_flags;\n\tchar str_old_flags[] = \"[.... . ]\";\n\n\tsprintf(str_old_flags, \"[%c%c%c%s%s]\",\n\t\t(old_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES) ? 'U' : '.',\n\t\t(old_flags & BATADV_MCAST_WANT_ALL_IPV4) ? '4' : '.',\n\t\t(old_flags & BATADV_MCAST_WANT_ALL_IPV6) ? '6' : '.',\n\t\t!(old_flags & BATADV_MCAST_WANT_NO_RTR4) ? \"R4\" : \". \",\n\t\t!(old_flags & BATADV_MCAST_WANT_NO_RTR6) ? \"R6\" : \". \");\n\n\tbatadv_dbg(BATADV_DBG_MCAST, bat_priv,\n\t\t   \"Changing multicast flags from '%s' to '[%c%c%c%s%s]'\\n\",\n\t\t   old_enabled ? str_old_flags : \"<undefined>\",\n\t\t   (flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES) ? 'U' : '.',\n\t\t   (flags & BATADV_MCAST_WANT_ALL_IPV4) ? '4' : '.',\n\t\t   (flags & BATADV_MCAST_WANT_ALL_IPV6) ? '6' : '.',\n\t\t   !(flags & BATADV_MCAST_WANT_NO_RTR4) ? \"R4\" : \". \",\n\t\t   !(flags & BATADV_MCAST_WANT_NO_RTR6) ? \"R6\" : \". \");\n}\n\n \nstatic void\nbatadv_mcast_mla_flags_update(struct batadv_priv *bat_priv,\n\t\t\t      struct batadv_mcast_mla_flags *flags)\n{\n\tstruct batadv_tvlv_mcast_data mcast_data;\n\n\tif (!memcmp(flags, &bat_priv->mcast.mla_flags, sizeof(*flags)))\n\t\treturn;\n\n\tbatadv_mcast_bridge_log(bat_priv, flags);\n\tbatadv_mcast_flags_log(bat_priv, flags->tvlv_flags);\n\n\tmcast_data.flags = flags->tvlv_flags;\n\tmemset(mcast_data.reserved, 0, sizeof(mcast_data.reserved));\n\n\tbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_MCAST, 2,\n\t\t\t\t       &mcast_data, sizeof(mcast_data));\n\n\tbat_priv->mcast.mla_flags = *flags;\n}\n\n \nstatic void __batadv_mcast_mla_update(struct batadv_priv *bat_priv)\n{\n\tstruct net_device *soft_iface = bat_priv->soft_iface;\n\tstruct hlist_head mcast_list = HLIST_HEAD_INIT;\n\tstruct batadv_mcast_mla_flags flags;\n\tint ret;\n\n\tflags = batadv_mcast_mla_flags_get(bat_priv);\n\n\tret = batadv_mcast_mla_softif_get(soft_iface, &mcast_list, &flags);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = batadv_mcast_mla_bridge_get(soft_iface, &mcast_list, &flags);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tspin_lock(&bat_priv->mcast.mla_lock);\n\tbatadv_mcast_mla_tt_retract(bat_priv, &mcast_list);\n\tbatadv_mcast_mla_tt_add(bat_priv, &mcast_list);\n\tbatadv_mcast_mla_flags_update(bat_priv, &flags);\n\tspin_unlock(&bat_priv->mcast.mla_lock);\n\nout:\n\tbatadv_mcast_mla_list_free(&mcast_list);\n}\n\n \nstatic void batadv_mcast_mla_update(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work;\n\tstruct batadv_priv_mcast *priv_mcast;\n\tstruct batadv_priv *bat_priv;\n\n\tdelayed_work = to_delayed_work(work);\n\tpriv_mcast = container_of(delayed_work, struct batadv_priv_mcast, work);\n\tbat_priv = container_of(priv_mcast, struct batadv_priv, mcast);\n\n\t__batadv_mcast_mla_update(bat_priv);\n\tbatadv_mcast_start_timer(bat_priv);\n}\n\n \nstatic bool batadv_mcast_is_report_ipv4(struct sk_buff *skb)\n{\n\tif (ip_mc_check_igmp(skb) < 0)\n\t\treturn false;\n\n\tswitch (igmp_hdr(skb)->type) {\n\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int batadv_mcast_forw_mode_check_ipv4(struct batadv_priv *bat_priv,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     bool *is_unsnoopable,\n\t\t\t\t\t     int *is_routable)\n{\n\tstruct iphdr *iphdr;\n\n\t \n\tif (!pskb_may_pull(skb, sizeof(struct ethhdr) + sizeof(*iphdr)))\n\t\treturn -ENOMEM;\n\n\tif (batadv_mcast_is_report_ipv4(skb))\n\t\treturn -EINVAL;\n\n\tiphdr = ip_hdr(skb);\n\n\t \n\tif (ipv4_is_local_multicast(iphdr->daddr))\n\t\t*is_unsnoopable = true;\n\telse\n\t\t*is_routable = ETH_P_IP;\n\n\treturn 0;\n}\n\n \nstatic bool batadv_mcast_is_report_ipv6(struct sk_buff *skb)\n{\n\tif (ipv6_mc_check_mld(skb) < 0)\n\t\treturn false;\n\n\tswitch (icmp6_hdr(skb)->icmp6_type) {\n\tcase ICMPV6_MGM_REPORT:\n\tcase ICMPV6_MLD2_REPORT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int batadv_mcast_forw_mode_check_ipv6(struct batadv_priv *bat_priv,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     bool *is_unsnoopable,\n\t\t\t\t\t     int *is_routable)\n{\n\tstruct ipv6hdr *ip6hdr;\n\n\t \n\tif (!pskb_may_pull(skb, sizeof(struct ethhdr) + sizeof(*ip6hdr)))\n\t\treturn -ENOMEM;\n\n\tif (batadv_mcast_is_report_ipv6(skb))\n\t\treturn -EINVAL;\n\n\tip6hdr = ipv6_hdr(skb);\n\n\tif (IPV6_ADDR_MC_SCOPE(&ip6hdr->daddr) < IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\treturn -EINVAL;\n\n\t \n\tif (ipv6_addr_is_ll_all_nodes(&ip6hdr->daddr))\n\t\t*is_unsnoopable = true;\n\telse if (IPV6_ADDR_MC_SCOPE(&ip6hdr->daddr) > IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\t*is_routable = ETH_P_IPV6;\n\n\treturn 0;\n}\n\n \nstatic int batadv_mcast_forw_mode_check(struct batadv_priv *bat_priv,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tbool *is_unsnoopable,\n\t\t\t\t\tint *is_routable)\n{\n\tstruct ethhdr *ethhdr = eth_hdr(skb);\n\n\tif (!atomic_read(&bat_priv->multicast_mode))\n\t\treturn -EINVAL;\n\n\tswitch (ntohs(ethhdr->h_proto)) {\n\tcase ETH_P_IP:\n\t\treturn batadv_mcast_forw_mode_check_ipv4(bat_priv, skb,\n\t\t\t\t\t\t\t is_unsnoopable,\n\t\t\t\t\t\t\t is_routable);\n\tcase ETH_P_IPV6:\n\t\tif (!IS_ENABLED(CONFIG_IPV6))\n\t\t\treturn -EINVAL;\n\n\t\treturn batadv_mcast_forw_mode_check_ipv6(bat_priv, skb,\n\t\t\t\t\t\t\t is_unsnoopable,\n\t\t\t\t\t\t\t is_routable);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int batadv_mcast_forw_want_all_ip_count(struct batadv_priv *bat_priv,\n\t\t\t\t\t       struct ethhdr *ethhdr)\n{\n\tswitch (ntohs(ethhdr->h_proto)) {\n\tcase ETH_P_IP:\n\t\treturn atomic_read(&bat_priv->mcast.num_want_all_ipv4);\n\tcase ETH_P_IPV6:\n\t\treturn atomic_read(&bat_priv->mcast.num_want_all_ipv6);\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\n \n\nstatic int batadv_mcast_forw_rtr_count(struct batadv_priv *bat_priv,\n\t\t\t\t       int protocol)\n{\n\tswitch (protocol) {\n\tcase ETH_P_IP:\n\t\treturn atomic_read(&bat_priv->mcast.num_want_all_rtr4);\n\tcase ETH_P_IPV6:\n\t\treturn atomic_read(&bat_priv->mcast.num_want_all_rtr6);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nenum batadv_forw_mode\nbatadv_mcast_forw_mode(struct batadv_priv *bat_priv, struct sk_buff *skb,\n\t\t       int *is_routable)\n{\n\tint ret, tt_count, ip_count, unsnoop_count, total_count;\n\tbool is_unsnoopable = false;\n\tstruct ethhdr *ethhdr;\n\tint rtr_count = 0;\n\n\tret = batadv_mcast_forw_mode_check(bat_priv, skb, &is_unsnoopable,\n\t\t\t\t\t   is_routable);\n\tif (ret == -ENOMEM)\n\t\treturn BATADV_FORW_NONE;\n\telse if (ret < 0)\n\t\treturn BATADV_FORW_BCAST;\n\n\tethhdr = eth_hdr(skb);\n\n\ttt_count = batadv_tt_global_hash_count(bat_priv, ethhdr->h_dest,\n\t\t\t\t\t       BATADV_NO_FLAGS);\n\tip_count = batadv_mcast_forw_want_all_ip_count(bat_priv, ethhdr);\n\tunsnoop_count = !is_unsnoopable ? 0 :\n\t\t\tatomic_read(&bat_priv->mcast.num_want_all_unsnoopables);\n\trtr_count = batadv_mcast_forw_rtr_count(bat_priv, *is_routable);\n\n\ttotal_count = tt_count + ip_count + unsnoop_count + rtr_count;\n\n\tif (!total_count)\n\t\treturn BATADV_FORW_NONE;\n\telse if (unsnoop_count)\n\t\treturn BATADV_FORW_BCAST;\n\n\tif (total_count <= atomic_read(&bat_priv->multicast_fanout))\n\t\treturn BATADV_FORW_UCASTS;\n\n\treturn BATADV_FORW_BCAST;\n}\n\n \nstatic int batadv_mcast_forw_send_orig(struct batadv_priv *bat_priv,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       unsigned short vid,\n\t\t\t\t       struct batadv_orig_node *orig_node)\n{\n\t \n\tif (batadv_bla_is_backbone_gw_orig(bat_priv, orig_node->orig, vid)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NET_XMIT_SUCCESS;\n\t}\n\n\treturn batadv_send_skb_unicast(bat_priv, skb, BATADV_UNICAST, 0,\n\t\t\t\t       orig_node, vid);\n}\n\n \nstatic int\nbatadv_mcast_forw_tt(struct batadv_priv *bat_priv, struct sk_buff *skb,\n\t\t     unsigned short vid)\n{\n\tint ret = NET_XMIT_SUCCESS;\n\tstruct sk_buff *newskb;\n\n\tstruct batadv_tt_orig_list_entry *orig_entry;\n\n\tstruct batadv_tt_global_entry *tt_global;\n\tconst u8 *addr = eth_hdr(skb)->h_dest;\n\n\ttt_global = batadv_tt_global_hash_find(bat_priv, addr, vid);\n\tif (!tt_global)\n\t\tgoto out;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(orig_entry, &tt_global->orig_list, list) {\n\t\tnewskb = skb_copy(skb, GFP_ATOMIC);\n\t\tif (!newskb) {\n\t\t\tret = NET_XMIT_DROP;\n\t\t\tbreak;\n\t\t}\n\n\t\tbatadv_mcast_forw_send_orig(bat_priv, newskb, vid,\n\t\t\t\t\t    orig_entry->orig_node);\n\t}\n\trcu_read_unlock();\n\n\tbatadv_tt_global_entry_put(tt_global);\n\nout:\n\treturn ret;\n}\n\n \nstatic int\nbatadv_mcast_forw_want_all_ipv4(struct batadv_priv *bat_priv,\n\t\t\t\tstruct sk_buff *skb, unsigned short vid)\n{\n\tstruct batadv_orig_node *orig_node;\n\tint ret = NET_XMIT_SUCCESS;\n\tstruct sk_buff *newskb;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(orig_node,\n\t\t\t\t &bat_priv->mcast.want_all_ipv4_list,\n\t\t\t\t mcast_want_all_ipv4_node) {\n\t\tnewskb = skb_copy(skb, GFP_ATOMIC);\n\t\tif (!newskb) {\n\t\t\tret = NET_XMIT_DROP;\n\t\t\tbreak;\n\t\t}\n\n\t\tbatadv_mcast_forw_send_orig(bat_priv, newskb, vid, orig_node);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int\nbatadv_mcast_forw_want_all_ipv6(struct batadv_priv *bat_priv,\n\t\t\t\tstruct sk_buff *skb, unsigned short vid)\n{\n\tstruct batadv_orig_node *orig_node;\n\tint ret = NET_XMIT_SUCCESS;\n\tstruct sk_buff *newskb;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(orig_node,\n\t\t\t\t &bat_priv->mcast.want_all_ipv6_list,\n\t\t\t\t mcast_want_all_ipv6_node) {\n\t\tnewskb = skb_copy(skb, GFP_ATOMIC);\n\t\tif (!newskb) {\n\t\t\tret = NET_XMIT_DROP;\n\t\t\tbreak;\n\t\t}\n\n\t\tbatadv_mcast_forw_send_orig(bat_priv, newskb, vid, orig_node);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int\nbatadv_mcast_forw_want_all(struct batadv_priv *bat_priv,\n\t\t\t   struct sk_buff *skb, unsigned short vid)\n{\n\tswitch (ntohs(eth_hdr(skb)->h_proto)) {\n\tcase ETH_P_IP:\n\t\treturn batadv_mcast_forw_want_all_ipv4(bat_priv, skb, vid);\n\tcase ETH_P_IPV6:\n\t\treturn batadv_mcast_forw_want_all_ipv6(bat_priv, skb, vid);\n\tdefault:\n\t\t \n\t\treturn NET_XMIT_DROP;\n\t}\n}\n\n \nstatic int\nbatadv_mcast_forw_want_all_rtr4(struct batadv_priv *bat_priv,\n\t\t\t\tstruct sk_buff *skb, unsigned short vid)\n{\n\tstruct batadv_orig_node *orig_node;\n\tint ret = NET_XMIT_SUCCESS;\n\tstruct sk_buff *newskb;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(orig_node,\n\t\t\t\t &bat_priv->mcast.want_all_rtr4_list,\n\t\t\t\t mcast_want_all_rtr4_node) {\n\t\tnewskb = skb_copy(skb, GFP_ATOMIC);\n\t\tif (!newskb) {\n\t\t\tret = NET_XMIT_DROP;\n\t\t\tbreak;\n\t\t}\n\n\t\tbatadv_mcast_forw_send_orig(bat_priv, newskb, vid, orig_node);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int\nbatadv_mcast_forw_want_all_rtr6(struct batadv_priv *bat_priv,\n\t\t\t\tstruct sk_buff *skb, unsigned short vid)\n{\n\tstruct batadv_orig_node *orig_node;\n\tint ret = NET_XMIT_SUCCESS;\n\tstruct sk_buff *newskb;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(orig_node,\n\t\t\t\t &bat_priv->mcast.want_all_rtr6_list,\n\t\t\t\t mcast_want_all_rtr6_node) {\n\t\tnewskb = skb_copy(skb, GFP_ATOMIC);\n\t\tif (!newskb) {\n\t\t\tret = NET_XMIT_DROP;\n\t\t\tbreak;\n\t\t}\n\n\t\tbatadv_mcast_forw_send_orig(bat_priv, newskb, vid, orig_node);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int\nbatadv_mcast_forw_want_rtr(struct batadv_priv *bat_priv,\n\t\t\t   struct sk_buff *skb, unsigned short vid)\n{\n\tswitch (ntohs(eth_hdr(skb)->h_proto)) {\n\tcase ETH_P_IP:\n\t\treturn batadv_mcast_forw_want_all_rtr4(bat_priv, skb, vid);\n\tcase ETH_P_IPV6:\n\t\treturn batadv_mcast_forw_want_all_rtr6(bat_priv, skb, vid);\n\tdefault:\n\t\t \n\t\treturn NET_XMIT_DROP;\n\t}\n}\n\n \nint batadv_mcast_forw_send(struct batadv_priv *bat_priv, struct sk_buff *skb,\n\t\t\t   unsigned short vid, int is_routable)\n{\n\tint ret;\n\n\tret = batadv_mcast_forw_tt(bat_priv, skb, vid);\n\tif (ret != NET_XMIT_SUCCESS) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tret = batadv_mcast_forw_want_all(bat_priv, skb, vid);\n\tif (ret != NET_XMIT_SUCCESS) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tif (!is_routable)\n\t\tgoto skip_mc_router;\n\n\tret = batadv_mcast_forw_want_rtr(bat_priv, skb, vid);\n\tif (ret != NET_XMIT_SUCCESS) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\nskip_mc_router:\n\tconsume_skb(skb);\n\treturn ret;\n}\n\n \nstatic void batadv_mcast_want_unsnoop_update(struct batadv_priv *bat_priv,\n\t\t\t\t\t     struct batadv_orig_node *orig,\n\t\t\t\t\t     u8 mcast_flags)\n{\n\tstruct hlist_node *node = &orig->mcast_want_all_unsnoopables_node;\n\tstruct hlist_head *head = &bat_priv->mcast.want_all_unsnoopables_list;\n\n\tlockdep_assert_held(&orig->mcast_handler_lock);\n\n\t \n\tif (mcast_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES &&\n\t    !(orig->mcast_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES)) {\n\t\tatomic_inc(&bat_priv->mcast.num_want_all_unsnoopables);\n\n\t\tspin_lock_bh(&bat_priv->mcast.want_lists_lock);\n\t\t \n\t\tWARN_ON(!hlist_unhashed(node));\n\n\t\thlist_add_head_rcu(node, head);\n\t\tspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\n\t \n\t} else if (!(mcast_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES) &&\n\t\t   orig->mcast_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES) {\n\t\tatomic_dec(&bat_priv->mcast.num_want_all_unsnoopables);\n\n\t\tspin_lock_bh(&bat_priv->mcast.want_lists_lock);\n\t\t \n\t\tWARN_ON(hlist_unhashed(node));\n\n\t\thlist_del_init_rcu(node);\n\t\tspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\n\t}\n}\n\n \nstatic void batadv_mcast_want_ipv4_update(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_orig_node *orig,\n\t\t\t\t\t  u8 mcast_flags)\n{\n\tstruct hlist_node *node = &orig->mcast_want_all_ipv4_node;\n\tstruct hlist_head *head = &bat_priv->mcast.want_all_ipv4_list;\n\n\tlockdep_assert_held(&orig->mcast_handler_lock);\n\n\t \n\tif (mcast_flags & BATADV_MCAST_WANT_ALL_IPV4 &&\n\t    !(orig->mcast_flags & BATADV_MCAST_WANT_ALL_IPV4)) {\n\t\tatomic_inc(&bat_priv->mcast.num_want_all_ipv4);\n\n\t\tspin_lock_bh(&bat_priv->mcast.want_lists_lock);\n\t\t \n\t\tWARN_ON(!hlist_unhashed(node));\n\n\t\thlist_add_head_rcu(node, head);\n\t\tspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\n\t \n\t} else if (!(mcast_flags & BATADV_MCAST_WANT_ALL_IPV4) &&\n\t\t   orig->mcast_flags & BATADV_MCAST_WANT_ALL_IPV4) {\n\t\tatomic_dec(&bat_priv->mcast.num_want_all_ipv4);\n\n\t\tspin_lock_bh(&bat_priv->mcast.want_lists_lock);\n\t\t \n\t\tWARN_ON(hlist_unhashed(node));\n\n\t\thlist_del_init_rcu(node);\n\t\tspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\n\t}\n}\n\n \nstatic void batadv_mcast_want_ipv6_update(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_orig_node *orig,\n\t\t\t\t\t  u8 mcast_flags)\n{\n\tstruct hlist_node *node = &orig->mcast_want_all_ipv6_node;\n\tstruct hlist_head *head = &bat_priv->mcast.want_all_ipv6_list;\n\n\tlockdep_assert_held(&orig->mcast_handler_lock);\n\n\t \n\tif (mcast_flags & BATADV_MCAST_WANT_ALL_IPV6 &&\n\t    !(orig->mcast_flags & BATADV_MCAST_WANT_ALL_IPV6)) {\n\t\tatomic_inc(&bat_priv->mcast.num_want_all_ipv6);\n\n\t\tspin_lock_bh(&bat_priv->mcast.want_lists_lock);\n\t\t \n\t\tWARN_ON(!hlist_unhashed(node));\n\n\t\thlist_add_head_rcu(node, head);\n\t\tspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\n\t \n\t} else if (!(mcast_flags & BATADV_MCAST_WANT_ALL_IPV6) &&\n\t\t   orig->mcast_flags & BATADV_MCAST_WANT_ALL_IPV6) {\n\t\tatomic_dec(&bat_priv->mcast.num_want_all_ipv6);\n\n\t\tspin_lock_bh(&bat_priv->mcast.want_lists_lock);\n\t\t \n\t\tWARN_ON(hlist_unhashed(node));\n\n\t\thlist_del_init_rcu(node);\n\t\tspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\n\t}\n}\n\n \nstatic void batadv_mcast_want_rtr4_update(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_orig_node *orig,\n\t\t\t\t\t  u8 mcast_flags)\n{\n\tstruct hlist_node *node = &orig->mcast_want_all_rtr4_node;\n\tstruct hlist_head *head = &bat_priv->mcast.want_all_rtr4_list;\n\n\tlockdep_assert_held(&orig->mcast_handler_lock);\n\n\t \n\tif (!(mcast_flags & BATADV_MCAST_WANT_NO_RTR4) &&\n\t    orig->mcast_flags & BATADV_MCAST_WANT_NO_RTR4) {\n\t\tatomic_inc(&bat_priv->mcast.num_want_all_rtr4);\n\n\t\tspin_lock_bh(&bat_priv->mcast.want_lists_lock);\n\t\t \n\t\tWARN_ON(!hlist_unhashed(node));\n\n\t\thlist_add_head_rcu(node, head);\n\t\tspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\n\t \n\t} else if (mcast_flags & BATADV_MCAST_WANT_NO_RTR4 &&\n\t\t   !(orig->mcast_flags & BATADV_MCAST_WANT_NO_RTR4)) {\n\t\tatomic_dec(&bat_priv->mcast.num_want_all_rtr4);\n\n\t\tspin_lock_bh(&bat_priv->mcast.want_lists_lock);\n\t\t \n\t\tWARN_ON(hlist_unhashed(node));\n\n\t\thlist_del_init_rcu(node);\n\t\tspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\n\t}\n}\n\n \nstatic void batadv_mcast_want_rtr6_update(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_orig_node *orig,\n\t\t\t\t\t  u8 mcast_flags)\n{\n\tstruct hlist_node *node = &orig->mcast_want_all_rtr6_node;\n\tstruct hlist_head *head = &bat_priv->mcast.want_all_rtr6_list;\n\n\tlockdep_assert_held(&orig->mcast_handler_lock);\n\n\t \n\tif (!(mcast_flags & BATADV_MCAST_WANT_NO_RTR6) &&\n\t    orig->mcast_flags & BATADV_MCAST_WANT_NO_RTR6) {\n\t\tatomic_inc(&bat_priv->mcast.num_want_all_rtr6);\n\n\t\tspin_lock_bh(&bat_priv->mcast.want_lists_lock);\n\t\t \n\t\tWARN_ON(!hlist_unhashed(node));\n\n\t\thlist_add_head_rcu(node, head);\n\t\tspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\n\t \n\t} else if (mcast_flags & BATADV_MCAST_WANT_NO_RTR6 &&\n\t\t   !(orig->mcast_flags & BATADV_MCAST_WANT_NO_RTR6)) {\n\t\tatomic_dec(&bat_priv->mcast.num_want_all_rtr6);\n\n\t\tspin_lock_bh(&bat_priv->mcast.want_lists_lock);\n\t\t \n\t\tWARN_ON(hlist_unhashed(node));\n\n\t\thlist_del_init_rcu(node);\n\t\tspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\n\t}\n}\n\n \nstatic u8\nbatadv_mcast_tvlv_flags_get(bool enabled, void *tvlv_value, u16 tvlv_value_len)\n{\n\tu8 mcast_flags = BATADV_NO_FLAGS;\n\n\tif (enabled && tvlv_value && tvlv_value_len >= sizeof(mcast_flags))\n\t\tmcast_flags = *(u8 *)tvlv_value;\n\n\tif (!enabled) {\n\t\tmcast_flags |= BATADV_MCAST_WANT_ALL_IPV4;\n\t\tmcast_flags |= BATADV_MCAST_WANT_ALL_IPV6;\n\t}\n\n\t \n\tif (mcast_flags & BATADV_MCAST_WANT_ALL_IPV4)\n\t\tmcast_flags |= BATADV_MCAST_WANT_NO_RTR4;\n\n\tif (mcast_flags & BATADV_MCAST_WANT_ALL_IPV6)\n\t\tmcast_flags |= BATADV_MCAST_WANT_NO_RTR6;\n\n\treturn mcast_flags;\n}\n\n \nstatic void batadv_mcast_tvlv_ogm_handler(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_orig_node *orig,\n\t\t\t\t\t  u8 flags,\n\t\t\t\t\t  void *tvlv_value,\n\t\t\t\t\t  u16 tvlv_value_len)\n{\n\tbool orig_mcast_enabled = !(flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND);\n\tu8 mcast_flags;\n\n\tmcast_flags = batadv_mcast_tvlv_flags_get(orig_mcast_enabled,\n\t\t\t\t\t\t  tvlv_value, tvlv_value_len);\n\n\tspin_lock_bh(&orig->mcast_handler_lock);\n\n\tif (orig_mcast_enabled &&\n\t    !test_bit(BATADV_ORIG_CAPA_HAS_MCAST, &orig->capabilities)) {\n\t\tset_bit(BATADV_ORIG_CAPA_HAS_MCAST, &orig->capabilities);\n\t} else if (!orig_mcast_enabled &&\n\t\t   test_bit(BATADV_ORIG_CAPA_HAS_MCAST, &orig->capabilities)) {\n\t\tclear_bit(BATADV_ORIG_CAPA_HAS_MCAST, &orig->capabilities);\n\t}\n\n\tset_bit(BATADV_ORIG_CAPA_HAS_MCAST, &orig->capa_initialized);\n\n\tbatadv_mcast_want_unsnoop_update(bat_priv, orig, mcast_flags);\n\tbatadv_mcast_want_ipv4_update(bat_priv, orig, mcast_flags);\n\tbatadv_mcast_want_ipv6_update(bat_priv, orig, mcast_flags);\n\tbatadv_mcast_want_rtr4_update(bat_priv, orig, mcast_flags);\n\tbatadv_mcast_want_rtr6_update(bat_priv, orig, mcast_flags);\n\n\torig->mcast_flags = mcast_flags;\n\tspin_unlock_bh(&orig->mcast_handler_lock);\n}\n\n \nvoid batadv_mcast_init(struct batadv_priv *bat_priv)\n{\n\tbatadv_tvlv_handler_register(bat_priv, batadv_mcast_tvlv_ogm_handler,\n\t\t\t\t     NULL, NULL, BATADV_TVLV_MCAST, 2,\n\t\t\t\t     BATADV_TVLV_HANDLER_OGM_CIFNOTFND);\n\n\tINIT_DELAYED_WORK(&bat_priv->mcast.work, batadv_mcast_mla_update);\n\tbatadv_mcast_start_timer(bat_priv);\n}\n\n \nint batadv_mcast_mesh_info_put(struct sk_buff *msg,\n\t\t\t       struct batadv_priv *bat_priv)\n{\n\tu32 flags = bat_priv->mcast.mla_flags.tvlv_flags;\n\tu32 flags_priv = BATADV_NO_FLAGS;\n\n\tif (bat_priv->mcast.mla_flags.bridged) {\n\t\tflags_priv |= BATADV_MCAST_FLAGS_BRIDGED;\n\n\t\tif (bat_priv->mcast.mla_flags.querier_ipv4.exists)\n\t\t\tflags_priv |= BATADV_MCAST_FLAGS_QUERIER_IPV4_EXISTS;\n\t\tif (bat_priv->mcast.mla_flags.querier_ipv6.exists)\n\t\t\tflags_priv |= BATADV_MCAST_FLAGS_QUERIER_IPV6_EXISTS;\n\t\tif (bat_priv->mcast.mla_flags.querier_ipv4.shadowing)\n\t\t\tflags_priv |= BATADV_MCAST_FLAGS_QUERIER_IPV4_SHADOWING;\n\t\tif (bat_priv->mcast.mla_flags.querier_ipv6.shadowing)\n\t\t\tflags_priv |= BATADV_MCAST_FLAGS_QUERIER_IPV6_SHADOWING;\n\t}\n\n\tif (nla_put_u32(msg, BATADV_ATTR_MCAST_FLAGS, flags) ||\n\t    nla_put_u32(msg, BATADV_ATTR_MCAST_FLAGS_PRIV, flags_priv))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\n \nstatic int\nbatadv_mcast_flags_dump_entry(struct sk_buff *msg, u32 portid,\n\t\t\t      struct netlink_callback *cb,\n\t\t\t      struct batadv_orig_node *orig_node)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, cb->nlh->nlmsg_seq,\n\t\t\t  &batadv_netlink_family, NLM_F_MULTI,\n\t\t\t  BATADV_CMD_GET_MCAST_FLAGS);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,\n\t\t    orig_node->orig)) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (test_bit(BATADV_ORIG_CAPA_HAS_MCAST,\n\t\t     &orig_node->capabilities)) {\n\t\tif (nla_put_u32(msg, BATADV_ATTR_MCAST_FLAGS,\n\t\t\t\torig_node->mcast_flags)) {\n\t\t\tgenlmsg_cancel(msg, hdr);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n}\n\n \nstatic int\nbatadv_mcast_flags_dump_bucket(struct sk_buff *msg, u32 portid,\n\t\t\t       struct netlink_callback *cb,\n\t\t\t       struct batadv_hashtable *hash,\n\t\t\t       unsigned int bucket, long *idx_skip)\n{\n\tstruct batadv_orig_node *orig_node;\n\tlong idx = 0;\n\n\tspin_lock_bh(&hash->list_locks[bucket]);\n\tcb->seq = atomic_read(&hash->generation) << 1 | 1;\n\n\thlist_for_each_entry(orig_node, &hash->table[bucket], hash_entry) {\n\t\tif (!test_bit(BATADV_ORIG_CAPA_HAS_MCAST,\n\t\t\t      &orig_node->capa_initialized))\n\t\t\tcontinue;\n\n\t\tif (idx < *idx_skip)\n\t\t\tgoto skip;\n\n\t\tif (batadv_mcast_flags_dump_entry(msg, portid, cb, orig_node)) {\n\t\t\tspin_unlock_bh(&hash->list_locks[bucket]);\n\t\t\t*idx_skip = idx;\n\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\nskip:\n\t\tidx++;\n\t}\n\tspin_unlock_bh(&hash->list_locks[bucket]);\n\n\treturn 0;\n}\n\n \nstatic int\n__batadv_mcast_flags_dump(struct sk_buff *msg, u32 portid,\n\t\t\t  struct netlink_callback *cb,\n\t\t\t  struct batadv_priv *bat_priv, long *bucket, long *idx)\n{\n\tstruct batadv_hashtable *hash = bat_priv->orig_hash;\n\tlong bucket_tmp = *bucket;\n\tlong idx_tmp = *idx;\n\n\twhile (bucket_tmp < hash->size) {\n\t\tif (batadv_mcast_flags_dump_bucket(msg, portid, cb, hash,\n\t\t\t\t\t\t   bucket_tmp, &idx_tmp))\n\t\t\tbreak;\n\n\t\tbucket_tmp++;\n\t\tidx_tmp = 0;\n\t}\n\n\t*bucket = bucket_tmp;\n\t*idx = idx_tmp;\n\n\treturn msg->len;\n}\n\n \nstatic int\nbatadv_mcast_netlink_get_primary(struct netlink_callback *cb,\n\t\t\t\t struct batadv_hard_iface **primary_if)\n{\n\tstruct batadv_hard_iface *hard_iface = NULL;\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct net_device *soft_iface;\n\tstruct batadv_priv *bat_priv;\n\tint ifindex;\n\tint ret = 0;\n\n\tifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);\n\tif (!ifindex)\n\t\treturn -EINVAL;\n\n\tsoft_iface = dev_get_by_index(net, ifindex);\n\tif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tbat_priv = netdev_priv(soft_iface);\n\n\thard_iface = batadv_primary_if_get_selected(bat_priv);\n\tif (!hard_iface || hard_iface->if_status != BATADV_IF_ACTIVE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\nout:\n\tdev_put(soft_iface);\n\n\tif (!ret && primary_if)\n\t\t*primary_if = hard_iface;\n\telse\n\t\tbatadv_hardif_put(hard_iface);\n\n\treturn ret;\n}\n\n \nint batadv_mcast_flags_dump(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tint portid = NETLINK_CB(cb->skb).portid;\n\tstruct batadv_priv *bat_priv;\n\tlong *bucket = &cb->args[0];\n\tlong *idx = &cb->args[1];\n\tint ret;\n\n\tret = batadv_mcast_netlink_get_primary(cb, &primary_if);\n\tif (ret)\n\t\treturn ret;\n\n\tbat_priv = netdev_priv(primary_if->soft_iface);\n\tret = __batadv_mcast_flags_dump(msg, portid, cb, bat_priv, bucket, idx);\n\n\tbatadv_hardif_put(primary_if);\n\treturn ret;\n}\n\n \nvoid batadv_mcast_free(struct batadv_priv *bat_priv)\n{\n\tcancel_delayed_work_sync(&bat_priv->mcast.work);\n\n\tbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_MCAST, 2);\n\tbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_MCAST, 2);\n\n\t \n\tbatadv_mcast_mla_tt_retract(bat_priv, NULL);\n}\n\n \nvoid batadv_mcast_purge_orig(struct batadv_orig_node *orig)\n{\n\tstruct batadv_priv *bat_priv = orig->bat_priv;\n\n\tspin_lock_bh(&orig->mcast_handler_lock);\n\n\tbatadv_mcast_want_unsnoop_update(bat_priv, orig, BATADV_NO_FLAGS);\n\tbatadv_mcast_want_ipv4_update(bat_priv, orig, BATADV_NO_FLAGS);\n\tbatadv_mcast_want_ipv6_update(bat_priv, orig, BATADV_NO_FLAGS);\n\tbatadv_mcast_want_rtr4_update(bat_priv, orig,\n\t\t\t\t      BATADV_MCAST_WANT_NO_RTR4);\n\tbatadv_mcast_want_rtr6_update(bat_priv, orig,\n\t\t\t\t      BATADV_MCAST_WANT_NO_RTR6);\n\n\tspin_unlock_bh(&orig->mcast_handler_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}