{
  "module_name": "routing.c",
  "hash_id": "1b2fa0b1376858f548dbb9c6d22edd76c08d0f57df27eeb1f09ee3b0414530f6",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/routing.c",
  "human_readable_source": "\n \n\n#include \"routing.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/byteorder/generic.h>\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/netdevice.h>\n#include <linux/printk.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <uapi/linux/batadv_packet.h>\n\n#include \"bitarray.h\"\n#include \"bridge_loop_avoidance.h\"\n#include \"distributed-arp-table.h\"\n#include \"fragmentation.h\"\n#include \"hard-interface.h\"\n#include \"log.h\"\n#include \"network-coding.h\"\n#include \"originator.h\"\n#include \"send.h\"\n#include \"soft-interface.h\"\n#include \"tp_meter.h\"\n#include \"translation-table.h\"\n#include \"tvlv.h\"\n\nstatic int batadv_route_unicast_packet(struct sk_buff *skb,\n\t\t\t\t       struct batadv_hard_iface *recv_if);\n\n \nstatic void _batadv_update_route(struct batadv_priv *bat_priv,\n\t\t\t\t struct batadv_orig_node *orig_node,\n\t\t\t\t struct batadv_hard_iface *recv_if,\n\t\t\t\t struct batadv_neigh_node *neigh_node)\n{\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tstruct batadv_neigh_node *curr_router;\n\n\torig_ifinfo = batadv_orig_ifinfo_get(orig_node, recv_if);\n\tif (!orig_ifinfo)\n\t\treturn;\n\n\tspin_lock_bh(&orig_node->neigh_list_lock);\n\t \n\n\t \n\tif (neigh_node)\n\t\tkref_get(&neigh_node->refcount);\n\n\tcurr_router = rcu_replace_pointer(orig_ifinfo->router, neigh_node,\n\t\t\t\t\t  true);\n\tspin_unlock_bh(&orig_node->neigh_list_lock);\n\tbatadv_orig_ifinfo_put(orig_ifinfo);\n\n\t \n\tif (curr_router && !neigh_node) {\n\t\tbatadv_dbg(BATADV_DBG_ROUTES, bat_priv,\n\t\t\t   \"Deleting route towards: %pM\\n\", orig_node->orig);\n\t\tbatadv_tt_global_del_orig(bat_priv, orig_node, -1,\n\t\t\t\t\t  \"Deleted route towards originator\");\n\n\t \n\t} else if (!curr_router && neigh_node) {\n\t\tbatadv_dbg(BATADV_DBG_ROUTES, bat_priv,\n\t\t\t   \"Adding route towards: %pM (via %pM)\\n\",\n\t\t\t   orig_node->orig, neigh_node->addr);\n\t \n\t} else if (neigh_node && curr_router) {\n\t\tbatadv_dbg(BATADV_DBG_ROUTES, bat_priv,\n\t\t\t   \"Changing route towards: %pM (now via %pM - was via %pM)\\n\",\n\t\t\t   orig_node->orig, neigh_node->addr,\n\t\t\t   curr_router->addr);\n\t}\n\n\t \n\tbatadv_neigh_node_put(curr_router);\n}\n\n \nvoid batadv_update_route(struct batadv_priv *bat_priv,\n\t\t\t struct batadv_orig_node *orig_node,\n\t\t\t struct batadv_hard_iface *recv_if,\n\t\t\t struct batadv_neigh_node *neigh_node)\n{\n\tstruct batadv_neigh_node *router = NULL;\n\n\tif (!orig_node)\n\t\tgoto out;\n\n\trouter = batadv_orig_router_get(orig_node, recv_if);\n\n\tif (router != neigh_node)\n\t\t_batadv_update_route(bat_priv, orig_node, recv_if, neigh_node);\n\nout:\n\tbatadv_neigh_node_put(router);\n}\n\n \nbool batadv_window_protected(struct batadv_priv *bat_priv, s32 seq_num_diff,\n\t\t\t     s32 seq_old_max_diff, unsigned long *last_reset,\n\t\t\t     bool *protection_started)\n{\n\tif (seq_num_diff <= -seq_old_max_diff ||\n\t    seq_num_diff >= BATADV_EXPECTED_SEQNO_RANGE) {\n\t\tif (!batadv_has_timed_out(*last_reset,\n\t\t\t\t\t  BATADV_RESET_PROTECTION_MS))\n\t\t\treturn true;\n\n\t\t*last_reset = jiffies;\n\t\tif (protection_started)\n\t\t\t*protection_started = true;\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"old packet received, start protection\\n\");\n\t}\n\n\treturn false;\n}\n\n \nbool batadv_check_management_packet(struct sk_buff *skb,\n\t\t\t\t    struct batadv_hard_iface *hard_iface,\n\t\t\t\t    int header_len)\n{\n\tstruct ethhdr *ethhdr;\n\n\t \n\tif (unlikely(!pskb_may_pull(skb, header_len)))\n\t\treturn false;\n\n\tethhdr = eth_hdr(skb);\n\n\t \n\tif (!is_broadcast_ether_addr(ethhdr->h_dest))\n\t\treturn false;\n\n\t \n\tif (!is_valid_ether_addr(ethhdr->h_source))\n\t\treturn false;\n\n\t \n\tif (skb_cow(skb, 0) < 0)\n\t\treturn false;\n\n\t \n\tif (skb_linearize(skb) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int batadv_recv_my_icmp_packet(struct batadv_priv *bat_priv,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_orig_node *orig_node = NULL;\n\tstruct batadv_icmp_header *icmph;\n\tint res, ret = NET_RX_DROP;\n\n\ticmph = (struct batadv_icmp_header *)skb->data;\n\n\tswitch (icmph->msg_type) {\n\tcase BATADV_ECHO_REQUEST:\n\t\t \n\t\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\t\tif (!primary_if)\n\t\t\tgoto out;\n\n\t\t \n\t\torig_node = batadv_orig_hash_find(bat_priv, icmph->orig);\n\t\tif (!orig_node)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (skb_cow(skb, ETH_HLEN) < 0)\n\t\t\tgoto out;\n\n\t\ticmph = (struct batadv_icmp_header *)skb->data;\n\n\t\tether_addr_copy(icmph->dst, icmph->orig);\n\t\tether_addr_copy(icmph->orig, primary_if->net_dev->dev_addr);\n\t\ticmph->msg_type = BATADV_ECHO_REPLY;\n\t\ticmph->ttl = BATADV_TTL;\n\n\t\tres = batadv_send_skb_to_orig(skb, orig_node, NULL);\n\t\tif (res == NET_XMIT_SUCCESS)\n\t\t\tret = NET_RX_SUCCESS;\n\n\t\t \n\t\tskb = NULL;\n\t\tbreak;\n\tcase BATADV_TP:\n\t\tif (!pskb_may_pull(skb, sizeof(struct batadv_icmp_tp_packet)))\n\t\t\tgoto out;\n\n\t\tbatadv_tp_meter_recv(bat_priv, skb);\n\t\tret = NET_RX_SUCCESS;\n\t\t \n\t\tskb = NULL;\n\t\tgoto out;\n\tdefault:\n\t\t \n\t\tgoto out;\n\t}\nout:\n\tbatadv_hardif_put(primary_if);\n\tbatadv_orig_node_put(orig_node);\n\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic int batadv_recv_icmp_ttl_exceeded(struct batadv_priv *bat_priv,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_orig_node *orig_node = NULL;\n\tstruct batadv_icmp_packet *icmp_packet;\n\tint res, ret = NET_RX_DROP;\n\n\ticmp_packet = (struct batadv_icmp_packet *)skb->data;\n\n\t \n\tif (icmp_packet->msg_type != BATADV_ECHO_REQUEST) {\n\t\tpr_debug(\"Warning - can't forward icmp packet from %pM to %pM: ttl exceeded\\n\",\n\t\t\t icmp_packet->orig, icmp_packet->dst);\n\t\tgoto out;\n\t}\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\tgoto out;\n\n\t \n\torig_node = batadv_orig_hash_find(bat_priv, icmp_packet->orig);\n\tif (!orig_node)\n\t\tgoto out;\n\n\t \n\tif (skb_cow(skb, ETH_HLEN) < 0)\n\t\tgoto out;\n\n\ticmp_packet = (struct batadv_icmp_packet *)skb->data;\n\n\tether_addr_copy(icmp_packet->dst, icmp_packet->orig);\n\tether_addr_copy(icmp_packet->orig, primary_if->net_dev->dev_addr);\n\ticmp_packet->msg_type = BATADV_TTL_EXCEEDED;\n\ticmp_packet->ttl = BATADV_TTL;\n\n\tres = batadv_send_skb_to_orig(skb, orig_node, NULL);\n\tif (res == NET_RX_SUCCESS)\n\t\tret = NET_XMIT_SUCCESS;\n\n\t \n\tskb = NULL;\n\nout:\n\tbatadv_hardif_put(primary_if);\n\tbatadv_orig_node_put(orig_node);\n\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\n \nint batadv_recv_icmp_packet(struct sk_buff *skb,\n\t\t\t    struct batadv_hard_iface *recv_if)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tstruct batadv_icmp_header *icmph;\n\tstruct batadv_icmp_packet_rr *icmp_packet_rr;\n\tstruct ethhdr *ethhdr;\n\tstruct batadv_orig_node *orig_node = NULL;\n\tint hdr_size = sizeof(struct batadv_icmp_header);\n\tint res, ret = NET_RX_DROP;\n\n\t \n\tif (unlikely(!pskb_may_pull(skb, hdr_size)))\n\t\tgoto free_skb;\n\n\tethhdr = eth_hdr(skb);\n\n\t \n\tif (!is_valid_ether_addr(ethhdr->h_dest))\n\t\tgoto free_skb;\n\n\t \n\tif (is_multicast_ether_addr(ethhdr->h_source))\n\t\tgoto free_skb;\n\n\t \n\tif (!batadv_is_my_mac(bat_priv, ethhdr->h_dest))\n\t\tgoto free_skb;\n\n\ticmph = (struct batadv_icmp_header *)skb->data;\n\n\t \n\tif ((icmph->msg_type == BATADV_ECHO_REPLY ||\n\t     icmph->msg_type == BATADV_ECHO_REQUEST) &&\n\t    skb->len >= sizeof(struct batadv_icmp_packet_rr)) {\n\t\tif (skb_linearize(skb) < 0)\n\t\t\tgoto free_skb;\n\n\t\t \n\t\tif (skb_cow(skb, ETH_HLEN) < 0)\n\t\t\tgoto free_skb;\n\n\t\tethhdr = eth_hdr(skb);\n\t\ticmph = (struct batadv_icmp_header *)skb->data;\n\t\ticmp_packet_rr = (struct batadv_icmp_packet_rr *)icmph;\n\t\tif (icmp_packet_rr->rr_cur >= BATADV_RR_LEN)\n\t\t\tgoto free_skb;\n\n\t\tether_addr_copy(icmp_packet_rr->rr[icmp_packet_rr->rr_cur],\n\t\t\t\tethhdr->h_dest);\n\t\ticmp_packet_rr->rr_cur++;\n\t}\n\n\t \n\tif (batadv_is_my_mac(bat_priv, icmph->dst))\n\t\treturn batadv_recv_my_icmp_packet(bat_priv, skb);\n\n\t \n\tif (icmph->ttl < 2)\n\t\treturn batadv_recv_icmp_ttl_exceeded(bat_priv, skb);\n\n\t \n\torig_node = batadv_orig_hash_find(bat_priv, icmph->dst);\n\tif (!orig_node)\n\t\tgoto free_skb;\n\n\t \n\tif (skb_cow(skb, ETH_HLEN) < 0)\n\t\tgoto put_orig_node;\n\n\ticmph = (struct batadv_icmp_header *)skb->data;\n\n\t \n\ticmph->ttl--;\n\n\t \n\tres = batadv_send_skb_to_orig(skb, orig_node, recv_if);\n\tif (res == NET_XMIT_SUCCESS)\n\t\tret = NET_RX_SUCCESS;\n\n\t \n\tskb = NULL;\n\nput_orig_node:\n\tbatadv_orig_node_put(orig_node);\nfree_skb:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\n \nstatic int batadv_check_unicast_packet(struct batadv_priv *bat_priv,\n\t\t\t\t       struct sk_buff *skb, int hdr_size)\n{\n\tstruct ethhdr *ethhdr;\n\n\t \n\tif (unlikely(!pskb_may_pull(skb, hdr_size)))\n\t\treturn -ENODATA;\n\n\tethhdr = eth_hdr(skb);\n\n\t \n\tif (!is_valid_ether_addr(ethhdr->h_dest))\n\t\treturn -EBADR;\n\n\t \n\tif (is_multicast_ether_addr(ethhdr->h_source))\n\t\treturn -EBADR;\n\n\t \n\tif (!batadv_is_my_mac(bat_priv, ethhdr->h_dest))\n\t\treturn -EREMOTE;\n\n\treturn 0;\n}\n\n \nstatic struct batadv_orig_ifinfo *\nbatadv_last_bonding_get(struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_orig_ifinfo *last_bonding_candidate;\n\n\tspin_lock_bh(&orig_node->neigh_list_lock);\n\tlast_bonding_candidate = orig_node->last_bonding_candidate;\n\n\tif (last_bonding_candidate)\n\t\tkref_get(&last_bonding_candidate->refcount);\n\tspin_unlock_bh(&orig_node->neigh_list_lock);\n\n\treturn last_bonding_candidate;\n}\n\n \nstatic void\nbatadv_last_bonding_replace(struct batadv_orig_node *orig_node,\n\t\t\t    struct batadv_orig_ifinfo *new_candidate)\n{\n\tstruct batadv_orig_ifinfo *old_candidate;\n\n\tspin_lock_bh(&orig_node->neigh_list_lock);\n\told_candidate = orig_node->last_bonding_candidate;\n\n\tif (new_candidate)\n\t\tkref_get(&new_candidate->refcount);\n\torig_node->last_bonding_candidate = new_candidate;\n\tspin_unlock_bh(&orig_node->neigh_list_lock);\n\n\tbatadv_orig_ifinfo_put(old_candidate);\n}\n\n \nstruct batadv_neigh_node *\nbatadv_find_router(struct batadv_priv *bat_priv,\n\t\t   struct batadv_orig_node *orig_node,\n\t\t   struct batadv_hard_iface *recv_if)\n{\n\tstruct batadv_algo_ops *bao = bat_priv->algo_ops;\n\tstruct batadv_neigh_node *first_candidate_router = NULL;\n\tstruct batadv_neigh_node *next_candidate_router = NULL;\n\tstruct batadv_neigh_node *router, *cand_router = NULL;\n\tstruct batadv_neigh_node *last_cand_router = NULL;\n\tstruct batadv_orig_ifinfo *cand, *first_candidate = NULL;\n\tstruct batadv_orig_ifinfo *next_candidate = NULL;\n\tstruct batadv_orig_ifinfo *last_candidate;\n\tbool last_candidate_found = false;\n\n\tif (!orig_node)\n\t\treturn NULL;\n\n\trouter = batadv_orig_router_get(orig_node, recv_if);\n\n\tif (!router)\n\t\treturn router;\n\n\t \n\tif (!(recv_if == BATADV_IF_DEFAULT && atomic_read(&bat_priv->bonding)))\n\t\treturn router;\n\n\t \n\trcu_read_lock();\n\tlast_candidate = batadv_last_bonding_get(orig_node);\n\tif (last_candidate)\n\t\tlast_cand_router = rcu_dereference(last_candidate->router);\n\n\thlist_for_each_entry_rcu(cand, &orig_node->ifinfo_list, list) {\n\t\t \n\t\tif (!kref_get_unless_zero(&cand->refcount))\n\t\t\tcontinue;\n\n\t\tcand_router = rcu_dereference(cand->router);\n\t\tif (!cand_router)\n\t\t\tgoto next;\n\n\t\tif (!kref_get_unless_zero(&cand_router->refcount)) {\n\t\t\tcand_router = NULL;\n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\tif (!bao->neigh.is_similar_or_better(cand_router,\n\t\t\t\t\t\t     cand->if_outgoing, router,\n\t\t\t\t\t\t     recv_if))\n\t\t\tgoto next;\n\n\t\t \n\t\tif (last_cand_router == cand_router)\n\t\t\tgoto next;\n\n\t\t \n\t\tif (!first_candidate) {\n\t\t\tkref_get(&cand_router->refcount);\n\t\t\tkref_get(&cand->refcount);\n\t\t\tfirst_candidate = cand;\n\t\t\tfirst_candidate_router = cand_router;\n\t\t}\n\n\t\t \n\t\tif (!last_candidate || last_candidate_found) {\n\t\t\tnext_candidate = cand;\n\t\t\tnext_candidate_router = cand_router;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (last_candidate == cand)\n\t\t\tlast_candidate_found = true;\nnext:\n\t\t \n\t\tif (cand_router) {\n\t\t\tbatadv_neigh_node_put(cand_router);\n\t\t\tcand_router = NULL;\n\t\t}\n\t\tbatadv_orig_ifinfo_put(cand);\n\t}\n\trcu_read_unlock();\n\n\t \n\tif (next_candidate) {\n\t\tbatadv_neigh_node_put(router);\n\n\t\tkref_get(&next_candidate_router->refcount);\n\t\trouter = next_candidate_router;\n\t\tbatadv_last_bonding_replace(orig_node, next_candidate);\n\t} else if (first_candidate) {\n\t\tbatadv_neigh_node_put(router);\n\n\t\tkref_get(&first_candidate_router->refcount);\n\t\trouter = first_candidate_router;\n\t\tbatadv_last_bonding_replace(orig_node, first_candidate);\n\t} else {\n\t\tbatadv_last_bonding_replace(orig_node, NULL);\n\t}\n\n\t \n\tif (first_candidate) {\n\t\tbatadv_neigh_node_put(first_candidate_router);\n\t\tbatadv_orig_ifinfo_put(first_candidate);\n\t}\n\n\tif (next_candidate) {\n\t\tbatadv_neigh_node_put(next_candidate_router);\n\t\tbatadv_orig_ifinfo_put(next_candidate);\n\t}\n\n\tbatadv_orig_ifinfo_put(last_candidate);\n\n\treturn router;\n}\n\nstatic int batadv_route_unicast_packet(struct sk_buff *skb,\n\t\t\t\t       struct batadv_hard_iface *recv_if)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tstruct batadv_orig_node *orig_node = NULL;\n\tstruct batadv_unicast_packet *unicast_packet;\n\tstruct ethhdr *ethhdr = eth_hdr(skb);\n\tint res, hdr_len, ret = NET_RX_DROP;\n\tunsigned int len;\n\n\tunicast_packet = (struct batadv_unicast_packet *)skb->data;\n\n\t \n\tif (unicast_packet->ttl < 2) {\n\t\tpr_debug(\"Warning - can't forward unicast packet from %pM to %pM: ttl exceeded\\n\",\n\t\t\t ethhdr->h_source, unicast_packet->dest);\n\t\tgoto free_skb;\n\t}\n\n\t \n\torig_node = batadv_orig_hash_find(bat_priv, unicast_packet->dest);\n\n\tif (!orig_node)\n\t\tgoto free_skb;\n\n\t \n\tif (skb_cow(skb, ETH_HLEN) < 0)\n\t\tgoto put_orig_node;\n\n\t \n\tunicast_packet = (struct batadv_unicast_packet *)skb->data;\n\tunicast_packet->ttl--;\n\n\tswitch (unicast_packet->packet_type) {\n\tcase BATADV_UNICAST_4ADDR:\n\t\thdr_len = sizeof(struct batadv_unicast_4addr_packet);\n\t\tbreak;\n\tcase BATADV_UNICAST:\n\t\thdr_len = sizeof(struct batadv_unicast_packet);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\thdr_len = -1;\n\t\tbreak;\n\t}\n\n\tif (hdr_len > 0)\n\t\tbatadv_skb_set_priority(skb, hdr_len);\n\n\tlen = skb->len;\n\tres = batadv_send_skb_to_orig(skb, orig_node, recv_if);\n\n\t \n\tif (res == NET_XMIT_SUCCESS) {\n\t\tret = NET_RX_SUCCESS;\n\t\t \n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_FORWARD);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_FORWARD_BYTES,\n\t\t\t\t   len + ETH_HLEN);\n\t}\n\n\t \n\tskb = NULL;\n\nput_orig_node:\n\tbatadv_orig_node_put(orig_node);\nfree_skb:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\n \nstatic bool\nbatadv_reroute_unicast_packet(struct batadv_priv *bat_priv, struct sk_buff *skb,\n\t\t\t      struct batadv_unicast_packet *unicast_packet,\n\t\t\t      u8 *dst_addr, unsigned short vid)\n{\n\tstruct batadv_orig_node *orig_node = NULL;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tbool ret = false;\n\tconst u8 *orig_addr;\n\tu8 orig_ttvn;\n\n\tif (batadv_is_my_client(bat_priv, dst_addr, vid)) {\n\t\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\t\tif (!primary_if)\n\t\t\tgoto out;\n\t\torig_addr = primary_if->net_dev->dev_addr;\n\t\torig_ttvn = (u8)atomic_read(&bat_priv->tt.vn);\n\t} else {\n\t\torig_node = batadv_transtable_search(bat_priv, NULL, dst_addr,\n\t\t\t\t\t\t     vid);\n\t\tif (!orig_node)\n\t\t\tgoto out;\n\n\t\tif (batadv_compare_eth(orig_node->orig, unicast_packet->dest))\n\t\t\tgoto out;\n\n\t\torig_addr = orig_node->orig;\n\t\torig_ttvn = (u8)atomic_read(&orig_node->last_ttvn);\n\t}\n\n\t \n\tskb_postpull_rcsum(skb, unicast_packet, sizeof(*unicast_packet));\n\tether_addr_copy(unicast_packet->dest, orig_addr);\n\tunicast_packet->ttvn = orig_ttvn;\n\tskb_postpush_rcsum(skb, unicast_packet, sizeof(*unicast_packet));\n\n\tret = true;\nout:\n\tbatadv_hardif_put(primary_if);\n\tbatadv_orig_node_put(orig_node);\n\n\treturn ret;\n}\n\nstatic bool batadv_check_unicast_ttvn(struct batadv_priv *bat_priv,\n\t\t\t\t      struct sk_buff *skb, int hdr_len)\n{\n\tstruct batadv_unicast_packet *unicast_packet;\n\tstruct batadv_hard_iface *primary_if;\n\tstruct batadv_orig_node *orig_node;\n\tu8 curr_ttvn, old_ttvn;\n\tstruct ethhdr *ethhdr;\n\tunsigned short vid;\n\tint is_old_ttvn;\n\n\t \n\tif (!pskb_may_pull(skb, hdr_len + ETH_HLEN))\n\t\treturn false;\n\n\t \n\tif (skb_cow(skb, sizeof(*unicast_packet)) < 0)\n\t\treturn false;\n\n\tunicast_packet = (struct batadv_unicast_packet *)skb->data;\n\tvid = batadv_get_vid(skb, hdr_len);\n\tethhdr = (struct ethhdr *)(skb->data + hdr_len);\n\n\t \n\tif (is_multicast_ether_addr(ethhdr->h_dest))\n\t\treturn true;\n\n\t \n\tif (batadv_tt_local_client_is_roaming(bat_priv, ethhdr->h_dest, vid)) {\n\t\tif (batadv_reroute_unicast_packet(bat_priv, skb, unicast_packet,\n\t\t\t\t\t\t  ethhdr->h_dest, vid))\n\t\t\tbatadv_dbg_ratelimited(BATADV_DBG_TT,\n\t\t\t\t\t       bat_priv,\n\t\t\t\t\t       \"Rerouting unicast packet to %pM (dst=%pM): Local Roaming\\n\",\n\t\t\t\t\t       unicast_packet->dest,\n\t\t\t\t\t       ethhdr->h_dest);\n\t\t \n\t\treturn true;\n\t}\n\n\t \n\tcurr_ttvn = (u8)atomic_read(&bat_priv->tt.vn);\n\tif (!batadv_is_my_mac(bat_priv, unicast_packet->dest)) {\n\t\torig_node = batadv_orig_hash_find(bat_priv,\n\t\t\t\t\t\t  unicast_packet->dest);\n\t\t \n\t\tif (!orig_node)\n\t\t\treturn false;\n\n\t\tcurr_ttvn = (u8)atomic_read(&orig_node->last_ttvn);\n\t\tbatadv_orig_node_put(orig_node);\n\t}\n\n\t \n\tis_old_ttvn = batadv_seq_before(unicast_packet->ttvn, curr_ttvn);\n\tif (!is_old_ttvn)\n\t\treturn true;\n\n\told_ttvn = unicast_packet->ttvn;\n\t \n\tif (batadv_reroute_unicast_packet(bat_priv, skb, unicast_packet,\n\t\t\t\t\t  ethhdr->h_dest, vid)) {\n\t\tbatadv_dbg_ratelimited(BATADV_DBG_TT, bat_priv,\n\t\t\t\t       \"Rerouting unicast packet to %pM (dst=%pM): TTVN mismatch old_ttvn=%u new_ttvn=%u\\n\",\n\t\t\t\t       unicast_packet->dest, ethhdr->h_dest,\n\t\t\t\t       old_ttvn, curr_ttvn);\n\t\treturn true;\n\t}\n\n\t \n\tif (!batadv_is_my_client(bat_priv, ethhdr->h_dest, vid))\n\t\treturn false;\n\n\t \n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\treturn false;\n\n\t \n\tskb_postpull_rcsum(skb, unicast_packet, sizeof(*unicast_packet));\n\tether_addr_copy(unicast_packet->dest, primary_if->net_dev->dev_addr);\n\tunicast_packet->ttvn = curr_ttvn;\n\tskb_postpush_rcsum(skb, unicast_packet, sizeof(*unicast_packet));\n\n\tbatadv_hardif_put(primary_if);\n\n\treturn true;\n}\n\n \nint batadv_recv_unhandled_unicast_packet(struct sk_buff *skb,\n\t\t\t\t\t struct batadv_hard_iface *recv_if)\n{\n\tstruct batadv_unicast_packet *unicast_packet;\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tint check, hdr_size = sizeof(*unicast_packet);\n\n\tcheck = batadv_check_unicast_packet(bat_priv, skb, hdr_size);\n\tif (check < 0)\n\t\tgoto free_skb;\n\n\t \n\tunicast_packet = (struct batadv_unicast_packet *)skb->data;\n\tif (batadv_is_my_mac(bat_priv, unicast_packet->dest))\n\t\tgoto free_skb;\n\n\treturn batadv_route_unicast_packet(skb, recv_if);\n\nfree_skb:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\n \nint batadv_recv_unicast_packet(struct sk_buff *skb,\n\t\t\t       struct batadv_hard_iface *recv_if)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tstruct batadv_unicast_packet *unicast_packet;\n\tstruct batadv_unicast_4addr_packet *unicast_4addr_packet;\n\tu8 *orig_addr, *orig_addr_gw;\n\tstruct batadv_orig_node *orig_node = NULL, *orig_node_gw = NULL;\n\tint check, hdr_size = sizeof(*unicast_packet);\n\tenum batadv_subtype subtype;\n\tint ret = NET_RX_DROP;\n\tbool is4addr, is_gw;\n\n\tunicast_packet = (struct batadv_unicast_packet *)skb->data;\n\tis4addr = unicast_packet->packet_type == BATADV_UNICAST_4ADDR;\n\t \n\tif (is4addr)\n\t\thdr_size = sizeof(*unicast_4addr_packet);\n\n\t \n\tcheck = batadv_check_unicast_packet(bat_priv, skb, hdr_size);\n\n\t \n\tif (check == -EREMOTE)\n\t\tbatadv_nc_skb_store_sniffed_unicast(bat_priv, skb);\n\n\tif (check < 0)\n\t\tgoto free_skb;\n\tif (!batadv_check_unicast_ttvn(bat_priv, skb, hdr_size))\n\t\tgoto free_skb;\n\n\tunicast_packet = (struct batadv_unicast_packet *)skb->data;\n\n\t \n\tif (batadv_is_my_mac(bat_priv, unicast_packet->dest)) {\n\t\t \n\t\torig_addr_gw = eth_hdr(skb)->h_source;\n\t\torig_node_gw = batadv_orig_hash_find(bat_priv, orig_addr_gw);\n\t\tif (orig_node_gw) {\n\t\t\tis_gw = batadv_bla_is_backbone_gw(skb, orig_node_gw,\n\t\t\t\t\t\t\t  hdr_size);\n\t\t\tbatadv_orig_node_put(orig_node_gw);\n\t\t\tif (is_gw) {\n\t\t\t\tbatadv_dbg(BATADV_DBG_BLA, bat_priv,\n\t\t\t\t\t   \"%s(): Dropped unicast pkt received from another backbone gw %pM.\\n\",\n\t\t\t\t\t   __func__, orig_addr_gw);\n\t\t\t\tgoto free_skb;\n\t\t\t}\n\t\t}\n\n\t\tif (is4addr) {\n\t\t\tunicast_4addr_packet =\n\t\t\t\t(struct batadv_unicast_4addr_packet *)skb->data;\n\t\t\tsubtype = unicast_4addr_packet->subtype;\n\t\t\tbatadv_dat_inc_counter(bat_priv, subtype);\n\n\t\t\t \n\t\t\tif (subtype == BATADV_P_DATA) {\n\t\t\t\torig_addr = unicast_4addr_packet->src;\n\t\t\t\torig_node = batadv_orig_hash_find(bat_priv,\n\t\t\t\t\t\t\t\t  orig_addr);\n\t\t\t}\n\t\t}\n\n\t\tif (batadv_dat_snoop_incoming_arp_request(bat_priv, skb,\n\t\t\t\t\t\t\t  hdr_size))\n\t\t\tgoto rx_success;\n\t\tif (batadv_dat_snoop_incoming_arp_reply(bat_priv, skb,\n\t\t\t\t\t\t\thdr_size))\n\t\t\tgoto rx_success;\n\n\t\tbatadv_dat_snoop_incoming_dhcp_ack(bat_priv, skb, hdr_size);\n\n\t\tbatadv_interface_rx(recv_if->soft_iface, skb, hdr_size,\n\t\t\t\t    orig_node);\n\nrx_success:\n\t\tbatadv_orig_node_put(orig_node);\n\n\t\treturn NET_RX_SUCCESS;\n\t}\n\n\tret = batadv_route_unicast_packet(skb, recv_if);\n\t \n\tskb = NULL;\n\nfree_skb:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\n \nint batadv_recv_unicast_tvlv(struct sk_buff *skb,\n\t\t\t     struct batadv_hard_iface *recv_if)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tstruct batadv_unicast_tvlv_packet *unicast_tvlv_packet;\n\tunsigned char *tvlv_buff;\n\tu16 tvlv_buff_len;\n\tint hdr_size = sizeof(*unicast_tvlv_packet);\n\tint ret = NET_RX_DROP;\n\n\tif (batadv_check_unicast_packet(bat_priv, skb, hdr_size) < 0)\n\t\tgoto free_skb;\n\n\t \n\tif (skb_cow(skb, hdr_size) < 0)\n\t\tgoto free_skb;\n\n\t \n\tif (skb_linearize(skb) < 0)\n\t\tgoto free_skb;\n\n\tunicast_tvlv_packet = (struct batadv_unicast_tvlv_packet *)skb->data;\n\n\ttvlv_buff = (unsigned char *)(skb->data + hdr_size);\n\ttvlv_buff_len = ntohs(unicast_tvlv_packet->tvlv_len);\n\n\tif (tvlv_buff_len > skb->len - hdr_size)\n\t\tgoto free_skb;\n\n\tret = batadv_tvlv_containers_process(bat_priv, BATADV_UNICAST_TVLV,\n\t\t\t\t\t     NULL, skb, tvlv_buff,\n\t\t\t\t\t     tvlv_buff_len);\n\n\tif (ret != NET_RX_SUCCESS) {\n\t\tret = batadv_route_unicast_packet(skb, recv_if);\n\t\t \n\t\tskb = NULL;\n\t}\n\nfree_skb:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\n \nint batadv_recv_frag_packet(struct sk_buff *skb,\n\t\t\t    struct batadv_hard_iface *recv_if)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tstruct batadv_orig_node *orig_node_src = NULL;\n\tstruct batadv_frag_packet *frag_packet;\n\tint ret = NET_RX_DROP;\n\n\tif (batadv_check_unicast_packet(bat_priv, skb,\n\t\t\t\t\tsizeof(*frag_packet)) < 0)\n\t\tgoto free_skb;\n\n\tfrag_packet = (struct batadv_frag_packet *)skb->data;\n\torig_node_src = batadv_orig_hash_find(bat_priv, frag_packet->orig);\n\tif (!orig_node_src)\n\t\tgoto free_skb;\n\n\tskb->priority = frag_packet->priority + 256;\n\n\t \n\tif (!batadv_is_my_mac(bat_priv, frag_packet->dest) &&\n\t    batadv_frag_skb_fwd(skb, recv_if, orig_node_src)) {\n\t\t \n\t\tskb = NULL;\n\t\tret = NET_RX_SUCCESS;\n\t\tgoto put_orig_node;\n\t}\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_RX);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_RX_BYTES, skb->len);\n\n\t \n\tif (!batadv_frag_skb_buffer(&skb, orig_node_src))\n\t\tgoto put_orig_node;\n\n\t \n\tif (skb) {\n\t\tbatadv_batman_skb_recv(skb, recv_if->net_dev,\n\t\t\t\t       &recv_if->batman_adv_ptype, NULL);\n\t\t \n\t\tskb = NULL;\n\t}\n\n\tret = NET_RX_SUCCESS;\n\nput_orig_node:\n\tbatadv_orig_node_put(orig_node_src);\nfree_skb:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\n \nint batadv_recv_bcast_packet(struct sk_buff *skb,\n\t\t\t     struct batadv_hard_iface *recv_if)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tstruct batadv_orig_node *orig_node = NULL;\n\tstruct batadv_bcast_packet *bcast_packet;\n\tstruct ethhdr *ethhdr;\n\tint hdr_size = sizeof(*bcast_packet);\n\ts32 seq_diff;\n\tu32 seqno;\n\tint ret;\n\n\t \n\tif (unlikely(!pskb_may_pull(skb, hdr_size)))\n\t\tgoto free_skb;\n\n\tethhdr = eth_hdr(skb);\n\n\t \n\tif (!is_broadcast_ether_addr(ethhdr->h_dest))\n\t\tgoto free_skb;\n\n\t \n\tif (is_multicast_ether_addr(ethhdr->h_source))\n\t\tgoto free_skb;\n\n\t \n\tif (batadv_is_my_mac(bat_priv, ethhdr->h_source))\n\t\tgoto free_skb;\n\n\tbcast_packet = (struct batadv_bcast_packet *)skb->data;\n\n\t \n\tif (batadv_is_my_mac(bat_priv, bcast_packet->orig))\n\t\tgoto free_skb;\n\n\tif (bcast_packet->ttl-- < 2)\n\t\tgoto free_skb;\n\n\torig_node = batadv_orig_hash_find(bat_priv, bcast_packet->orig);\n\n\tif (!orig_node)\n\t\tgoto free_skb;\n\n\tspin_lock_bh(&orig_node->bcast_seqno_lock);\n\n\tseqno = ntohl(bcast_packet->seqno);\n\t \n\tif (batadv_test_bit(orig_node->bcast_bits, orig_node->last_bcast_seqno,\n\t\t\t    seqno))\n\t\tgoto spin_unlock;\n\n\tseq_diff = seqno - orig_node->last_bcast_seqno;\n\n\t \n\tif (batadv_window_protected(bat_priv, seq_diff,\n\t\t\t\t    BATADV_BCAST_MAX_AGE,\n\t\t\t\t    &orig_node->bcast_seqno_reset, NULL))\n\t\tgoto spin_unlock;\n\n\t \n\tif (batadv_bit_get_packet(bat_priv, orig_node->bcast_bits, seq_diff, 1))\n\t\torig_node->last_bcast_seqno = seqno;\n\n\tspin_unlock_bh(&orig_node->bcast_seqno_lock);\n\n\t \n\tif (batadv_bla_check_bcast_duplist(bat_priv, skb))\n\t\tgoto free_skb;\n\n\tbatadv_skb_set_priority(skb, sizeof(struct batadv_bcast_packet));\n\n\t \n\tret = batadv_forw_bcast_packet(bat_priv, skb, 0, false);\n\tif (ret == NETDEV_TX_BUSY)\n\t\tgoto free_skb;\n\n\t \n\tif (batadv_bla_is_backbone_gw(skb, orig_node, hdr_size))\n\t\tgoto free_skb;\n\n\tif (batadv_dat_snoop_incoming_arp_request(bat_priv, skb, hdr_size))\n\t\tgoto rx_success;\n\tif (batadv_dat_snoop_incoming_arp_reply(bat_priv, skb, hdr_size))\n\t\tgoto rx_success;\n\n\tbatadv_dat_snoop_incoming_dhcp_ack(bat_priv, skb, hdr_size);\n\n\t \n\tbatadv_interface_rx(recv_if->soft_iface, skb, hdr_size, orig_node);\n\nrx_success:\n\tret = NET_RX_SUCCESS;\n\tgoto out;\n\nspin_unlock:\n\tspin_unlock_bh(&orig_node->bcast_seqno_lock);\nfree_skb:\n\tkfree_skb(skb);\n\tret = NET_RX_DROP;\nout:\n\tbatadv_orig_node_put(orig_node);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}