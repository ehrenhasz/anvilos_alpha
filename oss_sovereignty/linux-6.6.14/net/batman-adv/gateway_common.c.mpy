{
  "module_name": "gateway_common.c",
  "hash_id": "8f9d4e0b70236e320616ffbba08e54b6b516398e8ea434cbc19fce22b7f1cd9e",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/gateway_common.c",
  "human_readable_source": "\n \n\n#include \"gateway_common.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/byteorder/generic.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"gateway_client.h\"\n#include \"tvlv.h\"\n\n \nvoid batadv_gw_tvlv_container_update(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_tvlv_gateway_data gw;\n\tu32 down, up;\n\tchar gw_mode;\n\n\tgw_mode = atomic_read(&bat_priv->gw.mode);\n\n\tswitch (gw_mode) {\n\tcase BATADV_GW_MODE_OFF:\n\tcase BATADV_GW_MODE_CLIENT:\n\t\tbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_GW, 1);\n\t\tbreak;\n\tcase BATADV_GW_MODE_SERVER:\n\t\tdown = atomic_read(&bat_priv->gw.bandwidth_down);\n\t\tup = atomic_read(&bat_priv->gw.bandwidth_up);\n\t\tgw.bandwidth_down = htonl(down);\n\t\tgw.bandwidth_up = htonl(up);\n\t\tbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_GW, 1,\n\t\t\t\t\t       &gw, sizeof(gw));\n\t\tbreak;\n\t}\n}\n\n \nstatic void batadv_gw_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_orig_node *orig,\n\t\t\t\t\t  u8 flags,\n\t\t\t\t\t  void *tvlv_value, u16 tvlv_value_len)\n{\n\tstruct batadv_tvlv_gateway_data gateway, *gateway_ptr;\n\n\t \n\tif (flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND ||\n\t    tvlv_value_len < sizeof(gateway)) {\n\t\tgateway.bandwidth_down = 0;\n\t\tgateway.bandwidth_up = 0;\n\t} else {\n\t\tgateway_ptr = tvlv_value;\n\t\tgateway.bandwidth_down = gateway_ptr->bandwidth_down;\n\t\tgateway.bandwidth_up = gateway_ptr->bandwidth_up;\n\t\tif (gateway.bandwidth_down == 0 ||\n\t\t    gateway.bandwidth_up == 0) {\n\t\t\tgateway.bandwidth_down = 0;\n\t\t\tgateway.bandwidth_up = 0;\n\t\t}\n\t}\n\n\tbatadv_gw_node_update(bat_priv, orig, &gateway);\n\n\t \n\tif (gateway.bandwidth_down != 0 &&\n\t    atomic_read(&bat_priv->gw.mode) == BATADV_GW_MODE_CLIENT)\n\t\tbatadv_gw_check_election(bat_priv, orig);\n}\n\n \nvoid batadv_gw_init(struct batadv_priv *bat_priv)\n{\n\tif (bat_priv->algo_ops->gw.init_sel_class)\n\t\tbat_priv->algo_ops->gw.init_sel_class(bat_priv);\n\telse\n\t\tatomic_set(&bat_priv->gw.sel_class, 1);\n\n\tbatadv_tvlv_handler_register(bat_priv, batadv_gw_tvlv_ogm_handler_v1,\n\t\t\t\t     NULL, NULL, BATADV_TVLV_GW, 1,\n\t\t\t\t     BATADV_TVLV_HANDLER_OGM_CIFNOTFND);\n}\n\n \nvoid batadv_gw_free(struct batadv_priv *bat_priv)\n{\n\tbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_GW, 1);\n\tbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_GW, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}