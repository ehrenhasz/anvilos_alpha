{
  "module_name": "send.c",
  "hash_id": "d1ac60e99f5743832681ce195f2ab4080c299d077d9a95ec538c38e97a453318",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/send.c",
  "human_readable_source": "\n \n\n#include \"send.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/bug.h>\n#include <linux/byteorder/generic.h>\n#include <linux/container_of.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/printk.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/workqueue.h>\n\n#include \"distributed-arp-table.h\"\n#include \"fragmentation.h\"\n#include \"gateway_client.h\"\n#include \"hard-interface.h\"\n#include \"log.h\"\n#include \"network-coding.h\"\n#include \"originator.h\"\n#include \"routing.h\"\n#include \"soft-interface.h\"\n#include \"translation-table.h\"\n\nstatic void batadv_send_outstanding_bcast_packet(struct work_struct *work);\n\n \nint batadv_send_skb_packet(struct sk_buff *skb,\n\t\t\t   struct batadv_hard_iface *hard_iface,\n\t\t\t   const u8 *dst_addr)\n{\n\tstruct batadv_priv *bat_priv;\n\tstruct ethhdr *ethhdr;\n\tint ret;\n\n\tbat_priv = netdev_priv(hard_iface->soft_iface);\n\n\tif (hard_iface->if_status != BATADV_IF_ACTIVE)\n\t\tgoto send_skb_err;\n\n\tif (unlikely(!hard_iface->net_dev))\n\t\tgoto send_skb_err;\n\n\tif (!(hard_iface->net_dev->flags & IFF_UP)) {\n\t\tpr_warn(\"Interface %s is not up - can't send packet via that interface!\\n\",\n\t\t\thard_iface->net_dev->name);\n\t\tgoto send_skb_err;\n\t}\n\n\t \n\tif (batadv_skb_head_push(skb, ETH_HLEN) < 0)\n\t\tgoto send_skb_err;\n\n\tskb_reset_mac_header(skb);\n\n\tethhdr = eth_hdr(skb);\n\tether_addr_copy(ethhdr->h_source, hard_iface->net_dev->dev_addr);\n\tether_addr_copy(ethhdr->h_dest, dst_addr);\n\tethhdr->h_proto = htons(ETH_P_BATMAN);\n\n\tskb_set_network_header(skb, ETH_HLEN);\n\tskb->protocol = htons(ETH_P_BATMAN);\n\n\tskb->dev = hard_iface->net_dev;\n\n\t \n\tbatadv_nc_skb_store_for_decoding(bat_priv, skb);\n\n\t \n\tret = dev_queue_xmit(skb);\n\treturn net_xmit_eval(ret);\nsend_skb_err:\n\tkfree_skb(skb);\n\treturn NET_XMIT_DROP;\n}\n\n \nint batadv_send_broadcast_skb(struct sk_buff *skb,\n\t\t\t      struct batadv_hard_iface *hard_iface)\n{\n\treturn batadv_send_skb_packet(skb, hard_iface, batadv_broadcast_addr);\n}\n\n \nint batadv_send_unicast_skb(struct sk_buff *skb,\n\t\t\t    struct batadv_neigh_node *neigh)\n{\n#ifdef CONFIG_BATMAN_ADV_BATMAN_V\n\tstruct batadv_hardif_neigh_node *hardif_neigh;\n#endif\n\tint ret;\n\n\tret = batadv_send_skb_packet(skb, neigh->if_incoming, neigh->addr);\n\n#ifdef CONFIG_BATMAN_ADV_BATMAN_V\n\thardif_neigh = batadv_hardif_neigh_get(neigh->if_incoming, neigh->addr);\n\n\tif (hardif_neigh && ret != NET_XMIT_DROP)\n\t\thardif_neigh->bat_v.last_unicast_tx = jiffies;\n\n\tbatadv_hardif_neigh_put(hardif_neigh);\n#endif\n\n\treturn ret;\n}\n\n \nint batadv_send_skb_to_orig(struct sk_buff *skb,\n\t\t\t    struct batadv_orig_node *orig_node,\n\t\t\t    struct batadv_hard_iface *recv_if)\n{\n\tstruct batadv_priv *bat_priv = orig_node->bat_priv;\n\tstruct batadv_neigh_node *neigh_node;\n\tint ret;\n\n\t \n\tneigh_node = batadv_find_router(bat_priv, orig_node, recv_if);\n\tif (!neigh_node) {\n\t\tret = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\n\t \n\tif (atomic_read(&bat_priv->fragmentation) &&\n\t    skb->len > neigh_node->if_incoming->net_dev->mtu) {\n\t\t \n\t\tret = batadv_frag_send_packet(skb, orig_node, neigh_node);\n\t\t \n\t\tskb = NULL;\n\n\t\tgoto put_neigh_node;\n\t}\n\n\t \n\tif (recv_if && batadv_nc_skb_forward(skb, neigh_node))\n\t\tret = -EINPROGRESS;\n\telse\n\t\tret = batadv_send_unicast_skb(skb, neigh_node);\n\n\t \n\tskb = NULL;\n\nput_neigh_node:\n\tbatadv_neigh_node_put(neigh_node);\nfree_skb:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\n \nstatic bool\nbatadv_send_skb_push_fill_unicast(struct sk_buff *skb, int hdr_size,\n\t\t\t\t  struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_unicast_packet *unicast_packet;\n\tu8 ttvn = (u8)atomic_read(&orig_node->last_ttvn);\n\n\tif (batadv_skb_head_push(skb, hdr_size) < 0)\n\t\treturn false;\n\n\tunicast_packet = (struct batadv_unicast_packet *)skb->data;\n\tunicast_packet->version = BATADV_COMPAT_VERSION;\n\t \n\tunicast_packet->packet_type = BATADV_UNICAST;\n\t \n\tunicast_packet->ttl = BATADV_TTL;\n\t \n\tether_addr_copy(unicast_packet->dest, orig_node->orig);\n\t \n\tunicast_packet->ttvn = ttvn;\n\n\treturn true;\n}\n\n \nstatic bool batadv_send_skb_prepare_unicast(struct sk_buff *skb,\n\t\t\t\t\t    struct batadv_orig_node *orig_node)\n{\n\tsize_t uni_size = sizeof(struct batadv_unicast_packet);\n\n\treturn batadv_send_skb_push_fill_unicast(skb, uni_size, orig_node);\n}\n\n \nbool batadv_send_skb_prepare_unicast_4addr(struct batadv_priv *bat_priv,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   struct batadv_orig_node *orig,\n\t\t\t\t\t   int packet_subtype)\n{\n\tstruct batadv_hard_iface *primary_if;\n\tstruct batadv_unicast_4addr_packet *uc_4addr_packet;\n\tbool ret = false;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\tgoto out;\n\n\t \n\tif (!batadv_send_skb_push_fill_unicast(skb, sizeof(*uc_4addr_packet),\n\t\t\t\t\t       orig))\n\t\tgoto out;\n\n\tuc_4addr_packet = (struct batadv_unicast_4addr_packet *)skb->data;\n\tuc_4addr_packet->u.packet_type = BATADV_UNICAST_4ADDR;\n\tether_addr_copy(uc_4addr_packet->src, primary_if->net_dev->dev_addr);\n\tuc_4addr_packet->subtype = packet_subtype;\n\tuc_4addr_packet->reserved = 0;\n\n\tret = true;\nout:\n\tbatadv_hardif_put(primary_if);\n\treturn ret;\n}\n\n \nint batadv_send_skb_unicast(struct batadv_priv *bat_priv,\n\t\t\t    struct sk_buff *skb, int packet_type,\n\t\t\t    int packet_subtype,\n\t\t\t    struct batadv_orig_node *orig_node,\n\t\t\t    unsigned short vid)\n{\n\tstruct batadv_unicast_packet *unicast_packet;\n\tstruct ethhdr *ethhdr;\n\tint ret = NET_XMIT_DROP;\n\n\tif (!orig_node)\n\t\tgoto out;\n\n\tswitch (packet_type) {\n\tcase BATADV_UNICAST:\n\t\tif (!batadv_send_skb_prepare_unicast(skb, orig_node))\n\t\t\tgoto out;\n\t\tbreak;\n\tcase BATADV_UNICAST_4ADDR:\n\t\tif (!batadv_send_skb_prepare_unicast_4addr(bat_priv, skb,\n\t\t\t\t\t\t\t   orig_node,\n\t\t\t\t\t\t\t   packet_subtype))\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\tethhdr = eth_hdr(skb);\n\tunicast_packet = (struct batadv_unicast_packet *)skb->data;\n\n\t \n\tif (batadv_tt_global_client_is_roaming(bat_priv, ethhdr->h_dest, vid))\n\t\tunicast_packet->ttvn = unicast_packet->ttvn - 1;\n\n\tret = batadv_send_skb_to_orig(skb, orig_node, NULL);\n\t  \n\tskb = NULL;\n\nout:\n\tkfree_skb(skb);\n\treturn ret;\n}\n\n \nint batadv_send_skb_via_tt_generic(struct batadv_priv *bat_priv,\n\t\t\t\t   struct sk_buff *skb, int packet_type,\n\t\t\t\t   int packet_subtype, u8 *dst_hint,\n\t\t\t\t   unsigned short vid)\n{\n\tstruct ethhdr *ethhdr = (struct ethhdr *)skb->data;\n\tstruct batadv_orig_node *orig_node;\n\tu8 *src, *dst;\n\tint ret;\n\n\tsrc = ethhdr->h_source;\n\tdst = ethhdr->h_dest;\n\n\t \n\tif (dst_hint) {\n\t\tsrc = NULL;\n\t\tdst = dst_hint;\n\t}\n\torig_node = batadv_transtable_search(bat_priv, src, dst, vid);\n\n\tret = batadv_send_skb_unicast(bat_priv, skb, packet_type,\n\t\t\t\t      packet_subtype, orig_node, vid);\n\n\tbatadv_orig_node_put(orig_node);\n\n\treturn ret;\n}\n\n \nint batadv_send_skb_via_gw(struct batadv_priv *bat_priv, struct sk_buff *skb,\n\t\t\t   unsigned short vid)\n{\n\tstruct batadv_orig_node *orig_node;\n\tint ret;\n\n\torig_node = batadv_gw_get_selected_orig(bat_priv);\n\tret = batadv_send_skb_unicast(bat_priv, skb, BATADV_UNICAST_4ADDR,\n\t\t\t\t      BATADV_P_DATA, orig_node, vid);\n\n\tbatadv_orig_node_put(orig_node);\n\n\treturn ret;\n}\n\n \nvoid batadv_forw_packet_free(struct batadv_forw_packet *forw_packet,\n\t\t\t     bool dropped)\n{\n\tif (dropped)\n\t\tkfree_skb(forw_packet->skb);\n\telse\n\t\tconsume_skb(forw_packet->skb);\n\n\tbatadv_hardif_put(forw_packet->if_incoming);\n\tbatadv_hardif_put(forw_packet->if_outgoing);\n\tif (forw_packet->queue_left)\n\t\tatomic_inc(forw_packet->queue_left);\n\tkfree(forw_packet);\n}\n\n \nstruct batadv_forw_packet *\nbatadv_forw_packet_alloc(struct batadv_hard_iface *if_incoming,\n\t\t\t struct batadv_hard_iface *if_outgoing,\n\t\t\t atomic_t *queue_left,\n\t\t\t struct batadv_priv *bat_priv,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct batadv_forw_packet *forw_packet;\n\tconst char *qname;\n\n\tif (queue_left && !batadv_atomic_dec_not_zero(queue_left)) {\n\t\tqname = \"unknown\";\n\n\t\tif (queue_left == &bat_priv->bcast_queue_left)\n\t\t\tqname = \"bcast\";\n\n\t\tif (queue_left == &bat_priv->batman_queue_left)\n\t\t\tqname = \"batman\";\n\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"%s queue is full\\n\", qname);\n\n\t\treturn NULL;\n\t}\n\n\tforw_packet = kmalloc(sizeof(*forw_packet), GFP_ATOMIC);\n\tif (!forw_packet)\n\t\tgoto err;\n\n\tif (if_incoming)\n\t\tkref_get(&if_incoming->refcount);\n\n\tif (if_outgoing)\n\t\tkref_get(&if_outgoing->refcount);\n\n\tINIT_HLIST_NODE(&forw_packet->list);\n\tINIT_HLIST_NODE(&forw_packet->cleanup_list);\n\tforw_packet->skb = skb;\n\tforw_packet->queue_left = queue_left;\n\tforw_packet->if_incoming = if_incoming;\n\tforw_packet->if_outgoing = if_outgoing;\n\tforw_packet->num_packets = 0;\n\n\treturn forw_packet;\n\nerr:\n\tif (queue_left)\n\t\tatomic_inc(queue_left);\n\n\treturn NULL;\n}\n\n \nstatic bool\nbatadv_forw_packet_was_stolen(struct batadv_forw_packet *forw_packet)\n{\n\treturn !hlist_unhashed(&forw_packet->cleanup_list);\n}\n\n \nbool batadv_forw_packet_steal(struct batadv_forw_packet *forw_packet,\n\t\t\t      spinlock_t *lock)\n{\n\t \n\tspin_lock_bh(lock);\n\tif (batadv_forw_packet_was_stolen(forw_packet)) {\n\t\tspin_unlock_bh(lock);\n\t\treturn false;\n\t}\n\n\thlist_del_init(&forw_packet->list);\n\n\t \n\thlist_add_fake(&forw_packet->cleanup_list);\n\n\tspin_unlock_bh(lock);\n\treturn true;\n}\n\n \nstatic void\nbatadv_forw_packet_list_steal(struct hlist_head *forw_list,\n\t\t\t      struct hlist_head *cleanup_list,\n\t\t\t      const struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_forw_packet *forw_packet;\n\tstruct hlist_node *safe_tmp_node;\n\n\thlist_for_each_entry_safe(forw_packet, safe_tmp_node,\n\t\t\t\t  forw_list, list) {\n\t\t \n\t\tif (hard_iface &&\n\t\t    forw_packet->if_incoming != hard_iface &&\n\t\t    forw_packet->if_outgoing != hard_iface)\n\t\t\tcontinue;\n\n\t\thlist_del(&forw_packet->list);\n\t\thlist_add_head(&forw_packet->cleanup_list, cleanup_list);\n\t}\n}\n\n \nstatic void batadv_forw_packet_list_free(struct hlist_head *head)\n{\n\tstruct batadv_forw_packet *forw_packet;\n\tstruct hlist_node *safe_tmp_node;\n\n\thlist_for_each_entry_safe(forw_packet, safe_tmp_node, head,\n\t\t\t\t  cleanup_list) {\n\t\tcancel_delayed_work_sync(&forw_packet->delayed_work);\n\n\t\thlist_del(&forw_packet->cleanup_list);\n\t\tbatadv_forw_packet_free(forw_packet, true);\n\t}\n}\n\n \nstatic void batadv_forw_packet_queue(struct batadv_forw_packet *forw_packet,\n\t\t\t\t     spinlock_t *lock, struct hlist_head *head,\n\t\t\t\t     unsigned long send_time)\n{\n\tspin_lock_bh(lock);\n\n\t \n\tif (batadv_forw_packet_was_stolen(forw_packet)) {\n\t\t \n\t\tWARN_ONCE(hlist_fake(&forw_packet->cleanup_list),\n\t\t\t  \"Requeuing after batadv_forw_packet_steal() not allowed!\\n\");\n\n\t\tspin_unlock_bh(lock);\n\t\treturn;\n\t}\n\n\thlist_del_init(&forw_packet->list);\n\thlist_add_head(&forw_packet->list, head);\n\n\tqueue_delayed_work(batadv_event_workqueue,\n\t\t\t   &forw_packet->delayed_work,\n\t\t\t   send_time - jiffies);\n\tspin_unlock_bh(lock);\n}\n\n \nstatic void\nbatadv_forw_packet_bcast_queue(struct batadv_priv *bat_priv,\n\t\t\t       struct batadv_forw_packet *forw_packet,\n\t\t\t       unsigned long send_time)\n{\n\tbatadv_forw_packet_queue(forw_packet, &bat_priv->forw_bcast_list_lock,\n\t\t\t\t &bat_priv->forw_bcast_list, send_time);\n}\n\n \nvoid batadv_forw_packet_ogmv1_queue(struct batadv_priv *bat_priv,\n\t\t\t\t    struct batadv_forw_packet *forw_packet,\n\t\t\t\t    unsigned long send_time)\n{\n\tbatadv_forw_packet_queue(forw_packet, &bat_priv->forw_bat_list_lock,\n\t\t\t\t &bat_priv->forw_bat_list, send_time);\n}\n\n \nstatic int batadv_forw_bcast_packet_to_list(struct batadv_priv *bat_priv,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    unsigned long delay,\n\t\t\t\t\t    bool own_packet,\n\t\t\t\t\t    struct batadv_hard_iface *if_in,\n\t\t\t\t\t    struct batadv_hard_iface *if_out)\n{\n\tstruct batadv_forw_packet *forw_packet;\n\tunsigned long send_time = jiffies;\n\tstruct sk_buff *newskb;\n\n\tnewskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!newskb)\n\t\tgoto err;\n\n\tforw_packet = batadv_forw_packet_alloc(if_in, if_out,\n\t\t\t\t\t       &bat_priv->bcast_queue_left,\n\t\t\t\t\t       bat_priv, newskb);\n\tif (!forw_packet)\n\t\tgoto err_packet_free;\n\n\tforw_packet->own = own_packet;\n\n\tINIT_DELAYED_WORK(&forw_packet->delayed_work,\n\t\t\t  batadv_send_outstanding_bcast_packet);\n\n\tsend_time += delay ? delay : msecs_to_jiffies(5);\n\n\tbatadv_forw_packet_bcast_queue(bat_priv, forw_packet, send_time);\n\treturn NETDEV_TX_OK;\n\nerr_packet_free:\n\tkfree_skb(newskb);\nerr:\n\treturn NETDEV_TX_BUSY;\n}\n\n \nstatic int batadv_forw_bcast_packet_if(struct batadv_priv *bat_priv,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       unsigned long delay,\n\t\t\t\t       bool own_packet,\n\t\t\t\t       struct batadv_hard_iface *if_in,\n\t\t\t\t       struct batadv_hard_iface *if_out)\n{\n\tunsigned int num_bcasts = if_out->num_bcasts;\n\tstruct sk_buff *newskb;\n\tint ret = NETDEV_TX_OK;\n\n\tif (!delay) {\n\t\tnewskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!newskb)\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tbatadv_send_broadcast_skb(newskb, if_out);\n\t\tnum_bcasts--;\n\t}\n\n\t \n\tif (num_bcasts >= 1) {\n\t\tBATADV_SKB_CB(skb)->num_bcasts = num_bcasts;\n\n\t\tret = batadv_forw_bcast_packet_to_list(bat_priv, skb, delay,\n\t\t\t\t\t\t       own_packet, if_in,\n\t\t\t\t\t\t       if_out);\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool batadv_send_no_broadcast(struct batadv_priv *bat_priv,\n\t\t\t\t     struct sk_buff *skb, bool own_packet,\n\t\t\t\t     struct batadv_hard_iface *if_out)\n{\n\tstruct batadv_hardif_neigh_node *neigh_node = NULL;\n\tstruct batadv_bcast_packet *bcast_packet;\n\tu8 *orig_neigh;\n\tu8 *neigh_addr;\n\tchar *type;\n\tint ret;\n\n\tif (!own_packet) {\n\t\tneigh_addr = eth_hdr(skb)->h_source;\n\t\tneigh_node = batadv_hardif_neigh_get(if_out,\n\t\t\t\t\t\t     neigh_addr);\n\t}\n\n\tbcast_packet = (struct batadv_bcast_packet *)skb->data;\n\torig_neigh = neigh_node ? neigh_node->orig : NULL;\n\n\tret = batadv_hardif_no_broadcast(if_out, bcast_packet->orig,\n\t\t\t\t\t orig_neigh);\n\n\tbatadv_hardif_neigh_put(neigh_node);\n\n\t \n\tif (!ret)\n\t\treturn false;\n\n\t \n\tswitch (ret) {\n\tcase BATADV_HARDIF_BCAST_NORECIPIENT:\n\t\ttype = \"no neighbor\";\n\t\tbreak;\n\tcase BATADV_HARDIF_BCAST_DUPFWD:\n\t\ttype = \"single neighbor is source\";\n\t\tbreak;\n\tcase BATADV_HARDIF_BCAST_DUPORIG:\n\t\ttype = \"single neighbor is originator\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t}\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"BCAST packet from orig %pM on %s suppressed: %s\\n\",\n\t\t   bcast_packet->orig,\n\t\t   if_out->net_dev->name, type);\n\n\treturn true;\n}\n\n \nstatic int __batadv_forw_bcast_packet(struct batadv_priv *bat_priv,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      unsigned long delay,\n\t\t\t\t      bool own_packet)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_hard_iface *primary_if;\n\tint ret = NETDEV_TX_OK;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\treturn NETDEV_TX_BUSY;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->soft_iface != bat_priv->soft_iface)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&hard_iface->refcount))\n\t\t\tcontinue;\n\n\t\tif (batadv_send_no_broadcast(bat_priv, skb, own_packet,\n\t\t\t\t\t     hard_iface)) {\n\t\t\tbatadv_hardif_put(hard_iface);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = batadv_forw_bcast_packet_if(bat_priv, skb, delay,\n\t\t\t\t\t\t  own_packet, primary_if,\n\t\t\t\t\t\t  hard_iface);\n\t\tbatadv_hardif_put(hard_iface);\n\n\t\tif (ret == NETDEV_TX_BUSY)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tbatadv_hardif_put(primary_if);\n\treturn ret;\n}\n\n \nint batadv_forw_bcast_packet(struct batadv_priv *bat_priv,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     unsigned long delay,\n\t\t\t     bool own_packet)\n{\n\treturn __batadv_forw_bcast_packet(bat_priv, skb, delay, own_packet);\n}\n\n \nvoid batadv_send_bcast_packet(struct batadv_priv *bat_priv,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      unsigned long delay,\n\t\t\t      bool own_packet)\n{\n\t__batadv_forw_bcast_packet(bat_priv, skb, delay, own_packet);\n\tconsume_skb(skb);\n}\n\n \nstatic bool\nbatadv_forw_packet_bcasts_left(struct batadv_forw_packet *forw_packet)\n{\n\treturn BATADV_SKB_CB(forw_packet->skb)->num_bcasts;\n}\n\n \nstatic void\nbatadv_forw_packet_bcasts_dec(struct batadv_forw_packet *forw_packet)\n{\n\tBATADV_SKB_CB(forw_packet->skb)->num_bcasts--;\n}\n\n \nbool batadv_forw_packet_is_rebroadcast(struct batadv_forw_packet *forw_packet)\n{\n\tunsigned char num_bcasts = BATADV_SKB_CB(forw_packet->skb)->num_bcasts;\n\n\treturn num_bcasts != forw_packet->if_outgoing->num_bcasts;\n}\n\n \nstatic void batadv_send_outstanding_bcast_packet(struct work_struct *work)\n{\n\tunsigned long send_time = jiffies + msecs_to_jiffies(5);\n\tstruct batadv_forw_packet *forw_packet;\n\tstruct delayed_work *delayed_work;\n\tstruct batadv_priv *bat_priv;\n\tstruct sk_buff *skb1;\n\tbool dropped = false;\n\n\tdelayed_work = to_delayed_work(work);\n\tforw_packet = container_of(delayed_work, struct batadv_forw_packet,\n\t\t\t\t   delayed_work);\n\tbat_priv = netdev_priv(forw_packet->if_incoming->soft_iface);\n\n\tif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING) {\n\t\tdropped = true;\n\t\tgoto out;\n\t}\n\n\tif (batadv_dat_drop_broadcast_packet(bat_priv, forw_packet)) {\n\t\tdropped = true;\n\t\tgoto out;\n\t}\n\n\t \n\tskb1 = skb_clone(forw_packet->skb, GFP_ATOMIC);\n\tif (!skb1)\n\t\tgoto out;\n\n\tbatadv_send_broadcast_skb(skb1, forw_packet->if_outgoing);\n\tbatadv_forw_packet_bcasts_dec(forw_packet);\n\n\tif (batadv_forw_packet_bcasts_left(forw_packet)) {\n\t\tbatadv_forw_packet_bcast_queue(bat_priv, forw_packet,\n\t\t\t\t\t       send_time);\n\t\treturn;\n\t}\n\nout:\n\t \n\tif (batadv_forw_packet_steal(forw_packet,\n\t\t\t\t     &bat_priv->forw_bcast_list_lock))\n\t\tbatadv_forw_packet_free(forw_packet, dropped);\n}\n\n \nvoid\nbatadv_purge_outstanding_packets(struct batadv_priv *bat_priv,\n\t\t\t\t const struct batadv_hard_iface *hard_iface)\n{\n\tstruct hlist_head head = HLIST_HEAD_INIT;\n\n\tif (hard_iface)\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"%s(): %s\\n\",\n\t\t\t   __func__, hard_iface->net_dev->name);\n\telse\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"%s()\\n\", __func__);\n\n\t \n\tspin_lock_bh(&bat_priv->forw_bcast_list_lock);\n\tbatadv_forw_packet_list_steal(&bat_priv->forw_bcast_list, &head,\n\t\t\t\t      hard_iface);\n\tspin_unlock_bh(&bat_priv->forw_bcast_list_lock);\n\n\t \n\tspin_lock_bh(&bat_priv->forw_bat_list_lock);\n\tbatadv_forw_packet_list_steal(&bat_priv->forw_bat_list, &head,\n\t\t\t\t      hard_iface);\n\tspin_unlock_bh(&bat_priv->forw_bat_list_lock);\n\n\t \n\tbatadv_forw_packet_list_free(&head);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}