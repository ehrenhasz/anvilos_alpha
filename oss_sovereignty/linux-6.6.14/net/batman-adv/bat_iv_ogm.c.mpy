{
  "module_name": "bat_iv_ogm.c",
  "hash_id": "499c438c9c4fdde6f5ee2a7bfceef84e930c019c05af0820513336ae6234c93f",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/bat_iv_ogm.c",
  "human_readable_source": "\n \n\n#include \"bat_iv_ogm.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/bug.h>\n#include <linux/byteorder/generic.h>\n#include <linux/cache.h>\n#include <linux/container_of.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/pkt_sched.h>\n#include <linux/printk.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <net/genetlink.h>\n#include <net/netlink.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"bat_algo.h\"\n#include \"bitarray.h\"\n#include \"gateway_client.h\"\n#include \"hard-interface.h\"\n#include \"hash.h\"\n#include \"log.h\"\n#include \"netlink.h\"\n#include \"network-coding.h\"\n#include \"originator.h\"\n#include \"routing.h\"\n#include \"send.h\"\n#include \"translation-table.h\"\n#include \"tvlv.h\"\n\nstatic void batadv_iv_send_outstanding_bat_ogm_packet(struct work_struct *work);\n\n \nenum batadv_dup_status {\n\t \n\tBATADV_NO_DUP = 0,\n\n\t \n\tBATADV_ORIG_DUP,\n\n\t \n\tBATADV_NEIGH_DUP,\n\n\t \n\tBATADV_PROTECTED,\n};\n\n \nstatic void batadv_ring_buffer_set(u8 lq_recv[], u8 *lq_index, u8 value)\n{\n\tlq_recv[*lq_index] = value;\n\t*lq_index = (*lq_index + 1) % BATADV_TQ_GLOBAL_WINDOW_SIZE;\n}\n\n \nstatic u8 batadv_ring_buffer_avg(const u8 lq_recv[])\n{\n\tconst u8 *ptr;\n\tu16 count = 0;\n\tu16 i = 0;\n\tu16 sum = 0;\n\n\tptr = lq_recv;\n\n\twhile (i < BATADV_TQ_GLOBAL_WINDOW_SIZE) {\n\t\tif (*ptr != 0) {\n\t\t\tcount++;\n\t\t\tsum += *ptr;\n\t\t}\n\n\t\ti++;\n\t\tptr++;\n\t}\n\n\tif (count == 0)\n\t\treturn 0;\n\n\treturn (u8)(sum / count);\n}\n\n \nstatic struct batadv_orig_node *\nbatadv_iv_ogm_orig_get(struct batadv_priv *bat_priv, const u8 *addr)\n{\n\tstruct batadv_orig_node *orig_node;\n\tint hash_added;\n\n\torig_node = batadv_orig_hash_find(bat_priv, addr);\n\tif (orig_node)\n\t\treturn orig_node;\n\n\torig_node = batadv_orig_node_new(bat_priv, addr);\n\tif (!orig_node)\n\t\treturn NULL;\n\n\tspin_lock_init(&orig_node->bat_iv.ogm_cnt_lock);\n\n\tkref_get(&orig_node->refcount);\n\thash_added = batadv_hash_add(bat_priv->orig_hash, batadv_compare_orig,\n\t\t\t\t     batadv_choose_orig, orig_node,\n\t\t\t\t     &orig_node->hash_entry);\n\tif (hash_added != 0)\n\t\tgoto free_orig_node_hash;\n\n\treturn orig_node;\n\nfree_orig_node_hash:\n\t \n\tbatadv_orig_node_put(orig_node);\n\t \n\tbatadv_orig_node_put(orig_node);\n\n\treturn NULL;\n}\n\nstatic struct batadv_neigh_node *\nbatadv_iv_ogm_neigh_new(struct batadv_hard_iface *hard_iface,\n\t\t\tconst u8 *neigh_addr,\n\t\t\tstruct batadv_orig_node *orig_node,\n\t\t\tstruct batadv_orig_node *orig_neigh)\n{\n\tstruct batadv_neigh_node *neigh_node;\n\n\tneigh_node = batadv_neigh_node_get_or_create(orig_node,\n\t\t\t\t\t\t     hard_iface, neigh_addr);\n\tif (!neigh_node)\n\t\tgoto out;\n\n\tneigh_node->orig_node = orig_neigh;\n\nout:\n\treturn neigh_node;\n}\n\nstatic int batadv_iv_ogm_iface_enable(struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_ogm_packet *batadv_ogm_packet;\n\tunsigned char *ogm_buff;\n\tu32 random_seqno;\n\n\tmutex_lock(&hard_iface->bat_iv.ogm_buff_mutex);\n\n\t \n\tget_random_bytes(&random_seqno, sizeof(random_seqno));\n\tatomic_set(&hard_iface->bat_iv.ogm_seqno, random_seqno);\n\n\thard_iface->bat_iv.ogm_buff_len = BATADV_OGM_HLEN;\n\togm_buff = kmalloc(hard_iface->bat_iv.ogm_buff_len, GFP_ATOMIC);\n\tif (!ogm_buff) {\n\t\tmutex_unlock(&hard_iface->bat_iv.ogm_buff_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\thard_iface->bat_iv.ogm_buff = ogm_buff;\n\n\tbatadv_ogm_packet = (struct batadv_ogm_packet *)ogm_buff;\n\tbatadv_ogm_packet->packet_type = BATADV_IV_OGM;\n\tbatadv_ogm_packet->version = BATADV_COMPAT_VERSION;\n\tbatadv_ogm_packet->ttl = 2;\n\tbatadv_ogm_packet->flags = BATADV_NO_FLAGS;\n\tbatadv_ogm_packet->reserved = 0;\n\tbatadv_ogm_packet->tq = BATADV_TQ_MAX_VALUE;\n\n\tmutex_unlock(&hard_iface->bat_iv.ogm_buff_mutex);\n\n\treturn 0;\n}\n\nstatic void batadv_iv_ogm_iface_disable(struct batadv_hard_iface *hard_iface)\n{\n\tmutex_lock(&hard_iface->bat_iv.ogm_buff_mutex);\n\n\tkfree(hard_iface->bat_iv.ogm_buff);\n\thard_iface->bat_iv.ogm_buff = NULL;\n\n\tmutex_unlock(&hard_iface->bat_iv.ogm_buff_mutex);\n}\n\nstatic void batadv_iv_ogm_iface_update_mac(struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_ogm_packet *batadv_ogm_packet;\n\tvoid *ogm_buff;\n\n\tmutex_lock(&hard_iface->bat_iv.ogm_buff_mutex);\n\n\togm_buff = hard_iface->bat_iv.ogm_buff;\n\tif (!ogm_buff)\n\t\tgoto unlock;\n\n\tbatadv_ogm_packet = ogm_buff;\n\tether_addr_copy(batadv_ogm_packet->orig,\n\t\t\thard_iface->net_dev->dev_addr);\n\tether_addr_copy(batadv_ogm_packet->prev_sender,\n\t\t\thard_iface->net_dev->dev_addr);\n\nunlock:\n\tmutex_unlock(&hard_iface->bat_iv.ogm_buff_mutex);\n}\n\nstatic void\nbatadv_iv_ogm_primary_iface_set(struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_ogm_packet *batadv_ogm_packet;\n\tvoid *ogm_buff;\n\n\tmutex_lock(&hard_iface->bat_iv.ogm_buff_mutex);\n\n\togm_buff = hard_iface->bat_iv.ogm_buff;\n\tif (!ogm_buff)\n\t\tgoto unlock;\n\n\tbatadv_ogm_packet = ogm_buff;\n\tbatadv_ogm_packet->ttl = BATADV_TTL;\n\nunlock:\n\tmutex_unlock(&hard_iface->bat_iv.ogm_buff_mutex);\n}\n\n \nstatic unsigned long\nbatadv_iv_ogm_emit_send_time(const struct batadv_priv *bat_priv)\n{\n\tunsigned int msecs;\n\n\tmsecs = atomic_read(&bat_priv->orig_interval) - BATADV_JITTER;\n\tmsecs += get_random_u32_below(2 * BATADV_JITTER);\n\n\treturn jiffies + msecs_to_jiffies(msecs);\n}\n\n \nstatic unsigned long batadv_iv_ogm_fwd_send_time(void)\n{\n\treturn jiffies + msecs_to_jiffies(get_random_u32_below(BATADV_JITTER / 2));\n}\n\n \nstatic u8 batadv_hop_penalty(u8 tq, const struct batadv_priv *bat_priv)\n{\n\tint hop_penalty = atomic_read(&bat_priv->hop_penalty);\n\tint new_tq;\n\n\tnew_tq = tq * (BATADV_TQ_MAX_VALUE - hop_penalty);\n\tnew_tq /= BATADV_TQ_MAX_VALUE;\n\n\treturn new_tq;\n}\n\n \nstatic bool\nbatadv_iv_ogm_aggr_packet(int buff_pos, int packet_len,\n\t\t\t  const struct batadv_ogm_packet *ogm_packet)\n{\n\tint next_buff_pos = 0;\n\n\t \n\tnext_buff_pos += buff_pos + sizeof(*ogm_packet);\n\tif (next_buff_pos > packet_len)\n\t\treturn false;\n\n\t \n\tnext_buff_pos += ntohs(ogm_packet->tvlv_len);\n\n\treturn (next_buff_pos <= packet_len) &&\n\t       (next_buff_pos <= BATADV_MAX_AGGREGATION_BYTES);\n}\n\n \nstatic void batadv_iv_ogm_send_to_if(struct batadv_forw_packet *forw_packet,\n\t\t\t\t     struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\tconst char *fwd_str;\n\tu8 packet_num;\n\ts16 buff_pos;\n\tstruct batadv_ogm_packet *batadv_ogm_packet;\n\tstruct sk_buff *skb;\n\tu8 *packet_pos;\n\n\tif (hard_iface->if_status != BATADV_IF_ACTIVE)\n\t\treturn;\n\n\tpacket_num = 0;\n\tbuff_pos = 0;\n\tpacket_pos = forw_packet->skb->data;\n\tbatadv_ogm_packet = (struct batadv_ogm_packet *)packet_pos;\n\n\t \n\twhile (batadv_iv_ogm_aggr_packet(buff_pos, forw_packet->packet_len,\n\t\t\t\t\t batadv_ogm_packet)) {\n\t\t \n\t\tif (forw_packet->direct_link_flags & BIT(packet_num) &&\n\t\t    forw_packet->if_incoming == hard_iface)\n\t\t\tbatadv_ogm_packet->flags |= BATADV_DIRECTLINK;\n\t\telse\n\t\t\tbatadv_ogm_packet->flags &= ~BATADV_DIRECTLINK;\n\n\t\tif (packet_num > 0 || !forw_packet->own)\n\t\t\tfwd_str = \"Forwarding\";\n\t\telse\n\t\t\tfwd_str = \"Sending own\";\n\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"%s %spacket (originator %pM, seqno %u, TQ %d, TTL %d, IDF %s) on interface %s [%pM]\\n\",\n\t\t\t   fwd_str, (packet_num > 0 ? \"aggregated \" : \"\"),\n\t\t\t   batadv_ogm_packet->orig,\n\t\t\t   ntohl(batadv_ogm_packet->seqno),\n\t\t\t   batadv_ogm_packet->tq, batadv_ogm_packet->ttl,\n\t\t\t   ((batadv_ogm_packet->flags & BATADV_DIRECTLINK) ?\n\t\t\t    \"on\" : \"off\"),\n\t\t\t   hard_iface->net_dev->name,\n\t\t\t   hard_iface->net_dev->dev_addr);\n\n\t\tbuff_pos += BATADV_OGM_HLEN;\n\t\tbuff_pos += ntohs(batadv_ogm_packet->tvlv_len);\n\t\tpacket_num++;\n\t\tpacket_pos = forw_packet->skb->data + buff_pos;\n\t\tbatadv_ogm_packet = (struct batadv_ogm_packet *)packet_pos;\n\t}\n\n\t \n\tskb = skb_clone(forw_packet->skb, GFP_ATOMIC);\n\tif (skb) {\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_MGMT_TX);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_MGMT_TX_BYTES,\n\t\t\t\t   skb->len + ETH_HLEN);\n\t\tbatadv_send_broadcast_skb(skb, hard_iface);\n\t}\n}\n\n \nstatic void batadv_iv_ogm_emit(struct batadv_forw_packet *forw_packet)\n{\n\tstruct net_device *soft_iface;\n\n\tif (!forw_packet->if_incoming) {\n\t\tpr_err(\"Error - can't forward packet: incoming iface not specified\\n\");\n\t\treturn;\n\t}\n\n\tsoft_iface = forw_packet->if_incoming->soft_iface;\n\n\tif (WARN_ON(!forw_packet->if_outgoing))\n\t\treturn;\n\n\tif (forw_packet->if_outgoing->soft_iface != soft_iface) {\n\t\tpr_warn(\"%s: soft interface switch for queued OGM\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (forw_packet->if_incoming->if_status != BATADV_IF_ACTIVE)\n\t\treturn;\n\n\t \n\tbatadv_iv_ogm_send_to_if(forw_packet, forw_packet->if_outgoing);\n}\n\n \nstatic bool\nbatadv_iv_ogm_can_aggregate(const struct batadv_ogm_packet *new_bat_ogm_packet,\n\t\t\t    struct batadv_priv *bat_priv,\n\t\t\t    int packet_len, unsigned long send_time,\n\t\t\t    bool directlink,\n\t\t\t    const struct batadv_hard_iface *if_incoming,\n\t\t\t    const struct batadv_hard_iface *if_outgoing,\n\t\t\t    const struct batadv_forw_packet *forw_packet)\n{\n\tstruct batadv_ogm_packet *batadv_ogm_packet;\n\tint aggregated_bytes = forw_packet->packet_len + packet_len;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tbool res = false;\n\tunsigned long aggregation_end_time;\n\n\tbatadv_ogm_packet = (struct batadv_ogm_packet *)forw_packet->skb->data;\n\taggregation_end_time = send_time;\n\taggregation_end_time += msecs_to_jiffies(BATADV_MAX_AGGREGATION_MS);\n\n\t \n\tif (!time_before(send_time, forw_packet->send_time) ||\n\t    !time_after_eq(aggregation_end_time, forw_packet->send_time))\n\t\treturn false;\n\n\tif (aggregated_bytes > BATADV_MAX_AGGREGATION_BYTES)\n\t\treturn false;\n\n\t \n\tif (forw_packet->if_outgoing != if_outgoing)\n\t\treturn false;\n\n\t \n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\treturn false;\n\n\t \n\tif (!directlink &&\n\t    !(batadv_ogm_packet->flags & BATADV_DIRECTLINK) &&\n\t    batadv_ogm_packet->ttl != 1 &&\n\n\t     \n\t    (!forw_packet->own ||\n\t     forw_packet->if_incoming == primary_if)) {\n\t\tres = true;\n\t\tgoto out;\n\t}\n\n\t \n\tif (directlink &&\n\t    new_bat_ogm_packet->ttl == 1 &&\n\t    forw_packet->if_incoming == if_incoming &&\n\n\t     \n\t    (batadv_ogm_packet->flags & BATADV_DIRECTLINK ||\n\t     (forw_packet->own &&\n\t      forw_packet->if_incoming != primary_if))) {\n\t\tres = true;\n\t\tgoto out;\n\t}\n\nout:\n\tbatadv_hardif_put(primary_if);\n\treturn res;\n}\n\n \nstatic void batadv_iv_ogm_aggregate_new(const unsigned char *packet_buff,\n\t\t\t\t\tint packet_len, unsigned long send_time,\n\t\t\t\t\tbool direct_link,\n\t\t\t\t\tstruct batadv_hard_iface *if_incoming,\n\t\t\t\t\tstruct batadv_hard_iface *if_outgoing,\n\t\t\t\t\tint own_packet)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\n\tstruct batadv_forw_packet *forw_packet_aggr;\n\tstruct sk_buff *skb;\n\tunsigned char *skb_buff;\n\tunsigned int skb_size;\n\tatomic_t *queue_left = own_packet ? NULL : &bat_priv->batman_queue_left;\n\n\tif (atomic_read(&bat_priv->aggregated_ogms) &&\n\t    packet_len < BATADV_MAX_AGGREGATION_BYTES)\n\t\tskb_size = BATADV_MAX_AGGREGATION_BYTES;\n\telse\n\t\tskb_size = packet_len;\n\n\tskb_size += ETH_HLEN;\n\n\tskb = netdev_alloc_skb_ip_align(NULL, skb_size);\n\tif (!skb)\n\t\treturn;\n\n\tforw_packet_aggr = batadv_forw_packet_alloc(if_incoming, if_outgoing,\n\t\t\t\t\t\t    queue_left, bat_priv, skb);\n\tif (!forw_packet_aggr) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tforw_packet_aggr->skb->priority = TC_PRIO_CONTROL;\n\tskb_reserve(forw_packet_aggr->skb, ETH_HLEN);\n\n\tskb_buff = skb_put(forw_packet_aggr->skb, packet_len);\n\tforw_packet_aggr->packet_len = packet_len;\n\tmemcpy(skb_buff, packet_buff, packet_len);\n\n\tforw_packet_aggr->own = own_packet;\n\tforw_packet_aggr->direct_link_flags = BATADV_NO_FLAGS;\n\tforw_packet_aggr->send_time = send_time;\n\n\t \n\tif (direct_link)\n\t\tforw_packet_aggr->direct_link_flags |= 1;\n\n\tINIT_DELAYED_WORK(&forw_packet_aggr->delayed_work,\n\t\t\t  batadv_iv_send_outstanding_bat_ogm_packet);\n\n\tbatadv_forw_packet_ogmv1_queue(bat_priv, forw_packet_aggr, send_time);\n}\n\n \nstatic void batadv_iv_ogm_aggregate(struct batadv_forw_packet *forw_packet_aggr,\n\t\t\t\t    const unsigned char *packet_buff,\n\t\t\t\t    int packet_len, bool direct_link)\n{\n\tunsigned long new_direct_link_flag;\n\n\tskb_put_data(forw_packet_aggr->skb, packet_buff, packet_len);\n\tforw_packet_aggr->packet_len += packet_len;\n\tforw_packet_aggr->num_packets++;\n\n\t \n\tif (direct_link) {\n\t\tnew_direct_link_flag = BIT(forw_packet_aggr->num_packets);\n\t\tforw_packet_aggr->direct_link_flags |= new_direct_link_flag;\n\t}\n}\n\n \nstatic void batadv_iv_ogm_queue_add(struct batadv_priv *bat_priv,\n\t\t\t\t    unsigned char *packet_buff,\n\t\t\t\t    int packet_len,\n\t\t\t\t    struct batadv_hard_iface *if_incoming,\n\t\t\t\t    struct batadv_hard_iface *if_outgoing,\n\t\t\t\t    int own_packet, unsigned long send_time)\n{\n\t \n\tstruct batadv_forw_packet *forw_packet_aggr = NULL;\n\tstruct batadv_forw_packet *forw_packet_pos = NULL;\n\tstruct batadv_ogm_packet *batadv_ogm_packet;\n\tbool direct_link;\n\tunsigned long max_aggregation_jiffies;\n\n\tbatadv_ogm_packet = (struct batadv_ogm_packet *)packet_buff;\n\tdirect_link = !!(batadv_ogm_packet->flags & BATADV_DIRECTLINK);\n\tmax_aggregation_jiffies = msecs_to_jiffies(BATADV_MAX_AGGREGATION_MS);\n\n\t \n\tspin_lock_bh(&bat_priv->forw_bat_list_lock);\n\t \n\tif (atomic_read(&bat_priv->aggregated_ogms) && !own_packet) {\n\t\thlist_for_each_entry(forw_packet_pos,\n\t\t\t\t     &bat_priv->forw_bat_list, list) {\n\t\t\tif (batadv_iv_ogm_can_aggregate(batadv_ogm_packet,\n\t\t\t\t\t\t\tbat_priv, packet_len,\n\t\t\t\t\t\t\tsend_time, direct_link,\n\t\t\t\t\t\t\tif_incoming,\n\t\t\t\t\t\t\tif_outgoing,\n\t\t\t\t\t\t\tforw_packet_pos)) {\n\t\t\t\tforw_packet_aggr = forw_packet_pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!forw_packet_aggr) {\n\t\t \n\t\tspin_unlock_bh(&bat_priv->forw_bat_list_lock);\n\n\t\t \n\t\tif (!own_packet && atomic_read(&bat_priv->aggregated_ogms))\n\t\t\tsend_time += max_aggregation_jiffies;\n\n\t\tbatadv_iv_ogm_aggregate_new(packet_buff, packet_len,\n\t\t\t\t\t    send_time, direct_link,\n\t\t\t\t\t    if_incoming, if_outgoing,\n\t\t\t\t\t    own_packet);\n\t} else {\n\t\tbatadv_iv_ogm_aggregate(forw_packet_aggr, packet_buff,\n\t\t\t\t\tpacket_len, direct_link);\n\t\tspin_unlock_bh(&bat_priv->forw_bat_list_lock);\n\t}\n}\n\nstatic void batadv_iv_ogm_forward(struct batadv_orig_node *orig_node,\n\t\t\t\t  const struct ethhdr *ethhdr,\n\t\t\t\t  struct batadv_ogm_packet *batadv_ogm_packet,\n\t\t\t\t  bool is_single_hop_neigh,\n\t\t\t\t  bool is_from_best_next_hop,\n\t\t\t\t  struct batadv_hard_iface *if_incoming,\n\t\t\t\t  struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\n\tu16 tvlv_len;\n\n\tif (batadv_ogm_packet->ttl <= 1) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv, \"ttl exceeded\\n\");\n\t\treturn;\n\t}\n\n\tif (!is_from_best_next_hop) {\n\t\t \n\t\tif (is_single_hop_neigh)\n\t\t\tbatadv_ogm_packet->flags |= BATADV_NOT_BEST_NEXT_HOP;\n\t\telse\n\t\t\treturn;\n\t}\n\n\ttvlv_len = ntohs(batadv_ogm_packet->tvlv_len);\n\n\tbatadv_ogm_packet->ttl--;\n\tether_addr_copy(batadv_ogm_packet->prev_sender, ethhdr->h_source);\n\n\t \n\tbatadv_ogm_packet->tq = batadv_hop_penalty(batadv_ogm_packet->tq,\n\t\t\t\t\t\t   bat_priv);\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Forwarding packet: tq: %i, ttl: %i\\n\",\n\t\t   batadv_ogm_packet->tq, batadv_ogm_packet->ttl);\n\n\tif (is_single_hop_neigh)\n\t\tbatadv_ogm_packet->flags |= BATADV_DIRECTLINK;\n\telse\n\t\tbatadv_ogm_packet->flags &= ~BATADV_DIRECTLINK;\n\n\tbatadv_iv_ogm_queue_add(bat_priv, (unsigned char *)batadv_ogm_packet,\n\t\t\t\tBATADV_OGM_HLEN + tvlv_len,\n\t\t\t\tif_incoming, if_outgoing, 0,\n\t\t\t\tbatadv_iv_ogm_fwd_send_time());\n}\n\n \nstatic void\nbatadv_iv_ogm_slide_own_bcast_window(struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\tstruct batadv_hashtable *hash = bat_priv->orig_hash;\n\tstruct hlist_head *head;\n\tstruct batadv_orig_node *orig_node;\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tunsigned long *word;\n\tu32 i;\n\tu8 *w;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(orig_node, head, hash_entry) {\n\t\t\thlist_for_each_entry_rcu(orig_ifinfo,\n\t\t\t\t\t\t &orig_node->ifinfo_list,\n\t\t\t\t\t\t list) {\n\t\t\t\tif (orig_ifinfo->if_outgoing != hard_iface)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tspin_lock_bh(&orig_node->bat_iv.ogm_cnt_lock);\n\t\t\t\tword = orig_ifinfo->bat_iv.bcast_own;\n\t\t\t\tbatadv_bit_get_packet(bat_priv, word, 1, 0);\n\t\t\t\tw = &orig_ifinfo->bat_iv.bcast_own_sum;\n\t\t\t\t*w = bitmap_weight(word,\n\t\t\t\t\t\t   BATADV_TQ_LOCAL_WINDOW_SIZE);\n\t\t\t\tspin_unlock_bh(&orig_node->bat_iv.ogm_cnt_lock);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\n \nstatic void batadv_iv_ogm_schedule_buff(struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\tunsigned char **ogm_buff = &hard_iface->bat_iv.ogm_buff;\n\tstruct batadv_ogm_packet *batadv_ogm_packet;\n\tstruct batadv_hard_iface *primary_if, *tmp_hard_iface;\n\tint *ogm_buff_len = &hard_iface->bat_iv.ogm_buff_len;\n\tu32 seqno;\n\tu16 tvlv_len = 0;\n\tunsigned long send_time;\n\n\tlockdep_assert_held(&hard_iface->bat_iv.ogm_buff_mutex);\n\n\t \n\tif (!*ogm_buff)\n\t\treturn;\n\n\t \n\tif (hard_iface->if_status == BATADV_IF_TO_BE_ACTIVATED)\n\t\thard_iface->if_status = BATADV_IF_ACTIVE;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\n\tif (hard_iface == primary_if) {\n\t\t \n\t\tbatadv_tt_local_commit_changes(bat_priv);\n\t\ttvlv_len = batadv_tvlv_container_ogm_append(bat_priv, ogm_buff,\n\t\t\t\t\t\t\t    ogm_buff_len,\n\t\t\t\t\t\t\t    BATADV_OGM_HLEN);\n\t}\n\n\tbatadv_ogm_packet = (struct batadv_ogm_packet *)(*ogm_buff);\n\tbatadv_ogm_packet->tvlv_len = htons(tvlv_len);\n\n\t \n\tseqno = (u32)atomic_read(&hard_iface->bat_iv.ogm_seqno);\n\tbatadv_ogm_packet->seqno = htonl(seqno);\n\tatomic_inc(&hard_iface->bat_iv.ogm_seqno);\n\n\tbatadv_iv_ogm_slide_own_bcast_window(hard_iface);\n\n\tsend_time = batadv_iv_ogm_emit_send_time(bat_priv);\n\n\tif (hard_iface != primary_if) {\n\t\t \n\t\tbatadv_iv_ogm_queue_add(bat_priv, *ogm_buff, *ogm_buff_len,\n\t\t\t\t\thard_iface, hard_iface, 1, send_time);\n\t\tgoto out;\n\t}\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(tmp_hard_iface, &batadv_hardif_list, list) {\n\t\tif (tmp_hard_iface->soft_iface != hard_iface->soft_iface)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&tmp_hard_iface->refcount))\n\t\t\tcontinue;\n\n\t\tbatadv_iv_ogm_queue_add(bat_priv, *ogm_buff,\n\t\t\t\t\t*ogm_buff_len, hard_iface,\n\t\t\t\t\ttmp_hard_iface, 1, send_time);\n\n\t\tbatadv_hardif_put(tmp_hard_iface);\n\t}\n\trcu_read_unlock();\n\nout:\n\tbatadv_hardif_put(primary_if);\n}\n\nstatic void batadv_iv_ogm_schedule(struct batadv_hard_iface *hard_iface)\n{\n\tif (hard_iface->if_status == BATADV_IF_NOT_IN_USE ||\n\t    hard_iface->if_status == BATADV_IF_TO_BE_REMOVED)\n\t\treturn;\n\n\tmutex_lock(&hard_iface->bat_iv.ogm_buff_mutex);\n\tbatadv_iv_ogm_schedule_buff(hard_iface);\n\tmutex_unlock(&hard_iface->bat_iv.ogm_buff_mutex);\n}\n\n \nstatic u8 batadv_iv_orig_ifinfo_sum(struct batadv_orig_node *orig_node,\n\t\t\t\t    struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tu8 sum;\n\n\torig_ifinfo = batadv_orig_ifinfo_get(orig_node, if_outgoing);\n\tif (!orig_ifinfo)\n\t\treturn 0;\n\n\tspin_lock_bh(&orig_node->bat_iv.ogm_cnt_lock);\n\tsum = orig_ifinfo->bat_iv.bcast_own_sum;\n\tspin_unlock_bh(&orig_node->bat_iv.ogm_cnt_lock);\n\n\tbatadv_orig_ifinfo_put(orig_ifinfo);\n\n\treturn sum;\n}\n\n \nstatic void\nbatadv_iv_ogm_orig_update(struct batadv_priv *bat_priv,\n\t\t\t  struct batadv_orig_node *orig_node,\n\t\t\t  struct batadv_orig_ifinfo *orig_ifinfo,\n\t\t\t  const struct ethhdr *ethhdr,\n\t\t\t  const struct batadv_ogm_packet *batadv_ogm_packet,\n\t\t\t  struct batadv_hard_iface *if_incoming,\n\t\t\t  struct batadv_hard_iface *if_outgoing,\n\t\t\t  enum batadv_dup_status dup_status)\n{\n\tstruct batadv_neigh_ifinfo *neigh_ifinfo = NULL;\n\tstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\n\tstruct batadv_neigh_node *neigh_node = NULL;\n\tstruct batadv_neigh_node *tmp_neigh_node = NULL;\n\tstruct batadv_neigh_node *router = NULL;\n\tu8 sum_orig, sum_neigh;\n\tu8 *neigh_addr;\n\tu8 tq_avg;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"%s(): Searching and updating originator entry of received packet\\n\",\n\t\t   __func__);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(tmp_neigh_node,\n\t\t\t\t &orig_node->neigh_list, list) {\n\t\tneigh_addr = tmp_neigh_node->addr;\n\t\tif (batadv_compare_eth(neigh_addr, ethhdr->h_source) &&\n\t\t    tmp_neigh_node->if_incoming == if_incoming &&\n\t\t    kref_get_unless_zero(&tmp_neigh_node->refcount)) {\n\t\t\tif (WARN(neigh_node, \"too many matching neigh_nodes\"))\n\t\t\t\tbatadv_neigh_node_put(neigh_node);\n\t\t\tneigh_node = tmp_neigh_node;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dup_status != BATADV_NO_DUP)\n\t\t\tcontinue;\n\n\t\t \n\t\tneigh_ifinfo = batadv_neigh_ifinfo_get(tmp_neigh_node,\n\t\t\t\t\t\t       if_outgoing);\n\t\tif (!neigh_ifinfo)\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&tmp_neigh_node->ifinfo_lock);\n\t\tbatadv_ring_buffer_set(neigh_ifinfo->bat_iv.tq_recv,\n\t\t\t\t       &neigh_ifinfo->bat_iv.tq_index, 0);\n\t\ttq_avg = batadv_ring_buffer_avg(neigh_ifinfo->bat_iv.tq_recv);\n\t\tneigh_ifinfo->bat_iv.tq_avg = tq_avg;\n\t\tspin_unlock_bh(&tmp_neigh_node->ifinfo_lock);\n\n\t\tbatadv_neigh_ifinfo_put(neigh_ifinfo);\n\t\tneigh_ifinfo = NULL;\n\t}\n\n\tif (!neigh_node) {\n\t\tstruct batadv_orig_node *orig_tmp;\n\n\t\torig_tmp = batadv_iv_ogm_orig_get(bat_priv, ethhdr->h_source);\n\t\tif (!orig_tmp)\n\t\t\tgoto unlock;\n\n\t\tneigh_node = batadv_iv_ogm_neigh_new(if_incoming,\n\t\t\t\t\t\t     ethhdr->h_source,\n\t\t\t\t\t\t     orig_node, orig_tmp);\n\n\t\tbatadv_orig_node_put(orig_tmp);\n\t\tif (!neigh_node)\n\t\t\tgoto unlock;\n\t} else {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Updating existing last-hop neighbor of originator\\n\");\n\t}\n\n\trcu_read_unlock();\n\tneigh_ifinfo = batadv_neigh_ifinfo_new(neigh_node, if_outgoing);\n\tif (!neigh_ifinfo)\n\t\tgoto out;\n\n\tneigh_node->last_seen = jiffies;\n\n\tspin_lock_bh(&neigh_node->ifinfo_lock);\n\tbatadv_ring_buffer_set(neigh_ifinfo->bat_iv.tq_recv,\n\t\t\t       &neigh_ifinfo->bat_iv.tq_index,\n\t\t\t       batadv_ogm_packet->tq);\n\ttq_avg = batadv_ring_buffer_avg(neigh_ifinfo->bat_iv.tq_recv);\n\tneigh_ifinfo->bat_iv.tq_avg = tq_avg;\n\tspin_unlock_bh(&neigh_node->ifinfo_lock);\n\n\tif (dup_status == BATADV_NO_DUP) {\n\t\torig_ifinfo->last_ttl = batadv_ogm_packet->ttl;\n\t\tneigh_ifinfo->last_ttl = batadv_ogm_packet->ttl;\n\t}\n\n\t \n\trouter = batadv_orig_router_get(orig_node, if_outgoing);\n\tif (router == neigh_node)\n\t\tgoto out;\n\n\tif (router) {\n\t\trouter_ifinfo = batadv_neigh_ifinfo_get(router, if_outgoing);\n\t\tif (!router_ifinfo)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (router_ifinfo->bat_iv.tq_avg > neigh_ifinfo->bat_iv.tq_avg)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (router_ifinfo &&\n\t    neigh_ifinfo->bat_iv.tq_avg == router_ifinfo->bat_iv.tq_avg) {\n\t\tsum_orig = batadv_iv_orig_ifinfo_sum(router->orig_node,\n\t\t\t\t\t\t     router->if_incoming);\n\t\tsum_neigh = batadv_iv_orig_ifinfo_sum(neigh_node->orig_node,\n\t\t\t\t\t\t      neigh_node->if_incoming);\n\t\tif (sum_orig >= sum_neigh)\n\t\t\tgoto out;\n\t}\n\n\tbatadv_update_route(bat_priv, orig_node, if_outgoing, neigh_node);\n\tgoto out;\n\nunlock:\n\trcu_read_unlock();\nout:\n\tbatadv_neigh_node_put(neigh_node);\n\tbatadv_neigh_node_put(router);\n\tbatadv_neigh_ifinfo_put(neigh_ifinfo);\n\tbatadv_neigh_ifinfo_put(router_ifinfo);\n}\n\n \nstatic bool batadv_iv_ogm_calc_tq(struct batadv_orig_node *orig_node,\n\t\t\t\t  struct batadv_orig_node *orig_neigh_node,\n\t\t\t\t  struct batadv_ogm_packet *batadv_ogm_packet,\n\t\t\t\t  struct batadv_hard_iface *if_incoming,\n\t\t\t\t  struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\n\tstruct batadv_neigh_node *neigh_node = NULL, *tmp_neigh_node;\n\tstruct batadv_neigh_ifinfo *neigh_ifinfo;\n\tu8 total_count;\n\tu8 orig_eq_count, neigh_rq_count, neigh_rq_inv, tq_own;\n\tunsigned int tq_iface_hop_penalty = BATADV_TQ_MAX_VALUE;\n\tunsigned int neigh_rq_inv_cube, neigh_rq_max_cube;\n\tunsigned int tq_asym_penalty, inv_asym_penalty;\n\tunsigned int combined_tq;\n\tbool ret = false;\n\n\t \n\trcu_read_lock();\n\thlist_for_each_entry_rcu(tmp_neigh_node,\n\t\t\t\t &orig_neigh_node->neigh_list, list) {\n\t\tif (!batadv_compare_eth(tmp_neigh_node->addr,\n\t\t\t\t\torig_neigh_node->orig))\n\t\t\tcontinue;\n\n\t\tif (tmp_neigh_node->if_incoming != if_incoming)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&tmp_neigh_node->refcount))\n\t\t\tcontinue;\n\n\t\tneigh_node = tmp_neigh_node;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (!neigh_node)\n\t\tneigh_node = batadv_iv_ogm_neigh_new(if_incoming,\n\t\t\t\t\t\t     orig_neigh_node->orig,\n\t\t\t\t\t\t     orig_neigh_node,\n\t\t\t\t\t\t     orig_neigh_node);\n\n\tif (!neigh_node)\n\t\tgoto out;\n\n\t \n\tif (orig_node == orig_neigh_node)\n\t\tneigh_node->last_seen = jiffies;\n\n\torig_node->last_seen = jiffies;\n\n\t \n\torig_eq_count = batadv_iv_orig_ifinfo_sum(orig_neigh_node, if_incoming);\n\tneigh_ifinfo = batadv_neigh_ifinfo_new(neigh_node, if_outgoing);\n\tif (neigh_ifinfo) {\n\t\tneigh_rq_count = neigh_ifinfo->bat_iv.real_packet_count;\n\t\tbatadv_neigh_ifinfo_put(neigh_ifinfo);\n\t} else {\n\t\tneigh_rq_count = 0;\n\t}\n\n\t \n\tif (orig_eq_count > neigh_rq_count)\n\t\ttotal_count = neigh_rq_count;\n\telse\n\t\ttotal_count = orig_eq_count;\n\n\t \n\tif (total_count < BATADV_TQ_LOCAL_BIDRECT_SEND_MINIMUM ||\n\t    neigh_rq_count < BATADV_TQ_LOCAL_BIDRECT_RECV_MINIMUM)\n\t\ttq_own = 0;\n\telse\n\t\t \n\t\ttq_own = (BATADV_TQ_MAX_VALUE * total_count) /\tneigh_rq_count;\n\n\t \n\tneigh_rq_inv = BATADV_TQ_LOCAL_WINDOW_SIZE - neigh_rq_count;\n\tneigh_rq_inv_cube = neigh_rq_inv * neigh_rq_inv * neigh_rq_inv;\n\tneigh_rq_max_cube = BATADV_TQ_LOCAL_WINDOW_SIZE *\n\t\t\t    BATADV_TQ_LOCAL_WINDOW_SIZE *\n\t\t\t    BATADV_TQ_LOCAL_WINDOW_SIZE;\n\tinv_asym_penalty = BATADV_TQ_MAX_VALUE * neigh_rq_inv_cube;\n\tinv_asym_penalty /= neigh_rq_max_cube;\n\ttq_asym_penalty = BATADV_TQ_MAX_VALUE - inv_asym_penalty;\n\ttq_iface_hop_penalty -= atomic_read(&if_incoming->hop_penalty);\n\n\t \n\tif (if_outgoing && if_incoming == if_outgoing &&\n\t    batadv_is_wifi_hardif(if_outgoing))\n\t\ttq_iface_hop_penalty = batadv_hop_penalty(tq_iface_hop_penalty,\n\t\t\t\t\t\t\t  bat_priv);\n\n\tcombined_tq = batadv_ogm_packet->tq *\n\t\t      tq_own *\n\t\t      tq_asym_penalty *\n\t\t      tq_iface_hop_penalty;\n\tcombined_tq /= BATADV_TQ_MAX_VALUE *\n\t\t       BATADV_TQ_MAX_VALUE *\n\t\t       BATADV_TQ_MAX_VALUE;\n\tbatadv_ogm_packet->tq = combined_tq;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"bidirectional: orig = %pM neigh = %pM => own_bcast = %2i, real recv = %2i, local tq: %3i, asym_penalty: %3i, iface_hop_penalty: %3i, total tq: %3i, if_incoming = %s, if_outgoing = %s\\n\",\n\t\t   orig_node->orig, orig_neigh_node->orig, total_count,\n\t\t   neigh_rq_count, tq_own, tq_asym_penalty,\n\t\t   tq_iface_hop_penalty, batadv_ogm_packet->tq,\n\t\t   if_incoming->net_dev->name,\n\t\t   if_outgoing ? if_outgoing->net_dev->name : \"DEFAULT\");\n\n\t \n\tif (batadv_ogm_packet->tq >= BATADV_TQ_TOTAL_BIDRECT_LIMIT)\n\t\tret = true;\n\nout:\n\tbatadv_neigh_node_put(neigh_node);\n\treturn ret;\n}\n\n \nstatic enum batadv_dup_status\nbatadv_iv_ogm_update_seqnos(const struct ethhdr *ethhdr,\n\t\t\t    const struct batadv_ogm_packet *batadv_ogm_packet,\n\t\t\t    const struct batadv_hard_iface *if_incoming,\n\t\t\t    struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\n\tstruct batadv_orig_node *orig_node;\n\tstruct batadv_orig_ifinfo *orig_ifinfo = NULL;\n\tstruct batadv_neigh_node *neigh_node;\n\tstruct batadv_neigh_ifinfo *neigh_ifinfo;\n\tbool is_dup;\n\ts32 seq_diff;\n\tbool need_update = false;\n\tint set_mark;\n\tenum batadv_dup_status ret = BATADV_NO_DUP;\n\tu32 seqno = ntohl(batadv_ogm_packet->seqno);\n\tu8 *neigh_addr;\n\tu8 packet_count;\n\tunsigned long *bitmap;\n\n\torig_node = batadv_iv_ogm_orig_get(bat_priv, batadv_ogm_packet->orig);\n\tif (!orig_node)\n\t\treturn BATADV_NO_DUP;\n\n\torig_ifinfo = batadv_orig_ifinfo_new(orig_node, if_outgoing);\n\tif (WARN_ON(!orig_ifinfo)) {\n\t\tbatadv_orig_node_put(orig_node);\n\t\treturn 0;\n\t}\n\n\tspin_lock_bh(&orig_node->bat_iv.ogm_cnt_lock);\n\tseq_diff = seqno - orig_ifinfo->last_real_seqno;\n\n\t \n\tif (!hlist_empty(&orig_node->neigh_list) &&\n\t    batadv_window_protected(bat_priv, seq_diff,\n\t\t\t\t    BATADV_TQ_LOCAL_WINDOW_SIZE,\n\t\t\t\t    &orig_ifinfo->batman_seqno_reset, NULL)) {\n\t\tret = BATADV_PROTECTED;\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(neigh_node, &orig_node->neigh_list, list) {\n\t\tneigh_ifinfo = batadv_neigh_ifinfo_new(neigh_node,\n\t\t\t\t\t\t       if_outgoing);\n\t\tif (!neigh_ifinfo)\n\t\t\tcontinue;\n\n\t\tneigh_addr = neigh_node->addr;\n\t\tis_dup = batadv_test_bit(neigh_ifinfo->bat_iv.real_bits,\n\t\t\t\t\t orig_ifinfo->last_real_seqno,\n\t\t\t\t\t seqno);\n\n\t\tif (batadv_compare_eth(neigh_addr, ethhdr->h_source) &&\n\t\t    neigh_node->if_incoming == if_incoming) {\n\t\t\tset_mark = 1;\n\t\t\tif (is_dup)\n\t\t\t\tret = BATADV_NEIGH_DUP;\n\t\t} else {\n\t\t\tset_mark = 0;\n\t\t\tif (is_dup && ret != BATADV_NEIGH_DUP)\n\t\t\t\tret = BATADV_ORIG_DUP;\n\t\t}\n\n\t\t \n\t\tbitmap = neigh_ifinfo->bat_iv.real_bits;\n\t\tneed_update |= batadv_bit_get_packet(bat_priv, bitmap,\n\t\t\t\t\t\t     seq_diff, set_mark);\n\n\t\tpacket_count = bitmap_weight(bitmap,\n\t\t\t\t\t     BATADV_TQ_LOCAL_WINDOW_SIZE);\n\t\tneigh_ifinfo->bat_iv.real_packet_count = packet_count;\n\t\tbatadv_neigh_ifinfo_put(neigh_ifinfo);\n\t}\n\trcu_read_unlock();\n\n\tif (need_update) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"%s updating last_seqno: old %u, new %u\\n\",\n\t\t\t   if_outgoing ? if_outgoing->net_dev->name : \"DEFAULT\",\n\t\t\t   orig_ifinfo->last_real_seqno, seqno);\n\t\torig_ifinfo->last_real_seqno = seqno;\n\t}\n\nout:\n\tspin_unlock_bh(&orig_node->bat_iv.ogm_cnt_lock);\n\tbatadv_orig_node_put(orig_node);\n\tbatadv_orig_ifinfo_put(orig_ifinfo);\n\treturn ret;\n}\n\n \nstatic void\nbatadv_iv_ogm_process_per_outif(const struct sk_buff *skb, int ogm_offset,\n\t\t\t\tstruct batadv_orig_node *orig_node,\n\t\t\t\tstruct batadv_hard_iface *if_incoming,\n\t\t\t\tstruct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\n\tstruct batadv_hardif_neigh_node *hardif_neigh = NULL;\n\tstruct batadv_neigh_node *router = NULL;\n\tstruct batadv_neigh_node *router_router = NULL;\n\tstruct batadv_orig_node *orig_neigh_node;\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tstruct batadv_neigh_node *orig_neigh_router = NULL;\n\tstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\n\tstruct batadv_ogm_packet *ogm_packet;\n\tenum batadv_dup_status dup_status;\n\tbool is_from_best_next_hop = false;\n\tbool is_single_hop_neigh = false;\n\tbool sameseq, similar_ttl;\n\tstruct sk_buff *skb_priv;\n\tstruct ethhdr *ethhdr;\n\tu8 *prev_sender;\n\tbool is_bidirect;\n\n\t \n\tskb_priv = skb_copy(skb, GFP_ATOMIC);\n\tif (!skb_priv)\n\t\treturn;\n\n\tethhdr = eth_hdr(skb_priv);\n\togm_packet = (struct batadv_ogm_packet *)(skb_priv->data + ogm_offset);\n\n\tdup_status = batadv_iv_ogm_update_seqnos(ethhdr, ogm_packet,\n\t\t\t\t\t\t if_incoming, if_outgoing);\n\tif (batadv_compare_eth(ethhdr->h_source, ogm_packet->orig))\n\t\tis_single_hop_neigh = true;\n\n\tif (dup_status == BATADV_PROTECTED) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: packet within seqno protection time (sender: %pM)\\n\",\n\t\t\t   ethhdr->h_source);\n\t\tgoto out;\n\t}\n\n\tif (ogm_packet->tq == 0) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: originator packet with tq equal 0\\n\");\n\t\tgoto out;\n\t}\n\n\tif (is_single_hop_neigh) {\n\t\thardif_neigh = batadv_hardif_neigh_get(if_incoming,\n\t\t\t\t\t\t       ethhdr->h_source);\n\t\tif (hardif_neigh)\n\t\t\thardif_neigh->last_seen = jiffies;\n\t}\n\n\trouter = batadv_orig_router_get(orig_node, if_outgoing);\n\tif (router) {\n\t\trouter_router = batadv_orig_router_get(router->orig_node,\n\t\t\t\t\t\t       if_outgoing);\n\t\trouter_ifinfo = batadv_neigh_ifinfo_get(router, if_outgoing);\n\t}\n\n\tif ((router_ifinfo && router_ifinfo->bat_iv.tq_avg != 0) &&\n\t    (batadv_compare_eth(router->addr, ethhdr->h_source)))\n\t\tis_from_best_next_hop = true;\n\n\tprev_sender = ogm_packet->prev_sender;\n\t \n\tif (router && router_router &&\n\t    (batadv_compare_eth(router->addr, prev_sender)) &&\n\t    !(batadv_compare_eth(ogm_packet->orig, prev_sender)) &&\n\t    (batadv_compare_eth(router->addr, router_router->addr))) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: ignoring all rebroadcast packets that may make me loop (sender: %pM)\\n\",\n\t\t\t   ethhdr->h_source);\n\t\tgoto out;\n\t}\n\n\tif (if_outgoing == BATADV_IF_DEFAULT)\n\t\tbatadv_tvlv_ogm_receive(bat_priv, ogm_packet, orig_node);\n\n\t \n\tif (is_single_hop_neigh)\n\t\torig_neigh_node = orig_node;\n\telse\n\t\torig_neigh_node = batadv_iv_ogm_orig_get(bat_priv,\n\t\t\t\t\t\t\t ethhdr->h_source);\n\n\tif (!orig_neigh_node)\n\t\tgoto out;\n\n\t \n\tbatadv_nc_update_nc_node(bat_priv, orig_node, orig_neigh_node,\n\t\t\t\t ogm_packet, is_single_hop_neigh);\n\n\torig_neigh_router = batadv_orig_router_get(orig_neigh_node,\n\t\t\t\t\t\t   if_outgoing);\n\n\t \n\tif (!is_single_hop_neigh && !orig_neigh_router) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: OGM via unknown neighbor!\\n\");\n\t\tgoto out_neigh;\n\t}\n\n\tis_bidirect = batadv_iv_ogm_calc_tq(orig_node, orig_neigh_node,\n\t\t\t\t\t    ogm_packet, if_incoming,\n\t\t\t\t\t    if_outgoing);\n\n\t \n\torig_ifinfo = batadv_orig_ifinfo_new(orig_node, if_outgoing);\n\tif (!orig_ifinfo)\n\t\tgoto out_neigh;\n\n\tsameseq = orig_ifinfo->last_real_seqno == ntohl(ogm_packet->seqno);\n\tsimilar_ttl = (orig_ifinfo->last_ttl - 3) <= ogm_packet->ttl;\n\n\tif (is_bidirect && (dup_status == BATADV_NO_DUP ||\n\t\t\t    (sameseq && similar_ttl))) {\n\t\tbatadv_iv_ogm_orig_update(bat_priv, orig_node,\n\t\t\t\t\t  orig_ifinfo, ethhdr,\n\t\t\t\t\t  ogm_packet, if_incoming,\n\t\t\t\t\t  if_outgoing, dup_status);\n\t}\n\tbatadv_orig_ifinfo_put(orig_ifinfo);\n\n\t \n\tif (if_outgoing == BATADV_IF_DEFAULT)\n\t\tgoto out_neigh;\n\n\t \n\tif (is_single_hop_neigh) {\n\t\t \n\t\tif (ogm_packet->ttl <= 2 &&\n\t\t    if_incoming != if_outgoing) {\n\t\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t\t   \"Drop packet: OGM from secondary interface and wrong outgoing interface\\n\");\n\t\t\tgoto out_neigh;\n\t\t}\n\t\t \n\t\tbatadv_iv_ogm_forward(orig_node, ethhdr, ogm_packet,\n\t\t\t\t      is_single_hop_neigh,\n\t\t\t\t      is_from_best_next_hop, if_incoming,\n\t\t\t\t      if_outgoing);\n\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Forwarding packet: rebroadcast neighbor packet with direct link flag\\n\");\n\t\tgoto out_neigh;\n\t}\n\n\t \n\tif (!is_bidirect) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: not received via bidirectional link\\n\");\n\t\tgoto out_neigh;\n\t}\n\n\tif (dup_status == BATADV_NEIGH_DUP) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: duplicate packet received\\n\");\n\t\tgoto out_neigh;\n\t}\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Forwarding packet: rebroadcast originator packet\\n\");\n\tbatadv_iv_ogm_forward(orig_node, ethhdr, ogm_packet,\n\t\t\t      is_single_hop_neigh, is_from_best_next_hop,\n\t\t\t      if_incoming, if_outgoing);\n\nout_neigh:\n\tif (orig_neigh_node && !is_single_hop_neigh)\n\t\tbatadv_orig_node_put(orig_neigh_node);\nout:\n\tbatadv_neigh_ifinfo_put(router_ifinfo);\n\tbatadv_neigh_node_put(router);\n\tbatadv_neigh_node_put(router_router);\n\tbatadv_neigh_node_put(orig_neigh_router);\n\tbatadv_hardif_neigh_put(hardif_neigh);\n\n\tconsume_skb(skb_priv);\n}\n\n \nstatic void batadv_iv_ogm_process_reply(struct batadv_ogm_packet *ogm_packet,\n\t\t\t\t\tstruct batadv_hard_iface *if_incoming,\n\t\t\t\t\tstruct batadv_orig_node *orig_node,\n\t\t\t\t\tu32 if_incoming_seqno)\n{\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\ts32 bit_pos;\n\tu8 *weight;\n\n\t \n\tif (!(ogm_packet->flags & BATADV_DIRECTLINK))\n\t\treturn;\n\n\tif (!batadv_compare_eth(if_incoming->net_dev->dev_addr,\n\t\t\t\togm_packet->orig))\n\t\treturn;\n\n\torig_ifinfo = batadv_orig_ifinfo_get(orig_node, if_incoming);\n\tif (!orig_ifinfo)\n\t\treturn;\n\n\t \n\tspin_lock_bh(&orig_node->bat_iv.ogm_cnt_lock);\n\tbit_pos = if_incoming_seqno - 2;\n\tbit_pos -= ntohl(ogm_packet->seqno);\n\tbatadv_set_bit(orig_ifinfo->bat_iv.bcast_own, bit_pos);\n\tweight = &orig_ifinfo->bat_iv.bcast_own_sum;\n\t*weight = bitmap_weight(orig_ifinfo->bat_iv.bcast_own,\n\t\t\t\tBATADV_TQ_LOCAL_WINDOW_SIZE);\n\tspin_unlock_bh(&orig_node->bat_iv.ogm_cnt_lock);\n\n\tbatadv_orig_ifinfo_put(orig_ifinfo);\n}\n\n \nstatic void batadv_iv_ogm_process(const struct sk_buff *skb, int ogm_offset,\n\t\t\t\t  struct batadv_hard_iface *if_incoming)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\n\tstruct batadv_orig_node *orig_neigh_node, *orig_node;\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_ogm_packet *ogm_packet;\n\tu32 if_incoming_seqno;\n\tbool has_directlink_flag;\n\tstruct ethhdr *ethhdr;\n\tbool is_my_oldorig = false;\n\tbool is_my_addr = false;\n\tbool is_my_orig = false;\n\n\togm_packet = (struct batadv_ogm_packet *)(skb->data + ogm_offset);\n\tethhdr = eth_hdr(skb);\n\n\t \n\tif (ogm_packet->packet_type != BATADV_IV_OGM)\n\t\treturn;\n\n\t \n\tif_incoming_seqno = atomic_read(&if_incoming->bat_iv.ogm_seqno);\n\n\tif (ogm_packet->flags & BATADV_DIRECTLINK)\n\t\thas_directlink_flag = true;\n\telse\n\t\thas_directlink_flag = false;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Received BATMAN packet via NB: %pM, IF: %s [%pM] (from OG: %pM, via prev OG: %pM, seqno %u, tq %d, TTL %d, V %d, IDF %d)\\n\",\n\t\t   ethhdr->h_source, if_incoming->net_dev->name,\n\t\t   if_incoming->net_dev->dev_addr, ogm_packet->orig,\n\t\t   ogm_packet->prev_sender, ntohl(ogm_packet->seqno),\n\t\t   ogm_packet->tq, ogm_packet->ttl,\n\t\t   ogm_packet->version, has_directlink_flag);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->if_status != BATADV_IF_ACTIVE)\n\t\t\tcontinue;\n\n\t\tif (hard_iface->soft_iface != if_incoming->soft_iface)\n\t\t\tcontinue;\n\n\t\tif (batadv_compare_eth(ethhdr->h_source,\n\t\t\t\t       hard_iface->net_dev->dev_addr))\n\t\t\tis_my_addr = true;\n\n\t\tif (batadv_compare_eth(ogm_packet->orig,\n\t\t\t\t       hard_iface->net_dev->dev_addr))\n\t\t\tis_my_orig = true;\n\n\t\tif (batadv_compare_eth(ogm_packet->prev_sender,\n\t\t\t\t       hard_iface->net_dev->dev_addr))\n\t\t\tis_my_oldorig = true;\n\t}\n\trcu_read_unlock();\n\n\tif (is_my_addr) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: received my own broadcast (sender: %pM)\\n\",\n\t\t\t   ethhdr->h_source);\n\t\treturn;\n\t}\n\n\tif (is_my_orig) {\n\t\torig_neigh_node = batadv_iv_ogm_orig_get(bat_priv,\n\t\t\t\t\t\t\t ethhdr->h_source);\n\t\tif (!orig_neigh_node)\n\t\t\treturn;\n\n\t\tbatadv_iv_ogm_process_reply(ogm_packet, if_incoming,\n\t\t\t\t\t    orig_neigh_node, if_incoming_seqno);\n\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: originator packet from myself (via neighbor)\\n\");\n\t\tbatadv_orig_node_put(orig_neigh_node);\n\t\treturn;\n\t}\n\n\tif (is_my_oldorig) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: ignoring all rebroadcast echos (sender: %pM)\\n\",\n\t\t\t   ethhdr->h_source);\n\t\treturn;\n\t}\n\n\tif (ogm_packet->flags & BATADV_NOT_BEST_NEXT_HOP) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: ignoring all packets not forwarded from the best next hop (sender: %pM)\\n\",\n\t\t\t   ethhdr->h_source);\n\t\treturn;\n\t}\n\n\torig_node = batadv_iv_ogm_orig_get(bat_priv, ogm_packet->orig);\n\tif (!orig_node)\n\t\treturn;\n\n\tbatadv_iv_ogm_process_per_outif(skb, ogm_offset, orig_node,\n\t\t\t\t\tif_incoming, BATADV_IF_DEFAULT);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->if_status != BATADV_IF_ACTIVE)\n\t\t\tcontinue;\n\n\t\tif (hard_iface->soft_iface != bat_priv->soft_iface)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&hard_iface->refcount))\n\t\t\tcontinue;\n\n\t\tbatadv_iv_ogm_process_per_outif(skb, ogm_offset, orig_node,\n\t\t\t\t\t\tif_incoming, hard_iface);\n\n\t\tbatadv_hardif_put(hard_iface);\n\t}\n\trcu_read_unlock();\n\n\tbatadv_orig_node_put(orig_node);\n}\n\nstatic void batadv_iv_send_outstanding_bat_ogm_packet(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work;\n\tstruct batadv_forw_packet *forw_packet;\n\tstruct batadv_priv *bat_priv;\n\tbool dropped = false;\n\n\tdelayed_work = to_delayed_work(work);\n\tforw_packet = container_of(delayed_work, struct batadv_forw_packet,\n\t\t\t\t   delayed_work);\n\tbat_priv = netdev_priv(forw_packet->if_incoming->soft_iface);\n\n\tif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING) {\n\t\tdropped = true;\n\t\tgoto out;\n\t}\n\n\tbatadv_iv_ogm_emit(forw_packet);\n\n\t \n\tif (forw_packet->own &&\n\t    forw_packet->if_incoming == forw_packet->if_outgoing)\n\t\tbatadv_iv_ogm_schedule(forw_packet->if_incoming);\n\nout:\n\t \n\tif (batadv_forw_packet_steal(forw_packet,\n\t\t\t\t     &bat_priv->forw_bat_list_lock))\n\t\tbatadv_forw_packet_free(forw_packet, dropped);\n}\n\nstatic int batadv_iv_ogm_receive(struct sk_buff *skb,\n\t\t\t\t struct batadv_hard_iface *if_incoming)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\n\tstruct batadv_ogm_packet *ogm_packet;\n\tu8 *packet_pos;\n\tint ogm_offset;\n\tbool res;\n\tint ret = NET_RX_DROP;\n\n\tres = batadv_check_management_packet(skb, if_incoming, BATADV_OGM_HLEN);\n\tif (!res)\n\t\tgoto free_skb;\n\n\t \n\tif (bat_priv->algo_ops->iface.enable != batadv_iv_ogm_iface_enable)\n\t\tgoto free_skb;\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_MGMT_RX);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_MGMT_RX_BYTES,\n\t\t\t   skb->len + ETH_HLEN);\n\n\togm_offset = 0;\n\togm_packet = (struct batadv_ogm_packet *)skb->data;\n\n\t \n\twhile (batadv_iv_ogm_aggr_packet(ogm_offset, skb_headlen(skb),\n\t\t\t\t\t ogm_packet)) {\n\t\tbatadv_iv_ogm_process(skb, ogm_offset, if_incoming);\n\n\t\togm_offset += BATADV_OGM_HLEN;\n\t\togm_offset += ntohs(ogm_packet->tvlv_len);\n\n\t\tpacket_pos = skb->data + ogm_offset;\n\t\togm_packet = (struct batadv_ogm_packet *)packet_pos;\n\t}\n\n\tret = NET_RX_SUCCESS;\n\nfree_skb:\n\tif (ret == NET_RX_SUCCESS)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\n\treturn ret;\n}\n\n \nstatic bool\nbatadv_iv_ogm_neigh_get_tq_avg(struct batadv_neigh_node *neigh_node,\n\t\t\t       struct batadv_hard_iface *if_outgoing,\n\t\t\t       u8 *tq_avg)\n{\n\tstruct batadv_neigh_ifinfo *n_ifinfo;\n\n\tn_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);\n\tif (!n_ifinfo)\n\t\treturn false;\n\n\t*tq_avg = n_ifinfo->bat_iv.tq_avg;\n\tbatadv_neigh_ifinfo_put(n_ifinfo);\n\n\treturn true;\n}\n\n \nstatic int\nbatadv_iv_ogm_orig_dump_subentry(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t\t struct batadv_priv *bat_priv,\n\t\t\t\t struct batadv_hard_iface *if_outgoing,\n\t\t\t\t struct batadv_orig_node *orig_node,\n\t\t\t\t struct batadv_neigh_node *neigh_node,\n\t\t\t\t bool best)\n{\n\tvoid *hdr;\n\tu8 tq_avg;\n\tunsigned int last_seen_msecs;\n\n\tlast_seen_msecs = jiffies_to_msecs(jiffies - orig_node->last_seen);\n\n\tif (!batadv_iv_ogm_neigh_get_tq_avg(neigh_node, if_outgoing, &tq_avg))\n\t\treturn 0;\n\n\tif (if_outgoing != BATADV_IF_DEFAULT &&\n\t    if_outgoing != neigh_node->if_incoming)\n\t\treturn 0;\n\n\thdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,\n\t\t\t  NLM_F_MULTI, BATADV_CMD_GET_ORIGINATORS);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,\n\t\t    orig_node->orig) ||\n\t    nla_put(msg, BATADV_ATTR_NEIGH_ADDRESS, ETH_ALEN,\n\t\t    neigh_node->addr) ||\n\t    nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\n\t\t\t   neigh_node->if_incoming->net_dev->name) ||\n\t    nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\n\t\t\tneigh_node->if_incoming->net_dev->ifindex) ||\n\t    nla_put_u8(msg, BATADV_ATTR_TQ, tq_avg) ||\n\t    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS,\n\t\t\tlast_seen_msecs))\n\t\tgoto nla_put_failure;\n\n\tif (best && nla_put_flag(msg, BATADV_ATTR_FLAG_BEST))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int\nbatadv_iv_ogm_orig_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t      struct batadv_priv *bat_priv,\n\t\t\t      struct batadv_hard_iface *if_outgoing,\n\t\t\t      struct batadv_orig_node *orig_node, int *sub_s)\n{\n\tstruct batadv_neigh_node *neigh_node_best;\n\tstruct batadv_neigh_node *neigh_node;\n\tint sub = 0;\n\tbool best;\n\tu8 tq_avg_best;\n\n\tneigh_node_best = batadv_orig_router_get(orig_node, if_outgoing);\n\tif (!neigh_node_best)\n\t\tgoto out;\n\n\tif (!batadv_iv_ogm_neigh_get_tq_avg(neigh_node_best, if_outgoing,\n\t\t\t\t\t    &tq_avg_best))\n\t\tgoto out;\n\n\tif (tq_avg_best == 0)\n\t\tgoto out;\n\n\thlist_for_each_entry_rcu(neigh_node, &orig_node->neigh_list, list) {\n\t\tif (sub++ < *sub_s)\n\t\t\tcontinue;\n\n\t\tbest = (neigh_node == neigh_node_best);\n\n\t\tif (batadv_iv_ogm_orig_dump_subentry(msg, portid, seq,\n\t\t\t\t\t\t     bat_priv, if_outgoing,\n\t\t\t\t\t\t     orig_node, neigh_node,\n\t\t\t\t\t\t     best)) {\n\t\t\tbatadv_neigh_node_put(neigh_node_best);\n\n\t\t\t*sub_s = sub - 1;\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n out:\n\tbatadv_neigh_node_put(neigh_node_best);\n\n\t*sub_s = 0;\n\treturn 0;\n}\n\n \nstatic int\nbatadv_iv_ogm_orig_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t       struct batadv_priv *bat_priv,\n\t\t\t       struct batadv_hard_iface *if_outgoing,\n\t\t\t       struct hlist_head *head, int *idx_s, int *sub)\n{\n\tstruct batadv_orig_node *orig_node;\n\tint idx = 0;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(orig_node, head, hash_entry) {\n\t\tif (idx++ < *idx_s)\n\t\t\tcontinue;\n\n\t\tif (batadv_iv_ogm_orig_dump_entry(msg, portid, seq, bat_priv,\n\t\t\t\t\t\t  if_outgoing, orig_node,\n\t\t\t\t\t\t  sub)) {\n\t\t\trcu_read_unlock();\n\t\t\t*idx_s = idx - 1;\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t*idx_s = 0;\n\t*sub = 0;\n\treturn 0;\n}\n\n \nstatic void\nbatadv_iv_ogm_orig_dump(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\tstruct batadv_priv *bat_priv,\n\t\t\tstruct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_hashtable *hash = bat_priv->orig_hash;\n\tstruct hlist_head *head;\n\tint bucket = cb->args[0];\n\tint idx = cb->args[1];\n\tint sub = cb->args[2];\n\tint portid = NETLINK_CB(cb->skb).portid;\n\n\twhile (bucket < hash->size) {\n\t\thead = &hash->table[bucket];\n\n\t\tif (batadv_iv_ogm_orig_dump_bucket(msg, portid,\n\t\t\t\t\t\t   cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t   bat_priv, if_outgoing, head,\n\t\t\t\t\t\t   &idx, &sub))\n\t\t\tbreak;\n\n\t\tbucket++;\n\t}\n\n\tcb->args[0] = bucket;\n\tcb->args[1] = idx;\n\tcb->args[2] = sub;\n}\n\n \nstatic bool batadv_iv_ogm_neigh_diff(struct batadv_neigh_node *neigh1,\n\t\t\t\t     struct batadv_hard_iface *if_outgoing1,\n\t\t\t\t     struct batadv_neigh_node *neigh2,\n\t\t\t\t     struct batadv_hard_iface *if_outgoing2,\n\t\t\t\t     int *diff)\n{\n\tstruct batadv_neigh_ifinfo *neigh1_ifinfo, *neigh2_ifinfo;\n\tu8 tq1, tq2;\n\tbool ret = true;\n\n\tneigh1_ifinfo = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);\n\tneigh2_ifinfo = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);\n\n\tif (!neigh1_ifinfo || !neigh2_ifinfo) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\ttq1 = neigh1_ifinfo->bat_iv.tq_avg;\n\ttq2 = neigh2_ifinfo->bat_iv.tq_avg;\n\t*diff = (int)tq1 - (int)tq2;\n\nout:\n\tbatadv_neigh_ifinfo_put(neigh1_ifinfo);\n\tbatadv_neigh_ifinfo_put(neigh2_ifinfo);\n\n\treturn ret;\n}\n\n \nstatic int\nbatadv_iv_ogm_neigh_dump_neigh(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t       struct batadv_hardif_neigh_node *hardif_neigh)\n{\n\tvoid *hdr;\n\tunsigned int last_seen_msecs;\n\n\tlast_seen_msecs = jiffies_to_msecs(jiffies - hardif_neigh->last_seen);\n\n\thdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,\n\t\t\t  NLM_F_MULTI, BATADV_CMD_GET_NEIGHBORS);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put(msg, BATADV_ATTR_NEIGH_ADDRESS, ETH_ALEN,\n\t\t    hardif_neigh->addr) ||\n\t    nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\n\t\t\t   hardif_neigh->if_incoming->net_dev->name) ||\n\t    nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\n\t\t\thardif_neigh->if_incoming->net_dev->ifindex) ||\n\t    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS,\n\t\t\tlast_seen_msecs))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int\nbatadv_iv_ogm_neigh_dump_hardif(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t\tstruct batadv_priv *bat_priv,\n\t\t\t\tstruct batadv_hard_iface *hard_iface,\n\t\t\t\tint *idx_s)\n{\n\tstruct batadv_hardif_neigh_node *hardif_neigh;\n\tint idx = 0;\n\n\thlist_for_each_entry_rcu(hardif_neigh,\n\t\t\t\t &hard_iface->neigh_list, list) {\n\t\tif (idx++ < *idx_s)\n\t\t\tcontinue;\n\n\t\tif (batadv_iv_ogm_neigh_dump_neigh(msg, portid, seq,\n\t\t\t\t\t\t   hardif_neigh)) {\n\t\t\t*idx_s = idx - 1;\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t*idx_s = 0;\n\treturn 0;\n}\n\n \nstatic void\nbatadv_iv_ogm_neigh_dump(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t struct batadv_priv *bat_priv,\n\t\t\t struct batadv_hard_iface *single_hardif)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\tint i_hardif = 0;\n\tint i_hardif_s = cb->args[0];\n\tint idx = cb->args[1];\n\tint portid = NETLINK_CB(cb->skb).portid;\n\n\trcu_read_lock();\n\tif (single_hardif) {\n\t\tif (i_hardif_s == 0) {\n\t\t\tif (batadv_iv_ogm_neigh_dump_hardif(msg, portid,\n\t\t\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t\t    bat_priv,\n\t\t\t\t\t\t\t    single_hardif,\n\t\t\t\t\t\t\t    &idx) == 0)\n\t\t\t\ti_hardif++;\n\t\t}\n\t} else {\n\t\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list,\n\t\t\t\t\tlist) {\n\t\t\tif (hard_iface->soft_iface != bat_priv->soft_iface)\n\t\t\t\tcontinue;\n\n\t\t\tif (i_hardif++ < i_hardif_s)\n\t\t\t\tcontinue;\n\n\t\t\tif (batadv_iv_ogm_neigh_dump_hardif(msg, portid,\n\t\t\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t\t    bat_priv,\n\t\t\t\t\t\t\t    hard_iface, &idx)) {\n\t\t\t\ti_hardif--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tcb->args[0] = i_hardif;\n\tcb->args[1] = idx;\n}\n\n \nstatic int batadv_iv_ogm_neigh_cmp(struct batadv_neigh_node *neigh1,\n\t\t\t\t   struct batadv_hard_iface *if_outgoing1,\n\t\t\t\t   struct batadv_neigh_node *neigh2,\n\t\t\t\t   struct batadv_hard_iface *if_outgoing2)\n{\n\tbool ret;\n\tint diff;\n\n\tret = batadv_iv_ogm_neigh_diff(neigh1, if_outgoing1, neigh2,\n\t\t\t\t       if_outgoing2, &diff);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn diff;\n}\n\n \nstatic bool\nbatadv_iv_ogm_neigh_is_sob(struct batadv_neigh_node *neigh1,\n\t\t\t   struct batadv_hard_iface *if_outgoing1,\n\t\t\t   struct batadv_neigh_node *neigh2,\n\t\t\t   struct batadv_hard_iface *if_outgoing2)\n{\n\tbool ret;\n\tint diff;\n\n\tret = batadv_iv_ogm_neigh_diff(neigh1, if_outgoing1, neigh2,\n\t\t\t\t       if_outgoing2, &diff);\n\tif (!ret)\n\t\treturn false;\n\n\tret = diff > -BATADV_TQ_SIMILARITY_THRESHOLD;\n\treturn ret;\n}\n\nstatic void batadv_iv_iface_enabled(struct batadv_hard_iface *hard_iface)\n{\n\t \n\tbatadv_iv_ogm_schedule(hard_iface);\n}\n\n \nstatic void batadv_iv_init_sel_class(struct batadv_priv *bat_priv)\n{\n\t \n\tatomic_set(&bat_priv->gw.sel_class, 20);\n}\n\nstatic struct batadv_gw_node *\nbatadv_iv_gw_get_best_gw_node(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_neigh_node *router;\n\tstruct batadv_neigh_ifinfo *router_ifinfo;\n\tstruct batadv_gw_node *gw_node, *curr_gw = NULL;\n\tu64 max_gw_factor = 0;\n\tu64 tmp_gw_factor = 0;\n\tu8 max_tq = 0;\n\tu8 tq_avg;\n\tstruct batadv_orig_node *orig_node;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {\n\t\torig_node = gw_node->orig_node;\n\t\trouter = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);\n\t\tif (!router)\n\t\t\tcontinue;\n\n\t\trouter_ifinfo = batadv_neigh_ifinfo_get(router,\n\t\t\t\t\t\t\tBATADV_IF_DEFAULT);\n\t\tif (!router_ifinfo)\n\t\t\tgoto next;\n\n\t\tif (!kref_get_unless_zero(&gw_node->refcount))\n\t\t\tgoto next;\n\n\t\ttq_avg = router_ifinfo->bat_iv.tq_avg;\n\n\t\tswitch (atomic_read(&bat_priv->gw.sel_class)) {\n\t\tcase 1:  \n\t\t\ttmp_gw_factor = tq_avg * tq_avg;\n\t\t\ttmp_gw_factor *= gw_node->bandwidth_down;\n\t\t\ttmp_gw_factor *= 100 * 100;\n\t\t\ttmp_gw_factor >>= 18;\n\n\t\t\tif (tmp_gw_factor > max_gw_factor ||\n\t\t\t    (tmp_gw_factor == max_gw_factor &&\n\t\t\t     tq_avg > max_tq)) {\n\t\t\t\tbatadv_gw_node_put(curr_gw);\n\t\t\t\tcurr_gw = gw_node;\n\t\t\t\tkref_get(&curr_gw->refcount);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:  \n\t\t\tif (tq_avg > max_tq) {\n\t\t\t\tbatadv_gw_node_put(curr_gw);\n\t\t\t\tcurr_gw = gw_node;\n\t\t\t\tkref_get(&curr_gw->refcount);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tq_avg > max_tq)\n\t\t\tmax_tq = tq_avg;\n\n\t\tif (tmp_gw_factor > max_gw_factor)\n\t\t\tmax_gw_factor = tmp_gw_factor;\n\n\t\tbatadv_gw_node_put(gw_node);\n\nnext:\n\t\tbatadv_neigh_node_put(router);\n\t\tbatadv_neigh_ifinfo_put(router_ifinfo);\n\t}\n\trcu_read_unlock();\n\n\treturn curr_gw;\n}\n\nstatic bool batadv_iv_gw_is_eligible(struct batadv_priv *bat_priv,\n\t\t\t\t     struct batadv_orig_node *curr_gw_orig,\n\t\t\t\t     struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_neigh_ifinfo *router_orig_ifinfo = NULL;\n\tstruct batadv_neigh_ifinfo *router_gw_ifinfo = NULL;\n\tstruct batadv_neigh_node *router_gw = NULL;\n\tstruct batadv_neigh_node *router_orig = NULL;\n\tu8 gw_tq_avg, orig_tq_avg;\n\tbool ret = false;\n\n\t \n\tif (atomic_read(&bat_priv->gw.sel_class) <= 2)\n\t\treturn false;\n\n\trouter_gw = batadv_orig_router_get(curr_gw_orig, BATADV_IF_DEFAULT);\n\tif (!router_gw) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\trouter_gw_ifinfo = batadv_neigh_ifinfo_get(router_gw,\n\t\t\t\t\t\t   BATADV_IF_DEFAULT);\n\tif (!router_gw_ifinfo) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\trouter_orig = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);\n\tif (!router_orig)\n\t\tgoto out;\n\n\trouter_orig_ifinfo = batadv_neigh_ifinfo_get(router_orig,\n\t\t\t\t\t\t     BATADV_IF_DEFAULT);\n\tif (!router_orig_ifinfo)\n\t\tgoto out;\n\n\tgw_tq_avg = router_gw_ifinfo->bat_iv.tq_avg;\n\torig_tq_avg = router_orig_ifinfo->bat_iv.tq_avg;\n\n\t \n\tif (orig_tq_avg < gw_tq_avg)\n\t\tgoto out;\n\n\t \n\tif ((atomic_read(&bat_priv->gw.sel_class) > 3) &&\n\t    (orig_tq_avg - gw_tq_avg < atomic_read(&bat_priv->gw.sel_class)))\n\t\tgoto out;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Restarting gateway selection: better gateway found (tq curr: %i, tq new: %i)\\n\",\n\t\t   gw_tq_avg, orig_tq_avg);\n\n\tret = true;\nout:\n\tbatadv_neigh_ifinfo_put(router_gw_ifinfo);\n\tbatadv_neigh_ifinfo_put(router_orig_ifinfo);\n\tbatadv_neigh_node_put(router_gw);\n\tbatadv_neigh_node_put(router_orig);\n\n\treturn ret;\n}\n\n \nstatic int batadv_iv_gw_dump_entry(struct sk_buff *msg, u32 portid,\n\t\t\t\t   struct netlink_callback *cb,\n\t\t\t\t   struct batadv_priv *bat_priv,\n\t\t\t\t   struct batadv_gw_node *gw_node)\n{\n\tstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\n\tstruct batadv_neigh_node *router;\n\tstruct batadv_gw_node *curr_gw = NULL;\n\tint ret = 0;\n\tvoid *hdr;\n\n\trouter = batadv_orig_router_get(gw_node->orig_node, BATADV_IF_DEFAULT);\n\tif (!router)\n\t\tgoto out;\n\n\trouter_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);\n\tif (!router_ifinfo)\n\t\tgoto out;\n\n\tcurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\n\n\thdr = genlmsg_put(msg, portid, cb->nlh->nlmsg_seq,\n\t\t\t  &batadv_netlink_family, NLM_F_MULTI,\n\t\t\t  BATADV_CMD_GET_GATEWAYS);\n\tif (!hdr) {\n\t\tret = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tret = -EMSGSIZE;\n\n\tif (curr_gw == gw_node)\n\t\tif (nla_put_flag(msg, BATADV_ATTR_FLAG_BEST)) {\n\t\t\tgenlmsg_cancel(msg, hdr);\n\t\t\tgoto out;\n\t\t}\n\n\tif (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,\n\t\t    gw_node->orig_node->orig) ||\n\t    nla_put_u8(msg, BATADV_ATTR_TQ, router_ifinfo->bat_iv.tq_avg) ||\n\t    nla_put(msg, BATADV_ATTR_ROUTER, ETH_ALEN,\n\t\t    router->addr) ||\n\t    nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\n\t\t\t   router->if_incoming->net_dev->name) ||\n\t    nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\n\t\t\trouter->if_incoming->net_dev->ifindex) ||\n\t    nla_put_u32(msg, BATADV_ATTR_BANDWIDTH_DOWN,\n\t\t\tgw_node->bandwidth_down) ||\n\t    nla_put_u32(msg, BATADV_ATTR_BANDWIDTH_UP,\n\t\t\tgw_node->bandwidth_up)) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\tgoto out;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\tret = 0;\n\nout:\n\tbatadv_gw_node_put(curr_gw);\n\tbatadv_neigh_ifinfo_put(router_ifinfo);\n\tbatadv_neigh_node_put(router);\n\treturn ret;\n}\n\n \nstatic void batadv_iv_gw_dump(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t      struct batadv_priv *bat_priv)\n{\n\tint portid = NETLINK_CB(cb->skb).portid;\n\tstruct batadv_gw_node *gw_node;\n\tint idx_skip = cb->args[0];\n\tint idx = 0;\n\n\tspin_lock_bh(&bat_priv->gw.list_lock);\n\tcb->seq = bat_priv->gw.generation << 1 | 1;\n\n\thlist_for_each_entry(gw_node, &bat_priv->gw.gateway_list, list) {\n\t\tif (idx++ < idx_skip)\n\t\t\tcontinue;\n\n\t\tif (batadv_iv_gw_dump_entry(msg, portid, cb, bat_priv,\n\t\t\t\t\t    gw_node)) {\n\t\t\tidx_skip = idx - 1;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tidx_skip = idx;\nunlock:\n\tspin_unlock_bh(&bat_priv->gw.list_lock);\n\n\tcb->args[0] = idx_skip;\n}\n\nstatic struct batadv_algo_ops batadv_batman_iv __read_mostly = {\n\t.name = \"BATMAN_IV\",\n\t.iface = {\n\t\t.enable = batadv_iv_ogm_iface_enable,\n\t\t.enabled = batadv_iv_iface_enabled,\n\t\t.disable = batadv_iv_ogm_iface_disable,\n\t\t.update_mac = batadv_iv_ogm_iface_update_mac,\n\t\t.primary_set = batadv_iv_ogm_primary_iface_set,\n\t},\n\t.neigh = {\n\t\t.cmp = batadv_iv_ogm_neigh_cmp,\n\t\t.is_similar_or_better = batadv_iv_ogm_neigh_is_sob,\n\t\t.dump = batadv_iv_ogm_neigh_dump,\n\t},\n\t.orig = {\n\t\t.dump = batadv_iv_ogm_orig_dump,\n\t},\n\t.gw = {\n\t\t.init_sel_class = batadv_iv_init_sel_class,\n\t\t.sel_class_max = BATADV_TQ_MAX_VALUE,\n\t\t.get_best_gw_node = batadv_iv_gw_get_best_gw_node,\n\t\t.is_eligible = batadv_iv_gw_is_eligible,\n\t\t.dump = batadv_iv_gw_dump,\n\t},\n};\n\n \nint __init batadv_iv_init(void)\n{\n\tint ret;\n\n\t \n\tret = batadv_recv_handler_register(BATADV_IV_OGM,\n\t\t\t\t\t   batadv_iv_ogm_receive);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = batadv_algo_register(&batadv_batman_iv);\n\tif (ret < 0)\n\t\tgoto handler_unregister;\n\n\tgoto out;\n\nhandler_unregister:\n\tbatadv_recv_handler_unregister(BATADV_IV_OGM);\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}