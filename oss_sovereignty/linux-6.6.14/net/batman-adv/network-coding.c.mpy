{
  "module_name": "network-coding.c",
  "hash_id": "bc4f225d5fcc91af44050995436eba970ff178efff42e3691ec49d180c892c21",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/network-coding.c",
  "human_readable_source": "\n \n\n#include \"network-coding.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/byteorder/generic.h>\n#include <linux/compiler.h>\n#include <linux/container_of.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/printk.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <uapi/linux/batadv_packet.h>\n\n#include \"hash.h\"\n#include \"log.h\"\n#include \"originator.h\"\n#include \"routing.h\"\n#include \"send.h\"\n#include \"tvlv.h\"\n\nstatic struct lock_class_key batadv_nc_coding_hash_lock_class_key;\nstatic struct lock_class_key batadv_nc_decoding_hash_lock_class_key;\n\nstatic void batadv_nc_worker(struct work_struct *work);\nstatic int batadv_nc_recv_coded_packet(struct sk_buff *skb,\n\t\t\t\t       struct batadv_hard_iface *recv_if);\n\n \nint __init batadv_nc_init(void)\n{\n\t \n\treturn batadv_recv_handler_register(BATADV_CODED,\n\t\t\t\t\t    batadv_nc_recv_coded_packet);\n}\n\n \nstatic void batadv_nc_start_timer(struct batadv_priv *bat_priv)\n{\n\tqueue_delayed_work(batadv_event_workqueue, &bat_priv->nc.work,\n\t\t\t   msecs_to_jiffies(10));\n}\n\n \nstatic void batadv_nc_tvlv_container_update(struct batadv_priv *bat_priv)\n{\n\tchar nc_mode;\n\n\tnc_mode = atomic_read(&bat_priv->network_coding);\n\n\tswitch (nc_mode) {\n\tcase 0:\n\t\tbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_NC, 1);\n\t\tbreak;\n\tcase 1:\n\t\tbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_NC, 1,\n\t\t\t\t\t       NULL, 0);\n\t\tbreak;\n\t}\n}\n\n \nvoid batadv_nc_status_update(struct net_device *net_dev)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(net_dev);\n\n\tbatadv_nc_tvlv_container_update(bat_priv);\n}\n\n \nstatic void batadv_nc_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,\n\t\t\t\t\t  struct batadv_orig_node *orig,\n\t\t\t\t\t  u8 flags,\n\t\t\t\t\t  void *tvlv_value, u16 tvlv_value_len)\n{\n\tif (flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND)\n\t\tclear_bit(BATADV_ORIG_CAPA_HAS_NC, &orig->capabilities);\n\telse\n\t\tset_bit(BATADV_ORIG_CAPA_HAS_NC, &orig->capabilities);\n}\n\n \nint batadv_nc_mesh_init(struct batadv_priv *bat_priv)\n{\n\tbat_priv->nc.timestamp_fwd_flush = jiffies;\n\tbat_priv->nc.timestamp_sniffed_purge = jiffies;\n\n\tif (bat_priv->nc.coding_hash || bat_priv->nc.decoding_hash)\n\t\treturn 0;\n\n\tbat_priv->nc.coding_hash = batadv_hash_new(128);\n\tif (!bat_priv->nc.coding_hash)\n\t\tgoto err;\n\n\tbatadv_hash_set_lock_class(bat_priv->nc.coding_hash,\n\t\t\t\t   &batadv_nc_coding_hash_lock_class_key);\n\n\tbat_priv->nc.decoding_hash = batadv_hash_new(128);\n\tif (!bat_priv->nc.decoding_hash) {\n\t\tbatadv_hash_destroy(bat_priv->nc.coding_hash);\n\t\tgoto err;\n\t}\n\n\tbatadv_hash_set_lock_class(bat_priv->nc.decoding_hash,\n\t\t\t\t   &batadv_nc_decoding_hash_lock_class_key);\n\n\tINIT_DELAYED_WORK(&bat_priv->nc.work, batadv_nc_worker);\n\tbatadv_nc_start_timer(bat_priv);\n\n\tbatadv_tvlv_handler_register(bat_priv, batadv_nc_tvlv_ogm_handler_v1,\n\t\t\t\t     NULL, NULL, BATADV_TVLV_NC, 1,\n\t\t\t\t     BATADV_TVLV_HANDLER_OGM_CIFNOTFND);\n\tbatadv_nc_tvlv_container_update(bat_priv);\n\treturn 0;\n\nerr:\n\treturn -ENOMEM;\n}\n\n \nvoid batadv_nc_init_bat_priv(struct batadv_priv *bat_priv)\n{\n\tatomic_set(&bat_priv->network_coding, 0);\n\tbat_priv->nc.min_tq = 200;\n\tbat_priv->nc.max_fwd_delay = 10;\n\tbat_priv->nc.max_buffer_time = 200;\n}\n\n \nvoid batadv_nc_init_orig(struct batadv_orig_node *orig_node)\n{\n\tINIT_LIST_HEAD(&orig_node->in_coding_list);\n\tINIT_LIST_HEAD(&orig_node->out_coding_list);\n\tspin_lock_init(&orig_node->in_coding_list_lock);\n\tspin_lock_init(&orig_node->out_coding_list_lock);\n}\n\n \nstatic void batadv_nc_node_release(struct kref *ref)\n{\n\tstruct batadv_nc_node *nc_node;\n\n\tnc_node = container_of(ref, struct batadv_nc_node, refcount);\n\n\tbatadv_orig_node_put(nc_node->orig_node);\n\tkfree_rcu(nc_node, rcu);\n}\n\n \nstatic void batadv_nc_node_put(struct batadv_nc_node *nc_node)\n{\n\tif (!nc_node)\n\t\treturn;\n\n\tkref_put(&nc_node->refcount, batadv_nc_node_release);\n}\n\n \nstatic void batadv_nc_path_release(struct kref *ref)\n{\n\tstruct batadv_nc_path *nc_path;\n\n\tnc_path = container_of(ref, struct batadv_nc_path, refcount);\n\n\tkfree_rcu(nc_path, rcu);\n}\n\n \nstatic void batadv_nc_path_put(struct batadv_nc_path *nc_path)\n{\n\tif (!nc_path)\n\t\treturn;\n\n\tkref_put(&nc_path->refcount, batadv_nc_path_release);\n}\n\n \nstatic void batadv_nc_packet_free(struct batadv_nc_packet *nc_packet,\n\t\t\t\t  bool dropped)\n{\n\tif (dropped)\n\t\tkfree_skb(nc_packet->skb);\n\telse\n\t\tconsume_skb(nc_packet->skb);\n\n\tbatadv_nc_path_put(nc_packet->nc_path);\n\tkfree(nc_packet);\n}\n\n \nstatic bool batadv_nc_to_purge_nc_node(struct batadv_priv *bat_priv,\n\t\t\t\t       struct batadv_nc_node *nc_node)\n{\n\tif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\n\t\treturn true;\n\n\treturn batadv_has_timed_out(nc_node->last_seen, BATADV_NC_NODE_TIMEOUT);\n}\n\n \nstatic bool batadv_nc_to_purge_nc_path_coding(struct batadv_priv *bat_priv,\n\t\t\t\t\t      struct batadv_nc_path *nc_path)\n{\n\tif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\n\t\treturn true;\n\n\t \n\treturn batadv_has_timed_out(nc_path->last_valid,\n\t\t\t\t    bat_priv->nc.max_fwd_delay * 10);\n}\n\n \nstatic bool batadv_nc_to_purge_nc_path_decoding(struct batadv_priv *bat_priv,\n\t\t\t\t\t\tstruct batadv_nc_path *nc_path)\n{\n\tif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\n\t\treturn true;\n\n\t \n\treturn batadv_has_timed_out(nc_path->last_valid,\n\t\t\t\t    bat_priv->nc.max_buffer_time * 10);\n}\n\n \nstatic void\nbatadv_nc_purge_orig_nc_nodes(struct batadv_priv *bat_priv,\n\t\t\t      struct list_head *list,\n\t\t\t      spinlock_t *lock,\n\t\t\t      bool (*to_purge)(struct batadv_priv *,\n\t\t\t\t\t       struct batadv_nc_node *))\n{\n\tstruct batadv_nc_node *nc_node, *nc_node_tmp;\n\n\t \n\tspin_lock_bh(lock);\n\tlist_for_each_entry_safe(nc_node, nc_node_tmp, list, list) {\n\t\t \n\t\tif (to_purge && !to_purge(bat_priv, nc_node))\n\t\t\tcontinue;\n\n\t\tbatadv_dbg(BATADV_DBG_NC, bat_priv,\n\t\t\t   \"Removing nc_node %pM -> %pM\\n\",\n\t\t\t   nc_node->addr, nc_node->orig_node->orig);\n\t\tlist_del_rcu(&nc_node->list);\n\t\tbatadv_nc_node_put(nc_node);\n\t}\n\tspin_unlock_bh(lock);\n}\n\n \nvoid batadv_nc_purge_orig(struct batadv_priv *bat_priv,\n\t\t\t  struct batadv_orig_node *orig_node,\n\t\t\t  bool (*to_purge)(struct batadv_priv *,\n\t\t\t\t\t   struct batadv_nc_node *))\n{\n\t \n\tbatadv_nc_purge_orig_nc_nodes(bat_priv, &orig_node->in_coding_list,\n\t\t\t\t      &orig_node->in_coding_list_lock,\n\t\t\t\t      to_purge);\n\n\t \n\tbatadv_nc_purge_orig_nc_nodes(bat_priv, &orig_node->out_coding_list,\n\t\t\t\t      &orig_node->out_coding_list_lock,\n\t\t\t\t      to_purge);\n}\n\n \nstatic void batadv_nc_purge_orig_hash(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_hashtable *hash = bat_priv->orig_hash;\n\tstruct hlist_head *head;\n\tstruct batadv_orig_node *orig_node;\n\tu32 i;\n\n\tif (!hash)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(orig_node, head, hash_entry)\n\t\t\tbatadv_nc_purge_orig(bat_priv, orig_node,\n\t\t\t\t\t     batadv_nc_to_purge_nc_node);\n\t\trcu_read_unlock();\n\t}\n}\n\n \nstatic void batadv_nc_purge_paths(struct batadv_priv *bat_priv,\n\t\t\t\t  struct batadv_hashtable *hash,\n\t\t\t\t  bool (*to_purge)(struct batadv_priv *,\n\t\t\t\t\t\t   struct batadv_nc_path *))\n{\n\tstruct hlist_head *head;\n\tstruct hlist_node *node_tmp;\n\tstruct batadv_nc_path *nc_path;\n\tspinlock_t *lock;  \n\tu32 i;\n\n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\t\tlock = &hash->list_locks[i];\n\n\t\t \n\t\tspin_lock_bh(lock);\n\t\thlist_for_each_entry_safe(nc_path, node_tmp, head, hash_entry) {\n\t\t\t \n\t\t\tif (to_purge && !to_purge(bat_priv, nc_path))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!unlikely(list_empty(&nc_path->packet_list))) {\n\t\t\t\tnet_ratelimited_function(printk,\n\t\t\t\t\t\t\t KERN_WARNING\n\t\t\t\t\t\t\t \"Skipping free of non-empty nc_path (%pM -> %pM)!\\n\",\n\t\t\t\t\t\t\t nc_path->prev_hop,\n\t\t\t\t\t\t\t nc_path->next_hop);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tbatadv_dbg(BATADV_DBG_NC, bat_priv,\n\t\t\t\t   \"Remove nc_path %pM -> %pM\\n\",\n\t\t\t\t   nc_path->prev_hop, nc_path->next_hop);\n\t\t\thlist_del_rcu(&nc_path->hash_entry);\n\t\t\tbatadv_nc_path_put(nc_path);\n\t\t}\n\t\tspin_unlock_bh(lock);\n\t}\n}\n\n \nstatic void batadv_nc_hash_key_gen(struct batadv_nc_path *key, const char *src,\n\t\t\t\t   const char *dst)\n{\n\tmemcpy(key->prev_hop, src, sizeof(key->prev_hop));\n\tmemcpy(key->next_hop, dst, sizeof(key->next_hop));\n}\n\n \nstatic u32 batadv_nc_hash_choose(const void *data, u32 size)\n{\n\tconst struct batadv_nc_path *nc_path = data;\n\tu32 hash = 0;\n\n\thash = jhash(&nc_path->prev_hop, sizeof(nc_path->prev_hop), hash);\n\thash = jhash(&nc_path->next_hop, sizeof(nc_path->next_hop), hash);\n\n\treturn hash % size;\n}\n\n \nstatic bool batadv_nc_hash_compare(const struct hlist_node *node,\n\t\t\t\t   const void *data2)\n{\n\tconst struct batadv_nc_path *nc_path1, *nc_path2;\n\n\tnc_path1 = container_of(node, struct batadv_nc_path, hash_entry);\n\tnc_path2 = data2;\n\n\t \n\tif (!batadv_compare_eth(nc_path1->prev_hop, nc_path2->prev_hop))\n\t\treturn false;\n\n\tif (!batadv_compare_eth(nc_path1->next_hop, nc_path2->next_hop))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic struct batadv_nc_path *\nbatadv_nc_hash_find(struct batadv_hashtable *hash,\n\t\t    void *data)\n{\n\tstruct hlist_head *head;\n\tstruct batadv_nc_path *nc_path, *nc_path_tmp = NULL;\n\tint index;\n\n\tif (!hash)\n\t\treturn NULL;\n\n\tindex = batadv_nc_hash_choose(data, hash->size);\n\thead = &hash->table[index];\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(nc_path, head, hash_entry) {\n\t\tif (!batadv_nc_hash_compare(&nc_path->hash_entry, data))\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&nc_path->refcount))\n\t\t\tcontinue;\n\n\t\tnc_path_tmp = nc_path;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn nc_path_tmp;\n}\n\n \nstatic void batadv_nc_send_packet(struct batadv_nc_packet *nc_packet)\n{\n\tbatadv_send_unicast_skb(nc_packet->skb, nc_packet->neigh_node);\n\tnc_packet->skb = NULL;\n\tbatadv_nc_packet_free(nc_packet, false);\n}\n\n \nstatic bool batadv_nc_sniffed_purge(struct batadv_priv *bat_priv,\n\t\t\t\t    struct batadv_nc_path *nc_path,\n\t\t\t\t    struct batadv_nc_packet *nc_packet)\n{\n\tunsigned long timeout = bat_priv->nc.max_buffer_time;\n\tbool res = false;\n\n\tlockdep_assert_held(&nc_path->packet_list_lock);\n\n\t \n\tif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_ACTIVE &&\n\t    !batadv_has_timed_out(nc_packet->timestamp, timeout))\n\t\tgoto out;\n\n\t \n\tlist_del(&nc_packet->list);\n\tbatadv_nc_packet_free(nc_packet, true);\n\n\tres = true;\n\nout:\n\treturn res;\n}\n\n \nstatic bool batadv_nc_fwd_flush(struct batadv_priv *bat_priv,\n\t\t\t\tstruct batadv_nc_path *nc_path,\n\t\t\t\tstruct batadv_nc_packet *nc_packet)\n{\n\tunsigned long timeout = bat_priv->nc.max_fwd_delay;\n\n\tlockdep_assert_held(&nc_path->packet_list_lock);\n\n\t \n\tif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_ACTIVE &&\n\t    !batadv_has_timed_out(nc_packet->timestamp, timeout))\n\t\treturn false;\n\n\t \n\tbatadv_inc_counter(bat_priv, BATADV_CNT_FORWARD);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_FORWARD_BYTES,\n\t\t\t   nc_packet->skb->len + ETH_HLEN);\n\tlist_del(&nc_packet->list);\n\tbatadv_nc_send_packet(nc_packet);\n\n\treturn true;\n}\n\n \nstatic void\nbatadv_nc_process_nc_paths(struct batadv_priv *bat_priv,\n\t\t\t   struct batadv_hashtable *hash,\n\t\t\t   bool (*process_fn)(struct batadv_priv *,\n\t\t\t\t\t      struct batadv_nc_path *,\n\t\t\t\t\t      struct batadv_nc_packet *))\n{\n\tstruct hlist_head *head;\n\tstruct batadv_nc_packet *nc_packet, *nc_packet_tmp;\n\tstruct batadv_nc_path *nc_path;\n\tbool ret;\n\tint i;\n\n\tif (!hash)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < hash->size; i++) {\n\t\thead = &hash->table[i];\n\n\t\t \n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(nc_path, head, hash_entry) {\n\t\t\t \n\t\t\tspin_lock_bh(&nc_path->packet_list_lock);\n\t\t\tlist_for_each_entry_safe(nc_packet, nc_packet_tmp,\n\t\t\t\t\t\t &nc_path->packet_list, list) {\n\t\t\t\tret = process_fn(bat_priv, nc_path, nc_packet);\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_bh(&nc_path->packet_list_lock);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\n \nstatic void batadv_nc_worker(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work;\n\tstruct batadv_priv_nc *priv_nc;\n\tstruct batadv_priv *bat_priv;\n\tunsigned long timeout;\n\n\tdelayed_work = to_delayed_work(work);\n\tpriv_nc = container_of(delayed_work, struct batadv_priv_nc, work);\n\tbat_priv = container_of(priv_nc, struct batadv_priv, nc);\n\n\tbatadv_nc_purge_orig_hash(bat_priv);\n\tbatadv_nc_purge_paths(bat_priv, bat_priv->nc.coding_hash,\n\t\t\t      batadv_nc_to_purge_nc_path_coding);\n\tbatadv_nc_purge_paths(bat_priv, bat_priv->nc.decoding_hash,\n\t\t\t      batadv_nc_to_purge_nc_path_decoding);\n\n\ttimeout = bat_priv->nc.max_fwd_delay;\n\n\tif (batadv_has_timed_out(bat_priv->nc.timestamp_fwd_flush, timeout)) {\n\t\tbatadv_nc_process_nc_paths(bat_priv, bat_priv->nc.coding_hash,\n\t\t\t\t\t   batadv_nc_fwd_flush);\n\t\tbat_priv->nc.timestamp_fwd_flush = jiffies;\n\t}\n\n\tif (batadv_has_timed_out(bat_priv->nc.timestamp_sniffed_purge,\n\t\t\t\t bat_priv->nc.max_buffer_time)) {\n\t\tbatadv_nc_process_nc_paths(bat_priv, bat_priv->nc.decoding_hash,\n\t\t\t\t\t   batadv_nc_sniffed_purge);\n\t\tbat_priv->nc.timestamp_sniffed_purge = jiffies;\n\t}\n\n\t \n\tbatadv_nc_start_timer(bat_priv);\n}\n\n \nstatic bool batadv_can_nc_with_orig(struct batadv_priv *bat_priv,\n\t\t\t\t    struct batadv_orig_node *orig_node,\n\t\t\t\t    struct batadv_ogm_packet *ogm_packet)\n{\n\tstruct batadv_orig_ifinfo *orig_ifinfo;\n\tu32 last_real_seqno;\n\tu8 last_ttl;\n\n\torig_ifinfo = batadv_orig_ifinfo_get(orig_node, BATADV_IF_DEFAULT);\n\tif (!orig_ifinfo)\n\t\treturn false;\n\n\tlast_ttl = orig_ifinfo->last_ttl;\n\tlast_real_seqno = orig_ifinfo->last_real_seqno;\n\tbatadv_orig_ifinfo_put(orig_ifinfo);\n\n\tif (last_real_seqno != ntohl(ogm_packet->seqno))\n\t\treturn false;\n\tif (last_ttl != ogm_packet->ttl + 1)\n\t\treturn false;\n\tif (!batadv_compare_eth(ogm_packet->orig, ogm_packet->prev_sender))\n\t\treturn false;\n\tif (ogm_packet->tq < bat_priv->nc.min_tq)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic struct batadv_nc_node *\nbatadv_nc_find_nc_node(struct batadv_orig_node *orig_node,\n\t\t       struct batadv_orig_node *orig_neigh_node,\n\t\t       bool in_coding)\n{\n\tstruct batadv_nc_node *nc_node, *nc_node_out = NULL;\n\tstruct list_head *list;\n\n\tif (in_coding)\n\t\tlist = &orig_neigh_node->in_coding_list;\n\telse\n\t\tlist = &orig_neigh_node->out_coding_list;\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(nc_node, list, list) {\n\t\tif (!batadv_compare_eth(nc_node->addr, orig_node->orig))\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&nc_node->refcount))\n\t\t\tcontinue;\n\n\t\t \n\t\tnc_node_out = nc_node;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn nc_node_out;\n}\n\n \nstatic struct batadv_nc_node *\nbatadv_nc_get_nc_node(struct batadv_priv *bat_priv,\n\t\t      struct batadv_orig_node *orig_node,\n\t\t      struct batadv_orig_node *orig_neigh_node,\n\t\t      bool in_coding)\n{\n\tstruct batadv_nc_node *nc_node;\n\tspinlock_t *lock;  \n\tstruct list_head *list;\n\n\t \n\tif (in_coding) {\n\t\tlock = &orig_neigh_node->in_coding_list_lock;\n\t\tlist = &orig_neigh_node->in_coding_list;\n\t} else {\n\t\tlock = &orig_neigh_node->out_coding_list_lock;\n\t\tlist = &orig_neigh_node->out_coding_list;\n\t}\n\n\tspin_lock_bh(lock);\n\n\t \n\tnc_node = batadv_nc_find_nc_node(orig_node, orig_neigh_node, in_coding);\n\n\t \n\tif (nc_node)\n\t\tgoto unlock;\n\n\tnc_node = kzalloc(sizeof(*nc_node), GFP_ATOMIC);\n\tif (!nc_node)\n\t\tgoto unlock;\n\n\t \n\tINIT_LIST_HEAD(&nc_node->list);\n\tkref_init(&nc_node->refcount);\n\tether_addr_copy(nc_node->addr, orig_node->orig);\n\tkref_get(&orig_neigh_node->refcount);\n\tnc_node->orig_node = orig_neigh_node;\n\n\tbatadv_dbg(BATADV_DBG_NC, bat_priv, \"Adding nc_node %pM -> %pM\\n\",\n\t\t   nc_node->addr, nc_node->orig_node->orig);\n\n\t \n\tkref_get(&nc_node->refcount);\n\tlist_add_tail_rcu(&nc_node->list, list);\n\nunlock:\n\tspin_unlock_bh(lock);\n\n\treturn nc_node;\n}\n\n \nvoid batadv_nc_update_nc_node(struct batadv_priv *bat_priv,\n\t\t\t      struct batadv_orig_node *orig_node,\n\t\t\t      struct batadv_orig_node *orig_neigh_node,\n\t\t\t      struct batadv_ogm_packet *ogm_packet,\n\t\t\t      int is_single_hop_neigh)\n{\n\tstruct batadv_nc_node *in_nc_node = NULL;\n\tstruct batadv_nc_node *out_nc_node = NULL;\n\n\t \n\tif (!atomic_read(&bat_priv->network_coding))\n\t\tgoto out;\n\n\t \n\tif (!test_bit(BATADV_ORIG_CAPA_HAS_NC, &orig_node->capabilities))\n\t\tgoto out;\n\n\t \n\tif (!batadv_can_nc_with_orig(bat_priv, orig_node, ogm_packet) &&\n\t    !is_single_hop_neigh)\n\t\tgoto out;\n\n\t \n\tin_nc_node = batadv_nc_get_nc_node(bat_priv, orig_node,\n\t\t\t\t\t   orig_neigh_node, true);\n\tif (!in_nc_node)\n\t\tgoto out;\n\n\tin_nc_node->last_seen = jiffies;\n\n\t \n\tout_nc_node = batadv_nc_get_nc_node(bat_priv, orig_neigh_node,\n\t\t\t\t\t    orig_node, false);\n\tif (!out_nc_node)\n\t\tgoto out;\n\n\tout_nc_node->last_seen = jiffies;\n\nout:\n\tbatadv_nc_node_put(in_nc_node);\n\tbatadv_nc_node_put(out_nc_node);\n}\n\n \nstatic struct batadv_nc_path *batadv_nc_get_path(struct batadv_priv *bat_priv,\n\t\t\t\t\t\t struct batadv_hashtable *hash,\n\t\t\t\t\t\t u8 *src,\n\t\t\t\t\t\t u8 *dst)\n{\n\tint hash_added;\n\tstruct batadv_nc_path *nc_path, nc_path_key;\n\n\tbatadv_nc_hash_key_gen(&nc_path_key, src, dst);\n\n\t \n\tnc_path = batadv_nc_hash_find(hash, (void *)&nc_path_key);\n\n\tif (nc_path) {\n\t\t \n\t\tnc_path->last_valid = jiffies;\n\t\treturn nc_path;\n\t}\n\n\t \n\tnc_path = kzalloc(sizeof(*nc_path), GFP_ATOMIC);\n\n\tif (!nc_path)\n\t\treturn NULL;\n\n\t \n\tINIT_LIST_HEAD(&nc_path->packet_list);\n\tspin_lock_init(&nc_path->packet_list_lock);\n\tkref_init(&nc_path->refcount);\n\tnc_path->last_valid = jiffies;\n\tether_addr_copy(nc_path->next_hop, dst);\n\tether_addr_copy(nc_path->prev_hop, src);\n\n\tbatadv_dbg(BATADV_DBG_NC, bat_priv, \"Adding nc_path %pM -> %pM\\n\",\n\t\t   nc_path->prev_hop,\n\t\t   nc_path->next_hop);\n\n\t \n\tkref_get(&nc_path->refcount);\n\thash_added = batadv_hash_add(hash, batadv_nc_hash_compare,\n\t\t\t\t     batadv_nc_hash_choose, &nc_path_key,\n\t\t\t\t     &nc_path->hash_entry);\n\n\tif (hash_added < 0) {\n\t\tkfree(nc_path);\n\t\treturn NULL;\n\t}\n\n\treturn nc_path;\n}\n\n \nstatic u8 batadv_nc_random_weight_tq(u8 tq)\n{\n\t \n\tu8 rand_tq = get_random_u32_below(BATADV_TQ_MAX_VALUE + 1 - tq);\n\n\t \n\treturn BATADV_TQ_MAX_VALUE - rand_tq;\n}\n\n \nstatic void batadv_nc_memxor(char *dst, const char *src, unsigned int len)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < len; ++i)\n\t\tdst[i] ^= src[i];\n}\n\n \nstatic bool batadv_nc_code_packets(struct batadv_priv *bat_priv,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct ethhdr *ethhdr,\n\t\t\t\t   struct batadv_nc_packet *nc_packet,\n\t\t\t\t   struct batadv_neigh_node *neigh_node)\n{\n\tu8 tq_weighted_neigh, tq_weighted_coding, tq_tmp;\n\tstruct sk_buff *skb_dest, *skb_src;\n\tstruct batadv_unicast_packet *packet1;\n\tstruct batadv_unicast_packet *packet2;\n\tstruct batadv_coded_packet *coded_packet;\n\tstruct batadv_neigh_node *neigh_tmp, *router_neigh, *first_dest;\n\tstruct batadv_neigh_node *router_coding = NULL, *second_dest;\n\tstruct batadv_neigh_ifinfo *router_neigh_ifinfo = NULL;\n\tstruct batadv_neigh_ifinfo *router_coding_ifinfo = NULL;\n\tu8 *first_source, *second_source;\n\t__be32 packet_id1, packet_id2;\n\tsize_t count;\n\tbool res = false;\n\tint coding_len;\n\tint unicast_size = sizeof(*packet1);\n\tint coded_size = sizeof(*coded_packet);\n\tint header_add = coded_size - unicast_size;\n\n\t \n\trouter_neigh = batadv_orig_router_get(neigh_node->orig_node,\n\t\t\t\t\t      BATADV_IF_DEFAULT);\n\tif (!router_neigh)\n\t\tgoto out;\n\n\trouter_neigh_ifinfo = batadv_neigh_ifinfo_get(router_neigh,\n\t\t\t\t\t\t      BATADV_IF_DEFAULT);\n\tif (!router_neigh_ifinfo)\n\t\tgoto out;\n\n\tneigh_tmp = nc_packet->neigh_node;\n\trouter_coding = batadv_orig_router_get(neigh_tmp->orig_node,\n\t\t\t\t\t       BATADV_IF_DEFAULT);\n\tif (!router_coding)\n\t\tgoto out;\n\n\trouter_coding_ifinfo = batadv_neigh_ifinfo_get(router_coding,\n\t\t\t\t\t\t       BATADV_IF_DEFAULT);\n\tif (!router_coding_ifinfo)\n\t\tgoto out;\n\n\ttq_tmp = router_neigh_ifinfo->bat_iv.tq_avg;\n\ttq_weighted_neigh = batadv_nc_random_weight_tq(tq_tmp);\n\ttq_tmp = router_coding_ifinfo->bat_iv.tq_avg;\n\ttq_weighted_coding = batadv_nc_random_weight_tq(tq_tmp);\n\n\t \n\tif (tq_weighted_neigh >= tq_weighted_coding) {\n\t\t \n\t\tfirst_dest = nc_packet->neigh_node;\n\t\tfirst_source = nc_packet->nc_path->prev_hop;\n\t\tsecond_dest = neigh_node;\n\t\tsecond_source = ethhdr->h_source;\n\t\tpacket1 = (struct batadv_unicast_packet *)nc_packet->skb->data;\n\t\tpacket2 = (struct batadv_unicast_packet *)skb->data;\n\t\tpacket_id1 = nc_packet->packet_id;\n\t\tpacket_id2 = batadv_skb_crc32(skb,\n\t\t\t\t\t      skb->data + sizeof(*packet2));\n\t} else {\n\t\t \n\t\tfirst_dest = neigh_node;\n\t\tfirst_source = ethhdr->h_source;\n\t\tsecond_dest = nc_packet->neigh_node;\n\t\tsecond_source = nc_packet->nc_path->prev_hop;\n\t\tpacket1 = (struct batadv_unicast_packet *)skb->data;\n\t\tpacket2 = (struct batadv_unicast_packet *)nc_packet->skb->data;\n\t\tpacket_id1 = batadv_skb_crc32(skb,\n\t\t\t\t\t      skb->data + sizeof(*packet1));\n\t\tpacket_id2 = nc_packet->packet_id;\n\t}\n\n\t \n\tif (skb->len <= nc_packet->skb->len) {\n\t\tskb_dest = nc_packet->skb;\n\t\tskb_src = skb;\n\t} else {\n\t\tskb_dest = skb;\n\t\tskb_src = nc_packet->skb;\n\t}\n\n\t \n\tcoding_len = skb_src->len - unicast_size;\n\n\tif (skb_linearize(skb_dest) < 0 || skb_linearize(skb_src) < 0)\n\t\tgoto out;\n\n\tskb_push(skb_dest, header_add);\n\n\tcoded_packet = (struct batadv_coded_packet *)skb_dest->data;\n\tskb_reset_mac_header(skb_dest);\n\n\tcoded_packet->packet_type = BATADV_CODED;\n\tcoded_packet->version = BATADV_COMPAT_VERSION;\n\tcoded_packet->ttl = packet1->ttl;\n\n\t \n\tether_addr_copy(coded_packet->first_source, first_source);\n\tether_addr_copy(coded_packet->first_orig_dest, packet1->dest);\n\tcoded_packet->first_crc = packet_id1;\n\tcoded_packet->first_ttvn = packet1->ttvn;\n\n\t \n\tether_addr_copy(coded_packet->second_dest, second_dest->addr);\n\tether_addr_copy(coded_packet->second_source, second_source);\n\tether_addr_copy(coded_packet->second_orig_dest, packet2->dest);\n\tcoded_packet->second_crc = packet_id2;\n\tcoded_packet->second_ttl = packet2->ttl;\n\tcoded_packet->second_ttvn = packet2->ttvn;\n\tcoded_packet->coded_len = htons(coding_len);\n\n\t \n\tbatadv_nc_memxor(skb_dest->data + coded_size,\n\t\t\t skb_src->data + unicast_size, coding_len);\n\n\t \n\tif (BATADV_SKB_CB(skb_src)->decoded &&\n\t    BATADV_SKB_CB(skb_dest)->decoded) {\n\t\t \n\t\tcount = skb_src->len + ETH_HLEN;\n\t\tcount += skb_dest->len + ETH_HLEN;\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_NC_RECODE, 2);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_NC_RECODE_BYTES, count);\n\t} else if (!BATADV_SKB_CB(skb_src)->decoded &&\n\t\t   !BATADV_SKB_CB(skb_dest)->decoded) {\n\t\t \n\t\tcount = skb_src->len + ETH_HLEN;\n\t\tcount += skb_dest->len + ETH_HLEN;\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_NC_CODE, 2);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_NC_CODE_BYTES, count);\n\t} else if (BATADV_SKB_CB(skb_src)->decoded &&\n\t\t   !BATADV_SKB_CB(skb_dest)->decoded) {\n\t\t \n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_NC_RECODE);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_NC_RECODE_BYTES,\n\t\t\t\t   skb_src->len + ETH_HLEN);\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_NC_CODE);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_NC_CODE_BYTES,\n\t\t\t\t   skb_dest->len + ETH_HLEN);\n\t} else if (!BATADV_SKB_CB(skb_src)->decoded &&\n\t\t   BATADV_SKB_CB(skb_dest)->decoded) {\n\t\t \n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_NC_CODE);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_NC_CODE_BYTES,\n\t\t\t\t   skb_src->len + ETH_HLEN);\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_NC_RECODE);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_NC_RECODE_BYTES,\n\t\t\t\t   skb_dest->len + ETH_HLEN);\n\t}\n\n\t \n\tconsume_skb(skb_src);\n\n\t \n\tnc_packet->skb = NULL;\n\tbatadv_nc_packet_free(nc_packet, false);\n\n\t \n\tbatadv_send_unicast_skb(skb_dest, first_dest);\n\tres = true;\nout:\n\tbatadv_neigh_node_put(router_neigh);\n\tbatadv_neigh_node_put(router_coding);\n\tbatadv_neigh_ifinfo_put(router_neigh_ifinfo);\n\tbatadv_neigh_ifinfo_put(router_coding_ifinfo);\n\treturn res;\n}\n\n \nstatic bool batadv_nc_skb_coding_possible(struct sk_buff *skb, u8 *dst, u8 *src)\n{\n\tif (BATADV_SKB_CB(skb)->decoded && !batadv_compare_eth(dst, src))\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic struct batadv_nc_packet *\nbatadv_nc_path_search(struct batadv_priv *bat_priv,\n\t\t      struct batadv_nc_node *in_nc_node,\n\t\t      struct batadv_nc_node *out_nc_node,\n\t\t      struct sk_buff *skb,\n\t\t      u8 *eth_dst)\n{\n\tstruct batadv_nc_path *nc_path, nc_path_key;\n\tstruct batadv_nc_packet *nc_packet_out = NULL;\n\tstruct batadv_nc_packet *nc_packet, *nc_packet_tmp;\n\tstruct batadv_hashtable *hash = bat_priv->nc.coding_hash;\n\tint idx;\n\n\tif (!hash)\n\t\treturn NULL;\n\n\t \n\tbatadv_nc_hash_key_gen(&nc_path_key, in_nc_node->addr,\n\t\t\t       out_nc_node->addr);\n\tidx = batadv_nc_hash_choose(&nc_path_key, hash->size);\n\n\t \n\trcu_read_lock();\n\thlist_for_each_entry_rcu(nc_path, &hash->table[idx], hash_entry) {\n\t\tif (!batadv_compare_eth(nc_path->prev_hop, in_nc_node->addr))\n\t\t\tcontinue;\n\n\t\tif (!batadv_compare_eth(nc_path->next_hop, out_nc_node->addr))\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&nc_path->packet_list_lock);\n\t\tif (list_empty(&nc_path->packet_list)) {\n\t\t\tspin_unlock_bh(&nc_path->packet_list_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_for_each_entry_safe(nc_packet, nc_packet_tmp,\n\t\t\t\t\t &nc_path->packet_list, list) {\n\t\t\tif (!batadv_nc_skb_coding_possible(nc_packet->skb,\n\t\t\t\t\t\t\t   eth_dst,\n\t\t\t\t\t\t\t   in_nc_node->addr))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tlist_del(&nc_packet->list);\n\t\t\tnc_packet_out = nc_packet;\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock_bh(&nc_path->packet_list_lock);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn nc_packet_out;\n}\n\n \nstatic struct batadv_nc_packet *\nbatadv_nc_skb_src_search(struct batadv_priv *bat_priv,\n\t\t\t struct sk_buff *skb,\n\t\t\t u8 *eth_dst,\n\t\t\t u8 *eth_src,\n\t\t\t struct batadv_nc_node *in_nc_node)\n{\n\tstruct batadv_orig_node *orig_node;\n\tstruct batadv_nc_node *out_nc_node;\n\tstruct batadv_nc_packet *nc_packet = NULL;\n\n\torig_node = batadv_orig_hash_find(bat_priv, eth_src);\n\tif (!orig_node)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(out_nc_node,\n\t\t\t\t&orig_node->out_coding_list, list) {\n\t\t \n\t\tif (!batadv_nc_skb_coding_possible(skb,\n\t\t\t\t\t\t   out_nc_node->addr, eth_src))\n\t\t\tcontinue;\n\n\t\t \n\t\tnc_packet = batadv_nc_path_search(bat_priv, in_nc_node,\n\t\t\t\t\t\t  out_nc_node, skb, eth_dst);\n\t\tif (nc_packet)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tbatadv_orig_node_put(orig_node);\n\treturn nc_packet;\n}\n\n \nstatic void batadv_nc_skb_store_before_coding(struct batadv_priv *bat_priv,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      u8 *eth_dst_new)\n{\n\tstruct ethhdr *ethhdr;\n\n\t \n\tskb = pskb_copy_for_clone(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\t \n\tethhdr = eth_hdr(skb);\n\tether_addr_copy(ethhdr->h_source, ethhdr->h_dest);\n\tether_addr_copy(ethhdr->h_dest, eth_dst_new);\n\n\t \n\tskb_push(skb, ETH_HLEN);\n\n\t \n\tbatadv_nc_skb_store_for_decoding(bat_priv, skb);\n\n\t \n\tconsume_skb(skb);\n}\n\n \nstatic bool batadv_nc_skb_dst_search(struct sk_buff *skb,\n\t\t\t\t     struct batadv_neigh_node *neigh_node,\n\t\t\t\t     struct ethhdr *ethhdr)\n{\n\tstruct net_device *netdev = neigh_node->if_incoming->soft_iface;\n\tstruct batadv_priv *bat_priv = netdev_priv(netdev);\n\tstruct batadv_orig_node *orig_node = neigh_node->orig_node;\n\tstruct batadv_nc_node *nc_node;\n\tstruct batadv_nc_packet *nc_packet = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(nc_node, &orig_node->in_coding_list, list) {\n\t\t \n\t\tnc_packet = batadv_nc_skb_src_search(bat_priv, skb,\n\t\t\t\t\t\t     neigh_node->addr,\n\t\t\t\t\t\t     ethhdr->h_source, nc_node);\n\n\t\t \n\t\tif (nc_packet)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (!nc_packet)\n\t\treturn false;\n\n\t \n\tbatadv_nc_skb_store_before_coding(bat_priv, skb,\n\t\t\t\t\t  neigh_node->addr);\n\tbatadv_nc_skb_store_before_coding(bat_priv, nc_packet->skb,\n\t\t\t\t\t  nc_packet->neigh_node->addr);\n\n\t \n\tif (batadv_nc_code_packets(bat_priv, skb, ethhdr, nc_packet,\n\t\t\t\t   neigh_node))\n\t\treturn true;\n\n\t \n\tbatadv_nc_send_packet(nc_packet);\n\treturn false;\n}\n\n \nstatic bool batadv_nc_skb_add_to_path(struct sk_buff *skb,\n\t\t\t\t      struct batadv_nc_path *nc_path,\n\t\t\t\t      struct batadv_neigh_node *neigh_node,\n\t\t\t\t      __be32 packet_id)\n{\n\tstruct batadv_nc_packet *nc_packet;\n\n\tnc_packet = kzalloc(sizeof(*nc_packet), GFP_ATOMIC);\n\tif (!nc_packet)\n\t\treturn false;\n\n\t \n\tnc_packet->timestamp = jiffies;\n\tnc_packet->packet_id = packet_id;\n\tnc_packet->skb = skb;\n\tnc_packet->neigh_node = neigh_node;\n\tnc_packet->nc_path = nc_path;\n\n\t \n\tspin_lock_bh(&nc_path->packet_list_lock);\n\tlist_add_tail(&nc_packet->list, &nc_path->packet_list);\n\tspin_unlock_bh(&nc_path->packet_list_lock);\n\n\treturn true;\n}\n\n \nbool batadv_nc_skb_forward(struct sk_buff *skb,\n\t\t\t   struct batadv_neigh_node *neigh_node)\n{\n\tconst struct net_device *netdev = neigh_node->if_incoming->soft_iface;\n\tstruct batadv_priv *bat_priv = netdev_priv(netdev);\n\tstruct batadv_unicast_packet *packet;\n\tstruct batadv_nc_path *nc_path;\n\tstruct ethhdr *ethhdr = eth_hdr(skb);\n\t__be32 packet_id;\n\tu8 *payload;\n\n\t \n\tif (!atomic_read(&bat_priv->network_coding))\n\t\tgoto out;\n\n\t \n\tpayload = skb_network_header(skb);\n\tpacket = (struct batadv_unicast_packet *)payload;\n\tif (packet->packet_type != BATADV_UNICAST)\n\t\tgoto out;\n\n\t \n\tif (batadv_nc_skb_dst_search(skb, neigh_node, ethhdr))\n\t\treturn true;\n\n\t \n\tnc_path = batadv_nc_get_path(bat_priv,\n\t\t\t\t     bat_priv->nc.coding_hash,\n\t\t\t\t     ethhdr->h_source,\n\t\t\t\t     neigh_node->addr);\n\n\tif (!nc_path)\n\t\tgoto out;\n\n\t \n\tpacket_id = batadv_skb_crc32(skb, payload + sizeof(*packet));\n\tif (!batadv_nc_skb_add_to_path(skb, nc_path, neigh_node, packet_id))\n\t\tgoto free_nc_path;\n\n\t \n\treturn true;\n\nfree_nc_path:\n\tbatadv_nc_path_put(nc_path);\nout:\n\t \n\treturn false;\n}\n\n \nvoid batadv_nc_skb_store_for_decoding(struct batadv_priv *bat_priv,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct batadv_unicast_packet *packet;\n\tstruct batadv_nc_path *nc_path;\n\tstruct ethhdr *ethhdr = eth_hdr(skb);\n\t__be32 packet_id;\n\tu8 *payload;\n\n\t \n\tif (!atomic_read(&bat_priv->network_coding))\n\t\tgoto out;\n\n\t \n\tpayload = skb_network_header(skb);\n\tpacket = (struct batadv_unicast_packet *)payload;\n\tif (packet->packet_type != BATADV_UNICAST)\n\t\tgoto out;\n\n\t \n\tnc_path = batadv_nc_get_path(bat_priv,\n\t\t\t\t     bat_priv->nc.decoding_hash,\n\t\t\t\t     ethhdr->h_source,\n\t\t\t\t     ethhdr->h_dest);\n\n\tif (!nc_path)\n\t\tgoto out;\n\n\t \n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\tgoto free_nc_path;\n\n\tif (unlikely(!pskb_may_pull(skb, ETH_HLEN)))\n\t\tgoto free_skb;\n\n\tif (unlikely(!skb_pull_rcsum(skb, ETH_HLEN)))\n\t\tgoto free_skb;\n\n\t \n\tpacket_id = batadv_skb_crc32(skb, payload + sizeof(*packet));\n\tif (!batadv_nc_skb_add_to_path(skb, nc_path, NULL, packet_id))\n\t\tgoto free_skb;\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_NC_BUFFER);\n\treturn;\n\nfree_skb:\n\tkfree_skb(skb);\nfree_nc_path:\n\tbatadv_nc_path_put(nc_path);\nout:\n\treturn;\n}\n\n \nvoid batadv_nc_skb_store_sniffed_unicast(struct batadv_priv *bat_priv,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ethhdr *ethhdr = eth_hdr(skb);\n\n\tif (batadv_is_my_mac(bat_priv, ethhdr->h_dest))\n\t\treturn;\n\n\t \n\tskb_push(skb, ETH_HLEN);\n\n\tbatadv_nc_skb_store_for_decoding(bat_priv, skb);\n}\n\n \nstatic struct batadv_unicast_packet *\nbatadv_nc_skb_decode_packet(struct batadv_priv *bat_priv, struct sk_buff *skb,\n\t\t\t    struct batadv_nc_packet *nc_packet)\n{\n\tconst int h_size = sizeof(struct batadv_unicast_packet);\n\tconst int h_diff = sizeof(struct batadv_coded_packet) - h_size;\n\tstruct batadv_unicast_packet *unicast_packet;\n\tstruct batadv_coded_packet coded_packet_tmp;\n\tstruct ethhdr *ethhdr, ethhdr_tmp;\n\tu8 *orig_dest, ttl, ttvn;\n\tunsigned int coding_len;\n\tint err;\n\n\t \n\tmemcpy(&coded_packet_tmp, skb->data, sizeof(coded_packet_tmp));\n\tmemcpy(&ethhdr_tmp, skb_mac_header(skb), sizeof(ethhdr_tmp));\n\n\tif (skb_cow(skb, 0) < 0)\n\t\treturn NULL;\n\n\tif (unlikely(!skb_pull_rcsum(skb, h_diff)))\n\t\treturn NULL;\n\n\t \n\tskb_set_mac_header(skb, -ETH_HLEN);\n\tskb_reset_network_header(skb);\n\n\t \n\tethhdr = eth_hdr(skb);\n\t*ethhdr = ethhdr_tmp;\n\n\t \n\tif (batadv_is_my_mac(bat_priv, coded_packet_tmp.second_dest)) {\n\t\t \n\t\tether_addr_copy(ethhdr->h_dest, coded_packet_tmp.second_dest);\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\torig_dest = coded_packet_tmp.second_orig_dest;\n\t\tttl = coded_packet_tmp.second_ttl;\n\t\tttvn = coded_packet_tmp.second_ttvn;\n\t} else {\n\t\torig_dest = coded_packet_tmp.first_orig_dest;\n\t\tttl = coded_packet_tmp.ttl;\n\t\tttvn = coded_packet_tmp.first_ttvn;\n\t}\n\n\tcoding_len = ntohs(coded_packet_tmp.coded_len);\n\n\tif (coding_len > skb->len)\n\t\treturn NULL;\n\n\t \n\tbatadv_nc_memxor(skb->data + h_size,\n\t\t\t nc_packet->skb->data + h_size,\n\t\t\t coding_len);\n\n\t \n\tif (nc_packet->skb->len > coding_len + h_size) {\n\t\terr = pskb_trim_rcsum(skb, coding_len + h_size);\n\t\tif (err)\n\t\t\treturn NULL;\n\t}\n\n\t \n\tunicast_packet = (struct batadv_unicast_packet *)skb->data;\n\tunicast_packet->packet_type = BATADV_UNICAST;\n\tunicast_packet->version = BATADV_COMPAT_VERSION;\n\tunicast_packet->ttl = ttl;\n\tether_addr_copy(unicast_packet->dest, orig_dest);\n\tunicast_packet->ttvn = ttvn;\n\n\tbatadv_nc_packet_free(nc_packet, false);\n\treturn unicast_packet;\n}\n\n \nstatic struct batadv_nc_packet *\nbatadv_nc_find_decoding_packet(struct batadv_priv *bat_priv,\n\t\t\t       struct ethhdr *ethhdr,\n\t\t\t       struct batadv_coded_packet *coded)\n{\n\tstruct batadv_hashtable *hash = bat_priv->nc.decoding_hash;\n\tstruct batadv_nc_packet *tmp_nc_packet, *nc_packet = NULL;\n\tstruct batadv_nc_path *nc_path, nc_path_key;\n\tu8 *dest, *source;\n\t__be32 packet_id;\n\tint index;\n\n\tif (!hash)\n\t\treturn NULL;\n\n\t \n\tdest = ethhdr->h_source;\n\tif (!batadv_is_my_mac(bat_priv, coded->second_dest)) {\n\t\tsource = coded->second_source;\n\t\tpacket_id = coded->second_crc;\n\t} else {\n\t\tsource = coded->first_source;\n\t\tpacket_id = coded->first_crc;\n\t}\n\n\tbatadv_nc_hash_key_gen(&nc_path_key, source, dest);\n\tindex = batadv_nc_hash_choose(&nc_path_key, hash->size);\n\n\t \n\trcu_read_lock();\n\thlist_for_each_entry_rcu(nc_path, &hash->table[index], hash_entry) {\n\t\t \n\t\tspin_lock_bh(&nc_path->packet_list_lock);\n\t\tlist_for_each_entry(tmp_nc_packet,\n\t\t\t\t    &nc_path->packet_list, list) {\n\t\t\tif (packet_id == tmp_nc_packet->packet_id) {\n\t\t\t\tlist_del(&tmp_nc_packet->list);\n\n\t\t\t\tnc_packet = tmp_nc_packet;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&nc_path->packet_list_lock);\n\n\t\tif (nc_packet)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (!nc_packet)\n\t\tbatadv_dbg(BATADV_DBG_NC, bat_priv,\n\t\t\t   \"No decoding packet found for %u\\n\", packet_id);\n\n\treturn nc_packet;\n}\n\n \nstatic int batadv_nc_recv_coded_packet(struct sk_buff *skb,\n\t\t\t\t       struct batadv_hard_iface *recv_if)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tstruct batadv_unicast_packet *unicast_packet;\n\tstruct batadv_coded_packet *coded_packet;\n\tstruct batadv_nc_packet *nc_packet;\n\tstruct ethhdr *ethhdr;\n\tint hdr_size = sizeof(*coded_packet);\n\n\t \n\tif (!atomic_read(&bat_priv->network_coding))\n\t\tgoto free_skb;\n\n\t \n\tif (unlikely(!pskb_may_pull(skb, hdr_size)))\n\t\tgoto free_skb;\n\n\tcoded_packet = (struct batadv_coded_packet *)skb->data;\n\tethhdr = eth_hdr(skb);\n\n\t \n\tif (!batadv_is_my_mac(bat_priv, ethhdr->h_dest) &&\n\t    !batadv_is_my_mac(bat_priv, coded_packet->second_dest))\n\t\tgoto free_skb;\n\n\t \n\tif (batadv_is_my_mac(bat_priv, coded_packet->second_dest))\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_NC_SNIFFED);\n\n\tnc_packet = batadv_nc_find_decoding_packet(bat_priv, ethhdr,\n\t\t\t\t\t\t   coded_packet);\n\tif (!nc_packet) {\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_NC_DECODE_FAILED);\n\t\tgoto free_skb;\n\t}\n\n\t \n\tif (skb_linearize(skb) < 0)\n\t\tgoto free_nc_packet;\n\n\tif (skb_linearize(nc_packet->skb) < 0)\n\t\tgoto free_nc_packet;\n\n\t \n\tunicast_packet = batadv_nc_skb_decode_packet(bat_priv, skb, nc_packet);\n\tif (!unicast_packet) {\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_NC_DECODE_FAILED);\n\t\tgoto free_nc_packet;\n\t}\n\n\t \n\tBATADV_SKB_CB(skb)->decoded = true;\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_NC_DECODE);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_NC_DECODE_BYTES,\n\t\t\t   skb->len + ETH_HLEN);\n\treturn batadv_recv_unicast_packet(skb, recv_if);\n\nfree_nc_packet:\n\tbatadv_nc_packet_free(nc_packet, true);\nfree_skb:\n\tkfree_skb(skb);\n\n\treturn NET_RX_DROP;\n}\n\n \nvoid batadv_nc_mesh_free(struct batadv_priv *bat_priv)\n{\n\tbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_NC, 1);\n\tbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_NC, 1);\n\tcancel_delayed_work_sync(&bat_priv->nc.work);\n\n\tbatadv_nc_purge_paths(bat_priv, bat_priv->nc.coding_hash, NULL);\n\tbatadv_hash_destroy(bat_priv->nc.coding_hash);\n\tbatadv_nc_purge_paths(bat_priv, bat_priv->nc.decoding_hash, NULL);\n\tbatadv_hash_destroy(bat_priv->nc.decoding_hash);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}