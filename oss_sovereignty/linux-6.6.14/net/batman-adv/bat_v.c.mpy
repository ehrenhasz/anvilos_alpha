{
  "module_name": "bat_v.c",
  "hash_id": "3744d82f836d12990e461f38161308988f6bb0c9687a30637ad7fc25f2782e0d",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/bat_v.c",
  "human_readable_source": "\n \n\n#include \"bat_v.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/if_ether.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/minmax.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <net/genetlink.h>\n#include <net/netlink.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"bat_algo.h\"\n#include \"bat_v_elp.h\"\n#include \"bat_v_ogm.h\"\n#include \"gateway_client.h\"\n#include \"hard-interface.h\"\n#include \"hash.h\"\n#include \"log.h\"\n#include \"netlink.h\"\n#include \"originator.h\"\n\nstatic void batadv_v_iface_activate(struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\tstruct batadv_hard_iface *primary_if;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\n\tif (primary_if) {\n\t\tbatadv_v_elp_iface_activate(primary_if, hard_iface);\n\t\tbatadv_hardif_put(primary_if);\n\t}\n\n\t \n\tif (hard_iface->if_status == BATADV_IF_TO_BE_ACTIVATED)\n\t\thard_iface->if_status = BATADV_IF_ACTIVE;\n}\n\nstatic int batadv_v_iface_enable(struct batadv_hard_iface *hard_iface)\n{\n\tint ret;\n\n\tret = batadv_v_elp_iface_enable(hard_iface);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = batadv_v_ogm_iface_enable(hard_iface);\n\tif (ret < 0)\n\t\tbatadv_v_elp_iface_disable(hard_iface);\n\n\treturn ret;\n}\n\nstatic void batadv_v_iface_disable(struct batadv_hard_iface *hard_iface)\n{\n\tbatadv_v_ogm_iface_disable(hard_iface);\n\tbatadv_v_elp_iface_disable(hard_iface);\n}\n\nstatic void batadv_v_primary_iface_set(struct batadv_hard_iface *hard_iface)\n{\n\tbatadv_v_elp_primary_iface_set(hard_iface);\n\tbatadv_v_ogm_primary_iface_set(hard_iface);\n}\n\n \nstatic void batadv_v_iface_update_mac(struct batadv_hard_iface *hard_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\n\tstruct batadv_hard_iface *primary_if;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (primary_if != hard_iface)\n\t\tgoto out;\n\n\tbatadv_v_primary_iface_set(hard_iface);\nout:\n\tbatadv_hardif_put(primary_if);\n}\n\nstatic void\nbatadv_v_hardif_neigh_init(struct batadv_hardif_neigh_node *hardif_neigh)\n{\n\tewma_throughput_init(&hardif_neigh->bat_v.throughput);\n\tINIT_WORK(&hardif_neigh->bat_v.metric_work,\n\t\t  batadv_v_elp_throughput_metric_update);\n}\n\n \nstatic int\nbatadv_v_neigh_dump_neigh(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t  struct batadv_hardif_neigh_node *hardif_neigh)\n{\n\tvoid *hdr;\n\tunsigned int last_seen_msecs;\n\tu32 throughput;\n\n\tlast_seen_msecs = jiffies_to_msecs(jiffies - hardif_neigh->last_seen);\n\tthroughput = ewma_throughput_read(&hardif_neigh->bat_v.throughput);\n\tthroughput = throughput * 100;\n\n\thdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, NLM_F_MULTI,\n\t\t\t  BATADV_CMD_GET_NEIGHBORS);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put(msg, BATADV_ATTR_NEIGH_ADDRESS, ETH_ALEN,\n\t\t    hardif_neigh->addr) ||\n\t    nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\n\t\t\t   hardif_neigh->if_incoming->net_dev->name) ||\n\t    nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\n\t\t\thardif_neigh->if_incoming->net_dev->ifindex) ||\n\t    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS,\n\t\t\tlast_seen_msecs) ||\n\t    nla_put_u32(msg, BATADV_ATTR_THROUGHPUT, throughput))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int\nbatadv_v_neigh_dump_hardif(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t   struct batadv_priv *bat_priv,\n\t\t\t   struct batadv_hard_iface *hard_iface,\n\t\t\t   int *idx_s)\n{\n\tstruct batadv_hardif_neigh_node *hardif_neigh;\n\tint idx = 0;\n\n\thlist_for_each_entry_rcu(hardif_neigh,\n\t\t\t\t &hard_iface->neigh_list, list) {\n\t\tif (idx++ < *idx_s)\n\t\t\tcontinue;\n\n\t\tif (batadv_v_neigh_dump_neigh(msg, portid, seq, hardif_neigh)) {\n\t\t\t*idx_s = idx - 1;\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t*idx_s = 0;\n\treturn 0;\n}\n\n \nstatic void\nbatadv_v_neigh_dump(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t    struct batadv_priv *bat_priv,\n\t\t    struct batadv_hard_iface *single_hardif)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\tint i_hardif = 0;\n\tint i_hardif_s = cb->args[0];\n\tint idx = cb->args[1];\n\tint portid = NETLINK_CB(cb->skb).portid;\n\n\trcu_read_lock();\n\tif (single_hardif) {\n\t\tif (i_hardif_s == 0) {\n\t\t\tif (batadv_v_neigh_dump_hardif(msg, portid,\n\t\t\t\t\t\t       cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t       bat_priv, single_hardif,\n\t\t\t\t\t\t       &idx) == 0)\n\t\t\t\ti_hardif++;\n\t\t}\n\t} else {\n\t\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\t\tif (hard_iface->soft_iface != bat_priv->soft_iface)\n\t\t\t\tcontinue;\n\n\t\t\tif (i_hardif++ < i_hardif_s)\n\t\t\t\tcontinue;\n\n\t\t\tif (batadv_v_neigh_dump_hardif(msg, portid,\n\t\t\t\t\t\t       cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t       bat_priv, hard_iface,\n\t\t\t\t\t\t       &idx)) {\n\t\t\t\ti_hardif--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tcb->args[0] = i_hardif;\n\tcb->args[1] = idx;\n}\n\n \nstatic int\nbatadv_v_orig_dump_subentry(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t    struct batadv_priv *bat_priv,\n\t\t\t    struct batadv_hard_iface *if_outgoing,\n\t\t\t    struct batadv_orig_node *orig_node,\n\t\t\t    struct batadv_neigh_node *neigh_node,\n\t\t\t    bool best)\n{\n\tstruct batadv_neigh_ifinfo *n_ifinfo;\n\tunsigned int last_seen_msecs;\n\tu32 throughput;\n\tvoid *hdr;\n\n\tn_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);\n\tif (!n_ifinfo)\n\t\treturn 0;\n\n\tthroughput = n_ifinfo->bat_v.throughput * 100;\n\n\tbatadv_neigh_ifinfo_put(n_ifinfo);\n\n\tlast_seen_msecs = jiffies_to_msecs(jiffies - orig_node->last_seen);\n\n\tif (if_outgoing != BATADV_IF_DEFAULT &&\n\t    if_outgoing != neigh_node->if_incoming)\n\t\treturn 0;\n\n\thdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, NLM_F_MULTI,\n\t\t\t  BATADV_CMD_GET_ORIGINATORS);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN, orig_node->orig) ||\n\t    nla_put(msg, BATADV_ATTR_NEIGH_ADDRESS, ETH_ALEN,\n\t\t    neigh_node->addr) ||\n\t    nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\n\t\t\t   neigh_node->if_incoming->net_dev->name) ||\n\t    nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\n\t\t\tneigh_node->if_incoming->net_dev->ifindex) ||\n\t    nla_put_u32(msg, BATADV_ATTR_THROUGHPUT, throughput) ||\n\t    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS,\n\t\t\tlast_seen_msecs))\n\t\tgoto nla_put_failure;\n\n\tif (best && nla_put_flag(msg, BATADV_ATTR_FLAG_BEST))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int\nbatadv_v_orig_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t struct batadv_priv *bat_priv,\n\t\t\t struct batadv_hard_iface *if_outgoing,\n\t\t\t struct batadv_orig_node *orig_node, int *sub_s)\n{\n\tstruct batadv_neigh_node *neigh_node_best;\n\tstruct batadv_neigh_node *neigh_node;\n\tint sub = 0;\n\tbool best;\n\n\tneigh_node_best = batadv_orig_router_get(orig_node, if_outgoing);\n\tif (!neigh_node_best)\n\t\tgoto out;\n\n\thlist_for_each_entry_rcu(neigh_node, &orig_node->neigh_list, list) {\n\t\tif (sub++ < *sub_s)\n\t\t\tcontinue;\n\n\t\tbest = (neigh_node == neigh_node_best);\n\n\t\tif (batadv_v_orig_dump_subentry(msg, portid, seq, bat_priv,\n\t\t\t\t\t\tif_outgoing, orig_node,\n\t\t\t\t\t\tneigh_node, best)) {\n\t\t\tbatadv_neigh_node_put(neigh_node_best);\n\n\t\t\t*sub_s = sub - 1;\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n out:\n\tbatadv_neigh_node_put(neigh_node_best);\n\n\t*sub_s = 0;\n\treturn 0;\n}\n\n \nstatic int\nbatadv_v_orig_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t  struct batadv_priv *bat_priv,\n\t\t\t  struct batadv_hard_iface *if_outgoing,\n\t\t\t  struct hlist_head *head, int *idx_s, int *sub)\n{\n\tstruct batadv_orig_node *orig_node;\n\tint idx = 0;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(orig_node, head, hash_entry) {\n\t\tif (idx++ < *idx_s)\n\t\t\tcontinue;\n\n\t\tif (batadv_v_orig_dump_entry(msg, portid, seq, bat_priv,\n\t\t\t\t\t     if_outgoing, orig_node, sub)) {\n\t\t\trcu_read_unlock();\n\t\t\t*idx_s = idx - 1;\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t*idx_s = 0;\n\t*sub = 0;\n\treturn 0;\n}\n\n \nstatic void\nbatadv_v_orig_dump(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t   struct batadv_priv *bat_priv,\n\t\t   struct batadv_hard_iface *if_outgoing)\n{\n\tstruct batadv_hashtable *hash = bat_priv->orig_hash;\n\tstruct hlist_head *head;\n\tint bucket = cb->args[0];\n\tint idx = cb->args[1];\n\tint sub = cb->args[2];\n\tint portid = NETLINK_CB(cb->skb).portid;\n\n\twhile (bucket < hash->size) {\n\t\thead = &hash->table[bucket];\n\n\t\tif (batadv_v_orig_dump_bucket(msg, portid,\n\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t      bat_priv, if_outgoing, head, &idx,\n\t\t\t\t\t      &sub))\n\t\t\tbreak;\n\n\t\tbucket++;\n\t}\n\n\tcb->args[0] = bucket;\n\tcb->args[1] = idx;\n\tcb->args[2] = sub;\n}\n\nstatic int batadv_v_neigh_cmp(struct batadv_neigh_node *neigh1,\n\t\t\t      struct batadv_hard_iface *if_outgoing1,\n\t\t\t      struct batadv_neigh_node *neigh2,\n\t\t\t      struct batadv_hard_iface *if_outgoing2)\n{\n\tstruct batadv_neigh_ifinfo *ifinfo1, *ifinfo2;\n\tint ret = 0;\n\n\tifinfo1 = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);\n\tif (!ifinfo1)\n\t\tgoto err_ifinfo1;\n\n\tifinfo2 = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);\n\tif (!ifinfo2)\n\t\tgoto err_ifinfo2;\n\n\tret = ifinfo1->bat_v.throughput - ifinfo2->bat_v.throughput;\n\n\tbatadv_neigh_ifinfo_put(ifinfo2);\nerr_ifinfo2:\n\tbatadv_neigh_ifinfo_put(ifinfo1);\nerr_ifinfo1:\n\treturn ret;\n}\n\nstatic bool batadv_v_neigh_is_sob(struct batadv_neigh_node *neigh1,\n\t\t\t\t  struct batadv_hard_iface *if_outgoing1,\n\t\t\t\t  struct batadv_neigh_node *neigh2,\n\t\t\t\t  struct batadv_hard_iface *if_outgoing2)\n{\n\tstruct batadv_neigh_ifinfo *ifinfo1, *ifinfo2;\n\tu32 threshold;\n\tbool ret = false;\n\n\tifinfo1 = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);\n\tif (!ifinfo1)\n\t\tgoto err_ifinfo1;\n\n\tifinfo2 = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);\n\tif (!ifinfo2)\n\t\tgoto err_ifinfo2;\n\n\tthreshold = ifinfo1->bat_v.throughput / 4;\n\tthreshold = ifinfo1->bat_v.throughput - threshold;\n\n\tret = ifinfo2->bat_v.throughput > threshold;\n\n\tbatadv_neigh_ifinfo_put(ifinfo2);\nerr_ifinfo2:\n\tbatadv_neigh_ifinfo_put(ifinfo1);\nerr_ifinfo1:\n\treturn ret;\n}\n\n \nstatic void batadv_v_init_sel_class(struct batadv_priv *bat_priv)\n{\n\t \n\tatomic_set(&bat_priv->gw.sel_class, 50);\n}\n\n \nstatic int batadv_v_gw_throughput_get(struct batadv_gw_node *gw_node, u32 *bw)\n{\n\tstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\n\tstruct batadv_orig_node *orig_node;\n\tstruct batadv_neigh_node *router;\n\tint ret = -1;\n\n\torig_node = gw_node->orig_node;\n\trouter = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);\n\tif (!router)\n\t\tgoto out;\n\n\trouter_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);\n\tif (!router_ifinfo)\n\t\tgoto out;\n\n\t \n\t*bw = router_ifinfo->bat_v.throughput;\n\t*bw = min_t(u32, *bw, gw_node->bandwidth_down);\n\n\tret = 0;\nout:\n\tbatadv_neigh_node_put(router);\n\tbatadv_neigh_ifinfo_put(router_ifinfo);\n\n\treturn ret;\n}\n\n \nstatic struct batadv_gw_node *\nbatadv_v_gw_get_best_gw_node(struct batadv_priv *bat_priv)\n{\n\tstruct batadv_gw_node *gw_node, *curr_gw = NULL;\n\tu32 max_bw = 0, bw;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {\n\t\tif (!kref_get_unless_zero(&gw_node->refcount))\n\t\t\tcontinue;\n\n\t\tif (batadv_v_gw_throughput_get(gw_node, &bw) < 0)\n\t\t\tgoto next;\n\n\t\tif (curr_gw && bw <= max_bw)\n\t\t\tgoto next;\n\n\t\tbatadv_gw_node_put(curr_gw);\n\n\t\tcurr_gw = gw_node;\n\t\tkref_get(&curr_gw->refcount);\n\t\tmax_bw = bw;\n\nnext:\n\t\tbatadv_gw_node_put(gw_node);\n\t}\n\trcu_read_unlock();\n\n\treturn curr_gw;\n}\n\n \nstatic bool batadv_v_gw_is_eligible(struct batadv_priv *bat_priv,\n\t\t\t\t    struct batadv_orig_node *curr_gw_orig,\n\t\t\t\t    struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_gw_node *curr_gw, *orig_gw = NULL;\n\tu32 gw_throughput, orig_throughput, threshold;\n\tbool ret = false;\n\n\tthreshold = atomic_read(&bat_priv->gw.sel_class);\n\n\tcurr_gw = batadv_gw_node_get(bat_priv, curr_gw_orig);\n\tif (!curr_gw) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\tif (batadv_v_gw_throughput_get(curr_gw, &gw_throughput) < 0) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\torig_gw = batadv_gw_node_get(bat_priv, orig_node);\n\tif (!orig_gw)\n\t\tgoto out;\n\n\tif (batadv_v_gw_throughput_get(orig_gw, &orig_throughput) < 0)\n\t\tgoto out;\n\n\tif (orig_throughput < gw_throughput)\n\t\tgoto out;\n\n\tif ((orig_throughput - gw_throughput) < threshold)\n\t\tgoto out;\n\n\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t   \"Restarting gateway selection: better gateway found (throughput curr: %u, throughput new: %u)\\n\",\n\t\t   gw_throughput, orig_throughput);\n\n\tret = true;\nout:\n\tbatadv_gw_node_put(curr_gw);\n\tbatadv_gw_node_put(orig_gw);\n\n\treturn ret;\n}\n\n \nstatic int batadv_v_gw_dump_entry(struct sk_buff *msg, u32 portid,\n\t\t\t\t  struct netlink_callback *cb,\n\t\t\t\t  struct batadv_priv *bat_priv,\n\t\t\t\t  struct batadv_gw_node *gw_node)\n{\n\tstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\n\tstruct batadv_neigh_node *router;\n\tstruct batadv_gw_node *curr_gw = NULL;\n\tint ret = 0;\n\tvoid *hdr;\n\n\trouter = batadv_orig_router_get(gw_node->orig_node, BATADV_IF_DEFAULT);\n\tif (!router)\n\t\tgoto out;\n\n\trouter_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);\n\tif (!router_ifinfo)\n\t\tgoto out;\n\n\tcurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\n\n\thdr = genlmsg_put(msg, portid, cb->nlh->nlmsg_seq,\n\t\t\t  &batadv_netlink_family, NLM_F_MULTI,\n\t\t\t  BATADV_CMD_GET_GATEWAYS);\n\tif (!hdr) {\n\t\tret = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tret = -EMSGSIZE;\n\n\tif (curr_gw == gw_node) {\n\t\tif (nla_put_flag(msg, BATADV_ATTR_FLAG_BEST)) {\n\t\t\tgenlmsg_cancel(msg, hdr);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,\n\t\t    gw_node->orig_node->orig)) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\tgoto out;\n\t}\n\n\tif (nla_put_u32(msg, BATADV_ATTR_THROUGHPUT,\n\t\t\trouter_ifinfo->bat_v.throughput)) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\tgoto out;\n\t}\n\n\tif (nla_put(msg, BATADV_ATTR_ROUTER, ETH_ALEN, router->addr)) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\tgoto out;\n\t}\n\n\tif (nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\n\t\t\t   router->if_incoming->net_dev->name)) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\tgoto out;\n\t}\n\n\tif (nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\n\t\t\trouter->if_incoming->net_dev->ifindex)) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\tgoto out;\n\t}\n\n\tif (nla_put_u32(msg, BATADV_ATTR_BANDWIDTH_DOWN,\n\t\t\tgw_node->bandwidth_down)) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\tgoto out;\n\t}\n\n\tif (nla_put_u32(msg, BATADV_ATTR_BANDWIDTH_UP, gw_node->bandwidth_up)) {\n\t\tgenlmsg_cancel(msg, hdr);\n\t\tgoto out;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\tret = 0;\n\nout:\n\tbatadv_gw_node_put(curr_gw);\n\tbatadv_neigh_ifinfo_put(router_ifinfo);\n\tbatadv_neigh_node_put(router);\n\treturn ret;\n}\n\n \nstatic void batadv_v_gw_dump(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t     struct batadv_priv *bat_priv)\n{\n\tint portid = NETLINK_CB(cb->skb).portid;\n\tstruct batadv_gw_node *gw_node;\n\tint idx_skip = cb->args[0];\n\tint idx = 0;\n\n\tspin_lock_bh(&bat_priv->gw.list_lock);\n\tcb->seq = bat_priv->gw.generation << 1 | 1;\n\n\thlist_for_each_entry(gw_node, &bat_priv->gw.gateway_list, list) {\n\t\tif (idx++ < idx_skip)\n\t\t\tcontinue;\n\n\t\tif (batadv_v_gw_dump_entry(msg, portid, cb, bat_priv,\n\t\t\t\t\t   gw_node)) {\n\t\t\tidx_skip = idx - 1;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tidx_skip = idx;\nunlock:\n\tspin_unlock_bh(&bat_priv->gw.list_lock);\n\n\tcb->args[0] = idx_skip;\n}\n\nstatic struct batadv_algo_ops batadv_batman_v __read_mostly = {\n\t.name = \"BATMAN_V\",\n\t.iface = {\n\t\t.activate = batadv_v_iface_activate,\n\t\t.enable = batadv_v_iface_enable,\n\t\t.disable = batadv_v_iface_disable,\n\t\t.update_mac = batadv_v_iface_update_mac,\n\t\t.primary_set = batadv_v_primary_iface_set,\n\t},\n\t.neigh = {\n\t\t.hardif_init = batadv_v_hardif_neigh_init,\n\t\t.cmp = batadv_v_neigh_cmp,\n\t\t.is_similar_or_better = batadv_v_neigh_is_sob,\n\t\t.dump = batadv_v_neigh_dump,\n\t},\n\t.orig = {\n\t\t.dump = batadv_v_orig_dump,\n\t},\n\t.gw = {\n\t\t.init_sel_class = batadv_v_init_sel_class,\n\t\t.sel_class_max = U32_MAX,\n\t\t.get_best_gw_node = batadv_v_gw_get_best_gw_node,\n\t\t.is_eligible = batadv_v_gw_is_eligible,\n\t\t.dump = batadv_v_gw_dump,\n\t},\n};\n\n \nvoid batadv_v_hardif_init(struct batadv_hard_iface *hard_iface)\n{\n\t \n\tatomic_set(&hard_iface->bat_v.throughput_override, 0);\n\tatomic_set(&hard_iface->bat_v.elp_interval, 500);\n\n\thard_iface->bat_v.aggr_len = 0;\n\tskb_queue_head_init(&hard_iface->bat_v.aggr_list);\n\tINIT_DELAYED_WORK(&hard_iface->bat_v.aggr_wq,\n\t\t\t  batadv_v_ogm_aggr_work);\n}\n\n \nint batadv_v_mesh_init(struct batadv_priv *bat_priv)\n{\n\tint ret = 0;\n\n\tret = batadv_v_ogm_init(bat_priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nvoid batadv_v_mesh_free(struct batadv_priv *bat_priv)\n{\n\tbatadv_v_ogm_free(bat_priv);\n}\n\n \nint __init batadv_v_init(void)\n{\n\tint ret;\n\n\t \n\tret = batadv_recv_handler_register(BATADV_ELP,\n\t\t\t\t\t   batadv_v_elp_packet_recv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = batadv_recv_handler_register(BATADV_OGM2,\n\t\t\t\t\t   batadv_v_ogm_packet_recv);\n\tif (ret < 0)\n\t\tgoto elp_unregister;\n\n\tret = batadv_algo_register(&batadv_batman_v);\n\tif (ret < 0)\n\t\tgoto ogm_unregister;\n\n\treturn ret;\n\nogm_unregister:\n\tbatadv_recv_handler_unregister(BATADV_OGM2);\n\nelp_unregister:\n\tbatadv_recv_handler_unregister(BATADV_ELP);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}