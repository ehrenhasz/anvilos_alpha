{
  "module_name": "main.c",
  "hash_id": "46003f2f073198f29ed0c3998dbacb1369a4a7b0c433d6862764f97f4a4896af",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/main.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/build_bug.h>\n#include <linux/byteorder/generic.h>\n#include <linux/container_of.h>\n#include <linux/crc32c.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/genetlink.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/printk.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <net/dsfield.h>\n#include <net/rtnetlink.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"bat_algo.h\"\n#include \"bat_iv_ogm.h\"\n#include \"bat_v.h\"\n#include \"bridge_loop_avoidance.h\"\n#include \"distributed-arp-table.h\"\n#include \"gateway_client.h\"\n#include \"gateway_common.h\"\n#include \"hard-interface.h\"\n#include \"log.h\"\n#include \"multicast.h\"\n#include \"netlink.h\"\n#include \"network-coding.h\"\n#include \"originator.h\"\n#include \"routing.h\"\n#include \"send.h\"\n#include \"soft-interface.h\"\n#include \"tp_meter.h\"\n#include \"translation-table.h\"\n\n \nstruct list_head batadv_hardif_list;\nunsigned int batadv_hardif_generation;\nstatic int (*batadv_rx_handler[256])(struct sk_buff *skb,\n\t\t\t\t     struct batadv_hard_iface *recv_if);\n\nunsigned char batadv_broadcast_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\nstruct workqueue_struct *batadv_event_workqueue;\n\nstatic void batadv_recv_handler_init(void);\n\n#define BATADV_UEV_TYPE_VAR\t\"BATTYPE=\"\n#define BATADV_UEV_ACTION_VAR\t\"BATACTION=\"\n#define BATADV_UEV_DATA_VAR\t\"BATDATA=\"\n\nstatic char *batadv_uev_action_str[] = {\n\t\"add\",\n\t\"del\",\n\t\"change\",\n\t\"loopdetect\",\n};\n\nstatic char *batadv_uev_type_str[] = {\n\t\"gw\",\n\t\"bla\",\n};\n\nstatic int __init batadv_init(void)\n{\n\tint ret;\n\n\tret = batadv_tt_cache_init();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tINIT_LIST_HEAD(&batadv_hardif_list);\n\tbatadv_algo_init();\n\n\tbatadv_recv_handler_init();\n\n\tbatadv_v_init();\n\tbatadv_iv_init();\n\tbatadv_nc_init();\n\tbatadv_tp_meter_init();\n\n\tbatadv_event_workqueue = create_singlethread_workqueue(\"bat_events\");\n\tif (!batadv_event_workqueue)\n\t\tgoto err_create_wq;\n\n\tregister_netdevice_notifier(&batadv_hard_if_notifier);\n\trtnl_link_register(&batadv_link_ops);\n\tbatadv_netlink_register();\n\n\tpr_info(\"B.A.T.M.A.N. advanced %s (compatibility version %i) loaded\\n\",\n\t\tBATADV_SOURCE_VERSION, BATADV_COMPAT_VERSION);\n\n\treturn 0;\n\nerr_create_wq:\n\tbatadv_tt_cache_destroy();\n\n\treturn -ENOMEM;\n}\n\nstatic void __exit batadv_exit(void)\n{\n\tbatadv_netlink_unregister();\n\trtnl_link_unregister(&batadv_link_ops);\n\tunregister_netdevice_notifier(&batadv_hard_if_notifier);\n\n\tdestroy_workqueue(batadv_event_workqueue);\n\tbatadv_event_workqueue = NULL;\n\n\trcu_barrier();\n\n\tbatadv_tt_cache_destroy();\n}\n\n \nint batadv_mesh_init(struct net_device *soft_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\n\tint ret;\n\n\tspin_lock_init(&bat_priv->forw_bat_list_lock);\n\tspin_lock_init(&bat_priv->forw_bcast_list_lock);\n\tspin_lock_init(&bat_priv->tt.changes_list_lock);\n\tspin_lock_init(&bat_priv->tt.req_list_lock);\n\tspin_lock_init(&bat_priv->tt.roam_list_lock);\n\tspin_lock_init(&bat_priv->tt.last_changeset_lock);\n\tspin_lock_init(&bat_priv->tt.commit_lock);\n\tspin_lock_init(&bat_priv->gw.list_lock);\n#ifdef CONFIG_BATMAN_ADV_MCAST\n\tspin_lock_init(&bat_priv->mcast.mla_lock);\n\tspin_lock_init(&bat_priv->mcast.want_lists_lock);\n#endif\n\tspin_lock_init(&bat_priv->tvlv.container_list_lock);\n\tspin_lock_init(&bat_priv->tvlv.handler_list_lock);\n\tspin_lock_init(&bat_priv->softif_vlan_list_lock);\n\tspin_lock_init(&bat_priv->tp_list_lock);\n\n\tINIT_HLIST_HEAD(&bat_priv->forw_bat_list);\n\tINIT_HLIST_HEAD(&bat_priv->forw_bcast_list);\n\tINIT_HLIST_HEAD(&bat_priv->gw.gateway_list);\n#ifdef CONFIG_BATMAN_ADV_MCAST\n\tINIT_HLIST_HEAD(&bat_priv->mcast.want_all_unsnoopables_list);\n\tINIT_HLIST_HEAD(&bat_priv->mcast.want_all_ipv4_list);\n\tINIT_HLIST_HEAD(&bat_priv->mcast.want_all_ipv6_list);\n#endif\n\tINIT_LIST_HEAD(&bat_priv->tt.changes_list);\n\tINIT_HLIST_HEAD(&bat_priv->tt.req_list);\n\tINIT_LIST_HEAD(&bat_priv->tt.roam_list);\n#ifdef CONFIG_BATMAN_ADV_MCAST\n\tINIT_HLIST_HEAD(&bat_priv->mcast.mla_list);\n#endif\n\tINIT_HLIST_HEAD(&bat_priv->tvlv.container_list);\n\tINIT_HLIST_HEAD(&bat_priv->tvlv.handler_list);\n\tINIT_HLIST_HEAD(&bat_priv->softif_vlan_list);\n\tINIT_HLIST_HEAD(&bat_priv->tp_list);\n\n\tbat_priv->gw.generation = 0;\n\n\tret = batadv_originator_init(bat_priv);\n\tif (ret < 0) {\n\t\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_DEACTIVATING);\n\t\tgoto err_orig;\n\t}\n\n\tret = batadv_tt_init(bat_priv);\n\tif (ret < 0) {\n\t\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_DEACTIVATING);\n\t\tgoto err_tt;\n\t}\n\n\tret = batadv_v_mesh_init(bat_priv);\n\tif (ret < 0) {\n\t\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_DEACTIVATING);\n\t\tgoto err_v;\n\t}\n\n\tret = batadv_bla_init(bat_priv);\n\tif (ret < 0) {\n\t\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_DEACTIVATING);\n\t\tgoto err_bla;\n\t}\n\n\tret = batadv_dat_init(bat_priv);\n\tif (ret < 0) {\n\t\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_DEACTIVATING);\n\t\tgoto err_dat;\n\t}\n\n\tret = batadv_nc_mesh_init(bat_priv);\n\tif (ret < 0) {\n\t\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_DEACTIVATING);\n\t\tgoto err_nc;\n\t}\n\n\tbatadv_gw_init(bat_priv);\n\tbatadv_mcast_init(bat_priv);\n\n\tatomic_set(&bat_priv->gw.reselect, 0);\n\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_ACTIVE);\n\n\treturn 0;\n\nerr_nc:\n\tbatadv_dat_free(bat_priv);\nerr_dat:\n\tbatadv_bla_free(bat_priv);\nerr_bla:\n\tbatadv_v_mesh_free(bat_priv);\nerr_v:\n\tbatadv_tt_free(bat_priv);\nerr_tt:\n\tbatadv_originator_free(bat_priv);\nerr_orig:\n\tbatadv_purge_outstanding_packets(bat_priv, NULL);\n\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_INACTIVE);\n\n\treturn ret;\n}\n\n \nvoid batadv_mesh_free(struct net_device *soft_iface)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\n\n\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_DEACTIVATING);\n\n\tbatadv_purge_outstanding_packets(bat_priv, NULL);\n\n\tbatadv_gw_node_free(bat_priv);\n\n\tbatadv_v_mesh_free(bat_priv);\n\tbatadv_nc_mesh_free(bat_priv);\n\tbatadv_dat_free(bat_priv);\n\tbatadv_bla_free(bat_priv);\n\n\tbatadv_mcast_free(bat_priv);\n\n\t \n\tbatadv_tt_free(bat_priv);\n\n\t \n\tbatadv_originator_free(bat_priv);\n\n\tbatadv_gw_free(bat_priv);\n\n\tfree_percpu(bat_priv->bat_counters);\n\tbat_priv->bat_counters = NULL;\n\n\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_INACTIVE);\n}\n\n \nbool batadv_is_my_mac(struct batadv_priv *bat_priv, const u8 *addr)\n{\n\tconst struct batadv_hard_iface *hard_iface;\n\tbool is_my_mac = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->if_status != BATADV_IF_ACTIVE)\n\t\t\tcontinue;\n\n\t\tif (hard_iface->soft_iface != bat_priv->soft_iface)\n\t\t\tcontinue;\n\n\t\tif (batadv_compare_eth(hard_iface->net_dev->dev_addr, addr)) {\n\t\t\tis_my_mac = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn is_my_mac;\n}\n\n \nint batadv_max_header_len(void)\n{\n\tint header_len = 0;\n\n\theader_len = max_t(int, header_len,\n\t\t\t   sizeof(struct batadv_unicast_packet));\n\theader_len = max_t(int, header_len,\n\t\t\t   sizeof(struct batadv_unicast_4addr_packet));\n\theader_len = max_t(int, header_len,\n\t\t\t   sizeof(struct batadv_bcast_packet));\n\n#ifdef CONFIG_BATMAN_ADV_NC\n\theader_len = max_t(int, header_len,\n\t\t\t   sizeof(struct batadv_coded_packet));\n#endif\n\n\treturn header_len + ETH_HLEN;\n}\n\n \nvoid batadv_skb_set_priority(struct sk_buff *skb, int offset)\n{\n\tstruct iphdr ip_hdr_tmp, *ip_hdr;\n\tstruct ipv6hdr ip6_hdr_tmp, *ip6_hdr;\n\tstruct ethhdr ethhdr_tmp, *ethhdr;\n\tstruct vlan_ethhdr *vhdr, vhdr_tmp;\n\tu32 prio;\n\n\t \n\tif (skb->priority >= 256 && skb->priority <= 263)\n\t\treturn;\n\n\tethhdr = skb_header_pointer(skb, offset, sizeof(*ethhdr), &ethhdr_tmp);\n\tif (!ethhdr)\n\t\treturn;\n\n\tswitch (ethhdr->h_proto) {\n\tcase htons(ETH_P_8021Q):\n\t\tvhdr = skb_header_pointer(skb, offset + sizeof(*vhdr),\n\t\t\t\t\t  sizeof(*vhdr), &vhdr_tmp);\n\t\tif (!vhdr)\n\t\t\treturn;\n\t\tprio = ntohs(vhdr->h_vlan_TCI) & VLAN_PRIO_MASK;\n\t\tprio = prio >> VLAN_PRIO_SHIFT;\n\t\tbreak;\n\tcase htons(ETH_P_IP):\n\t\tip_hdr = skb_header_pointer(skb, offset + sizeof(*ethhdr),\n\t\t\t\t\t    sizeof(*ip_hdr), &ip_hdr_tmp);\n\t\tif (!ip_hdr)\n\t\t\treturn;\n\t\tprio = (ipv4_get_dsfield(ip_hdr) & 0xfc) >> 5;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tip6_hdr = skb_header_pointer(skb, offset + sizeof(*ethhdr),\n\t\t\t\t\t     sizeof(*ip6_hdr), &ip6_hdr_tmp);\n\t\tif (!ip6_hdr)\n\t\t\treturn;\n\t\tprio = (ipv6_get_dsfield(ip6_hdr) & 0xfc) >> 5;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tskb->priority = prio + 256;\n}\n\nstatic int batadv_recv_unhandled_packet(struct sk_buff *skb,\n\t\t\t\t\tstruct batadv_hard_iface *recv_if)\n{\n\tkfree_skb(skb);\n\n\treturn NET_RX_DROP;\n}\n\n \n\n \nint batadv_batman_skb_recv(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct packet_type *ptype,\n\t\t\t   struct net_device *orig_dev)\n{\n\tstruct batadv_priv *bat_priv;\n\tstruct batadv_ogm_packet *batadv_ogm_packet;\n\tstruct batadv_hard_iface *hard_iface;\n\tu8 idx;\n\n\thard_iface = container_of(ptype, struct batadv_hard_iface,\n\t\t\t\t  batman_adv_ptype);\n\n\t \n\tif (!kref_get_unless_zero(&hard_iface->refcount))\n\t\tgoto err_out;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\n\t \n\tif (!skb)\n\t\tgoto err_put;\n\n\t \n\tif (unlikely(!pskb_may_pull(skb, 2)))\n\t\tgoto err_free;\n\n\t \n\tif (unlikely(skb->mac_len != ETH_HLEN || !skb_mac_header(skb)))\n\t\tgoto err_free;\n\n\tif (!hard_iface->soft_iface)\n\t\tgoto err_free;\n\n\tbat_priv = netdev_priv(hard_iface->soft_iface);\n\n\tif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\n\t\tgoto err_free;\n\n\t \n\tif (hard_iface->if_status != BATADV_IF_ACTIVE)\n\t\tgoto err_free;\n\n\tbatadv_ogm_packet = (struct batadv_ogm_packet *)skb->data;\n\n\tif (batadv_ogm_packet->version != BATADV_COMPAT_VERSION) {\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Drop packet: incompatible batman version (%i)\\n\",\n\t\t\t   batadv_ogm_packet->version);\n\t\tgoto err_free;\n\t}\n\n\t \n\tmemset(skb->cb, 0, sizeof(struct batadv_skb_cb));\n\n\tidx = batadv_ogm_packet->packet_type;\n\t(*batadv_rx_handler[idx])(skb, hard_iface);\n\n\tbatadv_hardif_put(hard_iface);\n\n\t \n\treturn NET_RX_SUCCESS;\n\nerr_free:\n\tkfree_skb(skb);\nerr_put:\n\tbatadv_hardif_put(hard_iface);\nerr_out:\n\treturn NET_RX_DROP;\n}\n\nstatic void batadv_recv_handler_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(batadv_rx_handler); i++)\n\t\tbatadv_rx_handler[i] = batadv_recv_unhandled_packet;\n\n\tfor (i = BATADV_UNICAST_MIN; i <= BATADV_UNICAST_MAX; i++)\n\t\tbatadv_rx_handler[i] = batadv_recv_unhandled_unicast_packet;\n\n\t \n\tBUILD_BUG_ON(sizeof(struct batadv_bla_claim_dst) != 6);\n\tBUILD_BUG_ON(sizeof(struct batadv_ogm_packet) != 24);\n\tBUILD_BUG_ON(sizeof(struct batadv_icmp_header) != 20);\n\tBUILD_BUG_ON(sizeof(struct batadv_icmp_packet) != 20);\n\tBUILD_BUG_ON(sizeof(struct batadv_icmp_packet_rr) != 116);\n\tBUILD_BUG_ON(sizeof(struct batadv_unicast_packet) != 10);\n\tBUILD_BUG_ON(sizeof(struct batadv_unicast_4addr_packet) != 18);\n\tBUILD_BUG_ON(sizeof(struct batadv_frag_packet) != 20);\n\tBUILD_BUG_ON(sizeof(struct batadv_bcast_packet) != 14);\n\tBUILD_BUG_ON(sizeof(struct batadv_coded_packet) != 46);\n\tBUILD_BUG_ON(sizeof(struct batadv_unicast_tvlv_packet) != 20);\n\tBUILD_BUG_ON(sizeof(struct batadv_tvlv_hdr) != 4);\n\tBUILD_BUG_ON(sizeof(struct batadv_tvlv_gateway_data) != 8);\n\tBUILD_BUG_ON(sizeof(struct batadv_tvlv_tt_vlan_data) != 8);\n\tBUILD_BUG_ON(sizeof(struct batadv_tvlv_tt_change) != 12);\n\tBUILD_BUG_ON(sizeof(struct batadv_tvlv_roam_adv) != 8);\n\n\ti = sizeof_field(struct sk_buff, cb);\n\tBUILD_BUG_ON(sizeof(struct batadv_skb_cb) > i);\n\n\t \n\tbatadv_rx_handler[BATADV_BCAST] = batadv_recv_bcast_packet;\n\n\t \n\t \n\tbatadv_rx_handler[BATADV_UNICAST_4ADDR] = batadv_recv_unicast_packet;\n\t \n\tbatadv_rx_handler[BATADV_UNICAST] = batadv_recv_unicast_packet;\n\t \n\tbatadv_rx_handler[BATADV_UNICAST_TVLV] = batadv_recv_unicast_tvlv;\n\t \n\tbatadv_rx_handler[BATADV_ICMP] = batadv_recv_icmp_packet;\n\t \n\tbatadv_rx_handler[BATADV_UNICAST_FRAG] = batadv_recv_frag_packet;\n}\n\n \nint\nbatadv_recv_handler_register(u8 packet_type,\n\t\t\t     int (*recv_handler)(struct sk_buff *,\n\t\t\t\t\t\t struct batadv_hard_iface *))\n{\n\tint (*curr)(struct sk_buff *skb,\n\t\t    struct batadv_hard_iface *recv_if);\n\tcurr = batadv_rx_handler[packet_type];\n\n\tif (curr != batadv_recv_unhandled_packet &&\n\t    curr != batadv_recv_unhandled_unicast_packet)\n\t\treturn -EBUSY;\n\n\tbatadv_rx_handler[packet_type] = recv_handler;\n\treturn 0;\n}\n\n \nvoid batadv_recv_handler_unregister(u8 packet_type)\n{\n\tbatadv_rx_handler[packet_type] = batadv_recv_unhandled_packet;\n}\n\n \n__be32 batadv_skb_crc32(struct sk_buff *skb, u8 *payload_ptr)\n{\n\tu32 crc = 0;\n\tunsigned int from;\n\tunsigned int to = skb->len;\n\tstruct skb_seq_state st;\n\tconst u8 *data;\n\tunsigned int len;\n\tunsigned int consumed = 0;\n\n\tfrom = (unsigned int)(payload_ptr - skb->data);\n\n\tskb_prepare_seq_read(skb, from, to, &st);\n\twhile ((len = skb_seq_read(consumed, &data, &st)) != 0) {\n\t\tcrc = crc32c(crc, data, len);\n\t\tconsumed += len;\n\t}\n\n\treturn htonl(crc);\n}\n\n \nunsigned short batadv_get_vid(struct sk_buff *skb, size_t header_len)\n{\n\tstruct ethhdr *ethhdr = (struct ethhdr *)(skb->data + header_len);\n\tstruct vlan_ethhdr *vhdr;\n\tunsigned short vid;\n\n\tif (ethhdr->h_proto != htons(ETH_P_8021Q))\n\t\treturn BATADV_NO_FLAGS;\n\n\tif (!pskb_may_pull(skb, header_len + VLAN_ETH_HLEN))\n\t\treturn BATADV_NO_FLAGS;\n\n\tvhdr = (struct vlan_ethhdr *)(skb->data + header_len);\n\tvid = ntohs(vhdr->h_vlan_TCI) & VLAN_VID_MASK;\n\tvid |= BATADV_VLAN_HAS_TAG;\n\n\treturn vid;\n}\n\n \nbool batadv_vlan_ap_isola_get(struct batadv_priv *bat_priv, unsigned short vid)\n{\n\tbool ap_isolation_enabled = false;\n\tstruct batadv_softif_vlan *vlan;\n\n\t \n\tvlan = batadv_softif_vlan_get(bat_priv, vid);\n\tif (vlan) {\n\t\tap_isolation_enabled = atomic_read(&vlan->ap_isolation);\n\t\tbatadv_softif_vlan_put(vlan);\n\t}\n\n\treturn ap_isolation_enabled;\n}\n\n \nint batadv_throw_uevent(struct batadv_priv *bat_priv, enum batadv_uev_type type,\n\t\t\tenum batadv_uev_action action, const char *data)\n{\n\tint ret = -ENOMEM;\n\tstruct kobject *bat_kobj;\n\tchar *uevent_env[4] = { NULL, NULL, NULL, NULL };\n\n\tbat_kobj = &bat_priv->soft_iface->dev.kobj;\n\n\tuevent_env[0] = kasprintf(GFP_ATOMIC,\n\t\t\t\t  \"%s%s\", BATADV_UEV_TYPE_VAR,\n\t\t\t\t  batadv_uev_type_str[type]);\n\tif (!uevent_env[0])\n\t\tgoto out;\n\n\tuevent_env[1] = kasprintf(GFP_ATOMIC,\n\t\t\t\t  \"%s%s\", BATADV_UEV_ACTION_VAR,\n\t\t\t\t  batadv_uev_action_str[action]);\n\tif (!uevent_env[1])\n\t\tgoto out;\n\n\t \n\tif (action != BATADV_UEV_DEL) {\n\t\tuevent_env[2] = kasprintf(GFP_ATOMIC,\n\t\t\t\t\t  \"%s%s\", BATADV_UEV_DATA_VAR, data);\n\t\tif (!uevent_env[2])\n\t\t\tgoto out;\n\t}\n\n\tret = kobject_uevent_env(bat_kobj, KOBJ_CHANGE, uevent_env);\nout:\n\tkfree(uevent_env[0]);\n\tkfree(uevent_env[1]);\n\tkfree(uevent_env[2]);\n\n\tif (ret)\n\t\tbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\n\t\t\t   \"Impossible to send uevent for (%s,%s,%s) event (err: %d)\\n\",\n\t\t\t   batadv_uev_type_str[type],\n\t\t\t   batadv_uev_action_str[action],\n\t\t\t   (action == BATADV_UEV_DEL ? \"NULL\" : data), ret);\n\treturn ret;\n}\n\nmodule_init(batadv_init);\nmodule_exit(batadv_exit);\n\nMODULE_LICENSE(\"GPL\");\n\nMODULE_AUTHOR(BATADV_DRIVER_AUTHOR);\nMODULE_DESCRIPTION(BATADV_DRIVER_DESC);\nMODULE_VERSION(BATADV_SOURCE_VERSION);\nMODULE_ALIAS_RTNL_LINK(\"batadv\");\nMODULE_ALIAS_GENL_FAMILY(BATADV_NL_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}