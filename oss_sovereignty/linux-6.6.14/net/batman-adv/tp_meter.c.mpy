{
  "module_name": "tp_meter.c",
  "hash_id": "108ba0685028c1e83b48704f48dbf1fc7e144dc2c8f00a7733425cf2555fc172",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/tp_meter.c",
  "human_readable_source": "\n \n\n#include \"tp_meter.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/build_bug.h>\n#include <linux/byteorder/generic.h>\n#include <linux/cache.h>\n#include <linux/compiler.h>\n#include <linux/container_of.h>\n#include <linux/err.h>\n#include <linux/etherdevice.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/kthread.h>\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/minmax.h>\n#include <linux/netdevice.h>\n#include <linux/param.h>\n#include <linux/printk.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/sched.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"hard-interface.h\"\n#include \"log.h\"\n#include \"netlink.h\"\n#include \"originator.h\"\n#include \"send.h\"\n\n \n#define BATADV_TP_DEF_TEST_LENGTH 10000\n\n \n#define BATADV_TP_AWND 0x20000000\n\n \n#define BATADV_TP_RECV_TIMEOUT 1000\n\n \n#define BATADV_TP_MAX_RTO 30000\n\n \n#define BATADV_TP_FIRST_SEQ ((u32)-1 - 2000)\n\n \n#define BATADV_TP_PLEN (BATADV_TP_PACKET_LEN - ETH_HLEN - \\\n\t\t\tsizeof(struct batadv_unicast_packet))\n\nstatic u8 batadv_tp_prerandom[4096] __read_mostly;\n\n \nstatic u32 batadv_tp_session_cookie(const u8 session[2], u8 icmp_uid)\n{\n\tu32 cookie;\n\n\tcookie = icmp_uid << 16;\n\tcookie |= session[0] << 8;\n\tcookie |= session[1];\n\n\treturn cookie;\n}\n\n \nstatic u32 batadv_tp_cwnd(u32 base, u32 increment, u32 min)\n{\n\tu32 new_size = base + increment;\n\n\t \n\tif (new_size < base)\n\t\tnew_size = (u32)ULONG_MAX;\n\n\tnew_size = min_t(u32, new_size, BATADV_TP_AWND);\n\n\treturn max_t(u32, new_size, min);\n}\n\n \nstatic void batadv_tp_update_cwnd(struct batadv_tp_vars *tp_vars, u32 mss)\n{\n\tspin_lock_bh(&tp_vars->cwnd_lock);\n\n\t \n\tif (tp_vars->cwnd <= tp_vars->ss_threshold) {\n\t\ttp_vars->dec_cwnd = 0;\n\t\ttp_vars->cwnd = batadv_tp_cwnd(tp_vars->cwnd, mss, mss);\n\t\tspin_unlock_bh(&tp_vars->cwnd_lock);\n\t\treturn;\n\t}\n\n\t \n\ttp_vars->dec_cwnd += max_t(u32, 1U << 3,\n\t\t\t\t   ((mss * mss) << 6) / (tp_vars->cwnd << 3));\n\tif (tp_vars->dec_cwnd < (mss << 3)) {\n\t\tspin_unlock_bh(&tp_vars->cwnd_lock);\n\t\treturn;\n\t}\n\n\ttp_vars->cwnd = batadv_tp_cwnd(tp_vars->cwnd, mss, mss);\n\ttp_vars->dec_cwnd = 0;\n\n\tspin_unlock_bh(&tp_vars->cwnd_lock);\n}\n\n \nstatic void batadv_tp_update_rto(struct batadv_tp_vars *tp_vars,\n\t\t\t\t u32 new_rtt)\n{\n\tlong m = new_rtt;\n\n\t \n\tif (tp_vars->srtt != 0) {\n\t\tm -= (tp_vars->srtt >> 3);  \n\t\ttp_vars->srtt += m;  \n\t\tif (m < 0)\n\t\t\tm = -m;\n\n\t\tm -= (tp_vars->rttvar >> 2);\n\t\ttp_vars->rttvar += m;  \n\t} else {\n\t\t \n\t\ttp_vars->srtt = m << 3;\t \n\t\ttp_vars->rttvar = m << 1;  \n\t}\n\n\t \n\ttp_vars->rto = (tp_vars->srtt >> 3) + tp_vars->rttvar;\n}\n\n \nstatic void batadv_tp_batctl_notify(enum batadv_tp_meter_reason reason,\n\t\t\t\t    const u8 *dst, struct batadv_priv *bat_priv,\n\t\t\t\t    unsigned long start_time, u64 total_sent,\n\t\t\t\t    u32 cookie)\n{\n\tu32 test_time;\n\tu8 result;\n\tu32 total_bytes;\n\n\tif (!batadv_tp_is_error(reason)) {\n\t\tresult = BATADV_TP_REASON_COMPLETE;\n\t\ttest_time = jiffies_to_msecs(jiffies - start_time);\n\t\ttotal_bytes = total_sent;\n\t} else {\n\t\tresult = reason;\n\t\ttest_time = 0;\n\t\ttotal_bytes = 0;\n\t}\n\n\tbatadv_netlink_tpmeter_notify(bat_priv, dst, result, test_time,\n\t\t\t\t      total_bytes, cookie);\n}\n\n \nstatic void batadv_tp_batctl_error_notify(enum batadv_tp_meter_reason reason,\n\t\t\t\t\t  const u8 *dst,\n\t\t\t\t\t  struct batadv_priv *bat_priv,\n\t\t\t\t\t  u32 cookie)\n{\n\tbatadv_tp_batctl_notify(reason, dst, bat_priv, 0, 0, cookie);\n}\n\n \nstatic struct batadv_tp_vars *batadv_tp_list_find(struct batadv_priv *bat_priv,\n\t\t\t\t\t\t  const u8 *dst)\n{\n\tstruct batadv_tp_vars *pos, *tp_vars = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(pos, &bat_priv->tp_list, list) {\n\t\tif (!batadv_compare_eth(pos->other_end, dst))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unlikely(!kref_get_unless_zero(&pos->refcount)))\n\t\t\tcontinue;\n\n\t\ttp_vars = pos;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn tp_vars;\n}\n\n \nstatic struct batadv_tp_vars *\nbatadv_tp_list_find_session(struct batadv_priv *bat_priv, const u8 *dst,\n\t\t\t    const u8 *session)\n{\n\tstruct batadv_tp_vars *pos, *tp_vars = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(pos, &bat_priv->tp_list, list) {\n\t\tif (!batadv_compare_eth(pos->other_end, dst))\n\t\t\tcontinue;\n\n\t\tif (memcmp(pos->session, session, sizeof(pos->session)) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unlikely(!kref_get_unless_zero(&pos->refcount)))\n\t\t\tcontinue;\n\n\t\ttp_vars = pos;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn tp_vars;\n}\n\n \nstatic void batadv_tp_vars_release(struct kref *ref)\n{\n\tstruct batadv_tp_vars *tp_vars;\n\tstruct batadv_tp_unacked *un, *safe;\n\n\ttp_vars = container_of(ref, struct batadv_tp_vars, refcount);\n\n\t \n\tspin_lock_bh(&tp_vars->unacked_lock);\n\tlist_for_each_entry_safe(un, safe, &tp_vars->unacked_list, list) {\n\t\tlist_del(&un->list);\n\t\tkfree(un);\n\t}\n\tspin_unlock_bh(&tp_vars->unacked_lock);\n\n\tkfree_rcu(tp_vars, rcu);\n}\n\n \nstatic void batadv_tp_vars_put(struct batadv_tp_vars *tp_vars)\n{\n\tif (!tp_vars)\n\t\treturn;\n\n\tkref_put(&tp_vars->refcount, batadv_tp_vars_release);\n}\n\n \nstatic void batadv_tp_sender_cleanup(struct batadv_priv *bat_priv,\n\t\t\t\t     struct batadv_tp_vars *tp_vars)\n{\n\tcancel_delayed_work(&tp_vars->finish_work);\n\n\tspin_lock_bh(&tp_vars->bat_priv->tp_list_lock);\n\thlist_del_rcu(&tp_vars->list);\n\tspin_unlock_bh(&tp_vars->bat_priv->tp_list_lock);\n\n\t \n\tbatadv_tp_vars_put(tp_vars);\n\n\tatomic_dec(&tp_vars->bat_priv->tp_num);\n\n\t \n\tdel_timer_sync(&tp_vars->timer);\n\t \n\tdel_timer(&tp_vars->timer);\n\tbatadv_tp_vars_put(tp_vars);\n}\n\n \nstatic void batadv_tp_sender_end(struct batadv_priv *bat_priv,\n\t\t\t\t struct batadv_tp_vars *tp_vars)\n{\n\tu32 session_cookie;\n\n\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t   \"Test towards %pM finished..shutting down (reason=%d)\\n\",\n\t\t   tp_vars->other_end, tp_vars->reason);\n\n\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t   \"Last timing stats: SRTT=%ums RTTVAR=%ums RTO=%ums\\n\",\n\t\t   tp_vars->srtt >> 3, tp_vars->rttvar >> 2, tp_vars->rto);\n\n\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t   \"Final values: cwnd=%u ss_threshold=%u\\n\",\n\t\t   tp_vars->cwnd, tp_vars->ss_threshold);\n\n\tsession_cookie = batadv_tp_session_cookie(tp_vars->session,\n\t\t\t\t\t\t  tp_vars->icmp_uid);\n\n\tbatadv_tp_batctl_notify(tp_vars->reason,\n\t\t\t\ttp_vars->other_end,\n\t\t\t\tbat_priv,\n\t\t\t\ttp_vars->start_time,\n\t\t\t\tatomic64_read(&tp_vars->tot_sent),\n\t\t\t\tsession_cookie);\n}\n\n \nstatic void batadv_tp_sender_shutdown(struct batadv_tp_vars *tp_vars,\n\t\t\t\t      enum batadv_tp_meter_reason reason)\n{\n\tif (!atomic_dec_and_test(&tp_vars->sending))\n\t\treturn;\n\n\ttp_vars->reason = reason;\n}\n\n \nstatic void batadv_tp_sender_finish(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work;\n\tstruct batadv_tp_vars *tp_vars;\n\n\tdelayed_work = to_delayed_work(work);\n\ttp_vars = container_of(delayed_work, struct batadv_tp_vars,\n\t\t\t       finish_work);\n\n\tbatadv_tp_sender_shutdown(tp_vars, BATADV_TP_REASON_COMPLETE);\n}\n\n \nstatic void batadv_tp_reset_sender_timer(struct batadv_tp_vars *tp_vars)\n{\n\t \n\tif (unlikely(atomic_read(&tp_vars->sending) == 0))\n\t\t \n\t\treturn;\n\n\tmod_timer(&tp_vars->timer, jiffies + msecs_to_jiffies(tp_vars->rto));\n}\n\n \nstatic void batadv_tp_sender_timeout(struct timer_list *t)\n{\n\tstruct batadv_tp_vars *tp_vars = from_timer(tp_vars, t, timer);\n\tstruct batadv_priv *bat_priv = tp_vars->bat_priv;\n\n\tif (atomic_read(&tp_vars->sending) == 0)\n\t\treturn;\n\n\t \n\tif (unlikely(tp_vars->rto >= BATADV_TP_MAX_RTO)) {\n\t\tbatadv_tp_sender_shutdown(tp_vars,\n\t\t\t\t\t  BATADV_TP_REASON_DST_UNREACHABLE);\n\t\treturn;\n\t}\n\n\t \n\ttp_vars->rto <<= 1;\n\n\tspin_lock_bh(&tp_vars->cwnd_lock);\n\n\ttp_vars->ss_threshold = tp_vars->cwnd >> 1;\n\tif (tp_vars->ss_threshold < BATADV_TP_PLEN * 2)\n\t\ttp_vars->ss_threshold = BATADV_TP_PLEN * 2;\n\n\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t   \"Meter: RTO fired during test towards %pM! cwnd=%u new ss_thr=%u, resetting last_sent to %u\\n\",\n\t\t   tp_vars->other_end, tp_vars->cwnd, tp_vars->ss_threshold,\n\t\t   atomic_read(&tp_vars->last_acked));\n\n\ttp_vars->cwnd = BATADV_TP_PLEN * 3;\n\n\tspin_unlock_bh(&tp_vars->cwnd_lock);\n\n\t \n\ttp_vars->last_sent = atomic_read(&tp_vars->last_acked);\n\twake_up(&tp_vars->more_bytes);\n\n\tbatadv_tp_reset_sender_timer(tp_vars);\n}\n\n \nstatic void batadv_tp_fill_prerandom(struct batadv_tp_vars *tp_vars,\n\t\t\t\t     u8 *buf, size_t nbytes)\n{\n\tu32 local_offset;\n\tsize_t bytes_inbuf;\n\tsize_t to_copy;\n\tsize_t pos = 0;\n\n\tspin_lock_bh(&tp_vars->prerandom_lock);\n\tlocal_offset = tp_vars->prerandom_offset;\n\ttp_vars->prerandom_offset += nbytes;\n\ttp_vars->prerandom_offset %= sizeof(batadv_tp_prerandom);\n\tspin_unlock_bh(&tp_vars->prerandom_lock);\n\n\twhile (nbytes) {\n\t\tlocal_offset %= sizeof(batadv_tp_prerandom);\n\t\tbytes_inbuf = sizeof(batadv_tp_prerandom) - local_offset;\n\t\tto_copy = min(nbytes, bytes_inbuf);\n\n\t\tmemcpy(&buf[pos], &batadv_tp_prerandom[local_offset], to_copy);\n\t\tpos += to_copy;\n\t\tnbytes -= to_copy;\n\t\tlocal_offset = 0;\n\t}\n}\n\n \nstatic int batadv_tp_send_msg(struct batadv_tp_vars *tp_vars, const u8 *src,\n\t\t\t      struct batadv_orig_node *orig_node,\n\t\t\t      u32 seqno, size_t len, const u8 *session,\n\t\t\t      int uid, u32 timestamp)\n{\n\tstruct batadv_icmp_tp_packet *icmp;\n\tstruct sk_buff *skb;\n\tint r;\n\tu8 *data;\n\tsize_t data_len;\n\n\tskb = netdev_alloc_skb_ip_align(NULL, len + ETH_HLEN);\n\tif (unlikely(!skb))\n\t\treturn BATADV_TP_REASON_MEMORY_ERROR;\n\n\tskb_reserve(skb, ETH_HLEN);\n\ticmp = skb_put(skb, sizeof(*icmp));\n\n\t \n\tether_addr_copy(icmp->dst, orig_node->orig);\n\tether_addr_copy(icmp->orig, src);\n\ticmp->version = BATADV_COMPAT_VERSION;\n\ticmp->packet_type = BATADV_ICMP;\n\ticmp->ttl = BATADV_TTL;\n\ticmp->msg_type = BATADV_TP;\n\ticmp->uid = uid;\n\n\ticmp->subtype = BATADV_TP_MSG;\n\tmemcpy(icmp->session, session, sizeof(icmp->session));\n\ticmp->seqno = htonl(seqno);\n\ticmp->timestamp = htonl(timestamp);\n\n\tdata_len = len - sizeof(*icmp);\n\tdata = skb_put(skb, data_len);\n\tbatadv_tp_fill_prerandom(tp_vars, data, data_len);\n\n\tr = batadv_send_skb_to_orig(skb, orig_node, NULL);\n\tif (r == NET_XMIT_SUCCESS)\n\t\treturn 0;\n\n\treturn BATADV_TP_REASON_CANT_SEND;\n}\n\n \nstatic void batadv_tp_recv_ack(struct batadv_priv *bat_priv,\n\t\t\t       const struct sk_buff *skb)\n{\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_orig_node *orig_node = NULL;\n\tconst struct batadv_icmp_tp_packet *icmp;\n\tstruct batadv_tp_vars *tp_vars;\n\tconst unsigned char *dev_addr;\n\tsize_t packet_len, mss;\n\tu32 rtt, recv_ack, cwnd;\n\n\tpacket_len = BATADV_TP_PLEN;\n\tmss = BATADV_TP_PLEN;\n\tpacket_len += sizeof(struct batadv_unicast_packet);\n\n\ticmp = (struct batadv_icmp_tp_packet *)skb->data;\n\n\t \n\ttp_vars = batadv_tp_list_find_session(bat_priv, icmp->orig,\n\t\t\t\t\t      icmp->session);\n\tif (unlikely(!tp_vars))\n\t\treturn;\n\n\tif (unlikely(atomic_read(&tp_vars->sending) == 0))\n\t\tgoto out;\n\n\t \n\tif (batadv_seq_before(ntohl(icmp->seqno),\n\t\t\t      (u32)atomic_read(&tp_vars->last_acked)))\n\t\tgoto out;\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (unlikely(!primary_if))\n\t\tgoto out;\n\n\torig_node = batadv_orig_hash_find(bat_priv, icmp->orig);\n\tif (unlikely(!orig_node))\n\t\tgoto out;\n\n\t \n\trtt = jiffies_to_msecs(jiffies) - ntohl(icmp->timestamp);\n\tif (icmp->timestamp && rtt)\n\t\tbatadv_tp_update_rto(tp_vars, rtt);\n\n\t \n\tbatadv_tp_reset_sender_timer(tp_vars);\n\n\trecv_ack = ntohl(icmp->seqno);\n\n\t \n\tif (atomic_read(&tp_vars->last_acked) == recv_ack) {\n\t\tatomic_inc(&tp_vars->dup_acks);\n\t\tif (atomic_read(&tp_vars->dup_acks) != 3)\n\t\t\tgoto out;\n\n\t\tif (recv_ack >= tp_vars->recover)\n\t\t\tgoto out;\n\n\t\t \n\t\tbatadv_tp_send_msg(tp_vars, primary_if->net_dev->dev_addr,\n\t\t\t\t   orig_node, recv_ack, packet_len,\n\t\t\t\t   icmp->session, icmp->uid,\n\t\t\t\t   jiffies_to_msecs(jiffies));\n\n\t\tspin_lock_bh(&tp_vars->cwnd_lock);\n\n\t\t \n\t\ttp_vars->fast_recovery = true;\n\t\t \n\t\ttp_vars->recover = tp_vars->last_sent;\n\t\ttp_vars->ss_threshold = tp_vars->cwnd >> 1;\n\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t   \"Meter: Fast Recovery, (cur cwnd=%u) ss_thr=%u last_sent=%u recv_ack=%u\\n\",\n\t\t\t   tp_vars->cwnd, tp_vars->ss_threshold,\n\t\t\t   tp_vars->last_sent, recv_ack);\n\t\ttp_vars->cwnd = batadv_tp_cwnd(tp_vars->ss_threshold, 3 * mss,\n\t\t\t\t\t       mss);\n\t\ttp_vars->dec_cwnd = 0;\n\t\ttp_vars->last_sent = recv_ack;\n\n\t\tspin_unlock_bh(&tp_vars->cwnd_lock);\n\t} else {\n\t\t \n\t\tatomic64_add(recv_ack - atomic_read(&tp_vars->last_acked),\n\t\t\t     &tp_vars->tot_sent);\n\t\t \n\t\tatomic_set(&tp_vars->dup_acks, 0);\n\n\t\tif (tp_vars->fast_recovery) {\n\t\t\t \n\t\t\tif (batadv_seq_before(recv_ack, tp_vars->recover)) {\n\t\t\t\t \n\t\t\t\tdev_addr = primary_if->net_dev->dev_addr;\n\t\t\t\tbatadv_tp_send_msg(tp_vars, dev_addr,\n\t\t\t\t\t\t   orig_node, recv_ack,\n\t\t\t\t\t\t   packet_len, icmp->session,\n\t\t\t\t\t\t   icmp->uid,\n\t\t\t\t\t\t   jiffies_to_msecs(jiffies));\n\t\t\t\ttp_vars->cwnd = batadv_tp_cwnd(tp_vars->cwnd,\n\t\t\t\t\t\t\t       mss, mss);\n\t\t\t} else {\n\t\t\t\ttp_vars->fast_recovery = false;\n\t\t\t\t \n\t\t\t\tcwnd = batadv_tp_cwnd(tp_vars->ss_threshold, 0,\n\t\t\t\t\t\t      mss);\n\t\t\t\ttp_vars->cwnd = cwnd;\n\t\t\t}\n\t\t\tgoto move_twnd;\n\t\t}\n\n\t\tif (recv_ack - atomic_read(&tp_vars->last_acked) >= mss)\n\t\t\tbatadv_tp_update_cwnd(tp_vars, mss);\nmove_twnd:\n\t\t \n\t\tatomic_set(&tp_vars->last_acked, recv_ack);\n\t}\n\n\twake_up(&tp_vars->more_bytes);\nout:\n\tbatadv_hardif_put(primary_if);\n\tbatadv_orig_node_put(orig_node);\n\tbatadv_tp_vars_put(tp_vars);\n}\n\n \nstatic bool batadv_tp_avail(struct batadv_tp_vars *tp_vars,\n\t\t\t    size_t payload_len)\n{\n\tu32 win_left, win_limit;\n\n\twin_limit = atomic_read(&tp_vars->last_acked) + tp_vars->cwnd;\n\twin_left = win_limit - tp_vars->last_sent;\n\n\treturn win_left >= payload_len;\n}\n\n \nstatic int batadv_tp_wait_available(struct batadv_tp_vars *tp_vars, size_t plen)\n{\n\tint ret;\n\n\tret = wait_event_interruptible_timeout(tp_vars->more_bytes,\n\t\t\t\t\t       batadv_tp_avail(tp_vars, plen),\n\t\t\t\t\t       HZ / 10);\n\n\treturn ret;\n}\n\n \nstatic int batadv_tp_send(void *arg)\n{\n\tstruct batadv_tp_vars *tp_vars = arg;\n\tstruct batadv_priv *bat_priv = tp_vars->bat_priv;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_orig_node *orig_node = NULL;\n\tsize_t payload_len, packet_len;\n\tint err = 0;\n\n\tif (unlikely(tp_vars->role != BATADV_TP_SENDER)) {\n\t\terr = BATADV_TP_REASON_DST_UNREACHABLE;\n\t\ttp_vars->reason = err;\n\t\tgoto out;\n\t}\n\n\torig_node = batadv_orig_hash_find(bat_priv, tp_vars->other_end);\n\tif (unlikely(!orig_node)) {\n\t\terr = BATADV_TP_REASON_DST_UNREACHABLE;\n\t\ttp_vars->reason = err;\n\t\tgoto out;\n\t}\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (unlikely(!primary_if)) {\n\t\terr = BATADV_TP_REASON_DST_UNREACHABLE;\n\t\ttp_vars->reason = err;\n\t\tgoto out;\n\t}\n\n\t \n\tpayload_len = BATADV_TP_PLEN;\n\tBUILD_BUG_ON(sizeof(struct batadv_icmp_tp_packet) > BATADV_TP_PLEN);\n\n\tbatadv_tp_reset_sender_timer(tp_vars);\n\n\t \n\tqueue_delayed_work(batadv_event_workqueue, &tp_vars->finish_work,\n\t\t\t   msecs_to_jiffies(tp_vars->test_length));\n\n\twhile (atomic_read(&tp_vars->sending) != 0) {\n\t\tif (unlikely(!batadv_tp_avail(tp_vars, payload_len))) {\n\t\t\tbatadv_tp_wait_available(tp_vars, payload_len);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpacket_len = payload_len + sizeof(struct batadv_unicast_packet);\n\n\t\terr = batadv_tp_send_msg(tp_vars, primary_if->net_dev->dev_addr,\n\t\t\t\t\t orig_node, tp_vars->last_sent,\n\t\t\t\t\t packet_len,\n\t\t\t\t\t tp_vars->session, tp_vars->icmp_uid,\n\t\t\t\t\t jiffies_to_msecs(jiffies));\n\n\t\t \n\t\tif (unlikely(err && err != BATADV_TP_REASON_CANT_SEND)) {\n\t\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t\t   \"Meter: %s() cannot send packets (%d)\\n\",\n\t\t\t\t   __func__, err);\n\t\t\t \n\t\t\tif (atomic_dec_and_test(&tp_vars->sending))\n\t\t\t\ttp_vars->reason = err;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!err)\n\t\t\ttp_vars->last_sent += payload_len;\n\n\t\tcond_resched();\n\t}\n\nout:\n\tbatadv_hardif_put(primary_if);\n\tbatadv_orig_node_put(orig_node);\n\n\tbatadv_tp_sender_end(bat_priv, tp_vars);\n\tbatadv_tp_sender_cleanup(bat_priv, tp_vars);\n\n\tbatadv_tp_vars_put(tp_vars);\n\n\treturn 0;\n}\n\n \nstatic void batadv_tp_start_kthread(struct batadv_tp_vars *tp_vars)\n{\n\tstruct task_struct *kthread;\n\tstruct batadv_priv *bat_priv = tp_vars->bat_priv;\n\tu32 session_cookie;\n\n\tkref_get(&tp_vars->refcount);\n\tkthread = kthread_create(batadv_tp_send, tp_vars, \"kbatadv_tp_meter\");\n\tif (IS_ERR(kthread)) {\n\t\tsession_cookie = batadv_tp_session_cookie(tp_vars->session,\n\t\t\t\t\t\t\t  tp_vars->icmp_uid);\n\t\tpr_err(\"batadv: cannot create tp meter kthread\\n\");\n\t\tbatadv_tp_batctl_error_notify(BATADV_TP_REASON_MEMORY_ERROR,\n\t\t\t\t\t      tp_vars->other_end,\n\t\t\t\t\t      bat_priv, session_cookie);\n\n\t\t \n\t\tbatadv_tp_vars_put(tp_vars);\n\n\t\t \n\t\tbatadv_tp_sender_cleanup(bat_priv, tp_vars);\n\t\treturn;\n\t}\n\n\twake_up_process(kthread);\n}\n\n \nvoid batadv_tp_start(struct batadv_priv *bat_priv, const u8 *dst,\n\t\t     u32 test_length, u32 *cookie)\n{\n\tstruct batadv_tp_vars *tp_vars;\n\tu8 session_id[2];\n\tu8 icmp_uid;\n\tu32 session_cookie;\n\n\tget_random_bytes(session_id, sizeof(session_id));\n\tget_random_bytes(&icmp_uid, 1);\n\tsession_cookie = batadv_tp_session_cookie(session_id, icmp_uid);\n\t*cookie = session_cookie;\n\n\t \n\tspin_lock_bh(&bat_priv->tp_list_lock);\n\ttp_vars = batadv_tp_list_find(bat_priv, dst);\n\tif (tp_vars) {\n\t\tspin_unlock_bh(&bat_priv->tp_list_lock);\n\t\tbatadv_tp_vars_put(tp_vars);\n\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t   \"Meter: test to or from the same node already ongoing, aborting\\n\");\n\t\tbatadv_tp_batctl_error_notify(BATADV_TP_REASON_ALREADY_ONGOING,\n\t\t\t\t\t      dst, bat_priv, session_cookie);\n\t\treturn;\n\t}\n\n\tif (!atomic_add_unless(&bat_priv->tp_num, 1, BATADV_TP_MAX_NUM)) {\n\t\tspin_unlock_bh(&bat_priv->tp_list_lock);\n\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t   \"Meter: too many ongoing sessions, aborting (SEND)\\n\");\n\t\tbatadv_tp_batctl_error_notify(BATADV_TP_REASON_TOO_MANY, dst,\n\t\t\t\t\t      bat_priv, session_cookie);\n\t\treturn;\n\t}\n\n\ttp_vars = kmalloc(sizeof(*tp_vars), GFP_ATOMIC);\n\tif (!tp_vars) {\n\t\tspin_unlock_bh(&bat_priv->tp_list_lock);\n\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t   \"Meter: %s cannot allocate list elements\\n\",\n\t\t\t   __func__);\n\t\tbatadv_tp_batctl_error_notify(BATADV_TP_REASON_MEMORY_ERROR,\n\t\t\t\t\t      dst, bat_priv, session_cookie);\n\t\treturn;\n\t}\n\n\t \n\tether_addr_copy(tp_vars->other_end, dst);\n\tkref_init(&tp_vars->refcount);\n\ttp_vars->role = BATADV_TP_SENDER;\n\tatomic_set(&tp_vars->sending, 1);\n\tmemcpy(tp_vars->session, session_id, sizeof(session_id));\n\ttp_vars->icmp_uid = icmp_uid;\n\n\ttp_vars->last_sent = BATADV_TP_FIRST_SEQ;\n\tatomic_set(&tp_vars->last_acked, BATADV_TP_FIRST_SEQ);\n\ttp_vars->fast_recovery = false;\n\ttp_vars->recover = BATADV_TP_FIRST_SEQ;\n\n\t \n\ttp_vars->cwnd = BATADV_TP_PLEN * 3;\n\t \n\ttp_vars->ss_threshold = BATADV_TP_AWND;\n\n\t \n\ttp_vars->rto = 1000;\n\ttp_vars->srtt = 0;\n\ttp_vars->rttvar = 0;\n\n\tatomic64_set(&tp_vars->tot_sent, 0);\n\n\tkref_get(&tp_vars->refcount);\n\ttimer_setup(&tp_vars->timer, batadv_tp_sender_timeout, 0);\n\n\ttp_vars->bat_priv = bat_priv;\n\ttp_vars->start_time = jiffies;\n\n\tinit_waitqueue_head(&tp_vars->more_bytes);\n\n\tspin_lock_init(&tp_vars->unacked_lock);\n\tINIT_LIST_HEAD(&tp_vars->unacked_list);\n\n\tspin_lock_init(&tp_vars->cwnd_lock);\n\n\ttp_vars->prerandom_offset = 0;\n\tspin_lock_init(&tp_vars->prerandom_lock);\n\n\tkref_get(&tp_vars->refcount);\n\thlist_add_head_rcu(&tp_vars->list, &bat_priv->tp_list);\n\tspin_unlock_bh(&bat_priv->tp_list_lock);\n\n\ttp_vars->test_length = test_length;\n\tif (!tp_vars->test_length)\n\t\ttp_vars->test_length = BATADV_TP_DEF_TEST_LENGTH;\n\n\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t   \"Meter: starting throughput meter towards %pM (length=%ums)\\n\",\n\t\t   dst, test_length);\n\n\t \n\tINIT_DELAYED_WORK(&tp_vars->finish_work, batadv_tp_sender_finish);\n\n\t \n\tbatadv_tp_start_kthread(tp_vars);\n\n\t \n\tbatadv_tp_vars_put(tp_vars);\n}\n\n \nvoid batadv_tp_stop(struct batadv_priv *bat_priv, const u8 *dst,\n\t\t    u8 return_value)\n{\n\tstruct batadv_orig_node *orig_node;\n\tstruct batadv_tp_vars *tp_vars;\n\n\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t   \"Meter: stopping test towards %pM\\n\", dst);\n\n\torig_node = batadv_orig_hash_find(bat_priv, dst);\n\tif (!orig_node)\n\t\treturn;\n\n\ttp_vars = batadv_tp_list_find(bat_priv, orig_node->orig);\n\tif (!tp_vars) {\n\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t   \"Meter: trying to interrupt an already over connection\\n\");\n\t\tgoto out;\n\t}\n\n\tbatadv_tp_sender_shutdown(tp_vars, return_value);\n\tbatadv_tp_vars_put(tp_vars);\nout:\n\tbatadv_orig_node_put(orig_node);\n}\n\n \nstatic void batadv_tp_reset_receiver_timer(struct batadv_tp_vars *tp_vars)\n{\n\tmod_timer(&tp_vars->timer,\n\t\t  jiffies + msecs_to_jiffies(BATADV_TP_RECV_TIMEOUT));\n}\n\n \nstatic void batadv_tp_receiver_shutdown(struct timer_list *t)\n{\n\tstruct batadv_tp_vars *tp_vars = from_timer(tp_vars, t, timer);\n\tstruct batadv_tp_unacked *un, *safe;\n\tstruct batadv_priv *bat_priv;\n\n\tbat_priv = tp_vars->bat_priv;\n\n\t \n\tif (!batadv_has_timed_out(tp_vars->last_recv_time,\n\t\t\t\t  BATADV_TP_RECV_TIMEOUT)) {\n\t\t \n\t\tbatadv_tp_reset_receiver_timer(tp_vars);\n\t\treturn;\n\t}\n\n\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t   \"Shutting down for inactivity (more than %dms) from %pM\\n\",\n\t\t   BATADV_TP_RECV_TIMEOUT, tp_vars->other_end);\n\n\tspin_lock_bh(&tp_vars->bat_priv->tp_list_lock);\n\thlist_del_rcu(&tp_vars->list);\n\tspin_unlock_bh(&tp_vars->bat_priv->tp_list_lock);\n\n\t \n\tbatadv_tp_vars_put(tp_vars);\n\n\tatomic_dec(&bat_priv->tp_num);\n\n\tspin_lock_bh(&tp_vars->unacked_lock);\n\tlist_for_each_entry_safe(un, safe, &tp_vars->unacked_list, list) {\n\t\tlist_del(&un->list);\n\t\tkfree(un);\n\t}\n\tspin_unlock_bh(&tp_vars->unacked_lock);\n\n\t \n\tbatadv_tp_vars_put(tp_vars);\n}\n\n \nstatic int batadv_tp_send_ack(struct batadv_priv *bat_priv, const u8 *dst,\n\t\t\t      u32 seq, __be32 timestamp, const u8 *session,\n\t\t\t      int socket_index)\n{\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_orig_node *orig_node;\n\tstruct batadv_icmp_tp_packet *icmp;\n\tstruct sk_buff *skb;\n\tint r, ret;\n\n\torig_node = batadv_orig_hash_find(bat_priv, dst);\n\tif (unlikely(!orig_node)) {\n\t\tret = BATADV_TP_REASON_DST_UNREACHABLE;\n\t\tgoto out;\n\t}\n\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (unlikely(!primary_if)) {\n\t\tret = BATADV_TP_REASON_DST_UNREACHABLE;\n\t\tgoto out;\n\t}\n\n\tskb = netdev_alloc_skb_ip_align(NULL, sizeof(*icmp) + ETH_HLEN);\n\tif (unlikely(!skb)) {\n\t\tret = BATADV_TP_REASON_MEMORY_ERROR;\n\t\tgoto out;\n\t}\n\n\tskb_reserve(skb, ETH_HLEN);\n\ticmp = skb_put(skb, sizeof(*icmp));\n\ticmp->packet_type = BATADV_ICMP;\n\ticmp->version = BATADV_COMPAT_VERSION;\n\ticmp->ttl = BATADV_TTL;\n\ticmp->msg_type = BATADV_TP;\n\tether_addr_copy(icmp->dst, orig_node->orig);\n\tether_addr_copy(icmp->orig, primary_if->net_dev->dev_addr);\n\ticmp->uid = socket_index;\n\n\ticmp->subtype = BATADV_TP_ACK;\n\tmemcpy(icmp->session, session, sizeof(icmp->session));\n\ticmp->seqno = htonl(seq);\n\ticmp->timestamp = timestamp;\n\n\t \n\tr = batadv_send_skb_to_orig(skb, orig_node, NULL);\n\tif (unlikely(r < 0) || r == NET_XMIT_DROP) {\n\t\tret = BATADV_TP_REASON_DST_UNREACHABLE;\n\t\tgoto out;\n\t}\n\tret = 0;\n\nout:\n\tbatadv_orig_node_put(orig_node);\n\tbatadv_hardif_put(primary_if);\n\n\treturn ret;\n}\n\n \nstatic bool batadv_tp_handle_out_of_order(struct batadv_tp_vars *tp_vars,\n\t\t\t\t\t  const struct sk_buff *skb)\n{\n\tconst struct batadv_icmp_tp_packet *icmp;\n\tstruct batadv_tp_unacked *un, *new;\n\tu32 payload_len;\n\tbool added = false;\n\n\tnew = kmalloc(sizeof(*new), GFP_ATOMIC);\n\tif (unlikely(!new))\n\t\treturn false;\n\n\ticmp = (struct batadv_icmp_tp_packet *)skb->data;\n\n\tnew->seqno = ntohl(icmp->seqno);\n\tpayload_len = skb->len - sizeof(struct batadv_unicast_packet);\n\tnew->len = payload_len;\n\n\tspin_lock_bh(&tp_vars->unacked_lock);\n\t \n\tif (list_empty(&tp_vars->unacked_list)) {\n\t\tlist_add(&new->list, &tp_vars->unacked_list);\n\t\tgoto out;\n\t}\n\n\t \n\tlist_for_each_entry_reverse(un, &tp_vars->unacked_list, list) {\n\t\t \n\t\tif (new->seqno == un->seqno) {\n\t\t\tif (new->len > un->len)\n\t\t\t\tun->len = new->len;\n\t\t\tkfree(new);\n\t\t\tadded = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (batadv_seq_before(new->seqno, un->seqno))\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_add_tail(&new->list, &un->list);\n\t\tadded = true;\n\t\tbreak;\n\t}\n\n\t \n\tif (!added)\n\t\tlist_add(&new->list, &tp_vars->unacked_list);\n\nout:\n\tspin_unlock_bh(&tp_vars->unacked_lock);\n\n\treturn true;\n}\n\n \nstatic void batadv_tp_ack_unordered(struct batadv_tp_vars *tp_vars)\n{\n\tstruct batadv_tp_unacked *un, *safe;\n\tu32 to_ack;\n\n\t \n\tspin_lock_bh(&tp_vars->unacked_lock);\n\tlist_for_each_entry_safe(un, safe, &tp_vars->unacked_list, list) {\n\t\t \n\t\tif (batadv_seq_before(tp_vars->last_recv, un->seqno))\n\t\t\tbreak;\n\n\t\tto_ack = un->seqno + un->len - tp_vars->last_recv;\n\n\t\tif (batadv_seq_before(tp_vars->last_recv, un->seqno + un->len))\n\t\t\ttp_vars->last_recv += to_ack;\n\n\t\tlist_del(&un->list);\n\t\tkfree(un);\n\t}\n\tspin_unlock_bh(&tp_vars->unacked_lock);\n}\n\n \nstatic struct batadv_tp_vars *\nbatadv_tp_init_recv(struct batadv_priv *bat_priv,\n\t\t    const struct batadv_icmp_tp_packet *icmp)\n{\n\tstruct batadv_tp_vars *tp_vars;\n\n\tspin_lock_bh(&bat_priv->tp_list_lock);\n\ttp_vars = batadv_tp_list_find_session(bat_priv, icmp->orig,\n\t\t\t\t\t      icmp->session);\n\tif (tp_vars)\n\t\tgoto out_unlock;\n\n\tif (!atomic_add_unless(&bat_priv->tp_num, 1, BATADV_TP_MAX_NUM)) {\n\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t   \"Meter: too many ongoing sessions, aborting (RECV)\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\ttp_vars = kmalloc(sizeof(*tp_vars), GFP_ATOMIC);\n\tif (!tp_vars)\n\t\tgoto out_unlock;\n\n\tether_addr_copy(tp_vars->other_end, icmp->orig);\n\ttp_vars->role = BATADV_TP_RECEIVER;\n\tmemcpy(tp_vars->session, icmp->session, sizeof(tp_vars->session));\n\ttp_vars->last_recv = BATADV_TP_FIRST_SEQ;\n\ttp_vars->bat_priv = bat_priv;\n\tkref_init(&tp_vars->refcount);\n\n\tspin_lock_init(&tp_vars->unacked_lock);\n\tINIT_LIST_HEAD(&tp_vars->unacked_list);\n\n\tkref_get(&tp_vars->refcount);\n\thlist_add_head_rcu(&tp_vars->list, &bat_priv->tp_list);\n\n\tkref_get(&tp_vars->refcount);\n\ttimer_setup(&tp_vars->timer, batadv_tp_receiver_shutdown, 0);\n\n\tbatadv_tp_reset_receiver_timer(tp_vars);\n\nout_unlock:\n\tspin_unlock_bh(&bat_priv->tp_list_lock);\n\n\treturn tp_vars;\n}\n\n \nstatic void batadv_tp_recv_msg(struct batadv_priv *bat_priv,\n\t\t\t       const struct sk_buff *skb)\n{\n\tconst struct batadv_icmp_tp_packet *icmp;\n\tstruct batadv_tp_vars *tp_vars;\n\tsize_t packet_size;\n\tu32 seqno;\n\n\ticmp = (struct batadv_icmp_tp_packet *)skb->data;\n\n\tseqno = ntohl(icmp->seqno);\n\t \n\tif (seqno == BATADV_TP_FIRST_SEQ) {\n\t\ttp_vars = batadv_tp_init_recv(bat_priv, icmp);\n\t\tif (!tp_vars) {\n\t\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t\t   \"Meter: seqno != BATADV_TP_FIRST_SEQ cannot initiate connection\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\ttp_vars = batadv_tp_list_find_session(bat_priv, icmp->orig,\n\t\t\t\t\t\t      icmp->session);\n\t\tif (!tp_vars) {\n\t\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t\t   \"Unexpected packet from %pM!\\n\",\n\t\t\t\t   icmp->orig);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (unlikely(tp_vars->role != BATADV_TP_RECEIVER)) {\n\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t   \"Meter: dropping packet: not expected (role=%u)\\n\",\n\t\t\t   tp_vars->role);\n\t\tgoto out;\n\t}\n\n\ttp_vars->last_recv_time = jiffies;\n\n\t \n\tif (batadv_seq_before(seqno, tp_vars->last_recv))\n\t\tgoto send_ack;\n\n\t \n\tif (ntohl(icmp->seqno) != tp_vars->last_recv) {\n\t\t \n\t\tif (!batadv_tp_handle_out_of_order(tp_vars, skb))\n\t\t\tgoto out;\n\n\t\t \n\t\tgoto send_ack;\n\t}\n\n\t \n\tpacket_size = skb->len - sizeof(struct batadv_unicast_packet);\n\ttp_vars->last_recv += packet_size;\n\n\t \n\tbatadv_tp_ack_unordered(tp_vars);\n\nsend_ack:\n\t \n\tbatadv_tp_send_ack(bat_priv, icmp->orig, tp_vars->last_recv,\n\t\t\t   icmp->timestamp, icmp->session, icmp->uid);\nout:\n\tbatadv_tp_vars_put(tp_vars);\n}\n\n \nvoid batadv_tp_meter_recv(struct batadv_priv *bat_priv, struct sk_buff *skb)\n{\n\tstruct batadv_icmp_tp_packet *icmp;\n\n\ticmp = (struct batadv_icmp_tp_packet *)skb->data;\n\n\tswitch (icmp->subtype) {\n\tcase BATADV_TP_MSG:\n\t\tbatadv_tp_recv_msg(bat_priv, skb);\n\t\tbreak;\n\tcase BATADV_TP_ACK:\n\t\tbatadv_tp_recv_ack(bat_priv, skb);\n\t\tbreak;\n\tdefault:\n\t\tbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\n\t\t\t   \"Received unknown TP Metric packet type %u\\n\",\n\t\t\t   icmp->subtype);\n\t}\n\tconsume_skb(skb);\n}\n\n \nvoid __init batadv_tp_meter_init(void)\n{\n\tget_random_bytes(batadv_tp_prerandom, sizeof(batadv_tp_prerandom));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}