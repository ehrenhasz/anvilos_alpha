{
  "module_name": "soft-interface.c",
  "hash_id": "e09bba997a47f019bccc793ef3a0d027664fd81c8d6130b4ddf3c3582ba77111",
  "original_prompt": "Ingested from linux-6.6.14/net/batman-adv/soft-interface.c",
  "human_readable_source": "\n \n\n#include \"soft-interface.h\"\n#include \"main.h\"\n\n#include <linux/atomic.h>\n#include <linux/byteorder/generic.h>\n#include <linux/cache.h>\n#include <linux/compiler.h>\n#include <linux/container_of.h>\n#include <linux/cpumask.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/gfp.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/jiffies.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/percpu.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <net/net_namespace.h>\n#include <net/netlink.h>\n#include <uapi/linux/batadv_packet.h>\n#include <uapi/linux/batman_adv.h>\n\n#include \"bat_algo.h\"\n#include \"bridge_loop_avoidance.h\"\n#include \"distributed-arp-table.h\"\n#include \"gateway_client.h\"\n#include \"hard-interface.h\"\n#include \"multicast.h\"\n#include \"network-coding.h\"\n#include \"send.h\"\n#include \"translation-table.h\"\n\n \nint batadv_skb_head_push(struct sk_buff *skb, unsigned int len)\n{\n\tint result;\n\n\t \n\tresult = skb_cow_head(skb, len);\n\tif (result < 0)\n\t\treturn result;\n\n\tskb_push(skb, len);\n\treturn 0;\n}\n\nstatic int batadv_interface_open(struct net_device *dev)\n{\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic int batadv_interface_release(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\n \nstatic u64 batadv_sum_counter(struct batadv_priv *bat_priv,  size_t idx)\n{\n\tu64 *counters, sum = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcounters = per_cpu_ptr(bat_priv->bat_counters, cpu);\n\t\tsum += counters[idx];\n\t}\n\n\treturn sum;\n}\n\nstatic struct net_device_stats *batadv_interface_stats(struct net_device *dev)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\n\tstats->tx_packets = batadv_sum_counter(bat_priv, BATADV_CNT_TX);\n\tstats->tx_bytes = batadv_sum_counter(bat_priv, BATADV_CNT_TX_BYTES);\n\tstats->tx_dropped = batadv_sum_counter(bat_priv, BATADV_CNT_TX_DROPPED);\n\tstats->rx_packets = batadv_sum_counter(bat_priv, BATADV_CNT_RX);\n\tstats->rx_bytes = batadv_sum_counter(bat_priv, BATADV_CNT_RX_BYTES);\n\treturn stats;\n}\n\nstatic int batadv_interface_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(dev);\n\tstruct batadv_softif_vlan *vlan;\n\tstruct sockaddr *addr = p;\n\tu8 old_addr[ETH_ALEN];\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tether_addr_copy(old_addr, dev->dev_addr);\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\t \n\tif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\n\t\treturn 0;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\n\t\tbatadv_tt_local_remove(bat_priv, old_addr, vlan->vid,\n\t\t\t\t       \"mac address changed\", false);\n\t\tbatadv_tt_local_add(dev, addr->sa_data, vlan->vid,\n\t\t\t\t    BATADV_NULL_IFINDEX, BATADV_NO_MARK);\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int batadv_interface_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(dev);\n\n\t \n\tif (new_mtu < ETH_MIN_MTU || new_mtu > batadv_hardif_min_mtu(dev))\n\t\treturn -EINVAL;\n\n\tdev->mtu = new_mtu;\n\tbat_priv->mtu_set_by_user = new_mtu;\n\n\treturn 0;\n}\n\n \nstatic void batadv_interface_set_rx_mode(struct net_device *dev)\n{\n}\n\nstatic netdev_tx_t batadv_interface_tx(struct sk_buff *skb,\n\t\t\t\t       struct net_device *soft_iface)\n{\n\tstruct ethhdr *ethhdr;\n\tstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_bcast_packet *bcast_packet;\n\tstatic const u8 stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00,\n\t\t\t\t\t      0x00, 0x00};\n\tstatic const u8 ectp_addr[ETH_ALEN] = {0xCF, 0x00, 0x00, 0x00,\n\t\t\t\t\t       0x00, 0x00};\n\tenum batadv_dhcp_recipient dhcp_rcp = BATADV_DHCP_NO;\n\tu8 *dst_hint = NULL, chaddr[ETH_ALEN];\n\tstruct vlan_ethhdr *vhdr;\n\tunsigned int header_len = 0;\n\tint data_len = skb->len, ret;\n\tunsigned long brd_delay = 0;\n\tbool do_bcast = false, client_added;\n\tunsigned short vid;\n\tu32 seqno;\n\tint gw_mode;\n\tenum batadv_forw_mode forw_mode = BATADV_FORW_BCAST;\n\tint mcast_is_routable = 0;\n\tint network_offset = ETH_HLEN;\n\t__be16 proto;\n\n\tif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\n\t\tgoto dropped;\n\n\t \n\tmemset(skb->cb, 0, sizeof(struct batadv_skb_cb));\n\n\tnetif_trans_update(soft_iface);\n\tvid = batadv_get_vid(skb, 0);\n\n\tskb_reset_mac_header(skb);\n\tethhdr = eth_hdr(skb);\n\n\tproto = ethhdr->h_proto;\n\n\tswitch (ntohs(proto)) {\n\tcase ETH_P_8021Q:\n\t\tif (!pskb_may_pull(skb, sizeof(*vhdr)))\n\t\t\tgoto dropped;\n\t\tvhdr = vlan_eth_hdr(skb);\n\t\tproto = vhdr->h_vlan_encapsulated_proto;\n\n\t\t \n\t\tif (proto != htons(ETH_P_BATMAN)) {\n\t\t\tnetwork_offset += VLAN_HLEN;\n\t\t\tbreak;\n\t\t}\n\n\t\tfallthrough;\n\tcase ETH_P_BATMAN:\n\t\tgoto dropped;\n\t}\n\n\tskb_set_network_header(skb, network_offset);\n\n\tif (batadv_bla_tx(bat_priv, skb, vid))\n\t\tgoto dropped;\n\n\t \n\tethhdr = eth_hdr(skb);\n\n\t \n\tif (!is_multicast_ether_addr(ethhdr->h_source) &&\n\t    !batadv_bla_is_loopdetect_mac(ethhdr->h_source)) {\n\t\tclient_added = batadv_tt_local_add(soft_iface, ethhdr->h_source,\n\t\t\t\t\t\t   vid, skb->skb_iif,\n\t\t\t\t\t\t   skb->mark);\n\t\tif (!client_added)\n\t\t\tgoto dropped;\n\t}\n\n\t \n\tbatadv_dat_snoop_outgoing_dhcp_ack(bat_priv, skb, proto, vid);\n\n\t \n\tif (batadv_compare_eth(ethhdr->h_dest, stp_addr))\n\t\tgoto dropped;\n\n\tif (batadv_compare_eth(ethhdr->h_dest, ectp_addr))\n\t\tgoto dropped;\n\n\tgw_mode = atomic_read(&bat_priv->gw.mode);\n\tif (is_multicast_ether_addr(ethhdr->h_dest)) {\n\t\t \n\t\tif (gw_mode == BATADV_GW_MODE_OFF) {\n\t\t\tdo_bcast = true;\n\t\t\tgoto send;\n\t\t}\n\n\t\tdhcp_rcp = batadv_gw_dhcp_recipient_get(skb, &header_len,\n\t\t\t\t\t\t\tchaddr);\n\t\t \n\t\tethhdr = eth_hdr(skb);\n\t\t \n\t\tif (dhcp_rcp == BATADV_DHCP_NO) {\n\t\t\tdo_bcast = true;\n\t\t\tgoto send;\n\t\t}\n\n\t\tif (dhcp_rcp == BATADV_DHCP_TO_CLIENT)\n\t\t\tdst_hint = chaddr;\n\t\telse if ((gw_mode == BATADV_GW_MODE_SERVER) &&\n\t\t\t (dhcp_rcp == BATADV_DHCP_TO_SERVER))\n\t\t\t \n\t\t\tgoto dropped;\n\nsend:\n\t\tif (do_bcast && !is_broadcast_ether_addr(ethhdr->h_dest)) {\n\t\t\tforw_mode = batadv_mcast_forw_mode(bat_priv, skb,\n\t\t\t\t\t\t\t   &mcast_is_routable);\n\t\t\tswitch (forw_mode) {\n\t\t\tcase BATADV_FORW_BCAST:\n\t\t\t\tbreak;\n\t\t\tcase BATADV_FORW_UCASTS:\n\t\t\t\tdo_bcast = false;\n\t\t\t\tbreak;\n\t\t\tcase BATADV_FORW_NONE:\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tgoto dropped;\n\t\t\t}\n\t\t}\n\t}\n\n\tbatadv_skb_set_priority(skb, 0);\n\n\t \n\tif (do_bcast) {\n\t\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\t\tif (!primary_if)\n\t\t\tgoto dropped;\n\n\t\t \n\t\tif (batadv_dat_snoop_outgoing_arp_request(bat_priv, skb))\n\t\t\tbrd_delay = msecs_to_jiffies(ARP_REQ_DELAY);\n\n\t\tif (batadv_skb_head_push(skb, sizeof(*bcast_packet)) < 0)\n\t\t\tgoto dropped;\n\n\t\tbcast_packet = (struct batadv_bcast_packet *)skb->data;\n\t\tbcast_packet->version = BATADV_COMPAT_VERSION;\n\t\tbcast_packet->ttl = BATADV_TTL - 1;\n\n\t\t \n\t\tbcast_packet->packet_type = BATADV_BCAST;\n\t\tbcast_packet->reserved = 0;\n\n\t\t \n\t\tether_addr_copy(bcast_packet->orig,\n\t\t\t\tprimary_if->net_dev->dev_addr);\n\n\t\t \n\t\tseqno = atomic_inc_return(&bat_priv->bcast_seqno);\n\t\tbcast_packet->seqno = htonl(seqno);\n\n\t\tbatadv_send_bcast_packet(bat_priv, skb, brd_delay, true);\n\t \n\t} else {\n\t\t \n\t\tif (dhcp_rcp == BATADV_DHCP_TO_SERVER) {\n\t\t\tret = batadv_gw_out_of_range(bat_priv, skb);\n\t\t\tif (ret)\n\t\t\t\tgoto dropped;\n\t\t\tret = batadv_send_skb_via_gw(bat_priv, skb, vid);\n\t\t} else if (forw_mode == BATADV_FORW_UCASTS) {\n\t\t\tret = batadv_mcast_forw_send(bat_priv, skb, vid,\n\t\t\t\t\t\t     mcast_is_routable);\n\t\t} else {\n\t\t\tif (batadv_dat_snoop_outgoing_arp_request(bat_priv,\n\t\t\t\t\t\t\t\t  skb))\n\t\t\t\tgoto dropped;\n\n\t\t\tbatadv_dat_snoop_outgoing_arp_reply(bat_priv, skb);\n\n\t\t\tret = batadv_send_skb_via_tt(bat_priv, skb, dst_hint,\n\t\t\t\t\t\t     vid);\n\t\t}\n\t\tif (ret != NET_XMIT_SUCCESS)\n\t\t\tgoto dropped_freed;\n\t}\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_TX);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_TX_BYTES, data_len);\n\tgoto end;\n\ndropped:\n\tkfree_skb(skb);\ndropped_freed:\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_TX_DROPPED);\nend:\n\tbatadv_hardif_put(primary_if);\n\treturn NETDEV_TX_OK;\n}\n\n \nvoid batadv_interface_rx(struct net_device *soft_iface,\n\t\t\t struct sk_buff *skb, int hdr_size,\n\t\t\t struct batadv_orig_node *orig_node)\n{\n\tstruct batadv_bcast_packet *batadv_bcast_packet;\n\tstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\n\tstruct vlan_ethhdr *vhdr;\n\tstruct ethhdr *ethhdr;\n\tunsigned short vid;\n\tint packet_type;\n\n\tbatadv_bcast_packet = (struct batadv_bcast_packet *)skb->data;\n\tpacket_type = batadv_bcast_packet->packet_type;\n\n\tskb_pull_rcsum(skb, hdr_size);\n\tskb_reset_mac_header(skb);\n\n\t \n\tnf_reset_ct(skb);\n\n\tif (unlikely(!pskb_may_pull(skb, ETH_HLEN)))\n\t\tgoto dropped;\n\n\tvid = batadv_get_vid(skb, 0);\n\tethhdr = eth_hdr(skb);\n\n\tswitch (ntohs(ethhdr->h_proto)) {\n\tcase ETH_P_8021Q:\n\t\tif (!pskb_may_pull(skb, VLAN_ETH_HLEN))\n\t\t\tgoto dropped;\n\n\t\tvhdr = skb_vlan_eth_hdr(skb);\n\n\t\t \n\t\tif (vhdr->h_vlan_encapsulated_proto != htons(ETH_P_BATMAN))\n\t\t\tbreak;\n\n\t\tfallthrough;\n\tcase ETH_P_BATMAN:\n\t\tgoto dropped;\n\t}\n\n\t \n\tskb->protocol = eth_type_trans(skb, soft_iface);\n\tskb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);\n\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_RX);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_RX_BYTES,\n\t\t\t   skb->len + ETH_HLEN);\n\n\t \n\tif (batadv_bla_rx(bat_priv, skb, vid, packet_type))\n\t\tgoto out;\n\n\tif (orig_node)\n\t\tbatadv_tt_add_temporary_global_entry(bat_priv, orig_node,\n\t\t\t\t\t\t     ethhdr->h_source, vid);\n\n\tif (is_multicast_ether_addr(ethhdr->h_dest)) {\n\t\t \n\t\tif (batadv_vlan_ap_isola_get(bat_priv, vid) &&\n\t\t    batadv_tt_global_is_isolated(bat_priv, ethhdr->h_source,\n\t\t\t\t\t\t vid)) {\n\t\t\t \n\t\t\tskb->mark &= ~bat_priv->isolation_mark_mask;\n\t\t\tskb->mark |= bat_priv->isolation_mark;\n\t\t}\n\t} else if (batadv_is_ap_isolated(bat_priv, ethhdr->h_source,\n\t\t\t\t\t ethhdr->h_dest, vid)) {\n\t\tgoto dropped;\n\t}\n\n\tnetif_rx(skb);\n\tgoto out;\n\ndropped:\n\tkfree_skb(skb);\nout:\n\treturn;\n}\n\n \nvoid batadv_softif_vlan_release(struct kref *ref)\n{\n\tstruct batadv_softif_vlan *vlan;\n\n\tvlan = container_of(ref, struct batadv_softif_vlan, refcount);\n\n\tspin_lock_bh(&vlan->bat_priv->softif_vlan_list_lock);\n\thlist_del_rcu(&vlan->list);\n\tspin_unlock_bh(&vlan->bat_priv->softif_vlan_list_lock);\n\n\tkfree_rcu(vlan, rcu);\n}\n\n \nstruct batadv_softif_vlan *batadv_softif_vlan_get(struct batadv_priv *bat_priv,\n\t\t\t\t\t\t  unsigned short vid)\n{\n\tstruct batadv_softif_vlan *vlan_tmp, *vlan = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(vlan_tmp, &bat_priv->softif_vlan_list, list) {\n\t\tif (vlan_tmp->vid != vid)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&vlan_tmp->refcount))\n\t\t\tcontinue;\n\n\t\tvlan = vlan_tmp;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn vlan;\n}\n\n \nint batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)\n{\n\tstruct batadv_softif_vlan *vlan;\n\n\tspin_lock_bh(&bat_priv->softif_vlan_list_lock);\n\n\tvlan = batadv_softif_vlan_get(bat_priv, vid);\n\tif (vlan) {\n\t\tbatadv_softif_vlan_put(vlan);\n\t\tspin_unlock_bh(&bat_priv->softif_vlan_list_lock);\n\t\treturn -EEXIST;\n\t}\n\n\tvlan = kzalloc(sizeof(*vlan), GFP_ATOMIC);\n\tif (!vlan) {\n\t\tspin_unlock_bh(&bat_priv->softif_vlan_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tvlan->bat_priv = bat_priv;\n\tvlan->vid = vid;\n\tkref_init(&vlan->refcount);\n\n\tatomic_set(&vlan->ap_isolation, 0);\n\n\tkref_get(&vlan->refcount);\n\thlist_add_head_rcu(&vlan->list, &bat_priv->softif_vlan_list);\n\tspin_unlock_bh(&bat_priv->softif_vlan_list_lock);\n\n\t \n\tbatadv_tt_local_add(bat_priv->soft_iface,\n\t\t\t    bat_priv->soft_iface->dev_addr, vid,\n\t\t\t    BATADV_NULL_IFINDEX, BATADV_NO_MARK);\n\n\t \n\tbatadv_softif_vlan_put(vlan);\n\n\treturn 0;\n}\n\n \nstatic void batadv_softif_destroy_vlan(struct batadv_priv *bat_priv,\n\t\t\t\t       struct batadv_softif_vlan *vlan)\n{\n\t \n\tbatadv_tt_local_remove(bat_priv, bat_priv->soft_iface->dev_addr,\n\t\t\t       vlan->vid, \"vlan interface destroyed\", false);\n\n\tbatadv_softif_vlan_put(vlan);\n}\n\n \nstatic int batadv_interface_add_vid(struct net_device *dev, __be16 proto,\n\t\t\t\t    unsigned short vid)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(dev);\n\tstruct batadv_softif_vlan *vlan;\n\n\t \n\tif (proto != htons(ETH_P_8021Q))\n\t\treturn -EINVAL;\n\n\tvid |= BATADV_VLAN_HAS_TAG;\n\n\t \n\tvlan = batadv_softif_vlan_get(bat_priv, vid);\n\tif (!vlan)\n\t\treturn batadv_softif_create_vlan(bat_priv, vid);\n\n\t \n\tbatadv_tt_local_add(bat_priv->soft_iface,\n\t\t\t    bat_priv->soft_iface->dev_addr, vid,\n\t\t\t    BATADV_NULL_IFINDEX, BATADV_NO_MARK);\n\n\treturn 0;\n}\n\n \nstatic int batadv_interface_kill_vid(struct net_device *dev, __be16 proto,\n\t\t\t\t     unsigned short vid)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(dev);\n\tstruct batadv_softif_vlan *vlan;\n\n\t \n\tif (proto != htons(ETH_P_8021Q))\n\t\treturn -EINVAL;\n\n\tvlan = batadv_softif_vlan_get(bat_priv, vid | BATADV_VLAN_HAS_TAG);\n\tif (!vlan)\n\t\treturn -ENOENT;\n\n\tbatadv_softif_destroy_vlan(bat_priv, vlan);\n\n\t \n\tbatadv_softif_vlan_put(vlan);\n\n\treturn 0;\n}\n\n \nstatic struct lock_class_key batadv_netdev_xmit_lock_key;\nstatic struct lock_class_key batadv_netdev_addr_lock_key;\n\n \nstatic void batadv_set_lockdep_class_one(struct net_device *dev,\n\t\t\t\t\t struct netdev_queue *txq,\n\t\t\t\t\t void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock, &batadv_netdev_xmit_lock_key);\n}\n\n \nstatic void batadv_set_lockdep_class(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock, &batadv_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, batadv_set_lockdep_class_one, NULL);\n}\n\n \nstatic int batadv_softif_init_late(struct net_device *dev)\n{\n\tstruct batadv_priv *bat_priv;\n\tu32 random_seqno;\n\tint ret;\n\tsize_t cnt_len = sizeof(u64) * BATADV_CNT_NUM;\n\n\tbatadv_set_lockdep_class(dev);\n\n\tbat_priv = netdev_priv(dev);\n\tbat_priv->soft_iface = dev;\n\n\t \n\tbat_priv->bat_counters = __alloc_percpu(cnt_len, __alignof__(u64));\n\tif (!bat_priv->bat_counters)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&bat_priv->aggregated_ogms, 1);\n\tatomic_set(&bat_priv->bonding, 0);\n#ifdef CONFIG_BATMAN_ADV_BLA\n\tatomic_set(&bat_priv->bridge_loop_avoidance, 1);\n#endif\n#ifdef CONFIG_BATMAN_ADV_DAT\n\tatomic_set(&bat_priv->distributed_arp_table, 1);\n#endif\n#ifdef CONFIG_BATMAN_ADV_MCAST\n\tatomic_set(&bat_priv->multicast_mode, 1);\n\tatomic_set(&bat_priv->multicast_fanout, 16);\n\tatomic_set(&bat_priv->mcast.num_want_all_unsnoopables, 0);\n\tatomic_set(&bat_priv->mcast.num_want_all_ipv4, 0);\n\tatomic_set(&bat_priv->mcast.num_want_all_ipv6, 0);\n#endif\n\tatomic_set(&bat_priv->gw.mode, BATADV_GW_MODE_OFF);\n\tatomic_set(&bat_priv->gw.bandwidth_down, 100);\n\tatomic_set(&bat_priv->gw.bandwidth_up, 20);\n\tatomic_set(&bat_priv->orig_interval, 1000);\n\tatomic_set(&bat_priv->hop_penalty, 30);\n#ifdef CONFIG_BATMAN_ADV_DEBUG\n\tatomic_set(&bat_priv->log_level, 0);\n#endif\n\tatomic_set(&bat_priv->fragmentation, 1);\n\tatomic_set(&bat_priv->packet_size_max, ETH_DATA_LEN);\n\tatomic_set(&bat_priv->bcast_queue_left, BATADV_BCAST_QUEUE_LEN);\n\tatomic_set(&bat_priv->batman_queue_left, BATADV_BATMAN_QUEUE_LEN);\n\n\tatomic_set(&bat_priv->mesh_state, BATADV_MESH_INACTIVE);\n\tatomic_set(&bat_priv->bcast_seqno, 1);\n\tatomic_set(&bat_priv->tt.vn, 0);\n\tatomic_set(&bat_priv->tt.local_changes, 0);\n\tatomic_set(&bat_priv->tt.ogm_append_cnt, 0);\n#ifdef CONFIG_BATMAN_ADV_BLA\n\tatomic_set(&bat_priv->bla.num_requests, 0);\n#endif\n\tatomic_set(&bat_priv->tp_num, 0);\n\n\tbat_priv->tt.last_changeset = NULL;\n\tbat_priv->tt.last_changeset_len = 0;\n\tbat_priv->isolation_mark = 0;\n\tbat_priv->isolation_mark_mask = 0;\n\n\t \n\tget_random_bytes(&random_seqno, sizeof(random_seqno));\n\tatomic_set(&bat_priv->frag_seqno, random_seqno);\n\n\tbat_priv->primary_if = NULL;\n\n\tbatadv_nc_init_bat_priv(bat_priv);\n\n\tif (!bat_priv->algo_ops) {\n\t\tret = batadv_algo_select(bat_priv, batadv_routing_algo);\n\t\tif (ret < 0)\n\t\t\tgoto free_bat_counters;\n\t}\n\n\tret = batadv_mesh_init(dev);\n\tif (ret < 0)\n\t\tgoto free_bat_counters;\n\n\treturn 0;\n\nfree_bat_counters:\n\tfree_percpu(bat_priv->bat_counters);\n\tbat_priv->bat_counters = NULL;\n\n\treturn ret;\n}\n\n \nstatic int batadv_softif_slave_add(struct net_device *dev,\n\t\t\t\t   struct net_device *slave_dev,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\tint ret = -EINVAL;\n\n\thard_iface = batadv_hardif_get_by_netdev(slave_dev);\n\tif (!hard_iface || hard_iface->soft_iface)\n\t\tgoto out;\n\n\tret = batadv_hardif_enable_interface(hard_iface, dev);\n\nout:\n\tbatadv_hardif_put(hard_iface);\n\treturn ret;\n}\n\n \nstatic int batadv_softif_slave_del(struct net_device *dev,\n\t\t\t\t   struct net_device *slave_dev)\n{\n\tstruct batadv_hard_iface *hard_iface;\n\tint ret = -EINVAL;\n\n\thard_iface = batadv_hardif_get_by_netdev(slave_dev);\n\n\tif (!hard_iface || hard_iface->soft_iface != dev)\n\t\tgoto out;\n\n\tbatadv_hardif_disable_interface(hard_iface);\n\tret = 0;\n\nout:\n\tbatadv_hardif_put(hard_iface);\n\treturn ret;\n}\n\nstatic const struct net_device_ops batadv_netdev_ops = {\n\t.ndo_init = batadv_softif_init_late,\n\t.ndo_open = batadv_interface_open,\n\t.ndo_stop = batadv_interface_release,\n\t.ndo_get_stats = batadv_interface_stats,\n\t.ndo_vlan_rx_add_vid = batadv_interface_add_vid,\n\t.ndo_vlan_rx_kill_vid = batadv_interface_kill_vid,\n\t.ndo_set_mac_address = batadv_interface_set_mac_addr,\n\t.ndo_change_mtu = batadv_interface_change_mtu,\n\t.ndo_set_rx_mode = batadv_interface_set_rx_mode,\n\t.ndo_start_xmit = batadv_interface_tx,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_add_slave = batadv_softif_slave_add,\n\t.ndo_del_slave = batadv_softif_slave_del,\n};\n\nstatic void batadv_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, \"B.A.T.M.A.N. advanced\", sizeof(info->driver));\n\tstrscpy(info->version, BATADV_SOURCE_VERSION, sizeof(info->version));\n\tstrscpy(info->fw_version, \"N/A\", sizeof(info->fw_version));\n\tstrscpy(info->bus_info, \"batman\", sizeof(info->bus_info));\n}\n\n \nstatic const struct {\n\tconst char name[ETH_GSTRING_LEN];\n} batadv_counters_strings[] = {\n\t{ \"tx\" },\n\t{ \"tx_bytes\" },\n\t{ \"tx_dropped\" },\n\t{ \"rx\" },\n\t{ \"rx_bytes\" },\n\t{ \"forward\" },\n\t{ \"forward_bytes\" },\n\t{ \"mgmt_tx\" },\n\t{ \"mgmt_tx_bytes\" },\n\t{ \"mgmt_rx\" },\n\t{ \"mgmt_rx_bytes\" },\n\t{ \"frag_tx\" },\n\t{ \"frag_tx_bytes\" },\n\t{ \"frag_rx\" },\n\t{ \"frag_rx_bytes\" },\n\t{ \"frag_fwd\" },\n\t{ \"frag_fwd_bytes\" },\n\t{ \"tt_request_tx\" },\n\t{ \"tt_request_rx\" },\n\t{ \"tt_response_tx\" },\n\t{ \"tt_response_rx\" },\n\t{ \"tt_roam_adv_tx\" },\n\t{ \"tt_roam_adv_rx\" },\n#ifdef CONFIG_BATMAN_ADV_DAT\n\t{ \"dat_get_tx\" },\n\t{ \"dat_get_rx\" },\n\t{ \"dat_put_tx\" },\n\t{ \"dat_put_rx\" },\n\t{ \"dat_cached_reply_tx\" },\n#endif\n#ifdef CONFIG_BATMAN_ADV_NC\n\t{ \"nc_code\" },\n\t{ \"nc_code_bytes\" },\n\t{ \"nc_recode\" },\n\t{ \"nc_recode_bytes\" },\n\t{ \"nc_buffer\" },\n\t{ \"nc_decode\" },\n\t{ \"nc_decode_bytes\" },\n\t{ \"nc_decode_failed\" },\n\t{ \"nc_sniffed\" },\n#endif\n};\n\nstatic void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\tmemcpy(data, batadv_counters_strings,\n\t\t       sizeof(batadv_counters_strings));\n}\n\nstatic void batadv_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < BATADV_CNT_NUM; i++)\n\t\tdata[i] = batadv_sum_counter(bat_priv, i);\n}\n\nstatic int batadv_get_sset_count(struct net_device *dev, int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn BATADV_CNT_NUM;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct ethtool_ops batadv_ethtool_ops = {\n\t.get_drvinfo = batadv_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_strings = batadv_get_strings,\n\t.get_ethtool_stats = batadv_get_ethtool_stats,\n\t.get_sset_count = batadv_get_sset_count,\n};\n\n \nstatic void batadv_softif_free(struct net_device *dev)\n{\n\tbatadv_mesh_free(dev);\n\n\t \n\trcu_barrier();\n}\n\n \nstatic void batadv_softif_init_early(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->netdev_ops = &batadv_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = batadv_softif_free;\n\tdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_NETNS_LOCAL;\n\tdev->features |= NETIF_F_LLTX;\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\n\t \n\tdev->mtu = ETH_DATA_LEN;\n\n\t \n\teth_hw_addr_random(dev);\n\n\tdev->ethtool_ops = &batadv_ethtool_ops;\n}\n\n \nstatic int batadv_softif_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct batadv_algo_ops *algo_ops;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_BATADV_ALGO_NAME]) {\n\t\talgo_ops = batadv_algo_get(nla_data(data[IFLA_BATADV_ALGO_NAME]));\n\t\tif (!algo_ops)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int batadv_softif_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t\t struct nlattr *tb[], struct nlattr *data[],\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(dev);\n\tconst char *algo_name;\n\tint err;\n\n\tif (data && data[IFLA_BATADV_ALGO_NAME]) {\n\t\talgo_name = nla_data(data[IFLA_BATADV_ALGO_NAME]);\n\t\terr = batadv_algo_select(bat_priv, algo_name);\n\t\tif (err)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn register_netdevice(dev);\n}\n\n \nstatic void batadv_softif_destroy_netlink(struct net_device *soft_iface,\n\t\t\t\t\t  struct list_head *head)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\n\tstruct batadv_hard_iface *hard_iface;\n\tstruct batadv_softif_vlan *vlan;\n\n\tlist_for_each_entry(hard_iface, &batadv_hardif_list, list) {\n\t\tif (hard_iface->soft_iface == soft_iface)\n\t\t\tbatadv_hardif_disable_interface(hard_iface);\n\t}\n\n\t \n\tvlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);\n\tif (vlan) {\n\t\tbatadv_softif_destroy_vlan(bat_priv, vlan);\n\t\tbatadv_softif_vlan_put(vlan);\n\t}\n\n\tunregister_netdevice_queue(soft_iface, head);\n}\n\n \nbool batadv_softif_is_valid(const struct net_device *net_dev)\n{\n\tif (net_dev->netdev_ops->ndo_start_xmit == batadv_interface_tx)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct nla_policy batadv_ifla_policy[IFLA_BATADV_MAX + 1] = {\n\t[IFLA_BATADV_ALGO_NAME]\t= { .type = NLA_NUL_STRING },\n};\n\nstruct rtnl_link_ops batadv_link_ops __read_mostly = {\n\t.kind\t\t= \"batadv\",\n\t.priv_size\t= sizeof(struct batadv_priv),\n\t.setup\t\t= batadv_softif_init_early,\n\t.maxtype\t= IFLA_BATADV_MAX,\n\t.policy\t\t= batadv_ifla_policy,\n\t.validate\t= batadv_softif_validate,\n\t.newlink\t= batadv_softif_newlink,\n\t.dellink\t= batadv_softif_destroy_netlink,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}