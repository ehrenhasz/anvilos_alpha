{
  "module_name": "signaling.c",
  "hash_id": "fe11e97fa4424c45083122d61dadb694ebbe62fabd95763d1a19ae2814dc35c9",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/signaling.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/errno.h>\t \n#include <linux/kernel.h>\t \n#include <linux/skbuff.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\t \n#include <linux/atm.h>\t\t \n#include <linux/atmsap.h>\n#include <linux/atmsvc.h>\n#include <linux/atmdev.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n\n#include \"resources.h\"\n#include \"signaling.h\"\n\nstruct atm_vcc *sigd = NULL;\n\nstatic void sigd_put_skb(struct sk_buff *skb)\n{\n\tif (!sigd) {\n\t\tpr_debug(\"atmsvc: no signaling daemon\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tatm_force_charge(sigd, skb->truesize);\n\tskb_queue_tail(&sk_atm(sigd)->sk_receive_queue, skb);\n\tsk_atm(sigd)->sk_data_ready(sk_atm(sigd));\n}\n\nstatic void modify_qos(struct atm_vcc *vcc, struct atmsvc_msg *msg)\n{\n\tstruct sk_buff *skb;\n\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags))\n\t\treturn;\n\tmsg->type = as_error;\n\tif (!vcc->dev->ops->change_qos)\n\t\tmsg->reply = -EOPNOTSUPP;\n\telse {\n\t\t \n\t\tmsg->reply = vcc->dev->ops->change_qos(vcc, &msg->qos,\n\t\t\t\t\t\t       msg->reply);\n\t\tif (!msg->reply)\n\t\t\tmsg->type = as_okay;\n\t}\n\t \n\twhile (!(skb = alloc_skb(sizeof(struct atmsvc_msg), GFP_KERNEL)))\n\t\tschedule();\n\t*(struct atmsvc_msg *)skb_put(skb, sizeof(struct atmsvc_msg)) = *msg;\n\tsigd_put_skb(skb);\n}\n\nstatic int sigd_send(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tstruct atmsvc_msg *msg;\n\tstruct atm_vcc *session_vcc;\n\tstruct sock *sk;\n\n\tmsg = (struct atmsvc_msg *) skb->data;\n\tWARN_ON(refcount_sub_and_test(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc));\n\tvcc = *(struct atm_vcc **) &msg->vcc;\n\tpr_debug(\"%d (0x%lx)\\n\", (int)msg->type, (unsigned long)vcc);\n\tsk = sk_atm(vcc);\n\n\tswitch (msg->type) {\n\tcase as_okay:\n\t\tsk->sk_err = -msg->reply;\n\t\tclear_bit(ATM_VF_WAITING, &vcc->flags);\n\t\tif (!*vcc->local.sas_addr.prv && !*vcc->local.sas_addr.pub) {\n\t\t\tvcc->local.sas_family = AF_ATMSVC;\n\t\t\tmemcpy(vcc->local.sas_addr.prv,\n\t\t\t       msg->local.sas_addr.prv, ATM_ESA_LEN);\n\t\t\tmemcpy(vcc->local.sas_addr.pub,\n\t\t\t       msg->local.sas_addr.pub, ATM_E164_LEN + 1);\n\t\t}\n\t\tsession_vcc = vcc->session ? vcc->session : vcc;\n\t\tif (session_vcc->vpi || session_vcc->vci)\n\t\t\tbreak;\n\t\tsession_vcc->itf = msg->pvc.sap_addr.itf;\n\t\tsession_vcc->vpi = msg->pvc.sap_addr.vpi;\n\t\tsession_vcc->vci = msg->pvc.sap_addr.vci;\n\t\tif (session_vcc->vpi || session_vcc->vci)\n\t\t\tsession_vcc->qos = msg->qos;\n\t\tbreak;\n\tcase as_error:\n\t\tclear_bit(ATM_VF_REGIS, &vcc->flags);\n\t\tclear_bit(ATM_VF_READY, &vcc->flags);\n\t\tsk->sk_err = -msg->reply;\n\t\tclear_bit(ATM_VF_WAITING, &vcc->flags);\n\t\tbreak;\n\tcase as_indicate:\n\t\tvcc = *(struct atm_vcc **)&msg->listen_vcc;\n\t\tsk = sk_atm(vcc);\n\t\tpr_debug(\"as_indicate!!!\\n\");\n\t\tlock_sock(sk);\n\t\tif (sk_acceptq_is_full(sk)) {\n\t\t\tsigd_enq(NULL, as_reject, vcc, NULL, NULL);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tgoto as_indicate_complete;\n\t\t}\n\t\tsk_acceptq_added(sk);\n\t\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tpr_debug(\"waking sk_sleep(sk) 0x%p\\n\", sk_sleep(sk));\n\t\tsk->sk_state_change(sk);\nas_indicate_complete:\n\t\trelease_sock(sk);\n\t\treturn 0;\n\tcase as_close:\n\t\tset_bit(ATM_VF_RELEASED, &vcc->flags);\n\t\tvcc_release_async(vcc, msg->reply);\n\t\tgoto out;\n\tcase as_modify:\n\t\tmodify_qos(vcc, msg);\n\t\tbreak;\n\tcase as_addparty:\n\tcase as_dropparty:\n\t\tWRITE_ONCE(sk->sk_err_soft, -msg->reply);\n\t\t\t\t\t \n\t\tclear_bit(ATM_VF_WAITING, &vcc->flags);\n\t\tbreak;\n\tdefault:\n\t\tpr_alert(\"bad message type %d\\n\", (int)msg->type);\n\t\treturn -EINVAL;\n\t}\n\tsk->sk_state_change(sk);\nout:\n\tdev_kfree_skb(skb);\n\treturn 0;\n}\n\nvoid sigd_enq2(struct atm_vcc *vcc, enum atmsvc_msg_type type,\n\t       struct atm_vcc *listen_vcc, const struct sockaddr_atmpvc *pvc,\n\t       const struct sockaddr_atmsvc *svc, const struct atm_qos *qos,\n\t       int reply)\n{\n\tstruct sk_buff *skb;\n\tstruct atmsvc_msg *msg;\n\tstatic unsigned int session = 0;\n\n\tpr_debug(\"%d (0x%p)\\n\", (int)type, vcc);\n\twhile (!(skb = alloc_skb(sizeof(struct atmsvc_msg), GFP_KERNEL)))\n\t\tschedule();\n\tmsg = skb_put_zero(skb, sizeof(struct atmsvc_msg));\n\tmsg->type = type;\n\t*(struct atm_vcc **) &msg->vcc = vcc;\n\t*(struct atm_vcc **) &msg->listen_vcc = listen_vcc;\n\tmsg->reply = reply;\n\tif (qos)\n\t\tmsg->qos = *qos;\n\tif (vcc)\n\t\tmsg->sap = vcc->sap;\n\tif (svc)\n\t\tmsg->svc = *svc;\n\tif (vcc)\n\t\tmsg->local = vcc->local;\n\tif (pvc)\n\t\tmsg->pvc = *pvc;\n\tif (vcc) {\n\t\tif (type == as_connect && test_bit(ATM_VF_SESSION, &vcc->flags))\n\t\t\tmsg->session = ++session;\n\t\t\t \n\t}\n\tsigd_put_skb(skb);\n\tif (vcc)\n\t\tset_bit(ATM_VF_REGIS, &vcc->flags);\n}\n\nvoid sigd_enq(struct atm_vcc *vcc, enum atmsvc_msg_type type,\n\t      struct atm_vcc *listen_vcc, const struct sockaddr_atmpvc *pvc,\n\t      const struct sockaddr_atmsvc *svc)\n{\n\tsigd_enq2(vcc, type, listen_vcc, pvc, svc, vcc ? &vcc->qos : NULL, 0);\n\t \n}\n\nstatic void purge_vcc(struct atm_vcc *vcc)\n{\n\tif (sk_atm(vcc)->sk_family == PF_ATMSVC &&\n\t    !test_bit(ATM_VF_META, &vcc->flags)) {\n\t\tset_bit(ATM_VF_RELEASED, &vcc->flags);\n\t\tclear_bit(ATM_VF_REGIS, &vcc->flags);\n\t\tvcc_release_async(vcc, -EUNATCH);\n\t}\n}\n\nstatic void sigd_close(struct atm_vcc *vcc)\n{\n\tstruct sock *s;\n\tint i;\n\n\tpr_debug(\"\\n\");\n\tsigd = NULL;\n\tif (skb_peek(&sk_atm(vcc)->sk_receive_queue))\n\t\tpr_err(\"closing with requests pending\\n\");\n\tskb_queue_purge(&sk_atm(vcc)->sk_receive_queue);\n\n\tread_lock(&vcc_sklist_lock);\n\tfor (i = 0; i < VCC_HTABLE_SIZE; ++i) {\n\t\tstruct hlist_head *head = &vcc_hash[i];\n\n\t\tsk_for_each(s, head) {\n\t\t\tvcc = atm_sk(s);\n\n\t\t\tpurge_vcc(vcc);\n\t\t}\n\t}\n\tread_unlock(&vcc_sklist_lock);\n}\n\nstatic const struct atmdev_ops sigd_dev_ops = {\n\t.close = sigd_close,\n\t.send =\tsigd_send\n};\n\nstatic struct atm_dev sigd_dev = {\n\t.ops =\t\t&sigd_dev_ops,\n\t.type =\t\t\"sig\",\n\t.number =\t999,\n\t.lock =\t\t__SPIN_LOCK_UNLOCKED(sigd_dev.lock)\n};\n\nint sigd_attach(struct atm_vcc *vcc)\n{\n\tif (sigd)\n\t\treturn -EADDRINUSE;\n\tpr_debug(\"\\n\");\n\tsigd = vcc;\n\tvcc->dev = &sigd_dev;\n\tvcc_insert_socket(sk_atm(vcc));\n\tset_bit(ATM_VF_META, &vcc->flags);\n\tset_bit(ATM_VF_READY, &vcc->flags);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}