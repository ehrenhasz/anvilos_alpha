{
  "module_name": "mpoa_proc.c",
  "hash_id": "12426db9eab42896914bdcd00f21c33f8a8db9fab7e92608a3c68ebfd74890a5",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/mpoa_proc.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#ifdef CONFIG_PROC_FS\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/ktime.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/atmmpc.h>\n#include <linux/atm.h>\n#include <linux/gfp.h>\n#include \"mpc.h\"\n#include \"mpoa_caches.h\"\n\n \n\n#if 1\n#define dprintk(format, args...)\t\t\t\t\t\\\n\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __FILE__, ##args)   \n#else\n#define dprintk(format, args...)\t\t\t\t\t\\\n\tdo { if (0)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __FILE__, ##args);\\\n\t} while (0)\n#endif\n\n#if 0\n#define ddprintk(format, args...)\t\t\t\t\t\\\n\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __FILE__, ##args)   \n#else\n#define ddprintk(format, args...)\t\t\t\t\t\\\n\tdo { if (0)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __FILE__, ##args);\\\n\t} while (0)\n#endif\n\n#define STAT_FILE_NAME \"mpc\"      \n\nextern struct mpoa_client *mpcs;\nextern struct proc_dir_entry *atm_proc_root;   \n\nstatic int proc_mpc_open(struct inode *inode, struct file *file);\nstatic ssize_t proc_mpc_write(struct file *file, const char __user *buff,\n\t\t\t      size_t nbytes, loff_t *ppos);\n\nstatic int parse_qos(const char *buff);\n\nstatic const struct proc_ops mpc_proc_ops = {\n\t.proc_open\t= proc_mpc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= proc_mpc_write,\n\t.proc_release\t= seq_release,\n};\n\n \nstatic const char *ingress_state_string(int state)\n{\n\tswitch (state) {\n\tcase INGRESS_RESOLVING:\n\t\treturn \"resolving  \";\n\tcase INGRESS_RESOLVED:\n\t\treturn \"resolved   \";\n\tcase INGRESS_INVALID:\n\t\treturn \"invalid    \";\n\tcase INGRESS_REFRESHING:\n\t\treturn \"refreshing \";\n\t}\n\n\treturn \"\";\n}\n\n \nstatic const char *egress_state_string(int state)\n{\n\tswitch (state) {\n\tcase EGRESS_RESOLVED:\n\t\treturn \"resolved   \";\n\tcase EGRESS_PURGE:\n\t\treturn \"purge      \";\n\tcase EGRESS_INVALID:\n\t\treturn \"invalid    \";\n\t}\n\n\treturn \"\";\n}\n\n \n\nstatic void *mpc_start(struct seq_file *m, loff_t *pos)\n{\n\tloff_t l = *pos;\n\tstruct mpoa_client *mpc;\n\n\tif (!l--)\n\t\treturn SEQ_START_TOKEN;\n\tfor (mpc = mpcs; mpc; mpc = mpc->next)\n\t\tif (!l--)\n\t\t\treturn mpc;\n\treturn NULL;\n}\n\nstatic void *mpc_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct mpoa_client *p = v;\n\t(*pos)++;\n\treturn v == SEQ_START_TOKEN ? mpcs : p->next;\n}\n\nstatic void mpc_stop(struct seq_file *m, void *v)\n{\n}\n\n \nstatic int mpc_show(struct seq_file *m, void *v)\n{\n\tstruct mpoa_client *mpc = v;\n\tint i;\n\tin_cache_entry *in_entry;\n\teg_cache_entry *eg_entry;\n\ttime64_t now;\n\tunsigned char ip_string[16];\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tatm_mpoa_disp_qos(m);\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"\\nInterface %d:\\n\\n\", mpc->dev_num);\n\tseq_printf(m, \"Ingress Entries:\\nIP address      State      Holding time  Packets fwded  VPI  VCI\\n\");\n\tnow = ktime_get_seconds();\n\n\tfor (in_entry = mpc->in_cache; in_entry; in_entry = in_entry->next) {\n\t\tunsigned long seconds_delta = now - in_entry->time;\n\n\t\tsprintf(ip_string, \"%pI4\", &in_entry->ctrl_info.in_dst_ip);\n\t\tseq_printf(m, \"%-16s%s%-14lu%-12u\",\n\t\t\t   ip_string,\n\t\t\t   ingress_state_string(in_entry->entry_state),\n\t\t\t   in_entry->ctrl_info.holding_time -\n\t\t\t   seconds_delta,\n\t\t\t   in_entry->packets_fwded);\n\t\tif (in_entry->shortcut)\n\t\t\tseq_printf(m, \"   %-3d  %-3d\",\n\t\t\t\t   in_entry->shortcut->vpi,\n\t\t\t\t   in_entry->shortcut->vci);\n\t\tseq_printf(m, \"\\n\");\n\t}\n\n\tseq_printf(m, \"\\n\");\n\tseq_printf(m, \"Egress Entries:\\nIngress MPC ATM addr\\nCache-id        State      Holding time  Packets recvd  Latest IP addr   VPI VCI\\n\");\n\tfor (eg_entry = mpc->eg_cache; eg_entry; eg_entry = eg_entry->next) {\n\t\tunsigned char *p = eg_entry->ctrl_info.in_MPC_data_ATM_addr;\n\t\tunsigned long seconds_delta = now - eg_entry->time;\n\n\t\tfor (i = 0; i < ATM_ESA_LEN; i++)\n\t\t\tseq_printf(m, \"%02x\", p[i]);\n\t\tseq_printf(m, \"\\n%-16lu%s%-14lu%-15u\",\n\t\t\t   (unsigned long)ntohl(eg_entry->ctrl_info.cache_id),\n\t\t\t   egress_state_string(eg_entry->entry_state),\n\t\t\t   (eg_entry->ctrl_info.holding_time - seconds_delta),\n\t\t\t   eg_entry->packets_rcvd);\n\n\t\t \n\t\tsprintf(ip_string, \"%pI4\", &eg_entry->latest_ip_addr);\n\t\tseq_printf(m, \"%-16s\", ip_string);\n\n\t\tif (eg_entry->shortcut)\n\t\t\tseq_printf(m, \" %-3d %-3d\",\n\t\t\t\t   eg_entry->shortcut->vpi,\n\t\t\t\t   eg_entry->shortcut->vci);\n\t\tseq_printf(m, \"\\n\");\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}\n\nstatic const struct seq_operations mpc_op = {\n\t.start =\tmpc_start,\n\t.next =\t\tmpc_next,\n\t.stop =\t\tmpc_stop,\n\t.show =\t\tmpc_show\n};\n\nstatic int proc_mpc_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &mpc_op);\n}\n\nstatic ssize_t proc_mpc_write(struct file *file, const char __user *buff,\n\t\t\t      size_t nbytes, loff_t *ppos)\n{\n\tchar *page, *p;\n\tunsigned int len;\n\n\tif (nbytes == 0)\n\t\treturn 0;\n\n\tif (nbytes >= PAGE_SIZE)\n\t\tnbytes = PAGE_SIZE-1;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tfor (p = page, len = 0; len < nbytes; p++) {\n\t\tif (get_user(*p, buff++)) {\n\t\t\tfree_page((unsigned long)page);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tlen += 1;\n\t\tif (*p == '\\0' || *p == '\\n')\n\t\t\tbreak;\n\t}\n\n\t*p = '\\0';\n\n\tif (!parse_qos(page))\n\t\tprintk(\"mpoa: proc_mpc_write: could not parse '%s'\\n\", page);\n\n\tfree_page((unsigned long)page);\n\n\treturn len;\n}\n\nstatic int parse_qos(const char *buff)\n{\n\t \n\tunsigned char ip[4];\n\tint tx_pcr, tx_sdu, rx_pcr, rx_sdu;\n\t__be32 ipaddr;\n\tstruct atm_qos qos;\n\n\tmemset(&qos, 0, sizeof(struct atm_qos));\n\n\tif (sscanf(buff, \"del %hhu.%hhu.%hhu.%hhu\",\n\t\t\tip, ip+1, ip+2, ip+3) == 4) {\n\t\tipaddr = *(__be32 *)ip;\n\t\treturn atm_mpoa_delete_qos(atm_mpoa_search_qos(ipaddr));\n\t}\n\n\tif (sscanf(buff, \"add %hhu.%hhu.%hhu.%hhu tx=%d,%d rx=tx\",\n\t\t\tip, ip+1, ip+2, ip+3, &tx_pcr, &tx_sdu) == 6) {\n\t\trx_pcr = tx_pcr;\n\t\trx_sdu = tx_sdu;\n\t} else if (sscanf(buff, \"add %hhu.%hhu.%hhu.%hhu tx=%d,%d rx=%d,%d\",\n\t\tip, ip+1, ip+2, ip+3, &tx_pcr, &tx_sdu, &rx_pcr, &rx_sdu) != 8)\n\t\treturn 0;\n\n\tipaddr = *(__be32 *)ip;\n\tqos.txtp.traffic_class = ATM_CBR;\n\tqos.txtp.max_pcr = tx_pcr;\n\tqos.txtp.max_sdu = tx_sdu;\n\tqos.rxtp.traffic_class = ATM_CBR;\n\tqos.rxtp.max_pcr = rx_pcr;\n\tqos.rxtp.max_sdu = rx_sdu;\n\tqos.aal = ATM_AAL5;\n\tdprintk(\"parse_qos(): setting qos parameters to tx=%d,%d rx=%d,%d\\n\",\n\t\tqos.txtp.max_pcr, qos.txtp.max_sdu,\n\t\tqos.rxtp.max_pcr, qos.rxtp.max_sdu);\n\n\tatm_mpoa_add_qos(ipaddr, &qos);\n\treturn 1;\n}\n\n \nint mpc_proc_init(void)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create(STAT_FILE_NAME, 0, atm_proc_root, &mpc_proc_ops);\n\tif (!p) {\n\t\tpr_err(\"Unable to initialize /proc/atm/%s\\n\", STAT_FILE_NAME);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nvoid mpc_proc_clean(void)\n{\n\tremove_proc_entry(STAT_FILE_NAME, atm_proc_root);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}