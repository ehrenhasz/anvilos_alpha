{
  "module_name": "mpoa_caches.c",
  "hash_id": "6aa97d02465b3499616ade706d005780e26cefa9e60d36f0577f5d58559a68de",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/mpoa_caches.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/atmmpc.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#include \"mpoa_caches.h\"\n#include \"mpc.h\"\n\n \n\n#if 0\n#define dprintk(format, args...)\t\t\t\t\t\\\n\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __FILE__, ##args)   \n#else\n#define dprintk(format, args...)\t\t\t\t\t\\\n\tdo { if (0)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __FILE__, ##args);\\\n\t} while (0)\n#endif\n\n#if 0\n#define ddprintk(format, args...)\t\t\t\t\t\\\n\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __FILE__, ##args)   \n#else\n#define ddprintk(format, args...)\t\t\t\t\t\\\n\tdo { if (0)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __FILE__, ##args);\\\n\t} while (0)\n#endif\n\nstatic in_cache_entry *in_cache_get(__be32 dst_ip,\n\t\t\t\t    struct mpoa_client *client)\n{\n\tin_cache_entry *entry;\n\n\tread_lock_bh(&client->ingress_lock);\n\tentry = client->in_cache;\n\twhile (entry != NULL) {\n\t\tif (entry->ctrl_info.in_dst_ip == dst_ip) {\n\t\t\trefcount_inc(&entry->use);\n\t\t\tread_unlock_bh(&client->ingress_lock);\n\t\t\treturn entry;\n\t\t}\n\t\tentry = entry->next;\n\t}\n\tread_unlock_bh(&client->ingress_lock);\n\n\treturn NULL;\n}\n\nstatic in_cache_entry *in_cache_get_with_mask(__be32 dst_ip,\n\t\t\t\t\t      struct mpoa_client *client,\n\t\t\t\t\t      __be32 mask)\n{\n\tin_cache_entry *entry;\n\n\tread_lock_bh(&client->ingress_lock);\n\tentry = client->in_cache;\n\twhile (entry != NULL) {\n\t\tif ((entry->ctrl_info.in_dst_ip & mask) == (dst_ip & mask)) {\n\t\t\trefcount_inc(&entry->use);\n\t\t\tread_unlock_bh(&client->ingress_lock);\n\t\t\treturn entry;\n\t\t}\n\t\tentry = entry->next;\n\t}\n\tread_unlock_bh(&client->ingress_lock);\n\n\treturn NULL;\n\n}\n\nstatic in_cache_entry *in_cache_get_by_vcc(struct atm_vcc *vcc,\n\t\t\t\t\t   struct mpoa_client *client)\n{\n\tin_cache_entry *entry;\n\n\tread_lock_bh(&client->ingress_lock);\n\tentry = client->in_cache;\n\twhile (entry != NULL) {\n\t\tif (entry->shortcut == vcc) {\n\t\t\trefcount_inc(&entry->use);\n\t\t\tread_unlock_bh(&client->ingress_lock);\n\t\t\treturn entry;\n\t\t}\n\t\tentry = entry->next;\n\t}\n\tread_unlock_bh(&client->ingress_lock);\n\n\treturn NULL;\n}\n\nstatic in_cache_entry *in_cache_add_entry(__be32 dst_ip,\n\t\t\t\t\t  struct mpoa_client *client)\n{\n\tin_cache_entry *entry = kzalloc(sizeof(in_cache_entry), GFP_KERNEL);\n\n\tif (entry == NULL) {\n\t\tpr_info(\"mpoa: mpoa_caches.c: new_in_cache_entry: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tdprintk(\"adding an ingress entry, ip = %pI4\\n\", &dst_ip);\n\n\trefcount_set(&entry->use, 1);\n\tdprintk(\"new_in_cache_entry: about to lock\\n\");\n\twrite_lock_bh(&client->ingress_lock);\n\tentry->next = client->in_cache;\n\tentry->prev = NULL;\n\tif (client->in_cache != NULL)\n\t\tclient->in_cache->prev = entry;\n\tclient->in_cache = entry;\n\n\tmemcpy(entry->MPS_ctrl_ATM_addr, client->mps_ctrl_addr, ATM_ESA_LEN);\n\tentry->ctrl_info.in_dst_ip = dst_ip;\n\tentry->time = ktime_get_seconds();\n\tentry->retry_time = client->parameters.mpc_p4;\n\tentry->count = 1;\n\tentry->entry_state = INGRESS_INVALID;\n\tentry->ctrl_info.holding_time = HOLDING_TIME_DEFAULT;\n\trefcount_inc(&entry->use);\n\n\twrite_unlock_bh(&client->ingress_lock);\n\tdprintk(\"new_in_cache_entry: unlocked\\n\");\n\n\treturn entry;\n}\n\nstatic int cache_hit(in_cache_entry *entry, struct mpoa_client *mpc)\n{\n\tstruct atm_mpoa_qos *qos;\n\tstruct k_message msg;\n\n\tentry->count++;\n\tif (entry->entry_state == INGRESS_RESOLVED && entry->shortcut != NULL)\n\t\treturn OPEN;\n\n\tif (entry->entry_state == INGRESS_REFRESHING) {\n\t\tif (entry->count > mpc->parameters.mpc_p1) {\n\t\t\tmsg.type = SND_MPOA_RES_RQST;\n\t\t\tmsg.content.in_info = entry->ctrl_info;\n\t\t\tmemcpy(msg.MPS_ctrl, mpc->mps_ctrl_addr, ATM_ESA_LEN);\n\t\t\tqos = atm_mpoa_search_qos(entry->ctrl_info.in_dst_ip);\n\t\t\tif (qos != NULL)\n\t\t\t\tmsg.qos = qos->qos;\n\t\t\tmsg_to_mpoad(&msg, mpc);\n\t\t\tentry->reply_wait = ktime_get_seconds();\n\t\t\tentry->entry_state = INGRESS_RESOLVING;\n\t\t}\n\t\tif (entry->shortcut != NULL)\n\t\t\treturn OPEN;\n\t\treturn CLOSED;\n\t}\n\n\tif (entry->entry_state == INGRESS_RESOLVING && entry->shortcut != NULL)\n\t\treturn OPEN;\n\n\tif (entry->count > mpc->parameters.mpc_p1 &&\n\t    entry->entry_state == INGRESS_INVALID) {\n\t\tdprintk(\"(%s) threshold exceeded for ip %pI4, sending MPOA res req\\n\",\n\t\t\tmpc->dev->name, &entry->ctrl_info.in_dst_ip);\n\t\tentry->entry_state = INGRESS_RESOLVING;\n\t\tmsg.type = SND_MPOA_RES_RQST;\n\t\tmemcpy(msg.MPS_ctrl, mpc->mps_ctrl_addr, ATM_ESA_LEN);\n\t\tmsg.content.in_info = entry->ctrl_info;\n\t\tqos = atm_mpoa_search_qos(entry->ctrl_info.in_dst_ip);\n\t\tif (qos != NULL)\n\t\t\tmsg.qos = qos->qos;\n\t\tmsg_to_mpoad(&msg, mpc);\n\t\tentry->reply_wait = ktime_get_seconds();\n\t}\n\n\treturn CLOSED;\n}\n\nstatic void in_cache_put(in_cache_entry *entry)\n{\n\tif (refcount_dec_and_test(&entry->use)) {\n\t\tkfree_sensitive(entry);\n\t}\n}\n\n \nstatic void in_cache_remove_entry(in_cache_entry *entry,\n\t\t\t\t  struct mpoa_client *client)\n{\n\tstruct atm_vcc *vcc;\n\tstruct k_message msg;\n\n\tvcc = entry->shortcut;\n\tdprintk(\"removing an ingress entry, ip = %pI4\\n\",\n\t\t&entry->ctrl_info.in_dst_ip);\n\n\tif (entry->prev != NULL)\n\t\tentry->prev->next = entry->next;\n\telse\n\t\tclient->in_cache = entry->next;\n\tif (entry->next != NULL)\n\t\tentry->next->prev = entry->prev;\n\tclient->in_ops->put(entry);\n\tif (client->in_cache == NULL && client->eg_cache == NULL) {\n\t\tmsg.type = STOP_KEEP_ALIVE_SM;\n\t\tmsg_to_mpoad(&msg, client);\n\t}\n\n\t \n\tif (vcc != NULL) {\n\t\teg_cache_entry *eg_entry = client->eg_ops->get_by_vcc(vcc,\n\t\t\t\t\t\t\t\t      client);\n\t\tif (eg_entry != NULL) {\n\t\t\tclient->eg_ops->put(eg_entry);\n\t\t\treturn;\n\t\t}\n\t\tvcc_release_async(vcc, -EPIPE);\n\t}\n}\n\n \nstatic void clear_count_and_expired(struct mpoa_client *client)\n{\n\tin_cache_entry *entry, *next_entry;\n\ttime64_t now;\n\n\tnow = ktime_get_seconds();\n\n\twrite_lock_bh(&client->ingress_lock);\n\tentry = client->in_cache;\n\twhile (entry != NULL) {\n\t\tentry->count = 0;\n\t\tnext_entry = entry->next;\n\t\tif ((now - entry->time) > entry->ctrl_info.holding_time) {\n\t\t\tdprintk(\"holding time expired, ip = %pI4\\n\",\n\t\t\t\t&entry->ctrl_info.in_dst_ip);\n\t\t\tclient->in_ops->remove_entry(entry, client);\n\t\t}\n\t\tentry = next_entry;\n\t}\n\twrite_unlock_bh(&client->ingress_lock);\n}\n\n \nstatic void check_resolving_entries(struct mpoa_client *client)\n{\n\n\tstruct atm_mpoa_qos *qos;\n\tin_cache_entry *entry;\n\ttime64_t now;\n\tstruct k_message msg;\n\n\tnow = ktime_get_seconds();\n\n\tread_lock_bh(&client->ingress_lock);\n\tentry = client->in_cache;\n\twhile (entry != NULL) {\n\t\tif (entry->entry_state == INGRESS_RESOLVING) {\n\n\t\t\tif ((now - entry->hold_down)\n\t\t\t\t\t< client->parameters.mpc_p6) {\n\t\t\t\tentry = entry->next;\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((now - entry->reply_wait) > entry->retry_time) {\n\t\t\t\tentry->retry_time = MPC_C1 * (entry->retry_time);\n\t\t\t\t \n\t\t\t\tif (entry->retry_time > client->parameters.mpc_p5) {\n\t\t\t\t\tentry->hold_down = ktime_get_seconds();\n\t\t\t\t\tentry->retry_time = client->parameters.mpc_p4;\n\t\t\t\t\tentry = entry->next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tmemset(&entry->hold_down, 0, sizeof(time64_t));\n\t\t\t\tmsg.type = SND_MPOA_RES_RTRY;\n\t\t\t\tmemcpy(msg.MPS_ctrl, client->mps_ctrl_addr, ATM_ESA_LEN);\n\t\t\t\tmsg.content.in_info = entry->ctrl_info;\n\t\t\t\tqos = atm_mpoa_search_qos(entry->ctrl_info.in_dst_ip);\n\t\t\t\tif (qos != NULL)\n\t\t\t\t\tmsg.qos = qos->qos;\n\t\t\t\tmsg_to_mpoad(&msg, client);\n\t\t\t\tentry->reply_wait = ktime_get_seconds();\n\t\t\t}\n\t\t}\n\t\tentry = entry->next;\n\t}\n\tread_unlock_bh(&client->ingress_lock);\n}\n\n \nstatic void refresh_entries(struct mpoa_client *client)\n{\n\ttime64_t now;\n\tstruct in_cache_entry *entry = client->in_cache;\n\n\tddprintk(\"refresh_entries\\n\");\n\tnow = ktime_get_seconds();\n\n\tread_lock_bh(&client->ingress_lock);\n\twhile (entry != NULL) {\n\t\tif (entry->entry_state == INGRESS_RESOLVED) {\n\t\t\tif (!(entry->refresh_time))\n\t\t\t\tentry->refresh_time = (2 * (entry->ctrl_info.holding_time))/3;\n\t\t\tif ((now - entry->reply_wait) >\n\t\t\t    entry->refresh_time) {\n\t\t\t\tdprintk(\"refreshing an entry.\\n\");\n\t\t\t\tentry->entry_state = INGRESS_REFRESHING;\n\n\t\t\t}\n\t\t}\n\t\tentry = entry->next;\n\t}\n\tread_unlock_bh(&client->ingress_lock);\n}\n\nstatic void in_destroy_cache(struct mpoa_client *mpc)\n{\n\twrite_lock_irq(&mpc->ingress_lock);\n\twhile (mpc->in_cache != NULL)\n\t\tmpc->in_ops->remove_entry(mpc->in_cache, mpc);\n\twrite_unlock_irq(&mpc->ingress_lock);\n}\n\nstatic eg_cache_entry *eg_cache_get_by_cache_id(__be32 cache_id,\n\t\t\t\t\t\tstruct mpoa_client *mpc)\n{\n\teg_cache_entry *entry;\n\n\tread_lock_irq(&mpc->egress_lock);\n\tentry = mpc->eg_cache;\n\twhile (entry != NULL) {\n\t\tif (entry->ctrl_info.cache_id == cache_id) {\n\t\t\trefcount_inc(&entry->use);\n\t\t\tread_unlock_irq(&mpc->egress_lock);\n\t\t\treturn entry;\n\t\t}\n\t\tentry = entry->next;\n\t}\n\tread_unlock_irq(&mpc->egress_lock);\n\n\treturn NULL;\n}\n\n \nstatic eg_cache_entry *eg_cache_get_by_tag(__be32 tag, struct mpoa_client *mpc)\n{\n\tunsigned long flags;\n\teg_cache_entry *entry;\n\n\tread_lock_irqsave(&mpc->egress_lock, flags);\n\tentry = mpc->eg_cache;\n\twhile (entry != NULL) {\n\t\tif (entry->ctrl_info.tag == tag) {\n\t\t\trefcount_inc(&entry->use);\n\t\t\tread_unlock_irqrestore(&mpc->egress_lock, flags);\n\t\t\treturn entry;\n\t\t}\n\t\tentry = entry->next;\n\t}\n\tread_unlock_irqrestore(&mpc->egress_lock, flags);\n\n\treturn NULL;\n}\n\n \nstatic eg_cache_entry *eg_cache_get_by_vcc(struct atm_vcc *vcc,\n\t\t\t\t\t   struct mpoa_client *mpc)\n{\n\tunsigned long flags;\n\teg_cache_entry *entry;\n\n\tread_lock_irqsave(&mpc->egress_lock, flags);\n\tentry = mpc->eg_cache;\n\twhile (entry != NULL) {\n\t\tif (entry->shortcut == vcc) {\n\t\t\trefcount_inc(&entry->use);\n\t\t\tread_unlock_irqrestore(&mpc->egress_lock, flags);\n\t\t\treturn entry;\n\t\t}\n\t\tentry = entry->next;\n\t}\n\tread_unlock_irqrestore(&mpc->egress_lock, flags);\n\n\treturn NULL;\n}\n\nstatic eg_cache_entry *eg_cache_get_by_src_ip(__be32 ipaddr,\n\t\t\t\t\t      struct mpoa_client *mpc)\n{\n\teg_cache_entry *entry;\n\n\tread_lock_irq(&mpc->egress_lock);\n\tentry = mpc->eg_cache;\n\twhile (entry != NULL) {\n\t\tif (entry->latest_ip_addr == ipaddr) {\n\t\t\trefcount_inc(&entry->use);\n\t\t\tread_unlock_irq(&mpc->egress_lock);\n\t\t\treturn entry;\n\t\t}\n\t\tentry = entry->next;\n\t}\n\tread_unlock_irq(&mpc->egress_lock);\n\n\treturn NULL;\n}\n\nstatic void eg_cache_put(eg_cache_entry *entry)\n{\n\tif (refcount_dec_and_test(&entry->use)) {\n\t\tkfree_sensitive(entry);\n\t}\n}\n\n \nstatic void eg_cache_remove_entry(eg_cache_entry *entry,\n\t\t\t\t  struct mpoa_client *client)\n{\n\tstruct atm_vcc *vcc;\n\tstruct k_message msg;\n\n\tvcc = entry->shortcut;\n\tdprintk(\"removing an egress entry.\\n\");\n\tif (entry->prev != NULL)\n\t\tentry->prev->next = entry->next;\n\telse\n\t\tclient->eg_cache = entry->next;\n\tif (entry->next != NULL)\n\t\tentry->next->prev = entry->prev;\n\tclient->eg_ops->put(entry);\n\tif (client->in_cache == NULL && client->eg_cache == NULL) {\n\t\tmsg.type = STOP_KEEP_ALIVE_SM;\n\t\tmsg_to_mpoad(&msg, client);\n\t}\n\n\t \n\tif (vcc != NULL) {\n\t\tin_cache_entry *in_entry = client->in_ops->get_by_vcc(vcc, client);\n\t\tif (in_entry != NULL) {\n\t\t\tclient->in_ops->put(in_entry);\n\t\t\treturn;\n\t\t}\n\t\tvcc_release_async(vcc, -EPIPE);\n\t}\n}\n\nstatic eg_cache_entry *eg_cache_add_entry(struct k_message *msg,\n\t\t\t\t\t  struct mpoa_client *client)\n{\n\teg_cache_entry *entry = kzalloc(sizeof(eg_cache_entry), GFP_KERNEL);\n\n\tif (entry == NULL) {\n\t\tpr_info(\"out of memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tdprintk(\"adding an egress entry, ip = %pI4, this should be our IP\\n\",\n\t\t&msg->content.eg_info.eg_dst_ip);\n\n\trefcount_set(&entry->use, 1);\n\tdprintk(\"new_eg_cache_entry: about to lock\\n\");\n\twrite_lock_irq(&client->egress_lock);\n\tentry->next = client->eg_cache;\n\tentry->prev = NULL;\n\tif (client->eg_cache != NULL)\n\t\tclient->eg_cache->prev = entry;\n\tclient->eg_cache = entry;\n\n\tmemcpy(entry->MPS_ctrl_ATM_addr, client->mps_ctrl_addr, ATM_ESA_LEN);\n\tentry->ctrl_info = msg->content.eg_info;\n\tentry->time = ktime_get_seconds();\n\tentry->entry_state = EGRESS_RESOLVED;\n\tdprintk(\"new_eg_cache_entry cache_id %u\\n\",\n\t\tntohl(entry->ctrl_info.cache_id));\n\tdprintk(\"mps_ip = %pI4\\n\", &entry->ctrl_info.mps_ip);\n\trefcount_inc(&entry->use);\n\n\twrite_unlock_irq(&client->egress_lock);\n\tdprintk(\"new_eg_cache_entry: unlocked\\n\");\n\n\treturn entry;\n}\n\nstatic void update_eg_cache_entry(eg_cache_entry *entry, uint16_t holding_time)\n{\n\tentry->time = ktime_get_seconds();\n\tentry->entry_state = EGRESS_RESOLVED;\n\tentry->ctrl_info.holding_time = holding_time;\n}\n\nstatic void clear_expired(struct mpoa_client *client)\n{\n\teg_cache_entry *entry, *next_entry;\n\ttime64_t now;\n\tstruct k_message msg;\n\n\tnow = ktime_get_seconds();\n\n\twrite_lock_irq(&client->egress_lock);\n\tentry = client->eg_cache;\n\twhile (entry != NULL) {\n\t\tnext_entry = entry->next;\n\t\tif ((now - entry->time) > entry->ctrl_info.holding_time) {\n\t\t\tmsg.type = SND_EGRESS_PURGE;\n\t\t\tmsg.content.eg_info = entry->ctrl_info;\n\t\t\tdprintk(\"egress_cache: holding time expired, cache_id = %u.\\n\",\n\t\t\t\tntohl(entry->ctrl_info.cache_id));\n\t\t\tmsg_to_mpoad(&msg, client);\n\t\t\tclient->eg_ops->remove_entry(entry, client);\n\t\t}\n\t\tentry = next_entry;\n\t}\n\twrite_unlock_irq(&client->egress_lock);\n}\n\nstatic void eg_destroy_cache(struct mpoa_client *mpc)\n{\n\twrite_lock_irq(&mpc->egress_lock);\n\twhile (mpc->eg_cache != NULL)\n\t\tmpc->eg_ops->remove_entry(mpc->eg_cache, mpc);\n\twrite_unlock_irq(&mpc->egress_lock);\n}\n\n\nstatic const struct in_cache_ops ingress_ops = {\n\t.add_entry = in_cache_add_entry,\n\t.get = in_cache_get,\n\t.get_with_mask = in_cache_get_with_mask,\n\t.get_by_vcc = in_cache_get_by_vcc,\n\t.put = in_cache_put,\n\t.remove_entry = in_cache_remove_entry,\n\t.cache_hit = cache_hit,\n\t.clear_count = clear_count_and_expired,\n\t.check_resolving = check_resolving_entries,\n\t.refresh = refresh_entries,\n\t.destroy_cache = in_destroy_cache\n};\n\nstatic const struct eg_cache_ops egress_ops = {\n\t.add_entry = eg_cache_add_entry,\n\t.get_by_cache_id = eg_cache_get_by_cache_id,\n\t.get_by_tag = eg_cache_get_by_tag,\n\t.get_by_vcc = eg_cache_get_by_vcc,\n\t.get_by_src_ip = eg_cache_get_by_src_ip,\n\t.put = eg_cache_put,\n\t.remove_entry = eg_cache_remove_entry,\n\t.update = update_eg_cache_entry,\n\t.clear_expired = clear_expired,\n\t.destroy_cache = eg_destroy_cache\n};\n\nvoid atm_mpoa_init_cache(struct mpoa_client *mpc)\n{\n\tmpc->in_ops = &ingress_ops;\n\tmpc->eg_ops = &egress_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}