{
  "module_name": "ioctl.c",
  "hash_id": "dd75030706723bfba61a9acbf696c0a54bbba84d41d4d6554705c176e00b1558",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/ioctl.c",
  "human_readable_source": "\n \n\n \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/net.h>\t\t \n#include <linux/atm.h>\t\t \n#include <linux/atmdev.h>\n#include <linux/atmclip.h>\t \n#include <linux/atmarp.h>\t \n#include <linux/capability.h>\n#include <linux/sonet.h>\t \n#include <linux/atmsvc.h>\n#include <linux/atmmpc.h>\n#include <net/atmclip.h>\n#include <linux/atmlec.h>\n#include <linux/mutex.h>\n#include <asm/ioctls.h>\n#include <net/compat.h>\n\n#include \"resources.h\"\n#include \"signaling.h\"\t\t \n#include \"common.h\"\n\n\nstatic DEFINE_MUTEX(ioctl_mutex);\nstatic LIST_HEAD(ioctl_list);\n\n\nvoid register_atm_ioctl(struct atm_ioctl *ioctl)\n{\n\tmutex_lock(&ioctl_mutex);\n\tlist_add_tail(&ioctl->list, &ioctl_list);\n\tmutex_unlock(&ioctl_mutex);\n}\nEXPORT_SYMBOL(register_atm_ioctl);\n\nvoid deregister_atm_ioctl(struct atm_ioctl *ioctl)\n{\n\tmutex_lock(&ioctl_mutex);\n\tlist_del(&ioctl->list);\n\tmutex_unlock(&ioctl_mutex);\n}\nEXPORT_SYMBOL(deregister_atm_ioctl);\n\nstatic int do_vcc_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg, int compat)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n\tint error;\n\tstruct list_head *pos;\n\tvoid __user *argp = (void __user *)arg;\n\tvoid __user *buf;\n\tint __user *len;\n\n\tvcc = ATM_SD(sock);\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\t\tif (sock->state != SS_CONNECTED ||\n\t\t    !test_bit(ATM_VF_READY, &vcc->flags)) {\n\t\t\terror =  -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\terror = put_user(sk->sk_sndbuf - sk_wmem_alloc_get(sk),\n\t\t\t\t (int __user *)argp) ? -EFAULT : 0;\n\t\tgoto done;\n\tcase SIOCINQ:\n\t{\n\t\tstruct sk_buff *skb;\n\t\tint amount;\n\n\t\tif (sock->state != SS_CONNECTED) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tspin_lock_irq(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tamount = skb ? skb->len : 0;\n\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n\t\terror = put_user(amount, (int __user *)argp) ? -EFAULT : 0;\n\t\tgoto done;\n\t}\n\tcase ATM_SETSC:\n\t\tnet_warn_ratelimited(\"ATM_SETSC is obsolete; used by %s:%d\\n\",\n\t\t\t\t     current->comm, task_pid_nr(current));\n\t\terror = 0;\n\t\tgoto done;\n\tcase ATMSIGD_CTRL:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\tif (!capable(CAP_SYS_RAWIO)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n#ifdef CONFIG_COMPAT\n\t\t \n\t\tif (compat) {\n\t\t\tnet_warn_ratelimited(\"32-bit task cannot be atmsigd\\n\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n#endif\n\t\terror = sigd_attach(vcc);\n\t\tif (!error)\n\t\t\tsock->state = SS_CONNECTED;\n\t\tgoto done;\n\tcase ATM_SETBACKEND:\n\tcase ATM_NEWBACKENDIF:\n\t{\n\t\tatm_backend_t backend;\n\t\terror = get_user(backend, (atm_backend_t __user *)argp);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tswitch (backend) {\n\t\tcase ATM_BACKEND_PPP:\n\t\t\trequest_module(\"pppoatm\");\n\t\t\tbreak;\n\t\tcase ATM_BACKEND_BR2684:\n\t\t\trequest_module(\"br2684\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ATMMPC_CTRL:\n\tcase ATMMPC_DATA:\n\t\trequest_module(\"mpoa\");\n\t\tbreak;\n\tcase ATMARPD_CTRL:\n\t\trequest_module(\"clip\");\n\t\tbreak;\n\tcase ATMLEC_CTRL:\n\t\trequest_module(\"lec\");\n\t\tbreak;\n\t}\n\n\terror = -ENOIOCTLCMD;\n\n\tmutex_lock(&ioctl_mutex);\n\tlist_for_each(pos, &ioctl_list) {\n\t\tstruct atm_ioctl *ic = list_entry(pos, struct atm_ioctl, list);\n\t\tif (try_module_get(ic->owner)) {\n\t\t\terror = ic->ioctl(sock, cmd, arg);\n\t\t\tmodule_put(ic->owner);\n\t\t\tif (error != -ENOIOCTLCMD)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ioctl_mutex);\n\n\tif (error != -ENOIOCTLCMD)\n\t\tgoto done;\n\n\tif (cmd == ATM_GETNAMES) {\n\t\tif (IS_ENABLED(CONFIG_COMPAT) && compat) {\n#ifdef CONFIG_COMPAT\n\t\t\tstruct compat_atm_iobuf __user *ciobuf = argp;\n\t\t\tcompat_uptr_t cbuf;\n\t\t\tlen = &ciobuf->length;\n\t\t\tif (get_user(cbuf, &ciobuf->buffer))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf = compat_ptr(cbuf);\n#endif\n\t\t} else {\n\t\t\tstruct atm_iobuf __user *iobuf = argp;\n\t\t\tlen = &iobuf->length;\n\t\t\tif (get_user(buf, &iobuf->buffer))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\terror = atm_getnames(buf, len);\n\t} else {\n\t\tint number;\n\n\t\tif (IS_ENABLED(CONFIG_COMPAT) && compat) {\n#ifdef CONFIG_COMPAT\n\t\t\tstruct compat_atmif_sioc __user *csioc = argp;\n\t\t\tcompat_uptr_t carg;\n\n\t\t\tlen = &csioc->length;\n\t\t\tif (get_user(carg, &csioc->arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf = compat_ptr(carg);\n\t\t\tif (get_user(number, &csioc->number))\n\t\t\t\treturn -EFAULT;\n#endif\n\t\t} else {\n\t\t\tstruct atmif_sioc __user *sioc = argp;\n\n\t\t\tlen = &sioc->length;\n\t\t\tif (get_user(buf, &sioc->arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (get_user(number, &sioc->number))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\terror = atm_dev_ioctl(cmd, buf, len, number, compat);\n\t}\n\ndone:\n\treturn error;\n}\n\nint vcc_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\treturn do_vcc_ioctl(sock, cmd, arg, 0);\n}\n\n#ifdef CONFIG_COMPAT\n \n#define ATM_GETLINKRATE32 _IOW('a', ATMIOC_ITF+1, struct compat_atmif_sioc)\n#define ATM_GETNAMES32    _IOW('a', ATMIOC_ITF+3, struct compat_atm_iobuf)\n#define ATM_GETTYPE32     _IOW('a', ATMIOC_ITF+4, struct compat_atmif_sioc)\n#define ATM_GETESI32\t  _IOW('a', ATMIOC_ITF+5, struct compat_atmif_sioc)\n#define ATM_GETADDR32\t  _IOW('a', ATMIOC_ITF+6, struct compat_atmif_sioc)\n#define ATM_RSTADDR32\t  _IOW('a', ATMIOC_ITF+7, struct compat_atmif_sioc)\n#define ATM_ADDADDR32\t  _IOW('a', ATMIOC_ITF+8, struct compat_atmif_sioc)\n#define ATM_DELADDR32\t  _IOW('a', ATMIOC_ITF+9, struct compat_atmif_sioc)\n#define ATM_GETCIRANGE32  _IOW('a', ATMIOC_ITF+10, struct compat_atmif_sioc)\n#define ATM_SETCIRANGE32  _IOW('a', ATMIOC_ITF+11, struct compat_atmif_sioc)\n#define ATM_SETESI32      _IOW('a', ATMIOC_ITF+12, struct compat_atmif_sioc)\n#define ATM_SETESIF32     _IOW('a', ATMIOC_ITF+13, struct compat_atmif_sioc)\n#define ATM_GETSTAT32     _IOW('a', ATMIOC_SARCOM+0, struct compat_atmif_sioc)\n#define ATM_GETSTATZ32    _IOW('a', ATMIOC_SARCOM+1, struct compat_atmif_sioc)\n#define ATM_GETLOOP32\t  _IOW('a', ATMIOC_SARCOM+2, struct compat_atmif_sioc)\n#define ATM_SETLOOP32\t  _IOW('a', ATMIOC_SARCOM+3, struct compat_atmif_sioc)\n#define ATM_QUERYLOOP32\t  _IOW('a', ATMIOC_SARCOM+4, struct compat_atmif_sioc)\n\nstatic struct {\n\tunsigned int cmd32;\n\tunsigned int cmd;\n} atm_ioctl_map[] = {\n\t{ ATM_GETLINKRATE32, ATM_GETLINKRATE },\n\t{ ATM_GETNAMES32,    ATM_GETNAMES },\n\t{ ATM_GETTYPE32,     ATM_GETTYPE },\n\t{ ATM_GETESI32,\t     ATM_GETESI },\n\t{ ATM_GETADDR32,     ATM_GETADDR },\n\t{ ATM_RSTADDR32,     ATM_RSTADDR },\n\t{ ATM_ADDADDR32,     ATM_ADDADDR },\n\t{ ATM_DELADDR32,     ATM_DELADDR },\n\t{ ATM_GETCIRANGE32,  ATM_GETCIRANGE },\n\t{ ATM_SETCIRANGE32,  ATM_SETCIRANGE },\n\t{ ATM_SETESI32,\t     ATM_SETESI },\n\t{ ATM_SETESIF32,     ATM_SETESIF },\n\t{ ATM_GETSTAT32,     ATM_GETSTAT },\n\t{ ATM_GETSTATZ32,    ATM_GETSTATZ },\n\t{ ATM_GETLOOP32,     ATM_GETLOOP },\n\t{ ATM_SETLOOP32,     ATM_SETLOOP },\n\t{ ATM_QUERYLOOP32,   ATM_QUERYLOOP },\n};\n\n#define NR_ATM_IOCTL ARRAY_SIZE(atm_ioctl_map)\n\nstatic int do_atm_iobuf(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct compat_atm_iobuf __user *iobuf32 = compat_ptr(arg);\n\tu32 data;\n\n\tif (get_user(data, &iobuf32->buffer))\n\t\treturn -EFAULT;\n\n\treturn atm_getnames(&iobuf32->length, compat_ptr(data));\n}\n\nstatic int do_atmif_sioc(struct socket *sock, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tstruct compat_atmif_sioc __user *sioc32 = compat_ptr(arg);\n\tint number;\n\tu32 data;\n\n\tif (get_user(data, &sioc32->arg) || get_user(number, &sioc32->number))\n\t\treturn -EFAULT;\n\treturn atm_dev_ioctl(cmd, compat_ptr(data), &sioc32->length, number, 0);\n}\n\nstatic int do_atm_ioctl(struct socket *sock, unsigned int cmd32,\n\t\t\tunsigned long arg)\n{\n\tint i;\n\tunsigned int cmd = 0;\n\n\tswitch (cmd32) {\n\tcase SONET_GETSTAT:\n\tcase SONET_GETSTATZ:\n\tcase SONET_GETDIAG:\n\tcase SONET_SETDIAG:\n\tcase SONET_CLRDIAG:\n\tcase SONET_SETFRAMING:\n\tcase SONET_GETFRAMING:\n\tcase SONET_GETFRSENSE:\n\t\treturn do_atmif_sioc(sock, cmd32, arg);\n\t}\n\n\tfor (i = 0; i < NR_ATM_IOCTL; i++) {\n\t\tif (cmd32 == atm_ioctl_map[i].cmd32) {\n\t\t\tcmd = atm_ioctl_map[i].cmd;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == NR_ATM_IOCTL)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase ATM_GETNAMES:\n\t\treturn do_atm_iobuf(sock, cmd, arg);\n\n\tcase ATM_GETLINKRATE:\n\tcase ATM_GETTYPE:\n\tcase ATM_GETESI:\n\tcase ATM_GETADDR:\n\tcase ATM_RSTADDR:\n\tcase ATM_ADDADDR:\n\tcase ATM_DELADDR:\n\tcase ATM_GETCIRANGE:\n\tcase ATM_SETCIRANGE:\n\tcase ATM_SETESI:\n\tcase ATM_SETESIF:\n\tcase ATM_GETSTAT:\n\tcase ATM_GETSTATZ:\n\tcase ATM_GETLOOP:\n\tcase ATM_SETLOOP:\n\tcase ATM_QUERYLOOP:\n\t\treturn do_atmif_sioc(sock, cmd, arg);\n\t}\n\n\treturn -EINVAL;\n}\n\nint vcc_compat_ioctl(struct socket *sock, unsigned int cmd,\n\t\t     unsigned long arg)\n{\n\tint ret;\n\n\tret = do_vcc_ioctl(sock, cmd, arg, 1);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\treturn do_atm_ioctl(sock, cmd, arg);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}