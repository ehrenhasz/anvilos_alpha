{
  "module_name": "pppoatm.c",
  "hash_id": "253282062979b28a70c907064c8f2d148818b66defa6570fdb1a17458106e75e",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/pppoatm.c",
  "human_readable_source": "\n \n\n \n \n \n \n\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/atm.h>\n#include <linux/atmdev.h>\n#include <linux/capability.h>\n#include <linux/ppp_defs.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/ppp_channel.h>\n#include <linux/atmppp.h>\n\n#include \"common.h\"\n\nenum pppoatm_encaps {\n\te_autodetect = PPPOATM_ENCAPS_AUTODETECT,\n\te_vc = PPPOATM_ENCAPS_VC,\n\te_llc = PPPOATM_ENCAPS_LLC,\n};\n\nstruct pppoatm_vcc {\n\tstruct atm_vcc\t*atmvcc;\t \n\tvoid (*old_push)(struct atm_vcc *, struct sk_buff *);\n\tvoid (*old_pop)(struct atm_vcc *, struct sk_buff *);\n\tvoid (*old_release_cb)(struct atm_vcc *);\n\tstruct module *old_owner;\n\t\t\t\t\t \n\tenum pppoatm_encaps encaps;\n\tatomic_t inflight;\n\tunsigned long blocked;\n\tint flags;\t\t\t \n\tstruct ppp_channel chan;\t \n\tstruct tasklet_struct wakeup_tasklet;\n};\n\n \n#define NONE_INFLIGHT -2\n\n#define BLOCKED 0\n\n \nstatic const unsigned char pppllc[6] = { 0xFE, 0xFE, 0x03, 0xCF, 0xC0, 0x21 };\n#define LLC_LEN\t\t(4)\n\nstatic inline struct pppoatm_vcc *atmvcc_to_pvcc(const struct atm_vcc *atmvcc)\n{\n\treturn (struct pppoatm_vcc *) (atmvcc->user_back);\n}\n\nstatic inline struct pppoatm_vcc *chan_to_pvcc(const struct ppp_channel *chan)\n{\n\treturn (struct pppoatm_vcc *) (chan->private);\n}\n\n \nstatic void pppoatm_wakeup_sender(struct tasklet_struct *t)\n{\n\tstruct pppoatm_vcc *pvcc = from_tasklet(pvcc, t, wakeup_tasklet);\n\n\tppp_output_wakeup(&pvcc->chan);\n}\n\nstatic void pppoatm_release_cb(struct atm_vcc *atmvcc)\n{\n\tstruct pppoatm_vcc *pvcc = atmvcc_to_pvcc(atmvcc);\n\n\t \n\tif (test_and_clear_bit(BLOCKED, &pvcc->blocked))\n\t\ttasklet_schedule(&pvcc->wakeup_tasklet);\n\tif (pvcc->old_release_cb)\n\t\tpvcc->old_release_cb(atmvcc);\n}\n \nstatic void pppoatm_pop(struct atm_vcc *atmvcc, struct sk_buff *skb)\n{\n\tstruct pppoatm_vcc *pvcc = atmvcc_to_pvcc(atmvcc);\n\n\tpvcc->old_pop(atmvcc, skb);\n\tatomic_dec(&pvcc->inflight);\n\n\t \n\tif (test_and_clear_bit(BLOCKED, &pvcc->blocked))\n\t\ttasklet_schedule(&pvcc->wakeup_tasklet);\n}\n\n \nstatic void pppoatm_unassign_vcc(struct atm_vcc *atmvcc)\n{\n\tstruct pppoatm_vcc *pvcc;\n\tpvcc = atmvcc_to_pvcc(atmvcc);\n\tatmvcc->push = pvcc->old_push;\n\tatmvcc->pop = pvcc->old_pop;\n\tatmvcc->release_cb = pvcc->old_release_cb;\n\ttasklet_kill(&pvcc->wakeup_tasklet);\n\tppp_unregister_channel(&pvcc->chan);\n\tatmvcc->user_back = NULL;\n\tkfree(pvcc);\n}\n\n \nstatic void pppoatm_push(struct atm_vcc *atmvcc, struct sk_buff *skb)\n{\n\tstruct pppoatm_vcc *pvcc = atmvcc_to_pvcc(atmvcc);\n\tpr_debug(\"\\n\");\n\tif (skb == NULL) {\t\t\t \n\t\tstruct module *module;\n\n\t\tpr_debug(\"removing ATMPPP VCC %p\\n\", pvcc);\n\t\tmodule = pvcc->old_owner;\n\t\tpppoatm_unassign_vcc(atmvcc);\n\t\tatmvcc->push(atmvcc, NULL);\t \n\t\tmodule_put(module);\n\t\treturn;\n\t}\n\tatm_return(atmvcc, skb->truesize);\n\tswitch (pvcc->encaps) {\n\tcase e_llc:\n\t\tif (skb->len < LLC_LEN ||\n\t\t    memcmp(skb->data, pppllc, LLC_LEN))\n\t\t\tgoto error;\n\t\tskb_pull(skb, LLC_LEN);\n\t\tbreak;\n\tcase e_autodetect:\n\t\tif (pvcc->chan.ppp == NULL) {\t \n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tif (skb->len >= sizeof(pppllc) &&\n\t\t    !memcmp(skb->data, pppllc, sizeof(pppllc))) {\n\t\t\tpvcc->encaps = e_llc;\n\t\t\tskb_pull(skb, LLC_LEN);\n\t\t\tbreak;\n\t\t}\n\t\tif (skb->len >= (sizeof(pppllc) - LLC_LEN) &&\n\t\t    !memcmp(skb->data, &pppllc[LLC_LEN],\n\t\t    sizeof(pppllc) - LLC_LEN)) {\n\t\t\tpvcc->encaps = e_vc;\n\t\t\tpvcc->chan.mtu += LLC_LEN;\n\t\t\tbreak;\n\t\t}\n\t\tpr_debug(\"Couldn't autodetect yet (skb: %6ph)\\n\", skb->data);\n\t\tgoto error;\n\tcase e_vc:\n\t\tbreak;\n\t}\n\tppp_input(&pvcc->chan, skb);\n\treturn;\n\nerror:\n\tkfree_skb(skb);\n\tppp_input_error(&pvcc->chan, 0);\n}\n\nstatic int pppoatm_may_send(struct pppoatm_vcc *pvcc, int size)\n{\n\t \n\tif (atm_may_send(pvcc->atmvcc, size) &&\n\t    atomic_inc_not_zero(&pvcc->inflight))\n\t\treturn 1;\n\n\t \n\ttest_and_set_bit(BLOCKED, &pvcc->blocked);\n\n\t \n\tif (atm_may_send(pvcc->atmvcc, size) &&\n\t    atomic_inc_not_zero(&pvcc->inflight))\n\t\treturn 1;\n\n\treturn 0;\n}\n \n#define DROP_PACKET 1\nstatic int pppoatm_send(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct pppoatm_vcc *pvcc = chan_to_pvcc(chan);\n\tstruct atm_vcc *vcc;\n\tint ret;\n\n\tATM_SKB(skb)->vcc = pvcc->atmvcc;\n\tpr_debug(\"(skb=0x%p, vcc=0x%p)\\n\", skb, pvcc->atmvcc);\n\tif (skb->data[0] == '\\0' && (pvcc->flags & SC_COMP_PROT))\n\t\t(void) skb_pull(skb, 1);\n\n\tvcc = ATM_SKB(skb)->vcc;\n\tbh_lock_sock(sk_atm(vcc));\n\tif (sock_owned_by_user(sk_atm(vcc))) {\n\t\t \n\t\ttest_and_set_bit(BLOCKED, &pvcc->blocked);\n\t\tgoto nospace;\n\t}\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags)) {\n\t\tbh_unlock_sock(sk_atm(vcc));\n\t\tkfree_skb(skb);\n\t\treturn DROP_PACKET;\n\t}\n\n\tswitch (pvcc->encaps) {\t\t \n\tcase e_llc:\n\t\tif (skb_headroom(skb) < LLC_LEN) {\n\t\t\tstruct sk_buff *n;\n\t\t\tn = skb_realloc_headroom(skb, LLC_LEN);\n\t\t\tif (n != NULL &&\n\t\t\t    !pppoatm_may_send(pvcc, n->truesize)) {\n\t\t\t\tkfree_skb(n);\n\t\t\t\tgoto nospace;\n\t\t\t}\n\t\t\tconsume_skb(skb);\n\t\t\tskb = n;\n\t\t\tif (skb == NULL) {\n\t\t\t\tbh_unlock_sock(sk_atm(vcc));\n\t\t\t\treturn DROP_PACKET;\n\t\t\t}\n\t\t} else if (!pppoatm_may_send(pvcc, skb->truesize))\n\t\t\tgoto nospace;\n\t\tmemcpy(skb_push(skb, LLC_LEN), pppllc, LLC_LEN);\n\t\tbreak;\n\tcase e_vc:\n\t\tif (!pppoatm_may_send(pvcc, skb->truesize))\n\t\t\tgoto nospace;\n\t\tbreak;\n\tcase e_autodetect:\n\t\tbh_unlock_sock(sk_atm(vcc));\n\t\tpr_debug(\"Trying to send without setting encaps!\\n\");\n\t\tkfree_skb(skb);\n\t\treturn 1;\n\t}\n\n\tatm_account_tx(vcc, skb);\n\tpr_debug(\"atm_skb(%p)->vcc(%p)->dev(%p)\\n\",\n\t\t skb, ATM_SKB(skb)->vcc, ATM_SKB(skb)->vcc->dev);\n\tret = ATM_SKB(skb)->vcc->send(ATM_SKB(skb)->vcc, skb)\n\t    ? DROP_PACKET : 1;\n\tbh_unlock_sock(sk_atm(vcc));\n\treturn ret;\nnospace:\n\tbh_unlock_sock(sk_atm(vcc));\n\t \n\tif ((pvcc->flags & SC_COMP_PROT) && skb_headroom(skb) > 0 &&\n\t    skb->data[-1] == '\\0')\n\t\t(void) skb_push(skb, 1);\n\treturn 0;\n}\n\n \nstatic int pppoatm_devppp_ioctl(struct ppp_channel *chan, unsigned int cmd,\n\tunsigned long arg)\n{\n\tswitch (cmd) {\n\tcase PPPIOCGFLAGS:\n\t\treturn put_user(chan_to_pvcc(chan)->flags, (int __user *) arg)\n\t\t    ? -EFAULT : 0;\n\tcase PPPIOCSFLAGS:\n\t\treturn get_user(chan_to_pvcc(chan)->flags, (int __user *) arg)\n\t\t    ? -EFAULT : 0;\n\t}\n\treturn -ENOTTY;\n}\n\nstatic const struct ppp_channel_ops pppoatm_ops = {\n\t.start_xmit = pppoatm_send,\n\t.ioctl = pppoatm_devppp_ioctl,\n};\n\nstatic int pppoatm_assign_vcc(struct atm_vcc *atmvcc, void __user *arg)\n{\n\tstruct atm_backend_ppp be;\n\tstruct pppoatm_vcc *pvcc;\n\tint err;\n\n\tif (copy_from_user(&be, arg, sizeof be))\n\t\treturn -EFAULT;\n\tif (be.encaps != PPPOATM_ENCAPS_AUTODETECT &&\n\t    be.encaps != PPPOATM_ENCAPS_VC && be.encaps != PPPOATM_ENCAPS_LLC)\n\t\treturn -EINVAL;\n\tpvcc = kzalloc(sizeof(*pvcc), GFP_KERNEL);\n\tif (pvcc == NULL)\n\t\treturn -ENOMEM;\n\tpvcc->atmvcc = atmvcc;\n\n\t \n\tatomic_set(&pvcc->inflight, NONE_INFLIGHT);\n\tpvcc->old_push = atmvcc->push;\n\tpvcc->old_pop = atmvcc->pop;\n\tpvcc->old_owner = atmvcc->owner;\n\tpvcc->old_release_cb = atmvcc->release_cb;\n\tpvcc->encaps = (enum pppoatm_encaps) be.encaps;\n\tpvcc->chan.private = pvcc;\n\tpvcc->chan.ops = &pppoatm_ops;\n\tpvcc->chan.mtu = atmvcc->qos.txtp.max_sdu - PPP_HDRLEN -\n\t    (be.encaps == e_vc ? 0 : LLC_LEN);\n\ttasklet_setup(&pvcc->wakeup_tasklet, pppoatm_wakeup_sender);\n\terr = ppp_register_channel(&pvcc->chan);\n\tif (err != 0) {\n\t\tkfree(pvcc);\n\t\treturn err;\n\t}\n\tatmvcc->user_back = pvcc;\n\tatmvcc->push = pppoatm_push;\n\tatmvcc->pop = pppoatm_pop;\n\tatmvcc->release_cb = pppoatm_release_cb;\n\t__module_get(THIS_MODULE);\n\tatmvcc->owner = THIS_MODULE;\n\n\t \n\tvcc_process_recv_queue(atmvcc);\n\treturn 0;\n}\n\n \nstatic int pppoatm_ioctl(struct socket *sock, unsigned int cmd,\n\tunsigned long arg)\n{\n\tstruct atm_vcc *atmvcc = ATM_SD(sock);\n\tvoid __user *argp = (void __user *)arg;\n\n\tif (cmd != ATM_SETBACKEND && atmvcc->push != pppoatm_push)\n\t\treturn -ENOIOCTLCMD;\n\tswitch (cmd) {\n\tcase ATM_SETBACKEND: {\n\t\tatm_backend_t b;\n\t\tif (get_user(b, (atm_backend_t __user *) argp))\n\t\t\treturn -EFAULT;\n\t\tif (b != ATM_BACKEND_PPP)\n\t\t\treturn -ENOIOCTLCMD;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sock->state != SS_CONNECTED)\n\t\t\treturn -EINVAL;\n\t\treturn pppoatm_assign_vcc(atmvcc, argp);\n\t\t}\n\tcase PPPIOCGCHAN:\n\t\treturn put_user(ppp_channel_index(&atmvcc_to_pvcc(atmvcc)->\n\t\t    chan), (int __user *) argp) ? -EFAULT : 0;\n\tcase PPPIOCGUNIT:\n\t\treturn put_user(ppp_unit_number(&atmvcc_to_pvcc(atmvcc)->\n\t\t    chan), (int __user *) argp) ? -EFAULT : 0;\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\nstatic struct atm_ioctl pppoatm_ioctl_ops = {\n\t.owner\t= THIS_MODULE,\n\t.ioctl\t= pppoatm_ioctl,\n};\n\nstatic int __init pppoatm_init(void)\n{\n\tregister_atm_ioctl(&pppoatm_ioctl_ops);\n\treturn 0;\n}\n\nstatic void __exit pppoatm_exit(void)\n{\n\tderegister_atm_ioctl(&pppoatm_ioctl_ops);\n}\n\nmodule_init(pppoatm_init);\nmodule_exit(pppoatm_exit);\n\nMODULE_AUTHOR(\"Mitchell Blank Jr <mitch@sfgoth.com>\");\nMODULE_DESCRIPTION(\"RFC2364 PPP over ATM/AAL5\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}