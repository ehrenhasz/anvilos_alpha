{
  "module_name": "mpc.c",
  "hash_id": "946db043d87ade84845c898d74387769c34b943bdf03001839e363f8428b2dda",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/mpc.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/seq_file.h>\n\n \n#include <linux/if_ether.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <net/sock.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <net/checksum.h>    \n#include <net/arp.h>\n#include <net/dst.h>\n#include <linux/proc_fs.h>\n\n \n#include <linux/atmdev.h>\n#include <linux/atmlec.h>\n#include <linux/atmmpc.h>\n \n#include <linux/module.h>\n\n#include \"lec.h\"\n#include \"mpc.h\"\n#include \"resources.h\"\n\n \n\n#if 0\n#define dprintk(format, args...) \\\n\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __func__, ##args)\n#define dprintk_cont(format, args...) printk(KERN_CONT format, ##args)\n#else\n#define dprintk(format, args...)\t\t\t\t\t\\\n\tdo { if (0)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __func__, ##args);\\\n\t} while (0)\n#define dprintk_cont(format, args...)\t\t\t\\\n\tdo { if (0) printk(KERN_CONT format, ##args); } while (0)\n#endif\n\n#if 0\n#define ddprintk(format, args...) \\\n\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __func__, ##args)\n#define ddprintk_cont(format, args...) printk(KERN_CONT format, ##args)\n#else\n#define ddprintk(format, args...)\t\t\t\t\t\\\n\tdo { if (0)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"mpoa:%s: \" format, __func__, ##args);\\\n\t} while (0)\n#define ddprintk_cont(format, args...)\t\t\t\\\n\tdo { if (0) printk(KERN_CONT format, ##args); } while (0)\n#endif\n\n \nstatic void MPOA_trigger_rcvd(struct k_message *msg, struct mpoa_client *mpc);\nstatic void MPOA_res_reply_rcvd(struct k_message *msg, struct mpoa_client *mpc);\nstatic void ingress_purge_rcvd(struct k_message *msg, struct mpoa_client *mpc);\nstatic void egress_purge_rcvd(struct k_message *msg, struct mpoa_client *mpc);\nstatic void mps_death(struct k_message *msg, struct mpoa_client *mpc);\nstatic void clean_up(struct k_message *msg, struct mpoa_client *mpc,\n\t\t     int action);\nstatic void MPOA_cache_impos_rcvd(struct k_message *msg,\n\t\t\t\t  struct mpoa_client *mpc);\nstatic void set_mpc_ctrl_addr_rcvd(struct k_message *mesg,\n\t\t\t\t   struct mpoa_client *mpc);\nstatic void set_mps_mac_addr_rcvd(struct k_message *mesg,\n\t\t\t\t  struct mpoa_client *mpc);\n\nstatic const uint8_t *copy_macs(struct mpoa_client *mpc,\n\t\t\t\tconst uint8_t *router_mac,\n\t\t\t\tconst uint8_t *tlvs, uint8_t mps_macs,\n\t\t\t\tuint8_t device_type);\nstatic void purge_egress_shortcut(struct atm_vcc *vcc, eg_cache_entry *entry);\n\nstatic void send_set_mps_ctrl_addr(const char *addr, struct mpoa_client *mpc);\nstatic void mpoad_close(struct atm_vcc *vcc);\nstatic int msg_from_mpoad(struct atm_vcc *vcc, struct sk_buff *skb);\n\nstatic void mpc_push(struct atm_vcc *vcc, struct sk_buff *skb);\nstatic netdev_tx_t mpc_send_packet(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev);\nstatic int mpoa_event_listener(struct notifier_block *mpoa_notifier,\n\t\t\t       unsigned long event, void *dev);\nstatic void mpc_timer_refresh(void);\nstatic void mpc_cache_check(struct timer_list *unused);\n\nstatic struct llc_snap_hdr llc_snap_mpoa_ctrl = {\n\t0xaa, 0xaa, 0x03,\n\t{0x00, 0x00, 0x5e},\n\t{0x00, 0x03}          \n};\nstatic struct llc_snap_hdr llc_snap_mpoa_data = {\n\t0xaa, 0xaa, 0x03,\n\t{0x00, 0x00, 0x00},\n\t{0x08, 0x00}          \n};\nstatic struct llc_snap_hdr llc_snap_mpoa_data_tagged = {\n\t0xaa, 0xaa, 0x03,\n\t{0x00, 0x00, 0x00},\n\t{0x88, 0x4c}          \n};\n\nstatic struct notifier_block mpoa_notifier = {\n\tmpoa_event_listener,\n\tNULL,\n\t0\n};\n\nstruct mpoa_client *mpcs = NULL;  \nstatic struct atm_mpoa_qos *qos_head = NULL;\nstatic DEFINE_TIMER(mpc_timer, mpc_cache_check);\n\n\nstatic struct mpoa_client *find_mpc_by_itfnum(int itf)\n{\n\tstruct mpoa_client *mpc;\n\n\tmpc = mpcs;   \n\twhile (mpc != NULL) {\n\t\tif (mpc->dev_num == itf)\n\t\t\treturn mpc;\n\t\tmpc = mpc->next;\n\t}\n\n\treturn NULL;    \n}\n\nstatic struct mpoa_client *find_mpc_by_vcc(struct atm_vcc *vcc)\n{\n\tstruct mpoa_client *mpc;\n\n\tmpc = mpcs;   \n\twhile (mpc != NULL) {\n\t\tif (mpc->mpoad_vcc == vcc)\n\t\t\treturn mpc;\n\t\tmpc = mpc->next;\n\t}\n\n\treturn NULL;    \n}\n\nstatic struct mpoa_client *find_mpc_by_lec(struct net_device *dev)\n{\n\tstruct mpoa_client *mpc;\n\n\tmpc = mpcs;   \n\twhile (mpc != NULL) {\n\t\tif (mpc->dev == dev)\n\t\t\treturn mpc;\n\t\tmpc = mpc->next;\n\t}\n\n\treturn NULL;    \n}\n\n \n\n \nstruct atm_mpoa_qos *atm_mpoa_add_qos(__be32 dst_ip, struct atm_qos *qos)\n{\n\tstruct atm_mpoa_qos *entry;\n\n\tentry = atm_mpoa_search_qos(dst_ip);\n\tif (entry != NULL) {\n\t\tentry->qos = *qos;\n\t\treturn entry;\n\t}\n\n\tentry = kmalloc(sizeof(struct atm_mpoa_qos), GFP_KERNEL);\n\tif (entry == NULL) {\n\t\tpr_info(\"mpoa: out of memory\\n\");\n\t\treturn entry;\n\t}\n\n\tentry->ipaddr = dst_ip;\n\tentry->qos = *qos;\n\n\tentry->next = qos_head;\n\tqos_head = entry;\n\n\treturn entry;\n}\n\nstruct atm_mpoa_qos *atm_mpoa_search_qos(__be32 dst_ip)\n{\n\tstruct atm_mpoa_qos *qos;\n\n\tqos = qos_head;\n\twhile (qos) {\n\t\tif (qos->ipaddr == dst_ip)\n\t\t\tbreak;\n\t\tqos = qos->next;\n\t}\n\n\treturn qos;\n}\n\n \nint atm_mpoa_delete_qos(struct atm_mpoa_qos *entry)\n{\n\tstruct atm_mpoa_qos *curr;\n\n\tif (entry == NULL)\n\t\treturn 0;\n\tif (entry == qos_head) {\n\t\tqos_head = qos_head->next;\n\t\tkfree(entry);\n\t\treturn 1;\n\t}\n\n\tcurr = qos_head;\n\twhile (curr != NULL) {\n\t\tif (curr->next == entry) {\n\t\t\tcurr->next = entry->next;\n\t\t\tkfree(entry);\n\t\t\treturn 1;\n\t\t}\n\t\tcurr = curr->next;\n\t}\n\n\treturn 0;\n}\n\n \nvoid atm_mpoa_disp_qos(struct seq_file *m)\n{\n\tstruct atm_mpoa_qos *qos;\n\n\tqos = qos_head;\n\tseq_printf(m, \"QoS entries for shortcuts:\\n\");\n\tseq_printf(m, \"IP address\\n  TX:max_pcr pcr     min_pcr max_cdv max_sdu\\n  RX:max_pcr pcr     min_pcr max_cdv max_sdu\\n\");\n\n\twhile (qos != NULL) {\n\t\tseq_printf(m, \"%pI4\\n     %-7d %-7d %-7d %-7d %-7d\\n     %-7d %-7d %-7d %-7d %-7d\\n\",\n\t\t\t   &qos->ipaddr,\n\t\t\t   qos->qos.txtp.max_pcr,\n\t\t\t   qos->qos.txtp.pcr,\n\t\t\t   qos->qos.txtp.min_pcr,\n\t\t\t   qos->qos.txtp.max_cdv,\n\t\t\t   qos->qos.txtp.max_sdu,\n\t\t\t   qos->qos.rxtp.max_pcr,\n\t\t\t   qos->qos.rxtp.pcr,\n\t\t\t   qos->qos.rxtp.min_pcr,\n\t\t\t   qos->qos.rxtp.max_cdv,\n\t\t\t   qos->qos.rxtp.max_sdu);\n\t\tqos = qos->next;\n\t}\n}\n\nstatic struct net_device *find_lec_by_itfnum(int itf)\n{\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\n\tsprintf(name, \"lec%d\", itf);\n\tdev = dev_get_by_name(&init_net, name);\n\n\treturn dev;\n}\n\nstatic struct mpoa_client *alloc_mpc(void)\n{\n\tstruct mpoa_client *mpc;\n\n\tmpc = kzalloc(sizeof(struct mpoa_client), GFP_KERNEL);\n\tif (mpc == NULL)\n\t\treturn NULL;\n\trwlock_init(&mpc->ingress_lock);\n\trwlock_init(&mpc->egress_lock);\n\tmpc->next = mpcs;\n\tatm_mpoa_init_cache(mpc);\n\n\tmpc->parameters.mpc_p1 = MPC_P1;\n\tmpc->parameters.mpc_p2 = MPC_P2;\n\tmemset(mpc->parameters.mpc_p3, 0, sizeof(mpc->parameters.mpc_p3));\n\tmpc->parameters.mpc_p4 = MPC_P4;\n\tmpc->parameters.mpc_p5 = MPC_P5;\n\tmpc->parameters.mpc_p6 = MPC_P6;\n\n\tmpcs = mpc;\n\n\treturn mpc;\n}\n\n \nstatic void start_mpc(struct mpoa_client *mpc, struct net_device *dev)\n{\n\n\tdprintk(\"(%s)\\n\", mpc->dev->name);\n\tif (!dev->netdev_ops)\n\t\tpr_info(\"(%s) not starting\\n\", dev->name);\n\telse {\n\t\tmpc->old_ops = dev->netdev_ops;\n\t\tmpc->new_ops = *mpc->old_ops;\n\t\tmpc->new_ops.ndo_start_xmit = mpc_send_packet;\n\t\tdev->netdev_ops = &mpc->new_ops;\n\t}\n}\n\nstatic void stop_mpc(struct mpoa_client *mpc)\n{\n\tstruct net_device *dev = mpc->dev;\n\tdprintk(\"(%s)\", mpc->dev->name);\n\n\t \n\tif (dev->netdev_ops != &mpc->new_ops) {\n\t\tdprintk_cont(\" mpc already stopped, not fatal\\n\");\n\t\treturn;\n\t}\n\tdprintk_cont(\"\\n\");\n\n\tdev->netdev_ops = mpc->old_ops;\n\tmpc->old_ops = NULL;\n\n\t \n}\n\nstatic const char *mpoa_device_type_string(char type) __attribute__ ((unused));\n\nstatic const char *mpoa_device_type_string(char type)\n{\n\tswitch (type) {\n\tcase NON_MPOA:\n\t\treturn \"non-MPOA device\";\n\tcase MPS:\n\t\treturn \"MPS\";\n\tcase MPC:\n\t\treturn \"MPC\";\n\tcase MPS_AND_MPC:\n\t\treturn \"both MPS and MPC\";\n\t}\n\n\treturn \"unspecified (non-MPOA) device\";\n}\n\n \nstatic void lane2_assoc_ind(struct net_device *dev, const u8 *mac_addr,\n\t\t\t    const u8 *tlvs, u32 sizeoftlvs)\n{\n\tuint32_t type;\n\tuint8_t length, mpoa_device_type, number_of_mps_macs;\n\tconst uint8_t *end_of_tlvs;\n\tstruct mpoa_client *mpc;\n\n\tmpoa_device_type = number_of_mps_macs = 0;  \n\tdprintk(\"(%s) received TLV(s), \", dev->name);\n\tdprintk(\"total length of all TLVs %d\\n\", sizeoftlvs);\n\tmpc = find_mpc_by_lec(dev);  \n\tif (mpc == NULL) {\n\t\tpr_info(\"(%s) no mpc\\n\", dev->name);\n\t\treturn;\n\t}\n\tend_of_tlvs = tlvs + sizeoftlvs;\n\twhile (end_of_tlvs - tlvs >= 5) {\n\t\ttype = ((tlvs[0] << 24) | (tlvs[1] << 16) |\n\t\t\t(tlvs[2] << 8) | tlvs[3]);\n\t\tlength = tlvs[4];\n\t\ttlvs += 5;\n\t\tdprintk(\"    type 0x%x length %02x\\n\", type, length);\n\t\tif (tlvs + length > end_of_tlvs) {\n\t\t\tpr_info(\"TLV value extends past its buffer, aborting parse\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (type == 0) {\n\t\t\tpr_info(\"mpoa: (%s) TLV type was 0, returning\\n\",\n\t\t\t\tdev->name);\n\t\t\treturn;\n\t\t}\n\n\t\tif (type != TLV_MPOA_DEVICE_TYPE) {\n\t\t\ttlvs += length;\n\t\t\tcontinue;   \n\t\t}\n\t\tmpoa_device_type = *tlvs++;\n\t\tnumber_of_mps_macs = *tlvs++;\n\t\tdprintk(\"(%s) MPOA device type '%s', \",\n\t\t\tdev->name, mpoa_device_type_string(mpoa_device_type));\n\t\tif (mpoa_device_type == MPS_AND_MPC &&\n\t\t    length < (42 + number_of_mps_macs*ETH_ALEN)) {  \n\t\t\tpr_info(\"(%s) short MPOA Device Type TLV\\n\",\n\t\t\t\tdev->name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((mpoa_device_type == MPS || mpoa_device_type == MPC) &&\n\t\t    length < 22 + number_of_mps_macs*ETH_ALEN) {\n\t\t\tpr_info(\"(%s) short MPOA Device Type TLV\\n\", dev->name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (mpoa_device_type != MPS &&\n\t\t    mpoa_device_type != MPS_AND_MPC) {\n\t\t\tdprintk(\"ignoring non-MPS device \");\n\t\t\tif (mpoa_device_type == MPC)\n\t\t\t\ttlvs += 20;\n\t\t\tcontinue;   \n\t\t}\n\t\tif (number_of_mps_macs == 0 &&\n\t\t    mpoa_device_type == MPS_AND_MPC) {\n\t\t\tpr_info(\"(%s) MPS_AND_MPC has zero MACs\\n\", dev->name);\n\t\t\tcontinue;   \n\t\t}\n\t\tdprintk_cont(\"this MPS has %d MAC addresses\\n\",\n\t\t\t     number_of_mps_macs);\n\n\t\t \n\t\tsend_set_mps_ctrl_addr(tlvs, mpc);\n\n\t\ttlvs = copy_macs(mpc, mac_addr, tlvs,\n\t\t\t\t number_of_mps_macs, mpoa_device_type);\n\t\tif (tlvs == NULL)\n\t\t\treturn;\n\t}\n\tif (end_of_tlvs - tlvs != 0)\n\t\tpr_info(\"(%s) ignoring %zd bytes of trailing TLV garbage\\n\",\n\t\t\tdev->name, end_of_tlvs - tlvs);\n}\n\n \nstatic const uint8_t *copy_macs(struct mpoa_client *mpc,\n\t\t\t\tconst uint8_t *router_mac,\n\t\t\t\tconst uint8_t *tlvs, uint8_t mps_macs,\n\t\t\t\tuint8_t device_type)\n{\n\tint num_macs;\n\tnum_macs = (mps_macs > 1) ? mps_macs : 1;\n\n\tif (mpc->number_of_mps_macs != num_macs) {  \n\t\tif (mpc->number_of_mps_macs != 0)\n\t\t\tkfree(mpc->mps_macs);\n\t\tmpc->number_of_mps_macs = 0;\n\t\tmpc->mps_macs = kmalloc_array(ETH_ALEN, num_macs, GFP_KERNEL);\n\t\tif (mpc->mps_macs == NULL) {\n\t\t\tpr_info(\"(%s) out of mem\\n\", mpc->dev->name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tether_addr_copy(mpc->mps_macs, router_mac);\n\ttlvs += 20; if (device_type == MPS_AND_MPC) tlvs += 20;\n\tif (mps_macs > 0)\n\t\tmemcpy(mpc->mps_macs, tlvs, mps_macs*ETH_ALEN);\n\ttlvs += mps_macs*ETH_ALEN;\n\tmpc->number_of_mps_macs = num_macs;\n\n\treturn tlvs;\n}\n\nstatic int send_via_shortcut(struct sk_buff *skb, struct mpoa_client *mpc)\n{\n\tin_cache_entry *entry;\n\tstruct iphdr *iph;\n\tchar *buff;\n\t__be32 ipaddr = 0;\n\n\tstatic struct {\n\t\tstruct llc_snap_hdr hdr;\n\t\t__be32 tag;\n\t} tagged_llc_snap_hdr = {\n\t\t{0xaa, 0xaa, 0x03, {0x00, 0x00, 0x00}, {0x88, 0x4c}},\n\t\t0\n\t};\n\n\tbuff = skb->data + mpc->dev->hard_header_len;\n\tiph = (struct iphdr *)buff;\n\tipaddr = iph->daddr;\n\n\tddprintk(\"(%s) ipaddr 0x%x\\n\",\n\t\t mpc->dev->name, ipaddr);\n\n\tentry = mpc->in_ops->get(ipaddr, mpc);\n\tif (entry == NULL) {\n\t\tentry = mpc->in_ops->add_entry(ipaddr, mpc);\n\t\tif (entry != NULL)\n\t\t\tmpc->in_ops->put(entry);\n\t\treturn 1;\n\t}\n\t \n\tif (mpc->in_ops->cache_hit(entry, mpc) != OPEN) {\n\t\tddprintk(\"(%s) cache_hit: returns != OPEN\\n\",\n\t\t\t mpc->dev->name);\n\t\tmpc->in_ops->put(entry);\n\t\treturn 1;\n\t}\n\n\tddprintk(\"(%s) using shortcut\\n\",\n\t\t mpc->dev->name);\n\t \n\tif (iph->ttl <= 1) {\n\t\tddprintk(\"(%s) IP ttl = %u, using LANE\\n\",\n\t\t\t mpc->dev->name, iph->ttl);\n\t\tmpc->in_ops->put(entry);\n\t\treturn 1;\n\t}\n\tiph->ttl--;\n\tiph->check = 0;\n\tiph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\n\n\tif (entry->ctrl_info.tag != 0) {\n\t\tddprintk(\"(%s) adding tag 0x%x\\n\",\n\t\t\t mpc->dev->name, entry->ctrl_info.tag);\n\t\ttagged_llc_snap_hdr.tag = entry->ctrl_info.tag;\n\t\tskb_pull(skb, ETH_HLEN);\t \n\t\tskb_push(skb, sizeof(tagged_llc_snap_hdr));\n\t\t\t\t\t\t \n\t\tskb_copy_to_linear_data(skb, &tagged_llc_snap_hdr,\n\t\t\t\t\tsizeof(tagged_llc_snap_hdr));\n\t} else {\n\t\tskb_pull(skb, ETH_HLEN);\t \n\t\tskb_push(skb, sizeof(struct llc_snap_hdr));\n\t\t\t\t\t\t \n\t\tskb_copy_to_linear_data(skb, &llc_snap_mpoa_data,\n\t\t\t\t\tsizeof(struct llc_snap_hdr));\n\t}\n\n\tatm_account_tx(entry->shortcut, skb);\n\tentry->shortcut->send(entry->shortcut, skb);\n\tentry->packets_fwded++;\n\tmpc->in_ops->put(entry);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t mpc_send_packet(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct mpoa_client *mpc;\n\tstruct ethhdr *eth;\n\tint i = 0;\n\n\tmpc = find_mpc_by_lec(dev);  \n\tif (mpc == NULL) {\n\t\tpr_info(\"(%s) no MPC found\\n\", dev->name);\n\t\tgoto non_ip;\n\t}\n\n\teth = (struct ethhdr *)skb->data;\n\tif (eth->h_proto != htons(ETH_P_IP))\n\t\tgoto non_ip;  \n\n\t \n\tif (skb->len < ETH_HLEN + sizeof(struct iphdr))\n\t\tgoto non_ip;\n\tskb_set_network_header(skb, ETH_HLEN);\n\tif (skb->len < ETH_HLEN + ip_hdr(skb)->ihl * 4 || ip_hdr(skb)->ihl < 5)\n\t\tgoto non_ip;\n\n\twhile (i < mpc->number_of_mps_macs) {\n\t\tif (ether_addr_equal(eth->h_dest, mpc->mps_macs + i * ETH_ALEN))\n\t\t\tif (send_via_shortcut(skb, mpc) == 0)  \n\t\t\t\treturn NETDEV_TX_OK;\n\t\ti++;\n\t}\n\nnon_ip:\n\treturn __netdev_start_xmit(mpc->old_ops, skb, dev, false);\n}\n\nstatic int atm_mpoa_vcc_attach(struct atm_vcc *vcc, void __user *arg)\n{\n\tint bytes_left;\n\tstruct mpoa_client *mpc;\n\tstruct atmmpc_ioc ioc_data;\n\tin_cache_entry *in_entry;\n\t__be32  ipaddr;\n\n\tbytes_left = copy_from_user(&ioc_data, arg, sizeof(struct atmmpc_ioc));\n\tif (bytes_left != 0) {\n\t\tpr_info(\"mpoa:Short read (missed %d bytes) from userland\\n\",\n\t\t\tbytes_left);\n\t\treturn -EFAULT;\n\t}\n\tipaddr = ioc_data.ipaddr;\n\tif (ioc_data.dev_num < 0 || ioc_data.dev_num >= MAX_LEC_ITF)\n\t\treturn -EINVAL;\n\n\tmpc = find_mpc_by_itfnum(ioc_data.dev_num);\n\tif (mpc == NULL)\n\t\treturn -EINVAL;\n\n\tif (ioc_data.type == MPC_SOCKET_INGRESS) {\n\t\tin_entry = mpc->in_ops->get(ipaddr, mpc);\n\t\tif (in_entry == NULL ||\n\t\t    in_entry->entry_state < INGRESS_RESOLVED) {\n\t\t\tpr_info(\"(%s) did not find RESOLVED entry from ingress cache\\n\",\n\t\t\t\tmpc->dev->name);\n\t\t\tif (in_entry != NULL)\n\t\t\t\tmpc->in_ops->put(in_entry);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpr_info(\"(%s) attaching ingress SVC, entry = %pI4\\n\",\n\t\t\tmpc->dev->name, &in_entry->ctrl_info.in_dst_ip);\n\t\tin_entry->shortcut = vcc;\n\t\tmpc->in_ops->put(in_entry);\n\t} else {\n\t\tpr_info(\"(%s) attaching egress SVC\\n\", mpc->dev->name);\n\t}\n\n\tvcc->proto_data = mpc->dev;\n\tvcc->push = mpc_push;\n\n\treturn 0;\n}\n\n \nstatic void mpc_vcc_close(struct atm_vcc *vcc, struct net_device *dev)\n{\n\tstruct mpoa_client *mpc;\n\tin_cache_entry *in_entry;\n\teg_cache_entry *eg_entry;\n\n\tmpc = find_mpc_by_lec(dev);\n\tif (mpc == NULL) {\n\t\tpr_info(\"(%s) close for unknown MPC\\n\", dev->name);\n\t\treturn;\n\t}\n\n\tdprintk(\"(%s)\\n\", dev->name);\n\tin_entry = mpc->in_ops->get_by_vcc(vcc, mpc);\n\tif (in_entry) {\n\t\tdprintk(\"(%s) ingress SVC closed ip = %pI4\\n\",\n\t\t\tmpc->dev->name, &in_entry->ctrl_info.in_dst_ip);\n\t\tin_entry->shortcut = NULL;\n\t\tmpc->in_ops->put(in_entry);\n\t}\n\teg_entry = mpc->eg_ops->get_by_vcc(vcc, mpc);\n\tif (eg_entry) {\n\t\tdprintk(\"(%s) egress SVC closed\\n\", mpc->dev->name);\n\t\teg_entry->shortcut = NULL;\n\t\tmpc->eg_ops->put(eg_entry);\n\t}\n\n\tif (in_entry == NULL && eg_entry == NULL)\n\t\tdprintk(\"(%s) unused vcc closed\\n\", dev->name);\n}\n\nstatic void mpc_push(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tstruct net_device *dev = (struct net_device *)vcc->proto_data;\n\tstruct sk_buff *new_skb;\n\teg_cache_entry *eg;\n\tstruct mpoa_client *mpc;\n\t__be32 tag;\n\tchar *tmp;\n\n\tddprintk(\"(%s)\\n\", dev->name);\n\tif (skb == NULL) {\n\t\tdprintk(\"(%s) null skb, closing VCC\\n\", dev->name);\n\t\tmpc_vcc_close(vcc, dev);\n\t\treturn;\n\t}\n\n\tskb->dev = dev;\n\tif (memcmp(skb->data, &llc_snap_mpoa_ctrl,\n\t\t   sizeof(struct llc_snap_hdr)) == 0) {\n\t\tstruct sock *sk = sk_atm(vcc);\n\n\t\tdprintk(\"(%s) control packet arrived\\n\", dev->name);\n\t\t \n\t\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tsk->sk_data_ready(sk);\n\t\treturn;\n\t}\n\n\t \n\tatm_return(vcc, skb->truesize);\n\n\tmpc = find_mpc_by_lec(dev);\n\tif (mpc == NULL) {\n\t\tpr_info(\"(%s) unknown MPC\\n\", dev->name);\n\t\treturn;\n\t}\n\n\tif (memcmp(skb->data, &llc_snap_mpoa_data_tagged,\n\t\t   sizeof(struct llc_snap_hdr)) == 0) {  \n\t\tddprintk(\"(%s) tagged data packet arrived\\n\", dev->name);\n\n\t} else if (memcmp(skb->data, &llc_snap_mpoa_data,\n\t\t\t  sizeof(struct llc_snap_hdr)) == 0) {  \n\t\tpr_info(\"(%s) Unsupported non-tagged data packet arrived.  Purging\\n\",\n\t\t\tdev->name);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t} else {\n\t\tpr_info(\"(%s) garbage arrived, purging\\n\", dev->name);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\ttmp = skb->data + sizeof(struct llc_snap_hdr);\n\ttag = *(__be32 *)tmp;\n\n\teg = mpc->eg_ops->get_by_tag(tag, mpc);\n\tif (eg == NULL) {\n\t\tpr_info(\"mpoa: (%s) Didn't find egress cache entry, tag = %u\\n\",\n\t\t\tdev->name, tag);\n\t\tpurge_egress_shortcut(vcc, NULL);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (eg->shortcut == NULL) {\n\t\teg->shortcut = vcc;\n\t\tpr_info(\"(%s) egress SVC in use\\n\", dev->name);\n\t}\n\n\tskb_pull(skb, sizeof(struct llc_snap_hdr) + sizeof(tag));\n\t\t\t\t\t \n\tnew_skb = skb_realloc_headroom(skb, eg->ctrl_info.DH_length);\n\t\t\t\t\t \n\tdev_kfree_skb_any(skb);\n\tif (new_skb == NULL) {\n\t\tmpc->eg_ops->put(eg);\n\t\treturn;\n\t}\n\tskb_push(new_skb, eg->ctrl_info.DH_length);      \n\tskb_copy_to_linear_data(new_skb, eg->ctrl_info.DLL_header,\n\t\t\t\teg->ctrl_info.DH_length);\n\tnew_skb->protocol = eth_type_trans(new_skb, dev);\n\tskb_reset_network_header(new_skb);\n\n\teg->latest_ip_addr = ip_hdr(new_skb)->saddr;\n\teg->packets_rcvd++;\n\tmpc->eg_ops->put(eg);\n\n\tmemset(ATM_SKB(new_skb), 0, sizeof(struct atm_skb_data));\n\tnetif_rx(new_skb);\n}\n\nstatic const struct atmdev_ops mpc_ops = {  \n\t.close\t= mpoad_close,\n\t.send\t= msg_from_mpoad\n};\n\nstatic struct atm_dev mpc_dev = {\n\t.ops\t= &mpc_ops,\n\t.type\t= \"mpc\",\n\t.number\t= 42,\n\t.lock\t= __SPIN_LOCK_UNLOCKED(mpc_dev.lock)\n\t \n};\n\nstatic int atm_mpoa_mpoad_attach(struct atm_vcc *vcc, int arg)\n{\n\tstruct mpoa_client *mpc;\n\tstruct lec_priv *priv;\n\tint err;\n\n\tif (mpcs == NULL) {\n\t\tmpc_timer_refresh();\n\n\t\t \n\t\terr = register_netdevice_notifier(&mpoa_notifier);\n\t\tif (err < 0) {\n\t\t\tdel_timer(&mpc_timer);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tmpc = find_mpc_by_itfnum(arg);\n\tif (mpc == NULL) {\n\t\tdprintk(\"allocating new mpc for itf %d\\n\", arg);\n\t\tmpc = alloc_mpc();\n\t\tif (mpc == NULL)\n\t\t\treturn -ENOMEM;\n\t\tmpc->dev_num = arg;\n\t\tmpc->dev = find_lec_by_itfnum(arg);\n\t\t\t\t\t \n\t}\n\tif (mpc->mpoad_vcc) {\n\t\tpr_info(\"mpoad is already present for itf %d\\n\", arg);\n\t\treturn -EADDRINUSE;\n\t}\n\n\tif (mpc->dev) {  \n\t\tpriv = netdev_priv(mpc->dev);\n\t\tif (priv->lane_version < 2) {\n\t\t\tdev_put(mpc->dev);\n\t\t\tmpc->dev = NULL;\n\t\t} else\n\t\t\tpriv->lane2_ops->associate_indicator = lane2_assoc_ind;\n\t}\n\n\tmpc->mpoad_vcc = vcc;\n\tvcc->dev = &mpc_dev;\n\tvcc_insert_socket(sk_atm(vcc));\n\tset_bit(ATM_VF_META, &vcc->flags);\n\tset_bit(ATM_VF_READY, &vcc->flags);\n\n\tif (mpc->dev) {\n\t\tchar empty[ATM_ESA_LEN];\n\t\tmemset(empty, 0, ATM_ESA_LEN);\n\n\t\tstart_mpc(mpc, mpc->dev);\n\t\t \n\t\tif (memcmp(mpc->mps_ctrl_addr, empty, ATM_ESA_LEN) != 0)\n\t\t\tsend_set_mps_ctrl_addr(mpc->mps_ctrl_addr, mpc);\n\t}\n\n\t__module_get(THIS_MODULE);\n\treturn arg;\n}\n\nstatic void send_set_mps_ctrl_addr(const char *addr, struct mpoa_client *mpc)\n{\n\tstruct k_message mesg;\n\n\tmemcpy(mpc->mps_ctrl_addr, addr, ATM_ESA_LEN);\n\n\tmesg.type = SET_MPS_CTRL_ADDR;\n\tmemcpy(mesg.MPS_ctrl, addr, ATM_ESA_LEN);\n\tmsg_to_mpoad(&mesg, mpc);\n}\n\nstatic void mpoad_close(struct atm_vcc *vcc)\n{\n\tstruct mpoa_client *mpc;\n\tstruct sk_buff *skb;\n\n\tmpc = find_mpc_by_vcc(vcc);\n\tif (mpc == NULL) {\n\t\tpr_info(\"did not find MPC\\n\");\n\t\treturn;\n\t}\n\tif (!mpc->mpoad_vcc) {\n\t\tpr_info(\"close for non-present mpoad\\n\");\n\t\treturn;\n\t}\n\n\tmpc->mpoad_vcc = NULL;\n\tif (mpc->dev) {\n\t\tstruct lec_priv *priv = netdev_priv(mpc->dev);\n\t\tpriv->lane2_ops->associate_indicator = NULL;\n\t\tstop_mpc(mpc);\n\t\tdev_put(mpc->dev);\n\t}\n\n\tmpc->in_ops->destroy_cache(mpc);\n\tmpc->eg_ops->destroy_cache(mpc);\n\n\twhile ((skb = skb_dequeue(&sk_atm(vcc)->sk_receive_queue))) {\n\t\tatm_return(vcc, skb->truesize);\n\t\tkfree_skb(skb);\n\t}\n\n\tpr_info(\"(%s) going down\\n\",\n\t\t(mpc->dev) ? mpc->dev->name : \"<unknown>\");\n\tmodule_put(THIS_MODULE);\n}\n\n \nstatic int msg_from_mpoad(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\n\tstruct mpoa_client *mpc = find_mpc_by_vcc(vcc);\n\tstruct k_message *mesg = (struct k_message *)skb->data;\n\tWARN_ON(refcount_sub_and_test(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc));\n\n\tif (mpc == NULL) {\n\t\tpr_info(\"no mpc found\\n\");\n\t\treturn 0;\n\t}\n\tdprintk(\"(%s)\", mpc->dev ? mpc->dev->name : \"<unknown>\");\n\tswitch (mesg->type) {\n\tcase MPOA_RES_REPLY_RCVD:\n\t\tdprintk_cont(\"mpoa_res_reply_rcvd\\n\");\n\t\tMPOA_res_reply_rcvd(mesg, mpc);\n\t\tbreak;\n\tcase MPOA_TRIGGER_RCVD:\n\t\tdprintk_cont(\"mpoa_trigger_rcvd\\n\");\n\t\tMPOA_trigger_rcvd(mesg, mpc);\n\t\tbreak;\n\tcase INGRESS_PURGE_RCVD:\n\t\tdprintk_cont(\"nhrp_purge_rcvd\\n\");\n\t\tingress_purge_rcvd(mesg, mpc);\n\t\tbreak;\n\tcase EGRESS_PURGE_RCVD:\n\t\tdprintk_cont(\"egress_purge_reply_rcvd\\n\");\n\t\tegress_purge_rcvd(mesg, mpc);\n\t\tbreak;\n\tcase MPS_DEATH:\n\t\tdprintk_cont(\"mps_death\\n\");\n\t\tmps_death(mesg, mpc);\n\t\tbreak;\n\tcase CACHE_IMPOS_RCVD:\n\t\tdprintk_cont(\"cache_impos_rcvd\\n\");\n\t\tMPOA_cache_impos_rcvd(mesg, mpc);\n\t\tbreak;\n\tcase SET_MPC_CTRL_ADDR:\n\t\tdprintk_cont(\"set_mpc_ctrl_addr\\n\");\n\t\tset_mpc_ctrl_addr_rcvd(mesg, mpc);\n\t\tbreak;\n\tcase SET_MPS_MAC_ADDR:\n\t\tdprintk_cont(\"set_mps_mac_addr\\n\");\n\t\tset_mps_mac_addr_rcvd(mesg, mpc);\n\t\tbreak;\n\tcase CLEAN_UP_AND_EXIT:\n\t\tdprintk_cont(\"clean_up_and_exit\\n\");\n\t\tclean_up(mesg, mpc, DIE);\n\t\tbreak;\n\tcase RELOAD:\n\t\tdprintk_cont(\"reload\\n\");\n\t\tclean_up(mesg, mpc, RELOAD);\n\t\tbreak;\n\tcase SET_MPC_PARAMS:\n\t\tdprintk_cont(\"set_mpc_params\\n\");\n\t\tmpc->parameters = mesg->content.params;\n\t\tbreak;\n\tdefault:\n\t\tdprintk_cont(\"unknown message %d\\n\", mesg->type);\n\t\tbreak;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\n \nint msg_to_mpoad(struct k_message *mesg, struct mpoa_client *mpc)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\n\tif (mpc == NULL || !mpc->mpoad_vcc) {\n\t\tpr_info(\"mesg %d to a non-existent mpoad\\n\", mesg->type);\n\t\treturn -ENXIO;\n\t}\n\n\tskb = alloc_skb(sizeof(struct k_message), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\tskb_put(skb, sizeof(struct k_message));\n\tskb_copy_to_linear_data(skb, mesg, sizeof(*mesg));\n\tatm_force_charge(mpc->mpoad_vcc, skb->truesize);\n\n\tsk = sk_atm(mpc->mpoad_vcc);\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_data_ready(sk);\n\n\treturn 0;\n}\n\nstatic int mpoa_event_listener(struct notifier_block *mpoa_notifier,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct mpoa_client *mpc;\n\tstruct lec_priv *priv;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (strncmp(dev->name, \"lec\", 3))\n\t\treturn NOTIFY_DONE;  \n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:        \n\t\tpriv = netdev_priv(dev);\n\t\tif (priv->lane_version < 2)\n\t\t\tbreak;\n\t\tpriv->lane2_ops->associate_indicator = lane2_assoc_ind;\n\t\tmpc = find_mpc_by_itfnum(priv->itfnum);\n\t\tif (mpc == NULL) {\n\t\t\tdprintk(\"allocating new mpc for %s\\n\", dev->name);\n\t\t\tmpc = alloc_mpc();\n\t\t\tif (mpc == NULL) {\n\t\t\t\tpr_info(\"no new mpc\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmpc->dev_num = priv->itfnum;\n\t\tmpc->dev = dev;\n\t\tdev_hold(dev);\n\t\tdprintk(\"(%s) was initialized\\n\", dev->name);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t \n\t\tmpc = find_mpc_by_lec(dev);\n\t\tif (mpc == NULL)\n\t\t\tbreak;\n\t\tdprintk(\"device (%s) was deallocated\\n\", dev->name);\n\t\tstop_mpc(mpc);\n\t\tdev_put(mpc->dev);\n\t\tmpc->dev = NULL;\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\t \n\t\tmpc = find_mpc_by_lec(dev);\n\t\tif (mpc == NULL)\n\t\t\tbreak;\n\t\tif (mpc->mpoad_vcc != NULL)\n\t\t\tstart_mpc(mpc, dev);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\t \n\t\t \n\t\tmpc = find_mpc_by_lec(dev);\n\t\tif (mpc == NULL)\n\t\t\tbreak;\n\t\tif (mpc->mpoad_vcc != NULL)\n\t\t\tstop_mpc(mpc);\n\t\tbreak;\n\tcase NETDEV_REBOOT:\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_CHANGEMTU:\n\tcase NETDEV_CHANGEADDR:\n\tcase NETDEV_GOING_DOWN:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \n\n\nstatic void MPOA_trigger_rcvd(struct k_message *msg, struct mpoa_client *mpc)\n{\n\t__be32 dst_ip = msg->content.in_info.in_dst_ip;\n\tin_cache_entry *entry;\n\n\tentry = mpc->in_ops->get(dst_ip, mpc);\n\tif (entry == NULL) {\n\t\tentry = mpc->in_ops->add_entry(dst_ip, mpc);\n\t\tentry->entry_state = INGRESS_RESOLVING;\n\t\tmsg->type = SND_MPOA_RES_RQST;\n\t\tmsg->content.in_info = entry->ctrl_info;\n\t\tmsg_to_mpoad(msg, mpc);\n\t\tentry->reply_wait = ktime_get_seconds();\n\t\tmpc->in_ops->put(entry);\n\t\treturn;\n\t}\n\n\tif (entry->entry_state == INGRESS_INVALID) {\n\t\tentry->entry_state = INGRESS_RESOLVING;\n\t\tmsg->type = SND_MPOA_RES_RQST;\n\t\tmsg->content.in_info = entry->ctrl_info;\n\t\tmsg_to_mpoad(msg, mpc);\n\t\tentry->reply_wait = ktime_get_seconds();\n\t\tmpc->in_ops->put(entry);\n\t\treturn;\n\t}\n\n\tpr_info(\"(%s) entry already in resolving state\\n\",\n\t\t(mpc->dev) ? mpc->dev->name : \"<unknown>\");\n\tmpc->in_ops->put(entry);\n}\n\n \nstatic void check_qos_and_open_shortcut(struct k_message *msg,\n\t\t\t\t\tstruct mpoa_client *client,\n\t\t\t\t\tin_cache_entry *entry)\n{\n\t__be32 dst_ip = msg->content.in_info.in_dst_ip;\n\tstruct atm_mpoa_qos *qos = atm_mpoa_search_qos(dst_ip);\n\teg_cache_entry *eg_entry = client->eg_ops->get_by_src_ip(dst_ip, client);\n\n\tif (eg_entry && eg_entry->shortcut) {\n\t\tif (eg_entry->shortcut->qos.txtp.traffic_class &\n\t\t    msg->qos.txtp.traffic_class &\n\t\t    (qos ? qos->qos.txtp.traffic_class : ATM_UBR | ATM_CBR)) {\n\t\t\tif (eg_entry->shortcut->qos.txtp.traffic_class == ATM_UBR)\n\t\t\t\tentry->shortcut = eg_entry->shortcut;\n\t\t\telse if (eg_entry->shortcut->qos.txtp.max_pcr > 0)\n\t\t\t\tentry->shortcut = eg_entry->shortcut;\n\t\t}\n\t\tif (entry->shortcut) {\n\t\t\tdprintk(\"(%s) using egress SVC to reach %pI4\\n\",\n\t\t\t\tclient->dev->name, &dst_ip);\n\t\t\tclient->eg_ops->put(eg_entry);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (eg_entry != NULL)\n\t\tclient->eg_ops->put(eg_entry);\n\n\t \n\tmsg->type = OPEN_INGRESS_SVC;\n\tif (qos &&\n\t    (qos->qos.txtp.traffic_class == msg->qos.txtp.traffic_class)) {\n\t\tmsg->qos = qos->qos;\n\t\tpr_info(\"(%s) trying to get a CBR shortcut\\n\",\n\t\t\tclient->dev->name);\n\t} else\n\t\tmemset(&msg->qos, 0, sizeof(struct atm_qos));\n\tmsg_to_mpoad(msg, client);\n}\n\nstatic void MPOA_res_reply_rcvd(struct k_message *msg, struct mpoa_client *mpc)\n{\n\t__be32 dst_ip = msg->content.in_info.in_dst_ip;\n\tin_cache_entry *entry = mpc->in_ops->get(dst_ip, mpc);\n\n\tdprintk(\"(%s) ip %pI4\\n\",\n\t\tmpc->dev->name, &dst_ip);\n\tddprintk(\"(%s) entry = %p\",\n\t\t mpc->dev->name, entry);\n\tif (entry == NULL) {\n\t\tpr_info(\"(%s) ARGH, received res. reply for an entry that doesn't exist.\\n\",\n\t\t\tmpc->dev->name);\n\t\treturn;\n\t}\n\tddprintk_cont(\" entry_state = %d \", entry->entry_state);\n\n\tif (entry->entry_state == INGRESS_RESOLVED) {\n\t\tpr_info(\"(%s) RESOLVED entry!\\n\", mpc->dev->name);\n\t\tmpc->in_ops->put(entry);\n\t\treturn;\n\t}\n\n\tentry->ctrl_info = msg->content.in_info;\n\tentry->time = ktime_get_seconds();\n\t \n\tentry->reply_wait = ktime_get_seconds();\n\tentry->refresh_time = 0;\n\tddprintk_cont(\"entry->shortcut = %p\\n\", entry->shortcut);\n\n\tif (entry->entry_state == INGRESS_RESOLVING &&\n\t    entry->shortcut != NULL) {\n\t\tentry->entry_state = INGRESS_RESOLVED;\n\t\tmpc->in_ops->put(entry);\n\t\treturn;  \n\t}\n\n\tif (entry->shortcut != NULL) {\n\t\tpr_info(\"(%s) entry->shortcut != NULL, impossible!\\n\",\n\t\t\tmpc->dev->name);\n\t\tmpc->in_ops->put(entry);\n\t\treturn;\n\t}\n\n\tcheck_qos_and_open_shortcut(msg, mpc, entry);\n\tentry->entry_state = INGRESS_RESOLVED;\n\tmpc->in_ops->put(entry);\n\n\treturn;\n\n}\n\nstatic void ingress_purge_rcvd(struct k_message *msg, struct mpoa_client *mpc)\n{\n\t__be32 dst_ip = msg->content.in_info.in_dst_ip;\n\t__be32 mask = msg->ip_mask;\n\tin_cache_entry *entry = mpc->in_ops->get_with_mask(dst_ip, mpc, mask);\n\n\tif (entry == NULL) {\n\t\tpr_info(\"(%s) purge for a non-existing entry, ip = %pI4\\n\",\n\t\t\tmpc->dev->name, &dst_ip);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tdprintk(\"(%s) removing an ingress entry, ip = %pI4\\n\",\n\t\t\tmpc->dev->name, &dst_ip);\n\t\twrite_lock_bh(&mpc->ingress_lock);\n\t\tmpc->in_ops->remove_entry(entry, mpc);\n\t\twrite_unlock_bh(&mpc->ingress_lock);\n\t\tmpc->in_ops->put(entry);\n\t\tentry = mpc->in_ops->get_with_mask(dst_ip, mpc, mask);\n\t} while (entry != NULL);\n}\n\nstatic void egress_purge_rcvd(struct k_message *msg, struct mpoa_client *mpc)\n{\n\t__be32 cache_id = msg->content.eg_info.cache_id;\n\teg_cache_entry *entry = mpc->eg_ops->get_by_cache_id(cache_id, mpc);\n\n\tif (entry == NULL) {\n\t\tdprintk(\"(%s) purge for a non-existing entry\\n\",\n\t\t\tmpc->dev->name);\n\t\treturn;\n\t}\n\n\twrite_lock_irq(&mpc->egress_lock);\n\tmpc->eg_ops->remove_entry(entry, mpc);\n\twrite_unlock_irq(&mpc->egress_lock);\n\n\tmpc->eg_ops->put(entry);\n}\n\nstatic void purge_egress_shortcut(struct atm_vcc *vcc, eg_cache_entry *entry)\n{\n\tstruct sock *sk;\n\tstruct k_message *purge_msg;\n\tstruct sk_buff *skb;\n\n\tdprintk(\"entering\\n\");\n\tif (vcc == NULL) {\n\t\tpr_info(\"vcc == NULL\\n\");\n\t\treturn;\n\t}\n\n\tskb = alloc_skb(sizeof(struct k_message), GFP_ATOMIC);\n\tif (skb == NULL) {\n\t\tpr_info(\"out of memory\\n\");\n\t\treturn;\n\t}\n\n\tskb_put(skb, sizeof(struct k_message));\n\tmemset(skb->data, 0, sizeof(struct k_message));\n\tpurge_msg = (struct k_message *)skb->data;\n\tpurge_msg->type = DATA_PLANE_PURGE;\n\tif (entry != NULL)\n\t\tpurge_msg->content.eg_info = entry->ctrl_info;\n\n\tatm_force_charge(vcc, skb->truesize);\n\n\tsk = sk_atm(vcc);\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_data_ready(sk);\n\tdprintk(\"exiting\\n\");\n}\n\n \nstatic void mps_death(struct k_message *msg, struct mpoa_client *mpc)\n{\n\teg_cache_entry *entry;\n\n\tdprintk(\"(%s)\\n\", mpc->dev->name);\n\n\tif (memcmp(msg->MPS_ctrl, mpc->mps_ctrl_addr, ATM_ESA_LEN)) {\n\t\tpr_info(\"(%s) wrong MPS\\n\", mpc->dev->name);\n\t\treturn;\n\t}\n\n\t \n\tread_lock_irq(&mpc->egress_lock);\n\tentry = mpc->eg_cache;\n\twhile (entry != NULL) {\n\t\tpurge_egress_shortcut(entry->shortcut, entry);\n\t\tentry = entry->next;\n\t}\n\tread_unlock_irq(&mpc->egress_lock);\n\n\tmpc->in_ops->destroy_cache(mpc);\n\tmpc->eg_ops->destroy_cache(mpc);\n}\n\nstatic void MPOA_cache_impos_rcvd(struct k_message *msg,\n\t\t\t\t  struct mpoa_client *mpc)\n{\n\tuint16_t holding_time;\n\teg_cache_entry *entry = mpc->eg_ops->get_by_cache_id(msg->content.eg_info.cache_id, mpc);\n\n\tholding_time = msg->content.eg_info.holding_time;\n\tdprintk(\"(%s) entry = %p, holding_time = %u\\n\",\n\t\tmpc->dev->name, entry, holding_time);\n\tif (entry == NULL && holding_time) {\n\t\tentry = mpc->eg_ops->add_entry(msg, mpc);\n\t\tmpc->eg_ops->put(entry);\n\t\treturn;\n\t}\n\tif (holding_time) {\n\t\tmpc->eg_ops->update(entry, holding_time);\n\t\treturn;\n\t}\n\n\twrite_lock_irq(&mpc->egress_lock);\n\tmpc->eg_ops->remove_entry(entry, mpc);\n\twrite_unlock_irq(&mpc->egress_lock);\n\n\tmpc->eg_ops->put(entry);\n}\n\nstatic void set_mpc_ctrl_addr_rcvd(struct k_message *mesg,\n\t\t\t\t   struct mpoa_client *mpc)\n{\n\tstruct lec_priv *priv;\n\tint i, retval ;\n\n\tuint8_t tlv[4 + 1 + 1 + 1 + ATM_ESA_LEN];\n\n\ttlv[0] = 00; tlv[1] = 0xa0; tlv[2] = 0x3e; tlv[3] = 0x2a;  \n\ttlv[4] = 1 + 1 + ATM_ESA_LEN;   \n\ttlv[5] = 0x02;                  \n\ttlv[6] = 0x00;                  \n\n\tmemcpy(&tlv[7], mesg->MPS_ctrl, ATM_ESA_LEN);  \n\tmemcpy(mpc->our_ctrl_addr, mesg->MPS_ctrl, ATM_ESA_LEN);\n\n\tdprintk(\"(%s) setting MPC ctrl ATM address to\",\n\t\tmpc->dev ? mpc->dev->name : \"<unknown>\");\n\tfor (i = 7; i < sizeof(tlv); i++)\n\t\tdprintk_cont(\" %02x\", tlv[i]);\n\tdprintk_cont(\"\\n\");\n\n\tif (mpc->dev) {\n\t\tpriv = netdev_priv(mpc->dev);\n\t\tretval = priv->lane2_ops->associate_req(mpc->dev,\n\t\t\t\t\t\t\tmpc->dev->dev_addr,\n\t\t\t\t\t\t\ttlv, sizeof(tlv));\n\t\tif (retval == 0)\n\t\t\tpr_info(\"(%s) MPOA device type TLV association failed\\n\",\n\t\t\t\tmpc->dev->name);\n\t\tretval = priv->lane2_ops->resolve(mpc->dev, NULL, 1, NULL, NULL);\n\t\tif (retval < 0)\n\t\t\tpr_info(\"(%s) targetless LE_ARP request failed\\n\",\n\t\t\t\tmpc->dev->name);\n\t}\n}\n\nstatic void set_mps_mac_addr_rcvd(struct k_message *msg,\n\t\t\t\t  struct mpoa_client *client)\n{\n\n\tif (client->number_of_mps_macs)\n\t\tkfree(client->mps_macs);\n\tclient->number_of_mps_macs = 0;\n\tclient->mps_macs = kmemdup(msg->MPS_ctrl, ETH_ALEN, GFP_KERNEL);\n\tif (client->mps_macs == NULL) {\n\t\tpr_info(\"out of memory\\n\");\n\t\treturn;\n\t}\n\tclient->number_of_mps_macs = 1;\n}\n\n \nstatic void clean_up(struct k_message *msg, struct mpoa_client *mpc, int action)\n{\n\n\teg_cache_entry *entry;\n\tmsg->type = SND_EGRESS_PURGE;\n\n\n\t \n\tread_lock_irq(&mpc->egress_lock);\n\tentry = mpc->eg_cache;\n\twhile (entry != NULL) {\n\t\tmsg->content.eg_info = entry->ctrl_info;\n\t\tdprintk(\"cache_id %u\\n\", entry->ctrl_info.cache_id);\n\t\tmsg_to_mpoad(msg, mpc);\n\t\tentry = entry->next;\n\t}\n\tread_unlock_irq(&mpc->egress_lock);\n\n\tmsg->type = action;\n\tmsg_to_mpoad(msg, mpc);\n}\n\nstatic unsigned long checking_time;\n\nstatic void mpc_timer_refresh(void)\n{\n\tmpc_timer.expires = jiffies + (MPC_P2 * HZ);\n\tchecking_time = mpc_timer.expires;\n\tadd_timer(&mpc_timer);\n}\n\nstatic void mpc_cache_check(struct timer_list *unused)\n{\n\tstruct mpoa_client *mpc = mpcs;\n\tstatic unsigned long previous_resolving_check_time;\n\tstatic unsigned long previous_refresh_time;\n\n\twhile (mpc != NULL) {\n\t\tmpc->in_ops->clear_count(mpc);\n\t\tmpc->eg_ops->clear_expired(mpc);\n\t\tif (checking_time - previous_resolving_check_time >\n\t\t    mpc->parameters.mpc_p4 * HZ) {\n\t\t\tmpc->in_ops->check_resolving(mpc);\n\t\t\tprevious_resolving_check_time = checking_time;\n\t\t}\n\t\tif (checking_time - previous_refresh_time >\n\t\t    mpc->parameters.mpc_p5 * HZ) {\n\t\t\tmpc->in_ops->refresh(mpc);\n\t\t\tprevious_refresh_time = checking_time;\n\t\t}\n\t\tmpc = mpc->next;\n\t}\n\tmpc_timer_refresh();\n}\n\nstatic int atm_mpoa_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tint err = 0;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\n\tif (cmd != ATMMPC_CTRL && cmd != ATMMPC_DATA)\n\t\treturn -ENOIOCTLCMD;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase ATMMPC_CTRL:\n\t\terr = atm_mpoa_mpoad_attach(vcc, (int)arg);\n\t\tif (err >= 0)\n\t\t\tsock->state = SS_CONNECTED;\n\t\tbreak;\n\tcase ATMMPC_DATA:\n\t\terr = atm_mpoa_vcc_attach(vcc, (void __user *)arg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic struct atm_ioctl atm_ioctl_ops = {\n\t.owner\t= THIS_MODULE,\n\t.ioctl\t= atm_mpoa_ioctl,\n};\n\nstatic __init int atm_mpoa_init(void)\n{\n\tregister_atm_ioctl(&atm_ioctl_ops);\n\n\tif (mpc_proc_init() != 0)\n\t\tpr_info(\"failed to initialize /proc/mpoa\\n\");\n\n\tpr_info(\"mpc.c: initialized\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit atm_mpoa_cleanup(void)\n{\n\tstruct mpoa_client *mpc, *tmp;\n\tstruct atm_mpoa_qos *qos, *nextqos;\n\tstruct lec_priv *priv;\n\n\tmpc_proc_clean();\n\n\tdel_timer_sync(&mpc_timer);\n\tunregister_netdevice_notifier(&mpoa_notifier);\n\tderegister_atm_ioctl(&atm_ioctl_ops);\n\n\tmpc = mpcs;\n\tmpcs = NULL;\n\twhile (mpc != NULL) {\n\t\ttmp = mpc->next;\n\t\tif (mpc->dev != NULL) {\n\t\t\tstop_mpc(mpc);\n\t\t\tpriv = netdev_priv(mpc->dev);\n\t\t\tif (priv->lane2_ops != NULL)\n\t\t\t\tpriv->lane2_ops->associate_indicator = NULL;\n\t\t}\n\t\tddprintk(\"about to clear caches\\n\");\n\t\tmpc->in_ops->destroy_cache(mpc);\n\t\tmpc->eg_ops->destroy_cache(mpc);\n\t\tddprintk(\"caches cleared\\n\");\n\t\tkfree(mpc->mps_macs);\n\t\tmemset(mpc, 0, sizeof(struct mpoa_client));\n\t\tddprintk(\"about to kfree %p\\n\", mpc);\n\t\tkfree(mpc);\n\t\tddprintk(\"next mpc is at %p\\n\", tmp);\n\t\tmpc = tmp;\n\t}\n\n\tqos = qos_head;\n\tqos_head = NULL;\n\twhile (qos != NULL) {\n\t\tnextqos = qos->next;\n\t\tdprintk(\"freeing qos entry %p\\n\", qos);\n\t\tkfree(qos);\n\t\tqos = nextqos;\n\t}\n}\n\nmodule_init(atm_mpoa_init);\nmodule_exit(atm_mpoa_cleanup);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}