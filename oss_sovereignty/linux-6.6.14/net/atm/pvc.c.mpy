{
  "module_name": "pvc.c",
  "hash_id": "66b1dbc5040c8d5919d929367951bd574ddf026a6ba528ad4f5063321a76073a",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/pvc.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/net.h>\t\t \n#include <linux/atm.h>\t\t \n#include <linux/atmdev.h>\t \n#include <linux/errno.h>\t \n#include <linux/kernel.h>\t \n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/bitops.h>\n#include <linux/export.h>\n#include <net/sock.h>\t\t \n\n#include \"resources.h\"\t\t \n#include \"common.h\"\t\t \n\n\nstatic int pvc_shutdown(struct socket *sock, int how)\n{\n\treturn 0;\n}\n\nstatic int pvc_bind(struct socket *sock, struct sockaddr *sockaddr,\n\t\t    int sockaddr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc;\n\tint error;\n\n\tif (sockaddr_len != sizeof(struct sockaddr_atmpvc))\n\t\treturn -EINVAL;\n\taddr = (struct sockaddr_atmpvc *)sockaddr;\n\tif (addr->sap_family != AF_ATMPVC)\n\t\treturn -EAFNOSUPPORT;\n\tlock_sock(sk);\n\tvcc = ATM_SD(sock);\n\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags)) {\n\t\terror = -EBADFD;\n\t\tgoto out;\n\t}\n\tif (test_bit(ATM_VF_PARTIAL, &vcc->flags)) {\n\t\tif (vcc->vpi != ATM_VPI_UNSPEC)\n\t\t\taddr->sap_addr.vpi = vcc->vpi;\n\t\tif (vcc->vci != ATM_VCI_UNSPEC)\n\t\t\taddr->sap_addr.vci = vcc->vci;\n\t}\n\terror = vcc_connect(sock, addr->sap_addr.itf, addr->sap_addr.vpi,\n\t\t\t    addr->sap_addr.vci);\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int pvc_connect(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int sockaddr_len, int flags)\n{\n\treturn pvc_bind(sock, sockaddr, sockaddr_len);\n}\n\nstatic int pvc_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint error;\n\n\tlock_sock(sk);\n\terror = vcc_setsockopt(sock, level, optname, optval, optlen);\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int pvc_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint error;\n\n\tlock_sock(sk);\n\terror = vcc_getsockopt(sock, level, optname, optval, optlen);\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\treturn -ENOTCONN;\n\taddr = (struct sockaddr_atmpvc *)sockaddr;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sap_family = AF_ATMPVC;\n\taddr->sap_addr.itf = vcc->dev->number;\n\taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn sizeof(struct sockaddr_atmpvc);\n}\n\nstatic const struct proto_ops pvc_proto_ops = {\n\t.family =\tPF_ATMPVC,\n\t.owner =\tTHIS_MODULE,\n\n\t.release =\tvcc_release,\n\t.bind =\t\tpvc_bind,\n\t.connect =\tpvc_connect,\n\t.socketpair =\tsock_no_socketpair,\n\t.accept =\tsock_no_accept,\n\t.getname =\tpvc_getname,\n\t.poll =\t\tvcc_poll,\n\t.ioctl =\tvcc_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = vcc_compat_ioctl,\n#endif\n\t.gettstamp =\tsock_gettstamp,\n\t.listen =\tsock_no_listen,\n\t.shutdown =\tpvc_shutdown,\n\t.setsockopt =\tpvc_setsockopt,\n\t.getsockopt =\tpvc_getsockopt,\n\t.sendmsg =\tvcc_sendmsg,\n\t.recvmsg =\tvcc_recvmsg,\n\t.mmap =\t\tsock_no_mmap,\n};\n\n\nstatic int pvc_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tif (net != &init_net)\n\t\treturn -EAFNOSUPPORT;\n\n\tsock->ops = &pvc_proto_ops;\n\treturn vcc_create(net, sock, protocol, PF_ATMPVC, kern);\n}\n\nstatic const struct net_proto_family pvc_family_ops = {\n\t.family = PF_ATMPVC,\n\t.create = pvc_create,\n\t.owner = THIS_MODULE,\n};\n\n\n \n\n\nint __init atmpvc_init(void)\n{\n\treturn sock_register(&pvc_family_ops);\n}\n\nvoid atmpvc_exit(void)\n{\n\tsock_unregister(PF_ATMPVC);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}