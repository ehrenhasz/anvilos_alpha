{
  "module_name": "common.c",
  "hash_id": "63976513e0fecf6583d899ea7992108799bbe81036b10e0f11b6592b3d2f9295",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/common.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/net.h>\t\t \n#include <linux/atm.h>\t\t \n#include <linux/atmdev.h>\n#include <linux/socket.h>\t \n#include <linux/errno.h>\t \n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/time64.h>\t \n#include <linux/skbuff.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/sock.h>\t\t \n#include <linux/uaccess.h>\n#include <linux/poll.h>\n\n#include <linux/atomic.h>\n\n#include \"resources.h\"\t\t \n#include \"common.h\"\t\t \n#include \"protocols.h\"\t\t \n#include \"addr.h\"\t\t \n#include \"signaling.h\"\t\t \n\nstruct hlist_head vcc_hash[VCC_HTABLE_SIZE];\nEXPORT_SYMBOL(vcc_hash);\n\nDEFINE_RWLOCK(vcc_sklist_lock);\nEXPORT_SYMBOL(vcc_sklist_lock);\n\nstatic ATOMIC_NOTIFIER_HEAD(atm_dev_notify_chain);\n\nstatic void __vcc_insert_socket(struct sock *sk)\n{\n\tstruct atm_vcc *vcc = atm_sk(sk);\n\tstruct hlist_head *head = &vcc_hash[vcc->vci & (VCC_HTABLE_SIZE - 1)];\n\tsk->sk_hash = vcc->vci & (VCC_HTABLE_SIZE - 1);\n\tsk_add_node(sk, head);\n}\n\nvoid vcc_insert_socket(struct sock *sk)\n{\n\twrite_lock_irq(&vcc_sklist_lock);\n\t__vcc_insert_socket(sk);\n\twrite_unlock_irq(&vcc_sklist_lock);\n}\nEXPORT_SYMBOL(vcc_insert_socket);\n\nstatic void vcc_remove_socket(struct sock *sk)\n{\n\twrite_lock_irq(&vcc_sklist_lock);\n\tsk_del_node_init(sk);\n\twrite_unlock_irq(&vcc_sklist_lock);\n}\n\nstatic bool vcc_tx_ready(struct atm_vcc *vcc, unsigned int size)\n{\n\tstruct sock *sk = sk_atm(vcc);\n\n\tif (sk_wmem_alloc_get(sk) && !atm_may_send(vcc, size)) {\n\t\tpr_debug(\"Sorry: wmem_alloc = %d, size = %d, sndbuf = %d\\n\",\n\t\t\t sk_wmem_alloc_get(sk), size, sk->sk_sndbuf);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void vcc_sock_destruct(struct sock *sk)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc))\n\t\tprintk(KERN_DEBUG \"%s: rmem leakage (%d bytes) detected.\\n\",\n\t\t       __func__, atomic_read(&sk->sk_rmem_alloc));\n\n\tif (refcount_read(&sk->sk_wmem_alloc))\n\t\tprintk(KERN_DEBUG \"%s: wmem leakage (%d bytes) detected.\\n\",\n\t\t       __func__, refcount_read(&sk->sk_wmem_alloc));\n}\n\nstatic void vcc_def_wakeup(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (skwq_has_sleeper(wq))\n\t\twake_up(&wq->wait);\n\trcu_read_unlock();\n}\n\nstatic inline int vcc_writable(struct sock *sk)\n{\n\tstruct atm_vcc *vcc = atm_sk(sk);\n\n\treturn (vcc->qos.txtp.max_sdu +\n\t\trefcount_read(&sk->sk_wmem_alloc)) <= sk->sk_sndbuf;\n}\n\nstatic void vcc_write_space(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\trcu_read_lock();\n\n\tif (vcc_writable(sk)) {\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (skwq_has_sleeper(wq))\n\t\t\twake_up_interruptible(&wq->wait);\n\n\t\tsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void vcc_release_cb(struct sock *sk)\n{\n\tstruct atm_vcc *vcc = atm_sk(sk);\n\n\tif (vcc->release_cb)\n\t\tvcc->release_cb(vcc);\n}\n\nstatic struct proto vcc_proto = {\n\t.name\t  = \"VCC\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct atm_vcc),\n\t.release_cb = vcc_release_cb,\n};\n\nint vcc_create(struct net *net, struct socket *sock, int protocol, int family, int kern)\n{\n\tstruct sock *sk;\n\tstruct atm_vcc *vcc;\n\n\tsock->sk = NULL;\n\tif (sock->type == SOCK_STREAM)\n\t\treturn -EINVAL;\n\tsk = sk_alloc(net, family, GFP_KERNEL, &vcc_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_state_change = vcc_def_wakeup;\n\tsk->sk_write_space = vcc_write_space;\n\n\tvcc = atm_sk(sk);\n\tvcc->dev = NULL;\n\tmemset(&vcc->local, 0, sizeof(struct sockaddr_atmsvc));\n\tmemset(&vcc->remote, 0, sizeof(struct sockaddr_atmsvc));\n\tvcc->qos.txtp.max_sdu = 1 << 16;  \n\trefcount_set(&sk->sk_wmem_alloc, 1);\n\tatomic_set(&sk->sk_rmem_alloc, 0);\n\tvcc->push = NULL;\n\tvcc->pop = NULL;\n\tvcc->owner = NULL;\n\tvcc->push_oam = NULL;\n\tvcc->release_cb = NULL;\n\tvcc->vpi = vcc->vci = 0;  \n\tvcc->atm_options = vcc->aal_options = 0;\n\tsk->sk_destruct = vcc_sock_destruct;\n\treturn 0;\n}\n\nstatic void vcc_destroy_socket(struct sock *sk)\n{\n\tstruct atm_vcc *vcc = atm_sk(sk);\n\tstruct sk_buff *skb;\n\n\tset_bit(ATM_VF_CLOSE, &vcc->flags);\n\tclear_bit(ATM_VF_READY, &vcc->flags);\n\tif (vcc->dev && vcc->dev->ops->close)\n\t\tvcc->dev->ops->close(vcc);\n\tif (vcc->push)\n\t\tvcc->push(vcc, NULL);  \n\tmodule_put(vcc->owner);\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tatm_return(vcc, skb->truesize);\n\t\tkfree_skb(skb);\n\t}\n\n\tif (vcc->dev && vcc->dev->ops->owner) {\n\t\tmodule_put(vcc->dev->ops->owner);\n\t\tatm_dev_put(vcc->dev);\n\t}\n\n\tvcc_remove_socket(sk);\n}\n\nint vcc_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk) {\n\t\tlock_sock(sk);\n\t\tvcc_destroy_socket(sock->sk);\n\t\trelease_sock(sk);\n\t\tsock_put(sk);\n\t}\n\n\treturn 0;\n}\n\nvoid vcc_release_async(struct atm_vcc *vcc, int reply)\n{\n\tstruct sock *sk = sk_atm(vcc);\n\n\tset_bit(ATM_VF_CLOSE, &vcc->flags);\n\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\tsk->sk_err = -reply;\n\tclear_bit(ATM_VF_WAITING, &vcc->flags);\n\tsk->sk_state_change(sk);\n}\nEXPORT_SYMBOL(vcc_release_async);\n\nvoid vcc_process_recv_queue(struct atm_vcc *vcc)\n{\n\tstruct sk_buff_head queue, *rq;\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\n\t__skb_queue_head_init(&queue);\n\trq = &sk_atm(vcc)->sk_receive_queue;\n\n\tspin_lock_irqsave(&rq->lock, flags);\n\tskb_queue_splice_init(rq, &queue);\n\tspin_unlock_irqrestore(&rq->lock, flags);\n\n\tskb_queue_walk_safe(&queue, skb, tmp) {\n\t\t__skb_unlink(skb, &queue);\n\t\tvcc->push(vcc, skb);\n\t}\n}\nEXPORT_SYMBOL(vcc_process_recv_queue);\n\nvoid atm_dev_signal_change(struct atm_dev *dev, char signal)\n{\n\tpr_debug(\"%s signal=%d dev=%p number=%d dev->signal=%d\\n\",\n\t\t__func__, signal, dev, dev->number, dev->signal);\n\n\t \n\tWARN_ON(signal < ATM_PHY_SIG_LOST || signal > ATM_PHY_SIG_FOUND);\n\n\tif (dev->signal == signal)\n\t\treturn;  \n\n\tdev->signal = signal;\n\n\tatomic_notifier_call_chain(&atm_dev_notify_chain, signal, dev);\n}\nEXPORT_SYMBOL(atm_dev_signal_change);\n\nvoid atm_dev_release_vccs(struct atm_dev *dev)\n{\n\tint i;\n\n\twrite_lock_irq(&vcc_sklist_lock);\n\tfor (i = 0; i < VCC_HTABLE_SIZE; i++) {\n\t\tstruct hlist_head *head = &vcc_hash[i];\n\t\tstruct hlist_node *tmp;\n\t\tstruct sock *s;\n\t\tstruct atm_vcc *vcc;\n\n\t\tsk_for_each_safe(s, tmp, head) {\n\t\t\tvcc = atm_sk(s);\n\t\t\tif (vcc->dev == dev) {\n\t\t\t\tvcc_release_async(vcc, -EPIPE);\n\t\t\t\tsk_del_node_init(s);\n\t\t\t}\n\t\t}\n\t}\n\twrite_unlock_irq(&vcc_sklist_lock);\n}\nEXPORT_SYMBOL(atm_dev_release_vccs);\n\nstatic int adjust_tp(struct atm_trafprm *tp, unsigned char aal)\n{\n\tint max_sdu;\n\n\tif (!tp->traffic_class)\n\t\treturn 0;\n\tswitch (aal) {\n\tcase ATM_AAL0:\n\t\tmax_sdu = ATM_CELL_SIZE-1;\n\t\tbreak;\n\tcase ATM_AAL34:\n\t\tmax_sdu = ATM_MAX_AAL34_PDU;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"AAL problems ... (%d)\\n\", aal);\n\t\tfallthrough;\n\tcase ATM_AAL5:\n\t\tmax_sdu = ATM_MAX_AAL5_PDU;\n\t}\n\tif (!tp->max_sdu)\n\t\ttp->max_sdu = max_sdu;\n\telse if (tp->max_sdu > max_sdu)\n\t\treturn -EINVAL;\n\tif (!tp->max_cdv)\n\t\ttp->max_cdv = ATM_MAX_CDV;\n\treturn 0;\n}\n\nstatic int check_ci(const struct atm_vcc *vcc, short vpi, int vci)\n{\n\tstruct hlist_head *head = &vcc_hash[vci & (VCC_HTABLE_SIZE - 1)];\n\tstruct sock *s;\n\tstruct atm_vcc *walk;\n\n\tsk_for_each(s, head) {\n\t\twalk = atm_sk(s);\n\t\tif (walk->dev != vcc->dev)\n\t\t\tcontinue;\n\t\tif (test_bit(ATM_VF_ADDR, &walk->flags) && walk->vpi == vpi &&\n\t\t    walk->vci == vci && ((walk->qos.txtp.traffic_class !=\n\t\t    ATM_NONE && vcc->qos.txtp.traffic_class != ATM_NONE) ||\n\t\t    (walk->qos.rxtp.traffic_class != ATM_NONE &&\n\t\t    vcc->qos.rxtp.traffic_class != ATM_NONE)))\n\t\t\treturn -EADDRINUSE;\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic int find_ci(const struct atm_vcc *vcc, short *vpi, int *vci)\n{\n\tstatic short p;         \n\tstatic int c;\n\tshort old_p;\n\tint old_c;\n\tint err;\n\n\tif (*vpi != ATM_VPI_ANY && *vci != ATM_VCI_ANY) {\n\t\terr = check_ci(vcc, *vpi, *vci);\n\t\treturn err;\n\t}\n\t \n\tif (*vpi != ATM_VPI_ANY)\n\t\tp = *vpi;\n\telse if (p >= 1 << vcc->dev->ci_range.vpi_bits)\n\t\tp = 0;\n\tif (*vci != ATM_VCI_ANY)\n\t\tc = *vci;\n\telse if (c < ATM_NOT_RSV_VCI || c >= 1 << vcc->dev->ci_range.vci_bits)\n\t\t\tc = ATM_NOT_RSV_VCI;\n\told_p = p;\n\told_c = c;\n\tdo {\n\t\tif (!check_ci(vcc, p, c)) {\n\t\t\t*vpi = p;\n\t\t\t*vci = c;\n\t\t\treturn 0;\n\t\t}\n\t\tif (*vci == ATM_VCI_ANY) {\n\t\t\tc++;\n\t\t\tif (c >= 1 << vcc->dev->ci_range.vci_bits)\n\t\t\t\tc = ATM_NOT_RSV_VCI;\n\t\t}\n\t\tif ((c == ATM_NOT_RSV_VCI || *vci != ATM_VCI_ANY) &&\n\t\t    *vpi == ATM_VPI_ANY) {\n\t\t\tp++;\n\t\t\tif (p >= 1 << vcc->dev->ci_range.vpi_bits)\n\t\t\t\tp = 0;\n\t\t}\n\t} while (old_p != p || old_c != c);\n\treturn -EADDRINUSE;\n}\n\nstatic int __vcc_connect(struct atm_vcc *vcc, struct atm_dev *dev, short vpi,\n\t\t\t int vci)\n{\n\tstruct sock *sk = sk_atm(vcc);\n\tint error;\n\n\tif ((vpi != ATM_VPI_UNSPEC && vpi != ATM_VPI_ANY &&\n\t    vpi >> dev->ci_range.vpi_bits) || (vci != ATM_VCI_UNSPEC &&\n\t    vci != ATM_VCI_ANY && vci >> dev->ci_range.vci_bits))\n\t\treturn -EINVAL;\n\tif (vci > 0 && vci < ATM_NOT_RSV_VCI && !capable(CAP_NET_BIND_SERVICE))\n\t\treturn -EPERM;\n\terror = -ENODEV;\n\tif (!try_module_get(dev->ops->owner))\n\t\treturn error;\n\tvcc->dev = dev;\n\twrite_lock_irq(&vcc_sklist_lock);\n\tif (test_bit(ATM_DF_REMOVED, &dev->flags) ||\n\t    (error = find_ci(vcc, &vpi, &vci))) {\n\t\twrite_unlock_irq(&vcc_sklist_lock);\n\t\tgoto fail_module_put;\n\t}\n\tvcc->vpi = vpi;\n\tvcc->vci = vci;\n\t__vcc_insert_socket(sk);\n\twrite_unlock_irq(&vcc_sklist_lock);\n\tswitch (vcc->qos.aal) {\n\tcase ATM_AAL0:\n\t\terror = atm_init_aal0(vcc);\n\t\tvcc->stats = &dev->stats.aal0;\n\t\tbreak;\n\tcase ATM_AAL34:\n\t\terror = atm_init_aal34(vcc);\n\t\tvcc->stats = &dev->stats.aal34;\n\t\tbreak;\n\tcase ATM_NO_AAL:\n\t\t \n\t\tvcc->qos.aal = ATM_AAL5;\n\t\tfallthrough;\n\tcase ATM_AAL5:\n\t\terror = atm_init_aal5(vcc);\n\t\tvcc->stats = &dev->stats.aal5;\n\t\tbreak;\n\tdefault:\n\t\terror = -EPROTOTYPE;\n\t}\n\tif (!error)\n\t\terror = adjust_tp(&vcc->qos.txtp, vcc->qos.aal);\n\tif (!error)\n\t\terror = adjust_tp(&vcc->qos.rxtp, vcc->qos.aal);\n\tif (error)\n\t\tgoto fail;\n\tpr_debug(\"VCC %d.%d, AAL %d\\n\", vpi, vci, vcc->qos.aal);\n\tpr_debug(\"  TX: %d, PCR %d..%d, SDU %d\\n\",\n\t\t vcc->qos.txtp.traffic_class,\n\t\t vcc->qos.txtp.min_pcr,\n\t\t vcc->qos.txtp.max_pcr,\n\t\t vcc->qos.txtp.max_sdu);\n\tpr_debug(\"  RX: %d, PCR %d..%d, SDU %d\\n\",\n\t\t vcc->qos.rxtp.traffic_class,\n\t\t vcc->qos.rxtp.min_pcr,\n\t\t vcc->qos.rxtp.max_pcr,\n\t\t vcc->qos.rxtp.max_sdu);\n\n\tif (dev->ops->open) {\n\t\terror = dev->ops->open(vcc);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\n\nfail:\n\tvcc_remove_socket(sk);\nfail_module_put:\n\tmodule_put(dev->ops->owner);\n\t \n\tvcc->dev = NULL;\n\treturn error;\n}\n\nint vcc_connect(struct socket *sock, int itf, short vpi, int vci)\n{\n\tstruct atm_dev *dev;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint error;\n\n\tpr_debug(\"(vpi %d, vci %d)\\n\", vpi, vci);\n\tif (sock->state == SS_CONNECTED)\n\t\treturn -EISCONN;\n\tif (sock->state != SS_UNCONNECTED)\n\t\treturn -EINVAL;\n\tif (!(vpi || vci))\n\t\treturn -EINVAL;\n\n\tif (vpi != ATM_VPI_UNSPEC && vci != ATM_VCI_UNSPEC)\n\t\tclear_bit(ATM_VF_PARTIAL, &vcc->flags);\n\telse\n\t\tif (test_bit(ATM_VF_PARTIAL, &vcc->flags))\n\t\t\treturn -EINVAL;\n\tpr_debug(\"(TX: cl %d,bw %d-%d,sdu %d; \"\n\t\t \"RX: cl %d,bw %d-%d,sdu %d,AAL %s%d)\\n\",\n\t\t vcc->qos.txtp.traffic_class, vcc->qos.txtp.min_pcr,\n\t\t vcc->qos.txtp.max_pcr, vcc->qos.txtp.max_sdu,\n\t\t vcc->qos.rxtp.traffic_class, vcc->qos.rxtp.min_pcr,\n\t\t vcc->qos.rxtp.max_pcr, vcc->qos.rxtp.max_sdu,\n\t\t vcc->qos.aal == ATM_AAL5 ? \"\" :\n\t\t vcc->qos.aal == ATM_AAL0 ? \"\" : \" ??? code \",\n\t\t vcc->qos.aal == ATM_AAL0 ? 0 : vcc->qos.aal);\n\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags))\n\t\treturn -EBADFD;\n\tif (vcc->qos.txtp.traffic_class == ATM_ANYCLASS ||\n\t    vcc->qos.rxtp.traffic_class == ATM_ANYCLASS)\n\t\treturn -EINVAL;\n\tif (likely(itf != ATM_ITF_ANY)) {\n\t\tdev = try_then_request_module(atm_dev_lookup(itf),\n\t\t\t\t\t      \"atm-device-%d\", itf);\n\t} else {\n\t\tdev = NULL;\n\t\tmutex_lock(&atm_dev_mutex);\n\t\tif (!list_empty(&atm_devs)) {\n\t\t\tdev = list_entry(atm_devs.next,\n\t\t\t\t\t struct atm_dev, dev_list);\n\t\t\tatm_dev_hold(dev);\n\t\t}\n\t\tmutex_unlock(&atm_dev_mutex);\n\t}\n\tif (!dev)\n\t\treturn -ENODEV;\n\terror = __vcc_connect(vcc, dev, vpi, vci);\n\tif (error) {\n\t\tatm_dev_put(dev);\n\t\treturn error;\n\t}\n\tif (vpi == ATM_VPI_UNSPEC || vci == ATM_VCI_UNSPEC)\n\t\tset_bit(ATM_VF_PARTIAL, &vcc->flags);\n\tif (test_bit(ATM_VF_READY, &ATM_SD(sock)->flags))\n\t\tsock->state = SS_CONNECTED;\n\treturn 0;\n}\n\nint vcc_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\tint flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tint copied, error = -EINVAL;\n\n\tif (sock->state != SS_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\t \n\tif (flags & ~(MSG_DONTWAIT | MSG_PEEK))\n\t\treturn -EOPNOTSUPP;\n\n\tvcc = ATM_SD(sock);\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags))\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, &error);\n\tif (!skb)\n\t\treturn error;\n\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\terror = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (error)\n\t\treturn error;\n\tsock_recv_cmsgs(msg, sk, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tpr_debug(\"%d -= %d\\n\", atomic_read(&sk->sk_rmem_alloc),\n\t\t\t skb->truesize);\n\t\tatm_return(vcc, skb->truesize);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}\n\nint vcc_sendmsg(struct socket *sock, struct msghdr *m, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tDEFINE_WAIT(wait);\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tint eff, error;\n\n\tlock_sock(sk);\n\tif (sock->state != SS_CONNECTED) {\n\t\terror = -ENOTCONN;\n\t\tgoto out;\n\t}\n\tif (m->msg_name) {\n\t\terror = -EISCONN;\n\t\tgoto out;\n\t}\n\tvcc = ATM_SD(sock);\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags)) {\n\t\terror = -EPIPE;\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tgoto out;\n\t}\n\tif (!size) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\tif (size > vcc->qos.txtp.max_sdu) {\n\t\terror = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\teff = (size+3) & ~3;  \n\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\terror = 0;\n\twhile (!vcc_tx_ready(vcc, eff)) {\n\t\tif (m->msg_flags & MSG_DONTWAIT) {\n\t\t\terror = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t\tif (signal_pending(current)) {\n\t\t\terror = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t\t    !test_bit(ATM_VF_READY, &vcc->flags)) {\n\t\t\terror = -EPIPE;\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\tif (error)\n\t\tgoto out;\n\n\tskb = alloc_skb(eff, GFP_KERNEL);\n\tif (!skb) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpr_debug(\"%d += %d\\n\", sk_wmem_alloc_get(sk), skb->truesize);\n\tatm_account_tx(vcc, skb);\n\n\tskb->dev = NULL;  \n\tif (!copy_from_iter_full(skb_put(skb, size), size, &m->msg_iter)) {\n\t\tkfree_skb(skb);\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (eff != size)\n\t\tmemset(skb->data + size, 0, eff-size);\n\terror = vcc->dev->ops->send(vcc, skb);\n\terror = error ? error : size;\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\n__poll_t vcc_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n\t__poll_t mask;\n\n\tsock_poll_wait(file, sock, wait);\n\tmask = 0;\n\n\tvcc = ATM_SD(sock);\n\n\t \n\tif (sk->sk_err)\n\t\tmask = EPOLLERR;\n\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags))\n\t\tmask |= EPOLLHUP;\n\n\t \n\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\t \n\tif (sock->state == SS_CONNECTING &&\n\t    test_bit(ATM_VF_WAITING, &vcc->flags))\n\t\treturn mask;\n\n\tif (vcc->qos.txtp.traffic_class != ATM_NONE &&\n\t    vcc_writable(sk))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;\n\n\treturn mask;\n}\n\nstatic int atm_change_qos(struct atm_vcc *vcc, struct atm_qos *qos)\n{\n\tint error;\n\n\t \n\tif (qos->aal != vcc->qos.aal ||\n\t    qos->rxtp.traffic_class != vcc->qos.rxtp.traffic_class ||\n\t    qos->txtp.traffic_class != vcc->qos.txtp.traffic_class)\n\t\treturn -EINVAL;\n\terror = adjust_tp(&qos->txtp, qos->aal);\n\tif (!error)\n\t\terror = adjust_tp(&qos->rxtp, qos->aal);\n\tif (error)\n\t\treturn error;\n\tif (!vcc->dev->ops->change_qos)\n\t\treturn -EOPNOTSUPP;\n\tif (sk_atm(vcc)->sk_family == AF_ATMPVC)\n\t\treturn vcc->dev->ops->change_qos(vcc, qos, ATM_MF_SET);\n\treturn svc_change_qos(vcc, qos);\n}\n\nstatic int check_tp(const struct atm_trafprm *tp)\n{\n\t \n\tif (!tp->traffic_class || tp->traffic_class == ATM_ANYCLASS)\n\t\treturn 0;\n\tif (tp->traffic_class != ATM_UBR && !tp->min_pcr && !tp->pcr &&\n\t    !tp->max_pcr)\n\t\treturn -EINVAL;\n\tif (tp->min_pcr == ATM_MAX_PCR)\n\t\treturn -EINVAL;\n\tif (tp->min_pcr && tp->max_pcr && tp->max_pcr != ATM_MAX_PCR &&\n\t    tp->min_pcr > tp->max_pcr)\n\t\treturn -EINVAL;\n\t \n\treturn 0;\n}\n\nstatic int check_qos(const struct atm_qos *qos)\n{\n\tint error;\n\n\tif (!qos->txtp.traffic_class && !qos->rxtp.traffic_class)\n\t\treturn -EINVAL;\n\tif (qos->txtp.traffic_class != qos->rxtp.traffic_class &&\n\t    qos->txtp.traffic_class && qos->rxtp.traffic_class &&\n\t    qos->txtp.traffic_class != ATM_ANYCLASS &&\n\t    qos->rxtp.traffic_class != ATM_ANYCLASS)\n\t\treturn -EINVAL;\n\terror = check_tp(&qos->txtp);\n\tif (error)\n\t\treturn error;\n\treturn check_tp(&qos->rxtp);\n}\n\nint vcc_setsockopt(struct socket *sock, int level, int optname,\n\t\t   sockptr_t optval, unsigned int optlen)\n{\n\tstruct atm_vcc *vcc;\n\tunsigned long value;\n\tint error;\n\n\tif (__SO_LEVEL_MATCH(optname, level) && optlen != __SO_SIZE(optname))\n\t\treturn -EINVAL;\n\n\tvcc = ATM_SD(sock);\n\tswitch (optname) {\n\tcase SO_ATMQOS:\n\t{\n\t\tstruct atm_qos qos;\n\n\t\tif (copy_from_sockptr(&qos, optval, sizeof(qos)))\n\t\t\treturn -EFAULT;\n\t\terror = check_qos(&qos);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\treturn atm_change_qos(vcc, &qos);\n\t\tif (sock->state != SS_UNCONNECTED)\n\t\t\treturn -EBADFD;\n\t\tvcc->qos = qos;\n\t\tset_bit(ATM_VF_HASQOS, &vcc->flags);\n\t\treturn 0;\n\t}\n\tcase SO_SETCLP:\n\t\tif (copy_from_sockptr(&value, optval, sizeof(value)))\n\t\t\treturn -EFAULT;\n\t\tif (value)\n\t\t\tvcc->atm_options |= ATM_ATMOPT_CLP;\n\t\telse\n\t\t\tvcc->atm_options &= ~ATM_ATMOPT_CLP;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint vcc_getsockopt(struct socket *sock, int level, int optname,\n\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct atm_vcc *vcc;\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (__SO_LEVEL_MATCH(optname, level) && len != __SO_SIZE(optname))\n\t\treturn -EINVAL;\n\n\tvcc = ATM_SD(sock);\n\tswitch (optname) {\n\tcase SO_ATMQOS:\n\t\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags))\n\t\t\treturn -EINVAL;\n\t\treturn copy_to_user(optval, &vcc->qos, sizeof(vcc->qos))\n\t\t\t? -EFAULT : 0;\n\tcase SO_SETCLP:\n\t\treturn put_user(vcc->atm_options & ATM_ATMOPT_CLP ? 1 : 0,\n\t\t\t\t(unsigned long __user *)optval) ? -EFAULT : 0;\n\tcase SO_ATMPVC:\n\t{\n\t\tstruct sockaddr_atmpvc pvc;\n\n\t\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\t\treturn -ENOTCONN;\n\t\tmemset(&pvc, 0, sizeof(pvc));\n\t\tpvc.sap_family = AF_ATMPVC;\n\t\tpvc.sap_addr.itf = vcc->dev->number;\n\t\tpvc.sap_addr.vpi = vcc->vpi;\n\t\tpvc.sap_addr.vci = vcc->vci;\n\t\treturn copy_to_user(optval, &pvc, sizeof(pvc)) ? -EFAULT : 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint register_atmdevice_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&atm_dev_notify_chain, nb);\n}\nEXPORT_SYMBOL_GPL(register_atmdevice_notifier);\n\nvoid unregister_atmdevice_notifier(struct notifier_block *nb)\n{\n\tatomic_notifier_chain_unregister(&atm_dev_notify_chain, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_atmdevice_notifier);\n\nstatic int __init atm_init(void)\n{\n\tint error;\n\n\terror = proto_register(&vcc_proto, 0);\n\tif (error < 0)\n\t\tgoto out;\n\terror = atmpvc_init();\n\tif (error < 0) {\n\t\tpr_err(\"atmpvc_init() failed with %d\\n\", error);\n\t\tgoto out_unregister_vcc_proto;\n\t}\n\terror = atmsvc_init();\n\tif (error < 0) {\n\t\tpr_err(\"atmsvc_init() failed with %d\\n\", error);\n\t\tgoto out_atmpvc_exit;\n\t}\n\terror = atm_proc_init();\n\tif (error < 0) {\n\t\tpr_err(\"atm_proc_init() failed with %d\\n\", error);\n\t\tgoto out_atmsvc_exit;\n\t}\n\terror = atm_sysfs_init();\n\tif (error < 0) {\n\t\tpr_err(\"atm_sysfs_init() failed with %d\\n\", error);\n\t\tgoto out_atmproc_exit;\n\t}\nout:\n\treturn error;\nout_atmproc_exit:\n\tatm_proc_exit();\nout_atmsvc_exit:\n\tatmsvc_exit();\nout_atmpvc_exit:\n\tatmsvc_exit();\nout_unregister_vcc_proto:\n\tproto_unregister(&vcc_proto);\n\tgoto out;\n}\n\nstatic void __exit atm_exit(void)\n{\n\tatm_proc_exit();\n\tatm_sysfs_exit();\n\tatmsvc_exit();\n\tatmpvc_exit();\n\tproto_unregister(&vcc_proto);\n}\n\nsubsys_initcall(atm_init);\n\nmodule_exit(atm_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_ATMPVC);\nMODULE_ALIAS_NETPROTO(PF_ATMSVC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}