{
  "module_name": "svc.c",
  "hash_id": "c538ee5086e2b96ad0f063a6272c3d2a27994643c3eed0af59d83990cfbaed6b",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/svc.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/string.h>\n#include <linux/net.h>\t\t \n#include <linux/errno.h>\t \n#include <linux/kernel.h>\t \n#include <linux/skbuff.h>\n#include <linux/wait.h>\n#include <linux/sched/signal.h>\n#include <linux/fcntl.h>\t \n#include <linux/init.h>\n#include <linux/atm.h>\t\t \n#include <linux/atmsap.h>\n#include <linux/atmsvc.h>\n#include <linux/atmdev.h>\n#include <linux/bitops.h>\n#include <net/sock.h>\t\t \n#include <linux/uaccess.h>\n#include <linux/export.h>\n\n#include \"resources.h\"\n#include \"common.h\"\t\t \n#include \"signaling.h\"\n#include \"addr.h\"\n\n#ifdef CONFIG_COMPAT\n \n#define COMPAT_ATM_ADDPARTY _IOW('a', ATMIOC_SPECIAL + 4, struct compat_atm_iobuf)\n#endif\n\nstatic int svc_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern);\n\n \n\n\nstatic int svc_shutdown(struct socket *sock, int how)\n{\n\treturn 0;\n}\n\nstatic void svc_disconnect(struct atm_vcc *vcc)\n{\n\tDEFINE_WAIT(wait);\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sk_atm(vcc);\n\n\tpr_debug(\"%p\\n\", vcc);\n\tif (test_bit(ATM_VF_REGIS, &vcc->flags)) {\n\t\tsigd_enq(vcc, as_close, NULL, NULL, NULL);\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_UNINTERRUPTIBLE);\n\t\t\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) || !sigd)\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\t}\n\t \n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tatm_return(vcc, skb->truesize);\n\t\tpr_debug(\"LISTEN REL\\n\");\n\t\tsigd_enq2(NULL, as_reject, vcc, NULL, NULL, &vcc->qos, 0);\n\t\tdev_kfree_skb(skb);\n\t}\n\tclear_bit(ATM_VF_REGIS, &vcc->flags);\n\t \n}\n\nstatic int svc_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n\n\tif (sk) {\n\t\tvcc = ATM_SD(sock);\n\t\tpr_debug(\"%p\\n\", vcc);\n\t\tclear_bit(ATM_VF_READY, &vcc->flags);\n\t\t \n\t\tsvc_disconnect(vcc);\n\t\tvcc_release(sock);\n\t}\n\treturn 0;\n}\n\nstatic int svc_bind(struct socket *sock, struct sockaddr *sockaddr,\n\t\t    int sockaddr_len)\n{\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_atmsvc *addr;\n\tstruct atm_vcc *vcc;\n\tint error;\n\n\tif (sockaddr_len != sizeof(struct sockaddr_atmsvc))\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sock->state == SS_CONNECTED) {\n\t\terror = -EISCONN;\n\t\tgoto out;\n\t}\n\tif (sock->state != SS_UNCONNECTED) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\tvcc = ATM_SD(sock);\n\taddr = (struct sockaddr_atmsvc *) sockaddr;\n\tif (addr->sas_family != AF_ATMSVC) {\n\t\terror = -EAFNOSUPPORT;\n\t\tgoto out;\n\t}\n\tclear_bit(ATM_VF_BOUND, &vcc->flags);\n\t     \n\t \n\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags)) {\n\t\terror = -EBADFD;\n\t\tgoto out;\n\t}\n\tvcc->local = *addr;\n\tset_bit(ATM_VF_WAITING, &vcc->flags);\n\tsigd_enq(vcc, as_bind, NULL, NULL, &vcc->local);\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (!test_bit(ATM_VF_WAITING, &vcc->flags) || !sigd)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\tclear_bit(ATM_VF_REGIS, &vcc->flags);  \n\tif (!sigd) {\n\t\terror = -EUNATCH;\n\t\tgoto out;\n\t}\n\tif (!sk->sk_err)\n\t\tset_bit(ATM_VF_BOUND, &vcc->flags);\n\terror = -sk->sk_err;\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int svc_connect(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int sockaddr_len, int flags)\n{\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_atmsvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint error;\n\n\tpr_debug(\"%p\\n\", vcc);\n\tlock_sock(sk);\n\tif (sockaddr_len != sizeof(struct sockaddr_atmsvc)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (sock->state) {\n\tdefault:\n\t\terror = -EINVAL;\n\t\tgoto out;\n\tcase SS_CONNECTED:\n\t\terror = -EISCONN;\n\t\tgoto out;\n\tcase SS_CONNECTING:\n\t\tif (test_bit(ATM_VF_WAITING, &vcc->flags)) {\n\t\t\terror = -EALREADY;\n\t\t\tgoto out;\n\t\t}\n\t\tsock->state = SS_UNCONNECTED;\n\t\tif (sk->sk_err) {\n\t\t\terror = -sk->sk_err;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SS_UNCONNECTED:\n\t\taddr = (struct sockaddr_atmsvc *) sockaddr;\n\t\tif (addr->sas_family != AF_ATMSVC) {\n\t\t\terror = -EAFNOSUPPORT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags)) {\n\t\t\terror = -EBADFD;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vcc->qos.txtp.traffic_class == ATM_ANYCLASS ||\n\t\t    vcc->qos.rxtp.traffic_class == ATM_ANYCLASS) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!vcc->qos.txtp.traffic_class &&\n\t\t    !vcc->qos.rxtp.traffic_class) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tvcc->remote = *addr;\n\t\tset_bit(ATM_VF_WAITING, &vcc->flags);\n\t\tsigd_enq(vcc, as_connect, NULL, NULL, &vcc->remote);\n\t\tif (flags & O_NONBLOCK) {\n\t\t\tsock->state = SS_CONNECTING;\n\t\t\terror = -EINPROGRESS;\n\t\t\tgoto out;\n\t\t}\n\t\terror = 0;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\twhile (test_bit(ATM_VF_WAITING, &vcc->flags) && sigd) {\n\t\t\tschedule();\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpr_debug(\"*ABORT*\\n\");\n\t\t\t \n\t\t\tsigd_enq(vcc, as_close, NULL, NULL, NULL);\n\t\t\twhile (test_bit(ATM_VF_WAITING, &vcc->flags) && sigd) {\n\t\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\t\tschedule();\n\t\t\t}\n\t\t\tif (!sk->sk_err)\n\t\t\t\twhile (!test_bit(ATM_VF_RELEASED, &vcc->flags) &&\n\t\t\t\t       sigd) {\n\t\t\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\t\t\tschedule();\n\t\t\t\t}\n\t\t\tclear_bit(ATM_VF_REGIS, &vcc->flags);\n\t\t\tclear_bit(ATM_VF_RELEASED, &vcc->flags);\n\t\t\tclear_bit(ATM_VF_CLOSE, &vcc->flags);\n\t\t\t     \n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tif (!sigd) {\n\t\t\terror = -EUNATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sk->sk_err) {\n\t\t\terror = -sk->sk_err;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tvcc->qos.txtp.max_pcr = SELECT_TOP_PCR(vcc->qos.txtp);\n\tvcc->qos.txtp.pcr = 0;\n\tvcc->qos.txtp.min_pcr = 0;\n\n\terror = vcc_connect(sock, vcc->itf, vcc->vpi, vcc->vci);\n\tif (!error)\n\t\tsock->state = SS_CONNECTED;\n\telse\n\t\t(void)svc_disconnect(vcc);\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int svc_listen(struct socket *sock, int backlog)\n{\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint error;\n\n\tpr_debug(\"%p\\n\", vcc);\n\tlock_sock(sk);\n\t \n\tif (test_bit(ATM_VF_SESSION, &vcc->flags)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (test_bit(ATM_VF_LISTEN, &vcc->flags)) {\n\t\terror = -EADDRINUSE;\n\t\tgoto out;\n\t}\n\tset_bit(ATM_VF_WAITING, &vcc->flags);\n\tsigd_enq(vcc, as_listen, NULL, NULL, &vcc->local);\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (!test_bit(ATM_VF_WAITING, &vcc->flags) || !sigd)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\tif (!sigd) {\n\t\terror = -EUNATCH;\n\t\tgoto out;\n\t}\n\tset_bit(ATM_VF_LISTEN, &vcc->flags);\n\tvcc_insert_socket(sk);\n\tsk->sk_max_ack_backlog = backlog > 0 ? backlog : ATM_BACKLOG_DEFAULT;\n\terror = -sk->sk_err;\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int svc_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t      bool kern)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tstruct atmsvc_msg *msg;\n\tstruct atm_vcc *old_vcc = ATM_SD(sock);\n\tstruct atm_vcc *new_vcc;\n\tint error;\n\n\tlock_sock(sk);\n\n\terror = svc_create(sock_net(sk), newsock, 0, kern);\n\tif (error)\n\t\tgoto out;\n\n\tnew_vcc = ATM_SD(newsock);\n\n\tpr_debug(\"%p -> %p\\n\", old_vcc, new_vcc);\n\twhile (1) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\twhile (!(skb = skb_dequeue(&sk->sk_receive_queue)) &&\n\t\t       sigd) {\n\t\t\tif (test_bit(ATM_VF_RELEASED, &old_vcc->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(ATM_VF_CLOSE, &old_vcc->flags)) {\n\t\t\t\terror = -sk->sk_err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flags & O_NONBLOCK) {\n\t\t\t\terror = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terror = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tif (!skb) {\n\t\t\terror = -EUNATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tmsg = (struct atmsvc_msg *)skb->data;\n\t\tnew_vcc->qos = msg->qos;\n\t\tset_bit(ATM_VF_HASQOS, &new_vcc->flags);\n\t\tnew_vcc->remote = msg->svc;\n\t\tnew_vcc->local = msg->local;\n\t\tnew_vcc->sap = msg->sap;\n\t\terror = vcc_connect(newsock, msg->pvc.sap_addr.itf,\n\t\t\t\t    msg->pvc.sap_addr.vpi,\n\t\t\t\t    msg->pvc.sap_addr.vci);\n\t\tdev_kfree_skb(skb);\n\t\tsk_acceptq_removed(sk);\n\t\tif (error) {\n\t\t\tsigd_enq2(NULL, as_reject, old_vcc, NULL, NULL,\n\t\t\t\t  &old_vcc->qos, error);\n\t\t\terror = error == -EAGAIN ? -EBUSY : error;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tset_bit(ATM_VF_WAITING, &new_vcc->flags);\n\t\tsigd_enq(new_vcc, as_accept, old_vcc, NULL, NULL);\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk_atm(new_vcc)), &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\tif (!test_bit(ATM_VF_WAITING, &new_vcc->flags) || !sigd)\n\t\t\t\tbreak;\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t}\n\t\tfinish_wait(sk_sleep(sk_atm(new_vcc)), &wait);\n\t\tif (!sigd) {\n\t\t\terror = -EUNATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!sk_atm(new_vcc)->sk_err)\n\t\t\tbreak;\n\t\tif (sk_atm(new_vcc)->sk_err != ERESTARTSYS) {\n\t\t\terror = -sk_atm(new_vcc)->sk_err;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnewsock->state = SS_CONNECTED;\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int svc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int peer)\n{\n\tstruct sockaddr_atmsvc *addr;\n\n\taddr = (struct sockaddr_atmsvc *) sockaddr;\n\tmemcpy(addr, peer ? &ATM_SD(sock)->remote : &ATM_SD(sock)->local,\n\t       sizeof(struct sockaddr_atmsvc));\n\treturn sizeof(struct sockaddr_atmsvc);\n}\n\nint svc_change_qos(struct atm_vcc *vcc, struct atm_qos *qos)\n{\n\tstruct sock *sk = sk_atm(vcc);\n\tDEFINE_WAIT(wait);\n\n\tset_bit(ATM_VF_WAITING, &vcc->flags);\n\tsigd_enq2(vcc, as_modify, NULL, NULL, &vcc->local, qos, 0);\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (!test_bit(ATM_VF_WAITING, &vcc->flags) ||\n\t\t    test_bit(ATM_VF_RELEASED, &vcc->flags) || !sigd) {\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\tif (!sigd)\n\t\treturn -EUNATCH;\n\treturn -sk->sk_err;\n}\n\nstatic int svc_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint value, error = 0;\n\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase SO_ATMSAP:\n\t\tif (level != SOL_ATM || optlen != sizeof(struct atm_sap)) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (copy_from_sockptr(&vcc->sap, optval, optlen)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tset_bit(ATM_VF_HASSAP, &vcc->flags);\n\t\tbreak;\n\tcase SO_MULTIPOINT:\n\t\tif (level != SOL_ATM || optlen != sizeof(int)) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (copy_from_sockptr(&value, optval, sizeof(int))) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (value == 1)\n\t\t\tset_bit(ATM_VF_SESSION, &vcc->flags);\n\t\telse if (value == 0)\n\t\t\tclear_bit(ATM_VF_SESSION, &vcc->flags);\n\t\telse\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\terror = vcc_setsockopt(sock, level, optname, optval, optlen);\n\t}\n\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int svc_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint error = 0, len;\n\n\tlock_sock(sk);\n\tif (!__SO_LEVEL_MATCH(optname, level) || optname != SO_ATMSAP) {\n\t\terror = vcc_getsockopt(sock, level, optname, optval, optlen);\n\t\tgoto out;\n\t}\n\tif (get_user(len, optlen)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (len != sizeof(struct atm_sap)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (copy_to_user(optval, &ATM_SD(sock)->sap, sizeof(struct atm_sap))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int svc_addparty(struct socket *sock, struct sockaddr *sockaddr,\n\t\t\tint sockaddr_len, int flags)\n{\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint error;\n\n\tlock_sock(sk);\n\tset_bit(ATM_VF_WAITING, &vcc->flags);\n\tsigd_enq(vcc, as_addparty, NULL, NULL,\n\t\t (struct sockaddr_atmsvc *) sockaddr);\n\tif (flags & O_NONBLOCK) {\n\t\terror = -EINPROGRESS;\n\t\tgoto out;\n\t}\n\tpr_debug(\"added wait queue\\n\");\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tif (!test_bit(ATM_VF_WAITING, &vcc->flags) || !sigd)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\terror = -xchg(&sk->sk_err_soft, 0);\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int svc_dropparty(struct socket *sock, int ep_ref)\n{\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint error;\n\n\tlock_sock(sk);\n\tset_bit(ATM_VF_WAITING, &vcc->flags);\n\tsigd_enq2(vcc, as_dropparty, NULL, NULL, NULL, NULL, ep_ref);\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tif (!test_bit(ATM_VF_WAITING, &vcc->flags) || !sigd)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\tif (!sigd) {\n\t\terror = -EUNATCH;\n\t\tgoto out;\n\t}\n\terror = -xchg(&sk->sk_err_soft, 0);\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int svc_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint error, ep_ref;\n\tstruct sockaddr_atmsvc sa;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\n\tswitch (cmd) {\n\tcase ATM_ADDPARTY:\n\t\tif (!test_bit(ATM_VF_SESSION, &vcc->flags))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&sa, (void __user *) arg, sizeof(sa)))\n\t\t\treturn -EFAULT;\n\t\terror = svc_addparty(sock, (struct sockaddr *)&sa, sizeof(sa),\n\t\t\t\t     0);\n\t\tbreak;\n\tcase ATM_DROPPARTY:\n\t\tif (!test_bit(ATM_VF_SESSION, &vcc->flags))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ep_ref, (void __user *) arg, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\terror = svc_dropparty(sock, ep_ref);\n\t\tbreak;\n\tdefault:\n\t\terror = vcc_ioctl(sock, cmd, arg);\n\t}\n\n\treturn error;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int svc_compat_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\t \n\tif (cmd == COMPAT_ATM_ADDPARTY)\n\t\tcmd = ATM_ADDPARTY;\n\n\tif (cmd == ATM_ADDPARTY || cmd == ATM_DROPPARTY)\n\t\treturn svc_ioctl(sock, cmd, arg);\n\telse\n\t\treturn vcc_compat_ioctl(sock, cmd, arg);\n}\n#endif  \n\nstatic const struct proto_ops svc_proto_ops = {\n\t.family =\tPF_ATMSVC,\n\t.owner =\tTHIS_MODULE,\n\n\t.release =\tsvc_release,\n\t.bind =\t\tsvc_bind,\n\t.connect =\tsvc_connect,\n\t.socketpair =\tsock_no_socketpair,\n\t.accept =\tsvc_accept,\n\t.getname =\tsvc_getname,\n\t.poll =\t\tvcc_poll,\n\t.ioctl =\tsvc_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl =\tsvc_compat_ioctl,\n#endif\n\t.gettstamp =\tsock_gettstamp,\n\t.listen =\tsvc_listen,\n\t.shutdown =\tsvc_shutdown,\n\t.setsockopt =\tsvc_setsockopt,\n\t.getsockopt =\tsvc_getsockopt,\n\t.sendmsg =\tvcc_sendmsg,\n\t.recvmsg =\tvcc_recvmsg,\n\t.mmap =\t\tsock_no_mmap,\n};\n\n\nstatic int svc_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tint error;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tsock->ops = &svc_proto_ops;\n\terror = vcc_create(net, sock, protocol, AF_ATMSVC, kern);\n\tif (error)\n\t\treturn error;\n\tATM_SD(sock)->local.sas_family = AF_ATMSVC;\n\tATM_SD(sock)->remote.sas_family = AF_ATMSVC;\n\treturn 0;\n}\n\nstatic const struct net_proto_family svc_family_ops = {\n\t.family = PF_ATMSVC,\n\t.create = svc_create,\n\t.owner = THIS_MODULE,\n};\n\n\n \n\nint __init atmsvc_init(void)\n{\n\treturn sock_register(&svc_family_ops);\n}\n\nvoid atmsvc_exit(void)\n{\n\tsock_unregister(PF_ATMSVC);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}