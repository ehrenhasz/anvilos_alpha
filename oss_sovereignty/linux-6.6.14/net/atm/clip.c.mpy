{
  "module_name": "clip.c",
  "hash_id": "dadfc8bf10bc9340878e01eb0ff12bcf7ad80200e778a270438387f0db69e365",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/clip.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>  \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/if_arp.h>  \n#include <linux/notifier.h>\n#include <linux/atm.h>\n#include <linux/atmdev.h>\n#include <linux/atmclip.h>\n#include <linux/atmarp.h>\n#include <linux/capability.h>\n#include <linux/ip.h>  \n#include <linux/in.h>  \n#include <linux/if.h>  \n#include <linux/inetdevice.h>\n#include <linux/bitops.h>\n#include <linux/poison.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/rcupdate.h>\n#include <linux/jhash.h>\n#include <linux/slab.h>\n#include <net/route.h>  \n#include <net/icmp.h>  \n#include <net/arp.h>\n#include <linux/param.h>  \n#include <linux/uaccess.h>\n#include <asm/byteorder.h>  \n#include <linux/atomic.h>\n\n#include \"common.h\"\n#include \"resources.h\"\n#include <net/atmclip.h>\n\nstatic struct net_device *clip_devs;\nstatic struct atm_vcc *atmarpd;\nstatic struct timer_list idle_timer;\nstatic const struct neigh_ops clip_neigh_ops;\n\nstatic int to_atmarpd(enum atmarp_ctrl_type type, int itf, __be32 ip)\n{\n\tstruct sock *sk;\n\tstruct atmarp_ctrl *ctrl;\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"(%d)\\n\", type);\n\tif (!atmarpd)\n\t\treturn -EUNATCH;\n\tskb = alloc_skb(sizeof(struct atmarp_ctrl), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tctrl = skb_put(skb, sizeof(struct atmarp_ctrl));\n\tctrl->type = type;\n\tctrl->itf_num = itf;\n\tctrl->ip = ip;\n\tatm_force_charge(atmarpd, skb->truesize);\n\n\tsk = sk_atm(atmarpd);\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_data_ready(sk);\n\treturn 0;\n}\n\nstatic void link_vcc(struct clip_vcc *clip_vcc, struct atmarp_entry *entry)\n{\n\tpr_debug(\"%p to entry %p (neigh %p)\\n\", clip_vcc, entry, entry->neigh);\n\tclip_vcc->entry = entry;\n\tclip_vcc->xoff = 0;\t \n\tclip_vcc->next = entry->vccs;\n\tentry->vccs = clip_vcc;\n\tentry->neigh->used = jiffies;\n}\n\nstatic void unlink_clip_vcc(struct clip_vcc *clip_vcc)\n{\n\tstruct atmarp_entry *entry = clip_vcc->entry;\n\tstruct clip_vcc **walk;\n\n\tif (!entry) {\n\t\tpr_err(\"!clip_vcc->entry (clip_vcc %p)\\n\", clip_vcc);\n\t\treturn;\n\t}\n\tnetif_tx_lock_bh(entry->neigh->dev);\t \n\tentry->neigh->used = jiffies;\n\tfor (walk = &entry->vccs; *walk; walk = &(*walk)->next)\n\t\tif (*walk == clip_vcc) {\n\t\t\tint error;\n\n\t\t\t*walk = clip_vcc->next;\t \n\t\t\tclip_vcc->entry = NULL;\n\t\t\tif (clip_vcc->xoff)\n\t\t\t\tnetif_wake_queue(entry->neigh->dev);\n\t\t\tif (entry->vccs)\n\t\t\t\tgoto out;\n\t\t\tentry->expires = jiffies - 1;\n\t\t\t \n\t\t\terror = neigh_update(entry->neigh, NULL, NUD_NONE,\n\t\t\t\t\t     NEIGH_UPDATE_F_ADMIN, 0);\n\t\t\tif (error)\n\t\t\t\tpr_err(\"neigh_update failed with %d\\n\", error);\n\t\t\tgoto out;\n\t\t}\n\tpr_err(\"ATMARP: failed (entry %p, vcc 0x%p)\\n\", entry, clip_vcc);\nout:\n\tnetif_tx_unlock_bh(entry->neigh->dev);\n}\n\n \nstatic int neigh_check_cb(struct neighbour *n)\n{\n\tstruct atmarp_entry *entry = neighbour_priv(n);\n\tstruct clip_vcc *cv;\n\n\tif (n->ops != &clip_neigh_ops)\n\t\treturn 0;\n\tfor (cv = entry->vccs; cv; cv = cv->next) {\n\t\tunsigned long exp = cv->last_use + cv->idle_timeout;\n\n\t\tif (cv->idle_timeout && time_after(jiffies, exp)) {\n\t\t\tpr_debug(\"releasing vcc %p->%p of entry %p\\n\",\n\t\t\t\t cv, cv->vcc, entry);\n\t\t\tvcc_release_async(cv->vcc, -ETIMEDOUT);\n\t\t}\n\t}\n\n\tif (entry->vccs || time_before(jiffies, entry->expires))\n\t\treturn 0;\n\n\tif (refcount_read(&n->refcnt) > 1) {\n\t\tstruct sk_buff *skb;\n\n\t\tpr_debug(\"destruction postponed with ref %d\\n\",\n\t\t\t refcount_read(&n->refcnt));\n\n\t\twhile ((skb = skb_dequeue(&n->arp_queue)) != NULL)\n\t\t\tdev_kfree_skb(skb);\n\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"expired neigh %p\\n\", n);\n\treturn 1;\n}\n\nstatic void idle_timer_check(struct timer_list *unused)\n{\n\twrite_lock(&arp_tbl.lock);\n\t__neigh_for_each_release(&arp_tbl, neigh_check_cb);\n\tmod_timer(&idle_timer, jiffies + CLIP_CHECK_INTERVAL * HZ);\n\twrite_unlock(&arp_tbl.lock);\n}\n\nstatic int clip_arp_rcv(struct sk_buff *skb)\n{\n\tstruct atm_vcc *vcc;\n\n\tpr_debug(\"\\n\");\n\tvcc = ATM_SKB(skb)->vcc;\n\tif (!vcc || !atm_charge(vcc, skb->truesize)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\tpr_debug(\"pushing to %p\\n\", vcc);\n\tpr_debug(\"using %p\\n\", CLIP_VCC(vcc)->old_push);\n\tCLIP_VCC(vcc)->old_push(vcc, skb);\n\treturn 0;\n}\n\nstatic const unsigned char llc_oui[] = {\n\t0xaa,\t \n\t0xaa,\t \n\t0x03,\t \n\t0x00,\t \n\t0x00,\n\t0x00\n};\n\nstatic void clip_push(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tstruct clip_vcc *clip_vcc = CLIP_VCC(vcc);\n\n\tpr_debug(\"\\n\");\n\n\tif (!clip_devs) {\n\t\tatm_return(vcc, skb->truesize);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (!skb) {\n\t\tpr_debug(\"removing VCC %p\\n\", clip_vcc);\n\t\tif (clip_vcc->entry)\n\t\t\tunlink_clip_vcc(clip_vcc);\n\t\tclip_vcc->old_push(vcc, NULL);\t \n\t\tkfree(clip_vcc);\n\t\treturn;\n\t}\n\tatm_return(vcc, skb->truesize);\n\tskb->dev = clip_vcc->entry ? clip_vcc->entry->neigh->dev : clip_devs;\n\t \n\tif (!skb->dev) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\tATM_SKB(skb)->vcc = vcc;\n\tskb_reset_mac_header(skb);\n\tif (!clip_vcc->encap ||\n\t    skb->len < RFC1483LLC_LEN ||\n\t    memcmp(skb->data, llc_oui, sizeof(llc_oui)))\n\t\tskb->protocol = htons(ETH_P_IP);\n\telse {\n\t\tskb->protocol = ((__be16 *)skb->data)[3];\n\t\tskb_pull(skb, RFC1483LLC_LEN);\n\t\tif (skb->protocol == htons(ETH_P_ARP)) {\n\t\t\tskb->dev->stats.rx_packets++;\n\t\t\tskb->dev->stats.rx_bytes += skb->len;\n\t\t\tclip_arp_rcv(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\tclip_vcc->last_use = jiffies;\n\tskb->dev->stats.rx_packets++;\n\tskb->dev->stats.rx_bytes += skb->len;\n\tmemset(ATM_SKB(skb), 0, sizeof(struct atm_skb_data));\n\tnetif_rx(skb);\n}\n\n \n\nstatic void clip_pop(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tstruct clip_vcc *clip_vcc = CLIP_VCC(vcc);\n\tstruct net_device *dev = skb->dev;\n\tint old;\n\tunsigned long flags;\n\n\tpr_debug(\"(vcc %p)\\n\", vcc);\n\tclip_vcc->old_pop(vcc, skb);\n\t \n\tif (!dev)\n\t\treturn;\n\tspin_lock_irqsave(&PRIV(dev)->xoff_lock, flags);\n\tif (atm_may_send(vcc, 0)) {\n\t\told = xchg(&clip_vcc->xoff, 0);\n\t\tif (old)\n\t\t\tnetif_wake_queue(dev);\n\t}\n\tspin_unlock_irqrestore(&PRIV(dev)->xoff_lock, flags);\n}\n\nstatic void clip_neigh_solicit(struct neighbour *neigh, struct sk_buff *skb)\n{\n\t__be32 *ip = (__be32 *) neigh->primary_key;\n\n\tpr_debug(\"(neigh %p, skb %p)\\n\", neigh, skb);\n\tto_atmarpd(act_need, PRIV(neigh->dev)->number, *ip);\n}\n\nstatic void clip_neigh_error(struct neighbour *neigh, struct sk_buff *skb)\n{\n#ifndef CONFIG_ATM_CLIP_NO_ICMP\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_HOST_UNREACH, 0);\n#endif\n\tkfree_skb(skb);\n}\n\nstatic const struct neigh_ops clip_neigh_ops = {\n\t.family =\t\tAF_INET,\n\t.solicit =\t\tclip_neigh_solicit,\n\t.error_report =\t\tclip_neigh_error,\n\t.output =\t\tneigh_direct_output,\n\t.connected_output =\tneigh_direct_output,\n};\n\nstatic int clip_constructor(struct net_device *dev, struct neighbour *neigh)\n{\n\tstruct atmarp_entry *entry = neighbour_priv(neigh);\n\n\tif (neigh->tbl->family != AF_INET)\n\t\treturn -EINVAL;\n\n\tif (neigh->type != RTN_UNICAST)\n\t\treturn -EINVAL;\n\n\tneigh->nud_state = NUD_NONE;\n\tneigh->ops = &clip_neigh_ops;\n\tneigh->output = neigh->ops->output;\n\tentry->neigh = neigh;\n\tentry->vccs = NULL;\n\tentry->expires = jiffies - 1;\n\n\treturn 0;\n}\n\n \n\n \n\nstatic int clip_encap(struct atm_vcc *vcc, int mode)\n{\n\tif (!CLIP_VCC(vcc))\n\t\treturn -EBADFD;\n\n\tCLIP_VCC(vcc)->encap = mode;\n\treturn 0;\n}\n\nstatic netdev_tx_t clip_start_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev)\n{\n\tstruct clip_priv *clip_priv = PRIV(dev);\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct atmarp_entry *entry;\n\tstruct neighbour *n;\n\tstruct atm_vcc *vcc;\n\tstruct rtable *rt;\n\t__be32 *daddr;\n\tint old;\n\tunsigned long flags;\n\n\tpr_debug(\"(skb %p)\\n\", skb);\n\tif (!dst) {\n\t\tpr_err(\"skb_dst(skb) == NULL\\n\");\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\trt = (struct rtable *) dst;\n\tif (rt->rt_gw_family == AF_INET)\n\t\tdaddr = &rt->rt_gw4;\n\telse\n\t\tdaddr = &ip_hdr(skb)->daddr;\n\tn = dst_neigh_lookup(dst, daddr);\n\tif (!n) {\n\t\tpr_err(\"NO NEIGHBOUR !\\n\");\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\tentry = neighbour_priv(n);\n\tif (!entry->vccs) {\n\t\tif (time_after(jiffies, entry->expires)) {\n\t\t\t \n\t\t\tentry->expires = jiffies + ATMARP_RETRY_DELAY * HZ;\n\t\t\tto_atmarpd(act_need, PRIV(dev)->number, *((__be32 *)n->primary_key));\n\t\t}\n\t\tif (entry->neigh->arp_queue.qlen < ATMARP_MAX_UNRES_PACKETS)\n\t\t\tskb_queue_tail(&entry->neigh->arp_queue, skb);\n\t\telse {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tdev->stats.tx_dropped++;\n\t\t}\n\t\tgoto out_release_neigh;\n\t}\n\tpr_debug(\"neigh %p, vccs %p\\n\", entry, entry->vccs);\n\tATM_SKB(skb)->vcc = vcc = entry->vccs->vcc;\n\tpr_debug(\"using neighbour %p, vcc %p\\n\", n, vcc);\n\tif (entry->vccs->encap) {\n\t\tvoid *here;\n\n\t\there = skb_push(skb, RFC1483LLC_LEN);\n\t\tmemcpy(here, llc_oui, sizeof(llc_oui));\n\t\t((__be16 *) here)[3] = skb->protocol;\n\t}\n\tatm_account_tx(vcc, skb);\n\tentry->vccs->last_use = jiffies;\n\tpr_debug(\"atm_skb(%p)->vcc(%p)->dev(%p)\\n\", skb, vcc, vcc->dev);\n\told = xchg(&entry->vccs->xoff, 1);\t \n\tif (old) {\n\t\tpr_warn(\"XOFF->XOFF transition\\n\");\n\t\tgoto out_release_neigh;\n\t}\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\tvcc->send(vcc, skb);\n\tif (atm_may_send(vcc, 0)) {\n\t\tentry->vccs->xoff = 0;\n\t\tgoto out_release_neigh;\n\t}\n\tspin_lock_irqsave(&clip_priv->xoff_lock, flags);\n\tnetif_stop_queue(dev);\t \n\tbarrier();\n\tif (!entry->vccs->xoff)\n\t\tnetif_start_queue(dev);\n\t \n\tspin_unlock_irqrestore(&clip_priv->xoff_lock, flags);\nout_release_neigh:\n\tneigh_release(n);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int clip_mkip(struct atm_vcc *vcc, int timeout)\n{\n\tstruct clip_vcc *clip_vcc;\n\n\tif (!vcc->push)\n\t\treturn -EBADFD;\n\tclip_vcc = kmalloc(sizeof(struct clip_vcc), GFP_KERNEL);\n\tif (!clip_vcc)\n\t\treturn -ENOMEM;\n\tpr_debug(\"%p vcc %p\\n\", clip_vcc, vcc);\n\tclip_vcc->vcc = vcc;\n\tvcc->user_back = clip_vcc;\n\tset_bit(ATM_VF_IS_CLIP, &vcc->flags);\n\tclip_vcc->entry = NULL;\n\tclip_vcc->xoff = 0;\n\tclip_vcc->encap = 1;\n\tclip_vcc->last_use = jiffies;\n\tclip_vcc->idle_timeout = timeout * HZ;\n\tclip_vcc->old_push = vcc->push;\n\tclip_vcc->old_pop = vcc->pop;\n\tvcc->push = clip_push;\n\tvcc->pop = clip_pop;\n\n\t \n\tvcc_process_recv_queue(vcc);\n\n\treturn 0;\n}\n\nstatic int clip_setentry(struct atm_vcc *vcc, __be32 ip)\n{\n\tstruct neighbour *neigh;\n\tstruct atmarp_entry *entry;\n\tint error;\n\tstruct clip_vcc *clip_vcc;\n\tstruct rtable *rt;\n\n\tif (vcc->push != clip_push) {\n\t\tpr_warn(\"non-CLIP VCC\\n\");\n\t\treturn -EBADF;\n\t}\n\tclip_vcc = CLIP_VCC(vcc);\n\tif (!ip) {\n\t\tif (!clip_vcc->entry) {\n\t\t\tpr_err(\"hiding hidden ATMARP entry\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tpr_debug(\"remove\\n\");\n\t\tunlink_clip_vcc(clip_vcc);\n\t\treturn 0;\n\t}\n\trt = ip_route_output(&init_net, ip, 0, 1, 0);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\tneigh = __neigh_lookup(&arp_tbl, &ip, rt->dst.dev, 1);\n\tip_rt_put(rt);\n\tif (!neigh)\n\t\treturn -ENOMEM;\n\tentry = neighbour_priv(neigh);\n\tif (entry != clip_vcc->entry) {\n\t\tif (!clip_vcc->entry)\n\t\t\tpr_debug(\"add\\n\");\n\t\telse {\n\t\t\tpr_debug(\"update\\n\");\n\t\t\tunlink_clip_vcc(clip_vcc);\n\t\t}\n\t\tlink_vcc(clip_vcc, entry);\n\t}\n\terror = neigh_update(neigh, llc_oui, NUD_PERMANENT,\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE | NEIGH_UPDATE_F_ADMIN, 0);\n\tneigh_release(neigh);\n\treturn error;\n}\n\nstatic const struct net_device_ops clip_netdev_ops = {\n\t.ndo_start_xmit\t\t= clip_start_xmit,\n\t.ndo_neigh_construct\t= clip_constructor,\n};\n\nstatic void clip_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &clip_netdev_ops;\n\tdev->type = ARPHRD_ATM;\n\tdev->neigh_priv_len = sizeof(struct atmarp_entry);\n\tdev->hard_header_len = RFC1483LLC_LEN;\n\tdev->mtu = RFC1626_MTU;\n\tdev->tx_queue_len = 100;\t \n\t \n\t \n\t \n\t \n\t \n\tnetif_keep_dst(dev);\n}\n\nstatic int clip_create(int number)\n{\n\tstruct net_device *dev;\n\tstruct clip_priv *clip_priv;\n\tint error;\n\n\tif (number != -1) {\n\t\tfor (dev = clip_devs; dev; dev = PRIV(dev)->next)\n\t\t\tif (PRIV(dev)->number == number)\n\t\t\t\treturn -EEXIST;\n\t} else {\n\t\tnumber = 0;\n\t\tfor (dev = clip_devs; dev; dev = PRIV(dev)->next)\n\t\t\tif (PRIV(dev)->number >= number)\n\t\t\t\tnumber = PRIV(dev)->number + 1;\n\t}\n\tdev = alloc_netdev(sizeof(struct clip_priv), \"\", NET_NAME_UNKNOWN,\n\t\t\t   clip_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tclip_priv = PRIV(dev);\n\tsprintf(dev->name, \"atm%d\", number);\n\tspin_lock_init(&clip_priv->xoff_lock);\n\tclip_priv->number = number;\n\terror = register_netdev(dev);\n\tif (error) {\n\t\tfree_netdev(dev);\n\t\treturn error;\n\t}\n\tclip_priv->next = clip_devs;\n\tclip_devs = dev;\n\tpr_debug(\"registered (net:%s)\\n\", dev->name);\n\treturn number;\n}\n\nstatic int clip_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event == NETDEV_UNREGISTER)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (dev->type != ARPHRD_ATM || dev->netdev_ops != &clip_netdev_ops)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tpr_debug(\"NETDEV_UP\\n\");\n\t\tto_atmarpd(act_up, PRIV(dev)->number, 0);\n\t\tbreak;\n\tcase NETDEV_GOING_DOWN:\n\t\tpr_debug(\"NETDEV_DOWN\\n\");\n\t\tto_atmarpd(act_down, PRIV(dev)->number, 0);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_CHANGEMTU:\n\t\tpr_debug(\"NETDEV_CHANGE*\\n\");\n\t\tto_atmarpd(act_change, PRIV(dev)->number, 0);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic int clip_inet_event(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ifa)\n{\n\tstruct in_device *in_dev;\n\tstruct netdev_notifier_info info;\n\n\tin_dev = ((struct in_ifaddr *)ifa)->ifa_dev;\n\t \n\tif (event != NETDEV_UP)\n\t\treturn NOTIFY_DONE;\n\tnetdev_notifier_info_init(&info, in_dev->dev);\n\treturn clip_device_event(this, NETDEV_CHANGE, &info);\n}\n\nstatic struct notifier_block clip_dev_notifier = {\n\t.notifier_call = clip_device_event,\n};\n\n\n\nstatic struct notifier_block clip_inet_notifier = {\n\t.notifier_call = clip_inet_event,\n};\n\n\n\nstatic void atmarpd_close(struct atm_vcc *vcc)\n{\n\tpr_debug(\"\\n\");\n\n\trtnl_lock();\n\tatmarpd = NULL;\n\tskb_queue_purge(&sk_atm(vcc)->sk_receive_queue);\n\trtnl_unlock();\n\n\tpr_debug(\"(done)\\n\");\n\tmodule_put(THIS_MODULE);\n}\n\nstatic const struct atmdev_ops atmarpd_dev_ops = {\n\t.close = atmarpd_close\n};\n\n\nstatic struct atm_dev atmarpd_dev = {\n\t.ops =\t\t\t&atmarpd_dev_ops,\n\t.type =\t\t\t\"arpd\",\n\t.number = \t\t999,\n\t.lock =\t\t\t__SPIN_LOCK_UNLOCKED(atmarpd_dev.lock)\n};\n\n\nstatic int atm_init_atmarp(struct atm_vcc *vcc)\n{\n\trtnl_lock();\n\tif (atmarpd) {\n\t\trtnl_unlock();\n\t\treturn -EADDRINUSE;\n\t}\n\n\tmod_timer(&idle_timer, jiffies + CLIP_CHECK_INTERVAL * HZ);\n\n\tatmarpd = vcc;\n\tset_bit(ATM_VF_META, &vcc->flags);\n\tset_bit(ATM_VF_READY, &vcc->flags);\n\t     \n\tvcc->dev = &atmarpd_dev;\n\tvcc_insert_socket(sk_atm(vcc));\n\tvcc->push = NULL;\n\tvcc->pop = NULL;  \n\tvcc->push_oam = NULL;  \n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic int clip_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint err = 0;\n\n\tswitch (cmd) {\n\tcase SIOCMKCLIP:\n\tcase ATMARPD_CTRL:\n\tcase ATMARP_MKIP:\n\tcase ATMARP_SETENTRY:\n\tcase ATMARP_ENCAP:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\tswitch (cmd) {\n\tcase SIOCMKCLIP:\n\t\terr = clip_create(arg);\n\t\tbreak;\n\tcase ATMARPD_CTRL:\n\t\terr = atm_init_atmarp(vcc);\n\t\tif (!err) {\n\t\t\tsock->state = SS_CONNECTED;\n\t\t\t__module_get(THIS_MODULE);\n\t\t}\n\t\tbreak;\n\tcase ATMARP_MKIP:\n\t\terr = clip_mkip(vcc, arg);\n\t\tbreak;\n\tcase ATMARP_SETENTRY:\n\t\terr = clip_setentry(vcc, (__force __be32)arg);\n\t\tbreak;\n\tcase ATMARP_ENCAP:\n\t\terr = clip_encap(vcc, arg);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic struct atm_ioctl clip_ioctl_ops = {\n\t.owner = THIS_MODULE,\n\t.ioctl = clip_ioctl,\n};\n\n#ifdef CONFIG_PROC_FS\n\nstatic void svc_addr(struct seq_file *seq, struct sockaddr_atmsvc *addr)\n{\n\tstatic int code[] = { 1, 2, 10, 6, 1, 0 };\n\tstatic int e164[] = { 1, 8, 4, 6, 1, 0 };\n\n\tif (*addr->sas_addr.pub) {\n\t\tseq_printf(seq, \"%s\", addr->sas_addr.pub);\n\t\tif (*addr->sas_addr.prv)\n\t\t\tseq_putc(seq, '+');\n\t} else if (!*addr->sas_addr.prv) {\n\t\tseq_printf(seq, \"%s\", \"(none)\");\n\t\treturn;\n\t}\n\tif (*addr->sas_addr.prv) {\n\t\tunsigned char *prv = addr->sas_addr.prv;\n\t\tint *fields;\n\t\tint i, j;\n\n\t\tfields = *prv == ATM_AFI_E164 ? e164 : code;\n\t\tfor (i = 0; fields[i]; i++) {\n\t\t\tfor (j = fields[i]; j; j--)\n\t\t\t\tseq_printf(seq, \"%02X\", *prv++);\n\t\t\tif (fields[i + 1])\n\t\t\t\tseq_putc(seq, '.');\n\t\t}\n\t}\n}\n\n \n#define SEQ_NO_VCC_TOKEN\t((void *) 2)\n\nstatic void atmarp_info(struct seq_file *seq, struct neighbour *n,\n\t\t\tstruct atmarp_entry *entry, struct clip_vcc *clip_vcc)\n{\n\tstruct net_device *dev = n->dev;\n\tunsigned long exp;\n\tchar buf[17];\n\tint svc, llc, off;\n\n\tsvc = ((clip_vcc == SEQ_NO_VCC_TOKEN) ||\n\t       (sk_atm(clip_vcc->vcc)->sk_family == AF_ATMSVC));\n\n\tllc = ((clip_vcc == SEQ_NO_VCC_TOKEN) || clip_vcc->encap);\n\n\tif (clip_vcc == SEQ_NO_VCC_TOKEN)\n\t\texp = entry->neigh->used;\n\telse\n\t\texp = clip_vcc->last_use;\n\n\texp = (jiffies - exp) / HZ;\n\n\tseq_printf(seq, \"%-6s%-4s%-4s%5ld \",\n\t\t   dev->name, svc ? \"SVC\" : \"PVC\", llc ? \"LLC\" : \"NULL\", exp);\n\n\toff = scnprintf(buf, sizeof(buf) - 1, \"%pI4\", n->primary_key);\n\twhile (off < 16)\n\t\tbuf[off++] = ' ';\n\tbuf[off] = '\\0';\n\tseq_printf(seq, \"%s\", buf);\n\n\tif (clip_vcc == SEQ_NO_VCC_TOKEN) {\n\t\tif (time_before(jiffies, entry->expires))\n\t\t\tseq_printf(seq, \"(resolving)\\n\");\n\t\telse\n\t\t\tseq_printf(seq, \"(expired, ref %d)\\n\",\n\t\t\t\t   refcount_read(&entry->neigh->refcnt));\n\t} else if (!svc) {\n\t\tseq_printf(seq, \"%d.%d.%d\\n\",\n\t\t\t   clip_vcc->vcc->dev->number,\n\t\t\t   clip_vcc->vcc->vpi, clip_vcc->vcc->vci);\n\t} else {\n\t\tsvc_addr(seq, &clip_vcc->vcc->remote);\n\t\tseq_putc(seq, '\\n');\n\t}\n}\n\nstruct clip_seq_state {\n\t \n\tstruct neigh_seq_state ns;\n\n\t \n\tstruct clip_vcc *vcc;\n};\n\nstatic struct clip_vcc *clip_seq_next_vcc(struct atmarp_entry *e,\n\t\t\t\t\t  struct clip_vcc *curr)\n{\n\tif (!curr) {\n\t\tcurr = e->vccs;\n\t\tif (!curr)\n\t\t\treturn SEQ_NO_VCC_TOKEN;\n\t\treturn curr;\n\t}\n\tif (curr == SEQ_NO_VCC_TOKEN)\n\t\treturn NULL;\n\n\tcurr = curr->next;\n\n\treturn curr;\n}\n\nstatic void *clip_seq_vcc_walk(struct clip_seq_state *state,\n\t\t\t       struct atmarp_entry *e, loff_t * pos)\n{\n\tstruct clip_vcc *vcc = state->vcc;\n\n\tvcc = clip_seq_next_vcc(e, vcc);\n\tif (vcc && pos != NULL) {\n\t\twhile (*pos) {\n\t\t\tvcc = clip_seq_next_vcc(e, vcc);\n\t\t\tif (!vcc)\n\t\t\t\tbreak;\n\t\t\t--(*pos);\n\t\t}\n\t}\n\tstate->vcc = vcc;\n\n\treturn vcc;\n}\n\nstatic void *clip_seq_sub_iter(struct neigh_seq_state *_state,\n\t\t\t       struct neighbour *n, loff_t * pos)\n{\n\tstruct clip_seq_state *state = (struct clip_seq_state *)_state;\n\n\tif (n->dev->type != ARPHRD_ATM)\n\t\treturn NULL;\n\n\treturn clip_seq_vcc_walk(state, neighbour_priv(n), pos);\n}\n\nstatic void *clip_seq_start(struct seq_file *seq, loff_t * pos)\n{\n\tstruct clip_seq_state *state = seq->private;\n\tstate->ns.neigh_sub_iter = clip_seq_sub_iter;\n\treturn neigh_seq_start(seq, pos, &arp_tbl, NEIGH_SEQ_NEIGH_ONLY);\n}\n\nstatic int clip_seq_show(struct seq_file *seq, void *v)\n{\n\tstatic char atm_arp_banner[] =\n\t    \"IPitf TypeEncp Idle IP address      ATM address\\n\";\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, atm_arp_banner);\n\t} else {\n\t\tstruct clip_seq_state *state = seq->private;\n\t\tstruct clip_vcc *vcc = state->vcc;\n\t\tstruct neighbour *n = v;\n\n\t\tatmarp_info(seq, n, neighbour_priv(n), vcc);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations arp_seq_ops = {\n\t.start\t= clip_seq_start,\n\t.next\t= neigh_seq_next,\n\t.stop\t= neigh_seq_stop,\n\t.show\t= clip_seq_show,\n};\n#endif\n\nstatic void atm_clip_exit_noproc(void);\n\nstatic int __init atm_clip_init(void)\n{\n\tregister_atm_ioctl(&clip_ioctl_ops);\n\tregister_netdevice_notifier(&clip_dev_notifier);\n\tregister_inetaddr_notifier(&clip_inet_notifier);\n\n\ttimer_setup(&idle_timer, idle_timer_check, 0);\n\n#ifdef CONFIG_PROC_FS\n\t{\n\t\tstruct proc_dir_entry *p;\n\n\t\tp = proc_create_net(\"arp\", 0444, atm_proc_root, &arp_seq_ops,\n\t\t\t\tsizeof(struct clip_seq_state));\n\t\tif (!p) {\n\t\t\tpr_err(\"Unable to initialize /proc/net/atm/arp\\n\");\n\t\t\tatm_clip_exit_noproc();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic void atm_clip_exit_noproc(void)\n{\n\tstruct net_device *dev, *next;\n\n\tunregister_inetaddr_notifier(&clip_inet_notifier);\n\tunregister_netdevice_notifier(&clip_dev_notifier);\n\n\tderegister_atm_ioctl(&clip_ioctl_ops);\n\n\t \n\tdel_timer_sync(&idle_timer);\n\n\tdev = clip_devs;\n\twhile (dev) {\n\t\tnext = PRIV(dev)->next;\n\t\tunregister_netdev(dev);\n\t\tfree_netdev(dev);\n\t\tdev = next;\n\t}\n}\n\nstatic void __exit atm_clip_exit(void)\n{\n\tremove_proc_entry(\"arp\", atm_proc_root);\n\n\tatm_clip_exit_noproc();\n}\n\nmodule_init(atm_clip_init);\nmodule_exit(atm_clip_exit);\nMODULE_AUTHOR(\"Werner Almesberger\");\nMODULE_DESCRIPTION(\"Classical/IP over ATM interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}