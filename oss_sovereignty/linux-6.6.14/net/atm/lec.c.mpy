{
  "module_name": "lec.c",
  "hash_id": "b776275381f6220c992e25941269c33e18e2f737670530ecd347ca1e34c20f85",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/lec.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n\n \n#include <linux/if_ether.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <net/sock.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n#include <net/arp.h>\n#include <net/dst.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n\n \n#include <linux/atmdev.h>\n#include <linux/atmlec.h>\n\n \n#if IS_ENABLED(CONFIG_BRIDGE)\n#include \"../bridge/br_private.h\"\n\nstatic unsigned char bridge_ula_lec[] = { 0x01, 0x80, 0xc2, 0x00, 0x00 };\n#endif\n\n \n#include <linux/module.h>\n#include <linux/init.h>\n\n \n#include <linux/nospec.h>\n\n#include \"lec.h\"\n#include \"lec_arpc.h\"\n#include \"resources.h\"\n\n#define DUMP_PACKETS 0\t\t \n\n#define LEC_UNRES_QUE_LEN 8\t \n\nstatic int lec_open(struct net_device *dev);\nstatic netdev_tx_t lec_start_xmit(struct sk_buff *skb,\n\t\t\t\t  struct net_device *dev);\nstatic int lec_close(struct net_device *dev);\nstatic struct lec_arp_table *lec_arp_find(struct lec_priv *priv,\n\t\t\t\t\t  const unsigned char *mac_addr);\nstatic int lec_arp_remove(struct lec_priv *priv,\n\t\t\t  struct lec_arp_table *to_remove);\n \nstatic void lane2_associate_ind(struct net_device *dev, const u8 *mac_address,\n\t\t\t\tconst u8 *tlvs, u32 sizeoftlvs);\nstatic int lane2_resolve(struct net_device *dev, const u8 *dst_mac, int force,\n\t\t\t u8 **tlvs, u32 *sizeoftlvs);\nstatic int lane2_associate_req(struct net_device *dev, const u8 *lan_dst,\n\t\t\t       const u8 *tlvs, u32 sizeoftlvs);\n\nstatic int lec_addr_delete(struct lec_priv *priv, const unsigned char *atm_addr,\n\t\t\t   unsigned long permanent);\nstatic void lec_arp_check_empties(struct lec_priv *priv,\n\t\t\t\t  struct atm_vcc *vcc, struct sk_buff *skb);\nstatic void lec_arp_destroy(struct lec_priv *priv);\nstatic void lec_arp_init(struct lec_priv *priv);\nstatic struct atm_vcc *lec_arp_resolve(struct lec_priv *priv,\n\t\t\t\t       const unsigned char *mac_to_find,\n\t\t\t\t       int is_rdesc,\n\t\t\t\t       struct lec_arp_table **ret_entry);\nstatic void lec_arp_update(struct lec_priv *priv, const unsigned char *mac_addr,\n\t\t\t   const unsigned char *atm_addr,\n\t\t\t   unsigned long remoteflag,\n\t\t\t   unsigned int targetless_le_arp);\nstatic void lec_flush_complete(struct lec_priv *priv, unsigned long tran_id);\nstatic int lec_mcast_make(struct lec_priv *priv, struct atm_vcc *vcc);\nstatic void lec_set_flush_tran_id(struct lec_priv *priv,\n\t\t\t\t  const unsigned char *atm_addr,\n\t\t\t\t  unsigned long tran_id);\nstatic void lec_vcc_added(struct lec_priv *priv,\n\t\t\t  const struct atmlec_ioc *ioc_data,\n\t\t\t  struct atm_vcc *vcc,\n\t\t\t  void (*old_push)(struct atm_vcc *vcc,\n\t\t\t\t\t   struct sk_buff *skb));\nstatic void lec_vcc_close(struct lec_priv *priv, struct atm_vcc *vcc);\n\n \nstatic inline void lec_arp_hold(struct lec_arp_table *entry)\n{\n\trefcount_inc(&entry->usage);\n}\n\nstatic inline void lec_arp_put(struct lec_arp_table *entry)\n{\n\tif (refcount_dec_and_test(&entry->usage))\n\t\tkfree(entry);\n}\n\nstatic struct lane2_ops lane2_ops = {\n\t.resolve = lane2_resolve,\t\t \n\t.associate_req = lane2_associate_req,\t \n\t.associate_indicator = NULL              \n};\n\nstatic unsigned char bus_mac[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n \nstatic struct net_device *dev_lec[MAX_LEC_ITF];\n\n#if IS_ENABLED(CONFIG_BRIDGE)\nstatic void lec_handle_bridge(struct sk_buff *skb, struct net_device *dev)\n{\n\tchar *buff;\n\tstruct lec_priv *priv;\n\n\t \n\tbuff = skb->data + skb->dev->hard_header_len;\n\tif (*buff++ == 0x42 && *buff++ == 0x42 && *buff++ == 0x03) {\n\t\tstruct sock *sk;\n\t\tstruct sk_buff *skb2;\n\t\tstruct atmlec_msg *mesg;\n\n\t\tskb2 = alloc_skb(sizeof(struct atmlec_msg), GFP_ATOMIC);\n\t\tif (skb2 == NULL)\n\t\t\treturn;\n\t\tskb2->len = sizeof(struct atmlec_msg);\n\t\tmesg = (struct atmlec_msg *)skb2->data;\n\t\tmesg->type = l_topology_change;\n\t\tbuff += 4;\n\t\tmesg->content.normal.flag = *buff & 0x01;\n\t\t\t\t\t \n\n\t\tpriv = netdev_priv(dev);\n\t\tatm_force_charge(priv->lecd, skb2->truesize);\n\t\tsk = sk_atm(priv->lecd);\n\t\tskb_queue_tail(&sk->sk_receive_queue, skb2);\n\t\tsk->sk_data_ready(sk);\n\t}\n}\n#endif  \n\n \n\nstatic int lec_open(struct net_device *dev)\n{\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic void\nlec_send(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\n\tATM_SKB(skb)->vcc = vcc;\n\tatm_account_tx(vcc, skb);\n\n\tif (vcc->send(vcc, skb) < 0) {\n\t\tdev->stats.tx_dropped++;\n\t\treturn;\n\t}\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n}\n\nstatic void lec_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tpr_info(\"%s\\n\", dev->name);\n\tnetif_trans_update(dev);\n\tnetif_wake_queue(dev);\n}\n\nstatic netdev_tx_t lec_start_xmit(struct sk_buff *skb,\n\t\t\t\t  struct net_device *dev)\n{\n\tstruct sk_buff *skb2;\n\tstruct lec_priv *priv = netdev_priv(dev);\n\tstruct lecdatahdr_8023 *lec_h;\n\tstruct atm_vcc *vcc;\n\tstruct lec_arp_table *entry;\n\tunsigned char *dst;\n\tint min_frame_size;\n\tint is_rdesc;\n\n\tpr_debug(\"called\\n\");\n\tif (!priv->lecd) {\n\t\tpr_info(\"%s:No lecd attached\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t\tnetif_stop_queue(dev);\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tpr_debug(\"skbuff head:%lx data:%lx tail:%lx end:%lx\\n\",\n\t\t (long)skb->head, (long)skb->data, (long)skb_tail_pointer(skb),\n\t\t (long)skb_end_pointer(skb));\n#if IS_ENABLED(CONFIG_BRIDGE)\n\tif (memcmp(skb->data, bridge_ula_lec, sizeof(bridge_ula_lec)) == 0)\n\t\tlec_handle_bridge(skb, dev);\n#endif\n\n\t \n\tif (skb_headroom(skb) < 2) {\n\t\tpr_debug(\"reallocating skb\\n\");\n\t\tskb2 = skb_realloc_headroom(skb, LEC_HEADER_LEN);\n\t\tif (unlikely(!skb2)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tconsume_skb(skb);\n\t\tskb = skb2;\n\t}\n\tskb_push(skb, 2);\n\n\t \n\tlec_h = (struct lecdatahdr_8023 *)skb->data;\n\tlec_h->le_header = htons(priv->lecid);\n\n#if DUMP_PACKETS >= 2\n#define MAX_DUMP_SKB 99\n#elif DUMP_PACKETS >= 1\n#define MAX_DUMP_SKB 30\n#endif\n#if DUMP_PACKETS >= 1\n\tprintk(KERN_DEBUG \"%s: send datalen:%ld lecid:%4.4x\\n\",\n\t       dev->name, skb->len, priv->lecid);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_OFFSET, 16, 1,\n\t\t       skb->data, min(skb->len, MAX_DUMP_SKB), true);\n#endif  \n\n\t \n\tmin_frame_size = LEC_MINIMUM_8023_SIZE;\n\tif (skb->len < min_frame_size) {\n\t\tif ((skb->len + skb_tailroom(skb)) < min_frame_size) {\n\t\t\tskb2 = skb_copy_expand(skb, 0,\n\t\t\t\t\t       min_frame_size - skb->truesize,\n\t\t\t\t\t       GFP_ATOMIC);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tif (skb2 == NULL) {\n\t\t\t\tdev->stats.tx_dropped++;\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t}\n\t\t\tskb = skb2;\n\t\t}\n\t\tskb_put(skb, min_frame_size - skb->len);\n\t}\n\n\t \n\tis_rdesc = 0;\n\tdst = lec_h->h_dest;\n\tentry = NULL;\n\tvcc = lec_arp_resolve(priv, dst, is_rdesc, &entry);\n\tpr_debug(\"%s:vcc:%p vcc_flags:%lx, entry:%p\\n\",\n\t\t dev->name, vcc, vcc ? vcc->flags : 0, entry);\n\tif (!vcc || !test_bit(ATM_VF_READY, &vcc->flags)) {\n\t\tif (entry && (entry->tx_wait.qlen < LEC_UNRES_QUE_LEN)) {\n\t\t\tpr_debug(\"%s:queuing packet, MAC address %pM\\n\",\n\t\t\t\t dev->name, lec_h->h_dest);\n\t\t\tskb_queue_tail(&entry->tx_wait, skb);\n\t\t} else {\n\t\t\tpr_debug(\"%s:tx queue full or no arp entry, dropping, MAC address: %pM\\n\",\n\t\t\t\t dev->name, lec_h->h_dest);\n\t\t\tdev->stats.tx_dropped++;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t\tgoto out;\n\t}\n#if DUMP_PACKETS > 0\n\tprintk(KERN_DEBUG \"%s:sending to vpi:%d vci:%d\\n\",\n\t       dev->name, vcc->vpi, vcc->vci);\n#endif  \n\n\twhile (entry && (skb2 = skb_dequeue(&entry->tx_wait))) {\n\t\tpr_debug(\"emptying tx queue, MAC address %pM\\n\", lec_h->h_dest);\n\t\tlec_send(vcc, skb2);\n\t}\n\n\tlec_send(vcc, skb);\n\n\tif (!atm_may_send(vcc, 0)) {\n\t\tstruct lec_vcc_priv *vpriv = LEC_VCC_PRIV(vcc);\n\n\t\tvpriv->xoff = 1;\n\t\tnetif_stop_queue(dev);\n\n\t\t \n\n\t\tif (atm_may_send(vcc, 0))\n\t\t\tnetif_wake_queue(dev);\n\t}\n\nout:\n\tif (entry)\n\t\tlec_arp_put(entry);\n\tnetif_trans_update(dev);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic int lec_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\nstatic int lec_atm_send(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tstatic const u8 zero_addr[ETH_ALEN] = {};\n\tunsigned long flags;\n\tstruct net_device *dev = (struct net_device *)vcc->proto_data;\n\tstruct lec_priv *priv = netdev_priv(dev);\n\tstruct atmlec_msg *mesg;\n\tstruct lec_arp_table *entry;\n\tchar *tmp;\t\t \n\n\tWARN_ON(refcount_sub_and_test(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc));\n\tmesg = (struct atmlec_msg *)skb->data;\n\ttmp = skb->data;\n\ttmp += sizeof(struct atmlec_msg);\n\tpr_debug(\"%s: msg from zeppelin:%d\\n\", dev->name, mesg->type);\n\tswitch (mesg->type) {\n\tcase l_set_mac_addr:\n\t\teth_hw_addr_set(dev, mesg->content.normal.mac_addr);\n\t\tbreak;\n\tcase l_del_mac_addr:\n\t\teth_hw_addr_set(dev, zero_addr);\n\t\tbreak;\n\tcase l_addr_delete:\n\t\tlec_addr_delete(priv, mesg->content.normal.atm_addr,\n\t\t\t\tmesg->content.normal.flag);\n\t\tbreak;\n\tcase l_topology_change:\n\t\tpriv->topology_change = mesg->content.normal.flag;\n\t\tbreak;\n\tcase l_flush_complete:\n\t\tlec_flush_complete(priv, mesg->content.normal.flag);\n\t\tbreak;\n\tcase l_narp_req:\t \n\t\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\t\tentry = lec_arp_find(priv, mesg->content.normal.mac_addr);\n\t\tlec_arp_remove(priv, entry);\n\t\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\n\t\tif (mesg->content.normal.no_source_le_narp)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase l_arp_update:\n\t\tlec_arp_update(priv, mesg->content.normal.mac_addr,\n\t\t\t       mesg->content.normal.atm_addr,\n\t\t\t       mesg->content.normal.flag,\n\t\t\t       mesg->content.normal.targetless_le_arp);\n\t\tpr_debug(\"in l_arp_update\\n\");\n\t\tif (mesg->sizeoftlvs != 0) {\t \n\t\t\tpr_debug(\"LANE2 3.1.5, got tlvs, size %d\\n\",\n\t\t\t\t mesg->sizeoftlvs);\n\t\t\tlane2_associate_ind(dev, mesg->content.normal.mac_addr,\n\t\t\t\t\t    tmp, mesg->sizeoftlvs);\n\t\t}\n\t\tbreak;\n\tcase l_config:\n\t\tpriv->maximum_unknown_frame_count =\n\t\t    mesg->content.config.maximum_unknown_frame_count;\n\t\tpriv->max_unknown_frame_time =\n\t\t    (mesg->content.config.max_unknown_frame_time * HZ);\n\t\tpriv->max_retry_count = mesg->content.config.max_retry_count;\n\t\tpriv->aging_time = (mesg->content.config.aging_time * HZ);\n\t\tpriv->forward_delay_time =\n\t\t    (mesg->content.config.forward_delay_time * HZ);\n\t\tpriv->arp_response_time =\n\t\t    (mesg->content.config.arp_response_time * HZ);\n\t\tpriv->flush_timeout = (mesg->content.config.flush_timeout * HZ);\n\t\tpriv->path_switching_delay =\n\t\t    (mesg->content.config.path_switching_delay * HZ);\n\t\tpriv->lane_version = mesg->content.config.lane_version;\n\t\t\t\t\t \n\t\tpriv->lane2_ops = NULL;\n\t\tif (priv->lane_version > 1)\n\t\t\tpriv->lane2_ops = &lane2_ops;\n\t\trtnl_lock();\n\t\tif (dev_set_mtu(dev, mesg->content.config.mtu))\n\t\t\tpr_info(\"%s: change_mtu to %d failed\\n\",\n\t\t\t\tdev->name, mesg->content.config.mtu);\n\t\trtnl_unlock();\n\t\tpriv->is_proxy = mesg->content.config.is_proxy;\n\t\tbreak;\n\tcase l_flush_tran_id:\n\t\tlec_set_flush_tran_id(priv, mesg->content.normal.atm_addr,\n\t\t\t\t      mesg->content.normal.flag);\n\t\tbreak;\n\tcase l_set_lecid:\n\t\tpriv->lecid =\n\t\t    (unsigned short)(0xffff & mesg->content.normal.flag);\n\t\tbreak;\n\tcase l_should_bridge:\n#if IS_ENABLED(CONFIG_BRIDGE)\n\t{\n\t\tpr_debug(\"%s: bridge zeppelin asks about %pM\\n\",\n\t\t\t dev->name, mesg->content.proxy.mac_addr);\n\n\t\tif (br_fdb_test_addr_hook == NULL)\n\t\t\tbreak;\n\n\t\tif (br_fdb_test_addr_hook(dev, mesg->content.proxy.mac_addr)) {\n\t\t\t \n\t\t\tstruct sk_buff *skb2;\n\t\t\tstruct sock *sk;\n\n\t\t\tpr_debug(\"%s: entry found, responding to zeppelin\\n\",\n\t\t\t\t dev->name);\n\t\t\tskb2 = alloc_skb(sizeof(struct atmlec_msg), GFP_ATOMIC);\n\t\t\tif (skb2 == NULL)\n\t\t\t\tbreak;\n\t\t\tskb2->len = sizeof(struct atmlec_msg);\n\t\t\tskb_copy_to_linear_data(skb2, mesg, sizeof(*mesg));\n\t\t\tatm_force_charge(priv->lecd, skb2->truesize);\n\t\t\tsk = sk_atm(priv->lecd);\n\t\t\tskb_queue_tail(&sk->sk_receive_queue, skb2);\n\t\t\tsk->sk_data_ready(sk);\n\t\t}\n\t}\n#endif  \n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: Unknown message type %d\\n\", dev->name, mesg->type);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tdev_kfree_skb(skb);\n\treturn 0;\n}\n\nstatic void lec_atm_close(struct atm_vcc *vcc)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev = (struct net_device *)vcc->proto_data;\n\tstruct lec_priv *priv = netdev_priv(dev);\n\n\tpriv->lecd = NULL;\n\t \n\n\tnetif_stop_queue(dev);\n\tlec_arp_destroy(priv);\n\n\tif (skb_peek(&sk_atm(vcc)->sk_receive_queue))\n\t\tpr_info(\"%s closing with messages pending\\n\", dev->name);\n\twhile ((skb = skb_dequeue(&sk_atm(vcc)->sk_receive_queue))) {\n\t\tatm_return(vcc, skb->truesize);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tpr_info(\"%s: Shut down!\\n\", dev->name);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic const struct atmdev_ops lecdev_ops = {\n\t.close = lec_atm_close,\n\t.send = lec_atm_send\n};\n\nstatic struct atm_dev lecatm_dev = {\n\t.ops = &lecdev_ops,\n\t.type = \"lec\",\n\t.number = 999,\t\t \n\t.lock = __SPIN_LOCK_UNLOCKED(lecatm_dev.lock)\n};\n\n \nstatic int\nsend_to_lecd(struct lec_priv *priv, atmlec_msg_type type,\n\t     const unsigned char *mac_addr, const unsigned char *atm_addr,\n\t     struct sk_buff *data)\n{\n\tstruct sock *sk;\n\tstruct sk_buff *skb;\n\tstruct atmlec_msg *mesg;\n\n\tif (!priv || !priv->lecd)\n\t\treturn -1;\n\tskb = alloc_skb(sizeof(struct atmlec_msg), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -1;\n\tskb->len = sizeof(struct atmlec_msg);\n\tmesg = (struct atmlec_msg *)skb->data;\n\tmemset(mesg, 0, sizeof(struct atmlec_msg));\n\tmesg->type = type;\n\tif (data != NULL)\n\t\tmesg->sizeoftlvs = data->len;\n\tif (mac_addr)\n\t\tether_addr_copy(mesg->content.normal.mac_addr, mac_addr);\n\telse\n\t\tmesg->content.normal.targetless_le_arp = 1;\n\tif (atm_addr)\n\t\tmemcpy(&mesg->content.normal.atm_addr, atm_addr, ATM_ESA_LEN);\n\n\tatm_force_charge(priv->lecd, skb->truesize);\n\tsk = sk_atm(priv->lecd);\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_data_ready(sk);\n\n\tif (data != NULL) {\n\t\tpr_debug(\"about to send %d bytes of data\\n\", data->len);\n\t\tatm_force_charge(priv->lecd, data->truesize);\n\t\tskb_queue_tail(&sk->sk_receive_queue, data);\n\t\tsk->sk_data_ready(sk);\n\t}\n\n\treturn 0;\n}\n\nstatic void lec_set_multicast_list(struct net_device *dev)\n{\n\t \n}\n\nstatic const struct net_device_ops lec_netdev_ops = {\n\t.ndo_open\t\t= lec_open,\n\t.ndo_stop\t\t= lec_close,\n\t.ndo_start_xmit\t\t= lec_start_xmit,\n\t.ndo_tx_timeout\t\t= lec_tx_timeout,\n\t.ndo_set_rx_mode\t= lec_set_multicast_list,\n};\n\nstatic const unsigned char lec_ctrl_magic[] = {\n\t0xff,\n\t0x00,\n\t0x01,\n\t0x01\n};\n\n#define LEC_DATA_DIRECT_8023  2\n#define LEC_DATA_DIRECT_8025  3\n\nstatic int lec_is_data_direct(struct atm_vcc *vcc)\n{\n\treturn ((vcc->sap.blli[0].l3.tr9577.snap[4] == LEC_DATA_DIRECT_8023) ||\n\t\t(vcc->sap.blli[0].l3.tr9577.snap[4] == LEC_DATA_DIRECT_8025));\n}\n\nstatic void lec_push(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tunsigned long flags;\n\tstruct net_device *dev = (struct net_device *)vcc->proto_data;\n\tstruct lec_priv *priv = netdev_priv(dev);\n\n#if DUMP_PACKETS > 0\n\tprintk(KERN_DEBUG \"%s: vcc vpi:%d vci:%d\\n\",\n\t       dev->name, vcc->vpi, vcc->vci);\n#endif\n\tif (!skb) {\n\t\tpr_debug(\"%s: null skb\\n\", dev->name);\n\t\tlec_vcc_close(priv, vcc);\n\t\treturn;\n\t}\n#if DUMP_PACKETS >= 2\n#define MAX_SKB_DUMP 99\n#elif DUMP_PACKETS >= 1\n#define MAX_SKB_DUMP 30\n#endif\n#if DUMP_PACKETS > 0\n\tprintk(KERN_DEBUG \"%s: rcv datalen:%ld lecid:%4.4x\\n\",\n\t       dev->name, skb->len, priv->lecid);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_OFFSET, 16, 1,\n\t\t       skb->data, min(MAX_SKB_DUMP, skb->len), true);\n#endif  \n\tif (memcmp(skb->data, lec_ctrl_magic, 4) == 0) {\n\t\t\t\t \n\t\tstruct sock *sk = sk_atm(vcc);\n\n\t\tpr_debug(\"%s: To daemon\\n\", dev->name);\n\t\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tsk->sk_data_ready(sk);\n\t} else {\t\t \n\t\tstruct lec_arp_table *entry;\n\t\tunsigned char *src, *dst;\n\n\t\tatm_return(vcc, skb->truesize);\n\t\tif (*(__be16 *) skb->data == htons(priv->lecid) ||\n\t\t    !priv->lecd || !(dev->flags & IFF_UP)) {\n\t\t\t \n\t\t\tpr_debug(\"Ignoring frame...\\n\");\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tdst = ((struct lecdatahdr_8023 *)skb->data)->h_dest;\n\n\t\t \n\t\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\t\tif (lec_is_data_direct(vcc)) {\n\t\t\tsrc = ((struct lecdatahdr_8023 *)skb->data)->h_source;\n\t\t\tentry = lec_arp_find(priv, src);\n\t\t\tif (entry && entry->vcc != vcc) {\n\t\t\t\tlec_arp_remove(priv, entry);\n\t\t\t\tlec_arp_put(entry);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\n\t\tif (!(dst[0] & 0x01) &&\t \n\t\t    !priv->is_proxy &&\t \n\t\t    memcmp(dst, dev->dev_addr, dev->addr_len)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tif (!hlist_empty(&priv->lec_arp_empty_ones))\n\t\t\tlec_arp_check_empties(priv, vcc, skb);\n\t\tskb_pull(skb, 2);\t \n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += skb->len;\n\t\tmemset(ATM_SKB(skb), 0, sizeof(struct atm_skb_data));\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic void lec_pop(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tstruct lec_vcc_priv *vpriv = LEC_VCC_PRIV(vcc);\n\tstruct net_device *dev = skb->dev;\n\n\tif (vpriv == NULL) {\n\t\tpr_info(\"vpriv = NULL!?!?!?\\n\");\n\t\treturn;\n\t}\n\n\tvpriv->old_pop(vcc, skb);\n\n\tif (vpriv->xoff && atm_may_send(vcc, 0)) {\n\t\tvpriv->xoff = 0;\n\t\tif (netif_running(dev) && netif_queue_stopped(dev))\n\t\t\tnetif_wake_queue(dev);\n\t}\n}\n\nstatic int lec_vcc_attach(struct atm_vcc *vcc, void __user *arg)\n{\n\tstruct lec_vcc_priv *vpriv;\n\tint bytes_left;\n\tstruct atmlec_ioc ioc_data;\n\n\t \n\tbytes_left = copy_from_user(&ioc_data, arg, sizeof(struct atmlec_ioc));\n\tif (bytes_left != 0)\n\t\tpr_info(\"copy from user failed for %d bytes\\n\", bytes_left);\n\tif (ioc_data.dev_num < 0 || ioc_data.dev_num >= MAX_LEC_ITF)\n\t\treturn -EINVAL;\n\tioc_data.dev_num = array_index_nospec(ioc_data.dev_num, MAX_LEC_ITF);\n\tif (!dev_lec[ioc_data.dev_num])\n\t\treturn -EINVAL;\n\tvpriv = kmalloc(sizeof(struct lec_vcc_priv), GFP_KERNEL);\n\tif (!vpriv)\n\t\treturn -ENOMEM;\n\tvpriv->xoff = 0;\n\tvpriv->old_pop = vcc->pop;\n\tvcc->user_back = vpriv;\n\tvcc->pop = lec_pop;\n\tlec_vcc_added(netdev_priv(dev_lec[ioc_data.dev_num]),\n\t\t      &ioc_data, vcc, vcc->push);\n\tvcc->proto_data = dev_lec[ioc_data.dev_num];\n\tvcc->push = lec_push;\n\treturn 0;\n}\n\nstatic int lec_mcast_attach(struct atm_vcc *vcc, int arg)\n{\n\tif (arg < 0 || arg >= MAX_LEC_ITF)\n\t\treturn -EINVAL;\n\targ = array_index_nospec(arg, MAX_LEC_ITF);\n\tif (!dev_lec[arg])\n\t\treturn -EINVAL;\n\tvcc->proto_data = dev_lec[arg];\n\treturn lec_mcast_make(netdev_priv(dev_lec[arg]), vcc);\n}\n\n \nstatic int lecd_attach(struct atm_vcc *vcc, int arg)\n{\n\tint i;\n\tstruct lec_priv *priv;\n\n\tif (arg < 0)\n\t\targ = 0;\n\tif (arg >= MAX_LEC_ITF)\n\t\treturn -EINVAL;\n\ti = array_index_nospec(arg, MAX_LEC_ITF);\n\tif (!dev_lec[i]) {\n\t\tint size;\n\n\t\tsize = sizeof(struct lec_priv);\n\t\tdev_lec[i] = alloc_etherdev(size);\n\t\tif (!dev_lec[i])\n\t\t\treturn -ENOMEM;\n\t\tdev_lec[i]->netdev_ops = &lec_netdev_ops;\n\t\tdev_lec[i]->max_mtu = 18190;\n\t\tsnprintf(dev_lec[i]->name, IFNAMSIZ, \"lec%d\", i);\n\t\tif (register_netdev(dev_lec[i])) {\n\t\t\tfree_netdev(dev_lec[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv = netdev_priv(dev_lec[i]);\n\t} else {\n\t\tpriv = netdev_priv(dev_lec[i]);\n\t\tif (priv->lecd)\n\t\t\treturn -EADDRINUSE;\n\t}\n\tlec_arp_init(priv);\n\tpriv->itfnum = i;\t \n\tpriv->lecd = vcc;\n\tvcc->dev = &lecatm_dev;\n\tvcc_insert_socket(sk_atm(vcc));\n\n\tvcc->proto_data = dev_lec[i];\n\tset_bit(ATM_VF_META, &vcc->flags);\n\tset_bit(ATM_VF_READY, &vcc->flags);\n\n\t \n\tpriv->maximum_unknown_frame_count = 1;\n\tpriv->max_unknown_frame_time = (1 * HZ);\n\tpriv->vcc_timeout_period = (1200 * HZ);\n\tpriv->max_retry_count = 1;\n\tpriv->aging_time = (300 * HZ);\n\tpriv->forward_delay_time = (15 * HZ);\n\tpriv->topology_change = 0;\n\tpriv->arp_response_time = (1 * HZ);\n\tpriv->flush_timeout = (4 * HZ);\n\tpriv->path_switching_delay = (6 * HZ);\n\n\tif (dev_lec[i]->flags & IFF_UP)\n\t\tnetif_start_queue(dev_lec[i]);\n\t__module_get(THIS_MODULE);\n\treturn i;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic const char *lec_arp_get_status_string(unsigned char status)\n{\n\tstatic const char *const lec_arp_status_string[] = {\n\t\t\"ESI_UNKNOWN       \",\n\t\t\"ESI_ARP_PENDING   \",\n\t\t\"ESI_VC_PENDING    \",\n\t\t\"<Undefined>       \",\n\t\t\"ESI_FLUSH_PENDING \",\n\t\t\"ESI_FORWARD_DIRECT\"\n\t};\n\n\tif (status > ESI_FORWARD_DIRECT)\n\t\tstatus = 3;\t \n\treturn lec_arp_status_string[status];\n}\n\nstatic void lec_info(struct seq_file *seq, struct lec_arp_table *entry)\n{\n\tseq_printf(seq, \"%pM \", entry->mac_addr);\n\tseq_printf(seq, \"%*phN \", ATM_ESA_LEN, entry->atm_addr);\n\tseq_printf(seq, \"%s %4.4x\", lec_arp_get_status_string(entry->status),\n\t\t   entry->flags & 0xffff);\n\tif (entry->vcc)\n\t\tseq_printf(seq, \"%3d %3d \", entry->vcc->vpi, entry->vcc->vci);\n\telse\n\t\tseq_printf(seq, \"        \");\n\tif (entry->recv_vcc) {\n\t\tseq_printf(seq, \"     %3d %3d\", entry->recv_vcc->vpi,\n\t\t\t   entry->recv_vcc->vci);\n\t}\n\tseq_putc(seq, '\\n');\n}\n\nstruct lec_state {\n\tunsigned long flags;\n\tstruct lec_priv *locked;\n\tstruct hlist_node *node;\n\tstruct net_device *dev;\n\tint itf;\n\tint arp_table;\n\tint misc_table;\n};\n\nstatic void *lec_tbl_walk(struct lec_state *state, struct hlist_head *tbl,\n\t\t\t  loff_t *l)\n{\n\tstruct hlist_node *e = state->node;\n\n\tif (!e)\n\t\te = tbl->first;\n\tif (e == SEQ_START_TOKEN) {\n\t\te = tbl->first;\n\t\t--*l;\n\t}\n\n\tfor (; e; e = e->next) {\n\t\tif (--*l < 0)\n\t\t\tbreak;\n\t}\n\tstate->node = e;\n\n\treturn (*l < 0) ? state : NULL;\n}\n\nstatic void *lec_arp_walk(struct lec_state *state, loff_t *l,\n\t\t\t  struct lec_priv *priv)\n{\n\tvoid *v = NULL;\n\tint p;\n\n\tfor (p = state->arp_table; p < LEC_ARP_TABLE_SIZE; p++) {\n\t\tv = lec_tbl_walk(state, &priv->lec_arp_tables[p], l);\n\t\tif (v)\n\t\t\tbreak;\n\t}\n\tstate->arp_table = p;\n\treturn v;\n}\n\nstatic void *lec_misc_walk(struct lec_state *state, loff_t *l,\n\t\t\t   struct lec_priv *priv)\n{\n\tstruct hlist_head *lec_misc_tables[] = {\n\t\t&priv->lec_arp_empty_ones,\n\t\t&priv->lec_no_forward,\n\t\t&priv->mcast_fwds\n\t};\n\tvoid *v = NULL;\n\tint q;\n\n\tfor (q = state->misc_table; q < ARRAY_SIZE(lec_misc_tables); q++) {\n\t\tv = lec_tbl_walk(state, lec_misc_tables[q], l);\n\t\tif (v)\n\t\t\tbreak;\n\t}\n\tstate->misc_table = q;\n\treturn v;\n}\n\nstatic void *lec_priv_walk(struct lec_state *state, loff_t *l,\n\t\t\t   struct lec_priv *priv)\n{\n\tif (!state->locked) {\n\t\tstate->locked = priv;\n\t\tspin_lock_irqsave(&priv->lec_arp_lock, state->flags);\n\t}\n\tif (!lec_arp_walk(state, l, priv) && !lec_misc_walk(state, l, priv)) {\n\t\tspin_unlock_irqrestore(&priv->lec_arp_lock, state->flags);\n\t\tstate->locked = NULL;\n\t\t \n\t\tstate->arp_table = state->misc_table = 0;\n\t}\n\treturn state->locked;\n}\n\nstatic void *lec_itf_walk(struct lec_state *state, loff_t *l)\n{\n\tstruct net_device *dev;\n\tvoid *v;\n\n\tdev = state->dev ? state->dev : dev_lec[state->itf];\n\tv = (dev && netdev_priv(dev)) ?\n\t\tlec_priv_walk(state, l, netdev_priv(dev)) : NULL;\n\tif (!v && dev) {\n\t\tdev_put(dev);\n\t\t \n\t\tdev = NULL;\n\t}\n\tstate->dev = dev;\n\treturn v;\n}\n\nstatic void *lec_get_idx(struct lec_state *state, loff_t l)\n{\n\tvoid *v = NULL;\n\n\tfor (; state->itf < MAX_LEC_ITF; state->itf++) {\n\t\tv = lec_itf_walk(state, &l);\n\t\tif (v)\n\t\t\tbreak;\n\t}\n\treturn v;\n}\n\nstatic void *lec_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct lec_state *state = seq->private;\n\n\tstate->itf = 0;\n\tstate->dev = NULL;\n\tstate->locked = NULL;\n\tstate->arp_table = 0;\n\tstate->misc_table = 0;\n\tstate->node = SEQ_START_TOKEN;\n\n\treturn *pos ? lec_get_idx(state, *pos) : SEQ_START_TOKEN;\n}\n\nstatic void lec_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct lec_state *state = seq->private;\n\n\tif (state->dev) {\n\t\tspin_unlock_irqrestore(&state->locked->lec_arp_lock,\n\t\t\t\t       state->flags);\n\t\tdev_put(state->dev);\n\t}\n}\n\nstatic void *lec_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct lec_state *state = seq->private;\n\n\t++*pos;\n\treturn lec_get_idx(state, 1);\n}\n\nstatic int lec_seq_show(struct seq_file *seq, void *v)\n{\n\tstatic const char lec_banner[] =\n\t    \"Itf  MAC          ATM destination\"\n\t    \"                          Status            Flags \"\n\t    \"VPI/VCI Recv VPI/VCI\\n\";\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, lec_banner);\n\telse {\n\t\tstruct lec_state *state = seq->private;\n\t\tstruct net_device *dev = state->dev;\n\t\tstruct lec_arp_table *entry = hlist_entry(state->node,\n\t\t\t\t\t\t\t  struct lec_arp_table,\n\t\t\t\t\t\t\t  next);\n\n\t\tseq_printf(seq, \"%s \", dev->name);\n\t\tlec_info(seq, entry);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations lec_seq_ops = {\n\t.start = lec_seq_start,\n\t.next = lec_seq_next,\n\t.stop = lec_seq_stop,\n\t.show = lec_seq_show,\n};\n#endif\n\nstatic int lane_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint err = 0;\n\n\tswitch (cmd) {\n\tcase ATMLEC_CTRL:\n\tcase ATMLEC_MCAST:\n\tcase ATMLEC_DATA:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\tswitch (cmd) {\n\tcase ATMLEC_CTRL:\n\t\terr = lecd_attach(vcc, (int)arg);\n\t\tif (err >= 0)\n\t\t\tsock->state = SS_CONNECTED;\n\t\tbreak;\n\tcase ATMLEC_MCAST:\n\t\terr = lec_mcast_attach(vcc, (int)arg);\n\t\tbreak;\n\tcase ATMLEC_DATA:\n\t\terr = lec_vcc_attach(vcc, (void __user *)arg);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic struct atm_ioctl lane_ioctl_ops = {\n\t.owner = THIS_MODULE,\n\t.ioctl = lane_ioctl,\n};\n\nstatic int __init lane_module_init(void)\n{\n#ifdef CONFIG_PROC_FS\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_seq_private(\"lec\", 0444, atm_proc_root, &lec_seq_ops,\n\t\t\tsizeof(struct lec_state), NULL);\n\tif (!p) {\n\t\tpr_err(\"Unable to initialize /proc/net/atm/lec\\n\");\n\t\treturn -ENOMEM;\n\t}\n#endif\n\n\tregister_atm_ioctl(&lane_ioctl_ops);\n\tpr_info(\"lec.c: initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit lane_module_cleanup(void)\n{\n\tint i;\n\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"lec\", atm_proc_root);\n#endif\n\n\tderegister_atm_ioctl(&lane_ioctl_ops);\n\n\tfor (i = 0; i < MAX_LEC_ITF; i++) {\n\t\tif (dev_lec[i] != NULL) {\n\t\t\tunregister_netdev(dev_lec[i]);\n\t\t\tfree_netdev(dev_lec[i]);\n\t\t\tdev_lec[i] = NULL;\n\t\t}\n\t}\n}\n\nmodule_init(lane_module_init);\nmodule_exit(lane_module_cleanup);\n\n \nstatic int lane2_resolve(struct net_device *dev, const u8 *dst_mac, int force,\n\t\t\t u8 **tlvs, u32 *sizeoftlvs)\n{\n\tunsigned long flags;\n\tstruct lec_priv *priv = netdev_priv(dev);\n\tstruct lec_arp_table *table;\n\tstruct sk_buff *skb;\n\tint retval;\n\n\tif (force == 0) {\n\t\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\t\ttable = lec_arp_find(priv, dst_mac);\n\t\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\t\tif (table == NULL)\n\t\t\treturn -1;\n\n\t\t*tlvs = kmemdup(table->tlvs, table->sizeoftlvs, GFP_ATOMIC);\n\t\tif (*tlvs == NULL)\n\t\t\treturn -1;\n\n\t\t*sizeoftlvs = table->sizeoftlvs;\n\n\t\treturn 0;\n\t}\n\n\tif (sizeoftlvs == NULL)\n\t\tretval = send_to_lecd(priv, l_arp_xmt, dst_mac, NULL, NULL);\n\n\telse {\n\t\tskb = alloc_skb(*sizeoftlvs, GFP_ATOMIC);\n\t\tif (skb == NULL)\n\t\t\treturn -1;\n\t\tskb->len = *sizeoftlvs;\n\t\tskb_copy_to_linear_data(skb, *tlvs, *sizeoftlvs);\n\t\tretval = send_to_lecd(priv, l_arp_xmt, dst_mac, NULL, skb);\n\t}\n\treturn retval;\n}\n\n \nstatic int lane2_associate_req(struct net_device *dev, const u8 *lan_dst,\n\t\t\t       const u8 *tlvs, u32 sizeoftlvs)\n{\n\tint retval;\n\tstruct sk_buff *skb;\n\tstruct lec_priv *priv = netdev_priv(dev);\n\n\tif (!ether_addr_equal(lan_dst, dev->dev_addr))\n\t\treturn 0;\t \n\n\tkfree(priv->tlvs);\t \n\n\tpriv->tlvs = kmemdup(tlvs, sizeoftlvs, GFP_KERNEL);\n\tif (priv->tlvs == NULL)\n\t\treturn 0;\n\tpriv->sizeoftlvs = sizeoftlvs;\n\n\tskb = alloc_skb(sizeoftlvs, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn 0;\n\tskb->len = sizeoftlvs;\n\tskb_copy_to_linear_data(skb, tlvs, sizeoftlvs);\n\tretval = send_to_lecd(priv, l_associate_req, NULL, NULL, skb);\n\tif (retval != 0)\n\t\tpr_info(\"lec.c: lane2_associate_req() failed\\n\");\n\t \n\treturn 1;\n}\n\n \nstatic void lane2_associate_ind(struct net_device *dev, const u8 *mac_addr,\n\t\t\t\tconst u8 *tlvs, u32 sizeoftlvs)\n{\n#if 0\n\tint i = 0;\n#endif\n\tstruct lec_priv *priv = netdev_priv(dev);\n#if 0\t\t\t\t \n\tstruct lec_arp_table *entry = lec_arp_find(priv, mac_addr);\n\n\tif (entry == NULL)\n\t\treturn;\t\t \n\n\tkfree(entry->tlvs);\n\n\tentry->tlvs = kmemdup(tlvs, sizeoftlvs, GFP_KERNEL);\n\tif (entry->tlvs == NULL)\n\t\treturn;\n\tentry->sizeoftlvs = sizeoftlvs;\n#endif\n#if 0\n\tpr_info(\"\\n\");\n\tpr_info(\"dump of tlvs, sizeoftlvs=%d\\n\", sizeoftlvs);\n\twhile (i < sizeoftlvs)\n\t\tpr_cont(\"%02x \", tlvs[i++]);\n\n\tpr_cont(\"\\n\");\n#endif\n\n\t \n\tif (priv->lane2_ops && priv->lane2_ops->associate_indicator) {\n\t\tpriv->lane2_ops->associate_indicator(dev, mac_addr,\n\t\t\t\t\t\t     tlvs, sizeoftlvs);\n\t}\n}\n\n \n\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/param.h>\n#include <linux/atomic.h>\n#include <linux/inetdevice.h>\n#include <net/route.h>\n\n#if 0\n#define pr_debug(format, args...)\n \n#endif\n#define DEBUG_ARP_TABLE 0\n\n#define LEC_ARP_REFRESH_INTERVAL (3*HZ)\n\nstatic void lec_arp_check_expire(struct work_struct *work);\nstatic void lec_arp_expire_arp(struct timer_list *t);\n\n \n\n#define HASH(ch) (ch & (LEC_ARP_TABLE_SIZE - 1))\n\n \nstatic void lec_arp_init(struct lec_priv *priv)\n{\n\tunsigned short i;\n\n\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&priv->lec_arp_tables[i]);\n\tINIT_HLIST_HEAD(&priv->lec_arp_empty_ones);\n\tINIT_HLIST_HEAD(&priv->lec_no_forward);\n\tINIT_HLIST_HEAD(&priv->mcast_fwds);\n\tspin_lock_init(&priv->lec_arp_lock);\n\tINIT_DELAYED_WORK(&priv->lec_arp_work, lec_arp_check_expire);\n\tschedule_delayed_work(&priv->lec_arp_work, LEC_ARP_REFRESH_INTERVAL);\n}\n\nstatic void lec_arp_clear_vccs(struct lec_arp_table *entry)\n{\n\tif (entry->vcc) {\n\t\tstruct atm_vcc *vcc = entry->vcc;\n\t\tstruct lec_vcc_priv *vpriv = LEC_VCC_PRIV(vcc);\n\t\tstruct net_device *dev = (struct net_device *)vcc->proto_data;\n\n\t\tvcc->pop = vpriv->old_pop;\n\t\tif (vpriv->xoff)\n\t\t\tnetif_wake_queue(dev);\n\t\tkfree(vpriv);\n\t\tvcc->user_back = NULL;\n\t\tvcc->push = entry->old_push;\n\t\tvcc_release_async(vcc, -EPIPE);\n\t\tentry->vcc = NULL;\n\t}\n\tif (entry->recv_vcc) {\n\t\tstruct atm_vcc *vcc = entry->recv_vcc;\n\t\tstruct lec_vcc_priv *vpriv = LEC_VCC_PRIV(vcc);\n\n\t\tkfree(vpriv);\n\t\tvcc->user_back = NULL;\n\n\t\tentry->recv_vcc->push = entry->old_recv_push;\n\t\tvcc_release_async(entry->recv_vcc, -EPIPE);\n\t\tentry->recv_vcc = NULL;\n\t}\n}\n\n \nstatic inline void\nlec_arp_add(struct lec_priv *priv, struct lec_arp_table *entry)\n{\n\tstruct hlist_head *tmp;\n\n\ttmp = &priv->lec_arp_tables[HASH(entry->mac_addr[ETH_ALEN - 1])];\n\thlist_add_head(&entry->next, tmp);\n\n\tpr_debug(\"Added entry:%pM\\n\", entry->mac_addr);\n}\n\n \nstatic int\nlec_arp_remove(struct lec_priv *priv, struct lec_arp_table *to_remove)\n{\n\tstruct lec_arp_table *entry;\n\tint i, remove_vcc = 1;\n\n\tif (!to_remove)\n\t\treturn -1;\n\n\thlist_del(&to_remove->next);\n\tdel_timer(&to_remove->timer);\n\n\t \n\tif (to_remove->status >= ESI_FLUSH_PENDING) {\n\t\t \n\t\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\n\t\t\thlist_for_each_entry(entry,\n\t\t\t\t\t     &priv->lec_arp_tables[i], next) {\n\t\t\t\tif (memcmp(to_remove->atm_addr,\n\t\t\t\t\t   entry->atm_addr, ATM_ESA_LEN) == 0) {\n\t\t\t\t\tremove_vcc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (remove_vcc)\n\t\t\tlec_arp_clear_vccs(to_remove);\n\t}\n\tskb_queue_purge(&to_remove->tx_wait);\t \n\n\tpr_debug(\"Removed entry:%pM\\n\", to_remove->mac_addr);\n\treturn 0;\n}\n\n#if DEBUG_ARP_TABLE\nstatic const char *get_status_string(unsigned char st)\n{\n\tswitch (st) {\n\tcase ESI_UNKNOWN:\n\t\treturn \"ESI_UNKNOWN\";\n\tcase ESI_ARP_PENDING:\n\t\treturn \"ESI_ARP_PENDING\";\n\tcase ESI_VC_PENDING:\n\t\treturn \"ESI_VC_PENDING\";\n\tcase ESI_FLUSH_PENDING:\n\t\treturn \"ESI_FLUSH_PENDING\";\n\tcase ESI_FORWARD_DIRECT:\n\t\treturn \"ESI_FORWARD_DIRECT\";\n\t}\n\treturn \"<UNKNOWN>\";\n}\n\nstatic void dump_arp_table(struct lec_priv *priv)\n{\n\tstruct lec_arp_table *rulla;\n\tchar buf[256];\n\tint i, offset;\n\n\tpr_info(\"Dump %p:\\n\", priv);\n\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\n\t\thlist_for_each_entry(rulla,\n\t\t\t\t     &priv->lec_arp_tables[i], next) {\n\t\t\toffset = 0;\n\t\t\toffset += sprintf(buf, \"%d: %p\\n\", i, rulla);\n\t\t\toffset += sprintf(buf + offset, \"Mac: %pM \",\n\t\t\t\t\t  rulla->mac_addr);\n\t\t\toffset += sprintf(buf + offset, \"Atm: %*ph \", ATM_ESA_LEN,\n\t\t\t\t\t  rulla->atm_addr);\n\t\t\toffset += sprintf(buf + offset,\n\t\t\t\t\t  \"Vcc vpi:%d vci:%d, Recv_vcc vpi:%d vci:%d Last_used:%lx, Timestamp:%lx, No_tries:%d \",\n\t\t\t\t\t  rulla->vcc ? rulla->vcc->vpi : 0,\n\t\t\t\t\t  rulla->vcc ? rulla->vcc->vci : 0,\n\t\t\t\t\t  rulla->recv_vcc ? rulla->recv_vcc->\n\t\t\t\t\t  vpi : 0,\n\t\t\t\t\t  rulla->recv_vcc ? rulla->recv_vcc->\n\t\t\t\t\t  vci : 0, rulla->last_used,\n\t\t\t\t\t  rulla->timestamp, rulla->no_tries);\n\t\t\toffset +=\n\t\t\t    sprintf(buf + offset,\n\t\t\t\t    \"Flags:%x, Packets_flooded:%x, Status: %s \",\n\t\t\t\t    rulla->flags, rulla->packets_flooded,\n\t\t\t\t    get_status_string(rulla->status));\n\t\t\tpr_info(\"%s\\n\", buf);\n\t\t}\n\t}\n\n\tif (!hlist_empty(&priv->lec_no_forward))\n\t\tpr_info(\"No forward\\n\");\n\thlist_for_each_entry(rulla, &priv->lec_no_forward, next) {\n\t\toffset = 0;\n\t\toffset += sprintf(buf + offset, \"Mac: %pM \", rulla->mac_addr);\n\t\toffset += sprintf(buf + offset, \"Atm: %*ph \", ATM_ESA_LEN,\n\t\t\t\t  rulla->atm_addr);\n\t\toffset += sprintf(buf + offset,\n\t\t\t\t  \"Vcc vpi:%d vci:%d, Recv_vcc vpi:%d vci:%d Last_used:%lx, Timestamp:%lx, No_tries:%d \",\n\t\t\t\t  rulla->vcc ? rulla->vcc->vpi : 0,\n\t\t\t\t  rulla->vcc ? rulla->vcc->vci : 0,\n\t\t\t\t  rulla->recv_vcc ? rulla->recv_vcc->vpi : 0,\n\t\t\t\t  rulla->recv_vcc ? rulla->recv_vcc->vci : 0,\n\t\t\t\t  rulla->last_used,\n\t\t\t\t  rulla->timestamp, rulla->no_tries);\n\t\toffset += sprintf(buf + offset,\n\t\t\t\t  \"Flags:%x, Packets_flooded:%x, Status: %s \",\n\t\t\t\t  rulla->flags, rulla->packets_flooded,\n\t\t\t\t  get_status_string(rulla->status));\n\t\tpr_info(\"%s\\n\", buf);\n\t}\n\n\tif (!hlist_empty(&priv->lec_arp_empty_ones))\n\t\tpr_info(\"Empty ones\\n\");\n\thlist_for_each_entry(rulla, &priv->lec_arp_empty_ones, next) {\n\t\toffset = 0;\n\t\toffset += sprintf(buf + offset, \"Mac: %pM \", rulla->mac_addr);\n\t\toffset += sprintf(buf + offset, \"Atm: %*ph \", ATM_ESA_LEN,\n\t\t\t\t  rulla->atm_addr);\n\t\toffset += sprintf(buf + offset,\n\t\t\t\t  \"Vcc vpi:%d vci:%d, Recv_vcc vpi:%d vci:%d Last_used:%lx, Timestamp:%lx, No_tries:%d \",\n\t\t\t\t  rulla->vcc ? rulla->vcc->vpi : 0,\n\t\t\t\t  rulla->vcc ? rulla->vcc->vci : 0,\n\t\t\t\t  rulla->recv_vcc ? rulla->recv_vcc->vpi : 0,\n\t\t\t\t  rulla->recv_vcc ? rulla->recv_vcc->vci : 0,\n\t\t\t\t  rulla->last_used,\n\t\t\t\t  rulla->timestamp, rulla->no_tries);\n\t\toffset += sprintf(buf + offset,\n\t\t\t\t  \"Flags:%x, Packets_flooded:%x, Status: %s \",\n\t\t\t\t  rulla->flags, rulla->packets_flooded,\n\t\t\t\t  get_status_string(rulla->status));\n\t\tpr_info(\"%s\", buf);\n\t}\n\n\tif (!hlist_empty(&priv->mcast_fwds))\n\t\tpr_info(\"Multicast Forward VCCs\\n\");\n\thlist_for_each_entry(rulla, &priv->mcast_fwds, next) {\n\t\toffset = 0;\n\t\toffset += sprintf(buf + offset, \"Mac: %pM \", rulla->mac_addr);\n\t\toffset += sprintf(buf + offset, \"Atm: %*ph \", ATM_ESA_LEN,\n\t\t\t\t  rulla->atm_addr);\n\t\toffset += sprintf(buf + offset,\n\t\t\t\t  \"Vcc vpi:%d vci:%d, Recv_vcc vpi:%d vci:%d Last_used:%lx, Timestamp:%lx, No_tries:%d \",\n\t\t\t\t  rulla->vcc ? rulla->vcc->vpi : 0,\n\t\t\t\t  rulla->vcc ? rulla->vcc->vci : 0,\n\t\t\t\t  rulla->recv_vcc ? rulla->recv_vcc->vpi : 0,\n\t\t\t\t  rulla->recv_vcc ? rulla->recv_vcc->vci : 0,\n\t\t\t\t  rulla->last_used,\n\t\t\t\t  rulla->timestamp, rulla->no_tries);\n\t\toffset += sprintf(buf + offset,\n\t\t\t\t  \"Flags:%x, Packets_flooded:%x, Status: %s \",\n\t\t\t\t  rulla->flags, rulla->packets_flooded,\n\t\t\t\t  get_status_string(rulla->status));\n\t\tpr_info(\"%s\\n\", buf);\n\t}\n\n}\n#else\n#define dump_arp_table(priv) do { } while (0)\n#endif\n\n \nstatic void lec_arp_destroy(struct lec_priv *priv)\n{\n\tunsigned long flags;\n\tstruct hlist_node *next;\n\tstruct lec_arp_table *entry;\n\tint i;\n\n\tcancel_delayed_work_sync(&priv->lec_arp_work);\n\n\t \n\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\n\t\thlist_for_each_entry_safe(entry, next,\n\t\t\t\t\t  &priv->lec_arp_tables[i], next) {\n\t\t\tlec_arp_remove(priv, entry);\n\t\t\tlec_arp_put(entry);\n\t\t}\n\t\tINIT_HLIST_HEAD(&priv->lec_arp_tables[i]);\n\t}\n\n\thlist_for_each_entry_safe(entry, next,\n\t\t\t\t  &priv->lec_arp_empty_ones, next) {\n\t\tdel_timer_sync(&entry->timer);\n\t\tlec_arp_clear_vccs(entry);\n\t\thlist_del(&entry->next);\n\t\tlec_arp_put(entry);\n\t}\n\tINIT_HLIST_HEAD(&priv->lec_arp_empty_ones);\n\n\thlist_for_each_entry_safe(entry, next,\n\t\t\t\t  &priv->lec_no_forward, next) {\n\t\tdel_timer_sync(&entry->timer);\n\t\tlec_arp_clear_vccs(entry);\n\t\thlist_del(&entry->next);\n\t\tlec_arp_put(entry);\n\t}\n\tINIT_HLIST_HEAD(&priv->lec_no_forward);\n\n\thlist_for_each_entry_safe(entry, next, &priv->mcast_fwds, next) {\n\t\t \n\t\tlec_arp_clear_vccs(entry);\n\t\thlist_del(&entry->next);\n\t\tlec_arp_put(entry);\n\t}\n\tINIT_HLIST_HEAD(&priv->mcast_fwds);\n\tpriv->mcast_vcc = NULL;\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n}\n\n \nstatic struct lec_arp_table *lec_arp_find(struct lec_priv *priv,\n\t\t\t\t\t  const unsigned char *mac_addr)\n{\n\tstruct hlist_head *head;\n\tstruct lec_arp_table *entry;\n\n\tpr_debug(\"%pM\\n\", mac_addr);\n\n\thead = &priv->lec_arp_tables[HASH(mac_addr[ETH_ALEN - 1])];\n\thlist_for_each_entry(entry, head, next) {\n\t\tif (ether_addr_equal(mac_addr, entry->mac_addr))\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic struct lec_arp_table *make_entry(struct lec_priv *priv,\n\t\t\t\t\tconst unsigned char *mac_addr)\n{\n\tstruct lec_arp_table *to_return;\n\n\tto_return = kzalloc(sizeof(struct lec_arp_table), GFP_ATOMIC);\n\tif (!to_return)\n\t\treturn NULL;\n\tether_addr_copy(to_return->mac_addr, mac_addr);\n\tINIT_HLIST_NODE(&to_return->next);\n\ttimer_setup(&to_return->timer, lec_arp_expire_arp, 0);\n\tto_return->last_used = jiffies;\n\tto_return->priv = priv;\n\tskb_queue_head_init(&to_return->tx_wait);\n\trefcount_set(&to_return->usage, 1);\n\treturn to_return;\n}\n\n \nstatic void lec_arp_expire_arp(struct timer_list *t)\n{\n\tstruct lec_arp_table *entry;\n\n\tentry = from_timer(entry, t, timer);\n\n\tpr_debug(\"\\n\");\n\tif (entry->status == ESI_ARP_PENDING) {\n\t\tif (entry->no_tries <= entry->priv->max_retry_count) {\n\t\t\tif (entry->is_rdesc)\n\t\t\t\tsend_to_lecd(entry->priv, l_rdesc_arp_xmt,\n\t\t\t\t\t     entry->mac_addr, NULL, NULL);\n\t\t\telse\n\t\t\t\tsend_to_lecd(entry->priv, l_arp_xmt,\n\t\t\t\t\t     entry->mac_addr, NULL, NULL);\n\t\t\tentry->no_tries++;\n\t\t}\n\t\tmod_timer(&entry->timer, jiffies + (1 * HZ));\n\t}\n}\n\n \nstatic void lec_arp_expire_vcc(struct timer_list *t)\n{\n\tunsigned long flags;\n\tstruct lec_arp_table *to_remove = from_timer(to_remove, t, timer);\n\tstruct lec_priv *priv = to_remove->priv;\n\n\tdel_timer(&to_remove->timer);\n\n\tpr_debug(\"%p %p: vpi:%d vci:%d\\n\",\n\t\t to_remove, priv,\n\t\t to_remove->vcc ? to_remove->recv_vcc->vpi : 0,\n\t\t to_remove->vcc ? to_remove->recv_vcc->vci : 0);\n\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\thlist_del(&to_remove->next);\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\n\tlec_arp_clear_vccs(to_remove);\n\tlec_arp_put(to_remove);\n}\n\nstatic bool __lec_arp_check_expire(struct lec_arp_table *entry,\n\t\t\t\t   unsigned long now,\n\t\t\t\t   struct lec_priv *priv)\n{\n\tunsigned long time_to_check;\n\n\tif ((entry->flags) & LEC_REMOTE_FLAG && priv->topology_change)\n\t\ttime_to_check = priv->forward_delay_time;\n\telse\n\t\ttime_to_check = priv->aging_time;\n\n\tpr_debug(\"About to expire: %lx - %lx > %lx\\n\",\n\t\t now, entry->last_used, time_to_check);\n\tif (time_after(now, entry->last_used + time_to_check) &&\n\t    !(entry->flags & LEC_PERMANENT_FLAG) &&\n\t    !(entry->mac_addr[0] & 0x01)) {\t \n\t\t \n\t\tpr_debug(\"Entry timed out\\n\");\n\t\tlec_arp_remove(priv, entry);\n\t\tlec_arp_put(entry);\n\t} else {\n\t\t \n\t\tif ((entry->status == ESI_VC_PENDING ||\n\t\t     entry->status == ESI_ARP_PENDING) &&\n\t\t    time_after_eq(now, entry->timestamp +\n\t\t\t\t       priv->max_unknown_frame_time)) {\n\t\t\tentry->timestamp = jiffies;\n\t\t\tentry->packets_flooded = 0;\n\t\t\tif (entry->status == ESI_VC_PENDING)\n\t\t\t\tsend_to_lecd(priv, l_svc_setup,\n\t\t\t\t\t     entry->mac_addr,\n\t\t\t\t\t     entry->atm_addr,\n\t\t\t\t\t     NULL);\n\t\t}\n\t\tif (entry->status == ESI_FLUSH_PENDING &&\n\t\t    time_after_eq(now, entry->timestamp +\n\t\t\t\t       priv->path_switching_delay)) {\n\t\t\tlec_arp_hold(entry);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n \nstatic void lec_arp_check_expire(struct work_struct *work)\n{\n\tunsigned long flags;\n\tstruct lec_priv *priv =\n\t\tcontainer_of(work, struct lec_priv, lec_arp_work.work);\n\tstruct hlist_node *next;\n\tstruct lec_arp_table *entry;\n\tunsigned long now;\n\tint i;\n\n\tpr_debug(\"%p\\n\", priv);\n\tnow = jiffies;\nrestart:\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\n\t\thlist_for_each_entry_safe(entry, next,\n\t\t\t\t\t  &priv->lec_arp_tables[i], next) {\n\t\t\tif (__lec_arp_check_expire(entry, now, priv)) {\n\t\t\t\tstruct sk_buff *skb;\n\t\t\t\tstruct atm_vcc *vcc = entry->vcc;\n\n\t\t\t\tspin_unlock_irqrestore(&priv->lec_arp_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\twhile ((skb = skb_dequeue(&entry->tx_wait)))\n\t\t\t\t\tlec_send(vcc, skb);\n\t\t\t\tentry->last_used = jiffies;\n\t\t\t\tentry->status = ESI_FORWARD_DIRECT;\n\t\t\t\tlec_arp_put(entry);\n\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\n\tschedule_delayed_work(&priv->lec_arp_work, LEC_ARP_REFRESH_INTERVAL);\n}\n\n \nstatic struct atm_vcc *lec_arp_resolve(struct lec_priv *priv,\n\t\t\t\t       const unsigned char *mac_to_find,\n\t\t\t\t       int is_rdesc,\n\t\t\t\t       struct lec_arp_table **ret_entry)\n{\n\tunsigned long flags;\n\tstruct lec_arp_table *entry;\n\tstruct atm_vcc *found;\n\n\tif (mac_to_find[0] & 0x01) {\n\t\tswitch (priv->lane_version) {\n\t\tcase 1:\n\t\t\treturn priv->mcast_vcc;\n\t\tcase 2:\t \n\t\t\tif (ether_addr_equal(mac_to_find, bus_mac))\n\t\t\t\treturn priv->mcast_vcc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\tentry = lec_arp_find(priv, mac_to_find);\n\n\tif (entry) {\n\t\tif (entry->status == ESI_FORWARD_DIRECT) {\n\t\t\t \n\t\t\tentry->last_used = jiffies;\n\t\t\tlec_arp_hold(entry);\n\t\t\t*ret_entry = entry;\n\t\t\tfound = entry->vcc;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (entry->status == ESI_ARP_PENDING)\n\t\t\tentry->no_tries = 0;\n\t\t \n\t\tif (entry->status != ESI_FLUSH_PENDING &&\n\t\t    entry->packets_flooded <\n\t\t    priv->maximum_unknown_frame_count) {\n\t\t\tentry->packets_flooded++;\n\t\t\tpr_debug(\"Flooding..\\n\");\n\t\t\tfound = priv->mcast_vcc;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tlec_arp_hold(entry);\n\t\t*ret_entry = entry;\n\t\tpr_debug(\"entry->status %d entry->vcc %p\\n\", entry->status,\n\t\t\t entry->vcc);\n\t\tfound = NULL;\n\t} else {\n\t\t \n\t\tentry = make_entry(priv, mac_to_find);\n\t\tpr_debug(\"Making entry\\n\");\n\t\tif (!entry) {\n\t\t\tfound = priv->mcast_vcc;\n\t\t\tgoto out;\n\t\t}\n\t\tlec_arp_add(priv, entry);\n\t\t \n\t\tentry->packets_flooded = 1;\n\t\tentry->status = ESI_ARP_PENDING;\n\t\tentry->no_tries = 1;\n\t\tentry->last_used = entry->timestamp = jiffies;\n\t\tentry->is_rdesc = is_rdesc;\n\t\tif (entry->is_rdesc)\n\t\t\tsend_to_lecd(priv, l_rdesc_arp_xmt, mac_to_find, NULL,\n\t\t\t\t     NULL);\n\t\telse\n\t\t\tsend_to_lecd(priv, l_arp_xmt, mac_to_find, NULL, NULL);\n\t\tentry->timer.expires = jiffies + (1 * HZ);\n\t\tentry->timer.function = lec_arp_expire_arp;\n\t\tadd_timer(&entry->timer);\n\t\tfound = priv->mcast_vcc;\n\t}\n\nout:\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\treturn found;\n}\n\nstatic int\nlec_addr_delete(struct lec_priv *priv, const unsigned char *atm_addr,\n\t\tunsigned long permanent)\n{\n\tunsigned long flags;\n\tstruct hlist_node *next;\n\tstruct lec_arp_table *entry;\n\tint i;\n\n\tpr_debug(\"\\n\");\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\n\t\thlist_for_each_entry_safe(entry, next,\n\t\t\t\t\t  &priv->lec_arp_tables[i], next) {\n\t\t\tif (!memcmp(atm_addr, entry->atm_addr, ATM_ESA_LEN) &&\n\t\t\t    (permanent ||\n\t\t\t     !(entry->flags & LEC_PERMANENT_FLAG))) {\n\t\t\t\tlec_arp_remove(priv, entry);\n\t\t\t\tlec_arp_put(entry);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\treturn -1;\n}\n\n \nstatic void\nlec_arp_update(struct lec_priv *priv, const unsigned char *mac_addr,\n\t       const unsigned char *atm_addr, unsigned long remoteflag,\n\t       unsigned int targetless_le_arp)\n{\n\tunsigned long flags;\n\tstruct hlist_node *next;\n\tstruct lec_arp_table *entry, *tmp;\n\tint i;\n\n\tpr_debug(\"%smac:%pM\\n\",\n\t\t (targetless_le_arp) ? \"targetless \" : \"\", mac_addr);\n\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\tentry = lec_arp_find(priv, mac_addr);\n\tif (entry == NULL && targetless_le_arp)\n\t\tgoto out;\t \n\tif (!hlist_empty(&priv->lec_arp_empty_ones)) {\n\t\thlist_for_each_entry_safe(entry, next,\n\t\t\t\t\t  &priv->lec_arp_empty_ones, next) {\n\t\t\tif (memcmp(entry->atm_addr, atm_addr, ATM_ESA_LEN) == 0) {\n\t\t\t\thlist_del(&entry->next);\n\t\t\t\tdel_timer(&entry->timer);\n\t\t\t\ttmp = lec_arp_find(priv, mac_addr);\n\t\t\t\tif (tmp) {\n\t\t\t\t\tdel_timer(&tmp->timer);\n\t\t\t\t\ttmp->status = ESI_FORWARD_DIRECT;\n\t\t\t\t\tmemcpy(tmp->atm_addr, atm_addr, ATM_ESA_LEN);\n\t\t\t\t\ttmp->vcc = entry->vcc;\n\t\t\t\t\ttmp->old_push = entry->old_push;\n\t\t\t\t\ttmp->last_used = jiffies;\n\t\t\t\t\tdel_timer(&entry->timer);\n\t\t\t\t\tlec_arp_put(entry);\n\t\t\t\t\tentry = tmp;\n\t\t\t\t} else {\n\t\t\t\t\tentry->status = ESI_FORWARD_DIRECT;\n\t\t\t\t\tether_addr_copy(entry->mac_addr,\n\t\t\t\t\t\t\tmac_addr);\n\t\t\t\t\tentry->last_used = jiffies;\n\t\t\t\t\tlec_arp_add(priv, entry);\n\t\t\t\t}\n\t\t\t\tif (remoteflag)\n\t\t\t\t\tentry->flags |= LEC_REMOTE_FLAG;\n\t\t\t\telse\n\t\t\t\t\tentry->flags &= ~LEC_REMOTE_FLAG;\n\t\t\t\tpr_debug(\"After update\\n\");\n\t\t\t\tdump_arp_table(priv);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tentry = lec_arp_find(priv, mac_addr);\n\tif (!entry) {\n\t\tentry = make_entry(priv, mac_addr);\n\t\tif (!entry)\n\t\t\tgoto out;\n\t\tentry->status = ESI_UNKNOWN;\n\t\tlec_arp_add(priv, entry);\n\t\t \n\t}\n\tmemcpy(entry->atm_addr, atm_addr, ATM_ESA_LEN);\n\tdel_timer(&entry->timer);\n\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\n\t\thlist_for_each_entry(tmp,\n\t\t\t\t     &priv->lec_arp_tables[i], next) {\n\t\t\tif (entry != tmp &&\n\t\t\t    !memcmp(tmp->atm_addr, atm_addr, ATM_ESA_LEN)) {\n\t\t\t\t \n\t\t\t\tif (tmp->status > ESI_VC_PENDING) {\n\t\t\t\t\t \n\t\t\t\t\tentry->vcc = tmp->vcc;\n\t\t\t\t\tentry->old_push = tmp->old_push;\n\t\t\t\t}\n\t\t\t\tentry->status = tmp->status;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (remoteflag)\n\t\tentry->flags |= LEC_REMOTE_FLAG;\n\telse\n\t\tentry->flags &= ~LEC_REMOTE_FLAG;\n\tif (entry->status == ESI_ARP_PENDING || entry->status == ESI_UNKNOWN) {\n\t\tentry->status = ESI_VC_PENDING;\n\t\tsend_to_lecd(priv, l_svc_setup, entry->mac_addr, atm_addr, NULL);\n\t}\n\tpr_debug(\"After update2\\n\");\n\tdump_arp_table(priv);\nout:\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n}\n\n \nstatic void\nlec_vcc_added(struct lec_priv *priv, const struct atmlec_ioc *ioc_data,\n\t      struct atm_vcc *vcc,\n\t      void (*old_push) (struct atm_vcc *vcc, struct sk_buff *skb))\n{\n\tunsigned long flags;\n\tstruct lec_arp_table *entry;\n\tint i, found_entry = 0;\n\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\t \n\tif (ioc_data->receive == 2) {\n\t\tpr_debug(\"LEC_ARP: Attaching mcast forward\\n\");\n#if 0\n\t\tentry = lec_arp_find(priv, bus_mac);\n\t\tif (!entry) {\n\t\t\tpr_info(\"LEC_ARP: Multicast entry not found!\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(entry->atm_addr, ioc_data->atm_addr, ATM_ESA_LEN);\n\t\tentry->recv_vcc = vcc;\n\t\tentry->old_recv_push = old_push;\n#endif\n\t\tentry = make_entry(priv, bus_mac);\n\t\tif (entry == NULL)\n\t\t\tgoto out;\n\t\tdel_timer(&entry->timer);\n\t\tmemcpy(entry->atm_addr, ioc_data->atm_addr, ATM_ESA_LEN);\n\t\tentry->recv_vcc = vcc;\n\t\tentry->old_recv_push = old_push;\n\t\thlist_add_head(&entry->next, &priv->mcast_fwds);\n\t\tgoto out;\n\t} else if (ioc_data->receive == 1) {\n\t\t \n\t\tpr_debug(\"LEC_ARP:Attaching data direct, not default: %*phN\\n\",\n\t\t\t ATM_ESA_LEN, ioc_data->atm_addr);\n\t\tentry = make_entry(priv, bus_mac);\n\t\tif (entry == NULL)\n\t\t\tgoto out;\n\t\tmemcpy(entry->atm_addr, ioc_data->atm_addr, ATM_ESA_LEN);\n\t\teth_zero_addr(entry->mac_addr);\n\t\tentry->recv_vcc = vcc;\n\t\tentry->old_recv_push = old_push;\n\t\tentry->status = ESI_UNKNOWN;\n\t\tentry->timer.expires = jiffies + priv->vcc_timeout_period;\n\t\tentry->timer.function = lec_arp_expire_vcc;\n\t\thlist_add_head(&entry->next, &priv->lec_no_forward);\n\t\tadd_timer(&entry->timer);\n\t\tdump_arp_table(priv);\n\t\tgoto out;\n\t}\n\tpr_debug(\"LEC_ARP:Attaching data direct, default: %*phN\\n\",\n\t\t ATM_ESA_LEN, ioc_data->atm_addr);\n\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\n\t\thlist_for_each_entry(entry,\n\t\t\t\t     &priv->lec_arp_tables[i], next) {\n\t\t\tif (memcmp\n\t\t\t    (ioc_data->atm_addr, entry->atm_addr,\n\t\t\t     ATM_ESA_LEN) == 0) {\n\t\t\t\tpr_debug(\"LEC_ARP: Attaching data direct\\n\");\n\t\t\t\tpr_debug(\"Currently -> Vcc: %d, Rvcc:%d\\n\",\n\t\t\t\t\t entry->vcc ? entry->vcc->vci : 0,\n\t\t\t\t\t entry->recv_vcc ? entry->recv_vcc->\n\t\t\t\t\t vci : 0);\n\t\t\t\tfound_entry = 1;\n\t\t\t\tdel_timer(&entry->timer);\n\t\t\t\tentry->vcc = vcc;\n\t\t\t\tentry->old_push = old_push;\n\t\t\t\tif (entry->status == ESI_VC_PENDING) {\n\t\t\t\t\tif (priv->maximum_unknown_frame_count\n\t\t\t\t\t    == 0)\n\t\t\t\t\t\tentry->status =\n\t\t\t\t\t\t    ESI_FORWARD_DIRECT;\n\t\t\t\t\telse {\n\t\t\t\t\t\tentry->timestamp = jiffies;\n\t\t\t\t\t\tentry->status =\n\t\t\t\t\t\t    ESI_FLUSH_PENDING;\n#if 0\n\t\t\t\t\t\tsend_to_lecd(priv, l_flush_xmt,\n\t\t\t\t\t\t\t     NULL,\n\t\t\t\t\t\t\t     entry->atm_addr,\n\t\t\t\t\t\t\t     NULL);\n#endif\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (found_entry) {\n\t\tpr_debug(\"After vcc was added\\n\");\n\t\tdump_arp_table(priv);\n\t\tgoto out;\n\t}\n\t \n\tentry = make_entry(priv, bus_mac);\n\tif (!entry)\n\t\tgoto out;\n\tentry->vcc = vcc;\n\tentry->old_push = old_push;\n\tmemcpy(entry->atm_addr, ioc_data->atm_addr, ATM_ESA_LEN);\n\teth_zero_addr(entry->mac_addr);\n\tentry->status = ESI_UNKNOWN;\n\thlist_add_head(&entry->next, &priv->lec_arp_empty_ones);\n\tentry->timer.expires = jiffies + priv->vcc_timeout_period;\n\tentry->timer.function = lec_arp_expire_vcc;\n\tadd_timer(&entry->timer);\n\tpr_debug(\"After vcc was added\\n\");\n\tdump_arp_table(priv);\nout:\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n}\n\nstatic void lec_flush_complete(struct lec_priv *priv, unsigned long tran_id)\n{\n\tunsigned long flags;\n\tstruct lec_arp_table *entry;\n\tint i;\n\n\tpr_debug(\"%lx\\n\", tran_id);\nrestart:\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\n\t\thlist_for_each_entry(entry,\n\t\t\t\t     &priv->lec_arp_tables[i], next) {\n\t\t\tif (entry->flush_tran_id == tran_id &&\n\t\t\t    entry->status == ESI_FLUSH_PENDING) {\n\t\t\t\tstruct sk_buff *skb;\n\t\t\t\tstruct atm_vcc *vcc = entry->vcc;\n\n\t\t\t\tlec_arp_hold(entry);\n\t\t\t\tspin_unlock_irqrestore(&priv->lec_arp_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\twhile ((skb = skb_dequeue(&entry->tx_wait)))\n\t\t\t\t\tlec_send(vcc, skb);\n\t\t\t\tentry->last_used = jiffies;\n\t\t\t\tentry->status = ESI_FORWARD_DIRECT;\n\t\t\t\tlec_arp_put(entry);\n\t\t\t\tpr_debug(\"LEC_ARP: Flushed\\n\");\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\tdump_arp_table(priv);\n}\n\nstatic void\nlec_set_flush_tran_id(struct lec_priv *priv,\n\t\t      const unsigned char *atm_addr, unsigned long tran_id)\n{\n\tunsigned long flags;\n\tstruct lec_arp_table *entry;\n\tint i;\n\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++)\n\t\thlist_for_each_entry(entry,\n\t\t\t\t     &priv->lec_arp_tables[i], next) {\n\t\t\tif (!memcmp(atm_addr, entry->atm_addr, ATM_ESA_LEN)) {\n\t\t\t\tentry->flush_tran_id = tran_id;\n\t\t\t\tpr_debug(\"Set flush transaction id to %lx for %p\\n\",\n\t\t\t\t\t tran_id, entry);\n\t\t\t}\n\t\t}\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n}\n\nstatic int lec_mcast_make(struct lec_priv *priv, struct atm_vcc *vcc)\n{\n\tunsigned long flags;\n\tunsigned char mac_addr[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\tstruct lec_arp_table *to_add;\n\tstruct lec_vcc_priv *vpriv;\n\tint err = 0;\n\n\tvpriv = kmalloc(sizeof(struct lec_vcc_priv), GFP_KERNEL);\n\tif (!vpriv)\n\t\treturn -ENOMEM;\n\tvpriv->xoff = 0;\n\tvpriv->old_pop = vcc->pop;\n\tvcc->user_back = vpriv;\n\tvcc->pop = lec_pop;\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\tto_add = make_entry(priv, mac_addr);\n\tif (!to_add) {\n\t\tvcc->pop = vpriv->old_pop;\n\t\tkfree(vpriv);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(to_add->atm_addr, vcc->remote.sas_addr.prv, ATM_ESA_LEN);\n\tto_add->status = ESI_FORWARD_DIRECT;\n\tto_add->flags |= LEC_PERMANENT_FLAG;\n\tto_add->vcc = vcc;\n\tto_add->old_push = vcc->push;\n\tvcc->push = lec_push;\n\tpriv->mcast_vcc = vcc;\n\tlec_arp_add(priv, to_add);\nout:\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\treturn err;\n}\n\nstatic void lec_vcc_close(struct lec_priv *priv, struct atm_vcc *vcc)\n{\n\tunsigned long flags;\n\tstruct hlist_node *next;\n\tstruct lec_arp_table *entry;\n\tint i;\n\n\tpr_debug(\"LEC_ARP: lec_vcc_close vpi:%d vci:%d\\n\", vcc->vpi, vcc->vci);\n\tdump_arp_table(priv);\n\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\n\tfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\n\t\thlist_for_each_entry_safe(entry, next,\n\t\t\t\t\t  &priv->lec_arp_tables[i], next) {\n\t\t\tif (vcc == entry->vcc) {\n\t\t\t\tlec_arp_remove(priv, entry);\n\t\t\t\tlec_arp_put(entry);\n\t\t\t\tif (priv->mcast_vcc == vcc)\n\t\t\t\t\tpriv->mcast_vcc = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\thlist_for_each_entry_safe(entry, next,\n\t\t\t\t  &priv->lec_arp_empty_ones, next) {\n\t\tif (entry->vcc == vcc) {\n\t\t\tlec_arp_clear_vccs(entry);\n\t\t\tdel_timer(&entry->timer);\n\t\t\thlist_del(&entry->next);\n\t\t\tlec_arp_put(entry);\n\t\t}\n\t}\n\n\thlist_for_each_entry_safe(entry, next,\n\t\t\t\t  &priv->lec_no_forward, next) {\n\t\tif (entry->recv_vcc == vcc) {\n\t\t\tlec_arp_clear_vccs(entry);\n\t\t\tdel_timer(&entry->timer);\n\t\t\thlist_del(&entry->next);\n\t\t\tlec_arp_put(entry);\n\t\t}\n\t}\n\n\thlist_for_each_entry_safe(entry, next, &priv->mcast_fwds, next) {\n\t\tif (entry->recv_vcc == vcc) {\n\t\t\tlec_arp_clear_vccs(entry);\n\t\t\t \n\t\t\thlist_del(&entry->next);\n\t\t\tlec_arp_put(entry);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n\tdump_arp_table(priv);\n}\n\nstatic void\nlec_arp_check_empties(struct lec_priv *priv,\n\t\t      struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tunsigned long flags;\n\tstruct hlist_node *next;\n\tstruct lec_arp_table *entry, *tmp;\n\tstruct lecdatahdr_8023 *hdr = (struct lecdatahdr_8023 *)skb->data;\n\tunsigned char *src = hdr->h_source;\n\n\tspin_lock_irqsave(&priv->lec_arp_lock, flags);\n\thlist_for_each_entry_safe(entry, next,\n\t\t\t\t  &priv->lec_arp_empty_ones, next) {\n\t\tif (vcc == entry->vcc) {\n\t\t\tdel_timer(&entry->timer);\n\t\t\tether_addr_copy(entry->mac_addr, src);\n\t\t\tentry->status = ESI_FORWARD_DIRECT;\n\t\t\tentry->last_used = jiffies;\n\t\t\t \n\t\t\ttmp = lec_arp_find(priv, src);\n\t\t\tif (tmp) {\n\t\t\t\tlec_arp_remove(priv, tmp);\n\t\t\t\tlec_arp_put(tmp);\n\t\t\t}\n\t\t\thlist_del(&entry->next);\n\t\t\tlec_arp_add(priv, entry);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tpr_debug(\"LEC_ARP: Arp_check_empties: entry not found!\\n\");\nout:\n\tspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}