{
  "module_name": "br2684.c",
  "hash_id": "d8f97e46d05d3c1244800f1d9b2892001e1ef576f5301bb4ad9efc8365b2e95a",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/br2684.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/ip.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <net/arp.h>\n#include <linux/atm.h>\n#include <linux/atmdev.h>\n#include <linux/capability.h>\n#include <linux/seq_file.h>\n\n#include <linux/atmbr2684.h>\n\n#include \"common.h\"\n\nstatic void skb_debug(const struct sk_buff *skb)\n{\n#ifdef SKB_DEBUG\n#define NUM2PRINT 50\n\tprint_hex_dump(KERN_DEBUG, \"br2684: skb: \", DUMP_OFFSET,\n\t\t       16, 1, skb->data, min(NUM2PRINT, skb->len), true);\n#endif\n}\n\n#define BR2684_ETHERTYPE_LEN\t2\n#define BR2684_PAD_LEN\t\t2\n\n#define LLC\t\t0xaa, 0xaa, 0x03\n#define SNAP_BRIDGED\t0x00, 0x80, 0xc2\n#define SNAP_ROUTED\t0x00, 0x00, 0x00\n#define PID_ETHERNET\t0x00, 0x07\n#define ETHERTYPE_IPV4\t0x08, 0x00\n#define ETHERTYPE_IPV6\t0x86, 0xdd\n#define PAD_BRIDGED\t0x00, 0x00\n\nstatic const unsigned char ethertype_ipv4[] = { ETHERTYPE_IPV4 };\nstatic const unsigned char ethertype_ipv6[] = { ETHERTYPE_IPV6 };\nstatic const unsigned char llc_oui_pid_pad[] =\n\t\t\t{ LLC, SNAP_BRIDGED, PID_ETHERNET, PAD_BRIDGED };\nstatic const unsigned char pad[] = { PAD_BRIDGED };\nstatic const unsigned char llc_oui_ipv4[] = { LLC, SNAP_ROUTED, ETHERTYPE_IPV4 };\nstatic const unsigned char llc_oui_ipv6[] = { LLC, SNAP_ROUTED, ETHERTYPE_IPV6 };\n\nenum br2684_encaps {\n\te_vc = BR2684_ENCAPS_VC,\n\te_llc = BR2684_ENCAPS_LLC,\n};\n\nstruct br2684_vcc {\n\tstruct atm_vcc *atmvcc;\n\tstruct net_device *device;\n\t \n\tvoid (*old_push)(struct atm_vcc *vcc, struct sk_buff *skb);\n\tvoid (*old_pop)(struct atm_vcc *vcc, struct sk_buff *skb);\n\tvoid (*old_release_cb)(struct atm_vcc *vcc);\n\tstruct module *old_owner;\n\tenum br2684_encaps encaps;\n\tstruct list_head brvccs;\n#ifdef CONFIG_ATM_BR2684_IPFILTER\n\tstruct br2684_filter filter;\n#endif  \n\tunsigned int copies_needed, copies_failed;\n\tatomic_t qspace;\n};\n\nstruct br2684_dev {\n\tstruct net_device *net_dev;\n\tstruct list_head br2684_devs;\n\tint number;\n\tstruct list_head brvccs;\t \n\tint mac_was_set;\n\tenum br2684_payload payload;\n};\n\n \nstatic DEFINE_RWLOCK(devs_lock);\n\nstatic LIST_HEAD(br2684_devs);\n\nstatic inline struct br2684_dev *BRPRIV(const struct net_device *net_dev)\n{\n\treturn netdev_priv(net_dev);\n}\n\nstatic inline struct net_device *list_entry_brdev(const struct list_head *le)\n{\n\treturn list_entry(le, struct br2684_dev, br2684_devs)->net_dev;\n}\n\nstatic inline struct br2684_vcc *BR2684_VCC(const struct atm_vcc *atmvcc)\n{\n\treturn (struct br2684_vcc *)(atmvcc->user_back);\n}\n\nstatic inline struct br2684_vcc *list_entry_brvcc(const struct list_head *le)\n{\n\treturn list_entry(le, struct br2684_vcc, brvccs);\n}\n\n \nstatic struct net_device *br2684_find_dev(const struct br2684_if_spec *s)\n{\n\tstruct list_head *lh;\n\tstruct net_device *net_dev;\n\tswitch (s->method) {\n\tcase BR2684_FIND_BYNUM:\n\t\tlist_for_each(lh, &br2684_devs) {\n\t\t\tnet_dev = list_entry_brdev(lh);\n\t\t\tif (BRPRIV(net_dev)->number == s->spec.devnum)\n\t\t\t\treturn net_dev;\n\t\t}\n\t\tbreak;\n\tcase BR2684_FIND_BYIFNAME:\n\t\tlist_for_each(lh, &br2684_devs) {\n\t\t\tnet_dev = list_entry_brdev(lh);\n\t\t\tif (!strncmp(net_dev->name, s->spec.ifname, IFNAMSIZ))\n\t\t\t\treturn net_dev;\n\t\t}\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic int atm_dev_event(struct notifier_block *this, unsigned long event,\n\t\t void *arg)\n{\n\tstruct atm_dev *atm_dev = arg;\n\tstruct list_head *lh;\n\tstruct net_device *net_dev;\n\tstruct br2684_vcc *brvcc;\n\tstruct atm_vcc *atm_vcc;\n\tunsigned long flags;\n\n\tpr_debug(\"event=%ld dev=%p\\n\", event, atm_dev);\n\n\tread_lock_irqsave(&devs_lock, flags);\n\tlist_for_each(lh, &br2684_devs) {\n\t\tnet_dev = list_entry_brdev(lh);\n\n\t\tlist_for_each_entry(brvcc, &BRPRIV(net_dev)->brvccs, brvccs) {\n\t\t\tatm_vcc = brvcc->atmvcc;\n\t\t\tif (atm_vcc && brvcc->atmvcc->dev == atm_dev) {\n\n\t\t\t\tif (atm_vcc->dev->signal == ATM_PHY_SIG_LOST)\n\t\t\t\t\tnetif_carrier_off(net_dev);\n\t\t\t\telse\n\t\t\t\t\tnetif_carrier_on(net_dev);\n\n\t\t\t}\n\t\t}\n\t}\n\tread_unlock_irqrestore(&devs_lock, flags);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block atm_dev_notifier = {\n\t.notifier_call = atm_dev_event,\n};\n\n \nstatic void br2684_pop(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tstruct br2684_vcc *brvcc = BR2684_VCC(vcc);\n\n\tpr_debug(\"(vcc %p ; net_dev %p )\\n\", vcc, brvcc->device);\n\tbrvcc->old_pop(vcc, skb);\n\n\t \n\tif (atomic_inc_return(&brvcc->qspace) == 1)\n\t\tnetif_wake_queue(brvcc->device);\n}\n\n \nstatic int br2684_xmit_vcc(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct br2684_vcc *brvcc)\n{\n\tstruct br2684_dev *brdev = BRPRIV(dev);\n\tstruct atm_vcc *atmvcc;\n\tint minheadroom = (brvcc->encaps == e_llc) ?\n\t\t((brdev->payload == p_bridged) ?\n\t\t\tsizeof(llc_oui_pid_pad) : sizeof(llc_oui_ipv4)) :\n\t\t((brdev->payload == p_bridged) ? BR2684_PAD_LEN : 0);\n\n\tif (skb_headroom(skb) < minheadroom) {\n\t\tstruct sk_buff *skb2 = skb_realloc_headroom(skb, minheadroom);\n\t\tbrvcc->copies_needed++;\n\t\tdev_kfree_skb(skb);\n\t\tif (skb2 == NULL) {\n\t\t\tbrvcc->copies_failed++;\n\t\t\treturn 0;\n\t\t}\n\t\tskb = skb2;\n\t}\n\n\tif (brvcc->encaps == e_llc) {\n\t\tif (brdev->payload == p_bridged) {\n\t\t\tskb_push(skb, sizeof(llc_oui_pid_pad));\n\t\t\tskb_copy_to_linear_data(skb, llc_oui_pid_pad,\n\t\t\t\t\t\tsizeof(llc_oui_pid_pad));\n\t\t} else if (brdev->payload == p_routed) {\n\t\t\tunsigned short prot = ntohs(skb->protocol);\n\n\t\t\tskb_push(skb, sizeof(llc_oui_ipv4));\n\t\t\tswitch (prot) {\n\t\t\tcase ETH_P_IP:\n\t\t\t\tskb_copy_to_linear_data(skb, llc_oui_ipv4,\n\t\t\t\t\t\t\tsizeof(llc_oui_ipv4));\n\t\t\t\tbreak;\n\t\t\tcase ETH_P_IPV6:\n\t\t\t\tskb_copy_to_linear_data(skb, llc_oui_ipv6,\n\t\t\t\t\t\t\tsizeof(llc_oui_ipv6));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {  \n\t\tif (brdev->payload == p_bridged) {\n\t\t\tskb_push(skb, 2);\n\t\t\tmemset(skb->data, 0, 2);\n\t\t}\n\t}\n\tskb_debug(skb);\n\n\tATM_SKB(skb)->vcc = atmvcc = brvcc->atmvcc;\n\tpr_debug(\"atm_skb(%p)->vcc(%p)->dev(%p)\\n\", skb, atmvcc, atmvcc->dev);\n\tatm_account_tx(atmvcc, skb);\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\tif (atomic_dec_return(&brvcc->qspace) < 1) {\n\t\t \n\t\tnetif_stop_queue(brvcc->device);\n\t\t \n\t\tif (unlikely(atomic_read(&brvcc->qspace) > 0))\n\t\t\tnetif_wake_queue(brvcc->device);\n\t}\n\n\t \n\treturn !atmvcc->send(atmvcc, skb);\n}\n\nstatic void br2684_release_cb(struct atm_vcc *atmvcc)\n{\n\tstruct br2684_vcc *brvcc = BR2684_VCC(atmvcc);\n\n\tif (atomic_read(&brvcc->qspace) > 0)\n\t\tnetif_wake_queue(brvcc->device);\n\n\tif (brvcc->old_release_cb)\n\t\tbrvcc->old_release_cb(atmvcc);\n}\n\nstatic inline struct br2684_vcc *pick_outgoing_vcc(const struct sk_buff *skb,\n\t\t\t\t\t\t   const struct br2684_dev *brdev)\n{\n\treturn list_empty(&brdev->brvccs) ? NULL : list_entry_brvcc(brdev->brvccs.next);\t \n}\n\nstatic netdev_tx_t br2684_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct br2684_dev *brdev = BRPRIV(dev);\n\tstruct br2684_vcc *brvcc;\n\tstruct atm_vcc *atmvcc;\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\n\tpr_debug(\"skb_dst(skb)=%p\\n\", skb_dst(skb));\n\tread_lock(&devs_lock);\n\tbrvcc = pick_outgoing_vcc(skb, brdev);\n\tif (brvcc == NULL) {\n\t\tpr_debug(\"no vcc attached to dev %s\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_carrier_errors++;\n\t\t \n\t\tdev_kfree_skb(skb);\n\t\tgoto out_devs;\n\t}\n\tatmvcc = brvcc->atmvcc;\n\n\tbh_lock_sock(sk_atm(atmvcc));\n\n\tif (test_bit(ATM_VF_RELEASED, &atmvcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &atmvcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &atmvcc->flags)) {\n\t\tdev->stats.tx_dropped++;\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (sock_owned_by_user(sk_atm(atmvcc))) {\n\t\tnetif_stop_queue(brvcc->device);\n\t\tret = NETDEV_TX_BUSY;\n\t\tgoto out;\n\t}\n\n\tif (!br2684_xmit_vcc(skb, dev, brvcc)) {\n\t\t \n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_fifo_errors++;\n\t}\n out:\n\tbh_unlock_sock(sk_atm(atmvcc));\n out_devs:\n\tread_unlock(&devs_lock);\n\treturn ret;\n}\n\n \nstatic int br2684_mac_addr(struct net_device *dev, void *p)\n{\n\tint err = eth_mac_addr(dev, p);\n\tif (!err)\n\t\tBRPRIV(dev)->mac_was_set = 1;\n\treturn err;\n}\n\n#ifdef CONFIG_ATM_BR2684_IPFILTER\n \nstatic int br2684_setfilt(struct atm_vcc *atmvcc, void __user * arg)\n{\n\tstruct br2684_vcc *brvcc;\n\tstruct br2684_filter_set fs;\n\n\tif (copy_from_user(&fs, arg, sizeof fs))\n\t\treturn -EFAULT;\n\tif (fs.ifspec.method != BR2684_FIND_BYNOTHING) {\n\t\t \n\t\tstruct br2684_dev *brdev;\n\t\tread_lock(&devs_lock);\n\t\tbrdev = BRPRIV(br2684_find_dev(&fs.ifspec));\n\t\tif (brdev == NULL || list_empty(&brdev->brvccs) ||\n\t\t    brdev->brvccs.next != brdev->brvccs.prev)\t \n\t\t\tbrvcc = NULL;\n\t\telse\n\t\t\tbrvcc = list_entry_brvcc(brdev->brvccs.next);\n\t\tread_unlock(&devs_lock);\n\t\tif (brvcc == NULL)\n\t\t\treturn -ESRCH;\n\t} else\n\t\tbrvcc = BR2684_VCC(atmvcc);\n\tmemcpy(&brvcc->filter, &fs.filter, sizeof(brvcc->filter));\n\treturn 0;\n}\n\n \nstatic inline int\npacket_fails_filter(__be16 type, struct br2684_vcc *brvcc, struct sk_buff *skb)\n{\n\tif (brvcc->filter.netmask == 0)\n\t\treturn 0;\t \n\tif (type == htons(ETH_P_IP) &&\n\t    (((struct iphdr *)(skb->data))->daddr & brvcc->filter.\n\t     netmask) == brvcc->filter.prefix)\n\t\treturn 0;\n\tif (type == htons(ETH_P_ARP))\n\t\treturn 0;\n\t \n\treturn 1;\t\t \n}\n#endif  \n\nstatic void br2684_close_vcc(struct br2684_vcc *brvcc)\n{\n\tpr_debug(\"removing VCC %p from dev %p\\n\", brvcc, brvcc->device);\n\twrite_lock_irq(&devs_lock);\n\tlist_del(&brvcc->brvccs);\n\twrite_unlock_irq(&devs_lock);\n\tbrvcc->atmvcc->user_back = NULL;\t \n\tbrvcc->atmvcc->release_cb = brvcc->old_release_cb;\n\tbrvcc->old_push(brvcc->atmvcc, NULL);\t \n\tmodule_put(brvcc->old_owner);\n\tkfree(brvcc);\n}\n\n \nstatic void br2684_push(struct atm_vcc *atmvcc, struct sk_buff *skb)\n{\n\tstruct br2684_vcc *brvcc = BR2684_VCC(atmvcc);\n\tstruct net_device *net_dev = brvcc->device;\n\tstruct br2684_dev *brdev = BRPRIV(net_dev);\n\n\tpr_debug(\"\\n\");\n\n\tif (unlikely(skb == NULL)) {\n\t\t \n\t\tbr2684_close_vcc(brvcc);\n\t\tif (list_empty(&brdev->brvccs)) {\n\t\t\twrite_lock_irq(&devs_lock);\n\t\t\tlist_del(&brdev->br2684_devs);\n\t\t\twrite_unlock_irq(&devs_lock);\n\t\t\tunregister_netdev(net_dev);\n\t\t\tfree_netdev(net_dev);\n\t\t}\n\t\treturn;\n\t}\n\n\tskb_debug(skb);\n\tatm_return(atmvcc, skb->truesize);\n\tpr_debug(\"skb from brdev %p\\n\", brdev);\n\tif (brvcc->encaps == e_llc) {\n\n\t\tif (skb->len > 7 && skb->data[7] == 0x01)\n\t\t\t__skb_trim(skb, skb->len - 4);\n\n\t\t \n\t\tif ((skb->len >= (sizeof(llc_oui_ipv4))) &&\n\t\t    (memcmp(skb->data, llc_oui_ipv4,\n\t\t\t    sizeof(llc_oui_ipv4) - BR2684_ETHERTYPE_LEN) == 0)) {\n\t\t\tif (memcmp(skb->data + 6, ethertype_ipv6,\n\t\t\t\t   sizeof(ethertype_ipv6)) == 0)\n\t\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\telse if (memcmp(skb->data + 6, ethertype_ipv4,\n\t\t\t\t\tsizeof(ethertype_ipv4)) == 0)\n\t\t\t\tskb->protocol = htons(ETH_P_IP);\n\t\t\telse\n\t\t\t\tgoto error;\n\t\t\tskb_pull(skb, sizeof(llc_oui_ipv4));\n\t\t\tskb_reset_network_header(skb);\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t \n\t\t} else if ((skb->len >= sizeof(llc_oui_pid_pad)) &&\n\t\t\t   (memcmp(skb->data, llc_oui_pid_pad, 7) == 0)) {\n\t\t\tskb_pull(skb, sizeof(llc_oui_pid_pad));\n\t\t\tskb->protocol = eth_type_trans(skb, net_dev);\n\t\t} else\n\t\t\tgoto error;\n\n\t} else {  \n\t\tif (brdev->payload == p_routed) {\n\t\t\tstruct iphdr *iph;\n\n\t\t\tskb_reset_network_header(skb);\n\t\t\tiph = ip_hdr(skb);\n\t\t\tif (iph->version == 4)\n\t\t\t\tskb->protocol = htons(ETH_P_IP);\n\t\t\telse if (iph->version == 6)\n\t\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\telse\n\t\t\t\tgoto error;\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t} else {  \n\t\t\t \n\t\t\tif (memcmp(skb->data, pad, BR2684_PAD_LEN) != 0)\n\t\t\t\tgoto error;\n\t\t\tskb_pull(skb, BR2684_PAD_LEN);\n\t\t\tskb->protocol = eth_type_trans(skb, net_dev);\n\t\t}\n\t}\n\n#ifdef CONFIG_ATM_BR2684_IPFILTER\n\tif (unlikely(packet_fails_filter(skb->protocol, brvcc, skb)))\n\t\tgoto dropped;\n#endif  \n\tskb->dev = net_dev;\n\tATM_SKB(skb)->vcc = atmvcc;\t \n\tpr_debug(\"received packet's protocol: %x\\n\", ntohs(skb->protocol));\n\tskb_debug(skb);\n\t \n\tif (unlikely(!(net_dev->flags & IFF_UP)))\n\t\tgoto dropped;\n\tnet_dev->stats.rx_packets++;\n\tnet_dev->stats.rx_bytes += skb->len;\n\tmemset(ATM_SKB(skb), 0, sizeof(struct atm_skb_data));\n\tnetif_rx(skb);\n\treturn;\n\ndropped:\n\tnet_dev->stats.rx_dropped++;\n\tgoto free_skb;\nerror:\n\tnet_dev->stats.rx_errors++;\nfree_skb:\n\tdev_kfree_skb(skb);\n}\n\n \nstatic int br2684_regvcc(struct atm_vcc *atmvcc, void __user * arg)\n{\n\tstruct br2684_vcc *brvcc;\n\tstruct br2684_dev *brdev;\n\tstruct net_device *net_dev;\n\tstruct atm_backend_br2684 be;\n\tint err;\n\n\tif (copy_from_user(&be, arg, sizeof be))\n\t\treturn -EFAULT;\n\tbrvcc = kzalloc(sizeof(struct br2684_vcc), GFP_KERNEL);\n\tif (!brvcc)\n\t\treturn -ENOMEM;\n\t \n\tatomic_set(&brvcc->qspace, 2);\n\twrite_lock_irq(&devs_lock);\n\tnet_dev = br2684_find_dev(&be.ifspec);\n\tif (net_dev == NULL) {\n\t\tpr_err(\"tried to attach to non-existent device\\n\");\n\t\terr = -ENXIO;\n\t\tgoto error;\n\t}\n\tbrdev = BRPRIV(net_dev);\n\tif (atmvcc->push == NULL) {\n\t\terr = -EBADFD;\n\t\tgoto error;\n\t}\n\tif (!list_empty(&brdev->brvccs)) {\n\t\t \n\t\terr = -EEXIST;\n\t\tgoto error;\n\t}\n\tif (be.fcs_in != BR2684_FCSIN_NO ||\n\t    be.fcs_out != BR2684_FCSOUT_NO ||\n\t    be.fcs_auto || be.has_vpiid || be.send_padding ||\n\t    (be.encaps != BR2684_ENCAPS_VC &&\n\t     be.encaps != BR2684_ENCAPS_LLC) ||\n\t    be.min_size != 0) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\tpr_debug(\"vcc=%p, encaps=%d, brvcc=%p\\n\", atmvcc, be.encaps, brvcc);\n\tif (list_empty(&brdev->brvccs) && !brdev->mac_was_set) {\n\t\tunsigned char *esi = atmvcc->dev->esi;\n\t\tconst u8 one = 1;\n\n\t\tif (esi[0] | esi[1] | esi[2] | esi[3] | esi[4] | esi[5])\n\t\t\tdev_addr_set(net_dev, esi);\n\t\telse\n\t\t\tdev_addr_mod(net_dev, 2, &one, 1);\n\t}\n\tlist_add(&brvcc->brvccs, &brdev->brvccs);\n\twrite_unlock_irq(&devs_lock);\n\tbrvcc->device = net_dev;\n\tbrvcc->atmvcc = atmvcc;\n\tatmvcc->user_back = brvcc;\n\tbrvcc->encaps = (enum br2684_encaps)be.encaps;\n\tbrvcc->old_push = atmvcc->push;\n\tbrvcc->old_pop = atmvcc->pop;\n\tbrvcc->old_release_cb = atmvcc->release_cb;\n\tbrvcc->old_owner = atmvcc->owner;\n\tbarrier();\n\tatmvcc->push = br2684_push;\n\tatmvcc->pop = br2684_pop;\n\tatmvcc->release_cb = br2684_release_cb;\n\tatmvcc->owner = THIS_MODULE;\n\n\t \n\tif (atmvcc->dev->signal == ATM_PHY_SIG_LOST)\n\t\tnetif_carrier_off(net_dev);\n\telse\n\t\tnetif_carrier_on(net_dev);\n\n\t__module_get(THIS_MODULE);\n\n\t \n\tvcc_process_recv_queue(atmvcc);\n\treturn 0;\n\nerror:\n\twrite_unlock_irq(&devs_lock);\n\tkfree(brvcc);\n\treturn err;\n}\n\nstatic const struct net_device_ops br2684_netdev_ops = {\n\t.ndo_start_xmit \t= br2684_start_xmit,\n\t.ndo_set_mac_address\t= br2684_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const struct net_device_ops br2684_netdev_ops_routed = {\n\t.ndo_start_xmit \t= br2684_start_xmit,\n\t.ndo_set_mac_address\t= br2684_mac_addr,\n};\n\nstatic void br2684_setup(struct net_device *netdev)\n{\n\tstruct br2684_dev *brdev = BRPRIV(netdev);\n\n\tether_setup(netdev);\n\tnetdev->hard_header_len += sizeof(llc_oui_pid_pad);  \n\tbrdev->net_dev = netdev;\n\n\tnetdev->netdev_ops = &br2684_netdev_ops;\n\n\tINIT_LIST_HEAD(&brdev->brvccs);\n}\n\nstatic void br2684_setup_routed(struct net_device *netdev)\n{\n\tstruct br2684_dev *brdev = BRPRIV(netdev);\n\n\tbrdev->net_dev = netdev;\n\tnetdev->hard_header_len = sizeof(llc_oui_ipv4);  \n\tnetdev->netdev_ops = &br2684_netdev_ops_routed;\n\tnetdev->addr_len = 0;\n\tnetdev->mtu = ETH_DATA_LEN;\n\tnetdev->min_mtu = 0;\n\tnetdev->max_mtu = ETH_MAX_MTU;\n\tnetdev->type = ARPHRD_PPP;\n\tnetdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tnetdev->tx_queue_len = 100;\n\tINIT_LIST_HEAD(&brdev->brvccs);\n}\n\nstatic int br2684_create(void __user *arg)\n{\n\tint err;\n\tstruct net_device *netdev;\n\tstruct br2684_dev *brdev;\n\tstruct atm_newif_br2684 ni;\n\tenum br2684_payload payload;\n\n\tpr_debug(\"\\n\");\n\n\tif (copy_from_user(&ni, arg, sizeof ni))\n\t\treturn -EFAULT;\n\n\tif (ni.media & BR2684_FLAG_ROUTED)\n\t\tpayload = p_routed;\n\telse\n\t\tpayload = p_bridged;\n\tni.media &= 0xffff;\t \n\n\tif (ni.media != BR2684_MEDIA_ETHERNET || ni.mtu != 1500)\n\t\treturn -EINVAL;\n\n\tnetdev = alloc_netdev(sizeof(struct br2684_dev),\n\t\t\t      ni.ifname[0] ? ni.ifname : \"nas%d\",\n\t\t\t      NET_NAME_UNKNOWN,\n\t\t\t      (payload == p_routed) ? br2684_setup_routed : br2684_setup);\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tbrdev = BRPRIV(netdev);\n\n\tpr_debug(\"registered netdev %s\\n\", netdev->name);\n\t \n\terr = register_netdev(netdev);\n\tif (err < 0) {\n\t\tpr_err(\"register_netdev failed\\n\");\n\t\tfree_netdev(netdev);\n\t\treturn err;\n\t}\n\n\twrite_lock_irq(&devs_lock);\n\n\tbrdev->payload = payload;\n\n\tif (list_empty(&br2684_devs)) {\n\t\t \n\t\tbrdev->number = 1;\n\t} else\n\t\tbrdev->number = BRPRIV(list_entry_brdev(br2684_devs.prev))->number + 1;\n\n\tlist_add_tail(&brdev->br2684_devs, &br2684_devs);\n\twrite_unlock_irq(&devs_lock);\n\treturn 0;\n}\n\n \nstatic int br2684_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct atm_vcc *atmvcc = ATM_SD(sock);\n\tvoid __user *argp = (void __user *)arg;\n\tatm_backend_t b;\n\n\tint err;\n\tswitch (cmd) {\n\tcase ATM_SETBACKEND:\n\tcase ATM_NEWBACKENDIF:\n\t\terr = get_user(b, (atm_backend_t __user *) argp);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t\tif (b != ATM_BACKEND_BR2684)\n\t\t\treturn -ENOIOCTLCMD;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (cmd == ATM_SETBACKEND) {\n\t\t\tif (sock->state != SS_CONNECTED)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn br2684_regvcc(atmvcc, argp);\n\t\t} else {\n\t\t\treturn br2684_create(argp);\n\t\t}\n#ifdef CONFIG_ATM_BR2684_IPFILTER\n\tcase BR2684_SETFILT:\n\t\tif (atmvcc->push != br2684_push)\n\t\t\treturn -ENOIOCTLCMD;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = br2684_setfilt(atmvcc, argp);\n\n\t\treturn err;\n#endif  \n\t}\n\treturn -ENOIOCTLCMD;\n}\n\nstatic struct atm_ioctl br2684_ioctl_ops = {\n\t.owner = THIS_MODULE,\n\t.ioctl = br2684_ioctl,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic void *br2684_seq_start(struct seq_file *seq, loff_t * pos)\n\t__acquires(devs_lock)\n{\n\tread_lock(&devs_lock);\n\treturn seq_list_start(&br2684_devs, *pos);\n}\n\nstatic void *br2684_seq_next(struct seq_file *seq, void *v, loff_t * pos)\n{\n\treturn seq_list_next(v, &br2684_devs, pos);\n}\n\nstatic void br2684_seq_stop(struct seq_file *seq, void *v)\n\t__releases(devs_lock)\n{\n\tread_unlock(&devs_lock);\n}\n\nstatic int br2684_seq_show(struct seq_file *seq, void *v)\n{\n\tconst struct br2684_dev *brdev = list_entry(v, struct br2684_dev,\n\t\t\t\t\t\t    br2684_devs);\n\tconst struct net_device *net_dev = brdev->net_dev;\n\tconst struct br2684_vcc *brvcc;\n\n\tseq_printf(seq, \"dev %.16s: num=%d, mac=%pM (%s)\\n\",\n\t\t   net_dev->name,\n\t\t   brdev->number,\n\t\t   net_dev->dev_addr,\n\t\t   brdev->mac_was_set ? \"set\" : \"auto\");\n\n\tlist_for_each_entry(brvcc, &brdev->brvccs, brvccs) {\n\t\tseq_printf(seq, \"  vcc %d.%d.%d: encaps=%s payload=%s\"\n\t\t\t   \", failed copies %u/%u\"\n\t\t\t   \"\\n\", brvcc->atmvcc->dev->number,\n\t\t\t   brvcc->atmvcc->vpi, brvcc->atmvcc->vci,\n\t\t\t   (brvcc->encaps == e_llc) ? \"LLC\" : \"VC\",\n\t\t\t   (brdev->payload == p_bridged) ? \"bridged\" : \"routed\",\n\t\t\t   brvcc->copies_failed, brvcc->copies_needed);\n#ifdef CONFIG_ATM_BR2684_IPFILTER\n\t\tif (brvcc->filter.netmask != 0)\n\t\t\tseq_printf(seq, \"    filter=%pI4/%pI4\\n\",\n\t\t\t\t   &brvcc->filter.prefix,\n\t\t\t\t   &brvcc->filter.netmask);\n#endif  \n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations br2684_seq_ops = {\n\t.start = br2684_seq_start,\n\t.next = br2684_seq_next,\n\t.stop = br2684_seq_stop,\n\t.show = br2684_seq_show,\n};\n\nextern struct proc_dir_entry *atm_proc_root;\t \n#endif  \n\nstatic int __init br2684_init(void)\n{\n#ifdef CONFIG_PROC_FS\n\tstruct proc_dir_entry *p;\n\tp = proc_create_seq(\"br2684\", 0, atm_proc_root, &br2684_seq_ops);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n#endif\n\tregister_atm_ioctl(&br2684_ioctl_ops);\n\tregister_atmdevice_notifier(&atm_dev_notifier);\n\treturn 0;\n}\n\nstatic void __exit br2684_exit(void)\n{\n\tstruct net_device *net_dev;\n\tstruct br2684_dev *brdev;\n\tstruct br2684_vcc *brvcc;\n\tderegister_atm_ioctl(&br2684_ioctl_ops);\n\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"br2684\", atm_proc_root);\n#endif\n\n\n\tunregister_atmdevice_notifier(&atm_dev_notifier);\n\n\twhile (!list_empty(&br2684_devs)) {\n\t\tnet_dev = list_entry_brdev(br2684_devs.next);\n\t\tbrdev = BRPRIV(net_dev);\n\t\twhile (!list_empty(&brdev->brvccs)) {\n\t\t\tbrvcc = list_entry_brvcc(brdev->brvccs.next);\n\t\t\tbr2684_close_vcc(brvcc);\n\t\t}\n\n\t\tlist_del(&brdev->br2684_devs);\n\t\tunregister_netdev(net_dev);\n\t\tfree_netdev(net_dev);\n\t}\n}\n\nmodule_init(br2684_init);\nmodule_exit(br2684_exit);\n\nMODULE_AUTHOR(\"Marcell GAL\");\nMODULE_DESCRIPTION(\"RFC2684 bridged protocols over ATM/AAL5\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}