{
  "module_name": "addr.c",
  "hash_id": "6064d6e5a26daf395fe180211e17a6203a40ae3db3602bee7f143529849c28b5",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/addr.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/atm.h>\n#include <linux/atmdev.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include \"signaling.h\"\n#include \"addr.h\"\n\nstatic int check_addr(const struct sockaddr_atmsvc *addr)\n{\n\tint i;\n\n\tif (addr->sas_family != AF_ATMSVC)\n\t\treturn -EAFNOSUPPORT;\n\tif (!*addr->sas_addr.pub)\n\t\treturn *addr->sas_addr.prv ? 0 : -EINVAL;\n\tfor (i = 1; i < ATM_E164_LEN + 1; i++)\t \n\t\tif (!addr->sas_addr.pub[i])\n\t\t\treturn 0;\n\treturn -EINVAL;\n}\n\nstatic int identical(const struct sockaddr_atmsvc *a, const struct sockaddr_atmsvc *b)\n{\n\tif (*a->sas_addr.prv)\n\t\tif (memcmp(a->sas_addr.prv, b->sas_addr.prv, ATM_ESA_LEN))\n\t\t\treturn 0;\n\tif (!*a->sas_addr.pub)\n\t\treturn !*b->sas_addr.pub;\n\tif (!*b->sas_addr.pub)\n\t\treturn 0;\n\treturn !strcmp(a->sas_addr.pub, b->sas_addr.pub);\n}\n\nstatic void notify_sigd(const struct atm_dev *dev)\n{\n\tstruct sockaddr_atmpvc pvc;\n\n\tpvc.sap_addr.itf = dev->number;\n\tsigd_enq(NULL, as_itf_notify, NULL, &pvc, NULL);\n}\n\nvoid atm_reset_addr(struct atm_dev *dev, enum atm_addr_type_t atype)\n{\n\tunsigned long flags;\n\tstruct atm_dev_addr *this, *p;\n\tstruct list_head *head;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (atype == ATM_ADDR_LECS)\n\t\thead = &dev->lecs;\n\telse\n\t\thead = &dev->local;\n\tlist_for_each_entry_safe(this, p, head, entry) {\n\t\tlist_del(&this->entry);\n\t\tkfree(this);\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (head == &dev->local)\n\t\tnotify_sigd(dev);\n}\n\nint atm_add_addr(struct atm_dev *dev, const struct sockaddr_atmsvc *addr,\n\t\t enum atm_addr_type_t atype)\n{\n\tunsigned long flags;\n\tstruct atm_dev_addr *this;\n\tstruct list_head *head;\n\tint error;\n\n\terror = check_addr(addr);\n\tif (error)\n\t\treturn error;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (atype == ATM_ADDR_LECS)\n\t\thead = &dev->lecs;\n\telse\n\t\thead = &dev->local;\n\tlist_for_each_entry(this, head, entry) {\n\t\tif (identical(&this->addr, addr)) {\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tthis = kmalloc(sizeof(struct atm_dev_addr), GFP_ATOMIC);\n\tif (!this) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\tthis->addr = *addr;\n\tlist_add(&this->entry, head);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (head == &dev->local)\n\t\tnotify_sigd(dev);\n\treturn 0;\n}\n\nint atm_del_addr(struct atm_dev *dev, const struct sockaddr_atmsvc *addr,\n\t\t enum atm_addr_type_t atype)\n{\n\tunsigned long flags;\n\tstruct atm_dev_addr *this;\n\tstruct list_head *head;\n\tint error;\n\n\terror = check_addr(addr);\n\tif (error)\n\t\treturn error;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (atype == ATM_ADDR_LECS)\n\t\thead = &dev->lecs;\n\telse\n\t\thead = &dev->local;\n\tlist_for_each_entry(this, head, entry) {\n\t\tif (identical(&this->addr, addr)) {\n\t\t\tlist_del(&this->entry);\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tkfree(this);\n\t\t\tif (head == &dev->local)\n\t\t\t\tnotify_sigd(dev);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn -ENOENT;\n}\n\nint atm_get_addr(struct atm_dev *dev, struct sockaddr_atmsvc __user * buf,\n\t\t size_t size, enum atm_addr_type_t atype)\n{\n\tunsigned long flags;\n\tstruct atm_dev_addr *this;\n\tstruct list_head *head;\n\tint total = 0, error;\n\tstruct sockaddr_atmsvc *tmp_buf, *tmp_bufp;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (atype == ATM_ADDR_LECS)\n\t\thead = &dev->lecs;\n\telse\n\t\thead = &dev->local;\n\tlist_for_each_entry(this, head, entry)\n\t    total += sizeof(struct sockaddr_atmsvc);\n\ttmp_buf = tmp_bufp = kmalloc(total, GFP_ATOMIC);\n\tif (!tmp_buf) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\tlist_for_each_entry(this, head, entry)\n\t    memcpy(tmp_bufp++, &this->addr, sizeof(struct sockaddr_atmsvc));\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\terror = total > size ? -E2BIG : total;\n\tif (copy_to_user(buf, tmp_buf, total < size ? total : size))\n\t\terror = -EFAULT;\n\tkfree(tmp_buf);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}