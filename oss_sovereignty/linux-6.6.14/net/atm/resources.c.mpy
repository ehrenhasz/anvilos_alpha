{
  "module_name": "resources.c",
  "hash_id": "ecc06312fc76dd855f24986c9e7971730b6213157e42644d511b9b72f1301f58",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/resources.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/atmdev.h>\n#include <linux/sonet.h>\n#include <linux/kernel.h>  \n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\n#include <net/sock.h>\t  \n\n#include \"common.h\"\n#include \"resources.h\"\n#include \"addr.h\"\n\n\nLIST_HEAD(atm_devs);\nDEFINE_MUTEX(atm_dev_mutex);\n\nstatic struct atm_dev *__alloc_atm_dev(const char *type)\n{\n\tstruct atm_dev *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\tdev->type = type;\n\tdev->signal = ATM_PHY_SIG_UNKNOWN;\n\tdev->link_rate = ATM_OC3_PCR;\n\tspin_lock_init(&dev->lock);\n\tINIT_LIST_HEAD(&dev->local);\n\tINIT_LIST_HEAD(&dev->lecs);\n\n\treturn dev;\n}\n\nstatic struct atm_dev *__atm_dev_lookup(int number)\n{\n\tstruct atm_dev *dev;\n\n\tlist_for_each_entry(dev, &atm_devs, dev_list) {\n\t\tif (dev->number == number) {\n\t\t\tatm_dev_hold(dev);\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstruct atm_dev *atm_dev_lookup(int number)\n{\n\tstruct atm_dev *dev;\n\n\tmutex_lock(&atm_dev_mutex);\n\tdev = __atm_dev_lookup(number);\n\tmutex_unlock(&atm_dev_mutex);\n\treturn dev;\n}\nEXPORT_SYMBOL(atm_dev_lookup);\n\nstruct atm_dev *atm_dev_register(const char *type, struct device *parent,\n\t\t\t\t const struct atmdev_ops *ops, int number,\n\t\t\t\t unsigned long *flags)\n{\n\tstruct atm_dev *dev, *inuse;\n\n\tdev = __alloc_atm_dev(type);\n\tif (!dev) {\n\t\tpr_err(\"no space for dev %s\\n\", type);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&atm_dev_mutex);\n\tif (number != -1) {\n\t\tinuse = __atm_dev_lookup(number);\n\t\tif (inuse) {\n\t\t\tatm_dev_put(inuse);\n\t\t\tmutex_unlock(&atm_dev_mutex);\n\t\t\tkfree(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\tdev->number = number;\n\t} else {\n\t\tdev->number = 0;\n\t\twhile ((inuse = __atm_dev_lookup(dev->number))) {\n\t\t\tatm_dev_put(inuse);\n\t\t\tdev->number++;\n\t\t}\n\t}\n\n\tdev->ops = ops;\n\tif (flags)\n\t\tdev->flags = *flags;\n\telse\n\t\tmemset(&dev->flags, 0, sizeof(dev->flags));\n\tmemset(&dev->stats, 0, sizeof(dev->stats));\n\trefcount_set(&dev->refcnt, 1);\n\n\tif (atm_proc_dev_register(dev) < 0) {\n\t\tpr_err(\"atm_proc_dev_register failed for dev %s\\n\", type);\n\t\tgoto out_fail;\n\t}\n\n\tif (atm_register_sysfs(dev, parent) < 0) {\n\t\tpr_err(\"atm_register_sysfs failed for dev %s\\n\", type);\n\t\tatm_proc_dev_deregister(dev);\n\t\tgoto out_fail;\n\t}\n\n\tlist_add_tail(&dev->dev_list, &atm_devs);\n\nout:\n\tmutex_unlock(&atm_dev_mutex);\n\treturn dev;\n\nout_fail:\n\tkfree(dev);\n\tdev = NULL;\n\tgoto out;\n}\nEXPORT_SYMBOL(atm_dev_register);\n\nvoid atm_dev_deregister(struct atm_dev *dev)\n{\n\tBUG_ON(test_bit(ATM_DF_REMOVED, &dev->flags));\n\tset_bit(ATM_DF_REMOVED, &dev->flags);\n\n\t \n\tmutex_lock(&atm_dev_mutex);\n\tlist_del(&dev->dev_list);\n\tmutex_unlock(&atm_dev_mutex);\n\n\tatm_dev_release_vccs(dev);\n\tatm_unregister_sysfs(dev);\n\tatm_proc_dev_deregister(dev);\n\n\tatm_dev_put(dev);\n}\nEXPORT_SYMBOL(atm_dev_deregister);\n\nstatic void copy_aal_stats(struct k_atm_aal_stats *from,\n    struct atm_aal_stats *to)\n{\n#define __HANDLE_ITEM(i) to->i = atomic_read(&from->i)\n\t__AAL_STAT_ITEMS\n#undef __HANDLE_ITEM\n}\n\nstatic void subtract_aal_stats(struct k_atm_aal_stats *from,\n    struct atm_aal_stats *to)\n{\n#define __HANDLE_ITEM(i) atomic_sub(to->i, &from->i)\n\t__AAL_STAT_ITEMS\n#undef __HANDLE_ITEM\n}\n\nstatic int fetch_stats(struct atm_dev *dev, struct atm_dev_stats __user *arg,\n\t\t       int zero)\n{\n\tstruct atm_dev_stats tmp;\n\tint error = 0;\n\n\tcopy_aal_stats(&dev->stats.aal0, &tmp.aal0);\n\tcopy_aal_stats(&dev->stats.aal34, &tmp.aal34);\n\tcopy_aal_stats(&dev->stats.aal5, &tmp.aal5);\n\tif (arg)\n\t\terror = copy_to_user(arg, &tmp, sizeof(tmp));\n\tif (zero && !error) {\n\t\tsubtract_aal_stats(&dev->stats.aal0, &tmp.aal0);\n\t\tsubtract_aal_stats(&dev->stats.aal34, &tmp.aal34);\n\t\tsubtract_aal_stats(&dev->stats.aal5, &tmp.aal5);\n\t}\n\treturn error ? -EFAULT : 0;\n}\n\nint atm_getnames(void __user *buf, int __user *iobuf_len)\n{\n\tint error, len, size = 0;\n\tstruct atm_dev *dev;\n\tstruct list_head *p;\n\tint *tmp_buf, *tmp_p;\n\n\tif (get_user(len, iobuf_len))\n\t\treturn -EFAULT;\n\tmutex_lock(&atm_dev_mutex);\n\tlist_for_each(p, &atm_devs)\n\t\tsize += sizeof(int);\n\tif (size > len) {\n\t\tmutex_unlock(&atm_dev_mutex);\n\t\treturn -E2BIG;\n\t}\n\ttmp_buf = kmalloc(size, GFP_ATOMIC);\n\tif (!tmp_buf) {\n\t\tmutex_unlock(&atm_dev_mutex);\n\t\treturn -ENOMEM;\n\t}\n\ttmp_p = tmp_buf;\n\tlist_for_each_entry(dev, &atm_devs, dev_list) {\n\t\t*tmp_p++ = dev->number;\n\t}\n\tmutex_unlock(&atm_dev_mutex);\n\terror = ((copy_to_user(buf, tmp_buf, size)) ||\n\t\t put_user(size, iobuf_len))\n\t\t? -EFAULT : 0;\n\tkfree(tmp_buf);\n\treturn error;\n}\n\nint atm_dev_ioctl(unsigned int cmd, void __user *buf, int __user *sioc_len,\n\t\t  int number, int compat)\n{\n\tint error, len, size = 0;\n\tstruct atm_dev *dev;\n\n\tif (get_user(len, sioc_len))\n\t\treturn -EFAULT;\n\n\tdev = try_then_request_module(atm_dev_lookup(number), \"atm-device-%d\",\n\t\t\t\t      number);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase ATM_GETTYPE:\n\t\tsize = strlen(dev->type) + 1;\n\t\tif (copy_to_user(buf, dev->type, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase ATM_GETESI:\n\t\tsize = ESI_LEN;\n\t\tif (copy_to_user(buf, dev->esi, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase ATM_SETESI:\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < ESI_LEN; i++)\n\t\t\tif (dev->esi[i]) {\n\t\t\t\terror = -EEXIST;\n\t\t\t\tgoto done;\n\t\t\t}\n\t}\n\t\tfallthrough;\n\tcase ATM_SETESIF:\n\t{\n\t\tunsigned char esi[ESI_LEN];\n\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\tif (copy_from_user(esi, buf, ESI_LEN)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tmemcpy(dev->esi, esi, ESI_LEN);\n\t\terror =  ESI_LEN;\n\t\tgoto done;\n\t}\n\tcase ATM_GETSTATZ:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\tfallthrough;\n\tcase ATM_GETSTAT:\n\t\tsize = sizeof(struct atm_dev_stats);\n\t\terror = fetch_stats(dev, buf, cmd == ATM_GETSTATZ);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\tcase ATM_GETCIRANGE:\n\t\tsize = sizeof(struct atm_cirange);\n\t\tif (copy_to_user(buf, &dev->ci_range, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase ATM_GETLINKRATE:\n\t\tsize = sizeof(int);\n\t\tif (copy_to_user(buf, &dev->link_rate, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase ATM_RSTADDR:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\tatm_reset_addr(dev, ATM_ADDR_LOCAL);\n\t\tbreak;\n\tcase ATM_ADDADDR:\n\tcase ATM_DELADDR:\n\tcase ATM_ADDLECSADDR:\n\tcase ATM_DELLECSADDR:\n\t{\n\t\tstruct sockaddr_atmsvc addr;\n\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (copy_from_user(&addr, buf, sizeof(addr))) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tif (cmd == ATM_ADDADDR || cmd == ATM_ADDLECSADDR)\n\t\t\terror = atm_add_addr(dev, &addr,\n\t\t\t\t\t     (cmd == ATM_ADDADDR ?\n\t\t\t\t\t      ATM_ADDR_LOCAL : ATM_ADDR_LECS));\n\t\telse\n\t\t\terror = atm_del_addr(dev, &addr,\n\t\t\t\t\t     (cmd == ATM_DELADDR ?\n\t\t\t\t\t      ATM_ADDR_LOCAL : ATM_ADDR_LECS));\n\t\tgoto done;\n\t}\n\tcase ATM_GETADDR:\n\tcase ATM_GETLECSADDR:\n\t\terror = atm_get_addr(dev, buf, len,\n\t\t\t\t     (cmd == ATM_GETADDR ?\n\t\t\t\t      ATM_ADDR_LOCAL : ATM_ADDR_LECS));\n\t\tif (error < 0)\n\t\t\tgoto done;\n\t\tsize = error;\n\t\t \n\t\terror = put_user(size, sioc_len) ? -EFAULT : 0;\n\t\tgoto done;\n\tcase ATM_SETLOOP:\n\t\tif (__ATM_LM_XTRMT((int) (unsigned long) buf) &&\n\t\t    __ATM_LM_XTLOC((int) (unsigned long) buf) >\n\t\t    __ATM_LM_XTRMT((int) (unsigned long) buf)) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tfallthrough;\n\tcase ATM_SETCIRANGE:\n\tcase SONET_GETSTATZ:\n\tcase SONET_SETDIAG:\n\tcase SONET_CLRDIAG:\n\tcase SONET_SETFRAMING:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tif (IS_ENABLED(CONFIG_COMPAT) && compat) {\n#ifdef CONFIG_COMPAT\n\t\t\tif (!dev->ops->compat_ioctl) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tsize = dev->ops->compat_ioctl(dev, cmd, buf);\n#endif\n\t\t} else {\n\t\t\tif (!dev->ops->ioctl) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tsize = dev->ops->ioctl(dev, cmd, buf);\n\t\t}\n\t\tif (size < 0) {\n\t\t\terror = (size == -ENOIOCTLCMD ? -ENOTTY : size);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (size)\n\t\terror = put_user(size, sioc_len) ? -EFAULT : 0;\n\telse\n\t\terror = 0;\ndone:\n\tatm_dev_put(dev);\n\treturn error;\n}\n\n#ifdef CONFIG_PROC_FS\nvoid *atm_dev_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tmutex_lock(&atm_dev_mutex);\n\treturn seq_list_start_head(&atm_devs, *pos);\n}\n\nvoid atm_dev_seq_stop(struct seq_file *seq, void *v)\n{\n\tmutex_unlock(&atm_dev_mutex);\n}\n\nvoid *atm_dev_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &atm_devs, pos);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}