{
  "module_name": "proc.c",
  "hash_id": "d0d78219bc6156cad106f1869d7b9bae5e83a30c806a16d3642636ba5ab4e58e",
  "original_prompt": "Ingested from linux-6.6.14/net/atm/proc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>  \n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/errno.h>\n#include <linux/atm.h>\n#include <linux/atmdev.h>\n#include <linux/netdevice.h>\n#include <linux/atmclip.h>\n#include <linux/init.h>  \n#include <linux/slab.h>\n#include <net/net_namespace.h>\n#include <net/atmclip.h>\n#include <linux/uaccess.h>\n#include <linux/param.h>  \n#include <linux/atomic.h>\n#include \"resources.h\"\n#include \"common.h\"  \n#include \"signaling.h\"  \n\nstatic ssize_t proc_dev_atm_read(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *pos);\n\nstatic const struct proc_ops atm_dev_proc_ops = {\n\t.proc_read\t= proc_dev_atm_read,\n\t.proc_lseek\t= noop_llseek,\n};\n\nstatic void add_stats(struct seq_file *seq, const char *aal,\n  const struct k_atm_aal_stats *stats)\n{\n\tseq_printf(seq, \"%s ( %d %d %d %d %d )\", aal,\n\t\t   atomic_read(&stats->tx), atomic_read(&stats->tx_err),\n\t\t   atomic_read(&stats->rx), atomic_read(&stats->rx_err),\n\t\t   atomic_read(&stats->rx_drop));\n}\n\nstatic void atm_dev_info(struct seq_file *seq, const struct atm_dev *dev)\n{\n\tint i;\n\n\tseq_printf(seq, \"%3d %-8s\", dev->number, dev->type);\n\tfor (i = 0; i < ESI_LEN; i++)\n\t\tseq_printf(seq, \"%02x\", dev->esi[i]);\n\tseq_puts(seq, \"  \");\n\tadd_stats(seq, \"0\", &dev->stats.aal0);\n\tseq_puts(seq, \"  \");\n\tadd_stats(seq, \"5\", &dev->stats.aal5);\n\tseq_printf(seq, \"\\t[%d]\", refcount_read(&dev->refcnt));\n\tseq_putc(seq, '\\n');\n}\n\nstruct vcc_state {\n\tint bucket;\n\tstruct sock *sk;\n};\n\nstatic inline int compare_family(struct sock *sk, int family)\n{\n\treturn !family || (sk->sk_family == family);\n}\n\nstatic int __vcc_walk(struct sock **sock, int family, int *bucket, loff_t l)\n{\n\tstruct sock *sk = *sock;\n\n\tif (sk == SEQ_START_TOKEN) {\n\t\tfor (*bucket = 0; *bucket < VCC_HTABLE_SIZE; ++*bucket) {\n\t\t\tstruct hlist_head *head = &vcc_hash[*bucket];\n\n\t\t\tsk = hlist_empty(head) ? NULL : __sk_head(head);\n\t\t\tif (sk)\n\t\t\t\tbreak;\n\t\t}\n\t\tl--;\n\t}\ntry_again:\n\tfor (; sk; sk = sk_next(sk)) {\n\t\tl -= compare_family(sk, family);\n\t\tif (l < 0)\n\t\t\tgoto out;\n\t}\n\tif (!sk && ++*bucket < VCC_HTABLE_SIZE) {\n\t\tsk = sk_head(&vcc_hash[*bucket]);\n\t\tgoto try_again;\n\t}\n\tsk = SEQ_START_TOKEN;\nout:\n\t*sock = sk;\n\treturn (l < 0);\n}\n\nstatic inline void *vcc_walk(struct seq_file *seq, loff_t l)\n{\n\tstruct vcc_state *state = seq->private;\n\tint family = (uintptr_t)(pde_data(file_inode(seq->file)));\n\n\treturn __vcc_walk(&state->sk, family, &state->bucket, l) ?\n\t       state : NULL;\n}\n\nstatic void *vcc_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(vcc_sklist_lock)\n{\n\tstruct vcc_state *state = seq->private;\n\tloff_t left = *pos;\n\n\tread_lock(&vcc_sklist_lock);\n\tstate->sk = SEQ_START_TOKEN;\n\treturn left ? vcc_walk(seq, left) : SEQ_START_TOKEN;\n}\n\nstatic void vcc_seq_stop(struct seq_file *seq, void *v)\n\t__releases(vcc_sklist_lock)\n{\n\tread_unlock(&vcc_sklist_lock);\n}\n\nstatic void *vcc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tv = vcc_walk(seq, 1);\n\t(*pos)++;\n\treturn v;\n}\n\nstatic void pvc_info(struct seq_file *seq, struct atm_vcc *vcc)\n{\n\tstatic const char *const class_name[] = {\n\t\t\"off\", \"UBR\", \"CBR\", \"VBR\", \"ABR\"};\n\tstatic const char *const aal_name[] = {\n\t\t\"---\",\t\"1\",\t\"2\",\t\"3/4\",\t \n\t\t\"???\",\t\"5\",\t\"???\",\t\"???\",\t \n\t\t\"???\",\t\"???\",\t\"???\",\t\"???\",\t \n\t\t\"???\",\t\"0\",\t\"???\",\t\"???\"};\t \n\n\tseq_printf(seq, \"%3d %3d %5d %-3s %7d %-5s %7d %-6s\",\n\t\t   vcc->dev->number, vcc->vpi, vcc->vci,\n\t\t   vcc->qos.aal >= ARRAY_SIZE(aal_name) ? \"err\" :\n\t\t   aal_name[vcc->qos.aal], vcc->qos.rxtp.min_pcr,\n\t\t   class_name[vcc->qos.rxtp.traffic_class],\n\t\t   vcc->qos.txtp.min_pcr,\n\t\t   class_name[vcc->qos.txtp.traffic_class]);\n\tif (test_bit(ATM_VF_IS_CLIP, &vcc->flags)) {\n\t\tstruct clip_vcc *clip_vcc = CLIP_VCC(vcc);\n\t\tstruct net_device *dev;\n\n\t\tdev = clip_vcc->entry ? clip_vcc->entry->neigh->dev : NULL;\n\t\tseq_printf(seq, \"CLIP, Itf:%s, Encap:\",\n\t\t    dev ? dev->name : \"none?\");\n\t\tseq_printf(seq, \"%s\", clip_vcc->encap ? \"LLC/SNAP\" : \"None\");\n\t}\n\tseq_putc(seq, '\\n');\n}\n\nstatic const char *vcc_state(struct atm_vcc *vcc)\n{\n\tstatic const char *const map[] = { ATM_VS2TXT_MAP };\n\n\treturn map[ATM_VF2VS(vcc->flags)];\n}\n\nstatic void vcc_info(struct seq_file *seq, struct atm_vcc *vcc)\n{\n\tstruct sock *sk = sk_atm(vcc);\n\n\tseq_printf(seq, \"%pK \", vcc);\n\tif (!vcc->dev)\n\t\tseq_printf(seq, \"Unassigned    \");\n\telse\n\t\tseq_printf(seq, \"%3d %3d %5d \", vcc->dev->number, vcc->vpi,\n\t\t\tvcc->vci);\n\tswitch (sk->sk_family) {\n\tcase AF_ATMPVC:\n\t\tseq_printf(seq, \"PVC\");\n\t\tbreak;\n\tcase AF_ATMSVC:\n\t\tseq_printf(seq, \"SVC\");\n\t\tbreak;\n\tdefault:\n\t\tseq_printf(seq, \"%3d\", sk->sk_family);\n\t}\n\tseq_printf(seq, \" %04lx  %5d %7d/%7d %7d/%7d [%d]\\n\",\n\t\t   vcc->flags, sk->sk_err,\n\t\t   sk_wmem_alloc_get(sk), sk->sk_sndbuf,\n\t\t   sk_rmem_alloc_get(sk), sk->sk_rcvbuf,\n\t\t   refcount_read(&sk->sk_refcnt));\n}\n\nstatic void svc_info(struct seq_file *seq, struct atm_vcc *vcc)\n{\n\tif (!vcc->dev)\n\t\tseq_printf(seq, sizeof(void *) == 4 ?\n\t\t\t   \"N/A@%pK%10s\" : \"N/A@%pK%2s\", vcc, \"\");\n\telse\n\t\tseq_printf(seq, \"%3d %3d %5d         \",\n\t\t\t   vcc->dev->number, vcc->vpi, vcc->vci);\n\tseq_printf(seq, \"%-10s \", vcc_state(vcc));\n\tseq_printf(seq, \"%s%s\", vcc->remote.sas_addr.pub,\n\t    *vcc->remote.sas_addr.pub && *vcc->remote.sas_addr.prv ? \"+\" : \"\");\n\tif (*vcc->remote.sas_addr.prv) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ATM_ESA_LEN; i++)\n\t\t\tseq_printf(seq, \"%02x\", vcc->remote.sas_addr.prv[i]);\n\t}\n\tseq_putc(seq, '\\n');\n}\n\nstatic int atm_dev_seq_show(struct seq_file *seq, void *v)\n{\n\tstatic char atm_dev_banner[] =\n\t\t\"Itf Type    ESI/\\\"MAC\\\"addr \"\n\t\t\"AAL(TX,err,RX,err,drop) ...               [refcnt]\\n\";\n\n\tif (v == &atm_devs)\n\t\tseq_puts(seq, atm_dev_banner);\n\telse {\n\t\tstruct atm_dev *dev = list_entry(v, struct atm_dev, dev_list);\n\n\t\tatm_dev_info(seq, dev);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations atm_dev_seq_ops = {\n\t.start\t= atm_dev_seq_start,\n\t.next\t= atm_dev_seq_next,\n\t.stop\t= atm_dev_seq_stop,\n\t.show\t= atm_dev_seq_show,\n};\n\nstatic int pvc_seq_show(struct seq_file *seq, void *v)\n{\n\tstatic char atm_pvc_banner[] =\n\t\t\"Itf VPI VCI   AAL RX(PCR,Class) TX(PCR,Class)\\n\";\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, atm_pvc_banner);\n\telse {\n\t\tstruct vcc_state *state = seq->private;\n\t\tstruct atm_vcc *vcc = atm_sk(state->sk);\n\n\t\tpvc_info(seq, vcc);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations pvc_seq_ops = {\n\t.start\t= vcc_seq_start,\n\t.next\t= vcc_seq_next,\n\t.stop\t= vcc_seq_stop,\n\t.show\t= pvc_seq_show,\n};\n\nstatic int vcc_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq, sizeof(void *) == 4 ? \"%-8s%s\" : \"%-16s%s\",\n\t\t\t\"Address \", \"Itf VPI VCI   Fam Flags Reply \"\n\t\t\t\"Send buffer     Recv buffer      [refcnt]\\n\");\n\t} else {\n\t\tstruct vcc_state *state = seq->private;\n\t\tstruct atm_vcc *vcc = atm_sk(state->sk);\n\n\t\tvcc_info(seq, vcc);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations vcc_seq_ops = {\n\t.start\t= vcc_seq_start,\n\t.next\t= vcc_seq_next,\n\t.stop\t= vcc_seq_stop,\n\t.show\t= vcc_seq_show,\n};\n\nstatic int svc_seq_show(struct seq_file *seq, void *v)\n{\n\tstatic const char atm_svc_banner[] =\n\t\t\"Itf VPI VCI           State      Remote\\n\";\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, atm_svc_banner);\n\telse {\n\t\tstruct vcc_state *state = seq->private;\n\t\tstruct atm_vcc *vcc = atm_sk(state->sk);\n\n\t\tsvc_info(seq, vcc);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations svc_seq_ops = {\n\t.start\t= vcc_seq_start,\n\t.next\t= vcc_seq_next,\n\t.stop\t= vcc_seq_stop,\n\t.show\t= svc_seq_show,\n};\n\nstatic ssize_t proc_dev_atm_read(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *pos)\n{\n\tstruct atm_dev *dev;\n\tunsigned long page;\n\tint length;\n\n\tif (count == 0)\n\t\treturn 0;\n\tpage = get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tdev = pde_data(file_inode(file));\n\tif (!dev->ops->proc_read)\n\t\tlength = -EINVAL;\n\telse {\n\t\tlength = dev->ops->proc_read(dev, pos, (char *)page);\n\t\tif (length > count)\n\t\t\tlength = -EINVAL;\n\t}\n\tif (length >= 0) {\n\t\tif (copy_to_user(buf, (char *)page, length))\n\t\t\tlength = -EFAULT;\n\t\t(*pos)++;\n\t}\n\tfree_page(page);\n\treturn length;\n}\n\nstruct proc_dir_entry *atm_proc_root;\nEXPORT_SYMBOL(atm_proc_root);\n\n\nint atm_proc_dev_register(struct atm_dev *dev)\n{\n\tint error;\n\n\t \n\tif (!dev->ops->proc_read)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\tdev->proc_name = kasprintf(GFP_KERNEL, \"%s:%d\", dev->type, dev->number);\n\tif (!dev->proc_name)\n\t\tgoto err_out;\n\n\tdev->proc_entry = proc_create_data(dev->proc_name, 0, atm_proc_root,\n\t\t\t\t\t   &atm_dev_proc_ops, dev);\n\tif (!dev->proc_entry)\n\t\tgoto err_free_name;\n\treturn 0;\n\nerr_free_name:\n\tkfree(dev->proc_name);\nerr_out:\n\treturn error;\n}\n\nvoid atm_proc_dev_deregister(struct atm_dev *dev)\n{\n\tif (!dev->ops->proc_read)\n\t\treturn;\n\n\tremove_proc_entry(dev->proc_name, atm_proc_root);\n\tkfree(dev->proc_name);\n}\n\nint __init atm_proc_init(void)\n{\n\tatm_proc_root = proc_net_mkdir(&init_net, \"atm\", init_net.proc_net);\n\tif (!atm_proc_root)\n\t\treturn -ENOMEM;\n\tproc_create_seq(\"devices\", 0444, atm_proc_root, &atm_dev_seq_ops);\n\tproc_create_seq_private(\"pvc\", 0444, atm_proc_root, &pvc_seq_ops,\n\t\t\tsizeof(struct vcc_state), (void *)(uintptr_t)PF_ATMPVC);\n\tproc_create_seq_private(\"svc\", 0444, atm_proc_root, &svc_seq_ops,\n\t\t\tsizeof(struct vcc_state), (void *)(uintptr_t)PF_ATMSVC);\n\tproc_create_seq_private(\"vc\", 0444, atm_proc_root, &vcc_seq_ops,\n\t\t\tsizeof(struct vcc_state), NULL);\n\treturn 0;\n}\n\nvoid atm_proc_exit(void)\n{\n\tremove_proc_subtree(\"atm\", init_net.proc_net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}