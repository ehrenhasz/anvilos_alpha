{
  "module_name": "raw.c",
  "hash_id": "7cf31bf732fff72e6adbcfc9e40adb80b7ef0e52f15294d15a2e70f7bfeebaab",
  "original_prompt": "Ingested from linux-6.6.14/net/can/raw.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/uio.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/socket.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/can.h>\n#include <linux/can/core.h>\n#include <linux/can/dev.h>  \n#include <linux/can/skb.h>\n#include <linux/can/raw.h>\n#include <net/sock.h>\n#include <net/net_namespace.h>\n\nMODULE_DESCRIPTION(\"PF_CAN raw protocol\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Urs Thuermann <urs.thuermann@volkswagen.de>\");\nMODULE_ALIAS(\"can-proto-1\");\n\n#define RAW_MIN_NAMELEN CAN_REQUIRED_SIZE(struct sockaddr_can, can_ifindex)\n\n#define MASK_ALL 0\n\n \n\nstruct uniqframe {\n\tint skbcnt;\n\tconst struct sk_buff *skb;\n\tunsigned int join_rx_count;\n};\n\nstruct raw_sock {\n\tstruct sock sk;\n\tint bound;\n\tint ifindex;\n\tstruct net_device *dev;\n\tnetdevice_tracker dev_tracker;\n\tstruct list_head notifier;\n\tint loopback;\n\tint recv_own_msgs;\n\tint fd_frames;\n\tint xl_frames;\n\tint join_filters;\n\tint count;                  \n\tstruct can_filter dfilter;  \n\tstruct can_filter *filter;  \n\tcan_err_mask_t err_mask;\n\tstruct uniqframe __percpu *uniq;\n};\n\nstatic LIST_HEAD(raw_notifier_list);\nstatic DEFINE_SPINLOCK(raw_notifier_lock);\nstatic struct raw_sock *raw_busy_notifier;\n\n \nstatic inline unsigned int *raw_flags(struct sk_buff *skb)\n{\n\tsock_skb_cb_check_size(sizeof(struct sockaddr_can) +\n\t\t\t       sizeof(unsigned int));\n\n\t \n\treturn (unsigned int *)(&((struct sockaddr_can *)skb->cb)[1]);\n}\n\nstatic inline struct raw_sock *raw_sk(const struct sock *sk)\n{\n\treturn (struct raw_sock *)sk;\n}\n\nstatic void raw_rcv(struct sk_buff *oskb, void *data)\n{\n\tstruct sock *sk = (struct sock *)data;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tstruct sockaddr_can *addr;\n\tstruct sk_buff *skb;\n\tunsigned int *pflags;\n\n\t \n\tif (!ro->recv_own_msgs && oskb->sk == sk)\n\t\treturn;\n\n\t \n\tif ((!ro->fd_frames && can_is_canfd_skb(oskb)) ||\n\t    (!ro->xl_frames && can_is_canxl_skb(oskb)))\n\t\treturn;\n\n\t \n\tif (this_cpu_ptr(ro->uniq)->skb == oskb &&\n\t    this_cpu_ptr(ro->uniq)->skbcnt == can_skb_prv(oskb)->skbcnt) {\n\t\tif (!ro->join_filters)\n\t\t\treturn;\n\n\t\tthis_cpu_inc(ro->uniq->join_rx_count);\n\t\t \n\t\tif (this_cpu_ptr(ro->uniq)->join_rx_count < ro->count)\n\t\t\treturn;\n\t} else {\n\t\tthis_cpu_ptr(ro->uniq)->skb = oskb;\n\t\tthis_cpu_ptr(ro->uniq)->skbcnt = can_skb_prv(oskb)->skbcnt;\n\t\tthis_cpu_ptr(ro->uniq)->join_rx_count = 1;\n\t\t \n\t\tif (ro->join_filters && ro->count > 1)\n\t\t\treturn;\n\t}\n\n\t \n\tskb = skb_clone(oskb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\t \n\n\tsock_skb_cb_check_size(sizeof(struct sockaddr_can));\n\taddr = (struct sockaddr_can *)skb->cb;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->can_family = AF_CAN;\n\taddr->can_ifindex = skb->dev->ifindex;\n\n\t \n\tpflags = raw_flags(skb);\n\t*pflags = 0;\n\tif (oskb->sk)\n\t\t*pflags |= MSG_DONTROUTE;\n\tif (oskb->sk == sk)\n\t\t*pflags |= MSG_CONFIRM;\n\n\tif (sock_queue_rcv_skb(sk, skb) < 0)\n\t\tkfree_skb(skb);\n}\n\nstatic int raw_enable_filters(struct net *net, struct net_device *dev,\n\t\t\t      struct sock *sk, struct can_filter *filter,\n\t\t\t      int count)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\terr = can_rx_register(net, dev, filter[i].can_id,\n\t\t\t\t      filter[i].can_mask,\n\t\t\t\t      raw_rcv, sk, \"raw\", sk);\n\t\tif (err) {\n\t\t\t \n\t\t\twhile (--i >= 0)\n\t\t\t\tcan_rx_unregister(net, dev, filter[i].can_id,\n\t\t\t\t\t\t  filter[i].can_mask,\n\t\t\t\t\t\t  raw_rcv, sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int raw_enable_errfilter(struct net *net, struct net_device *dev,\n\t\t\t\tstruct sock *sk, can_err_mask_t err_mask)\n{\n\tint err = 0;\n\n\tif (err_mask)\n\t\terr = can_rx_register(net, dev, 0, err_mask | CAN_ERR_FLAG,\n\t\t\t\t      raw_rcv, sk, \"raw\", sk);\n\n\treturn err;\n}\n\nstatic void raw_disable_filters(struct net *net, struct net_device *dev,\n\t\t\t\tstruct sock *sk, struct can_filter *filter,\n\t\t\t\tint count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tcan_rx_unregister(net, dev, filter[i].can_id,\n\t\t\t\t  filter[i].can_mask, raw_rcv, sk);\n}\n\nstatic inline void raw_disable_errfilter(struct net *net,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t struct sock *sk,\n\t\t\t\t\t can_err_mask_t err_mask)\n\n{\n\tif (err_mask)\n\t\tcan_rx_unregister(net, dev, 0, err_mask | CAN_ERR_FLAG,\n\t\t\t\t  raw_rcv, sk);\n}\n\nstatic inline void raw_disable_allfilters(struct net *net,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  struct sock *sk)\n{\n\tstruct raw_sock *ro = raw_sk(sk);\n\n\traw_disable_filters(net, dev, sk, ro->filter, ro->count);\n\traw_disable_errfilter(net, dev, sk, ro->err_mask);\n}\n\nstatic int raw_enable_allfilters(struct net *net, struct net_device *dev,\n\t\t\t\t struct sock *sk)\n{\n\tstruct raw_sock *ro = raw_sk(sk);\n\tint err;\n\n\terr = raw_enable_filters(net, dev, sk, ro->filter, ro->count);\n\tif (!err) {\n\t\terr = raw_enable_errfilter(net, dev, sk, ro->err_mask);\n\t\tif (err)\n\t\t\traw_disable_filters(net, dev, sk, ro->filter,\n\t\t\t\t\t    ro->count);\n\t}\n\n\treturn err;\n}\n\nstatic void raw_notify(struct raw_sock *ro, unsigned long msg,\n\t\t       struct net_device *dev)\n{\n\tstruct sock *sk = &ro->sk;\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\treturn;\n\n\tif (ro->dev != dev)\n\t\treturn;\n\n\tswitch (msg) {\n\tcase NETDEV_UNREGISTER:\n\t\tlock_sock(sk);\n\t\t \n\t\tif (ro->bound) {\n\t\t\traw_disable_allfilters(dev_net(dev), dev, sk);\n\t\t\tnetdev_put(dev, &ro->dev_tracker);\n\t\t}\n\n\t\tif (ro->count > 1)\n\t\t\tkfree(ro->filter);\n\n\t\tro->ifindex = 0;\n\t\tro->bound = 0;\n\t\tro->dev = NULL;\n\t\tro->count = 0;\n\t\trelease_sock(sk);\n\n\t\tsk->sk_err = ENODEV;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tsk->sk_err = ENETDOWN;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\t\tbreak;\n\t}\n}\n\nstatic int raw_notifier(struct notifier_block *nb, unsigned long msg,\n\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (dev->type != ARPHRD_CAN)\n\t\treturn NOTIFY_DONE;\n\tif (msg != NETDEV_UNREGISTER && msg != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\tif (unlikely(raw_busy_notifier))  \n\t\treturn NOTIFY_DONE;\n\n\tspin_lock(&raw_notifier_lock);\n\tlist_for_each_entry(raw_busy_notifier, &raw_notifier_list, notifier) {\n\t\tspin_unlock(&raw_notifier_lock);\n\t\traw_notify(raw_busy_notifier, msg, dev);\n\t\tspin_lock(&raw_notifier_lock);\n\t}\n\traw_busy_notifier = NULL;\n\tspin_unlock(&raw_notifier_lock);\n\treturn NOTIFY_DONE;\n}\n\nstatic int raw_init(struct sock *sk)\n{\n\tstruct raw_sock *ro = raw_sk(sk);\n\n\tro->bound            = 0;\n\tro->ifindex          = 0;\n\tro->dev              = NULL;\n\n\t \n\tro->dfilter.can_id   = 0;\n\tro->dfilter.can_mask = MASK_ALL;\n\tro->filter           = &ro->dfilter;\n\tro->count            = 1;\n\n\t \n\tro->loopback         = 1;\n\tro->recv_own_msgs    = 0;\n\tro->fd_frames        = 0;\n\tro->xl_frames        = 0;\n\tro->join_filters     = 0;\n\n\t \n\tro->uniq = alloc_percpu(struct uniqframe);\n\tif (unlikely(!ro->uniq))\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock(&raw_notifier_lock);\n\tlist_add_tail(&ro->notifier, &raw_notifier_list);\n\tspin_unlock(&raw_notifier_lock);\n\n\treturn 0;\n}\n\nstatic int raw_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tro = raw_sk(sk);\n\n\tspin_lock(&raw_notifier_lock);\n\twhile (raw_busy_notifier == ro) {\n\t\tspin_unlock(&raw_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&raw_notifier_lock);\n\t}\n\tlist_del(&ro->notifier);\n\tspin_unlock(&raw_notifier_lock);\n\n\trtnl_lock();\n\tlock_sock(sk);\n\n\t \n\tif (ro->bound) {\n\t\tif (ro->dev) {\n\t\t\traw_disable_allfilters(dev_net(ro->dev), ro->dev, sk);\n\t\t\tnetdev_put(ro->dev, &ro->dev_tracker);\n\t\t} else {\n\t\t\traw_disable_allfilters(sock_net(sk), NULL, sk);\n\t\t}\n\t}\n\n\tif (ro->count > 1)\n\t\tkfree(ro->filter);\n\n\tro->ifindex = 0;\n\tro->bound = 0;\n\tro->dev = NULL;\n\tro->count = 0;\n\tfree_percpu(ro->uniq);\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\trelease_sock(sk);\n\trtnl_unlock();\n\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tstruct net_device *dev = NULL;\n\tint ifindex;\n\tint err = 0;\n\tint notify_enetdown = 0;\n\n\tif (len < RAW_MIN_NAMELEN)\n\t\treturn -EINVAL;\n\tif (addr->can_family != AF_CAN)\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\tlock_sock(sk);\n\n\tif (ro->bound && addr->can_ifindex == ro->ifindex)\n\t\tgoto out;\n\n\tif (addr->can_ifindex) {\n\t\tdev = dev_get_by_index(sock_net(sk), addr->can_ifindex);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (dev->type != ARPHRD_CAN) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_put_dev;\n\t\t}\n\n\t\tif (!(dev->flags & IFF_UP))\n\t\t\tnotify_enetdown = 1;\n\n\t\tifindex = dev->ifindex;\n\n\t\t \n\t\terr = raw_enable_allfilters(sock_net(sk), dev, sk);\n\t\tif (err)\n\t\t\tgoto out_put_dev;\n\n\t} else {\n\t\tifindex = 0;\n\n\t\t \n\t\terr = raw_enable_allfilters(sock_net(sk), NULL, sk);\n\t}\n\n\tif (!err) {\n\t\tif (ro->bound) {\n\t\t\t \n\t\t\tif (ro->dev) {\n\t\t\t\traw_disable_allfilters(dev_net(ro->dev),\n\t\t\t\t\t\t       ro->dev, sk);\n\t\t\t\t \n\t\t\t\tnetdev_put(ro->dev, &ro->dev_tracker);\n\t\t\t} else {\n\t\t\t\traw_disable_allfilters(sock_net(sk), NULL, sk);\n\t\t\t}\n\t\t}\n\t\tro->ifindex = ifindex;\n\t\tro->bound = 1;\n\t\t \n\t\tro->dev = dev;\n\t\tif (ro->dev)\n\t\t\tnetdev_hold(ro->dev, &ro->dev_tracker, GFP_KERNEL);\n\t}\n\nout_put_dev:\n\t \n\tif (dev)\n\t\tdev_put(dev);\nout:\n\trelease_sock(sk);\n\trtnl_unlock();\n\n\tif (notify_enetdown) {\n\t\tsk->sk_err = ENETDOWN;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\t}\n\n\treturn err;\n}\n\nstatic int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(addr, 0, RAW_MIN_NAMELEN);\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\n\treturn RAW_MIN_NAMELEN;\n}\n\nstatic int raw_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tstruct can_filter *filter = NULL;   \n\tstruct can_filter sfilter;          \n\tstruct net_device *dev = NULL;\n\tcan_err_mask_t err_mask = 0;\n\tint fd_frames;\n\tint count = 0;\n\tint err = 0;\n\n\tif (level != SOL_CAN_RAW)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase CAN_RAW_FILTER:\n\t\tif (optlen % sizeof(struct can_filter) != 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (optlen > CAN_RAW_FILTER_MAX * sizeof(struct can_filter))\n\t\t\treturn -EINVAL;\n\n\t\tcount = optlen / sizeof(struct can_filter);\n\n\t\tif (count > 1) {\n\t\t\t \n\t\t\tfilter = memdup_sockptr(optval, optlen);\n\t\t\tif (IS_ERR(filter))\n\t\t\t\treturn PTR_ERR(filter);\n\t\t} else if (count == 1) {\n\t\t\tif (copy_from_sockptr(&sfilter, optval, sizeof(sfilter)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\trtnl_lock();\n\t\tlock_sock(sk);\n\n\t\tdev = ro->dev;\n\t\tif (ro->bound && dev) {\n\t\t\tif (dev->reg_state != NETREG_REGISTERED) {\n\t\t\t\tif (count > 1)\n\t\t\t\t\tkfree(filter);\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto out_fil;\n\t\t\t}\n\t\t}\n\n\t\tif (ro->bound) {\n\t\t\t \n\t\t\tif (count == 1)\n\t\t\t\terr = raw_enable_filters(sock_net(sk), dev, sk,\n\t\t\t\t\t\t\t &sfilter, 1);\n\t\t\telse\n\t\t\t\terr = raw_enable_filters(sock_net(sk), dev, sk,\n\t\t\t\t\t\t\t filter, count);\n\t\t\tif (err) {\n\t\t\t\tif (count > 1)\n\t\t\t\t\tkfree(filter);\n\t\t\t\tgoto out_fil;\n\t\t\t}\n\n\t\t\t \n\t\t\traw_disable_filters(sock_net(sk), dev, sk, ro->filter,\n\t\t\t\t\t    ro->count);\n\t\t}\n\n\t\t \n\t\tif (ro->count > 1)\n\t\t\tkfree(ro->filter);\n\n\t\t \n\t\tif (count == 1) {\n\t\t\t \n\t\t\tro->dfilter = sfilter;\n\t\t\tfilter = &ro->dfilter;\n\t\t}\n\t\tro->filter = filter;\n\t\tro->count  = count;\n\n out_fil:\n\t\trelease_sock(sk);\n\t\trtnl_unlock();\n\n\t\tbreak;\n\n\tcase CAN_RAW_ERR_FILTER:\n\t\tif (optlen != sizeof(err_mask))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&err_mask, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\terr_mask &= CAN_ERR_MASK;\n\n\t\trtnl_lock();\n\t\tlock_sock(sk);\n\n\t\tdev = ro->dev;\n\t\tif (ro->bound && dev) {\n\t\t\tif (dev->reg_state != NETREG_REGISTERED) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ro->bound) {\n\t\t\t \n\t\t\terr = raw_enable_errfilter(sock_net(sk), dev, sk,\n\t\t\t\t\t\t   err_mask);\n\n\t\t\tif (err)\n\t\t\t\tgoto out_err;\n\n\t\t\t \n\t\t\traw_disable_errfilter(sock_net(sk), dev, sk,\n\t\t\t\t\t      ro->err_mask);\n\t\t}\n\n\t\t \n\t\tro->err_mask = err_mask;\n\n out_err:\n\t\trelease_sock(sk);\n\t\trtnl_unlock();\n\n\t\tbreak;\n\n\tcase CAN_RAW_LOOPBACK:\n\t\tif (optlen != sizeof(ro->loopback))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&ro->loopback, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\tcase CAN_RAW_RECV_OWN_MSGS:\n\t\tif (optlen != sizeof(ro->recv_own_msgs))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&ro->recv_own_msgs, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\tcase CAN_RAW_FD_FRAMES:\n\t\tif (optlen != sizeof(fd_frames))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&fd_frames, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (ro->xl_frames && !fd_frames)\n\t\t\treturn -EINVAL;\n\n\t\tro->fd_frames = fd_frames;\n\t\tbreak;\n\n\tcase CAN_RAW_XL_FRAMES:\n\t\tif (optlen != sizeof(ro->xl_frames))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&ro->xl_frames, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (ro->xl_frames)\n\t\t\tro->fd_frames = ro->xl_frames;\n\t\tbreak;\n\n\tcase CAN_RAW_JOIN_FILTERS:\n\t\tif (optlen != sizeof(ro->join_filters))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&ro->join_filters, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\treturn err;\n}\n\nstatic int raw_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tint len;\n\tvoid *val;\n\tint err = 0;\n\n\tif (level != SOL_CAN_RAW)\n\t\treturn -EINVAL;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase CAN_RAW_FILTER:\n\t\tlock_sock(sk);\n\t\tif (ro->count > 0) {\n\t\t\tint fsize = ro->count * sizeof(struct can_filter);\n\n\t\t\t \n\t\t\tif (len < fsize) {\n\t\t\t\t \n\t\t\t\terr = -ERANGE;\n\t\t\t\tif (put_user(fsize, optlen))\n\t\t\t\t\terr = -EFAULT;\n\t\t\t} else {\n\t\t\t\tif (len > fsize)\n\t\t\t\t\tlen = fsize;\n\t\t\t\tif (copy_to_user(optval, ro->filter, len))\n\t\t\t\t\terr = -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\n\t\trelease_sock(sk);\n\n\t\tif (!err)\n\t\t\terr = put_user(len, optlen);\n\t\treturn err;\n\n\tcase CAN_RAW_ERR_FILTER:\n\t\tif (len > sizeof(can_err_mask_t))\n\t\t\tlen = sizeof(can_err_mask_t);\n\t\tval = &ro->err_mask;\n\t\tbreak;\n\n\tcase CAN_RAW_LOOPBACK:\n\t\tif (len > sizeof(int))\n\t\t\tlen = sizeof(int);\n\t\tval = &ro->loopback;\n\t\tbreak;\n\n\tcase CAN_RAW_RECV_OWN_MSGS:\n\t\tif (len > sizeof(int))\n\t\t\tlen = sizeof(int);\n\t\tval = &ro->recv_own_msgs;\n\t\tbreak;\n\n\tcase CAN_RAW_FD_FRAMES:\n\t\tif (len > sizeof(int))\n\t\t\tlen = sizeof(int);\n\t\tval = &ro->fd_frames;\n\t\tbreak;\n\n\tcase CAN_RAW_XL_FRAMES:\n\t\tif (len > sizeof(int))\n\t\t\tlen = sizeof(int);\n\t\tval = &ro->xl_frames;\n\t\tbreak;\n\n\tcase CAN_RAW_JOIN_FILTERS:\n\t\tif (len > sizeof(int))\n\t\t\tlen = sizeof(int);\n\t\tval = &ro->join_filters;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic bool raw_bad_txframe(struct raw_sock *ro, struct sk_buff *skb, int mtu)\n{\n\t \n\tif (can_is_can_skb(skb))\n\t\treturn false;\n\n\t \n\tif (ro->fd_frames && can_is_canfd_skb(skb) &&\n\t    (mtu == CANFD_MTU || can_is_canxl_dev_mtu(mtu)))\n\t\treturn false;\n\n\t \n\tif (ro->xl_frames && can_is_canxl_skb(skb) &&\n\t    can_is_canxl_dev_mtu(mtu))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int raw_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tstruct sockcm_cookie sockc;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tint ifindex;\n\tint err = -EINVAL;\n\n\t \n\tif (size < CANXL_HDR_SIZE + CANXL_MIN_DLEN || size > CANXL_MTU)\n\t\treturn -EINVAL;\n\n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);\n\n\t\tif (msg->msg_namelen < RAW_MIN_NAMELEN)\n\t\t\treturn -EINVAL;\n\n\t\tif (addr->can_family != AF_CAN)\n\t\t\treturn -EINVAL;\n\n\t\tifindex = addr->can_ifindex;\n\t} else {\n\t\tifindex = ro->ifindex;\n\t}\n\n\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\tif (!dev)\n\t\treturn -ENXIO;\n\n\tskb = sock_alloc_send_skb(sk, size + sizeof(struct can_skb_priv),\n\t\t\t\t  msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto put_dev;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\t \n\terr = memcpy_from_msg(skb_put(skb, size), msg, size);\n\tif (err < 0)\n\t\tgoto free_skb;\n\n\terr = -EINVAL;\n\tif (raw_bad_txframe(ro, skb, dev->mtu))\n\t\tgoto free_skb;\n\n\tsockcm_init(&sockc, sk);\n\tif (msg->msg_controllen) {\n\t\terr = sock_cmsg_send(sk, msg, &sockc);\n\t\tif (unlikely(err))\n\t\t\tgoto free_skb;\n\t}\n\n\tskb->dev = dev;\n\tskb->priority = sk->sk_priority;\n\tskb->mark = READ_ONCE(sk->sk_mark);\n\tskb->tstamp = sockc.transmit_time;\n\n\tskb_setup_tx_timestamp(skb, sockc.tsflags);\n\n\terr = can_send(skb, ro->loopback);\n\n\tdev_put(dev);\n\n\tif (err)\n\t\tgoto send_failed;\n\n\treturn size;\n\nfree_skb:\n\tkfree_skb(skb);\nput_dev:\n\tdev_put(dev);\nsend_failed:\n\treturn err;\n}\n\nstatic int raw_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn sock_recv_errqueue(sk, msg, size,\n\t\t\t\t\t  SOL_CAN_RAW, SCM_CAN_RAW_ERRQUEUE);\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (size < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\telse\n\t\tsize = skb->len;\n\n\terr = memcpy_to_msg(msg, skb->data, size);\n\tif (err < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\treturn err;\n\t}\n\n\tsock_recv_cmsgs(msg, sk, skb);\n\n\tif (msg->msg_name) {\n\t\t__sockaddr_check_size(RAW_MIN_NAMELEN);\n\t\tmsg->msg_namelen = RAW_MIN_NAMELEN;\n\t\tmemcpy(msg->msg_name, skb->cb, msg->msg_namelen);\n\t}\n\n\t \n\tmsg->msg_flags |= *(raw_flags(skb));\n\n\tskb_free_datagram(sk, skb);\n\n\treturn size;\n}\n\nstatic int raw_sock_no_ioctlcmd(struct socket *sock, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\t \n\treturn -ENOIOCTLCMD;\n}\n\nstatic const struct proto_ops raw_ops = {\n\t.family        = PF_CAN,\n\t.release       = raw_release,\n\t.bind          = raw_bind,\n\t.connect       = sock_no_connect,\n\t.socketpair    = sock_no_socketpair,\n\t.accept        = sock_no_accept,\n\t.getname       = raw_getname,\n\t.poll          = datagram_poll,\n\t.ioctl         = raw_sock_no_ioctlcmd,\n\t.gettstamp     = sock_gettstamp,\n\t.listen        = sock_no_listen,\n\t.shutdown      = sock_no_shutdown,\n\t.setsockopt    = raw_setsockopt,\n\t.getsockopt    = raw_getsockopt,\n\t.sendmsg       = raw_sendmsg,\n\t.recvmsg       = raw_recvmsg,\n\t.mmap          = sock_no_mmap,\n};\n\nstatic struct proto raw_proto __read_mostly = {\n\t.name       = \"CAN_RAW\",\n\t.owner      = THIS_MODULE,\n\t.obj_size   = sizeof(struct raw_sock),\n\t.init       = raw_init,\n};\n\nstatic const struct can_proto raw_can_proto = {\n\t.type       = SOCK_RAW,\n\t.protocol   = CAN_RAW,\n\t.ops        = &raw_ops,\n\t.prot       = &raw_proto,\n};\n\nstatic struct notifier_block canraw_notifier = {\n\t.notifier_call = raw_notifier\n};\n\nstatic __init int raw_module_init(void)\n{\n\tint err;\n\n\tpr_info(\"can: raw protocol\\n\");\n\n\terr = register_netdevice_notifier(&canraw_notifier);\n\tif (err)\n\t\treturn err;\n\n\terr = can_proto_register(&raw_can_proto);\n\tif (err < 0) {\n\t\tpr_err(\"can: registration of raw protocol failed\\n\");\n\t\tgoto register_proto_failed;\n\t}\n\n\treturn 0;\n\nregister_proto_failed:\n\tunregister_netdevice_notifier(&canraw_notifier);\n\treturn err;\n}\n\nstatic __exit void raw_module_exit(void)\n{\n\tcan_proto_unregister(&raw_can_proto);\n\tunregister_netdevice_notifier(&canraw_notifier);\n}\n\nmodule_init(raw_module_init);\nmodule_exit(raw_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}