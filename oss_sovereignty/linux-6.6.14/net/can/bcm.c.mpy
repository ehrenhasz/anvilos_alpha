{
  "module_name": "bcm.c",
  "hash_id": "098aa9b4e9746f3dc3127e39b2c11fc4bed53b03597e8ef7a8c7ca66884183e0",
  "original_prompt": "Ingested from linux-6.6.14/net/can/bcm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/list.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uio.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/socket.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/can.h>\n#include <linux/can/core.h>\n#include <linux/can/skb.h>\n#include <linux/can/bcm.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/net_namespace.h>\n\n \n#define MAX_NFRAMES 256\n\n \n#define BCM_TIMER_SEC_MAX (400 * 24 * 60 * 60)\n\n \n#define RX_RECV    0x40  \n#define RX_THR     0x80  \n#define BCM_CAN_FLAGS_MASK 0x3F  \n\n \n#define REGMASK(id) ((id & CAN_EFF_FLAG) ? \\\n\t\t     (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG) : \\\n\t\t     (CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG))\n\nMODULE_DESCRIPTION(\"PF_CAN broadcast manager protocol\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Oliver Hartkopp <oliver.hartkopp@volkswagen.de>\");\nMODULE_ALIAS(\"can-proto-2\");\n\n#define BCM_MIN_NAMELEN CAN_REQUIRED_SIZE(struct sockaddr_can, can_ifindex)\n\n \nstatic inline u64 get_u64(const struct canfd_frame *cp, int offset)\n{\n\treturn *(u64 *)(cp->data + offset);\n}\n\nstruct bcm_op {\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n\tint ifindex;\n\tcanid_t can_id;\n\tu32 flags;\n\tunsigned long frames_abs, frames_filtered;\n\tstruct bcm_timeval ival1, ival2;\n\tstruct hrtimer timer, thrtimer;\n\tktime_t rx_stamp, kt_ival1, kt_ival2, kt_lastmsg;\n\tint rx_ifindex;\n\tint cfsiz;\n\tu32 count;\n\tu32 nframes;\n\tu32 currframe;\n\t \n\tvoid *frames;\n\tvoid *last_frames;\n\tstruct canfd_frame sframe;\n\tstruct canfd_frame last_sframe;\n\tstruct sock *sk;\n\tstruct net_device *rx_reg_dev;\n};\n\nstruct bcm_sock {\n\tstruct sock sk;\n\tint bound;\n\tint ifindex;\n\tstruct list_head notifier;\n\tstruct list_head rx_ops;\n\tstruct list_head tx_ops;\n\tunsigned long dropped_usr_msgs;\n\tstruct proc_dir_entry *bcm_proc_read;\n\tchar procname [32];  \n};\n\nstatic LIST_HEAD(bcm_notifier_list);\nstatic DEFINE_SPINLOCK(bcm_notifier_lock);\nstatic struct bcm_sock *bcm_busy_notifier;\n\nstatic inline struct bcm_sock *bcm_sk(const struct sock *sk)\n{\n\treturn (struct bcm_sock *)sk;\n}\n\nstatic inline ktime_t bcm_timeval_to_ktime(struct bcm_timeval tv)\n{\n\treturn ktime_set(tv.tv_sec, tv.tv_usec * NSEC_PER_USEC);\n}\n\n \nstatic bool bcm_is_invalid_tv(struct bcm_msg_head *msg_head)\n{\n\tif ((msg_head->ival1.tv_sec < 0) ||\n\t    (msg_head->ival1.tv_sec > BCM_TIMER_SEC_MAX) ||\n\t    (msg_head->ival1.tv_usec < 0) ||\n\t    (msg_head->ival1.tv_usec >= USEC_PER_SEC) ||\n\t    (msg_head->ival2.tv_sec < 0) ||\n\t    (msg_head->ival2.tv_sec > BCM_TIMER_SEC_MAX) ||\n\t    (msg_head->ival2.tv_usec < 0) ||\n\t    (msg_head->ival2.tv_usec >= USEC_PER_SEC))\n\t\treturn true;\n\n\treturn false;\n}\n\n#define CFSIZ(flags) ((flags & CAN_FD_FRAME) ? CANFD_MTU : CAN_MTU)\n#define OPSIZ sizeof(struct bcm_op)\n#define MHSIZ sizeof(struct bcm_msg_head)\n\n \n#if IS_ENABLED(CONFIG_PROC_FS)\nstatic char *bcm_proc_getifname(struct net *net, char *result, int ifindex)\n{\n\tstruct net_device *dev;\n\n\tif (!ifindex)\n\t\treturn \"any\";\n\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(net, ifindex);\n\tif (dev)\n\t\tstrcpy(result, dev->name);\n\telse\n\t\tstrcpy(result, \"???\");\n\trcu_read_unlock();\n\n\treturn result;\n}\n\nstatic int bcm_proc_show(struct seq_file *m, void *v)\n{\n\tchar ifname[IFNAMSIZ];\n\tstruct net *net = m->private;\n\tstruct sock *sk = (struct sock *)pde_data(m->file->f_inode);\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct bcm_op *op;\n\n\tseq_printf(m, \">>> socket %pK\", sk->sk_socket);\n\tseq_printf(m, \" / sk %pK\", sk);\n\tseq_printf(m, \" / bo %pK\", bo);\n\tseq_printf(m, \" / dropped %lu\", bo->dropped_usr_msgs);\n\tseq_printf(m, \" / bound %s\", bcm_proc_getifname(net, ifname, bo->ifindex));\n\tseq_printf(m, \" <<<\\n\");\n\n\tlist_for_each_entry(op, &bo->rx_ops, list) {\n\n\t\tunsigned long reduction;\n\n\t\t \n\t\tif (!op->frames_abs)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"rx_op: %03X %-5s \", op->can_id,\n\t\t\t   bcm_proc_getifname(net, ifname, op->ifindex));\n\n\t\tif (op->flags & CAN_FD_FRAME)\n\t\t\tseq_printf(m, \"(%u)\", op->nframes);\n\t\telse\n\t\t\tseq_printf(m, \"[%u]\", op->nframes);\n\n\t\tseq_printf(m, \"%c \", (op->flags & RX_CHECK_DLC) ? 'd' : ' ');\n\n\t\tif (op->kt_ival1)\n\t\t\tseq_printf(m, \"timeo=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival1));\n\n\t\tif (op->kt_ival2)\n\t\t\tseq_printf(m, \"thr=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival2));\n\n\t\tseq_printf(m, \"# recv %ld (%ld) => reduction: \",\n\t\t\t   op->frames_filtered, op->frames_abs);\n\n\t\treduction = 100 - (op->frames_filtered * 100) / op->frames_abs;\n\n\t\tseq_printf(m, \"%s%ld%%\\n\",\n\t\t\t   (reduction == 100) ? \"near \" : \"\", reduction);\n\t}\n\n\tlist_for_each_entry(op, &bo->tx_ops, list) {\n\n\t\tseq_printf(m, \"tx_op: %03X %s \", op->can_id,\n\t\t\t   bcm_proc_getifname(net, ifname, op->ifindex));\n\n\t\tif (op->flags & CAN_FD_FRAME)\n\t\t\tseq_printf(m, \"(%u) \", op->nframes);\n\t\telse\n\t\t\tseq_printf(m, \"[%u] \", op->nframes);\n\n\t\tif (op->kt_ival1)\n\t\t\tseq_printf(m, \"t1=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival1));\n\n\t\tif (op->kt_ival2)\n\t\t\tseq_printf(m, \"t2=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival2));\n\n\t\tseq_printf(m, \"# sent %ld\\n\", op->frames_abs);\n\t}\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n#endif  \n\n \nstatic void bcm_can_tx(struct bcm_op *op)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct canfd_frame *cf = op->frames + op->cfsiz * op->currframe;\n\tint err;\n\n\t \n\tif (!op->ifindex)\n\t\treturn;\n\n\tdev = dev_get_by_index(sock_net(op->sk), op->ifindex);\n\tif (!dev) {\n\t\t \n\t\treturn;\n\t}\n\n\tskb = alloc_skb(op->cfsiz + sizeof(struct can_skb_priv), gfp_any());\n\tif (!skb)\n\t\tgoto out;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\tskb_put_data(skb, cf, op->cfsiz);\n\n\t \n\tskb->dev = dev;\n\tcan_skb_set_owner(skb, op->sk);\n\terr = can_send(skb, 1);\n\tif (!err)\n\t\top->frames_abs++;\n\n\top->currframe++;\n\n\t \n\tif (op->currframe >= op->nframes)\n\t\top->currframe = 0;\nout:\n\tdev_put(dev);\n}\n\n \nstatic void bcm_send_to_user(struct bcm_op *op, struct bcm_msg_head *head,\n\t\t\t     struct canfd_frame *frames, int has_timestamp)\n{\n\tstruct sk_buff *skb;\n\tstruct canfd_frame *firstframe;\n\tstruct sockaddr_can *addr;\n\tstruct sock *sk = op->sk;\n\tunsigned int datalen = head->nframes * op->cfsiz;\n\tint err;\n\n\tskb = alloc_skb(sizeof(*head) + datalen, gfp_any());\n\tif (!skb)\n\t\treturn;\n\n\tskb_put_data(skb, head, sizeof(*head));\n\n\tif (head->nframes) {\n\t\t \n\t\tfirstframe = (struct canfd_frame *)skb_tail_pointer(skb);\n\n\t\tskb_put_data(skb, frames, datalen);\n\n\t\t \n\t\tif (head->nframes == 1)\n\t\t\tfirstframe->flags &= BCM_CAN_FLAGS_MASK;\n\t}\n\n\tif (has_timestamp) {\n\t\t \n\t\tskb->tstamp = op->rx_stamp;\n\t}\n\n\t \n\n\tsock_skb_cb_check_size(sizeof(struct sockaddr_can));\n\taddr = (struct sockaddr_can *)skb->cb;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = op->rx_ifindex;\n\n\terr = sock_queue_rcv_skb(sk, skb);\n\tif (err < 0) {\n\t\tstruct bcm_sock *bo = bcm_sk(sk);\n\n\t\tkfree_skb(skb);\n\t\t \n\t\tbo->dropped_usr_msgs++;\n\t}\n}\n\nstatic bool bcm_tx_set_expiry(struct bcm_op *op, struct hrtimer *hrt)\n{\n\tktime_t ival;\n\n\tif (op->kt_ival1 && op->count)\n\t\tival = op->kt_ival1;\n\telse if (op->kt_ival2)\n\t\tival = op->kt_ival2;\n\telse\n\t\treturn false;\n\n\thrtimer_set_expires(hrt, ktime_add(ktime_get(), ival));\n\treturn true;\n}\n\nstatic void bcm_tx_start_timer(struct bcm_op *op)\n{\n\tif (bcm_tx_set_expiry(op, &op->timer))\n\t\thrtimer_start_expires(&op->timer, HRTIMER_MODE_ABS_SOFT);\n}\n\n \nstatic enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\n\tstruct bcm_msg_head msg_head;\n\n\tif (op->kt_ival1 && (op->count > 0)) {\n\t\top->count--;\n\t\tif (!op->count && (op->flags & TX_COUNTEVT)) {\n\n\t\t\t \n\t\t\tmemset(&msg_head, 0, sizeof(msg_head));\n\t\t\tmsg_head.opcode  = TX_EXPIRED;\n\t\t\tmsg_head.flags   = op->flags;\n\t\t\tmsg_head.count   = op->count;\n\t\t\tmsg_head.ival1   = op->ival1;\n\t\t\tmsg_head.ival2   = op->ival2;\n\t\t\tmsg_head.can_id  = op->can_id;\n\t\t\tmsg_head.nframes = 0;\n\n\t\t\tbcm_send_to_user(op, &msg_head, NULL, 0);\n\t\t}\n\t\tbcm_can_tx(op);\n\n\t} else if (op->kt_ival2) {\n\t\tbcm_can_tx(op);\n\t}\n\n\treturn bcm_tx_set_expiry(op, &op->timer) ?\n\t\tHRTIMER_RESTART : HRTIMER_NORESTART;\n}\n\n \nstatic void bcm_rx_changed(struct bcm_op *op, struct canfd_frame *data)\n{\n\tstruct bcm_msg_head head;\n\n\t \n\top->frames_filtered++;\n\n\t \n\tif (op->frames_filtered > ULONG_MAX/100)\n\t\top->frames_filtered = op->frames_abs = 0;\n\n\t \n\tdata->flags &= (BCM_CAN_FLAGS_MASK|RX_RECV);\n\n\tmemset(&head, 0, sizeof(head));\n\thead.opcode  = RX_CHANGED;\n\thead.flags   = op->flags;\n\thead.count   = op->count;\n\thead.ival1   = op->ival1;\n\thead.ival2   = op->ival2;\n\thead.can_id  = op->can_id;\n\thead.nframes = 1;\n\n\tbcm_send_to_user(op, &head, data, 1);\n}\n\n \nstatic void bcm_rx_update_and_send(struct bcm_op *op,\n\t\t\t\t   struct canfd_frame *lastdata,\n\t\t\t\t   const struct canfd_frame *rxdata)\n{\n\tmemcpy(lastdata, rxdata, op->cfsiz);\n\n\t \n\tlastdata->flags |= (RX_RECV|RX_THR);\n\n\t \n\tif (!op->kt_ival2) {\n\t\t \n\t\tbcm_rx_changed(op, lastdata);\n\t\treturn;\n\t}\n\n\t \n\tif (hrtimer_active(&op->thrtimer))\n\t\treturn;\n\n\t \n\tif (!op->kt_lastmsg)\n\t\tgoto rx_changed_settime;\n\n\t \n\tif (ktime_us_delta(ktime_get(), op->kt_lastmsg) <\n\t    ktime_to_us(op->kt_ival2)) {\n\t\t \n\t\thrtimer_start(&op->thrtimer,\n\t\t\t      ktime_add(op->kt_lastmsg, op->kt_ival2),\n\t\t\t      HRTIMER_MODE_ABS_SOFT);\n\t\treturn;\n\t}\n\n\t \nrx_changed_settime:\n\tbcm_rx_changed(op, lastdata);\n\top->kt_lastmsg = ktime_get();\n}\n\n \nstatic void bcm_rx_cmp_to_index(struct bcm_op *op, unsigned int index,\n\t\t\t\tconst struct canfd_frame *rxdata)\n{\n\tstruct canfd_frame *cf = op->frames + op->cfsiz * index;\n\tstruct canfd_frame *lcf = op->last_frames + op->cfsiz * index;\n\tint i;\n\n\t \n\n\tif (!(lcf->flags & RX_RECV)) {\n\t\t \n\t\tbcm_rx_update_and_send(op, lcf, rxdata);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < rxdata->len; i += 8) {\n\t\tif ((get_u64(cf, i) & get_u64(rxdata, i)) !=\n\t\t    (get_u64(cf, i) & get_u64(lcf, i))) {\n\t\t\tbcm_rx_update_and_send(op, lcf, rxdata);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (op->flags & RX_CHECK_DLC) {\n\t\t \n\t\tif (rxdata->len != lcf->len) {\n\t\t\tbcm_rx_update_and_send(op, lcf, rxdata);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic void bcm_rx_starttimer(struct bcm_op *op)\n{\n\tif (op->flags & RX_NO_AUTOTIMER)\n\t\treturn;\n\n\tif (op->kt_ival1)\n\t\thrtimer_start(&op->timer, op->kt_ival1, HRTIMER_MODE_REL_SOFT);\n}\n\n \nstatic enum hrtimer_restart bcm_rx_timeout_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\n\tstruct bcm_msg_head msg_head;\n\n\t \n\tif ((op->flags & RX_ANNOUNCE_RESUME) && op->last_frames) {\n\t\t \n\t\tmemset(op->last_frames, 0, op->nframes * op->cfsiz);\n\t}\n\n\t \n\tmemset(&msg_head, 0, sizeof(msg_head));\n\tmsg_head.opcode  = RX_TIMEOUT;\n\tmsg_head.flags   = op->flags;\n\tmsg_head.count   = op->count;\n\tmsg_head.ival1   = op->ival1;\n\tmsg_head.ival2   = op->ival2;\n\tmsg_head.can_id  = op->can_id;\n\tmsg_head.nframes = 0;\n\n\tbcm_send_to_user(op, &msg_head, NULL, 0);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic inline int bcm_rx_do_flush(struct bcm_op *op, unsigned int index)\n{\n\tstruct canfd_frame *lcf = op->last_frames + op->cfsiz * index;\n\n\tif ((op->last_frames) && (lcf->flags & RX_THR)) {\n\t\tbcm_rx_changed(op, lcf);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int bcm_rx_thr_flush(struct bcm_op *op)\n{\n\tint updated = 0;\n\n\tif (op->nframes > 1) {\n\t\tunsigned int i;\n\n\t\t \n\t\tfor (i = 1; i < op->nframes; i++)\n\t\t\tupdated += bcm_rx_do_flush(op, i);\n\n\t} else {\n\t\t \n\t\tupdated += bcm_rx_do_flush(op, 0);\n\t}\n\n\treturn updated;\n}\n\n \nstatic enum hrtimer_restart bcm_rx_thr_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, thrtimer);\n\n\tif (bcm_rx_thr_flush(op)) {\n\t\thrtimer_forward_now(hrtimer, op->kt_ival2);\n\t\treturn HRTIMER_RESTART;\n\t} else {\n\t\t \n\t\top->kt_lastmsg = 0;\n\t\treturn HRTIMER_NORESTART;\n\t}\n}\n\n \nstatic void bcm_rx_handler(struct sk_buff *skb, void *data)\n{\n\tstruct bcm_op *op = (struct bcm_op *)data;\n\tconst struct canfd_frame *rxframe = (struct canfd_frame *)skb->data;\n\tunsigned int i;\n\n\tif (op->can_id != rxframe->can_id)\n\t\treturn;\n\n\t \n\tif (op->flags & CAN_FD_FRAME) {\n\t\tif (!can_is_canfd_skb(skb))\n\t\t\treturn;\n\t} else {\n\t\tif (!can_is_can_skb(skb))\n\t\t\treturn;\n\t}\n\n\t \n\thrtimer_cancel(&op->timer);\n\n\t \n\top->rx_stamp = skb->tstamp;\n\t \n\top->rx_ifindex = skb->dev->ifindex;\n\t \n\top->frames_abs++;\n\n\tif (op->flags & RX_RTR_FRAME) {\n\t\t \n\t\tbcm_can_tx(op);\n\t\treturn;\n\t}\n\n\tif (op->flags & RX_FILTER_ID) {\n\t\t \n\t\tbcm_rx_update_and_send(op, op->last_frames, rxframe);\n\t\tgoto rx_starttimer;\n\t}\n\n\tif (op->nframes == 1) {\n\t\t \n\t\tbcm_rx_cmp_to_index(op, 0, rxframe);\n\t\tgoto rx_starttimer;\n\t}\n\n\tif (op->nframes > 1) {\n\t\t \n\n\t\tfor (i = 1; i < op->nframes; i++) {\n\t\t\tif ((get_u64(op->frames, 0) & get_u64(rxframe, 0)) ==\n\t\t\t    (get_u64(op->frames, 0) &\n\t\t\t     get_u64(op->frames + op->cfsiz * i, 0))) {\n\t\t\t\tbcm_rx_cmp_to_index(op, i, rxframe);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nrx_starttimer:\n\tbcm_rx_starttimer(op);\n}\n\n \nstatic struct bcm_op *bcm_find_op(struct list_head *ops,\n\t\t\t\t  struct bcm_msg_head *mh, int ifindex)\n{\n\tstruct bcm_op *op;\n\n\tlist_for_each_entry(op, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME))\n\t\t\treturn op;\n\t}\n\n\treturn NULL;\n}\n\nstatic void bcm_free_op_rcu(struct rcu_head *rcu_head)\n{\n\tstruct bcm_op *op = container_of(rcu_head, struct bcm_op, rcu);\n\n\tif ((op->frames) && (op->frames != &op->sframe))\n\t\tkfree(op->frames);\n\n\tif ((op->last_frames) && (op->last_frames != &op->last_sframe))\n\t\tkfree(op->last_frames);\n\n\tkfree(op);\n}\n\nstatic void bcm_remove_op(struct bcm_op *op)\n{\n\thrtimer_cancel(&op->timer);\n\thrtimer_cancel(&op->thrtimer);\n\n\tcall_rcu(&op->rcu, bcm_free_op_rcu);\n}\n\nstatic void bcm_rx_unreg(struct net_device *dev, struct bcm_op *op)\n{\n\tif (op->rx_reg_dev == dev) {\n\t\tcan_rx_unregister(dev_net(dev), dev, op->can_id,\n\t\t\t\t  REGMASK(op->can_id), bcm_rx_handler, op);\n\n\t\t \n\t\top->rx_reg_dev = NULL;\n\t} else\n\t\tprintk(KERN_ERR \"can-bcm: bcm_rx_unreg: registered device \"\n\t\t       \"mismatch %p %p\\n\", op->rx_reg_dev, dev);\n}\n\n \nstatic int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\n\t\t\t \n\t\t\top->flags |= RX_NO_AUTOTIMER;\n\n\t\t\t \n\t\t\tif (op->ifindex) {\n\t\t\t\t \n\t\t\t\tif (op->rx_reg_dev) {\n\t\t\t\t\tstruct net_device *dev;\n\n\t\t\t\t\tdev = dev_get_by_index(sock_net(op->sk),\n\t\t\t\t\t\t\t       op->ifindex);\n\t\t\t\t\tif (dev) {\n\t\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\t\tdev_put(dev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan_rx_unregister(sock_net(op->sk), NULL,\n\t\t\t\t\t\t  op->can_id,\n\t\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t\t  bcm_rx_handler, op);\n\n\t\t\tlist_del(&op->list);\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1;  \n\t\t}\n\t}\n\n\treturn 0;  \n}\n\n \nstatic int bcm_delete_tx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\t\t\tlist_del(&op->list);\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1;  \n\t\t}\n\t}\n\n\treturn 0;  \n}\n\n \nstatic int bcm_read_op(struct list_head *ops, struct bcm_msg_head *msg_head,\n\t\t       int ifindex)\n{\n\tstruct bcm_op *op = bcm_find_op(ops, msg_head, ifindex);\n\n\tif (!op)\n\t\treturn -EINVAL;\n\n\t \n\tmsg_head->flags   = op->flags;\n\tmsg_head->count   = op->count;\n\tmsg_head->ival1   = op->ival1;\n\tmsg_head->ival2   = op->ival2;\n\tmsg_head->nframes = op->nframes;\n\n\tbcm_send_to_user(op, msg_head, op->frames, 0);\n\n\treturn MHSIZ;\n}\n\n \nstatic int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n\t\t\tint ifindex, struct sock *sk)\n{\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct bcm_op *op;\n\tstruct canfd_frame *cf;\n\tunsigned int i;\n\tint err;\n\n\t \n\tif (!ifindex)\n\t\treturn -ENODEV;\n\n\t \n\tif (msg_head->nframes < 1 || msg_head->nframes > MAX_NFRAMES)\n\t\treturn -EINVAL;\n\n\t \n\tif ((msg_head->flags & SETTIMER) && bcm_is_invalid_tv(msg_head))\n\t\treturn -EINVAL;\n\n\t \n\top = bcm_find_op(&bo->tx_ops, msg_head, ifindex);\n\tif (op) {\n\t\t \n\n\t\t \n\t\tif (msg_head->nframes > op->nframes)\n\t\t\treturn -E2BIG;\n\n\t\t \n\t\tfor (i = 0; i < msg_head->nframes; i++) {\n\n\t\t\tcf = op->frames + op->cfsiz * i;\n\t\t\terr = memcpy_from_msg((u8 *)cf, msg, op->cfsiz);\n\n\t\t\tif (op->flags & CAN_FD_FRAME) {\n\t\t\t\tif (cf->len > 64)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t} else {\n\t\t\t\tif (cf->len > 8)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t}\n\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tif (msg_head->flags & TX_CP_CAN_ID) {\n\t\t\t\t \n\t\t\t\tcf->can_id = msg_head->can_id;\n\t\t\t}\n\t\t}\n\t\top->flags = msg_head->flags;\n\n\t} else {\n\t\t \n\n\t\top = kzalloc(OPSIZ, GFP_KERNEL);\n\t\tif (!op)\n\t\t\treturn -ENOMEM;\n\n\t\top->can_id = msg_head->can_id;\n\t\top->cfsiz = CFSIZ(msg_head->flags);\n\t\top->flags = msg_head->flags;\n\n\t\t \n\t\tif (msg_head->nframes > 1) {\n\t\t\top->frames = kmalloc_array(msg_head->nframes,\n\t\t\t\t\t\t   op->cfsiz,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!op->frames) {\n\t\t\t\tkfree(op);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\top->frames = &op->sframe;\n\n\t\tfor (i = 0; i < msg_head->nframes; i++) {\n\n\t\t\tcf = op->frames + op->cfsiz * i;\n\t\t\terr = memcpy_from_msg((u8 *)cf, msg, op->cfsiz);\n\t\t\tif (err < 0)\n\t\t\t\tgoto free_op;\n\n\t\t\tif (op->flags & CAN_FD_FRAME) {\n\t\t\t\tif (cf->len > 64)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t} else {\n\t\t\t\tif (cf->len > 8)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t}\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto free_op;\n\n\t\t\tif (msg_head->flags & TX_CP_CAN_ID) {\n\t\t\t\t \n\t\t\t\tcf->can_id = msg_head->can_id;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\top->last_frames = NULL;\n\n\t\t \n\t\top->sk = sk;\n\t\top->ifindex = ifindex;\n\n\t\t \n\t\thrtimer_init(&op->timer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\t\top->timer.function = bcm_tx_timeout_handler;\n\n\t\t \n\t\thrtimer_init(&op->thrtimer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\n\t\t \n\t\tlist_add(&op->list, &bo->tx_ops);\n\n\t}  \n\n\tif (op->nframes != msg_head->nframes) {\n\t\top->nframes   = msg_head->nframes;\n\t\t \n\t\top->currframe = 0;\n\t}\n\n\t \n\n\tif (op->flags & TX_RESET_MULTI_IDX) {\n\t\t \n\t\top->currframe = 0;\n\t}\n\n\tif (op->flags & SETTIMER) {\n\t\t \n\t\top->count = msg_head->count;\n\t\top->ival1 = msg_head->ival1;\n\t\top->ival2 = msg_head->ival2;\n\t\top->kt_ival1 = bcm_timeval_to_ktime(msg_head->ival1);\n\t\top->kt_ival2 = bcm_timeval_to_ktime(msg_head->ival2);\n\n\t\t \n\t\tif (!op->kt_ival1 && !op->kt_ival2)\n\t\t\thrtimer_cancel(&op->timer);\n\t}\n\n\tif (op->flags & STARTTIMER) {\n\t\thrtimer_cancel(&op->timer);\n\t\t \n\t\top->flags |= TX_ANNOUNCE;\n\t}\n\n\tif (op->flags & TX_ANNOUNCE) {\n\t\tbcm_can_tx(op);\n\t\tif (op->count)\n\t\t\top->count--;\n\t}\n\n\tif (op->flags & STARTTIMER)\n\t\tbcm_tx_start_timer(op);\n\n\treturn msg_head->nframes * op->cfsiz + MHSIZ;\n\nfree_op:\n\tif (op->frames != &op->sframe)\n\t\tkfree(op->frames);\n\tkfree(op);\n\treturn err;\n}\n\n \nstatic int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n\t\t\tint ifindex, struct sock *sk)\n{\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct bcm_op *op;\n\tint do_rx_register;\n\tint err = 0;\n\n\tif ((msg_head->flags & RX_FILTER_ID) || (!(msg_head->nframes))) {\n\t\t \n\t\tmsg_head->flags |= RX_FILTER_ID;\n\t\t \n\t\tmsg_head->nframes = 0;\n\t}\n\n\t \n\tif (msg_head->nframes > MAX_NFRAMES + 1)\n\t\treturn -EINVAL;\n\n\tif ((msg_head->flags & RX_RTR_FRAME) &&\n\t    ((msg_head->nframes != 1) ||\n\t     (!(msg_head->can_id & CAN_RTR_FLAG))))\n\t\treturn -EINVAL;\n\n\t \n\tif ((msg_head->flags & SETTIMER) && bcm_is_invalid_tv(msg_head))\n\t\treturn -EINVAL;\n\n\t \n\top = bcm_find_op(&bo->rx_ops, msg_head, ifindex);\n\tif (op) {\n\t\t \n\n\t\t \n\t\tif (msg_head->nframes > op->nframes)\n\t\t\treturn -E2BIG;\n\n\t\tif (msg_head->nframes) {\n\t\t\t \n\t\t\terr = memcpy_from_msg(op->frames, msg,\n\t\t\t\t\t      msg_head->nframes * op->cfsiz);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\tmemset(op->last_frames, 0, msg_head->nframes * op->cfsiz);\n\t\t}\n\n\t\top->nframes = msg_head->nframes;\n\t\top->flags = msg_head->flags;\n\n\t\t \n\t\tdo_rx_register = 0;\n\n\t} else {\n\t\t \n\t\top = kzalloc(OPSIZ, GFP_KERNEL);\n\t\tif (!op)\n\t\t\treturn -ENOMEM;\n\n\t\top->can_id = msg_head->can_id;\n\t\top->nframes = msg_head->nframes;\n\t\top->cfsiz = CFSIZ(msg_head->flags);\n\t\top->flags = msg_head->flags;\n\n\t\tif (msg_head->nframes > 1) {\n\t\t\t \n\t\t\top->frames = kmalloc_array(msg_head->nframes,\n\t\t\t\t\t\t   op->cfsiz,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!op->frames) {\n\t\t\t\tkfree(op);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t \n\t\t\top->last_frames = kcalloc(msg_head->nframes,\n\t\t\t\t\t\t  op->cfsiz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!op->last_frames) {\n\t\t\t\tkfree(op->frames);\n\t\t\t\tkfree(op);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t} else {\n\t\t\top->frames = &op->sframe;\n\t\t\top->last_frames = &op->last_sframe;\n\t\t}\n\n\t\tif (msg_head->nframes) {\n\t\t\terr = memcpy_from_msg(op->frames, msg,\n\t\t\t\t\t      msg_head->nframes * op->cfsiz);\n\t\t\tif (err < 0) {\n\t\t\t\tif (op->frames != &op->sframe)\n\t\t\t\t\tkfree(op->frames);\n\t\t\t\tif (op->last_frames != &op->last_sframe)\n\t\t\t\t\tkfree(op->last_frames);\n\t\t\t\tkfree(op);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\top->sk = sk;\n\t\top->ifindex = ifindex;\n\n\t\t \n\t\top->rx_ifindex = ifindex;\n\n\t\t \n\t\thrtimer_init(&op->timer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\t\top->timer.function = bcm_rx_timeout_handler;\n\n\t\thrtimer_init(&op->thrtimer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\t\top->thrtimer.function = bcm_rx_thr_handler;\n\n\t\t \n\t\tlist_add(&op->list, &bo->rx_ops);\n\n\t\t \n\t\tdo_rx_register = 1;\n\n\t}  \n\n\t \n\n\tif (op->flags & RX_RTR_FRAME) {\n\t\tstruct canfd_frame *frame0 = op->frames;\n\n\t\t \n\t\thrtimer_cancel(&op->thrtimer);\n\t\thrtimer_cancel(&op->timer);\n\n\t\t \n\t\tif ((op->flags & TX_CP_CAN_ID) ||\n\t\t    (frame0->can_id == op->can_id))\n\t\t\tframe0->can_id = op->can_id & ~CAN_RTR_FLAG;\n\n\t} else {\n\t\tif (op->flags & SETTIMER) {\n\n\t\t\t \n\t\t\top->ival1 = msg_head->ival1;\n\t\t\top->ival2 = msg_head->ival2;\n\t\t\top->kt_ival1 = bcm_timeval_to_ktime(msg_head->ival1);\n\t\t\top->kt_ival2 = bcm_timeval_to_ktime(msg_head->ival2);\n\n\t\t\t \n\t\t\tif (!op->kt_ival1)\n\t\t\t\thrtimer_cancel(&op->timer);\n\n\t\t\t \n\t\t\top->kt_lastmsg = 0;\n\t\t\thrtimer_cancel(&op->thrtimer);\n\t\t\tbcm_rx_thr_flush(op);\n\t\t}\n\n\t\tif ((op->flags & STARTTIMER) && op->kt_ival1)\n\t\t\thrtimer_start(&op->timer, op->kt_ival1,\n\t\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t}\n\n\t \n\tif (do_rx_register) {\n\t\tif (ifindex) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\t\t\tif (dev) {\n\t\t\t\terr = can_rx_register(sock_net(sk), dev,\n\t\t\t\t\t\t      op->can_id,\n\t\t\t\t\t\t      REGMASK(op->can_id),\n\t\t\t\t\t\t      bcm_rx_handler, op,\n\t\t\t\t\t\t      \"bcm\", sk);\n\n\t\t\t\top->rx_reg_dev = dev;\n\t\t\t\tdev_put(dev);\n\t\t\t}\n\n\t\t} else\n\t\t\terr = can_rx_register(sock_net(sk), NULL, op->can_id,\n\t\t\t\t\t      REGMASK(op->can_id),\n\t\t\t\t\t      bcm_rx_handler, op, \"bcm\", sk);\n\t\tif (err) {\n\t\t\t \n\t\t\tlist_del(&op->list);\n\t\t\tbcm_remove_op(op);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn msg_head->nframes * op->cfsiz + MHSIZ;\n}\n\n \nstatic int bcm_tx_send(struct msghdr *msg, int ifindex, struct sock *sk,\n\t\t       int cfsiz)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tint err;\n\n\t \n\tif (!ifindex)\n\t\treturn -ENODEV;\n\n\tskb = alloc_skb(cfsiz + sizeof(struct can_skb_priv), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcan_skb_reserve(skb);\n\n\terr = memcpy_from_msg(skb_put(skb, cfsiz), msg, cfsiz);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\tif (!dev) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\tskb->dev = dev;\n\tcan_skb_set_owner(skb, sk);\n\terr = can_send(skb, 1);  \n\tdev_put(dev);\n\n\tif (err)\n\t\treturn err;\n\n\treturn cfsiz + MHSIZ;\n}\n\n \nstatic int bcm_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tint ifindex = bo->ifindex;  \n\tstruct bcm_msg_head msg_head;\n\tint cfsiz;\n\tint ret;  \n\n\tif (!bo->bound)\n\t\treturn -ENOTCONN;\n\n\t \n\tif (size < MHSIZ)\n\t\treturn -EINVAL;\n\n\t \n\tret = memcpy_from_msg((u8 *)&msg_head, msg, MHSIZ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcfsiz = CFSIZ(msg_head.flags);\n\tif ((size - MHSIZ) % cfsiz)\n\t\treturn -EINVAL;\n\n\t \n\n\tif (!ifindex && msg->msg_name) {\n\t\t \n\t\tDECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);\n\n\t\tif (msg->msg_namelen < BCM_MIN_NAMELEN)\n\t\t\treturn -EINVAL;\n\n\t\tif (addr->can_family != AF_CAN)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tifindex = addr->can_ifindex;\n\n\t\tif (ifindex) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\t\t\tif (!dev)\n\t\t\t\treturn -ENODEV;\n\n\t\t\tif (dev->type != ARPHRD_CAN) {\n\t\t\t\tdev_put(dev);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\tdev_put(dev);\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\n\tswitch (msg_head.opcode) {\n\n\tcase TX_SETUP:\n\t\tret = bcm_tx_setup(&msg_head, msg, ifindex, sk);\n\t\tbreak;\n\n\tcase RX_SETUP:\n\t\tret = bcm_rx_setup(&msg_head, msg, ifindex, sk);\n\t\tbreak;\n\n\tcase TX_DELETE:\n\t\tif (bcm_delete_tx_op(&bo->tx_ops, &msg_head, ifindex))\n\t\t\tret = MHSIZ;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase RX_DELETE:\n\t\tif (bcm_delete_rx_op(&bo->rx_ops, &msg_head, ifindex))\n\t\t\tret = MHSIZ;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase TX_READ:\n\t\t \n\t\tmsg_head.opcode  = TX_STATUS;\n\t\tret = bcm_read_op(&bo->tx_ops, &msg_head, ifindex);\n\t\tbreak;\n\n\tcase RX_READ:\n\t\t \n\t\tmsg_head.opcode  = RX_STATUS;\n\t\tret = bcm_read_op(&bo->rx_ops, &msg_head, ifindex);\n\t\tbreak;\n\n\tcase TX_SEND:\n\t\t \n\t\tif ((msg_head.nframes != 1) || (size != cfsiz + MHSIZ))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = bcm_tx_send(msg, ifindex, sk, cfsiz);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\n \nstatic void bcm_notify(struct bcm_sock *bo, unsigned long msg,\n\t\t       struct net_device *dev)\n{\n\tstruct sock *sk = &bo->sk;\n\tstruct bcm_op *op;\n\tint notify_enodev = 0;\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\treturn;\n\n\tswitch (msg) {\n\n\tcase NETDEV_UNREGISTER:\n\t\tlock_sock(sk);\n\n\t\t \n\t\tlist_for_each_entry(op, &bo->rx_ops, list)\n\t\t\tif (op->rx_reg_dev == dev)\n\t\t\t\tbcm_rx_unreg(dev, op);\n\n\t\t \n\t\tif (bo->bound && bo->ifindex == dev->ifindex) {\n\t\t\tbo->bound   = 0;\n\t\t\tbo->ifindex = 0;\n\t\t\tnotify_enodev = 1;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\tif (notify_enodev) {\n\t\t\tsk->sk_err = ENODEV;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\tsk_error_report(sk);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tif (bo->bound && bo->ifindex == dev->ifindex) {\n\t\t\tsk->sk_err = ENETDOWN;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\tsk_error_report(sk);\n\t\t}\n\t}\n}\n\nstatic int bcm_notifier(struct notifier_block *nb, unsigned long msg,\n\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (dev->type != ARPHRD_CAN)\n\t\treturn NOTIFY_DONE;\n\tif (msg != NETDEV_UNREGISTER && msg != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\tif (unlikely(bcm_busy_notifier))  \n\t\treturn NOTIFY_DONE;\n\n\tspin_lock(&bcm_notifier_lock);\n\tlist_for_each_entry(bcm_busy_notifier, &bcm_notifier_list, notifier) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tbcm_notify(bcm_busy_notifier, msg, dev);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tbcm_busy_notifier = NULL;\n\tspin_unlock(&bcm_notifier_lock);\n\treturn NOTIFY_DONE;\n}\n\n \nstatic int bcm_init(struct sock *sk)\n{\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\n\tbo->bound            = 0;\n\tbo->ifindex          = 0;\n\tbo->dropped_usr_msgs = 0;\n\tbo->bcm_proc_read    = NULL;\n\n\tINIT_LIST_HEAD(&bo->tx_ops);\n\tINIT_LIST_HEAD(&bo->rx_ops);\n\n\t \n\tspin_lock(&bcm_notifier_lock);\n\tlist_add_tail(&bo->notifier, &bcm_notifier_list);\n\tspin_unlock(&bcm_notifier_lock);\n\n\treturn 0;\n}\n\n \nstatic int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\n\t \n\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\n\tlock_sock(sk);\n\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t \n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif  \n\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\t \n\t\tif (op->ifindex) {\n\t\t\t \n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list)\n\t\tbcm_remove_op(op);\n\n\t \n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,\n\t\t       int flags)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint ret = 0;\n\n\tif (len < BCM_MIN_NAMELEN)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (bo->bound) {\n\t\tret = -EISCONN;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (addr->can_ifindex) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index(net, addr->can_ifindex);\n\t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (dev->type != ARPHRD_CAN) {\n\t\t\tdev_put(dev);\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tbo->ifindex = dev->ifindex;\n\t\tdev_put(dev);\n\n\t} else {\n\t\t \n\t\tbo->ifindex = 0;\n\t}\n\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir) {\n\t\t \n\t\tsprintf(bo->procname, \"%lu\", sock_i_ino(sk));\n\t\tbo->bcm_proc_read = proc_create_net_single(bo->procname, 0644,\n\t\t\t\t\t\t     net->can.bcmproc_dir,\n\t\t\t\t\t\t     bcm_proc_show, sk);\n\t\tif (!bo->bcm_proc_read) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n#endif  \n\n\tbo->bound = 1;\n\nfail:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int bcm_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\tint err;\n\n\tskb = skb_recv_datagram(sk, flags, &error);\n\tif (!skb)\n\t\treturn error;\n\n\tif (skb->len < size)\n\t\tsize = skb->len;\n\n\terr = memcpy_to_msg(msg, skb->data, size);\n\tif (err < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\treturn err;\n\t}\n\n\tsock_recv_cmsgs(msg, sk, skb);\n\n\tif (msg->msg_name) {\n\t\t__sockaddr_check_size(BCM_MIN_NAMELEN);\n\t\tmsg->msg_namelen = BCM_MIN_NAMELEN;\n\t\tmemcpy(msg->msg_name, skb->cb, msg->msg_namelen);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn size;\n}\n\nstatic int bcm_sock_no_ioctlcmd(struct socket *sock, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\t \n\treturn -ENOIOCTLCMD;\n}\n\nstatic const struct proto_ops bcm_ops = {\n\t.family        = PF_CAN,\n\t.release       = bcm_release,\n\t.bind          = sock_no_bind,\n\t.connect       = bcm_connect,\n\t.socketpair    = sock_no_socketpair,\n\t.accept        = sock_no_accept,\n\t.getname       = sock_no_getname,\n\t.poll          = datagram_poll,\n\t.ioctl         = bcm_sock_no_ioctlcmd,\n\t.gettstamp     = sock_gettstamp,\n\t.listen        = sock_no_listen,\n\t.shutdown      = sock_no_shutdown,\n\t.sendmsg       = bcm_sendmsg,\n\t.recvmsg       = bcm_recvmsg,\n\t.mmap          = sock_no_mmap,\n};\n\nstatic struct proto bcm_proto __read_mostly = {\n\t.name       = \"CAN_BCM\",\n\t.owner      = THIS_MODULE,\n\t.obj_size   = sizeof(struct bcm_sock),\n\t.init       = bcm_init,\n};\n\nstatic const struct can_proto bcm_can_proto = {\n\t.type       = SOCK_DGRAM,\n\t.protocol   = CAN_BCM,\n\t.ops        = &bcm_ops,\n\t.prot       = &bcm_proto,\n};\n\nstatic int canbcm_pernet_init(struct net *net)\n{\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t \n\tnet->can.bcmproc_dir = proc_net_mkdir(net, \"can-bcm\", net->proc_net);\n#endif  \n\n\treturn 0;\n}\n\nstatic void canbcm_pernet_exit(struct net *net)\n{\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t \n\tif (net->can.bcmproc_dir)\n\t\tremove_proc_entry(\"can-bcm\", net->proc_net);\n#endif  \n}\n\nstatic struct pernet_operations canbcm_pernet_ops __read_mostly = {\n\t.init = canbcm_pernet_init,\n\t.exit = canbcm_pernet_exit,\n};\n\nstatic struct notifier_block canbcm_notifier = {\n\t.notifier_call = bcm_notifier\n};\n\nstatic int __init bcm_module_init(void)\n{\n\tint err;\n\n\tpr_info(\"can: broadcast manager protocol\\n\");\n\n\terr = register_pernet_subsys(&canbcm_pernet_ops);\n\tif (err)\n\t\treturn err;\n\n\terr = register_netdevice_notifier(&canbcm_notifier);\n\tif (err)\n\t\tgoto register_notifier_failed;\n\n\terr = can_proto_register(&bcm_can_proto);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"can: registration of bcm protocol failed\\n\");\n\t\tgoto register_proto_failed;\n\t}\n\n\treturn 0;\n\nregister_proto_failed:\n\tunregister_netdevice_notifier(&canbcm_notifier);\nregister_notifier_failed:\n\tunregister_pernet_subsys(&canbcm_pernet_ops);\n\treturn err;\n}\n\nstatic void __exit bcm_module_exit(void)\n{\n\tcan_proto_unregister(&bcm_can_proto);\n\tunregister_netdevice_notifier(&canbcm_notifier);\n\tunregister_pernet_subsys(&canbcm_pernet_ops);\n}\n\nmodule_init(bcm_module_init);\nmodule_exit(bcm_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}