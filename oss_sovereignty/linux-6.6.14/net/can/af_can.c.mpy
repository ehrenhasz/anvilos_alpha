{
  "module_name": "af_can.c",
  "hash_id": "c89e91ff44b7f60206c8af9ca01529faff56893101c69767a26132bbb49446d6",
  "original_prompt": "Ingested from linux-6.6.14/net/can/af_can.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/stddef.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/uaccess.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/socket.h>\n#include <linux/if_ether.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/can.h>\n#include <linux/can/core.h>\n#include <linux/can/skb.h>\n#include <linux/can/can-ml.h>\n#include <linux/ratelimit.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n\n#include \"af_can.h\"\n\nMODULE_DESCRIPTION(\"Controller Area Network PF_CAN core\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Urs Thuermann <urs.thuermann@volkswagen.de>, \"\n\t      \"Oliver Hartkopp <oliver.hartkopp@volkswagen.de>\");\n\nMODULE_ALIAS_NETPROTO(PF_CAN);\n\nstatic int stats_timer __read_mostly = 1;\nmodule_param(stats_timer, int, 0444);\nMODULE_PARM_DESC(stats_timer, \"enable timer for statistics (default:on)\");\n\nstatic struct kmem_cache *rcv_cache __read_mostly;\n\n \nstatic const struct can_proto __rcu *proto_tab[CAN_NPROTO] __read_mostly;\nstatic DEFINE_MUTEX(proto_tab_lock);\n\nstatic atomic_t skbcounter = ATOMIC_INIT(0);\n\n \n\nvoid can_sock_destruct(struct sock *sk)\n{\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_error_queue);\n}\nEXPORT_SYMBOL(can_sock_destruct);\n\nstatic const struct can_proto *can_get_proto(int protocol)\n{\n\tconst struct can_proto *cp;\n\n\trcu_read_lock();\n\tcp = rcu_dereference(proto_tab[protocol]);\n\tif (cp && !try_module_get(cp->prot->owner))\n\t\tcp = NULL;\n\trcu_read_unlock();\n\n\treturn cp;\n}\n\nstatic inline void can_put_proto(const struct can_proto *cp)\n{\n\tmodule_put(cp->prot->owner);\n}\n\nstatic int can_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tstruct sock *sk;\n\tconst struct can_proto *cp;\n\tint err = 0;\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (protocol < 0 || protocol >= CAN_NPROTO)\n\t\treturn -EINVAL;\n\n\tcp = can_get_proto(protocol);\n\n#ifdef CONFIG_MODULES\n\tif (!cp) {\n\t\t \n\n\t\terr = request_module(\"can-proto-%d\", protocol);\n\n\t\t \n\t\tif (err)\n\t\t\tpr_err_ratelimited(\"can: request_module (can-proto-%d) failed.\\n\",\n\t\t\t\t\t   protocol);\n\n\t\tcp = can_get_proto(protocol);\n\t}\n#endif\n\n\t \n\n\tif (!cp)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (cp->type != sock->type) {\n\t\terr = -EPROTOTYPE;\n\t\tgoto errout;\n\t}\n\n\tsock->ops = cp->ops;\n\n\tsk = sk_alloc(net, PF_CAN, GFP_KERNEL, cp->prot, kern);\n\tif (!sk) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = can_sock_destruct;\n\n\tif (sk->sk_prot->init)\n\t\terr = sk->sk_prot->init(sk);\n\n\tif (err) {\n\t\t \n\t\tsock_orphan(sk);\n\t\tsock_put(sk);\n\t}\n\n errout:\n\tcan_put_proto(cp);\n\treturn err;\n}\n\n \n\n \nint can_send(struct sk_buff *skb, int loop)\n{\n\tstruct sk_buff *newskb = NULL;\n\tstruct can_pkg_stats *pkg_stats = dev_net(skb->dev)->can.pkg_stats;\n\tint err = -EINVAL;\n\n\tif (can_is_canxl_skb(skb)) {\n\t\tskb->protocol = htons(ETH_P_CANXL);\n\t} else if (can_is_can_skb(skb)) {\n\t\tskb->protocol = htons(ETH_P_CAN);\n\t} else if (can_is_canfd_skb(skb)) {\n\t\tstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\n\n\t\tskb->protocol = htons(ETH_P_CANFD);\n\n\t\t \n\t\tcfd->flags |= CANFD_FDF;\n\t} else {\n\t\tgoto inval_skb;\n\t}\n\n\t \n\tif (unlikely(skb->len > skb->dev->mtu)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto inval_skb;\n\t}\n\n\tif (unlikely(skb->dev->type != ARPHRD_CAN)) {\n\t\terr = -EPERM;\n\t\tgoto inval_skb;\n\t}\n\n\tif (unlikely(!(skb->dev->flags & IFF_UP))) {\n\t\terr = -ENETDOWN;\n\t\tgoto inval_skb;\n\t}\n\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\n\tif (loop) {\n\t\t \n\n\t\t \n\t\tskb->pkt_type = PACKET_LOOPBACK;\n\n\t\t \n\n\t\tif (!(skb->dev->flags & IFF_ECHO)) {\n\t\t\t \n\t\t\tnewskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (!newskb) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tcan_skb_set_owner(newskb, skb->sk);\n\t\t\tnewskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tnewskb->pkt_type = PACKET_BROADCAST;\n\t\t}\n\t} else {\n\t\t \n\t\tskb->pkt_type = PACKET_HOST;\n\t}\n\n\t \n\terr = dev_queue_xmit(skb);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\n\tif (err) {\n\t\tkfree_skb(newskb);\n\t\treturn err;\n\t}\n\n\tif (newskb)\n\t\tnetif_rx(newskb);\n\n\t \n\tpkg_stats->tx_frames++;\n\tpkg_stats->tx_frames_delta++;\n\n\treturn 0;\n\ninval_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\nEXPORT_SYMBOL(can_send);\n\n \n\nstatic struct can_dev_rcv_lists *can_dev_rcv_lists_find(struct net *net,\n\t\t\t\t\t\t\tstruct net_device *dev)\n{\n\tif (dev) {\n\t\tstruct can_ml_priv *can_ml = can_get_ml_priv(dev);\n\t\treturn &can_ml->dev_rcv_lists;\n\t} else {\n\t\treturn net->can.rx_alldev_list;\n\t}\n}\n\n \nstatic unsigned int effhash(canid_t can_id)\n{\n\tunsigned int hash;\n\n\thash = can_id;\n\thash ^= can_id >> CAN_EFF_RCV_HASH_BITS;\n\thash ^= can_id >> (2 * CAN_EFF_RCV_HASH_BITS);\n\n\treturn hash & ((1 << CAN_EFF_RCV_HASH_BITS) - 1);\n}\n\n \nstatic struct hlist_head *can_rcv_list_find(canid_t *can_id, canid_t *mask,\n\t\t\t\t\t    struct can_dev_rcv_lists *dev_rcv_lists)\n{\n\tcanid_t inv = *can_id & CAN_INV_FILTER;  \n\n\t \n\tif (*mask & CAN_ERR_FLAG) {\n\t\t \n\t\t*mask &= CAN_ERR_MASK;\n\t\treturn &dev_rcv_lists->rx[RX_ERR];\n\t}\n\n\t \n\n#define CAN_EFF_RTR_FLAGS (CAN_EFF_FLAG | CAN_RTR_FLAG)\n\n\t \n\tif ((*mask & CAN_EFF_FLAG) && !(*can_id & CAN_EFF_FLAG))\n\t\t*mask &= (CAN_SFF_MASK | CAN_EFF_RTR_FLAGS);\n\n\t \n\t*can_id &= *mask;\n\n\t \n\tif (inv)\n\t\treturn &dev_rcv_lists->rx[RX_INV];\n\n\t \n\tif (!(*mask))\n\t\treturn &dev_rcv_lists->rx[RX_ALL];\n\n\t \n\tif (((*mask & CAN_EFF_RTR_FLAGS) == CAN_EFF_RTR_FLAGS) &&\n\t    !(*can_id & CAN_RTR_FLAG)) {\n\t\tif (*can_id & CAN_EFF_FLAG) {\n\t\t\tif (*mask == (CAN_EFF_MASK | CAN_EFF_RTR_FLAGS))\n\t\t\t\treturn &dev_rcv_lists->rx_eff[effhash(*can_id)];\n\t\t} else {\n\t\t\tif (*mask == (CAN_SFF_MASK | CAN_EFF_RTR_FLAGS))\n\t\t\t\treturn &dev_rcv_lists->rx_sff[*can_id];\n\t\t}\n\t}\n\n\t \n\treturn &dev_rcv_lists->rx[RX_FIL];\n}\n\n \nint can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,\n\t\t    canid_t mask, void (*func)(struct sk_buff *, void *),\n\t\t    void *data, char *ident, struct sock *sk)\n{\n\tstruct receiver *rcv;\n\tstruct hlist_head *rcv_list;\n\tstruct can_dev_rcv_lists *dev_rcv_lists;\n\tstruct can_rcv_lists_stats *rcv_lists_stats = net->can.rcv_lists_stats;\n\n\t \n\n\tif (dev && (dev->type != ARPHRD_CAN || !can_get_ml_priv(dev)))\n\t\treturn -ENODEV;\n\n\tif (dev && !net_eq(net, dev_net(dev)))\n\t\treturn -ENODEV;\n\n\trcv = kmem_cache_alloc(rcv_cache, GFP_KERNEL);\n\tif (!rcv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&net->can.rcvlists_lock);\n\n\tdev_rcv_lists = can_dev_rcv_lists_find(net, dev);\n\trcv_list = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);\n\n\trcv->can_id = can_id;\n\trcv->mask = mask;\n\trcv->matches = 0;\n\trcv->func = func;\n\trcv->data = data;\n\trcv->ident = ident;\n\trcv->sk = sk;\n\n\thlist_add_head_rcu(&rcv->list, rcv_list);\n\tdev_rcv_lists->entries++;\n\n\trcv_lists_stats->rcv_entries++;\n\trcv_lists_stats->rcv_entries_max = max(rcv_lists_stats->rcv_entries_max,\n\t\t\t\t\t       rcv_lists_stats->rcv_entries);\n\tspin_unlock_bh(&net->can.rcvlists_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(can_rx_register);\n\n \nstatic void can_rx_delete_receiver(struct rcu_head *rp)\n{\n\tstruct receiver *rcv = container_of(rp, struct receiver, rcu);\n\tstruct sock *sk = rcv->sk;\n\n\tkmem_cache_free(rcv_cache, rcv);\n\tif (sk)\n\t\tsock_put(sk);\n}\n\n \nvoid can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,\n\t\t       canid_t mask, void (*func)(struct sk_buff *, void *),\n\t\t       void *data)\n{\n\tstruct receiver *rcv = NULL;\n\tstruct hlist_head *rcv_list;\n\tstruct can_rcv_lists_stats *rcv_lists_stats = net->can.rcv_lists_stats;\n\tstruct can_dev_rcv_lists *dev_rcv_lists;\n\n\tif (dev && dev->type != ARPHRD_CAN)\n\t\treturn;\n\n\tif (dev && !net_eq(net, dev_net(dev)))\n\t\treturn;\n\n\tspin_lock_bh(&net->can.rcvlists_lock);\n\n\tdev_rcv_lists = can_dev_rcv_lists_find(net, dev);\n\trcv_list = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);\n\n\t \n\thlist_for_each_entry_rcu(rcv, rcv_list, list) {\n\t\tif (rcv->can_id == can_id && rcv->mask == mask &&\n\t\t    rcv->func == func && rcv->data == data)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!rcv) {\n\t\tpr_warn(\"can: receive list entry not found for dev %s, id %03X, mask %03X\\n\",\n\t\t\tDNAME(dev), can_id, mask);\n\t\tgoto out;\n\t}\n\n\thlist_del_rcu(&rcv->list);\n\tdev_rcv_lists->entries--;\n\n\tif (rcv_lists_stats->rcv_entries > 0)\n\t\trcv_lists_stats->rcv_entries--;\n\n out:\n\tspin_unlock_bh(&net->can.rcvlists_lock);\n\n\t \n\tif (rcv) {\n\t\tif (rcv->sk)\n\t\t\tsock_hold(rcv->sk);\n\t\tcall_rcu(&rcv->rcu, can_rx_delete_receiver);\n\t}\n}\nEXPORT_SYMBOL(can_rx_unregister);\n\nstatic inline void deliver(struct sk_buff *skb, struct receiver *rcv)\n{\n\trcv->func(skb, rcv->data);\n\trcv->matches++;\n}\n\nstatic int can_rcv_filter(struct can_dev_rcv_lists *dev_rcv_lists, struct sk_buff *skb)\n{\n\tstruct receiver *rcv;\n\tint matches = 0;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tcanid_t can_id = cf->can_id;\n\n\tif (dev_rcv_lists->entries == 0)\n\t\treturn 0;\n\n\tif (can_id & CAN_ERR_FLAG) {\n\t\t \n\t\thlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx[RX_ERR], list) {\n\t\t\tif (can_id & rcv->mask) {\n\t\t\t\tdeliver(skb, rcv);\n\t\t\t\tmatches++;\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}\n\n\t \n\thlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx[RX_ALL], list) {\n\t\tdeliver(skb, rcv);\n\t\tmatches++;\n\t}\n\n\t \n\thlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx[RX_FIL], list) {\n\t\tif ((can_id & rcv->mask) == rcv->can_id) {\n\t\t\tdeliver(skb, rcv);\n\t\t\tmatches++;\n\t\t}\n\t}\n\n\t \n\thlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx[RX_INV], list) {\n\t\tif ((can_id & rcv->mask) != rcv->can_id) {\n\t\t\tdeliver(skb, rcv);\n\t\t\tmatches++;\n\t\t}\n\t}\n\n\t \n\tif (can_id & CAN_RTR_FLAG)\n\t\treturn matches;\n\n\tif (can_id & CAN_EFF_FLAG) {\n\t\thlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx_eff[effhash(can_id)], list) {\n\t\t\tif (rcv->can_id == can_id) {\n\t\t\t\tdeliver(skb, rcv);\n\t\t\t\tmatches++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcan_id &= CAN_SFF_MASK;\n\t\thlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx_sff[can_id], list) {\n\t\t\tdeliver(skb, rcv);\n\t\t\tmatches++;\n\t\t}\n\t}\n\n\treturn matches;\n}\n\nstatic void can_receive(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct can_dev_rcv_lists *dev_rcv_lists;\n\tstruct net *net = dev_net(dev);\n\tstruct can_pkg_stats *pkg_stats = net->can.pkg_stats;\n\tint matches;\n\n\t \n\tpkg_stats->rx_frames++;\n\tpkg_stats->rx_frames_delta++;\n\n\t \n\twhile (!(can_skb_prv(skb)->skbcnt))\n\t\tcan_skb_prv(skb)->skbcnt = atomic_inc_return(&skbcounter);\n\n\trcu_read_lock();\n\n\t \n\tmatches = can_rcv_filter(net->can.rx_alldev_list, skb);\n\n\t \n\tdev_rcv_lists = can_dev_rcv_lists_find(net, dev);\n\tmatches += can_rcv_filter(dev_rcv_lists, skb);\n\n\trcu_read_unlock();\n\n\t \n\tconsume_skb(skb);\n\n\tif (matches > 0) {\n\t\tpkg_stats->matches++;\n\t\tpkg_stats->matches_delta++;\n\t}\n}\n\nstatic int can_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t   struct packet_type *pt, struct net_device *orig_dev)\n{\n\tif (unlikely(dev->type != ARPHRD_CAN || !can_get_ml_priv(dev) || !can_is_can_skb(skb))) {\n\t\tpr_warn_once(\"PF_CAN: dropped non conform CAN skbuff: dev type %d, len %d\\n\",\n\t\t\t     dev->type, skb->len);\n\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tcan_receive(skb, dev);\n\treturn NET_RX_SUCCESS;\n}\n\nstatic int canfd_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tif (unlikely(dev->type != ARPHRD_CAN || !can_get_ml_priv(dev) || !can_is_canfd_skb(skb))) {\n\t\tpr_warn_once(\"PF_CAN: dropped non conform CAN FD skbuff: dev type %d, len %d\\n\",\n\t\t\t     dev->type, skb->len);\n\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tcan_receive(skb, dev);\n\treturn NET_RX_SUCCESS;\n}\n\nstatic int canxl_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tif (unlikely(dev->type != ARPHRD_CAN || !can_get_ml_priv(dev) || !can_is_canxl_skb(skb))) {\n\t\tpr_warn_once(\"PF_CAN: dropped non conform CAN XL skbuff: dev type %d, len %d\\n\",\n\t\t\t     dev->type, skb->len);\n\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tcan_receive(skb, dev);\n\treturn NET_RX_SUCCESS;\n}\n\n \n\n \nint can_proto_register(const struct can_proto *cp)\n{\n\tint proto = cp->protocol;\n\tint err = 0;\n\n\tif (proto < 0 || proto >= CAN_NPROTO) {\n\t\tpr_err(\"can: protocol number %d out of range\\n\", proto);\n\t\treturn -EINVAL;\n\t}\n\n\terr = proto_register(cp->prot, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&proto_tab_lock);\n\n\tif (rcu_access_pointer(proto_tab[proto])) {\n\t\tpr_err(\"can: protocol %d already registered\\n\", proto);\n\t\terr = -EBUSY;\n\t} else {\n\t\tRCU_INIT_POINTER(proto_tab[proto], cp);\n\t}\n\n\tmutex_unlock(&proto_tab_lock);\n\n\tif (err < 0)\n\t\tproto_unregister(cp->prot);\n\n\treturn err;\n}\nEXPORT_SYMBOL(can_proto_register);\n\n \nvoid can_proto_unregister(const struct can_proto *cp)\n{\n\tint proto = cp->protocol;\n\n\tmutex_lock(&proto_tab_lock);\n\tBUG_ON(rcu_access_pointer(proto_tab[proto]) != cp);\n\tRCU_INIT_POINTER(proto_tab[proto], NULL);\n\tmutex_unlock(&proto_tab_lock);\n\n\tsynchronize_rcu();\n\n\tproto_unregister(cp->prot);\n}\nEXPORT_SYMBOL(can_proto_unregister);\n\nstatic int can_pernet_init(struct net *net)\n{\n\tspin_lock_init(&net->can.rcvlists_lock);\n\tnet->can.rx_alldev_list =\n\t\tkzalloc(sizeof(*net->can.rx_alldev_list), GFP_KERNEL);\n\tif (!net->can.rx_alldev_list)\n\t\tgoto out;\n\tnet->can.pkg_stats = kzalloc(sizeof(*net->can.pkg_stats), GFP_KERNEL);\n\tif (!net->can.pkg_stats)\n\t\tgoto out_free_rx_alldev_list;\n\tnet->can.rcv_lists_stats = kzalloc(sizeof(*net->can.rcv_lists_stats), GFP_KERNEL);\n\tif (!net->can.rcv_lists_stats)\n\t\tgoto out_free_pkg_stats;\n\n\tif (IS_ENABLED(CONFIG_PROC_FS)) {\n\t\t \n\t\tif (stats_timer) {\n\t\t\ttimer_setup(&net->can.stattimer, can_stat_update,\n\t\t\t\t    0);\n\t\t\tmod_timer(&net->can.stattimer,\n\t\t\t\t  round_jiffies(jiffies + HZ));\n\t\t}\n\t\tnet->can.pkg_stats->jiffies_init = jiffies;\n\t\tcan_init_proc(net);\n\t}\n\n\treturn 0;\n\n out_free_pkg_stats:\n\tkfree(net->can.pkg_stats);\n out_free_rx_alldev_list:\n\tkfree(net->can.rx_alldev_list);\n out:\n\treturn -ENOMEM;\n}\n\nstatic void can_pernet_exit(struct net *net)\n{\n\tif (IS_ENABLED(CONFIG_PROC_FS)) {\n\t\tcan_remove_proc(net);\n\t\tif (stats_timer)\n\t\t\tdel_timer_sync(&net->can.stattimer);\n\t}\n\n\tkfree(net->can.rx_alldev_list);\n\tkfree(net->can.pkg_stats);\n\tkfree(net->can.rcv_lists_stats);\n}\n\n \n\nstatic struct packet_type can_packet __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_CAN),\n\t.func = can_rcv,\n};\n\nstatic struct packet_type canfd_packet __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_CANFD),\n\t.func = canfd_rcv,\n};\n\nstatic struct packet_type canxl_packet __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_CANXL),\n\t.func = canxl_rcv,\n};\n\nstatic const struct net_proto_family can_family_ops = {\n\t.family = PF_CAN,\n\t.create = can_create,\n\t.owner  = THIS_MODULE,\n};\n\nstatic struct pernet_operations can_pernet_ops __read_mostly = {\n\t.init = can_pernet_init,\n\t.exit = can_pernet_exit,\n};\n\nstatic __init int can_init(void)\n{\n\tint err;\n\n\t \n\tBUILD_BUG_ON(offsetof(struct can_frame, len) !=\n\t\t     offsetof(struct canfd_frame, len) ||\n\t\t     offsetof(struct can_frame, data) !=\n\t\t     offsetof(struct canfd_frame, data));\n\n\tpr_info(\"can: controller area network core\\n\");\n\n\trcv_cache = kmem_cache_create(\"can_receiver\", sizeof(struct receiver),\n\t\t\t\t      0, 0, NULL);\n\tif (!rcv_cache)\n\t\treturn -ENOMEM;\n\n\terr = register_pernet_subsys(&can_pernet_ops);\n\tif (err)\n\t\tgoto out_pernet;\n\n\t \n\terr = sock_register(&can_family_ops);\n\tif (err)\n\t\tgoto out_sock;\n\n\tdev_add_pack(&can_packet);\n\tdev_add_pack(&canfd_packet);\n\tdev_add_pack(&canxl_packet);\n\n\treturn 0;\n\nout_sock:\n\tunregister_pernet_subsys(&can_pernet_ops);\nout_pernet:\n\tkmem_cache_destroy(rcv_cache);\n\n\treturn err;\n}\n\nstatic __exit void can_exit(void)\n{\n\t \n\tdev_remove_pack(&canxl_packet);\n\tdev_remove_pack(&canfd_packet);\n\tdev_remove_pack(&can_packet);\n\tsock_unregister(PF_CAN);\n\n\tunregister_pernet_subsys(&can_pernet_ops);\n\n\trcu_barrier();  \n\n\tkmem_cache_destroy(rcv_cache);\n}\n\nmodule_init(can_init);\nmodule_exit(can_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}