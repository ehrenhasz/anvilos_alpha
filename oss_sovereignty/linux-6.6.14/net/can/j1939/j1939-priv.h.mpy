{
  "module_name": "j1939-priv.h",
  "hash_id": "283c4a19a53b4ee4dbae84e67aa18afaf2446e7eb369b96c7777452b6c45d1de",
  "original_prompt": "Ingested from linux-6.6.14/net/can/j1939/j1939-priv.h",
  "human_readable_source": " \n\n\n\n\n\n\n\n#ifndef _J1939_PRIV_H_\n#define _J1939_PRIV_H_\n\n#include <linux/can/j1939.h>\n#include <net/sock.h>\n\n \n#define J1939_XTP_ABORT_TIMEOUT_MS 500\n#define J1939_SIMPLE_ECHO_TIMEOUT_MS (10 * 1000)\n\nstruct j1939_session;\nenum j1939_sk_errqueue_type {\n\tJ1939_ERRQUEUE_TX_ACK,\n\tJ1939_ERRQUEUE_TX_SCHED,\n\tJ1939_ERRQUEUE_TX_ABORT,\n\tJ1939_ERRQUEUE_RX_RTS,\n\tJ1939_ERRQUEUE_RX_DPO,\n\tJ1939_ERRQUEUE_RX_ABORT,\n};\n\n \nstruct j1939_ecu {\n\tstruct list_head list;\n\tname_t name;\n\tu8 addr;\n\n\t \n\tstruct hrtimer ac_timer;\n\tstruct kref kref;\n\tstruct j1939_priv *priv;\n\n\t \n\tint nusers;\n};\n\nstruct j1939_priv {\n\tstruct list_head ecus;\n\t \n\n\t \n\trwlock_t lock;\n\n\tstruct net_device *ndev;\n\n\t \n\tstruct j1939_addr_ent {\n\t\tstruct j1939_ecu *ecu;\n\t\t \n\t\tint nusers;\n\t} ents[256];\n\n\tstruct kref kref;\n\n\t \n\tstruct list_head active_session_list;\n\n\t \n\tspinlock_t active_session_list_lock;\n\n\tunsigned int tp_max_packet_size;\n\n\t \n\tspinlock_t j1939_socks_lock;\n\tstruct list_head j1939_socks;\n\n\tstruct kref rx_kref;\n\tu32 rx_tskey;\n};\n\nvoid j1939_ecu_put(struct j1939_ecu *ecu);\n\n \nint j1939_local_ecu_get(struct j1939_priv *priv, name_t name, u8 sa);\nvoid j1939_local_ecu_put(struct j1939_priv *priv, name_t name, u8 sa);\n\nstatic inline bool j1939_address_is_unicast(u8 addr)\n{\n\treturn addr <= J1939_MAX_UNICAST_ADDR;\n}\n\nstatic inline bool j1939_address_is_idle(u8 addr)\n{\n\treturn addr == J1939_IDLE_ADDR;\n}\n\nstatic inline bool j1939_address_is_valid(u8 addr)\n{\n\treturn addr != J1939_NO_ADDR;\n}\n\nstatic inline bool j1939_pgn_is_pdu1(pgn_t pgn)\n{\n\t \n\treturn (pgn & 0xff00) < 0xf000;\n}\n\n \nvoid j1939_ecu_unmap_locked(struct j1939_ecu *ecu);\nvoid j1939_ecu_unmap(struct j1939_ecu *ecu);\n\nu8 j1939_name_to_addr(struct j1939_priv *priv, name_t name);\nstruct j1939_ecu *j1939_ecu_find_by_addr_locked(struct j1939_priv *priv,\n\t\t\t\t\t\tu8 addr);\nstruct j1939_ecu *j1939_ecu_get_by_addr(struct j1939_priv *priv, u8 addr);\nstruct j1939_ecu *j1939_ecu_get_by_addr_locked(struct j1939_priv *priv,\n\t\t\t\t\t       u8 addr);\nstruct j1939_ecu *j1939_ecu_get_by_name(struct j1939_priv *priv, name_t name);\nstruct j1939_ecu *j1939_ecu_get_by_name_locked(struct j1939_priv *priv,\n\t\t\t\t\t       name_t name);\n\nenum j1939_transfer_type {\n\tJ1939_TP,\n\tJ1939_ETP,\n\tJ1939_SIMPLE,\n};\n\nstruct j1939_addr {\n\tname_t src_name;\n\tname_t dst_name;\n\tpgn_t pgn;\n\n\tu8 sa;\n\tu8 da;\n\n\tu8 type;\n};\n\n \nstruct j1939_sk_buff_cb {\n\t \n\tu32 offset;\n\n\t \n\tu32 msg_flags;\n\tu32 tskey;\n\n\tstruct j1939_addr addr;\n\n\t \n#define J1939_ECU_LOCAL_SRC BIT(0)\n#define J1939_ECU_LOCAL_DST BIT(1)\n\tu8 flags;\n\n\tpriority_t priority;\n};\n\nstatic inline\nstruct j1939_sk_buff_cb *j1939_skb_to_cb(const struct sk_buff *skb)\n{\n\tBUILD_BUG_ON(sizeof(struct j1939_sk_buff_cb) > sizeof(skb->cb));\n\n\treturn (struct j1939_sk_buff_cb *)skb->cb;\n}\n\nint j1939_send_one(struct j1939_priv *priv, struct sk_buff *skb);\nvoid j1939_sk_recv(struct j1939_priv *priv, struct sk_buff *skb);\nbool j1939_sk_recv_match(struct j1939_priv *priv,\n\t\t\t struct j1939_sk_buff_cb *skcb);\nvoid j1939_sk_send_loop_abort(struct sock *sk, int err);\nvoid j1939_sk_errqueue(struct j1939_session *session,\n\t\t       enum j1939_sk_errqueue_type type);\nvoid j1939_sk_queue_activate_next(struct j1939_session *session);\n\n \nstruct j1939_session *j1939_tp_send(struct j1939_priv *priv,\n\t\t\t\t    struct sk_buff *skb, size_t size);\nint j1939_tp_recv(struct j1939_priv *priv, struct sk_buff *skb);\nint j1939_ac_fixup(struct j1939_priv *priv, struct sk_buff *skb);\nvoid j1939_ac_recv(struct j1939_priv *priv, struct sk_buff *skb);\nvoid j1939_simple_recv(struct j1939_priv *priv, struct sk_buff *skb);\n\n \nstruct j1939_ecu *j1939_ecu_create_locked(struct j1939_priv *priv, name_t name);\n\nvoid j1939_ecu_timer_start(struct j1939_ecu *ecu);\nvoid j1939_ecu_timer_cancel(struct j1939_ecu *ecu);\nvoid j1939_ecu_unmap_all(struct j1939_priv *priv);\n\nstruct j1939_priv *j1939_netdev_start(struct net_device *ndev);\nvoid j1939_netdev_stop(struct j1939_priv *priv);\n\nvoid j1939_priv_put(struct j1939_priv *priv);\nvoid j1939_priv_get(struct j1939_priv *priv);\n\n \nvoid j1939_sk_netdev_event_netdown(struct j1939_priv *priv);\nint j1939_cancel_active_session(struct j1939_priv *priv, struct sock *sk);\nvoid j1939_tp_init(struct j1939_priv *priv);\n\n \nvoid j1939_sock_pending_del(struct sock *sk);\n\nenum j1939_session_state {\n\tJ1939_SESSION_NEW,\n\tJ1939_SESSION_ACTIVE,\n\t \n\tJ1939_SESSION_WAITING_ABORT,\n\tJ1939_SESSION_ACTIVE_MAX,\n\tJ1939_SESSION_DONE,\n};\n\nstruct j1939_session {\n\tstruct j1939_priv *priv;\n\tstruct list_head active_session_list_entry;\n\tstruct list_head sk_session_queue_entry;\n\tstruct kref kref;\n\tstruct sock *sk;\n\n\t \n\tstruct j1939_sk_buff_cb skcb;\n\tstruct sk_buff_head skb_queue;\n\n\t \n\tu8 last_cmd, last_txcmd;\n\tbool transmission;\n\tbool extd;\n\t \n\tunsigned int total_message_size;\n\t \n\tunsigned int total_queued_size;\n\tunsigned int tx_retry;\n\n\tint err;\n\tu32 tskey;\n\tenum j1939_session_state state;\n\n\t \n\tstruct {\n\t\t \n\t\tunsigned int total;\n\t\t \n\t\tunsigned int last;\n\t\t \n\t\tunsigned int tx;\n\t\tunsigned int tx_acked;\n\t\t \n\t\tunsigned int rx;\n\t\t \n\t\tunsigned int block;\n\t\t \n\t\tunsigned int dpo;\n\t} pkt;\n\tstruct hrtimer txtimer, rxtimer;\n};\n\nstruct j1939_sock {\n\tstruct sock sk;  \n\tstruct j1939_priv *priv;\n\tstruct list_head list;\n\n#define J1939_SOCK_BOUND BIT(0)\n#define J1939_SOCK_CONNECTED BIT(1)\n#define J1939_SOCK_PROMISC BIT(2)\n#define J1939_SOCK_ERRQUEUE BIT(3)\n\tint state;\n\n\tint ifindex;\n\tstruct j1939_addr addr;\n\tstruct j1939_filter *filters;\n\tint nfilters;\n\tpgn_t pgn_rx_filter;\n\n\t \n\tatomic_t skb_pending;\n\twait_queue_head_t waitq;\n\n\t \n\tspinlock_t sk_session_queue_lock;\n\tstruct list_head sk_session_queue;\n};\n\nstatic inline struct j1939_sock *j1939_sk(const struct sock *sk)\n{\n\treturn container_of(sk, struct j1939_sock, sk);\n}\n\nvoid j1939_session_get(struct j1939_session *session);\nvoid j1939_session_put(struct j1939_session *session);\nvoid j1939_session_skb_queue(struct j1939_session *session,\n\t\t\t     struct sk_buff *skb);\nint j1939_session_activate(struct j1939_session *session);\nvoid j1939_tp_schedule_txtimer(struct j1939_session *session, int msec);\nvoid j1939_session_timers_cancel(struct j1939_session *session);\n\n#define J1939_MIN_TP_PACKET_SIZE 9\n#define J1939_MAX_TP_PACKET_SIZE (7 * 0xff)\n#define J1939_MAX_ETP_PACKET_SIZE (7 * 0x00ffffff)\n\n#define J1939_REGULAR 0\n#define J1939_EXTENDED 1\n\n \nextern const struct can_proto j1939_can_proto;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}