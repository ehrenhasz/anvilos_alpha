{
  "module_name": "transport.c",
  "hash_id": "5f4282019cc1fe9dc2e263ec9755c7fef96f23612cc3a7b45727cd1db8c43a9c",
  "original_prompt": "Ingested from linux-6.6.14/net/can/j1939/transport.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/can/skb.h>\n\n#include \"j1939-priv.h\"\n\n#define J1939_XTP_TX_RETRY_LIMIT 100\n\n#define J1939_ETP_PGN_CTL 0xc800\n#define J1939_ETP_PGN_DAT 0xc700\n#define J1939_TP_PGN_CTL 0xec00\n#define J1939_TP_PGN_DAT 0xeb00\n\n#define J1939_TP_CMD_RTS 0x10\n#define J1939_TP_CMD_CTS 0x11\n#define J1939_TP_CMD_EOMA 0x13\n#define J1939_TP_CMD_BAM 0x20\n#define J1939_TP_CMD_ABORT 0xff\n\n#define J1939_ETP_CMD_RTS 0x14\n#define J1939_ETP_CMD_CTS 0x15\n#define J1939_ETP_CMD_DPO 0x16\n#define J1939_ETP_CMD_EOMA 0x17\n#define J1939_ETP_CMD_ABORT 0xff\n\nenum j1939_xtp_abort {\n\tJ1939_XTP_NO_ABORT = 0,\n\tJ1939_XTP_ABORT_BUSY = 1,\n\t \n\n\tJ1939_XTP_ABORT_RESOURCE = 2,\n\t \n\n\tJ1939_XTP_ABORT_TIMEOUT = 3,\n\t \n\n\tJ1939_XTP_ABORT_GENERIC = 4,\n\t \n\n\tJ1939_XTP_ABORT_FAULT = 5,\n\t \n\n\tJ1939_XTP_ABORT_UNEXPECTED_DATA = 6,\n\t \n\n\tJ1939_XTP_ABORT_BAD_SEQ = 7,\n\t \n\n\tJ1939_XTP_ABORT_DUP_SEQ = 8,\n\t \n\n\tJ1939_XTP_ABORT_EDPO_UNEXPECTED = 9,\n\t \n\n\tJ1939_XTP_ABORT_BAD_EDPO_PGN = 10,\n\t \n\n\tJ1939_XTP_ABORT_EDPO_OUTOF_CTS = 11,\n\t \n\n\tJ1939_XTP_ABORT_BAD_EDPO_OFFSET = 12,\n\t \n\n\tJ1939_XTP_ABORT_OTHER_DEPRECATED = 13,\n\t \n\n\tJ1939_XTP_ABORT_ECTS_UNXPECTED_PGN = 14,\n\t \n\n\tJ1939_XTP_ABORT_ECTS_TOO_BIG = 15,\n\t \n\n\tJ1939_XTP_ABORT_OTHER = 250,\n\t \n};\n\nstatic unsigned int j1939_tp_block = 255;\nstatic unsigned int j1939_tp_packet_delay;\nstatic unsigned int j1939_tp_padding = 1;\n\n \nstatic const char *j1939_xtp_abort_to_str(enum j1939_xtp_abort abort)\n{\n\tswitch (abort) {\n\tcase J1939_XTP_ABORT_BUSY:\n\t\treturn \"Already in one or more connection managed sessions and cannot support another.\";\n\tcase J1939_XTP_ABORT_RESOURCE:\n\t\treturn \"System resources were needed for another task so this connection managed session was terminated.\";\n\tcase J1939_XTP_ABORT_TIMEOUT:\n\t\treturn \"A timeout occurred and this is the connection abort to close the session.\";\n\tcase J1939_XTP_ABORT_GENERIC:\n\t\treturn \"CTS messages received when data transfer is in progress\";\n\tcase J1939_XTP_ABORT_FAULT:\n\t\treturn \"Maximal retransmit request limit reached\";\n\tcase J1939_XTP_ABORT_UNEXPECTED_DATA:\n\t\treturn \"Unexpected data transfer packet\";\n\tcase J1939_XTP_ABORT_BAD_SEQ:\n\t\treturn \"Bad sequence number (and software is not able to recover)\";\n\tcase J1939_XTP_ABORT_DUP_SEQ:\n\t\treturn \"Duplicate sequence number (and software is not able to recover)\";\n\tcase J1939_XTP_ABORT_EDPO_UNEXPECTED:\n\t\treturn \"Unexpected EDPO packet (ETP) or Message size > 1785 bytes (TP)\";\n\tcase J1939_XTP_ABORT_BAD_EDPO_PGN:\n\t\treturn \"Unexpected EDPO PGN (PGN in EDPO is bad)\";\n\tcase J1939_XTP_ABORT_EDPO_OUTOF_CTS:\n\t\treturn \"EDPO number of packets is greater than CTS\";\n\tcase J1939_XTP_ABORT_BAD_EDPO_OFFSET:\n\t\treturn \"Bad EDPO offset\";\n\tcase J1939_XTP_ABORT_OTHER_DEPRECATED:\n\t\treturn \"Deprecated. Use 250 instead (Any other reason)\";\n\tcase J1939_XTP_ABORT_ECTS_UNXPECTED_PGN:\n\t\treturn \"Unexpected ECTS PGN (PGN in ECTS is bad)\";\n\tcase J1939_XTP_ABORT_ECTS_TOO_BIG:\n\t\treturn \"ECTS requested packets exceeds message size\";\n\tcase J1939_XTP_ABORT_OTHER:\n\t\treturn \"Any other reason (if a Connection Abort reason is identified that is not listed in the table use code 250)\";\n\tdefault:\n\t\treturn \"<unknown>\";\n\t}\n}\n\nstatic int j1939_xtp_abort_to_errno(struct j1939_priv *priv,\n\t\t\t\t    enum j1939_xtp_abort abort)\n{\n\tint err;\n\n\tswitch (abort) {\n\tcase J1939_XTP_NO_ABORT:\n\t\tWARN_ON_ONCE(abort == J1939_XTP_NO_ABORT);\n\t\terr = 0;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_BUSY:\n\t\terr = EALREADY;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_RESOURCE:\n\t\terr = EMSGSIZE;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_TIMEOUT:\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_GENERIC:\n\t\terr = EBADMSG;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_FAULT:\n\t\terr = ENOTRECOVERABLE;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_UNEXPECTED_DATA:\n\t\terr = ENOTCONN;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_BAD_SEQ:\n\t\terr = EILSEQ;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_DUP_SEQ:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_EDPO_UNEXPECTED:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_BAD_EDPO_PGN:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_EDPO_OUTOF_CTS:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_BAD_EDPO_OFFSET:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_OTHER_DEPRECATED:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_ECTS_UNXPECTED_PGN:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_ECTS_TOO_BIG:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase J1939_XTP_ABORT_OTHER:\n\t\terr = EPROTO;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(priv->ndev, \"Unknown abort code %i\", abort);\n\t\terr = EPROTO;\n\t}\n\n\treturn err;\n}\n\nstatic inline void j1939_session_list_lock(struct j1939_priv *priv)\n{\n\tspin_lock_bh(&priv->active_session_list_lock);\n}\n\nstatic inline void j1939_session_list_unlock(struct j1939_priv *priv)\n{\n\tspin_unlock_bh(&priv->active_session_list_lock);\n}\n\nvoid j1939_session_get(struct j1939_session *session)\n{\n\tkref_get(&session->kref);\n}\n\n \nstatic void __j1939_session_drop(struct j1939_session *session)\n{\n\tif (!session->transmission)\n\t\treturn;\n\n\tj1939_sock_pending_del(session->sk);\n\tsock_put(session->sk);\n}\n\nstatic void j1939_session_destroy(struct j1939_session *session)\n{\n\tstruct sk_buff *skb;\n\n\tif (session->transmission) {\n\t\tif (session->err)\n\t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_TX_ABORT);\n\t\telse\n\t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_TX_ACK);\n\t} else if (session->err) {\n\t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_RX_ABORT);\n\t}\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\tWARN_ON_ONCE(!list_empty(&session->sk_session_queue_entry));\n\tWARN_ON_ONCE(!list_empty(&session->active_session_list_entry));\n\n\twhile ((skb = skb_dequeue(&session->skb_queue)) != NULL) {\n\t\t \n\t\tskb_unref(skb);\n\t\tkfree_skb(skb);\n\t}\n\t__j1939_session_drop(session);\n\tj1939_priv_put(session->priv);\n\tkfree(session);\n}\n\nstatic void __j1939_session_release(struct kref *kref)\n{\n\tstruct j1939_session *session = container_of(kref, struct j1939_session,\n\t\t\t\t\t\t     kref);\n\n\tj1939_session_destroy(session);\n}\n\nvoid j1939_session_put(struct j1939_session *session)\n{\n\tkref_put(&session->kref, __j1939_session_release);\n}\n\nstatic void j1939_session_txtimer_cancel(struct j1939_session *session)\n{\n\tif (hrtimer_cancel(&session->txtimer))\n\t\tj1939_session_put(session);\n}\n\nstatic void j1939_session_rxtimer_cancel(struct j1939_session *session)\n{\n\tif (hrtimer_cancel(&session->rxtimer))\n\t\tj1939_session_put(session);\n}\n\nvoid j1939_session_timers_cancel(struct j1939_session *session)\n{\n\tj1939_session_txtimer_cancel(session);\n\tj1939_session_rxtimer_cancel(session);\n}\n\nstatic inline bool j1939_cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)\n{\n\treturn (!skcb->addr.dst_name && (skcb->addr.da == 0xff));\n}\n\nstatic void j1939_session_skb_drop_old(struct j1939_session *session)\n{\n\tstruct sk_buff *do_skb;\n\tstruct j1939_sk_buff_cb *do_skcb;\n\tunsigned int offset_start;\n\tunsigned long flags;\n\n\tif (skb_queue_len(&session->skb_queue) < 2)\n\t\treturn;\n\n\toffset_start = session->pkt.tx_acked * 7;\n\n\tspin_lock_irqsave(&session->skb_queue.lock, flags);\n\tdo_skb = skb_peek(&session->skb_queue);\n\tdo_skcb = j1939_skb_to_cb(do_skb);\n\n\tif ((do_skcb->offset + do_skb->len) < offset_start) {\n\t\t__skb_unlink(do_skb, &session->skb_queue);\n\t\t \n\t\tskb_unref(do_skb);\n\t\tspin_unlock_irqrestore(&session->skb_queue.lock, flags);\n\n\t\tkfree_skb(do_skb);\n\t} else {\n\t\tspin_unlock_irqrestore(&session->skb_queue.lock, flags);\n\t}\n}\n\nvoid j1939_session_skb_queue(struct j1939_session *session,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_priv *priv = session->priv;\n\n\tj1939_ac_fixup(priv, skb);\n\n\tif (j1939_address_is_unicast(skcb->addr.da) &&\n\t    priv->ents[skcb->addr.da].nusers)\n\t\tskcb->flags |= J1939_ECU_LOCAL_DST;\n\n\tskcb->flags |= J1939_ECU_LOCAL_SRC;\n\n\tskb_get(skb);\n\tskb_queue_tail(&session->skb_queue, skb);\n}\n\nstatic struct\nsk_buff *j1939_session_skb_get_by_offset(struct j1939_session *session,\n\t\t\t\t\t unsigned int offset_start)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tstruct j1939_sk_buff_cb *do_skcb;\n\tstruct sk_buff *skb = NULL;\n\tstruct sk_buff *do_skb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&session->skb_queue.lock, flags);\n\tskb_queue_walk(&session->skb_queue, do_skb) {\n\t\tdo_skcb = j1939_skb_to_cb(do_skb);\n\n\t\tif (offset_start >= do_skcb->offset &&\n\t\t    offset_start < (do_skcb->offset + do_skb->len)) {\n\t\t\tskb = do_skb;\n\t\t}\n\t}\n\n\tif (skb)\n\t\tskb_get(skb);\n\n\tspin_unlock_irqrestore(&session->skb_queue.lock, flags);\n\n\tif (!skb)\n\t\tnetdev_dbg(priv->ndev, \"%s: 0x%p: no skb found for start: %i, queue size: %i\\n\",\n\t\t\t   __func__, session, offset_start,\n\t\t\t   skb_queue_len(&session->skb_queue));\n\n\treturn skb;\n}\n\nstatic struct sk_buff *j1939_session_skb_get(struct j1939_session *session)\n{\n\tunsigned int offset_start;\n\n\toffset_start = session->pkt.dpo * 7;\n\treturn j1939_session_skb_get_by_offset(session, offset_start);\n}\n\n \nstatic inline int j1939_tp_im_receiver(const struct j1939_sk_buff_cb *skcb)\n{\n\treturn skcb->flags & J1939_ECU_LOCAL_DST;\n}\n\n \nstatic inline int j1939_tp_im_transmitter(const struct j1939_sk_buff_cb *skcb)\n{\n\treturn skcb->flags & J1939_ECU_LOCAL_SRC;\n}\n\n \nstatic int j1939_tp_im_involved(const struct j1939_sk_buff_cb *skcb, bool swap)\n{\n\tif (swap)\n\t\treturn j1939_tp_im_receiver(skcb);\n\telse\n\t\treturn j1939_tp_im_transmitter(skcb);\n}\n\nstatic int j1939_tp_im_involved_anydir(struct j1939_sk_buff_cb *skcb)\n{\n\treturn skcb->flags & (J1939_ECU_LOCAL_SRC | J1939_ECU_LOCAL_DST);\n}\n\n \nstatic inline pgn_t j1939_xtp_ctl_to_pgn(const u8 *dat)\n{\n\tpgn_t pgn;\n\n\tpgn = (dat[7] << 16) | (dat[6] << 8) | (dat[5] << 0);\n\tif (j1939_pgn_is_pdu1(pgn))\n\t\tpgn &= 0xffff00;\n\treturn pgn;\n}\n\nstatic inline unsigned int j1939_tp_ctl_to_size(const u8 *dat)\n{\n\treturn (dat[2] << 8) + (dat[1] << 0);\n}\n\nstatic inline unsigned int j1939_etp_ctl_to_packet(const u8 *dat)\n{\n\treturn (dat[4] << 16) | (dat[3] << 8) | (dat[2] << 0);\n}\n\nstatic inline unsigned int j1939_etp_ctl_to_size(const u8 *dat)\n{\n\treturn (dat[4] << 24) | (dat[3] << 16) |\n\t\t(dat[2] << 8) | (dat[1] << 0);\n}\n\n \nstatic bool j1939_session_match(struct j1939_addr *se_addr,\n\t\t\t\tstruct j1939_addr *sk_addr, bool reverse)\n{\n\tif (se_addr->type != sk_addr->type)\n\t\treturn false;\n\n\tif (reverse) {\n\t\tif (se_addr->src_name) {\n\t\t\tif (se_addr->src_name != sk_addr->dst_name)\n\t\t\t\treturn false;\n\t\t} else if (se_addr->sa != sk_addr->da) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (se_addr->dst_name) {\n\t\t\tif (se_addr->dst_name != sk_addr->src_name)\n\t\t\t\treturn false;\n\t\t} else if (se_addr->da != sk_addr->sa) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (se_addr->src_name) {\n\t\t\tif (se_addr->src_name != sk_addr->src_name)\n\t\t\t\treturn false;\n\t\t} else if (se_addr->sa != sk_addr->sa) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (se_addr->dst_name) {\n\t\t\tif (se_addr->dst_name != sk_addr->dst_name)\n\t\t\t\treturn false;\n\t\t} else if (se_addr->da != sk_addr->da) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic struct\nj1939_session *j1939_session_get_by_addr_locked(struct j1939_priv *priv,\n\t\t\t\t\t\tstruct list_head *root,\n\t\t\t\t\t\tstruct j1939_addr *addr,\n\t\t\t\t\t\tbool reverse, bool transmitter)\n{\n\tstruct j1939_session *session;\n\n\tlockdep_assert_held(&priv->active_session_list_lock);\n\n\tlist_for_each_entry(session, root, active_session_list_entry) {\n\t\tj1939_session_get(session);\n\t\tif (j1939_session_match(&session->skcb.addr, addr, reverse) &&\n\t\t    session->transmission == transmitter)\n\t\t\treturn session;\n\t\tj1939_session_put(session);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct\nj1939_session *j1939_session_get_simple(struct j1939_priv *priv,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_session *session;\n\n\tlockdep_assert_held(&priv->active_session_list_lock);\n\n\tlist_for_each_entry(session, &priv->active_session_list,\n\t\t\t    active_session_list_entry) {\n\t\tj1939_session_get(session);\n\t\tif (session->skcb.addr.type == J1939_SIMPLE &&\n\t\t    session->tskey == skcb->tskey && session->sk == skb->sk)\n\t\t\treturn session;\n\t\tj1939_session_put(session);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct\nj1939_session *j1939_session_get_by_addr(struct j1939_priv *priv,\n\t\t\t\t\t struct j1939_addr *addr,\n\t\t\t\t\t bool reverse, bool transmitter)\n{\n\tstruct j1939_session *session;\n\n\tj1939_session_list_lock(priv);\n\tsession = j1939_session_get_by_addr_locked(priv,\n\t\t\t\t\t\t   &priv->active_session_list,\n\t\t\t\t\t\t   addr, reverse, transmitter);\n\tj1939_session_list_unlock(priv);\n\n\treturn session;\n}\n\nstatic void j1939_skbcb_swap(struct j1939_sk_buff_cb *skcb)\n{\n\tu8 tmp = 0;\n\n\tswap(skcb->addr.dst_name, skcb->addr.src_name);\n\tswap(skcb->addr.da, skcb->addr.sa);\n\n\t \n\tif (skcb->flags & J1939_ECU_LOCAL_SRC)\n\t\ttmp |= J1939_ECU_LOCAL_DST;\n\tif (skcb->flags & J1939_ECU_LOCAL_DST)\n\t\ttmp |= J1939_ECU_LOCAL_SRC;\n\tskcb->flags &= ~(J1939_ECU_LOCAL_SRC | J1939_ECU_LOCAL_DST);\n\tskcb->flags |= tmp;\n}\n\nstatic struct\nsk_buff *j1939_tp_tx_dat_new(struct j1939_priv *priv,\n\t\t\t     const struct j1939_sk_buff_cb *re_skcb,\n\t\t\t     bool ctl,\n\t\t\t     bool swap_src_dst)\n{\n\tstruct sk_buff *skb;\n\tstruct j1939_sk_buff_cb *skcb;\n\n\tskb = alloc_skb(sizeof(struct can_frame) + sizeof(struct can_skb_priv),\n\t\t\tGFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb->dev = priv->ndev;\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = priv->ndev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\t \n\tskb_reserve(skb, offsetof(struct can_frame, data));\n\n\t \n\tBUILD_BUG_ON(sizeof(skb->cb) < sizeof(*re_skcb));\n\n\tmemcpy(skb->cb, re_skcb, sizeof(*re_skcb));\n\tskcb = j1939_skb_to_cb(skb);\n\tif (swap_src_dst)\n\t\tj1939_skbcb_swap(skcb);\n\n\tif (ctl) {\n\t\tif (skcb->addr.type == J1939_ETP)\n\t\t\tskcb->addr.pgn = J1939_ETP_PGN_CTL;\n\t\telse\n\t\t\tskcb->addr.pgn = J1939_TP_PGN_CTL;\n\t} else {\n\t\tif (skcb->addr.type == J1939_ETP)\n\t\t\tskcb->addr.pgn = J1939_ETP_PGN_DAT;\n\t\telse\n\t\t\tskcb->addr.pgn = J1939_TP_PGN_DAT;\n\t}\n\n\treturn skb;\n}\n\n \nstatic int j1939_tp_tx_dat(struct j1939_session *session,\n\t\t\t   const u8 *dat, int len)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tstruct sk_buff *skb;\n\n\tskb = j1939_tp_tx_dat_new(priv, &session->skcb,\n\t\t\t\t  false, false);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tskb_put_data(skb, dat, len);\n\tif (j1939_tp_padding && len < 8)\n\t\tmemset(skb_put(skb, 8 - len), 0xff, 8 - len);\n\n\treturn j1939_send_one(priv, skb);\n}\n\nstatic int j1939_xtp_do_tx_ctl(struct j1939_priv *priv,\n\t\t\t       const struct j1939_sk_buff_cb *re_skcb,\n\t\t\t       bool swap_src_dst, pgn_t pgn, const u8 *dat)\n{\n\tstruct sk_buff *skb;\n\tu8 *skdat;\n\n\tif (!j1939_tp_im_involved(re_skcb, swap_src_dst))\n\t\treturn 0;\n\n\tskb = j1939_tp_tx_dat_new(priv, re_skcb, true, swap_src_dst);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tskdat = skb_put(skb, 8);\n\tmemcpy(skdat, dat, 5);\n\tskdat[5] = (pgn >> 0);\n\tskdat[6] = (pgn >> 8);\n\tskdat[7] = (pgn >> 16);\n\n\treturn j1939_send_one(priv, skb);\n}\n\nstatic inline int j1939_tp_tx_ctl(struct j1939_session *session,\n\t\t\t\t  bool swap_src_dst, const u8 *dat)\n{\n\tstruct j1939_priv *priv = session->priv;\n\n\treturn j1939_xtp_do_tx_ctl(priv, &session->skcb,\n\t\t\t\t   swap_src_dst,\n\t\t\t\t   session->skcb.addr.pgn, dat);\n}\n\nstatic int j1939_xtp_tx_abort(struct j1939_priv *priv,\n\t\t\t      const struct j1939_sk_buff_cb *re_skcb,\n\t\t\t      bool swap_src_dst,\n\t\t\t      enum j1939_xtp_abort err,\n\t\t\t      pgn_t pgn)\n{\n\tu8 dat[5];\n\n\tif (!j1939_tp_im_involved(re_skcb, swap_src_dst))\n\t\treturn 0;\n\n\tmemset(dat, 0xff, sizeof(dat));\n\tdat[0] = J1939_TP_CMD_ABORT;\n\tdat[1] = err;\n\treturn j1939_xtp_do_tx_ctl(priv, re_skcb, swap_src_dst, pgn, dat);\n}\n\nvoid j1939_tp_schedule_txtimer(struct j1939_session *session, int msec)\n{\n\tj1939_session_get(session);\n\thrtimer_start(&session->txtimer, ms_to_ktime(msec),\n\t\t      HRTIMER_MODE_REL_SOFT);\n}\n\nstatic inline void j1939_tp_set_rxtimeout(struct j1939_session *session,\n\t\t\t\t\t  int msec)\n{\n\tj1939_session_rxtimer_cancel(session);\n\tj1939_session_get(session);\n\thrtimer_start(&session->rxtimer, ms_to_ktime(msec),\n\t\t      HRTIMER_MODE_REL_SOFT);\n}\n\nstatic int j1939_session_tx_rts(struct j1939_session *session)\n{\n\tu8 dat[8];\n\tint ret;\n\n\tmemset(dat, 0xff, sizeof(dat));\n\n\tdat[1] = (session->total_message_size >> 0);\n\tdat[2] = (session->total_message_size >> 8);\n\tdat[3] = session->pkt.total;\n\n\tif (session->skcb.addr.type == J1939_ETP) {\n\t\tdat[0] = J1939_ETP_CMD_RTS;\n\t\tdat[1] = (session->total_message_size >> 0);\n\t\tdat[2] = (session->total_message_size >> 8);\n\t\tdat[3] = (session->total_message_size >> 16);\n\t\tdat[4] = (session->total_message_size >> 24);\n\t} else if (j1939_cb_is_broadcast(&session->skcb)) {\n\t\tdat[0] = J1939_TP_CMD_BAM;\n\t\t \n\t\tsession->pkt.tx = 0;\n\t} else {\n\t\tdat[0] = J1939_TP_CMD_RTS;\n\t\tdat[4] = dat[3];\n\t}\n\n\tif (dat[0] == session->last_txcmd)\n\t\t \n\t\treturn 0;\n\n\tret = j1939_tp_tx_ctl(session, false, dat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsession->last_txcmd = dat[0];\n\tif (dat[0] == J1939_TP_CMD_BAM) {\n\t\tj1939_tp_schedule_txtimer(session, 50);\n\t\tj1939_tp_set_rxtimeout(session, 250);\n\t} else {\n\t\tj1939_tp_set_rxtimeout(session, 1250);\n\t}\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\treturn 0;\n}\n\nstatic int j1939_session_tx_dpo(struct j1939_session *session)\n{\n\tunsigned int pkt;\n\tu8 dat[8];\n\tint ret;\n\n\tmemset(dat, 0xff, sizeof(dat));\n\n\tdat[0] = J1939_ETP_CMD_DPO;\n\tsession->pkt.dpo = session->pkt.tx_acked;\n\tpkt = session->pkt.dpo;\n\tdat[1] = session->pkt.last - session->pkt.tx_acked;\n\tdat[2] = (pkt >> 0);\n\tdat[3] = (pkt >> 8);\n\tdat[4] = (pkt >> 16);\n\n\tret = j1939_tp_tx_ctl(session, false, dat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsession->last_txcmd = dat[0];\n\tj1939_tp_set_rxtimeout(session, 1250);\n\tsession->pkt.tx = session->pkt.tx_acked;\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\treturn 0;\n}\n\nstatic int j1939_session_tx_dat(struct j1939_session *session)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tstruct j1939_sk_buff_cb *se_skcb;\n\tint offset, pkt_done, pkt_end;\n\tunsigned int len, pdelay;\n\tstruct sk_buff *se_skb;\n\tconst u8 *tpdat;\n\tint ret = 0;\n\tu8 dat[8];\n\n\tse_skb = j1939_session_skb_get_by_offset(session, session->pkt.tx * 7);\n\tif (!se_skb)\n\t\treturn -ENOBUFS;\n\n\tse_skcb = j1939_skb_to_cb(se_skb);\n\ttpdat = se_skb->data;\n\tret = 0;\n\tpkt_done = 0;\n\tif (session->skcb.addr.type != J1939_ETP &&\n\t    j1939_cb_is_broadcast(&session->skcb))\n\t\tpkt_end = session->pkt.total;\n\telse\n\t\tpkt_end = session->pkt.last;\n\n\twhile (session->pkt.tx < pkt_end) {\n\t\tdat[0] = session->pkt.tx - session->pkt.dpo + 1;\n\t\toffset = (session->pkt.tx * 7) - se_skcb->offset;\n\t\tlen =  se_skb->len - offset;\n\t\tif (len > 7)\n\t\t\tlen = 7;\n\n\t\tif (offset + len > se_skb->len) {\n\t\t\tnetdev_err_once(priv->ndev,\n\t\t\t\t\t\"%s: 0x%p: requested data outside of queued buffer: offset %i, len %i, pkt.tx: %i\\n\",\n\t\t\t\t\t__func__, session, se_skcb->offset,\n\t\t\t\t\tse_skb->len , session->pkt.tx);\n\t\t\tret = -EOVERFLOW;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (!len) {\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(&dat[1], &tpdat[offset], len);\n\t\tret = j1939_tp_tx_dat(session, dat, len + 1);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tif (ret != -ENOBUFS)\n\t\t\t\tnetdev_alert(priv->ndev,\n\t\t\t\t\t     \"%s: 0x%p: queue data error: %i\\n\",\n\t\t\t\t\t     __func__, session, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tsession->last_txcmd = 0xff;\n\t\tpkt_done++;\n\t\tsession->pkt.tx++;\n\t\tpdelay = j1939_cb_is_broadcast(&session->skcb) ? 50 :\n\t\t\tj1939_tp_packet_delay;\n\n\t\tif (session->pkt.tx < session->pkt.total && pdelay) {\n\t\t\tj1939_tp_schedule_txtimer(session, pdelay);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pkt_done)\n\t\tj1939_tp_set_rxtimeout(session, 250);\n\n out_free:\n\tif (ret)\n\t\tkfree_skb(se_skb);\n\telse\n\t\tconsume_skb(se_skb);\n\n\treturn ret;\n}\n\nstatic int j1939_xtp_txnext_transmiter(struct j1939_session *session)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tint ret = 0;\n\n\tif (!j1939_tp_im_transmitter(&session->skcb)) {\n\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: called by not transmitter!\\n\",\n\t\t\t     __func__, session);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (session->last_cmd) {\n\tcase 0:\n\t\tret = j1939_session_tx_rts(session);\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_CTS:\n\t\tif (session->last_txcmd != J1939_ETP_CMD_DPO) {\n\t\t\tret = j1939_session_tx_dpo(session);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tfallthrough;\n\tcase J1939_TP_CMD_CTS:\n\tcase 0xff:  \n\tcase J1939_ETP_CMD_DPO:\n\tcase J1939_TP_CMD_BAM:\n\t\tret = j1939_session_tx_dat(session);\n\n\t\tbreak;\n\tdefault:\n\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: unexpected last_cmd: %x\\n\",\n\t\t\t     __func__, session, session->last_cmd);\n\t}\n\n\treturn ret;\n}\n\nstatic int j1939_session_tx_cts(struct j1939_session *session)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tunsigned int pkt, len;\n\tint ret;\n\tu8 dat[8];\n\n\tif (!j1939_sk_recv_match(priv, &session->skcb))\n\t\treturn -ENOENT;\n\n\tlen = session->pkt.total - session->pkt.rx;\n\tlen = min3(len, session->pkt.block, j1939_tp_block ?: 255);\n\tmemset(dat, 0xff, sizeof(dat));\n\n\tif (session->skcb.addr.type == J1939_ETP) {\n\t\tpkt = session->pkt.rx + 1;\n\t\tdat[0] = J1939_ETP_CMD_CTS;\n\t\tdat[1] = len;\n\t\tdat[2] = (pkt >> 0);\n\t\tdat[3] = (pkt >> 8);\n\t\tdat[4] = (pkt >> 16);\n\t} else {\n\t\tdat[0] = J1939_TP_CMD_CTS;\n\t\tdat[1] = len;\n\t\tdat[2] = session->pkt.rx + 1;\n\t}\n\n\tif (dat[0] == session->last_txcmd)\n\t\t \n\t\treturn 0;\n\n\tret = j1939_tp_tx_ctl(session, true, dat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (len)\n\t\t \n\t\tsession->last_txcmd = dat[0];\n\tj1939_tp_set_rxtimeout(session, 1250);\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\treturn 0;\n}\n\nstatic int j1939_session_tx_eoma(struct j1939_session *session)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tu8 dat[8];\n\tint ret;\n\n\tif (!j1939_sk_recv_match(priv, &session->skcb))\n\t\treturn -ENOENT;\n\n\tmemset(dat, 0xff, sizeof(dat));\n\n\tif (session->skcb.addr.type == J1939_ETP) {\n\t\tdat[0] = J1939_ETP_CMD_EOMA;\n\t\tdat[1] = session->total_message_size >> 0;\n\t\tdat[2] = session->total_message_size >> 8;\n\t\tdat[3] = session->total_message_size >> 16;\n\t\tdat[4] = session->total_message_size >> 24;\n\t} else {\n\t\tdat[0] = J1939_TP_CMD_EOMA;\n\t\tdat[1] = session->total_message_size;\n\t\tdat[2] = session->total_message_size >> 8;\n\t\tdat[3] = session->pkt.total;\n\t}\n\n\tif (dat[0] == session->last_txcmd)\n\t\t \n\t\treturn 0;\n\n\tret = j1939_tp_tx_ctl(session, true, dat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsession->last_txcmd = dat[0];\n\n\t \n\tj1939_tp_set_rxtimeout(session, 1250);\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\treturn 0;\n}\n\nstatic int j1939_xtp_txnext_receiver(struct j1939_session *session)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tint ret = 0;\n\n\tif (!j1939_tp_im_receiver(&session->skcb)) {\n\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: called by not receiver!\\n\",\n\t\t\t     __func__, session);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (session->last_cmd) {\n\tcase J1939_TP_CMD_RTS:\n\tcase J1939_ETP_CMD_RTS:\n\t\tret = j1939_session_tx_cts(session);\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_CTS:\n\tcase J1939_TP_CMD_CTS:\n\tcase 0xff:  \n\tcase J1939_ETP_CMD_DPO:\n\t\tif ((session->skcb.addr.type == J1939_TP &&\n\t\t     j1939_cb_is_broadcast(&session->skcb)))\n\t\t\tbreak;\n\n\t\tif (session->pkt.rx >= session->pkt.total) {\n\t\t\tret = j1939_session_tx_eoma(session);\n\t\t} else if (session->pkt.rx >= session->pkt.last) {\n\t\t\tsession->last_txcmd = 0;\n\t\t\tret = j1939_session_tx_cts(session);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: unexpected last_cmd: %x\\n\",\n\t\t\t     __func__, session, session->last_cmd);\n\t}\n\n\treturn ret;\n}\n\nstatic int j1939_simple_txnext(struct j1939_session *session)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tstruct sk_buff *se_skb = j1939_session_skb_get(session);\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tif (!se_skb)\n\t\treturn 0;\n\n\tskb = skb_clone(se_skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tcan_skb_set_owner(skb, se_skb->sk);\n\n\tj1939_tp_set_rxtimeout(session, J1939_SIMPLE_ECHO_TIMEOUT_MS);\n\n\tret = j1939_send_one(priv, skb);\n\tif (ret)\n\t\tgoto out_free;\n\n\tj1939_sk_errqueue(session, J1939_ERRQUEUE_TX_SCHED);\n\tj1939_sk_queue_activate_next(session);\n\n out_free:\n\tif (ret)\n\t\tkfree_skb(se_skb);\n\telse\n\t\tconsume_skb(se_skb);\n\n\treturn ret;\n}\n\nstatic bool j1939_session_deactivate_locked(struct j1939_session *session)\n{\n\tbool active = false;\n\n\tlockdep_assert_held(&session->priv->active_session_list_lock);\n\n\tif (session->state >= J1939_SESSION_ACTIVE &&\n\t    session->state < J1939_SESSION_ACTIVE_MAX) {\n\t\tactive = true;\n\n\t\tlist_del_init(&session->active_session_list_entry);\n\t\tsession->state = J1939_SESSION_DONE;\n\t\tj1939_session_put(session);\n\t}\n\n\treturn active;\n}\n\nstatic bool j1939_session_deactivate(struct j1939_session *session)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tbool active;\n\n\tj1939_session_list_lock(priv);\n\tactive = j1939_session_deactivate_locked(session);\n\tj1939_session_list_unlock(priv);\n\n\treturn active;\n}\n\nstatic void\nj1939_session_deactivate_activate_next(struct j1939_session *session)\n{\n\tif (j1939_session_deactivate(session))\n\t\tj1939_sk_queue_activate_next(session);\n}\n\nstatic void __j1939_session_cancel(struct j1939_session *session,\n\t\t\t\t   enum j1939_xtp_abort err)\n{\n\tstruct j1939_priv *priv = session->priv;\n\n\tWARN_ON_ONCE(!err);\n\tlockdep_assert_held(&session->priv->active_session_list_lock);\n\n\tsession->err = j1939_xtp_abort_to_errno(priv, err);\n\tsession->state = J1939_SESSION_WAITING_ABORT;\n\t \n\tif (!j1939_cb_is_broadcast(&session->skcb)) {\n\t\tj1939_xtp_tx_abort(priv, &session->skcb,\n\t\t\t\t   !session->transmission,\n\t\t\t\t   err, session->skcb.addr.pgn);\n\t}\n\n\tif (session->sk)\n\t\tj1939_sk_send_loop_abort(session->sk, session->err);\n}\n\nstatic void j1939_session_cancel(struct j1939_session *session,\n\t\t\t\t enum j1939_xtp_abort err)\n{\n\tj1939_session_list_lock(session->priv);\n\n\tif (session->state >= J1939_SESSION_ACTIVE &&\n\t    session->state < J1939_SESSION_WAITING_ABORT) {\n\t\tj1939_tp_set_rxtimeout(session, J1939_XTP_ABORT_TIMEOUT_MS);\n\t\t__j1939_session_cancel(session, err);\n\t}\n\n\tj1939_session_list_unlock(session->priv);\n\n\tif (!session->sk)\n\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_RX_ABORT);\n}\n\nstatic enum hrtimer_restart j1939_tp_txtimer(struct hrtimer *hrtimer)\n{\n\tstruct j1939_session *session =\n\t\tcontainer_of(hrtimer, struct j1939_session, txtimer);\n\tstruct j1939_priv *priv = session->priv;\n\tint ret = 0;\n\n\tif (session->skcb.addr.type == J1939_SIMPLE) {\n\t\tret = j1939_simple_txnext(session);\n\t} else {\n\t\tif (session->transmission)\n\t\t\tret = j1939_xtp_txnext_transmiter(session);\n\t\telse\n\t\t\tret = j1939_xtp_txnext_receiver(session);\n\t}\n\n\tswitch (ret) {\n\tcase -ENOBUFS:\n\t\t \n\t\tif (session->tx_retry < J1939_XTP_TX_RETRY_LIMIT) {\n\t\t\tsession->tx_retry++;\n\t\t\tj1939_tp_schedule_txtimer(session,\n\t\t\t\t\t\t  10 + get_random_u32_below(16));\n\t\t} else {\n\t\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: tx retry count reached\\n\",\n\t\t\t\t     __func__, session);\n\t\t\tsession->err = -ENETUNREACH;\n\t\t\tj1939_session_rxtimer_cancel(session);\n\t\t\tj1939_session_deactivate_activate_next(session);\n\t\t}\n\t\tbreak;\n\tcase -ENETDOWN:\n\t\t \n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\tj1939_session_cancel(session, J1939_XTP_ABORT_ECTS_TOO_BIG);\n\t\tbreak;\n\tcase 0:\n\t\tsession->tx_retry = 0;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: tx aborted with unknown reason: %i\\n\",\n\t\t\t     __func__, session, ret);\n\t\tif (session->skcb.addr.type != J1939_SIMPLE) {\n\t\t\tj1939_session_cancel(session, J1939_XTP_ABORT_OTHER);\n\t\t} else {\n\t\t\tsession->err = ret;\n\t\t\tj1939_session_rxtimer_cancel(session);\n\t\t\tj1939_session_deactivate_activate_next(session);\n\t\t}\n\t}\n\n\tj1939_session_put(session);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void j1939_session_completed(struct j1939_session *session)\n{\n\tstruct sk_buff *se_skb;\n\n\tif (!session->transmission) {\n\t\tse_skb = j1939_session_skb_get(session);\n\t\t \n\t\tj1939_sk_recv(session->priv, se_skb);\n\t\tconsume_skb(se_skb);\n\t}\n\n\tj1939_session_deactivate_activate_next(session);\n}\n\nstatic enum hrtimer_restart j1939_tp_rxtimer(struct hrtimer *hrtimer)\n{\n\tstruct j1939_session *session = container_of(hrtimer,\n\t\t\t\t\t\t     struct j1939_session,\n\t\t\t\t\t\t     rxtimer);\n\tstruct j1939_priv *priv = session->priv;\n\n\tif (session->state == J1939_SESSION_WAITING_ABORT) {\n\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: abort rx timeout. Force session deactivation\\n\",\n\t\t\t     __func__, session);\n\n\t\tj1939_session_deactivate_activate_next(session);\n\n\t} else if (session->skcb.addr.type == J1939_SIMPLE) {\n\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: Timeout. Failed to send simple message.\\n\",\n\t\t\t     __func__, session);\n\n\t\t \n\t\tsession->err = -ETIME;\n\t\tj1939_session_deactivate(session);\n\t} else {\n\t\tj1939_session_list_lock(session->priv);\n\t\tif (session->state >= J1939_SESSION_ACTIVE &&\n\t\t    session->state < J1939_SESSION_ACTIVE_MAX) {\n\t\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: rx timeout, send abort\\n\",\n\t\t\t\t     __func__, session);\n\t\t\tj1939_session_get(session);\n\t\t\thrtimer_start(&session->rxtimer,\n\t\t\t\t      ms_to_ktime(J1939_XTP_ABORT_TIMEOUT_MS),\n\t\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\t\t__j1939_session_cancel(session, J1939_XTP_ABORT_TIMEOUT);\n\t\t}\n\t\tj1939_session_list_unlock(session->priv);\n\n\t\tif (!session->sk)\n\t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_RX_ABORT);\n\t}\n\n\tj1939_session_put(session);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic bool j1939_xtp_rx_cmd_bad_pgn(struct j1939_session *session,\n\t\t\t\t     const struct sk_buff *skb)\n{\n\tconst struct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tpgn_t pgn = j1939_xtp_ctl_to_pgn(skb->data);\n\tstruct j1939_priv *priv = session->priv;\n\tenum j1939_xtp_abort abort = J1939_XTP_NO_ABORT;\n\tu8 cmd = skb->data[0];\n\n\tif (session->skcb.addr.pgn == pgn)\n\t\treturn false;\n\n\tswitch (cmd) {\n\tcase J1939_TP_CMD_BAM:\n\t\tabort = J1939_XTP_NO_ABORT;\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_RTS:\n\t\tfallthrough;\n\tcase J1939_TP_CMD_RTS:\n\t\tabort = J1939_XTP_ABORT_BUSY;\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_CTS:\n\t\tfallthrough;\n\tcase J1939_TP_CMD_CTS:\n\t\tabort = J1939_XTP_ABORT_ECTS_UNXPECTED_PGN;\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_DPO:\n\t\tabort = J1939_XTP_ABORT_BAD_EDPO_PGN;\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_EOMA:\n\t\tfallthrough;\n\tcase J1939_TP_CMD_EOMA:\n\t\tabort = J1939_XTP_ABORT_OTHER;\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_ABORT:  \n\t\tabort = J1939_XTP_NO_ABORT;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\tnetdev_warn(priv->ndev, \"%s: 0x%p: CMD 0x%02x with PGN 0x%05x for running session with different PGN 0x%05x.\\n\",\n\t\t    __func__, session, cmd, pgn, session->skcb.addr.pgn);\n\tif (abort != J1939_XTP_NO_ABORT)\n\t\tj1939_xtp_tx_abort(priv, skcb, true, abort, pgn);\n\n\treturn true;\n}\n\nstatic void j1939_xtp_rx_abort_one(struct j1939_priv *priv, struct sk_buff *skb,\n\t\t\t\t   bool reverse, bool transmitter)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_session *session;\n\tu8 abort = skb->data[1];\n\n\tsession = j1939_session_get_by_addr(priv, &skcb->addr, reverse,\n\t\t\t\t\t    transmitter);\n\tif (!session)\n\t\treturn;\n\n\tif (j1939_xtp_rx_cmd_bad_pgn(session, skb))\n\t\tgoto abort_put;\n\n\tnetdev_info(priv->ndev, \"%s: 0x%p: 0x%05x: (%u) %s\\n\", __func__,\n\t\t    session, j1939_xtp_ctl_to_pgn(skb->data), abort,\n\t\t    j1939_xtp_abort_to_str(abort));\n\n\tj1939_session_timers_cancel(session);\n\tsession->err = j1939_xtp_abort_to_errno(priv, abort);\n\tif (session->sk)\n\t\tj1939_sk_send_loop_abort(session->sk, session->err);\n\telse\n\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_RX_ABORT);\n\tj1939_session_deactivate_activate_next(session);\n\nabort_put:\n\tj1939_session_put(session);\n}\n\n \nstatic void\nj1939_xtp_rx_abort(struct j1939_priv *priv, struct sk_buff *skb,\n\t\t   bool transmitter)\n{\n\tj1939_xtp_rx_abort_one(priv, skb, false, transmitter);\n\tj1939_xtp_rx_abort_one(priv, skb, true, transmitter);\n}\n\nstatic void\nj1939_xtp_rx_eoma_one(struct j1939_session *session, struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tconst u8 *dat;\n\tint len;\n\n\tif (j1939_xtp_rx_cmd_bad_pgn(session, skb))\n\t\treturn;\n\n\tdat = skb->data;\n\n\tif (skcb->addr.type == J1939_ETP)\n\t\tlen = j1939_etp_ctl_to_size(dat);\n\telse\n\t\tlen = j1939_tp_ctl_to_size(dat);\n\n\tif (session->total_message_size != len) {\n\t\tnetdev_warn_once(session->priv->ndev,\n\t\t\t\t \"%s: 0x%p: Incorrect size. Expected: %i; got: %i.\\n\",\n\t\t\t\t __func__, session, session->total_message_size,\n\t\t\t\t len);\n\t}\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\tsession->pkt.tx_acked = session->pkt.total;\n\tj1939_session_timers_cancel(session);\n\t \n\tj1939_session_completed(session);\n}\n\nstatic void\nj1939_xtp_rx_eoma(struct j1939_priv *priv, struct sk_buff *skb,\n\t\t  bool transmitter)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_session *session;\n\n\tsession = j1939_session_get_by_addr(priv, &skcb->addr, true,\n\t\t\t\t\t    transmitter);\n\tif (!session)\n\t\treturn;\n\n\tj1939_xtp_rx_eoma_one(session, skb);\n\tj1939_session_put(session);\n}\n\nstatic void\nj1939_xtp_rx_cts_one(struct j1939_session *session, struct sk_buff *skb)\n{\n\tenum j1939_xtp_abort err = J1939_XTP_ABORT_FAULT;\n\tunsigned int pkt;\n\tconst u8 *dat;\n\n\tdat = skb->data;\n\n\tif (j1939_xtp_rx_cmd_bad_pgn(session, skb))\n\t\treturn;\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\tif (session->last_cmd == dat[0]) {\n\t\terr = J1939_XTP_ABORT_DUP_SEQ;\n\t\tgoto out_session_cancel;\n\t}\n\n\tif (session->skcb.addr.type == J1939_ETP)\n\t\tpkt = j1939_etp_ctl_to_packet(dat);\n\telse\n\t\tpkt = dat[2];\n\n\tif (!pkt)\n\t\tgoto out_session_cancel;\n\telse if (dat[1] > session->pkt.block  )\n\t\tgoto out_session_cancel;\n\n\t \n\tsession->pkt.tx_acked = pkt - 1;\n\tj1939_session_skb_drop_old(session);\n\tsession->pkt.last = session->pkt.tx_acked + dat[1];\n\tif (session->pkt.last > session->pkt.total)\n\t\t \n\t\tsession->pkt.last = session->pkt.total;\n\t \n\tsession->pkt.tx = session->pkt.tx_acked;\n\n\tsession->last_cmd = dat[0];\n\tif (dat[1]) {\n\t\tj1939_tp_set_rxtimeout(session, 1250);\n\t\tif (session->transmission) {\n\t\t\tif (session->pkt.tx_acked)\n\t\t\t\tj1939_sk_errqueue(session,\n\t\t\t\t\t\t  J1939_ERRQUEUE_TX_SCHED);\n\t\t\tj1939_session_txtimer_cancel(session);\n\t\t\tj1939_tp_schedule_txtimer(session, 0);\n\t\t}\n\t} else {\n\t\t \n\t\tj1939_tp_set_rxtimeout(session, 550);\n\t}\n\treturn;\n\n out_session_cancel:\n\tj1939_session_timers_cancel(session);\n\tj1939_session_cancel(session, err);\n}\n\nstatic void\nj1939_xtp_rx_cts(struct j1939_priv *priv, struct sk_buff *skb, bool transmitter)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_session *session;\n\n\tsession = j1939_session_get_by_addr(priv, &skcb->addr, true,\n\t\t\t\t\t    transmitter);\n\tif (!session)\n\t\treturn;\n\tj1939_xtp_rx_cts_one(session, skb);\n\tj1939_session_put(session);\n}\n\nstatic struct j1939_session *j1939_session_new(struct j1939_priv *priv,\n\t\t\t\t\t       struct sk_buff *skb, size_t size)\n{\n\tstruct j1939_session *session;\n\tstruct j1939_sk_buff_cb *skcb;\n\n\tsession = kzalloc(sizeof(*session), gfp_any());\n\tif (!session)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&session->active_session_list_entry);\n\tINIT_LIST_HEAD(&session->sk_session_queue_entry);\n\tkref_init(&session->kref);\n\n\tj1939_priv_get(priv);\n\tsession->priv = priv;\n\tsession->total_message_size = size;\n\tsession->state = J1939_SESSION_NEW;\n\n\tskb_queue_head_init(&session->skb_queue);\n\tskb_queue_tail(&session->skb_queue, skb);\n\n\tskcb = j1939_skb_to_cb(skb);\n\tmemcpy(&session->skcb, skcb, sizeof(session->skcb));\n\n\thrtimer_init(&session->txtimer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL_SOFT);\n\tsession->txtimer.function = j1939_tp_txtimer;\n\thrtimer_init(&session->rxtimer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL_SOFT);\n\tsession->rxtimer.function = j1939_tp_rxtimer;\n\n\tnetdev_dbg(priv->ndev, \"%s: 0x%p: sa: %02x, da: %02x\\n\",\n\t\t   __func__, session, skcb->addr.sa, skcb->addr.da);\n\n\treturn session;\n}\n\nstatic struct\nj1939_session *j1939_session_fresh_new(struct j1939_priv *priv,\n\t\t\t\t       int size,\n\t\t\t\t       const struct j1939_sk_buff_cb *rel_skcb)\n{\n\tstruct sk_buff *skb;\n\tstruct j1939_sk_buff_cb *skcb;\n\tstruct j1939_session *session;\n\n\tskb = alloc_skb(size + sizeof(struct can_skb_priv), GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn NULL;\n\n\tskb->dev = priv->ndev;\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = priv->ndev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\tskcb = j1939_skb_to_cb(skb);\n\tmemcpy(skcb, rel_skcb, sizeof(*skcb));\n\n\tsession = j1939_session_new(priv, skb, size);\n\tif (!session) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\t \n\tskb_put(skb, size);\n\t \n\treturn session;\n}\n\nint j1939_session_activate(struct j1939_session *session)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tstruct j1939_session *active = NULL;\n\tint ret = 0;\n\n\tj1939_session_list_lock(priv);\n\tif (session->skcb.addr.type != J1939_SIMPLE)\n\t\tactive = j1939_session_get_by_addr_locked(priv,\n\t\t\t\t\t\t\t  &priv->active_session_list,\n\t\t\t\t\t\t\t  &session->skcb.addr, false,\n\t\t\t\t\t\t\t  session->transmission);\n\tif (active) {\n\t\tj1939_session_put(active);\n\t\tret = -EAGAIN;\n\t} else {\n\t\tWARN_ON_ONCE(session->state != J1939_SESSION_NEW);\n\t\tlist_add_tail(&session->active_session_list_entry,\n\t\t\t      &priv->active_session_list);\n\t\tj1939_session_get(session);\n\t\tsession->state = J1939_SESSION_ACTIVE;\n\n\t\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\",\n\t\t\t   __func__, session);\n\t}\n\tj1939_session_list_unlock(priv);\n\n\treturn ret;\n}\n\nstatic struct\nj1939_session *j1939_xtp_rx_rts_session_new(struct j1939_priv *priv,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tenum j1939_xtp_abort abort = J1939_XTP_NO_ABORT;\n\tstruct j1939_sk_buff_cb skcb = *j1939_skb_to_cb(skb);\n\tstruct j1939_session *session;\n\tconst u8 *dat;\n\tpgn_t pgn;\n\tint len;\n\n\tnetdev_dbg(priv->ndev, \"%s\\n\", __func__);\n\n\tdat = skb->data;\n\tpgn = j1939_xtp_ctl_to_pgn(dat);\n\tskcb.addr.pgn = pgn;\n\n\tif (!j1939_sk_recv_match(priv, &skcb))\n\t\treturn NULL;\n\n\tif (skcb.addr.type == J1939_ETP) {\n\t\tlen = j1939_etp_ctl_to_size(dat);\n\t\tif (len > J1939_MAX_ETP_PACKET_SIZE)\n\t\t\tabort = J1939_XTP_ABORT_FAULT;\n\t\telse if (len > priv->tp_max_packet_size)\n\t\t\tabort = J1939_XTP_ABORT_RESOURCE;\n\t\telse if (len <= J1939_MAX_TP_PACKET_SIZE)\n\t\t\tabort = J1939_XTP_ABORT_FAULT;\n\t} else {\n\t\tlen = j1939_tp_ctl_to_size(dat);\n\t\tif (len > J1939_MAX_TP_PACKET_SIZE)\n\t\t\tabort = J1939_XTP_ABORT_FAULT;\n\t\telse if (len > priv->tp_max_packet_size)\n\t\t\tabort = J1939_XTP_ABORT_RESOURCE;\n\t\telse if (len < J1939_MIN_TP_PACKET_SIZE)\n\t\t\tabort = J1939_XTP_ABORT_FAULT;\n\t}\n\n\tif (abort != J1939_XTP_NO_ABORT) {\n\t\tj1939_xtp_tx_abort(priv, &skcb, true, abort, pgn);\n\t\treturn NULL;\n\t}\n\n\tsession = j1939_session_fresh_new(priv, len, &skcb);\n\tif (!session) {\n\t\tj1939_xtp_tx_abort(priv, &skcb, true,\n\t\t\t\t   J1939_XTP_ABORT_RESOURCE, pgn);\n\t\treturn NULL;\n\t}\n\n\t \n\tsession->pkt.total = (len + 6) / 7;\n\tsession->pkt.block = 0xff;\n\tif (skcb.addr.type != J1939_ETP) {\n\t\tif (dat[3] != session->pkt.total)\n\t\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: strange total, %u != %u\\n\",\n\t\t\t\t     __func__, session, session->pkt.total,\n\t\t\t\t     dat[3]);\n\t\tsession->pkt.total = dat[3];\n\t\tsession->pkt.block = min(dat[3], dat[4]);\n\t}\n\n\tsession->pkt.rx = 0;\n\tsession->pkt.tx = 0;\n\n\tsession->tskey = priv->rx_tskey++;\n\tj1939_sk_errqueue(session, J1939_ERRQUEUE_RX_RTS);\n\n\tWARN_ON_ONCE(j1939_session_activate(session));\n\n\treturn session;\n}\n\nstatic int j1939_xtp_rx_rts_session_active(struct j1939_session *session,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_priv *priv = session->priv;\n\n\tif (!session->transmission) {\n\t\tif (j1939_xtp_rx_cmd_bad_pgn(session, skb))\n\t\t\treturn -EBUSY;\n\n\t\t \n\t\tj1939_session_timers_cancel(session);\n\t\tj1939_session_cancel(session, J1939_XTP_ABORT_BUSY);\n\t}\n\n\tif (session->last_cmd != 0) {\n\t\t \n\t\tnetdev_alert(priv->ndev, \"%s: 0x%p: connection exists (%02x %02x). last cmd: %x\\n\",\n\t\t\t     __func__, session, skcb->addr.sa, skcb->addr.da,\n\t\t\t     session->last_cmd);\n\n\t\tj1939_session_timers_cancel(session);\n\t\tj1939_session_cancel(session, J1939_XTP_ABORT_BUSY);\n\n\t\treturn -EBUSY;\n\t}\n\n\tif (session->skcb.addr.sa != skcb->addr.sa ||\n\t    session->skcb.addr.da != skcb->addr.da)\n\t\tnetdev_warn(priv->ndev, \"%s: 0x%p: session->skcb.addr.sa=0x%02x skcb->addr.sa=0x%02x session->skcb.addr.da=0x%02x skcb->addr.da=0x%02x\\n\",\n\t\t\t    __func__, session,\n\t\t\t    session->skcb.addr.sa, skcb->addr.sa,\n\t\t\t    session->skcb.addr.da, skcb->addr.da);\n\t \n\tsession->skcb.addr.sa = skcb->addr.sa;\n\tsession->skcb.addr.da = skcb->addr.da;\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\treturn 0;\n}\n\nstatic void j1939_xtp_rx_rts(struct j1939_priv *priv, struct sk_buff *skb,\n\t\t\t     bool transmitter)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_session *session;\n\tu8 cmd = skb->data[0];\n\n\tsession = j1939_session_get_by_addr(priv, &skcb->addr, false,\n\t\t\t\t\t    transmitter);\n\n\tif (!session) {\n\t\tif (transmitter) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\tsession = j1939_xtp_rx_rts_session_new(priv, skb);\n\t\tif (!session) {\n\t\t\tif (cmd == J1939_TP_CMD_BAM && j1939_sk_recv_match(priv, skcb))\n\t\t\t\tnetdev_info(priv->ndev, \"%s: failed to create TP BAM session\\n\",\n\t\t\t\t\t    __func__);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (j1939_xtp_rx_rts_session_active(session, skb)) {\n\t\t\tj1939_session_put(session);\n\t\t\treturn;\n\t\t}\n\t}\n\tsession->last_cmd = cmd;\n\n\tif (cmd == J1939_TP_CMD_BAM) {\n\t\tif (!session->transmission)\n\t\t\tj1939_tp_set_rxtimeout(session, 750);\n\t} else {\n\t\tif (!session->transmission) {\n\t\t\tj1939_session_txtimer_cancel(session);\n\t\t\tj1939_tp_schedule_txtimer(session, 0);\n\t\t}\n\t\tj1939_tp_set_rxtimeout(session, 1250);\n\t}\n\n\tj1939_session_put(session);\n}\n\nstatic void j1939_xtp_rx_dpo_one(struct j1939_session *session,\n\t\t\t\t struct sk_buff *skb)\n{\n\tconst u8 *dat = skb->data;\n\n\tif (j1939_xtp_rx_cmd_bad_pgn(session, skb))\n\t\treturn;\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\t \n\tsession->pkt.dpo = j1939_etp_ctl_to_packet(skb->data);\n\tsession->last_cmd = dat[0];\n\tj1939_tp_set_rxtimeout(session, 750);\n\n\tif (!session->transmission)\n\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_RX_DPO);\n}\n\nstatic void j1939_xtp_rx_dpo(struct j1939_priv *priv, struct sk_buff *skb,\n\t\t\t     bool transmitter)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_session *session;\n\n\tsession = j1939_session_get_by_addr(priv, &skcb->addr, false,\n\t\t\t\t\t    transmitter);\n\tif (!session) {\n\t\tnetdev_info(priv->ndev,\n\t\t\t    \"%s: no connection found\\n\", __func__);\n\t\treturn;\n\t}\n\n\tj1939_xtp_rx_dpo_one(session, skb);\n\tj1939_session_put(session);\n}\n\nstatic void j1939_xtp_rx_dat_one(struct j1939_session *session,\n\t\t\t\t struct sk_buff *skb)\n{\n\tenum j1939_xtp_abort abort = J1939_XTP_ABORT_FAULT;\n\tstruct j1939_priv *priv = session->priv;\n\tstruct j1939_sk_buff_cb *skcb, *se_skcb;\n\tstruct sk_buff *se_skb = NULL;\n\tconst u8 *dat;\n\tu8 *tpdat;\n\tint offset;\n\tint nbytes;\n\tbool final = false;\n\tbool remain = false;\n\tbool do_cts_eoma = false;\n\tint packet;\n\n\tskcb = j1939_skb_to_cb(skb);\n\tdat = skb->data;\n\tif (skb->len != 8) {\n\t\t \n\t\tabort = J1939_XTP_ABORT_UNEXPECTED_DATA;\n\t\tgoto out_session_cancel;\n\t}\n\n\tswitch (session->last_cmd) {\n\tcase 0xff:\n\t\tbreak;\n\tcase J1939_ETP_CMD_DPO:\n\t\tif (skcb->addr.type == J1939_ETP)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase J1939_TP_CMD_BAM:\n\t\tfallthrough;\n\tcase J1939_TP_CMD_CTS:\n\t\tif (skcb->addr.type != J1939_ETP)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tnetdev_info(priv->ndev, \"%s: 0x%p: last %02x\\n\", __func__,\n\t\t\t    session, session->last_cmd);\n\t\tgoto out_session_cancel;\n\t}\n\n\tpacket = (dat[0] - 1 + session->pkt.dpo);\n\tif (packet > session->pkt.total ||\n\t    (session->pkt.rx + 1) > session->pkt.total) {\n\t\tnetdev_info(priv->ndev, \"%s: 0x%p: should have been completed\\n\",\n\t\t\t    __func__, session);\n\t\tgoto out_session_cancel;\n\t}\n\n\tse_skb = j1939_session_skb_get_by_offset(session, packet * 7);\n\tif (!se_skb) {\n\t\tnetdev_warn(priv->ndev, \"%s: 0x%p: no skb found\\n\", __func__,\n\t\t\t    session);\n\t\tgoto out_session_cancel;\n\t}\n\n\tse_skcb = j1939_skb_to_cb(se_skb);\n\toffset = packet * 7 - se_skcb->offset;\n\tnbytes = se_skb->len - offset;\n\tif (nbytes > 7)\n\t\tnbytes = 7;\n\tif (nbytes <= 0 || (nbytes + 1) > skb->len) {\n\t\tnetdev_info(priv->ndev, \"%s: 0x%p: nbytes %i, len %i\\n\",\n\t\t\t    __func__, session, nbytes, skb->len);\n\t\tgoto out_session_cancel;\n\t}\n\n\ttpdat = se_skb->data;\n\tif (!session->transmission) {\n\t\tmemcpy(&tpdat[offset], &dat[1], nbytes);\n\t} else {\n\t\tint err;\n\n\t\terr = memcmp(&tpdat[offset], &dat[1], nbytes);\n\t\tif (err)\n\t\t\tnetdev_err_once(priv->ndev,\n\t\t\t\t\t\"%s: 0x%p: Data of RX-looped back packet (%*ph) doesn't match TX data (%*ph)!\\n\",\n\t\t\t\t\t__func__, session,\n\t\t\t\t\tnbytes, &dat[1],\n\t\t\t\t\tnbytes, &tpdat[offset]);\n\t}\n\n\tif (packet == session->pkt.rx)\n\t\tsession->pkt.rx++;\n\n\tif (se_skcb->addr.type != J1939_ETP &&\n\t    j1939_cb_is_broadcast(&session->skcb)) {\n\t\tif (session->pkt.rx >= session->pkt.total)\n\t\t\tfinal = true;\n\t\telse\n\t\t\tremain = true;\n\t} else {\n\t\t \n\t\tif (session->pkt.rx >= session->pkt.last)\n\t\t\tdo_cts_eoma = true;\n\t}\n\n\tif (final) {\n\t\tj1939_session_timers_cancel(session);\n\t\tj1939_session_completed(session);\n\t} else if (remain) {\n\t\tif (!session->transmission)\n\t\t\tj1939_tp_set_rxtimeout(session, 750);\n\t} else if (do_cts_eoma) {\n\t\tj1939_tp_set_rxtimeout(session, 1250);\n\t\tif (!session->transmission)\n\t\t\tj1939_tp_schedule_txtimer(session, 0);\n\t} else {\n\t\tj1939_tp_set_rxtimeout(session, 750);\n\t}\n\tsession->last_cmd = 0xff;\n\tconsume_skb(se_skb);\n\tj1939_session_put(session);\n\n\treturn;\n\n out_session_cancel:\n\tkfree_skb(se_skb);\n\tj1939_session_timers_cancel(session);\n\tj1939_session_cancel(session, abort);\n\tj1939_session_put(session);\n}\n\nstatic void j1939_xtp_rx_dat(struct j1939_priv *priv, struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb;\n\tstruct j1939_session *session;\n\n\tskcb = j1939_skb_to_cb(skb);\n\n\tif (j1939_tp_im_transmitter(skcb)) {\n\t\tsession = j1939_session_get_by_addr(priv, &skcb->addr, false,\n\t\t\t\t\t\t    true);\n\t\tif (!session)\n\t\t\tnetdev_info(priv->ndev, \"%s: no tx connection found\\n\",\n\t\t\t\t    __func__);\n\t\telse\n\t\t\tj1939_xtp_rx_dat_one(session, skb);\n\t}\n\n\tif (j1939_tp_im_receiver(skcb)) {\n\t\tsession = j1939_session_get_by_addr(priv, &skcb->addr, false,\n\t\t\t\t\t\t    false);\n\t\tif (!session)\n\t\t\tnetdev_info(priv->ndev, \"%s: no rx connection found\\n\",\n\t\t\t\t    __func__);\n\t\telse\n\t\t\tj1939_xtp_rx_dat_one(session, skb);\n\t}\n\n\tif (j1939_cb_is_broadcast(skcb)) {\n\t\tsession = j1939_session_get_by_addr(priv, &skcb->addr, false,\n\t\t\t\t\t\t    false);\n\t\tif (session)\n\t\t\tj1939_xtp_rx_dat_one(session, skb);\n\t}\n}\n\n \nstruct j1939_session *j1939_tp_send(struct j1939_priv *priv,\n\t\t\t\t    struct sk_buff *skb, size_t size)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_session *session;\n\tint ret;\n\n\tif (skcb->addr.pgn == J1939_TP_PGN_DAT ||\n\t    skcb->addr.pgn == J1939_TP_PGN_CTL ||\n\t    skcb->addr.pgn == J1939_ETP_PGN_DAT ||\n\t    skcb->addr.pgn == J1939_ETP_PGN_CTL)\n\t\t \n\t\treturn ERR_PTR(-EDOM);\n\n\tif (size > priv->tp_max_packet_size)\n\t\treturn ERR_PTR(-EMSGSIZE);\n\n\tif (size <= 8)\n\t\tskcb->addr.type = J1939_SIMPLE;\n\telse if (size > J1939_MAX_TP_PACKET_SIZE)\n\t\tskcb->addr.type = J1939_ETP;\n\telse\n\t\tskcb->addr.type = J1939_TP;\n\n\tif (skcb->addr.type == J1939_ETP &&\n\t    j1939_cb_is_broadcast(skcb))\n\t\treturn ERR_PTR(-EDESTADDRREQ);\n\n\t \n\tret = j1939_ac_fixup(priv, skb);\n\tif (unlikely(ret))\n\t\treturn ERR_PTR(ret);\n\n\t \n\tif (j1939_address_is_unicast(skcb->addr.da) &&\n\t    priv->ents[skcb->addr.da].nusers)\n\t\tskcb->flags |= J1939_ECU_LOCAL_DST;\n\n\t \n\tskcb->flags |= J1939_ECU_LOCAL_SRC;\n\n\t \n\tsession = j1939_session_new(priv, skb, size);\n\tif (!session)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tsock_hold(skb->sk);\n\tsession->sk = skb->sk;\n\tsession->transmission = true;\n\tsession->pkt.total = (size + 6) / 7;\n\tsession->pkt.block = skcb->addr.type == J1939_ETP ? 255 :\n\t\tmin(j1939_tp_block ?: 255, session->pkt.total);\n\n\tif (j1939_cb_is_broadcast(&session->skcb))\n\t\t \n\t\tsession->pkt.last = session->pkt.total;\n\n\tskcb->tskey = atomic_inc_return(&session->sk->sk_tskey) - 1;\n\tsession->tskey = skcb->tskey;\n\n\treturn session;\n}\n\nstatic void j1939_tp_cmd_recv(struct j1939_priv *priv, struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tint extd = J1939_TP;\n\tu8 cmd = skb->data[0];\n\n\tswitch (cmd) {\n\tcase J1939_ETP_CMD_RTS:\n\t\textd = J1939_ETP;\n\t\tfallthrough;\n\tcase J1939_TP_CMD_BAM:\n\t\tif (cmd == J1939_TP_CMD_BAM && !j1939_cb_is_broadcast(skcb)) {\n\t\t\tnetdev_err_once(priv->ndev, \"%s: BAM to unicast (%02x), ignoring!\\n\",\n\t\t\t\t\t__func__, skcb->addr.sa);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase J1939_TP_CMD_RTS:\n\t\tif (skcb->addr.type != extd)\n\t\t\treturn;\n\n\t\tif (cmd == J1939_TP_CMD_RTS && j1939_cb_is_broadcast(skcb)) {\n\t\t\tnetdev_alert(priv->ndev, \"%s: rts without destination (%02x)\\n\",\n\t\t\t\t     __func__, skcb->addr.sa);\n\t\t\treturn;\n\t\t}\n\n\t\tif (j1939_tp_im_transmitter(skcb))\n\t\t\tj1939_xtp_rx_rts(priv, skb, true);\n\n\t\tif (j1939_tp_im_receiver(skcb) || j1939_cb_is_broadcast(skcb))\n\t\t\tj1939_xtp_rx_rts(priv, skb, false);\n\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_CTS:\n\t\textd = J1939_ETP;\n\t\tfallthrough;\n\tcase J1939_TP_CMD_CTS:\n\t\tif (skcb->addr.type != extd)\n\t\t\treturn;\n\n\t\tif (j1939_tp_im_transmitter(skcb))\n\t\t\tj1939_xtp_rx_cts(priv, skb, false);\n\n\t\tif (j1939_tp_im_receiver(skcb))\n\t\t\tj1939_xtp_rx_cts(priv, skb, true);\n\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_DPO:\n\t\tif (skcb->addr.type != J1939_ETP)\n\t\t\treturn;\n\n\t\tif (j1939_tp_im_transmitter(skcb))\n\t\t\tj1939_xtp_rx_dpo(priv, skb, true);\n\n\t\tif (j1939_tp_im_receiver(skcb))\n\t\t\tj1939_xtp_rx_dpo(priv, skb, false);\n\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_EOMA:\n\t\textd = J1939_ETP;\n\t\tfallthrough;\n\tcase J1939_TP_CMD_EOMA:\n\t\tif (skcb->addr.type != extd)\n\t\t\treturn;\n\n\t\tif (j1939_tp_im_transmitter(skcb))\n\t\t\tj1939_xtp_rx_eoma(priv, skb, false);\n\n\t\tif (j1939_tp_im_receiver(skcb))\n\t\t\tj1939_xtp_rx_eoma(priv, skb, true);\n\n\t\tbreak;\n\n\tcase J1939_ETP_CMD_ABORT:  \n\t\tif (j1939_cb_is_broadcast(skcb)) {\n\t\t\tnetdev_err_once(priv->ndev, \"%s: abort to broadcast (%02x), ignoring!\\n\",\n\t\t\t\t\t__func__, skcb->addr.sa);\n\t\t\treturn;\n\t\t}\n\n\t\tif (j1939_tp_im_transmitter(skcb))\n\t\t\tj1939_xtp_rx_abort(priv, skb, true);\n\n\t\tif (j1939_tp_im_receiver(skcb))\n\t\t\tj1939_xtp_rx_abort(priv, skb, false);\n\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\nint j1939_tp_recv(struct j1939_priv *priv, struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\n\tif (!j1939_tp_im_involved_anydir(skcb) && !j1939_cb_is_broadcast(skcb))\n\t\treturn 0;\n\n\tswitch (skcb->addr.pgn) {\n\tcase J1939_ETP_PGN_DAT:\n\t\tskcb->addr.type = J1939_ETP;\n\t\tfallthrough;\n\tcase J1939_TP_PGN_DAT:\n\t\tj1939_xtp_rx_dat(priv, skb);\n\t\tbreak;\n\n\tcase J1939_ETP_PGN_CTL:\n\t\tskcb->addr.type = J1939_ETP;\n\t\tfallthrough;\n\tcase J1939_TP_PGN_CTL:\n\t\tif (skb->len < 8)\n\t\t\treturn 0;  \n\n\t\tj1939_tp_cmd_recv(priv, skb);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;  \n\t}\n\treturn 1;  \n}\n\nvoid j1939_simple_recv(struct j1939_priv *priv, struct sk_buff *skb)\n{\n\tstruct j1939_session *session;\n\n\tif (!skb->sk)\n\t\treturn;\n\n\tif (skb->sk->sk_family != AF_CAN ||\n\t    skb->sk->sk_protocol != CAN_J1939)\n\t\treturn;\n\n\tj1939_session_list_lock(priv);\n\tsession = j1939_session_get_simple(priv, skb);\n\tj1939_session_list_unlock(priv);\n\tif (!session) {\n\t\tnetdev_warn(priv->ndev,\n\t\t\t    \"%s: Received already invalidated message\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tj1939_session_timers_cancel(session);\n\tj1939_session_deactivate(session);\n\tj1939_session_put(session);\n}\n\nint j1939_cancel_active_session(struct j1939_priv *priv, struct sock *sk)\n{\n\tstruct j1939_session *session, *saved;\n\n\tnetdev_dbg(priv->ndev, \"%s, sk: %p\\n\", __func__, sk);\n\tj1939_session_list_lock(priv);\n\tlist_for_each_entry_safe(session, saved,\n\t\t\t\t &priv->active_session_list,\n\t\t\t\t active_session_list_entry) {\n\t\tif (!sk || sk == session->sk) {\n\t\t\tif (hrtimer_try_to_cancel(&session->txtimer) == 1)\n\t\t\t\tj1939_session_put(session);\n\t\t\tif (hrtimer_try_to_cancel(&session->rxtimer) == 1)\n\t\t\t\tj1939_session_put(session);\n\n\t\t\tsession->err = ESHUTDOWN;\n\t\t\tj1939_session_deactivate_locked(session);\n\t\t}\n\t}\n\tj1939_session_list_unlock(priv);\n\treturn NOTIFY_DONE;\n}\n\nvoid j1939_tp_init(struct j1939_priv *priv)\n{\n\tspin_lock_init(&priv->active_session_list_lock);\n\tINIT_LIST_HEAD(&priv->active_session_list);\n\tpriv->tp_max_packet_size = J1939_MAX_ETP_PACKET_SIZE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}