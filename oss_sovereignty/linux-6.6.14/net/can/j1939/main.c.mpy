{
  "module_name": "main.c",
  "hash_id": "2fe796f684a835f9c8608afd0b8b44f5dd37c102db5bf86d8c47deb9af386fda",
  "original_prompt": "Ingested from linux-6.6.14/net/can/j1939/main.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/can/can-ml.h>\n#include <linux/can/core.h>\n#include <linux/can/skb.h>\n#include <linux/if_arp.h>\n#include <linux/module.h>\n\n#include \"j1939-priv.h\"\n\nMODULE_DESCRIPTION(\"PF_CAN SAE J1939\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"EIA Electronics (Kurt Van Dijck & Pieter Beyens)\");\nMODULE_ALIAS(\"can-proto-\" __stringify(CAN_J1939));\n\n \n\n \n#define J1939_CAN_HDR (offsetof(struct can_frame, data))\n\n \n#define J1939_CAN_FTR (sizeof(struct can_frame) - J1939_CAN_HDR - \\\n\t\t sizeof(((struct can_frame *)0)->data))\n\n \nstatic void j1939_can_recv(struct sk_buff *iskb, void *data)\n{\n\tstruct j1939_priv *priv = data;\n\tstruct sk_buff *skb;\n\tstruct j1939_sk_buff_cb *skcb, *iskcb;\n\tstruct can_frame *cf;\n\n\t \n\tif (!can_is_can_skb(iskb))\n\t\treturn;\n\n\t \n\tskb = skb_clone(iskb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tj1939_priv_get(priv);\n\tcan_skb_set_owner(skb, iskb->sk);\n\n\t \n\tcf = (void *)skb->data;\n\tskb_pull(skb, J1939_CAN_HDR);\n\n\t \n\tskb_trim(skb, min_t(uint8_t, cf->len, 8));\n\n\t \n\tskcb = j1939_skb_to_cb(skb);\n\tmemset(skcb, 0, sizeof(*skcb));\n\n\tiskcb = j1939_skb_to_cb(iskb);\n\tskcb->tskey = iskcb->tskey;\n\tskcb->priority = (cf->can_id >> 26) & 0x7;\n\tskcb->addr.sa = cf->can_id;\n\tskcb->addr.pgn = (cf->can_id >> 8) & J1939_PGN_MAX;\n\t \n\tskcb->addr.type = J1939_TP;\n\n\tif (!j1939_address_is_valid(skcb->addr.sa)) {\n\t\tnetdev_err_once(priv->ndev, \"%s: sa is broadcast address, ignoring!\\n\",\n\t\t\t\t__func__);\n\t\tgoto done;\n\t}\n\n\tif (j1939_pgn_is_pdu1(skcb->addr.pgn)) {\n\t\t \n\t\tskcb->addr.da = skcb->addr.pgn;\n\t\t \n\t\tskcb->addr.pgn &= 0x3ff00;\n\t} else {\n\t\t \n\t\tskcb->addr.da = J1939_NO_ADDR;\n\t}\n\n\t \n\tread_lock_bh(&priv->lock);\n\tif (j1939_address_is_unicast(skcb->addr.sa) &&\n\t    priv->ents[skcb->addr.sa].nusers)\n\t\tskcb->flags |= J1939_ECU_LOCAL_SRC;\n\tif (j1939_address_is_unicast(skcb->addr.da) &&\n\t    priv->ents[skcb->addr.da].nusers)\n\t\tskcb->flags |= J1939_ECU_LOCAL_DST;\n\tread_unlock_bh(&priv->lock);\n\n\t \n\tj1939_ac_recv(priv, skb);\n\n\tif (j1939_tp_recv(priv, skb))\n\t\t \n\t\tgoto done;\n\n\tj1939_simple_recv(priv, skb);\n\tj1939_sk_recv(priv, skb);\n done:\n\tj1939_priv_put(priv);\n\tkfree_skb(skb);\n}\n\n \n\n \n#define J1939_CAN_ID CAN_EFF_FLAG\n#define J1939_CAN_MASK (CAN_EFF_FLAG | CAN_RTR_FLAG)\n\nstatic DEFINE_MUTEX(j1939_netdev_lock);\n\nstatic struct j1939_priv *j1939_priv_create(struct net_device *ndev)\n{\n\tstruct j1939_priv *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\n\trwlock_init(&priv->lock);\n\tINIT_LIST_HEAD(&priv->ecus);\n\tpriv->ndev = ndev;\n\tkref_init(&priv->kref);\n\tkref_init(&priv->rx_kref);\n\tdev_hold(ndev);\n\n\tnetdev_dbg(priv->ndev, \"%s : 0x%p\\n\", __func__, priv);\n\n\treturn priv;\n}\n\nstatic inline void j1939_priv_set(struct net_device *ndev,\n\t\t\t\t  struct j1939_priv *priv)\n{\n\tstruct can_ml_priv *can_ml = can_get_ml_priv(ndev);\n\n\tcan_ml->j1939_priv = priv;\n}\n\nstatic void __j1939_priv_release(struct kref *kref)\n{\n\tstruct j1939_priv *priv = container_of(kref, struct j1939_priv, kref);\n\tstruct net_device *ndev = priv->ndev;\n\n\tnetdev_dbg(priv->ndev, \"%s: 0x%p\\n\", __func__, priv);\n\n\tWARN_ON_ONCE(!list_empty(&priv->active_session_list));\n\tWARN_ON_ONCE(!list_empty(&priv->ecus));\n\tWARN_ON_ONCE(!list_empty(&priv->j1939_socks));\n\n\tdev_put(ndev);\n\tkfree(priv);\n}\n\nvoid j1939_priv_put(struct j1939_priv *priv)\n{\n\tkref_put(&priv->kref, __j1939_priv_release);\n}\n\nvoid j1939_priv_get(struct j1939_priv *priv)\n{\n\tkref_get(&priv->kref);\n}\n\nstatic int j1939_can_rx_register(struct j1939_priv *priv)\n{\n\tstruct net_device *ndev = priv->ndev;\n\tint ret;\n\n\tj1939_priv_get(priv);\n\tret = can_rx_register(dev_net(ndev), ndev, J1939_CAN_ID, J1939_CAN_MASK,\n\t\t\t      j1939_can_recv, priv, \"j1939\", NULL);\n\tif (ret < 0) {\n\t\tj1939_priv_put(priv);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void j1939_can_rx_unregister(struct j1939_priv *priv)\n{\n\tstruct net_device *ndev = priv->ndev;\n\n\tcan_rx_unregister(dev_net(ndev), ndev, J1939_CAN_ID, J1939_CAN_MASK,\n\t\t\t  j1939_can_recv, priv);\n\n\t \n\tj1939_priv_put(priv);\n}\n\nstatic void __j1939_rx_release(struct kref *kref)\n\t__releases(&j1939_netdev_lock)\n{\n\tstruct j1939_priv *priv = container_of(kref, struct j1939_priv,\n\t\t\t\t\t       rx_kref);\n\n\tj1939_can_rx_unregister(priv);\n\tj1939_ecu_unmap_all(priv);\n\tj1939_priv_set(priv->ndev, NULL);\n\tmutex_unlock(&j1939_netdev_lock);\n}\n\n \nstatic inline struct j1939_priv *j1939_ndev_to_priv(struct net_device *ndev)\n{\n\tstruct can_ml_priv *can_ml = can_get_ml_priv(ndev);\n\n\treturn can_ml->j1939_priv;\n}\n\nstatic struct j1939_priv *j1939_priv_get_by_ndev_locked(struct net_device *ndev)\n{\n\tstruct j1939_priv *priv;\n\n\tlockdep_assert_held(&j1939_netdev_lock);\n\n\tpriv = j1939_ndev_to_priv(ndev);\n\tif (priv)\n\t\tj1939_priv_get(priv);\n\n\treturn priv;\n}\n\nstatic struct j1939_priv *j1939_priv_get_by_ndev(struct net_device *ndev)\n{\n\tstruct j1939_priv *priv;\n\n\tmutex_lock(&j1939_netdev_lock);\n\tpriv = j1939_priv_get_by_ndev_locked(ndev);\n\tmutex_unlock(&j1939_netdev_lock);\n\n\treturn priv;\n}\n\nstruct j1939_priv *j1939_netdev_start(struct net_device *ndev)\n{\n\tstruct j1939_priv *priv, *priv_new;\n\tint ret;\n\n\tmutex_lock(&j1939_netdev_lock);\n\tpriv = j1939_priv_get_by_ndev_locked(ndev);\n\tif (priv) {\n\t\tkref_get(&priv->rx_kref);\n\t\tmutex_unlock(&j1939_netdev_lock);\n\t\treturn priv;\n\t}\n\tmutex_unlock(&j1939_netdev_lock);\n\n\tpriv = j1939_priv_create(ndev);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tj1939_tp_init(priv);\n\tspin_lock_init(&priv->j1939_socks_lock);\n\tINIT_LIST_HEAD(&priv->j1939_socks);\n\n\tmutex_lock(&j1939_netdev_lock);\n\tpriv_new = j1939_priv_get_by_ndev_locked(ndev);\n\tif (priv_new) {\n\t\t \n\t\tkref_get(&priv_new->rx_kref);\n\t\tmutex_unlock(&j1939_netdev_lock);\n\t\tdev_put(ndev);\n\t\tkfree(priv);\n\t\treturn priv_new;\n\t}\n\tj1939_priv_set(ndev, priv);\n\n\tret = j1939_can_rx_register(priv);\n\tif (ret < 0)\n\t\tgoto out_priv_put;\n\n\tmutex_unlock(&j1939_netdev_lock);\n\treturn priv;\n\n out_priv_put:\n\tj1939_priv_set(ndev, NULL);\n\tmutex_unlock(&j1939_netdev_lock);\n\n\tdev_put(ndev);\n\tkfree(priv);\n\n\treturn ERR_PTR(ret);\n}\n\nvoid j1939_netdev_stop(struct j1939_priv *priv)\n{\n\tkref_put_mutex(&priv->rx_kref, __j1939_rx_release, &j1939_netdev_lock);\n\tj1939_priv_put(priv);\n}\n\nint j1939_send_one(struct j1939_priv *priv, struct sk_buff *skb)\n{\n\tint ret, dlc;\n\tcanid_t canid;\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct can_frame *cf;\n\n\t \n\tif (j1939_pgn_is_pdu1(skcb->addr.pgn))\n\t\tskcb->addr.pgn &= J1939_PGN_PDU1_MAX;\n\telse\n\t\tskcb->addr.pgn &= J1939_PGN_MAX;\n\n\tif (skcb->priority > 7)\n\t\tskcb->priority = 6;\n\n\tret = j1939_ac_fixup(priv, skb);\n\tif (unlikely(ret))\n\t\tgoto failed;\n\tdlc = skb->len;\n\n\t \n\tcf = skb_push(skb, J1939_CAN_HDR);\n\n\t \n\tmemset(cf, 0, J1939_CAN_HDR);\n\n\t \n\tskb_put(skb, J1939_CAN_FTR + (8 - dlc));\n\n\tcanid = CAN_EFF_FLAG |\n\t\t(skcb->priority << 26) |\n\t\t(skcb->addr.pgn << 8) |\n\t\tskcb->addr.sa;\n\tif (j1939_pgn_is_pdu1(skcb->addr.pgn))\n\t\tcanid |= skcb->addr.da << 8;\n\n\tcf->can_id = canid;\n\tcf->len = dlc;\n\n\treturn can_send(skb, 1);\n\n failed:\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic int j1939_netdev_notify(struct notifier_block *nb,\n\t\t\t       unsigned long msg, void *data)\n{\n\tstruct net_device *ndev = netdev_notifier_info_to_dev(data);\n\tstruct can_ml_priv *can_ml = can_get_ml_priv(ndev);\n\tstruct j1939_priv *priv;\n\n\tif (!can_ml)\n\t\tgoto notify_done;\n\n\tpriv = j1939_priv_get_by_ndev(ndev);\n\tif (!priv)\n\t\tgoto notify_done;\n\n\tswitch (msg) {\n\tcase NETDEV_DOWN:\n\t\tj1939_cancel_active_session(priv, NULL);\n\t\tj1939_sk_netdev_event_netdown(priv);\n\t\tj1939_ecu_unmap_all(priv);\n\t\tbreak;\n\t}\n\n\tj1939_priv_put(priv);\n\nnotify_done:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block j1939_netdev_notifier = {\n\t.notifier_call = j1939_netdev_notify,\n};\n\n \nstatic __init int j1939_module_init(void)\n{\n\tint ret;\n\n\tpr_info(\"can: SAE J1939\\n\");\n\n\tret = register_netdevice_notifier(&j1939_netdev_notifier);\n\tif (ret)\n\t\tgoto fail_notifier;\n\n\tret = can_proto_register(&j1939_can_proto);\n\tif (ret < 0) {\n\t\tpr_err(\"can: registration of j1939 protocol failed\\n\");\n\t\tgoto fail_sk;\n\t}\n\n\treturn 0;\n\n fail_sk:\n\tunregister_netdevice_notifier(&j1939_netdev_notifier);\n fail_notifier:\n\treturn ret;\n}\n\nstatic __exit void j1939_module_exit(void)\n{\n\tcan_proto_unregister(&j1939_can_proto);\n\n\tunregister_netdevice_notifier(&j1939_netdev_notifier);\n}\n\nmodule_init(j1939_module_init);\nmodule_exit(j1939_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}