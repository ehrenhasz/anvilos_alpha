{
  "module_name": "address-claim.c",
  "hash_id": "f614f8a2e3c99fb59e1fd0c3333a97cd201327b892d877fff6d11ecf1fa78633",
  "original_prompt": "Ingested from linux-6.6.14/net/can/j1939/address-claim.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n\n#include \"j1939-priv.h\"\n\nstatic inline name_t j1939_skb_to_name(const struct sk_buff *skb)\n{\n\treturn le64_to_cpup((__le64 *)skb->data);\n}\n\nstatic inline bool j1939_ac_msg_is_request(struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tint req_pgn;\n\n\tif (skb->len < 3 || skcb->addr.pgn != J1939_PGN_REQUEST)\n\t\treturn false;\n\n\treq_pgn = skb->data[0] | (skb->data[1] << 8) | (skb->data[2] << 16);\n\n\treturn req_pgn == J1939_PGN_ADDRESS_CLAIMED;\n}\n\nstatic int j1939_ac_verify_outgoing(struct j1939_priv *priv,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\n\tif (skb->len != 8) {\n\t\tnetdev_notice(priv->ndev, \"tx address claim with dlc %i\\n\",\n\t\t\t      skb->len);\n\t\treturn -EPROTO;\n\t}\n\n\tif (skcb->addr.src_name != j1939_skb_to_name(skb)) {\n\t\tnetdev_notice(priv->ndev, \"tx address claim with different name\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\tif (skcb->addr.sa == J1939_NO_ADDR) {\n\t\tnetdev_notice(priv->ndev, \"tx address claim with broadcast sa\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tif (skcb->addr.dst_name || skcb->addr.da != J1939_NO_ADDR) {\n\t\tnetdev_notice(priv->ndev, \"tx address claim with dest, not broadcast\\n\");\n\t\treturn -EPROTO;\n\t}\n\treturn 0;\n}\n\nint j1939_ac_fixup(struct j1939_priv *priv, struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tint ret;\n\tu8 addr;\n\n\t \n\tif (skcb->addr.pgn == J1939_PGN_ADDRESS_CLAIMED) {\n\t\tstruct j1939_ecu *ecu;\n\n\t\tret = j1939_ac_verify_outgoing(priv, skb);\n\t\t \n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tecu = j1939_ecu_get_by_name(priv, skcb->addr.src_name);\n\t\tif (!ecu)\n\t\t\treturn -ENODEV;\n\n\t\tif (ecu->addr != skcb->addr.sa)\n\t\t\t \n\t\t\tj1939_ecu_unmap(ecu);\n\t\tj1939_ecu_put(ecu);\n\t} else if (skcb->addr.src_name) {\n\t\t \n\t\taddr = j1939_name_to_addr(priv, skcb->addr.src_name);\n\t\tif (!j1939_address_is_unicast(addr) &&\n\t\t    !j1939_ac_msg_is_request(skb)) {\n\t\t\tnetdev_notice(priv->ndev, \"tx drop: invalid sa for name 0x%016llx\\n\",\n\t\t\t\t      skcb->addr.src_name);\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t\tskcb->addr.sa = addr;\n\t}\n\n\t \n\tif (skcb->addr.dst_name) {\n\t\taddr = j1939_name_to_addr(priv, skcb->addr.dst_name);\n\t\tif (!j1939_address_is_unicast(addr)) {\n\t\t\tnetdev_notice(priv->ndev, \"tx drop: invalid da for name 0x%016llx\\n\",\n\t\t\t\t      skcb->addr.dst_name);\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t\tskcb->addr.da = addr;\n\t}\n\treturn 0;\n}\n\nstatic void j1939_ac_process(struct j1939_priv *priv, struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_ecu *ecu, *prev;\n\tname_t name;\n\n\tif (skb->len != 8) {\n\t\tnetdev_notice(priv->ndev, \"rx address claim with wrong dlc %i\\n\",\n\t\t\t      skb->len);\n\t\treturn;\n\t}\n\n\tname = j1939_skb_to_name(skb);\n\tskcb->addr.src_name = name;\n\tif (!name) {\n\t\tnetdev_notice(priv->ndev, \"rx address claim without name\\n\");\n\t\treturn;\n\t}\n\n\tif (!j1939_address_is_valid(skcb->addr.sa)) {\n\t\tnetdev_notice(priv->ndev, \"rx address claim with broadcast sa\\n\");\n\t\treturn;\n\t}\n\n\twrite_lock_bh(&priv->lock);\n\n\t \n\tecu = j1939_ecu_get_by_name_locked(priv, name);\n\n\tif (ecu && ecu->addr == skcb->addr.sa) {\n\t\t \n\t\tgoto out_ecu_put;\n\t}\n\n\tif (!ecu && j1939_address_is_unicast(skcb->addr.sa))\n\t\tecu = j1939_ecu_create_locked(priv, name);\n\n\tif (IS_ERR_OR_NULL(ecu))\n\t\tgoto out_unlock_bh;\n\n\t \n\tj1939_ecu_timer_cancel(ecu);\n\n\tif (j1939_address_is_idle(skcb->addr.sa)) {\n\t\tj1939_ecu_unmap_locked(ecu);\n\t\tgoto out_ecu_put;\n\t}\n\n\t \n\tif (ecu->addr != skcb->addr.sa)\n\t\tj1939_ecu_unmap_locked(ecu);\n\tecu->addr = skcb->addr.sa;\n\n\tprev = j1939_ecu_get_by_addr_locked(priv, skcb->addr.sa);\n\tif (prev) {\n\t\tif (ecu->name > prev->name) {\n\t\t\tj1939_ecu_unmap_locked(ecu);\n\t\t\tj1939_ecu_put(prev);\n\t\t\tgoto out_ecu_put;\n\t\t} else {\n\t\t\t \n\t\t\tj1939_ecu_unmap_locked(prev);\n\t\t\tj1939_ecu_put(prev);\n\t\t}\n\t}\n\n\tj1939_ecu_timer_start(ecu);\n out_ecu_put:\n\tj1939_ecu_put(ecu);\n out_unlock_bh:\n\twrite_unlock_bh(&priv->lock);\n}\n\nvoid j1939_ac_recv(struct j1939_priv *priv, struct sk_buff *skb)\n{\n\tstruct j1939_sk_buff_cb *skcb = j1939_skb_to_cb(skb);\n\tstruct j1939_ecu *ecu;\n\n\t \n\tif (skcb->addr.pgn == J1939_PGN_ADDRESS_CLAIMED) {\n\t\tj1939_ac_process(priv, skb);\n\t} else if (j1939_address_is_unicast(skcb->addr.sa)) {\n\t\t \n\t\tecu = j1939_ecu_get_by_addr(priv, skcb->addr.sa);\n\t\tif (ecu) {\n\t\t\tskcb->addr.src_name = ecu->name;\n\t\t\tj1939_ecu_put(ecu);\n\t\t}\n\t}\n\n\t \n\tecu = j1939_ecu_get_by_addr(priv, skcb->addr.da);\n\tif (ecu) {\n\t\tskcb->addr.dst_name = ecu->name;\n\t\tj1939_ecu_put(ecu);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}