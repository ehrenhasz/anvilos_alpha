{
  "module_name": "bus.c",
  "hash_id": "fa336042201980906a2b40206c023e6544683ca51069790c36824ac4e745af1c",
  "original_prompt": "Ingested from linux-6.6.14/net/can/j1939/bus.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n \n\n#include <net/sock.h>\n\n#include \"j1939-priv.h\"\n\nstatic void __j1939_ecu_release(struct kref *kref)\n{\n\tstruct j1939_ecu *ecu = container_of(kref, struct j1939_ecu, kref);\n\tstruct j1939_priv *priv = ecu->priv;\n\n\tlist_del(&ecu->list);\n\tkfree(ecu);\n\tj1939_priv_put(priv);\n}\n\nvoid j1939_ecu_put(struct j1939_ecu *ecu)\n{\n\tkref_put(&ecu->kref, __j1939_ecu_release);\n}\n\nstatic void j1939_ecu_get(struct j1939_ecu *ecu)\n{\n\tkref_get(&ecu->kref);\n}\n\nstatic bool j1939_ecu_is_mapped_locked(struct j1939_ecu *ecu)\n{\n\tstruct j1939_priv *priv = ecu->priv;\n\n\tlockdep_assert_held(&priv->lock);\n\n\treturn j1939_ecu_find_by_addr_locked(priv, ecu->addr) == ecu;\n}\n\n \n \nstatic void j1939_ecu_map_locked(struct j1939_ecu *ecu)\n{\n\tstruct j1939_priv *priv = ecu->priv;\n\tstruct j1939_addr_ent *ent;\n\n\tlockdep_assert_held(&priv->lock);\n\n\tif (!j1939_address_is_unicast(ecu->addr))\n\t\treturn;\n\n\tent = &priv->ents[ecu->addr];\n\n\tif (ent->ecu) {\n\t\tnetdev_warn(priv->ndev, \"Trying to map already mapped ECU, addr: 0x%02x, name: 0x%016llx. Skip it.\\n\",\n\t\t\t    ecu->addr, ecu->name);\n\t\treturn;\n\t}\n\n\tj1939_ecu_get(ecu);\n\tent->ecu = ecu;\n\tent->nusers += ecu->nusers;\n}\n\n \nvoid j1939_ecu_unmap_locked(struct j1939_ecu *ecu)\n{\n\tstruct j1939_priv *priv = ecu->priv;\n\tstruct j1939_addr_ent *ent;\n\n\tlockdep_assert_held(&priv->lock);\n\n\tif (!j1939_address_is_unicast(ecu->addr))\n\t\treturn;\n\n\tif (!j1939_ecu_is_mapped_locked(ecu))\n\t\treturn;\n\n\tent = &priv->ents[ecu->addr];\n\tent->ecu = NULL;\n\tent->nusers -= ecu->nusers;\n\tj1939_ecu_put(ecu);\n}\n\nvoid j1939_ecu_unmap(struct j1939_ecu *ecu)\n{\n\twrite_lock_bh(&ecu->priv->lock);\n\tj1939_ecu_unmap_locked(ecu);\n\twrite_unlock_bh(&ecu->priv->lock);\n}\n\nvoid j1939_ecu_unmap_all(struct j1939_priv *priv)\n{\n\tint i;\n\n\twrite_lock_bh(&priv->lock);\n\tfor (i = 0; i < ARRAY_SIZE(priv->ents); i++)\n\t\tif (priv->ents[i].ecu)\n\t\t\tj1939_ecu_unmap_locked(priv->ents[i].ecu);\n\twrite_unlock_bh(&priv->lock);\n}\n\nvoid j1939_ecu_timer_start(struct j1939_ecu *ecu)\n{\n\t \n\tj1939_ecu_get(ecu);\n\n\t \n\thrtimer_start(&ecu->ac_timer, ms_to_ktime(250),\n\t\t      HRTIMER_MODE_REL_SOFT);\n}\n\nvoid j1939_ecu_timer_cancel(struct j1939_ecu *ecu)\n{\n\tif (hrtimer_cancel(&ecu->ac_timer))\n\t\tj1939_ecu_put(ecu);\n}\n\nstatic enum hrtimer_restart j1939_ecu_timer_handler(struct hrtimer *hrtimer)\n{\n\tstruct j1939_ecu *ecu =\n\t\tcontainer_of(hrtimer, struct j1939_ecu, ac_timer);\n\tstruct j1939_priv *priv = ecu->priv;\n\n\twrite_lock_bh(&priv->lock);\n\t \n\tj1939_ecu_map_locked(ecu);\n\n\t \n\tj1939_ecu_put(ecu);\n\twrite_unlock_bh(&priv->lock);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstruct j1939_ecu *j1939_ecu_create_locked(struct j1939_priv *priv, name_t name)\n{\n\tstruct j1939_ecu *ecu;\n\n\tlockdep_assert_held(&priv->lock);\n\n\tecu = kzalloc(sizeof(*ecu), gfp_any());\n\tif (!ecu)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&ecu->kref);\n\tecu->addr = J1939_IDLE_ADDR;\n\tecu->name = name;\n\n\thrtimer_init(&ecu->ac_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_SOFT);\n\tecu->ac_timer.function = j1939_ecu_timer_handler;\n\tINIT_LIST_HEAD(&ecu->list);\n\n\tj1939_priv_get(priv);\n\tecu->priv = priv;\n\tlist_add_tail(&ecu->list, &priv->ecus);\n\n\treturn ecu;\n}\n\nstruct j1939_ecu *j1939_ecu_find_by_addr_locked(struct j1939_priv *priv,\n\t\t\t\t\t\tu8 addr)\n{\n\tlockdep_assert_held(&priv->lock);\n\n\treturn priv->ents[addr].ecu;\n}\n\nstruct j1939_ecu *j1939_ecu_get_by_addr_locked(struct j1939_priv *priv, u8 addr)\n{\n\tstruct j1939_ecu *ecu;\n\n\tlockdep_assert_held(&priv->lock);\n\n\tif (!j1939_address_is_unicast(addr))\n\t\treturn NULL;\n\n\tecu = j1939_ecu_find_by_addr_locked(priv, addr);\n\tif (ecu)\n\t\tj1939_ecu_get(ecu);\n\n\treturn ecu;\n}\n\nstruct j1939_ecu *j1939_ecu_get_by_addr(struct j1939_priv *priv, u8 addr)\n{\n\tstruct j1939_ecu *ecu;\n\n\tread_lock_bh(&priv->lock);\n\tecu = j1939_ecu_get_by_addr_locked(priv, addr);\n\tread_unlock_bh(&priv->lock);\n\n\treturn ecu;\n}\n\n \nstatic struct j1939_ecu *j1939_ecu_find_by_name_locked(struct j1939_priv *priv,\n\t\t\t\t\t\t       name_t name)\n{\n\tstruct j1939_ecu *ecu;\n\n\tlockdep_assert_held(&priv->lock);\n\n\tlist_for_each_entry(ecu, &priv->ecus, list) {\n\t\tif (ecu->name == name)\n\t\t\treturn ecu;\n\t}\n\n\treturn NULL;\n}\n\nstruct j1939_ecu *j1939_ecu_get_by_name_locked(struct j1939_priv *priv,\n\t\t\t\t\t       name_t name)\n{\n\tstruct j1939_ecu *ecu;\n\n\tlockdep_assert_held(&priv->lock);\n\n\tif (!name)\n\t\treturn NULL;\n\n\tecu = j1939_ecu_find_by_name_locked(priv, name);\n\tif (ecu)\n\t\tj1939_ecu_get(ecu);\n\n\treturn ecu;\n}\n\nstruct j1939_ecu *j1939_ecu_get_by_name(struct j1939_priv *priv, name_t name)\n{\n\tstruct j1939_ecu *ecu;\n\n\tread_lock_bh(&priv->lock);\n\tecu = j1939_ecu_get_by_name_locked(priv, name);\n\tread_unlock_bh(&priv->lock);\n\n\treturn ecu;\n}\n\nu8 j1939_name_to_addr(struct j1939_priv *priv, name_t name)\n{\n\tstruct j1939_ecu *ecu;\n\tint addr = J1939_IDLE_ADDR;\n\n\tif (!name)\n\t\treturn J1939_NO_ADDR;\n\n\tread_lock_bh(&priv->lock);\n\tecu = j1939_ecu_find_by_name_locked(priv, name);\n\tif (ecu && j1939_ecu_is_mapped_locked(ecu))\n\t\t \n\t\taddr = ecu->addr;\n\n\tread_unlock_bh(&priv->lock);\n\n\treturn addr;\n}\n\n \n\nint j1939_local_ecu_get(struct j1939_priv *priv, name_t name, u8 sa)\n{\n\tstruct j1939_ecu *ecu;\n\tint err = 0;\n\n\twrite_lock_bh(&priv->lock);\n\n\tif (j1939_address_is_unicast(sa))\n\t\tpriv->ents[sa].nusers++;\n\n\tif (!name)\n\t\tgoto done;\n\n\tecu = j1939_ecu_get_by_name_locked(priv, name);\n\tif (!ecu)\n\t\tecu = j1939_ecu_create_locked(priv, name);\n\terr = PTR_ERR_OR_ZERO(ecu);\n\tif (err)\n\t\tgoto done;\n\n\tecu->nusers++;\n\t \n\tif (j1939_ecu_is_mapped_locked(ecu))\n\t\t \n\t\tpriv->ents[ecu->addr].nusers++;\n\n done:\n\twrite_unlock_bh(&priv->lock);\n\n\treturn err;\n}\n\nvoid j1939_local_ecu_put(struct j1939_priv *priv, name_t name, u8 sa)\n{\n\tstruct j1939_ecu *ecu;\n\n\twrite_lock_bh(&priv->lock);\n\n\tif (j1939_address_is_unicast(sa))\n\t\tpriv->ents[sa].nusers--;\n\n\tif (!name)\n\t\tgoto done;\n\n\tecu = j1939_ecu_find_by_name_locked(priv, name);\n\tif (WARN_ON_ONCE(!ecu))\n\t\tgoto done;\n\n\tecu->nusers--;\n\t \n\tif (j1939_ecu_is_mapped_locked(ecu))\n\t\t \n\t\tpriv->ents[ecu->addr].nusers--;\n\tj1939_ecu_put(ecu);\n\n done:\n\twrite_unlock_bh(&priv->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}