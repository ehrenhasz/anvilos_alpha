{
  "module_name": "socket.c",
  "hash_id": "ee08f41fff3085f97324d4634eaf38052e22fded627cdbb1b518511d98594d2f",
  "original_prompt": "Ingested from linux-6.6.14/net/can/j1939/socket.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/can/can-ml.h>\n#include <linux/can/core.h>\n#include <linux/can/skb.h>\n#include <linux/errqueue.h>\n#include <linux/if_arp.h>\n\n#include \"j1939-priv.h\"\n\n#define J1939_MIN_NAMELEN CAN_REQUIRED_SIZE(struct sockaddr_can, can_addr.j1939)\n\n \nstatic inline priority_t j1939_prio(u32 sk_priority)\n{\n\tsk_priority = min(sk_priority, 7U);\n\n\treturn 7 - sk_priority;\n}\n\nstatic inline u32 j1939_to_sk_priority(priority_t prio)\n{\n\treturn 7 - prio;\n}\n\n \nstatic inline bool j1939_pgn_is_valid(pgn_t pgn)\n{\n\treturn pgn <= J1939_PGN_MAX;\n}\n\n \nstatic inline bool j1939_pgn_is_clean_pdu(pgn_t pgn)\n{\n\tif (j1939_pgn_is_pdu1(pgn))\n\t\treturn !(pgn & 0xff);\n\telse\n\t\treturn true;\n}\n\nstatic inline void j1939_sock_pending_add(struct sock *sk)\n{\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\n\tatomic_inc(&jsk->skb_pending);\n}\n\nstatic int j1939_sock_pending_get(struct sock *sk)\n{\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\n\treturn atomic_read(&jsk->skb_pending);\n}\n\nvoid j1939_sock_pending_del(struct sock *sk)\n{\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\n\t \n\tif (!atomic_dec_return(&jsk->skb_pending))\n\t\twake_up(&jsk->waitq);\t \n}\n\nstatic void j1939_jsk_add(struct j1939_priv *priv, struct j1939_sock *jsk)\n{\n\tjsk->state |= J1939_SOCK_BOUND;\n\tj1939_priv_get(priv);\n\n\tspin_lock_bh(&priv->j1939_socks_lock);\n\tlist_add_tail(&jsk->list, &priv->j1939_socks);\n\tspin_unlock_bh(&priv->j1939_socks_lock);\n}\n\nstatic void j1939_jsk_del(struct j1939_priv *priv, struct j1939_sock *jsk)\n{\n\tspin_lock_bh(&priv->j1939_socks_lock);\n\tlist_del_init(&jsk->list);\n\tspin_unlock_bh(&priv->j1939_socks_lock);\n\n\tj1939_priv_put(priv);\n\tjsk->state &= ~J1939_SOCK_BOUND;\n}\n\nstatic bool j1939_sk_queue_session(struct j1939_session *session)\n{\n\tstruct j1939_sock *jsk = j1939_sk(session->sk);\n\tbool empty;\n\n\tspin_lock_bh(&jsk->sk_session_queue_lock);\n\tempty = list_empty(&jsk->sk_session_queue);\n\tj1939_session_get(session);\n\tlist_add_tail(&session->sk_session_queue_entry, &jsk->sk_session_queue);\n\tspin_unlock_bh(&jsk->sk_session_queue_lock);\n\tj1939_sock_pending_add(&jsk->sk);\n\n\treturn empty;\n}\n\nstatic struct\nj1939_session *j1939_sk_get_incomplete_session(struct j1939_sock *jsk)\n{\n\tstruct j1939_session *session = NULL;\n\n\tspin_lock_bh(&jsk->sk_session_queue_lock);\n\tif (!list_empty(&jsk->sk_session_queue)) {\n\t\tsession = list_last_entry(&jsk->sk_session_queue,\n\t\t\t\t\t  struct j1939_session,\n\t\t\t\t\t  sk_session_queue_entry);\n\t\tif (session->total_queued_size == session->total_message_size)\n\t\t\tsession = NULL;\n\t\telse\n\t\t\tj1939_session_get(session);\n\t}\n\tspin_unlock_bh(&jsk->sk_session_queue_lock);\n\n\treturn session;\n}\n\nstatic void j1939_sk_queue_drop_all(struct j1939_priv *priv,\n\t\t\t\t    struct j1939_sock *jsk, int err)\n{\n\tstruct j1939_session *session, *tmp;\n\n\tnetdev_dbg(priv->ndev, \"%s: err: %i\\n\", __func__, err);\n\tspin_lock_bh(&jsk->sk_session_queue_lock);\n\tlist_for_each_entry_safe(session, tmp, &jsk->sk_session_queue,\n\t\t\t\t sk_session_queue_entry) {\n\t\tlist_del_init(&session->sk_session_queue_entry);\n\t\tsession->err = err;\n\t\tj1939_session_put(session);\n\t}\n\tspin_unlock_bh(&jsk->sk_session_queue_lock);\n}\n\nstatic void j1939_sk_queue_activate_next_locked(struct j1939_session *session)\n{\n\tstruct j1939_sock *jsk;\n\tstruct j1939_session *first;\n\tint err;\n\n\t \n\tif (!session->sk)\n\t\treturn;\n\n\tjsk = j1939_sk(session->sk);\n\tlockdep_assert_held(&jsk->sk_session_queue_lock);\n\n\terr = session->err;\n\n\tfirst = list_first_entry_or_null(&jsk->sk_session_queue,\n\t\t\t\t\t struct j1939_session,\n\t\t\t\t\t sk_session_queue_entry);\n\n\t \n\tif (first != session)\n\t\treturn;\n\nactivate_next:\n\tlist_del_init(&first->sk_session_queue_entry);\n\tj1939_session_put(first);\n\tfirst = list_first_entry_or_null(&jsk->sk_session_queue,\n\t\t\t\t\t struct j1939_session,\n\t\t\t\t\t sk_session_queue_entry);\n\tif (!first)\n\t\treturn;\n\n\tif (j1939_session_activate(first)) {\n\t\tnetdev_warn_once(first->priv->ndev,\n\t\t\t\t \"%s: 0x%p: Identical session is already activated.\\n\",\n\t\t\t\t __func__, first);\n\t\tfirst->err = -EBUSY;\n\t\tgoto activate_next;\n\t} else {\n\t\t \n\t\tint time_ms = 0;\n\n\t\tif (err)\n\t\t\ttime_ms = 10 + get_random_u32_below(16);\n\n\t\tj1939_tp_schedule_txtimer(first, time_ms);\n\t}\n}\n\nvoid j1939_sk_queue_activate_next(struct j1939_session *session)\n{\n\tstruct j1939_sock *jsk;\n\n\tif (!session->sk)\n\t\treturn;\n\n\tjsk = j1939_sk(session->sk);\n\n\tspin_lock_bh(&jsk->sk_session_queue_lock);\n\tj1939_sk_queue_activate_next_locked(session);\n\tspin_unlock_bh(&jsk->sk_session_queue_lock);\n}\n\nstatic bool j1939_sk_match_dst(struct j1939_sock *jsk,\n\t\t\t       const struct j1939_sk_buff_cb *skcb)\n{\n\tif ((jsk->state & J1939_SOCK_PROMISC))\n\t\treturn true;\n\n\t \n\tif (jsk->addr.src_name && skcb->addr.dst_name) {\n\t\tif (jsk->addr.src_name != skcb->addr.dst_name)\n\t\t\treturn false;\n\t} else {\n\t\t \n\t\tif (j1939_address_is_unicast(skcb->addr.da)) {\n\t\t\tif (jsk->addr.sa != skcb->addr.da)\n\t\t\t\treturn false;\n\t\t} else if (!sock_flag(&jsk->sk, SOCK_BROADCAST)) {\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tif (jsk->state & J1939_SOCK_CONNECTED) {\n\t\t \n\t\tif (jsk->addr.dst_name && skcb->addr.src_name) {\n\t\t\tif (jsk->addr.dst_name != skcb->addr.src_name)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (jsk->addr.da != skcb->addr.sa)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tif (j1939_pgn_is_valid(jsk->pgn_rx_filter) &&\n\t    jsk->pgn_rx_filter != skcb->addr.pgn)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool j1939_sk_match_filter(struct j1939_sock *jsk,\n\t\t\t\t  const struct j1939_sk_buff_cb *skcb)\n{\n\tconst struct j1939_filter *f = jsk->filters;\n\tint nfilter = jsk->nfilters;\n\n\tif (!nfilter)\n\t\t \n\t\treturn true;\n\n\tfor (; nfilter; ++f, --nfilter) {\n\t\tif ((skcb->addr.pgn & f->pgn_mask) != f->pgn)\n\t\t\tcontinue;\n\t\tif ((skcb->addr.sa & f->addr_mask) != f->addr)\n\t\t\tcontinue;\n\t\tif ((skcb->addr.src_name & f->name_mask) != f->name)\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool j1939_sk_recv_match_one(struct j1939_sock *jsk,\n\t\t\t\t    const struct j1939_sk_buff_cb *skcb)\n{\n\tif (!(jsk->state & J1939_SOCK_BOUND))\n\t\treturn false;\n\n\tif (!j1939_sk_match_dst(jsk, skcb))\n\t\treturn false;\n\n\tif (!j1939_sk_match_filter(jsk, skcb))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void j1939_sk_recv_one(struct j1939_sock *jsk, struct sk_buff *oskb)\n{\n\tconst struct j1939_sk_buff_cb *oskcb = j1939_skb_to_cb(oskb);\n\tstruct j1939_sk_buff_cb *skcb;\n\tstruct sk_buff *skb;\n\n\tif (oskb->sk == &jsk->sk)\n\t\treturn;\n\n\tif (!j1939_sk_recv_match_one(jsk, oskcb))\n\t\treturn;\n\n\tskb = skb_clone(oskb, GFP_ATOMIC);\n\tif (!skb) {\n\t\tpr_warn(\"skb clone failed\\n\");\n\t\treturn;\n\t}\n\tcan_skb_set_owner(skb, oskb->sk);\n\n\tskcb = j1939_skb_to_cb(skb);\n\tskcb->msg_flags &= ~(MSG_DONTROUTE);\n\tif (skb->sk)\n\t\tskcb->msg_flags |= MSG_DONTROUTE;\n\n\tif (sock_queue_rcv_skb(&jsk->sk, skb) < 0)\n\t\tkfree_skb(skb);\n}\n\nbool j1939_sk_recv_match(struct j1939_priv *priv, struct j1939_sk_buff_cb *skcb)\n{\n\tstruct j1939_sock *jsk;\n\tbool match = false;\n\n\tspin_lock_bh(&priv->j1939_socks_lock);\n\tlist_for_each_entry(jsk, &priv->j1939_socks, list) {\n\t\tmatch = j1939_sk_recv_match_one(jsk, skcb);\n\t\tif (match)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&priv->j1939_socks_lock);\n\n\treturn match;\n}\n\nvoid j1939_sk_recv(struct j1939_priv *priv, struct sk_buff *skb)\n{\n\tstruct j1939_sock *jsk;\n\n\tspin_lock_bh(&priv->j1939_socks_lock);\n\tlist_for_each_entry(jsk, &priv->j1939_socks, list) {\n\t\tj1939_sk_recv_one(jsk, skb);\n\t}\n\tspin_unlock_bh(&priv->j1939_socks_lock);\n}\n\nstatic void j1939_sk_sock_destruct(struct sock *sk)\n{\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\n\t \n\tif (jsk->priv) {\n\t\tj1939_priv_put(jsk->priv);\n\t\tjsk->priv = NULL;\n\t}\n\n\t \n\tcan_sock_destruct(sk);\n}\n\nstatic int j1939_sk_init(struct sock *sk)\n{\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\n\t \n\tBUILD_BUG_ON(offsetof(struct j1939_sock, sk) != 0);\n\tmemset((void *)jsk + sizeof(jsk->sk), 0x0,\n\t       sizeof(*jsk) - sizeof(jsk->sk));\n\n\tINIT_LIST_HEAD(&jsk->list);\n\tinit_waitqueue_head(&jsk->waitq);\n\tjsk->sk.sk_priority = j1939_to_sk_priority(6);\n\tjsk->sk.sk_reuse = 1;  \n\tjsk->addr.sa = J1939_NO_ADDR;\n\tjsk->addr.da = J1939_NO_ADDR;\n\tjsk->addr.pgn = J1939_NO_PGN;\n\tjsk->pgn_rx_filter = J1939_NO_PGN;\n\tatomic_set(&jsk->skb_pending, 0);\n\tspin_lock_init(&jsk->sk_session_queue_lock);\n\tINIT_LIST_HEAD(&jsk->sk_session_queue);\n\n\t \n\tsock_set_flag(sk, SOCK_RCU_FREE);\n\tsk->sk_destruct = j1939_sk_sock_destruct;\n\tsk->sk_protocol = CAN_J1939;\n\n\treturn 0;\n}\n\nstatic int j1939_sk_sanity_check(struct sockaddr_can *addr, int len)\n{\n\tif (!addr)\n\t\treturn -EDESTADDRREQ;\n\tif (len < J1939_MIN_NAMELEN)\n\t\treturn -EINVAL;\n\tif (addr->can_family != AF_CAN)\n\t\treturn -EINVAL;\n\tif (!addr->can_ifindex)\n\t\treturn -ENODEV;\n\tif (j1939_pgn_is_valid(addr->can_addr.j1939.pgn) &&\n\t    !j1939_pgn_is_clean_pdu(addr->can_addr.j1939.pgn))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int j1939_sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct j1939_sock *jsk = j1939_sk(sock->sk);\n\tstruct j1939_priv *priv;\n\tstruct sock *sk;\n\tstruct net *net;\n\tint ret = 0;\n\n\tret = j1939_sk_sanity_check(addr, len);\n\tif (ret)\n\t\treturn ret;\n\n\tlock_sock(sock->sk);\n\n\tpriv = jsk->priv;\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\n\t \n\tif (jsk->state & J1939_SOCK_BOUND) {\n\t\t \n\t\tif (jsk->ifindex != addr->can_ifindex) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_release_sock;\n\t\t}\n\n\t\t \n\t\tj1939_jsk_del(priv, jsk);\n\t\tj1939_local_ecu_put(priv, jsk->addr.src_name, jsk->addr.sa);\n\t} else {\n\t\tstruct can_ml_priv *can_ml;\n\t\tstruct net_device *ndev;\n\n\t\tndev = dev_get_by_index(net, addr->can_ifindex);\n\t\tif (!ndev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_release_sock;\n\t\t}\n\n\t\tcan_ml = can_get_ml_priv(ndev);\n\t\tif (!can_ml) {\n\t\t\tdev_put(ndev);\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_release_sock;\n\t\t}\n\n\t\tif (!(ndev->flags & IFF_UP)) {\n\t\t\tdev_put(ndev);\n\t\t\tret = -ENETDOWN;\n\t\t\tgoto out_release_sock;\n\t\t}\n\n\t\tpriv = j1939_netdev_start(ndev);\n\t\tdev_put(ndev);\n\t\tif (IS_ERR(priv)) {\n\t\t\tret = PTR_ERR(priv);\n\t\t\tgoto out_release_sock;\n\t\t}\n\n\t\tjsk->ifindex = addr->can_ifindex;\n\n\t\t \n\t\tj1939_priv_get(priv);\n\t\tjsk->priv = priv;\n\t}\n\n\t \n\tif (j1939_pgn_is_valid(addr->can_addr.j1939.pgn))\n\t\tjsk->pgn_rx_filter = addr->can_addr.j1939.pgn;\n\tjsk->addr.src_name = addr->can_addr.j1939.name;\n\tjsk->addr.sa = addr->can_addr.j1939.addr;\n\n\t \n\tret = j1939_local_ecu_get(priv, jsk->addr.src_name, jsk->addr.sa);\n\tif (ret) {\n\t\tj1939_netdev_stop(priv);\n\t\tgoto out_release_sock;\n\t}\n\n\tj1939_jsk_add(priv, jsk);\n\n out_release_sock:  \n\trelease_sock(sock->sk);\n\n\treturn ret;\n}\n\nstatic int j1939_sk_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int len, int flags)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct j1939_sock *jsk = j1939_sk(sock->sk);\n\tint ret = 0;\n\n\tret = j1939_sk_sanity_check(addr, len);\n\tif (ret)\n\t\treturn ret;\n\n\tlock_sock(sock->sk);\n\n\t \n\tif (!(jsk->state & J1939_SOCK_BOUND)) {\n\t\tret = -EINVAL;\n\t\tgoto out_release_sock;\n\t}\n\n\t \n\tif (jsk->ifindex != addr->can_ifindex) {\n\t\tret = -EINVAL;\n\t\tgoto out_release_sock;\n\t}\n\n\tif (!addr->can_addr.j1939.name &&\n\t    addr->can_addr.j1939.addr == J1939_NO_ADDR &&\n\t    !sock_flag(&jsk->sk, SOCK_BROADCAST)) {\n\t\t \n\t\tret = -EACCES;\n\t\tgoto out_release_sock;\n\t}\n\n\tjsk->addr.dst_name = addr->can_addr.j1939.name;\n\tjsk->addr.da = addr->can_addr.j1939.addr;\n\n\tif (j1939_pgn_is_valid(addr->can_addr.j1939.pgn))\n\t\tjsk->addr.pgn = addr->can_addr.j1939.pgn;\n\n\tjsk->state |= J1939_SOCK_CONNECTED;\n\n out_release_sock:  \n\trelease_sock(sock->sk);\n\n\treturn ret;\n}\n\nstatic void j1939_sk_sock2sockaddr_can(struct sockaddr_can *addr,\n\t\t\t\t       const struct j1939_sock *jsk, int peer)\n{\n\t \n\tmemset(addr, 0, J1939_MIN_NAMELEN);\n\n\taddr->can_family = AF_CAN;\n\taddr->can_ifindex = jsk->ifindex;\n\taddr->can_addr.j1939.pgn = jsk->addr.pgn;\n\tif (peer) {\n\t\taddr->can_addr.j1939.name = jsk->addr.dst_name;\n\t\taddr->can_addr.j1939.addr = jsk->addr.da;\n\t} else {\n\t\taddr->can_addr.j1939.name = jsk->addr.src_name;\n\t\taddr->can_addr.j1939.addr = jsk->addr.sa;\n\t}\n}\n\nstatic int j1939_sk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\tint ret = 0;\n\n\tlock_sock(sk);\n\n\tif (peer && !(jsk->state & J1939_SOCK_CONNECTED)) {\n\t\tret = -EADDRNOTAVAIL;\n\t\tgoto failure;\n\t}\n\n\tj1939_sk_sock2sockaddr_can(addr, jsk, peer);\n\tret = J1939_MIN_NAMELEN;\n\n failure:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int j1939_sk_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct j1939_sock *jsk;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tjsk = j1939_sk(sk);\n\n\tif (jsk->state & J1939_SOCK_BOUND) {\n\t\tstruct j1939_priv *priv = jsk->priv;\n\n\t\tif (wait_event_interruptible(jsk->waitq,\n\t\t\t\t\t     !j1939_sock_pending_get(&jsk->sk))) {\n\t\t\tj1939_cancel_active_session(priv, sk);\n\t\t\tj1939_sk_queue_drop_all(priv, jsk, ESHUTDOWN);\n\t\t}\n\n\t\tj1939_jsk_del(priv, jsk);\n\n\t\tj1939_local_ecu_put(priv, jsk->addr.src_name,\n\t\t\t\t    jsk->addr.sa);\n\n\t\tj1939_netdev_stop(priv);\n\t}\n\n\tkfree(jsk->filters);\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int j1939_sk_setsockopt_flag(struct j1939_sock *jsk, sockptr_t optval,\n\t\t\t\t    unsigned int optlen, int flag)\n{\n\tint tmp;\n\n\tif (optlen != sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&tmp, optval, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(&jsk->sk);\n\tif (tmp)\n\t\tjsk->state |= flag;\n\telse\n\t\tjsk->state &= ~flag;\n\trelease_sock(&jsk->sk);\n\treturn tmp;\n}\n\nstatic int j1939_sk_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\tint tmp, count = 0, ret = 0;\n\tstruct j1939_filter *filters = NULL, *ofilters;\n\n\tif (level != SOL_CAN_J1939)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase SO_J1939_FILTER:\n\t\tif (!sockptr_is_null(optval) && optlen != 0) {\n\t\t\tstruct j1939_filter *f;\n\t\t\tint c;\n\n\t\t\tif (optlen % sizeof(*filters) != 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (optlen > J1939_FILTER_MAX *\n\t\t\t    sizeof(struct j1939_filter))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcount = optlen / sizeof(*filters);\n\t\t\tfilters = memdup_sockptr(optval, optlen);\n\t\t\tif (IS_ERR(filters))\n\t\t\t\treturn PTR_ERR(filters);\n\n\t\t\tfor (f = filters, c = count; c; f++, c--) {\n\t\t\t\tf->name &= f->name_mask;\n\t\t\t\tf->pgn &= f->pgn_mask;\n\t\t\t\tf->addr &= f->addr_mask;\n\t\t\t}\n\t\t}\n\n\t\tlock_sock(&jsk->sk);\n\t\tofilters = jsk->filters;\n\t\tjsk->filters = filters;\n\t\tjsk->nfilters = count;\n\t\trelease_sock(&jsk->sk);\n\t\tkfree(ofilters);\n\t\treturn 0;\n\tcase SO_J1939_PROMISC:\n\t\treturn j1939_sk_setsockopt_flag(jsk, optval, optlen,\n\t\t\t\t\t\tJ1939_SOCK_PROMISC);\n\tcase SO_J1939_ERRQUEUE:\n\t\tret = j1939_sk_setsockopt_flag(jsk, optval, optlen,\n\t\t\t\t\t       J1939_SOCK_ERRQUEUE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(jsk->state & J1939_SOCK_ERRQUEUE))\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\treturn ret;\n\tcase SO_J1939_SEND_PRIO:\n\t\tif (optlen != sizeof(tmp))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&tmp, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (tmp < 0 || tmp > 7)\n\t\t\treturn -EDOM;\n\t\tif (tmp < 2 && !capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tlock_sock(&jsk->sk);\n\t\tjsk->sk.sk_priority = j1939_to_sk_priority(tmp);\n\t\trelease_sock(&jsk->sk);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\nstatic int j1939_sk_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\tint ret, ulen;\n\t \n\tint tmp = 0;\n\tint len = sizeof(tmp);\n\tvoid *val = &tmp;\n\n\tif (level != SOL_CAN_J1939)\n\t\treturn -EINVAL;\n\tif (get_user(ulen, optlen))\n\t\treturn -EFAULT;\n\tif (ulen < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(&jsk->sk);\n\tswitch (optname) {\n\tcase SO_J1939_PROMISC:\n\t\ttmp = (jsk->state & J1939_SOCK_PROMISC) ? 1 : 0;\n\t\tbreak;\n\tcase SO_J1939_ERRQUEUE:\n\t\ttmp = (jsk->state & J1939_SOCK_ERRQUEUE) ? 1 : 0;\n\t\tbreak;\n\tcase SO_J1939_SEND_PRIO:\n\t\ttmp = j1939_prio(jsk->sk.sk_priority);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tgoto no_copy;\n\t}\n\n\t \n\tif (len > ulen)\n\t\tret = -EFAULT;\n\telse if (put_user(len, optlen))\n\t\tret = -EFAULT;\n\telse if (copy_to_user(optval, val, len))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\n no_copy:\n\trelease_sock(&jsk->sk);\n\treturn ret;\n}\n\nstatic int j1939_sk_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tstruct j1939_sk_buff_cb *skcb;\n\tint ret = 0;\n\n\tif (flags & ~(MSG_DONTWAIT | MSG_ERRQUEUE | MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn sock_recv_errqueue(sock->sk, msg, size, SOL_CAN_J1939,\n\t\t\t\t\t  SCM_J1939_ERRQUEUE);\n\n\tskb = skb_recv_datagram(sk, flags, &ret);\n\tif (!skb)\n\t\treturn ret;\n\n\tif (size < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\telse\n\t\tsize = skb->len;\n\n\tret = memcpy_to_msg(msg, skb->data, size);\n\tif (ret < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\treturn ret;\n\t}\n\n\tskcb = j1939_skb_to_cb(skb);\n\tif (j1939_address_is_valid(skcb->addr.da))\n\t\tput_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_ADDR,\n\t\t\t sizeof(skcb->addr.da), &skcb->addr.da);\n\n\tif (skcb->addr.dst_name)\n\t\tput_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_NAME,\n\t\t\t sizeof(skcb->addr.dst_name), &skcb->addr.dst_name);\n\n\tput_cmsg(msg, SOL_CAN_J1939, SCM_J1939_PRIO,\n\t\t sizeof(skcb->priority), &skcb->priority);\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_can *paddr = msg->msg_name;\n\n\t\tmsg->msg_namelen = J1939_MIN_NAMELEN;\n\t\tmemset(msg->msg_name, 0, msg->msg_namelen);\n\t\tpaddr->can_family = AF_CAN;\n\t\tpaddr->can_ifindex = skb->skb_iif;\n\t\tpaddr->can_addr.j1939.name = skcb->addr.src_name;\n\t\tpaddr->can_addr.j1939.addr = skcb->addr.sa;\n\t\tpaddr->can_addr.j1939.pgn = skcb->addr.pgn;\n\t}\n\n\tsock_recv_cmsgs(msg, sk, skb);\n\tmsg->msg_flags |= skcb->msg_flags;\n\tskb_free_datagram(sk, skb);\n\n\treturn size;\n}\n\nstatic struct sk_buff *j1939_sk_alloc_skb(struct net_device *ndev,\n\t\t\t\t\t  struct sock *sk,\n\t\t\t\t\t  struct msghdr *msg, size_t size,\n\t\t\t\t\t  int *errcode)\n{\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\tstruct j1939_sk_buff_cb *skcb;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t  size +\n\t\t\t\t  sizeof(struct can_frame) -\n\t\t\t\t  sizeof(((struct can_frame *)NULL)->data) +\n\t\t\t\t  sizeof(struct can_skb_priv),\n\t\t\t\t  msg->msg_flags & MSG_DONTWAIT, &ret);\n\tif (!skb)\n\t\tgoto failure;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = ndev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\tskb_reserve(skb, offsetof(struct can_frame, data));\n\n\tret = memcpy_from_msg(skb_put(skb, size), msg, size);\n\tif (ret < 0)\n\t\tgoto free_skb;\n\n\tskb->dev = ndev;\n\n\tskcb = j1939_skb_to_cb(skb);\n\tmemset(skcb, 0, sizeof(*skcb));\n\tskcb->addr = jsk->addr;\n\tskcb->priority = j1939_prio(sk->sk_priority);\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_can *addr = msg->msg_name;\n\n\t\tif (addr->can_addr.j1939.name ||\n\t\t    addr->can_addr.j1939.addr != J1939_NO_ADDR) {\n\t\t\tskcb->addr.dst_name = addr->can_addr.j1939.name;\n\t\t\tskcb->addr.da = addr->can_addr.j1939.addr;\n\t\t}\n\t\tif (j1939_pgn_is_valid(addr->can_addr.j1939.pgn))\n\t\t\tskcb->addr.pgn = addr->can_addr.j1939.pgn;\n\t}\n\n\t*errcode = ret;\n\treturn skb;\n\nfree_skb:\n\tkfree_skb(skb);\nfailure:\n\t*errcode = ret;\n\treturn NULL;\n}\n\nstatic size_t j1939_sk_opt_stats_get_size(enum j1939_sk_errqueue_type type)\n{\n\tswitch (type) {\n\tcase J1939_ERRQUEUE_RX_RTS:\n\t\treturn\n\t\t\tnla_total_size(sizeof(u32)) +  \n\t\t\tnla_total_size(sizeof(u32)) +  \n\t\t\tnla_total_size(sizeof(u64)) +  \n\t\t\tnla_total_size(sizeof(u64)) +  \n\t\t\tnla_total_size(sizeof(u8)) +   \n\t\t\tnla_total_size(sizeof(u8)) +   \n\t\t\t0;\n\tdefault:\n\t\treturn\n\t\t\tnla_total_size(sizeof(u32)) +  \n\t\t\t0;\n\t}\n}\n\nstatic struct sk_buff *\nj1939_sk_get_timestamping_opt_stats(struct j1939_session *session,\n\t\t\t\t    enum j1939_sk_errqueue_type type)\n{\n\tstruct sk_buff *stats;\n\tu32 size;\n\n\tstats = alloc_skb(j1939_sk_opt_stats_get_size(type), GFP_ATOMIC);\n\tif (!stats)\n\t\treturn NULL;\n\n\tif (session->skcb.addr.type == J1939_SIMPLE)\n\t\tsize = session->total_message_size;\n\telse\n\t\tsize = min(session->pkt.tx_acked * 7,\n\t\t\t   session->total_message_size);\n\n\tswitch (type) {\n\tcase J1939_ERRQUEUE_RX_RTS:\n\t\tnla_put_u32(stats, J1939_NLA_TOTAL_SIZE,\n\t\t\t    session->total_message_size);\n\t\tnla_put_u32(stats, J1939_NLA_PGN,\n\t\t\t    session->skcb.addr.pgn);\n\t\tnla_put_u64_64bit(stats, J1939_NLA_SRC_NAME,\n\t\t\t\t  session->skcb.addr.src_name, J1939_NLA_PAD);\n\t\tnla_put_u64_64bit(stats, J1939_NLA_DEST_NAME,\n\t\t\t\t  session->skcb.addr.dst_name, J1939_NLA_PAD);\n\t\tnla_put_u8(stats, J1939_NLA_SRC_ADDR,\n\t\t\t   session->skcb.addr.sa);\n\t\tnla_put_u8(stats, J1939_NLA_DEST_ADDR,\n\t\t\t   session->skcb.addr.da);\n\t\tbreak;\n\tdefault:\n\t\tnla_put_u32(stats, J1939_NLA_BYTES_ACKED, size);\n\t}\n\n\treturn stats;\n}\n\nstatic void __j1939_sk_errqueue(struct j1939_session *session, struct sock *sk,\n\t\t\t\tenum j1939_sk_errqueue_type type)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tstruct j1939_sock *jsk;\n\tstruct sock_exterr_skb *serr;\n\tstruct sk_buff *skb;\n\tchar *state = \"UNK\";\n\tu32 tsflags;\n\tint err;\n\n\tjsk = j1939_sk(sk);\n\n\tif (!(jsk->state & J1939_SOCK_ERRQUEUE))\n\t\treturn;\n\n\ttsflags = READ_ONCE(sk->sk_tsflags);\n\tswitch (type) {\n\tcase J1939_ERRQUEUE_TX_ACK:\n\t\tif (!(tsflags & SOF_TIMESTAMPING_TX_ACK))\n\t\t\treturn;\n\t\tbreak;\n\tcase J1939_ERRQUEUE_TX_SCHED:\n\t\tif (!(tsflags & SOF_TIMESTAMPING_TX_SCHED))\n\t\t\treturn;\n\t\tbreak;\n\tcase J1939_ERRQUEUE_TX_ABORT:\n\t\tbreak;\n\tcase J1939_ERRQUEUE_RX_RTS:\n\t\tfallthrough;\n\tcase J1939_ERRQUEUE_RX_DPO:\n\t\tfallthrough;\n\tcase J1939_ERRQUEUE_RX_ABORT:\n\t\tif (!(tsflags & SOF_TIMESTAMPING_RX_SOFTWARE))\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(priv->ndev, \"Unknown errqueue type %i\\n\", type);\n\t}\n\n\tskb = j1939_sk_get_timestamping_opt_stats(session, type);\n\tif (!skb)\n\t\treturn;\n\n\tskb->tstamp = ktime_get_real();\n\n\tBUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));\n\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tswitch (type) {\n\tcase J1939_ERRQUEUE_TX_ACK:\n\t\tserr->ee.ee_errno = ENOMSG;\n\t\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\t\tserr->ee.ee_info = SCM_TSTAMP_ACK;\n\t\tstate = \"TX ACK\";\n\t\tbreak;\n\tcase J1939_ERRQUEUE_TX_SCHED:\n\t\tserr->ee.ee_errno = ENOMSG;\n\t\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\t\tserr->ee.ee_info = SCM_TSTAMP_SCHED;\n\t\tstate = \"TX SCH\";\n\t\tbreak;\n\tcase J1939_ERRQUEUE_TX_ABORT:\n\t\tserr->ee.ee_errno = session->err;\n\t\tserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\n\t\tserr->ee.ee_info = J1939_EE_INFO_TX_ABORT;\n\t\tstate = \"TX ABT\";\n\t\tbreak;\n\tcase J1939_ERRQUEUE_RX_RTS:\n\t\tserr->ee.ee_errno = ENOMSG;\n\t\tserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\n\t\tserr->ee.ee_info = J1939_EE_INFO_RX_RTS;\n\t\tstate = \"RX RTS\";\n\t\tbreak;\n\tcase J1939_ERRQUEUE_RX_DPO:\n\t\tserr->ee.ee_errno = ENOMSG;\n\t\tserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\n\t\tserr->ee.ee_info = J1939_EE_INFO_RX_DPO;\n\t\tstate = \"RX DPO\";\n\t\tbreak;\n\tcase J1939_ERRQUEUE_RX_ABORT:\n\t\tserr->ee.ee_errno = session->err;\n\t\tserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\n\t\tserr->ee.ee_info = J1939_EE_INFO_RX_ABORT;\n\t\tstate = \"RX ABT\";\n\t\tbreak;\n\t}\n\n\tserr->opt_stats = true;\n\tif (tsflags & SOF_TIMESTAMPING_OPT_ID)\n\t\tserr->ee.ee_data = session->tskey;\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p tskey: %i, state: %s\\n\",\n\t\t   __func__, session, session->tskey, state);\n\terr = sock_queue_err_skb(sk, skb);\n\n\tif (err)\n\t\tkfree_skb(skb);\n};\n\nvoid j1939_sk_errqueue(struct j1939_session *session,\n\t\t       enum j1939_sk_errqueue_type type)\n{\n\tstruct j1939_priv *priv = session->priv;\n\tstruct j1939_sock *jsk;\n\n\tif (session->sk) {\n\t\t \n\t\t__j1939_sk_errqueue(session, session->sk, type);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_bh(&priv->j1939_socks_lock);\n\tlist_for_each_entry(jsk, &priv->j1939_socks, list) {\n\t\tif (j1939_sk_recv_match_one(jsk, &session->skcb))\n\t\t\t__j1939_sk_errqueue(session, &jsk->sk, type);\n\t}\n\tspin_unlock_bh(&priv->j1939_socks_lock);\n};\n\nvoid j1939_sk_send_loop_abort(struct sock *sk, int err)\n{\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\n\tif (jsk->state & J1939_SOCK_ERRQUEUE)\n\t\treturn;\n\n\tsk->sk_err = err;\n\n\tsk_error_report(sk);\n}\n\nstatic int j1939_sk_send_loop(struct j1939_priv *priv,  struct sock *sk,\n\t\t\t      struct msghdr *msg, size_t size)\n\n{\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\tstruct j1939_session *session = j1939_sk_get_incomplete_session(jsk);\n\tstruct sk_buff *skb;\n\tsize_t segment_size, todo_size;\n\tint ret = 0;\n\n\tif (session &&\n\t    session->total_message_size != session->total_queued_size + size) {\n\t\tj1939_session_put(session);\n\t\treturn -EIO;\n\t}\n\n\ttodo_size = size;\n\n\twhile (todo_size) {\n\t\tstruct j1939_sk_buff_cb *skcb;\n\n\t\tsegment_size = min_t(size_t, J1939_MAX_TP_PACKET_SIZE,\n\t\t\t\t     todo_size);\n\n\t\t \n\t\tskb = j1939_sk_alloc_skb(priv->ndev, sk, msg, segment_size,\n\t\t\t\t\t &ret);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tskcb = j1939_skb_to_cb(skb);\n\n\t\tif (!session) {\n\t\t\t \n\t\t\tskcb->offset = 0;\n\t\t\tsession = j1939_tp_send(priv, skb, size);\n\t\t\tif (IS_ERR(session)) {\n\t\t\t\tret = PTR_ERR(session);\n\t\t\t\tgoto kfree_skb;\n\t\t\t}\n\t\t\tif (j1939_sk_queue_session(session)) {\n\t\t\t\t \n\t\t\t\tif (!j1939_session_activate(session)) {\n\t\t\t\t\tj1939_tp_schedule_txtimer(session, 0);\n\t\t\t\t} else {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tsession->err = ret;\n\t\t\t\t\tj1939_sk_queue_drop_all(priv, jsk,\n\t\t\t\t\t\t\t\tEBUSY);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tskcb->offset = session->total_queued_size;\n\t\t\tj1939_session_skb_queue(session, skb);\n\t\t}\n\n\t\ttodo_size -= segment_size;\n\t\tsession->total_queued_size += segment_size;\n\t}\n\n\tswitch (ret) {\n\tcase 0:  \n\t\tif (todo_size)\n\t\t\tnetdev_warn(priv->ndev,\n\t\t\t\t    \"no error found and not completely queued?! %zu\\n\",\n\t\t\t\t    todo_size);\n\t\tret = size;\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\t\tret = -EINTR;\n\t\tfallthrough;\n\tcase -EAGAIN:  \n\t\tif (todo_size != size)\n\t\t\tret = size - todo_size;\n\t\tbreak;\n\tdefault:  \n\t\tbreak;\n\t}\n\n\tif (session)\n\t\tj1939_session_put(session);\n\n\treturn ret;\n\n kfree_skb:\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic int j1939_sk_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct j1939_sock *jsk = j1939_sk(sk);\n\tstruct j1939_priv *priv;\n\tint ifindex;\n\tint ret;\n\n\tlock_sock(sock->sk);\n\t \n\tif (!(jsk->state & J1939_SOCK_BOUND)) {\n\t\tret = -EBADFD;\n\t\tgoto sendmsg_done;\n\t}\n\n\tpriv = jsk->priv;\n\tifindex = jsk->ifindex;\n\n\tif (!jsk->addr.src_name && jsk->addr.sa == J1939_NO_ADDR) {\n\t\t \n\t\tret = -EBADFD;\n\t\tgoto sendmsg_done;\n\t}\n\n\t \n\tif (msg->msg_name) {\n\t\tstruct sockaddr_can *addr = msg->msg_name;\n\n\t\tif (msg->msg_namelen < J1939_MIN_NAMELEN) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto sendmsg_done;\n\t\t}\n\n\t\tif (addr->can_family != AF_CAN) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto sendmsg_done;\n\t\t}\n\n\t\tif (addr->can_ifindex && addr->can_ifindex != ifindex) {\n\t\t\tret = -EBADFD;\n\t\t\tgoto sendmsg_done;\n\t\t}\n\n\t\tif (j1939_pgn_is_valid(addr->can_addr.j1939.pgn) &&\n\t\t    !j1939_pgn_is_clean_pdu(addr->can_addr.j1939.pgn)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto sendmsg_done;\n\t\t}\n\n\t\tif (!addr->can_addr.j1939.name &&\n\t\t    addr->can_addr.j1939.addr == J1939_NO_ADDR &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\t \n\t\t\tret = -EACCES;\n\t\t\tgoto sendmsg_done;\n\t\t}\n\t} else {\n\t\tif (!jsk->addr.dst_name && jsk->addr.da == J1939_NO_ADDR &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\t \n\t\t\tret = -EACCES;\n\t\t\tgoto sendmsg_done;\n\t\t}\n\t}\n\n\tret = j1939_sk_send_loop(priv, sk, msg, size);\n\nsendmsg_done:\n\trelease_sock(sock->sk);\n\n\treturn ret;\n}\n\nvoid j1939_sk_netdev_event_netdown(struct j1939_priv *priv)\n{\n\tstruct j1939_sock *jsk;\n\tint error_code = ENETDOWN;\n\n\tspin_lock_bh(&priv->j1939_socks_lock);\n\tlist_for_each_entry(jsk, &priv->j1939_socks, list) {\n\t\tjsk->sk.sk_err = error_code;\n\t\tif (!sock_flag(&jsk->sk, SOCK_DEAD))\n\t\t\tsk_error_report(&jsk->sk);\n\n\t\tj1939_sk_queue_drop_all(priv, jsk, error_code);\n\t}\n\tspin_unlock_bh(&priv->j1939_socks_lock);\n}\n\nstatic int j1939_sk_no_ioctlcmd(struct socket *sock, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\t \n\treturn -ENOIOCTLCMD;\n}\n\nstatic const struct proto_ops j1939_ops = {\n\t.family = PF_CAN,\n\t.release = j1939_sk_release,\n\t.bind = j1939_sk_bind,\n\t.connect = j1939_sk_connect,\n\t.socketpair = sock_no_socketpair,\n\t.accept = sock_no_accept,\n\t.getname = j1939_sk_getname,\n\t.poll = datagram_poll,\n\t.ioctl = j1939_sk_no_ioctlcmd,\n\t.listen = sock_no_listen,\n\t.shutdown = sock_no_shutdown,\n\t.setsockopt = j1939_sk_setsockopt,\n\t.getsockopt = j1939_sk_getsockopt,\n\t.sendmsg = j1939_sk_sendmsg,\n\t.recvmsg = j1939_sk_recvmsg,\n\t.mmap = sock_no_mmap,\n};\n\nstatic struct proto j1939_proto __read_mostly = {\n\t.name = \"CAN_J1939\",\n\t.owner = THIS_MODULE,\n\t.obj_size = sizeof(struct j1939_sock),\n\t.init = j1939_sk_init,\n};\n\nconst struct can_proto j1939_can_proto = {\n\t.type = SOCK_DGRAM,\n\t.protocol = CAN_J1939,\n\t.ops = &j1939_ops,\n\t.prot = &j1939_proto,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}