{
  "module_name": "gw.c",
  "hash_id": "0f84fafeb14d6590e95d3b8ab90a659d542092bcedc4a5baa66c6333711ac0b3",
  "original_prompt": "Ingested from linux-6.6.14/net/can/gw.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/can.h>\n#include <linux/can/core.h>\n#include <linux/can/skb.h>\n#include <linux/can/gw.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n\n#define CAN_GW_NAME \"can-gw\"\n\nMODULE_DESCRIPTION(\"PF_CAN netlink gateway\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Oliver Hartkopp <oliver.hartkopp@volkswagen.de>\");\nMODULE_ALIAS(CAN_GW_NAME);\n\n#define CGW_MIN_HOPS 1\n#define CGW_MAX_HOPS 6\n#define CGW_DEFAULT_HOPS 1\n\nstatic unsigned int max_hops __read_mostly = CGW_DEFAULT_HOPS;\nmodule_param(max_hops, uint, 0444);\nMODULE_PARM_DESC(max_hops,\n\t\t \"maximum \" CAN_GW_NAME \" routing hops for CAN frames \"\n\t\t \"(valid values: \" __stringify(CGW_MIN_HOPS) \"-\"\n\t\t __stringify(CGW_MAX_HOPS) \" hops, \"\n\t\t \"default: \" __stringify(CGW_DEFAULT_HOPS) \")\");\n\nstatic struct notifier_block notifier;\nstatic struct kmem_cache *cgw_cache __read_mostly;\n\n \nstruct cf_mod {\n\tstruct {\n\t\tstruct canfd_frame and;\n\t\tstruct canfd_frame or;\n\t\tstruct canfd_frame xor;\n\t\tstruct canfd_frame set;\n\t} modframe;\n\tstruct {\n\t\tu8 and;\n\t\tu8 or;\n\t\tu8 xor;\n\t\tu8 set;\n\t} modtype;\n\tvoid (*modfunc[MAX_MODFUNCTIONS])(struct canfd_frame *cf,\n\t\t\t\t\t  struct cf_mod *mod);\n\n\t \n\tstruct {\n\t\tstruct cgw_csum_xor xor;\n\t\tstruct cgw_csum_crc8 crc8;\n\t} csum;\n\tstruct {\n\t\tvoid (*xor)(struct canfd_frame *cf,\n\t\t\t    struct cgw_csum_xor *xor);\n\t\tvoid (*crc8)(struct canfd_frame *cf,\n\t\t\t     struct cgw_csum_crc8 *crc8);\n\t} csumfunc;\n\tu32 uid;\n};\n\n \nstruct can_can_gw {\n\tstruct can_filter filter;\n\tint src_idx;\n\tint dst_idx;\n};\n\n \nstruct cgw_job {\n\tstruct hlist_node list;\n\tstruct rcu_head rcu;\n\tu32 handled_frames;\n\tu32 dropped_frames;\n\tu32 deleted_frames;\n\tstruct cf_mod mod;\n\tunion {\n\t\t \n\t\tstruct net_device *dev;\n\t} src;\n\tunion {\n\t\t \n\t\tstruct net_device *dev;\n\t} dst;\n\tunion {\n\t\tstruct can_can_gw ccgw;\n\t\t \n\t};\n\tu8 gwtype;\n\tu8 limit_hops;\n\tu16 flags;\n};\n\n \n\n#define MODFUNC(func, op) static void func(struct canfd_frame *cf, \\\n\t\t\t\t\t   struct cf_mod *mod) { op ; }\n\nMODFUNC(mod_and_id, cf->can_id &= mod->modframe.and.can_id)\nMODFUNC(mod_and_len, cf->len &= mod->modframe.and.len)\nMODFUNC(mod_and_flags, cf->flags &= mod->modframe.and.flags)\nMODFUNC(mod_and_data, *(u64 *)cf->data &= *(u64 *)mod->modframe.and.data)\nMODFUNC(mod_or_id, cf->can_id |= mod->modframe.or.can_id)\nMODFUNC(mod_or_len, cf->len |= mod->modframe.or.len)\nMODFUNC(mod_or_flags, cf->flags |= mod->modframe.or.flags)\nMODFUNC(mod_or_data, *(u64 *)cf->data |= *(u64 *)mod->modframe.or.data)\nMODFUNC(mod_xor_id, cf->can_id ^= mod->modframe.xor.can_id)\nMODFUNC(mod_xor_len, cf->len ^= mod->modframe.xor.len)\nMODFUNC(mod_xor_flags, cf->flags ^= mod->modframe.xor.flags)\nMODFUNC(mod_xor_data, *(u64 *)cf->data ^= *(u64 *)mod->modframe.xor.data)\nMODFUNC(mod_set_id, cf->can_id = mod->modframe.set.can_id)\nMODFUNC(mod_set_len, cf->len = mod->modframe.set.len)\nMODFUNC(mod_set_flags, cf->flags = mod->modframe.set.flags)\nMODFUNC(mod_set_data, *(u64 *)cf->data = *(u64 *)mod->modframe.set.data)\n\nstatic void mod_and_fddata(struct canfd_frame *cf, struct cf_mod *mod)\n{\n\tint i;\n\n\tfor (i = 0; i < CANFD_MAX_DLEN; i += 8)\n\t\t*(u64 *)(cf->data + i) &= *(u64 *)(mod->modframe.and.data + i);\n}\n\nstatic void mod_or_fddata(struct canfd_frame *cf, struct cf_mod *mod)\n{\n\tint i;\n\n\tfor (i = 0; i < CANFD_MAX_DLEN; i += 8)\n\t\t*(u64 *)(cf->data + i) |= *(u64 *)(mod->modframe.or.data + i);\n}\n\nstatic void mod_xor_fddata(struct canfd_frame *cf, struct cf_mod *mod)\n{\n\tint i;\n\n\tfor (i = 0; i < CANFD_MAX_DLEN; i += 8)\n\t\t*(u64 *)(cf->data + i) ^= *(u64 *)(mod->modframe.xor.data + i);\n}\n\nstatic void mod_set_fddata(struct canfd_frame *cf, struct cf_mod *mod)\n{\n\tmemcpy(cf->data, mod->modframe.set.data, CANFD_MAX_DLEN);\n}\n\n \nstatic void mod_retrieve_ccdlc(struct canfd_frame *cf)\n{\n\tstruct can_frame *ccf = (struct can_frame *)cf;\n\n\t \n\tif (ccf->len != CAN_MAX_DLEN)\n\t\treturn;\n\n\t \n\tif (ccf->len8_dlc > CAN_MAX_DLEN && ccf->len8_dlc <= CAN_MAX_RAW_DLC)\n\t\tccf->len = ccf->len8_dlc;\n}\n\n \nstatic void mod_store_ccdlc(struct canfd_frame *cf)\n{\n\tstruct can_frame *ccf = (struct can_frame *)cf;\n\n\t \n\tccf->len8_dlc = 0;\n\n\t \n\tif (ccf->len <= CAN_MAX_DLEN)\n\t\treturn;\n\n\t \n\tif (ccf->len > CAN_MAX_RAW_DLC)\n\t\treturn;\n\n\t \n\tccf->len8_dlc = ccf->len;\n\tccf->len = CAN_MAX_DLEN;\n}\n\nstatic void mod_and_ccdlc(struct canfd_frame *cf, struct cf_mod *mod)\n{\n\tmod_retrieve_ccdlc(cf);\n\tmod_and_len(cf, mod);\n\tmod_store_ccdlc(cf);\n}\n\nstatic void mod_or_ccdlc(struct canfd_frame *cf, struct cf_mod *mod)\n{\n\tmod_retrieve_ccdlc(cf);\n\tmod_or_len(cf, mod);\n\tmod_store_ccdlc(cf);\n}\n\nstatic void mod_xor_ccdlc(struct canfd_frame *cf, struct cf_mod *mod)\n{\n\tmod_retrieve_ccdlc(cf);\n\tmod_xor_len(cf, mod);\n\tmod_store_ccdlc(cf);\n}\n\nstatic void mod_set_ccdlc(struct canfd_frame *cf, struct cf_mod *mod)\n{\n\tmod_set_len(cf, mod);\n\tmod_store_ccdlc(cf);\n}\n\nstatic void canframecpy(struct canfd_frame *dst, struct can_frame *src)\n{\n\t \n\n\tdst->can_id = src->can_id;\n\tdst->len = src->len;\n\t*(u64 *)dst->data = *(u64 *)src->data;\n}\n\nstatic void canfdframecpy(struct canfd_frame *dst, struct canfd_frame *src)\n{\n\t \n\n\tdst->can_id = src->can_id;\n\tdst->flags = src->flags;\n\tdst->len = src->len;\n\tmemcpy(dst->data, src->data, CANFD_MAX_DLEN);\n}\n\nstatic int cgw_chk_csum_parms(s8 fr, s8 to, s8 re, struct rtcanmsg *r)\n{\n\ts8 dlen = CAN_MAX_DLEN;\n\n\tif (r->flags & CGW_FLAGS_CAN_FD)\n\t\tdlen = CANFD_MAX_DLEN;\n\n\t \n\n\tif (fr >= -dlen && fr < dlen &&\n\t    to >= -dlen && to < dlen &&\n\t    re >= -dlen && re < dlen)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic inline int calc_idx(int idx, int rx_len)\n{\n\tif (idx < 0)\n\t\treturn rx_len + idx;\n\telse\n\t\treturn idx;\n}\n\nstatic void cgw_csum_xor_rel(struct canfd_frame *cf, struct cgw_csum_xor *xor)\n{\n\tint from = calc_idx(xor->from_idx, cf->len);\n\tint to = calc_idx(xor->to_idx, cf->len);\n\tint res = calc_idx(xor->result_idx, cf->len);\n\tu8 val = xor->init_xor_val;\n\tint i;\n\n\tif (from < 0 || to < 0 || res < 0)\n\t\treturn;\n\n\tif (from <= to) {\n\t\tfor (i = from; i <= to; i++)\n\t\t\tval ^= cf->data[i];\n\t} else {\n\t\tfor (i = from; i >= to; i--)\n\t\t\tval ^= cf->data[i];\n\t}\n\n\tcf->data[res] = val;\n}\n\nstatic void cgw_csum_xor_pos(struct canfd_frame *cf, struct cgw_csum_xor *xor)\n{\n\tu8 val = xor->init_xor_val;\n\tint i;\n\n\tfor (i = xor->from_idx; i <= xor->to_idx; i++)\n\t\tval ^= cf->data[i];\n\n\tcf->data[xor->result_idx] = val;\n}\n\nstatic void cgw_csum_xor_neg(struct canfd_frame *cf, struct cgw_csum_xor *xor)\n{\n\tu8 val = xor->init_xor_val;\n\tint i;\n\n\tfor (i = xor->from_idx; i >= xor->to_idx; i--)\n\t\tval ^= cf->data[i];\n\n\tcf->data[xor->result_idx] = val;\n}\n\nstatic void cgw_csum_crc8_rel(struct canfd_frame *cf,\n\t\t\t      struct cgw_csum_crc8 *crc8)\n{\n\tint from = calc_idx(crc8->from_idx, cf->len);\n\tint to = calc_idx(crc8->to_idx, cf->len);\n\tint res = calc_idx(crc8->result_idx, cf->len);\n\tu8 crc = crc8->init_crc_val;\n\tint i;\n\n\tif (from < 0 || to < 0 || res < 0)\n\t\treturn;\n\n\tif (from <= to) {\n\t\tfor (i = crc8->from_idx; i <= crc8->to_idx; i++)\n\t\t\tcrc = crc8->crctab[crc ^ cf->data[i]];\n\t} else {\n\t\tfor (i = crc8->from_idx; i >= crc8->to_idx; i--)\n\t\t\tcrc = crc8->crctab[crc ^ cf->data[i]];\n\t}\n\n\tswitch (crc8->profile) {\n\tcase CGW_CRC8PRF_1U8:\n\t\tcrc = crc8->crctab[crc ^ crc8->profile_data[0]];\n\t\tbreak;\n\n\tcase  CGW_CRC8PRF_16U8:\n\t\tcrc = crc8->crctab[crc ^ crc8->profile_data[cf->data[1] & 0xF]];\n\t\tbreak;\n\n\tcase CGW_CRC8PRF_SFFID_XOR:\n\t\tcrc = crc8->crctab[crc ^ (cf->can_id & 0xFF) ^\n\t\t\t\t   (cf->can_id >> 8 & 0xFF)];\n\t\tbreak;\n\t}\n\n\tcf->data[crc8->result_idx] = crc ^ crc8->final_xor_val;\n}\n\nstatic void cgw_csum_crc8_pos(struct canfd_frame *cf,\n\t\t\t      struct cgw_csum_crc8 *crc8)\n{\n\tu8 crc = crc8->init_crc_val;\n\tint i;\n\n\tfor (i = crc8->from_idx; i <= crc8->to_idx; i++)\n\t\tcrc = crc8->crctab[crc ^ cf->data[i]];\n\n\tswitch (crc8->profile) {\n\tcase CGW_CRC8PRF_1U8:\n\t\tcrc = crc8->crctab[crc ^ crc8->profile_data[0]];\n\t\tbreak;\n\n\tcase  CGW_CRC8PRF_16U8:\n\t\tcrc = crc8->crctab[crc ^ crc8->profile_data[cf->data[1] & 0xF]];\n\t\tbreak;\n\n\tcase CGW_CRC8PRF_SFFID_XOR:\n\t\tcrc = crc8->crctab[crc ^ (cf->can_id & 0xFF) ^\n\t\t\t\t   (cf->can_id >> 8 & 0xFF)];\n\t\tbreak;\n\t}\n\n\tcf->data[crc8->result_idx] = crc ^ crc8->final_xor_val;\n}\n\nstatic void cgw_csum_crc8_neg(struct canfd_frame *cf,\n\t\t\t      struct cgw_csum_crc8 *crc8)\n{\n\tu8 crc = crc8->init_crc_val;\n\tint i;\n\n\tfor (i = crc8->from_idx; i >= crc8->to_idx; i--)\n\t\tcrc = crc8->crctab[crc ^ cf->data[i]];\n\n\tswitch (crc8->profile) {\n\tcase CGW_CRC8PRF_1U8:\n\t\tcrc = crc8->crctab[crc ^ crc8->profile_data[0]];\n\t\tbreak;\n\n\tcase  CGW_CRC8PRF_16U8:\n\t\tcrc = crc8->crctab[crc ^ crc8->profile_data[cf->data[1] & 0xF]];\n\t\tbreak;\n\n\tcase CGW_CRC8PRF_SFFID_XOR:\n\t\tcrc = crc8->crctab[crc ^ (cf->can_id & 0xFF) ^\n\t\t\t\t   (cf->can_id >> 8 & 0xFF)];\n\t\tbreak;\n\t}\n\n\tcf->data[crc8->result_idx] = crc ^ crc8->final_xor_val;\n}\n\n \nstatic void can_can_gw_rcv(struct sk_buff *skb, void *data)\n{\n\tstruct cgw_job *gwj = (struct cgw_job *)data;\n\tstruct canfd_frame *cf;\n\tstruct sk_buff *nskb;\n\tint modidx = 0;\n\n\t \n\tif (gwj->flags & CGW_FLAGS_CAN_FD) {\n\t\tif (!can_is_canfd_skb(skb))\n\t\t\treturn;\n\t} else {\n\t\tif (!can_is_can_skb(skb))\n\t\t\treturn;\n\t}\n\n\t \n\n#define cgw_hops(skb) ((skb)->csum_start)\n\n\tBUG_ON(skb->ip_summed != CHECKSUM_UNNECESSARY);\n\n\tif (cgw_hops(skb) >= max_hops) {\n\t\t \n\t\tgwj->deleted_frames++;\n\t\treturn;\n\t}\n\n\tif (!(gwj->dst.dev->flags & IFF_UP)) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\n\t \n\tif (!(gwj->flags & CGW_FLAGS_CAN_IIF_TX_OK) &&\n\t    can_skb_prv(skb)->ifindex == gwj->dst.dev->ifindex)\n\t\treturn;\n\n\t \n\tif (gwj->mod.modfunc[0])\n\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\telse\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (!nskb) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\n\t \n\tcgw_hops(nskb) = cgw_hops(skb) + 1;\n\n\t \n\tif (gwj->limit_hops && cgw_hops(nskb) == 1)\n\t\tcgw_hops(nskb) = max_hops - gwj->limit_hops + 1;\n\n\tnskb->dev = gwj->dst.dev;\n\n\t \n\tcf = (struct canfd_frame *)nskb->data;\n\n\t \n\twhile (modidx < MAX_MODFUNCTIONS && gwj->mod.modfunc[modidx])\n\t\t(*gwj->mod.modfunc[modidx++])(cf, &gwj->mod);\n\n\t \n\tif (modidx) {\n\t\t \n\t\tint max_len = nskb->len - offsetof(struct canfd_frame, data);\n\n\t\t \n\t\tif (cf->len > max_len) {\n\t\t\t \n\t\t\tgwj->deleted_frames++;\n\t\t\tkfree_skb(nskb);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (gwj->mod.csumfunc.crc8)\n\t\t\t(*gwj->mod.csumfunc.crc8)(cf, &gwj->mod.csum.crc8);\n\n\t\tif (gwj->mod.csumfunc.xor)\n\t\t\t(*gwj->mod.csumfunc.xor)(cf, &gwj->mod.csum.xor);\n\t}\n\n\t \n\tif (!(gwj->flags & CGW_FLAGS_CAN_SRC_TSTAMP))\n\t\tnskb->tstamp = 0;\n\n\t \n\tif (can_send(nskb, gwj->flags & CGW_FLAGS_CAN_ECHO))\n\t\tgwj->dropped_frames++;\n\telse\n\t\tgwj->handled_frames++;\n}\n\nstatic inline int cgw_register_filter(struct net *net, struct cgw_job *gwj)\n{\n\treturn can_rx_register(net, gwj->src.dev, gwj->ccgw.filter.can_id,\n\t\t\t       gwj->ccgw.filter.can_mask, can_can_gw_rcv,\n\t\t\t       gwj, \"gw\", NULL);\n}\n\nstatic inline void cgw_unregister_filter(struct net *net, struct cgw_job *gwj)\n{\n\tcan_rx_unregister(net, gwj->src.dev, gwj->ccgw.filter.can_id,\n\t\t\t  gwj->ccgw.filter.can_mask, can_can_gw_rcv, gwj);\n}\n\nstatic void cgw_job_free_rcu(struct rcu_head *rcu_head)\n{\n\tstruct cgw_job *gwj = container_of(rcu_head, struct cgw_job, rcu);\n\n\tkmem_cache_free(cgw_cache, gwj);\n}\n\nstatic int cgw_notifier(struct notifier_block *nb,\n\t\t\tunsigned long msg, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\n\tif (dev->type != ARPHRD_CAN)\n\t\treturn NOTIFY_DONE;\n\n\tif (msg == NETDEV_UNREGISTER) {\n\t\tstruct cgw_job *gwj = NULL;\n\t\tstruct hlist_node *nx;\n\n\t\tASSERT_RTNL();\n\n\t\thlist_for_each_entry_safe(gwj, nx, &net->can.cgw_list, list) {\n\t\t\tif (gwj->src.dev == dev || gwj->dst.dev == dev) {\n\t\t\t\thlist_del(&gwj->list);\n\t\t\t\tcgw_unregister_filter(net, gwj);\n\t\t\t\tcall_rcu(&gwj->rcu, cgw_job_free_rcu);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int cgw_put_job(struct sk_buff *skb, struct cgw_job *gwj, int type,\n\t\t       u32 pid, u32 seq, int flags)\n{\n\tstruct rtcanmsg *rtcan;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*rtcan), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\trtcan = nlmsg_data(nlh);\n\trtcan->can_family = AF_CAN;\n\trtcan->gwtype = gwj->gwtype;\n\trtcan->flags = gwj->flags;\n\n\t \n\n\tif (gwj->handled_frames) {\n\t\tif (nla_put_u32(skb, CGW_HANDLED, gwj->handled_frames) < 0)\n\t\t\tgoto cancel;\n\t}\n\n\tif (gwj->dropped_frames) {\n\t\tif (nla_put_u32(skb, CGW_DROPPED, gwj->dropped_frames) < 0)\n\t\t\tgoto cancel;\n\t}\n\n\tif (gwj->deleted_frames) {\n\t\tif (nla_put_u32(skb, CGW_DELETED, gwj->deleted_frames) < 0)\n\t\t\tgoto cancel;\n\t}\n\n\t \n\n\tif (gwj->limit_hops) {\n\t\tif (nla_put_u8(skb, CGW_LIM_HOPS, gwj->limit_hops) < 0)\n\t\t\tgoto cancel;\n\t}\n\n\tif (gwj->flags & CGW_FLAGS_CAN_FD) {\n\t\tstruct cgw_fdframe_mod mb;\n\n\t\tif (gwj->mod.modtype.and) {\n\t\t\tmemcpy(&mb.cf, &gwj->mod.modframe.and, sizeof(mb.cf));\n\t\t\tmb.modtype = gwj->mod.modtype.and;\n\t\t\tif (nla_put(skb, CGW_FDMOD_AND, sizeof(mb), &mb) < 0)\n\t\t\t\tgoto cancel;\n\t\t}\n\n\t\tif (gwj->mod.modtype.or) {\n\t\t\tmemcpy(&mb.cf, &gwj->mod.modframe.or, sizeof(mb.cf));\n\t\t\tmb.modtype = gwj->mod.modtype.or;\n\t\t\tif (nla_put(skb, CGW_FDMOD_OR, sizeof(mb), &mb) < 0)\n\t\t\t\tgoto cancel;\n\t\t}\n\n\t\tif (gwj->mod.modtype.xor) {\n\t\t\tmemcpy(&mb.cf, &gwj->mod.modframe.xor, sizeof(mb.cf));\n\t\t\tmb.modtype = gwj->mod.modtype.xor;\n\t\t\tif (nla_put(skb, CGW_FDMOD_XOR, sizeof(mb), &mb) < 0)\n\t\t\t\tgoto cancel;\n\t\t}\n\n\t\tif (gwj->mod.modtype.set) {\n\t\t\tmemcpy(&mb.cf, &gwj->mod.modframe.set, sizeof(mb.cf));\n\t\t\tmb.modtype = gwj->mod.modtype.set;\n\t\t\tif (nla_put(skb, CGW_FDMOD_SET, sizeof(mb), &mb) < 0)\n\t\t\t\tgoto cancel;\n\t\t}\n\t} else {\n\t\tstruct cgw_frame_mod mb;\n\n\t\tif (gwj->mod.modtype.and) {\n\t\t\tmemcpy(&mb.cf, &gwj->mod.modframe.and, sizeof(mb.cf));\n\t\t\tmb.modtype = gwj->mod.modtype.and;\n\t\t\tif (nla_put(skb, CGW_MOD_AND, sizeof(mb), &mb) < 0)\n\t\t\t\tgoto cancel;\n\t\t}\n\n\t\tif (gwj->mod.modtype.or) {\n\t\t\tmemcpy(&mb.cf, &gwj->mod.modframe.or, sizeof(mb.cf));\n\t\t\tmb.modtype = gwj->mod.modtype.or;\n\t\t\tif (nla_put(skb, CGW_MOD_OR, sizeof(mb), &mb) < 0)\n\t\t\t\tgoto cancel;\n\t\t}\n\n\t\tif (gwj->mod.modtype.xor) {\n\t\t\tmemcpy(&mb.cf, &gwj->mod.modframe.xor, sizeof(mb.cf));\n\t\t\tmb.modtype = gwj->mod.modtype.xor;\n\t\t\tif (nla_put(skb, CGW_MOD_XOR, sizeof(mb), &mb) < 0)\n\t\t\t\tgoto cancel;\n\t\t}\n\n\t\tif (gwj->mod.modtype.set) {\n\t\t\tmemcpy(&mb.cf, &gwj->mod.modframe.set, sizeof(mb.cf));\n\t\t\tmb.modtype = gwj->mod.modtype.set;\n\t\t\tif (nla_put(skb, CGW_MOD_SET, sizeof(mb), &mb) < 0)\n\t\t\t\tgoto cancel;\n\t\t}\n\t}\n\n\tif (gwj->mod.uid) {\n\t\tif (nla_put_u32(skb, CGW_MOD_UID, gwj->mod.uid) < 0)\n\t\t\tgoto cancel;\n\t}\n\n\tif (gwj->mod.csumfunc.crc8) {\n\t\tif (nla_put(skb, CGW_CS_CRC8, CGW_CS_CRC8_LEN,\n\t\t\t    &gwj->mod.csum.crc8) < 0)\n\t\t\tgoto cancel;\n\t}\n\n\tif (gwj->mod.csumfunc.xor) {\n\t\tif (nla_put(skb, CGW_CS_XOR, CGW_CS_XOR_LEN,\n\t\t\t    &gwj->mod.csum.xor) < 0)\n\t\t\tgoto cancel;\n\t}\n\n\tif (gwj->gwtype == CGW_TYPE_CAN_CAN) {\n\t\tif (gwj->ccgw.filter.can_id || gwj->ccgw.filter.can_mask) {\n\t\t\tif (nla_put(skb, CGW_FILTER, sizeof(struct can_filter),\n\t\t\t\t    &gwj->ccgw.filter) < 0)\n\t\t\t\tgoto cancel;\n\t\t}\n\n\t\tif (nla_put_u32(skb, CGW_SRC_IF, gwj->ccgw.src_idx) < 0)\n\t\t\tgoto cancel;\n\n\t\tif (nla_put_u32(skb, CGW_DST_IF, gwj->ccgw.dst_idx) < 0)\n\t\t\tgoto cancel;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\n \nstatic int cgw_dump_jobs(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct cgw_job *gwj = NULL;\n\tint idx = 0;\n\tint s_idx = cb->args[0];\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(gwj, &net->can.cgw_list, list) {\n\t\tif (idx < s_idx)\n\t\t\tgoto cont;\n\n\t\tif (cgw_put_job(skb, gwj, RTM_NEWROUTE,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI) < 0)\n\t\t\tbreak;\ncont:\n\t\tidx++;\n\t}\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}\n\nstatic const struct nla_policy cgw_policy[CGW_MAX + 1] = {\n\t[CGW_MOD_AND]\t= { .len = sizeof(struct cgw_frame_mod) },\n\t[CGW_MOD_OR]\t= { .len = sizeof(struct cgw_frame_mod) },\n\t[CGW_MOD_XOR]\t= { .len = sizeof(struct cgw_frame_mod) },\n\t[CGW_MOD_SET]\t= { .len = sizeof(struct cgw_frame_mod) },\n\t[CGW_CS_XOR]\t= { .len = sizeof(struct cgw_csum_xor) },\n\t[CGW_CS_CRC8]\t= { .len = sizeof(struct cgw_csum_crc8) },\n\t[CGW_SRC_IF]\t= { .type = NLA_U32 },\n\t[CGW_DST_IF]\t= { .type = NLA_U32 },\n\t[CGW_FILTER]\t= { .len = sizeof(struct can_filter) },\n\t[CGW_LIM_HOPS]\t= { .type = NLA_U8 },\n\t[CGW_MOD_UID]\t= { .type = NLA_U32 },\n\t[CGW_FDMOD_AND]\t= { .len = sizeof(struct cgw_fdframe_mod) },\n\t[CGW_FDMOD_OR]\t= { .len = sizeof(struct cgw_fdframe_mod) },\n\t[CGW_FDMOD_XOR]\t= { .len = sizeof(struct cgw_fdframe_mod) },\n\t[CGW_FDMOD_SET]\t= { .len = sizeof(struct cgw_fdframe_mod) },\n};\n\n \nstatic int cgw_parse_attr(struct nlmsghdr *nlh, struct cf_mod *mod,\n\t\t\t  u8 gwtype, void *gwtypeattr, u8 *limhops)\n{\n\tstruct nlattr *tb[CGW_MAX + 1];\n\tstruct rtcanmsg *r = nlmsg_data(nlh);\n\tint modidx = 0;\n\tint err = 0;\n\n\t \n\tmemset(mod, 0, sizeof(*mod));\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(struct rtcanmsg), tb,\n\t\t\t\t     CGW_MAX, cgw_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[CGW_LIM_HOPS]) {\n\t\t*limhops = nla_get_u8(tb[CGW_LIM_HOPS]);\n\n\t\tif (*limhops < 1 || *limhops > max_hops)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (r->flags & CGW_FLAGS_CAN_FD) {\n\t\tstruct cgw_fdframe_mod mb;\n\n\t\tif (tb[CGW_FDMOD_AND]) {\n\t\t\tnla_memcpy(&mb, tb[CGW_FDMOD_AND], CGW_FDMODATTR_LEN);\n\n\t\t\tcanfdframecpy(&mod->modframe.and, &mb.cf);\n\t\t\tmod->modtype.and = mb.modtype;\n\n\t\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\t\tmod->modfunc[modidx++] = mod_and_id;\n\n\t\t\tif (mb.modtype & CGW_MOD_LEN)\n\t\t\t\tmod->modfunc[modidx++] = mod_and_len;\n\n\t\t\tif (mb.modtype & CGW_MOD_FLAGS)\n\t\t\t\tmod->modfunc[modidx++] = mod_and_flags;\n\n\t\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\t\tmod->modfunc[modidx++] = mod_and_fddata;\n\t\t}\n\n\t\tif (tb[CGW_FDMOD_OR]) {\n\t\t\tnla_memcpy(&mb, tb[CGW_FDMOD_OR], CGW_FDMODATTR_LEN);\n\n\t\t\tcanfdframecpy(&mod->modframe.or, &mb.cf);\n\t\t\tmod->modtype.or = mb.modtype;\n\n\t\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\t\tmod->modfunc[modidx++] = mod_or_id;\n\n\t\t\tif (mb.modtype & CGW_MOD_LEN)\n\t\t\t\tmod->modfunc[modidx++] = mod_or_len;\n\n\t\t\tif (mb.modtype & CGW_MOD_FLAGS)\n\t\t\t\tmod->modfunc[modidx++] = mod_or_flags;\n\n\t\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\t\tmod->modfunc[modidx++] = mod_or_fddata;\n\t\t}\n\n\t\tif (tb[CGW_FDMOD_XOR]) {\n\t\t\tnla_memcpy(&mb, tb[CGW_FDMOD_XOR], CGW_FDMODATTR_LEN);\n\n\t\t\tcanfdframecpy(&mod->modframe.xor, &mb.cf);\n\t\t\tmod->modtype.xor = mb.modtype;\n\n\t\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\t\tmod->modfunc[modidx++] = mod_xor_id;\n\n\t\t\tif (mb.modtype & CGW_MOD_LEN)\n\t\t\t\tmod->modfunc[modidx++] = mod_xor_len;\n\n\t\t\tif (mb.modtype & CGW_MOD_FLAGS)\n\t\t\t\tmod->modfunc[modidx++] = mod_xor_flags;\n\n\t\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\t\tmod->modfunc[modidx++] = mod_xor_fddata;\n\t\t}\n\n\t\tif (tb[CGW_FDMOD_SET]) {\n\t\t\tnla_memcpy(&mb, tb[CGW_FDMOD_SET], CGW_FDMODATTR_LEN);\n\n\t\t\tcanfdframecpy(&mod->modframe.set, &mb.cf);\n\t\t\tmod->modtype.set = mb.modtype;\n\n\t\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\t\tmod->modfunc[modidx++] = mod_set_id;\n\n\t\t\tif (mb.modtype & CGW_MOD_LEN)\n\t\t\t\tmod->modfunc[modidx++] = mod_set_len;\n\n\t\t\tif (mb.modtype & CGW_MOD_FLAGS)\n\t\t\t\tmod->modfunc[modidx++] = mod_set_flags;\n\n\t\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\t\tmod->modfunc[modidx++] = mod_set_fddata;\n\t\t}\n\t} else {\n\t\tstruct cgw_frame_mod mb;\n\n\t\tif (tb[CGW_MOD_AND]) {\n\t\t\tnla_memcpy(&mb, tb[CGW_MOD_AND], CGW_MODATTR_LEN);\n\n\t\t\tcanframecpy(&mod->modframe.and, &mb.cf);\n\t\t\tmod->modtype.and = mb.modtype;\n\n\t\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\t\tmod->modfunc[modidx++] = mod_and_id;\n\n\t\t\tif (mb.modtype & CGW_MOD_DLC)\n\t\t\t\tmod->modfunc[modidx++] = mod_and_ccdlc;\n\n\t\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\t\tmod->modfunc[modidx++] = mod_and_data;\n\t\t}\n\n\t\tif (tb[CGW_MOD_OR]) {\n\t\t\tnla_memcpy(&mb, tb[CGW_MOD_OR], CGW_MODATTR_LEN);\n\n\t\t\tcanframecpy(&mod->modframe.or, &mb.cf);\n\t\t\tmod->modtype.or = mb.modtype;\n\n\t\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\t\tmod->modfunc[modidx++] = mod_or_id;\n\n\t\t\tif (mb.modtype & CGW_MOD_DLC)\n\t\t\t\tmod->modfunc[modidx++] = mod_or_ccdlc;\n\n\t\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\t\tmod->modfunc[modidx++] = mod_or_data;\n\t\t}\n\n\t\tif (tb[CGW_MOD_XOR]) {\n\t\t\tnla_memcpy(&mb, tb[CGW_MOD_XOR], CGW_MODATTR_LEN);\n\n\t\t\tcanframecpy(&mod->modframe.xor, &mb.cf);\n\t\t\tmod->modtype.xor = mb.modtype;\n\n\t\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\t\tmod->modfunc[modidx++] = mod_xor_id;\n\n\t\t\tif (mb.modtype & CGW_MOD_DLC)\n\t\t\t\tmod->modfunc[modidx++] = mod_xor_ccdlc;\n\n\t\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\t\tmod->modfunc[modidx++] = mod_xor_data;\n\t\t}\n\n\t\tif (tb[CGW_MOD_SET]) {\n\t\t\tnla_memcpy(&mb, tb[CGW_MOD_SET], CGW_MODATTR_LEN);\n\n\t\t\tcanframecpy(&mod->modframe.set, &mb.cf);\n\t\t\tmod->modtype.set = mb.modtype;\n\n\t\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\t\tmod->modfunc[modidx++] = mod_set_id;\n\n\t\t\tif (mb.modtype & CGW_MOD_DLC)\n\t\t\t\tmod->modfunc[modidx++] = mod_set_ccdlc;\n\n\t\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\t\tmod->modfunc[modidx++] = mod_set_data;\n\t\t}\n\t}\n\n\t \n\tif (modidx) {\n\t\tif (tb[CGW_CS_CRC8]) {\n\t\t\tstruct cgw_csum_crc8 *c = nla_data(tb[CGW_CS_CRC8]);\n\n\t\t\terr = cgw_chk_csum_parms(c->from_idx, c->to_idx,\n\t\t\t\t\t\t c->result_idx, r);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tnla_memcpy(&mod->csum.crc8, tb[CGW_CS_CRC8],\n\t\t\t\t   CGW_CS_CRC8_LEN);\n\n\t\t\t \n\t\t\tif (c->from_idx < 0 || c->to_idx < 0 ||\n\t\t\t    c->result_idx < 0)\n\t\t\t\tmod->csumfunc.crc8 = cgw_csum_crc8_rel;\n\t\t\telse if (c->from_idx <= c->to_idx)\n\t\t\t\tmod->csumfunc.crc8 = cgw_csum_crc8_pos;\n\t\t\telse\n\t\t\t\tmod->csumfunc.crc8 = cgw_csum_crc8_neg;\n\t\t}\n\n\t\tif (tb[CGW_CS_XOR]) {\n\t\t\tstruct cgw_csum_xor *c = nla_data(tb[CGW_CS_XOR]);\n\n\t\t\terr = cgw_chk_csum_parms(c->from_idx, c->to_idx,\n\t\t\t\t\t\t c->result_idx, r);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tnla_memcpy(&mod->csum.xor, tb[CGW_CS_XOR],\n\t\t\t\t   CGW_CS_XOR_LEN);\n\n\t\t\t \n\t\t\tif (c->from_idx < 0 || c->to_idx < 0 ||\n\t\t\t    c->result_idx < 0)\n\t\t\t\tmod->csumfunc.xor = cgw_csum_xor_rel;\n\t\t\telse if (c->from_idx <= c->to_idx)\n\t\t\t\tmod->csumfunc.xor = cgw_csum_xor_pos;\n\t\t\telse\n\t\t\t\tmod->csumfunc.xor = cgw_csum_xor_neg;\n\t\t}\n\n\t\tif (tb[CGW_MOD_UID])\n\t\t\tnla_memcpy(&mod->uid, tb[CGW_MOD_UID], sizeof(u32));\n\t}\n\n\tif (gwtype == CGW_TYPE_CAN_CAN) {\n\t\t \n\t\tstruct can_can_gw *ccgw = (struct can_can_gw *)gwtypeattr;\n\n\t\tmemset(ccgw, 0, sizeof(*ccgw));\n\n\t\t \n\t\tif (tb[CGW_FILTER])\n\t\t\tnla_memcpy(&ccgw->filter, tb[CGW_FILTER],\n\t\t\t\t   sizeof(struct can_filter));\n\n\t\terr = -ENODEV;\n\n\t\t \n\t\tif (!tb[CGW_SRC_IF] || !tb[CGW_DST_IF])\n\t\t\treturn err;\n\n\t\tccgw->src_idx = nla_get_u32(tb[CGW_SRC_IF]);\n\t\tccgw->dst_idx = nla_get_u32(tb[CGW_DST_IF]);\n\n\t\t \n\t\tif (!ccgw->src_idx && !ccgw->dst_idx)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!ccgw->src_idx || !ccgw->dst_idx)\n\t\t\treturn err;\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic int cgw_create_job(struct sk_buff *skb,  struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct rtcanmsg *r;\n\tstruct cgw_job *gwj;\n\tstruct cf_mod mod;\n\tstruct can_can_gw ccgw;\n\tu8 limhops = 0;\n\tint err = 0;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (nlmsg_len(nlh) < sizeof(*r))\n\t\treturn -EINVAL;\n\n\tr = nlmsg_data(nlh);\n\tif (r->can_family != AF_CAN)\n\t\treturn -EPFNOSUPPORT;\n\n\t \n\tif (r->gwtype != CGW_TYPE_CAN_CAN)\n\t\treturn -EINVAL;\n\n\terr = cgw_parse_attr(nlh, &mod, CGW_TYPE_CAN_CAN, &ccgw, &limhops);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (mod.uid) {\n\t\tASSERT_RTNL();\n\n\t\t \n\t\thlist_for_each_entry(gwj, &net->can.cgw_list, list) {\n\t\t\tif (gwj->mod.uid != mod.uid)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (memcmp(&gwj->ccgw, &ccgw, sizeof(ccgw)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tlocal_bh_disable();\n\t\t\tmemcpy(&gwj->mod, &mod, sizeof(mod));\n\t\t\tlocal_bh_enable();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (!ccgw.src_idx || !ccgw.dst_idx)\n\t\treturn -ENODEV;\n\n\tgwj = kmem_cache_alloc(cgw_cache, GFP_KERNEL);\n\tif (!gwj)\n\t\treturn -ENOMEM;\n\n\tgwj->handled_frames = 0;\n\tgwj->dropped_frames = 0;\n\tgwj->deleted_frames = 0;\n\tgwj->flags = r->flags;\n\tgwj->gwtype = r->gwtype;\n\tgwj->limit_hops = limhops;\n\n\t \n\tmemcpy(&gwj->mod, &mod, sizeof(mod));\n\tmemcpy(&gwj->ccgw, &ccgw, sizeof(ccgw));\n\n\terr = -ENODEV;\n\n\tgwj->src.dev = __dev_get_by_index(net, gwj->ccgw.src_idx);\n\n\tif (!gwj->src.dev)\n\t\tgoto out;\n\n\tif (gwj->src.dev->type != ARPHRD_CAN)\n\t\tgoto out;\n\n\tgwj->dst.dev = __dev_get_by_index(net, gwj->ccgw.dst_idx);\n\n\tif (!gwj->dst.dev)\n\t\tgoto out;\n\n\tif (gwj->dst.dev->type != ARPHRD_CAN)\n\t\tgoto out;\n\n\t \n\tif (gwj->src.dev == gwj->dst.dev &&\n\t    !(gwj->flags & CGW_FLAGS_CAN_IIF_TX_OK)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tASSERT_RTNL();\n\n\terr = cgw_register_filter(net, gwj);\n\tif (!err)\n\t\thlist_add_head_rcu(&gwj->list, &net->can.cgw_list);\nout:\n\tif (err)\n\t\tkmem_cache_free(cgw_cache, gwj);\n\n\treturn err;\n}\n\nstatic void cgw_remove_all_jobs(struct net *net)\n{\n\tstruct cgw_job *gwj = NULL;\n\tstruct hlist_node *nx;\n\n\tASSERT_RTNL();\n\n\thlist_for_each_entry_safe(gwj, nx, &net->can.cgw_list, list) {\n\t\thlist_del(&gwj->list);\n\t\tcgw_unregister_filter(net, gwj);\n\t\tcall_rcu(&gwj->rcu, cgw_job_free_rcu);\n\t}\n}\n\nstatic int cgw_remove_job(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct cgw_job *gwj = NULL;\n\tstruct hlist_node *nx;\n\tstruct rtcanmsg *r;\n\tstruct cf_mod mod;\n\tstruct can_can_gw ccgw;\n\tu8 limhops = 0;\n\tint err = 0;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (nlmsg_len(nlh) < sizeof(*r))\n\t\treturn -EINVAL;\n\n\tr = nlmsg_data(nlh);\n\tif (r->can_family != AF_CAN)\n\t\treturn -EPFNOSUPPORT;\n\n\t \n\tif (r->gwtype != CGW_TYPE_CAN_CAN)\n\t\treturn -EINVAL;\n\n\terr = cgw_parse_attr(nlh, &mod, CGW_TYPE_CAN_CAN, &ccgw, &limhops);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!ccgw.src_idx && !ccgw.dst_idx) {\n\t\tcgw_remove_all_jobs(net);\n\t\treturn 0;\n\t}\n\n\terr = -EINVAL;\n\n\tASSERT_RTNL();\n\n\t \n\thlist_for_each_entry_safe(gwj, nx, &net->can.cgw_list, list) {\n\t\tif (gwj->flags != r->flags)\n\t\t\tcontinue;\n\n\t\tif (gwj->limit_hops != limhops)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (gwj->mod.uid || mod.uid) {\n\t\t\tif (gwj->mod.uid != mod.uid)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tif (memcmp(&gwj->mod, &mod, sizeof(mod)))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (memcmp(&gwj->ccgw, &ccgw, sizeof(ccgw)))\n\t\t\tcontinue;\n\n\t\thlist_del(&gwj->list);\n\t\tcgw_unregister_filter(net, gwj);\n\t\tcall_rcu(&gwj->rcu, cgw_job_free_rcu);\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int __net_init cangw_pernet_init(struct net *net)\n{\n\tINIT_HLIST_HEAD(&net->can.cgw_list);\n\treturn 0;\n}\n\nstatic void __net_exit cangw_pernet_exit_batch(struct list_head *net_list)\n{\n\tstruct net *net;\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list)\n\t\tcgw_remove_all_jobs(net);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations cangw_pernet_ops = {\n\t.init = cangw_pernet_init,\n\t.exit_batch = cangw_pernet_exit_batch,\n};\n\nstatic __init int cgw_module_init(void)\n{\n\tint ret;\n\n\t \n\tmax_hops = clamp_t(unsigned int, max_hops, CGW_MIN_HOPS, CGW_MAX_HOPS);\n\n\tpr_info(\"can: netlink gateway - max_hops=%d\\n\",\tmax_hops);\n\n\tret = register_pernet_subsys(&cangw_pernet_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ENOMEM;\n\tcgw_cache = kmem_cache_create(\"can_gw\", sizeof(struct cgw_job),\n\t\t\t\t      0, 0, NULL);\n\tif (!cgw_cache)\n\t\tgoto out_cache_create;\n\n\t \n\tnotifier.notifier_call = cgw_notifier;\n\tret = register_netdevice_notifier(&notifier);\n\tif (ret)\n\t\tgoto out_register_notifier;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_CAN, RTM_GETROUTE,\n\t\t\t\t   NULL, cgw_dump_jobs, 0);\n\tif (ret)\n\t\tgoto out_rtnl_register1;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_CAN, RTM_NEWROUTE,\n\t\t\t\t   cgw_create_job, NULL, 0);\n\tif (ret)\n\t\tgoto out_rtnl_register2;\n\tret = rtnl_register_module(THIS_MODULE, PF_CAN, RTM_DELROUTE,\n\t\t\t\t   cgw_remove_job, NULL, 0);\n\tif (ret)\n\t\tgoto out_rtnl_register3;\n\n\treturn 0;\n\nout_rtnl_register3:\n\trtnl_unregister(PF_CAN, RTM_NEWROUTE);\nout_rtnl_register2:\n\trtnl_unregister(PF_CAN, RTM_GETROUTE);\nout_rtnl_register1:\n\tunregister_netdevice_notifier(&notifier);\nout_register_notifier:\n\tkmem_cache_destroy(cgw_cache);\nout_cache_create:\n\tunregister_pernet_subsys(&cangw_pernet_ops);\n\n\treturn ret;\n}\n\nstatic __exit void cgw_module_exit(void)\n{\n\trtnl_unregister_all(PF_CAN);\n\n\tunregister_netdevice_notifier(&notifier);\n\n\tunregister_pernet_subsys(&cangw_pernet_ops);\n\trcu_barrier();  \n\n\tkmem_cache_destroy(cgw_cache);\n}\n\nmodule_init(cgw_module_init);\nmodule_exit(cgw_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}