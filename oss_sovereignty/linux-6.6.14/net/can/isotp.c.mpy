{
  "module_name": "isotp.c",
  "hash_id": "968d164cd378da8451ab4dc1f5b24a7797385561b6beb8d8b07d88ee7113a0e5",
  "original_prompt": "Ingested from linux-6.6.14/net/can/isotp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/hrtimer.h>\n#include <linux/wait.h>\n#include <linux/uio.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/socket.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/can.h>\n#include <linux/can/core.h>\n#include <linux/can/skb.h>\n#include <linux/can/isotp.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/net_namespace.h>\n\nMODULE_DESCRIPTION(\"PF_CAN isotp 15765-2:2016 protocol\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Oliver Hartkopp <socketcan@hartkopp.net>\");\nMODULE_ALIAS(\"can-proto-6\");\n\n#define ISOTP_MIN_NAMELEN CAN_REQUIRED_SIZE(struct sockaddr_can, can_addr.tp)\n\n#define SINGLE_MASK(id) (((id) & CAN_EFF_FLAG) ? \\\n\t\t\t (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG) : \\\n\t\t\t (CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG))\n\n \n#define DEFAULT_MAX_PDU_SIZE 8300\n\n \n#define MAX_12BIT_PDU_SIZE 4095\n\n \n#define MAX_PDU_SIZE (1025 * 1024U)\n\nstatic unsigned int max_pdu_size __read_mostly = DEFAULT_MAX_PDU_SIZE;\nmodule_param(max_pdu_size, uint, 0444);\nMODULE_PARM_DESC(max_pdu_size, \"maximum isotp pdu size (default \"\n\t\t __stringify(DEFAULT_MAX_PDU_SIZE) \")\");\n\n \n#define N_PCI_SF 0x00\t \n#define N_PCI_FF 0x10\t \n#define N_PCI_CF 0x20\t \n#define N_PCI_FC 0x30\t \n\n#define N_PCI_SZ 1\t \n#define SF_PCI_SZ4 1\t \n#define SF_PCI_SZ8 2\t \n#define FF_PCI_SZ12 2\t \n#define FF_PCI_SZ32 6\t \n#define FC_CONTENT_SZ 3\t \n\n#define ISOTP_CHECK_PADDING (CAN_ISOTP_CHK_PAD_LEN | CAN_ISOTP_CHK_PAD_DATA)\n#define ISOTP_ALL_BC_FLAGS (CAN_ISOTP_SF_BROADCAST | CAN_ISOTP_CF_BROADCAST)\n\n \n#define ISOTP_FC_CTS 0\t\t \n#define ISOTP_FC_WT 1\t\t \n#define ISOTP_FC_OVFLW 2\t \n\n#define ISOTP_FC_TIMEOUT 1\t \n#define ISOTP_ECHO_TIMEOUT 2\t \n\nenum {\n\tISOTP_IDLE = 0,\n\tISOTP_WAIT_FIRST_FC,\n\tISOTP_WAIT_FC,\n\tISOTP_WAIT_DATA,\n\tISOTP_SENDING,\n\tISOTP_SHUTDOWN,\n};\n\nstruct tpcon {\n\tu8 *buf;\n\tunsigned int buflen;\n\tunsigned int len;\n\tunsigned int idx;\n\tu32 state;\n\tu8 bs;\n\tu8 sn;\n\tu8 ll_dl;\n\tu8 sbuf[DEFAULT_MAX_PDU_SIZE];\n};\n\nstruct isotp_sock {\n\tstruct sock sk;\n\tint bound;\n\tint ifindex;\n\tcanid_t txid;\n\tcanid_t rxid;\n\tktime_t tx_gap;\n\tktime_t lastrxcf_tstamp;\n\tstruct hrtimer rxtimer, txtimer, txfrtimer;\n\tstruct can_isotp_options opt;\n\tstruct can_isotp_fc_options rxfc, txfc;\n\tstruct can_isotp_ll_options ll;\n\tu32 frame_txtime;\n\tu32 force_tx_stmin;\n\tu32 force_rx_stmin;\n\tu32 cfecho;  \n\tstruct tpcon rx, tx;\n\tstruct list_head notifier;\n\twait_queue_head_t wait;\n\tspinlock_t rx_lock;  \n};\n\nstatic LIST_HEAD(isotp_notifier_list);\nstatic DEFINE_SPINLOCK(isotp_notifier_lock);\nstatic struct isotp_sock *isotp_busy_notifier;\n\nstatic inline struct isotp_sock *isotp_sk(const struct sock *sk)\n{\n\treturn (struct isotp_sock *)sk;\n}\n\nstatic u32 isotp_bc_flags(struct isotp_sock *so)\n{\n\treturn so->opt.flags & ISOTP_ALL_BC_FLAGS;\n}\n\nstatic bool isotp_register_rxid(struct isotp_sock *so)\n{\n\t \n\treturn (isotp_bc_flags(so) == 0);\n}\n\nstatic enum hrtimer_restart isotp_rx_timer_handler(struct hrtimer *hrtimer)\n{\n\tstruct isotp_sock *so = container_of(hrtimer, struct isotp_sock,\n\t\t\t\t\t     rxtimer);\n\tstruct sock *sk = &so->sk;\n\n\tif (so->rx.state == ISOTP_WAIT_DATA) {\n\t\t \n\n\t\t \n\t\tsk->sk_err = ETIMEDOUT;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\n\t\t \n\t\tso->rx.state = ISOTP_IDLE;\n\t}\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic int isotp_send_fc(struct sock *sk, int ae, u8 flowstatus)\n{\n\tstruct net_device *dev;\n\tstruct sk_buff *nskb;\n\tstruct canfd_frame *ncf;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tint can_send_ret;\n\n\tnskb = alloc_skb(so->ll.mtu + sizeof(struct can_skb_priv), gfp_any());\n\tif (!nskb)\n\t\treturn 1;\n\n\tdev = dev_get_by_index(sock_net(sk), so->ifindex);\n\tif (!dev) {\n\t\tkfree_skb(nskb);\n\t\treturn 1;\n\t}\n\n\tcan_skb_reserve(nskb);\n\tcan_skb_prv(nskb)->ifindex = dev->ifindex;\n\tcan_skb_prv(nskb)->skbcnt = 0;\n\n\tnskb->dev = dev;\n\tcan_skb_set_owner(nskb, sk);\n\tncf = (struct canfd_frame *)nskb->data;\n\tskb_put_zero(nskb, so->ll.mtu);\n\n\t \n\tncf->can_id = so->txid;\n\n\tif (so->opt.flags & CAN_ISOTP_TX_PADDING) {\n\t\tmemset(ncf->data, so->opt.txpad_content, CAN_MAX_DLEN);\n\t\tncf->len = CAN_MAX_DLEN;\n\t} else {\n\t\tncf->len = ae + FC_CONTENT_SZ;\n\t}\n\n\tncf->data[ae] = N_PCI_FC | flowstatus;\n\tncf->data[ae + 1] = so->rxfc.bs;\n\tncf->data[ae + 2] = so->rxfc.stmin;\n\n\tif (ae)\n\t\tncf->data[0] = so->opt.ext_address;\n\n\tncf->flags = so->ll.tx_flags;\n\n\tcan_send_ret = can_send(nskb, 1);\n\tif (can_send_ret)\n\t\tpr_notice_once(\"can-isotp: %s: can_send_ret %pe\\n\",\n\t\t\t       __func__, ERR_PTR(can_send_ret));\n\n\tdev_put(dev);\n\n\t \n\tso->rx.bs = 0;\n\n\t \n\tso->lastrxcf_tstamp = ktime_set(0, 0);\n\n\t \n\thrtimer_start(&so->rxtimer, ktime_set(ISOTP_FC_TIMEOUT, 0),\n\t\t      HRTIMER_MODE_REL_SOFT);\n\treturn 0;\n}\n\nstatic void isotp_rcv_skb(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)skb->cb;\n\n\tBUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct sockaddr_can));\n\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->can_family = AF_CAN;\n\taddr->can_ifindex = skb->dev->ifindex;\n\n\tif (sock_queue_rcv_skb(sk, skb) < 0)\n\t\tkfree_skb(skb);\n}\n\nstatic u8 padlen(u8 datalen)\n{\n\tstatic const u8 plen[] = {\n\t\t8, 8, 8, 8, 8, 8, 8, 8, 8,\t \n\t\t12, 12, 12, 12,\t\t\t \n\t\t16, 16, 16, 16,\t\t\t \n\t\t20, 20, 20, 20,\t\t\t \n\t\t24, 24, 24, 24,\t\t\t \n\t\t32, 32, 32, 32, 32, 32, 32, 32,\t \n\t\t48, 48, 48, 48, 48, 48, 48, 48,\t \n\t\t48, 48, 48, 48, 48, 48, 48, 48\t \n\t};\n\n\tif (datalen > 48)\n\t\treturn 64;\n\n\treturn plen[datalen];\n}\n\n \nstatic int check_optimized(struct canfd_frame *cf, int start_index)\n{\n\t \n\tif (cf->len <= CAN_MAX_DLEN)\n\t\treturn (cf->len != start_index);\n\n\t \n\treturn (cf->len != padlen(start_index));\n}\n\n \nstatic int check_pad(struct isotp_sock *so, struct canfd_frame *cf,\n\t\t     int start_index, u8 content)\n{\n\tint i;\n\n\t \n\tif (!(so->opt.flags & CAN_ISOTP_RX_PADDING)) {\n\t\tif (so->opt.flags & CAN_ISOTP_CHK_PAD_LEN)\n\t\t\treturn check_optimized(cf, start_index);\n\n\t\t \n\t\treturn 1;\n\t}\n\n\t \n\tif ((so->opt.flags & CAN_ISOTP_CHK_PAD_LEN) &&\n\t    cf->len != padlen(cf->len))\n\t\treturn 1;\n\n\t \n\tif (so->opt.flags & CAN_ISOTP_CHK_PAD_DATA) {\n\t\tfor (i = start_index; i < cf->len; i++)\n\t\t\tif (cf->data[i] != content)\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void isotp_send_cframe(struct isotp_sock *so);\n\nstatic int isotp_rcv_fc(struct isotp_sock *so, struct canfd_frame *cf, int ae)\n{\n\tstruct sock *sk = &so->sk;\n\n\tif (so->tx.state != ISOTP_WAIT_FC &&\n\t    so->tx.state != ISOTP_WAIT_FIRST_FC)\n\t\treturn 0;\n\n\thrtimer_cancel(&so->txtimer);\n\n\tif ((cf->len < ae + FC_CONTENT_SZ) ||\n\t    ((so->opt.flags & ISOTP_CHECK_PADDING) &&\n\t     check_pad(so, cf, ae + FC_CONTENT_SZ, so->opt.rxpad_content))) {\n\t\t \n\t\tsk->sk_err = EBADMSG;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\n\t\tso->tx.state = ISOTP_IDLE;\n\t\twake_up_interruptible(&so->wait);\n\t\treturn 1;\n\t}\n\n\t \n\tif (so->tx.state == ISOTP_WAIT_FIRST_FC) {\n\t\tso->txfc.bs = cf->data[ae + 1];\n\t\tso->txfc.stmin = cf->data[ae + 2];\n\n\t\t \n\t\tif (so->txfc.stmin > 0x7F &&\n\t\t    (so->txfc.stmin < 0xF1 || so->txfc.stmin > 0xF9))\n\t\t\tso->txfc.stmin = 0x7F;\n\n\t\tso->tx_gap = ktime_set(0, 0);\n\t\t \n\t\tso->tx_gap = ktime_add_ns(so->tx_gap, so->frame_txtime);\n\t\t \n\t\tif (so->opt.flags & CAN_ISOTP_FORCE_TXSTMIN)\n\t\t\tso->tx_gap = ktime_add_ns(so->tx_gap,\n\t\t\t\t\t\t  so->force_tx_stmin);\n\t\telse if (so->txfc.stmin < 0x80)\n\t\t\tso->tx_gap = ktime_add_ns(so->tx_gap,\n\t\t\t\t\t\t  so->txfc.stmin * 1000000);\n\t\telse\n\t\t\tso->tx_gap = ktime_add_ns(so->tx_gap,\n\t\t\t\t\t\t  (so->txfc.stmin - 0xF0)\n\t\t\t\t\t\t  * 100000);\n\t\tso->tx.state = ISOTP_WAIT_FC;\n\t}\n\n\tswitch (cf->data[ae] & 0x0F) {\n\tcase ISOTP_FC_CTS:\n\t\tso->tx.bs = 0;\n\t\tso->tx.state = ISOTP_SENDING;\n\t\t \n\t\thrtimer_start(&so->txtimer, ktime_set(ISOTP_ECHO_TIMEOUT, 0),\n\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\tisotp_send_cframe(so);\n\t\tbreak;\n\n\tcase ISOTP_FC_WT:\n\t\t \n\t\thrtimer_start(&so->txtimer, ktime_set(ISOTP_FC_TIMEOUT, 0),\n\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\tbreak;\n\n\tcase ISOTP_FC_OVFLW:\n\t\t \n\t\tsk->sk_err = EMSGSIZE;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\t\tfallthrough;\n\n\tdefault:\n\t\t \n\t\tso->tx.state = ISOTP_IDLE;\n\t\twake_up_interruptible(&so->wait);\n\t}\n\treturn 0;\n}\n\nstatic int isotp_rcv_sf(struct sock *sk, struct canfd_frame *cf, int pcilen,\n\t\t\tstruct sk_buff *skb, int len)\n{\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tstruct sk_buff *nskb;\n\n\thrtimer_cancel(&so->rxtimer);\n\tso->rx.state = ISOTP_IDLE;\n\n\tif (!len || len > cf->len - pcilen)\n\t\treturn 1;\n\n\tif ((so->opt.flags & ISOTP_CHECK_PADDING) &&\n\t    check_pad(so, cf, pcilen + len, so->opt.rxpad_content)) {\n\t\t \n\t\tsk->sk_err = EBADMSG;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\t\treturn 1;\n\t}\n\n\tnskb = alloc_skb(len, gfp_any());\n\tif (!nskb)\n\t\treturn 1;\n\n\tmemcpy(skb_put(nskb, len), &cf->data[pcilen], len);\n\n\tnskb->tstamp = skb->tstamp;\n\tnskb->dev = skb->dev;\n\tisotp_rcv_skb(nskb, sk);\n\treturn 0;\n}\n\nstatic int isotp_rcv_ff(struct sock *sk, struct canfd_frame *cf, int ae)\n{\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tint i;\n\tint off;\n\tint ff_pci_sz;\n\n\thrtimer_cancel(&so->rxtimer);\n\tso->rx.state = ISOTP_IDLE;\n\n\t \n\tso->rx.ll_dl = padlen(cf->len);\n\n\t \n\tif (cf->len != so->rx.ll_dl)\n\t\treturn 1;\n\n\t \n\tso->rx.len = (cf->data[ae] & 0x0F) << 8;\n\tso->rx.len += cf->data[ae + 1];\n\n\t \n\tif (so->rx.len) {\n\t\tff_pci_sz = FF_PCI_SZ12;\n\t} else {\n\t\t \n\t\tso->rx.len = cf->data[ae + 2] << 24;\n\t\tso->rx.len += cf->data[ae + 3] << 16;\n\t\tso->rx.len += cf->data[ae + 4] << 8;\n\t\tso->rx.len += cf->data[ae + 5];\n\t\tff_pci_sz = FF_PCI_SZ32;\n\t}\n\n\t \n\toff = (so->rx.ll_dl > CAN_MAX_DLEN) ? 1 : 0;\n\n\tif (so->rx.len + ae + off + ff_pci_sz < so->rx.ll_dl)\n\t\treturn 1;\n\n\t \n\tif (so->rx.len > so->rx.buflen && so->rx.buflen < max_pdu_size) {\n\t\tu8 *newbuf = kmalloc(max_pdu_size, GFP_ATOMIC);\n\n\t\tif (newbuf) {\n\t\t\tso->rx.buf = newbuf;\n\t\t\tso->rx.buflen = max_pdu_size;\n\t\t}\n\t}\n\n\tif (so->rx.len > so->rx.buflen) {\n\t\t \n\t\tisotp_send_fc(sk, ae, ISOTP_FC_OVFLW);\n\t\treturn 1;\n\t}\n\n\t \n\tso->rx.idx = 0;\n\tfor (i = ae + ff_pci_sz; i < so->rx.ll_dl; i++)\n\t\tso->rx.buf[so->rx.idx++] = cf->data[i];\n\n\t \n\tso->rx.sn = 1;\n\tso->rx.state = ISOTP_WAIT_DATA;\n\n\t \n\tif (so->opt.flags & CAN_ISOTP_LISTEN_MODE)\n\t\treturn 0;\n\n\t \n\tisotp_send_fc(sk, ae, ISOTP_FC_CTS);\n\treturn 0;\n}\n\nstatic int isotp_rcv_cf(struct sock *sk, struct canfd_frame *cf, int ae,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tstruct sk_buff *nskb;\n\tint i;\n\n\tif (so->rx.state != ISOTP_WAIT_DATA)\n\t\treturn 0;\n\n\t \n\tif (so->opt.flags & CAN_ISOTP_FORCE_RXSTMIN) {\n\t\tif (ktime_to_ns(ktime_sub(skb->tstamp, so->lastrxcf_tstamp)) <\n\t\t    so->force_rx_stmin)\n\t\t\treturn 0;\n\n\t\tso->lastrxcf_tstamp = skb->tstamp;\n\t}\n\n\thrtimer_cancel(&so->rxtimer);\n\n\t \n\tif (cf->len > so->rx.ll_dl)\n\t\treturn 1;\n\n\t \n\tif (cf->len < so->rx.ll_dl) {\n\t\t \n\t\tif (so->rx.len - so->rx.idx > so->rx.ll_dl - ae - N_PCI_SZ)\n\t\t\treturn 1;\n\t}\n\n\tif ((cf->data[ae] & 0x0F) != so->rx.sn) {\n\t\t \n\t\tsk->sk_err = EILSEQ;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\n\t\t \n\t\tso->rx.state = ISOTP_IDLE;\n\t\treturn 1;\n\t}\n\tso->rx.sn++;\n\tso->rx.sn %= 16;\n\n\tfor (i = ae + N_PCI_SZ; i < cf->len; i++) {\n\t\tso->rx.buf[so->rx.idx++] = cf->data[i];\n\t\tif (so->rx.idx >= so->rx.len)\n\t\t\tbreak;\n\t}\n\n\tif (so->rx.idx >= so->rx.len) {\n\t\t \n\t\tso->rx.state = ISOTP_IDLE;\n\n\t\tif ((so->opt.flags & ISOTP_CHECK_PADDING) &&\n\t\t    check_pad(so, cf, i + 1, so->opt.rxpad_content)) {\n\t\t\t \n\t\t\tsk->sk_err = EBADMSG;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\tsk_error_report(sk);\n\t\t\treturn 1;\n\t\t}\n\n\t\tnskb = alloc_skb(so->rx.len, gfp_any());\n\t\tif (!nskb)\n\t\t\treturn 1;\n\n\t\tmemcpy(skb_put(nskb, so->rx.len), so->rx.buf,\n\t\t       so->rx.len);\n\n\t\tnskb->tstamp = skb->tstamp;\n\t\tnskb->dev = skb->dev;\n\t\tisotp_rcv_skb(nskb, sk);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!so->rxfc.bs || ++so->rx.bs < so->rxfc.bs) {\n\t\t \n\t\thrtimer_start(&so->rxtimer, ktime_set(ISOTP_FC_TIMEOUT, 0),\n\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\treturn 0;\n\t}\n\n\t \n\tif (so->opt.flags & CAN_ISOTP_LISTEN_MODE)\n\t\treturn 0;\n\n\t \n\tisotp_send_fc(sk, ae, ISOTP_FC_CTS);\n\treturn 0;\n}\n\nstatic void isotp_rcv(struct sk_buff *skb, void *data)\n{\n\tstruct sock *sk = (struct sock *)data;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tstruct canfd_frame *cf;\n\tint ae = (so->opt.flags & CAN_ISOTP_EXTEND_ADDR) ? 1 : 0;\n\tu8 n_pci_type, sf_dl;\n\n\t \n\tif (skb->len != so->ll.mtu)\n\t\treturn;\n\n\tcf = (struct canfd_frame *)skb->data;\n\n\t \n\tif (ae && cf->data[0] != so->opt.rx_ext_address)\n\t\treturn;\n\n\tn_pci_type = cf->data[ae] & 0xF0;\n\n\t \n\tspin_lock(&so->rx_lock);\n\n\tif (so->opt.flags & CAN_ISOTP_HALF_DUPLEX) {\n\t\t \n\t\tif ((so->tx.state != ISOTP_IDLE && n_pci_type != N_PCI_FC) ||\n\t\t    (so->rx.state != ISOTP_IDLE && n_pci_type == N_PCI_FC))\n\t\t\tgoto out_unlock;\n\t}\n\n\tswitch (n_pci_type) {\n\tcase N_PCI_FC:\n\t\t \n\t\tisotp_rcv_fc(so, cf, ae);\n\t\tbreak;\n\n\tcase N_PCI_SF:\n\t\t \n\n\t\t \n\t\tsf_dl = cf->data[ae] & 0x0F;\n\n\t\tif (cf->len <= CAN_MAX_DLEN) {\n\t\t\tisotp_rcv_sf(sk, cf, SF_PCI_SZ4 + ae, skb, sf_dl);\n\t\t} else {\n\t\t\tif (can_is_canfd_skb(skb)) {\n\t\t\t\t \n\t\t\t\tif (sf_dl == 0)\n\t\t\t\t\tisotp_rcv_sf(sk, cf, SF_PCI_SZ8 + ae, skb,\n\t\t\t\t\t\t     cf->data[SF_PCI_SZ4 + ae]);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase N_PCI_FF:\n\t\t \n\t\tisotp_rcv_ff(sk, cf, ae);\n\t\tbreak;\n\n\tcase N_PCI_CF:\n\t\t \n\t\tisotp_rcv_cf(sk, cf, ae, skb);\n\t\tbreak;\n\t}\n\nout_unlock:\n\tspin_unlock(&so->rx_lock);\n}\n\nstatic void isotp_fill_dataframe(struct canfd_frame *cf, struct isotp_sock *so,\n\t\t\t\t int ae, int off)\n{\n\tint pcilen = N_PCI_SZ + ae + off;\n\tint space = so->tx.ll_dl - pcilen;\n\tint num = min_t(int, so->tx.len - so->tx.idx, space);\n\tint i;\n\n\tcf->can_id = so->txid;\n\tcf->len = num + pcilen;\n\n\tif (num < space) {\n\t\tif (so->opt.flags & CAN_ISOTP_TX_PADDING) {\n\t\t\t \n\t\t\tcf->len = padlen(cf->len);\n\t\t\tmemset(cf->data, so->opt.txpad_content, cf->len);\n\t\t} else if (cf->len > CAN_MAX_DLEN) {\n\t\t\t \n\t\t\tcf->len = padlen(cf->len);\n\t\t\tmemset(cf->data, CAN_ISOTP_DEFAULT_PAD_CONTENT,\n\t\t\t       cf->len);\n\t\t}\n\t}\n\n\tfor (i = 0; i < num; i++)\n\t\tcf->data[pcilen + i] = so->tx.buf[so->tx.idx++];\n\n\tif (ae)\n\t\tcf->data[0] = so->opt.ext_address;\n}\n\nstatic void isotp_send_cframe(struct isotp_sock *so)\n{\n\tstruct sock *sk = &so->sk;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct canfd_frame *cf;\n\tint can_send_ret;\n\tint ae = (so->opt.flags & CAN_ISOTP_EXTEND_ADDR) ? 1 : 0;\n\n\tdev = dev_get_by_index(sock_net(sk), so->ifindex);\n\tif (!dev)\n\t\treturn;\n\n\tskb = alloc_skb(so->ll.mtu + sizeof(struct can_skb_priv), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_put(dev);\n\t\treturn;\n\t}\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\tcf = (struct canfd_frame *)skb->data;\n\tskb_put_zero(skb, so->ll.mtu);\n\n\t \n\tisotp_fill_dataframe(cf, so, ae, 0);\n\n\t \n\tcf->data[ae] = N_PCI_CF | so->tx.sn++;\n\tso->tx.sn %= 16;\n\tso->tx.bs++;\n\n\tcf->flags = so->ll.tx_flags;\n\n\tskb->dev = dev;\n\tcan_skb_set_owner(skb, sk);\n\n\t \n\tif (so->cfecho)\n\t\tpr_notice_once(\"can-isotp: cfecho is %08X != 0\\n\", so->cfecho);\n\n\t \n\tso->cfecho = *(u32 *)cf->data;\n\n\t \n\tcan_send_ret = can_send(skb, 1);\n\tif (can_send_ret) {\n\t\tpr_notice_once(\"can-isotp: %s: can_send_ret %pe\\n\",\n\t\t\t       __func__, ERR_PTR(can_send_ret));\n\t\tif (can_send_ret == -ENOBUFS)\n\t\t\tpr_notice_once(\"can-isotp: tx queue is full\\n\");\n\t}\n\tdev_put(dev);\n}\n\nstatic void isotp_create_fframe(struct canfd_frame *cf, struct isotp_sock *so,\n\t\t\t\tint ae)\n{\n\tint i;\n\tint ff_pci_sz;\n\n\tcf->can_id = so->txid;\n\tcf->len = so->tx.ll_dl;\n\tif (ae)\n\t\tcf->data[0] = so->opt.ext_address;\n\n\t \n\tif (so->tx.len > MAX_12BIT_PDU_SIZE) {\n\t\t \n\t\tcf->data[ae] = N_PCI_FF;\n\t\tcf->data[ae + 1] = 0;\n\t\tcf->data[ae + 2] = (u8)(so->tx.len >> 24) & 0xFFU;\n\t\tcf->data[ae + 3] = (u8)(so->tx.len >> 16) & 0xFFU;\n\t\tcf->data[ae + 4] = (u8)(so->tx.len >> 8) & 0xFFU;\n\t\tcf->data[ae + 5] = (u8)so->tx.len & 0xFFU;\n\t\tff_pci_sz = FF_PCI_SZ32;\n\t} else {\n\t\t \n\t\tcf->data[ae] = (u8)(so->tx.len >> 8) | N_PCI_FF;\n\t\tcf->data[ae + 1] = (u8)so->tx.len & 0xFFU;\n\t\tff_pci_sz = FF_PCI_SZ12;\n\t}\n\n\t \n\tfor (i = ae + ff_pci_sz; i < so->tx.ll_dl; i++)\n\t\tcf->data[i] = so->tx.buf[so->tx.idx++];\n\n\tso->tx.sn = 1;\n}\n\nstatic void isotp_rcv_echo(struct sk_buff *skb, void *data)\n{\n\tstruct sock *sk = (struct sock *)data;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\n\n\t \n\tif (skb->sk != sk || so->cfecho != *(u32 *)cf->data)\n\t\treturn;\n\n\t \n\thrtimer_cancel(&so->txtimer);\n\n\t \n\tso->cfecho = 0;\n\n\tif (so->tx.idx >= so->tx.len) {\n\t\t \n\t\tso->tx.state = ISOTP_IDLE;\n\t\twake_up_interruptible(&so->wait);\n\t\treturn;\n\t}\n\n\tif (so->txfc.bs && so->tx.bs >= so->txfc.bs) {\n\t\t \n\t\tso->tx.state = ISOTP_WAIT_FC;\n\t\thrtimer_start(&so->txtimer, ktime_set(ISOTP_FC_TIMEOUT, 0),\n\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\treturn;\n\t}\n\n\t \n\tif (!so->tx_gap) {\n\t\t \n\t\thrtimer_start(&so->txtimer, ktime_set(ISOTP_ECHO_TIMEOUT, 0),\n\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\tisotp_send_cframe(so);\n\t\treturn;\n\t}\n\n\t \n\thrtimer_start(&so->txfrtimer, so->tx_gap, HRTIMER_MODE_REL_SOFT);\n}\n\nstatic enum hrtimer_restart isotp_tx_timer_handler(struct hrtimer *hrtimer)\n{\n\tstruct isotp_sock *so = container_of(hrtimer, struct isotp_sock,\n\t\t\t\t\t     txtimer);\n\tstruct sock *sk = &so->sk;\n\n\t \n\tif (so->tx.state == ISOTP_IDLE || so->tx.state == ISOTP_SHUTDOWN)\n\t\treturn HRTIMER_NORESTART;\n\n\t \n\n\t \n\tsk->sk_err = ECOMM;\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk_error_report(sk);\n\n\t \n\tso->tx.state = ISOTP_IDLE;\n\twake_up_interruptible(&so->wait);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic enum hrtimer_restart isotp_txfr_timer_handler(struct hrtimer *hrtimer)\n{\n\tstruct isotp_sock *so = container_of(hrtimer, struct isotp_sock,\n\t\t\t\t\t     txfrtimer);\n\n\t \n\thrtimer_start(&so->txtimer, ktime_set(ISOTP_ECHO_TIMEOUT, 0),\n\t\t      HRTIMER_MODE_REL_SOFT);\n\n\t \n\tif (so->tx.state == ISOTP_SENDING && !so->cfecho)\n\t\tisotp_send_cframe(so);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic int isotp_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct canfd_frame *cf;\n\tint ae = (so->opt.flags & CAN_ISOTP_EXTEND_ADDR) ? 1 : 0;\n\tint wait_tx_done = (so->opt.flags & CAN_ISOTP_WAIT_TX_DONE) ? 1 : 0;\n\ts64 hrtimer_sec = ISOTP_ECHO_TIMEOUT;\n\tint off;\n\tint err;\n\n\tif (!so->bound || so->tx.state == ISOTP_SHUTDOWN)\n\t\treturn -EADDRNOTAVAIL;\n\n\twhile (cmpxchg(&so->tx.state, ISOTP_IDLE, ISOTP_SENDING) != ISOTP_IDLE) {\n\t\t \n\t\tif (msg->msg_flags & MSG_DONTWAIT)\n\t\t\treturn -EAGAIN;\n\n\t\tif (so->tx.state == ISOTP_SHUTDOWN)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\t \n\t\terr = wait_event_interruptible(so->wait, so->tx.state == ISOTP_IDLE);\n\t\tif (err)\n\t\t\tgoto err_event_drop;\n\t}\n\n\t \n\tif (size > so->tx.buflen && so->tx.buflen < max_pdu_size) {\n\t\tu8 *newbuf = kmalloc(max_pdu_size, GFP_KERNEL);\n\n\t\tif (newbuf) {\n\t\t\tso->tx.buf = newbuf;\n\t\t\tso->tx.buflen = max_pdu_size;\n\t\t}\n\t}\n\n\tif (!size || size > so->tx.buflen) {\n\t\terr = -EINVAL;\n\t\tgoto err_out_drop;\n\t}\n\n\t \n\toff = (so->tx.ll_dl > CAN_MAX_DLEN) ? 1 : 0;\n\n\t \n\tif ((isotp_bc_flags(so) == CAN_ISOTP_SF_BROADCAST) &&\n\t    (size > so->tx.ll_dl - SF_PCI_SZ4 - ae - off)) {\n\t\terr = -EINVAL;\n\t\tgoto err_out_drop;\n\t}\n\n\terr = memcpy_from_msg(so->tx.buf, msg, size);\n\tif (err < 0)\n\t\tgoto err_out_drop;\n\n\tdev = dev_get_by_index(sock_net(sk), so->ifindex);\n\tif (!dev) {\n\t\terr = -ENXIO;\n\t\tgoto err_out_drop;\n\t}\n\n\tskb = sock_alloc_send_skb(sk, so->ll.mtu + sizeof(struct can_skb_priv),\n\t\t\t\t  msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb) {\n\t\tdev_put(dev);\n\t\tgoto err_out_drop;\n\t}\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\tso->tx.len = size;\n\tso->tx.idx = 0;\n\n\tcf = (struct canfd_frame *)skb->data;\n\tskb_put_zero(skb, so->ll.mtu);\n\n\t \n\tif (so->cfecho)\n\t\tpr_notice_once(\"can-isotp: uninit cfecho %08X\\n\", so->cfecho);\n\n\t \n\tif (size <= so->tx.ll_dl - SF_PCI_SZ4 - ae - off) {\n\t\t \n\t\tif (size <= CAN_MAX_DLEN - SF_PCI_SZ4 - ae)\n\t\t\toff = 0;\n\n\t\tisotp_fill_dataframe(cf, so, ae, off);\n\n\t\t \n\t\tcf->data[ae] = N_PCI_SF;\n\n\t\t \n\t\tif (off)\n\t\t\tcf->data[SF_PCI_SZ4 + ae] = size;\n\t\telse\n\t\t\tcf->data[ae] |= size;\n\n\t\t \n\t\tso->cfecho = *(u32 *)cf->data;\n\t} else {\n\t\t \n\n\t\tisotp_create_fframe(cf, so, ae);\n\n\t\tif (isotp_bc_flags(so) == CAN_ISOTP_CF_BROADCAST) {\n\t\t\t \n\t\t\tif (so->opt.flags & CAN_ISOTP_FORCE_TXSTMIN)\n\t\t\t\tso->tx_gap = ktime_set(0, so->force_tx_stmin);\n\t\t\telse\n\t\t\t\tso->tx_gap = ktime_set(0, so->frame_txtime);\n\n\t\t\t \n\t\t\tso->txfc.bs = 0;\n\n\t\t\t \n\t\t\tso->cfecho = *(u32 *)cf->data;\n\t\t} else {\n\t\t\t \n\t\t\tso->tx.state = ISOTP_WAIT_FIRST_FC;\n\n\t\t\t \n\t\t\thrtimer_sec = ISOTP_FC_TIMEOUT;\n\n\t\t\t \n\t\t\tso->cfecho = 0;\n\t\t}\n\t}\n\n\thrtimer_start(&so->txtimer, ktime_set(hrtimer_sec, 0),\n\t\t      HRTIMER_MODE_REL_SOFT);\n\n\t \n\tcf->flags = so->ll.tx_flags;\n\n\tskb->dev = dev;\n\tskb->sk = sk;\n\terr = can_send(skb, 1);\n\tdev_put(dev);\n\tif (err) {\n\t\tpr_notice_once(\"can-isotp: %s: can_send_ret %pe\\n\",\n\t\t\t       __func__, ERR_PTR(err));\n\n\t\t \n\t\thrtimer_cancel(&so->txtimer);\n\n\t\t \n\t\tso->cfecho = 0;\n\n\t\tgoto err_out_drop;\n\t}\n\n\tif (wait_tx_done) {\n\t\t \n\t\terr = wait_event_interruptible(so->wait, so->tx.state == ISOTP_IDLE);\n\t\tif (err)\n\t\t\tgoto err_event_drop;\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn size;\n\nerr_event_drop:\n\t \n\tso->tx.state = ISOTP_IDLE;\n\thrtimer_cancel(&so->txfrtimer);\n\thrtimer_cancel(&so->txtimer);\nerr_out_drop:\n\t \n\tso->tx.state = ISOTP_IDLE;\n\twake_up_interruptible(&so->wait);\n\n\treturn err;\n}\n\nstatic int isotp_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tint ret = 0;\n\n\tif (flags & ~(MSG_DONTWAIT | MSG_TRUNC | MSG_PEEK | MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (!so->bound)\n\t\treturn -EADDRNOTAVAIL;\n\n\tskb = skb_recv_datagram(sk, flags, &ret);\n\tif (!skb)\n\t\treturn ret;\n\n\tif (size < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\telse\n\t\tsize = skb->len;\n\n\tret = memcpy_to_msg(msg, skb->data, size);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\tsock_recv_cmsgs(msg, sk, skb);\n\n\tif (msg->msg_name) {\n\t\t__sockaddr_check_size(ISOTP_MIN_NAMELEN);\n\t\tmsg->msg_namelen = ISOTP_MIN_NAMELEN;\n\t\tmemcpy(msg->msg_name, skb->cb, msg->msg_namelen);\n\t}\n\n\t \n\tret = (flags & MSG_TRUNC) ? skb->len : size;\n\nout_err:\n\tskb_free_datagram(sk, skb);\n\n\treturn ret;\n}\n\nstatic int isotp_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct isotp_sock *so;\n\tstruct net *net;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tso = isotp_sk(sk);\n\tnet = sock_net(sk);\n\n\t \n\twhile (wait_event_interruptible(so->wait, so->tx.state == ISOTP_IDLE) == 0 &&\n\t       cmpxchg(&so->tx.state, ISOTP_IDLE, ISOTP_SHUTDOWN) != ISOTP_IDLE)\n\t\t;\n\n\t \n\tso->tx.state = ISOTP_SHUTDOWN;\n\tso->rx.state = ISOTP_IDLE;\n\n\tspin_lock(&isotp_notifier_lock);\n\twhile (isotp_busy_notifier == so) {\n\t\tspin_unlock(&isotp_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&isotp_notifier_lock);\n\t}\n\tlist_del(&so->notifier);\n\tspin_unlock(&isotp_notifier_lock);\n\n\tlock_sock(sk);\n\n\t \n\tif (so->bound) {\n\t\tif (so->ifindex) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tdev = dev_get_by_index(net, so->ifindex);\n\t\t\tif (dev) {\n\t\t\t\tif (isotp_register_rxid(so))\n\t\t\t\t\tcan_rx_unregister(net, dev, so->rxid,\n\t\t\t\t\t\t\t  SINGLE_MASK(so->rxid),\n\t\t\t\t\t\t\t  isotp_rcv, sk);\n\n\t\t\t\tcan_rx_unregister(net, dev, so->txid,\n\t\t\t\t\t\t  SINGLE_MASK(so->txid),\n\t\t\t\t\t\t  isotp_rcv_echo, sk);\n\t\t\t\tdev_put(dev);\n\t\t\t\tsynchronize_rcu();\n\t\t\t}\n\t\t}\n\t}\n\n\thrtimer_cancel(&so->txfrtimer);\n\thrtimer_cancel(&so->txtimer);\n\thrtimer_cancel(&so->rxtimer);\n\n\tso->ifindex = 0;\n\tso->bound = 0;\n\n\tif (so->rx.buf != so->rx.sbuf)\n\t\tkfree(so->rx.buf);\n\n\tif (so->tx.buf != so->tx.sbuf)\n\t\tkfree(so->tx.buf);\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int isotp_bind(struct socket *sock, struct sockaddr *uaddr, int len)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint ifindex;\n\tstruct net_device *dev;\n\tcanid_t tx_id = addr->can_addr.tp.tx_id;\n\tcanid_t rx_id = addr->can_addr.tp.rx_id;\n\tint err = 0;\n\tint notify_enetdown = 0;\n\n\tif (len < ISOTP_MIN_NAMELEN)\n\t\treturn -EINVAL;\n\n\tif (addr->can_family != AF_CAN)\n\t\treturn -EINVAL;\n\n\t \n\tif (tx_id & CAN_EFF_FLAG)\n\t\ttx_id &= (CAN_EFF_FLAG | CAN_EFF_MASK);\n\telse\n\t\ttx_id &= CAN_SFF_MASK;\n\n\t \n\tif (tx_id != addr->can_addr.tp.tx_id)\n\t\treturn -EINVAL;\n\n\t \n\tif (isotp_register_rxid(so)) {\n\t\tif (rx_id & CAN_EFF_FLAG)\n\t\t\trx_id &= (CAN_EFF_FLAG | CAN_EFF_MASK);\n\t\telse\n\t\t\trx_id &= CAN_SFF_MASK;\n\n\t\t \n\t\tif (rx_id != addr->can_addr.tp.rx_id)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!addr->can_ifindex)\n\t\treturn -ENODEV;\n\n\tlock_sock(sk);\n\n\tif (so->bound) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (isotp_register_rxid(so) && rx_id == tx_id) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tdev = dev_get_by_index(net, addr->can_ifindex);\n\tif (!dev) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (dev->type != ARPHRD_CAN) {\n\t\tdev_put(dev);\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (dev->mtu < so->ll.mtu) {\n\t\tdev_put(dev);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!(dev->flags & IFF_UP))\n\t\tnotify_enetdown = 1;\n\n\tifindex = dev->ifindex;\n\n\tif (isotp_register_rxid(so))\n\t\tcan_rx_register(net, dev, rx_id, SINGLE_MASK(rx_id),\n\t\t\t\tisotp_rcv, sk, \"isotp\", sk);\n\n\t \n\tso->cfecho = 0;\n\n\t \n\tcan_rx_register(net, dev, tx_id, SINGLE_MASK(tx_id),\n\t\t\tisotp_rcv_echo, sk, \"isotpe\", sk);\n\n\tdev_put(dev);\n\n\t \n\tso->ifindex = ifindex;\n\tso->rxid = rx_id;\n\tso->txid = tx_id;\n\tso->bound = 1;\n\nout:\n\trelease_sock(sk);\n\n\tif (notify_enetdown) {\n\t\tsk->sk_err = ENETDOWN;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\t}\n\n\treturn err;\n}\n\nstatic int isotp_getname(struct socket *sock, struct sockaddr *uaddr, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(addr, 0, ISOTP_MIN_NAMELEN);\n\taddr->can_family = AF_CAN;\n\taddr->can_ifindex = so->ifindex;\n\taddr->can_addr.tp.rx_id = so->rxid;\n\taddr->can_addr.tp.tx_id = so->txid;\n\n\treturn ISOTP_MIN_NAMELEN;\n}\n\nstatic int isotp_setsockopt_locked(struct socket *sock, int level, int optname,\n\t\t\t    sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tint ret = 0;\n\n\tif (so->bound)\n\t\treturn -EISCONN;\n\n\tswitch (optname) {\n\tcase CAN_ISOTP_OPTS:\n\t\tif (optlen != sizeof(struct can_isotp_options))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&so->opt, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (!(so->opt.flags & CAN_ISOTP_RX_EXT_ADDR))\n\t\t\tso->opt.rx_ext_address = so->opt.ext_address;\n\n\t\t \n\t\tif (isotp_bc_flags(so) == ISOTP_ALL_BC_FLAGS) {\n\t\t\t \n\t\t\tso->opt.flags &= ~CAN_ISOTP_CF_BROADCAST;\n\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (so->opt.frame_txtime) {\n\t\t\tif (so->opt.frame_txtime == CAN_ISOTP_FRAME_TXTIME_ZERO)\n\t\t\t\tso->frame_txtime = 0;\n\t\t\telse\n\t\t\t\tso->frame_txtime = so->opt.frame_txtime;\n\t\t}\n\t\tbreak;\n\n\tcase CAN_ISOTP_RECV_FC:\n\t\tif (optlen != sizeof(struct can_isotp_fc_options))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&so->rxfc, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase CAN_ISOTP_TX_STMIN:\n\t\tif (optlen != sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&so->force_tx_stmin, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase CAN_ISOTP_RX_STMIN:\n\t\tif (optlen != sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&so->force_rx_stmin, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase CAN_ISOTP_LL_OPTS:\n\t\tif (optlen == sizeof(struct can_isotp_ll_options)) {\n\t\t\tstruct can_isotp_ll_options ll;\n\n\t\t\tif (copy_from_sockptr(&ll, optval, optlen))\n\t\t\t\treturn -EFAULT;\n\n\t\t\t \n\t\t\tif (ll.tx_dl != padlen(ll.tx_dl))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (ll.mtu != CAN_MTU && ll.mtu != CANFD_MTU)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (ll.mtu == CAN_MTU &&\n\t\t\t    (ll.tx_dl > CAN_MAX_DLEN || ll.tx_flags != 0))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmemcpy(&so->ll, &ll, sizeof(ll));\n\n\t\t\t \n\t\t\tso->tx.ll_dl = ll.tx_dl;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t}\n\n\treturn ret;\n}\n\nstatic int isotp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t    sockptr_t optval, unsigned int optlen)\n\n{\n\tstruct sock *sk = sock->sk;\n\tint ret;\n\n\tif (level != SOL_CAN_ISOTP)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tret = isotp_setsockopt_locked(sock, level, optname, optval, optlen);\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int isotp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tint len;\n\tvoid *val;\n\n\tif (level != SOL_CAN_ISOTP)\n\t\treturn -EINVAL;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase CAN_ISOTP_OPTS:\n\t\tlen = min_t(int, len, sizeof(struct can_isotp_options));\n\t\tval = &so->opt;\n\t\tbreak;\n\n\tcase CAN_ISOTP_RECV_FC:\n\t\tlen = min_t(int, len, sizeof(struct can_isotp_fc_options));\n\t\tval = &so->rxfc;\n\t\tbreak;\n\n\tcase CAN_ISOTP_TX_STMIN:\n\t\tlen = min_t(int, len, sizeof(u32));\n\t\tval = &so->force_tx_stmin;\n\t\tbreak;\n\n\tcase CAN_ISOTP_RX_STMIN:\n\t\tlen = min_t(int, len, sizeof(u32));\n\t\tval = &so->force_rx_stmin;\n\t\tbreak;\n\n\tcase CAN_ISOTP_LL_OPTS:\n\t\tlen = min_t(int, len, sizeof(struct can_isotp_ll_options));\n\t\tval = &so->ll;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void isotp_notify(struct isotp_sock *so, unsigned long msg,\n\t\t\t struct net_device *dev)\n{\n\tstruct sock *sk = &so->sk;\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\treturn;\n\n\tif (so->ifindex != dev->ifindex)\n\t\treturn;\n\n\tswitch (msg) {\n\tcase NETDEV_UNREGISTER:\n\t\tlock_sock(sk);\n\t\t \n\t\tif (so->bound) {\n\t\t\tif (isotp_register_rxid(so))\n\t\t\t\tcan_rx_unregister(dev_net(dev), dev, so->rxid,\n\t\t\t\t\t\t  SINGLE_MASK(so->rxid),\n\t\t\t\t\t\t  isotp_rcv, sk);\n\n\t\t\tcan_rx_unregister(dev_net(dev), dev, so->txid,\n\t\t\t\t\t  SINGLE_MASK(so->txid),\n\t\t\t\t\t  isotp_rcv_echo, sk);\n\t\t}\n\n\t\tso->ifindex = 0;\n\t\tso->bound  = 0;\n\t\trelease_sock(sk);\n\n\t\tsk->sk_err = ENODEV;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tsk->sk_err = ENETDOWN;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk_error_report(sk);\n\t\tbreak;\n\t}\n}\n\nstatic int isotp_notifier(struct notifier_block *nb, unsigned long msg,\n\t\t\t  void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (dev->type != ARPHRD_CAN)\n\t\treturn NOTIFY_DONE;\n\tif (msg != NETDEV_UNREGISTER && msg != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\tif (unlikely(isotp_busy_notifier))  \n\t\treturn NOTIFY_DONE;\n\n\tspin_lock(&isotp_notifier_lock);\n\tlist_for_each_entry(isotp_busy_notifier, &isotp_notifier_list, notifier) {\n\t\tspin_unlock(&isotp_notifier_lock);\n\t\tisotp_notify(isotp_busy_notifier, msg, dev);\n\t\tspin_lock(&isotp_notifier_lock);\n\t}\n\tisotp_busy_notifier = NULL;\n\tspin_unlock(&isotp_notifier_lock);\n\treturn NOTIFY_DONE;\n}\n\nstatic int isotp_init(struct sock *sk)\n{\n\tstruct isotp_sock *so = isotp_sk(sk);\n\n\tso->ifindex = 0;\n\tso->bound = 0;\n\n\tso->opt.flags = CAN_ISOTP_DEFAULT_FLAGS;\n\tso->opt.ext_address = CAN_ISOTP_DEFAULT_EXT_ADDRESS;\n\tso->opt.rx_ext_address = CAN_ISOTP_DEFAULT_EXT_ADDRESS;\n\tso->opt.rxpad_content = CAN_ISOTP_DEFAULT_PAD_CONTENT;\n\tso->opt.txpad_content = CAN_ISOTP_DEFAULT_PAD_CONTENT;\n\tso->opt.frame_txtime = CAN_ISOTP_DEFAULT_FRAME_TXTIME;\n\tso->frame_txtime = CAN_ISOTP_DEFAULT_FRAME_TXTIME;\n\tso->rxfc.bs = CAN_ISOTP_DEFAULT_RECV_BS;\n\tso->rxfc.stmin = CAN_ISOTP_DEFAULT_RECV_STMIN;\n\tso->rxfc.wftmax = CAN_ISOTP_DEFAULT_RECV_WFTMAX;\n\tso->ll.mtu = CAN_ISOTP_DEFAULT_LL_MTU;\n\tso->ll.tx_dl = CAN_ISOTP_DEFAULT_LL_TX_DL;\n\tso->ll.tx_flags = CAN_ISOTP_DEFAULT_LL_TX_FLAGS;\n\n\t \n\tso->tx.ll_dl = so->ll.tx_dl;\n\n\tso->rx.state = ISOTP_IDLE;\n\tso->tx.state = ISOTP_IDLE;\n\n\tso->rx.buf = so->rx.sbuf;\n\tso->tx.buf = so->tx.sbuf;\n\tso->rx.buflen = ARRAY_SIZE(so->rx.sbuf);\n\tso->tx.buflen = ARRAY_SIZE(so->tx.sbuf);\n\n\thrtimer_init(&so->rxtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_SOFT);\n\tso->rxtimer.function = isotp_rx_timer_handler;\n\thrtimer_init(&so->txtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_SOFT);\n\tso->txtimer.function = isotp_tx_timer_handler;\n\thrtimer_init(&so->txfrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_SOFT);\n\tso->txfrtimer.function = isotp_txfr_timer_handler;\n\n\tinit_waitqueue_head(&so->wait);\n\tspin_lock_init(&so->rx_lock);\n\n\tspin_lock(&isotp_notifier_lock);\n\tlist_add_tail(&so->notifier, &isotp_notifier_list);\n\tspin_unlock(&isotp_notifier_lock);\n\n\treturn 0;\n}\n\nstatic __poll_t isotp_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\n\t__poll_t mask = datagram_poll(file, sock, wait);\n\tpoll_wait(file, &so->wait, wait);\n\n\t \n\tif ((mask & EPOLLWRNORM) && (so->tx.state != ISOTP_IDLE))\n\t\tmask &= ~(EPOLLOUT | EPOLLWRNORM);\n\n\treturn mask;\n}\n\nstatic int isotp_sock_no_ioctlcmd(struct socket *sock, unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\t \n\treturn -ENOIOCTLCMD;\n}\n\nstatic const struct proto_ops isotp_ops = {\n\t.family = PF_CAN,\n\t.release = isotp_release,\n\t.bind = isotp_bind,\n\t.connect = sock_no_connect,\n\t.socketpair = sock_no_socketpair,\n\t.accept = sock_no_accept,\n\t.getname = isotp_getname,\n\t.poll = isotp_poll,\n\t.ioctl = isotp_sock_no_ioctlcmd,\n\t.gettstamp = sock_gettstamp,\n\t.listen = sock_no_listen,\n\t.shutdown = sock_no_shutdown,\n\t.setsockopt = isotp_setsockopt,\n\t.getsockopt = isotp_getsockopt,\n\t.sendmsg = isotp_sendmsg,\n\t.recvmsg = isotp_recvmsg,\n\t.mmap = sock_no_mmap,\n};\n\nstatic struct proto isotp_proto __read_mostly = {\n\t.name = \"CAN_ISOTP\",\n\t.owner = THIS_MODULE,\n\t.obj_size = sizeof(struct isotp_sock),\n\t.init = isotp_init,\n};\n\nstatic const struct can_proto isotp_can_proto = {\n\t.type = SOCK_DGRAM,\n\t.protocol = CAN_ISOTP,\n\t.ops = &isotp_ops,\n\t.prot = &isotp_proto,\n};\n\nstatic struct notifier_block canisotp_notifier = {\n\t.notifier_call = isotp_notifier\n};\n\nstatic __init int isotp_module_init(void)\n{\n\tint err;\n\n\tmax_pdu_size = max_t(unsigned int, max_pdu_size, MAX_12BIT_PDU_SIZE);\n\tmax_pdu_size = min_t(unsigned int, max_pdu_size, MAX_PDU_SIZE);\n\n\tpr_info(\"can: isotp protocol (max_pdu_size %d)\\n\", max_pdu_size);\n\n\terr = can_proto_register(&isotp_can_proto);\n\tif (err < 0)\n\t\tpr_err(\"can: registration of isotp protocol failed %pe\\n\", ERR_PTR(err));\n\telse\n\t\tregister_netdevice_notifier(&canisotp_notifier);\n\n\treturn err;\n}\n\nstatic __exit void isotp_module_exit(void)\n{\n\tcan_proto_unregister(&isotp_can_proto);\n\tunregister_netdevice_notifier(&canisotp_notifier);\n}\n\nmodule_init(isotp_module_init);\nmodule_exit(isotp_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}