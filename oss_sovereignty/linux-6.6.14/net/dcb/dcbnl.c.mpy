{
  "module_name": "dcbnl.c",
  "hash_id": "3326c56d4314b59ef50393ae7fc2f0a104bcaa8a8c6d4f6d796ec5754720ed14",
  "original_prompt": "Ingested from linux-6.6.14/net/dcb/dcbnl.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/slab.h>\n#include <net/netlink.h>\n#include <net/rtnetlink.h>\n#include <linux/dcbnl.h>\n#include <net/dcbevent.h>\n#include <linux/rtnetlink.h>\n#include <linux/init.h>\n#include <net/sock.h>\n\n \n\n \n\n \nstatic const struct nla_policy dcbnl_rtnl_policy[DCB_ATTR_MAX + 1] = {\n\t[DCB_ATTR_IFNAME]      = {.type = NLA_NUL_STRING, .len = IFNAMSIZ - 1},\n\t[DCB_ATTR_STATE]       = {.type = NLA_U8},\n\t[DCB_ATTR_PFC_CFG]     = {.type = NLA_NESTED},\n\t[DCB_ATTR_PG_CFG]      = {.type = NLA_NESTED},\n\t[DCB_ATTR_SET_ALL]     = {.type = NLA_U8},\n\t[DCB_ATTR_PERM_HWADDR] = {.type = NLA_FLAG},\n\t[DCB_ATTR_CAP]         = {.type = NLA_NESTED},\n\t[DCB_ATTR_PFC_STATE]   = {.type = NLA_U8},\n\t[DCB_ATTR_BCN]         = {.type = NLA_NESTED},\n\t[DCB_ATTR_APP]         = {.type = NLA_NESTED},\n\t[DCB_ATTR_IEEE]\t       = {.type = NLA_NESTED},\n\t[DCB_ATTR_DCBX]        = {.type = NLA_U8},\n\t[DCB_ATTR_FEATCFG]     = {.type = NLA_NESTED},\n};\n\n \nstatic const struct nla_policy dcbnl_pfc_up_nest[DCB_PFC_UP_ATTR_MAX + 1] = {\n\t[DCB_PFC_UP_ATTR_0]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_1]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_2]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_3]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_4]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_5]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_6]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_7]   = {.type = NLA_U8},\n\t[DCB_PFC_UP_ATTR_ALL] = {.type = NLA_FLAG},\n};\n\n \nstatic const struct nla_policy dcbnl_pg_nest[DCB_PG_ATTR_MAX + 1] = {\n\t[DCB_PG_ATTR_TC_0]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_1]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_2]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_3]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_4]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_5]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_6]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_7]      = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_TC_ALL]    = {.type = NLA_NESTED},\n\t[DCB_PG_ATTR_BW_ID_0]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_1]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_2]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_3]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_4]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_5]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_6]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_7]   = {.type = NLA_U8},\n\t[DCB_PG_ATTR_BW_ID_ALL] = {.type = NLA_FLAG},\n};\n\n \nstatic const struct nla_policy dcbnl_tc_param_nest[DCB_TC_ATTR_PARAM_MAX + 1] = {\n\t[DCB_TC_ATTR_PARAM_PGID]            = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_UP_MAPPING]      = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_STRICT_PRIO]     = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_BW_PCT]          = {.type = NLA_U8},\n\t[DCB_TC_ATTR_PARAM_ALL]             = {.type = NLA_FLAG},\n};\n\n \nstatic const struct nla_policy dcbnl_cap_nest[DCB_CAP_ATTR_MAX + 1] = {\n\t[DCB_CAP_ATTR_ALL]     = {.type = NLA_FLAG},\n\t[DCB_CAP_ATTR_PG]      = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_PFC]     = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_UP2TC]   = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_PG_TCS]  = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_PFC_TCS] = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_GSP]     = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_BCN]     = {.type = NLA_U8},\n\t[DCB_CAP_ATTR_DCBX]    = {.type = NLA_U8},\n};\n\n \nstatic const struct nla_policy dcbnl_numtcs_nest[DCB_NUMTCS_ATTR_MAX + 1] = {\n\t[DCB_NUMTCS_ATTR_ALL]     = {.type = NLA_FLAG},\n\t[DCB_NUMTCS_ATTR_PG]      = {.type = NLA_U8},\n\t[DCB_NUMTCS_ATTR_PFC]     = {.type = NLA_U8},\n};\n\n \nstatic const struct nla_policy dcbnl_bcn_nest[DCB_BCN_ATTR_MAX + 1] = {\n\t[DCB_BCN_ATTR_RP_0]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_1]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_2]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_3]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_4]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_5]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_6]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_7]         = {.type = NLA_U8},\n\t[DCB_BCN_ATTR_RP_ALL]       = {.type = NLA_FLAG},\n\t[DCB_BCN_ATTR_BCNA_0]       = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_BCNA_1]       = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_ALPHA]        = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_BETA]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_GD]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_GI]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_TMAX]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_TD]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RMIN]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_W]            = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RD]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RU]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_WRTT]         = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_RI]           = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_C]            = {.type = NLA_U32},\n\t[DCB_BCN_ATTR_ALL]          = {.type = NLA_FLAG},\n};\n\n \nstatic const struct nla_policy dcbnl_app_nest[DCB_APP_ATTR_MAX + 1] = {\n\t[DCB_APP_ATTR_IDTYPE]       = {.type = NLA_U8},\n\t[DCB_APP_ATTR_ID]           = {.type = NLA_U16},\n\t[DCB_APP_ATTR_PRIORITY]     = {.type = NLA_U8},\n};\n\n \nstatic const struct nla_policy dcbnl_ieee_policy[DCB_ATTR_IEEE_MAX + 1] = {\n\t[DCB_ATTR_IEEE_ETS]\t    = {.len = sizeof(struct ieee_ets)},\n\t[DCB_ATTR_IEEE_PFC]\t    = {.len = sizeof(struct ieee_pfc)},\n\t[DCB_ATTR_IEEE_APP_TABLE]   = {.type = NLA_NESTED},\n\t[DCB_ATTR_IEEE_MAXRATE]   = {.len = sizeof(struct ieee_maxrate)},\n\t[DCB_ATTR_IEEE_QCN]         = {.len = sizeof(struct ieee_qcn)},\n\t[DCB_ATTR_IEEE_QCN_STATS]   = {.len = sizeof(struct ieee_qcn_stats)},\n\t[DCB_ATTR_DCB_BUFFER]       = {.len = sizeof(struct dcbnl_buffer)},\n\t[DCB_ATTR_DCB_APP_TRUST_TABLE] = {.type = NLA_NESTED},\n};\n\n \nstatic const struct nla_policy dcbnl_featcfg_nest[DCB_FEATCFG_ATTR_MAX + 1] = {\n\t[DCB_FEATCFG_ATTR_ALL]      = {.type = NLA_FLAG},\n\t[DCB_FEATCFG_ATTR_PG]       = {.type = NLA_U8},\n\t[DCB_FEATCFG_ATTR_PFC]      = {.type = NLA_U8},\n\t[DCB_FEATCFG_ATTR_APP]      = {.type = NLA_U8},\n};\n\nstatic LIST_HEAD(dcb_app_list);\nstatic LIST_HEAD(dcb_rewr_list);\nstatic DEFINE_SPINLOCK(dcb_lock);\n\nstatic enum ieee_attrs_app dcbnl_app_attr_type_get(u8 selector)\n{\n\tswitch (selector) {\n\tcase IEEE_8021QAZ_APP_SEL_ETHERTYPE:\n\tcase IEEE_8021QAZ_APP_SEL_STREAM:\n\tcase IEEE_8021QAZ_APP_SEL_DGRAM:\n\tcase IEEE_8021QAZ_APP_SEL_ANY:\n\tcase IEEE_8021QAZ_APP_SEL_DSCP:\n\t\treturn DCB_ATTR_IEEE_APP;\n\tcase DCB_APP_SEL_PCP:\n\t\treturn DCB_ATTR_DCB_APP;\n\tdefault:\n\t\treturn DCB_ATTR_IEEE_APP_UNSPEC;\n\t}\n}\n\nstatic bool dcbnl_app_attr_type_validate(enum ieee_attrs_app type)\n{\n\tswitch (type) {\n\tcase DCB_ATTR_IEEE_APP:\n\tcase DCB_ATTR_DCB_APP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool dcbnl_app_selector_validate(enum ieee_attrs_app type, u8 selector)\n{\n\treturn dcbnl_app_attr_type_get(selector) == type;\n}\n\nstatic struct sk_buff *dcbnl_newmsg(int type, u8 cmd, u32 port, u32 seq,\n\t\t\t\t    u32 flags, struct nlmsghdr **nlhp)\n{\n\tstruct sk_buff *skb;\n\tstruct dcbmsg *dcb;\n\tstruct nlmsghdr *nlh;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh = nlmsg_put(skb, port, seq, type, sizeof(*dcb), flags);\n\tBUG_ON(!nlh);\n\n\tdcb = nlmsg_data(nlh);\n\tdcb->dcb_family = AF_UNSPEC;\n\tdcb->cmd = cmd;\n\tdcb->dcb_pad = 0;\n\n\tif (nlhp)\n\t\t*nlhp = nlh;\n\n\treturn skb;\n}\n\nstatic int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\t \n\tif (!netdev->dcbnl_ops->getstate)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_STATE,\n\t\t\t  netdev->dcbnl_ops->getstate(netdev));\n}\n\nstatic int dcbnl_getpfccfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_PFC_UP_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret;\n\tint i;\n\tint getall = 0;\n\n\tif (!tb[DCB_ATTR_PFC_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getpfccfg)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested_deprecated(data, DCB_PFC_UP_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_PFC_CFG],\n\t\t\t\t\t  dcbnl_pfc_up_nest, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start_noflag(skb, DCB_ATTR_PFC_CFG);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_PFC_UP_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tnetdev->dcbnl_ops->getpfccfg(netdev, i - DCB_PFC_UP_ATTR_0,\n\t\t                             &value);\n\t\tret = nla_put_u8(skb, i, value);\n\t\tif (ret) {\n\t\t\tnla_nest_cancel(skb, nest);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n}\n\nstatic int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 perm_addr[MAX_ADDR_LEN];\n\n\tif (!netdev->dcbnl_ops->getpermhwaddr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(perm_addr, 0, sizeof(perm_addr));\n\tnetdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);\n\n\treturn nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);\n}\n\nstatic int dcbnl_getcap(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_CAP_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret;\n\tint i;\n\tint getall = 0;\n\n\tif (!tb[DCB_ATTR_CAP])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getcap)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested_deprecated(data, DCB_CAP_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_CAP], dcbnl_cap_nest,\n\t\t\t\t\t  NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start_noflag(skb, DCB_ATTR_CAP);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_CAP_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_CAP_ATTR_ALL+1; i <= DCB_CAP_ATTR_MAX; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tif (!netdev->dcbnl_ops->getcap(netdev, i, &value)) {\n\t\t\tret = nla_put_u8(skb, i, value);\n\t\t\tif (ret) {\n\t\t\t\tnla_nest_cancel(skb, nest);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n}\n\nstatic int dcbnl_getnumtcs(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_NUMTCS_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret;\n\tint i;\n\tint getall = 0;\n\n\tif (!tb[DCB_ATTR_NUMTCS])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getnumtcs)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested_deprecated(data, DCB_NUMTCS_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_NUMTCS],\n\t\t\t\t\t  dcbnl_numtcs_nest, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start_noflag(skb, DCB_ATTR_NUMTCS);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_NUMTCS_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_NUMTCS_ATTR_ALL+1; i <= DCB_NUMTCS_ATTR_MAX; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tret = netdev->dcbnl_ops->getnumtcs(netdev, i, &value);\n\t\tif (!ret) {\n\t\t\tret = nla_put_u8(skb, i, value);\n\t\t\tif (ret) {\n\t\t\t\tnla_nest_cancel(skb, nest);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n}\n\nstatic int dcbnl_setnumtcs(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_NUMTCS_ATTR_MAX + 1];\n\tint ret;\n\tu8 value;\n\tint i;\n\n\tif (!tb[DCB_ATTR_NUMTCS])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setnumtcs)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested_deprecated(data, DCB_NUMTCS_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_NUMTCS],\n\t\t\t\t\t  dcbnl_numtcs_nest, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_NUMTCS_ATTR_ALL+1; i <= DCB_NUMTCS_ATTR_MAX; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\n\t\tvalue = nla_get_u8(data[i]);\n\n\t\tret = netdev->dcbnl_ops->setnumtcs(netdev, i, value);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_NUMTCS, !!ret);\n}\n\nstatic int dcbnl_getpfcstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tif (!netdev->dcbnl_ops->getpfcstate)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_PFC_STATE,\n\t\t\t  netdev->dcbnl_ops->getpfcstate(netdev));\n}\n\nstatic int dcbnl_setpfcstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 value;\n\n\tif (!tb[DCB_ATTR_PFC_STATE])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setpfcstate)\n\t\treturn -EOPNOTSUPP;\n\n\tvalue = nla_get_u8(tb[DCB_ATTR_PFC_STATE]);\n\n\tnetdev->dcbnl_ops->setpfcstate(netdev, value);\n\n\treturn nla_put_u8(skb, DCB_ATTR_PFC_STATE, 0);\n}\n\nstatic int dcbnl_getapp(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *app_nest;\n\tstruct nlattr *app_tb[DCB_APP_ATTR_MAX + 1];\n\tu16 id;\n\tu8 up, idtype;\n\tint ret;\n\n\tif (!tb[DCB_ATTR_APP])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested_deprecated(app_tb, DCB_APP_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_APP], dcbnl_app_nest,\n\t\t\t\t\t  NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((!app_tb[DCB_APP_ATTR_IDTYPE]) ||\n\t    (!app_tb[DCB_APP_ATTR_ID]))\n\t\treturn -EINVAL;\n\n\t \n\tidtype = nla_get_u8(app_tb[DCB_APP_ATTR_IDTYPE]);\n\tif ((idtype != DCB_APP_IDTYPE_ETHTYPE) &&\n\t    (idtype != DCB_APP_IDTYPE_PORTNUM))\n\t\treturn -EINVAL;\n\n\tid = nla_get_u16(app_tb[DCB_APP_ATTR_ID]);\n\n\tif (netdev->dcbnl_ops->getapp) {\n\t\tret = netdev->dcbnl_ops->getapp(netdev, idtype, id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\tup = ret;\n\t} else {\n\t\tstruct dcb_app app = {\n\t\t\t\t\t.selector = idtype,\n\t\t\t\t\t.protocol = id,\n\t\t\t\t     };\n\t\tup = dcb_getapp(netdev, &app);\n\t}\n\n\tapp_nest = nla_nest_start_noflag(skb, DCB_ATTR_APP);\n\tif (!app_nest)\n\t\treturn -EMSGSIZE;\n\n\tret = nla_put_u8(skb, DCB_APP_ATTR_IDTYPE, idtype);\n\tif (ret)\n\t\tgoto out_cancel;\n\n\tret = nla_put_u16(skb, DCB_APP_ATTR_ID, id);\n\tif (ret)\n\t\tgoto out_cancel;\n\n\tret = nla_put_u8(skb, DCB_APP_ATTR_PRIORITY, up);\n\tif (ret)\n\t\tgoto out_cancel;\n\n\tnla_nest_end(skb, app_nest);\n\n\treturn 0;\n\nout_cancel:\n\tnla_nest_cancel(skb, app_nest);\n\treturn ret;\n}\n\nstatic int dcbnl_setapp(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tint ret;\n\tu16 id;\n\tu8 up, idtype;\n\tstruct nlattr *app_tb[DCB_APP_ATTR_MAX + 1];\n\n\tif (!tb[DCB_ATTR_APP])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested_deprecated(app_tb, DCB_APP_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_APP], dcbnl_app_nest,\n\t\t\t\t\t  NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((!app_tb[DCB_APP_ATTR_IDTYPE]) ||\n\t    (!app_tb[DCB_APP_ATTR_ID]) ||\n\t    (!app_tb[DCB_APP_ATTR_PRIORITY]))\n\t\treturn -EINVAL;\n\n\t \n\tidtype = nla_get_u8(app_tb[DCB_APP_ATTR_IDTYPE]);\n\tif ((idtype != DCB_APP_IDTYPE_ETHTYPE) &&\n\t    (idtype != DCB_APP_IDTYPE_PORTNUM))\n\t\treturn -EINVAL;\n\n\tid = nla_get_u16(app_tb[DCB_APP_ATTR_ID]);\n\tup = nla_get_u8(app_tb[DCB_APP_ATTR_PRIORITY]);\n\n\tif (netdev->dcbnl_ops->setapp) {\n\t\tret = netdev->dcbnl_ops->setapp(netdev, idtype, id, up);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tstruct dcb_app app;\n\t\tapp.selector = idtype;\n\t\tapp.protocol = id;\n\t\tapp.priority = up;\n\t\tret = dcb_setapp(netdev, &app);\n\t}\n\n\tret = nla_put_u8(skb, DCB_ATTR_APP, ret);\n\tdcbnl_cee_notify(netdev, RTM_SETDCB, DCB_CMD_SAPP, seq, 0);\n\n\treturn ret;\n}\n\nstatic int __dcbnl_pg_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     struct nlattr **tb, struct sk_buff *skb, int dir)\n{\n\tstruct nlattr *pg_nest, *param_nest, *data;\n\tstruct nlattr *pg_tb[DCB_PG_ATTR_MAX + 1];\n\tstruct nlattr *param_tb[DCB_TC_ATTR_PARAM_MAX + 1];\n\tu8 prio, pgid, tc_pct, up_map;\n\tint ret;\n\tint getall = 0;\n\tint i;\n\n\tif (!tb[DCB_ATTR_PG_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getpgtccfgtx ||\n\t    !netdev->dcbnl_ops->getpgtccfgrx ||\n\t    !netdev->dcbnl_ops->getpgbwgcfgtx ||\n\t    !netdev->dcbnl_ops->getpgbwgcfgrx)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested_deprecated(pg_tb, DCB_PG_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_PG_CFG], dcbnl_pg_nest,\n\t\t\t\t\t  NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tpg_nest = nla_nest_start_noflag(skb, DCB_ATTR_PG_CFG);\n\tif (!pg_nest)\n\t\treturn -EMSGSIZE;\n\n\tif (pg_tb[DCB_PG_ATTR_TC_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\n\t\tif (!getall && !pg_tb[i])\n\t\t\tcontinue;\n\n\t\tif (pg_tb[DCB_PG_ATTR_TC_ALL])\n\t\t\tdata = pg_tb[DCB_PG_ATTR_TC_ALL];\n\t\telse\n\t\t\tdata = pg_tb[i];\n\t\tret = nla_parse_nested_deprecated(param_tb,\n\t\t\t\t\t\t  DCB_TC_ATTR_PARAM_MAX, data,\n\t\t\t\t\t\t  dcbnl_tc_param_nest, NULL);\n\t\tif (ret)\n\t\t\tgoto err_pg;\n\n\t\tparam_nest = nla_nest_start_noflag(skb, i);\n\t\tif (!param_nest)\n\t\t\tgoto err_pg;\n\n\t\tpgid = DCB_ATTR_VALUE_UNDEFINED;\n\t\tprio = DCB_ATTR_VALUE_UNDEFINED;\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\t\tup_map = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (dir) {\n\t\t\t \n\t\t\tnetdev->dcbnl_ops->getpgtccfgrx(netdev,\n\t\t\t\t\t\ti - DCB_PG_ATTR_TC_0, &prio,\n\t\t\t\t\t\t&pgid, &tc_pct, &up_map);\n\t\t} else {\n\t\t\t \n\t\t\tnetdev->dcbnl_ops->getpgtccfgtx(netdev,\n\t\t\t\t\t\ti - DCB_PG_ATTR_TC_0, &prio,\n\t\t\t\t\t\t&pgid, &tc_pct, &up_map);\n\t\t}\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_PGID] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb,\n\t\t\t                 DCB_TC_ATTR_PARAM_PGID, pgid);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb,\n\t\t\t                 DCB_TC_ATTR_PARAM_UP_MAPPING, up_map);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb,\n\t\t\t                 DCB_TC_ATTR_PARAM_STRICT_PRIO, prio);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_BW_PCT] ||\n\t\t    param_tb[DCB_TC_ATTR_PARAM_ALL]) {\n\t\t\tret = nla_put_u8(skb, DCB_TC_ATTR_PARAM_BW_PCT,\n\t\t\t                 tc_pct);\n\t\t\tif (ret)\n\t\t\t\tgoto err_param;\n\t\t}\n\t\tnla_nest_end(skb, param_nest);\n\t}\n\n\tif (pg_tb[DCB_PG_ATTR_BW_ID_ALL])\n\t\tgetall = 1;\n\telse\n\t\tgetall = 0;\n\n\tfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\n\t\tif (!getall && !pg_tb[i])\n\t\t\tcontinue;\n\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (dir) {\n\t\t\t \n\t\t\tnetdev->dcbnl_ops->getpgbwgcfgrx(netdev,\n\t\t\t\t\ti - DCB_PG_ATTR_BW_ID_0, &tc_pct);\n\t\t} else {\n\t\t\t \n\t\t\tnetdev->dcbnl_ops->getpgbwgcfgtx(netdev,\n\t\t\t\t\ti - DCB_PG_ATTR_BW_ID_0, &tc_pct);\n\t\t}\n\t\tret = nla_put_u8(skb, i, tc_pct);\n\t\tif (ret)\n\t\t\tgoto err_pg;\n\t}\n\n\tnla_nest_end(skb, pg_nest);\n\n\treturn 0;\n\nerr_param:\n\tnla_nest_cancel(skb, param_nest);\nerr_pg:\n\tnla_nest_cancel(skb, pg_nest);\n\n\treturn -EMSGSIZE;\n}\n\nstatic int dcbnl_pgtx_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_getcfg(netdev, nlh, tb, skb, 0);\n}\n\nstatic int dcbnl_pgrx_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_getcfg(netdev, nlh, tb, skb, 1);\n}\n\nstatic int dcbnl_setstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 value;\n\n\tif (!tb[DCB_ATTR_STATE])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setstate)\n\t\treturn -EOPNOTSUPP;\n\n\tvalue = nla_get_u8(tb[DCB_ATTR_STATE]);\n\n\treturn nla_put_u8(skb, DCB_ATTR_STATE,\n\t\t\t  netdev->dcbnl_ops->setstate(netdev, value));\n}\n\nstatic int dcbnl_setpfccfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t   u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_PFC_UP_ATTR_MAX + 1];\n\tint i;\n\tint ret;\n\tu8 value;\n\n\tif (!tb[DCB_ATTR_PFC_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setpfccfg)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested_deprecated(data, DCB_PFC_UP_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_PFC_CFG],\n\t\t\t\t\t  dcbnl_pfc_up_nest, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue = nla_get_u8(data[i]);\n\t\tnetdev->dcbnl_ops->setpfccfg(netdev,\n\t\t\tdata[i]->nla_type - DCB_PFC_UP_ATTR_0, value);\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_PFC_CFG, 0);\n}\n\nstatic int dcbnl_setall(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tint ret;\n\n\tif (!tb[DCB_ATTR_SET_ALL])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setall)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_put_u8(skb, DCB_ATTR_SET_ALL,\n\t\t\t netdev->dcbnl_ops->setall(netdev));\n\tdcbnl_cee_notify(netdev, RTM_SETDCB, DCB_CMD_SET_ALL, seq, 0);\n\n\treturn ret;\n}\n\nstatic int __dcbnl_pg_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb,\n\t\t\t     int dir)\n{\n\tstruct nlattr *pg_tb[DCB_PG_ATTR_MAX + 1];\n\tstruct nlattr *param_tb[DCB_TC_ATTR_PARAM_MAX + 1];\n\tint ret;\n\tint i;\n\tu8 pgid;\n\tu8 up_map;\n\tu8 prio;\n\tu8 tc_pct;\n\n\tif (!tb[DCB_ATTR_PG_CFG])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setpgtccfgtx ||\n\t    !netdev->dcbnl_ops->setpgtccfgrx ||\n\t    !netdev->dcbnl_ops->setpgbwgcfgtx ||\n\t    !netdev->dcbnl_ops->setpgbwgcfgrx)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested_deprecated(pg_tb, DCB_PG_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_PG_CFG], dcbnl_pg_nest,\n\t\t\t\t\t  NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\n\t\tif (!pg_tb[i])\n\t\t\tcontinue;\n\n\t\tret = nla_parse_nested_deprecated(param_tb,\n\t\t\t\t\t\t  DCB_TC_ATTR_PARAM_MAX,\n\t\t\t\t\t\t  pg_tb[i],\n\t\t\t\t\t\t  dcbnl_tc_param_nest, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpgid = DCB_ATTR_VALUE_UNDEFINED;\n\t\tprio = DCB_ATTR_VALUE_UNDEFINED;\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\t\tup_map = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO])\n\t\t\tprio =\n\t\t\t    nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO]);\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_PGID])\n\t\t\tpgid = nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_PGID]);\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_BW_PCT])\n\t\t\ttc_pct = nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_BW_PCT]);\n\n\t\tif (param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING])\n\t\t\tup_map =\n\t\t\t     nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING]);\n\n\t\t \n\t\tif (dir) {\n\t\t\t \n\t\t\tnetdev->dcbnl_ops->setpgtccfgrx(netdev,\n\t\t\t\ti - DCB_PG_ATTR_TC_0,\n\t\t\t\tprio, pgid, tc_pct, up_map);\n\t\t} else {\n\t\t\t \n\t\t\tnetdev->dcbnl_ops->setpgtccfgtx(netdev,\n\t\t\t\ti - DCB_PG_ATTR_TC_0,\n\t\t\t\tprio, pgid, tc_pct, up_map);\n\t\t}\n\t}\n\n\tfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\n\t\tif (!pg_tb[i])\n\t\t\tcontinue;\n\n\t\ttc_pct = nla_get_u8(pg_tb[i]);\n\n\t\t \n\t\tif (dir) {\n\t\t\t \n\t\t\tnetdev->dcbnl_ops->setpgbwgcfgrx(netdev,\n\t\t\t\t\t i - DCB_PG_ATTR_BW_ID_0, tc_pct);\n\t\t} else {\n\t\t\t \n\t\t\tnetdev->dcbnl_ops->setpgbwgcfgtx(netdev,\n\t\t\t\t\t i - DCB_PG_ATTR_BW_ID_0, tc_pct);\n\t\t}\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_PG_CFG, 0);\n}\n\nstatic int dcbnl_pgtx_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_setcfg(netdev, nlh, seq, tb, skb, 0);\n}\n\nstatic int dcbnl_pgrx_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t     u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\treturn __dcbnl_pg_setcfg(netdev, nlh, seq, tb, skb, 1);\n}\n\nstatic int dcbnl_bcn_getcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *bcn_nest;\n\tstruct nlattr *bcn_tb[DCB_BCN_ATTR_MAX + 1];\n\tu8 value_byte;\n\tu32 value_integer;\n\tint ret;\n\tbool getall = false;\n\tint i;\n\n\tif (!tb[DCB_ATTR_BCN])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->getbcnrp ||\n\t    !netdev->dcbnl_ops->getbcncfg)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested_deprecated(bcn_tb, DCB_BCN_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_BCN], dcbnl_bcn_nest,\n\t\t\t\t\t  NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tbcn_nest = nla_nest_start_noflag(skb, DCB_ATTR_BCN);\n\tif (!bcn_nest)\n\t\treturn -EMSGSIZE;\n\n\tif (bcn_tb[DCB_BCN_ATTR_ALL])\n\t\tgetall = true;\n\n\tfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\n\t\tif (!getall && !bcn_tb[i])\n\t\t\tcontinue;\n\n\t\tnetdev->dcbnl_ops->getbcnrp(netdev, i - DCB_BCN_ATTR_RP_0,\n\t\t                            &value_byte);\n\t\tret = nla_put_u8(skb, i, value_byte);\n\t\tif (ret)\n\t\t\tgoto err_bcn;\n\t}\n\n\tfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\n\t\tif (!getall && !bcn_tb[i])\n\t\t\tcontinue;\n\n\t\tnetdev->dcbnl_ops->getbcncfg(netdev, i,\n\t\t                             &value_integer);\n\t\tret = nla_put_u32(skb, i, value_integer);\n\t\tif (ret)\n\t\t\tgoto err_bcn;\n\t}\n\n\tnla_nest_end(skb, bcn_nest);\n\n\treturn 0;\n\nerr_bcn:\n\tnla_nest_cancel(skb, bcn_nest);\n\treturn ret;\n}\n\nstatic int dcbnl_bcn_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_BCN_ATTR_MAX + 1];\n\tint i;\n\tint ret;\n\tu8 value_byte;\n\tu32 value_int;\n\n\tif (!tb[DCB_ATTR_BCN])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setbcncfg ||\n\t    !netdev->dcbnl_ops->setbcnrp)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested_deprecated(data, DCB_BCN_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_BCN], dcbnl_bcn_nest,\n\t\t\t\t\t  NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue_byte = nla_get_u8(data[i]);\n\t\tnetdev->dcbnl_ops->setbcnrp(netdev,\n\t\t\tdata[i]->nla_type - DCB_BCN_ATTR_RP_0, value_byte);\n\t}\n\n\tfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue_int = nla_get_u32(data[i]);\n\t\tnetdev->dcbnl_ops->setbcncfg(netdev,\n\t                                     i, value_int);\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_BCN, 0);\n}\n\nstatic int dcbnl_build_peer_app(struct net_device *netdev, struct sk_buff* skb,\n\t\t\t\tint app_nested_type, int app_info_type,\n\t\t\t\tint app_entry_type)\n{\n\tstruct dcb_peer_app_info info;\n\tstruct dcb_app *table = NULL;\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tu16 app_count;\n\tint err;\n\n\n\t \n\terr = ops->peer_getappinfo(netdev, &info, &app_count);\n\tif (!err && app_count) {\n\t\ttable = kmalloc_array(app_count, sizeof(struct dcb_app),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\terr = ops->peer_getapptable(netdev, table);\n\t}\n\n\tif (!err) {\n\t\tu16 i;\n\t\tstruct nlattr *app;\n\n\t\t \n\t\terr = -EMSGSIZE;\n\n\t\tapp = nla_nest_start_noflag(skb, app_nested_type);\n\t\tif (!app)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (app_info_type &&\n\t\t    nla_put(skb, app_info_type, sizeof(info), &info))\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < app_count; i++) {\n\t\t\tif (nla_put(skb, app_entry_type, sizeof(struct dcb_app),\n\t\t\t\t    &table[i]))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, app);\n\t}\n\terr = 0;\n\nnla_put_failure:\n\tkfree(table);\n\treturn err;\n}\n\nstatic int dcbnl_getapptrust(struct net_device *netdev, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tenum ieee_attrs_app type;\n\tstruct nlattr *apptrust;\n\tint nselectors, err, i;\n\tu8 *selectors;\n\n\tselectors = kzalloc(IEEE_8021QAZ_APP_SEL_MAX + 1, GFP_KERNEL);\n\tif (!selectors)\n\t\treturn -ENOMEM;\n\n\terr = ops->dcbnl_getapptrust(netdev, selectors, &nselectors);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tapptrust = nla_nest_start(skb, DCB_ATTR_DCB_APP_TRUST_TABLE);\n\tif (!apptrust) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nselectors; i++) {\n\t\ttype = dcbnl_app_attr_type_get(selectors[i]);\n\t\terr = nla_put_u8(skb, type, selectors[i]);\n\t\tif (err) {\n\t\t\tnla_nest_cancel(skb, apptrust);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnla_nest_end(skb, apptrust);\n\nout:\n\tkfree(selectors);\n\treturn err;\n}\n\n \nstatic int dcbnl_app_table_setdel(struct nlattr *attr,\n\t\t\t\t  struct net_device *netdev,\n\t\t\t\t  int (*setdel)(struct net_device *dev,\n\t\t\t\t\t\tstruct dcb_app *app))\n{\n\tstruct dcb_app *app_data;\n\tenum ieee_attrs_app type;\n\tstruct nlattr *attr_itr;\n\tint rem, err;\n\n\tnla_for_each_nested(attr_itr, attr, rem) {\n\t\ttype = nla_type(attr_itr);\n\n\t\tif (!dcbnl_app_attr_type_validate(type))\n\t\t\tcontinue;\n\n\t\tif (nla_len(attr_itr) < sizeof(struct dcb_app))\n\t\t\treturn -ERANGE;\n\n\t\tapp_data = nla_data(attr_itr);\n\n\t\tif (!dcbnl_app_selector_validate(type, app_data->selector))\n\t\t\treturn -EINVAL;\n\n\t\terr = setdel(netdev, app_data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tstruct nlattr *ieee, *app, *rewr;\n\tstruct dcb_app_type *itr;\n\tint dcbx;\n\tint err;\n\n\tif (nla_put_string(skb, DCB_ATTR_IFNAME, netdev->name))\n\t\treturn -EMSGSIZE;\n\n\tieee = nla_nest_start_noflag(skb, DCB_ATTR_IEEE);\n\tif (!ieee)\n\t\treturn -EMSGSIZE;\n\n\tif (ops->ieee_getets) {\n\t\tstruct ieee_ets ets;\n\t\tmemset(&ets, 0, sizeof(ets));\n\t\terr = ops->ieee_getets(netdev, &ets);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_ETS, sizeof(ets), &ets))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (ops->ieee_getmaxrate) {\n\t\tstruct ieee_maxrate maxrate;\n\t\tmemset(&maxrate, 0, sizeof(maxrate));\n\t\terr = ops->ieee_getmaxrate(netdev, &maxrate);\n\t\tif (!err) {\n\t\t\terr = nla_put(skb, DCB_ATTR_IEEE_MAXRATE,\n\t\t\t\t      sizeof(maxrate), &maxrate);\n\t\t\tif (err)\n\t\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\tif (ops->ieee_getqcn) {\n\t\tstruct ieee_qcn qcn;\n\n\t\tmemset(&qcn, 0, sizeof(qcn));\n\t\terr = ops->ieee_getqcn(netdev, &qcn);\n\t\tif (!err) {\n\t\t\terr = nla_put(skb, DCB_ATTR_IEEE_QCN,\n\t\t\t\t      sizeof(qcn), &qcn);\n\t\t\tif (err)\n\t\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\tif (ops->ieee_getqcnstats) {\n\t\tstruct ieee_qcn_stats qcn_stats;\n\n\t\tmemset(&qcn_stats, 0, sizeof(qcn_stats));\n\t\terr = ops->ieee_getqcnstats(netdev, &qcn_stats);\n\t\tif (!err) {\n\t\t\terr = nla_put(skb, DCB_ATTR_IEEE_QCN_STATS,\n\t\t\t\t      sizeof(qcn_stats), &qcn_stats);\n\t\t\tif (err)\n\t\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\tif (ops->ieee_getpfc) {\n\t\tstruct ieee_pfc pfc;\n\t\tmemset(&pfc, 0, sizeof(pfc));\n\t\terr = ops->ieee_getpfc(netdev, &pfc);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_PFC, sizeof(pfc), &pfc))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (ops->dcbnl_getbuffer) {\n\t\tstruct dcbnl_buffer buffer;\n\n\t\tmemset(&buffer, 0, sizeof(buffer));\n\t\terr = ops->dcbnl_getbuffer(netdev, &buffer);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_DCB_BUFFER, sizeof(buffer), &buffer))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tapp = nla_nest_start_noflag(skb, DCB_ATTR_IEEE_APP_TABLE);\n\tif (!app)\n\t\treturn -EMSGSIZE;\n\n\tspin_lock_bh(&dcb_lock);\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->ifindex == netdev->ifindex) {\n\t\t\tenum ieee_attrs_app type =\n\t\t\t\tdcbnl_app_attr_type_get(itr->app.selector);\n\t\t\terr = nla_put(skb, type, sizeof(itr->app), &itr->app);\n\t\t\tif (err) {\n\t\t\t\tspin_unlock_bh(&dcb_lock);\n\t\t\t\treturn -EMSGSIZE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (netdev->dcbnl_ops->getdcbx)\n\t\tdcbx = netdev->dcbnl_ops->getdcbx(netdev);\n\telse\n\t\tdcbx = -EOPNOTSUPP;\n\n\tspin_unlock_bh(&dcb_lock);\n\tnla_nest_end(skb, app);\n\n\trewr = nla_nest_start(skb, DCB_ATTR_DCB_REWR_TABLE);\n\tif (!rewr)\n\t\treturn -EMSGSIZE;\n\n\tspin_lock_bh(&dcb_lock);\n\tlist_for_each_entry(itr, &dcb_rewr_list, list) {\n\t\tif (itr->ifindex == netdev->ifindex) {\n\t\t\tenum ieee_attrs_app type =\n\t\t\t\tdcbnl_app_attr_type_get(itr->app.selector);\n\t\t\terr = nla_put(skb, type, sizeof(itr->app), &itr->app);\n\t\t\tif (err) {\n\t\t\t\tspin_unlock_bh(&dcb_lock);\n\t\t\t\tnla_nest_cancel(skb, rewr);\n\t\t\t\treturn -EMSGSIZE;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&dcb_lock);\n\tnla_nest_end(skb, rewr);\n\n\tif (ops->dcbnl_getapptrust) {\n\t\terr = dcbnl_getapptrust(netdev, skb);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (ops->ieee_peer_getets) {\n\t\tstruct ieee_ets ets;\n\t\tmemset(&ets, 0, sizeof(ets));\n\t\terr = ops->ieee_peer_getets(netdev, &ets);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_PEER_ETS, sizeof(ets), &ets))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (ops->ieee_peer_getpfc) {\n\t\tstruct ieee_pfc pfc;\n\t\tmemset(&pfc, 0, sizeof(pfc));\n\t\terr = ops->ieee_peer_getpfc(netdev, &pfc);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_IEEE_PEER_PFC, sizeof(pfc), &pfc))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (ops->peer_getappinfo && ops->peer_getapptable) {\n\t\terr = dcbnl_build_peer_app(netdev, skb,\n\t\t\t\t\t   DCB_ATTR_IEEE_PEER_APP,\n\t\t\t\t\t   DCB_ATTR_IEEE_APP_UNSPEC,\n\t\t\t\t\t   DCB_ATTR_IEEE_APP);\n\t\tif (err)\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tnla_nest_end(skb, ieee);\n\tif (dcbx >= 0) {\n\t\terr = nla_put_u8(skb, DCB_ATTR_DCBX, dcbx);\n\t\tif (err)\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int dcbnl_cee_pg_fill(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     int dir)\n{\n\tu8 pgid, up_map, prio, tc_pct;\n\tconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\n\tint i = dir ? DCB_ATTR_CEE_TX_PG : DCB_ATTR_CEE_RX_PG;\n\tstruct nlattr *pg = nla_nest_start_noflag(skb, i);\n\n\tif (!pg)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\n\t\tstruct nlattr *tc_nest = nla_nest_start_noflag(skb, i);\n\n\t\tif (!tc_nest)\n\t\t\treturn -EMSGSIZE;\n\n\t\tpgid = DCB_ATTR_VALUE_UNDEFINED;\n\t\tprio = DCB_ATTR_VALUE_UNDEFINED;\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\t\tup_map = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (!dir)\n\t\t\tops->getpgtccfgrx(dev, i - DCB_PG_ATTR_TC_0,\n\t\t\t\t\t  &prio, &pgid, &tc_pct, &up_map);\n\t\telse\n\t\t\tops->getpgtccfgtx(dev, i - DCB_PG_ATTR_TC_0,\n\t\t\t\t\t  &prio, &pgid, &tc_pct, &up_map);\n\n\t\tif (nla_put_u8(skb, DCB_TC_ATTR_PARAM_PGID, pgid) ||\n\t\t    nla_put_u8(skb, DCB_TC_ATTR_PARAM_UP_MAPPING, up_map) ||\n\t\t    nla_put_u8(skb, DCB_TC_ATTR_PARAM_STRICT_PRIO, prio) ||\n\t\t    nla_put_u8(skb, DCB_TC_ATTR_PARAM_BW_PCT, tc_pct))\n\t\t\treturn -EMSGSIZE;\n\t\tnla_nest_end(skb, tc_nest);\n\t}\n\n\tfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\n\t\ttc_pct = DCB_ATTR_VALUE_UNDEFINED;\n\n\t\tif (!dir)\n\t\t\tops->getpgbwgcfgrx(dev, i - DCB_PG_ATTR_BW_ID_0,\n\t\t\t\t\t   &tc_pct);\n\t\telse\n\t\t\tops->getpgbwgcfgtx(dev, i - DCB_PG_ATTR_BW_ID_0,\n\t\t\t\t\t   &tc_pct);\n\t\tif (nla_put_u8(skb, i, tc_pct))\n\t\t\treturn -EMSGSIZE;\n\t}\n\tnla_nest_end(skb, pg);\n\treturn 0;\n}\n\nstatic int dcbnl_cee_fill(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct nlattr *cee, *app;\n\tstruct dcb_app_type *itr;\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tint dcbx, i, err = -EMSGSIZE;\n\tu8 value;\n\n\tif (nla_put_string(skb, DCB_ATTR_IFNAME, netdev->name))\n\t\tgoto nla_put_failure;\n\tcee = nla_nest_start_noflag(skb, DCB_ATTR_CEE);\n\tif (!cee)\n\t\tgoto nla_put_failure;\n\n\t \n\tif (ops->getpgtccfgtx && ops->getpgbwgcfgtx) {\n\t\terr = dcbnl_cee_pg_fill(skb, netdev, 1);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->getpgtccfgrx && ops->getpgbwgcfgrx) {\n\t\terr = dcbnl_cee_pg_fill(skb, netdev, 0);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\t \n\tif (ops->getpfccfg) {\n\t\tstruct nlattr *pfc_nest = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t\tDCB_ATTR_CEE_PFC);\n\n\t\tif (!pfc_nest)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\n\t\t\tops->getpfccfg(netdev, i - DCB_PFC_UP_ATTR_0, &value);\n\t\t\tif (nla_put_u8(skb, i, value))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, pfc_nest);\n\t}\n\n\t \n\tspin_lock_bh(&dcb_lock);\n\tapp = nla_nest_start_noflag(skb, DCB_ATTR_CEE_APP_TABLE);\n\tif (!app)\n\t\tgoto dcb_unlock;\n\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->ifindex == netdev->ifindex) {\n\t\t\tstruct nlattr *app_nest = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t\t\tDCB_ATTR_APP);\n\t\t\tif (!app_nest)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\terr = nla_put_u8(skb, DCB_APP_ATTR_IDTYPE,\n\t\t\t\t\t itr->app.selector);\n\t\t\tif (err)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\terr = nla_put_u16(skb, DCB_APP_ATTR_ID,\n\t\t\t\t\t  itr->app.protocol);\n\t\t\tif (err)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\terr = nla_put_u8(skb, DCB_APP_ATTR_PRIORITY,\n\t\t\t\t\t itr->app.priority);\n\t\t\tif (err)\n\t\t\t\tgoto dcb_unlock;\n\n\t\t\tnla_nest_end(skb, app_nest);\n\t\t}\n\t}\n\tnla_nest_end(skb, app);\n\n\tif (netdev->dcbnl_ops->getdcbx)\n\t\tdcbx = netdev->dcbnl_ops->getdcbx(netdev);\n\telse\n\t\tdcbx = -EOPNOTSUPP;\n\n\tspin_unlock_bh(&dcb_lock);\n\n\t \n\tif (ops->getfeatcfg) {\n\t\tstruct nlattr *feat = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t    DCB_ATTR_CEE_FEAT);\n\t\tif (!feat)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = DCB_FEATCFG_ATTR_ALL + 1; i <= DCB_FEATCFG_ATTR_MAX;\n\t\t     i++)\n\t\t\tif (!ops->getfeatcfg(netdev, i, &value) &&\n\t\t\t    nla_put_u8(skb, i, value))\n\t\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, feat);\n\t}\n\n\t \n\tif (ops->cee_peer_getpg) {\n\t\tstruct cee_pg pg;\n\t\tmemset(&pg, 0, sizeof(pg));\n\t\terr = ops->cee_peer_getpg(netdev, &pg);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_CEE_PEER_PG, sizeof(pg), &pg))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->cee_peer_getpfc) {\n\t\tstruct cee_pfc pfc;\n\t\tmemset(&pfc, 0, sizeof(pfc));\n\t\terr = ops->cee_peer_getpfc(netdev, &pfc);\n\t\tif (!err &&\n\t\t    nla_put(skb, DCB_ATTR_CEE_PEER_PFC, sizeof(pfc), &pfc))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->peer_getappinfo && ops->peer_getapptable) {\n\t\terr = dcbnl_build_peer_app(netdev, skb,\n\t\t\t\t\t   DCB_ATTR_CEE_PEER_APP_TABLE,\n\t\t\t\t\t   DCB_ATTR_CEE_PEER_APP_INFO,\n\t\t\t\t\t   DCB_ATTR_CEE_PEER_APP);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, cee);\n\n\t \n\tif (dcbx >= 0) {\n\t\terr = nla_put_u8(skb, DCB_ATTR_DCBX, dcbx);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\treturn 0;\n\ndcb_unlock:\n\tspin_unlock_bh(&dcb_lock);\nnla_put_failure:\n\terr = -EMSGSIZE;\n\treturn err;\n}\n\nstatic int dcbnl_notify(struct net_device *dev, int event, int cmd,\n\t\t\tu32 seq, u32 portid, int dcbx_ver)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = dcbnl_newmsg(event, cmd, portid, seq, 0, &nlh);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (dcbx_ver == DCB_CAP_DCBX_VER_IEEE)\n\t\terr = dcbnl_ieee_fill(skb, dev);\n\telse\n\t\terr = dcbnl_cee_fill(skb, dev);\n\n\tif (err < 0) {\n\t\t \n\t\tnlmsg_free(skb);\n\t\trtnl_set_sk_err(net, RTNLGRP_DCB, err);\n\t} else {\n\t\t \n\t\tnlmsg_end(skb, nlh);\n\t\trtnl_notify(skb, net, 0, RTNLGRP_DCB, NULL, GFP_KERNEL);\n\t}\n\n\treturn err;\n}\n\nint dcbnl_ieee_notify(struct net_device *dev, int event, int cmd,\n\t\t      u32 seq, u32 portid)\n{\n\treturn dcbnl_notify(dev, event, cmd, seq, portid, DCB_CAP_DCBX_VER_IEEE);\n}\nEXPORT_SYMBOL(dcbnl_ieee_notify);\n\nint dcbnl_cee_notify(struct net_device *dev, int event, int cmd,\n\t\t     u32 seq, u32 portid)\n{\n\treturn dcbnl_notify(dev, event, cmd, seq, portid, DCB_CAP_DCBX_VER_CEE);\n}\nEXPORT_SYMBOL(dcbnl_cee_notify);\n\n \nstatic int dcbnl_ieee_set(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tstruct nlattr *ieee[DCB_ATTR_IEEE_MAX + 1];\n\tint prio;\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_IEEE])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(ieee, DCB_ATTR_IEEE_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_IEEE],\n\t\t\t\t\t  dcbnl_ieee_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (ieee[DCB_ATTR_IEEE_ETS] && ops->ieee_setets) {\n\t\tstruct ieee_ets *ets = nla_data(ieee[DCB_ATTR_IEEE_ETS]);\n\t\terr = ops->ieee_setets(netdev, ets);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_IEEE_MAXRATE] && ops->ieee_setmaxrate) {\n\t\tstruct ieee_maxrate *maxrate =\n\t\t\tnla_data(ieee[DCB_ATTR_IEEE_MAXRATE]);\n\t\terr = ops->ieee_setmaxrate(netdev, maxrate);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_IEEE_QCN] && ops->ieee_setqcn) {\n\t\tstruct ieee_qcn *qcn =\n\t\t\tnla_data(ieee[DCB_ATTR_IEEE_QCN]);\n\n\t\terr = ops->ieee_setqcn(netdev, qcn);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_IEEE_PFC] && ops->ieee_setpfc) {\n\t\tstruct ieee_pfc *pfc = nla_data(ieee[DCB_ATTR_IEEE_PFC]);\n\t\terr = ops->ieee_setpfc(netdev, pfc);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_DCB_BUFFER] && ops->dcbnl_setbuffer) {\n\t\tstruct dcbnl_buffer *buffer =\n\t\t\tnla_data(ieee[DCB_ATTR_DCB_BUFFER]);\n\n\t\tfor (prio = 0; prio < ARRAY_SIZE(buffer->prio2buffer); prio++) {\n\t\t\tif (buffer->prio2buffer[prio] >= DCBX_MAX_BUFFERS) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\terr = ops->dcbnl_setbuffer(netdev, buffer);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_DCB_REWR_TABLE]) {\n\t\terr = dcbnl_app_table_setdel(ieee[DCB_ATTR_DCB_REWR_TABLE],\n\t\t\t\t\t     netdev,\n\t\t\t\t\t     ops->dcbnl_setrewr ?: dcb_setrewr);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_IEEE_APP_TABLE]) {\n\t\terr = dcbnl_app_table_setdel(ieee[DCB_ATTR_IEEE_APP_TABLE],\n\t\t\t\t\t     netdev, ops->ieee_setapp ?:\n\t\t\t\t\t     dcb_ieee_setapp);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_DCB_APP_TRUST_TABLE]) {\n\t\tu8 selectors[IEEE_8021QAZ_APP_SEL_MAX + 1] = {0};\n\t\tstruct nlattr *attr;\n\t\tint nselectors = 0;\n\t\tint rem;\n\n\t\tif (!ops->dcbnl_setapptrust) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\n\t\tnla_for_each_nested(attr, ieee[DCB_ATTR_DCB_APP_TRUST_TABLE],\n\t\t\t\t    rem) {\n\t\t\tenum ieee_attrs_app type = nla_type(attr);\n\t\t\tu8 selector;\n\t\t\tint i;\n\n\t\t\tif (!dcbnl_app_attr_type_validate(type) ||\n\t\t\t    nla_len(attr) != 1 ||\n\t\t\t    nselectors >= sizeof(selectors)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tselector = nla_get_u8(attr);\n\n\t\t\tif (!dcbnl_app_selector_validate(type, selector)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (i = 0; i < nselectors; i++) {\n\t\t\t\tif (selectors[i] == selector) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tselectors[nselectors++] = selector;\n\t\t}\n\n\t\terr = ops->dcbnl_setapptrust(netdev, selectors, nselectors);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\nerr:\n\terr = nla_put_u8(skb, DCB_ATTR_IEEE, err);\n\tdcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_SET, seq, 0);\n\treturn err;\n}\n\nstatic int dcbnl_ieee_get(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dcbnl_ieee_fill(skb, netdev);\n}\n\nstatic int dcbnl_ieee_del(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\tstruct nlattr *ieee[DCB_ATTR_IEEE_MAX + 1];\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_IEEE])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(ieee, DCB_ATTR_IEEE_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_IEEE],\n\t\t\t\t\t  dcbnl_ieee_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (ieee[DCB_ATTR_IEEE_APP_TABLE]) {\n\t\terr = dcbnl_app_table_setdel(ieee[DCB_ATTR_IEEE_APP_TABLE],\n\t\t\t\t\t     netdev, ops->ieee_delapp ?:\n\t\t\t\t\t     dcb_ieee_delapp);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ieee[DCB_ATTR_DCB_REWR_TABLE]) {\n\t\terr = dcbnl_app_table_setdel(ieee[DCB_ATTR_DCB_REWR_TABLE],\n\t\t\t\t\t     netdev,\n\t\t\t\t\t     ops->dcbnl_delrewr ?: dcb_delrewr);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\nerr:\n\terr = nla_put_u8(skb, DCB_ATTR_IEEE, err);\n\tdcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_DEL, seq, 0);\n\treturn err;\n}\n\n\n \nstatic int dcbnl_getdcbx(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tif (!netdev->dcbnl_ops->getdcbx)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_DCBX,\n\t\t\t  netdev->dcbnl_ops->getdcbx(netdev));\n}\n\nstatic int dcbnl_setdcbx(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 value;\n\n\tif (!netdev->dcbnl_ops->setdcbx)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_DCBX])\n\t\treturn -EINVAL;\n\n\tvalue = nla_get_u8(tb[DCB_ATTR_DCBX]);\n\n\treturn nla_put_u8(skb, DCB_ATTR_DCBX,\n\t\t\t  netdev->dcbnl_ops->setdcbx(netdev, value));\n}\n\nstatic int dcbnl_getfeatcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_FEATCFG_ATTR_MAX + 1], *nest;\n\tu8 value;\n\tint ret, i;\n\tint getall = 0;\n\n\tif (!netdev->dcbnl_ops->getfeatcfg)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tb[DCB_ATTR_FEATCFG])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested_deprecated(data, DCB_FEATCFG_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_FEATCFG],\n\t\t\t\t\t  dcbnl_featcfg_nest, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tnest = nla_nest_start_noflag(skb, DCB_ATTR_FEATCFG);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (data[DCB_FEATCFG_ATTR_ALL])\n\t\tgetall = 1;\n\n\tfor (i = DCB_FEATCFG_ATTR_ALL+1; i <= DCB_FEATCFG_ATTR_MAX; i++) {\n\t\tif (!getall && !data[i])\n\t\t\tcontinue;\n\n\t\tret = netdev->dcbnl_ops->getfeatcfg(netdev, i, &value);\n\t\tif (!ret)\n\t\t\tret = nla_put_u8(skb, i, value);\n\n\t\tif (ret) {\n\t\t\tnla_nest_cancel(skb, nest);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\tnla_nest_end(skb, nest);\n\nnla_put_failure:\n\treturn ret;\n}\n\nstatic int dcbnl_setfeatcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_FEATCFG_ATTR_MAX + 1];\n\tint ret, i;\n\tu8 value;\n\n\tif (!netdev->dcbnl_ops->setfeatcfg)\n\t\treturn -ENOTSUPP;\n\n\tif (!tb[DCB_ATTR_FEATCFG])\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested_deprecated(data, DCB_FEATCFG_ATTR_MAX,\n\t\t\t\t\t  tb[DCB_ATTR_FEATCFG],\n\t\t\t\t\t  dcbnl_featcfg_nest, NULL);\n\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = DCB_FEATCFG_ATTR_ALL+1; i <= DCB_FEATCFG_ATTR_MAX; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\n\t\tvalue = nla_get_u8(data[i]);\n\n\t\tret = netdev->dcbnl_ops->setfeatcfg(netdev, i, value);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\nerr:\n\tret = nla_put_u8(skb, DCB_ATTR_FEATCFG, ret);\n\n\treturn ret;\n}\n\n \nstatic int dcbnl_cee_get(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dcbnl_cee_fill(skb, netdev);\n}\n\nstruct reply_func {\n\t \n\tint\ttype;\n\n\t \n\tint   (*cb)(struct net_device *, struct nlmsghdr *, u32,\n\t\t    struct nlattr **, struct sk_buff *);\n};\n\nstatic const struct reply_func reply_funcs[DCB_CMD_MAX+1] = {\n\t[DCB_CMD_GSTATE]\t= { RTM_GETDCB, dcbnl_getstate },\n\t[DCB_CMD_SSTATE]\t= { RTM_SETDCB, dcbnl_setstate },\n\t[DCB_CMD_PFC_GCFG]\t= { RTM_GETDCB, dcbnl_getpfccfg },\n\t[DCB_CMD_PFC_SCFG]\t= { RTM_SETDCB, dcbnl_setpfccfg },\n\t[DCB_CMD_GPERM_HWADDR]\t= { RTM_GETDCB, dcbnl_getperm_hwaddr },\n\t[DCB_CMD_GCAP]\t\t= { RTM_GETDCB, dcbnl_getcap },\n\t[DCB_CMD_GNUMTCS]\t= { RTM_GETDCB, dcbnl_getnumtcs },\n\t[DCB_CMD_SNUMTCS]\t= { RTM_SETDCB, dcbnl_setnumtcs },\n\t[DCB_CMD_PFC_GSTATE]\t= { RTM_GETDCB, dcbnl_getpfcstate },\n\t[DCB_CMD_PFC_SSTATE]\t= { RTM_SETDCB, dcbnl_setpfcstate },\n\t[DCB_CMD_GAPP]\t\t= { RTM_GETDCB, dcbnl_getapp },\n\t[DCB_CMD_SAPP]\t\t= { RTM_SETDCB, dcbnl_setapp },\n\t[DCB_CMD_PGTX_GCFG]\t= { RTM_GETDCB, dcbnl_pgtx_getcfg },\n\t[DCB_CMD_PGTX_SCFG]\t= { RTM_SETDCB, dcbnl_pgtx_setcfg },\n\t[DCB_CMD_PGRX_GCFG]\t= { RTM_GETDCB, dcbnl_pgrx_getcfg },\n\t[DCB_CMD_PGRX_SCFG]\t= { RTM_SETDCB, dcbnl_pgrx_setcfg },\n\t[DCB_CMD_SET_ALL]\t= { RTM_SETDCB, dcbnl_setall },\n\t[DCB_CMD_BCN_GCFG]\t= { RTM_GETDCB, dcbnl_bcn_getcfg },\n\t[DCB_CMD_BCN_SCFG]\t= { RTM_SETDCB, dcbnl_bcn_setcfg },\n\t[DCB_CMD_IEEE_GET]\t= { RTM_GETDCB, dcbnl_ieee_get },\n\t[DCB_CMD_IEEE_SET]\t= { RTM_SETDCB, dcbnl_ieee_set },\n\t[DCB_CMD_IEEE_DEL]\t= { RTM_SETDCB, dcbnl_ieee_del },\n\t[DCB_CMD_GDCBX]\t\t= { RTM_GETDCB, dcbnl_getdcbx },\n\t[DCB_CMD_SDCBX]\t\t= { RTM_SETDCB, dcbnl_setdcbx },\n\t[DCB_CMD_GFEATCFG]\t= { RTM_GETDCB, dcbnl_getfeatcfg },\n\t[DCB_CMD_SFEATCFG]\t= { RTM_SETDCB, dcbnl_setfeatcfg },\n\t[DCB_CMD_CEE_GET]\t= { RTM_GETDCB, dcbnl_cee_get },\n};\n\nstatic int dcb_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *netdev;\n\tstruct dcbmsg *dcb = nlmsg_data(nlh);\n\tstruct nlattr *tb[DCB_ATTR_MAX + 1];\n\tu32 portid = NETLINK_CB(skb).portid;\n\tint ret = -EINVAL;\n\tstruct sk_buff *reply_skb;\n\tstruct nlmsghdr *reply_nlh = NULL;\n\tconst struct reply_func *fn;\n\n\tif ((nlh->nlmsg_type == RTM_SETDCB) && !netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tret = nlmsg_parse_deprecated(nlh, sizeof(*dcb), tb, DCB_ATTR_MAX,\n\t\t\t\t     dcbnl_rtnl_policy, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dcb->cmd > DCB_CMD_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tfn = &reply_funcs[dcb->cmd];\n\tif (!fn->cb)\n\t\treturn -EOPNOTSUPP;\n\tif (fn->type == RTM_SETDCB && !netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!tb[DCB_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tnetdev = __dev_get_by_name(net, nla_data(tb[DCB_ATTR_IFNAME]));\n\tif (!netdev)\n\t\treturn -ENODEV;\n\n\tif (!netdev->dcbnl_ops)\n\t\treturn -EOPNOTSUPP;\n\n\treply_skb = dcbnl_newmsg(fn->type, dcb->cmd, portid, nlh->nlmsg_seq,\n\t\t\t\t nlh->nlmsg_flags, &reply_nlh);\n\tif (!reply_skb)\n\t\treturn -ENOMEM;\n\n\tret = fn->cb(netdev, nlh, nlh->nlmsg_seq, tb, reply_skb);\n\tif (ret < 0) {\n\t\tnlmsg_free(reply_skb);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(reply_skb, reply_nlh);\n\n\tret = rtnl_unicast(reply_skb, net, portid);\nout:\n\treturn ret;\n}\n\nstatic struct dcb_app_type *dcb_rewr_lookup(const struct dcb_app *app,\n\t\t\t\t\t    int ifindex, int proto)\n{\n\tstruct dcb_app_type *itr;\n\n\tlist_for_each_entry(itr, &dcb_rewr_list, list) {\n\t\tif (itr->app.selector == app->selector &&\n\t\t    itr->app.priority == app->priority &&\n\t\t    itr->ifindex == ifindex &&\n\t\t    ((proto == -1) || itr->app.protocol == proto))\n\t\t\treturn itr;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct dcb_app_type *dcb_app_lookup(const struct dcb_app *app,\n\t\t\t\t\t   int ifindex, int prio)\n{\n\tstruct dcb_app_type *itr;\n\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->app.selector == app->selector &&\n\t\t    itr->app.protocol == app->protocol &&\n\t\t    itr->ifindex == ifindex &&\n\t\t    ((prio == -1) || itr->app.priority == prio))\n\t\t\treturn itr;\n\t}\n\n\treturn NULL;\n}\n\nstatic int dcb_app_add(struct list_head *list, const struct dcb_app *app,\n\t\t       int ifindex)\n{\n\tstruct dcb_app_type *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&entry->app, app, sizeof(*app));\n\tentry->ifindex = ifindex;\n\tlist_add(&entry->list, list);\n\n\treturn 0;\n}\n\n \nu8 dcb_getapp(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app_type *itr;\n\tu8 prio = 0;\n\n\tspin_lock_bh(&dcb_lock);\n\titr = dcb_app_lookup(app, dev->ifindex, -1);\n\tif (itr)\n\t\tprio = itr->app.priority;\n\tspin_unlock_bh(&dcb_lock);\n\n\treturn prio;\n}\nEXPORT_SYMBOL(dcb_getapp);\n\n \nint dcb_setapp(struct net_device *dev, struct dcb_app *new)\n{\n\tstruct dcb_app_type *itr;\n\tstruct dcb_app_type event;\n\tint err = 0;\n\n\tevent.ifindex = dev->ifindex;\n\tmemcpy(&event.app, new, sizeof(event.app));\n\tif (dev->dcbnl_ops->getdcbx)\n\t\tevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\n\n\tspin_lock_bh(&dcb_lock);\n\t \n\titr = dcb_app_lookup(new, dev->ifindex, -1);\n\tif (itr) {\n\t\tif (new->priority)\n\t\t\titr->app.priority = new->priority;\n\t\telse {\n\t\t\tlist_del(&itr->list);\n\t\t\tkfree(itr);\n\t\t}\n\t\tgoto out;\n\t}\n\t \n\tif (new->priority)\n\t\terr = dcb_app_add(&dcb_app_list, new, dev->ifindex);\nout:\n\tspin_unlock_bh(&dcb_lock);\n\tif (!err)\n\t\tcall_dcbevent_notifiers(DCB_APP_EVENT, &event);\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_setapp);\n\n \nu8 dcb_ieee_getapp_mask(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app_type *itr;\n\tu8 prio = 0;\n\n\tspin_lock_bh(&dcb_lock);\n\titr = dcb_app_lookup(app, dev->ifindex, -1);\n\tif (itr)\n\t\tprio |= 1 << itr->app.priority;\n\tspin_unlock_bh(&dcb_lock);\n\n\treturn prio;\n}\nEXPORT_SYMBOL(dcb_ieee_getapp_mask);\n\n \nu16 dcb_getrewr(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app_type *itr;\n\tu16 proto = 0;\n\n\tspin_lock_bh(&dcb_lock);\n\titr = dcb_rewr_lookup(app, dev->ifindex, -1);\n\tif (itr)\n\t\tproto = itr->app.protocol;\n\tspin_unlock_bh(&dcb_lock);\n\n\treturn proto;\n}\nEXPORT_SYMBOL(dcb_getrewr);\n\n  \nint dcb_setrewr(struct net_device *dev, struct dcb_app *new)\n{\n\tint err;\n\n\tspin_lock_bh(&dcb_lock);\n\t \n\tif (dcb_rewr_lookup(new, dev->ifindex, new->protocol)) {\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = dcb_app_add(&dcb_rewr_list, new, dev->ifindex);\nout:\n\tspin_unlock_bh(&dcb_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_setrewr);\n\n \nint dcb_delrewr(struct net_device *dev, struct dcb_app *del)\n{\n\tstruct dcb_app_type *itr;\n\tint err = -ENOENT;\n\n\tspin_lock_bh(&dcb_lock);\n\t \n\titr = dcb_rewr_lookup(del, dev->ifindex, del->protocol);\n\tif (itr) {\n\t\tlist_del(&itr->list);\n\t\tkfree(itr);\n\t\terr = 0;\n\t}\n\n\tspin_unlock_bh(&dcb_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_delrewr);\n\n \nint dcb_ieee_setapp(struct net_device *dev, struct dcb_app *new)\n{\n\tstruct dcb_app_type event;\n\tint err = 0;\n\n\tevent.ifindex = dev->ifindex;\n\tmemcpy(&event.app, new, sizeof(event.app));\n\tif (dev->dcbnl_ops->getdcbx)\n\t\tevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\n\n\tspin_lock_bh(&dcb_lock);\n\t \n\tif (dcb_app_lookup(new, dev->ifindex, new->priority)) {\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = dcb_app_add(&dcb_app_list, new, dev->ifindex);\nout:\n\tspin_unlock_bh(&dcb_lock);\n\tif (!err)\n\t\tcall_dcbevent_notifiers(DCB_APP_EVENT, &event);\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_ieee_setapp);\n\n \nint dcb_ieee_delapp(struct net_device *dev, struct dcb_app *del)\n{\n\tstruct dcb_app_type *itr;\n\tstruct dcb_app_type event;\n\tint err = -ENOENT;\n\n\tevent.ifindex = dev->ifindex;\n\tmemcpy(&event.app, del, sizeof(event.app));\n\tif (dev->dcbnl_ops->getdcbx)\n\t\tevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\n\n\tspin_lock_bh(&dcb_lock);\n\t \n\tif ((itr = dcb_app_lookup(del, dev->ifindex, del->priority))) {\n\t\tlist_del(&itr->list);\n\t\tkfree(itr);\n\t\terr = 0;\n\t}\n\n\tspin_unlock_bh(&dcb_lock);\n\tif (!err)\n\t\tcall_dcbevent_notifiers(DCB_APP_EVENT, &event);\n\treturn err;\n}\nEXPORT_SYMBOL(dcb_ieee_delapp);\n\n \nvoid dcb_getrewr_prio_pcp_mask_map(const struct net_device *dev,\n\t\t\t\t   struct dcb_rewr_prio_pcp_map *p_map)\n{\n\tint ifindex = dev->ifindex;\n\tstruct dcb_app_type *itr;\n\tu8 prio;\n\n\tmemset(p_map->map, 0, sizeof(p_map->map));\n\n\tspin_lock_bh(&dcb_lock);\n\tlist_for_each_entry(itr, &dcb_rewr_list, list) {\n\t\tif (itr->ifindex == ifindex &&\n\t\t    itr->app.selector == DCB_APP_SEL_PCP &&\n\t\t    itr->app.protocol < 16 &&\n\t\t    itr->app.priority < IEEE_8021QAZ_MAX_TCS) {\n\t\t\tprio = itr->app.priority;\n\t\t\tp_map->map[prio] |= 1 << itr->app.protocol;\n\t\t}\n\t}\n\tspin_unlock_bh(&dcb_lock);\n}\nEXPORT_SYMBOL(dcb_getrewr_prio_pcp_mask_map);\n\n \nvoid dcb_getrewr_prio_dscp_mask_map(const struct net_device *dev,\n\t\t\t\t    struct dcb_ieee_app_prio_map *p_map)\n{\n\tint ifindex = dev->ifindex;\n\tstruct dcb_app_type *itr;\n\tu8 prio;\n\n\tmemset(p_map->map, 0, sizeof(p_map->map));\n\n\tspin_lock_bh(&dcb_lock);\n\tlist_for_each_entry(itr, &dcb_rewr_list, list) {\n\t\tif (itr->ifindex == ifindex &&\n\t\t    itr->app.selector == IEEE_8021QAZ_APP_SEL_DSCP &&\n\t\t    itr->app.protocol < 64 &&\n\t\t    itr->app.priority < IEEE_8021QAZ_MAX_TCS) {\n\t\t\tprio = itr->app.priority;\n\t\t\tp_map->map[prio] |= 1ULL << itr->app.protocol;\n\t\t}\n\t}\n\tspin_unlock_bh(&dcb_lock);\n}\nEXPORT_SYMBOL(dcb_getrewr_prio_dscp_mask_map);\n\n \nvoid dcb_ieee_getapp_prio_dscp_mask_map(const struct net_device *dev,\n\t\t\t\t\tstruct dcb_ieee_app_prio_map *p_map)\n{\n\tint ifindex = dev->ifindex;\n\tstruct dcb_app_type *itr;\n\tu8 prio;\n\n\tmemset(p_map->map, 0, sizeof(p_map->map));\n\n\tspin_lock_bh(&dcb_lock);\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->ifindex == ifindex &&\n\t\t    itr->app.selector == IEEE_8021QAZ_APP_SEL_DSCP &&\n\t\t    itr->app.protocol < 64 &&\n\t\t    itr->app.priority < IEEE_8021QAZ_MAX_TCS) {\n\t\t\tprio = itr->app.priority;\n\t\t\tp_map->map[prio] |= 1ULL << itr->app.protocol;\n\t\t}\n\t}\n\tspin_unlock_bh(&dcb_lock);\n}\nEXPORT_SYMBOL(dcb_ieee_getapp_prio_dscp_mask_map);\n\n \nvoid\ndcb_ieee_getapp_dscp_prio_mask_map(const struct net_device *dev,\n\t\t\t\t   struct dcb_ieee_app_dscp_map *p_map)\n{\n\tint ifindex = dev->ifindex;\n\tstruct dcb_app_type *itr;\n\n\tmemset(p_map->map, 0, sizeof(p_map->map));\n\n\tspin_lock_bh(&dcb_lock);\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->ifindex == ifindex &&\n\t\t    itr->app.selector == IEEE_8021QAZ_APP_SEL_DSCP &&\n\t\t    itr->app.protocol < 64 &&\n\t\t    itr->app.priority < IEEE_8021QAZ_MAX_TCS)\n\t\t\tp_map->map[itr->app.protocol] |= 1 << itr->app.priority;\n\t}\n\tspin_unlock_bh(&dcb_lock);\n}\nEXPORT_SYMBOL(dcb_ieee_getapp_dscp_prio_mask_map);\n\n \nu8 dcb_ieee_getapp_default_prio_mask(const struct net_device *dev)\n{\n\tint ifindex = dev->ifindex;\n\tstruct dcb_app_type *itr;\n\tu8 mask = 0;\n\n\tspin_lock_bh(&dcb_lock);\n\tlist_for_each_entry(itr, &dcb_app_list, list) {\n\t\tif (itr->ifindex == ifindex &&\n\t\t    itr->app.selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\n\t\t    itr->app.protocol == 0 &&\n\t\t    itr->app.priority < IEEE_8021QAZ_MAX_TCS)\n\t\t\tmask |= 1 << itr->app.priority;\n\t}\n\tspin_unlock_bh(&dcb_lock);\n\n\treturn mask;\n}\nEXPORT_SYMBOL(dcb_ieee_getapp_default_prio_mask);\n\nstatic void dcbnl_flush_dev(struct net_device *dev)\n{\n\tstruct dcb_app_type *itr, *tmp;\n\n\tspin_lock_bh(&dcb_lock);\n\n\tlist_for_each_entry_safe(itr, tmp, &dcb_app_list, list) {\n\t\tif (itr->ifindex == dev->ifindex) {\n\t\t\tlist_del(&itr->list);\n\t\t\tkfree(itr);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&dcb_lock);\n}\n\nstatic int dcbnl_netdevice_event(struct notifier_block *nb,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tif (!dev->dcbnl_ops)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tdcbnl_flush_dev(dev);\n\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic struct notifier_block dcbnl_nb __read_mostly = {\n\t.notifier_call  = dcbnl_netdevice_event,\n};\n\nstatic int __init dcbnl_init(void)\n{\n\tint err;\n\n\terr = register_netdevice_notifier(&dcbnl_nb);\n\tif (err)\n\t\treturn err;\n\n\trtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, 0);\n\n\treturn 0;\n}\ndevice_initcall(dcbnl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}