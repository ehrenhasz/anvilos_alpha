{
  "module_name": "nf_conntrack_proto.c",
  "hash_id": "e02210473debe0f9739d0da90a7f330c34f67f3c0fb59f79b37e928e8efb0f06",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_proto.c",
  "human_readable_source": "\n\n#include <linux/types.h>\n#include <linux/netfilter.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/err.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_bridge.h>\n#include <net/netfilter/nf_log.h>\n\n#include <linux/ip.h>\n#include <linux/icmp.h>\n#include <linux/sysctl.h>\n#include <net/route.h>\n#include <net/ip.h>\n\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/ipv4/nf_conntrack_ipv4.h>\n#include <net/netfilter/ipv6/nf_conntrack_ipv6.h>\n#include <net/netfilter/nf_nat_helper.h>\n#include <net/netfilter/ipv4/nf_defrag_ipv4.h>\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n\n#include <linux/ipv6.h>\n#include <linux/in6.h>\n#include <net/ipv6.h>\n#include <net/inet_frag.h>\n\nstatic DEFINE_MUTEX(nf_ct_proto_mutex);\n\n#ifdef CONFIG_SYSCTL\n__printf(4, 5)\nvoid nf_l4proto_log_invalid(const struct sk_buff *skb,\n\t\t\t    const struct nf_hook_state *state,\n\t\t\t    u8 protonum,\n\t\t\t    const char *fmt, ...)\n{\n\tstruct net *net = state->net;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (net->ct.sysctl_log_invalid != protonum &&\n\t    net->ct.sysctl_log_invalid != IPPROTO_RAW)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tnf_log_packet(net, state->pf, 0, skb, state->in, state->out,\n\t\t      NULL, \"nf_ct_proto_%d: %pV \", protonum, &vaf);\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(nf_l4proto_log_invalid);\n\n__printf(4, 5)\nvoid nf_ct_l4proto_log_invalid(const struct sk_buff *skb,\n\t\t\t       const struct nf_conn *ct,\n\t\t\t       const struct nf_hook_state *state,\n\t\t\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tstruct net *net;\n\tva_list args;\n\n\tnet = nf_ct_net(ct);\n\tif (likely(net->ct.sysctl_log_invalid == 0))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tnf_l4proto_log_invalid(skb, state,\n\t\t\t       nf_ct_protonum(ct), \"%pV\", &vaf);\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(nf_ct_l4proto_log_invalid);\n#endif\n\nconst struct nf_conntrack_l4proto *nf_ct_l4proto_find(u8 l4proto)\n{\n\tswitch (l4proto) {\n\tcase IPPROTO_UDP: return &nf_conntrack_l4proto_udp;\n\tcase IPPROTO_TCP: return &nf_conntrack_l4proto_tcp;\n\tcase IPPROTO_ICMP: return &nf_conntrack_l4proto_icmp;\n#ifdef CONFIG_NF_CT_PROTO_DCCP\n\tcase IPPROTO_DCCP: return &nf_conntrack_l4proto_dccp;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_SCTP\n\tcase IPPROTO_SCTP: return &nf_conntrack_l4proto_sctp;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_UDPLITE\n\tcase IPPROTO_UDPLITE: return &nf_conntrack_l4proto_udplite;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_GRE\n\tcase IPPROTO_GRE: return &nf_conntrack_l4proto_gre;\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase IPPROTO_ICMPV6: return &nf_conntrack_l4proto_icmpv6;\n#endif  \n\t}\n\n\treturn &nf_conntrack_l4proto_generic;\n};\nEXPORT_SYMBOL_GPL(nf_ct_l4proto_find);\n\nstatic bool in_vrf_postrouting(const struct nf_hook_state *state)\n{\n#if IS_ENABLED(CONFIG_NET_L3_MASTER_DEV)\n\tif (state->hook == NF_INET_POST_ROUTING &&\n\t    netif_is_l3_master(state->out))\n\t\treturn true;\n#endif\n\treturn false;\n}\n\nunsigned int nf_confirm(void *priv,\n\t\t\tstruct sk_buff *skb,\n\t\t\tconst struct nf_hook_state *state)\n{\n\tconst struct nf_conn_help *help;\n\tenum ip_conntrack_info ctinfo;\n\tunsigned int protoff;\n\tstruct nf_conn *ct;\n\tbool seqadj_needed;\n\t__be16 frag_off;\n\tint start;\n\tu8 pnum;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (!ct || in_vrf_postrouting(state))\n\t\treturn NF_ACCEPT;\n\n\thelp = nfct_help(ct);\n\n\tseqadj_needed = test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) && !nf_is_loopback_packet(skb);\n\tif (!help && !seqadj_needed)\n\t\treturn nf_conntrack_confirm(skb);\n\n\t \n\tif (ctinfo == IP_CT_RELATED_REPLY)\n\t\treturn nf_conntrack_confirm(skb);\n\n\tswitch (nf_ct_l3num(ct)) {\n\tcase NFPROTO_IPV4:\n\t\tprotoff = skb_network_offset(skb) + ip_hdrlen(skb);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tpnum = ipv6_hdr(skb)->nexthdr;\n\t\tstart = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &pnum, &frag_off);\n\t\tif (start < 0 || (frag_off & htons(~0x7)) != 0)\n\t\t\treturn nf_conntrack_confirm(skb);\n\n\t\tprotoff = start;\n\t\tbreak;\n\tdefault:\n\t\treturn nf_conntrack_confirm(skb);\n\t}\n\n\tif (help) {\n\t\tconst struct nf_conntrack_helper *helper;\n\t\tint ret;\n\n\t\t \n\t\thelper = rcu_dereference(help->helper);\n\t\tif (helper) {\n\t\t\tret = helper->help(skb,\n\t\t\t\t\t   protoff,\n\t\t\t\t\t   ct, ctinfo);\n\t\t\tif (ret != NF_ACCEPT)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (seqadj_needed &&\n\t    !nf_ct_seq_adjust(skb, ct, ctinfo, protoff)) {\n\t\tNF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop);\n\t\treturn NF_DROP;\n\t}\n\n\t \n\treturn nf_conntrack_confirm(skb);\n}\nEXPORT_SYMBOL_GPL(nf_confirm);\n\nstatic unsigned int ipv4_conntrack_in(void *priv,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const struct nf_hook_state *state)\n{\n\treturn nf_conntrack_in(skb, state);\n}\n\nstatic unsigned int ipv4_conntrack_local(void *priv,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t const struct nf_hook_state *state)\n{\n\tif (ip_is_fragment(ip_hdr(skb))) {  \n\t\tenum ip_conntrack_info ctinfo;\n\t\tstruct nf_conn *tmpl;\n\n\t\ttmpl = nf_ct_get(skb, &ctinfo);\n\t\tif (tmpl && nf_ct_is_template(tmpl)) {\n\t\t\t \n\t\t\tskb->_nfct = 0;\n\t\t\tnf_ct_put(tmpl);\n\t\t}\n\t\treturn NF_ACCEPT;\n\t}\n\n\treturn nf_conntrack_in(skb, state);\n}\n\n \nstatic const struct nf_hook_ops ipv4_conntrack_ops[] = {\n\t{\n\t\t.hook\t\t= ipv4_conntrack_in,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_PRE_ROUTING,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK,\n\t},\n\t{\n\t\t.hook\t\t= ipv4_conntrack_local,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_LOCAL_OUT,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK,\n\t},\n\t{\n\t\t.hook\t\t= nf_confirm,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_POST_ROUTING,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK_CONFIRM,\n\t},\n\t{\n\t\t.hook\t\t= nf_confirm,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_LOCAL_IN,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK_CONFIRM,\n\t},\n};\n\n \nstatic int\ngetorigdst(struct sock *sk, int optval, void __user *user, int *len)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct nf_conntrack_tuple_hash *h;\n\tstruct nf_conntrack_tuple tuple;\n\n\tmemset(&tuple, 0, sizeof(tuple));\n\n\tlock_sock(sk);\n\ttuple.src.u3.ip = inet->inet_rcv_saddr;\n\ttuple.src.u.tcp.port = inet->inet_sport;\n\ttuple.dst.u3.ip = inet->inet_daddr;\n\ttuple.dst.u.tcp.port = inet->inet_dport;\n\ttuple.src.l3num = PF_INET;\n\ttuple.dst.protonum = sk->sk_protocol;\n\trelease_sock(sk);\n\n\t \n\tif (tuple.dst.protonum != IPPROTO_TCP &&\n\t    tuple.dst.protonum != IPPROTO_SCTP)\n\t\treturn -ENOPROTOOPT;\n\n\tif ((unsigned int)*len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\th = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);\n\tif (h) {\n\t\tstruct sockaddr_in sin;\n\t\tstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = ct->tuplehash[IP_CT_DIR_ORIGINAL]\n\t\t\t.tuple.dst.u.tcp.port;\n\t\tsin.sin_addr.s_addr = ct->tuplehash[IP_CT_DIR_ORIGINAL]\n\t\t\t.tuple.dst.u3.ip;\n\t\tmemset(sin.sin_zero, 0, sizeof(sin.sin_zero));\n\n\t\tnf_ct_put(ct);\n\t\tif (copy_to_user(user, &sin, sizeof(sin)) != 0)\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\nstatic struct nf_sockopt_ops so_getorigdst = {\n\t.pf\t\t= PF_INET,\n\t.get_optmin\t= SO_ORIGINAL_DST,\n\t.get_optmax\t= SO_ORIGINAL_DST + 1,\n\t.get\t\t= getorigdst,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int\nipv6_getorigdst(struct sock *sk, int optval, void __user *user, int *len)\n{\n\tstruct nf_conntrack_tuple tuple = { .src.l3num = NFPROTO_IPV6 };\n\tconst struct ipv6_pinfo *inet6 = inet6_sk(sk);\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct nf_conntrack_tuple_hash *h;\n\tstruct sockaddr_in6 sin6;\n\tstruct nf_conn *ct;\n\t__be32 flow_label;\n\tint bound_dev_if;\n\n\tlock_sock(sk);\n\ttuple.src.u3.in6 = sk->sk_v6_rcv_saddr;\n\ttuple.src.u.tcp.port = inet->inet_sport;\n\ttuple.dst.u3.in6 = sk->sk_v6_daddr;\n\ttuple.dst.u.tcp.port = inet->inet_dport;\n\ttuple.dst.protonum = sk->sk_protocol;\n\tbound_dev_if = sk->sk_bound_dev_if;\n\tflow_label = inet6->flow_label;\n\trelease_sock(sk);\n\n\tif (tuple.dst.protonum != IPPROTO_TCP &&\n\t    tuple.dst.protonum != IPPROTO_SCTP)\n\t\treturn -ENOPROTOOPT;\n\n\tif (*len < 0 || (unsigned int)*len < sizeof(sin6))\n\t\treturn -EINVAL;\n\n\th = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);\n\tif (!h)\n\t\treturn -ENOENT;\n\n\tct = nf_ct_tuplehash_to_ctrack(h);\n\n\tsin6.sin6_family = AF_INET6;\n\tsin6.sin6_port = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port;\n\tsin6.sin6_flowinfo = flow_label & IPV6_FLOWINFO_MASK;\n\tmemcpy(&sin6.sin6_addr,\n\t       &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.in6,\n\t       sizeof(sin6.sin6_addr));\n\n\tnf_ct_put(ct);\n\tsin6.sin6_scope_id = ipv6_iface_scope_id(&sin6.sin6_addr, bound_dev_if);\n\treturn copy_to_user(user, &sin6, sizeof(sin6)) ? -EFAULT : 0;\n}\n\nstatic struct nf_sockopt_ops so_getorigdst6 = {\n\t.pf\t\t= NFPROTO_IPV6,\n\t.get_optmin\t= IP6T_SO_ORIGINAL_DST,\n\t.get_optmax\t= IP6T_SO_ORIGINAL_DST + 1,\n\t.get\t\t= ipv6_getorigdst,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic unsigned int ipv6_conntrack_in(void *priv,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const struct nf_hook_state *state)\n{\n\treturn nf_conntrack_in(skb, state);\n}\n\nstatic unsigned int ipv6_conntrack_local(void *priv,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t const struct nf_hook_state *state)\n{\n\treturn nf_conntrack_in(skb, state);\n}\n\nstatic const struct nf_hook_ops ipv6_conntrack_ops[] = {\n\t{\n\t\t.hook\t\t= ipv6_conntrack_in,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_PRE_ROUTING,\n\t\t.priority\t= NF_IP6_PRI_CONNTRACK,\n\t},\n\t{\n\t\t.hook\t\t= ipv6_conntrack_local,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_LOCAL_OUT,\n\t\t.priority\t= NF_IP6_PRI_CONNTRACK,\n\t},\n\t{\n\t\t.hook\t\t= nf_confirm,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_POST_ROUTING,\n\t\t.priority\t= NF_IP6_PRI_LAST,\n\t},\n\t{\n\t\t.hook\t\t= nf_confirm,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_LOCAL_IN,\n\t\t.priority\t= NF_IP6_PRI_LAST - 1,\n\t},\n};\n#endif\n\nstatic int nf_ct_tcp_fixup(struct nf_conn *ct, void *_nfproto)\n{\n\tu8 nfproto = (unsigned long)_nfproto;\n\n\tif (nf_ct_l3num(ct) != nfproto)\n\t\treturn 0;\n\n\tif (nf_ct_protonum(ct) == IPPROTO_TCP &&\n\t    ct->proto.tcp.state == TCP_CONNTRACK_ESTABLISHED) {\n\t\tct->proto.tcp.seen[0].td_maxwin = 0;\n\t\tct->proto.tcp.seen[1].td_maxwin = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nf_ct_bridge_info *nf_ct_bridge_info;\n\nstatic int nf_ct_netns_do_get(struct net *net, u8 nfproto)\n{\n\tstruct nf_conntrack_net *cnet = nf_ct_pernet(net);\n\tbool fixup_needed = false, retry = true;\n\tint err = 0;\nretry:\n\tmutex_lock(&nf_ct_proto_mutex);\n\n\tswitch (nfproto) {\n\tcase NFPROTO_IPV4:\n\t\tcnet->users4++;\n\t\tif (cnet->users4 > 1)\n\t\t\tgoto out_unlock;\n\t\terr = nf_defrag_ipv4_enable(net);\n\t\tif (err) {\n\t\t\tcnet->users4 = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = nf_register_net_hooks(net, ipv4_conntrack_ops,\n\t\t\t\t\t    ARRAY_SIZE(ipv4_conntrack_ops));\n\t\tif (err)\n\t\t\tcnet->users4 = 0;\n\t\telse\n\t\t\tfixup_needed = true;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase NFPROTO_IPV6:\n\t\tcnet->users6++;\n\t\tif (cnet->users6 > 1)\n\t\t\tgoto out_unlock;\n\t\terr = nf_defrag_ipv6_enable(net);\n\t\tif (err < 0) {\n\t\t\tcnet->users6 = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = nf_register_net_hooks(net, ipv6_conntrack_ops,\n\t\t\t\t\t    ARRAY_SIZE(ipv6_conntrack_ops));\n\t\tif (err)\n\t\t\tcnet->users6 = 0;\n\t\telse\n\t\t\tfixup_needed = true;\n\t\tbreak;\n#endif\n\tcase NFPROTO_BRIDGE:\n\t\tif (!nf_ct_bridge_info) {\n\t\t\tif (!retry) {\n\t\t\t\terr = -EPROTO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tmutex_unlock(&nf_ct_proto_mutex);\n\t\t\trequest_module(\"nf_conntrack_bridge\");\n\t\t\tretry = false;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!try_module_get(nf_ct_bridge_info->me)) {\n\t\t\terr = -EPROTO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tcnet->users_bridge++;\n\t\tif (cnet->users_bridge > 1)\n\t\t\tgoto out_unlock;\n\n\t\terr = nf_register_net_hooks(net, nf_ct_bridge_info->ops,\n\t\t\t\t\t    nf_ct_bridge_info->ops_size);\n\t\tif (err)\n\t\t\tcnet->users_bridge = 0;\n\t\telse\n\t\t\tfixup_needed = true;\n\t\tbreak;\n\tdefault:\n\t\terr = -EPROTO;\n\t\tbreak;\n\t}\n out_unlock:\n\tmutex_unlock(&nf_ct_proto_mutex);\n\n\tif (fixup_needed) {\n\t\tstruct nf_ct_iter_data iter_data = {\n\t\t\t.net\t= net,\n\t\t\t.data\t= (void *)(unsigned long)nfproto,\n\t\t};\n\t\tnf_ct_iterate_cleanup_net(nf_ct_tcp_fixup, &iter_data);\n\t}\n\n\treturn err;\n}\n\nstatic void nf_ct_netns_do_put(struct net *net, u8 nfproto)\n{\n\tstruct nf_conntrack_net *cnet = nf_ct_pernet(net);\n\n\tmutex_lock(&nf_ct_proto_mutex);\n\tswitch (nfproto) {\n\tcase NFPROTO_IPV4:\n\t\tif (cnet->users4 && (--cnet->users4 == 0)) {\n\t\t\tnf_unregister_net_hooks(net, ipv4_conntrack_ops,\n\t\t\t\t\t\tARRAY_SIZE(ipv4_conntrack_ops));\n\t\t\tnf_defrag_ipv4_disable(net);\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase NFPROTO_IPV6:\n\t\tif (cnet->users6 && (--cnet->users6 == 0)) {\n\t\t\tnf_unregister_net_hooks(net, ipv6_conntrack_ops,\n\t\t\t\t\t\tARRAY_SIZE(ipv6_conntrack_ops));\n\t\t\tnf_defrag_ipv6_disable(net);\n\t\t}\n\t\tbreak;\n#endif\n\tcase NFPROTO_BRIDGE:\n\t\tif (!nf_ct_bridge_info)\n\t\t\tbreak;\n\t\tif (cnet->users_bridge && (--cnet->users_bridge == 0))\n\t\t\tnf_unregister_net_hooks(net, nf_ct_bridge_info->ops,\n\t\t\t\t\t\tnf_ct_bridge_info->ops_size);\n\n\t\tmodule_put(nf_ct_bridge_info->me);\n\t\tbreak;\n\t}\n\tmutex_unlock(&nf_ct_proto_mutex);\n}\n\nstatic int nf_ct_netns_inet_get(struct net *net)\n{\n\tint err;\n\n\terr = nf_ct_netns_do_get(net, NFPROTO_IPV4);\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (err < 0)\n\t\tgoto err1;\n\terr = nf_ct_netns_do_get(net, NFPROTO_IPV6);\n\tif (err < 0)\n\t\tgoto err2;\n\n\treturn err;\nerr2:\n\tnf_ct_netns_put(net, NFPROTO_IPV4);\nerr1:\n#endif\n\treturn err;\n}\n\nint nf_ct_netns_get(struct net *net, u8 nfproto)\n{\n\tint err;\n\n\tswitch (nfproto) {\n\tcase NFPROTO_INET:\n\t\terr = nf_ct_netns_inet_get(net);\n\t\tbreak;\n\tcase NFPROTO_BRIDGE:\n\t\terr = nf_ct_netns_do_get(net, NFPROTO_BRIDGE);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = nf_ct_netns_inet_get(net);\n\t\tif (err < 0) {\n\t\t\tnf_ct_netns_put(net, NFPROTO_BRIDGE);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = nf_ct_netns_do_get(net, nfproto);\n\t\tbreak;\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nf_ct_netns_get);\n\nvoid nf_ct_netns_put(struct net *net, uint8_t nfproto)\n{\n\tswitch (nfproto) {\n\tcase NFPROTO_BRIDGE:\n\t\tnf_ct_netns_do_put(net, NFPROTO_BRIDGE);\n\t\tfallthrough;\n\tcase NFPROTO_INET:\n\t\tnf_ct_netns_do_put(net, NFPROTO_IPV4);\n\t\tnf_ct_netns_do_put(net, NFPROTO_IPV6);\n\t\tbreak;\n\tdefault:\n\t\tnf_ct_netns_do_put(net, nfproto);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(nf_ct_netns_put);\n\nvoid nf_ct_bridge_register(struct nf_ct_bridge_info *info)\n{\n\tWARN_ON(nf_ct_bridge_info);\n\tmutex_lock(&nf_ct_proto_mutex);\n\tnf_ct_bridge_info = info;\n\tmutex_unlock(&nf_ct_proto_mutex);\n}\nEXPORT_SYMBOL_GPL(nf_ct_bridge_register);\n\nvoid nf_ct_bridge_unregister(struct nf_ct_bridge_info *info)\n{\n\tWARN_ON(!nf_ct_bridge_info);\n\tmutex_lock(&nf_ct_proto_mutex);\n\tnf_ct_bridge_info = NULL;\n\tmutex_unlock(&nf_ct_proto_mutex);\n}\nEXPORT_SYMBOL_GPL(nf_ct_bridge_unregister);\n\nint nf_conntrack_proto_init(void)\n{\n\tint ret;\n\n\tret = nf_register_sockopt(&so_getorigdst);\n\tif (ret < 0)\n\t\treturn ret;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tret = nf_register_sockopt(&so_getorigdst6);\n\tif (ret < 0)\n\t\tgoto cleanup_sockopt;\n#endif\n\n\treturn ret;\n\n#if IS_ENABLED(CONFIG_IPV6)\ncleanup_sockopt:\n\tnf_unregister_sockopt(&so_getorigdst);\n#endif\n\treturn ret;\n}\n\nvoid nf_conntrack_proto_fini(void)\n{\n\tnf_unregister_sockopt(&so_getorigdst);\n#if IS_ENABLED(CONFIG_IPV6)\n\tnf_unregister_sockopt(&so_getorigdst6);\n#endif\n}\n\nvoid nf_conntrack_proto_pernet_init(struct net *net)\n{\n\tnf_conntrack_generic_init_net(net);\n\tnf_conntrack_udp_init_net(net);\n\tnf_conntrack_tcp_init_net(net);\n\tnf_conntrack_icmp_init_net(net);\n#if IS_ENABLED(CONFIG_IPV6)\n\tnf_conntrack_icmpv6_init_net(net);\n#endif\n#ifdef CONFIG_NF_CT_PROTO_DCCP\n\tnf_conntrack_dccp_init_net(net);\n#endif\n#ifdef CONFIG_NF_CT_PROTO_SCTP\n\tnf_conntrack_sctp_init_net(net);\n#endif\n#ifdef CONFIG_NF_CT_PROTO_GRE\n\tnf_conntrack_gre_init_net(net);\n#endif\n}\n\nmodule_param_call(hashsize, nf_conntrack_set_hashsize, param_get_uint,\n\t\t  &nf_conntrack_htable_size, 0600);\n\nMODULE_ALIAS(\"ip_conntrack\");\nMODULE_ALIAS(\"nf_conntrack-\" __stringify(AF_INET));\nMODULE_ALIAS(\"nf_conntrack-\" __stringify(AF_INET6));\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}