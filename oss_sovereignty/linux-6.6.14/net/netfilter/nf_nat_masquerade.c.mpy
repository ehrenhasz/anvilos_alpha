{
  "module_name": "nf_nat_masquerade.c",
  "hash_id": "de8950f511d4af14e11126369e18d96ca6210abb0e50c7da2b1c1d91b325c261",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_nat_masquerade.c",
  "human_readable_source": "\n\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/inetdevice.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/netfilter/nf_nat_masquerade.h>\n\nstruct masq_dev_work {\n\tstruct work_struct work;\n\tstruct net *net;\n\tnetns_tracker ns_tracker;\n\tunion nf_inet_addr addr;\n\tint ifindex;\n\tint (*iter)(struct nf_conn *i, void *data);\n};\n\n#define MAX_MASQ_WORKER_COUNT\t16\n\nstatic DEFINE_MUTEX(masq_mutex);\nstatic unsigned int masq_refcnt __read_mostly;\nstatic atomic_t masq_worker_count __read_mostly;\n\nunsigned int\nnf_nat_masquerade_ipv4(struct sk_buff *skb, unsigned int hooknum,\n\t\t       const struct nf_nat_range2 *range,\n\t\t       const struct net_device *out)\n{\n\tstruct nf_conn *ct;\n\tstruct nf_conn_nat *nat;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_nat_range2 newrange;\n\tconst struct rtable *rt;\n\t__be32 newsrc, nh;\n\n\tWARN_ON(hooknum != NF_INET_POST_ROUTING);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\n\tWARN_ON(!(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ||\n\t\t\t ctinfo == IP_CT_RELATED_REPLY)));\n\n\t \n\tif (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip == 0)\n\t\treturn NF_ACCEPT;\n\n\trt = skb_rtable(skb);\n\tnh = rt_nexthop(rt, ip_hdr(skb)->daddr);\n\tnewsrc = inet_select_addr(out, nh, RT_SCOPE_UNIVERSE);\n\tif (!newsrc) {\n\t\tpr_info(\"%s ate my IP address\\n\", out->name);\n\t\treturn NF_DROP;\n\t}\n\n\tnat = nf_ct_nat_ext_add(ct);\n\tif (nat)\n\t\tnat->masq_index = out->ifindex;\n\n\t \n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags       = range->flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newsrc;\n\tnewrange.max_addr.ip = newsrc;\n\tnewrange.min_proto   = range->min_proto;\n\tnewrange.max_proto   = range->max_proto;\n\n\t \n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_SRC);\n}\nEXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv4);\n\nstatic void iterate_cleanup_work(struct work_struct *work)\n{\n\tstruct nf_ct_iter_data iter_data = {};\n\tstruct masq_dev_work *w;\n\n\tw = container_of(work, struct masq_dev_work, work);\n\n\titer_data.net = w->net;\n\titer_data.data = (void *)w;\n\tnf_ct_iterate_cleanup_net(w->iter, &iter_data);\n\n\tput_net_track(w->net, &w->ns_tracker);\n\tkfree(w);\n\tatomic_dec(&masq_worker_count);\n\tmodule_put(THIS_MODULE);\n}\n\n \nstatic void nf_nat_masq_schedule(struct net *net, union nf_inet_addr *addr,\n\t\t\t\t int ifindex,\n\t\t\t\t int (*iter)(struct nf_conn *i, void *data),\n\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct masq_dev_work *w;\n\n\tif (atomic_read(&masq_worker_count) > MAX_MASQ_WORKER_COUNT)\n\t\treturn;\n\n\tnet = maybe_get_net(net);\n\tif (!net)\n\t\treturn;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\tgoto err_module;\n\n\tw = kzalloc(sizeof(*w), gfp_flags);\n\tif (w) {\n\t\t \n\t\tatomic_inc(&masq_worker_count);\n\n\t\tINIT_WORK(&w->work, iterate_cleanup_work);\n\t\tw->ifindex = ifindex;\n\t\tw->net = net;\n\t\tnetns_tracker_alloc(net, &w->ns_tracker, gfp_flags);\n\t\tw->iter = iter;\n\t\tif (addr)\n\t\t\tw->addr = *addr;\n\t\tschedule_work(&w->work);\n\t\treturn;\n\t}\n\n\tmodule_put(THIS_MODULE);\n err_module:\n\tput_net(net);\n}\n\nstatic int device_cmp(struct nf_conn *i, void *arg)\n{\n\tconst struct nf_conn_nat *nat = nfct_nat(i);\n\tconst struct masq_dev_work *w = arg;\n\n\tif (!nat)\n\t\treturn 0;\n\treturn nat->masq_index == w->ifindex;\n}\n\nstatic int masq_device_event(struct notifier_block *this,\n\t\t\t     unsigned long event,\n\t\t\t     void *ptr)\n{\n\tconst struct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\n\tif (event == NETDEV_DOWN) {\n\t\t \n\n\t\tnf_nat_masq_schedule(net, NULL, dev->ifindex,\n\t\t\t\t     device_cmp, GFP_KERNEL);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int inet_cmp(struct nf_conn *ct, void *ptr)\n{\n\tstruct nf_conntrack_tuple *tuple;\n\tstruct masq_dev_work *w = ptr;\n\n\tif (!device_cmp(ct, ptr))\n\t\treturn 0;\n\n\ttuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;\n\n\treturn nf_inet_addr_cmp(&w->addr, &tuple->dst.u3);\n}\n\nstatic int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tconst struct in_ifaddr *ifa = ptr;\n\tconst struct in_device *idev;\n\tconst struct net_device *dev;\n\tunion nf_inet_addr addr;\n\n\tif (event != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tidev = ifa->ifa_dev;\n\tif (idev->dead)\n\t\treturn NOTIFY_DONE;\n\n\tmemset(&addr, 0, sizeof(addr));\n\n\taddr.ip = ifa->ifa_address;\n\n\tdev = idev->dev;\n\tnf_nat_masq_schedule(dev_net(idev->dev), &addr, dev->ifindex,\n\t\t\t     inet_cmp, GFP_KERNEL);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block masq_dev_notifier = {\n\t.notifier_call\t= masq_device_event,\n};\n\nstatic struct notifier_block masq_inet_notifier = {\n\t.notifier_call\t= masq_inet_event,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int\nnat_ipv6_dev_get_saddr(struct net *net, const struct net_device *dev,\n\t\t       const struct in6_addr *daddr, unsigned int srcprefs,\n\t\t       struct in6_addr *saddr)\n{\n#ifdef CONFIG_IPV6_MODULE\n\tconst struct nf_ipv6_ops *v6_ops = nf_get_ipv6_ops();\n\n\tif (!v6_ops)\n\t\treturn -EHOSTUNREACH;\n\n\treturn v6_ops->dev_get_saddr(net, dev, daddr, srcprefs, saddr);\n#else\n\treturn ipv6_dev_get_saddr(net, dev, daddr, srcprefs, saddr);\n#endif\n}\n\nunsigned int\nnf_nat_masquerade_ipv6(struct sk_buff *skb, const struct nf_nat_range2 *range,\n\t\t       const struct net_device *out)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn_nat *nat;\n\tstruct in6_addr src;\n\tstruct nf_conn *ct;\n\tstruct nf_nat_range2 newrange;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tWARN_ON(!(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ||\n\t\t\t ctinfo == IP_CT_RELATED_REPLY)));\n\n\tif (nat_ipv6_dev_get_saddr(nf_ct_net(ct), out,\n\t\t\t\t   &ipv6_hdr(skb)->daddr, 0, &src) < 0)\n\t\treturn NF_DROP;\n\n\tnat = nf_ct_nat_ext_add(ct);\n\tif (nat)\n\t\tnat->masq_index = out->ifindex;\n\n\tnewrange.flags\t\t= range->flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.in6\t= src;\n\tnewrange.max_addr.in6\t= src;\n\tnewrange.min_proto\t= range->min_proto;\n\tnewrange.max_proto\t= range->max_proto;\n\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_SRC);\n}\nEXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv6);\n\n \nstatic int masq_inet6_event(struct notifier_block *this,\n\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct inet6_ifaddr *ifa = ptr;\n\tconst struct net_device *dev;\n\tunion nf_inet_addr addr;\n\n\tif (event != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\n\tdev = ifa->idev->dev;\n\n\tmemset(&addr, 0, sizeof(addr));\n\n\taddr.in6 = ifa->addr;\n\n\tnf_nat_masq_schedule(dev_net(dev), &addr, dev->ifindex, inet_cmp,\n\t\t\t     GFP_ATOMIC);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block masq_inet6_notifier = {\n\t.notifier_call\t= masq_inet6_event,\n};\n\nstatic int nf_nat_masquerade_ipv6_register_notifier(void)\n{\n\treturn register_inet6addr_notifier(&masq_inet6_notifier);\n}\n#else\nstatic inline int nf_nat_masquerade_ipv6_register_notifier(void) { return 0; }\n#endif\n\nint nf_nat_masquerade_inet_register_notifiers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&masq_mutex);\n\tif (WARN_ON_ONCE(masq_refcnt == UINT_MAX)) {\n\t\tret = -EOVERFLOW;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (++masq_refcnt > 1)\n\t\tgoto out_unlock;\n\n\t \n\tret = register_netdevice_notifier(&masq_dev_notifier);\n\tif (ret)\n\t\tgoto err_dec;\n\t \n\tret = register_inetaddr_notifier(&masq_inet_notifier);\n\tif (ret)\n\t\tgoto err_unregister;\n\n\tret = nf_nat_masquerade_ipv6_register_notifier();\n\tif (ret)\n\t\tgoto err_unreg_inet;\n\n\tmutex_unlock(&masq_mutex);\n\treturn ret;\nerr_unreg_inet:\n\tunregister_inetaddr_notifier(&masq_inet_notifier);\nerr_unregister:\n\tunregister_netdevice_notifier(&masq_dev_notifier);\nerr_dec:\n\tmasq_refcnt--;\nout_unlock:\n\tmutex_unlock(&masq_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nf_nat_masquerade_inet_register_notifiers);\n\nvoid nf_nat_masquerade_inet_unregister_notifiers(void)\n{\n\tmutex_lock(&masq_mutex);\n\t \n\tif (--masq_refcnt > 0)\n\t\tgoto out_unlock;\n\n\tunregister_netdevice_notifier(&masq_dev_notifier);\n\tunregister_inetaddr_notifier(&masq_inet_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tunregister_inet6addr_notifier(&masq_inet6_notifier);\n#endif\nout_unlock:\n\tmutex_unlock(&masq_mutex);\n}\nEXPORT_SYMBOL_GPL(nf_nat_masquerade_inet_unregister_notifiers);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}