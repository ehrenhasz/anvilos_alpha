{
  "module_name": "nfnetlink_osf.c",
  "hash_id": "3b297decb85fe3a49bb6235de30d8f03e7dd4ad4f04e8b95f67e5ba7536c07af",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nfnetlink_osf.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <linux/capability.h>\n#include <linux/if.h>\n#include <linux/inetdevice.h>\n#include <linux/ip.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/tcp.h>\n\n#include <net/ip.h>\n#include <net/tcp.h>\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/x_tables.h>\n#include <net/netfilter/nf_log.h>\n#include <linux/netfilter/nfnetlink_osf.h>\n\n \nstruct list_head nf_osf_fingers[2];\nEXPORT_SYMBOL_GPL(nf_osf_fingers);\n\nstatic inline int nf_osf_ttl(const struct sk_buff *skb,\n\t\t\t     int ttl_check, unsigned char f_ttl)\n{\n\tstruct in_device *in_dev = __in_dev_get_rcu(skb->dev);\n\tconst struct iphdr *ip = ip_hdr(skb);\n\tconst struct in_ifaddr *ifa;\n\tint ret = 0;\n\n\tif (ttl_check == NF_OSF_TTL_TRUE)\n\t\treturn ip->ttl == f_ttl;\n\tif (ttl_check == NF_OSF_TTL_NOCHECK)\n\t\treturn 1;\n\telse if (ip->ttl <= f_ttl)\n\t\treturn 1;\n\n\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\tif (inet_ifa_match(ip->saddr, ifa)) {\n\t\t\tret = (ip->ttl == f_ttl);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstruct nf_osf_hdr_ctx {\n\tbool\t\t\tdf;\n\tu16\t\t\twindow;\n\tu16\t\t\ttotlen;\n\tconst unsigned char\t*optp;\n\tunsigned int\t\toptsize;\n};\n\nstatic bool nf_osf_match_one(const struct sk_buff *skb,\n\t\t\t     const struct nf_osf_user_finger *f,\n\t\t\t     int ttl_check,\n\t\t\t     struct nf_osf_hdr_ctx *ctx)\n{\n\tconst __u8 *optpinit = ctx->optp;\n\tunsigned int check_WSS = 0;\n\tint fmatch = FMATCH_WRONG;\n\tint foptsize, optnum;\n\tu16 mss = 0;\n\n\tif (ctx->totlen != f->ss || !nf_osf_ttl(skb, ttl_check, f->ttl))\n\t\treturn false;\n\n\t \n\tif (f->wss.wc >= OSF_WSS_MAX)\n\t\treturn false;\n\n\t \n\n\tfoptsize = 0;\n\tfor (optnum = 0; optnum < f->opt_num; ++optnum)\n\t\tfoptsize += f->opt[optnum].length;\n\n\tif (foptsize > MAX_IPOPTLEN ||\n\t    ctx->optsize > MAX_IPOPTLEN ||\n\t    ctx->optsize != foptsize)\n\t\treturn false;\n\n\tcheck_WSS = f->wss.wc;\n\n\tfor (optnum = 0; optnum < f->opt_num; ++optnum) {\n\t\tif (f->opt[optnum].kind == *ctx->optp) {\n\t\t\t__u32 len = f->opt[optnum].length;\n\t\t\tconst __u8 *optend = ctx->optp + len;\n\n\t\t\tfmatch = FMATCH_OK;\n\n\t\t\tswitch (*ctx->optp) {\n\t\t\tcase OSFOPT_MSS:\n\t\t\t\tmss = ctx->optp[3];\n\t\t\t\tmss <<= 8;\n\t\t\t\tmss |= ctx->optp[2];\n\n\t\t\t\tmss = ntohs((__force __be16)mss);\n\t\t\t\tbreak;\n\t\t\tcase OSFOPT_TS:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tctx->optp = optend;\n\t\t} else\n\t\t\tfmatch = FMATCH_OPT_WRONG;\n\n\t\tif (fmatch != FMATCH_OK)\n\t\t\tbreak;\n\t}\n\n\tif (fmatch != FMATCH_OPT_WRONG) {\n\t\tfmatch = FMATCH_WRONG;\n\n\t\tswitch (check_WSS) {\n\t\tcase OSF_WSS_PLAIN:\n\t\t\tif (f->wss.val == 0 || ctx->window == f->wss.val)\n\t\t\t\tfmatch = FMATCH_OK;\n\t\t\tbreak;\n\t\tcase OSF_WSS_MSS:\n\t\t\t \n#define SMART_MSS_1\t1460\n#define SMART_MSS_2\t1448\n\t\t\tif (ctx->window == f->wss.val * mss ||\n\t\t\t    ctx->window == f->wss.val * SMART_MSS_1 ||\n\t\t\t    ctx->window == f->wss.val * SMART_MSS_2)\n\t\t\t\tfmatch = FMATCH_OK;\n\t\t\tbreak;\n\t\tcase OSF_WSS_MTU:\n\t\t\tif (ctx->window == f->wss.val * (mss + 40) ||\n\t\t\t    ctx->window == f->wss.val * (SMART_MSS_1 + 40) ||\n\t\t\t    ctx->window == f->wss.val * (SMART_MSS_2 + 40))\n\t\t\t\tfmatch = FMATCH_OK;\n\t\t\tbreak;\n\t\tcase OSF_WSS_MODULO:\n\t\t\tif ((ctx->window % f->wss.val) == 0)\n\t\t\t\tfmatch = FMATCH_OK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fmatch != FMATCH_OK)\n\t\tctx->optp = optpinit;\n\n\treturn fmatch == FMATCH_OK;\n}\n\nstatic const struct tcphdr *nf_osf_hdr_ctx_init(struct nf_osf_hdr_ctx *ctx,\n\t\t\t\t\t\tconst struct sk_buff *skb,\n\t\t\t\t\t\tconst struct iphdr *ip,\n\t\t\t\t\t\tunsigned char *opts,\n\t\t\t\t\t\tstruct tcphdr *_tcph)\n{\n\tconst struct tcphdr *tcp;\n\n\ttcp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(struct tcphdr), _tcph);\n\tif (!tcp)\n\t\treturn NULL;\n\n\tif (!tcp->syn)\n\t\treturn NULL;\n\n\tctx->totlen = ntohs(ip->tot_len);\n\tctx->df = ntohs(ip->frag_off) & IP_DF;\n\tctx->window = ntohs(tcp->window);\n\n\tif (tcp->doff * 4 > sizeof(struct tcphdr)) {\n\t\tctx->optsize = tcp->doff * 4 - sizeof(struct tcphdr);\n\n\t\tctx->optp = skb_header_pointer(skb, ip_hdrlen(skb) +\n\t\t\t\tsizeof(struct tcphdr), ctx->optsize, opts);\n\t\tif (!ctx->optp)\n\t\t\treturn NULL;\n\t}\n\n\treturn tcp;\n}\n\nbool\nnf_osf_match(const struct sk_buff *skb, u_int8_t family,\n\t     int hooknum, struct net_device *in, struct net_device *out,\n\t     const struct nf_osf_info *info, struct net *net,\n\t     const struct list_head *nf_osf_fingers)\n{\n\tconst struct iphdr *ip = ip_hdr(skb);\n\tconst struct nf_osf_user_finger *f;\n\tunsigned char opts[MAX_IPOPTLEN];\n\tconst struct nf_osf_finger *kf;\n\tint fcount = 0, ttl_check;\n\tint fmatch = FMATCH_WRONG;\n\tstruct nf_osf_hdr_ctx ctx;\n\tconst struct tcphdr *tcp;\n\tstruct tcphdr _tcph;\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\n\ttcp = nf_osf_hdr_ctx_init(&ctx, skb, ip, opts, &_tcph);\n\tif (!tcp)\n\t\treturn false;\n\n\tttl_check = (info->flags & NF_OSF_TTL) ? info->ttl : 0;\n\n\tlist_for_each_entry_rcu(kf, &nf_osf_fingers[ctx.df], finger_entry) {\n\n\t\tf = &kf->finger;\n\n\t\tif (!(info->flags & NF_OSF_LOG) && strcmp(info->genre, f->genre))\n\t\t\tcontinue;\n\n\t\tif (!nf_osf_match_one(skb, f, ttl_check, &ctx))\n\t\t\tcontinue;\n\n\t\tfmatch = FMATCH_OK;\n\n\t\tfcount++;\n\n\t\tif (info->flags & NF_OSF_LOG)\n\t\t\tnf_log_packet(net, family, hooknum, skb,\n\t\t\t\t      in, out, NULL,\n\t\t\t\t      \"%s [%s:%s] : %pI4:%d -> %pI4:%d hops=%d\\n\",\n\t\t\t\t      f->genre, f->version, f->subtype,\n\t\t\t\t      &ip->saddr, ntohs(tcp->source),\n\t\t\t\t      &ip->daddr, ntohs(tcp->dest),\n\t\t\t\t      f->ttl - ip->ttl);\n\n\t\tif ((info->flags & NF_OSF_LOG) &&\n\t\t    info->loglevel == NF_OSF_LOGLEVEL_FIRST)\n\t\t\tbreak;\n\t}\n\n\tif (!fcount && (info->flags & NF_OSF_LOG))\n\t\tnf_log_packet(net, family, hooknum, skb, in, out, NULL,\n\t\t\t      \"Remote OS is not known: %pI4:%u -> %pI4:%u\\n\",\n\t\t\t      &ip->saddr, ntohs(tcp->source),\n\t\t\t      &ip->daddr, ntohs(tcp->dest));\n\n\tif (fcount)\n\t\tfmatch = FMATCH_OK;\n\n\treturn fmatch == FMATCH_OK;\n}\nEXPORT_SYMBOL_GPL(nf_osf_match);\n\nbool nf_osf_find(const struct sk_buff *skb,\n\t\t const struct list_head *nf_osf_fingers,\n\t\t const int ttl_check, struct nf_osf_data *data)\n{\n\tconst struct iphdr *ip = ip_hdr(skb);\n\tconst struct nf_osf_user_finger *f;\n\tunsigned char opts[MAX_IPOPTLEN];\n\tconst struct nf_osf_finger *kf;\n\tstruct nf_osf_hdr_ctx ctx;\n\tconst struct tcphdr *tcp;\n\tstruct tcphdr _tcph;\n\tbool found = false;\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\n\ttcp = nf_osf_hdr_ctx_init(&ctx, skb, ip, opts, &_tcph);\n\tif (!tcp)\n\t\treturn false;\n\n\tlist_for_each_entry_rcu(kf, &nf_osf_fingers[ctx.df], finger_entry) {\n\t\tf = &kf->finger;\n\t\tif (!nf_osf_match_one(skb, f, ttl_check, &ctx))\n\t\t\tcontinue;\n\n\t\tdata->genre = f->genre;\n\t\tdata->version = f->version;\n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\treturn found;\n}\nEXPORT_SYMBOL_GPL(nf_osf_find);\n\nstatic const struct nla_policy nfnl_osf_policy[OSF_ATTR_MAX + 1] = {\n\t[OSF_ATTR_FINGER]\t= { .len = sizeof(struct nf_osf_user_finger) },\n};\n\nstatic int nfnl_osf_add_callback(struct sk_buff *skb,\n\t\t\t\t const struct nfnl_info *info,\n\t\t\t\t const struct nlattr * const osf_attrs[])\n{\n\tstruct nf_osf_user_finger *f;\n\tstruct nf_osf_finger *kf = NULL, *sf;\n\tint err = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!osf_attrs[OSF_ATTR_FINGER])\n\t\treturn -EINVAL;\n\n\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\treturn -EINVAL;\n\n\tf = nla_data(osf_attrs[OSF_ATTR_FINGER]);\n\n\tif (f->opt_num > ARRAY_SIZE(f->opt))\n\t\treturn -EINVAL;\n\n\tif (!memchr(f->genre, 0, MAXGENRELEN) ||\n\t    !memchr(f->subtype, 0, MAXGENRELEN) ||\n\t    !memchr(f->version, 0, MAXGENRELEN))\n\t\treturn -EINVAL;\n\n\tkf = kmalloc(sizeof(struct nf_osf_finger), GFP_KERNEL);\n\tif (!kf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&kf->finger, f, sizeof(struct nf_osf_user_finger));\n\n\tlist_for_each_entry(sf, &nf_osf_fingers[!!f->df], finger_entry) {\n\t\tif (memcmp(&sf->finger, f, sizeof(struct nf_osf_user_finger)))\n\t\t\tcontinue;\n\n\t\tkfree(kf);\n\t\tkf = NULL;\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL)\n\t\t\terr = -EEXIST;\n\t\tbreak;\n\t}\n\n\t \n\tif (kf)\n\t\tlist_add_tail_rcu(&kf->finger_entry, &nf_osf_fingers[!!f->df]);\n\n\treturn err;\n}\n\nstatic int nfnl_osf_remove_callback(struct sk_buff *skb,\n\t\t\t\t    const struct nfnl_info *info,\n\t\t\t\t    const struct nlattr * const osf_attrs[])\n{\n\tstruct nf_osf_user_finger *f;\n\tstruct nf_osf_finger *sf;\n\tint err = -ENOENT;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!osf_attrs[OSF_ATTR_FINGER])\n\t\treturn -EINVAL;\n\n\tf = nla_data(osf_attrs[OSF_ATTR_FINGER]);\n\n\tlist_for_each_entry(sf, &nf_osf_fingers[!!f->df], finger_entry) {\n\t\tif (memcmp(&sf->finger, f, sizeof(struct nf_osf_user_finger)))\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_del_rcu(&sf->finger_entry);\n\t\tkfree_rcu(sf, rcu_head);\n\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic const struct nfnl_callback nfnl_osf_callbacks[OSF_MSG_MAX] = {\n\t[OSF_MSG_ADD]\t= {\n\t\t.call\t\t= nfnl_osf_add_callback,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= OSF_ATTR_MAX,\n\t\t.policy\t\t= nfnl_osf_policy,\n\t},\n\t[OSF_MSG_REMOVE]\t= {\n\t\t.call\t\t= nfnl_osf_remove_callback,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= OSF_ATTR_MAX,\n\t\t.policy\t\t= nfnl_osf_policy,\n\t},\n};\n\nstatic const struct nfnetlink_subsystem nfnl_osf_subsys = {\n\t.name\t\t\t= \"osf\",\n\t.subsys_id\t\t= NFNL_SUBSYS_OSF,\n\t.cb_count\t\t= OSF_MSG_MAX,\n\t.cb\t\t\t= nfnl_osf_callbacks,\n};\n\nstatic int __init nfnl_osf_init(void)\n{\n\tint err = -EINVAL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nf_osf_fingers); ++i)\n\t\tINIT_LIST_HEAD(&nf_osf_fingers[i]);\n\n\terr = nfnetlink_subsys_register(&nfnl_osf_subsys);\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register OSF nsfnetlink helper (%d)\\n\", err);\n\t\tgoto err_out_exit;\n\t}\n\treturn 0;\n\nerr_out_exit:\n\treturn err;\n}\n\nstatic void __exit nfnl_osf_fini(void)\n{\n\tstruct nf_osf_finger *f;\n\tint i;\n\n\tnfnetlink_subsys_unregister(&nfnl_osf_subsys);\n\n\trcu_read_lock();\n\tfor (i = 0; i < ARRAY_SIZE(nf_osf_fingers); ++i) {\n\t\tlist_for_each_entry_rcu(f, &nf_osf_fingers[i], finger_entry) {\n\t\t\tlist_del_rcu(&f->finger_entry);\n\t\t\tkfree_rcu(f, rcu_head);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\trcu_barrier();\n}\n\nmodule_init(nfnl_osf_init);\nmodule_exit(nfnl_osf_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_OSF);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}