{
  "module_name": "xt_nfacct.c",
  "hash_id": "b878a21f6a6b4d85e2427c2bb798a39c3747bbdb238174769f23f8f7fa556da8",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_nfacct.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/nfnetlink_acct.h>\n#include <linux/netfilter/xt_nfacct.h>\n\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: match for the extended accounting infrastructure\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_nfacct\");\nMODULE_ALIAS(\"ip6t_nfacct\");\n\nstatic bool nfacct_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tint overquota;\n\tconst struct xt_nfacct_match_info *info = par->targinfo;\n\n\tnfnl_acct_update(skb, info->nfacct);\n\n\toverquota = nfnl_acct_overquota(xt_net(par), info->nfacct);\n\n\treturn overquota != NFACCT_UNDERQUOTA;\n}\n\nstatic int\nnfacct_mt_checkentry(const struct xt_mtchk_param *par)\n{\n\tstruct xt_nfacct_match_info *info = par->matchinfo;\n\tstruct nf_acct *nfacct;\n\n\tnfacct = nfnl_acct_find_get(par->net, info->name);\n\tif (nfacct == NULL) {\n\t\tpr_info_ratelimited(\"accounting object `%s' does not exists\\n\",\n\t\t\t\t    info->name);\n\t\treturn -ENOENT;\n\t}\n\tinfo->nfacct = nfacct;\n\treturn 0;\n}\n\nstatic void\nnfacct_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tconst struct xt_nfacct_match_info *info = par->matchinfo;\n\n\tnfnl_acct_put(info->nfacct);\n}\n\nstatic struct xt_match nfacct_mt_reg[] __read_mostly = {\n\t{\n\t\t.name       = \"nfacct\",\n\t\t.revision   = 0,\n\t\t.family     = NFPROTO_UNSPEC,\n\t\t.checkentry = nfacct_mt_checkentry,\n\t\t.match      = nfacct_mt,\n\t\t.destroy    = nfacct_mt_destroy,\n\t\t.matchsize  = sizeof(struct xt_nfacct_match_info),\n\t\t.usersize   = offsetof(struct xt_nfacct_match_info, nfacct),\n\t\t.me         = THIS_MODULE,\n\t},\n\t{\n\t\t.name       = \"nfacct\",\n\t\t.revision   = 1,\n\t\t.family     = NFPROTO_UNSPEC,\n\t\t.checkentry = nfacct_mt_checkentry,\n\t\t.match      = nfacct_mt,\n\t\t.destroy    = nfacct_mt_destroy,\n\t\t.matchsize  = sizeof(struct xt_nfacct_match_info_v1),\n\t\t.usersize   = offsetof(struct xt_nfacct_match_info_v1, nfacct),\n\t\t.me         = THIS_MODULE,\n\t},\n};\n\nstatic int __init nfacct_mt_init(void)\n{\n\treturn xt_register_matches(nfacct_mt_reg, ARRAY_SIZE(nfacct_mt_reg));\n}\n\nstatic void __exit nfacct_mt_exit(void)\n{\n\txt_unregister_matches(nfacct_mt_reg, ARRAY_SIZE(nfacct_mt_reg));\n}\n\nmodule_init(nfacct_mt_init);\nmodule_exit(nfacct_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}