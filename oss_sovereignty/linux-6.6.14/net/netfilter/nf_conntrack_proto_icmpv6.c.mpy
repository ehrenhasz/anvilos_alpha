{
  "module_name": "nf_conntrack_proto_icmpv6.c",
  "hash_id": "99a89f795c35186dec99d6b0aca8901500eff158fbfce86b8262a3d3605db64d",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_proto_icmpv6.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/module.h>\n#include <linux/netfilter.h>\n#include <linux/in6.h>\n#include <linux/icmpv6.h>\n#include <linux/ipv6.h>\n#include <net/ipv6.h>\n#include <net/ip6_checksum.h>\n#include <linux/seq_file.h>\n#include <linux/netfilter_ipv6.h>\n#include <net/netfilter/nf_conntrack_tuple.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/nf_log.h>\n\n#include \"nf_internals.h\"\n\nstatic const unsigned int nf_ct_icmpv6_timeout = 30*HZ;\n\nbool icmpv6_pkt_to_tuple(const struct sk_buff *skb,\n\t\t\t unsigned int dataoff,\n\t\t\t struct net *net,\n\t\t\t struct nf_conntrack_tuple *tuple)\n{\n\tconst struct icmp6hdr *hp;\n\tstruct icmp6hdr _hdr;\n\n\thp = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\n\tif (hp == NULL)\n\t\treturn false;\n\ttuple->dst.u.icmp.type = hp->icmp6_type;\n\ttuple->src.u.icmp.id = hp->icmp6_identifier;\n\ttuple->dst.u.icmp.code = hp->icmp6_code;\n\n\treturn true;\n}\n\n \nstatic const u_int8_t invmap[] = {\n\t[ICMPV6_ECHO_REQUEST - 128]\t= ICMPV6_ECHO_REPLY + 1,\n\t[ICMPV6_ECHO_REPLY - 128]\t= ICMPV6_ECHO_REQUEST + 1,\n\t[ICMPV6_NI_QUERY - 128]\t\t= ICMPV6_NI_REPLY + 1,\n\t[ICMPV6_NI_REPLY - 128]\t\t= ICMPV6_NI_QUERY + 1\n};\n\nstatic const u_int8_t noct_valid_new[] = {\n\t[ICMPV6_MGM_QUERY - 130] = 1,\n\t[ICMPV6_MGM_REPORT - 130] = 1,\n\t[ICMPV6_MGM_REDUCTION - 130] = 1,\n\t[NDISC_ROUTER_SOLICITATION - 130] = 1,\n\t[NDISC_ROUTER_ADVERTISEMENT - 130] = 1,\n\t[NDISC_NEIGHBOUR_SOLICITATION - 130] = 1,\n\t[NDISC_NEIGHBOUR_ADVERTISEMENT - 130] = 1,\n\t[ICMPV6_MLD2_REPORT - 130] = 1\n};\n\nbool nf_conntrack_invert_icmpv6_tuple(struct nf_conntrack_tuple *tuple,\n\t\t\t\t      const struct nf_conntrack_tuple *orig)\n{\n\tint type = orig->dst.u.icmp.type - 128;\n\tif (type < 0 || type >= sizeof(invmap) || !invmap[type])\n\t\treturn false;\n\n\ttuple->src.u.icmp.id   = orig->src.u.icmp.id;\n\ttuple->dst.u.icmp.type = invmap[type] - 1;\n\ttuple->dst.u.icmp.code = orig->dst.u.icmp.code;\n\treturn true;\n}\n\nstatic unsigned int *icmpv6_get_timeouts(struct net *net)\n{\n\treturn &nf_icmpv6_pernet(net)->timeout;\n}\n\n \nint nf_conntrack_icmpv6_packet(struct nf_conn *ct,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       enum ip_conntrack_info ctinfo,\n\t\t\t       const struct nf_hook_state *state)\n{\n\tunsigned int *timeout = nf_ct_timeout_lookup(ct);\n\tstatic const u8 valid_new[] = {\n\t\t[ICMPV6_ECHO_REQUEST - 128] = 1,\n\t\t[ICMPV6_NI_QUERY - 128] = 1\n\t};\n\n\tif (state->pf != NFPROTO_IPV6)\n\t\treturn -NF_ACCEPT;\n\n\tif (!nf_ct_is_confirmed(ct)) {\n\t\tint type = ct->tuplehash[0].tuple.dst.u.icmp.type - 128;\n\n\t\tif (type < 0 || type >= sizeof(valid_new) || !valid_new[type]) {\n\t\t\t \n\t\t\tpr_debug(\"icmpv6: can't create new conn with type %u\\n\",\n\t\t\t\t type + 128);\n\t\t\tnf_ct_dump_tuple_ipv6(&ct->tuplehash[0].tuple);\n\t\t\treturn -NF_ACCEPT;\n\t\t}\n\t}\n\n\tif (!timeout)\n\t\ttimeout = icmpv6_get_timeouts(nf_ct_net(ct));\n\n\t \n\tnf_ct_refresh_acct(ct, ctinfo, skb, *timeout);\n\n\treturn NF_ACCEPT;\n}\n\n\nstatic void icmpv6_error_log(const struct sk_buff *skb,\n\t\t\t     const struct nf_hook_state *state,\n\t\t\t     const char *msg)\n{\n\tnf_l4proto_log_invalid(skb, state, IPPROTO_ICMPV6, \"%s\", msg);\n}\n\nstatic noinline_for_stack int\nnf_conntrack_icmpv6_redirect(struct nf_conn *tmpl, struct sk_buff *skb,\n\t\t\t     unsigned int dataoff,\n\t\t\t     const struct nf_hook_state *state)\n{\n\tu8 hl = ipv6_hdr(skb)->hop_limit;\n\tunion nf_inet_addr outer_daddr;\n\tunion {\n\t\tstruct nd_opt_hdr nd_opt;\n\t\tstruct rd_msg rd_msg;\n\t} tmp;\n\tconst struct nd_opt_hdr *nd_opt;\n\tconst struct rd_msg *rd_msg;\n\n\trd_msg = skb_header_pointer(skb, dataoff, sizeof(*rd_msg), &tmp.rd_msg);\n\tif (!rd_msg) {\n\t\ticmpv6_error_log(skb, state, \"short redirect\");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\tif (rd_msg->icmph.icmp6_code != 0)\n\t\treturn NF_ACCEPT;\n\n\tif (hl != 255 || !(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL)) {\n\t\ticmpv6_error_log(skb, state, \"invalid saddr or hoplimit for redirect\");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\tdataoff += sizeof(*rd_msg);\n\n\t \n\tnd_opt = skb_header_pointer(skb, dataoff, sizeof(*nd_opt), &tmp.nd_opt);\n\tif (!nd_opt || nd_opt->nd_opt_len == 0) {\n\t\ticmpv6_error_log(skb, state, \"redirect without options\");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\t \n\tif (nd_opt->nd_opt_type != ND_OPT_REDIRECT_HDR)\n\t\treturn NF_ACCEPT;\n\n\tmemcpy(&outer_daddr.ip6, &ipv6_hdr(skb)->daddr,\n\t       sizeof(outer_daddr.ip6));\n\tdataoff += 8;\n\treturn nf_conntrack_inet_error(tmpl, skb, dataoff, state,\n\t\t\t\t       IPPROTO_ICMPV6, &outer_daddr);\n}\n\nint nf_conntrack_icmpv6_error(struct nf_conn *tmpl,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      unsigned int dataoff,\n\t\t\t      const struct nf_hook_state *state)\n{\n\tunion nf_inet_addr outer_daddr;\n\tconst struct icmp6hdr *icmp6h;\n\tstruct icmp6hdr _ih;\n\tint type;\n\n\ticmp6h = skb_header_pointer(skb, dataoff, sizeof(_ih), &_ih);\n\tif (icmp6h == NULL) {\n\t\ticmpv6_error_log(skb, state, \"short packet\");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\tif (state->hook == NF_INET_PRE_ROUTING &&\n\t    state->net->ct.sysctl_checksum &&\n\t    nf_ip6_checksum(skb, state->hook, dataoff, IPPROTO_ICMPV6)) {\n\t\ticmpv6_error_log(skb, state, \"ICMPv6 checksum failed\");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\ttype = icmp6h->icmp6_type - 130;\n\tif (type >= 0 && type < sizeof(noct_valid_new) &&\n\t    noct_valid_new[type]) {\n\t\tnf_ct_set(skb, NULL, IP_CT_UNTRACKED);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tif (icmp6h->icmp6_type == NDISC_REDIRECT)\n\t\treturn nf_conntrack_icmpv6_redirect(tmpl, skb, dataoff, state);\n\n\t \n\tif (icmp6h->icmp6_type >= 128)\n\t\treturn NF_ACCEPT;\n\n\tmemcpy(&outer_daddr.ip6, &ipv6_hdr(skb)->daddr,\n\t       sizeof(outer_daddr.ip6));\n\tdataoff += sizeof(*icmp6h);\n\treturn nf_conntrack_inet_error(tmpl, skb, dataoff, state,\n\t\t\t\t       IPPROTO_ICMPV6, &outer_daddr);\n}\n\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_conntrack.h>\nstatic int icmpv6_tuple_to_nlattr(struct sk_buff *skb,\n\t\t\t\t  const struct nf_conntrack_tuple *t)\n{\n\tif (nla_put_be16(skb, CTA_PROTO_ICMPV6_ID, t->src.u.icmp.id) ||\n\t    nla_put_u8(skb, CTA_PROTO_ICMPV6_TYPE, t->dst.u.icmp.type) ||\n\t    nla_put_u8(skb, CTA_PROTO_ICMPV6_CODE, t->dst.u.icmp.code))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic const struct nla_policy icmpv6_nla_policy[CTA_PROTO_MAX+1] = {\n\t[CTA_PROTO_ICMPV6_TYPE]\t= { .type = NLA_U8 },\n\t[CTA_PROTO_ICMPV6_CODE]\t= { .type = NLA_U8 },\n\t[CTA_PROTO_ICMPV6_ID]\t= { .type = NLA_U16 },\n};\n\nstatic int icmpv6_nlattr_to_tuple(struct nlattr *tb[],\n\t\t\t\tstruct nf_conntrack_tuple *tuple,\n\t\t\t\tu_int32_t flags)\n{\n\tif (flags & CTA_FILTER_FLAG(CTA_PROTO_ICMPV6_TYPE)) {\n\t\tif (!tb[CTA_PROTO_ICMPV6_TYPE])\n\t\t\treturn -EINVAL;\n\n\t\ttuple->dst.u.icmp.type = nla_get_u8(tb[CTA_PROTO_ICMPV6_TYPE]);\n\t\tif (tuple->dst.u.icmp.type < 128 ||\n\t\t    tuple->dst.u.icmp.type - 128 >= sizeof(invmap) ||\n\t\t    !invmap[tuple->dst.u.icmp.type - 128])\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (flags & CTA_FILTER_FLAG(CTA_PROTO_ICMPV6_CODE)) {\n\t\tif (!tb[CTA_PROTO_ICMPV6_CODE])\n\t\t\treturn -EINVAL;\n\n\t\ttuple->dst.u.icmp.code = nla_get_u8(tb[CTA_PROTO_ICMPV6_CODE]);\n\t}\n\n\tif (flags & CTA_FILTER_FLAG(CTA_PROTO_ICMPV6_ID)) {\n\t\tif (!tb[CTA_PROTO_ICMPV6_ID])\n\t\t\treturn -EINVAL;\n\n\t\ttuple->src.u.icmp.id = nla_get_be16(tb[CTA_PROTO_ICMPV6_ID]);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int icmpv6_nlattr_tuple_size(void)\n{\n\tstatic unsigned int size __read_mostly;\n\n\tif (!size)\n\t\tsize = nla_policy_len(icmpv6_nla_policy, CTA_PROTO_MAX + 1);\n\n\treturn size;\n}\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_cttimeout.h>\n\nstatic int icmpv6_timeout_nlattr_to_obj(struct nlattr *tb[],\n\t\t\t\t\tstruct net *net, void *data)\n{\n\tunsigned int *timeout = data;\n\tstruct nf_icmp_net *in = nf_icmpv6_pernet(net);\n\n\tif (!timeout)\n\t\ttimeout = icmpv6_get_timeouts(net);\n\tif (tb[CTA_TIMEOUT_ICMPV6_TIMEOUT]) {\n\t\t*timeout =\n\t\t    ntohl(nla_get_be32(tb[CTA_TIMEOUT_ICMPV6_TIMEOUT])) * HZ;\n\t} else {\n\t\t \n\t\t*timeout = in->timeout;\n\t}\n\treturn 0;\n}\n\nstatic int\nicmpv6_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\n{\n\tconst unsigned int *timeout = data;\n\n\tif (nla_put_be32(skb, CTA_TIMEOUT_ICMPV6_TIMEOUT, htonl(*timeout / HZ)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic const struct nla_policy\nicmpv6_timeout_nla_policy[CTA_TIMEOUT_ICMPV6_MAX+1] = {\n\t[CTA_TIMEOUT_ICMPV6_TIMEOUT]\t= { .type = NLA_U32 },\n};\n#endif  \n\nvoid nf_conntrack_icmpv6_init_net(struct net *net)\n{\n\tstruct nf_icmp_net *in = nf_icmpv6_pernet(net);\n\n\tin->timeout = nf_ct_icmpv6_timeout;\n}\n\nconst struct nf_conntrack_l4proto nf_conntrack_l4proto_icmpv6 =\n{\n\t.l4proto\t\t= IPPROTO_ICMPV6,\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.tuple_to_nlattr\t= icmpv6_tuple_to_nlattr,\n\t.nlattr_tuple_size\t= icmpv6_nlattr_tuple_size,\n\t.nlattr_to_tuple\t= icmpv6_nlattr_to_tuple,\n\t.nla_policy\t\t= icmpv6_nla_policy,\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\t.ctnl_timeout\t\t= {\n\t\t.nlattr_to_obj\t= icmpv6_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= icmpv6_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_ICMP_MAX,\n\t\t.obj_size\t= sizeof(unsigned int),\n\t\t.nla_policy\t= icmpv6_timeout_nla_policy,\n\t},\n#endif  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}