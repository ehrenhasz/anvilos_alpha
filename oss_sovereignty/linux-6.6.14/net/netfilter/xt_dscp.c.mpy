{
  "module_name": "xt_dscp.c",
  "hash_id": "2950eee33eeb49fe9f75dd418956159ebe003241cf35bd86f1e4f3e1b6059179",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_dscp.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/dsfield.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_dscp.h>\n\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: DSCP/TOS field match\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_dscp\");\nMODULE_ALIAS(\"ip6t_dscp\");\nMODULE_ALIAS(\"ipt_tos\");\nMODULE_ALIAS(\"ip6t_tos\");\n\nstatic bool\ndscp_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_dscp_info *info = par->matchinfo;\n\tu_int8_t dscp = ipv4_get_dsfield(ip_hdr(skb)) >> XT_DSCP_SHIFT;\n\n\treturn (dscp == info->dscp) ^ !!info->invert;\n}\n\nstatic bool\ndscp_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_dscp_info *info = par->matchinfo;\n\tu_int8_t dscp = ipv6_get_dsfield(ipv6_hdr(skb)) >> XT_DSCP_SHIFT;\n\n\treturn (dscp == info->dscp) ^ !!info->invert;\n}\n\nstatic int dscp_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_dscp_info *info = par->matchinfo;\n\n\tif (info->dscp > XT_DSCP_MAX)\n\t\treturn -EDOM;\n\n\treturn 0;\n}\n\nstatic bool tos_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_tos_match_info *info = par->matchinfo;\n\n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\treturn ((ip_hdr(skb)->tos & info->tos_mask) ==\n\t\t       info->tos_value) ^ !!info->invert;\n\telse\n\t\treturn ((ipv6_get_dsfield(ipv6_hdr(skb)) & info->tos_mask) ==\n\t\t       info->tos_value) ^ !!info->invert;\n}\n\nstatic struct xt_match dscp_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"dscp\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.checkentry\t= dscp_mt_check,\n\t\t.match\t\t= dscp_mt,\n\t\t.matchsize\t= sizeof(struct xt_dscp_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"dscp\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.checkentry\t= dscp_mt_check,\n\t\t.match\t\t= dscp_mt6,\n\t\t.matchsize\t= sizeof(struct xt_dscp_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"tos\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.match\t\t= tos_mt,\n\t\t.matchsize\t= sizeof(struct xt_tos_match_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"tos\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.match\t\t= tos_mt,\n\t\t.matchsize\t= sizeof(struct xt_tos_match_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init dscp_mt_init(void)\n{\n\treturn xt_register_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));\n}\n\nstatic void __exit dscp_mt_exit(void)\n{\n\txt_unregister_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));\n}\n\nmodule_init(dscp_mt_init);\nmodule_exit(dscp_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}