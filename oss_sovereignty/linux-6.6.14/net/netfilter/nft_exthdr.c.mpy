{
  "module_name": "nft_exthdr.c",
  "hash_id": "9176c4dd611ab3732a6208b08b1d7cf95ae2d2ae4bd5197ed6637506b0b5e046",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_exthdr.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/dccp.h>\n#include <linux/sctp.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/tcp.h>\n\nstruct nft_exthdr {\n\tu8\t\t\ttype;\n\tu8\t\t\toffset;\n\tu8\t\t\tlen;\n\tu8\t\t\top;\n\tu8\t\t\tdreg;\n\tu8\t\t\tsreg;\n\tu8\t\t\tflags;\n};\n\nstatic unsigned int optlen(const u8 *opt, unsigned int offset)\n{\n\t \n\tif (opt[offset] <= TCPOPT_NOP || opt[offset + 1] == 0)\n\t\treturn 1;\n\telse\n\t\treturn opt[offset + 1];\n}\n\nstatic int nft_skb_copy_to_reg(const struct sk_buff *skb, int offset, u32 *dest, unsigned int len)\n{\n\tif (len % NFT_REG32_SIZE)\n\t\tdest[len / NFT_REG32_SIZE] = 0;\n\n\treturn skb_copy_bits(skb, offset, dest, len);\n}\n\nstatic void nft_exthdr_ipv6_eval(const struct nft_expr *expr,\n\t\t\t\t struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tu32 *dest = &regs->data[priv->dreg];\n\tunsigned int offset = 0;\n\tint err;\n\n\tif (pkt->skb->protocol != htons(ETH_P_IPV6))\n\t\tgoto err;\n\n\terr = ipv6_find_hdr(pkt->skb, &offset, priv->type, NULL, NULL);\n\tif (priv->flags & NFT_EXTHDR_F_PRESENT) {\n\t\tnft_reg_store8(dest, err >= 0);\n\t\treturn;\n\t} else if (err < 0) {\n\t\tgoto err;\n\t}\n\toffset += priv->offset;\n\n\tif (nft_skb_copy_to_reg(pkt->skb, offset, dest, priv->len) < 0)\n\t\tgoto err;\n\treturn;\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\n\n \nstatic int ipv4_find_option(struct net *net, struct sk_buff *skb,\n\t\t\t    unsigned int *offset, int target)\n{\n\tunsigned char optbuf[sizeof(struct ip_options) + 40];\n\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\tstruct iphdr *iph, _iph;\n\tunsigned int start;\n\tbool found = false;\n\t__be32 info;\n\tint optlen;\n\n\tiph = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\n\tif (!iph)\n\t\treturn -EBADMSG;\n\tstart = sizeof(struct iphdr);\n\n\toptlen = iph->ihl * 4 - (int)sizeof(struct iphdr);\n\tif (optlen <= 0)\n\t\treturn -ENOENT;\n\n\tmemset(opt, 0, sizeof(struct ip_options));\n\t \n\tif (skb_copy_bits(skb, start, opt->__data, optlen))\n\t\treturn -EBADMSG;\n\topt->optlen = optlen;\n\n\tif (__ip_options_compile(net, opt, NULL, &info))\n\t\treturn -EBADMSG;\n\n\tswitch (target) {\n\tcase IPOPT_SSRR:\n\tcase IPOPT_LSRR:\n\t\tif (!opt->srr)\n\t\t\tbreak;\n\t\tfound = target == IPOPT_SSRR ? opt->is_strictroute :\n\t\t\t\t\t       !opt->is_strictroute;\n\t\tif (found)\n\t\t\t*offset = opt->srr + start;\n\t\tbreak;\n\tcase IPOPT_RR:\n\t\tif (!opt->rr)\n\t\t\tbreak;\n\t\t*offset = opt->rr + start;\n\t\tfound = true;\n\t\tbreak;\n\tcase IPOPT_RA:\n\t\tif (!opt->router_alert)\n\t\t\tbreak;\n\t\t*offset = opt->router_alert + start;\n\t\tfound = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn found ? target : -ENOENT;\n}\n\nstatic void nft_exthdr_ipv4_eval(const struct nft_expr *expr,\n\t\t\t\t struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tu32 *dest = &regs->data[priv->dreg];\n\tstruct sk_buff *skb = pkt->skb;\n\tunsigned int offset;\n\tint err;\n\n\tif (skb->protocol != htons(ETH_P_IP))\n\t\tgoto err;\n\n\terr = ipv4_find_option(nft_net(pkt), skb, &offset, priv->type);\n\tif (priv->flags & NFT_EXTHDR_F_PRESENT) {\n\t\tnft_reg_store8(dest, err >= 0);\n\t\treturn;\n\t} else if (err < 0) {\n\t\tgoto err;\n\t}\n\toffset += priv->offset;\n\n\tif (nft_skb_copy_to_reg(pkt->skb, offset, dest, priv->len) < 0)\n\t\tgoto err;\n\treturn;\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic void *\nnft_tcp_header_pointer(const struct nft_pktinfo *pkt,\n\t\t       unsigned int len, void *buffer, unsigned int *tcphdr_len)\n{\n\tstruct tcphdr *tcph;\n\n\tif (pkt->tprot != IPPROTO_TCP || pkt->fragoff)\n\t\treturn NULL;\n\n\ttcph = skb_header_pointer(pkt->skb, nft_thoff(pkt), sizeof(*tcph), buffer);\n\tif (!tcph)\n\t\treturn NULL;\n\n\t*tcphdr_len = __tcp_hdrlen(tcph);\n\tif (*tcphdr_len < sizeof(*tcph) || *tcphdr_len > len)\n\t\treturn NULL;\n\n\treturn skb_header_pointer(pkt->skb, nft_thoff(pkt), *tcphdr_len, buffer);\n}\n\nstatic void nft_exthdr_tcp_eval(const struct nft_expr *expr,\n\t\t\t\tstruct nft_regs *regs,\n\t\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tu8 buff[sizeof(struct tcphdr) + MAX_TCP_OPTION_SPACE];\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tunsigned int i, optl, tcphdr_len, offset;\n\tu32 *dest = &regs->data[priv->dreg];\n\tstruct tcphdr *tcph;\n\tu8 *opt;\n\n\ttcph = nft_tcp_header_pointer(pkt, sizeof(buff), buff, &tcphdr_len);\n\tif (!tcph)\n\t\tgoto err;\n\n\topt = (u8 *)tcph;\n\tfor (i = sizeof(*tcph); i < tcphdr_len - 1; i += optl) {\n\t\toptl = optlen(opt, i);\n\n\t\tif (priv->type != opt[i])\n\t\t\tcontinue;\n\n\t\tif (i + optl > tcphdr_len || priv->len + priv->offset > optl)\n\t\t\tgoto err;\n\n\t\toffset = i + priv->offset;\n\t\tif (priv->flags & NFT_EXTHDR_F_PRESENT) {\n\t\t\tnft_reg_store8(dest, 1);\n\t\t} else {\n\t\t\tif (priv->len % NFT_REG32_SIZE)\n\t\t\t\tdest[priv->len / NFT_REG32_SIZE] = 0;\n\t\t\tmemcpy(dest, opt + offset, priv->len);\n\t\t}\n\n\t\treturn;\n\t}\n\nerr:\n\tif (priv->flags & NFT_EXTHDR_F_PRESENT)\n\t\t*dest = 0;\n\telse\n\t\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic void nft_exthdr_tcp_set_eval(const struct nft_expr *expr,\n\t\t\t\t    struct nft_regs *regs,\n\t\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tu8 buff[sizeof(struct tcphdr) + MAX_TCP_OPTION_SPACE];\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tunsigned int i, optl, tcphdr_len, offset;\n\tstruct tcphdr *tcph;\n\tu8 *opt;\n\n\ttcph = nft_tcp_header_pointer(pkt, sizeof(buff), buff, &tcphdr_len);\n\tif (!tcph)\n\t\tgoto err;\n\n\tif (skb_ensure_writable(pkt->skb, nft_thoff(pkt) + tcphdr_len))\n\t\tgoto err;\n\n\ttcph = (struct tcphdr *)(pkt->skb->data + nft_thoff(pkt));\n\topt = (u8 *)tcph;\n\n\tfor (i = sizeof(*tcph); i < tcphdr_len - 1; i += optl) {\n\t\tunion {\n\t\t\t__be16 v16;\n\t\t\t__be32 v32;\n\t\t} old, new;\n\n\t\toptl = optlen(opt, i);\n\n\t\tif (priv->type != opt[i])\n\t\t\tcontinue;\n\n\t\tif (i + optl > tcphdr_len || priv->len + priv->offset > optl)\n\t\t\tgoto err;\n\n\t\toffset = i + priv->offset;\n\n\t\tswitch (priv->len) {\n\t\tcase 2:\n\t\t\told.v16 = (__force __be16)get_unaligned((u16 *)(opt + offset));\n\t\t\tnew.v16 = (__force __be16)nft_reg_load16(\n\t\t\t\t&regs->data[priv->sreg]);\n\n\t\t\tswitch (priv->type) {\n\t\t\tcase TCPOPT_MSS:\n\t\t\t\t \n\t\t\t\tif (ntohs(old.v16) <= ntohs(new.v16))\n\t\t\t\t\treturn;\n\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (old.v16 == new.v16)\n\t\t\t\treturn;\n\n\t\t\tput_unaligned(new.v16, (__be16*)(opt + offset));\n\t\t\tinet_proto_csum_replace2(&tcph->check, pkt->skb,\n\t\t\t\t\t\t old.v16, new.v16, false);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tnew.v32 = nft_reg_load_be32(&regs->data[priv->sreg]);\n\t\t\told.v32 = (__force __be32)get_unaligned((u32 *)(opt + offset));\n\n\t\t\tif (old.v32 == new.v32)\n\t\t\t\treturn;\n\n\t\t\tput_unaligned(new.v32, (__be32*)(opt + offset));\n\t\t\tinet_proto_csum_replace4(&tcph->check, pkt->skb,\n\t\t\t\t\t\t old.v32, new.v32, false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn;\n\t}\n\treturn;\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic void nft_exthdr_tcp_strip_eval(const struct nft_expr *expr,\n\t\t\t\t      struct nft_regs *regs,\n\t\t\t\t      const struct nft_pktinfo *pkt)\n{\n\tu8 buff[sizeof(struct tcphdr) + MAX_TCP_OPTION_SPACE];\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tunsigned int i, tcphdr_len, optl;\n\tstruct tcphdr *tcph;\n\tu8 *opt;\n\n\ttcph = nft_tcp_header_pointer(pkt, sizeof(buff), buff, &tcphdr_len);\n\tif (!tcph)\n\t\tgoto err;\n\n\tif (skb_ensure_writable(pkt->skb, nft_thoff(pkt) + tcphdr_len))\n\t\tgoto drop;\n\n\ttcph = (struct tcphdr *)(pkt->skb->data + nft_thoff(pkt));\n\topt = (u8 *)tcph;\n\n\tfor (i = sizeof(*tcph); i < tcphdr_len - 1; i += optl) {\n\t\tunsigned int j;\n\n\t\toptl = optlen(opt, i);\n\t\tif (priv->type != opt[i])\n\t\t\tcontinue;\n\n\t\tif (i + optl > tcphdr_len)\n\t\t\tgoto drop;\n\n\t\tfor (j = 0; j < optl; ++j) {\n\t\t\tu16 n = TCPOPT_NOP;\n\t\t\tu16 o = opt[i+j];\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\to <<= 8;\n\t\t\t\tn <<= 8;\n\t\t\t}\n\t\t\tinet_proto_csum_replace2(&tcph->check, pkt->skb, htons(o),\n\t\t\t\t\t\t htons(n), false);\n\t\t}\n\t\tmemset(opt + i, TCPOPT_NOP, optl);\n\t\treturn;\n\t}\n\n\t \n\treturn;\nerr:\n\tregs->verdict.code = NFT_BREAK;\n\treturn;\ndrop:\n\t \n\tregs->verdict.code = NF_DROP;\n}\n\nstatic void nft_exthdr_sctp_eval(const struct nft_expr *expr,\n\t\t\t\t struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tunsigned int offset = nft_thoff(pkt) + sizeof(struct sctphdr);\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tu32 *dest = &regs->data[priv->dreg];\n\tconst struct sctp_chunkhdr *sch;\n\tstruct sctp_chunkhdr _sch;\n\n\tif (pkt->tprot != IPPROTO_SCTP)\n\t\tgoto err;\n\n\tdo {\n\t\tsch = skb_header_pointer(pkt->skb, offset, sizeof(_sch), &_sch);\n\t\tif (!sch || !sch->length)\n\t\t\tbreak;\n\n\t\tif (sch->type == priv->type) {\n\t\t\tif (priv->flags & NFT_EXTHDR_F_PRESENT) {\n\t\t\t\tnft_reg_store8(dest, true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (priv->offset + priv->len > ntohs(sch->length) ||\n\t\t\t    offset + ntohs(sch->length) > pkt->skb->len)\n\t\t\t\tbreak;\n\n\t\t\tif (nft_skb_copy_to_reg(pkt->skb, offset + priv->offset,\n\t\t\t\t\t\tdest, priv->len) < 0)\n\t\t\t\tbreak;\n\t\t\treturn;\n\t\t}\n\t\toffset += SCTP_PAD4(ntohs(sch->length));\n\t} while (offset < pkt->skb->len);\nerr:\n\tif (priv->flags & NFT_EXTHDR_F_PRESENT)\n\t\tnft_reg_store8(dest, false);\n\telse\n\t\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic void nft_exthdr_dccp_eval(const struct nft_expr *expr,\n\t\t\t\t struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tunsigned int thoff, dataoff, optoff, optlen, i;\n\tu32 *dest = &regs->data[priv->dreg];\n\tconst struct dccp_hdr *dh;\n\tstruct dccp_hdr _dh;\n\n\tif (pkt->tprot != IPPROTO_DCCP || pkt->fragoff)\n\t\tgoto err;\n\n\tthoff = nft_thoff(pkt);\n\n\tdh = skb_header_pointer(pkt->skb, thoff, sizeof(_dh), &_dh);\n\tif (!dh)\n\t\tgoto err;\n\n\tdataoff = dh->dccph_doff * sizeof(u32);\n\toptoff = __dccp_hdr_len(dh);\n\tif (dataoff <= optoff)\n\t\tgoto err;\n\n\toptlen = dataoff - optoff;\n\n\tfor (i = 0; i < optlen; ) {\n\t\t \n\t\tunsigned int buflen = optlen - i;\n\t\tu8 buf[2], *bufp;\n\t\tu8 type, len;\n\n\t\tif (buflen > sizeof(buf))\n\t\t\tbuflen = sizeof(buf);\n\n\t\tbufp = skb_header_pointer(pkt->skb, thoff + optoff + i, buflen,\n\t\t\t\t\t  &buf);\n\t\tif (!bufp)\n\t\t\tgoto err;\n\n\t\ttype = bufp[0];\n\n\t\tif (type == priv->type) {\n\t\t\tnft_reg_store8(dest, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (type <= DCCPO_MAX_RESERVED) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buflen < 2)\n\t\t\tgoto err;\n\n\t\tlen = bufp[1];\n\n\t\tif (len < 2)\n\t\t\tgoto err;\n\n\t\ti += len;\n\t}\n\nerr:\n\t*dest = 0;\n}\n\nstatic const struct nla_policy nft_exthdr_policy[NFTA_EXTHDR_MAX + 1] = {\n\t[NFTA_EXTHDR_DREG]\t\t= { .type = NLA_U32 },\n\t[NFTA_EXTHDR_TYPE]\t\t= { .type = NLA_U8 },\n\t[NFTA_EXTHDR_OFFSET]\t\t= { .type = NLA_U32 },\n\t[NFTA_EXTHDR_LEN]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_EXTHDR_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NFTA_EXTHDR_OP]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_EXTHDR_SREG]\t\t= { .type = NLA_U32 },\n};\n\nstatic int nft_exthdr_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tu32 offset, len, flags = 0, op = NFT_EXTHDR_OP_IPV6;\n\tint err;\n\n\tif (!tb[NFTA_EXTHDR_DREG] ||\n\t    !tb[NFTA_EXTHDR_TYPE] ||\n\t    !tb[NFTA_EXTHDR_OFFSET] ||\n\t    !tb[NFTA_EXTHDR_LEN])\n\t\treturn -EINVAL;\n\n\terr = nft_parse_u32_check(tb[NFTA_EXTHDR_OFFSET], U8_MAX, &offset);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_parse_u32_check(tb[NFTA_EXTHDR_LEN], U8_MAX, &len);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_EXTHDR_FLAGS]) {\n\t\terr = nft_parse_u32_check(tb[NFTA_EXTHDR_FLAGS], U8_MAX, &flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (flags & ~NFT_EXTHDR_F_PRESENT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NFTA_EXTHDR_OP]) {\n\t\terr = nft_parse_u32_check(tb[NFTA_EXTHDR_OP], U8_MAX, &op);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tpriv->type   = nla_get_u8(tb[NFTA_EXTHDR_TYPE]);\n\tpriv->offset = offset;\n\tpriv->len    = len;\n\tpriv->flags  = flags;\n\tpriv->op     = op;\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_EXTHDR_DREG],\n\t\t\t\t\t&priv->dreg, NULL, NFT_DATA_VALUE,\n\t\t\t\t\tpriv->len);\n}\n\nstatic int nft_exthdr_tcp_set_init(const struct nft_ctx *ctx,\n\t\t\t\t   const struct nft_expr *expr,\n\t\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tu32 offset, len, flags = 0, op = NFT_EXTHDR_OP_IPV6;\n\tint err;\n\n\tif (!tb[NFTA_EXTHDR_SREG] ||\n\t    !tb[NFTA_EXTHDR_TYPE] ||\n\t    !tb[NFTA_EXTHDR_OFFSET] ||\n\t    !tb[NFTA_EXTHDR_LEN])\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_EXTHDR_DREG] || tb[NFTA_EXTHDR_FLAGS])\n\t\treturn -EINVAL;\n\n\terr = nft_parse_u32_check(tb[NFTA_EXTHDR_OFFSET], U8_MAX, &offset);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_parse_u32_check(tb[NFTA_EXTHDR_LEN], U8_MAX, &len);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (offset < 2)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (len) {\n\tcase 2: break;\n\tcase 4: break;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = nft_parse_u32_check(tb[NFTA_EXTHDR_OP], U8_MAX, &op);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->type   = nla_get_u8(tb[NFTA_EXTHDR_TYPE]);\n\tpriv->offset = offset;\n\tpriv->len    = len;\n\tpriv->flags  = flags;\n\tpriv->op     = op;\n\n\treturn nft_parse_register_load(tb[NFTA_EXTHDR_SREG], &priv->sreg,\n\t\t\t\t       priv->len);\n}\n\nstatic int nft_exthdr_tcp_strip_init(const struct nft_ctx *ctx,\n\t\t\t\t     const struct nft_expr *expr,\n\t\t\t\t     const struct nlattr * const tb[])\n{\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\n\tif (tb[NFTA_EXTHDR_SREG] ||\n\t    tb[NFTA_EXTHDR_DREG] ||\n\t    tb[NFTA_EXTHDR_FLAGS] ||\n\t    tb[NFTA_EXTHDR_OFFSET] ||\n\t    tb[NFTA_EXTHDR_LEN])\n\t\treturn -EINVAL;\n\n\tif (!tb[NFTA_EXTHDR_TYPE])\n\t\treturn -EINVAL;\n\n\tpriv->type = nla_get_u8(tb[NFTA_EXTHDR_TYPE]);\n\tpriv->op = NFT_EXTHDR_OP_TCPOPT;\n\n\treturn 0;\n}\n\nstatic int nft_exthdr_ipv4_init(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr,\n\t\t\t\tconst struct nlattr * const tb[])\n{\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tint err = nft_exthdr_init(ctx, expr, tb);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (priv->type) {\n\tcase IPOPT_SSRR:\n\tcase IPOPT_LSRR:\n\tcase IPOPT_RR:\n\tcase IPOPT_RA:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int nft_exthdr_dccp_init(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr,\n\t\t\t\tconst struct nlattr * const tb[])\n{\n\tstruct nft_exthdr *priv = nft_expr_priv(expr);\n\tint err = nft_exthdr_init(ctx, expr, tb);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!(priv->flags & NFT_EXTHDR_F_PRESENT))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int nft_exthdr_dump_common(struct sk_buff *skb, const struct nft_exthdr *priv)\n{\n\tif (nla_put_u8(skb, NFTA_EXTHDR_TYPE, priv->type))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_EXTHDR_OFFSET, htonl(priv->offset)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_EXTHDR_LEN, htonl(priv->len)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_EXTHDR_FLAGS, htonl(priv->flags)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_EXTHDR_OP, htonl(priv->op)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_exthdr_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_exthdr *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_EXTHDR_DREG, priv->dreg))\n\t\treturn -1;\n\n\treturn nft_exthdr_dump_common(skb, priv);\n}\n\nstatic int nft_exthdr_dump_set(struct sk_buff *skb,\n\t\t\t       const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_exthdr *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_EXTHDR_SREG, priv->sreg))\n\t\treturn -1;\n\n\treturn nft_exthdr_dump_common(skb, priv);\n}\n\nstatic int nft_exthdr_dump_strip(struct sk_buff *skb,\n\t\t\t\t const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_exthdr *priv = nft_expr_priv(expr);\n\n\treturn nft_exthdr_dump_common(skb, priv);\n}\n\nstatic bool nft_exthdr_reduce(struct nft_regs_track *track,\n\t\t\t       const struct nft_expr *expr)\n{\n\tconst struct nft_exthdr *priv = nft_expr_priv(expr);\n\tconst struct nft_exthdr *exthdr;\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\texthdr = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->type != exthdr->type ||\n\t    priv->op != exthdr->op ||\n\t    priv->flags != exthdr->flags ||\n\t    priv->offset != exthdr->offset ||\n\t    priv->len != exthdr->len) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn nft_expr_reduce_bitwise(track, expr);\n}\n\nstatic const struct nft_expr_ops nft_exthdr_ipv6_ops = {\n\t.type\t\t= &nft_exthdr_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_exthdr)),\n\t.eval\t\t= nft_exthdr_ipv6_eval,\n\t.init\t\t= nft_exthdr_init,\n\t.dump\t\t= nft_exthdr_dump,\n\t.reduce\t\t= nft_exthdr_reduce,\n};\n\nstatic const struct nft_expr_ops nft_exthdr_ipv4_ops = {\n\t.type\t\t= &nft_exthdr_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_exthdr)),\n\t.eval\t\t= nft_exthdr_ipv4_eval,\n\t.init\t\t= nft_exthdr_ipv4_init,\n\t.dump\t\t= nft_exthdr_dump,\n\t.reduce\t\t= nft_exthdr_reduce,\n};\n\nstatic const struct nft_expr_ops nft_exthdr_tcp_ops = {\n\t.type\t\t= &nft_exthdr_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_exthdr)),\n\t.eval\t\t= nft_exthdr_tcp_eval,\n\t.init\t\t= nft_exthdr_init,\n\t.dump\t\t= nft_exthdr_dump,\n\t.reduce\t\t= nft_exthdr_reduce,\n};\n\nstatic const struct nft_expr_ops nft_exthdr_tcp_set_ops = {\n\t.type\t\t= &nft_exthdr_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_exthdr)),\n\t.eval\t\t= nft_exthdr_tcp_set_eval,\n\t.init\t\t= nft_exthdr_tcp_set_init,\n\t.dump\t\t= nft_exthdr_dump_set,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic const struct nft_expr_ops nft_exthdr_tcp_strip_ops = {\n\t.type\t\t= &nft_exthdr_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_exthdr)),\n\t.eval\t\t= nft_exthdr_tcp_strip_eval,\n\t.init\t\t= nft_exthdr_tcp_strip_init,\n\t.dump\t\t= nft_exthdr_dump_strip,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic const struct nft_expr_ops nft_exthdr_sctp_ops = {\n\t.type\t\t= &nft_exthdr_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_exthdr)),\n\t.eval\t\t= nft_exthdr_sctp_eval,\n\t.init\t\t= nft_exthdr_init,\n\t.dump\t\t= nft_exthdr_dump,\n\t.reduce\t\t= nft_exthdr_reduce,\n};\n\nstatic const struct nft_expr_ops nft_exthdr_dccp_ops = {\n\t.type\t\t= &nft_exthdr_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_exthdr)),\n\t.eval\t\t= nft_exthdr_dccp_eval,\n\t.init\t\t= nft_exthdr_dccp_init,\n\t.dump\t\t= nft_exthdr_dump,\n\t.reduce\t\t= nft_exthdr_reduce,\n};\n\nstatic const struct nft_expr_ops *\nnft_exthdr_select_ops(const struct nft_ctx *ctx,\n\t\t      const struct nlattr * const tb[])\n{\n\tu32 op;\n\n\tif (!tb[NFTA_EXTHDR_OP])\n\t\treturn &nft_exthdr_ipv6_ops;\n\n\tif (tb[NFTA_EXTHDR_SREG] && tb[NFTA_EXTHDR_DREG])\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\top = ntohl(nla_get_be32(tb[NFTA_EXTHDR_OP]));\n\tswitch (op) {\n\tcase NFT_EXTHDR_OP_TCPOPT:\n\t\tif (tb[NFTA_EXTHDR_SREG])\n\t\t\treturn &nft_exthdr_tcp_set_ops;\n\t\tif (tb[NFTA_EXTHDR_DREG])\n\t\t\treturn &nft_exthdr_tcp_ops;\n\t\treturn &nft_exthdr_tcp_strip_ops;\n\tcase NFT_EXTHDR_OP_IPV6:\n\t\tif (tb[NFTA_EXTHDR_DREG])\n\t\t\treturn &nft_exthdr_ipv6_ops;\n\t\tbreak;\n\tcase NFT_EXTHDR_OP_IPV4:\n\t\tif (ctx->family != NFPROTO_IPV6) {\n\t\t\tif (tb[NFTA_EXTHDR_DREG])\n\t\t\t\treturn &nft_exthdr_ipv4_ops;\n\t\t}\n\t\tbreak;\n\tcase NFT_EXTHDR_OP_SCTP:\n\t\tif (tb[NFTA_EXTHDR_DREG])\n\t\t\treturn &nft_exthdr_sctp_ops;\n\t\tbreak;\n\tcase NFT_EXTHDR_OP_DCCP:\n\t\tif (tb[NFTA_EXTHDR_DREG])\n\t\t\treturn &nft_exthdr_dccp_ops;\n\t\tbreak;\n\t}\n\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\nstruct nft_expr_type nft_exthdr_type __read_mostly = {\n\t.name\t\t= \"exthdr\",\n\t.select_ops\t= nft_exthdr_select_ops,\n\t.policy\t\t= nft_exthdr_policy,\n\t.maxattr\t= NFTA_EXTHDR_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}