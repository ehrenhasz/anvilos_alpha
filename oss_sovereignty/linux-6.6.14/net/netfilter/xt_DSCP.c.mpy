{
  "module_name": "xt_DSCP.c",
  "hash_id": "ecc4ac194113a297e1316ea24518b1b4f0180a9224439f1c0faba2a4a8348c07",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_DSCP.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/dsfield.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_DSCP.h>\n\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: DSCP/TOS field modification\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_DSCP\");\nMODULE_ALIAS(\"ip6t_DSCP\");\nMODULE_ALIAS(\"ipt_TOS\");\nMODULE_ALIAS(\"ip6t_TOS\");\n\n#define XT_DSCP_ECN_MASK\t3u\n\nstatic unsigned int\ndscp_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_DSCP_info *dinfo = par->targinfo;\n\tu_int8_t dscp = ipv4_get_dsfield(ip_hdr(skb)) >> XT_DSCP_SHIFT;\n\n\tif (dscp != dinfo->dscp) {\n\t\tif (skb_ensure_writable(skb, sizeof(struct iphdr)))\n\t\t\treturn NF_DROP;\n\n\t\tipv4_change_dsfield(ip_hdr(skb), XT_DSCP_ECN_MASK,\n\t\t\t\t    dinfo->dscp << XT_DSCP_SHIFT);\n\n\t}\n\treturn XT_CONTINUE;\n}\n\nstatic unsigned int\ndscp_tg6(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_DSCP_info *dinfo = par->targinfo;\n\tu_int8_t dscp = ipv6_get_dsfield(ipv6_hdr(skb)) >> XT_DSCP_SHIFT;\n\n\tif (dscp != dinfo->dscp) {\n\t\tif (skb_ensure_writable(skb, sizeof(struct ipv6hdr)))\n\t\t\treturn NF_DROP;\n\n\t\tipv6_change_dsfield(ipv6_hdr(skb), XT_DSCP_ECN_MASK,\n\t\t\t\t    dinfo->dscp << XT_DSCP_SHIFT);\n\t}\n\treturn XT_CONTINUE;\n}\n\nstatic int dscp_tg_check(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_DSCP_info *info = par->targinfo;\n\n\tif (info->dscp > XT_DSCP_MAX)\n\t\treturn -EDOM;\n\treturn 0;\n}\n\nstatic unsigned int\ntos_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_tos_target_info *info = par->targinfo;\n\tstruct iphdr *iph = ip_hdr(skb);\n\tu_int8_t orig, nv;\n\n\torig = ipv4_get_dsfield(iph);\n\tnv   = (orig & ~info->tos_mask) ^ info->tos_value;\n\n\tif (orig != nv) {\n\t\tif (skb_ensure_writable(skb, sizeof(struct iphdr)))\n\t\t\treturn NF_DROP;\n\t\tiph = ip_hdr(skb);\n\t\tipv4_change_dsfield(iph, 0, nv);\n\t}\n\n\treturn XT_CONTINUE;\n}\n\nstatic unsigned int\ntos_tg6(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_tos_target_info *info = par->targinfo;\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\tu_int8_t orig, nv;\n\n\torig = ipv6_get_dsfield(iph);\n\tnv   = (orig & ~info->tos_mask) ^ info->tos_value;\n\n\tif (orig != nv) {\n\t\tif (skb_ensure_writable(skb, sizeof(struct iphdr)))\n\t\t\treturn NF_DROP;\n\t\tiph = ipv6_hdr(skb);\n\t\tipv6_change_dsfield(iph, 0, nv);\n\t}\n\n\treturn XT_CONTINUE;\n}\n\nstatic struct xt_target dscp_tg_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"DSCP\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.checkentry\t= dscp_tg_check,\n\t\t.target\t\t= dscp_tg,\n\t\t.targetsize\t= sizeof(struct xt_DSCP_info),\n\t\t.table\t\t= \"mangle\",\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"DSCP\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.checkentry\t= dscp_tg_check,\n\t\t.target\t\t= dscp_tg6,\n\t\t.targetsize\t= sizeof(struct xt_DSCP_info),\n\t\t.table\t\t= \"mangle\",\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"TOS\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.table\t\t= \"mangle\",\n\t\t.target\t\t= tos_tg,\n\t\t.targetsize\t= sizeof(struct xt_tos_target_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"TOS\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.table\t\t= \"mangle\",\n\t\t.target\t\t= tos_tg6,\n\t\t.targetsize\t= sizeof(struct xt_tos_target_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init dscp_tg_init(void)\n{\n\treturn xt_register_targets(dscp_tg_reg, ARRAY_SIZE(dscp_tg_reg));\n}\n\nstatic void __exit dscp_tg_exit(void)\n{\n\txt_unregister_targets(dscp_tg_reg, ARRAY_SIZE(dscp_tg_reg));\n}\n\nmodule_init(dscp_tg_init);\nmodule_exit(dscp_tg_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}