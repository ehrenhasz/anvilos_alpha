{
  "module_name": "nft_objref.c",
  "hash_id": "0c8d751236f44e71a775f3e9145ee94756b0d9816468f87276dc23c2137fe05e",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_objref.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n\n#define nft_objref_priv(expr)\t*((struct nft_object **)nft_expr_priv(expr))\n\nvoid nft_objref_eval(const struct nft_expr *expr,\n\t\t     struct nft_regs *regs,\n\t\t     const struct nft_pktinfo *pkt)\n{\n\tstruct nft_object *obj = nft_objref_priv(expr);\n\n\tobj->ops->eval(obj, regs, pkt);\n}\n\nstatic int nft_objref_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nft_object *obj = nft_objref_priv(expr);\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tu32 objtype;\n\n\tif (!tb[NFTA_OBJREF_IMM_NAME] ||\n\t    !tb[NFTA_OBJREF_IMM_TYPE])\n\t\treturn -EINVAL;\n\n\tobjtype = ntohl(nla_get_be32(tb[NFTA_OBJREF_IMM_TYPE]));\n\tobj = nft_obj_lookup(ctx->net, ctx->table,\n\t\t\t     tb[NFTA_OBJREF_IMM_NAME], objtype,\n\t\t\t     genmask);\n\tif (IS_ERR(obj))\n\t\treturn -ENOENT;\n\n\tif (!nft_use_inc(&obj->use))\n\t\treturn -EMFILE;\n\n\tnft_objref_priv(expr) = obj;\n\n\treturn 0;\n}\n\nstatic int nft_objref_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_object *obj = nft_objref_priv(expr);\n\n\tif (nla_put_string(skb, NFTA_OBJREF_IMM_NAME, obj->key.name) ||\n\t    nla_put_be32(skb, NFTA_OBJREF_IMM_TYPE,\n\t\t\t htonl(obj->ops->type->type)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic void nft_objref_deactivate(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nft_expr *expr,\n\t\t\t\t  enum nft_trans_phase phase)\n{\n\tstruct nft_object *obj = nft_objref_priv(expr);\n\n\tif (phase == NFT_TRANS_COMMIT)\n\t\treturn;\n\n\tnft_use_dec(&obj->use);\n}\n\nstatic void nft_objref_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_object *obj = nft_objref_priv(expr);\n\n\tnft_use_inc_restore(&obj->use);\n}\n\nstatic const struct nft_expr_ops nft_objref_ops = {\n\t.type\t\t= &nft_objref_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_object *)),\n\t.eval\t\t= nft_objref_eval,\n\t.init\t\t= nft_objref_init,\n\t.activate\t= nft_objref_activate,\n\t.deactivate\t= nft_objref_deactivate,\n\t.dump\t\t= nft_objref_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstruct nft_objref_map {\n\tstruct nft_set\t\t*set;\n\tu8\t\t\tsreg;\n\tstruct nft_set_binding\tbinding;\n};\n\nvoid nft_objref_map_eval(const struct nft_expr *expr,\n\t\t\t struct nft_regs *regs,\n\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\tconst struct nft_set *set = priv->set;\n\tstruct net *net = nft_net(pkt);\n\tconst struct nft_set_ext *ext;\n\tstruct nft_object *obj;\n\tbool found;\n\n\tfound = nft_set_do_lookup(net, set, &regs->data[priv->sreg], &ext);\n\tif (!found) {\n\t\text = nft_set_catchall_lookup(net, set);\n\t\tif (!ext) {\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\t\treturn;\n\t\t}\n\t}\n\tobj = *nft_set_ext_obj(ext);\n\tobj->ops->eval(obj, regs, pkt);\n}\n\nstatic int nft_objref_map_init(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nlattr * const tb[])\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set *set;\n\tint err;\n\n\tset = nft_set_lookup_global(ctx->net, ctx->table,\n\t\t\t\t    tb[NFTA_OBJREF_SET_NAME],\n\t\t\t\t    tb[NFTA_OBJREF_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tif (!(set->flags & NFT_SET_OBJECT))\n\t\treturn -EINVAL;\n\n\terr = nft_parse_register_load(tb[NFTA_OBJREF_SET_SREG], &priv->sreg,\n\t\t\t\t      set->klen);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->binding.flags = set->flags & NFT_SET_OBJECT;\n\n\terr = nf_tables_bind_set(ctx, set, &priv->binding);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->set = set;\n\treturn 0;\n}\n\nstatic int nft_objref_map_dump(struct sk_buff *skb,\n\t\t\t       const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_objref_map *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_OBJREF_SET_SREG, priv->sreg) ||\n\t    nla_put_string(skb, NFTA_OBJREF_SET_NAME, priv->set->name))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic void nft_objref_map_deactivate(const struct nft_ctx *ctx,\n\t\t\t\t      const struct nft_expr *expr,\n\t\t\t\t      enum nft_trans_phase phase)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\n\tnf_tables_deactivate_set(ctx, priv->set, &priv->binding, phase);\n}\n\nstatic void nft_objref_map_activate(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\n\tnf_tables_activate_set(ctx, priv->set);\n}\n\nstatic void nft_objref_map_destroy(const struct nft_ctx *ctx,\n\t\t\t\t   const struct nft_expr *expr)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\n\tnf_tables_destroy_set(ctx, priv->set);\n}\n\nstatic const struct nft_expr_ops nft_objref_map_ops = {\n\t.type\t\t= &nft_objref_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_objref_map)),\n\t.eval\t\t= nft_objref_map_eval,\n\t.init\t\t= nft_objref_map_init,\n\t.activate\t= nft_objref_map_activate,\n\t.deactivate\t= nft_objref_map_deactivate,\n\t.destroy\t= nft_objref_map_destroy,\n\t.dump\t\t= nft_objref_map_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic const struct nft_expr_ops *\nnft_objref_select_ops(const struct nft_ctx *ctx,\n                      const struct nlattr * const tb[])\n{\n\tif (tb[NFTA_OBJREF_SET_SREG] &&\n\t    (tb[NFTA_OBJREF_SET_NAME] ||\n\t     tb[NFTA_OBJREF_SET_ID]))\n\t\treturn &nft_objref_map_ops;\n\telse if (tb[NFTA_OBJREF_IMM_NAME] &&\n\t\t tb[NFTA_OBJREF_IMM_TYPE])\n\t\treturn &nft_objref_ops;\n\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\nstatic const struct nla_policy nft_objref_policy[NFTA_OBJREF_MAX + 1] = {\n\t[NFTA_OBJREF_IMM_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_OBJ_MAXNAMELEN - 1 },\n\t[NFTA_OBJREF_IMM_TYPE]\t= { .type = NLA_U32 },\n\t[NFTA_OBJREF_SET_SREG]\t= { .type = NLA_U32 },\n\t[NFTA_OBJREF_SET_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_SET_MAXNAMELEN - 1 },\n\t[NFTA_OBJREF_SET_ID]\t= { .type = NLA_U32 },\n};\n\nstruct nft_expr_type nft_objref_type __read_mostly = {\n\t.name\t\t= \"objref\",\n\t.select_ops\t= nft_objref_select_ops,\n\t.policy\t\t= nft_objref_policy,\n\t.maxattr\t= NFTA_OBJREF_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}