{
  "module_name": "nft_last.c",
  "hash_id": "7fafc31cc98212e8d8f51b7ea5612bbcdcd59f13ffd28e0ef5b130dd61d3bd95",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_last.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n\nstruct nft_last {\n\tunsigned long\tjiffies;\n\tunsigned int\tset;\n};\n\nstruct nft_last_priv {\n\tstruct nft_last\t*last;\n};\n\nstatic const struct nla_policy nft_last_policy[NFTA_LAST_MAX + 1] = {\n\t[NFTA_LAST_SET] = { .type = NLA_U32 },\n\t[NFTA_LAST_MSECS] = { .type = NLA_U64 },\n};\n\nstatic int nft_last_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t\t const struct nlattr * const tb[])\n{\n\tstruct nft_last_priv *priv = nft_expr_priv(expr);\n\tstruct nft_last *last;\n\tu64 last_jiffies;\n\tint err;\n\n\tlast = kzalloc(sizeof(*last), GFP_KERNEL_ACCOUNT);\n\tif (!last)\n\t\treturn -ENOMEM;\n\n\tif (tb[NFTA_LAST_SET])\n\t\tlast->set = ntohl(nla_get_be32(tb[NFTA_LAST_SET]));\n\n\tif (last->set && tb[NFTA_LAST_MSECS]) {\n\t\terr = nf_msecs_to_jiffies64(tb[NFTA_LAST_MSECS], &last_jiffies);\n\t\tif (err < 0)\n\t\t\tgoto err;\n\n\t\tlast->jiffies = jiffies - (unsigned long)last_jiffies;\n\t}\n\tpriv->last = last;\n\n\treturn 0;\nerr:\n\tkfree(last);\n\n\treturn err;\n}\n\nstatic void nft_last_eval(const struct nft_expr *expr,\n\t\t\t  struct nft_regs *regs, const struct nft_pktinfo *pkt)\n{\n\tstruct nft_last_priv *priv = nft_expr_priv(expr);\n\tstruct nft_last *last = priv->last;\n\n\tif (READ_ONCE(last->jiffies) != jiffies)\n\t\tWRITE_ONCE(last->jiffies, jiffies);\n\tif (READ_ONCE(last->set) == 0)\n\t\tWRITE_ONCE(last->set, 1);\n}\n\nstatic int nft_last_dump(struct sk_buff *skb,\n\t\t\t const struct nft_expr *expr, bool reset)\n{\n\tstruct nft_last_priv *priv = nft_expr_priv(expr);\n\tstruct nft_last *last = priv->last;\n\tunsigned long last_jiffies = READ_ONCE(last->jiffies);\n\tu32 last_set = READ_ONCE(last->set);\n\t__be64 msecs;\n\n\tif (time_before(jiffies, last_jiffies)) {\n\t\tWRITE_ONCE(last->set, 0);\n\t\tlast_set = 0;\n\t}\n\n\tif (last_set)\n\t\tmsecs = nf_jiffies64_to_msecs(jiffies - last_jiffies);\n\telse\n\t\tmsecs = 0;\n\n\tif (nla_put_be32(skb, NFTA_LAST_SET, htonl(last_set)) ||\n\t    nla_put_be64(skb, NFTA_LAST_MSECS, msecs, NFTA_LAST_PAD))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic void nft_last_destroy(const struct nft_ctx *ctx,\n\t\t\t     const struct nft_expr *expr)\n{\n\tstruct nft_last_priv *priv = nft_expr_priv(expr);\n\n\tkfree(priv->last);\n}\n\nstatic int nft_last_clone(struct nft_expr *dst, const struct nft_expr *src)\n{\n\tstruct nft_last_priv *priv_dst = nft_expr_priv(dst);\n\tstruct nft_last_priv *priv_src = nft_expr_priv(src);\n\n\tpriv_dst->last = kzalloc(sizeof(*priv_dst->last), GFP_ATOMIC);\n\tif (!priv_dst->last)\n\t\treturn -ENOMEM;\n\n\tpriv_dst->last->set = priv_src->last->set;\n\tpriv_dst->last->jiffies = priv_src->last->jiffies;\n\n\treturn 0;\n}\n\nstatic const struct nft_expr_ops nft_last_ops = {\n\t.type\t\t= &nft_last_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_last_priv)),\n\t.eval\t\t= nft_last_eval,\n\t.init\t\t= nft_last_init,\n\t.destroy\t= nft_last_destroy,\n\t.clone\t\t= nft_last_clone,\n\t.dump\t\t= nft_last_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstruct nft_expr_type nft_last_type __read_mostly = {\n\t.name\t\t= \"last\",\n\t.ops\t\t= &nft_last_ops,\n\t.policy\t\t= nft_last_policy,\n\t.maxattr\t= NFTA_LAST_MAX,\n\t.flags\t\t= NFT_EXPR_STATEFUL,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}