{
  "module_name": "nft_tunnel.c",
  "hash_id": "85317c73f412ffc1b32c35ba4ba6eef1115f56d674cbffb8bbfdee051f83bc44",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_tunnel.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/seqlock.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/dst_metadata.h>\n#include <net/ip_tunnels.h>\n#include <net/vxlan.h>\n#include <net/erspan.h>\n#include <net/geneve.h>\n\nstruct nft_tunnel {\n\tenum nft_tunnel_keys\tkey:8;\n\tu8\t\t\tdreg;\n\tenum nft_tunnel_mode\tmode:8;\n\tu8\t\t\tlen;\n};\n\nstatic void nft_tunnel_get_eval(const struct nft_expr *expr,\n\t\t\t\tstruct nft_regs *regs,\n\t\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_tunnel *priv = nft_expr_priv(expr);\n\tu32 *dest = &regs->data[priv->dreg];\n\tstruct ip_tunnel_info *tun_info;\n\n\ttun_info = skb_tunnel_info(pkt->skb);\n\n\tswitch (priv->key) {\n\tcase NFT_TUNNEL_PATH:\n\t\tif (!tun_info) {\n\t\t\tnft_reg_store8(dest, false);\n\t\t\treturn;\n\t\t}\n\t\tif (priv->mode == NFT_TUNNEL_MODE_NONE ||\n\t\t    (priv->mode == NFT_TUNNEL_MODE_RX &&\n\t\t     !(tun_info->mode & IP_TUNNEL_INFO_TX)) ||\n\t\t    (priv->mode == NFT_TUNNEL_MODE_TX &&\n\t\t     (tun_info->mode & IP_TUNNEL_INFO_TX)))\n\t\t\tnft_reg_store8(dest, true);\n\t\telse\n\t\t\tnft_reg_store8(dest, false);\n\t\tbreak;\n\tcase NFT_TUNNEL_ID:\n\t\tif (!tun_info) {\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\t\treturn;\n\t\t}\n\t\tif (priv->mode == NFT_TUNNEL_MODE_NONE ||\n\t\t    (priv->mode == NFT_TUNNEL_MODE_RX &&\n\t\t     !(tun_info->mode & IP_TUNNEL_INFO_TX)) ||\n\t\t    (priv->mode == NFT_TUNNEL_MODE_TX &&\n\t\t     (tun_info->mode & IP_TUNNEL_INFO_TX)))\n\t\t\t*dest = ntohl(tunnel_id_to_key32(tun_info->key.tun_id));\n\t\telse\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tregs->verdict.code = NFT_BREAK;\n\t}\n}\n\nstatic const struct nla_policy nft_tunnel_policy[NFTA_TUNNEL_MAX + 1] = {\n\t[NFTA_TUNNEL_KEY]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_TUNNEL_DREG]\t= { .type = NLA_U32 },\n\t[NFTA_TUNNEL_MODE]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n};\n\nstatic int nft_tunnel_get_init(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nlattr * const tb[])\n{\n\tstruct nft_tunnel *priv = nft_expr_priv(expr);\n\tu32 len;\n\n\tif (!tb[NFTA_TUNNEL_KEY] ||\n\t    !tb[NFTA_TUNNEL_DREG])\n\t\treturn -EINVAL;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_TUNNEL_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_TUNNEL_PATH:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tcase NFT_TUNNEL_ID:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[NFTA_TUNNEL_MODE]) {\n\t\tpriv->mode = ntohl(nla_get_be32(tb[NFTA_TUNNEL_MODE]));\n\t\tif (priv->mode > NFT_TUNNEL_MODE_MAX)\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tpriv->mode = NFT_TUNNEL_MODE_NONE;\n\t}\n\n\tpriv->len = len;\n\treturn nft_parse_register_store(ctx, tb[NFTA_TUNNEL_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\n\nstatic int nft_tunnel_get_dump(struct sk_buff *skb,\n\t\t\t       const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_tunnel *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_TUNNEL_KEY, htonl(priv->key)))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_TUNNEL_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_TUNNEL_MODE, htonl(priv->mode)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic bool nft_tunnel_get_reduce(struct nft_regs_track *track,\n\t\t\t\t  const struct nft_expr *expr)\n{\n\tconst struct nft_tunnel *priv = nft_expr_priv(expr);\n\tconst struct nft_tunnel *tunnel;\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\ttunnel = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->key != tunnel->key ||\n\t    priv->dreg != tunnel->dreg ||\n\t    priv->mode != tunnel->mode) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct nft_expr_type nft_tunnel_type;\nstatic const struct nft_expr_ops nft_tunnel_get_ops = {\n\t.type\t\t= &nft_tunnel_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_tunnel)),\n\t.eval\t\t= nft_tunnel_get_eval,\n\t.init\t\t= nft_tunnel_get_init,\n\t.dump\t\t= nft_tunnel_get_dump,\n\t.reduce\t\t= nft_tunnel_get_reduce,\n};\n\nstatic struct nft_expr_type nft_tunnel_type __read_mostly = {\n\t.name\t\t= \"tunnel\",\n\t.family\t\t= NFPROTO_NETDEV,\n\t.ops\t\t= &nft_tunnel_get_ops,\n\t.policy\t\t= nft_tunnel_policy,\n\t.maxattr\t= NFTA_TUNNEL_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstruct nft_tunnel_opts {\n\tunion {\n\t\tstruct vxlan_metadata\tvxlan;\n\t\tstruct erspan_metadata\terspan;\n\t\tu8\tdata[IP_TUNNEL_OPTS_MAX];\n\t} u;\n\tu32\tlen;\n\t__be16\tflags;\n};\n\nstruct nft_tunnel_obj {\n\tstruct metadata_dst\t*md;\n\tstruct nft_tunnel_opts\topts;\n};\n\nstatic const struct nla_policy nft_tunnel_ip_policy[NFTA_TUNNEL_KEY_IP_MAX + 1] = {\n\t[NFTA_TUNNEL_KEY_IP_SRC]\t= { .type = NLA_U32 },\n\t[NFTA_TUNNEL_KEY_IP_DST]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_tunnel_obj_ip_init(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nlattr *attr,\n\t\t\t\t  struct ip_tunnel_info *info)\n{\n\tstruct nlattr *tb[NFTA_TUNNEL_KEY_IP_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_TUNNEL_KEY_IP_MAX, attr,\n\t\t\t\t\t  nft_tunnel_ip_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_TUNNEL_KEY_IP_DST])\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_TUNNEL_KEY_IP_SRC])\n\t\tinfo->key.u.ipv4.src = nla_get_be32(tb[NFTA_TUNNEL_KEY_IP_SRC]);\n\tif (tb[NFTA_TUNNEL_KEY_IP_DST])\n\t\tinfo->key.u.ipv4.dst = nla_get_be32(tb[NFTA_TUNNEL_KEY_IP_DST]);\n\n\treturn 0;\n}\n\nstatic const struct nla_policy nft_tunnel_ip6_policy[NFTA_TUNNEL_KEY_IP6_MAX + 1] = {\n\t[NFTA_TUNNEL_KEY_IP6_SRC]\t= { .len = sizeof(struct in6_addr), },\n\t[NFTA_TUNNEL_KEY_IP6_DST]\t= { .len = sizeof(struct in6_addr), },\n\t[NFTA_TUNNEL_KEY_IP6_FLOWLABEL]\t= { .type = NLA_U32, }\n};\n\nstatic int nft_tunnel_obj_ip6_init(const struct nft_ctx *ctx,\n\t\t\t\t   const struct nlattr *attr,\n\t\t\t\t   struct ip_tunnel_info *info)\n{\n\tstruct nlattr *tb[NFTA_TUNNEL_KEY_IP6_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_TUNNEL_KEY_IP6_MAX, attr,\n\t\t\t\t\t  nft_tunnel_ip6_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_TUNNEL_KEY_IP6_DST])\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_TUNNEL_KEY_IP6_SRC]) {\n\t\tmemcpy(&info->key.u.ipv6.src,\n\t\t       nla_data(tb[NFTA_TUNNEL_KEY_IP6_SRC]),\n\t\t       sizeof(struct in6_addr));\n\t}\n\tif (tb[NFTA_TUNNEL_KEY_IP6_DST]) {\n\t\tmemcpy(&info->key.u.ipv6.dst,\n\t\t       nla_data(tb[NFTA_TUNNEL_KEY_IP6_DST]),\n\t\t       sizeof(struct in6_addr));\n\t}\n\tif (tb[NFTA_TUNNEL_KEY_IP6_FLOWLABEL])\n\t\tinfo->key.label = nla_get_be32(tb[NFTA_TUNNEL_KEY_IP6_FLOWLABEL]);\n\n\tinfo->mode |= IP_TUNNEL_INFO_IPV6;\n\n\treturn 0;\n}\n\nstatic const struct nla_policy nft_tunnel_opts_vxlan_policy[NFTA_TUNNEL_KEY_VXLAN_MAX + 1] = {\n\t[NFTA_TUNNEL_KEY_VXLAN_GBP]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_tunnel_obj_vxlan_init(const struct nlattr *attr,\n\t\t\t\t     struct nft_tunnel_opts *opts)\n{\n\tstruct nlattr *tb[NFTA_TUNNEL_KEY_VXLAN_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_TUNNEL_KEY_VXLAN_MAX, attr,\n\t\t\t\t\t  nft_tunnel_opts_vxlan_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_TUNNEL_KEY_VXLAN_GBP])\n\t\treturn -EINVAL;\n\n\topts->u.vxlan.gbp = ntohl(nla_get_be32(tb[NFTA_TUNNEL_KEY_VXLAN_GBP]));\n\n\topts->len\t= sizeof(struct vxlan_metadata);\n\topts->flags\t= TUNNEL_VXLAN_OPT;\n\n\treturn 0;\n}\n\nstatic const struct nla_policy nft_tunnel_opts_erspan_policy[NFTA_TUNNEL_KEY_ERSPAN_MAX + 1] = {\n\t[NFTA_TUNNEL_KEY_ERSPAN_VERSION]\t= { .type = NLA_U32 },\n\t[NFTA_TUNNEL_KEY_ERSPAN_V1_INDEX]\t= { .type = NLA_U32 },\n\t[NFTA_TUNNEL_KEY_ERSPAN_V2_DIR]\t\t= { .type = NLA_U8 },\n\t[NFTA_TUNNEL_KEY_ERSPAN_V2_HWID]\t= { .type = NLA_U8 },\n};\n\nstatic int nft_tunnel_obj_erspan_init(const struct nlattr *attr,\n\t\t\t\t      struct nft_tunnel_opts *opts)\n{\n\tstruct nlattr *tb[NFTA_TUNNEL_KEY_ERSPAN_MAX + 1];\n\tuint8_t hwid, dir;\n\tint err, version;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_TUNNEL_KEY_ERSPAN_MAX,\n\t\t\t\t\t  attr, nft_tunnel_opts_erspan_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_TUNNEL_KEY_ERSPAN_VERSION])\n\t\t return -EINVAL;\n\n\tversion = ntohl(nla_get_be32(tb[NFTA_TUNNEL_KEY_ERSPAN_VERSION]));\n\tswitch (version) {\n\tcase ERSPAN_VERSION:\n\t\tif (!tb[NFTA_TUNNEL_KEY_ERSPAN_V1_INDEX])\n\t\t\treturn -EINVAL;\n\n\t\topts->u.erspan.u.index =\n\t\t\tnla_get_be32(tb[NFTA_TUNNEL_KEY_ERSPAN_V1_INDEX]);\n\t\tbreak;\n\tcase ERSPAN_VERSION2:\n\t\tif (!tb[NFTA_TUNNEL_KEY_ERSPAN_V2_DIR] ||\n\t\t    !tb[NFTA_TUNNEL_KEY_ERSPAN_V2_HWID])\n\t\t\treturn -EINVAL;\n\n\t\thwid = nla_get_u8(tb[NFTA_TUNNEL_KEY_ERSPAN_V2_HWID]);\n\t\tdir = nla_get_u8(tb[NFTA_TUNNEL_KEY_ERSPAN_V2_DIR]);\n\n\t\tset_hwid(&opts->u.erspan.u.md2, hwid);\n\t\topts->u.erspan.u.md2.dir = dir;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\topts->u.erspan.version = version;\n\n\topts->len\t= sizeof(struct erspan_metadata);\n\topts->flags\t= TUNNEL_ERSPAN_OPT;\n\n\treturn 0;\n}\n\nstatic const struct nla_policy nft_tunnel_opts_geneve_policy[NFTA_TUNNEL_KEY_GENEVE_MAX + 1] = {\n\t[NFTA_TUNNEL_KEY_GENEVE_CLASS]\t= { .type = NLA_U16 },\n\t[NFTA_TUNNEL_KEY_GENEVE_TYPE]\t= { .type = NLA_U8 },\n\t[NFTA_TUNNEL_KEY_GENEVE_DATA]\t= { .type = NLA_BINARY, .len = 128 },\n};\n\nstatic int nft_tunnel_obj_geneve_init(const struct nlattr *attr,\n\t\t\t\t      struct nft_tunnel_opts *opts)\n{\n\tstruct geneve_opt *opt = (struct geneve_opt *)opts->u.data + opts->len;\n\tstruct nlattr *tb[NFTA_TUNNEL_KEY_GENEVE_MAX + 1];\n\tint err, data_len;\n\n\terr = nla_parse_nested(tb, NFTA_TUNNEL_KEY_GENEVE_MAX, attr,\n\t\t\t       nft_tunnel_opts_geneve_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_TUNNEL_KEY_GENEVE_CLASS] ||\n\t    !tb[NFTA_TUNNEL_KEY_GENEVE_TYPE] ||\n\t    !tb[NFTA_TUNNEL_KEY_GENEVE_DATA])\n\t\treturn -EINVAL;\n\n\tattr = tb[NFTA_TUNNEL_KEY_GENEVE_DATA];\n\tdata_len = nla_len(attr);\n\tif (data_len % 4)\n\t\treturn -EINVAL;\n\n\topts->len += sizeof(*opt) + data_len;\n\tif (opts->len > IP_TUNNEL_OPTS_MAX)\n\t\treturn -EINVAL;\n\n\tmemcpy(opt->opt_data, nla_data(attr), data_len);\n\topt->length = data_len / 4;\n\topt->opt_class = nla_get_be16(tb[NFTA_TUNNEL_KEY_GENEVE_CLASS]);\n\topt->type = nla_get_u8(tb[NFTA_TUNNEL_KEY_GENEVE_TYPE]);\n\topts->flags = TUNNEL_GENEVE_OPT;\n\n\treturn 0;\n}\n\nstatic const struct nla_policy nft_tunnel_opts_policy[NFTA_TUNNEL_KEY_OPTS_MAX + 1] = {\n\t[NFTA_TUNNEL_KEY_OPTS_UNSPEC]\t= {\n\t\t.strict_start_type = NFTA_TUNNEL_KEY_OPTS_GENEVE },\n\t[NFTA_TUNNEL_KEY_OPTS_VXLAN]\t= { .type = NLA_NESTED, },\n\t[NFTA_TUNNEL_KEY_OPTS_ERSPAN]\t= { .type = NLA_NESTED, },\n\t[NFTA_TUNNEL_KEY_OPTS_GENEVE]\t= { .type = NLA_NESTED, },\n};\n\nstatic int nft_tunnel_obj_opts_init(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nlattr *attr,\n\t\t\t\t    struct ip_tunnel_info *info,\n\t\t\t\t    struct nft_tunnel_opts *opts)\n{\n\tstruct nlattr *nla;\n\t__be16 type = 0;\n\tint err, rem;\n\n\terr = nla_validate_nested_deprecated(attr, NFTA_TUNNEL_KEY_OPTS_MAX,\n\t\t\t\t\t     nft_tunnel_opts_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tnla_for_each_attr(nla, nla_data(attr), nla_len(attr), rem) {\n\t\tswitch (nla_type(nla)) {\n\t\tcase NFTA_TUNNEL_KEY_OPTS_VXLAN:\n\t\t\tif (type)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = nft_tunnel_obj_vxlan_init(nla, opts);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\ttype = TUNNEL_VXLAN_OPT;\n\t\t\tbreak;\n\t\tcase NFTA_TUNNEL_KEY_OPTS_ERSPAN:\n\t\t\tif (type)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = nft_tunnel_obj_erspan_init(nla, opts);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\ttype = TUNNEL_ERSPAN_OPT;\n\t\t\tbreak;\n\t\tcase NFTA_TUNNEL_KEY_OPTS_GENEVE:\n\t\t\tif (type && type != TUNNEL_GENEVE_OPT)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = nft_tunnel_obj_geneve_init(nla, opts);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\ttype = TUNNEL_GENEVE_OPT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic const struct nla_policy nft_tunnel_key_policy[NFTA_TUNNEL_KEY_MAX + 1] = {\n\t[NFTA_TUNNEL_KEY_IP]\t= { .type = NLA_NESTED, },\n\t[NFTA_TUNNEL_KEY_IP6]\t= { .type = NLA_NESTED, },\n\t[NFTA_TUNNEL_KEY_ID]\t= { .type = NLA_U32, },\n\t[NFTA_TUNNEL_KEY_FLAGS]\t= { .type = NLA_U32, },\n\t[NFTA_TUNNEL_KEY_TOS]\t= { .type = NLA_U8, },\n\t[NFTA_TUNNEL_KEY_TTL]\t= { .type = NLA_U8, },\n\t[NFTA_TUNNEL_KEY_SPORT]\t= { .type = NLA_U16, },\n\t[NFTA_TUNNEL_KEY_DPORT]\t= { .type = NLA_U16, },\n\t[NFTA_TUNNEL_KEY_OPTS]\t= { .type = NLA_NESTED, },\n};\n\nstatic int nft_tunnel_obj_init(const struct nft_ctx *ctx,\n\t\t\t       const struct nlattr * const tb[],\n\t\t\t       struct nft_object *obj)\n{\n\tstruct nft_tunnel_obj *priv = nft_obj_data(obj);\n\tstruct ip_tunnel_info info;\n\tstruct metadata_dst *md;\n\tint err;\n\n\tif (!tb[NFTA_TUNNEL_KEY_ID])\n\t\treturn -EINVAL;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.mode\t\t= IP_TUNNEL_INFO_TX;\n\tinfo.key.tun_id\t\t= key32_to_tunnel_id(nla_get_be32(tb[NFTA_TUNNEL_KEY_ID]));\n\tinfo.key.tun_flags\t= TUNNEL_KEY | TUNNEL_CSUM | TUNNEL_NOCACHE;\n\n\tif (tb[NFTA_TUNNEL_KEY_IP]) {\n\t\terr = nft_tunnel_obj_ip_init(ctx, tb[NFTA_TUNNEL_KEY_IP], &info);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (tb[NFTA_TUNNEL_KEY_IP6]) {\n\t\terr = nft_tunnel_obj_ip6_init(ctx, tb[NFTA_TUNNEL_KEY_IP6], &info);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NFTA_TUNNEL_KEY_SPORT]) {\n\t\tinfo.key.tp_src = nla_get_be16(tb[NFTA_TUNNEL_KEY_SPORT]);\n\t}\n\tif (tb[NFTA_TUNNEL_KEY_DPORT]) {\n\t\tinfo.key.tp_dst = nla_get_be16(tb[NFTA_TUNNEL_KEY_DPORT]);\n\t}\n\n\tif (tb[NFTA_TUNNEL_KEY_FLAGS]) {\n\t\tu32 tun_flags;\n\n\t\ttun_flags = ntohl(nla_get_be32(tb[NFTA_TUNNEL_KEY_FLAGS]));\n\t\tif (tun_flags & ~NFT_TUNNEL_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (tun_flags & NFT_TUNNEL_F_ZERO_CSUM_TX)\n\t\t\tinfo.key.tun_flags &= ~TUNNEL_CSUM;\n\t\tif (tun_flags & NFT_TUNNEL_F_DONT_FRAGMENT)\n\t\t\tinfo.key.tun_flags |= TUNNEL_DONT_FRAGMENT;\n\t\tif (tun_flags & NFT_TUNNEL_F_SEQ_NUMBER)\n\t\t\tinfo.key.tun_flags |= TUNNEL_SEQ;\n\t}\n\tif (tb[NFTA_TUNNEL_KEY_TOS])\n\t\tinfo.key.tos = nla_get_u8(tb[NFTA_TUNNEL_KEY_TOS]);\n\tif (tb[NFTA_TUNNEL_KEY_TTL])\n\t\tinfo.key.ttl = nla_get_u8(tb[NFTA_TUNNEL_KEY_TTL]);\n\telse\n\t\tinfo.key.ttl = U8_MAX;\n\n\tif (tb[NFTA_TUNNEL_KEY_OPTS]) {\n\t\terr = nft_tunnel_obj_opts_init(ctx, tb[NFTA_TUNNEL_KEY_OPTS],\n\t\t\t\t\t       &info, &priv->opts);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tmd = metadata_dst_alloc(priv->opts.len, METADATA_IP_TUNNEL, GFP_KERNEL);\n\tif (!md)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&md->u.tun_info, &info, sizeof(info));\n#ifdef CONFIG_DST_CACHE\n\terr = dst_cache_init(&md->u.tun_info.dst_cache, GFP_KERNEL);\n\tif (err < 0) {\n\t\tmetadata_dst_free(md);\n\t\treturn err;\n\t}\n#endif\n\tip_tunnel_info_opts_set(&md->u.tun_info, &priv->opts.u, priv->opts.len,\n\t\t\t\tpriv->opts.flags);\n\tpriv->md = md;\n\n\treturn 0;\n}\n\nstatic inline void nft_tunnel_obj_eval(struct nft_object *obj,\n\t\t\t\t       struct nft_regs *regs,\n\t\t\t\t       const struct nft_pktinfo *pkt)\n{\n\tstruct nft_tunnel_obj *priv = nft_obj_data(obj);\n\tstruct sk_buff *skb = pkt->skb;\n\n\tskb_dst_drop(skb);\n\tdst_hold((struct dst_entry *) priv->md);\n\tskb_dst_set(skb, (struct dst_entry *) priv->md);\n}\n\nstatic int nft_tunnel_ip_dump(struct sk_buff *skb, struct ip_tunnel_info *info)\n{\n\tstruct nlattr *nest;\n\n\tif (info->mode & IP_TUNNEL_INFO_IPV6) {\n\t\tnest = nla_nest_start_noflag(skb, NFTA_TUNNEL_KEY_IP6);\n\t\tif (!nest)\n\t\t\treturn -1;\n\n\t\tif (nla_put_in6_addr(skb, NFTA_TUNNEL_KEY_IP6_SRC,\n\t\t\t\t     &info->key.u.ipv6.src) < 0 ||\n\t\t    nla_put_in6_addr(skb, NFTA_TUNNEL_KEY_IP6_DST,\n\t\t\t\t     &info->key.u.ipv6.dst) < 0 ||\n\t\t    nla_put_be32(skb, NFTA_TUNNEL_KEY_IP6_FLOWLABEL,\n\t\t\t\t info->key.label)) {\n\t\t\tnla_nest_cancel(skb, nest);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnla_nest_end(skb, nest);\n\t} else {\n\t\tnest = nla_nest_start_noflag(skb, NFTA_TUNNEL_KEY_IP);\n\t\tif (!nest)\n\t\t\treturn -1;\n\n\t\tif (nla_put_in_addr(skb, NFTA_TUNNEL_KEY_IP_SRC,\n\t\t\t\t    info->key.u.ipv4.src) < 0 ||\n\t\t    nla_put_in_addr(skb, NFTA_TUNNEL_KEY_IP_DST,\n\t\t\t\t    info->key.u.ipv4.dst) < 0) {\n\t\t\tnla_nest_cancel(skb, nest);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_tunnel_opts_dump(struct sk_buff *skb,\n\t\t\t\tstruct nft_tunnel_obj *priv)\n{\n\tstruct nft_tunnel_opts *opts = &priv->opts;\n\tstruct nlattr *nest, *inner;\n\n\tnest = nla_nest_start_noflag(skb, NFTA_TUNNEL_KEY_OPTS);\n\tif (!nest)\n\t\treturn -1;\n\n\tif (opts->flags & TUNNEL_VXLAN_OPT) {\n\t\tinner = nla_nest_start_noflag(skb, NFTA_TUNNEL_KEY_OPTS_VXLAN);\n\t\tif (!inner)\n\t\t\tgoto failure;\n\t\tif (nla_put_be32(skb, NFTA_TUNNEL_KEY_VXLAN_GBP,\n\t\t\t\t htonl(opts->u.vxlan.gbp)))\n\t\t\tgoto inner_failure;\n\t\tnla_nest_end(skb, inner);\n\t} else if (opts->flags & TUNNEL_ERSPAN_OPT) {\n\t\tinner = nla_nest_start_noflag(skb, NFTA_TUNNEL_KEY_OPTS_ERSPAN);\n\t\tif (!inner)\n\t\t\tgoto failure;\n\t\tif (nla_put_be32(skb, NFTA_TUNNEL_KEY_ERSPAN_VERSION,\n\t\t\t\t htonl(opts->u.erspan.version)))\n\t\t\tgoto inner_failure;\n\t\tswitch (opts->u.erspan.version) {\n\t\tcase ERSPAN_VERSION:\n\t\t\tif (nla_put_be32(skb, NFTA_TUNNEL_KEY_ERSPAN_V1_INDEX,\n\t\t\t\t\t opts->u.erspan.u.index))\n\t\t\t\tgoto inner_failure;\n\t\t\tbreak;\n\t\tcase ERSPAN_VERSION2:\n\t\t\tif (nla_put_u8(skb, NFTA_TUNNEL_KEY_ERSPAN_V2_HWID,\n\t\t\t\t       get_hwid(&opts->u.erspan.u.md2)) ||\n\t\t\t    nla_put_u8(skb, NFTA_TUNNEL_KEY_ERSPAN_V2_DIR,\n\t\t\t\t       opts->u.erspan.u.md2.dir))\n\t\t\t\tgoto inner_failure;\n\t\t\tbreak;\n\t\t}\n\t\tnla_nest_end(skb, inner);\n\t} else if (opts->flags & TUNNEL_GENEVE_OPT) {\n\t\tstruct geneve_opt *opt;\n\t\tint offset = 0;\n\n\t\tinner = nla_nest_start_noflag(skb, NFTA_TUNNEL_KEY_OPTS_GENEVE);\n\t\tif (!inner)\n\t\t\tgoto failure;\n\t\twhile (opts->len > offset) {\n\t\t\topt = (struct geneve_opt *)opts->u.data + offset;\n\t\t\tif (nla_put_be16(skb, NFTA_TUNNEL_KEY_GENEVE_CLASS,\n\t\t\t\t\t opt->opt_class) ||\n\t\t\t    nla_put_u8(skb, NFTA_TUNNEL_KEY_GENEVE_TYPE,\n\t\t\t\t       opt->type) ||\n\t\t\t    nla_put(skb, NFTA_TUNNEL_KEY_GENEVE_DATA,\n\t\t\t\t    opt->length * 4, opt->opt_data))\n\t\t\t\tgoto inner_failure;\n\t\t\toffset += sizeof(*opt) + opt->length * 4;\n\t\t}\n\t\tnla_nest_end(skb, inner);\n\t}\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\ninner_failure:\n\tnla_nest_cancel(skb, inner);\nfailure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}\n\nstatic int nft_tunnel_ports_dump(struct sk_buff *skb,\n\t\t\t\t struct ip_tunnel_info *info)\n{\n\tif (nla_put_be16(skb, NFTA_TUNNEL_KEY_SPORT, info->key.tp_src) < 0 ||\n\t    nla_put_be16(skb, NFTA_TUNNEL_KEY_DPORT, info->key.tp_dst) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int nft_tunnel_flags_dump(struct sk_buff *skb,\n\t\t\t\t struct ip_tunnel_info *info)\n{\n\tu32 flags = 0;\n\n\tif (info->key.tun_flags & TUNNEL_DONT_FRAGMENT)\n\t\tflags |= NFT_TUNNEL_F_DONT_FRAGMENT;\n\tif (!(info->key.tun_flags & TUNNEL_CSUM))\n\t\tflags |= NFT_TUNNEL_F_ZERO_CSUM_TX;\n\tif (info->key.tun_flags & TUNNEL_SEQ)\n\t\tflags |= NFT_TUNNEL_F_SEQ_NUMBER;\n\n\tif (nla_put_be32(skb, NFTA_TUNNEL_KEY_FLAGS, htonl(flags)) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int nft_tunnel_obj_dump(struct sk_buff *skb,\n\t\t\t       struct nft_object *obj, bool reset)\n{\n\tstruct nft_tunnel_obj *priv = nft_obj_data(obj);\n\tstruct ip_tunnel_info *info = &priv->md->u.tun_info;\n\n\tif (nla_put_be32(skb, NFTA_TUNNEL_KEY_ID,\n\t\t\t tunnel_id_to_key32(info->key.tun_id)) ||\n\t    nft_tunnel_ip_dump(skb, info) < 0 ||\n\t    nft_tunnel_ports_dump(skb, info) < 0 ||\n\t    nft_tunnel_flags_dump(skb, info) < 0 ||\n\t    nla_put_u8(skb, NFTA_TUNNEL_KEY_TOS, info->key.tos) ||\n\t    nla_put_u8(skb, NFTA_TUNNEL_KEY_TTL, info->key.ttl) ||\n\t    nft_tunnel_opts_dump(skb, priv) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic void nft_tunnel_obj_destroy(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_object *obj)\n{\n\tstruct nft_tunnel_obj *priv = nft_obj_data(obj);\n\n\tmetadata_dst_free(priv->md);\n}\n\nstatic struct nft_object_type nft_tunnel_obj_type;\nstatic const struct nft_object_ops nft_tunnel_obj_ops = {\n\t.type\t\t= &nft_tunnel_obj_type,\n\t.size\t\t= sizeof(struct nft_tunnel_obj),\n\t.eval\t\t= nft_tunnel_obj_eval,\n\t.init\t\t= nft_tunnel_obj_init,\n\t.destroy\t= nft_tunnel_obj_destroy,\n\t.dump\t\t= nft_tunnel_obj_dump,\n};\n\nstatic struct nft_object_type nft_tunnel_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_TUNNEL,\n\t.ops\t\t= &nft_tunnel_obj_ops,\n\t.maxattr\t= NFTA_TUNNEL_KEY_MAX,\n\t.policy\t\t= nft_tunnel_key_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_tunnel_module_init(void)\n{\n\tint err;\n\n\terr = nft_register_expr(&nft_tunnel_type);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_register_obj(&nft_tunnel_obj_type);\n\tif (err < 0)\n\t\tnft_unregister_expr(&nft_tunnel_type);\n\n\treturn err;\n}\n\nstatic void __exit nft_tunnel_module_exit(void)\n{\n\tnft_unregister_obj(&nft_tunnel_obj_type);\n\tnft_unregister_expr(&nft_tunnel_type);\n}\n\nmodule_init(nft_tunnel_module_init);\nmodule_exit(nft_tunnel_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_ALIAS_NFT_EXPR(\"tunnel\");\nMODULE_ALIAS_NFT_OBJ(NFT_OBJECT_TUNNEL);\nMODULE_DESCRIPTION(\"nftables tunnel expression support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}