{
  "module_name": "xt_ecn.c",
  "hash_id": "758f3fa5b6a3a36a0db1df1271c865806ccaf36c0527acb00e11b9f4fda37cd6",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_ecn.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <net/ip.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_ecn.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: Explicit Congestion Notification (ECN) flag match\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_ecn\");\nMODULE_ALIAS(\"ip6t_ecn\");\n\nstatic bool match_tcp(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_ecn_info *einfo = par->matchinfo;\n\tstruct tcphdr _tcph;\n\tconst struct tcphdr *th;\n\n\t \n\tth = skb_header_pointer(skb, par->thoff, sizeof(_tcph), &_tcph);\n\tif (th == NULL)\n\t\treturn false;\n\n\tif (einfo->operation & XT_ECN_OP_MATCH_ECE) {\n\t\tif (einfo->invert & XT_ECN_OP_MATCH_ECE) {\n\t\t\tif (th->ece == 1)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (th->ece == 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (einfo->operation & XT_ECN_OP_MATCH_CWR) {\n\t\tif (einfo->invert & XT_ECN_OP_MATCH_CWR) {\n\t\t\tif (th->cwr == 1)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (th->cwr == 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic inline bool match_ip(const struct sk_buff *skb,\n\t\t\t    const struct xt_ecn_info *einfo)\n{\n\treturn ((ip_hdr(skb)->tos & XT_ECN_IP_MASK) == einfo->ip_ect) ^\n\t       !!(einfo->invert & XT_ECN_OP_MATCH_IP);\n}\n\nstatic bool ecn_mt4(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_ecn_info *info = par->matchinfo;\n\n\tif (info->operation & XT_ECN_OP_MATCH_IP && !match_ip(skb, info))\n\t\treturn false;\n\n\tif (info->operation & (XT_ECN_OP_MATCH_ECE | XT_ECN_OP_MATCH_CWR) &&\n\t    !match_tcp(skb, par))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int ecn_mt_check4(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_ecn_info *info = par->matchinfo;\n\tconst struct ipt_ip *ip = par->entryinfo;\n\n\tif (info->operation & XT_ECN_OP_MATCH_MASK)\n\t\treturn -EINVAL;\n\n\tif (info->invert & XT_ECN_OP_MATCH_MASK)\n\t\treturn -EINVAL;\n\n\tif (info->operation & (XT_ECN_OP_MATCH_ECE | XT_ECN_OP_MATCH_CWR) &&\n\t    (ip->proto != IPPROTO_TCP || ip->invflags & IPT_INV_PROTO)) {\n\t\tpr_info_ratelimited(\"cannot match TCP bits for non-tcp packets\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool match_ipv6(const struct sk_buff *skb,\n\t\t\t      const struct xt_ecn_info *einfo)\n{\n\treturn (((ipv6_hdr(skb)->flow_lbl[0] >> 4) & XT_ECN_IP_MASK) ==\n\t        einfo->ip_ect) ^\n\t       !!(einfo->invert & XT_ECN_OP_MATCH_IP);\n}\n\nstatic bool ecn_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_ecn_info *info = par->matchinfo;\n\n\tif (info->operation & XT_ECN_OP_MATCH_IP && !match_ipv6(skb, info))\n\t\treturn false;\n\n\tif (info->operation & (XT_ECN_OP_MATCH_ECE | XT_ECN_OP_MATCH_CWR) &&\n\t    !match_tcp(skb, par))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int ecn_mt_check6(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_ecn_info *info = par->matchinfo;\n\tconst struct ip6t_ip6 *ip = par->entryinfo;\n\n\tif (info->operation & XT_ECN_OP_MATCH_MASK)\n\t\treturn -EINVAL;\n\n\tif (info->invert & XT_ECN_OP_MATCH_MASK)\n\t\treturn -EINVAL;\n\n\tif (info->operation & (XT_ECN_OP_MATCH_ECE | XT_ECN_OP_MATCH_CWR) &&\n\t    (ip->proto != IPPROTO_TCP || ip->invflags & IP6T_INV_PROTO)) {\n\t\tpr_info_ratelimited(\"cannot match TCP bits for non-tcp packets\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_match ecn_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"ecn\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.match\t\t= ecn_mt4,\n\t\t.matchsize\t= sizeof(struct xt_ecn_info),\n\t\t.checkentry\t= ecn_mt_check4,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"ecn\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.match\t\t= ecn_mt6,\n\t\t.matchsize\t= sizeof(struct xt_ecn_info),\n\t\t.checkentry\t= ecn_mt_check6,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init ecn_mt_init(void)\n{\n\treturn xt_register_matches(ecn_mt_reg, ARRAY_SIZE(ecn_mt_reg));\n}\n\nstatic void __exit ecn_mt_exit(void)\n{\n\txt_unregister_matches(ecn_mt_reg, ARRAY_SIZE(ecn_mt_reg));\n}\n\nmodule_init(ecn_mt_init);\nmodule_exit(ecn_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}