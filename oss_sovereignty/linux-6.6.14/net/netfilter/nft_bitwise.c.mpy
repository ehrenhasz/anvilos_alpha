{
  "module_name": "nft_bitwise.c",
  "hash_id": "b1e41c7c8165d11834bbe6aff3f0b7c030d2e74c86ccc0151401a822ca13e421",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_bitwise.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_offload.h>\n\nstruct nft_bitwise {\n\tu8\t\t\tsreg;\n\tu8\t\t\tdreg;\n\tenum nft_bitwise_ops\top:8;\n\tu8\t\t\tlen;\n\tstruct nft_data\t\tmask;\n\tstruct nft_data\t\txor;\n\tstruct nft_data\t\tdata;\n};\n\nstatic void nft_bitwise_eval_bool(u32 *dst, const u32 *src,\n\t\t\t\t  const struct nft_bitwise *priv)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < DIV_ROUND_UP(priv->len, sizeof(u32)); i++)\n\t\tdst[i] = (src[i] & priv->mask.data[i]) ^ priv->xor.data[i];\n}\n\nstatic void nft_bitwise_eval_lshift(u32 *dst, const u32 *src,\n\t\t\t\t    const struct nft_bitwise *priv)\n{\n\tu32 shift = priv->data.data[0];\n\tunsigned int i;\n\tu32 carry = 0;\n\n\tfor (i = DIV_ROUND_UP(priv->len, sizeof(u32)); i > 0; i--) {\n\t\tdst[i - 1] = (src[i - 1] << shift) | carry;\n\t\tcarry = src[i - 1] >> (BITS_PER_TYPE(u32) - shift);\n\t}\n}\n\nstatic void nft_bitwise_eval_rshift(u32 *dst, const u32 *src,\n\t\t\t\t    const struct nft_bitwise *priv)\n{\n\tu32 shift = priv->data.data[0];\n\tunsigned int i;\n\tu32 carry = 0;\n\n\tfor (i = 0; i < DIV_ROUND_UP(priv->len, sizeof(u32)); i++) {\n\t\tdst[i] = carry | (src[i] >> shift);\n\t\tcarry = src[i] << (BITS_PER_TYPE(u32) - shift);\n\t}\n}\n\nvoid nft_bitwise_eval(const struct nft_expr *expr,\n\t\t      struct nft_regs *regs, const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_bitwise *priv = nft_expr_priv(expr);\n\tconst u32 *src = &regs->data[priv->sreg];\n\tu32 *dst = &regs->data[priv->dreg];\n\n\tswitch (priv->op) {\n\tcase NFT_BITWISE_BOOL:\n\t\tnft_bitwise_eval_bool(dst, src, priv);\n\t\tbreak;\n\tcase NFT_BITWISE_LSHIFT:\n\t\tnft_bitwise_eval_lshift(dst, src, priv);\n\t\tbreak;\n\tcase NFT_BITWISE_RSHIFT:\n\t\tnft_bitwise_eval_rshift(dst, src, priv);\n\t\tbreak;\n\t}\n}\n\nstatic const struct nla_policy nft_bitwise_policy[NFTA_BITWISE_MAX + 1] = {\n\t[NFTA_BITWISE_SREG]\t= { .type = NLA_U32 },\n\t[NFTA_BITWISE_DREG]\t= { .type = NLA_U32 },\n\t[NFTA_BITWISE_LEN]\t= { .type = NLA_U32 },\n\t[NFTA_BITWISE_MASK]\t= { .type = NLA_NESTED },\n\t[NFTA_BITWISE_XOR]\t= { .type = NLA_NESTED },\n\t[NFTA_BITWISE_OP]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_BITWISE_DATA]\t= { .type = NLA_NESTED },\n};\n\nstatic int nft_bitwise_init_bool(struct nft_bitwise *priv,\n\t\t\t\t const struct nlattr *const tb[])\n{\n\tstruct nft_data_desc mask = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= sizeof(priv->mask),\n\t\t.len\t= priv->len,\n\t};\n\tstruct nft_data_desc xor = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= sizeof(priv->xor),\n\t\t.len\t= priv->len,\n\t};\n\tint err;\n\n\tif (tb[NFTA_BITWISE_DATA])\n\t\treturn -EINVAL;\n\n\tif (!tb[NFTA_BITWISE_MASK] ||\n\t    !tb[NFTA_BITWISE_XOR])\n\t\treturn -EINVAL;\n\n\terr = nft_data_init(NULL, &priv->mask, &mask, tb[NFTA_BITWISE_MASK]);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_data_init(NULL, &priv->xor, &xor, tb[NFTA_BITWISE_XOR]);\n\tif (err < 0)\n\t\tgoto err_xor_err;\n\n\treturn 0;\n\nerr_xor_err:\n\tnft_data_release(&priv->mask, mask.type);\n\n\treturn err;\n}\n\nstatic int nft_bitwise_init_shift(struct nft_bitwise *priv,\n\t\t\t\t  const struct nlattr *const tb[])\n{\n\tstruct nft_data_desc desc = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= sizeof(priv->data),\n\t\t.len\t= sizeof(u32),\n\t};\n\tint err;\n\n\tif (tb[NFTA_BITWISE_MASK] ||\n\t    tb[NFTA_BITWISE_XOR])\n\t\treturn -EINVAL;\n\n\tif (!tb[NFTA_BITWISE_DATA])\n\t\treturn -EINVAL;\n\n\terr = nft_data_init(NULL, &priv->data, &desc, tb[NFTA_BITWISE_DATA]);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (priv->data.data[0] >= BITS_PER_TYPE(u32)) {\n\t\tnft_data_release(&priv->data, desc.type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_bitwise_init(const struct nft_ctx *ctx,\n\t\t\t    const struct nft_expr *expr,\n\t\t\t    const struct nlattr * const tb[])\n{\n\tstruct nft_bitwise *priv = nft_expr_priv(expr);\n\tu32 len;\n\tint err;\n\n\terr = nft_parse_u32_check(tb[NFTA_BITWISE_LEN], U8_MAX, &len);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->len = len;\n\n\terr = nft_parse_register_load(tb[NFTA_BITWISE_SREG], &priv->sreg,\n\t\t\t\t      priv->len);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_parse_register_store(ctx, tb[NFTA_BITWISE_DREG],\n\t\t\t\t       &priv->dreg, NULL, NFT_DATA_VALUE,\n\t\t\t\t       priv->len);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_BITWISE_OP]) {\n\t\tpriv->op = ntohl(nla_get_be32(tb[NFTA_BITWISE_OP]));\n\t\tswitch (priv->op) {\n\t\tcase NFT_BITWISE_BOOL:\n\t\tcase NFT_BITWISE_LSHIFT:\n\t\tcase NFT_BITWISE_RSHIFT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tpriv->op = NFT_BITWISE_BOOL;\n\t}\n\n\tswitch(priv->op) {\n\tcase NFT_BITWISE_BOOL:\n\t\terr = nft_bitwise_init_bool(priv, tb);\n\t\tbreak;\n\tcase NFT_BITWISE_LSHIFT:\n\tcase NFT_BITWISE_RSHIFT:\n\t\terr = nft_bitwise_init_shift(priv, tb);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int nft_bitwise_dump_bool(struct sk_buff *skb,\n\t\t\t\t const struct nft_bitwise *priv)\n{\n\tif (nft_data_dump(skb, NFTA_BITWISE_MASK, &priv->mask,\n\t\t\t  NFT_DATA_VALUE, priv->len) < 0)\n\t\treturn -1;\n\n\tif (nft_data_dump(skb, NFTA_BITWISE_XOR, &priv->xor,\n\t\t\t  NFT_DATA_VALUE, priv->len) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int nft_bitwise_dump_shift(struct sk_buff *skb,\n\t\t\t\t  const struct nft_bitwise *priv)\n{\n\tif (nft_data_dump(skb, NFTA_BITWISE_DATA, &priv->data,\n\t\t\t  NFT_DATA_VALUE, sizeof(u32)) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int nft_bitwise_dump(struct sk_buff *skb,\n\t\t\t    const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_bitwise *priv = nft_expr_priv(expr);\n\tint err = 0;\n\n\tif (nft_dump_register(skb, NFTA_BITWISE_SREG, priv->sreg))\n\t\treturn -1;\n\tif (nft_dump_register(skb, NFTA_BITWISE_DREG, priv->dreg))\n\t\treturn -1;\n\tif (nla_put_be32(skb, NFTA_BITWISE_LEN, htonl(priv->len)))\n\t\treturn -1;\n\tif (nla_put_be32(skb, NFTA_BITWISE_OP, htonl(priv->op)))\n\t\treturn -1;\n\n\tswitch (priv->op) {\n\tcase NFT_BITWISE_BOOL:\n\t\terr = nft_bitwise_dump_bool(skb, priv);\n\t\tbreak;\n\tcase NFT_BITWISE_LSHIFT:\n\tcase NFT_BITWISE_RSHIFT:\n\t\terr = nft_bitwise_dump_shift(skb, priv);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic struct nft_data zero;\n\nstatic int nft_bitwise_offload(struct nft_offload_ctx *ctx,\n\t\t\t       struct nft_flow_rule *flow,\n\t\t\t       const struct nft_expr *expr)\n{\n\tconst struct nft_bitwise *priv = nft_expr_priv(expr);\n\tstruct nft_offload_reg *reg = &ctx->regs[priv->dreg];\n\n\tif (priv->op != NFT_BITWISE_BOOL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (memcmp(&priv->xor, &zero, sizeof(priv->xor)) ||\n\t    priv->sreg != priv->dreg || priv->len != reg->len)\n\t\treturn -EOPNOTSUPP;\n\n\tmemcpy(&reg->mask, &priv->mask, sizeof(priv->mask));\n\n\treturn 0;\n}\n\nstatic bool nft_bitwise_reduce(struct nft_regs_track *track,\n\t\t\t       const struct nft_expr *expr)\n{\n\tconst struct nft_bitwise *priv = nft_expr_priv(expr);\n\tconst struct nft_bitwise *bitwise;\n\tunsigned int regcount;\n\tu8 dreg;\n\tint i;\n\n\tif (!track->regs[priv->sreg].selector)\n\t\treturn false;\n\n\tbitwise = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (track->regs[priv->sreg].selector == track->regs[priv->dreg].selector &&\n\t    track->regs[priv->sreg].num_reg == 0 &&\n\t    track->regs[priv->dreg].bitwise &&\n\t    track->regs[priv->dreg].bitwise->ops == expr->ops &&\n\t    priv->sreg == bitwise->sreg &&\n\t    priv->dreg == bitwise->dreg &&\n\t    priv->op == bitwise->op &&\n\t    priv->len == bitwise->len &&\n\t    !memcmp(&priv->mask, &bitwise->mask, sizeof(priv->mask)) &&\n\t    !memcmp(&priv->xor, &bitwise->xor, sizeof(priv->xor)) &&\n\t    !memcmp(&priv->data, &bitwise->data, sizeof(priv->data))) {\n\t\ttrack->cur = expr;\n\t\treturn true;\n\t}\n\n\tif (track->regs[priv->sreg].bitwise ||\n\t    track->regs[priv->sreg].num_reg != 0) {\n\t\tnft_reg_track_cancel(track, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tif (priv->sreg != priv->dreg) {\n\t\tnft_reg_track_update(track, track->regs[priv->sreg].selector,\n\t\t\t\t     priv->dreg, priv->len);\n\t}\n\n\tdreg = priv->dreg;\n\tregcount = DIV_ROUND_UP(priv->len, NFT_REG32_SIZE);\n\tfor (i = 0; i < regcount; i++, dreg++)\n\t\ttrack->regs[dreg].bitwise = expr;\n\n\treturn false;\n}\n\nstatic const struct nft_expr_ops nft_bitwise_ops = {\n\t.type\t\t= &nft_bitwise_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_bitwise)),\n\t.eval\t\t= nft_bitwise_eval,\n\t.init\t\t= nft_bitwise_init,\n\t.dump\t\t= nft_bitwise_dump,\n\t.reduce\t\t= nft_bitwise_reduce,\n\t.offload\t= nft_bitwise_offload,\n};\n\nstatic int\nnft_bitwise_extract_u32_data(const struct nlattr * const tb, u32 *out)\n{\n\tstruct nft_data data;\n\tstruct nft_data_desc desc = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= sizeof(data),\n\t\t.len\t= sizeof(u32),\n\t};\n\tint err;\n\n\terr = nft_data_init(NULL, &data, &desc, tb);\n\tif (err < 0)\n\t\treturn err;\n\n\t*out = data.data[0];\n\n\treturn 0;\n}\n\nstatic int nft_bitwise_fast_init(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_expr *expr,\n\t\t\t\t const struct nlattr * const tb[])\n{\n\tstruct nft_bitwise_fast_expr *priv = nft_expr_priv(expr);\n\tint err;\n\n\terr = nft_parse_register_load(tb[NFTA_BITWISE_SREG], &priv->sreg,\n\t\t\t\t      sizeof(u32));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_parse_register_store(ctx, tb[NFTA_BITWISE_DREG], &priv->dreg,\n\t\t\t\t       NULL, NFT_DATA_VALUE, sizeof(u32));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_BITWISE_DATA])\n\t\treturn -EINVAL;\n\n\tif (!tb[NFTA_BITWISE_MASK] ||\n\t    !tb[NFTA_BITWISE_XOR])\n\t\treturn -EINVAL;\n\n\terr = nft_bitwise_extract_u32_data(tb[NFTA_BITWISE_MASK], &priv->mask);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_bitwise_extract_u32_data(tb[NFTA_BITWISE_XOR], &priv->xor);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int\nnft_bitwise_fast_dump(struct sk_buff *skb,\n\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_bitwise_fast_expr *priv = nft_expr_priv(expr);\n\tstruct nft_data data;\n\n\tif (nft_dump_register(skb, NFTA_BITWISE_SREG, priv->sreg))\n\t\treturn -1;\n\tif (nft_dump_register(skb, NFTA_BITWISE_DREG, priv->dreg))\n\t\treturn -1;\n\tif (nla_put_be32(skb, NFTA_BITWISE_LEN, htonl(sizeof(u32))))\n\t\treturn -1;\n\tif (nla_put_be32(skb, NFTA_BITWISE_OP, htonl(NFT_BITWISE_BOOL)))\n\t\treturn -1;\n\n\tdata.data[0] = priv->mask;\n\tif (nft_data_dump(skb, NFTA_BITWISE_MASK, &data,\n\t\t\t  NFT_DATA_VALUE, sizeof(u32)) < 0)\n\t\treturn -1;\n\n\tdata.data[0] = priv->xor;\n\tif (nft_data_dump(skb, NFTA_BITWISE_XOR, &data,\n\t\t\t  NFT_DATA_VALUE, sizeof(u32)) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int nft_bitwise_fast_offload(struct nft_offload_ctx *ctx,\n\t\t\t\t    struct nft_flow_rule *flow,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tconst struct nft_bitwise_fast_expr *priv = nft_expr_priv(expr);\n\tstruct nft_offload_reg *reg = &ctx->regs[priv->dreg];\n\n\tif (priv->xor || priv->sreg != priv->dreg || reg->len != sizeof(u32))\n\t\treturn -EOPNOTSUPP;\n\n\treg->mask.data[0] = priv->mask;\n\treturn 0;\n}\n\nstatic bool nft_bitwise_fast_reduce(struct nft_regs_track *track,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tconst struct nft_bitwise_fast_expr *priv = nft_expr_priv(expr);\n\tconst struct nft_bitwise_fast_expr *bitwise;\n\n\tif (!track->regs[priv->sreg].selector)\n\t\treturn false;\n\n\tbitwise = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (track->regs[priv->sreg].selector == track->regs[priv->dreg].selector &&\n\t    track->regs[priv->dreg].bitwise &&\n\t    track->regs[priv->dreg].bitwise->ops == expr->ops &&\n\t    priv->sreg == bitwise->sreg &&\n\t    priv->dreg == bitwise->dreg &&\n\t    priv->mask == bitwise->mask &&\n\t    priv->xor == bitwise->xor) {\n\t\ttrack->cur = expr;\n\t\treturn true;\n\t}\n\n\tif (track->regs[priv->sreg].bitwise) {\n\t\tnft_reg_track_cancel(track, priv->dreg, NFT_REG32_SIZE);\n\t\treturn false;\n\t}\n\n\tif (priv->sreg != priv->dreg) {\n\t\ttrack->regs[priv->dreg].selector =\n\t\t\ttrack->regs[priv->sreg].selector;\n\t}\n\ttrack->regs[priv->dreg].bitwise = expr;\n\n\treturn false;\n}\n\nconst struct nft_expr_ops nft_bitwise_fast_ops = {\n\t.type\t\t= &nft_bitwise_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_bitwise_fast_expr)),\n\t.eval\t\t= NULL,  \n\t.init\t\t= nft_bitwise_fast_init,\n\t.dump\t\t= nft_bitwise_fast_dump,\n\t.reduce\t\t= nft_bitwise_fast_reduce,\n\t.offload\t= nft_bitwise_fast_offload,\n};\n\nstatic const struct nft_expr_ops *\nnft_bitwise_select_ops(const struct nft_ctx *ctx,\n\t\t       const struct nlattr * const tb[])\n{\n\tint err;\n\tu32 len;\n\n\tif (!tb[NFTA_BITWISE_LEN] ||\n\t    !tb[NFTA_BITWISE_SREG] ||\n\t    !tb[NFTA_BITWISE_DREG])\n\t\treturn ERR_PTR(-EINVAL);\n\n\terr = nft_parse_u32_check(tb[NFTA_BITWISE_LEN], U8_MAX, &len);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tif (len != sizeof(u32))\n\t\treturn &nft_bitwise_ops;\n\n\tif (tb[NFTA_BITWISE_OP] &&\n\t    ntohl(nla_get_be32(tb[NFTA_BITWISE_OP])) != NFT_BITWISE_BOOL)\n\t\treturn &nft_bitwise_ops;\n\n\treturn &nft_bitwise_fast_ops;\n}\n\nstruct nft_expr_type nft_bitwise_type __read_mostly = {\n\t.name\t\t= \"bitwise\",\n\t.select_ops\t= nft_bitwise_select_ops,\n\t.policy\t\t= nft_bitwise_policy,\n\t.maxattr\t= NFTA_BITWISE_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nbool nft_expr_reduce_bitwise(struct nft_regs_track *track,\n\t\t\t     const struct nft_expr *expr)\n{\n\tconst struct nft_expr *last = track->last;\n\tconst struct nft_expr *next;\n\n\tif (expr == last)\n\t\treturn false;\n\n\tnext = nft_expr_next(expr);\n\tif (next->ops == &nft_bitwise_ops)\n\t\treturn nft_bitwise_reduce(track, next);\n\telse if (next->ops == &nft_bitwise_fast_ops)\n\t\treturn nft_bitwise_fast_reduce(track, next);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(nft_expr_reduce_bitwise);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}