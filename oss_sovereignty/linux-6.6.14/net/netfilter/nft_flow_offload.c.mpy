{
  "module_name": "nft_flow_offload.c",
  "hash_id": "2ade8fc4989bfe83c62b34f4a146989f3fbdcaf20d27e1f2ff0c00a35772ecfd",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_flow_offload.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include <linux/netfilter/nf_conntrack_common.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/ip.h>  \n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_extend.h>\n#include <net/netfilter/nf_flow_table.h>\n\nstruct nft_flow_offload {\n\tstruct nft_flowtable\t*flowtable;\n};\n\nstatic enum flow_offload_xmit_type nft_xmit_type(struct dst_entry *dst)\n{\n\tif (dst_xfrm(dst))\n\t\treturn FLOW_OFFLOAD_XMIT_XFRM;\n\n\treturn FLOW_OFFLOAD_XMIT_NEIGH;\n}\n\nstatic void nft_default_forward_path(struct nf_flow_route *route,\n\t\t\t\t     struct dst_entry *dst_cache,\n\t\t\t\t     enum ip_conntrack_dir dir)\n{\n\troute->tuple[!dir].in.ifindex\t= dst_cache->dev->ifindex;\n\troute->tuple[dir].dst\t\t= dst_cache;\n\troute->tuple[dir].xmit_type\t= nft_xmit_type(dst_cache);\n}\n\nstatic bool nft_is_valid_ether_device(const struct net_device *dev)\n{\n\tif (!dev || (dev->flags & IFF_LOOPBACK) || dev->type != ARPHRD_ETHER ||\n\t    dev->addr_len != ETH_ALEN || !is_valid_ether_addr(dev->dev_addr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int nft_dev_fill_forward_path(const struct nf_flow_route *route,\n\t\t\t\t     const struct dst_entry *dst_cache,\n\t\t\t\t     const struct nf_conn *ct,\n\t\t\t\t     enum ip_conntrack_dir dir, u8 *ha,\n\t\t\t\t     struct net_device_path_stack *stack)\n{\n\tconst void *daddr = &ct->tuplehash[!dir].tuple.src.u3;\n\tstruct net_device *dev = dst_cache->dev;\n\tstruct neighbour *n;\n\tu8 nud_state;\n\n\tif (!nft_is_valid_ether_device(dev))\n\t\tgoto out;\n\n\tn = dst_neigh_lookup(dst_cache, daddr);\n\tif (!n)\n\t\treturn -1;\n\n\tread_lock_bh(&n->lock);\n\tnud_state = n->nud_state;\n\tether_addr_copy(ha, n->ha);\n\tread_unlock_bh(&n->lock);\n\tneigh_release(n);\n\n\tif (!(nud_state & NUD_VALID))\n\t\treturn -1;\n\nout:\n\treturn dev_fill_forward_path(dev, ha, stack);\n}\n\nstruct nft_forward_info {\n\tconst struct net_device *indev;\n\tconst struct net_device *outdev;\n\tconst struct net_device *hw_outdev;\n\tstruct id {\n\t\t__u16\tid;\n\t\t__be16\tproto;\n\t} encap[NF_FLOW_TABLE_ENCAP_MAX];\n\tu8 num_encaps;\n\tu8 ingress_vlans;\n\tu8 h_source[ETH_ALEN];\n\tu8 h_dest[ETH_ALEN];\n\tenum flow_offload_xmit_type xmit_type;\n};\n\nstatic void nft_dev_path_info(const struct net_device_path_stack *stack,\n\t\t\t      struct nft_forward_info *info,\n\t\t\t      unsigned char *ha, struct nf_flowtable *flowtable)\n{\n\tconst struct net_device_path *path;\n\tint i;\n\n\tmemcpy(info->h_dest, ha, ETH_ALEN);\n\n\tfor (i = 0; i < stack->num_paths; i++) {\n\t\tpath = &stack->path[i];\n\t\tswitch (path->type) {\n\t\tcase DEV_PATH_ETHERNET:\n\t\tcase DEV_PATH_DSA:\n\t\tcase DEV_PATH_VLAN:\n\t\tcase DEV_PATH_PPPOE:\n\t\t\tinfo->indev = path->dev;\n\t\t\tif (is_zero_ether_addr(info->h_source))\n\t\t\t\tmemcpy(info->h_source, path->dev->dev_addr, ETH_ALEN);\n\n\t\t\tif (path->type == DEV_PATH_ETHERNET)\n\t\t\t\tbreak;\n\t\t\tif (path->type == DEV_PATH_DSA) {\n\t\t\t\ti = stack->num_paths;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (info->num_encaps >= NF_FLOW_TABLE_ENCAP_MAX) {\n\t\t\t\tinfo->indev = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!info->outdev)\n\t\t\t\tinfo->outdev = path->dev;\n\t\t\tinfo->encap[info->num_encaps].id = path->encap.id;\n\t\t\tinfo->encap[info->num_encaps].proto = path->encap.proto;\n\t\t\tinfo->num_encaps++;\n\t\t\tif (path->type == DEV_PATH_PPPOE)\n\t\t\t\tmemcpy(info->h_dest, path->encap.h_dest, ETH_ALEN);\n\t\t\tbreak;\n\t\tcase DEV_PATH_BRIDGE:\n\t\t\tif (is_zero_ether_addr(info->h_source))\n\t\t\t\tmemcpy(info->h_source, path->dev->dev_addr, ETH_ALEN);\n\n\t\t\tswitch (path->bridge.vlan_mode) {\n\t\t\tcase DEV_PATH_BR_VLAN_UNTAG_HW:\n\t\t\t\tinfo->ingress_vlans |= BIT(info->num_encaps - 1);\n\t\t\t\tbreak;\n\t\t\tcase DEV_PATH_BR_VLAN_TAG:\n\t\t\t\tinfo->encap[info->num_encaps].id = path->bridge.vlan_id;\n\t\t\t\tinfo->encap[info->num_encaps].proto = path->bridge.vlan_proto;\n\t\t\t\tinfo->num_encaps++;\n\t\t\t\tbreak;\n\t\t\tcase DEV_PATH_BR_VLAN_UNTAG:\n\t\t\t\tinfo->num_encaps--;\n\t\t\t\tbreak;\n\t\t\tcase DEV_PATH_BR_VLAN_KEEP:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->xmit_type = FLOW_OFFLOAD_XMIT_DIRECT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo->indev = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!info->outdev)\n\t\tinfo->outdev = info->indev;\n\n\tinfo->hw_outdev = info->indev;\n\n\tif (nf_flowtable_hw_offload(flowtable) &&\n\t    nft_is_valid_ether_device(info->indev))\n\t\tinfo->xmit_type = FLOW_OFFLOAD_XMIT_DIRECT;\n}\n\nstatic bool nft_flowtable_find_dev(const struct net_device *dev,\n\t\t\t\t   struct nft_flowtable *ft)\n{\n\tstruct nft_hook *hook;\n\tbool found = false;\n\n\tlist_for_each_entry_rcu(hook, &ft->hook_list, list) {\n\t\tif (hook->ops.dev != dev)\n\t\t\tcontinue;\n\n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\treturn found;\n}\n\nstatic void nft_dev_forward_path(struct nf_flow_route *route,\n\t\t\t\t const struct nf_conn *ct,\n\t\t\t\t enum ip_conntrack_dir dir,\n\t\t\t\t struct nft_flowtable *ft)\n{\n\tconst struct dst_entry *dst = route->tuple[dir].dst;\n\tstruct net_device_path_stack stack;\n\tstruct nft_forward_info info = {};\n\tunsigned char ha[ETH_ALEN];\n\tint i;\n\n\tif (nft_dev_fill_forward_path(route, dst, ct, dir, ha, &stack) >= 0)\n\t\tnft_dev_path_info(&stack, &info, ha, &ft->data);\n\n\tif (!info.indev || !nft_flowtable_find_dev(info.indev, ft))\n\t\treturn;\n\n\troute->tuple[!dir].in.ifindex = info.indev->ifindex;\n\tfor (i = 0; i < info.num_encaps; i++) {\n\t\troute->tuple[!dir].in.encap[i].id = info.encap[i].id;\n\t\troute->tuple[!dir].in.encap[i].proto = info.encap[i].proto;\n\t}\n\troute->tuple[!dir].in.num_encaps = info.num_encaps;\n\troute->tuple[!dir].in.ingress_vlans = info.ingress_vlans;\n\n\tif (info.xmit_type == FLOW_OFFLOAD_XMIT_DIRECT) {\n\t\tmemcpy(route->tuple[dir].out.h_source, info.h_source, ETH_ALEN);\n\t\tmemcpy(route->tuple[dir].out.h_dest, info.h_dest, ETH_ALEN);\n\t\troute->tuple[dir].out.ifindex = info.outdev->ifindex;\n\t\troute->tuple[dir].out.hw_ifindex = info.hw_outdev->ifindex;\n\t\troute->tuple[dir].xmit_type = info.xmit_type;\n\t}\n}\n\nstatic int nft_flow_route(const struct nft_pktinfo *pkt,\n\t\t\t  const struct nf_conn *ct,\n\t\t\t  struct nf_flow_route *route,\n\t\t\t  enum ip_conntrack_dir dir,\n\t\t\t  struct nft_flowtable *ft)\n{\n\tstruct dst_entry *this_dst = skb_dst(pkt->skb);\n\tstruct dst_entry *other_dst = NULL;\n\tstruct flowi fl;\n\n\tmemset(&fl, 0, sizeof(fl));\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tfl.u.ip4.daddr = ct->tuplehash[dir].tuple.src.u3.ip;\n\t\tfl.u.ip4.saddr = ct->tuplehash[!dir].tuple.src.u3.ip;\n\t\tfl.u.ip4.flowi4_oif = nft_in(pkt)->ifindex;\n\t\tfl.u.ip4.flowi4_iif = this_dst->dev->ifindex;\n\t\tfl.u.ip4.flowi4_tos = RT_TOS(ip_hdr(pkt->skb)->tos);\n\t\tfl.u.ip4.flowi4_mark = pkt->skb->mark;\n\t\tfl.u.ip4.flowi4_flags = FLOWI_FLAG_ANYSRC;\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tfl.u.ip6.daddr = ct->tuplehash[dir].tuple.src.u3.in6;\n\t\tfl.u.ip6.saddr = ct->tuplehash[!dir].tuple.src.u3.in6;\n\t\tfl.u.ip6.flowi6_oif = nft_in(pkt)->ifindex;\n\t\tfl.u.ip6.flowi6_iif = this_dst->dev->ifindex;\n\t\tfl.u.ip6.flowlabel = ip6_flowinfo(ipv6_hdr(pkt->skb));\n\t\tfl.u.ip6.flowi6_mark = pkt->skb->mark;\n\t\tfl.u.ip6.flowi6_flags = FLOWI_FLAG_ANYSRC;\n\t\tbreak;\n\t}\n\n\tif (!dst_hold_safe(this_dst))\n\t\treturn -ENOENT;\n\n\tnf_route(nft_net(pkt), &other_dst, &fl, false, nft_pf(pkt));\n\tif (!other_dst) {\n\t\tdst_release(this_dst);\n\t\treturn -ENOENT;\n\t}\n\n\tnft_default_forward_path(route, this_dst, dir);\n\tnft_default_forward_path(route, other_dst, !dir);\n\n\tif (route->tuple[dir].xmit_type\t== FLOW_OFFLOAD_XMIT_NEIGH &&\n\t    route->tuple[!dir].xmit_type == FLOW_OFFLOAD_XMIT_NEIGH) {\n\t\tnft_dev_forward_path(route, ct, dir, ft);\n\t\tnft_dev_forward_path(route, ct, !dir, ft);\n\t}\n\n\treturn 0;\n}\n\nstatic bool nft_flow_offload_skip(struct sk_buff *skb, int family)\n{\n\tif (skb_sec_path(skb))\n\t\treturn true;\n\n\tif (family == NFPROTO_IPV4) {\n\t\tconst struct ip_options *opt;\n\n\t\topt = &(IPCB(skb)->opt);\n\n\t\tif (unlikely(opt->optlen))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void nft_flow_offload_eval(const struct nft_expr *expr,\n\t\t\t\t  struct nft_regs *regs,\n\t\t\t\t  const struct nft_pktinfo *pkt)\n{\n\tstruct nft_flow_offload *priv = nft_expr_priv(expr);\n\tstruct nf_flowtable *flowtable = &priv->flowtable->data;\n\tstruct tcphdr _tcph, *tcph = NULL;\n\tstruct nf_flow_route route = {};\n\tenum ip_conntrack_info ctinfo;\n\tstruct flow_offload *flow;\n\tenum ip_conntrack_dir dir;\n\tstruct nf_conn *ct;\n\tint ret;\n\n\tif (nft_flow_offload_skip(pkt->skb, nft_pf(pkt)))\n\t\tgoto out;\n\n\tct = nf_ct_get(pkt->skb, &ctinfo);\n\tif (!ct)\n\t\tgoto out;\n\n\tswitch (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum) {\n\tcase IPPROTO_TCP:\n\t\ttcph = skb_header_pointer(pkt->skb, nft_thoff(pkt),\n\t\t\t\t\t  sizeof(_tcph), &_tcph);\n\t\tif (unlikely(!tcph || tcph->fin || tcph->rst ||\n\t\t\t     !nf_conntrack_tcp_established(ct)))\n\t\t\tgoto out;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tbreak;\n#ifdef CONFIG_NF_CT_PROTO_GRE\n\tcase IPPROTO_GRE: {\n\t\tstruct nf_conntrack_tuple *tuple;\n\n\t\tif (ct->status & IPS_NAT_MASK)\n\t\t\tgoto out;\n\t\ttuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\t\t \n\t\tif (tuple->src.u.gre.key || tuple->dst.u.gre.key)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif (nf_ct_ext_exist(ct, NF_CT_EXT_HELPER) ||\n\t    ct->status & (IPS_SEQ_ADJUST | IPS_NAT_CLASH))\n\t\tgoto out;\n\n\tif (!nf_ct_is_confirmed(ct))\n\t\tgoto out;\n\n\tif (test_and_set_bit(IPS_OFFLOAD_BIT, &ct->status))\n\t\tgoto out;\n\n\tdir = CTINFO2DIR(ctinfo);\n\tif (nft_flow_route(pkt, ct, &route, dir, priv->flowtable) < 0)\n\t\tgoto err_flow_route;\n\n\tflow = flow_offload_alloc(ct);\n\tif (!flow)\n\t\tgoto err_flow_alloc;\n\n\tflow_offload_route_init(flow, &route);\n\n\tif (tcph) {\n\t\tct->proto.tcp.seen[0].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;\n\t\tct->proto.tcp.seen[1].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;\n\t}\n\n\tret = flow_offload_add(flowtable, flow);\n\tif (ret < 0)\n\t\tgoto err_flow_add;\n\n\treturn;\n\nerr_flow_add:\n\tflow_offload_free(flow);\nerr_flow_alloc:\n\tdst_release(route.tuple[dir].dst);\n\tdst_release(route.tuple[!dir].dst);\nerr_flow_route:\n\tclear_bit(IPS_OFFLOAD_BIT, &ct->status);\nout:\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic int nft_flow_offload_validate(const struct nft_ctx *ctx,\n\t\t\t\t     const struct nft_expr *expr,\n\t\t\t\t     const struct nft_data **data)\n{\n\tunsigned int hook_mask = (1 << NF_INET_FORWARD);\n\n\treturn nft_chain_validate_hooks(ctx->chain, hook_mask);\n}\n\nstatic const struct nla_policy nft_flow_offload_policy[NFTA_FLOW_MAX + 1] = {\n\t[NFTA_FLOW_TABLE_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_NAME_MAXLEN - 1 },\n};\n\nstatic int nft_flow_offload_init(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_expr *expr,\n\t\t\t\t const struct nlattr * const tb[])\n{\n\tstruct nft_flow_offload *priv = nft_expr_priv(expr);\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_flowtable *flowtable;\n\n\tif (!tb[NFTA_FLOW_TABLE_NAME])\n\t\treturn -EINVAL;\n\n\tflowtable = nft_flowtable_lookup(ctx->table, tb[NFTA_FLOW_TABLE_NAME],\n\t\t\t\t\t genmask);\n\tif (IS_ERR(flowtable))\n\t\treturn PTR_ERR(flowtable);\n\n\tif (!nft_use_inc(&flowtable->use))\n\t\treturn -EMFILE;\n\n\tpriv->flowtable = flowtable;\n\n\treturn nf_ct_netns_get(ctx->net, ctx->family);\n}\n\nstatic void nft_flow_offload_deactivate(const struct nft_ctx *ctx,\n\t\t\t\t\tconst struct nft_expr *expr,\n\t\t\t\t\tenum nft_trans_phase phase)\n{\n\tstruct nft_flow_offload *priv = nft_expr_priv(expr);\n\n\tnf_tables_deactivate_flowtable(ctx, priv->flowtable, phase);\n}\n\nstatic void nft_flow_offload_activate(const struct nft_ctx *ctx,\n\t\t\t\t      const struct nft_expr *expr)\n{\n\tstruct nft_flow_offload *priv = nft_expr_priv(expr);\n\n\tnft_use_inc_restore(&priv->flowtable->use);\n}\n\nstatic void nft_flow_offload_destroy(const struct nft_ctx *ctx,\n\t\t\t\t     const struct nft_expr *expr)\n{\n\tnf_ct_netns_put(ctx->net, ctx->family);\n}\n\nstatic int nft_flow_offload_dump(struct sk_buff *skb,\n\t\t\t\t const struct nft_expr *expr, bool reset)\n{\n\tstruct nft_flow_offload *priv = nft_expr_priv(expr);\n\n\tif (nla_put_string(skb, NFTA_FLOW_TABLE_NAME, priv->flowtable->name))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic struct nft_expr_type nft_flow_offload_type;\nstatic const struct nft_expr_ops nft_flow_offload_ops = {\n\t.type\t\t= &nft_flow_offload_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_flow_offload)),\n\t.eval\t\t= nft_flow_offload_eval,\n\t.init\t\t= nft_flow_offload_init,\n\t.activate\t= nft_flow_offload_activate,\n\t.deactivate\t= nft_flow_offload_deactivate,\n\t.destroy\t= nft_flow_offload_destroy,\n\t.validate\t= nft_flow_offload_validate,\n\t.dump\t\t= nft_flow_offload_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_flow_offload_type __read_mostly = {\n\t.name\t\t= \"flow_offload\",\n\t.ops\t\t= &nft_flow_offload_ops,\n\t.policy\t\t= nft_flow_offload_policy,\n\t.maxattr\t= NFTA_FLOW_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int flow_offload_netdev_event(struct notifier_block *this,\n\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (event != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\n\tnf_flow_table_cleanup(dev);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block flow_offload_netdev_notifier = {\n\t.notifier_call\t= flow_offload_netdev_event,\n};\n\nstatic int __init nft_flow_offload_module_init(void)\n{\n\tint err;\n\n\terr = register_netdevice_notifier(&flow_offload_netdev_notifier);\n\tif (err)\n\t\tgoto err;\n\n\terr = nft_register_expr(&nft_flow_offload_type);\n\tif (err < 0)\n\t\tgoto register_expr;\n\n\treturn 0;\n\nregister_expr:\n\tunregister_netdevice_notifier(&flow_offload_netdev_notifier);\nerr:\n\treturn err;\n}\n\nstatic void __exit nft_flow_offload_module_exit(void)\n{\n\tnft_unregister_expr(&nft_flow_offload_type);\n\tunregister_netdevice_notifier(&flow_offload_netdev_notifier);\n}\n\nmodule_init(nft_flow_offload_module_init);\nmodule_exit(nft_flow_offload_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_ALIAS_NFT_EXPR(\"flow_offload\");\nMODULE_DESCRIPTION(\"nftables hardware flow offload module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}