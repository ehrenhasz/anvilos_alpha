{
  "module_name": "xt_cgroup.c",
  "hash_id": "4afc5d93679fede3ab91c78a1f00a6ca9f81b6914759f9c9106d21b31beef19c",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_cgroup.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/skbuff.h>\n#include <linux/module.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_cgroup.h>\n#include <net/sock.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Daniel Borkmann <dborkman@redhat.com>\");\nMODULE_DESCRIPTION(\"Xtables: process control group matching\");\nMODULE_ALIAS(\"ipt_cgroup\");\nMODULE_ALIAS(\"ip6t_cgroup\");\n\nstatic int cgroup_mt_check_v0(const struct xt_mtchk_param *par)\n{\n\tstruct xt_cgroup_info_v0 *info = par->matchinfo;\n\n\tif (info->invert & ~1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cgroup_mt_check_v1(const struct xt_mtchk_param *par)\n{\n\tstruct xt_cgroup_info_v1 *info = par->matchinfo;\n\tstruct cgroup *cgrp;\n\n\tif ((info->invert_path & ~1) || (info->invert_classid & ~1))\n\t\treturn -EINVAL;\n\n\tif (!info->has_path && !info->has_classid) {\n\t\tpr_info(\"xt_cgroup: no path or classid specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->has_path && info->has_classid) {\n\t\tpr_info_ratelimited(\"path and classid specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->priv = NULL;\n\tif (info->has_path) {\n\t\tcgrp = cgroup_get_from_path(info->path);\n\t\tif (IS_ERR(cgrp)) {\n\t\t\tpr_info_ratelimited(\"invalid path, errno=%ld\\n\",\n\t\t\t\t\t    PTR_ERR(cgrp));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinfo->priv = cgrp;\n\t}\n\n\treturn 0;\n}\n\nstatic int cgroup_mt_check_v2(const struct xt_mtchk_param *par)\n{\n\tstruct xt_cgroup_info_v2 *info = par->matchinfo;\n\tstruct cgroup *cgrp;\n\n\tif ((info->invert_path & ~1) || (info->invert_classid & ~1))\n\t\treturn -EINVAL;\n\n\tif (!info->has_path && !info->has_classid) {\n\t\tpr_info(\"xt_cgroup: no path or classid specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->has_path && info->has_classid) {\n\t\tpr_info_ratelimited(\"path and classid specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->priv = NULL;\n\tif (info->has_path) {\n\t\tcgrp = cgroup_get_from_path(info->path);\n\t\tif (IS_ERR(cgrp)) {\n\t\t\tpr_info_ratelimited(\"invalid path, errno=%ld\\n\",\n\t\t\t\t\t    PTR_ERR(cgrp));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinfo->priv = cgrp;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\ncgroup_mt_v0(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_cgroup_info_v0 *info = par->matchinfo;\n\tstruct sock *sk = skb->sk;\n\n\tif (!sk || !sk_fullsock(sk) || !net_eq(xt_net(par), sock_net(sk)))\n\t\treturn false;\n\n\treturn (info->id == sock_cgroup_classid(&skb->sk->sk_cgrp_data)) ^\n\t\tinfo->invert;\n}\n\nstatic bool cgroup_mt_v1(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_cgroup_info_v1 *info = par->matchinfo;\n\tstruct sock_cgroup_data *skcd = &skb->sk->sk_cgrp_data;\n\tstruct cgroup *ancestor = info->priv;\n\tstruct sock *sk = skb->sk;\n\n\tif (!sk || !sk_fullsock(sk) || !net_eq(xt_net(par), sock_net(sk)))\n\t\treturn false;\n\n\tif (ancestor)\n\t\treturn cgroup_is_descendant(sock_cgroup_ptr(skcd), ancestor) ^\n\t\t\tinfo->invert_path;\n\telse\n\t\treturn (info->classid == sock_cgroup_classid(skcd)) ^\n\t\t\tinfo->invert_classid;\n}\n\nstatic bool cgroup_mt_v2(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_cgroup_info_v2 *info = par->matchinfo;\n\tstruct sock_cgroup_data *skcd = &skb->sk->sk_cgrp_data;\n\tstruct cgroup *ancestor = info->priv;\n\tstruct sock *sk = skb->sk;\n\n\tif (!sk || !sk_fullsock(sk) || !net_eq(xt_net(par), sock_net(sk)))\n\t\treturn false;\n\n\tif (ancestor)\n\t\treturn cgroup_is_descendant(sock_cgroup_ptr(skcd), ancestor) ^\n\t\t\tinfo->invert_path;\n\telse\n\t\treturn (info->classid == sock_cgroup_classid(skcd)) ^\n\t\t\tinfo->invert_classid;\n}\n\nstatic void cgroup_mt_destroy_v1(const struct xt_mtdtor_param *par)\n{\n\tstruct xt_cgroup_info_v1 *info = par->matchinfo;\n\n\tif (info->priv)\n\t\tcgroup_put(info->priv);\n}\n\nstatic void cgroup_mt_destroy_v2(const struct xt_mtdtor_param *par)\n{\n\tstruct xt_cgroup_info_v2 *info = par->matchinfo;\n\n\tif (info->priv)\n\t\tcgroup_put(info->priv);\n}\n\nstatic struct xt_match cgroup_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"cgroup\",\n\t\t.revision\t= 0,\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.checkentry\t= cgroup_mt_check_v0,\n\t\t.match\t\t= cgroup_mt_v0,\n\t\t.matchsize\t= sizeof(struct xt_cgroup_info_v0),\n\t\t.me\t\t= THIS_MODULE,\n\t\t.hooks\t\t= (1 << NF_INET_LOCAL_OUT) |\n\t\t\t\t  (1 << NF_INET_POST_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t},\n\t{\n\t\t.name\t\t= \"cgroup\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.checkentry\t= cgroup_mt_check_v1,\n\t\t.match\t\t= cgroup_mt_v1,\n\t\t.matchsize\t= sizeof(struct xt_cgroup_info_v1),\n\t\t.usersize\t= offsetof(struct xt_cgroup_info_v1, priv),\n\t\t.destroy\t= cgroup_mt_destroy_v1,\n\t\t.me\t\t= THIS_MODULE,\n\t\t.hooks\t\t= (1 << NF_INET_LOCAL_OUT) |\n\t\t\t\t  (1 << NF_INET_POST_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t},\n\t{\n\t\t.name\t\t= \"cgroup\",\n\t\t.revision\t= 2,\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.checkentry\t= cgroup_mt_check_v2,\n\t\t.match\t\t= cgroup_mt_v2,\n\t\t.matchsize\t= sizeof(struct xt_cgroup_info_v2),\n\t\t.usersize\t= offsetof(struct xt_cgroup_info_v2, priv),\n\t\t.destroy\t= cgroup_mt_destroy_v2,\n\t\t.me\t\t= THIS_MODULE,\n\t\t.hooks\t\t= (1 << NF_INET_LOCAL_OUT) |\n\t\t\t\t  (1 << NF_INET_POST_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t},\n};\n\nstatic int __init cgroup_mt_init(void)\n{\n\treturn xt_register_matches(cgroup_mt_reg, ARRAY_SIZE(cgroup_mt_reg));\n}\n\nstatic void __exit cgroup_mt_exit(void)\n{\n\txt_unregister_matches(cgroup_mt_reg, ARRAY_SIZE(cgroup_mt_reg));\n}\n\nmodule_init(cgroup_mt_init);\nmodule_exit(cgroup_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}