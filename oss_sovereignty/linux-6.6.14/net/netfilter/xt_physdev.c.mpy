{
  "module_name": "xt_physdev.c",
  "hash_id": "1e6db98d757d610aa21d68fe00fae659aa3e2d59a4cd72f7e62192277ac8e741",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_physdev.c",
  "human_readable_source": "\n \n\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/if.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/netfilter/x_tables.h>\n#include <uapi/linux/netfilter/xt_physdev.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bart De Schuymer <bdschuym@pandora.be>\");\nMODULE_DESCRIPTION(\"Xtables: Bridge physical device match\");\nMODULE_ALIAS(\"ipt_physdev\");\nMODULE_ALIAS(\"ip6t_physdev\");\n\n\nstatic bool\nphysdev_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_physdev_info *info = par->matchinfo;\n\tconst struct net_device *physdev;\n\tunsigned long ret;\n\tconst char *indev, *outdev;\n\n\t \n\tif (!nf_bridge_info_exists(skb)) {\n\t\t \n\t\tif ((info->bitmask & XT_PHYSDEV_OP_BRIDGED) &&\n\t\t    !(info->invert & XT_PHYSDEV_OP_BRIDGED))\n\t\t\treturn false;\n\t\tif ((info->bitmask & XT_PHYSDEV_OP_ISIN) &&\n\t\t    !(info->invert & XT_PHYSDEV_OP_ISIN))\n\t\t\treturn false;\n\t\tif ((info->bitmask & XT_PHYSDEV_OP_ISOUT) &&\n\t\t    !(info->invert & XT_PHYSDEV_OP_ISOUT))\n\t\t\treturn false;\n\t\tif ((info->bitmask & XT_PHYSDEV_OP_IN) &&\n\t\t    !(info->invert & XT_PHYSDEV_OP_IN))\n\t\t\treturn false;\n\t\tif ((info->bitmask & XT_PHYSDEV_OP_OUT) &&\n\t\t    !(info->invert & XT_PHYSDEV_OP_OUT))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tphysdev = nf_bridge_get_physoutdev(skb);\n\toutdev = physdev ? physdev->name : NULL;\n\n\t \n\tif ((info->bitmask & XT_PHYSDEV_OP_BRIDGED) &&\n\t    (!!outdev ^ !(info->invert & XT_PHYSDEV_OP_BRIDGED)))\n\t\treturn false;\n\n\tphysdev = nf_bridge_get_physindev(skb, xt_net(par));\n\tindev = physdev ? physdev->name : NULL;\n\n\tif ((info->bitmask & XT_PHYSDEV_OP_ISIN &&\n\t    (!indev ^ !!(info->invert & XT_PHYSDEV_OP_ISIN))) ||\n\t    (info->bitmask & XT_PHYSDEV_OP_ISOUT &&\n\t    (!outdev ^ !!(info->invert & XT_PHYSDEV_OP_ISOUT))))\n\t\treturn false;\n\n\tif (!(info->bitmask & XT_PHYSDEV_OP_IN))\n\t\tgoto match_outdev;\n\n\tif (indev) {\n\t\tret = ifname_compare_aligned(indev, info->physindev,\n\t\t\t\t\t     info->in_mask);\n\n\t\tif (!ret ^ !(info->invert & XT_PHYSDEV_OP_IN))\n\t\t\treturn false;\n\t}\n\nmatch_outdev:\n\tif (!(info->bitmask & XT_PHYSDEV_OP_OUT))\n\t\treturn true;\n\n\tif (!outdev)\n\t\treturn false;\n\n\tret = ifname_compare_aligned(outdev, info->physoutdev, info->out_mask);\n\n\treturn (!!ret ^ !(info->invert & XT_PHYSDEV_OP_OUT));\n}\n\nstatic int physdev_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_physdev_info *info = par->matchinfo;\n\tstatic bool brnf_probed __read_mostly;\n\n\tif (!(info->bitmask & XT_PHYSDEV_OP_MASK) ||\n\t    info->bitmask & ~XT_PHYSDEV_OP_MASK)\n\t\treturn -EINVAL;\n\tif (info->bitmask & (XT_PHYSDEV_OP_OUT | XT_PHYSDEV_OP_ISOUT) &&\n\t    (!(info->bitmask & XT_PHYSDEV_OP_BRIDGED) ||\n\t     info->invert & XT_PHYSDEV_OP_BRIDGED) &&\n\t    par->hook_mask & (1 << NF_INET_LOCAL_OUT)) {\n\t\tpr_info_ratelimited(\"--physdev-out and --physdev-is-out only supported in the FORWARD and POSTROUTING chains with bridged traffic\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!brnf_probed) {\n\t\tbrnf_probed = true;\n\t\trequest_module(\"br_netfilter\");\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_match physdev_mt_reg __read_mostly = {\n\t.name       = \"physdev\",\n\t.revision   = 0,\n\t.family     = NFPROTO_UNSPEC,\n\t.checkentry = physdev_mt_check,\n\t.match      = physdev_mt,\n\t.matchsize  = sizeof(struct xt_physdev_info),\n\t.me         = THIS_MODULE,\n};\n\nstatic int __init physdev_mt_init(void)\n{\n\treturn xt_register_match(&physdev_mt_reg);\n}\n\nstatic void __exit physdev_mt_exit(void)\n{\n\txt_unregister_match(&physdev_mt_reg);\n}\n\nmodule_init(physdev_mt_init);\nmodule_exit(physdev_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}