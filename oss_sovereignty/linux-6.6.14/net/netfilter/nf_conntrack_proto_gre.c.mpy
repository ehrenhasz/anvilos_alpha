{
  "module_name": "nf_conntrack_proto_gre.c",
  "hash_id": "b0823d5a6bb7d8d7a0df84356ff14a7fea4b9491849c4951dda9051916dc1c90",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_proto_gre.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/seq_file.h>\n#include <linux/in.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/dst.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n#include <linux/netfilter/nf_conntrack_proto_gre.h>\n#include <linux/netfilter/nf_conntrack_pptp.h>\n\nstatic const unsigned int gre_timeouts[GRE_CT_MAX] = {\n\t[GRE_CT_UNREPLIED]\t= 30*HZ,\n\t[GRE_CT_REPLIED]\t= 180*HZ,\n};\n\n \nstatic DEFINE_SPINLOCK(keymap_lock);\n\nstatic inline struct nf_gre_net *gre_pernet(struct net *net)\n{\n\treturn &net->ct.nf_ct_proto.gre;\n}\n\nstatic inline int gre_key_cmpfn(const struct nf_ct_gre_keymap *km,\n\t\t\t\tconst struct nf_conntrack_tuple *t)\n{\n\treturn km->tuple.src.l3num == t->src.l3num &&\n\t       !memcmp(&km->tuple.src.u3, &t->src.u3, sizeof(t->src.u3)) &&\n\t       !memcmp(&km->tuple.dst.u3, &t->dst.u3, sizeof(t->dst.u3)) &&\n\t       km->tuple.dst.protonum == t->dst.protonum &&\n\t       km->tuple.dst.u.all == t->dst.u.all;\n}\n\n \nstatic __be16 gre_keymap_lookup(struct net *net, struct nf_conntrack_tuple *t)\n{\n\tstruct nf_gre_net *net_gre = gre_pernet(net);\n\tstruct nf_ct_gre_keymap *km;\n\t__be16 key = 0;\n\n\tlist_for_each_entry_rcu(km, &net_gre->keymap_list, list) {\n\t\tif (gre_key_cmpfn(km, t)) {\n\t\t\tkey = km->tuple.src.u.gre.key;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpr_debug(\"lookup src key 0x%x for \", key);\n\tnf_ct_dump_tuple(t);\n\n\treturn key;\n}\n\n \nint nf_ct_gre_keymap_add(struct nf_conn *ct, enum ip_conntrack_dir dir,\n\t\t\t struct nf_conntrack_tuple *t)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct nf_gre_net *net_gre = gre_pernet(net);\n\tstruct nf_ct_pptp_master *ct_pptp_info = nfct_help_data(ct);\n\tstruct nf_ct_gre_keymap **kmp, *km;\n\n\tkmp = &ct_pptp_info->keymap[dir];\n\tif (*kmp) {\n\t\t \n\t\tlist_for_each_entry_rcu(km, &net_gre->keymap_list, list) {\n\t\t\tif (gre_key_cmpfn(km, t) && km == *kmp)\n\t\t\t\treturn 0;\n\t\t}\n\t\tpr_debug(\"trying to override keymap_%s for ct %p\\n\",\n\t\t\t dir == IP_CT_DIR_REPLY ? \"reply\" : \"orig\", ct);\n\t\treturn -EEXIST;\n\t}\n\n\tkm = kmalloc(sizeof(*km), GFP_ATOMIC);\n\tif (!km)\n\t\treturn -ENOMEM;\n\tmemcpy(&km->tuple, t, sizeof(*t));\n\t*kmp = km;\n\n\tpr_debug(\"adding new entry %p: \", km);\n\tnf_ct_dump_tuple(&km->tuple);\n\n\tspin_lock_bh(&keymap_lock);\n\tlist_add_tail(&km->list, &net_gre->keymap_list);\n\tspin_unlock_bh(&keymap_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_ct_gre_keymap_add);\n\n \nvoid nf_ct_gre_keymap_destroy(struct nf_conn *ct)\n{\n\tstruct nf_ct_pptp_master *ct_pptp_info = nfct_help_data(ct);\n\tenum ip_conntrack_dir dir;\n\n\tpr_debug(\"entering for ct %p\\n\", ct);\n\n\tspin_lock_bh(&keymap_lock);\n\tfor (dir = IP_CT_DIR_ORIGINAL; dir < IP_CT_DIR_MAX; dir++) {\n\t\tif (ct_pptp_info->keymap[dir]) {\n\t\t\tpr_debug(\"removing %p from list\\n\",\n\t\t\t\t ct_pptp_info->keymap[dir]);\n\t\t\tlist_del_rcu(&ct_pptp_info->keymap[dir]->list);\n\t\t\tkfree_rcu(ct_pptp_info->keymap[dir], rcu);\n\t\t\tct_pptp_info->keymap[dir] = NULL;\n\t\t}\n\t}\n\tspin_unlock_bh(&keymap_lock);\n}\nEXPORT_SYMBOL_GPL(nf_ct_gre_keymap_destroy);\n\n \n\n \nbool gre_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\n\t\t      struct net *net, struct nf_conntrack_tuple *tuple)\n{\n\tconst struct pptp_gre_header *pgrehdr;\n\tstruct pptp_gre_header _pgrehdr;\n\t__be16 srckey;\n\tconst struct gre_base_hdr *grehdr;\n\tstruct gre_base_hdr _grehdr;\n\n\t \n\tgrehdr = skb_header_pointer(skb, dataoff, sizeof(_grehdr), &_grehdr);\n\tif (!grehdr || (grehdr->flags & GRE_VERSION) != GRE_VERSION_1) {\n\t\t \n\t\ttuple->src.u.all = 0;\n\t\ttuple->dst.u.all = 0;\n\t\treturn true;\n\t}\n\n\t \n\tpgrehdr = skb_header_pointer(skb, dataoff, 8, &_pgrehdr);\n\tif (!pgrehdr)\n\t\treturn true;\n\n\tif (grehdr->protocol != GRE_PROTO_PPP) {\n\t\tpr_debug(\"Unsupported GRE proto(0x%x)\\n\", ntohs(grehdr->protocol));\n\t\treturn false;\n\t}\n\n\ttuple->dst.u.gre.key = pgrehdr->call_id;\n\tsrckey = gre_keymap_lookup(net, tuple);\n\ttuple->src.u.gre.key = srckey;\n\n\treturn true;\n}\n\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\n \nstatic void gre_print_conntrack(struct seq_file *s, struct nf_conn *ct)\n{\n\tseq_printf(s, \"timeout=%u, stream_timeout=%u \",\n\t\t   (ct->proto.gre.timeout / HZ),\n\t\t   (ct->proto.gre.stream_timeout / HZ));\n}\n#endif\n\nstatic unsigned int *gre_get_timeouts(struct net *net)\n{\n\treturn gre_pernet(net)->timeouts;\n}\n\n \nint nf_conntrack_gre_packet(struct nf_conn *ct,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    unsigned int dataoff,\n\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t    const struct nf_hook_state *state)\n{\n\tunsigned long status;\n\n\tif (!nf_ct_is_confirmed(ct)) {\n\t\tunsigned int *timeouts = nf_ct_timeout_lookup(ct);\n\n\t\tif (!timeouts)\n\t\t\ttimeouts = gre_get_timeouts(nf_ct_net(ct));\n\n\t\t \n\t\tct->proto.gre.stream_timeout = timeouts[GRE_CT_REPLIED];\n\t\tct->proto.gre.timeout = timeouts[GRE_CT_UNREPLIED];\n\t}\n\n\tstatus = READ_ONCE(ct->status);\n\t \n\tif (status & IPS_SEEN_REPLY) {\n\t\tnf_ct_refresh_acct(ct, ctinfo, skb,\n\t\t\t\t   ct->proto.gre.stream_timeout);\n\n\t\t \n\t\tif (unlikely((status & IPS_NAT_CLASH)))\n\t\t\treturn NF_ACCEPT;\n\n\t\t \n\t\tif (!test_and_set_bit(IPS_ASSURED_BIT, &ct->status))\n\t\t\tnf_conntrack_event_cache(IPCT_ASSURED, ct);\n\t} else\n\t\tnf_ct_refresh_acct(ct, ctinfo, skb,\n\t\t\t\t   ct->proto.gre.timeout);\n\n\treturn NF_ACCEPT;\n}\n\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_cttimeout.h>\n\nstatic int gre_timeout_nlattr_to_obj(struct nlattr *tb[],\n\t\t\t\t     struct net *net, void *data)\n{\n\tunsigned int *timeouts = data;\n\tstruct nf_gre_net *net_gre = gre_pernet(net);\n\n\tif (!timeouts)\n\t\ttimeouts = gre_get_timeouts(net);\n\t \n\ttimeouts[GRE_CT_UNREPLIED] = net_gre->timeouts[GRE_CT_UNREPLIED];\n\ttimeouts[GRE_CT_REPLIED] = net_gre->timeouts[GRE_CT_REPLIED];\n\n\tif (tb[CTA_TIMEOUT_GRE_UNREPLIED]) {\n\t\ttimeouts[GRE_CT_UNREPLIED] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_GRE_UNREPLIED])) * HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_GRE_REPLIED]) {\n\t\ttimeouts[GRE_CT_REPLIED] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_GRE_REPLIED])) * HZ;\n\t}\n\treturn 0;\n}\n\nstatic int\ngre_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\n{\n\tconst unsigned int *timeouts = data;\n\n\tif (nla_put_be32(skb, CTA_TIMEOUT_GRE_UNREPLIED,\n\t\t\t htonl(timeouts[GRE_CT_UNREPLIED] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_GRE_REPLIED,\n\t\t\t htonl(timeouts[GRE_CT_REPLIED] / HZ)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic const struct nla_policy\ngre_timeout_nla_policy[CTA_TIMEOUT_GRE_MAX+1] = {\n\t[CTA_TIMEOUT_GRE_UNREPLIED]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_GRE_REPLIED]\t= { .type = NLA_U32 },\n};\n#endif  \n\nvoid nf_conntrack_gre_init_net(struct net *net)\n{\n\tstruct nf_gre_net *net_gre = gre_pernet(net);\n\tint i;\n\n\tINIT_LIST_HEAD(&net_gre->keymap_list);\n\tfor (i = 0; i < GRE_CT_MAX; i++)\n\t\tnet_gre->timeouts[i] = gre_timeouts[i];\n}\n\n \nconst struct nf_conntrack_l4proto nf_conntrack_l4proto_gre = {\n\t.l4proto\t = IPPROTO_GRE,\n\t.allow_clash\t = true,\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\n\t.print_conntrack = gre_print_conntrack,\n#endif\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.tuple_to_nlattr = nf_ct_port_tuple_to_nlattr,\n\t.nlattr_tuple_size = nf_ct_port_nlattr_tuple_size,\n\t.nlattr_to_tuple = nf_ct_port_nlattr_to_tuple,\n\t.nla_policy\t = nf_ct_port_nla_policy,\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\t.ctnl_timeout    = {\n\t\t.nlattr_to_obj\t= gre_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= gre_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_GRE_MAX,\n\t\t.obj_size\t= sizeof(unsigned int) * GRE_CT_MAX,\n\t\t.nla_policy\t= gre_timeout_nla_policy,\n\t},\n#endif  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}