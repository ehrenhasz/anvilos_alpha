{
  "module_name": "nf_conntrack_amanda.c",
  "hash_id": "ce84d9c762b030614e50d1da9341f2930f922bd4c82e21250e3648cd3fb2ab6f",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_amanda.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/textsearch.h>\n#include <linux/skbuff.h>\n#include <linux/in.h>\n#include <linux/udp.h>\n#include <linux/netfilter.h>\n#include <linux/gfp.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <linux/netfilter/nf_conntrack_amanda.h>\n\nstatic unsigned int master_timeout __read_mostly = 300;\nstatic char *ts_algo = \"kmp\";\n\n#define HELPER_NAME \"amanda\"\n\nMODULE_AUTHOR(\"Brian J. Murrell <netfilter@interlinx.bc.ca>\");\nMODULE_DESCRIPTION(\"Amanda connection tracking module\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ip_conntrack_amanda\");\nMODULE_ALIAS_NFCT_HELPER(HELPER_NAME);\n\nmodule_param(master_timeout, uint, 0600);\nMODULE_PARM_DESC(master_timeout, \"timeout for the master connection\");\nmodule_param(ts_algo, charp, 0400);\nMODULE_PARM_DESC(ts_algo, \"textsearch algorithm to use (default kmp)\");\n\nunsigned int (*nf_nat_amanda_hook)(struct sk_buff *skb,\n\t\t\t\t   enum ip_conntrack_info ctinfo,\n\t\t\t\t   unsigned int protoff,\n\t\t\t\t   unsigned int matchoff,\n\t\t\t\t   unsigned int matchlen,\n\t\t\t\t   struct nf_conntrack_expect *exp)\n\t\t\t\t   __read_mostly;\nEXPORT_SYMBOL_GPL(nf_nat_amanda_hook);\n\nenum amanda_strings {\n\tSEARCH_CONNECT,\n\tSEARCH_NEWLINE,\n\tSEARCH_DATA,\n\tSEARCH_MESG,\n\tSEARCH_INDEX,\n\tSEARCH_STATE,\n};\n\nstatic struct {\n\tconst char\t\t*string;\n\tsize_t\t\t\tlen;\n\tstruct ts_config\t*ts;\n} search[] __read_mostly = {\n\t[SEARCH_CONNECT] = {\n\t\t.string\t= \"CONNECT \",\n\t\t.len\t= 8,\n\t},\n\t[SEARCH_NEWLINE] = {\n\t\t.string\t= \"\\n\",\n\t\t.len\t= 1,\n\t},\n\t[SEARCH_DATA] = {\n\t\t.string\t= \"DATA \",\n\t\t.len\t= 5,\n\t},\n\t[SEARCH_MESG] = {\n\t\t.string\t= \"MESG \",\n\t\t.len\t= 5,\n\t},\n\t[SEARCH_INDEX] = {\n\t\t.string = \"INDEX \",\n\t\t.len\t= 6,\n\t},\n\t[SEARCH_STATE] = {\n\t\t.string = \"STATE \",\n\t\t.len\t= 6,\n\t},\n};\n\nstatic int amanda_help(struct sk_buff *skb,\n\t\t       unsigned int protoff,\n\t\t       struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo)\n{\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conntrack_tuple *tuple;\n\tunsigned int dataoff, start, stop, off, i;\n\tchar pbuf[sizeof(\"65535\")], *tmp;\n\tu_int16_t len;\n\t__be16 port;\n\tint ret = NF_ACCEPT;\n\ttypeof(nf_nat_amanda_hook) nf_nat_amanda;\n\n\t \n\tif (CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL)\n\t\treturn NF_ACCEPT;\n\n\t \n\tnf_ct_refresh(ct, skb, master_timeout * HZ);\n\n\t \n\tdataoff = protoff + sizeof(struct udphdr);\n\tif (dataoff >= skb->len) {\n\t\tnet_err_ratelimited(\"amanda_help: skblen = %u\\n\", skb->len);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tstart = skb_find_text(skb, dataoff, skb->len,\n\t\t\t      search[SEARCH_CONNECT].ts);\n\tif (start == UINT_MAX)\n\t\tgoto out;\n\tstart += dataoff + search[SEARCH_CONNECT].len;\n\n\tstop = skb_find_text(skb, start, skb->len,\n\t\t\t     search[SEARCH_NEWLINE].ts);\n\tif (stop == UINT_MAX)\n\t\tgoto out;\n\tstop += start;\n\n\tfor (i = SEARCH_DATA; i <= SEARCH_STATE; i++) {\n\t\toff = skb_find_text(skb, start, stop, search[i].ts);\n\t\tif (off == UINT_MAX)\n\t\t\tcontinue;\n\t\toff += start + search[i].len;\n\n\t\tlen = min_t(unsigned int, sizeof(pbuf) - 1, stop - off);\n\t\tif (skb_copy_bits(skb, off, pbuf, len))\n\t\t\tbreak;\n\t\tpbuf[len] = '\\0';\n\n\t\tport = htons(simple_strtoul(pbuf, &tmp, 10));\n\t\tlen = tmp - pbuf;\n\t\tif (port == 0 || len > 5)\n\t\t\tbreak;\n\n\t\texp = nf_ct_expect_alloc(ct);\n\t\tif (exp == NULL) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot alloc expectation\");\n\t\t\tret = NF_DROP;\n\t\t\tgoto out;\n\t\t}\n\t\ttuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\t\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT,\n\t\t\t\t  nf_ct_l3num(ct),\n\t\t\t\t  &tuple->src.u3, &tuple->dst.u3,\n\t\t\t\t  IPPROTO_TCP, NULL, &port);\n\n\t\tnf_nat_amanda = rcu_dereference(nf_nat_amanda_hook);\n\t\tif (nf_nat_amanda && ct->status & IPS_NAT_MASK)\n\t\t\tret = nf_nat_amanda(skb, ctinfo, protoff,\n\t\t\t\t\t    off - dataoff, len, exp);\n\t\telse if (nf_ct_expect_related(exp, 0) != 0) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot add expectation\");\n\t\t\tret = NF_DROP;\n\t\t}\n\t\tnf_ct_expect_put(exp);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic const struct nf_conntrack_expect_policy amanda_exp_policy = {\n\t.max_expected\t\t= 4,\n\t.timeout\t\t= 180,\n};\n\nstatic struct nf_conntrack_helper amanda_helper[2] __read_mostly = {\n\t{\n\t\t.name\t\t\t= HELPER_NAME,\n\t\t.me\t\t\t= THIS_MODULE,\n\t\t.help\t\t\t= amanda_help,\n\t\t.tuple.src.l3num\t= AF_INET,\n\t\t.tuple.src.u.udp.port\t= cpu_to_be16(10080),\n\t\t.tuple.dst.protonum\t= IPPROTO_UDP,\n\t\t.expect_policy\t\t= &amanda_exp_policy,\n\t\t.nat_mod_name\t\t= NF_NAT_HELPER_NAME(HELPER_NAME),\n\t},\n\t{\n\t\t.name\t\t\t= \"amanda\",\n\t\t.me\t\t\t= THIS_MODULE,\n\t\t.help\t\t\t= amanda_help,\n\t\t.tuple.src.l3num\t= AF_INET6,\n\t\t.tuple.src.u.udp.port\t= cpu_to_be16(10080),\n\t\t.tuple.dst.protonum\t= IPPROTO_UDP,\n\t\t.expect_policy\t\t= &amanda_exp_policy,\n\t\t.nat_mod_name\t\t= NF_NAT_HELPER_NAME(HELPER_NAME),\n\t},\n};\n\nstatic void __exit nf_conntrack_amanda_fini(void)\n{\n\tint i;\n\n\tnf_conntrack_helpers_unregister(amanda_helper,\n\t\t\t\t\tARRAY_SIZE(amanda_helper));\n\tfor (i = 0; i < ARRAY_SIZE(search); i++)\n\t\ttextsearch_destroy(search[i].ts);\n}\n\nstatic int __init nf_conntrack_amanda_init(void)\n{\n\tint ret, i;\n\n\tNF_CT_HELPER_BUILD_BUG_ON(0);\n\n\tfor (i = 0; i < ARRAY_SIZE(search); i++) {\n\t\tsearch[i].ts = textsearch_prepare(ts_algo, search[i].string,\n\t\t\t\t\t\t  search[i].len,\n\t\t\t\t\t\t  GFP_KERNEL, TS_AUTOLOAD);\n\t\tif (IS_ERR(search[i].ts)) {\n\t\t\tret = PTR_ERR(search[i].ts);\n\t\t\tgoto err1;\n\t\t}\n\t}\n\tret = nf_conntrack_helpers_register(amanda_helper,\n\t\t\t\t\t    ARRAY_SIZE(amanda_helper));\n\tif (ret < 0)\n\t\tgoto err1;\n\treturn 0;\n\nerr1:\n\twhile (--i >= 0)\n\t\ttextsearch_destroy(search[i].ts);\n\n\treturn ret;\n}\n\nmodule_init(nf_conntrack_amanda_init);\nmodule_exit(nf_conntrack_amanda_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}