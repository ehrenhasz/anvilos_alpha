{
  "module_name": "nf_dup_netdev.c",
  "hash_id": "e4c7180827784682d28b757852255bcc80c48def6de1fb5417891d75c6f17828",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_dup_netdev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_offload.h>\n#include <net/netfilter/nf_dup_netdev.h>\n\n#define NF_RECURSION_LIMIT\t2\n\nstatic DEFINE_PER_CPU(u8, nf_dup_skb_recursion);\n\nstatic void nf_do_netdev_egress(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\tenum nf_dev_hooks hook)\n{\n\tif (__this_cpu_read(nf_dup_skb_recursion) > NF_RECURSION_LIMIT)\n\t\tgoto err;\n\n\tif (hook == NF_NETDEV_INGRESS && skb_mac_header_was_set(skb)) {\n\t\tif (skb_cow_head(skb, skb->mac_len))\n\t\t\tgoto err;\n\n\t\tskb_push(skb, skb->mac_len);\n\t}\n\n\tskb->dev = dev;\n\tskb_clear_tstamp(skb);\n\t__this_cpu_inc(nf_dup_skb_recursion);\n\tdev_queue_xmit(skb);\n\t__this_cpu_dec(nf_dup_skb_recursion);\n\treturn;\nerr:\n\tkfree_skb(skb);\n}\n\nvoid nf_fwd_netdev_egress(const struct nft_pktinfo *pkt, int oif)\n{\n\tstruct net_device *dev;\n\n\tdev = dev_get_by_index_rcu(nft_net(pkt), oif);\n\tif (!dev) {\n\t\tkfree_skb(pkt->skb);\n\t\treturn;\n\t}\n\n\tnf_do_netdev_egress(pkt->skb, dev, nft_hook(pkt));\n}\nEXPORT_SYMBOL_GPL(nf_fwd_netdev_egress);\n\nvoid nf_dup_netdev_egress(const struct nft_pktinfo *pkt, int oif)\n{\n\tstruct net_device *dev;\n\tstruct sk_buff *skb;\n\n\tdev = dev_get_by_index_rcu(nft_net(pkt), oif);\n\tif (dev == NULL)\n\t\treturn;\n\n\tskb = skb_clone(pkt->skb, GFP_ATOMIC);\n\tif (skb)\n\t\tnf_do_netdev_egress(skb, dev, nft_hook(pkt));\n}\nEXPORT_SYMBOL_GPL(nf_dup_netdev_egress);\n\nint nft_fwd_dup_netdev_offload(struct nft_offload_ctx *ctx,\n\t\t\t       struct nft_flow_rule *flow,\n\t\t\t       enum flow_action_id id, int oif)\n{\n\tstruct flow_action_entry *entry;\n\tstruct net_device *dev;\n\n\t \n\tdev = dev_get_by_index(ctx->net, oif);\n\tif (!dev)\n\t\treturn -EOPNOTSUPP;\n\n\tentry = &flow->rule->action.entries[ctx->num_actions++];\n\tentry->id = id;\n\tentry->dev = dev;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_fwd_dup_netdev_offload);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_DESCRIPTION(\"Netfilter packet duplication support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}