{
  "module_name": "xt_addrtype.c",
  "hash_id": "0f284efb6a0ffe50c731328930b819f41595498ba3243e16767f61e7329f1a31",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_addrtype.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/ip.h>\n#include <net/route.h>\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/ip6_fib.h>\n#endif\n\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter/xt_addrtype.h>\n#include <linux/netfilter/x_tables.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_DESCRIPTION(\"Xtables: address type match\");\nMODULE_ALIAS(\"ipt_addrtype\");\nMODULE_ALIAS(\"ip6t_addrtype\");\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nstatic u32 match_lookup_rt6(struct net *net, const struct net_device *dev,\n\t\t\t    const struct in6_addr *addr, u16 mask)\n{\n\tstruct flowi6 flow;\n\tstruct rt6_info *rt;\n\tu32 ret = 0;\n\tint route_err;\n\n\tmemset(&flow, 0, sizeof(flow));\n\tflow.daddr = *addr;\n\tif (dev)\n\t\tflow.flowi6_oif = dev->ifindex;\n\n\tif (dev && (mask & XT_ADDRTYPE_LOCAL)) {\n\t\tif (nf_ipv6_chk_addr(net, addr, dev, true))\n\t\t\tret = XT_ADDRTYPE_LOCAL;\n\t}\n\n\troute_err = nf_ip6_route(net, (struct dst_entry **)&rt,\n\t\t\t\t flowi6_to_flowi(&flow), false);\n\tif (route_err)\n\t\treturn XT_ADDRTYPE_UNREACHABLE;\n\n\tif (rt->rt6i_flags & RTF_REJECT)\n\t\tret = XT_ADDRTYPE_UNREACHABLE;\n\n\tif (dev == NULL && rt->rt6i_flags & RTF_LOCAL)\n\t\tret |= XT_ADDRTYPE_LOCAL;\n\tif (ipv6_anycast_destination((struct dst_entry *)rt, addr))\n\t\tret |= XT_ADDRTYPE_ANYCAST;\n\n\tdst_release(&rt->dst);\n\treturn ret;\n}\n\nstatic bool match_type6(struct net *net, const struct net_device *dev,\n\t\t\t\tconst struct in6_addr *addr, u16 mask)\n{\n\tint addr_type = ipv6_addr_type(addr);\n\n\tif ((mask & XT_ADDRTYPE_MULTICAST) &&\n\t    !(addr_type & IPV6_ADDR_MULTICAST))\n\t\treturn false;\n\tif ((mask & XT_ADDRTYPE_UNICAST) && !(addr_type & IPV6_ADDR_UNICAST))\n\t\treturn false;\n\tif ((mask & XT_ADDRTYPE_UNSPEC) && addr_type != IPV6_ADDR_ANY)\n\t\treturn false;\n\n\tif ((XT_ADDRTYPE_LOCAL | XT_ADDRTYPE_ANYCAST |\n\t     XT_ADDRTYPE_UNREACHABLE) & mask)\n\t\treturn !!(mask & match_lookup_rt6(net, dev, addr, mask));\n\treturn true;\n}\n\nstatic bool\naddrtype_mt6(struct net *net, const struct net_device *dev,\n\tconst struct sk_buff *skb, const struct xt_addrtype_info_v1 *info)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tbool ret = true;\n\n\tif (info->source)\n\t\tret &= match_type6(net, dev, &iph->saddr, info->source) ^\n\t\t       (info->flags & XT_ADDRTYPE_INVERT_SOURCE);\n\tif (ret && info->dest)\n\t\tret &= match_type6(net, dev, &iph->daddr, info->dest) ^\n\t\t       !!(info->flags & XT_ADDRTYPE_INVERT_DEST);\n\treturn ret;\n}\n#endif\n\nstatic inline bool match_type(struct net *net, const struct net_device *dev,\n\t\t\t      __be32 addr, u_int16_t mask)\n{\n\treturn !!(mask & (1 << inet_dev_addr_type(net, dev, addr)));\n}\n\nstatic bool\naddrtype_mt_v0(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tstruct net *net = xt_net(par);\n\tconst struct xt_addrtype_info *info = par->matchinfo;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tbool ret = true;\n\n\tif (info->source)\n\t\tret &= match_type(net, NULL, iph->saddr, info->source) ^\n\t\t       info->invert_source;\n\tif (info->dest)\n\t\tret &= match_type(net, NULL, iph->daddr, info->dest) ^\n\t\t       info->invert_dest;\n\n\treturn ret;\n}\n\nstatic bool\naddrtype_mt_v1(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tstruct net *net = xt_net(par);\n\tconst struct xt_addrtype_info_v1 *info = par->matchinfo;\n\tconst struct iphdr *iph;\n\tconst struct net_device *dev = NULL;\n\tbool ret = true;\n\n\tif (info->flags & XT_ADDRTYPE_LIMIT_IFACE_IN)\n\t\tdev = xt_in(par);\n\telse if (info->flags & XT_ADDRTYPE_LIMIT_IFACE_OUT)\n\t\tdev = xt_out(par);\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\tif (xt_family(par) == NFPROTO_IPV6)\n\t\treturn addrtype_mt6(net, dev, skb, info);\n#endif\n\tiph = ip_hdr(skb);\n\tif (info->source)\n\t\tret &= match_type(net, dev, iph->saddr, info->source) ^\n\t\t       (info->flags & XT_ADDRTYPE_INVERT_SOURCE);\n\tif (ret && info->dest)\n\t\tret &= match_type(net, dev, iph->daddr, info->dest) ^\n\t\t       !!(info->flags & XT_ADDRTYPE_INVERT_DEST);\n\treturn ret;\n}\n\nstatic int addrtype_mt_checkentry_v1(const struct xt_mtchk_param *par)\n{\n\tconst char *errmsg = \"both incoming and outgoing interface limitation cannot be selected\";\n\tstruct xt_addrtype_info_v1 *info = par->matchinfo;\n\n\tif (info->flags & XT_ADDRTYPE_LIMIT_IFACE_IN &&\n\t    info->flags & XT_ADDRTYPE_LIMIT_IFACE_OUT)\n\t\tgoto err;\n\n\tif (par->hook_mask & ((1 << NF_INET_PRE_ROUTING) |\n\t    (1 << NF_INET_LOCAL_IN)) &&\n\t    info->flags & XT_ADDRTYPE_LIMIT_IFACE_OUT) {\n\t\terrmsg = \"output interface limitation not valid in PREROUTING and INPUT\";\n\t\tgoto err;\n\t}\n\n\tif (par->hook_mask & ((1 << NF_INET_POST_ROUTING) |\n\t    (1 << NF_INET_LOCAL_OUT)) &&\n\t    info->flags & XT_ADDRTYPE_LIMIT_IFACE_IN) {\n\t\terrmsg = \"input interface limitation not valid in POSTROUTING and OUTPUT\";\n\t\tgoto err;\n\t}\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\tif (par->family == NFPROTO_IPV6) {\n\t\tif ((info->source | info->dest) & XT_ADDRTYPE_BLACKHOLE) {\n\t\t\terrmsg = \"ipv6 BLACKHOLE matching not supported\";\n\t\t\tgoto err;\n\t\t}\n\t\tif ((info->source | info->dest) >= XT_ADDRTYPE_PROHIBIT) {\n\t\t\terrmsg = \"ipv6 PROHIBIT (THROW, NAT ..) matching not supported\";\n\t\t\tgoto err;\n\t\t}\n\t\tif ((info->source | info->dest) & XT_ADDRTYPE_BROADCAST) {\n\t\t\terrmsg = \"ipv6 does not support BROADCAST matching\";\n\t\t\tgoto err;\n\t\t}\n\t}\n#endif\n\treturn 0;\nerr:\n\tpr_info_ratelimited(\"%s\\n\", errmsg);\n\treturn -EINVAL;\n}\n\nstatic struct xt_match addrtype_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"addrtype\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.match\t\t= addrtype_mt_v0,\n\t\t.matchsize\t= sizeof(struct xt_addrtype_info),\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"addrtype\",\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.revision\t= 1,\n\t\t.match\t\t= addrtype_mt_v1,\n\t\t.checkentry\t= addrtype_mt_checkentry_v1,\n\t\t.matchsize\t= sizeof(struct xt_addrtype_info_v1),\n\t\t.me\t\t= THIS_MODULE\n\t}\n};\n\nstatic int __init addrtype_mt_init(void)\n{\n\treturn xt_register_matches(addrtype_mt_reg,\n\t\t\t\t   ARRAY_SIZE(addrtype_mt_reg));\n}\n\nstatic void __exit addrtype_mt_exit(void)\n{\n\txt_unregister_matches(addrtype_mt_reg, ARRAY_SIZE(addrtype_mt_reg));\n}\n\nmodule_init(addrtype_mt_init);\nmodule_exit(addrtype_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}