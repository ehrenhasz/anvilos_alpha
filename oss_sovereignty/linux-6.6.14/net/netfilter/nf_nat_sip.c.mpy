{
  "module_name": "nf_nat_sip.c",
  "hash_id": "7b2ace17114ceef3dd420ae4068adc306803ac127f79fe6ce8d6e5c3aa386c69",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_nat_sip.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/inet.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_nat_helper.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <linux/netfilter/nf_conntrack_sip.h>\n\n#define NAT_HELPER_NAME \"sip\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Christian Hentschel <chentschel@arnet.com.ar>\");\nMODULE_DESCRIPTION(\"SIP NAT helper\");\nMODULE_ALIAS_NF_NAT_HELPER(NAT_HELPER_NAME);\n\nstatic struct nf_conntrack_nat_helper nat_helper_sip =\n\tNF_CT_NAT_HELPER_INIT(NAT_HELPER_NAME);\n\nstatic unsigned int mangle_packet(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t  unsigned int dataoff,\n\t\t\t\t  const char **dptr, unsigned int *datalen,\n\t\t\t\t  unsigned int matchoff, unsigned int matchlen,\n\t\t\t\t  const char *buffer, unsigned int buflen)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct tcphdr *th;\n\tunsigned int baseoff;\n\n\tif (nf_ct_protonum(ct) == IPPROTO_TCP) {\n\t\tth = (struct tcphdr *)(skb->data + protoff);\n\t\tbaseoff = protoff + th->doff * 4;\n\t\tmatchoff += dataoff - baseoff;\n\n\t\tif (!__nf_nat_mangle_tcp_packet(skb, ct, ctinfo,\n\t\t\t\t\t\tprotoff, matchoff, matchlen,\n\t\t\t\t\t\tbuffer, buflen, false))\n\t\t\treturn 0;\n\t} else {\n\t\tbaseoff = protoff + sizeof(struct udphdr);\n\t\tmatchoff += dataoff - baseoff;\n\n\t\tif (!nf_nat_mangle_udp_packet(skb, ct, ctinfo,\n\t\t\t\t\t      protoff, matchoff, matchlen,\n\t\t\t\t\t      buffer, buflen))\n\t\t\treturn 0;\n\t}\n\n\t \n\t*dptr = skb->data + dataoff;\n\t*datalen += buflen - matchlen;\n\treturn 1;\n}\n\nstatic int sip_sprintf_addr(const struct nf_conn *ct, char *buffer,\n\t\t\t    const union nf_inet_addr *addr, bool delim)\n{\n\tif (nf_ct_l3num(ct) == NFPROTO_IPV4)\n\t\treturn sprintf(buffer, \"%pI4\", &addr->ip);\n\telse {\n\t\tif (delim)\n\t\t\treturn sprintf(buffer, \"[%pI6c]\", &addr->ip6);\n\t\telse\n\t\t\treturn sprintf(buffer, \"%pI6c\", &addr->ip6);\n\t}\n}\n\nstatic int sip_sprintf_addr_port(const struct nf_conn *ct, char *buffer,\n\t\t\t\t const union nf_inet_addr *addr, u16 port)\n{\n\tif (nf_ct_l3num(ct) == NFPROTO_IPV4)\n\t\treturn sprintf(buffer, \"%pI4:%u\", &addr->ip, port);\n\telse\n\t\treturn sprintf(buffer, \"[%pI6c]:%u\", &addr->ip6, port);\n}\n\nstatic int map_addr(struct sk_buff *skb, unsigned int protoff,\n\t\t    unsigned int dataoff,\n\t\t    const char **dptr, unsigned int *datalen,\n\t\t    unsigned int matchoff, unsigned int matchlen,\n\t\t    union nf_inet_addr *addr, __be16 port)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\tchar buffer[INET6_ADDRSTRLEN + sizeof(\"[]:nnnnn\")];\n\tunsigned int buflen;\n\tunion nf_inet_addr newaddr;\n\t__be16 newport;\n\n\tif (nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.src.u3, addr) &&\n\t    ct->tuplehash[dir].tuple.src.u.udp.port == port) {\n\t\tnewaddr = ct->tuplehash[!dir].tuple.dst.u3;\n\t\tnewport = ct->tuplehash[!dir].tuple.dst.u.udp.port;\n\t} else if (nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.dst.u3, addr) &&\n\t\t   ct->tuplehash[dir].tuple.dst.u.udp.port == port) {\n\t\tnewaddr = ct->tuplehash[!dir].tuple.src.u3;\n\t\tnewport = ct_sip_info->forced_dport ? :\n\t\t\t  ct->tuplehash[!dir].tuple.src.u.udp.port;\n\t} else\n\t\treturn 1;\n\n\tif (nf_inet_addr_cmp(&newaddr, addr) && newport == port)\n\t\treturn 1;\n\n\tbuflen = sip_sprintf_addr_port(ct, buffer, &newaddr, ntohs(newport));\n\treturn mangle_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t     matchoff, matchlen, buffer, buflen);\n}\n\nstatic int map_sip_addr(struct sk_buff *skb, unsigned int protoff,\n\t\t\tunsigned int dataoff,\n\t\t\tconst char **dptr, unsigned int *datalen,\n\t\t\tenum sip_header_types type)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tunsigned int matchlen, matchoff;\n\tunion nf_inet_addr addr;\n\t__be16 port;\n\n\tif (ct_sip_parse_header_uri(ct, *dptr, NULL, *datalen, type, NULL,\n\t\t\t\t    &matchoff, &matchlen, &addr, &port) <= 0)\n\t\treturn 1;\n\treturn map_addr(skb, protoff, dataoff, dptr, datalen,\n\t\t\tmatchoff, matchlen, &addr, port);\n}\n\nstatic unsigned int nf_nat_sip(struct sk_buff *skb, unsigned int protoff,\n\t\t\t       unsigned int dataoff,\n\t\t\t       const char **dptr, unsigned int *datalen)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\tunsigned int coff, matchoff, matchlen;\n\tenum sip_header_types hdr;\n\tunion nf_inet_addr addr;\n\t__be16 port;\n\tint request, in_header;\n\n\t \n\tif (strncasecmp(*dptr, \"SIP/2.0\", strlen(\"SIP/2.0\")) != 0) {\n\t\tif (ct_sip_parse_request(ct, *dptr, *datalen,\n\t\t\t\t\t &matchoff, &matchlen,\n\t\t\t\t\t &addr, &port) > 0 &&\n\t\t    !map_addr(skb, protoff, dataoff, dptr, datalen,\n\t\t\t      matchoff, matchlen, &addr, port)) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot mangle SIP message\");\n\t\t\treturn NF_DROP;\n\t\t}\n\t\trequest = 1;\n\t} else\n\t\trequest = 0;\n\n\tif (nf_ct_protonum(ct) == IPPROTO_TCP)\n\t\thdr = SIP_HDR_VIA_TCP;\n\telse\n\t\thdr = SIP_HDR_VIA_UDP;\n\n\t \n\tif (ct_sip_parse_header_uri(ct, *dptr, NULL, *datalen,\n\t\t\t\t    hdr, NULL, &matchoff, &matchlen,\n\t\t\t\t    &addr, &port) > 0) {\n\t\tunsigned int olen, matchend, poff, plen, buflen, n;\n\t\tchar buffer[INET6_ADDRSTRLEN + sizeof(\"[]:nnnnn\")];\n\n\t\t \n\t\tif (request) {\n\t\t\tif (!nf_inet_addr_cmp(&addr,\n\t\t\t\t\t&ct->tuplehash[dir].tuple.src.u3) ||\n\t\t\t    port != ct->tuplehash[dir].tuple.src.u.udp.port)\n\t\t\t\tgoto next;\n\t\t} else {\n\t\t\tif (!nf_inet_addr_cmp(&addr,\n\t\t\t\t\t&ct->tuplehash[dir].tuple.dst.u3) ||\n\t\t\t    port != ct->tuplehash[dir].tuple.dst.u.udp.port)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tolen = *datalen;\n\t\tif (!map_addr(skb, protoff, dataoff, dptr, datalen,\n\t\t\t      matchoff, matchlen, &addr, port)) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot mangle Via header\");\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\tmatchend = matchoff + matchlen + *datalen - olen;\n\n\t\t \n\t\tif (ct_sip_parse_address_param(ct, *dptr, matchend, *datalen,\n\t\t\t\t\t       \"maddr=\", &poff, &plen,\n\t\t\t\t\t       &addr, true) > 0 &&\n\t\t    nf_inet_addr_cmp(&addr, &ct->tuplehash[dir].tuple.src.u3) &&\n\t\t    !nf_inet_addr_cmp(&addr, &ct->tuplehash[!dir].tuple.dst.u3)) {\n\t\t\tbuflen = sip_sprintf_addr(ct, buffer,\n\t\t\t\t\t&ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t\t\ttrue);\n\t\t\tif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t\t\t   poff, plen, buffer, buflen)) {\n\t\t\t\tnf_ct_helper_log(skb, ct, \"cannot mangle maddr\");\n\t\t\t\treturn NF_DROP;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ct_sip_parse_address_param(ct, *dptr, matchend, *datalen,\n\t\t\t\t\t       \"received=\", &poff, &plen,\n\t\t\t\t\t       &addr, false) > 0 &&\n\t\t    nf_inet_addr_cmp(&addr, &ct->tuplehash[dir].tuple.dst.u3) &&\n\t\t    !nf_inet_addr_cmp(&addr, &ct->tuplehash[!dir].tuple.src.u3)) {\n\t\t\tbuflen = sip_sprintf_addr(ct, buffer,\n\t\t\t\t\t&ct->tuplehash[!dir].tuple.src.u3,\n\t\t\t\t\tfalse);\n\t\t\tif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t\t\t   poff, plen, buffer, buflen)) {\n\t\t\t\tnf_ct_helper_log(skb, ct, \"cannot mangle received\");\n\t\t\t\treturn NF_DROP;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ct_sip_parse_numerical_param(ct, *dptr, matchend, *datalen,\n\t\t\t\t\t\t \"rport=\", &poff, &plen,\n\t\t\t\t\t\t &n) > 0 &&\n\t\t    htons(n) == ct->tuplehash[dir].tuple.dst.u.udp.port &&\n\t\t    htons(n) != ct->tuplehash[!dir].tuple.src.u.udp.port) {\n\t\t\t__be16 p = ct->tuplehash[!dir].tuple.src.u.udp.port;\n\t\t\tbuflen = sprintf(buffer, \"%u\", ntohs(p));\n\t\t\tif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t\t\t   poff, plen, buffer, buflen)) {\n\t\t\t\tnf_ct_helper_log(skb, ct, \"cannot mangle rport\");\n\t\t\t\treturn NF_DROP;\n\t\t\t}\n\t\t}\n\t}\n\nnext:\n\t \n\tcoff = 0;\n\tin_header = 0;\n\twhile (ct_sip_parse_header_uri(ct, *dptr, &coff, *datalen,\n\t\t\t\t       SIP_HDR_CONTACT, &in_header,\n\t\t\t\t       &matchoff, &matchlen,\n\t\t\t\t       &addr, &port) > 0) {\n\t\tif (!map_addr(skb, protoff, dataoff, dptr, datalen,\n\t\t\t      matchoff, matchlen,\n\t\t\t      &addr, port)) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot mangle contact\");\n\t\t\treturn NF_DROP;\n\t\t}\n\t}\n\n\tif (!map_sip_addr(skb, protoff, dataoff, dptr, datalen, SIP_HDR_FROM) ||\n\t    !map_sip_addr(skb, protoff, dataoff, dptr, datalen, SIP_HDR_TO)) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot mangle SIP from/to\");\n\t\treturn NF_DROP;\n\t}\n\n\t \n\tif (dir == IP_CT_DIR_REPLY && ct_sip_info->forced_dport) {\n\t\tstruct udphdr *uh;\n\n\t\tif (skb_ensure_writable(skb, skb->len)) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot mangle packet\");\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\tuh = (void *)skb->data + protoff;\n\t\tuh->dest = ct_sip_info->forced_dport;\n\n\t\tif (!nf_nat_mangle_udp_packet(skb, ct, ctinfo, protoff,\n\t\t\t\t\t      0, 0, NULL, 0)) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot mangle packet\");\n\t\t\treturn NF_DROP;\n\t\t}\n\t}\n\n\treturn NF_ACCEPT;\n}\n\nstatic void nf_nat_sip_seq_adjust(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t  s16 off)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tconst struct tcphdr *th;\n\n\tif (nf_ct_protonum(ct) != IPPROTO_TCP || off == 0)\n\t\treturn;\n\n\tth = (struct tcphdr *)(skb->data + protoff);\n\tnf_ct_seqadj_set(ct, ctinfo, th->seq, off);\n}\n\n \nstatic void nf_nat_sip_expected(struct nf_conn *ct,\n\t\t\t\tstruct nf_conntrack_expect *exp)\n{\n\tstruct nf_conn_help *help = nfct_help(ct->master);\n\tstruct nf_conntrack_expect *pair_exp;\n\tint range_set_for_snat = 0;\n\tstruct nf_nat_range2 range;\n\n\t \n\tBUG_ON(ct->status & IPS_NAT_DONE_MASK);\n\n\t \n\trange.flags = (NF_NAT_RANGE_MAP_IPS | NF_NAT_RANGE_PROTO_SPECIFIED);\n\trange.min_proto = range.max_proto = exp->saved_proto;\n\trange.min_addr = range.max_addr = exp->saved_addr;\n\tnf_nat_setup_info(ct, &range, NF_NAT_MANIP_DST);\n\n\t \n\tif (exp->class != SIP_EXPECT_SIGNALLING) {\n\t\tspin_lock_bh(&nf_conntrack_expect_lock);\n\t\thlist_for_each_entry(pair_exp, &help->expectations, lnode) {\n\t\t\tif (pair_exp->tuple.src.l3num == nf_ct_l3num(ct) &&\n\t\t\t    pair_exp->tuple.dst.protonum == ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum &&\n\t\t\t    nf_inet_addr_cmp(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3, &pair_exp->saved_addr) &&\n\t\t\t    ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all == pair_exp->saved_proto.all) {\n\t\t\t\trange.flags = (NF_NAT_RANGE_MAP_IPS | NF_NAT_RANGE_PROTO_SPECIFIED);\n\t\t\t\trange.min_proto.all = range.max_proto.all = pair_exp->tuple.dst.u.all;\n\t\t\t\trange.min_addr = range.max_addr = pair_exp->tuple.dst.u3;\n\t\t\t\trange_set_for_snat = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&nf_conntrack_expect_lock);\n\t}\n\n\t \n\tif (!range_set_for_snat &&\n\t    nf_inet_addr_cmp(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3,\n\t\t\t     &ct->master->tuplehash[exp->dir].tuple.src.u3)) {\n\t\trange.flags = NF_NAT_RANGE_MAP_IPS;\n\t\trange.min_addr = range.max_addr\n\t\t\t= ct->master->tuplehash[!exp->dir].tuple.dst.u3;\n\t\trange_set_for_snat = 1;\n\t}\n\n\t \n\tif (range_set_for_snat)\n\t\tnf_nat_setup_info(ct, &range, NF_NAT_MANIP_SRC);\n}\n\nstatic unsigned int nf_nat_sip_expect(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t      unsigned int dataoff,\n\t\t\t\t      const char **dptr, unsigned int *datalen,\n\t\t\t\t      struct nf_conntrack_expect *exp,\n\t\t\t\t      unsigned int matchoff,\n\t\t\t\t      unsigned int matchlen)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\tunion nf_inet_addr newaddr;\n\tu_int16_t port;\n\t__be16 srcport;\n\tchar buffer[INET6_ADDRSTRLEN + sizeof(\"[]:nnnnn\")];\n\tunsigned int buflen;\n\n\t \n\tif (nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.src.u3,\n\t\t\t     &ct->tuplehash[!dir].tuple.dst.u3))\n\t\tnewaddr = exp->tuple.dst.u3;\n\telse\n\t\tnewaddr = ct->tuplehash[!dir].tuple.dst.u3;\n\n\t \n\tsrcport = ct_sip_info->forced_dport ? :\n\t\t  ct->tuplehash[dir].tuple.src.u.udp.port;\n\tif (exp->tuple.dst.u.udp.port == srcport)\n\t\tport = ntohs(ct->tuplehash[!dir].tuple.dst.u.udp.port);\n\telse\n\t\tport = ntohs(exp->tuple.dst.u.udp.port);\n\n\texp->saved_addr = exp->tuple.dst.u3;\n\texp->tuple.dst.u3 = newaddr;\n\texp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;\n\texp->dir = !dir;\n\texp->expectfn = nf_nat_sip_expected;\n\n\tport = nf_nat_exp_find_port(exp, port);\n\tif (port == 0) {\n\t\tnf_ct_helper_log(skb, ct, \"all ports in use for SIP\");\n\t\treturn NF_DROP;\n\t}\n\n\tif (!nf_inet_addr_cmp(&exp->tuple.dst.u3, &exp->saved_addr) ||\n\t    exp->tuple.dst.u.udp.port != exp->saved_proto.udp.port) {\n\t\tbuflen = sip_sprintf_addr_port(ct, buffer, &newaddr, port);\n\t\tif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t\t   matchoff, matchlen, buffer, buflen)) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot mangle packet\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\treturn NF_ACCEPT;\n\nerr:\n\tnf_ct_unexpect_related(exp);\n\treturn NF_DROP;\n}\n\nstatic int mangle_content_len(struct sk_buff *skb, unsigned int protoff,\n\t\t\t      unsigned int dataoff,\n\t\t\t      const char **dptr, unsigned int *datalen)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tunsigned int matchoff, matchlen;\n\tchar buffer[sizeof(\"65536\")];\n\tint buflen, c_len;\n\n\t \n\tif (ct_sip_get_sdp_header(ct, *dptr, 0, *datalen,\n\t\t\t\t  SDP_HDR_VERSION, SDP_HDR_UNSPEC,\n\t\t\t\t  &matchoff, &matchlen) <= 0)\n\t\treturn 0;\n\tc_len = *datalen - matchoff + strlen(\"v=\");\n\n\t \n\tif (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_CONTENT_LENGTH,\n\t\t\t      &matchoff, &matchlen) <= 0)\n\t\treturn 0;\n\n\tbuflen = sprintf(buffer, \"%u\", c_len);\n\treturn mangle_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t     matchoff, matchlen, buffer, buflen);\n}\n\nstatic int mangle_sdp_packet(struct sk_buff *skb, unsigned int protoff,\n\t\t\t     unsigned int dataoff,\n\t\t\t     const char **dptr, unsigned int *datalen,\n\t\t\t     unsigned int sdpoff,\n\t\t\t     enum sdp_header_types type,\n\t\t\t     enum sdp_header_types term,\n\t\t\t     char *buffer, int buflen)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tunsigned int matchlen, matchoff;\n\n\tif (ct_sip_get_sdp_header(ct, *dptr, sdpoff, *datalen, type, term,\n\t\t\t\t  &matchoff, &matchlen) <= 0)\n\t\treturn -ENOENT;\n\treturn mangle_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t     matchoff, matchlen, buffer, buflen) ? 0 : -EINVAL;\n}\n\nstatic unsigned int nf_nat_sdp_addr(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t    unsigned int dataoff,\n\t\t\t\t    const char **dptr, unsigned int *datalen,\n\t\t\t\t    unsigned int sdpoff,\n\t\t\t\t    enum sdp_header_types type,\n\t\t\t\t    enum sdp_header_types term,\n\t\t\t\t    const union nf_inet_addr *addr)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tchar buffer[INET6_ADDRSTRLEN];\n\tunsigned int buflen;\n\n\tbuflen = sip_sprintf_addr(ct, buffer, addr, false);\n\tif (mangle_sdp_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t      sdpoff, type, term, buffer, buflen))\n\t\treturn 0;\n\n\treturn mangle_content_len(skb, protoff, dataoff, dptr, datalen);\n}\n\nstatic unsigned int nf_nat_sdp_port(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t    unsigned int dataoff,\n\t\t\t\t    const char **dptr, unsigned int *datalen,\n\t\t\t\t    unsigned int matchoff,\n\t\t\t\t    unsigned int matchlen,\n\t\t\t\t    u_int16_t port)\n{\n\tchar buffer[sizeof(\"nnnnn\")];\n\tunsigned int buflen;\n\n\tbuflen = sprintf(buffer, \"%u\", port);\n\tif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\n\t\t\t   matchoff, matchlen, buffer, buflen))\n\t\treturn 0;\n\n\treturn mangle_content_len(skb, protoff, dataoff, dptr, datalen);\n}\n\nstatic unsigned int nf_nat_sdp_session(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t       unsigned int dataoff,\n\t\t\t\t       const char **dptr, unsigned int *datalen,\n\t\t\t\t       unsigned int sdpoff,\n\t\t\t\t       const union nf_inet_addr *addr)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tchar buffer[INET6_ADDRSTRLEN];\n\tunsigned int buflen;\n\n\t \n\tbuflen = sip_sprintf_addr(ct, buffer, addr, false);\n\tif (mangle_sdp_packet(skb, protoff, dataoff, dptr, datalen, sdpoff,\n\t\t\t      SDP_HDR_OWNER, SDP_HDR_MEDIA, buffer, buflen))\n\t\treturn 0;\n\n\tswitch (mangle_sdp_packet(skb, protoff, dataoff, dptr, datalen, sdpoff,\n\t\t\t\t  SDP_HDR_CONNECTION, SDP_HDR_MEDIA,\n\t\t\t\t  buffer, buflen)) {\n\tcase 0:\n\t \n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn mangle_content_len(skb, protoff, dataoff, dptr, datalen);\n}\n\n \nstatic unsigned int nf_nat_sdp_media(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t     unsigned int dataoff,\n\t\t\t\t     const char **dptr, unsigned int *datalen,\n\t\t\t\t     struct nf_conntrack_expect *rtp_exp,\n\t\t\t\t     struct nf_conntrack_expect *rtcp_exp,\n\t\t\t\t     unsigned int mediaoff,\n\t\t\t\t     unsigned int medialen,\n\t\t\t\t     union nf_inet_addr *rtp_addr)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tu_int16_t port;\n\n\t \n\tif (nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.src.u3,\n\t\t\t     &ct->tuplehash[!dir].tuple.dst.u3))\n\t\t*rtp_addr = rtp_exp->tuple.dst.u3;\n\telse\n\t\t*rtp_addr = ct->tuplehash[!dir].tuple.dst.u3;\n\n\trtp_exp->saved_addr = rtp_exp->tuple.dst.u3;\n\trtp_exp->tuple.dst.u3 = *rtp_addr;\n\trtp_exp->saved_proto.udp.port = rtp_exp->tuple.dst.u.udp.port;\n\trtp_exp->dir = !dir;\n\trtp_exp->expectfn = nf_nat_sip_expected;\n\n\trtcp_exp->saved_addr = rtcp_exp->tuple.dst.u3;\n\trtcp_exp->tuple.dst.u3 = *rtp_addr;\n\trtcp_exp->saved_proto.udp.port = rtcp_exp->tuple.dst.u.udp.port;\n\trtcp_exp->dir = !dir;\n\trtcp_exp->expectfn = nf_nat_sip_expected;\n\n\t \n\tfor (port = ntohs(rtp_exp->tuple.dst.u.udp.port);\n\t     port != 0; port += 2) {\n\t\tint ret;\n\n\t\trtp_exp->tuple.dst.u.udp.port = htons(port);\n\t\tret = nf_ct_expect_related(rtp_exp,\n\t\t\t\t\t   NF_CT_EXP_F_SKIP_MASTER);\n\t\tif (ret == -EBUSY)\n\t\t\tcontinue;\n\t\telse if (ret < 0) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n\t\trtcp_exp->tuple.dst.u.udp.port = htons(port + 1);\n\t\tret = nf_ct_expect_related(rtcp_exp,\n\t\t\t\t\t   NF_CT_EXP_F_SKIP_MASTER);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret == -EBUSY) {\n\t\t\tnf_ct_unexpect_related(rtp_exp);\n\t\t\tcontinue;\n\t\t} else if (ret < 0) {\n\t\t\tnf_ct_unexpect_related(rtp_exp);\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (port == 0) {\n\t\tnf_ct_helper_log(skb, ct, \"all ports in use for SDP media\");\n\t\tgoto err1;\n\t}\n\n\t \n\tif (rtp_exp->tuple.dst.u.udp.port != rtp_exp->saved_proto.udp.port &&\n\t    !nf_nat_sdp_port(skb, protoff, dataoff, dptr, datalen,\n\t\t\t     mediaoff, medialen, port)) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot mangle SDP message\");\n\t\tgoto err2;\n\t}\n\n\treturn NF_ACCEPT;\n\nerr2:\n\tnf_ct_unexpect_related(rtp_exp);\n\tnf_ct_unexpect_related(rtcp_exp);\nerr1:\n\treturn NF_DROP;\n}\n\nstatic struct nf_ct_helper_expectfn sip_nat = {\n\t.name\t\t= \"sip\",\n\t.expectfn\t= nf_nat_sip_expected,\n};\n\nstatic void __exit nf_nat_sip_fini(void)\n{\n\tnf_nat_helper_unregister(&nat_helper_sip);\n\tRCU_INIT_POINTER(nf_nat_sip_hooks, NULL);\n\tnf_ct_helper_expectfn_unregister(&sip_nat);\n\tsynchronize_rcu();\n}\n\nstatic const struct nf_nat_sip_hooks sip_hooks = {\n\t.msg\t\t= nf_nat_sip,\n\t.seq_adjust\t= nf_nat_sip_seq_adjust,\n\t.expect\t\t= nf_nat_sip_expect,\n\t.sdp_addr\t= nf_nat_sdp_addr,\n\t.sdp_port\t= nf_nat_sdp_port,\n\t.sdp_session\t= nf_nat_sdp_session,\n\t.sdp_media\t= nf_nat_sdp_media,\n};\n\nstatic int __init nf_nat_sip_init(void)\n{\n\tBUG_ON(nf_nat_sip_hooks != NULL);\n\tnf_nat_helper_register(&nat_helper_sip);\n\tRCU_INIT_POINTER(nf_nat_sip_hooks, &sip_hooks);\n\tnf_ct_helper_expectfn_register(&sip_nat);\n\treturn 0;\n}\n\nmodule_init(nf_nat_sip_init);\nmodule_exit(nf_nat_sip_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}