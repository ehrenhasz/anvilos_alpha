{
  "module_name": "nft_set_hash.c",
  "hash_id": "08777c64efc29a7c92877cf578622f09dd5582da9566c29f81740903363d7d8e",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_set_hash.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/log2.h>\n#include <linux/jhash.h>\n#include <linux/netlink.h>\n#include <linux/workqueue.h>\n#include <linux/rhashtable.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n\n \n#define NFT_RHASH_ELEMENT_HINT 3\n\nstruct nft_rhash {\n\tstruct rhashtable\t\tht;\n\tstruct delayed_work\t\tgc_work;\n};\n\nstruct nft_rhash_elem {\n\tstruct rhash_head\t\tnode;\n\tstruct nft_set_ext\t\text;\n};\n\nstruct nft_rhash_cmp_arg {\n\tconst struct nft_set\t\t*set;\n\tconst u32\t\t\t*key;\n\tu8\t\t\t\tgenmask;\n};\n\nstatic inline u32 nft_rhash_key(const void *data, u32 len, u32 seed)\n{\n\tconst struct nft_rhash_cmp_arg *arg = data;\n\n\treturn jhash(arg->key, len, seed);\n}\n\nstatic inline u32 nft_rhash_obj(const void *data, u32 len, u32 seed)\n{\n\tconst struct nft_rhash_elem *he = data;\n\n\treturn jhash(nft_set_ext_key(&he->ext), len, seed);\n}\n\nstatic inline int nft_rhash_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t\tconst void *ptr)\n{\n\tconst struct nft_rhash_cmp_arg *x = arg->key;\n\tconst struct nft_rhash_elem *he = ptr;\n\n\tif (memcmp(nft_set_ext_key(&he->ext), x->key, x->set->klen))\n\t\treturn 1;\n\tif (nft_set_elem_is_dead(&he->ext))\n\t\treturn 1;\n\tif (nft_set_elem_expired(&he->ext))\n\t\treturn 1;\n\tif (!nft_set_elem_active(&he->ext, x->genmask))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic const struct rhashtable_params nft_rhash_params = {\n\t.head_offset\t\t= offsetof(struct nft_rhash_elem, node),\n\t.hashfn\t\t\t= nft_rhash_key,\n\t.obj_hashfn\t\t= nft_rhash_obj,\n\t.obj_cmpfn\t\t= nft_rhash_cmp,\n\t.automatic_shrinking\t= true,\n};\n\nINDIRECT_CALLABLE_SCOPE\nbool nft_rhash_lookup(const struct net *net, const struct nft_set *set,\n\t\t      const u32 *key, const struct nft_set_ext **ext)\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\tconst struct nft_rhash_elem *he;\n\tstruct nft_rhash_cmp_arg arg = {\n\t\t.genmask = nft_genmask_cur(net),\n\t\t.set\t = set,\n\t\t.key\t = key,\n\t};\n\n\the = rhashtable_lookup(&priv->ht, &arg, nft_rhash_params);\n\tif (he != NULL)\n\t\t*ext = &he->ext;\n\n\treturn !!he;\n}\n\nstatic void *nft_rhash_get(const struct net *net, const struct nft_set *set,\n\t\t\t   const struct nft_set_elem *elem, unsigned int flags)\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\tstruct nft_rhash_elem *he;\n\tstruct nft_rhash_cmp_arg arg = {\n\t\t.genmask = nft_genmask_cur(net),\n\t\t.set\t = set,\n\t\t.key\t = elem->key.val.data,\n\t};\n\n\the = rhashtable_lookup(&priv->ht, &arg, nft_rhash_params);\n\tif (he != NULL)\n\t\treturn he;\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic bool nft_rhash_update(struct nft_set *set, const u32 *key,\n\t\t\t     void *(*new)(struct nft_set *,\n\t\t\t\t\t  const struct nft_expr *,\n\t\t\t\t\t  struct nft_regs *regs),\n\t\t\t     const struct nft_expr *expr,\n\t\t\t     struct nft_regs *regs,\n\t\t\t     const struct nft_set_ext **ext)\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\tstruct nft_rhash_elem *he, *prev;\n\tstruct nft_rhash_cmp_arg arg = {\n\t\t.genmask = NFT_GENMASK_ANY,\n\t\t.set\t = set,\n\t\t.key\t = key,\n\t};\n\n\the = rhashtable_lookup(&priv->ht, &arg, nft_rhash_params);\n\tif (he != NULL)\n\t\tgoto out;\n\n\the = new(set, expr, regs);\n\tif (he == NULL)\n\t\tgoto err1;\n\n\tprev = rhashtable_lookup_get_insert_key(&priv->ht, &arg, &he->node,\n\t\t\t\t\t\tnft_rhash_params);\n\tif (IS_ERR(prev))\n\t\tgoto err2;\n\n\t \n\tif (prev) {\n\t\tnft_set_elem_destroy(set, he, true);\n\t\tatomic_dec(&set->nelems);\n\t\the = prev;\n\t}\n\nout:\n\t*ext = &he->ext;\n\treturn true;\n\nerr2:\n\tnft_set_elem_destroy(set, he, true);\n\tatomic_dec(&set->nelems);\nerr1:\n\treturn false;\n}\n\nstatic int nft_rhash_insert(const struct net *net, const struct nft_set *set,\n\t\t\t    const struct nft_set_elem *elem,\n\t\t\t    struct nft_set_ext **ext)\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\tstruct nft_rhash_elem *he = elem->priv;\n\tstruct nft_rhash_cmp_arg arg = {\n\t\t.genmask = nft_genmask_next(net),\n\t\t.set\t = set,\n\t\t.key\t = elem->key.val.data,\n\t};\n\tstruct nft_rhash_elem *prev;\n\n\tprev = rhashtable_lookup_get_insert_key(&priv->ht, &arg, &he->node,\n\t\t\t\t\t\tnft_rhash_params);\n\tif (IS_ERR(prev))\n\t\treturn PTR_ERR(prev);\n\tif (prev) {\n\t\t*ext = &prev->ext;\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}\n\nstatic void nft_rhash_activate(const struct net *net, const struct nft_set *set,\n\t\t\t       const struct nft_set_elem *elem)\n{\n\tstruct nft_rhash_elem *he = elem->priv;\n\n\tnft_set_elem_change_active(net, set, &he->ext);\n}\n\nstatic bool nft_rhash_flush(const struct net *net,\n\t\t\t    const struct nft_set *set, void *priv)\n{\n\tstruct nft_rhash_elem *he = priv;\n\n\tnft_set_elem_change_active(net, set, &he->ext);\n\n\treturn true;\n}\n\nstatic void *nft_rhash_deactivate(const struct net *net,\n\t\t\t\t  const struct nft_set *set,\n\t\t\t\t  const struct nft_set_elem *elem)\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\tstruct nft_rhash_elem *he;\n\tstruct nft_rhash_cmp_arg arg = {\n\t\t.genmask = nft_genmask_next(net),\n\t\t.set\t = set,\n\t\t.key\t = elem->key.val.data,\n\t};\n\n\trcu_read_lock();\n\the = rhashtable_lookup(&priv->ht, &arg, nft_rhash_params);\n\tif (he)\n\t\tnft_set_elem_change_active(net, set, &he->ext);\n\n\trcu_read_unlock();\n\n\treturn he;\n}\n\nstatic void nft_rhash_remove(const struct net *net,\n\t\t\t     const struct nft_set *set,\n\t\t\t     const struct nft_set_elem *elem)\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\tstruct nft_rhash_elem *he = elem->priv;\n\n\trhashtable_remove_fast(&priv->ht, &he->node, nft_rhash_params);\n}\n\nstatic bool nft_rhash_delete(const struct nft_set *set,\n\t\t\t     const u32 *key)\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\tstruct nft_rhash_cmp_arg arg = {\n\t\t.genmask = NFT_GENMASK_ANY,\n\t\t.set = set,\n\t\t.key = key,\n\t};\n\tstruct nft_rhash_elem *he;\n\n\the = rhashtable_lookup(&priv->ht, &arg, nft_rhash_params);\n\tif (he == NULL)\n\t\treturn false;\n\n\tnft_set_elem_dead(&he->ext);\n\n\treturn true;\n}\n\nstatic void nft_rhash_walk(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t   struct nft_set_iter *iter)\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\tstruct nft_rhash_elem *he;\n\tstruct rhashtable_iter hti;\n\tstruct nft_set_elem elem;\n\n\trhashtable_walk_enter(&priv->ht, &hti);\n\trhashtable_walk_start(&hti);\n\n\twhile ((he = rhashtable_walk_next(&hti))) {\n\t\tif (IS_ERR(he)) {\n\t\t\tif (PTR_ERR(he) != -EAGAIN) {\n\t\t\t\titer->err = PTR_ERR(he);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iter->count < iter->skip)\n\t\t\tgoto cont;\n\t\tif (!nft_set_elem_active(&he->ext, iter->genmask))\n\t\t\tgoto cont;\n\n\t\telem.priv = he;\n\n\t\titer->err = iter->fn(ctx, set, iter, &elem);\n\t\tif (iter->err < 0)\n\t\t\tbreak;\n\ncont:\n\t\titer->count++;\n\t}\n\trhashtable_walk_stop(&hti);\n\trhashtable_walk_exit(&hti);\n}\n\nstatic bool nft_rhash_expr_needs_gc_run(const struct nft_set *set,\n\t\t\t\t\tstruct nft_set_ext *ext)\n{\n\tstruct nft_set_elem_expr *elem_expr = nft_set_ext_expr(ext);\n\tstruct nft_expr *expr;\n\tu32 size;\n\n\tnft_setelem_expr_foreach(expr, elem_expr, size) {\n\t\tif (expr->ops->gc &&\n\t\t    expr->ops->gc(read_pnet(&set->net), expr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void nft_rhash_gc(struct work_struct *work)\n{\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_set *set;\n\tstruct nft_rhash_elem *he;\n\tstruct nft_rhash *priv;\n\tstruct rhashtable_iter hti;\n\tstruct nft_trans_gc *gc;\n\tstruct net *net;\n\tu32 gc_seq;\n\n\tpriv = container_of(work, struct nft_rhash, gc_work.work);\n\tset  = nft_set_container_of(priv);\n\tnet  = read_pnet(&set->net);\n\tnft_net = nft_pernet(net);\n\tgc_seq = READ_ONCE(nft_net->gc_seq);\n\n\tif (nft_set_gc_is_pending(set))\n\t\tgoto done;\n\n\tgc = nft_trans_gc_alloc(set, gc_seq, GFP_KERNEL);\n\tif (!gc)\n\t\tgoto done;\n\n\trhashtable_walk_enter(&priv->ht, &hti);\n\trhashtable_walk_start(&hti);\n\n\twhile ((he = rhashtable_walk_next(&hti))) {\n\t\tif (IS_ERR(he)) {\n\t\t\tnft_trans_gc_destroy(gc);\n\t\t\tgc = NULL;\n\t\t\tgoto try_later;\n\t\t}\n\n\t\t \n\t\tif (READ_ONCE(nft_net->gc_seq) != gc_seq) {\n\t\t\tnft_trans_gc_destroy(gc);\n\t\t\tgc = NULL;\n\t\t\tgoto try_later;\n\t\t}\n\n\t\tif (nft_set_elem_is_dead(&he->ext))\n\t\t\tgoto dead_elem;\n\n\t\tif (nft_set_ext_exists(&he->ext, NFT_SET_EXT_EXPRESSIONS) &&\n\t\t    nft_rhash_expr_needs_gc_run(set, &he->ext))\n\t\t\tgoto needs_gc_run;\n\n\t\tif (!nft_set_elem_expired(&he->ext))\n\t\t\tcontinue;\nneeds_gc_run:\n\t\tnft_set_elem_dead(&he->ext);\ndead_elem:\n\t\tgc = nft_trans_gc_queue_async(gc, gc_seq, GFP_ATOMIC);\n\t\tif (!gc)\n\t\t\tgoto try_later;\n\n\t\tnft_trans_gc_elem_add(gc, he);\n\t}\n\n\tgc = nft_trans_gc_catchall_async(gc, gc_seq);\n\ntry_later:\n\t \n\trhashtable_walk_stop(&hti);\n\trhashtable_walk_exit(&hti);\n\n\tif (gc)\n\t\tnft_trans_gc_queue_async_done(gc);\n\ndone:\n\tqueue_delayed_work(system_power_efficient_wq, &priv->gc_work,\n\t\t\t   nft_set_gc_interval(set));\n}\n\nstatic u64 nft_rhash_privsize(const struct nlattr * const nla[],\n\t\t\t      const struct nft_set_desc *desc)\n{\n\treturn sizeof(struct nft_rhash);\n}\n\nstatic void nft_rhash_gc_init(const struct nft_set *set)\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\n\tqueue_delayed_work(system_power_efficient_wq, &priv->gc_work,\n\t\t\t   nft_set_gc_interval(set));\n}\n\nstatic int nft_rhash_init(const struct nft_set *set,\n\t\t\t  const struct nft_set_desc *desc,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\tstruct rhashtable_params params = nft_rhash_params;\n\tint err;\n\n\tparams.nelem_hint = desc->size ?: NFT_RHASH_ELEMENT_HINT;\n\tparams.key_len\t  = set->klen;\n\n\terr = rhashtable_init(&priv->ht, &params);\n\tif (err < 0)\n\t\treturn err;\n\n\tINIT_DEFERRABLE_WORK(&priv->gc_work, nft_rhash_gc);\n\tif (set->flags & (NFT_SET_TIMEOUT | NFT_SET_EVAL))\n\t\tnft_rhash_gc_init(set);\n\n\treturn 0;\n}\n\nstruct nft_rhash_ctx {\n\tconst struct nft_ctx\tctx;\n\tconst struct nft_set\t*set;\n};\n\nstatic void nft_rhash_elem_destroy(void *ptr, void *arg)\n{\n\tstruct nft_rhash_ctx *rhash_ctx = arg;\n\n\tnf_tables_set_elem_destroy(&rhash_ctx->ctx, rhash_ctx->set, ptr);\n}\n\nstatic void nft_rhash_destroy(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_set *set)\n{\n\tstruct nft_rhash *priv = nft_set_priv(set);\n\tstruct nft_rhash_ctx rhash_ctx = {\n\t\t.ctx\t= *ctx,\n\t\t.set\t= set,\n\t};\n\n\tcancel_delayed_work_sync(&priv->gc_work);\n\trhashtable_free_and_destroy(&priv->ht, nft_rhash_elem_destroy,\n\t\t\t\t    (void *)&rhash_ctx);\n}\n\n \n#define NFT_MAX_BUCKETS (1U << 31)\n\nstatic u32 nft_hash_buckets(u32 size)\n{\n\tu64 val = div_u64((u64)size * 4, 3);\n\n\tif (val >= NFT_MAX_BUCKETS)\n\t\treturn NFT_MAX_BUCKETS;\n\n\treturn roundup_pow_of_two(val);\n}\n\nstatic bool nft_rhash_estimate(const struct nft_set_desc *desc, u32 features,\n\t\t\t       struct nft_set_estimate *est)\n{\n\test->size   = ~0;\n\test->lookup = NFT_SET_CLASS_O_1;\n\test->space  = NFT_SET_CLASS_O_N;\n\n\treturn true;\n}\n\nstruct nft_hash {\n\tu32\t\t\t\tseed;\n\tu32\t\t\t\tbuckets;\n\tstruct hlist_head\t\ttable[];\n};\n\nstruct nft_hash_elem {\n\tstruct hlist_node\t\tnode;\n\tstruct nft_set_ext\t\text;\n};\n\nINDIRECT_CALLABLE_SCOPE\nbool nft_hash_lookup(const struct net *net, const struct nft_set *set,\n\t\t     const u32 *key, const struct nft_set_ext **ext)\n{\n\tstruct nft_hash *priv = nft_set_priv(set);\n\tu8 genmask = nft_genmask_cur(net);\n\tconst struct nft_hash_elem *he;\n\tu32 hash;\n\n\thash = jhash(key, set->klen, priv->seed);\n\thash = reciprocal_scale(hash, priv->buckets);\n\thlist_for_each_entry_rcu(he, &priv->table[hash], node) {\n\t\tif (!memcmp(nft_set_ext_key(&he->ext), key, set->klen) &&\n\t\t    nft_set_elem_active(&he->ext, genmask)) {\n\t\t\t*ext = &he->ext;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void *nft_hash_get(const struct net *net, const struct nft_set *set,\n\t\t\t  const struct nft_set_elem *elem, unsigned int flags)\n{\n\tstruct nft_hash *priv = nft_set_priv(set);\n\tu8 genmask = nft_genmask_cur(net);\n\tstruct nft_hash_elem *he;\n\tu32 hash;\n\n\thash = jhash(elem->key.val.data, set->klen, priv->seed);\n\thash = reciprocal_scale(hash, priv->buckets);\n\thlist_for_each_entry_rcu(he, &priv->table[hash], node) {\n\t\tif (!memcmp(nft_set_ext_key(&he->ext), elem->key.val.data, set->klen) &&\n\t\t    nft_set_elem_active(&he->ext, genmask))\n\t\t\treturn he;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nINDIRECT_CALLABLE_SCOPE\nbool nft_hash_lookup_fast(const struct net *net,\n\t\t\t  const struct nft_set *set,\n\t\t\t  const u32 *key, const struct nft_set_ext **ext)\n{\n\tstruct nft_hash *priv = nft_set_priv(set);\n\tu8 genmask = nft_genmask_cur(net);\n\tconst struct nft_hash_elem *he;\n\tu32 hash, k1, k2;\n\n\tk1 = *key;\n\thash = jhash_1word(k1, priv->seed);\n\thash = reciprocal_scale(hash, priv->buckets);\n\thlist_for_each_entry_rcu(he, &priv->table[hash], node) {\n\t\tk2 = *(u32 *)nft_set_ext_key(&he->ext)->data;\n\t\tif (k1 == k2 &&\n\t\t    nft_set_elem_active(&he->ext, genmask)) {\n\t\t\t*ext = &he->ext;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic u32 nft_jhash(const struct nft_set *set, const struct nft_hash *priv,\n\t\t     const struct nft_set_ext *ext)\n{\n\tconst struct nft_data *key = nft_set_ext_key(ext);\n\tu32 hash, k1;\n\n\tif (set->klen == 4) {\n\t\tk1 = *(u32 *)key;\n\t\thash = jhash_1word(k1, priv->seed);\n\t} else {\n\t\thash = jhash(key, set->klen, priv->seed);\n\t}\n\thash = reciprocal_scale(hash, priv->buckets);\n\n\treturn hash;\n}\n\nstatic int nft_hash_insert(const struct net *net, const struct nft_set *set,\n\t\t\t   const struct nft_set_elem *elem,\n\t\t\t   struct nft_set_ext **ext)\n{\n\tstruct nft_hash_elem *this = elem->priv, *he;\n\tstruct nft_hash *priv = nft_set_priv(set);\n\tu8 genmask = nft_genmask_next(net);\n\tu32 hash;\n\n\thash = nft_jhash(set, priv, &this->ext);\n\thlist_for_each_entry(he, &priv->table[hash], node) {\n\t\tif (!memcmp(nft_set_ext_key(&this->ext),\n\t\t\t    nft_set_ext_key(&he->ext), set->klen) &&\n\t\t    nft_set_elem_active(&he->ext, genmask)) {\n\t\t\t*ext = &he->ext;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\thlist_add_head_rcu(&this->node, &priv->table[hash]);\n\treturn 0;\n}\n\nstatic void nft_hash_activate(const struct net *net, const struct nft_set *set,\n\t\t\t      const struct nft_set_elem *elem)\n{\n\tstruct nft_hash_elem *he = elem->priv;\n\n\tnft_set_elem_change_active(net, set, &he->ext);\n}\n\nstatic bool nft_hash_flush(const struct net *net,\n\t\t\t   const struct nft_set *set, void *priv)\n{\n\tstruct nft_hash_elem *he = priv;\n\n\tnft_set_elem_change_active(net, set, &he->ext);\n\treturn true;\n}\n\nstatic void *nft_hash_deactivate(const struct net *net,\n\t\t\t\t const struct nft_set *set,\n\t\t\t\t const struct nft_set_elem *elem)\n{\n\tstruct nft_hash *priv = nft_set_priv(set);\n\tstruct nft_hash_elem *this = elem->priv, *he;\n\tu8 genmask = nft_genmask_next(net);\n\tu32 hash;\n\n\thash = nft_jhash(set, priv, &this->ext);\n\thlist_for_each_entry(he, &priv->table[hash], node) {\n\t\tif (!memcmp(nft_set_ext_key(&he->ext), &elem->key.val,\n\t\t\t    set->klen) &&\n\t\t    nft_set_elem_active(&he->ext, genmask)) {\n\t\t\tnft_set_elem_change_active(net, set, &he->ext);\n\t\t\treturn he;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void nft_hash_remove(const struct net *net,\n\t\t\t    const struct nft_set *set,\n\t\t\t    const struct nft_set_elem *elem)\n{\n\tstruct nft_hash_elem *he = elem->priv;\n\n\thlist_del_rcu(&he->node);\n}\n\nstatic void nft_hash_walk(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t  struct nft_set_iter *iter)\n{\n\tstruct nft_hash *priv = nft_set_priv(set);\n\tstruct nft_hash_elem *he;\n\tstruct nft_set_elem elem;\n\tint i;\n\n\tfor (i = 0; i < priv->buckets; i++) {\n\t\thlist_for_each_entry_rcu(he, &priv->table[i], node) {\n\t\t\tif (iter->count < iter->skip)\n\t\t\t\tgoto cont;\n\t\t\tif (!nft_set_elem_active(&he->ext, iter->genmask))\n\t\t\t\tgoto cont;\n\n\t\t\telem.priv = he;\n\n\t\t\titer->err = iter->fn(ctx, set, iter, &elem);\n\t\t\tif (iter->err < 0)\n\t\t\t\treturn;\ncont:\n\t\t\titer->count++;\n\t\t}\n\t}\n}\n\nstatic u64 nft_hash_privsize(const struct nlattr * const nla[],\n\t\t\t     const struct nft_set_desc *desc)\n{\n\treturn sizeof(struct nft_hash) +\n\t       (u64)nft_hash_buckets(desc->size) * sizeof(struct hlist_head);\n}\n\nstatic int nft_hash_init(const struct nft_set *set,\n\t\t\t const struct nft_set_desc *desc,\n\t\t\t const struct nlattr * const tb[])\n{\n\tstruct nft_hash *priv = nft_set_priv(set);\n\n\tpriv->buckets = nft_hash_buckets(desc->size);\n\tget_random_bytes(&priv->seed, sizeof(priv->seed));\n\n\treturn 0;\n}\n\nstatic void nft_hash_destroy(const struct nft_ctx *ctx,\n\t\t\t     const struct nft_set *set)\n{\n\tstruct nft_hash *priv = nft_set_priv(set);\n\tstruct nft_hash_elem *he;\n\tstruct hlist_node *next;\n\tint i;\n\n\tfor (i = 0; i < priv->buckets; i++) {\n\t\thlist_for_each_entry_safe(he, next, &priv->table[i], node) {\n\t\t\thlist_del_rcu(&he->node);\n\t\t\tnf_tables_set_elem_destroy(ctx, set, he);\n\t\t}\n\t}\n}\n\nstatic bool nft_hash_estimate(const struct nft_set_desc *desc, u32 features,\n\t\t\t      struct nft_set_estimate *est)\n{\n\tif (!desc->size)\n\t\treturn false;\n\n\tif (desc->klen == 4)\n\t\treturn false;\n\n\test->size   = sizeof(struct nft_hash) +\n\t\t      (u64)nft_hash_buckets(desc->size) * sizeof(struct hlist_head) +\n\t\t      (u64)desc->size * sizeof(struct nft_hash_elem);\n\test->lookup = NFT_SET_CLASS_O_1;\n\test->space  = NFT_SET_CLASS_O_N;\n\n\treturn true;\n}\n\nstatic bool nft_hash_fast_estimate(const struct nft_set_desc *desc, u32 features,\n\t\t\t\t   struct nft_set_estimate *est)\n{\n\tif (!desc->size)\n\t\treturn false;\n\n\tif (desc->klen != 4)\n\t\treturn false;\n\n\test->size   = sizeof(struct nft_hash) +\n\t\t      (u64)nft_hash_buckets(desc->size) * sizeof(struct hlist_head) +\n\t\t      (u64)desc->size * sizeof(struct nft_hash_elem);\n\test->lookup = NFT_SET_CLASS_O_1;\n\test->space  = NFT_SET_CLASS_O_N;\n\n\treturn true;\n}\n\nconst struct nft_set_type nft_set_rhash_type = {\n\t.features\t= NFT_SET_MAP | NFT_SET_OBJECT |\n\t\t\t  NFT_SET_TIMEOUT | NFT_SET_EVAL,\n\t.ops\t\t= {\n\t\t.privsize       = nft_rhash_privsize,\n\t\t.elemsize\t= offsetof(struct nft_rhash_elem, ext),\n\t\t.estimate\t= nft_rhash_estimate,\n\t\t.init\t\t= nft_rhash_init,\n\t\t.gc_init\t= nft_rhash_gc_init,\n\t\t.destroy\t= nft_rhash_destroy,\n\t\t.insert\t\t= nft_rhash_insert,\n\t\t.activate\t= nft_rhash_activate,\n\t\t.deactivate\t= nft_rhash_deactivate,\n\t\t.flush\t\t= nft_rhash_flush,\n\t\t.remove\t\t= nft_rhash_remove,\n\t\t.lookup\t\t= nft_rhash_lookup,\n\t\t.update\t\t= nft_rhash_update,\n\t\t.delete\t\t= nft_rhash_delete,\n\t\t.walk\t\t= nft_rhash_walk,\n\t\t.get\t\t= nft_rhash_get,\n\t},\n};\n\nconst struct nft_set_type nft_set_hash_type = {\n\t.features\t= NFT_SET_MAP | NFT_SET_OBJECT,\n\t.ops\t\t= {\n\t\t.privsize       = nft_hash_privsize,\n\t\t.elemsize\t= offsetof(struct nft_hash_elem, ext),\n\t\t.estimate\t= nft_hash_estimate,\n\t\t.init\t\t= nft_hash_init,\n\t\t.destroy\t= nft_hash_destroy,\n\t\t.insert\t\t= nft_hash_insert,\n\t\t.activate\t= nft_hash_activate,\n\t\t.deactivate\t= nft_hash_deactivate,\n\t\t.flush\t\t= nft_hash_flush,\n\t\t.remove\t\t= nft_hash_remove,\n\t\t.lookup\t\t= nft_hash_lookup,\n\t\t.walk\t\t= nft_hash_walk,\n\t\t.get\t\t= nft_hash_get,\n\t},\n};\n\nconst struct nft_set_type nft_set_hash_fast_type = {\n\t.features\t= NFT_SET_MAP | NFT_SET_OBJECT,\n\t.ops\t\t= {\n\t\t.privsize       = nft_hash_privsize,\n\t\t.elemsize\t= offsetof(struct nft_hash_elem, ext),\n\t\t.estimate\t= nft_hash_fast_estimate,\n\t\t.init\t\t= nft_hash_init,\n\t\t.destroy\t= nft_hash_destroy,\n\t\t.insert\t\t= nft_hash_insert,\n\t\t.activate\t= nft_hash_activate,\n\t\t.deactivate\t= nft_hash_deactivate,\n\t\t.flush\t\t= nft_hash_flush,\n\t\t.remove\t\t= nft_hash_remove,\n\t\t.lookup\t\t= nft_hash_lookup_fast,\n\t\t.walk\t\t= nft_hash_walk,\n\t\t.get\t\t= nft_hash_get,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}