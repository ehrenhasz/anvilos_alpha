{
  "module_name": "nf_log.c",
  "hash_id": "fa4a848ee6c2ff2a73c77c738b90e4f779be4bf708882c8c8830b85ee51e4fa8",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_log.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter.h>\n#include <linux/seq_file.h>\n#include <net/protocol.h>\n#include <net/netfilter/nf_log.h>\n\n#include \"nf_internals.h\"\n\n \n\n#define NFLOGGER_NAME_LEN\t\t64\n\nint sysctl_nf_log_all_netns __read_mostly;\nEXPORT_SYMBOL(sysctl_nf_log_all_netns);\n\nstatic struct nf_logger __rcu *loggers[NFPROTO_NUMPROTO][NF_LOG_TYPE_MAX] __read_mostly;\nstatic DEFINE_MUTEX(nf_log_mutex);\n\n#define nft_log_dereference(logger) \\\n\trcu_dereference_protected(logger, lockdep_is_held(&nf_log_mutex))\n\nstatic struct nf_logger *__find_logger(int pf, const char *str_logger)\n{\n\tstruct nf_logger *log;\n\tint i;\n\n\tfor (i = 0; i < NF_LOG_TYPE_MAX; i++) {\n\t\tif (loggers[pf][i] == NULL)\n\t\t\tcontinue;\n\n\t\tlog = nft_log_dereference(loggers[pf][i]);\n\t\tif (!strncasecmp(str_logger, log->name, strlen(log->name)))\n\t\t\treturn log;\n\t}\n\n\treturn NULL;\n}\n\nint nf_log_set(struct net *net, u_int8_t pf, const struct nf_logger *logger)\n{\n\tconst struct nf_logger *log;\n\n\tif (pf == NFPROTO_UNSPEC || pf >= ARRAY_SIZE(net->nf.nf_loggers))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&nf_log_mutex);\n\tlog = nft_log_dereference(net->nf.nf_loggers[pf]);\n\tif (log == NULL)\n\t\trcu_assign_pointer(net->nf.nf_loggers[pf], logger);\n\n\tmutex_unlock(&nf_log_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nf_log_set);\n\nvoid nf_log_unset(struct net *net, const struct nf_logger *logger)\n{\n\tint i;\n\tconst struct nf_logger *log;\n\n\tmutex_lock(&nf_log_mutex);\n\tfor (i = 0; i < NFPROTO_NUMPROTO; i++) {\n\t\tlog = nft_log_dereference(net->nf.nf_loggers[i]);\n\t\tif (log == logger)\n\t\t\tRCU_INIT_POINTER(net->nf.nf_loggers[i], NULL);\n\t}\n\tmutex_unlock(&nf_log_mutex);\n}\nEXPORT_SYMBOL(nf_log_unset);\n\n \nint nf_log_register(u_int8_t pf, struct nf_logger *logger)\n{\n\tint i;\n\tint ret = 0;\n\n\tif (pf >= ARRAY_SIZE(init_net.nf.nf_loggers))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&nf_log_mutex);\n\n\tif (pf == NFPROTO_UNSPEC) {\n\t\tfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++) {\n\t\t\tif (rcu_access_pointer(loggers[i][logger->type])) {\n\t\t\t\tret = -EEXIST;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t\tfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++)\n\t\t\trcu_assign_pointer(loggers[i][logger->type], logger);\n\t} else {\n\t\tif (rcu_access_pointer(loggers[pf][logger->type])) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto unlock;\n\t\t}\n\t\trcu_assign_pointer(loggers[pf][logger->type], logger);\n\t}\n\nunlock:\n\tmutex_unlock(&nf_log_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(nf_log_register);\n\nvoid nf_log_unregister(struct nf_logger *logger)\n{\n\tconst struct nf_logger *log;\n\tint i;\n\n\tmutex_lock(&nf_log_mutex);\n\tfor (i = 0; i < NFPROTO_NUMPROTO; i++) {\n\t\tlog = nft_log_dereference(loggers[i][logger->type]);\n\t\tif (log == logger)\n\t\t\tRCU_INIT_POINTER(loggers[i][logger->type], NULL);\n\t}\n\tmutex_unlock(&nf_log_mutex);\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL(nf_log_unregister);\n\nint nf_log_bind_pf(struct net *net, u_int8_t pf,\n\t\t   const struct nf_logger *logger)\n{\n\tif (pf >= ARRAY_SIZE(net->nf.nf_loggers))\n\t\treturn -EINVAL;\n\tmutex_lock(&nf_log_mutex);\n\tif (__find_logger(pf, logger->name) == NULL) {\n\t\tmutex_unlock(&nf_log_mutex);\n\t\treturn -ENOENT;\n\t}\n\trcu_assign_pointer(net->nf.nf_loggers[pf], logger);\n\tmutex_unlock(&nf_log_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(nf_log_bind_pf);\n\nvoid nf_log_unbind_pf(struct net *net, u_int8_t pf)\n{\n\tif (pf >= ARRAY_SIZE(net->nf.nf_loggers))\n\t\treturn;\n\tmutex_lock(&nf_log_mutex);\n\tRCU_INIT_POINTER(net->nf.nf_loggers[pf], NULL);\n\tmutex_unlock(&nf_log_mutex);\n}\nEXPORT_SYMBOL(nf_log_unbind_pf);\n\nint nf_logger_find_get(int pf, enum nf_log_type type)\n{\n\tstruct nf_logger *logger;\n\tint ret = -ENOENT;\n\n\tif (pf == NFPROTO_INET) {\n\t\tret = nf_logger_find_get(NFPROTO_IPV4, type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = nf_logger_find_get(NFPROTO_IPV6, type);\n\t\tif (ret < 0) {\n\t\t\tnf_logger_put(NFPROTO_IPV4, type);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\trcu_read_lock();\n\tlogger = rcu_dereference(loggers[pf][type]);\n\tif (logger == NULL)\n\t\tgoto out;\n\n\tif (try_module_get(logger->me))\n\t\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nf_logger_find_get);\n\nvoid nf_logger_put(int pf, enum nf_log_type type)\n{\n\tstruct nf_logger *logger;\n\n\tif (pf == NFPROTO_INET) {\n\t\tnf_logger_put(NFPROTO_IPV4, type);\n\t\tnf_logger_put(NFPROTO_IPV6, type);\n\t\treturn;\n\t}\n\n\tBUG_ON(loggers[pf][type] == NULL);\n\n\trcu_read_lock();\n\tlogger = rcu_dereference(loggers[pf][type]);\n\tmodule_put(logger->me);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(nf_logger_put);\n\nvoid nf_log_packet(struct net *net,\n\t\t   u_int8_t pf,\n\t\t   unsigned int hooknum,\n\t\t   const struct sk_buff *skb,\n\t\t   const struct net_device *in,\n\t\t   const struct net_device *out,\n\t\t   const struct nf_loginfo *loginfo,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\tchar prefix[NF_LOG_PREFIXLEN];\n\tconst struct nf_logger *logger;\n\n\trcu_read_lock();\n\tif (loginfo != NULL)\n\t\tlogger = rcu_dereference(loggers[pf][loginfo->type]);\n\telse\n\t\tlogger = rcu_dereference(net->nf.nf_loggers[pf]);\n\n\tif (logger) {\n\t\tva_start(args, fmt);\n\t\tvsnprintf(prefix, sizeof(prefix), fmt, args);\n\t\tva_end(args);\n\t\tlogger->logfn(net, pf, hooknum, skb, in, out, loginfo, prefix);\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(nf_log_packet);\n\nvoid nf_log_trace(struct net *net,\n\t\t  u_int8_t pf,\n\t\t  unsigned int hooknum,\n\t\t  const struct sk_buff *skb,\n\t\t  const struct net_device *in,\n\t\t  const struct net_device *out,\n\t\t  const struct nf_loginfo *loginfo, const char *fmt, ...)\n{\n\tva_list args;\n\tchar prefix[NF_LOG_PREFIXLEN];\n\tconst struct nf_logger *logger;\n\n\trcu_read_lock();\n\tlogger = rcu_dereference(net->nf.nf_loggers[pf]);\n\tif (logger) {\n\t\tva_start(args, fmt);\n\t\tvsnprintf(prefix, sizeof(prefix), fmt, args);\n\t\tva_end(args);\n\t\tlogger->logfn(net, pf, hooknum, skb, in, out, loginfo, prefix);\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(nf_log_trace);\n\n#define S_SIZE (1024 - (sizeof(unsigned int) + 1))\n\nstruct nf_log_buf {\n\tunsigned int\tcount;\n\tchar\t\tbuf[S_SIZE + 1];\n};\nstatic struct nf_log_buf emergency, *emergency_ptr = &emergency;\n\n__printf(2, 3) int nf_log_buf_add(struct nf_log_buf *m, const char *f, ...)\n{\n\tva_list args;\n\tint len;\n\n\tif (likely(m->count < S_SIZE)) {\n\t\tva_start(args, f);\n\t\tlen = vsnprintf(m->buf + m->count, S_SIZE - m->count, f, args);\n\t\tva_end(args);\n\t\tif (likely(m->count + len < S_SIZE)) {\n\t\t\tm->count += len;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tm->count = S_SIZE;\n\tprintk_once(KERN_ERR KBUILD_MODNAME \" please increase S_SIZE\\n\");\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(nf_log_buf_add);\n\nstruct nf_log_buf *nf_log_buf_open(void)\n{\n\tstruct nf_log_buf *m = kmalloc(sizeof(*m), GFP_ATOMIC);\n\n\tif (unlikely(!m)) {\n\t\tlocal_bh_disable();\n\t\tdo {\n\t\t\tm = xchg(&emergency_ptr, NULL);\n\t\t} while (!m);\n\t}\n\tm->count = 0;\n\treturn m;\n}\nEXPORT_SYMBOL_GPL(nf_log_buf_open);\n\nvoid nf_log_buf_close(struct nf_log_buf *m)\n{\n\tm->buf[m->count] = 0;\n\tprintk(\"%s\\n\", m->buf);\n\n\tif (likely(m != &emergency))\n\t\tkfree(m);\n\telse {\n\t\temergency_ptr = m;\n\t\tlocal_bh_enable();\n\t}\n}\nEXPORT_SYMBOL_GPL(nf_log_buf_close);\n\n#ifdef CONFIG_PROC_FS\nstatic void *seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\n\tmutex_lock(&nf_log_mutex);\n\n\tif (*pos >= ARRAY_SIZE(net->nf.nf_loggers))\n\t\treturn NULL;\n\n\treturn pos;\n}\n\nstatic void *seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(s);\n\n\t(*pos)++;\n\n\tif (*pos >= ARRAY_SIZE(net->nf.nf_loggers))\n\t\treturn NULL;\n\n\treturn pos;\n}\n\nstatic void seq_stop(struct seq_file *s, void *v)\n{\n\tmutex_unlock(&nf_log_mutex);\n}\n\nstatic int seq_show(struct seq_file *s, void *v)\n{\n\tloff_t *pos = v;\n\tconst struct nf_logger *logger;\n\tint i;\n\tstruct net *net = seq_file_net(s);\n\n\tlogger = nft_log_dereference(net->nf.nf_loggers[*pos]);\n\n\tif (!logger)\n\t\tseq_printf(s, \"%2lld NONE (\", *pos);\n\telse\n\t\tseq_printf(s, \"%2lld %s (\", *pos, logger->name);\n\n\tif (seq_has_overflowed(s))\n\t\treturn -ENOSPC;\n\n\tfor (i = 0; i < NF_LOG_TYPE_MAX; i++) {\n\t\tif (loggers[*pos][i] == NULL)\n\t\t\tcontinue;\n\n\t\tlogger = nft_log_dereference(loggers[*pos][i]);\n\t\tseq_puts(s, logger->name);\n\t\tif (i == 0 && loggers[*pos][i + 1] != NULL)\n\t\t\tseq_puts(s, \",\");\n\n\t\tif (seq_has_overflowed(s))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tseq_puts(s, \")\\n\");\n\n\tif (seq_has_overflowed(s))\n\t\treturn -ENOSPC;\n\treturn 0;\n}\n\nstatic const struct seq_operations nflog_seq_ops = {\n\t.start\t= seq_start,\n\t.next\t= seq_next,\n\t.stop\t= seq_stop,\n\t.show\t= seq_show,\n};\n#endif  \n\n#ifdef CONFIG_SYSCTL\nstatic char nf_log_sysctl_fnames[NFPROTO_NUMPROTO-NFPROTO_UNSPEC][3];\nstatic struct ctl_table nf_log_sysctl_table[NFPROTO_NUMPROTO+1];\nstatic struct ctl_table_header *nf_log_sysctl_fhdr;\n\nstatic struct ctl_table nf_log_sysctl_ftable[] = {\n\t{\n\t\t.procname\t= \"nf_log_all_netns\",\n\t\t.data\t\t= &sysctl_nf_log_all_netns,\n\t\t.maxlen\t\t= sizeof(sysctl_nf_log_all_netns),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\nstatic int nf_log_proc_dostring(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tconst struct nf_logger *logger;\n\tchar buf[NFLOGGER_NAME_LEN];\n\tint r = 0;\n\tint tindex = (unsigned long)table->extra1;\n\tstruct net *net = table->extra2;\n\n\tif (write) {\n\t\tstruct ctl_table tmp = *table;\n\n\t\t \n\t\tbuf[0] = '\\0';\n\t\ttmp.data = buf;\n\t\tr = proc_dostring(&tmp, write, buffer, lenp, ppos);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tif (!strcmp(buf, \"NONE\")) {\n\t\t\tnf_log_unbind_pf(net, tindex);\n\t\t\treturn 0;\n\t\t}\n\t\tmutex_lock(&nf_log_mutex);\n\t\tlogger = __find_logger(tindex, buf);\n\t\tif (logger == NULL) {\n\t\t\tmutex_unlock(&nf_log_mutex);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\trcu_assign_pointer(net->nf.nf_loggers[tindex], logger);\n\t\tmutex_unlock(&nf_log_mutex);\n\t} else {\n\t\tstruct ctl_table tmp = *table;\n\n\t\ttmp.data = buf;\n\t\tmutex_lock(&nf_log_mutex);\n\t\tlogger = nft_log_dereference(net->nf.nf_loggers[tindex]);\n\t\tif (!logger)\n\t\t\tstrscpy(buf, \"NONE\", sizeof(buf));\n\t\telse\n\t\t\tstrscpy(buf, logger->name, sizeof(buf));\n\t\tmutex_unlock(&nf_log_mutex);\n\t\tr = proc_dostring(&tmp, write, buffer, lenp, ppos);\n\t}\n\n\treturn r;\n}\n\nstatic int netfilter_log_sysctl_init(struct net *net)\n{\n\tint i;\n\tstruct ctl_table *table;\n\n\ttable = nf_log_sysctl_table;\n\tif (!net_eq(net, &init_net)) {\n\t\ttable = kmemdup(nf_log_sysctl_table,\n\t\t\t\t sizeof(nf_log_sysctl_table),\n\t\t\t\t GFP_KERNEL);\n\t\tif (!table)\n\t\t\tgoto err_alloc;\n\t} else {\n\t\tfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++) {\n\t\t\tsnprintf(nf_log_sysctl_fnames[i],\n\t\t\t\t 3, \"%d\", i);\n\t\t\tnf_log_sysctl_table[i].procname\t=\n\t\t\t\tnf_log_sysctl_fnames[i];\n\t\t\tnf_log_sysctl_table[i].maxlen = NFLOGGER_NAME_LEN;\n\t\t\tnf_log_sysctl_table[i].mode = 0644;\n\t\t\tnf_log_sysctl_table[i].proc_handler =\n\t\t\t\tnf_log_proc_dostring;\n\t\t\tnf_log_sysctl_table[i].extra1 =\n\t\t\t\t(void *)(unsigned long) i;\n\t\t}\n\t\tnf_log_sysctl_fhdr = register_net_sysctl(net, \"net/netfilter\",\n\t\t\t\t\t\t\t nf_log_sysctl_ftable);\n\t\tif (!nf_log_sysctl_fhdr)\n\t\t\tgoto err_freg;\n\t}\n\n\tfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++)\n\t\ttable[i].extra2 = net;\n\n\tnet->nf.nf_log_dir_header = register_net_sysctl_sz(net,\n\t\t\t\t\t\t\t   \"net/netfilter/nf_log\",\n\t\t\t\t\t\t\t   table,\n\t\t\t\t\t\t\t   ARRAY_SIZE(nf_log_sysctl_table));\n\tif (!net->nf.nf_log_dir_header)\n\t\tgoto err_reg;\n\n\treturn 0;\n\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n\telse\n\t\tunregister_net_sysctl_table(nf_log_sysctl_fhdr);\nerr_freg:\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nstatic void netfilter_log_sysctl_exit(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = net->nf.nf_log_dir_header->ctl_table_arg;\n\tunregister_net_sysctl_table(net->nf.nf_log_dir_header);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n\telse\n\t\tunregister_net_sysctl_table(nf_log_sysctl_fhdr);\n}\n#else\nstatic int netfilter_log_sysctl_init(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void netfilter_log_sysctl_exit(struct net *net)\n{\n}\n#endif  \n\nstatic int __net_init nf_log_net_init(struct net *net)\n{\n\tint ret = -ENOMEM;\n\n#ifdef CONFIG_PROC_FS\n\tif (!proc_create_net(\"nf_log\", 0444, net->nf.proc_netfilter,\n\t\t\t&nflog_seq_ops, sizeof(struct seq_net_private)))\n\t\treturn ret;\n#endif\n\tret = netfilter_log_sysctl_init(net);\n\tif (ret < 0)\n\t\tgoto out_sysctl;\n\n\treturn 0;\n\nout_sysctl:\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"nf_log\", net->nf.proc_netfilter);\n#endif\n\treturn ret;\n}\n\nstatic void __net_exit nf_log_net_exit(struct net *net)\n{\n\tnetfilter_log_sysctl_exit(net);\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"nf_log\", net->nf.proc_netfilter);\n#endif\n}\n\nstatic struct pernet_operations nf_log_net_ops = {\n\t.init = nf_log_net_init,\n\t.exit = nf_log_net_exit,\n};\n\nint __init netfilter_log_init(void)\n{\n\treturn register_pernet_subsys(&nf_log_net_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}