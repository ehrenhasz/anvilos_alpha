{
  "module_name": "xt_ipvs.c",
  "hash_id": "db800ec87e7b74ae13e1a9d62553cac747c262b5e70eba8ad863fc58bd790ed9",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_ipvs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#ifdef CONFIG_IP_VS_IPV6\n#include <net/ipv6.h>\n#endif\n#include <linux/ip_vs.h>\n#include <linux/types.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_ipvs.h>\n#include <net/netfilter/nf_conntrack.h>\n\n#include <net/ip_vs.h>\n\nMODULE_AUTHOR(\"Hannes Eder <heder@google.com>\");\nMODULE_DESCRIPTION(\"Xtables: match IPVS connection properties\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_ipvs\");\nMODULE_ALIAS(\"ip6t_ipvs\");\n\n \nstatic bool ipvs_mt_addrcmp(const union nf_inet_addr *kaddr,\n\t\t\t    const union nf_inet_addr *uaddr,\n\t\t\t    const union nf_inet_addr *umask,\n\t\t\t    unsigned int l3proto)\n{\n\tif (l3proto == NFPROTO_IPV4)\n\t\treturn ((kaddr->ip ^ uaddr->ip) & umask->ip) == 0;\n#ifdef CONFIG_IP_VS_IPV6\n\telse if (l3proto == NFPROTO_IPV6)\n\t\treturn ipv6_masked_addr_cmp(&kaddr->in6, &umask->in6,\n\t\t       &uaddr->in6) == 0;\n#endif\n\telse\n\t\treturn false;\n}\n\nstatic bool\nipvs_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_ipvs_mtinfo *data = par->matchinfo;\n\tstruct netns_ipvs *ipvs = net_ipvs(xt_net(par));\n\t \n\tconst u_int8_t family = xt_family(par);\n\tstruct ip_vs_iphdr iph;\n\tstruct ip_vs_protocol *pp;\n\tstruct ip_vs_conn *cp;\n\tbool match = true;\n\n\tif (data->bitmask == XT_IPVS_IPVS_PROPERTY) {\n\t\tmatch = skb->ipvs_property ^\n\t\t\t!!(data->invert & XT_IPVS_IPVS_PROPERTY);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!skb->ipvs_property) {\n\t\tmatch = false;\n\t\tgoto out;\n\t}\n\n\tip_vs_fill_iph_skb(family, skb, true, &iph);\n\n\tif (data->bitmask & XT_IPVS_PROTO)\n\t\tif ((iph.protocol == data->l4proto) ^\n\t\t    !(data->invert & XT_IPVS_PROTO)) {\n\t\t\tmatch = false;\n\t\t\tgoto out;\n\t\t}\n\n\tpp = ip_vs_proto_get(iph.protocol);\n\tif (unlikely(!pp)) {\n\t\tmatch = false;\n\t\tgoto out;\n\t}\n\n\t \n\tcp = pp->conn_out_get(ipvs, family, skb, &iph);\n\tif (unlikely(cp == NULL)) {\n\t\tmatch = false;\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (data->bitmask & XT_IPVS_VPORT)\n\t\tif ((cp->vport == data->vport) ^\n\t\t    !(data->invert & XT_IPVS_VPORT)) {\n\t\t\tmatch = false;\n\t\t\tgoto out_put_cp;\n\t\t}\n\n\tif (data->bitmask & XT_IPVS_VPORTCTL)\n\t\tif ((cp->control != NULL &&\n\t\t     cp->control->vport == data->vportctl) ^\n\t\t    !(data->invert & XT_IPVS_VPORTCTL)) {\n\t\t\tmatch = false;\n\t\t\tgoto out_put_cp;\n\t\t}\n\n\tif (data->bitmask & XT_IPVS_DIR) {\n\t\tenum ip_conntrack_info ctinfo;\n\t\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\n\t\tif (ct == NULL) {\n\t\t\tmatch = false;\n\t\t\tgoto out_put_cp;\n\t\t}\n\n\t\tif ((ctinfo >= IP_CT_IS_REPLY) ^\n\t\t    !!(data->invert & XT_IPVS_DIR)) {\n\t\t\tmatch = false;\n\t\t\tgoto out_put_cp;\n\t\t}\n\t}\n\n\tif (data->bitmask & XT_IPVS_METHOD)\n\t\tif (((cp->flags & IP_VS_CONN_F_FWD_MASK) == data->fwd_method) ^\n\t\t    !(data->invert & XT_IPVS_METHOD)) {\n\t\t\tmatch = false;\n\t\t\tgoto out_put_cp;\n\t\t}\n\n\tif (data->bitmask & XT_IPVS_VADDR) {\n\t\tif (ipvs_mt_addrcmp(&cp->vaddr, &data->vaddr,\n\t\t\t\t    &data->vmask, family) ^\n\t\t    !(data->invert & XT_IPVS_VADDR)) {\n\t\t\tmatch = false;\n\t\t\tgoto out_put_cp;\n\t\t}\n\t}\n\nout_put_cp:\n\t__ip_vs_conn_put(cp);\nout:\n\tpr_debug(\"match=%d\\n\", match);\n\treturn match;\n}\n\nstatic int ipvs_mt_check(const struct xt_mtchk_param *par)\n{\n\tif (par->family != NFPROTO_IPV4\n#ifdef CONFIG_IP_VS_IPV6\n\t    && par->family != NFPROTO_IPV6\n#endif\n\t\t) {\n\t\tpr_info_ratelimited(\"protocol family %u not supported\\n\",\n\t\t\t\t    par->family);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_match xt_ipvs_mt_reg __read_mostly = {\n\t.name       = \"ipvs\",\n\t.revision   = 0,\n\t.family     = NFPROTO_UNSPEC,\n\t.match      = ipvs_mt,\n\t.checkentry = ipvs_mt_check,\n\t.matchsize  = XT_ALIGN(sizeof(struct xt_ipvs_mtinfo)),\n\t.me         = THIS_MODULE,\n};\n\nstatic int __init ipvs_mt_init(void)\n{\n\treturn xt_register_match(&xt_ipvs_mt_reg);\n}\n\nstatic void __exit ipvs_mt_exit(void)\n{\n\txt_unregister_match(&xt_ipvs_mt_reg);\n}\n\nmodule_init(ipvs_mt_init);\nmodule_exit(ipvs_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}