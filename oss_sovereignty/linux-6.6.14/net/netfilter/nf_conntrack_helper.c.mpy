{
  "module_name": "nf_conntrack_helper.c",
  "hash_id": "6a24f5a58abb6541858be09603b46aa1c762382edca5724840b23723cef92bf7",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_helper.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/netfilter.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/rculist.h>\n#include <linux/rtnetlink.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_extend.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/nf_log.h>\n#include <net/ip.h>\n\nstatic DEFINE_MUTEX(nf_ct_helper_mutex);\nstruct hlist_head *nf_ct_helper_hash __read_mostly;\nEXPORT_SYMBOL_GPL(nf_ct_helper_hash);\nunsigned int nf_ct_helper_hsize __read_mostly;\nEXPORT_SYMBOL_GPL(nf_ct_helper_hsize);\nstatic unsigned int nf_ct_helper_count __read_mostly;\n\nstatic DEFINE_MUTEX(nf_ct_nat_helpers_mutex);\nstatic struct list_head nf_ct_nat_helpers __read_mostly;\n\n \nstatic unsigned int helper_hash(const struct nf_conntrack_tuple *tuple)\n{\n\treturn (((tuple->src.l3num << 8) | tuple->dst.protonum) ^\n\t\t(__force __u16)tuple->src.u.all) % nf_ct_helper_hsize;\n}\n\nstruct nf_conntrack_helper *\n__nf_conntrack_helper_find(const char *name, u16 l3num, u8 protonum)\n{\n\tstruct nf_conntrack_helper *h;\n\tunsigned int i;\n\n\tfor (i = 0; i < nf_ct_helper_hsize; i++) {\n\t\thlist_for_each_entry_rcu(h, &nf_ct_helper_hash[i], hnode) {\n\t\t\tif (strcmp(h->name, name))\n\t\t\t\tcontinue;\n\n\t\t\tif (h->tuple.src.l3num != NFPROTO_UNSPEC &&\n\t\t\t    h->tuple.src.l3num != l3num)\n\t\t\t\tcontinue;\n\n\t\t\tif (h->tuple.dst.protonum == protonum)\n\t\t\t\treturn h;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(__nf_conntrack_helper_find);\n\nstruct nf_conntrack_helper *\nnf_conntrack_helper_try_module_get(const char *name, u16 l3num, u8 protonum)\n{\n\tstruct nf_conntrack_helper *h;\n\n\trcu_read_lock();\n\n\th = __nf_conntrack_helper_find(name, l3num, protonum);\n#ifdef CONFIG_MODULES\n\tif (h == NULL) {\n\t\trcu_read_unlock();\n\t\tif (request_module(\"nfct-helper-%s\", name) == 0) {\n\t\t\trcu_read_lock();\n\t\t\th = __nf_conntrack_helper_find(name, l3num, protonum);\n\t\t} else {\n\t\t\treturn h;\n\t\t}\n\t}\n#endif\n\tif (h != NULL && !try_module_get(h->me))\n\t\th = NULL;\n\tif (h != NULL && !refcount_inc_not_zero(&h->refcnt)) {\n\t\tmodule_put(h->me);\n\t\th = NULL;\n\t}\n\n\trcu_read_unlock();\n\n\treturn h;\n}\nEXPORT_SYMBOL_GPL(nf_conntrack_helper_try_module_get);\n\nvoid nf_conntrack_helper_put(struct nf_conntrack_helper *helper)\n{\n\trefcount_dec(&helper->refcnt);\n\tmodule_put(helper->me);\n}\nEXPORT_SYMBOL_GPL(nf_conntrack_helper_put);\n\nstatic struct nf_conntrack_nat_helper *\nnf_conntrack_nat_helper_find(const char *mod_name)\n{\n\tstruct nf_conntrack_nat_helper *cur;\n\tbool found = false;\n\n\tlist_for_each_entry_rcu(cur, &nf_ct_nat_helpers, list) {\n\t\tif (!strcmp(cur->mod_name, mod_name)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found ? cur : NULL;\n}\n\nint\nnf_nat_helper_try_module_get(const char *name, u16 l3num, u8 protonum)\n{\n\tstruct nf_conntrack_helper *h;\n\tstruct nf_conntrack_nat_helper *nat;\n\tchar mod_name[NF_CT_HELPER_NAME_LEN];\n\tint ret = 0;\n\n\trcu_read_lock();\n\th = __nf_conntrack_helper_find(name, l3num, protonum);\n\tif (!h) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\tnat = nf_conntrack_nat_helper_find(h->nat_mod_name);\n\tif (!nat) {\n\t\tsnprintf(mod_name, sizeof(mod_name), \"%s\", h->nat_mod_name);\n\t\trcu_read_unlock();\n\t\trequest_module(\"%s\", mod_name);\n\n\t\trcu_read_lock();\n\t\tnat = nf_conntrack_nat_helper_find(mod_name);\n\t\tif (!nat) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (!try_module_get(nat->module))\n\t\tret = -ENOENT;\n\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nf_nat_helper_try_module_get);\n\nvoid nf_nat_helper_put(struct nf_conntrack_helper *helper)\n{\n\tstruct nf_conntrack_nat_helper *nat;\n\n\tnat = nf_conntrack_nat_helper_find(helper->nat_mod_name);\n\tif (WARN_ON_ONCE(!nat))\n\t\treturn;\n\n\tmodule_put(nat->module);\n}\nEXPORT_SYMBOL_GPL(nf_nat_helper_put);\n\nstruct nf_conn_help *\nnf_ct_helper_ext_add(struct nf_conn *ct, gfp_t gfp)\n{\n\tstruct nf_conn_help *help;\n\n\thelp = nf_ct_ext_add(ct, NF_CT_EXT_HELPER, gfp);\n\tif (help)\n\t\tINIT_HLIST_HEAD(&help->expectations);\n\telse\n\t\tpr_debug(\"failed to add helper extension area\");\n\treturn help;\n}\nEXPORT_SYMBOL_GPL(nf_ct_helper_ext_add);\n\nint __nf_ct_try_assign_helper(struct nf_conn *ct, struct nf_conn *tmpl,\n\t\t\t      gfp_t flags)\n{\n\tstruct nf_conntrack_helper *helper = NULL;\n\tstruct nf_conn_help *help;\n\n\t \n\tif (test_bit(IPS_HELPER_BIT, &ct->status))\n\t\treturn 0;\n\n\tif (WARN_ON_ONCE(!tmpl))\n\t\treturn 0;\n\n\thelp = nfct_help(tmpl);\n\tif (help != NULL) {\n\t\thelper = rcu_dereference(help->helper);\n\t\tset_bit(IPS_HELPER_BIT, &ct->status);\n\t}\n\n\thelp = nfct_help(ct);\n\n\tif (helper == NULL) {\n\t\tif (help)\n\t\t\tRCU_INIT_POINTER(help->helper, NULL);\n\t\treturn 0;\n\t}\n\n\tif (help == NULL) {\n\t\thelp = nf_ct_helper_ext_add(ct, flags);\n\t\tif (help == NULL)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\t \n\t\tstruct nf_conntrack_helper *tmp = rcu_dereference(help->helper);\n\n\t\tif (tmp && tmp->help != helper->help) {\n\t\t\tRCU_INIT_POINTER(help->helper, NULL);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trcu_assign_pointer(help->helper, helper);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__nf_ct_try_assign_helper);\n\n \nstatic int unhelp(struct nf_conn *ct, void *me)\n{\n\tstruct nf_conn_help *help = nfct_help(ct);\n\n\tif (help && rcu_dereference_raw(help->helper) == me) {\n\t\tnf_conntrack_event(IPCT_HELPER, ct);\n\t\tRCU_INIT_POINTER(help->helper, NULL);\n\t}\n\n\t \n\treturn 0;\n}\n\nvoid nf_ct_helper_destroy(struct nf_conn *ct)\n{\n\tstruct nf_conn_help *help = nfct_help(ct);\n\tstruct nf_conntrack_helper *helper;\n\n\tif (help) {\n\t\trcu_read_lock();\n\t\thelper = rcu_dereference(help->helper);\n\t\tif (helper && helper->destroy)\n\t\t\thelper->destroy(ct);\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic LIST_HEAD(nf_ct_helper_expectfn_list);\n\nvoid nf_ct_helper_expectfn_register(struct nf_ct_helper_expectfn *n)\n{\n\tspin_lock_bh(&nf_conntrack_expect_lock);\n\tlist_add_rcu(&n->head, &nf_ct_helper_expectfn_list);\n\tspin_unlock_bh(&nf_conntrack_expect_lock);\n}\nEXPORT_SYMBOL_GPL(nf_ct_helper_expectfn_register);\n\nvoid nf_ct_helper_expectfn_unregister(struct nf_ct_helper_expectfn *n)\n{\n\tspin_lock_bh(&nf_conntrack_expect_lock);\n\tlist_del_rcu(&n->head);\n\tspin_unlock_bh(&nf_conntrack_expect_lock);\n}\nEXPORT_SYMBOL_GPL(nf_ct_helper_expectfn_unregister);\n\n \nstruct nf_ct_helper_expectfn *\nnf_ct_helper_expectfn_find_by_name(const char *name)\n{\n\tstruct nf_ct_helper_expectfn *cur;\n\tbool found = false;\n\n\tlist_for_each_entry_rcu(cur, &nf_ct_helper_expectfn_list, head) {\n\t\tif (!strcmp(cur->name, name)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found ? cur : NULL;\n}\nEXPORT_SYMBOL_GPL(nf_ct_helper_expectfn_find_by_name);\n\n \nstruct nf_ct_helper_expectfn *\nnf_ct_helper_expectfn_find_by_symbol(const void *symbol)\n{\n\tstruct nf_ct_helper_expectfn *cur;\n\tbool found = false;\n\n\tlist_for_each_entry_rcu(cur, &nf_ct_helper_expectfn_list, head) {\n\t\tif (cur->expectfn == symbol) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found ? cur : NULL;\n}\nEXPORT_SYMBOL_GPL(nf_ct_helper_expectfn_find_by_symbol);\n\n__printf(3, 4)\nvoid nf_ct_helper_log(struct sk_buff *skb, const struct nf_conn *ct,\n\t\t      const char *fmt, ...)\n{\n\tconst struct nf_conn_help *help;\n\tconst struct nf_conntrack_helper *helper;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t \n\thelp = nfct_help(ct);\n\n\t \n\thelper = rcu_dereference(help->helper);\n\n\tnf_log_packet(nf_ct_net(ct), nf_ct_l3num(ct), 0, skb, NULL, NULL, NULL,\n\t\t      \"nf_ct_%s: dropping packet: %pV \", helper->name, &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(nf_ct_helper_log);\n\nint nf_conntrack_helper_register(struct nf_conntrack_helper *me)\n{\n\tstruct nf_conntrack_tuple_mask mask = { .src.u.all = htons(0xFFFF) };\n\tunsigned int h = helper_hash(&me->tuple);\n\tstruct nf_conntrack_helper *cur;\n\tint ret = 0, i;\n\n\tBUG_ON(me->expect_policy == NULL);\n\tBUG_ON(me->expect_class_max >= NF_CT_MAX_EXPECT_CLASSES);\n\tBUG_ON(strlen(me->name) > NF_CT_HELPER_NAME_LEN - 1);\n\n\tif (!nf_ct_helper_hash)\n\t\treturn -ENOENT;\n\n\tif (me->expect_policy->max_expected > NF_CT_EXPECT_MAX_CNT)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&nf_ct_helper_mutex);\n\tfor (i = 0; i < nf_ct_helper_hsize; i++) {\n\t\thlist_for_each_entry(cur, &nf_ct_helper_hash[i], hnode) {\n\t\t\tif (!strcmp(cur->name, me->name) &&\n\t\t\t    (cur->tuple.src.l3num == NFPROTO_UNSPEC ||\n\t\t\t     cur->tuple.src.l3num == me->tuple.src.l3num) &&\n\t\t\t    cur->tuple.dst.protonum == me->tuple.dst.protonum) {\n\t\t\t\tret = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!(me->flags & NF_CT_HELPER_F_USERSPACE)) {\n\t\thlist_for_each_entry(cur, &nf_ct_helper_hash[h], hnode) {\n\t\t\tif (nf_ct_tuple_src_mask_cmp(&cur->tuple, &me->tuple,\n\t\t\t\t\t\t     &mask)) {\n\t\t\t\tret = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\trefcount_set(&me->refcnt, 1);\n\thlist_add_head_rcu(&me->hnode, &nf_ct_helper_hash[h]);\n\tnf_ct_helper_count++;\nout:\n\tmutex_unlock(&nf_ct_helper_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nf_conntrack_helper_register);\n\nstatic bool expect_iter_me(struct nf_conntrack_expect *exp, void *data)\n{\n\tstruct nf_conn_help *help = nfct_help(exp->master);\n\tconst struct nf_conntrack_helper *me = data;\n\tconst struct nf_conntrack_helper *this;\n\n\tif (exp->helper == me)\n\t\treturn true;\n\n\tthis = rcu_dereference_protected(help->helper,\n\t\t\t\t\t lockdep_is_held(&nf_conntrack_expect_lock));\n\treturn this == me;\n}\n\nvoid nf_conntrack_helper_unregister(struct nf_conntrack_helper *me)\n{\n\tmutex_lock(&nf_ct_helper_mutex);\n\thlist_del_rcu(&me->hnode);\n\tnf_ct_helper_count--;\n\tmutex_unlock(&nf_ct_helper_mutex);\n\n\t \n\tsynchronize_rcu();\n\n\tnf_ct_expect_iterate_destroy(expect_iter_me, NULL);\n\tnf_ct_iterate_destroy(unhelp, me);\n}\nEXPORT_SYMBOL_GPL(nf_conntrack_helper_unregister);\n\nvoid nf_ct_helper_init(struct nf_conntrack_helper *helper,\n\t\t       u16 l3num, u16 protonum, const char *name,\n\t\t       u16 default_port, u16 spec_port, u32 id,\n\t\t       const struct nf_conntrack_expect_policy *exp_pol,\n\t\t       u32 expect_class_max,\n\t\t       int (*help)(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t   struct nf_conn *ct,\n\t\t\t\t   enum ip_conntrack_info ctinfo),\n\t\t       int (*from_nlattr)(struct nlattr *attr,\n\t\t\t\t\t  struct nf_conn *ct),\n\t\t       struct module *module)\n{\n\thelper->tuple.src.l3num = l3num;\n\thelper->tuple.dst.protonum = protonum;\n\thelper->tuple.src.u.all = htons(spec_port);\n\thelper->expect_policy = exp_pol;\n\thelper->expect_class_max = expect_class_max;\n\thelper->help = help;\n\thelper->from_nlattr = from_nlattr;\n\thelper->me = module;\n\tsnprintf(helper->nat_mod_name, sizeof(helper->nat_mod_name),\n\t\t NF_NAT_HELPER_PREFIX \"%s\", name);\n\n\tif (spec_port == default_port)\n\t\tsnprintf(helper->name, sizeof(helper->name), \"%s\", name);\n\telse\n\t\tsnprintf(helper->name, sizeof(helper->name), \"%s-%u\", name, id);\n}\nEXPORT_SYMBOL_GPL(nf_ct_helper_init);\n\nint nf_conntrack_helpers_register(struct nf_conntrack_helper *helper,\n\t\t\t\t  unsigned int n)\n{\n\tunsigned int i;\n\tint err = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\terr = nf_conntrack_helper_register(&helper[i]);\n\t\tif (err < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn err;\nerr:\n\tif (i > 0)\n\t\tnf_conntrack_helpers_unregister(helper, i);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nf_conntrack_helpers_register);\n\nvoid nf_conntrack_helpers_unregister(struct nf_conntrack_helper *helper,\n\t\t\t\tunsigned int n)\n{\n\twhile (n-- > 0)\n\t\tnf_conntrack_helper_unregister(&helper[n]);\n}\nEXPORT_SYMBOL_GPL(nf_conntrack_helpers_unregister);\n\nvoid nf_nat_helper_register(struct nf_conntrack_nat_helper *nat)\n{\n\tmutex_lock(&nf_ct_nat_helpers_mutex);\n\tlist_add_rcu(&nat->list, &nf_ct_nat_helpers);\n\tmutex_unlock(&nf_ct_nat_helpers_mutex);\n}\nEXPORT_SYMBOL_GPL(nf_nat_helper_register);\n\nvoid nf_nat_helper_unregister(struct nf_conntrack_nat_helper *nat)\n{\n\tmutex_lock(&nf_ct_nat_helpers_mutex);\n\tlist_del_rcu(&nat->list);\n\tmutex_unlock(&nf_ct_nat_helpers_mutex);\n}\nEXPORT_SYMBOL_GPL(nf_nat_helper_unregister);\n\nint nf_conntrack_helper_init(void)\n{\n\tnf_ct_helper_hsize = 1;  \n\tnf_ct_helper_hash =\n\t\tnf_ct_alloc_hashtable(&nf_ct_helper_hsize, 0);\n\tif (!nf_ct_helper_hash)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&nf_ct_nat_helpers);\n\treturn 0;\n}\n\nvoid nf_conntrack_helper_fini(void)\n{\n\tkvfree(nf_ct_helper_hash);\n\tnf_ct_helper_hash = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}