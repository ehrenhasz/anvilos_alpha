{
  "module_name": "nf_conntrack_pptp.c",
  "hash_id": "787b91ffd95c3465971b1b6e33943b37809495fff2066e8a7f1c81783fee770a",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_pptp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <linux/netfilter/nf_conntrack_proto_gre.h>\n#include <linux/netfilter/nf_conntrack_pptp.h>\n\n#define NF_CT_PPTP_VERSION \"3.1\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Harald Welte <laforge@gnumonks.org>\");\nMODULE_DESCRIPTION(\"Netfilter connection tracking helper module for PPTP\");\nMODULE_ALIAS(\"ip_conntrack_pptp\");\nMODULE_ALIAS_NFCT_HELPER(\"pptp\");\n\nstatic DEFINE_SPINLOCK(nf_pptp_lock);\n\nconst struct nf_nat_pptp_hook __rcu *nf_nat_pptp_hook;\nEXPORT_SYMBOL_GPL(nf_nat_pptp_hook);\n\n#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)\n \nstatic const char *const pptp_msg_name_array[PPTP_MSG_MAX + 1] = {\n\t[0]\t\t\t\t= \"UNKNOWN_MESSAGE\",\n\t[PPTP_START_SESSION_REQUEST]\t= \"START_SESSION_REQUEST\",\n\t[PPTP_START_SESSION_REPLY]\t= \"START_SESSION_REPLY\",\n\t[PPTP_STOP_SESSION_REQUEST]\t= \"STOP_SESSION_REQUEST\",\n\t[PPTP_STOP_SESSION_REPLY]\t= \"STOP_SESSION_REPLY\",\n\t[PPTP_ECHO_REQUEST]\t\t= \"ECHO_REQUEST\",\n\t[PPTP_ECHO_REPLY]\t\t= \"ECHO_REPLY\",\n\t[PPTP_OUT_CALL_REQUEST]\t\t= \"OUT_CALL_REQUEST\",\n\t[PPTP_OUT_CALL_REPLY]\t\t= \"OUT_CALL_REPLY\",\n\t[PPTP_IN_CALL_REQUEST]\t\t= \"IN_CALL_REQUEST\",\n\t[PPTP_IN_CALL_REPLY]\t\t= \"IN_CALL_REPLY\",\n\t[PPTP_IN_CALL_CONNECT]\t\t= \"IN_CALL_CONNECT\",\n\t[PPTP_CALL_CLEAR_REQUEST]\t= \"CALL_CLEAR_REQUEST\",\n\t[PPTP_CALL_DISCONNECT_NOTIFY]\t= \"CALL_DISCONNECT_NOTIFY\",\n\t[PPTP_WAN_ERROR_NOTIFY]\t\t= \"WAN_ERROR_NOTIFY\",\n\t[PPTP_SET_LINK_INFO]\t\t= \"SET_LINK_INFO\"\n};\n\nconst char *pptp_msg_name(u_int16_t msg)\n{\n\tif (msg > PPTP_MSG_MAX)\n\t\treturn pptp_msg_name_array[0];\n\n\treturn pptp_msg_name_array[msg];\n}\nEXPORT_SYMBOL(pptp_msg_name);\n#endif\n\n#define SECS *HZ\n#define MINS * 60 SECS\n#define HOURS * 60 MINS\n\n#define PPTP_GRE_TIMEOUT \t\t(10 MINS)\n#define PPTP_GRE_STREAM_TIMEOUT \t(5 HOURS)\n\nstatic void pptp_expectfn(struct nf_conn *ct,\n\t\t\t struct nf_conntrack_expect *exp)\n{\n\tconst struct nf_nat_pptp_hook *hook;\n\tstruct net *net = nf_ct_net(ct);\n\tpr_debug(\"increasing timeouts\\n\");\n\n\t \n\tct->proto.gre.timeout\t     = PPTP_GRE_TIMEOUT;\n\tct->proto.gre.stream_timeout = PPTP_GRE_STREAM_TIMEOUT;\n\n\t \n\n\thook = rcu_dereference(nf_nat_pptp_hook);\n\tif (hook && ct->master->status & IPS_NAT_MASK)\n\t\thook->expectfn(ct, exp);\n\telse {\n\t\tstruct nf_conntrack_tuple inv_t;\n\t\tstruct nf_conntrack_expect *exp_other;\n\n\t\t \n\t\tnf_ct_invert_tuple(&inv_t, &exp->tuple);\n\t\tpr_debug(\"trying to unexpect other dir: \");\n\t\tnf_ct_dump_tuple(&inv_t);\n\n\t\texp_other = nf_ct_expect_find_get(net, nf_ct_zone(ct), &inv_t);\n\t\tif (exp_other) {\n\t\t\t \n\t\t\tpr_debug(\"found\\n\");\n\t\t\tnf_ct_unexpect_related(exp_other);\n\t\t\tnf_ct_expect_put(exp_other);\n\t\t} else {\n\t\t\tpr_debug(\"not found\\n\");\n\t\t}\n\t}\n}\n\nstatic int destroy_sibling_or_exp(struct net *net, struct nf_conn *ct,\n\t\t\t\t  const struct nf_conntrack_tuple *t)\n{\n\tconst struct nf_conntrack_tuple_hash *h;\n\tconst struct nf_conntrack_zone *zone;\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conn *sibling;\n\n\tpr_debug(\"trying to timeout ct or exp for tuple \");\n\tnf_ct_dump_tuple(t);\n\n\tzone = nf_ct_zone(ct);\n\th = nf_conntrack_find_get(net, zone, t);\n\tif (h)  {\n\t\tsibling = nf_ct_tuplehash_to_ctrack(h);\n\t\tpr_debug(\"setting timeout of conntrack %p to 0\\n\", sibling);\n\t\tsibling->proto.gre.timeout\t  = 0;\n\t\tsibling->proto.gre.stream_timeout = 0;\n\t\tnf_ct_kill(sibling);\n\t\tnf_ct_put(sibling);\n\t\treturn 1;\n\t} else {\n\t\texp = nf_ct_expect_find_get(net, zone, t);\n\t\tif (exp) {\n\t\t\tpr_debug(\"unexpect_related of expect %p\\n\", exp);\n\t\t\tnf_ct_unexpect_related(exp);\n\t\t\tnf_ct_expect_put(exp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void pptp_destroy_siblings(struct nf_conn *ct)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tconst struct nf_ct_pptp_master *ct_pptp_info = nfct_help_data(ct);\n\tstruct nf_conntrack_tuple t;\n\n\tnf_ct_gre_keymap_destroy(ct);\n\n\t \n\tmemcpy(&t, &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple, sizeof(t));\n\tt.dst.protonum = IPPROTO_GRE;\n\tt.src.u.gre.key = ct_pptp_info->pns_call_id;\n\tt.dst.u.gre.key = ct_pptp_info->pac_call_id;\n\tif (!destroy_sibling_or_exp(net, ct, &t))\n\t\tpr_debug(\"failed to timeout original pns->pac ct/exp\\n\");\n\n\t \n\tmemcpy(&t, &ct->tuplehash[IP_CT_DIR_REPLY].tuple, sizeof(t));\n\tt.dst.protonum = IPPROTO_GRE;\n\tt.src.u.gre.key = ct_pptp_info->pac_call_id;\n\tt.dst.u.gre.key = ct_pptp_info->pns_call_id;\n\tif (!destroy_sibling_or_exp(net, ct, &t))\n\t\tpr_debug(\"failed to timeout reply pac->pns ct/exp\\n\");\n}\n\n \nstatic int exp_gre(struct nf_conn *ct, __be16 callid, __be16 peer_callid)\n{\n\tstruct nf_conntrack_expect *exp_orig, *exp_reply;\n\tconst struct nf_nat_pptp_hook *hook;\n\tenum ip_conntrack_dir dir;\n\tint ret = 1;\n\n\texp_orig = nf_ct_expect_alloc(ct);\n\tif (exp_orig == NULL)\n\t\tgoto out;\n\n\texp_reply = nf_ct_expect_alloc(ct);\n\tif (exp_reply == NULL)\n\t\tgoto out_put_orig;\n\n\t \n\tdir = IP_CT_DIR_ORIGINAL;\n\tnf_ct_expect_init(exp_orig, NF_CT_EXPECT_CLASS_DEFAULT,\n\t\t\t  nf_ct_l3num(ct),\n\t\t\t  &ct->tuplehash[dir].tuple.src.u3,\n\t\t\t  &ct->tuplehash[dir].tuple.dst.u3,\n\t\t\t  IPPROTO_GRE, &peer_callid, &callid);\n\texp_orig->expectfn = pptp_expectfn;\n\n\t \n\tdir = IP_CT_DIR_REPLY;\n\tnf_ct_expect_init(exp_reply, NF_CT_EXPECT_CLASS_DEFAULT,\n\t\t\t  nf_ct_l3num(ct),\n\t\t\t  &ct->tuplehash[dir].tuple.src.u3,\n\t\t\t  &ct->tuplehash[dir].tuple.dst.u3,\n\t\t\t  IPPROTO_GRE, &callid, &peer_callid);\n\texp_reply->expectfn = pptp_expectfn;\n\n\thook = rcu_dereference(nf_nat_pptp_hook);\n\tif (hook && ct->status & IPS_NAT_MASK)\n\t\thook->exp_gre(exp_orig, exp_reply);\n\tif (nf_ct_expect_related(exp_orig, 0) != 0)\n\t\tgoto out_put_both;\n\tif (nf_ct_expect_related(exp_reply, 0) != 0)\n\t\tgoto out_unexpect_orig;\n\n\t \n\tif (nf_ct_gre_keymap_add(ct, IP_CT_DIR_ORIGINAL, &exp_orig->tuple) != 0)\n\t\tgoto out_unexpect_both;\n\tif (nf_ct_gre_keymap_add(ct, IP_CT_DIR_REPLY, &exp_reply->tuple) != 0) {\n\t\tnf_ct_gre_keymap_destroy(ct);\n\t\tgoto out_unexpect_both;\n\t}\n\tret = 0;\n\nout_put_both:\n\tnf_ct_expect_put(exp_reply);\nout_put_orig:\n\tnf_ct_expect_put(exp_orig);\nout:\n\treturn ret;\n\nout_unexpect_both:\n\tnf_ct_unexpect_related(exp_reply);\nout_unexpect_orig:\n\tnf_ct_unexpect_related(exp_orig);\n\tgoto out_put_both;\n}\n\nstatic int\npptp_inbound_pkt(struct sk_buff *skb, unsigned int protoff,\n\t\t struct PptpControlHeader *ctlh,\n\t\t union pptp_ctrl_union *pptpReq,\n\t\t unsigned int reqlen,\n\t\t struct nf_conn *ct,\n\t\t enum ip_conntrack_info ctinfo)\n{\n\tstruct nf_ct_pptp_master *info = nfct_help_data(ct);\n\tconst struct nf_nat_pptp_hook *hook;\n\tu_int16_t msg;\n\t__be16 cid = 0, pcid = 0;\n\n\tmsg = ntohs(ctlh->messageType);\n\tpr_debug(\"inbound control message %s\\n\", pptp_msg_name(msg));\n\n\tswitch (msg) {\n\tcase PPTP_START_SESSION_REPLY:\n\t\t \n\t\tif (info->sstate < PPTP_SESSION_REQUESTED)\n\t\t\tgoto invalid;\n\t\tif (pptpReq->srep.resultCode == PPTP_START_OK)\n\t\t\tinfo->sstate = PPTP_SESSION_CONFIRMED;\n\t\telse\n\t\t\tinfo->sstate = PPTP_SESSION_ERROR;\n\t\tbreak;\n\n\tcase PPTP_STOP_SESSION_REPLY:\n\t\t \n\t\tif (info->sstate > PPTP_SESSION_STOPREQ)\n\t\t\tgoto invalid;\n\t\tif (pptpReq->strep.resultCode == PPTP_STOP_OK)\n\t\t\tinfo->sstate = PPTP_SESSION_NONE;\n\t\telse\n\t\t\tinfo->sstate = PPTP_SESSION_ERROR;\n\t\tbreak;\n\n\tcase PPTP_OUT_CALL_REPLY:\n\t\t \n\t\tif (info->sstate != PPTP_SESSION_CONFIRMED)\n\t\t\tgoto invalid;\n\t\tif (info->cstate != PPTP_CALL_OUT_REQ &&\n\t\t    info->cstate != PPTP_CALL_OUT_CONF)\n\t\t\tgoto invalid;\n\n\t\tcid = pptpReq->ocack.callID;\n\t\tpcid = pptpReq->ocack.peersCallID;\n\t\tif (info->pns_call_id != pcid)\n\t\t\tgoto invalid;\n\t\tpr_debug(\"%s, CID=%X, PCID=%X\\n\", pptp_msg_name(msg),\n\t\t\t ntohs(cid), ntohs(pcid));\n\n\t\tif (pptpReq->ocack.resultCode == PPTP_OUTCALL_CONNECT) {\n\t\t\tinfo->cstate = PPTP_CALL_OUT_CONF;\n\t\t\tinfo->pac_call_id = cid;\n\t\t\texp_gre(ct, cid, pcid);\n\t\t} else\n\t\t\tinfo->cstate = PPTP_CALL_NONE;\n\t\tbreak;\n\n\tcase PPTP_IN_CALL_REQUEST:\n\t\t \n\t\tif (info->sstate != PPTP_SESSION_CONFIRMED)\n\t\t\tgoto invalid;\n\n\t\tcid = pptpReq->icreq.callID;\n\t\tpr_debug(\"%s, CID=%X\\n\", pptp_msg_name(msg), ntohs(cid));\n\t\tinfo->cstate = PPTP_CALL_IN_REQ;\n\t\tinfo->pac_call_id = cid;\n\t\tbreak;\n\n\tcase PPTP_IN_CALL_CONNECT:\n\t\t \n\t\tif (info->sstate != PPTP_SESSION_CONFIRMED)\n\t\t\tgoto invalid;\n\t\tif (info->cstate != PPTP_CALL_IN_REP &&\n\t\t    info->cstate != PPTP_CALL_IN_CONF)\n\t\t\tgoto invalid;\n\n\t\tpcid = pptpReq->iccon.peersCallID;\n\t\tcid = info->pac_call_id;\n\n\t\tif (info->pns_call_id != pcid)\n\t\t\tgoto invalid;\n\n\t\tpr_debug(\"%s, PCID=%X\\n\", pptp_msg_name(msg), ntohs(pcid));\n\t\tinfo->cstate = PPTP_CALL_IN_CONF;\n\n\t\t \n\t\texp_gre(ct, cid, pcid);\n\t\tbreak;\n\n\tcase PPTP_CALL_DISCONNECT_NOTIFY:\n\t\t \n\t\tcid = pptpReq->disc.callID;\n\t\tpr_debug(\"%s, CID=%X\\n\", pptp_msg_name(msg), ntohs(cid));\n\t\tinfo->cstate = PPTP_CALL_NONE;\n\n\t\t \n\t\tpptp_destroy_siblings(ct);\n\t\tbreak;\n\n\tcase PPTP_WAN_ERROR_NOTIFY:\n\tcase PPTP_SET_LINK_INFO:\n\tcase PPTP_ECHO_REQUEST:\n\tcase PPTP_ECHO_REPLY:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tgoto invalid;\n\t}\n\n\thook = rcu_dereference(nf_nat_pptp_hook);\n\tif (hook && ct->status & IPS_NAT_MASK)\n\t\treturn hook->inbound(skb, ct, ctinfo, protoff, ctlh, pptpReq);\n\treturn NF_ACCEPT;\n\ninvalid:\n\tpr_debug(\"invalid %s: type=%d cid=%u pcid=%u \"\n\t\t \"cstate=%d sstate=%d pns_cid=%u pac_cid=%u\\n\",\n\t\t pptp_msg_name(msg),\n\t\t msg, ntohs(cid), ntohs(pcid),  info->cstate, info->sstate,\n\t\t ntohs(info->pns_call_id), ntohs(info->pac_call_id));\n\treturn NF_ACCEPT;\n}\n\nstatic int\npptp_outbound_pkt(struct sk_buff *skb, unsigned int protoff,\n\t\t  struct PptpControlHeader *ctlh,\n\t\t  union pptp_ctrl_union *pptpReq,\n\t\t  unsigned int reqlen,\n\t\t  struct nf_conn *ct,\n\t\t  enum ip_conntrack_info ctinfo)\n{\n\tstruct nf_ct_pptp_master *info = nfct_help_data(ct);\n\tconst struct nf_nat_pptp_hook *hook;\n\tu_int16_t msg;\n\t__be16 cid = 0, pcid = 0;\n\n\tmsg = ntohs(ctlh->messageType);\n\tpr_debug(\"outbound control message %s\\n\", pptp_msg_name(msg));\n\n\tswitch (msg) {\n\tcase PPTP_START_SESSION_REQUEST:\n\t\t \n\t\tif (info->sstate != PPTP_SESSION_NONE)\n\t\t\tgoto invalid;\n\t\tinfo->sstate = PPTP_SESSION_REQUESTED;\n\t\tbreak;\n\n\tcase PPTP_STOP_SESSION_REQUEST:\n\t\t \n\t\tinfo->sstate = PPTP_SESSION_STOPREQ;\n\t\tbreak;\n\n\tcase PPTP_OUT_CALL_REQUEST:\n\t\t \n\t\tif (info->sstate != PPTP_SESSION_CONFIRMED)\n\t\t\tgoto invalid;\n\t\tinfo->cstate = PPTP_CALL_OUT_REQ;\n\t\t \n\t\tcid = pptpReq->ocreq.callID;\n\t\tpr_debug(\"%s, CID=%X\\n\", pptp_msg_name(msg), ntohs(cid));\n\t\tinfo->pns_call_id = cid;\n\t\tbreak;\n\n\tcase PPTP_IN_CALL_REPLY:\n\t\t \n\t\tif (info->cstate != PPTP_CALL_IN_REQ &&\n\t\t    info->cstate != PPTP_CALL_IN_REP)\n\t\t\tgoto invalid;\n\n\t\tcid = pptpReq->icack.callID;\n\t\tpcid = pptpReq->icack.peersCallID;\n\t\tif (info->pac_call_id != pcid)\n\t\t\tgoto invalid;\n\t\tpr_debug(\"%s, CID=%X PCID=%X\\n\", pptp_msg_name(msg),\n\t\t\t ntohs(cid), ntohs(pcid));\n\n\t\tif (pptpReq->icack.resultCode == PPTP_INCALL_ACCEPT) {\n\t\t\t \n\t\t\tinfo->cstate = PPTP_CALL_IN_REP;\n\t\t\tinfo->pns_call_id = cid;\n\t\t} else\n\t\t\tinfo->cstate = PPTP_CALL_NONE;\n\t\tbreak;\n\n\tcase PPTP_CALL_CLEAR_REQUEST:\n\t\t \n\t\tif (info->sstate != PPTP_SESSION_CONFIRMED)\n\t\t\tgoto invalid;\n\t\t \n\t\tinfo->cstate = PPTP_CALL_CLEAR_REQ;\n\t\tbreak;\n\n\tcase PPTP_SET_LINK_INFO:\n\tcase PPTP_ECHO_REQUEST:\n\tcase PPTP_ECHO_REPLY:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tgoto invalid;\n\t}\n\n\thook = rcu_dereference(nf_nat_pptp_hook);\n\tif (hook && ct->status & IPS_NAT_MASK)\n\t\treturn hook->outbound(skb, ct, ctinfo, protoff, ctlh, pptpReq);\n\treturn NF_ACCEPT;\n\ninvalid:\n\tpr_debug(\"invalid %s: type=%d cid=%u pcid=%u \"\n\t\t \"cstate=%d sstate=%d pns_cid=%u pac_cid=%u\\n\",\n\t\t pptp_msg_name(msg),\n\t\t msg, ntohs(cid), ntohs(pcid),  info->cstate, info->sstate,\n\t\t ntohs(info->pns_call_id), ntohs(info->pac_call_id));\n\treturn NF_ACCEPT;\n}\n\nstatic const unsigned int pptp_msg_size[] = {\n\t[PPTP_START_SESSION_REQUEST]  = sizeof(struct PptpStartSessionRequest),\n\t[PPTP_START_SESSION_REPLY]    = sizeof(struct PptpStartSessionReply),\n\t[PPTP_STOP_SESSION_REQUEST]   = sizeof(struct PptpStopSessionRequest),\n\t[PPTP_STOP_SESSION_REPLY]     = sizeof(struct PptpStopSessionReply),\n\t[PPTP_OUT_CALL_REQUEST]       = sizeof(struct PptpOutCallRequest),\n\t[PPTP_OUT_CALL_REPLY]\t      = sizeof(struct PptpOutCallReply),\n\t[PPTP_IN_CALL_REQUEST]\t      = sizeof(struct PptpInCallRequest),\n\t[PPTP_IN_CALL_REPLY]\t      = sizeof(struct PptpInCallReply),\n\t[PPTP_IN_CALL_CONNECT]\t      = sizeof(struct PptpInCallConnected),\n\t[PPTP_CALL_CLEAR_REQUEST]     = sizeof(struct PptpClearCallRequest),\n\t[PPTP_CALL_DISCONNECT_NOTIFY] = sizeof(struct PptpCallDisconnectNotify),\n\t[PPTP_WAN_ERROR_NOTIFY]\t      = sizeof(struct PptpWanErrorNotify),\n\t[PPTP_SET_LINK_INFO]\t      = sizeof(struct PptpSetLinkInfo),\n};\n\n \nstatic int\nconntrack_pptp_help(struct sk_buff *skb, unsigned int protoff,\n\t\t    struct nf_conn *ct, enum ip_conntrack_info ctinfo)\n\n{\n\tint dir = CTINFO2DIR(ctinfo);\n\tconst struct nf_ct_pptp_master *info = nfct_help_data(ct);\n\tconst struct tcphdr *tcph;\n\tstruct tcphdr _tcph;\n\tconst struct pptp_pkt_hdr *pptph;\n\tstruct pptp_pkt_hdr _pptph;\n\tstruct PptpControlHeader _ctlh, *ctlh;\n\tunion pptp_ctrl_union _pptpReq, *pptpReq;\n\tunsigned int tcplen = skb->len - protoff;\n\tunsigned int datalen, reqlen, nexthdr_off;\n\tint oldsstate, oldcstate;\n\tint ret;\n\tu_int16_t msg;\n\n#if IS_ENABLED(CONFIG_NF_NAT)\n\tif (!nf_ct_is_confirmed(ct) && (ct->status & IPS_NAT_MASK)) {\n\t\tstruct nf_conn_nat *nat = nf_ct_ext_find(ct, NF_CT_EXT_NAT);\n\n\t\tif (!nat && !nf_ct_ext_add(ct, NF_CT_EXT_NAT, GFP_ATOMIC))\n\t\t\treturn NF_DROP;\n\t}\n#endif\n\t \n\tif (ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED_REPLY)\n\t\treturn NF_ACCEPT;\n\n\tnexthdr_off = protoff;\n\ttcph = skb_header_pointer(skb, nexthdr_off, sizeof(_tcph), &_tcph);\n\tif (!tcph)\n\t\treturn NF_ACCEPT;\n\n\tnexthdr_off += tcph->doff * 4;\n\tdatalen = tcplen - tcph->doff * 4;\n\n\tpptph = skb_header_pointer(skb, nexthdr_off, sizeof(_pptph), &_pptph);\n\tif (!pptph) {\n\t\tpr_debug(\"no full PPTP header, can't track\\n\");\n\t\treturn NF_ACCEPT;\n\t}\n\tnexthdr_off += sizeof(_pptph);\n\tdatalen -= sizeof(_pptph);\n\n\t \n\tif (ntohs(pptph->packetType) != PPTP_PACKET_CONTROL ||\n\t    ntohl(pptph->magicCookie) != PPTP_MAGIC_COOKIE) {\n\t\tpr_debug(\"not a control packet\\n\");\n\t\treturn NF_ACCEPT;\n\t}\n\n\tctlh = skb_header_pointer(skb, nexthdr_off, sizeof(_ctlh), &_ctlh);\n\tif (!ctlh)\n\t\treturn NF_ACCEPT;\n\tnexthdr_off += sizeof(_ctlh);\n\tdatalen -= sizeof(_ctlh);\n\n\treqlen = datalen;\n\tmsg = ntohs(ctlh->messageType);\n\tif (msg > 0 && msg <= PPTP_MSG_MAX && reqlen < pptp_msg_size[msg])\n\t\treturn NF_ACCEPT;\n\tif (reqlen > sizeof(*pptpReq))\n\t\treqlen = sizeof(*pptpReq);\n\n\tpptpReq = skb_header_pointer(skb, nexthdr_off, reqlen, &_pptpReq);\n\tif (!pptpReq)\n\t\treturn NF_ACCEPT;\n\n\toldsstate = info->sstate;\n\toldcstate = info->cstate;\n\n\tspin_lock_bh(&nf_pptp_lock);\n\n\t \n\tif (dir == IP_CT_DIR_ORIGINAL)\n\t\t \n\t\tret = pptp_outbound_pkt(skb, protoff, ctlh, pptpReq, reqlen, ct,\n\t\t\t\t\tctinfo);\n\telse\n\t\t \n\t\tret = pptp_inbound_pkt(skb, protoff, ctlh, pptpReq, reqlen, ct,\n\t\t\t\t       ctinfo);\n\tpr_debug(\"sstate: %d->%d, cstate: %d->%d\\n\",\n\t\t oldsstate, info->sstate, oldcstate, info->cstate);\n\tspin_unlock_bh(&nf_pptp_lock);\n\n\treturn ret;\n}\n\nstatic const struct nf_conntrack_expect_policy pptp_exp_policy = {\n\t.max_expected\t= 2,\n\t.timeout\t= 5 * 60,\n};\n\n \nstatic struct nf_conntrack_helper pptp __read_mostly = {\n\t.name\t\t\t= \"pptp\",\n\t.me\t\t\t= THIS_MODULE,\n\t.tuple.src.l3num\t= AF_INET,\n\t.tuple.src.u.tcp.port\t= cpu_to_be16(PPTP_CONTROL_PORT),\n\t.tuple.dst.protonum\t= IPPROTO_TCP,\n\t.help\t\t\t= conntrack_pptp_help,\n\t.destroy\t\t= pptp_destroy_siblings,\n\t.expect_policy\t\t= &pptp_exp_policy,\n};\n\nstatic int __init nf_conntrack_pptp_init(void)\n{\n\tNF_CT_HELPER_BUILD_BUG_ON(sizeof(struct nf_ct_pptp_master));\n\n\treturn nf_conntrack_helper_register(&pptp);\n}\n\nstatic void __exit nf_conntrack_pptp_fini(void)\n{\n\tnf_conntrack_helper_unregister(&pptp);\n}\n\nmodule_init(nf_conntrack_pptp_init);\nmodule_exit(nf_conntrack_pptp_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}