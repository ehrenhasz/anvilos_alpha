{
  "module_name": "nf_conntrack_timeout.c",
  "hash_id": "08574e4d20b701526d4f26c2fa875ff2523a7666accae53bb1330b89958858f3",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_timeout.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/netfilter.h>\n#include <linux/skbuff.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/err.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_extend.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n\nconst struct nf_ct_timeout_hooks __rcu *nf_ct_timeout_hook __read_mostly;\nEXPORT_SYMBOL_GPL(nf_ct_timeout_hook);\n\nstatic int untimeout(struct nf_conn *ct, void *timeout)\n{\n\tstruct nf_conn_timeout *timeout_ext = nf_ct_timeout_find(ct);\n\n\tif (timeout_ext) {\n\t\tconst struct nf_ct_timeout *t;\n\n\t\tt = rcu_access_pointer(timeout_ext->timeout);\n\n\t\tif (!timeout || t == timeout)\n\t\t\tRCU_INIT_POINTER(timeout_ext->timeout, NULL);\n\t}\n\n\t \n\treturn 0;\n}\n\nvoid nf_ct_untimeout(struct net *net, struct nf_ct_timeout *timeout)\n{\n\tstruct nf_ct_iter_data iter_data = {\n\t\t.net\t= net,\n\t\t.data\t= timeout,\n\t};\n\n\tnf_ct_iterate_cleanup_net(untimeout, &iter_data);\n}\nEXPORT_SYMBOL_GPL(nf_ct_untimeout);\n\nstatic void __nf_ct_timeout_put(struct nf_ct_timeout *timeout)\n{\n\tconst struct nf_ct_timeout_hooks *h = rcu_dereference(nf_ct_timeout_hook);\n\n\tif (h)\n\t\th->timeout_put(timeout);\n}\n\nint nf_ct_set_timeout(struct net *net, struct nf_conn *ct,\n\t\t      u8 l3num, u8 l4num, const char *timeout_name)\n{\n\tconst struct nf_ct_timeout_hooks *h;\n\tstruct nf_ct_timeout *timeout;\n\tstruct nf_conn_timeout *timeout_ext;\n\tconst char *errmsg = NULL;\n\tint ret = 0;\n\n\trcu_read_lock();\n\th = rcu_dereference(nf_ct_timeout_hook);\n\tif (!h) {\n\t\tret = -ENOENT;\n\t\terrmsg = \"Timeout policy base is empty\";\n\t\tgoto out;\n\t}\n\n\ttimeout = h->timeout_find_get(net, timeout_name);\n\tif (!timeout) {\n\t\tret = -ENOENT;\n\t\tpr_info_ratelimited(\"No such timeout policy \\\"%s\\\"\\n\",\n\t\t\t\t    timeout_name);\n\t\tgoto out;\n\t}\n\n\tif (timeout->l3num != l3num) {\n\t\tret = -EINVAL;\n\t\tpr_info_ratelimited(\"Timeout policy `%s' can only be used by \"\n\t\t\t\t    \"L%d protocol number %d\\n\",\n\t\t\t\t    timeout_name, 3, timeout->l3num);\n\t\tgoto err_put_timeout;\n\t}\n\t \n\tif (timeout->l4proto->l4proto != l4num) {\n\t\tret = -EINVAL;\n\t\tpr_info_ratelimited(\"Timeout policy `%s' can only be used by \"\n\t\t\t\t    \"L%d protocol number %d\\n\",\n\t\t\t\t    timeout_name, 4, timeout->l4proto->l4proto);\n\t\tgoto err_put_timeout;\n\t}\n\ttimeout_ext = nf_ct_timeout_ext_add(ct, timeout, GFP_ATOMIC);\n\tif (!timeout_ext) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_timeout;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n\nerr_put_timeout:\n\t__nf_ct_timeout_put(timeout);\nout:\n\trcu_read_unlock();\n\tif (errmsg)\n\t\tpr_info_ratelimited(\"%s\\n\", errmsg);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nf_ct_set_timeout);\n\nvoid nf_ct_destroy_timeout(struct nf_conn *ct)\n{\n\tstruct nf_conn_timeout *timeout_ext;\n\tconst struct nf_ct_timeout_hooks *h;\n\n\trcu_read_lock();\n\th = rcu_dereference(nf_ct_timeout_hook);\n\n\tif (h) {\n\t\ttimeout_ext = nf_ct_timeout_find(ct);\n\t\tif (timeout_ext) {\n\t\t\tstruct nf_ct_timeout *t;\n\n\t\t\tt = rcu_dereference(timeout_ext->timeout);\n\t\t\tif (t)\n\t\t\t\th->timeout_put(t);\n\t\t\tRCU_INIT_POINTER(timeout_ext->timeout, NULL);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(nf_ct_destroy_timeout);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}