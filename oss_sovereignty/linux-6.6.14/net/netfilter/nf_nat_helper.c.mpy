{
  "module_name": "nf_nat_helper.c",
  "hash_id": "9b2e621b9eab4d71372c641fc8d6a43b1c336aac057e6c5a89cf5ed45cd4a6de",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_nat_helper.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <net/tcp.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_nat_helper.h>\n\n \nstatic void mangle_contents(struct sk_buff *skb,\n\t\t\t    unsigned int dataoff,\n\t\t\t    unsigned int match_offset,\n\t\t\t    unsigned int match_len,\n\t\t\t    const char *rep_buffer,\n\t\t\t    unsigned int rep_len)\n{\n\tunsigned char *data;\n\n\tSKB_LINEAR_ASSERT(skb);\n\tdata = skb_network_header(skb) + dataoff;\n\n\t \n\tmemmove(data + match_offset + rep_len,\n\t\tdata + match_offset + match_len,\n\t\tskb_tail_pointer(skb) - (skb_network_header(skb) + dataoff +\n\t\t\t     match_offset + match_len));\n\n\t \n\tmemcpy(data + match_offset, rep_buffer, rep_len);\n\n\t \n\tif (rep_len > match_len) {\n\t\tpr_debug(\"nf_nat_mangle_packet: Extending packet by \"\n\t\t\t \"%u from %u bytes\\n\", rep_len - match_len, skb->len);\n\t\tskb_put(skb, rep_len - match_len);\n\t} else {\n\t\tpr_debug(\"nf_nat_mangle_packet: Shrinking packet from \"\n\t\t\t \"%u from %u bytes\\n\", match_len - rep_len, skb->len);\n\t\t__skb_trim(skb, skb->len + rep_len - match_len);\n\t}\n\n\tif (nf_ct_l3num((struct nf_conn *)skb_nfct(skb)) == NFPROTO_IPV4) {\n\t\t \n\t\tip_hdr(skb)->tot_len = htons(skb->len);\n\t\tip_send_check(ip_hdr(skb));\n\t} else\n\t\tipv6_hdr(skb)->payload_len =\n\t\t\thtons(skb->len - sizeof(struct ipv6hdr));\n}\n\n \nstatic bool enlarge_skb(struct sk_buff *skb, unsigned int extra)\n{\n\tif (skb->len + extra > 65535)\n\t\treturn false;\n\n\tif (pskb_expand_head(skb, 0, extra - skb_tailroom(skb), GFP_ATOMIC))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nbool __nf_nat_mangle_tcp_packet(struct sk_buff *skb,\n\t\t\t\tstruct nf_conn *ct,\n\t\t\t\tenum ip_conntrack_info ctinfo,\n\t\t\t\tunsigned int protoff,\n\t\t\t\tunsigned int match_offset,\n\t\t\t\tunsigned int match_len,\n\t\t\t\tconst char *rep_buffer,\n\t\t\t\tunsigned int rep_len, bool adjust)\n{\n\tstruct tcphdr *tcph;\n\tint oldlen, datalen;\n\n\tif (skb_ensure_writable(skb, skb->len))\n\t\treturn false;\n\n\tif (rep_len > match_len &&\n\t    rep_len - match_len > skb_tailroom(skb) &&\n\t    !enlarge_skb(skb, rep_len - match_len))\n\t\treturn false;\n\n\ttcph = (void *)skb->data + protoff;\n\n\toldlen = skb->len - protoff;\n\tmangle_contents(skb, protoff + tcph->doff*4,\n\t\t\tmatch_offset, match_len, rep_buffer, rep_len);\n\n\tdatalen = skb->len - protoff;\n\n\tnf_nat_csum_recalc(skb, nf_ct_l3num(ct), IPPROTO_TCP,\n\t\t\t   tcph, &tcph->check, datalen, oldlen);\n\n\tif (adjust && rep_len != match_len)\n\t\tnf_ct_seqadj_set(ct, ctinfo, tcph->seq,\n\t\t\t\t (int)rep_len - (int)match_len);\n\n\treturn true;\n}\nEXPORT_SYMBOL(__nf_nat_mangle_tcp_packet);\n\n \nbool\nnf_nat_mangle_udp_packet(struct sk_buff *skb,\n\t\t\t struct nf_conn *ct,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int match_offset,\n\t\t\t unsigned int match_len,\n\t\t\t const char *rep_buffer,\n\t\t\t unsigned int rep_len)\n{\n\tstruct udphdr *udph;\n\tint datalen, oldlen;\n\n\tif (skb_ensure_writable(skb, skb->len))\n\t\treturn false;\n\n\tif (rep_len > match_len &&\n\t    rep_len - match_len > skb_tailroom(skb) &&\n\t    !enlarge_skb(skb, rep_len - match_len))\n\t\treturn false;\n\n\tudph = (void *)skb->data + protoff;\n\n\toldlen = skb->len - protoff;\n\tmangle_contents(skb, protoff + sizeof(*udph),\n\t\t\tmatch_offset, match_len, rep_buffer, rep_len);\n\n\t \n\tdatalen = skb->len - protoff;\n\tudph->len = htons(datalen);\n\n\t \n\tif (!udph->check && skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn true;\n\n\tnf_nat_csum_recalc(skb, nf_ct_l3num(ct), IPPROTO_UDP,\n\t\t\t   udph, &udph->check, datalen, oldlen);\n\n\treturn true;\n}\nEXPORT_SYMBOL(nf_nat_mangle_udp_packet);\n\n \n \nvoid nf_nat_follow_master(struct nf_conn *ct,\n\t\t\t  struct nf_conntrack_expect *exp)\n{\n\tstruct nf_nat_range2 range;\n\n\t \n\tBUG_ON(ct->status & IPS_NAT_DONE_MASK);\n\n\t \n\trange.flags = NF_NAT_RANGE_MAP_IPS;\n\trange.min_addr = range.max_addr\n\t\t= ct->master->tuplehash[!exp->dir].tuple.dst.u3;\n\tnf_nat_setup_info(ct, &range, NF_NAT_MANIP_SRC);\n\n\t \n\trange.flags = (NF_NAT_RANGE_MAP_IPS | NF_NAT_RANGE_PROTO_SPECIFIED);\n\trange.min_proto = range.max_proto = exp->saved_proto;\n\trange.min_addr = range.max_addr\n\t\t= ct->master->tuplehash[!exp->dir].tuple.src.u3;\n\tnf_nat_setup_info(ct, &range, NF_NAT_MANIP_DST);\n}\nEXPORT_SYMBOL(nf_nat_follow_master);\n\nu16 nf_nat_exp_find_port(struct nf_conntrack_expect *exp, u16 port)\n{\n\tstatic const unsigned int max_attempts = 128;\n\tint range, attempts_left;\n\tu16 min = port;\n\n\trange = USHRT_MAX - port;\n\tattempts_left = range;\n\n\tif (attempts_left > max_attempts)\n\t\tattempts_left = max_attempts;\n\n\t \n\tfor (;;) {\n\t\tint res;\n\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tres = nf_ct_expect_related(exp, 0);\n\t\tif (res == 0)\n\t\t\treturn port;\n\n\t\tif (res != -EBUSY || (--attempts_left < 0))\n\t\t\tbreak;\n\n\t\tport = min + get_random_u32_below(range);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_nat_exp_find_port);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}