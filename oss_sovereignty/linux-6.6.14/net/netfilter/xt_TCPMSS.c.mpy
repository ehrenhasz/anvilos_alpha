{
  "module_name": "xt_TCPMSS.c",
  "hash_id": "bd35fd66dee9925326163fb5591a9cab112fdb6e1d11bcc00f193ee879cd95c2",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_TCPMSS.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <net/dst.h>\n#include <net/flow.h>\n#include <net/ipv6.h>\n#include <net/route.h>\n#include <net/tcp.h>\n\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_tcpudp.h>\n#include <linux/netfilter/xt_TCPMSS.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Marc Boucher <marc@mbsi.ca>\");\nMODULE_DESCRIPTION(\"Xtables: TCP Maximum Segment Size (MSS) adjustment\");\nMODULE_ALIAS(\"ipt_TCPMSS\");\nMODULE_ALIAS(\"ip6t_TCPMSS\");\n\nstatic inline unsigned int\noptlen(const u_int8_t *opt, unsigned int offset)\n{\n\t \n\tif (opt[offset] <= TCPOPT_NOP || opt[offset+1] == 0)\n\t\treturn 1;\n\telse\n\t\treturn opt[offset+1];\n}\n\nstatic u_int32_t tcpmss_reverse_mtu(struct net *net,\n\t\t\t\t    const struct sk_buff *skb,\n\t\t\t\t    unsigned int family)\n{\n\tstruct flowi fl;\n\tstruct rtable *rt = NULL;\n\tu_int32_t mtu     = ~0U;\n\n\tif (family == PF_INET) {\n\t\tstruct flowi4 *fl4 = &fl.u.ip4;\n\t\tmemset(fl4, 0, sizeof(*fl4));\n\t\tfl4->daddr = ip_hdr(skb)->saddr;\n\t} else {\n\t\tstruct flowi6 *fl6 = &fl.u.ip6;\n\n\t\tmemset(fl6, 0, sizeof(*fl6));\n\t\tfl6->daddr = ipv6_hdr(skb)->saddr;\n\t}\n\n\tnf_route(net, (struct dst_entry **)&rt, &fl, false, family);\n\tif (rt != NULL) {\n\t\tmtu = dst_mtu(&rt->dst);\n\t\tdst_release(&rt->dst);\n\t}\n\treturn mtu;\n}\n\nstatic int\ntcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     const struct xt_action_param *par,\n\t\t     unsigned int family,\n\t\t     unsigned int tcphoff,\n\t\t     unsigned int minlen)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tstruct tcphdr *tcph;\n\tint len, tcp_hdrlen;\n\tunsigned int i;\n\t__be16 oldval;\n\tu16 newmss;\n\tu8 *opt;\n\n\t \n\tif (par->fragoff != 0)\n\t\treturn 0;\n\n\tif (skb_ensure_writable(skb, skb->len))\n\t\treturn -1;\n\n\tlen = skb->len - tcphoff;\n\tif (len < (int)sizeof(struct tcphdr))\n\t\treturn -1;\n\n\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\ttcp_hdrlen = tcph->doff * 4;\n\n\tif (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))\n\t\treturn -1;\n\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tstruct net *net = xt_net(par);\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t\tunsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);\n\n\t\tif (min_mtu <= minlen) {\n\t\t\tnet_err_ratelimited(\"unknown or invalid path-MTU (%u)\\n\",\n\t\t\t\t\t    min_mtu);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmss = min_mtu - minlen;\n\t} else\n\t\tnewmss = info->mss;\n\n\topt = (u_int8_t *)tcph;\n\tfor (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {\n\t\tif (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {\n\t\t\tu_int16_t oldmss;\n\n\t\t\toldmss = (opt[i+2] << 8) | opt[i+3];\n\n\t\t\t \n\t\t\tif (oldmss <= newmss)\n\t\t\t\treturn 0;\n\n\t\t\topt[i+2] = (newmss & 0xff00) >> 8;\n\t\t\topt[i+3] = newmss & 0x00ff;\n\n\t\t\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t\t\t htons(oldmss), htons(newmss),\n\t\t\t\t\t\t false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (len > tcp_hdrlen)\n\t\treturn 0;\n\n\t \n\tif (tcp_hdrlen >= 15 * 4)\n\t\treturn 0;\n\n\t \n\tif (skb_tailroom(skb) < TCPOLEN_MSS) {\n\t\tif (pskb_expand_head(skb, 0,\n\t\t\t\t     TCPOLEN_MSS - skb_tailroom(skb),\n\t\t\t\t     GFP_ATOMIC))\n\t\t\treturn -1;\n\t\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\t}\n\n\tskb_put(skb, TCPOLEN_MSS);\n\n\t \n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\tnewmss = min(newmss, (u16)536);\n\telse\n\t\tnewmss = min(newmss, (u16)1220);\n\n\topt = (u_int8_t *)tcph + sizeof(struct tcphdr);\n\tmemmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));\n\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t htons(len), htons(len + TCPOLEN_MSS), true);\n\topt[0] = TCPOPT_MSS;\n\topt[1] = TCPOLEN_MSS;\n\topt[2] = (newmss & 0xff00) >> 8;\n\topt[3] = newmss & 0x00ff;\n\n\tinet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);\n\n\toldval = ((__be16 *)tcph)[6];\n\ttcph->doff += TCPOLEN_MSS/4;\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn TCPOLEN_MSS;\n}\n\nstatic unsigned int\ntcpmss_tg4(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tstruct iphdr *iph = ip_hdr(skb);\n\t__be16 newlen;\n\tint ret;\n\n\tret = tcpmss_mangle_packet(skb, par,\n\t\t\t\t   PF_INET,\n\t\t\t\t   iph->ihl * 4,\n\t\t\t\t   sizeof(*iph) + sizeof(struct tcphdr));\n\tif (ret < 0)\n\t\treturn NF_DROP;\n\tif (ret > 0) {\n\t\tiph = ip_hdr(skb);\n\t\tnewlen = htons(ntohs(iph->tot_len) + ret);\n\t\tcsum_replace2(&iph->check, iph->tot_len, newlen);\n\t\tiph->tot_len = newlen;\n\t}\n\treturn XT_CONTINUE;\n}\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nstatic unsigned int\ntcpmss_tg6(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tu8 nexthdr;\n\t__be16 frag_off, oldlen, newlen;\n\tint tcphoff;\n\tint ret;\n\n\tnexthdr = ipv6h->nexthdr;\n\ttcphoff = ipv6_skip_exthdr(skb, sizeof(*ipv6h), &nexthdr, &frag_off);\n\tif (tcphoff < 0)\n\t\treturn NF_DROP;\n\tret = tcpmss_mangle_packet(skb, par,\n\t\t\t\t   PF_INET6,\n\t\t\t\t   tcphoff,\n\t\t\t\t   sizeof(*ipv6h) + sizeof(struct tcphdr));\n\tif (ret < 0)\n\t\treturn NF_DROP;\n\tif (ret > 0) {\n\t\tipv6h = ipv6_hdr(skb);\n\t\toldlen = ipv6h->payload_len;\n\t\tnewlen = htons(ntohs(oldlen) + ret);\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\t\tskb->csum = csum_add(csum_sub(skb->csum, (__force __wsum)oldlen),\n\t\t\t\t\t     (__force __wsum)newlen);\n\t\tipv6h->payload_len = newlen;\n\t}\n\treturn XT_CONTINUE;\n}\n#endif\n\n \nstatic inline bool find_syn_match(const struct xt_entry_match *m)\n{\n\tconst struct xt_tcp *tcpinfo = (const struct xt_tcp *)m->data;\n\n\tif (strcmp(m->u.kernel.match->name, \"tcp\") == 0 &&\n\t    tcpinfo->flg_cmp & TCPHDR_SYN &&\n\t    !(tcpinfo->invflags & XT_TCP_INV_FLAGS))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int tcpmss_tg4_check(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tconst struct ipt_entry *e = par->entryinfo;\n\tconst struct xt_entry_match *ematch;\n\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU &&\n\t    (par->hook_mask & ~((1 << NF_INET_FORWARD) |\n\t\t\t   (1 << NF_INET_LOCAL_OUT) |\n\t\t\t   (1 << NF_INET_POST_ROUTING))) != 0) {\n\t\tpr_info_ratelimited(\"path-MTU clamping only supported in FORWARD, OUTPUT and POSTROUTING hooks\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (par->nft_compat)\n\t\treturn 0;\n\n\txt_ematch_foreach(ematch, e)\n\t\tif (find_syn_match(ematch))\n\t\t\treturn 0;\n\tpr_info_ratelimited(\"Only works on TCP SYN packets\\n\");\n\treturn -EINVAL;\n}\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nstatic int tcpmss_tg6_check(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tconst struct ip6t_entry *e = par->entryinfo;\n\tconst struct xt_entry_match *ematch;\n\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU &&\n\t    (par->hook_mask & ~((1 << NF_INET_FORWARD) |\n\t\t\t   (1 << NF_INET_LOCAL_OUT) |\n\t\t\t   (1 << NF_INET_POST_ROUTING))) != 0) {\n\t\tpr_info_ratelimited(\"path-MTU clamping only supported in FORWARD, OUTPUT and POSTROUTING hooks\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (par->nft_compat)\n\t\treturn 0;\n\n\txt_ematch_foreach(ematch, e)\n\t\tif (find_syn_match(ematch))\n\t\t\treturn 0;\n\tpr_info_ratelimited(\"Only works on TCP SYN packets\\n\");\n\treturn -EINVAL;\n}\n#endif\n\nstatic struct xt_target tcpmss_tg_reg[] __read_mostly = {\n\t{\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.name\t\t= \"TCPMSS\",\n\t\t.checkentry\t= tcpmss_tg4_check,\n\t\t.target\t\t= tcpmss_tg4,\n\t\t.targetsize\t= sizeof(struct xt_tcpmss_info),\n\t\t.proto\t\t= IPPROTO_TCP,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\t{\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.name\t\t= \"TCPMSS\",\n\t\t.checkentry\t= tcpmss_tg6_check,\n\t\t.target\t\t= tcpmss_tg6,\n\t\t.targetsize\t= sizeof(struct xt_tcpmss_info),\n\t\t.proto\t\t= IPPROTO_TCP,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#endif\n};\n\nstatic int __init tcpmss_tg_init(void)\n{\n\treturn xt_register_targets(tcpmss_tg_reg, ARRAY_SIZE(tcpmss_tg_reg));\n}\n\nstatic void __exit tcpmss_tg_exit(void)\n{\n\txt_unregister_targets(tcpmss_tg_reg, ARRAY_SIZE(tcpmss_tg_reg));\n}\n\nmodule_init(tcpmss_tg_init);\nmodule_exit(tcpmss_tg_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}