{
  "module_name": "nft_synproxy.c",
  "hash_id": "6f54877a3cf847660c33a62c2f3e1c2f5aa733ecc0315d8ea0fc1b21958deead",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_synproxy.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <net/netlink.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_synproxy.h>\n#include <net/netfilter/nf_synproxy.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/netfilter/nf_synproxy.h>\n\nstruct nft_synproxy {\n\tstruct nf_synproxy_info\tinfo;\n};\n\nstatic const struct nla_policy nft_synproxy_policy[NFTA_SYNPROXY_MAX + 1] = {\n\t[NFTA_SYNPROXY_MSS]\t\t= { .type = NLA_U16 },\n\t[NFTA_SYNPROXY_WSCALE]\t\t= { .type = NLA_U8 },\n\t[NFTA_SYNPROXY_FLAGS]\t\t= { .type = NLA_U32 },\n};\n\nstatic void nft_synproxy_tcp_options(struct synproxy_options *opts,\n\t\t\t\t     const struct tcphdr *tcp,\n\t\t\t\t     struct synproxy_net *snet,\n\t\t\t\t     struct nf_synproxy_info *info,\n\t\t\t\t     const struct nft_synproxy *priv)\n{\n\tthis_cpu_inc(snet->stats->syn_received);\n\tif (tcp->ece && tcp->cwr)\n\t\topts->options |= NF_SYNPROXY_OPT_ECN;\n\n\topts->options &= priv->info.options;\n\topts->mss_encode = opts->mss_option;\n\topts->mss_option = info->mss;\n\tif (opts->options & NF_SYNPROXY_OPT_TIMESTAMP)\n\t\tsynproxy_init_timestamp_cookie(info, opts);\n\telse\n\t\topts->options &= ~(NF_SYNPROXY_OPT_WSCALE |\n\t\t\t\t   NF_SYNPROXY_OPT_SACK_PERM |\n\t\t\t\t   NF_SYNPROXY_OPT_ECN);\n}\n\nstatic void nft_synproxy_eval_v4(const struct nft_synproxy *priv,\n\t\t\t\t struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt,\n\t\t\t\t const struct tcphdr *tcp,\n\t\t\t\t struct tcphdr *_tcph,\n\t\t\t\t struct synproxy_options *opts)\n{\n\tstruct nf_synproxy_info info = priv->info;\n\tstruct net *net = nft_net(pkt);\n\tstruct synproxy_net *snet = synproxy_pernet(net);\n\tstruct sk_buff *skb = pkt->skb;\n\n\tif (tcp->syn) {\n\t\t \n\t\tnft_synproxy_tcp_options(opts, tcp, snet, &info, priv);\n\t\tsynproxy_send_client_synack(net, skb, tcp, opts);\n\t\tconsume_skb(skb);\n\t\tregs->verdict.code = NF_STOLEN;\n\t} else if (tcp->ack) {\n\t\t \n\t\tif (synproxy_recv_client_ack(net, skb, tcp, opts,\n\t\t\t\t\t     ntohl(tcp->seq))) {\n\t\t\tconsume_skb(skb);\n\t\t\tregs->verdict.code = NF_STOLEN;\n\t\t} else {\n\t\t\tregs->verdict.code = NF_DROP;\n\t\t}\n\t}\n}\n\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\nstatic void nft_synproxy_eval_v6(const struct nft_synproxy *priv,\n\t\t\t\t struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt,\n\t\t\t\t const struct tcphdr *tcp,\n\t\t\t\t struct tcphdr *_tcph,\n\t\t\t\t struct synproxy_options *opts)\n{\n\tstruct nf_synproxy_info info = priv->info;\n\tstruct net *net = nft_net(pkt);\n\tstruct synproxy_net *snet = synproxy_pernet(net);\n\tstruct sk_buff *skb = pkt->skb;\n\n\tif (tcp->syn) {\n\t\t \n\t\tnft_synproxy_tcp_options(opts, tcp, snet, &info, priv);\n\t\tsynproxy_send_client_synack_ipv6(net, skb, tcp, opts);\n\t\tconsume_skb(skb);\n\t\tregs->verdict.code = NF_STOLEN;\n\t} else if (tcp->ack) {\n\t\t \n\t\tif (synproxy_recv_client_ack_ipv6(net, skb, tcp, opts,\n\t\t\t\t\t\t  ntohl(tcp->seq))) {\n\t\t\tconsume_skb(skb);\n\t\t\tregs->verdict.code = NF_STOLEN;\n\t\t} else {\n\t\t\tregs->verdict.code = NF_DROP;\n\t\t}\n\t}\n}\n#endif  \n\nstatic void nft_synproxy_do_eval(const struct nft_synproxy *priv,\n\t\t\t\t struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct synproxy_options opts = {};\n\tstruct sk_buff *skb = pkt->skb;\n\tint thoff = nft_thoff(pkt);\n\tconst struct tcphdr *tcp;\n\tstruct tcphdr _tcph;\n\n\tif (pkt->tprot != IPPROTO_TCP) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tif (nf_ip_checksum(skb, nft_hook(pkt), thoff, IPPROTO_TCP)) {\n\t\tregs->verdict.code = NF_DROP;\n\t\treturn;\n\t}\n\n\ttcp = skb_header_pointer(skb, thoff,\n\t\t\t\t sizeof(struct tcphdr),\n\t\t\t\t &_tcph);\n\tif (!tcp) {\n\t\tregs->verdict.code = NF_DROP;\n\t\treturn;\n\t}\n\n\tif (!synproxy_parse_options(skb, thoff, tcp, &opts)) {\n\t\tregs->verdict.code = NF_DROP;\n\t\treturn;\n\t}\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tnft_synproxy_eval_v4(priv, regs, pkt, tcp, &_tcph, &opts);\n\t\treturn;\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tnft_synproxy_eval_v6(priv, regs, pkt, tcp, &_tcph, &opts);\n\t\treturn;\n#endif\n\t}\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic int nft_synproxy_do_init(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nlattr * const tb[],\n\t\t\t\tstruct nft_synproxy *priv)\n{\n\tstruct synproxy_net *snet = synproxy_pernet(ctx->net);\n\tu32 flags;\n\tint err;\n\n\tif (tb[NFTA_SYNPROXY_MSS])\n\t\tpriv->info.mss = ntohs(nla_get_be16(tb[NFTA_SYNPROXY_MSS]));\n\tif (tb[NFTA_SYNPROXY_WSCALE])\n\t\tpriv->info.wscale = nla_get_u8(tb[NFTA_SYNPROXY_WSCALE]);\n\tif (tb[NFTA_SYNPROXY_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(tb[NFTA_SYNPROXY_FLAGS]));\n\t\tif (flags & ~NF_SYNPROXY_OPT_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t\tpriv->info.options = flags;\n\t}\n\n\terr = nf_ct_netns_get(ctx->net, ctx->family);\n\tif (err)\n\t\treturn err;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_IPV4:\n\t\terr = nf_synproxy_ipv4_init(snet, ctx->net);\n\t\tif (err)\n\t\t\tgoto nf_ct_failure;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\tcase NFPROTO_IPV6:\n\t\terr = nf_synproxy_ipv6_init(snet, ctx->net);\n\t\tif (err)\n\t\t\tgoto nf_ct_failure;\n\t\tbreak;\n#endif\n\tcase NFPROTO_INET:\n\tcase NFPROTO_BRIDGE:\n\t\terr = nf_synproxy_ipv4_init(snet, ctx->net);\n\t\tif (err)\n\t\t\tgoto nf_ct_failure;\n\t\terr = nf_synproxy_ipv6_init(snet, ctx->net);\n\t\tif (err) {\n\t\t\tnf_synproxy_ipv4_fini(snet, ctx->net);\n\t\t\tgoto nf_ct_failure;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nnf_ct_failure:\n\tnf_ct_netns_put(ctx->net, ctx->family);\n\treturn err;\n}\n\nstatic void nft_synproxy_do_destroy(const struct nft_ctx *ctx)\n{\n\tstruct synproxy_net *snet = synproxy_pernet(ctx->net);\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_IPV4:\n\t\tnf_synproxy_ipv4_fini(snet, ctx->net);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\tcase NFPROTO_IPV6:\n\t\tnf_synproxy_ipv6_fini(snet, ctx->net);\n\t\tbreak;\n#endif\n\tcase NFPROTO_INET:\n\tcase NFPROTO_BRIDGE:\n\t\tnf_synproxy_ipv4_fini(snet, ctx->net);\n\t\tnf_synproxy_ipv6_fini(snet, ctx->net);\n\t\tbreak;\n\t}\n\tnf_ct_netns_put(ctx->net, ctx->family);\n}\n\nstatic int nft_synproxy_do_dump(struct sk_buff *skb, struct nft_synproxy *priv)\n{\n\tif (nla_put_be16(skb, NFTA_SYNPROXY_MSS, htons(priv->info.mss)) ||\n\t    nla_put_u8(skb, NFTA_SYNPROXY_WSCALE, priv->info.wscale) ||\n\t    nla_put_be32(skb, NFTA_SYNPROXY_FLAGS, htonl(priv->info.options)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic void nft_synproxy_eval(const struct nft_expr *expr,\n\t\t\t      struct nft_regs *regs,\n\t\t\t      const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_synproxy *priv = nft_expr_priv(expr);\n\n\tnft_synproxy_do_eval(priv, regs, pkt);\n}\n\nstatic int nft_synproxy_validate(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_expr *expr,\n\t\t\t\t const struct nft_data **data)\n{\n\treturn nft_chain_validate_hooks(ctx->chain, (1 << NF_INET_LOCAL_IN) |\n\t\t\t\t\t\t    (1 << NF_INET_FORWARD));\n}\n\nstatic int nft_synproxy_init(const struct nft_ctx *ctx,\n\t\t\t     const struct nft_expr *expr,\n\t\t\t     const struct nlattr * const tb[])\n{\n\tstruct nft_synproxy *priv = nft_expr_priv(expr);\n\n\treturn nft_synproxy_do_init(ctx, tb, priv);\n}\n\nstatic void nft_synproxy_destroy(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_expr *expr)\n{\n\tnft_synproxy_do_destroy(ctx);\n}\n\nstatic int nft_synproxy_dump(struct sk_buff *skb,\n\t\t\t     const struct nft_expr *expr, bool reset)\n{\n\tstruct nft_synproxy *priv = nft_expr_priv(expr);\n\n\treturn nft_synproxy_do_dump(skb, priv);\n}\n\nstatic struct nft_expr_type nft_synproxy_type;\nstatic const struct nft_expr_ops nft_synproxy_ops = {\n\t.eval\t\t= nft_synproxy_eval,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_synproxy)),\n\t.init\t\t= nft_synproxy_init,\n\t.destroy\t= nft_synproxy_destroy,\n\t.dump\t\t= nft_synproxy_dump,\n\t.type\t\t= &nft_synproxy_type,\n\t.validate\t= nft_synproxy_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_synproxy_type __read_mostly = {\n\t.ops\t\t= &nft_synproxy_ops,\n\t.name\t\t= \"synproxy\",\n\t.owner\t\t= THIS_MODULE,\n\t.policy\t\t= nft_synproxy_policy,\n\t.maxattr\t= NFTA_SYNPROXY_MAX,\n};\n\nstatic int nft_synproxy_obj_init(const struct nft_ctx *ctx,\n\t\t\t\t const struct nlattr * const tb[],\n\t\t\t\t struct nft_object *obj)\n{\n\tstruct nft_synproxy *priv = nft_obj_data(obj);\n\n\treturn nft_synproxy_do_init(ctx, tb, priv);\n}\n\nstatic void nft_synproxy_obj_destroy(const struct nft_ctx *ctx,\n\t\t\t\t     struct nft_object *obj)\n{\n\tnft_synproxy_do_destroy(ctx);\n}\n\nstatic int nft_synproxy_obj_dump(struct sk_buff *skb,\n\t\t\t\t struct nft_object *obj, bool reset)\n{\n\tstruct nft_synproxy *priv = nft_obj_data(obj);\n\n\treturn nft_synproxy_do_dump(skb, priv);\n}\n\nstatic void nft_synproxy_obj_eval(struct nft_object *obj,\n\t\t\t\t  struct nft_regs *regs,\n\t\t\t\t  const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_synproxy *priv = nft_obj_data(obj);\n\n\tnft_synproxy_do_eval(priv, regs, pkt);\n}\n\nstatic void nft_synproxy_obj_update(struct nft_object *obj,\n\t\t\t\t    struct nft_object *newobj)\n{\n\tstruct nft_synproxy *newpriv = nft_obj_data(newobj);\n\tstruct nft_synproxy *priv = nft_obj_data(obj);\n\n\tpriv->info = newpriv->info;\n}\n\nstatic struct nft_object_type nft_synproxy_obj_type;\nstatic const struct nft_object_ops nft_synproxy_obj_ops = {\n\t.type\t\t= &nft_synproxy_obj_type,\n\t.size\t\t= sizeof(struct nft_synproxy),\n\t.init\t\t= nft_synproxy_obj_init,\n\t.destroy\t= nft_synproxy_obj_destroy,\n\t.dump\t\t= nft_synproxy_obj_dump,\n\t.eval\t\t= nft_synproxy_obj_eval,\n\t.update\t\t= nft_synproxy_obj_update,\n};\n\nstatic struct nft_object_type nft_synproxy_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_SYNPROXY,\n\t.ops\t\t= &nft_synproxy_obj_ops,\n\t.maxattr\t= NFTA_SYNPROXY_MAX,\n\t.policy\t\t= nft_synproxy_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_synproxy_module_init(void)\n{\n\tint err;\n\n\terr = nft_register_obj(&nft_synproxy_obj_type);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_register_expr(&nft_synproxy_type);\n\tif (err < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tnft_unregister_obj(&nft_synproxy_obj_type);\n\treturn err;\n}\n\nstatic void __exit nft_synproxy_module_exit(void)\n{\n\tnft_unregister_expr(&nft_synproxy_type);\n\tnft_unregister_obj(&nft_synproxy_obj_type);\n}\n\nmodule_init(nft_synproxy_module_init);\nmodule_exit(nft_synproxy_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Fernando Fernandez <ffmancera@riseup.net>\");\nMODULE_ALIAS_NFT_EXPR(\"synproxy\");\nMODULE_ALIAS_NFT_OBJ(NFT_OBJECT_SYNPROXY);\nMODULE_DESCRIPTION(\"nftables SYNPROXY expression support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}