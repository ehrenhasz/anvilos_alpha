{
  "module_name": "xt_HMARK.c",
  "hash_id": "0a79a01b912dc0b203ab89f47facbab9b290eddb8f18870290490cde4506fd7c",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_HMARK.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/icmp.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_HMARK.h>\n\n#include <net/ip.h>\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <net/netfilter/nf_conntrack.h>\n#endif\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n#include <net/ipv6.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#endif\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Hans Schillstrom <hans.schillstrom@ericsson.com>\");\nMODULE_DESCRIPTION(\"Xtables: packet marking using hash calculation\");\nMODULE_ALIAS(\"ipt_HMARK\");\nMODULE_ALIAS(\"ip6t_HMARK\");\n\nstruct hmark_tuple {\n\t__be32\t\t\tsrc;\n\t__be32\t\t\tdst;\n\tunion hmark_ports\tuports;\n\tu8\t\t\tproto;\n};\n\nstatic inline __be32 hmark_addr6_mask(const __be32 *addr32, const __be32 *mask)\n{\n\treturn (addr32[0] & mask[0]) ^\n\t       (addr32[1] & mask[1]) ^\n\t       (addr32[2] & mask[2]) ^\n\t       (addr32[3] & mask[3]);\n}\n\nstatic inline __be32\nhmark_addr_mask(int l3num, const __be32 *addr32, const __be32 *mask)\n{\n\tswitch (l3num) {\n\tcase AF_INET:\n\t\treturn *addr32 & *mask;\n\tcase AF_INET6:\n\t\treturn hmark_addr6_mask(addr32, mask);\n\t}\n\treturn 0;\n}\n\nstatic inline void hmark_swap_ports(union hmark_ports *uports,\n\t\t\t\t    const struct xt_hmark_info *info)\n{\n\tunion hmark_ports hp;\n\tu16 src, dst;\n\n\thp.b32 = (uports->b32 & info->port_mask.b32) | info->port_set.b32;\n\tsrc = ntohs(hp.b16.src);\n\tdst = ntohs(hp.b16.dst);\n\n\tif (dst > src)\n\t\tuports->v32 = (dst << 16) | src;\n\telse\n\t\tuports->v32 = (src << 16) | dst;\n}\n\nstatic int\nhmark_ct_set_htuple(const struct sk_buff *skb, struct hmark_tuple *t,\n\t\t    const struct xt_hmark_info *info)\n{\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct nf_conntrack_tuple *otuple;\n\tstruct nf_conntrack_tuple *rtuple;\n\n\tif (ct == NULL)\n\t\treturn -1;\n\n\totuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\trtuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;\n\n\tt->src = hmark_addr_mask(otuple->src.l3num, otuple->src.u3.ip6,\n\t\t\t\t info->src_mask.ip6);\n\tt->dst = hmark_addr_mask(otuple->src.l3num, rtuple->src.u3.ip6,\n\t\t\t\t info->dst_mask.ip6);\n\n\tif (info->flags & XT_HMARK_FLAG(XT_HMARK_METHOD_L3))\n\t\treturn 0;\n\n\tt->proto = nf_ct_protonum(ct);\n\tif (t->proto != IPPROTO_ICMP) {\n\t\tt->uports.b16.src = otuple->src.u.all;\n\t\tt->uports.b16.dst = rtuple->src.u.all;\n\t\thmark_swap_ports(&t->uports, info);\n\t}\n\n\treturn 0;\n#else\n\treturn -1;\n#endif\n}\n\n \nstatic inline u32\nhmark_hash(struct hmark_tuple *t, const struct xt_hmark_info *info)\n{\n\tu32 hash;\n\tu32 src = ntohl(t->src);\n\tu32 dst = ntohl(t->dst);\n\n\tif (dst < src)\n\t\tswap(src, dst);\n\n\thash = jhash_3words(src, dst, t->uports.v32, info->hashrnd);\n\thash = hash ^ (t->proto & info->proto_mask);\n\n\treturn reciprocal_scale(hash, info->hmodulus) + info->hoffset;\n}\n\nstatic void\nhmark_set_tuple_ports(const struct sk_buff *skb, unsigned int nhoff,\n\t\t      struct hmark_tuple *t, const struct xt_hmark_info *info)\n{\n\tint protoff;\n\n\tprotoff = proto_ports_offset(t->proto);\n\tif (protoff < 0)\n\t\treturn;\n\n\tnhoff += protoff;\n\tif (skb_copy_bits(skb, nhoff, &t->uports, sizeof(t->uports)) < 0)\n\t\treturn;\n\n\thmark_swap_ports(&t->uports, info);\n}\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nstatic int get_inner6_hdr(const struct sk_buff *skb, int *offset)\n{\n\tstruct icmp6hdr *icmp6h, _ih6;\n\n\ticmp6h = skb_header_pointer(skb, *offset, sizeof(_ih6), &_ih6);\n\tif (icmp6h == NULL)\n\t\treturn 0;\n\n\tif (icmp6h->icmp6_type && icmp6h->icmp6_type < 128) {\n\t\t*offset += sizeof(struct icmp6hdr);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\nhmark_pkt_set_htuple_ipv6(const struct sk_buff *skb, struct hmark_tuple *t,\n\t\t\t  const struct xt_hmark_info *info)\n{\n\tstruct ipv6hdr *ip6, _ip6;\n\tint flag = IP6_FH_F_AUTH;\n\tunsigned int nhoff = 0;\n\tu16 fragoff = 0;\n\tint nexthdr;\n\n\tip6 = (struct ipv6hdr *) (skb->data + skb_network_offset(skb));\n\tnexthdr = ipv6_find_hdr(skb, &nhoff, -1, &fragoff, &flag);\n\tif (nexthdr < 0)\n\t\treturn 0;\n\t \n\tif ((flag & IP6_FH_F_FRAG) || (nexthdr != IPPROTO_ICMPV6))\n\t\tgoto noicmp;\n\t \n\tif (get_inner6_hdr(skb, &nhoff)) {\n\t\tip6 = skb_header_pointer(skb, nhoff, sizeof(_ip6), &_ip6);\n\t\tif (ip6 == NULL)\n\t\t\treturn -1;\n\t\t \n\t\tflag = IP6_FH_F_AUTH;\n\t\tnexthdr = ipv6_find_hdr(skb, &nhoff, -1, &fragoff, &flag);\n\t\tif (nexthdr < 0)\n\t\t\treturn -1;\n\t}\nnoicmp:\n\tt->src = hmark_addr6_mask(ip6->saddr.s6_addr32, info->src_mask.ip6);\n\tt->dst = hmark_addr6_mask(ip6->daddr.s6_addr32, info->dst_mask.ip6);\n\n\tif (info->flags & XT_HMARK_FLAG(XT_HMARK_METHOD_L3))\n\t\treturn 0;\n\n\tt->proto = nexthdr;\n\tif (t->proto == IPPROTO_ICMPV6)\n\t\treturn 0;\n\n\tif (flag & IP6_FH_F_FRAG)\n\t\treturn 0;\n\n\thmark_set_tuple_ports(skb, nhoff, t, info);\n\treturn 0;\n}\n\nstatic unsigned int\nhmark_tg_v6(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_hmark_info *info = par->targinfo;\n\tstruct hmark_tuple t;\n\n\tmemset(&t, 0, sizeof(struct hmark_tuple));\n\n\tif (info->flags & XT_HMARK_FLAG(XT_HMARK_CT)) {\n\t\tif (hmark_ct_set_htuple(skb, &t, info) < 0)\n\t\t\treturn XT_CONTINUE;\n\t} else {\n\t\tif (hmark_pkt_set_htuple_ipv6(skb, &t, info) < 0)\n\t\t\treturn XT_CONTINUE;\n\t}\n\n\tskb->mark = hmark_hash(&t, info);\n\treturn XT_CONTINUE;\n}\n#endif\n\nstatic int get_inner_hdr(const struct sk_buff *skb, int iphsz, int *nhoff)\n{\n\tconst struct icmphdr *icmph;\n\tstruct icmphdr _ih;\n\n\t \n\ticmph = skb_header_pointer(skb, *nhoff + iphsz, sizeof(_ih), &_ih);\n\tif (icmph == NULL || icmph->type > NR_ICMP_TYPES)\n\t\treturn 0;\n\n\t \n\tif (!icmp_is_err(icmph->type))\n\t\treturn 0;\n\n\t*nhoff += iphsz + sizeof(_ih);\n\treturn 1;\n}\n\nstatic int\nhmark_pkt_set_htuple_ipv4(const struct sk_buff *skb, struct hmark_tuple *t,\n\t\t\t  const struct xt_hmark_info *info)\n{\n\tstruct iphdr *ip, _ip;\n\tint nhoff = skb_network_offset(skb);\n\n\tip = (struct iphdr *) (skb->data + nhoff);\n\tif (ip->protocol == IPPROTO_ICMP) {\n\t\t \n\t\tif (get_inner_hdr(skb, ip->ihl * 4, &nhoff)) {\n\t\t\tip = skb_header_pointer(skb, nhoff, sizeof(_ip), &_ip);\n\t\t\tif (ip == NULL)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tt->src = ip->saddr & info->src_mask.ip;\n\tt->dst = ip->daddr & info->dst_mask.ip;\n\n\tif (info->flags & XT_HMARK_FLAG(XT_HMARK_METHOD_L3))\n\t\treturn 0;\n\n\tt->proto = ip->protocol;\n\n\t \n\tif (t->proto == IPPROTO_ICMP)\n\t\treturn 0;\n\n\t \n\tif (ip_is_fragment(ip))\n\t\treturn 0;\n\n\thmark_set_tuple_ports(skb, (ip->ihl * 4) + nhoff, t, info);\n\n\treturn 0;\n}\n\nstatic unsigned int\nhmark_tg_v4(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_hmark_info *info = par->targinfo;\n\tstruct hmark_tuple t;\n\n\tmemset(&t, 0, sizeof(struct hmark_tuple));\n\n\tif (info->flags & XT_HMARK_FLAG(XT_HMARK_CT)) {\n\t\tif (hmark_ct_set_htuple(skb, &t, info) < 0)\n\t\t\treturn XT_CONTINUE;\n\t} else {\n\t\tif (hmark_pkt_set_htuple_ipv4(skb, &t, info) < 0)\n\t\t\treturn XT_CONTINUE;\n\t}\n\n\tskb->mark = hmark_hash(&t, info);\n\treturn XT_CONTINUE;\n}\n\nstatic int hmark_tg_check(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_hmark_info *info = par->targinfo;\n\tconst char *errmsg = \"proto mask must be zero with L3 mode\";\n\n\tif (!info->hmodulus)\n\t\treturn -EINVAL;\n\n\tif (info->proto_mask &&\n\t    (info->flags & XT_HMARK_FLAG(XT_HMARK_METHOD_L3)))\n\t\tgoto err;\n\n\tif (info->flags & XT_HMARK_FLAG(XT_HMARK_SPI_MASK) &&\n\t    (info->flags & (XT_HMARK_FLAG(XT_HMARK_SPORT_MASK) |\n\t\t\t     XT_HMARK_FLAG(XT_HMARK_DPORT_MASK))))\n\t\treturn -EINVAL;\n\n\tif (info->flags & XT_HMARK_FLAG(XT_HMARK_SPI) &&\n\t    (info->flags & (XT_HMARK_FLAG(XT_HMARK_SPORT) |\n\t\t\t     XT_HMARK_FLAG(XT_HMARK_DPORT)))) {\n\t\terrmsg = \"spi-set and port-set can't be combined\";\n\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tpr_info_ratelimited(\"%s\\n\", errmsg);\n\treturn -EINVAL;\n}\n\nstatic struct xt_target hmark_tg_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"HMARK\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.target\t\t= hmark_tg_v4,\n\t\t.targetsize\t= sizeof(struct xt_hmark_info),\n\t\t.checkentry\t= hmark_tg_check,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\t{\n\t\t.name\t\t= \"HMARK\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.target\t\t= hmark_tg_v6,\n\t\t.targetsize\t= sizeof(struct xt_hmark_info),\n\t\t.checkentry\t= hmark_tg_check,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#endif\n};\n\nstatic int __init hmark_tg_init(void)\n{\n\treturn xt_register_targets(hmark_tg_reg, ARRAY_SIZE(hmark_tg_reg));\n}\n\nstatic void __exit hmark_tg_exit(void)\n{\n\txt_unregister_targets(hmark_tg_reg, ARRAY_SIZE(hmark_tg_reg));\n}\n\nmodule_init(hmark_tg_init);\nmodule_exit(hmark_tg_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}