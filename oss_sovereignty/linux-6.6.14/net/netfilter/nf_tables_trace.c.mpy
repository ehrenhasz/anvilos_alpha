{
  "module_name": "nf_tables_trace.c",
  "hash_id": "dee9de0de717b7e61933637bf637668e097f605716bff92410152880b5ac6e85",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_tables_trace.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/static_key.h>\n#include <linux/hash.h>\n#include <linux/siphash.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n\n#define NFT_TRACETYPE_LL_HSIZE\t\t20\n#define NFT_TRACETYPE_NETWORK_HSIZE\t40\n#define NFT_TRACETYPE_TRANSPORT_HSIZE\t20\n\nDEFINE_STATIC_KEY_FALSE(nft_trace_enabled);\nEXPORT_SYMBOL_GPL(nft_trace_enabled);\n\nstatic int trace_fill_header(struct sk_buff *nlskb, u16 type,\n\t\t\t     const struct sk_buff *skb,\n\t\t\t     int off, unsigned int len)\n{\n\tstruct nlattr *nla;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tnla = nla_reserve(nlskb, type, len);\n\tif (!nla || skb_copy_bits(skb, off, nla_data(nla), len))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int nf_trace_fill_ll_header(struct sk_buff *nlskb,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\tstruct vlan_ethhdr veth;\n\tint off;\n\n\tBUILD_BUG_ON(sizeof(veth) > NFT_TRACETYPE_LL_HSIZE);\n\n\toff = skb_mac_header(skb) - skb->data;\n\tif (off != -ETH_HLEN)\n\t\treturn -1;\n\n\tif (skb_copy_bits(skb, off, &veth, ETH_HLEN))\n\t\treturn -1;\n\n\tveth.h_vlan_proto = skb->vlan_proto;\n\tveth.h_vlan_TCI = htons(skb_vlan_tag_get(skb));\n\tveth.h_vlan_encapsulated_proto = skb->protocol;\n\n\treturn nla_put(nlskb, NFTA_TRACE_LL_HEADER, sizeof(veth), &veth);\n}\n\nstatic int nf_trace_fill_dev_info(struct sk_buff *nlskb,\n\t\t\t\t  const struct net_device *indev,\n\t\t\t\t  const struct net_device *outdev)\n{\n\tif (indev) {\n\t\tif (nla_put_be32(nlskb, NFTA_TRACE_IIF,\n\t\t\t\t htonl(indev->ifindex)))\n\t\t\treturn -1;\n\n\t\tif (nla_put_be16(nlskb, NFTA_TRACE_IIFTYPE,\n\t\t\t\t htons(indev->type)))\n\t\t\treturn -1;\n\t}\n\n\tif (outdev) {\n\t\tif (nla_put_be32(nlskb, NFTA_TRACE_OIF,\n\t\t\t\t htonl(outdev->ifindex)))\n\t\t\treturn -1;\n\n\t\tif (nla_put_be16(nlskb, NFTA_TRACE_OIFTYPE,\n\t\t\t\t htons(outdev->type)))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int nf_trace_fill_pkt_info(struct sk_buff *nlskb,\n\t\t\t\t  const struct nft_pktinfo *pkt)\n{\n\tconst struct sk_buff *skb = pkt->skb;\n\tint off = skb_network_offset(skb);\n\tunsigned int len, nh_end;\n\n\tnh_end = pkt->flags & NFT_PKTINFO_L4PROTO ? nft_thoff(pkt) : skb->len;\n\tlen = min_t(unsigned int, nh_end - skb_network_offset(skb),\n\t\t    NFT_TRACETYPE_NETWORK_HSIZE);\n\tif (trace_fill_header(nlskb, NFTA_TRACE_NETWORK_HEADER, skb, off, len))\n\t\treturn -1;\n\n\tif (pkt->flags & NFT_PKTINFO_L4PROTO) {\n\t\tlen = min_t(unsigned int, skb->len - nft_thoff(pkt),\n\t\t\t    NFT_TRACETYPE_TRANSPORT_HSIZE);\n\t\tif (trace_fill_header(nlskb, NFTA_TRACE_TRANSPORT_HEADER, skb,\n\t\t\t\t      nft_thoff(pkt), len))\n\t\t\treturn -1;\n\t}\n\n\tif (!skb_mac_header_was_set(skb))\n\t\treturn 0;\n\n\tif (skb_vlan_tag_get(skb))\n\t\treturn nf_trace_fill_ll_header(nlskb, skb);\n\n\toff = skb_mac_header(skb) - skb->data;\n\tlen = min_t(unsigned int, -off, NFT_TRACETYPE_LL_HSIZE);\n\treturn trace_fill_header(nlskb, NFTA_TRACE_LL_HEADER,\n\t\t\t\t skb, off, len);\n}\n\nstatic int nf_trace_fill_rule_info(struct sk_buff *nlskb,\n\t\t\t\t   const struct nft_verdict *verdict,\n\t\t\t\t   const struct nft_rule_dp *rule,\n\t\t\t\t   const struct nft_traceinfo *info)\n{\n\tif (!rule || rule->is_last)\n\t\treturn 0;\n\n\t \n\tif (info->type == NFT_TRACETYPE_RETURN &&\n\t    verdict->code == NFT_CONTINUE)\n\t\treturn 0;\n\n\treturn nla_put_be64(nlskb, NFTA_TRACE_RULE_HANDLE,\n\t\t\t    cpu_to_be64(rule->handle),\n\t\t\t    NFTA_TRACE_PAD);\n}\n\nstatic bool nft_trace_have_verdict_chain(const struct nft_verdict *verdict,\n\t\t\t\t\t struct nft_traceinfo *info)\n{\n\tswitch (info->type) {\n\tcase NFT_TRACETYPE_RETURN:\n\tcase NFT_TRACETYPE_RULE:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (verdict->code) {\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic const struct nft_chain *nft_trace_get_chain(const struct nft_rule_dp *rule,\n\t\t\t\t\t\t   const struct nft_traceinfo *info)\n{\n\tconst struct nft_rule_dp_last *last;\n\n\tif (!rule)\n\t\treturn &info->basechain->chain;\n\n\twhile (!rule->is_last)\n\t\trule = nft_rule_next(rule);\n\n\tlast = (const struct nft_rule_dp_last *)rule;\n\n\tif (WARN_ON_ONCE(!last->chain))\n\t\treturn &info->basechain->chain;\n\n\treturn last->chain;\n}\n\nvoid nft_trace_notify(const struct nft_pktinfo *pkt,\n\t\t      const struct nft_verdict *verdict,\n\t\t      const struct nft_rule_dp *rule,\n\t\t      struct nft_traceinfo *info)\n{\n\tconst struct nft_chain *chain;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tunsigned int size;\n\tu32 mark = 0;\n\tu16 event;\n\n\tif (!nfnetlink_has_listeners(nft_net(pkt), NFNLGRP_NFTRACE))\n\t\treturn;\n\n\tchain = nft_trace_get_chain(rule, info);\n\n\tsize = nlmsg_total_size(sizeof(struct nfgenmsg)) +\n\t\tnla_total_size(strlen(chain->table->name)) +\n\t\tnla_total_size(strlen(chain->name)) +\n\t\tnla_total_size_64bit(sizeof(__be64)) +\t \n\t\tnla_total_size(sizeof(__be32)) +\t \n\t\tnla_total_size(0) +\t\t\t \n\t\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t\t \n\t\tnla_total_size(NFT_TRACETYPE_LL_HSIZE) +\n\t\tnla_total_size(NFT_TRACETYPE_NETWORK_HSIZE) +\n\t\tnla_total_size(NFT_TRACETYPE_TRANSPORT_HSIZE) +\n\t\tnla_total_size(sizeof(u32)) +\t\t \n\t\tnla_total_size(sizeof(__be16)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t\t \n\t\tnla_total_size(sizeof(__be16)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t\t \n\t\tnla_total_size(sizeof(u32)) +\t\t \n\t\tnla_total_size(sizeof(u32));\t\t \n\n\tif (nft_trace_have_verdict_chain(verdict, info))\n\t\tsize += nla_total_size(strlen(verdict->chain->name));  \n\n\tskb = nlmsg_new(size, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, NFT_MSG_TRACE);\n\tnlh = nfnl_msg_put(skb, 0, 0, event, 0, info->basechain->type->family,\n\t\t\t   NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFTA_TRACE_NFPROTO, htonl(nft_pf(pkt))))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFTA_TRACE_TYPE, htonl(info->type)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, NFTA_TRACE_ID, info->skbid))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_TRACE_CHAIN, chain->name))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, NFTA_TRACE_TABLE, chain->table->name))\n\t\tgoto nla_put_failure;\n\n\tif (nf_trace_fill_rule_info(skb, verdict, rule, info))\n\t\tgoto nla_put_failure;\n\n\tswitch (info->type) {\n\tcase NFT_TRACETYPE_UNSPEC:\n\tcase __NFT_TRACETYPE_MAX:\n\t\tbreak;\n\tcase NFT_TRACETYPE_RETURN:\n\tcase NFT_TRACETYPE_RULE:\n\t\tif (nft_verdict_dump(skb, NFTA_TRACE_VERDICT, verdict))\n\t\t\tgoto nla_put_failure;\n\n\t\t \n\t\tif (verdict->code == NF_STOLEN)\n\t\t\tinfo->packet_dumped = true;\n\t\telse\n\t\t\tmark = pkt->skb->mark;\n\n\t\tbreak;\n\tcase NFT_TRACETYPE_POLICY:\n\t\tmark = pkt->skb->mark;\n\n\t\tif (nla_put_be32(skb, NFTA_TRACE_POLICY,\n\t\t\t\t htonl(info->basechain->policy)))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\n\tif (mark && nla_put_be32(skb, NFTA_TRACE_MARK, htonl(mark)))\n\t\tgoto nla_put_failure;\n\n\tif (!info->packet_dumped) {\n\t\tif (nf_trace_fill_dev_info(skb, nft_in(pkt), nft_out(pkt)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nf_trace_fill_pkt_info(skb, pkt))\n\t\t\tgoto nla_put_failure;\n\t\tinfo->packet_dumped = true;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\tnfnetlink_send(skb, nft_net(pkt), 0, NFNLGRP_NFTRACE, 0, GFP_ATOMIC);\n\treturn;\n\n nla_put_failure:\n\tWARN_ON_ONCE(1);\n\tkfree_skb(skb);\n}\n\nvoid nft_trace_init(struct nft_traceinfo *info, const struct nft_pktinfo *pkt,\n\t\t    const struct nft_chain *chain)\n{\n\tstatic siphash_key_t trace_key __read_mostly;\n\tstruct sk_buff *skb = pkt->skb;\n\n\tinfo->basechain = nft_base_chain(chain);\n\tinfo->trace = true;\n\tinfo->nf_trace = pkt->skb->nf_trace;\n\tinfo->packet_dumped = false;\n\n\tnet_get_random_once(&trace_key, sizeof(trace_key));\n\n\tinfo->skbid = (u32)siphash_3u32(hash32_ptr(skb),\n\t\t\t\t\tskb_get_hash(skb),\n\t\t\t\t\tskb->skb_iif,\n\t\t\t\t\t&trace_key);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}