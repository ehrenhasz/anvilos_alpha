{
  "module_name": "nft_cmp.c",
  "hash_id": "74f9426337c5025e431ab8fcd21a6e7dc09f95781f22a1c593d70697b70a74ba",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_cmp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/if_arp.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables_offload.h>\n#include <net/netfilter/nf_tables.h>\n\nstruct nft_cmp_expr {\n\tstruct nft_data\t\tdata;\n\tu8\t\t\tsreg;\n\tu8\t\t\tlen;\n\tenum nft_cmp_ops\top:8;\n};\n\nvoid nft_cmp_eval(const struct nft_expr *expr,\n\t\t  struct nft_regs *regs,\n\t\t  const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_cmp_expr *priv = nft_expr_priv(expr);\n\tint d;\n\n\td = memcmp(&regs->data[priv->sreg], &priv->data, priv->len);\n\tswitch (priv->op) {\n\tcase NFT_CMP_EQ:\n\t\tif (d != 0)\n\t\t\tgoto mismatch;\n\t\tbreak;\n\tcase NFT_CMP_NEQ:\n\t\tif (d == 0)\n\t\t\tgoto mismatch;\n\t\tbreak;\n\tcase NFT_CMP_LT:\n\t\tif (d == 0)\n\t\t\tgoto mismatch;\n\t\tfallthrough;\n\tcase NFT_CMP_LTE:\n\t\tif (d > 0)\n\t\t\tgoto mismatch;\n\t\tbreak;\n\tcase NFT_CMP_GT:\n\t\tif (d == 0)\n\t\t\tgoto mismatch;\n\t\tfallthrough;\n\tcase NFT_CMP_GTE:\n\t\tif (d < 0)\n\t\t\tgoto mismatch;\n\t\tbreak;\n\t}\n\treturn;\n\nmismatch:\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic const struct nla_policy nft_cmp_policy[NFTA_CMP_MAX + 1] = {\n\t[NFTA_CMP_SREG]\t\t= { .type = NLA_U32 },\n\t[NFTA_CMP_OP]\t\t= { .type = NLA_U32 },\n\t[NFTA_CMP_DATA]\t\t= { .type = NLA_NESTED },\n};\n\nstatic int nft_cmp_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t\tconst struct nlattr * const tb[])\n{\n\tstruct nft_cmp_expr *priv = nft_expr_priv(expr);\n\tstruct nft_data_desc desc = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= sizeof(priv->data),\n\t};\n\tint err;\n\n\terr = nft_data_init(NULL, &priv->data, &desc, tb[NFTA_CMP_DATA]);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_parse_register_load(tb[NFTA_CMP_SREG], &priv->sreg, desc.len);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->op  = ntohl(nla_get_be32(tb[NFTA_CMP_OP]));\n\tpriv->len = desc.len;\n\treturn 0;\n}\n\nstatic int nft_cmp_dump(struct sk_buff *skb,\n\t\t\tconst struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_cmp_expr *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_CMP_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_CMP_OP, htonl(priv->op)))\n\t\tgoto nla_put_failure;\n\n\tif (nft_data_dump(skb, NFTA_CMP_DATA, &priv->data,\n\t\t\t  NFT_DATA_VALUE, priv->len) < 0)\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nunion nft_cmp_offload_data {\n\tu16\tval16;\n\tu32\tval32;\n\tu64\tval64;\n};\n\nstatic void nft_payload_n2h(union nft_cmp_offload_data *data,\n\t\t\t    const u8 *val, u32 len)\n{\n\tswitch (len) {\n\tcase 2:\n\t\tdata->val16 = ntohs(*((__be16 *)val));\n\t\tbreak;\n\tcase 4:\n\t\tdata->val32 = ntohl(*((__be32 *)val));\n\t\tbreak;\n\tcase 8:\n\t\tdata->val64 = be64_to_cpu(*((__be64 *)val));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}\n\nstatic int __nft_cmp_offload(struct nft_offload_ctx *ctx,\n\t\t\t     struct nft_flow_rule *flow,\n\t\t\t     const struct nft_cmp_expr *priv)\n{\n\tstruct nft_offload_reg *reg = &ctx->regs[priv->sreg];\n\tunion nft_cmp_offload_data _data, _datamask;\n\tu8 *mask = (u8 *)&flow->match.mask;\n\tu8 *key = (u8 *)&flow->match.key;\n\tu8 *data, *datamask;\n\n\tif (priv->op != NFT_CMP_EQ || priv->len > reg->len)\n\t\treturn -EOPNOTSUPP;\n\n\tif (reg->flags & NFT_OFFLOAD_F_NETWORK2HOST) {\n\t\tnft_payload_n2h(&_data, (u8 *)&priv->data, reg->len);\n\t\tnft_payload_n2h(&_datamask, (u8 *)&reg->mask, reg->len);\n\t\tdata = (u8 *)&_data;\n\t\tdatamask = (u8 *)&_datamask;\n\t} else {\n\t\tdata = (u8 *)&priv->data;\n\t\tdatamask = (u8 *)&reg->mask;\n\t}\n\n\tmemcpy(key + reg->offset, data, reg->len);\n\tmemcpy(mask + reg->offset, datamask, reg->len);\n\n\tflow->match.dissector.used_keys |= BIT_ULL(reg->key);\n\tflow->match.dissector.offset[reg->key] = reg->base_offset;\n\n\tif (reg->key == FLOW_DISSECTOR_KEY_META &&\n\t    reg->offset == offsetof(struct nft_flow_key, meta.ingress_iftype) &&\n\t    nft_reg_load16(priv->data.data) != ARPHRD_ETHER)\n\t\treturn -EOPNOTSUPP;\n\n\tnft_offload_update_dependency(ctx, &priv->data, reg->len);\n\n\treturn 0;\n}\n\nstatic int nft_cmp_offload(struct nft_offload_ctx *ctx,\n\t\t\t   struct nft_flow_rule *flow,\n\t\t\t   const struct nft_expr *expr)\n{\n\tconst struct nft_cmp_expr *priv = nft_expr_priv(expr);\n\n\treturn __nft_cmp_offload(ctx, flow, priv);\n}\n\nstatic const struct nft_expr_ops nft_cmp_ops = {\n\t.type\t\t= &nft_cmp_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_cmp_expr)),\n\t.eval\t\t= nft_cmp_eval,\n\t.init\t\t= nft_cmp_init,\n\t.dump\t\t= nft_cmp_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n\t.offload\t= nft_cmp_offload,\n};\n\n \nstatic u32 nft_cmp_fast_mask(unsigned int len)\n{\n\t__le32 mask = cpu_to_le32(~0U >> (sizeof_field(struct nft_cmp_fast_expr,\n\t\t\t\t\t  data) * BITS_PER_BYTE - len));\n\n\treturn (__force u32)mask;\n}\n\nstatic int nft_cmp_fast_init(const struct nft_ctx *ctx,\n\t\t\t     const struct nft_expr *expr,\n\t\t\t     const struct nlattr * const tb[])\n{\n\tstruct nft_cmp_fast_expr *priv = nft_expr_priv(expr);\n\tstruct nft_data data;\n\tstruct nft_data_desc desc = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= sizeof(data),\n\t};\n\tint err;\n\n\terr = nft_data_init(NULL, &data, &desc, tb[NFTA_CMP_DATA]);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_parse_register_load(tb[NFTA_CMP_SREG], &priv->sreg, desc.len);\n\tif (err < 0)\n\t\treturn err;\n\n\tdesc.len *= BITS_PER_BYTE;\n\n\tpriv->mask = nft_cmp_fast_mask(desc.len);\n\tpriv->data = data.data[0] & priv->mask;\n\tpriv->len  = desc.len;\n\tpriv->inv  = ntohl(nla_get_be32(tb[NFTA_CMP_OP])) != NFT_CMP_EQ;\n\treturn 0;\n}\n\nstatic int nft_cmp_fast_offload(struct nft_offload_ctx *ctx,\n\t\t\t\tstruct nft_flow_rule *flow,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tconst struct nft_cmp_fast_expr *priv = nft_expr_priv(expr);\n\tstruct nft_cmp_expr cmp = {\n\t\t.data\t= {\n\t\t\t.data\t= {\n\t\t\t\t[0] = priv->data,\n\t\t\t},\n\t\t},\n\t\t.sreg\t= priv->sreg,\n\t\t.len\t= priv->len / BITS_PER_BYTE,\n\t\t.op\t= priv->inv ? NFT_CMP_NEQ : NFT_CMP_EQ,\n\t};\n\n\treturn __nft_cmp_offload(ctx, flow, &cmp);\n}\n\nstatic int nft_cmp_fast_dump(struct sk_buff *skb,\n\t\t\t     const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_cmp_fast_expr *priv = nft_expr_priv(expr);\n\tenum nft_cmp_ops op = priv->inv ? NFT_CMP_NEQ : NFT_CMP_EQ;\n\tstruct nft_data data;\n\n\tif (nft_dump_register(skb, NFTA_CMP_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_CMP_OP, htonl(op)))\n\t\tgoto nla_put_failure;\n\n\tdata.data[0] = priv->data;\n\tif (nft_data_dump(skb, NFTA_CMP_DATA, &data,\n\t\t\t  NFT_DATA_VALUE, priv->len / BITS_PER_BYTE) < 0)\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nconst struct nft_expr_ops nft_cmp_fast_ops = {\n\t.type\t\t= &nft_cmp_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_cmp_fast_expr)),\n\t.eval\t\t= NULL,\t \n\t.init\t\t= nft_cmp_fast_init,\n\t.dump\t\t= nft_cmp_fast_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n\t.offload\t= nft_cmp_fast_offload,\n};\n\nstatic u32 nft_cmp_mask(u32 bitlen)\n{\n\treturn (__force u32)cpu_to_le32(~0U >> (sizeof(u32) * BITS_PER_BYTE - bitlen));\n}\n\nstatic void nft_cmp16_fast_mask(struct nft_data *data, unsigned int bitlen)\n{\n\tint len = bitlen / BITS_PER_BYTE;\n\tint i, words = len / sizeof(u32);\n\n\tfor (i = 0; i < words; i++) {\n\t\tdata->data[i] = 0xffffffff;\n\t\tbitlen -= sizeof(u32) * BITS_PER_BYTE;\n\t}\n\n\tif (len % sizeof(u32))\n\t\tdata->data[i++] = nft_cmp_mask(bitlen);\n\n\tfor (; i < 4; i++)\n\t\tdata->data[i] = 0;\n}\n\nstatic int nft_cmp16_fast_init(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nlattr * const tb[])\n{\n\tstruct nft_cmp16_fast_expr *priv = nft_expr_priv(expr);\n\tstruct nft_data_desc desc = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= sizeof(priv->data),\n\t};\n\tint err;\n\n\terr = nft_data_init(NULL, &priv->data, &desc, tb[NFTA_CMP_DATA]);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_parse_register_load(tb[NFTA_CMP_SREG], &priv->sreg, desc.len);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_cmp16_fast_mask(&priv->mask, desc.len * BITS_PER_BYTE);\n\tpriv->inv = ntohl(nla_get_be32(tb[NFTA_CMP_OP])) != NFT_CMP_EQ;\n\tpriv->len = desc.len;\n\n\treturn 0;\n}\n\nstatic int nft_cmp16_fast_offload(struct nft_offload_ctx *ctx,\n\t\t\t\t  struct nft_flow_rule *flow,\n\t\t\t\t  const struct nft_expr *expr)\n{\n\tconst struct nft_cmp16_fast_expr *priv = nft_expr_priv(expr);\n\tstruct nft_cmp_expr cmp = {\n\t\t.data\t= priv->data,\n\t\t.sreg\t= priv->sreg,\n\t\t.len\t= priv->len,\n\t\t.op\t= priv->inv ? NFT_CMP_NEQ : NFT_CMP_EQ,\n\t};\n\n\treturn __nft_cmp_offload(ctx, flow, &cmp);\n}\n\nstatic int nft_cmp16_fast_dump(struct sk_buff *skb,\n\t\t\t       const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_cmp16_fast_expr *priv = nft_expr_priv(expr);\n\tenum nft_cmp_ops op = priv->inv ? NFT_CMP_NEQ : NFT_CMP_EQ;\n\n\tif (nft_dump_register(skb, NFTA_CMP_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_CMP_OP, htonl(op)))\n\t\tgoto nla_put_failure;\n\n\tif (nft_data_dump(skb, NFTA_CMP_DATA, &priv->data,\n\t\t\t  NFT_DATA_VALUE, priv->len) < 0)\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\n\nconst struct nft_expr_ops nft_cmp16_fast_ops = {\n\t.type\t\t= &nft_cmp_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_cmp16_fast_expr)),\n\t.eval\t\t= NULL,\t \n\t.init\t\t= nft_cmp16_fast_init,\n\t.dump\t\t= nft_cmp16_fast_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n\t.offload\t= nft_cmp16_fast_offload,\n};\n\nstatic const struct nft_expr_ops *\nnft_cmp_select_ops(const struct nft_ctx *ctx, const struct nlattr * const tb[])\n{\n\tstruct nft_data data;\n\tstruct nft_data_desc desc = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= sizeof(data),\n\t};\n\tenum nft_cmp_ops op;\n\tu8 sreg;\n\tint err;\n\n\tif (tb[NFTA_CMP_SREG] == NULL ||\n\t    tb[NFTA_CMP_OP] == NULL ||\n\t    tb[NFTA_CMP_DATA] == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\top = ntohl(nla_get_be32(tb[NFTA_CMP_OP]));\n\tswitch (op) {\n\tcase NFT_CMP_EQ:\n\tcase NFT_CMP_NEQ:\n\tcase NFT_CMP_LT:\n\tcase NFT_CMP_LTE:\n\tcase NFT_CMP_GT:\n\tcase NFT_CMP_GTE:\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\terr = nft_data_init(NULL, &data, &desc, tb[NFTA_CMP_DATA]);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tsreg = ntohl(nla_get_be32(tb[NFTA_CMP_SREG]));\n\n\tif (op == NFT_CMP_EQ || op == NFT_CMP_NEQ) {\n\t\tif (desc.len <= sizeof(u32))\n\t\t\treturn &nft_cmp_fast_ops;\n\t\telse if (desc.len <= sizeof(data) &&\n\t\t\t ((sreg >= NFT_REG_1 && sreg <= NFT_REG_4) ||\n\t\t\t  (sreg >= NFT_REG32_00 && sreg <= NFT_REG32_12 && sreg % 2 == 0)))\n\t\t\treturn &nft_cmp16_fast_ops;\n\t}\n\treturn &nft_cmp_ops;\n}\n\nstruct nft_expr_type nft_cmp_type __read_mostly = {\n\t.name\t\t= \"cmp\",\n\t.select_ops\t= nft_cmp_select_ops,\n\t.policy\t\t= nft_cmp_policy,\n\t.maxattr\t= NFTA_CMP_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}