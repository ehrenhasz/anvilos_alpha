{
  "module_name": "nf_conntrack_proto_tcp.c",
  "hash_id": "282f36c44def08e8b885dc3d6ebcc8d1b92645029a56e30c572b89bb49278039",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_proto_tcp.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/module.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/ipv6.h>\n#include <net/ip6_checksum.h>\n#include <asm/unaligned.h>\n\n#include <net/tcp.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/nf_conntrack_synproxy.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n#include <net/netfilter/nf_log.h>\n#include <net/netfilter/ipv4/nf_conntrack_ipv4.h>\n#include <net/netfilter/ipv6/nf_conntrack_ipv6.h>\n\n   \n\nstatic const char *const tcp_conntrack_names[] = {\n\t\"NONE\",\n\t\"SYN_SENT\",\n\t\"SYN_RECV\",\n\t\"ESTABLISHED\",\n\t\"FIN_WAIT\",\n\t\"CLOSE_WAIT\",\n\t\"LAST_ACK\",\n\t\"TIME_WAIT\",\n\t\"CLOSE\",\n\t\"SYN_SENT2\",\n};\n\nenum nf_ct_tcp_action {\n\tNFCT_TCP_IGNORE,\n\tNFCT_TCP_INVALID,\n\tNFCT_TCP_ACCEPT,\n};\n\n#define SECS * HZ\n#define MINS * 60 SECS\n#define HOURS * 60 MINS\n#define DAYS * 24 HOURS\n\nstatic const unsigned int tcp_timeouts[TCP_CONNTRACK_TIMEOUT_MAX] = {\n\t[TCP_CONNTRACK_SYN_SENT]\t= 2 MINS,\n\t[TCP_CONNTRACK_SYN_RECV]\t= 60 SECS,\n\t[TCP_CONNTRACK_ESTABLISHED]\t= 5 DAYS,\n\t[TCP_CONNTRACK_FIN_WAIT]\t= 2 MINS,\n\t[TCP_CONNTRACK_CLOSE_WAIT]\t= 60 SECS,\n\t[TCP_CONNTRACK_LAST_ACK]\t= 30 SECS,\n\t[TCP_CONNTRACK_TIME_WAIT]\t= 2 MINS,\n\t[TCP_CONNTRACK_CLOSE]\t\t= 10 SECS,\n\t[TCP_CONNTRACK_SYN_SENT2]\t= 2 MINS,\n \n\t[TCP_CONNTRACK_RETRANS]\t\t= 5 MINS,\n\t[TCP_CONNTRACK_UNACK]\t\t= 5 MINS,\n};\n\n#define sNO TCP_CONNTRACK_NONE\n#define sSS TCP_CONNTRACK_SYN_SENT\n#define sSR TCP_CONNTRACK_SYN_RECV\n#define sES TCP_CONNTRACK_ESTABLISHED\n#define sFW TCP_CONNTRACK_FIN_WAIT\n#define sCW TCP_CONNTRACK_CLOSE_WAIT\n#define sLA TCP_CONNTRACK_LAST_ACK\n#define sTW TCP_CONNTRACK_TIME_WAIT\n#define sCL TCP_CONNTRACK_CLOSE\n#define sS2 TCP_CONNTRACK_SYN_SENT2\n#define sIV TCP_CONNTRACK_MAX\n#define sIG TCP_CONNTRACK_IGNORE\n\n \nenum tcp_bit_set {\n\tTCP_SYN_SET,\n\tTCP_SYNACK_SET,\n\tTCP_FIN_SET,\n\tTCP_ACK_SET,\n\tTCP_RST_SET,\n\tTCP_NONE_SET,\n};\n\n \nstatic const u8 tcp_conntracks[2][6][TCP_CONNTRACK_MAX] = {\n\t{\n \n \n \t   { sSS, sSS, sIG, sIG, sIG, sIG, sIG, sSS, sSS, sS2 },\n \n \n  { sIV, sIV, sSR, sIV, sIV, sIV, sIV, sIV, sIV, sSR },\n \n \n     { sIV, sIV, sFW, sFW, sLA, sLA, sLA, sTW, sCL, sIV },\n \n \n \t   { sES, sIV, sES, sES, sCW, sCW, sTW, sTW, sCL, sIV },\n \n \n     { sIV, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL },\n    { sIV, sIV, sIV, sIV, sIV, sIV, sIV, sIV, sIV, sIV }\n\t},\n\t{\n \n \n \t   { sIV, sS2, sIV, sIV, sIV, sIV, sIV, sSS, sIV, sS2 },\n \n \n  { sIV, sSR, sIG, sIG, sIG, sIG, sIG, sIG, sIG, sSR },\n \n \n     { sIV, sIV, sFW, sFW, sLA, sLA, sLA, sTW, sCL, sIV },\n \n \n \t   { sIV, sIG, sSR, sES, sCW, sCW, sTW, sTW, sCL, sIG },\n \n \n     { sIV, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL },\n    { sIV, sIV, sIV, sIV, sIV, sIV, sIV, sIV, sIV, sIV }\n\t}\n};\n\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\n \nstatic void tcp_print_conntrack(struct seq_file *s, struct nf_conn *ct)\n{\n\tif (test_bit(IPS_OFFLOAD_BIT, &ct->status))\n\t\treturn;\n\n\tseq_printf(s, \"%s \", tcp_conntrack_names[ct->proto.tcp.state]);\n}\n#endif\n\nstatic unsigned int get_conntrack_index(const struct tcphdr *tcph)\n{\n\tif (tcph->rst) return TCP_RST_SET;\n\telse if (tcph->syn) return (tcph->ack ? TCP_SYNACK_SET : TCP_SYN_SET);\n\telse if (tcph->fin) return TCP_FIN_SET;\n\telse if (tcph->ack) return TCP_ACK_SET;\n\telse return TCP_NONE_SET;\n}\n\n \n\nstatic inline __u32 segment_seq_plus_len(__u32 seq,\n\t\t\t\t\t size_t len,\n\t\t\t\t\t unsigned int dataoff,\n\t\t\t\t\t const struct tcphdr *tcph)\n{\n\t \n\treturn (seq + len - dataoff - tcph->doff*4\n\t\t+ (tcph->syn ? 1 : 0) + (tcph->fin ? 1 : 0));\n}\n\n \n#define MAXACKWINCONST\t\t\t66000\n#define MAXACKWINDOW(sender)\t\t\t\t\t\t\\\n\t((sender)->td_maxwin > MAXACKWINCONST ? (sender)->td_maxwin\t\\\n\t\t\t\t\t      : MAXACKWINCONST)\n\n \nstatic void tcp_options(const struct sk_buff *skb,\n\t\t\tunsigned int dataoff,\n\t\t\tconst struct tcphdr *tcph,\n\t\t\tstruct ip_ct_tcp_state *state)\n{\n\tunsigned char buff[(15 * 4) - sizeof(struct tcphdr)];\n\tconst unsigned char *ptr;\n\tint length = (tcph->doff*4) - sizeof(struct tcphdr);\n\n\tif (!length)\n\t\treturn;\n\n\tptr = skb_header_pointer(skb, dataoff + sizeof(struct tcphdr),\n\t\t\t\t length, buff);\n\tif (!ptr)\n\t\treturn;\n\n\tstate->td_scale = 0;\n\tstate->flags &= IP_CT_TCP_FLAG_BE_LIBERAL;\n\n\twhile (length > 0) {\n\t\tint opcode=*ptr++;\n\t\tint opsize;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn;\n\t\tcase TCPOPT_NOP:\t \n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (length < 2)\n\t\t\t\treturn;\n\t\t\topsize=*ptr++;\n\t\t\tif (opsize < 2)  \n\t\t\t\treturn;\n\t\t\tif (opsize > length)\n\t\t\t\treturn;\t \n\n\t\t\tif (opcode == TCPOPT_SACK_PERM\n\t\t\t    && opsize == TCPOLEN_SACK_PERM)\n\t\t\t\tstate->flags |= IP_CT_TCP_FLAG_SACK_PERM;\n\t\t\telse if (opcode == TCPOPT_WINDOW\n\t\t\t\t && opsize == TCPOLEN_WINDOW) {\n\t\t\t\tstate->td_scale = *(u_int8_t *)ptr;\n\n\t\t\t\tif (state->td_scale > TCP_MAX_WSCALE)\n\t\t\t\t\tstate->td_scale = TCP_MAX_WSCALE;\n\n\t\t\t\tstate->flags |=\n\t\t\t\t\tIP_CT_TCP_FLAG_WINDOW_SCALE;\n\t\t\t}\n\t\t\tptr += opsize - 2;\n\t\t\tlength -= opsize;\n\t\t}\n\t}\n}\n\nstatic void tcp_sack(const struct sk_buff *skb, unsigned int dataoff,\n                     const struct tcphdr *tcph, __u32 *sack)\n{\n\tunsigned char buff[(15 * 4) - sizeof(struct tcphdr)];\n\tconst unsigned char *ptr;\n\tint length = (tcph->doff*4) - sizeof(struct tcphdr);\n\t__u32 tmp;\n\n\tif (!length)\n\t\treturn;\n\n\tptr = skb_header_pointer(skb, dataoff + sizeof(struct tcphdr),\n\t\t\t\t length, buff);\n\tif (!ptr)\n\t\treturn;\n\n\t \n\tif (length == TCPOLEN_TSTAMP_ALIGNED\n\t    && *(__be32 *)ptr == htonl((TCPOPT_NOP << 24)\n\t\t\t\t       | (TCPOPT_NOP << 16)\n\t\t\t\t       | (TCPOPT_TIMESTAMP << 8)\n\t\t\t\t       | TCPOLEN_TIMESTAMP))\n\t\treturn;\n\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize, i;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn;\n\t\tcase TCPOPT_NOP:\t \n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (length < 2)\n\t\t\t\treturn;\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2)  \n\t\t\t\treturn;\n\t\t\tif (opsize > length)\n\t\t\t\treturn;\t \n\n\t\t\tif (opcode == TCPOPT_SACK\n\t\t\t    && opsize >= (TCPOLEN_SACK_BASE\n\t\t\t\t\t  + TCPOLEN_SACK_PERBLOCK)\n\t\t\t    && !((opsize - TCPOLEN_SACK_BASE)\n\t\t\t\t % TCPOLEN_SACK_PERBLOCK)) {\n\t\t\t\tfor (i = 0;\n\t\t\t\t     i < (opsize - TCPOLEN_SACK_BASE);\n\t\t\t\t     i += TCPOLEN_SACK_PERBLOCK) {\n\t\t\t\t\ttmp = get_unaligned_be32((__be32 *)(ptr+i)+1);\n\n\t\t\t\t\tif (after(tmp, *sack))\n\t\t\t\t\t\t*sack = tmp;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tptr += opsize - 2;\n\t\t\tlength -= opsize;\n\t\t}\n\t}\n}\n\nstatic void tcp_init_sender(struct ip_ct_tcp_state *sender,\n\t\t\t    struct ip_ct_tcp_state *receiver,\n\t\t\t    const struct sk_buff *skb,\n\t\t\t    unsigned int dataoff,\n\t\t\t    const struct tcphdr *tcph,\n\t\t\t    u32 end, u32 win)\n{\n\t \n\tsender->td_end =\n\tsender->td_maxend = end;\n\tsender->td_maxwin = (win == 0 ? 1 : win);\n\n\ttcp_options(skb, dataoff, tcph, sender);\n\t \n\tif (!(sender->flags & IP_CT_TCP_FLAG_WINDOW_SCALE &&\n\t      receiver->flags & IP_CT_TCP_FLAG_WINDOW_SCALE)) {\n\t\tsender->td_scale = 0;\n\t\treceiver->td_scale = 0;\n\t}\n}\n\n__printf(6, 7)\nstatic enum nf_ct_tcp_action nf_tcp_log_invalid(const struct sk_buff *skb,\n\t\t\t\t\t\tconst struct nf_conn *ct,\n\t\t\t\t\t\tconst struct nf_hook_state *state,\n\t\t\t\t\t\tconst struct ip_ct_tcp_state *sender,\n\t\t\t\t\t\tenum nf_ct_tcp_action ret,\n\t\t\t\t\t\tconst char *fmt, ...)\n{\n\tconst struct nf_tcp_net *tn = nf_tcp_pernet(nf_ct_net(ct));\n\tstruct va_format vaf;\n\tva_list args;\n\tbool be_liberal;\n\n\tbe_liberal = sender->flags & IP_CT_TCP_FLAG_BE_LIBERAL || tn->tcp_be_liberal;\n\tif (be_liberal)\n\t\treturn NFCT_TCP_ACCEPT;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tnf_ct_l4proto_log_invalid(skb, ct, state, \"%pV\", &vaf);\n\tva_end(args);\n\n\treturn ret;\n}\n\nstatic enum nf_ct_tcp_action\ntcp_in_window(struct nf_conn *ct, enum ip_conntrack_dir dir,\n\t      unsigned int index, const struct sk_buff *skb,\n\t      unsigned int dataoff, const struct tcphdr *tcph,\n\t      const struct nf_hook_state *hook_state)\n{\n\tstruct ip_ct_tcp *state = &ct->proto.tcp;\n\tstruct ip_ct_tcp_state *sender = &state->seen[dir];\n\tstruct ip_ct_tcp_state *receiver = &state->seen[!dir];\n\t__u32 seq, ack, sack, end, win, swin;\n\tbool in_recv_win, seq_ok;\n\ts32 receiver_offset;\n\tu16 win_raw;\n\n\t \n\tseq = ntohl(tcph->seq);\n\tack = sack = ntohl(tcph->ack_seq);\n\twin_raw = ntohs(tcph->window);\n\twin = win_raw;\n\tend = segment_seq_plus_len(seq, skb->len, dataoff, tcph);\n\n\tif (receiver->flags & IP_CT_TCP_FLAG_SACK_PERM)\n\t\ttcp_sack(skb, dataoff, tcph, &sack);\n\n\t \n\treceiver_offset = nf_ct_seq_offset(ct, !dir, ack - 1);\n\tack -= receiver_offset;\n\tsack -= receiver_offset;\n\n\tif (sender->td_maxwin == 0) {\n\t\t \n\t\tif (tcph->syn) {\n\t\t\ttcp_init_sender(sender, receiver,\n\t\t\t\t\tskb, dataoff, tcph,\n\t\t\t\t\tend, win);\n\t\t\tif (!tcph->ack)\n\t\t\t\t \n\t\t\t\treturn NFCT_TCP_ACCEPT;\n\t\t} else {\n\t\t\t \n\t\t\tsender->td_end = end;\n\t\t\tswin = win << sender->td_scale;\n\t\t\tsender->td_maxwin = (swin == 0 ? 1 : swin);\n\t\t\tsender->td_maxend = end + sender->td_maxwin;\n\t\t\tif (receiver->td_maxwin == 0) {\n\t\t\t\t \n\t\t\t\treceiver->td_end = receiver->td_maxend = sack;\n\t\t\t} else if (sack == receiver->td_end + 1) {\n\t\t\t\t \n\t\t\t\treceiver->td_end++;\n\t\t\t}\n\n\t\t}\n\t} else if (tcph->syn &&\n\t\t   after(end, sender->td_end) &&\n\t\t   (state->state == TCP_CONNTRACK_SYN_SENT ||\n\t\t    state->state == TCP_CONNTRACK_SYN_RECV)) {\n\t\t \n\t\ttcp_init_sender(sender, receiver,\n\t\t\t\tskb, dataoff, tcph,\n\t\t\t\tend, win);\n\n\t\tif (dir == IP_CT_DIR_REPLY && !tcph->ack)\n\t\t\treturn NFCT_TCP_ACCEPT;\n\t}\n\n\tif (!(tcph->ack)) {\n\t\t \n\t\tack = sack = receiver->td_end;\n\t} else if (((tcp_flag_word(tcph) & (TCP_FLAG_ACK|TCP_FLAG_RST)) ==\n\t\t    (TCP_FLAG_ACK|TCP_FLAG_RST))\n\t\t   && (ack == 0)) {\n\t\t \n\t\tack = sack = receiver->td_end;\n\t}\n\n\tif (tcph->rst && seq == 0 && state->state == TCP_CONNTRACK_SYN_SENT)\n\t\t \n\t\tseq = end = sender->td_end;\n\n\tseq_ok = before(seq, sender->td_maxend + 1);\n\tif (!seq_ok) {\n\t\tu32 overshot = end - sender->td_maxend + 1;\n\t\tbool ack_ok;\n\n\t\tack_ok = after(sack, receiver->td_end - MAXACKWINDOW(sender) - 1);\n\t\tin_recv_win = receiver->td_maxwin &&\n\t\t\t      after(end, sender->td_end - receiver->td_maxwin - 1);\n\n\t\tif (in_recv_win &&\n\t\t    ack_ok &&\n\t\t    overshot <= receiver->td_maxwin &&\n\t\t    before(sack, receiver->td_end + 1)) {\n\t\t\t \n\t\t\tsender->td_end = end;\n\t\t\tsender->flags |= IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;\n\n\t\t\treturn nf_tcp_log_invalid(skb, ct, hook_state, sender, NFCT_TCP_IGNORE,\n\t\t\t\t\t\t  \"%u bytes more than expected\", overshot);\n\t\t}\n\n\t\treturn nf_tcp_log_invalid(skb, ct, hook_state, sender, NFCT_TCP_INVALID,\n\t\t\t\t\t  \"SEQ is over upper bound %u (over the window of the receiver)\",\n\t\t\t\t\t  sender->td_maxend + 1);\n\t}\n\n\tif (!before(sack, receiver->td_end + 1))\n\t\treturn nf_tcp_log_invalid(skb, ct, hook_state, sender, NFCT_TCP_INVALID,\n\t\t\t\t\t  \"ACK is over upper bound %u (ACKed data not seen yet)\",\n\t\t\t\t\t  receiver->td_end + 1);\n\n\t \n\tin_recv_win = !receiver->td_maxwin ||\n\t\t      after(end, sender->td_end - receiver->td_maxwin - 1);\n\tif (!in_recv_win)\n\t\treturn nf_tcp_log_invalid(skb, ct, hook_state, sender, NFCT_TCP_IGNORE,\n\t\t\t\t\t  \"SEQ is under lower bound %u (already ACKed data retransmitted)\",\n\t\t\t\t\t  sender->td_end - receiver->td_maxwin - 1);\n\tif (!after(sack, receiver->td_end - MAXACKWINDOW(sender) - 1))\n\t\treturn nf_tcp_log_invalid(skb, ct, hook_state, sender, NFCT_TCP_IGNORE,\n\t\t\t\t\t  \"ignored ACK under lower bound %u (possible overly delayed)\",\n\t\t\t\t\t  receiver->td_end - MAXACKWINDOW(sender) - 1);\n\n\t \n\tif (!tcph->syn)\n\t\twin <<= sender->td_scale;\n\n\t \n\tswin = win + (sack - ack);\n\tif (sender->td_maxwin < swin)\n\t\tsender->td_maxwin = swin;\n\tif (after(end, sender->td_end)) {\n\t\tsender->td_end = end;\n\t\tsender->flags |= IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;\n\t}\n\tif (tcph->ack) {\n\t\tif (!(sender->flags & IP_CT_TCP_FLAG_MAXACK_SET)) {\n\t\t\tsender->td_maxack = ack;\n\t\t\tsender->flags |= IP_CT_TCP_FLAG_MAXACK_SET;\n\t\t} else if (after(ack, sender->td_maxack)) {\n\t\t\tsender->td_maxack = ack;\n\t\t}\n\t}\n\n\t \n\tif (receiver->td_maxwin != 0 && after(end, sender->td_maxend))\n\t\treceiver->td_maxwin += end - sender->td_maxend;\n\tif (after(sack + win, receiver->td_maxend - 1)) {\n\t\treceiver->td_maxend = sack + win;\n\t\tif (win == 0)\n\t\t\treceiver->td_maxend++;\n\t}\n\tif (ack == receiver->td_end)\n\t\treceiver->flags &= ~IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;\n\n\t \n\tif (index == TCP_ACK_SET) {\n\t\tif (state->last_dir == dir &&\n\t\t    state->last_seq == seq &&\n\t\t    state->last_ack == ack &&\n\t\t    state->last_end == end &&\n\t\t    state->last_win == win_raw) {\n\t\t\tstate->retrans++;\n\t\t} else {\n\t\t\tstate->last_dir = dir;\n\t\t\tstate->last_seq = seq;\n\t\t\tstate->last_ack = ack;\n\t\t\tstate->last_end = end;\n\t\t\tstate->last_win = win_raw;\n\t\t\tstate->retrans = 0;\n\t\t}\n\t}\n\n\treturn NFCT_TCP_ACCEPT;\n}\n\nstatic void __cold nf_tcp_handle_invalid(struct nf_conn *ct,\n\t\t\t\t\t enum ip_conntrack_dir dir,\n\t\t\t\t\t int index,\n\t\t\t\t\t const struct sk_buff *skb,\n\t\t\t\t\t const struct nf_hook_state *hook_state)\n{\n\tconst unsigned int *timeouts;\n\tconst struct nf_tcp_net *tn;\n\tunsigned int timeout;\n\tu32 expires;\n\n\tif (!test_bit(IPS_ASSURED_BIT, &ct->status) ||\n\t    test_bit(IPS_FIXED_TIMEOUT_BIT, &ct->status))\n\t\treturn;\n\n\t \n\tswitch (index) {\n\tcase TCP_RST_SET:\n\tcase TCP_FIN_SET:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (ct->proto.tcp.last_dir != dir &&\n\t    (ct->proto.tcp.last_index == TCP_FIN_SET ||\n\t     ct->proto.tcp.last_index == TCP_RST_SET)) {\n\t\texpires = nf_ct_expires(ct);\n\t\tif (expires < 120 * HZ)\n\t\t\treturn;\n\n\t\ttn = nf_tcp_pernet(nf_ct_net(ct));\n\t\ttimeouts = nf_ct_timeout_lookup(ct);\n\t\tif (!timeouts)\n\t\t\ttimeouts = tn->timeouts;\n\n\t\ttimeout = READ_ONCE(timeouts[TCP_CONNTRACK_UNACK]);\n\t\tif (expires > timeout) {\n\t\t\tnf_ct_l4proto_log_invalid(skb, ct, hook_state,\n\t\t\t\t\t  \"packet (index %d, dir %d) response for index %d lower timeout to %u\",\n\t\t\t\t\t  index, dir, ct->proto.tcp.last_index, timeout);\n\n\t\t\tWRITE_ONCE(ct->timeout, timeout + nfct_time_stamp);\n\t\t}\n\t} else {\n\t\tct->proto.tcp.last_index = index;\n\t\tct->proto.tcp.last_dir = dir;\n\t}\n}\n\n \nstatic const u8 tcp_valid_flags[(TCPHDR_FIN|TCPHDR_SYN|TCPHDR_RST|TCPHDR_ACK|\n\t\t\t\t TCPHDR_URG) + 1] =\n{\n\t[TCPHDR_SYN]\t\t\t\t= 1,\n\t[TCPHDR_SYN|TCPHDR_URG]\t\t\t= 1,\n\t[TCPHDR_SYN|TCPHDR_ACK]\t\t\t= 1,\n\t[TCPHDR_RST]\t\t\t\t= 1,\n\t[TCPHDR_RST|TCPHDR_ACK]\t\t\t= 1,\n\t[TCPHDR_FIN|TCPHDR_ACK]\t\t\t= 1,\n\t[TCPHDR_FIN|TCPHDR_ACK|TCPHDR_URG]\t= 1,\n\t[TCPHDR_ACK]\t\t\t\t= 1,\n\t[TCPHDR_ACK|TCPHDR_URG]\t\t\t= 1,\n};\n\nstatic void tcp_error_log(const struct sk_buff *skb,\n\t\t\t  const struct nf_hook_state *state,\n\t\t\t  const char *msg)\n{\n\tnf_l4proto_log_invalid(skb, state, IPPROTO_TCP, \"%s\", msg);\n}\n\n \nstatic bool tcp_error(const struct tcphdr *th,\n\t\t      struct sk_buff *skb,\n\t\t      unsigned int dataoff,\n\t\t      const struct nf_hook_state *state)\n{\n\tunsigned int tcplen = skb->len - dataoff;\n\tu8 tcpflags;\n\n\t \n\tif (th->doff*4 < sizeof(struct tcphdr) || tcplen < th->doff*4) {\n\t\ttcp_error_log(skb, state, \"truncated packet\");\n\t\treturn true;\n\t}\n\n\t \n\t \n\tif (state->net->ct.sysctl_checksum &&\n\t    state->hook == NF_INET_PRE_ROUTING &&\n\t    nf_checksum(skb, state->hook, dataoff, IPPROTO_TCP, state->pf)) {\n\t\ttcp_error_log(skb, state, \"bad checksum\");\n\t\treturn true;\n\t}\n\n\t \n\ttcpflags = (tcp_flag_byte(th) & ~(TCPHDR_ECE|TCPHDR_CWR|TCPHDR_PSH));\n\tif (!tcp_valid_flags[tcpflags]) {\n\t\ttcp_error_log(skb, state, \"invalid tcp flag combination\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic noinline bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\t     unsigned int dataoff,\n\t\t\t     const struct tcphdr *th)\n{\n\tenum tcp_conntrack new_state;\n\tstruct net *net = nf_ct_net(ct);\n\tconst struct nf_tcp_net *tn = nf_tcp_pernet(net);\n\n\t \n\tnew_state = tcp_conntracks[0][get_conntrack_index(th)][TCP_CONNTRACK_NONE];\n\n\t \n\tif (new_state >= TCP_CONNTRACK_MAX) {\n\t\tpr_debug(\"nf_ct_tcp: invalid new deleting.\\n\");\n\t\treturn false;\n\t}\n\n\tif (new_state == TCP_CONNTRACK_SYN_SENT) {\n\t\tmemset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));\n\t\t \n\t\tct->proto.tcp.seen[0].td_end =\n\t\t\tsegment_seq_plus_len(ntohl(th->seq), skb->len,\n\t\t\t\t\t     dataoff, th);\n\t\tct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);\n\t\tif (ct->proto.tcp.seen[0].td_maxwin == 0)\n\t\t\tct->proto.tcp.seen[0].td_maxwin = 1;\n\t\tct->proto.tcp.seen[0].td_maxend =\n\t\t\tct->proto.tcp.seen[0].td_end;\n\n\t\ttcp_options(skb, dataoff, th, &ct->proto.tcp.seen[0]);\n\t} else if (tn->tcp_loose == 0) {\n\t\t \n\t\treturn false;\n\t} else {\n\t\tmemset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));\n\t\t \n\t\tct->proto.tcp.seen[0].td_end =\n\t\t\tsegment_seq_plus_len(ntohl(th->seq), skb->len,\n\t\t\t\t\t     dataoff, th);\n\t\tct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);\n\t\tif (ct->proto.tcp.seen[0].td_maxwin == 0)\n\t\t\tct->proto.tcp.seen[0].td_maxwin = 1;\n\t\tct->proto.tcp.seen[0].td_maxend =\n\t\t\tct->proto.tcp.seen[0].td_end +\n\t\t\tct->proto.tcp.seen[0].td_maxwin;\n\n\t\t \n\t\tct->proto.tcp.seen[0].flags =\n\t\tct->proto.tcp.seen[1].flags = IP_CT_TCP_FLAG_SACK_PERM |\n\t\t\t\t\t      IP_CT_TCP_FLAG_BE_LIBERAL;\n\t}\n\n\t \n\tct->proto.tcp.last_index = TCP_NONE_SET;\n\treturn true;\n}\n\nstatic bool tcp_can_early_drop(const struct nf_conn *ct)\n{\n\tswitch (ct->proto.tcp.state) {\n\tcase TCP_CONNTRACK_FIN_WAIT:\n\tcase TCP_CONNTRACK_LAST_ACK:\n\tcase TCP_CONNTRACK_TIME_WAIT:\n\tcase TCP_CONNTRACK_CLOSE:\n\tcase TCP_CONNTRACK_CLOSE_WAIT:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nvoid nf_conntrack_tcp_set_closing(struct nf_conn *ct)\n{\n\tenum tcp_conntrack old_state;\n\tconst unsigned int *timeouts;\n\tu32 timeout;\n\n\tif (!nf_ct_is_confirmed(ct))\n\t\treturn;\n\n\tspin_lock_bh(&ct->lock);\n\told_state = ct->proto.tcp.state;\n\tct->proto.tcp.state = TCP_CONNTRACK_CLOSE;\n\n\tif (old_state == TCP_CONNTRACK_CLOSE ||\n\t    test_bit(IPS_FIXED_TIMEOUT_BIT, &ct->status)) {\n\t\tspin_unlock_bh(&ct->lock);\n\t\treturn;\n\t}\n\n\ttimeouts = nf_ct_timeout_lookup(ct);\n\tif (!timeouts) {\n\t\tconst struct nf_tcp_net *tn;\n\n\t\ttn = nf_tcp_pernet(nf_ct_net(ct));\n\t\ttimeouts = tn->timeouts;\n\t}\n\n\ttimeout = timeouts[TCP_CONNTRACK_CLOSE];\n\tWRITE_ONCE(ct->timeout, timeout + nfct_time_stamp);\n\n\tspin_unlock_bh(&ct->lock);\n\n\tnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\n}\n\nstatic void nf_ct_tcp_state_reset(struct ip_ct_tcp_state *state)\n{\n\tstate->td_end\t\t= 0;\n\tstate->td_maxend\t= 0;\n\tstate->td_maxwin\t= 0;\n\tstate->td_maxack\t= 0;\n\tstate->td_scale\t\t= 0;\n\tstate->flags\t\t&= IP_CT_TCP_FLAG_BE_LIBERAL;\n}\n\n \nint nf_conntrack_tcp_packet(struct nf_conn *ct,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    unsigned int dataoff,\n\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t    const struct nf_hook_state *state)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct nf_tcp_net *tn = nf_tcp_pernet(net);\n\tenum tcp_conntrack new_state, old_state;\n\tunsigned int index, *timeouts;\n\tenum nf_ct_tcp_action res;\n\tenum ip_conntrack_dir dir;\n\tconst struct tcphdr *th;\n\tstruct tcphdr _tcph;\n\tunsigned long timeout;\n\n\tth = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);\n\tif (th == NULL)\n\t\treturn -NF_ACCEPT;\n\n\tif (tcp_error(th, skb, dataoff, state))\n\t\treturn -NF_ACCEPT;\n\n\tif (!nf_ct_is_confirmed(ct) && !tcp_new(ct, skb, dataoff, th))\n\t\treturn -NF_ACCEPT;\n\n\tspin_lock_bh(&ct->lock);\n\told_state = ct->proto.tcp.state;\n\tdir = CTINFO2DIR(ctinfo);\n\tindex = get_conntrack_index(th);\n\tnew_state = tcp_conntracks[dir][index][old_state];\n\n\tswitch (new_state) {\n\tcase TCP_CONNTRACK_SYN_SENT:\n\t\tif (old_state < TCP_CONNTRACK_TIME_WAIT)\n\t\t\tbreak;\n\t\t \n\t\tif (((ct->proto.tcp.seen[dir].flags\n\t\t      | ct->proto.tcp.seen[!dir].flags)\n\t\t     & IP_CT_TCP_FLAG_CLOSE_INIT)\n\t\t    || (ct->proto.tcp.last_dir == dir\n\t\t        && ct->proto.tcp.last_index == TCP_RST_SET)) {\n\t\t\t \n\t\t\tspin_unlock_bh(&ct->lock);\n\n\t\t\t \n\t\t\tif (nf_ct_kill(ct))\n\t\t\t\treturn -NF_REPEAT;\n\t\t\treturn NF_DROP;\n\t\t}\n\t\tfallthrough;\n\tcase TCP_CONNTRACK_IGNORE:\n\t\t \n\t\tif (index == TCP_SYNACK_SET\n\t\t    && ct->proto.tcp.last_index == TCP_SYN_SET\n\t\t    && ct->proto.tcp.last_dir != dir\n\t\t    && ntohl(th->ack_seq) == ct->proto.tcp.last_end) {\n\t\t\t \n\t\t\told_state = TCP_CONNTRACK_SYN_SENT;\n\t\t\tnew_state = TCP_CONNTRACK_SYN_RECV;\n\t\t\tct->proto.tcp.seen[ct->proto.tcp.last_dir].td_end =\n\t\t\t\tct->proto.tcp.last_end;\n\t\t\tct->proto.tcp.seen[ct->proto.tcp.last_dir].td_maxend =\n\t\t\t\tct->proto.tcp.last_end;\n\t\t\tct->proto.tcp.seen[ct->proto.tcp.last_dir].td_maxwin =\n\t\t\t\tct->proto.tcp.last_win == 0 ?\n\t\t\t\t\t1 : ct->proto.tcp.last_win;\n\t\t\tct->proto.tcp.seen[ct->proto.tcp.last_dir].td_scale =\n\t\t\t\tct->proto.tcp.last_wscale;\n\t\t\tct->proto.tcp.last_flags &= ~IP_CT_EXP_CHALLENGE_ACK;\n\t\t\tct->proto.tcp.seen[ct->proto.tcp.last_dir].flags =\n\t\t\t\tct->proto.tcp.last_flags;\n\t\t\tnf_ct_tcp_state_reset(&ct->proto.tcp.seen[dir]);\n\t\t\tbreak;\n\t\t}\n\t\tct->proto.tcp.last_index = index;\n\t\tct->proto.tcp.last_dir = dir;\n\t\tct->proto.tcp.last_seq = ntohl(th->seq);\n\t\tct->proto.tcp.last_end =\n\t\t    segment_seq_plus_len(ntohl(th->seq), skb->len, dataoff, th);\n\t\tct->proto.tcp.last_win = ntohs(th->window);\n\n\t\t \n\t\tif (index == TCP_SYN_SET && dir == IP_CT_DIR_ORIGINAL) {\n\t\t\tstruct ip_ct_tcp_state seen = {};\n\n\t\t\tct->proto.tcp.last_flags =\n\t\t\tct->proto.tcp.last_wscale = 0;\n\t\t\ttcp_options(skb, dataoff, th, &seen);\n\t\t\tif (seen.flags & IP_CT_TCP_FLAG_WINDOW_SCALE) {\n\t\t\t\tct->proto.tcp.last_flags |=\n\t\t\t\t\tIP_CT_TCP_FLAG_WINDOW_SCALE;\n\t\t\t\tct->proto.tcp.last_wscale = seen.td_scale;\n\t\t\t}\n\t\t\tif (seen.flags & IP_CT_TCP_FLAG_SACK_PERM) {\n\t\t\t\tct->proto.tcp.last_flags |=\n\t\t\t\t\tIP_CT_TCP_FLAG_SACK_PERM;\n\t\t\t}\n\t\t\t \n\t\t\tif (old_state == TCP_CONNTRACK_LAST_ACK)\n\t\t\t\tct->proto.tcp.last_flags |=\n\t\t\t\t\tIP_CT_EXP_CHALLENGE_ACK;\n\t\t}\n\n\t\t \n\t\tif (old_state == TCP_CONNTRACK_SYN_SENT &&\n\t\t    index == TCP_ACK_SET &&\n\t\t    dir == IP_CT_DIR_REPLY)\n\t\t\tct->proto.tcp.last_ack = ntohl(th->ack_seq);\n\n\t\tspin_unlock_bh(&ct->lock);\n\t\tnf_ct_l4proto_log_invalid(skb, ct, state,\n\t\t\t\t\t  \"packet (index %d) in dir %d ignored, state %s\",\n\t\t\t\t\t  index, dir,\n\t\t\t\t\t  tcp_conntrack_names[old_state]);\n\t\treturn NF_ACCEPT;\n\tcase TCP_CONNTRACK_MAX:\n\t\t \n\t\tif (nfct_synproxy(ct) && old_state == TCP_CONNTRACK_SYN_SENT &&\n\t\t    index == TCP_ACK_SET && dir == IP_CT_DIR_ORIGINAL &&\n\t\t    ct->proto.tcp.last_dir == IP_CT_DIR_ORIGINAL &&\n\t\t    ct->proto.tcp.seen[dir].td_end - 1 == ntohl(th->seq)) {\n\t\t\tpr_debug(\"nf_ct_tcp: SYN proxy client keep alive\\n\");\n\t\t\tspin_unlock_bh(&ct->lock);\n\t\t\treturn NF_ACCEPT;\n\t\t}\n\n\t\t \n\t\tspin_unlock_bh(&ct->lock);\n\t\tnf_ct_l4proto_log_invalid(skb, ct, state,\n\t\t\t\t\t  \"packet (index %d) in dir %d invalid, state %s\",\n\t\t\t\t\t  index, dir,\n\t\t\t\t\t  tcp_conntrack_names[old_state]);\n\t\treturn -NF_ACCEPT;\n\tcase TCP_CONNTRACK_TIME_WAIT:\n\t\t \n\t\tif (old_state == TCP_CONNTRACK_LAST_ACK &&\n\t\t    index == TCP_ACK_SET &&\n\t\t    ct->proto.tcp.last_dir != dir &&\n\t\t    ct->proto.tcp.last_index == TCP_SYN_SET &&\n\t\t    (ct->proto.tcp.last_flags & IP_CT_EXP_CHALLENGE_ACK)) {\n\t\t\t \n\t\t\tct->proto.tcp.last_flags &= ~IP_CT_EXP_CHALLENGE_ACK;\n\t\t\tspin_unlock_bh(&ct->lock);\n\t\t\tnf_ct_l4proto_log_invalid(skb, ct, state, \"challenge-ack ignored\");\n\t\t\treturn NF_ACCEPT;  \n\t\t}\n\t\tbreak;\n\tcase TCP_CONNTRACK_SYN_SENT2:\n\t\t \n\t\tct->proto.tcp.last_flags |= IP_CT_TCP_SIMULTANEOUS_OPEN;\n\t\tbreak;\n\tcase TCP_CONNTRACK_SYN_RECV:\n\t\tif (dir == IP_CT_DIR_REPLY && index == TCP_ACK_SET &&\n\t\t    ct->proto.tcp.last_flags & IP_CT_TCP_SIMULTANEOUS_OPEN)\n\t\t\tnew_state = TCP_CONNTRACK_ESTABLISHED;\n\t\tbreak;\n\tcase TCP_CONNTRACK_CLOSE:\n\t\tif (index != TCP_RST_SET)\n\t\t\tbreak;\n\n\t\t \n\t\tif (tcp_can_early_drop(ct))\n\t\t\tgoto in_window;\n\n\t\t \n\t\tif ((ct->proto.tcp.seen[!dir].flags & IP_CT_TCP_FLAG_MAXACK_SET) &&\n\t\t    ct->proto.tcp.last_index != TCP_SYN_SET) {\n\t\t\tu32 seq = ntohl(th->seq);\n\n\t\t\t \n\t\t\tif (seq == 0 && !nf_conntrack_tcp_established(ct))\n\t\t\t\tbreak;\n\n\t\t\tif (before(seq, ct->proto.tcp.seen[!dir].td_maxack) &&\n\t\t\t    !tn->tcp_ignore_invalid_rst) {\n\t\t\t\t \n\t\t\t\tspin_unlock_bh(&ct->lock);\n\t\t\t\tnf_ct_l4proto_log_invalid(skb, ct, state, \"invalid rst\");\n\t\t\t\treturn -NF_ACCEPT;\n\t\t\t}\n\n\t\t\tif (!nf_conntrack_tcp_established(ct) ||\n\t\t\t    seq == ct->proto.tcp.seen[!dir].td_maxack)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (ct->proto.tcp.last_index == TCP_ACK_SET &&\n\t\t\t    ct->proto.tcp.last_dir == dir &&\n\t\t\t    seq == ct->proto.tcp.last_end)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tnew_state = old_state;\n\t\t}\n\t\tif (((test_bit(IPS_SEEN_REPLY_BIT, &ct->status)\n\t\t\t && ct->proto.tcp.last_index == TCP_SYN_SET)\n\t\t\t|| (!test_bit(IPS_ASSURED_BIT, &ct->status)\n\t\t\t    && ct->proto.tcp.last_index == TCP_ACK_SET))\n\t\t    && ntohl(th->ack_seq) == ct->proto.tcp.last_end) {\n\t\t\t \n\t\t\tgoto in_window;\n\t\t}\n\n\t\t \n\t\tif (old_state == TCP_CONNTRACK_SYN_SENT &&\n\t\t    ct->proto.tcp.last_index == TCP_ACK_SET &&\n\t\t    ct->proto.tcp.last_dir == IP_CT_DIR_REPLY &&\n\t\t    ntohl(th->seq) == ct->proto.tcp.last_ack)\n\t\t\tgoto in_window;\n\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tres = tcp_in_window(ct, dir, index,\n\t\t\t    skb, dataoff, th, state);\n\tswitch (res) {\n\tcase NFCT_TCP_IGNORE:\n\t\tspin_unlock_bh(&ct->lock);\n\t\treturn NF_ACCEPT;\n\tcase NFCT_TCP_INVALID:\n\t\tnf_tcp_handle_invalid(ct, dir, index, skb, state);\n\t\tspin_unlock_bh(&ct->lock);\n\t\treturn -NF_ACCEPT;\n\tcase NFCT_TCP_ACCEPT:\n\t\tbreak;\n\t}\n     in_window:\n\t \n\tct->proto.tcp.last_index = index;\n\tct->proto.tcp.last_dir = dir;\n\n\tct->proto.tcp.state = new_state;\n\tif (old_state != new_state\n\t    && new_state == TCP_CONNTRACK_FIN_WAIT)\n\t\tct->proto.tcp.seen[dir].flags |= IP_CT_TCP_FLAG_CLOSE_INIT;\n\n\ttimeouts = nf_ct_timeout_lookup(ct);\n\tif (!timeouts)\n\t\ttimeouts = tn->timeouts;\n\n\tif (ct->proto.tcp.retrans >= tn->tcp_max_retrans &&\n\t    timeouts[new_state] > timeouts[TCP_CONNTRACK_RETRANS])\n\t\ttimeout = timeouts[TCP_CONNTRACK_RETRANS];\n\telse if (unlikely(index == TCP_RST_SET))\n\t\ttimeout = timeouts[TCP_CONNTRACK_CLOSE];\n\telse if ((ct->proto.tcp.seen[0].flags | ct->proto.tcp.seen[1].flags) &\n\t\t IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED &&\n\t\t timeouts[new_state] > timeouts[TCP_CONNTRACK_UNACK])\n\t\ttimeout = timeouts[TCP_CONNTRACK_UNACK];\n\telse if (ct->proto.tcp.last_win == 0 &&\n\t\t timeouts[new_state] > timeouts[TCP_CONNTRACK_RETRANS])\n\t\ttimeout = timeouts[TCP_CONNTRACK_RETRANS];\n\telse\n\t\ttimeout = timeouts[new_state];\n\tspin_unlock_bh(&ct->lock);\n\n\tif (new_state != old_state)\n\t\tnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\n\n\tif (!test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\n\t\t \n\t\tif (th->rst) {\n\t\t\tnf_ct_kill_acct(ct, ctinfo, skb);\n\t\t\treturn NF_ACCEPT;\n\t\t}\n\n\t\tif (index == TCP_SYN_SET && old_state == TCP_CONNTRACK_SYN_SENT) {\n\t\t\t \n\t\t\treturn NF_ACCEPT;\n\t\t}\n\n\t\t \n\t\tif (new_state == TCP_CONNTRACK_ESTABLISHED &&\n\t\t    timeout > timeouts[TCP_CONNTRACK_UNACK])\n\t\t\ttimeout = timeouts[TCP_CONNTRACK_UNACK];\n\t} else if (!test_bit(IPS_ASSURED_BIT, &ct->status)\n\t\t   && (old_state == TCP_CONNTRACK_SYN_RECV\n\t\t       || old_state == TCP_CONNTRACK_ESTABLISHED)\n\t\t   && new_state == TCP_CONNTRACK_ESTABLISHED) {\n\t\t \n\t\tset_bit(IPS_ASSURED_BIT, &ct->status);\n\t\tnf_conntrack_event_cache(IPCT_ASSURED, ct);\n\t}\n\tnf_ct_refresh_acct(ct, ctinfo, skb, timeout);\n\n\treturn NF_ACCEPT;\n}\n\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_conntrack.h>\n\nstatic int tcp_to_nlattr(struct sk_buff *skb, struct nlattr *nla,\n\t\t\t struct nf_conn *ct, bool destroy)\n{\n\tstruct nlattr *nest_parms;\n\tstruct nf_ct_tcp_flags tmp = {};\n\n\tspin_lock_bh(&ct->lock);\n\tnest_parms = nla_nest_start(skb, CTA_PROTOINFO_TCP);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, CTA_PROTOINFO_TCP_STATE, ct->proto.tcp.state))\n\t\tgoto nla_put_failure;\n\n\tif (destroy)\n\t\tgoto skip_state;\n\n\tif (nla_put_u8(skb, CTA_PROTOINFO_TCP_WSCALE_ORIGINAL,\n\t\t       ct->proto.tcp.seen[0].td_scale) ||\n\t    nla_put_u8(skb, CTA_PROTOINFO_TCP_WSCALE_REPLY,\n\t\t       ct->proto.tcp.seen[1].td_scale))\n\t\tgoto nla_put_failure;\n\n\ttmp.flags = ct->proto.tcp.seen[0].flags;\n\tif (nla_put(skb, CTA_PROTOINFO_TCP_FLAGS_ORIGINAL,\n\t\t    sizeof(struct nf_ct_tcp_flags), &tmp))\n\t\tgoto nla_put_failure;\n\n\ttmp.flags = ct->proto.tcp.seen[1].flags;\n\tif (nla_put(skb, CTA_PROTOINFO_TCP_FLAGS_REPLY,\n\t\t    sizeof(struct nf_ct_tcp_flags), &tmp))\n\t\tgoto nla_put_failure;\nskip_state:\n\tspin_unlock_bh(&ct->lock);\n\tnla_nest_end(skb, nest_parms);\n\n\treturn 0;\n\nnla_put_failure:\n\tspin_unlock_bh(&ct->lock);\n\treturn -1;\n}\n\nstatic const struct nla_policy tcp_nla_policy[CTA_PROTOINFO_TCP_MAX+1] = {\n\t[CTA_PROTOINFO_TCP_STATE]\t    = { .type = NLA_U8 },\n\t[CTA_PROTOINFO_TCP_WSCALE_ORIGINAL] = { .type = NLA_U8 },\n\t[CTA_PROTOINFO_TCP_WSCALE_REPLY]    = { .type = NLA_U8 },\n\t[CTA_PROTOINFO_TCP_FLAGS_ORIGINAL]  = { .len = sizeof(struct nf_ct_tcp_flags) },\n\t[CTA_PROTOINFO_TCP_FLAGS_REPLY]\t    = { .len = sizeof(struct nf_ct_tcp_flags) },\n};\n\n#define TCP_NLATTR_SIZE\t( \\\n\tNLA_ALIGN(NLA_HDRLEN + 1) + \\\n\tNLA_ALIGN(NLA_HDRLEN + 1) + \\\n\tNLA_ALIGN(NLA_HDRLEN + sizeof(struct nf_ct_tcp_flags)) + \\\n\tNLA_ALIGN(NLA_HDRLEN + sizeof(struct nf_ct_tcp_flags)))\n\nstatic int nlattr_to_tcp(struct nlattr *cda[], struct nf_conn *ct)\n{\n\tstruct nlattr *pattr = cda[CTA_PROTOINFO_TCP];\n\tstruct nlattr *tb[CTA_PROTOINFO_TCP_MAX+1];\n\tint err;\n\n\t \n\tif (!pattr)\n\t\treturn 0;\n\n\terr = nla_parse_nested_deprecated(tb, CTA_PROTOINFO_TCP_MAX, pattr,\n\t\t\t\t\t  tcp_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[CTA_PROTOINFO_TCP_STATE] &&\n\t    nla_get_u8(tb[CTA_PROTOINFO_TCP_STATE]) >= TCP_CONNTRACK_MAX)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&ct->lock);\n\tif (tb[CTA_PROTOINFO_TCP_STATE])\n\t\tct->proto.tcp.state = nla_get_u8(tb[CTA_PROTOINFO_TCP_STATE]);\n\n\tif (tb[CTA_PROTOINFO_TCP_FLAGS_ORIGINAL]) {\n\t\tstruct nf_ct_tcp_flags *attr =\n\t\t\tnla_data(tb[CTA_PROTOINFO_TCP_FLAGS_ORIGINAL]);\n\t\tct->proto.tcp.seen[0].flags &= ~attr->mask;\n\t\tct->proto.tcp.seen[0].flags |= attr->flags & attr->mask;\n\t}\n\n\tif (tb[CTA_PROTOINFO_TCP_FLAGS_REPLY]) {\n\t\tstruct nf_ct_tcp_flags *attr =\n\t\t\tnla_data(tb[CTA_PROTOINFO_TCP_FLAGS_REPLY]);\n\t\tct->proto.tcp.seen[1].flags &= ~attr->mask;\n\t\tct->proto.tcp.seen[1].flags |= attr->flags & attr->mask;\n\t}\n\n\tif (tb[CTA_PROTOINFO_TCP_WSCALE_ORIGINAL] &&\n\t    tb[CTA_PROTOINFO_TCP_WSCALE_REPLY] &&\n\t    ct->proto.tcp.seen[0].flags & IP_CT_TCP_FLAG_WINDOW_SCALE &&\n\t    ct->proto.tcp.seen[1].flags & IP_CT_TCP_FLAG_WINDOW_SCALE) {\n\t\tct->proto.tcp.seen[0].td_scale =\n\t\t\tnla_get_u8(tb[CTA_PROTOINFO_TCP_WSCALE_ORIGINAL]);\n\t\tct->proto.tcp.seen[1].td_scale =\n\t\t\tnla_get_u8(tb[CTA_PROTOINFO_TCP_WSCALE_REPLY]);\n\t}\n\tspin_unlock_bh(&ct->lock);\n\n\treturn 0;\n}\n\nstatic unsigned int tcp_nlattr_tuple_size(void)\n{\n\tstatic unsigned int size __read_mostly;\n\n\tif (!size)\n\t\tsize = nla_policy_len(nf_ct_port_nla_policy, CTA_PROTO_MAX + 1);\n\n\treturn size;\n}\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_cttimeout.h>\n\nstatic int tcp_timeout_nlattr_to_obj(struct nlattr *tb[],\n\t\t\t\t     struct net *net, void *data)\n{\n\tstruct nf_tcp_net *tn = nf_tcp_pernet(net);\n\tunsigned int *timeouts = data;\n\tint i;\n\n\tif (!timeouts)\n\t\ttimeouts = tn->timeouts;\n\t \n\tfor (i=0; i<TCP_CONNTRACK_TIMEOUT_MAX; i++)\n\t\ttimeouts[i] = tn->timeouts[i];\n\n\tif (tb[CTA_TIMEOUT_TCP_SYN_SENT]) {\n\t\ttimeouts[TCP_CONNTRACK_SYN_SENT] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_SYN_SENT]))*HZ;\n\t}\n\n\tif (tb[CTA_TIMEOUT_TCP_SYN_RECV]) {\n\t\ttimeouts[TCP_CONNTRACK_SYN_RECV] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_SYN_RECV]))*HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_TCP_ESTABLISHED]) {\n\t\ttimeouts[TCP_CONNTRACK_ESTABLISHED] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_ESTABLISHED]))*HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_TCP_FIN_WAIT]) {\n\t\ttimeouts[TCP_CONNTRACK_FIN_WAIT] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_FIN_WAIT]))*HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_TCP_CLOSE_WAIT]) {\n\t\ttimeouts[TCP_CONNTRACK_CLOSE_WAIT] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_CLOSE_WAIT]))*HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_TCP_LAST_ACK]) {\n\t\ttimeouts[TCP_CONNTRACK_LAST_ACK] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_LAST_ACK]))*HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_TCP_TIME_WAIT]) {\n\t\ttimeouts[TCP_CONNTRACK_TIME_WAIT] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_TIME_WAIT]))*HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_TCP_CLOSE]) {\n\t\ttimeouts[TCP_CONNTRACK_CLOSE] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_CLOSE]))*HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_TCP_SYN_SENT2]) {\n\t\ttimeouts[TCP_CONNTRACK_SYN_SENT2] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_SYN_SENT2]))*HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_TCP_RETRANS]) {\n\t\ttimeouts[TCP_CONNTRACK_RETRANS] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_RETRANS]))*HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_TCP_UNACK]) {\n\t\ttimeouts[TCP_CONNTRACK_UNACK] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_UNACK]))*HZ;\n\t}\n\n\ttimeouts[CTA_TIMEOUT_TCP_UNSPEC] = timeouts[CTA_TIMEOUT_TCP_SYN_SENT];\n\treturn 0;\n}\n\nstatic int\ntcp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\n{\n\tconst unsigned int *timeouts = data;\n\n\tif (nla_put_be32(skb, CTA_TIMEOUT_TCP_SYN_SENT,\n\t\t\thtonl(timeouts[TCP_CONNTRACK_SYN_SENT] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_TCP_SYN_RECV,\n\t\t\t htonl(timeouts[TCP_CONNTRACK_SYN_RECV] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_TCP_ESTABLISHED,\n\t\t\t htonl(timeouts[TCP_CONNTRACK_ESTABLISHED] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_TCP_FIN_WAIT,\n\t\t\t htonl(timeouts[TCP_CONNTRACK_FIN_WAIT] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_TCP_CLOSE_WAIT,\n\t\t\t htonl(timeouts[TCP_CONNTRACK_CLOSE_WAIT] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_TCP_LAST_ACK,\n\t\t\t htonl(timeouts[TCP_CONNTRACK_LAST_ACK] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_TCP_TIME_WAIT,\n\t\t\t htonl(timeouts[TCP_CONNTRACK_TIME_WAIT] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_TCP_CLOSE,\n\t\t\t htonl(timeouts[TCP_CONNTRACK_CLOSE] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_TCP_SYN_SENT2,\n\t\t\t htonl(timeouts[TCP_CONNTRACK_SYN_SENT2] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_TCP_RETRANS,\n\t\t\t htonl(timeouts[TCP_CONNTRACK_RETRANS] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_TCP_UNACK,\n\t\t\t htonl(timeouts[TCP_CONNTRACK_UNACK] / HZ)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic const struct nla_policy tcp_timeout_nla_policy[CTA_TIMEOUT_TCP_MAX+1] = {\n\t[CTA_TIMEOUT_TCP_SYN_SENT]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_TCP_SYN_RECV]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_TCP_ESTABLISHED]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_TCP_FIN_WAIT]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_TCP_CLOSE_WAIT]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_TCP_LAST_ACK]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_TCP_TIME_WAIT]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_TCP_CLOSE]\t\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_TCP_SYN_SENT2]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_TCP_RETRANS]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_TCP_UNACK]\t\t= { .type = NLA_U32 },\n};\n#endif  \n\nvoid nf_conntrack_tcp_init_net(struct net *net)\n{\n\tstruct nf_tcp_net *tn = nf_tcp_pernet(net);\n\tint i;\n\n\tfor (i = 0; i < TCP_CONNTRACK_TIMEOUT_MAX; i++)\n\t\ttn->timeouts[i] = tcp_timeouts[i];\n\n\t \n\ttn->timeouts[0] = tcp_timeouts[TCP_CONNTRACK_SYN_SENT];\n\n\t \n\ttn->tcp_loose = 1;\n\n\t \n\ttn->tcp_be_liberal = 0;\n\n\t \n\ttn->tcp_ignore_invalid_rst = 0;\n\n\t \n\ttn->tcp_max_retrans = 3;\n\n#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)\n\ttn->offload_timeout = 30 * HZ;\n#endif\n}\n\nconst struct nf_conntrack_l4proto nf_conntrack_l4proto_tcp =\n{\n\t.l4proto \t\t= IPPROTO_TCP,\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\n\t.print_conntrack \t= tcp_print_conntrack,\n#endif\n\t.can_early_drop\t\t= tcp_can_early_drop,\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.to_nlattr\t\t= tcp_to_nlattr,\n\t.from_nlattr\t\t= nlattr_to_tcp,\n\t.tuple_to_nlattr\t= nf_ct_port_tuple_to_nlattr,\n\t.nlattr_to_tuple\t= nf_ct_port_nlattr_to_tuple,\n\t.nlattr_tuple_size\t= tcp_nlattr_tuple_size,\n\t.nlattr_size\t\t= TCP_NLATTR_SIZE,\n\t.nla_policy\t\t= nf_ct_port_nla_policy,\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\t.ctnl_timeout\t\t= {\n\t\t.nlattr_to_obj\t= tcp_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= tcp_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_TCP_MAX,\n\t\t.obj_size\t= sizeof(unsigned int) *\n\t\t\t\t\tTCP_CONNTRACK_TIMEOUT_MAX,\n\t\t.nla_policy\t= tcp_timeout_nla_policy,\n\t},\n#endif  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}