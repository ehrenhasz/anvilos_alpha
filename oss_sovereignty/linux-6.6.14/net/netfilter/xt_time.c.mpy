{
  "module_name": "xt_time.c",
  "hash_id": "bb1d973fc38693dbad7121712624d0a5bdae83b01520a9a49af8282a49eff791",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_time.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/types.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_time.h>\n\nstruct xtm {\n\tu_int8_t month;     \n\tu_int8_t monthday;  \n\tu_int8_t weekday;   \n\tu_int8_t hour;      \n\tu_int8_t minute;    \n\tu_int8_t second;    \n\tunsigned int dse;\n};\n\nextern struct timezone sys_tz;  \n\nstatic const u_int16_t days_since_year[] = {\n\t0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,\n};\n\nstatic const u_int16_t days_since_leapyear[] = {\n\t0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335,\n};\n\n \nenum {\n\tDSE_FIRST = 2039,\n\tSECONDS_PER_DAY = 86400,\n};\nstatic const u_int16_t days_since_epoch[] = {\n\t \n\t25202, 24837, 24472, 24106, 23741, 23376, 23011, 22645, 22280, 21915,\n\t \n\t21550, 21184, 20819, 20454, 20089, 19723, 19358, 18993, 18628, 18262,\n\t \n\t17897, 17532, 17167, 16801, 16436, 16071, 15706, 15340, 14975, 14610,\n\t \n\t14245, 13879, 13514, 13149, 12784, 12418, 12053, 11688, 11323, 10957,\n\t \n\t10592, 10227, 9862, 9496, 9131, 8766, 8401, 8035, 7670, 7305,\n\t \n\t6940, 6574, 6209, 5844, 5479, 5113, 4748, 4383, 4018, 3652,\n\t \n\t3287, 2922, 2557, 2191, 1826, 1461, 1096, 730, 365, 0,\n};\n\nstatic inline bool is_leap(unsigned int y)\n{\n\treturn y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);\n}\n\n \nstatic inline unsigned int localtime_1(struct xtm *r, time64_t time)\n{\n\tunsigned int v, w;\n\n\t \n\tdiv_u64_rem(time, SECONDS_PER_DAY, &v);\n\tr->second = v % 60;\n\tw         = v / 60;\n\tr->minute = w % 60;\n\tr->hour   = w / 60;\n\treturn v;\n}\n\nstatic inline void localtime_2(struct xtm *r, time64_t time)\n{\n\t \n\tr->dse = div_u64(time, SECONDS_PER_DAY);\n\n\t \n\tr->weekday = (4 + r->dse - 1) % 7 + 1;\n}\n\nstatic void localtime_3(struct xtm *r, time64_t time)\n{\n\tunsigned int year, i, w = r->dse;\n\n\t \n\tfor (i = 0, year = DSE_FIRST; days_since_epoch[i] > w;\n\t    ++i, --year)\n\t\t ;\n\n\tw -= days_since_epoch[i];\n\n\t \n\tif (is_leap(year)) {\n\t\t \n\t\tfor (i = ARRAY_SIZE(days_since_leapyear) - 1;\n\t\t    i > 0 && days_since_leapyear[i] > w; --i)\n\t\t\t ;\n\t\tr->monthday = w - days_since_leapyear[i] + 1;\n\t} else {\n\t\tfor (i = ARRAY_SIZE(days_since_year) - 1;\n\t\t    i > 0 && days_since_year[i] > w; --i)\n\t\t\t ;\n\t\tr->monthday = w - days_since_year[i] + 1;\n\t}\n\n\tr->month    = i + 1;\n}\n\nstatic bool\ntime_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_time_info *info = par->matchinfo;\n\tunsigned int packet_time;\n\tstruct xtm current_time;\n\ttime64_t stamp;\n\n\t \n\tstamp = ktime_get_real_seconds();\n\n\tif (info->flags & XT_TIME_LOCAL_TZ)\n\t\t \n\t\tstamp -= 60 * sys_tz.tz_minuteswest;\n\n\t \n\n\tif (stamp < info->date_start || stamp > info->date_stop)\n\t\treturn false;\n\n\tpacket_time = localtime_1(&current_time, stamp);\n\n\tif (info->daytime_start < info->daytime_stop) {\n\t\tif (packet_time < info->daytime_start ||\n\t\t    packet_time > info->daytime_stop)\n\t\t\treturn false;\n\t} else {\n\t\tif (packet_time < info->daytime_start &&\n\t\t    packet_time > info->daytime_stop)\n\t\t\treturn false;\n\n\t\t \n\t\tif ((info->flags & XT_TIME_CONTIGUOUS) &&\n\t\t     packet_time <= info->daytime_stop)\n\t\t\tstamp -= SECONDS_PER_DAY;\n\t}\n\n\tlocaltime_2(&current_time, stamp);\n\n\tif (!(info->weekdays_match & (1 << current_time.weekday)))\n\t\treturn false;\n\n\t \n\tif (info->monthdays_match != XT_TIME_ALL_MONTHDAYS) {\n\t\tlocaltime_3(&current_time, stamp);\n\t\tif (!(info->monthdays_match & (1 << current_time.monthday)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int time_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_time_info *info = par->matchinfo;\n\n\tif (info->daytime_start > XT_TIME_MAX_DAYTIME ||\n\t    info->daytime_stop > XT_TIME_MAX_DAYTIME) {\n\t\tpr_info_ratelimited(\"invalid argument - start or stop time greater than 23:59:59\\n\");\n\t\treturn -EDOM;\n\t}\n\n\tif (info->flags & ~XT_TIME_ALL_FLAGS) {\n\t\tpr_info_ratelimited(\"unknown flags 0x%x\\n\",\n\t\t\t\t    info->flags & ~XT_TIME_ALL_FLAGS);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((info->flags & XT_TIME_CONTIGUOUS) &&\n\t     info->daytime_start < info->daytime_stop)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct xt_match xt_time_mt_reg __read_mostly = {\n\t.name       = \"time\",\n\t.family     = NFPROTO_UNSPEC,\n\t.match      = time_mt,\n\t.checkentry = time_mt_check,\n\t.matchsize  = sizeof(struct xt_time_info),\n\t.me         = THIS_MODULE,\n};\n\nstatic int __init time_mt_init(void)\n{\n\tint minutes = sys_tz.tz_minuteswest;\n\n\tif (minutes < 0)  \n\t\tpr_info(\"kernel timezone is +%02d%02d\\n\",\n\t\t\t-minutes / 60, -minutes % 60);\n\telse  \n\t\tpr_info(\"kernel timezone is -%02d%02d\\n\",\n\t\t\tminutes / 60, minutes % 60);\n\n\treturn xt_register_match(&xt_time_mt_reg);\n}\n\nstatic void __exit time_mt_exit(void)\n{\n\txt_unregister_match(&xt_time_mt_reg);\n}\n\nmodule_init(time_mt_init);\nmodule_exit(time_mt_exit);\nMODULE_AUTHOR(\"Jan Engelhardt <jengelh@medozas.de>\");\nMODULE_DESCRIPTION(\"Xtables: time-based matching\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_time\");\nMODULE_ALIAS(\"ip6t_time\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}