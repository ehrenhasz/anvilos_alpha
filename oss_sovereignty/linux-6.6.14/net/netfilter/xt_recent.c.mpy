{
  "module_name": "xt_recent.c",
  "hash_id": "1ffd3ed20dacc34ee142e1ba73a090f4eea4e6c8d29d8e3154e30f457f7cc7f4",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_recent.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/init.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/list.h>\n#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/bitops.h>\n#include <linux/skbuff.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_recent.h>\n\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_AUTHOR(\"Jan Engelhardt <jengelh@medozas.de>\");\nMODULE_DESCRIPTION(\"Xtables: \\\"recently-seen\\\" host matching\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_recent\");\nMODULE_ALIAS(\"ip6t_recent\");\n\nstatic unsigned int ip_list_tot __read_mostly = 100;\nstatic unsigned int ip_list_hash_size __read_mostly;\nstatic unsigned int ip_list_perms __read_mostly = 0644;\nstatic unsigned int ip_list_uid __read_mostly;\nstatic unsigned int ip_list_gid __read_mostly;\nmodule_param(ip_list_tot, uint, 0400);\nmodule_param(ip_list_hash_size, uint, 0400);\nmodule_param(ip_list_perms, uint, 0400);\nmodule_param(ip_list_uid, uint, 0644);\nmodule_param(ip_list_gid, uint, 0644);\nMODULE_PARM_DESC(ip_list_tot, \"number of IPs to remember per list\");\nMODULE_PARM_DESC(ip_list_hash_size, \"size of hash table used to look up IPs\");\nMODULE_PARM_DESC(ip_list_perms, \"permissions on /proc/net/xt_recent/* files\");\nMODULE_PARM_DESC(ip_list_uid, \"default owner of /proc/net/xt_recent/* files\");\nMODULE_PARM_DESC(ip_list_gid, \"default owning group of /proc/net/xt_recent/* files\");\n\n \nstatic unsigned int ip_pkt_list_tot __read_mostly;\nmodule_param(ip_pkt_list_tot, uint, 0400);\nMODULE_PARM_DESC(ip_pkt_list_tot, \"number of packets per IP address to remember (max. 255)\");\n\n#define XT_RECENT_MAX_NSTAMPS\t256\n\nstruct recent_entry {\n\tstruct list_head\tlist;\n\tstruct list_head\tlru_list;\n\tunion nf_inet_addr\taddr;\n\tu_int16_t\t\tfamily;\n\tu_int8_t\t\tttl;\n\tu_int8_t\t\tindex;\n\tu_int16_t\t\tnstamps;\n\tunsigned long\t\tstamps[];\n};\n\nstruct recent_table {\n\tstruct list_head\tlist;\n\tchar\t\t\tname[XT_RECENT_NAME_LEN];\n\tunion nf_inet_addr\tmask;\n\tunsigned int\t\trefcnt;\n\tunsigned int\t\tentries;\n\tu8\t\t\tnstamps_max_mask;\n\tstruct list_head\tlru_list;\n\tstruct list_head\tiphash[];\n};\n\nstruct recent_net {\n\tstruct list_head\ttables;\n#ifdef CONFIG_PROC_FS\n\tstruct proc_dir_entry\t*xt_recent;\n#endif\n};\n\nstatic unsigned int recent_net_id __read_mostly;\n\nstatic inline struct recent_net *recent_pernet(struct net *net)\n{\n\treturn net_generic(net, recent_net_id);\n}\n\nstatic DEFINE_SPINLOCK(recent_lock);\nstatic DEFINE_MUTEX(recent_mutex);\n\n#ifdef CONFIG_PROC_FS\nstatic const struct proc_ops recent_mt_proc_ops;\n#endif\n\nstatic u_int32_t hash_rnd __read_mostly;\n\nstatic inline unsigned int recent_entry_hash4(const union nf_inet_addr *addr)\n{\n\treturn jhash_1word((__force u32)addr->ip, hash_rnd) &\n\t       (ip_list_hash_size - 1);\n}\n\nstatic inline unsigned int recent_entry_hash6(const union nf_inet_addr *addr)\n{\n\treturn jhash2((u32 *)addr->ip6, ARRAY_SIZE(addr->ip6), hash_rnd) &\n\t       (ip_list_hash_size - 1);\n}\n\nstatic struct recent_entry *\nrecent_entry_lookup(const struct recent_table *table,\n\t\t    const union nf_inet_addr *addrp, u_int16_t family,\n\t\t    u_int8_t ttl)\n{\n\tstruct recent_entry *e;\n\tunsigned int h;\n\n\tif (family == NFPROTO_IPV4)\n\t\th = recent_entry_hash4(addrp);\n\telse\n\t\th = recent_entry_hash6(addrp);\n\n\tlist_for_each_entry(e, &table->iphash[h], list)\n\t\tif (e->family == family &&\n\t\t    memcmp(&e->addr, addrp, sizeof(e->addr)) == 0 &&\n\t\t    (ttl == e->ttl || ttl == 0 || e->ttl == 0))\n\t\t\treturn e;\n\treturn NULL;\n}\n\nstatic void recent_entry_remove(struct recent_table *t, struct recent_entry *e)\n{\n\tlist_del(&e->list);\n\tlist_del(&e->lru_list);\n\tkfree(e);\n\tt->entries--;\n}\n\n \nstatic void recent_entry_reap(struct recent_table *t, unsigned long time,\n\t\t\t      struct recent_entry *working, bool update)\n{\n\tstruct recent_entry *e;\n\n\t \n\te = list_entry(t->lru_list.next, struct recent_entry, lru_list);\n\n\t \n\tif (e == working && update)\n\t\treturn;\n\n\t \n\tif (time_after(time, e->stamps[e->index-1]))\n\t\trecent_entry_remove(t, e);\n}\n\nstatic struct recent_entry *\nrecent_entry_init(struct recent_table *t, const union nf_inet_addr *addr,\n\t\t  u_int16_t family, u_int8_t ttl)\n{\n\tstruct recent_entry *e;\n\tunsigned int nstamps_max = t->nstamps_max_mask;\n\n\tif (t->entries >= ip_list_tot) {\n\t\te = list_entry(t->lru_list.next, struct recent_entry, lru_list);\n\t\trecent_entry_remove(t, e);\n\t}\n\n\tnstamps_max += 1;\n\te = kmalloc(struct_size(e, stamps, nstamps_max), GFP_ATOMIC);\n\tif (e == NULL)\n\t\treturn NULL;\n\tmemcpy(&e->addr, addr, sizeof(e->addr));\n\te->ttl       = ttl;\n\te->stamps[0] = jiffies;\n\te->nstamps   = 1;\n\te->index     = 1;\n\te->family    = family;\n\tif (family == NFPROTO_IPV4)\n\t\tlist_add_tail(&e->list, &t->iphash[recent_entry_hash4(addr)]);\n\telse\n\t\tlist_add_tail(&e->list, &t->iphash[recent_entry_hash6(addr)]);\n\tlist_add_tail(&e->lru_list, &t->lru_list);\n\tt->entries++;\n\treturn e;\n}\n\nstatic void recent_entry_update(struct recent_table *t, struct recent_entry *e)\n{\n\te->index &= t->nstamps_max_mask;\n\te->stamps[e->index++] = jiffies;\n\tif (e->index > e->nstamps)\n\t\te->nstamps = e->index;\n\tlist_move_tail(&e->lru_list, &t->lru_list);\n}\n\nstatic struct recent_table *recent_table_lookup(struct recent_net *recent_net,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct recent_table *t;\n\n\tlist_for_each_entry(t, &recent_net->tables, list)\n\t\tif (!strcmp(t->name, name))\n\t\t\treturn t;\n\treturn NULL;\n}\n\nstatic void recent_table_flush(struct recent_table *t)\n{\n\tstruct recent_entry *e, *next;\n\tunsigned int i;\n\n\tfor (i = 0; i < ip_list_hash_size; i++)\n\t\tlist_for_each_entry_safe(e, next, &t->iphash[i], list)\n\t\t\trecent_entry_remove(t, e);\n}\n\nstatic bool\nrecent_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tstruct net *net = xt_net(par);\n\tstruct recent_net *recent_net = recent_pernet(net);\n\tconst struct xt_recent_mtinfo_v1 *info = par->matchinfo;\n\tstruct recent_table *t;\n\tstruct recent_entry *e;\n\tunion nf_inet_addr addr = {}, addr_mask;\n\tu_int8_t ttl;\n\tbool ret = info->invert;\n\n\tif (xt_family(par) == NFPROTO_IPV4) {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\n\t\tif (info->side == XT_RECENT_DEST)\n\t\t\taddr.ip = iph->daddr;\n\t\telse\n\t\t\taddr.ip = iph->saddr;\n\n\t\tttl = iph->ttl;\n\t} else {\n\t\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\n\t\tif (info->side == XT_RECENT_DEST)\n\t\t\tmemcpy(&addr.in6, &iph->daddr, sizeof(addr.in6));\n\t\telse\n\t\t\tmemcpy(&addr.in6, &iph->saddr, sizeof(addr.in6));\n\n\t\tttl = iph->hop_limit;\n\t}\n\n\t \n\tif (xt_out(par) != NULL &&\n\t    (!skb->sk || !net_eq(net, sock_net(skb->sk))))\n\t\tttl++;\n\n\tspin_lock_bh(&recent_lock);\n\tt = recent_table_lookup(recent_net, info->name);\n\n\tnf_inet_addr_mask(&addr, &addr_mask, &t->mask);\n\n\te = recent_entry_lookup(t, &addr_mask, xt_family(par),\n\t\t\t\t(info->check_set & XT_RECENT_TTL) ? ttl : 0);\n\tif (e == NULL) {\n\t\tif (!(info->check_set & XT_RECENT_SET))\n\t\t\tgoto out;\n\t\te = recent_entry_init(t, &addr_mask, xt_family(par), ttl);\n\t\tif (e == NULL)\n\t\t\tpar->hotdrop = true;\n\t\tret = !ret;\n\t\tgoto out;\n\t}\n\n\tif (info->check_set & XT_RECENT_SET)\n\t\tret = !ret;\n\telse if (info->check_set & XT_RECENT_REMOVE) {\n\t\trecent_entry_remove(t, e);\n\t\tret = !ret;\n\t} else if (info->check_set & (XT_RECENT_CHECK | XT_RECENT_UPDATE)) {\n\t\tunsigned long time = jiffies - info->seconds * HZ;\n\t\tunsigned int i, hits = 0;\n\n\t\tfor (i = 0; i < e->nstamps; i++) {\n\t\t\tif (info->seconds && time_after(time, e->stamps[i]))\n\t\t\t\tcontinue;\n\t\t\tif (!info->hit_count || ++hits >= info->hit_count) {\n\t\t\t\tret = !ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (info->check_set & XT_RECENT_REAP)\n\t\t\trecent_entry_reap(t, time, e,\n\t\t\t\tinfo->check_set & XT_RECENT_UPDATE && ret);\n\t}\n\n\tif (info->check_set & XT_RECENT_SET ||\n\t    (info->check_set & XT_RECENT_UPDATE && ret)) {\n\t\trecent_entry_update(t, e);\n\t\te->ttl = ttl;\n\t}\nout:\n\tspin_unlock_bh(&recent_lock);\n\treturn ret;\n}\n\nstatic void recent_table_free(void *addr)\n{\n\tkvfree(addr);\n}\n\nstatic int recent_mt_check(const struct xt_mtchk_param *par,\n\t\t\t   const struct xt_recent_mtinfo_v1 *info)\n{\n\tstruct recent_net *recent_net = recent_pernet(par->net);\n\tstruct recent_table *t;\n#ifdef CONFIG_PROC_FS\n\tstruct proc_dir_entry *pde;\n\tkuid_t uid;\n\tkgid_t gid;\n#endif\n\tunsigned int nstamp_mask;\n\tunsigned int i;\n\tint ret = -EINVAL;\n\n\tnet_get_random_once(&hash_rnd, sizeof(hash_rnd));\n\n\tif (info->check_set & ~XT_RECENT_VALID_FLAGS) {\n\t\tpr_info_ratelimited(\"Unsupported userspace flags (%08x)\\n\",\n\t\t\t\t    info->check_set);\n\t\treturn -EINVAL;\n\t}\n\tif (hweight8(info->check_set &\n\t\t     (XT_RECENT_SET | XT_RECENT_REMOVE |\n\t\t      XT_RECENT_CHECK | XT_RECENT_UPDATE)) != 1)\n\t\treturn -EINVAL;\n\tif ((info->check_set & (XT_RECENT_SET | XT_RECENT_REMOVE)) &&\n\t    (info->seconds || info->hit_count ||\n\t    (info->check_set & XT_RECENT_MODIFIERS)))\n\t\treturn -EINVAL;\n\tif ((info->check_set & XT_RECENT_REAP) && !info->seconds)\n\t\treturn -EINVAL;\n\tif (info->hit_count >= XT_RECENT_MAX_NSTAMPS) {\n\t\tpr_info_ratelimited(\"hitcount (%u) is larger than allowed maximum (%u)\\n\",\n\t\t\t\t    info->hit_count, XT_RECENT_MAX_NSTAMPS - 1);\n\t\treturn -EINVAL;\n\t}\n\tret = xt_check_proc_name(info->name, sizeof(info->name));\n\tif (ret)\n\t\treturn ret;\n\n\tif (ip_pkt_list_tot && info->hit_count < ip_pkt_list_tot)\n\t\tnstamp_mask = roundup_pow_of_two(ip_pkt_list_tot) - 1;\n\telse if (info->hit_count)\n\t\tnstamp_mask = roundup_pow_of_two(info->hit_count) - 1;\n\telse\n\t\tnstamp_mask = 32 - 1;\n\n\tmutex_lock(&recent_mutex);\n\tt = recent_table_lookup(recent_net, info->name);\n\tif (t != NULL) {\n\t\tif (nstamp_mask > t->nstamps_max_mask) {\n\t\t\tspin_lock_bh(&recent_lock);\n\t\t\trecent_table_flush(t);\n\t\t\tt->nstamps_max_mask = nstamp_mask;\n\t\t\tspin_unlock_bh(&recent_lock);\n\t\t}\n\n\t\tt->refcnt++;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tt = kvzalloc(struct_size(t, iphash, ip_list_hash_size), GFP_KERNEL);\n\tif (t == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tt->refcnt = 1;\n\tt->nstamps_max_mask = nstamp_mask;\n\n\tmemcpy(&t->mask, &info->mask, sizeof(t->mask));\n\tstrcpy(t->name, info->name);\n\tINIT_LIST_HEAD(&t->lru_list);\n\tfor (i = 0; i < ip_list_hash_size; i++)\n\t\tINIT_LIST_HEAD(&t->iphash[i]);\n#ifdef CONFIG_PROC_FS\n\tuid = make_kuid(&init_user_ns, ip_list_uid);\n\tgid = make_kgid(&init_user_ns, ip_list_gid);\n\tif (!uid_valid(uid) || !gid_valid(gid)) {\n\t\trecent_table_free(t);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tpde = proc_create_data(t->name, ip_list_perms, recent_net->xt_recent,\n\t\t\t       &recent_mt_proc_ops, t);\n\tif (pde == NULL) {\n\t\trecent_table_free(t);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tproc_set_user(pde, uid, gid);\n#endif\n\tspin_lock_bh(&recent_lock);\n\tlist_add_tail(&t->list, &recent_net->tables);\n\tspin_unlock_bh(&recent_lock);\n\tret = 0;\nout:\n\tmutex_unlock(&recent_mutex);\n\treturn ret;\n}\n\nstatic int recent_mt_check_v0(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_recent_mtinfo_v0 *info_v0 = par->matchinfo;\n\tstruct xt_recent_mtinfo_v1 info_v1;\n\n\t \n\tmemcpy(&info_v1, info_v0, sizeof(struct xt_recent_mtinfo));\n\t \n\tmemset(info_v1.mask.all, 0xFF, sizeof(info_v1.mask.all));\n\n\treturn recent_mt_check(par, &info_v1);\n}\n\nstatic int recent_mt_check_v1(const struct xt_mtchk_param *par)\n{\n\treturn recent_mt_check(par, par->matchinfo);\n}\n\nstatic void recent_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tstruct recent_net *recent_net = recent_pernet(par->net);\n\tconst struct xt_recent_mtinfo_v1 *info = par->matchinfo;\n\tstruct recent_table *t;\n\n\tmutex_lock(&recent_mutex);\n\tt = recent_table_lookup(recent_net, info->name);\n\tif (--t->refcnt == 0) {\n\t\tspin_lock_bh(&recent_lock);\n\t\tlist_del(&t->list);\n\t\tspin_unlock_bh(&recent_lock);\n#ifdef CONFIG_PROC_FS\n\t\tif (recent_net->xt_recent != NULL)\n\t\t\tremove_proc_entry(t->name, recent_net->xt_recent);\n#endif\n\t\trecent_table_flush(t);\n\t\trecent_table_free(t);\n\t}\n\tmutex_unlock(&recent_mutex);\n}\n\n#ifdef CONFIG_PROC_FS\nstruct recent_iter_state {\n\tconst struct recent_table *table;\n\tunsigned int\t\tbucket;\n};\n\nstatic void *recent_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(recent_lock)\n{\n\tstruct recent_iter_state *st = seq->private;\n\tconst struct recent_table *t = st->table;\n\tstruct recent_entry *e;\n\tloff_t p = *pos;\n\n\tspin_lock_bh(&recent_lock);\n\n\tfor (st->bucket = 0; st->bucket < ip_list_hash_size; st->bucket++)\n\t\tlist_for_each_entry(e, &t->iphash[st->bucket], list)\n\t\t\tif (p-- == 0)\n\t\t\t\treturn e;\n\treturn NULL;\n}\n\nstatic void *recent_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct recent_iter_state *st = seq->private;\n\tconst struct recent_table *t = st->table;\n\tconst struct recent_entry *e = v;\n\tconst struct list_head *head = e->list.next;\n\n\t(*pos)++;\n\twhile (head == &t->iphash[st->bucket]) {\n\t\tif (++st->bucket >= ip_list_hash_size)\n\t\t\treturn NULL;\n\t\thead = t->iphash[st->bucket].next;\n\t}\n\treturn list_entry(head, struct recent_entry, list);\n}\n\nstatic void recent_seq_stop(struct seq_file *s, void *v)\n\t__releases(recent_lock)\n{\n\tspin_unlock_bh(&recent_lock);\n}\n\nstatic int recent_seq_show(struct seq_file *seq, void *v)\n{\n\tconst struct recent_entry *e = v;\n\tstruct recent_iter_state *st = seq->private;\n\tconst struct recent_table *t = st->table;\n\tunsigned int i;\n\n\ti = (e->index - 1) & t->nstamps_max_mask;\n\n\tif (e->family == NFPROTO_IPV4)\n\t\tseq_printf(seq, \"src=%pI4 ttl: %u last_seen: %lu oldest_pkt: %u\",\n\t\t\t   &e->addr.ip, e->ttl, e->stamps[i], e->index);\n\telse\n\t\tseq_printf(seq, \"src=%pI6 ttl: %u last_seen: %lu oldest_pkt: %u\",\n\t\t\t   &e->addr.in6, e->ttl, e->stamps[i], e->index);\n\tfor (i = 0; i < e->nstamps; i++)\n\t\tseq_printf(seq, \"%s %lu\", i ? \",\" : \"\", e->stamps[i]);\n\tseq_putc(seq, '\\n');\n\treturn 0;\n}\n\nstatic const struct seq_operations recent_seq_ops = {\n\t.start\t\t= recent_seq_start,\n\t.next\t\t= recent_seq_next,\n\t.stop\t\t= recent_seq_stop,\n\t.show\t\t= recent_seq_show,\n};\n\nstatic int recent_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct recent_iter_state *st;\n\n\tst = __seq_open_private(file, &recent_seq_ops, sizeof(*st));\n\tif (st == NULL)\n\t\treturn -ENOMEM;\n\n\tst->table    = pde_data(inode);\n\treturn 0;\n}\n\nstatic ssize_t\nrecent_mt_proc_write(struct file *file, const char __user *input,\n\t\t     size_t size, loff_t *loff)\n{\n\tstruct recent_table *t = pde_data(file_inode(file));\n\tstruct recent_entry *e;\n\tchar buf[sizeof(\"+b335:1d35:1e55:dead:c0de:1715:255.255.255.255\")];\n\tconst char *c = buf;\n\tunion nf_inet_addr addr = {};\n\tu_int16_t family;\n\tbool add, succ;\n\n\tif (size == 0)\n\t\treturn 0;\n\tif (size > sizeof(buf))\n\t\tsize = sizeof(buf);\n\tif (copy_from_user(buf, input, size) != 0)\n\t\treturn -EFAULT;\n\n\t \n\tif (*loff != 0)\n\t\treturn -ESPIPE;\n\tswitch (*c) {\n\tcase '/':  \n\t\tspin_lock_bh(&recent_lock);\n\t\trecent_table_flush(t);\n\t\tspin_unlock_bh(&recent_lock);\n\t\treturn size;\n\tcase '-':  \n\t\tadd = false;\n\t\tbreak;\n\tcase '+':  \n\t\tadd = true;\n\t\tbreak;\n\tdefault:\n\t\tpr_info_ratelimited(\"Need \\\"+ip\\\", \\\"-ip\\\" or \\\"/\\\"\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t++c;\n\t--size;\n\tif (strnchr(c, size, ':') != NULL) {\n\t\tfamily = NFPROTO_IPV6;\n\t\tsucc   = in6_pton(c, size, (void *)&addr, '\\n', NULL);\n\t} else {\n\t\tfamily = NFPROTO_IPV4;\n\t\tsucc   = in4_pton(c, size, (void *)&addr, '\\n', NULL);\n\t}\n\n\tif (!succ)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&recent_lock);\n\te = recent_entry_lookup(t, &addr, family, 0);\n\tif (e == NULL) {\n\t\tif (add)\n\t\t\trecent_entry_init(t, &addr, family, 0);\n\t} else {\n\t\tif (add)\n\t\t\trecent_entry_update(t, e);\n\t\telse\n\t\t\trecent_entry_remove(t, e);\n\t}\n\tspin_unlock_bh(&recent_lock);\n\t \n\t*loff += size + 1;\n\treturn size + 1;\n}\n\nstatic const struct proc_ops recent_mt_proc_ops = {\n\t.proc_open\t= recent_seq_open,\n\t.proc_read\t= seq_read,\n\t.proc_write\t= recent_mt_proc_write,\n\t.proc_release\t= seq_release_private,\n\t.proc_lseek\t= seq_lseek,\n};\n\nstatic int __net_init recent_proc_net_init(struct net *net)\n{\n\tstruct recent_net *recent_net = recent_pernet(net);\n\n\trecent_net->xt_recent = proc_mkdir(\"xt_recent\", net->proc_net);\n\tif (!recent_net->xt_recent)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __net_exit recent_proc_net_exit(struct net *net)\n{\n\tstruct recent_net *recent_net = recent_pernet(net);\n\tstruct recent_table *t;\n\n\t \n\tspin_lock_bh(&recent_lock);\n\tlist_for_each_entry(t, &recent_net->tables, list)\n\t        remove_proc_entry(t->name, recent_net->xt_recent);\n\n\trecent_net->xt_recent = NULL;\n\tspin_unlock_bh(&recent_lock);\n\n\tremove_proc_entry(\"xt_recent\", net->proc_net);\n}\n#else\nstatic inline int recent_proc_net_init(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void recent_proc_net_exit(struct net *net)\n{\n}\n#endif  \n\nstatic int __net_init recent_net_init(struct net *net)\n{\n\tstruct recent_net *recent_net = recent_pernet(net);\n\n\tINIT_LIST_HEAD(&recent_net->tables);\n\treturn recent_proc_net_init(net);\n}\n\nstatic void __net_exit recent_net_exit(struct net *net)\n{\n\trecent_proc_net_exit(net);\n}\n\nstatic struct pernet_operations recent_net_ops = {\n\t.init\t= recent_net_init,\n\t.exit\t= recent_net_exit,\n\t.id\t= &recent_net_id,\n\t.size\t= sizeof(struct recent_net),\n};\n\nstatic struct xt_match recent_mt_reg[] __read_mostly = {\n\t{\n\t\t.name       = \"recent\",\n\t\t.revision   = 0,\n\t\t.family     = NFPROTO_IPV4,\n\t\t.match      = recent_mt,\n\t\t.matchsize  = sizeof(struct xt_recent_mtinfo),\n\t\t.checkentry = recent_mt_check_v0,\n\t\t.destroy    = recent_mt_destroy,\n\t\t.me         = THIS_MODULE,\n\t},\n\t{\n\t\t.name       = \"recent\",\n\t\t.revision   = 0,\n\t\t.family     = NFPROTO_IPV6,\n\t\t.match      = recent_mt,\n\t\t.matchsize  = sizeof(struct xt_recent_mtinfo),\n\t\t.checkentry = recent_mt_check_v0,\n\t\t.destroy    = recent_mt_destroy,\n\t\t.me         = THIS_MODULE,\n\t},\n\t{\n\t\t.name       = \"recent\",\n\t\t.revision   = 1,\n\t\t.family     = NFPROTO_IPV4,\n\t\t.match      = recent_mt,\n\t\t.matchsize  = sizeof(struct xt_recent_mtinfo_v1),\n\t\t.checkentry = recent_mt_check_v1,\n\t\t.destroy    = recent_mt_destroy,\n\t\t.me         = THIS_MODULE,\n\t},\n\t{\n\t\t.name       = \"recent\",\n\t\t.revision   = 1,\n\t\t.family     = NFPROTO_IPV6,\n\t\t.match      = recent_mt,\n\t\t.matchsize  = sizeof(struct xt_recent_mtinfo_v1),\n\t\t.checkentry = recent_mt_check_v1,\n\t\t.destroy    = recent_mt_destroy,\n\t\t.me         = THIS_MODULE,\n\t}\n};\n\nstatic int __init recent_mt_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(XT_RECENT_MAX_NSTAMPS);\n\n\tif (!ip_list_tot || ip_pkt_list_tot >= XT_RECENT_MAX_NSTAMPS)\n\t\treturn -EINVAL;\n\tip_list_hash_size = 1 << fls(ip_list_tot);\n\n\terr = register_pernet_subsys(&recent_net_ops);\n\tif (err)\n\t\treturn err;\n\terr = xt_register_matches(recent_mt_reg, ARRAY_SIZE(recent_mt_reg));\n\tif (err)\n\t\tunregister_pernet_subsys(&recent_net_ops);\n\treturn err;\n}\n\nstatic void __exit recent_mt_exit(void)\n{\n\txt_unregister_matches(recent_mt_reg, ARRAY_SIZE(recent_mt_reg));\n\tunregister_pernet_subsys(&recent_net_ops);\n}\n\nmodule_init(recent_mt_init);\nmodule_exit(recent_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}