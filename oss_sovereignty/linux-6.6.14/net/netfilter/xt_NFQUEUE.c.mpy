{
  "module_name": "xt_NFQUEUE.c",
  "hash_id": "b40331c24b41bcdc9080c3202b1bbdd71dd19598c095aa05d0e37385c429bdbb",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_NFQUEUE.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_arp.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_NFQUEUE.h>\n\n#include <net/netfilter/nf_queue.h>\n\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: packet forwarding to netlink\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_NFQUEUE\");\nMODULE_ALIAS(\"ip6t_NFQUEUE\");\nMODULE_ALIAS(\"arpt_NFQUEUE\");\n\nstatic u32 jhash_initval __read_mostly;\n\nstatic unsigned int\nnfqueue_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_NFQ_info *tinfo = par->targinfo;\n\n\treturn NF_QUEUE_NR(tinfo->queuenum);\n}\n\nstatic unsigned int\nnfqueue_tg_v1(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_NFQ_info_v1 *info = par->targinfo;\n\tu32 queue = info->queuenum;\n\n\tif (info->queues_total > 1) {\n\t\tqueue = nfqueue_hash(skb, queue, info->queues_total,\n\t\t\t\t     xt_family(par), jhash_initval);\n\t}\n\treturn NF_QUEUE_NR(queue);\n}\n\nstatic unsigned int\nnfqueue_tg_v2(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_NFQ_info_v2 *info = par->targinfo;\n\tunsigned int ret = nfqueue_tg_v1(skb, par);\n\n\tif (info->bypass)\n\t\tret |= NF_VERDICT_FLAG_QUEUE_BYPASS;\n\treturn ret;\n}\n\nstatic int nfqueue_tg_check(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_NFQ_info_v3 *info = par->targinfo;\n\tu32 maxid;\n\n\tinit_hashrandom(&jhash_initval);\n\n\tif (info->queues_total == 0) {\n\t\tpr_info_ratelimited(\"number of total queues is 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmaxid = info->queues_total - 1 + info->queuenum;\n\tif (maxid > 0xffff) {\n\t\tpr_info_ratelimited(\"number of queues (%u) out of range (got %u)\\n\",\n\t\t\t\t    info->queues_total, maxid);\n\t\treturn -ERANGE;\n\t}\n\tif (par->target->revision == 2 && info->flags > 1)\n\t\treturn -EINVAL;\n\tif (par->target->revision == 3 && info->flags & ~NFQ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic unsigned int\nnfqueue_tg_v3(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_NFQ_info_v3 *info = par->targinfo;\n\tu32 queue = info->queuenum;\n\tint ret;\n\n\tif (info->queues_total > 1) {\n\t\tif (info->flags & NFQ_FLAG_CPU_FANOUT) {\n\t\t\tint cpu = smp_processor_id();\n\n\t\t\tqueue = info->queuenum + cpu % info->queues_total;\n\t\t} else {\n\t\t\tqueue = nfqueue_hash(skb, queue, info->queues_total,\n\t\t\t\t\t     xt_family(par), jhash_initval);\n\t\t}\n\t}\n\n\tret = NF_QUEUE_NR(queue);\n\tif (info->flags & NFQ_FLAG_BYPASS)\n\t\tret |= NF_VERDICT_FLAG_QUEUE_BYPASS;\n\n\treturn ret;\n}\n\nstatic struct xt_target nfqueue_tg_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"NFQUEUE\",\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.target\t\t= nfqueue_tg,\n\t\t.targetsize\t= sizeof(struct xt_NFQ_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"NFQUEUE\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.checkentry\t= nfqueue_tg_check,\n\t\t.target\t\t= nfqueue_tg_v1,\n\t\t.targetsize\t= sizeof(struct xt_NFQ_info_v1),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"NFQUEUE\",\n\t\t.revision\t= 2,\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.checkentry\t= nfqueue_tg_check,\n\t\t.target\t\t= nfqueue_tg_v2,\n\t\t.targetsize\t= sizeof(struct xt_NFQ_info_v2),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"NFQUEUE\",\n\t\t.revision\t= 3,\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.checkentry\t= nfqueue_tg_check,\n\t\t.target\t\t= nfqueue_tg_v3,\n\t\t.targetsize\t= sizeof(struct xt_NFQ_info_v3),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init nfqueue_tg_init(void)\n{\n\treturn xt_register_targets(nfqueue_tg_reg, ARRAY_SIZE(nfqueue_tg_reg));\n}\n\nstatic void __exit nfqueue_tg_exit(void)\n{\n\txt_unregister_targets(nfqueue_tg_reg, ARRAY_SIZE(nfqueue_tg_reg));\n}\n\nmodule_init(nfqueue_tg_init);\nmodule_exit(nfqueue_tg_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}