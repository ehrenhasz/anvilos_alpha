{
  "module_name": "xt_CONNSECMARK.c",
  "hash_id": "2822dd0d94a7bf6129180f0ba12428b22f127ac123c6e7a2545dae82687a870b",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_CONNSECMARK.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_CONNSECMARK.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Morris <jmorris@redhat.com>\");\nMODULE_DESCRIPTION(\"Xtables: target for copying between connection and security mark\");\nMODULE_ALIAS(\"ipt_CONNSECMARK\");\nMODULE_ALIAS(\"ip6t_CONNSECMARK\");\n\n \nstatic void secmark_save(const struct sk_buff *skb)\n{\n\tif (skb->secmark) {\n\t\tstruct nf_conn *ct;\n\t\tenum ip_conntrack_info ctinfo;\n\n\t\tct = nf_ct_get(skb, &ctinfo);\n\t\tif (ct && !ct->secmark) {\n\t\t\tct->secmark = skb->secmark;\n\t\t\tnf_conntrack_event_cache(IPCT_SECMARK, ct);\n\t\t}\n\t}\n}\n\n \nstatic void secmark_restore(struct sk_buff *skb)\n{\n\tif (!skb->secmark) {\n\t\tconst struct nf_conn *ct;\n\t\tenum ip_conntrack_info ctinfo;\n\n\t\tct = nf_ct_get(skb, &ctinfo);\n\t\tif (ct && ct->secmark)\n\t\t\tskb->secmark = ct->secmark;\n\t}\n}\n\nstatic unsigned int\nconnsecmark_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_connsecmark_target_info *info = par->targinfo;\n\n\tswitch (info->mode) {\n\tcase CONNSECMARK_SAVE:\n\t\tsecmark_save(skb);\n\t\tbreak;\n\n\tcase CONNSECMARK_RESTORE:\n\t\tsecmark_restore(skb);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn XT_CONTINUE;\n}\n\nstatic int connsecmark_tg_check(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_connsecmark_target_info *info = par->targinfo;\n\tint ret;\n\n\tif (strcmp(par->table, \"mangle\") != 0 &&\n\t    strcmp(par->table, \"security\") != 0) {\n\t\tpr_info_ratelimited(\"only valid in \\'mangle\\' or \\'security\\' table, not \\'%s\\'\\n\",\n\t\t\t\t    par->table);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (info->mode) {\n\tcase CONNSECMARK_SAVE:\n\tcase CONNSECMARK_RESTORE:\n\t\tbreak;\n\n\tdefault:\n\t\tpr_info_ratelimited(\"invalid mode: %hu\\n\", info->mode);\n\t\treturn -EINVAL;\n\t}\n\n\tret = nf_ct_netns_get(par->net, par->family);\n\tif (ret < 0)\n\t\tpr_info_ratelimited(\"cannot load conntrack support for proto=%u\\n\",\n\t\t\t\t    par->family);\n\treturn ret;\n}\n\nstatic void connsecmark_tg_destroy(const struct xt_tgdtor_param *par)\n{\n\tnf_ct_netns_put(par->net, par->family);\n}\n\nstatic struct xt_target connsecmark_tg_reg __read_mostly = {\n\t.name       = \"CONNSECMARK\",\n\t.revision   = 0,\n\t.family     = NFPROTO_UNSPEC,\n\t.checkentry = connsecmark_tg_check,\n\t.destroy    = connsecmark_tg_destroy,\n\t.target     = connsecmark_tg,\n\t.targetsize = sizeof(struct xt_connsecmark_target_info),\n\t.me         = THIS_MODULE,\n};\n\nstatic int __init connsecmark_tg_init(void)\n{\n\treturn xt_register_target(&connsecmark_tg_reg);\n}\n\nstatic void __exit connsecmark_tg_exit(void)\n{\n\txt_unregister_target(&connsecmark_tg_reg);\n}\n\nmodule_init(connsecmark_tg_init);\nmodule_exit(connsecmark_tg_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}