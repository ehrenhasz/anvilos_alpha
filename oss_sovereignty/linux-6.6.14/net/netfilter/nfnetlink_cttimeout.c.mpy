{
  "module_name": "nfnetlink_cttimeout.c",
  "hash_id": "5867f9445bf619a9f9c940cdd162a00a050434e7b92933c61259398c9e056369",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nfnetlink_cttimeout.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rculist_nulls.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/netlink.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\n#include <linux/netfilter.h>\n#include <net/netlink.h>\n#include <net/netns/generic.h>\n#include <net/sock.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_tuple.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_cttimeout.h>\n\nstatic unsigned int nfct_timeout_id __read_mostly;\n\nstruct ctnl_timeout {\n\tstruct list_head\thead;\n\tstruct list_head\tfree_head;\n\tstruct rcu_head\t\trcu_head;\n\trefcount_t\t\trefcnt;\n\tchar\t\t\tname[CTNL_TIMEOUT_NAME_MAX];\n\n\t \n\tstruct nf_ct_timeout\ttimeout;\n};\n\nstruct nfct_timeout_pernet {\n\tstruct list_head\tnfct_timeout_list;\n\tstruct list_head\tnfct_timeout_freelist;\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_DESCRIPTION(\"cttimeout: Extended Netfilter Connection Tracking timeout tuning\");\n\nstatic const struct nla_policy cttimeout_nla_policy[CTA_TIMEOUT_MAX+1] = {\n\t[CTA_TIMEOUT_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len  = CTNL_TIMEOUT_NAME_MAX - 1},\n\t[CTA_TIMEOUT_L3PROTO]\t= { .type = NLA_U16 },\n\t[CTA_TIMEOUT_L4PROTO]\t= { .type = NLA_U8 },\n\t[CTA_TIMEOUT_DATA]\t= { .type = NLA_NESTED },\n};\n\nstatic struct nfct_timeout_pernet *nfct_timeout_pernet(struct net *net)\n{\n\treturn net_generic(net, nfct_timeout_id);\n}\n\nstatic int\nctnl_timeout_parse_policy(void *timeout,\n\t\t\t  const struct nf_conntrack_l4proto *l4proto,\n\t\t\t  struct net *net, const struct nlattr *attr)\n{\n\tstruct nlattr **tb;\n\tint ret = 0;\n\n\ttb = kcalloc(l4proto->ctnl_timeout.nlattr_max + 1, sizeof(*tb),\n\t\t     GFP_KERNEL);\n\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t  l4proto->ctnl_timeout.nlattr_max,\n\t\t\t\t\t  attr,\n\t\t\t\t\t  l4proto->ctnl_timeout.nla_policy,\n\t\t\t\t\t  NULL);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = l4proto->ctnl_timeout.nlattr_to_obj(tb, net, timeout);\n\nerr:\n\tkfree(tb);\n\treturn ret;\n}\n\nstatic int cttimeout_new_timeout(struct sk_buff *skb,\n\t\t\t\t const struct nfnl_info *info,\n\t\t\t\t const struct nlattr * const cda[])\n{\n\tstruct nfct_timeout_pernet *pernet = nfct_timeout_pernet(info->net);\n\t__u16 l3num;\n\t__u8 l4num;\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tstruct ctnl_timeout *timeout, *matching = NULL;\n\tchar *name;\n\tint ret;\n\n\tif (!cda[CTA_TIMEOUT_NAME] ||\n\t    !cda[CTA_TIMEOUT_L3PROTO] ||\n\t    !cda[CTA_TIMEOUT_L4PROTO] ||\n\t    !cda[CTA_TIMEOUT_DATA])\n\t\treturn -EINVAL;\n\n\tname = nla_data(cda[CTA_TIMEOUT_NAME]);\n\tl3num = ntohs(nla_get_be16(cda[CTA_TIMEOUT_L3PROTO]));\n\tl4num = nla_get_u8(cda[CTA_TIMEOUT_L4PROTO]);\n\n\tlist_for_each_entry(timeout, &pernet->nfct_timeout_list, head) {\n\t\tif (strncmp(timeout->name, name, CTNL_TIMEOUT_NAME_MAX) != 0)\n\t\t\tcontinue;\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL)\n\t\t\treturn -EEXIST;\n\n\t\tmatching = timeout;\n\t\tbreak;\n\t}\n\n\tif (matching) {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE) {\n\t\t\t \n\t\t\tif (matching->timeout.l3num != l3num ||\n\t\t\t    matching->timeout.l4proto->l4proto != l4num)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn ctnl_timeout_parse_policy(&matching->timeout.data,\n\t\t\t\t\t\t\t matching->timeout.l4proto,\n\t\t\t\t\t\t\t info->net,\n\t\t\t\t\t\t\t cda[CTA_TIMEOUT_DATA]);\n\t\t}\n\n\t\treturn -EBUSY;\n\t}\n\n\tl4proto = nf_ct_l4proto_find(l4num);\n\n\t \n\tif (l4proto->l4proto != l4num) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_proto_put;\n\t}\n\n\ttimeout = kzalloc(sizeof(struct ctnl_timeout) +\n\t\t\t  l4proto->ctnl_timeout.obj_size, GFP_KERNEL);\n\tif (timeout == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_proto_put;\n\t}\n\n\tret = ctnl_timeout_parse_policy(&timeout->timeout.data, l4proto,\n\t\t\t\t\tinfo->net, cda[CTA_TIMEOUT_DATA]);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tstrcpy(timeout->name, nla_data(cda[CTA_TIMEOUT_NAME]));\n\ttimeout->timeout.l3num = l3num;\n\ttimeout->timeout.l4proto = l4proto;\n\trefcount_set(&timeout->refcnt, 1);\n\t__module_get(THIS_MODULE);\n\tlist_add_tail_rcu(&timeout->head, &pernet->nfct_timeout_list);\n\n\treturn 0;\nerr:\n\tkfree(timeout);\nerr_proto_put:\n\treturn ret;\n}\n\nstatic int\nctnl_timeout_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\n\t\t       int event, struct ctnl_timeout *timeout)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned int flags = portid ? NLM_F_MULTI : 0;\n\tconst struct nf_conntrack_l4proto *l4proto = timeout->timeout.l4proto;\n\tstruct nlattr *nest_parms;\n\tint ret;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_CTNETLINK_TIMEOUT, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, AF_UNSPEC,\n\t\t\t   NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tif (nla_put_string(skb, CTA_TIMEOUT_NAME, timeout->name) ||\n\t    nla_put_be16(skb, CTA_TIMEOUT_L3PROTO,\n\t\t\t htons(timeout->timeout.l3num)) ||\n\t    nla_put_u8(skb, CTA_TIMEOUT_L4PROTO, l4proto->l4proto) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_USE,\n\t\t\t htonl(refcount_read(&timeout->refcnt))))\n\t\tgoto nla_put_failure;\n\n\tnest_parms = nla_nest_start(skb, CTA_TIMEOUT_DATA);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\n\tret = l4proto->ctnl_timeout.obj_to_nlattr(skb, &timeout->timeout.data);\n\tif (ret < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest_parms);\n\n\tnlmsg_end(skb, nlh);\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -1;\n}\n\nstatic int\nctnl_timeout_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nfct_timeout_pernet *pernet;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ctnl_timeout *cur, *last;\n\n\tif (cb->args[2])\n\t\treturn 0;\n\n\tlast = (struct ctnl_timeout *)cb->args[1];\n\tif (cb->args[1])\n\t\tcb->args[1] = 0;\n\n\trcu_read_lock();\n\tpernet = nfct_timeout_pernet(net);\n\tlist_for_each_entry_rcu(cur, &pernet->nfct_timeout_list, head) {\n\t\tif (last) {\n\t\t\tif (cur != last)\n\t\t\t\tcontinue;\n\n\t\t\tlast = NULL;\n\t\t}\n\t\tif (ctnl_timeout_fill_info(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq,\n\t\t\t\t\t   NFNL_MSG_TYPE(cb->nlh->nlmsg_type),\n\t\t\t\t\t   IPCTNL_MSG_TIMEOUT_NEW, cur) < 0) {\n\t\t\tcb->args[1] = (unsigned long)cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cb->args[1])\n\t\tcb->args[2] = 1;\n\trcu_read_unlock();\n\treturn skb->len;\n}\n\nstatic int cttimeout_get_timeout(struct sk_buff *skb,\n\t\t\t\t const struct nfnl_info *info,\n\t\t\t\t const struct nlattr * const cda[])\n{\n\tstruct nfct_timeout_pernet *pernet = nfct_timeout_pernet(info->net);\n\tint ret = -ENOENT;\n\tchar *name;\n\tstruct ctnl_timeout *cur;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = ctnl_timeout_dump,\n\t\t};\n\t\treturn netlink_dump_start(info->sk, skb, info->nlh, &c);\n\t}\n\n\tif (!cda[CTA_TIMEOUT_NAME])\n\t\treturn -EINVAL;\n\tname = nla_data(cda[CTA_TIMEOUT_NAME]);\n\n\tlist_for_each_entry(cur, &pernet->nfct_timeout_list, head) {\n\t\tstruct sk_buff *skb2;\n\n\t\tif (strncmp(cur->name, name, CTNL_TIMEOUT_NAME_MAX) != 0)\n\t\t\tcontinue;\n\n\t\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (skb2 == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ctnl_timeout_fill_info(skb2, NETLINK_CB(skb).portid,\n\t\t\t\t\t     info->nlh->nlmsg_seq,\n\t\t\t\t\t     NFNL_MSG_TYPE(info->nlh->nlmsg_type),\n\t\t\t\t\t     IPCTNL_MSG_TIMEOUT_NEW, cur);\n\t\tif (ret <= 0) {\n\t\t\tkfree_skb(skb2);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ctnl_timeout_try_del(struct net *net, struct ctnl_timeout *timeout)\n{\n\tint ret = 0;\n\n\t \n\tif (refcount_dec_if_one(&timeout->refcnt)) {\n\t\t \n\t\tlist_del_rcu(&timeout->head);\n\t\tnf_ct_untimeout(net, &timeout->timeout);\n\t\tkfree_rcu(timeout, rcu_head);\n\t} else {\n\t\tret = -EBUSY;\n\t}\n\treturn ret;\n}\n\nstatic int cttimeout_del_timeout(struct sk_buff *skb,\n\t\t\t\t const struct nfnl_info *info,\n\t\t\t\t const struct nlattr * const cda[])\n{\n\tstruct nfct_timeout_pernet *pernet = nfct_timeout_pernet(info->net);\n\tstruct ctnl_timeout *cur, *tmp;\n\tint ret = -ENOENT;\n\tchar *name;\n\n\tif (!cda[CTA_TIMEOUT_NAME]) {\n\t\tlist_for_each_entry_safe(cur, tmp, &pernet->nfct_timeout_list,\n\t\t\t\t\t head)\n\t\t\tctnl_timeout_try_del(info->net, cur);\n\n\t\treturn 0;\n\t}\n\tname = nla_data(cda[CTA_TIMEOUT_NAME]);\n\n\tlist_for_each_entry(cur, &pernet->nfct_timeout_list, head) {\n\t\tif (strncmp(cur->name, name, CTNL_TIMEOUT_NAME_MAX) != 0)\n\t\t\tcontinue;\n\n\t\tret = ctnl_timeout_try_del(info->net, cur);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int cttimeout_default_set(struct sk_buff *skb,\n\t\t\t\t const struct nfnl_info *info,\n\t\t\t\t const struct nlattr * const cda[])\n{\n\tconst struct nf_conntrack_l4proto *l4proto;\n\t__u8 l4num;\n\tint ret;\n\n\tif (!cda[CTA_TIMEOUT_L3PROTO] ||\n\t    !cda[CTA_TIMEOUT_L4PROTO] ||\n\t    !cda[CTA_TIMEOUT_DATA])\n\t\treturn -EINVAL;\n\n\tl4num = nla_get_u8(cda[CTA_TIMEOUT_L4PROTO]);\n\tl4proto = nf_ct_l4proto_find(l4num);\n\n\t \n\tif (l4proto->l4proto != l4num) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\tret = ctnl_timeout_parse_policy(NULL, l4proto, info->net,\n\t\t\t\t\tcda[CTA_TIMEOUT_DATA]);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int\ncttimeout_default_fill_info(struct net *net, struct sk_buff *skb, u32 portid,\n\t\t\t    u32 seq, u32 type, int event, u16 l3num,\n\t\t\t    const struct nf_conntrack_l4proto *l4proto,\n\t\t\t    const unsigned int *timeouts)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned int flags = portid ? NLM_F_MULTI : 0;\n\tstruct nlattr *nest_parms;\n\tint ret;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_CTNETLINK_TIMEOUT, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, AF_UNSPEC,\n\t\t\t   NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tif (nla_put_be16(skb, CTA_TIMEOUT_L3PROTO, htons(l3num)) ||\n\t    nla_put_u8(skb, CTA_TIMEOUT_L4PROTO, l4proto->l4proto))\n\t\tgoto nla_put_failure;\n\n\tnest_parms = nla_nest_start(skb, CTA_TIMEOUT_DATA);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\n\tret = l4proto->ctnl_timeout.obj_to_nlattr(skb, timeouts);\n\tif (ret < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest_parms);\n\n\tnlmsg_end(skb, nlh);\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -1;\n}\n\nstatic int cttimeout_default_get(struct sk_buff *skb,\n\t\t\t\t const struct nfnl_info *info,\n\t\t\t\t const struct nlattr * const cda[])\n{\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tunsigned int *timeouts = NULL;\n\tstruct sk_buff *skb2;\n\t__u16 l3num;\n\t__u8 l4num;\n\tint ret;\n\n\tif (!cda[CTA_TIMEOUT_L3PROTO] || !cda[CTA_TIMEOUT_L4PROTO])\n\t\treturn -EINVAL;\n\n\tl3num = ntohs(nla_get_be16(cda[CTA_TIMEOUT_L3PROTO]));\n\tl4num = nla_get_u8(cda[CTA_TIMEOUT_L4PROTO]);\n\tl4proto = nf_ct_l4proto_find(l4num);\n\n\tif (l4proto->l4proto != l4num)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (l4proto->l4proto) {\n\tcase IPPROTO_ICMP:\n\t\ttimeouts = &nf_icmp_pernet(info->net)->timeout;\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\ttimeouts = nf_tcp_pernet(info->net)->timeouts;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\t\ttimeouts = nf_udp_pernet(info->net)->timeouts;\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n#ifdef CONFIG_NF_CT_PROTO_DCCP\n\t\ttimeouts = nf_dccp_pernet(info->net)->dccp_timeout;\n#endif\n\t\tbreak;\n\tcase IPPROTO_ICMPV6:\n\t\ttimeouts = &nf_icmpv6_pernet(info->net)->timeout;\n\t\tbreak;\n\tcase IPPROTO_SCTP:\n#ifdef CONFIG_NF_CT_PROTO_SCTP\n\t\ttimeouts = nf_sctp_pernet(info->net)->timeouts;\n#endif\n\t\tbreak;\n\tcase IPPROTO_GRE:\n#ifdef CONFIG_NF_CT_PROTO_GRE\n\t\ttimeouts = nf_gre_pernet(info->net)->timeouts;\n#endif\n\t\tbreak;\n\tcase 255:\n\t\ttimeouts = &nf_generic_pernet(info->net)->timeout;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Missing timeouts for proto %d\", l4proto->l4proto);\n\t\tbreak;\n\t}\n\n\tif (!timeouts)\n\t\treturn -EOPNOTSUPP;\n\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\tret = cttimeout_default_fill_info(info->net, skb2,\n\t\t\t\t\t  NETLINK_CB(skb).portid,\n\t\t\t\t\t  info->nlh->nlmsg_seq,\n\t\t\t\t\t  NFNL_MSG_TYPE(info->nlh->nlmsg_type),\n\t\t\t\t\t  IPCTNL_MSG_TIMEOUT_DEFAULT_SET,\n\t\t\t\t\t  l3num, l4proto, timeouts);\n\tif (ret <= 0) {\n\t\tkfree_skb(skb2);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n}\n\nstatic struct nf_ct_timeout *ctnl_timeout_find_get(struct net *net,\n\t\t\t\t\t\t   const char *name)\n{\n\tstruct nfct_timeout_pernet *pernet = nfct_timeout_pernet(net);\n\tstruct ctnl_timeout *timeout, *matching = NULL;\n\n\tlist_for_each_entry_rcu(timeout, &pernet->nfct_timeout_list, head) {\n\t\tif (strncmp(timeout->name, name, CTNL_TIMEOUT_NAME_MAX) != 0)\n\t\t\tcontinue;\n\n\t\tif (!refcount_inc_not_zero(&timeout->refcnt))\n\t\t\tgoto err;\n\t\tmatching = timeout;\n\t\tbreak;\n\t}\nerr:\n\treturn matching ? &matching->timeout : NULL;\n}\n\nstatic void ctnl_timeout_put(struct nf_ct_timeout *t)\n{\n\tstruct ctnl_timeout *timeout =\n\t\tcontainer_of(t, struct ctnl_timeout, timeout);\n\n\tif (refcount_dec_and_test(&timeout->refcnt)) {\n\t\tkfree_rcu(timeout, rcu_head);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}\n\nstatic const struct nfnl_callback cttimeout_cb[IPCTNL_MSG_TIMEOUT_MAX] = {\n\t[IPCTNL_MSG_TIMEOUT_NEW] = {\n\t\t.call\t\t= cttimeout_new_timeout,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_TIMEOUT_MAX,\n\t\t.policy\t\t= cttimeout_nla_policy\n\t},\n\t[IPCTNL_MSG_TIMEOUT_GET] = {\n\t\t.call\t\t= cttimeout_get_timeout,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_TIMEOUT_MAX,\n\t\t.policy\t\t= cttimeout_nla_policy\n\t},\n\t[IPCTNL_MSG_TIMEOUT_DELETE] = {\n\t\t.call\t\t= cttimeout_del_timeout,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_TIMEOUT_MAX,\n\t\t.policy\t\t= cttimeout_nla_policy\n\t},\n\t[IPCTNL_MSG_TIMEOUT_DEFAULT_SET] = {\n\t\t.call\t\t= cttimeout_default_set,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_TIMEOUT_MAX,\n\t\t.policy\t\t= cttimeout_nla_policy\n\t},\n\t[IPCTNL_MSG_TIMEOUT_DEFAULT_GET] = {\n\t\t.call\t\t= cttimeout_default_get,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_TIMEOUT_MAX,\n\t\t.policy\t\t= cttimeout_nla_policy\n\t},\n};\n\nstatic const struct nfnetlink_subsystem cttimeout_subsys = {\n\t.name\t\t\t\t= \"conntrack_timeout\",\n\t.subsys_id\t\t\t= NFNL_SUBSYS_CTNETLINK_TIMEOUT,\n\t.cb_count\t\t\t= IPCTNL_MSG_TIMEOUT_MAX,\n\t.cb\t\t\t\t= cttimeout_cb,\n};\n\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_CTNETLINK_TIMEOUT);\n\nstatic int __net_init cttimeout_net_init(struct net *net)\n{\n\tstruct nfct_timeout_pernet *pernet = nfct_timeout_pernet(net);\n\n\tINIT_LIST_HEAD(&pernet->nfct_timeout_list);\n\tINIT_LIST_HEAD(&pernet->nfct_timeout_freelist);\n\n\treturn 0;\n}\n\nstatic void __net_exit cttimeout_net_pre_exit(struct net *net)\n{\n\tstruct nfct_timeout_pernet *pernet = nfct_timeout_pernet(net);\n\tstruct ctnl_timeout *cur, *tmp;\n\n\tlist_for_each_entry_safe(cur, tmp, &pernet->nfct_timeout_list, head) {\n\t\tlist_del_rcu(&cur->head);\n\t\tlist_add(&cur->free_head, &pernet->nfct_timeout_freelist);\n\t}\n\n\t \n}\n\nstatic void __net_exit cttimeout_net_exit(struct net *net)\n{\n\tstruct nfct_timeout_pernet *pernet = nfct_timeout_pernet(net);\n\tstruct ctnl_timeout *cur, *tmp;\n\n\tif (list_empty(&pernet->nfct_timeout_freelist))\n\t\treturn;\n\n\tnf_ct_untimeout(net, NULL);\n\n\tlist_for_each_entry_safe(cur, tmp, &pernet->nfct_timeout_freelist, free_head) {\n\t\tlist_del(&cur->free_head);\n\n\t\tif (refcount_dec_and_test(&cur->refcnt))\n\t\t\tkfree_rcu(cur, rcu_head);\n\t}\n}\n\nstatic struct pernet_operations cttimeout_ops = {\n\t.init\t= cttimeout_net_init,\n\t.pre_exit = cttimeout_net_pre_exit,\n\t.exit\t= cttimeout_net_exit,\n\t.id     = &nfct_timeout_id,\n\t.size   = sizeof(struct nfct_timeout_pernet),\n};\n\nstatic const struct nf_ct_timeout_hooks hooks = {\n\t.timeout_find_get = ctnl_timeout_find_get,\n\t.timeout_put = ctnl_timeout_put,\n};\n\nstatic int __init cttimeout_init(void)\n{\n\tint ret;\n\n\tret = register_pernet_subsys(&cttimeout_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nfnetlink_subsys_register(&cttimeout_subsys);\n\tif (ret < 0) {\n\t\tpr_err(\"cttimeout_init: cannot register cttimeout with \"\n\t\t\t\"nfnetlink.\\n\");\n\t\tgoto err_out;\n\t}\n\tRCU_INIT_POINTER(nf_ct_timeout_hook, &hooks);\n\treturn 0;\n\nerr_out:\n\tunregister_pernet_subsys(&cttimeout_ops);\n\treturn ret;\n}\n\nstatic int untimeout(struct nf_conn *ct, void *timeout)\n{\n\tstruct nf_conn_timeout *timeout_ext = nf_ct_timeout_find(ct);\n\n\tif (timeout_ext)\n\t\tRCU_INIT_POINTER(timeout_ext->timeout, NULL);\n\n\treturn 0;\n}\n\nstatic void __exit cttimeout_exit(void)\n{\n\tnfnetlink_subsys_unregister(&cttimeout_subsys);\n\n\tunregister_pernet_subsys(&cttimeout_ops);\n\tRCU_INIT_POINTER(nf_ct_timeout_hook, NULL);\n\n\tnf_ct_iterate_destroy(untimeout, NULL);\n}\n\nmodule_init(cttimeout_init);\nmodule_exit(cttimeout_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}