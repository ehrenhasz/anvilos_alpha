{
  "module_name": "nf_log_syslog.c",
  "hash_id": "d62581e1098d5a2f01a37f51a33c26c2f33f80818aa8b9acbf836a24fc10a096",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_log_syslog.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ip.h>\n#include <net/ipv6.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/tcp.h>\n#include <net/route.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter/xt_LOG.h>\n#include <net/netfilter/nf_log.h>\n\nstatic const struct nf_loginfo default_loginfo = {\n\t.type\t= NF_LOG_TYPE_LOG,\n\t.u = {\n\t\t.log = {\n\t\t\t.level\t  = LOGLEVEL_NOTICE,\n\t\t\t.logflags = NF_LOG_DEFAULT_MASK,\n\t\t},\n\t},\n};\n\nstruct arppayload {\n\tunsigned char mac_src[ETH_ALEN];\n\tunsigned char ip_src[4];\n\tunsigned char mac_dst[ETH_ALEN];\n\tunsigned char ip_dst[4];\n};\n\n \nstatic bool nf_log_allowed(const struct net *net)\n{\n\treturn net_eq(net, &init_net) || sysctl_nf_log_all_netns;\n}\n\nstatic void nf_log_dump_vlan(struct nf_log_buf *m, const struct sk_buff *skb)\n{\n\tu16 vid;\n\n\tif (!skb_vlan_tag_present(skb))\n\t\treturn;\n\n\tvid = skb_vlan_tag_get(skb);\n\tnf_log_buf_add(m, \"VPROTO=%04x VID=%u \", ntohs(skb->vlan_proto), vid);\n}\nstatic void noinline_for_stack\ndump_arp_packet(struct nf_log_buf *m,\n\t\tconst struct nf_loginfo *info,\n\t\tconst struct sk_buff *skb, unsigned int nhoff)\n{\n\tconst struct arppayload *ap;\n\tstruct arppayload _arpp;\n\tconst struct arphdr *ah;\n\tunsigned int logflags;\n\tstruct arphdr _arph;\n\n\tah = skb_header_pointer(skb, nhoff, sizeof(_arph), &_arph);\n\tif (!ah) {\n\t\tnf_log_buf_add(m, \"TRUNCATED\");\n\t\treturn;\n\t}\n\n\tif (info->type == NF_LOG_TYPE_LOG)\n\t\tlogflags = info->u.log.logflags;\n\telse\n\t\tlogflags = NF_LOG_DEFAULT_MASK;\n\n\tif (logflags & NF_LOG_MACDECODE) {\n\t\tnf_log_buf_add(m, \"MACSRC=%pM MACDST=%pM \",\n\t\t\t       eth_hdr(skb)->h_source, eth_hdr(skb)->h_dest);\n\t\tnf_log_dump_vlan(m, skb);\n\t\tnf_log_buf_add(m, \"MACPROTO=%04x \",\n\t\t\t       ntohs(eth_hdr(skb)->h_proto));\n\t}\n\n\tnf_log_buf_add(m, \"ARP HTYPE=%d PTYPE=0x%04x OPCODE=%d\",\n\t\t       ntohs(ah->ar_hrd), ntohs(ah->ar_pro), ntohs(ah->ar_op));\n\t \n\tif (ah->ar_hrd != htons(ARPHRD_ETHER) ||\n\t    ah->ar_hln != ETH_ALEN ||\n\t    ah->ar_pln != sizeof(__be32))\n\t\treturn;\n\n\tap = skb_header_pointer(skb, nhoff + sizeof(_arph), sizeof(_arpp), &_arpp);\n\tif (!ap) {\n\t\tnf_log_buf_add(m, \" INCOMPLETE [%zu bytes]\",\n\t\t\t       skb->len - sizeof(_arph));\n\t\treturn;\n\t}\n\tnf_log_buf_add(m, \" MACSRC=%pM IPSRC=%pI4 MACDST=%pM IPDST=%pI4\",\n\t\t       ap->mac_src, ap->ip_src, ap->mac_dst, ap->ip_dst);\n}\n\nstatic void\nnf_log_dump_packet_common(struct nf_log_buf *m, u8 pf,\n\t\t\t  unsigned int hooknum, const struct sk_buff *skb,\n\t\t\t  const struct net_device *in,\n\t\t\t  const struct net_device *out,\n\t\t\t  const struct nf_loginfo *loginfo, const char *prefix,\n\t\t\t  struct net *net)\n{\n\tconst struct net_device *physoutdev __maybe_unused;\n\tconst struct net_device *physindev __maybe_unused;\n\n\tnf_log_buf_add(m, KERN_SOH \"%c%sIN=%s OUT=%s \",\n\t\t       '0' + loginfo->u.log.level, prefix,\n\t\t\tin ? in->name : \"\",\n\t\t\tout ? out->name : \"\");\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tphysindev = nf_bridge_get_physindev(skb, net);\n\tif (physindev && in != physindev)\n\t\tnf_log_buf_add(m, \"PHYSIN=%s \", physindev->name);\n\tphysoutdev = nf_bridge_get_physoutdev(skb);\n\tif (physoutdev && out != physoutdev)\n\t\tnf_log_buf_add(m, \"PHYSOUT=%s \", physoutdev->name);\n#endif\n}\n\nstatic void nf_log_arp_packet(struct net *net, u_int8_t pf,\n\t\t\t      unsigned int hooknum, const struct sk_buff *skb,\n\t\t\t      const struct net_device *in,\n\t\t\t      const struct net_device *out,\n\t\t\t      const struct nf_loginfo *loginfo,\n\t\t\t      const char *prefix)\n{\n\tstruct nf_log_buf *m;\n\n\tif (!nf_log_allowed(net))\n\t\treturn;\n\n\tm = nf_log_buf_open();\n\n\tif (!loginfo)\n\t\tloginfo = &default_loginfo;\n\n\tnf_log_dump_packet_common(m, pf, hooknum, skb, in, out, loginfo,\n\t\t\t\t  prefix, net);\n\tdump_arp_packet(m, loginfo, skb, skb_network_offset(skb));\n\n\tnf_log_buf_close(m);\n}\n\nstatic struct nf_logger nf_arp_logger __read_mostly = {\n\t.name\t\t= \"nf_log_arp\",\n\t.type\t\t= NF_LOG_TYPE_LOG,\n\t.logfn\t\t= nf_log_arp_packet,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic void nf_log_dump_sk_uid_gid(struct net *net, struct nf_log_buf *m,\n\t\t\t\t   struct sock *sk)\n{\n\tif (!sk || !sk_fullsock(sk) || !net_eq(net, sock_net(sk)))\n\t\treturn;\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tif (sk->sk_socket && sk->sk_socket->file) {\n\t\tconst struct cred *cred = sk->sk_socket->file->f_cred;\n\n\t\tnf_log_buf_add(m, \"UID=%u GID=%u \",\n\t\t\t       from_kuid_munged(&init_user_ns, cred->fsuid),\n\t\t\t       from_kgid_munged(&init_user_ns, cred->fsgid));\n\t}\n\tread_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic noinline_for_stack int\nnf_log_dump_tcp_header(struct nf_log_buf *m,\n\t\t       const struct sk_buff *skb,\n\t\t       u8 proto, int fragment,\n\t\t       unsigned int offset,\n\t\t       unsigned int logflags)\n{\n\tstruct tcphdr _tcph;\n\tconst struct tcphdr *th;\n\n\t \n\tnf_log_buf_add(m, \"PROTO=TCP \");\n\n\tif (fragment)\n\t\treturn 0;\n\n\t \n\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\tif (!th) {\n\t\tnf_log_buf_add(m, \"INCOMPLETE [%u bytes] \", skb->len - offset);\n\t\treturn 1;\n\t}\n\n\t \n\tnf_log_buf_add(m, \"SPT=%u DPT=%u \",\n\t\t       ntohs(th->source), ntohs(th->dest));\n\t \n\tif (logflags & NF_LOG_TCPSEQ) {\n\t\tnf_log_buf_add(m, \"SEQ=%u ACK=%u \",\n\t\t\t       ntohl(th->seq), ntohl(th->ack_seq));\n\t}\n\n\t \n\tnf_log_buf_add(m, \"WINDOW=%u \", ntohs(th->window));\n\t \n\tnf_log_buf_add(m, \"RES=0x%02x \", (u_int8_t)(ntohl(tcp_flag_word(th) &\n\t\t\t\t\t    TCP_RESERVED_BITS) >> 22));\n\t \n\tif (th->cwr)\n\t\tnf_log_buf_add(m, \"CWR \");\n\tif (th->ece)\n\t\tnf_log_buf_add(m, \"ECE \");\n\tif (th->urg)\n\t\tnf_log_buf_add(m, \"URG \");\n\tif (th->ack)\n\t\tnf_log_buf_add(m, \"ACK \");\n\tif (th->psh)\n\t\tnf_log_buf_add(m, \"PSH \");\n\tif (th->rst)\n\t\tnf_log_buf_add(m, \"RST \");\n\tif (th->syn)\n\t\tnf_log_buf_add(m, \"SYN \");\n\tif (th->fin)\n\t\tnf_log_buf_add(m, \"FIN \");\n\t \n\tnf_log_buf_add(m, \"URGP=%u \", ntohs(th->urg_ptr));\n\n\tif ((logflags & NF_LOG_TCPOPT) && th->doff * 4 > sizeof(struct tcphdr)) {\n\t\tunsigned int optsize = th->doff * 4 - sizeof(struct tcphdr);\n\t\tu8 _opt[60 - sizeof(struct tcphdr)];\n\t\tunsigned int i;\n\t\tconst u8 *op;\n\n\t\top = skb_header_pointer(skb, offset + sizeof(struct tcphdr),\n\t\t\t\t\toptsize, _opt);\n\t\tif (!op) {\n\t\t\tnf_log_buf_add(m, \"OPT (TRUNCATED)\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tnf_log_buf_add(m, \"OPT (\");\n\t\tfor (i = 0; i < optsize; i++)\n\t\t\tnf_log_buf_add(m, \"%02X\", op[i]);\n\n\t\tnf_log_buf_add(m, \") \");\n\t}\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int\nnf_log_dump_udp_header(struct nf_log_buf *m,\n\t\t       const struct sk_buff *skb,\n\t\t       u8 proto, int fragment,\n\t\t       unsigned int offset)\n{\n\tstruct udphdr _udph;\n\tconst struct udphdr *uh;\n\n\tif (proto == IPPROTO_UDP)\n\t\t \n\t\tnf_log_buf_add(m, \"PROTO=UDP \");\n\telse\t \n\t\tnf_log_buf_add(m, \"PROTO=UDPLITE \");\n\n\tif (fragment)\n\t\tgoto out;\n\n\t \n\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\tif (!uh) {\n\t\tnf_log_buf_add(m, \"INCOMPLETE [%u bytes] \", skb->len - offset);\n\n\t\treturn 1;\n\t}\n\n\t \n\tnf_log_buf_add(m, \"SPT=%u DPT=%u LEN=%u \",\n\t\t       ntohs(uh->source), ntohs(uh->dest), ntohs(uh->len));\n\nout:\n\treturn 0;\n}\n\n \nstatic noinline_for_stack void\ndump_ipv4_packet(struct net *net, struct nf_log_buf *m,\n\t\t const struct nf_loginfo *info,\n\t\t const struct sk_buff *skb, unsigned int iphoff)\n{\n\tconst struct iphdr *ih;\n\tunsigned int logflags;\n\tstruct iphdr _iph;\n\n\tif (info->type == NF_LOG_TYPE_LOG)\n\t\tlogflags = info->u.log.logflags;\n\telse\n\t\tlogflags = NF_LOG_DEFAULT_MASK;\n\n\tih = skb_header_pointer(skb, iphoff, sizeof(_iph), &_iph);\n\tif (!ih) {\n\t\tnf_log_buf_add(m, \"TRUNCATED\");\n\t\treturn;\n\t}\n\n\t \n\tnf_log_buf_add(m, \"SRC=%pI4 DST=%pI4 \", &ih->saddr, &ih->daddr);\n\n\t \n\tnf_log_buf_add(m, \"LEN=%u TOS=0x%02X PREC=0x%02X TTL=%u ID=%u \",\n\t\t       iph_totlen(skb, ih), ih->tos & IPTOS_TOS_MASK,\n\t\t       ih->tos & IPTOS_PREC_MASK, ih->ttl, ntohs(ih->id));\n\n\t \n\tif (ntohs(ih->frag_off) & IP_CE)\n\t\tnf_log_buf_add(m, \"CE \");\n\tif (ntohs(ih->frag_off) & IP_DF)\n\t\tnf_log_buf_add(m, \"DF \");\n\tif (ntohs(ih->frag_off) & IP_MF)\n\t\tnf_log_buf_add(m, \"MF \");\n\n\t \n\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\tnf_log_buf_add(m, \"FRAG:%u \", ntohs(ih->frag_off) & IP_OFFSET);\n\n\tif ((logflags & NF_LOG_IPOPT) &&\n\t    ih->ihl * 4 > sizeof(struct iphdr)) {\n\t\tunsigned char _opt[4 * 15 - sizeof(struct iphdr)];\n\t\tconst unsigned char *op;\n\t\tunsigned int i, optsize;\n\n\t\toptsize = ih->ihl * 4 - sizeof(struct iphdr);\n\t\top = skb_header_pointer(skb, iphoff + sizeof(_iph),\n\t\t\t\t\toptsize, _opt);\n\t\tif (!op) {\n\t\t\tnf_log_buf_add(m, \"TRUNCATED\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tnf_log_buf_add(m, \"OPT (\");\n\t\tfor (i = 0; i < optsize; i++)\n\t\t\tnf_log_buf_add(m, \"%02X\", op[i]);\n\t\tnf_log_buf_add(m, \") \");\n\t}\n\n\tswitch (ih->protocol) {\n\tcase IPPROTO_TCP:\n\t\tif (nf_log_dump_tcp_header(m, skb, ih->protocol,\n\t\t\t\t\t   ntohs(ih->frag_off) & IP_OFFSET,\n\t\t\t\t\t   iphoff + ih->ihl * 4, logflags))\n\t\t\treturn;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\t\tif (nf_log_dump_udp_header(m, skb, ih->protocol,\n\t\t\t\t\t   ntohs(ih->frag_off) & IP_OFFSET,\n\t\t\t\t\t   iphoff + ih->ihl * 4))\n\t\t\treturn;\n\t\tbreak;\n\tcase IPPROTO_ICMP: {\n\t\tstatic const size_t required_len[NR_ICMP_TYPES + 1] = {\n\t\t\t[ICMP_ECHOREPLY] = 4,\n\t\t\t[ICMP_DEST_UNREACH] = 8 + sizeof(struct iphdr),\n\t\t\t[ICMP_SOURCE_QUENCH] = 8 + sizeof(struct iphdr),\n\t\t\t[ICMP_REDIRECT] = 8 + sizeof(struct iphdr),\n\t\t\t[ICMP_ECHO] = 4,\n\t\t\t[ICMP_TIME_EXCEEDED] = 8 + sizeof(struct iphdr),\n\t\t\t[ICMP_PARAMETERPROB] = 8 + sizeof(struct iphdr),\n\t\t\t[ICMP_TIMESTAMP] = 20,\n\t\t\t[ICMP_TIMESTAMPREPLY] = 20,\n\t\t\t[ICMP_ADDRESS] = 12,\n\t\t\t[ICMP_ADDRESSREPLY] = 12 };\n\t\tconst struct icmphdr *ich;\n\t\tstruct icmphdr _icmph;\n\n\t\t \n\t\tnf_log_buf_add(m, \"PROTO=ICMP \");\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\t \n\t\tich = skb_header_pointer(skb, iphoff + ih->ihl * 4,\n\t\t\t\t\t sizeof(_icmph), &_icmph);\n\t\tif (!ich) {\n\t\t\tnf_log_buf_add(m, \"INCOMPLETE [%u bytes] \",\n\t\t\t\t       skb->len - iphoff - ih->ihl * 4);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tnf_log_buf_add(m, \"TYPE=%u CODE=%u \", ich->type, ich->code);\n\n\t\t \n\t\tif (ich->type <= NR_ICMP_TYPES &&\n\t\t    required_len[ich->type] &&\n\t\t    skb->len - iphoff - ih->ihl * 4 < required_len[ich->type]) {\n\t\t\tnf_log_buf_add(m, \"INCOMPLETE [%u bytes] \",\n\t\t\t\t       skb->len - iphoff - ih->ihl * 4);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ich->type) {\n\t\tcase ICMP_ECHOREPLY:\n\t\tcase ICMP_ECHO:\n\t\t\t \n\t\t\tnf_log_buf_add(m, \"ID=%u SEQ=%u \",\n\t\t\t\t       ntohs(ich->un.echo.id),\n\t\t\t\t       ntohs(ich->un.echo.sequence));\n\t\t\tbreak;\n\n\t\tcase ICMP_PARAMETERPROB:\n\t\t\t \n\t\t\tnf_log_buf_add(m, \"PARAMETER=%u \",\n\t\t\t\t       ntohl(ich->un.gateway) >> 24);\n\t\t\tbreak;\n\t\tcase ICMP_REDIRECT:\n\t\t\t \n\t\t\tnf_log_buf_add(m, \"GATEWAY=%pI4 \", &ich->un.gateway);\n\t\t\tfallthrough;\n\t\tcase ICMP_DEST_UNREACH:\n\t\tcase ICMP_SOURCE_QUENCH:\n\t\tcase ICMP_TIME_EXCEEDED:\n\t\t\t \n\t\t\tif (!iphoff) {  \n\t\t\t\tnf_log_buf_add(m, \"[\");\n\t\t\t\tdump_ipv4_packet(net, m, info, skb,\n\t\t\t\t\t\t iphoff + ih->ihl * 4 + sizeof(_icmph));\n\t\t\t\tnf_log_buf_add(m, \"] \");\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ich->type == ICMP_DEST_UNREACH &&\n\t\t\t    ich->code == ICMP_FRAG_NEEDED) {\n\t\t\t\tnf_log_buf_add(m, \"MTU=%u \",\n\t\t\t\t\t       ntohs(ich->un.frag.mtu));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t \n\tcase IPPROTO_AH: {\n\t\tconst struct ip_auth_hdr *ah;\n\t\tstruct ip_auth_hdr _ahdr;\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\t \n\t\tnf_log_buf_add(m, \"PROTO=AH \");\n\n\t\t \n\t\tah = skb_header_pointer(skb, iphoff + ih->ihl * 4,\n\t\t\t\t\tsizeof(_ahdr), &_ahdr);\n\t\tif (!ah) {\n\t\t\tnf_log_buf_add(m, \"INCOMPLETE [%u bytes] \",\n\t\t\t\t       skb->len - iphoff - ih->ihl * 4);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tnf_log_buf_add(m, \"SPI=0x%x \", ntohl(ah->spi));\n\t\tbreak;\n\t}\n\tcase IPPROTO_ESP: {\n\t\tconst struct ip_esp_hdr *eh;\n\t\tstruct ip_esp_hdr _esph;\n\n\t\t \n\t\tnf_log_buf_add(m, \"PROTO=ESP \");\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\t \n\t\teh = skb_header_pointer(skb, iphoff + ih->ihl * 4,\n\t\t\t\t\tsizeof(_esph), &_esph);\n\t\tif (!eh) {\n\t\t\tnf_log_buf_add(m, \"INCOMPLETE [%u bytes] \",\n\t\t\t\t       skb->len - iphoff - ih->ihl * 4);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tnf_log_buf_add(m, \"SPI=0x%x \", ntohl(eh->spi));\n\t\tbreak;\n\t}\n\t \n\tdefault:\n\t\tnf_log_buf_add(m, \"PROTO=%u \", ih->protocol);\n\t}\n\n\t \n\tif ((logflags & NF_LOG_UID) && !iphoff)\n\t\tnf_log_dump_sk_uid_gid(net, m, skb->sk);\n\n\t \n\tif (!iphoff && skb->mark)\n\t\tnf_log_buf_add(m, \"MARK=0x%x \", skb->mark);\n\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\n\t \n\t \n\t \n}\n\nstatic noinline_for_stack void\ndump_ipv6_packet(struct net *net, struct nf_log_buf *m,\n\t\t const struct nf_loginfo *info,\n\t\t const struct sk_buff *skb, unsigned int ip6hoff,\n\t\t int recurse)\n{\n\tconst struct ipv6hdr *ih;\n\tunsigned int hdrlen = 0;\n\tunsigned int logflags;\n\tstruct ipv6hdr _ip6h;\n\tunsigned int ptr;\n\tu8 currenthdr;\n\tint fragment;\n\n\tif (info->type == NF_LOG_TYPE_LOG)\n\t\tlogflags = info->u.log.logflags;\n\telse\n\t\tlogflags = NF_LOG_DEFAULT_MASK;\n\n\tih = skb_header_pointer(skb, ip6hoff, sizeof(_ip6h), &_ip6h);\n\tif (!ih) {\n\t\tnf_log_buf_add(m, \"TRUNCATED\");\n\t\treturn;\n\t}\n\n\t \n\tnf_log_buf_add(m, \"SRC=%pI6 DST=%pI6 \", &ih->saddr, &ih->daddr);\n\n\t \n\tnf_log_buf_add(m, \"LEN=%zu TC=%u HOPLIMIT=%u FLOWLBL=%u \",\n\t\t       ntohs(ih->payload_len) + sizeof(struct ipv6hdr),\n\t\t       (ntohl(*(__be32 *)ih) & 0x0ff00000) >> 20,\n\t\t       ih->hop_limit,\n\t\t       (ntohl(*(__be32 *)ih) & 0x000fffff));\n\n\tfragment = 0;\n\tptr = ip6hoff + sizeof(struct ipv6hdr);\n\tcurrenthdr = ih->nexthdr;\n\twhile (currenthdr != NEXTHDR_NONE && nf_ip6_ext_hdr(currenthdr)) {\n\t\tstruct ipv6_opt_hdr _hdr;\n\t\tconst struct ipv6_opt_hdr *hp;\n\n\t\thp = skb_header_pointer(skb, ptr, sizeof(_hdr), &_hdr);\n\t\tif (!hp) {\n\t\t\tnf_log_buf_add(m, \"TRUNCATED\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (logflags & NF_LOG_IPOPT)\n\t\t\tnf_log_buf_add(m, \"OPT ( \");\n\n\t\tswitch (currenthdr) {\n\t\tcase IPPROTO_FRAGMENT: {\n\t\t\tstruct frag_hdr _fhdr;\n\t\t\tconst struct frag_hdr *fh;\n\n\t\t\tnf_log_buf_add(m, \"FRAG:\");\n\t\t\tfh = skb_header_pointer(skb, ptr, sizeof(_fhdr),\n\t\t\t\t\t\t&_fhdr);\n\t\t\tif (!fh) {\n\t\t\t\tnf_log_buf_add(m, \"TRUNCATED \");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tnf_log_buf_add(m, \"%u \", ntohs(fh->frag_off) & 0xFFF8);\n\n\t\t\t \n\t\t\tif (fh->frag_off & htons(0x0001))\n\t\t\t\tnf_log_buf_add(m, \"INCOMPLETE \");\n\n\t\t\tnf_log_buf_add(m, \"ID:%08x \",\n\t\t\t\t       ntohl(fh->identification));\n\n\t\t\tif (ntohs(fh->frag_off) & 0xFFF8)\n\t\t\t\tfragment = 1;\n\n\t\t\thdrlen = 8;\n\t\t\tbreak;\n\t\t}\n\t\tcase IPPROTO_DSTOPTS:\n\t\tcase IPPROTO_ROUTING:\n\t\tcase IPPROTO_HOPOPTS:\n\t\t\tif (fragment) {\n\t\t\t\tif (logflags & NF_LOG_IPOPT)\n\t\t\t\t\tnf_log_buf_add(m, \")\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\thdrlen = ipv6_optlen(hp);\n\t\t\tbreak;\n\t\t \n\t\tcase IPPROTO_AH:\n\t\t\tif (logflags & NF_LOG_IPOPT) {\n\t\t\t\tstruct ip_auth_hdr _ahdr;\n\t\t\t\tconst struct ip_auth_hdr *ah;\n\n\t\t\t\t \n\t\t\t\tnf_log_buf_add(m, \"AH \");\n\n\t\t\t\tif (fragment) {\n\t\t\t\t\tnf_log_buf_add(m, \")\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tah = skb_header_pointer(skb, ptr, sizeof(_ahdr),\n\t\t\t\t\t\t\t&_ahdr);\n\t\t\t\tif (!ah) {\n\t\t\t\t\t \n\t\t\t\t\tnf_log_buf_add(m, \"INCOMPLETE [%u bytes] )\",\n\t\t\t\t\t\t       skb->len - ptr);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tnf_log_buf_add(m, \"SPI=0x%x \", ntohl(ah->spi));\n\t\t\t}\n\n\t\t\thdrlen = ipv6_authlen(hp);\n\t\t\tbreak;\n\t\tcase IPPROTO_ESP:\n\t\t\tif (logflags & NF_LOG_IPOPT) {\n\t\t\t\tstruct ip_esp_hdr _esph;\n\t\t\t\tconst struct ip_esp_hdr *eh;\n\n\t\t\t\t \n\t\t\t\tnf_log_buf_add(m, \"ESP \");\n\n\t\t\t\tif (fragment) {\n\t\t\t\t\tnf_log_buf_add(m, \")\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\teh = skb_header_pointer(skb, ptr, sizeof(_esph),\n\t\t\t\t\t\t\t&_esph);\n\t\t\t\tif (!eh) {\n\t\t\t\t\tnf_log_buf_add(m, \"INCOMPLETE [%u bytes] )\",\n\t\t\t\t\t\t       skb->len - ptr);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tnf_log_buf_add(m, \"SPI=0x%x )\",\n\t\t\t\t\t       ntohl(eh->spi));\n\t\t\t}\n\t\t\treturn;\n\t\tdefault:\n\t\t\t \n\t\t\tnf_log_buf_add(m, \"Unknown Ext Hdr %u\", currenthdr);\n\t\t\treturn;\n\t\t}\n\t\tif (logflags & NF_LOG_IPOPT)\n\t\t\tnf_log_buf_add(m, \") \");\n\n\t\tcurrenthdr = hp->nexthdr;\n\t\tptr += hdrlen;\n\t}\n\n\tswitch (currenthdr) {\n\tcase IPPROTO_TCP:\n\t\tif (nf_log_dump_tcp_header(m, skb, currenthdr, fragment,\n\t\t\t\t\t   ptr, logflags))\n\t\t\treturn;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\t\tif (nf_log_dump_udp_header(m, skb, currenthdr, fragment, ptr))\n\t\t\treturn;\n\t\tbreak;\n\tcase IPPROTO_ICMPV6: {\n\t\tstruct icmp6hdr _icmp6h;\n\t\tconst struct icmp6hdr *ic;\n\n\t\t \n\t\tnf_log_buf_add(m, \"PROTO=ICMPv6 \");\n\n\t\tif (fragment)\n\t\t\tbreak;\n\n\t\t \n\t\tic = skb_header_pointer(skb, ptr, sizeof(_icmp6h), &_icmp6h);\n\t\tif (!ic) {\n\t\t\tnf_log_buf_add(m, \"INCOMPLETE [%u bytes] \",\n\t\t\t\t       skb->len - ptr);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tnf_log_buf_add(m, \"TYPE=%u CODE=%u \",\n\t\t\t       ic->icmp6_type, ic->icmp6_code);\n\n\t\tswitch (ic->icmp6_type) {\n\t\tcase ICMPV6_ECHO_REQUEST:\n\t\tcase ICMPV6_ECHO_REPLY:\n\t\t\t \n\t\t\tnf_log_buf_add(m, \"ID=%u SEQ=%u \",\n\t\t\t\t       ntohs(ic->icmp6_identifier),\n\t\t\t\t       ntohs(ic->icmp6_sequence));\n\t\t\tbreak;\n\t\tcase ICMPV6_MGM_QUERY:\n\t\tcase ICMPV6_MGM_REPORT:\n\t\tcase ICMPV6_MGM_REDUCTION:\n\t\t\tbreak;\n\n\t\tcase ICMPV6_PARAMPROB:\n\t\t\t \n\t\t\tnf_log_buf_add(m, \"POINTER=%08x \",\n\t\t\t\t       ntohl(ic->icmp6_pointer));\n\t\t\tfallthrough;\n\t\tcase ICMPV6_DEST_UNREACH:\n\t\tcase ICMPV6_PKT_TOOBIG:\n\t\tcase ICMPV6_TIME_EXCEED:\n\t\t\t \n\t\t\tif (recurse) {\n\t\t\t\tnf_log_buf_add(m, \"[\");\n\t\t\t\tdump_ipv6_packet(net, m, info, skb,\n\t\t\t\t\t\t ptr + sizeof(_icmp6h), 0);\n\t\t\t\tnf_log_buf_add(m, \"] \");\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ic->icmp6_type == ICMPV6_PKT_TOOBIG) {\n\t\t\t\tnf_log_buf_add(m, \"MTU=%u \",\n\t\t\t\t\t       ntohl(ic->icmp6_mtu));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t \n\tdefault:\n\t\tnf_log_buf_add(m, \"PROTO=%u \", currenthdr);\n\t}\n\n\t \n\tif ((logflags & NF_LOG_UID) && recurse)\n\t\tnf_log_dump_sk_uid_gid(net, m, skb->sk);\n\n\t \n\tif (recurse && skb->mark)\n\t\tnf_log_buf_add(m, \"MARK=0x%x \", skb->mark);\n}\n\nstatic void dump_mac_header(struct nf_log_buf *m,\n\t\t\t    const struct nf_loginfo *info,\n\t\t\t    const struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tunsigned int logflags = 0;\n\n\tif (info->type == NF_LOG_TYPE_LOG)\n\t\tlogflags = info->u.log.logflags;\n\n\tif (!(logflags & NF_LOG_MACDECODE))\n\t\tgoto fallback;\n\n\tswitch (dev->type) {\n\tcase ARPHRD_ETHER:\n\t\tnf_log_buf_add(m, \"MACSRC=%pM MACDST=%pM \",\n\t\t\t       eth_hdr(skb)->h_source, eth_hdr(skb)->h_dest);\n\t\tnf_log_dump_vlan(m, skb);\n\t\tnf_log_buf_add(m, \"MACPROTO=%04x \",\n\t\t\t       ntohs(eth_hdr(skb)->h_proto));\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\nfallback:\n\tnf_log_buf_add(m, \"MAC=\");\n\tif (dev->hard_header_len &&\n\t    skb->mac_header != skb->network_header) {\n\t\tconst unsigned char *p = skb_mac_header(skb);\n\t\tunsigned int i;\n\n\t\tif (dev->type == ARPHRD_SIT) {\n\t\t\tp -= ETH_HLEN;\n\n\t\t\tif (p < skb->head)\n\t\t\t\tp = NULL;\n\t\t}\n\n\t\tif (p) {\n\t\t\tnf_log_buf_add(m, \"%02x\", *p++);\n\t\t\tfor (i = 1; i < dev->hard_header_len; i++)\n\t\t\t\tnf_log_buf_add(m, \":%02x\", *p++);\n\t\t}\n\n\t\tif (dev->type == ARPHRD_SIT) {\n\t\t\tconst struct iphdr *iph =\n\t\t\t\t(struct iphdr *)skb_mac_header(skb);\n\n\t\t\tnf_log_buf_add(m, \" TUNNEL=%pI4->%pI4\", &iph->saddr,\n\t\t\t\t       &iph->daddr);\n\t\t}\n\t}\n\tnf_log_buf_add(m, \" \");\n}\n\nstatic void nf_log_ip_packet(struct net *net, u_int8_t pf,\n\t\t\t     unsigned int hooknum, const struct sk_buff *skb,\n\t\t\t     const struct net_device *in,\n\t\t\t     const struct net_device *out,\n\t\t\t     const struct nf_loginfo *loginfo,\n\t\t\t     const char *prefix)\n{\n\tstruct nf_log_buf *m;\n\n\tif (!nf_log_allowed(net))\n\t\treturn;\n\n\tm = nf_log_buf_open();\n\n\tif (!loginfo)\n\t\tloginfo = &default_loginfo;\n\n\tnf_log_dump_packet_common(m, pf, hooknum, skb, in,\n\t\t\t\t  out, loginfo, prefix, net);\n\n\tif (in)\n\t\tdump_mac_header(m, loginfo, skb);\n\n\tdump_ipv4_packet(net, m, loginfo, skb, skb_network_offset(skb));\n\n\tnf_log_buf_close(m);\n}\n\nstatic struct nf_logger nf_ip_logger __read_mostly = {\n\t.name\t\t= \"nf_log_ipv4\",\n\t.type\t\t= NF_LOG_TYPE_LOG,\n\t.logfn\t\t= nf_log_ip_packet,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic void nf_log_ip6_packet(struct net *net, u_int8_t pf,\n\t\t\t      unsigned int hooknum, const struct sk_buff *skb,\n\t\t\t      const struct net_device *in,\n\t\t\t      const struct net_device *out,\n\t\t\t      const struct nf_loginfo *loginfo,\n\t\t\t      const char *prefix)\n{\n\tstruct nf_log_buf *m;\n\n\tif (!nf_log_allowed(net))\n\t\treturn;\n\n\tm = nf_log_buf_open();\n\n\tif (!loginfo)\n\t\tloginfo = &default_loginfo;\n\n\tnf_log_dump_packet_common(m, pf, hooknum, skb, in, out,\n\t\t\t\t  loginfo, prefix, net);\n\n\tif (in)\n\t\tdump_mac_header(m, loginfo, skb);\n\n\tdump_ipv6_packet(net, m, loginfo, skb, skb_network_offset(skb), 1);\n\n\tnf_log_buf_close(m);\n}\n\nstatic struct nf_logger nf_ip6_logger __read_mostly = {\n\t.name\t\t= \"nf_log_ipv6\",\n\t.type\t\t= NF_LOG_TYPE_LOG,\n\t.logfn\t\t= nf_log_ip6_packet,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic void nf_log_unknown_packet(struct net *net, u_int8_t pf,\n\t\t\t\t  unsigned int hooknum,\n\t\t\t\t  const struct sk_buff *skb,\n\t\t\t\t  const struct net_device *in,\n\t\t\t\t  const struct net_device *out,\n\t\t\t\t  const struct nf_loginfo *loginfo,\n\t\t\t\t  const char *prefix)\n{\n\tstruct nf_log_buf *m;\n\n\tif (!nf_log_allowed(net))\n\t\treturn;\n\n\tm = nf_log_buf_open();\n\n\tif (!loginfo)\n\t\tloginfo = &default_loginfo;\n\n\tnf_log_dump_packet_common(m, pf, hooknum, skb, in, out, loginfo,\n\t\t\t\t  prefix, net);\n\n\tdump_mac_header(m, loginfo, skb);\n\n\tnf_log_buf_close(m);\n}\n\nstatic void nf_log_netdev_packet(struct net *net, u_int8_t pf,\n\t\t\t\t unsigned int hooknum,\n\t\t\t\t const struct sk_buff *skb,\n\t\t\t\t const struct net_device *in,\n\t\t\t\t const struct net_device *out,\n\t\t\t\t const struct nf_loginfo *loginfo,\n\t\t\t\t const char *prefix)\n{\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tnf_log_ip_packet(net, pf, hooknum, skb, in, out, loginfo, prefix);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tnf_log_ip6_packet(net, pf, hooknum, skb, in, out, loginfo, prefix);\n\t\tbreak;\n\tcase htons(ETH_P_ARP):\n\tcase htons(ETH_P_RARP):\n\t\tnf_log_arp_packet(net, pf, hooknum, skb, in, out, loginfo, prefix);\n\t\tbreak;\n\tdefault:\n\t\tnf_log_unknown_packet(net, pf, hooknum, skb,\n\t\t\t\t      in, out, loginfo, prefix);\n\t\tbreak;\n\t}\n}\n\nstatic struct nf_logger nf_netdev_logger __read_mostly = {\n\t.name\t\t= \"nf_log_netdev\",\n\t.type\t\t= NF_LOG_TYPE_LOG,\n\t.logfn\t\t= nf_log_netdev_packet,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic struct nf_logger nf_bridge_logger __read_mostly = {\n\t.name\t\t= \"nf_log_bridge\",\n\t.type\t\t= NF_LOG_TYPE_LOG,\n\t.logfn\t\t= nf_log_netdev_packet,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __net_init nf_log_syslog_net_init(struct net *net)\n{\n\tint ret = nf_log_set(net, NFPROTO_IPV4, &nf_ip_logger);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = nf_log_set(net, NFPROTO_ARP, &nf_arp_logger);\n\tif (ret)\n\t\tgoto err1;\n\n\tret = nf_log_set(net, NFPROTO_IPV6, &nf_ip6_logger);\n\tif (ret)\n\t\tgoto err2;\n\n\tret = nf_log_set(net, NFPROTO_NETDEV, &nf_netdev_logger);\n\tif (ret)\n\t\tgoto err3;\n\n\tret = nf_log_set(net, NFPROTO_BRIDGE, &nf_bridge_logger);\n\tif (ret)\n\t\tgoto err4;\n\treturn 0;\nerr4:\n\tnf_log_unset(net, &nf_netdev_logger);\nerr3:\n\tnf_log_unset(net, &nf_ip6_logger);\nerr2:\n\tnf_log_unset(net, &nf_arp_logger);\nerr1:\n\tnf_log_unset(net, &nf_ip_logger);\n\treturn ret;\n}\n\nstatic void __net_exit nf_log_syslog_net_exit(struct net *net)\n{\n\tnf_log_unset(net, &nf_ip_logger);\n\tnf_log_unset(net, &nf_arp_logger);\n\tnf_log_unset(net, &nf_ip6_logger);\n\tnf_log_unset(net, &nf_netdev_logger);\n\tnf_log_unset(net, &nf_bridge_logger);\n}\n\nstatic struct pernet_operations nf_log_syslog_net_ops = {\n\t.init = nf_log_syslog_net_init,\n\t.exit = nf_log_syslog_net_exit,\n};\n\nstatic int __init nf_log_syslog_init(void)\n{\n\tint ret;\n\n\tret = register_pernet_subsys(&nf_log_syslog_net_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nf_log_register(NFPROTO_IPV4, &nf_ip_logger);\n\tif (ret < 0)\n\t\tgoto err1;\n\n\tret = nf_log_register(NFPROTO_ARP, &nf_arp_logger);\n\tif (ret < 0)\n\t\tgoto err2;\n\n\tret = nf_log_register(NFPROTO_IPV6, &nf_ip6_logger);\n\tif (ret < 0)\n\t\tgoto err3;\n\n\tret = nf_log_register(NFPROTO_NETDEV, &nf_netdev_logger);\n\tif (ret < 0)\n\t\tgoto err4;\n\n\tret = nf_log_register(NFPROTO_BRIDGE, &nf_bridge_logger);\n\tif (ret < 0)\n\t\tgoto err5;\n\n\treturn 0;\nerr5:\n\tnf_log_unregister(&nf_netdev_logger);\nerr4:\n\tnf_log_unregister(&nf_ip6_logger);\nerr3:\n\tnf_log_unregister(&nf_arp_logger);\nerr2:\n\tnf_log_unregister(&nf_ip_logger);\nerr1:\n\tpr_err(\"failed to register logger\\n\");\n\tunregister_pernet_subsys(&nf_log_syslog_net_ops);\n\treturn ret;\n}\n\nstatic void __exit nf_log_syslog_exit(void)\n{\n\tunregister_pernet_subsys(&nf_log_syslog_net_ops);\n\tnf_log_unregister(&nf_ip_logger);\n\tnf_log_unregister(&nf_arp_logger);\n\tnf_log_unregister(&nf_ip6_logger);\n\tnf_log_unregister(&nf_netdev_logger);\n\tnf_log_unregister(&nf_bridge_logger);\n}\n\nmodule_init(nf_log_syslog_init);\nmodule_exit(nf_log_syslog_exit);\n\nMODULE_AUTHOR(\"Netfilter Core Team <coreteam@netfilter.org>\");\nMODULE_DESCRIPTION(\"Netfilter syslog packet logging\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"nf_log_arp\");\nMODULE_ALIAS(\"nf_log_bridge\");\nMODULE_ALIAS(\"nf_log_ipv4\");\nMODULE_ALIAS(\"nf_log_ipv6\");\nMODULE_ALIAS(\"nf_log_netdev\");\nMODULE_ALIAS_NF_LOGGER(AF_BRIDGE, 0);\nMODULE_ALIAS_NF_LOGGER(AF_INET, 0);\nMODULE_ALIAS_NF_LOGGER(3, 0);\nMODULE_ALIAS_NF_LOGGER(5, 0);  \nMODULE_ALIAS_NF_LOGGER(AF_INET6, 0);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}