{
  "module_name": "nf_bpf_link.c",
  "hash_id": "5f1e7511d3b926f06bc5fb53a7a864bd18fd45d495af058d30597e38c1e38ecd",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_bpf_link.c",
  "human_readable_source": "\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kmod.h>\n#include <linux/module.h>\n#include <linux/netfilter.h>\n\n#include <net/netfilter/nf_bpf_link.h>\n#include <uapi/linux/netfilter_ipv4.h>\n\nstatic unsigned int nf_hook_run_bpf(void *bpf_prog, struct sk_buff *skb,\n\t\t\t\t    const struct nf_hook_state *s)\n{\n\tconst struct bpf_prog *prog = bpf_prog;\n\tstruct bpf_nf_ctx ctx = {\n\t\t.state = s,\n\t\t.skb = skb,\n\t};\n\n\treturn bpf_prog_run(prog, &ctx);\n}\n\nstruct bpf_nf_link {\n\tstruct bpf_link link;\n\tstruct nf_hook_ops hook_ops;\n\tstruct net *net;\n\tu32 dead;\n\tconst struct nf_defrag_hook *defrag_hook;\n};\n\n#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4) || IS_ENABLED(CONFIG_NF_DEFRAG_IPV6)\nstatic const struct nf_defrag_hook *\nget_proto_defrag_hook(struct bpf_nf_link *link,\n\t\t      const struct nf_defrag_hook __rcu **ptr_global_hook,\n\t\t      const char *mod)\n{\n\tconst struct nf_defrag_hook *hook;\n\tint err;\n\n\t \n\trcu_read_lock();\n\thook = rcu_dereference(*ptr_global_hook);\n\tif (!hook) {\n\t\trcu_read_unlock();\n\t\terr = request_module(mod);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err < 0 ? err : -EINVAL);\n\n\t\trcu_read_lock();\n\t\thook = rcu_dereference(*ptr_global_hook);\n\t}\n\n\tif (hook && try_module_get(hook->owner)) {\n\t\t \n\t\thook = rcu_pointer_handoff(hook);\n\t} else {\n\t\tWARN_ONCE(!hook, \"%s has bad registration\", mod);\n\t\thook = ERR_PTR(-ENOENT);\n\t}\n\trcu_read_unlock();\n\n\tif (!IS_ERR(hook)) {\n\t\terr = hook->enable(link->net);\n\t\tif (err) {\n\t\t\tmodule_put(hook->owner);\n\t\t\thook = ERR_PTR(err);\n\t\t}\n\t}\n\n\treturn hook;\n}\n#endif\n\nstatic int bpf_nf_enable_defrag(struct bpf_nf_link *link)\n{\n\tconst struct nf_defrag_hook __maybe_unused *hook;\n\n\tswitch (link->hook_ops.pf) {\n#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)\n\tcase NFPROTO_IPV4:\n\t\thook = get_proto_defrag_hook(link, &nf_defrag_v4_hook, \"nf_defrag_ipv4\");\n\t\tif (IS_ERR(hook))\n\t\t\treturn PTR_ERR(hook);\n\n\t\tlink->defrag_hook = hook;\n\t\treturn 0;\n#endif\n#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV6)\n\tcase NFPROTO_IPV6:\n\t\thook = get_proto_defrag_hook(link, &nf_defrag_v6_hook, \"nf_defrag_ipv6\");\n\t\tif (IS_ERR(hook))\n\t\t\treturn PTR_ERR(hook);\n\n\t\tlink->defrag_hook = hook;\n\t\treturn 0;\n#endif\n\tdefault:\n\t\treturn -EAFNOSUPPORT;\n\t}\n}\n\nstatic void bpf_nf_disable_defrag(struct bpf_nf_link *link)\n{\n\tconst struct nf_defrag_hook *hook = link->defrag_hook;\n\n\tif (!hook)\n\t\treturn;\n\thook->disable(link->net);\n\tmodule_put(hook->owner);\n}\n\nstatic void bpf_nf_link_release(struct bpf_link *link)\n{\n\tstruct bpf_nf_link *nf_link = container_of(link, struct bpf_nf_link, link);\n\n\tif (nf_link->dead)\n\t\treturn;\n\n\t \n\tif (!cmpxchg(&nf_link->dead, 0, 1)) {\n\t\tnf_unregister_net_hook(nf_link->net, &nf_link->hook_ops);\n\t\tbpf_nf_disable_defrag(nf_link);\n\t}\n}\n\nstatic void bpf_nf_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_nf_link *nf_link = container_of(link, struct bpf_nf_link, link);\n\n\tkfree(nf_link);\n}\n\nstatic int bpf_nf_link_detach(struct bpf_link *link)\n{\n\tbpf_nf_link_release(link);\n\treturn 0;\n}\n\nstatic void bpf_nf_link_show_info(const struct bpf_link *link,\n\t\t\t\t  struct seq_file *seq)\n{\n\tstruct bpf_nf_link *nf_link = container_of(link, struct bpf_nf_link, link);\n\n\tseq_printf(seq, \"pf:\\t%u\\thooknum:\\t%u\\tprio:\\t%d\\n\",\n\t\t   nf_link->hook_ops.pf, nf_link->hook_ops.hooknum,\n\t\t   nf_link->hook_ops.priority);\n}\n\nstatic int bpf_nf_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t      struct bpf_link_info *info)\n{\n\tstruct bpf_nf_link *nf_link = container_of(link, struct bpf_nf_link, link);\n\n\tinfo->netfilter.pf = nf_link->hook_ops.pf;\n\tinfo->netfilter.hooknum = nf_link->hook_ops.hooknum;\n\tinfo->netfilter.priority = nf_link->hook_ops.priority;\n\tinfo->netfilter.flags = 0;\n\n\treturn 0;\n}\n\nstatic int bpf_nf_link_update(struct bpf_link *link, struct bpf_prog *new_prog,\n\t\t\t      struct bpf_prog *old_prog)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct bpf_link_ops bpf_nf_link_lops = {\n\t.release = bpf_nf_link_release,\n\t.dealloc = bpf_nf_link_dealloc,\n\t.detach = bpf_nf_link_detach,\n\t.show_fdinfo = bpf_nf_link_show_info,\n\t.fill_link_info = bpf_nf_link_fill_link_info,\n\t.update_prog = bpf_nf_link_update,\n};\n\nstatic int bpf_nf_check_pf_and_hooks(const union bpf_attr *attr)\n{\n\tint prio;\n\n\tswitch (attr->link_create.netfilter.pf) {\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\t\tif (attr->link_create.netfilter.hooknum >= NF_INET_NUMHOOKS)\n\t\t\treturn -EPROTO;\n\t\tbreak;\n\tdefault:\n\t\treturn -EAFNOSUPPORT;\n\t}\n\n\tif (attr->link_create.netfilter.flags & ~BPF_F_NETFILTER_IP_DEFRAG)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tprio = attr->link_create.netfilter.priority;\n\tif (prio == NF_IP_PRI_FIRST)\n\t\treturn -ERANGE;   \n\telse if (prio == NF_IP_PRI_LAST)\n\t\treturn -ERANGE;   \n\telse if ((attr->link_create.netfilter.flags & BPF_F_NETFILTER_IP_DEFRAG) &&\n\t\t prio <= NF_IP_PRI_CONNTRACK_DEFRAG)\n\t\treturn -ERANGE;   \n\n\treturn 0;\n}\n\nint bpf_nf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_nf_link *link;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\terr = bpf_nf_check_pf_and_hooks(attr);\n\tif (err)\n\t\treturn err;\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_NETFILTER, &bpf_nf_link_lops, prog);\n\n\tlink->hook_ops.hook = nf_hook_run_bpf;\n\tlink->hook_ops.hook_ops_type = NF_HOOK_OP_BPF;\n\tlink->hook_ops.priv = prog;\n\n\tlink->hook_ops.pf = attr->link_create.netfilter.pf;\n\tlink->hook_ops.priority = attr->link_create.netfilter.priority;\n\tlink->hook_ops.hooknum = attr->link_create.netfilter.hooknum;\n\n\tlink->net = net;\n\tlink->dead = false;\n\tlink->defrag_hook = NULL;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\treturn err;\n\t}\n\n\tif (attr->link_create.netfilter.flags & BPF_F_NETFILTER_IP_DEFRAG) {\n\t\terr = bpf_nf_enable_defrag(link);\n\t\tif (err) {\n\t\t\tbpf_link_cleanup(&link_primer);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = nf_register_net_hook(net, &link->hook_ops);\n\tif (err) {\n\t\tbpf_nf_disable_defrag(link);\n\t\tbpf_link_cleanup(&link_primer);\n\t\treturn err;\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n}\n\nconst struct bpf_prog_ops netfilter_prog_ops = {\n\t.test_run = bpf_prog_test_run_nf,\n};\n\nstatic bool nf_ptr_to_btf_id(struct bpf_insn_access_aux *info, const char *name)\n{\n\tstruct btf *btf;\n\ts32 type_id;\n\n\tbtf = bpf_get_btf_vmlinux();\n\tif (IS_ERR_OR_NULL(btf))\n\t\treturn false;\n\n\ttype_id = btf_find_by_name_kind(btf, name, BTF_KIND_STRUCT);\n\tif (WARN_ON_ONCE(type_id < 0))\n\t\treturn false;\n\n\tinfo->btf = btf;\n\tinfo->btf_id = type_id;\n\tinfo->reg_type = PTR_TO_BTF_ID | PTR_TRUSTED;\n\treturn true;\n}\n\nstatic bool nf_is_valid_access(int off, int size, enum bpf_access_type type,\n\t\t\t       const struct bpf_prog *prog,\n\t\t\t       struct bpf_insn_access_aux *info)\n{\n\tif (off < 0 || off >= sizeof(struct bpf_nf_ctx))\n\t\treturn false;\n\n\tif (type == BPF_WRITE)\n\t\treturn false;\n\n\tswitch (off) {\n\tcase bpf_ctx_range(struct bpf_nf_ctx, skb):\n\t\tif (size != sizeof_field(struct bpf_nf_ctx, skb))\n\t\t\treturn false;\n\n\t\treturn nf_ptr_to_btf_id(info, \"sk_buff\");\n\tcase bpf_ctx_range(struct bpf_nf_ctx, state):\n\t\tif (size != sizeof_field(struct bpf_nf_ctx, state))\n\t\t\treturn false;\n\n\t\treturn nf_ptr_to_btf_id(info, \"nf_hook_state\");\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic const struct bpf_func_proto *\nbpf_nf_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\treturn bpf_base_func_proto(func_id);\n}\n\nconst struct bpf_verifier_ops netfilter_verifier_ops = {\n\t.is_valid_access\t= nf_is_valid_access,\n\t.get_func_proto\t\t= bpf_nf_func_proto,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}