{
  "module_name": "nf_queue.c",
  "hash_id": "f5e06558487f2cf5e978afe83ed94f706558c15f991fd8854b4d2b2729d1eaa0",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_queue.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/seq_file.h>\n#include <linux/rcupdate.h>\n#include <net/protocol.h>\n#include <net/netfilter/nf_queue.h>\n#include <net/dst.h>\n\n#include \"nf_internals.h\"\n\nstatic const struct nf_queue_handler __rcu *nf_queue_handler;\n\n \n\nvoid nf_register_queue_handler(const struct nf_queue_handler *qh)\n{\n\t \n\tWARN_ON(rcu_access_pointer(nf_queue_handler));\n\trcu_assign_pointer(nf_queue_handler, qh);\n}\nEXPORT_SYMBOL(nf_register_queue_handler);\n\n \nvoid nf_unregister_queue_handler(void)\n{\n\tRCU_INIT_POINTER(nf_queue_handler, NULL);\n}\nEXPORT_SYMBOL(nf_unregister_queue_handler);\n\nstatic void nf_queue_sock_put(struct sock *sk)\n{\n#ifdef CONFIG_INET\n\tsock_gen_put(sk);\n#else\n\tsock_put(sk);\n#endif\n}\n\nstatic void nf_queue_entry_release_refs(struct nf_queue_entry *entry)\n{\n\tstruct nf_hook_state *state = &entry->state;\n\n\t \n\tdev_put(state->in);\n\tdev_put(state->out);\n\tif (state->sk)\n\t\tnf_queue_sock_put(state->sk);\n\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tdev_put(entry->physin);\n\tdev_put(entry->physout);\n#endif\n}\n\nvoid nf_queue_entry_free(struct nf_queue_entry *entry)\n{\n\tnf_queue_entry_release_refs(entry);\n\tkfree(entry);\n}\nEXPORT_SYMBOL_GPL(nf_queue_entry_free);\n\nstatic void __nf_queue_entry_init_physdevs(struct nf_queue_entry *entry)\n{\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tconst struct sk_buff *skb = entry->skb;\n\n\tif (nf_bridge_info_exists(skb)) {\n\t\tentry->physin = nf_bridge_get_physindev(skb, entry->state.net);\n\t\tentry->physout = nf_bridge_get_physoutdev(skb);\n\t} else {\n\t\tentry->physin = NULL;\n\t\tentry->physout = NULL;\n\t}\n#endif\n}\n\n \nbool nf_queue_entry_get_refs(struct nf_queue_entry *entry)\n{\n\tstruct nf_hook_state *state = &entry->state;\n\n\tif (state->sk && !refcount_inc_not_zero(&state->sk->sk_refcnt))\n\t\treturn false;\n\n\tdev_hold(state->in);\n\tdev_hold(state->out);\n\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tdev_hold(entry->physin);\n\tdev_hold(entry->physout);\n#endif\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(nf_queue_entry_get_refs);\n\nvoid nf_queue_nf_hook_drop(struct net *net)\n{\n\tconst struct nf_queue_handler *qh;\n\n\trcu_read_lock();\n\tqh = rcu_dereference(nf_queue_handler);\n\tif (qh)\n\t\tqh->nf_hook_drop(net);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(nf_queue_nf_hook_drop);\n\nstatic void nf_ip_saveroute(const struct sk_buff *skb,\n\t\t\t    struct nf_queue_entry *entry)\n{\n\tstruct ip_rt_info *rt_info = nf_queue_entry_reroute(entry);\n\n\tif (entry->state.hook == NF_INET_LOCAL_OUT) {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\n\t\trt_info->tos = iph->tos;\n\t\trt_info->daddr = iph->daddr;\n\t\trt_info->saddr = iph->saddr;\n\t\trt_info->mark = skb->mark;\n\t}\n}\n\nstatic void nf_ip6_saveroute(const struct sk_buff *skb,\n\t\t\t     struct nf_queue_entry *entry)\n{\n\tstruct ip6_rt_info *rt_info = nf_queue_entry_reroute(entry);\n\n\tif (entry->state.hook == NF_INET_LOCAL_OUT) {\n\t\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\n\t\trt_info->daddr = iph->daddr;\n\t\trt_info->saddr = iph->saddr;\n\t\trt_info->mark = skb->mark;\n\t}\n}\n\nstatic int __nf_queue(struct sk_buff *skb, const struct nf_hook_state *state,\n\t\t      unsigned int index, unsigned int queuenum)\n{\n\tstruct nf_queue_entry *entry = NULL;\n\tconst struct nf_queue_handler *qh;\n\tunsigned int route_key_size;\n\tint status;\n\n\t \n\tqh = rcu_dereference(nf_queue_handler);\n\tif (!qh)\n\t\treturn -ESRCH;\n\n\tswitch (state->pf) {\n\tcase AF_INET:\n\t\troute_key_size = sizeof(struct ip_rt_info);\n\t\tbreak;\n\tcase AF_INET6:\n\t\troute_key_size = sizeof(struct ip6_rt_info);\n\t\tbreak;\n\tdefault:\n\t\troute_key_size = 0;\n\t\tbreak;\n\t}\n\n\tif (skb_sk_is_prefetched(skb)) {\n\t\tstruct sock *sk = skb->sk;\n\n\t\tif (!sk_is_refcounted(sk)) {\n\t\t\tif (!refcount_inc_not_zero(&sk->sk_refcnt))\n\t\t\t\treturn -ENOTCONN;\n\n\t\t\t \n\t\t\tskb->destructor = sock_edemux;\n\t\t}\n\t}\n\n\tentry = kmalloc(sizeof(*entry) + route_key_size, GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tif (skb_dst(skb) && !skb_dst_force(skb)) {\n\t\tkfree(entry);\n\t\treturn -ENETDOWN;\n\t}\n\n\t*entry = (struct nf_queue_entry) {\n\t\t.skb\t= skb,\n\t\t.state\t= *state,\n\t\t.hook_index = index,\n\t\t.size\t= sizeof(*entry) + route_key_size,\n\t};\n\n\t__nf_queue_entry_init_physdevs(entry);\n\n\tif (!nf_queue_entry_get_refs(entry)) {\n\t\tkfree(entry);\n\t\treturn -ENOTCONN;\n\t}\n\n\tswitch (entry->state.pf) {\n\tcase AF_INET:\n\t\tnf_ip_saveroute(skb, entry);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tnf_ip6_saveroute(skb, entry);\n\t\tbreak;\n\t}\n\n\tstatus = qh->outfn(entry, queuenum);\n\tif (status < 0) {\n\t\tnf_queue_entry_free(entry);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nint nf_queue(struct sk_buff *skb, struct nf_hook_state *state,\n\t     unsigned int index, unsigned int verdict)\n{\n\tint ret;\n\n\tret = __nf_queue(skb, state, index, verdict >> NF_VERDICT_QBITS);\n\tif (ret < 0) {\n\t\tif (ret == -ESRCH &&\n\t\t    (verdict & NF_VERDICT_FLAG_QUEUE_BYPASS))\n\t\t\treturn 1;\n\t\tkfree_skb(skb);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_queue);\n\nstatic unsigned int nf_iterate(struct sk_buff *skb,\n\t\t\t       struct nf_hook_state *state,\n\t\t\t       const struct nf_hook_entries *hooks,\n\t\t\t       unsigned int *index)\n{\n\tconst struct nf_hook_entry *hook;\n\tunsigned int verdict, i = *index;\n\n\twhile (i < hooks->num_hook_entries) {\n\t\thook = &hooks->hooks[i];\nrepeat:\n\t\tverdict = nf_hook_entry_hookfn(hook, skb, state);\n\t\tif (verdict != NF_ACCEPT) {\n\t\t\t*index = i;\n\t\t\tif (verdict != NF_REPEAT)\n\t\t\t\treturn verdict;\n\t\t\tgoto repeat;\n\t\t}\n\t\ti++;\n\t}\n\n\t*index = i;\n\treturn NF_ACCEPT;\n}\n\nstatic struct nf_hook_entries *nf_hook_entries_head(const struct net *net, u8 pf, u8 hooknum)\n{\n\tswitch (pf) {\n#ifdef CONFIG_NETFILTER_FAMILY_BRIDGE\n\tcase NFPROTO_BRIDGE:\n\t\treturn rcu_dereference(net->nf.hooks_bridge[hooknum]);\n#endif\n\tcase NFPROTO_IPV4:\n\t\treturn rcu_dereference(net->nf.hooks_ipv4[hooknum]);\n\tcase NFPROTO_IPV6:\n\t\treturn rcu_dereference(net->nf.hooks_ipv6[hooknum]);\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn NULL;\n\t}\n\n\treturn NULL;\n}\n\n \nvoid nf_reinject(struct nf_queue_entry *entry, unsigned int verdict)\n{\n\tconst struct nf_hook_entry *hook_entry;\n\tconst struct nf_hook_entries *hooks;\n\tstruct sk_buff *skb = entry->skb;\n\tconst struct net *net;\n\tunsigned int i;\n\tint err;\n\tu8 pf;\n\n\tnet = entry->state.net;\n\tpf = entry->state.pf;\n\n\thooks = nf_hook_entries_head(net, pf, entry->state.hook);\n\n\ti = entry->hook_index;\n\tif (WARN_ON_ONCE(!hooks || i >= hooks->num_hook_entries)) {\n\t\tkfree_skb(skb);\n\t\tnf_queue_entry_free(entry);\n\t\treturn;\n\t}\n\n\thook_entry = &hooks->hooks[i];\n\n\t \n\tif (verdict == NF_REPEAT)\n\t\tverdict = nf_hook_entry_hookfn(hook_entry, skb, &entry->state);\n\n\tif (verdict == NF_ACCEPT) {\n\t\tif (nf_reroute(skb, entry) < 0)\n\t\t\tverdict = NF_DROP;\n\t}\n\n\tif (verdict == NF_ACCEPT) {\nnext_hook:\n\t\t++i;\n\t\tverdict = nf_iterate(skb, &entry->state, hooks, &i);\n\t}\n\n\tswitch (verdict & NF_VERDICT_MASK) {\n\tcase NF_ACCEPT:\n\tcase NF_STOP:\n\t\tlocal_bh_disable();\n\t\tentry->state.okfn(entry->state.net, entry->state.sk, skb);\n\t\tlocal_bh_enable();\n\t\tbreak;\n\tcase NF_QUEUE:\n\t\terr = nf_queue(skb, &entry->state, i, verdict);\n\t\tif (err == 1)\n\t\t\tgoto next_hook;\n\t\tbreak;\n\tcase NF_STOLEN:\n\t\tbreak;\n\tdefault:\n\t\tkfree_skb(skb);\n\t}\n\n\tnf_queue_entry_free(entry);\n}\nEXPORT_SYMBOL(nf_reinject);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}