{
  "module_name": "nf_tables_offload.c",
  "hash_id": "7a037de437b8239171cdb3d6209b88f976cc67f74b4d9c5458b85aa0dd8783b9",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_tables_offload.c",
  "human_readable_source": " \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netfilter.h>\n#include <net/flow_offload.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_offload.h>\n#include <net/pkt_cls.h>\n\nstatic struct nft_flow_rule *nft_flow_rule_alloc(int num_actions)\n{\n\tstruct nft_flow_rule *flow;\n\n\tflow = kzalloc(sizeof(struct nft_flow_rule), GFP_KERNEL);\n\tif (!flow)\n\t\treturn NULL;\n\n\tflow->rule = flow_rule_alloc(num_actions);\n\tif (!flow->rule) {\n\t\tkfree(flow);\n\t\treturn NULL;\n\t}\n\n\tflow->rule->match.dissector\t= &flow->match.dissector;\n\tflow->rule->match.mask\t\t= &flow->match.mask;\n\tflow->rule->match.key\t\t= &flow->match.key;\n\n\treturn flow;\n}\n\nvoid nft_flow_rule_set_addr_type(struct nft_flow_rule *flow,\n\t\t\t\t enum flow_dissector_key_id addr_type)\n{\n\tstruct nft_flow_match *match = &flow->match;\n\tstruct nft_flow_key *mask = &match->mask;\n\tstruct nft_flow_key *key = &match->key;\n\n\tif (match->dissector.used_keys & BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL))\n\t\treturn;\n\n\tkey->control.addr_type = addr_type;\n\tmask->control.addr_type = 0xffff;\n\tmatch->dissector.used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL);\n\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_CONTROL] =\n\t\toffsetof(struct nft_flow_key, control);\n}\n\nstruct nft_offload_ethertype {\n\t__be16 value;\n\t__be16 mask;\n};\n\nstatic void nft_flow_rule_transfer_vlan(struct nft_offload_ctx *ctx,\n\t\t\t\t\tstruct nft_flow_rule *flow)\n{\n\tstruct nft_flow_match *match = &flow->match;\n\tstruct nft_offload_ethertype ethertype = {\n\t\t.value\t= match->key.basic.n_proto,\n\t\t.mask\t= match->mask.basic.n_proto,\n\t};\n\n\tif (match->dissector.used_keys & BIT_ULL(FLOW_DISSECTOR_KEY_VLAN) &&\n\t    (match->key.vlan.vlan_tpid == htons(ETH_P_8021Q) ||\n\t     match->key.vlan.vlan_tpid == htons(ETH_P_8021AD))) {\n\t\tmatch->key.basic.n_proto = match->key.cvlan.vlan_tpid;\n\t\tmatch->mask.basic.n_proto = match->mask.cvlan.vlan_tpid;\n\t\tmatch->key.cvlan.vlan_tpid = match->key.vlan.vlan_tpid;\n\t\tmatch->mask.cvlan.vlan_tpid = match->mask.vlan.vlan_tpid;\n\t\tmatch->key.vlan.vlan_tpid = ethertype.value;\n\t\tmatch->mask.vlan.vlan_tpid = ethertype.mask;\n\t\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_CVLAN] =\n\t\t\toffsetof(struct nft_flow_key, cvlan);\n\t\tmatch->dissector.used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_CVLAN);\n\t} else if (match->dissector.used_keys &\n\t\t   BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) &&\n\t\t   (match->key.basic.n_proto == htons(ETH_P_8021Q) ||\n\t\t    match->key.basic.n_proto == htons(ETH_P_8021AD))) {\n\t\tmatch->key.basic.n_proto = match->key.vlan.vlan_tpid;\n\t\tmatch->mask.basic.n_proto = match->mask.vlan.vlan_tpid;\n\t\tmatch->key.vlan.vlan_tpid = ethertype.value;\n\t\tmatch->mask.vlan.vlan_tpid = ethertype.mask;\n\t\tmatch->dissector.offset[FLOW_DISSECTOR_KEY_VLAN] =\n\t\t\toffsetof(struct nft_flow_key, vlan);\n\t\tmatch->dissector.used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_VLAN);\n\t}\n}\n\nstruct nft_flow_rule *nft_flow_rule_create(struct net *net,\n\t\t\t\t\t   const struct nft_rule *rule)\n{\n\tstruct nft_offload_ctx *ctx;\n\tstruct nft_flow_rule *flow;\n\tint num_actions = 0, err;\n\tstruct nft_expr *expr;\n\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->offload_action &&\n\t\t    expr->ops->offload_action(expr))\n\t\t\tnum_actions++;\n\n\t\texpr = nft_expr_next(expr);\n\t}\n\n\tif (num_actions == 0)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tflow = nft_flow_rule_alloc(num_actions);\n\tif (!flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\texpr = nft_expr_first(rule);\n\n\tctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tctx->net = net;\n\tctx->dep.type = NFT_OFFLOAD_DEP_UNSPEC;\n\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (!expr->ops->offload) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = expr->ops->offload(ctx, flow, expr);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\n\t\texpr = nft_expr_next(expr);\n\t}\n\tnft_flow_rule_transfer_vlan(ctx, flow);\n\n\tflow->proto = ctx->dep.l3num;\n\tkfree(ctx);\n\n\treturn flow;\nerr_out:\n\tkfree(ctx);\n\tnft_flow_rule_destroy(flow);\n\n\treturn ERR_PTR(err);\n}\n\nvoid nft_flow_rule_destroy(struct nft_flow_rule *flow)\n{\n\tstruct flow_action_entry *entry;\n\tint i;\n\n\tflow_action_for_each(i, entry, &flow->rule->action) {\n\t\tswitch (entry->id) {\n\t\tcase FLOW_ACTION_REDIRECT:\n\t\tcase FLOW_ACTION_MIRRED:\n\t\t\tdev_put(entry->dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(flow->rule);\n\tkfree(flow);\n}\n\nvoid nft_offload_set_dependency(struct nft_offload_ctx *ctx,\n\t\t\t\tenum nft_offload_dep_type type)\n{\n\tctx->dep.type = type;\n}\n\nvoid nft_offload_update_dependency(struct nft_offload_ctx *ctx,\n\t\t\t\t   const void *data, u32 len)\n{\n\tswitch (ctx->dep.type) {\n\tcase NFT_OFFLOAD_DEP_NETWORK:\n\t\tWARN_ON(len != sizeof(__u16));\n\t\tmemcpy(&ctx->dep.l3num, data, sizeof(__u16));\n\t\tbreak;\n\tcase NFT_OFFLOAD_DEP_TRANSPORT:\n\t\tWARN_ON(len != sizeof(__u8));\n\t\tmemcpy(&ctx->dep.protonum, data, sizeof(__u8));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tctx->dep.type = NFT_OFFLOAD_DEP_UNSPEC;\n}\n\nstatic void nft_flow_offload_common_init(struct flow_cls_common_offload *common,\n\t\t\t\t\t __be16 proto, int priority,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tcommon->protocol = proto;\n\tcommon->prio = priority;\n\tcommon->extack = extack;\n}\n\nstatic int nft_setup_cb_call(enum tc_setup_type type, void *type_data,\n\t\t\t     struct list_head *cb_list)\n{\n\tstruct flow_block_cb *block_cb;\n\tint err;\n\n\tlist_for_each_entry(block_cb, cb_list, list) {\n\t\terr = block_cb->cb(type, type_data, block_cb->cb_priv);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int nft_chain_offload_priority(const struct nft_base_chain *basechain)\n{\n\tif (basechain->ops.priority <= 0 ||\n\t    basechain->ops.priority > USHRT_MAX)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nbool nft_chain_offload_support(const struct nft_base_chain *basechain)\n{\n\tstruct net_device *dev;\n\tstruct nft_hook *hook;\n\n\tif (nft_chain_offload_priority(basechain) < 0)\n\t\treturn false;\n\n\tlist_for_each_entry(hook, &basechain->hook_list, list) {\n\t\tif (hook->ops.pf != NFPROTO_NETDEV ||\n\t\t    hook->ops.hooknum != NF_NETDEV_INGRESS)\n\t\t\treturn false;\n\n\t\tdev = hook->ops.dev;\n\t\tif (!dev->netdev_ops->ndo_setup_tc && !flow_indr_dev_exists())\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void nft_flow_cls_offload_setup(struct flow_cls_offload *cls_flow,\n\t\t\t\t       const struct nft_base_chain *basechain,\n\t\t\t\t       const struct nft_rule *rule,\n\t\t\t\t       const struct nft_flow_rule *flow,\n\t\t\t\t       struct netlink_ext_ack *extack,\n\t\t\t\t       enum flow_cls_command command)\n{\n\t__be16 proto = ETH_P_ALL;\n\n\tmemset(cls_flow, 0, sizeof(*cls_flow));\n\n\tif (flow)\n\t\tproto = flow->proto;\n\n\tnft_flow_offload_common_init(&cls_flow->common, proto,\n\t\t\t\t     basechain->ops.priority, extack);\n\tcls_flow->command = command;\n\tcls_flow->cookie = (unsigned long) rule;\n\tif (flow)\n\t\tcls_flow->rule = flow->rule;\n}\n\nstatic int nft_flow_offload_cmd(const struct nft_chain *chain,\n\t\t\t\tconst struct nft_rule *rule,\n\t\t\t\tstruct nft_flow_rule *flow,\n\t\t\t\tenum flow_cls_command command,\n\t\t\t\tstruct flow_cls_offload *cls_flow)\n{\n\tstruct netlink_ext_ack extack = {};\n\tstruct nft_base_chain *basechain;\n\n\tif (!nft_is_base_chain(chain))\n\t\treturn -EOPNOTSUPP;\n\n\tbasechain = nft_base_chain(chain);\n\tnft_flow_cls_offload_setup(cls_flow, basechain, rule, flow, &extack,\n\t\t\t\t   command);\n\n\treturn nft_setup_cb_call(TC_SETUP_CLSFLOWER, cls_flow,\n\t\t\t\t &basechain->flow_block.cb_list);\n}\n\nstatic int nft_flow_offload_rule(const struct nft_chain *chain,\n\t\t\t\t struct nft_rule *rule,\n\t\t\t\t struct nft_flow_rule *flow,\n\t\t\t\t enum flow_cls_command command)\n{\n\tstruct flow_cls_offload cls_flow;\n\n\treturn nft_flow_offload_cmd(chain, rule, flow, command, &cls_flow);\n}\n\nint nft_flow_rule_stats(const struct nft_chain *chain,\n\t\t\tconst struct nft_rule *rule)\n{\n\tstruct flow_cls_offload cls_flow = {};\n\tstruct nft_expr *expr, *next;\n\tint err;\n\n\terr = nft_flow_offload_cmd(chain, rule, NULL, FLOW_CLS_STATS,\n\t\t\t\t   &cls_flow);\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_rule_for_each_expr(expr, next, rule) {\n\t\tif (expr->ops->offload_stats)\n\t\t\texpr->ops->offload_stats(expr, &cls_flow.stats);\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_flow_offload_bind(struct flow_block_offload *bo,\n\t\t\t\t struct nft_base_chain *basechain)\n{\n\tlist_splice(&bo->cb_list, &basechain->flow_block.cb_list);\n\treturn 0;\n}\n\nstatic int nft_flow_offload_unbind(struct flow_block_offload *bo,\n\t\t\t\t   struct nft_base_chain *basechain)\n{\n\tstruct flow_block_cb *block_cb, *next;\n\tstruct flow_cls_offload cls_flow;\n\tstruct netlink_ext_ack extack;\n\tstruct nft_chain *chain;\n\tstruct nft_rule *rule;\n\n\tchain = &basechain->chain;\n\tlist_for_each_entry(rule, &chain->rules, list) {\n\t\tmemset(&extack, 0, sizeof(extack));\n\t\tnft_flow_cls_offload_setup(&cls_flow, basechain, rule, NULL,\n\t\t\t\t\t   &extack, FLOW_CLS_DESTROY);\n\t\tnft_setup_cb_call(TC_SETUP_CLSFLOWER, &cls_flow, &bo->cb_list);\n\t}\n\n\tlist_for_each_entry_safe(block_cb, next, &bo->cb_list, list) {\n\t\tlist_del(&block_cb->list);\n\t\tflow_block_cb_free(block_cb);\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_block_setup(struct nft_base_chain *basechain,\n\t\t\t   struct flow_block_offload *bo,\n\t\t\t   enum flow_block_command cmd)\n{\n\tint err;\n\n\tswitch (cmd) {\n\tcase FLOW_BLOCK_BIND:\n\t\terr = nft_flow_offload_bind(bo, basechain);\n\t\tbreak;\n\tcase FLOW_BLOCK_UNBIND:\n\t\terr = nft_flow_offload_unbind(bo, basechain);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic void nft_flow_block_offload_init(struct flow_block_offload *bo,\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tenum flow_block_command cmd,\n\t\t\t\t\tstruct nft_base_chain *basechain,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tmemset(bo, 0, sizeof(*bo));\n\tbo->net\t\t= net;\n\tbo->block\t= &basechain->flow_block;\n\tbo->command\t= cmd;\n\tbo->binder_type\t= FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS;\n\tbo->extack\t= extack;\n\tbo->cb_list_head = &basechain->flow_block.cb_list;\n\tINIT_LIST_HEAD(&bo->cb_list);\n}\n\nstatic int nft_block_offload_cmd(struct nft_base_chain *chain,\n\t\t\t\t struct net_device *dev,\n\t\t\t\t enum flow_block_command cmd)\n{\n\tstruct netlink_ext_ack extack = {};\n\tstruct flow_block_offload bo;\n\tint err;\n\n\tnft_flow_block_offload_init(&bo, dev_net(dev), cmd, chain, &extack);\n\n\terr = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_BLOCK, &bo);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn nft_block_setup(chain, &bo, cmd);\n}\n\nstatic void nft_indr_block_cleanup(struct flow_block_cb *block_cb)\n{\n\tstruct nft_base_chain *basechain = block_cb->indr.data;\n\tstruct net_device *dev = block_cb->indr.dev;\n\tstruct netlink_ext_ack extack = {};\n\tstruct nftables_pernet *nft_net;\n\tstruct net *net = dev_net(dev);\n\tstruct flow_block_offload bo;\n\n\tnft_flow_block_offload_init(&bo, dev_net(dev), FLOW_BLOCK_UNBIND,\n\t\t\t\t    basechain, &extack);\n\tnft_net = nft_pernet(net);\n\tmutex_lock(&nft_net->commit_mutex);\n\tlist_del(&block_cb->driver_list);\n\tlist_move(&block_cb->list, &bo.cb_list);\n\tnft_flow_offload_unbind(&bo, basechain);\n\tmutex_unlock(&nft_net->commit_mutex);\n}\n\nstatic int nft_indr_block_offload_cmd(struct nft_base_chain *basechain,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      enum flow_block_command cmd)\n{\n\tstruct netlink_ext_ack extack = {};\n\tstruct flow_block_offload bo;\n\tint err;\n\n\tnft_flow_block_offload_init(&bo, dev_net(dev), cmd, basechain, &extack);\n\n\terr = flow_indr_dev_setup_offload(dev, NULL, TC_SETUP_BLOCK, basechain, &bo,\n\t\t\t\t\t  nft_indr_block_cleanup);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (list_empty(&bo.cb_list))\n\t\treturn -EOPNOTSUPP;\n\n\treturn nft_block_setup(basechain, &bo, cmd);\n}\n\nstatic int nft_chain_offload_cmd(struct nft_base_chain *basechain,\n\t\t\t\t struct net_device *dev,\n\t\t\t\t enum flow_block_command cmd)\n{\n\tint err;\n\n\tif (dev->netdev_ops->ndo_setup_tc)\n\t\terr = nft_block_offload_cmd(basechain, dev, cmd);\n\telse\n\t\terr = nft_indr_block_offload_cmd(basechain, dev, cmd);\n\n\treturn err;\n}\n\nstatic int nft_flow_block_chain(struct nft_base_chain *basechain,\n\t\t\t\tconst struct net_device *this_dev,\n\t\t\t\tenum flow_block_command cmd)\n{\n\tstruct net_device *dev;\n\tstruct nft_hook *hook;\n\tint err, i = 0;\n\n\tlist_for_each_entry(hook, &basechain->hook_list, list) {\n\t\tdev = hook->ops.dev;\n\t\tif (this_dev && this_dev != dev)\n\t\t\tcontinue;\n\n\t\terr = nft_chain_offload_cmd(basechain, dev, cmd);\n\t\tif (err < 0 && cmd == FLOW_BLOCK_BIND) {\n\t\t\tif (!this_dev)\n\t\t\t\tgoto err_flow_block;\n\n\t\t\treturn err;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn 0;\n\nerr_flow_block:\n\tlist_for_each_entry(hook, &basechain->hook_list, list) {\n\t\tif (i-- <= 0)\n\t\t\tbreak;\n\n\t\tdev = hook->ops.dev;\n\t\tnft_chain_offload_cmd(basechain, dev, FLOW_BLOCK_UNBIND);\n\t}\n\treturn err;\n}\n\nstatic int nft_flow_offload_chain(struct nft_chain *chain, u8 *ppolicy,\n\t\t\t\t  enum flow_block_command cmd)\n{\n\tstruct nft_base_chain *basechain;\n\tu8 policy;\n\n\tif (!nft_is_base_chain(chain))\n\t\treturn -EOPNOTSUPP;\n\n\tbasechain = nft_base_chain(chain);\n\tpolicy = ppolicy ? *ppolicy : basechain->policy;\n\n\t \n\tif (cmd == FLOW_BLOCK_BIND && policy == NF_DROP)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nft_flow_block_chain(basechain, NULL, cmd);\n}\n\nstatic void nft_flow_rule_offload_abort(struct net *net,\n\t\t\t\t\tstruct nft_trans *trans)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tint err = 0;\n\n\tlist_for_each_entry_continue_reverse(trans, &nft_net->commit_list, list) {\n\t\tif (trans->ctx.family != NFPROTO_NETDEV)\n\t\t\tcontinue;\n\n\t\tswitch (trans->msg_type) {\n\t\tcase NFT_MSG_NEWCHAIN:\n\t\t\tif (!(trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD) ||\n\t\t\t    nft_trans_chain_update(trans))\n\t\t\t\tcontinue;\n\n\t\t\terr = nft_flow_offload_chain(trans->ctx.chain, NULL,\n\t\t\t\t\t\t     FLOW_BLOCK_UNBIND);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELCHAIN:\n\t\t\tif (!(trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD))\n\t\t\t\tcontinue;\n\n\t\t\terr = nft_flow_offload_chain(trans->ctx.chain, NULL,\n\t\t\t\t\t\t     FLOW_BLOCK_BIND);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWRULE:\n\t\t\tif (!(trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD))\n\t\t\t\tcontinue;\n\n\t\t\terr = nft_flow_offload_rule(trans->ctx.chain,\n\t\t\t\t\t\t    nft_trans_rule(trans),\n\t\t\t\t\t\t    NULL, FLOW_CLS_DESTROY);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELRULE:\n\t\t\tif (!(trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD))\n\t\t\t\tcontinue;\n\n\t\t\terr = nft_flow_offload_rule(trans->ctx.chain,\n\t\t\t\t\t\t    nft_trans_rule(trans),\n\t\t\t\t\t\t    nft_trans_flow_rule(trans),\n\t\t\t\t\t\t    FLOW_CLS_REPLACE);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (WARN_ON_ONCE(err))\n\t\t\tbreak;\n\t}\n}\n\nint nft_flow_rule_offload_commit(struct net *net)\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(net);\n\tstruct nft_trans *trans;\n\tint err = 0;\n\tu8 policy;\n\n\tlist_for_each_entry(trans, &nft_net->commit_list, list) {\n\t\tif (trans->ctx.family != NFPROTO_NETDEV)\n\t\t\tcontinue;\n\n\t\tswitch (trans->msg_type) {\n\t\tcase NFT_MSG_NEWCHAIN:\n\t\t\tif (!(trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD) ||\n\t\t\t    nft_trans_chain_update(trans))\n\t\t\t\tcontinue;\n\n\t\t\tpolicy = nft_trans_chain_policy(trans);\n\t\t\terr = nft_flow_offload_chain(trans->ctx.chain, &policy,\n\t\t\t\t\t\t     FLOW_BLOCK_BIND);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELCHAIN:\n\t\t\tif (!(trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD))\n\t\t\t\tcontinue;\n\n\t\t\tpolicy = nft_trans_chain_policy(trans);\n\t\t\terr = nft_flow_offload_chain(trans->ctx.chain, &policy,\n\t\t\t\t\t\t     FLOW_BLOCK_UNBIND);\n\t\t\tbreak;\n\t\tcase NFT_MSG_NEWRULE:\n\t\t\tif (!(trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD))\n\t\t\t\tcontinue;\n\n\t\t\tif (trans->ctx.flags & NLM_F_REPLACE ||\n\t\t\t    !(trans->ctx.flags & NLM_F_APPEND)) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = nft_flow_offload_rule(trans->ctx.chain,\n\t\t\t\t\t\t    nft_trans_rule(trans),\n\t\t\t\t\t\t    nft_trans_flow_rule(trans),\n\t\t\t\t\t\t    FLOW_CLS_REPLACE);\n\t\t\tbreak;\n\t\tcase NFT_MSG_DELRULE:\n\t\t\tif (!(trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD))\n\t\t\t\tcontinue;\n\n\t\t\terr = nft_flow_offload_rule(trans->ctx.chain,\n\t\t\t\t\t\t    nft_trans_rule(trans),\n\t\t\t\t\t\t    NULL, FLOW_CLS_DESTROY);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err) {\n\t\t\tnft_flow_rule_offload_abort(net, trans);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic struct nft_chain *__nft_offload_get_chain(const struct nftables_pernet *nft_net,\n\t\t\t\t\t\t struct net_device *dev)\n{\n\tstruct nft_base_chain *basechain;\n\tstruct nft_hook *hook, *found;\n\tconst struct nft_table *table;\n\tstruct nft_chain *chain;\n\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tif (table->family != NFPROTO_NETDEV)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(chain, &table->chains, list) {\n\t\t\tif (!nft_is_base_chain(chain) ||\n\t\t\t    !(chain->flags & NFT_CHAIN_HW_OFFLOAD))\n\t\t\t\tcontinue;\n\n\t\t\tfound = NULL;\n\t\t\tbasechain = nft_base_chain(chain);\n\t\t\tlist_for_each_entry(hook, &basechain->hook_list, list) {\n\t\t\t\tif (hook->ops.dev != dev)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfound = hook;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tcontinue;\n\n\t\t\treturn chain;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int nft_offload_netdev_event(struct notifier_block *this,\n\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct nftables_pernet *nft_net;\n\tstruct net *net = dev_net(dev);\n\tstruct nft_chain *chain;\n\n\tif (event != NETDEV_UNREGISTER)\n\t\treturn NOTIFY_DONE;\n\n\tnft_net = nft_pernet(net);\n\tmutex_lock(&nft_net->commit_mutex);\n\tchain = __nft_offload_get_chain(nft_net, dev);\n\tif (chain)\n\t\tnft_flow_block_chain(nft_base_chain(chain), dev,\n\t\t\t\t     FLOW_BLOCK_UNBIND);\n\n\tmutex_unlock(&nft_net->commit_mutex);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nft_offload_netdev_notifier = {\n\t.notifier_call\t= nft_offload_netdev_event,\n};\n\nint nft_offload_init(void)\n{\n\treturn register_netdevice_notifier(&nft_offload_netdev_notifier);\n}\n\nvoid nft_offload_exit(void)\n{\n\tunregister_netdevice_notifier(&nft_offload_netdev_notifier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}