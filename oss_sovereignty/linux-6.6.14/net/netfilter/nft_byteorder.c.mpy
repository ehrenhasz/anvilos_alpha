{
  "module_name": "nft_byteorder.c",
  "hash_id": "62c726b13ba0da9d8e42092f0587431a9014beaff42786e508ac54b4e482d34f",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_byteorder.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n\nstruct nft_byteorder {\n\tu8\t\t\tsreg;\n\tu8\t\t\tdreg;\n\tenum nft_byteorder_ops\top:8;\n\tu8\t\t\tlen;\n\tu8\t\t\tsize;\n};\n\nvoid nft_byteorder_eval(const struct nft_expr *expr,\n\t\t\tstruct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 *src = &regs->data[priv->sreg];\n\tu32 *dst = &regs->data[priv->dreg];\n\tu16 *s16, *d16;\n\tunsigned int i;\n\n\ts16 = (void *)src;\n\td16 = (void *)dst;\n\n\tswitch (priv->size) {\n\tcase 8: {\n\t\tu64 *dst64 = (void *)dst;\n\t\tu64 src64;\n\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = nft_reg_load64(&src[i]);\n\t\t\t\tnft_reg_store64(&dst64[i],\n\t\t\t\t\t\tbe64_to_cpu((__force __be64)src64));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = (__force __u64)\n\t\t\t\t\tcpu_to_be64(nft_reg_load64(&src[i]));\n\t\t\t\tnft_reg_store64(&dst64[i], src64);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = ntohl((__force __be32)src[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = (__force __u32)htonl(src[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = ntohs((__force __be16)s16[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = (__force __u16)htons(s16[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic const struct nla_policy nft_byteorder_policy[NFTA_BYTEORDER_MAX + 1] = {\n\t[NFTA_BYTEORDER_SREG]\t= { .type = NLA_U32 },\n\t[NFTA_BYTEORDER_DREG]\t= { .type = NLA_U32 },\n\t[NFTA_BYTEORDER_OP]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_BYTEORDER_LEN]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_BYTEORDER_SIZE]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n};\n\nstatic int nft_byteorder_init(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr,\n\t\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 size, len;\n\tint err;\n\n\tif (tb[NFTA_BYTEORDER_SREG] == NULL ||\n\t    tb[NFTA_BYTEORDER_DREG] == NULL ||\n\t    tb[NFTA_BYTEORDER_LEN] == NULL ||\n\t    tb[NFTA_BYTEORDER_SIZE] == NULL ||\n\t    tb[NFTA_BYTEORDER_OP] == NULL)\n\t\treturn -EINVAL;\n\n\tpriv->op = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_OP]));\n\tswitch (priv->op) {\n\tcase NFT_BYTEORDER_NTOH:\n\tcase NFT_BYTEORDER_HTON:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = nft_parse_u32_check(tb[NFTA_BYTEORDER_SIZE], U8_MAX, &size);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->size = size;\n\n\tswitch (priv->size) {\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = nft_parse_u32_check(tb[NFTA_BYTEORDER_LEN], U8_MAX, &len);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->len = len;\n\n\terr = nft_parse_register_load(tb[NFTA_BYTEORDER_SREG], &priv->sreg,\n\t\t\t\t      priv->len);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_BYTEORDER_DREG],\n\t\t\t\t\t&priv->dreg, NULL, NFT_DATA_VALUE,\n\t\t\t\t\tpriv->len);\n}\n\nstatic int nft_byteorder_dump(struct sk_buff *skb,\n\t\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_BYTEORDER_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_BYTEORDER_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_BYTEORDER_OP, htonl(priv->op)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_BYTEORDER_LEN, htonl(priv->len)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_BYTEORDER_SIZE, htonl(priv->size)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic bool nft_byteorder_reduce(struct nft_regs_track *track,\n\t\t\t\t const struct nft_expr *expr)\n{\n\tstruct nft_byteorder *priv = nft_expr_priv(expr);\n\n\tnft_reg_track_cancel(track, priv->dreg, priv->len);\n\n\treturn false;\n}\n\nstatic const struct nft_expr_ops nft_byteorder_ops = {\n\t.type\t\t= &nft_byteorder_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_byteorder)),\n\t.eval\t\t= nft_byteorder_eval,\n\t.init\t\t= nft_byteorder_init,\n\t.dump\t\t= nft_byteorder_dump,\n\t.reduce\t\t= nft_byteorder_reduce,\n};\n\nstruct nft_expr_type nft_byteorder_type __read_mostly = {\n\t.name\t\t= \"byteorder\",\n\t.ops\t\t= &nft_byteorder_ops,\n\t.policy\t\t= nft_byteorder_policy,\n\t.maxattr\t= NFTA_BYTEORDER_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}