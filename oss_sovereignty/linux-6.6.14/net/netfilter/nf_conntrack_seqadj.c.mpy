{
  "module_name": "nf_conntrack_seqadj.c",
  "hash_id": "c08445c88a8bb2ff08ffbe177826d0efc15cc4a2ed6c207652f3aa00f9526ff8",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_seqadj.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/netfilter.h>\n#include <net/tcp.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_extend.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n\nint nf_ct_seqadj_init(struct nf_conn *ct, enum ip_conntrack_info ctinfo,\n\t\t      s32 off)\n{\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct nf_conn_seqadj *seqadj;\n\tstruct nf_ct_seqadj *this_way;\n\n\tif (off == 0)\n\t\treturn 0;\n\n\tset_bit(IPS_SEQ_ADJUST_BIT, &ct->status);\n\n\tseqadj = nfct_seqadj(ct);\n\tthis_way = &seqadj->seq[dir];\n\tthis_way->offset_before\t = off;\n\tthis_way->offset_after\t = off;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_ct_seqadj_init);\n\nint nf_ct_seqadj_set(struct nf_conn *ct, enum ip_conntrack_info ctinfo,\n\t\t     __be32 seq, s32 off)\n{\n\tstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct nf_ct_seqadj *this_way;\n\n\tif (off == 0)\n\t\treturn 0;\n\n\tif (unlikely(!seqadj)) {\n\t\tWARN_ONCE(1, \"Missing nfct_seqadj_ext_add() setup call\\n\");\n\t\treturn 0;\n\t}\n\n\tset_bit(IPS_SEQ_ADJUST_BIT, &ct->status);\n\n\tspin_lock_bh(&ct->lock);\n\tthis_way = &seqadj->seq[dir];\n\tif (this_way->offset_before == this_way->offset_after ||\n\t    before(this_way->correction_pos, ntohl(seq))) {\n\t\tthis_way->correction_pos = ntohl(seq);\n\t\tthis_way->offset_before\t = this_way->offset_after;\n\t\tthis_way->offset_after\t+= off;\n\t}\n\tspin_unlock_bh(&ct->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_ct_seqadj_set);\n\nvoid nf_ct_tcp_seqadj_set(struct sk_buff *skb,\n\t\t\t  struct nf_conn *ct, enum ip_conntrack_info ctinfo,\n\t\t\t  s32 off)\n{\n\tconst struct tcphdr *th;\n\n\tif (nf_ct_protonum(ct) != IPPROTO_TCP)\n\t\treturn;\n\n\tth = (struct tcphdr *)(skb_network_header(skb) + ip_hdrlen(skb));\n\tnf_ct_seqadj_set(ct, ctinfo, th->seq, off);\n}\nEXPORT_SYMBOL_GPL(nf_ct_tcp_seqadj_set);\n\n \nstatic void nf_ct_sack_block_adjust(struct sk_buff *skb,\n\t\t\t\t    struct tcphdr *tcph,\n\t\t\t\t    unsigned int sackoff,\n\t\t\t\t    unsigned int sackend,\n\t\t\t\t    struct nf_ct_seqadj *seq)\n{\n\twhile (sackoff < sackend) {\n\t\tstruct tcp_sack_block_wire *sack;\n\t\t__be32 new_start_seq, new_end_seq;\n\n\t\tsack = (void *)skb->data + sackoff;\n\t\tif (after(ntohl(sack->start_seq) - seq->offset_before,\n\t\t\t  seq->correction_pos))\n\t\t\tnew_start_seq = htonl(ntohl(sack->start_seq) -\n\t\t\t\t\tseq->offset_after);\n\t\telse\n\t\t\tnew_start_seq = htonl(ntohl(sack->start_seq) -\n\t\t\t\t\tseq->offset_before);\n\n\t\tif (after(ntohl(sack->end_seq) - seq->offset_before,\n\t\t\t  seq->correction_pos))\n\t\t\tnew_end_seq = htonl(ntohl(sack->end_seq) -\n\t\t\t\t      seq->offset_after);\n\t\telse\n\t\t\tnew_end_seq = htonl(ntohl(sack->end_seq) -\n\t\t\t\t      seq->offset_before);\n\n\t\tpr_debug(\"sack_adjust: start_seq: %u->%u, end_seq: %u->%u\\n\",\n\t\t\t ntohl(sack->start_seq), ntohl(new_start_seq),\n\t\t\t ntohl(sack->end_seq), ntohl(new_end_seq));\n\n\t\tinet_proto_csum_replace4(&tcph->check, skb,\n\t\t\t\t\t sack->start_seq, new_start_seq, false);\n\t\tinet_proto_csum_replace4(&tcph->check, skb,\n\t\t\t\t\t sack->end_seq, new_end_seq, false);\n\t\tsack->start_seq = new_start_seq;\n\t\tsack->end_seq = new_end_seq;\n\t\tsackoff += sizeof(*sack);\n\t}\n}\n\n \nstatic unsigned int nf_ct_sack_adjust(struct sk_buff *skb,\n\t\t\t\t      unsigned int protoff,\n\t\t\t\t      struct nf_conn *ct,\n\t\t\t\t      enum ip_conntrack_info ctinfo)\n{\n\tstruct tcphdr *tcph = (void *)skb->data + protoff;\n\tstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\n\tunsigned int dir, optoff, optend;\n\n\toptoff = protoff + sizeof(struct tcphdr);\n\toptend = protoff + tcph->doff * 4;\n\n\tif (skb_ensure_writable(skb, optend))\n\t\treturn 0;\n\n\ttcph = (void *)skb->data + protoff;\n\tdir = CTINFO2DIR(ctinfo);\n\n\twhile (optoff < optend) {\n\t\t \n\t\tunsigned char *op = skb->data + optoff;\n\n\t\tswitch (op[0]) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn 1;\n\t\tcase TCPOPT_NOP:\n\t\t\toptoff++;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t \n\t\t\tif (optoff + 1 == optend ||\n\t\t\t    optoff + op[1] > optend ||\n\t\t\t    op[1] < 2)\n\t\t\t\treturn 0;\n\t\t\tif (op[0] == TCPOPT_SACK &&\n\t\t\t    op[1] >= 2+TCPOLEN_SACK_PERBLOCK &&\n\t\t\t    ((op[1] - 2) % TCPOLEN_SACK_PERBLOCK) == 0)\n\t\t\t\tnf_ct_sack_block_adjust(skb, tcph, optoff + 2,\n\t\t\t\t\t\t\toptoff+op[1],\n\t\t\t\t\t\t\t&seqadj->seq[!dir]);\n\t\t\toptoff += op[1];\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nint nf_ct_seq_adjust(struct sk_buff *skb,\n\t\t     struct nf_conn *ct, enum ip_conntrack_info ctinfo,\n\t\t     unsigned int protoff)\n{\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct tcphdr *tcph;\n\t__be32 newseq, newack;\n\ts32 seqoff, ackoff;\n\tstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\n\tstruct nf_ct_seqadj *this_way, *other_way;\n\tint res = 1;\n\n\tthis_way  = &seqadj->seq[dir];\n\tother_way = &seqadj->seq[!dir];\n\n\tif (skb_ensure_writable(skb, protoff + sizeof(*tcph)))\n\t\treturn 0;\n\n\ttcph = (void *)skb->data + protoff;\n\tspin_lock_bh(&ct->lock);\n\tif (after(ntohl(tcph->seq), this_way->correction_pos))\n\t\tseqoff = this_way->offset_after;\n\telse\n\t\tseqoff = this_way->offset_before;\n\n\tnewseq = htonl(ntohl(tcph->seq) + seqoff);\n\tinet_proto_csum_replace4(&tcph->check, skb, tcph->seq, newseq, false);\n\tpr_debug(\"Adjusting sequence number from %u->%u\\n\",\n\t\t ntohl(tcph->seq), ntohl(newseq));\n\ttcph->seq = newseq;\n\n\tif (!tcph->ack)\n\t\tgoto out;\n\n\tif (after(ntohl(tcph->ack_seq) - other_way->offset_before,\n\t\t  other_way->correction_pos))\n\t\tackoff = other_way->offset_after;\n\telse\n\t\tackoff = other_way->offset_before;\n\n\tnewack = htonl(ntohl(tcph->ack_seq) - ackoff);\n\tinet_proto_csum_replace4(&tcph->check, skb, tcph->ack_seq, newack,\n\t\t\t\t false);\n\tpr_debug(\"Adjusting ack number from %u->%u, ack from %u->%u\\n\",\n\t\t ntohl(tcph->seq), ntohl(newseq), ntohl(tcph->ack_seq),\n\t\t ntohl(newack));\n\ttcph->ack_seq = newack;\n\n\tres = nf_ct_sack_adjust(skb, protoff, ct, ctinfo);\nout:\n\tspin_unlock_bh(&ct->lock);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(nf_ct_seq_adjust);\n\ns32 nf_ct_seq_offset(const struct nf_conn *ct,\n\t\t     enum ip_conntrack_dir dir,\n\t\t     u32 seq)\n{\n\tstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\n\tstruct nf_ct_seqadj *this_way;\n\n\tif (!seqadj)\n\t\treturn 0;\n\n\tthis_way = &seqadj->seq[dir];\n\treturn after(seq, this_way->correction_pos) ?\n\t\t this_way->offset_after : this_way->offset_before;\n}\nEXPORT_SYMBOL_GPL(nf_ct_seq_offset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}