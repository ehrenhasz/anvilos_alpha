{
  "module_name": "nf_nat_proto.c",
  "hash_id": "e850058fd3a4bf5185a2e49ecd92b926874b61f3444b862d84f3ff1b520e980d",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_nat_proto.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n\n#include <linux/dccp.h>\n#include <linux/sctp.h>\n#include <net/sctp/checksum.h>\n\n#include <linux/netfilter.h>\n#include <net/netfilter/nf_nat.h>\n\n#include <linux/ipv6.h>\n#include <linux/netfilter_ipv6.h>\n#include <net/checksum.h>\n#include <net/ip6_checksum.h>\n#include <net/ip6_route.h>\n#include <net/xfrm.h>\n#include <net/ipv6.h>\n\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <linux/netfilter/nfnetlink_conntrack.h>\n\nstatic void nf_csum_update(struct sk_buff *skb,\n\t\t\t   unsigned int iphdroff, __sum16 *check,\n\t\t\t   const struct nf_conntrack_tuple *t,\n\t\t\t   enum nf_nat_manip_type maniptype);\n\nstatic void\n__udp_manip_pkt(struct sk_buff *skb,\n\t        unsigned int iphdroff, struct udphdr *hdr,\n\t        const struct nf_conntrack_tuple *tuple,\n\t        enum nf_nat_manip_type maniptype, bool do_csum)\n{\n\t__be16 *portptr, newport;\n\n\tif (maniptype == NF_NAT_MANIP_SRC) {\n\t\t \n\t\tnewport = tuple->src.u.udp.port;\n\t\tportptr = &hdr->source;\n\t} else {\n\t\t \n\t\tnewport = tuple->dst.u.udp.port;\n\t\tportptr = &hdr->dest;\n\t}\n\tif (do_csum) {\n\t\tnf_csum_update(skb, iphdroff, &hdr->check, tuple, maniptype);\n\t\tinet_proto_csum_replace2(&hdr->check, skb, *portptr, newport,\n\t\t\t\t\t false);\n\t\tif (!hdr->check)\n\t\t\thdr->check = CSUM_MANGLED_0;\n\t}\n\t*portptr = newport;\n}\n\nstatic bool udp_manip_pkt(struct sk_buff *skb,\n\t\t\t  unsigned int iphdroff, unsigned int hdroff,\n\t\t\t  const struct nf_conntrack_tuple *tuple,\n\t\t\t  enum nf_nat_manip_type maniptype)\n{\n\tstruct udphdr *hdr;\n\n\tif (skb_ensure_writable(skb, hdroff + sizeof(*hdr)))\n\t\treturn false;\n\n\thdr = (struct udphdr *)(skb->data + hdroff);\n\t__udp_manip_pkt(skb, iphdroff, hdr, tuple, maniptype, !!hdr->check);\n\n\treturn true;\n}\n\nstatic bool udplite_manip_pkt(struct sk_buff *skb,\n\t\t\t      unsigned int iphdroff, unsigned int hdroff,\n\t\t\t      const struct nf_conntrack_tuple *tuple,\n\t\t\t      enum nf_nat_manip_type maniptype)\n{\n#ifdef CONFIG_NF_CT_PROTO_UDPLITE\n\tstruct udphdr *hdr;\n\n\tif (skb_ensure_writable(skb, hdroff + sizeof(*hdr)))\n\t\treturn false;\n\n\thdr = (struct udphdr *)(skb->data + hdroff);\n\t__udp_manip_pkt(skb, iphdroff, hdr, tuple, maniptype, true);\n#endif\n\treturn true;\n}\n\nstatic bool\nsctp_manip_pkt(struct sk_buff *skb,\n\t       unsigned int iphdroff, unsigned int hdroff,\n\t       const struct nf_conntrack_tuple *tuple,\n\t       enum nf_nat_manip_type maniptype)\n{\n#ifdef CONFIG_NF_CT_PROTO_SCTP\n\tstruct sctphdr *hdr;\n\tint hdrsize = 8;\n\n\t \n\tif (skb->len >= hdroff + sizeof(*hdr))\n\t\thdrsize = sizeof(*hdr);\n\n\tif (skb_ensure_writable(skb, hdroff + hdrsize))\n\t\treturn false;\n\n\thdr = (struct sctphdr *)(skb->data + hdroff);\n\n\tif (maniptype == NF_NAT_MANIP_SRC) {\n\t\t \n\t\thdr->source = tuple->src.u.sctp.port;\n\t} else {\n\t\t \n\t\thdr->dest = tuple->dst.u.sctp.port;\n\t}\n\n\tif (hdrsize < sizeof(*hdr))\n\t\treturn true;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\thdr->checksum = sctp_compute_cksum(skb, hdroff);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t}\n\n#endif\n\treturn true;\n}\n\nstatic bool\ntcp_manip_pkt(struct sk_buff *skb,\n\t      unsigned int iphdroff, unsigned int hdroff,\n\t      const struct nf_conntrack_tuple *tuple,\n\t      enum nf_nat_manip_type maniptype)\n{\n\tstruct tcphdr *hdr;\n\t__be16 *portptr, newport, oldport;\n\tint hdrsize = 8;  \n\n\t \n\tif (skb->len >= hdroff + sizeof(struct tcphdr))\n\t\thdrsize = sizeof(struct tcphdr);\n\n\tif (skb_ensure_writable(skb, hdroff + hdrsize))\n\t\treturn false;\n\n\thdr = (struct tcphdr *)(skb->data + hdroff);\n\n\tif (maniptype == NF_NAT_MANIP_SRC) {\n\t\t \n\t\tnewport = tuple->src.u.tcp.port;\n\t\tportptr = &hdr->source;\n\t} else {\n\t\t \n\t\tnewport = tuple->dst.u.tcp.port;\n\t\tportptr = &hdr->dest;\n\t}\n\n\toldport = *portptr;\n\t*portptr = newport;\n\n\tif (hdrsize < sizeof(*hdr))\n\t\treturn true;\n\n\tnf_csum_update(skb, iphdroff, &hdr->check, tuple, maniptype);\n\tinet_proto_csum_replace2(&hdr->check, skb, oldport, newport, false);\n\treturn true;\n}\n\nstatic bool\ndccp_manip_pkt(struct sk_buff *skb,\n\t       unsigned int iphdroff, unsigned int hdroff,\n\t       const struct nf_conntrack_tuple *tuple,\n\t       enum nf_nat_manip_type maniptype)\n{\n#ifdef CONFIG_NF_CT_PROTO_DCCP\n\tstruct dccp_hdr *hdr;\n\t__be16 *portptr, oldport, newport;\n\tint hdrsize = 8;  \n\n\tif (skb->len >= hdroff + sizeof(struct dccp_hdr))\n\t\thdrsize = sizeof(struct dccp_hdr);\n\n\tif (skb_ensure_writable(skb, hdroff + hdrsize))\n\t\treturn false;\n\n\thdr = (struct dccp_hdr *)(skb->data + hdroff);\n\n\tif (maniptype == NF_NAT_MANIP_SRC) {\n\t\tnewport = tuple->src.u.dccp.port;\n\t\tportptr = &hdr->dccph_sport;\n\t} else {\n\t\tnewport = tuple->dst.u.dccp.port;\n\t\tportptr = &hdr->dccph_dport;\n\t}\n\n\toldport = *portptr;\n\t*portptr = newport;\n\n\tif (hdrsize < sizeof(*hdr))\n\t\treturn true;\n\n\tnf_csum_update(skb, iphdroff, &hdr->dccph_checksum, tuple, maniptype);\n\tinet_proto_csum_replace2(&hdr->dccph_checksum, skb, oldport, newport,\n\t\t\t\t false);\n#endif\n\treturn true;\n}\n\nstatic bool\nicmp_manip_pkt(struct sk_buff *skb,\n\t       unsigned int iphdroff, unsigned int hdroff,\n\t       const struct nf_conntrack_tuple *tuple,\n\t       enum nf_nat_manip_type maniptype)\n{\n\tstruct icmphdr *hdr;\n\n\tif (skb_ensure_writable(skb, hdroff + sizeof(*hdr)))\n\t\treturn false;\n\n\thdr = (struct icmphdr *)(skb->data + hdroff);\n\tswitch (hdr->type) {\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\tcase ICMP_TIMESTAMP:\n\tcase ICMP_TIMESTAMPREPLY:\n\tcase ICMP_INFO_REQUEST:\n\tcase ICMP_INFO_REPLY:\n\tcase ICMP_ADDRESS:\n\tcase ICMP_ADDRESSREPLY:\n\t\tbreak;\n\tdefault:\n\t\treturn true;\n\t}\n\tinet_proto_csum_replace2(&hdr->checksum, skb,\n\t\t\t\t hdr->un.echo.id, tuple->src.u.icmp.id, false);\n\thdr->un.echo.id = tuple->src.u.icmp.id;\n\treturn true;\n}\n\nstatic bool\nicmpv6_manip_pkt(struct sk_buff *skb,\n\t\t unsigned int iphdroff, unsigned int hdroff,\n\t\t const struct nf_conntrack_tuple *tuple,\n\t\t enum nf_nat_manip_type maniptype)\n{\n\tstruct icmp6hdr *hdr;\n\n\tif (skb_ensure_writable(skb, hdroff + sizeof(*hdr)))\n\t\treturn false;\n\n\thdr = (struct icmp6hdr *)(skb->data + hdroff);\n\tnf_csum_update(skb, iphdroff, &hdr->icmp6_cksum, tuple, maniptype);\n\tif (hdr->icmp6_type == ICMPV6_ECHO_REQUEST ||\n\t    hdr->icmp6_type == ICMPV6_ECHO_REPLY) {\n\t\tinet_proto_csum_replace2(&hdr->icmp6_cksum, skb,\n\t\t\t\t\t hdr->icmp6_identifier,\n\t\t\t\t\t tuple->src.u.icmp.id, false);\n\t\thdr->icmp6_identifier = tuple->src.u.icmp.id;\n\t}\n\treturn true;\n}\n\n \nstatic bool\ngre_manip_pkt(struct sk_buff *skb,\n\t      unsigned int iphdroff, unsigned int hdroff,\n\t      const struct nf_conntrack_tuple *tuple,\n\t      enum nf_nat_manip_type maniptype)\n{\n#if IS_ENABLED(CONFIG_NF_CT_PROTO_GRE)\n\tconst struct gre_base_hdr *greh;\n\tstruct pptp_gre_header *pgreh;\n\n\t \n\tif (skb_ensure_writable(skb, hdroff + sizeof(*pgreh) - 8))\n\t\treturn false;\n\n\tgreh = (void *)skb->data + hdroff;\n\tpgreh = (struct pptp_gre_header *)greh;\n\n\t \n\tif (maniptype != NF_NAT_MANIP_DST)\n\t\treturn true;\n\n\tswitch (greh->flags & GRE_VERSION) {\n\tcase GRE_VERSION_0:\n\t\t \n\t\tbreak;\n\tcase GRE_VERSION_1:\n\t\tpr_debug(\"call_id -> 0x%04x\\n\", ntohs(tuple->dst.u.gre.key));\n\t\tpgreh->call_id = tuple->dst.u.gre.key;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"can't nat unknown GRE version\\n\");\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\nstatic bool l4proto_manip_pkt(struct sk_buff *skb,\n\t\t\t      unsigned int iphdroff, unsigned int hdroff,\n\t\t\t      const struct nf_conntrack_tuple *tuple,\n\t\t\t      enum nf_nat_manip_type maniptype)\n{\n\tswitch (tuple->dst.protonum) {\n\tcase IPPROTO_TCP:\n\t\treturn tcp_manip_pkt(skb, iphdroff, hdroff,\n\t\t\t\t     tuple, maniptype);\n\tcase IPPROTO_UDP:\n\t\treturn udp_manip_pkt(skb, iphdroff, hdroff,\n\t\t\t\t     tuple, maniptype);\n\tcase IPPROTO_UDPLITE:\n\t\treturn udplite_manip_pkt(skb, iphdroff, hdroff,\n\t\t\t\t\t tuple, maniptype);\n\tcase IPPROTO_SCTP:\n\t\treturn sctp_manip_pkt(skb, iphdroff, hdroff,\n\t\t\t\t      tuple, maniptype);\n\tcase IPPROTO_ICMP:\n\t\treturn icmp_manip_pkt(skb, iphdroff, hdroff,\n\t\t\t\t      tuple, maniptype);\n\tcase IPPROTO_ICMPV6:\n\t\treturn icmpv6_manip_pkt(skb, iphdroff, hdroff,\n\t\t\t\t\ttuple, maniptype);\n\tcase IPPROTO_DCCP:\n\t\treturn dccp_manip_pkt(skb, iphdroff, hdroff,\n\t\t\t\t      tuple, maniptype);\n\tcase IPPROTO_GRE:\n\t\treturn gre_manip_pkt(skb, iphdroff, hdroff,\n\t\t\t\t     tuple, maniptype);\n\t}\n\n\t \n\treturn true;\n}\n\nstatic bool nf_nat_ipv4_manip_pkt(struct sk_buff *skb,\n\t\t\t\t  unsigned int iphdroff,\n\t\t\t\t  const struct nf_conntrack_tuple *target,\n\t\t\t\t  enum nf_nat_manip_type maniptype)\n{\n\tstruct iphdr *iph;\n\tunsigned int hdroff;\n\n\tif (skb_ensure_writable(skb, iphdroff + sizeof(*iph)))\n\t\treturn false;\n\n\tiph = (void *)skb->data + iphdroff;\n\thdroff = iphdroff + iph->ihl * 4;\n\n\tif (!l4proto_manip_pkt(skb, iphdroff, hdroff, target, maniptype))\n\t\treturn false;\n\tiph = (void *)skb->data + iphdroff;\n\n\tif (maniptype == NF_NAT_MANIP_SRC) {\n\t\tcsum_replace4(&iph->check, iph->saddr, target->src.u3.ip);\n\t\tiph->saddr = target->src.u3.ip;\n\t} else {\n\t\tcsum_replace4(&iph->check, iph->daddr, target->dst.u3.ip);\n\t\tiph->daddr = target->dst.u3.ip;\n\t}\n\treturn true;\n}\n\nstatic bool nf_nat_ipv6_manip_pkt(struct sk_buff *skb,\n\t\t\t\t  unsigned int iphdroff,\n\t\t\t\t  const struct nf_conntrack_tuple *target,\n\t\t\t\t  enum nf_nat_manip_type maniptype)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct ipv6hdr *ipv6h;\n\t__be16 frag_off;\n\tint hdroff;\n\tu8 nexthdr;\n\n\tif (skb_ensure_writable(skb, iphdroff + sizeof(*ipv6h)))\n\t\treturn false;\n\n\tipv6h = (void *)skb->data + iphdroff;\n\tnexthdr = ipv6h->nexthdr;\n\thdroff = ipv6_skip_exthdr(skb, iphdroff + sizeof(*ipv6h),\n\t\t\t\t  &nexthdr, &frag_off);\n\tif (hdroff < 0)\n\t\tgoto manip_addr;\n\n\tif ((frag_off & htons(~0x7)) == 0 &&\n\t    !l4proto_manip_pkt(skb, iphdroff, hdroff, target, maniptype))\n\t\treturn false;\n\n\t \n\tipv6h = (void *)skb->data + iphdroff;\n\nmanip_addr:\n\tif (maniptype == NF_NAT_MANIP_SRC)\n\t\tipv6h->saddr = target->src.u3.in6;\n\telse\n\t\tipv6h->daddr = target->dst.u3.in6;\n\n#endif\n\treturn true;\n}\n\nunsigned int nf_nat_manip_pkt(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t      enum nf_nat_manip_type mtype,\n\t\t\t      enum ip_conntrack_dir dir)\n{\n\tstruct nf_conntrack_tuple target;\n\n\t \n\tnf_ct_invert_tuple(&target, &ct->tuplehash[!dir].tuple);\n\n\tswitch (target.src.l3num) {\n\tcase NFPROTO_IPV6:\n\t\tif (nf_nat_ipv6_manip_pkt(skb, 0, &target, mtype))\n\t\t\treturn NF_ACCEPT;\n\t\tbreak;\n\tcase NFPROTO_IPV4:\n\t\tif (nf_nat_ipv4_manip_pkt(skb, 0, &target, mtype))\n\t\t\treturn NF_ACCEPT;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn NF_DROP;\n}\n\nstatic void nf_nat_ipv4_csum_update(struct sk_buff *skb,\n\t\t\t\t    unsigned int iphdroff, __sum16 *check,\n\t\t\t\t    const struct nf_conntrack_tuple *t,\n\t\t\t\t    enum nf_nat_manip_type maniptype)\n{\n\tstruct iphdr *iph = (struct iphdr *)(skb->data + iphdroff);\n\t__be32 oldip, newip;\n\n\tif (maniptype == NF_NAT_MANIP_SRC) {\n\t\toldip = iph->saddr;\n\t\tnewip = t->src.u3.ip;\n\t} else {\n\t\toldip = iph->daddr;\n\t\tnewip = t->dst.u3.ip;\n\t}\n\tinet_proto_csum_replace4(check, skb, oldip, newip, true);\n}\n\nstatic void nf_nat_ipv6_csum_update(struct sk_buff *skb,\n\t\t\t\t    unsigned int iphdroff, __sum16 *check,\n\t\t\t\t    const struct nf_conntrack_tuple *t,\n\t\t\t\t    enum nf_nat_manip_type maniptype)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tconst struct ipv6hdr *ipv6h = (struct ipv6hdr *)(skb->data + iphdroff);\n\tconst struct in6_addr *oldip, *newip;\n\n\tif (maniptype == NF_NAT_MANIP_SRC) {\n\t\toldip = &ipv6h->saddr;\n\t\tnewip = &t->src.u3.in6;\n\t} else {\n\t\toldip = &ipv6h->daddr;\n\t\tnewip = &t->dst.u3.in6;\n\t}\n\tinet_proto_csum_replace16(check, skb, oldip->s6_addr32,\n\t\t\t\t  newip->s6_addr32, true);\n#endif\n}\n\nstatic void nf_csum_update(struct sk_buff *skb,\n\t\t\t   unsigned int iphdroff, __sum16 *check,\n\t\t\t   const struct nf_conntrack_tuple *t,\n\t\t\t   enum nf_nat_manip_type maniptype)\n{\n\tswitch (t->src.l3num) {\n\tcase NFPROTO_IPV4:\n\t\tnf_nat_ipv4_csum_update(skb, iphdroff, check, t, maniptype);\n\t\treturn;\n\tcase NFPROTO_IPV6:\n\t\tnf_nat_ipv6_csum_update(skb, iphdroff, check, t, maniptype);\n\t\treturn;\n\t}\n}\n\nstatic void nf_nat_ipv4_csum_recalc(struct sk_buff *skb,\n\t\t\t\t    u8 proto, void *data, __sum16 *check,\n\t\t\t\t    int datalen, int oldlen)\n{\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum_start = skb_headroom(skb) + skb_network_offset(skb) +\n\t\t\tip_hdrlen(skb);\n\t\tskb->csum_offset = (void *)check - data;\n\t\t*check = ~csum_tcpudp_magic(iph->saddr, iph->daddr, datalen,\n\t\t\t\t\t    proto, 0);\n\t} else {\n\t\tinet_proto_csum_replace2(check, skb,\n\t\t\t\t\t htons(oldlen), htons(datalen), true);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void nf_nat_ipv6_csum_recalc(struct sk_buff *skb,\n\t\t\t\t    u8 proto, void *data, __sum16 *check,\n\t\t\t\t    int datalen, int oldlen)\n{\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\tconst struct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum_start = skb_headroom(skb) + skb_network_offset(skb) +\n\t\t\t(data - (void *)skb->data);\n\t\tskb->csum_offset = (void *)check - data;\n\t\t*check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,\n\t\t\t\t\t  datalen, proto, 0);\n\t} else {\n\t\tinet_proto_csum_replace2(check, skb,\n\t\t\t\t\t htons(oldlen), htons(datalen), true);\n\t}\n}\n#endif\n\nvoid nf_nat_csum_recalc(struct sk_buff *skb,\n\t\t\tu8 nfproto, u8 proto, void *data, __sum16 *check,\n\t\t\tint datalen, int oldlen)\n{\n\tswitch (nfproto) {\n\tcase NFPROTO_IPV4:\n\t\tnf_nat_ipv4_csum_recalc(skb, proto, data, check,\n\t\t\t\t\tdatalen, oldlen);\n\t\treturn;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase NFPROTO_IPV6:\n\t\tnf_nat_ipv6_csum_recalc(skb, proto, data, check,\n\t\t\t\t\tdatalen, oldlen);\n\t\treturn;\n#endif\n\t}\n\n\tWARN_ON_ONCE(1);\n}\n\nint nf_nat_icmp_reply_translation(struct sk_buff *skb,\n\t\t\t\t  struct nf_conn *ct,\n\t\t\t\t  enum ip_conntrack_info ctinfo,\n\t\t\t\t  unsigned int hooknum)\n{\n\tstruct {\n\t\tstruct icmphdr\ticmp;\n\t\tstruct iphdr\tip;\n\t} *inside;\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tenum nf_nat_manip_type manip = HOOK2MANIP(hooknum);\n\tunsigned int hdrlen = ip_hdrlen(skb);\n\tstruct nf_conntrack_tuple target;\n\tunsigned long statusbit;\n\n\tWARN_ON(ctinfo != IP_CT_RELATED && ctinfo != IP_CT_RELATED_REPLY);\n\n\tif (skb_ensure_writable(skb, hdrlen + sizeof(*inside)))\n\t\treturn 0;\n\tif (nf_ip_checksum(skb, hooknum, hdrlen, IPPROTO_ICMP))\n\t\treturn 0;\n\n\tinside = (void *)skb->data + hdrlen;\n\tif (inside->icmp.type == ICMP_REDIRECT) {\n\t\tif ((ct->status & IPS_NAT_DONE_MASK) != IPS_NAT_DONE_MASK)\n\t\t\treturn 0;\n\t\tif (ct->status & IPS_NAT_MASK)\n\t\t\treturn 0;\n\t}\n\n\tif (manip == NF_NAT_MANIP_SRC)\n\t\tstatusbit = IPS_SRC_NAT;\n\telse\n\t\tstatusbit = IPS_DST_NAT;\n\n\t \n\tif (dir == IP_CT_DIR_REPLY)\n\t\tstatusbit ^= IPS_NAT_MASK;\n\n\tif (!(ct->status & statusbit))\n\t\treturn 1;\n\n\tif (!nf_nat_ipv4_manip_pkt(skb, hdrlen + sizeof(inside->icmp),\n\t\t\t\t   &ct->tuplehash[!dir].tuple, !manip))\n\t\treturn 0;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\t \n\t\tinside = (void *)skb->data + hdrlen;\n\t\tinside->icmp.checksum = 0;\n\t\tinside->icmp.checksum =\n\t\t\tcsum_fold(skb_checksum(skb, hdrlen,\n\t\t\t\t\t       skb->len - hdrlen, 0));\n\t}\n\n\t \n\tnf_ct_invert_tuple(&target, &ct->tuplehash[!dir].tuple);\n\ttarget.dst.protonum = IPPROTO_ICMP;\n\tif (!nf_nat_ipv4_manip_pkt(skb, 0, &target, manip))\n\t\treturn 0;\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(nf_nat_icmp_reply_translation);\n\nstatic unsigned int\nnf_nat_ipv4_fn(void *priv, struct sk_buff *skb,\n\t       const struct nf_hook_state *state)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (!ct)\n\t\treturn NF_ACCEPT;\n\n\tif (ctinfo == IP_CT_RELATED || ctinfo == IP_CT_RELATED_REPLY) {\n\t\tif (ip_hdr(skb)->protocol == IPPROTO_ICMP) {\n\t\t\tif (!nf_nat_icmp_reply_translation(skb, ct, ctinfo,\n\t\t\t\t\t\t\t   state->hook))\n\t\t\t\treturn NF_DROP;\n\t\t\telse\n\t\t\t\treturn NF_ACCEPT;\n\t\t}\n\t}\n\n\treturn nf_nat_inet_fn(priv, skb, state);\n}\n\nstatic unsigned int\nnf_nat_ipv4_pre_routing(void *priv, struct sk_buff *skb,\n\t\t\tconst struct nf_hook_state *state)\n{\n\tunsigned int ret;\n\t__be32 daddr = ip_hdr(skb)->daddr;\n\n\tret = nf_nat_ipv4_fn(priv, skb, state);\n\tif (ret == NF_ACCEPT && daddr != ip_hdr(skb)->daddr)\n\t\tskb_dst_drop(skb);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_XFRM\nstatic int nf_xfrm_me_harder(struct net *net, struct sk_buff *skb, unsigned int family)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct dst_entry *dst;\n\tunsigned int hh_len;\n\tstruct flowi fl;\n\tint err;\n\n\terr = xfrm_decode_session(skb, &fl, family);\n\tif (err < 0)\n\t\treturn err;\n\n\tdst = skb_dst(skb);\n\tif (dst->xfrm)\n\t\tdst = ((struct xfrm_dst *)dst)->route;\n\tif (!dst_hold_safe(dst))\n\t\treturn -EHOSTUNREACH;\n\n\tif (sk && !net_eq(net, sock_net(sk)))\n\t\tsk = NULL;\n\n\tdst = xfrm_lookup(net, dst, &fl, sk, 0);\n\tif (IS_ERR(dst))\n\t\treturn PTR_ERR(dst);\n\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, dst);\n\n\t \n\thh_len = skb_dst(skb)->dev->hard_header_len;\n\tif (skb_headroom(skb) < hh_len &&\n\t    pskb_expand_head(skb, hh_len - skb_headroom(skb), 0, GFP_ATOMIC))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n#endif\n\nstatic unsigned int\nnf_nat_ipv4_local_in(void *priv, struct sk_buff *skb,\n\t\t     const struct nf_hook_state *state)\n{\n\t__be32 saddr = ip_hdr(skb)->saddr;\n\tstruct sock *sk = skb->sk;\n\tunsigned int ret;\n\n\tret = nf_nat_ipv4_fn(priv, skb, state);\n\n\tif (ret == NF_ACCEPT && sk && saddr != ip_hdr(skb)->saddr &&\n\t    !inet_sk_transparent(sk))\n\t\tskb_orphan(skb);  \n\n\treturn ret;\n}\n\nstatic unsigned int\nnf_nat_ipv4_out(void *priv, struct sk_buff *skb,\n\t\tconst struct nf_hook_state *state)\n{\n#ifdef CONFIG_XFRM\n\tconst struct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\tint err;\n#endif\n\tunsigned int ret;\n\n\tret = nf_nat_ipv4_fn(priv, skb, state);\n#ifdef CONFIG_XFRM\n\tif (ret != NF_ACCEPT)\n\t\treturn ret;\n\n\tif (IPCB(skb)->flags & IPSKB_XFRM_TRANSFORMED)\n\t\treturn ret;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct) {\n\t\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\n\t\tif (ct->tuplehash[dir].tuple.src.u3.ip !=\n\t\t     ct->tuplehash[!dir].tuple.dst.u3.ip ||\n\t\t    (ct->tuplehash[dir].tuple.dst.protonum != IPPROTO_ICMP &&\n\t\t     ct->tuplehash[dir].tuple.src.u.all !=\n\t\t     ct->tuplehash[!dir].tuple.dst.u.all)) {\n\t\t\terr = nf_xfrm_me_harder(state->net, skb, AF_INET);\n\t\t\tif (err < 0)\n\t\t\t\tret = NF_DROP_ERR(err);\n\t\t}\n\t}\n#endif\n\treturn ret;\n}\n\nstatic unsigned int\nnf_nat_ipv4_local_fn(void *priv, struct sk_buff *skb,\n\t\t     const struct nf_hook_state *state)\n{\n\tconst struct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\tunsigned int ret;\n\tint err;\n\n\tret = nf_nat_ipv4_fn(priv, skb, state);\n\tif (ret != NF_ACCEPT)\n\t\treturn ret;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct) {\n\t\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\n\t\tif (ct->tuplehash[dir].tuple.dst.u3.ip !=\n\t\t    ct->tuplehash[!dir].tuple.src.u3.ip) {\n\t\t\terr = ip_route_me_harder(state->net, state->sk, skb, RTN_UNSPEC);\n\t\t\tif (err < 0)\n\t\t\t\tret = NF_DROP_ERR(err);\n\t\t}\n#ifdef CONFIG_XFRM\n\t\telse if (!(IPCB(skb)->flags & IPSKB_XFRM_TRANSFORMED) &&\n\t\t\t ct->tuplehash[dir].tuple.dst.protonum != IPPROTO_ICMP &&\n\t\t\t ct->tuplehash[dir].tuple.dst.u.all !=\n\t\t\t ct->tuplehash[!dir].tuple.src.u.all) {\n\t\t\terr = nf_xfrm_me_harder(state->net, skb, AF_INET);\n\t\t\tif (err < 0)\n\t\t\t\tret = NF_DROP_ERR(err);\n\t\t}\n#endif\n\t}\n\treturn ret;\n}\n\nstatic const struct nf_hook_ops nf_nat_ipv4_ops[] = {\n\t \n\t{\n\t\t.hook\t\t= nf_nat_ipv4_pre_routing,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_PRE_ROUTING,\n\t\t.priority\t= NF_IP_PRI_NAT_DST,\n\t},\n\t \n\t{\n\t\t.hook\t\t= nf_nat_ipv4_out,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_POST_ROUTING,\n\t\t.priority\t= NF_IP_PRI_NAT_SRC,\n\t},\n\t \n\t{\n\t\t.hook\t\t= nf_nat_ipv4_local_fn,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_LOCAL_OUT,\n\t\t.priority\t= NF_IP_PRI_NAT_DST,\n\t},\n\t \n\t{\n\t\t.hook\t\t= nf_nat_ipv4_local_in,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_LOCAL_IN,\n\t\t.priority\t= NF_IP_PRI_NAT_SRC,\n\t},\n};\n\nint nf_nat_ipv4_register_fn(struct net *net, const struct nf_hook_ops *ops)\n{\n\treturn nf_nat_register_fn(net, ops->pf, ops, nf_nat_ipv4_ops,\n\t\t\t\t  ARRAY_SIZE(nf_nat_ipv4_ops));\n}\nEXPORT_SYMBOL_GPL(nf_nat_ipv4_register_fn);\n\nvoid nf_nat_ipv4_unregister_fn(struct net *net, const struct nf_hook_ops *ops)\n{\n\tnf_nat_unregister_fn(net, ops->pf, ops, ARRAY_SIZE(nf_nat_ipv4_ops));\n}\nEXPORT_SYMBOL_GPL(nf_nat_ipv4_unregister_fn);\n\n#if IS_ENABLED(CONFIG_IPV6)\nint nf_nat_icmpv6_reply_translation(struct sk_buff *skb,\n\t\t\t\t    struct nf_conn *ct,\n\t\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t\t    unsigned int hooknum,\n\t\t\t\t    unsigned int hdrlen)\n{\n\tstruct {\n\t\tstruct icmp6hdr\ticmp6;\n\t\tstruct ipv6hdr\tip6;\n\t} *inside;\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tenum nf_nat_manip_type manip = HOOK2MANIP(hooknum);\n\tstruct nf_conntrack_tuple target;\n\tunsigned long statusbit;\n\n\tWARN_ON(ctinfo != IP_CT_RELATED && ctinfo != IP_CT_RELATED_REPLY);\n\n\tif (skb_ensure_writable(skb, hdrlen + sizeof(*inside)))\n\t\treturn 0;\n\tif (nf_ip6_checksum(skb, hooknum, hdrlen, IPPROTO_ICMPV6))\n\t\treturn 0;\n\n\tinside = (void *)skb->data + hdrlen;\n\tif (inside->icmp6.icmp6_type == NDISC_REDIRECT) {\n\t\tif ((ct->status & IPS_NAT_DONE_MASK) != IPS_NAT_DONE_MASK)\n\t\t\treturn 0;\n\t\tif (ct->status & IPS_NAT_MASK)\n\t\t\treturn 0;\n\t}\n\n\tif (manip == NF_NAT_MANIP_SRC)\n\t\tstatusbit = IPS_SRC_NAT;\n\telse\n\t\tstatusbit = IPS_DST_NAT;\n\n\t \n\tif (dir == IP_CT_DIR_REPLY)\n\t\tstatusbit ^= IPS_NAT_MASK;\n\n\tif (!(ct->status & statusbit))\n\t\treturn 1;\n\n\tif (!nf_nat_ipv6_manip_pkt(skb, hdrlen + sizeof(inside->icmp6),\n\t\t\t\t   &ct->tuplehash[!dir].tuple, !manip))\n\t\treturn 0;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\n\t\tinside = (void *)skb->data + hdrlen;\n\t\tinside->icmp6.icmp6_cksum = 0;\n\t\tinside->icmp6.icmp6_cksum =\n\t\t\tcsum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,\n\t\t\t\t\tskb->len - hdrlen, IPPROTO_ICMPV6,\n\t\t\t\t\tskb_checksum(skb, hdrlen,\n\t\t\t\t\t\t     skb->len - hdrlen, 0));\n\t}\n\n\tnf_ct_invert_tuple(&target, &ct->tuplehash[!dir].tuple);\n\ttarget.dst.protonum = IPPROTO_ICMPV6;\n\tif (!nf_nat_ipv6_manip_pkt(skb, 0, &target, manip))\n\t\treturn 0;\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(nf_nat_icmpv6_reply_translation);\n\nstatic unsigned int\nnf_nat_ipv6_fn(void *priv, struct sk_buff *skb,\n\t       const struct nf_hook_state *state)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be16 frag_off;\n\tint hdrlen;\n\tu8 nexthdr;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\t \n\tif (!ct)\n\t\treturn NF_ACCEPT;\n\n\tif (ctinfo == IP_CT_RELATED || ctinfo == IP_CT_RELATED_REPLY) {\n\t\tnexthdr = ipv6_hdr(skb)->nexthdr;\n\t\thdrlen = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr),\n\t\t\t\t\t  &nexthdr, &frag_off);\n\n\t\tif (hdrlen >= 0 && nexthdr == IPPROTO_ICMPV6) {\n\t\t\tif (!nf_nat_icmpv6_reply_translation(skb, ct, ctinfo,\n\t\t\t\t\t\t\t     state->hook,\n\t\t\t\t\t\t\t     hdrlen))\n\t\t\t\treturn NF_DROP;\n\t\t\telse\n\t\t\t\treturn NF_ACCEPT;\n\t\t}\n\t}\n\n\treturn nf_nat_inet_fn(priv, skb, state);\n}\n\nstatic unsigned int\nnf_nat_ipv6_in(void *priv, struct sk_buff *skb,\n\t       const struct nf_hook_state *state)\n{\n\tunsigned int ret;\n\tstruct in6_addr daddr = ipv6_hdr(skb)->daddr;\n\n\tret = nf_nat_ipv6_fn(priv, skb, state);\n\tif (ret != NF_DROP && ret != NF_STOLEN &&\n\t    ipv6_addr_cmp(&daddr, &ipv6_hdr(skb)->daddr))\n\t\tskb_dst_drop(skb);\n\n\treturn ret;\n}\n\nstatic unsigned int\nnf_nat_ipv6_out(void *priv, struct sk_buff *skb,\n\t\tconst struct nf_hook_state *state)\n{\n#ifdef CONFIG_XFRM\n\tconst struct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\tint err;\n#endif\n\tunsigned int ret;\n\n\tret = nf_nat_ipv6_fn(priv, skb, state);\n#ifdef CONFIG_XFRM\n\tif (ret != NF_ACCEPT)\n\t\treturn ret;\n\n\tif (IP6CB(skb)->flags & IP6SKB_XFRM_TRANSFORMED)\n\t\treturn ret;\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct) {\n\t\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\n\t\tif (!nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.src.u3,\n\t\t\t\t      &ct->tuplehash[!dir].tuple.dst.u3) ||\n\t\t    (ct->tuplehash[dir].tuple.dst.protonum != IPPROTO_ICMPV6 &&\n\t\t     ct->tuplehash[dir].tuple.src.u.all !=\n\t\t     ct->tuplehash[!dir].tuple.dst.u.all)) {\n\t\t\terr = nf_xfrm_me_harder(state->net, skb, AF_INET6);\n\t\t\tif (err < 0)\n\t\t\t\tret = NF_DROP_ERR(err);\n\t\t}\n\t}\n#endif\n\n\treturn ret;\n}\n\nstatic unsigned int\nnf_nat_ipv6_local_fn(void *priv, struct sk_buff *skb,\n\t\t     const struct nf_hook_state *state)\n{\n\tconst struct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\tunsigned int ret;\n\tint err;\n\n\tret = nf_nat_ipv6_fn(priv, skb, state);\n\tif (ret != NF_ACCEPT)\n\t\treturn ret;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct) {\n\t\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\n\t\tif (!nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.dst.u3,\n\t\t\t\t      &ct->tuplehash[!dir].tuple.src.u3)) {\n\t\t\terr = nf_ip6_route_me_harder(state->net, state->sk, skb);\n\t\t\tif (err < 0)\n\t\t\t\tret = NF_DROP_ERR(err);\n\t\t}\n#ifdef CONFIG_XFRM\n\t\telse if (!(IP6CB(skb)->flags & IP6SKB_XFRM_TRANSFORMED) &&\n\t\t\t ct->tuplehash[dir].tuple.dst.protonum != IPPROTO_ICMPV6 &&\n\t\t\t ct->tuplehash[dir].tuple.dst.u.all !=\n\t\t\t ct->tuplehash[!dir].tuple.src.u.all) {\n\t\t\terr = nf_xfrm_me_harder(state->net, skb, AF_INET6);\n\t\t\tif (err < 0)\n\t\t\t\tret = NF_DROP_ERR(err);\n\t\t}\n#endif\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nf_hook_ops nf_nat_ipv6_ops[] = {\n\t \n\t{\n\t\t.hook\t\t= nf_nat_ipv6_in,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_PRE_ROUTING,\n\t\t.priority\t= NF_IP6_PRI_NAT_DST,\n\t},\n\t \n\t{\n\t\t.hook\t\t= nf_nat_ipv6_out,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_POST_ROUTING,\n\t\t.priority\t= NF_IP6_PRI_NAT_SRC,\n\t},\n\t \n\t{\n\t\t.hook\t\t= nf_nat_ipv6_local_fn,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_LOCAL_OUT,\n\t\t.priority\t= NF_IP6_PRI_NAT_DST,\n\t},\n\t \n\t{\n\t\t.hook\t\t= nf_nat_ipv6_fn,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_LOCAL_IN,\n\t\t.priority\t= NF_IP6_PRI_NAT_SRC,\n\t},\n};\n\nint nf_nat_ipv6_register_fn(struct net *net, const struct nf_hook_ops *ops)\n{\n\treturn nf_nat_register_fn(net, ops->pf, ops, nf_nat_ipv6_ops,\n\t\t\t\t  ARRAY_SIZE(nf_nat_ipv6_ops));\n}\nEXPORT_SYMBOL_GPL(nf_nat_ipv6_register_fn);\n\nvoid nf_nat_ipv6_unregister_fn(struct net *net, const struct nf_hook_ops *ops)\n{\n\tnf_nat_unregister_fn(net, ops->pf, ops, ARRAY_SIZE(nf_nat_ipv6_ops));\n}\nEXPORT_SYMBOL_GPL(nf_nat_ipv6_unregister_fn);\n#endif  \n\n#if defined(CONFIG_NF_TABLES_INET) && IS_ENABLED(CONFIG_NFT_NAT)\nint nf_nat_inet_register_fn(struct net *net, const struct nf_hook_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(ops->pf != NFPROTO_INET))\n\t\treturn -EINVAL;\n\n\tret = nf_nat_register_fn(net, NFPROTO_IPV6, ops, nf_nat_ipv6_ops,\n\t\t\t\t ARRAY_SIZE(nf_nat_ipv6_ops));\n\tif (ret)\n\t\treturn ret;\n\n\tret = nf_nat_register_fn(net, NFPROTO_IPV4, ops, nf_nat_ipv4_ops,\n\t\t\t\t ARRAY_SIZE(nf_nat_ipv4_ops));\n\tif (ret)\n\t\tnf_nat_unregister_fn(net, NFPROTO_IPV6, ops,\n\t\t\t\t\tARRAY_SIZE(nf_nat_ipv6_ops));\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nf_nat_inet_register_fn);\n\nvoid nf_nat_inet_unregister_fn(struct net *net, const struct nf_hook_ops *ops)\n{\n\tnf_nat_unregister_fn(net, NFPROTO_IPV4, ops, ARRAY_SIZE(nf_nat_ipv4_ops));\n\tnf_nat_unregister_fn(net, NFPROTO_IPV6, ops, ARRAY_SIZE(nf_nat_ipv6_ops));\n}\nEXPORT_SYMBOL_GPL(nf_nat_inet_unregister_fn);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}