{
  "module_name": "xt_u32.c",
  "hash_id": "d326e37c2e17302243112b0f73b07d0d2d656716e296eb46fb7946f5e02829d9",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_u32.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/types.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_u32.h>\n\nstatic bool u32_match_it(const struct xt_u32 *data,\n\t\t\t const struct sk_buff *skb)\n{\n\tconst struct xt_u32_test *ct;\n\tunsigned int testind;\n\tunsigned int nnums;\n\tunsigned int nvals;\n\tunsigned int i;\n\t__be32 n;\n\tu_int32_t pos;\n\tu_int32_t val;\n\tu_int32_t at;\n\n\t \n\tfor (testind = 0; testind < data->ntests; ++testind) {\n\t\tct  = &data->tests[testind];\n\t\tat  = 0;\n\t\tpos = ct->location[0].number;\n\n\t\tif (skb->len < 4 || pos > skb->len - 4)\n\t\t\treturn false;\n\n\t\tif (skb_copy_bits(skb, pos, &n, sizeof(n)) < 0)\n\t\t\tBUG();\n\t\tval   = ntohl(n);\n\t\tnnums = ct->nnums;\n\n\t\t \n\t\tfor (i = 1; i < nnums; ++i) {\n\t\t\tu_int32_t number = ct->location[i].number;\n\t\t\tswitch (ct->location[i].nextop) {\n\t\t\tcase XT_U32_AND:\n\t\t\t\tval &= number;\n\t\t\t\tbreak;\n\t\t\tcase XT_U32_LEFTSH:\n\t\t\t\tval <<= number;\n\t\t\t\tbreak;\n\t\t\tcase XT_U32_RIGHTSH:\n\t\t\t\tval >>= number;\n\t\t\t\tbreak;\n\t\t\tcase XT_U32_AT:\n\t\t\t\tif (at + val < at)\n\t\t\t\t\treturn false;\n\t\t\t\tat += val;\n\t\t\t\tpos = number;\n\t\t\t\tif (at + 4 < at || skb->len < at + 4 ||\n\t\t\t\t    pos > skb->len - at - 4)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (skb_copy_bits(skb, at + pos, &n,\n\t\t\t\t\t\t    sizeof(n)) < 0)\n\t\t\t\t\tBUG();\n\t\t\t\tval = ntohl(n);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tnvals = ct->nvalues;\n\t\tfor (i = 0; i < nvals; ++i)\n\t\t\tif (ct->value[i].min <= val && val <= ct->value[i].max)\n\t\t\t\tbreak;\n\n\t\tif (i >= ct->nvalues)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool u32_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_u32 *data = par->matchinfo;\n\tbool ret;\n\n\tret = u32_match_it(data, skb);\n\treturn ret ^ data->invert;\n}\n\nstatic int u32_mt_checkentry(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_u32 *data = par->matchinfo;\n\tconst struct xt_u32_test *ct;\n\tunsigned int i;\n\n\tif (data->ntests > ARRAY_SIZE(data->tests))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < data->ntests; ++i) {\n\t\tct = &data->tests[i];\n\n\t\tif (ct->nnums > ARRAY_SIZE(ct->location) ||\n\t\t    ct->nvalues > ARRAY_SIZE(ct->value))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_match xt_u32_mt_reg __read_mostly = {\n\t.name       = \"u32\",\n\t.revision   = 0,\n\t.family     = NFPROTO_UNSPEC,\n\t.match      = u32_mt,\n\t.checkentry = u32_mt_checkentry,\n\t.matchsize  = sizeof(struct xt_u32),\n\t.me         = THIS_MODULE,\n};\n\nstatic int __init u32_mt_init(void)\n{\n\treturn xt_register_match(&xt_u32_mt_reg);\n}\n\nstatic void __exit u32_mt_exit(void)\n{\n\txt_unregister_match(&xt_u32_mt_reg);\n}\n\nmodule_init(u32_mt_init);\nmodule_exit(u32_mt_exit);\nMODULE_AUTHOR(\"Jan Engelhardt <jengelh@medozas.de>\");\nMODULE_DESCRIPTION(\"Xtables: arbitrary byte matching\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_u32\");\nMODULE_ALIAS(\"ip6t_u32\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}