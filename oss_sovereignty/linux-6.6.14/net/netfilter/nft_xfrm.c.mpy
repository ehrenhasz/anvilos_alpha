{
  "module_name": "nft_xfrm.c",
  "hash_id": "491c2cf8529e02611b6136b28ba32f976d4d91bbd0db142ba218c7132c831ece",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_xfrm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <linux/in.h>\n#include <net/xfrm.h>\n\nstatic const struct nla_policy nft_xfrm_policy[NFTA_XFRM_MAX + 1] = {\n\t[NFTA_XFRM_KEY]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_XFRM_DIR]\t\t= { .type = NLA_U8 },\n\t[NFTA_XFRM_SPNUM]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_XFRM_DREG]\t= { .type = NLA_U32 },\n};\n\nstruct nft_xfrm {\n\tenum nft_xfrm_keys\tkey:8;\n\tu8\t\t\tdreg;\n\tu8\t\t\tdir;\n\tu8\t\t\tspnum;\n\tu8\t\t\tlen;\n};\n\nstatic int nft_xfrm_get_init(const struct nft_ctx *ctx,\n\t\t\t     const struct nft_expr *expr,\n\t\t\t     const struct nlattr * const tb[])\n{\n\tstruct nft_xfrm *priv = nft_expr_priv(expr);\n\tunsigned int len = 0;\n\tu32 spnum = 0;\n\tu8 dir;\n\n\tif (!tb[NFTA_XFRM_KEY] || !tb[NFTA_XFRM_DIR] || !tb[NFTA_XFRM_DREG])\n\t\treturn -EINVAL;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_XFRM_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_XFRM_KEY_REQID:\n\tcase NFT_XFRM_KEY_SPI:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tcase NFT_XFRM_KEY_DADDR_IP4:\n\tcase NFT_XFRM_KEY_SADDR_IP4:\n\t\tlen = sizeof(struct in_addr);\n\t\tbreak;\n\tcase NFT_XFRM_KEY_DADDR_IP6:\n\tcase NFT_XFRM_KEY_SADDR_IP6:\n\t\tlen = sizeof(struct in6_addr);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdir = nla_get_u8(tb[NFTA_XFRM_DIR]);\n\tswitch (dir) {\n\tcase XFRM_POLICY_IN:\n\tcase XFRM_POLICY_OUT:\n\t\tpriv->dir = dir;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NFTA_XFRM_SPNUM])\n\t\tspnum = ntohl(nla_get_be32(tb[NFTA_XFRM_SPNUM]));\n\n\tif (spnum >= XFRM_MAX_DEPTH)\n\t\treturn -ERANGE;\n\n\tpriv->spnum = spnum;\n\n\tpriv->len = len;\n\treturn nft_parse_register_store(ctx, tb[NFTA_XFRM_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\n\n \nstatic bool xfrm_state_addr_ok(enum nft_xfrm_keys k, u8 family, u8 mode)\n{\n\tswitch (k) {\n\tcase NFT_XFRM_KEY_DADDR_IP4:\n\tcase NFT_XFRM_KEY_SADDR_IP4:\n\t\tif (family == NFPROTO_IPV4)\n\t\t\tbreak;\n\t\treturn false;\n\tcase NFT_XFRM_KEY_DADDR_IP6:\n\tcase NFT_XFRM_KEY_SADDR_IP6:\n\t\tif (family == NFPROTO_IPV6)\n\t\t\tbreak;\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n\n\treturn mode == XFRM_MODE_BEET || mode == XFRM_MODE_TUNNEL;\n}\n\nstatic void nft_xfrm_state_get_key(const struct nft_xfrm *priv,\n\t\t\t\t   struct nft_regs *regs,\n\t\t\t\t   const struct xfrm_state *state)\n{\n\tu32 *dest = &regs->data[priv->dreg];\n\n\tif (!xfrm_state_addr_ok(priv->key,\n\t\t\t\tstate->props.family,\n\t\t\t\tstate->props.mode)) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tswitch (priv->key) {\n\tcase NFT_XFRM_KEY_UNSPEC:\n\tcase __NFT_XFRM_KEY_MAX:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\tcase NFT_XFRM_KEY_DADDR_IP4:\n\t\t*dest = (__force __u32)state->id.daddr.a4;\n\t\treturn;\n\tcase NFT_XFRM_KEY_DADDR_IP6:\n\t\tmemcpy(dest, &state->id.daddr.in6, sizeof(struct in6_addr));\n\t\treturn;\n\tcase NFT_XFRM_KEY_SADDR_IP4:\n\t\t*dest = (__force __u32)state->props.saddr.a4;\n\t\treturn;\n\tcase NFT_XFRM_KEY_SADDR_IP6:\n\t\tmemcpy(dest, &state->props.saddr.in6, sizeof(struct in6_addr));\n\t\treturn;\n\tcase NFT_XFRM_KEY_REQID:\n\t\t*dest = state->props.reqid;\n\t\treturn;\n\tcase NFT_XFRM_KEY_SPI:\n\t\t*dest = (__force __u32)state->id.spi;\n\t\treturn;\n\t}\n\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic void nft_xfrm_get_eval_in(const struct nft_xfrm *priv,\n\t\t\t\t    struct nft_regs *regs,\n\t\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tconst struct sec_path *sp = skb_sec_path(pkt->skb);\n\tconst struct xfrm_state *state;\n\n\tif (sp == NULL || sp->len <= priv->spnum) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tstate = sp->xvec[priv->spnum];\n\tnft_xfrm_state_get_key(priv, regs, state);\n}\n\nstatic void nft_xfrm_get_eval_out(const struct nft_xfrm *priv,\n\t\t\t\t  struct nft_regs *regs,\n\t\t\t\t  const struct nft_pktinfo *pkt)\n{\n\tconst struct dst_entry *dst = skb_dst(pkt->skb);\n\tint i;\n\n\tfor (i = 0; dst && dst->xfrm;\n\t     dst = ((const struct xfrm_dst *)dst)->child, i++) {\n\t\tif (i < priv->spnum)\n\t\t\tcontinue;\n\n\t\tnft_xfrm_state_get_key(priv, regs, dst->xfrm);\n\t\treturn;\n\t}\n\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic void nft_xfrm_get_eval(const struct nft_expr *expr,\n\t\t\t      struct nft_regs *regs,\n\t\t\t      const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_xfrm *priv = nft_expr_priv(expr);\n\n\tswitch (priv->dir) {\n\tcase XFRM_POLICY_IN:\n\t\tnft_xfrm_get_eval_in(priv, regs, pkt);\n\t\tbreak;\n\tcase XFRM_POLICY_OUT:\n\t\tnft_xfrm_get_eval_out(priv, regs, pkt);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tregs->verdict.code = NFT_BREAK;\n\t\tbreak;\n\t}\n}\n\nstatic int nft_xfrm_get_dump(struct sk_buff *skb,\n\t\t\t     const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_xfrm *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_XFRM_DREG, priv->dreg))\n\t\treturn -1;\n\n\tif (nla_put_be32(skb, NFTA_XFRM_KEY, htonl(priv->key)))\n\t\treturn -1;\n\tif (nla_put_u8(skb, NFTA_XFRM_DIR, priv->dir))\n\t\treturn -1;\n\tif (nla_put_be32(skb, NFTA_XFRM_SPNUM, htonl(priv->spnum)))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int nft_xfrm_validate(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t\t     const struct nft_data **data)\n{\n\tconst struct nft_xfrm *priv = nft_expr_priv(expr);\n\tunsigned int hooks;\n\n\tswitch (priv->dir) {\n\tcase XFRM_POLICY_IN:\n\t\thooks = (1 << NF_INET_FORWARD) |\n\t\t\t(1 << NF_INET_LOCAL_IN) |\n\t\t\t(1 << NF_INET_PRE_ROUTING);\n\t\tbreak;\n\tcase XFRM_POLICY_OUT:\n\t\thooks = (1 << NF_INET_FORWARD) |\n\t\t\t(1 << NF_INET_LOCAL_OUT) |\n\t\t\t(1 << NF_INET_POST_ROUTING);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\n\nstatic bool nft_xfrm_reduce(struct nft_regs_track *track,\n\t\t\t    const struct nft_expr *expr)\n{\n\tconst struct nft_xfrm *priv = nft_expr_priv(expr);\n\tconst struct nft_xfrm *xfrm;\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\txfrm = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->key != xfrm->key ||\n\t    priv->dreg != xfrm->dreg ||\n\t    priv->dir != xfrm->dir ||\n\t    priv->spnum != xfrm->spnum) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn nft_expr_reduce_bitwise(track, expr);\n}\n\nstatic struct nft_expr_type nft_xfrm_type;\nstatic const struct nft_expr_ops nft_xfrm_get_ops = {\n\t.type\t\t= &nft_xfrm_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_xfrm)),\n\t.eval\t\t= nft_xfrm_get_eval,\n\t.init\t\t= nft_xfrm_get_init,\n\t.dump\t\t= nft_xfrm_get_dump,\n\t.validate\t= nft_xfrm_validate,\n\t.reduce\t\t= nft_xfrm_reduce,\n};\n\nstatic struct nft_expr_type nft_xfrm_type __read_mostly = {\n\t.name\t\t= \"xfrm\",\n\t.ops\t\t= &nft_xfrm_get_ops,\n\t.policy\t\t= nft_xfrm_policy,\n\t.maxattr\t= NFTA_XFRM_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_xfrm_module_init(void)\n{\n\treturn nft_register_expr(&nft_xfrm_type);\n}\n\nstatic void __exit nft_xfrm_module_exit(void)\n{\n\tnft_unregister_expr(&nft_xfrm_type);\n}\n\nmodule_init(nft_xfrm_module_init);\nmodule_exit(nft_xfrm_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"nf_tables: xfrm/IPSec matching\");\nMODULE_AUTHOR(\"Florian Westphal <fw@strlen.de>\");\nMODULE_AUTHOR(\"M\u00e1t\u00e9 Eckl <ecklm94@gmail.com>\");\nMODULE_ALIAS_NFT_EXPR(\"xfrm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}