{
  "module_name": "xt_l2tp.c",
  "hash_id": "4afb24df9bf2da17539583e9bb9bf202a90010477ae3093b36ac2d454cfbaa82",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_l2tp.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/if_ether.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n#include <linux/l2tp.h>\n\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_tcpudp.h>\n#include <linux/netfilter/xt_l2tp.h>\n\n \n#define L2TP_HDR_T_BIT\t0x8000\n#define L2TP_HDR_L_BIT\t0x4000\n#define L2TP_HDR_VER\t0x000f\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"Xtables: L2TP header match\");\nMODULE_ALIAS(\"ipt_l2tp\");\nMODULE_ALIAS(\"ip6t_l2tp\");\n\n \nstruct l2tp_data {\n\tu32 tid;\n\tu32 sid;\n\tu8 type;\n\tu8 version;\n};\n\nunion l2tp_val {\n\t__be16 val16[2];\n\t__be32 val32;\n};\n\nstatic bool l2tp_match(const struct xt_l2tp_info *info, struct l2tp_data *data)\n{\n\tif ((info->flags & XT_L2TP_TYPE) && (info->type != data->type))\n\t\treturn false;\n\n\tif ((info->flags & XT_L2TP_VERSION) && (info->version != data->version))\n\t\treturn false;\n\n\t \n\tif ((info->flags & XT_L2TP_TID) &&\n\t    ((data->type == XT_L2TP_TYPE_CONTROL) || (data->version == 2)) &&\n\t    (info->tid != data->tid))\n\t\treturn false;\n\n\t \n\tif ((info->flags & XT_L2TP_SID) && (data->type == XT_L2TP_TYPE_DATA) &&\n\t    (info->sid != data->sid))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool l2tp_udp_mt(const struct sk_buff *skb, struct xt_action_param *par, u16 thoff)\n{\n\tconst struct xt_l2tp_info *info = par->matchinfo;\n\tint uhlen = sizeof(struct udphdr);\n\tint offs = thoff + uhlen;\n\tunion l2tp_val *lh;\n\tunion l2tp_val lhbuf;\n\tu16 flags;\n\tstruct l2tp_data data = { 0, };\n\n\tif (par->fragoff != 0)\n\t\treturn false;\n\n\t \n\tlh = skb_header_pointer(skb, offs, 2, &lhbuf);\n\tif (lh == NULL)\n\t\treturn false;\n\n\tflags = ntohs(lh->val16[0]);\n\tif (flags & L2TP_HDR_T_BIT)\n\t\tdata.type = XT_L2TP_TYPE_CONTROL;\n\telse\n\t\tdata.type = XT_L2TP_TYPE_DATA;\n\tdata.version = (u8) flags & L2TP_HDR_VER;\n\n\t \n\tif (data.version == 3) {\n\t\tlh = skb_header_pointer(skb, offs + 4, 4, &lhbuf);\n\t\tif (lh == NULL)\n\t\t\treturn false;\n\t\tif (data.type == XT_L2TP_TYPE_CONTROL)\n\t\t\tdata.tid = ntohl(lh->val32);\n\t\telse\n\t\t\tdata.sid = ntohl(lh->val32);\n\t} else if (data.version == 2) {\n\t\tif (flags & L2TP_HDR_L_BIT)\n\t\t\toffs += 2;\n\t\tlh = skb_header_pointer(skb, offs + 2, 4, &lhbuf);\n\t\tif (lh == NULL)\n\t\t\treturn false;\n\t\tdata.tid = (u32) ntohs(lh->val16[0]);\n\t\tdata.sid = (u32) ntohs(lh->val16[1]);\n\t} else\n\t\treturn false;\n\n\treturn l2tp_match(info, &data);\n}\n\n \nstatic bool l2tp_ip_mt(const struct sk_buff *skb, struct xt_action_param *par, u16 thoff)\n{\n\tconst struct xt_l2tp_info *info = par->matchinfo;\n\tunion l2tp_val *lh;\n\tunion l2tp_val lhbuf;\n\tstruct l2tp_data data = { 0, };\n\n\t \n\tlh = skb_header_pointer(skb, thoff, sizeof(lhbuf), &lhbuf);\n\tif (lh == NULL)\n\t\treturn false;\n\tif (lh->val32 == 0) {\n\t\t \n\t\tdata.type = XT_L2TP_TYPE_CONTROL;\n\t\tlh = skb_header_pointer(skb, thoff + 8, sizeof(lhbuf),\n\t\t\t\t\t&lhbuf);\n\t\tif (lh == NULL)\n\t\t\treturn false;\n\t\tdata.tid = ntohl(lh->val32);\n\t} else {\n\t\tdata.sid = ntohl(lh->val32);\n\t\tdata.type = XT_L2TP_TYPE_DATA;\n\t}\n\n\tdata.version = 3;\n\n\treturn l2tp_match(info, &data);\n}\n\nstatic bool l2tp_mt4(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tstruct iphdr *iph = ip_hdr(skb);\n\tu8 ipproto = iph->protocol;\n\n\t \n\tswitch (ipproto) {\n\tcase IPPROTO_UDP:\n\t\treturn l2tp_udp_mt(skb, par, par->thoff);\n\tcase IPPROTO_L2TP:\n\t\treturn l2tp_ip_mt(skb, par, par->thoff);\n\t}\n\n\treturn false;\n}\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nstatic bool l2tp_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tunsigned int thoff = 0;\n\tunsigned short fragoff = 0;\n\tint ipproto;\n\n\tipproto = ipv6_find_hdr(skb, &thoff, -1, &fragoff, NULL);\n\tif (fragoff != 0)\n\t\treturn false;\n\n\t \n\tswitch (ipproto) {\n\tcase IPPROTO_UDP:\n\t\treturn l2tp_udp_mt(skb, par, thoff);\n\tcase IPPROTO_L2TP:\n\t\treturn l2tp_ip_mt(skb, par, thoff);\n\t}\n\n\treturn false;\n}\n#endif\n\nstatic int l2tp_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_l2tp_info *info = par->matchinfo;\n\n\t \n\tif (info->flags & ~(XT_L2TP_TID | XT_L2TP_SID | XT_L2TP_VERSION |\n\t\t\t    XT_L2TP_TYPE)) {\n\t\tpr_info_ratelimited(\"unknown flags: %x\\n\", info->flags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((!(info->flags & XT_L2TP_TID)) &&\n\t    (!(info->flags & XT_L2TP_SID)) &&\n\t    ((!(info->flags & XT_L2TP_TYPE)) ||\n\t     (info->type != XT_L2TP_TYPE_CONTROL))) {\n\t\tpr_info_ratelimited(\"invalid flags combination: %x\\n\",\n\t\t\t\t    info->flags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (info->flags & XT_L2TP_VERSION) {\n\t\tif ((info->version < 2) || (info->version > 3)) {\n\t\t\tpr_info_ratelimited(\"wrong L2TP version: %u\\n\",\n\t\t\t\t\t    info->version);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (info->version == 2) {\n\t\t\tif ((info->flags & XT_L2TP_TID) &&\n\t\t\t    (info->tid > 0xffff)) {\n\t\t\t\tpr_info_ratelimited(\"v2 tid > 0xffff: %u\\n\",\n\t\t\t\t\t\t    info->tid);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif ((info->flags & XT_L2TP_SID) &&\n\t\t\t    (info->sid > 0xffff)) {\n\t\t\t\tpr_info_ratelimited(\"v2 sid > 0xffff: %u\\n\",\n\t\t\t\t\t\t    info->sid);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int l2tp_mt_check4(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_l2tp_info *info = par->matchinfo;\n\tconst struct ipt_entry *e = par->entryinfo;\n\tconst struct ipt_ip *ip = &e->ip;\n\tint ret;\n\n\tret = l2tp_mt_check(par);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif ((ip->proto != IPPROTO_UDP) &&\n\t    (ip->proto != IPPROTO_L2TP)) {\n\t\tpr_info_ratelimited(\"missing protocol rule (udp|l2tpip)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ip->proto == IPPROTO_L2TP) &&\n\t    (info->version == 2)) {\n\t\tpr_info_ratelimited(\"v2 doesn't support IP mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nstatic int l2tp_mt_check6(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_l2tp_info *info = par->matchinfo;\n\tconst struct ip6t_entry *e = par->entryinfo;\n\tconst struct ip6t_ip6 *ip = &e->ipv6;\n\tint ret;\n\n\tret = l2tp_mt_check(par);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif ((ip->proto != IPPROTO_UDP) &&\n\t    (ip->proto != IPPROTO_L2TP)) {\n\t\tpr_info_ratelimited(\"missing protocol rule (udp|l2tpip)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ip->proto == IPPROTO_L2TP) &&\n\t    (info->version == 2)) {\n\t\tpr_info_ratelimited(\"v2 doesn't support IP mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic struct xt_match l2tp_mt_reg[] __read_mostly = {\n\t{\n\t\t.name      = \"l2tp\",\n\t\t.revision  = 0,\n\t\t.family    = NFPROTO_IPV4,\n\t\t.match     = l2tp_mt4,\n\t\t.matchsize = XT_ALIGN(sizeof(struct xt_l2tp_info)),\n\t\t.checkentry = l2tp_mt_check4,\n\t\t.hooks     = ((1 << NF_INET_PRE_ROUTING) |\n\t\t\t      (1 << NF_INET_LOCAL_IN) |\n\t\t\t      (1 << NF_INET_LOCAL_OUT) |\n\t\t\t      (1 << NF_INET_FORWARD)),\n\t\t.me        = THIS_MODULE,\n\t},\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\t{\n\t\t.name      = \"l2tp\",\n\t\t.revision  = 0,\n\t\t.family    = NFPROTO_IPV6,\n\t\t.match     = l2tp_mt6,\n\t\t.matchsize = XT_ALIGN(sizeof(struct xt_l2tp_info)),\n\t\t.checkentry = l2tp_mt_check6,\n\t\t.hooks     = ((1 << NF_INET_PRE_ROUTING) |\n\t\t\t      (1 << NF_INET_LOCAL_IN) |\n\t\t\t      (1 << NF_INET_LOCAL_OUT) |\n\t\t\t      (1 << NF_INET_FORWARD)),\n\t\t.me        = THIS_MODULE,\n\t},\n#endif\n};\n\nstatic int __init l2tp_mt_init(void)\n{\n\treturn xt_register_matches(&l2tp_mt_reg[0], ARRAY_SIZE(l2tp_mt_reg));\n}\n\nstatic void __exit l2tp_mt_exit(void)\n{\n\txt_unregister_matches(&l2tp_mt_reg[0], ARRAY_SIZE(l2tp_mt_reg));\n}\n\nmodule_init(l2tp_mt_init);\nmodule_exit(l2tp_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}