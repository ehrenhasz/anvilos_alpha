{
  "module_name": "nf_tables_core.c",
  "hash_id": "42db7e030e4029ef9f24a1740be5b553492f4651923c60b31947ae8cea964b8f",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_tables_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/static_key.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_log.h>\n#include <net/netfilter/nft_meta.h>\n\n#if defined(CONFIG_RETPOLINE) && defined(CONFIG_X86)\n\nstatic struct static_key_false nf_tables_skip_direct_calls;\n\nstatic bool nf_skip_indirect_calls(void)\n{\n\treturn static_branch_likely(&nf_tables_skip_direct_calls);\n}\n\nstatic void __init nf_skip_indirect_calls_enable(void)\n{\n\tif (!cpu_feature_enabled(X86_FEATURE_RETPOLINE))\n\t\tstatic_branch_enable(&nf_tables_skip_direct_calls);\n}\n#else\nstatic inline bool nf_skip_indirect_calls(void) { return false; }\n\nstatic inline void nf_skip_indirect_calls_enable(void) { }\n#endif\n\nstatic noinline void __nft_trace_packet(const struct nft_pktinfo *pkt,\n\t\t\t\t\tconst struct nft_verdict *verdict,\n\t\t\t\t\tconst struct nft_rule_dp *rule,\n\t\t\t\t\tstruct nft_traceinfo *info,\n\t\t\t\t\tenum nft_trace_types type)\n{\n\tif (!info->trace || !info->nf_trace)\n\t\treturn;\n\n\tinfo->type = type;\n\n\tnft_trace_notify(pkt, verdict, rule, info);\n}\n\nstatic inline void nft_trace_packet(const struct nft_pktinfo *pkt,\n\t\t\t\t    struct nft_verdict *verdict,\n\t\t\t\t    struct nft_traceinfo *info,\n\t\t\t\t    const struct nft_rule_dp *rule,\n\t\t\t\t    enum nft_trace_types type)\n{\n\tif (static_branch_unlikely(&nft_trace_enabled)) {\n\t\tinfo->nf_trace = pkt->skb->nf_trace;\n\t\t__nft_trace_packet(pkt, verdict, rule, info, type);\n\t}\n}\n\nstatic inline void nft_trace_copy_nftrace(const struct nft_pktinfo *pkt,\n\t\t\t\t\t  struct nft_traceinfo *info)\n{\n\tif (static_branch_unlikely(&nft_trace_enabled))\n\t\tinfo->nf_trace = pkt->skb->nf_trace;\n}\n\nstatic void nft_bitwise_fast_eval(const struct nft_expr *expr,\n\t\t\t\t  struct nft_regs *regs)\n{\n\tconst struct nft_bitwise_fast_expr *priv = nft_expr_priv(expr);\n\tu32 *src = &regs->data[priv->sreg];\n\tu32 *dst = &regs->data[priv->dreg];\n\n\t*dst = (*src & priv->mask) ^ priv->xor;\n}\n\nstatic void nft_cmp_fast_eval(const struct nft_expr *expr,\n\t\t\t      struct nft_regs *regs)\n{\n\tconst struct nft_cmp_fast_expr *priv = nft_expr_priv(expr);\n\n\tif (((regs->data[priv->sreg] & priv->mask) == priv->data) ^ priv->inv)\n\t\treturn;\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic void nft_cmp16_fast_eval(const struct nft_expr *expr,\n\t\t\t\tstruct nft_regs *regs)\n{\n\tconst struct nft_cmp16_fast_expr *priv = nft_expr_priv(expr);\n\tconst u64 *reg_data = (const u64 *)&regs->data[priv->sreg];\n\tconst u64 *mask = (const u64 *)&priv->mask;\n\tconst u64 *data = (const u64 *)&priv->data;\n\n\tif (((reg_data[0] & mask[0]) == data[0] &&\n\t    ((reg_data[1] & mask[1]) == data[1])) ^ priv->inv)\n\t\treturn;\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic noinline void __nft_trace_verdict(const struct nft_pktinfo *pkt,\n\t\t\t\t\t struct nft_traceinfo *info,\n\t\t\t\t\t const struct nft_rule_dp *rule,\n\t\t\t\t\t const struct nft_regs *regs)\n{\n\tenum nft_trace_types type;\n\n\tswitch (regs->verdict.code) {\n\tcase NFT_CONTINUE:\n\tcase NFT_RETURN:\n\t\ttype = NFT_TRACETYPE_RETURN;\n\t\tbreak;\n\tcase NF_STOLEN:\n\t\ttype = NFT_TRACETYPE_RULE;\n\t\t \n\t\tbreak;\n\tdefault:\n\t\ttype = NFT_TRACETYPE_RULE;\n\n\t\tif (info->trace)\n\t\t\tinfo->nf_trace = pkt->skb->nf_trace;\n\t\tbreak;\n\t}\n\n\t__nft_trace_packet(pkt, &regs->verdict, rule, info, type);\n}\n\nstatic inline void nft_trace_verdict(const struct nft_pktinfo *pkt,\n\t\t\t\t     struct nft_traceinfo *info,\n\t\t\t\t     const struct nft_rule_dp *rule,\n\t\t\t\t     const struct nft_regs *regs)\n{\n\tif (static_branch_unlikely(&nft_trace_enabled))\n\t\t__nft_trace_verdict(pkt, info, rule, regs);\n}\n\nstatic bool nft_payload_fast_eval(const struct nft_expr *expr,\n\t\t\t\t  struct nft_regs *regs,\n\t\t\t\t  const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_payload *priv = nft_expr_priv(expr);\n\tconst struct sk_buff *skb = pkt->skb;\n\tu32 *dest = &regs->data[priv->dreg];\n\tunsigned char *ptr;\n\n\tif (priv->base == NFT_PAYLOAD_NETWORK_HEADER)\n\t\tptr = skb_network_header(skb);\n\telse {\n\t\tif (!(pkt->flags & NFT_PKTINFO_L4PROTO))\n\t\t\treturn false;\n\t\tptr = skb->data + nft_thoff(pkt);\n\t}\n\n\tptr += priv->offset;\n\n\tif (unlikely(ptr + priv->len > skb_tail_pointer(skb)))\n\t\treturn false;\n\n\t*dest = 0;\n\tif (priv->len == 2)\n\t\t*(u16 *)dest = *(u16 *)ptr;\n\telse if (priv->len == 4)\n\t\t*(u32 *)dest = *(u32 *)ptr;\n\telse\n\t\t*(u8 *)dest = *(u8 *)ptr;\n\treturn true;\n}\n\nDEFINE_STATIC_KEY_FALSE(nft_counters_enabled);\n\nstatic noinline void nft_update_chain_stats(const struct nft_chain *chain,\n\t\t\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tstruct nft_base_chain *base_chain;\n\tstruct nft_stats __percpu *pstats;\n\tstruct nft_stats *stats;\n\n\tbase_chain = nft_base_chain(chain);\n\n\tpstats = READ_ONCE(base_chain->stats);\n\tif (pstats) {\n\t\tlocal_bh_disable();\n\t\tstats = this_cpu_ptr(pstats);\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tstats->pkts++;\n\t\tstats->bytes += pkt->skb->len;\n\t\tu64_stats_update_end(&stats->syncp);\n\t\tlocal_bh_enable();\n\t}\n}\n\nstruct nft_jumpstack {\n\tconst struct nft_rule_dp *rule;\n};\n\nstatic void expr_call_ops_eval(const struct nft_expr *expr,\n\t\t\t       struct nft_regs *regs,\n\t\t\t       struct nft_pktinfo *pkt)\n{\n#ifdef CONFIG_RETPOLINE\n\tunsigned long e;\n\n\tif (nf_skip_indirect_calls())\n\t\tgoto indirect_call;\n\n\te = (unsigned long)expr->ops->eval;\n#define X(e, fun) \\\n\tdo { if ((e) == (unsigned long)(fun)) \\\n\t\treturn fun(expr, regs, pkt); } while (0)\n\n\tX(e, nft_payload_eval);\n\tX(e, nft_cmp_eval);\n\tX(e, nft_counter_eval);\n\tX(e, nft_meta_get_eval);\n\tX(e, nft_lookup_eval);\n#if IS_ENABLED(CONFIG_NFT_CT)\n\tX(e, nft_ct_get_fast_eval);\n#endif\n\tX(e, nft_range_eval);\n\tX(e, nft_immediate_eval);\n\tX(e, nft_byteorder_eval);\n\tX(e, nft_dynset_eval);\n\tX(e, nft_rt_get_eval);\n\tX(e, nft_bitwise_eval);\n\tX(e, nft_objref_eval);\n\tX(e, nft_objref_map_eval);\n#undef  X\nindirect_call:\n#endif  \n\texpr->ops->eval(expr, regs, pkt);\n}\n\n#define nft_rule_expr_first(rule)\t(struct nft_expr *)&rule->data[0]\n#define nft_rule_expr_next(expr)\t((void *)expr) + expr->ops->size\n#define nft_rule_expr_last(rule)\t(struct nft_expr *)&rule->data[rule->dlen]\n\n#define nft_rule_dp_for_each_expr(expr, last, rule) \\\n        for ((expr) = nft_rule_expr_first(rule), (last) = nft_rule_expr_last(rule); \\\n             (expr) != (last); \\\n             (expr) = nft_rule_expr_next(expr))\n\nunsigned int\nnft_do_chain(struct nft_pktinfo *pkt, void *priv)\n{\n\tconst struct nft_chain *chain = priv, *basechain = chain;\n\tconst struct net *net = nft_net(pkt);\n\tconst struct nft_expr *expr, *last;\n\tconst struct nft_rule_dp *rule;\n\tstruct nft_regs regs = {};\n\tunsigned int stackptr = 0;\n\tstruct nft_jumpstack jumpstack[NFT_JUMP_STACK_SIZE];\n\tbool genbit = READ_ONCE(net->nft.gencursor);\n\tstruct nft_rule_blob *blob;\n\tstruct nft_traceinfo info;\n\n\tinfo.trace = false;\n\tif (static_branch_unlikely(&nft_trace_enabled))\n\t\tnft_trace_init(&info, pkt, basechain);\ndo_chain:\n\tif (genbit)\n\t\tblob = rcu_dereference(chain->blob_gen_1);\n\telse\n\t\tblob = rcu_dereference(chain->blob_gen_0);\n\n\trule = (struct nft_rule_dp *)blob->data;\nnext_rule:\n\tregs.verdict.code = NFT_CONTINUE;\n\tfor (; !rule->is_last ; rule = nft_rule_next(rule)) {\n\t\tnft_rule_dp_for_each_expr(expr, last, rule) {\n\t\t\tif (expr->ops == &nft_cmp_fast_ops)\n\t\t\t\tnft_cmp_fast_eval(expr, &regs);\n\t\t\telse if (expr->ops == &nft_cmp16_fast_ops)\n\t\t\t\tnft_cmp16_fast_eval(expr, &regs);\n\t\t\telse if (expr->ops == &nft_bitwise_fast_ops)\n\t\t\t\tnft_bitwise_fast_eval(expr, &regs);\n\t\t\telse if (expr->ops != &nft_payload_fast_ops ||\n\t\t\t\t !nft_payload_fast_eval(expr, &regs, pkt))\n\t\t\t\texpr_call_ops_eval(expr, &regs, pkt);\n\n\t\t\tif (regs.verdict.code != NFT_CONTINUE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tswitch (regs.verdict.code) {\n\t\tcase NFT_BREAK:\n\t\t\tregs.verdict.code = NFT_CONTINUE;\n\t\t\tnft_trace_copy_nftrace(pkt, &info);\n\t\t\tcontinue;\n\t\tcase NFT_CONTINUE:\n\t\t\tnft_trace_packet(pkt, &regs.verdict,  &info, rule,\n\t\t\t\t\t NFT_TRACETYPE_RULE);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tnft_trace_verdict(pkt, &info, rule, &regs);\n\n\tswitch (regs.verdict.code & NF_VERDICT_MASK) {\n\tcase NF_ACCEPT:\n\tcase NF_DROP:\n\tcase NF_QUEUE:\n\tcase NF_STOLEN:\n\t\treturn regs.verdict.code;\n\t}\n\n\tswitch (regs.verdict.code) {\n\tcase NFT_JUMP:\n\t\tif (WARN_ON_ONCE(stackptr >= NFT_JUMP_STACK_SIZE))\n\t\t\treturn NF_DROP;\n\t\tjumpstack[stackptr].rule = nft_rule_next(rule);\n\t\tstackptr++;\n\t\tfallthrough;\n\tcase NFT_GOTO:\n\t\tchain = regs.verdict.chain;\n\t\tgoto do_chain;\n\tcase NFT_CONTINUE:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\tif (stackptr > 0) {\n\t\tstackptr--;\n\t\trule = jumpstack[stackptr].rule;\n\t\tgoto next_rule;\n\t}\n\n\tnft_trace_packet(pkt, &regs.verdict, &info, NULL, NFT_TRACETYPE_POLICY);\n\n\tif (static_branch_unlikely(&nft_counters_enabled))\n\t\tnft_update_chain_stats(basechain, pkt);\n\n\treturn nft_base_chain(basechain)->policy;\n}\nEXPORT_SYMBOL_GPL(nft_do_chain);\n\nstatic struct nft_expr_type *nft_basic_types[] = {\n\t&nft_imm_type,\n\t&nft_cmp_type,\n\t&nft_lookup_type,\n\t&nft_bitwise_type,\n\t&nft_byteorder_type,\n\t&nft_payload_type,\n\t&nft_dynset_type,\n\t&nft_range_type,\n\t&nft_meta_type,\n\t&nft_rt_type,\n\t&nft_exthdr_type,\n\t&nft_last_type,\n\t&nft_counter_type,\n\t&nft_objref_type,\n\t&nft_inner_type,\n};\n\nstatic struct nft_object_type *nft_basic_objects[] = {\n#ifdef CONFIG_NETWORK_SECMARK\n\t&nft_secmark_obj_type,\n#endif\n\t&nft_counter_obj_type,\n};\n\nint __init nf_tables_core_module_init(void)\n{\n\tint err, i, j = 0;\n\n\tnft_counter_init_seqcount();\n\n\tfor (i = 0; i < ARRAY_SIZE(nft_basic_objects); i++) {\n\t\terr = nft_register_obj(nft_basic_objects[i]);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tfor (j = 0; j < ARRAY_SIZE(nft_basic_types); j++) {\n\t\terr = nft_register_expr(nft_basic_types[j]);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tnf_skip_indirect_calls_enable();\n\n\treturn 0;\n\nerr:\n\twhile (j-- > 0)\n\t\tnft_unregister_expr(nft_basic_types[j]);\n\n\twhile (i-- > 0)\n\t\tnft_unregister_obj(nft_basic_objects[i]);\n\n\treturn err;\n}\n\nvoid nf_tables_core_module_exit(void)\n{\n\tint i;\n\n\ti = ARRAY_SIZE(nft_basic_types);\n\twhile (i-- > 0)\n\t\tnft_unregister_expr(nft_basic_types[i]);\n\n\ti = ARRAY_SIZE(nft_basic_objects);\n\twhile (i-- > 0)\n\t\tnft_unregister_obj(nft_basic_objects[i]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}