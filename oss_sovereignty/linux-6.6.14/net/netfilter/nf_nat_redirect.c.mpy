{
  "module_name": "nf_nat_redirect.c",
  "hash_id": "837f83bff995a212f188bfe7dfe4548d9be154dab46e721c1fa957b147a832f6",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_nat_redirect.c",
  "human_readable_source": "\n \n\n#include <linux/if.h>\n#include <linux/inetdevice.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter.h>\n#include <linux/types.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter/x_tables.h>\n#include <net/addrconf.h>\n#include <net/checksum.h>\n#include <net/protocol.h>\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_nat_redirect.h>\n\nstatic unsigned int\nnf_nat_redirect(struct sk_buff *skb, const struct nf_nat_range2 *range,\n\t\tconst union nf_inet_addr *newdst)\n{\n\tstruct nf_nat_range2 newrange;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\n\tmemset(&newrange, 0, sizeof(newrange));\n\n\tnewrange.flags\t\t= range->flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr\t= *newdst;\n\tnewrange.max_addr\t= *newdst;\n\tnewrange.min_proto\t= range->min_proto;\n\tnewrange.max_proto\t= range->max_proto;\n\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}\n\nunsigned int\nnf_nat_redirect_ipv4(struct sk_buff *skb, const struct nf_nat_range2 *range,\n\t\t     unsigned int hooknum)\n{\n\tunion nf_inet_addr newdst = {};\n\n\tWARN_ON(hooknum != NF_INET_PRE_ROUTING &&\n\t\thooknum != NF_INET_LOCAL_OUT);\n\n\t \n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst.ip = htonl(INADDR_LOOPBACK);\n\t} else {\n\t\tconst struct in_device *indev;\n\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev) {\n\t\t\tconst struct in_ifaddr *ifa;\n\n\t\t\tifa = rcu_dereference(indev->ifa_list);\n\t\t\tif (ifa)\n\t\t\t\tnewdst.ip = ifa->ifa_local;\n\t\t}\n\n\t\tif (!newdst.ip)\n\t\t\treturn NF_DROP;\n\t}\n\n\treturn nf_nat_redirect(skb, range, &newdst);\n}\nEXPORT_SYMBOL_GPL(nf_nat_redirect_ipv4);\n\nstatic const struct in6_addr loopback_addr = IN6ADDR_LOOPBACK_INIT;\n\nstatic bool nf_nat_redirect_ipv6_usable(const struct inet6_ifaddr *ifa, unsigned int scope)\n{\n\tunsigned int ifa_addr_type = ipv6_addr_type(&ifa->addr);\n\n\tif (ifa_addr_type & IPV6_ADDR_MAPPED)\n\t\treturn false;\n\n\tif ((ifa->flags & IFA_F_TENTATIVE) && (!(ifa->flags & IFA_F_OPTIMISTIC)))\n\t\treturn false;\n\n\tif (scope) {\n\t\tunsigned int ifa_scope = ifa_addr_type & IPV6_ADDR_SCOPE_MASK;\n\n\t\tif (!(scope & ifa_scope))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nunsigned int\nnf_nat_redirect_ipv6(struct sk_buff *skb, const struct nf_nat_range2 *range,\n\t\t     unsigned int hooknum)\n{\n\tunion nf_inet_addr newdst = {};\n\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst.in6 = loopback_addr;\n\t} else {\n\t\tunsigned int scope = ipv6_addr_scope(&ipv6_hdr(skb)->daddr);\n\t\tstruct inet6_dev *idev;\n\t\tbool addr = false;\n\n\t\tidev = __in6_dev_get(skb->dev);\n\t\tif (idev != NULL) {\n\t\t\tconst struct inet6_ifaddr *ifa;\n\n\t\t\tread_lock_bh(&idev->lock);\n\t\t\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\t\t\tif (!nf_nat_redirect_ipv6_usable(ifa, scope))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnewdst.in6 = ifa->addr;\n\t\t\t\taddr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_unlock_bh(&idev->lock);\n\t\t}\n\n\t\tif (!addr)\n\t\t\treturn NF_DROP;\n\t}\n\n\treturn nf_nat_redirect(skb, range, &newdst);\n}\nEXPORT_SYMBOL_GPL(nf_nat_redirect_ipv6);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}