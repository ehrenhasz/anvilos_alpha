{
  "module_name": "xt_length.c",
  "hash_id": "167cdf511ed406a0648a10f33dc791eef3a9b7adc060235666f1ef65c285bb62",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_length.c",
  "human_readable_source": "\n \n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ipv6.h>\n#include <net/ip.h>\n\n#include <linux/netfilter/xt_length.h>\n#include <linux/netfilter/x_tables.h>\n\nMODULE_AUTHOR(\"James Morris <jmorris@intercode.com.au>\");\nMODULE_DESCRIPTION(\"Xtables: Packet length (Layer3,4,5) match\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_length\");\nMODULE_ALIAS(\"ip6t_length\");\n\nstatic bool\nlength_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_length_info *info = par->matchinfo;\n\tu32 pktlen = skb_ip_totlen(skb);\n\n\treturn (pktlen >= info->min && pktlen <= info->max) ^ info->invert;\n}\n\nstatic bool\nlength_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_length_info *info = par->matchinfo;\n\tu32 pktlen = skb->len;\n\n\treturn (pktlen >= info->min && pktlen <= info->max) ^ info->invert;\n}\n\nstatic struct xt_match length_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"length\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.match\t\t= length_mt,\n\t\t.matchsize\t= sizeof(struct xt_length_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"length\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.match\t\t= length_mt6,\n\t\t.matchsize\t= sizeof(struct xt_length_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init length_mt_init(void)\n{\n\treturn xt_register_matches(length_mt_reg, ARRAY_SIZE(length_mt_reg));\n}\n\nstatic void __exit length_mt_exit(void)\n{\n\txt_unregister_matches(length_mt_reg, ARRAY_SIZE(length_mt_reg));\n}\n\nmodule_init(length_mt_init);\nmodule_exit(length_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}