{
  "module_name": "nfnetlink_cthelper.c",
  "hash_id": "c77a437d0a3ebc3ac5862046d4a3bfb48aa012388851e0eec4647c92cd27ffcb",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nfnetlink_cthelper.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/netlink.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_conntrack.h>\n#include <linux/netfilter/nfnetlink_cthelper.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_DESCRIPTION(\"nfnl_cthelper: User-space connection tracking helpers\");\n\nstruct nfnl_cthelper {\n\tstruct list_head\t\tlist;\n\tstruct nf_conntrack_helper\thelper;\n};\n\nstatic LIST_HEAD(nfnl_cthelper_list);\n\nstatic int\nnfnl_userspace_cthelper(struct sk_buff *skb, unsigned int protoff,\n\t\t\tstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\n{\n\tconst struct nf_conn_help *help;\n\tstruct nf_conntrack_helper *helper;\n\n\thelp = nfct_help(ct);\n\tif (help == NULL)\n\t\treturn NF_DROP;\n\n\t \n\thelper = rcu_dereference(help->helper);\n\tif (helper == NULL)\n\t\treturn NF_DROP;\n\n\t \n\tif ((helper->flags &\n\t    (NF_CT_HELPER_F_USERSPACE | NF_CT_HELPER_F_CONFIGURED)) ==\n\t     NF_CT_HELPER_F_USERSPACE)\n\t\treturn NF_ACCEPT;\n\n\t \n\treturn NF_QUEUE_NR(helper->queue_num) | NF_VERDICT_FLAG_QUEUE_BYPASS;\n}\n\nstatic const struct nla_policy nfnl_cthelper_tuple_pol[NFCTH_TUPLE_MAX+1] = {\n\t[NFCTH_TUPLE_L3PROTONUM] = { .type = NLA_U16, },\n\t[NFCTH_TUPLE_L4PROTONUM] = { .type = NLA_U8, },\n};\n\nstatic int\nnfnl_cthelper_parse_tuple(struct nf_conntrack_tuple *tuple,\n\t\t\t  const struct nlattr *attr)\n{\n\tint err;\n\tstruct nlattr *tb[NFCTH_TUPLE_MAX+1];\n\n\terr = nla_parse_nested_deprecated(tb, NFCTH_TUPLE_MAX, attr,\n\t\t\t\t\t  nfnl_cthelper_tuple_pol, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFCTH_TUPLE_L3PROTONUM] || !tb[NFCTH_TUPLE_L4PROTONUM])\n\t\treturn -EINVAL;\n\n\t \n\tmemset(tuple, 0, sizeof(struct nf_conntrack_tuple));\n\n\ttuple->src.l3num = ntohs(nla_get_be16(tb[NFCTH_TUPLE_L3PROTONUM]));\n\ttuple->dst.protonum = nla_get_u8(tb[NFCTH_TUPLE_L4PROTONUM]);\n\n\treturn 0;\n}\n\nstatic int\nnfnl_cthelper_from_nlattr(struct nlattr *attr, struct nf_conn *ct)\n{\n\tstruct nf_conn_help *help = nfct_help(ct);\n\tconst struct nf_conntrack_helper *helper;\n\n\tif (attr == NULL)\n\t\treturn -EINVAL;\n\n\thelper = rcu_dereference(help->helper);\n\tif (!helper || helper->data_len == 0)\n\t\treturn -EINVAL;\n\n\tnla_memcpy(help->data, attr, sizeof(help->data));\n\treturn 0;\n}\n\nstatic int\nnfnl_cthelper_to_nlattr(struct sk_buff *skb, const struct nf_conn *ct)\n{\n\tconst struct nf_conn_help *help = nfct_help(ct);\n\tconst struct nf_conntrack_helper *helper;\n\n\thelper = rcu_dereference(help->helper);\n\tif (helper && helper->data_len &&\n\t    nla_put(skb, CTA_HELP_INFO, helper->data_len, &help->data))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic const struct nla_policy nfnl_cthelper_expect_pol[NFCTH_POLICY_MAX+1] = {\n\t[NFCTH_POLICY_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t.len = NF_CT_HELPER_NAME_LEN-1 },\n\t[NFCTH_POLICY_EXPECT_MAX] = { .type = NLA_U32, },\n\t[NFCTH_POLICY_EXPECT_TIMEOUT] = { .type = NLA_U32, },\n};\n\nstatic int\nnfnl_cthelper_expect_policy(struct nf_conntrack_expect_policy *expect_policy,\n\t\t\t    const struct nlattr *attr)\n{\n\tint err;\n\tstruct nlattr *tb[NFCTH_POLICY_MAX+1];\n\n\terr = nla_parse_nested_deprecated(tb, NFCTH_POLICY_MAX, attr,\n\t\t\t\t\t  nfnl_cthelper_expect_pol, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFCTH_POLICY_NAME] ||\n\t    !tb[NFCTH_POLICY_EXPECT_MAX] ||\n\t    !tb[NFCTH_POLICY_EXPECT_TIMEOUT])\n\t\treturn -EINVAL;\n\n\tnla_strscpy(expect_policy->name,\n\t\t    tb[NFCTH_POLICY_NAME], NF_CT_HELPER_NAME_LEN);\n\texpect_policy->max_expected =\n\t\tntohl(nla_get_be32(tb[NFCTH_POLICY_EXPECT_MAX]));\n\tif (expect_policy->max_expected > NF_CT_EXPECT_MAX_CNT)\n\t\treturn -EINVAL;\n\n\texpect_policy->timeout =\n\t\tntohl(nla_get_be32(tb[NFCTH_POLICY_EXPECT_TIMEOUT]));\n\n\treturn 0;\n}\n\nstatic const struct nla_policy\nnfnl_cthelper_expect_policy_set[NFCTH_POLICY_SET_MAX+1] = {\n\t[NFCTH_POLICY_SET_NUM] = { .type = NLA_U32, },\n};\n\nstatic int\nnfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,\n\t\t\t\t  const struct nlattr *attr)\n{\n\tint i, ret;\n\tstruct nf_conntrack_expect_policy *expect_policy;\n\tstruct nlattr *tb[NFCTH_POLICY_SET_MAX+1];\n\tunsigned int class_max;\n\n\tret = nla_parse_nested_deprecated(tb, NFCTH_POLICY_SET_MAX, attr,\n\t\t\t\t\t  nfnl_cthelper_expect_policy_set,\n\t\t\t\t\t  NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!tb[NFCTH_POLICY_SET_NUM])\n\t\treturn -EINVAL;\n\n\tclass_max = ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));\n\tif (class_max == 0)\n\t\treturn -EINVAL;\n\tif (class_max > NF_CT_MAX_EXPECT_CLASSES)\n\t\treturn -EOVERFLOW;\n\n\texpect_policy = kcalloc(class_max,\n\t\t\t\tsizeof(struct nf_conntrack_expect_policy),\n\t\t\t\tGFP_KERNEL);\n\tif (expect_policy == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < class_max; i++) {\n\t\tif (!tb[NFCTH_POLICY_SET+i])\n\t\t\tgoto err;\n\n\t\tret = nfnl_cthelper_expect_policy(&expect_policy[i],\n\t\t\t\t\t\t  tb[NFCTH_POLICY_SET+i]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\thelper->expect_class_max = class_max - 1;\n\thelper->expect_policy = expect_policy;\n\treturn 0;\nerr:\n\tkfree(expect_policy);\n\treturn -EINVAL;\n}\n\nstatic int\nnfnl_cthelper_create(const struct nlattr * const tb[],\n\t\t     struct nf_conntrack_tuple *tuple)\n{\n\tstruct nf_conntrack_helper *helper;\n\tstruct nfnl_cthelper *nfcth;\n\tunsigned int size;\n\tint ret;\n\n\tif (!tb[NFCTH_TUPLE] || !tb[NFCTH_POLICY] || !tb[NFCTH_PRIV_DATA_LEN])\n\t\treturn -EINVAL;\n\n\tnfcth = kzalloc(sizeof(*nfcth), GFP_KERNEL);\n\tif (nfcth == NULL)\n\t\treturn -ENOMEM;\n\thelper = &nfcth->helper;\n\n\tret = nfnl_cthelper_parse_expect_policy(helper, tb[NFCTH_POLICY]);\n\tif (ret < 0)\n\t\tgoto err1;\n\n\tnla_strscpy(helper->name,\n\t\t    tb[NFCTH_NAME], NF_CT_HELPER_NAME_LEN);\n\tsize = ntohl(nla_get_be32(tb[NFCTH_PRIV_DATA_LEN]));\n\tif (size > sizeof_field(struct nf_conn_help, data)) {\n\t\tret = -ENOMEM;\n\t\tgoto err2;\n\t}\n\thelper->data_len = size;\n\n\thelper->flags |= NF_CT_HELPER_F_USERSPACE;\n\tmemcpy(&helper->tuple, tuple, sizeof(struct nf_conntrack_tuple));\n\n\thelper->me = THIS_MODULE;\n\thelper->help = nfnl_userspace_cthelper;\n\thelper->from_nlattr = nfnl_cthelper_from_nlattr;\n\thelper->to_nlattr = nfnl_cthelper_to_nlattr;\n\n\t \n\tif (tb[NFCTH_QUEUE_NUM])\n\t\thelper->queue_num = ntohl(nla_get_be32(tb[NFCTH_QUEUE_NUM]));\n\n\tif (tb[NFCTH_STATUS]) {\n\t\tint status = ntohl(nla_get_be32(tb[NFCTH_STATUS]));\n\n\t\tswitch(status) {\n\t\tcase NFCT_HELPER_STATUS_ENABLED:\n\t\t\thelper->flags |= NF_CT_HELPER_F_CONFIGURED;\n\t\t\tbreak;\n\t\tcase NFCT_HELPER_STATUS_DISABLED:\n\t\t\thelper->flags &= ~NF_CT_HELPER_F_CONFIGURED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = nf_conntrack_helper_register(helper);\n\tif (ret < 0)\n\t\tgoto err2;\n\n\tlist_add_tail(&nfcth->list, &nfnl_cthelper_list);\n\treturn 0;\nerr2:\n\tkfree(helper->expect_policy);\nerr1:\n\tkfree(nfcth);\n\treturn ret;\n}\n\nstatic int\nnfnl_cthelper_update_policy_one(const struct nf_conntrack_expect_policy *policy,\n\t\t\t\tstruct nf_conntrack_expect_policy *new_policy,\n\t\t\t\tconst struct nlattr *attr)\n{\n\tstruct nlattr *tb[NFCTH_POLICY_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFCTH_POLICY_MAX, attr,\n\t\t\t\t\t  nfnl_cthelper_expect_pol, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFCTH_POLICY_NAME] ||\n\t    !tb[NFCTH_POLICY_EXPECT_MAX] ||\n\t    !tb[NFCTH_POLICY_EXPECT_TIMEOUT])\n\t\treturn -EINVAL;\n\n\tif (nla_strcmp(tb[NFCTH_POLICY_NAME], policy->name))\n\t\treturn -EBUSY;\n\n\tnew_policy->max_expected =\n\t\tntohl(nla_get_be32(tb[NFCTH_POLICY_EXPECT_MAX]));\n\tif (new_policy->max_expected > NF_CT_EXPECT_MAX_CNT)\n\t\treturn -EINVAL;\n\n\tnew_policy->timeout =\n\t\tntohl(nla_get_be32(tb[NFCTH_POLICY_EXPECT_TIMEOUT]));\n\n\treturn 0;\n}\n\nstatic int nfnl_cthelper_update_policy_all(struct nlattr *tb[],\n\t\t\t\t\t   struct nf_conntrack_helper *helper)\n{\n\tstruct nf_conntrack_expect_policy *new_policy;\n\tstruct nf_conntrack_expect_policy *policy;\n\tint i, ret = 0;\n\n\tnew_policy = kmalloc_array(helper->expect_class_max + 1,\n\t\t\t\t   sizeof(*new_policy), GFP_KERNEL);\n\tif (!new_policy)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < helper->expect_class_max + 1; i++) {\n\n\t\tif (!tb[NFCTH_POLICY_SET + i]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = nfnl_cthelper_update_policy_one(&helper->expect_policy[i],\n\t\t\t\t\t\t      &new_policy[i],\n\t\t\t\t\t\t      tb[NFCTH_POLICY_SET + i]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\t \n\tfor (i = 0; i < helper->expect_class_max + 1; i++) {\n\t\tpolicy = (struct nf_conntrack_expect_policy *)\n\t\t\t\t&helper->expect_policy[i];\n\t\tpolicy->max_expected = new_policy->max_expected;\n\t\tpolicy->timeout\t= new_policy->timeout;\n\t}\n\nerr:\n\tkfree(new_policy);\n\treturn ret;\n}\n\nstatic int nfnl_cthelper_update_policy(struct nf_conntrack_helper *helper,\n\t\t\t\t       const struct nlattr *attr)\n{\n\tstruct nlattr *tb[NFCTH_POLICY_SET_MAX + 1];\n\tunsigned int class_max;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFCTH_POLICY_SET_MAX, attr,\n\t\t\t\t\t  nfnl_cthelper_expect_policy_set,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFCTH_POLICY_SET_NUM])\n\t\treturn -EINVAL;\n\n\tclass_max = ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));\n\tif (helper->expect_class_max + 1 != class_max)\n\t\treturn -EBUSY;\n\n\treturn nfnl_cthelper_update_policy_all(tb, helper);\n}\n\nstatic int\nnfnl_cthelper_update(const struct nlattr * const tb[],\n\t\t     struct nf_conntrack_helper *helper)\n{\n\tu32 size;\n\tint ret;\n\n\tif (tb[NFCTH_PRIV_DATA_LEN]) {\n\t\tsize = ntohl(nla_get_be32(tb[NFCTH_PRIV_DATA_LEN]));\n\t\tif (size != helper->data_len)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (tb[NFCTH_POLICY]) {\n\t\tret = nfnl_cthelper_update_policy(helper, tb[NFCTH_POLICY]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tif (tb[NFCTH_QUEUE_NUM])\n\t\thelper->queue_num = ntohl(nla_get_be32(tb[NFCTH_QUEUE_NUM]));\n\n\tif (tb[NFCTH_STATUS]) {\n\t\tint status = ntohl(nla_get_be32(tb[NFCTH_STATUS]));\n\n\t\tswitch(status) {\n\t\tcase NFCT_HELPER_STATUS_ENABLED:\n\t\t\thelper->flags |= NF_CT_HELPER_F_CONFIGURED;\n\t\t\tbreak;\n\t\tcase NFCT_HELPER_STATUS_DISABLED:\n\t\t\thelper->flags &= ~NF_CT_HELPER_F_CONFIGURED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int nfnl_cthelper_new(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const tb[])\n{\n\tconst char *helper_name;\n\tstruct nf_conntrack_helper *cur, *helper = NULL;\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nfnl_cthelper *nlcth;\n\tint ret = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!tb[NFCTH_NAME] || !tb[NFCTH_TUPLE])\n\t\treturn -EINVAL;\n\n\thelper_name = nla_data(tb[NFCTH_NAME]);\n\n\tret = nfnl_cthelper_parse_tuple(&tuple, tb[NFCTH_TUPLE]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_for_each_entry(nlcth, &nfnl_cthelper_list, list) {\n\t\tcur = &nlcth->helper;\n\n\t\tif (strncmp(cur->name, helper_name, NF_CT_HELPER_NAME_LEN))\n\t\t\tcontinue;\n\n\t\tif ((tuple.src.l3num != cur->tuple.src.l3num ||\n\t\t     tuple.dst.protonum != cur->tuple.dst.protonum))\n\t\t\tcontinue;\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL)\n\t\t\treturn -EEXIST;\n\n\t\thelper = cur;\n\t\tbreak;\n\t}\n\n\tif (helper == NULL)\n\t\tret = nfnl_cthelper_create(tb, &tuple);\n\telse\n\t\tret = nfnl_cthelper_update(tb, helper);\n\n\treturn ret;\n}\n\nstatic int\nnfnl_cthelper_dump_tuple(struct sk_buff *skb,\n\t\t\t struct nf_conntrack_helper *helper)\n{\n\tstruct nlattr *nest_parms;\n\n\tnest_parms = nla_nest_start(skb, NFCTH_TUPLE);\n\tif (nest_parms == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be16(skb, NFCTH_TUPLE_L3PROTONUM,\n\t\t\t htons(helper->tuple.src.l3num)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, NFCTH_TUPLE_L4PROTONUM, helper->tuple.dst.protonum))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest_parms);\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int\nnfnl_cthelper_dump_policy(struct sk_buff *skb,\n\t\t\tstruct nf_conntrack_helper *helper)\n{\n\tint i;\n\tstruct nlattr *nest_parms1, *nest_parms2;\n\n\tnest_parms1 = nla_nest_start(skb, NFCTH_POLICY);\n\tif (nest_parms1 == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFCTH_POLICY_SET_NUM,\n\t\t\t htonl(helper->expect_class_max + 1)))\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < helper->expect_class_max + 1; i++) {\n\t\tnest_parms2 = nla_nest_start(skb, (NFCTH_POLICY_SET + i));\n\t\tif (nest_parms2 == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_string(skb, NFCTH_POLICY_NAME,\n\t\t\t\t   helper->expect_policy[i].name))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_be32(skb, NFCTH_POLICY_EXPECT_MAX,\n\t\t\t\t htonl(helper->expect_policy[i].max_expected)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_be32(skb, NFCTH_POLICY_EXPECT_TIMEOUT,\n\t\t\t\t htonl(helper->expect_policy[i].timeout)))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, nest_parms2);\n\t}\n\tnla_nest_end(skb, nest_parms1);\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int\nnfnl_cthelper_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\n\t\t\tint event, struct nf_conntrack_helper *helper)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned int flags = portid ? NLM_F_MULTI : 0;\n\tint status;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_CTHELPER, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, AF_UNSPEC,\n\t\t\t   NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tif (nla_put_string(skb, NFCTH_NAME, helper->name))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFCTH_QUEUE_NUM, htonl(helper->queue_num)))\n\t\tgoto nla_put_failure;\n\n\tif (nfnl_cthelper_dump_tuple(skb, helper) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nfnl_cthelper_dump_policy(skb, helper) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, NFCTH_PRIV_DATA_LEN, htonl(helper->data_len)))\n\t\tgoto nla_put_failure;\n\n\tif (helper->flags & NF_CT_HELPER_F_CONFIGURED)\n\t\tstatus = NFCT_HELPER_STATUS_ENABLED;\n\telse\n\t\tstatus = NFCT_HELPER_STATUS_DISABLED;\n\n\tif (nla_put_be32(skb, NFCTH_STATUS, htonl(status)))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -1;\n}\n\nstatic int\nnfnl_cthelper_dump_table(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nf_conntrack_helper *cur, *last;\n\n\trcu_read_lock();\n\tlast = (struct nf_conntrack_helper *)cb->args[1];\n\tfor (; cb->args[0] < nf_ct_helper_hsize; cb->args[0]++) {\nrestart:\n\t\thlist_for_each_entry_rcu(cur,\n\t\t\t\t&nf_ct_helper_hash[cb->args[0]], hnode) {\n\n\t\t\t \n\t\t\tif (!(cur->flags & NF_CT_HELPER_F_USERSPACE))\n\t\t\t\tcontinue;\n\n\t\t\tif (cb->args[1]) {\n\t\t\t\tif (cur != last)\n\t\t\t\t\tcontinue;\n\t\t\t\tcb->args[1] = 0;\n\t\t\t}\n\t\t\tif (nfnl_cthelper_fill_info(skb,\n\t\t\t\t\t    NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t    NFNL_MSG_TYPE(cb->nlh->nlmsg_type),\n\t\t\t\t\t    NFNL_MSG_CTHELPER_NEW, cur) < 0) {\n\t\t\t\tcb->args[1] = (unsigned long)cur;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif (cb->args[1]) {\n\t\tcb->args[1] = 0;\n\t\tgoto restart;\n\t}\nout:\n\trcu_read_unlock();\n\treturn skb->len;\n}\n\nstatic int nfnl_cthelper_get(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const tb[])\n{\n\tint ret = -ENOENT;\n\tstruct nf_conntrack_helper *cur;\n\tstruct sk_buff *skb2;\n\tchar *helper_name = NULL;\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nfnl_cthelper *nlcth;\n\tbool tuple_set = false;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = nfnl_cthelper_dump_table,\n\t\t};\n\t\treturn netlink_dump_start(info->sk, skb, info->nlh, &c);\n\t}\n\n\tif (tb[NFCTH_NAME])\n\t\thelper_name = nla_data(tb[NFCTH_NAME]);\n\n\tif (tb[NFCTH_TUPLE]) {\n\t\tret = nfnl_cthelper_parse_tuple(&tuple, tb[NFCTH_TUPLE]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttuple_set = true;\n\t}\n\n\tlist_for_each_entry(nlcth, &nfnl_cthelper_list, list) {\n\t\tcur = &nlcth->helper;\n\t\tif (helper_name &&\n\t\t    strncmp(cur->name, helper_name, NF_CT_HELPER_NAME_LEN))\n\t\t\tcontinue;\n\n\t\tif (tuple_set &&\n\t\t    (tuple.src.l3num != cur->tuple.src.l3num ||\n\t\t     tuple.dst.protonum != cur->tuple.dst.protonum))\n\t\t\tcontinue;\n\n\t\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (skb2 == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = nfnl_cthelper_fill_info(skb2, NETLINK_CB(skb).portid,\n\t\t\t\t\t      info->nlh->nlmsg_seq,\n\t\t\t\t\t      NFNL_MSG_TYPE(info->nlh->nlmsg_type),\n\t\t\t\t\t      NFNL_MSG_CTHELPER_NEW, cur);\n\t\tif (ret <= 0) {\n\t\t\tkfree_skb(skb2);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int nfnl_cthelper_del(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const tb[])\n{\n\tchar *helper_name = NULL;\n\tstruct nf_conntrack_helper *cur;\n\tstruct nf_conntrack_tuple tuple;\n\tbool tuple_set = false, found = false;\n\tstruct nfnl_cthelper *nlcth, *n;\n\tint j = 0, ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (tb[NFCTH_NAME])\n\t\thelper_name = nla_data(tb[NFCTH_NAME]);\n\n\tif (tb[NFCTH_TUPLE]) {\n\t\tret = nfnl_cthelper_parse_tuple(&tuple, tb[NFCTH_TUPLE]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttuple_set = true;\n\t}\n\n\tret = -ENOENT;\n\tlist_for_each_entry_safe(nlcth, n, &nfnl_cthelper_list, list) {\n\t\tcur = &nlcth->helper;\n\t\tj++;\n\n\t\tif (helper_name &&\n\t\t    strncmp(cur->name, helper_name, NF_CT_HELPER_NAME_LEN))\n\t\t\tcontinue;\n\n\t\tif (tuple_set &&\n\t\t    (tuple.src.l3num != cur->tuple.src.l3num ||\n\t\t     tuple.dst.protonum != cur->tuple.dst.protonum))\n\t\t\tcontinue;\n\n\t\tif (refcount_dec_if_one(&cur->refcnt)) {\n\t\t\tfound = true;\n\t\t\tnf_conntrack_helper_unregister(cur);\n\t\t\tkfree(cur->expect_policy);\n\n\t\t\tlist_del(&nlcth->list);\n\t\t\tkfree(nlcth);\n\t\t} else {\n\t\t\tret = -EBUSY;\n\t\t}\n\t}\n\n\t \n\treturn (found || j == 0) ? 0 : ret;\n}\n\nstatic const struct nla_policy nfnl_cthelper_policy[NFCTH_MAX+1] = {\n\t[NFCTH_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t .len = NF_CT_HELPER_NAME_LEN-1 },\n\t[NFCTH_QUEUE_NUM] = { .type = NLA_U32, },\n\t[NFCTH_PRIV_DATA_LEN] = { .type = NLA_U32, },\n\t[NFCTH_STATUS] = { .type = NLA_U32, },\n};\n\nstatic const struct nfnl_callback nfnl_cthelper_cb[NFNL_MSG_CTHELPER_MAX] = {\n\t[NFNL_MSG_CTHELPER_NEW]\t= {\n\t\t.call\t\t= nfnl_cthelper_new,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= NFCTH_MAX,\n\t\t.policy\t\t= nfnl_cthelper_policy\n\t},\n\t[NFNL_MSG_CTHELPER_GET] = {\n\t\t.call\t\t= nfnl_cthelper_get,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= NFCTH_MAX,\n\t\t.policy\t\t= nfnl_cthelper_policy\n\t},\n\t[NFNL_MSG_CTHELPER_DEL]\t= {\n\t\t.call\t\t= nfnl_cthelper_del,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= NFCTH_MAX,\n\t\t.policy\t\t= nfnl_cthelper_policy\n\t},\n};\n\nstatic const struct nfnetlink_subsystem nfnl_cthelper_subsys = {\n\t.name\t\t\t\t= \"cthelper\",\n\t.subsys_id\t\t\t= NFNL_SUBSYS_CTHELPER,\n\t.cb_count\t\t\t= NFNL_MSG_CTHELPER_MAX,\n\t.cb\t\t\t\t= nfnl_cthelper_cb,\n};\n\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_CTHELPER);\n\nstatic int __init nfnl_cthelper_init(void)\n{\n\tint ret;\n\n\tret = nfnetlink_subsys_register(&nfnl_cthelper_subsys);\n\tif (ret < 0) {\n\t\tpr_err(\"nfnl_cthelper: cannot register with nfnetlink.\\n\");\n\t\tgoto err_out;\n\t}\n\treturn 0;\nerr_out:\n\treturn ret;\n}\n\nstatic void __exit nfnl_cthelper_exit(void)\n{\n\tstruct nf_conntrack_helper *cur;\n\tstruct nfnl_cthelper *nlcth, *n;\n\n\tnfnetlink_subsys_unregister(&nfnl_cthelper_subsys);\n\n\tlist_for_each_entry_safe(nlcth, n, &nfnl_cthelper_list, list) {\n\t\tcur = &nlcth->helper;\n\n\t\tnf_conntrack_helper_unregister(cur);\n\t\tkfree(cur->expect_policy);\n\t\tkfree(nlcth);\n\t}\n}\n\nmodule_init(nfnl_cthelper_init);\nmodule_exit(nfnl_cthelper_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}