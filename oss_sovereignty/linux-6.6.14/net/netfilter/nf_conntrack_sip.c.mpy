{
  "module_name": "nf_conntrack_sip.c",
  "hash_id": "a0ce1934c1e6c732154faa673449bbaa766229e9d4b4888a5eeee78a50f63e7a",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_sip.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/skbuff.h>\n#include <linux/inet.h>\n#include <linux/in.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <linux/netfilter/nf_conntrack_sip.h>\n\n#define HELPER_NAME \"sip\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Christian Hentschel <chentschel@arnet.com.ar>\");\nMODULE_DESCRIPTION(\"SIP connection tracking helper\");\nMODULE_ALIAS(\"ip_conntrack_sip\");\nMODULE_ALIAS_NFCT_HELPER(HELPER_NAME);\n\n#define MAX_PORTS\t8\nstatic unsigned short ports[MAX_PORTS];\nstatic unsigned int ports_c;\nmodule_param_array(ports, ushort, &ports_c, 0400);\nMODULE_PARM_DESC(ports, \"port numbers of SIP servers\");\n\nstatic unsigned int sip_timeout __read_mostly = SIP_TIMEOUT;\nmodule_param(sip_timeout, uint, 0600);\nMODULE_PARM_DESC(sip_timeout, \"timeout for the master SIP session\");\n\nstatic int sip_direct_signalling __read_mostly = 1;\nmodule_param(sip_direct_signalling, int, 0600);\nMODULE_PARM_DESC(sip_direct_signalling, \"expect incoming calls from registrar \"\n\t\t\t\t\t\"only (default 1)\");\n\nstatic int sip_direct_media __read_mostly = 1;\nmodule_param(sip_direct_media, int, 0600);\nMODULE_PARM_DESC(sip_direct_media, \"Expect Media streams between signalling \"\n\t\t\t\t   \"endpoints only (default 1)\");\n\nstatic int sip_external_media __read_mostly = 0;\nmodule_param(sip_external_media, int, 0600);\nMODULE_PARM_DESC(sip_external_media, \"Expect Media streams between external \"\n\t\t\t\t     \"endpoints (default 0)\");\n\nconst struct nf_nat_sip_hooks __rcu *nf_nat_sip_hooks;\nEXPORT_SYMBOL_GPL(nf_nat_sip_hooks);\n\nstatic int string_len(const struct nf_conn *ct, const char *dptr,\n\t\t      const char *limit, int *shift)\n{\n\tint len = 0;\n\n\twhile (dptr < limit && isalpha(*dptr)) {\n\t\tdptr++;\n\t\tlen++;\n\t}\n\treturn len;\n}\n\nstatic int digits_len(const struct nf_conn *ct, const char *dptr,\n\t\t      const char *limit, int *shift)\n{\n\tint len = 0;\n\twhile (dptr < limit && isdigit(*dptr)) {\n\t\tdptr++;\n\t\tlen++;\n\t}\n\treturn len;\n}\n\nstatic int iswordc(const char c)\n{\n\tif (isalnum(c) || c == '!' || c == '\"' || c == '%' ||\n\t    (c >= '(' && c <= '+') || c == ':' || c == '<' || c == '>' ||\n\t    c == '?' || (c >= '[' && c <= ']') || c == '_' || c == '`' ||\n\t    c == '{' || c == '}' || c == '~' || (c >= '-' && c <= '/') ||\n\t    c == '\\'')\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int word_len(const char *dptr, const char *limit)\n{\n\tint len = 0;\n\twhile (dptr < limit && iswordc(*dptr)) {\n\t\tdptr++;\n\t\tlen++;\n\t}\n\treturn len;\n}\n\nstatic int callid_len(const struct nf_conn *ct, const char *dptr,\n\t\t      const char *limit, int *shift)\n{\n\tint len, domain_len;\n\n\tlen = word_len(dptr, limit);\n\tdptr += len;\n\tif (!len || dptr == limit || *dptr != '@')\n\t\treturn len;\n\tdptr++;\n\tlen++;\n\n\tdomain_len = word_len(dptr, limit);\n\tif (!domain_len)\n\t\treturn 0;\n\treturn len + domain_len;\n}\n\n \nstatic int media_len(const struct nf_conn *ct, const char *dptr,\n\t\t     const char *limit, int *shift)\n{\n\tint len = string_len(ct, dptr, limit, shift);\n\n\tdptr += len;\n\tif (dptr >= limit || *dptr != ' ')\n\t\treturn 0;\n\tlen++;\n\tdptr++;\n\n\treturn len + digits_len(ct, dptr, limit, shift);\n}\n\nstatic int sip_parse_addr(const struct nf_conn *ct, const char *cp,\n\t\t\t  const char **endp, union nf_inet_addr *addr,\n\t\t\t  const char *limit, bool delim)\n{\n\tconst char *end;\n\tint ret;\n\n\tif (!ct)\n\t\treturn 0;\n\n\tmemset(addr, 0, sizeof(*addr));\n\tswitch (nf_ct_l3num(ct)) {\n\tcase AF_INET:\n\t\tret = in4_pton(cp, limit - cp, (u8 *)&addr->ip, -1, &end);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (cp < limit && *cp == '[')\n\t\t\tcp++;\n\t\telse if (delim)\n\t\t\treturn 0;\n\n\t\tret = in6_pton(cp, limit - cp, (u8 *)&addr->ip6, -1, &end);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\n\t\tif (end < limit && *end == ']')\n\t\t\tend++;\n\t\telse if (delim)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (endp)\n\t\t*endp = end;\n\treturn 1;\n}\n\n \nstatic int epaddr_len(const struct nf_conn *ct, const char *dptr,\n\t\t      const char *limit, int *shift)\n{\n\tunion nf_inet_addr addr;\n\tconst char *aux = dptr;\n\n\tif (!sip_parse_addr(ct, dptr, &dptr, &addr, limit, true)) {\n\t\tpr_debug(\"ip: %s parse failed.!\\n\", dptr);\n\t\treturn 0;\n\t}\n\n\t \n\tif (*dptr == ':') {\n\t\tdptr++;\n\t\tdptr += digits_len(ct, dptr, limit, shift);\n\t}\n\treturn dptr - aux;\n}\n\n \nstatic int skp_epaddr_len(const struct nf_conn *ct, const char *dptr,\n\t\t\t  const char *limit, int *shift)\n{\n\tconst char *start = dptr;\n\tint s = *shift;\n\n\t \n\twhile (dptr < limit &&\n\t       *dptr != '@' && *dptr != '\\r' && *dptr != '\\n') {\n\t\t(*shift)++;\n\t\tdptr++;\n\t}\n\n\tif (dptr < limit && *dptr == '@') {\n\t\tdptr++;\n\t\t(*shift)++;\n\t} else {\n\t\tdptr = start;\n\t\t*shift = s;\n\t}\n\n\treturn epaddr_len(ct, dptr, limit, shift);\n}\n\n \nint ct_sip_parse_request(const struct nf_conn *ct,\n\t\t\t const char *dptr, unsigned int datalen,\n\t\t\t unsigned int *matchoff, unsigned int *matchlen,\n\t\t\t union nf_inet_addr *addr, __be16 *port)\n{\n\tconst char *start = dptr, *limit = dptr + datalen, *end;\n\tunsigned int mlen;\n\tunsigned int p;\n\tint shift = 0;\n\n\t \n\tmlen = string_len(ct, dptr, limit, NULL);\n\tif (!mlen)\n\t\treturn 0;\n\tdptr += mlen;\n\tif (++dptr >= limit)\n\t\treturn 0;\n\n\t \n\tfor (; dptr < limit - strlen(\"sip:\"); dptr++) {\n\t\tif (*dptr == '\\r' || *dptr == '\\n')\n\t\t\treturn -1;\n\t\tif (strncasecmp(dptr, \"sip:\", strlen(\"sip:\")) == 0) {\n\t\t\tdptr += strlen(\"sip:\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!skp_epaddr_len(ct, dptr, limit, &shift))\n\t\treturn 0;\n\tdptr += shift;\n\n\tif (!sip_parse_addr(ct, dptr, &end, addr, limit, true))\n\t\treturn -1;\n\tif (end < limit && *end == ':') {\n\t\tend++;\n\t\tp = simple_strtoul(end, (char **)&end, 10);\n\t\tif (p < 1024 || p > 65535)\n\t\t\treturn -1;\n\t\t*port = htons(p);\n\t} else\n\t\t*port = htons(SIP_PORT);\n\n\tif (end == dptr)\n\t\treturn 0;\n\t*matchoff = dptr - start;\n\t*matchlen = end - dptr;\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(ct_sip_parse_request);\n\n \nstatic const struct sip_header ct_sip_hdrs[] = {\n\t[SIP_HDR_CSEQ]\t\t\t= SIP_HDR(\"CSeq\", NULL, NULL, digits_len),\n\t[SIP_HDR_FROM]\t\t\t= SIP_HDR(\"From\", \"f\", \"sip:\", skp_epaddr_len),\n\t[SIP_HDR_TO]\t\t\t= SIP_HDR(\"To\", \"t\", \"sip:\", skp_epaddr_len),\n\t[SIP_HDR_CONTACT]\t\t= SIP_HDR(\"Contact\", \"m\", \"sip:\", skp_epaddr_len),\n\t[SIP_HDR_VIA_UDP]\t\t= SIP_HDR(\"Via\", \"v\", \"UDP \", epaddr_len),\n\t[SIP_HDR_VIA_TCP]\t\t= SIP_HDR(\"Via\", \"v\", \"TCP \", epaddr_len),\n\t[SIP_HDR_EXPIRES]\t\t= SIP_HDR(\"Expires\", NULL, NULL, digits_len),\n\t[SIP_HDR_CONTENT_LENGTH]\t= SIP_HDR(\"Content-Length\", \"l\", NULL, digits_len),\n\t[SIP_HDR_CALL_ID]\t\t= SIP_HDR(\"Call-Id\", \"i\", NULL, callid_len),\n};\n\nstatic const char *sip_follow_continuation(const char *dptr, const char *limit)\n{\n\t \n\tif (++dptr >= limit)\n\t\treturn NULL;\n\n\t \n\tif (*(dptr - 1) == '\\r' && *dptr == '\\n') {\n\t\tif (++dptr >= limit)\n\t\t\treturn NULL;\n\t}\n\n\t \n\tif (*dptr != ' ' && *dptr != '\\t')\n\t\treturn NULL;\n\n\t \n\tfor (; dptr < limit; dptr++) {\n\t\tif (*dptr != ' ' && *dptr != '\\t')\n\t\t\tbreak;\n\t}\n\treturn dptr;\n}\n\nstatic const char *sip_skip_whitespace(const char *dptr, const char *limit)\n{\n\tfor (; dptr < limit; dptr++) {\n\t\tif (*dptr == ' ' || *dptr == '\\t')\n\t\t\tcontinue;\n\t\tif (*dptr != '\\r' && *dptr != '\\n')\n\t\t\tbreak;\n\t\tdptr = sip_follow_continuation(dptr, limit);\n\t\tbreak;\n\t}\n\treturn dptr;\n}\n\n \nstatic const char *ct_sip_header_search(const char *dptr, const char *limit,\n\t\t\t\t\tconst char *needle, unsigned int len)\n{\n\tfor (limit -= len; dptr < limit; dptr++) {\n\t\tif (*dptr == '\\r' || *dptr == '\\n') {\n\t\t\tdptr = sip_follow_continuation(dptr, limit);\n\t\t\tif (dptr == NULL)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strncasecmp(dptr, needle, len) == 0)\n\t\t\treturn dptr;\n\t}\n\treturn NULL;\n}\n\nint ct_sip_get_header(const struct nf_conn *ct, const char *dptr,\n\t\t      unsigned int dataoff, unsigned int datalen,\n\t\t      enum sip_header_types type,\n\t\t      unsigned int *matchoff, unsigned int *matchlen)\n{\n\tconst struct sip_header *hdr = &ct_sip_hdrs[type];\n\tconst char *start = dptr, *limit = dptr + datalen;\n\tint shift = 0;\n\n\tfor (dptr += dataoff; dptr < limit; dptr++) {\n\t\t \n\t\tif (*dptr != '\\r' && *dptr != '\\n')\n\t\t\tcontinue;\n\t\tif (++dptr >= limit)\n\t\t\tbreak;\n\t\tif (*(dptr - 1) == '\\r' && *dptr == '\\n') {\n\t\t\tif (++dptr >= limit)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (*dptr == ' ' || *dptr == '\\t')\n\t\t\tcontinue;\n\n\t\t \n\t\tif (limit - dptr >= hdr->len &&\n\t\t    strncasecmp(dptr, hdr->name, hdr->len) == 0)\n\t\t\tdptr += hdr->len;\n\t\telse if (hdr->cname && limit - dptr >= hdr->clen + 1 &&\n\t\t\t strncasecmp(dptr, hdr->cname, hdr->clen) == 0 &&\n\t\t\t !isalpha(*(dptr + hdr->clen)))\n\t\t\tdptr += hdr->clen;\n\t\telse\n\t\t\tcontinue;\n\n\t\t \n\t\tdptr = sip_skip_whitespace(dptr, limit);\n\t\tif (dptr == NULL)\n\t\t\tbreak;\n\t\tif (*dptr != ':' || ++dptr >= limit)\n\t\t\tbreak;\n\n\t\t \n\t\tdptr = sip_skip_whitespace(dptr, limit);\n\t\tif (dptr == NULL)\n\t\t\tbreak;\n\n\t\t*matchoff = dptr - start;\n\t\tif (hdr->search) {\n\t\t\tdptr = ct_sip_header_search(dptr, limit, hdr->search,\n\t\t\t\t\t\t    hdr->slen);\n\t\t\tif (!dptr)\n\t\t\t\treturn -1;\n\t\t\tdptr += hdr->slen;\n\t\t}\n\n\t\t*matchlen = hdr->match_len(ct, dptr, limit, &shift);\n\t\tif (!*matchlen)\n\t\t\treturn -1;\n\t\t*matchoff = dptr - start + shift;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ct_sip_get_header);\n\n \nstatic int ct_sip_next_header(const struct nf_conn *ct, const char *dptr,\n\t\t\t      unsigned int dataoff, unsigned int datalen,\n\t\t\t      enum sip_header_types type,\n\t\t\t      unsigned int *matchoff, unsigned int *matchlen)\n{\n\tconst struct sip_header *hdr = &ct_sip_hdrs[type];\n\tconst char *start = dptr, *limit = dptr + datalen;\n\tint shift = 0;\n\n\tdptr += dataoff;\n\n\tdptr = ct_sip_header_search(dptr, limit, \",\", strlen(\",\"));\n\tif (!dptr)\n\t\treturn 0;\n\n\tdptr = ct_sip_header_search(dptr, limit, hdr->search, hdr->slen);\n\tif (!dptr)\n\t\treturn 0;\n\tdptr += hdr->slen;\n\n\t*matchoff = dptr - start;\n\t*matchlen = hdr->match_len(ct, dptr, limit, &shift);\n\tif (!*matchlen)\n\t\treturn -1;\n\t*matchoff += shift;\n\treturn 1;\n}\n\n \nstatic int ct_sip_walk_headers(const struct nf_conn *ct, const char *dptr,\n\t\t\t       unsigned int dataoff, unsigned int datalen,\n\t\t\t       enum sip_header_types type, int *in_header,\n\t\t\t       unsigned int *matchoff, unsigned int *matchlen)\n{\n\tint ret;\n\n\tif (in_header && *in_header) {\n\t\twhile (1) {\n\t\t\tret = ct_sip_next_header(ct, dptr, dataoff, datalen,\n\t\t\t\t\t\t type, matchoff, matchlen);\n\t\t\tif (ret > 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tdataoff = *matchoff;\n\t\t}\n\t\t*in_header = 0;\n\t}\n\n\twhile (1) {\n\t\tret = ct_sip_get_header(ct, dptr, dataoff, datalen,\n\t\t\t\t\ttype, matchoff, matchlen);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t\tif (ret == 0)\n\t\t\treturn ret;\n\t\tdataoff = *matchoff;\n\t}\n\n\tif (in_header)\n\t\t*in_header = 1;\n\treturn 1;\n}\n\n \nint ct_sip_parse_header_uri(const struct nf_conn *ct, const char *dptr,\n\t\t\t    unsigned int *dataoff, unsigned int datalen,\n\t\t\t    enum sip_header_types type, int *in_header,\n\t\t\t    unsigned int *matchoff, unsigned int *matchlen,\n\t\t\t    union nf_inet_addr *addr, __be16 *port)\n{\n\tconst char *c, *limit = dptr + datalen;\n\tunsigned int p;\n\tint ret;\n\n\tret = ct_sip_walk_headers(ct, dptr, dataoff ? *dataoff : 0, datalen,\n\t\t\t\t  type, in_header, matchoff, matchlen);\n\tWARN_ON(ret < 0);\n\tif (ret == 0)\n\t\treturn ret;\n\n\tif (!sip_parse_addr(ct, dptr + *matchoff, &c, addr, limit, true))\n\t\treturn -1;\n\tif (*c == ':') {\n\t\tc++;\n\t\tp = simple_strtoul(c, (char **)&c, 10);\n\t\tif (p < 1024 || p > 65535)\n\t\t\treturn -1;\n\t\t*port = htons(p);\n\t} else\n\t\t*port = htons(SIP_PORT);\n\n\tif (dataoff)\n\t\t*dataoff = c - dptr;\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(ct_sip_parse_header_uri);\n\nstatic int ct_sip_parse_param(const struct nf_conn *ct, const char *dptr,\n\t\t\t      unsigned int dataoff, unsigned int datalen,\n\t\t\t      const char *name,\n\t\t\t      unsigned int *matchoff, unsigned int *matchlen)\n{\n\tconst char *limit = dptr + datalen;\n\tconst char *start;\n\tconst char *end;\n\n\tlimit = ct_sip_header_search(dptr + dataoff, limit, \",\", strlen(\",\"));\n\tif (!limit)\n\t\tlimit = dptr + datalen;\n\n\tstart = ct_sip_header_search(dptr + dataoff, limit, name, strlen(name));\n\tif (!start)\n\t\treturn 0;\n\tstart += strlen(name);\n\n\tend = ct_sip_header_search(start, limit, \";\", strlen(\";\"));\n\tif (!end)\n\t\tend = limit;\n\n\t*matchoff = start - dptr;\n\t*matchlen = end - start;\n\treturn 1;\n}\n\n \nint ct_sip_parse_address_param(const struct nf_conn *ct, const char *dptr,\n\t\t\t       unsigned int dataoff, unsigned int datalen,\n\t\t\t       const char *name,\n\t\t\t       unsigned int *matchoff, unsigned int *matchlen,\n\t\t\t       union nf_inet_addr *addr, bool delim)\n{\n\tconst char *limit = dptr + datalen;\n\tconst char *start, *end;\n\n\tlimit = ct_sip_header_search(dptr + dataoff, limit, \",\", strlen(\",\"));\n\tif (!limit)\n\t\tlimit = dptr + datalen;\n\n\tstart = ct_sip_header_search(dptr + dataoff, limit, name, strlen(name));\n\tif (!start)\n\t\treturn 0;\n\n\tstart += strlen(name);\n\tif (!sip_parse_addr(ct, start, &end, addr, limit, delim))\n\t\treturn 0;\n\t*matchoff = start - dptr;\n\t*matchlen = end - start;\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(ct_sip_parse_address_param);\n\n \nint ct_sip_parse_numerical_param(const struct nf_conn *ct, const char *dptr,\n\t\t\t\t unsigned int dataoff, unsigned int datalen,\n\t\t\t\t const char *name,\n\t\t\t\t unsigned int *matchoff, unsigned int *matchlen,\n\t\t\t\t unsigned int *val)\n{\n\tconst char *limit = dptr + datalen;\n\tconst char *start;\n\tchar *end;\n\n\tlimit = ct_sip_header_search(dptr + dataoff, limit, \",\", strlen(\",\"));\n\tif (!limit)\n\t\tlimit = dptr + datalen;\n\n\tstart = ct_sip_header_search(dptr + dataoff, limit, name, strlen(name));\n\tif (!start)\n\t\treturn 0;\n\n\tstart += strlen(name);\n\t*val = simple_strtoul(start, &end, 0);\n\tif (start == end)\n\t\treturn -1;\n\tif (matchoff && matchlen) {\n\t\t*matchoff = start - dptr;\n\t\t*matchlen = end - start;\n\t}\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(ct_sip_parse_numerical_param);\n\nstatic int ct_sip_parse_transport(struct nf_conn *ct, const char *dptr,\n\t\t\t\t  unsigned int dataoff, unsigned int datalen,\n\t\t\t\t  u8 *proto)\n{\n\tunsigned int matchoff, matchlen;\n\n\tif (ct_sip_parse_param(ct, dptr, dataoff, datalen, \"transport=\",\n\t\t\t       &matchoff, &matchlen)) {\n\t\tif (!strncasecmp(dptr + matchoff, \"TCP\", strlen(\"TCP\")))\n\t\t\t*proto = IPPROTO_TCP;\n\t\telse if (!strncasecmp(dptr + matchoff, \"UDP\", strlen(\"UDP\")))\n\t\t\t*proto = IPPROTO_UDP;\n\t\telse\n\t\t\treturn 0;\n\n\t\tif (*proto != nf_ct_protonum(ct))\n\t\t\treturn 0;\n\t} else\n\t\t*proto = nf_ct_protonum(ct);\n\n\treturn 1;\n}\n\nstatic int sdp_parse_addr(const struct nf_conn *ct, const char *cp,\n\t\t\t  const char **endp, union nf_inet_addr *addr,\n\t\t\t  const char *limit)\n{\n\tconst char *end;\n\tint ret;\n\n\tmemset(addr, 0, sizeof(*addr));\n\tswitch (nf_ct_l3num(ct)) {\n\tcase AF_INET:\n\t\tret = in4_pton(cp, limit - cp, (u8 *)&addr->ip, -1, &end);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tret = in6_pton(cp, limit - cp, (u8 *)&addr->ip6, -1, &end);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (ret == 0)\n\t\treturn 0;\n\tif (endp)\n\t\t*endp = end;\n\treturn 1;\n}\n\n \nstatic int sdp_addr_len(const struct nf_conn *ct, const char *dptr,\n\t\t\tconst char *limit, int *shift)\n{\n\tunion nf_inet_addr addr;\n\tconst char *aux = dptr;\n\n\tif (!sdp_parse_addr(ct, dptr, &dptr, &addr, limit)) {\n\t\tpr_debug(\"ip: %s parse failed.!\\n\", dptr);\n\t\treturn 0;\n\t}\n\n\treturn dptr - aux;\n}\n\n \nstatic const struct sip_header ct_sdp_hdrs_v4[] = {\n\t[SDP_HDR_VERSION]\t= SDP_HDR(\"v=\", NULL, digits_len),\n\t[SDP_HDR_OWNER]\t\t= SDP_HDR(\"o=\", \"IN IP4 \", sdp_addr_len),\n\t[SDP_HDR_CONNECTION]\t= SDP_HDR(\"c=\", \"IN IP4 \", sdp_addr_len),\n\t[SDP_HDR_MEDIA]\t\t= SDP_HDR(\"m=\", NULL, media_len),\n};\n\nstatic const struct sip_header ct_sdp_hdrs_v6[] = {\n\t[SDP_HDR_VERSION]\t= SDP_HDR(\"v=\", NULL, digits_len),\n\t[SDP_HDR_OWNER]\t\t= SDP_HDR(\"o=\", \"IN IP6 \", sdp_addr_len),\n\t[SDP_HDR_CONNECTION]\t= SDP_HDR(\"c=\", \"IN IP6 \", sdp_addr_len),\n\t[SDP_HDR_MEDIA]\t\t= SDP_HDR(\"m=\", NULL, media_len),\n};\n\n \nstatic const char *ct_sdp_header_search(const char *dptr, const char *limit,\n\t\t\t\t\tconst char *needle, unsigned int len)\n{\n\tfor (limit -= len; dptr < limit; dptr++) {\n\t\tif (*dptr == '\\r' || *dptr == '\\n')\n\t\t\tbreak;\n\t\tif (strncmp(dptr, needle, len) == 0)\n\t\t\treturn dptr;\n\t}\n\treturn NULL;\n}\n\n \nint ct_sip_get_sdp_header(const struct nf_conn *ct, const char *dptr,\n\t\t\t  unsigned int dataoff, unsigned int datalen,\n\t\t\t  enum sdp_header_types type,\n\t\t\t  enum sdp_header_types term,\n\t\t\t  unsigned int *matchoff, unsigned int *matchlen)\n{\n\tconst struct sip_header *hdrs, *hdr, *thdr;\n\tconst char *start = dptr, *limit = dptr + datalen;\n\tint shift = 0;\n\n\thdrs = nf_ct_l3num(ct) == NFPROTO_IPV4 ? ct_sdp_hdrs_v4 : ct_sdp_hdrs_v6;\n\thdr = &hdrs[type];\n\tthdr = &hdrs[term];\n\n\tfor (dptr += dataoff; dptr < limit; dptr++) {\n\t\t \n\t\tif (*dptr != '\\r' && *dptr != '\\n')\n\t\t\tcontinue;\n\t\tif (++dptr >= limit)\n\t\t\tbreak;\n\t\tif (*(dptr - 1) == '\\r' && *dptr == '\\n') {\n\t\t\tif (++dptr >= limit)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (term != SDP_HDR_UNSPEC &&\n\t\t    limit - dptr >= thdr->len &&\n\t\t    strncasecmp(dptr, thdr->name, thdr->len) == 0)\n\t\t\tbreak;\n\t\telse if (limit - dptr >= hdr->len &&\n\t\t\t strncasecmp(dptr, hdr->name, hdr->len) == 0)\n\t\t\tdptr += hdr->len;\n\t\telse\n\t\t\tcontinue;\n\n\t\t*matchoff = dptr - start;\n\t\tif (hdr->search) {\n\t\t\tdptr = ct_sdp_header_search(dptr, limit, hdr->search,\n\t\t\t\t\t\t    hdr->slen);\n\t\t\tif (!dptr)\n\t\t\t\treturn -1;\n\t\t\tdptr += hdr->slen;\n\t\t}\n\n\t\t*matchlen = hdr->match_len(ct, dptr, limit, &shift);\n\t\tif (!*matchlen)\n\t\t\treturn -1;\n\t\t*matchoff = dptr - start + shift;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ct_sip_get_sdp_header);\n\nstatic int ct_sip_parse_sdp_addr(const struct nf_conn *ct, const char *dptr,\n\t\t\t\t unsigned int dataoff, unsigned int datalen,\n\t\t\t\t enum sdp_header_types type,\n\t\t\t\t enum sdp_header_types term,\n\t\t\t\t unsigned int *matchoff, unsigned int *matchlen,\n\t\t\t\t union nf_inet_addr *addr)\n{\n\tint ret;\n\n\tret = ct_sip_get_sdp_header(ct, dptr, dataoff, datalen, type, term,\n\t\t\t\t    matchoff, matchlen);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tif (!sdp_parse_addr(ct, dptr + *matchoff, NULL, addr,\n\t\t\t    dptr + *matchoff + *matchlen))\n\t\treturn -1;\n\treturn 1;\n}\n\nstatic int refresh_signalling_expectation(struct nf_conn *ct,\n\t\t\t\t\t  union nf_inet_addr *addr,\n\t\t\t\t\t  u8 proto, __be16 port,\n\t\t\t\t\t  unsigned int expires)\n{\n\tstruct nf_conn_help *help = nfct_help(ct);\n\tstruct nf_conntrack_expect *exp;\n\tstruct hlist_node *next;\n\tint found = 0;\n\n\tspin_lock_bh(&nf_conntrack_expect_lock);\n\thlist_for_each_entry_safe(exp, next, &help->expectations, lnode) {\n\t\tif (exp->class != SIP_EXPECT_SIGNALLING ||\n\t\t    !nf_inet_addr_cmp(&exp->tuple.dst.u3, addr) ||\n\t\t    exp->tuple.dst.protonum != proto ||\n\t\t    exp->tuple.dst.u.udp.port != port)\n\t\t\tcontinue;\n\t\tif (mod_timer_pending(&exp->timeout, jiffies + expires * HZ)) {\n\t\t\texp->flags &= ~NF_CT_EXPECT_INACTIVE;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&nf_conntrack_expect_lock);\n\treturn found;\n}\n\nstatic void flush_expectations(struct nf_conn *ct, bool media)\n{\n\tstruct nf_conn_help *help = nfct_help(ct);\n\tstruct nf_conntrack_expect *exp;\n\tstruct hlist_node *next;\n\n\tspin_lock_bh(&nf_conntrack_expect_lock);\n\thlist_for_each_entry_safe(exp, next, &help->expectations, lnode) {\n\t\tif ((exp->class != SIP_EXPECT_SIGNALLING) ^ media)\n\t\t\tcontinue;\n\t\tif (!nf_ct_remove_expect(exp))\n\t\t\tcontinue;\n\t\tif (!media)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&nf_conntrack_expect_lock);\n}\n\nstatic int set_expected_rtp_rtcp(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t unsigned int dataoff,\n\t\t\t\t const char **dptr, unsigned int *datalen,\n\t\t\t\t union nf_inet_addr *daddr, __be16 port,\n\t\t\t\t enum sip_expectation_classes class,\n\t\t\t\t unsigned int mediaoff, unsigned int medialen)\n{\n\tstruct nf_conntrack_expect *exp, *rtp_exp, *rtcp_exp;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct net *net = nf_ct_net(ct);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tunion nf_inet_addr *saddr;\n\tstruct nf_conntrack_tuple tuple;\n\tint direct_rtp = 0, skip_expect = 0, ret = NF_DROP;\n\tu_int16_t base_port;\n\t__be16 rtp_port, rtcp_port;\n\tconst struct nf_nat_sip_hooks *hooks;\n\n\tsaddr = NULL;\n\tif (sip_direct_media) {\n\t\tif (!nf_inet_addr_cmp(daddr, &ct->tuplehash[dir].tuple.src.u3))\n\t\t\treturn NF_ACCEPT;\n\t\tsaddr = &ct->tuplehash[!dir].tuple.src.u3;\n\t} else if (sip_external_media) {\n\t\tstruct net_device *dev = skb_dst(skb)->dev;\n\t\tstruct net *net = dev_net(dev);\n\t\tstruct flowi fl;\n\t\tstruct dst_entry *dst = NULL;\n\n\t\tmemset(&fl, 0, sizeof(fl));\n\n\t\tswitch (nf_ct_l3num(ct)) {\n\t\t\tcase NFPROTO_IPV4:\n\t\t\t\tfl.u.ip4.daddr = daddr->ip;\n\t\t\t\tnf_ip_route(net, &dst, &fl, false);\n\t\t\t\tbreak;\n\n\t\t\tcase NFPROTO_IPV6:\n\t\t\t\tfl.u.ip6.daddr = daddr->in6;\n\t\t\t\tnf_ip6_route(net, &dst, &fl, false);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dst) {\n\t\t\tbool external_media = (dst->dev == dev);\n\n\t\t\tdst_release(dst);\n\t\t\tif (external_media)\n\t\t\t\treturn NF_ACCEPT;\n\t\t}\n\t}\n\n\t \n\tmemset(&tuple, 0, sizeof(tuple));\n\tif (saddr)\n\t\ttuple.src.u3 = *saddr;\n\ttuple.src.l3num\t\t= nf_ct_l3num(ct);\n\ttuple.dst.protonum\t= IPPROTO_UDP;\n\ttuple.dst.u3\t\t= *daddr;\n\ttuple.dst.u.udp.port\t= port;\n\n\tdo {\n\t\texp = __nf_ct_expect_find(net, nf_ct_zone(ct), &tuple);\n\n\t\tif (!exp || exp->master == ct ||\n\t\t    nfct_help(exp->master)->helper != nfct_help(ct)->helper ||\n\t\t    exp->class != class)\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_NF_NAT)\n\t\tif (!direct_rtp &&\n\t\t    (!nf_inet_addr_cmp(&exp->saved_addr, &exp->tuple.dst.u3) ||\n\t\t     exp->saved_proto.udp.port != exp->tuple.dst.u.udp.port) &&\n\t\t    ct->status & IPS_NAT_MASK) {\n\t\t\t*daddr\t\t\t= exp->saved_addr;\n\t\t\ttuple.dst.u3\t\t= exp->saved_addr;\n\t\t\ttuple.dst.u.udp.port\t= exp->saved_proto.udp.port;\n\t\t\tdirect_rtp = 1;\n\t\t} else\n#endif\n\t\t\tskip_expect = 1;\n\t} while (!skip_expect);\n\n\tbase_port = ntohs(tuple.dst.u.udp.port) & ~1;\n\trtp_port = htons(base_port);\n\trtcp_port = htons(base_port + 1);\n\n\tif (direct_rtp) {\n\t\thooks = rcu_dereference(nf_nat_sip_hooks);\n\t\tif (hooks &&\n\t\t    !hooks->sdp_port(skb, protoff, dataoff, dptr, datalen,\n\t\t\t\t     mediaoff, medialen, ntohs(rtp_port)))\n\t\t\tgoto err1;\n\t}\n\n\tif (skip_expect)\n\t\treturn NF_ACCEPT;\n\n\trtp_exp = nf_ct_expect_alloc(ct);\n\tif (rtp_exp == NULL)\n\t\tgoto err1;\n\tnf_ct_expect_init(rtp_exp, class, nf_ct_l3num(ct), saddr, daddr,\n\t\t\t  IPPROTO_UDP, NULL, &rtp_port);\n\n\trtcp_exp = nf_ct_expect_alloc(ct);\n\tif (rtcp_exp == NULL)\n\t\tgoto err2;\n\tnf_ct_expect_init(rtcp_exp, class, nf_ct_l3num(ct), saddr, daddr,\n\t\t\t  IPPROTO_UDP, NULL, &rtcp_port);\n\n\thooks = rcu_dereference(nf_nat_sip_hooks);\n\tif (hooks && ct->status & IPS_NAT_MASK && !direct_rtp)\n\t\tret = hooks->sdp_media(skb, protoff, dataoff, dptr,\n\t\t\t\t       datalen, rtp_exp, rtcp_exp,\n\t\t\t\t       mediaoff, medialen, daddr);\n\telse {\n\t\t \n\t\tint errp = nf_ct_expect_related(rtp_exp,\n\t\t\t\t\t\tNF_CT_EXP_F_SKIP_MASTER);\n\n\t\tif (errp == 0 || errp == -EALREADY) {\n\t\t\tint errcp = nf_ct_expect_related(rtcp_exp,\n\t\t\t\t\t\tNF_CT_EXP_F_SKIP_MASTER);\n\n\t\t\tif (errcp == 0 || errcp == -EALREADY)\n\t\t\t\tret = NF_ACCEPT;\n\t\t\telse if (errp == 0)\n\t\t\t\tnf_ct_unexpect_related(rtp_exp);\n\t\t}\n\t}\n\tnf_ct_expect_put(rtcp_exp);\nerr2:\n\tnf_ct_expect_put(rtp_exp);\nerr1:\n\treturn ret;\n}\n\nstatic const struct sdp_media_type sdp_media_types[] = {\n\tSDP_MEDIA_TYPE(\"audio \", SIP_EXPECT_AUDIO),\n\tSDP_MEDIA_TYPE(\"video \", SIP_EXPECT_VIDEO),\n\tSDP_MEDIA_TYPE(\"image \", SIP_EXPECT_IMAGE),\n};\n\nstatic const struct sdp_media_type *sdp_media_type(const char *dptr,\n\t\t\t\t\t\t   unsigned int matchoff,\n\t\t\t\t\t\t   unsigned int matchlen)\n{\n\tconst struct sdp_media_type *t;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sdp_media_types); i++) {\n\t\tt = &sdp_media_types[i];\n\t\tif (matchlen < t->len ||\n\t\t    strncmp(dptr + matchoff, t->name, t->len))\n\t\t\tcontinue;\n\t\treturn t;\n\t}\n\treturn NULL;\n}\n\nstatic int process_sdp(struct sk_buff *skb, unsigned int protoff,\n\t\t       unsigned int dataoff,\n\t\t       const char **dptr, unsigned int *datalen,\n\t\t       unsigned int cseq)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tunsigned int matchoff, matchlen;\n\tunsigned int mediaoff, medialen;\n\tunsigned int sdpoff;\n\tunsigned int caddr_len, maddr_len;\n\tunsigned int i;\n\tunion nf_inet_addr caddr, maddr, rtp_addr;\n\tconst struct nf_nat_sip_hooks *hooks;\n\tunsigned int port;\n\tconst struct sdp_media_type *t;\n\tint ret = NF_ACCEPT;\n\n\thooks = rcu_dereference(nf_nat_sip_hooks);\n\n\t \n\tif (ct_sip_get_sdp_header(ct, *dptr, 0, *datalen,\n\t\t\t\t  SDP_HDR_VERSION, SDP_HDR_UNSPEC,\n\t\t\t\t  &matchoff, &matchlen) <= 0)\n\t\treturn NF_ACCEPT;\n\tsdpoff = matchoff;\n\n\t \n\tcaddr_len = 0;\n\tif (ct_sip_parse_sdp_addr(ct, *dptr, sdpoff, *datalen,\n\t\t\t\t  SDP_HDR_CONNECTION, SDP_HDR_MEDIA,\n\t\t\t\t  &matchoff, &matchlen, &caddr) > 0)\n\t\tcaddr_len = matchlen;\n\n\tmediaoff = sdpoff;\n\tfor (i = 0; i < ARRAY_SIZE(sdp_media_types); ) {\n\t\tif (ct_sip_get_sdp_header(ct, *dptr, mediaoff, *datalen,\n\t\t\t\t\t  SDP_HDR_MEDIA, SDP_HDR_UNSPEC,\n\t\t\t\t\t  &mediaoff, &medialen) <= 0)\n\t\t\tbreak;\n\n\t\t \n\t\tt = sdp_media_type(*dptr, mediaoff, medialen);\n\t\tif (!t) {\n\t\t\tmediaoff += medialen;\n\t\t\tcontinue;\n\t\t}\n\t\tmediaoff += t->len;\n\t\tmedialen -= t->len;\n\n\t\tport = simple_strtoul(*dptr + mediaoff, NULL, 10);\n\t\tif (port == 0)\n\t\t\tcontinue;\n\t\tif (port < 1024 || port > 65535) {\n\t\t\tnf_ct_helper_log(skb, ct, \"wrong port %u\", port);\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\t \n\t\tmaddr_len = 0;\n\t\tif (ct_sip_parse_sdp_addr(ct, *dptr, mediaoff, *datalen,\n\t\t\t\t\t  SDP_HDR_CONNECTION, SDP_HDR_MEDIA,\n\t\t\t\t\t  &matchoff, &matchlen, &maddr) > 0) {\n\t\t\tmaddr_len = matchlen;\n\t\t\tmemcpy(&rtp_addr, &maddr, sizeof(rtp_addr));\n\t\t} else if (caddr_len)\n\t\t\tmemcpy(&rtp_addr, &caddr, sizeof(rtp_addr));\n\t\telse {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot parse SDP message\");\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\tret = set_expected_rtp_rtcp(skb, protoff, dataoff,\n\t\t\t\t\t    dptr, datalen,\n\t\t\t\t\t    &rtp_addr, htons(port), t->class,\n\t\t\t\t\t    mediaoff, medialen);\n\t\tif (ret != NF_ACCEPT) {\n\t\t\tnf_ct_helper_log(skb, ct,\n\t\t\t\t\t \"cannot add expectation for voice\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (maddr_len && hooks && ct->status & IPS_NAT_MASK) {\n\t\t\tret = hooks->sdp_addr(skb, protoff, dataoff,\n\t\t\t\t\t      dptr, datalen, mediaoff,\n\t\t\t\t\t      SDP_HDR_CONNECTION,\n\t\t\t\t\t      SDP_HDR_MEDIA,\n\t\t\t\t\t      &rtp_addr);\n\t\t\tif (ret != NF_ACCEPT) {\n\t\t\t\tnf_ct_helper_log(skb, ct, \"cannot mangle SDP\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\t \n\thooks = rcu_dereference(nf_nat_sip_hooks);\n\tif (hooks && ct->status & IPS_NAT_MASK)\n\t\tret = hooks->sdp_session(skb, protoff, dataoff,\n\t\t\t\t\t dptr, datalen, sdpoff,\n\t\t\t\t\t &rtp_addr);\n\n\treturn ret;\n}\nstatic int process_invite_response(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t   unsigned int dataoff,\n\t\t\t\t   const char **dptr, unsigned int *datalen,\n\t\t\t\t   unsigned int cseq, unsigned int code)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\n\tif ((code >= 100 && code <= 199) ||\n\t    (code >= 200 && code <= 299))\n\t\treturn process_sdp(skb, protoff, dataoff, dptr, datalen, cseq);\n\telse if (ct_sip_info->invite_cseq == cseq)\n\t\tflush_expectations(ct, true);\n\treturn NF_ACCEPT;\n}\n\nstatic int process_update_response(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t   unsigned int dataoff,\n\t\t\t\t   const char **dptr, unsigned int *datalen,\n\t\t\t\t   unsigned int cseq, unsigned int code)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\n\tif ((code >= 100 && code <= 199) ||\n\t    (code >= 200 && code <= 299))\n\t\treturn process_sdp(skb, protoff, dataoff, dptr, datalen, cseq);\n\telse if (ct_sip_info->invite_cseq == cseq)\n\t\tflush_expectations(ct, true);\n\treturn NF_ACCEPT;\n}\n\nstatic int process_prack_response(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t  unsigned int dataoff,\n\t\t\t\t  const char **dptr, unsigned int *datalen,\n\t\t\t\t  unsigned int cseq, unsigned int code)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\n\tif ((code >= 100 && code <= 199) ||\n\t    (code >= 200 && code <= 299))\n\t\treturn process_sdp(skb, protoff, dataoff, dptr, datalen, cseq);\n\telse if (ct_sip_info->invite_cseq == cseq)\n\t\tflush_expectations(ct, true);\n\treturn NF_ACCEPT;\n}\n\nstatic int process_invite_request(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t  unsigned int dataoff,\n\t\t\t\t  const char **dptr, unsigned int *datalen,\n\t\t\t\t  unsigned int cseq)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\tunsigned int ret;\n\n\tflush_expectations(ct, true);\n\tret = process_sdp(skb, protoff, dataoff, dptr, datalen, cseq);\n\tif (ret == NF_ACCEPT)\n\t\tct_sip_info->invite_cseq = cseq;\n\treturn ret;\n}\n\nstatic int process_bye_request(struct sk_buff *skb, unsigned int protoff,\n\t\t\t       unsigned int dataoff,\n\t\t\t       const char **dptr, unsigned int *datalen,\n\t\t\t       unsigned int cseq)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\n\tflush_expectations(ct, true);\n\treturn NF_ACCEPT;\n}\n\n \nstatic int process_register_request(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t    unsigned int dataoff,\n\t\t\t\t    const char **dptr, unsigned int *datalen,\n\t\t\t\t    unsigned int cseq)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tunsigned int matchoff, matchlen;\n\tstruct nf_conntrack_expect *exp;\n\tunion nf_inet_addr *saddr, daddr;\n\tconst struct nf_nat_sip_hooks *hooks;\n\tstruct nf_conntrack_helper *helper;\n\t__be16 port;\n\tu8 proto;\n\tunsigned int expires = 0;\n\tint ret;\n\n\t \n\tif (ct->status & IPS_EXPECTED)\n\t\treturn NF_ACCEPT;\n\n\t \n\tif (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_EXPIRES,\n\t\t\t      &matchoff, &matchlen) > 0)\n\t\texpires = simple_strtoul(*dptr + matchoff, NULL, 10);\n\n\tret = ct_sip_parse_header_uri(ct, *dptr, NULL, *datalen,\n\t\t\t\t      SIP_HDR_CONTACT, NULL,\n\t\t\t\t      &matchoff, &matchlen, &daddr, &port);\n\tif (ret < 0) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot parse contact\");\n\t\treturn NF_DROP;\n\t} else if (ret == 0)\n\t\treturn NF_ACCEPT;\n\n\t \n\tif (!nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.src.u3, &daddr))\n\t\treturn NF_ACCEPT;\n\n\tif (ct_sip_parse_transport(ct, *dptr, matchoff + matchlen, *datalen,\n\t\t\t\t   &proto) == 0)\n\t\treturn NF_ACCEPT;\n\n\tif (ct_sip_parse_numerical_param(ct, *dptr,\n\t\t\t\t\t matchoff + matchlen, *datalen,\n\t\t\t\t\t \"expires=\", NULL, NULL, &expires) < 0) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot parse expires\");\n\t\treturn NF_DROP;\n\t}\n\n\tif (expires == 0) {\n\t\tret = NF_ACCEPT;\n\t\tgoto store_cseq;\n\t}\n\n\texp = nf_ct_expect_alloc(ct);\n\tif (!exp) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot alloc expectation\");\n\t\treturn NF_DROP;\n\t}\n\n\tsaddr = NULL;\n\tif (sip_direct_signalling)\n\t\tsaddr = &ct->tuplehash[!dir].tuple.src.u3;\n\n\thelper = rcu_dereference(nfct_help(ct)->helper);\n\tif (!helper)\n\t\treturn NF_DROP;\n\n\tnf_ct_expect_init(exp, SIP_EXPECT_SIGNALLING, nf_ct_l3num(ct),\n\t\t\t  saddr, &daddr, proto, NULL, &port);\n\texp->timeout.expires = sip_timeout * HZ;\n\texp->helper = helper;\n\texp->flags = NF_CT_EXPECT_PERMANENT | NF_CT_EXPECT_INACTIVE;\n\n\thooks = rcu_dereference(nf_nat_sip_hooks);\n\tif (hooks && ct->status & IPS_NAT_MASK)\n\t\tret = hooks->expect(skb, protoff, dataoff, dptr, datalen,\n\t\t\t\t    exp, matchoff, matchlen);\n\telse {\n\t\tif (nf_ct_expect_related(exp, 0) != 0) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot add expectation\");\n\t\t\tret = NF_DROP;\n\t\t} else\n\t\t\tret = NF_ACCEPT;\n\t}\n\tnf_ct_expect_put(exp);\n\nstore_cseq:\n\tif (ret == NF_ACCEPT)\n\t\tct_sip_info->register_cseq = cseq;\n\treturn ret;\n}\n\nstatic int process_register_response(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t     unsigned int dataoff,\n\t\t\t\t     const char **dptr, unsigned int *datalen,\n\t\t\t\t     unsigned int cseq, unsigned int code)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tunion nf_inet_addr addr;\n\t__be16 port;\n\tu8 proto;\n\tunsigned int matchoff, matchlen, coff = 0;\n\tunsigned int expires = 0;\n\tint in_contact = 0, ret;\n\n\t \n\tif (ct_sip_info->register_cseq != cseq)\n\t\treturn NF_ACCEPT;\n\n\tif (code >= 100 && code <= 199)\n\t\treturn NF_ACCEPT;\n\tif (code < 200 || code > 299)\n\t\tgoto flush;\n\n\tif (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_EXPIRES,\n\t\t\t      &matchoff, &matchlen) > 0)\n\t\texpires = simple_strtoul(*dptr + matchoff, NULL, 10);\n\n\twhile (1) {\n\t\tunsigned int c_expires = expires;\n\n\t\tret = ct_sip_parse_header_uri(ct, *dptr, &coff, *datalen,\n\t\t\t\t\t      SIP_HDR_CONTACT, &in_contact,\n\t\t\t\t\t      &matchoff, &matchlen,\n\t\t\t\t\t      &addr, &port);\n\t\tif (ret < 0) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot parse contact\");\n\t\t\treturn NF_DROP;\n\t\t} else if (ret == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.dst.u3, &addr))\n\t\t\tcontinue;\n\n\t\tif (ct_sip_parse_transport(ct, *dptr, matchoff + matchlen,\n\t\t\t\t\t   *datalen, &proto) == 0)\n\t\t\tcontinue;\n\n\t\tret = ct_sip_parse_numerical_param(ct, *dptr,\n\t\t\t\t\t\t   matchoff + matchlen,\n\t\t\t\t\t\t   *datalen, \"expires=\",\n\t\t\t\t\t\t   NULL, NULL, &c_expires);\n\t\tif (ret < 0) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot parse expires\");\n\t\t\treturn NF_DROP;\n\t\t}\n\t\tif (c_expires == 0)\n\t\t\tbreak;\n\t\tif (refresh_signalling_expectation(ct, &addr, proto, port,\n\t\t\t\t\t\t   c_expires))\n\t\t\treturn NF_ACCEPT;\n\t}\n\nflush:\n\tflush_expectations(ct, false);\n\treturn NF_ACCEPT;\n}\n\nstatic const struct sip_handler sip_handlers[] = {\n\tSIP_HANDLER(\"INVITE\", process_invite_request, process_invite_response),\n\tSIP_HANDLER(\"UPDATE\", process_sdp, process_update_response),\n\tSIP_HANDLER(\"ACK\", process_sdp, NULL),\n\tSIP_HANDLER(\"PRACK\", process_sdp, process_prack_response),\n\tSIP_HANDLER(\"BYE\", process_bye_request, NULL),\n\tSIP_HANDLER(\"REGISTER\", process_register_request, process_register_response),\n};\n\nstatic int process_sip_response(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\tunsigned int dataoff,\n\t\t\t\tconst char **dptr, unsigned int *datalen)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tunsigned int matchoff, matchlen, matchend;\n\tunsigned int code, cseq, i;\n\n\tif (*datalen < strlen(\"SIP/2.0 200\"))\n\t\treturn NF_ACCEPT;\n\tcode = simple_strtoul(*dptr + strlen(\"SIP/2.0 \"), NULL, 10);\n\tif (!code) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot get code\");\n\t\treturn NF_DROP;\n\t}\n\n\tif (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_CSEQ,\n\t\t\t      &matchoff, &matchlen) <= 0) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot parse cseq\");\n\t\treturn NF_DROP;\n\t}\n\tcseq = simple_strtoul(*dptr + matchoff, NULL, 10);\n\tif (!cseq && *(*dptr + matchoff) != '0') {\n\t\tnf_ct_helper_log(skb, ct, \"cannot get cseq\");\n\t\treturn NF_DROP;\n\t}\n\tmatchend = matchoff + matchlen + 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(sip_handlers); i++) {\n\t\tconst struct sip_handler *handler;\n\n\t\thandler = &sip_handlers[i];\n\t\tif (handler->response == NULL)\n\t\t\tcontinue;\n\t\tif (*datalen < matchend + handler->len ||\n\t\t    strncasecmp(*dptr + matchend, handler->method, handler->len))\n\t\t\tcontinue;\n\t\treturn handler->response(skb, protoff, dataoff, dptr, datalen,\n\t\t\t\t\t cseq, code);\n\t}\n\treturn NF_ACCEPT;\n}\n\nstatic int process_sip_request(struct sk_buff *skb, unsigned int protoff,\n\t\t\t       unsigned int dataoff,\n\t\t\t       const char **dptr, unsigned int *datalen)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tunsigned int matchoff, matchlen;\n\tunsigned int cseq, i;\n\tunion nf_inet_addr addr;\n\t__be16 port;\n\n\t \n\tif (ct_sip_parse_header_uri(ct, *dptr, NULL, *datalen,\n\t\t\t\t    SIP_HDR_VIA_UDP, NULL, &matchoff,\n\t\t\t\t    &matchlen, &addr, &port) > 0 &&\n\t    port != ct->tuplehash[dir].tuple.src.u.udp.port &&\n\t    nf_inet_addr_cmp(&addr, &ct->tuplehash[dir].tuple.src.u3))\n\t\tct_sip_info->forced_dport = port;\n\n\tfor (i = 0; i < ARRAY_SIZE(sip_handlers); i++) {\n\t\tconst struct sip_handler *handler;\n\n\t\thandler = &sip_handlers[i];\n\t\tif (handler->request == NULL)\n\t\t\tcontinue;\n\t\tif (*datalen < handler->len + 2 ||\n\t\t    strncasecmp(*dptr, handler->method, handler->len))\n\t\t\tcontinue;\n\t\tif ((*dptr)[handler->len] != ' ' ||\n\t\t    !isalpha((*dptr)[handler->len+1]))\n\t\t\tcontinue;\n\n\t\tif (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_CSEQ,\n\t\t\t\t      &matchoff, &matchlen) <= 0) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot parse cseq\");\n\t\t\treturn NF_DROP;\n\t\t}\n\t\tcseq = simple_strtoul(*dptr + matchoff, NULL, 10);\n\t\tif (!cseq && *(*dptr + matchoff) != '0') {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot get cseq\");\n\t\t\treturn NF_DROP;\n\t\t}\n\n\t\treturn handler->request(skb, protoff, dataoff, dptr, datalen,\n\t\t\t\t\tcseq);\n\t}\n\treturn NF_ACCEPT;\n}\n\nstatic int process_sip_msg(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t   unsigned int protoff, unsigned int dataoff,\n\t\t\t   const char **dptr, unsigned int *datalen)\n{\n\tconst struct nf_nat_sip_hooks *hooks;\n\tint ret;\n\n\tif (strncasecmp(*dptr, \"SIP/2.0 \", strlen(\"SIP/2.0 \")) != 0)\n\t\tret = process_sip_request(skb, protoff, dataoff, dptr, datalen);\n\telse\n\t\tret = process_sip_response(skb, protoff, dataoff, dptr, datalen);\n\n\tif (ret == NF_ACCEPT && ct->status & IPS_NAT_MASK) {\n\t\thooks = rcu_dereference(nf_nat_sip_hooks);\n\t\tif (hooks && !hooks->msg(skb, protoff, dataoff,\n\t\t\t\t\t dptr, datalen)) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot NAT SIP message\");\n\t\t\tret = NF_DROP;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int sip_help_tcp(struct sk_buff *skb, unsigned int protoff,\n\t\t\tstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\n{\n\tstruct tcphdr *th, _tcph;\n\tunsigned int dataoff, datalen;\n\tunsigned int matchoff, matchlen, clen;\n\tunsigned int msglen, origlen;\n\tconst char *dptr, *end;\n\ts16 diff, tdiff = 0;\n\tint ret = NF_ACCEPT;\n\tbool term;\n\n\tif (ctinfo != IP_CT_ESTABLISHED &&\n\t    ctinfo != IP_CT_ESTABLISHED_REPLY)\n\t\treturn NF_ACCEPT;\n\n\t \n\tth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\n\tif (th == NULL)\n\t\treturn NF_ACCEPT;\n\tdataoff = protoff + th->doff * 4;\n\tif (dataoff >= skb->len)\n\t\treturn NF_ACCEPT;\n\n\tnf_ct_refresh(ct, skb, sip_timeout * HZ);\n\n\tif (unlikely(skb_linearize(skb)))\n\t\treturn NF_DROP;\n\n\tdptr = skb->data + dataoff;\n\tdatalen = skb->len - dataoff;\n\tif (datalen < strlen(\"SIP/2.0 200\"))\n\t\treturn NF_ACCEPT;\n\n\twhile (1) {\n\t\tif (ct_sip_get_header(ct, dptr, 0, datalen,\n\t\t\t\t      SIP_HDR_CONTENT_LENGTH,\n\t\t\t\t      &matchoff, &matchlen) <= 0)\n\t\t\tbreak;\n\n\t\tclen = simple_strtoul(dptr + matchoff, (char **)&end, 10);\n\t\tif (dptr + matchoff == end)\n\t\t\tbreak;\n\n\t\tterm = false;\n\t\tfor (; end + strlen(\"\\r\\n\\r\\n\") <= dptr + datalen; end++) {\n\t\t\tif (end[0] == '\\r' && end[1] == '\\n' &&\n\t\t\t    end[2] == '\\r' && end[3] == '\\n') {\n\t\t\t\tterm = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!term)\n\t\t\tbreak;\n\t\tend += strlen(\"\\r\\n\\r\\n\") + clen;\n\n\t\tmsglen = origlen = end - dptr;\n\t\tif (msglen > datalen)\n\t\t\treturn NF_ACCEPT;\n\n\t\tret = process_sip_msg(skb, ct, protoff, dataoff,\n\t\t\t\t      &dptr, &msglen);\n\t\t \n\t\tif (ret != NF_ACCEPT)\n\t\t\tbreak;\n\t\tdiff     = msglen - origlen;\n\t\ttdiff   += diff;\n\n\t\tdataoff += msglen;\n\t\tdptr    += msglen;\n\t\tdatalen  = datalen + diff - msglen;\n\t}\n\n\tif (ret == NF_ACCEPT && ct->status & IPS_NAT_MASK) {\n\t\tconst struct nf_nat_sip_hooks *hooks;\n\n\t\thooks = rcu_dereference(nf_nat_sip_hooks);\n\t\tif (hooks)\n\t\t\thooks->seq_adjust(skb, protoff, tdiff);\n\t}\n\n\treturn ret;\n}\n\nstatic int sip_help_udp(struct sk_buff *skb, unsigned int protoff,\n\t\t\tstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\n{\n\tunsigned int dataoff, datalen;\n\tconst char *dptr;\n\n\t \n\tdataoff = protoff + sizeof(struct udphdr);\n\tif (dataoff >= skb->len)\n\t\treturn NF_ACCEPT;\n\n\tnf_ct_refresh(ct, skb, sip_timeout * HZ);\n\n\tif (unlikely(skb_linearize(skb)))\n\t\treturn NF_DROP;\n\n\tdptr = skb->data + dataoff;\n\tdatalen = skb->len - dataoff;\n\tif (datalen < strlen(\"SIP/2.0 200\"))\n\t\treturn NF_ACCEPT;\n\n\treturn process_sip_msg(skb, ct, protoff, dataoff, &dptr, &datalen);\n}\n\nstatic struct nf_conntrack_helper sip[MAX_PORTS * 4] __read_mostly;\n\nstatic const struct nf_conntrack_expect_policy sip_exp_policy[SIP_EXPECT_MAX + 1] = {\n\t[SIP_EXPECT_SIGNALLING] = {\n\t\t.name\t\t= \"signalling\",\n\t\t.max_expected\t= 1,\n\t\t.timeout\t= 3 * 60,\n\t},\n\t[SIP_EXPECT_AUDIO] = {\n\t\t.name\t\t= \"audio\",\n\t\t.max_expected\t= 2 * IP_CT_DIR_MAX,\n\t\t.timeout\t= 3 * 60,\n\t},\n\t[SIP_EXPECT_VIDEO] = {\n\t\t.name\t\t= \"video\",\n\t\t.max_expected\t= 2 * IP_CT_DIR_MAX,\n\t\t.timeout\t= 3 * 60,\n\t},\n\t[SIP_EXPECT_IMAGE] = {\n\t\t.name\t\t= \"image\",\n\t\t.max_expected\t= IP_CT_DIR_MAX,\n\t\t.timeout\t= 3 * 60,\n\t},\n};\n\nstatic void __exit nf_conntrack_sip_fini(void)\n{\n\tnf_conntrack_helpers_unregister(sip, ports_c * 4);\n}\n\nstatic int __init nf_conntrack_sip_init(void)\n{\n\tint i, ret;\n\n\tNF_CT_HELPER_BUILD_BUG_ON(sizeof(struct nf_ct_sip_master));\n\n\tif (ports_c == 0)\n\t\tports[ports_c++] = SIP_PORT;\n\n\tfor (i = 0; i < ports_c; i++) {\n\t\tnf_ct_helper_init(&sip[4 * i], AF_INET, IPPROTO_UDP,\n\t\t\t\t  HELPER_NAME, SIP_PORT, ports[i], i,\n\t\t\t\t  sip_exp_policy, SIP_EXPECT_MAX, sip_help_udp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t\tnf_ct_helper_init(&sip[4 * i + 1], AF_INET, IPPROTO_TCP,\n\t\t\t\t  HELPER_NAME, SIP_PORT, ports[i], i,\n\t\t\t\t  sip_exp_policy, SIP_EXPECT_MAX, sip_help_tcp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t\tnf_ct_helper_init(&sip[4 * i + 2], AF_INET6, IPPROTO_UDP,\n\t\t\t\t  HELPER_NAME, SIP_PORT, ports[i], i,\n\t\t\t\t  sip_exp_policy, SIP_EXPECT_MAX, sip_help_udp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t\tnf_ct_helper_init(&sip[4 * i + 3], AF_INET6, IPPROTO_TCP,\n\t\t\t\t  HELPER_NAME, SIP_PORT, ports[i], i,\n\t\t\t\t  sip_exp_policy, SIP_EXPECT_MAX, sip_help_tcp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t}\n\n\tret = nf_conntrack_helpers_register(sip, ports_c * 4);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to register helpers\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nmodule_init(nf_conntrack_sip_init);\nmodule_exit(nf_conntrack_sip_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}