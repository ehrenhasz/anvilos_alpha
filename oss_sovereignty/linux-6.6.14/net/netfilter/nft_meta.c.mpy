{
  "module_name": "nft_meta.c",
  "hash_id": "983a003f53280118f96d118af5a8e4c20396d7e1ce467da09eaec2e2064b8075",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_meta.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/random.h>\n#include <linux/smp.h>\n#include <linux/static_key.h>\n#include <net/dst.h>\n#include <net/ip.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>  \n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nft_meta.h>\n#include <net/netfilter/nf_tables_offload.h>\n\n#include <uapi/linux/netfilter_bridge.h>  \n\n#define NFT_META_SECS_PER_MINUTE\t60\n#define NFT_META_SECS_PER_HOUR\t\t3600\n#define NFT_META_SECS_PER_DAY\t\t86400\n#define NFT_META_DAYS_PER_WEEK\t\t7\n\nstatic u8 nft_meta_weekday(void)\n{\n\ttime64_t secs = ktime_get_real_seconds();\n\tunsigned int dse;\n\tu8 wday;\n\n\tsecs -= NFT_META_SECS_PER_MINUTE * sys_tz.tz_minuteswest;\n\tdse = div_u64(secs, NFT_META_SECS_PER_DAY);\n\twday = (4 + dse) % NFT_META_DAYS_PER_WEEK;\n\n\treturn wday;\n}\n\nstatic u32 nft_meta_hour(time64_t secs)\n{\n\tstruct tm tm;\n\n\ttime64_to_tm(secs, 0, &tm);\n\n\treturn tm.tm_hour * NFT_META_SECS_PER_HOUR\n\t\t+ tm.tm_min * NFT_META_SECS_PER_MINUTE\n\t\t+ tm.tm_sec;\n}\n\nstatic noinline_for_stack void\nnft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64((u64 *)dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic noinline bool\nnft_meta_get_eval_pkttype_lo(const struct nft_pktinfo *pkt,\n\t\t\t     u32 *dest)\n{\n\tconst struct sk_buff *skb = pkt->skb;\n\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tif (ipv4_is_multicast(ip_hdr(skb)->daddr))\n\t\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\telse\n\t\t\tnft_reg_store8(dest, PACKET_BROADCAST);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\tbreak;\n\tcase NFPROTO_NETDEV:\n\t\tswitch (skb->protocol) {\n\t\tcase htons(ETH_P_IP): {\n\t\t\tint noff = skb_network_offset(skb);\n\t\t\tstruct iphdr *iph, _iph;\n\n\t\t\tiph = skb_header_pointer(skb, noff,\n\t\t\t\t\t\t sizeof(_iph), &_iph);\n\t\t\tif (!iph)\n\t\t\t\treturn false;\n\n\t\t\tif (ipv4_is_multicast(iph->daddr))\n\t\t\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\t\telse\n\t\t\t\tnft_reg_store8(dest, PACKET_BROADCAST);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic noinline bool\nnft_meta_get_eval_skugid(enum nft_meta_keys key,\n\t\t\t u32 *dest,\n\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct sock *sk = skb_to_full_sk(pkt->skb);\n\tstruct socket *sock;\n\n\tif (!sk || !sk_fullsock(sk) || !net_eq(nft_net(pkt), sock_net(sk)))\n\t\treturn false;\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tsock = sk->sk_socket;\n\tif (!sock || !sock->file) {\n\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t\treturn false;\n\t}\n\n\tswitch (key) {\n\tcase NFT_META_SKUID:\n\t\t*dest = from_kuid_munged(sock_net(sk)->user_ns,\n\t\t\t\t\t sock->file->f_cred->fsuid);\n\t\tbreak;\n\tcase NFT_META_SKGID:\n\t\t*dest =\tfrom_kgid_munged(sock_net(sk)->user_ns,\n\t\t\t\t\t sock->file->f_cred->fsgid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tread_unlock_bh(&sk->sk_callback_lock);\n\treturn true;\n}\n\n#ifdef CONFIG_CGROUP_NET_CLASSID\nstatic noinline bool\nnft_meta_get_eval_cgroup(u32 *dest, const struct nft_pktinfo *pkt)\n{\n\tstruct sock *sk = skb_to_full_sk(pkt->skb);\n\n\tif (!sk || !sk_fullsock(sk) || !net_eq(nft_net(pkt), sock_net(sk)))\n\t\treturn false;\n\n\t*dest = sock_cgroup_classid(&sk->sk_cgrp_data);\n\treturn true;\n}\n#endif\n\nstatic noinline bool nft_meta_get_eval_kind(enum nft_meta_keys key,\n\t\t\t\t\t    u32 *dest,\n\t\t\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tconst struct net_device *in = nft_in(pkt), *out = nft_out(pkt);\n\n\tswitch (key) {\n\tcase NFT_META_IIFKIND:\n\t\tif (!in || !in->rtnl_link_ops)\n\t\t\treturn false;\n\t\tstrscpy_pad((char *)dest, in->rtnl_link_ops->kind, IFNAMSIZ);\n\t\tbreak;\n\tcase NFT_META_OIFKIND:\n\t\tif (!out || !out->rtnl_link_ops)\n\t\t\treturn false;\n\t\tstrscpy_pad((char *)dest, out->rtnl_link_ops->kind, IFNAMSIZ);\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void nft_meta_store_ifindex(u32 *dest, const struct net_device *dev)\n{\n\t*dest = dev ? dev->ifindex : 0;\n}\n\nstatic void nft_meta_store_ifname(u32 *dest, const struct net_device *dev)\n{\n\tstrscpy_pad((char *)dest, dev ? dev->name : \"\", IFNAMSIZ);\n}\n\nstatic bool nft_meta_store_iftype(u32 *dest, const struct net_device *dev)\n{\n\tif (!dev)\n\t\treturn false;\n\n\tnft_reg_store16(dest, dev->type);\n\treturn true;\n}\n\nstatic bool nft_meta_store_ifgroup(u32 *dest, const struct net_device *dev)\n{\n\tif (!dev)\n\t\treturn false;\n\n\t*dest = dev->group;\n\treturn true;\n}\n\nstatic bool nft_meta_get_eval_ifname(enum nft_meta_keys key, u32 *dest,\n\t\t\t\t     const struct nft_pktinfo *pkt)\n{\n\tswitch (key) {\n\tcase NFT_META_IIFNAME:\n\t\tnft_meta_store_ifname(dest, nft_in(pkt));\n\t\tbreak;\n\tcase NFT_META_OIFNAME:\n\t\tnft_meta_store_ifname(dest, nft_out(pkt));\n\t\tbreak;\n\tcase NFT_META_IIF:\n\t\tnft_meta_store_ifindex(dest, nft_in(pkt));\n\t\tbreak;\n\tcase NFT_META_OIF:\n\t\tnft_meta_store_ifindex(dest, nft_out(pkt));\n\t\tbreak;\n\tcase NFT_META_IFTYPE:\n\t\tif (!nft_meta_store_iftype(dest, pkt->skb->dev))\n\t\t\treturn false;\n\t\tbreak;\n\tcase __NFT_META_IIFTYPE:\n\t\tif (!nft_meta_store_iftype(dest, nft_in(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NFT_META_OIFTYPE:\n\t\tif (!nft_meta_store_iftype(dest, nft_out(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NFT_META_IIFGROUP:\n\t\tif (!nft_meta_store_ifgroup(dest, nft_in(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NFT_META_OIFGROUP:\n\t\tif (!nft_meta_store_ifgroup(dest, nft_out(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\nstatic noinline bool\nnft_meta_get_eval_rtclassid(const struct sk_buff *skb, u32 *dest)\n{\n\tconst struct dst_entry *dst = skb_dst(skb);\n\n\tif (!dst)\n\t\treturn false;\n\n\t*dest = dst->tclassid;\n\treturn true;\n}\n#endif\n\nstatic noinline u32 nft_meta_get_eval_sdif(const struct nft_pktinfo *pkt)\n{\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\treturn inet_sdif(pkt->skb);\n\tcase NFPROTO_IPV6:\n\t\treturn inet6_sdif(pkt->skb);\n\t}\n\n\treturn 0;\n}\n\nstatic noinline void\nnft_meta_get_eval_sdifname(u32 *dest, const struct nft_pktinfo *pkt)\n{\n\tu32 sdif = nft_meta_get_eval_sdif(pkt);\n\tconst struct net_device *dev;\n\n\tdev = sdif ? dev_get_by_index_rcu(nft_net(pkt), sdif) : NULL;\n\tnft_meta_store_ifname(dest, dev);\n}\n\nvoid nft_meta_get_eval(const struct nft_expr *expr,\n\t\t       struct nft_regs *regs,\n\t\t       const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tconst struct sk_buff *skb = pkt->skb;\n\tu32 *dest = &regs->data[priv->dreg];\n\n\tswitch (priv->key) {\n\tcase NFT_META_LEN:\n\t\t*dest = skb->len;\n\t\tbreak;\n\tcase NFT_META_PROTOCOL:\n\t\tnft_reg_store16(dest, (__force u16)skb->protocol);\n\t\tbreak;\n\tcase NFT_META_NFPROTO:\n\t\tnft_reg_store8(dest, nft_pf(pkt));\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tif (!(pkt->flags & NFT_PKTINFO_L4PROTO))\n\t\t\tgoto err;\n\t\tnft_reg_store8(dest, pkt->tprot);\n\t\tbreak;\n\tcase NFT_META_PRIORITY:\n\t\t*dest = skb->priority;\n\t\tbreak;\n\tcase NFT_META_MARK:\n\t\t*dest = skb->mark;\n\t\tbreak;\n\tcase NFT_META_IIF:\n\tcase NFT_META_OIF:\n\tcase NFT_META_IIFNAME:\n\tcase NFT_META_OIFNAME:\n\tcase NFT_META_IIFTYPE:\n\tcase NFT_META_OIFTYPE:\n\tcase NFT_META_IIFGROUP:\n\tcase NFT_META_OIFGROUP:\n\t\tif (!nft_meta_get_eval_ifname(priv->key, dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n\tcase NFT_META_SKUID:\n\tcase NFT_META_SKGID:\n\t\tif (!nft_meta_get_eval_skugid(priv->key, dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tcase NFT_META_RTCLASSID:\n\t\tif (!nft_meta_get_eval_rtclassid(skb, dest))\n\t\t\tgoto err;\n\t\tbreak;\n#endif\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n\t\t*dest = skb->secmark;\n\t\tbreak;\n#endif\n\tcase NFT_META_PKTTYPE:\n\t\tif (skb->pkt_type != PACKET_LOOPBACK) {\n\t\t\tnft_reg_store8(dest, skb->pkt_type);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!nft_meta_get_eval_pkttype_lo(pkt, dest))\n\t\t\tgoto err;\n\t\tbreak;\n\tcase NFT_META_CPU:\n\t\t*dest = raw_smp_processor_id();\n\t\tbreak;\n#ifdef CONFIG_CGROUP_NET_CLASSID\n\tcase NFT_META_CGROUP:\n\t\tif (!nft_meta_get_eval_cgroup(dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n#endif\n\tcase NFT_META_PRANDOM:\n\t\t*dest = get_random_u32();\n\t\tbreak;\n#ifdef CONFIG_XFRM\n\tcase NFT_META_SECPATH:\n\t\tnft_reg_store8(dest, secpath_exists(skb));\n\t\tbreak;\n#endif\n\tcase NFT_META_IIFKIND:\n\tcase NFT_META_OIFKIND:\n\t\tif (!nft_meta_get_eval_kind(priv->key, dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n\tcase NFT_META_TIME_NS:\n\tcase NFT_META_TIME_DAY:\n\tcase NFT_META_TIME_HOUR:\n\t\tnft_meta_get_eval_time(priv->key, dest);\n\t\tbreak;\n\tcase NFT_META_SDIF:\n\t\t*dest = nft_meta_get_eval_sdif(pkt);\n\t\tbreak;\n\tcase NFT_META_SDIFNAME:\n\t\tnft_meta_get_eval_sdifname(dest, pkt);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tgoto err;\n\t}\n\treturn;\n\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_eval);\n\nvoid nft_meta_set_eval(const struct nft_expr *expr,\n\t\t       struct nft_regs *regs,\n\t\t       const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_meta *meta = nft_expr_priv(expr);\n\tstruct sk_buff *skb = pkt->skb;\n\tu32 *sreg = &regs->data[meta->sreg];\n\tu32 value = *sreg;\n\tu8 value8;\n\n\tswitch (meta->key) {\n\tcase NFT_META_MARK:\n\t\tskb->mark = value;\n\t\tbreak;\n\tcase NFT_META_PRIORITY:\n\t\tskb->priority = value;\n\t\tbreak;\n\tcase NFT_META_PKTTYPE:\n\t\tvalue8 = nft_reg_load8(sreg);\n\n\t\tif (skb->pkt_type != value8 &&\n\t\t    skb_pkt_type_ok(value8) &&\n\t\t    skb_pkt_type_ok(skb->pkt_type))\n\t\t\tskb->pkt_type = value8;\n\t\tbreak;\n\tcase NFT_META_NFTRACE:\n\t\tvalue8 = nft_reg_load8(sreg);\n\n\t\tskb->nf_trace = !!value8;\n\t\tbreak;\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n\t\tskb->secmark = value;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_eval);\n\nconst struct nla_policy nft_meta_policy[NFTA_META_MAX + 1] = {\n\t[NFTA_META_DREG]\t= { .type = NLA_U32 },\n\t[NFTA_META_KEY]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_META_SREG]\t= { .type = NLA_U32 },\n};\nEXPORT_SYMBOL_GPL(nft_meta_policy);\n\nint nft_meta_get_init(const struct nft_ctx *ctx,\n\t\t      const struct nft_expr *expr,\n\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\tcase NFT_META_IIFTYPE:\n\tcase NFT_META_OIFTYPE:\n\t\tlen = sizeof(u16);\n\t\tbreak;\n\tcase NFT_META_NFPROTO:\n\tcase NFT_META_L4PROTO:\n\tcase NFT_META_LEN:\n\tcase NFT_META_PRIORITY:\n\tcase NFT_META_MARK:\n\tcase NFT_META_IIF:\n\tcase NFT_META_OIF:\n\tcase NFT_META_SDIF:\n\tcase NFT_META_SKUID:\n\tcase NFT_META_SKGID:\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tcase NFT_META_RTCLASSID:\n#endif\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n#endif\n\tcase NFT_META_PKTTYPE:\n\tcase NFT_META_CPU:\n\tcase NFT_META_IIFGROUP:\n\tcase NFT_META_OIFGROUP:\n#ifdef CONFIG_CGROUP_NET_CLASSID\n\tcase NFT_META_CGROUP:\n#endif\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tcase NFT_META_IIFNAME:\n\tcase NFT_META_OIFNAME:\n\tcase NFT_META_IIFKIND:\n\tcase NFT_META_OIFKIND:\n\tcase NFT_META_SDIFNAME:\n\t\tlen = IFNAMSIZ;\n\t\tbreak;\n\tcase NFT_META_PRANDOM:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n#ifdef CONFIG_XFRM\n\tcase NFT_META_SECPATH:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n#endif\n\tcase NFT_META_TIME_NS:\n\t\tlen = sizeof(u64);\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->len = len;\n\treturn nft_parse_register_store(ctx, tb[NFTA_META_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_init);\n\nstatic int nft_meta_get_validate_sdif(const struct nft_ctx *ctx)\n{\n\tunsigned int hooks;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\thooks = (1 << NF_INET_LOCAL_IN) |\n\t\t\t(1 << NF_INET_FORWARD);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\n\nstatic int nft_meta_get_validate_xfrm(const struct nft_ctx *ctx)\n{\n#ifdef CONFIG_XFRM\n\tunsigned int hooks;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_NETDEV:\n\t\thooks = 1 << NF_NETDEV_INGRESS;\n\t\tbreak;\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\thooks = (1 << NF_INET_PRE_ROUTING) |\n\t\t\t(1 << NF_INET_LOCAL_IN) |\n\t\t\t(1 << NF_INET_FORWARD);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n#else\n\treturn 0;\n#endif\n}\n\nstatic int nft_meta_get_validate(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_expr *expr,\n\t\t\t\t const struct nft_data **data)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tswitch (priv->key) {\n\tcase NFT_META_SECPATH:\n\t\treturn nft_meta_get_validate_xfrm(ctx);\n\tcase NFT_META_SDIF:\n\tcase NFT_META_SDIFNAME:\n\t\treturn nft_meta_get_validate_sdif(ctx);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint nft_meta_set_validate(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nft_data **data)\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int hooks;\n\n\tif (priv->key != NFT_META_PKTTYPE)\n\t\treturn 0;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_BRIDGE:\n\t\thooks = 1 << NF_BR_PRE_ROUTING;\n\t\tbreak;\n\tcase NFPROTO_NETDEV:\n\t\thooks = 1 << NF_NETDEV_INGRESS;\n\t\tbreak;\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\thooks = 1 << NF_INET_PRE_ROUTING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_validate);\n\nint nft_meta_set_init(const struct nft_ctx *ctx,\n\t\t      const struct nft_expr *expr,\n\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\tint err;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_MARK:\n\tcase NFT_META_PRIORITY:\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n#endif\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tcase NFT_META_NFTRACE:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tcase NFT_META_PKTTYPE:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->len = len;\n\terr = nft_parse_register_load(tb[NFTA_META_SREG], &priv->sreg, len);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (priv->key == NFT_META_NFTRACE)\n\t\tstatic_branch_inc(&nft_trace_enabled);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_init);\n\nint nft_meta_get_dump(struct sk_buff *skb,\n\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_META_KEY, htonl(priv->key)))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_META_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_dump);\n\nint nft_meta_set_dump(struct sk_buff *skb,\n\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_META_KEY, htonl(priv->key)))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_META_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_dump);\n\nvoid nft_meta_set_destroy(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tif (priv->key == NFT_META_NFTRACE)\n\t\tstatic_branch_dec(&nft_trace_enabled);\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_destroy);\n\nstatic int nft_meta_get_offload(struct nft_offload_ctx *ctx,\n\t\t\t\tstruct nft_flow_rule *flow,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tstruct nft_offload_reg *reg = &ctx->regs[priv->dreg];\n\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_BASIC, basic, n_proto,\n\t\t\t\t\tsizeof(__u16), reg);\n\t\tnft_offload_set_dependency(ctx, NFT_OFFLOAD_DEP_NETWORK);\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_BASIC, basic, ip_proto,\n\t\t\t\t\tsizeof(__u8), reg);\n\t\tnft_offload_set_dependency(ctx, NFT_OFFLOAD_DEP_TRANSPORT);\n\t\tbreak;\n\tcase NFT_META_IIF:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_META, meta,\n\t\t\t\t\tingress_ifindex, sizeof(__u32), reg);\n\t\tbreak;\n\tcase NFT_META_IIFTYPE:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_META, meta,\n\t\t\t\t\tingress_iftype, sizeof(__u16), reg);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nbool nft_meta_get_reduce(struct nft_regs_track *track,\n\t\t\t const struct nft_expr *expr)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tconst struct nft_meta *meta;\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tmeta = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->key != meta->key ||\n\t    priv->dreg != meta->dreg) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn nft_expr_reduce_bitwise(track, expr);\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_reduce);\n\nstatic const struct nft_expr_ops nft_meta_get_ops = {\n\t.type\t\t= &nft_meta_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.eval\t\t= nft_meta_get_eval,\n\t.init\t\t= nft_meta_get_init,\n\t.dump\t\t= nft_meta_get_dump,\n\t.reduce\t\t= nft_meta_get_reduce,\n\t.validate\t= nft_meta_get_validate,\n\t.offload\t= nft_meta_get_offload,\n};\n\nstatic bool nft_meta_set_reduce(struct nft_regs_track *track,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tint i;\n\n\tfor (i = 0; i < NFT_REG32_NUM; i++) {\n\t\tif (!track->regs[i].selector)\n\t\t\tcontinue;\n\n\t\tif (track->regs[i].selector->ops != &nft_meta_get_ops)\n\t\t\tcontinue;\n\n\t\t__nft_reg_track_cancel(track, i);\n\t}\n\n\treturn false;\n}\n\nstatic const struct nft_expr_ops nft_meta_set_ops = {\n\t.type\t\t= &nft_meta_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.eval\t\t= nft_meta_set_eval,\n\t.init\t\t= nft_meta_set_init,\n\t.destroy\t= nft_meta_set_destroy,\n\t.dump\t\t= nft_meta_set_dump,\n\t.reduce\t\t= nft_meta_set_reduce,\n\t.validate\t= nft_meta_set_validate,\n};\n\nstatic const struct nft_expr_ops *\nnft_meta_select_ops(const struct nft_ctx *ctx,\n\t\t    const struct nlattr * const tb[])\n{\n\tif (tb[NFTA_META_KEY] == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tb[NFTA_META_DREG] && tb[NFTA_META_SREG])\n\t\treturn ERR_PTR(-EINVAL);\n\n#if IS_ENABLED(CONFIG_NF_TABLES_BRIDGE) && IS_MODULE(CONFIG_NFT_BRIDGE_META)\n\tif (ctx->family == NFPROTO_BRIDGE)\n\t\treturn ERR_PTR(-EAGAIN);\n#endif\n\tif (tb[NFTA_META_DREG])\n\t\treturn &nft_meta_get_ops;\n\n\tif (tb[NFTA_META_SREG])\n\t\treturn &nft_meta_set_ops;\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int nft_meta_inner_init(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\t\tlen = sizeof(u16);\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tpriv->len = len;\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_META_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\n\nvoid nft_meta_inner_eval(const struct nft_expr *expr,\n\t\t\t struct nft_regs *regs,\n\t\t\t const struct nft_pktinfo *pkt,\n\t\t\t struct nft_inner_tun_ctx *tun_ctx)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tu32 *dest = &regs->data[priv->dreg];\n\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\t\tnft_reg_store16(dest, (__force u16)tun_ctx->llproto);\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tif (!(tun_ctx->flags & NFT_PAYLOAD_CTX_INNER_TH))\n\t\t\tgoto err;\n\n\t\tnft_reg_store8(dest, tun_ctx->l4proto);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tgoto err;\n\t}\n\treturn;\n\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\nEXPORT_SYMBOL_GPL(nft_meta_inner_eval);\n\nstatic const struct nft_expr_ops nft_meta_inner_ops = {\n\t.type\t\t= &nft_meta_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.init\t\t= nft_meta_inner_init,\n\t.dump\t\t= nft_meta_get_dump,\n\t \n};\n\nstruct nft_expr_type nft_meta_type __read_mostly = {\n\t.name\t\t= \"meta\",\n\t.select_ops\t= nft_meta_select_ops,\n\t.inner_ops\t= &nft_meta_inner_ops,\n\t.policy\t\t= nft_meta_policy,\n\t.maxattr\t= NFTA_META_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_NETWORK_SECMARK\nstruct nft_secmark {\n\tu32 secid;\n\tchar *ctx;\n};\n\nstatic const struct nla_policy nft_secmark_policy[NFTA_SECMARK_MAX + 1] = {\n\t[NFTA_SECMARK_CTX]     = { .type = NLA_STRING, .len = NFT_SECMARK_CTX_MAXLEN },\n};\n\nstatic int nft_secmark_compute_secid(struct nft_secmark *priv)\n{\n\tu32 tmp_secid = 0;\n\tint err;\n\n\terr = security_secctx_to_secid(priv->ctx, strlen(priv->ctx), &tmp_secid);\n\tif (err)\n\t\treturn err;\n\n\tif (!tmp_secid)\n\t\treturn -ENOENT;\n\n\terr = security_secmark_relabel_packet(tmp_secid);\n\tif (err)\n\t\treturn err;\n\n\tpriv->secid = tmp_secid;\n\treturn 0;\n}\n\nstatic void nft_secmark_obj_eval(struct nft_object *obj, struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_secmark *priv = nft_obj_data(obj);\n\tstruct sk_buff *skb = pkt->skb;\n\n\tskb->secmark = priv->secid;\n}\n\nstatic int nft_secmark_obj_init(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nlattr * const tb[],\n\t\t\t\tstruct nft_object *obj)\n{\n\tstruct nft_secmark *priv = nft_obj_data(obj);\n\tint err;\n\n\tif (tb[NFTA_SECMARK_CTX] == NULL)\n\t\treturn -EINVAL;\n\n\tpriv->ctx = nla_strdup(tb[NFTA_SECMARK_CTX], GFP_KERNEL);\n\tif (!priv->ctx)\n\t\treturn -ENOMEM;\n\n\terr = nft_secmark_compute_secid(priv);\n\tif (err) {\n\t\tkfree(priv->ctx);\n\t\treturn err;\n\t}\n\n\tsecurity_secmark_refcount_inc();\n\n\treturn 0;\n}\n\nstatic int nft_secmark_obj_dump(struct sk_buff *skb, struct nft_object *obj,\n\t\t\t\tbool reset)\n{\n\tstruct nft_secmark *priv = nft_obj_data(obj);\n\tint err;\n\n\tif (nla_put_string(skb, NFTA_SECMARK_CTX, priv->ctx))\n\t\treturn -1;\n\n\tif (reset) {\n\t\terr = nft_secmark_compute_secid(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void nft_secmark_obj_destroy(const struct nft_ctx *ctx, struct nft_object *obj)\n{\n\tstruct nft_secmark *priv = nft_obj_data(obj);\n\n\tsecurity_secmark_refcount_dec();\n\n\tkfree(priv->ctx);\n}\n\nstatic const struct nft_object_ops nft_secmark_obj_ops = {\n\t.type\t\t= &nft_secmark_obj_type,\n\t.size\t\t= sizeof(struct nft_secmark),\n\t.init\t\t= nft_secmark_obj_init,\n\t.eval\t\t= nft_secmark_obj_eval,\n\t.dump\t\t= nft_secmark_obj_dump,\n\t.destroy\t= nft_secmark_obj_destroy,\n};\nstruct nft_object_type nft_secmark_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_SECMARK,\n\t.ops\t\t= &nft_secmark_obj_ops,\n\t.maxattr\t= NFTA_SECMARK_MAX,\n\t.policy\t\t= nft_secmark_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}