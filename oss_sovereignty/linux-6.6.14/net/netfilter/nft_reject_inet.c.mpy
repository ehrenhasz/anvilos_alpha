{
  "module_name": "nft_reject_inet.c",
  "hash_id": "c713f21df8882cc380ff6841ce545f35e0dcde6fd60f6e3b5b863f0e1e81a7aa",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_reject_inet.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nft_reject.h>\n#include <net/netfilter/ipv4/nf_reject.h>\n#include <net/netfilter/ipv6/nf_reject.h>\n\nstatic void nft_reject_inet_eval(const struct nft_expr *expr,\n\t\t\t\t struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct nft_reject *priv = nft_expr_priv(expr);\n\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tswitch (priv->type) {\n\t\tcase NFT_REJECT_ICMP_UNREACH:\n\t\t\tnf_send_unreach(pkt->skb, priv->icmp_code,\n\t\t\t\t\tnft_hook(pkt));\n\t\t\tbreak;\n\t\tcase NFT_REJECT_TCP_RST:\n\t\t\tnf_send_reset(nft_net(pkt), nft_sk(pkt),\n\t\t\t\t      pkt->skb, nft_hook(pkt));\n\t\t\tbreak;\n\t\tcase NFT_REJECT_ICMPX_UNREACH:\n\t\t\tnf_send_unreach(pkt->skb,\n\t\t\t\t\tnft_reject_icmp_code(priv->icmp_code),\n\t\t\t\t\tnft_hook(pkt));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tswitch (priv->type) {\n\t\tcase NFT_REJECT_ICMP_UNREACH:\n\t\t\tnf_send_unreach6(nft_net(pkt), pkt->skb,\n\t\t\t\t\t priv->icmp_code, nft_hook(pkt));\n\t\t\tbreak;\n\t\tcase NFT_REJECT_TCP_RST:\n\t\t\tnf_send_reset6(nft_net(pkt), nft_sk(pkt),\n\t\t\t\t       pkt->skb, nft_hook(pkt));\n\t\t\tbreak;\n\t\tcase NFT_REJECT_ICMPX_UNREACH:\n\t\t\tnf_send_unreach6(nft_net(pkt), pkt->skb,\n\t\t\t\t\t nft_reject_icmpv6_code(priv->icmp_code),\n\t\t\t\t\t nft_hook(pkt));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tregs->verdict.code = NF_DROP;\n}\n\nstatic int nft_reject_inet_validate(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr,\n\t\t\t\t    const struct nft_data **data)\n{\n\treturn nft_chain_validate_hooks(ctx->chain,\n\t\t\t\t\t(1 << NF_INET_LOCAL_IN) |\n\t\t\t\t\t(1 << NF_INET_FORWARD) |\n\t\t\t\t\t(1 << NF_INET_LOCAL_OUT) |\n\t\t\t\t\t(1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t\t(1 << NF_INET_INGRESS));\n}\n\nstatic struct nft_expr_type nft_reject_inet_type;\nstatic const struct nft_expr_ops nft_reject_inet_ops = {\n\t.type\t\t= &nft_reject_inet_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_reject)),\n\t.eval\t\t= nft_reject_inet_eval,\n\t.init\t\t= nft_reject_init,\n\t.dump\t\t= nft_reject_dump,\n\t.validate\t= nft_reject_inet_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_reject_inet_type __read_mostly = {\n\t.family\t\t= NFPROTO_INET,\n\t.name\t\t= \"reject\",\n\t.ops\t\t= &nft_reject_inet_ops,\n\t.policy\t\t= nft_reject_policy,\n\t.maxattr\t= NFTA_REJECT_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_reject_inet_module_init(void)\n{\n\treturn nft_register_expr(&nft_reject_inet_type);\n}\n\nstatic void __exit nft_reject_inet_module_exit(void)\n{\n\tnft_unregister_expr(&nft_reject_inet_type);\n}\n\nmodule_init(nft_reject_inet_module_init);\nmodule_exit(nft_reject_inet_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_ALIAS_NFT_AF_EXPR(1, \"reject\");\nMODULE_DESCRIPTION(\"Netfilter nftables reject inet support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}