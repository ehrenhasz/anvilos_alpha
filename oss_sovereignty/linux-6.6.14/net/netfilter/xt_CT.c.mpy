{
  "module_name": "xt_CT.c",
  "hash_id": "fbf739ef9d849cc6d3b5edb1de7d28ee575a0ba2d18079b9b08e1c4f8b9f8fe9",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_CT.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_CT.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n\nstatic inline int xt_ct_target(struct sk_buff *skb, struct nf_conn *ct)\n{\n\t \n\tif (skb->_nfct != 0)\n\t\treturn XT_CONTINUE;\n\n\tif (ct) {\n\t\trefcount_inc(&ct->ct_general.use);\n\t\tnf_ct_set(skb, ct, IP_CT_NEW);\n\t} else {\n\t\tnf_ct_set(skb, ct, IP_CT_UNTRACKED);\n\t}\n\n\treturn XT_CONTINUE;\n}\n\nstatic unsigned int xt_ct_target_v0(struct sk_buff *skb,\n\t\t\t\t    const struct xt_action_param *par)\n{\n\tconst struct xt_ct_target_info *info = par->targinfo;\n\tstruct nf_conn *ct = info->ct;\n\n\treturn xt_ct_target(skb, ct);\n}\n\nstatic unsigned int xt_ct_target_v1(struct sk_buff *skb,\n\t\t\t\t    const struct xt_action_param *par)\n{\n\tconst struct xt_ct_target_info_v1 *info = par->targinfo;\n\tstruct nf_conn *ct = info->ct;\n\n\treturn xt_ct_target(skb, ct);\n}\n\nstatic u8 xt_ct_find_proto(const struct xt_tgchk_param *par)\n{\n\tif (par->family == NFPROTO_IPV4) {\n\t\tconst struct ipt_entry *e = par->entryinfo;\n\n\t\tif (e->ip.invflags & IPT_INV_PROTO)\n\t\t\treturn 0;\n\t\treturn e->ip.proto;\n\t} else if (par->family == NFPROTO_IPV6) {\n\t\tconst struct ip6t_entry *e = par->entryinfo;\n\n\t\tif (e->ipv6.invflags & IP6T_INV_PROTO)\n\t\t\treturn 0;\n\t\treturn e->ipv6.proto;\n\t} else\n\t\treturn 0;\n}\n\nstatic int\nxt_ct_set_helper(struct nf_conn *ct, const char *helper_name,\n\t\t const struct xt_tgchk_param *par)\n{\n\tstruct nf_conntrack_helper *helper;\n\tstruct nf_conn_help *help;\n\tu8 proto;\n\n\tproto = xt_ct_find_proto(par);\n\tif (!proto) {\n\t\tpr_info_ratelimited(\"You must specify a L4 protocol and not use inversions on it\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\thelper = nf_conntrack_helper_try_module_get(helper_name, par->family,\n\t\t\t\t\t\t    proto);\n\tif (helper == NULL) {\n\t\tpr_info_ratelimited(\"No such helper \\\"%s\\\"\\n\", helper_name);\n\t\treturn -ENOENT;\n\t}\n\n\thelp = nf_ct_helper_ext_add(ct, GFP_KERNEL);\n\tif (help == NULL) {\n\t\tnf_conntrack_helper_put(helper);\n\t\treturn -ENOMEM;\n\t}\n\n\trcu_assign_pointer(help->helper, helper);\n\treturn 0;\n}\n\nstatic int\nxt_ct_set_timeout(struct nf_conn *ct, const struct xt_tgchk_param *par,\n\t\t  const char *timeout_name)\n{\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tu8 proto;\n\n\tproto = xt_ct_find_proto(par);\n\tif (!proto) {\n\t\tpr_info_ratelimited(\"You must specify a L4 protocol and not \"\n\t\t\t\t    \"use inversions on it\");\n\t\treturn -EINVAL;\n\t}\n\tl4proto = nf_ct_l4proto_find(proto);\n\treturn nf_ct_set_timeout(par->net, ct, par->family, l4proto->l4proto,\n\t\t\t\t timeout_name);\n\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic u16 xt_ct_flags_to_dir(const struct xt_ct_target_info_v1 *info)\n{\n\tswitch (info->flags & (XT_CT_ZONE_DIR_ORIG |\n\t\t\t       XT_CT_ZONE_DIR_REPL)) {\n\tcase XT_CT_ZONE_DIR_ORIG:\n\t\treturn NF_CT_ZONE_DIR_ORIG;\n\tcase XT_CT_ZONE_DIR_REPL:\n\t\treturn NF_CT_ZONE_DIR_REPL;\n\tdefault:\n\t\treturn NF_CT_DEFAULT_ZONE_DIR;\n\t}\n}\n\nstatic void xt_ct_put_helper(struct nf_conn_help *help)\n{\n\tstruct nf_conntrack_helper *helper;\n\n\tif (!help)\n\t\treturn;\n\n\t \n\thelper = rcu_dereference_raw(help->helper);\n\tif (helper)\n\t\tnf_conntrack_helper_put(helper);\n}\n\nstatic int xt_ct_tg_check(const struct xt_tgchk_param *par,\n\t\t\t  struct xt_ct_target_info_v1 *info)\n{\n\tstruct nf_conntrack_zone zone;\n\tstruct nf_conn_help *help;\n\tstruct nf_conn *ct;\n\tint ret = -EOPNOTSUPP;\n\n\tif (info->flags & XT_CT_NOTRACK) {\n\t\tct = NULL;\n\t\tgoto out;\n\t}\n\n#ifndef CONFIG_NF_CONNTRACK_ZONES\n\tif (info->zone || info->flags & (XT_CT_ZONE_DIR_ORIG |\n\t\t\t\t\t XT_CT_ZONE_DIR_REPL |\n\t\t\t\t\t XT_CT_ZONE_MARK))\n\t\tgoto err1;\n#endif\n\n\tret = nf_ct_netns_get(par->net, par->family);\n\tif (ret < 0)\n\t\tgoto err1;\n\n\tmemset(&zone, 0, sizeof(zone));\n\tzone.id = info->zone;\n\tzone.dir = xt_ct_flags_to_dir(info);\n\tif (info->flags & XT_CT_ZONE_MARK)\n\t\tzone.flags |= NF_CT_FLAG_MARK;\n\n\tct = nf_ct_tmpl_alloc(par->net, &zone, GFP_KERNEL);\n\tif (!ct) {\n\t\tret = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tif ((info->ct_events || info->exp_events) &&\n\t    !nf_ct_ecache_ext_add(ct, info->ct_events, info->exp_events,\n\t\t\t\t  GFP_KERNEL)) {\n\t\tret = -EINVAL;\n\t\tgoto err3;\n\t}\n\n\tif (info->helper[0]) {\n\t\tif (strnlen(info->helper, sizeof(info->helper)) == sizeof(info->helper)) {\n\t\t\tret = -ENAMETOOLONG;\n\t\t\tgoto err3;\n\t\t}\n\n\t\tret = xt_ct_set_helper(ct, info->helper, par);\n\t\tif (ret < 0)\n\t\t\tgoto err3;\n\t}\n\n\tif (info->timeout[0]) {\n\t\tif (strnlen(info->timeout, sizeof(info->timeout)) == sizeof(info->timeout)) {\n\t\t\tret = -ENAMETOOLONG;\n\t\t\tgoto err4;\n\t\t}\n\n\t\tret = xt_ct_set_timeout(ct, par, info->timeout);\n\t\tif (ret < 0)\n\t\t\tgoto err4;\n\t}\n\t__set_bit(IPS_CONFIRMED_BIT, &ct->status);\nout:\n\tinfo->ct = ct;\n\treturn 0;\n\nerr4:\n\thelp = nfct_help(ct);\n\txt_ct_put_helper(help);\nerr3:\n\tnf_ct_tmpl_free(ct);\nerr2:\n\tnf_ct_netns_put(par->net, par->family);\nerr1:\n\treturn ret;\n}\n\nstatic int xt_ct_tg_check_v0(const struct xt_tgchk_param *par)\n{\n\tstruct xt_ct_target_info *info = par->targinfo;\n\tstruct xt_ct_target_info_v1 info_v1 = {\n\t\t.flags \t\t= info->flags,\n\t\t.zone\t\t= info->zone,\n\t\t.ct_events\t= info->ct_events,\n\t\t.exp_events\t= info->exp_events,\n\t};\n\tint ret;\n\n\tif (info->flags & ~XT_CT_NOTRACK)\n\t\treturn -EINVAL;\n\n\tmemcpy(info_v1.helper, info->helper, sizeof(info->helper));\n\n\tret = xt_ct_tg_check(par, &info_v1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinfo->ct = info_v1.ct;\n\n\treturn ret;\n}\n\nstatic int xt_ct_tg_check_v1(const struct xt_tgchk_param *par)\n{\n\tstruct xt_ct_target_info_v1 *info = par->targinfo;\n\n\tif (info->flags & ~XT_CT_NOTRACK)\n\t\treturn -EINVAL;\n\n\treturn xt_ct_tg_check(par, par->targinfo);\n}\n\nstatic int xt_ct_tg_check_v2(const struct xt_tgchk_param *par)\n{\n\tstruct xt_ct_target_info_v1 *info = par->targinfo;\n\n\tif (info->flags & ~XT_CT_MASK)\n\t\treturn -EINVAL;\n\n\treturn xt_ct_tg_check(par, par->targinfo);\n}\n\nstatic void xt_ct_tg_destroy(const struct xt_tgdtor_param *par,\n\t\t\t     struct xt_ct_target_info_v1 *info)\n{\n\tstruct nf_conn *ct = info->ct;\n\tstruct nf_conn_help *help;\n\n\tif (ct) {\n\t\thelp = nfct_help(ct);\n\t\txt_ct_put_helper(help);\n\n\t\tnf_ct_netns_put(par->net, par->family);\n\n\t\tnf_ct_destroy_timeout(ct);\n\t\tnf_ct_put(info->ct);\n\t}\n}\n\nstatic void xt_ct_tg_destroy_v0(const struct xt_tgdtor_param *par)\n{\n\tstruct xt_ct_target_info *info = par->targinfo;\n\tstruct xt_ct_target_info_v1 info_v1 = {\n\t\t.flags \t\t= info->flags,\n\t\t.zone\t\t= info->zone,\n\t\t.ct_events\t= info->ct_events,\n\t\t.exp_events\t= info->exp_events,\n\t\t.ct\t\t= info->ct,\n\t};\n\tmemcpy(info_v1.helper, info->helper, sizeof(info->helper));\n\n\txt_ct_tg_destroy(par, &info_v1);\n}\n\nstatic void xt_ct_tg_destroy_v1(const struct xt_tgdtor_param *par)\n{\n\txt_ct_tg_destroy(par, par->targinfo);\n}\n\nstatic struct xt_target xt_ct_tg_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"CT\",\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.targetsize\t= sizeof(struct xt_ct_target_info),\n\t\t.usersize\t= offsetof(struct xt_ct_target_info, ct),\n\t\t.checkentry\t= xt_ct_tg_check_v0,\n\t\t.destroy\t= xt_ct_tg_destroy_v0,\n\t\t.target\t\t= xt_ct_target_v0,\n\t\t.table\t\t= \"raw\",\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"CT\",\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.revision\t= 1,\n\t\t.targetsize\t= sizeof(struct xt_ct_target_info_v1),\n\t\t.usersize\t= offsetof(struct xt_ct_target_info, ct),\n\t\t.checkentry\t= xt_ct_tg_check_v1,\n\t\t.destroy\t= xt_ct_tg_destroy_v1,\n\t\t.target\t\t= xt_ct_target_v1,\n\t\t.table\t\t= \"raw\",\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"CT\",\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.revision\t= 2,\n\t\t.targetsize\t= sizeof(struct xt_ct_target_info_v1),\n\t\t.usersize\t= offsetof(struct xt_ct_target_info, ct),\n\t\t.checkentry\t= xt_ct_tg_check_v2,\n\t\t.destroy\t= xt_ct_tg_destroy_v1,\n\t\t.target\t\t= xt_ct_target_v1,\n\t\t.table\t\t= \"raw\",\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic unsigned int\nnotrack_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\t \n\tif (skb->_nfct != 0)\n\t\treturn XT_CONTINUE;\n\n\tnf_ct_set(skb, NULL, IP_CT_UNTRACKED);\n\n\treturn XT_CONTINUE;\n}\n\nstatic struct xt_target notrack_tg_reg __read_mostly = {\n\t.name\t\t= \"NOTRACK\",\n\t.revision\t= 0,\n\t.family\t\t= NFPROTO_UNSPEC,\n\t.target\t\t= notrack_tg,\n\t.table\t\t= \"raw\",\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init xt_ct_tg_init(void)\n{\n\tint ret;\n\n\tret = xt_register_target(&notrack_tg_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = xt_register_targets(xt_ct_tg_reg, ARRAY_SIZE(xt_ct_tg_reg));\n\tif (ret < 0) {\n\t\txt_unregister_target(&notrack_tg_reg);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void __exit xt_ct_tg_exit(void)\n{\n\txt_unregister_targets(xt_ct_tg_reg, ARRAY_SIZE(xt_ct_tg_reg));\n\txt_unregister_target(&notrack_tg_reg);\n}\n\nmodule_init(xt_ct_tg_init);\nmodule_exit(xt_ct_tg_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Xtables: connection tracking target\");\nMODULE_ALIAS(\"ipt_CT\");\nMODULE_ALIAS(\"ip6t_CT\");\nMODULE_ALIAS(\"ipt_NOTRACK\");\nMODULE_ALIAS(\"ip6t_NOTRACK\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}