{
  "module_name": "nft_set_pipapo.c",
  "hash_id": "e920f0b3d0e91020e49ef9e69b0654d4a3ed42f2d7590081606195c1423995f7",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_set_pipapo.c",
  "human_readable_source": "\n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n\n#include \"nft_set_pipapo_avx2.h\"\n#include \"nft_set_pipapo.h\"\n\n \nstatic DEFINE_PER_CPU(bool, nft_pipapo_scratch_index);\n\n \nint pipapo_refill(unsigned long *map, int len, int rules, unsigned long *dst,\n\t\t  union nft_pipapo_map_bucket *mt, bool match_only)\n{\n\tunsigned long bitset;\n\tint k, ret = -1;\n\n\tfor (k = 0; k < len; k++) {\n\t\tbitset = map[k];\n\t\twhile (bitset) {\n\t\t\tunsigned long t = bitset & -bitset;\n\t\t\tint r = __builtin_ctzl(bitset);\n\t\t\tint i = k * BITS_PER_LONG + r;\n\n\t\t\tif (unlikely(i >= rules)) {\n\t\t\t\tmap[k] = 0;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (match_only) {\n\t\t\t\tbitmap_clear(map, i, 1);\n\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\tret = 0;\n\n\t\t\tbitmap_set(dst, mt[i].to, mt[i].n);\n\n\t\t\tbitset ^= t;\n\t\t}\n\t\tmap[k] = 0;\n\t}\n\n\treturn ret;\n}\n\n \nbool nft_pipapo_lookup(const struct net *net, const struct nft_set *set,\n\t\t       const u32 *key, const struct nft_set_ext **ext)\n{\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\tunsigned long *res_map, *fill_map;\n\tu8 genmask = nft_genmask_cur(net);\n\tconst u8 *rp = (const u8 *)key;\n\tstruct nft_pipapo_match *m;\n\tstruct nft_pipapo_field *f;\n\tbool map_index;\n\tint i;\n\n\tlocal_bh_disable();\n\n\tmap_index = raw_cpu_read(nft_pipapo_scratch_index);\n\n\tm = rcu_dereference(priv->match);\n\n\tif (unlikely(!m || !*raw_cpu_ptr(m->scratch)))\n\t\tgoto out;\n\n\tres_map  = *raw_cpu_ptr(m->scratch) + (map_index ? m->bsize_max : 0);\n\tfill_map = *raw_cpu_ptr(m->scratch) + (map_index ? 0 : m->bsize_max);\n\n\tmemset(res_map, 0xff, m->bsize_max * sizeof(*res_map));\n\n\tnft_pipapo_for_each_field(f, i, m) {\n\t\tbool last = i == m->field_count - 1;\n\t\tint b;\n\n\t\t \n\t\tif (likely(f->bb == 8))\n\t\t\tpipapo_and_field_buckets_8bit(f, res_map, rp);\n\t\telse\n\t\t\tpipapo_and_field_buckets_4bit(f, res_map, rp);\n\t\tNFT_PIPAPO_GROUP_BITS_ARE_8_OR_4;\n\n\t\trp += f->groups / NFT_PIPAPO_GROUPS_PER_BYTE(f);\n\n\t\t \nnext_match:\n\t\tb = pipapo_refill(res_map, f->bsize, f->rules, fill_map, f->mt,\n\t\t\t\t  last);\n\t\tif (b < 0) {\n\t\t\traw_cpu_write(nft_pipapo_scratch_index, map_index);\n\t\t\tlocal_bh_enable();\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (last) {\n\t\t\t*ext = &f->mt[b].e->ext;\n\t\t\tif (unlikely(nft_set_elem_expired(*ext) ||\n\t\t\t\t     !nft_set_elem_active(*ext, genmask)))\n\t\t\t\tgoto next_match;\n\n\t\t\t \n\t\t\traw_cpu_write(nft_pipapo_scratch_index, map_index);\n\t\t\tlocal_bh_enable();\n\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\tmap_index = !map_index;\n\t\tswap(res_map, fill_map);\n\n\t\trp += NFT_PIPAPO_GROUPS_PADDING(f);\n\t}\n\nout:\n\tlocal_bh_enable();\n\treturn false;\n}\n\n \nstatic struct nft_pipapo_elem *pipapo_get(const struct net *net,\n\t\t\t\t\t  const struct nft_set *set,\n\t\t\t\t\t  const u8 *data, u8 genmask)\n{\n\tstruct nft_pipapo_elem *ret = ERR_PTR(-ENOENT);\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\tstruct nft_pipapo_match *m = priv->clone;\n\tunsigned long *res_map, *fill_map = NULL;\n\tstruct nft_pipapo_field *f;\n\tint i;\n\n\tres_map = kmalloc_array(m->bsize_max, sizeof(*res_map), GFP_ATOMIC);\n\tif (!res_map) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfill_map = kcalloc(m->bsize_max, sizeof(*res_map), GFP_ATOMIC);\n\tif (!fill_map) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tmemset(res_map, 0xff, m->bsize_max * sizeof(*res_map));\n\n\tnft_pipapo_for_each_field(f, i, m) {\n\t\tbool last = i == m->field_count - 1;\n\t\tint b;\n\n\t\t \n\t\tif (f->bb == 8)\n\t\t\tpipapo_and_field_buckets_8bit(f, res_map, data);\n\t\telse if (f->bb == 4)\n\t\t\tpipapo_and_field_buckets_4bit(f, res_map, data);\n\t\telse\n\t\t\tBUG();\n\n\t\tdata += f->groups / NFT_PIPAPO_GROUPS_PER_BYTE(f);\n\n\t\t \nnext_match:\n\t\tb = pipapo_refill(res_map, f->bsize, f->rules, fill_map, f->mt,\n\t\t\t\t  last);\n\t\tif (b < 0)\n\t\t\tgoto out;\n\n\t\tif (last) {\n\t\t\tif (nft_set_elem_expired(&f->mt[b].e->ext))\n\t\t\t\tgoto next_match;\n\t\t\tif ((genmask &&\n\t\t\t     !nft_set_elem_active(&f->mt[b].e->ext, genmask)))\n\t\t\t\tgoto next_match;\n\n\t\t\tret = f->mt[b].e;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata += NFT_PIPAPO_GROUPS_PADDING(f);\n\n\t\t \n\t\tswap(res_map, fill_map);\n\t}\n\nout:\n\tkfree(fill_map);\n\tkfree(res_map);\n\treturn ret;\n}\n\n \nstatic void *nft_pipapo_get(const struct net *net, const struct nft_set *set,\n\t\t\t    const struct nft_set_elem *elem, unsigned int flags)\n{\n\treturn pipapo_get(net, set, (const u8 *)elem->key.val.data,\n\t\t\t nft_genmask_cur(net));\n}\n\n \nstatic int pipapo_resize(struct nft_pipapo_field *f, int old_rules, int rules)\n{\n\tlong *new_lt = NULL, *new_p, *old_lt = f->lt, *old_p;\n\tunion nft_pipapo_map_bucket *new_mt, *old_mt = f->mt;\n\tsize_t new_bucket_size, copy;\n\tint group, bucket;\n\n\tnew_bucket_size = DIV_ROUND_UP(rules, BITS_PER_LONG);\n#ifdef NFT_PIPAPO_ALIGN\n\tnew_bucket_size = roundup(new_bucket_size,\n\t\t\t\t  NFT_PIPAPO_ALIGN / sizeof(*new_lt));\n#endif\n\n\tif (new_bucket_size == f->bsize)\n\t\tgoto mt;\n\n\tif (new_bucket_size > f->bsize)\n\t\tcopy = f->bsize;\n\telse\n\t\tcopy = new_bucket_size;\n\n\tnew_lt = kvzalloc(f->groups * NFT_PIPAPO_BUCKETS(f->bb) *\n\t\t\t  new_bucket_size * sizeof(*new_lt) +\n\t\t\t  NFT_PIPAPO_ALIGN_HEADROOM,\n\t\t\t  GFP_KERNEL);\n\tif (!new_lt)\n\t\treturn -ENOMEM;\n\n\tnew_p = NFT_PIPAPO_LT_ALIGN(new_lt);\n\told_p = NFT_PIPAPO_LT_ALIGN(old_lt);\n\n\tfor (group = 0; group < f->groups; group++) {\n\t\tfor (bucket = 0; bucket < NFT_PIPAPO_BUCKETS(f->bb); bucket++) {\n\t\t\tmemcpy(new_p, old_p, copy * sizeof(*new_p));\n\t\t\tnew_p += copy;\n\t\t\told_p += copy;\n\n\t\t\tif (new_bucket_size > f->bsize)\n\t\t\t\tnew_p += new_bucket_size - f->bsize;\n\t\t\telse\n\t\t\t\told_p += f->bsize - new_bucket_size;\n\t\t}\n\t}\n\nmt:\n\tnew_mt = kvmalloc(rules * sizeof(*new_mt), GFP_KERNEL);\n\tif (!new_mt) {\n\t\tkvfree(new_lt);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(new_mt, f->mt, min(old_rules, rules) * sizeof(*new_mt));\n\tif (rules > old_rules) {\n\t\tmemset(new_mt + old_rules, 0,\n\t\t       (rules - old_rules) * sizeof(*new_mt));\n\t}\n\n\tif (new_lt) {\n\t\tf->bsize = new_bucket_size;\n\t\tNFT_PIPAPO_LT_ASSIGN(f, new_lt);\n\t\tkvfree(old_lt);\n\t}\n\n\tf->mt = new_mt;\n\tkvfree(old_mt);\n\n\treturn 0;\n}\n\n \nstatic void pipapo_bucket_set(struct nft_pipapo_field *f, int rule, int group,\n\t\t\t      int v)\n{\n\tunsigned long *pos;\n\n\tpos = NFT_PIPAPO_LT_ALIGN(f->lt);\n\tpos += f->bsize * NFT_PIPAPO_BUCKETS(f->bb) * group;\n\tpos += f->bsize * v;\n\n\t__set_bit(rule, pos);\n}\n\n \nstatic void pipapo_lt_4b_to_8b(int old_groups, int bsize,\n\t\t\t       unsigned long *old_lt, unsigned long *new_lt)\n{\n\tint g, b, i;\n\n\tfor (g = 0; g < old_groups / 2; g++) {\n\t\tint src_g0 = g * 2, src_g1 = g * 2 + 1;\n\n\t\tfor (b = 0; b < NFT_PIPAPO_BUCKETS(8); b++) {\n\t\t\tint src_b0 = b / NFT_PIPAPO_BUCKETS(4);\n\t\t\tint src_b1 = b % NFT_PIPAPO_BUCKETS(4);\n\t\t\tint src_i0 = src_g0 * NFT_PIPAPO_BUCKETS(4) + src_b0;\n\t\t\tint src_i1 = src_g1 * NFT_PIPAPO_BUCKETS(4) + src_b1;\n\n\t\t\tfor (i = 0; i < bsize; i++) {\n\t\t\t\t*new_lt = old_lt[src_i0 * bsize + i] &\n\t\t\t\t\t  old_lt[src_i1 * bsize + i];\n\t\t\t\tnew_lt++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void pipapo_lt_8b_to_4b(int old_groups, int bsize,\n\t\t\t       unsigned long *old_lt, unsigned long *new_lt)\n{\n\tint g, b, bsrc, i;\n\n\tmemset(new_lt, 0, old_groups * 2 * NFT_PIPAPO_BUCKETS(4) * bsize *\n\t\t\t  sizeof(unsigned long));\n\n\tfor (g = 0; g < old_groups * 2; g += 2) {\n\t\tint src_g = g / 2;\n\n\t\tfor (b = 0; b < NFT_PIPAPO_BUCKETS(4); b++) {\n\t\t\tfor (bsrc = NFT_PIPAPO_BUCKETS(8) * src_g;\n\t\t\t     bsrc < NFT_PIPAPO_BUCKETS(8) * (src_g + 1);\n\t\t\t     bsrc++) {\n\t\t\t\tif (((bsrc & 0xf0) >> 4) != b)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (i = 0; i < bsize; i++)\n\t\t\t\t\tnew_lt[i] |= old_lt[bsrc * bsize + i];\n\t\t\t}\n\n\t\t\tnew_lt += bsize;\n\t\t}\n\n\t\tfor (b = 0; b < NFT_PIPAPO_BUCKETS(4); b++) {\n\t\t\tfor (bsrc = NFT_PIPAPO_BUCKETS(8) * src_g;\n\t\t\t     bsrc < NFT_PIPAPO_BUCKETS(8) * (src_g + 1);\n\t\t\t     bsrc++) {\n\t\t\t\tif ((bsrc & 0x0f) != b)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (i = 0; i < bsize; i++)\n\t\t\t\t\tnew_lt[i] |= old_lt[bsrc * bsize + i];\n\t\t\t}\n\n\t\t\tnew_lt += bsize;\n\t\t}\n\t}\n}\n\n \nstatic void pipapo_lt_bits_adjust(struct nft_pipapo_field *f)\n{\n\tunsigned long *new_lt;\n\tint groups, bb;\n\tsize_t lt_size;\n\n\tlt_size = f->groups * NFT_PIPAPO_BUCKETS(f->bb) * f->bsize *\n\t\t  sizeof(*f->lt);\n\n\tif (f->bb == NFT_PIPAPO_GROUP_BITS_SMALL_SET &&\n\t    lt_size > NFT_PIPAPO_LT_SIZE_HIGH) {\n\t\tgroups = f->groups * 2;\n\t\tbb = NFT_PIPAPO_GROUP_BITS_LARGE_SET;\n\n\t\tlt_size = groups * NFT_PIPAPO_BUCKETS(bb) * f->bsize *\n\t\t\t  sizeof(*f->lt);\n\t} else if (f->bb == NFT_PIPAPO_GROUP_BITS_LARGE_SET &&\n\t\t   lt_size < NFT_PIPAPO_LT_SIZE_LOW) {\n\t\tgroups = f->groups / 2;\n\t\tbb = NFT_PIPAPO_GROUP_BITS_SMALL_SET;\n\n\t\tlt_size = groups * NFT_PIPAPO_BUCKETS(bb) * f->bsize *\n\t\t\t  sizeof(*f->lt);\n\n\t\t \n\t\tif (lt_size > NFT_PIPAPO_LT_SIZE_HIGH)\n\t\t\treturn;\n\t} else {\n\t\treturn;\n\t}\n\n\tnew_lt = kvzalloc(lt_size + NFT_PIPAPO_ALIGN_HEADROOM, GFP_KERNEL);\n\tif (!new_lt)\n\t\treturn;\n\n\tNFT_PIPAPO_GROUP_BITS_ARE_8_OR_4;\n\tif (f->bb == 4 && bb == 8) {\n\t\tpipapo_lt_4b_to_8b(f->groups, f->bsize,\n\t\t\t\t   NFT_PIPAPO_LT_ALIGN(f->lt),\n\t\t\t\t   NFT_PIPAPO_LT_ALIGN(new_lt));\n\t} else if (f->bb == 8 && bb == 4) {\n\t\tpipapo_lt_8b_to_4b(f->groups, f->bsize,\n\t\t\t\t   NFT_PIPAPO_LT_ALIGN(f->lt),\n\t\t\t\t   NFT_PIPAPO_LT_ALIGN(new_lt));\n\t} else {\n\t\tBUG();\n\t}\n\n\tf->groups = groups;\n\tf->bb = bb;\n\tkvfree(f->lt);\n\tNFT_PIPAPO_LT_ASSIGN(f, new_lt);\n}\n\n \nstatic int pipapo_insert(struct nft_pipapo_field *f, const uint8_t *k,\n\t\t\t int mask_bits)\n{\n\tint rule = f->rules, group, ret, bit_offset = 0;\n\n\tret = pipapo_resize(f, f->rules, f->rules + 1);\n\tif (ret)\n\t\treturn ret;\n\n\tf->rules++;\n\n\tfor (group = 0; group < f->groups; group++) {\n\t\tint i, v;\n\t\tu8 mask;\n\n\t\tv = k[group / (BITS_PER_BYTE / f->bb)];\n\t\tv &= GENMASK(BITS_PER_BYTE - bit_offset - 1, 0);\n\t\tv >>= (BITS_PER_BYTE - bit_offset) - f->bb;\n\n\t\tbit_offset += f->bb;\n\t\tbit_offset %= BITS_PER_BYTE;\n\n\t\tif (mask_bits >= (group + 1) * f->bb) {\n\t\t\t \n\t\t\tpipapo_bucket_set(f, rule, group, v);\n\t\t} else if (mask_bits <= group * f->bb) {\n\t\t\t \n\t\t\tfor (i = 0; i < NFT_PIPAPO_BUCKETS(f->bb); i++)\n\t\t\t\tpipapo_bucket_set(f, rule, group, i);\n\t\t} else {\n\t\t\t \n\t\t\tmask = GENMASK(f->bb - 1, 0);\n\t\t\tmask >>= mask_bits - group * f->bb;\n\t\t\tfor (i = 0; i < NFT_PIPAPO_BUCKETS(f->bb); i++) {\n\t\t\t\tif ((i & ~mask) == (v & ~mask))\n\t\t\t\t\tpipapo_bucket_set(f, rule, group, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tpipapo_lt_bits_adjust(f);\n\n\treturn 1;\n}\n\n \nstatic bool pipapo_step_diff(u8 *base, int step, int len)\n{\n\t \n#ifdef __BIG_ENDIAN__\n\treturn !(BIT(step % BITS_PER_BYTE) & base[step / BITS_PER_BYTE]);\n#else\n\treturn !(BIT(step % BITS_PER_BYTE) &\n\t\t base[len - 1 - step / BITS_PER_BYTE]);\n#endif\n}\n\n \nstatic bool pipapo_step_after_end(const u8 *base, const u8 *end, int step,\n\t\t\t\t  int len)\n{\n\tu8 tmp[NFT_PIPAPO_MAX_BYTES];\n\tint i;\n\n\tmemcpy(tmp, base, len);\n\n\t \n\tfor (i = 0; i <= step; i++)\n#ifdef __BIG_ENDIAN__\n\t\ttmp[i / BITS_PER_BYTE] |= BIT(i % BITS_PER_BYTE);\n#else\n\t\ttmp[len - 1 - i / BITS_PER_BYTE] |= BIT(i % BITS_PER_BYTE);\n#endif\n\n\treturn memcmp(tmp, end, len) > 0;\n}\n\n \nstatic void pipapo_base_sum(u8 *base, int step, int len)\n{\n\tbool carry = false;\n\tint i;\n\n\t \n#ifdef __BIG_ENDIAN__\n\tfor (i = step / BITS_PER_BYTE; i < len; i++) {\n#else\n\tfor (i = len - 1 - step / BITS_PER_BYTE; i >= 0; i--) {\n#endif\n\t\tif (carry)\n\t\t\tbase[i]++;\n\t\telse\n\t\t\tbase[i] += 1 << (step % BITS_PER_BYTE);\n\n\t\tif (base[i])\n\t\t\tbreak;\n\n\t\tcarry = true;\n\t}\n}\n\n \nstatic int pipapo_expand(struct nft_pipapo_field *f,\n\t\t\t const u8 *start, const u8 *end, int len)\n{\n\tint step, masks = 0, bytes = DIV_ROUND_UP(len, BITS_PER_BYTE);\n\tu8 base[NFT_PIPAPO_MAX_BYTES];\n\n\tmemcpy(base, start, bytes);\n\twhile (memcmp(base, end, bytes) <= 0) {\n\t\tint err;\n\n\t\tstep = 0;\n\t\twhile (pipapo_step_diff(base, step, bytes)) {\n\t\t\tif (pipapo_step_after_end(base, end, step, bytes))\n\t\t\t\tbreak;\n\n\t\t\tstep++;\n\t\t\tif (step >= len) {\n\t\t\t\tif (!masks) {\n\t\t\t\t\terr = pipapo_insert(f, base, 0);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tmasks = 1;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\terr = pipapo_insert(f, base, len - step);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmasks++;\n\t\tpipapo_base_sum(base, step, bytes);\n\t}\nout:\n\treturn masks;\n}\n\n \nstatic void pipapo_map(struct nft_pipapo_match *m,\n\t\t       union nft_pipapo_map_bucket map[NFT_PIPAPO_MAX_FIELDS],\n\t\t       struct nft_pipapo_elem *e)\n{\n\tstruct nft_pipapo_field *f;\n\tint i, j;\n\n\tfor (i = 0, f = m->f; i < m->field_count - 1; i++, f++) {\n\t\tfor (j = 0; j < map[i].n; j++) {\n\t\t\tf->mt[map[i].to + j].to = map[i + 1].to;\n\t\t\tf->mt[map[i].to + j].n = map[i + 1].n;\n\t\t}\n\t}\n\n\t \n\tfor (j = 0; j < map[i].n; j++)\n\t\tf->mt[map[i].to + j].e = e;\n}\n\n \nstatic int pipapo_realloc_scratch(struct nft_pipapo_match *clone,\n\t\t\t\t  unsigned long bsize_max)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tunsigned long *scratch;\n#ifdef NFT_PIPAPO_ALIGN\n\t\tunsigned long *scratch_aligned;\n#endif\n\n\t\tscratch = kzalloc_node(bsize_max * sizeof(*scratch) * 2 +\n\t\t\t\t       NFT_PIPAPO_ALIGN_HEADROOM,\n\t\t\t\t       GFP_KERNEL, cpu_to_node(i));\n\t\tif (!scratch) {\n\t\t\t \n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tkfree(*per_cpu_ptr(clone->scratch, i));\n\n\t\t*per_cpu_ptr(clone->scratch, i) = scratch;\n\n#ifdef NFT_PIPAPO_ALIGN\n\t\tscratch_aligned = NFT_PIPAPO_LT_ALIGN(scratch);\n\t\t*per_cpu_ptr(clone->scratch_aligned, i) = scratch_aligned;\n#endif\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nft_pipapo_insert(const struct net *net, const struct nft_set *set,\n\t\t\t     const struct nft_set_elem *elem,\n\t\t\t     struct nft_set_ext **ext2)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\tunion nft_pipapo_map_bucket rulemap[NFT_PIPAPO_MAX_FIELDS];\n\tconst u8 *start = (const u8 *)elem->key.val.data, *end;\n\tstruct nft_pipapo_elem *e = elem->priv, *dup;\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\tstruct nft_pipapo_match *m = priv->clone;\n\tu8 genmask = nft_genmask_next(net);\n\tstruct nft_pipapo_field *f;\n\tconst u8 *start_p, *end_p;\n\tint i, bsize_max, err = 0;\n\n\tif (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END))\n\t\tend = (const u8 *)nft_set_ext_key_end(ext)->data;\n\telse\n\t\tend = start;\n\n\tdup = pipapo_get(net, set, start, genmask);\n\tif (!IS_ERR(dup)) {\n\t\t \n\t\tconst struct nft_data *dup_key, *dup_end;\n\n\t\tdup_key = nft_set_ext_key(&dup->ext);\n\t\tif (nft_set_ext_exists(&dup->ext, NFT_SET_EXT_KEY_END))\n\t\t\tdup_end = nft_set_ext_key_end(&dup->ext);\n\t\telse\n\t\t\tdup_end = dup_key;\n\n\t\tif (!memcmp(start, dup_key->data, sizeof(*dup_key->data)) &&\n\t\t    !memcmp(end, dup_end->data, sizeof(*dup_end->data))) {\n\t\t\t*ext2 = &dup->ext;\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\treturn -ENOTEMPTY;\n\t}\n\n\tif (PTR_ERR(dup) == -ENOENT) {\n\t\t \n\t\tdup = pipapo_get(net, set, end, nft_genmask_next(net));\n\t}\n\n\tif (PTR_ERR(dup) != -ENOENT) {\n\t\tif (IS_ERR(dup))\n\t\t\treturn PTR_ERR(dup);\n\t\t*ext2 = &dup->ext;\n\t\treturn -ENOTEMPTY;\n\t}\n\n\t \n\tstart_p = start;\n\tend_p = end;\n\tnft_pipapo_for_each_field(f, i, m) {\n\t\tif (f->rules >= (unsigned long)NFT_PIPAPO_RULE0_MAX)\n\t\t\treturn -ENOSPC;\n\n\t\tif (memcmp(start_p, end_p,\n\t\t\t   f->groups / NFT_PIPAPO_GROUPS_PER_BYTE(f)) > 0)\n\t\t\treturn -EINVAL;\n\n\t\tstart_p += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);\n\t\tend_p += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);\n\t}\n\n\t \n\tpriv->dirty = true;\n\n\tbsize_max = m->bsize_max;\n\n\tnft_pipapo_for_each_field(f, i, m) {\n\t\tint ret;\n\n\t\trulemap[i].to = f->rules;\n\n\t\tret = memcmp(start, end,\n\t\t\t     f->groups / NFT_PIPAPO_GROUPS_PER_BYTE(f));\n\t\tif (!ret)\n\t\t\tret = pipapo_insert(f, start, f->groups * f->bb);\n\t\telse\n\t\t\tret = pipapo_expand(f, start, end, f->groups * f->bb);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (f->bsize > bsize_max)\n\t\t\tbsize_max = f->bsize;\n\n\t\trulemap[i].n = ret;\n\n\t\tstart += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);\n\t\tend += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);\n\t}\n\n\tif (!*get_cpu_ptr(m->scratch) || bsize_max > m->bsize_max) {\n\t\tput_cpu_ptr(m->scratch);\n\n\t\terr = pipapo_realloc_scratch(m, bsize_max);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tm->bsize_max = bsize_max;\n\t} else {\n\t\tput_cpu_ptr(m->scratch);\n\t}\n\n\t*ext2 = &e->ext;\n\n\tpipapo_map(m, rulemap, e);\n\n\treturn 0;\n}\n\n \nstatic struct nft_pipapo_match *pipapo_clone(struct nft_pipapo_match *old)\n{\n\tstruct nft_pipapo_field *dst, *src;\n\tstruct nft_pipapo_match *new;\n\tint i;\n\n\tnew = kmalloc(struct_size(new, f, old->field_count), GFP_KERNEL);\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew->field_count = old->field_count;\n\tnew->bsize_max = old->bsize_max;\n\n\tnew->scratch = alloc_percpu(*new->scratch);\n\tif (!new->scratch)\n\t\tgoto out_scratch;\n\n#ifdef NFT_PIPAPO_ALIGN\n\tnew->scratch_aligned = alloc_percpu(*new->scratch_aligned);\n\tif (!new->scratch_aligned)\n\t\tgoto out_scratch;\n#endif\n\tfor_each_possible_cpu(i)\n\t\t*per_cpu_ptr(new->scratch, i) = NULL;\n\n\tif (pipapo_realloc_scratch(new, old->bsize_max))\n\t\tgoto out_scratch_realloc;\n\n\trcu_head_init(&new->rcu);\n\n\tsrc = old->f;\n\tdst = new->f;\n\n\tfor (i = 0; i < old->field_count; i++) {\n\t\tunsigned long *new_lt;\n\n\t\tmemcpy(dst, src, offsetof(struct nft_pipapo_field, lt));\n\n\t\tnew_lt = kvzalloc(src->groups * NFT_PIPAPO_BUCKETS(src->bb) *\n\t\t\t\t  src->bsize * sizeof(*dst->lt) +\n\t\t\t\t  NFT_PIPAPO_ALIGN_HEADROOM,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!new_lt)\n\t\t\tgoto out_lt;\n\n\t\tNFT_PIPAPO_LT_ASSIGN(dst, new_lt);\n\n\t\tmemcpy(NFT_PIPAPO_LT_ALIGN(new_lt),\n\t\t       NFT_PIPAPO_LT_ALIGN(src->lt),\n\t\t       src->bsize * sizeof(*dst->lt) *\n\t\t       src->groups * NFT_PIPAPO_BUCKETS(src->bb));\n\n\t\tdst->mt = kvmalloc(src->rules * sizeof(*src->mt), GFP_KERNEL);\n\t\tif (!dst->mt)\n\t\t\tgoto out_mt;\n\n\t\tmemcpy(dst->mt, src->mt, src->rules * sizeof(*src->mt));\n\t\tsrc++;\n\t\tdst++;\n\t}\n\n\treturn new;\n\nout_mt:\n\tkvfree(dst->lt);\nout_lt:\n\tfor (dst--; i > 0; i--) {\n\t\tkvfree(dst->mt);\n\t\tkvfree(dst->lt);\n\t\tdst--;\n\t}\nout_scratch_realloc:\n\tfor_each_possible_cpu(i)\n\t\tkfree(*per_cpu_ptr(new->scratch, i));\n#ifdef NFT_PIPAPO_ALIGN\n\tfree_percpu(new->scratch_aligned);\n#endif\nout_scratch:\n\tfree_percpu(new->scratch);\n\tkfree(new);\n\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nstatic int pipapo_rules_same_key(struct nft_pipapo_field *f, int first)\n{\n\tstruct nft_pipapo_elem *e = NULL;  \n\tint r;\n\n\tfor (r = first; r < f->rules; r++) {\n\t\tif (r != first && e != f->mt[r].e)\n\t\t\treturn r - first;\n\n\t\te = f->mt[r].e;\n\t}\n\n\tif (r != first)\n\t\treturn r - first;\n\n\treturn 0;\n}\n\n \nstatic void pipapo_unmap(union nft_pipapo_map_bucket *mt, int rules,\n\t\t\t int start, int n, int to_offset, bool is_last)\n{\n\tint i;\n\n\tmemmove(mt + start, mt + start + n, (rules - start - n) * sizeof(*mt));\n\tmemset(mt + rules - n, 0, n * sizeof(*mt));\n\n\tif (is_last)\n\t\treturn;\n\n\tfor (i = start; i < rules - n; i++)\n\t\tmt[i].to -= to_offset;\n}\n\n \nstatic void pipapo_drop(struct nft_pipapo_match *m,\n\t\t\tunion nft_pipapo_map_bucket rulemap[])\n{\n\tstruct nft_pipapo_field *f;\n\tint i;\n\n\tnft_pipapo_for_each_field(f, i, m) {\n\t\tint g;\n\n\t\tfor (g = 0; g < f->groups; g++) {\n\t\t\tunsigned long *pos;\n\t\t\tint b;\n\n\t\t\tpos = NFT_PIPAPO_LT_ALIGN(f->lt) + g *\n\t\t\t      NFT_PIPAPO_BUCKETS(f->bb) * f->bsize;\n\n\t\t\tfor (b = 0; b < NFT_PIPAPO_BUCKETS(f->bb); b++) {\n\t\t\t\tbitmap_cut(pos, pos, rulemap[i].to,\n\t\t\t\t\t   rulemap[i].n,\n\t\t\t\t\t   f->bsize * BITS_PER_LONG);\n\n\t\t\t\tpos += f->bsize;\n\t\t\t}\n\t\t}\n\n\t\tpipapo_unmap(f->mt, f->rules, rulemap[i].to, rulemap[i].n,\n\t\t\t     rulemap[i + 1].n, i == m->field_count - 1);\n\t\tif (pipapo_resize(f, f->rules, f->rules - rulemap[i].n)) {\n\t\t\t \n\t\t\t;\n\t\t}\n\t\tf->rules -= rulemap[i].n;\n\n\t\tpipapo_lt_bits_adjust(f);\n\t}\n}\n\nstatic void nft_pipapo_gc_deactivate(struct net *net, struct nft_set *set,\n\t\t\t\t     struct nft_pipapo_elem *e)\n\n{\n\tstruct nft_set_elem elem = {\n\t\t.priv\t= e,\n\t};\n\n\tnft_setelem_data_deactivate(net, set, &elem);\n}\n\n \nstatic void pipapo_gc(const struct nft_set *_set, struct nft_pipapo_match *m)\n{\n\tstruct nft_set *set = (struct nft_set *) _set;\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\tstruct net *net = read_pnet(&set->net);\n\tint rules_f0, first_rule = 0;\n\tstruct nft_pipapo_elem *e;\n\tstruct nft_trans_gc *gc;\n\n\tgc = nft_trans_gc_alloc(set, 0, GFP_KERNEL);\n\tif (!gc)\n\t\treturn;\n\n\twhile ((rules_f0 = pipapo_rules_same_key(m->f, first_rule))) {\n\t\tunion nft_pipapo_map_bucket rulemap[NFT_PIPAPO_MAX_FIELDS];\n\t\tstruct nft_pipapo_field *f;\n\t\tint i, start, rules_fx;\n\n\t\tstart = first_rule;\n\t\trules_fx = rules_f0;\n\n\t\tnft_pipapo_for_each_field(f, i, m) {\n\t\t\trulemap[i].to = start;\n\t\t\trulemap[i].n = rules_fx;\n\n\t\t\tif (i < m->field_count - 1) {\n\t\t\t\trules_fx = f->mt[start].n;\n\t\t\t\tstart = f->mt[start].to;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tf--;\n\t\ti--;\n\t\te = f->mt[rulemap[i].to].e;\n\n\t\t \n\t\tif (nft_set_elem_expired(&e->ext)) {\n\t\t\tpriv->dirty = true;\n\n\t\t\tgc = nft_trans_gc_queue_sync(gc, GFP_ATOMIC);\n\t\t\tif (!gc)\n\t\t\t\treturn;\n\n\t\t\tnft_pipapo_gc_deactivate(net, set, e);\n\t\t\tpipapo_drop(m, rulemap);\n\t\t\tnft_trans_gc_elem_add(gc, e);\n\n\t\t\t \n\t\t} else {\n\t\t\tfirst_rule += rules_f0;\n\t\t}\n\t}\n\n\tgc = nft_trans_gc_catchall_sync(gc);\n\tif (gc) {\n\t\tnft_trans_gc_queue_sync_done(gc);\n\t\tpriv->last_gc = jiffies;\n\t}\n}\n\n \nstatic void pipapo_free_fields(struct nft_pipapo_match *m)\n{\n\tstruct nft_pipapo_field *f;\n\tint i;\n\n\tnft_pipapo_for_each_field(f, i, m) {\n\t\tkvfree(f->lt);\n\t\tkvfree(f->mt);\n\t}\n}\n\nstatic void pipapo_free_match(struct nft_pipapo_match *m)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\tkfree(*per_cpu_ptr(m->scratch, i));\n\n#ifdef NFT_PIPAPO_ALIGN\n\tfree_percpu(m->scratch_aligned);\n#endif\n\tfree_percpu(m->scratch);\n\n\tpipapo_free_fields(m);\n\n\tkfree(m);\n}\n\n \nstatic void pipapo_reclaim_match(struct rcu_head *rcu)\n{\n\tstruct nft_pipapo_match *m;\n\n\tm = container_of(rcu, struct nft_pipapo_match, rcu);\n\tpipapo_free_match(m);\n}\n\n \nstatic void nft_pipapo_commit(const struct nft_set *set)\n{\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\tstruct nft_pipapo_match *new_clone, *old;\n\n\tif (time_after_eq(jiffies, priv->last_gc + nft_set_gc_interval(set)))\n\t\tpipapo_gc(set, priv->clone);\n\n\tif (!priv->dirty)\n\t\treturn;\n\n\tnew_clone = pipapo_clone(priv->clone);\n\tif (IS_ERR(new_clone))\n\t\treturn;\n\n\tpriv->dirty = false;\n\n\told = rcu_access_pointer(priv->match);\n\trcu_assign_pointer(priv->match, priv->clone);\n\tif (old)\n\t\tcall_rcu(&old->rcu, pipapo_reclaim_match);\n\n\tpriv->clone = new_clone;\n}\n\nstatic bool nft_pipapo_transaction_mutex_held(const struct nft_set *set)\n{\n#ifdef CONFIG_PROVE_LOCKING\n\tconst struct net *net = read_pnet(&set->net);\n\n\treturn lockdep_is_held(&nft_pernet(net)->commit_mutex);\n#else\n\treturn true;\n#endif\n}\n\nstatic void nft_pipapo_abort(const struct nft_set *set)\n{\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\tstruct nft_pipapo_match *new_clone, *m;\n\n\tif (!priv->dirty)\n\t\treturn;\n\n\tm = rcu_dereference_protected(priv->match, nft_pipapo_transaction_mutex_held(set));\n\n\tnew_clone = pipapo_clone(m);\n\tif (IS_ERR(new_clone))\n\t\treturn;\n\n\tpriv->dirty = false;\n\n\tpipapo_free_match(priv->clone);\n\tpriv->clone = new_clone;\n}\n\n \nstatic void nft_pipapo_activate(const struct net *net,\n\t\t\t\tconst struct nft_set *set,\n\t\t\t\tconst struct nft_set_elem *elem)\n{\n\tstruct nft_pipapo_elem *e = elem->priv;\n\n\tnft_set_elem_change_active(net, set, &e->ext);\n}\n\n \nstatic void *pipapo_deactivate(const struct net *net, const struct nft_set *set,\n\t\t\t       const u8 *data, const struct nft_set_ext *ext)\n{\n\tstruct nft_pipapo_elem *e;\n\n\te = pipapo_get(net, set, data, nft_genmask_next(net));\n\tif (IS_ERR(e))\n\t\treturn NULL;\n\n\tnft_set_elem_change_active(net, set, &e->ext);\n\n\treturn e;\n}\n\n \nstatic void *nft_pipapo_deactivate(const struct net *net,\n\t\t\t\t   const struct nft_set *set,\n\t\t\t\t   const struct nft_set_elem *elem)\n{\n\tconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\n\n\treturn pipapo_deactivate(net, set, (const u8 *)elem->key.val.data, ext);\n}\n\n \nstatic bool nft_pipapo_flush(const struct net *net, const struct nft_set *set,\n\t\t\t     void *elem)\n{\n\tstruct nft_pipapo_elem *e = elem;\n\n\treturn pipapo_deactivate(net, set, (const u8 *)nft_set_ext_key(&e->ext),\n\t\t\t\t &e->ext);\n}\n\n \nstatic int pipapo_get_boundaries(struct nft_pipapo_field *f, int first_rule,\n\t\t\t\t int rule_count, u8 *left, u8 *right)\n{\n\tint g, mask_len = 0, bit_offset = 0;\n\tu8 *l = left, *r = right;\n\n\tfor (g = 0; g < f->groups; g++) {\n\t\tint b, x0, x1;\n\n\t\tx0 = -1;\n\t\tx1 = -1;\n\t\tfor (b = 0; b < NFT_PIPAPO_BUCKETS(f->bb); b++) {\n\t\t\tunsigned long *pos;\n\n\t\t\tpos = NFT_PIPAPO_LT_ALIGN(f->lt) +\n\t\t\t      (g * NFT_PIPAPO_BUCKETS(f->bb) + b) * f->bsize;\n\t\t\tif (test_bit(first_rule, pos) && x0 == -1)\n\t\t\t\tx0 = b;\n\t\t\tif (test_bit(first_rule + rule_count - 1, pos))\n\t\t\t\tx1 = b;\n\t\t}\n\n\t\t*l |= x0 << (BITS_PER_BYTE - f->bb - bit_offset);\n\t\t*r |= x1 << (BITS_PER_BYTE - f->bb - bit_offset);\n\n\t\tbit_offset += f->bb;\n\t\tif (bit_offset >= BITS_PER_BYTE) {\n\t\t\tbit_offset %= BITS_PER_BYTE;\n\t\t\tl++;\n\t\t\tr++;\n\t\t}\n\n\t\tif (x1 - x0 == 0)\n\t\t\tmask_len += 4;\n\t\telse if (x1 - x0 == 1)\n\t\t\tmask_len += 3;\n\t\telse if (x1 - x0 == 3)\n\t\t\tmask_len += 2;\n\t\telse if (x1 - x0 == 7)\n\t\t\tmask_len += 1;\n\t}\n\n\treturn mask_len;\n}\n\n \nstatic bool pipapo_match_field(struct nft_pipapo_field *f,\n\t\t\t       int first_rule, int rule_count,\n\t\t\t       const u8 *start, const u8 *end)\n{\n\tu8 right[NFT_PIPAPO_MAX_BYTES] = { 0 };\n\tu8 left[NFT_PIPAPO_MAX_BYTES] = { 0 };\n\n\tpipapo_get_boundaries(f, first_rule, rule_count, left, right);\n\n\treturn !memcmp(start, left,\n\t\t       f->groups / NFT_PIPAPO_GROUPS_PER_BYTE(f)) &&\n\t       !memcmp(end, right, f->groups / NFT_PIPAPO_GROUPS_PER_BYTE(f));\n}\n\n \nstatic void nft_pipapo_remove(const struct net *net, const struct nft_set *set,\n\t\t\t      const struct nft_set_elem *elem)\n{\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\tstruct nft_pipapo_match *m = priv->clone;\n\tstruct nft_pipapo_elem *e = elem->priv;\n\tint rules_f0, first_rule = 0;\n\tconst u8 *data;\n\n\tdata = (const u8 *)nft_set_ext_key(&e->ext);\n\n\twhile ((rules_f0 = pipapo_rules_same_key(m->f, first_rule))) {\n\t\tunion nft_pipapo_map_bucket rulemap[NFT_PIPAPO_MAX_FIELDS];\n\t\tconst u8 *match_start, *match_end;\n\t\tstruct nft_pipapo_field *f;\n\t\tint i, start, rules_fx;\n\n\t\tmatch_start = data;\n\n\t\tif (nft_set_ext_exists(&e->ext, NFT_SET_EXT_KEY_END))\n\t\t\tmatch_end = (const u8 *)nft_set_ext_key_end(&e->ext)->data;\n\t\telse\n\t\t\tmatch_end = data;\n\n\t\tstart = first_rule;\n\t\trules_fx = rules_f0;\n\n\t\tnft_pipapo_for_each_field(f, i, m) {\n\t\t\tif (!pipapo_match_field(f, start, rules_fx,\n\t\t\t\t\t\tmatch_start, match_end))\n\t\t\t\tbreak;\n\n\t\t\trulemap[i].to = start;\n\t\t\trulemap[i].n = rules_fx;\n\n\t\t\trules_fx = f->mt[start].n;\n\t\t\tstart = f->mt[start].to;\n\n\t\t\tmatch_start += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);\n\t\t\tmatch_end += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);\n\t\t}\n\n\t\tif (i == m->field_count) {\n\t\t\tpriv->dirty = true;\n\t\t\tpipapo_drop(m, rulemap);\n\t\t\treturn;\n\t\t}\n\n\t\tfirst_rule += rules_f0;\n\t}\n}\n\n \nstatic void nft_pipapo_walk(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    struct nft_set_iter *iter)\n{\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\tstruct net *net = read_pnet(&set->net);\n\tstruct nft_pipapo_match *m;\n\tstruct nft_pipapo_field *f;\n\tint i, r;\n\n\trcu_read_lock();\n\tif (iter->genmask == nft_genmask_cur(net))\n\t\tm = rcu_dereference(priv->match);\n\telse\n\t\tm = priv->clone;\n\n\tif (unlikely(!m))\n\t\tgoto out;\n\n\tfor (i = 0, f = m->f; i < m->field_count - 1; i++, f++)\n\t\t;\n\n\tfor (r = 0; r < f->rules; r++) {\n\t\tstruct nft_pipapo_elem *e;\n\t\tstruct nft_set_elem elem;\n\n\t\tif (r < f->rules - 1 && f->mt[r + 1].e == f->mt[r].e)\n\t\t\tcontinue;\n\n\t\tif (iter->count < iter->skip)\n\t\t\tgoto cont;\n\n\t\te = f->mt[r].e;\n\n\t\tif (!nft_set_elem_active(&e->ext, iter->genmask))\n\t\t\tgoto cont;\n\n\t\telem.priv = e;\n\n\t\titer->err = iter->fn(ctx, set, iter, &elem);\n\t\tif (iter->err < 0)\n\t\t\tgoto out;\n\ncont:\n\t\titer->count++;\n\t}\n\nout:\n\trcu_read_unlock();\n}\n\n \nstatic u64 nft_pipapo_privsize(const struct nlattr * const nla[],\n\t\t\t       const struct nft_set_desc *desc)\n{\n\treturn sizeof(struct nft_pipapo);\n}\n\n \nstatic bool nft_pipapo_estimate(const struct nft_set_desc *desc, u32 features,\n\t\t\t\tstruct nft_set_estimate *est)\n{\n\tif (!(features & NFT_SET_INTERVAL) ||\n\t    desc->field_count < NFT_PIPAPO_MIN_FIELDS)\n\t\treturn false;\n\n\test->size = pipapo_estimate_size(desc);\n\tif (!est->size)\n\t\treturn false;\n\n\test->lookup = NFT_SET_CLASS_O_LOG_N;\n\n\test->space = NFT_SET_CLASS_O_N;\n\n\treturn true;\n}\n\n \nstatic int nft_pipapo_init(const struct nft_set *set,\n\t\t\t   const struct nft_set_desc *desc,\n\t\t\t   const struct nlattr * const nla[])\n{\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\tstruct nft_pipapo_match *m;\n\tstruct nft_pipapo_field *f;\n\tint err, i, field_count;\n\n\tfield_count = desc->field_count ? : 1;\n\n\tif (field_count > NFT_PIPAPO_MAX_FIELDS)\n\t\treturn -EINVAL;\n\n\tm = kmalloc(struct_size(m, f, field_count), GFP_KERNEL);\n\tif (!m)\n\t\treturn -ENOMEM;\n\n\tm->field_count = field_count;\n\tm->bsize_max = 0;\n\n\tm->scratch = alloc_percpu(unsigned long *);\n\tif (!m->scratch) {\n\t\terr = -ENOMEM;\n\t\tgoto out_scratch;\n\t}\n\tfor_each_possible_cpu(i)\n\t\t*per_cpu_ptr(m->scratch, i) = NULL;\n\n#ifdef NFT_PIPAPO_ALIGN\n\tm->scratch_aligned = alloc_percpu(unsigned long *);\n\tif (!m->scratch_aligned) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tfor_each_possible_cpu(i)\n\t\t*per_cpu_ptr(m->scratch_aligned, i) = NULL;\n#endif\n\n\trcu_head_init(&m->rcu);\n\n\tnft_pipapo_for_each_field(f, i, m) {\n\t\tint len = desc->field_len[i] ? : set->klen;\n\n\t\tf->bb = NFT_PIPAPO_GROUP_BITS_INIT;\n\t\tf->groups = len * NFT_PIPAPO_GROUPS_PER_BYTE(f);\n\n\t\tpriv->width += round_up(len, sizeof(u32));\n\n\t\tf->bsize = 0;\n\t\tf->rules = 0;\n\t\tNFT_PIPAPO_LT_ASSIGN(f, NULL);\n\t\tf->mt = NULL;\n\t}\n\n\t \n\tpriv->clone = pipapo_clone(m);\n\tif (IS_ERR(priv->clone)) {\n\t\terr = PTR_ERR(priv->clone);\n\t\tgoto out_free;\n\t}\n\n\tpriv->dirty = false;\n\n\trcu_assign_pointer(priv->match, m);\n\n\treturn 0;\n\nout_free:\n#ifdef NFT_PIPAPO_ALIGN\n\tfree_percpu(m->scratch_aligned);\n#endif\n\tfree_percpu(m->scratch);\nout_scratch:\n\tkfree(m);\n\n\treturn err;\n}\n\n \nstatic void nft_set_pipapo_match_destroy(const struct nft_ctx *ctx,\n\t\t\t\t\t const struct nft_set *set,\n\t\t\t\t\t struct nft_pipapo_match *m)\n{\n\tstruct nft_pipapo_field *f;\n\tint i, r;\n\n\tfor (i = 0, f = m->f; i < m->field_count - 1; i++, f++)\n\t\t;\n\n\tfor (r = 0; r < f->rules; r++) {\n\t\tstruct nft_pipapo_elem *e;\n\n\t\tif (r < f->rules - 1 && f->mt[r + 1].e == f->mt[r].e)\n\t\t\tcontinue;\n\n\t\te = f->mt[r].e;\n\n\t\tnf_tables_set_elem_destroy(ctx, set, e);\n\t}\n}\n\n \nstatic void nft_pipapo_destroy(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_set *set)\n{\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\tstruct nft_pipapo_match *m;\n\tint cpu;\n\n\tm = rcu_dereference_protected(priv->match, true);\n\tif (m) {\n\t\trcu_barrier();\n\n\t\tnft_set_pipapo_match_destroy(ctx, set, m);\n\n#ifdef NFT_PIPAPO_ALIGN\n\t\tfree_percpu(m->scratch_aligned);\n#endif\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tkfree(*per_cpu_ptr(m->scratch, cpu));\n\t\tfree_percpu(m->scratch);\n\t\tpipapo_free_fields(m);\n\t\tkfree(m);\n\t\tpriv->match = NULL;\n\t}\n\n\tif (priv->clone) {\n\t\tm = priv->clone;\n\n\t\tif (priv->dirty)\n\t\t\tnft_set_pipapo_match_destroy(ctx, set, m);\n\n#ifdef NFT_PIPAPO_ALIGN\n\t\tfree_percpu(priv->clone->scratch_aligned);\n#endif\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tkfree(*per_cpu_ptr(priv->clone->scratch, cpu));\n\t\tfree_percpu(priv->clone->scratch);\n\n\t\tpipapo_free_fields(priv->clone);\n\t\tkfree(priv->clone);\n\t\tpriv->clone = NULL;\n\t}\n}\n\n \nstatic void nft_pipapo_gc_init(const struct nft_set *set)\n{\n\tstruct nft_pipapo *priv = nft_set_priv(set);\n\n\tpriv->last_gc = jiffies;\n}\n\nconst struct nft_set_type nft_set_pipapo_type = {\n\t.features\t= NFT_SET_INTERVAL | NFT_SET_MAP | NFT_SET_OBJECT |\n\t\t\t  NFT_SET_TIMEOUT,\n\t.ops\t\t= {\n\t\t.lookup\t\t= nft_pipapo_lookup,\n\t\t.insert\t\t= nft_pipapo_insert,\n\t\t.activate\t= nft_pipapo_activate,\n\t\t.deactivate\t= nft_pipapo_deactivate,\n\t\t.flush\t\t= nft_pipapo_flush,\n\t\t.remove\t\t= nft_pipapo_remove,\n\t\t.walk\t\t= nft_pipapo_walk,\n\t\t.get\t\t= nft_pipapo_get,\n\t\t.privsize\t= nft_pipapo_privsize,\n\t\t.estimate\t= nft_pipapo_estimate,\n\t\t.init\t\t= nft_pipapo_init,\n\t\t.destroy\t= nft_pipapo_destroy,\n\t\t.gc_init\t= nft_pipapo_gc_init,\n\t\t.commit\t\t= nft_pipapo_commit,\n\t\t.abort\t\t= nft_pipapo_abort,\n\t\t.elemsize\t= offsetof(struct nft_pipapo_elem, ext),\n\t},\n};\n\n#if defined(CONFIG_X86_64) && !defined(CONFIG_UML)\nconst struct nft_set_type nft_set_pipapo_avx2_type = {\n\t.features\t= NFT_SET_INTERVAL | NFT_SET_MAP | NFT_SET_OBJECT |\n\t\t\t  NFT_SET_TIMEOUT,\n\t.ops\t\t= {\n\t\t.lookup\t\t= nft_pipapo_avx2_lookup,\n\t\t.insert\t\t= nft_pipapo_insert,\n\t\t.activate\t= nft_pipapo_activate,\n\t\t.deactivate\t= nft_pipapo_deactivate,\n\t\t.flush\t\t= nft_pipapo_flush,\n\t\t.remove\t\t= nft_pipapo_remove,\n\t\t.walk\t\t= nft_pipapo_walk,\n\t\t.get\t\t= nft_pipapo_get,\n\t\t.privsize\t= nft_pipapo_privsize,\n\t\t.estimate\t= nft_pipapo_avx2_estimate,\n\t\t.init\t\t= nft_pipapo_init,\n\t\t.destroy\t= nft_pipapo_destroy,\n\t\t.gc_init\t= nft_pipapo_gc_init,\n\t\t.commit\t\t= nft_pipapo_commit,\n\t\t.abort\t\t= nft_pipapo_abort,\n\t\t.elemsize\t= offsetof(struct nft_pipapo_elem, ext),\n\t},\n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}