{
  "module_name": "xt_HL.c",
  "hash_id": "d073777338228c6f08448d4c4c6ed37e10fb36c781085fef488780b4ee7d4f81",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_HL.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/checksum.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv4/ipt_TTL.h>\n#include <linux/netfilter_ipv6/ip6t_HL.h>\n\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_AUTHOR(\"Maciej Soltysiak <solt@dns.toxicfilms.tv>\");\nMODULE_DESCRIPTION(\"Xtables: Hoplimit/TTL Limit field modification target\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int\nttl_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tstruct iphdr *iph;\n\tconst struct ipt_TTL_info *info = par->targinfo;\n\tint new_ttl;\n\n\tif (skb_ensure_writable(skb, sizeof(*iph)))\n\t\treturn NF_DROP;\n\n\tiph = ip_hdr(skb);\n\n\tswitch (info->mode) {\n\tcase IPT_TTL_SET:\n\t\tnew_ttl = info->ttl;\n\t\tbreak;\n\tcase IPT_TTL_INC:\n\t\tnew_ttl = iph->ttl + info->ttl;\n\t\tif (new_ttl > 255)\n\t\t\tnew_ttl = 255;\n\t\tbreak;\n\tcase IPT_TTL_DEC:\n\t\tnew_ttl = iph->ttl - info->ttl;\n\t\tif (new_ttl < 0)\n\t\t\tnew_ttl = 0;\n\t\tbreak;\n\tdefault:\n\t\tnew_ttl = iph->ttl;\n\t\tbreak;\n\t}\n\n\tif (new_ttl != iph->ttl) {\n\t\tcsum_replace2(&iph->check, htons(iph->ttl << 8),\n\t\t\t\t\t   htons(new_ttl << 8));\n\t\tiph->ttl = new_ttl;\n\t}\n\n\treturn XT_CONTINUE;\n}\n\nstatic unsigned int\nhl_tg6(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tstruct ipv6hdr *ip6h;\n\tconst struct ip6t_HL_info *info = par->targinfo;\n\tint new_hl;\n\n\tif (skb_ensure_writable(skb, sizeof(*ip6h)))\n\t\treturn NF_DROP;\n\n\tip6h = ipv6_hdr(skb);\n\n\tswitch (info->mode) {\n\tcase IP6T_HL_SET:\n\t\tnew_hl = info->hop_limit;\n\t\tbreak;\n\tcase IP6T_HL_INC:\n\t\tnew_hl = ip6h->hop_limit + info->hop_limit;\n\t\tif (new_hl > 255)\n\t\t\tnew_hl = 255;\n\t\tbreak;\n\tcase IP6T_HL_DEC:\n\t\tnew_hl = ip6h->hop_limit - info->hop_limit;\n\t\tif (new_hl < 0)\n\t\t\tnew_hl = 0;\n\t\tbreak;\n\tdefault:\n\t\tnew_hl = ip6h->hop_limit;\n\t\tbreak;\n\t}\n\n\tip6h->hop_limit = new_hl;\n\n\treturn XT_CONTINUE;\n}\n\nstatic int ttl_tg_check(const struct xt_tgchk_param *par)\n{\n\tconst struct ipt_TTL_info *info = par->targinfo;\n\n\tif (info->mode > IPT_TTL_MAXMODE)\n\t\treturn -EINVAL;\n\tif (info->mode != IPT_TTL_SET && info->ttl == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int hl_tg6_check(const struct xt_tgchk_param *par)\n{\n\tconst struct ip6t_HL_info *info = par->targinfo;\n\n\tif (info->mode > IP6T_HL_MAXMODE)\n\t\treturn -EINVAL;\n\tif (info->mode != IP6T_HL_SET && info->hop_limit == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct xt_target hl_tg_reg[] __read_mostly = {\n\t{\n\t\t.name       = \"TTL\",\n\t\t.revision   = 0,\n\t\t.family     = NFPROTO_IPV4,\n\t\t.target     = ttl_tg,\n\t\t.targetsize = sizeof(struct ipt_TTL_info),\n\t\t.table      = \"mangle\",\n\t\t.checkentry = ttl_tg_check,\n\t\t.me         = THIS_MODULE,\n\t},\n\t{\n\t\t.name       = \"HL\",\n\t\t.revision   = 0,\n\t\t.family     = NFPROTO_IPV6,\n\t\t.target     = hl_tg6,\n\t\t.targetsize = sizeof(struct ip6t_HL_info),\n\t\t.table      = \"mangle\",\n\t\t.checkentry = hl_tg6_check,\n\t\t.me         = THIS_MODULE,\n\t},\n};\n\nstatic int __init hl_tg_init(void)\n{\n\treturn xt_register_targets(hl_tg_reg, ARRAY_SIZE(hl_tg_reg));\n}\n\nstatic void __exit hl_tg_exit(void)\n{\n\txt_unregister_targets(hl_tg_reg, ARRAY_SIZE(hl_tg_reg));\n}\n\nmodule_init(hl_tg_init);\nmodule_exit(hl_tg_exit);\nMODULE_ALIAS(\"ipt_TTL\");\nMODULE_ALIAS(\"ip6t_HL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}