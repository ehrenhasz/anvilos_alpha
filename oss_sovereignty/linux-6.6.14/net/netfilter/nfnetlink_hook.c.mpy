{
  "module_name": "nfnetlink_hook.c",
  "hash_id": "9a230d36ae4c58c4fb9c1168a55840a7d5320bdcfb5c46a70c869b28841e936d",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nfnetlink_hook.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/netlink.h>\n#include <linux/slab.h>\n\n#include <linux/netfilter.h>\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_hook.h>\n\n#include <net/netfilter/nf_tables.h>\n#include <net/sock.h>\n\nstatic const struct nla_policy nfnl_hook_nla_policy[NFNLA_HOOK_MAX + 1] = {\n\t[NFNLA_HOOK_HOOKNUM]\t= { .type = NLA_U32 },\n\t[NFNLA_HOOK_PRIORITY]\t= { .type = NLA_U32 },\n\t[NFNLA_HOOK_DEV]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = IFNAMSIZ - 1 },\n\t[NFNLA_HOOK_FUNCTION_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t       .len = KSYM_NAME_LEN, },\n\t[NFNLA_HOOK_MODULE_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t     .len = MODULE_NAME_LEN, },\n\t[NFNLA_HOOK_CHAIN_INFO] = { .type = NLA_NESTED, },\n};\n\nstatic int nf_netlink_dump_start_rcu(struct sock *nlsk, struct sk_buff *skb,\n\t\t\t\t     const struct nlmsghdr *nlh,\n\t\t\t\t     struct netlink_dump_control *c)\n{\n\tint err;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -EINVAL;\n\n\trcu_read_unlock();\n\terr = netlink_dump_start(nlsk, skb, nlh, c);\n\trcu_read_lock();\n\tmodule_put(THIS_MODULE);\n\n\treturn err;\n}\n\nstruct nfnl_dump_hook_data {\n\tchar devname[IFNAMSIZ];\n\tunsigned long headv;\n\tu8 hook;\n};\n\nstatic struct nlattr *nfnl_start_info_type(struct sk_buff *nlskb, enum nfnl_hook_chaintype t)\n{\n\tstruct nlattr *nest = nla_nest_start(nlskb, NFNLA_HOOK_CHAIN_INFO);\n\tint ret;\n\n\tif (!nest)\n\t\treturn NULL;\n\n\tret = nla_put_be32(nlskb, NFNLA_HOOK_INFO_TYPE, htonl(t));\n\tif (ret == 0)\n\t\treturn nest;\n\n\tnla_nest_cancel(nlskb, nest);\n\treturn NULL;\n}\n\nstatic int nfnl_hook_put_bpf_prog_info(struct sk_buff *nlskb,\n\t\t\t\t       const struct nfnl_dump_hook_data *ctx,\n\t\t\t\t       unsigned int seq,\n\t\t\t\t       const struct bpf_prog *prog)\n{\n\tstruct nlattr *nest, *nest2;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_NETFILTER_BPF_LINK))\n\t\treturn 0;\n\n\tif (WARN_ON_ONCE(!prog))\n\t\treturn 0;\n\n\tnest = nfnl_start_info_type(nlskb, NFNL_HOOK_TYPE_BPF);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tnest2 = nla_nest_start(nlskb, NFNLA_HOOK_INFO_DESC);\n\tif (!nest2)\n\t\tgoto cancel_nest;\n\n\tret = nla_put_be32(nlskb, NFNLA_HOOK_BPF_ID, htonl(prog->aux->id));\n\tif (ret)\n\t\tgoto cancel_nest;\n\n\tnla_nest_end(nlskb, nest2);\n\tnla_nest_end(nlskb, nest);\n\treturn 0;\n\ncancel_nest:\n\tnla_nest_cancel(nlskb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfnl_hook_put_nft_chain_info(struct sk_buff *nlskb,\n\t\t\t\t\tconst struct nfnl_dump_hook_data *ctx,\n\t\t\t\t\tunsigned int seq,\n\t\t\t\t\tstruct nft_chain *chain)\n{\n\tstruct net *net = sock_net(nlskb->sk);\n\tstruct nlattr *nest, *nest2;\n\tint ret = 0;\n\n\tif (WARN_ON_ONCE(!chain))\n\t\treturn 0;\n\n\tif (!nft_is_active(net, chain))\n\t\treturn 0;\n\n\tnest = nfnl_start_info_type(nlskb, NFNL_HOOK_TYPE_NFTABLES);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tnest2 = nla_nest_start(nlskb, NFNLA_HOOK_INFO_DESC);\n\tif (!nest2)\n\t\tgoto cancel_nest;\n\n\tret = nla_put_string(nlskb, NFNLA_CHAIN_TABLE, chain->table->name);\n\tif (ret)\n\t\tgoto cancel_nest;\n\n\tret = nla_put_string(nlskb, NFNLA_CHAIN_NAME, chain->name);\n\tif (ret)\n\t\tgoto cancel_nest;\n\n\tret = nla_put_u8(nlskb, NFNLA_CHAIN_FAMILY, chain->table->family);\n\tif (ret)\n\t\tgoto cancel_nest;\n\n\tnla_nest_end(nlskb, nest2);\n\tnla_nest_end(nlskb, nest);\n\treturn ret;\n\ncancel_nest:\n\tnla_nest_cancel(nlskb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfnl_hook_dump_one(struct sk_buff *nlskb,\n\t\t\t      const struct nfnl_dump_hook_data *ctx,\n\t\t\t      const struct nf_hook_ops *ops,\n\t\t\t      int family, unsigned int seq)\n{\n\tu16 event = nfnl_msg_type(NFNL_SUBSYS_HOOK, NFNL_MSG_HOOK_GET);\n\tunsigned int portid = NETLINK_CB(nlskb).portid;\n\tstruct nlmsghdr *nlh;\n\tint ret = -EMSGSIZE;\n\tu32 hooknum;\n#ifdef CONFIG_KALLSYMS\n\tchar sym[KSYM_SYMBOL_LEN];\n\tchar *module_name;\n#endif\n\tnlh = nfnl_msg_put(nlskb, portid, seq, event,\n\t\t\t   NLM_F_MULTI, family, NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_KALLSYMS\n\tret = snprintf(sym, sizeof(sym), \"%ps\", ops->hook);\n\tif (ret >= sizeof(sym)) {\n\t\tret = -EINVAL;\n\t\tgoto nla_put_failure;\n\t}\n\n\tmodule_name = strstr(sym, \" [\");\n\tif (module_name) {\n\t\tchar *end;\n\n\t\t*module_name = '\\0';\n\t\tmodule_name += 2;\n\t\tend = strchr(module_name, ']');\n\t\tif (end) {\n\t\t\t*end = 0;\n\n\t\t\tret = nla_put_string(nlskb, NFNLA_HOOK_MODULE_NAME, module_name);\n\t\t\tif (ret)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tret = nla_put_string(nlskb, NFNLA_HOOK_FUNCTION_NAME, sym);\n\tif (ret)\n\t\tgoto nla_put_failure;\n#endif\n\n\tif (ops->pf == NFPROTO_INET && ops->hooknum == NF_INET_INGRESS)\n\t\thooknum = NF_NETDEV_INGRESS;\n\telse\n\t\thooknum = ops->hooknum;\n\n\tret = nla_put_be32(nlskb, NFNLA_HOOK_HOOKNUM, htonl(hooknum));\n\tif (ret)\n\t\tgoto nla_put_failure;\n\n\tret = nla_put_be32(nlskb, NFNLA_HOOK_PRIORITY, htonl(ops->priority));\n\tif (ret)\n\t\tgoto nla_put_failure;\n\n\tswitch (ops->hook_ops_type) {\n\tcase NF_HOOK_OP_NF_TABLES:\n\t\tret = nfnl_hook_put_nft_chain_info(nlskb, ctx, seq, ops->priv);\n\t\tbreak;\n\tcase NF_HOOK_OP_BPF:\n\t\tret = nfnl_hook_put_bpf_prog_info(nlskb, ctx, seq, ops->priv);\n\t\tbreak;\n\tcase NF_HOOK_OP_UNDEFINED:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(nlskb, nlh);\n\treturn 0;\nnla_put_failure:\n\tnlmsg_trim(nlskb, nlh);\n\treturn ret;\n}\n\nstatic const struct nf_hook_entries *\nnfnl_hook_entries_head(u8 pf, unsigned int hook, struct net *net, const char *dev)\n{\n\tconst struct nf_hook_entries *hook_head = NULL;\n#if defined(CONFIG_NETFILTER_INGRESS) || defined(CONFIG_NETFILTER_EGRESS)\n\tstruct net_device *netdev;\n#endif\n\n\tswitch (pf) {\n\tcase NFPROTO_IPV4:\n\t\tif (hook >= ARRAY_SIZE(net->nf.hooks_ipv4))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\thook_head = rcu_dereference(net->nf.hooks_ipv4[hook]);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tif (hook >= ARRAY_SIZE(net->nf.hooks_ipv6))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\thook_head = rcu_dereference(net->nf.hooks_ipv6[hook]);\n\t\tbreak;\n\tcase NFPROTO_ARP:\n#ifdef CONFIG_NETFILTER_FAMILY_ARP\n\t\tif (hook >= ARRAY_SIZE(net->nf.hooks_arp))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\thook_head = rcu_dereference(net->nf.hooks_arp[hook]);\n#endif\n\t\tbreak;\n\tcase NFPROTO_BRIDGE:\n#ifdef CONFIG_NETFILTER_FAMILY_BRIDGE\n\t\tif (hook >= ARRAY_SIZE(net->nf.hooks_bridge))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\thook_head = rcu_dereference(net->nf.hooks_bridge[hook]);\n#endif\n\t\tbreak;\n#if defined(CONFIG_NETFILTER_INGRESS) || defined(CONFIG_NETFILTER_EGRESS)\n\tcase NFPROTO_NETDEV:\n\t\tif (hook >= NF_NETDEV_NUMHOOKS)\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\t\tif (!dev)\n\t\t\treturn ERR_PTR(-ENODEV);\n\n\t\tnetdev = dev_get_by_name_rcu(net, dev);\n\t\tif (!netdev)\n\t\t\treturn ERR_PTR(-ENODEV);\n\n#ifdef CONFIG_NETFILTER_INGRESS\n\t\tif (hook == NF_NETDEV_INGRESS)\n\t\t\treturn rcu_dereference(netdev->nf_hooks_ingress);\n#endif\n#ifdef CONFIG_NETFILTER_EGRESS\n\t\tif (hook == NF_NETDEV_EGRESS)\n\t\t\treturn rcu_dereference(netdev->nf_hooks_egress);\n#endif\n\t\tfallthrough;\n#endif\n\tdefault:\n\t\treturn ERR_PTR(-EPROTONOSUPPORT);\n\t}\n\n\treturn hook_head;\n}\n\nstatic int nfnl_hook_dump(struct sk_buff *nlskb,\n\t\t\t  struct netlink_callback *cb)\n{\n\tstruct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tstruct nfnl_dump_hook_data *ctx = cb->data;\n\tint err, family = nfmsg->nfgen_family;\n\tstruct net *net = sock_net(nlskb->sk);\n\tstruct nf_hook_ops * const *ops;\n\tconst struct nf_hook_entries *e;\n\tunsigned int i = cb->args[0];\n\n\trcu_read_lock();\n\n\te = nfnl_hook_entries_head(family, ctx->hook, net, ctx->devname);\n\tif (!e)\n\t\tgoto done;\n\n\tif (IS_ERR(e)) {\n\t\tcb->seq++;\n\t\tgoto done;\n\t}\n\n\tif ((unsigned long)e != ctx->headv || i >= e->num_hook_entries)\n\t\tcb->seq++;\n\n\tops = nf_hook_entries_get_hook_ops(e);\n\n\tfor (; i < e->num_hook_entries; i++) {\n\t\terr = nfnl_hook_dump_one(nlskb, ctx, ops[i], family,\n\t\t\t\t\t cb->nlh->nlmsg_seq);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\ndone:\n\tnl_dump_check_consistent(cb, nlmsg_hdr(nlskb));\n\trcu_read_unlock();\n\tcb->args[0] = i;\n\treturn nlskb->len;\n}\n\nstatic int nfnl_hook_dump_start(struct netlink_callback *cb)\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tconst struct nlattr * const *nla = cb->data;\n\tstruct nfnl_dump_hook_data *ctx = NULL;\n\tstruct net *net = sock_net(cb->skb->sk);\n\tu8 family = nfmsg->nfgen_family;\n\tchar name[IFNAMSIZ] = \"\";\n\tconst void *head;\n\tu32 hooknum;\n\n\thooknum = ntohl(nla_get_be32(nla[NFNLA_HOOK_HOOKNUM]));\n\tif (hooknum > 255)\n\t\treturn -EINVAL;\n\n\tif (family == NFPROTO_NETDEV) {\n\t\tif (!nla[NFNLA_HOOK_DEV])\n\t\t\treturn -EINVAL;\n\n\t\tnla_strscpy(name, nla[NFNLA_HOOK_DEV], sizeof(name));\n\t}\n\n\trcu_read_lock();\n\t \n\thead = nfnl_hook_entries_head(family, hooknum, net, name);\n\trcu_read_unlock();\n\n\tif (head && IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tstrscpy(ctx->devname, name, sizeof(ctx->devname));\n\tctx->headv = (unsigned long)head;\n\tctx->hook = hooknum;\n\n\tcb->seq = 1;\n\tcb->data = ctx;\n\n\treturn 0;\n}\n\nstatic int nfnl_hook_dump_stop(struct netlink_callback *cb)\n{\n\tkfree(cb->data);\n\treturn 0;\n}\n\nstatic int nfnl_hook_get(struct sk_buff *skb,\n\t\t\t const struct nfnl_info *info,\n\t\t\t const struct nlattr * const nla[])\n{\n\tif (!nla[NFNLA_HOOK_HOOKNUM])\n\t\treturn -EINVAL;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = nfnl_hook_dump_start,\n\t\t\t.done = nfnl_hook_dump_stop,\n\t\t\t.dump = nfnl_hook_dump,\n\t\t\t.module = THIS_MODULE,\n\t\t\t.data = (void *)nla,\n\t\t};\n\n\t\treturn nf_netlink_dump_start_rcu(info->sk, skb, info->nlh, &c);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct nfnl_callback nfnl_hook_cb[NFNL_MSG_HOOK_MAX] = {\n\t[NFNL_MSG_HOOK_GET] = {\n\t\t.call\t\t= nfnl_hook_get,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFNLA_HOOK_MAX,\n\t\t.policy\t\t= nfnl_hook_nla_policy\n\t},\n};\n\nstatic const struct nfnetlink_subsystem nfhook_subsys = {\n\t.name\t\t\t\t= \"nfhook\",\n\t.subsys_id\t\t\t= NFNL_SUBSYS_HOOK,\n\t.cb_count\t\t\t= NFNL_MSG_HOOK_MAX,\n\t.cb\t\t\t\t= nfnl_hook_cb,\n};\n\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_HOOK);\n\nstatic int __init nfnetlink_hook_init(void)\n{\n\treturn nfnetlink_subsys_register(&nfhook_subsys);\n}\n\nstatic void __exit nfnetlink_hook_exit(void)\n{\n\tnfnetlink_subsys_unregister(&nfhook_subsys);\n}\n\nmodule_init(nfnetlink_hook_init);\nmodule_exit(nfnetlink_hook_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Florian Westphal <fw@strlen.de>\");\nMODULE_DESCRIPTION(\"nfnetlink_hook: list registered netfilter hooks\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}