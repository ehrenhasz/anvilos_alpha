{
  "module_name": "xt_limit.c",
  "hash_id": "87a4e03cd93892455908510977d547c49c6bfce0765384eb05e0a3ebdb504d77",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_limit.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/interrupt.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_limit.h>\n\nstruct xt_limit_priv {\n\tunsigned long prev;\n\tu32 credit;\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Herve Eychenne <rv@wallfire.org>\");\nMODULE_DESCRIPTION(\"Xtables: rate-limit match\");\nMODULE_ALIAS(\"ipt_limit\");\nMODULE_ALIAS(\"ip6t_limit\");\n\n \n\n \n#define MAX_CPJ (0xFFFFFFFF / (HZ*60*60*24))\n\n \n#define _POW2_BELOW2(x) ((x)|((x)>>1))\n#define _POW2_BELOW4(x) (_POW2_BELOW2(x)|_POW2_BELOW2((x)>>2))\n#define _POW2_BELOW8(x) (_POW2_BELOW4(x)|_POW2_BELOW4((x)>>4))\n#define _POW2_BELOW16(x) (_POW2_BELOW8(x)|_POW2_BELOW8((x)>>8))\n#define _POW2_BELOW32(x) (_POW2_BELOW16(x)|_POW2_BELOW16((x)>>16))\n#define POW2_BELOW32(x) ((_POW2_BELOW32(x)>>1) + 1)\n\n#define CREDITS_PER_JIFFY POW2_BELOW32(MAX_CPJ)\n\nstatic bool\nlimit_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_rateinfo *r = par->matchinfo;\n\tstruct xt_limit_priv *priv = r->master;\n\tunsigned long now;\n\tu32 old_credit, new_credit, credit_increase = 0;\n\tbool ret;\n\n\t \n\tif ((READ_ONCE(priv->credit) < r->cost) && (READ_ONCE(priv->prev) == jiffies))\n\t\treturn false;\n\n\tdo {\n\t\tnow = jiffies;\n\t\tcredit_increase += (now - xchg(&priv->prev, now)) * CREDITS_PER_JIFFY;\n\t\told_credit = READ_ONCE(priv->credit);\n\t\tnew_credit = old_credit;\n\t\tnew_credit += credit_increase;\n\t\tif (new_credit > r->credit_cap)\n\t\t\tnew_credit = r->credit_cap;\n\t\tif (new_credit >= r->cost) {\n\t\t\tret = true;\n\t\t\tnew_credit -= r->cost;\n\t\t} else {\n\t\t\tret = false;\n\t\t}\n\t} while (cmpxchg(&priv->credit, old_credit, new_credit) != old_credit);\n\n\treturn ret;\n}\n\n \nstatic u32 user2credits(u32 user)\n{\n\t \n\tif (user > 0xFFFFFFFF / (HZ*CREDITS_PER_JIFFY))\n\t\t \n\t\treturn (user / XT_LIMIT_SCALE) * HZ * CREDITS_PER_JIFFY;\n\n\treturn (user * HZ * CREDITS_PER_JIFFY) / XT_LIMIT_SCALE;\n}\n\nstatic int limit_mt_check(const struct xt_mtchk_param *par)\n{\n\tstruct xt_rateinfo *r = par->matchinfo;\n\tstruct xt_limit_priv *priv;\n\n\t \n\tif (r->burst == 0\n\t    || user2credits(r->avg * r->burst) < user2credits(r->avg)) {\n\t\tpr_info_ratelimited(\"Overflow, try lower: %u/%u\\n\",\n\t\t\t\t    r->avg, r->burst);\n\t\treturn -ERANGE;\n\t}\n\n\tpriv = kmalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tr->master = priv;\n\t \n\tpriv->prev = jiffies;\n\tpriv->credit = user2credits(r->avg * r->burst);  \n\tif (r->cost == 0) {\n\t\tr->credit_cap = priv->credit;  \n\t\tr->cost = user2credits(r->avg);\n\t}\n\n\treturn 0;\n}\n\nstatic void limit_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tconst struct xt_rateinfo *info = par->matchinfo;\n\n\tkfree(info->master);\n}\n\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\nstruct compat_xt_rateinfo {\n\tu_int32_t avg;\n\tu_int32_t burst;\n\n\tcompat_ulong_t prev;\n\tu_int32_t credit;\n\tu_int32_t credit_cap, cost;\n\n\tu_int32_t master;\n};\n\n \nstatic void limit_mt_compat_from_user(void *dst, const void *src)\n{\n\tconst struct compat_xt_rateinfo *cm = src;\n\tstruct xt_rateinfo m = {\n\t\t.avg\t\t= cm->avg,\n\t\t.burst\t\t= cm->burst,\n\t\t.prev\t\t= cm->prev | (unsigned long)cm->master << 32,\n\t\t.credit\t\t= cm->credit,\n\t\t.credit_cap\t= cm->credit_cap,\n\t\t.cost\t\t= cm->cost,\n\t};\n\tmemcpy(dst, &m, sizeof(m));\n}\n\nstatic int limit_mt_compat_to_user(void __user *dst, const void *src)\n{\n\tconst struct xt_rateinfo *m = src;\n\tstruct compat_xt_rateinfo cm = {\n\t\t.avg\t\t= m->avg,\n\t\t.burst\t\t= m->burst,\n\t\t.prev\t\t= m->prev,\n\t\t.credit\t\t= m->credit,\n\t\t.credit_cap\t= m->credit_cap,\n\t\t.cost\t\t= m->cost,\n\t\t.master\t\t= m->prev >> 32,\n\t};\n\treturn copy_to_user(dst, &cm, sizeof(cm)) ? -EFAULT : 0;\n}\n#endif  \n\nstatic struct xt_match limit_mt_reg __read_mostly = {\n\t.name             = \"limit\",\n\t.revision         = 0,\n\t.family           = NFPROTO_UNSPEC,\n\t.match            = limit_mt,\n\t.checkentry       = limit_mt_check,\n\t.destroy          = limit_mt_destroy,\n\t.matchsize        = sizeof(struct xt_rateinfo),\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t.compatsize       = sizeof(struct compat_xt_rateinfo),\n\t.compat_from_user = limit_mt_compat_from_user,\n\t.compat_to_user   = limit_mt_compat_to_user,\n#endif\n\t.usersize         = offsetof(struct xt_rateinfo, prev),\n\t.me               = THIS_MODULE,\n};\n\nstatic int __init limit_mt_init(void)\n{\n\treturn xt_register_match(&limit_mt_reg);\n}\n\nstatic void __exit limit_mt_exit(void)\n{\n\txt_unregister_match(&limit_mt_reg);\n}\n\nmodule_init(limit_mt_init);\nmodule_exit(limit_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}