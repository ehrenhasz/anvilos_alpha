{
  "module_name": "xt_policy.c",
  "hash_id": "d7c14e36815a4cadf954379d0b1368eaeb8a489d1a1a7cd0cd74f81eb600bae9",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_policy.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <net/xfrm.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter/xt_policy.h>\n#include <linux/netfilter/x_tables.h>\n\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_DESCRIPTION(\"Xtables: IPsec policy match\");\nMODULE_LICENSE(\"GPL\");\n\nstatic inline bool\nxt_addr_cmp(const union nf_inet_addr *a1, const union nf_inet_addr *m,\n\t    const union nf_inet_addr *a2, unsigned short family)\n{\n\tswitch (family) {\n\tcase NFPROTO_IPV4:\n\t\treturn ((a1->ip ^ a2->ip) & m->ip) == 0;\n\tcase NFPROTO_IPV6:\n\t\treturn ipv6_masked_addr_cmp(&a1->in6, &m->in6, &a2->in6) == 0;\n\t}\n\treturn false;\n}\n\nstatic bool\nmatch_xfrm_state(const struct xfrm_state *x, const struct xt_policy_elem *e,\n\t\t unsigned short family)\n{\n#define MATCH_ADDR(x,y,z)\t(!e->match.x ||\t\t\t       \\\n\t\t\t\t (xt_addr_cmp(&e->x, &e->y, (const union nf_inet_addr *)(z), family) \\\n\t\t\t\t  ^ e->invert.x))\n#define MATCH(x,y)\t\t(!e->match.x || ((e->x == (y)) ^ e->invert.x))\n\n\treturn MATCH_ADDR(saddr, smask, &x->props.saddr) &&\n\t       MATCH_ADDR(daddr, dmask, &x->id.daddr) &&\n\t       MATCH(proto, x->id.proto) &&\n\t       MATCH(mode, x->props.mode) &&\n\t       MATCH(spi, x->id.spi) &&\n\t       MATCH(reqid, x->props.reqid);\n}\n\nstatic int\nmatch_policy_in(const struct sk_buff *skb, const struct xt_policy_info *info,\n\t\tunsigned short family)\n{\n\tconst struct xt_policy_elem *e;\n\tconst struct sec_path *sp = skb_sec_path(skb);\n\tint strict = info->flags & XT_POLICY_MATCH_STRICT;\n\tint i, pos;\n\n\tif (sp == NULL)\n\t\treturn -1;\n\tif (strict && info->len != sp->len)\n\t\treturn 0;\n\n\tfor (i = sp->len - 1; i >= 0; i--) {\n\t\tpos = strict ? i - sp->len + 1 : 0;\n\t\tif (pos >= info->len)\n\t\t\treturn 0;\n\t\te = &info->pol[pos];\n\n\t\tif (match_xfrm_state(sp->xvec[i], e, family)) {\n\t\t\tif (!strict)\n\t\t\t\treturn 1;\n\t\t} else if (strict)\n\t\t\treturn 0;\n\t}\n\n\treturn strict ? 1 : 0;\n}\n\nstatic int\nmatch_policy_out(const struct sk_buff *skb, const struct xt_policy_info *info,\n\t\t unsigned short family)\n{\n\tconst struct xt_policy_elem *e;\n\tconst struct dst_entry *dst = skb_dst(skb);\n\tint strict = info->flags & XT_POLICY_MATCH_STRICT;\n\tint i, pos;\n\n\tif (dst->xfrm == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; dst && dst->xfrm;\n\t     dst = ((struct xfrm_dst *)dst)->child, i++) {\n\t\tpos = strict ? i : 0;\n\t\tif (pos >= info->len)\n\t\t\treturn 0;\n\t\te = &info->pol[pos];\n\n\t\tif (match_xfrm_state(dst->xfrm, e, family)) {\n\t\t\tif (!strict)\n\t\t\t\treturn 1;\n\t\t} else if (strict)\n\t\t\treturn 0;\n\t}\n\n\treturn strict ? i == info->len : 0;\n}\n\nstatic bool\npolicy_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_policy_info *info = par->matchinfo;\n\tint ret;\n\n\tif (info->flags & XT_POLICY_MATCH_IN)\n\t\tret = match_policy_in(skb, info, xt_family(par));\n\telse\n\t\tret = match_policy_out(skb, info, xt_family(par));\n\n\tif (ret < 0)\n\t\tret = info->flags & XT_POLICY_MATCH_NONE ? true : false;\n\telse if (info->flags & XT_POLICY_MATCH_NONE)\n\t\tret = false;\n\n\treturn ret;\n}\n\nstatic int policy_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_policy_info *info = par->matchinfo;\n\tconst char *errmsg = \"neither incoming nor outgoing policy selected\";\n\n\tif (!(info->flags & (XT_POLICY_MATCH_IN|XT_POLICY_MATCH_OUT)))\n\t\tgoto err;\n\n\tif (par->hook_mask & ((1 << NF_INET_PRE_ROUTING) |\n\t    (1 << NF_INET_LOCAL_IN)) && info->flags & XT_POLICY_MATCH_OUT) {\n\t\terrmsg = \"output policy not valid in PREROUTING and INPUT\";\n\t\tgoto err;\n\t}\n\tif (par->hook_mask & ((1 << NF_INET_POST_ROUTING) |\n\t    (1 << NF_INET_LOCAL_OUT)) && info->flags & XT_POLICY_MATCH_IN) {\n\t\terrmsg = \"input policy not valid in POSTROUTING and OUTPUT\";\n\t\tgoto err;\n\t}\n\tif (info->len > XT_POLICY_MAX_ELEM) {\n\t\terrmsg = \"too many policy elements\";\n\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tpr_info_ratelimited(\"%s\\n\", errmsg);\n\treturn -EINVAL;\n}\n\nstatic struct xt_match policy_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"policy\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.checkentry \t= policy_mt_check,\n\t\t.match\t\t= policy_mt,\n\t\t.matchsize\t= sizeof(struct xt_policy_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"policy\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.checkentry\t= policy_mt_check,\n\t\t.match\t\t= policy_mt,\n\t\t.matchsize\t= sizeof(struct xt_policy_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init policy_mt_init(void)\n{\n\treturn xt_register_matches(policy_mt_reg, ARRAY_SIZE(policy_mt_reg));\n}\n\nstatic void __exit policy_mt_exit(void)\n{\n\txt_unregister_matches(policy_mt_reg, ARRAY_SIZE(policy_mt_reg));\n}\n\nmodule_init(policy_mt_init);\nmodule_exit(policy_mt_exit);\nMODULE_ALIAS(\"ipt_policy\");\nMODULE_ALIAS(\"ip6t_policy\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}