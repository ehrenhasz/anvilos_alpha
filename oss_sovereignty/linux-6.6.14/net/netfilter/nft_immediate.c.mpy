{
  "module_name": "nft_immediate.c",
  "hash_id": "2e5d66491c07bbb160c1b2c4a8dcf75d57c78ca9f597ffd97bea3ff54b0d6193",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_immediate.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_offload.h>\n\nvoid nft_immediate_eval(const struct nft_expr *expr,\n\t\t\tstruct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_immediate_expr *priv = nft_expr_priv(expr);\n\n\tnft_data_copy(&regs->data[priv->dreg], &priv->data, priv->dlen);\n}\n\nstatic const struct nla_policy nft_immediate_policy[NFTA_IMMEDIATE_MAX + 1] = {\n\t[NFTA_IMMEDIATE_DREG]\t= { .type = NLA_U32 },\n\t[NFTA_IMMEDIATE_DATA]\t= { .type = NLA_NESTED },\n};\n\nstatic enum nft_data_types nft_reg_to_type(const struct nlattr *nla)\n{\n\tenum nft_data_types type;\n\tu8 reg;\n\n\treg = ntohl(nla_get_be32(nla));\n\tif (reg == NFT_REG_VERDICT)\n\t\ttype = NFT_DATA_VERDICT;\n\telse\n\t\ttype = NFT_DATA_VALUE;\n\n\treturn type;\n}\n\nstatic int nft_immediate_init(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr,\n\t\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_immediate_expr *priv = nft_expr_priv(expr);\n\tstruct nft_data_desc desc = {\n\t\t.size\t= sizeof(priv->data),\n\t};\n\tint err;\n\n\tif (tb[NFTA_IMMEDIATE_DREG] == NULL ||\n\t    tb[NFTA_IMMEDIATE_DATA] == NULL)\n\t\treturn -EINVAL;\n\n\tdesc.type = nft_reg_to_type(tb[NFTA_IMMEDIATE_DREG]);\n\terr = nft_data_init(ctx, &priv->data, &desc, tb[NFTA_IMMEDIATE_DATA]);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->dlen = desc.len;\n\n\terr = nft_parse_register_store(ctx, tb[NFTA_IMMEDIATE_DREG],\n\t\t\t\t       &priv->dreg, &priv->data, desc.type,\n\t\t\t\t       desc.len);\n\tif (err < 0)\n\t\tgoto err1;\n\n\tif (priv->dreg == NFT_REG_VERDICT) {\n\t\tstruct nft_chain *chain = priv->data.verdict.chain;\n\n\t\tswitch (priv->data.verdict.code) {\n\t\tcase NFT_JUMP:\n\t\tcase NFT_GOTO:\n\t\t\terr = nf_tables_bind_chain(ctx, chain);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr1:\n\tnft_data_release(&priv->data, desc.type);\n\treturn err;\n}\n\nstatic void nft_immediate_activate(const struct nft_ctx *ctx,\n\t\t\t\t   const struct nft_expr *expr)\n{\n\tconst struct nft_immediate_expr *priv = nft_expr_priv(expr);\n\tconst struct nft_data *data = &priv->data;\n\tstruct nft_ctx chain_ctx;\n\tstruct nft_chain *chain;\n\tstruct nft_rule *rule;\n\n\tif (priv->dreg == NFT_REG_VERDICT) {\n\t\tswitch (data->verdict.code) {\n\t\tcase NFT_JUMP:\n\t\tcase NFT_GOTO:\n\t\t\tchain = data->verdict.chain;\n\t\t\tif (!nft_chain_binding(chain))\n\t\t\t\tbreak;\n\n\t\t\tchain_ctx = *ctx;\n\t\t\tchain_ctx.chain = chain;\n\n\t\t\tlist_for_each_entry(rule, &chain->rules, list)\n\t\t\t\tnft_rule_expr_activate(&chain_ctx, rule);\n\n\t\t\tnft_clear(ctx->net, chain);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nft_data_hold(&priv->data, nft_dreg_to_type(priv->dreg));\n}\n\nstatic void nft_immediate_chain_deactivate(const struct nft_ctx *ctx,\n\t\t\t\t\t   struct nft_chain *chain,\n\t\t\t\t\t   enum nft_trans_phase phase)\n{\n\tstruct nft_ctx chain_ctx;\n\tstruct nft_rule *rule;\n\n\tchain_ctx = *ctx;\n\tchain_ctx.chain = chain;\n\n\tlist_for_each_entry(rule, &chain->rules, list)\n\t\tnft_rule_expr_deactivate(&chain_ctx, rule, phase);\n}\n\nstatic void nft_immediate_deactivate(const struct nft_ctx *ctx,\n\t\t\t\t     const struct nft_expr *expr,\n\t\t\t\t     enum nft_trans_phase phase)\n{\n\tconst struct nft_immediate_expr *priv = nft_expr_priv(expr);\n\tconst struct nft_data *data = &priv->data;\n\tstruct nft_chain *chain;\n\n\tif (priv->dreg == NFT_REG_VERDICT) {\n\t\tswitch (data->verdict.code) {\n\t\tcase NFT_JUMP:\n\t\tcase NFT_GOTO:\n\t\t\tchain = data->verdict.chain;\n\t\t\tif (!nft_chain_binding(chain))\n\t\t\t\tbreak;\n\n\t\t\tswitch (phase) {\n\t\t\tcase NFT_TRANS_PREPARE_ERROR:\n\t\t\t\tnf_tables_unbind_chain(ctx, chain);\n\t\t\t\tnft_deactivate_next(ctx->net, chain);\n\t\t\t\tbreak;\n\t\t\tcase NFT_TRANS_PREPARE:\n\t\t\t\tnft_immediate_chain_deactivate(ctx, chain, phase);\n\t\t\t\tnft_deactivate_next(ctx->net, chain);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnft_immediate_chain_deactivate(ctx, chain, phase);\n\t\t\t\tnft_chain_del(chain);\n\t\t\t\tchain->bound = false;\n\t\t\t\tnft_use_dec(&chain->table->use);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (phase == NFT_TRANS_COMMIT)\n\t\treturn;\n\n\treturn nft_data_release(&priv->data, nft_dreg_to_type(priv->dreg));\n}\n\nstatic void nft_immediate_destroy(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nft_expr *expr)\n{\n\tconst struct nft_immediate_expr *priv = nft_expr_priv(expr);\n\tconst struct nft_data *data = &priv->data;\n\tstruct nft_rule *rule, *n;\n\tstruct nft_ctx chain_ctx;\n\tstruct nft_chain *chain;\n\n\tif (priv->dreg != NFT_REG_VERDICT)\n\t\treturn;\n\n\tswitch (data->verdict.code) {\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tchain = data->verdict.chain;\n\n\t\tif (!nft_chain_binding(chain))\n\t\t\tbreak;\n\n\t\t \n\t\tif (chain->bound) {\n\t\t\tnft_use_dec(&chain->use);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tchain_ctx = *ctx;\n\t\tchain_ctx.chain = chain;\n\n\t\tnft_use_dec(&chain->use);\n\t\tlist_for_each_entry_safe(rule, n, &chain->rules, list) {\n\t\t\tnft_use_dec(&chain->use);\n\t\t\tlist_del(&rule->list);\n\t\t\tnf_tables_rule_destroy(&chain_ctx, rule);\n\t\t}\n\t\tnf_tables_chain_destroy(&chain_ctx);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int nft_immediate_dump(struct sk_buff *skb,\n\t\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_immediate_expr *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_IMMEDIATE_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\n\treturn nft_data_dump(skb, NFTA_IMMEDIATE_DATA, &priv->data,\n\t\t\t     nft_dreg_to_type(priv->dreg), priv->dlen);\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_immediate_validate(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nft_expr *expr,\n\t\t\t\t  const struct nft_data **d)\n{\n\tconst struct nft_immediate_expr *priv = nft_expr_priv(expr);\n\tstruct nft_ctx *pctx = (struct nft_ctx *)ctx;\n\tconst struct nft_data *data;\n\tint err;\n\n\tif (priv->dreg != NFT_REG_VERDICT)\n\t\treturn 0;\n\n\tdata = &priv->data;\n\n\tswitch (data->verdict.code) {\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tpctx->level++;\n\t\terr = nft_chain_validate(ctx, data->verdict.chain);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpctx->level--;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_immediate_offload_verdict(struct nft_offload_ctx *ctx,\n\t\t\t\t\t struct nft_flow_rule *flow,\n\t\t\t\t\t const struct nft_immediate_expr *priv)\n{\n\tstruct flow_action_entry *entry;\n\tconst struct nft_data *data;\n\n\tentry = &flow->rule->action.entries[ctx->num_actions++];\n\n\tdata = &priv->data;\n\tswitch (data->verdict.code) {\n\tcase NF_ACCEPT:\n\t\tentry->id = FLOW_ACTION_ACCEPT;\n\t\tbreak;\n\tcase NF_DROP:\n\t\tentry->id = FLOW_ACTION_DROP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_immediate_offload(struct nft_offload_ctx *ctx,\n\t\t\t\t struct nft_flow_rule *flow,\n\t\t\t\t const struct nft_expr *expr)\n{\n\tconst struct nft_immediate_expr *priv = nft_expr_priv(expr);\n\n\tif (priv->dreg == NFT_REG_VERDICT)\n\t\treturn nft_immediate_offload_verdict(ctx, flow, priv);\n\n\tmemcpy(&ctx->regs[priv->dreg].data, &priv->data, sizeof(priv->data));\n\n\treturn 0;\n}\n\nstatic bool nft_immediate_offload_action(const struct nft_expr *expr)\n{\n\tconst struct nft_immediate_expr *priv = nft_expr_priv(expr);\n\n\tif (priv->dreg == NFT_REG_VERDICT)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool nft_immediate_reduce(struct nft_regs_track *track,\n\t\t\t\t const struct nft_expr *expr)\n{\n\tconst struct nft_immediate_expr *priv = nft_expr_priv(expr);\n\n\tif (priv->dreg != NFT_REG_VERDICT)\n\t\tnft_reg_track_cancel(track, priv->dreg, priv->dlen);\n\n\treturn false;\n}\n\nstatic const struct nft_expr_ops nft_imm_ops = {\n\t.type\t\t= &nft_imm_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_immediate_expr)),\n\t.eval\t\t= nft_immediate_eval,\n\t.init\t\t= nft_immediate_init,\n\t.activate\t= nft_immediate_activate,\n\t.deactivate\t= nft_immediate_deactivate,\n\t.destroy\t= nft_immediate_destroy,\n\t.dump\t\t= nft_immediate_dump,\n\t.validate\t= nft_immediate_validate,\n\t.reduce\t\t= nft_immediate_reduce,\n\t.offload\t= nft_immediate_offload,\n\t.offload_action\t= nft_immediate_offload_action,\n};\n\nstruct nft_expr_type nft_imm_type __read_mostly = {\n\t.name\t\t= \"immediate\",\n\t.ops\t\t= &nft_imm_ops,\n\t.policy\t\t= nft_immediate_policy,\n\t.maxattr\t= NFTA_IMMEDIATE_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}