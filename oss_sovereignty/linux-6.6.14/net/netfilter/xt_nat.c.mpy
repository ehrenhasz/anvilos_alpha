{
  "module_name": "xt_nat.c",
  "hash_id": "5f80cb0fef2f1c7e31fdc04f3888bffcd67b45a4095765502e99d003e9a5cc09",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_nat.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/x_tables.h>\n#include <net/netfilter/nf_nat.h>\n\nstatic int xt_nat_checkentry_v0(const struct xt_tgchk_param *par)\n{\n\tconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\n\n\tif (mr->rangesize != 1) {\n\t\tpr_info_ratelimited(\"multiple ranges no longer supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn nf_ct_netns_get(par->net, par->family);\n}\n\nstatic int xt_nat_checkentry(const struct xt_tgchk_param *par)\n{\n\treturn nf_ct_netns_get(par->net, par->family);\n}\n\nstatic void xt_nat_destroy(const struct xt_tgdtor_param *par)\n{\n\tnf_ct_netns_put(par->net, par->family);\n}\n\nstatic void xt_nat_convert_range(struct nf_nat_range2 *dst,\n\t\t\t\t const struct nf_nat_ipv4_range *src)\n{\n\tmemset(&dst->min_addr, 0, sizeof(dst->min_addr));\n\tmemset(&dst->max_addr, 0, sizeof(dst->max_addr));\n\tmemset(&dst->base_proto, 0, sizeof(dst->base_proto));\n\n\tdst->flags\t = src->flags;\n\tdst->min_addr.ip = src->min_ip;\n\tdst->max_addr.ip = src->max_ip;\n\tdst->min_proto\t = src->min;\n\tdst->max_proto\t = src->max;\n}\n\nstatic unsigned int\nxt_snat_target_v0(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\n\tstruct nf_nat_range2 range;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tWARN_ON(!(ct != NULL &&\n\t\t (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ||\n\t\t  ctinfo == IP_CT_RELATED_REPLY)));\n\n\txt_nat_convert_range(&range, &mr->range[0]);\n\treturn nf_nat_setup_info(ct, &range, NF_NAT_MANIP_SRC);\n}\n\nstatic unsigned int\nxt_dnat_target_v0(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\n\tstruct nf_nat_range2 range;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tWARN_ON(!(ct != NULL &&\n\t\t (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED)));\n\n\txt_nat_convert_range(&range, &mr->range[0]);\n\treturn nf_nat_setup_info(ct, &range, NF_NAT_MANIP_DST);\n}\n\nstatic unsigned int\nxt_snat_target_v1(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct nf_nat_range *range_v1 = par->targinfo;\n\tstruct nf_nat_range2 range;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tWARN_ON(!(ct != NULL &&\n\t\t (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ||\n\t\t  ctinfo == IP_CT_RELATED_REPLY)));\n\n\tmemcpy(&range, range_v1, sizeof(*range_v1));\n\tmemset(&range.base_proto, 0, sizeof(range.base_proto));\n\n\treturn nf_nat_setup_info(ct, &range, NF_NAT_MANIP_SRC);\n}\n\nstatic unsigned int\nxt_dnat_target_v1(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct nf_nat_range *range_v1 = par->targinfo;\n\tstruct nf_nat_range2 range;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tWARN_ON(!(ct != NULL &&\n\t\t (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED)));\n\n\tmemcpy(&range, range_v1, sizeof(*range_v1));\n\tmemset(&range.base_proto, 0, sizeof(range.base_proto));\n\n\treturn nf_nat_setup_info(ct, &range, NF_NAT_MANIP_DST);\n}\n\nstatic unsigned int\nxt_snat_target_v2(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct nf_nat_range2 *range = par->targinfo;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tWARN_ON(!(ct != NULL &&\n\t\t (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ||\n\t\t  ctinfo == IP_CT_RELATED_REPLY)));\n\n\treturn nf_nat_setup_info(ct, range, NF_NAT_MANIP_SRC);\n}\n\nstatic unsigned int\nxt_dnat_target_v2(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct nf_nat_range2 *range = par->targinfo;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tWARN_ON(!(ct != NULL &&\n\t\t (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED)));\n\n\treturn nf_nat_setup_info(ct, range, NF_NAT_MANIP_DST);\n}\n\nstatic struct xt_target xt_nat_target_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"SNAT\",\n\t\t.revision\t= 0,\n\t\t.checkentry\t= xt_nat_checkentry_v0,\n\t\t.destroy\t= xt_nat_destroy,\n\t\t.target\t\t= xt_snat_target_v0,\n\t\t.targetsize\t= sizeof(struct nf_nat_ipv4_multi_range_compat),\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.table\t\t= \"nat\",\n\t\t.hooks\t\t= (1 << NF_INET_POST_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"DNAT\",\n\t\t.revision\t= 0,\n\t\t.checkentry\t= xt_nat_checkentry_v0,\n\t\t.destroy\t= xt_nat_destroy,\n\t\t.target\t\t= xt_dnat_target_v0,\n\t\t.targetsize\t= sizeof(struct nf_nat_ipv4_multi_range_compat),\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.table\t\t= \"nat\",\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_OUT),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"SNAT\",\n\t\t.revision\t= 1,\n\t\t.checkentry\t= xt_nat_checkentry,\n\t\t.destroy\t= xt_nat_destroy,\n\t\t.target\t\t= xt_snat_target_v1,\n\t\t.targetsize\t= sizeof(struct nf_nat_range),\n\t\t.table\t\t= \"nat\",\n\t\t.hooks\t\t= (1 << NF_INET_POST_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"DNAT\",\n\t\t.revision\t= 1,\n\t\t.checkentry\t= xt_nat_checkentry,\n\t\t.destroy\t= xt_nat_destroy,\n\t\t.target\t\t= xt_dnat_target_v1,\n\t\t.targetsize\t= sizeof(struct nf_nat_range),\n\t\t.table\t\t= \"nat\",\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_OUT),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"SNAT\",\n\t\t.revision\t= 2,\n\t\t.checkentry\t= xt_nat_checkentry,\n\t\t.destroy\t= xt_nat_destroy,\n\t\t.target\t\t= xt_snat_target_v2,\n\t\t.targetsize\t= sizeof(struct nf_nat_range2),\n\t\t.table\t\t= \"nat\",\n\t\t.hooks\t\t= (1 << NF_INET_POST_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"DNAT\",\n\t\t.revision\t= 2,\n\t\t.checkentry\t= xt_nat_checkentry,\n\t\t.destroy\t= xt_nat_destroy,\n\t\t.target\t\t= xt_dnat_target_v2,\n\t\t.targetsize\t= sizeof(struct nf_nat_range2),\n\t\t.table\t\t= \"nat\",\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_OUT),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init xt_nat_init(void)\n{\n\treturn xt_register_targets(xt_nat_target_reg,\n\t\t\t\t   ARRAY_SIZE(xt_nat_target_reg));\n}\n\nstatic void __exit xt_nat_exit(void)\n{\n\txt_unregister_targets(xt_nat_target_reg, ARRAY_SIZE(xt_nat_target_reg));\n}\n\nmodule_init(xt_nat_init);\nmodule_exit(xt_nat_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_ALIAS(\"ipt_SNAT\");\nMODULE_ALIAS(\"ipt_DNAT\");\nMODULE_ALIAS(\"ip6t_SNAT\");\nMODULE_ALIAS(\"ip6t_DNAT\");\nMODULE_DESCRIPTION(\"SNAT and DNAT targets support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}