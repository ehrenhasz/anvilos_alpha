{
  "module_name": "nf_conntrack_h323_main.c",
  "hash_id": "225ab3344fb6018386157fe7f1bab12722e826e27e5e4a7780087b9aa3ff0cf0",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_h323_main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/ctype.h>\n#include <linux/inet.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/skbuff.h>\n#include <net/route.h>\n#include <net/ip6_route.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_tuple.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <linux/netfilter/nf_conntrack_h323.h>\n\n#define H323_MAX_SIZE 65535\n\n \nstatic unsigned int default_rrq_ttl __read_mostly = 300;\nmodule_param(default_rrq_ttl, uint, 0600);\nMODULE_PARM_DESC(default_rrq_ttl, \"use this TTL if it's missing in RRQ\");\n\nstatic int gkrouted_only __read_mostly = 1;\nmodule_param(gkrouted_only, int, 0600);\nMODULE_PARM_DESC(gkrouted_only, \"only accept calls from gatekeeper\");\n\nstatic bool callforward_filter __read_mostly = true;\nmodule_param(callforward_filter, bool, 0600);\nMODULE_PARM_DESC(callforward_filter, \"only create call forwarding expectations \"\n\t\t\t\t     \"if both endpoints are on different sides \"\n\t\t\t\t     \"(determined by routing information)\");\n\nconst struct nfct_h323_nat_hooks __rcu *nfct_h323_nat_hook __read_mostly;\nEXPORT_SYMBOL_GPL(nfct_h323_nat_hook);\n\nstatic DEFINE_SPINLOCK(nf_h323_lock);\nstatic char *h323_buffer;\n\nstatic struct nf_conntrack_helper nf_conntrack_helper_h245;\nstatic struct nf_conntrack_helper nf_conntrack_helper_q931[];\nstatic struct nf_conntrack_helper nf_conntrack_helper_ras[];\n\nstatic int get_tpkt_data(struct sk_buff *skb, unsigned int protoff,\n\t\t\t struct nf_conn *ct, enum ip_conntrack_info ctinfo,\n\t\t\t unsigned char **data, int *datalen, int *dataoff)\n{\n\tstruct nf_ct_h323_master *info = nfct_help_data(ct);\n\tint dir = CTINFO2DIR(ctinfo);\n\tconst struct tcphdr *th;\n\tstruct tcphdr _tcph;\n\tint tcpdatalen;\n\tint tcpdataoff;\n\tunsigned char *tpkt;\n\tint tpktlen;\n\tint tpktoff;\n\n\t \n\tth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\n\tif (th == NULL)\n\t\treturn 0;\n\n\t \n\ttcpdataoff = protoff + th->doff * 4;\n\n\t \n\ttcpdatalen = skb->len - tcpdataoff;\n\tif (tcpdatalen <= 0)\t \n\t\tgoto clear_out;\n\n\tif (tcpdatalen > H323_MAX_SIZE)\n\t\ttcpdatalen = H323_MAX_SIZE;\n\n\tif (*data == NULL) {\t \n\t\t \n\t\ttpkt = skb_header_pointer(skb, tcpdataoff, tcpdatalen,\n\t\t\t\t\t  h323_buffer);\n\t\tif (!tpkt)\n\t\t\tgoto clear_out;\n\n\t\t \n\t\tif (tcpdatalen < 4 || tpkt[0] != 0x03 || tpkt[1] != 0) {\n\t\t\t \n\t\t\tif (info->tpkt_len[dir] > 0) {\n\t\t\t\tpr_debug(\"nf_ct_h323: previous packet \"\n\t\t\t\t\t \"indicated separate TPKT data of %hu \"\n\t\t\t\t\t \"bytes\\n\", info->tpkt_len[dir]);\n\t\t\t\tif (info->tpkt_len[dir] <= tcpdatalen) {\n\t\t\t\t\t \n\t\t\t\t\t*data = tpkt;\n\t\t\t\t\t*datalen = info->tpkt_len[dir];\n\t\t\t\t\t*dataoff = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tpr_debug(\"nf_ct_h323: fragmented TPKT\\n\");\n\t\t\t\tgoto clear_out;\n\t\t\t}\n\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\ttpktoff = 0;\n\t} else {\t\t \n\t\ttpktoff = *dataoff + *datalen;\n\t\ttcpdatalen -= tpktoff;\n\t\tif (tcpdatalen <= 4)\t \n\t\t\tgoto clear_out;\n\t\ttpkt = *data + *datalen;\n\n\t\t \n\t\tif (tpkt[0] != 0x03 || tpkt[1] != 0)\n\t\t\tgoto clear_out;\n\t}\n\n\t \n\ttpktlen = tpkt[2] * 256 + tpkt[3];\n\tif (tpktlen < 4)\n\t\tgoto clear_out;\n\tif (tpktlen > tcpdatalen) {\n\t\tif (tcpdatalen == 4) {\t \n\t\t\t \n\t\t\tpr_debug(\"nf_ct_h323: separate TPKT header indicates \"\n\t\t\t\t \"there will be TPKT data of %d bytes\\n\",\n\t\t\t\t tpktlen - 4);\n\t\t\tinfo->tpkt_len[dir] = tpktlen - 4;\n\t\t\treturn 0;\n\t\t}\n\n\t\tpr_debug(\"nf_ct_h323: incomplete TPKT (fragmented?)\\n\");\n\t\tgoto clear_out;\n\t}\n\n\t \n\t*data = tpkt + 4;\n\t*datalen = tpktlen - 4;\n\t*dataoff = tpktoff + 4;\n\n      out:\n\t \n\tinfo->tpkt_len[dir] = 0;\n\treturn 1;\n\n      clear_out:\n\tinfo->tpkt_len[dir] = 0;\n\treturn 0;\n}\n\nstatic int get_h245_addr(struct nf_conn *ct, const unsigned char *data,\n\t\t\t H245_TransportAddress *taddr,\n\t\t\t union nf_inet_addr *addr, __be16 *port)\n{\n\tconst unsigned char *p;\n\tint len;\n\n\tif (taddr->choice != eH245_TransportAddress_unicastAddress)\n\t\treturn 0;\n\n\tswitch (taddr->unicastAddress.choice) {\n\tcase eUnicastAddress_iPAddress:\n\t\tif (nf_ct_l3num(ct) != AF_INET)\n\t\t\treturn 0;\n\t\tp = data + taddr->unicastAddress.iPAddress.network;\n\t\tlen = 4;\n\t\tbreak;\n\tcase eUnicastAddress_iP6Address:\n\t\tif (nf_ct_l3num(ct) != AF_INET6)\n\t\t\treturn 0;\n\t\tp = data + taddr->unicastAddress.iP6Address.network;\n\t\tlen = 16;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tmemcpy(addr, p, len);\n\tmemset((void *)addr + len, 0, sizeof(*addr) - len);\n\tmemcpy(port, p + len, sizeof(__be16));\n\n\treturn 1;\n}\n\nstatic int expect_rtp_rtcp(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t   enum ip_conntrack_info ctinfo,\n\t\t\t   unsigned int protoff,\n\t\t\t   unsigned char **data, int dataoff,\n\t\t\t   H245_TransportAddress *taddr)\n{\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret = 0;\n\t__be16 port;\n\t__be16 rtp_port, rtcp_port;\n\tunion nf_inet_addr addr;\n\tstruct nf_conntrack_expect *rtp_exp;\n\tstruct nf_conntrack_expect *rtcp_exp;\n\n\t \n\tif (!get_h245_addr(ct, *data, taddr, &addr, &port) ||\n\t    memcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) ||\n\t    port == 0)\n\t\treturn 0;\n\n\t \n\trtp_port = port & ~htons(1);\n\trtcp_port = port | htons(1);\n\n\t \n\tif ((rtp_exp = nf_ct_expect_alloc(ct)) == NULL)\n\t\treturn -1;\n\tnf_ct_expect_init(rtp_exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\t  &ct->tuplehash[!dir].tuple.src.u3,\n\t\t\t  &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t  IPPROTO_UDP, NULL, &rtp_port);\n\n\t \n\tif ((rtcp_exp = nf_ct_expect_alloc(ct)) == NULL) {\n\t\tnf_ct_expect_put(rtp_exp);\n\t\treturn -1;\n\t}\n\tnf_ct_expect_init(rtcp_exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\t  &ct->tuplehash[!dir].tuple.src.u3,\n\t\t\t  &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t  IPPROTO_UDP, NULL, &rtcp_port);\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (memcmp(&ct->tuplehash[dir].tuple.src.u3,\n\t\t   &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t   sizeof(ct->tuplehash[dir].tuple.src.u3)) &&\n\t\t   nathook &&\n\t\t   nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t\t   ct->status & IPS_NAT_MASK) {\n\t\t \n\t\tret = nathook->nat_rtp_rtcp(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t\t    taddr, port, rtp_port, rtp_exp, rtcp_exp);\n\t} else {\t\t \n\t\tif (nf_ct_expect_related(rtp_exp, 0) == 0) {\n\t\t\tif (nf_ct_expect_related(rtcp_exp, 0) == 0) {\n\t\t\t\tpr_debug(\"nf_ct_h323: expect RTP \");\n\t\t\t\tnf_ct_dump_tuple(&rtp_exp->tuple);\n\t\t\t\tpr_debug(\"nf_ct_h323: expect RTCP \");\n\t\t\t\tnf_ct_dump_tuple(&rtcp_exp->tuple);\n\t\t\t} else {\n\t\t\t\tnf_ct_unexpect_related(rtp_exp);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\tnf_ct_expect_put(rtp_exp);\n\tnf_ct_expect_put(rtcp_exp);\n\n\treturn ret;\n}\n\nstatic int expect_t120(struct sk_buff *skb,\n\t\t       struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, int dataoff,\n\t\t       H245_TransportAddress *taddr)\n{\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret = 0;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\tstruct nf_conntrack_expect *exp;\n\n\t \n\tif (!get_h245_addr(ct, *data, taddr, &addr, &port) ||\n\t    memcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) ||\n\t    port == 0)\n\t\treturn 0;\n\n\t \n\tif ((exp = nf_ct_expect_alloc(ct)) == NULL)\n\t\treturn -1;\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\t  &ct->tuplehash[!dir].tuple.src.u3,\n\t\t\t  &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t  IPPROTO_TCP, NULL, &port);\n\texp->flags = NF_CT_EXPECT_PERMANENT;\t \n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (memcmp(&ct->tuplehash[dir].tuple.src.u3,\n\t\t   &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t   sizeof(ct->tuplehash[dir].tuple.src.u3)) &&\n\t    nathook &&\n\t    nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK) {\n\t\t \n\t\tret = nathook->nat_t120(skb, ct, ctinfo, protoff, data,\n\t\t\t\t\tdataoff, taddr, port, exp);\n\t} else {\t\t \n\t\tif (nf_ct_expect_related(exp, 0) == 0) {\n\t\t\tpr_debug(\"nf_ct_h323: expect T.120 \");\n\t\t\tnf_ct_dump_tuple(&exp->tuple);\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\tnf_ct_expect_put(exp);\n\n\treturn ret;\n}\n\nstatic int process_h245_channel(struct sk_buff *skb,\n\t\t\t\tstruct nf_conn *ct,\n\t\t\t\tenum ip_conntrack_info ctinfo,\n\t\t\t\tunsigned int protoff,\n\t\t\t\tunsigned char **data, int dataoff,\n\t\t\t\tH2250LogicalChannelParameters *channel)\n{\n\tint ret;\n\n\tif (channel->options & eH2250LogicalChannelParameters_mediaChannel) {\n\t\t \n\t\tret = expect_rtp_rtcp(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t      &channel->mediaChannel);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (channel->\n\t    options & eH2250LogicalChannelParameters_mediaControlChannel) {\n\t\t \n\t\tret = expect_rtp_rtcp(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t      &channel->mediaControlChannel);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int process_olc(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, int dataoff,\n\t\t       OpenLogicalChannel *olc)\n{\n\tint ret;\n\n\tpr_debug(\"nf_ct_h323: OpenLogicalChannel\\n\");\n\n\tif (olc->forwardLogicalChannelParameters.multiplexParameters.choice ==\n\t    eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters)\n\t{\n\t\tret = process_h245_channel(skb, ct, ctinfo,\n\t\t\t\t\t   protoff, data, dataoff,\n\t\t\t\t\t   &olc->\n\t\t\t\t\t   forwardLogicalChannelParameters.\n\t\t\t\t\t   multiplexParameters.\n\t\t\t\t\t   h2250LogicalChannelParameters);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif ((olc->options &\n\t     eOpenLogicalChannel_reverseLogicalChannelParameters) &&\n\t    (olc->reverseLogicalChannelParameters.options &\n\t     eOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters)\n\t    && (olc->reverseLogicalChannelParameters.multiplexParameters.\n\t\tchoice ==\n\t\teOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters))\n\t{\n\t\tret =\n\t\t    process_h245_channel(skb, ct, ctinfo,\n\t\t\t\t\t protoff, data, dataoff,\n\t\t\t\t\t &olc->\n\t\t\t\t\t reverseLogicalChannelParameters.\n\t\t\t\t\t multiplexParameters.\n\t\t\t\t\t h2250LogicalChannelParameters);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif ((olc->options & eOpenLogicalChannel_separateStack) &&\n\t    olc->forwardLogicalChannelParameters.dataType.choice ==\n\t    eDataType_data &&\n\t    olc->forwardLogicalChannelParameters.dataType.data.application.\n\t    choice == eDataApplicationCapability_application_t120 &&\n\t    olc->forwardLogicalChannelParameters.dataType.data.application.\n\t    t120.choice == eDataProtocolCapability_separateLANStack &&\n\t    olc->separateStack.networkAddress.choice ==\n\t    eNetworkAccessParameters_networkAddress_localAreaAddress) {\n\t\tret = expect_t120(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t  &olc->separateStack.networkAddress.\n\t\t\t\t  localAreaAddress);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int process_olca(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\tenum ip_conntrack_info ctinfo,\n\t\t\tunsigned int protoff, unsigned char **data, int dataoff,\n\t\t\tOpenLogicalChannelAck *olca)\n{\n\tH2250LogicalChannelAckParameters *ack;\n\tint ret;\n\n\tpr_debug(\"nf_ct_h323: OpenLogicalChannelAck\\n\");\n\n\tif ((olca->options &\n\t     eOpenLogicalChannelAck_reverseLogicalChannelParameters) &&\n\t    (olca->reverseLogicalChannelParameters.options &\n\t     eOpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters)\n\t    && (olca->reverseLogicalChannelParameters.multiplexParameters.\n\t\tchoice ==\n\t\teOpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters))\n\t{\n\t\tret = process_h245_channel(skb, ct, ctinfo,\n\t\t\t\t\t   protoff, data, dataoff,\n\t\t\t\t\t   &olca->\n\t\t\t\t\t   reverseLogicalChannelParameters.\n\t\t\t\t\t   multiplexParameters.\n\t\t\t\t\t   h2250LogicalChannelParameters);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif ((olca->options &\n\t     eOpenLogicalChannelAck_forwardMultiplexAckParameters) &&\n\t    (olca->forwardMultiplexAckParameters.choice ==\n\t     eOpenLogicalChannelAck_forwardMultiplexAckParameters_h2250LogicalChannelAckParameters))\n\t{\n\t\tack = &olca->forwardMultiplexAckParameters.\n\t\t    h2250LogicalChannelAckParameters;\n\t\tif (ack->options &\n\t\t    eH2250LogicalChannelAckParameters_mediaChannel) {\n\t\t\t \n\t\t\tret = expect_rtp_rtcp(skb, ct, ctinfo,\n\t\t\t\t\t      protoff, data, dataoff,\n\t\t\t\t\t      &ack->mediaChannel);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (ack->options &\n\t\t    eH2250LogicalChannelAckParameters_mediaControlChannel) {\n\t\t\t \n\t\t\tret = expect_rtp_rtcp(skb, ct, ctinfo,\n\t\t\t\t\t      protoff, data, dataoff,\n\t\t\t\t\t      &ack->mediaControlChannel);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((olca->options & eOpenLogicalChannelAck_separateStack) &&\n\t\tolca->separateStack.networkAddress.choice ==\n\t\teNetworkAccessParameters_networkAddress_localAreaAddress) {\n\t\tret = expect_t120(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t  &olca->separateStack.networkAddress.\n\t\t\t\t  localAreaAddress);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int process_h245(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\tenum ip_conntrack_info ctinfo,\n\t\t\tunsigned int protoff, unsigned char **data, int dataoff,\n\t\t\tMultimediaSystemControlMessage *mscm)\n{\n\tswitch (mscm->choice) {\n\tcase eMultimediaSystemControlMessage_request:\n\t\tif (mscm->request.choice ==\n\t\t    eRequestMessage_openLogicalChannel) {\n\t\t\treturn process_olc(skb, ct, ctinfo,\n\t\t\t\t\t   protoff, data, dataoff,\n\t\t\t\t\t   &mscm->request.openLogicalChannel);\n\t\t}\n\t\tpr_debug(\"nf_ct_h323: H.245 Request %d\\n\",\n\t\t\t mscm->request.choice);\n\t\tbreak;\n\tcase eMultimediaSystemControlMessage_response:\n\t\tif (mscm->response.choice ==\n\t\t    eResponseMessage_openLogicalChannelAck) {\n\t\t\treturn process_olca(skb, ct, ctinfo,\n\t\t\t\t\t    protoff, data, dataoff,\n\t\t\t\t\t    &mscm->response.\n\t\t\t\t\t    openLogicalChannelAck);\n\t\t}\n\t\tpr_debug(\"nf_ct_h323: H.245 Response %d\\n\",\n\t\t\t mscm->response.choice);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"nf_ct_h323: H.245 signal %d\\n\", mscm->choice);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int h245_help(struct sk_buff *skb, unsigned int protoff,\n\t\t     struct nf_conn *ct, enum ip_conntrack_info ctinfo)\n{\n\tstatic MultimediaSystemControlMessage mscm;\n\tunsigned char *data = NULL;\n\tint datalen;\n\tint dataoff;\n\tint ret;\n\n\t \n\tif (ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED_REPLY)\n\t\treturn NF_ACCEPT;\n\n\tpr_debug(\"nf_ct_h245: skblen = %u\\n\", skb->len);\n\n\tspin_lock_bh(&nf_h323_lock);\n\n\t \n\twhile (get_tpkt_data(skb, protoff, ct, ctinfo,\n\t\t\t     &data, &datalen, &dataoff)) {\n\t\tpr_debug(\"nf_ct_h245: TPKT len=%d \", datalen);\n\t\tnf_ct_dump_tuple(&ct->tuplehash[CTINFO2DIR(ctinfo)].tuple);\n\n\t\t \n\t\tret = DecodeMultimediaSystemControlMessage(data, datalen,\n\t\t\t\t\t\t\t   &mscm);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"nf_ct_h245: decoding error: %s\\n\",\n\t\t\t\t ret == H323_ERROR_BOUND ?\n\t\t\t\t \"out of bound\" : \"out of range\");\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (process_h245(skb, ct, ctinfo, protoff,\n\t\t\t\t &data, dataoff, &mscm) < 0)\n\t\t\tgoto drop;\n\t}\n\n\tspin_unlock_bh(&nf_h323_lock);\n\treturn NF_ACCEPT;\n\n      drop:\n\tspin_unlock_bh(&nf_h323_lock);\n\tnf_ct_helper_log(skb, ct, \"cannot process H.245 message\");\n\treturn NF_DROP;\n}\n\nstatic const struct nf_conntrack_expect_policy h245_exp_policy = {\n\t.max_expected\t= H323_RTP_CHANNEL_MAX * 4 + 2  ,\n\t.timeout\t= 240,\n};\n\nstatic struct nf_conntrack_helper nf_conntrack_helper_h245 __read_mostly = {\n\t.name\t\t\t= \"H.245\",\n\t.me\t\t\t= THIS_MODULE,\n\t.tuple.src.l3num\t= AF_UNSPEC,\n\t.tuple.dst.protonum\t= IPPROTO_UDP,\n\t.help\t\t\t= h245_help,\n\t.expect_policy\t\t= &h245_exp_policy,\n};\n\nint get_h225_addr(struct nf_conn *ct, unsigned char *data,\n\t\t  TransportAddress *taddr,\n\t\t  union nf_inet_addr *addr, __be16 *port)\n{\n\tconst unsigned char *p;\n\tint len;\n\n\tswitch (taddr->choice) {\n\tcase eTransportAddress_ipAddress:\n\t\tif (nf_ct_l3num(ct) != AF_INET)\n\t\t\treturn 0;\n\t\tp = data + taddr->ipAddress.ip;\n\t\tlen = 4;\n\t\tbreak;\n\tcase eTransportAddress_ip6Address:\n\t\tif (nf_ct_l3num(ct) != AF_INET6)\n\t\t\treturn 0;\n\t\tp = data + taddr->ip6Address.ip;\n\t\tlen = 16;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tmemcpy(addr, p, len);\n\tmemset((void *)addr + len, 0, sizeof(*addr) - len);\n\tmemcpy(port, p + len, sizeof(__be16));\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(get_h225_addr);\n\nstatic int expect_h245(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff, unsigned char **data, int dataoff,\n\t\t       TransportAddress *taddr)\n{\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret = 0;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\tstruct nf_conntrack_expect *exp;\n\n\t \n\tif (!get_h225_addr(ct, *data, taddr, &addr, &port) ||\n\t    memcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) ||\n\t    port == 0)\n\t\treturn 0;\n\n\t \n\tif ((exp = nf_ct_expect_alloc(ct)) == NULL)\n\t\treturn -1;\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\t  &ct->tuplehash[!dir].tuple.src.u3,\n\t\t\t  &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t  IPPROTO_TCP, NULL, &port);\n\texp->helper = &nf_conntrack_helper_h245;\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (memcmp(&ct->tuplehash[dir].tuple.src.u3,\n\t\t   &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t   sizeof(ct->tuplehash[dir].tuple.src.u3)) &&\n\t    nathook &&\n\t    nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK) {\n\t\t \n\t\tret = nathook->nat_h245(skb, ct, ctinfo, protoff, data,\n\t\t\t\t\tdataoff, taddr, port, exp);\n\t} else {\t\t \n\t\tif (nf_ct_expect_related(exp, 0) == 0) {\n\t\t\tpr_debug(\"nf_ct_q931: expect H.245 \");\n\t\t\tnf_ct_dump_tuple(&exp->tuple);\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\tnf_ct_expect_put(exp);\n\n\treturn ret;\n}\n\n \nstatic int callforward_do_filter(struct net *net,\n\t\t\t\t const union nf_inet_addr *src,\n\t\t\t\t const union nf_inet_addr *dst,\n\t\t\t\t u_int8_t family)\n{\n\tint ret = 0;\n\n\tswitch (family) {\n\tcase AF_INET: {\n\t\tstruct flowi4 fl1, fl2;\n\t\tstruct rtable *rt1, *rt2;\n\n\t\tmemset(&fl1, 0, sizeof(fl1));\n\t\tfl1.daddr = src->ip;\n\n\t\tmemset(&fl2, 0, sizeof(fl2));\n\t\tfl2.daddr = dst->ip;\n\t\tif (!nf_ip_route(net, (struct dst_entry **)&rt1,\n\t\t\t\t flowi4_to_flowi(&fl1), false)) {\n\t\t\tif (!nf_ip_route(net, (struct dst_entry **)&rt2,\n\t\t\t\t\t flowi4_to_flowi(&fl2), false)) {\n\t\t\t\tif (rt_nexthop(rt1, fl1.daddr) ==\n\t\t\t\t    rt_nexthop(rt2, fl2.daddr) &&\n\t\t\t\t    rt1->dst.dev  == rt2->dst.dev)\n\t\t\t\t\tret = 1;\n\t\t\t\tdst_release(&rt2->dst);\n\t\t\t}\n\t\t\tdst_release(&rt1->dst);\n\t\t}\n\t\tbreak;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6: {\n\t\tstruct rt6_info *rt1, *rt2;\n\t\tstruct flowi6 fl1, fl2;\n\n\t\tmemset(&fl1, 0, sizeof(fl1));\n\t\tfl1.daddr = src->in6;\n\n\t\tmemset(&fl2, 0, sizeof(fl2));\n\t\tfl2.daddr = dst->in6;\n\t\tif (!nf_ip6_route(net, (struct dst_entry **)&rt1,\n\t\t\t\t  flowi6_to_flowi(&fl1), false)) {\n\t\t\tif (!nf_ip6_route(net, (struct dst_entry **)&rt2,\n\t\t\t\t\t  flowi6_to_flowi(&fl2), false)) {\n\t\t\t\tif (ipv6_addr_equal(rt6_nexthop(rt1, &fl1.daddr),\n\t\t\t\t\t\t    rt6_nexthop(rt2, &fl2.daddr)) &&\n\t\t\t\t    rt1->dst.dev == rt2->dst.dev)\n\t\t\t\t\tret = 1;\n\t\t\t\tdst_release(&rt2->dst);\n\t\t\t}\n\t\t\tdst_release(&rt1->dst);\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\t}\n\treturn ret;\n\n}\n\nstatic int expect_callforwarding(struct sk_buff *skb,\n\t\t\t\t struct nf_conn *ct,\n\t\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t\t unsigned int protoff,\n\t\t\t\t unsigned char **data, int dataoff,\n\t\t\t\t TransportAddress *taddr)\n{\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret = 0;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\tstruct nf_conntrack_expect *exp;\n\tstruct net *net = nf_ct_net(ct);\n\n\t \n\tif (!get_h225_addr(ct, *data, taddr, &addr, &port) || port == 0)\n\t\treturn 0;\n\n\t \n\tif (callforward_filter &&\n\t    callforward_do_filter(net, &addr, &ct->tuplehash[!dir].tuple.src.u3,\n\t\t\t\t  nf_ct_l3num(ct))) {\n\t\tpr_debug(\"nf_ct_q931: Call Forwarding not tracked\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif ((exp = nf_ct_expect_alloc(ct)) == NULL)\n\t\treturn -1;\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\t  &ct->tuplehash[!dir].tuple.src.u3, &addr,\n\t\t\t  IPPROTO_TCP, NULL, &port);\n\texp->helper = nf_conntrack_helper_q931;\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (memcmp(&ct->tuplehash[dir].tuple.src.u3,\n\t\t   &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t   sizeof(ct->tuplehash[dir].tuple.src.u3)) &&\n\t    nathook &&\n\t    nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK) {\n\t\t \n\t\tret = nathook->nat_callforwarding(skb, ct, ctinfo,\n\t\t\t\t\t\t  protoff, data, dataoff,\n\t\t\t\t\t\t  taddr, port, exp);\n\t} else {\t\t \n\t\tif (nf_ct_expect_related(exp, 0) == 0) {\n\t\t\tpr_debug(\"nf_ct_q931: expect Call Forwarding \");\n\t\t\tnf_ct_dump_tuple(&exp->tuple);\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\tnf_ct_expect_put(exp);\n\n\treturn ret;\n}\n\nstatic int process_setup(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned char **data, int dataoff,\n\t\t\t Setup_UUIE *setup)\n{\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret;\n\tint i;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\n\tpr_debug(\"nf_ct_q931: Setup\\n\");\n\n\tif (setup->options & eSetup_UUIE_h245Address) {\n\t\tret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t  &setup->h245Address);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif ((setup->options & eSetup_UUIE_destCallSignalAddress) &&\n\t    nathook && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK &&\n\t    get_h225_addr(ct, *data, &setup->destCallSignalAddress,\n\t\t\t  &addr, &port) &&\n\t    memcmp(&addr, &ct->tuplehash[!dir].tuple.src.u3, sizeof(addr))) {\n\t\tpr_debug(\"nf_ct_q931: set destCallSignalAddress %pI6:%hu->%pI6:%hu\\n\",\n\t\t\t &addr, ntohs(port), &ct->tuplehash[!dir].tuple.src.u3,\n\t\t\t ntohs(ct->tuplehash[!dir].tuple.src.u.tcp.port));\n\t\tret = nathook->set_h225_addr(skb, protoff, data, dataoff,\n\t\t\t\t\t     &setup->destCallSignalAddress,\n\t\t\t\t\t     &ct->tuplehash[!dir].tuple.src.u3,\n\t\t\t\t\t     ct->tuplehash[!dir].tuple.src.u.tcp.port);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif ((setup->options & eSetup_UUIE_sourceCallSignalAddress) &&\n\t    nathook && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK &&\n\t    get_h225_addr(ct, *data, &setup->sourceCallSignalAddress,\n\t\t\t  &addr, &port) &&\n\t    memcmp(&addr, &ct->tuplehash[!dir].tuple.dst.u3, sizeof(addr))) {\n\t\tpr_debug(\"nf_ct_q931: set sourceCallSignalAddress %pI6:%hu->%pI6:%hu\\n\",\n\t\t\t &addr, ntohs(port), &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t ntohs(ct->tuplehash[!dir].tuple.dst.u.tcp.port));\n\t\tret = nathook->set_h225_addr(skb, protoff, data, dataoff,\n\t\t\t\t\t     &setup->sourceCallSignalAddress,\n\t\t\t\t\t     &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t\t\t     ct->tuplehash[!dir].tuple.dst.u.tcp.port);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (setup->options & eSetup_UUIE_fastStart) {\n\t\tfor (i = 0; i < setup->fastStart.count; i++) {\n\t\t\tret = process_olc(skb, ct, ctinfo,\n\t\t\t\t\t  protoff, data, dataoff,\n\t\t\t\t\t  &setup->fastStart.item[i]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int process_callproceeding(struct sk_buff *skb,\n\t\t\t\t  struct nf_conn *ct,\n\t\t\t\t  enum ip_conntrack_info ctinfo,\n\t\t\t\t  unsigned int protoff,\n\t\t\t\t  unsigned char **data, int dataoff,\n\t\t\t\t  CallProceeding_UUIE *callproc)\n{\n\tint ret;\n\tint i;\n\n\tpr_debug(\"nf_ct_q931: CallProceeding\\n\");\n\n\tif (callproc->options & eCallProceeding_UUIE_h245Address) {\n\t\tret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t  &callproc->h245Address);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (callproc->options & eCallProceeding_UUIE_fastStart) {\n\t\tfor (i = 0; i < callproc->fastStart.count; i++) {\n\t\t\tret = process_olc(skb, ct, ctinfo,\n\t\t\t\t\t  protoff, data, dataoff,\n\t\t\t\t\t  &callproc->fastStart.item[i]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int process_connect(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t   enum ip_conntrack_info ctinfo,\n\t\t\t   unsigned int protoff,\n\t\t\t   unsigned char **data, int dataoff,\n\t\t\t   Connect_UUIE *connect)\n{\n\tint ret;\n\tint i;\n\n\tpr_debug(\"nf_ct_q931: Connect\\n\");\n\n\tif (connect->options & eConnect_UUIE_h245Address) {\n\t\tret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t  &connect->h245Address);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (connect->options & eConnect_UUIE_fastStart) {\n\t\tfor (i = 0; i < connect->fastStart.count; i++) {\n\t\t\tret = process_olc(skb, ct, ctinfo,\n\t\t\t\t\t  protoff, data, dataoff,\n\t\t\t\t\t  &connect->fastStart.item[i]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int process_alerting(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t    unsigned int protoff,\n\t\t\t    unsigned char **data, int dataoff,\n\t\t\t    Alerting_UUIE *alert)\n{\n\tint ret;\n\tint i;\n\n\tpr_debug(\"nf_ct_q931: Alerting\\n\");\n\n\tif (alert->options & eAlerting_UUIE_h245Address) {\n\t\tret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t  &alert->h245Address);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (alert->options & eAlerting_UUIE_fastStart) {\n\t\tfor (i = 0; i < alert->fastStart.count; i++) {\n\t\t\tret = process_olc(skb, ct, ctinfo,\n\t\t\t\t\t  protoff, data, dataoff,\n\t\t\t\t\t  &alert->fastStart.item[i]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int process_facility(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t    unsigned int protoff,\n\t\t\t    unsigned char **data, int dataoff,\n\t\t\t    Facility_UUIE *facility)\n{\n\tint ret;\n\tint i;\n\n\tpr_debug(\"nf_ct_q931: Facility\\n\");\n\n\tif (facility->reason.choice == eFacilityReason_callForwarded) {\n\t\tif (facility->options & eFacility_UUIE_alternativeAddress)\n\t\t\treturn expect_callforwarding(skb, ct, ctinfo,\n\t\t\t\t\t\t     protoff, data, dataoff,\n\t\t\t\t\t\t     &facility->\n\t\t\t\t\t\t     alternativeAddress);\n\t\treturn 0;\n\t}\n\n\tif (facility->options & eFacility_UUIE_h245Address) {\n\t\tret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t  &facility->h245Address);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (facility->options & eFacility_UUIE_fastStart) {\n\t\tfor (i = 0; i < facility->fastStart.count; i++) {\n\t\t\tret = process_olc(skb, ct, ctinfo,\n\t\t\t\t\t  protoff, data, dataoff,\n\t\t\t\t\t  &facility->fastStart.item[i]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int process_progress(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t    unsigned int protoff,\n\t\t\t    unsigned char **data, int dataoff,\n\t\t\t    Progress_UUIE *progress)\n{\n\tint ret;\n\tint i;\n\n\tpr_debug(\"nf_ct_q931: Progress\\n\");\n\n\tif (progress->options & eProgress_UUIE_h245Address) {\n\t\tret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t  &progress->h245Address);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (progress->options & eProgress_UUIE_fastStart) {\n\t\tfor (i = 0; i < progress->fastStart.count; i++) {\n\t\t\tret = process_olc(skb, ct, ctinfo,\n\t\t\t\t\t  protoff, data, dataoff,\n\t\t\t\t\t  &progress->fastStart.item[i]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int process_q931(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\tenum ip_conntrack_info ctinfo,\n\t\t\tunsigned int protoff, unsigned char **data, int dataoff,\n\t\t\tQ931 *q931)\n{\n\tH323_UU_PDU *pdu = &q931->UUIE.h323_uu_pdu;\n\tint i;\n\tint ret = 0;\n\n\tswitch (pdu->h323_message_body.choice) {\n\tcase eH323_UU_PDU_h323_message_body_setup:\n\t\tret = process_setup(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t    &pdu->h323_message_body.setup);\n\t\tbreak;\n\tcase eH323_UU_PDU_h323_message_body_callProceeding:\n\t\tret = process_callproceeding(skb, ct, ctinfo,\n\t\t\t\t\t     protoff, data, dataoff,\n\t\t\t\t\t     &pdu->h323_message_body.\n\t\t\t\t\t     callProceeding);\n\t\tbreak;\n\tcase eH323_UU_PDU_h323_message_body_connect:\n\t\tret = process_connect(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t      &pdu->h323_message_body.connect);\n\t\tbreak;\n\tcase eH323_UU_PDU_h323_message_body_alerting:\n\t\tret = process_alerting(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t       &pdu->h323_message_body.alerting);\n\t\tbreak;\n\tcase eH323_UU_PDU_h323_message_body_facility:\n\t\tret = process_facility(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t       &pdu->h323_message_body.facility);\n\t\tbreak;\n\tcase eH323_UU_PDU_h323_message_body_progress:\n\t\tret = process_progress(skb, ct, ctinfo, protoff, data, dataoff,\n\t\t\t\t       &pdu->h323_message_body.progress);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"nf_ct_q931: Q.931 signal %d\\n\",\n\t\t\t pdu->h323_message_body.choice);\n\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\tif (pdu->options & eH323_UU_PDU_h245Control) {\n\t\tfor (i = 0; i < pdu->h245Control.count; i++) {\n\t\t\tret = process_h245(skb, ct, ctinfo,\n\t\t\t\t\t   protoff, data, dataoff,\n\t\t\t\t\t   &pdu->h245Control.item[i]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int q931_help(struct sk_buff *skb, unsigned int protoff,\n\t\t     struct nf_conn *ct, enum ip_conntrack_info ctinfo)\n{\n\tstatic Q931 q931;\n\tunsigned char *data = NULL;\n\tint datalen;\n\tint dataoff;\n\tint ret;\n\n\t \n\tif (ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED_REPLY)\n\t\treturn NF_ACCEPT;\n\n\tpr_debug(\"nf_ct_q931: skblen = %u\\n\", skb->len);\n\n\tspin_lock_bh(&nf_h323_lock);\n\n\t \n\twhile (get_tpkt_data(skb, protoff, ct, ctinfo,\n\t\t\t     &data, &datalen, &dataoff)) {\n\t\tpr_debug(\"nf_ct_q931: TPKT len=%d \", datalen);\n\t\tnf_ct_dump_tuple(&ct->tuplehash[CTINFO2DIR(ctinfo)].tuple);\n\n\t\t \n\t\tret = DecodeQ931(data, datalen, &q931);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"nf_ct_q931: decoding error: %s\\n\",\n\t\t\t\t ret == H323_ERROR_BOUND ?\n\t\t\t\t \"out of bound\" : \"out of range\");\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (process_q931(skb, ct, ctinfo, protoff,\n\t\t\t\t &data, dataoff, &q931) < 0)\n\t\t\tgoto drop;\n\t}\n\n\tspin_unlock_bh(&nf_h323_lock);\n\treturn NF_ACCEPT;\n\n      drop:\n\tspin_unlock_bh(&nf_h323_lock);\n\tnf_ct_helper_log(skb, ct, \"cannot process Q.931 message\");\n\treturn NF_DROP;\n}\n\nstatic const struct nf_conntrack_expect_policy q931_exp_policy = {\n\t \n\t.max_expected\t\t= H323_RTP_CHANNEL_MAX * 4 + 4,\n\t.timeout\t\t= 240,\n};\n\nstatic struct nf_conntrack_helper nf_conntrack_helper_q931[] __read_mostly = {\n\t{\n\t\t.name\t\t\t= \"Q.931\",\n\t\t.me\t\t\t= THIS_MODULE,\n\t\t.tuple.src.l3num\t= AF_INET,\n\t\t.tuple.src.u.tcp.port\t= cpu_to_be16(Q931_PORT),\n\t\t.tuple.dst.protonum\t= IPPROTO_TCP,\n\t\t.help\t\t\t= q931_help,\n\t\t.expect_policy\t\t= &q931_exp_policy,\n\t},\n\t{\n\t\t.name\t\t\t= \"Q.931\",\n\t\t.me\t\t\t= THIS_MODULE,\n\t\t.tuple.src.l3num\t= AF_INET6,\n\t\t.tuple.src.u.tcp.port\t= cpu_to_be16(Q931_PORT),\n\t\t.tuple.dst.protonum\t= IPPROTO_TCP,\n\t\t.help\t\t\t= q931_help,\n\t\t.expect_policy\t\t= &q931_exp_policy,\n\t},\n};\n\nstatic unsigned char *get_udp_data(struct sk_buff *skb, unsigned int protoff,\n\t\t\t\t   int *datalen)\n{\n\tconst struct udphdr *uh;\n\tstruct udphdr _uh;\n\tint dataoff;\n\n\tuh = skb_header_pointer(skb, protoff, sizeof(_uh), &_uh);\n\tif (uh == NULL)\n\t\treturn NULL;\n\tdataoff = protoff + sizeof(_uh);\n\tif (dataoff >= skb->len)\n\t\treturn NULL;\n\t*datalen = skb->len - dataoff;\n\tif (*datalen > H323_MAX_SIZE)\n\t\t*datalen = H323_MAX_SIZE;\n\n\treturn skb_header_pointer(skb, dataoff, *datalen, h323_buffer);\n}\n\nstatic struct nf_conntrack_expect *find_expect(struct nf_conn *ct,\n\t\t\t\t\t       union nf_inet_addr *addr,\n\t\t\t\t\t       __be16 port)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conntrack_tuple tuple;\n\n\tmemset(&tuple.src.u3, 0, sizeof(tuple.src.u3));\n\ttuple.src.u.tcp.port = 0;\n\tmemcpy(&tuple.dst.u3, addr, sizeof(tuple.dst.u3));\n\ttuple.dst.u.tcp.port = port;\n\ttuple.dst.protonum = IPPROTO_TCP;\n\n\texp = __nf_ct_expect_find(net, nf_ct_zone(ct), &tuple);\n\tif (exp && exp->master == ct)\n\t\treturn exp;\n\treturn NULL;\n}\n\nstatic int expect_q931(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff, unsigned char **data,\n\t\t       TransportAddress *taddr, int count)\n{\n\tstruct nf_ct_h323_master *info = nfct_help_data(ct);\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret = 0;\n\tint i;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\tstruct nf_conntrack_expect *exp;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tif (get_h225_addr(ct, *data, &taddr[i], &addr, &port) &&\n\t\t    memcmp(&addr, &ct->tuplehash[dir].tuple.src.u3,\n\t\t\t   sizeof(addr)) == 0 && port != 0)\n\t\t\tbreak;\n\t}\n\n\tif (i >= count)\t\t \n\t\treturn 0;\n\n\t \n\tif ((exp = nf_ct_expect_alloc(ct)) == NULL)\n\t\treturn -1;\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\t  gkrouted_only ?  \n\t\t\t\t&ct->tuplehash[!dir].tuple.src.u3 : NULL,\n\t\t\t  &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t  IPPROTO_TCP, NULL, &port);\n\texp->helper = nf_conntrack_helper_q931;\n\texp->flags = NF_CT_EXPECT_PERMANENT;\t \n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (nathook && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK) {\t \n\t\tret = nathook->nat_q931(skb, ct, ctinfo, protoff, data,\n\t\t\t\t\ttaddr, i, port, exp);\n\t} else {\t\t \n\t\tif (nf_ct_expect_related(exp, 0) == 0) {\n\t\t\tpr_debug(\"nf_ct_ras: expect Q.931 \");\n\t\t\tnf_ct_dump_tuple(&exp->tuple);\n\n\t\t\t \n\t\t\tinfo->sig_port[dir] = port;\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\tnf_ct_expect_put(exp);\n\n\treturn ret;\n}\n\nstatic int process_grq(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, GatekeeperRequest *grq)\n{\n\tconst struct nfct_h323_nat_hooks *nathook;\n\n\tpr_debug(\"nf_ct_ras: GRQ\\n\");\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (nathook && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK)\t \n\t\treturn nathook->set_ras_addr(skb, ct, ctinfo, protoff, data,\n\t\t\t\t\t     &grq->rasAddress, 1);\n\treturn 0;\n}\n\nstatic int process_gcf(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, GatekeeperConfirm *gcf)\n{\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret = 0;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\tstruct nf_conntrack_expect *exp;\n\n\tpr_debug(\"nf_ct_ras: GCF\\n\");\n\n\tif (!get_h225_addr(ct, *data, &gcf->rasAddress, &addr, &port))\n\t\treturn 0;\n\n\t \n\tif (!memcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) &&\n\t    port == ct->tuplehash[dir].tuple.src.u.udp.port)\n\t\treturn 0;\n\n\t \n\tif (test_bit(IPS_EXPECTED_BIT, &ct->status))\n\t\treturn 0;\n\n\t \n\tif ((exp = nf_ct_expect_alloc(ct)) == NULL)\n\t\treturn -1;\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\t  &ct->tuplehash[!dir].tuple.src.u3, &addr,\n\t\t\t  IPPROTO_UDP, NULL, &port);\n\texp->helper = nf_conntrack_helper_ras;\n\n\tif (nf_ct_expect_related(exp, 0) == 0) {\n\t\tpr_debug(\"nf_ct_ras: expect RAS \");\n\t\tnf_ct_dump_tuple(&exp->tuple);\n\t} else\n\t\tret = -1;\n\n\tnf_ct_expect_put(exp);\n\n\treturn ret;\n}\n\nstatic int process_rrq(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, RegistrationRequest *rrq)\n{\n\tstruct nf_ct_h323_master *info = nfct_help_data(ct);\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint ret;\n\n\tpr_debug(\"nf_ct_ras: RRQ\\n\");\n\n\tret = expect_q931(skb, ct, ctinfo, protoff, data,\n\t\t\t  rrq->callSignalAddress.item,\n\t\t\t  rrq->callSignalAddress.count);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (nathook && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK) {\n\t\tret = nathook->set_ras_addr(skb, ct, ctinfo, protoff, data,\n\t\t\t\t\t    rrq->rasAddress.item,\n\t\t\t\t\t    rrq->rasAddress.count);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (rrq->options & eRegistrationRequest_timeToLive) {\n\t\tpr_debug(\"nf_ct_ras: RRQ TTL = %u seconds\\n\", rrq->timeToLive);\n\t\tinfo->timeout = rrq->timeToLive;\n\t} else\n\t\tinfo->timeout = default_rrq_ttl;\n\n\treturn 0;\n}\n\nstatic int process_rcf(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, RegistrationConfirm *rcf)\n{\n\tstruct nf_ct_h323_master *info = nfct_help_data(ct);\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret;\n\tstruct nf_conntrack_expect *exp;\n\n\tpr_debug(\"nf_ct_ras: RCF\\n\");\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (nathook && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK) {\n\t\tret = nathook->set_sig_addr(skb, ct, ctinfo, protoff, data,\n\t\t\t\t\t    rcf->callSignalAddress.item,\n\t\t\t\t\t    rcf->callSignalAddress.count);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (rcf->options & eRegistrationConfirm_timeToLive) {\n\t\tpr_debug(\"nf_ct_ras: RCF TTL = %u seconds\\n\", rcf->timeToLive);\n\t\tinfo->timeout = rcf->timeToLive;\n\t}\n\n\tif (info->timeout > 0) {\n\t\tpr_debug(\"nf_ct_ras: set RAS connection timeout to \"\n\t\t\t \"%u seconds\\n\", info->timeout);\n\t\tnf_ct_refresh(ct, skb, info->timeout * HZ);\n\n\t\t \n\t\tspin_lock_bh(&nf_conntrack_expect_lock);\n\t\texp = find_expect(ct, &ct->tuplehash[dir].tuple.dst.u3,\n\t\t\t\t  info->sig_port[!dir]);\n\t\tif (exp) {\n\t\t\tpr_debug(\"nf_ct_ras: set Q.931 expect \"\n\t\t\t\t \"timeout to %u seconds for\",\n\t\t\t\t info->timeout);\n\t\t\tnf_ct_dump_tuple(&exp->tuple);\n\t\t\tmod_timer_pending(&exp->timeout,\n\t\t\t\t\t  jiffies + info->timeout * HZ);\n\t\t}\n\t\tspin_unlock_bh(&nf_conntrack_expect_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int process_urq(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, UnregistrationRequest *urq)\n{\n\tstruct nf_ct_h323_master *info = nfct_help_data(ct);\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret;\n\n\tpr_debug(\"nf_ct_ras: URQ\\n\");\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (nathook && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK) {\n\t\tret = nathook->set_sig_addr(skb, ct, ctinfo, protoff, data,\n\t\t\t\t\t    urq->callSignalAddress.item,\n\t\t\t\t\t    urq->callSignalAddress.count);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\t \n\tnf_ct_remove_expectations(ct);\n\tinfo->sig_port[dir] = 0;\n\tinfo->sig_port[!dir] = 0;\n\n\t \n\tnf_ct_refresh(ct, skb, 30 * HZ);\n\n\treturn 0;\n}\n\nstatic int process_arq(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, AdmissionRequest *arq)\n{\n\tconst struct nf_ct_h323_master *info = nfct_help_data(ct);\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint dir = CTINFO2DIR(ctinfo);\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\n\tpr_debug(\"nf_ct_ras: ARQ\\n\");\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (!nathook)\n\t\treturn 0;\n\n\tif ((arq->options & eAdmissionRequest_destCallSignalAddress) &&\n\t    get_h225_addr(ct, *data, &arq->destCallSignalAddress,\n\t\t\t  &addr, &port) &&\n\t    !memcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) &&\n\t    port == info->sig_port[dir] &&\n\t    nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK) {\n\t\t \n\t\treturn nathook->set_h225_addr(skb, protoff, data, 0,\n\t\t\t\t\t      &arq->destCallSignalAddress,\n\t\t\t\t\t      &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t\t\t      info->sig_port[!dir]);\n\t}\n\n\tif ((arq->options & eAdmissionRequest_srcCallSignalAddress) &&\n\t    get_h225_addr(ct, *data, &arq->srcCallSignalAddress,\n\t\t\t  &addr, &port) &&\n\t    !memcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) &&\n\t    nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK) {\n\t\t \n\t\treturn nathook->set_h225_addr(skb, protoff, data, 0,\n\t\t\t\t\t      &arq->srcCallSignalAddress,\n\t\t\t\t\t      &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t\t\t\t      port);\n\t}\n\n\treturn 0;\n}\n\nstatic int process_acf(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, AdmissionConfirm *acf)\n{\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret = 0;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\tstruct nf_conntrack_expect *exp;\n\n\tpr_debug(\"nf_ct_ras: ACF\\n\");\n\n\tif (!get_h225_addr(ct, *data, &acf->destCallSignalAddress,\n\t\t\t   &addr, &port))\n\t\treturn 0;\n\n\tif (!memcmp(&addr, &ct->tuplehash[dir].tuple.dst.u3, sizeof(addr))) {\n\t\tconst struct nfct_h323_nat_hooks *nathook;\n\n\t\t \n\t\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\t\tif (nathook && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t\t    ct->status & IPS_NAT_MASK)\n\t\t\treturn nathook->set_sig_addr(skb, ct, ctinfo, protoff,\n\t\t\t\t\t\t     data,\n\t\t\t\t\t\t     &acf->destCallSignalAddress, 1);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((exp = nf_ct_expect_alloc(ct)) == NULL)\n\t\treturn -1;\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\t  &ct->tuplehash[!dir].tuple.src.u3, &addr,\n\t\t\t  IPPROTO_TCP, NULL, &port);\n\texp->flags = NF_CT_EXPECT_PERMANENT;\n\texp->helper = nf_conntrack_helper_q931;\n\n\tif (nf_ct_expect_related(exp, 0) == 0) {\n\t\tpr_debug(\"nf_ct_ras: expect Q.931 \");\n\t\tnf_ct_dump_tuple(&exp->tuple);\n\t} else\n\t\tret = -1;\n\n\tnf_ct_expect_put(exp);\n\n\treturn ret;\n}\n\nstatic int process_lrq(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, LocationRequest *lrq)\n{\n\tconst struct nfct_h323_nat_hooks *nathook;\n\n\tpr_debug(\"nf_ct_ras: LRQ\\n\");\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (nathook && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK)\n\t\treturn nathook->set_ras_addr(skb, ct, ctinfo, protoff, data,\n\t\t\t\t\t     &lrq->replyAddress, 1);\n\treturn 0;\n}\n\nstatic int process_lcf(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, LocationConfirm *lcf)\n{\n\tint dir = CTINFO2DIR(ctinfo);\n\tint ret = 0;\n\t__be16 port;\n\tunion nf_inet_addr addr;\n\tstruct nf_conntrack_expect *exp;\n\n\tpr_debug(\"nf_ct_ras: LCF\\n\");\n\n\tif (!get_h225_addr(ct, *data, &lcf->callSignalAddress,\n\t\t\t   &addr, &port))\n\t\treturn 0;\n\n\t \n\tif ((exp = nf_ct_expect_alloc(ct)) == NULL)\n\t\treturn -1;\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\t  &ct->tuplehash[!dir].tuple.src.u3, &addr,\n\t\t\t  IPPROTO_TCP, NULL, &port);\n\texp->flags = NF_CT_EXPECT_PERMANENT;\n\texp->helper = nf_conntrack_helper_q931;\n\n\tif (nf_ct_expect_related(exp, 0) == 0) {\n\t\tpr_debug(\"nf_ct_ras: expect Q.931 \");\n\t\tnf_ct_dump_tuple(&exp->tuple);\n\t} else\n\t\tret = -1;\n\n\tnf_ct_expect_put(exp);\n\n\t \n\n\treturn ret;\n}\n\nstatic int process_irr(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, InfoRequestResponse *irr)\n{\n\tconst struct nfct_h323_nat_hooks *nathook;\n\tint ret;\n\n\tpr_debug(\"nf_ct_ras: IRR\\n\");\n\n\tnathook = rcu_dereference(nfct_h323_nat_hook);\n\tif (nathook && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\n\t    ct->status & IPS_NAT_MASK) {\n\t\tret = nathook->set_ras_addr(skb, ct, ctinfo, protoff, data,\n\t\t\t\t\t    &irr->rasAddress, 1);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\n\t\tret = nathook->set_sig_addr(skb, ct, ctinfo, protoff, data,\n\t\t\t\t\t    irr->callSignalAddress.item,\n\t\t\t\t\t    irr->callSignalAddress.count);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int process_ras(struct sk_buff *skb, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       unsigned int protoff,\n\t\t       unsigned char **data, RasMessage *ras)\n{\n\tswitch (ras->choice) {\n\tcase eRasMessage_gatekeeperRequest:\n\t\treturn process_grq(skb, ct, ctinfo, protoff, data,\n\t\t\t\t   &ras->gatekeeperRequest);\n\tcase eRasMessage_gatekeeperConfirm:\n\t\treturn process_gcf(skb, ct, ctinfo, protoff, data,\n\t\t\t\t   &ras->gatekeeperConfirm);\n\tcase eRasMessage_registrationRequest:\n\t\treturn process_rrq(skb, ct, ctinfo, protoff, data,\n\t\t\t\t   &ras->registrationRequest);\n\tcase eRasMessage_registrationConfirm:\n\t\treturn process_rcf(skb, ct, ctinfo, protoff, data,\n\t\t\t\t   &ras->registrationConfirm);\n\tcase eRasMessage_unregistrationRequest:\n\t\treturn process_urq(skb, ct, ctinfo, protoff, data,\n\t\t\t\t   &ras->unregistrationRequest);\n\tcase eRasMessage_admissionRequest:\n\t\treturn process_arq(skb, ct, ctinfo, protoff, data,\n\t\t\t\t   &ras->admissionRequest);\n\tcase eRasMessage_admissionConfirm:\n\t\treturn process_acf(skb, ct, ctinfo, protoff, data,\n\t\t\t\t   &ras->admissionConfirm);\n\tcase eRasMessage_locationRequest:\n\t\treturn process_lrq(skb, ct, ctinfo, protoff, data,\n\t\t\t\t   &ras->locationRequest);\n\tcase eRasMessage_locationConfirm:\n\t\treturn process_lcf(skb, ct, ctinfo, protoff, data,\n\t\t\t\t   &ras->locationConfirm);\n\tcase eRasMessage_infoRequestResponse:\n\t\treturn process_irr(skb, ct, ctinfo, protoff, data,\n\t\t\t\t   &ras->infoRequestResponse);\n\tdefault:\n\t\tpr_debug(\"nf_ct_ras: RAS message %d\\n\", ras->choice);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ras_help(struct sk_buff *skb, unsigned int protoff,\n\t\t    struct nf_conn *ct, enum ip_conntrack_info ctinfo)\n{\n\tstatic RasMessage ras;\n\tunsigned char *data;\n\tint datalen = 0;\n\tint ret;\n\n\tpr_debug(\"nf_ct_ras: skblen = %u\\n\", skb->len);\n\n\tspin_lock_bh(&nf_h323_lock);\n\n\t \n\tdata = get_udp_data(skb, protoff, &datalen);\n\tif (data == NULL)\n\t\tgoto accept;\n\tpr_debug(\"nf_ct_ras: RAS message len=%d \", datalen);\n\tnf_ct_dump_tuple(&ct->tuplehash[CTINFO2DIR(ctinfo)].tuple);\n\n\t \n\tret = DecodeRasMessage(data, datalen, &ras);\n\tif (ret < 0) {\n\t\tpr_debug(\"nf_ct_ras: decoding error: %s\\n\",\n\t\t\t ret == H323_ERROR_BOUND ?\n\t\t\t \"out of bound\" : \"out of range\");\n\t\tgoto accept;\n\t}\n\n\t \n\tif (process_ras(skb, ct, ctinfo, protoff, &data, &ras) < 0)\n\t\tgoto drop;\n\n      accept:\n\tspin_unlock_bh(&nf_h323_lock);\n\treturn NF_ACCEPT;\n\n      drop:\n\tspin_unlock_bh(&nf_h323_lock);\n\tnf_ct_helper_log(skb, ct, \"cannot process RAS message\");\n\treturn NF_DROP;\n}\n\nstatic const struct nf_conntrack_expect_policy ras_exp_policy = {\n\t.max_expected\t\t= 32,\n\t.timeout\t\t= 240,\n};\n\nstatic struct nf_conntrack_helper nf_conntrack_helper_ras[] __read_mostly = {\n\t{\n\t\t.name\t\t\t= \"RAS\",\n\t\t.me\t\t\t= THIS_MODULE,\n\t\t.tuple.src.l3num\t= AF_INET,\n\t\t.tuple.src.u.udp.port\t= cpu_to_be16(RAS_PORT),\n\t\t.tuple.dst.protonum\t= IPPROTO_UDP,\n\t\t.help\t\t\t= ras_help,\n\t\t.expect_policy\t\t= &ras_exp_policy,\n\t},\n\t{\n\t\t.name\t\t\t= \"RAS\",\n\t\t.me\t\t\t= THIS_MODULE,\n\t\t.tuple.src.l3num\t= AF_INET6,\n\t\t.tuple.src.u.udp.port\t= cpu_to_be16(RAS_PORT),\n\t\t.tuple.dst.protonum\t= IPPROTO_UDP,\n\t\t.help\t\t\t= ras_help,\n\t\t.expect_policy\t\t= &ras_exp_policy,\n\t},\n};\n\nstatic int __init h323_helper_init(void)\n{\n\tint ret;\n\n\tret = nf_conntrack_helper_register(&nf_conntrack_helper_h245);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = nf_conntrack_helpers_register(nf_conntrack_helper_q931,\n\t\t\t\t\tARRAY_SIZE(nf_conntrack_helper_q931));\n\tif (ret < 0)\n\t\tgoto err1;\n\tret = nf_conntrack_helpers_register(nf_conntrack_helper_ras,\n\t\t\t\t\tARRAY_SIZE(nf_conntrack_helper_ras));\n\tif (ret < 0)\n\t\tgoto err2;\n\n\treturn 0;\nerr2:\n\tnf_conntrack_helpers_unregister(nf_conntrack_helper_q931,\n\t\t\t\t\tARRAY_SIZE(nf_conntrack_helper_q931));\nerr1:\n\tnf_conntrack_helper_unregister(&nf_conntrack_helper_h245);\n\treturn ret;\n}\n\nstatic void __exit h323_helper_exit(void)\n{\n\tnf_conntrack_helpers_unregister(nf_conntrack_helper_ras,\n\t\t\t\t\tARRAY_SIZE(nf_conntrack_helper_ras));\n\tnf_conntrack_helpers_unregister(nf_conntrack_helper_q931,\n\t\t\t\t\tARRAY_SIZE(nf_conntrack_helper_q931));\n\tnf_conntrack_helper_unregister(&nf_conntrack_helper_h245);\n}\n\nstatic void __exit nf_conntrack_h323_fini(void)\n{\n\th323_helper_exit();\n\tkfree(h323_buffer);\n\tpr_debug(\"nf_ct_h323: fini\\n\");\n}\n\nstatic int __init nf_conntrack_h323_init(void)\n{\n\tint ret;\n\n\tNF_CT_HELPER_BUILD_BUG_ON(sizeof(struct nf_ct_h323_master));\n\n\th323_buffer = kmalloc(H323_MAX_SIZE + 1, GFP_KERNEL);\n\tif (!h323_buffer)\n\t\treturn -ENOMEM;\n\tret = h323_helper_init();\n\tif (ret < 0)\n\t\tgoto err1;\n\tpr_debug(\"nf_ct_h323: init success\\n\");\n\treturn 0;\nerr1:\n\tkfree(h323_buffer);\n\treturn ret;\n}\n\nmodule_init(nf_conntrack_h323_init);\nmodule_exit(nf_conntrack_h323_fini);\n\nMODULE_AUTHOR(\"Jing Min Zhao <zhaojingmin@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"H.323 connection tracking helper\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ip_conntrack_h323\");\nMODULE_ALIAS_NFCT_HELPER(\"RAS\");\nMODULE_ALIAS_NFCT_HELPER(\"Q.931\");\nMODULE_ALIAS_NFCT_HELPER(\"H.245\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}