{
  "module_name": "nf_conntrack_netlink.c",
  "hash_id": "eea780c9f3a7077a6c97aaec6448daf58a8ae03229a1ae684aa8500cbe723691",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_netlink.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rculist_nulls.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/netlink.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/siphash.h>\n\n#include <linux/netfilter.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_tuple.h>\n#include <net/netfilter/nf_conntrack_acct.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/nf_conntrack_timestamp.h>\n#include <net/netfilter/nf_conntrack_labels.h>\n#include <net/netfilter/nf_conntrack_synproxy.h>\n#if IS_ENABLED(CONFIG_NF_NAT)\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_nat_helper.h>\n#endif\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_conntrack.h>\n\n#include \"nf_internals.h\"\n\nMODULE_LICENSE(\"GPL\");\n\nstruct ctnetlink_list_dump_ctx {\n\tstruct nf_conn *last;\n\tunsigned int cpu;\n\tbool done;\n};\n\nstatic int ctnetlink_dump_tuples_proto(struct sk_buff *skb,\n\t\t\t\tconst struct nf_conntrack_tuple *tuple,\n\t\t\t\tconst struct nf_conntrack_l4proto *l4proto)\n{\n\tint ret = 0;\n\tstruct nlattr *nest_parms;\n\n\tnest_parms = nla_nest_start(skb, CTA_TUPLE_PROTO);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, CTA_PROTO_NUM, tuple->dst.protonum))\n\t\tgoto nla_put_failure;\n\n\tif (likely(l4proto->tuple_to_nlattr))\n\t\tret = l4proto->tuple_to_nlattr(skb, tuple);\n\n\tnla_nest_end(skb, nest_parms);\n\n\treturn ret;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int ipv4_tuple_to_nlattr(struct sk_buff *skb,\n\t\t\t\tconst struct nf_conntrack_tuple *tuple)\n{\n\tif (nla_put_in_addr(skb, CTA_IP_V4_SRC, tuple->src.u3.ip) ||\n\t    nla_put_in_addr(skb, CTA_IP_V4_DST, tuple->dst.u3.ip))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int ipv6_tuple_to_nlattr(struct sk_buff *skb,\n\t\t\t\tconst struct nf_conntrack_tuple *tuple)\n{\n\tif (nla_put_in6_addr(skb, CTA_IP_V6_SRC, &tuple->src.u3.in6) ||\n\t    nla_put_in6_addr(skb, CTA_IP_V6_DST, &tuple->dst.u3.in6))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int ctnetlink_dump_tuples_ip(struct sk_buff *skb,\n\t\t\t\t    const struct nf_conntrack_tuple *tuple)\n{\n\tint ret = 0;\n\tstruct nlattr *nest_parms;\n\n\tnest_parms = nla_nest_start(skb, CTA_TUPLE_IP);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\n\tswitch (tuple->src.l3num) {\n\tcase NFPROTO_IPV4:\n\t\tret = ipv4_tuple_to_nlattr(skb, tuple);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tret = ipv6_tuple_to_nlattr(skb, tuple);\n\t\tbreak;\n\t}\n\n\tnla_nest_end(skb, nest_parms);\n\n\treturn ret;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int ctnetlink_dump_tuples(struct sk_buff *skb,\n\t\t\t\t const struct nf_conntrack_tuple *tuple)\n{\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tint ret;\n\n\trcu_read_lock();\n\tret = ctnetlink_dump_tuples_ip(skb, tuple);\n\n\tif (ret >= 0) {\n\t\tl4proto = nf_ct_l4proto_find(tuple->dst.protonum);\n\t\tret = ctnetlink_dump_tuples_proto(skb, tuple, l4proto);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int ctnetlink_dump_zone_id(struct sk_buff *skb, int attrtype,\n\t\t\t\t  const struct nf_conntrack_zone *zone, int dir)\n{\n\tif (zone->id == NF_CT_DEFAULT_ZONE_ID || zone->dir != dir)\n\t\treturn 0;\n\tif (nla_put_be16(skb, attrtype, htons(zone->id)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int ctnetlink_dump_status(struct sk_buff *skb, const struct nf_conn *ct)\n{\n\tif (nla_put_be32(skb, CTA_STATUS, htonl(ct->status)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int ctnetlink_dump_timeout(struct sk_buff *skb, const struct nf_conn *ct,\n\t\t\t\t  bool skip_zero)\n{\n\tlong timeout;\n\n\tif (nf_ct_is_confirmed(ct))\n\t\ttimeout = nf_ct_expires(ct) / HZ;\n\telse\n\t\ttimeout = ct->timeout / HZ;\n\n\tif (skip_zero && timeout == 0)\n\t\treturn 0;\n\n\tif (nla_put_be32(skb, CTA_TIMEOUT, htonl(timeout)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int ctnetlink_dump_protoinfo(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t\t    bool destroy)\n{\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tstruct nlattr *nest_proto;\n\tint ret;\n\n\tl4proto = nf_ct_l4proto_find(nf_ct_protonum(ct));\n\tif (!l4proto->to_nlattr)\n\t\treturn 0;\n\n\tnest_proto = nla_nest_start(skb, CTA_PROTOINFO);\n\tif (!nest_proto)\n\t\tgoto nla_put_failure;\n\n\tret = l4proto->to_nlattr(skb, nest_proto, ct, destroy);\n\n\tnla_nest_end(skb, nest_proto);\n\n\treturn ret;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int ctnetlink_dump_helpinfo(struct sk_buff *skb,\n\t\t\t\t   const struct nf_conn *ct)\n{\n\tstruct nlattr *nest_helper;\n\tconst struct nf_conn_help *help = nfct_help(ct);\n\tstruct nf_conntrack_helper *helper;\n\n\tif (!help)\n\t\treturn 0;\n\n\trcu_read_lock();\n\thelper = rcu_dereference(help->helper);\n\tif (!helper)\n\t\tgoto out;\n\n\tnest_helper = nla_nest_start(skb, CTA_HELP);\n\tif (!nest_helper)\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, CTA_HELP_NAME, helper->name))\n\t\tgoto nla_put_failure;\n\n\tif (helper->to_nlattr)\n\t\thelper->to_nlattr(skb, ct);\n\n\tnla_nest_end(skb, nest_helper);\nout:\n\trcu_read_unlock();\n\treturn 0;\n\nnla_put_failure:\n\trcu_read_unlock();\n\treturn -1;\n}\n\nstatic int\ndump_counters(struct sk_buff *skb, struct nf_conn_acct *acct,\n\t      enum ip_conntrack_dir dir, int type)\n{\n\tenum ctattr_type attr = dir ? CTA_COUNTERS_REPLY: CTA_COUNTERS_ORIG;\n\tstruct nf_conn_counter *counter = acct->counter;\n\tstruct nlattr *nest_count;\n\tu64 pkts, bytes;\n\n\tif (type == IPCTNL_MSG_CT_GET_CTRZERO) {\n\t\tpkts = atomic64_xchg(&counter[dir].packets, 0);\n\t\tbytes = atomic64_xchg(&counter[dir].bytes, 0);\n\t} else {\n\t\tpkts = atomic64_read(&counter[dir].packets);\n\t\tbytes = atomic64_read(&counter[dir].bytes);\n\t}\n\n\tnest_count = nla_nest_start(skb, attr);\n\tif (!nest_count)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be64(skb, CTA_COUNTERS_PACKETS, cpu_to_be64(pkts),\n\t\t\t CTA_COUNTERS_PAD) ||\n\t    nla_put_be64(skb, CTA_COUNTERS_BYTES, cpu_to_be64(bytes),\n\t\t\t CTA_COUNTERS_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest_count);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int\nctnetlink_dump_acct(struct sk_buff *skb, const struct nf_conn *ct, int type)\n{\n\tstruct nf_conn_acct *acct = nf_conn_acct_find(ct);\n\n\tif (!acct)\n\t\treturn 0;\n\n\tif (dump_counters(skb, acct, IP_CT_DIR_ORIGINAL, type) < 0)\n\t\treturn -1;\n\tif (dump_counters(skb, acct, IP_CT_DIR_REPLY, type) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int\nctnetlink_dump_timestamp(struct sk_buff *skb, const struct nf_conn *ct)\n{\n\tstruct nlattr *nest_count;\n\tconst struct nf_conn_tstamp *tstamp;\n\n\ttstamp = nf_conn_tstamp_find(ct);\n\tif (!tstamp)\n\t\treturn 0;\n\n\tnest_count = nla_nest_start(skb, CTA_TIMESTAMP);\n\tif (!nest_count)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be64(skb, CTA_TIMESTAMP_START, cpu_to_be64(tstamp->start),\n\t\t\t CTA_TIMESTAMP_PAD) ||\n\t    (tstamp->stop != 0 && nla_put_be64(skb, CTA_TIMESTAMP_STOP,\n\t\t\t\t\t       cpu_to_be64(tstamp->stop),\n\t\t\t\t\t       CTA_TIMESTAMP_PAD)))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_count);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\n#ifdef CONFIG_NF_CONNTRACK_MARK\nstatic int ctnetlink_dump_mark(struct sk_buff *skb, const struct nf_conn *ct,\n\t\t\t       bool dump)\n{\n\tu32 mark = READ_ONCE(ct->mark);\n\n\tif (!mark && !dump)\n\t\treturn 0;\n\n\tif (nla_put_be32(skb, CTA_MARK, htonl(mark)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n#else\n#define ctnetlink_dump_mark(a, b, c) (0)\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\nstatic int ctnetlink_dump_secctx(struct sk_buff *skb, const struct nf_conn *ct)\n{\n\tstruct nlattr *nest_secctx;\n\tint len, ret;\n\tchar *secctx;\n\n\tret = security_secid_to_secctx(ct->secmark, &secctx, &len);\n\tif (ret)\n\t\treturn 0;\n\n\tret = -1;\n\tnest_secctx = nla_nest_start(skb, CTA_SECCTX);\n\tif (!nest_secctx)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, CTA_SECCTX_NAME, secctx))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_secctx);\n\n\tret = 0;\nnla_put_failure:\n\tsecurity_release_secctx(secctx, len);\n\treturn ret;\n}\n#else\n#define ctnetlink_dump_secctx(a, b) (0)\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_LABELS\nstatic inline int ctnetlink_label_size(const struct nf_conn *ct)\n{\n\tstruct nf_conn_labels *labels = nf_ct_labels_find(ct);\n\n\tif (!labels)\n\t\treturn 0;\n\treturn nla_total_size(sizeof(labels->bits));\n}\n\nstatic int\nctnetlink_dump_labels(struct sk_buff *skb, const struct nf_conn *ct)\n{\n\tstruct nf_conn_labels *labels = nf_ct_labels_find(ct);\n\tunsigned int i;\n\n\tif (!labels)\n\t\treturn 0;\n\n\ti = 0;\n\tdo {\n\t\tif (labels->bits[i] != 0)\n\t\t\treturn nla_put(skb, CTA_LABELS, sizeof(labels->bits),\n\t\t\t\t       labels->bits);\n\t\ti++;\n\t} while (i < ARRAY_SIZE(labels->bits));\n\n\treturn 0;\n}\n#else\n#define ctnetlink_dump_labels(a, b) (0)\n#define ctnetlink_label_size(a)\t(0)\n#endif\n\n#define master_tuple(ct) &(ct->master->tuplehash[IP_CT_DIR_ORIGINAL].tuple)\n\nstatic int ctnetlink_dump_master(struct sk_buff *skb, const struct nf_conn *ct)\n{\n\tstruct nlattr *nest_parms;\n\n\tif (!(ct->status & IPS_EXPECTED))\n\t\treturn 0;\n\n\tnest_parms = nla_nest_start(skb, CTA_TUPLE_MASTER);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_tuples(skb, master_tuple(ct)) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_parms);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int\ndump_ct_seq_adj(struct sk_buff *skb, const struct nf_ct_seqadj *seq, int type)\n{\n\tstruct nlattr *nest_parms;\n\n\tnest_parms = nla_nest_start(skb, type);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, CTA_SEQADJ_CORRECTION_POS,\n\t\t\t htonl(seq->correction_pos)) ||\n\t    nla_put_be32(skb, CTA_SEQADJ_OFFSET_BEFORE,\n\t\t\t htonl(seq->offset_before)) ||\n\t    nla_put_be32(skb, CTA_SEQADJ_OFFSET_AFTER,\n\t\t\t htonl(seq->offset_after)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest_parms);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int ctnetlink_dump_ct_seq_adj(struct sk_buff *skb, struct nf_conn *ct)\n{\n\tstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\n\tstruct nf_ct_seqadj *seq;\n\n\tif (!(ct->status & IPS_SEQ_ADJUST) || !seqadj)\n\t\treturn 0;\n\n\tspin_lock_bh(&ct->lock);\n\tseq = &seqadj->seq[IP_CT_DIR_ORIGINAL];\n\tif (dump_ct_seq_adj(skb, seq, CTA_SEQ_ADJ_ORIG) == -1)\n\t\tgoto err;\n\n\tseq = &seqadj->seq[IP_CT_DIR_REPLY];\n\tif (dump_ct_seq_adj(skb, seq, CTA_SEQ_ADJ_REPLY) == -1)\n\t\tgoto err;\n\n\tspin_unlock_bh(&ct->lock);\n\treturn 0;\nerr:\n\tspin_unlock_bh(&ct->lock);\n\treturn -1;\n}\n\nstatic int ctnetlink_dump_ct_synproxy(struct sk_buff *skb, struct nf_conn *ct)\n{\n\tstruct nf_conn_synproxy *synproxy = nfct_synproxy(ct);\n\tstruct nlattr *nest_parms;\n\n\tif (!synproxy)\n\t\treturn 0;\n\n\tnest_parms = nla_nest_start(skb, CTA_SYNPROXY);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, CTA_SYNPROXY_ISN, htonl(synproxy->isn)) ||\n\t    nla_put_be32(skb, CTA_SYNPROXY_ITS, htonl(synproxy->its)) ||\n\t    nla_put_be32(skb, CTA_SYNPROXY_TSOFF, htonl(synproxy->tsoff)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest_parms);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int ctnetlink_dump_id(struct sk_buff *skb, const struct nf_conn *ct)\n{\n\t__be32 id = (__force __be32)nf_ct_get_id(ct);\n\n\tif (nla_put_be32(skb, CTA_ID, id))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int ctnetlink_dump_use(struct sk_buff *skb, const struct nf_conn *ct)\n{\n\tif (nla_put_be32(skb, CTA_USE, htonl(refcount_read(&ct->ct_general.use))))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\n \nstatic int ctnetlink_dump_extinfo(struct sk_buff *skb,\n\t\t\t\t  struct nf_conn *ct, u32 type)\n{\n\tif (ctnetlink_dump_acct(skb, ct, type) < 0 ||\n\t    ctnetlink_dump_timestamp(skb, ct) < 0 ||\n\t    ctnetlink_dump_helpinfo(skb, ct) < 0 ||\n\t    ctnetlink_dump_labels(skb, ct) < 0 ||\n\t    ctnetlink_dump_ct_seq_adj(skb, ct) < 0 ||\n\t    ctnetlink_dump_ct_synproxy(skb, ct) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int ctnetlink_dump_info(struct sk_buff *skb, struct nf_conn *ct)\n{\n\tif (ctnetlink_dump_status(skb, ct) < 0 ||\n\t    ctnetlink_dump_mark(skb, ct, true) < 0 ||\n\t    ctnetlink_dump_secctx(skb, ct) < 0 ||\n\t    ctnetlink_dump_id(skb, ct) < 0 ||\n\t    ctnetlink_dump_use(skb, ct) < 0 ||\n\t    ctnetlink_dump_master(skb, ct) < 0)\n\t\treturn -1;\n\n\tif (!test_bit(IPS_OFFLOAD_BIT, &ct->status) &&\n\t    (ctnetlink_dump_timeout(skb, ct, false) < 0 ||\n\t     ctnetlink_dump_protoinfo(skb, ct, false) < 0))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int\nctnetlink_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\n\t\t    struct nf_conn *ct, bool extinfo, unsigned int flags)\n{\n\tconst struct nf_conntrack_zone *zone;\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *nest_parms;\n\tunsigned int event;\n\n\tif (portid)\n\t\tflags |= NLM_F_MULTI;\n\tevent = nfnl_msg_type(NFNL_SUBSYS_CTNETLINK, IPCTNL_MSG_CT_NEW);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, nf_ct_l3num(ct),\n\t\t\t   NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tzone = nf_ct_zone(ct);\n\n\tnest_parms = nla_nest_start(skb, CTA_TUPLE_ORIG);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_ORIGINAL)) < 0)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_zone_id(skb, CTA_TUPLE_ZONE, zone,\n\t\t\t\t   NF_CT_ZONE_DIR_ORIG) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_parms);\n\n\tnest_parms = nla_nest_start(skb, CTA_TUPLE_REPLY);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_REPLY)) < 0)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_zone_id(skb, CTA_TUPLE_ZONE, zone,\n\t\t\t\t   NF_CT_ZONE_DIR_REPL) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_parms);\n\n\tif (ctnetlink_dump_zone_id(skb, CTA_ZONE, zone,\n\t\t\t\t   NF_CT_DEFAULT_ZONE_DIR) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ctnetlink_dump_info(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\tif (extinfo && ctnetlink_dump_extinfo(skb, ct, type) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -1;\n}\n\nstatic const struct nla_policy cta_ip_nla_policy[CTA_IP_MAX + 1] = {\n\t[CTA_IP_V4_SRC]\t= { .type = NLA_U32 },\n\t[CTA_IP_V4_DST]\t= { .type = NLA_U32 },\n\t[CTA_IP_V6_SRC]\t= { .len = sizeof(__be32) * 4 },\n\t[CTA_IP_V6_DST]\t= { .len = sizeof(__be32) * 4 },\n};\n\n#if defined(CONFIG_NETFILTER_NETLINK_GLUE_CT) || defined(CONFIG_NF_CONNTRACK_EVENTS)\nstatic size_t ctnetlink_proto_size(const struct nf_conn *ct)\n{\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tsize_t len, len4 = 0;\n\n\tlen = nla_policy_len(cta_ip_nla_policy, CTA_IP_MAX + 1);\n\tlen *= 3u;  \n\n\tl4proto = nf_ct_l4proto_find(nf_ct_protonum(ct));\n\tlen += l4proto->nlattr_size;\n\tif (l4proto->nlattr_tuple_size) {\n\t\tlen4 = l4proto->nlattr_tuple_size();\n\t\tlen4 *= 3u;  \n\t}\n\n\treturn len + len4;\n}\n#endif\n\nstatic inline size_t ctnetlink_acct_size(const struct nf_conn *ct)\n{\n\tif (!nf_ct_ext_exist(ct, NF_CT_EXT_ACCT))\n\t\treturn 0;\n\treturn 2 * nla_total_size(0)  \n\t       + 2 * nla_total_size_64bit(sizeof(uint64_t))  \n\t       + 2 * nla_total_size_64bit(sizeof(uint64_t))  \n\t       ;\n}\n\nstatic inline int ctnetlink_secctx_size(const struct nf_conn *ct)\n{\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\n\tint len, ret;\n\n\tret = security_secid_to_secctx(ct->secmark, NULL, &len);\n\tif (ret)\n\t\treturn 0;\n\n\treturn nla_total_size(0)  \n\t       + nla_total_size(sizeof(char) * len);  \n#else\n\treturn 0;\n#endif\n}\n\nstatic inline size_t ctnetlink_timestamp_size(const struct nf_conn *ct)\n{\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\n\tif (!nf_ct_ext_exist(ct, NF_CT_EXT_TSTAMP))\n\t\treturn 0;\n\treturn nla_total_size(0) + 2 * nla_total_size_64bit(sizeof(uint64_t));\n#else\n\treturn 0;\n#endif\n}\n\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\nstatic size_t ctnetlink_nlmsg_size(const struct nf_conn *ct)\n{\n\treturn NLMSG_ALIGN(sizeof(struct nfgenmsg))\n\t       + 3 * nla_total_size(0)  \n\t       + 3 * nla_total_size(0)  \n\t       + 3 * nla_total_size(0)  \n\t       + 3 * nla_total_size(sizeof(u_int8_t))  \n\t       + nla_total_size(sizeof(u_int32_t))  \n\t       + nla_total_size(sizeof(u_int32_t))  \n\t       + ctnetlink_acct_size(ct)\n\t       + ctnetlink_timestamp_size(ct)\n\t       + nla_total_size(sizeof(u_int32_t))  \n\t       + nla_total_size(0)  \n\t       + nla_total_size(0)  \n\t       + nla_total_size(NF_CT_HELPER_NAME_LEN)  \n\t       + ctnetlink_secctx_size(ct)\n#if IS_ENABLED(CONFIG_NF_NAT)\n\t       + 2 * nla_total_size(0)  \n\t       + 6 * nla_total_size(sizeof(u_int32_t))  \n#endif\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\t       + nla_total_size(sizeof(u_int32_t))  \n#endif\n#ifdef CONFIG_NF_CONNTRACK_ZONES\n\t       + nla_total_size(sizeof(u_int16_t))  \n#endif\n\t       + ctnetlink_proto_size(ct)\n\t       + ctnetlink_label_size(ct)\n\t       ;\n}\n\nstatic int\nctnetlink_conntrack_event(unsigned int events, const struct nf_ct_event *item)\n{\n\tconst struct nf_conntrack_zone *zone;\n\tstruct net *net;\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *nest_parms;\n\tstruct nf_conn *ct = item->ct;\n\tstruct sk_buff *skb;\n\tunsigned int type;\n\tunsigned int flags = 0, group;\n\tint err;\n\n\tif (events & (1 << IPCT_DESTROY)) {\n\t\ttype = IPCTNL_MSG_CT_DELETE;\n\t\tgroup = NFNLGRP_CONNTRACK_DESTROY;\n\t} else if (events & ((1 << IPCT_NEW) | (1 << IPCT_RELATED))) {\n\t\ttype = IPCTNL_MSG_CT_NEW;\n\t\tflags = NLM_F_CREATE|NLM_F_EXCL;\n\t\tgroup = NFNLGRP_CONNTRACK_NEW;\n\t} else if (events) {\n\t\ttype = IPCTNL_MSG_CT_NEW;\n\t\tgroup = NFNLGRP_CONNTRACK_UPDATE;\n\t} else\n\t\treturn 0;\n\n\tnet = nf_ct_net(ct);\n\tif (!item->report && !nfnetlink_has_listeners(net, group))\n\t\treturn 0;\n\n\tskb = nlmsg_new(ctnetlink_nlmsg_size(ct), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\ttype = nfnl_msg_type(NFNL_SUBSYS_CTNETLINK, type);\n\tnlh = nfnl_msg_put(skb, item->portid, 0, type, flags, nf_ct_l3num(ct),\n\t\t\t   NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tzone = nf_ct_zone(ct);\n\n\tnest_parms = nla_nest_start(skb, CTA_TUPLE_ORIG);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_ORIGINAL)) < 0)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_zone_id(skb, CTA_TUPLE_ZONE, zone,\n\t\t\t\t   NF_CT_ZONE_DIR_ORIG) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_parms);\n\n\tnest_parms = nla_nest_start(skb, CTA_TUPLE_REPLY);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_REPLY)) < 0)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_zone_id(skb, CTA_TUPLE_ZONE, zone,\n\t\t\t\t   NF_CT_ZONE_DIR_REPL) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_parms);\n\n\tif (ctnetlink_dump_zone_id(skb, CTA_ZONE, zone,\n\t\t\t\t   NF_CT_DEFAULT_ZONE_DIR) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ctnetlink_dump_id(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ctnetlink_dump_status(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (events & (1 << IPCT_DESTROY)) {\n\t\tif (ctnetlink_dump_timeout(skb, ct, true) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (ctnetlink_dump_acct(skb, ct, type) < 0 ||\n\t\t    ctnetlink_dump_timestamp(skb, ct) < 0 ||\n\t\t    ctnetlink_dump_protoinfo(skb, ct, true) < 0)\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tif (ctnetlink_dump_timeout(skb, ct, false) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (events & (1 << IPCT_PROTOINFO) &&\n\t\t    ctnetlink_dump_protoinfo(skb, ct, false) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((events & (1 << IPCT_HELPER) || nfct_help(ct))\n\t\t    && ctnetlink_dump_helpinfo(skb, ct) < 0)\n\t\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\n\t\tif ((events & (1 << IPCT_SECMARK) || ct->secmark)\n\t\t    && ctnetlink_dump_secctx(skb, ct) < 0)\n\t\t\tgoto nla_put_failure;\n#endif\n\t\tif (events & (1 << IPCT_LABEL) &&\n\t\t     ctnetlink_dump_labels(skb, ct) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (events & (1 << IPCT_RELATED) &&\n\t\t    ctnetlink_dump_master(skb, ct) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (events & (1 << IPCT_SEQADJ) &&\n\t\t    ctnetlink_dump_ct_seq_adj(skb, ct) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (events & (1 << IPCT_SYNPROXY) &&\n\t\t    ctnetlink_dump_ct_synproxy(skb, ct) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\tif (ctnetlink_dump_mark(skb, ct, events & (1 << IPCT_MARK)))\n\t\tgoto nla_put_failure;\n#endif\n\tnlmsg_end(skb, nlh);\n\terr = nfnetlink_send(skb, net, item->portid, group, item->report,\n\t\t\t     GFP_ATOMIC);\n\tif (err == -ENOBUFS || err == -EAGAIN)\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\nnlmsg_failure:\n\tkfree_skb(skb);\nerrout:\n\tif (nfnetlink_set_err(net, 0, group, -ENOBUFS) > 0)\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n#endif  \n\nstatic int ctnetlink_done(struct netlink_callback *cb)\n{\n\tif (cb->args[1])\n\t\tnf_ct_put((struct nf_conn *)cb->args[1]);\n\tkfree(cb->data);\n\treturn 0;\n}\n\nstruct ctnetlink_filter_u32 {\n\tu32 val;\n\tu32 mask;\n};\n\nstruct ctnetlink_filter {\n\tu8 family;\n\n\tu_int32_t orig_flags;\n\tu_int32_t reply_flags;\n\n\tstruct nf_conntrack_tuple orig;\n\tstruct nf_conntrack_tuple reply;\n\tstruct nf_conntrack_zone zone;\n\n\tstruct ctnetlink_filter_u32 mark;\n\tstruct ctnetlink_filter_u32 status;\n};\n\nstatic const struct nla_policy cta_filter_nla_policy[CTA_FILTER_MAX + 1] = {\n\t[CTA_FILTER_ORIG_FLAGS]\t\t= { .type = NLA_U32 },\n\t[CTA_FILTER_REPLY_FLAGS]\t= { .type = NLA_U32 },\n};\n\nstatic int ctnetlink_parse_filter(const struct nlattr *attr,\n\t\t\t\t  struct ctnetlink_filter *filter)\n{\n\tstruct nlattr *tb[CTA_FILTER_MAX + 1];\n\tint ret = 0;\n\n\tret = nla_parse_nested(tb, CTA_FILTER_MAX, attr, cta_filter_nla_policy,\n\t\t\t       NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[CTA_FILTER_ORIG_FLAGS]) {\n\t\tfilter->orig_flags = nla_get_u32(tb[CTA_FILTER_ORIG_FLAGS]);\n\t\tif (filter->orig_flags & ~CTA_FILTER_F_ALL)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[CTA_FILTER_REPLY_FLAGS]) {\n\t\tfilter->reply_flags = nla_get_u32(tb[CTA_FILTER_REPLY_FLAGS]);\n\t\tif (filter->reply_flags & ~CTA_FILTER_F_ALL)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ctnetlink_parse_zone(const struct nlattr *attr,\n\t\t\t\tstruct nf_conntrack_zone *zone);\nstatic int ctnetlink_parse_tuple_filter(const struct nlattr * const cda[],\n\t\t\t\t\t struct nf_conntrack_tuple *tuple,\n\t\t\t\t\t u32 type, u_int8_t l3num,\n\t\t\t\t\t struct nf_conntrack_zone *zone,\n\t\t\t\t\t u_int32_t flags);\n\nstatic int ctnetlink_filter_parse_mark(struct ctnetlink_filter_u32 *mark,\n\t\t\t\t       const struct nlattr * const cda[])\n{\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\tif (cda[CTA_MARK]) {\n\t\tmark->val = ntohl(nla_get_be32(cda[CTA_MARK]));\n\n\t\tif (cda[CTA_MARK_MASK])\n\t\t\tmark->mask = ntohl(nla_get_be32(cda[CTA_MARK_MASK]));\n\t\telse\n\t\t\tmark->mask = 0xffffffff;\n\t} else if (cda[CTA_MARK_MASK]) {\n\t\treturn -EINVAL;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int ctnetlink_filter_parse_status(struct ctnetlink_filter_u32 *status,\n\t\t\t\t\t const struct nlattr * const cda[])\n{\n\tif (cda[CTA_STATUS]) {\n\t\tstatus->val = ntohl(nla_get_be32(cda[CTA_STATUS]));\n\t\tif (cda[CTA_STATUS_MASK])\n\t\t\tstatus->mask = ntohl(nla_get_be32(cda[CTA_STATUS_MASK]));\n\t\telse\n\t\t\tstatus->mask = status->val;\n\n\t\t \n\t\tif (status->mask == 0)\n\t\t\treturn -EINVAL;\n\t} else if (cda[CTA_STATUS_MASK]) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tBUILD_BUG_ON(__IPS_MAX_BIT >= 32);\n\treturn 0;\n}\n\nstatic struct ctnetlink_filter *\nctnetlink_alloc_filter(const struct nlattr * const cda[], u8 family)\n{\n\tstruct ctnetlink_filter *filter;\n\tint err;\n\n#ifndef CONFIG_NF_CONNTRACK_MARK\n\tif (cda[CTA_MARK] || cda[CTA_MARK_MASK])\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n#endif\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfilter->family = family;\n\n\terr = ctnetlink_filter_parse_mark(&filter->mark, cda);\n\tif (err)\n\t\tgoto err_filter;\n\n\terr = ctnetlink_filter_parse_status(&filter->status, cda);\n\tif (err)\n\t\tgoto err_filter;\n\n\tif (!cda[CTA_FILTER])\n\t\treturn filter;\n\n\terr = ctnetlink_parse_zone(cda[CTA_ZONE], &filter->zone);\n\tif (err < 0)\n\t\tgoto err_filter;\n\n\terr = ctnetlink_parse_filter(cda[CTA_FILTER], filter);\n\tif (err < 0)\n\t\tgoto err_filter;\n\n\tif (filter->orig_flags) {\n\t\tif (!cda[CTA_TUPLE_ORIG]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_filter;\n\t\t}\n\n\t\terr = ctnetlink_parse_tuple_filter(cda, &filter->orig,\n\t\t\t\t\t\t   CTA_TUPLE_ORIG,\n\t\t\t\t\t\t   filter->family,\n\t\t\t\t\t\t   &filter->zone,\n\t\t\t\t\t\t   filter->orig_flags);\n\t\tif (err < 0)\n\t\t\tgoto err_filter;\n\t}\n\n\tif (filter->reply_flags) {\n\t\tif (!cda[CTA_TUPLE_REPLY]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_filter;\n\t\t}\n\n\t\terr = ctnetlink_parse_tuple_filter(cda, &filter->reply,\n\t\t\t\t\t\t   CTA_TUPLE_REPLY,\n\t\t\t\t\t\t   filter->family,\n\t\t\t\t\t\t   &filter->zone,\n\t\t\t\t\t\t   filter->reply_flags);\n\t\tif (err < 0)\n\t\t\tgoto err_filter;\n\t}\n\n\treturn filter;\n\nerr_filter:\n\tkfree(filter);\n\n\treturn ERR_PTR(err);\n}\n\nstatic bool ctnetlink_needs_filter(u8 family, const struct nlattr * const *cda)\n{\n\treturn family || cda[CTA_MARK] || cda[CTA_FILTER] || cda[CTA_STATUS];\n}\n\nstatic int ctnetlink_start(struct netlink_callback *cb)\n{\n\tconst struct nlattr * const *cda = cb->data;\n\tstruct ctnetlink_filter *filter = NULL;\n\tstruct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tu8 family = nfmsg->nfgen_family;\n\n\tif (ctnetlink_needs_filter(family, cda)) {\n\t\tfilter = ctnetlink_alloc_filter(cda, family);\n\t\tif (IS_ERR(filter))\n\t\t\treturn PTR_ERR(filter);\n\t}\n\n\tcb->data = filter;\n\treturn 0;\n}\n\nstatic int ctnetlink_filter_match_tuple(struct nf_conntrack_tuple *filter_tuple,\n\t\t\t\t\tstruct nf_conntrack_tuple *ct_tuple,\n\t\t\t\t\tu_int32_t flags, int family)\n{\n\tswitch (family) {\n\tcase NFPROTO_IPV4:\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_IP_SRC)) &&\n\t\t    filter_tuple->src.u3.ip != ct_tuple->src.u3.ip)\n\t\t\treturn  0;\n\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_IP_DST)) &&\n\t\t    filter_tuple->dst.u3.ip != ct_tuple->dst.u3.ip)\n\t\t\treturn  0;\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_IP_SRC)) &&\n\t\t    !ipv6_addr_cmp(&filter_tuple->src.u3.in6,\n\t\t\t\t   &ct_tuple->src.u3.in6))\n\t\t\treturn 0;\n\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_IP_DST)) &&\n\t\t    !ipv6_addr_cmp(&filter_tuple->dst.u3.in6,\n\t\t\t\t   &ct_tuple->dst.u3.in6))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\tif ((flags & CTA_FILTER_FLAG(CTA_PROTO_NUM)) &&\n\t    filter_tuple->dst.protonum != ct_tuple->dst.protonum)\n\t\treturn 0;\n\n\tswitch (ct_tuple->dst.protonum) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_PROTO_SRC_PORT)) &&\n\t\t    filter_tuple->src.u.tcp.port != ct_tuple->src.u.tcp.port)\n\t\t\treturn 0;\n\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_PROTO_DST_PORT)) &&\n\t\t    filter_tuple->dst.u.tcp.port != ct_tuple->dst.u.tcp.port)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase IPPROTO_ICMP:\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_PROTO_ICMP_TYPE)) &&\n\t\t    filter_tuple->dst.u.icmp.type != ct_tuple->dst.u.icmp.type)\n\t\t\treturn 0;\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_PROTO_ICMP_CODE)) &&\n\t\t    filter_tuple->dst.u.icmp.code != ct_tuple->dst.u.icmp.code)\n\t\t\treturn 0;\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_PROTO_ICMP_ID)) &&\n\t\t    filter_tuple->src.u.icmp.id != ct_tuple->src.u.icmp.id)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase IPPROTO_ICMPV6:\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_PROTO_ICMPV6_TYPE)) &&\n\t\t    filter_tuple->dst.u.icmp.type != ct_tuple->dst.u.icmp.type)\n\t\t\treturn 0;\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_PROTO_ICMPV6_CODE)) &&\n\t\t    filter_tuple->dst.u.icmp.code != ct_tuple->dst.u.icmp.code)\n\t\t\treturn 0;\n\t\tif ((flags & CTA_FILTER_FLAG(CTA_PROTO_ICMPV6_ID)) &&\n\t\t    filter_tuple->src.u.icmp.id != ct_tuple->src.u.icmp.id)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nstatic int ctnetlink_filter_match(struct nf_conn *ct, void *data)\n{\n\tstruct ctnetlink_filter *filter = data;\n\tstruct nf_conntrack_tuple *tuple;\n\tu32 status;\n\n\tif (filter == NULL)\n\t\tgoto out;\n\n\t \n\tif (filter->family && nf_ct_l3num(ct) != filter->family)\n\t\tgoto ignore_entry;\n\n\tif (filter->orig_flags) {\n\t\ttuple = nf_ct_tuple(ct, IP_CT_DIR_ORIGINAL);\n\t\tif (!ctnetlink_filter_match_tuple(&filter->orig, tuple,\n\t\t\t\t\t\t  filter->orig_flags,\n\t\t\t\t\t\t  filter->family))\n\t\t\tgoto ignore_entry;\n\t}\n\n\tif (filter->reply_flags) {\n\t\ttuple = nf_ct_tuple(ct, IP_CT_DIR_REPLY);\n\t\tif (!ctnetlink_filter_match_tuple(&filter->reply, tuple,\n\t\t\t\t\t\t  filter->reply_flags,\n\t\t\t\t\t\t  filter->family))\n\t\t\tgoto ignore_entry;\n\t}\n\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\tif ((READ_ONCE(ct->mark) & filter->mark.mask) != filter->mark.val)\n\t\tgoto ignore_entry;\n#endif\n\tstatus = (u32)READ_ONCE(ct->status);\n\tif ((status & filter->status.mask) != filter->status.val)\n\t\tgoto ignore_entry;\n\nout:\n\treturn 1;\n\nignore_entry:\n\treturn 0;\n}\n\nstatic int\nctnetlink_dump_table(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tunsigned int flags = cb->data ? NLM_F_DUMP_FILTERED : 0;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nf_conn *ct, *last;\n\tstruct nf_conntrack_tuple_hash *h;\n\tstruct hlist_nulls_node *n;\n\tstruct nf_conn *nf_ct_evict[8];\n\tint res, i;\n\tspinlock_t *lockp;\n\n\tlast = (struct nf_conn *)cb->args[1];\n\ti = 0;\n\n\tlocal_bh_disable();\n\tfor (; cb->args[0] < nf_conntrack_htable_size; cb->args[0]++) {\nrestart:\n\t\twhile (i) {\n\t\t\ti--;\n\t\t\tif (nf_ct_should_gc(nf_ct_evict[i]))\n\t\t\t\tnf_ct_kill(nf_ct_evict[i]);\n\t\t\tnf_ct_put(nf_ct_evict[i]);\n\t\t}\n\n\t\tlockp = &nf_conntrack_locks[cb->args[0] % CONNTRACK_LOCKS];\n\t\tnf_conntrack_lock(lockp);\n\t\tif (cb->args[0] >= nf_conntrack_htable_size) {\n\t\t\tspin_unlock(lockp);\n\t\t\tgoto out;\n\t\t}\n\t\thlist_nulls_for_each_entry(h, n, &nf_conntrack_hash[cb->args[0]],\n\t\t\t\t\t   hnnode) {\n\t\t\tct = nf_ct_tuplehash_to_ctrack(h);\n\t\t\tif (nf_ct_is_expired(ct)) {\n\t\t\t\t \n\t\t\t\tif (i < ARRAY_SIZE(nf_ct_evict) &&\n\t\t\t\t    refcount_inc_not_zero(&ct->ct_general.use))\n\t\t\t\t\tnf_ct_evict[i++] = ct;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!net_eq(net, nf_ct_net(ct)))\n\t\t\t\tcontinue;\n\n\t\t\tif (NF_CT_DIRECTION(h) != IP_CT_DIR_ORIGINAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (cb->args[1]) {\n\t\t\t\tif (ct != last)\n\t\t\t\t\tcontinue;\n\t\t\t\tcb->args[1] = 0;\n\t\t\t}\n\t\t\tif (!ctnetlink_filter_match(ct, cb->data))\n\t\t\t\tcontinue;\n\n\t\t\tres =\n\t\t\tctnetlink_fill_info(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t    NFNL_MSG_TYPE(cb->nlh->nlmsg_type),\n\t\t\t\t\t    ct, true, flags);\n\t\t\tif (res < 0) {\n\t\t\t\tnf_conntrack_get(&ct->ct_general);\n\t\t\t\tcb->args[1] = (unsigned long)ct;\n\t\t\t\tspin_unlock(lockp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(lockp);\n\t\tif (cb->args[1]) {\n\t\t\tcb->args[1] = 0;\n\t\t\tgoto restart;\n\t\t}\n\t}\nout:\n\tlocal_bh_enable();\n\tif (last) {\n\t\t \n\t\tif ((struct nf_conn *)cb->args[1] == last)\n\t\t\tcb->args[1] = 0;\n\n\t\tnf_ct_put(last);\n\t}\n\n\twhile (i) {\n\t\ti--;\n\t\tif (nf_ct_should_gc(nf_ct_evict[i]))\n\t\t\tnf_ct_kill(nf_ct_evict[i]);\n\t\tnf_ct_put(nf_ct_evict[i]);\n\t}\n\n\treturn skb->len;\n}\n\nstatic int ipv4_nlattr_to_tuple(struct nlattr *tb[],\n\t\t\t\tstruct nf_conntrack_tuple *t,\n\t\t\t\tu_int32_t flags)\n{\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_SRC)) {\n\t\tif (!tb[CTA_IP_V4_SRC])\n\t\t\treturn -EINVAL;\n\n\t\tt->src.u3.ip = nla_get_in_addr(tb[CTA_IP_V4_SRC]);\n\t}\n\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_DST)) {\n\t\tif (!tb[CTA_IP_V4_DST])\n\t\t\treturn -EINVAL;\n\n\t\tt->dst.u3.ip = nla_get_in_addr(tb[CTA_IP_V4_DST]);\n\t}\n\n\treturn 0;\n}\n\nstatic int ipv6_nlattr_to_tuple(struct nlattr *tb[],\n\t\t\t\tstruct nf_conntrack_tuple *t,\n\t\t\t\tu_int32_t flags)\n{\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_SRC)) {\n\t\tif (!tb[CTA_IP_V6_SRC])\n\t\t\treturn -EINVAL;\n\n\t\tt->src.u3.in6 = nla_get_in6_addr(tb[CTA_IP_V6_SRC]);\n\t}\n\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_DST)) {\n\t\tif (!tb[CTA_IP_V6_DST])\n\t\t\treturn -EINVAL;\n\n\t\tt->dst.u3.in6 = nla_get_in6_addr(tb[CTA_IP_V6_DST]);\n\t}\n\n\treturn 0;\n}\n\nstatic int ctnetlink_parse_tuple_ip(struct nlattr *attr,\n\t\t\t\t    struct nf_conntrack_tuple *tuple,\n\t\t\t\t    u_int32_t flags)\n{\n\tstruct nlattr *tb[CTA_IP_MAX+1];\n\tint ret = 0;\n\n\tret = nla_parse_nested_deprecated(tb, CTA_IP_MAX, attr,\n\t\t\t\t\t  cta_ip_nla_policy, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (tuple->src.l3num) {\n\tcase NFPROTO_IPV4:\n\t\tret = ipv4_nlattr_to_tuple(tb, tuple, flags);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tret = ipv6_nlattr_to_tuple(tb, tuple, flags);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nla_policy proto_nla_policy[CTA_PROTO_MAX+1] = {\n\t[CTA_PROTO_NUM]\t= { .type = NLA_U8 },\n};\n\nstatic int ctnetlink_parse_tuple_proto(struct nlattr *attr,\n\t\t\t\t       struct nf_conntrack_tuple *tuple,\n\t\t\t\t       u_int32_t flags)\n{\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tstruct nlattr *tb[CTA_PROTO_MAX+1];\n\tint ret = 0;\n\n\tret = nla_parse_nested_deprecated(tb, CTA_PROTO_MAX, attr,\n\t\t\t\t\t  proto_nla_policy, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(flags & CTA_FILTER_FLAG(CTA_PROTO_NUM)))\n\t\treturn 0;\n\n\tif (!tb[CTA_PROTO_NUM])\n\t\treturn -EINVAL;\n\n\ttuple->dst.protonum = nla_get_u8(tb[CTA_PROTO_NUM]);\n\n\trcu_read_lock();\n\tl4proto = nf_ct_l4proto_find(tuple->dst.protonum);\n\n\tif (likely(l4proto->nlattr_to_tuple)) {\n\t\tret = nla_validate_nested_deprecated(attr, CTA_PROTO_MAX,\n\t\t\t\t\t\t     l4proto->nla_policy,\n\t\t\t\t\t\t     NULL);\n\t\tif (ret == 0)\n\t\t\tret = l4proto->nlattr_to_tuple(tb, tuple, flags);\n\t}\n\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic int\nctnetlink_parse_zone(const struct nlattr *attr,\n\t\t     struct nf_conntrack_zone *zone)\n{\n\tnf_ct_zone_init(zone, NF_CT_DEFAULT_ZONE_ID,\n\t\t\tNF_CT_DEFAULT_ZONE_DIR, 0);\n#ifdef CONFIG_NF_CONNTRACK_ZONES\n\tif (attr)\n\t\tzone->id = ntohs(nla_get_be16(attr));\n#else\n\tif (attr)\n\t\treturn -EOPNOTSUPP;\n#endif\n\treturn 0;\n}\n\nstatic int\nctnetlink_parse_tuple_zone(struct nlattr *attr, enum ctattr_type type,\n\t\t\t   struct nf_conntrack_zone *zone)\n{\n\tint ret;\n\n\tif (zone->id != NF_CT_DEFAULT_ZONE_ID)\n\t\treturn -EINVAL;\n\n\tret = ctnetlink_parse_zone(attr, zone);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (type == CTA_TUPLE_REPLY)\n\t\tzone->dir = NF_CT_ZONE_DIR_REPL;\n\telse\n\t\tzone->dir = NF_CT_ZONE_DIR_ORIG;\n\n\treturn 0;\n}\n\nstatic const struct nla_policy tuple_nla_policy[CTA_TUPLE_MAX+1] = {\n\t[CTA_TUPLE_IP]\t\t= { .type = NLA_NESTED },\n\t[CTA_TUPLE_PROTO]\t= { .type = NLA_NESTED },\n\t[CTA_TUPLE_ZONE]\t= { .type = NLA_U16 },\n};\n\n#define CTA_FILTER_F_ALL_CTA_PROTO \\\n  (CTA_FILTER_F_CTA_PROTO_SRC_PORT | \\\n   CTA_FILTER_F_CTA_PROTO_DST_PORT | \\\n   CTA_FILTER_F_CTA_PROTO_ICMP_TYPE | \\\n   CTA_FILTER_F_CTA_PROTO_ICMP_CODE | \\\n   CTA_FILTER_F_CTA_PROTO_ICMP_ID | \\\n   CTA_FILTER_F_CTA_PROTO_ICMPV6_TYPE | \\\n   CTA_FILTER_F_CTA_PROTO_ICMPV6_CODE | \\\n   CTA_FILTER_F_CTA_PROTO_ICMPV6_ID)\n\nstatic int\nctnetlink_parse_tuple_filter(const struct nlattr * const cda[],\n\t\t\t      struct nf_conntrack_tuple *tuple, u32 type,\n\t\t\t      u_int8_t l3num, struct nf_conntrack_zone *zone,\n\t\t\t      u_int32_t flags)\n{\n\tstruct nlattr *tb[CTA_TUPLE_MAX+1];\n\tint err;\n\n\tmemset(tuple, 0, sizeof(*tuple));\n\n\terr = nla_parse_nested_deprecated(tb, CTA_TUPLE_MAX, cda[type],\n\t\t\t\t\t  tuple_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (l3num != NFPROTO_IPV4 && l3num != NFPROTO_IPV6)\n\t\treturn -EOPNOTSUPP;\n\ttuple->src.l3num = l3num;\n\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||\n\t    flags & CTA_FILTER_FLAG(CTA_IP_SRC)) {\n\t\tif (!tb[CTA_TUPLE_IP])\n\t\t\treturn -EINVAL;\n\n\t\terr = ctnetlink_parse_tuple_ip(tb[CTA_TUPLE_IP], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (flags & CTA_FILTER_FLAG(CTA_PROTO_NUM)) {\n\t\tif (!tb[CTA_TUPLE_PROTO])\n\t\t\treturn -EINVAL;\n\n\t\terr = ctnetlink_parse_tuple_proto(tb[CTA_TUPLE_PROTO], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (flags & CTA_FILTER_FLAG(ALL_CTA_PROTO)) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif ((flags & CTA_FILTER_FLAG(CTA_TUPLE_ZONE)) && tb[CTA_TUPLE_ZONE]) {\n\t\tif (!zone)\n\t\t\treturn -EINVAL;\n\n\t\terr = ctnetlink_parse_tuple_zone(tb[CTA_TUPLE_ZONE],\n\t\t\t\t\t\t type, zone);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (type == CTA_TUPLE_REPLY)\n\t\ttuple->dst.dir = IP_CT_DIR_REPLY;\n\telse\n\t\ttuple->dst.dir = IP_CT_DIR_ORIGINAL;\n\n\treturn 0;\n}\n\nstatic int\nctnetlink_parse_tuple(const struct nlattr * const cda[],\n\t\t      struct nf_conntrack_tuple *tuple, u32 type,\n\t\t      u_int8_t l3num, struct nf_conntrack_zone *zone)\n{\n\treturn ctnetlink_parse_tuple_filter(cda, tuple, type, l3num, zone,\n\t\t\t\t\t    CTA_FILTER_FLAG(ALL));\n}\n\nstatic const struct nla_policy help_nla_policy[CTA_HELP_MAX+1] = {\n\t[CTA_HELP_NAME]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = NF_CT_HELPER_NAME_LEN - 1 },\n};\n\nstatic int ctnetlink_parse_help(const struct nlattr *attr, char **helper_name,\n\t\t\t\tstruct nlattr **helpinfo)\n{\n\tint err;\n\tstruct nlattr *tb[CTA_HELP_MAX+1];\n\n\terr = nla_parse_nested_deprecated(tb, CTA_HELP_MAX, attr,\n\t\t\t\t\t  help_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[CTA_HELP_NAME])\n\t\treturn -EINVAL;\n\n\t*helper_name = nla_data(tb[CTA_HELP_NAME]);\n\n\tif (tb[CTA_HELP_INFO])\n\t\t*helpinfo = tb[CTA_HELP_INFO];\n\n\treturn 0;\n}\n\nstatic const struct nla_policy ct_nla_policy[CTA_MAX+1] = {\n\t[CTA_TUPLE_ORIG]\t= { .type = NLA_NESTED },\n\t[CTA_TUPLE_REPLY]\t= { .type = NLA_NESTED },\n\t[CTA_STATUS] \t\t= { .type = NLA_U32 },\n\t[CTA_PROTOINFO]\t\t= { .type = NLA_NESTED },\n\t[CTA_HELP]\t\t= { .type = NLA_NESTED },\n\t[CTA_NAT_SRC]\t\t= { .type = NLA_NESTED },\n\t[CTA_TIMEOUT] \t\t= { .type = NLA_U32 },\n\t[CTA_MARK]\t\t= { .type = NLA_U32 },\n\t[CTA_ID]\t\t= { .type = NLA_U32 },\n\t[CTA_NAT_DST]\t\t= { .type = NLA_NESTED },\n\t[CTA_TUPLE_MASTER]\t= { .type = NLA_NESTED },\n\t[CTA_NAT_SEQ_ADJ_ORIG]  = { .type = NLA_NESTED },\n\t[CTA_NAT_SEQ_ADJ_REPLY] = { .type = NLA_NESTED },\n\t[CTA_ZONE]\t\t= { .type = NLA_U16 },\n\t[CTA_MARK_MASK]\t\t= { .type = NLA_U32 },\n\t[CTA_LABELS]\t\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = NF_CT_LABELS_MAX_SIZE },\n\t[CTA_LABELS_MASK]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = NF_CT_LABELS_MAX_SIZE },\n\t[CTA_FILTER]\t\t= { .type = NLA_NESTED },\n\t[CTA_STATUS_MASK]\t= { .type = NLA_U32 },\n};\n\nstatic int ctnetlink_flush_iterate(struct nf_conn *ct, void *data)\n{\n\treturn ctnetlink_filter_match(ct, data);\n}\n\nstatic int ctnetlink_flush_conntrack(struct net *net,\n\t\t\t\t     const struct nlattr * const cda[],\n\t\t\t\t     u32 portid, int report, u8 family)\n{\n\tstruct ctnetlink_filter *filter = NULL;\n\tstruct nf_ct_iter_data iter = {\n\t\t.net\t\t= net,\n\t\t.portid\t\t= portid,\n\t\t.report\t\t= report,\n\t};\n\n\tif (ctnetlink_needs_filter(family, cda)) {\n\t\tif (cda[CTA_FILTER])\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tfilter = ctnetlink_alloc_filter(cda, family);\n\t\tif (IS_ERR(filter))\n\t\t\treturn PTR_ERR(filter);\n\n\t\titer.data = filter;\n\t}\n\n\tnf_ct_iterate_cleanup_net(ctnetlink_flush_iterate, &iter);\n\tkfree(filter);\n\n\treturn 0;\n}\n\nstatic int ctnetlink_del_conntrack(struct sk_buff *skb,\n\t\t\t\t   const struct nfnl_info *info,\n\t\t\t\t   const struct nlattr * const cda[])\n{\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nf_conntrack_tuple_hash *h;\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nf_conntrack_zone zone;\n\tstruct nf_conn *ct;\n\tint err;\n\n\terr = ctnetlink_parse_zone(cda[CTA_ZONE], &zone);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cda[CTA_TUPLE_ORIG])\n\t\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_TUPLE_ORIG,\n\t\t\t\t\t    family, &zone);\n\telse if (cda[CTA_TUPLE_REPLY])\n\t\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_TUPLE_REPLY,\n\t\t\t\t\t    family, &zone);\n\telse {\n\t\tu_int8_t u3 = info->nfmsg->version ? family : AF_UNSPEC;\n\n\t\treturn ctnetlink_flush_conntrack(info->net, cda,\n\t\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t\t nlmsg_report(info->nlh), u3);\n\t}\n\n\tif (err < 0)\n\t\treturn err;\n\n\th = nf_conntrack_find_get(info->net, &zone, &tuple);\n\tif (!h)\n\t\treturn -ENOENT;\n\n\tct = nf_ct_tuplehash_to_ctrack(h);\n\n\tif (cda[CTA_ID]) {\n\t\t__be32 id = nla_get_be32(cda[CTA_ID]);\n\n\t\tif (id != (__force __be32)nf_ct_get_id(ct)) {\n\t\t\tnf_ct_put(ct);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tnf_ct_delete(ct, NETLINK_CB(skb).portid, nlmsg_report(info->nlh));\n\tnf_ct_put(ct);\n\n\treturn 0;\n}\n\nstatic int ctnetlink_get_conntrack(struct sk_buff *skb,\n\t\t\t\t   const struct nfnl_info *info,\n\t\t\t\t   const struct nlattr * const cda[])\n{\n\tu_int8_t u3 = info->nfmsg->nfgen_family;\n\tstruct nf_conntrack_tuple_hash *h;\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nf_conntrack_zone zone;\n\tstruct sk_buff *skb2;\n\tstruct nf_conn *ct;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = ctnetlink_start,\n\t\t\t.dump = ctnetlink_dump_table,\n\t\t\t.done = ctnetlink_done,\n\t\t\t.data = (void *)cda,\n\t\t};\n\n\t\treturn netlink_dump_start(info->sk, skb, info->nlh, &c);\n\t}\n\n\terr = ctnetlink_parse_zone(cda[CTA_ZONE], &zone);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cda[CTA_TUPLE_ORIG])\n\t\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_TUPLE_ORIG,\n\t\t\t\t\t    u3, &zone);\n\telse if (cda[CTA_TUPLE_REPLY])\n\t\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_TUPLE_REPLY,\n\t\t\t\t\t    u3, &zone);\n\telse\n\t\treturn -EINVAL;\n\n\tif (err < 0)\n\t\treturn err;\n\n\th = nf_conntrack_find_get(info->net, &zone, &tuple);\n\tif (!h)\n\t\treturn -ENOENT;\n\n\tct = nf_ct_tuplehash_to_ctrack(h);\n\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb2) {\n\t\tnf_ct_put(ct);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = ctnetlink_fill_info(skb2, NETLINK_CB(skb).portid,\n\t\t\t\t  info->nlh->nlmsg_seq,\n\t\t\t\t  NFNL_MSG_TYPE(info->nlh->nlmsg_type), ct,\n\t\t\t\t  true, 0);\n\tnf_ct_put(ct);\n\tif (err <= 0) {\n\t\tkfree_skb(skb2);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n}\n\nstatic int ctnetlink_done_list(struct netlink_callback *cb)\n{\n\tstruct ctnetlink_list_dump_ctx *ctx = (void *)cb->ctx;\n\n\tif (ctx->last)\n\t\tnf_ct_put(ctx->last);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\nstatic int ctnetlink_dump_one_entry(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb,\n\t\t\t\t    struct nf_conn *ct,\n\t\t\t\t    bool dying)\n{\n\tstruct ctnetlink_list_dump_ctx *ctx = (void *)cb->ctx;\n\tstruct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tu8 l3proto = nfmsg->nfgen_family;\n\tint res;\n\n\tif (l3proto && nf_ct_l3num(ct) != l3proto)\n\t\treturn 0;\n\n\tif (ctx->last) {\n\t\tif (ct != ctx->last)\n\t\t\treturn 0;\n\n\t\tctx->last = NULL;\n\t}\n\n\t \n\tres = ctnetlink_fill_info(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t  cb->nlh->nlmsg_seq,\n\t\t\t\t  NFNL_MSG_TYPE(cb->nlh->nlmsg_type),\n\t\t\t\t  ct, dying, 0);\n\tif (res < 0) {\n\t\tif (!refcount_inc_not_zero(&ct->ct_general.use))\n\t\t\treturn 0;\n\n\t\tctx->last = ct;\n\t}\n\n\treturn res;\n}\n#endif\n\nstatic int\nctnetlink_dump_unconfirmed(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\treturn 0;\n}\n\nstatic int\nctnetlink_dump_dying(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct ctnetlink_list_dump_ctx *ctx = (void *)cb->ctx;\n\tstruct nf_conn *last = ctx->last;\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tconst struct net *net = sock_net(skb->sk);\n\tstruct nf_conntrack_net_ecache *ecache_net;\n\tstruct nf_conntrack_tuple_hash *h;\n\tstruct hlist_nulls_node *n;\n#endif\n\n\tif (ctx->done)\n\t\treturn 0;\n\n\tctx->last = NULL;\n\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tecache_net = nf_conn_pernet_ecache(net);\n\tspin_lock_bh(&ecache_net->dying_lock);\n\n\thlist_nulls_for_each_entry(h, n, &ecache_net->dying_list, hnnode) {\n\t\tstruct nf_conn *ct;\n\t\tint res;\n\n\t\tct = nf_ct_tuplehash_to_ctrack(h);\n\t\tif (last && last != ct)\n\t\t\tcontinue;\n\n\t\tres = ctnetlink_dump_one_entry(skb, cb, ct, true);\n\t\tif (res < 0) {\n\t\t\tspin_unlock_bh(&ecache_net->dying_lock);\n\t\t\tnf_ct_put(last);\n\t\t\treturn skb->len;\n\t\t}\n\n\t\tnf_ct_put(last);\n\t\tlast = NULL;\n\t}\n\n\tspin_unlock_bh(&ecache_net->dying_lock);\n#endif\n\tctx->done = true;\n\tnf_ct_put(last);\n\n\treturn skb->len;\n}\n\nstatic int ctnetlink_get_ct_dying(struct sk_buff *skb,\n\t\t\t\t  const struct nfnl_info *info,\n\t\t\t\t  const struct nlattr * const cda[])\n{\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = ctnetlink_dump_dying,\n\t\t\t.done = ctnetlink_done_list,\n\t\t};\n\t\treturn netlink_dump_start(info->sk, skb, info->nlh, &c);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ctnetlink_get_ct_unconfirmed(struct sk_buff *skb,\n\t\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\t\tconst struct nlattr * const cda[])\n{\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = ctnetlink_dump_unconfirmed,\n\t\t\t.done = ctnetlink_done_list,\n\t\t};\n\t\treturn netlink_dump_start(info->sk, skb, info->nlh, &c);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n#if IS_ENABLED(CONFIG_NF_NAT)\nstatic int\nctnetlink_parse_nat_setup(struct nf_conn *ct,\n\t\t\t  enum nf_nat_manip_type manip,\n\t\t\t  const struct nlattr *attr)\n\t__must_hold(RCU)\n{\n\tconst struct nf_nat_hook *nat_hook;\n\tint err;\n\n\tnat_hook = rcu_dereference(nf_nat_hook);\n\tif (!nat_hook) {\n#ifdef CONFIG_MODULES\n\t\trcu_read_unlock();\n\t\tnfnl_unlock(NFNL_SUBSYS_CTNETLINK);\n\t\tif (request_module(\"nf-nat\") < 0) {\n\t\t\tnfnl_lock(NFNL_SUBSYS_CTNETLINK);\n\t\t\trcu_read_lock();\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tnfnl_lock(NFNL_SUBSYS_CTNETLINK);\n\t\trcu_read_lock();\n\t\tnat_hook = rcu_dereference(nf_nat_hook);\n\t\tif (nat_hook)\n\t\t\treturn -EAGAIN;\n#endif\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = nat_hook->parse_nat_setup(ct, manip, attr);\n\tif (err == -EAGAIN) {\n#ifdef CONFIG_MODULES\n\t\trcu_read_unlock();\n\t\tnfnl_unlock(NFNL_SUBSYS_CTNETLINK);\n\t\tif (request_module(\"nf-nat-%u\", nf_ct_l3num(ct)) < 0) {\n\t\t\tnfnl_lock(NFNL_SUBSYS_CTNETLINK);\n\t\t\trcu_read_lock();\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tnfnl_lock(NFNL_SUBSYS_CTNETLINK);\n\t\trcu_read_lock();\n#else\n\t\terr = -EOPNOTSUPP;\n#endif\n\t}\n\treturn err;\n}\n#endif\n\nstatic int\nctnetlink_change_status(struct nf_conn *ct, const struct nlattr * const cda[])\n{\n\treturn nf_ct_change_status_common(ct, ntohl(nla_get_be32(cda[CTA_STATUS])));\n}\n\nstatic int\nctnetlink_setup_nat(struct nf_conn *ct, const struct nlattr * const cda[])\n{\n#if IS_ENABLED(CONFIG_NF_NAT)\n\tint ret;\n\n\tif (!cda[CTA_NAT_DST] && !cda[CTA_NAT_SRC])\n\t\treturn 0;\n\n\tret = ctnetlink_parse_nat_setup(ct, NF_NAT_MANIP_DST,\n\t\t\t\t\tcda[CTA_NAT_DST]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ctnetlink_parse_nat_setup(ct, NF_NAT_MANIP_SRC,\n\t\t\t\t\t cda[CTA_NAT_SRC]);\n#else\n\tif (!cda[CTA_NAT_DST] && !cda[CTA_NAT_SRC])\n\t\treturn 0;\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int ctnetlink_change_helper(struct nf_conn *ct,\n\t\t\t\t   const struct nlattr * const cda[])\n{\n\tstruct nf_conntrack_helper *helper;\n\tstruct nf_conn_help *help = nfct_help(ct);\n\tchar *helpname = NULL;\n\tstruct nlattr *helpinfo = NULL;\n\tint err;\n\n\terr = ctnetlink_parse_help(cda[CTA_HELP], &helpname, &helpinfo);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (ct->master) {\n\t\t \n\t\terr = -EBUSY;\n\t\tif (help) {\n\t\t\trcu_read_lock();\n\t\t\thelper = rcu_dereference(help->helper);\n\t\t\tif (helper && !strcmp(helper->name, helpname))\n\t\t\t\terr = 0;\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\treturn err;\n\t}\n\n\tif (!strcmp(helpname, \"\")) {\n\t\tif (help && help->helper) {\n\t\t\t \n\t\t\tnf_ct_remove_expectations(ct);\n\t\t\tRCU_INIT_POINTER(help->helper, NULL);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\trcu_read_lock();\n\thelper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),\n\t\t\t\t\t    nf_ct_protonum(ct));\n\tif (helper == NULL) {\n\t\trcu_read_unlock();\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (help) {\n\t\tif (rcu_access_pointer(help->helper) == helper) {\n\t\t\t \n\t\t\tif (helper->from_nlattr)\n\t\t\t\thelper->from_nlattr(helpinfo, ct);\n\t\t\terr = 0;\n\t\t} else\n\t\t\terr = -EBUSY;\n\t} else {\n\t\t \n\t\terr = -EOPNOTSUPP;\n\t}\n\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int ctnetlink_change_timeout(struct nf_conn *ct,\n\t\t\t\t    const struct nlattr * const cda[])\n{\n\treturn __nf_ct_change_timeout(ct, (u64)ntohl(nla_get_be32(cda[CTA_TIMEOUT])) * HZ);\n}\n\n#if defined(CONFIG_NF_CONNTRACK_MARK)\nstatic void ctnetlink_change_mark(struct nf_conn *ct,\n\t\t\t\t    const struct nlattr * const cda[])\n{\n\tu32 mark, newmark, mask = 0;\n\n\tif (cda[CTA_MARK_MASK])\n\t\tmask = ~ntohl(nla_get_be32(cda[CTA_MARK_MASK]));\n\n\tmark = ntohl(nla_get_be32(cda[CTA_MARK]));\n\tnewmark = (READ_ONCE(ct->mark) & mask) ^ mark;\n\tif (newmark != READ_ONCE(ct->mark))\n\t\tWRITE_ONCE(ct->mark, newmark);\n}\n#endif\n\nstatic const struct nla_policy protoinfo_policy[CTA_PROTOINFO_MAX+1] = {\n\t[CTA_PROTOINFO_TCP]\t= { .type = NLA_NESTED },\n\t[CTA_PROTOINFO_DCCP]\t= { .type = NLA_NESTED },\n\t[CTA_PROTOINFO_SCTP]\t= { .type = NLA_NESTED },\n};\n\nstatic int ctnetlink_change_protoinfo(struct nf_conn *ct,\n\t\t\t\t      const struct nlattr * const cda[])\n{\n\tconst struct nlattr *attr = cda[CTA_PROTOINFO];\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tstruct nlattr *tb[CTA_PROTOINFO_MAX+1];\n\tint err = 0;\n\n\terr = nla_parse_nested_deprecated(tb, CTA_PROTOINFO_MAX, attr,\n\t\t\t\t\t  protoinfo_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tl4proto = nf_ct_l4proto_find(nf_ct_protonum(ct));\n\tif (l4proto->from_nlattr)\n\t\terr = l4proto->from_nlattr(tb, ct);\n\n\treturn err;\n}\n\nstatic const struct nla_policy seqadj_policy[CTA_SEQADJ_MAX+1] = {\n\t[CTA_SEQADJ_CORRECTION_POS]\t= { .type = NLA_U32 },\n\t[CTA_SEQADJ_OFFSET_BEFORE]\t= { .type = NLA_U32 },\n\t[CTA_SEQADJ_OFFSET_AFTER]\t= { .type = NLA_U32 },\n};\n\nstatic int change_seq_adj(struct nf_ct_seqadj *seq,\n\t\t\t  const struct nlattr * const attr)\n{\n\tint err;\n\tstruct nlattr *cda[CTA_SEQADJ_MAX+1];\n\n\terr = nla_parse_nested_deprecated(cda, CTA_SEQADJ_MAX, attr,\n\t\t\t\t\t  seqadj_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!cda[CTA_SEQADJ_CORRECTION_POS])\n\t\treturn -EINVAL;\n\n\tseq->correction_pos =\n\t\tntohl(nla_get_be32(cda[CTA_SEQADJ_CORRECTION_POS]));\n\n\tif (!cda[CTA_SEQADJ_OFFSET_BEFORE])\n\t\treturn -EINVAL;\n\n\tseq->offset_before =\n\t\tntohl(nla_get_be32(cda[CTA_SEQADJ_OFFSET_BEFORE]));\n\n\tif (!cda[CTA_SEQADJ_OFFSET_AFTER])\n\t\treturn -EINVAL;\n\n\tseq->offset_after =\n\t\tntohl(nla_get_be32(cda[CTA_SEQADJ_OFFSET_AFTER]));\n\n\treturn 0;\n}\n\nstatic int\nctnetlink_change_seq_adj(struct nf_conn *ct,\n\t\t\t const struct nlattr * const cda[])\n{\n\tstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\n\tint ret = 0;\n\n\tif (!seqadj)\n\t\treturn 0;\n\n\tspin_lock_bh(&ct->lock);\n\tif (cda[CTA_SEQ_ADJ_ORIG]) {\n\t\tret = change_seq_adj(&seqadj->seq[IP_CT_DIR_ORIGINAL],\n\t\t\t\t     cda[CTA_SEQ_ADJ_ORIG]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tset_bit(IPS_SEQ_ADJUST_BIT, &ct->status);\n\t}\n\n\tif (cda[CTA_SEQ_ADJ_REPLY]) {\n\t\tret = change_seq_adj(&seqadj->seq[IP_CT_DIR_REPLY],\n\t\t\t\t     cda[CTA_SEQ_ADJ_REPLY]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tset_bit(IPS_SEQ_ADJUST_BIT, &ct->status);\n\t}\n\n\tspin_unlock_bh(&ct->lock);\n\treturn 0;\nerr:\n\tspin_unlock_bh(&ct->lock);\n\treturn ret;\n}\n\nstatic const struct nla_policy synproxy_policy[CTA_SYNPROXY_MAX + 1] = {\n\t[CTA_SYNPROXY_ISN]\t= { .type = NLA_U32 },\n\t[CTA_SYNPROXY_ITS]\t= { .type = NLA_U32 },\n\t[CTA_SYNPROXY_TSOFF]\t= { .type = NLA_U32 },\n};\n\nstatic int ctnetlink_change_synproxy(struct nf_conn *ct,\n\t\t\t\t     const struct nlattr * const cda[])\n{\n\tstruct nf_conn_synproxy *synproxy = nfct_synproxy(ct);\n\tstruct nlattr *tb[CTA_SYNPROXY_MAX + 1];\n\tint err;\n\n\tif (!synproxy)\n\t\treturn 0;\n\n\terr = nla_parse_nested_deprecated(tb, CTA_SYNPROXY_MAX,\n\t\t\t\t\t  cda[CTA_SYNPROXY], synproxy_policy,\n\t\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[CTA_SYNPROXY_ISN] ||\n\t    !tb[CTA_SYNPROXY_ITS] ||\n\t    !tb[CTA_SYNPROXY_TSOFF])\n\t\treturn -EINVAL;\n\n\tsynproxy->isn = ntohl(nla_get_be32(tb[CTA_SYNPROXY_ISN]));\n\tsynproxy->its = ntohl(nla_get_be32(tb[CTA_SYNPROXY_ITS]));\n\tsynproxy->tsoff = ntohl(nla_get_be32(tb[CTA_SYNPROXY_TSOFF]));\n\n\treturn 0;\n}\n\nstatic int\nctnetlink_attach_labels(struct nf_conn *ct, const struct nlattr * const cda[])\n{\n#ifdef CONFIG_NF_CONNTRACK_LABELS\n\tsize_t len = nla_len(cda[CTA_LABELS]);\n\tconst void *mask = cda[CTA_LABELS_MASK];\n\n\tif (len & (sizeof(u32)-1))  \n\t\treturn -EINVAL;\n\n\tif (mask) {\n\t\tif (nla_len(cda[CTA_LABELS_MASK]) == 0 ||\n\t\t    nla_len(cda[CTA_LABELS_MASK]) != len)\n\t\t\treturn -EINVAL;\n\t\tmask = nla_data(cda[CTA_LABELS_MASK]);\n\t}\n\n\tlen /= sizeof(u32);\n\n\treturn nf_connlabels_replace(ct, nla_data(cda[CTA_LABELS]), mask, len);\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int\nctnetlink_change_conntrack(struct nf_conn *ct,\n\t\t\t   const struct nlattr * const cda[])\n{\n\tint err;\n\n\t \n\tif (cda[CTA_NAT_SRC] || cda[CTA_NAT_DST] || cda[CTA_TUPLE_MASTER])\n\t\treturn -EOPNOTSUPP;\n\n\tif (cda[CTA_HELP]) {\n\t\terr = ctnetlink_change_helper(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (cda[CTA_TIMEOUT]) {\n\t\terr = ctnetlink_change_timeout(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (cda[CTA_STATUS]) {\n\t\terr = ctnetlink_change_status(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (cda[CTA_PROTOINFO]) {\n\t\terr = ctnetlink_change_protoinfo(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n#if defined(CONFIG_NF_CONNTRACK_MARK)\n\tif (cda[CTA_MARK])\n\t\tctnetlink_change_mark(ct, cda);\n#endif\n\n\tif (cda[CTA_SEQ_ADJ_ORIG] || cda[CTA_SEQ_ADJ_REPLY]) {\n\t\terr = ctnetlink_change_seq_adj(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (cda[CTA_SYNPROXY]) {\n\t\terr = ctnetlink_change_synproxy(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (cda[CTA_LABELS]) {\n\t\terr = ctnetlink_attach_labels(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nf_conn *\nctnetlink_create_conntrack(struct net *net,\n\t\t\t   const struct nf_conntrack_zone *zone,\n\t\t\t   const struct nlattr * const cda[],\n\t\t\t   struct nf_conntrack_tuple *otuple,\n\t\t\t   struct nf_conntrack_tuple *rtuple,\n\t\t\t   u8 u3)\n{\n\tstruct nf_conn *ct;\n\tint err = -EINVAL;\n\tstruct nf_conntrack_helper *helper;\n\tstruct nf_conn_tstamp *tstamp;\n\tu64 timeout;\n\n\tct = nf_conntrack_alloc(net, zone, otuple, rtuple, GFP_ATOMIC);\n\tif (IS_ERR(ct))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!cda[CTA_TIMEOUT])\n\t\tgoto err1;\n\n\trcu_read_lock();\n \tif (cda[CTA_HELP]) {\n\t\tchar *helpname = NULL;\n\t\tstruct nlattr *helpinfo = NULL;\n\n\t\terr = ctnetlink_parse_help(cda[CTA_HELP], &helpname, &helpinfo);\n \t\tif (err < 0)\n\t\t\tgoto err2;\n\n\t\thelper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),\n\t\t\t\t\t\t    nf_ct_protonum(ct));\n\t\tif (helper == NULL) {\n\t\t\trcu_read_unlock();\n#ifdef CONFIG_MODULES\n\t\t\tif (request_module(\"nfct-helper-%s\", helpname) < 0) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto err1;\n\t\t\t}\n\n\t\t\trcu_read_lock();\n\t\t\thelper = __nf_conntrack_helper_find(helpname,\n\t\t\t\t\t\t\t    nf_ct_l3num(ct),\n\t\t\t\t\t\t\t    nf_ct_protonum(ct));\n\t\t\tif (helper) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto err2;\n\t\t\t}\n\t\t\trcu_read_unlock();\n#endif\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err1;\n\t\t} else {\n\t\t\tstruct nf_conn_help *help;\n\n\t\t\thelp = nf_ct_helper_ext_add(ct, GFP_ATOMIC);\n\t\t\tif (help == NULL) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err2;\n\t\t\t}\n\t\t\t \n\t\t\tif (helper->from_nlattr)\n\t\t\t\thelper->from_nlattr(helpinfo, ct);\n\n\t\t\t \n\t\t\tct->status |= IPS_HELPER;\n\t\t\tRCU_INIT_POINTER(help->helper, helper);\n\t\t}\n\t}\n\n\terr = ctnetlink_setup_nat(ct, cda);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tnf_ct_acct_ext_add(ct, GFP_ATOMIC);\n\tnf_ct_tstamp_ext_add(ct, GFP_ATOMIC);\n\tnf_ct_ecache_ext_add(ct, 0, 0, GFP_ATOMIC);\n\tnf_ct_labels_ext_add(ct);\n\tnfct_seqadj_ext_add(ct);\n\tnfct_synproxy_ext_add(ct);\n\n\t \n\tct->status |= IPS_CONFIRMED;\n\n\ttimeout = (u64)ntohl(nla_get_be32(cda[CTA_TIMEOUT])) * HZ;\n\t__nf_ct_set_timeout(ct, timeout);\n\n\tif (cda[CTA_STATUS]) {\n\t\terr = ctnetlink_change_status(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n\tif (cda[CTA_SEQ_ADJ_ORIG] || cda[CTA_SEQ_ADJ_REPLY]) {\n\t\terr = ctnetlink_change_seq_adj(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n\tmemset(&ct->proto, 0, sizeof(ct->proto));\n\tif (cda[CTA_PROTOINFO]) {\n\t\terr = ctnetlink_change_protoinfo(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n\tif (cda[CTA_SYNPROXY]) {\n\t\terr = ctnetlink_change_synproxy(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n#if defined(CONFIG_NF_CONNTRACK_MARK)\n\tif (cda[CTA_MARK])\n\t\tctnetlink_change_mark(ct, cda);\n#endif\n\n\t \n\tif (cda[CTA_TUPLE_MASTER]) {\n\t\tstruct nf_conntrack_tuple master;\n\t\tstruct nf_conntrack_tuple_hash *master_h;\n\t\tstruct nf_conn *master_ct;\n\n\t\terr = ctnetlink_parse_tuple(cda, &master, CTA_TUPLE_MASTER,\n\t\t\t\t\t    u3, NULL);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\n\t\tmaster_h = nf_conntrack_find_get(net, zone, &master);\n\t\tif (master_h == NULL) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err2;\n\t\t}\n\t\tmaster_ct = nf_ct_tuplehash_to_ctrack(master_h);\n\t\t__set_bit(IPS_EXPECTED_BIT, &ct->status);\n\t\tct->master = master_ct;\n\t}\n\ttstamp = nf_conn_tstamp_find(ct);\n\tif (tstamp)\n\t\ttstamp->start = ktime_get_real_ns();\n\n\terr = nf_conntrack_hash_check_insert(ct);\n\tif (err < 0)\n\t\tgoto err3;\n\n\trcu_read_unlock();\n\n\treturn ct;\n\nerr3:\n\tif (ct->master)\n\t\tnf_ct_put(ct->master);\nerr2:\n\trcu_read_unlock();\nerr1:\n\tnf_conntrack_free(ct);\n\treturn ERR_PTR(err);\n}\n\nstatic int ctnetlink_new_conntrack(struct sk_buff *skb,\n\t\t\t\t   const struct nfnl_info *info,\n\t\t\t\t   const struct nlattr * const cda[])\n{\n\tstruct nf_conntrack_tuple otuple, rtuple;\n\tstruct nf_conntrack_tuple_hash *h = NULL;\n\tu_int8_t u3 = info->nfmsg->nfgen_family;\n\tstruct nf_conntrack_zone zone;\n\tstruct nf_conn *ct;\n\tint err;\n\n\terr = ctnetlink_parse_zone(cda[CTA_ZONE], &zone);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cda[CTA_TUPLE_ORIG]) {\n\t\terr = ctnetlink_parse_tuple(cda, &otuple, CTA_TUPLE_ORIG,\n\t\t\t\t\t    u3, &zone);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (cda[CTA_TUPLE_REPLY]) {\n\t\terr = ctnetlink_parse_tuple(cda, &rtuple, CTA_TUPLE_REPLY,\n\t\t\t\t\t    u3, &zone);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (cda[CTA_TUPLE_ORIG])\n\t\th = nf_conntrack_find_get(info->net, &zone, &otuple);\n\telse if (cda[CTA_TUPLE_REPLY])\n\t\th = nf_conntrack_find_get(info->net, &zone, &rtuple);\n\n\tif (h == NULL) {\n\t\terr = -ENOENT;\n\t\tif (info->nlh->nlmsg_flags & NLM_F_CREATE) {\n\t\t\tenum ip_conntrack_events events;\n\n\t\t\tif (!cda[CTA_TUPLE_ORIG] || !cda[CTA_TUPLE_REPLY])\n\t\t\t\treturn -EINVAL;\n\t\t\tif (otuple.dst.protonum != rtuple.dst.protonum)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tct = ctnetlink_create_conntrack(info->net, &zone, cda,\n\t\t\t\t\t\t\t&otuple, &rtuple, u3);\n\t\t\tif (IS_ERR(ct))\n\t\t\t\treturn PTR_ERR(ct);\n\n\t\t\terr = 0;\n\t\t\tif (test_bit(IPS_EXPECTED_BIT, &ct->status))\n\t\t\t\tevents = 1 << IPCT_RELATED;\n\t\t\telse\n\t\t\t\tevents = 1 << IPCT_NEW;\n\n\t\t\tif (cda[CTA_LABELS] &&\n\t\t\t    ctnetlink_attach_labels(ct, cda) == 0)\n\t\t\t\tevents |= (1 << IPCT_LABEL);\n\n\t\t\tnf_conntrack_eventmask_report((1 << IPCT_REPLY) |\n\t\t\t\t\t\t      (1 << IPCT_ASSURED) |\n\t\t\t\t\t\t      (1 << IPCT_HELPER) |\n\t\t\t\t\t\t      (1 << IPCT_PROTOINFO) |\n\t\t\t\t\t\t      (1 << IPCT_SEQADJ) |\n\t\t\t\t\t\t      (1 << IPCT_MARK) |\n\t\t\t\t\t\t      (1 << IPCT_SYNPROXY) |\n\t\t\t\t\t\t      events,\n\t\t\t\t\t\t      ct, NETLINK_CB(skb).portid,\n\t\t\t\t\t\t      nlmsg_report(info->nlh));\n\t\t\tnf_ct_put(ct);\n\t\t}\n\n\t\treturn err;\n\t}\n\t \n\n\terr = -EEXIST;\n\tct = nf_ct_tuplehash_to_ctrack(h);\n\tif (!(info->nlh->nlmsg_flags & NLM_F_EXCL)) {\n\t\terr = ctnetlink_change_conntrack(ct, cda);\n\t\tif (err == 0) {\n\t\t\tnf_conntrack_eventmask_report((1 << IPCT_REPLY) |\n\t\t\t\t\t\t      (1 << IPCT_ASSURED) |\n\t\t\t\t\t\t      (1 << IPCT_HELPER) |\n\t\t\t\t\t\t      (1 << IPCT_LABEL) |\n\t\t\t\t\t\t      (1 << IPCT_PROTOINFO) |\n\t\t\t\t\t\t      (1 << IPCT_SEQADJ) |\n\t\t\t\t\t\t      (1 << IPCT_MARK) |\n\t\t\t\t\t\t      (1 << IPCT_SYNPROXY),\n\t\t\t\t\t\t      ct, NETLINK_CB(skb).portid,\n\t\t\t\t\t\t      nlmsg_report(info->nlh));\n\t\t}\n\t}\n\n\tnf_ct_put(ct);\n\treturn err;\n}\n\nstatic int\nctnetlink_ct_stat_cpu_fill_info(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\t__u16 cpu, const struct ip_conntrack_stat *st)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned int flags = portid ? NLM_F_MULTI : 0, event;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_CTNETLINK,\n\t\t\t      IPCTNL_MSG_CT_GET_STATS_CPU);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, AF_UNSPEC,\n\t\t\t   NFNETLINK_V0, htons(cpu));\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tif (nla_put_be32(skb, CTA_STATS_FOUND, htonl(st->found)) ||\n\t    nla_put_be32(skb, CTA_STATS_INVALID, htonl(st->invalid)) ||\n\t    nla_put_be32(skb, CTA_STATS_INSERT, htonl(st->insert)) ||\n\t    nla_put_be32(skb, CTA_STATS_INSERT_FAILED,\n\t\t\t\thtonl(st->insert_failed)) ||\n\t    nla_put_be32(skb, CTA_STATS_DROP, htonl(st->drop)) ||\n\t    nla_put_be32(skb, CTA_STATS_EARLY_DROP, htonl(st->early_drop)) ||\n\t    nla_put_be32(skb, CTA_STATS_ERROR, htonl(st->error)) ||\n\t    nla_put_be32(skb, CTA_STATS_SEARCH_RESTART,\n\t\t\t\thtonl(st->search_restart)) ||\n\t    nla_put_be32(skb, CTA_STATS_CLASH_RESOLVE,\n\t\t\t\thtonl(st->clash_resolve)) ||\n\t    nla_put_be32(skb, CTA_STATS_CHAIN_TOOLONG,\n\t\t\t htonl(st->chaintoolong)))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn skb->len;\n\nnla_put_failure:\nnlmsg_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -1;\n}\n\nstatic int\nctnetlink_ct_stat_cpu_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint cpu;\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (cb->args[0] == nr_cpu_ids)\n\t\treturn 0;\n\n\tfor (cpu = cb->args[0]; cpu < nr_cpu_ids; cpu++) {\n\t\tconst struct ip_conntrack_stat *st;\n\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\n\t\tst = per_cpu_ptr(net->ct.stat, cpu);\n\t\tif (ctnetlink_ct_stat_cpu_fill_info(skb,\n\t\t\t\t\t\t    NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t    cpu, st) < 0)\n\t\t\t\tbreak;\n\t}\n\tcb->args[0] = cpu;\n\n\treturn skb->len;\n}\n\nstatic int ctnetlink_stat_ct_cpu(struct sk_buff *skb,\n\t\t\t\t const struct nfnl_info *info,\n\t\t\t\t const struct nlattr * const cda[])\n{\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = ctnetlink_ct_stat_cpu_dump,\n\t\t};\n\t\treturn netlink_dump_start(info->sk, skb, info->nlh, &c);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nctnetlink_stat_ct_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\n\t\t\t    struct net *net)\n{\n\tunsigned int flags = portid ? NLM_F_MULTI : 0, event;\n\tunsigned int nr_conntracks;\n\tstruct nlmsghdr *nlh;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_CTNETLINK, IPCTNL_MSG_CT_GET_STATS);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, AF_UNSPEC,\n\t\t\t   NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tnr_conntracks = nf_conntrack_count(net);\n\tif (nla_put_be32(skb, CTA_STATS_GLOBAL_ENTRIES, htonl(nr_conntracks)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be32(skb, CTA_STATS_GLOBAL_MAX_ENTRIES, htonl(nf_conntrack_max)))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn skb->len;\n\nnla_put_failure:\nnlmsg_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -1;\n}\n\nstatic int ctnetlink_stat_ct(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const cda[])\n{\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb2 == NULL)\n\t\treturn -ENOMEM;\n\n\terr = ctnetlink_stat_ct_fill_info(skb2, NETLINK_CB(skb).portid,\n\t\t\t\t\t  info->nlh->nlmsg_seq,\n\t\t\t\t\t  NFNL_MSG_TYPE(info->nlh->nlmsg_type),\n\t\t\t\t\t  sock_net(skb->sk));\n\tif (err <= 0) {\n\t\tkfree_skb(skb2);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n}\n\nstatic const struct nla_policy exp_nla_policy[CTA_EXPECT_MAX+1] = {\n\t[CTA_EXPECT_MASTER]\t= { .type = NLA_NESTED },\n\t[CTA_EXPECT_TUPLE]\t= { .type = NLA_NESTED },\n\t[CTA_EXPECT_MASK]\t= { .type = NLA_NESTED },\n\t[CTA_EXPECT_TIMEOUT]\t= { .type = NLA_U32 },\n\t[CTA_EXPECT_ID]\t\t= { .type = NLA_U32 },\n\t[CTA_EXPECT_HELP_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = NF_CT_HELPER_NAME_LEN - 1 },\n\t[CTA_EXPECT_ZONE]\t= { .type = NLA_U16 },\n\t[CTA_EXPECT_FLAGS]\t= { .type = NLA_U32 },\n\t[CTA_EXPECT_CLASS]\t= { .type = NLA_U32 },\n\t[CTA_EXPECT_NAT]\t= { .type = NLA_NESTED },\n\t[CTA_EXPECT_FN]\t\t= { .type = NLA_NUL_STRING },\n};\n\nstatic struct nf_conntrack_expect *\nctnetlink_alloc_expect(const struct nlattr *const cda[], struct nf_conn *ct,\n\t\t       struct nf_conntrack_helper *helper,\n\t\t       struct nf_conntrack_tuple *tuple,\n\t\t       struct nf_conntrack_tuple *mask);\n\n#ifdef CONFIG_NETFILTER_NETLINK_GLUE_CT\nstatic size_t\nctnetlink_glue_build_size(const struct nf_conn *ct)\n{\n\treturn 3 * nla_total_size(0)  \n\t       + 3 * nla_total_size(0)  \n\t       + 3 * nla_total_size(0)  \n\t       + 3 * nla_total_size(sizeof(u_int8_t))  \n\t       + nla_total_size(sizeof(u_int32_t))  \n\t       + nla_total_size(sizeof(u_int32_t))  \n\t       + nla_total_size(sizeof(u_int32_t))  \n\t       + nla_total_size(0)  \n\t       + nla_total_size(0)  \n\t       + nla_total_size(NF_CT_HELPER_NAME_LEN)  \n\t       + ctnetlink_secctx_size(ct)\n\t       + ctnetlink_acct_size(ct)\n\t       + ctnetlink_timestamp_size(ct)\n#if IS_ENABLED(CONFIG_NF_NAT)\n\t       + 2 * nla_total_size(0)  \n\t       + 6 * nla_total_size(sizeof(u_int32_t))  \n#endif\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\t       + nla_total_size(sizeof(u_int32_t))  \n#endif\n#ifdef CONFIG_NF_CONNTRACK_ZONES\n\t       + nla_total_size(sizeof(u_int16_t))  \n#endif\n\t       + ctnetlink_proto_size(ct)\n\t       ;\n}\n\nstatic int __ctnetlink_glue_build(struct sk_buff *skb, struct nf_conn *ct)\n{\n\tconst struct nf_conntrack_zone *zone;\n\tstruct nlattr *nest_parms;\n\n\tzone = nf_ct_zone(ct);\n\n\tnest_parms = nla_nest_start(skb, CTA_TUPLE_ORIG);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_ORIGINAL)) < 0)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_zone_id(skb, CTA_TUPLE_ZONE, zone,\n\t\t\t\t   NF_CT_ZONE_DIR_ORIG) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_parms);\n\n\tnest_parms = nla_nest_start(skb, CTA_TUPLE_REPLY);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_REPLY)) < 0)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_zone_id(skb, CTA_TUPLE_ZONE, zone,\n\t\t\t\t   NF_CT_ZONE_DIR_REPL) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_parms);\n\n\tif (ctnetlink_dump_zone_id(skb, CTA_ZONE, zone,\n\t\t\t\t   NF_CT_DEFAULT_ZONE_DIR) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ctnetlink_dump_id(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ctnetlink_dump_status(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ctnetlink_dump_timeout(skb, ct, false) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ctnetlink_dump_protoinfo(skb, ct, false) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ctnetlink_dump_acct(skb, ct, IPCTNL_MSG_CT_GET) < 0 ||\n\t    ctnetlink_dump_timestamp(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ctnetlink_dump_helpinfo(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\n\tif (ct->secmark && ctnetlink_dump_secctx(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n#endif\n\tif (ct->master && ctnetlink_dump_master(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\n\tif ((ct->status & IPS_SEQ_ADJUST) &&\n\t    ctnetlink_dump_ct_seq_adj(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ctnetlink_dump_ct_synproxy(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\tif (ctnetlink_dump_mark(skb, ct, true) < 0)\n\t\tgoto nla_put_failure;\n#endif\n\tif (ctnetlink_dump_labels(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic int\nctnetlink_glue_build(struct sk_buff *skb, struct nf_conn *ct,\n\t\t     enum ip_conntrack_info ctinfo,\n\t\t     u_int16_t ct_attr, u_int16_t ct_info_attr)\n{\n\tstruct nlattr *nest_parms;\n\n\tnest_parms = nla_nest_start(skb, ct_attr);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\n\tif (__ctnetlink_glue_build(skb, ct) < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest_parms);\n\n\tif (nla_put_be32(skb, ct_info_attr, htonl(ctinfo)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic int\nctnetlink_update_status(struct nf_conn *ct, const struct nlattr * const cda[])\n{\n\tunsigned int status = ntohl(nla_get_be32(cda[CTA_STATUS]));\n\tunsigned long d = ct->status ^ status;\n\n\tif (d & IPS_SEEN_REPLY && !(status & IPS_SEEN_REPLY))\n\t\t \n\t\treturn -EBUSY;\n\n\tif (d & IPS_ASSURED && !(status & IPS_ASSURED))\n\t\t \n\t\treturn -EBUSY;\n\n\t \n\t__nf_ct_change_status(ct, status, ~status);\n\treturn 0;\n}\n\nstatic int\nctnetlink_glue_parse_ct(const struct nlattr *cda[], struct nf_conn *ct)\n{\n\tint err;\n\n\tif (cda[CTA_TIMEOUT]) {\n\t\terr = ctnetlink_change_timeout(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (cda[CTA_STATUS]) {\n\t\terr = ctnetlink_update_status(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (cda[CTA_HELP]) {\n\t\terr = ctnetlink_change_helper(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (cda[CTA_LABELS]) {\n\t\terr = ctnetlink_attach_labels(ct, cda);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n#if defined(CONFIG_NF_CONNTRACK_MARK)\n\tif (cda[CTA_MARK]) {\n\t\tctnetlink_change_mark(ct, cda);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int\nctnetlink_glue_parse(const struct nlattr *attr, struct nf_conn *ct)\n{\n\tstruct nlattr *cda[CTA_MAX+1];\n\tint ret;\n\n\tret = nla_parse_nested_deprecated(cda, CTA_MAX, attr, ct_nla_policy,\n\t\t\t\t\t  NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ctnetlink_glue_parse_ct((const struct nlattr **)cda, ct);\n}\n\nstatic int ctnetlink_glue_exp_parse(const struct nlattr * const *cda,\n\t\t\t\t    const struct nf_conn *ct,\n\t\t\t\t    struct nf_conntrack_tuple *tuple,\n\t\t\t\t    struct nf_conntrack_tuple *mask)\n{\n\tint err;\n\n\terr = ctnetlink_parse_tuple(cda, tuple, CTA_EXPECT_TUPLE,\n\t\t\t\t    nf_ct_l3num(ct), NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn ctnetlink_parse_tuple(cda, mask, CTA_EXPECT_MASK,\n\t\t\t\t     nf_ct_l3num(ct), NULL);\n}\n\nstatic int\nctnetlink_glue_attach_expect(const struct nlattr *attr, struct nf_conn *ct,\n\t\t\t     u32 portid, u32 report)\n{\n\tstruct nlattr *cda[CTA_EXPECT_MAX+1];\n\tstruct nf_conntrack_tuple tuple, mask;\n\tstruct nf_conntrack_helper *helper = NULL;\n\tstruct nf_conntrack_expect *exp;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(cda, CTA_EXPECT_MAX, attr,\n\t\t\t\t\t  exp_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ctnetlink_glue_exp_parse((const struct nlattr * const *)cda,\n\t\t\t\t       ct, &tuple, &mask);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cda[CTA_EXPECT_HELP_NAME]) {\n\t\tconst char *helpname = nla_data(cda[CTA_EXPECT_HELP_NAME]);\n\n\t\thelper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),\n\t\t\t\t\t\t    nf_ct_protonum(ct));\n\t\tif (helper == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\texp = ctnetlink_alloc_expect((const struct nlattr * const *)cda, ct,\n\t\t\t\t     helper, &tuple, &mask);\n\tif (IS_ERR(exp))\n\t\treturn PTR_ERR(exp);\n\n\terr = nf_ct_expect_related_report(exp, portid, report, 0);\n\tnf_ct_expect_put(exp);\n\treturn err;\n}\n\nstatic void ctnetlink_glue_seqadj(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t\t  enum ip_conntrack_info ctinfo, int diff)\n{\n\tif (!(ct->status & IPS_NAT_MASK))\n\t\treturn;\n\n\tnf_ct_tcp_seqadj_set(skb, ct, ctinfo, diff);\n}\n\nstatic const struct nfnl_ct_hook ctnetlink_glue_hook = {\n\t.build_size\t= ctnetlink_glue_build_size,\n\t.build\t\t= ctnetlink_glue_build,\n\t.parse\t\t= ctnetlink_glue_parse,\n\t.attach_expect\t= ctnetlink_glue_attach_expect,\n\t.seq_adjust\t= ctnetlink_glue_seqadj,\n};\n#endif  \n\n \n\nstatic int ctnetlink_exp_dump_tuple(struct sk_buff *skb,\n\t\t\t\t    const struct nf_conntrack_tuple *tuple,\n\t\t\t\t    u32 type)\n{\n\tstruct nlattr *nest_parms;\n\n\tnest_parms = nla_nest_start(skb, type);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_dump_tuples(skb, tuple) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_parms);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int ctnetlink_exp_dump_mask(struct sk_buff *skb,\n\t\t\t\t   const struct nf_conntrack_tuple *tuple,\n\t\t\t\t   const struct nf_conntrack_tuple_mask *mask)\n{\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tstruct nf_conntrack_tuple m;\n\tstruct nlattr *nest_parms;\n\tint ret;\n\n\tmemset(&m, 0xFF, sizeof(m));\n\tmemcpy(&m.src.u3, &mask->src.u3, sizeof(m.src.u3));\n\tm.src.u.all = mask->src.u.all;\n\tm.src.l3num = tuple->src.l3num;\n\tm.dst.protonum = tuple->dst.protonum;\n\n\tnest_parms = nla_nest_start(skb, CTA_EXPECT_MASK);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\tret = ctnetlink_dump_tuples_ip(skb, &m);\n\tif (ret >= 0) {\n\t\tl4proto = nf_ct_l4proto_find(tuple->dst.protonum);\n\t\tret = ctnetlink_dump_tuples_proto(skb, &m, l4proto);\n\t}\n\trcu_read_unlock();\n\n\tif (unlikely(ret < 0))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest_parms);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\n#if IS_ENABLED(CONFIG_NF_NAT)\nstatic const union nf_inet_addr any_addr;\n#endif\n\nstatic __be32 nf_expect_get_id(const struct nf_conntrack_expect *exp)\n{\n\tstatic siphash_aligned_key_t exp_id_seed;\n\tunsigned long a, b, c, d;\n\n\tnet_get_random_once(&exp_id_seed, sizeof(exp_id_seed));\n\n\ta = (unsigned long)exp;\n\tb = (unsigned long)exp->helper;\n\tc = (unsigned long)exp->master;\n\td = (unsigned long)siphash(&exp->tuple, sizeof(exp->tuple), &exp_id_seed);\n\n#ifdef CONFIG_64BIT\n\treturn (__force __be32)siphash_4u64((u64)a, (u64)b, (u64)c, (u64)d, &exp_id_seed);\n#else\n\treturn (__force __be32)siphash_4u32((u32)a, (u32)b, (u32)c, (u32)d, &exp_id_seed);\n#endif\n}\n\nstatic int\nctnetlink_exp_dump_expect(struct sk_buff *skb,\n\t\t\t  const struct nf_conntrack_expect *exp)\n{\n\tstruct nf_conn *master = exp->master;\n\tlong timeout = ((long)exp->timeout.expires - (long)jiffies) / HZ;\n\tstruct nf_conn_help *help;\n#if IS_ENABLED(CONFIG_NF_NAT)\n\tstruct nlattr *nest_parms;\n\tstruct nf_conntrack_tuple nat_tuple = {};\n#endif\n\tstruct nf_ct_helper_expectfn *expfn;\n\n\tif (timeout < 0)\n\t\ttimeout = 0;\n\n\tif (ctnetlink_exp_dump_tuple(skb, &exp->tuple, CTA_EXPECT_TUPLE) < 0)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_exp_dump_mask(skb, &exp->tuple, &exp->mask) < 0)\n\t\tgoto nla_put_failure;\n\tif (ctnetlink_exp_dump_tuple(skb,\n\t\t\t\t &master->tuplehash[IP_CT_DIR_ORIGINAL].tuple,\n\t\t\t\t CTA_EXPECT_MASTER) < 0)\n\t\tgoto nla_put_failure;\n\n#if IS_ENABLED(CONFIG_NF_NAT)\n\tif (!nf_inet_addr_cmp(&exp->saved_addr, &any_addr) ||\n\t    exp->saved_proto.all) {\n\t\tnest_parms = nla_nest_start(skb, CTA_EXPECT_NAT);\n\t\tif (!nest_parms)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_be32(skb, CTA_EXPECT_NAT_DIR, htonl(exp->dir)))\n\t\t\tgoto nla_put_failure;\n\n\t\tnat_tuple.src.l3num = nf_ct_l3num(master);\n\t\tnat_tuple.src.u3 = exp->saved_addr;\n\t\tnat_tuple.dst.protonum = nf_ct_protonum(master);\n\t\tnat_tuple.src.u = exp->saved_proto;\n\n\t\tif (ctnetlink_exp_dump_tuple(skb, &nat_tuple,\n\t\t\t\t\t\tCTA_EXPECT_NAT_TUPLE) < 0)\n\t                goto nla_put_failure;\n\t        nla_nest_end(skb, nest_parms);\n\t}\n#endif\n\tif (nla_put_be32(skb, CTA_EXPECT_TIMEOUT, htonl(timeout)) ||\n\t    nla_put_be32(skb, CTA_EXPECT_ID, nf_expect_get_id(exp)) ||\n\t    nla_put_be32(skb, CTA_EXPECT_FLAGS, htonl(exp->flags)) ||\n\t    nla_put_be32(skb, CTA_EXPECT_CLASS, htonl(exp->class)))\n\t\tgoto nla_put_failure;\n\thelp = nfct_help(master);\n\tif (help) {\n\t\tstruct nf_conntrack_helper *helper;\n\n\t\thelper = rcu_dereference(help->helper);\n\t\tif (helper &&\n\t\t    nla_put_string(skb, CTA_EXPECT_HELP_NAME, helper->name))\n\t\t\tgoto nla_put_failure;\n\t}\n\texpfn = nf_ct_helper_expectfn_find_by_symbol(exp->expectfn);\n\tif (expfn != NULL &&\n\t    nla_put_string(skb, CTA_EXPECT_FN, expfn->name))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int\nctnetlink_exp_fill_info(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\tint event, const struct nf_conntrack_expect *exp)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned int flags = portid ? NLM_F_MULTI : 0;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_CTNETLINK_EXP, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags,\n\t\t\t   exp->tuple.src.l3num, NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tif (ctnetlink_exp_dump_expect(skb, exp) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -1;\n}\n\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\nstatic int\nctnetlink_expect_event(unsigned int events, const struct nf_exp_event *item)\n{\n\tstruct nf_conntrack_expect *exp = item->exp;\n\tstruct net *net = nf_ct_exp_net(exp);\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tunsigned int type, group;\n\tint flags = 0;\n\n\tif (events & (1 << IPEXP_DESTROY)) {\n\t\ttype = IPCTNL_MSG_EXP_DELETE;\n\t\tgroup = NFNLGRP_CONNTRACK_EXP_DESTROY;\n\t} else if (events & (1 << IPEXP_NEW)) {\n\t\ttype = IPCTNL_MSG_EXP_NEW;\n\t\tflags = NLM_F_CREATE|NLM_F_EXCL;\n\t\tgroup = NFNLGRP_CONNTRACK_EXP_NEW;\n\t} else\n\t\treturn 0;\n\n\tif (!item->report && !nfnetlink_has_listeners(net, group))\n\t\treturn 0;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\ttype = nfnl_msg_type(NFNL_SUBSYS_CTNETLINK_EXP, type);\n\tnlh = nfnl_msg_put(skb, item->portid, 0, type, flags,\n\t\t\t   exp->tuple.src.l3num, NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tif (ctnetlink_exp_dump_expect(skb, exp) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\tnfnetlink_send(skb, net, item->portid, group, item->report, GFP_ATOMIC);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\nnlmsg_failure:\n\tkfree_skb(skb);\nerrout:\n\tnfnetlink_set_err(net, 0, 0, -ENOBUFS);\n\treturn 0;\n}\n#endif\nstatic int ctnetlink_exp_done(struct netlink_callback *cb)\n{\n\tif (cb->args[1])\n\t\tnf_ct_expect_put((struct nf_conntrack_expect *)cb->args[1]);\n\treturn 0;\n}\n\nstatic int\nctnetlink_exp_dump_table(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nf_conntrack_expect *exp, *last;\n\tstruct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tu_int8_t l3proto = nfmsg->nfgen_family;\n\n\trcu_read_lock();\n\tlast = (struct nf_conntrack_expect *)cb->args[1];\n\tfor (; cb->args[0] < nf_ct_expect_hsize; cb->args[0]++) {\nrestart:\n\t\thlist_for_each_entry_rcu(exp, &nf_ct_expect_hash[cb->args[0]],\n\t\t\t\t\t hnode) {\n\t\t\tif (l3proto && exp->tuple.src.l3num != l3proto)\n\t\t\t\tcontinue;\n\n\t\t\tif (!net_eq(nf_ct_net(exp->master), net))\n\t\t\t\tcontinue;\n\n\t\t\tif (cb->args[1]) {\n\t\t\t\tif (exp != last)\n\t\t\t\t\tcontinue;\n\t\t\t\tcb->args[1] = 0;\n\t\t\t}\n\t\t\tif (ctnetlink_exp_fill_info(skb,\n\t\t\t\t\t\t    NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t    IPCTNL_MSG_EXP_NEW,\n\t\t\t\t\t\t    exp) < 0) {\n\t\t\t\tif (!refcount_inc_not_zero(&exp->use))\n\t\t\t\t\tcontinue;\n\t\t\t\tcb->args[1] = (unsigned long)exp;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (cb->args[1]) {\n\t\t\tcb->args[1] = 0;\n\t\t\tgoto restart;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\tif (last)\n\t\tnf_ct_expect_put(last);\n\n\treturn skb->len;\n}\n\nstatic int\nctnetlink_exp_ct_dump_table(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nf_conntrack_expect *exp, *last;\n\tstruct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\n\tstruct nf_conn *ct = cb->data;\n\tstruct nf_conn_help *help = nfct_help(ct);\n\tu_int8_t l3proto = nfmsg->nfgen_family;\n\n\tif (cb->args[0])\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlast = (struct nf_conntrack_expect *)cb->args[1];\nrestart:\n\thlist_for_each_entry_rcu(exp, &help->expectations, lnode) {\n\t\tif (l3proto && exp->tuple.src.l3num != l3proto)\n\t\t\tcontinue;\n\t\tif (cb->args[1]) {\n\t\t\tif (exp != last)\n\t\t\t\tcontinue;\n\t\t\tcb->args[1] = 0;\n\t\t}\n\t\tif (ctnetlink_exp_fill_info(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t    IPCTNL_MSG_EXP_NEW,\n\t\t\t\t\t    exp) < 0) {\n\t\t\tif (!refcount_inc_not_zero(&exp->use))\n\t\t\t\tcontinue;\n\t\t\tcb->args[1] = (unsigned long)exp;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (cb->args[1]) {\n\t\tcb->args[1] = 0;\n\t\tgoto restart;\n\t}\n\tcb->args[0] = 1;\nout:\n\trcu_read_unlock();\n\tif (last)\n\t\tnf_ct_expect_put(last);\n\n\treturn skb->len;\n}\n\nstatic int ctnetlink_dump_exp_ct(struct net *net, struct sock *ctnl,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t const struct nlmsghdr *nlh,\n\t\t\t\t const struct nlattr * const cda[],\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err;\n\tstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\n\tu_int8_t u3 = nfmsg->nfgen_family;\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nf_conntrack_tuple_hash *h;\n\tstruct nf_conn *ct;\n\tstruct nf_conntrack_zone zone;\n\tstruct netlink_dump_control c = {\n\t\t.dump = ctnetlink_exp_ct_dump_table,\n\t\t.done = ctnetlink_exp_done,\n\t};\n\n\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_MASTER,\n\t\t\t\t    u3, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ctnetlink_parse_zone(cda[CTA_EXPECT_ZONE], &zone);\n\tif (err < 0)\n\t\treturn err;\n\n\th = nf_conntrack_find_get(net, &zone, &tuple);\n\tif (!h)\n\t\treturn -ENOENT;\n\n\tct = nf_ct_tuplehash_to_ctrack(h);\n\t \n\tif (!nfct_help(ct)) {\n\t\tnf_ct_put(ct);\n\t\treturn 0;\n\t}\n\n\tc.data = ct;\n\n\terr = netlink_dump_start(ctnl, skb, nlh, &c);\n\tnf_ct_put(ct);\n\n\treturn err;\n}\n\nstatic int ctnetlink_get_expect(struct sk_buff *skb,\n\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\tconst struct nlattr * const cda[])\n{\n\tu_int8_t u3 = info->nfmsg->nfgen_family;\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conntrack_zone zone;\n\tstruct sk_buff *skb2;\n\tint err;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tif (cda[CTA_EXPECT_MASTER])\n\t\t\treturn ctnetlink_dump_exp_ct(info->net, info->sk, skb,\n\t\t\t\t\t\t     info->nlh, cda,\n\t\t\t\t\t\t     info->extack);\n\t\telse {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = ctnetlink_exp_dump_table,\n\t\t\t\t.done = ctnetlink_exp_done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(info->sk, skb, info->nlh, &c);\n\t\t}\n\t}\n\n\terr = ctnetlink_parse_zone(cda[CTA_EXPECT_ZONE], &zone);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cda[CTA_EXPECT_TUPLE])\n\t\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_TUPLE,\n\t\t\t\t\t    u3, NULL);\n\telse if (cda[CTA_EXPECT_MASTER])\n\t\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_MASTER,\n\t\t\t\t\t    u3, NULL);\n\telse\n\t\treturn -EINVAL;\n\n\tif (err < 0)\n\t\treturn err;\n\n\texp = nf_ct_expect_find_get(info->net, &zone, &tuple);\n\tif (!exp)\n\t\treturn -ENOENT;\n\n\tif (cda[CTA_EXPECT_ID]) {\n\t\t__be32 id = nla_get_be32(cda[CTA_EXPECT_ID]);\n\n\t\tif (id != nf_expect_get_id(exp)) {\n\t\t\tnf_ct_expect_put(exp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb2) {\n\t\tnf_ct_expect_put(exp);\n\t\treturn -ENOMEM;\n\t}\n\n\trcu_read_lock();\n\terr = ctnetlink_exp_fill_info(skb2, NETLINK_CB(skb).portid,\n\t\t\t\t      info->nlh->nlmsg_seq, IPCTNL_MSG_EXP_NEW,\n\t\t\t\t      exp);\n\trcu_read_unlock();\n\tnf_ct_expect_put(exp);\n\tif (err <= 0) {\n\t\tkfree_skb(skb2);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n}\n\nstatic bool expect_iter_name(struct nf_conntrack_expect *exp, void *data)\n{\n\tstruct nf_conntrack_helper *helper;\n\tconst struct nf_conn_help *m_help;\n\tconst char *name = data;\n\n\tm_help = nfct_help(exp->master);\n\n\thelper = rcu_dereference(m_help->helper);\n\tif (!helper)\n\t\treturn false;\n\n\treturn strcmp(helper->name, name) == 0;\n}\n\nstatic bool expect_iter_all(struct nf_conntrack_expect *exp, void *data)\n{\n\treturn true;\n}\n\nstatic int ctnetlink_del_expect(struct sk_buff *skb,\n\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\tconst struct nlattr * const cda[])\n{\n\tu_int8_t u3 = info->nfmsg->nfgen_family;\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nf_conntrack_zone zone;\n\tint err;\n\n\tif (cda[CTA_EXPECT_TUPLE]) {\n\t\t \n\t\terr = ctnetlink_parse_zone(cda[CTA_EXPECT_ZONE], &zone);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_TUPLE,\n\t\t\t\t\t    u3, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\texp = nf_ct_expect_find_get(info->net, &zone, &tuple);\n\t\tif (!exp)\n\t\t\treturn -ENOENT;\n\n\t\tif (cda[CTA_EXPECT_ID]) {\n\t\t\t__be32 id = nla_get_be32(cda[CTA_EXPECT_ID]);\n\t\t\tif (ntohl(id) != (u32)(unsigned long)exp) {\n\t\t\t\tnf_ct_expect_put(exp);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tspin_lock_bh(&nf_conntrack_expect_lock);\n\t\tif (del_timer(&exp->timeout)) {\n\t\t\tnf_ct_unlink_expect_report(exp, NETLINK_CB(skb).portid,\n\t\t\t\t\t\t   nlmsg_report(info->nlh));\n\t\t\tnf_ct_expect_put(exp);\n\t\t}\n\t\tspin_unlock_bh(&nf_conntrack_expect_lock);\n\t\t \n\t\tnf_ct_expect_put(exp);\n\t} else if (cda[CTA_EXPECT_HELP_NAME]) {\n\t\tchar *name = nla_data(cda[CTA_EXPECT_HELP_NAME]);\n\n\t\tnf_ct_expect_iterate_net(info->net, expect_iter_name, name,\n\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t nlmsg_report(info->nlh));\n\t} else {\n\t\t \n\t\tnf_ct_expect_iterate_net(info->net, expect_iter_all, NULL,\n\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t nlmsg_report(info->nlh));\n\t}\n\n\treturn 0;\n}\nstatic int\nctnetlink_change_expect(struct nf_conntrack_expect *x,\n\t\t\tconst struct nlattr * const cda[])\n{\n\tif (cda[CTA_EXPECT_TIMEOUT]) {\n\t\tif (!del_timer(&x->timeout))\n\t\t\treturn -ETIME;\n\n\t\tx->timeout.expires = jiffies +\n\t\t\tntohl(nla_get_be32(cda[CTA_EXPECT_TIMEOUT])) * HZ;\n\t\tadd_timer(&x->timeout);\n\t}\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_NF_NAT)\nstatic const struct nla_policy exp_nat_nla_policy[CTA_EXPECT_NAT_MAX+1] = {\n\t[CTA_EXPECT_NAT_DIR]\t= { .type = NLA_U32 },\n\t[CTA_EXPECT_NAT_TUPLE]\t= { .type = NLA_NESTED },\n};\n#endif\n\nstatic int\nctnetlink_parse_expect_nat(const struct nlattr *attr,\n\t\t\t   struct nf_conntrack_expect *exp,\n\t\t\t   u_int8_t u3)\n{\n#if IS_ENABLED(CONFIG_NF_NAT)\n\tstruct nlattr *tb[CTA_EXPECT_NAT_MAX+1];\n\tstruct nf_conntrack_tuple nat_tuple = {};\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, CTA_EXPECT_NAT_MAX, attr,\n\t\t\t\t\t  exp_nat_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[CTA_EXPECT_NAT_DIR] || !tb[CTA_EXPECT_NAT_TUPLE])\n\t\treturn -EINVAL;\n\n\terr = ctnetlink_parse_tuple((const struct nlattr * const *)tb,\n\t\t\t\t    &nat_tuple, CTA_EXPECT_NAT_TUPLE,\n\t\t\t\t    u3, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\texp->saved_addr = nat_tuple.src.u3;\n\texp->saved_proto = nat_tuple.src.u;\n\texp->dir = ntohl(nla_get_be32(tb[CTA_EXPECT_NAT_DIR]));\n\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic struct nf_conntrack_expect *\nctnetlink_alloc_expect(const struct nlattr * const cda[], struct nf_conn *ct,\n\t\t       struct nf_conntrack_helper *helper,\n\t\t       struct nf_conntrack_tuple *tuple,\n\t\t       struct nf_conntrack_tuple *mask)\n{\n\tu_int32_t class = 0;\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conn_help *help;\n\tint err;\n\n\thelp = nfct_help(ct);\n\tif (!help)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (cda[CTA_EXPECT_CLASS] && helper) {\n\t\tclass = ntohl(nla_get_be32(cda[CTA_EXPECT_CLASS]));\n\t\tif (class > helper->expect_class_max)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\texp = nf_ct_expect_alloc(ct);\n\tif (!exp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (cda[CTA_EXPECT_FLAGS]) {\n\t\texp->flags = ntohl(nla_get_be32(cda[CTA_EXPECT_FLAGS]));\n\t\texp->flags &= ~NF_CT_EXPECT_USERSPACE;\n\t} else {\n\t\texp->flags = 0;\n\t}\n\tif (cda[CTA_EXPECT_FN]) {\n\t\tconst char *name = nla_data(cda[CTA_EXPECT_FN]);\n\t\tstruct nf_ct_helper_expectfn *expfn;\n\n\t\texpfn = nf_ct_helper_expectfn_find_by_name(name);\n\t\tif (expfn == NULL) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t\texp->expectfn = expfn->expectfn;\n\t} else\n\t\texp->expectfn = NULL;\n\n\texp->class = class;\n\texp->master = ct;\n\texp->helper = helper;\n\texp->tuple = *tuple;\n\texp->mask.src.u3 = mask->src.u3;\n\texp->mask.src.u.all = mask->src.u.all;\n\n\tif (cda[CTA_EXPECT_NAT]) {\n\t\terr = ctnetlink_parse_expect_nat(cda[CTA_EXPECT_NAT],\n\t\t\t\t\t\t exp, nf_ct_l3num(ct));\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\treturn exp;\nerr_out:\n\tnf_ct_expect_put(exp);\n\treturn ERR_PTR(err);\n}\n\nstatic int\nctnetlink_create_expect(struct net *net,\n\t\t\tconst struct nf_conntrack_zone *zone,\n\t\t\tconst struct nlattr * const cda[],\n\t\t\tu_int8_t u3, u32 portid, int report)\n{\n\tstruct nf_conntrack_tuple tuple, mask, master_tuple;\n\tstruct nf_conntrack_tuple_hash *h = NULL;\n\tstruct nf_conntrack_helper *helper = NULL;\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conn *ct;\n\tint err;\n\n\t \n\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_TUPLE,\n\t\t\t\t    u3, NULL);\n\tif (err < 0)\n\t\treturn err;\n\terr = ctnetlink_parse_tuple(cda, &mask, CTA_EXPECT_MASK,\n\t\t\t\t    u3, NULL);\n\tif (err < 0)\n\t\treturn err;\n\terr = ctnetlink_parse_tuple(cda, &master_tuple, CTA_EXPECT_MASTER,\n\t\t\t\t    u3, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\th = nf_conntrack_find_get(net, zone, &master_tuple);\n\tif (!h)\n\t\treturn -ENOENT;\n\tct = nf_ct_tuplehash_to_ctrack(h);\n\n\trcu_read_lock();\n\tif (cda[CTA_EXPECT_HELP_NAME]) {\n\t\tconst char *helpname = nla_data(cda[CTA_EXPECT_HELP_NAME]);\n\n\t\thelper = __nf_conntrack_helper_find(helpname, u3,\n\t\t\t\t\t\t    nf_ct_protonum(ct));\n\t\tif (helper == NULL) {\n\t\t\trcu_read_unlock();\n#ifdef CONFIG_MODULES\n\t\t\tif (request_module(\"nfct-helper-%s\", helpname) < 0) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto err_ct;\n\t\t\t}\n\t\t\trcu_read_lock();\n\t\t\thelper = __nf_conntrack_helper_find(helpname, u3,\n\t\t\t\t\t\t\t    nf_ct_protonum(ct));\n\t\t\tif (helper) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto err_rcu;\n\t\t\t}\n\t\t\trcu_read_unlock();\n#endif\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_ct;\n\t\t}\n\t}\n\n\texp = ctnetlink_alloc_expect(cda, ct, helper, &tuple, &mask);\n\tif (IS_ERR(exp)) {\n\t\terr = PTR_ERR(exp);\n\t\tgoto err_rcu;\n\t}\n\n\terr = nf_ct_expect_related_report(exp, portid, report, 0);\n\tnf_ct_expect_put(exp);\nerr_rcu:\n\trcu_read_unlock();\nerr_ct:\n\tnf_ct_put(ct);\n\treturn err;\n}\n\nstatic int ctnetlink_new_expect(struct sk_buff *skb,\n\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\tconst struct nlattr * const cda[])\n{\n\tu_int8_t u3 = info->nfmsg->nfgen_family;\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conntrack_zone zone;\n\tint err;\n\n\tif (!cda[CTA_EXPECT_TUPLE]\n\t    || !cda[CTA_EXPECT_MASK]\n\t    || !cda[CTA_EXPECT_MASTER])\n\t\treturn -EINVAL;\n\n\terr = ctnetlink_parse_zone(cda[CTA_EXPECT_ZONE], &zone);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_TUPLE,\n\t\t\t\t    u3, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_bh(&nf_conntrack_expect_lock);\n\texp = __nf_ct_expect_find(info->net, &zone, &tuple);\n\tif (!exp) {\n\t\tspin_unlock_bh(&nf_conntrack_expect_lock);\n\t\terr = -ENOENT;\n\t\tif (info->nlh->nlmsg_flags & NLM_F_CREATE) {\n\t\t\terr = ctnetlink_create_expect(info->net, &zone, cda, u3,\n\t\t\t\t\t\t      NETLINK_CB(skb).portid,\n\t\t\t\t\t\t      nlmsg_report(info->nlh));\n\t\t}\n\t\treturn err;\n\t}\n\n\terr = -EEXIST;\n\tif (!(info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\terr = ctnetlink_change_expect(exp, cda);\n\tspin_unlock_bh(&nf_conntrack_expect_lock);\n\n\treturn err;\n}\n\nstatic int\nctnetlink_exp_stat_fill_info(struct sk_buff *skb, u32 portid, u32 seq, int cpu,\n\t\t\t     const struct ip_conntrack_stat *st)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned int flags = portid ? NLM_F_MULTI : 0, event;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_CTNETLINK,\n\t\t\t      IPCTNL_MSG_EXP_GET_STATS_CPU);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, AF_UNSPEC,\n\t\t\t   NFNETLINK_V0, htons(cpu));\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tif (nla_put_be32(skb, CTA_STATS_EXP_NEW, htonl(st->expect_new)) ||\n\t    nla_put_be32(skb, CTA_STATS_EXP_CREATE, htonl(st->expect_create)) ||\n\t    nla_put_be32(skb, CTA_STATS_EXP_DELETE, htonl(st->expect_delete)))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn skb->len;\n\nnla_put_failure:\nnlmsg_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -1;\n}\n\nstatic int\nctnetlink_exp_stat_cpu_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint cpu;\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (cb->args[0] == nr_cpu_ids)\n\t\treturn 0;\n\n\tfor (cpu = cb->args[0]; cpu < nr_cpu_ids; cpu++) {\n\t\tconst struct ip_conntrack_stat *st;\n\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\n\t\tst = per_cpu_ptr(net->ct.stat, cpu);\n\t\tif (ctnetlink_exp_stat_fill_info(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t cpu, st) < 0)\n\t\t\tbreak;\n\t}\n\tcb->args[0] = cpu;\n\n\treturn skb->len;\n}\n\nstatic int ctnetlink_stat_exp_cpu(struct sk_buff *skb,\n\t\t\t\t  const struct nfnl_info *info,\n\t\t\t\t  const struct nlattr * const cda[])\n{\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = ctnetlink_exp_stat_cpu_dump,\n\t\t};\n\t\treturn netlink_dump_start(info->sk, skb, info->nlh, &c);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\nstatic struct nf_ct_event_notifier ctnl_notifier = {\n\t.ct_event = ctnetlink_conntrack_event,\n\t.exp_event = ctnetlink_expect_event,\n};\n#endif\n\nstatic const struct nfnl_callback ctnl_cb[IPCTNL_MSG_MAX] = {\n\t[IPCTNL_MSG_CT_NEW]\t= {\n\t\t.call\t\t= ctnetlink_new_conntrack,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_MAX,\n\t\t.policy\t\t= ct_nla_policy\n\t},\n\t[IPCTNL_MSG_CT_GET]\t= {\n\t\t.call\t\t= ctnetlink_get_conntrack,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_MAX,\n\t\t.policy\t\t= ct_nla_policy\n\t},\n\t[IPCTNL_MSG_CT_DELETE]\t= {\n\t\t.call\t\t= ctnetlink_del_conntrack,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_MAX,\n\t\t.policy\t\t= ct_nla_policy\n\t},\n\t[IPCTNL_MSG_CT_GET_CTRZERO] = {\n\t\t.call\t\t= ctnetlink_get_conntrack,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_MAX,\n\t\t.policy\t\t= ct_nla_policy\n\t},\n\t[IPCTNL_MSG_CT_GET_STATS_CPU] = {\n\t\t.call\t\t= ctnetlink_stat_ct_cpu,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t},\n\t[IPCTNL_MSG_CT_GET_STATS] = {\n\t\t.call\t\t= ctnetlink_stat_ct,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t},\n\t[IPCTNL_MSG_CT_GET_DYING] = {\n\t\t.call\t\t= ctnetlink_get_ct_dying,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t},\n\t[IPCTNL_MSG_CT_GET_UNCONFIRMED]\t= {\n\t\t.call\t\t= ctnetlink_get_ct_unconfirmed,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t},\n};\n\nstatic const struct nfnl_callback ctnl_exp_cb[IPCTNL_MSG_EXP_MAX] = {\n\t[IPCTNL_MSG_EXP_GET] = {\n\t\t.call\t\t= ctnetlink_get_expect,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_EXPECT_MAX,\n\t\t.policy\t\t= exp_nla_policy\n\t},\n\t[IPCTNL_MSG_EXP_NEW] = {\n\t\t.call\t\t= ctnetlink_new_expect,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_EXPECT_MAX,\n\t\t.policy\t\t= exp_nla_policy\n\t},\n\t[IPCTNL_MSG_EXP_DELETE] = {\n\t\t.call\t\t= ctnetlink_del_expect,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= CTA_EXPECT_MAX,\n\t\t.policy\t\t= exp_nla_policy\n\t},\n\t[IPCTNL_MSG_EXP_GET_STATS_CPU] = {\n\t\t.call\t\t= ctnetlink_stat_exp_cpu,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t},\n};\n\nstatic const struct nfnetlink_subsystem ctnl_subsys = {\n\t.name\t\t\t\t= \"conntrack\",\n\t.subsys_id\t\t\t= NFNL_SUBSYS_CTNETLINK,\n\t.cb_count\t\t\t= IPCTNL_MSG_MAX,\n\t.cb\t\t\t\t= ctnl_cb,\n};\n\nstatic const struct nfnetlink_subsystem ctnl_exp_subsys = {\n\t.name\t\t\t\t= \"conntrack_expect\",\n\t.subsys_id\t\t\t= NFNL_SUBSYS_CTNETLINK_EXP,\n\t.cb_count\t\t\t= IPCTNL_MSG_EXP_MAX,\n\t.cb\t\t\t\t= ctnl_exp_cb,\n};\n\nMODULE_ALIAS(\"ip_conntrack_netlink\");\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_CTNETLINK);\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_CTNETLINK_EXP);\n\nstatic int __net_init ctnetlink_net_init(struct net *net)\n{\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tnf_conntrack_register_notifier(net, &ctnl_notifier);\n#endif\n\treturn 0;\n}\n\nstatic void ctnetlink_net_pre_exit(struct net *net)\n{\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tnf_conntrack_unregister_notifier(net);\n#endif\n}\n\nstatic struct pernet_operations ctnetlink_net_ops = {\n\t.init\t\t= ctnetlink_net_init,\n\t.pre_exit\t= ctnetlink_net_pre_exit,\n};\n\nstatic int __init ctnetlink_init(void)\n{\n\tint ret;\n\n\tNL_ASSERT_DUMP_CTX_FITS(struct ctnetlink_list_dump_ctx);\n\n\tret = nfnetlink_subsys_register(&ctnl_subsys);\n\tif (ret < 0) {\n\t\tpr_err(\"ctnetlink_init: cannot register with nfnetlink.\\n\");\n\t\tgoto err_out;\n\t}\n\n\tret = nfnetlink_subsys_register(&ctnl_exp_subsys);\n\tif (ret < 0) {\n\t\tpr_err(\"ctnetlink_init: cannot register exp with nfnetlink.\\n\");\n\t\tgoto err_unreg_subsys;\n\t}\n\n\tret = register_pernet_subsys(&ctnetlink_net_ops);\n\tif (ret < 0) {\n\t\tpr_err(\"ctnetlink_init: cannot register pernet operations\\n\");\n\t\tgoto err_unreg_exp_subsys;\n\t}\n#ifdef CONFIG_NETFILTER_NETLINK_GLUE_CT\n\t \n\tRCU_INIT_POINTER(nfnl_ct_hook, &ctnetlink_glue_hook);\n#endif\n\treturn 0;\n\nerr_unreg_exp_subsys:\n\tnfnetlink_subsys_unregister(&ctnl_exp_subsys);\nerr_unreg_subsys:\n\tnfnetlink_subsys_unregister(&ctnl_subsys);\nerr_out:\n\treturn ret;\n}\n\nstatic void __exit ctnetlink_exit(void)\n{\n\tunregister_pernet_subsys(&ctnetlink_net_ops);\n\tnfnetlink_subsys_unregister(&ctnl_exp_subsys);\n\tnfnetlink_subsys_unregister(&ctnl_subsys);\n#ifdef CONFIG_NETFILTER_NETLINK_GLUE_CT\n\tRCU_INIT_POINTER(nfnl_ct_hook, NULL);\n#endif\n\tsynchronize_rcu();\n}\n\nmodule_init(ctnetlink_init);\nmodule_exit(ctnetlink_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}