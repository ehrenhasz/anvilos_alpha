{
  "module_name": "xt_RATEEST.c",
  "hash_id": "13b355e640a95fb9c03637bf2647decf9c7444861856c5375a5727399f188277",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_RATEEST.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/gen_stats.h>\n#include <linux/jhash.h>\n#include <linux/rtnetlink.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <net/gen_stats.h>\n#include <net/netlink.h>\n#include <net/netns/generic.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_RATEEST.h>\n#include <net/netfilter/xt_rateest.h>\n\n#define RATEEST_HSIZE\t16\n\nstruct xt_rateest_net {\n\tstruct mutex hash_lock;\n\tstruct hlist_head hash[RATEEST_HSIZE];\n};\n\nstatic unsigned int xt_rateest_id;\n\nstatic unsigned int jhash_rnd __read_mostly;\n\nstatic unsigned int xt_rateest_hash(const char *name)\n{\n\treturn jhash(name, sizeof_field(struct xt_rateest, name), jhash_rnd) &\n\t       (RATEEST_HSIZE - 1);\n}\n\nstatic void xt_rateest_hash_insert(struct xt_rateest_net *xn,\n\t\t\t\t   struct xt_rateest *est)\n{\n\tunsigned int h;\n\n\th = xt_rateest_hash(est->name);\n\thlist_add_head(&est->list, &xn->hash[h]);\n}\n\nstatic struct xt_rateest *__xt_rateest_lookup(struct xt_rateest_net *xn,\n\t\t\t\t\t      const char *name)\n{\n\tstruct xt_rateest *est;\n\tunsigned int h;\n\n\th = xt_rateest_hash(name);\n\thlist_for_each_entry(est, &xn->hash[h], list) {\n\t\tif (strcmp(est->name, name) == 0) {\n\t\t\test->refcnt++;\n\t\t\treturn est;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct xt_rateest *xt_rateest_lookup(struct net *net, const char *name)\n{\n\tstruct xt_rateest_net *xn = net_generic(net, xt_rateest_id);\n\tstruct xt_rateest *est;\n\n\tmutex_lock(&xn->hash_lock);\n\test = __xt_rateest_lookup(xn, name);\n\tmutex_unlock(&xn->hash_lock);\n\treturn est;\n}\nEXPORT_SYMBOL_GPL(xt_rateest_lookup);\n\nvoid xt_rateest_put(struct net *net, struct xt_rateest *est)\n{\n\tstruct xt_rateest_net *xn = net_generic(net, xt_rateest_id);\n\n\tmutex_lock(&xn->hash_lock);\n\tif (--est->refcnt == 0) {\n\t\thlist_del(&est->list);\n\t\tgen_kill_estimator(&est->rate_est);\n\t\t \n\t\tkfree_rcu(est, rcu);\n\t}\n\tmutex_unlock(&xn->hash_lock);\n}\nEXPORT_SYMBOL_GPL(xt_rateest_put);\n\nstatic unsigned int\nxt_rateest_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_rateest_target_info *info = par->targinfo;\n\tstruct gnet_stats_basic_sync *stats = &info->est->bstats;\n\n\tspin_lock_bh(&info->est->lock);\n\tu64_stats_add(&stats->bytes, skb->len);\n\tu64_stats_inc(&stats->packets);\n\tspin_unlock_bh(&info->est->lock);\n\n\treturn XT_CONTINUE;\n}\n\nstatic int xt_rateest_tg_checkentry(const struct xt_tgchk_param *par)\n{\n\tstruct xt_rateest_net *xn = net_generic(par->net, xt_rateest_id);\n\tstruct xt_rateest_target_info *info = par->targinfo;\n\tstruct xt_rateest *est;\n\tstruct {\n\t\tstruct nlattr\t\topt;\n\t\tstruct gnet_estimator\test;\n\t} cfg;\n\tint ret;\n\n\tif (strnlen(info->name, sizeof(est->name)) >= sizeof(est->name))\n\t\treturn -ENAMETOOLONG;\n\n\tnet_get_random_once(&jhash_rnd, sizeof(jhash_rnd));\n\n\tmutex_lock(&xn->hash_lock);\n\test = __xt_rateest_lookup(xn, info->name);\n\tif (est) {\n\t\tmutex_unlock(&xn->hash_lock);\n\t\t \n\t\tif ((!info->interval && !info->ewma_log) ||\n\t\t    (info->interval != est->params.interval ||\n\t\t     info->ewma_log != est->params.ewma_log)) {\n\t\t\txt_rateest_put(par->net, est);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinfo->est = est;\n\t\treturn 0;\n\t}\n\n\tret = -ENOMEM;\n\test = kzalloc(sizeof(*est), GFP_KERNEL);\n\tif (!est)\n\t\tgoto err1;\n\n\tgnet_stats_basic_sync_init(&est->bstats);\n\tstrscpy(est->name, info->name, sizeof(est->name));\n\tspin_lock_init(&est->lock);\n\test->refcnt\t\t= 1;\n\test->params.interval\t= info->interval;\n\test->params.ewma_log\t= info->ewma_log;\n\n\tcfg.opt.nla_len\t\t= nla_attr_size(sizeof(cfg.est));\n\tcfg.opt.nla_type\t= TCA_STATS_RATE_EST;\n\tcfg.est.interval\t= info->interval;\n\tcfg.est.ewma_log\t= info->ewma_log;\n\n\tret = gen_new_estimator(&est->bstats, NULL, &est->rate_est,\n\t\t\t\t&est->lock, NULL, &cfg.opt);\n\tif (ret < 0)\n\t\tgoto err2;\n\n\tinfo->est = est;\n\txt_rateest_hash_insert(xn, est);\n\tmutex_unlock(&xn->hash_lock);\n\treturn 0;\n\nerr2:\n\tkfree(est);\nerr1:\n\tmutex_unlock(&xn->hash_lock);\n\treturn ret;\n}\n\nstatic void xt_rateest_tg_destroy(const struct xt_tgdtor_param *par)\n{\n\tstruct xt_rateest_target_info *info = par->targinfo;\n\n\txt_rateest_put(par->net, info->est);\n}\n\nstatic struct xt_target xt_rateest_tg_reg __read_mostly = {\n\t.name       = \"RATEEST\",\n\t.revision   = 0,\n\t.family     = NFPROTO_UNSPEC,\n\t.target     = xt_rateest_tg,\n\t.checkentry = xt_rateest_tg_checkentry,\n\t.destroy    = xt_rateest_tg_destroy,\n\t.targetsize = sizeof(struct xt_rateest_target_info),\n\t.usersize   = offsetof(struct xt_rateest_target_info, est),\n\t.me         = THIS_MODULE,\n};\n\nstatic __net_init int xt_rateest_net_init(struct net *net)\n{\n\tstruct xt_rateest_net *xn = net_generic(net, xt_rateest_id);\n\tint i;\n\n\tmutex_init(&xn->hash_lock);\n\tfor (i = 0; i < ARRAY_SIZE(xn->hash); i++)\n\t\tINIT_HLIST_HEAD(&xn->hash[i]);\n\treturn 0;\n}\n\nstatic struct pernet_operations xt_rateest_net_ops = {\n\t.init = xt_rateest_net_init,\n\t.id   = &xt_rateest_id,\n\t.size = sizeof(struct xt_rateest_net),\n};\n\nstatic int __init xt_rateest_tg_init(void)\n{\n\tint err = register_pernet_subsys(&xt_rateest_net_ops);\n\n\tif (err)\n\t\treturn err;\n\treturn xt_register_target(&xt_rateest_tg_reg);\n}\n\nstatic void __exit xt_rateest_tg_fini(void)\n{\n\txt_unregister_target(&xt_rateest_tg_reg);\n\tunregister_pernet_subsys(&xt_rateest_net_ops);\n}\n\n\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Xtables: packet rate estimator\");\nMODULE_ALIAS(\"ipt_RATEEST\");\nMODULE_ALIAS(\"ip6t_RATEEST\");\nmodule_init(xt_rateest_tg_init);\nmodule_exit(xt_rateest_tg_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}