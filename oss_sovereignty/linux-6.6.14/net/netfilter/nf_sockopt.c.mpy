{
  "module_name": "nf_sockopt.c",
  "hash_id": "976806c1e736b25a06a17810e42ef147cd5589fb7231fbca9dab445280dd8eed",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_sockopt.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter.h>\n#include <linux/mutex.h>\n#include <net/sock.h>\n\n#include \"nf_internals.h\"\n\n \nstatic DEFINE_MUTEX(nf_sockopt_mutex);\nstatic LIST_HEAD(nf_sockopts);\n\n \nstatic inline int overlap(int min1, int max1, int min2, int max2)\n{\n\treturn max1 > min2 && min1 < max2;\n}\n\n \nint nf_register_sockopt(struct nf_sockopt_ops *reg)\n{\n\tstruct nf_sockopt_ops *ops;\n\tint ret = 0;\n\n\tmutex_lock(&nf_sockopt_mutex);\n\tlist_for_each_entry(ops, &nf_sockopts, list) {\n\t\tif (ops->pf == reg->pf\n\t\t    && (overlap(ops->set_optmin, ops->set_optmax,\n\t\t\t\treg->set_optmin, reg->set_optmax)\n\t\t\t|| overlap(ops->get_optmin, ops->get_optmax,\n\t\t\t\t   reg->get_optmin, reg->get_optmax))) {\n\t\t\tpr_debug(\"nf_sock overlap: %u-%u/%u-%u v %u-%u/%u-%u\\n\",\n\t\t\t\tops->set_optmin, ops->set_optmax,\n\t\t\t\tops->get_optmin, ops->get_optmax,\n\t\t\t\treg->set_optmin, reg->set_optmax,\n\t\t\t\treg->get_optmin, reg->get_optmax);\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add(&reg->list, &nf_sockopts);\nout:\n\tmutex_unlock(&nf_sockopt_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(nf_register_sockopt);\n\nvoid nf_unregister_sockopt(struct nf_sockopt_ops *reg)\n{\n\tmutex_lock(&nf_sockopt_mutex);\n\tlist_del(&reg->list);\n\tmutex_unlock(&nf_sockopt_mutex);\n}\nEXPORT_SYMBOL(nf_unregister_sockopt);\n\nstatic struct nf_sockopt_ops *nf_sockopt_find(struct sock *sk, u_int8_t pf,\n\t\tint val, int get)\n{\n\tstruct nf_sockopt_ops *ops;\n\n\tmutex_lock(&nf_sockopt_mutex);\n\tlist_for_each_entry(ops, &nf_sockopts, list) {\n\t\tif (ops->pf == pf) {\n\t\t\tif (!try_module_get(ops->owner))\n\t\t\t\tgoto out_nosup;\n\n\t\t\tif (get) {\n\t\t\t\tif (val >= ops->get_optmin &&\n\t\t\t\t\t\tval < ops->get_optmax)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (val >= ops->set_optmin &&\n\t\t\t\t\t\tval < ops->set_optmax)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmodule_put(ops->owner);\n\t\t}\n\t}\nout_nosup:\n\tops = ERR_PTR(-ENOPROTOOPT);\nout:\n\tmutex_unlock(&nf_sockopt_mutex);\n\treturn ops;\n}\n\nint nf_setsockopt(struct sock *sk, u_int8_t pf, int val, sockptr_t opt,\n\t\t  unsigned int len)\n{\n\tstruct nf_sockopt_ops *ops;\n\tint ret;\n\n\tops = nf_sockopt_find(sk, pf, val, 0);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\tret = ops->set(sk, val, opt, len);\n\tmodule_put(ops->owner);\n\treturn ret;\n}\nEXPORT_SYMBOL(nf_setsockopt);\n\nint nf_getsockopt(struct sock *sk, u_int8_t pf, int val, char __user *opt,\n\t\t  int *len)\n{\n\tstruct nf_sockopt_ops *ops;\n\tint ret;\n\n\tops = nf_sockopt_find(sk, pf, val, 1);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\tret = ops->get(sk, val, opt, len);\n\tmodule_put(ops->owner);\n\treturn ret;\n}\nEXPORT_SYMBOL(nf_getsockopt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}