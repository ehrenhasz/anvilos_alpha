{
  "module_name": "nft_range.c",
  "hash_id": "93a6602480617ebef8a7e262c71a75bb8ddcfa32555617496f486d0d094abf07",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_range.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n\nstruct nft_range_expr {\n\tstruct nft_data\t\tdata_from;\n\tstruct nft_data\t\tdata_to;\n\tu8\t\t\tsreg;\n\tu8\t\t\tlen;\n\tenum nft_range_ops\top:8;\n};\n\nvoid nft_range_eval(const struct nft_expr *expr,\n\t\t    struct nft_regs *regs, const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_range_expr *priv = nft_expr_priv(expr);\n\tint d1, d2;\n\n\td1 = memcmp(&regs->data[priv->sreg], &priv->data_from, priv->len);\n\td2 = memcmp(&regs->data[priv->sreg], &priv->data_to, priv->len);\n\tswitch (priv->op) {\n\tcase NFT_RANGE_EQ:\n\t\tif (d1 < 0 || d2 > 0)\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\tbreak;\n\tcase NFT_RANGE_NEQ:\n\t\tif (d1 >= 0 && d2 <= 0)\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\tbreak;\n\t}\n}\n\nstatic const struct nla_policy nft_range_policy[NFTA_RANGE_MAX + 1] = {\n\t[NFTA_RANGE_SREG]\t\t= { .type = NLA_U32 },\n\t[NFTA_RANGE_OP]\t\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_RANGE_FROM_DATA]\t\t= { .type = NLA_NESTED },\n\t[NFTA_RANGE_TO_DATA]\t\t= { .type = NLA_NESTED },\n};\n\nstatic int nft_range_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t\tconst struct nlattr * const tb[])\n{\n\tstruct nft_range_expr *priv = nft_expr_priv(expr);\n\tstruct nft_data_desc desc_from = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= sizeof(priv->data_from),\n\t};\n\tstruct nft_data_desc desc_to = {\n\t\t.type\t= NFT_DATA_VALUE,\n\t\t.size\t= sizeof(priv->data_to),\n\t};\n\tint err;\n\tu32 op;\n\n\tif (!tb[NFTA_RANGE_SREG]      ||\n\t    !tb[NFTA_RANGE_OP]\t      ||\n\t    !tb[NFTA_RANGE_FROM_DATA] ||\n\t    !tb[NFTA_RANGE_TO_DATA])\n\t\treturn -EINVAL;\n\n\terr = nft_data_init(NULL, &priv->data_from, &desc_from,\n\t\t\t    tb[NFTA_RANGE_FROM_DATA]);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_data_init(NULL, &priv->data_to, &desc_to,\n\t\t\t    tb[NFTA_RANGE_TO_DATA]);\n\tif (err < 0)\n\t\tgoto err1;\n\n\tif (desc_from.len != desc_to.len) {\n\t\terr = -EINVAL;\n\t\tgoto err2;\n\t}\n\n\terr = nft_parse_register_load(tb[NFTA_RANGE_SREG], &priv->sreg,\n\t\t\t\t      desc_from.len);\n\tif (err < 0)\n\t\tgoto err2;\n\n\terr = nft_parse_u32_check(tb[NFTA_RANGE_OP], U8_MAX, &op);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tswitch (op) {\n\tcase NFT_RANGE_EQ:\n\tcase NFT_RANGE_NEQ:\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto err2;\n\t}\n\n\tpriv->op  = op;\n\tpriv->len = desc_from.len;\n\treturn 0;\nerr2:\n\tnft_data_release(&priv->data_to, desc_to.type);\nerr1:\n\tnft_data_release(&priv->data_from, desc_from.type);\n\treturn err;\n}\n\nstatic int nft_range_dump(struct sk_buff *skb,\n\t\t\t  const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_range_expr *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_RANGE_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_RANGE_OP, htonl(priv->op)))\n\t\tgoto nla_put_failure;\n\n\tif (nft_data_dump(skb, NFTA_RANGE_FROM_DATA, &priv->data_from,\n\t\t\t  NFT_DATA_VALUE, priv->len) < 0 ||\n\t    nft_data_dump(skb, NFTA_RANGE_TO_DATA, &priv->data_to,\n\t\t\t  NFT_DATA_VALUE, priv->len) < 0)\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic const struct nft_expr_ops nft_range_ops = {\n\t.type\t\t= &nft_range_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_range_expr)),\n\t.eval\t\t= nft_range_eval,\n\t.init\t\t= nft_range_init,\n\t.dump\t\t= nft_range_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstruct nft_expr_type nft_range_type __read_mostly = {\n\t.name\t\t= \"range\",\n\t.ops\t\t= &nft_range_ops,\n\t.policy\t\t= nft_range_policy,\n\t.maxattr\t= NFTA_RANGE_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}