{
  "module_name": "nft_chain_filter.c",
  "hash_id": "81e688ec1acc05806e6804b855f894d9c43261796bf7a13629add66c7fac6b9c",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_chain_filter.c",
  "human_readable_source": "#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <net/net_namespace.h>\n#include <net/netfilter/nf_tables.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/netfilter_arp.h>\n#include <net/netfilter/nf_tables_ipv4.h>\n#include <net/netfilter/nf_tables_ipv6.h>\n\n#ifdef CONFIG_NF_TABLES_IPV4\nstatic unsigned int nft_do_chain_ipv4(void *priv,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const struct nf_hook_state *state)\n{\n\tstruct nft_pktinfo pkt;\n\n\tnft_set_pktinfo(&pkt, skb, state);\n\tnft_set_pktinfo_ipv4(&pkt);\n\n\treturn nft_do_chain(&pkt, priv);\n}\n\nstatic const struct nft_chain_type nft_chain_filter_ipv4 = {\n\t.name\t\t= \"filter\",\n\t.type\t\t= NFT_CHAIN_T_DEFAULT,\n\t.family\t\t= NFPROTO_IPV4,\n\t.hook_mask\t= (1 << NF_INET_LOCAL_IN) |\n\t\t\t  (1 << NF_INET_LOCAL_OUT) |\n\t\t\t  (1 << NF_INET_FORWARD) |\n\t\t\t  (1 << NF_INET_PRE_ROUTING) |\n\t\t\t  (1 << NF_INET_POST_ROUTING),\n\t.hooks\t\t= {\n\t\t[NF_INET_LOCAL_IN]\t= nft_do_chain_ipv4,\n\t\t[NF_INET_LOCAL_OUT]\t= nft_do_chain_ipv4,\n\t\t[NF_INET_FORWARD]\t= nft_do_chain_ipv4,\n\t\t[NF_INET_PRE_ROUTING]\t= nft_do_chain_ipv4,\n\t\t[NF_INET_POST_ROUTING]\t= nft_do_chain_ipv4,\n\t},\n};\n\nstatic void nft_chain_filter_ipv4_init(void)\n{\n\tnft_register_chain_type(&nft_chain_filter_ipv4);\n}\nstatic void nft_chain_filter_ipv4_fini(void)\n{\n\tnft_unregister_chain_type(&nft_chain_filter_ipv4);\n}\n\n#else\nstatic inline void nft_chain_filter_ipv4_init(void) {}\nstatic inline void nft_chain_filter_ipv4_fini(void) {}\n#endif  \n\n#ifdef CONFIG_NF_TABLES_ARP\nstatic unsigned int nft_do_chain_arp(void *priv, struct sk_buff *skb,\n\t\t\t\t     const struct nf_hook_state *state)\n{\n\tstruct nft_pktinfo pkt;\n\n\tnft_set_pktinfo(&pkt, skb, state);\n\tnft_set_pktinfo_unspec(&pkt);\n\n\treturn nft_do_chain(&pkt, priv);\n}\n\nstatic const struct nft_chain_type nft_chain_filter_arp = {\n\t.name\t\t= \"filter\",\n\t.type\t\t= NFT_CHAIN_T_DEFAULT,\n\t.family\t\t= NFPROTO_ARP,\n\t.owner\t\t= THIS_MODULE,\n\t.hook_mask\t= (1 << NF_ARP_IN) |\n\t\t\t  (1 << NF_ARP_OUT),\n\t.hooks\t\t= {\n\t\t[NF_ARP_IN]\t\t= nft_do_chain_arp,\n\t\t[NF_ARP_OUT]\t\t= nft_do_chain_arp,\n\t},\n};\n\nstatic void nft_chain_filter_arp_init(void)\n{\n\tnft_register_chain_type(&nft_chain_filter_arp);\n}\n\nstatic void nft_chain_filter_arp_fini(void)\n{\n\tnft_unregister_chain_type(&nft_chain_filter_arp);\n}\n#else\nstatic inline void nft_chain_filter_arp_init(void) {}\nstatic inline void nft_chain_filter_arp_fini(void) {}\n#endif  \n\n#ifdef CONFIG_NF_TABLES_IPV6\nstatic unsigned int nft_do_chain_ipv6(void *priv,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const struct nf_hook_state *state)\n{\n\tstruct nft_pktinfo pkt;\n\n\tnft_set_pktinfo(&pkt, skb, state);\n\tnft_set_pktinfo_ipv6(&pkt);\n\n\treturn nft_do_chain(&pkt, priv);\n}\n\nstatic const struct nft_chain_type nft_chain_filter_ipv6 = {\n\t.name\t\t= \"filter\",\n\t.type\t\t= NFT_CHAIN_T_DEFAULT,\n\t.family\t\t= NFPROTO_IPV6,\n\t.hook_mask\t= (1 << NF_INET_LOCAL_IN) |\n\t\t\t  (1 << NF_INET_LOCAL_OUT) |\n\t\t\t  (1 << NF_INET_FORWARD) |\n\t\t\t  (1 << NF_INET_PRE_ROUTING) |\n\t\t\t  (1 << NF_INET_POST_ROUTING),\n\t.hooks\t\t= {\n\t\t[NF_INET_LOCAL_IN]\t= nft_do_chain_ipv6,\n\t\t[NF_INET_LOCAL_OUT]\t= nft_do_chain_ipv6,\n\t\t[NF_INET_FORWARD]\t= nft_do_chain_ipv6,\n\t\t[NF_INET_PRE_ROUTING]\t= nft_do_chain_ipv6,\n\t\t[NF_INET_POST_ROUTING]\t= nft_do_chain_ipv6,\n\t},\n};\n\nstatic void nft_chain_filter_ipv6_init(void)\n{\n\tnft_register_chain_type(&nft_chain_filter_ipv6);\n}\n\nstatic void nft_chain_filter_ipv6_fini(void)\n{\n\tnft_unregister_chain_type(&nft_chain_filter_ipv6);\n}\n#else\nstatic inline void nft_chain_filter_ipv6_init(void) {}\nstatic inline void nft_chain_filter_ipv6_fini(void) {}\n#endif  \n\n#ifdef CONFIG_NF_TABLES_INET\nstatic unsigned int nft_do_chain_inet(void *priv, struct sk_buff *skb,\n\t\t\t\t      const struct nf_hook_state *state)\n{\n\tstruct nft_pktinfo pkt;\n\n\tnft_set_pktinfo(&pkt, skb, state);\n\n\tswitch (state->pf) {\n\tcase NFPROTO_IPV4:\n\t\tnft_set_pktinfo_ipv4(&pkt);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tnft_set_pktinfo_ipv6(&pkt);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn nft_do_chain(&pkt, priv);\n}\n\nstatic unsigned int nft_do_chain_inet_ingress(void *priv, struct sk_buff *skb,\n\t\t\t\t\t      const struct nf_hook_state *state)\n{\n\tstruct nf_hook_state ingress_state = *state;\n\tstruct nft_pktinfo pkt;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\t \n\t\tingress_state.pf = NFPROTO_IPV4;\n\t\tingress_state.hook = NF_INET_INGRESS;\n\t\tnft_set_pktinfo(&pkt, skb, &ingress_state);\n\n\t\tif (nft_set_pktinfo_ipv4_ingress(&pkt) < 0)\n\t\t\treturn NF_DROP;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tingress_state.pf = NFPROTO_IPV6;\n\t\tingress_state.hook = NF_INET_INGRESS;\n\t\tnft_set_pktinfo(&pkt, skb, &ingress_state);\n\n\t\tif (nft_set_pktinfo_ipv6_ingress(&pkt) < 0)\n\t\t\treturn NF_DROP;\n\t\tbreak;\n\tdefault:\n\t\treturn NF_ACCEPT;\n\t}\n\n\treturn nft_do_chain(&pkt, priv);\n}\n\nstatic const struct nft_chain_type nft_chain_filter_inet = {\n\t.name\t\t= \"filter\",\n\t.type\t\t= NFT_CHAIN_T_DEFAULT,\n\t.family\t\t= NFPROTO_INET,\n\t.hook_mask\t= (1 << NF_INET_INGRESS) |\n\t\t\t  (1 << NF_INET_LOCAL_IN) |\n\t\t\t  (1 << NF_INET_LOCAL_OUT) |\n\t\t\t  (1 << NF_INET_FORWARD) |\n\t\t\t  (1 << NF_INET_PRE_ROUTING) |\n\t\t\t  (1 << NF_INET_POST_ROUTING),\n\t.hooks\t\t= {\n\t\t[NF_INET_INGRESS]\t= nft_do_chain_inet_ingress,\n\t\t[NF_INET_LOCAL_IN]\t= nft_do_chain_inet,\n\t\t[NF_INET_LOCAL_OUT]\t= nft_do_chain_inet,\n\t\t[NF_INET_FORWARD]\t= nft_do_chain_inet,\n\t\t[NF_INET_PRE_ROUTING]\t= nft_do_chain_inet,\n\t\t[NF_INET_POST_ROUTING]\t= nft_do_chain_inet,\n        },\n};\n\nstatic void nft_chain_filter_inet_init(void)\n{\n\tnft_register_chain_type(&nft_chain_filter_inet);\n}\n\nstatic void nft_chain_filter_inet_fini(void)\n{\n\tnft_unregister_chain_type(&nft_chain_filter_inet);\n}\n#else\nstatic inline void nft_chain_filter_inet_init(void) {}\nstatic inline void nft_chain_filter_inet_fini(void) {}\n#endif  \n\n#if IS_ENABLED(CONFIG_NF_TABLES_BRIDGE)\nstatic unsigned int\nnft_do_chain_bridge(void *priv,\n\t\t    struct sk_buff *skb,\n\t\t    const struct nf_hook_state *state)\n{\n\tstruct nft_pktinfo pkt;\n\n\tnft_set_pktinfo(&pkt, skb, state);\n\n\tswitch (eth_hdr(skb)->h_proto) {\n\tcase htons(ETH_P_IP):\n\t\tnft_set_pktinfo_ipv4_validate(&pkt);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tnft_set_pktinfo_ipv6_validate(&pkt);\n\t\tbreak;\n\tdefault:\n\t\tnft_set_pktinfo_unspec(&pkt);\n\t\tbreak;\n\t}\n\n\treturn nft_do_chain(&pkt, priv);\n}\n\nstatic const struct nft_chain_type nft_chain_filter_bridge = {\n\t.name\t\t= \"filter\",\n\t.type\t\t= NFT_CHAIN_T_DEFAULT,\n\t.family\t\t= NFPROTO_BRIDGE,\n\t.hook_mask\t= (1 << NF_BR_PRE_ROUTING) |\n\t\t\t  (1 << NF_BR_LOCAL_IN) |\n\t\t\t  (1 << NF_BR_FORWARD) |\n\t\t\t  (1 << NF_BR_LOCAL_OUT) |\n\t\t\t  (1 << NF_BR_POST_ROUTING),\n\t.hooks\t\t= {\n\t\t[NF_BR_PRE_ROUTING]\t= nft_do_chain_bridge,\n\t\t[NF_BR_LOCAL_IN]\t= nft_do_chain_bridge,\n\t\t[NF_BR_FORWARD]\t\t= nft_do_chain_bridge,\n\t\t[NF_BR_LOCAL_OUT]\t= nft_do_chain_bridge,\n\t\t[NF_BR_POST_ROUTING]\t= nft_do_chain_bridge,\n\t},\n};\n\nstatic void nft_chain_filter_bridge_init(void)\n{\n\tnft_register_chain_type(&nft_chain_filter_bridge);\n}\n\nstatic void nft_chain_filter_bridge_fini(void)\n{\n\tnft_unregister_chain_type(&nft_chain_filter_bridge);\n}\n#else\nstatic inline void nft_chain_filter_bridge_init(void) {}\nstatic inline void nft_chain_filter_bridge_fini(void) {}\n#endif  \n\n#ifdef CONFIG_NF_TABLES_NETDEV\nstatic unsigned int nft_do_chain_netdev(void *priv, struct sk_buff *skb,\n\t\t\t\t\tconst struct nf_hook_state *state)\n{\n\tstruct nft_pktinfo pkt;\n\n\tnft_set_pktinfo(&pkt, skb, state);\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tnft_set_pktinfo_ipv4_validate(&pkt);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tnft_set_pktinfo_ipv6_validate(&pkt);\n\t\tbreak;\n\tdefault:\n\t\tnft_set_pktinfo_unspec(&pkt);\n\t\tbreak;\n\t}\n\n\treturn nft_do_chain(&pkt, priv);\n}\n\nstatic const struct nft_chain_type nft_chain_filter_netdev = {\n\t.name\t\t= \"filter\",\n\t.type\t\t= NFT_CHAIN_T_DEFAULT,\n\t.family\t\t= NFPROTO_NETDEV,\n\t.hook_mask\t= (1 << NF_NETDEV_INGRESS) |\n\t\t\t  (1 << NF_NETDEV_EGRESS),\n\t.hooks\t\t= {\n\t\t[NF_NETDEV_INGRESS]\t= nft_do_chain_netdev,\n\t\t[NF_NETDEV_EGRESS]\t= nft_do_chain_netdev,\n\t},\n};\n\nstatic void nft_netdev_event(unsigned long event, struct net_device *dev,\n\t\t\t     struct nft_ctx *ctx)\n{\n\tstruct nft_base_chain *basechain = nft_base_chain(ctx->chain);\n\tstruct nft_hook *hook, *found = NULL;\n\tint n = 0;\n\n\tif (event != NETDEV_UNREGISTER)\n\t\treturn;\n\n\tlist_for_each_entry(hook, &basechain->hook_list, list) {\n\t\tif (hook->ops.dev == dev)\n\t\t\tfound = hook;\n\n\t\tn++;\n\t}\n\tif (!found)\n\t\treturn;\n\n\tif (n > 1) {\n\t\tnf_unregister_net_hook(ctx->net, &found->ops);\n\t\tlist_del_rcu(&found->list);\n\t\tkfree_rcu(found, rcu);\n\t\treturn;\n\t}\n\n\t \n\t__nft_release_basechain(ctx);\n}\n\nstatic int nf_tables_netdev_event(struct notifier_block *this,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct nftables_pernet *nft_net;\n\tstruct nft_table *table;\n\tstruct nft_chain *chain, *nr;\n\tstruct nft_ctx ctx = {\n\t\t.net\t= dev_net(dev),\n\t};\n\n\tif (event != NETDEV_UNREGISTER &&\n\t    event != NETDEV_CHANGENAME)\n\t\treturn NOTIFY_DONE;\n\n\tnft_net = nft_pernet(ctx.net);\n\tmutex_lock(&nft_net->commit_mutex);\n\tlist_for_each_entry(table, &nft_net->tables, list) {\n\t\tif (table->family != NFPROTO_NETDEV)\n\t\t\tcontinue;\n\n\t\tctx.family = table->family;\n\t\tctx.table = table;\n\t\tlist_for_each_entry_safe(chain, nr, &table->chains, list) {\n\t\t\tif (!nft_is_base_chain(chain))\n\t\t\t\tcontinue;\n\n\t\t\tctx.chain = chain;\n\t\t\tnft_netdev_event(event, dev, &ctx);\n\t\t}\n\t}\n\tmutex_unlock(&nft_net->commit_mutex);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nf_tables_netdev_notifier = {\n\t.notifier_call\t= nf_tables_netdev_event,\n};\n\nstatic int nft_chain_filter_netdev_init(void)\n{\n\tint err;\n\n\tnft_register_chain_type(&nft_chain_filter_netdev);\n\n\terr = register_netdevice_notifier(&nf_tables_netdev_notifier);\n\tif (err)\n\t\tgoto err_register_netdevice_notifier;\n\n\treturn 0;\n\nerr_register_netdevice_notifier:\n\tnft_unregister_chain_type(&nft_chain_filter_netdev);\n\n\treturn err;\n}\n\nstatic void nft_chain_filter_netdev_fini(void)\n{\n\tnft_unregister_chain_type(&nft_chain_filter_netdev);\n\tunregister_netdevice_notifier(&nf_tables_netdev_notifier);\n}\n#else\nstatic inline int nft_chain_filter_netdev_init(void) { return 0; }\nstatic inline void nft_chain_filter_netdev_fini(void) {}\n#endif  \n\nint __init nft_chain_filter_init(void)\n{\n\tint err;\n\n\terr = nft_chain_filter_netdev_init();\n\tif (err < 0)\n\t\treturn err;\n\n\tnft_chain_filter_ipv4_init();\n\tnft_chain_filter_ipv6_init();\n\tnft_chain_filter_arp_init();\n\tnft_chain_filter_inet_init();\n\tnft_chain_filter_bridge_init();\n\n\treturn 0;\n}\n\nvoid nft_chain_filter_fini(void)\n{\n\tnft_chain_filter_bridge_fini();\n\tnft_chain_filter_inet_fini();\n\tnft_chain_filter_arp_fini();\n\tnft_chain_filter_ipv6_fini();\n\tnft_chain_filter_ipv4_fini();\n\tnft_chain_filter_netdev_fini();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}