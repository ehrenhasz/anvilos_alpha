{
  "module_name": "xt_connmark.c",
  "hash_id": "d2eefe85d296da850678bb41c5a9c15783bf495a9a55b47b8f3e9f5137f4b23a",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_connmark.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_connmark.h>\n\nMODULE_AUTHOR(\"Henrik Nordstrom <hno@marasystems.com>\");\nMODULE_DESCRIPTION(\"Xtables: connection mark operations\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_CONNMARK\");\nMODULE_ALIAS(\"ip6t_CONNMARK\");\nMODULE_ALIAS(\"ipt_connmark\");\nMODULE_ALIAS(\"ip6t_connmark\");\n\nstatic unsigned int\nconnmark_tg_shift(struct sk_buff *skb, const struct xt_connmark_tginfo2 *info)\n{\n\tenum ip_conntrack_info ctinfo;\n\tu_int32_t new_targetmark;\n\tstruct nf_conn *ct;\n\tu_int32_t newmark;\n\tu_int32_t oldmark;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct == NULL)\n\t\treturn XT_CONTINUE;\n\n\tswitch (info->mode) {\n\tcase XT_CONNMARK_SET:\n\t\toldmark = READ_ONCE(ct->mark);\n\t\tnewmark = (oldmark & ~info->ctmask) ^ info->ctmark;\n\t\tif (info->shift_dir == D_SHIFT_RIGHT)\n\t\t\tnewmark >>= info->shift_bits;\n\t\telse\n\t\t\tnewmark <<= info->shift_bits;\n\n\t\tif (READ_ONCE(ct->mark) != newmark) {\n\t\t\tWRITE_ONCE(ct->mark, newmark);\n\t\t\tnf_conntrack_event_cache(IPCT_MARK, ct);\n\t\t}\n\t\tbreak;\n\tcase XT_CONNMARK_SAVE:\n\t\tnew_targetmark = (skb->mark & info->nfmask);\n\t\tif (info->shift_dir == D_SHIFT_RIGHT)\n\t\t\tnew_targetmark >>= info->shift_bits;\n\t\telse\n\t\t\tnew_targetmark <<= info->shift_bits;\n\n\t\tnewmark = (READ_ONCE(ct->mark) & ~info->ctmask) ^\n\t\t\t  new_targetmark;\n\t\tif (READ_ONCE(ct->mark) != newmark) {\n\t\t\tWRITE_ONCE(ct->mark, newmark);\n\t\t\tnf_conntrack_event_cache(IPCT_MARK, ct);\n\t\t}\n\t\tbreak;\n\tcase XT_CONNMARK_RESTORE:\n\t\tnew_targetmark = (READ_ONCE(ct->mark) & info->ctmask);\n\t\tif (info->shift_dir == D_SHIFT_RIGHT)\n\t\t\tnew_targetmark >>= info->shift_bits;\n\t\telse\n\t\t\tnew_targetmark <<= info->shift_bits;\n\n\t\tnewmark = (skb->mark & ~info->nfmask) ^\n\t\t\t  new_targetmark;\n\t\tskb->mark = newmark;\n\t\tbreak;\n\t}\n\treturn XT_CONTINUE;\n}\n\nstatic unsigned int\nconnmark_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_connmark_tginfo1 *info = par->targinfo;\n\tconst struct xt_connmark_tginfo2 info2 = {\n\t\t.ctmark\t= info->ctmark,\n\t\t.ctmask\t= info->ctmask,\n\t\t.nfmask\t= info->nfmask,\n\t\t.mode\t= info->mode,\n\t};\n\n\treturn connmark_tg_shift(skb, &info2);\n}\n\nstatic unsigned int\nconnmark_tg_v2(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_connmark_tginfo2 *info = par->targinfo;\n\n\treturn connmark_tg_shift(skb, info);\n}\n\nstatic int connmark_tg_check(const struct xt_tgchk_param *par)\n{\n\tint ret;\n\n\tret = nf_ct_netns_get(par->net, par->family);\n\tif (ret < 0)\n\t\tpr_info_ratelimited(\"cannot load conntrack support for proto=%u\\n\",\n\t\t\t\t    par->family);\n\treturn ret;\n}\n\nstatic void connmark_tg_destroy(const struct xt_tgdtor_param *par)\n{\n\tnf_ct_netns_put(par->net, par->family);\n}\n\nstatic bool\nconnmark_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_connmark_mtinfo1 *info = par->matchinfo;\n\tenum ip_conntrack_info ctinfo;\n\tconst struct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct == NULL)\n\t\treturn false;\n\n\treturn ((READ_ONCE(ct->mark) & info->mask) == info->mark) ^ info->invert;\n}\n\nstatic int connmark_mt_check(const struct xt_mtchk_param *par)\n{\n\tint ret;\n\n\tret = nf_ct_netns_get(par->net, par->family);\n\tif (ret < 0)\n\t\tpr_info_ratelimited(\"cannot load conntrack support for proto=%u\\n\",\n\t\t\t\t    par->family);\n\treturn ret;\n}\n\nstatic void connmark_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tnf_ct_netns_put(par->net, par->family);\n}\n\nstatic struct xt_target connmark_tg_reg[] __read_mostly = {\n\t{\n\t\t.name           = \"CONNMARK\",\n\t\t.revision       = 1,\n\t\t.family         = NFPROTO_UNSPEC,\n\t\t.checkentry     = connmark_tg_check,\n\t\t.target         = connmark_tg,\n\t\t.targetsize     = sizeof(struct xt_connmark_tginfo1),\n\t\t.destroy        = connmark_tg_destroy,\n\t\t.me             = THIS_MODULE,\n\t},\n\t{\n\t\t.name           = \"CONNMARK\",\n\t\t.revision       = 2,\n\t\t.family         = NFPROTO_UNSPEC,\n\t\t.checkentry     = connmark_tg_check,\n\t\t.target         = connmark_tg_v2,\n\t\t.targetsize     = sizeof(struct xt_connmark_tginfo2),\n\t\t.destroy        = connmark_tg_destroy,\n\t\t.me             = THIS_MODULE,\n\t}\n};\n\nstatic struct xt_match connmark_mt_reg __read_mostly = {\n\t.name           = \"connmark\",\n\t.revision       = 1,\n\t.family         = NFPROTO_UNSPEC,\n\t.checkentry     = connmark_mt_check,\n\t.match          = connmark_mt,\n\t.matchsize      = sizeof(struct xt_connmark_mtinfo1),\n\t.destroy        = connmark_mt_destroy,\n\t.me             = THIS_MODULE,\n};\n\nstatic int __init connmark_mt_init(void)\n{\n\tint ret;\n\n\tret = xt_register_targets(connmark_tg_reg,\n\t\t\t\t  ARRAY_SIZE(connmark_tg_reg));\n\tif (ret < 0)\n\t\treturn ret;\n\tret = xt_register_match(&connmark_mt_reg);\n\tif (ret < 0) {\n\t\txt_unregister_targets(connmark_tg_reg,\n\t\t\t\t      ARRAY_SIZE(connmark_tg_reg));\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void __exit connmark_mt_exit(void)\n{\n\txt_unregister_match(&connmark_mt_reg);\n\txt_unregister_targets(connmark_tg_reg, ARRAY_SIZE(connmark_tg_reg));\n}\n\nmodule_init(connmark_mt_init);\nmodule_exit(connmark_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}