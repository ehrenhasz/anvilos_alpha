{
  "module_name": "nft_set_pipapo.h",
  "hash_id": "17fed979133c5662ac4187c4032adc2ac6f2a1c67bd3545b5c45da8ccdb39422",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_set_pipapo.h",
  "human_readable_source": "\n\n#ifndef _NFT_SET_PIPAPO_H\n\n#include <linux/log2.h>\n#include <net/ipv6.h>\t\t\t \n\n \n#define NFT_PIPAPO_MAX_FIELDS\t\tNFT_REG32_COUNT\n\n \n#define NFT_PIPAPO_MIN_FIELDS\t\t2\n\n \n#define NFT_PIPAPO_MAX_BYTES\t\t(sizeof(struct in6_addr))\n#define NFT_PIPAPO_MAX_BITS\t\t(NFT_PIPAPO_MAX_BYTES * BITS_PER_BYTE)\n\n \n#define NFT_PIPAPO_GROUP_BITS_INIT\tNFT_PIPAPO_GROUP_BITS_SMALL_SET\n#define NFT_PIPAPO_GROUP_BITS_SMALL_SET\t8\n#define NFT_PIPAPO_GROUP_BITS_LARGE_SET\t4\n#define NFT_PIPAPO_GROUP_BITS_ARE_8_OR_4\t\t\t\t\\\n\tBUILD_BUG_ON((NFT_PIPAPO_GROUP_BITS_SMALL_SET != 8) ||\t\t\\\n\t\t     (NFT_PIPAPO_GROUP_BITS_LARGE_SET != 4))\n#define NFT_PIPAPO_GROUPS_PER_BYTE(f)\t(BITS_PER_BYTE / (f)->bb)\n\n \n#define NFT_PIPAPO_LT_SIZE_THRESHOLD\t(1 << 21)\n#define NFT_PIPAPO_LT_SIZE_HYSTERESIS\t(1 << 16)\n#define NFT_PIPAPO_LT_SIZE_HIGH\t\tNFT_PIPAPO_LT_SIZE_THRESHOLD\n#define NFT_PIPAPO_LT_SIZE_LOW\t\tNFT_PIPAPO_LT_SIZE_THRESHOLD -\t\\\n\t\t\t\t\tNFT_PIPAPO_LT_SIZE_HYSTERESIS\n\n \n#define NFT_PIPAPO_GROUPS_PADDED_SIZE(f)\t\t\t\t\\\n\t(round_up((f)->groups / NFT_PIPAPO_GROUPS_PER_BYTE(f), sizeof(u32)))\n#define NFT_PIPAPO_GROUPS_PADDING(f)\t\t\t\t\t\\\n\t(NFT_PIPAPO_GROUPS_PADDED_SIZE(f) - (f)->groups /\t\t\\\n\t\t\t\t\t    NFT_PIPAPO_GROUPS_PER_BYTE(f))\n\n \n#define NFT_PIPAPO_BUCKETS(bb)\t\t(1 << (bb))\n\n \n#define NFT_PIPAPO_MAP_NBITS\t\t(const_ilog2(NFT_PIPAPO_MAX_BITS * 2))\n\n \n#if BITS_PER_LONG == 64\n#define NFT_PIPAPO_MAP_TOBITS\t\t32\n#else\n#define NFT_PIPAPO_MAP_TOBITS\t\t(BITS_PER_LONG - NFT_PIPAPO_MAP_NBITS)\n#endif\n\n \n#define NFT_PIPAPO_RULE0_MAX\t\t((1UL << (NFT_PIPAPO_MAP_TOBITS - 1)) \\\n\t\t\t\t\t- (1UL << NFT_PIPAPO_MAP_NBITS))\n\n \n#ifdef NFT_PIPAPO_ALIGN\n#define NFT_PIPAPO_ALIGN_HEADROOM\t\t\t\t\t\\\n\t(NFT_PIPAPO_ALIGN - ARCH_KMALLOC_MINALIGN)\n#define NFT_PIPAPO_LT_ALIGN(lt)\t\t(PTR_ALIGN((lt), NFT_PIPAPO_ALIGN))\n#define NFT_PIPAPO_LT_ASSIGN(field, x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t(field)->lt_aligned = NFT_PIPAPO_LT_ALIGN(x);\t\t\\\n\t\t(field)->lt = (x);\t\t\t\t\t\\\n\t} while (0)\n#else\n#define NFT_PIPAPO_ALIGN_HEADROOM\t0\n#define NFT_PIPAPO_LT_ALIGN(lt)\t\t(lt)\n#define NFT_PIPAPO_LT_ASSIGN(field, x)\t((field)->lt = (x))\n#endif  \n\n#define nft_pipapo_for_each_field(field, index, match)\t\t\\\n\tfor ((field) = (match)->f, (index) = 0;\t\t\t\\\n\t     (index) < (match)->field_count;\t\t\t\\\n\t     (index)++, (field)++)\n\n \nunion nft_pipapo_map_bucket {\n\tstruct {\n#if BITS_PER_LONG == 64\n\t\tstatic_assert(NFT_PIPAPO_MAP_TOBITS <= 32);\n\t\tu32 to;\n\n\t\tstatic_assert(NFT_PIPAPO_MAP_NBITS <= 32);\n\t\tu32 n;\n#else\n\t\tunsigned long to:NFT_PIPAPO_MAP_TOBITS;\n\t\tunsigned long  n:NFT_PIPAPO_MAP_NBITS;\n#endif\n\t};\n\tstruct nft_pipapo_elem *e;\n};\n\n \nstruct nft_pipapo_field {\n\tint groups;\n\tunsigned long rules;\n\tsize_t bsize;\n\tint bb;\n#ifdef NFT_PIPAPO_ALIGN\n\tunsigned long *lt_aligned;\n#endif\n\tunsigned long *lt;\n\tunion nft_pipapo_map_bucket *mt;\n};\n\n \nstruct nft_pipapo_match {\n\tint field_count;\n#ifdef NFT_PIPAPO_ALIGN\n\tunsigned long * __percpu *scratch_aligned;\n#endif\n\tunsigned long * __percpu *scratch;\n\tsize_t bsize_max;\n\tstruct rcu_head rcu;\n\tstruct nft_pipapo_field f[] __counted_by(field_count);\n};\n\n \nstruct nft_pipapo {\n\tstruct nft_pipapo_match __rcu *match;\n\tstruct nft_pipapo_match *clone;\n\tint width;\n\tbool dirty;\n\tunsigned long last_gc;\n};\n\nstruct nft_pipapo_elem;\n\n \nstruct nft_pipapo_elem {\n\tstruct nft_set_ext ext;\n};\n\nint pipapo_refill(unsigned long *map, int len, int rules, unsigned long *dst,\n\t\t  union nft_pipapo_map_bucket *mt, bool match_only);\n\n \nstatic inline void pipapo_and_field_buckets_4bit(struct nft_pipapo_field *f,\n\t\t\t\t\t\t unsigned long *dst,\n\t\t\t\t\t\t const u8 *data)\n{\n\tunsigned long *lt = NFT_PIPAPO_LT_ALIGN(f->lt);\n\tint group;\n\n\tfor (group = 0; group < f->groups; group += BITS_PER_BYTE / 4, data++) {\n\t\tu8 v;\n\n\t\tv = *data >> 4;\n\t\t__bitmap_and(dst, dst, lt + v * f->bsize,\n\t\t\t     f->bsize * BITS_PER_LONG);\n\t\tlt += f->bsize * NFT_PIPAPO_BUCKETS(4);\n\n\t\tv = *data & 0x0f;\n\t\t__bitmap_and(dst, dst, lt + v * f->bsize,\n\t\t\t     f->bsize * BITS_PER_LONG);\n\t\tlt += f->bsize * NFT_PIPAPO_BUCKETS(4);\n\t}\n}\n\n \nstatic inline void pipapo_and_field_buckets_8bit(struct nft_pipapo_field *f,\n\t\t\t\t\t\t unsigned long *dst,\n\t\t\t\t\t\t const u8 *data)\n{\n\tunsigned long *lt = NFT_PIPAPO_LT_ALIGN(f->lt);\n\tint group;\n\n\tfor (group = 0; group < f->groups; group++, data++) {\n\t\t__bitmap_and(dst, dst, lt + *data * f->bsize,\n\t\t\t     f->bsize * BITS_PER_LONG);\n\t\tlt += f->bsize * NFT_PIPAPO_BUCKETS(8);\n\t}\n}\n\n \nstatic u64 pipapo_estimate_size(const struct nft_set_desc *desc)\n{\n\tunsigned long entry_size;\n\tu64 size;\n\tint i;\n\n\tfor (i = 0, entry_size = 0; i < desc->field_count; i++) {\n\t\tunsigned long rules;\n\n\t\tif (desc->field_len[i] > NFT_PIPAPO_MAX_BYTES)\n\t\t\treturn 0;\n\n\t\t \n\t\trules = ilog2(desc->field_len[i] * BITS_PER_BYTE) * 2;\n\t\tentry_size += rules *\n\t\t\t      NFT_PIPAPO_BUCKETS(NFT_PIPAPO_GROUP_BITS_INIT) /\n\t\t\t      BITS_PER_BYTE;\n\t\tentry_size += rules * sizeof(union nft_pipapo_map_bucket);\n\t}\n\n\t \n\tsize = desc->size * entry_size;\n\tif (size && div_u64(size, desc->size) != entry_size)\n\t\treturn 0;\n\n\tsize += sizeof(struct nft_pipapo) + sizeof(struct nft_pipapo_match) * 2;\n\n\tsize += sizeof(struct nft_pipapo_field) * desc->field_count;\n\n\treturn size;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}