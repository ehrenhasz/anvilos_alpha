{
  "module_name": "nf_conntrack_extend.c",
  "hash_id": "4af54a093fb9034aac8ad68ca9a9ac4324e7b5fe92aaee439569eb80c40ec3c0",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_extend.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/kmemleak.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <net/netfilter/nf_conntrack_extend.h>\n\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_acct.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/nf_conntrack_timestamp.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n#include <net/netfilter/nf_conntrack_labels.h>\n#include <net/netfilter/nf_conntrack_synproxy.h>\n#include <net/netfilter/nf_conntrack_act_ct.h>\n#include <net/netfilter/nf_nat.h>\n\n#define NF_CT_EXT_PREALLOC\t128u  \n\natomic_t nf_conntrack_ext_genid __read_mostly = ATOMIC_INIT(1);\n\nstatic const u8 nf_ct_ext_type_len[NF_CT_EXT_NUM] = {\n\t[NF_CT_EXT_HELPER] = sizeof(struct nf_conn_help),\n#if IS_ENABLED(CONFIG_NF_NAT)\n\t[NF_CT_EXT_NAT] = sizeof(struct nf_conn_nat),\n#endif\n\t[NF_CT_EXT_SEQADJ] = sizeof(struct nf_conn_seqadj),\n\t[NF_CT_EXT_ACCT] = sizeof(struct nf_conn_acct),\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\t[NF_CT_EXT_ECACHE] = sizeof(struct nf_conntrack_ecache),\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\n\t[NF_CT_EXT_TSTAMP] = sizeof(struct nf_conn_tstamp),\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\t[NF_CT_EXT_TIMEOUT] = sizeof(struct nf_conn_timeout),\n#endif\n#ifdef CONFIG_NF_CONNTRACK_LABELS\n\t[NF_CT_EXT_LABELS] = sizeof(struct nf_conn_labels),\n#endif\n#if IS_ENABLED(CONFIG_NETFILTER_SYNPROXY)\n\t[NF_CT_EXT_SYNPROXY] = sizeof(struct nf_conn_synproxy),\n#endif\n#if IS_ENABLED(CONFIG_NET_ACT_CT)\n\t[NF_CT_EXT_ACT_CT] = sizeof(struct nf_conn_act_ct_ext),\n#endif\n};\n\nstatic __always_inline unsigned int total_extension_size(void)\n{\n\t \n\tBUILD_BUG_ON(NF_CT_EXT_NUM > 10);\n\n\treturn sizeof(struct nf_ct_ext) +\n\t       sizeof(struct nf_conn_help)\n#if IS_ENABLED(CONFIG_NF_NAT)\n\t\t+ sizeof(struct nf_conn_nat)\n#endif\n\t\t+ sizeof(struct nf_conn_seqadj)\n\t\t+ sizeof(struct nf_conn_acct)\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\t\t+ sizeof(struct nf_conntrack_ecache)\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\n\t\t+ sizeof(struct nf_conn_tstamp)\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\t\t+ sizeof(struct nf_conn_timeout)\n#endif\n#ifdef CONFIG_NF_CONNTRACK_LABELS\n\t\t+ sizeof(struct nf_conn_labels)\n#endif\n#if IS_ENABLED(CONFIG_NETFILTER_SYNPROXY)\n\t\t+ sizeof(struct nf_conn_synproxy)\n#endif\n#if IS_ENABLED(CONFIG_NET_ACT_CT)\n\t\t+ sizeof(struct nf_conn_act_ct_ext)\n#endif\n\t;\n}\n\nvoid *nf_ct_ext_add(struct nf_conn *ct, enum nf_ct_ext_id id, gfp_t gfp)\n{\n\tunsigned int newlen, newoff, oldlen, alloc;\n\tstruct nf_ct_ext *new;\n\n\t \n\tWARN_ON(nf_ct_is_confirmed(ct));\n\n\t \n\tBUILD_BUG_ON(total_extension_size() > 255u);\n\n\tif (ct->ext) {\n\t\tconst struct nf_ct_ext *old = ct->ext;\n\n\t\tif (__nf_ct_ext_exist(old, id))\n\t\t\treturn NULL;\n\t\toldlen = old->len;\n\t} else {\n\t\toldlen = sizeof(*new);\n\t}\n\n\tnewoff = ALIGN(oldlen, __alignof__(struct nf_ct_ext));\n\tnewlen = newoff + nf_ct_ext_type_len[id];\n\n\talloc = max(newlen, NF_CT_EXT_PREALLOC);\n\tnew = krealloc(ct->ext, alloc, gfp);\n\tif (!new)\n\t\treturn NULL;\n\n\tif (!ct->ext) {\n\t\tmemset(new->offset, 0, sizeof(new->offset));\n\t\tnew->gen_id = atomic_read(&nf_conntrack_ext_genid);\n\t}\n\n\tnew->offset[id] = newoff;\n\tnew->len = newlen;\n\tmemset((void *)new + newoff, 0, newlen - newoff);\n\n\tct->ext = new;\n\treturn (void *)new + newoff;\n}\nEXPORT_SYMBOL(nf_ct_ext_add);\n\n \nvoid *__nf_ct_ext_find(const struct nf_ct_ext *ext, u8 id)\n{\n\tunsigned int gen_id = atomic_read(&nf_conntrack_ext_genid);\n\tunsigned int this_id = READ_ONCE(ext->gen_id);\n\n\tif (!__nf_ct_ext_exist(ext, id))\n\t\treturn NULL;\n\n\tif (this_id == 0 || ext->gen_id == gen_id)\n\t\treturn (void *)ext + ext->offset[id];\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(__nf_ct_ext_find);\n\nvoid nf_ct_ext_bump_genid(void)\n{\n\tunsigned int value = atomic_inc_return(&nf_conntrack_ext_genid);\n\n\tif (value == UINT_MAX)\n\t\tatomic_set(&nf_conntrack_ext_genid, 1);\n\n\tmsleep(HZ);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}