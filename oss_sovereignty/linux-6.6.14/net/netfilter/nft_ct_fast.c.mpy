{
  "module_name": "nft_ct_fast.c",
  "hash_id": "025b256eb16965e147b29d2c31619047c2390e441b76fee0105412302ffdf21e",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_ct_fast.c",
  "human_readable_source": "\n#if IS_ENABLED(CONFIG_NFT_CT)\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_conntrack.h>\n\nvoid nft_ct_get_fast_eval(const struct nft_expr *expr,\n\t\t\t  struct nft_regs *regs,\n\t\t\t  const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_ct *priv = nft_expr_priv(expr);\n\tu32 *dest = &regs->data[priv->dreg];\n\tenum ip_conntrack_info ctinfo;\n\tconst struct nf_conn *ct;\n\tunsigned int state;\n\n\tct = nf_ct_get(pkt->skb, &ctinfo);\n\n\tswitch (priv->key) {\n\tcase NFT_CT_STATE:\n\t\tif (ct)\n\t\t\tstate = NF_CT_STATE_BIT(ctinfo);\n\t\telse if (ctinfo == IP_CT_UNTRACKED)\n\t\t\tstate = NF_CT_STATE_UNTRACKED_BIT;\n\t\telse\n\t\t\tstate = NF_CT_STATE_INVALID_BIT;\n\t\t*dest = state;\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!ct) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tswitch (priv->key) {\n\tcase NFT_CT_DIRECTION:\n\t\tnft_reg_store8(dest, CTINFO2DIR(ctinfo));\n\t\treturn;\n\tcase NFT_CT_STATUS:\n\t\t*dest = ct->status;\n\t\treturn;\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\tcase NFT_CT_MARK:\n\t\t*dest = ct->mark;\n\t\treturn;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\n\tcase NFT_CT_SECMARK:\n\t\t*dest = ct->secmark;\n\t\treturn;\n#endif\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tregs->verdict.code = NFT_BREAK;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(nft_ct_get_fast_eval);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}