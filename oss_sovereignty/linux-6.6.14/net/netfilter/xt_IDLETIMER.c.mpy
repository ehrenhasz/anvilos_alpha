{
  "module_name": "xt_IDLETIMER.c",
  "hash_id": "bac467b9551e59f4b5f7e010d042ec1c24871631911c9d579e007c20a71dc543",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_IDLETIMER.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/alarmtimer.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_IDLETIMER.h>\n#include <linux/kdev_t.h>\n#include <linux/kobject.h>\n#include <linux/workqueue.h>\n#include <linux/sysfs.h>\n\nstruct idletimer_tg {\n\tstruct list_head entry;\n\tstruct alarm alarm;\n\tstruct timer_list timer;\n\tstruct work_struct work;\n\n\tstruct kobject *kobj;\n\tstruct device_attribute attr;\n\n\tunsigned int refcnt;\n\tu8 timer_type;\n};\n\nstatic LIST_HEAD(idletimer_tg_list);\nstatic DEFINE_MUTEX(list_mutex);\n\nstatic struct kobject *idletimer_tg_kobj;\n\nstatic\nstruct idletimer_tg *__idletimer_tg_find_by_label(const char *label)\n{\n\tstruct idletimer_tg *entry;\n\n\tlist_for_each_entry(entry, &idletimer_tg_list, entry) {\n\t\tif (!strcmp(label, entry->attr.attr.name))\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic ssize_t idletimer_tg_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct idletimer_tg *timer;\n\tunsigned long expires = 0;\n\tstruct timespec64 ktimespec = {};\n\tlong time_diff = 0;\n\n\tmutex_lock(&list_mutex);\n\n\ttimer =\t__idletimer_tg_find_by_label(attr->attr.name);\n\tif (timer) {\n\t\tif (timer->timer_type & XT_IDLETIMER_ALARM) {\n\t\t\tktime_t expires_alarm = alarm_expires_remaining(&timer->alarm);\n\t\t\tktimespec = ktime_to_timespec64(expires_alarm);\n\t\t\ttime_diff = ktimespec.tv_sec;\n\t\t} else {\n\t\t\texpires = timer->timer.expires;\n\t\t\ttime_diff = jiffies_to_msecs(expires - jiffies) / 1000;\n\t\t}\n\t}\n\n\tmutex_unlock(&list_mutex);\n\n\tif (time_after(expires, jiffies) || ktimespec.tv_sec > 0)\n\t\treturn sysfs_emit(buf, \"%ld\\n\", time_diff);\n\n\treturn sysfs_emit(buf, \"0\\n\");\n}\n\nstatic void idletimer_tg_work(struct work_struct *work)\n{\n\tstruct idletimer_tg *timer = container_of(work, struct idletimer_tg,\n\t\t\t\t\t\t  work);\n\n\tsysfs_notify(idletimer_tg_kobj, NULL, timer->attr.attr.name);\n}\n\nstatic void idletimer_tg_expired(struct timer_list *t)\n{\n\tstruct idletimer_tg *timer = from_timer(timer, t, timer);\n\n\tpr_debug(\"timer %s expired\\n\", timer->attr.attr.name);\n\n\tschedule_work(&timer->work);\n}\n\nstatic enum alarmtimer_restart idletimer_tg_alarmproc(struct alarm *alarm,\n\t\t\t\t\t\t\t  ktime_t now)\n{\n\tstruct idletimer_tg *timer = alarm->data;\n\n\tpr_debug(\"alarm %s expired\\n\", timer->attr.attr.name);\n\tschedule_work(&timer->work);\n\treturn ALARMTIMER_NORESTART;\n}\n\nstatic int idletimer_check_sysfs_name(const char *name, unsigned int size)\n{\n\tint ret;\n\n\tret = xt_check_proc_name(name, size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!strcmp(name, \"power\") ||\n\t    !strcmp(name, \"subsystem\") ||\n\t    !strcmp(name, \"uevent\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int idletimer_tg_create(struct idletimer_tg_info *info)\n{\n\tint ret;\n\n\tinfo->timer = kzalloc(sizeof(*info->timer), GFP_KERNEL);\n\tif (!info->timer) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = idletimer_check_sysfs_name(info->label, sizeof(info->label));\n\tif (ret < 0)\n\t\tgoto out_free_timer;\n\n\tsysfs_attr_init(&info->timer->attr.attr);\n\tinfo->timer->attr.attr.name = kstrdup(info->label, GFP_KERNEL);\n\tif (!info->timer->attr.attr.name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_timer;\n\t}\n\tinfo->timer->attr.attr.mode = 0444;\n\tinfo->timer->attr.show = idletimer_tg_show;\n\n\tret = sysfs_create_file(idletimer_tg_kobj, &info->timer->attr.attr);\n\tif (ret < 0) {\n\t\tpr_debug(\"couldn't add file to sysfs\");\n\t\tgoto out_free_attr;\n\t}\n\n\tlist_add(&info->timer->entry, &idletimer_tg_list);\n\n\ttimer_setup(&info->timer->timer, idletimer_tg_expired, 0);\n\tinfo->timer->refcnt = 1;\n\n\tINIT_WORK(&info->timer->work, idletimer_tg_work);\n\n\tmod_timer(&info->timer->timer,\n\t\t  msecs_to_jiffies(info->timeout * 1000) + jiffies);\n\n\treturn 0;\n\nout_free_attr:\n\tkfree(info->timer->attr.attr.name);\nout_free_timer:\n\tkfree(info->timer);\nout:\n\treturn ret;\n}\n\nstatic int idletimer_tg_create_v1(struct idletimer_tg_info_v1 *info)\n{\n\tint ret;\n\n\tinfo->timer = kmalloc(sizeof(*info->timer), GFP_KERNEL);\n\tif (!info->timer) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = idletimer_check_sysfs_name(info->label, sizeof(info->label));\n\tif (ret < 0)\n\t\tgoto out_free_timer;\n\n\tsysfs_attr_init(&info->timer->attr.attr);\n\tinfo->timer->attr.attr.name = kstrdup(info->label, GFP_KERNEL);\n\tif (!info->timer->attr.attr.name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_timer;\n\t}\n\tinfo->timer->attr.attr.mode = 0444;\n\tinfo->timer->attr.show = idletimer_tg_show;\n\n\tret = sysfs_create_file(idletimer_tg_kobj, &info->timer->attr.attr);\n\tif (ret < 0) {\n\t\tpr_debug(\"couldn't add file to sysfs\");\n\t\tgoto out_free_attr;\n\t}\n\n\t \n\tkobject_uevent(idletimer_tg_kobj,KOBJ_ADD);\n\n\tlist_add(&info->timer->entry, &idletimer_tg_list);\n\tpr_debug(\"timer type value is %u\", info->timer_type);\n\tinfo->timer->timer_type = info->timer_type;\n\tinfo->timer->refcnt = 1;\n\n\tINIT_WORK(&info->timer->work, idletimer_tg_work);\n\n\tif (info->timer->timer_type & XT_IDLETIMER_ALARM) {\n\t\tktime_t tout;\n\t\talarm_init(&info->timer->alarm, ALARM_BOOTTIME,\n\t\t\t   idletimer_tg_alarmproc);\n\t\tinfo->timer->alarm.data = info->timer;\n\t\ttout = ktime_set(info->timeout, 0);\n\t\talarm_start_relative(&info->timer->alarm, tout);\n\t} else {\n\t\ttimer_setup(&info->timer->timer, idletimer_tg_expired, 0);\n\t\tmod_timer(&info->timer->timer,\n\t\t\t\tmsecs_to_jiffies(info->timeout * 1000) + jiffies);\n\t}\n\n\treturn 0;\n\nout_free_attr:\n\tkfree(info->timer->attr.attr.name);\nout_free_timer:\n\tkfree(info->timer);\nout:\n\treturn ret;\n}\n\n \nstatic unsigned int idletimer_tg_target(struct sk_buff *skb,\n\t\t\t\t\t const struct xt_action_param *par)\n{\n\tconst struct idletimer_tg_info *info = par->targinfo;\n\n\tpr_debug(\"resetting timer %s, timeout period %u\\n\",\n\t\t info->label, info->timeout);\n\n\tmod_timer(&info->timer->timer,\n\t\t  msecs_to_jiffies(info->timeout * 1000) + jiffies);\n\n\treturn XT_CONTINUE;\n}\n\n \nstatic unsigned int idletimer_tg_target_v1(struct sk_buff *skb,\n\t\t\t\t\t const struct xt_action_param *par)\n{\n\tconst struct idletimer_tg_info_v1 *info = par->targinfo;\n\n\tpr_debug(\"resetting timer %s, timeout period %u\\n\",\n\t\t info->label, info->timeout);\n\n\tif (info->timer->timer_type & XT_IDLETIMER_ALARM) {\n\t\tktime_t tout = ktime_set(info->timeout, 0);\n\t\talarm_start_relative(&info->timer->alarm, tout);\n\t} else {\n\t\tmod_timer(&info->timer->timer,\n\t\t\t\tmsecs_to_jiffies(info->timeout * 1000) + jiffies);\n\t}\n\n\treturn XT_CONTINUE;\n}\n\nstatic int idletimer_tg_helper(struct idletimer_tg_info *info)\n{\n\tif (info->timeout == 0) {\n\t\tpr_debug(\"timeout value is zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (info->timeout >= INT_MAX / 1000) {\n\t\tpr_debug(\"timeout value is too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (info->label[0] == '\\0' ||\n\t    strnlen(info->label,\n\t\t    MAX_IDLETIMER_LABEL_SIZE) == MAX_IDLETIMER_LABEL_SIZE) {\n\t\tpr_debug(\"label is empty or not nul-terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\nstatic int idletimer_tg_checkentry(const struct xt_tgchk_param *par)\n{\n\tstruct idletimer_tg_info *info = par->targinfo;\n\tint ret;\n\n\tpr_debug(\"checkentry targinfo%s\\n\", info->label);\n\n\tret = idletimer_tg_helper(info);\n\tif(ret < 0)\n\t{\n\t\tpr_debug(\"checkentry helper return invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&list_mutex);\n\n\tinfo->timer = __idletimer_tg_find_by_label(info->label);\n\tif (info->timer) {\n\t\tinfo->timer->refcnt++;\n\t\tmod_timer(&info->timer->timer,\n\t\t\t  msecs_to_jiffies(info->timeout * 1000) + jiffies);\n\n\t\tpr_debug(\"increased refcnt of timer %s to %u\\n\",\n\t\t\t info->label, info->timer->refcnt);\n\t} else {\n\t\tret = idletimer_tg_create(info);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"failed to create timer\\n\");\n\t\t\tmutex_unlock(&list_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_unlock(&list_mutex);\n\treturn 0;\n}\n\nstatic int idletimer_tg_checkentry_v1(const struct xt_tgchk_param *par)\n{\n\tstruct idletimer_tg_info_v1 *info = par->targinfo;\n\tint ret;\n\n\tpr_debug(\"checkentry targinfo%s\\n\", info->label);\n\n\tif (info->send_nl_msg)\n\t\treturn -EOPNOTSUPP;\n\n\tret = idletimer_tg_helper((struct idletimer_tg_info *)info);\n\tif(ret < 0)\n\t{\n\t\tpr_debug(\"checkentry helper return invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->timer_type > XT_IDLETIMER_ALARM) {\n\t\tpr_debug(\"invalid value for timer type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&list_mutex);\n\n\tinfo->timer = __idletimer_tg_find_by_label(info->label);\n\tif (info->timer) {\n\t\tif (info->timer->timer_type != info->timer_type) {\n\t\t\tpr_debug(\"Adding/Replacing rule with same label and different timer type is not allowed\\n\");\n\t\t\tmutex_unlock(&list_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo->timer->refcnt++;\n\t\tif (info->timer_type & XT_IDLETIMER_ALARM) {\n\t\t\t \n\t\t\tktime_t tout = alarm_expires_remaining(&info->timer->alarm);\n\t\t\tstruct timespec64 ktimespec = ktime_to_timespec64(tout);\n\n\t\t\tif (ktimespec.tv_sec > 0) {\n\t\t\t\tpr_debug(\"time_expiry_remaining %lld\\n\",\n\t\t\t\t\t ktimespec.tv_sec);\n\t\t\t\talarm_start_relative(&info->timer->alarm, tout);\n\t\t\t}\n\t\t} else {\n\t\t\t\tmod_timer(&info->timer->timer,\n\t\t\t\t\tmsecs_to_jiffies(info->timeout * 1000) + jiffies);\n\t\t}\n\t\tpr_debug(\"increased refcnt of timer %s to %u\\n\",\n\t\t\t info->label, info->timer->refcnt);\n\t} else {\n\t\tret = idletimer_tg_create_v1(info);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"failed to create timer\\n\");\n\t\t\tmutex_unlock(&list_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_unlock(&list_mutex);\n\treturn 0;\n}\n\nstatic void idletimer_tg_destroy(const struct xt_tgdtor_param *par)\n{\n\tconst struct idletimer_tg_info *info = par->targinfo;\n\n\tpr_debug(\"destroy targinfo %s\\n\", info->label);\n\n\tmutex_lock(&list_mutex);\n\n\tif (--info->timer->refcnt == 0) {\n\t\tpr_debug(\"deleting timer %s\\n\", info->label);\n\n\t\tlist_del(&info->timer->entry);\n\t\ttimer_shutdown_sync(&info->timer->timer);\n\t\tcancel_work_sync(&info->timer->work);\n\t\tsysfs_remove_file(idletimer_tg_kobj, &info->timer->attr.attr);\n\t\tkfree(info->timer->attr.attr.name);\n\t\tkfree(info->timer);\n\t} else {\n\t\tpr_debug(\"decreased refcnt of timer %s to %u\\n\",\n\t\t\t info->label, info->timer->refcnt);\n\t}\n\n\tmutex_unlock(&list_mutex);\n}\n\nstatic void idletimer_tg_destroy_v1(const struct xt_tgdtor_param *par)\n{\n\tconst struct idletimer_tg_info_v1 *info = par->targinfo;\n\n\tpr_debug(\"destroy targinfo %s\\n\", info->label);\n\n\tmutex_lock(&list_mutex);\n\n\tif (--info->timer->refcnt == 0) {\n\t\tpr_debug(\"deleting timer %s\\n\", info->label);\n\n\t\tlist_del(&info->timer->entry);\n\t\tif (info->timer->timer_type & XT_IDLETIMER_ALARM) {\n\t\t\talarm_cancel(&info->timer->alarm);\n\t\t} else {\n\t\t\ttimer_shutdown_sync(&info->timer->timer);\n\t\t}\n\t\tcancel_work_sync(&info->timer->work);\n\t\tsysfs_remove_file(idletimer_tg_kobj, &info->timer->attr.attr);\n\t\tkfree(info->timer->attr.attr.name);\n\t\tkfree(info->timer);\n\t} else {\n\t\tpr_debug(\"decreased refcnt of timer %s to %u\\n\",\n\t\t\t info->label, info->timer->refcnt);\n\t}\n\n\tmutex_unlock(&list_mutex);\n}\n\n\nstatic struct xt_target idletimer_tg[] __read_mostly = {\n\t{\n\t.name\t\t= \"IDLETIMER\",\n\t.family\t\t= NFPROTO_UNSPEC,\n\t.target\t\t= idletimer_tg_target,\n\t.targetsize     = sizeof(struct idletimer_tg_info),\n\t.usersize\t= offsetof(struct idletimer_tg_info, timer),\n\t.checkentry\t= idletimer_tg_checkentry,\n\t.destroy        = idletimer_tg_destroy,\n\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t.name\t\t= \"IDLETIMER\",\n\t.family\t\t= NFPROTO_UNSPEC,\n\t.revision\t= 1,\n\t.target\t\t= idletimer_tg_target_v1,\n\t.targetsize     = sizeof(struct idletimer_tg_info_v1),\n\t.usersize\t= offsetof(struct idletimer_tg_info_v1, timer),\n\t.checkentry\t= idletimer_tg_checkentry_v1,\n\t.destroy        = idletimer_tg_destroy_v1,\n\t.me\t\t= THIS_MODULE,\n\t},\n\n\n};\n\nstatic struct class *idletimer_tg_class;\n\nstatic struct device *idletimer_tg_device;\n\nstatic int __init idletimer_tg_init(void)\n{\n\tint err;\n\n\tidletimer_tg_class = class_create(\"xt_idletimer\");\n\terr = PTR_ERR(idletimer_tg_class);\n\tif (IS_ERR(idletimer_tg_class)) {\n\t\tpr_debug(\"couldn't register device class\\n\");\n\t\tgoto out;\n\t}\n\n\tidletimer_tg_device = device_create(idletimer_tg_class, NULL,\n\t\t\t\t\t    MKDEV(0, 0), NULL, \"timers\");\n\terr = PTR_ERR(idletimer_tg_device);\n\tif (IS_ERR(idletimer_tg_device)) {\n\t\tpr_debug(\"couldn't register system device\\n\");\n\t\tgoto out_class;\n\t}\n\n\tidletimer_tg_kobj = &idletimer_tg_device->kobj;\n\n\terr = xt_register_targets(idletimer_tg, ARRAY_SIZE(idletimer_tg));\n\n\tif (err < 0) {\n\t\tpr_debug(\"couldn't register xt target\\n\");\n\t\tgoto out_dev;\n\t}\n\n\treturn 0;\nout_dev:\n\tdevice_destroy(idletimer_tg_class, MKDEV(0, 0));\nout_class:\n\tclass_destroy(idletimer_tg_class);\nout:\n\treturn err;\n}\n\nstatic void __exit idletimer_tg_exit(void)\n{\n\txt_unregister_targets(idletimer_tg, ARRAY_SIZE(idletimer_tg));\n\n\tdevice_destroy(idletimer_tg_class, MKDEV(0, 0));\n\tclass_destroy(idletimer_tg_class);\n}\n\nmodule_init(idletimer_tg_init);\nmodule_exit(idletimer_tg_exit);\n\nMODULE_AUTHOR(\"Timo Teras <ext-timo.teras@nokia.com>\");\nMODULE_AUTHOR(\"Luciano Coelho <luciano.coelho@nokia.com>\");\nMODULE_DESCRIPTION(\"Xtables: idle time monitor\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"ipt_IDLETIMER\");\nMODULE_ALIAS(\"ip6t_IDLETIMER\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}