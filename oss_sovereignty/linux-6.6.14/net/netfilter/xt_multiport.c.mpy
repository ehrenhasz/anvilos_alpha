{
  "module_name": "xt_multiport.c",
  "hash_id": "c6e9277ac2b3f27acaa510e422d067d104c5c84ce7bfc5a8996880fd4923ffd3",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_multiport.c",
  "human_readable_source": "\n \n\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/udp.h>\n#include <linux/skbuff.h>\n#include <linux/in.h>\n\n#include <linux/netfilter/xt_multiport.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Netfilter Core Team <coreteam@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: multiple port matching for TCP, UDP, UDP-Lite, SCTP and DCCP\");\nMODULE_ALIAS(\"ipt_multiport\");\nMODULE_ALIAS(\"ip6t_multiport\");\n\n \nstatic inline bool\nports_match_v1(const struct xt_multiport_v1 *minfo,\n\t       u_int16_t src, u_int16_t dst)\n{\n\tunsigned int i;\n\tu_int16_t s, e;\n\n\tfor (i = 0; i < minfo->count; i++) {\n\t\ts = minfo->ports[i];\n\n\t\tif (minfo->pflags[i]) {\n\t\t\t \n\t\t\te = minfo->ports[++i];\n\t\t\tpr_debug(\"src or dst matches with %d-%d?\\n\", s, e);\n\n\t\t\tswitch (minfo->flags) {\n\t\t\tcase XT_MULTIPORT_SOURCE:\n\t\t\t\tif (src >= s && src <= e)\n\t\t\t\t\treturn true ^ minfo->invert;\n\t\t\t\tbreak;\n\t\t\tcase XT_MULTIPORT_DESTINATION:\n\t\t\t\tif (dst >= s && dst <= e)\n\t\t\t\t\treturn true ^ minfo->invert;\n\t\t\t\tbreak;\n\t\t\tcase XT_MULTIPORT_EITHER:\n\t\t\t\tif ((dst >= s && dst <= e) ||\n\t\t\t\t    (src >= s && src <= e))\n\t\t\t\t\treturn true ^ minfo->invert;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tpr_debug(\"src or dst matches with %d?\\n\", s);\n\n\t\t\tswitch (minfo->flags) {\n\t\t\tcase XT_MULTIPORT_SOURCE:\n\t\t\t\tif (src == s)\n\t\t\t\t\treturn true ^ minfo->invert;\n\t\t\t\tbreak;\n\t\t\tcase XT_MULTIPORT_DESTINATION:\n\t\t\t\tif (dst == s)\n\t\t\t\t\treturn true ^ minfo->invert;\n\t\t\t\tbreak;\n\t\t\tcase XT_MULTIPORT_EITHER:\n\t\t\t\tif (src == s || dst == s)\n\t\t\t\t\treturn true ^ minfo->invert;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn minfo->invert;\n}\n\nstatic bool\nmultiport_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst __be16 *pptr;\n\t__be16 _ports[2];\n\tconst struct xt_multiport_v1 *multiinfo = par->matchinfo;\n\n\tif (par->fragoff != 0)\n\t\treturn false;\n\n\tpptr = skb_header_pointer(skb, par->thoff, sizeof(_ports), _ports);\n\tif (pptr == NULL) {\n\t\t \n\t\tpr_debug(\"Dropping evil offset=0 tinygram.\\n\");\n\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\treturn ports_match_v1(multiinfo, ntohs(pptr[0]), ntohs(pptr[1]));\n}\n\nstatic inline bool\ncheck(u_int16_t proto,\n      u_int8_t ip_invflags,\n      u_int8_t match_flags,\n      u_int8_t count)\n{\n\t \n\treturn (proto == IPPROTO_TCP || proto == IPPROTO_UDP\n\t\t|| proto == IPPROTO_UDPLITE\n\t\t|| proto == IPPROTO_SCTP || proto == IPPROTO_DCCP)\n\t\t&& !(ip_invflags & XT_INV_PROTO)\n\t\t&& (match_flags == XT_MULTIPORT_SOURCE\n\t\t    || match_flags == XT_MULTIPORT_DESTINATION\n\t\t    || match_flags == XT_MULTIPORT_EITHER)\n\t\t&& count <= XT_MULTI_PORTS;\n}\n\nstatic int multiport_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ipt_ip *ip = par->entryinfo;\n\tconst struct xt_multiport_v1 *multiinfo = par->matchinfo;\n\n\treturn check(ip->proto, ip->invflags, multiinfo->flags,\n\t\t     multiinfo->count) ? 0 : -EINVAL;\n}\n\nstatic int multiport_mt6_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ip6t_ip6 *ip = par->entryinfo;\n\tconst struct xt_multiport_v1 *multiinfo = par->matchinfo;\n\n\treturn check(ip->proto, ip->invflags, multiinfo->flags,\n\t\t     multiinfo->count) ? 0 : -EINVAL;\n}\n\nstatic struct xt_match multiport_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"multiport\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.revision\t= 1,\n\t\t.checkentry\t= multiport_mt_check,\n\t\t.match\t\t= multiport_mt,\n\t\t.matchsize\t= sizeof(struct xt_multiport_v1),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"multiport\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.revision\t= 1,\n\t\t.checkentry\t= multiport_mt6_check,\n\t\t.match\t\t= multiport_mt,\n\t\t.matchsize\t= sizeof(struct xt_multiport_v1),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init multiport_mt_init(void)\n{\n\treturn xt_register_matches(multiport_mt_reg,\n\t       ARRAY_SIZE(multiport_mt_reg));\n}\n\nstatic void __exit multiport_mt_exit(void)\n{\n\txt_unregister_matches(multiport_mt_reg, ARRAY_SIZE(multiport_mt_reg));\n}\n\nmodule_init(multiport_mt_init);\nmodule_exit(multiport_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}