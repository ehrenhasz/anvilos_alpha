{
  "module_name": "nft_set_bitmap.c",
  "hash_id": "a2ac5ebf521814036d10b91d34fb4f868b8348fee1f3b4c48358f1f347c32ed9",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_set_bitmap.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n\nstruct nft_bitmap_elem {\n\tstruct list_head\thead;\n\tstruct nft_set_ext\text;\n};\n\n \nstruct nft_bitmap {\n\tstruct\tlist_head\tlist;\n\tu16\t\t\tbitmap_size;\n\tu8\t\t\tbitmap[];\n};\n\nstatic inline void nft_bitmap_location(const struct nft_set *set,\n\t\t\t\t       const void *key,\n\t\t\t\t       u32 *idx, u32 *off)\n{\n\tu32 k;\n\n\tif (set->klen == 2)\n\t\tk = *(u16 *)key;\n\telse\n\t\tk = *(u8 *)key;\n\tk <<= 1;\n\n\t*idx = k / BITS_PER_BYTE;\n\t*off = k % BITS_PER_BYTE;\n}\n\n \nstatic inline bool\nnft_bitmap_active(const u8 *bitmap, u32 idx, u32 off, u8 genmask)\n{\n\treturn (bitmap[idx] & (0x3 << off)) & (genmask << off);\n}\n\nINDIRECT_CALLABLE_SCOPE\nbool nft_bitmap_lookup(const struct net *net, const struct nft_set *set,\n\t\t       const u32 *key, const struct nft_set_ext **ext)\n{\n\tconst struct nft_bitmap *priv = nft_set_priv(set);\n\tu8 genmask = nft_genmask_cur(net);\n\tu32 idx, off;\n\n\tnft_bitmap_location(set, key, &idx, &off);\n\n\treturn nft_bitmap_active(priv->bitmap, idx, off, genmask);\n}\n\nstatic struct nft_bitmap_elem *\nnft_bitmap_elem_find(const struct nft_set *set, struct nft_bitmap_elem *this,\n\t\t     u8 genmask)\n{\n\tconst struct nft_bitmap *priv = nft_set_priv(set);\n\tstruct nft_bitmap_elem *be;\n\n\tlist_for_each_entry_rcu(be, &priv->list, head) {\n\t\tif (memcmp(nft_set_ext_key(&be->ext),\n\t\t\t   nft_set_ext_key(&this->ext), set->klen) ||\n\t\t    !nft_set_elem_active(&be->ext, genmask))\n\t\t\tcontinue;\n\n\t\treturn be;\n\t}\n\treturn NULL;\n}\n\nstatic void *nft_bitmap_get(const struct net *net, const struct nft_set *set,\n\t\t\t    const struct nft_set_elem *elem, unsigned int flags)\n{\n\tconst struct nft_bitmap *priv = nft_set_priv(set);\n\tu8 genmask = nft_genmask_cur(net);\n\tstruct nft_bitmap_elem *be;\n\n\tlist_for_each_entry_rcu(be, &priv->list, head) {\n\t\tif (memcmp(nft_set_ext_key(&be->ext), elem->key.val.data, set->klen) ||\n\t\t    !nft_set_elem_active(&be->ext, genmask))\n\t\t\tcontinue;\n\n\t\treturn be;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic int nft_bitmap_insert(const struct net *net, const struct nft_set *set,\n\t\t\t     const struct nft_set_elem *elem,\n\t\t\t     struct nft_set_ext **ext)\n{\n\tstruct nft_bitmap *priv = nft_set_priv(set);\n\tstruct nft_bitmap_elem *new = elem->priv, *be;\n\tu8 genmask = nft_genmask_next(net);\n\tu32 idx, off;\n\n\tbe = nft_bitmap_elem_find(set, new, genmask);\n\tif (be) {\n\t\t*ext = &be->ext;\n\t\treturn -EEXIST;\n\t}\n\n\tnft_bitmap_location(set, nft_set_ext_key(&new->ext), &idx, &off);\n\t \n\tpriv->bitmap[idx] |= (genmask << off);\n\tlist_add_tail_rcu(&new->head, &priv->list);\n\n\treturn 0;\n}\n\nstatic void nft_bitmap_remove(const struct net *net,\n\t\t\t      const struct nft_set *set,\n\t\t\t      const struct nft_set_elem *elem)\n{\n\tstruct nft_bitmap *priv = nft_set_priv(set);\n\tstruct nft_bitmap_elem *be = elem->priv;\n\tu8 genmask = nft_genmask_next(net);\n\tu32 idx, off;\n\n\tnft_bitmap_location(set, nft_set_ext_key(&be->ext), &idx, &off);\n\t \n\tpriv->bitmap[idx] &= ~(genmask << off);\n\tlist_del_rcu(&be->head);\n}\n\nstatic void nft_bitmap_activate(const struct net *net,\n\t\t\t\tconst struct nft_set *set,\n\t\t\t\tconst struct nft_set_elem *elem)\n{\n\tstruct nft_bitmap *priv = nft_set_priv(set);\n\tstruct nft_bitmap_elem *be = elem->priv;\n\tu8 genmask = nft_genmask_next(net);\n\tu32 idx, off;\n\n\tnft_bitmap_location(set, nft_set_ext_key(&be->ext), &idx, &off);\n\t \n\tpriv->bitmap[idx] |= (genmask << off);\n\tnft_set_elem_change_active(net, set, &be->ext);\n}\n\nstatic bool nft_bitmap_flush(const struct net *net,\n\t\t\t     const struct nft_set *set, void *_be)\n{\n\tstruct nft_bitmap *priv = nft_set_priv(set);\n\tu8 genmask = nft_genmask_next(net);\n\tstruct nft_bitmap_elem *be = _be;\n\tu32 idx, off;\n\n\tnft_bitmap_location(set, nft_set_ext_key(&be->ext), &idx, &off);\n\t \n\tpriv->bitmap[idx] &= ~(genmask << off);\n\tnft_set_elem_change_active(net, set, &be->ext);\n\n\treturn true;\n}\n\nstatic void *nft_bitmap_deactivate(const struct net *net,\n\t\t\t\t   const struct nft_set *set,\n\t\t\t\t   const struct nft_set_elem *elem)\n{\n\tstruct nft_bitmap *priv = nft_set_priv(set);\n\tstruct nft_bitmap_elem *this = elem->priv, *be;\n\tu8 genmask = nft_genmask_next(net);\n\tu32 idx, off;\n\n\tnft_bitmap_location(set, elem->key.val.data, &idx, &off);\n\n\tbe = nft_bitmap_elem_find(set, this, genmask);\n\tif (!be)\n\t\treturn NULL;\n\n\t \n\tpriv->bitmap[idx] &= ~(genmask << off);\n\tnft_set_elem_change_active(net, set, &be->ext);\n\n\treturn be;\n}\n\nstatic void nft_bitmap_walk(const struct nft_ctx *ctx,\n\t\t\t    struct nft_set *set,\n\t\t\t    struct nft_set_iter *iter)\n{\n\tconst struct nft_bitmap *priv = nft_set_priv(set);\n\tstruct nft_bitmap_elem *be;\n\tstruct nft_set_elem elem;\n\n\tlist_for_each_entry_rcu(be, &priv->list, head) {\n\t\tif (iter->count < iter->skip)\n\t\t\tgoto cont;\n\t\tif (!nft_set_elem_active(&be->ext, iter->genmask))\n\t\t\tgoto cont;\n\n\t\telem.priv = be;\n\n\t\titer->err = iter->fn(ctx, set, iter, &elem);\n\n\t\tif (iter->err < 0)\n\t\t\treturn;\ncont:\n\t\titer->count++;\n\t}\n}\n\n \nstatic inline u32 nft_bitmap_size(u32 klen)\n{\n\treturn ((2 << ((klen * BITS_PER_BYTE) - 1)) / BITS_PER_BYTE) << 1;\n}\n\nstatic inline u64 nft_bitmap_total_size(u32 klen)\n{\n\treturn sizeof(struct nft_bitmap) + nft_bitmap_size(klen);\n}\n\nstatic u64 nft_bitmap_privsize(const struct nlattr * const nla[],\n\t\t\t       const struct nft_set_desc *desc)\n{\n\tu32 klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));\n\n\treturn nft_bitmap_total_size(klen);\n}\n\nstatic int nft_bitmap_init(const struct nft_set *set,\n\t\t\t   const struct nft_set_desc *desc,\n\t\t\t   const struct nlattr * const nla[])\n{\n\tstruct nft_bitmap *priv = nft_set_priv(set);\n\n\tINIT_LIST_HEAD(&priv->list);\n\tpriv->bitmap_size = nft_bitmap_size(set->klen);\n\n\treturn 0;\n}\n\nstatic void nft_bitmap_destroy(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_set *set)\n{\n\tstruct nft_bitmap *priv = nft_set_priv(set);\n\tstruct nft_bitmap_elem *be, *n;\n\n\tlist_for_each_entry_safe(be, n, &priv->list, head)\n\t\tnf_tables_set_elem_destroy(ctx, set, be);\n}\n\nstatic bool nft_bitmap_estimate(const struct nft_set_desc *desc, u32 features,\n\t\t\t\tstruct nft_set_estimate *est)\n{\n\t \n\tif (desc->klen > 2)\n\t\treturn false;\n\telse if (desc->expr)\n\t\treturn false;\n\n\test->size   = nft_bitmap_total_size(desc->klen);\n\test->lookup = NFT_SET_CLASS_O_1;\n\test->space  = NFT_SET_CLASS_O_1;\n\n\treturn true;\n}\n\nconst struct nft_set_type nft_set_bitmap_type = {\n\t.ops\t\t= {\n\t\t.privsize\t= nft_bitmap_privsize,\n\t\t.elemsize\t= offsetof(struct nft_bitmap_elem, ext),\n\t\t.estimate\t= nft_bitmap_estimate,\n\t\t.init\t\t= nft_bitmap_init,\n\t\t.destroy\t= nft_bitmap_destroy,\n\t\t.insert\t\t= nft_bitmap_insert,\n\t\t.remove\t\t= nft_bitmap_remove,\n\t\t.deactivate\t= nft_bitmap_deactivate,\n\t\t.flush\t\t= nft_bitmap_flush,\n\t\t.activate\t= nft_bitmap_activate,\n\t\t.lookup\t\t= nft_bitmap_lookup,\n\t\t.walk\t\t= nft_bitmap_walk,\n\t\t.get\t\t= nft_bitmap_get,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}