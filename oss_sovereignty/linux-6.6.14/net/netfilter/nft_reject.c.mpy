{
  "module_name": "nft_reject.c",
  "hash_id": "5cf6ca2bd88f8972f1541a2e3aef99c1a8b41f6e832d8b2f3481e59e11d10d8f",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_reject.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nft_reject.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n\nconst struct nla_policy nft_reject_policy[NFTA_REJECT_MAX + 1] = {\n\t[NFTA_REJECT_TYPE]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_REJECT_ICMP_CODE]\t\t= { .type = NLA_U8 },\n};\nEXPORT_SYMBOL_GPL(nft_reject_policy);\n\nint nft_reject_validate(const struct nft_ctx *ctx,\n\t\t\tconst struct nft_expr *expr,\n\t\t\tconst struct nft_data **data)\n{\n\treturn nft_chain_validate_hooks(ctx->chain,\n\t\t\t\t\t(1 << NF_INET_LOCAL_IN) |\n\t\t\t\t\t(1 << NF_INET_FORWARD) |\n\t\t\t\t\t(1 << NF_INET_LOCAL_OUT) |\n\t\t\t\t\t(1 << NF_INET_PRE_ROUTING));\n}\nEXPORT_SYMBOL_GPL(nft_reject_validate);\n\nint nft_reject_init(const struct nft_ctx *ctx,\n\t\t    const struct nft_expr *expr,\n\t\t    const struct nlattr * const tb[])\n{\n\tstruct nft_reject *priv = nft_expr_priv(expr);\n\tint icmp_code;\n\n\tif (tb[NFTA_REJECT_TYPE] == NULL)\n\t\treturn -EINVAL;\n\n\tpriv->type = ntohl(nla_get_be32(tb[NFTA_REJECT_TYPE]));\n\tswitch (priv->type) {\n\tcase NFT_REJECT_ICMP_UNREACH:\n\tcase NFT_REJECT_ICMPX_UNREACH:\n\t\tif (tb[NFTA_REJECT_ICMP_CODE] == NULL)\n\t\t\treturn -EINVAL;\n\n\t\ticmp_code = nla_get_u8(tb[NFTA_REJECT_ICMP_CODE]);\n\t\tif (priv->type == NFT_REJECT_ICMPX_UNREACH &&\n\t\t    icmp_code > NFT_REJECT_ICMPX_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tpriv->icmp_code = icmp_code;\n\t\tbreak;\n\tcase NFT_REJECT_TCP_RST:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_reject_init);\n\nint nft_reject_dump(struct sk_buff *skb,\n\t\t    const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_reject *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_REJECT_TYPE, htonl(priv->type)))\n\t\tgoto nla_put_failure;\n\n\tswitch (priv->type) {\n\tcase NFT_REJECT_ICMP_UNREACH:\n\tcase NFT_REJECT_ICMPX_UNREACH:\n\t\tif (nla_put_u8(skb, NFTA_REJECT_ICMP_CODE, priv->icmp_code))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(nft_reject_dump);\n\nstatic u8 icmp_code_v4[NFT_REJECT_ICMPX_MAX + 1] = {\n\t[NFT_REJECT_ICMPX_NO_ROUTE]\t\t= ICMP_NET_UNREACH,\n\t[NFT_REJECT_ICMPX_PORT_UNREACH]\t\t= ICMP_PORT_UNREACH,\n\t[NFT_REJECT_ICMPX_HOST_UNREACH]\t\t= ICMP_HOST_UNREACH,\n\t[NFT_REJECT_ICMPX_ADMIN_PROHIBITED]\t= ICMP_PKT_FILTERED,\n};\n\nint nft_reject_icmp_code(u8 code)\n{\n\tif (WARN_ON_ONCE(code > NFT_REJECT_ICMPX_MAX))\n\t\treturn ICMP_NET_UNREACH;\n\n\treturn icmp_code_v4[code];\n}\n\nEXPORT_SYMBOL_GPL(nft_reject_icmp_code);\n\n\nstatic u8 icmp_code_v6[NFT_REJECT_ICMPX_MAX + 1] = {\n\t[NFT_REJECT_ICMPX_NO_ROUTE]\t\t= ICMPV6_NOROUTE,\n\t[NFT_REJECT_ICMPX_PORT_UNREACH]\t\t= ICMPV6_PORT_UNREACH,\n\t[NFT_REJECT_ICMPX_HOST_UNREACH]\t\t= ICMPV6_ADDR_UNREACH,\n\t[NFT_REJECT_ICMPX_ADMIN_PROHIBITED]\t= ICMPV6_ADM_PROHIBITED,\n};\n\nint nft_reject_icmpv6_code(u8 code)\n{\n\tif (WARN_ON_ONCE(code > NFT_REJECT_ICMPX_MAX))\n\t\treturn ICMPV6_NOROUTE;\n\n\treturn icmp_code_v6[code];\n}\n\nEXPORT_SYMBOL_GPL(nft_reject_icmpv6_code);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_DESCRIPTION(\"Netfilter x_tables over nftables module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}