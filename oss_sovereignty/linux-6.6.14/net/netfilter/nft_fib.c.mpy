{
  "module_name": "nft_fib.c",
  "hash_id": "3a5e5884791e6db00bf837d6248676ec1919aec93b3007f63fe0b1aa9dc45a6c",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_fib.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nft_fib.h>\n\n#define NFTA_FIB_F_ALL (NFTA_FIB_F_SADDR | NFTA_FIB_F_DADDR | \\\n\t\t\tNFTA_FIB_F_MARK | NFTA_FIB_F_IIF | NFTA_FIB_F_OIF | \\\n\t\t\tNFTA_FIB_F_PRESENT)\n\nconst struct nla_policy nft_fib_policy[NFTA_FIB_MAX + 1] = {\n\t[NFTA_FIB_DREG]\t\t= { .type = NLA_U32 },\n\t[NFTA_FIB_RESULT]\t= { .type = NLA_U32 },\n\t[NFTA_FIB_FLAGS]\t=\n\t\tNLA_POLICY_MASK(NLA_BE32, NFTA_FIB_F_ALL),\n};\nEXPORT_SYMBOL(nft_fib_policy);\n\nint nft_fib_validate(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t     const struct nft_data **data)\n{\n\tconst struct nft_fib *priv = nft_expr_priv(expr);\n\tunsigned int hooks;\n\n\tswitch (priv->result) {\n\tcase NFT_FIB_RESULT_OIF:\n\tcase NFT_FIB_RESULT_OIFNAME:\n\t\thooks = (1 << NF_INET_PRE_ROUTING);\n\t\tif (priv->flags & NFTA_FIB_F_IIF) {\n\t\t\thooks |= (1 << NF_INET_LOCAL_IN) |\n\t\t\t\t (1 << NF_INET_FORWARD);\n\t\t}\n\t\tbreak;\n\tcase NFT_FIB_RESULT_ADDRTYPE:\n\t\tif (priv->flags & NFTA_FIB_F_IIF)\n\t\t\thooks = (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t(1 << NF_INET_LOCAL_IN) |\n\t\t\t\t(1 << NF_INET_FORWARD);\n\t\telse if (priv->flags & NFTA_FIB_F_OIF)\n\t\t\thooks = (1 << NF_INET_LOCAL_OUT) |\n\t\t\t\t(1 << NF_INET_POST_ROUTING) |\n\t\t\t\t(1 << NF_INET_FORWARD);\n\t\telse\n\t\t\thooks = (1 << NF_INET_LOCAL_IN) |\n\t\t\t\t(1 << NF_INET_LOCAL_OUT) |\n\t\t\t\t(1 << NF_INET_FORWARD) |\n\t\t\t\t(1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t(1 << NF_INET_POST_ROUTING);\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\nEXPORT_SYMBOL_GPL(nft_fib_validate);\n\nint nft_fib_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t const struct nlattr * const tb[])\n{\n\tstruct nft_fib *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\tint err;\n\n\tif (!tb[NFTA_FIB_DREG] || !tb[NFTA_FIB_RESULT] || !tb[NFTA_FIB_FLAGS])\n\t\treturn -EINVAL;\n\n\tpriv->flags = ntohl(nla_get_be32(tb[NFTA_FIB_FLAGS]));\n\n\tif (priv->flags == 0)\n\t\treturn -EINVAL;\n\n\tif ((priv->flags & (NFTA_FIB_F_SADDR | NFTA_FIB_F_DADDR)) ==\n\t\t\t   (NFTA_FIB_F_SADDR | NFTA_FIB_F_DADDR))\n\t\treturn -EINVAL;\n\tif ((priv->flags & (NFTA_FIB_F_IIF | NFTA_FIB_F_OIF)) ==\n\t\t\t   (NFTA_FIB_F_IIF | NFTA_FIB_F_OIF))\n\t\treturn -EINVAL;\n\tif ((priv->flags & (NFTA_FIB_F_SADDR | NFTA_FIB_F_DADDR)) == 0)\n\t\treturn -EINVAL;\n\n\tpriv->result = ntohl(nla_get_be32(tb[NFTA_FIB_RESULT]));\n\n\tswitch (priv->result) {\n\tcase NFT_FIB_RESULT_OIF:\n\t\tif (priv->flags & NFTA_FIB_F_OIF)\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof(int);\n\t\tbreak;\n\tcase NFT_FIB_RESULT_OIFNAME:\n\t\tif (priv->flags & NFTA_FIB_F_OIF)\n\t\t\treturn -EINVAL;\n\t\tlen = IFNAMSIZ;\n\t\tbreak;\n\tcase NFT_FIB_RESULT_ADDRTYPE:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = nft_parse_register_store(ctx, tb[NFTA_FIB_DREG], &priv->dreg,\n\t\t\t\t       NULL, NFT_DATA_VALUE, len);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_fib_init);\n\nint nft_fib_dump(struct sk_buff *skb, const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_fib *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_FIB_DREG, priv->dreg))\n\t\treturn -1;\n\n\tif (nla_put_be32(skb, NFTA_FIB_RESULT, htonl(priv->result)))\n\t\treturn -1;\n\n\tif (nla_put_be32(skb, NFTA_FIB_FLAGS, htonl(priv->flags)))\n\t\treturn -1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_fib_dump);\n\nvoid nft_fib_store_result(void *reg, const struct nft_fib *priv,\n\t\t\t  const struct net_device *dev)\n{\n\tu32 *dreg = reg;\n\tint index;\n\n\tswitch (priv->result) {\n\tcase NFT_FIB_RESULT_OIF:\n\t\tindex = dev ? dev->ifindex : 0;\n\t\tif (priv->flags & NFTA_FIB_F_PRESENT)\n\t\t\tnft_reg_store8(dreg, !!index);\n\t\telse\n\t\t\t*dreg = index;\n\n\t\tbreak;\n\tcase NFT_FIB_RESULT_OIFNAME:\n\t\tif (priv->flags & NFTA_FIB_F_PRESENT)\n\t\t\tnft_reg_store8(dreg, !!dev);\n\t\telse\n\t\t\tstrscpy_pad(reg, dev ? dev->name : \"\", IFNAMSIZ);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\t*dreg = 0;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(nft_fib_store_result);\n\nbool nft_fib_reduce(struct nft_regs_track *track,\n\t\t    const struct nft_expr *expr)\n{\n\tconst struct nft_fib *priv = nft_expr_priv(expr);\n\tunsigned int len = NFT_REG32_SIZE;\n\tconst struct nft_fib *fib;\n\n\tswitch (priv->result) {\n\tcase NFT_FIB_RESULT_OIF:\n\t\tbreak;\n\tcase NFT_FIB_RESULT_OIFNAME:\n\t\tif (priv->flags & NFTA_FIB_F_PRESENT)\n\t\t\tlen = NFT_REG32_SIZE;\n\t\telse\n\t\t\tlen = IFNAMSIZ;\n\t\tbreak;\n\tcase NFT_FIB_RESULT_ADDRTYPE:\n\t     break;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, len);\n\t\treturn false;\n\t}\n\n\tfib = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->result != fib->result ||\n\t    priv->flags != fib->flags) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, len);\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(nft_fib_reduce);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Florian Westphal <fw@strlen.de>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}