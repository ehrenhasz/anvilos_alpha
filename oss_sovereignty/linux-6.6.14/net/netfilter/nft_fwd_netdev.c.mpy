{
  "module_name": "nft_fwd_netdev.c",
  "hash_id": "ef6911e6df345156f9c063746ecd7c76e06e254904f1e4bc238788f6ff954534",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_fwd_netdev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_offload.h>\n#include <net/netfilter/nf_dup_netdev.h>\n#include <net/neighbour.h>\n#include <net/ip.h>\n\nstruct nft_fwd_netdev {\n\tu8\tsreg_dev;\n};\n\nstatic void nft_fwd_netdev_eval(const struct nft_expr *expr,\n\t\t\t\tstruct nft_regs *regs,\n\t\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tstruct nft_fwd_netdev *priv = nft_expr_priv(expr);\n\tint oif = regs->data[priv->sreg_dev];\n\tstruct sk_buff *skb = pkt->skb;\n\n\t \n\tskb->skb_iif = skb->dev->ifindex;\n\tskb_set_redirected(skb, nft_hook(pkt) == NF_NETDEV_INGRESS);\n\n\tnf_fwd_netdev_egress(pkt, oif);\n\tregs->verdict.code = NF_STOLEN;\n}\n\nstatic const struct nla_policy nft_fwd_netdev_policy[NFTA_FWD_MAX + 1] = {\n\t[NFTA_FWD_SREG_DEV]\t= { .type = NLA_U32 },\n\t[NFTA_FWD_SREG_ADDR]\t= { .type = NLA_U32 },\n\t[NFTA_FWD_NFPROTO]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n};\n\nstatic int nft_fwd_netdev_init(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nlattr * const tb[])\n{\n\tstruct nft_fwd_netdev *priv = nft_expr_priv(expr);\n\n\tif (tb[NFTA_FWD_SREG_DEV] == NULL)\n\t\treturn -EINVAL;\n\n\treturn nft_parse_register_load(tb[NFTA_FWD_SREG_DEV], &priv->sreg_dev,\n\t\t\t\t       sizeof(int));\n}\n\nstatic int nft_fwd_netdev_dump(struct sk_buff *skb,\n\t\t\t       const struct nft_expr *expr, bool reset)\n{\n\tstruct nft_fwd_netdev *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_FWD_SREG_DEV, priv->sreg_dev))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_fwd_netdev_offload(struct nft_offload_ctx *ctx,\n\t\t\t\t  struct nft_flow_rule *flow,\n\t\t\t\t  const struct nft_expr *expr)\n{\n\tconst struct nft_fwd_netdev *priv = nft_expr_priv(expr);\n\tint oif = ctx->regs[priv->sreg_dev].data.data[0];\n\n\treturn nft_fwd_dup_netdev_offload(ctx, flow, FLOW_ACTION_REDIRECT, oif);\n}\n\nstatic bool nft_fwd_netdev_offload_action(const struct nft_expr *expr)\n{\n\treturn true;\n}\n\nstruct nft_fwd_neigh {\n\tu8\t\t\tsreg_dev;\n\tu8\t\t\tsreg_addr;\n\tu8\t\t\tnfproto;\n};\n\nstatic void nft_fwd_neigh_eval(const struct nft_expr *expr,\n\t\t\t      struct nft_regs *regs,\n\t\t\t      const struct nft_pktinfo *pkt)\n{\n\tstruct nft_fwd_neigh *priv = nft_expr_priv(expr);\n\tvoid *addr = &regs->data[priv->sreg_addr];\n\tint oif = regs->data[priv->sreg_dev];\n\tunsigned int verdict = NF_STOLEN;\n\tstruct sk_buff *skb = pkt->skb;\n\tstruct net_device *dev;\n\tint neigh_table;\n\n\tswitch (priv->nfproto) {\n\tcase NFPROTO_IPV4: {\n\t\tstruct iphdr *iph;\n\n\t\tif (skb->protocol != htons(ETH_P_IP)) {\n\t\t\tverdict = NFT_BREAK;\n\t\t\tgoto out;\n\t\t}\n\t\tif (skb_try_make_writable(skb, sizeof(*iph))) {\n\t\t\tverdict = NF_DROP;\n\t\t\tgoto out;\n\t\t}\n\t\tiph = ip_hdr(skb);\n\t\tip_decrease_ttl(iph);\n\t\tneigh_table = NEIGH_ARP_TABLE;\n\t\tbreak;\n\t\t}\n\tcase NFPROTO_IPV6: {\n\t\tstruct ipv6hdr *ip6h;\n\n\t\tif (skb->protocol != htons(ETH_P_IPV6)) {\n\t\t\tverdict = NFT_BREAK;\n\t\t\tgoto out;\n\t\t}\n\t\tif (skb_try_make_writable(skb, sizeof(*ip6h))) {\n\t\t\tverdict = NF_DROP;\n\t\t\tgoto out;\n\t\t}\n\t\tip6h = ipv6_hdr(skb);\n\t\tip6h->hop_limit--;\n\t\tneigh_table = NEIGH_ND_TABLE;\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\tverdict = NFT_BREAK;\n\t\tgoto out;\n\t}\n\n\tdev = dev_get_by_index_rcu(nft_net(pkt), oif);\n\tif (dev == NULL)\n\t\treturn;\n\n\tskb->dev = dev;\n\tskb_clear_tstamp(skb);\n\tneigh_xmit(neigh_table, dev, addr, skb);\nout:\n\tregs->verdict.code = verdict;\n}\n\nstatic int nft_fwd_neigh_init(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr,\n\t\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_fwd_neigh *priv = nft_expr_priv(expr);\n\tunsigned int addr_len;\n\tint err;\n\n\tif (!tb[NFTA_FWD_SREG_DEV] ||\n\t    !tb[NFTA_FWD_SREG_ADDR] ||\n\t    !tb[NFTA_FWD_NFPROTO])\n\t\treturn -EINVAL;\n\n\tpriv->nfproto = ntohl(nla_get_be32(tb[NFTA_FWD_NFPROTO]));\n\n\tswitch (priv->nfproto) {\n\tcase NFPROTO_IPV4:\n\t\taddr_len = sizeof(struct in_addr);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\taddr_len = sizeof(struct in6_addr);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = nft_parse_register_load(tb[NFTA_FWD_SREG_DEV], &priv->sreg_dev,\n\t\t\t\t      sizeof(int));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn nft_parse_register_load(tb[NFTA_FWD_SREG_ADDR], &priv->sreg_addr,\n\t\t\t\t       addr_len);\n}\n\nstatic int nft_fwd_neigh_dump(struct sk_buff *skb,\n\t\t\t      const struct nft_expr *expr, bool reset)\n{\n\tstruct nft_fwd_neigh *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_FWD_SREG_DEV, priv->sreg_dev) ||\n\t    nft_dump_register(skb, NFTA_FWD_SREG_ADDR, priv->sreg_addr) ||\n\t    nla_put_be32(skb, NFTA_FWD_NFPROTO, htonl(priv->nfproto)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_fwd_validate(const struct nft_ctx *ctx,\n\t\t\t    const struct nft_expr *expr,\n\t\t\t    const struct nft_data **data)\n{\n\treturn nft_chain_validate_hooks(ctx->chain, (1 << NF_NETDEV_INGRESS) |\n\t\t\t\t\t\t    (1 << NF_NETDEV_EGRESS));\n}\n\nstatic struct nft_expr_type nft_fwd_netdev_type;\nstatic const struct nft_expr_ops nft_fwd_neigh_netdev_ops = {\n\t.type\t\t= &nft_fwd_netdev_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_fwd_neigh)),\n\t.eval\t\t= nft_fwd_neigh_eval,\n\t.init\t\t= nft_fwd_neigh_init,\n\t.dump\t\t= nft_fwd_neigh_dump,\n\t.validate\t= nft_fwd_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic const struct nft_expr_ops nft_fwd_netdev_ops = {\n\t.type\t\t= &nft_fwd_netdev_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_fwd_netdev)),\n\t.eval\t\t= nft_fwd_netdev_eval,\n\t.init\t\t= nft_fwd_netdev_init,\n\t.dump\t\t= nft_fwd_netdev_dump,\n\t.validate\t= nft_fwd_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n\t.offload\t= nft_fwd_netdev_offload,\n\t.offload_action\t= nft_fwd_netdev_offload_action,\n};\n\nstatic const struct nft_expr_ops *\nnft_fwd_select_ops(const struct nft_ctx *ctx,\n\t\t   const struct nlattr * const tb[])\n{\n\tif (tb[NFTA_FWD_SREG_ADDR])\n\t\treturn &nft_fwd_neigh_netdev_ops;\n\tif (tb[NFTA_FWD_SREG_DEV])\n\t\treturn &nft_fwd_netdev_ops;\n\n        return ERR_PTR(-EOPNOTSUPP);\n}\n\nstatic struct nft_expr_type nft_fwd_netdev_type __read_mostly = {\n\t.family\t\t= NFPROTO_NETDEV,\n\t.name\t\t= \"fwd\",\n\t.select_ops\t= nft_fwd_select_ops,\n\t.policy\t\t= nft_fwd_netdev_policy,\n\t.maxattr\t= NFTA_FWD_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_fwd_netdev_module_init(void)\n{\n\treturn nft_register_expr(&nft_fwd_netdev_type);\n}\n\nstatic void __exit nft_fwd_netdev_module_exit(void)\n{\n\tnft_unregister_expr(&nft_fwd_netdev_type);\n}\n\nmodule_init(nft_fwd_netdev_module_init);\nmodule_exit(nft_fwd_netdev_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_ALIAS_NFT_AF_EXPR(5, \"fwd\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}