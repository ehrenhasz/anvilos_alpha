{
  "module_name": "xt_bpf.c",
  "hash_id": "4e83721d0fef7e4cd79d1977f3614475c2346cd4a739f510df48ed7950100bac",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_bpf.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/syscalls.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n\n#include <linux/netfilter/xt_bpf.h>\n#include <linux/netfilter/x_tables.h>\n\nMODULE_AUTHOR(\"Willem de Bruijn <willemb@google.com>\");\nMODULE_DESCRIPTION(\"Xtables: BPF filter match\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_bpf\");\nMODULE_ALIAS(\"ip6t_bpf\");\n\nstatic int __bpf_mt_check_bytecode(struct sock_filter *insns, __u16 len,\n\t\t\t\t   struct bpf_prog **ret)\n{\n\tstruct sock_fprog_kern program;\n\n\tif (len > XT_BPF_MAX_NUM_INSTR)\n\t\treturn -EINVAL;\n\n\tprogram.len = len;\n\tprogram.filter = insns;\n\n\tif (bpf_prog_create(ret, &program)) {\n\t\tpr_info_ratelimited(\"check failed: parse error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __bpf_mt_check_fd(int fd, struct bpf_prog **ret)\n{\n\tstruct bpf_prog *prog;\n\n\tprog = bpf_prog_get_type(fd, BPF_PROG_TYPE_SOCKET_FILTER);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\t*ret = prog;\n\treturn 0;\n}\n\nstatic int __bpf_mt_check_path(const char *path, struct bpf_prog **ret)\n{\n\tif (strnlen(path, XT_BPF_PATH_MAX) == XT_BPF_PATH_MAX)\n\t\treturn -EINVAL;\n\n\t*ret = bpf_prog_get_type_path(path, BPF_PROG_TYPE_SOCKET_FILTER);\n\treturn PTR_ERR_OR_ZERO(*ret);\n}\n\nstatic int bpf_mt_check(const struct xt_mtchk_param *par)\n{\n\tstruct xt_bpf_info *info = par->matchinfo;\n\n\treturn __bpf_mt_check_bytecode(info->bpf_program,\n\t\t\t\t       info->bpf_program_num_elem,\n\t\t\t\t       &info->filter);\n}\n\nstatic int bpf_mt_check_v1(const struct xt_mtchk_param *par)\n{\n\tstruct xt_bpf_info_v1 *info = par->matchinfo;\n\n\tif (info->mode == XT_BPF_MODE_BYTECODE)\n\t\treturn __bpf_mt_check_bytecode(info->bpf_program,\n\t\t\t\t\t       info->bpf_program_num_elem,\n\t\t\t\t\t       &info->filter);\n\telse if (info->mode == XT_BPF_MODE_FD_ELF)\n\t\treturn __bpf_mt_check_fd(info->fd, &info->filter);\n\telse if (info->mode == XT_BPF_MODE_PATH_PINNED)\n\t\treturn __bpf_mt_check_path(info->path, &info->filter);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic bool bpf_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_bpf_info *info = par->matchinfo;\n\n\treturn bpf_prog_run(info->filter, skb);\n}\n\nstatic bool bpf_mt_v1(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_bpf_info_v1 *info = par->matchinfo;\n\n\treturn !!bpf_prog_run_save_cb(info->filter, (struct sk_buff *) skb);\n}\n\nstatic void bpf_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tconst struct xt_bpf_info *info = par->matchinfo;\n\n\tbpf_prog_destroy(info->filter);\n}\n\nstatic void bpf_mt_destroy_v1(const struct xt_mtdtor_param *par)\n{\n\tconst struct xt_bpf_info_v1 *info = par->matchinfo;\n\n\tbpf_prog_destroy(info->filter);\n}\n\nstatic struct xt_match bpf_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"bpf\",\n\t\t.revision\t= 0,\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.checkentry\t= bpf_mt_check,\n\t\t.match\t\t= bpf_mt,\n\t\t.destroy\t= bpf_mt_destroy,\n\t\t.matchsize\t= sizeof(struct xt_bpf_info),\n\t\t.usersize\t= offsetof(struct xt_bpf_info, filter),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"bpf\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.checkentry\t= bpf_mt_check_v1,\n\t\t.match\t\t= bpf_mt_v1,\n\t\t.destroy\t= bpf_mt_destroy_v1,\n\t\t.matchsize\t= sizeof(struct xt_bpf_info_v1),\n\t\t.usersize\t= offsetof(struct xt_bpf_info_v1, filter),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init bpf_mt_init(void)\n{\n\treturn xt_register_matches(bpf_mt_reg, ARRAY_SIZE(bpf_mt_reg));\n}\n\nstatic void __exit bpf_mt_exit(void)\n{\n\txt_unregister_matches(bpf_mt_reg, ARRAY_SIZE(bpf_mt_reg));\n}\n\nmodule_init(bpf_mt_init);\nmodule_exit(bpf_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}