{
  "module_name": "nf_conntrack_tftp.c",
  "hash_id": "461648813b7b39e9f9021210b17b548dad6728bc166baeeeae2c8e88a16d0655",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_tftp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/in.h>\n#include <linux/udp.h>\n#include <linux/netfilter.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_tuple.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <linux/netfilter/nf_conntrack_tftp.h>\n\n#define HELPER_NAME \"tftp\"\n\nMODULE_AUTHOR(\"Magnus Boden <mb@ozaba.mine.nu>\");\nMODULE_DESCRIPTION(\"TFTP connection tracking helper\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ip_conntrack_tftp\");\nMODULE_ALIAS_NFCT_HELPER(HELPER_NAME);\n\n#define MAX_PORTS 8\nstatic unsigned short ports[MAX_PORTS];\nstatic unsigned int ports_c;\nmodule_param_array(ports, ushort, &ports_c, 0400);\nMODULE_PARM_DESC(ports, \"Port numbers of TFTP servers\");\n\nunsigned int (*nf_nat_tftp_hook)(struct sk_buff *skb,\n\t\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t\t struct nf_conntrack_expect *exp) __read_mostly;\nEXPORT_SYMBOL_GPL(nf_nat_tftp_hook);\n\nstatic int tftp_help(struct sk_buff *skb,\n\t\t     unsigned int protoff,\n\t\t     struct nf_conn *ct,\n\t\t     enum ip_conntrack_info ctinfo)\n{\n\tconst struct tftphdr *tfh;\n\tstruct tftphdr _tftph;\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conntrack_tuple *tuple;\n\tunsigned int ret = NF_ACCEPT;\n\ttypeof(nf_nat_tftp_hook) nf_nat_tftp;\n\n\ttfh = skb_header_pointer(skb, protoff + sizeof(struct udphdr),\n\t\t\t\t sizeof(_tftph), &_tftph);\n\tif (tfh == NULL)\n\t\treturn NF_ACCEPT;\n\n\tswitch (ntohs(tfh->opcode)) {\n\tcase TFTP_OPCODE_READ:\n\tcase TFTP_OPCODE_WRITE:\n\t\t \n\t\tnf_ct_dump_tuple(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);\n\t\tnf_ct_dump_tuple(&ct->tuplehash[IP_CT_DIR_REPLY].tuple);\n\n\t\texp = nf_ct_expect_alloc(ct);\n\t\tif (exp == NULL) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot alloc expectation\");\n\t\t\treturn NF_DROP;\n\t\t}\n\t\ttuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;\n\t\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT,\n\t\t\t\t  nf_ct_l3num(ct),\n\t\t\t\t  &tuple->src.u3, &tuple->dst.u3,\n\t\t\t\t  IPPROTO_UDP, NULL, &tuple->dst.u.udp.port);\n\n\t\tpr_debug(\"expect: \");\n\t\tnf_ct_dump_tuple(&exp->tuple);\n\n\t\tnf_nat_tftp = rcu_dereference(nf_nat_tftp_hook);\n\t\tif (nf_nat_tftp && ct->status & IPS_NAT_MASK)\n\t\t\tret = nf_nat_tftp(skb, ctinfo, exp);\n\t\telse if (nf_ct_expect_related(exp, 0) != 0) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot add expectation\");\n\t\t\tret = NF_DROP;\n\t\t}\n\t\tnf_ct_expect_put(exp);\n\t\tbreak;\n\tcase TFTP_OPCODE_DATA:\n\tcase TFTP_OPCODE_ACK:\n\t\tpr_debug(\"Data/ACK opcode\\n\");\n\t\tbreak;\n\tcase TFTP_OPCODE_ERROR:\n\t\tpr_debug(\"Error opcode\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Unknown opcode\\n\");\n\t}\n\treturn ret;\n}\n\nstatic struct nf_conntrack_helper tftp[MAX_PORTS * 2] __read_mostly;\n\nstatic const struct nf_conntrack_expect_policy tftp_exp_policy = {\n\t.max_expected\t= 1,\n\t.timeout\t= 5 * 60,\n};\n\nstatic void __exit nf_conntrack_tftp_fini(void)\n{\n\tnf_conntrack_helpers_unregister(tftp, ports_c * 2);\n}\n\nstatic int __init nf_conntrack_tftp_init(void)\n{\n\tint i, ret;\n\n\tNF_CT_HELPER_BUILD_BUG_ON(0);\n\n\tif (ports_c == 0)\n\t\tports[ports_c++] = TFTP_PORT;\n\n\tfor (i = 0; i < ports_c; i++) {\n\t\tnf_ct_helper_init(&tftp[2 * i], AF_INET, IPPROTO_UDP,\n\t\t\t\t  HELPER_NAME, TFTP_PORT, ports[i], i,\n\t\t\t\t  &tftp_exp_policy, 0, tftp_help, NULL,\n\t\t\t\t  THIS_MODULE);\n\t\tnf_ct_helper_init(&tftp[2 * i + 1], AF_INET6, IPPROTO_UDP,\n\t\t\t\t  HELPER_NAME, TFTP_PORT, ports[i], i,\n\t\t\t\t  &tftp_exp_policy, 0, tftp_help, NULL,\n\t\t\t\t  THIS_MODULE);\n\t}\n\n\tret = nf_conntrack_helpers_register(tftp, ports_c * 2);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to register helpers\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nmodule_init(nf_conntrack_tftp_init);\nmodule_exit(nf_conntrack_tftp_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}