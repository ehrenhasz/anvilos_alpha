{
  "module_name": "nft_compat.c",
  "hash_id": "014ff8d2297177792d863ecbab96d8e6a4cc4754fdd8223ec567b2735a57c01d",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_compat.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/netfilter/nf_tables_compat.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <linux/netfilter_bridge/ebtables.h>\n#include <linux/netfilter_arp/arp_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_log.h>\n\n \n#define NFT_MATCH_LARGE_THRESH\t192\n\nstruct nft_xt_match_priv {\n\tvoid *info;\n};\n\nstatic int nft_compat_chain_validate_dependency(const struct nft_ctx *ctx,\n\t\t\t\t\t\tconst char *tablename)\n{\n\tenum nft_chain_types type = NFT_CHAIN_T_DEFAULT;\n\tconst struct nft_chain *chain = ctx->chain;\n\tconst struct nft_base_chain *basechain;\n\n\tif (!tablename ||\n\t    !nft_is_base_chain(chain))\n\t\treturn 0;\n\n\tbasechain = nft_base_chain(chain);\n\tif (strcmp(tablename, \"nat\") == 0) {\n\t\tif (ctx->family != NFPROTO_BRIDGE)\n\t\t\ttype = NFT_CHAIN_T_NAT;\n\t\tif (basechain->type->type != type)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nunion nft_entry {\n\tstruct ipt_entry e4;\n\tstruct ip6t_entry e6;\n\tstruct ebt_entry ebt;\n\tstruct arpt_entry arp;\n};\n\nstatic inline void\nnft_compat_set_par(struct xt_action_param *par,\n\t\t   const struct nft_pktinfo *pkt,\n\t\t   const void *xt, const void *xt_info)\n{\n\tpar->state\t= pkt->state;\n\tpar->thoff\t= nft_thoff(pkt);\n\tpar->fragoff\t= pkt->fragoff;\n\tpar->target\t= xt;\n\tpar->targinfo\t= xt_info;\n\tpar->hotdrop\t= false;\n}\n\nstatic void nft_target_eval_xt(const struct nft_expr *expr,\n\t\t\t       struct nft_regs *regs,\n\t\t\t       const struct nft_pktinfo *pkt)\n{\n\tvoid *info = nft_expr_priv(expr);\n\tstruct xt_target *target = expr->ops->data;\n\tstruct sk_buff *skb = pkt->skb;\n\tstruct xt_action_param xt;\n\tint ret;\n\n\tnft_compat_set_par(&xt, pkt, target, info);\n\n\tret = target->target(skb, &xt);\n\n\tif (xt.hotdrop)\n\t\tret = NF_DROP;\n\n\tswitch (ret) {\n\tcase XT_CONTINUE:\n\t\tregs->verdict.code = NFT_CONTINUE;\n\t\tbreak;\n\tdefault:\n\t\tregs->verdict.code = ret;\n\t\tbreak;\n\t}\n}\n\nstatic void nft_target_eval_bridge(const struct nft_expr *expr,\n\t\t\t\t   struct nft_regs *regs,\n\t\t\t\t   const struct nft_pktinfo *pkt)\n{\n\tvoid *info = nft_expr_priv(expr);\n\tstruct xt_target *target = expr->ops->data;\n\tstruct sk_buff *skb = pkt->skb;\n\tstruct xt_action_param xt;\n\tint ret;\n\n\tnft_compat_set_par(&xt, pkt, target, info);\n\n\tret = target->target(skb, &xt);\n\n\tif (xt.hotdrop)\n\t\tret = NF_DROP;\n\n\tswitch (ret) {\n\tcase EBT_ACCEPT:\n\t\tregs->verdict.code = NF_ACCEPT;\n\t\tbreak;\n\tcase EBT_DROP:\n\t\tregs->verdict.code = NF_DROP;\n\t\tbreak;\n\tcase EBT_CONTINUE:\n\t\tregs->verdict.code = NFT_CONTINUE;\n\t\tbreak;\n\tcase EBT_RETURN:\n\t\tregs->verdict.code = NFT_RETURN;\n\t\tbreak;\n\tdefault:\n\t\tregs->verdict.code = ret;\n\t\tbreak;\n\t}\n}\n\nstatic const struct nla_policy nft_target_policy[NFTA_TARGET_MAX + 1] = {\n\t[NFTA_TARGET_NAME]\t= { .type = NLA_NUL_STRING },\n\t[NFTA_TARGET_REV]\t= { .type = NLA_U32 },\n\t[NFTA_TARGET_INFO]\t= { .type = NLA_BINARY },\n};\n\nstatic void\nnft_target_set_tgchk_param(struct xt_tgchk_param *par,\n\t\t\t   const struct nft_ctx *ctx,\n\t\t\t   struct xt_target *target, void *info,\n\t\t\t   union nft_entry *entry, u16 proto, bool inv)\n{\n\tpar->net\t= ctx->net;\n\tpar->table\t= ctx->table->name;\n\tswitch (ctx->family) {\n\tcase AF_INET:\n\t\tentry->e4.ip.proto = proto;\n\t\tentry->e4.ip.invflags = inv ? IPT_INV_PROTO : 0;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (proto)\n\t\t\tentry->e6.ipv6.flags |= IP6T_F_PROTO;\n\n\t\tentry->e6.ipv6.proto = proto;\n\t\tentry->e6.ipv6.invflags = inv ? IP6T_INV_PROTO : 0;\n\t\tbreak;\n\tcase NFPROTO_BRIDGE:\n\t\tentry->ebt.ethproto = (__force __be16)proto;\n\t\tentry->ebt.invflags = inv ? EBT_IPROTO : 0;\n\t\tbreak;\n\tcase NFPROTO_ARP:\n\t\tbreak;\n\t}\n\tpar->entryinfo\t= entry;\n\tpar->target\t= target;\n\tpar->targinfo\t= info;\n\tif (nft_is_base_chain(ctx->chain)) {\n\t\tconst struct nft_base_chain *basechain =\n\t\t\t\t\t\tnft_base_chain(ctx->chain);\n\t\tconst struct nf_hook_ops *ops = &basechain->ops;\n\n\t\tpar->hook_mask = 1 << ops->hooknum;\n\t} else {\n\t\tpar->hook_mask = 0;\n\t}\n\tpar->family\t= ctx->family;\n\tpar->nft_compat = true;\n}\n\nstatic void target_compat_from_user(struct xt_target *t, void *in, void *out)\n{\n\tint pad;\n\n\tmemcpy(out, in, t->targetsize);\n\tpad = XT_ALIGN(t->targetsize) - t->targetsize;\n\tif (pad > 0)\n\t\tmemset(out + t->targetsize, 0, pad);\n}\n\nstatic const struct nla_policy nft_rule_compat_policy[NFTA_RULE_COMPAT_MAX + 1] = {\n\t[NFTA_RULE_COMPAT_PROTO]\t= { .type = NLA_U32 },\n\t[NFTA_RULE_COMPAT_FLAGS]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_parse_compat(const struct nlattr *attr, u16 *proto, bool *inv)\n{\n\tstruct nlattr *tb[NFTA_RULE_COMPAT_MAX+1];\n\tu32 flags;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_RULE_COMPAT_MAX, attr,\n\t\t\t\t\t  nft_rule_compat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_RULE_COMPAT_PROTO] || !tb[NFTA_RULE_COMPAT_FLAGS])\n\t\treturn -EINVAL;\n\n\tflags = ntohl(nla_get_be32(tb[NFTA_RULE_COMPAT_FLAGS]));\n\tif (flags & ~NFT_RULE_COMPAT_F_MASK)\n\t\treturn -EINVAL;\n\tif (flags & NFT_RULE_COMPAT_F_INV)\n\t\t*inv = true;\n\n\t*proto = ntohl(nla_get_be32(tb[NFTA_RULE_COMPAT_PROTO]));\n\treturn 0;\n}\n\nstatic void nft_compat_wait_for_destructors(void)\n{\n\t \n\tnf_tables_trans_destroy_flush_work();\n}\n\nstatic int\nnft_target_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\tconst struct nlattr * const tb[])\n{\n\tvoid *info = nft_expr_priv(expr);\n\tstruct xt_target *target = expr->ops->data;\n\tstruct xt_tgchk_param par;\n\tsize_t size = XT_ALIGN(nla_len(tb[NFTA_TARGET_INFO]));\n\tu16 proto = 0;\n\tbool inv = false;\n\tunion nft_entry e = {};\n\tint ret;\n\n\ttarget_compat_from_user(target, nla_data(tb[NFTA_TARGET_INFO]), info);\n\n\tif (ctx->nla[NFTA_RULE_COMPAT]) {\n\t\tret = nft_parse_compat(ctx->nla[NFTA_RULE_COMPAT], &proto, &inv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tnft_target_set_tgchk_param(&par, ctx, target, info, &e, proto, inv);\n\n\tnft_compat_wait_for_destructors();\n\n\tret = xt_check_target(&par, size, proto, inv);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT) {\n\t\t\tconst char *modname = NULL;\n\n\t\t\tif (strcmp(target->name, \"LOG\") == 0)\n\t\t\t\tmodname = \"nf_log_syslog\";\n\t\t\telse if (strcmp(target->name, \"NFLOG\") == 0)\n\t\t\t\tmodname = \"nfnetlink_log\";\n\n\t\t\tif (modname &&\n\t\t\t    nft_request_module(ctx->net, \"%s\", modname) == -EAGAIN)\n\t\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t \n\tif (!target->target)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void __nft_mt_tg_destroy(struct module *me, const struct nft_expr *expr)\n{\n\tmodule_put(me);\n\tkfree(expr->ops);\n}\n\nstatic void\nnft_target_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\n{\n\tstruct xt_target *target = expr->ops->data;\n\tvoid *info = nft_expr_priv(expr);\n\tstruct module *me = target->me;\n\tstruct xt_tgdtor_param par;\n\n\tpar.net = ctx->net;\n\tpar.target = target;\n\tpar.targinfo = info;\n\tpar.family = ctx->family;\n\tif (par.target->destroy != NULL)\n\t\tpar.target->destroy(&par);\n\n\t__nft_mt_tg_destroy(me, expr);\n}\n\nstatic int nft_extension_dump_info(struct sk_buff *skb, int attr,\n\t\t\t\t   const void *info,\n\t\t\t\t   unsigned int size, unsigned int user_size)\n{\n\tunsigned int info_size, aligned_size = XT_ALIGN(size);\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, attr, aligned_size);\n\tif (!nla)\n\t\treturn -1;\n\n\tinfo_size = user_size ? : size;\n\tmemcpy(nla_data(nla), info, info_size);\n\tmemset(nla_data(nla) + info_size, 0, aligned_size - info_size);\n\n\treturn 0;\n}\n\nstatic int nft_target_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct xt_target *target = expr->ops->data;\n\tvoid *info = nft_expr_priv(expr);\n\n\tif (nla_put_string(skb, NFTA_TARGET_NAME, target->name) ||\n\t    nla_put_be32(skb, NFTA_TARGET_REV, htonl(target->revision)) ||\n\t    nft_extension_dump_info(skb, NFTA_TARGET_INFO, info,\n\t\t\t\t    target->targetsize, target->usersize))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_target_validate(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nft_data **data)\n{\n\tstruct xt_target *target = expr->ops->data;\n\tunsigned int hook_mask = 0;\n\tint ret;\n\n\tif (nft_is_base_chain(ctx->chain)) {\n\t\tconst struct nft_base_chain *basechain =\n\t\t\t\t\t\tnft_base_chain(ctx->chain);\n\t\tconst struct nf_hook_ops *ops = &basechain->ops;\n\n\t\thook_mask = 1 << ops->hooknum;\n\t\tif (target->hooks && !(hook_mask & target->hooks))\n\t\t\treturn -EINVAL;\n\n\t\tret = nft_compat_chain_validate_dependency(ctx, target->table);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void __nft_match_eval(const struct nft_expr *expr,\n\t\t\t     struct nft_regs *regs,\n\t\t\t     const struct nft_pktinfo *pkt,\n\t\t\t     void *info)\n{\n\tstruct xt_match *match = expr->ops->data;\n\tstruct sk_buff *skb = pkt->skb;\n\tstruct xt_action_param xt;\n\tbool ret;\n\n\tnft_compat_set_par(&xt, pkt, match, info);\n\n\tret = match->match(skb, &xt);\n\n\tif (xt.hotdrop) {\n\t\tregs->verdict.code = NF_DROP;\n\t\treturn;\n\t}\n\n\tswitch (ret ? 1 : 0) {\n\tcase 1:\n\t\tregs->verdict.code = NFT_CONTINUE;\n\t\tbreak;\n\tcase 0:\n\t\tregs->verdict.code = NFT_BREAK;\n\t\tbreak;\n\t}\n}\n\nstatic void nft_match_large_eval(const struct nft_expr *expr,\n\t\t\t\t struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct nft_xt_match_priv *priv = nft_expr_priv(expr);\n\n\t__nft_match_eval(expr, regs, pkt, priv->info);\n}\n\nstatic void nft_match_eval(const struct nft_expr *expr,\n\t\t\t   struct nft_regs *regs,\n\t\t\t   const struct nft_pktinfo *pkt)\n{\n\t__nft_match_eval(expr, regs, pkt, nft_expr_priv(expr));\n}\n\nstatic const struct nla_policy nft_match_policy[NFTA_MATCH_MAX + 1] = {\n\t[NFTA_MATCH_NAME]\t= { .type = NLA_NUL_STRING },\n\t[NFTA_MATCH_REV]\t= { .type = NLA_U32 },\n\t[NFTA_MATCH_INFO]\t= { .type = NLA_BINARY },\n};\n\n \nstatic void\nnft_match_set_mtchk_param(struct xt_mtchk_param *par, const struct nft_ctx *ctx,\n\t\t\t  struct xt_match *match, void *info,\n\t\t\t  union nft_entry *entry, u16 proto, bool inv)\n{\n\tpar->net\t= ctx->net;\n\tpar->table\t= ctx->table->name;\n\tswitch (ctx->family) {\n\tcase AF_INET:\n\t\tentry->e4.ip.proto = proto;\n\t\tentry->e4.ip.invflags = inv ? IPT_INV_PROTO : 0;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (proto)\n\t\t\tentry->e6.ipv6.flags |= IP6T_F_PROTO;\n\n\t\tentry->e6.ipv6.proto = proto;\n\t\tentry->e6.ipv6.invflags = inv ? IP6T_INV_PROTO : 0;\n\t\tbreak;\n\tcase NFPROTO_BRIDGE:\n\t\tentry->ebt.ethproto = (__force __be16)proto;\n\t\tentry->ebt.invflags = inv ? EBT_IPROTO : 0;\n\t\tbreak;\n\tcase NFPROTO_ARP:\n\t\tbreak;\n\t}\n\tpar->entryinfo\t= entry;\n\tpar->match\t= match;\n\tpar->matchinfo\t= info;\n\tif (nft_is_base_chain(ctx->chain)) {\n\t\tconst struct nft_base_chain *basechain =\n\t\t\t\t\t\tnft_base_chain(ctx->chain);\n\t\tconst struct nf_hook_ops *ops = &basechain->ops;\n\n\t\tpar->hook_mask = 1 << ops->hooknum;\n\t} else {\n\t\tpar->hook_mask = 0;\n\t}\n\tpar->family\t= ctx->family;\n\tpar->nft_compat = true;\n}\n\nstatic void match_compat_from_user(struct xt_match *m, void *in, void *out)\n{\n\tint pad;\n\n\tmemcpy(out, in, m->matchsize);\n\tpad = XT_ALIGN(m->matchsize) - m->matchsize;\n\tif (pad > 0)\n\t\tmemset(out + m->matchsize, 0, pad);\n}\n\nstatic int\n__nft_match_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t const struct nlattr * const tb[],\n\t\t void *info)\n{\n\tstruct xt_match *match = expr->ops->data;\n\tstruct xt_mtchk_param par;\n\tsize_t size = XT_ALIGN(nla_len(tb[NFTA_MATCH_INFO]));\n\tu16 proto = 0;\n\tbool inv = false;\n\tunion nft_entry e = {};\n\tint ret;\n\n\tmatch_compat_from_user(match, nla_data(tb[NFTA_MATCH_INFO]), info);\n\n\tif (ctx->nla[NFTA_RULE_COMPAT]) {\n\t\tret = nft_parse_compat(ctx->nla[NFTA_RULE_COMPAT], &proto, &inv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tnft_match_set_mtchk_param(&par, ctx, match, info, &e, proto, inv);\n\n\tnft_compat_wait_for_destructors();\n\n\treturn xt_check_match(&par, size, proto, inv);\n}\n\nstatic int\nnft_match_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t       const struct nlattr * const tb[])\n{\n\treturn __nft_match_init(ctx, expr, tb, nft_expr_priv(expr));\n}\n\nstatic int\nnft_match_large_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t     const struct nlattr * const tb[])\n{\n\tstruct nft_xt_match_priv *priv = nft_expr_priv(expr);\n\tstruct xt_match *m = expr->ops->data;\n\tint ret;\n\n\tpriv->info = kmalloc(XT_ALIGN(m->matchsize), GFP_KERNEL);\n\tif (!priv->info)\n\t\treturn -ENOMEM;\n\n\tret = __nft_match_init(ctx, expr, tb, priv->info);\n\tif (ret)\n\t\tkfree(priv->info);\n\treturn ret;\n}\n\nstatic void\n__nft_match_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t    void *info)\n{\n\tstruct xt_match *match = expr->ops->data;\n\tstruct module *me = match->me;\n\tstruct xt_mtdtor_param par;\n\n\tpar.net = ctx->net;\n\tpar.match = match;\n\tpar.matchinfo = info;\n\tpar.family = ctx->family;\n\tif (par.match->destroy != NULL)\n\t\tpar.match->destroy(&par);\n\n\t__nft_mt_tg_destroy(me, expr);\n}\n\nstatic void\nnft_match_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\n{\n\t__nft_match_destroy(ctx, expr, nft_expr_priv(expr));\n}\n\nstatic void\nnft_match_large_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\n{\n\tstruct nft_xt_match_priv *priv = nft_expr_priv(expr);\n\n\t__nft_match_destroy(ctx, expr, priv->info);\n\tkfree(priv->info);\n}\n\nstatic int __nft_match_dump(struct sk_buff *skb, const struct nft_expr *expr,\n\t\t\t    void *info)\n{\n\tstruct xt_match *match = expr->ops->data;\n\n\tif (nla_put_string(skb, NFTA_MATCH_NAME, match->name) ||\n\t    nla_put_be32(skb, NFTA_MATCH_REV, htonl(match->revision)) ||\n\t    nft_extension_dump_info(skb, NFTA_MATCH_INFO, info,\n\t\t\t\t    match->matchsize, match->usersize))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_match_dump(struct sk_buff *skb,\n\t\t\t  const struct nft_expr *expr, bool reset)\n{\n\treturn __nft_match_dump(skb, expr, nft_expr_priv(expr));\n}\n\nstatic int nft_match_large_dump(struct sk_buff *skb,\n\t\t\t\tconst struct nft_expr *e, bool reset)\n{\n\tstruct nft_xt_match_priv *priv = nft_expr_priv(e);\n\n\treturn __nft_match_dump(skb, e, priv->info);\n}\n\nstatic int nft_match_validate(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr,\n\t\t\t      const struct nft_data **data)\n{\n\tstruct xt_match *match = expr->ops->data;\n\tunsigned int hook_mask = 0;\n\tint ret;\n\n\tif (nft_is_base_chain(ctx->chain)) {\n\t\tconst struct nft_base_chain *basechain =\n\t\t\t\t\t\tnft_base_chain(ctx->chain);\n\t\tconst struct nf_hook_ops *ops = &basechain->ops;\n\n\t\thook_mask = 1 << ops->hooknum;\n\t\tif (match->hooks && !(hook_mask & match->hooks))\n\t\t\treturn -EINVAL;\n\n\t\tret = nft_compat_chain_validate_dependency(ctx, match->table);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int\nnfnl_compat_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\n\t\t      int event, u16 family, const char *name,\n\t\t      int rev, int target)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned int flags = portid ? NLM_F_MULTI : 0;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_NFT_COMPAT, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, family,\n\t\t\t   NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tif (nla_put_string(skb, NFTA_COMPAT_NAME, name) ||\n\t    nla_put_be32(skb, NFTA_COMPAT_REV, htonl(rev)) ||\n\t    nla_put_be32(skb, NFTA_COMPAT_TYPE, htonl(target)))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -1;\n}\n\nstatic int nfnl_compat_get_rcu(struct sk_buff *skb,\n\t\t\t       const struct nfnl_info *info,\n\t\t\t       const struct nlattr * const tb[])\n{\n\tu8 family = info->nfmsg->nfgen_family;\n\tconst char *name, *fmt;\n\tstruct sk_buff *skb2;\n\tint ret = 0, target;\n\tu32 rev;\n\n\tif (tb[NFTA_COMPAT_NAME] == NULL ||\n\t    tb[NFTA_COMPAT_REV] == NULL ||\n\t    tb[NFTA_COMPAT_TYPE] == NULL)\n\t\treturn -EINVAL;\n\n\tname = nla_data(tb[NFTA_COMPAT_NAME]);\n\trev = ntohl(nla_get_be32(tb[NFTA_COMPAT_REV]));\n\ttarget = ntohl(nla_get_be32(tb[NFTA_COMPAT_TYPE]));\n\n\tswitch(family) {\n\tcase AF_INET:\n\t\tfmt = \"ipt_%s\";\n\t\tbreak;\n\tcase AF_INET6:\n\t\tfmt = \"ip6t_%s\";\n\t\tbreak;\n\tcase NFPROTO_BRIDGE:\n\t\tfmt = \"ebt_%s\";\n\t\tbreak;\n\tcase NFPROTO_ARP:\n\t\tfmt = \"arpt_%s\";\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"nft_compat: unsupported protocol %d\\n\", family);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -EINVAL;\n\n\trcu_read_unlock();\n\ttry_then_request_module(xt_find_revision(family, name, rev, target, &ret),\n\t\t\t\tfmt, name);\n\tif (ret < 0)\n\t\tgoto out_put;\n\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb2 == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\t \n\tif (nfnl_compat_fill_info(skb2, NETLINK_CB(skb).portid,\n\t\t\t\t  info->nlh->nlmsg_seq,\n\t\t\t\t  NFNL_MSG_TYPE(info->nlh->nlmsg_type),\n\t\t\t\t  NFNL_MSG_COMPAT_GET,\n\t\t\t\t  family, name, ret, target) <= 0) {\n\t\tkfree_skb(skb2);\n\t\tgoto out_put;\n\t}\n\n\tret = nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\nout_put:\n\trcu_read_lock();\n\tmodule_put(THIS_MODULE);\n\n\treturn ret;\n}\n\nstatic const struct nla_policy nfnl_compat_policy_get[NFTA_COMPAT_MAX+1] = {\n\t[NFTA_COMPAT_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = NFT_COMPAT_NAME_MAX-1 },\n\t[NFTA_COMPAT_REV]\t= { .type = NLA_U32 },\n\t[NFTA_COMPAT_TYPE]\t= { .type = NLA_U32 },\n};\n\nstatic const struct nfnl_callback nfnl_nft_compat_cb[NFNL_MSG_COMPAT_MAX] = {\n\t[NFNL_MSG_COMPAT_GET]\t= {\n\t\t.call\t\t= nfnl_compat_get_rcu,\n\t\t.type\t\t= NFNL_CB_RCU,\n\t\t.attr_count\t= NFTA_COMPAT_MAX,\n\t\t.policy\t\t= nfnl_compat_policy_get\n\t},\n};\n\nstatic const struct nfnetlink_subsystem nfnl_compat_subsys = {\n\t.name\t\t= \"nft-compat\",\n\t.subsys_id\t= NFNL_SUBSYS_NFT_COMPAT,\n\t.cb_count\t= NFNL_MSG_COMPAT_MAX,\n\t.cb\t\t= nfnl_nft_compat_cb,\n};\n\nstatic struct nft_expr_type nft_match_type;\n\nstatic bool nft_match_reduce(struct nft_regs_track *track,\n\t\t\t     const struct nft_expr *expr)\n{\n\tconst struct xt_match *match = expr->ops->data;\n\n\treturn strcmp(match->name, \"comment\") == 0;\n}\n\nstatic const struct nft_expr_ops *\nnft_match_select_ops(const struct nft_ctx *ctx,\n\t\t     const struct nlattr * const tb[])\n{\n\tstruct nft_expr_ops *ops;\n\tstruct xt_match *match;\n\tunsigned int matchsize;\n\tchar *mt_name;\n\tu32 rev, family;\n\tint err;\n\n\tif (tb[NFTA_MATCH_NAME] == NULL ||\n\t    tb[NFTA_MATCH_REV] == NULL ||\n\t    tb[NFTA_MATCH_INFO] == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmt_name = nla_data(tb[NFTA_MATCH_NAME]);\n\trev = ntohl(nla_get_be32(tb[NFTA_MATCH_REV]));\n\tfamily = ctx->family;\n\n\tmatch = xt_request_find_match(family, mt_name, rev);\n\tif (IS_ERR(match))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (match->matchsize > nla_len(tb[NFTA_MATCH_INFO])) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tops = kzalloc(sizeof(struct nft_expr_ops), GFP_KERNEL);\n\tif (!ops) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tops->type = &nft_match_type;\n\tops->eval = nft_match_eval;\n\tops->init = nft_match_init;\n\tops->destroy = nft_match_destroy;\n\tops->dump = nft_match_dump;\n\tops->validate = nft_match_validate;\n\tops->data = match;\n\tops->reduce = nft_match_reduce;\n\n\tmatchsize = NFT_EXPR_SIZE(XT_ALIGN(match->matchsize));\n\tif (matchsize > NFT_MATCH_LARGE_THRESH) {\n\t\tmatchsize = NFT_EXPR_SIZE(sizeof(struct nft_xt_match_priv));\n\n\t\tops->eval = nft_match_large_eval;\n\t\tops->init = nft_match_large_init;\n\t\tops->destroy = nft_match_large_destroy;\n\t\tops->dump = nft_match_large_dump;\n\t}\n\n\tops->size = matchsize;\n\n\treturn ops;\nerr:\n\tmodule_put(match->me);\n\treturn ERR_PTR(err);\n}\n\nstatic void nft_match_release_ops(const struct nft_expr_ops *ops)\n{\n\tstruct xt_match *match = ops->data;\n\n\tmodule_put(match->me);\n\tkfree(ops);\n}\n\nstatic struct nft_expr_type nft_match_type __read_mostly = {\n\t.name\t\t= \"match\",\n\t.select_ops\t= nft_match_select_ops,\n\t.release_ops\t= nft_match_release_ops,\n\t.policy\t\t= nft_match_policy,\n\t.maxattr\t= NFTA_MATCH_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct nft_expr_type nft_target_type;\n\nstatic const struct nft_expr_ops *\nnft_target_select_ops(const struct nft_ctx *ctx,\n\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_expr_ops *ops;\n\tstruct xt_target *target;\n\tchar *tg_name;\n\tu32 rev, family;\n\tint err;\n\n\tif (tb[NFTA_TARGET_NAME] == NULL ||\n\t    tb[NFTA_TARGET_REV] == NULL ||\n\t    tb[NFTA_TARGET_INFO] == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttg_name = nla_data(tb[NFTA_TARGET_NAME]);\n\trev = ntohl(nla_get_be32(tb[NFTA_TARGET_REV]));\n\tfamily = ctx->family;\n\n\tif (strcmp(tg_name, XT_ERROR_TARGET) == 0 ||\n\t    strcmp(tg_name, XT_STANDARD_TARGET) == 0 ||\n\t    strcmp(tg_name, \"standard\") == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttarget = xt_request_find_target(family, tg_name, rev);\n\tif (IS_ERR(target))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (!target->target) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (target->targetsize > nla_len(tb[NFTA_TARGET_INFO])) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tops = kzalloc(sizeof(struct nft_expr_ops), GFP_KERNEL);\n\tif (!ops) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tops->type = &nft_target_type;\n\tops->size = NFT_EXPR_SIZE(XT_ALIGN(target->targetsize));\n\tops->init = nft_target_init;\n\tops->destroy = nft_target_destroy;\n\tops->dump = nft_target_dump;\n\tops->validate = nft_target_validate;\n\tops->data = target;\n\tops->reduce = NFT_REDUCE_READONLY;\n\n\tif (family == NFPROTO_BRIDGE)\n\t\tops->eval = nft_target_eval_bridge;\n\telse\n\t\tops->eval = nft_target_eval_xt;\n\n\treturn ops;\nerr:\n\tmodule_put(target->me);\n\treturn ERR_PTR(err);\n}\n\nstatic void nft_target_release_ops(const struct nft_expr_ops *ops)\n{\n\tstruct xt_target *target = ops->data;\n\n\tmodule_put(target->me);\n\tkfree(ops);\n}\n\nstatic struct nft_expr_type nft_target_type __read_mostly = {\n\t.name\t\t= \"target\",\n\t.select_ops\t= nft_target_select_ops,\n\t.release_ops\t= nft_target_release_ops,\n\t.policy\t\t= nft_target_policy,\n\t.maxattr\t= NFTA_TARGET_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_compat_module_init(void)\n{\n\tint ret;\n\n\tret = nft_register_expr(&nft_match_type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nft_register_expr(&nft_target_type);\n\tif (ret < 0)\n\t\tgoto err_match;\n\n\tret = nfnetlink_subsys_register(&nfnl_compat_subsys);\n\tif (ret < 0) {\n\t\tpr_err(\"nft_compat: cannot register with nfnetlink.\\n\");\n\t\tgoto err_target;\n\t}\n\n\treturn ret;\nerr_target:\n\tnft_unregister_expr(&nft_target_type);\nerr_match:\n\tnft_unregister_expr(&nft_match_type);\n\treturn ret;\n}\n\nstatic void __exit nft_compat_module_exit(void)\n{\n\tnfnetlink_subsys_unregister(&nfnl_compat_subsys);\n\tnft_unregister_expr(&nft_target_type);\n\tnft_unregister_expr(&nft_match_type);\n}\n\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_NFT_COMPAT);\n\nmodule_init(nft_compat_module_init);\nmodule_exit(nft_compat_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_ALIAS_NFT_EXPR(\"match\");\nMODULE_ALIAS_NFT_EXPR(\"target\");\nMODULE_DESCRIPTION(\"x_tables over nftables support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}