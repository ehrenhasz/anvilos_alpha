{
  "module_name": "xt_iprange.c",
  "hash_id": "04015a2b61feb8a5447ed0fc3d80999577cbe8c125e5004505cbd70ac3737a19",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_iprange.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_iprange.h>\n\nstatic bool\niprange_mt4(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_iprange_mtinfo *info = par->matchinfo;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tbool m;\n\n\tif (info->flags & IPRANGE_SRC) {\n\t\tm  = ntohl(iph->saddr) < ntohl(info->src_min.ip);\n\t\tm |= ntohl(iph->saddr) > ntohl(info->src_max.ip);\n\t\tm ^= !!(info->flags & IPRANGE_SRC_INV);\n\t\tif (m) {\n\t\t\tpr_debug(\"src IP %pI4 NOT in range %s%pI4-%pI4\\n\",\n\t\t\t         &iph->saddr,\n\t\t\t         (info->flags & IPRANGE_SRC_INV) ? \"(INV) \" : \"\",\n\t\t\t         &info->src_min.ip,\n\t\t\t         &info->src_max.ip);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (info->flags & IPRANGE_DST) {\n\t\tm  = ntohl(iph->daddr) < ntohl(info->dst_min.ip);\n\t\tm |= ntohl(iph->daddr) > ntohl(info->dst_max.ip);\n\t\tm ^= !!(info->flags & IPRANGE_DST_INV);\n\t\tif (m) {\n\t\t\tpr_debug(\"dst IP %pI4 NOT in range %s%pI4-%pI4\\n\",\n\t\t\t         &iph->daddr,\n\t\t\t         (info->flags & IPRANGE_DST_INV) ? \"(INV) \" : \"\",\n\t\t\t         &info->dst_min.ip,\n\t\t\t         &info->dst_max.ip);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic inline int\niprange_ipv6_lt(const struct in6_addr *a, const struct in6_addr *b)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (a->s6_addr32[i] != b->s6_addr32[i])\n\t\t\treturn ntohl(a->s6_addr32[i]) < ntohl(b->s6_addr32[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic bool\niprange_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_iprange_mtinfo *info = par->matchinfo;\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tbool m;\n\n\tif (info->flags & IPRANGE_SRC) {\n\t\tm  = iprange_ipv6_lt(&iph->saddr, &info->src_min.in6);\n\t\tm |= iprange_ipv6_lt(&info->src_max.in6, &iph->saddr);\n\t\tm ^= !!(info->flags & IPRANGE_SRC_INV);\n\t\tif (m) {\n\t\t\tpr_debug(\"src IP %pI6 NOT in range %s%pI6-%pI6\\n\",\n\t\t\t\t &iph->saddr,\n\t\t\t\t (info->flags & IPRANGE_SRC_INV) ? \"(INV) \" : \"\",\n\t\t\t\t &info->src_min.in6,\n\t\t\t\t &info->src_max.in6);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (info->flags & IPRANGE_DST) {\n\t\tm  = iprange_ipv6_lt(&iph->daddr, &info->dst_min.in6);\n\t\tm |= iprange_ipv6_lt(&info->dst_max.in6, &iph->daddr);\n\t\tm ^= !!(info->flags & IPRANGE_DST_INV);\n\t\tif (m) {\n\t\t\tpr_debug(\"dst IP %pI6 NOT in range %s%pI6-%pI6\\n\",\n\t\t\t\t &iph->daddr,\n\t\t\t\t (info->flags & IPRANGE_DST_INV) ? \"(INV) \" : \"\",\n\t\t\t\t &info->dst_min.in6,\n\t\t\t\t &info->dst_max.in6);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic struct xt_match iprange_mt_reg[] __read_mostly = {\n\t{\n\t\t.name      = \"iprange\",\n\t\t.revision  = 1,\n\t\t.family    = NFPROTO_IPV4,\n\t\t.match     = iprange_mt4,\n\t\t.matchsize = sizeof(struct xt_iprange_mtinfo),\n\t\t.me        = THIS_MODULE,\n\t},\n\t{\n\t\t.name      = \"iprange\",\n\t\t.revision  = 1,\n\t\t.family    = NFPROTO_IPV6,\n\t\t.match     = iprange_mt6,\n\t\t.matchsize = sizeof(struct xt_iprange_mtinfo),\n\t\t.me        = THIS_MODULE,\n\t},\n};\n\nstatic int __init iprange_mt_init(void)\n{\n\treturn xt_register_matches(iprange_mt_reg, ARRAY_SIZE(iprange_mt_reg));\n}\n\nstatic void __exit iprange_mt_exit(void)\n{\n\txt_unregister_matches(iprange_mt_reg, ARRAY_SIZE(iprange_mt_reg));\n}\n\nmodule_init(iprange_mt_init);\nmodule_exit(iprange_mt_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jozsef Kadlecsik <kadlec@netfilter.org>\");\nMODULE_AUTHOR(\"Jan Engelhardt <jengelh@medozas.de>\");\nMODULE_DESCRIPTION(\"Xtables: arbitrary IPv4 range matching\");\nMODULE_ALIAS(\"ipt_iprange\");\nMODULE_ALIAS(\"ip6t_iprange\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}