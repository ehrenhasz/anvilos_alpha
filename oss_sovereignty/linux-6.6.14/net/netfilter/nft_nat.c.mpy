{
  "module_name": "nft_nat.c",
  "hash_id": "7ad577f4c912ce16740391f92275e53814252160d1ad6cabf4273733dd16700e",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_nat.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/string.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/ip.h>\n\nstruct nft_nat {\n\tu8\t\t\tsreg_addr_min;\n\tu8\t\t\tsreg_addr_max;\n\tu8\t\t\tsreg_proto_min;\n\tu8\t\t\tsreg_proto_max;\n\tenum nf_nat_manip_type  type:8;\n\tu8\t\t\tfamily;\n\tu16\t\t\tflags;\n};\n\nstatic void nft_nat_setup_addr(struct nf_nat_range2 *range,\n\t\t\t       const struct nft_regs *regs,\n\t\t\t       const struct nft_nat *priv)\n{\n\tswitch (priv->family) {\n\tcase AF_INET:\n\t\trange->min_addr.ip = (__force __be32)\n\t\t\t\tregs->data[priv->sreg_addr_min];\n\t\trange->max_addr.ip = (__force __be32)\n\t\t\t\tregs->data[priv->sreg_addr_max];\n\t\tbreak;\n\tcase AF_INET6:\n\t\tmemcpy(range->min_addr.ip6, &regs->data[priv->sreg_addr_min],\n\t\t       sizeof(range->min_addr.ip6));\n\t\tmemcpy(range->max_addr.ip6, &regs->data[priv->sreg_addr_max],\n\t\t       sizeof(range->max_addr.ip6));\n\t\tbreak;\n\t}\n}\n\nstatic void nft_nat_setup_proto(struct nf_nat_range2 *range,\n\t\t\t\tconst struct nft_regs *regs,\n\t\t\t\tconst struct nft_nat *priv)\n{\n\trange->min_proto.all = (__force __be16)\n\t\tnft_reg_load16(&regs->data[priv->sreg_proto_min]);\n\trange->max_proto.all = (__force __be16)\n\t\tnft_reg_load16(&regs->data[priv->sreg_proto_max]);\n}\n\nstatic void nft_nat_setup_netmap(struct nf_nat_range2 *range,\n\t\t\t\t const struct nft_pktinfo *pkt,\n\t\t\t\t const struct nft_nat *priv)\n{\n\tstruct sk_buff *skb = pkt->skb;\n\tunion nf_inet_addr new_addr;\n\t__be32 netmask;\n\tint i, len = 0;\n\n\tswitch (priv->type) {\n\tcase NFT_NAT_SNAT:\n\t\tif (nft_pf(pkt) == NFPROTO_IPV4) {\n\t\t\tnew_addr.ip = ip_hdr(skb)->saddr;\n\t\t\tlen = sizeof(struct in_addr);\n\t\t} else {\n\t\t\tnew_addr.in6 = ipv6_hdr(skb)->saddr;\n\t\t\tlen = sizeof(struct in6_addr);\n\t\t}\n\t\tbreak;\n\tcase NFT_NAT_DNAT:\n\t\tif (nft_pf(pkt) == NFPROTO_IPV4) {\n\t\t\tnew_addr.ip = ip_hdr(skb)->daddr;\n\t\t\tlen = sizeof(struct in_addr);\n\t\t} else {\n\t\t\tnew_addr.in6 = ipv6_hdr(skb)->daddr;\n\t\t\tlen = sizeof(struct in6_addr);\n\t\t}\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < len / sizeof(__be32); i++) {\n\t\tnetmask = ~(range->min_addr.ip6[i] ^ range->max_addr.ip6[i]);\n\t\tnew_addr.ip6[i] &= ~netmask;\n\t\tnew_addr.ip6[i] |= range->min_addr.ip6[i] & netmask;\n\t}\n\n\trange->min_addr = new_addr;\n\trange->max_addr = new_addr;\n}\n\nstatic void nft_nat_eval(const struct nft_expr *expr,\n\t\t\t struct nft_regs *regs,\n\t\t\t const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_nat *priv = nft_expr_priv(expr);\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(pkt->skb, &ctinfo);\n\tstruct nf_nat_range2 range;\n\n\tmemset(&range, 0, sizeof(range));\n\n\tif (priv->sreg_addr_min) {\n\t\tnft_nat_setup_addr(&range, regs, priv);\n\t\tif (priv->flags & NF_NAT_RANGE_NETMAP)\n\t\t\tnft_nat_setup_netmap(&range, pkt, priv);\n\t}\n\n\tif (priv->sreg_proto_min)\n\t\tnft_nat_setup_proto(&range, regs, priv);\n\n\trange.flags = priv->flags;\n\n\tregs->verdict.code = nf_nat_setup_info(ct, &range, priv->type);\n}\n\nstatic const struct nla_policy nft_nat_policy[NFTA_NAT_MAX + 1] = {\n\t[NFTA_NAT_TYPE]\t\t = { .type = NLA_U32 },\n\t[NFTA_NAT_FAMILY]\t = { .type = NLA_U32 },\n\t[NFTA_NAT_REG_ADDR_MIN]\t = { .type = NLA_U32 },\n\t[NFTA_NAT_REG_ADDR_MAX]\t = { .type = NLA_U32 },\n\t[NFTA_NAT_REG_PROTO_MIN] = { .type = NLA_U32 },\n\t[NFTA_NAT_REG_PROTO_MAX] = { .type = NLA_U32 },\n\t[NFTA_NAT_FLAGS]\t =\n\t\tNLA_POLICY_MASK(NLA_BE32, NF_NAT_RANGE_MASK),\n};\n\nstatic int nft_nat_validate(const struct nft_ctx *ctx,\n\t\t\t    const struct nft_expr *expr,\n\t\t\t    const struct nft_data **data)\n{\n\tstruct nft_nat *priv = nft_expr_priv(expr);\n\tint err;\n\n\terr = nft_chain_validate_dependency(ctx->chain, NFT_CHAIN_T_NAT);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (priv->type) {\n\tcase NFT_NAT_SNAT:\n\t\terr = nft_chain_validate_hooks(ctx->chain,\n\t\t\t\t\t       (1 << NF_INET_POST_ROUTING) |\n\t\t\t\t\t       (1 << NF_INET_LOCAL_IN));\n\t\tbreak;\n\tcase NFT_NAT_DNAT:\n\t\terr = nft_chain_validate_hooks(ctx->chain,\n\t\t\t\t\t       (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t\t       (1 << NF_INET_LOCAL_OUT));\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int nft_nat_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t\tconst struct nlattr * const tb[])\n{\n\tstruct nft_nat *priv = nft_expr_priv(expr);\n\tunsigned int alen, plen;\n\tu32 family;\n\tint err;\n\n\tif (tb[NFTA_NAT_TYPE] == NULL ||\n\t    (tb[NFTA_NAT_REG_ADDR_MIN] == NULL &&\n\t     tb[NFTA_NAT_REG_PROTO_MIN] == NULL))\n\t\treturn -EINVAL;\n\n\tswitch (ntohl(nla_get_be32(tb[NFTA_NAT_TYPE]))) {\n\tcase NFT_NAT_SNAT:\n\t\tpriv->type = NF_NAT_MANIP_SRC;\n\t\tbreak;\n\tcase NFT_NAT_DNAT:\n\t\tpriv->type = NF_NAT_MANIP_DST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[NFTA_NAT_FAMILY] == NULL)\n\t\treturn -EINVAL;\n\n\tfamily = ntohl(nla_get_be32(tb[NFTA_NAT_FAMILY]));\n\tif (ctx->family != NFPROTO_INET && ctx->family != family)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (family) {\n\tcase NFPROTO_IPV4:\n\t\talen = sizeof_field(struct nf_nat_range, min_addr.ip);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\talen = sizeof_field(struct nf_nat_range, min_addr.ip6);\n\t\tbreak;\n\tdefault:\n\t\tif (tb[NFTA_NAT_REG_ADDR_MIN])\n\t\t\treturn -EAFNOSUPPORT;\n\t\tbreak;\n\t}\n\tpriv->family = family;\n\n\tif (tb[NFTA_NAT_REG_ADDR_MIN]) {\n\t\terr = nft_parse_register_load(tb[NFTA_NAT_REG_ADDR_MIN],\n\t\t\t\t\t      &priv->sreg_addr_min, alen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tb[NFTA_NAT_REG_ADDR_MAX]) {\n\t\t\terr = nft_parse_register_load(tb[NFTA_NAT_REG_ADDR_MAX],\n\t\t\t\t\t\t      &priv->sreg_addr_max,\n\t\t\t\t\t\t      alen);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tpriv->sreg_addr_max = priv->sreg_addr_min;\n\t\t}\n\n\t\tpriv->flags |= NF_NAT_RANGE_MAP_IPS;\n\t}\n\n\tplen = sizeof_field(struct nf_nat_range, min_proto.all);\n\tif (tb[NFTA_NAT_REG_PROTO_MIN]) {\n\t\terr = nft_parse_register_load(tb[NFTA_NAT_REG_PROTO_MIN],\n\t\t\t\t\t      &priv->sreg_proto_min, plen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tb[NFTA_NAT_REG_PROTO_MAX]) {\n\t\t\terr = nft_parse_register_load(tb[NFTA_NAT_REG_PROTO_MAX],\n\t\t\t\t\t\t      &priv->sreg_proto_max,\n\t\t\t\t\t\t      plen);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tpriv->sreg_proto_max = priv->sreg_proto_min;\n\t\t}\n\n\t\tpriv->flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\n\t}\n\n\tif (tb[NFTA_NAT_FLAGS])\n\t\tpriv->flags |= ntohl(nla_get_be32(tb[NFTA_NAT_FLAGS]));\n\n\treturn nf_ct_netns_get(ctx->net, family);\n}\n\nstatic int nft_nat_dump(struct sk_buff *skb,\n\t\t\tconst struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_nat *priv = nft_expr_priv(expr);\n\n\tswitch (priv->type) {\n\tcase NF_NAT_MANIP_SRC:\n\t\tif (nla_put_be32(skb, NFTA_NAT_TYPE, htonl(NFT_NAT_SNAT)))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase NF_NAT_MANIP_DST:\n\t\tif (nla_put_be32(skb, NFTA_NAT_TYPE, htonl(NFT_NAT_DNAT)))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\n\tif (nla_put_be32(skb, NFTA_NAT_FAMILY, htonl(priv->family)))\n\t\tgoto nla_put_failure;\n\n\tif (priv->sreg_addr_min) {\n\t\tif (nft_dump_register(skb, NFTA_NAT_REG_ADDR_MIN,\n\t\t\t\t      priv->sreg_addr_min) ||\n\t\t    nft_dump_register(skb, NFTA_NAT_REG_ADDR_MAX,\n\t\t\t\t      priv->sreg_addr_max))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (priv->sreg_proto_min) {\n\t\tif (nft_dump_register(skb, NFTA_NAT_REG_PROTO_MIN,\n\t\t\t\t      priv->sreg_proto_min) ||\n\t\t    nft_dump_register(skb, NFTA_NAT_REG_PROTO_MAX,\n\t\t\t\t      priv->sreg_proto_max))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (priv->flags != 0) {\n\t\tif (nla_put_be32(skb, NFTA_NAT_FLAGS, htonl(priv->flags)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic void\nnft_nat_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\n{\n\tconst struct nft_nat *priv = nft_expr_priv(expr);\n\n\tnf_ct_netns_put(ctx->net, priv->family);\n}\n\nstatic struct nft_expr_type nft_nat_type;\nstatic const struct nft_expr_ops nft_nat_ops = {\n\t.type           = &nft_nat_type,\n\t.size           = NFT_EXPR_SIZE(sizeof(struct nft_nat)),\n\t.eval           = nft_nat_eval,\n\t.init           = nft_nat_init,\n\t.destroy        = nft_nat_destroy,\n\t.dump           = nft_nat_dump,\n\t.validate\t= nft_nat_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_nat_type __read_mostly = {\n\t.name           = \"nat\",\n\t.ops            = &nft_nat_ops,\n\t.policy         = nft_nat_policy,\n\t.maxattr        = NFTA_NAT_MAX,\n\t.owner          = THIS_MODULE,\n};\n\n#ifdef CONFIG_NF_TABLES_INET\nstatic void nft_nat_inet_eval(const struct nft_expr *expr,\n\t\t\t      struct nft_regs *regs,\n\t\t\t      const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_nat *priv = nft_expr_priv(expr);\n\n\tif (priv->family == nft_pf(pkt) ||\n\t    priv->family == NFPROTO_INET)\n\t\tnft_nat_eval(expr, regs, pkt);\n}\n\nstatic const struct nft_expr_ops nft_nat_inet_ops = {\n\t.type           = &nft_nat_type,\n\t.size           = NFT_EXPR_SIZE(sizeof(struct nft_nat)),\n\t.eval           = nft_nat_inet_eval,\n\t.init           = nft_nat_init,\n\t.destroy        = nft_nat_destroy,\n\t.dump           = nft_nat_dump,\n\t.validate\t= nft_nat_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_inet_nat_type __read_mostly = {\n\t.name           = \"nat\",\n\t.family\t\t= NFPROTO_INET,\n\t.ops            = &nft_nat_inet_ops,\n\t.policy         = nft_nat_policy,\n\t.maxattr        = NFTA_NAT_MAX,\n\t.owner          = THIS_MODULE,\n};\n\nstatic int nft_nat_inet_module_init(void)\n{\n\treturn nft_register_expr(&nft_inet_nat_type);\n}\n\nstatic void nft_nat_inet_module_exit(void)\n{\n\tnft_unregister_expr(&nft_inet_nat_type);\n}\n#else\nstatic int nft_nat_inet_module_init(void) { return 0; }\nstatic void nft_nat_inet_module_exit(void) { }\n#endif\n\nstatic int __init nft_nat_module_init(void)\n{\n\tint ret = nft_nat_inet_module_init();\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = nft_register_expr(&nft_nat_type);\n\tif (ret)\n\t\tnft_nat_inet_module_exit();\n\n\treturn ret;\n}\n\nstatic void __exit nft_nat_module_exit(void)\n{\n\tnft_nat_inet_module_exit();\n\tnft_unregister_expr(&nft_nat_type);\n}\n\nmodule_init(nft_nat_module_init);\nmodule_exit(nft_nat_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tomasz Bursztyka <tomasz.bursztyka@linux.intel.com>\");\nMODULE_ALIAS_NFT_EXPR(\"nat\");\nMODULE_DESCRIPTION(\"Network Address Translation support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}