{
  "module_name": "nft_hash.c",
  "hash_id": "7e0f2c90ef6d0f087b83ae4cb9d34513d457fabdc1eb9029af4d62dcc1e9cddf",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_hash.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <linux/jhash.h>\n\nstruct nft_jhash {\n\tu8\t\t\tsreg;\n\tu8\t\t\tdreg;\n\tu8\t\t\tlen;\n\tbool\t\t\tautogen_seed:1;\n\tu32\t\t\tmodulus;\n\tu32\t\t\tseed;\n\tu32\t\t\toffset;\n};\n\nstatic void nft_jhash_eval(const struct nft_expr *expr,\n\t\t\t   struct nft_regs *regs,\n\t\t\t   const struct nft_pktinfo *pkt)\n{\n\tstruct nft_jhash *priv = nft_expr_priv(expr);\n\tconst void *data = &regs->data[priv->sreg];\n\tu32 h;\n\n\th = reciprocal_scale(jhash(data, priv->len, priv->seed),\n\t\t\t     priv->modulus);\n\n\tregs->data[priv->dreg] = h + priv->offset;\n}\n\nstruct nft_symhash {\n\tu8\t\t\tdreg;\n\tu32\t\t\tmodulus;\n\tu32\t\t\toffset;\n};\n\nstatic void nft_symhash_eval(const struct nft_expr *expr,\n\t\t\t     struct nft_regs *regs,\n\t\t\t     const struct nft_pktinfo *pkt)\n{\n\tstruct nft_symhash *priv = nft_expr_priv(expr);\n\tstruct sk_buff *skb = pkt->skb;\n\tu32 h;\n\n\th = reciprocal_scale(__skb_get_hash_symmetric(skb), priv->modulus);\n\n\tregs->data[priv->dreg] = h + priv->offset;\n}\n\nstatic const struct nla_policy nft_hash_policy[NFTA_HASH_MAX + 1] = {\n\t[NFTA_HASH_SREG]\t= { .type = NLA_U32 },\n\t[NFTA_HASH_DREG]\t= { .type = NLA_U32 },\n\t[NFTA_HASH_LEN]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_HASH_MODULUS]\t= { .type = NLA_U32 },\n\t[NFTA_HASH_SEED]\t= { .type = NLA_U32 },\n\t[NFTA_HASH_OFFSET]\t= { .type = NLA_U32 },\n\t[NFTA_HASH_TYPE]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_jhash_init(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_jhash *priv = nft_expr_priv(expr);\n\tu32 len;\n\tint err;\n\n\tif (!tb[NFTA_HASH_SREG] ||\n\t    !tb[NFTA_HASH_DREG] ||\n\t    !tb[NFTA_HASH_LEN]  ||\n\t    !tb[NFTA_HASH_MODULUS])\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_HASH_OFFSET])\n\t\tpriv->offset = ntohl(nla_get_be32(tb[NFTA_HASH_OFFSET]));\n\n\terr = nft_parse_u32_check(tb[NFTA_HASH_LEN], U8_MAX, &len);\n\tif (err < 0)\n\t\treturn err;\n\tif (len == 0)\n\t\treturn -ERANGE;\n\n\tpriv->len = len;\n\n\terr = nft_parse_register_load(tb[NFTA_HASH_SREG], &priv->sreg, len);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->modulus = ntohl(nla_get_be32(tb[NFTA_HASH_MODULUS]));\n\tif (priv->modulus < 1)\n\t\treturn -ERANGE;\n\n\tif (priv->offset + priv->modulus - 1 < priv->offset)\n\t\treturn -EOVERFLOW;\n\n\tif (tb[NFTA_HASH_SEED]) {\n\t\tpriv->seed = ntohl(nla_get_be32(tb[NFTA_HASH_SEED]));\n\t} else {\n\t\tpriv->autogen_seed = true;\n\t\tget_random_bytes(&priv->seed, sizeof(priv->seed));\n\t}\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_HASH_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, sizeof(u32));\n}\n\nstatic int nft_symhash_init(const struct nft_ctx *ctx,\n\t\t\t    const struct nft_expr *expr,\n\t\t\t    const struct nlattr * const tb[])\n{\n\tstruct nft_symhash *priv = nft_expr_priv(expr);\n\n\tif (!tb[NFTA_HASH_DREG]    ||\n\t    !tb[NFTA_HASH_MODULUS])\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_HASH_OFFSET])\n\t\tpriv->offset = ntohl(nla_get_be32(tb[NFTA_HASH_OFFSET]));\n\n\tpriv->modulus = ntohl(nla_get_be32(tb[NFTA_HASH_MODULUS]));\n\tif (priv->modulus < 1)\n\t\treturn -ERANGE;\n\n\tif (priv->offset + priv->modulus - 1 < priv->offset)\n\t\treturn -EOVERFLOW;\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_HASH_DREG],\n\t\t\t\t\t&priv->dreg, NULL, NFT_DATA_VALUE,\n\t\t\t\t\tsizeof(u32));\n}\n\nstatic int nft_jhash_dump(struct sk_buff *skb,\n\t\t\t  const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_jhash *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_HASH_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_HASH_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_HASH_LEN, htonl(priv->len)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_HASH_MODULUS, htonl(priv->modulus)))\n\t\tgoto nla_put_failure;\n\tif (!priv->autogen_seed &&\n\t    nla_put_be32(skb, NFTA_HASH_SEED, htonl(priv->seed)))\n\t\tgoto nla_put_failure;\n\tif (priv->offset != 0)\n\t\tif (nla_put_be32(skb, NFTA_HASH_OFFSET, htonl(priv->offset)))\n\t\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_HASH_TYPE, htonl(NFT_HASH_JENKINS)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic bool nft_jhash_reduce(struct nft_regs_track *track,\n\t\t\t     const struct nft_expr *expr)\n{\n\tconst struct nft_jhash *priv = nft_expr_priv(expr);\n\n\tnft_reg_track_cancel(track, priv->dreg, sizeof(u32));\n\n\treturn false;\n}\n\nstatic int nft_symhash_dump(struct sk_buff *skb,\n\t\t\t    const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_symhash *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_HASH_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_HASH_MODULUS, htonl(priv->modulus)))\n\t\tgoto nla_put_failure;\n\tif (priv->offset != 0)\n\t\tif (nla_put_be32(skb, NFTA_HASH_OFFSET, htonl(priv->offset)))\n\t\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_HASH_TYPE, htonl(NFT_HASH_SYM)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic bool nft_symhash_reduce(struct nft_regs_track *track,\n\t\t\t       const struct nft_expr *expr)\n{\n\tstruct nft_symhash *priv = nft_expr_priv(expr);\n\tstruct nft_symhash *symhash;\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, sizeof(u32));\n\t\treturn false;\n\t}\n\n\tsymhash = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->offset != symhash->offset ||\n\t    priv->modulus != symhash->modulus) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, sizeof(u32));\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct nft_expr_type nft_hash_type;\nstatic const struct nft_expr_ops nft_jhash_ops = {\n\t.type\t\t= &nft_hash_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_jhash)),\n\t.eval\t\t= nft_jhash_eval,\n\t.init\t\t= nft_jhash_init,\n\t.dump\t\t= nft_jhash_dump,\n\t.reduce\t\t= nft_jhash_reduce,\n};\n\nstatic const struct nft_expr_ops nft_symhash_ops = {\n\t.type\t\t= &nft_hash_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_symhash)),\n\t.eval\t\t= nft_symhash_eval,\n\t.init\t\t= nft_symhash_init,\n\t.dump\t\t= nft_symhash_dump,\n\t.reduce\t\t= nft_symhash_reduce,\n};\n\nstatic const struct nft_expr_ops *\nnft_hash_select_ops(const struct nft_ctx *ctx,\n\t\t    const struct nlattr * const tb[])\n{\n\tu32 type;\n\n\tif (!tb[NFTA_HASH_TYPE])\n\t\treturn &nft_jhash_ops;\n\n\ttype = ntohl(nla_get_be32(tb[NFTA_HASH_TYPE]));\n\tswitch (type) {\n\tcase NFT_HASH_SYM:\n\t\treturn &nft_symhash_ops;\n\tcase NFT_HASH_JENKINS:\n\t\treturn &nft_jhash_ops;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\nstatic struct nft_expr_type nft_hash_type __read_mostly = {\n\t.name\t\t= \"hash\",\n\t.select_ops\t= nft_hash_select_ops,\n\t.policy\t\t= nft_hash_policy,\n\t.maxattr\t= NFTA_HASH_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_hash_module_init(void)\n{\n\treturn nft_register_expr(&nft_hash_type);\n}\n\nstatic void __exit nft_hash_module_exit(void)\n{\n\tnft_unregister_expr(&nft_hash_type);\n}\n\nmodule_init(nft_hash_module_init);\nmodule_exit(nft_hash_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Laura Garcia <nevola@gmail.com>\");\nMODULE_ALIAS_NFT_EXPR(\"hash\");\nMODULE_DESCRIPTION(\"Netfilter nftables hash module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}