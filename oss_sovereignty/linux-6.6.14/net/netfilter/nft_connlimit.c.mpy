{
  "module_name": "nft_connlimit.c",
  "hash_id": "83354215da923e97c476f17d0eda647e4bca942984c0a573d2c7c37e2cd61f15",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_connlimit.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_count.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_tuple.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n\nstruct nft_connlimit {\n\tstruct nf_conncount_list\t*list;\n\tu32\t\t\t\tlimit;\n\tbool\t\t\t\tinvert;\n};\n\nstatic inline void nft_connlimit_do_eval(struct nft_connlimit *priv,\n\t\t\t\t\t struct nft_regs *regs,\n\t\t\t\t\t const struct nft_pktinfo *pkt,\n\t\t\t\t\t const struct nft_set_ext *ext)\n{\n\tconst struct nf_conntrack_zone *zone = &nf_ct_zone_dflt;\n\tconst struct nf_conntrack_tuple *tuple_ptr;\n\tstruct nf_conntrack_tuple tuple;\n\tenum ip_conntrack_info ctinfo;\n\tconst struct nf_conn *ct;\n\tunsigned int count;\n\n\ttuple_ptr = &tuple;\n\n\tct = nf_ct_get(pkt->skb, &ctinfo);\n\tif (ct != NULL) {\n\t\ttuple_ptr = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\t\tzone = nf_ct_zone(ct);\n\t} else if (!nf_ct_get_tuplepr(pkt->skb, skb_network_offset(pkt->skb),\n\t\t\t\t      nft_pf(pkt), nft_net(pkt), &tuple)) {\n\t\tregs->verdict.code = NF_DROP;\n\t\treturn;\n\t}\n\n\tif (nf_conncount_add(nft_net(pkt), priv->list, tuple_ptr, zone)) {\n\t\tregs->verdict.code = NF_DROP;\n\t\treturn;\n\t}\n\n\tcount = priv->list->count;\n\n\tif ((count > priv->limit) ^ priv->invert) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n}\n\nstatic int nft_connlimit_do_init(const struct nft_ctx *ctx,\n\t\t\t\t const struct nlattr * const tb[],\n\t\t\t\t struct nft_connlimit *priv)\n{\n\tbool invert = false;\n\tu32 flags, limit;\n\tint err;\n\n\tif (!tb[NFTA_CONNLIMIT_COUNT])\n\t\treturn -EINVAL;\n\n\tlimit = ntohl(nla_get_be32(tb[NFTA_CONNLIMIT_COUNT]));\n\n\tif (tb[NFTA_CONNLIMIT_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(tb[NFTA_CONNLIMIT_FLAGS]));\n\t\tif (flags & ~NFT_CONNLIMIT_F_INV)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (flags & NFT_CONNLIMIT_F_INV)\n\t\t\tinvert = true;\n\t}\n\n\tpriv->list = kmalloc(sizeof(*priv->list), GFP_KERNEL_ACCOUNT);\n\tif (!priv->list)\n\t\treturn -ENOMEM;\n\n\tnf_conncount_list_init(priv->list);\n\tpriv->limit\t= limit;\n\tpriv->invert\t= invert;\n\n\terr = nf_ct_netns_get(ctx->net, ctx->family);\n\tif (err < 0)\n\t\tgoto err_netns;\n\n\treturn 0;\nerr_netns:\n\tkfree(priv->list);\n\n\treturn err;\n}\n\nstatic void nft_connlimit_do_destroy(const struct nft_ctx *ctx,\n\t\t\t\t     struct nft_connlimit *priv)\n{\n\tnf_ct_netns_put(ctx->net, ctx->family);\n\tnf_conncount_cache_free(priv->list);\n\tkfree(priv->list);\n}\n\nstatic int nft_connlimit_do_dump(struct sk_buff *skb,\n\t\t\t\t struct nft_connlimit *priv)\n{\n\tif (nla_put_be32(skb, NFTA_CONNLIMIT_COUNT, htonl(priv->limit)))\n\t\tgoto nla_put_failure;\n\tif (priv->invert &&\n\t    nla_put_be32(skb, NFTA_CONNLIMIT_FLAGS, htonl(NFT_CONNLIMIT_F_INV)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic inline void nft_connlimit_obj_eval(struct nft_object *obj,\n\t\t\t\t\tstruct nft_regs *regs,\n\t\t\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tstruct nft_connlimit *priv = nft_obj_data(obj);\n\n\tnft_connlimit_do_eval(priv, regs, pkt, NULL);\n}\n\nstatic int nft_connlimit_obj_init(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nlattr * const tb[],\n\t\t\t\tstruct nft_object *obj)\n{\n\tstruct nft_connlimit *priv = nft_obj_data(obj);\n\n\treturn nft_connlimit_do_init(ctx, tb, priv);\n}\n\nstatic void nft_connlimit_obj_destroy(const struct nft_ctx *ctx,\n\t\t\t\t      struct nft_object *obj)\n{\n\tstruct nft_connlimit *priv = nft_obj_data(obj);\n\n\tnft_connlimit_do_destroy(ctx, priv);\n}\n\nstatic int nft_connlimit_obj_dump(struct sk_buff *skb,\n\t\t\t\t  struct nft_object *obj, bool reset)\n{\n\tstruct nft_connlimit *priv = nft_obj_data(obj);\n\n\treturn nft_connlimit_do_dump(skb, priv);\n}\n\nstatic const struct nla_policy nft_connlimit_policy[NFTA_CONNLIMIT_MAX + 1] = {\n\t[NFTA_CONNLIMIT_COUNT]\t= { .type = NLA_U32 },\n\t[NFTA_CONNLIMIT_FLAGS]\t= { .type = NLA_U32 },\n};\n\nstatic struct nft_object_type nft_connlimit_obj_type;\nstatic const struct nft_object_ops nft_connlimit_obj_ops = {\n\t.type\t\t= &nft_connlimit_obj_type,\n\t.size\t\t= sizeof(struct nft_connlimit),\n\t.eval\t\t= nft_connlimit_obj_eval,\n\t.init\t\t= nft_connlimit_obj_init,\n\t.destroy\t= nft_connlimit_obj_destroy,\n\t.dump\t\t= nft_connlimit_obj_dump,\n};\n\nstatic struct nft_object_type nft_connlimit_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_CONNLIMIT,\n\t.ops\t\t= &nft_connlimit_obj_ops,\n\t.maxattr\t= NFTA_CONNLIMIT_MAX,\n\t.policy\t\t= nft_connlimit_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void nft_connlimit_eval(const struct nft_expr *expr,\n\t\t\t       struct nft_regs *regs,\n\t\t\t       const struct nft_pktinfo *pkt)\n{\n\tstruct nft_connlimit *priv = nft_expr_priv(expr);\n\n\tnft_connlimit_do_eval(priv, regs, pkt, NULL);\n}\n\nstatic int nft_connlimit_dump(struct sk_buff *skb,\n\t\t\t      const struct nft_expr *expr, bool reset)\n{\n\tstruct nft_connlimit *priv = nft_expr_priv(expr);\n\n\treturn nft_connlimit_do_dump(skb, priv);\n}\n\nstatic int nft_connlimit_init(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr,\n\t\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_connlimit *priv = nft_expr_priv(expr);\n\n\treturn nft_connlimit_do_init(ctx, tb, priv);\n}\n\nstatic void nft_connlimit_destroy(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_connlimit *priv = nft_expr_priv(expr);\n\n\tnft_connlimit_do_destroy(ctx, priv);\n}\n\nstatic int nft_connlimit_clone(struct nft_expr *dst, const struct nft_expr *src)\n{\n\tstruct nft_connlimit *priv_dst = nft_expr_priv(dst);\n\tstruct nft_connlimit *priv_src = nft_expr_priv(src);\n\n\tpriv_dst->list = kmalloc(sizeof(*priv_dst->list), GFP_ATOMIC);\n\tif (!priv_dst->list)\n\t\treturn -ENOMEM;\n\n\tnf_conncount_list_init(priv_dst->list);\n\tpriv_dst->limit\t = priv_src->limit;\n\tpriv_dst->invert = priv_src->invert;\n\n\treturn 0;\n}\n\nstatic void nft_connlimit_destroy_clone(const struct nft_ctx *ctx,\n\t\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_connlimit *priv = nft_expr_priv(expr);\n\n\tnf_conncount_cache_free(priv->list);\n\tkfree(priv->list);\n}\n\nstatic bool nft_connlimit_gc(struct net *net, const struct nft_expr *expr)\n{\n\tstruct nft_connlimit *priv = nft_expr_priv(expr);\n\tbool ret;\n\n\tlocal_bh_disable();\n\tret = nf_conncount_gc_list(net, priv->list);\n\tlocal_bh_enable();\n\n\treturn ret;\n}\n\nstatic struct nft_expr_type nft_connlimit_type;\nstatic const struct nft_expr_ops nft_connlimit_ops = {\n\t.type\t\t= &nft_connlimit_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_connlimit)),\n\t.eval\t\t= nft_connlimit_eval,\n\t.init\t\t= nft_connlimit_init,\n\t.destroy\t= nft_connlimit_destroy,\n\t.clone\t\t= nft_connlimit_clone,\n\t.destroy_clone\t= nft_connlimit_destroy_clone,\n\t.dump\t\t= nft_connlimit_dump,\n\t.gc\t\t= nft_connlimit_gc,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_connlimit_type __read_mostly = {\n\t.name\t\t= \"connlimit\",\n\t.ops\t\t= &nft_connlimit_ops,\n\t.policy\t\t= nft_connlimit_policy,\n\t.maxattr\t= NFTA_CONNLIMIT_MAX,\n\t.flags\t\t= NFT_EXPR_STATEFUL | NFT_EXPR_GC,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_connlimit_module_init(void)\n{\n\tint err;\n\n\terr = nft_register_obj(&nft_connlimit_obj_type);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_register_expr(&nft_connlimit_type);\n\tif (err < 0)\n\t\tgoto err1;\n\n\treturn 0;\nerr1:\n\tnft_unregister_obj(&nft_connlimit_obj_type);\n\treturn err;\n}\n\nstatic void __exit nft_connlimit_module_exit(void)\n{\n\tnft_unregister_expr(&nft_connlimit_type);\n\tnft_unregister_obj(&nft_connlimit_obj_type);\n}\n\nmodule_init(nft_connlimit_module_init);\nmodule_exit(nft_connlimit_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso\");\nMODULE_ALIAS_NFT_EXPR(\"connlimit\");\nMODULE_ALIAS_NFT_OBJ(NFT_OBJECT_CONNLIMIT);\nMODULE_DESCRIPTION(\"nftables connlimit rule support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}