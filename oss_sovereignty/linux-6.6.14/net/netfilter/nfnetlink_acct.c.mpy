{
  "module_name": "nfnetlink_acct.c",
  "hash_id": "e5608936927c02a38f26072e3cda9763d2bb7a67ab48651d609a926b899278a8",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nfnetlink_acct.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/atomic.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <net/netns/generic.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_acct.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_DESCRIPTION(\"nfacct: Extended Netfilter accounting infrastructure\");\n\nstruct nf_acct {\n\tatomic64_t\t\tpkts;\n\tatomic64_t\t\tbytes;\n\tunsigned long\t\tflags;\n\tstruct list_head\thead;\n\trefcount_t\t\trefcnt;\n\tchar\t\t\tname[NFACCT_NAME_MAX];\n\tstruct rcu_head\t\trcu_head;\n\tchar\t\t\tdata[];\n};\n\nstruct nfacct_filter {\n\tu32 value;\n\tu32 mask;\n};\n\nstruct nfnl_acct_net {\n\tstruct list_head        nfnl_acct_list;\n};\n\nstatic unsigned int nfnl_acct_net_id __read_mostly;\n\nstatic inline struct nfnl_acct_net *nfnl_acct_pernet(struct net *net)\n{\n\treturn net_generic(net, nfnl_acct_net_id);\n}\n\n#define NFACCT_F_QUOTA (NFACCT_F_QUOTA_PKTS | NFACCT_F_QUOTA_BYTES)\n#define NFACCT_OVERQUOTA_BIT\t2\t \n\nstatic int nfnl_acct_new(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t const struct nlattr * const tb[])\n{\n\tstruct nfnl_acct_net *nfnl_acct_net = nfnl_acct_pernet(info->net);\n\tstruct nf_acct *nfacct, *matching = NULL;\n\tunsigned int size = 0;\n\tchar *acct_name;\n\tu32 flags = 0;\n\n\tif (!tb[NFACCT_NAME])\n\t\treturn -EINVAL;\n\n\tacct_name = nla_data(tb[NFACCT_NAME]);\n\tif (strlen(acct_name) == 0)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(nfacct, &nfnl_acct_net->nfnl_acct_list, head) {\n\t\tif (strncmp(nfacct->name, acct_name, NFACCT_NAME_MAX) != 0)\n\t\t\tcontinue;\n\n                if (info->nlh->nlmsg_flags & NLM_F_EXCL)\n\t\t\treturn -EEXIST;\n\n\t\tmatching = nfacct;\n\t\tbreak;\n        }\n\n\tif (matching) {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE) {\n\t\t\t \n\t\t\tatomic64_set(&matching->pkts, 0);\n\t\t\tatomic64_set(&matching->bytes, 0);\n\t\t\tsmp_mb__before_atomic();\n\t\t\t \n\t\t\tif ((matching->flags & NFACCT_F_QUOTA))\n\t\t\t\tclear_bit(NFACCT_OVERQUOTA_BIT,\n\t\t\t\t\t  &matching->flags);\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\tif (tb[NFACCT_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(tb[NFACCT_FLAGS]));\n\t\tif (flags & ~NFACCT_F_QUOTA)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif ((flags & NFACCT_F_QUOTA) == NFACCT_F_QUOTA)\n\t\t\treturn -EINVAL;\n\t\tif (flags & NFACCT_F_OVERQUOTA)\n\t\t\treturn -EINVAL;\n\t\tif ((flags & NFACCT_F_QUOTA) && !tb[NFACCT_QUOTA])\n\t\t\treturn -EINVAL;\n\n\t\tsize += sizeof(u64);\n\t}\n\n\tnfacct = kzalloc(sizeof(struct nf_acct) + size, GFP_KERNEL);\n\tif (nfacct == NULL)\n\t\treturn -ENOMEM;\n\n\tif (flags & NFACCT_F_QUOTA) {\n\t\tu64 *quota = (u64 *)nfacct->data;\n\n\t\t*quota = be64_to_cpu(nla_get_be64(tb[NFACCT_QUOTA]));\n\t\tnfacct->flags = flags;\n\t}\n\n\tnla_strscpy(nfacct->name, tb[NFACCT_NAME], NFACCT_NAME_MAX);\n\n\tif (tb[NFACCT_BYTES]) {\n\t\tatomic64_set(&nfacct->bytes,\n\t\t\t     be64_to_cpu(nla_get_be64(tb[NFACCT_BYTES])));\n\t}\n\tif (tb[NFACCT_PKTS]) {\n\t\tatomic64_set(&nfacct->pkts,\n\t\t\t     be64_to_cpu(nla_get_be64(tb[NFACCT_PKTS])));\n\t}\n\trefcount_set(&nfacct->refcnt, 1);\n\tlist_add_tail_rcu(&nfacct->head, &nfnl_acct_net->nfnl_acct_list);\n\treturn 0;\n}\n\nstatic int\nnfnl_acct_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\n\t\t   int event, struct nf_acct *acct)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned int flags = portid ? NLM_F_MULTI : 0;\n\tu64 pkts, bytes;\n\tu32 old_flags;\n\n\tevent = nfnl_msg_type(NFNL_SUBSYS_ACCT, event);\n\tnlh = nfnl_msg_put(skb, portid, seq, event, flags, AF_UNSPEC,\n\t\t\t   NFNETLINK_V0, 0);\n\tif (!nlh)\n\t\tgoto nlmsg_failure;\n\n\tif (nla_put_string(skb, NFACCT_NAME, acct->name))\n\t\tgoto nla_put_failure;\n\n\told_flags = acct->flags;\n\tif (type == NFNL_MSG_ACCT_GET_CTRZERO) {\n\t\tpkts = atomic64_xchg(&acct->pkts, 0);\n\t\tbytes = atomic64_xchg(&acct->bytes, 0);\n\t\tsmp_mb__before_atomic();\n\t\tif (acct->flags & NFACCT_F_QUOTA)\n\t\t\tclear_bit(NFACCT_OVERQUOTA_BIT, &acct->flags);\n\t} else {\n\t\tpkts = atomic64_read(&acct->pkts);\n\t\tbytes = atomic64_read(&acct->bytes);\n\t}\n\tif (nla_put_be64(skb, NFACCT_PKTS, cpu_to_be64(pkts),\n\t\t\t NFACCT_PAD) ||\n\t    nla_put_be64(skb, NFACCT_BYTES, cpu_to_be64(bytes),\n\t\t\t NFACCT_PAD) ||\n\t    nla_put_be32(skb, NFACCT_USE, htonl(refcount_read(&acct->refcnt))))\n\t\tgoto nla_put_failure;\n\tif (acct->flags & NFACCT_F_QUOTA) {\n\t\tu64 *quota = (u64 *)acct->data;\n\n\t\tif (nla_put_be32(skb, NFACCT_FLAGS, htonl(old_flags)) ||\n\t\t    nla_put_be64(skb, NFACCT_QUOTA, cpu_to_be64(*quota),\n\t\t\t\t NFACCT_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -1;\n}\n\nstatic int\nnfnl_acct_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nfnl_acct_net *nfnl_acct_net = nfnl_acct_pernet(net);\n\tstruct nf_acct *cur, *last;\n\tconst struct nfacct_filter *filter = cb->data;\n\n\tif (cb->args[2])\n\t\treturn 0;\n\n\tlast = (struct nf_acct *)cb->args[1];\n\tif (cb->args[1])\n\t\tcb->args[1] = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cur, &nfnl_acct_net->nfnl_acct_list, head) {\n\t\tif (last) {\n\t\t\tif (cur != last)\n\t\t\t\tcontinue;\n\n\t\t\tlast = NULL;\n\t\t}\n\n\t\tif (filter && (cur->flags & filter->mask) != filter->value)\n\t\t\tcontinue;\n\n\t\tif (nfnl_acct_fill_info(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq,\n\t\t\t\t       NFNL_MSG_TYPE(cb->nlh->nlmsg_type),\n\t\t\t\t       NFNL_MSG_ACCT_NEW, cur) < 0) {\n\t\t\tcb->args[1] = (unsigned long)cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cb->args[1])\n\t\tcb->args[2] = 1;\n\trcu_read_unlock();\n\treturn skb->len;\n}\n\nstatic int nfnl_acct_done(struct netlink_callback *cb)\n{\n\tkfree(cb->data);\n\treturn 0;\n}\n\nstatic const struct nla_policy filter_policy[NFACCT_FILTER_MAX + 1] = {\n\t[NFACCT_FILTER_MASK]\t= { .type = NLA_U32 },\n\t[NFACCT_FILTER_VALUE]\t= { .type = NLA_U32 },\n};\n\nstatic int nfnl_acct_start(struct netlink_callback *cb)\n{\n\tconst struct nlattr *const attr = cb->data;\n\tstruct nlattr *tb[NFACCT_FILTER_MAX + 1];\n\tstruct nfacct_filter *filter;\n\tint err;\n\n\tif (!attr)\n\t\treturn 0;\n\n\terr = nla_parse_nested_deprecated(tb, NFACCT_FILTER_MAX, attr,\n\t\t\t\t\t  filter_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFACCT_FILTER_MASK] || !tb[NFACCT_FILTER_VALUE])\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(struct nfacct_filter), GFP_KERNEL);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\tfilter->mask = ntohl(nla_get_be32(tb[NFACCT_FILTER_MASK]));\n\tfilter->value = ntohl(nla_get_be32(tb[NFACCT_FILTER_VALUE]));\n\tcb->data = filter;\n\n\treturn 0;\n}\n\nstatic int nfnl_acct_get(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t const struct nlattr * const tb[])\n{\n\tstruct nfnl_acct_net *nfnl_acct_net = nfnl_acct_pernet(info->net);\n\tint ret = -ENOENT;\n\tstruct nf_acct *cur;\n\tchar *acct_name;\n\n\tif (info->nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = nfnl_acct_dump,\n\t\t\t.start = nfnl_acct_start,\n\t\t\t.done = nfnl_acct_done,\n\t\t\t.data = (void *)tb[NFACCT_FILTER],\n\t\t};\n\n\t\treturn netlink_dump_start(info->sk, skb, info->nlh, &c);\n\t}\n\n\tif (!tb[NFACCT_NAME])\n\t\treturn -EINVAL;\n\tacct_name = nla_data(tb[NFACCT_NAME]);\n\n\tlist_for_each_entry(cur, &nfnl_acct_net->nfnl_acct_list, head) {\n\t\tstruct sk_buff *skb2;\n\n\t\tif (strncmp(cur->name, acct_name, NFACCT_NAME_MAX)!= 0)\n\t\t\tcontinue;\n\n\t\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (skb2 == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = nfnl_acct_fill_info(skb2, NETLINK_CB(skb).portid,\n\t\t\t\t\t  info->nlh->nlmsg_seq,\n\t\t\t\t\t  NFNL_MSG_TYPE(info->nlh->nlmsg_type),\n\t\t\t\t\t  NFNL_MSG_ACCT_NEW, cur);\n\t\tif (ret <= 0) {\n\t\t\tkfree_skb(skb2);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int nfnl_acct_try_del(struct nf_acct *cur)\n{\n\tint ret = 0;\n\n\t \n\tif (refcount_dec_if_one(&cur->refcnt)) {\n\t\t \n\t\tlist_del_rcu(&cur->head);\n\t\tkfree_rcu(cur, rcu_head);\n\t} else {\n\t\tret = -EBUSY;\n\t}\n\treturn ret;\n}\n\nstatic int nfnl_acct_del(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t const struct nlattr * const tb[])\n{\n\tstruct nfnl_acct_net *nfnl_acct_net = nfnl_acct_pernet(info->net);\n\tstruct nf_acct *cur, *tmp;\n\tint ret = -ENOENT;\n\tchar *acct_name;\n\n\tif (!tb[NFACCT_NAME]) {\n\t\tlist_for_each_entry_safe(cur, tmp, &nfnl_acct_net->nfnl_acct_list, head)\n\t\t\tnfnl_acct_try_del(cur);\n\n\t\treturn 0;\n\t}\n\tacct_name = nla_data(tb[NFACCT_NAME]);\n\n\tlist_for_each_entry(cur, &nfnl_acct_net->nfnl_acct_list, head) {\n\t\tif (strncmp(cur->name, acct_name, NFACCT_NAME_MAX) != 0)\n\t\t\tcontinue;\n\n\t\tret = nfnl_acct_try_del(cur);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct nla_policy nfnl_acct_policy[NFACCT_MAX+1] = {\n\t[NFACCT_NAME] = { .type = NLA_NUL_STRING, .len = NFACCT_NAME_MAX-1 },\n\t[NFACCT_BYTES] = { .type = NLA_U64 },\n\t[NFACCT_PKTS] = { .type = NLA_U64 },\n\t[NFACCT_FLAGS] = { .type = NLA_U32 },\n\t[NFACCT_QUOTA] = { .type = NLA_U64 },\n\t[NFACCT_FILTER] = {.type = NLA_NESTED },\n};\n\nstatic const struct nfnl_callback nfnl_acct_cb[NFNL_MSG_ACCT_MAX] = {\n\t[NFNL_MSG_ACCT_NEW] = {\n\t\t.call\t\t= nfnl_acct_new,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= NFACCT_MAX,\n\t\t.policy\t\t= nfnl_acct_policy\n\t},\n\t[NFNL_MSG_ACCT_GET] = {\n\t\t.call\t\t= nfnl_acct_get,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= NFACCT_MAX,\n\t\t.policy\t\t= nfnl_acct_policy\n\t},\n\t[NFNL_MSG_ACCT_GET_CTRZERO] = {\n\t\t.call\t\t= nfnl_acct_get,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= NFACCT_MAX,\n\t\t.policy\t\t= nfnl_acct_policy\n\t},\n\t[NFNL_MSG_ACCT_DEL] = {\n\t\t.call\t\t= nfnl_acct_del,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= NFACCT_MAX,\n\t\t.policy\t\t= nfnl_acct_policy\n\t},\n};\n\nstatic const struct nfnetlink_subsystem nfnl_acct_subsys = {\n\t.name\t\t\t\t= \"acct\",\n\t.subsys_id\t\t\t= NFNL_SUBSYS_ACCT,\n\t.cb_count\t\t\t= NFNL_MSG_ACCT_MAX,\n\t.cb\t\t\t\t= nfnl_acct_cb,\n};\n\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_ACCT);\n\nstruct nf_acct *nfnl_acct_find_get(struct net *net, const char *acct_name)\n{\n\tstruct nfnl_acct_net *nfnl_acct_net = nfnl_acct_pernet(net);\n\tstruct nf_acct *cur, *acct = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cur, &nfnl_acct_net->nfnl_acct_list, head) {\n\t\tif (strncmp(cur->name, acct_name, NFACCT_NAME_MAX)!= 0)\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(THIS_MODULE))\n\t\t\tgoto err;\n\n\t\tif (!refcount_inc_not_zero(&cur->refcnt)) {\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\tgoto err;\n\t\t}\n\n\t\tacct = cur;\n\t\tbreak;\n\t}\nerr:\n\trcu_read_unlock();\n\treturn acct;\n}\nEXPORT_SYMBOL_GPL(nfnl_acct_find_get);\n\nvoid nfnl_acct_put(struct nf_acct *acct)\n{\n\tif (refcount_dec_and_test(&acct->refcnt))\n\t\tkfree_rcu(acct, rcu_head);\n\n\tmodule_put(THIS_MODULE);\n}\nEXPORT_SYMBOL_GPL(nfnl_acct_put);\n\nvoid nfnl_acct_update(const struct sk_buff *skb, struct nf_acct *nfacct)\n{\n\tatomic64_inc(&nfacct->pkts);\n\tatomic64_add(skb->len, &nfacct->bytes);\n}\nEXPORT_SYMBOL_GPL(nfnl_acct_update);\n\nstatic void nfnl_overquota_report(struct net *net, struct nf_acct *nfacct)\n{\n\tint ret;\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn;\n\n\tret = nfnl_acct_fill_info(skb, 0, 0, NFNL_MSG_ACCT_OVERQUOTA, 0,\n\t\t\t\t  nfacct);\n\tif (ret <= 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tnfnetlink_broadcast(net, skb, 0, NFNLGRP_ACCT_QUOTA, GFP_ATOMIC);\n}\n\nint nfnl_acct_overquota(struct net *net, struct nf_acct *nfacct)\n{\n\tu64 now;\n\tu64 *quota;\n\tint ret = NFACCT_UNDERQUOTA;\n\n\t \n\tif (!(nfacct->flags & NFACCT_F_QUOTA))\n\t\treturn NFACCT_NO_QUOTA;\n\n\tquota = (u64 *)nfacct->data;\n\tnow = (nfacct->flags & NFACCT_F_QUOTA_PKTS) ?\n\t       atomic64_read(&nfacct->pkts) : atomic64_read(&nfacct->bytes);\n\n\tret = now > *quota;\n\n\tif (now >= *quota &&\n\t    !test_and_set_bit(NFACCT_OVERQUOTA_BIT, &nfacct->flags)) {\n\t\tnfnl_overquota_report(net, nfacct);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nfnl_acct_overquota);\n\nstatic int __net_init nfnl_acct_net_init(struct net *net)\n{\n\tINIT_LIST_HEAD(&nfnl_acct_pernet(net)->nfnl_acct_list);\n\n\treturn 0;\n}\n\nstatic void __net_exit nfnl_acct_net_exit(struct net *net)\n{\n\tstruct nfnl_acct_net *nfnl_acct_net = nfnl_acct_pernet(net);\n\tstruct nf_acct *cur, *tmp;\n\n\tlist_for_each_entry_safe(cur, tmp, &nfnl_acct_net->nfnl_acct_list, head) {\n\t\tlist_del_rcu(&cur->head);\n\n\t\tif (refcount_dec_and_test(&cur->refcnt))\n\t\t\tkfree_rcu(cur, rcu_head);\n\t}\n}\n\nstatic struct pernet_operations nfnl_acct_ops = {\n        .init   = nfnl_acct_net_init,\n        .exit   = nfnl_acct_net_exit,\n        .id     = &nfnl_acct_net_id,\n        .size   = sizeof(struct nfnl_acct_net),\n};\n\nstatic int __init nfnl_acct_init(void)\n{\n\tint ret;\n\n\tret = register_pernet_subsys(&nfnl_acct_ops);\n\tif (ret < 0) {\n\t\tpr_err(\"nfnl_acct_init: failed to register pernet ops\\n\");\n\t\tgoto err_out;\n\t}\n\n\tret = nfnetlink_subsys_register(&nfnl_acct_subsys);\n\tif (ret < 0) {\n\t\tpr_err(\"nfnl_acct_init: cannot register with nfnetlink.\\n\");\n\t\tgoto cleanup_pernet;\n\t}\n\treturn 0;\n\ncleanup_pernet:\n\tunregister_pernet_subsys(&nfnl_acct_ops);\nerr_out:\n\treturn ret;\n}\n\nstatic void __exit nfnl_acct_exit(void)\n{\n\tnfnetlink_subsys_unregister(&nfnl_acct_subsys);\n\tunregister_pernet_subsys(&nfnl_acct_ops);\n}\n\nmodule_init(nfnl_acct_init);\nmodule_exit(nfnl_acct_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}