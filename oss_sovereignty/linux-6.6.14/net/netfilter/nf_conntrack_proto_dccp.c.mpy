{
  "module_name": "nf_conntrack_proto_dccp.c",
  "hash_id": "0c5c7ba696f894bb3d9994d780e0f147d651b106f8a43be8b8e0419a9c612a5e",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_proto_dccp.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/dccp.h>\n#include <linux/slab.h>\n\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#include <linux/netfilter/nfnetlink_conntrack.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n#include <net/netfilter/nf_log.h>\n\n \n\n#define DCCP_MSL (2 * 60 * HZ)\n\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\nstatic const char * const dccp_state_names[] = {\n\t[CT_DCCP_NONE]\t\t= \"NONE\",\n\t[CT_DCCP_REQUEST]\t= \"REQUEST\",\n\t[CT_DCCP_RESPOND]\t= \"RESPOND\",\n\t[CT_DCCP_PARTOPEN]\t= \"PARTOPEN\",\n\t[CT_DCCP_OPEN]\t\t= \"OPEN\",\n\t[CT_DCCP_CLOSEREQ]\t= \"CLOSEREQ\",\n\t[CT_DCCP_CLOSING]\t= \"CLOSING\",\n\t[CT_DCCP_TIMEWAIT]\t= \"TIMEWAIT\",\n\t[CT_DCCP_IGNORE]\t= \"IGNORE\",\n\t[CT_DCCP_INVALID]\t= \"INVALID\",\n};\n#endif\n\n#define sNO\tCT_DCCP_NONE\n#define sRQ\tCT_DCCP_REQUEST\n#define sRS\tCT_DCCP_RESPOND\n#define sPO\tCT_DCCP_PARTOPEN\n#define sOP\tCT_DCCP_OPEN\n#define sCR\tCT_DCCP_CLOSEREQ\n#define sCG\tCT_DCCP_CLOSING\n#define sTW\tCT_DCCP_TIMEWAIT\n#define sIG\tCT_DCCP_IGNORE\n#define sIV\tCT_DCCP_INVALID\n\n \nstatic const u_int8_t\ndccp_state_table[CT_DCCP_ROLE_MAX + 1][DCCP_PKT_SYNCACK + 1][CT_DCCP_MAX + 1] = {\n\t[CT_DCCP_ROLE_CLIENT] = {\n\t\t[DCCP_PKT_REQUEST] = {\n\t\t \n\t\t\tsRQ, sRQ, sRS, sIG, sIG, sIG, sIG, sRQ,\n\t\t},\n\t\t[DCCP_PKT_RESPONSE] = {\n\t\t \n\t\t\tsIV, sIG, sIG, sIG, sIG, sIG, sIG, sIV,\n\t\t},\n\t\t[DCCP_PKT_ACK] = {\n\t\t \n\t\t\tsIV, sIV, sPO, sPO, sOP, sCR, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_DATA] = {\n\t\t \n\t\t\tsIV, sIV, sIV, sIV, sOP, sCR, sCG, sIV,\n\t\t},\n\t\t[DCCP_PKT_DATAACK] = {\n\t\t \n\t\t\tsIV, sIV, sPO, sPO, sOP, sCR, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSEREQ] = {\n\t\t \n\t\t\tsIV, sIV, sIV, sIV, sIV, sIV, sIV, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSE] = {\n\t\t \n\t\t\tsIV, sIV, sIV, sCG, sCG, sCG, sIV, sIV\n\t\t},\n\t\t[DCCP_PKT_RESET] = {\n\t\t \n\t\t\tsIV, sTW, sTW, sTW, sTW, sTW, sTW, sIG\n\t\t},\n\t\t[DCCP_PKT_SYNC] = {\n\t\t \n\t\t\tsIV, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t\t[DCCP_PKT_SYNCACK] = {\n\t\t \n\t\t\tsIV, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t},\n\t[CT_DCCP_ROLE_SERVER] = {\n\t\t[DCCP_PKT_REQUEST] = {\n\t\t \n\t\t\tsIV, sIG, sIG, sIG, sIG, sIG, sIG, sRQ\n\t\t},\n\t\t[DCCP_PKT_RESPONSE] = {\n\t\t \n\t\t\tsIV, sRS, sRS, sIG, sIG, sIG, sIG, sIV\n\t\t},\n\t\t[DCCP_PKT_ACK] = {\n\t\t \n\t\t\tsIV, sIV, sIV, sOP, sOP, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_DATA] = {\n\t\t \n\t\t\tsIV, sIV, sIV, sOP, sOP, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_DATAACK] = {\n\t\t \n\t\t\tsIV, sIV, sIV, sOP, sOP, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSEREQ] = {\n\t\t \n\t\t\tsIV, sIV, sIV, sCR, sCR, sCR, sCR, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSE] = {\n\t\t \n\t\t\tsIV, sIV, sIV, sCG, sCG, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_RESET] = {\n\t\t \n\t\t\tsIV, sTW, sTW, sTW, sTW, sTW, sTW, sTW, sIG\n\t\t},\n\t\t[DCCP_PKT_SYNC] = {\n\t\t \n\t\t\tsIV, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t\t[DCCP_PKT_SYNCACK] = {\n\t\t \n\t\t\tsIV, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t},\n};\n\nstatic noinline bool\ndccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t const struct dccp_hdr *dh,\n\t const struct nf_hook_state *hook_state)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct nf_dccp_net *dn;\n\tconst char *msg;\n\tu_int8_t state;\n\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = nf_dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tbreak;\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\n\nout_invalid:\n\tnf_ct_l4proto_log_invalid(skb, ct, hook_state, \"%s\", msg);\n\treturn false;\n}\n\nstatic u64 dccp_ack_seq(const struct dccp_hdr *dh)\n{\n\tconst struct dccp_hdr_ack_bits *dhack;\n\n\tdhack = (void *)dh + __dccp_basic_hdr_len(dh);\n\treturn ((u64)ntohs(dhack->dccph_ack_nr_high) << 32) +\n\t\t     ntohl(dhack->dccph_ack_nr_low);\n}\n\nstatic bool dccp_error(const struct dccp_hdr *dh,\n\t\t       struct sk_buff *skb, unsigned int dataoff,\n\t\t       const struct nf_hook_state *state)\n{\n\tstatic const unsigned long require_seq48 = 1 << DCCP_PKT_REQUEST |\n\t\t\t\t\t\t   1 << DCCP_PKT_RESPONSE |\n\t\t\t\t\t\t   1 << DCCP_PKT_CLOSEREQ |\n\t\t\t\t\t\t   1 << DCCP_PKT_CLOSE |\n\t\t\t\t\t\t   1 << DCCP_PKT_RESET |\n\t\t\t\t\t\t   1 << DCCP_PKT_SYNC |\n\t\t\t\t\t\t   1 << DCCP_PKT_SYNCACK;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\tu8 type;\n\n\tBUILD_BUG_ON(DCCP_PKT_INVALID >= BITS_PER_LONG);\n\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\n\tif (state->hook == NF_INET_PRE_ROUTING &&\n\t    state->net->ct.sysctl_checksum &&\n\t    nf_checksum_partial(skb, state->hook, dataoff, cscov,\n\t\t\t\tIPPROTO_DCCP, state->pf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\n\ttype = dh->dccph_type;\n\tif (type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (test_bit(type, &require_seq48) && !dh->dccph_x) {\n\t\tmsg = \"nf_ct_dccp: type lacks 48bit sequence numbers\";\n\t\tgoto out_invalid;\n\t}\n\n\treturn false;\nout_invalid:\n\tnf_l4proto_log_invalid(skb, state, IPPROTO_DCCP, \"%s\", msg);\n\treturn true;\n}\n\nstruct nf_conntrack_dccp_buf {\n\tstruct dccp_hdr dh;\t  \n\tstruct dccp_hdr_ext ext;  \n\tunion {\t\t\t  \n\t\tstruct dccp_hdr_ack_bits ack;\n\t\tstruct dccp_hdr_request req;\n\t\tstruct dccp_hdr_response response;\n\t\tstruct dccp_hdr_reset rst;\n\t} u;\n};\n\nstatic struct dccp_hdr *\ndccp_header_pointer(const struct sk_buff *skb, int offset, const struct dccp_hdr *dh,\n\t\t    struct nf_conntrack_dccp_buf *buf)\n{\n\tunsigned int hdrlen = __dccp_hdr_len(dh);\n\n\tif (hdrlen > sizeof(*buf))\n\t\treturn NULL;\n\n\treturn skb_header_pointer(skb, offset, hdrlen, buf);\n}\n\nint nf_conntrack_dccp_packet(struct nf_conn *ct, struct sk_buff *skb,\n\t\t\t     unsigned int dataoff,\n\t\t\t     enum ip_conntrack_info ctinfo,\n\t\t\t     const struct nf_hook_state *state)\n{\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct nf_conntrack_dccp_buf _dh;\n\tu_int8_t type, old_state, new_state;\n\tenum ct_dccp_roles role;\n\tunsigned int *timeouts;\n\tstruct dccp_hdr *dh;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(*dh), &_dh.dh);\n\tif (!dh)\n\t\treturn NF_DROP;\n\n\tif (dccp_error(dh, skb, dataoff, state))\n\t\treturn -NF_ACCEPT;\n\n\t \n\tdh = dccp_header_pointer(skb, dataoff, dh, &_dh);\n\tif (!dh)\n\t\treturn NF_DROP;\n\n\ttype = dh->dccph_type;\n\tif (!nf_ct_is_confirmed(ct) && !dccp_new(ct, skb, dh, state))\n\t\treturn -NF_ACCEPT;\n\n\tif (type == DCCP_PKT_RESET &&\n\t    !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\n\t\t \n\t\tnf_ct_kill_acct(ct, ctinfo, skb);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tspin_lock_bh(&ct->lock);\n\n\trole = ct->proto.dccp.role[dir];\n\told_state = ct->proto.dccp.state;\n\tnew_state = dccp_state_table[role][type][old_state];\n\n\tswitch (new_state) {\n\tcase CT_DCCP_REQUEST:\n\t\tif (old_state == CT_DCCP_TIMEWAIT &&\n\t\t    role == CT_DCCP_ROLE_SERVER) {\n\t\t\t \n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_SERVER;\n\t\t}\n\t\tbreak;\n\tcase CT_DCCP_RESPOND:\n\t\tif (old_state == CT_DCCP_REQUEST)\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\tbreak;\n\tcase CT_DCCP_PARTOPEN:\n\t\tif (old_state == CT_DCCP_RESPOND &&\n\t\t    type == DCCP_PKT_ACK &&\n\t\t    dccp_ack_seq(dh) == ct->proto.dccp.handshake_seq)\n\t\t\tset_bit(IPS_ASSURED_BIT, &ct->status);\n\t\tbreak;\n\tcase CT_DCCP_IGNORE:\n\t\t \n\t\tif (ct->proto.dccp.last_dir == !dir &&\n\t\t    ct->proto.dccp.last_pkt == DCCP_PKT_REQUEST &&\n\t\t    type == DCCP_PKT_RESPONSE) {\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_SERVER;\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\t\tnew_state = CT_DCCP_RESPOND;\n\t\t\tbreak;\n\t\t}\n\t\tct->proto.dccp.last_dir = dir;\n\t\tct->proto.dccp.last_pkt = type;\n\n\t\tspin_unlock_bh(&ct->lock);\n\t\tnf_ct_l4proto_log_invalid(skb, ct, state, \"%s\", \"invalid packet\");\n\t\treturn NF_ACCEPT;\n\tcase CT_DCCP_INVALID:\n\t\tspin_unlock_bh(&ct->lock);\n\t\tnf_ct_l4proto_log_invalid(skb, ct, state, \"%s\", \"invalid state transition\");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\tct->proto.dccp.last_dir = dir;\n\tct->proto.dccp.last_pkt = type;\n\tct->proto.dccp.state = new_state;\n\tspin_unlock_bh(&ct->lock);\n\n\tif (new_state != old_state)\n\t\tnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\n\n\ttimeouts = nf_ct_timeout_lookup(ct);\n\tif (!timeouts)\n\t\ttimeouts = nf_dccp_pernet(nf_ct_net(ct))->dccp_timeout;\n\tnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);\n\n\treturn NF_ACCEPT;\n}\n\nstatic bool dccp_can_early_drop(const struct nf_conn *ct)\n{\n\tswitch (ct->proto.dccp.state) {\n\tcase CT_DCCP_CLOSEREQ:\n\tcase CT_DCCP_CLOSING:\n\tcase CT_DCCP_TIMEWAIT:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\nstatic void dccp_print_conntrack(struct seq_file *s, struct nf_conn *ct)\n{\n\tseq_printf(s, \"%s \", dccp_state_names[ct->proto.dccp.state]);\n}\n#endif\n\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\nstatic int dccp_to_nlattr(struct sk_buff *skb, struct nlattr *nla,\n\t\t\t  struct nf_conn *ct, bool destroy)\n{\n\tstruct nlattr *nest_parms;\n\n\tspin_lock_bh(&ct->lock);\n\tnest_parms = nla_nest_start(skb, CTA_PROTOINFO_DCCP);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, CTA_PROTOINFO_DCCP_STATE, ct->proto.dccp.state))\n\t\tgoto nla_put_failure;\n\n\tif (destroy)\n\t\tgoto skip_state;\n\n\tif (nla_put_u8(skb, CTA_PROTOINFO_DCCP_ROLE,\n\t\t       ct->proto.dccp.role[IP_CT_DIR_ORIGINAL]) ||\n\t    nla_put_be64(skb, CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ,\n\t\t\t cpu_to_be64(ct->proto.dccp.handshake_seq),\n\t\t\t CTA_PROTOINFO_DCCP_PAD))\n\t\tgoto nla_put_failure;\nskip_state:\n\tnla_nest_end(skb, nest_parms);\n\tspin_unlock_bh(&ct->lock);\n\n\treturn 0;\n\nnla_put_failure:\n\tspin_unlock_bh(&ct->lock);\n\treturn -1;\n}\n\nstatic const struct nla_policy dccp_nla_policy[CTA_PROTOINFO_DCCP_MAX + 1] = {\n\t[CTA_PROTOINFO_DCCP_STATE]\t= { .type = NLA_U8 },\n\t[CTA_PROTOINFO_DCCP_ROLE]\t= { .type = NLA_U8 },\n\t[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ] = { .type = NLA_U64 },\n\t[CTA_PROTOINFO_DCCP_PAD]\t= { .type = NLA_UNSPEC },\n};\n\n#define DCCP_NLATTR_SIZE ( \\\n\tNLA_ALIGN(NLA_HDRLEN + 1) + \\\n\tNLA_ALIGN(NLA_HDRLEN + 1) + \\\n\tNLA_ALIGN(NLA_HDRLEN + sizeof(u64)) + \\\n\tNLA_ALIGN(NLA_HDRLEN + 0))\n\nstatic int nlattr_to_dccp(struct nlattr *cda[], struct nf_conn *ct)\n{\n\tstruct nlattr *attr = cda[CTA_PROTOINFO_DCCP];\n\tstruct nlattr *tb[CTA_PROTOINFO_DCCP_MAX + 1];\n\tint err;\n\n\tif (!attr)\n\t\treturn 0;\n\n\terr = nla_parse_nested_deprecated(tb, CTA_PROTOINFO_DCCP_MAX, attr,\n\t\t\t\t\t  dccp_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[CTA_PROTOINFO_DCCP_STATE] ||\n\t    !tb[CTA_PROTOINFO_DCCP_ROLE] ||\n\t    nla_get_u8(tb[CTA_PROTOINFO_DCCP_ROLE]) > CT_DCCP_ROLE_MAX ||\n\t    nla_get_u8(tb[CTA_PROTOINFO_DCCP_STATE]) >= CT_DCCP_IGNORE) {\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&ct->lock);\n\tct->proto.dccp.state = nla_get_u8(tb[CTA_PROTOINFO_DCCP_STATE]);\n\tif (nla_get_u8(tb[CTA_PROTOINFO_DCCP_ROLE]) == CT_DCCP_ROLE_CLIENT) {\n\t\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\t\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\t} else {\n\t\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_SERVER;\n\t\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_CLIENT;\n\t}\n\tif (tb[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ]) {\n\t\tct->proto.dccp.handshake_seq =\n\t\tbe64_to_cpu(nla_get_be64(tb[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ]));\n\t}\n\tspin_unlock_bh(&ct->lock);\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_cttimeout.h>\n\nstatic int dccp_timeout_nlattr_to_obj(struct nlattr *tb[],\n\t\t\t\t      struct net *net, void *data)\n{\n\tstruct nf_dccp_net *dn = nf_dccp_pernet(net);\n\tunsigned int *timeouts = data;\n\tint i;\n\n\tif (!timeouts)\n\t\t timeouts = dn->dccp_timeout;\n\n\t \n\tfor (i=0; i<CT_DCCP_MAX; i++)\n\t\ttimeouts[i] = dn->dccp_timeout[i];\n\n\t \n\tfor (i=CTA_TIMEOUT_DCCP_UNSPEC+1; i<CTA_TIMEOUT_DCCP_MAX+1; i++) {\n\t\tif (tb[i]) {\n\t\t\ttimeouts[i] = ntohl(nla_get_be32(tb[i])) * HZ;\n\t\t}\n\t}\n\n\ttimeouts[CTA_TIMEOUT_DCCP_UNSPEC] = timeouts[CTA_TIMEOUT_DCCP_REQUEST];\n\treturn 0;\n}\n\nstatic int\ndccp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\n{\n        const unsigned int *timeouts = data;\n\tint i;\n\n\tfor (i=CTA_TIMEOUT_DCCP_UNSPEC+1; i<CTA_TIMEOUT_DCCP_MAX+1; i++) {\n\t\tif (nla_put_be32(skb, i, htonl(timeouts[i] / HZ)))\n\t\t\tgoto nla_put_failure;\n\t}\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic const struct nla_policy\ndccp_timeout_nla_policy[CTA_TIMEOUT_DCCP_MAX+1] = {\n\t[CTA_TIMEOUT_DCCP_REQUEST]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_RESPOND]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_PARTOPEN]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_OPEN]\t\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_CLOSEREQ]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_CLOSING]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_TIMEWAIT]\t= { .type = NLA_U32 },\n};\n#endif  \n\nvoid nf_conntrack_dccp_init_net(struct net *net)\n{\n\tstruct nf_dccp_net *dn = nf_dccp_pernet(net);\n\n\t \n\tdn->dccp_loose = 1;\n\tdn->dccp_timeout[CT_DCCP_REQUEST]\t= 2 * DCCP_MSL;\n\tdn->dccp_timeout[CT_DCCP_RESPOND]\t= 4 * DCCP_MSL;\n\tdn->dccp_timeout[CT_DCCP_PARTOPEN]\t= 4 * DCCP_MSL;\n\tdn->dccp_timeout[CT_DCCP_OPEN]\t\t= 12 * 3600 * HZ;\n\tdn->dccp_timeout[CT_DCCP_CLOSEREQ]\t= 64 * HZ;\n\tdn->dccp_timeout[CT_DCCP_CLOSING]\t= 64 * HZ;\n\tdn->dccp_timeout[CT_DCCP_TIMEWAIT]\t= 2 * DCCP_MSL;\n\n\t \n\tdn->dccp_timeout[CT_DCCP_NONE] = dn->dccp_timeout[CT_DCCP_REQUEST];\n}\n\nconst struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp = {\n\t.l4proto\t\t= IPPROTO_DCCP,\n\t.can_early_drop\t\t= dccp_can_early_drop,\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\n\t.print_conntrack\t= dccp_print_conntrack,\n#endif\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.nlattr_size\t\t= DCCP_NLATTR_SIZE,\n\t.to_nlattr\t\t= dccp_to_nlattr,\n\t.from_nlattr\t\t= nlattr_to_dccp,\n\t.tuple_to_nlattr\t= nf_ct_port_tuple_to_nlattr,\n\t.nlattr_tuple_size\t= nf_ct_port_nlattr_tuple_size,\n\t.nlattr_to_tuple\t= nf_ct_port_nlattr_to_tuple,\n\t.nla_policy\t\t= nf_ct_port_nla_policy,\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\t.ctnl_timeout\t\t= {\n\t\t.nlattr_to_obj\t= dccp_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= dccp_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_DCCP_MAX,\n\t\t.obj_size\t= sizeof(unsigned int) * CT_DCCP_MAX,\n\t\t.nla_policy\t= dccp_timeout_nla_policy,\n\t},\n#endif  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}