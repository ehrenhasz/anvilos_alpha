{
  "module_name": "nft_tproxy.c",
  "hash_id": "c142c3dd6feee038cb05e71dad6697e620f15e9b5588ecf4545d47ea3018b741",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_tproxy.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tproxy.h>\n#include <net/inet_sock.h>\n#include <net/tcp.h>\n#include <linux/if_ether.h>\n#include <net/netfilter/ipv4/nf_defrag_ipv4.h>\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n#endif\n\nstruct nft_tproxy {\n\tu8\tsreg_addr;\n\tu8\tsreg_port;\n\tu8\tfamily;\n};\n\nstatic void nft_tproxy_eval_v4(const struct nft_expr *expr,\n\t\t\t       struct nft_regs *regs,\n\t\t\t       const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_tproxy *priv = nft_expr_priv(expr);\n\tstruct sk_buff *skb = pkt->skb;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct udphdr _hdr, *hp;\n\t__be32 taddr = 0;\n\t__be16 tport = 0;\n\tstruct sock *sk;\n\n\tif (pkt->tprot != IPPROTO_TCP &&\n\t    pkt->tprot != IPPROTO_UDP) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\thp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_hdr), &_hdr);\n\tif (!hp) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\t \n\tsk = nf_tproxy_get_sock_v4(nft_net(pkt), skb, iph->protocol,\n\t\t\t\t   iph->saddr, iph->daddr,\n\t\t\t\t   hp->source, hp->dest,\n\t\t\t\t   skb->dev, NF_TPROXY_LOOKUP_ESTABLISHED);\n\n\tif (priv->sreg_addr)\n\t\ttaddr = nft_reg_load_be32(&regs->data[priv->sreg_addr]);\n\ttaddr = nf_tproxy_laddr4(skb, taddr, iph->daddr);\n\n\tif (priv->sreg_port)\n\t\ttport = nft_reg_load_be16(&regs->data[priv->sreg_port]);\n\tif (!tport)\n\t\ttport = hp->dest;\n\n\t \n\tif (sk && sk->sk_state == TCP_TIME_WAIT) {\n\t\t \n\t\tsk = nf_tproxy_handle_time_wait4(nft_net(pkt), skb, taddr, tport, sk);\n\t} else if (!sk) {\n\t\t \n\t\tsk = nf_tproxy_get_sock_v4(nft_net(pkt), skb, iph->protocol,\n\t\t\t\t\t   iph->saddr, taddr,\n\t\t\t\t\t   hp->source, tport,\n\t\t\t\t\t   skb->dev, NF_TPROXY_LOOKUP_LISTENER);\n\t}\n\n\tif (sk && nf_tproxy_sk_is_transparent(sk))\n\t\tnf_tproxy_assign_sock(skb, sk);\n\telse\n\t\tregs->verdict.code = NFT_BREAK;\n}\n\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\nstatic void nft_tproxy_eval_v6(const struct nft_expr *expr,\n\t\t\t       struct nft_regs *regs,\n\t\t\t       const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_tproxy *priv = nft_expr_priv(expr);\n\tstruct sk_buff *skb = pkt->skb;\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tint thoff = nft_thoff(pkt);\n\tstruct udphdr _hdr, *hp;\n\tstruct in6_addr taddr;\n\t__be16 tport = 0;\n\tstruct sock *sk;\n\tint l4proto;\n\n\tmemset(&taddr, 0, sizeof(taddr));\n\n\tif (pkt->tprot != IPPROTO_TCP &&\n\t    pkt->tprot != IPPROTO_UDP) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\tl4proto = pkt->tprot;\n\n\thp = skb_header_pointer(skb, thoff, sizeof(_hdr), &_hdr);\n\tif (hp == NULL) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\t \n\tsk = nf_tproxy_get_sock_v6(nft_net(pkt), skb, thoff, l4proto,\n\t\t\t\t   &iph->saddr, &iph->daddr,\n\t\t\t\t   hp->source, hp->dest,\n\t\t\t\t   nft_in(pkt), NF_TPROXY_LOOKUP_ESTABLISHED);\n\n\tif (priv->sreg_addr)\n\t\tmemcpy(&taddr, &regs->data[priv->sreg_addr], sizeof(taddr));\n\ttaddr = *nf_tproxy_laddr6(skb, &taddr, &iph->daddr);\n\n\tif (priv->sreg_port)\n\t\ttport = nft_reg_load_be16(&regs->data[priv->sreg_port]);\n\tif (!tport)\n\t\ttport = hp->dest;\n\n\t \n\tif (sk && sk->sk_state == TCP_TIME_WAIT) {\n\t\t \n\t\tsk = nf_tproxy_handle_time_wait6(skb, l4proto, thoff,\n\t\t\t\t\t\t nft_net(pkt),\n\t\t\t\t\t\t &taddr,\n\t\t\t\t\t\t tport,\n\t\t\t\t\t\t sk);\n\t} else if (!sk) {\n\t\t \n\t\tsk = nf_tproxy_get_sock_v6(nft_net(pkt), skb, thoff,\n\t\t\t\t\t   l4proto, &iph->saddr, &taddr,\n\t\t\t\t\t   hp->source, tport,\n\t\t\t\t\t   nft_in(pkt), NF_TPROXY_LOOKUP_LISTENER);\n\t}\n\n\t \n\tif (sk && nf_tproxy_sk_is_transparent(sk))\n\t\tnf_tproxy_assign_sock(skb, sk);\n\telse\n\t\tregs->verdict.code = NFT_BREAK;\n}\n#endif\n\nstatic void nft_tproxy_eval(const struct nft_expr *expr,\n\t\t\t    struct nft_regs *regs,\n\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_tproxy *priv = nft_expr_priv(expr);\n\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tswitch (priv->family) {\n\t\tcase NFPROTO_IPV4:\n\t\tcase NFPROTO_UNSPEC:\n\t\t\tnft_tproxy_eval_v4(expr, regs, pkt);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\tcase NFPROTO_IPV6:\n\t\tswitch (priv->family) {\n\t\tcase NFPROTO_IPV6:\n\t\tcase NFPROTO_UNSPEC:\n\t\t\tnft_tproxy_eval_v6(expr, regs, pkt);\n\t\t\treturn;\n\t\t}\n#endif\n\t}\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic const struct nla_policy nft_tproxy_policy[NFTA_TPROXY_MAX + 1] = {\n\t[NFTA_TPROXY_FAMILY]   = NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_TPROXY_REG_ADDR] = { .type = NLA_U32 },\n\t[NFTA_TPROXY_REG_PORT] = { .type = NLA_U32 },\n};\n\nstatic int nft_tproxy_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nft_tproxy *priv = nft_expr_priv(expr);\n\tunsigned int alen = 0;\n\tint err;\n\n\tif (!tb[NFTA_TPROXY_FAMILY] ||\n\t    (!tb[NFTA_TPROXY_REG_ADDR] && !tb[NFTA_TPROXY_REG_PORT]))\n\t\treturn -EINVAL;\n\n\tpriv->family = ntohl(nla_get_be32(tb[NFTA_TPROXY_FAMILY]));\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_IPV4:\n\t\tif (priv->family != NFPROTO_IPV4)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\tcase NFPROTO_IPV6:\n\t\tif (priv->family != NFPROTO_IPV6)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#endif\n\tcase NFPROTO_INET:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (priv->family == NFPROTO_UNSPEC && tb[NFTA_TPROXY_REG_ADDR])\n\t\treturn -EINVAL;\n\n\tswitch (priv->family) {\n\tcase NFPROTO_IPV4:\n\t\talen = sizeof_field(union nf_inet_addr, in);\n\t\terr = nf_defrag_ipv4_enable(ctx->net);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\tcase NFPROTO_IPV6:\n\t\talen = sizeof_field(union nf_inet_addr, in6);\n\t\terr = nf_defrag_ipv6_enable(ctx->net);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n#endif\n\tcase NFPROTO_UNSPEC:\n\t\t \n\t\terr = nf_defrag_ipv4_enable(ctx->net);\n\t\tif (err)\n\t\t\treturn err;\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\t\terr = nf_defrag_ipv6_enable(ctx->net);\n\t\tif (err)\n\t\t\treturn err;\n#endif\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[NFTA_TPROXY_REG_ADDR]) {\n\t\terr = nft_parse_register_load(tb[NFTA_TPROXY_REG_ADDR],\n\t\t\t\t\t      &priv->sreg_addr, alen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[NFTA_TPROXY_REG_PORT]) {\n\t\terr = nft_parse_register_load(tb[NFTA_TPROXY_REG_PORT],\n\t\t\t\t\t      &priv->sreg_port, sizeof(u16));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void nft_tproxy_destroy(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr)\n{\n\tconst struct nft_tproxy *priv = nft_expr_priv(expr);\n\n\tswitch (priv->family) {\n\tcase NFPROTO_IPV4:\n\t\tnf_defrag_ipv4_disable(ctx->net);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\tcase NFPROTO_IPV6:\n\t\tnf_defrag_ipv6_disable(ctx->net);\n\t\tbreak;\n#endif\n\tcase NFPROTO_UNSPEC:\n\t\tnf_defrag_ipv4_disable(ctx->net);\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\t\tnf_defrag_ipv6_disable(ctx->net);\n#endif\n\t\tbreak;\n\t}\n}\n\nstatic int nft_tproxy_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_tproxy *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_TPROXY_FAMILY, htonl(priv->family)))\n\t\treturn -1;\n\n\tif (priv->sreg_addr &&\n\t    nft_dump_register(skb, NFTA_TPROXY_REG_ADDR, priv->sreg_addr))\n\t\treturn -1;\n\n\tif (priv->sreg_port &&\n\t    nft_dump_register(skb, NFTA_TPROXY_REG_PORT, priv->sreg_port))\n\t\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int nft_tproxy_validate(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nft_data **data)\n{\n\treturn nft_chain_validate_hooks(ctx->chain, 1 << NF_INET_PRE_ROUTING);\n}\n\nstatic struct nft_expr_type nft_tproxy_type;\nstatic const struct nft_expr_ops nft_tproxy_ops = {\n\t.type\t\t= &nft_tproxy_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_tproxy)),\n\t.eval\t\t= nft_tproxy_eval,\n\t.init\t\t= nft_tproxy_init,\n\t.destroy\t= nft_tproxy_destroy,\n\t.dump\t\t= nft_tproxy_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n\t.validate\t= nft_tproxy_validate,\n};\n\nstatic struct nft_expr_type nft_tproxy_type __read_mostly = {\n\t.name\t\t= \"tproxy\",\n\t.ops\t\t= &nft_tproxy_ops,\n\t.policy\t\t= nft_tproxy_policy,\n\t.maxattr\t= NFTA_TPROXY_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_tproxy_module_init(void)\n{\n\treturn nft_register_expr(&nft_tproxy_type);\n}\n\nstatic void __exit nft_tproxy_module_exit(void)\n{\n\tnft_unregister_expr(&nft_tproxy_type);\n}\n\nmodule_init(nft_tproxy_module_init);\nmodule_exit(nft_tproxy_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"M\u00e1t\u00e9 Eckl\");\nMODULE_DESCRIPTION(\"nf_tables tproxy support module\");\nMODULE_ALIAS_NFT_EXPR(\"tproxy\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}