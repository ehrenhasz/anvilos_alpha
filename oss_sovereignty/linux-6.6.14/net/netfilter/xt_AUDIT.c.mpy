{
  "module_name": "xt_AUDIT.c",
  "hash_id": "ef654bd9d9965f759960a9b05d7c706fc6b578ed8f555ce58b3a5349e55668ed",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_AUDIT.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/audit.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_AUDIT.h>\n#include <linux/netfilter_bridge/ebtables.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Thomas Graf <tgraf@redhat.com>\");\nMODULE_DESCRIPTION(\"Xtables: creates audit records for dropped/accepted packets\");\nMODULE_ALIAS(\"ipt_AUDIT\");\nMODULE_ALIAS(\"ip6t_AUDIT\");\nMODULE_ALIAS(\"ebt_AUDIT\");\nMODULE_ALIAS(\"arpt_AUDIT\");\n\nstatic bool audit_ip4(struct audit_buffer *ab, struct sk_buff *skb)\n{\n\tstruct iphdr _iph;\n\tconst struct iphdr *ih;\n\n\tih = skb_header_pointer(skb, skb_network_offset(skb), sizeof(_iph), &_iph);\n\tif (!ih)\n\t\treturn false;\n\n\taudit_log_format(ab, \" saddr=%pI4 daddr=%pI4 proto=%hhu\",\n\t\t\t &ih->saddr, &ih->daddr, ih->protocol);\n\n\treturn true;\n}\n\nstatic bool audit_ip6(struct audit_buffer *ab, struct sk_buff *skb)\n{\n\tstruct ipv6hdr _ip6h;\n\tconst struct ipv6hdr *ih;\n\tu8 nexthdr;\n\t__be16 frag_off;\n\n\tih = skb_header_pointer(skb, skb_network_offset(skb), sizeof(_ip6h), &_ip6h);\n\tif (!ih)\n\t\treturn false;\n\n\tnexthdr = ih->nexthdr;\n\tipv6_skip_exthdr(skb, skb_network_offset(skb) + sizeof(_ip6h), &nexthdr, &frag_off);\n\n\taudit_log_format(ab, \" saddr=%pI6c daddr=%pI6c proto=%hhu\",\n\t\t\t &ih->saddr, &ih->daddr, nexthdr);\n\n\treturn true;\n}\n\nstatic unsigned int\naudit_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tstruct audit_buffer *ab;\n\tint fam = -1;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\tgoto errout;\n\tab = audit_log_start(NULL, GFP_ATOMIC, AUDIT_NETFILTER_PKT);\n\tif (ab == NULL)\n\t\tgoto errout;\n\n\taudit_log_format(ab, \"mark=%#x\", skb->mark);\n\n\tswitch (xt_family(par)) {\n\tcase NFPROTO_BRIDGE:\n\t\tswitch (eth_hdr(skb)->h_proto) {\n\t\tcase htons(ETH_P_IP):\n\t\t\tfam = audit_ip4(ab, skb) ? NFPROTO_IPV4 : -1;\n\t\t\tbreak;\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tfam = audit_ip6(ab, skb) ? NFPROTO_IPV6 : -1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NFPROTO_IPV4:\n\t\tfam = audit_ip4(ab, skb) ? NFPROTO_IPV4 : -1;\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tfam = audit_ip6(ab, skb) ? NFPROTO_IPV6 : -1;\n\t\tbreak;\n\t}\n\n\tif (fam == -1)\n\t\taudit_log_format(ab, \" saddr=? daddr=? proto=-1\");\n\n\taudit_log_end(ab);\n\nerrout:\n\treturn XT_CONTINUE;\n}\n\nstatic unsigned int\naudit_tg_ebt(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\taudit_tg(skb, par);\n\treturn EBT_CONTINUE;\n}\n\nstatic int audit_tg_check(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_audit_info *info = par->targinfo;\n\n\tif (info->type > XT_AUDIT_TYPE_MAX) {\n\t\tpr_info_ratelimited(\"Audit type out of range (valid range: 0..%u)\\n\",\n\t\t\t\t    XT_AUDIT_TYPE_MAX);\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_target audit_tg_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"AUDIT\",\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.target\t\t= audit_tg,\n\t\t.targetsize\t= sizeof(struct xt_audit_info),\n\t\t.checkentry\t= audit_tg_check,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"AUDIT\",\n\t\t.family\t\t= NFPROTO_BRIDGE,\n\t\t.target\t\t= audit_tg_ebt,\n\t\t.targetsize\t= sizeof(struct xt_audit_info),\n\t\t.checkentry\t= audit_tg_check,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init audit_tg_init(void)\n{\n\treturn xt_register_targets(audit_tg_reg, ARRAY_SIZE(audit_tg_reg));\n}\n\nstatic void __exit audit_tg_exit(void)\n{\n\txt_unregister_targets(audit_tg_reg, ARRAY_SIZE(audit_tg_reg));\n}\n\nmodule_init(audit_tg_init);\nmodule_exit(audit_tg_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}