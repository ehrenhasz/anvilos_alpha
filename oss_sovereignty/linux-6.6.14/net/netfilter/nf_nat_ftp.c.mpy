{
  "module_name": "nf_nat_ftp.c",
  "hash_id": "87f42aab2a373b74d8fd08b01de1cc1091fdf0e2a7c46b4ad22f134287819a40",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_nat_ftp.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/inet.h>\n#include <linux/tcp.h>\n#include <linux/netfilter_ipv4.h>\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_nat_helper.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <linux/netfilter/nf_conntrack_ftp.h>\n\n#define NAT_HELPER_NAME \"ftp\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Rusty Russell <rusty@rustcorp.com.au>\");\nMODULE_DESCRIPTION(\"ftp NAT helper\");\nMODULE_ALIAS_NF_NAT_HELPER(NAT_HELPER_NAME);\n\n \n\nstatic struct nf_conntrack_nat_helper nat_helper_ftp =\n\tNF_CT_NAT_HELPER_INIT(NAT_HELPER_NAME);\n\nstatic int nf_nat_ftp_fmt_cmd(struct nf_conn *ct, enum nf_ct_ftp_type type,\n\t\t\t      char *buffer, size_t buflen,\n\t\t\t      union nf_inet_addr *addr, u16 port)\n{\n\tswitch (type) {\n\tcase NF_CT_FTP_PORT:\n\tcase NF_CT_FTP_PASV:\n\t\treturn snprintf(buffer, buflen, \"%u,%u,%u,%u,%u,%u\",\n\t\t\t\t((unsigned char *)&addr->ip)[0],\n\t\t\t\t((unsigned char *)&addr->ip)[1],\n\t\t\t\t((unsigned char *)&addr->ip)[2],\n\t\t\t\t((unsigned char *)&addr->ip)[3],\n\t\t\t\tport >> 8,\n\t\t\t\tport & 0xFF);\n\tcase NF_CT_FTP_EPRT:\n\t\tif (nf_ct_l3num(ct) == NFPROTO_IPV4)\n\t\t\treturn snprintf(buffer, buflen, \"|1|%pI4|%u|\",\n\t\t\t\t\t&addr->ip, port);\n\t\telse\n\t\t\treturn snprintf(buffer, buflen, \"|2|%pI6|%u|\",\n\t\t\t\t\t&addr->ip6, port);\n\tcase NF_CT_FTP_EPSV:\n\t\treturn snprintf(buffer, buflen, \"|||%u|\", port);\n\t}\n\n\treturn 0;\n}\n\n \nstatic unsigned int nf_nat_ftp(struct sk_buff *skb,\n\t\t\t       enum ip_conntrack_info ctinfo,\n\t\t\t       enum nf_ct_ftp_type type,\n\t\t\t       unsigned int protoff,\n\t\t\t       unsigned int matchoff,\n\t\t\t       unsigned int matchlen,\n\t\t\t       struct nf_conntrack_expect *exp)\n{\n\tunion nf_inet_addr newaddr;\n\tu_int16_t port;\n\tint dir = CTINFO2DIR(ctinfo);\n\tstruct nf_conn *ct = exp->master;\n\tchar buffer[sizeof(\"|1||65535|\") + INET6_ADDRSTRLEN];\n\tunsigned int buflen;\n\n\tpr_debug(\"type %i, off %u len %u\\n\", type, matchoff, matchlen);\n\n\t \n\tnewaddr = ct->tuplehash[!dir].tuple.dst.u3;\n\texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n\texp->dir = !dir;\n\n\t \n\texp->expectfn = nf_nat_follow_master;\n\n\tport = nf_nat_exp_find_port(exp, ntohs(exp->saved_proto.tcp.port));\n\tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n\t\treturn NF_DROP;\n\t}\n\n\tbuflen = nf_nat_ftp_fmt_cmd(ct, type, buffer, sizeof(buffer),\n\t\t\t\t    &newaddr, port);\n\tif (!buflen)\n\t\tgoto out;\n\n\tpr_debug(\"calling nf_nat_mangle_tcp_packet\\n\");\n\n\tif (!nf_nat_mangle_tcp_packet(skb, ct, ctinfo, protoff, matchoff,\n\t\t\t\t      matchlen, buffer, buflen))\n\t\tgoto out;\n\n\treturn NF_ACCEPT;\n\nout:\n\tnf_ct_helper_log(skb, ct, \"cannot mangle packet\");\n\tnf_ct_unexpect_related(exp);\n\treturn NF_DROP;\n}\n\nstatic void __exit nf_nat_ftp_fini(void)\n{\n\tnf_nat_helper_unregister(&nat_helper_ftp);\n\tRCU_INIT_POINTER(nf_nat_ftp_hook, NULL);\n\tsynchronize_rcu();\n}\n\nstatic int __init nf_nat_ftp_init(void)\n{\n\tBUG_ON(nf_nat_ftp_hook != NULL);\n\tnf_nat_helper_register(&nat_helper_ftp);\n\tRCU_INIT_POINTER(nf_nat_ftp_hook, nf_nat_ftp);\n\treturn 0;\n}\n\n \nstatic int warn_set(const char *val, const struct kernel_param *kp)\n{\n\tpr_info(\"kernel >= 2.6.10 only uses 'ports' for conntrack modules\\n\");\n\treturn 0;\n}\nmodule_param_call(ports, warn_set, NULL, NULL, 0);\n\nmodule_init(nf_nat_ftp_init);\nmodule_exit(nf_nat_ftp_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}