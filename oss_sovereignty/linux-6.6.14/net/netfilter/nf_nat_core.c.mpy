{
  "module_name": "nf_nat_core.c",
  "hash_id": "6569ed225cfca27d305c4bd9074854b935bc43721f383128100031ee67adbe0a",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_nat_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/skbuff.h>\n#include <linux/gfp.h>\n#include <net/xfrm.h>\n#include <linux/siphash.h>\n#include <linux/rtnetlink.h>\n\n#include <net/netfilter/nf_conntrack_bpf.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_nat_helper.h>\n#include <uapi/linux/netfilter/nf_nat.h>\n\n#include \"nf_internals.h\"\n\n#define NF_NAT_MAX_ATTEMPTS\t128\n#define NF_NAT_HARDER_THRESH\t(NF_NAT_MAX_ATTEMPTS / 4)\n\nstatic spinlock_t nf_nat_locks[CONNTRACK_LOCKS];\n\nstatic DEFINE_MUTEX(nf_nat_proto_mutex);\nstatic unsigned int nat_net_id __read_mostly;\n\nstatic struct hlist_head *nf_nat_bysource __read_mostly;\nstatic unsigned int nf_nat_htable_size __read_mostly;\nstatic siphash_aligned_key_t nf_nat_hash_rnd;\n\nstruct nf_nat_lookup_hook_priv {\n\tstruct nf_hook_entries __rcu *entries;\n\n\tstruct rcu_head rcu_head;\n};\n\nstruct nf_nat_hooks_net {\n\tstruct nf_hook_ops *nat_hook_ops;\n\tunsigned int users;\n};\n\nstruct nat_net {\n\tstruct nf_nat_hooks_net nat_proto_net[NFPROTO_NUMPROTO];\n};\n\n#ifdef CONFIG_XFRM\nstatic void nf_nat_ipv4_decode_session(struct sk_buff *skb,\n\t\t\t\t       const struct nf_conn *ct,\n\t\t\t\t       enum ip_conntrack_dir dir,\n\t\t\t\t       unsigned long statusbit,\n\t\t\t\t       struct flowi *fl)\n{\n\tconst struct nf_conntrack_tuple *t = &ct->tuplehash[dir].tuple;\n\tstruct flowi4 *fl4 = &fl->u.ip4;\n\n\tif (ct->status & statusbit) {\n\t\tfl4->daddr = t->dst.u3.ip;\n\t\tif (t->dst.protonum == IPPROTO_TCP ||\n\t\t    t->dst.protonum == IPPROTO_UDP ||\n\t\t    t->dst.protonum == IPPROTO_UDPLITE ||\n\t\t    t->dst.protonum == IPPROTO_DCCP ||\n\t\t    t->dst.protonum == IPPROTO_SCTP)\n\t\t\tfl4->fl4_dport = t->dst.u.all;\n\t}\n\n\tstatusbit ^= IPS_NAT_MASK;\n\n\tif (ct->status & statusbit) {\n\t\tfl4->saddr = t->src.u3.ip;\n\t\tif (t->dst.protonum == IPPROTO_TCP ||\n\t\t    t->dst.protonum == IPPROTO_UDP ||\n\t\t    t->dst.protonum == IPPROTO_UDPLITE ||\n\t\t    t->dst.protonum == IPPROTO_DCCP ||\n\t\t    t->dst.protonum == IPPROTO_SCTP)\n\t\t\tfl4->fl4_sport = t->src.u.all;\n\t}\n}\n\nstatic void nf_nat_ipv6_decode_session(struct sk_buff *skb,\n\t\t\t\t       const struct nf_conn *ct,\n\t\t\t\t       enum ip_conntrack_dir dir,\n\t\t\t\t       unsigned long statusbit,\n\t\t\t\t       struct flowi *fl)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tconst struct nf_conntrack_tuple *t = &ct->tuplehash[dir].tuple;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\n\tif (ct->status & statusbit) {\n\t\tfl6->daddr = t->dst.u3.in6;\n\t\tif (t->dst.protonum == IPPROTO_TCP ||\n\t\t    t->dst.protonum == IPPROTO_UDP ||\n\t\t    t->dst.protonum == IPPROTO_UDPLITE ||\n\t\t    t->dst.protonum == IPPROTO_DCCP ||\n\t\t    t->dst.protonum == IPPROTO_SCTP)\n\t\t\tfl6->fl6_dport = t->dst.u.all;\n\t}\n\n\tstatusbit ^= IPS_NAT_MASK;\n\n\tif (ct->status & statusbit) {\n\t\tfl6->saddr = t->src.u3.in6;\n\t\tif (t->dst.protonum == IPPROTO_TCP ||\n\t\t    t->dst.protonum == IPPROTO_UDP ||\n\t\t    t->dst.protonum == IPPROTO_UDPLITE ||\n\t\t    t->dst.protonum == IPPROTO_DCCP ||\n\t\t    t->dst.protonum == IPPROTO_SCTP)\n\t\t\tfl6->fl6_sport = t->src.u.all;\n\t}\n#endif\n}\n\nstatic void __nf_nat_decode_session(struct sk_buff *skb, struct flowi *fl)\n{\n\tconst struct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\tenum ip_conntrack_dir dir;\n\tunsigned  long statusbit;\n\tu8 family;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct == NULL)\n\t\treturn;\n\n\tfamily = nf_ct_l3num(ct);\n\tdir = CTINFO2DIR(ctinfo);\n\tif (dir == IP_CT_DIR_ORIGINAL)\n\t\tstatusbit = IPS_DST_NAT;\n\telse\n\t\tstatusbit = IPS_SRC_NAT;\n\n\tswitch (family) {\n\tcase NFPROTO_IPV4:\n\t\tnf_nat_ipv4_decode_session(skb, ct, dir, statusbit, fl);\n\t\treturn;\n\tcase NFPROTO_IPV6:\n\t\tnf_nat_ipv6_decode_session(skb, ct, dir, statusbit, fl);\n\t\treturn;\n\t}\n}\n#endif  \n\n \nstatic unsigned int\nhash_by_src(const struct net *net,\n\t    const struct nf_conntrack_zone *zone,\n\t    const struct nf_conntrack_tuple *tuple)\n{\n\tunsigned int hash;\n\tstruct {\n\t\tstruct nf_conntrack_man src;\n\t\tu32 net_mix;\n\t\tu32 protonum;\n\t\tu32 zone;\n\t} __aligned(SIPHASH_ALIGNMENT) combined;\n\n\tget_random_once(&nf_nat_hash_rnd, sizeof(nf_nat_hash_rnd));\n\n\tmemset(&combined, 0, sizeof(combined));\n\n\t \n\tcombined.src = tuple->src;\n\tcombined.net_mix = net_hash_mix(net);\n\tcombined.protonum = tuple->dst.protonum;\n\n\t \n\tif (zone->dir == NF_CT_DEFAULT_ZONE_DIR)\n\t\tcombined.zone = zone->id;\n\n\thash = siphash(&combined, sizeof(combined), &nf_nat_hash_rnd);\n\n\treturn reciprocal_scale(hash, nf_nat_htable_size);\n}\n\n \nstatic int\nnf_nat_used_tuple(const struct nf_conntrack_tuple *tuple,\n\t\t  const struct nf_conn *ignored_conntrack)\n{\n\t \n\tstruct nf_conntrack_tuple reply;\n\n\tnf_ct_invert_tuple(&reply, tuple);\n\treturn nf_conntrack_tuple_taken(&reply, ignored_conntrack);\n}\n\nstatic bool nf_nat_may_kill(struct nf_conn *ct, unsigned long flags)\n{\n\tstatic const unsigned long flags_refuse = IPS_FIXED_TIMEOUT |\n\t\t\t\t\t\t  IPS_DYING;\n\tstatic const unsigned long flags_needed = IPS_SRC_NAT;\n\tenum tcp_conntrack old_state;\n\n\told_state = READ_ONCE(ct->proto.tcp.state);\n\tif (old_state < TCP_CONNTRACK_TIME_WAIT)\n\t\treturn false;\n\n\tif (flags & flags_refuse)\n\t\treturn false;\n\n\treturn (flags & flags_needed) == flags_needed;\n}\n\n \nstatic bool nf_seq_has_advanced(const struct nf_conn *old, const struct nf_conn *new)\n{\n\treturn (__s32)(new->proto.tcp.seen[0].td_end -\n\t\t       old->proto.tcp.seen[0].td_end) > 0;\n}\n\nstatic int\nnf_nat_used_tuple_harder(const struct nf_conntrack_tuple *tuple,\n\t\t\t const struct nf_conn *ignored_conntrack,\n\t\t\t unsigned int attempts_left)\n{\n\tstatic const unsigned long flags_offload = IPS_OFFLOAD | IPS_HW_OFFLOAD;\n\tstruct nf_conntrack_tuple_hash *thash;\n\tconst struct nf_conntrack_zone *zone;\n\tstruct nf_conntrack_tuple reply;\n\tunsigned long flags;\n\tstruct nf_conn *ct;\n\tbool taken = true;\n\tstruct net *net;\n\n\tnf_ct_invert_tuple(&reply, tuple);\n\n\tif (attempts_left > NF_NAT_HARDER_THRESH ||\n\t    tuple->dst.protonum != IPPROTO_TCP ||\n\t    ignored_conntrack->proto.tcp.state != TCP_CONNTRACK_SYN_SENT)\n\t\treturn nf_conntrack_tuple_taken(&reply, ignored_conntrack);\n\n\t \n\tnet = nf_ct_net(ignored_conntrack);\n\tzone = nf_ct_zone(ignored_conntrack);\n\n\tthash = nf_conntrack_find_get(net, zone, &reply);\n\tif (!thash)\n\t\treturn false;\n\n\tct = nf_ct_tuplehash_to_ctrack(thash);\n\n\tif (thash->tuple.dst.dir == IP_CT_DIR_ORIGINAL)\n\t\tgoto out;\n\n\tif (WARN_ON_ONCE(ct == ignored_conntrack))\n\t\tgoto out;\n\n\tflags = READ_ONCE(ct->status);\n\tif (!nf_nat_may_kill(ct, flags))\n\t\tgoto out;\n\n\tif (!nf_seq_has_advanced(ct, ignored_conntrack))\n\t\tgoto out;\n\n\t \n\tif (nf_ct_kill(ct))\n\t\ttaken = flags & flags_offload;\nout:\n\tnf_ct_put(ct);\n\treturn taken;\n}\n\nstatic bool nf_nat_inet_in_range(const struct nf_conntrack_tuple *t,\n\t\t\t\t const struct nf_nat_range2 *range)\n{\n\tif (t->src.l3num == NFPROTO_IPV4)\n\t\treturn ntohl(t->src.u3.ip) >= ntohl(range->min_addr.ip) &&\n\t\t       ntohl(t->src.u3.ip) <= ntohl(range->max_addr.ip);\n\n\treturn ipv6_addr_cmp(&t->src.u3.in6, &range->min_addr.in6) >= 0 &&\n\t       ipv6_addr_cmp(&t->src.u3.in6, &range->max_addr.in6) <= 0;\n}\n\n \nstatic bool l4proto_in_range(const struct nf_conntrack_tuple *tuple,\n\t\t\t     enum nf_nat_manip_type maniptype,\n\t\t\t     const union nf_conntrack_man_proto *min,\n\t\t\t     const union nf_conntrack_man_proto *max)\n{\n\t__be16 port;\n\n\tswitch (tuple->dst.protonum) {\n\tcase IPPROTO_ICMP:\n\tcase IPPROTO_ICMPV6:\n\t\treturn ntohs(tuple->src.u.icmp.id) >= ntohs(min->icmp.id) &&\n\t\t       ntohs(tuple->src.u.icmp.id) <= ntohs(max->icmp.id);\n\tcase IPPROTO_GRE:  \n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\tcase IPPROTO_DCCP:\n\tcase IPPROTO_SCTP:\n\t\tif (maniptype == NF_NAT_MANIP_SRC)\n\t\t\tport = tuple->src.u.all;\n\t\telse\n\t\t\tport = tuple->dst.u.all;\n\n\t\treturn ntohs(port) >= ntohs(min->all) &&\n\t\t       ntohs(port) <= ntohs(max->all);\n\tdefault:\n\t\treturn true;\n\t}\n}\n\n \nstatic int nf_in_range(const struct nf_conntrack_tuple *tuple,\n\t\t    const struct nf_nat_range2 *range)\n{\n\t \n\tif (range->flags & NF_NAT_RANGE_MAP_IPS &&\n\t    !nf_nat_inet_in_range(tuple, range))\n\t\treturn 0;\n\n\tif (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED))\n\t\treturn 1;\n\n\treturn l4proto_in_range(tuple, NF_NAT_MANIP_SRC,\n\t\t\t\t&range->min_proto, &range->max_proto);\n}\n\nstatic inline int\nsame_src(const struct nf_conn *ct,\n\t const struct nf_conntrack_tuple *tuple)\n{\n\tconst struct nf_conntrack_tuple *t;\n\n\tt = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\treturn (t->dst.protonum == tuple->dst.protonum &&\n\t\tnf_inet_addr_cmp(&t->src.u3, &tuple->src.u3) &&\n\t\tt->src.u.all == tuple->src.u.all);\n}\n\n \nstatic int\nfind_appropriate_src(struct net *net,\n\t\t     const struct nf_conntrack_zone *zone,\n\t\t     const struct nf_conntrack_tuple *tuple,\n\t\t     struct nf_conntrack_tuple *result,\n\t\t     const struct nf_nat_range2 *range)\n{\n\tunsigned int h = hash_by_src(net, zone, tuple);\n\tconst struct nf_conn *ct;\n\n\thlist_for_each_entry_rcu(ct, &nf_nat_bysource[h], nat_bysource) {\n\t\tif (same_src(ct, tuple) &&\n\t\t    net_eq(net, nf_ct_net(ct)) &&\n\t\t    nf_ct_zone_equal(ct, zone, IP_CT_DIR_ORIGINAL)) {\n\t\t\t \n\t\t\tnf_ct_invert_tuple(result,\n\t\t\t\t       &ct->tuplehash[IP_CT_DIR_REPLY].tuple);\n\t\t\tresult->dst = tuple->dst;\n\n\t\t\tif (nf_in_range(result, range))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void\nfind_best_ips_proto(const struct nf_conntrack_zone *zone,\n\t\t    struct nf_conntrack_tuple *tuple,\n\t\t    const struct nf_nat_range2 *range,\n\t\t    const struct nf_conn *ct,\n\t\t    enum nf_nat_manip_type maniptype)\n{\n\tunion nf_inet_addr *var_ipp;\n\tunsigned int i, max;\n\t \n\tu32 minip, maxip, j, dist;\n\tbool full_range;\n\n\t \n\tif (!(range->flags & NF_NAT_RANGE_MAP_IPS))\n\t\treturn;\n\n\tif (maniptype == NF_NAT_MANIP_SRC)\n\t\tvar_ipp = &tuple->src.u3;\n\telse\n\t\tvar_ipp = &tuple->dst.u3;\n\n\t \n\tif (nf_inet_addr_cmp(&range->min_addr, &range->max_addr)) {\n\t\t*var_ipp = range->min_addr;\n\t\treturn;\n\t}\n\n\tif (nf_ct_l3num(ct) == NFPROTO_IPV4)\n\t\tmax = sizeof(var_ipp->ip) / sizeof(u32) - 1;\n\telse\n\t\tmax = sizeof(var_ipp->ip6) / sizeof(u32) - 1;\n\n\t \n\tj = jhash2((u32 *)&tuple->src.u3, sizeof(tuple->src.u3) / sizeof(u32),\n\t\t   range->flags & NF_NAT_RANGE_PERSISTENT ?\n\t\t\t0 : (__force u32)tuple->dst.u3.all[max] ^ zone->id);\n\n\tfull_range = false;\n\tfor (i = 0; i <= max; i++) {\n\t\t \n\t\tif (!full_range) {\n\t\t\tminip = ntohl((__force __be32)range->min_addr.all[i]);\n\t\t\tmaxip = ntohl((__force __be32)range->max_addr.all[i]);\n\t\t\tdist  = maxip - minip + 1;\n\t\t} else {\n\t\t\tminip = 0;\n\t\t\tdist  = ~0;\n\t\t}\n\n\t\tvar_ipp->all[i] = (__force __u32)\n\t\t\thtonl(minip + reciprocal_scale(j, dist));\n\t\tif (var_ipp->all[i] != range->max_addr.all[i])\n\t\t\tfull_range = true;\n\n\t\tif (!(range->flags & NF_NAT_RANGE_PERSISTENT))\n\t\t\tj ^= (__force u32)tuple->dst.u3.all[i];\n\t}\n}\n\n \nstatic void nf_nat_l4proto_unique_tuple(struct nf_conntrack_tuple *tuple,\n\t\t\t\t\tconst struct nf_nat_range2 *range,\n\t\t\t\t\tenum nf_nat_manip_type maniptype,\n\t\t\t\t\tconst struct nf_conn *ct)\n{\n\tunsigned int range_size, min, max, i, attempts;\n\t__be16 *keyptr;\n\tu16 off;\n\n\tswitch (tuple->dst.protonum) {\n\tcase IPPROTO_ICMP:\n\tcase IPPROTO_ICMPV6:\n\t\t \n\t\tkeyptr = &tuple->src.u.icmp.id;\n\t\tif (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED)) {\n\t\t\tmin = 0;\n\t\t\trange_size = 65536;\n\t\t} else {\n\t\t\tmin = ntohs(range->min_proto.icmp.id);\n\t\t\trange_size = ntohs(range->max_proto.icmp.id) -\n\t\t\t\t     ntohs(range->min_proto.icmp.id) + 1;\n\t\t}\n\t\tgoto find_free_id;\n#if IS_ENABLED(CONFIG_NF_CT_PROTO_GRE)\n\tcase IPPROTO_GRE:\n\t\t \n\t\tif (!ct->master)\n\t\t\treturn;\n\n\t\tif (maniptype == NF_NAT_MANIP_SRC)\n\t\t\tkeyptr = &tuple->src.u.gre.key;\n\t\telse\n\t\t\tkeyptr = &tuple->dst.u.gre.key;\n\n\t\tif (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED)) {\n\t\t\tmin = 1;\n\t\t\trange_size = 65535;\n\t\t} else {\n\t\t\tmin = ntohs(range->min_proto.gre.key);\n\t\t\trange_size = ntohs(range->max_proto.gre.key) - min + 1;\n\t\t}\n\t\tgoto find_free_id;\n#endif\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_SCTP:\n\tcase IPPROTO_DCCP:\n\t\tif (maniptype == NF_NAT_MANIP_SRC)\n\t\t\tkeyptr = &tuple->src.u.all;\n\t\telse\n\t\t\tkeyptr = &tuple->dst.u.all;\n\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tif (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED)) {\n\t\t \n\t\tif (maniptype == NF_NAT_MANIP_DST)\n\t\t\treturn;\n\n\t\tif (ntohs(*keyptr) < 1024) {\n\t\t\t \n\t\t\tif (ntohs(*keyptr) < 512) {\n\t\t\t\tmin = 1;\n\t\t\t\trange_size = 511 - min + 1;\n\t\t\t} else {\n\t\t\t\tmin = 600;\n\t\t\t\trange_size = 1023 - min + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tmin = 1024;\n\t\t\trange_size = 65535 - 1024 + 1;\n\t\t}\n\t} else {\n\t\tmin = ntohs(range->min_proto.all);\n\t\tmax = ntohs(range->max_proto.all);\n\t\tif (unlikely(max < min))\n\t\t\tswap(max, min);\n\t\trange_size = max - min + 1;\n\t}\n\nfind_free_id:\n\tif (range->flags & NF_NAT_RANGE_PROTO_OFFSET)\n\t\toff = (ntohs(*keyptr) - ntohs(range->base_proto.all));\n\telse\n\t\toff = get_random_u16();\n\n\tattempts = range_size;\n\tif (attempts > NF_NAT_MAX_ATTEMPTS)\n\t\tattempts = NF_NAT_MAX_ATTEMPTS;\n\n\t \nanother_round:\n\tfor (i = 0; i < attempts; i++, off++) {\n\t\t*keyptr = htons(min + off % range_size);\n\t\tif (!nf_nat_used_tuple_harder(tuple, ct, attempts - i))\n\t\t\treturn;\n\t}\n\n\tif (attempts >= range_size || attempts < 16)\n\t\treturn;\n\tattempts /= 2;\n\toff = get_random_u16();\n\tgoto another_round;\n}\n\n \nstatic void\nget_unique_tuple(struct nf_conntrack_tuple *tuple,\n\t\t const struct nf_conntrack_tuple *orig_tuple,\n\t\t const struct nf_nat_range2 *range,\n\t\t struct nf_conn *ct,\n\t\t enum nf_nat_manip_type maniptype)\n{\n\tconst struct nf_conntrack_zone *zone;\n\tstruct net *net = nf_ct_net(ct);\n\n\tzone = nf_ct_zone(ct);\n\n\t \n\tif (maniptype == NF_NAT_MANIP_SRC &&\n\t    !(range->flags & NF_NAT_RANGE_PROTO_RANDOM_ALL)) {\n\t\t \n\t\tif (nf_in_range(orig_tuple, range)) {\n\t\t\tif (!nf_nat_used_tuple(orig_tuple, ct)) {\n\t\t\t\t*tuple = *orig_tuple;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (find_appropriate_src(net, zone,\n\t\t\t\t\t\torig_tuple, tuple, range)) {\n\t\t\tpr_debug(\"get_unique_tuple: Found current src map\\n\");\n\t\t\tif (!nf_nat_used_tuple(tuple, ct))\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\t*tuple = *orig_tuple;\n\tfind_best_ips_proto(zone, tuple, range, ct, maniptype);\n\n\t \n\n\t \n\tif (!(range->flags & NF_NAT_RANGE_PROTO_RANDOM_ALL)) {\n\t\tif (range->flags & NF_NAT_RANGE_PROTO_SPECIFIED) {\n\t\t\tif (!(range->flags & NF_NAT_RANGE_PROTO_OFFSET) &&\n\t\t\t    l4proto_in_range(tuple, maniptype,\n\t\t\t\t\t     &range->min_proto,\n\t\t\t\t\t     &range->max_proto) &&\n\t\t\t    (range->min_proto.all == range->max_proto.all ||\n\t\t\t     !nf_nat_used_tuple(tuple, ct)))\n\t\t\t\treturn;\n\t\t} else if (!nf_nat_used_tuple(tuple, ct)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tnf_nat_l4proto_unique_tuple(tuple, range, maniptype, ct);\n}\n\nstruct nf_conn_nat *nf_ct_nat_ext_add(struct nf_conn *ct)\n{\n\tstruct nf_conn_nat *nat = nfct_nat(ct);\n\tif (nat)\n\t\treturn nat;\n\n\tif (!nf_ct_is_confirmed(ct))\n\t\tnat = nf_ct_ext_add(ct, NF_CT_EXT_NAT, GFP_ATOMIC);\n\n\treturn nat;\n}\nEXPORT_SYMBOL_GPL(nf_ct_nat_ext_add);\n\nunsigned int\nnf_nat_setup_info(struct nf_conn *ct,\n\t\t  const struct nf_nat_range2 *range,\n\t\t  enum nf_nat_manip_type maniptype)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct nf_conntrack_tuple curr_tuple, new_tuple;\n\n\t \n\tif (nf_ct_is_confirmed(ct))\n\t\treturn NF_ACCEPT;\n\n\tWARN_ON(maniptype != NF_NAT_MANIP_SRC &&\n\t\tmaniptype != NF_NAT_MANIP_DST);\n\n\tif (WARN_ON(nf_nat_initialized(ct, maniptype)))\n\t\treturn NF_DROP;\n\n\t \n\tnf_ct_invert_tuple(&curr_tuple,\n\t\t\t   &ct->tuplehash[IP_CT_DIR_REPLY].tuple);\n\n\tget_unique_tuple(&new_tuple, &curr_tuple, range, ct, maniptype);\n\n\tif (!nf_ct_tuple_equal(&new_tuple, &curr_tuple)) {\n\t\tstruct nf_conntrack_tuple reply;\n\n\t\t \n\t\tnf_ct_invert_tuple(&reply, &new_tuple);\n\t\tnf_conntrack_alter_reply(ct, &reply);\n\n\t\t \n\t\tif (maniptype == NF_NAT_MANIP_SRC)\n\t\t\tct->status |= IPS_SRC_NAT;\n\t\telse\n\t\t\tct->status |= IPS_DST_NAT;\n\n\t\tif (nfct_help(ct) && !nfct_seqadj(ct))\n\t\t\tif (!nfct_seqadj_ext_add(ct))\n\t\t\t\treturn NF_DROP;\n\t}\n\n\tif (maniptype == NF_NAT_MANIP_SRC) {\n\t\tunsigned int srchash;\n\t\tspinlock_t *lock;\n\n\t\tsrchash = hash_by_src(net, nf_ct_zone(ct),\n\t\t\t\t      &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);\n\t\tlock = &nf_nat_locks[srchash % CONNTRACK_LOCKS];\n\t\tspin_lock_bh(lock);\n\t\thlist_add_head_rcu(&ct->nat_bysource,\n\t\t\t\t   &nf_nat_bysource[srchash]);\n\t\tspin_unlock_bh(lock);\n\t}\n\n\t \n\tif (maniptype == NF_NAT_MANIP_DST)\n\t\tct->status |= IPS_DST_NAT_DONE;\n\telse\n\t\tct->status |= IPS_SRC_NAT_DONE;\n\n\treturn NF_ACCEPT;\n}\nEXPORT_SYMBOL(nf_nat_setup_info);\n\nstatic unsigned int\n__nf_nat_alloc_null_binding(struct nf_conn *ct, enum nf_nat_manip_type manip)\n{\n\t \n\tunion nf_inet_addr ip =\n\t\t(manip == NF_NAT_MANIP_SRC ?\n\t\tct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3 :\n\t\tct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3);\n\tstruct nf_nat_range2 range = {\n\t\t.flags\t\t= NF_NAT_RANGE_MAP_IPS,\n\t\t.min_addr\t= ip,\n\t\t.max_addr\t= ip,\n\t};\n\treturn nf_nat_setup_info(ct, &range, manip);\n}\n\nunsigned int\nnf_nat_alloc_null_binding(struct nf_conn *ct, unsigned int hooknum)\n{\n\treturn __nf_nat_alloc_null_binding(ct, HOOK2MANIP(hooknum));\n}\nEXPORT_SYMBOL_GPL(nf_nat_alloc_null_binding);\n\n \nunsigned int nf_nat_packet(struct nf_conn *ct,\n\t\t\t   enum ip_conntrack_info ctinfo,\n\t\t\t   unsigned int hooknum,\n\t\t\t   struct sk_buff *skb)\n{\n\tenum nf_nat_manip_type mtype = HOOK2MANIP(hooknum);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tunsigned int verdict = NF_ACCEPT;\n\tunsigned long statusbit;\n\n\tif (mtype == NF_NAT_MANIP_SRC)\n\t\tstatusbit = IPS_SRC_NAT;\n\telse\n\t\tstatusbit = IPS_DST_NAT;\n\n\t \n\tif (dir == IP_CT_DIR_REPLY)\n\t\tstatusbit ^= IPS_NAT_MASK;\n\n\t \n\tif (ct->status & statusbit)\n\t\tverdict = nf_nat_manip_pkt(skb, ct, mtype, dir);\n\n\treturn verdict;\n}\nEXPORT_SYMBOL_GPL(nf_nat_packet);\n\nstatic bool in_vrf_postrouting(const struct nf_hook_state *state)\n{\n#if IS_ENABLED(CONFIG_NET_L3_MASTER_DEV)\n\tif (state->hook == NF_INET_POST_ROUTING &&\n\t    netif_is_l3_master(state->out))\n\t\treturn true;\n#endif\n\treturn false;\n}\n\nunsigned int\nnf_nat_inet_fn(void *priv, struct sk_buff *skb,\n\t       const struct nf_hook_state *state)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn_nat *nat;\n\t \n\tenum nf_nat_manip_type maniptype = HOOK2MANIP(state->hook);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\t \n\tif (!ct || in_vrf_postrouting(state))\n\t\treturn NF_ACCEPT;\n\n\tnat = nfct_nat(ct);\n\n\tswitch (ctinfo) {\n\tcase IP_CT_RELATED:\n\tcase IP_CT_RELATED_REPLY:\n\t\t \n\tcase IP_CT_NEW:\n\t\t \n\t\tif (!nf_nat_initialized(ct, maniptype)) {\n\t\t\tstruct nf_nat_lookup_hook_priv *lpriv = priv;\n\t\t\tstruct nf_hook_entries *e = rcu_dereference(lpriv->entries);\n\t\t\tunsigned int ret;\n\t\t\tint i;\n\n\t\t\tif (!e)\n\t\t\t\tgoto null_bind;\n\n\t\t\tfor (i = 0; i < e->num_hook_entries; i++) {\n\t\t\t\tret = e->hooks[i].hook(e->hooks[i].priv, skb,\n\t\t\t\t\t\t       state);\n\t\t\t\tif (ret != NF_ACCEPT)\n\t\t\t\t\treturn ret;\n\t\t\t\tif (nf_nat_initialized(ct, maniptype))\n\t\t\t\t\tgoto do_nat;\n\t\t\t}\nnull_bind:\n\t\t\tret = nf_nat_alloc_null_binding(ct, state->hook);\n\t\t\tif (ret != NF_ACCEPT)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpr_debug(\"Already setup manip %s for ct %p (status bits 0x%lx)\\n\",\n\t\t\t\t maniptype == NF_NAT_MANIP_SRC ? \"SRC\" : \"DST\",\n\t\t\t\t ct, ct->status);\n\t\t\tif (nf_nat_oif_changed(state->hook, ctinfo, nat,\n\t\t\t\t\t       state->out))\n\t\t\t\tgoto oif_changed;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON(ctinfo != IP_CT_ESTABLISHED &&\n\t\t\tctinfo != IP_CT_ESTABLISHED_REPLY);\n\t\tif (nf_nat_oif_changed(state->hook, ctinfo, nat, state->out))\n\t\t\tgoto oif_changed;\n\t}\ndo_nat:\n\treturn nf_nat_packet(ct, ctinfo, state->hook, skb);\n\noif_changed:\n\tnf_ct_kill_acct(ct, ctinfo, skb);\n\treturn NF_DROP;\n}\nEXPORT_SYMBOL_GPL(nf_nat_inet_fn);\n\nstruct nf_nat_proto_clean {\n\tu8\tl3proto;\n\tu8\tl4proto;\n};\n\n \nstatic int nf_nat_proto_remove(struct nf_conn *i, void *data)\n{\n\tconst struct nf_nat_proto_clean *clean = data;\n\n\tif ((clean->l3proto && nf_ct_l3num(i) != clean->l3proto) ||\n\t    (clean->l4proto && nf_ct_protonum(i) != clean->l4proto))\n\t\treturn 0;\n\n\treturn i->status & IPS_NAT_MASK ? 1 : 0;\n}\n\nstatic void nf_nat_cleanup_conntrack(struct nf_conn *ct)\n{\n\tunsigned int h;\n\n\th = hash_by_src(nf_ct_net(ct), nf_ct_zone(ct), &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);\n\tspin_lock_bh(&nf_nat_locks[h % CONNTRACK_LOCKS]);\n\thlist_del_rcu(&ct->nat_bysource);\n\tspin_unlock_bh(&nf_nat_locks[h % CONNTRACK_LOCKS]);\n}\n\nstatic int nf_nat_proto_clean(struct nf_conn *ct, void *data)\n{\n\tif (nf_nat_proto_remove(ct, data))\n\t\treturn 1;\n\n\t \n\tif (test_and_clear_bit(IPS_SRC_NAT_DONE_BIT, &ct->status))\n\t\tnf_nat_cleanup_conntrack(ct);\n\n\t \n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_conntrack.h>\n\nstatic const struct nla_policy protonat_nla_policy[CTA_PROTONAT_MAX+1] = {\n\t[CTA_PROTONAT_PORT_MIN]\t= { .type = NLA_U16 },\n\t[CTA_PROTONAT_PORT_MAX]\t= { .type = NLA_U16 },\n};\n\nstatic int nf_nat_l4proto_nlattr_to_range(struct nlattr *tb[],\n\t\t\t\t\t  struct nf_nat_range2 *range)\n{\n\tif (tb[CTA_PROTONAT_PORT_MIN]) {\n\t\trange->min_proto.all = nla_get_be16(tb[CTA_PROTONAT_PORT_MIN]);\n\t\trange->max_proto.all = range->min_proto.all;\n\t\trange->flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\n\t}\n\tif (tb[CTA_PROTONAT_PORT_MAX]) {\n\t\trange->max_proto.all = nla_get_be16(tb[CTA_PROTONAT_PORT_MAX]);\n\t\trange->flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\n\t}\n\treturn 0;\n}\n\nstatic int nfnetlink_parse_nat_proto(struct nlattr *attr,\n\t\t\t\t     const struct nf_conn *ct,\n\t\t\t\t     struct nf_nat_range2 *range)\n{\n\tstruct nlattr *tb[CTA_PROTONAT_MAX+1];\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, CTA_PROTONAT_MAX, attr,\n\t\t\t\t\t  protonat_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn nf_nat_l4proto_nlattr_to_range(tb, range);\n}\n\nstatic const struct nla_policy nat_nla_policy[CTA_NAT_MAX+1] = {\n\t[CTA_NAT_V4_MINIP]\t= { .type = NLA_U32 },\n\t[CTA_NAT_V4_MAXIP]\t= { .type = NLA_U32 },\n\t[CTA_NAT_V6_MINIP]\t= { .len = sizeof(struct in6_addr) },\n\t[CTA_NAT_V6_MAXIP]\t= { .len = sizeof(struct in6_addr) },\n\t[CTA_NAT_PROTO]\t\t= { .type = NLA_NESTED },\n};\n\nstatic int nf_nat_ipv4_nlattr_to_range(struct nlattr *tb[],\n\t\t\t\t       struct nf_nat_range2 *range)\n{\n\tif (tb[CTA_NAT_V4_MINIP]) {\n\t\trange->min_addr.ip = nla_get_be32(tb[CTA_NAT_V4_MINIP]);\n\t\trange->flags |= NF_NAT_RANGE_MAP_IPS;\n\t}\n\n\tif (tb[CTA_NAT_V4_MAXIP])\n\t\trange->max_addr.ip = nla_get_be32(tb[CTA_NAT_V4_MAXIP]);\n\telse\n\t\trange->max_addr.ip = range->min_addr.ip;\n\n\treturn 0;\n}\n\nstatic int nf_nat_ipv6_nlattr_to_range(struct nlattr *tb[],\n\t\t\t\t       struct nf_nat_range2 *range)\n{\n\tif (tb[CTA_NAT_V6_MINIP]) {\n\t\tnla_memcpy(&range->min_addr.ip6, tb[CTA_NAT_V6_MINIP],\n\t\t\t   sizeof(struct in6_addr));\n\t\trange->flags |= NF_NAT_RANGE_MAP_IPS;\n\t}\n\n\tif (tb[CTA_NAT_V6_MAXIP])\n\t\tnla_memcpy(&range->max_addr.ip6, tb[CTA_NAT_V6_MAXIP],\n\t\t\t   sizeof(struct in6_addr));\n\telse\n\t\trange->max_addr = range->min_addr;\n\n\treturn 0;\n}\n\nstatic int\nnfnetlink_parse_nat(const struct nlattr *nat,\n\t\t    const struct nf_conn *ct, struct nf_nat_range2 *range)\n{\n\tstruct nlattr *tb[CTA_NAT_MAX+1];\n\tint err;\n\n\tmemset(range, 0, sizeof(*range));\n\n\terr = nla_parse_nested_deprecated(tb, CTA_NAT_MAX, nat,\n\t\t\t\t\t  nat_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (nf_ct_l3num(ct)) {\n\tcase NFPROTO_IPV4:\n\t\terr = nf_nat_ipv4_nlattr_to_range(tb, range);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\terr = nf_nat_ipv6_nlattr_to_range(tb, range);\n\t\tbreak;\n\tdefault:\n\t\terr = -EPROTONOSUPPORT;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[CTA_NAT_PROTO])\n\t\treturn 0;\n\n\treturn nfnetlink_parse_nat_proto(tb[CTA_NAT_PROTO], ct, range);\n}\n\n \nstatic int\nnfnetlink_parse_nat_setup(struct nf_conn *ct,\n\t\t\t  enum nf_nat_manip_type manip,\n\t\t\t  const struct nlattr *attr)\n{\n\tstruct nf_nat_range2 range;\n\tint err;\n\n\t \n\tif (WARN_ON_ONCE(nf_nat_initialized(ct, manip)))\n\t\treturn -EEXIST;\n\n\t \n\tif (attr == NULL)\n\t\treturn __nf_nat_alloc_null_binding(ct, manip) == NF_DROP ? -ENOMEM : 0;\n\n\terr = nfnetlink_parse_nat(attr, ct, &range);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn nf_nat_setup_info(ct, &range, manip) == NF_DROP ? -ENOMEM : 0;\n}\n#else\nstatic int\nnfnetlink_parse_nat_setup(struct nf_conn *ct,\n\t\t\t  enum nf_nat_manip_type manip,\n\t\t\t  const struct nlattr *attr)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic struct nf_ct_helper_expectfn follow_master_nat = {\n\t.name\t\t= \"nat-follow-master\",\n\t.expectfn\t= nf_nat_follow_master,\n};\n\nint nf_nat_register_fn(struct net *net, u8 pf, const struct nf_hook_ops *ops,\n\t\t       const struct nf_hook_ops *orig_nat_ops, unsigned int ops_count)\n{\n\tstruct nat_net *nat_net = net_generic(net, nat_net_id);\n\tstruct nf_nat_hooks_net *nat_proto_net;\n\tstruct nf_nat_lookup_hook_priv *priv;\n\tunsigned int hooknum = ops->hooknum;\n\tstruct nf_hook_ops *nat_ops;\n\tint i, ret;\n\n\tif (WARN_ON_ONCE(pf >= ARRAY_SIZE(nat_net->nat_proto_net)))\n\t\treturn -EINVAL;\n\n\tnat_proto_net = &nat_net->nat_proto_net[pf];\n\n\tfor (i = 0; i < ops_count; i++) {\n\t\tif (orig_nat_ops[i].hooknum == hooknum) {\n\t\t\thooknum = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(i == ops_count))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&nf_nat_proto_mutex);\n\tif (!nat_proto_net->nat_hook_ops) {\n\t\tWARN_ON(nat_proto_net->users != 0);\n\n\t\tnat_ops = kmemdup(orig_nat_ops, sizeof(*orig_nat_ops) * ops_count, GFP_KERNEL);\n\t\tif (!nat_ops) {\n\t\t\tmutex_unlock(&nf_nat_proto_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfor (i = 0; i < ops_count; i++) {\n\t\t\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\t\t\tif (priv) {\n\t\t\t\tnat_ops[i].priv = priv;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmutex_unlock(&nf_nat_proto_mutex);\n\t\t\twhile (i)\n\t\t\t\tkfree(nat_ops[--i].priv);\n\t\t\tkfree(nat_ops);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = nf_register_net_hooks(net, nat_ops, ops_count);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&nf_nat_proto_mutex);\n\t\t\tfor (i = 0; i < ops_count; i++)\n\t\t\t\tkfree(nat_ops[i].priv);\n\t\t\tkfree(nat_ops);\n\t\t\treturn ret;\n\t\t}\n\n\t\tnat_proto_net->nat_hook_ops = nat_ops;\n\t}\n\n\tnat_ops = nat_proto_net->nat_hook_ops;\n\tpriv = nat_ops[hooknum].priv;\n\tif (WARN_ON_ONCE(!priv)) {\n\t\tmutex_unlock(&nf_nat_proto_mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = nf_hook_entries_insert_raw(&priv->entries, ops);\n\tif (ret == 0)\n\t\tnat_proto_net->users++;\n\n\tmutex_unlock(&nf_nat_proto_mutex);\n\treturn ret;\n}\n\nvoid nf_nat_unregister_fn(struct net *net, u8 pf, const struct nf_hook_ops *ops,\n\t\t\t  unsigned int ops_count)\n{\n\tstruct nat_net *nat_net = net_generic(net, nat_net_id);\n\tstruct nf_nat_hooks_net *nat_proto_net;\n\tstruct nf_nat_lookup_hook_priv *priv;\n\tstruct nf_hook_ops *nat_ops;\n\tint hooknum = ops->hooknum;\n\tint i;\n\n\tif (pf >= ARRAY_SIZE(nat_net->nat_proto_net))\n\t\treturn;\n\n\tnat_proto_net = &nat_net->nat_proto_net[pf];\n\n\tmutex_lock(&nf_nat_proto_mutex);\n\tif (WARN_ON(nat_proto_net->users == 0))\n\t\tgoto unlock;\n\n\tnat_proto_net->users--;\n\n\tnat_ops = nat_proto_net->nat_hook_ops;\n\tfor (i = 0; i < ops_count; i++) {\n\t\tif (nat_ops[i].hooknum == hooknum) {\n\t\t\thooknum = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (WARN_ON_ONCE(i == ops_count))\n\t\tgoto unlock;\n\tpriv = nat_ops[hooknum].priv;\n\tnf_hook_entries_delete_raw(&priv->entries, ops);\n\n\tif (nat_proto_net->users == 0) {\n\t\tnf_unregister_net_hooks(net, nat_ops, ops_count);\n\n\t\tfor (i = 0; i < ops_count; i++) {\n\t\t\tpriv = nat_ops[i].priv;\n\t\t\tkfree_rcu(priv, rcu_head);\n\t\t}\n\n\t\tnat_proto_net->nat_hook_ops = NULL;\n\t\tkfree(nat_ops);\n\t}\nunlock:\n\tmutex_unlock(&nf_nat_proto_mutex);\n}\n\nstatic struct pernet_operations nat_net_ops = {\n\t.id = &nat_net_id,\n\t.size = sizeof(struct nat_net),\n};\n\nstatic const struct nf_nat_hook nat_hook = {\n\t.parse_nat_setup\t= nfnetlink_parse_nat_setup,\n#ifdef CONFIG_XFRM\n\t.decode_session\t\t= __nf_nat_decode_session,\n#endif\n\t.manip_pkt\t\t= nf_nat_manip_pkt,\n\t.remove_nat_bysrc\t= nf_nat_cleanup_conntrack,\n};\n\nstatic int __init nf_nat_init(void)\n{\n\tint ret, i;\n\n\t \n\tnf_nat_htable_size = nf_conntrack_htable_size;\n\tif (nf_nat_htable_size < CONNTRACK_LOCKS)\n\t\tnf_nat_htable_size = CONNTRACK_LOCKS;\n\n\tnf_nat_bysource = nf_ct_alloc_hashtable(&nf_nat_htable_size, 0);\n\tif (!nf_nat_bysource)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CONNTRACK_LOCKS; i++)\n\t\tspin_lock_init(&nf_nat_locks[i]);\n\n\tret = register_pernet_subsys(&nat_net_ops);\n\tif (ret < 0) {\n\t\tkvfree(nf_nat_bysource);\n\t\treturn ret;\n\t}\n\n\tnf_ct_helper_expectfn_register(&follow_master_nat);\n\n\tWARN_ON(nf_nat_hook != NULL);\n\tRCU_INIT_POINTER(nf_nat_hook, &nat_hook);\n\n\tret = register_nf_nat_bpf();\n\tif (ret < 0) {\n\t\tRCU_INIT_POINTER(nf_nat_hook, NULL);\n\t\tnf_ct_helper_expectfn_unregister(&follow_master_nat);\n\t\tsynchronize_net();\n\t\tunregister_pernet_subsys(&nat_net_ops);\n\t\tkvfree(nf_nat_bysource);\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit nf_nat_cleanup(void)\n{\n\tstruct nf_nat_proto_clean clean = {};\n\n\tnf_ct_iterate_destroy(nf_nat_proto_clean, &clean);\n\n\tnf_ct_helper_expectfn_unregister(&follow_master_nat);\n\tRCU_INIT_POINTER(nf_nat_hook, NULL);\n\n\tsynchronize_net();\n\tkvfree(nf_nat_bysource);\n\tunregister_pernet_subsys(&nat_net_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(nf_nat_init);\nmodule_exit(nf_nat_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}