{
  "module_name": "xt_dccp.c",
  "hash_id": "7cde04f588a7d10aa4cb3fe96079723fc6f94018354b8e52d9aa5eb170b15857",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_dccp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <net/ip.h>\n#include <linux/dccp.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_dccp.h>\n\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: DCCP protocol packet match\");\nMODULE_ALIAS(\"ipt_dccp\");\nMODULE_ALIAS(\"ip6t_dccp\");\n\n#define DCCHECK(cond, option, flag, invflag) (!((flag) & (option)) \\\n\t\t\t\t  || (!!((invflag) & (option)) ^ (cond)))\n\nstatic unsigned char *dccp_optbuf;\nstatic DEFINE_SPINLOCK(dccp_buflock);\n\nstatic inline bool\ndccp_find_option(u_int8_t option,\n\t\t const struct sk_buff *skb,\n\t\t unsigned int protoff,\n\t\t const struct dccp_hdr *dh,\n\t\t bool *hotdrop)\n{\n\t \n\tconst unsigned char *op;\n\tunsigned int optoff = __dccp_hdr_len(dh);\n\tunsigned int optlen = dh->dccph_doff*4 - __dccp_hdr_len(dh);\n\tunsigned int i;\n\n\tif (dh->dccph_doff * 4 < __dccp_hdr_len(dh))\n\t\tgoto invalid;\n\n\tif (!optlen)\n\t\treturn false;\n\n\tspin_lock_bh(&dccp_buflock);\n\top = skb_header_pointer(skb, protoff + optoff, optlen, dccp_optbuf);\n\tif (op == NULL) {\n\t\t \n\t\tgoto partial;\n\t}\n\n\tfor (i = 0; i < optlen; ) {\n\t\tif (op[i] == option) {\n\t\t\tspin_unlock_bh(&dccp_buflock);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (op[i] < 2)\n\t\t\ti++;\n\t\telse\n\t\t\ti += op[i+1]?:1;\n\t}\n\n\tspin_unlock_bh(&dccp_buflock);\n\treturn false;\n\npartial:\n\tspin_unlock_bh(&dccp_buflock);\ninvalid:\n\t*hotdrop = true;\n\treturn false;\n}\n\n\nstatic inline bool\nmatch_types(const struct dccp_hdr *dh, u_int16_t typemask)\n{\n\treturn typemask & (1 << dh->dccph_type);\n}\n\nstatic inline bool\nmatch_option(u_int8_t option, const struct sk_buff *skb, unsigned int protoff,\n\t     const struct dccp_hdr *dh, bool *hotdrop)\n{\n\treturn dccp_find_option(option, skb, protoff, dh, hotdrop);\n}\n\nstatic bool\ndccp_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_dccp_info *info = par->matchinfo;\n\tconst struct dccp_hdr *dh;\n\tstruct dccp_hdr _dh;\n\n\tif (par->fragoff != 0)\n\t\treturn false;\n\n\tdh = skb_header_pointer(skb, par->thoff, sizeof(_dh), &_dh);\n\tif (dh == NULL) {\n\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\treturn  DCCHECK(ntohs(dh->dccph_sport) >= info->spts[0]\n\t\t\t&& ntohs(dh->dccph_sport) <= info->spts[1],\n\t\t\tXT_DCCP_SRC_PORTS, info->flags, info->invflags)\n\t\t&& DCCHECK(ntohs(dh->dccph_dport) >= info->dpts[0]\n\t\t\t&& ntohs(dh->dccph_dport) <= info->dpts[1],\n\t\t\tXT_DCCP_DEST_PORTS, info->flags, info->invflags)\n\t\t&& DCCHECK(match_types(dh, info->typemask),\n\t\t\t   XT_DCCP_TYPE, info->flags, info->invflags)\n\t\t&& DCCHECK(match_option(info->option, skb, par->thoff, dh,\n\t\t\t\t\t&par->hotdrop),\n\t\t\t   XT_DCCP_OPTION, info->flags, info->invflags);\n}\n\nstatic int dccp_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_dccp_info *info = par->matchinfo;\n\n\tif (info->flags & ~XT_DCCP_VALID_FLAGS)\n\t\treturn -EINVAL;\n\tif (info->invflags & ~XT_DCCP_VALID_FLAGS)\n\t\treturn -EINVAL;\n\tif (info->invflags & ~info->flags)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct xt_match dccp_mt_reg[] __read_mostly = {\n\t{\n\t\t.name \t\t= \"dccp\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.checkentry\t= dccp_mt_check,\n\t\t.match\t\t= dccp_mt,\n\t\t.matchsize\t= sizeof(struct xt_dccp_info),\n\t\t.proto\t\t= IPPROTO_DCCP,\n\t\t.me \t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name \t\t= \"dccp\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.checkentry\t= dccp_mt_check,\n\t\t.match\t\t= dccp_mt,\n\t\t.matchsize\t= sizeof(struct xt_dccp_info),\n\t\t.proto\t\t= IPPROTO_DCCP,\n\t\t.me \t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init dccp_mt_init(void)\n{\n\tint ret;\n\n\t \n\tdccp_optbuf = kmalloc(256 * 4, GFP_KERNEL);\n\tif (!dccp_optbuf)\n\t\treturn -ENOMEM;\n\tret = xt_register_matches(dccp_mt_reg, ARRAY_SIZE(dccp_mt_reg));\n\tif (ret)\n\t\tgoto out_kfree;\n\treturn ret;\n\nout_kfree:\n\tkfree(dccp_optbuf);\n\treturn ret;\n}\n\nstatic void __exit dccp_mt_exit(void)\n{\n\txt_unregister_matches(dccp_mt_reg, ARRAY_SIZE(dccp_mt_reg));\n\tkfree(dccp_optbuf);\n}\n\nmodule_init(dccp_mt_init);\nmodule_exit(dccp_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}