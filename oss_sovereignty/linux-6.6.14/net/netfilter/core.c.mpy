{
  "module_name": "core.c",
  "hash_id": "6fb321f7490f0a1dac0a1921c0d35ed4fbca1d3cded7c5d77f91a768114fd36f",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/core.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/netfilter.h>\n#include <net/protocol.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/if.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/inetdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/rcupdate.h>\n#include <net/net_namespace.h>\n#include <net/netfilter/nf_queue.h>\n#include <net/sock.h>\n\n#include \"nf_internals.h\"\n\nconst struct nf_ipv6_ops __rcu *nf_ipv6_ops __read_mostly;\nEXPORT_SYMBOL_GPL(nf_ipv6_ops);\n\nDEFINE_PER_CPU(bool, nf_skb_duplicated);\nEXPORT_SYMBOL_GPL(nf_skb_duplicated);\n\n#ifdef CONFIG_JUMP_LABEL\nstruct static_key nf_hooks_needed[NFPROTO_NUMPROTO][NF_MAX_HOOKS];\nEXPORT_SYMBOL(nf_hooks_needed);\n#endif\n\nstatic DEFINE_MUTEX(nf_hook_mutex);\n\n \n#define MAX_HOOK_COUNT\t\t1024\n\n#define nf_entry_dereference(e) \\\n\trcu_dereference_protected(e, lockdep_is_held(&nf_hook_mutex))\n\nstatic struct nf_hook_entries *allocate_hook_entries_size(u16 num)\n{\n\tstruct nf_hook_entries *e;\n\tsize_t alloc = sizeof(*e) +\n\t\t       sizeof(struct nf_hook_entry) * num +\n\t\t       sizeof(struct nf_hook_ops *) * num +\n\t\t       sizeof(struct nf_hook_entries_rcu_head);\n\n\tif (num == 0)\n\t\treturn NULL;\n\n\te = kvzalloc(alloc, GFP_KERNEL_ACCOUNT);\n\tif (e)\n\t\te->num_hook_entries = num;\n\treturn e;\n}\n\nstatic void __nf_hook_entries_free(struct rcu_head *h)\n{\n\tstruct nf_hook_entries_rcu_head *head;\n\n\thead = container_of(h, struct nf_hook_entries_rcu_head, head);\n\tkvfree(head->allocation);\n}\n\nstatic void nf_hook_entries_free(struct nf_hook_entries *e)\n{\n\tstruct nf_hook_entries_rcu_head *head;\n\tstruct nf_hook_ops **ops;\n\tunsigned int num;\n\n\tif (!e)\n\t\treturn;\n\n\tnum = e->num_hook_entries;\n\tops = nf_hook_entries_get_hook_ops(e);\n\thead = (void *)&ops[num];\n\thead->allocation = e;\n\tcall_rcu(&head->head, __nf_hook_entries_free);\n}\n\nstatic unsigned int accept_all(void *priv,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       const struct nf_hook_state *state)\n{\n\treturn NF_ACCEPT;  \n}\n\nstatic const struct nf_hook_ops dummy_ops = {\n\t.hook = accept_all,\n\t.priority = INT_MIN,\n};\n\nstatic struct nf_hook_entries *\nnf_hook_entries_grow(const struct nf_hook_entries *old,\n\t\t     const struct nf_hook_ops *reg)\n{\n\tunsigned int i, alloc_entries, nhooks, old_entries;\n\tstruct nf_hook_ops **orig_ops = NULL;\n\tstruct nf_hook_ops **new_ops;\n\tstruct nf_hook_entries *new;\n\tbool inserted = false;\n\n\talloc_entries = 1;\n\told_entries = old ? old->num_hook_entries : 0;\n\n\tif (old) {\n\t\torig_ops = nf_hook_entries_get_hook_ops(old);\n\n\t\tfor (i = 0; i < old_entries; i++) {\n\t\t\tif (orig_ops[i] != &dummy_ops)\n\t\t\t\talloc_entries++;\n\n\t\t\t \n\t\t\tif (reg->priority == orig_ops[i]->priority &&\n\t\t\t    reg->hook_ops_type == NF_HOOK_OP_BPF)\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\t\t}\n\t}\n\n\tif (alloc_entries > MAX_HOOK_COUNT)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tnew = allocate_hook_entries_size(alloc_entries);\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_ops = nf_hook_entries_get_hook_ops(new);\n\n\ti = 0;\n\tnhooks = 0;\n\twhile (i < old_entries) {\n\t\tif (orig_ops[i] == &dummy_ops) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (inserted || reg->priority > orig_ops[i]->priority) {\n\t\t\tnew_ops[nhooks] = (void *)orig_ops[i];\n\t\t\tnew->hooks[nhooks] = old->hooks[i];\n\t\t\ti++;\n\t\t} else {\n\t\t\tnew_ops[nhooks] = (void *)reg;\n\t\t\tnew->hooks[nhooks].hook = reg->hook;\n\t\t\tnew->hooks[nhooks].priv = reg->priv;\n\t\t\tinserted = true;\n\t\t}\n\t\tnhooks++;\n\t}\n\n\tif (!inserted) {\n\t\tnew_ops[nhooks] = (void *)reg;\n\t\tnew->hooks[nhooks].hook = reg->hook;\n\t\tnew->hooks[nhooks].priv = reg->priv;\n\t}\n\n\treturn new;\n}\n\nstatic void hooks_validate(const struct nf_hook_entries *hooks)\n{\n#ifdef CONFIG_DEBUG_MISC\n\tstruct nf_hook_ops **orig_ops;\n\tint prio = INT_MIN;\n\tsize_t i = 0;\n\n\torig_ops = nf_hook_entries_get_hook_ops(hooks);\n\n\tfor (i = 0; i < hooks->num_hook_entries; i++) {\n\t\tif (orig_ops[i] == &dummy_ops)\n\t\t\tcontinue;\n\n\t\tWARN_ON(orig_ops[i]->priority < prio);\n\n\t\tif (orig_ops[i]->priority > prio)\n\t\t\tprio = orig_ops[i]->priority;\n\t}\n#endif\n}\n\nint nf_hook_entries_insert_raw(struct nf_hook_entries __rcu **pp,\n\t\t\t\tconst struct nf_hook_ops *reg)\n{\n\tstruct nf_hook_entries *new_hooks;\n\tstruct nf_hook_entries *p;\n\n\tp = rcu_dereference_raw(*pp);\n\tnew_hooks = nf_hook_entries_grow(p, reg);\n\tif (IS_ERR(new_hooks))\n\t\treturn PTR_ERR(new_hooks);\n\n\thooks_validate(new_hooks);\n\n\trcu_assign_pointer(*pp, new_hooks);\n\n\tBUG_ON(p == new_hooks);\n\tnf_hook_entries_free(p);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_hook_entries_insert_raw);\n\n \nstatic void *__nf_hook_entries_try_shrink(struct nf_hook_entries *old,\n\t\t\t\t\t  struct nf_hook_entries __rcu **pp)\n{\n\tunsigned int i, j, skip = 0, hook_entries;\n\tstruct nf_hook_entries *new = NULL;\n\tstruct nf_hook_ops **orig_ops;\n\tstruct nf_hook_ops **new_ops;\n\n\tif (WARN_ON_ONCE(!old))\n\t\treturn NULL;\n\n\torig_ops = nf_hook_entries_get_hook_ops(old);\n\tfor (i = 0; i < old->num_hook_entries; i++) {\n\t\tif (orig_ops[i] == &dummy_ops)\n\t\t\tskip++;\n\t}\n\n\t \n\thook_entries = old->num_hook_entries;\n\tif (skip == hook_entries)\n\t\tgoto out_assign;\n\n\tif (skip == 0)\n\t\treturn NULL;\n\n\thook_entries -= skip;\n\tnew = allocate_hook_entries_size(hook_entries);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew_ops = nf_hook_entries_get_hook_ops(new);\n\tfor (i = 0, j = 0; i < old->num_hook_entries; i++) {\n\t\tif (orig_ops[i] == &dummy_ops)\n\t\t\tcontinue;\n\t\tnew->hooks[j] = old->hooks[i];\n\t\tnew_ops[j] = (void *)orig_ops[i];\n\t\tj++;\n\t}\n\thooks_validate(new);\nout_assign:\n\trcu_assign_pointer(*pp, new);\n\treturn old;\n}\n\nstatic struct nf_hook_entries __rcu **\nnf_hook_entry_head(struct net *net, int pf, unsigned int hooknum,\n\t\t   struct net_device *dev)\n{\n\tswitch (pf) {\n\tcase NFPROTO_NETDEV:\n\t\tbreak;\n#ifdef CONFIG_NETFILTER_FAMILY_ARP\n\tcase NFPROTO_ARP:\n\t\tif (WARN_ON_ONCE(ARRAY_SIZE(net->nf.hooks_arp) <= hooknum))\n\t\t\treturn NULL;\n\t\treturn net->nf.hooks_arp + hooknum;\n#endif\n#ifdef CONFIG_NETFILTER_FAMILY_BRIDGE\n\tcase NFPROTO_BRIDGE:\n\t\tif (WARN_ON_ONCE(ARRAY_SIZE(net->nf.hooks_bridge) <= hooknum))\n\t\t\treturn NULL;\n\t\treturn net->nf.hooks_bridge + hooknum;\n#endif\n#ifdef CONFIG_NETFILTER_INGRESS\n\tcase NFPROTO_INET:\n\t\tif (WARN_ON_ONCE(hooknum != NF_INET_INGRESS))\n\t\t\treturn NULL;\n\t\tif (!dev || dev_net(dev) != net) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn &dev->nf_hooks_ingress;\n#endif\n\tcase NFPROTO_IPV4:\n\t\tif (WARN_ON_ONCE(ARRAY_SIZE(net->nf.hooks_ipv4) <= hooknum))\n\t\t\treturn NULL;\n\t\treturn net->nf.hooks_ipv4 + hooknum;\n\tcase NFPROTO_IPV6:\n\t\tif (WARN_ON_ONCE(ARRAY_SIZE(net->nf.hooks_ipv6) <= hooknum))\n\t\t\treturn NULL;\n\t\treturn net->nf.hooks_ipv6 + hooknum;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn NULL;\n\t}\n\n#ifdef CONFIG_NETFILTER_INGRESS\n\tif (hooknum == NF_NETDEV_INGRESS) {\n\t\tif (dev && dev_net(dev) == net)\n\t\t\treturn &dev->nf_hooks_ingress;\n\t}\n#endif\n#ifdef CONFIG_NETFILTER_EGRESS\n\tif (hooknum == NF_NETDEV_EGRESS) {\n\t\tif (dev && dev_net(dev) == net)\n\t\t\treturn &dev->nf_hooks_egress;\n\t}\n#endif\n\tWARN_ON_ONCE(1);\n\treturn NULL;\n}\n\nstatic int nf_ingress_check(struct net *net, const struct nf_hook_ops *reg,\n\t\t\t    int hooknum)\n{\n#ifndef CONFIG_NETFILTER_INGRESS\n\tif (reg->hooknum == hooknum)\n\t\treturn -EOPNOTSUPP;\n#endif\n\tif (reg->hooknum != hooknum ||\n\t    !reg->dev || dev_net(reg->dev) != net)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline bool __maybe_unused nf_ingress_hook(const struct nf_hook_ops *reg,\n\t\t\t\t\t\t  int pf)\n{\n\tif ((pf == NFPROTO_NETDEV && reg->hooknum == NF_NETDEV_INGRESS) ||\n\t    (pf == NFPROTO_INET && reg->hooknum == NF_INET_INGRESS))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool __maybe_unused nf_egress_hook(const struct nf_hook_ops *reg,\n\t\t\t\t\t\t int pf)\n{\n\treturn pf == NFPROTO_NETDEV && reg->hooknum == NF_NETDEV_EGRESS;\n}\n\nstatic void nf_static_key_inc(const struct nf_hook_ops *reg, int pf)\n{\n#ifdef CONFIG_JUMP_LABEL\n\tint hooknum;\n\n\tif (pf == NFPROTO_INET && reg->hooknum == NF_INET_INGRESS) {\n\t\tpf = NFPROTO_NETDEV;\n\t\thooknum = NF_NETDEV_INGRESS;\n\t} else {\n\t\thooknum = reg->hooknum;\n\t}\n\tstatic_key_slow_inc(&nf_hooks_needed[pf][hooknum]);\n#endif\n}\n\nstatic void nf_static_key_dec(const struct nf_hook_ops *reg, int pf)\n{\n#ifdef CONFIG_JUMP_LABEL\n\tint hooknum;\n\n\tif (pf == NFPROTO_INET && reg->hooknum == NF_INET_INGRESS) {\n\t\tpf = NFPROTO_NETDEV;\n\t\thooknum = NF_NETDEV_INGRESS;\n\t} else {\n\t\thooknum = reg->hooknum;\n\t}\n\tstatic_key_slow_dec(&nf_hooks_needed[pf][hooknum]);\n#endif\n}\n\nstatic int __nf_register_net_hook(struct net *net, int pf,\n\t\t\t\t  const struct nf_hook_ops *reg)\n{\n\tstruct nf_hook_entries *p, *new_hooks;\n\tstruct nf_hook_entries __rcu **pp;\n\tint err;\n\n\tswitch (pf) {\n\tcase NFPROTO_NETDEV:\n#ifndef CONFIG_NETFILTER_INGRESS\n\t\tif (reg->hooknum == NF_NETDEV_INGRESS)\n\t\t\treturn -EOPNOTSUPP;\n#endif\n#ifndef CONFIG_NETFILTER_EGRESS\n\t\tif (reg->hooknum == NF_NETDEV_EGRESS)\n\t\t\treturn -EOPNOTSUPP;\n#endif\n\t\tif ((reg->hooknum != NF_NETDEV_INGRESS &&\n\t\t     reg->hooknum != NF_NETDEV_EGRESS) ||\n\t\t    !reg->dev || dev_net(reg->dev) != net)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NFPROTO_INET:\n\t\tif (reg->hooknum != NF_INET_INGRESS)\n\t\t\tbreak;\n\n\t\terr = nf_ingress_check(net, reg, NF_INET_INGRESS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\tpp = nf_hook_entry_head(net, pf, reg->hooknum, reg->dev);\n\tif (!pp)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&nf_hook_mutex);\n\n\tp = nf_entry_dereference(*pp);\n\tnew_hooks = nf_hook_entries_grow(p, reg);\n\n\tif (!IS_ERR(new_hooks)) {\n\t\thooks_validate(new_hooks);\n\t\trcu_assign_pointer(*pp, new_hooks);\n\t}\n\n\tmutex_unlock(&nf_hook_mutex);\n\tif (IS_ERR(new_hooks))\n\t\treturn PTR_ERR(new_hooks);\n\n#ifdef CONFIG_NETFILTER_INGRESS\n\tif (nf_ingress_hook(reg, pf))\n\t\tnet_inc_ingress_queue();\n#endif\n#ifdef CONFIG_NETFILTER_EGRESS\n\tif (nf_egress_hook(reg, pf))\n\t\tnet_inc_egress_queue();\n#endif\n\tnf_static_key_inc(reg, pf);\n\n\tBUG_ON(p == new_hooks);\n\tnf_hook_entries_free(p);\n\treturn 0;\n}\n\n \nstatic bool nf_remove_net_hook(struct nf_hook_entries *old,\n\t\t\t       const struct nf_hook_ops *unreg)\n{\n\tstruct nf_hook_ops **orig_ops;\n\tunsigned int i;\n\n\torig_ops = nf_hook_entries_get_hook_ops(old);\n\tfor (i = 0; i < old->num_hook_entries; i++) {\n\t\tif (orig_ops[i] != unreg)\n\t\t\tcontinue;\n\t\tWRITE_ONCE(old->hooks[i].hook, accept_all);\n\t\tWRITE_ONCE(orig_ops[i], (void *)&dummy_ops);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void __nf_unregister_net_hook(struct net *net, int pf,\n\t\t\t\t     const struct nf_hook_ops *reg)\n{\n\tstruct nf_hook_entries __rcu **pp;\n\tstruct nf_hook_entries *p;\n\n\tpp = nf_hook_entry_head(net, pf, reg->hooknum, reg->dev);\n\tif (!pp)\n\t\treturn;\n\n\tmutex_lock(&nf_hook_mutex);\n\n\tp = nf_entry_dereference(*pp);\n\tif (WARN_ON_ONCE(!p)) {\n\t\tmutex_unlock(&nf_hook_mutex);\n\t\treturn;\n\t}\n\n\tif (nf_remove_net_hook(p, reg)) {\n#ifdef CONFIG_NETFILTER_INGRESS\n\t\tif (nf_ingress_hook(reg, pf))\n\t\t\tnet_dec_ingress_queue();\n#endif\n#ifdef CONFIG_NETFILTER_EGRESS\n\t\tif (nf_egress_hook(reg, pf))\n\t\t\tnet_dec_egress_queue();\n#endif\n\t\tnf_static_key_dec(reg, pf);\n\t} else {\n\t\tWARN_ONCE(1, \"hook not found, pf %d num %d\", pf, reg->hooknum);\n\t}\n\n\tp = __nf_hook_entries_try_shrink(p, pp);\n\tmutex_unlock(&nf_hook_mutex);\n\tif (!p)\n\t\treturn;\n\n\tnf_queue_nf_hook_drop(net);\n\tnf_hook_entries_free(p);\n}\n\nvoid nf_unregister_net_hook(struct net *net, const struct nf_hook_ops *reg)\n{\n\tif (reg->pf == NFPROTO_INET) {\n\t\tif (reg->hooknum == NF_INET_INGRESS) {\n\t\t\t__nf_unregister_net_hook(net, NFPROTO_INET, reg);\n\t\t} else {\n\t\t\t__nf_unregister_net_hook(net, NFPROTO_IPV4, reg);\n\t\t\t__nf_unregister_net_hook(net, NFPROTO_IPV6, reg);\n\t\t}\n\t} else {\n\t\t__nf_unregister_net_hook(net, reg->pf, reg);\n\t}\n}\nEXPORT_SYMBOL(nf_unregister_net_hook);\n\nvoid nf_hook_entries_delete_raw(struct nf_hook_entries __rcu **pp,\n\t\t\t\tconst struct nf_hook_ops *reg)\n{\n\tstruct nf_hook_entries *p;\n\n\tp = rcu_dereference_raw(*pp);\n\tif (nf_remove_net_hook(p, reg)) {\n\t\tp = __nf_hook_entries_try_shrink(p, pp);\n\t\tnf_hook_entries_free(p);\n\t}\n}\nEXPORT_SYMBOL_GPL(nf_hook_entries_delete_raw);\n\nint nf_register_net_hook(struct net *net, const struct nf_hook_ops *reg)\n{\n\tint err;\n\n\tif (reg->pf == NFPROTO_INET) {\n\t\tif (reg->hooknum == NF_INET_INGRESS) {\n\t\t\terr = __nf_register_net_hook(net, NFPROTO_INET, reg);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\terr = __nf_register_net_hook(net, NFPROTO_IPV4, reg);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\terr = __nf_register_net_hook(net, NFPROTO_IPV6, reg);\n\t\t\tif (err < 0) {\n\t\t\t\t__nf_unregister_net_hook(net, NFPROTO_IPV4, reg);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\terr = __nf_register_net_hook(net, reg->pf, reg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nf_register_net_hook);\n\nint nf_register_net_hooks(struct net *net, const struct nf_hook_ops *reg,\n\t\t\t  unsigned int n)\n{\n\tunsigned int i;\n\tint err = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\terr = nf_register_net_hook(net, &reg[i]);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\treturn err;\n\nerr:\n\tif (i > 0)\n\t\tnf_unregister_net_hooks(net, reg, i);\n\treturn err;\n}\nEXPORT_SYMBOL(nf_register_net_hooks);\n\nvoid nf_unregister_net_hooks(struct net *net, const struct nf_hook_ops *reg,\n\t\t\t     unsigned int hookcount)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hookcount; i++)\n\t\tnf_unregister_net_hook(net, &reg[i]);\n}\nEXPORT_SYMBOL(nf_unregister_net_hooks);\n\n \nint nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,\n\t\t const struct nf_hook_entries *e, unsigned int s)\n{\n\tunsigned int verdict;\n\tint ret;\n\n\tfor (; s < e->num_hook_entries; s++) {\n\t\tverdict = nf_hook_entry_hookfn(&e->hooks[s], skb, state);\n\t\tswitch (verdict & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\t\tbreak;\n\t\tcase NF_DROP:\n\t\t\tkfree_skb_reason(skb,\n\t\t\t\t\t SKB_DROP_REASON_NETFILTER_DROP);\n\t\t\tret = NF_DROP_GETERR(verdict);\n\t\t\tif (ret == 0)\n\t\t\t\tret = -EPERM;\n\t\t\treturn ret;\n\t\tcase NF_QUEUE:\n\t\t\tret = nf_queue(skb, state, s, verdict);\n\t\t\tif (ret == 1)\n\t\t\t\tcontinue;\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL(nf_hook_slow);\n\nvoid nf_hook_slow_list(struct list_head *head, struct nf_hook_state *state,\n\t\t       const struct nf_hook_entries *e)\n{\n\tstruct sk_buff *skb, *next;\n\tstruct list_head sublist;\n\tint ret;\n\n\tINIT_LIST_HEAD(&sublist);\n\n\tlist_for_each_entry_safe(skb, next, head, list) {\n\t\tskb_list_del_init(skb);\n\t\tret = nf_hook_slow(skb, state, e, 0);\n\t\tif (ret == 1)\n\t\t\tlist_add_tail(&skb->list, &sublist);\n\t}\n\t \n\tlist_splice(&sublist, head);\n}\nEXPORT_SYMBOL(nf_hook_slow_list);\n\n \nconst struct nfnl_ct_hook __rcu *nfnl_ct_hook __read_mostly;\nEXPORT_SYMBOL_GPL(nfnl_ct_hook);\n\nconst struct nf_ct_hook __rcu *nf_ct_hook __read_mostly;\nEXPORT_SYMBOL_GPL(nf_ct_hook);\n\nconst struct nf_defrag_hook __rcu *nf_defrag_v4_hook __read_mostly;\nEXPORT_SYMBOL_GPL(nf_defrag_v4_hook);\n\nconst struct nf_defrag_hook __rcu *nf_defrag_v6_hook __read_mostly;\nEXPORT_SYMBOL_GPL(nf_defrag_v6_hook);\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\nu8 nf_ctnetlink_has_listener;\nEXPORT_SYMBOL_GPL(nf_ctnetlink_has_listener);\n\nconst struct nf_nat_hook __rcu *nf_nat_hook __read_mostly;\nEXPORT_SYMBOL_GPL(nf_nat_hook);\n\n \nvoid nf_ct_attach(struct sk_buff *new, const struct sk_buff *skb)\n{\n\tconst struct nf_ct_hook *ct_hook;\n\n\tif (skb->_nfct) {\n\t\trcu_read_lock();\n\t\tct_hook = rcu_dereference(nf_ct_hook);\n\t\tif (ct_hook)\n\t\t\tct_hook->attach(new, skb);\n\t\trcu_read_unlock();\n\t}\n}\nEXPORT_SYMBOL(nf_ct_attach);\n\nvoid nf_conntrack_destroy(struct nf_conntrack *nfct)\n{\n\tconst struct nf_ct_hook *ct_hook;\n\n\trcu_read_lock();\n\tct_hook = rcu_dereference(nf_ct_hook);\n\tif (ct_hook)\n\t\tct_hook->destroy(nfct);\n\trcu_read_unlock();\n\n\tWARN_ON(!ct_hook);\n}\nEXPORT_SYMBOL(nf_conntrack_destroy);\n\nvoid nf_ct_set_closing(struct nf_conntrack *nfct)\n{\n\tconst struct nf_ct_hook *ct_hook;\n\n\tif (!nfct)\n\t\treturn;\n\n\trcu_read_lock();\n\tct_hook = rcu_dereference(nf_ct_hook);\n\tif (ct_hook)\n\t\tct_hook->set_closing(nfct);\n\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(nf_ct_set_closing);\n\nbool nf_ct_get_tuple_skb(struct nf_conntrack_tuple *dst_tuple,\n\t\t\t const struct sk_buff *skb)\n{\n\tconst struct nf_ct_hook *ct_hook;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tct_hook = rcu_dereference(nf_ct_hook);\n\tif (ct_hook)\n\t\tret = ct_hook->get_tuple_skb(dst_tuple, skb);\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL(nf_ct_get_tuple_skb);\n\n \nconst struct nf_conntrack_zone nf_ct_zone_dflt = {\n\t.id\t= NF_CT_DEFAULT_ZONE_ID,\n\t.dir\t= NF_CT_DEFAULT_ZONE_DIR,\n};\nEXPORT_SYMBOL_GPL(nf_ct_zone_dflt);\n#endif  \n\nstatic void __net_init\n__netfilter_net_init(struct nf_hook_entries __rcu **e, int max)\n{\n\tint h;\n\n\tfor (h = 0; h < max; h++)\n\t\tRCU_INIT_POINTER(e[h], NULL);\n}\n\nstatic int __net_init netfilter_net_init(struct net *net)\n{\n\t__netfilter_net_init(net->nf.hooks_ipv4, ARRAY_SIZE(net->nf.hooks_ipv4));\n\t__netfilter_net_init(net->nf.hooks_ipv6, ARRAY_SIZE(net->nf.hooks_ipv6));\n#ifdef CONFIG_NETFILTER_FAMILY_ARP\n\t__netfilter_net_init(net->nf.hooks_arp, ARRAY_SIZE(net->nf.hooks_arp));\n#endif\n#ifdef CONFIG_NETFILTER_FAMILY_BRIDGE\n\t__netfilter_net_init(net->nf.hooks_bridge, ARRAY_SIZE(net->nf.hooks_bridge));\n#endif\n#ifdef CONFIG_PROC_FS\n\tnet->nf.proc_netfilter = proc_net_mkdir(net, \"netfilter\",\n\t\t\t\t\t\tnet->proc_net);\n\tif (!net->nf.proc_netfilter) {\n\t\tif (!net_eq(net, &init_net))\n\t\t\tpr_err(\"cannot create netfilter proc entry\");\n\n\t\treturn -ENOMEM;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic void __net_exit netfilter_net_exit(struct net *net)\n{\n\tremove_proc_entry(\"netfilter\", net->proc_net);\n}\n\nstatic struct pernet_operations netfilter_net_ops = {\n\t.init = netfilter_net_init,\n\t.exit = netfilter_net_exit,\n};\n\nint __init netfilter_init(void)\n{\n\tint ret;\n\n\tret = register_pernet_subsys(&netfilter_net_ops);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = netfilter_log_init();\n\tif (ret < 0)\n\t\tgoto err_pernet;\n\n\treturn 0;\nerr_pernet:\n\tunregister_pernet_subsys(&netfilter_net_ops);\nerr:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}