{
  "module_name": "nf_synproxy_core.c",
  "hash_id": "d3c6979137fb43f192184c7fb16dcd322cb6a2be42c1d1528feb3a60f62a11ae",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_synproxy_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <asm/unaligned.h>\n#include <net/tcp.h>\n#include <net/netns/generic.h>\n#include <linux/proc_fs.h>\n\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter/nf_synproxy.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_extend.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/nf_conntrack_synproxy.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/nf_synproxy.h>\n\nunsigned int synproxy_net_id;\nEXPORT_SYMBOL_GPL(synproxy_net_id);\n\nbool\nsynproxy_parse_options(const struct sk_buff *skb, unsigned int doff,\n\t\t       const struct tcphdr *th, struct synproxy_options *opts)\n{\n\tint length = (th->doff * 4) - sizeof(*th);\n\tu8 buf[40], *ptr;\n\n\tif (unlikely(length < 0))\n\t\treturn false;\n\n\tptr = skb_header_pointer(skb, doff + sizeof(*th), length, buf);\n\tif (ptr == NULL)\n\t\treturn false;\n\n\topts->options = 0;\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn true;\n\t\tcase TCPOPT_NOP:\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (length < 2)\n\t\t\t\treturn true;\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2)\n\t\t\t\treturn true;\n\t\t\tif (opsize > length)\n\t\t\t\treturn true;\n\n\t\t\tswitch (opcode) {\n\t\t\tcase TCPOPT_MSS:\n\t\t\t\tif (opsize == TCPOLEN_MSS) {\n\t\t\t\t\topts->mss_option = get_unaligned_be16(ptr);\n\t\t\t\t\topts->options |= NF_SYNPROXY_OPT_MSS;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_WINDOW:\n\t\t\t\tif (opsize == TCPOLEN_WINDOW) {\n\t\t\t\t\topts->wscale = *ptr;\n\t\t\t\t\tif (opts->wscale > TCP_MAX_WSCALE)\n\t\t\t\t\t\topts->wscale = TCP_MAX_WSCALE;\n\t\t\t\t\topts->options |= NF_SYNPROXY_OPT_WSCALE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_TIMESTAMP:\n\t\t\t\tif (opsize == TCPOLEN_TIMESTAMP) {\n\t\t\t\t\topts->tsval = get_unaligned_be32(ptr);\n\t\t\t\t\topts->tsecr = get_unaligned_be32(ptr + 4);\n\t\t\t\t\topts->options |= NF_SYNPROXY_OPT_TIMESTAMP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_SACK_PERM:\n\t\t\t\tif (opsize == TCPOLEN_SACK_PERM)\n\t\t\t\t\topts->options |= NF_SYNPROXY_OPT_SACK_PERM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tptr += opsize - 2;\n\t\t\tlength -= opsize;\n\t\t}\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(synproxy_parse_options);\n\nstatic unsigned int\nsynproxy_options_size(const struct synproxy_options *opts)\n{\n\tunsigned int size = 0;\n\n\tif (opts->options & NF_SYNPROXY_OPT_MSS)\n\t\tsize += TCPOLEN_MSS_ALIGNED;\n\tif (opts->options & NF_SYNPROXY_OPT_TIMESTAMP)\n\t\tsize += TCPOLEN_TSTAMP_ALIGNED;\n\telse if (opts->options & NF_SYNPROXY_OPT_SACK_PERM)\n\t\tsize += TCPOLEN_SACKPERM_ALIGNED;\n\tif (opts->options & NF_SYNPROXY_OPT_WSCALE)\n\t\tsize += TCPOLEN_WSCALE_ALIGNED;\n\n\treturn size;\n}\n\nstatic void\nsynproxy_build_options(struct tcphdr *th, const struct synproxy_options *opts)\n{\n\t__be32 *ptr = (__be32 *)(th + 1);\n\tu8 options = opts->options;\n\n\tif (options & NF_SYNPROXY_OPT_MSS)\n\t\t*ptr++ = htonl((TCPOPT_MSS << 24) |\n\t\t\t       (TCPOLEN_MSS << 16) |\n\t\t\t       opts->mss_option);\n\n\tif (options & NF_SYNPROXY_OPT_TIMESTAMP) {\n\t\tif (options & NF_SYNPROXY_OPT_SACK_PERM)\n\t\t\t*ptr++ = htonl((TCPOPT_SACK_PERM << 24) |\n\t\t\t\t       (TCPOLEN_SACK_PERM << 16) |\n\t\t\t\t       (TCPOPT_TIMESTAMP << 8) |\n\t\t\t\t       TCPOLEN_TIMESTAMP);\n\t\telse\n\t\t\t*ptr++ = htonl((TCPOPT_NOP << 24) |\n\t\t\t\t       (TCPOPT_NOP << 16) |\n\t\t\t\t       (TCPOPT_TIMESTAMP << 8) |\n\t\t\t\t       TCPOLEN_TIMESTAMP);\n\n\t\t*ptr++ = htonl(opts->tsval);\n\t\t*ptr++ = htonl(opts->tsecr);\n\t} else if (options & NF_SYNPROXY_OPT_SACK_PERM)\n\t\t*ptr++ = htonl((TCPOPT_NOP << 24) |\n\t\t\t       (TCPOPT_NOP << 16) |\n\t\t\t       (TCPOPT_SACK_PERM << 8) |\n\t\t\t       TCPOLEN_SACK_PERM);\n\n\tif (options & NF_SYNPROXY_OPT_WSCALE)\n\t\t*ptr++ = htonl((TCPOPT_NOP << 24) |\n\t\t\t       (TCPOPT_WINDOW << 16) |\n\t\t\t       (TCPOLEN_WINDOW << 8) |\n\t\t\t       opts->wscale);\n}\n\nvoid synproxy_init_timestamp_cookie(const struct nf_synproxy_info *info,\n\t\t\t\t    struct synproxy_options *opts)\n{\n\topts->tsecr = opts->tsval;\n\topts->tsval = tcp_time_stamp_raw() & ~0x3f;\n\n\tif (opts->options & NF_SYNPROXY_OPT_WSCALE) {\n\t\topts->tsval |= opts->wscale;\n\t\topts->wscale = info->wscale;\n\t} else\n\t\topts->tsval |= 0xf;\n\n\tif (opts->options & NF_SYNPROXY_OPT_SACK_PERM)\n\t\topts->tsval |= 1 << 4;\n\n\tif (opts->options & NF_SYNPROXY_OPT_ECN)\n\t\topts->tsval |= 1 << 5;\n}\nEXPORT_SYMBOL_GPL(synproxy_init_timestamp_cookie);\n\nstatic void\nsynproxy_check_timestamp_cookie(struct synproxy_options *opts)\n{\n\topts->wscale = opts->tsecr & 0xf;\n\tif (opts->wscale != 0xf)\n\t\topts->options |= NF_SYNPROXY_OPT_WSCALE;\n\n\topts->options |= opts->tsecr & (1 << 4) ? NF_SYNPROXY_OPT_SACK_PERM : 0;\n\n\topts->options |= opts->tsecr & (1 << 5) ? NF_SYNPROXY_OPT_ECN : 0;\n}\n\nstatic unsigned int\nsynproxy_tstamp_adjust(struct sk_buff *skb, unsigned int protoff,\n\t\t       struct tcphdr *th, struct nf_conn *ct,\n\t\t       enum ip_conntrack_info ctinfo,\n\t\t       const struct nf_conn_synproxy *synproxy)\n{\n\tunsigned int optoff, optend;\n\t__be32 *ptr, old;\n\n\tif (synproxy->tsoff == 0)\n\t\treturn 1;\n\n\toptoff = protoff + sizeof(struct tcphdr);\n\toptend = protoff + th->doff * 4;\n\n\tif (skb_ensure_writable(skb, optend))\n\t\treturn 0;\n\n\twhile (optoff < optend) {\n\t\tunsigned char *op = skb->data + optoff;\n\n\t\tswitch (op[0]) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn 1;\n\t\tcase TCPOPT_NOP:\n\t\t\toptoff++;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (optoff + 1 == optend ||\n\t\t\t    optoff + op[1] > optend ||\n\t\t\t    op[1] < 2)\n\t\t\t\treturn 0;\n\t\t\tif (op[0] == TCPOPT_TIMESTAMP &&\n\t\t\t    op[1] == TCPOLEN_TIMESTAMP) {\n\t\t\t\tif (CTINFO2DIR(ctinfo) == IP_CT_DIR_REPLY) {\n\t\t\t\t\tptr = (__be32 *)&op[2];\n\t\t\t\t\told = *ptr;\n\t\t\t\t\t*ptr = htonl(ntohl(*ptr) -\n\t\t\t\t\t\t     synproxy->tsoff);\n\t\t\t\t} else {\n\t\t\t\t\tptr = (__be32 *)&op[6];\n\t\t\t\t\told = *ptr;\n\t\t\t\t\t*ptr = htonl(ntohl(*ptr) +\n\t\t\t\t\t\t     synproxy->tsoff);\n\t\t\t\t}\n\t\t\t\tinet_proto_csum_replace4(&th->check, skb,\n\t\t\t\t\t\t\t old, *ptr, false);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\toptoff += op[1];\n\t\t}\n\t}\n\treturn 1;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void *synproxy_cpu_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct synproxy_net *snet = synproxy_pernet(seq_file_net(seq));\n\tint cpu;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (cpu = *pos - 1; cpu < nr_cpu_ids; cpu++) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*pos = cpu + 1;\n\t\treturn per_cpu_ptr(snet->stats, cpu);\n\t}\n\n\treturn NULL;\n}\n\nstatic void *synproxy_cpu_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct synproxy_net *snet = synproxy_pernet(seq_file_net(seq));\n\tint cpu;\n\n\tfor (cpu = *pos; cpu < nr_cpu_ids; cpu++) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*pos = cpu + 1;\n\t\treturn per_cpu_ptr(snet->stats, cpu);\n\t}\n\t(*pos)++;\n\treturn NULL;\n}\n\nstatic void synproxy_cpu_seq_stop(struct seq_file *seq, void *v)\n{\n\treturn;\n}\n\nstatic int synproxy_cpu_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct synproxy_stats *stats = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"entries\\t\\tsyn_received\\t\"\n\t\t\t      \"cookie_invalid\\tcookie_valid\\t\"\n\t\t\t      \"cookie_retrans\\tconn_reopened\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(seq, \"%08x\\t%08x\\t%08x\\t%08x\\t%08x\\t%08x\\n\", 0,\n\t\t   stats->syn_received,\n\t\t   stats->cookie_invalid,\n\t\t   stats->cookie_valid,\n\t\t   stats->cookie_retrans,\n\t\t   stats->conn_reopened);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations synproxy_cpu_seq_ops = {\n\t.start\t\t= synproxy_cpu_seq_start,\n\t.next\t\t= synproxy_cpu_seq_next,\n\t.stop\t\t= synproxy_cpu_seq_stop,\n\t.show\t\t= synproxy_cpu_seq_show,\n};\n\nstatic int __net_init synproxy_proc_init(struct net *net)\n{\n\tif (!proc_create_net(\"synproxy\", 0444, net->proc_net_stat,\n\t\t\t&synproxy_cpu_seq_ops, sizeof(struct seq_net_private)))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __net_exit synproxy_proc_exit(struct net *net)\n{\n\tremove_proc_entry(\"synproxy\", net->proc_net_stat);\n}\n#else\nstatic int __net_init synproxy_proc_init(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void __net_exit synproxy_proc_exit(struct net *net)\n{\n\treturn;\n}\n#endif  \n\nstatic int __net_init synproxy_net_init(struct net *net)\n{\n\tstruct synproxy_net *snet = synproxy_pernet(net);\n\tstruct nf_conn *ct;\n\tint err = -ENOMEM;\n\n\tct = nf_ct_tmpl_alloc(net, &nf_ct_zone_dflt, GFP_KERNEL);\n\tif (!ct)\n\t\tgoto err1;\n\n\tif (!nfct_seqadj_ext_add(ct))\n\t\tgoto err2;\n\tif (!nfct_synproxy_ext_add(ct))\n\t\tgoto err2;\n\n\t__set_bit(IPS_CONFIRMED_BIT, &ct->status);\n\tsnet->tmpl = ct;\n\n\tsnet->stats = alloc_percpu(struct synproxy_stats);\n\tif (snet->stats == NULL)\n\t\tgoto err2;\n\n\terr = synproxy_proc_init(net);\n\tif (err < 0)\n\t\tgoto err3;\n\n\treturn 0;\n\nerr3:\n\tfree_percpu(snet->stats);\nerr2:\n\tnf_ct_tmpl_free(ct);\nerr1:\n\treturn err;\n}\n\nstatic void __net_exit synproxy_net_exit(struct net *net)\n{\n\tstruct synproxy_net *snet = synproxy_pernet(net);\n\n\tnf_ct_put(snet->tmpl);\n\tsynproxy_proc_exit(net);\n\tfree_percpu(snet->stats);\n}\n\nstatic struct pernet_operations synproxy_net_ops = {\n\t.init\t\t= synproxy_net_init,\n\t.exit\t\t= synproxy_net_exit,\n\t.id\t\t= &synproxy_net_id,\n\t.size\t\t= sizeof(struct synproxy_net),\n};\n\nstatic int __init synproxy_core_init(void)\n{\n\treturn register_pernet_subsys(&synproxy_net_ops);\n}\n\nstatic void __exit synproxy_core_exit(void)\n{\n\tunregister_pernet_subsys(&synproxy_net_ops);\n}\n\nmodule_init(synproxy_core_init);\nmodule_exit(synproxy_core_exit);\n\nstatic struct iphdr *\nsynproxy_build_ip(struct net *net, struct sk_buff *skb, __be32 saddr,\n\t\t  __be32 daddr)\n{\n\tstruct iphdr *iph;\n\n\tskb_reset_network_header(skb);\n\tiph = skb_put(skb, sizeof(*iph));\n\tiph->version\t= 4;\n\tiph->ihl\t= sizeof(*iph) / 4;\n\tiph->tos\t= 0;\n\tiph->id\t\t= 0;\n\tiph->frag_off\t= htons(IP_DF);\n\tiph->ttl\t= READ_ONCE(net->ipv4.sysctl_ip_default_ttl);\n\tiph->protocol\t= IPPROTO_TCP;\n\tiph->check\t= 0;\n\tiph->saddr\t= saddr;\n\tiph->daddr\t= daddr;\n\n\treturn iph;\n}\n\nstatic void\nsynproxy_send_tcp(struct net *net,\n\t\t  const struct sk_buff *skb, struct sk_buff *nskb,\n\t\t  struct nf_conntrack *nfct, enum ip_conntrack_info ctinfo,\n\t\t  struct iphdr *niph, struct tcphdr *nth,\n\t\t  unsigned int tcp_hdr_size)\n{\n\tnth->check = ~tcp_v4_check(tcp_hdr_size, niph->saddr, niph->daddr, 0);\n\tnskb->ip_summed   = CHECKSUM_PARTIAL;\n\tnskb->csum_start  = (unsigned char *)nth - nskb->head;\n\tnskb->csum_offset = offsetof(struct tcphdr, check);\n\n\tskb_dst_set_noref(nskb, skb_dst(skb));\n\tnskb->protocol = htons(ETH_P_IP);\n\tif (ip_route_me_harder(net, nskb->sk, nskb, RTN_UNSPEC))\n\t\tgoto free_nskb;\n\n\tif (nfct) {\n\t\tnf_ct_set(nskb, (struct nf_conn *)nfct, ctinfo);\n\t\tnf_conntrack_get(nfct);\n\t}\n\n\tip_local_out(net, nskb->sk, nskb);\n\treturn;\n\nfree_nskb:\n\tkfree_skb(nskb);\n}\n\nvoid\nsynproxy_send_client_synack(struct net *net,\n\t\t\t    const struct sk_buff *skb, const struct tcphdr *th,\n\t\t\t    const struct synproxy_options *opts)\n{\n\tstruct sk_buff *nskb;\n\tstruct iphdr *iph, *niph;\n\tstruct tcphdr *nth;\n\tunsigned int tcp_hdr_size;\n\tu16 mss = opts->mss_encode;\n\n\tiph = ip_hdr(skb);\n\n\ttcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\n\tnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\n\t\t\t GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\tskb_reserve(nskb, MAX_TCP_HEADER);\n\n\tniph = synproxy_build_ip(net, nskb, iph->daddr, iph->saddr);\n\n\tskb_reset_transport_header(nskb);\n\tnth = skb_put(nskb, tcp_hdr_size);\n\tnth->source\t= th->dest;\n\tnth->dest\t= th->source;\n\tnth->seq\t= htonl(__cookie_v4_init_sequence(iph, th, &mss));\n\tnth->ack_seq\t= htonl(ntohl(th->seq) + 1);\n\ttcp_flag_word(nth) = TCP_FLAG_SYN | TCP_FLAG_ACK;\n\tif (opts->options & NF_SYNPROXY_OPT_ECN)\n\t\ttcp_flag_word(nth) |= TCP_FLAG_ECE;\n\tnth->doff\t= tcp_hdr_size / 4;\n\tnth->window\t= 0;\n\tnth->check\t= 0;\n\tnth->urg_ptr\t= 0;\n\n\tsynproxy_build_options(nth, opts);\n\n\tsynproxy_send_tcp(net, skb, nskb, skb_nfct(skb),\n\t\t\t  IP_CT_ESTABLISHED_REPLY, niph, nth, tcp_hdr_size);\n}\nEXPORT_SYMBOL_GPL(synproxy_send_client_synack);\n\nstatic void\nsynproxy_send_server_syn(struct net *net,\n\t\t\t const struct sk_buff *skb, const struct tcphdr *th,\n\t\t\t const struct synproxy_options *opts, u32 recv_seq)\n{\n\tstruct synproxy_net *snet = synproxy_pernet(net);\n\tstruct sk_buff *nskb;\n\tstruct iphdr *iph, *niph;\n\tstruct tcphdr *nth;\n\tunsigned int tcp_hdr_size;\n\n\tiph = ip_hdr(skb);\n\n\ttcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\n\tnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\n\t\t\t GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\tskb_reserve(nskb, MAX_TCP_HEADER);\n\n\tniph = synproxy_build_ip(net, nskb, iph->saddr, iph->daddr);\n\n\tskb_reset_transport_header(nskb);\n\tnth = skb_put(nskb, tcp_hdr_size);\n\tnth->source\t= th->source;\n\tnth->dest\t= th->dest;\n\tnth->seq\t= htonl(recv_seq - 1);\n\t \n\tnth->ack_seq\t= htonl(ntohl(th->ack_seq) - 1);\n\ttcp_flag_word(nth) = TCP_FLAG_SYN;\n\tif (opts->options & NF_SYNPROXY_OPT_ECN)\n\t\ttcp_flag_word(nth) |= TCP_FLAG_ECE | TCP_FLAG_CWR;\n\tnth->doff\t= tcp_hdr_size / 4;\n\tnth->window\t= th->window;\n\tnth->check\t= 0;\n\tnth->urg_ptr\t= 0;\n\n\tsynproxy_build_options(nth, opts);\n\n\tsynproxy_send_tcp(net, skb, nskb, &snet->tmpl->ct_general, IP_CT_NEW,\n\t\t\t  niph, nth, tcp_hdr_size);\n}\n\nstatic void\nsynproxy_send_server_ack(struct net *net,\n\t\t\t const struct ip_ct_tcp *state,\n\t\t\t const struct sk_buff *skb, const struct tcphdr *th,\n\t\t\t const struct synproxy_options *opts)\n{\n\tstruct sk_buff *nskb;\n\tstruct iphdr *iph, *niph;\n\tstruct tcphdr *nth;\n\tunsigned int tcp_hdr_size;\n\n\tiph = ip_hdr(skb);\n\n\ttcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\n\tnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\n\t\t\t GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\tskb_reserve(nskb, MAX_TCP_HEADER);\n\n\tniph = synproxy_build_ip(net, nskb, iph->daddr, iph->saddr);\n\n\tskb_reset_transport_header(nskb);\n\tnth = skb_put(nskb, tcp_hdr_size);\n\tnth->source\t= th->dest;\n\tnth->dest\t= th->source;\n\tnth->seq\t= htonl(ntohl(th->ack_seq));\n\tnth->ack_seq\t= htonl(ntohl(th->seq) + 1);\n\ttcp_flag_word(nth) = TCP_FLAG_ACK;\n\tnth->doff\t= tcp_hdr_size / 4;\n\tnth->window\t= htons(state->seen[IP_CT_DIR_ORIGINAL].td_maxwin);\n\tnth->check\t= 0;\n\tnth->urg_ptr\t= 0;\n\n\tsynproxy_build_options(nth, opts);\n\n\tsynproxy_send_tcp(net, skb, nskb, NULL, 0, niph, nth, tcp_hdr_size);\n}\n\nstatic void\nsynproxy_send_client_ack(struct net *net,\n\t\t\t const struct sk_buff *skb, const struct tcphdr *th,\n\t\t\t const struct synproxy_options *opts)\n{\n\tstruct sk_buff *nskb;\n\tstruct iphdr *iph, *niph;\n\tstruct tcphdr *nth;\n\tunsigned int tcp_hdr_size;\n\n\tiph = ip_hdr(skb);\n\n\ttcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\n\tnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\n\t\t\t GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\tskb_reserve(nskb, MAX_TCP_HEADER);\n\n\tniph = synproxy_build_ip(net, nskb, iph->saddr, iph->daddr);\n\n\tskb_reset_transport_header(nskb);\n\tnth = skb_put(nskb, tcp_hdr_size);\n\tnth->source\t= th->source;\n\tnth->dest\t= th->dest;\n\tnth->seq\t= htonl(ntohl(th->seq) + 1);\n\tnth->ack_seq\t= th->ack_seq;\n\ttcp_flag_word(nth) = TCP_FLAG_ACK;\n\tnth->doff\t= tcp_hdr_size / 4;\n\tnth->window\t= htons(ntohs(th->window) >> opts->wscale);\n\tnth->check\t= 0;\n\tnth->urg_ptr\t= 0;\n\n\tsynproxy_build_options(nth, opts);\n\n\tsynproxy_send_tcp(net, skb, nskb, skb_nfct(skb),\n\t\t\t  IP_CT_ESTABLISHED_REPLY, niph, nth, tcp_hdr_size);\n}\n\nbool\nsynproxy_recv_client_ack(struct net *net,\n\t\t\t const struct sk_buff *skb, const struct tcphdr *th,\n\t\t\t struct synproxy_options *opts, u32 recv_seq)\n{\n\tstruct synproxy_net *snet = synproxy_pernet(net);\n\tint mss;\n\n\tmss = __cookie_v4_check(ip_hdr(skb), th, ntohl(th->ack_seq) - 1);\n\tif (mss == 0) {\n\t\tthis_cpu_inc(snet->stats->cookie_invalid);\n\t\treturn false;\n\t}\n\n\tthis_cpu_inc(snet->stats->cookie_valid);\n\topts->mss_option = mss;\n\topts->options |= NF_SYNPROXY_OPT_MSS;\n\n\tif (opts->options & NF_SYNPROXY_OPT_TIMESTAMP)\n\t\tsynproxy_check_timestamp_cookie(opts);\n\n\tsynproxy_send_server_syn(net, skb, th, opts, recv_seq);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(synproxy_recv_client_ack);\n\nunsigned int\nipv4_synproxy_hook(void *priv, struct sk_buff *skb,\n\t\t   const struct nf_hook_state *nhs)\n{\n\tstruct net *net = nhs->net;\n\tstruct synproxy_net *snet = synproxy_pernet(net);\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\tstruct nf_conn_synproxy *synproxy;\n\tstruct synproxy_options opts = {};\n\tconst struct ip_ct_tcp *state;\n\tstruct tcphdr *th, _th;\n\tunsigned int thoff;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (!ct)\n\t\treturn NF_ACCEPT;\n\n\tsynproxy = nfct_synproxy(ct);\n\tif (!synproxy)\n\t\treturn NF_ACCEPT;\n\n\tif (nf_is_loopback_packet(skb) ||\n\t    ip_hdr(skb)->protocol != IPPROTO_TCP)\n\t\treturn NF_ACCEPT;\n\n\tthoff = ip_hdrlen(skb);\n\tth = skb_header_pointer(skb, thoff, sizeof(_th), &_th);\n\tif (!th)\n\t\treturn NF_DROP;\n\n\tstate = &ct->proto.tcp;\n\tswitch (state->state) {\n\tcase TCP_CONNTRACK_CLOSE:\n\t\tif (th->rst && CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL) {\n\t\t\tnf_ct_seqadj_init(ct, ctinfo, synproxy->isn -\n\t\t\t\t\t\t      ntohl(th->seq) + 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!th->syn || th->ack ||\n\t\t    CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)\n\t\t\tbreak;\n\n\t\t \n\t\tnf_ct_seqadj_init(ct, ctinfo, 0);\n\t\tsynproxy->tsoff = 0;\n\t\tthis_cpu_inc(snet->stats->conn_reopened);\n\t\tfallthrough;\n\tcase TCP_CONNTRACK_SYN_SENT:\n\t\tif (!synproxy_parse_options(skb, thoff, th, &opts))\n\t\t\treturn NF_DROP;\n\n\t\tif (!th->syn && th->ack &&\n\t\t    CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) {\n\t\t\t \n\t\t\tif (synproxy_recv_client_ack(net, skb, th, &opts,\n\t\t\t\t\t\t     ntohl(th->seq) + 1)) {\n\t\t\t\tthis_cpu_inc(snet->stats->cookie_retrans);\n\t\t\t\tconsume_skb(skb);\n\t\t\t\treturn NF_STOLEN;\n\t\t\t} else {\n\t\t\t\treturn NF_DROP;\n\t\t\t}\n\t\t}\n\n\t\tsynproxy->isn = ntohl(th->ack_seq);\n\t\tif (opts.options & NF_SYNPROXY_OPT_TIMESTAMP)\n\t\t\tsynproxy->its = opts.tsecr;\n\n\t\tnf_conntrack_event_cache(IPCT_SYNPROXY, ct);\n\t\tbreak;\n\tcase TCP_CONNTRACK_SYN_RECV:\n\t\tif (!th->syn || !th->ack)\n\t\t\tbreak;\n\n\t\tif (!synproxy_parse_options(skb, thoff, th, &opts))\n\t\t\treturn NF_DROP;\n\n\t\tif (opts.options & NF_SYNPROXY_OPT_TIMESTAMP) {\n\t\t\tsynproxy->tsoff = opts.tsval - synproxy->its;\n\t\t\tnf_conntrack_event_cache(IPCT_SYNPROXY, ct);\n\t\t}\n\n\t\topts.options &= ~(NF_SYNPROXY_OPT_MSS |\n\t\t\t\t  NF_SYNPROXY_OPT_WSCALE |\n\t\t\t\t  NF_SYNPROXY_OPT_SACK_PERM);\n\n\t\tswap(opts.tsval, opts.tsecr);\n\t\tsynproxy_send_server_ack(net, state, skb, th, &opts);\n\n\t\tnf_ct_seqadj_init(ct, ctinfo, synproxy->isn - ntohl(th->seq));\n\t\tnf_conntrack_event_cache(IPCT_SEQADJ, ct);\n\n\t\tswap(opts.tsval, opts.tsecr);\n\t\tsynproxy_send_client_ack(net, skb, th, &opts);\n\n\t\tconsume_skb(skb);\n\t\treturn NF_STOLEN;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsynproxy_tstamp_adjust(skb, thoff, th, ct, ctinfo, synproxy);\n\treturn NF_ACCEPT;\n}\nEXPORT_SYMBOL_GPL(ipv4_synproxy_hook);\n\nstatic const struct nf_hook_ops ipv4_synproxy_ops[] = {\n\t{\n\t\t.hook\t\t= ipv4_synproxy_hook,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_LOCAL_IN,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK_CONFIRM - 1,\n\t},\n\t{\n\t\t.hook\t\t= ipv4_synproxy_hook,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_POST_ROUTING,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK_CONFIRM - 1,\n\t},\n};\n\nint nf_synproxy_ipv4_init(struct synproxy_net *snet, struct net *net)\n{\n\tint err;\n\n\tif (snet->hook_ref4 == 0) {\n\t\terr = nf_register_net_hooks(net, ipv4_synproxy_ops,\n\t\t\t\t\t    ARRAY_SIZE(ipv4_synproxy_ops));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsnet->hook_ref4++;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_synproxy_ipv4_init);\n\nvoid nf_synproxy_ipv4_fini(struct synproxy_net *snet, struct net *net)\n{\n\tsnet->hook_ref4--;\n\tif (snet->hook_ref4 == 0)\n\t\tnf_unregister_net_hooks(net, ipv4_synproxy_ops,\n\t\t\t\t\tARRAY_SIZE(ipv4_synproxy_ops));\n}\nEXPORT_SYMBOL_GPL(nf_synproxy_ipv4_fini);\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct ipv6hdr *\nsynproxy_build_ip_ipv6(struct net *net, struct sk_buff *skb,\n\t\t       const struct in6_addr *saddr,\n\t\t       const struct in6_addr *daddr)\n{\n\tstruct ipv6hdr *iph;\n\n\tskb_reset_network_header(skb);\n\tiph = skb_put(skb, sizeof(*iph));\n\tip6_flow_hdr(iph, 0, 0);\n\tiph->hop_limit\t= net->ipv6.devconf_all->hop_limit;\n\tiph->nexthdr\t= IPPROTO_TCP;\n\tiph->saddr\t= *saddr;\n\tiph->daddr\t= *daddr;\n\n\treturn iph;\n}\n\nstatic void\nsynproxy_send_tcp_ipv6(struct net *net,\n\t\t       const struct sk_buff *skb, struct sk_buff *nskb,\n\t\t       struct nf_conntrack *nfct, enum ip_conntrack_info ctinfo,\n\t\t       struct ipv6hdr *niph, struct tcphdr *nth,\n\t\t       unsigned int tcp_hdr_size)\n{\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\tint err;\n\n\tnth->check = ~tcp_v6_check(tcp_hdr_size, &niph->saddr, &niph->daddr, 0);\n\tnskb->ip_summed   = CHECKSUM_PARTIAL;\n\tnskb->csum_start  = (unsigned char *)nth - nskb->head;\n\tnskb->csum_offset = offsetof(struct tcphdr, check);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tfl6.saddr = niph->saddr;\n\tfl6.daddr = niph->daddr;\n\tfl6.fl6_sport = nth->source;\n\tfl6.fl6_dport = nth->dest;\n\tsecurity_skb_classify_flow((struct sk_buff *)skb,\n\t\t\t\t   flowi6_to_flowi_common(&fl6));\n\terr = nf_ip6_route(net, &dst, flowi6_to_flowi(&fl6), false);\n\tif (err) {\n\t\tgoto free_nskb;\n\t}\n\n\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\n\tif (IS_ERR(dst))\n\t\tgoto free_nskb;\n\n\tskb_dst_set(nskb, dst);\n\n\tif (nfct) {\n\t\tnf_ct_set(nskb, (struct nf_conn *)nfct, ctinfo);\n\t\tnf_conntrack_get(nfct);\n\t}\n\n\tip6_local_out(net, nskb->sk, nskb);\n\treturn;\n\nfree_nskb:\n\tkfree_skb(nskb);\n}\n\nvoid\nsynproxy_send_client_synack_ipv6(struct net *net,\n\t\t\t\t const struct sk_buff *skb,\n\t\t\t\t const struct tcphdr *th,\n\t\t\t\t const struct synproxy_options *opts)\n{\n\tstruct sk_buff *nskb;\n\tstruct ipv6hdr *iph, *niph;\n\tstruct tcphdr *nth;\n\tunsigned int tcp_hdr_size;\n\tu16 mss = opts->mss_encode;\n\n\tiph = ipv6_hdr(skb);\n\n\ttcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\n\tnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\n\t\t\t GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\tskb_reserve(nskb, MAX_TCP_HEADER);\n\n\tniph = synproxy_build_ip_ipv6(net, nskb, &iph->daddr, &iph->saddr);\n\n\tskb_reset_transport_header(nskb);\n\tnth = skb_put(nskb, tcp_hdr_size);\n\tnth->source\t= th->dest;\n\tnth->dest\t= th->source;\n\tnth->seq\t= htonl(nf_ipv6_cookie_init_sequence(iph, th, &mss));\n\tnth->ack_seq\t= htonl(ntohl(th->seq) + 1);\n\ttcp_flag_word(nth) = TCP_FLAG_SYN | TCP_FLAG_ACK;\n\tif (opts->options & NF_SYNPROXY_OPT_ECN)\n\t\ttcp_flag_word(nth) |= TCP_FLAG_ECE;\n\tnth->doff\t= tcp_hdr_size / 4;\n\tnth->window\t= 0;\n\tnth->check\t= 0;\n\tnth->urg_ptr\t= 0;\n\n\tsynproxy_build_options(nth, opts);\n\n\tsynproxy_send_tcp_ipv6(net, skb, nskb, skb_nfct(skb),\n\t\t\t       IP_CT_ESTABLISHED_REPLY, niph, nth,\n\t\t\t       tcp_hdr_size);\n}\nEXPORT_SYMBOL_GPL(synproxy_send_client_synack_ipv6);\n\nstatic void\nsynproxy_send_server_syn_ipv6(struct net *net, const struct sk_buff *skb,\n\t\t\t      const struct tcphdr *th,\n\t\t\t      const struct synproxy_options *opts, u32 recv_seq)\n{\n\tstruct synproxy_net *snet = synproxy_pernet(net);\n\tstruct sk_buff *nskb;\n\tstruct ipv6hdr *iph, *niph;\n\tstruct tcphdr *nth;\n\tunsigned int tcp_hdr_size;\n\n\tiph = ipv6_hdr(skb);\n\n\ttcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\n\tnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\n\t\t\t GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\tskb_reserve(nskb, MAX_TCP_HEADER);\n\n\tniph = synproxy_build_ip_ipv6(net, nskb, &iph->saddr, &iph->daddr);\n\n\tskb_reset_transport_header(nskb);\n\tnth = skb_put(nskb, tcp_hdr_size);\n\tnth->source\t= th->source;\n\tnth->dest\t= th->dest;\n\tnth->seq\t= htonl(recv_seq - 1);\n\t \n\tnth->ack_seq\t= htonl(ntohl(th->ack_seq) - 1);\n\ttcp_flag_word(nth) = TCP_FLAG_SYN;\n\tif (opts->options & NF_SYNPROXY_OPT_ECN)\n\t\ttcp_flag_word(nth) |= TCP_FLAG_ECE | TCP_FLAG_CWR;\n\tnth->doff\t= tcp_hdr_size / 4;\n\tnth->window\t= th->window;\n\tnth->check\t= 0;\n\tnth->urg_ptr\t= 0;\n\n\tsynproxy_build_options(nth, opts);\n\n\tsynproxy_send_tcp_ipv6(net, skb, nskb, &snet->tmpl->ct_general,\n\t\t\t       IP_CT_NEW, niph, nth, tcp_hdr_size);\n}\n\nstatic void\nsynproxy_send_server_ack_ipv6(struct net *net, const struct ip_ct_tcp *state,\n\t\t\t      const struct sk_buff *skb,\n\t\t\t      const struct tcphdr *th,\n\t\t\t      const struct synproxy_options *opts)\n{\n\tstruct sk_buff *nskb;\n\tstruct ipv6hdr *iph, *niph;\n\tstruct tcphdr *nth;\n\tunsigned int tcp_hdr_size;\n\n\tiph = ipv6_hdr(skb);\n\n\ttcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\n\tnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\n\t\t\t GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\tskb_reserve(nskb, MAX_TCP_HEADER);\n\n\tniph = synproxy_build_ip_ipv6(net, nskb, &iph->daddr, &iph->saddr);\n\n\tskb_reset_transport_header(nskb);\n\tnth = skb_put(nskb, tcp_hdr_size);\n\tnth->source\t= th->dest;\n\tnth->dest\t= th->source;\n\tnth->seq\t= htonl(ntohl(th->ack_seq));\n\tnth->ack_seq\t= htonl(ntohl(th->seq) + 1);\n\ttcp_flag_word(nth) = TCP_FLAG_ACK;\n\tnth->doff\t= tcp_hdr_size / 4;\n\tnth->window\t= htons(state->seen[IP_CT_DIR_ORIGINAL].td_maxwin);\n\tnth->check\t= 0;\n\tnth->urg_ptr\t= 0;\n\n\tsynproxy_build_options(nth, opts);\n\n\tsynproxy_send_tcp_ipv6(net, skb, nskb, NULL, 0, niph, nth,\n\t\t\t       tcp_hdr_size);\n}\n\nstatic void\nsynproxy_send_client_ack_ipv6(struct net *net, const struct sk_buff *skb,\n\t\t\t      const struct tcphdr *th,\n\t\t\t      const struct synproxy_options *opts)\n{\n\tstruct sk_buff *nskb;\n\tstruct ipv6hdr *iph, *niph;\n\tstruct tcphdr *nth;\n\tunsigned int tcp_hdr_size;\n\n\tiph = ipv6_hdr(skb);\n\n\ttcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\n\tnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\n\t\t\t GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\tskb_reserve(nskb, MAX_TCP_HEADER);\n\n\tniph = synproxy_build_ip_ipv6(net, nskb, &iph->saddr, &iph->daddr);\n\n\tskb_reset_transport_header(nskb);\n\tnth = skb_put(nskb, tcp_hdr_size);\n\tnth->source\t= th->source;\n\tnth->dest\t= th->dest;\n\tnth->seq\t= htonl(ntohl(th->seq) + 1);\n\tnth->ack_seq\t= th->ack_seq;\n\ttcp_flag_word(nth) = TCP_FLAG_ACK;\n\tnth->doff\t= tcp_hdr_size / 4;\n\tnth->window\t= htons(ntohs(th->window) >> opts->wscale);\n\tnth->check\t= 0;\n\tnth->urg_ptr\t= 0;\n\n\tsynproxy_build_options(nth, opts);\n\n\tsynproxy_send_tcp_ipv6(net, skb, nskb, skb_nfct(skb),\n\t\t\t       IP_CT_ESTABLISHED_REPLY, niph, nth,\n\t\t\t       tcp_hdr_size);\n}\n\nbool\nsynproxy_recv_client_ack_ipv6(struct net *net,\n\t\t\t      const struct sk_buff *skb,\n\t\t\t      const struct tcphdr *th,\n\t\t\t      struct synproxy_options *opts, u32 recv_seq)\n{\n\tstruct synproxy_net *snet = synproxy_pernet(net);\n\tint mss;\n\n\tmss = nf_cookie_v6_check(ipv6_hdr(skb), th, ntohl(th->ack_seq) - 1);\n\tif (mss == 0) {\n\t\tthis_cpu_inc(snet->stats->cookie_invalid);\n\t\treturn false;\n\t}\n\n\tthis_cpu_inc(snet->stats->cookie_valid);\n\topts->mss_option = mss;\n\topts->options |= NF_SYNPROXY_OPT_MSS;\n\n\tif (opts->options & NF_SYNPROXY_OPT_TIMESTAMP)\n\t\tsynproxy_check_timestamp_cookie(opts);\n\n\tsynproxy_send_server_syn_ipv6(net, skb, th, opts, recv_seq);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(synproxy_recv_client_ack_ipv6);\n\nunsigned int\nipv6_synproxy_hook(void *priv, struct sk_buff *skb,\n\t\t   const struct nf_hook_state *nhs)\n{\n\tstruct net *net = nhs->net;\n\tstruct synproxy_net *snet = synproxy_pernet(net);\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\tstruct nf_conn_synproxy *synproxy;\n\tstruct synproxy_options opts = {};\n\tconst struct ip_ct_tcp *state;\n\tstruct tcphdr *th, _th;\n\t__be16 frag_off;\n\tu8 nexthdr;\n\tint thoff;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (!ct)\n\t\treturn NF_ACCEPT;\n\n\tsynproxy = nfct_synproxy(ct);\n\tif (!synproxy)\n\t\treturn NF_ACCEPT;\n\n\tif (nf_is_loopback_packet(skb))\n\t\treturn NF_ACCEPT;\n\n\tnexthdr = ipv6_hdr(skb)->nexthdr;\n\tthoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr,\n\t\t\t\t &frag_off);\n\tif (thoff < 0 || nexthdr != IPPROTO_TCP)\n\t\treturn NF_ACCEPT;\n\n\tth = skb_header_pointer(skb, thoff, sizeof(_th), &_th);\n\tif (!th)\n\t\treturn NF_DROP;\n\n\tstate = &ct->proto.tcp;\n\tswitch (state->state) {\n\tcase TCP_CONNTRACK_CLOSE:\n\t\tif (th->rst && CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL) {\n\t\t\tnf_ct_seqadj_init(ct, ctinfo, synproxy->isn -\n\t\t\t\t\t\t      ntohl(th->seq) + 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!th->syn || th->ack ||\n\t\t    CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)\n\t\t\tbreak;\n\n\t\t \n\t\tnf_ct_seqadj_init(ct, ctinfo, 0);\n\t\tsynproxy->tsoff = 0;\n\t\tthis_cpu_inc(snet->stats->conn_reopened);\n\t\tfallthrough;\n\tcase TCP_CONNTRACK_SYN_SENT:\n\t\tif (!synproxy_parse_options(skb, thoff, th, &opts))\n\t\t\treturn NF_DROP;\n\n\t\tif (!th->syn && th->ack &&\n\t\t    CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) {\n\t\t\t \n\t\t\tif (synproxy_recv_client_ack_ipv6(net, skb, th, &opts,\n\t\t\t\t\t\t\t  ntohl(th->seq) + 1)) {\n\t\t\t\tthis_cpu_inc(snet->stats->cookie_retrans);\n\t\t\t\tconsume_skb(skb);\n\t\t\t\treturn NF_STOLEN;\n\t\t\t} else {\n\t\t\t\treturn NF_DROP;\n\t\t\t}\n\t\t}\n\n\t\tsynproxy->isn = ntohl(th->ack_seq);\n\t\tif (opts.options & NF_SYNPROXY_OPT_TIMESTAMP)\n\t\t\tsynproxy->its = opts.tsecr;\n\n\t\tnf_conntrack_event_cache(IPCT_SYNPROXY, ct);\n\t\tbreak;\n\tcase TCP_CONNTRACK_SYN_RECV:\n\t\tif (!th->syn || !th->ack)\n\t\t\tbreak;\n\n\t\tif (!synproxy_parse_options(skb, thoff, th, &opts))\n\t\t\treturn NF_DROP;\n\n\t\tif (opts.options & NF_SYNPROXY_OPT_TIMESTAMP) {\n\t\t\tsynproxy->tsoff = opts.tsval - synproxy->its;\n\t\t\tnf_conntrack_event_cache(IPCT_SYNPROXY, ct);\n\t\t}\n\n\t\topts.options &= ~(NF_SYNPROXY_OPT_MSS |\n\t\t\t\t  NF_SYNPROXY_OPT_WSCALE |\n\t\t\t\t  NF_SYNPROXY_OPT_SACK_PERM);\n\n\t\tswap(opts.tsval, opts.tsecr);\n\t\tsynproxy_send_server_ack_ipv6(net, state, skb, th, &opts);\n\n\t\tnf_ct_seqadj_init(ct, ctinfo, synproxy->isn - ntohl(th->seq));\n\t\tnf_conntrack_event_cache(IPCT_SEQADJ, ct);\n\n\t\tswap(opts.tsval, opts.tsecr);\n\t\tsynproxy_send_client_ack_ipv6(net, skb, th, &opts);\n\n\t\tconsume_skb(skb);\n\t\treturn NF_STOLEN;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsynproxy_tstamp_adjust(skb, thoff, th, ct, ctinfo, synproxy);\n\treturn NF_ACCEPT;\n}\nEXPORT_SYMBOL_GPL(ipv6_synproxy_hook);\n\nstatic const struct nf_hook_ops ipv6_synproxy_ops[] = {\n\t{\n\t\t.hook\t\t= ipv6_synproxy_hook,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_LOCAL_IN,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK_CONFIRM - 1,\n\t},\n\t{\n\t\t.hook\t\t= ipv6_synproxy_hook,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_POST_ROUTING,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK_CONFIRM - 1,\n\t},\n};\n\nint\nnf_synproxy_ipv6_init(struct synproxy_net *snet, struct net *net)\n{\n\tint err;\n\n\tif (snet->hook_ref6 == 0) {\n\t\terr = nf_register_net_hooks(net, ipv6_synproxy_ops,\n\t\t\t\t\t    ARRAY_SIZE(ipv6_synproxy_ops));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsnet->hook_ref6++;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_synproxy_ipv6_init);\n\nvoid\nnf_synproxy_ipv6_fini(struct synproxy_net *snet, struct net *net)\n{\n\tsnet->hook_ref6--;\n\tif (snet->hook_ref6 == 0)\n\t\tnf_unregister_net_hooks(net, ipv6_synproxy_ops,\n\t\t\t\t\tARRAY_SIZE(ipv6_synproxy_ops));\n}\nEXPORT_SYMBOL_GPL(nf_synproxy_ipv6_fini);\n#endif  \n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_DESCRIPTION(\"nftables SYNPROXY expression support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}