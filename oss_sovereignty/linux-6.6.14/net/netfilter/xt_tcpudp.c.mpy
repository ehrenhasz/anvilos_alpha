{
  "module_name": "xt_tcpudp.c",
  "hash_id": "2c06f1bccef0d30191f4da28d10603835095eb2d407e8480503e66f8d25a5491",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_tcpudp.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/types.h>\n#include <linux/module.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/icmp.h>\n#include <net/ipv6.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_tcpudp.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n\nMODULE_DESCRIPTION(\"Xtables: TCP, UDP and UDP-Lite match\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"xt_tcp\");\nMODULE_ALIAS(\"xt_udp\");\nMODULE_ALIAS(\"ipt_udp\");\nMODULE_ALIAS(\"ipt_tcp\");\nMODULE_ALIAS(\"ip6t_udp\");\nMODULE_ALIAS(\"ip6t_tcp\");\nMODULE_ALIAS(\"ipt_icmp\");\nMODULE_ALIAS(\"ip6t_icmp6\");\n\n \nstatic inline bool\nport_match(u_int16_t min, u_int16_t max, u_int16_t port, bool invert)\n{\n\treturn (port >= min && port <= max) ^ invert;\n}\n\nstatic bool\ntcp_find_option(u_int8_t option,\n\t\tconst struct sk_buff *skb,\n\t\tunsigned int protoff,\n\t\tunsigned int optlen,\n\t\tbool invert,\n\t\tbool *hotdrop)\n{\n\t \n\tconst u_int8_t *op;\n\tu_int8_t _opt[60 - sizeof(struct tcphdr)];\n\tunsigned int i;\n\n\tpr_debug(\"finding option\\n\");\n\n\tif (!optlen)\n\t\treturn invert;\n\n\t \n\top = skb_header_pointer(skb, protoff + sizeof(struct tcphdr),\n\t\t\t\toptlen, _opt);\n\tif (op == NULL) {\n\t\t*hotdrop = true;\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < optlen; ) {\n\t\tif (op[i] == option) return !invert;\n\t\tif (op[i] < 2) i++;\n\t\telse i += op[i+1]?:1;\n\t}\n\n\treturn invert;\n}\n\nstatic bool tcp_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct tcphdr *th;\n\tstruct tcphdr _tcph;\n\tconst struct xt_tcp *tcpinfo = par->matchinfo;\n\n\tif (par->fragoff != 0) {\n\t\t \n\t\tif (par->fragoff == 1) {\n\t\t\tpr_debug(\"Dropping evil TCP offset=1 frag.\\n\");\n\t\t\tpar->hotdrop = true;\n\t\t}\n\t\t \n\t\treturn false;\n\t}\n\n\tth = skb_header_pointer(skb, par->thoff, sizeof(_tcph), &_tcph);\n\tif (th == NULL) {\n\t\t \n\t\tpr_debug(\"Dropping evil TCP offset=0 tinygram.\\n\");\n\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\tif (!port_match(tcpinfo->spts[0], tcpinfo->spts[1],\n\t\t\tntohs(th->source),\n\t\t\t!!(tcpinfo->invflags & XT_TCP_INV_SRCPT)))\n\t\treturn false;\n\tif (!port_match(tcpinfo->dpts[0], tcpinfo->dpts[1],\n\t\t\tntohs(th->dest),\n\t\t\t!!(tcpinfo->invflags & XT_TCP_INV_DSTPT)))\n\t\treturn false;\n\tif (!NF_INVF(tcpinfo, XT_TCP_INV_FLAGS,\n\t\t     (((unsigned char *)th)[13] & tcpinfo->flg_mask) == tcpinfo->flg_cmp))\n\t\treturn false;\n\tif (tcpinfo->option) {\n\t\tif (th->doff * 4 < sizeof(_tcph)) {\n\t\t\tpar->hotdrop = true;\n\t\t\treturn false;\n\t\t}\n\t\tif (!tcp_find_option(tcpinfo->option, skb, par->thoff,\n\t\t\t\t     th->doff*4 - sizeof(_tcph),\n\t\t\t\t     tcpinfo->invflags & XT_TCP_INV_OPTION,\n\t\t\t\t     &par->hotdrop))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int tcp_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_tcp *tcpinfo = par->matchinfo;\n\n\t \n\treturn (tcpinfo->invflags & ~XT_TCP_INV_MASK) ? -EINVAL : 0;\n}\n\nstatic bool udp_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct udphdr *uh;\n\tstruct udphdr _udph;\n\tconst struct xt_udp *udpinfo = par->matchinfo;\n\n\t \n\tif (par->fragoff != 0)\n\t\treturn false;\n\n\tuh = skb_header_pointer(skb, par->thoff, sizeof(_udph), &_udph);\n\tif (uh == NULL) {\n\t\t \n\t\tpr_debug(\"Dropping evil UDP tinygram.\\n\");\n\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\treturn port_match(udpinfo->spts[0], udpinfo->spts[1],\n\t\t\t  ntohs(uh->source),\n\t\t\t  !!(udpinfo->invflags & XT_UDP_INV_SRCPT))\n\t\t&& port_match(udpinfo->dpts[0], udpinfo->dpts[1],\n\t\t\t      ntohs(uh->dest),\n\t\t\t      !!(udpinfo->invflags & XT_UDP_INV_DSTPT));\n}\n\nstatic int udp_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_udp *udpinfo = par->matchinfo;\n\n\t \n\treturn (udpinfo->invflags & ~XT_UDP_INV_MASK) ? -EINVAL : 0;\n}\n\n \nstatic bool type_code_in_range(u8 test_type, u8 min_code, u8 max_code,\n\t\t\t       u8 type, u8 code)\n{\n\treturn type == test_type && code >= min_code && code <= max_code;\n}\n\nstatic bool icmp_type_code_match(u8 test_type, u8 min_code, u8 max_code,\n\t\t\t\t u8 type, u8 code, bool invert)\n{\n\treturn (test_type == 0xFF ||\n\t\ttype_code_in_range(test_type, min_code, max_code, type, code))\n\t\t^ invert;\n}\n\nstatic bool icmp6_type_code_match(u8 test_type, u8 min_code, u8 max_code,\n\t\t\t\t  u8 type, u8 code, bool invert)\n{\n\treturn type_code_in_range(test_type, min_code, max_code, type, code) ^ invert;\n}\n\nstatic bool\nicmp_match(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct icmphdr *ic;\n\tstruct icmphdr _icmph;\n\tconst struct ipt_icmp *icmpinfo = par->matchinfo;\n\n\t \n\tif (par->fragoff != 0)\n\t\treturn false;\n\n\tic = skb_header_pointer(skb, par->thoff, sizeof(_icmph), &_icmph);\n\tif (!ic) {\n\t\t \n\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\treturn icmp_type_code_match(icmpinfo->type,\n\t\t\t\t    icmpinfo->code[0],\n\t\t\t\t    icmpinfo->code[1],\n\t\t\t\t    ic->type, ic->code,\n\t\t\t\t    !!(icmpinfo->invflags & IPT_ICMP_INV));\n}\n\nstatic bool\nicmp6_match(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct icmp6hdr *ic;\n\tstruct icmp6hdr _icmph;\n\tconst struct ip6t_icmp *icmpinfo = par->matchinfo;\n\n\t \n\tif (par->fragoff != 0)\n\t\treturn false;\n\n\tic = skb_header_pointer(skb, par->thoff, sizeof(_icmph), &_icmph);\n\tif (!ic) {\n\t\t \n\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\treturn icmp6_type_code_match(icmpinfo->type,\n\t\t\t\t     icmpinfo->code[0],\n\t\t\t\t     icmpinfo->code[1],\n\t\t\t\t     ic->icmp6_type, ic->icmp6_code,\n\t\t\t\t     !!(icmpinfo->invflags & IP6T_ICMP_INV));\n}\n\nstatic int icmp_checkentry(const struct xt_mtchk_param *par)\n{\n\tconst struct ipt_icmp *icmpinfo = par->matchinfo;\n\n\treturn (icmpinfo->invflags & ~IPT_ICMP_INV) ? -EINVAL : 0;\n}\n\nstatic int icmp6_checkentry(const struct xt_mtchk_param *par)\n{\n\tconst struct ip6t_icmp *icmpinfo = par->matchinfo;\n\n\treturn (icmpinfo->invflags & ~IP6T_ICMP_INV) ? -EINVAL : 0;\n}\n\nstatic struct xt_match tcpudp_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"tcp\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.checkentry\t= tcp_mt_check,\n\t\t.match\t\t= tcp_mt,\n\t\t.matchsize\t= sizeof(struct xt_tcp),\n\t\t.proto\t\t= IPPROTO_TCP,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"tcp\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.checkentry\t= tcp_mt_check,\n\t\t.match\t\t= tcp_mt,\n\t\t.matchsize\t= sizeof(struct xt_tcp),\n\t\t.proto\t\t= IPPROTO_TCP,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"udp\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.checkentry\t= udp_mt_check,\n\t\t.match\t\t= udp_mt,\n\t\t.matchsize\t= sizeof(struct xt_udp),\n\t\t.proto\t\t= IPPROTO_UDP,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"udp\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.checkentry\t= udp_mt_check,\n\t\t.match\t\t= udp_mt,\n\t\t.matchsize\t= sizeof(struct xt_udp),\n\t\t.proto\t\t= IPPROTO_UDP,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"udplite\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.checkentry\t= udp_mt_check,\n\t\t.match\t\t= udp_mt,\n\t\t.matchsize\t= sizeof(struct xt_udp),\n\t\t.proto\t\t= IPPROTO_UDPLITE,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"udplite\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.checkentry\t= udp_mt_check,\n\t\t.match\t\t= udp_mt,\n\t\t.matchsize\t= sizeof(struct xt_udp),\n\t\t.proto\t\t= IPPROTO_UDPLITE,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name       = \"icmp\",\n\t\t.match      = icmp_match,\n\t\t.matchsize  = sizeof(struct ipt_icmp),\n\t\t.checkentry = icmp_checkentry,\n\t\t.proto      = IPPROTO_ICMP,\n\t\t.family     = NFPROTO_IPV4,\n\t\t.me         = THIS_MODULE,\n\t},\n\t{\n\t\t.name       = \"icmp6\",\n\t\t.match      = icmp6_match,\n\t\t.matchsize  = sizeof(struct ip6t_icmp),\n\t\t.checkentry = icmp6_checkentry,\n\t\t.proto      = IPPROTO_ICMPV6,\n\t\t.family     = NFPROTO_IPV6,\n\t\t.me\t    = THIS_MODULE,\n\t},\n};\n\nstatic int __init tcpudp_mt_init(void)\n{\n\treturn xt_register_matches(tcpudp_mt_reg, ARRAY_SIZE(tcpudp_mt_reg));\n}\n\nstatic void __exit tcpudp_mt_exit(void)\n{\n\txt_unregister_matches(tcpudp_mt_reg, ARRAY_SIZE(tcpudp_mt_reg));\n}\n\nmodule_init(tcpudp_mt_init);\nmodule_exit(tcpudp_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}