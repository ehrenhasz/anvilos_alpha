{
  "module_name": "nft_numgen.c",
  "hash_id": "f52938613251264023615a25d7b8176598f2cbd2b2f4e521401a31fa95086091",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_numgen.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/random.h>\n#include <linux/static_key.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n\nstruct nft_ng_inc {\n\tu8\t\t\tdreg;\n\tu32\t\t\tmodulus;\n\tatomic_t\t\t*counter;\n\tu32\t\t\toffset;\n};\n\nstatic u32 nft_ng_inc_gen(struct nft_ng_inc *priv)\n{\n\tu32 nval, oval;\n\n\tdo {\n\t\toval = atomic_read(priv->counter);\n\t\tnval = (oval + 1 < priv->modulus) ? oval + 1 : 0;\n\t} while (atomic_cmpxchg(priv->counter, oval, nval) != oval);\n\n\treturn nval + priv->offset;\n}\n\nstatic void nft_ng_inc_eval(const struct nft_expr *expr,\n\t\t\t    struct nft_regs *regs,\n\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tstruct nft_ng_inc *priv = nft_expr_priv(expr);\n\n\tregs->data[priv->dreg] = nft_ng_inc_gen(priv);\n}\n\nstatic const struct nla_policy nft_ng_policy[NFTA_NG_MAX + 1] = {\n\t[NFTA_NG_DREG]\t\t= { .type = NLA_U32 },\n\t[NFTA_NG_MODULUS]\t= { .type = NLA_U32 },\n\t[NFTA_NG_TYPE]\t\t= { .type = NLA_U32 },\n\t[NFTA_NG_OFFSET]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_ng_inc_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nft_ng_inc *priv = nft_expr_priv(expr);\n\tint err;\n\n\tif (tb[NFTA_NG_OFFSET])\n\t\tpriv->offset = ntohl(nla_get_be32(tb[NFTA_NG_OFFSET]));\n\n\tpriv->modulus = ntohl(nla_get_be32(tb[NFTA_NG_MODULUS]));\n\tif (priv->modulus == 0)\n\t\treturn -ERANGE;\n\n\tif (priv->offset + priv->modulus - 1 < priv->offset)\n\t\treturn -EOVERFLOW;\n\n\tpriv->counter = kmalloc(sizeof(*priv->counter), GFP_KERNEL);\n\tif (!priv->counter)\n\t\treturn -ENOMEM;\n\n\tatomic_set(priv->counter, priv->modulus - 1);\n\n\terr = nft_parse_register_store(ctx, tb[NFTA_NG_DREG], &priv->dreg,\n\t\t\t\t       NULL, NFT_DATA_VALUE, sizeof(u32));\n\tif (err < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tkfree(priv->counter);\n\n\treturn err;\n}\n\nstatic bool nft_ng_inc_reduce(struct nft_regs_track *track,\n\t\t\t\t const struct nft_expr *expr)\n{\n\tconst struct nft_ng_inc *priv = nft_expr_priv(expr);\n\n\tnft_reg_track_cancel(track, priv->dreg, NFT_REG32_SIZE);\n\n\treturn false;\n}\n\nstatic int nft_ng_dump(struct sk_buff *skb, enum nft_registers dreg,\n\t\t       u32 modulus, enum nft_ng_types type, u32 offset)\n{\n\tif (nft_dump_register(skb, NFTA_NG_DREG, dreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_NG_MODULUS, htonl(modulus)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_NG_TYPE, htonl(type)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_NG_OFFSET, htonl(offset)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_ng_inc_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_ng_inc *priv = nft_expr_priv(expr);\n\n\treturn nft_ng_dump(skb, priv->dreg, priv->modulus, NFT_NG_INCREMENTAL,\n\t\t\t   priv->offset);\n}\n\nstatic void nft_ng_inc_destroy(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr)\n{\n\tconst struct nft_ng_inc *priv = nft_expr_priv(expr);\n\n\tkfree(priv->counter);\n}\n\nstruct nft_ng_random {\n\tu8\t\t\tdreg;\n\tu32\t\t\tmodulus;\n\tu32\t\t\toffset;\n};\n\nstatic u32 nft_ng_random_gen(const struct nft_ng_random *priv)\n{\n\treturn reciprocal_scale(get_random_u32(), priv->modulus) + priv->offset;\n}\n\nstatic void nft_ng_random_eval(const struct nft_expr *expr,\n\t\t\t       struct nft_regs *regs,\n\t\t\t       const struct nft_pktinfo *pkt)\n{\n\tstruct nft_ng_random *priv = nft_expr_priv(expr);\n\n\tregs->data[priv->dreg] = nft_ng_random_gen(priv);\n}\n\nstatic int nft_ng_random_init(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr,\n\t\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_ng_random *priv = nft_expr_priv(expr);\n\n\tif (tb[NFTA_NG_OFFSET])\n\t\tpriv->offset = ntohl(nla_get_be32(tb[NFTA_NG_OFFSET]));\n\n\tpriv->modulus = ntohl(nla_get_be32(tb[NFTA_NG_MODULUS]));\n\tif (priv->modulus == 0)\n\t\treturn -ERANGE;\n\n\tif (priv->offset + priv->modulus - 1 < priv->offset)\n\t\treturn -EOVERFLOW;\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_NG_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, sizeof(u32));\n}\n\nstatic int nft_ng_random_dump(struct sk_buff *skb,\n\t\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_ng_random *priv = nft_expr_priv(expr);\n\n\treturn nft_ng_dump(skb, priv->dreg, priv->modulus, NFT_NG_RANDOM,\n\t\t\t   priv->offset);\n}\n\nstatic bool nft_ng_random_reduce(struct nft_regs_track *track,\n\t\t\t\t const struct nft_expr *expr)\n{\n\tconst struct nft_ng_random *priv = nft_expr_priv(expr);\n\n\tnft_reg_track_cancel(track, priv->dreg, NFT_REG32_SIZE);\n\n\treturn false;\n}\n\nstatic struct nft_expr_type nft_ng_type;\nstatic const struct nft_expr_ops nft_ng_inc_ops = {\n\t.type\t\t= &nft_ng_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_ng_inc)),\n\t.eval\t\t= nft_ng_inc_eval,\n\t.init\t\t= nft_ng_inc_init,\n\t.destroy\t= nft_ng_inc_destroy,\n\t.dump\t\t= nft_ng_inc_dump,\n\t.reduce\t\t= nft_ng_inc_reduce,\n};\n\nstatic const struct nft_expr_ops nft_ng_random_ops = {\n\t.type\t\t= &nft_ng_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_ng_random)),\n\t.eval\t\t= nft_ng_random_eval,\n\t.init\t\t= nft_ng_random_init,\n\t.dump\t\t= nft_ng_random_dump,\n\t.reduce\t\t= nft_ng_random_reduce,\n};\n\nstatic const struct nft_expr_ops *\nnft_ng_select_ops(const struct nft_ctx *ctx, const struct nlattr * const tb[])\n{\n\tu32 type;\n\n\tif (!tb[NFTA_NG_DREG]\t ||\n\t    !tb[NFTA_NG_MODULUS] ||\n\t    !tb[NFTA_NG_TYPE])\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttype = ntohl(nla_get_be32(tb[NFTA_NG_TYPE]));\n\n\tswitch (type) {\n\tcase NFT_NG_INCREMENTAL:\n\t\treturn &nft_ng_inc_ops;\n\tcase NFT_NG_RANDOM:\n\t\treturn &nft_ng_random_ops;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct nft_expr_type nft_ng_type __read_mostly = {\n\t.name\t\t= \"numgen\",\n\t.select_ops\t= nft_ng_select_ops,\n\t.policy\t\t= nft_ng_policy,\n\t.maxattr\t= NFTA_NG_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_ng_module_init(void)\n{\n\treturn nft_register_expr(&nft_ng_type);\n}\n\nstatic void __exit nft_ng_module_exit(void)\n{\n\tnft_unregister_expr(&nft_ng_type);\n}\n\nmodule_init(nft_ng_module_init);\nmodule_exit(nft_ng_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Laura Garcia <nevola@gmail.com>\");\nMODULE_ALIAS_NFT_EXPR(\"numgen\");\nMODULE_DESCRIPTION(\"nftables number generator module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}