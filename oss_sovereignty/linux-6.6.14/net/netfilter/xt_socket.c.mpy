{
  "module_name": "xt_socket.c",
  "hash_id": "79c58ee59c0be6c2135e2ae54b39321ac1ead59ef52c643e23f8c30e9d5061ba",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_socket.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/icmp.h>\n#include <net/sock.h>\n#include <net/inet_sock.h>\n#include <net/netfilter/ipv4/nf_defrag_ipv4.h>\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <net/inet6_hashtables.h>\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n#endif\n\n#include <net/netfilter/nf_socket.h>\n#include <linux/netfilter/xt_socket.h>\n\n \nstatic bool\nsocket_match(const struct sk_buff *skb, struct xt_action_param *par,\n\t     const struct xt_socket_mtinfo1 *info)\n{\n\tstruct sk_buff *pskb = (struct sk_buff *)skb;\n\tstruct sock *sk = skb->sk;\n\n\tif (sk && !net_eq(xt_net(par), sock_net(sk)))\n\t\tsk = NULL;\n\n\tif (!sk)\n\t\tsk = nf_sk_lookup_slow_v4(xt_net(par), skb, xt_in(par));\n\n\tif (sk) {\n\t\tbool wildcard;\n\t\tbool transparent = true;\n\n\t\t \n\t\twildcard = (!(info->flags & XT_SOCKET_NOWILDCARD) &&\n\t\t\t    sk_fullsock(sk) &&\n\t\t\t    inet_sk(sk)->inet_rcv_saddr == 0);\n\n\t\t \n\t\tif (info->flags & XT_SOCKET_TRANSPARENT)\n\t\t\ttransparent = inet_sk_transparent(sk);\n\n\t\tif (info->flags & XT_SOCKET_RESTORESKMARK && !wildcard &&\n\t\t    transparent && sk_fullsock(sk))\n\t\t\tpskb->mark = READ_ONCE(sk->sk_mark);\n\n\t\tif (sk != skb->sk)\n\t\t\tsock_gen_put(sk);\n\n\t\tif (wildcard || !transparent)\n\t\t\tsk = NULL;\n\t}\n\n\treturn sk != NULL;\n}\n\nstatic bool\nsocket_mt4_v0(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tstatic struct xt_socket_mtinfo1 xt_info_v0 = {\n\t\t.flags = 0,\n\t};\n\n\treturn socket_match(skb, par, &xt_info_v0);\n}\n\nstatic bool\nsocket_mt4_v1_v2_v3(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\treturn socket_match(skb, par, par->matchinfo);\n}\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nstatic bool\nsocket_mt6_v1_v2_v3(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;\n\tstruct sk_buff *pskb = (struct sk_buff *)skb;\n\tstruct sock *sk = skb->sk;\n\n\tif (sk && !net_eq(xt_net(par), sock_net(sk)))\n\t\tsk = NULL;\n\n\tif (!sk)\n\t\tsk = nf_sk_lookup_slow_v6(xt_net(par), skb, xt_in(par));\n\n\tif (sk) {\n\t\tbool wildcard;\n\t\tbool transparent = true;\n\n\t\t \n\t\twildcard = (!(info->flags & XT_SOCKET_NOWILDCARD) &&\n\t\t\t    sk_fullsock(sk) &&\n\t\t\t    ipv6_addr_any(&sk->sk_v6_rcv_saddr));\n\n\t\t \n\t\tif (info->flags & XT_SOCKET_TRANSPARENT)\n\t\t\ttransparent = inet_sk_transparent(sk);\n\n\t\tif (info->flags & XT_SOCKET_RESTORESKMARK && !wildcard &&\n\t\t    transparent && sk_fullsock(sk))\n\t\t\tpskb->mark = READ_ONCE(sk->sk_mark);\n\n\t\tif (sk != skb->sk)\n\t\t\tsock_gen_put(sk);\n\n\t\tif (wildcard || !transparent)\n\t\t\tsk = NULL;\n\t}\n\n\treturn sk != NULL;\n}\n#endif\n\nstatic int socket_mt_enable_defrag(struct net *net, int family)\n{\n\tswitch (family) {\n\tcase NFPROTO_IPV4:\n\t\treturn nf_defrag_ipv4_enable(net);\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\tcase NFPROTO_IPV6:\n\t\treturn nf_defrag_ipv6_enable(net);\n#endif\n\t}\n\tWARN_ONCE(1, \"Unknown family %d\\n\", family);\n\treturn 0;\n}\n\nstatic int socket_mt_v1_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;\n\tint err;\n\n\terr = socket_mt_enable_defrag(par->net, par->family);\n\tif (err)\n\t\treturn err;\n\n\tif (info->flags & ~XT_SOCKET_FLAGS_V1) {\n\t\tpr_info_ratelimited(\"unknown flags 0x%x\\n\",\n\t\t\t\t    info->flags & ~XT_SOCKET_FLAGS_V1);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int socket_mt_v2_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_socket_mtinfo2 *info = (struct xt_socket_mtinfo2 *) par->matchinfo;\n\tint err;\n\n\terr = socket_mt_enable_defrag(par->net, par->family);\n\tif (err)\n\t\treturn err;\n\n\tif (info->flags & ~XT_SOCKET_FLAGS_V2) {\n\t\tpr_info_ratelimited(\"unknown flags 0x%x\\n\",\n\t\t\t\t    info->flags & ~XT_SOCKET_FLAGS_V2);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int socket_mt_v3_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_socket_mtinfo3 *info =\n\t\t\t\t    (struct xt_socket_mtinfo3 *)par->matchinfo;\n\tint err;\n\n\terr = socket_mt_enable_defrag(par->net, par->family);\n\tif (err)\n\t\treturn err;\n\tif (info->flags & ~XT_SOCKET_FLAGS_V3) {\n\t\tpr_info_ratelimited(\"unknown flags 0x%x\\n\",\n\t\t\t\t    info->flags & ~XT_SOCKET_FLAGS_V3);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void socket_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tif (par->family == NFPROTO_IPV4)\n\t\tnf_defrag_ipv4_disable(par->net);\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\telse if (par->family == NFPROTO_IPV6)\n\t\tnf_defrag_ipv6_disable(par->net);\n#endif\n}\n\nstatic struct xt_match socket_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"socket\",\n\t\t.revision\t= 0,\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.match\t\t= socket_mt4_v0,\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"socket\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.match\t\t= socket_mt4_v1_v2_v3,\n\t\t.destroy\t= socket_mt_destroy,\n\t\t.checkentry\t= socket_mt_v1_check,\n\t\t.matchsize\t= sizeof(struct xt_socket_mtinfo1),\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\t{\n\t\t.name\t\t= \"socket\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.match\t\t= socket_mt6_v1_v2_v3,\n\t\t.checkentry\t= socket_mt_v1_check,\n\t\t.matchsize\t= sizeof(struct xt_socket_mtinfo1),\n\t\t.destroy\t= socket_mt_destroy,\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#endif\n\t{\n\t\t.name\t\t= \"socket\",\n\t\t.revision\t= 2,\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.match\t\t= socket_mt4_v1_v2_v3,\n\t\t.checkentry\t= socket_mt_v2_check,\n\t\t.destroy\t= socket_mt_destroy,\n\t\t.matchsize\t= sizeof(struct xt_socket_mtinfo1),\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\t{\n\t\t.name\t\t= \"socket\",\n\t\t.revision\t= 2,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.match\t\t= socket_mt6_v1_v2_v3,\n\t\t.checkentry\t= socket_mt_v2_check,\n\t\t.destroy\t= socket_mt_destroy,\n\t\t.matchsize\t= sizeof(struct xt_socket_mtinfo1),\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#endif\n\t{\n\t\t.name\t\t= \"socket\",\n\t\t.revision\t= 3,\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.match\t\t= socket_mt4_v1_v2_v3,\n\t\t.checkentry\t= socket_mt_v3_check,\n\t\t.destroy\t= socket_mt_destroy,\n\t\t.matchsize\t= sizeof(struct xt_socket_mtinfo1),\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\t{\n\t\t.name\t\t= \"socket\",\n\t\t.revision\t= 3,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.match\t\t= socket_mt6_v1_v2_v3,\n\t\t.checkentry\t= socket_mt_v3_check,\n\t\t.destroy\t= socket_mt_destroy,\n\t\t.matchsize\t= sizeof(struct xt_socket_mtinfo1),\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_IN),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#endif\n};\n\nstatic int __init socket_mt_init(void)\n{\n\treturn xt_register_matches(socket_mt_reg, ARRAY_SIZE(socket_mt_reg));\n}\n\nstatic void __exit socket_mt_exit(void)\n{\n\txt_unregister_matches(socket_mt_reg, ARRAY_SIZE(socket_mt_reg));\n}\n\nmodule_init(socket_mt_init);\nmodule_exit(socket_mt_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Krisztian Kovacs, Balazs Scheidler\");\nMODULE_DESCRIPTION(\"x_tables socket match module\");\nMODULE_ALIAS(\"ipt_socket\");\nMODULE_ALIAS(\"ip6t_socket\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}