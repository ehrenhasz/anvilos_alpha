{
  "module_name": "xt_TCPOPTSTRIP.c",
  "hash_id": "193c87058421e5146c617f962615e6fb76bf5c8c331116f44e3d0b29e3c749b1",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_TCPOPTSTRIP.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <net/ipv6.h>\n#include <net/tcp.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_TCPOPTSTRIP.h>\n\nstatic inline unsigned int optlen(const u_int8_t *opt, unsigned int offset)\n{\n\t \n\tif (opt[offset] <= TCPOPT_NOP || opt[offset+1] == 0)\n\t\treturn 1;\n\telse\n\t\treturn opt[offset+1];\n}\n\nstatic unsigned int\ntcpoptstrip_mangle_packet(struct sk_buff *skb,\n\t\t\t  const struct xt_action_param *par,\n\t\t\t  unsigned int tcphoff)\n{\n\tconst struct xt_tcpoptstrip_target_info *info = par->targinfo;\n\tstruct tcphdr *tcph, _th;\n\tunsigned int optl, i, j;\n\tu_int16_t n, o;\n\tu_int8_t *opt;\n\tint tcp_hdrlen;\n\n\t \n\tif (par->fragoff != 0)\n\t\treturn XT_CONTINUE;\n\n\ttcph = skb_header_pointer(skb, tcphoff, sizeof(_th), &_th);\n\tif (!tcph)\n\t\treturn NF_DROP;\n\n\ttcp_hdrlen = tcph->doff * 4;\n\tif (tcp_hdrlen < sizeof(struct tcphdr))\n\t\treturn NF_DROP;\n\n\tif (skb_ensure_writable(skb, tcphoff + tcp_hdrlen))\n\t\treturn NF_DROP;\n\n\t \n\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\topt  = (u8 *)tcph;\n\n\t \n\tfor (i = sizeof(struct tcphdr); i < tcp_hdrlen - 1; i += optl) {\n\t\toptl = optlen(opt, i);\n\n\t\tif (i + optl > tcp_hdrlen)\n\t\t\tbreak;\n\n\t\tif (!tcpoptstrip_test_bit(info->strip_bmap, opt[i]))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < optl; ++j) {\n\t\t\to = opt[i+j];\n\t\t\tn = TCPOPT_NOP;\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\to <<= 8;\n\t\t\t\tn <<= 8;\n\t\t\t}\n\t\t\tinet_proto_csum_replace2(&tcph->check, skb, htons(o),\n\t\t\t\t\t\t htons(n), false);\n\t\t}\n\t\tmemset(opt + i, TCPOPT_NOP, optl);\n\t}\n\n\treturn XT_CONTINUE;\n}\n\nstatic unsigned int\ntcpoptstrip_tg4(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\treturn tcpoptstrip_mangle_packet(skb, par, ip_hdrlen(skb));\n}\n\n#if IS_ENABLED(CONFIG_IP6_NF_MANGLE)\nstatic unsigned int\ntcpoptstrip_tg6(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tint tcphoff;\n\tu_int8_t nexthdr;\n\t__be16 frag_off;\n\n\tnexthdr = ipv6h->nexthdr;\n\ttcphoff = ipv6_skip_exthdr(skb, sizeof(*ipv6h), &nexthdr, &frag_off);\n\tif (tcphoff < 0)\n\t\treturn NF_DROP;\n\n\treturn tcpoptstrip_mangle_packet(skb, par, tcphoff);\n}\n#endif\n\nstatic struct xt_target tcpoptstrip_tg_reg[] __read_mostly = {\n\t{\n\t\t.name       = \"TCPOPTSTRIP\",\n\t\t.family     = NFPROTO_IPV4,\n\t\t.table      = \"mangle\",\n\t\t.proto      = IPPROTO_TCP,\n\t\t.target     = tcpoptstrip_tg4,\n\t\t.targetsize = sizeof(struct xt_tcpoptstrip_target_info),\n\t\t.me         = THIS_MODULE,\n\t},\n#if IS_ENABLED(CONFIG_IP6_NF_MANGLE)\n\t{\n\t\t.name       = \"TCPOPTSTRIP\",\n\t\t.family     = NFPROTO_IPV6,\n\t\t.table      = \"mangle\",\n\t\t.proto      = IPPROTO_TCP,\n\t\t.target     = tcpoptstrip_tg6,\n\t\t.targetsize = sizeof(struct xt_tcpoptstrip_target_info),\n\t\t.me         = THIS_MODULE,\n\t},\n#endif\n};\n\nstatic int __init tcpoptstrip_tg_init(void)\n{\n\treturn xt_register_targets(tcpoptstrip_tg_reg,\n\t\t\t\t   ARRAY_SIZE(tcpoptstrip_tg_reg));\n}\n\nstatic void __exit tcpoptstrip_tg_exit(void)\n{\n\txt_unregister_targets(tcpoptstrip_tg_reg,\n\t\t\t      ARRAY_SIZE(tcpoptstrip_tg_reg));\n}\n\nmodule_init(tcpoptstrip_tg_init);\nmodule_exit(tcpoptstrip_tg_exit);\nMODULE_AUTHOR(\"Sven Schnelle <svens@bitebene.org>, Jan Engelhardt <jengelh@medozas.de>\");\nMODULE_DESCRIPTION(\"Xtables: TCP option stripping\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_TCPOPTSTRIP\");\nMODULE_ALIAS(\"ip6t_TCPOPTSTRIP\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}