{
  "module_name": "xt_TPROXY.c",
  "hash_id": "7bf9e6dd81bcde49400b11656a781bf0152c530b928bdccb0633fa65459ceef1",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_TPROXY.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <net/checksum.h>\n#include <net/udp.h>\n#include <net/tcp.h>\n#include <net/inet_sock.h>\n#include <net/inet_hashtables.h>\n#include <linux/inetdevice.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n\n#include <net/netfilter/ipv4/nf_defrag_ipv4.h>\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n#define XT_TPROXY_HAVE_IPV6 1\n#include <net/if_inet6.h>\n#include <net/addrconf.h>\n#include <net/inet6_hashtables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n#endif\n\n#include <net/netfilter/nf_tproxy.h>\n#include <linux/netfilter/xt_TPROXY.h>\n\nstatic unsigned int\ntproxy_tg4(struct net *net, struct sk_buff *skb, __be32 laddr, __be16 lport,\n\t   u_int32_t mark_mask, u_int32_t mark_value)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct udphdr _hdr, *hp;\n\tstruct sock *sk;\n\n\thp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_hdr), &_hdr);\n\tif (hp == NULL)\n\t\treturn NF_DROP;\n\n\t \n\tsk = nf_tproxy_get_sock_v4(net, skb, iph->protocol,\n\t\t\t\t   iph->saddr, iph->daddr,\n\t\t\t\t   hp->source, hp->dest,\n\t\t\t\t   skb->dev, NF_TPROXY_LOOKUP_ESTABLISHED);\n\n\tladdr = nf_tproxy_laddr4(skb, laddr, iph->daddr);\n\tif (!lport)\n\t\tlport = hp->dest;\n\n\t \n\tif (sk && sk->sk_state == TCP_TIME_WAIT)\n\t\t \n\t\tsk = nf_tproxy_handle_time_wait4(net, skb, laddr, lport, sk);\n\telse if (!sk)\n\t\t \n\t\tsk = nf_tproxy_get_sock_v4(net, skb, iph->protocol,\n\t\t\t\t\t   iph->saddr, laddr,\n\t\t\t\t\t   hp->source, lport,\n\t\t\t\t\t   skb->dev, NF_TPROXY_LOOKUP_LISTENER);\n\n\t \n\tif (sk && nf_tproxy_sk_is_transparent(sk)) {\n\t\t \n\t\tskb->mark = (skb->mark & ~mark_mask) ^ mark_value;\n\t\tnf_tproxy_assign_sock(skb, sk);\n\t\treturn NF_ACCEPT;\n\t}\n\n\treturn NF_DROP;\n}\n\nstatic unsigned int\ntproxy_tg4_v0(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_tproxy_target_info *tgi = par->targinfo;\n\n\treturn tproxy_tg4(xt_net(par), skb, tgi->laddr, tgi->lport,\n\t\t\t  tgi->mark_mask, tgi->mark_value);\n}\n\nstatic unsigned int\ntproxy_tg4_v1(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_tproxy_target_info_v1 *tgi = par->targinfo;\n\n\treturn tproxy_tg4(xt_net(par), skb, tgi->laddr.ip, tgi->lport,\n\t\t\t  tgi->mark_mask, tgi->mark_value);\n}\n\n#ifdef XT_TPROXY_HAVE_IPV6\n\nstatic unsigned int\ntproxy_tg6_v1(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tconst struct xt_tproxy_target_info_v1 *tgi = par->targinfo;\n\tstruct udphdr _hdr, *hp;\n\tstruct sock *sk;\n\tconst struct in6_addr *laddr;\n\t__be16 lport;\n\tint thoff = 0;\n\tint tproto;\n\n\ttproto = ipv6_find_hdr(skb, &thoff, -1, NULL, NULL);\n\tif (tproto < 0)\n\t\treturn NF_DROP;\n\n\thp = skb_header_pointer(skb, thoff, sizeof(_hdr), &_hdr);\n\tif (!hp)\n\t\treturn NF_DROP;\n\n\t \n\tsk = nf_tproxy_get_sock_v6(xt_net(par), skb, thoff, tproto,\n\t\t\t\t   &iph->saddr, &iph->daddr,\n\t\t\t\t   hp->source, hp->dest,\n\t\t\t\t   xt_in(par), NF_TPROXY_LOOKUP_ESTABLISHED);\n\n\tladdr = nf_tproxy_laddr6(skb, &tgi->laddr.in6, &iph->daddr);\n\tlport = tgi->lport ? tgi->lport : hp->dest;\n\n\t \n\tif (sk && sk->sk_state == TCP_TIME_WAIT) {\n\t\tconst struct xt_tproxy_target_info_v1 *tgi = par->targinfo;\n\t\t \n\t\tsk = nf_tproxy_handle_time_wait6(skb, tproto, thoff,\n\t\t\t\t\t      xt_net(par),\n\t\t\t\t\t      &tgi->laddr.in6,\n\t\t\t\t\t      tgi->lport,\n\t\t\t\t\t      sk);\n\t}\n\telse if (!sk)\n\t\t \n\t\tsk = nf_tproxy_get_sock_v6(xt_net(par), skb, thoff,\n\t\t\t\t\t   tproto, &iph->saddr, laddr,\n\t\t\t\t\t   hp->source, lport,\n\t\t\t\t\t   xt_in(par), NF_TPROXY_LOOKUP_LISTENER);\n\n\t \n\tif (sk && nf_tproxy_sk_is_transparent(sk)) {\n\t\t \n\t\tskb->mark = (skb->mark & ~tgi->mark_mask) ^ tgi->mark_value;\n\t\tnf_tproxy_assign_sock(skb, sk);\n\t\treturn NF_ACCEPT;\n\t}\n\n\treturn NF_DROP;\n}\n\nstatic int tproxy_tg6_check(const struct xt_tgchk_param *par)\n{\n\tconst struct ip6t_ip6 *i = par->entryinfo;\n\tint err;\n\n\terr = nf_defrag_ipv6_enable(par->net);\n\tif (err)\n\t\treturn err;\n\n\tif ((i->proto == IPPROTO_TCP || i->proto == IPPROTO_UDP) &&\n\t    !(i->invflags & IP6T_INV_PROTO))\n\t\treturn 0;\n\n\tpr_info_ratelimited(\"Can be used only with -p tcp or -p udp\\n\");\n\treturn -EINVAL;\n}\n\nstatic void tproxy_tg6_destroy(const struct xt_tgdtor_param *par)\n{\n\tnf_defrag_ipv6_disable(par->net);\n}\n#endif\n\nstatic int tproxy_tg4_check(const struct xt_tgchk_param *par)\n{\n\tconst struct ipt_ip *i = par->entryinfo;\n\tint err;\n\n\terr = nf_defrag_ipv4_enable(par->net);\n\tif (err)\n\t\treturn err;\n\n\tif ((i->proto == IPPROTO_TCP || i->proto == IPPROTO_UDP)\n\t    && !(i->invflags & IPT_INV_PROTO))\n\t\treturn 0;\n\n\tpr_info_ratelimited(\"Can be used only with -p tcp or -p udp\\n\");\n\treturn -EINVAL;\n}\n\nstatic void tproxy_tg4_destroy(const struct xt_tgdtor_param *par)\n{\n\tnf_defrag_ipv4_disable(par->net);\n}\n\nstatic struct xt_target tproxy_tg_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"TPROXY\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.table\t\t= \"mangle\",\n\t\t.target\t\t= tproxy_tg4_v0,\n\t\t.revision\t= 0,\n\t\t.targetsize\t= sizeof(struct xt_tproxy_target_info),\n\t\t.checkentry\t= tproxy_tg4_check,\n\t\t.destroy\t= tproxy_tg4_destroy,\n\t\t.hooks\t\t= 1 << NF_INET_PRE_ROUTING,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"TPROXY\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.table\t\t= \"mangle\",\n\t\t.target\t\t= tproxy_tg4_v1,\n\t\t.revision\t= 1,\n\t\t.targetsize\t= sizeof(struct xt_tproxy_target_info_v1),\n\t\t.checkentry\t= tproxy_tg4_check,\n\t\t.destroy\t= tproxy_tg4_destroy,\n\t\t.hooks\t\t= 1 << NF_INET_PRE_ROUTING,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#ifdef XT_TPROXY_HAVE_IPV6\n\t{\n\t\t.name\t\t= \"TPROXY\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.table\t\t= \"mangle\",\n\t\t.target\t\t= tproxy_tg6_v1,\n\t\t.revision\t= 1,\n\t\t.targetsize\t= sizeof(struct xt_tproxy_target_info_v1),\n\t\t.checkentry\t= tproxy_tg6_check,\n\t\t.destroy\t= tproxy_tg6_destroy,\n\t\t.hooks\t\t= 1 << NF_INET_PRE_ROUTING,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#endif\n\n};\n\nstatic int __init tproxy_tg_init(void)\n{\n\treturn xt_register_targets(tproxy_tg_reg, ARRAY_SIZE(tproxy_tg_reg));\n}\n\nstatic void __exit tproxy_tg_exit(void)\n{\n\txt_unregister_targets(tproxy_tg_reg, ARRAY_SIZE(tproxy_tg_reg));\n}\n\nmodule_init(tproxy_tg_init);\nmodule_exit(tproxy_tg_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Balazs Scheidler, Krisztian Kovacs\");\nMODULE_DESCRIPTION(\"Netfilter transparent proxy (TPROXY) target module.\");\nMODULE_ALIAS(\"ipt_TPROXY\");\nMODULE_ALIAS(\"ip6t_TPROXY\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}