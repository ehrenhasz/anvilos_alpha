{
  "module_name": "nft_ct.c",
  "hash_id": "6ea690cce3fc94a1e7778a1f8976f4ffab86db2d8729f78b6fdaacb9ee32fb40",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_ct.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_acct.h>\n#include <net/netfilter/nf_conntrack_tuple.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_labels.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n\nstruct nft_ct_helper_obj  {\n\tstruct nf_conntrack_helper *helper4;\n\tstruct nf_conntrack_helper *helper6;\n\tu8 l4proto;\n};\n\n#ifdef CONFIG_NF_CONNTRACK_ZONES\nstatic DEFINE_PER_CPU(struct nf_conn *, nft_ct_pcpu_template);\nstatic unsigned int nft_ct_pcpu_template_refcnt __read_mostly;\nstatic DEFINE_MUTEX(nft_ct_pcpu_mutex);\n#endif\n\nstatic u64 nft_ct_get_eval_counter(const struct nf_conn_counter *c,\n\t\t\t\t   enum nft_ct_keys k,\n\t\t\t\t   enum ip_conntrack_dir d)\n{\n\tif (d < IP_CT_DIR_MAX)\n\t\treturn k == NFT_CT_BYTES ? atomic64_read(&c[d].bytes) :\n\t\t\t\t\t   atomic64_read(&c[d].packets);\n\n\treturn nft_ct_get_eval_counter(c, k, IP_CT_DIR_ORIGINAL) +\n\t       nft_ct_get_eval_counter(c, k, IP_CT_DIR_REPLY);\n}\n\nstatic void nft_ct_get_eval(const struct nft_expr *expr,\n\t\t\t    struct nft_regs *regs,\n\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_ct *priv = nft_expr_priv(expr);\n\tu32 *dest = &regs->data[priv->dreg];\n\tenum ip_conntrack_info ctinfo;\n\tconst struct nf_conn *ct;\n\tconst struct nf_conn_help *help;\n\tconst struct nf_conntrack_tuple *tuple;\n\tconst struct nf_conntrack_helper *helper;\n\tunsigned int state;\n\n\tct = nf_ct_get(pkt->skb, &ctinfo);\n\n\tswitch (priv->key) {\n\tcase NFT_CT_STATE:\n\t\tif (ct)\n\t\t\tstate = NF_CT_STATE_BIT(ctinfo);\n\t\telse if (ctinfo == IP_CT_UNTRACKED)\n\t\t\tstate = NF_CT_STATE_UNTRACKED_BIT;\n\t\telse\n\t\t\tstate = NF_CT_STATE_INVALID_BIT;\n\t\t*dest = state;\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ct == NULL)\n\t\tgoto err;\n\n\tswitch (priv->key) {\n\tcase NFT_CT_DIRECTION:\n\t\tnft_reg_store8(dest, CTINFO2DIR(ctinfo));\n\t\treturn;\n\tcase NFT_CT_STATUS:\n\t\t*dest = ct->status;\n\t\treturn;\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\tcase NFT_CT_MARK:\n\t\t*dest = READ_ONCE(ct->mark);\n\t\treturn;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\n\tcase NFT_CT_SECMARK:\n\t\t*dest = ct->secmark;\n\t\treturn;\n#endif\n\tcase NFT_CT_EXPIRATION:\n\t\t*dest = jiffies_to_msecs(nf_ct_expires(ct));\n\t\treturn;\n\tcase NFT_CT_HELPER:\n\t\tif (ct->master == NULL)\n\t\t\tgoto err;\n\t\thelp = nfct_help(ct->master);\n\t\tif (help == NULL)\n\t\t\tgoto err;\n\t\thelper = rcu_dereference(help->helper);\n\t\tif (helper == NULL)\n\t\t\tgoto err;\n\t\tstrscpy_pad((char *)dest, helper->name, NF_CT_HELPER_NAME_LEN);\n\t\treturn;\n#ifdef CONFIG_NF_CONNTRACK_LABELS\n\tcase NFT_CT_LABELS: {\n\t\tstruct nf_conn_labels *labels = nf_ct_labels_find(ct);\n\n\t\tif (labels)\n\t\t\tmemcpy(dest, labels->bits, NF_CT_LABELS_MAX_SIZE);\n\t\telse\n\t\t\tmemset(dest, 0, NF_CT_LABELS_MAX_SIZE);\n\t\treturn;\n\t}\n#endif\n\tcase NFT_CT_BYTES:\n\tcase NFT_CT_PKTS: {\n\t\tconst struct nf_conn_acct *acct = nf_conn_acct_find(ct);\n\t\tu64 count = 0;\n\n\t\tif (acct)\n\t\t\tcount = nft_ct_get_eval_counter(acct->counter,\n\t\t\t\t\t\t\tpriv->key, priv->dir);\n\t\tmemcpy(dest, &count, sizeof(count));\n\t\treturn;\n\t}\n\tcase NFT_CT_AVGPKT: {\n\t\tconst struct nf_conn_acct *acct = nf_conn_acct_find(ct);\n\t\tu64 avgcnt = 0, bcnt = 0, pcnt = 0;\n\n\t\tif (acct) {\n\t\t\tpcnt = nft_ct_get_eval_counter(acct->counter,\n\t\t\t\t\t\t       NFT_CT_PKTS, priv->dir);\n\t\t\tbcnt = nft_ct_get_eval_counter(acct->counter,\n\t\t\t\t\t\t       NFT_CT_BYTES, priv->dir);\n\t\t\tif (pcnt != 0)\n\t\t\t\tavgcnt = div64_u64(bcnt, pcnt);\n\t\t}\n\n\t\tmemcpy(dest, &avgcnt, sizeof(avgcnt));\n\t\treturn;\n\t}\n\tcase NFT_CT_L3PROTOCOL:\n\t\tnft_reg_store8(dest, nf_ct_l3num(ct));\n\t\treturn;\n\tcase NFT_CT_PROTOCOL:\n\t\tnft_reg_store8(dest, nf_ct_protonum(ct));\n\t\treturn;\n#ifdef CONFIG_NF_CONNTRACK_ZONES\n\tcase NFT_CT_ZONE: {\n\t\tconst struct nf_conntrack_zone *zone = nf_ct_zone(ct);\n\t\tu16 zoneid;\n\n\t\tif (priv->dir < IP_CT_DIR_MAX)\n\t\t\tzoneid = nf_ct_zone_id(zone, priv->dir);\n\t\telse\n\t\t\tzoneid = zone->id;\n\n\t\tnft_reg_store16(dest, zoneid);\n\t\treturn;\n\t}\n#endif\n\tcase NFT_CT_ID:\n\t\t*dest = nf_ct_get_id(ct);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttuple = &ct->tuplehash[priv->dir].tuple;\n\tswitch (priv->key) {\n\tcase NFT_CT_SRC:\n\t\tmemcpy(dest, tuple->src.u3.all,\n\t\t       nf_ct_l3num(ct) == NFPROTO_IPV4 ? 4 : 16);\n\t\treturn;\n\tcase NFT_CT_DST:\n\t\tmemcpy(dest, tuple->dst.u3.all,\n\t\t       nf_ct_l3num(ct) == NFPROTO_IPV4 ? 4 : 16);\n\t\treturn;\n\tcase NFT_CT_PROTO_SRC:\n\t\tnft_reg_store16(dest, (__force u16)tuple->src.u.all);\n\t\treturn;\n\tcase NFT_CT_PROTO_DST:\n\t\tnft_reg_store16(dest, (__force u16)tuple->dst.u.all);\n\t\treturn;\n\tcase NFT_CT_SRC_IP:\n\t\tif (nf_ct_l3num(ct) != NFPROTO_IPV4)\n\t\t\tgoto err;\n\t\t*dest = (__force __u32)tuple->src.u3.ip;\n\t\treturn;\n\tcase NFT_CT_DST_IP:\n\t\tif (nf_ct_l3num(ct) != NFPROTO_IPV4)\n\t\t\tgoto err;\n\t\t*dest = (__force __u32)tuple->dst.u3.ip;\n\t\treturn;\n\tcase NFT_CT_SRC_IP6:\n\t\tif (nf_ct_l3num(ct) != NFPROTO_IPV6)\n\t\t\tgoto err;\n\t\tmemcpy(dest, tuple->src.u3.ip6, sizeof(struct in6_addr));\n\t\treturn;\n\tcase NFT_CT_DST_IP6:\n\t\tif (nf_ct_l3num(ct) != NFPROTO_IPV6)\n\t\t\tgoto err;\n\t\tmemcpy(dest, tuple->dst.u3.ip6, sizeof(struct in6_addr));\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn;\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\n\n#ifdef CONFIG_NF_CONNTRACK_ZONES\nstatic void nft_ct_set_zone_eval(const struct nft_expr *expr,\n\t\t\t\t struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct nf_conntrack_zone zone = { .dir = NF_CT_DEFAULT_ZONE_DIR };\n\tconst struct nft_ct *priv = nft_expr_priv(expr);\n\tstruct sk_buff *skb = pkt->skb;\n\tenum ip_conntrack_info ctinfo;\n\tu16 value = nft_reg_load16(&regs->data[priv->sreg]);\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct)  \n\t\treturn;\n\n\tzone.id = value;\n\n\tswitch (priv->dir) {\n\tcase IP_CT_DIR_ORIGINAL:\n\t\tzone.dir = NF_CT_ZONE_DIR_ORIG;\n\t\tbreak;\n\tcase IP_CT_DIR_REPLY:\n\t\tzone.dir = NF_CT_ZONE_DIR_REPL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tct = this_cpu_read(nft_ct_pcpu_template);\n\n\tif (likely(refcount_read(&ct->ct_general.use) == 1)) {\n\t\trefcount_inc(&ct->ct_general.use);\n\t\tnf_ct_zone_add(ct, &zone);\n\t} else {\n\t\t \n\t\tct = nf_ct_tmpl_alloc(nft_net(pkt), &zone, GFP_ATOMIC);\n\t\tif (!ct) {\n\t\t\tregs->verdict.code = NF_DROP;\n\t\t\treturn;\n\t\t}\n\t\t__set_bit(IPS_CONFIRMED_BIT, &ct->status);\n\t}\n\n\tnf_ct_set(skb, ct, IP_CT_NEW);\n}\n#endif\n\nstatic void nft_ct_set_eval(const struct nft_expr *expr,\n\t\t\t    struct nft_regs *regs,\n\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_ct *priv = nft_expr_priv(expr);\n\tstruct sk_buff *skb = pkt->skb;\n#if defined(CONFIG_NF_CONNTRACK_MARK) || defined(CONFIG_NF_CONNTRACK_SECMARK)\n\tu32 value = regs->data[priv->sreg];\n#endif\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct == NULL || nf_ct_is_template(ct))\n\t\treturn;\n\n\tswitch (priv->key) {\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\tcase NFT_CT_MARK:\n\t\tif (READ_ONCE(ct->mark) != value) {\n\t\t\tWRITE_ONCE(ct->mark, value);\n\t\t\tnf_conntrack_event_cache(IPCT_MARK, ct);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\n\tcase NFT_CT_SECMARK:\n\t\tif (ct->secmark != value) {\n\t\t\tct->secmark = value;\n\t\t\tnf_conntrack_event_cache(IPCT_SECMARK, ct);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_LABELS\n\tcase NFT_CT_LABELS:\n\t\tnf_connlabels_replace(ct,\n\t\t\t\t      &regs->data[priv->sreg],\n\t\t\t\t      &regs->data[priv->sreg],\n\t\t\t\t      NF_CT_LABELS_MAX_SIZE / sizeof(u32));\n\t\tbreak;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tcase NFT_CT_EVENTMASK: {\n\t\tstruct nf_conntrack_ecache *e = nf_ct_ecache_find(ct);\n\t\tu32 ctmask = regs->data[priv->sreg];\n\n\t\tif (e) {\n\t\t\tif (e->ctmask != ctmask)\n\t\t\t\te->ctmask = ctmask;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ctmask && !nf_ct_is_confirmed(ct))\n\t\t\tnf_ct_ecache_ext_add(ct, ctmask, 0, GFP_ATOMIC);\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic const struct nla_policy nft_ct_policy[NFTA_CT_MAX + 1] = {\n\t[NFTA_CT_DREG]\t\t= { .type = NLA_U32 },\n\t[NFTA_CT_KEY]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_CT_DIRECTION]\t= { .type = NLA_U8 },\n\t[NFTA_CT_SREG]\t\t= { .type = NLA_U32 },\n};\n\n#ifdef CONFIG_NF_CONNTRACK_ZONES\nstatic void nft_ct_tmpl_put_pcpu(void)\n{\n\tstruct nf_conn *ct;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tct = per_cpu(nft_ct_pcpu_template, cpu);\n\t\tif (!ct)\n\t\t\tbreak;\n\t\tnf_ct_put(ct);\n\t\tper_cpu(nft_ct_pcpu_template, cpu) = NULL;\n\t}\n}\n\nstatic bool nft_ct_tmpl_alloc_pcpu(void)\n{\n\tstruct nf_conntrack_zone zone = { .id = 0 };\n\tstruct nf_conn *tmp;\n\tint cpu;\n\n\tif (nft_ct_pcpu_template_refcnt)\n\t\treturn true;\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttmp = nf_ct_tmpl_alloc(&init_net, &zone, GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\tnft_ct_tmpl_put_pcpu();\n\t\t\treturn false;\n\t\t}\n\n\t\t__set_bit(IPS_CONFIRMED_BIT, &tmp->status);\n\t\tper_cpu(nft_ct_pcpu_template, cpu) = tmp;\n\t}\n\n\treturn true;\n}\n#endif\n\nstatic int nft_ct_get_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nft_ct *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\tint err;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_CT_KEY]));\n\tpriv->dir = IP_CT_DIR_MAX;\n\tswitch (priv->key) {\n\tcase NFT_CT_DIRECTION:\n\t\tif (tb[NFTA_CT_DIRECTION] != NULL)\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tcase NFT_CT_STATE:\n\tcase NFT_CT_STATUS:\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\tcase NFT_CT_MARK:\n#endif\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\n\tcase NFT_CT_SECMARK:\n#endif\n\tcase NFT_CT_EXPIRATION:\n\t\tif (tb[NFTA_CT_DIRECTION] != NULL)\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof(u32);\n\t\tbreak;\n#ifdef CONFIG_NF_CONNTRACK_LABELS\n\tcase NFT_CT_LABELS:\n\t\tif (tb[NFTA_CT_DIRECTION] != NULL)\n\t\t\treturn -EINVAL;\n\t\tlen = NF_CT_LABELS_MAX_SIZE;\n\t\tbreak;\n#endif\n\tcase NFT_CT_HELPER:\n\t\tif (tb[NFTA_CT_DIRECTION] != NULL)\n\t\t\treturn -EINVAL;\n\t\tlen = NF_CT_HELPER_NAME_LEN;\n\t\tbreak;\n\n\tcase NFT_CT_L3PROTOCOL:\n\tcase NFT_CT_PROTOCOL:\n\t\t \n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tcase NFT_CT_SRC:\n\tcase NFT_CT_DST:\n\t\tif (tb[NFTA_CT_DIRECTION] == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (ctx->family) {\n\t\tcase NFPROTO_IPV4:\n\t\t\tlen = sizeof_field(struct nf_conntrack_tuple,\n\t\t\t\t\t   src.u3.ip);\n\t\t\tbreak;\n\t\tcase NFPROTO_IPV6:\n\t\tcase NFPROTO_INET:\n\t\t\tlen = sizeof_field(struct nf_conntrack_tuple,\n\t\t\t\t\t   src.u3.ip6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\t\tbreak;\n\tcase NFT_CT_SRC_IP:\n\tcase NFT_CT_DST_IP:\n\t\tif (tb[NFTA_CT_DIRECTION] == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tlen = sizeof_field(struct nf_conntrack_tuple, src.u3.ip);\n\t\tbreak;\n\tcase NFT_CT_SRC_IP6:\n\tcase NFT_CT_DST_IP6:\n\t\tif (tb[NFTA_CT_DIRECTION] == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tlen = sizeof_field(struct nf_conntrack_tuple, src.u3.ip6);\n\t\tbreak;\n\tcase NFT_CT_PROTO_SRC:\n\tcase NFT_CT_PROTO_DST:\n\t\tif (tb[NFTA_CT_DIRECTION] == NULL)\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof_field(struct nf_conntrack_tuple, src.u.all);\n\t\tbreak;\n\tcase NFT_CT_BYTES:\n\tcase NFT_CT_PKTS:\n\tcase NFT_CT_AVGPKT:\n\t\tlen = sizeof(u64);\n\t\tbreak;\n#ifdef CONFIG_NF_CONNTRACK_ZONES\n\tcase NFT_CT_ZONE:\n\t\tlen = sizeof(u16);\n\t\tbreak;\n#endif\n\tcase NFT_CT_ID:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[NFTA_CT_DIRECTION] != NULL) {\n\t\tpriv->dir = nla_get_u8(tb[NFTA_CT_DIRECTION]);\n\t\tswitch (priv->dir) {\n\t\tcase IP_CT_DIR_ORIGINAL:\n\t\tcase IP_CT_DIR_REPLY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpriv->len = len;\n\terr = nft_parse_register_store(ctx, tb[NFTA_CT_DREG], &priv->dreg, NULL,\n\t\t\t\t       NFT_DATA_VALUE, len);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nf_ct_netns_get(ctx->net, ctx->family);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (priv->key == NFT_CT_BYTES ||\n\t    priv->key == NFT_CT_PKTS  ||\n\t    priv->key == NFT_CT_AVGPKT)\n\t\tnf_ct_set_acct(ctx->net, true);\n\n\treturn 0;\n}\n\nstatic void __nft_ct_set_destroy(const struct nft_ctx *ctx, struct nft_ct *priv)\n{\n\tswitch (priv->key) {\n#ifdef CONFIG_NF_CONNTRACK_LABELS\n\tcase NFT_CT_LABELS:\n\t\tnf_connlabels_put(ctx->net);\n\t\tbreak;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_ZONES\n\tcase NFT_CT_ZONE:\n\t\tmutex_lock(&nft_ct_pcpu_mutex);\n\t\tif (--nft_ct_pcpu_template_refcnt == 0)\n\t\t\tnft_ct_tmpl_put_pcpu();\n\t\tmutex_unlock(&nft_ct_pcpu_mutex);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int nft_ct_set_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nft_ct *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\tint err;\n\n\tpriv->dir = IP_CT_DIR_MAX;\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_CT_KEY]));\n\tswitch (priv->key) {\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\tcase NFT_CT_MARK:\n\t\tif (tb[NFTA_CT_DIRECTION])\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof_field(struct nf_conn, mark);\n\t\tbreak;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_LABELS\n\tcase NFT_CT_LABELS:\n\t\tif (tb[NFTA_CT_DIRECTION])\n\t\t\treturn -EINVAL;\n\t\tlen = NF_CT_LABELS_MAX_SIZE;\n\t\terr = nf_connlabels_get(ctx->net, (len * BITS_PER_BYTE) - 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_ZONES\n\tcase NFT_CT_ZONE:\n\t\tmutex_lock(&nft_ct_pcpu_mutex);\n\t\tif (!nft_ct_tmpl_alloc_pcpu()) {\n\t\t\tmutex_unlock(&nft_ct_pcpu_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnft_ct_pcpu_template_refcnt++;\n\t\tmutex_unlock(&nft_ct_pcpu_mutex);\n\t\tlen = sizeof(u16);\n\t\tbreak;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tcase NFT_CT_EVENTMASK:\n\t\tif (tb[NFTA_CT_DIRECTION])\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof(u32);\n\t\tbreak;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\n\tcase NFT_CT_SECMARK:\n\t\tif (tb[NFTA_CT_DIRECTION])\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof(u32);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[NFTA_CT_DIRECTION]) {\n\t\tpriv->dir = nla_get_u8(tb[NFTA_CT_DIRECTION]);\n\t\tswitch (priv->dir) {\n\t\tcase IP_CT_DIR_ORIGINAL:\n\t\tcase IP_CT_DIR_REPLY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tpriv->len = len;\n\terr = nft_parse_register_load(tb[NFTA_CT_SREG], &priv->sreg, len);\n\tif (err < 0)\n\t\tgoto err1;\n\n\terr = nf_ct_netns_get(ctx->net, ctx->family);\n\tif (err < 0)\n\t\tgoto err1;\n\n\treturn 0;\n\nerr1:\n\t__nft_ct_set_destroy(ctx, priv);\n\treturn err;\n}\n\nstatic void nft_ct_get_destroy(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr)\n{\n\tnf_ct_netns_put(ctx->net, ctx->family);\n}\n\nstatic void nft_ct_set_destroy(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr)\n{\n\tstruct nft_ct *priv = nft_expr_priv(expr);\n\n\t__nft_ct_set_destroy(ctx, priv);\n\tnf_ct_netns_put(ctx->net, ctx->family);\n}\n\nstatic int nft_ct_get_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_ct *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_CT_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_CT_KEY, htonl(priv->key)))\n\t\tgoto nla_put_failure;\n\n\tswitch (priv->key) {\n\tcase NFT_CT_SRC:\n\tcase NFT_CT_DST:\n\tcase NFT_CT_SRC_IP:\n\tcase NFT_CT_DST_IP:\n\tcase NFT_CT_SRC_IP6:\n\tcase NFT_CT_DST_IP6:\n\tcase NFT_CT_PROTO_SRC:\n\tcase NFT_CT_PROTO_DST:\n\t\tif (nla_put_u8(skb, NFTA_CT_DIRECTION, priv->dir))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase NFT_CT_BYTES:\n\tcase NFT_CT_PKTS:\n\tcase NFT_CT_AVGPKT:\n\tcase NFT_CT_ZONE:\n\t\tif (priv->dir < IP_CT_DIR_MAX &&\n\t\t    nla_put_u8(skb, NFTA_CT_DIRECTION, priv->dir))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic bool nft_ct_get_reduce(struct nft_regs_track *track,\n\t\t\t      const struct nft_expr *expr)\n{\n\tconst struct nft_ct *priv = nft_expr_priv(expr);\n\tconst struct nft_ct *ct;\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tct = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->key != ct->key) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn nft_expr_reduce_bitwise(track, expr);\n}\n\nstatic int nft_ct_set_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_ct *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_CT_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_CT_KEY, htonl(priv->key)))\n\t\tgoto nla_put_failure;\n\n\tswitch (priv->key) {\n\tcase NFT_CT_ZONE:\n\t\tif (priv->dir < IP_CT_DIR_MAX &&\n\t\t    nla_put_u8(skb, NFTA_CT_DIRECTION, priv->dir))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic struct nft_expr_type nft_ct_type;\nstatic const struct nft_expr_ops nft_ct_get_ops = {\n\t.type\t\t= &nft_ct_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_ct)),\n\t.eval\t\t= nft_ct_get_eval,\n\t.init\t\t= nft_ct_get_init,\n\t.destroy\t= nft_ct_get_destroy,\n\t.dump\t\t= nft_ct_get_dump,\n\t.reduce\t\t= nft_ct_get_reduce,\n};\n\nstatic bool nft_ct_set_reduce(struct nft_regs_track *track,\n\t\t\t      const struct nft_expr *expr)\n{\n\tint i;\n\n\tfor (i = 0; i < NFT_REG32_NUM; i++) {\n\t\tif (!track->regs[i].selector)\n\t\t\tcontinue;\n\n\t\tif (track->regs[i].selector->ops != &nft_ct_get_ops)\n\t\t\tcontinue;\n\n\t\t__nft_reg_track_cancel(track, i);\n\t}\n\n\treturn false;\n}\n\n#ifdef CONFIG_RETPOLINE\nstatic const struct nft_expr_ops nft_ct_get_fast_ops = {\n\t.type\t\t= &nft_ct_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_ct)),\n\t.eval\t\t= nft_ct_get_fast_eval,\n\t.init\t\t= nft_ct_get_init,\n\t.destroy\t= nft_ct_get_destroy,\n\t.dump\t\t= nft_ct_get_dump,\n\t.reduce\t\t= nft_ct_set_reduce,\n};\n#endif\n\nstatic const struct nft_expr_ops nft_ct_set_ops = {\n\t.type\t\t= &nft_ct_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_ct)),\n\t.eval\t\t= nft_ct_set_eval,\n\t.init\t\t= nft_ct_set_init,\n\t.destroy\t= nft_ct_set_destroy,\n\t.dump\t\t= nft_ct_set_dump,\n\t.reduce\t\t= nft_ct_set_reduce,\n};\n\n#ifdef CONFIG_NF_CONNTRACK_ZONES\nstatic const struct nft_expr_ops nft_ct_set_zone_ops = {\n\t.type\t\t= &nft_ct_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_ct)),\n\t.eval\t\t= nft_ct_set_zone_eval,\n\t.init\t\t= nft_ct_set_init,\n\t.destroy\t= nft_ct_set_destroy,\n\t.dump\t\t= nft_ct_set_dump,\n\t.reduce\t\t= nft_ct_set_reduce,\n};\n#endif\n\nstatic const struct nft_expr_ops *\nnft_ct_select_ops(const struct nft_ctx *ctx,\n\t\t    const struct nlattr * const tb[])\n{\n\tif (tb[NFTA_CT_KEY] == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tb[NFTA_CT_DREG] && tb[NFTA_CT_SREG])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tb[NFTA_CT_DREG]) {\n#ifdef CONFIG_RETPOLINE\n\t\tu32 k = ntohl(nla_get_be32(tb[NFTA_CT_KEY]));\n\n\t\tswitch (k) {\n\t\tcase NFT_CT_STATE:\n\t\tcase NFT_CT_DIRECTION:\n\t\tcase NFT_CT_STATUS:\n\t\tcase NFT_CT_MARK:\n\t\tcase NFT_CT_SECMARK:\n\t\t\treturn &nft_ct_get_fast_ops;\n\t\t}\n#endif\n\t\treturn &nft_ct_get_ops;\n\t}\n\n\tif (tb[NFTA_CT_SREG]) {\n#ifdef CONFIG_NF_CONNTRACK_ZONES\n\t\tif (nla_get_be32(tb[NFTA_CT_KEY]) == htonl(NFT_CT_ZONE))\n\t\t\treturn &nft_ct_set_zone_ops;\n#endif\n\t\treturn &nft_ct_set_ops;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct nft_expr_type nft_ct_type __read_mostly = {\n\t.name\t\t= \"ct\",\n\t.select_ops\t= nft_ct_select_ops,\n\t.policy\t\t= nft_ct_policy,\n\t.maxattr\t= NFTA_CT_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void nft_notrack_eval(const struct nft_expr *expr,\n\t\t\t     struct nft_regs *regs,\n\t\t\t     const struct nft_pktinfo *pkt)\n{\n\tstruct sk_buff *skb = pkt->skb;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(pkt->skb, &ctinfo);\n\t \n\tif (ct || ctinfo == IP_CT_UNTRACKED)\n\t\treturn;\n\n\tnf_ct_set(skb, ct, IP_CT_UNTRACKED);\n}\n\nstatic struct nft_expr_type nft_notrack_type;\nstatic const struct nft_expr_ops nft_notrack_ops = {\n\t.type\t\t= &nft_notrack_type,\n\t.size\t\t= NFT_EXPR_SIZE(0),\n\t.eval\t\t= nft_notrack_eval,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_notrack_type __read_mostly = {\n\t.name\t\t= \"notrack\",\n\t.ops\t\t= &nft_notrack_ops,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\nstatic int\nnft_ct_timeout_parse_policy(void *timeouts,\n\t\t\t    const struct nf_conntrack_l4proto *l4proto,\n\t\t\t    struct net *net, const struct nlattr *attr)\n{\n\tstruct nlattr **tb;\n\tint ret = 0;\n\n\ttb = kcalloc(l4proto->ctnl_timeout.nlattr_max + 1, sizeof(*tb),\n\t\t     GFP_KERNEL);\n\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t  l4proto->ctnl_timeout.nlattr_max,\n\t\t\t\t\t  attr,\n\t\t\t\t\t  l4proto->ctnl_timeout.nla_policy,\n\t\t\t\t\t  NULL);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = l4proto->ctnl_timeout.nlattr_to_obj(tb, net, timeouts);\n\nerr:\n\tkfree(tb);\n\treturn ret;\n}\n\nstruct nft_ct_timeout_obj {\n\tstruct nf_ct_timeout    *timeout;\n\tu8\t\t\tl4proto;\n};\n\nstatic void nft_ct_timeout_obj_eval(struct nft_object *obj,\n\t\t\t\t    struct nft_regs *regs,\n\t\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_ct_timeout_obj *priv = nft_obj_data(obj);\n\tstruct nf_conn *ct = (struct nf_conn *)skb_nfct(pkt->skb);\n\tstruct nf_conn_timeout *timeout;\n\tconst unsigned int *values;\n\n\tif (priv->l4proto != pkt->tprot)\n\t\treturn;\n\n\tif (!ct || nf_ct_is_template(ct) || nf_ct_is_confirmed(ct))\n\t\treturn;\n\n\ttimeout = nf_ct_timeout_find(ct);\n\tif (!timeout) {\n\t\ttimeout = nf_ct_timeout_ext_add(ct, priv->timeout, GFP_ATOMIC);\n\t\tif (!timeout) {\n\t\t\tregs->verdict.code = NF_DROP;\n\t\t\treturn;\n\t\t}\n\t}\n\n\trcu_assign_pointer(timeout->timeout, priv->timeout);\n\n\t \n\tvalues = nf_ct_timeout_data(timeout);\n\tif (values)\n\t\tnf_ct_refresh(ct, pkt->skb, values[0]);\n}\n\nstatic int nft_ct_timeout_obj_init(const struct nft_ctx *ctx,\n\t\t\t\t   const struct nlattr * const tb[],\n\t\t\t\t   struct nft_object *obj)\n{\n\tstruct nft_ct_timeout_obj *priv = nft_obj_data(obj);\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tstruct nf_ct_timeout *timeout;\n\tint l3num = ctx->family;\n\t__u8 l4num;\n\tint ret;\n\n\tif (!tb[NFTA_CT_TIMEOUT_L4PROTO] ||\n\t    !tb[NFTA_CT_TIMEOUT_DATA])\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_CT_TIMEOUT_L3PROTO])\n\t\tl3num = ntohs(nla_get_be16(tb[NFTA_CT_TIMEOUT_L3PROTO]));\n\n\tl4num = nla_get_u8(tb[NFTA_CT_TIMEOUT_L4PROTO]);\n\tpriv->l4proto = l4num;\n\n\tl4proto = nf_ct_l4proto_find(l4num);\n\n\tif (l4proto->l4proto != l4num) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_proto_put;\n\t}\n\n\ttimeout = kzalloc(sizeof(struct nf_ct_timeout) +\n\t\t\t  l4proto->ctnl_timeout.obj_size, GFP_KERNEL);\n\tif (timeout == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_proto_put;\n\t}\n\n\tret = nft_ct_timeout_parse_policy(&timeout->data, l4proto, ctx->net,\n\t\t\t\t\t  tb[NFTA_CT_TIMEOUT_DATA]);\n\tif (ret < 0)\n\t\tgoto err_free_timeout;\n\n\ttimeout->l3num = l3num;\n\ttimeout->l4proto = l4proto;\n\n\tret = nf_ct_netns_get(ctx->net, ctx->family);\n\tif (ret < 0)\n\t\tgoto err_free_timeout;\n\n\tpriv->timeout = timeout;\n\treturn 0;\n\nerr_free_timeout:\n\tkfree(timeout);\nerr_proto_put:\n\treturn ret;\n}\n\nstatic void nft_ct_timeout_obj_destroy(const struct nft_ctx *ctx,\n\t\t\t\t       struct nft_object *obj)\n{\n\tstruct nft_ct_timeout_obj *priv = nft_obj_data(obj);\n\tstruct nf_ct_timeout *timeout = priv->timeout;\n\n\tnf_ct_untimeout(ctx->net, timeout);\n\tnf_ct_netns_put(ctx->net, ctx->family);\n\tkfree(priv->timeout);\n}\n\nstatic int nft_ct_timeout_obj_dump(struct sk_buff *skb,\n\t\t\t\t   struct nft_object *obj, bool reset)\n{\n\tconst struct nft_ct_timeout_obj *priv = nft_obj_data(obj);\n\tconst struct nf_ct_timeout *timeout = priv->timeout;\n\tstruct nlattr *nest_params;\n\tint ret;\n\n\tif (nla_put_u8(skb, NFTA_CT_TIMEOUT_L4PROTO, timeout->l4proto->l4proto) ||\n\t    nla_put_be16(skb, NFTA_CT_TIMEOUT_L3PROTO, htons(timeout->l3num)))\n\t\treturn -1;\n\n\tnest_params = nla_nest_start(skb, NFTA_CT_TIMEOUT_DATA);\n\tif (!nest_params)\n\t\treturn -1;\n\n\tret = timeout->l4proto->ctnl_timeout.obj_to_nlattr(skb, &timeout->data);\n\tif (ret < 0)\n\t\treturn -1;\n\tnla_nest_end(skb, nest_params);\n\treturn 0;\n}\n\nstatic const struct nla_policy nft_ct_timeout_policy[NFTA_CT_TIMEOUT_MAX + 1] = {\n\t[NFTA_CT_TIMEOUT_L3PROTO] = {.type = NLA_U16 },\n\t[NFTA_CT_TIMEOUT_L4PROTO] = {.type = NLA_U8 },\n\t[NFTA_CT_TIMEOUT_DATA]\t  = {.type = NLA_NESTED },\n};\n\nstatic struct nft_object_type nft_ct_timeout_obj_type;\n\nstatic const struct nft_object_ops nft_ct_timeout_obj_ops = {\n\t.type\t\t= &nft_ct_timeout_obj_type,\n\t.size\t\t= sizeof(struct nft_ct_timeout_obj),\n\t.eval\t\t= nft_ct_timeout_obj_eval,\n\t.init\t\t= nft_ct_timeout_obj_init,\n\t.destroy\t= nft_ct_timeout_obj_destroy,\n\t.dump\t\t= nft_ct_timeout_obj_dump,\n};\n\nstatic struct nft_object_type nft_ct_timeout_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_CT_TIMEOUT,\n\t.ops\t\t= &nft_ct_timeout_obj_ops,\n\t.maxattr\t= NFTA_CT_TIMEOUT_MAX,\n\t.policy\t\t= nft_ct_timeout_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n#endif  \n\nstatic int nft_ct_helper_obj_init(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nlattr * const tb[],\n\t\t\t\t  struct nft_object *obj)\n{\n\tstruct nft_ct_helper_obj *priv = nft_obj_data(obj);\n\tstruct nf_conntrack_helper *help4, *help6;\n\tchar name[NF_CT_HELPER_NAME_LEN];\n\tint family = ctx->family;\n\tint err;\n\n\tif (!tb[NFTA_CT_HELPER_NAME] || !tb[NFTA_CT_HELPER_L4PROTO])\n\t\treturn -EINVAL;\n\n\tpriv->l4proto = nla_get_u8(tb[NFTA_CT_HELPER_L4PROTO]);\n\tif (!priv->l4proto)\n\t\treturn -ENOENT;\n\n\tnla_strscpy(name, tb[NFTA_CT_HELPER_NAME], sizeof(name));\n\n\tif (tb[NFTA_CT_HELPER_L3PROTO])\n\t\tfamily = ntohs(nla_get_be16(tb[NFTA_CT_HELPER_L3PROTO]));\n\n\thelp4 = NULL;\n\thelp6 = NULL;\n\n\tswitch (family) {\n\tcase NFPROTO_IPV4:\n\t\tif (ctx->family == NFPROTO_IPV6)\n\t\t\treturn -EINVAL;\n\n\t\thelp4 = nf_conntrack_helper_try_module_get(name, family,\n\t\t\t\t\t\t\t   priv->l4proto);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tif (ctx->family == NFPROTO_IPV4)\n\t\t\treturn -EINVAL;\n\n\t\thelp6 = nf_conntrack_helper_try_module_get(name, family,\n\t\t\t\t\t\t\t   priv->l4proto);\n\t\tbreak;\n\tcase NFPROTO_NETDEV:\n\tcase NFPROTO_BRIDGE:\n\tcase NFPROTO_INET:\n\t\thelp4 = nf_conntrack_helper_try_module_get(name, NFPROTO_IPV4,\n\t\t\t\t\t\t\t   priv->l4proto);\n\t\thelp6 = nf_conntrack_helper_try_module_get(name, NFPROTO_IPV6,\n\t\t\t\t\t\t\t   priv->l4proto);\n\t\tbreak;\n\tdefault:\n\t\treturn -EAFNOSUPPORT;\n\t}\n\n\t \n\tif (!help4 && !help6)\n\t\treturn -ENOENT;\n\n\tpriv->helper4 = help4;\n\tpriv->helper6 = help6;\n\n\terr = nf_ct_netns_get(ctx->net, ctx->family);\n\tif (err < 0)\n\t\tgoto err_put_helper;\n\n\treturn 0;\n\nerr_put_helper:\n\tif (priv->helper4)\n\t\tnf_conntrack_helper_put(priv->helper4);\n\tif (priv->helper6)\n\t\tnf_conntrack_helper_put(priv->helper6);\n\treturn err;\n}\n\nstatic void nft_ct_helper_obj_destroy(const struct nft_ctx *ctx,\n\t\t\t\t      struct nft_object *obj)\n{\n\tstruct nft_ct_helper_obj *priv = nft_obj_data(obj);\n\n\tif (priv->helper4)\n\t\tnf_conntrack_helper_put(priv->helper4);\n\tif (priv->helper6)\n\t\tnf_conntrack_helper_put(priv->helper6);\n\n\tnf_ct_netns_put(ctx->net, ctx->family);\n}\n\nstatic void nft_ct_helper_obj_eval(struct nft_object *obj,\n\t\t\t\t   struct nft_regs *regs,\n\t\t\t\t   const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_ct_helper_obj *priv = nft_obj_data(obj);\n\tstruct nf_conn *ct = (struct nf_conn *)skb_nfct(pkt->skb);\n\tstruct nf_conntrack_helper *to_assign = NULL;\n\tstruct nf_conn_help *help;\n\n\tif (!ct ||\n\t    nf_ct_is_confirmed(ct) ||\n\t    nf_ct_is_template(ct) ||\n\t    priv->l4proto != nf_ct_protonum(ct))\n\t\treturn;\n\n\tswitch (nf_ct_l3num(ct)) {\n\tcase NFPROTO_IPV4:\n\t\tto_assign = priv->helper4;\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tto_assign = priv->helper6;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (!to_assign)\n\t\treturn;\n\n\tif (test_bit(IPS_HELPER_BIT, &ct->status))\n\t\treturn;\n\n\thelp = nf_ct_helper_ext_add(ct, GFP_ATOMIC);\n\tif (help) {\n\t\trcu_assign_pointer(help->helper, to_assign);\n\t\tset_bit(IPS_HELPER_BIT, &ct->status);\n\t}\n}\n\nstatic int nft_ct_helper_obj_dump(struct sk_buff *skb,\n\t\t\t\t  struct nft_object *obj, bool reset)\n{\n\tconst struct nft_ct_helper_obj *priv = nft_obj_data(obj);\n\tconst struct nf_conntrack_helper *helper;\n\tu16 family;\n\n\tif (priv->helper4 && priv->helper6) {\n\t\tfamily = NFPROTO_INET;\n\t\thelper = priv->helper4;\n\t} else if (priv->helper6) {\n\t\tfamily = NFPROTO_IPV6;\n\t\thelper = priv->helper6;\n\t} else {\n\t\tfamily = NFPROTO_IPV4;\n\t\thelper = priv->helper4;\n\t}\n\n\tif (nla_put_string(skb, NFTA_CT_HELPER_NAME, helper->name))\n\t\treturn -1;\n\n\tif (nla_put_u8(skb, NFTA_CT_HELPER_L4PROTO, priv->l4proto))\n\t\treturn -1;\n\n\tif (nla_put_be16(skb, NFTA_CT_HELPER_L3PROTO, htons(family)))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic const struct nla_policy nft_ct_helper_policy[NFTA_CT_HELPER_MAX + 1] = {\n\t[NFTA_CT_HELPER_NAME] = { .type = NLA_STRING,\n\t\t\t\t  .len = NF_CT_HELPER_NAME_LEN - 1 },\n\t[NFTA_CT_HELPER_L3PROTO] = { .type = NLA_U16 },\n\t[NFTA_CT_HELPER_L4PROTO] = { .type = NLA_U8 },\n};\n\nstatic struct nft_object_type nft_ct_helper_obj_type;\nstatic const struct nft_object_ops nft_ct_helper_obj_ops = {\n\t.type\t\t= &nft_ct_helper_obj_type,\n\t.size\t\t= sizeof(struct nft_ct_helper_obj),\n\t.eval\t\t= nft_ct_helper_obj_eval,\n\t.init\t\t= nft_ct_helper_obj_init,\n\t.destroy\t= nft_ct_helper_obj_destroy,\n\t.dump\t\t= nft_ct_helper_obj_dump,\n};\n\nstatic struct nft_object_type nft_ct_helper_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_CT_HELPER,\n\t.ops\t\t= &nft_ct_helper_obj_ops,\n\t.maxattr\t= NFTA_CT_HELPER_MAX,\n\t.policy\t\t= nft_ct_helper_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstruct nft_ct_expect_obj {\n\tu16\t\tl3num;\n\t__be16\t\tdport;\n\tu8\t\tl4proto;\n\tu8\t\tsize;\n\tu32\t\ttimeout;\n};\n\nstatic int nft_ct_expect_obj_init(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nlattr * const tb[],\n\t\t\t\t  struct nft_object *obj)\n{\n\tstruct nft_ct_expect_obj *priv = nft_obj_data(obj);\n\n\tif (!tb[NFTA_CT_EXPECT_L4PROTO] ||\n\t    !tb[NFTA_CT_EXPECT_DPORT] ||\n\t    !tb[NFTA_CT_EXPECT_TIMEOUT] ||\n\t    !tb[NFTA_CT_EXPECT_SIZE])\n\t\treturn -EINVAL;\n\n\tpriv->l3num = ctx->family;\n\tif (tb[NFTA_CT_EXPECT_L3PROTO])\n\t\tpriv->l3num = ntohs(nla_get_be16(tb[NFTA_CT_EXPECT_L3PROTO]));\n\n\tpriv->l4proto = nla_get_u8(tb[NFTA_CT_EXPECT_L4PROTO]);\n\tpriv->dport = nla_get_be16(tb[NFTA_CT_EXPECT_DPORT]);\n\tpriv->timeout = nla_get_u32(tb[NFTA_CT_EXPECT_TIMEOUT]);\n\tpriv->size = nla_get_u8(tb[NFTA_CT_EXPECT_SIZE]);\n\n\treturn nf_ct_netns_get(ctx->net, ctx->family);\n}\n\nstatic void nft_ct_expect_obj_destroy(const struct nft_ctx *ctx,\n\t\t\t\t       struct nft_object *obj)\n{\n\tnf_ct_netns_put(ctx->net, ctx->family);\n}\n\nstatic int nft_ct_expect_obj_dump(struct sk_buff *skb,\n\t\t\t\t  struct nft_object *obj, bool reset)\n{\n\tconst struct nft_ct_expect_obj *priv = nft_obj_data(obj);\n\n\tif (nla_put_be16(skb, NFTA_CT_EXPECT_L3PROTO, htons(priv->l3num)) ||\n\t    nla_put_u8(skb, NFTA_CT_EXPECT_L4PROTO, priv->l4proto) ||\n\t    nla_put_be16(skb, NFTA_CT_EXPECT_DPORT, priv->dport) ||\n\t    nla_put_u32(skb, NFTA_CT_EXPECT_TIMEOUT, priv->timeout) ||\n\t    nla_put_u8(skb, NFTA_CT_EXPECT_SIZE, priv->size))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void nft_ct_expect_obj_eval(struct nft_object *obj,\n\t\t\t\t   struct nft_regs *regs,\n\t\t\t\t   const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_ct_expect_obj *priv = nft_obj_data(obj);\n\tstruct nf_conntrack_expect *exp;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn_help *help;\n\tenum ip_conntrack_dir dir;\n\tu16 l3num = priv->l3num;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(pkt->skb, &ctinfo);\n\tif (!ct || nf_ct_is_confirmed(ct) || nf_ct_is_template(ct)) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\tdir = CTINFO2DIR(ctinfo);\n\n\thelp = nfct_help(ct);\n\tif (!help)\n\t\thelp = nf_ct_helper_ext_add(ct, GFP_ATOMIC);\n\tif (!help) {\n\t\tregs->verdict.code = NF_DROP;\n\t\treturn;\n\t}\n\n\tif (help->expecting[NF_CT_EXPECT_CLASS_DEFAULT] >= priv->size) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\tif (l3num == NFPROTO_INET)\n\t\tl3num = nf_ct_l3num(ct);\n\n\texp = nf_ct_expect_alloc(ct);\n\tif (exp == NULL) {\n\t\tregs->verdict.code = NF_DROP;\n\t\treturn;\n\t}\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, l3num,\n\t\t          &ct->tuplehash[!dir].tuple.src.u3,\n\t\t          &ct->tuplehash[!dir].tuple.dst.u3,\n\t\t          priv->l4proto, NULL, &priv->dport);\n\texp->timeout.expires = jiffies + priv->timeout * HZ;\n\n\tif (nf_ct_expect_related(exp, 0) != 0)\n\t\tregs->verdict.code = NF_DROP;\n}\n\nstatic const struct nla_policy nft_ct_expect_policy[NFTA_CT_EXPECT_MAX + 1] = {\n\t[NFTA_CT_EXPECT_L3PROTO]\t= { .type = NLA_U16 },\n\t[NFTA_CT_EXPECT_L4PROTO]\t= { .type = NLA_U8 },\n\t[NFTA_CT_EXPECT_DPORT]\t\t= { .type = NLA_U16 },\n\t[NFTA_CT_EXPECT_TIMEOUT]\t= { .type = NLA_U32 },\n\t[NFTA_CT_EXPECT_SIZE]\t\t= { .type = NLA_U8 },\n};\n\nstatic struct nft_object_type nft_ct_expect_obj_type;\n\nstatic const struct nft_object_ops nft_ct_expect_obj_ops = {\n\t.type\t\t= &nft_ct_expect_obj_type,\n\t.size\t\t= sizeof(struct nft_ct_expect_obj),\n\t.eval\t\t= nft_ct_expect_obj_eval,\n\t.init\t\t= nft_ct_expect_obj_init,\n\t.destroy\t= nft_ct_expect_obj_destroy,\n\t.dump\t\t= nft_ct_expect_obj_dump,\n};\n\nstatic struct nft_object_type nft_ct_expect_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_CT_EXPECT,\n\t.ops\t\t= &nft_ct_expect_obj_ops,\n\t.maxattr\t= NFTA_CT_EXPECT_MAX,\n\t.policy\t\t= nft_ct_expect_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_ct_module_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(NF_CT_LABELS_MAX_SIZE > NFT_REG_SIZE);\n\n\terr = nft_register_expr(&nft_ct_type);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_register_expr(&nft_notrack_type);\n\tif (err < 0)\n\t\tgoto err1;\n\n\terr = nft_register_obj(&nft_ct_helper_obj_type);\n\tif (err < 0)\n\t\tgoto err2;\n\n\terr = nft_register_obj(&nft_ct_expect_obj_type);\n\tif (err < 0)\n\t\tgoto err3;\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\terr = nft_register_obj(&nft_ct_timeout_obj_type);\n\tif (err < 0)\n\t\tgoto err4;\n#endif\n\treturn 0;\n\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\nerr4:\n\tnft_unregister_obj(&nft_ct_expect_obj_type);\n#endif\nerr3:\n\tnft_unregister_obj(&nft_ct_helper_obj_type);\nerr2:\n\tnft_unregister_expr(&nft_notrack_type);\nerr1:\n\tnft_unregister_expr(&nft_ct_type);\n\treturn err;\n}\n\nstatic void __exit nft_ct_module_exit(void)\n{\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\tnft_unregister_obj(&nft_ct_timeout_obj_type);\n#endif\n\tnft_unregister_obj(&nft_ct_expect_obj_type);\n\tnft_unregister_obj(&nft_ct_helper_obj_type);\n\tnft_unregister_expr(&nft_notrack_type);\n\tnft_unregister_expr(&nft_ct_type);\n}\n\nmodule_init(nft_ct_module_init);\nmodule_exit(nft_ct_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_ALIAS_NFT_EXPR(\"ct\");\nMODULE_ALIAS_NFT_EXPR(\"notrack\");\nMODULE_ALIAS_NFT_OBJ(NFT_OBJECT_CT_HELPER);\nMODULE_ALIAS_NFT_OBJ(NFT_OBJECT_CT_TIMEOUT);\nMODULE_ALIAS_NFT_OBJ(NFT_OBJECT_CT_EXPECT);\nMODULE_DESCRIPTION(\"Netfilter nf_tables conntrack module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}