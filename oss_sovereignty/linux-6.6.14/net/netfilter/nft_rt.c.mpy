{
  "module_name": "nft_rt.c",
  "hash_id": "05ce76c52347c26da5e97bb41b2a57a17087eb682f1a5c7895f5af23526d74be",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_rt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/dst.h>\n#include <net/ip6_route.h>\n#include <net/route.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n\nstruct nft_rt {\n\tenum nft_rt_keys\tkey:8;\n\tu8\t\t\tdreg;\n};\n\nstatic u16 get_tcpmss(const struct nft_pktinfo *pkt, const struct dst_entry *skbdst)\n{\n\tu32 minlen = sizeof(struct ipv6hdr), mtu = dst_mtu(skbdst);\n\tconst struct sk_buff *skb = pkt->skb;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi fl;\n\n\tmemset(&fl, 0, sizeof(fl));\n\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tfl.u.ip4.daddr = ip_hdr(skb)->saddr;\n\t\tminlen = sizeof(struct iphdr) + sizeof(struct tcphdr);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tfl.u.ip6.daddr = ipv6_hdr(skb)->saddr;\n\t\tminlen = sizeof(struct ipv6hdr) + sizeof(struct tcphdr);\n\t\tbreak;\n\t}\n\n\tnf_route(nft_net(pkt), &dst, &fl, false, nft_pf(pkt));\n\tif (dst) {\n\t\tmtu = min(mtu, dst_mtu(dst));\n\t\tdst_release(dst);\n\t}\n\n\tif (mtu <= minlen || mtu > 0xffff)\n\t\treturn TCP_MSS_DEFAULT;\n\n\treturn mtu - minlen;\n}\n\nvoid nft_rt_get_eval(const struct nft_expr *expr,\n\t\t     struct nft_regs *regs,\n\t\t     const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_rt *priv = nft_expr_priv(expr);\n\tconst struct sk_buff *skb = pkt->skb;\n\tu32 *dest = &regs->data[priv->dreg];\n\tconst struct dst_entry *dst;\n\n\tdst = skb_dst(skb);\n\tif (!dst)\n\t\tgoto err;\n\n\tswitch (priv->key) {\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tcase NFT_RT_CLASSID:\n\t\t*dest = dst->tclassid;\n\t\tbreak;\n#endif\n\tcase NFT_RT_NEXTHOP4:\n\t\tif (nft_pf(pkt) != NFPROTO_IPV4)\n\t\t\tgoto err;\n\n\t\t*dest = (__force u32)rt_nexthop((const struct rtable *)dst,\n\t\t\t\t\t\tip_hdr(skb)->daddr);\n\t\tbreak;\n\tcase NFT_RT_NEXTHOP6:\n\t\tif (nft_pf(pkt) != NFPROTO_IPV6)\n\t\t\tgoto err;\n\n\t\tmemcpy(dest, rt6_nexthop((struct rt6_info *)dst,\n\t\t\t\t\t &ipv6_hdr(skb)->daddr),\n\t\t       sizeof(struct in6_addr));\n\t\tbreak;\n\tcase NFT_RT_TCPMSS:\n\t\tnft_reg_store16(dest, get_tcpmss(pkt, dst));\n\t\tbreak;\n#ifdef CONFIG_XFRM\n\tcase NFT_RT_XFRM:\n\t\tnft_reg_store8(dest, !!dst->xfrm);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON(1);\n\t\tgoto err;\n\t}\n\treturn;\n\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic const struct nla_policy nft_rt_policy[NFTA_RT_MAX + 1] = {\n\t[NFTA_RT_DREG]\t\t= { .type = NLA_U32 },\n\t[NFTA_RT_KEY]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n};\n\nstatic int nft_rt_get_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nft_rt *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\n\tif (tb[NFTA_RT_KEY] == NULL ||\n\t    tb[NFTA_RT_DREG] == NULL)\n\t\treturn -EINVAL;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_RT_KEY]));\n\tswitch (priv->key) {\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tcase NFT_RT_CLASSID:\n#endif\n\tcase NFT_RT_NEXTHOP4:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tcase NFT_RT_NEXTHOP6:\n\t\tlen = sizeof(struct in6_addr);\n\t\tbreak;\n\tcase NFT_RT_TCPMSS:\n\t\tlen = sizeof(u16);\n\t\tbreak;\n#ifdef CONFIG_XFRM\n\tcase NFT_RT_XFRM:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_RT_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\n\nstatic int nft_rt_get_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_rt *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_RT_KEY, htonl(priv->key)))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_RT_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_rt_validate(const struct nft_ctx *ctx, const struct nft_expr *expr,\n\t\t\t   const struct nft_data **data)\n{\n\tconst struct nft_rt *priv = nft_expr_priv(expr);\n\tunsigned int hooks;\n\n\tswitch (priv->key) {\n\tcase NFT_RT_NEXTHOP4:\n\tcase NFT_RT_NEXTHOP6:\n\tcase NFT_RT_CLASSID:\n\tcase NFT_RT_XFRM:\n\t\treturn 0;\n\tcase NFT_RT_TCPMSS:\n\t\thooks = (1 << NF_INET_FORWARD) |\n\t\t\t(1 << NF_INET_LOCAL_OUT) |\n\t\t\t(1 << NF_INET_POST_ROUTING);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\n\nstatic const struct nft_expr_ops nft_rt_get_ops = {\n\t.type\t\t= &nft_rt_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_rt)),\n\t.eval\t\t= nft_rt_get_eval,\n\t.init\t\t= nft_rt_get_init,\n\t.dump\t\t= nft_rt_get_dump,\n\t.validate\t= nft_rt_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstruct nft_expr_type nft_rt_type __read_mostly = {\n\t.name\t\t= \"rt\",\n\t.ops\t\t= &nft_rt_get_ops,\n\t.policy\t\t= nft_rt_policy,\n\t.maxattr\t= NFTA_RT_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}