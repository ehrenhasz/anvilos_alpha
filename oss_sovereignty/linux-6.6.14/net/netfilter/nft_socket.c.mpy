{
  "module_name": "nft_socket.c",
  "hash_id": "8603e16ab40732312f885f49dd36840a66509fb65a60ef23d88b78e6c1494d79",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_socket.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_socket.h>\n#include <net/inet_sock.h>\n#include <net/tcp.h>\n\nstruct nft_socket {\n\tenum nft_socket_keys\t\tkey:8;\n\tu8\t\t\t\tlevel;\n\tu8\t\t\t\tlen;\n\tunion {\n\t\tu8\t\t\tdreg;\n\t};\n};\n\nstatic void nft_socket_wildcard(const struct nft_pktinfo *pkt,\n\t\t\t\tstruct nft_regs *regs, struct sock *sk,\n\t\t\t\tu32 *dest)\n{\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tnft_reg_store8(dest, inet_sk(sk)->inet_rcv_saddr == 0);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\tcase NFPROTO_IPV6:\n\t\tnft_reg_store8(dest, ipv6_addr_any(&sk->sk_v6_rcv_saddr));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n}\n\n#ifdef CONFIG_SOCK_CGROUP_DATA\nstatic noinline bool\nnft_sock_get_eval_cgroupv2(u32 *dest, struct sock *sk, const struct nft_pktinfo *pkt, u32 level)\n{\n\tstruct cgroup *cgrp;\n\tu64 cgid;\n\n\tif (!sk_fullsock(sk))\n\t\treturn false;\n\n\tcgrp = cgroup_ancestor(sock_cgroup_ptr(&sk->sk_cgrp_data), level);\n\tif (!cgrp)\n\t\treturn false;\n\n\tcgid = cgroup_id(cgrp);\n\tmemcpy(dest, &cgid, sizeof(u64));\n\treturn true;\n}\n#endif\n\nstatic struct sock *nft_socket_do_lookup(const struct nft_pktinfo *pkt)\n{\n\tconst struct net_device *indev = nft_in(pkt);\n\tconst struct sk_buff *skb = pkt->skb;\n\tstruct sock *sk = NULL;\n\n\tif (!indev)\n\t\treturn NULL;\n\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tsk = nf_sk_lookup_slow_v4(nft_net(pkt), skb, indev);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\tcase NFPROTO_IPV6:\n\t\tsk = nf_sk_lookup_slow_v6(nft_net(pkt), skb, indev);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn sk;\n}\n\nstatic void nft_socket_eval(const struct nft_expr *expr,\n\t\t\t    struct nft_regs *regs,\n\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_socket *priv = nft_expr_priv(expr);\n\tstruct sk_buff *skb = pkt->skb;\n\tstruct sock *sk = skb->sk;\n\tu32 *dest = &regs->data[priv->dreg];\n\n\tif (sk && !net_eq(nft_net(pkt), sock_net(sk)))\n\t\tsk = NULL;\n\n\tif (!sk)\n\t\tsk = nft_socket_do_lookup(pkt);\n\n\tif (!sk) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tswitch(priv->key) {\n\tcase NFT_SOCKET_TRANSPARENT:\n\t\tnft_reg_store8(dest, inet_sk_transparent(sk));\n\t\tbreak;\n\tcase NFT_SOCKET_MARK:\n\t\tif (sk_fullsock(sk)) {\n\t\t\t*dest = READ_ONCE(sk->sk_mark);\n\t\t} else {\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase NFT_SOCKET_WILDCARD:\n\t\tif (!sk_fullsock(sk)) {\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\t\treturn;\n\t\t}\n\t\tnft_socket_wildcard(pkt, regs, sk, dest);\n\t\tbreak;\n#ifdef CONFIG_SOCK_CGROUP_DATA\n\tcase NFT_SOCKET_CGROUPV2:\n\t\tif (!nft_sock_get_eval_cgroupv2(dest, sk, pkt, priv->level)) {\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON(1);\n\t\tregs->verdict.code = NFT_BREAK;\n\t}\n\n\tif (sk != skb->sk)\n\t\tsock_gen_put(sk);\n}\n\nstatic const struct nla_policy nft_socket_policy[NFTA_SOCKET_MAX + 1] = {\n\t[NFTA_SOCKET_KEY]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_SOCKET_DREG]\t\t= { .type = NLA_U32 },\n\t[NFTA_SOCKET_LEVEL]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n};\n\nstatic int nft_socket_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nft_socket *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\n\tif (!tb[NFTA_SOCKET_DREG] || !tb[NFTA_SOCKET_KEY])\n\t\treturn -EINVAL;\n\n\tswitch(ctx->family) {\n\tcase NFPROTO_IPV4:\n#if IS_ENABLED(CONFIG_NF_TABLES_IPV6)\n\tcase NFPROTO_IPV6:\n#endif\n\tcase NFPROTO_INET:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_SOCKET_KEY]));\n\tswitch(priv->key) {\n\tcase NFT_SOCKET_TRANSPARENT:\n\tcase NFT_SOCKET_WILDCARD:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tcase NFT_SOCKET_MARK:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n#ifdef CONFIG_CGROUPS\n\tcase NFT_SOCKET_CGROUPV2: {\n\t\tunsigned int level;\n\n\t\tif (!tb[NFTA_SOCKET_LEVEL])\n\t\t\treturn -EINVAL;\n\n\t\tlevel = ntohl(nla_get_be32(tb[NFTA_SOCKET_LEVEL]));\n\t\tif (level > 255)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tpriv->level = level;\n\t\tlen = sizeof(u64);\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->len = len;\n\treturn nft_parse_register_store(ctx, tb[NFTA_SOCKET_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\n\nstatic int nft_socket_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_socket *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_SOCKET_KEY, htonl(priv->key)))\n\t\treturn -1;\n\tif (nft_dump_register(skb, NFTA_SOCKET_DREG, priv->dreg))\n\t\treturn -1;\n\tif (priv->key == NFT_SOCKET_CGROUPV2 &&\n\t    nla_put_be32(skb, NFTA_SOCKET_LEVEL, htonl(priv->level)))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic bool nft_socket_reduce(struct nft_regs_track *track,\n\t\t\t      const struct nft_expr *expr)\n{\n\tconst struct nft_socket *priv = nft_expr_priv(expr);\n\tconst struct nft_socket *socket;\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tsocket = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->key != socket->key ||\n\t    priv->dreg != socket->dreg ||\n\t    priv->level != socket->level) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn nft_expr_reduce_bitwise(track, expr);\n}\n\nstatic int nft_socket_validate(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nft_data **data)\n{\n\treturn nft_chain_validate_hooks(ctx->chain,\n\t\t\t\t\t(1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t\t(1 << NF_INET_LOCAL_IN) |\n\t\t\t\t\t(1 << NF_INET_LOCAL_OUT));\n}\n\nstatic struct nft_expr_type nft_socket_type;\nstatic const struct nft_expr_ops nft_socket_ops = {\n\t.type\t\t= &nft_socket_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_socket)),\n\t.eval\t\t= nft_socket_eval,\n\t.init\t\t= nft_socket_init,\n\t.dump\t\t= nft_socket_dump,\n\t.validate\t= nft_socket_validate,\n\t.reduce\t\t= nft_socket_reduce,\n};\n\nstatic struct nft_expr_type nft_socket_type __read_mostly = {\n\t.name\t\t= \"socket\",\n\t.ops\t\t= &nft_socket_ops,\n\t.policy\t\t= nft_socket_policy,\n\t.maxattr\t= NFTA_SOCKET_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_socket_module_init(void)\n{\n\treturn nft_register_expr(&nft_socket_type);\n}\n\nstatic void __exit nft_socket_module_exit(void)\n{\n\tnft_unregister_expr(&nft_socket_type);\n}\n\nmodule_init(nft_socket_module_init);\nmodule_exit(nft_socket_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"M\u00e1t\u00e9 Eckl\");\nMODULE_DESCRIPTION(\"nf_tables socket match module\");\nMODULE_ALIAS_NFT_EXPR(\"socket\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}