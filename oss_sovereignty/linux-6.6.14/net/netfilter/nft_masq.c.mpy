{
  "module_name": "nft_masq.c",
  "hash_id": "fe475e627ca8f44164dbd34e3152fd276d89b4bf12adde55c7e7d1de7c01a0d3",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_masq.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_nat_masquerade.h>\n\nstruct nft_masq {\n\tu32\t\t\tflags;\n\tu8\t\t\tsreg_proto_min;\n\tu8\t\t\tsreg_proto_max;\n};\n\nstatic const struct nla_policy nft_masq_policy[NFTA_MASQ_MAX + 1] = {\n\t[NFTA_MASQ_FLAGS]\t\t=\n\t\tNLA_POLICY_MASK(NLA_BE32, NF_NAT_RANGE_MASK),\n\t[NFTA_MASQ_REG_PROTO_MIN]\t= { .type = NLA_U32 },\n\t[NFTA_MASQ_REG_PROTO_MAX]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_masq_validate(const struct nft_ctx *ctx,\n\t\t\t     const struct nft_expr *expr,\n\t\t\t     const struct nft_data **data)\n{\n\tint err;\n\n\terr = nft_chain_validate_dependency(ctx->chain, NFT_CHAIN_T_NAT);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn nft_chain_validate_hooks(ctx->chain,\n\t\t\t\t        (1 << NF_INET_POST_ROUTING));\n}\n\nstatic int nft_masq_init(const struct nft_ctx *ctx,\n\t\t\t const struct nft_expr *expr,\n\t\t\t const struct nlattr * const tb[])\n{\n\tu32 plen = sizeof_field(struct nf_nat_range, min_proto.all);\n\tstruct nft_masq *priv = nft_expr_priv(expr);\n\tint err;\n\n\tif (tb[NFTA_MASQ_FLAGS])\n\t\tpriv->flags = ntohl(nla_get_be32(tb[NFTA_MASQ_FLAGS]));\n\n\tif (tb[NFTA_MASQ_REG_PROTO_MIN]) {\n\t\terr = nft_parse_register_load(tb[NFTA_MASQ_REG_PROTO_MIN],\n\t\t\t\t\t      &priv->sreg_proto_min, plen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tb[NFTA_MASQ_REG_PROTO_MAX]) {\n\t\t\terr = nft_parse_register_load(tb[NFTA_MASQ_REG_PROTO_MAX],\n\t\t\t\t\t\t      &priv->sreg_proto_max,\n\t\t\t\t\t\t      plen);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tpriv->sreg_proto_max = priv->sreg_proto_min;\n\t\t}\n\t}\n\n\treturn nf_ct_netns_get(ctx->net, ctx->family);\n}\n\nstatic int nft_masq_dump(struct sk_buff *skb,\n\t\t\t const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_masq *priv = nft_expr_priv(expr);\n\n\tif (priv->flags != 0 &&\n\t    nla_put_be32(skb, NFTA_MASQ_FLAGS, htonl(priv->flags)))\n\t\tgoto nla_put_failure;\n\n\tif (priv->sreg_proto_min) {\n\t\tif (nft_dump_register(skb, NFTA_MASQ_REG_PROTO_MIN,\n\t\t\t\t      priv->sreg_proto_min) ||\n\t\t    nft_dump_register(skb, NFTA_MASQ_REG_PROTO_MAX,\n\t\t\t\t      priv->sreg_proto_max))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic void nft_masq_eval(const struct nft_expr *expr,\n\t\t\t  struct nft_regs *regs,\n\t\t\t  const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_masq *priv = nft_expr_priv(expr);\n\tstruct nf_nat_range2 range;\n\n\tmemset(&range, 0, sizeof(range));\n\trange.flags = priv->flags;\n\tif (priv->sreg_proto_min) {\n\t\trange.min_proto.all = (__force __be16)\n\t\t\tnft_reg_load16(&regs->data[priv->sreg_proto_min]);\n\t\trange.max_proto.all = (__force __be16)\n\t\t\tnft_reg_load16(&regs->data[priv->sreg_proto_max]);\n\t}\n\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tregs->verdict.code = nf_nat_masquerade_ipv4(pkt->skb,\n\t\t\t\t\t\t\t    nft_hook(pkt),\n\t\t\t\t\t\t\t    &range,\n\t\t\t\t\t\t\t    nft_out(pkt));\n\t\tbreak;\n#ifdef CONFIG_NF_TABLES_IPV6\n\tcase NFPROTO_IPV6:\n\t\tregs->verdict.code = nf_nat_masquerade_ipv6(pkt->skb, &range,\n\t\t\t\t\t\t\t    nft_out(pkt));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}\n\nstatic void\nnft_masq_ipv4_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\n{\n\tnf_ct_netns_put(ctx->net, NFPROTO_IPV4);\n}\n\nstatic struct nft_expr_type nft_masq_ipv4_type;\nstatic const struct nft_expr_ops nft_masq_ipv4_ops = {\n\t.type\t\t= &nft_masq_ipv4_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_masq)),\n\t.eval\t\t= nft_masq_eval,\n\t.init\t\t= nft_masq_init,\n\t.destroy\t= nft_masq_ipv4_destroy,\n\t.dump\t\t= nft_masq_dump,\n\t.validate\t= nft_masq_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_masq_ipv4_type __read_mostly = {\n\t.family\t\t= NFPROTO_IPV4,\n\t.name\t\t= \"masq\",\n\t.ops\t\t= &nft_masq_ipv4_ops,\n\t.policy\t\t= nft_masq_policy,\n\t.maxattr\t= NFTA_MASQ_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_NF_TABLES_IPV6\nstatic void\nnft_masq_ipv6_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\n{\n\tnf_ct_netns_put(ctx->net, NFPROTO_IPV6);\n}\n\nstatic struct nft_expr_type nft_masq_ipv6_type;\nstatic const struct nft_expr_ops nft_masq_ipv6_ops = {\n\t.type\t\t= &nft_masq_ipv6_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_masq)),\n\t.eval\t\t= nft_masq_eval,\n\t.init\t\t= nft_masq_init,\n\t.destroy\t= nft_masq_ipv6_destroy,\n\t.dump\t\t= nft_masq_dump,\n\t.validate\t= nft_masq_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_masq_ipv6_type __read_mostly = {\n\t.family\t\t= NFPROTO_IPV6,\n\t.name\t\t= \"masq\",\n\t.ops\t\t= &nft_masq_ipv6_ops,\n\t.policy\t\t= nft_masq_policy,\n\t.maxattr\t= NFTA_MASQ_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_masq_module_init_ipv6(void)\n{\n\treturn nft_register_expr(&nft_masq_ipv6_type);\n}\n\nstatic void nft_masq_module_exit_ipv6(void)\n{\n\tnft_unregister_expr(&nft_masq_ipv6_type);\n}\n#else\nstatic inline int nft_masq_module_init_ipv6(void) { return 0; }\nstatic inline void nft_masq_module_exit_ipv6(void) {}\n#endif\n\n#ifdef CONFIG_NF_TABLES_INET\nstatic void\nnft_masq_inet_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\n{\n\tnf_ct_netns_put(ctx->net, NFPROTO_INET);\n}\n\nstatic struct nft_expr_type nft_masq_inet_type;\nstatic const struct nft_expr_ops nft_masq_inet_ops = {\n\t.type\t\t= &nft_masq_inet_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_masq)),\n\t.eval\t\t= nft_masq_eval,\n\t.init\t\t= nft_masq_init,\n\t.destroy\t= nft_masq_inet_destroy,\n\t.dump\t\t= nft_masq_dump,\n\t.validate\t= nft_masq_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_masq_inet_type __read_mostly = {\n\t.family\t\t= NFPROTO_INET,\n\t.name\t\t= \"masq\",\n\t.ops\t\t= &nft_masq_inet_ops,\n\t.policy\t\t= nft_masq_policy,\n\t.maxattr\t= NFTA_MASQ_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_masq_module_init_inet(void)\n{\n\treturn nft_register_expr(&nft_masq_inet_type);\n}\n\nstatic void nft_masq_module_exit_inet(void)\n{\n\tnft_unregister_expr(&nft_masq_inet_type);\n}\n#else\nstatic inline int nft_masq_module_init_inet(void) { return 0; }\nstatic inline void nft_masq_module_exit_inet(void) {}\n#endif\n\nstatic int __init nft_masq_module_init(void)\n{\n\tint ret;\n\n\tret = nft_masq_module_init_ipv6();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nft_masq_module_init_inet();\n\tif (ret < 0) {\n\t\tnft_masq_module_exit_ipv6();\n\t\treturn ret;\n\t}\n\n\tret = nft_register_expr(&nft_masq_ipv4_type);\n\tif (ret < 0) {\n\t\tnft_masq_module_exit_inet();\n\t\tnft_masq_module_exit_ipv6();\n\t\treturn ret;\n\t}\n\n\tret = nf_nat_masquerade_inet_register_notifiers();\n\tif (ret < 0) {\n\t\tnft_masq_module_exit_ipv6();\n\t\tnft_masq_module_exit_inet();\n\t\tnft_unregister_expr(&nft_masq_ipv4_type);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit nft_masq_module_exit(void)\n{\n\tnft_masq_module_exit_ipv6();\n\tnft_masq_module_exit_inet();\n\tnft_unregister_expr(&nft_masq_ipv4_type);\n\tnf_nat_masquerade_inet_unregister_notifiers();\n}\n\nmodule_init(nft_masq_module_init);\nmodule_exit(nft_masq_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arturo Borrero Gonzalez <arturo@debian.org>\");\nMODULE_ALIAS_NFT_EXPR(\"masq\");\nMODULE_DESCRIPTION(\"Netfilter nftables masquerade expression support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}