{
  "module_name": "nf_conntrack_proto_sctp.c",
  "hash_id": "083811980f45f12eda979cbcba444b82415b5fdfbf8f12cb9a29a07ca5bf6060",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_proto_sctp.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/netfilter.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/sctp.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <net/sctp/checksum.h>\n\n#include <net/netfilter/nf_log.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n\nstatic const char *const sctp_conntrack_names[] = {\n\t[SCTP_CONNTRACK_NONE]\t\t\t= \"NONE\",\n\t[SCTP_CONNTRACK_CLOSED]\t\t\t= \"CLOSED\",\n\t[SCTP_CONNTRACK_COOKIE_WAIT]\t\t= \"COOKIE_WAIT\",\n\t[SCTP_CONNTRACK_COOKIE_ECHOED]\t\t= \"COOKIE_ECHOED\",\n\t[SCTP_CONNTRACK_ESTABLISHED]\t\t= \"ESTABLISHED\",\n\t[SCTP_CONNTRACK_SHUTDOWN_SENT]\t\t= \"SHUTDOWN_SENT\",\n\t[SCTP_CONNTRACK_SHUTDOWN_RECD]\t\t= \"SHUTDOWN_RECD\",\n\t[SCTP_CONNTRACK_SHUTDOWN_ACK_SENT]\t= \"SHUTDOWN_ACK_SENT\",\n\t[SCTP_CONNTRACK_HEARTBEAT_SENT]\t\t= \"HEARTBEAT_SENT\",\n};\n\n#define SECS  * HZ\n#define MINS  * 60 SECS\n#define HOURS * 60 MINS\n#define DAYS  * 24 HOURS\n\nstatic const unsigned int sctp_timeouts[SCTP_CONNTRACK_MAX] = {\n\t[SCTP_CONNTRACK_CLOSED]\t\t\t= 10 SECS,\n\t[SCTP_CONNTRACK_COOKIE_WAIT]\t\t= 3 SECS,\n\t[SCTP_CONNTRACK_COOKIE_ECHOED]\t\t= 3 SECS,\n\t[SCTP_CONNTRACK_ESTABLISHED]\t\t= 210 SECS,\n\t[SCTP_CONNTRACK_SHUTDOWN_SENT]\t\t= 3 SECS,\n\t[SCTP_CONNTRACK_SHUTDOWN_RECD]\t\t= 3 SECS,\n\t[SCTP_CONNTRACK_SHUTDOWN_ACK_SENT]\t= 3 SECS,\n\t[SCTP_CONNTRACK_HEARTBEAT_SENT]\t\t= 30 SECS,\n};\n\n#define\tSCTP_FLAG_HEARTBEAT_VTAG_FAILED\t1\n\n#define sNO SCTP_CONNTRACK_NONE\n#define\tsCL SCTP_CONNTRACK_CLOSED\n#define\tsCW SCTP_CONNTRACK_COOKIE_WAIT\n#define\tsCE SCTP_CONNTRACK_COOKIE_ECHOED\n#define\tsES SCTP_CONNTRACK_ESTABLISHED\n#define\tsSS SCTP_CONNTRACK_SHUTDOWN_SENT\n#define\tsSR SCTP_CONNTRACK_SHUTDOWN_RECD\n#define\tsSA SCTP_CONNTRACK_SHUTDOWN_ACK_SENT\n#define\tsHS SCTP_CONNTRACK_HEARTBEAT_SENT\n#define\tsIV SCTP_CONNTRACK_MAX\n\n \n\n \n\n \nstatic const u8 sctp_conntracks[2][11][SCTP_CONNTRACK_MAX] = {\n\t{\n \n \n  {sCL, sCL, sCW, sCE, sES, sCL, sCL, sSA, sCW},\n  {sCL, sCL, sCW, sCE, sES, sSS, sSR, sSA, sCL},\n  {sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL},\n  {sCL, sCL, sCW, sCE, sSS, sSS, sSR, sSA, sCL},\n  {sSA, sCL, sCW, sCE, sES, sSA, sSA, sSA, sSA},\n  {sCL, sCL, sCW, sCE, sES, sSS, sSR, sSA, sCL}, \n  {sCL, sCL, sCE, sCE, sES, sSS, sSR, sSA, sCL}, \n  {sCL, sCL, sCW, sES, sES, sSS, sSR, sSA, sCL}, \n  {sCL, sCL, sCW, sCE, sES, sSS, sSR, sCL, sCL},\n  {sHS, sCL, sCW, sCE, sES, sSS, sSR, sSA, sHS},\n  {sCL, sCL, sCW, sCE, sES, sSS, sSR, sSA, sHS},\n\t},\n\t{\n \n \n  {sIV, sCL, sCW, sCE, sES, sSS, sSR, sSA, sIV}, \n  {sIV, sCW, sCW, sCE, sES, sSS, sSR, sSA, sIV},\n  {sIV, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sIV},\n  {sIV, sCL, sCW, sCE, sSR, sSS, sSR, sSA, sIV},\n  {sIV, sCL, sCW, sCE, sES, sSA, sSA, sSA, sIV},\n  {sIV, sCL, sCW, sCL, sES, sSS, sSR, sSA, sIV},\n  {sIV, sCL, sCE, sCE, sES, sSS, sSR, sSA, sIV}, \n  {sIV, sCL, sCW, sES, sES, sSS, sSR, sSA, sIV},\n  {sIV, sCL, sCW, sCE, sES, sSS, sSR, sCL, sIV},\n  {sIV, sCL, sCW, sCE, sES, sSS, sSR, sSA, sHS},\n  {sIV, sCL, sCW, sCE, sES, sSS, sSR, sSA, sES},\n\t}\n};\n\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\n \nstatic void sctp_print_conntrack(struct seq_file *s, struct nf_conn *ct)\n{\n\tseq_printf(s, \"%s \", sctp_conntrack_names[ct->proto.sctp.state]);\n}\n#endif\n\n \n#define for_each_sctp_chunk(skb, sch, _sch, offset, dataoff, count)\t\\\nfor ((offset) = (dataoff) + sizeof(struct sctphdr), (count) = 0;\t\\\n\t(offset) < (skb)->len &&\t\t\t\t\t\\\n\t((sch) = skb_header_pointer((skb), (offset), sizeof(_sch), &(_sch)));\t\\\n\t(offset) += (ntohs((sch)->length) + 3) & ~3, (count)++)\n\n \nstatic int do_basic_checks(struct nf_conn *ct,\n\t\t\t   const struct sk_buff *skb,\n\t\t\t   unsigned int dataoff,\n\t\t\t   unsigned long *map,\n\t\t\t   const struct nf_hook_state *state)\n{\n\tu_int32_t offset, count;\n\tstruct sctp_chunkhdr _sch, *sch;\n\tint flag;\n\n\tflag = 0;\n\n\tfor_each_sctp_chunk (skb, sch, _sch, offset, dataoff, count) {\n\t\tif (sch->type == SCTP_CID_INIT ||\n\t\t    sch->type == SCTP_CID_INIT_ACK ||\n\t\t    sch->type == SCTP_CID_SHUTDOWN_COMPLETE)\n\t\t\tflag = 1;\n\n\t\t \n\t\tif (((sch->type == SCTP_CID_COOKIE_ACK ||\n\t\t      sch->type == SCTP_CID_COOKIE_ECHO ||\n\t\t      flag) &&\n\t\t     count != 0) || !sch->length) {\n\t\t\tnf_ct_l4proto_log_invalid(skb, ct, state,\n\t\t\t\t\t\t  \"%s failed. chunk num %d, type %d, len %d flag %d\\n\",\n\t\t\t\t\t\t  __func__, count, sch->type, sch->length, flag);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (map)\n\t\t\tset_bit(sch->type, map);\n\t}\n\n\treturn count == 0;\n}\n\nstatic int sctp_new_state(enum ip_conntrack_dir dir,\n\t\t\t  enum sctp_conntrack cur_state,\n\t\t\t  int chunk_type)\n{\n\tint i;\n\n\tswitch (chunk_type) {\n\tcase SCTP_CID_INIT:\n\t\ti = 0;\n\t\tbreak;\n\tcase SCTP_CID_INIT_ACK:\n\t\ti = 1;\n\t\tbreak;\n\tcase SCTP_CID_ABORT:\n\t\ti = 2;\n\t\tbreak;\n\tcase SCTP_CID_SHUTDOWN:\n\t\ti = 3;\n\t\tbreak;\n\tcase SCTP_CID_SHUTDOWN_ACK:\n\t\ti = 4;\n\t\tbreak;\n\tcase SCTP_CID_ERROR:\n\t\ti = 5;\n\t\tbreak;\n\tcase SCTP_CID_COOKIE_ECHO:\n\t\ti = 6;\n\t\tbreak;\n\tcase SCTP_CID_COOKIE_ACK:\n\t\ti = 7;\n\t\tbreak;\n\tcase SCTP_CID_SHUTDOWN_COMPLETE:\n\t\ti = 8;\n\t\tbreak;\n\tcase SCTP_CID_HEARTBEAT:\n\t\ti = 9;\n\t\tbreak;\n\tcase SCTP_CID_HEARTBEAT_ACK:\n\t\ti = 10;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tpr_debug(\"Unknown chunk type %d, Will stay in %s\\n\",\n\t\t\t chunk_type, sctp_conntrack_names[cur_state]);\n\t\treturn cur_state;\n\t}\n\n\treturn sctp_conntracks[dir][i][cur_state];\n}\n\n \nstatic noinline bool\nsctp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t const struct sctphdr *sh, unsigned int dataoff)\n{\n\tenum sctp_conntrack new_state;\n\tconst struct sctp_chunkhdr *sch;\n\tstruct sctp_chunkhdr _sch;\n\tu32 offset, count;\n\n\tmemset(&ct->proto.sctp, 0, sizeof(ct->proto.sctp));\n\tnew_state = SCTP_CONNTRACK_MAX;\n\tfor_each_sctp_chunk(skb, sch, _sch, offset, dataoff, count) {\n\t\tnew_state = sctp_new_state(IP_CT_DIR_ORIGINAL,\n\t\t\t\t\t   SCTP_CONNTRACK_NONE, sch->type);\n\n\t\t \n\t\tif (new_state == SCTP_CONNTRACK_NONE ||\n\t\t    new_state == SCTP_CONNTRACK_MAX) {\n\t\t\tpr_debug(\"nf_conntrack_sctp: invalid new deleting.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tif (sch->type == SCTP_CID_INIT) {\n\t\t\tstruct sctp_inithdr _inithdr, *ih;\n\t\t\t \n\t\t\tif (sh->vtag)\n\t\t\t\treturn false;\n\n\t\t\tih = skb_header_pointer(skb, offset + sizeof(_sch),\n\t\t\t\t\t\tsizeof(_inithdr), &_inithdr);\n\t\t\tif (!ih)\n\t\t\t\treturn false;\n\n\t\t\tpr_debug(\"Setting vtag %x for new conn\\n\",\n\t\t\t\t ih->init_tag);\n\n\t\t\tct->proto.sctp.vtag[IP_CT_DIR_REPLY] = ih->init_tag;\n\t\t} else if (sch->type == SCTP_CID_HEARTBEAT) {\n\t\t\tpr_debug(\"Setting vtag %x for secondary conntrack\\n\",\n\t\t\t\t sh->vtag);\n\t\t\tct->proto.sctp.vtag[IP_CT_DIR_ORIGINAL] = sh->vtag;\n\t\t} else {\n\t\t \n\t\t\tpr_debug(\"Setting vtag %x for new conn OOTB\\n\",\n\t\t\t\t sh->vtag);\n\t\t\tct->proto.sctp.vtag[IP_CT_DIR_REPLY] = sh->vtag;\n\t\t}\n\n\t\tct->proto.sctp.state = SCTP_CONNTRACK_NONE;\n\t}\n\n\treturn true;\n}\n\nstatic bool sctp_error(struct sk_buff *skb,\n\t\t       unsigned int dataoff,\n\t\t       const struct nf_hook_state *state)\n{\n\tconst struct sctphdr *sh;\n\tconst char *logmsg;\n\n\tif (skb->len < dataoff + sizeof(struct sctphdr)) {\n\t\tlogmsg = \"nf_ct_sctp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\tif (state->hook == NF_INET_PRE_ROUTING &&\n\t    state->net->ct.sysctl_checksum &&\n\t    skb->ip_summed == CHECKSUM_NONE) {\n\t\tif (skb_ensure_writable(skb, dataoff + sizeof(*sh))) {\n\t\t\tlogmsg = \"nf_ct_sctp: failed to read header \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tsh = (const struct sctphdr *)(skb->data + dataoff);\n\t\tif (sh->checksum != sctp_compute_cksum(skb, dataoff)) {\n\t\t\tlogmsg = \"nf_ct_sctp: bad CRC \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\treturn false;\nout_invalid:\n\tnf_l4proto_log_invalid(skb, state, IPPROTO_SCTP, \"%s\", logmsg);\n\treturn true;\n}\n\n \nint nf_conntrack_sctp_packet(struct nf_conn *ct,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     unsigned int dataoff,\n\t\t\t     enum ip_conntrack_info ctinfo,\n\t\t\t     const struct nf_hook_state *state)\n{\n\tenum sctp_conntrack new_state, old_state;\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tconst struct sctphdr *sh;\n\tstruct sctphdr _sctph;\n\tconst struct sctp_chunkhdr *sch;\n\tstruct sctp_chunkhdr _sch;\n\tu_int32_t offset, count;\n\tunsigned int *timeouts;\n\tunsigned long map[256 / sizeof(unsigned long)] = { 0 };\n\tbool ignore = false;\n\n\tif (sctp_error(skb, dataoff, state))\n\t\treturn -NF_ACCEPT;\n\n\tsh = skb_header_pointer(skb, dataoff, sizeof(_sctph), &_sctph);\n\tif (sh == NULL)\n\t\tgoto out;\n\n\tif (do_basic_checks(ct, skb, dataoff, map, state) != 0)\n\t\tgoto out;\n\n\tif (!nf_ct_is_confirmed(ct)) {\n\t\t \n\t\tif (test_bit(SCTP_CID_ABORT, map) ||\n\t\t    test_bit(SCTP_CID_SHUTDOWN_COMPLETE, map) ||\n\t\t    test_bit(SCTP_CID_COOKIE_ACK, map))\n\t\t\treturn -NF_ACCEPT;\n\n\t\tif (!sctp_new(ct, skb, sh, dataoff))\n\t\t\treturn -NF_ACCEPT;\n\t}\n\n\t \n\tif (!test_bit(SCTP_CID_INIT, map) &&\n\t    !test_bit(SCTP_CID_SHUTDOWN_COMPLETE, map) &&\n\t    !test_bit(SCTP_CID_COOKIE_ECHO, map) &&\n\t    !test_bit(SCTP_CID_ABORT, map) &&\n\t    !test_bit(SCTP_CID_SHUTDOWN_ACK, map) &&\n\t    !test_bit(SCTP_CID_HEARTBEAT, map) &&\n\t    !test_bit(SCTP_CID_HEARTBEAT_ACK, map) &&\n\t    sh->vtag != ct->proto.sctp.vtag[dir]) {\n\t\tnf_ct_l4proto_log_invalid(skb, ct, state,\n\t\t\t\t\t  \"verification tag check failed %x vs %x for dir %d\",\n\t\t\t\t\t  sh->vtag, ct->proto.sctp.vtag[dir], dir);\n\t\tgoto out;\n\t}\n\n\told_state = new_state = SCTP_CONNTRACK_NONE;\n\tspin_lock_bh(&ct->lock);\n\tfor_each_sctp_chunk (skb, sch, _sch, offset, dataoff, count) {\n\t\t \n\t\tif (sch->type == SCTP_CID_INIT) {\n\t\t\t \n\t\t\tif (sh->vtag != 0)\n\t\t\t\tgoto out_unlock;\n\t\t} else if (sch->type == SCTP_CID_ABORT) {\n\t\t\t \n\t\t\tif ((!(sch->flags & SCTP_CHUNK_FLAG_T) &&\n\t\t\t     sh->vtag != ct->proto.sctp.vtag[dir]) ||\n\t\t\t    ((sch->flags & SCTP_CHUNK_FLAG_T) &&\n\t\t\t     sh->vtag != ct->proto.sctp.vtag[!dir]))\n\t\t\t\tgoto out_unlock;\n\t\t} else if (sch->type == SCTP_CID_SHUTDOWN_COMPLETE) {\n\t\t\t \n\t\t\tif ((!(sch->flags & SCTP_CHUNK_FLAG_T) &&\n\t\t\t     sh->vtag != ct->proto.sctp.vtag[dir]) ||\n\t\t\t    ((sch->flags & SCTP_CHUNK_FLAG_T) &&\n\t\t\t     sh->vtag != ct->proto.sctp.vtag[!dir]))\n\t\t\t\tgoto out_unlock;\n\t\t} else if (sch->type == SCTP_CID_COOKIE_ECHO) {\n\t\t\t \n\t\t\tif (sh->vtag != ct->proto.sctp.vtag[dir])\n\t\t\t\tgoto out_unlock;\n\t\t} else if (sch->type == SCTP_CID_COOKIE_ACK) {\n\t\t\tct->proto.sctp.init[dir] = 0;\n\t\t\tct->proto.sctp.init[!dir] = 0;\n\t\t} else if (sch->type == SCTP_CID_HEARTBEAT) {\n\t\t\tif (ct->proto.sctp.vtag[dir] == 0) {\n\t\t\t\tpr_debug(\"Setting %d vtag %x for dir %d\\n\", sch->type, sh->vtag, dir);\n\t\t\t\tct->proto.sctp.vtag[dir] = sh->vtag;\n\t\t\t} else if (sh->vtag != ct->proto.sctp.vtag[dir]) {\n\t\t\t\tif (test_bit(SCTP_CID_DATA, map) || ignore)\n\t\t\t\t\tgoto out_unlock;\n\n\t\t\t\tct->proto.sctp.flags |= SCTP_FLAG_HEARTBEAT_VTAG_FAILED;\n\t\t\t\tct->proto.sctp.last_dir = dir;\n\t\t\t\tignore = true;\n\t\t\t\tcontinue;\n\t\t\t} else if (ct->proto.sctp.flags & SCTP_FLAG_HEARTBEAT_VTAG_FAILED) {\n\t\t\t\tct->proto.sctp.flags &= ~SCTP_FLAG_HEARTBEAT_VTAG_FAILED;\n\t\t\t}\n\t\t} else if (sch->type == SCTP_CID_HEARTBEAT_ACK) {\n\t\t\tif (ct->proto.sctp.vtag[dir] == 0) {\n\t\t\t\tpr_debug(\"Setting vtag %x for dir %d\\n\",\n\t\t\t\t\t sh->vtag, dir);\n\t\t\t\tct->proto.sctp.vtag[dir] = sh->vtag;\n\t\t\t} else if (sh->vtag != ct->proto.sctp.vtag[dir]) {\n\t\t\t\tif (test_bit(SCTP_CID_DATA, map) || ignore)\n\t\t\t\t\tgoto out_unlock;\n\n\t\t\t\tif ((ct->proto.sctp.flags & SCTP_FLAG_HEARTBEAT_VTAG_FAILED) == 0 ||\n\t\t\t\t    ct->proto.sctp.last_dir == dir)\n\t\t\t\t\tgoto out_unlock;\n\n\t\t\t\tct->proto.sctp.flags &= ~SCTP_FLAG_HEARTBEAT_VTAG_FAILED;\n\t\t\t\tct->proto.sctp.vtag[dir] = sh->vtag;\n\t\t\t\tct->proto.sctp.vtag[!dir] = 0;\n\t\t\t} else if (ct->proto.sctp.flags & SCTP_FLAG_HEARTBEAT_VTAG_FAILED) {\n\t\t\t\tct->proto.sctp.flags &= ~SCTP_FLAG_HEARTBEAT_VTAG_FAILED;\n\t\t\t}\n\t\t}\n\n\t\told_state = ct->proto.sctp.state;\n\t\tnew_state = sctp_new_state(dir, old_state, sch->type);\n\n\t\t \n\t\tif (new_state == SCTP_CONNTRACK_MAX) {\n\t\t\tnf_ct_l4proto_log_invalid(skb, ct, state,\n\t\t\t\t\t\t  \"Invalid, old_state %d, dir %d, type %d\",\n\t\t\t\t\t\t  old_state, dir, sch->type);\n\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (sch->type == SCTP_CID_INIT) {\n\t\t\tstruct sctp_inithdr _ih, *ih;\n\n\t\t\tih = skb_header_pointer(skb, offset + sizeof(_sch), sizeof(*ih), &_ih);\n\t\t\tif (!ih)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tif (ct->proto.sctp.init[dir] && ct->proto.sctp.init[!dir])\n\t\t\t\tct->proto.sctp.init[!dir] = 0;\n\t\t\tct->proto.sctp.init[dir] = 1;\n\n\t\t\tpr_debug(\"Setting vtag %x for dir %d\\n\", ih->init_tag, !dir);\n\t\t\tct->proto.sctp.vtag[!dir] = ih->init_tag;\n\n\t\t\t \n\t\t\tif (new_state == SCTP_CONNTRACK_CLOSED &&\n\t\t\t    old_state == SCTP_CONNTRACK_CLOSED &&\n\t\t\t    nf_ct_is_confirmed(ct))\n\t\t\t\tignore = true;\n\t\t} else if (sch->type == SCTP_CID_INIT_ACK) {\n\t\t\tstruct sctp_inithdr _ih, *ih;\n\t\t\t__be32 vtag;\n\n\t\t\tih = skb_header_pointer(skb, offset + sizeof(_sch), sizeof(*ih), &_ih);\n\t\t\tif (!ih)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tvtag = ct->proto.sctp.vtag[!dir];\n\t\t\tif (!ct->proto.sctp.init[!dir] && vtag && vtag != ih->init_tag)\n\t\t\t\tgoto out_unlock;\n\t\t\t \n\t\t\tif (ct->proto.sctp.init[dir] && ct->proto.sctp.init[!dir] &&\n\t\t\t    vtag != ih->init_tag)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tpr_debug(\"Setting vtag %x for dir %d\\n\", ih->init_tag, !dir);\n\t\t\tct->proto.sctp.vtag[!dir] = ih->init_tag;\n\t\t}\n\n\t\tct->proto.sctp.state = new_state;\n\t\tif (old_state != new_state) {\n\t\t\tnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\n\t\t\tif (new_state == SCTP_CONNTRACK_ESTABLISHED &&\n\t\t\t    !test_and_set_bit(IPS_ASSURED_BIT, &ct->status))\n\t\t\t\tnf_conntrack_event_cache(IPCT_ASSURED, ct);\n\t\t}\n\t}\n\tspin_unlock_bh(&ct->lock);\n\n\t \n\tif (ignore)\n\t\treturn NF_ACCEPT;\n\n\ttimeouts = nf_ct_timeout_lookup(ct);\n\tif (!timeouts)\n\t\ttimeouts = nf_sctp_pernet(nf_ct_net(ct))->timeouts;\n\n\tnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);\n\n\treturn NF_ACCEPT;\n\nout_unlock:\n\tspin_unlock_bh(&ct->lock);\nout:\n\treturn -NF_ACCEPT;\n}\n\nstatic bool sctp_can_early_drop(const struct nf_conn *ct)\n{\n\tswitch (ct->proto.sctp.state) {\n\tcase SCTP_CONNTRACK_SHUTDOWN_SENT:\n\tcase SCTP_CONNTRACK_SHUTDOWN_RECD:\n\tcase SCTP_CONNTRACK_SHUTDOWN_ACK_SENT:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_conntrack.h>\n\nstatic int sctp_to_nlattr(struct sk_buff *skb, struct nlattr *nla,\n\t\t\t  struct nf_conn *ct, bool destroy)\n{\n\tstruct nlattr *nest_parms;\n\n\tspin_lock_bh(&ct->lock);\n\tnest_parms = nla_nest_start(skb, CTA_PROTOINFO_SCTP);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, CTA_PROTOINFO_SCTP_STATE, ct->proto.sctp.state))\n\t\tgoto nla_put_failure;\n\n\tif (destroy)\n\t\tgoto skip_state;\n\n\tif (nla_put_be32(skb, CTA_PROTOINFO_SCTP_VTAG_ORIGINAL,\n\t\t\t ct->proto.sctp.vtag[IP_CT_DIR_ORIGINAL]) ||\n\t    nla_put_be32(skb, CTA_PROTOINFO_SCTP_VTAG_REPLY,\n\t\t\t ct->proto.sctp.vtag[IP_CT_DIR_REPLY]))\n\t\tgoto nla_put_failure;\n\nskip_state:\n\tspin_unlock_bh(&ct->lock);\n\tnla_nest_end(skb, nest_parms);\n\n\treturn 0;\n\nnla_put_failure:\n\tspin_unlock_bh(&ct->lock);\n\treturn -1;\n}\n\nstatic const struct nla_policy sctp_nla_policy[CTA_PROTOINFO_SCTP_MAX+1] = {\n\t[CTA_PROTOINFO_SCTP_STATE]\t    = { .type = NLA_U8 },\n\t[CTA_PROTOINFO_SCTP_VTAG_ORIGINAL]  = { .type = NLA_U32 },\n\t[CTA_PROTOINFO_SCTP_VTAG_REPLY]     = { .type = NLA_U32 },\n};\n\n#define SCTP_NLATTR_SIZE ( \\\n\t\tNLA_ALIGN(NLA_HDRLEN + 1) + \\\n\t\tNLA_ALIGN(NLA_HDRLEN + 4) + \\\n\t\tNLA_ALIGN(NLA_HDRLEN + 4))\n\nstatic int nlattr_to_sctp(struct nlattr *cda[], struct nf_conn *ct)\n{\n\tstruct nlattr *attr = cda[CTA_PROTOINFO_SCTP];\n\tstruct nlattr *tb[CTA_PROTOINFO_SCTP_MAX+1];\n\tint err;\n\n\t \n\tif (!attr)\n\t\treturn 0;\n\n\terr = nla_parse_nested_deprecated(tb, CTA_PROTOINFO_SCTP_MAX, attr,\n\t\t\t\t\t  sctp_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[CTA_PROTOINFO_SCTP_STATE] ||\n\t    !tb[CTA_PROTOINFO_SCTP_VTAG_ORIGINAL] ||\n\t    !tb[CTA_PROTOINFO_SCTP_VTAG_REPLY])\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&ct->lock);\n\tct->proto.sctp.state = nla_get_u8(tb[CTA_PROTOINFO_SCTP_STATE]);\n\tct->proto.sctp.vtag[IP_CT_DIR_ORIGINAL] =\n\t\tnla_get_be32(tb[CTA_PROTOINFO_SCTP_VTAG_ORIGINAL]);\n\tct->proto.sctp.vtag[IP_CT_DIR_REPLY] =\n\t\tnla_get_be32(tb[CTA_PROTOINFO_SCTP_VTAG_REPLY]);\n\tspin_unlock_bh(&ct->lock);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_cttimeout.h>\n\nstatic int sctp_timeout_nlattr_to_obj(struct nlattr *tb[],\n\t\t\t\t      struct net *net, void *data)\n{\n\tunsigned int *timeouts = data;\n\tstruct nf_sctp_net *sn = nf_sctp_pernet(net);\n\tint i;\n\n\tif (!timeouts)\n\t\ttimeouts = sn->timeouts;\n\n\t \n\tfor (i=0; i<SCTP_CONNTRACK_MAX; i++)\n\t\ttimeouts[i] = sn->timeouts[i];\n\n\t \n\tfor (i=CTA_TIMEOUT_SCTP_UNSPEC+1; i<CTA_TIMEOUT_SCTP_MAX+1; i++) {\n\t\tif (tb[i]) {\n\t\t\ttimeouts[i] = ntohl(nla_get_be32(tb[i])) * HZ;\n\t\t}\n\t}\n\n\ttimeouts[CTA_TIMEOUT_SCTP_UNSPEC] = timeouts[CTA_TIMEOUT_SCTP_CLOSED];\n\treturn 0;\n}\n\nstatic int\nsctp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\n{\n        const unsigned int *timeouts = data;\n\tint i;\n\n\tfor (i=CTA_TIMEOUT_SCTP_UNSPEC+1; i<CTA_TIMEOUT_SCTP_MAX+1; i++) {\n\t        if (nla_put_be32(skb, i, htonl(timeouts[i] / HZ)))\n\t\t\tgoto nla_put_failure;\n\t}\n        return 0;\n\nnla_put_failure:\n        return -ENOSPC;\n}\n\nstatic const struct nla_policy\nsctp_timeout_nla_policy[CTA_TIMEOUT_SCTP_MAX+1] = {\n\t[CTA_TIMEOUT_SCTP_CLOSED]\t\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_SCTP_COOKIE_WAIT]\t\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_SCTP_COOKIE_ECHOED]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_SCTP_ESTABLISHED]\t\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_SCTP_SHUTDOWN_SENT]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_SCTP_SHUTDOWN_RECD]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_SCTP_SHUTDOWN_ACK_SENT]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_SCTP_HEARTBEAT_SENT]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_SCTP_HEARTBEAT_ACKED]\t= { .type = NLA_U32 },\n};\n#endif  \n\nvoid nf_conntrack_sctp_init_net(struct net *net)\n{\n\tstruct nf_sctp_net *sn = nf_sctp_pernet(net);\n\tint i;\n\n\tfor (i = 0; i < SCTP_CONNTRACK_MAX; i++)\n\t\tsn->timeouts[i] = sctp_timeouts[i];\n\n\t \n\tsn->timeouts[0] = sctp_timeouts[SCTP_CONNTRACK_CLOSED];\n}\n\nconst struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp = {\n\t.l4proto \t\t= IPPROTO_SCTP,\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\n\t.print_conntrack\t= sctp_print_conntrack,\n#endif\n\t.can_early_drop\t\t= sctp_can_early_drop,\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.nlattr_size\t\t= SCTP_NLATTR_SIZE,\n\t.to_nlattr\t\t= sctp_to_nlattr,\n\t.from_nlattr\t\t= nlattr_to_sctp,\n\t.tuple_to_nlattr\t= nf_ct_port_tuple_to_nlattr,\n\t.nlattr_tuple_size\t= nf_ct_port_nlattr_tuple_size,\n\t.nlattr_to_tuple\t= nf_ct_port_nlattr_to_tuple,\n\t.nla_policy\t\t= nf_ct_port_nla_policy,\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\t.ctnl_timeout\t\t= {\n\t\t.nlattr_to_obj\t= sctp_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= sctp_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_SCTP_MAX,\n\t\t.obj_size\t= sizeof(unsigned int) * SCTP_CONNTRACK_MAX,\n\t\t.nla_policy\t= sctp_timeout_nla_policy,\n\t},\n#endif  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}