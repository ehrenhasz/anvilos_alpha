{
  "module_name": "utils.c",
  "hash_id": "050c50d0b21ccca273b559cb8b8d8ff01cd069076c96121a4915d3b2c4b338e8",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/utils.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <net/netfilter/nf_queue.h>\n#include <net/ip6_checksum.h>\n\n#ifdef CONFIG_INET\n__sum16 nf_ip_checksum(struct sk_buff *skb, unsigned int hook,\n\t\t       unsigned int dataoff, u8 protocol)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\t__sum16 csum = 0;\n\n\tswitch (skb->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (hook != NF_INET_PRE_ROUTING && hook != NF_INET_LOCAL_IN)\n\t\t\tbreak;\n\t\tif ((protocol != IPPROTO_TCP && protocol != IPPROTO_UDP &&\n\t\t    !csum_fold(skb->csum)) ||\n\t\t    !csum_tcpudp_magic(iph->saddr, iph->daddr,\n\t\t\t\t       skb->len - dataoff, protocol,\n\t\t\t\t       skb->csum)) {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase CHECKSUM_NONE:\n\t\tif (protocol != IPPROTO_TCP && protocol != IPPROTO_UDP)\n\t\t\tskb->csum = 0;\n\t\telse\n\t\t\tskb->csum = csum_tcpudp_nofold(iph->saddr, iph->daddr,\n\t\t\t\t\t\t       skb->len - dataoff,\n\t\t\t\t\t\t       protocol, 0);\n\t\tcsum = __skb_checksum_complete(skb);\n\t}\n\treturn csum;\n}\nEXPORT_SYMBOL(nf_ip_checksum);\n#endif\n\nstatic __sum16 nf_ip_checksum_partial(struct sk_buff *skb, unsigned int hook,\n\t\t\t\t      unsigned int dataoff, unsigned int len,\n\t\t\t\t      u8 protocol)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\t__sum16 csum = 0;\n\n\tswitch (skb->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (len == skb->len - dataoff)\n\t\t\treturn nf_ip_checksum(skb, hook, dataoff, protocol);\n\t\tfallthrough;\n\tcase CHECKSUM_NONE:\n\t\tskb->csum = csum_tcpudp_nofold(iph->saddr, iph->daddr, protocol,\n\t\t\t\t\t       skb->len - dataoff, 0);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\treturn __skb_checksum_complete_head(skb, dataoff + len);\n\t}\n\treturn csum;\n}\n\n__sum16 nf_ip6_checksum(struct sk_buff *skb, unsigned int hook,\n\t\t\tunsigned int dataoff, u8 protocol)\n{\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t__sum16 csum = 0;\n\n\tswitch (skb->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (hook != NF_INET_PRE_ROUTING && hook != NF_INET_LOCAL_IN)\n\t\t\tbreak;\n\t\tif (!csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\n\t\t\t\t     skb->len - dataoff, protocol,\n\t\t\t\t     csum_sub(skb->csum,\n\t\t\t\t\t      skb_checksum(skb, 0,\n\t\t\t\t\t\t\t   dataoff, 0)))) {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase CHECKSUM_NONE:\n\t\tskb->csum = ~csum_unfold(\n\t\t\t\tcsum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\n\t\t\t\t\t     skb->len - dataoff,\n\t\t\t\t\t     protocol,\n\t\t\t\t\t     csum_sub(0,\n\t\t\t\t\t\t      skb_checksum(skb, 0,\n\t\t\t\t\t\t\t\t   dataoff, 0))));\n\t\tcsum = __skb_checksum_complete(skb);\n\t}\n\treturn csum;\n}\nEXPORT_SYMBOL(nf_ip6_checksum);\n\nstatic __sum16 nf_ip6_checksum_partial(struct sk_buff *skb, unsigned int hook,\n\t\t\t\t       unsigned int dataoff, unsigned int len,\n\t\t\t\t       u8 protocol)\n{\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t__wsum hsum;\n\t__sum16 csum = 0;\n\n\tswitch (skb->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (len == skb->len - dataoff)\n\t\t\treturn nf_ip6_checksum(skb, hook, dataoff, protocol);\n\t\tfallthrough;\n\tcase CHECKSUM_NONE:\n\t\thsum = skb_checksum(skb, 0, dataoff, 0);\n\t\tskb->csum = ~csum_unfold(csum_ipv6_magic(&ip6h->saddr,\n\t\t\t\t\t\t\t &ip6h->daddr,\n\t\t\t\t\t\t\t skb->len - dataoff,\n\t\t\t\t\t\t\t protocol,\n\t\t\t\t\t\t\t csum_sub(0, hsum)));\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\treturn __skb_checksum_complete_head(skb, dataoff + len);\n\t}\n\treturn csum;\n};\n\n__sum16 nf_checksum(struct sk_buff *skb, unsigned int hook,\n\t\t    unsigned int dataoff, u8 protocol,\n\t\t    unsigned short family)\n{\n\t__sum16 csum = 0;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tcsum = nf_ip_checksum(skb, hook, dataoff, protocol);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tcsum = nf_ip6_checksum(skb, hook, dataoff, protocol);\n\t\tbreak;\n\t}\n\n\treturn csum;\n}\nEXPORT_SYMBOL_GPL(nf_checksum);\n\n__sum16 nf_checksum_partial(struct sk_buff *skb, unsigned int hook,\n\t\t\t    unsigned int dataoff, unsigned int len,\n\t\t\t    u8 protocol, unsigned short family)\n{\n\t__sum16 csum = 0;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tcsum = nf_ip_checksum_partial(skb, hook, dataoff, len,\n\t\t\t\t\t      protocol);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tcsum = nf_ip6_checksum_partial(skb, hook, dataoff, len,\n\t\t\t\t\t       protocol);\n\t\tbreak;\n\t}\n\n\treturn csum;\n}\nEXPORT_SYMBOL_GPL(nf_checksum_partial);\n\nint nf_route(struct net *net, struct dst_entry **dst, struct flowi *fl,\n\t     bool strict, unsigned short family)\n{\n\tconst struct nf_ipv6_ops *v6ops __maybe_unused;\n\tint ret = 0;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tret = nf_ip_route(net, dst, fl, strict);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tret = nf_ip6_route(net, dst, fl, strict);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nf_route);\n\nstatic int nf_ip_reroute(struct sk_buff *skb, const struct nf_queue_entry *entry)\n{\n#ifdef CONFIG_INET\n\tconst struct ip_rt_info *rt_info = nf_queue_entry_reroute(entry);\n\n\tif (entry->state.hook == NF_INET_LOCAL_OUT) {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\n\t\tif (!(iph->tos == rt_info->tos &&\n\t\t      skb->mark == rt_info->mark &&\n\t\t      iph->daddr == rt_info->daddr &&\n\t\t      iph->saddr == rt_info->saddr))\n\t\t\treturn ip_route_me_harder(entry->state.net, entry->state.sk,\n\t\t\t\t\t\t  skb, RTN_UNSPEC);\n\t}\n#endif\n\treturn 0;\n}\n\nint nf_reroute(struct sk_buff *skb, struct nf_queue_entry *entry)\n{\n\tconst struct nf_ipv6_ops *v6ops;\n\tint ret = 0;\n\n\tswitch (entry->state.pf) {\n\tcase AF_INET:\n\t\tret = nf_ip_reroute(skb, entry);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tv6ops = rcu_dereference(nf_ipv6_ops);\n\t\tif (v6ops)\n\t\t\tret = v6ops->reroute(skb, entry);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nint nf_ip6_check_hbh_len(struct sk_buff *skb, u32 *plen)\n{\n\tint len, off = sizeof(struct ipv6hdr);\n\tunsigned char *nh;\n\n\tif (!pskb_may_pull(skb, off + 8))\n\t\treturn -ENOMEM;\n\tnh = (unsigned char *)(ipv6_hdr(skb) + 1);\n\tlen = (nh[1] + 1) << 3;\n\n\tif (!pskb_may_pull(skb, off + len))\n\t\treturn -ENOMEM;\n\tnh = skb_network_header(skb);\n\n\toff += 2;\n\tlen -= 2;\n\twhile (len > 0) {\n\t\tint optlen;\n\n\t\tif (nh[off] == IPV6_TLV_PAD1) {\n\t\t\toff++;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len < 2)\n\t\t\treturn -EBADMSG;\n\t\toptlen = nh[off + 1] + 2;\n\t\tif (optlen > len)\n\t\t\treturn -EBADMSG;\n\n\t\tif (nh[off] == IPV6_TLV_JUMBO) {\n\t\t\tu32 pkt_len;\n\n\t\t\tif (nh[off + 1] != 4 || (off & 3) != 2)\n\t\t\t\treturn -EBADMSG;\n\t\t\tpkt_len = ntohl(*(__be32 *)(nh + off + 2));\n\t\t\tif (pkt_len <= IPV6_MAXPLEN ||\n\t\t\t    ipv6_hdr(skb)->payload_len)\n\t\t\t\treturn -EBADMSG;\n\t\t\tif (pkt_len > skb->len - sizeof(struct ipv6hdr))\n\t\t\t\treturn -EBADMSG;\n\t\t\t*plen = pkt_len;\n\t\t}\n\t\toff += optlen;\n\t\tlen -= optlen;\n\t}\n\n\treturn len ? -EBADMSG : 0;\n}\nEXPORT_SYMBOL_GPL(nf_ip6_check_hbh_len);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}