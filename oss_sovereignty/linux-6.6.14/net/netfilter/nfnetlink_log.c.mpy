{
  "module_name": "nfnetlink_log.c",
  "hash_id": "90fea1686882f5403f8160251d4226ed2fce8ff191a42eb7807042d1bb36f7de",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nfnetlink_log.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_bridge.h>\n#include <net/netlink.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_log.h>\n#include <linux/netfilter/nf_conntrack_common.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/proc_fs.h>\n#include <linux/security.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/netfilter/nf_log.h>\n#include <net/netns/generic.h>\n\n#include <linux/atomic.h>\n#include <linux/refcount.h>\n\n\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n#include \"../bridge/br_private.h\"\n#endif\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <net/netfilter/nf_conntrack.h>\n#endif\n\n#define NFULNL_COPY_DISABLED\t0xff\n#define NFULNL_NLBUFSIZ_DEFAULT\tNLMSG_GOODSIZE\n#define NFULNL_TIMEOUT_DEFAULT \t100\t \n#define NFULNL_QTHRESH_DEFAULT \t100\t \n \n#define NFULNL_COPY_RANGE_MAX\t(0xFFFF - NLA_HDRLEN)\n\n#define PRINTR(x, args...)\tdo { if (net_ratelimit()) \\\n\t\t\t\t     printk(x, ## args); } while (0);\n\nstruct nfulnl_instance {\n\tstruct hlist_node hlist;\t \n\tspinlock_t lock;\n\trefcount_t use;\t\t\t \n\n\tunsigned int qlen;\t\t \n\tstruct sk_buff *skb;\t\t \n\tstruct timer_list timer;\n\tstruct net *net;\n\tnetns_tracker ns_tracker;\n\tstruct user_namespace *peer_user_ns;\t \n\tu32 peer_portid;\t\t \n\n\t \n\tunsigned int flushtimeout;\t \n\tunsigned int nlbufsiz;\t\t \n\tunsigned int qthreshold;\t \n\tu_int32_t copy_range;\n\tu_int32_t seq;\t\t\t \n\tu_int16_t group_num;\t\t \n\tu_int16_t flags;\n\tu_int8_t copy_mode;\n\tstruct rcu_head rcu;\n};\n\n#define INSTANCE_BUCKETS\t16\n\nstatic unsigned int nfnl_log_net_id __read_mostly;\n\nstruct nfnl_log_net {\n\tspinlock_t instances_lock;\n\tstruct hlist_head instance_table[INSTANCE_BUCKETS];\n\tatomic_t global_seq;\n};\n\nstatic struct nfnl_log_net *nfnl_log_pernet(struct net *net)\n{\n\treturn net_generic(net, nfnl_log_net_id);\n}\n\nstatic inline u_int8_t instance_hashfn(u_int16_t group_num)\n{\n\treturn ((group_num & 0xff) % INSTANCE_BUCKETS);\n}\n\nstatic struct nfulnl_instance *\n__instance_lookup(const struct nfnl_log_net *log, u16 group_num)\n{\n\tconst struct hlist_head *head;\n\tstruct nfulnl_instance *inst;\n\n\thead = &log->instance_table[instance_hashfn(group_num)];\n\thlist_for_each_entry_rcu(inst, head, hlist) {\n\t\tif (inst->group_num == group_num)\n\t\t\treturn inst;\n\t}\n\treturn NULL;\n}\n\nstatic inline void\ninstance_get(struct nfulnl_instance *inst)\n{\n\trefcount_inc(&inst->use);\n}\n\nstatic struct nfulnl_instance *\ninstance_lookup_get_rcu(const struct nfnl_log_net *log, u16 group_num)\n{\n\tstruct nfulnl_instance *inst;\n\n\tinst = __instance_lookup(log, group_num);\n\tif (inst && !refcount_inc_not_zero(&inst->use))\n\t\tinst = NULL;\n\n\treturn inst;\n}\n\nstatic struct nfulnl_instance *\ninstance_lookup_get(const struct nfnl_log_net *log, u16 group_num)\n{\n\tstruct nfulnl_instance *inst;\n\n\trcu_read_lock();\n\tinst = instance_lookup_get_rcu(log, group_num);\n\trcu_read_unlock();\n\n\treturn inst;\n}\n\nstatic void nfulnl_instance_free_rcu(struct rcu_head *head)\n{\n\tstruct nfulnl_instance *inst =\n\t\tcontainer_of(head, struct nfulnl_instance, rcu);\n\n\tput_net_track(inst->net, &inst->ns_tracker);\n\tkfree(inst);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic void\ninstance_put(struct nfulnl_instance *inst)\n{\n\tif (inst && refcount_dec_and_test(&inst->use))\n\t\tcall_rcu(&inst->rcu, nfulnl_instance_free_rcu);\n}\n\nstatic void nfulnl_timer(struct timer_list *t);\n\nstatic struct nfulnl_instance *\ninstance_create(struct net *net, u_int16_t group_num,\n\t\tu32 portid, struct user_namespace *user_ns)\n{\n\tstruct nfulnl_instance *inst;\n\tstruct nfnl_log_net *log = nfnl_log_pernet(net);\n\tint err;\n\n\tspin_lock_bh(&log->instances_lock);\n\tif (__instance_lookup(log, group_num)) {\n\t\terr = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tinst = kzalloc(sizeof(*inst), GFP_ATOMIC);\n\tif (!inst) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!try_module_get(THIS_MODULE)) {\n\t\tkfree(inst);\n\t\terr = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tINIT_HLIST_NODE(&inst->hlist);\n\tspin_lock_init(&inst->lock);\n\t \n\trefcount_set(&inst->use, 2);\n\n\ttimer_setup(&inst->timer, nfulnl_timer, 0);\n\n\tinst->net = get_net_track(net, &inst->ns_tracker, GFP_ATOMIC);\n\tinst->peer_user_ns = user_ns;\n\tinst->peer_portid = portid;\n\tinst->group_num = group_num;\n\n\tinst->qthreshold \t= NFULNL_QTHRESH_DEFAULT;\n\tinst->flushtimeout \t= NFULNL_TIMEOUT_DEFAULT;\n\tinst->nlbufsiz \t\t= NFULNL_NLBUFSIZ_DEFAULT;\n\tinst->copy_mode \t= NFULNL_COPY_PACKET;\n\tinst->copy_range \t= NFULNL_COPY_RANGE_MAX;\n\n\thlist_add_head_rcu(&inst->hlist,\n\t\t       &log->instance_table[instance_hashfn(group_num)]);\n\n\n\tspin_unlock_bh(&log->instances_lock);\n\n\treturn inst;\n\nout_unlock:\n\tspin_unlock_bh(&log->instances_lock);\n\treturn ERR_PTR(err);\n}\n\nstatic void __nfulnl_flush(struct nfulnl_instance *inst);\n\n \nstatic void\n__instance_destroy(struct nfulnl_instance *inst)\n{\n\t \n\thlist_del_rcu(&inst->hlist);\n\n\t \n\n\tspin_lock(&inst->lock);\n\n\t \n\tinst->copy_mode = NFULNL_COPY_DISABLED;\n\n\tif (inst->skb)\n\t\t__nfulnl_flush(inst);\n\tspin_unlock(&inst->lock);\n\n\t \n\tinstance_put(inst);\n}\n\nstatic inline void\ninstance_destroy(struct nfnl_log_net *log,\n\t\t struct nfulnl_instance *inst)\n{\n\tspin_lock_bh(&log->instances_lock);\n\t__instance_destroy(inst);\n\tspin_unlock_bh(&log->instances_lock);\n}\n\nstatic int\nnfulnl_set_mode(struct nfulnl_instance *inst, u_int8_t mode,\n\t\t  unsigned int range)\n{\n\tint status = 0;\n\n\tspin_lock_bh(&inst->lock);\n\n\tswitch (mode) {\n\tcase NFULNL_COPY_NONE:\n\tcase NFULNL_COPY_META:\n\t\tinst->copy_mode = mode;\n\t\tinst->copy_range = 0;\n\t\tbreak;\n\n\tcase NFULNL_COPY_PACKET:\n\t\tinst->copy_mode = mode;\n\t\tif (range == 0)\n\t\t\trange = NFULNL_COPY_RANGE_MAX;\n\t\tinst->copy_range = min_t(unsigned int,\n\t\t\t\t\t range, NFULNL_COPY_RANGE_MAX);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&inst->lock);\n\n\treturn status;\n}\n\nstatic int\nnfulnl_set_nlbufsiz(struct nfulnl_instance *inst, u_int32_t nlbufsiz)\n{\n\tint status;\n\n\tspin_lock_bh(&inst->lock);\n\tif (nlbufsiz < NFULNL_NLBUFSIZ_DEFAULT)\n\t\tstatus = -ERANGE;\n\telse if (nlbufsiz > 131072)\n\t\tstatus = -ERANGE;\n\telse {\n\t\tinst->nlbufsiz = nlbufsiz;\n\t\tstatus = 0;\n\t}\n\tspin_unlock_bh(&inst->lock);\n\n\treturn status;\n}\n\nstatic void\nnfulnl_set_timeout(struct nfulnl_instance *inst, u_int32_t timeout)\n{\n\tspin_lock_bh(&inst->lock);\n\tinst->flushtimeout = timeout;\n\tspin_unlock_bh(&inst->lock);\n}\n\nstatic void\nnfulnl_set_qthresh(struct nfulnl_instance *inst, u_int32_t qthresh)\n{\n\tspin_lock_bh(&inst->lock);\n\tinst->qthreshold = qthresh;\n\tspin_unlock_bh(&inst->lock);\n}\n\nstatic int\nnfulnl_set_flags(struct nfulnl_instance *inst, u_int16_t flags)\n{\n\tspin_lock_bh(&inst->lock);\n\tinst->flags = flags;\n\tspin_unlock_bh(&inst->lock);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *\nnfulnl_alloc_skb(struct net *net, u32 peer_portid, unsigned int inst_size,\n\t\t unsigned int pkt_size)\n{\n\tstruct sk_buff *skb;\n\tunsigned int n;\n\n\t \n\n\tn = max(inst_size, pkt_size);\n\tskb = alloc_skb(n, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!skb) {\n\t\tif (n > pkt_size) {\n\t\t\t \n\n\t\t\tskb = alloc_skb(pkt_size, GFP_ATOMIC);\n\t\t}\n\t}\n\n\treturn skb;\n}\n\nstatic void\n__nfulnl_send(struct nfulnl_instance *inst)\n{\n\tif (inst->qlen > 1) {\n\t\tstruct nlmsghdr *nlh = nlmsg_put(inst->skb, 0, 0,\n\t\t\t\t\t\t NLMSG_DONE,\n\t\t\t\t\t\t sizeof(struct nfgenmsg),\n\t\t\t\t\t\t 0);\n\t\tif (WARN_ONCE(!nlh, \"bad nlskb size: %u, tailroom %d\\n\",\n\t\t\t      inst->skb->len, skb_tailroom(inst->skb))) {\n\t\t\tkfree_skb(inst->skb);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnfnetlink_unicast(inst->skb, inst->net, inst->peer_portid);\nout:\n\tinst->qlen = 0;\n\tinst->skb = NULL;\n}\n\nstatic void\n__nfulnl_flush(struct nfulnl_instance *inst)\n{\n\t \n\tif (del_timer(&inst->timer))\n\t\tinstance_put(inst);\n\tif (inst->skb)\n\t\t__nfulnl_send(inst);\n}\n\nstatic void\nnfulnl_timer(struct timer_list *t)\n{\n\tstruct nfulnl_instance *inst = from_timer(inst, t, timer);\n\n\tspin_lock_bh(&inst->lock);\n\tif (inst->skb)\n\t\t__nfulnl_send(inst);\n\tspin_unlock_bh(&inst->lock);\n\tinstance_put(inst);\n}\n\nstatic u32 nfulnl_get_bridge_size(const struct sk_buff *skb)\n{\n\tu32 size = 0;\n\n\tif (!skb_mac_header_was_set(skb))\n\t\treturn 0;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tsize += nla_total_size(0);  \n\t\tsize += nla_total_size(sizeof(u16));  \n\t\tsize += nla_total_size(sizeof(u16));  \n\t}\n\n\tif (skb->network_header > skb->mac_header)\n\t\tsize += nla_total_size(skb->network_header - skb->mac_header);\n\n\treturn size;\n}\n\nstatic int nfulnl_put_bridge(struct nfulnl_instance *inst, const struct sk_buff *skb)\n{\n\tif (!skb_mac_header_was_set(skb))\n\t\treturn 0;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tstruct nlattr *nest;\n\n\t\tnest = nla_nest_start(inst->skb, NFULA_VLAN);\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_be16(inst->skb, NFULA_VLAN_TCI, htons(skb->vlan_tci)) ||\n\t\t    nla_put_be16(inst->skb, NFULA_VLAN_PROTO, skb->vlan_proto))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(inst->skb, nest);\n\t}\n\n\tif (skb->mac_header < skb->network_header) {\n\t\tint len = (int)(skb->network_header - skb->mac_header);\n\n\t\tif (nla_put(inst->skb, NFULA_L2HDR, len, skb_mac_header(skb)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\n \nstatic inline int\n__build_packet_message(struct nfnl_log_net *log,\n\t\t\tstruct nfulnl_instance *inst,\n\t\t\tconst struct sk_buff *skb,\n\t\t\tunsigned int data_len,\n\t\t\tu_int8_t pf,\n\t\t\tunsigned int hooknum,\n\t\t\tconst struct net_device *indev,\n\t\t\tconst struct net_device *outdev,\n\t\t\tconst char *prefix, unsigned int plen,\n\t\t\tconst struct nfnl_ct_hook *nfnl_ct,\n\t\t\tstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\n{\n\tstruct nfulnl_msg_packet_hdr pmsg;\n\tstruct nlmsghdr *nlh;\n\tsk_buff_data_t old_tail = inst->skb->tail;\n\tstruct sock *sk;\n\tconst unsigned char *hwhdrp;\n\n\tnlh = nfnl_msg_put(inst->skb, 0, 0,\n\t\t\t   nfnl_msg_type(NFNL_SUBSYS_ULOG, NFULNL_MSG_PACKET),\n\t\t\t   0, pf, NFNETLINK_V0, htons(inst->group_num));\n\tif (!nlh)\n\t\treturn -1;\n\n\tmemset(&pmsg, 0, sizeof(pmsg));\n\tpmsg.hw_protocol\t= skb->protocol;\n\tpmsg.hook\t\t= hooknum;\n\n\tif (nla_put(inst->skb, NFULA_PACKET_HDR, sizeof(pmsg), &pmsg))\n\t\tgoto nla_put_failure;\n\n\tif (prefix &&\n\t    nla_put(inst->skb, NFULA_PREFIX, plen, prefix))\n\t\tgoto nla_put_failure;\n\n\tif (indev) {\n#if !IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\t\tif (nla_put_be32(inst->skb, NFULA_IFINDEX_INDEV,\n\t\t\t\t htonl(indev->ifindex)))\n\t\t\tgoto nla_put_failure;\n#else\n\t\tif (pf == PF_BRIDGE) {\n\t\t\t \n\t\t\tif (nla_put_be32(inst->skb, NFULA_IFINDEX_PHYSINDEV,\n\t\t\t\t\t htonl(indev->ifindex)) ||\n\t\t\t \n\t\t\t \n\t\t\t    nla_put_be32(inst->skb, NFULA_IFINDEX_INDEV,\n\t\t\t\t\t htonl(br_port_get_rcu(indev)->br->dev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\tint physinif;\n\n\t\t\t \n\t\t\tif (nla_put_be32(inst->skb, NFULA_IFINDEX_INDEV,\n\t\t\t\t\t htonl(indev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tphysinif = nf_bridge_get_physinif(skb);\n\t\t\tif (physinif &&\n\t\t\t    nla_put_be32(inst->skb, NFULA_IFINDEX_PHYSINDEV,\n\t\t\t\t\t htonl(physinif)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#endif\n\t}\n\n\tif (outdev) {\n#if !IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\t\tif (nla_put_be32(inst->skb, NFULA_IFINDEX_OUTDEV,\n\t\t\t\t htonl(outdev->ifindex)))\n\t\t\tgoto nla_put_failure;\n#else\n\t\tif (pf == PF_BRIDGE) {\n\t\t\t \n\t\t\tif (nla_put_be32(inst->skb, NFULA_IFINDEX_PHYSOUTDEV,\n\t\t\t\t\t htonl(outdev->ifindex)) ||\n\t\t\t \n\t\t\t \n\t\t\t    nla_put_be32(inst->skb, NFULA_IFINDEX_OUTDEV,\n\t\t\t\t\t htonl(br_port_get_rcu(outdev)->br->dev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\tstruct net_device *physoutdev;\n\n\t\t\t \n\t\t\tif (nla_put_be32(inst->skb, NFULA_IFINDEX_OUTDEV,\n\t\t\t\t\t htonl(outdev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tphysoutdev = nf_bridge_get_physoutdev(skb);\n\t\t\tif (physoutdev &&\n\t\t\t    nla_put_be32(inst->skb, NFULA_IFINDEX_PHYSOUTDEV,\n\t\t\t\t\t htonl(physoutdev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#endif\n\t}\n\n\tif (skb->mark &&\n\t    nla_put_be32(inst->skb, NFULA_MARK, htonl(skb->mark)))\n\t\tgoto nla_put_failure;\n\n\tif (indev && skb->dev &&\n\t    skb_mac_header_was_set(skb) &&\n\t    skb_mac_header_len(skb) != 0) {\n\t\tstruct nfulnl_msg_packet_hw phw;\n\t\tint len;\n\n\t\tmemset(&phw, 0, sizeof(phw));\n\t\tlen = dev_parse_header(skb, phw.hw_addr);\n\t\tif (len > 0) {\n\t\t\tphw.hw_addrlen = htons(len);\n\t\t\tif (nla_put(inst->skb, NFULA_HWADDR, sizeof(phw), &phw))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (indev && skb_mac_header_was_set(skb)) {\n\t\tif (nla_put_be16(inst->skb, NFULA_HWTYPE, htons(skb->dev->type)) ||\n\t\t    nla_put_be16(inst->skb, NFULA_HWLEN,\n\t\t\t\t htons(skb->dev->hard_header_len)))\n\t\t\tgoto nla_put_failure;\n\n\t\thwhdrp = skb_mac_header(skb);\n\n\t\tif (skb->dev->type == ARPHRD_SIT)\n\t\t\thwhdrp -= ETH_HLEN;\n\n\t\tif (hwhdrp >= skb->head &&\n\t\t    nla_put(inst->skb, NFULA_HWHEADER,\n\t\t\t    skb->dev->hard_header_len, hwhdrp))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (hooknum <= NF_INET_FORWARD) {\n\t\tstruct timespec64 kts = ktime_to_timespec64(skb_tstamp_cond(skb, true));\n\t\tstruct nfulnl_msg_packet_timestamp ts;\n\t\tts.sec = cpu_to_be64(kts.tv_sec);\n\t\tts.usec = cpu_to_be64(kts.tv_nsec / NSEC_PER_USEC);\n\n\t\tif (nla_put(inst->skb, NFULA_TIMESTAMP, sizeof(ts), &ts))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\t \n\tsk = skb->sk;\n\tif (sk && sk_fullsock(sk)) {\n\t\tread_lock_bh(&sk->sk_callback_lock);\n\t\tif (sk->sk_socket && sk->sk_socket->file) {\n\t\t\tstruct file *file = sk->sk_socket->file;\n\t\t\tconst struct cred *cred = file->f_cred;\n\t\t\tstruct user_namespace *user_ns = inst->peer_user_ns;\n\t\t\t__be32 uid = htonl(from_kuid_munged(user_ns, cred->fsuid));\n\t\t\t__be32 gid = htonl(from_kgid_munged(user_ns, cred->fsgid));\n\t\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t\t\tif (nla_put_be32(inst->skb, NFULA_UID, uid) ||\n\t\t\t    nla_put_be32(inst->skb, NFULA_GID, gid))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else\n\t\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t}\n\n\t \n\tif ((inst->flags & NFULNL_CFG_F_SEQ) &&\n\t    nla_put_be32(inst->skb, NFULA_SEQ, htonl(inst->seq++)))\n\t\tgoto nla_put_failure;\n\n\t \n\tif ((inst->flags & NFULNL_CFG_F_SEQ_GLOBAL) &&\n\t    nla_put_be32(inst->skb, NFULA_SEQ_GLOBAL,\n\t\t\t htonl(atomic_inc_return(&log->global_seq))))\n\t\tgoto nla_put_failure;\n\n\tif (ct && nfnl_ct->build(inst->skb, ct, ctinfo,\n\t\t\t\t NFULA_CT, NFULA_CT_INFO) < 0)\n\t\tgoto nla_put_failure;\n\n\tif ((pf == NFPROTO_NETDEV || pf == NFPROTO_BRIDGE) &&\n\t    nfulnl_put_bridge(inst, skb) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (data_len) {\n\t\tstruct nlattr *nla;\n\t\tint size = nla_attr_size(data_len);\n\n\t\tif (skb_tailroom(inst->skb) < nla_total_size(data_len))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla = skb_put(inst->skb, nla_total_size(data_len));\n\t\tnla->nla_type = NFULA_PAYLOAD;\n\t\tnla->nla_len = size;\n\n\t\tif (skb_copy_bits(skb, 0, nla_data(nla), data_len))\n\t\t\tBUG();\n\t}\n\n\tnlh->nlmsg_len = inst->skb->tail - old_tail;\n\treturn 0;\n\nnla_put_failure:\n\tPRINTR(KERN_ERR \"nfnetlink_log: error creating log nlmsg\\n\");\n\treturn -1;\n}\n\nstatic const struct nf_loginfo default_loginfo = {\n\t.type =\t\tNF_LOG_TYPE_ULOG,\n\t.u = {\n\t\t.ulog = {\n\t\t\t.copy_len\t= 0xffff,\n\t\t\t.group\t\t= 0,\n\t\t\t.qthreshold\t= 1,\n\t\t},\n\t},\n};\n\n \nstatic void\nnfulnl_log_packet(struct net *net,\n\t\t  u_int8_t pf,\n\t\t  unsigned int hooknum,\n\t\t  const struct sk_buff *skb,\n\t\t  const struct net_device *in,\n\t\t  const struct net_device *out,\n\t\t  const struct nf_loginfo *li_user,\n\t\t  const char *prefix)\n{\n\tsize_t size;\n\tunsigned int data_len;\n\tstruct nfulnl_instance *inst;\n\tconst struct nf_loginfo *li;\n\tunsigned int qthreshold;\n\tunsigned int plen = 0;\n\tstruct nfnl_log_net *log = nfnl_log_pernet(net);\n\tconst struct nfnl_ct_hook *nfnl_ct = NULL;\n\tenum ip_conntrack_info ctinfo = 0;\n\tstruct nf_conn *ct = NULL;\n\n\tif (li_user && li_user->type == NF_LOG_TYPE_ULOG)\n\t\tli = li_user;\n\telse\n\t\tli = &default_loginfo;\n\n\tinst = instance_lookup_get_rcu(log, li->u.ulog.group);\n\tif (!inst)\n\t\treturn;\n\n\tif (prefix)\n\t\tplen = strlen(prefix) + 1;\n\n\t \n\tsize = nlmsg_total_size(sizeof(struct nfgenmsg))\n\t\t+ nla_total_size(sizeof(struct nfulnl_msg_packet_hdr))\n\t\t+ nla_total_size(sizeof(u_int32_t))\t \n\t\t+ nla_total_size(sizeof(u_int32_t))\t \n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\t\t+ nla_total_size(sizeof(u_int32_t))\t \n\t\t+ nla_total_size(sizeof(u_int32_t))\t \n#endif\n\t\t+ nla_total_size(sizeof(u_int32_t))\t \n\t\t+ nla_total_size(sizeof(u_int32_t))\t \n\t\t+ nla_total_size(sizeof(u_int32_t))\t \n\t\t+ nla_total_size(plen)\t\t\t \n\t\t+ nla_total_size(sizeof(struct nfulnl_msg_packet_hw))\n\t\t+ nla_total_size(sizeof(struct nfulnl_msg_packet_timestamp))\n\t\t+ nla_total_size(sizeof(struct nfgenmsg));\t \n\n\tif (in && skb_mac_header_was_set(skb)) {\n\t\tsize += nla_total_size(skb->dev->hard_header_len)\n\t\t\t+ nla_total_size(sizeof(u_int16_t))\t \n\t\t\t+ nla_total_size(sizeof(u_int16_t));\t \n\t}\n\n\tspin_lock_bh(&inst->lock);\n\n\tif (inst->flags & NFULNL_CFG_F_SEQ)\n\t\tsize += nla_total_size(sizeof(u_int32_t));\n\tif (inst->flags & NFULNL_CFG_F_SEQ_GLOBAL)\n\t\tsize += nla_total_size(sizeof(u_int32_t));\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (inst->flags & NFULNL_CFG_F_CONNTRACK) {\n\t\tnfnl_ct = rcu_dereference(nfnl_ct_hook);\n\t\tif (nfnl_ct != NULL) {\n\t\t\tct = nf_ct_get(skb, &ctinfo);\n\t\t\tif (ct != NULL)\n\t\t\t\tsize += nfnl_ct->build_size(ct);\n\t\t}\n\t}\n#endif\n\tif (pf == NFPROTO_NETDEV || pf == NFPROTO_BRIDGE)\n\t\tsize += nfulnl_get_bridge_size(skb);\n\n\tqthreshold = inst->qthreshold;\n\t \n\tif (li->u.ulog.qthreshold)\n\t\tif (qthreshold > li->u.ulog.qthreshold)\n\t\t\tqthreshold = li->u.ulog.qthreshold;\n\n\n\tswitch (inst->copy_mode) {\n\tcase NFULNL_COPY_META:\n\tcase NFULNL_COPY_NONE:\n\t\tdata_len = 0;\n\t\tbreak;\n\n\tcase NFULNL_COPY_PACKET:\n\t\tdata_len = inst->copy_range;\n\t\tif ((li->u.ulog.flags & NF_LOG_F_COPY_LEN) &&\n\t\t    (li->u.ulog.copy_len < data_len))\n\t\t\tdata_len = li->u.ulog.copy_len;\n\n\t\tif (data_len > skb->len)\n\t\t\tdata_len = skb->len;\n\n\t\tsize += nla_total_size(data_len);\n\t\tbreak;\n\n\tcase NFULNL_COPY_DISABLED:\n\tdefault:\n\t\tgoto unlock_and_release;\n\t}\n\n\tif (inst->skb && size > skb_tailroom(inst->skb)) {\n\t\t \n\t\t__nfulnl_flush(inst);\n\t}\n\n\tif (!inst->skb) {\n\t\tinst->skb = nfulnl_alloc_skb(net, inst->peer_portid,\n\t\t\t\t\t     inst->nlbufsiz, size);\n\t\tif (!inst->skb)\n\t\t\tgoto alloc_failure;\n\t}\n\n\tinst->qlen++;\n\n\t__build_packet_message(log, inst, skb, data_len, pf,\n\t\t\t\thooknum, in, out, prefix, plen,\n\t\t\t\tnfnl_ct, ct, ctinfo);\n\n\tif (inst->qlen >= qthreshold)\n\t\t__nfulnl_flush(inst);\n\t \n\telse if (!timer_pending(&inst->timer)) {\n\t\tinstance_get(inst);\n\t\tinst->timer.expires = jiffies + (inst->flushtimeout*HZ/100);\n\t\tadd_timer(&inst->timer);\n\t}\n\nunlock_and_release:\n\tspin_unlock_bh(&inst->lock);\n\tinstance_put(inst);\n\treturn;\n\nalloc_failure:\n\t \n\tgoto unlock_and_release;\n}\n\nstatic int\nnfulnl_rcv_nl_event(struct notifier_block *this,\n\t\t   unsigned long event, void *ptr)\n{\n\tstruct netlink_notify *n = ptr;\n\tstruct nfnl_log_net *log = nfnl_log_pernet(n->net);\n\n\tif (event == NETLINK_URELEASE && n->protocol == NETLINK_NETFILTER) {\n\t\tint i;\n\n\t\t \n\t\tspin_lock_bh(&log->instances_lock);\n\t\tfor  (i = 0; i < INSTANCE_BUCKETS; i++) {\n\t\t\tstruct hlist_node *t2;\n\t\t\tstruct nfulnl_instance *inst;\n\t\t\tstruct hlist_head *head = &log->instance_table[i];\n\n\t\t\thlist_for_each_entry_safe(inst, t2, head, hlist) {\n\t\t\t\tif (n->portid == inst->peer_portid)\n\t\t\t\t\t__instance_destroy(inst);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&log->instances_lock);\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nfulnl_rtnl_notifier = {\n\t.notifier_call\t= nfulnl_rcv_nl_event,\n};\n\nstatic int nfulnl_recv_unsupp(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nfula[])\n{\n\treturn -ENOTSUPP;\n}\n\nstatic struct nf_logger nfulnl_logger __read_mostly = {\n\t.name\t= \"nfnetlink_log\",\n\t.type\t= NF_LOG_TYPE_ULOG,\n\t.logfn\t= nfulnl_log_packet,\n\t.me\t= THIS_MODULE,\n};\n\nstatic const struct nla_policy nfula_cfg_policy[NFULA_CFG_MAX+1] = {\n\t[NFULA_CFG_CMD]\t\t= { .len = sizeof(struct nfulnl_msg_config_cmd) },\n\t[NFULA_CFG_MODE]\t= { .len = sizeof(struct nfulnl_msg_config_mode) },\n\t[NFULA_CFG_TIMEOUT]\t= { .type = NLA_U32 },\n\t[NFULA_CFG_QTHRESH]\t= { .type = NLA_U32 },\n\t[NFULA_CFG_NLBUFSIZ]\t= { .type = NLA_U32 },\n\t[NFULA_CFG_FLAGS]\t= { .type = NLA_U16 },\n};\n\nstatic int nfulnl_recv_config(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nfula[])\n{\n\tstruct nfnl_log_net *log = nfnl_log_pernet(info->net);\n\tu_int16_t group_num = ntohs(info->nfmsg->res_id);\n\tstruct nfulnl_msg_config_cmd *cmd = NULL;\n\tstruct nfulnl_instance *inst;\n\tu16 flags = 0;\n\tint ret = 0;\n\n\tif (nfula[NFULA_CFG_CMD]) {\n\t\tu_int8_t pf = info->nfmsg->nfgen_family;\n\t\tcmd = nla_data(nfula[NFULA_CFG_CMD]);\n\n\t\t \n\t\tswitch (cmd->command) {\n\t\tcase NFULNL_CFG_CMD_PF_BIND:\n\t\t\treturn nf_log_bind_pf(info->net, pf, &nfulnl_logger);\n\t\tcase NFULNL_CFG_CMD_PF_UNBIND:\n\t\t\tnf_log_unbind_pf(info->net, pf);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tinst = instance_lookup_get(log, group_num);\n\tif (inst && inst->peer_portid != NETLINK_CB(skb).portid) {\n\t\tret = -EPERM;\n\t\tgoto out_put;\n\t}\n\n\t \n\tif (nfula[NFULA_CFG_FLAGS]) {\n\t\tflags = ntohs(nla_get_be16(nfula[NFULA_CFG_FLAGS]));\n\n\t\tif ((flags & NFULNL_CFG_F_CONNTRACK) &&\n\t\t    !rcu_access_pointer(nfnl_ct_hook)) {\n#ifdef CONFIG_MODULES\n\t\t\tnfnl_unlock(NFNL_SUBSYS_ULOG);\n\t\t\trequest_module(\"ip_conntrack_netlink\");\n\t\t\tnfnl_lock(NFNL_SUBSYS_ULOG);\n\t\t\tif (rcu_access_pointer(nfnl_ct_hook)) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto out_put;\n\t\t\t}\n#endif\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tif (cmd != NULL) {\n\t\tswitch (cmd->command) {\n\t\tcase NFULNL_CFG_CMD_BIND:\n\t\t\tif (inst) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\tinst = instance_create(info->net, group_num,\n\t\t\t\t\t       NETLINK_CB(skb).portid,\n\t\t\t\t\t       sk_user_ns(NETLINK_CB(skb).sk));\n\t\t\tif (IS_ERR(inst)) {\n\t\t\t\tret = PTR_ERR(inst);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFULNL_CFG_CMD_UNBIND:\n\t\t\tif (!inst) {\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tinstance_destroy(log, inst);\n\t\t\tgoto out_put;\n\t\tdefault:\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out_put;\n\t\t}\n\t} else if (!inst) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (nfula[NFULA_CFG_MODE]) {\n\t\tstruct nfulnl_msg_config_mode *params =\n\t\t\tnla_data(nfula[NFULA_CFG_MODE]);\n\n\t\tnfulnl_set_mode(inst, params->copy_mode,\n\t\t\t\tntohl(params->copy_range));\n\t}\n\n\tif (nfula[NFULA_CFG_TIMEOUT]) {\n\t\t__be32 timeout = nla_get_be32(nfula[NFULA_CFG_TIMEOUT]);\n\n\t\tnfulnl_set_timeout(inst, ntohl(timeout));\n\t}\n\n\tif (nfula[NFULA_CFG_NLBUFSIZ]) {\n\t\t__be32 nlbufsiz = nla_get_be32(nfula[NFULA_CFG_NLBUFSIZ]);\n\n\t\tnfulnl_set_nlbufsiz(inst, ntohl(nlbufsiz));\n\t}\n\n\tif (nfula[NFULA_CFG_QTHRESH]) {\n\t\t__be32 qthresh = nla_get_be32(nfula[NFULA_CFG_QTHRESH]);\n\n\t\tnfulnl_set_qthresh(inst, ntohl(qthresh));\n\t}\n\n\tif (nfula[NFULA_CFG_FLAGS])\n\t\tnfulnl_set_flags(inst, flags);\n\nout_put:\n\tinstance_put(inst);\nout:\n\treturn ret;\n}\n\nstatic const struct nfnl_callback nfulnl_cb[NFULNL_MSG_MAX] = {\n\t[NFULNL_MSG_PACKET]\t= {\n\t\t.call\t\t= nfulnl_recv_unsupp,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= NFULA_MAX,\n\t},\n\t[NFULNL_MSG_CONFIG]\t= {\n\t\t.call\t\t= nfulnl_recv_config,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= NFULA_CFG_MAX,\n\t\t.policy\t\t= nfula_cfg_policy\n\t},\n};\n\nstatic const struct nfnetlink_subsystem nfulnl_subsys = {\n\t.name\t\t= \"log\",\n\t.subsys_id\t= NFNL_SUBSYS_ULOG,\n\t.cb_count\t= NFULNL_MSG_MAX,\n\t.cb\t\t= nfulnl_cb,\n};\n\n#ifdef CONFIG_PROC_FS\nstruct iter_state {\n\tstruct seq_net_private p;\n\tunsigned int bucket;\n};\n\nstatic struct hlist_node *get_first(struct net *net, struct iter_state *st)\n{\n\tstruct nfnl_log_net *log;\n\tif (!st)\n\t\treturn NULL;\n\n\tlog = nfnl_log_pernet(net);\n\n\tfor (st->bucket = 0; st->bucket < INSTANCE_BUCKETS; st->bucket++) {\n\t\tstruct hlist_head *head = &log->instance_table[st->bucket];\n\n\t\tif (!hlist_empty(head))\n\t\t\treturn rcu_dereference(hlist_first_rcu(head));\n\t}\n\treturn NULL;\n}\n\nstatic struct hlist_node *get_next(struct net *net, struct iter_state *st,\n\t\t\t\t   struct hlist_node *h)\n{\n\th = rcu_dereference(hlist_next_rcu(h));\n\twhile (!h) {\n\t\tstruct nfnl_log_net *log;\n\t\tstruct hlist_head *head;\n\n\t\tif (++st->bucket >= INSTANCE_BUCKETS)\n\t\t\treturn NULL;\n\n\t\tlog = nfnl_log_pernet(net);\n\t\thead = &log->instance_table[st->bucket];\n\t\th = rcu_dereference(hlist_first_rcu(head));\n\t}\n\treturn h;\n}\n\nstatic struct hlist_node *get_idx(struct net *net, struct iter_state *st,\n\t\t\t\t  loff_t pos)\n{\n\tstruct hlist_node *head;\n\thead = get_first(net, st);\n\n\tif (head)\n\t\twhile (pos && (head = get_next(net, st, head)))\n\t\t\tpos--;\n\treturn pos ? NULL : head;\n}\n\nstatic void *seq_start(struct seq_file *s, loff_t *pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn get_idx(seq_file_net(s), s->private, *pos);\n}\n\nstatic void *seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn get_next(seq_file_net(s), s->private, v);\n}\n\nstatic void seq_stop(struct seq_file *s, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic int seq_show(struct seq_file *s, void *v)\n{\n\tconst struct nfulnl_instance *inst = v;\n\n\tseq_printf(s, \"%5u %6u %5u %1u %5u %6u %2u\\n\",\n\t\t   inst->group_num,\n\t\t   inst->peer_portid, inst->qlen,\n\t\t   inst->copy_mode, inst->copy_range,\n\t\t   inst->flushtimeout, refcount_read(&inst->use));\n\n\treturn 0;\n}\n\nstatic const struct seq_operations nful_seq_ops = {\n\t.start\t= seq_start,\n\t.next\t= seq_next,\n\t.stop\t= seq_stop,\n\t.show\t= seq_show,\n};\n#endif  \n\nstatic int __net_init nfnl_log_net_init(struct net *net)\n{\n\tunsigned int i;\n\tstruct nfnl_log_net *log = nfnl_log_pernet(net);\n#ifdef CONFIG_PROC_FS\n\tstruct proc_dir_entry *proc;\n\tkuid_t root_uid;\n\tkgid_t root_gid;\n#endif\n\n\tfor (i = 0; i < INSTANCE_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(&log->instance_table[i]);\n\tspin_lock_init(&log->instances_lock);\n\n#ifdef CONFIG_PROC_FS\n\tproc = proc_create_net(\"nfnetlink_log\", 0440, net->nf.proc_netfilter,\n\t\t\t&nful_seq_ops, sizeof(struct iter_state));\n\tif (!proc)\n\t\treturn -ENOMEM;\n\n\troot_uid = make_kuid(net->user_ns, 0);\n\troot_gid = make_kgid(net->user_ns, 0);\n\tif (uid_valid(root_uid) && gid_valid(root_gid))\n\t\tproc_set_user(proc, root_uid, root_gid);\n#endif\n\treturn 0;\n}\n\nstatic void __net_exit nfnl_log_net_exit(struct net *net)\n{\n\tstruct nfnl_log_net *log = nfnl_log_pernet(net);\n\tunsigned int i;\n\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"nfnetlink_log\", net->nf.proc_netfilter);\n#endif\n\tnf_log_unset(net, &nfulnl_logger);\n\tfor (i = 0; i < INSTANCE_BUCKETS; i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&log->instance_table[i]));\n}\n\nstatic struct pernet_operations nfnl_log_net_ops = {\n\t.init\t= nfnl_log_net_init,\n\t.exit\t= nfnl_log_net_exit,\n\t.id\t= &nfnl_log_net_id,\n\t.size\t= sizeof(struct nfnl_log_net),\n};\n\nstatic int __init nfnetlink_log_init(void)\n{\n\tint status;\n\n\tstatus = register_pernet_subsys(&nfnl_log_net_ops);\n\tif (status < 0) {\n\t\tpr_err(\"failed to register pernet ops\\n\");\n\t\tgoto out;\n\t}\n\n\tnetlink_register_notifier(&nfulnl_rtnl_notifier);\n\tstatus = nfnetlink_subsys_register(&nfulnl_subsys);\n\tif (status < 0) {\n\t\tpr_err(\"failed to create netlink socket\\n\");\n\t\tgoto cleanup_netlink_notifier;\n\t}\n\n\tstatus = nf_log_register(NFPROTO_UNSPEC, &nfulnl_logger);\n\tif (status < 0) {\n\t\tpr_err(\"failed to register logger\\n\");\n\t\tgoto cleanup_subsys;\n\t}\n\n\treturn status;\n\ncleanup_subsys:\n\tnfnetlink_subsys_unregister(&nfulnl_subsys);\ncleanup_netlink_notifier:\n\tnetlink_unregister_notifier(&nfulnl_rtnl_notifier);\n\tunregister_pernet_subsys(&nfnl_log_net_ops);\nout:\n\treturn status;\n}\n\nstatic void __exit nfnetlink_log_fini(void)\n{\n\tnfnetlink_subsys_unregister(&nfulnl_subsys);\n\tnetlink_unregister_notifier(&nfulnl_rtnl_notifier);\n\tunregister_pernet_subsys(&nfnl_log_net_ops);\n\tnf_log_unregister(&nfulnl_logger);\n}\n\nMODULE_DESCRIPTION(\"netfilter userspace logging\");\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_ULOG);\nMODULE_ALIAS_NF_LOGGER(AF_INET, 1);\nMODULE_ALIAS_NF_LOGGER(AF_INET6, 1);\nMODULE_ALIAS_NF_LOGGER(AF_BRIDGE, 1);\nMODULE_ALIAS_NF_LOGGER(3, 1);  \nMODULE_ALIAS_NF_LOGGER(5, 1);  \n\nmodule_init(nfnetlink_log_init);\nmodule_exit(nfnetlink_log_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}