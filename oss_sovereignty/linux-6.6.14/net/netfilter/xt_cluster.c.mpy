{
  "module_name": "xt_cluster.c",
  "hash_id": "3717fbd677d7c823f9229406de12c24274c1575b22f4b6f7e0bb2b1156a50bd5",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_cluster.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/jhash.h>\n#include <linux/ip.h>\n#include <net/ipv6.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <linux/netfilter/xt_cluster.h>\n\nstatic inline u32 nf_ct_orig_ipv4_src(const struct nf_conn *ct)\n{\n\treturn (__force u32)ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;\n}\n\nstatic inline const u32 *nf_ct_orig_ipv6_src(const struct nf_conn *ct)\n{\n\treturn (__force u32 *)ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip6;\n}\n\nstatic inline u_int32_t\nxt_cluster_hash_ipv4(u_int32_t ip, const struct xt_cluster_match_info *info)\n{\n\treturn jhash_1word(ip, info->hash_seed);\n}\n\nstatic inline u_int32_t\nxt_cluster_hash_ipv6(const void *ip, const struct xt_cluster_match_info *info)\n{\n\treturn jhash2(ip, NF_CT_TUPLE_L3SIZE / sizeof(__u32), info->hash_seed);\n}\n\nstatic inline u_int32_t\nxt_cluster_hash(const struct nf_conn *ct,\n\t\tconst struct xt_cluster_match_info *info)\n{\n\tu_int32_t hash = 0;\n\n\tswitch(nf_ct_l3num(ct)) {\n\tcase AF_INET:\n\t\thash = xt_cluster_hash_ipv4(nf_ct_orig_ipv4_src(ct), info);\n\t\tbreak;\n\tcase AF_INET6:\n\t\thash = xt_cluster_hash_ipv6(nf_ct_orig_ipv6_src(ct), info);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn reciprocal_scale(hash, info->total_nodes);\n}\n\nstatic inline bool\nxt_cluster_is_multicast_addr(const struct sk_buff *skb, u_int8_t family)\n{\n\tbool is_multicast = false;\n\n\tswitch(family) {\n\tcase NFPROTO_IPV4:\n\t\tis_multicast = ipv4_is_multicast(ip_hdr(skb)->daddr);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tis_multicast = ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\treturn is_multicast;\n}\n\nstatic bool\nxt_cluster_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tstruct sk_buff *pskb = (struct sk_buff *)skb;\n\tconst struct xt_cluster_match_info *info = par->matchinfo;\n\tconst struct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\tunsigned long hash;\n\n\t \n\tif (!xt_cluster_is_multicast_addr(skb, xt_family(par)) &&\n\t    skb->pkt_type == PACKET_MULTICAST) {\n\t    \tpskb->pkt_type = PACKET_HOST;\n\t}\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct == NULL)\n\t\treturn false;\n\n\tif (ct->master)\n\t\thash = xt_cluster_hash(ct->master, info);\n\telse\n\t\thash = xt_cluster_hash(ct, info);\n\n\treturn !!((1 << hash) & info->node_mask) ^\n\t       !!(info->flags & XT_CLUSTER_F_INV);\n}\n\nstatic int xt_cluster_mt_checkentry(const struct xt_mtchk_param *par)\n{\n\tstruct xt_cluster_match_info *info = par->matchinfo;\n\tint ret;\n\n\tif (info->total_nodes > XT_CLUSTER_NODES_MAX) {\n\t\tpr_info_ratelimited(\"you have exceeded the maximum number of cluster nodes (%u > %u)\\n\",\n\t\t\t\t    info->total_nodes, XT_CLUSTER_NODES_MAX);\n\t\treturn -EINVAL;\n\t}\n\tif (info->node_mask >= (1ULL << info->total_nodes)) {\n\t\tpr_info_ratelimited(\"node mask cannot exceed total number of nodes\\n\");\n\t\treturn -EDOM;\n\t}\n\n\tret = nf_ct_netns_get(par->net, par->family);\n\tif (ret < 0)\n\t\tpr_info_ratelimited(\"cannot load conntrack support for proto=%u\\n\",\n\t\t\t\t    par->family);\n\treturn ret;\n}\n\nstatic void xt_cluster_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tnf_ct_netns_put(par->net, par->family);\n}\n\nstatic struct xt_match xt_cluster_match __read_mostly = {\n\t.name\t\t= \"cluster\",\n\t.family\t\t= NFPROTO_UNSPEC,\n\t.match\t\t= xt_cluster_mt,\n\t.checkentry\t= xt_cluster_mt_checkentry,\n\t.matchsize\t= sizeof(struct xt_cluster_match_info),\n\t.destroy\t= xt_cluster_mt_destroy,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init xt_cluster_mt_init(void)\n{\n\treturn xt_register_match(&xt_cluster_match);\n}\n\nstatic void __exit xt_cluster_mt_fini(void)\n{\n\txt_unregister_match(&xt_cluster_match);\n}\n\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Xtables: hash-based cluster match\");\nMODULE_ALIAS(\"ipt_cluster\");\nMODULE_ALIAS(\"ip6t_cluster\");\nmodule_init(xt_cluster_mt_init);\nmodule_exit(xt_cluster_mt_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}