{
  "module_name": "nft_inner.c",
  "hash_id": "73f3bb7c9ec899595d99cfb7d680c84fdc3506143c5cd66e270b3decabe5f2ba",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_inner.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nft_meta.h>\n#include <net/netfilter/nf_tables_offload.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <net/gre.h>\n#include <net/geneve.h>\n#include <net/ip.h>\n#include <linux/icmpv6.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n\nstatic DEFINE_PER_CPU(struct nft_inner_tun_ctx, nft_pcpu_tun_ctx);\n\n \nstruct __nft_expr {\n\tconst struct nft_expr_ops\t*ops;\n\tunion {\n\t\tstruct nft_payload\tpayload;\n\t\tstruct nft_meta\t\tmeta;\n\t} __attribute__((aligned(__alignof__(u64))));\n};\n\nenum {\n\tNFT_INNER_EXPR_PAYLOAD,\n\tNFT_INNER_EXPR_META,\n};\n\nstruct nft_inner {\n\tu8\t\t\tflags;\n\tu8\t\t\thdrsize;\n\tu8\t\t\ttype;\n\tu8\t\t\texpr_type;\n\n\tstruct __nft_expr\texpr;\n};\n\nstatic int nft_inner_parse_l2l3(const struct nft_inner *priv,\n\t\t\t\tconst struct nft_pktinfo *pkt,\n\t\t\t\tstruct nft_inner_tun_ctx *ctx, u32 off)\n{\n\t__be16 llproto, outer_llproto;\n\tu32 nhoff, thoff;\n\n\tif (priv->flags & NFT_INNER_LL) {\n\t\tstruct vlan_ethhdr *veth, _veth;\n\t\tstruct ethhdr *eth, _eth;\n\t\tu32 hdrsize;\n\n\t\teth = skb_header_pointer(pkt->skb, off, sizeof(_eth), &_eth);\n\t\tif (!eth)\n\t\t\treturn -1;\n\n\t\tswitch (eth->h_proto) {\n\t\tcase htons(ETH_P_IP):\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tllproto = eth->h_proto;\n\t\t\thdrsize = sizeof(_eth);\n\t\t\tbreak;\n\t\tcase htons(ETH_P_8021Q):\n\t\t\tveth = skb_header_pointer(pkt->skb, off, sizeof(_veth), &_veth);\n\t\t\tif (!veth)\n\t\t\t\treturn -1;\n\n\t\t\touter_llproto = veth->h_vlan_encapsulated_proto;\n\t\t\tllproto = veth->h_vlan_proto;\n\t\t\thdrsize = sizeof(_veth);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tctx->inner_lloff = off;\n\t\tctx->flags |= NFT_PAYLOAD_CTX_INNER_LL;\n\t\toff += hdrsize;\n\t} else {\n\t\tstruct iphdr *iph;\n\t\tu32 _version;\n\n\t\tiph = skb_header_pointer(pkt->skb, off, sizeof(_version), &_version);\n\t\tif (!iph)\n\t\t\treturn -1;\n\n\t\tswitch (iph->version) {\n\t\tcase 4:\n\t\t\tllproto = htons(ETH_P_IP);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tllproto = htons(ETH_P_IPV6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tctx->llproto = llproto;\n\tif (llproto == htons(ETH_P_8021Q))\n\t\tllproto = outer_llproto;\n\n\tnhoff = off;\n\n\tswitch (llproto) {\n\tcase htons(ETH_P_IP): {\n\t\tstruct iphdr *iph, _iph;\n\n\t\tiph = skb_header_pointer(pkt->skb, nhoff, sizeof(_iph), &_iph);\n\t\tif (!iph)\n\t\t\treturn -1;\n\n\t\tif (iph->ihl < 5 || iph->version != 4)\n\t\t\treturn -1;\n\n\t\tctx->inner_nhoff = nhoff;\n\t\tctx->flags |= NFT_PAYLOAD_CTX_INNER_NH;\n\n\t\tthoff = nhoff + (iph->ihl * 4);\n\t\tif ((ntohs(iph->frag_off) & IP_OFFSET) == 0) {\n\t\t\tctx->flags |= NFT_PAYLOAD_CTX_INNER_TH;\n\t\t\tctx->inner_thoff = thoff;\n\t\t\tctx->l4proto = iph->protocol;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase htons(ETH_P_IPV6): {\n\t\tstruct ipv6hdr *ip6h, _ip6h;\n\t\tint fh_flags = IP6_FH_F_AUTH;\n\t\tunsigned short fragoff;\n\t\tint l4proto;\n\n\t\tip6h = skb_header_pointer(pkt->skb, nhoff, sizeof(_ip6h), &_ip6h);\n\t\tif (!ip6h)\n\t\t\treturn -1;\n\n\t\tif (ip6h->version != 6)\n\t\t\treturn -1;\n\n\t\tctx->inner_nhoff = nhoff;\n\t\tctx->flags |= NFT_PAYLOAD_CTX_INNER_NH;\n\n\t\tthoff = nhoff;\n\t\tl4proto = ipv6_find_hdr(pkt->skb, &thoff, -1, &fragoff, &fh_flags);\n\t\tif (l4proto < 0 || thoff > U16_MAX)\n\t\t\treturn -1;\n\n\t\tif (fragoff == 0) {\n\t\t\tthoff = nhoff + sizeof(_ip6h);\n\t\t\tctx->flags |= NFT_PAYLOAD_CTX_INNER_TH;\n\t\t\tctx->inner_thoff = thoff;\n\t\t\tctx->l4proto = l4proto;\n\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_inner_parse_tunhdr(const struct nft_inner *priv,\n\t\t\t\t  const struct nft_pktinfo *pkt,\n\t\t\t\t  struct nft_inner_tun_ctx *ctx, u32 *off)\n{\n\tif (pkt->tprot == IPPROTO_GRE) {\n\t\tctx->inner_tunoff = pkt->thoff;\n\t\tctx->flags |= NFT_PAYLOAD_CTX_INNER_TUN;\n\t\treturn 0;\n\t}\n\n\tif (pkt->tprot != IPPROTO_UDP)\n\t\treturn -1;\n\n\tctx->inner_tunoff = *off;\n\tctx->flags |= NFT_PAYLOAD_CTX_INNER_TUN;\n\t*off += priv->hdrsize;\n\n\tswitch (priv->type) {\n\tcase NFT_INNER_GENEVE: {\n\t\tstruct genevehdr *gnvh, _gnvh;\n\n\t\tgnvh = skb_header_pointer(pkt->skb, pkt->inneroff,\n\t\t\t\t\t  sizeof(_gnvh), &_gnvh);\n\t\tif (!gnvh)\n\t\t\treturn -1;\n\n\t\t*off += gnvh->opt_len * 4;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_inner_parse(const struct nft_inner *priv,\n\t\t\t   struct nft_pktinfo *pkt,\n\t\t\t   struct nft_inner_tun_ctx *tun_ctx)\n{\n\tstruct nft_inner_tun_ctx ctx = {};\n\tu32 off = pkt->inneroff;\n\n\tif (priv->flags & NFT_INNER_HDRSIZE &&\n\t    nft_inner_parse_tunhdr(priv, pkt, &ctx, &off) < 0)\n\t\treturn -1;\n\n\tif (priv->flags & (NFT_INNER_LL | NFT_INNER_NH)) {\n\t\tif (nft_inner_parse_l2l3(priv, pkt, &ctx, off) < 0)\n\t\t\treturn -1;\n\t} else if (priv->flags & NFT_INNER_TH) {\n\t\tctx.inner_thoff = off;\n\t\tctx.flags |= NFT_PAYLOAD_CTX_INNER_TH;\n\t}\n\n\t*tun_ctx = ctx;\n\ttun_ctx->type = priv->type;\n\tpkt->flags |= NFT_PKTINFO_INNER_FULL;\n\n\treturn 0;\n}\n\nstatic bool nft_inner_parse_needed(const struct nft_inner *priv,\n\t\t\t\t   const struct nft_pktinfo *pkt,\n\t\t\t\t   const struct nft_inner_tun_ctx *tun_ctx)\n{\n\tif (!(pkt->flags & NFT_PKTINFO_INNER_FULL))\n\t\treturn true;\n\n\tif (priv->type != tun_ctx->type)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void nft_inner_eval(const struct nft_expr *expr, struct nft_regs *regs,\n\t\t\t   const struct nft_pktinfo *pkt)\n{\n\tstruct nft_inner_tun_ctx *tun_ctx = this_cpu_ptr(&nft_pcpu_tun_ctx);\n\tconst struct nft_inner *priv = nft_expr_priv(expr);\n\n\tif (nft_payload_inner_offset(pkt) < 0)\n\t\tgoto err;\n\n\tif (nft_inner_parse_needed(priv, pkt, tun_ctx) &&\n\t    nft_inner_parse(priv, (struct nft_pktinfo *)pkt, tun_ctx) < 0)\n\t\tgoto err;\n\n\tswitch (priv->expr_type) {\n\tcase NFT_INNER_EXPR_PAYLOAD:\n\t\tnft_payload_inner_eval((struct nft_expr *)&priv->expr, regs, pkt, tun_ctx);\n\t\tbreak;\n\tcase NFT_INNER_EXPR_META:\n\t\tnft_meta_inner_eval((struct nft_expr *)&priv->expr, regs, pkt, tun_ctx);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tgoto err;\n\t}\n\treturn;\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic const struct nla_policy nft_inner_policy[NFTA_INNER_MAX + 1] = {\n\t[NFTA_INNER_NUM]\t= { .type = NLA_U32 },\n\t[NFTA_INNER_FLAGS]\t= { .type = NLA_U32 },\n\t[NFTA_INNER_HDRSIZE]\t= { .type = NLA_U32 },\n\t[NFTA_INNER_TYPE]\t= { .type = NLA_U32 },\n\t[NFTA_INNER_EXPR]\t= { .type = NLA_NESTED },\n};\n\nstruct nft_expr_info {\n\tconst struct nft_expr_ops\t*ops;\n\tconst struct nlattr\t\t*attr;\n\tstruct nlattr\t\t\t*tb[NFT_EXPR_MAXATTR + 1];\n};\n\nstatic int nft_inner_init(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_inner *priv = nft_expr_priv(expr);\n\tu32 flags, hdrsize, type, num;\n\tstruct nft_expr_info expr_info;\n\tint err;\n\n\tif (!tb[NFTA_INNER_FLAGS] ||\n\t    !tb[NFTA_INNER_NUM] ||\n\t    !tb[NFTA_INNER_HDRSIZE] ||\n\t    !tb[NFTA_INNER_TYPE] ||\n\t    !tb[NFTA_INNER_EXPR])\n\t\treturn -EINVAL;\n\n\tflags = ntohl(nla_get_be32(tb[NFTA_INNER_FLAGS]));\n\tif (flags & ~NFT_INNER_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\tnum = ntohl(nla_get_be32(tb[NFTA_INNER_NUM]));\n\tif (num != 0)\n\t\treturn -EOPNOTSUPP;\n\n\thdrsize = ntohl(nla_get_be32(tb[NFTA_INNER_HDRSIZE]));\n\ttype = ntohl(nla_get_be32(tb[NFTA_INNER_TYPE]));\n\n\tif (type > U8_MAX)\n\t\treturn -EINVAL;\n\n\tif (flags & NFT_INNER_HDRSIZE) {\n\t\tif (hdrsize == 0 || hdrsize > 64)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->flags = flags;\n\tpriv->hdrsize = hdrsize;\n\tpriv->type = type;\n\n\terr = nft_expr_inner_parse(ctx, tb[NFTA_INNER_EXPR], &expr_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->expr.ops = expr_info.ops;\n\n\tif (!strcmp(expr_info.ops->type->name, \"payload\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_PAYLOAD;\n\telse if (!strcmp(expr_info.ops->type->name, \"meta\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_META;\n\telse\n\t\treturn -EINVAL;\n\n\terr = expr_info.ops->init(ctx, (struct nft_expr *)&priv->expr,\n\t\t\t\t  (const struct nlattr * const*)expr_info.tb);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int nft_inner_dump(struct sk_buff *skb,\n\t\t\t  const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_inner *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_INNER_NUM, htonl(0)) ||\n\t    nla_put_be32(skb, NFTA_INNER_TYPE, htonl(priv->type)) ||\n\t    nla_put_be32(skb, NFTA_INNER_FLAGS, htonl(priv->flags)) ||\n\t    nla_put_be32(skb, NFTA_INNER_HDRSIZE, htonl(priv->hdrsize)))\n\t\tgoto nla_put_failure;\n\n\tif (nft_expr_dump(skb, NFTA_INNER_EXPR,\n\t\t\t  (struct nft_expr *)&priv->expr, reset) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic const struct nft_expr_ops nft_inner_ops = {\n\t.type\t\t= &nft_inner_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_inner)),\n\t.eval\t\t= nft_inner_eval,\n\t.init\t\t= nft_inner_init,\n\t.dump\t\t= nft_inner_dump,\n};\n\nstruct nft_expr_type nft_inner_type __read_mostly = {\n\t.name\t\t= \"inner\",\n\t.ops\t\t= &nft_inner_ops,\n\t.policy\t\t= nft_inner_policy,\n\t.maxattr\t= NFTA_INNER_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}