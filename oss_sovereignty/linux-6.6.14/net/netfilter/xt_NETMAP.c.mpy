{
  "module_name": "xt_NETMAP.c",
  "hash_id": "3f3440ff2009f8ddfd0dc295caeea24268387a1c31fd141e444a27761dcf11d5",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_NETMAP.c",
  "human_readable_source": "\n \n\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/ipv6.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter/x_tables.h>\n#include <net/netfilter/nf_nat.h>\n\nstatic unsigned int\nnetmap_tg6(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct nf_nat_range2 *range = par->targinfo;\n\tstruct nf_nat_range2 newrange;\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\tunion nf_inet_addr new_addr, netmask;\n\tunsigned int i;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tfor (i = 0; i < ARRAY_SIZE(range->min_addr.ip6); i++)\n\t\tnetmask.ip6[i] = ~(range->min_addr.ip6[i] ^\n\t\t\t\t   range->max_addr.ip6[i]);\n\n\tif (xt_hooknum(par) == NF_INET_PRE_ROUTING ||\n\t    xt_hooknum(par) == NF_INET_LOCAL_OUT)\n\t\tnew_addr.in6 = ipv6_hdr(skb)->daddr;\n\telse\n\t\tnew_addr.in6 = ipv6_hdr(skb)->saddr;\n\n\tfor (i = 0; i < ARRAY_SIZE(new_addr.ip6); i++) {\n\t\tnew_addr.ip6[i] &= ~netmask.ip6[i];\n\t\tnew_addr.ip6[i] |= range->min_addr.ip6[i] &\n\t\t\t\t   netmask.ip6[i];\n\t}\n\n\tnewrange.flags\t= range->flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr\t= new_addr;\n\tnewrange.max_addr\t= new_addr;\n\tnewrange.min_proto\t= range->min_proto;\n\tnewrange.max_proto\t= range->max_proto;\n\n\treturn nf_nat_setup_info(ct, &newrange, HOOK2MANIP(xt_hooknum(par)));\n}\n\nstatic int netmap_tg6_checkentry(const struct xt_tgchk_param *par)\n{\n\tconst struct nf_nat_range2 *range = par->targinfo;\n\n\tif (!(range->flags & NF_NAT_RANGE_MAP_IPS))\n\t\treturn -EINVAL;\n\treturn nf_ct_netns_get(par->net, par->family);\n}\n\nstatic void netmap_tg_destroy(const struct xt_tgdtor_param *par)\n{\n\tnf_ct_netns_put(par->net, par->family);\n}\n\nstatic unsigned int\nnetmap_tg4(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 new_ip, netmask;\n\tconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\n\tstruct nf_nat_range2 newrange;\n\n\tWARN_ON(xt_hooknum(par) != NF_INET_PRE_ROUTING &&\n\t\txt_hooknum(par) != NF_INET_POST_ROUTING &&\n\t\txt_hooknum(par) != NF_INET_LOCAL_OUT &&\n\t\txt_hooknum(par) != NF_INET_LOCAL_IN);\n\tct = nf_ct_get(skb, &ctinfo);\n\n\tnetmask = ~(mr->range[0].min_ip ^ mr->range[0].max_ip);\n\n\tif (xt_hooknum(par) == NF_INET_PRE_ROUTING ||\n\t    xt_hooknum(par) == NF_INET_LOCAL_OUT)\n\t\tnew_ip = ip_hdr(skb)->daddr & ~netmask;\n\telse\n\t\tnew_ip = ip_hdr(skb)->saddr & ~netmask;\n\tnew_ip |= mr->range[0].min_ip & netmask;\n\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = new_ip;\n\tnewrange.max_addr.ip = new_ip;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\n\t \n\treturn nf_nat_setup_info(ct, &newrange, HOOK2MANIP(xt_hooknum(par)));\n}\n\nstatic int netmap_tg4_check(const struct xt_tgchk_param *par)\n{\n\tconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\n\n\tif (!(mr->range[0].flags & NF_NAT_RANGE_MAP_IPS)) {\n\t\tpr_debug(\"bad MAP_IPS.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (mr->rangesize != 1) {\n\t\tpr_debug(\"bad rangesize %u.\\n\", mr->rangesize);\n\t\treturn -EINVAL;\n\t}\n\treturn nf_ct_netns_get(par->net, par->family);\n}\n\nstatic struct xt_target netmap_tg_reg[] __read_mostly = {\n\t{\n\t\t.name       = \"NETMAP\",\n\t\t.family     = NFPROTO_IPV6,\n\t\t.revision   = 0,\n\t\t.target     = netmap_tg6,\n\t\t.targetsize = sizeof(struct nf_nat_range),\n\t\t.table      = \"nat\",\n\t\t.hooks      = (1 << NF_INET_PRE_ROUTING) |\n\t\t              (1 << NF_INET_POST_ROUTING) |\n\t\t              (1 << NF_INET_LOCAL_OUT) |\n\t\t              (1 << NF_INET_LOCAL_IN),\n\t\t.checkentry = netmap_tg6_checkentry,\n\t\t.destroy    = netmap_tg_destroy,\n\t\t.me         = THIS_MODULE,\n\t},\n\t{\n\t\t.name       = \"NETMAP\",\n\t\t.family     = NFPROTO_IPV4,\n\t\t.revision   = 0,\n\t\t.target     = netmap_tg4,\n\t\t.targetsize = sizeof(struct nf_nat_ipv4_multi_range_compat),\n\t\t.table      = \"nat\",\n\t\t.hooks      = (1 << NF_INET_PRE_ROUTING) |\n\t\t              (1 << NF_INET_POST_ROUTING) |\n\t\t              (1 << NF_INET_LOCAL_OUT) |\n\t\t              (1 << NF_INET_LOCAL_IN),\n\t\t.checkentry = netmap_tg4_check,\n\t\t.destroy    = netmap_tg_destroy,\n\t\t.me         = THIS_MODULE,\n\t},\n};\n\nstatic int __init netmap_tg_init(void)\n{\n\treturn xt_register_targets(netmap_tg_reg, ARRAY_SIZE(netmap_tg_reg));\n}\n\nstatic void netmap_tg_exit(void)\n{\n\txt_unregister_targets(netmap_tg_reg, ARRAY_SIZE(netmap_tg_reg));\n}\n\nmodule_init(netmap_tg_init);\nmodule_exit(netmap_tg_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Xtables: 1:1 NAT mapping of subnets\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_ALIAS(\"ip6t_NETMAP\");\nMODULE_ALIAS(\"ipt_NETMAP\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}