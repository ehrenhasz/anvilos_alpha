{
  "module_name": "nf_conntrack_proto_udp.c",
  "hash_id": "d28da91eb0ff7a47ff6161f94dee7c2bb019f95ae0b5f83edc160c3e0b141b09",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_proto_udp.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/module.h>\n#include <linux/udp.h>\n#include <linux/seq_file.h>\n#include <linux/skbuff.h>\n#include <linux/ipv6.h>\n#include <net/ip6_checksum.h>\n#include <net/checksum.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n#include <net/netfilter/nf_log.h>\n#include <net/netfilter/ipv4/nf_conntrack_ipv4.h>\n#include <net/netfilter/ipv6/nf_conntrack_ipv6.h>\n\nstatic const unsigned int udp_timeouts[UDP_CT_MAX] = {\n\t[UDP_CT_UNREPLIED]\t= 30*HZ,\n\t[UDP_CT_REPLIED]\t= 120*HZ,\n};\n\nstatic unsigned int *udp_get_timeouts(struct net *net)\n{\n\treturn nf_udp_pernet(net)->timeouts;\n}\n\nstatic void udp_error_log(const struct sk_buff *skb,\n\t\t\t  const struct nf_hook_state *state,\n\t\t\t  const char *msg)\n{\n\tnf_l4proto_log_invalid(skb, state, IPPROTO_UDP, \"%s\", msg);\n}\n\nstatic bool udp_error(struct sk_buff *skb,\n\t\t      unsigned int dataoff,\n\t\t      const struct nf_hook_state *state)\n{\n\tunsigned int udplen = skb->len - dataoff;\n\tconst struct udphdr *hdr;\n\tstruct udphdr _hdr;\n\n\t \n\thdr = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\n\tif (!hdr) {\n\t\tudp_error_log(skb, state, \"short packet\");\n\t\treturn true;\n\t}\n\n\t \n\tif (ntohs(hdr->len) > udplen || ntohs(hdr->len) < sizeof(*hdr)) {\n\t\tudp_error_log(skb, state, \"truncated/malformed packet\");\n\t\treturn true;\n\t}\n\n\t \n\tif (!hdr->check)\n\t\treturn false;\n\n\t \n\tif (state->hook == NF_INET_PRE_ROUTING &&\n\t    state->net->ct.sysctl_checksum &&\n\t    nf_checksum(skb, state->hook, dataoff, IPPROTO_UDP, state->pf)) {\n\t\tudp_error_log(skb, state, \"bad checksum\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nint nf_conntrack_udp_packet(struct nf_conn *ct,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    unsigned int dataoff,\n\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t    const struct nf_hook_state *state)\n{\n\tunsigned int *timeouts;\n\tunsigned long status;\n\n\tif (udp_error(skb, dataoff, state))\n\t\treturn -NF_ACCEPT;\n\n\ttimeouts = nf_ct_timeout_lookup(ct);\n\tif (!timeouts)\n\t\ttimeouts = udp_get_timeouts(nf_ct_net(ct));\n\n\tstatus = READ_ONCE(ct->status);\n\tif ((status & IPS_CONFIRMED) == 0)\n\t\tct->proto.udp.stream_ts = 2 * HZ + jiffies;\n\n\t \n\tif (status & IPS_SEEN_REPLY) {\n\t\tunsigned long extra = timeouts[UDP_CT_UNREPLIED];\n\t\tbool stream = false;\n\n\t\t \n\t\tif (time_after(jiffies, ct->proto.udp.stream_ts)) {\n\t\t\textra = timeouts[UDP_CT_REPLIED];\n\t\t\tstream = (status & IPS_ASSURED) == 0;\n\t\t}\n\n\t\tnf_ct_refresh_acct(ct, ctinfo, skb, extra);\n\n\t\t \n\t\tif (unlikely((status & IPS_NAT_CLASH)))\n\t\t\treturn NF_ACCEPT;\n\n\t\t \n\t\tif (stream && !test_and_set_bit(IPS_ASSURED_BIT, &ct->status))\n\t\t\tnf_conntrack_event_cache(IPCT_ASSURED, ct);\n\t} else {\n\t\tnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[UDP_CT_UNREPLIED]);\n\t}\n\treturn NF_ACCEPT;\n}\n\n#ifdef CONFIG_NF_CT_PROTO_UDPLITE\nstatic void udplite_error_log(const struct sk_buff *skb,\n\t\t\t      const struct nf_hook_state *state,\n\t\t\t      const char *msg)\n{\n\tnf_l4proto_log_invalid(skb, state, IPPROTO_UDPLITE, \"%s\", msg);\n}\n\nstatic bool udplite_error(struct sk_buff *skb,\n\t\t\t  unsigned int dataoff,\n\t\t\t  const struct nf_hook_state *state)\n{\n\tunsigned int udplen = skb->len - dataoff;\n\tconst struct udphdr *hdr;\n\tstruct udphdr _hdr;\n\tunsigned int cscov;\n\n\t \n\thdr = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\n\tif (!hdr) {\n\t\tudplite_error_log(skb, state, \"short packet\");\n\t\treturn true;\n\t}\n\n\tcscov = ntohs(hdr->len);\n\tif (cscov == 0) {\n\t\tcscov = udplen;\n\t} else if (cscov < sizeof(*hdr) || cscov > udplen) {\n\t\tudplite_error_log(skb, state, \"invalid checksum coverage\");\n\t\treturn true;\n\t}\n\n\t \n\tif (!hdr->check) {\n\t\tudplite_error_log(skb, state, \"checksum missing\");\n\t\treturn true;\n\t}\n\n\t \n\tif (state->hook == NF_INET_PRE_ROUTING &&\n\t    state->net->ct.sysctl_checksum &&\n\t    nf_checksum_partial(skb, state->hook, dataoff, cscov, IPPROTO_UDP,\n\t\t\t\tstate->pf)) {\n\t\tudplite_error_log(skb, state, \"bad checksum\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nint nf_conntrack_udplite_packet(struct nf_conn *ct,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tunsigned int dataoff,\n\t\t\t\tenum ip_conntrack_info ctinfo,\n\t\t\t\tconst struct nf_hook_state *state)\n{\n\tunsigned int *timeouts;\n\n\tif (udplite_error(skb, dataoff, state))\n\t\treturn -NF_ACCEPT;\n\n\ttimeouts = nf_ct_timeout_lookup(ct);\n\tif (!timeouts)\n\t\ttimeouts = udp_get_timeouts(nf_ct_net(ct));\n\n\t \n\tif (test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\n\t\tnf_ct_refresh_acct(ct, ctinfo, skb,\n\t\t\t\t   timeouts[UDP_CT_REPLIED]);\n\n\t\tif (unlikely((ct->status & IPS_NAT_CLASH)))\n\t\t\treturn NF_ACCEPT;\n\n\t\t \n\t\tif (!test_and_set_bit(IPS_ASSURED_BIT, &ct->status))\n\t\t\tnf_conntrack_event_cache(IPCT_ASSURED, ct);\n\t} else {\n\t\tnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[UDP_CT_UNREPLIED]);\n\t}\n\treturn NF_ACCEPT;\n}\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_cttimeout.h>\n\nstatic int udp_timeout_nlattr_to_obj(struct nlattr *tb[],\n\t\t\t\t     struct net *net, void *data)\n{\n\tunsigned int *timeouts = data;\n\tstruct nf_udp_net *un = nf_udp_pernet(net);\n\n\tif (!timeouts)\n\t\ttimeouts = un->timeouts;\n\n\t \n\ttimeouts[UDP_CT_UNREPLIED] = un->timeouts[UDP_CT_UNREPLIED];\n\ttimeouts[UDP_CT_REPLIED] = un->timeouts[UDP_CT_REPLIED];\n\n\tif (tb[CTA_TIMEOUT_UDP_UNREPLIED]) {\n\t\ttimeouts[UDP_CT_UNREPLIED] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_UDP_UNREPLIED])) * HZ;\n\t}\n\tif (tb[CTA_TIMEOUT_UDP_REPLIED]) {\n\t\ttimeouts[UDP_CT_REPLIED] =\n\t\t\tntohl(nla_get_be32(tb[CTA_TIMEOUT_UDP_REPLIED])) * HZ;\n\t}\n\treturn 0;\n}\n\nstatic int\nudp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\n{\n\tconst unsigned int *timeouts = data;\n\n\tif (nla_put_be32(skb, CTA_TIMEOUT_UDP_UNREPLIED,\n\t\t\t htonl(timeouts[UDP_CT_UNREPLIED] / HZ)) ||\n\t    nla_put_be32(skb, CTA_TIMEOUT_UDP_REPLIED,\n\t\t\t htonl(timeouts[UDP_CT_REPLIED] / HZ)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic const struct nla_policy\nudp_timeout_nla_policy[CTA_TIMEOUT_UDP_MAX+1] = {\n       [CTA_TIMEOUT_UDP_UNREPLIED]\t= { .type = NLA_U32 },\n       [CTA_TIMEOUT_UDP_REPLIED]\t= { .type = NLA_U32 },\n};\n#endif  \n\nvoid nf_conntrack_udp_init_net(struct net *net)\n{\n\tstruct nf_udp_net *un = nf_udp_pernet(net);\n\tint i;\n\n\tfor (i = 0; i < UDP_CT_MAX; i++)\n\t\tun->timeouts[i] = udp_timeouts[i];\n\n#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)\n\tun->offload_timeout = 30 * HZ;\n#endif\n}\n\nconst struct nf_conntrack_l4proto nf_conntrack_l4proto_udp =\n{\n\t.l4proto\t\t= IPPROTO_UDP,\n\t.allow_clash\t\t= true,\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.tuple_to_nlattr\t= nf_ct_port_tuple_to_nlattr,\n\t.nlattr_to_tuple\t= nf_ct_port_nlattr_to_tuple,\n\t.nlattr_tuple_size\t= nf_ct_port_nlattr_tuple_size,\n\t.nla_policy\t\t= nf_ct_port_nla_policy,\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\t.ctnl_timeout\t\t= {\n\t\t.nlattr_to_obj\t= udp_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= udp_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_UDP_MAX,\n\t\t.obj_size\t= sizeof(unsigned int) * CTA_TIMEOUT_UDP_MAX,\n\t\t.nla_policy\t= udp_timeout_nla_policy,\n\t},\n#endif  \n};\n\n#ifdef CONFIG_NF_CT_PROTO_UDPLITE\nconst struct nf_conntrack_l4proto nf_conntrack_l4proto_udplite =\n{\n\t.l4proto\t\t= IPPROTO_UDPLITE,\n\t.allow_clash\t\t= true,\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.tuple_to_nlattr\t= nf_ct_port_tuple_to_nlattr,\n\t.nlattr_to_tuple\t= nf_ct_port_nlattr_to_tuple,\n\t.nlattr_tuple_size\t= nf_ct_port_nlattr_tuple_size,\n\t.nla_policy\t\t= nf_ct_port_nla_policy,\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\t.ctnl_timeout\t\t= {\n\t\t.nlattr_to_obj\t= udp_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= udp_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_UDP_MAX,\n\t\t.obj_size\t= sizeof(unsigned int) * CTA_TIMEOUT_UDP_MAX,\n\t\t.nla_policy\t= udp_timeout_nla_policy,\n\t},\n#endif  \n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}