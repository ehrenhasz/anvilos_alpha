{
  "module_name": "nft_counter.c",
  "hash_id": "8bdc247b57f7673d95940aee1eb9064b4d629b66ef5fc1ecfb59b71a43c14dba",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_counter.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/seqlock.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables_offload.h>\n\nstruct nft_counter {\n\ts64\t\tbytes;\n\ts64\t\tpackets;\n};\n\nstruct nft_counter_percpu_priv {\n\tstruct nft_counter __percpu *counter;\n};\n\nstatic DEFINE_PER_CPU(seqcount_t, nft_counter_seq);\n\nstatic inline void nft_counter_do_eval(struct nft_counter_percpu_priv *priv,\n\t\t\t\t       struct nft_regs *regs,\n\t\t\t\t       const struct nft_pktinfo *pkt)\n{\n\tstruct nft_counter *this_cpu;\n\tseqcount_t *myseq;\n\n\tlocal_bh_disable();\n\tthis_cpu = this_cpu_ptr(priv->counter);\n\tmyseq = this_cpu_ptr(&nft_counter_seq);\n\n\twrite_seqcount_begin(myseq);\n\n\tthis_cpu->bytes += pkt->skb->len;\n\tthis_cpu->packets++;\n\n\twrite_seqcount_end(myseq);\n\tlocal_bh_enable();\n}\n\nstatic inline void nft_counter_obj_eval(struct nft_object *obj,\n\t\t\t\t\tstruct nft_regs *regs,\n\t\t\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tstruct nft_counter_percpu_priv *priv = nft_obj_data(obj);\n\n\tnft_counter_do_eval(priv, regs, pkt);\n}\n\nstatic int nft_counter_do_init(const struct nlattr * const tb[],\n\t\t\t       struct nft_counter_percpu_priv *priv)\n{\n\tstruct nft_counter __percpu *cpu_stats;\n\tstruct nft_counter *this_cpu;\n\n\tcpu_stats = alloc_percpu_gfp(struct nft_counter, GFP_KERNEL_ACCOUNT);\n\tif (cpu_stats == NULL)\n\t\treturn -ENOMEM;\n\n\tpreempt_disable();\n\tthis_cpu = this_cpu_ptr(cpu_stats);\n\tif (tb[NFTA_COUNTER_PACKETS]) {\n\t        this_cpu->packets =\n\t\t\tbe64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));\n\t}\n\tif (tb[NFTA_COUNTER_BYTES]) {\n\t\tthis_cpu->bytes =\n\t\t\tbe64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));\n\t}\n\tpreempt_enable();\n\tpriv->counter = cpu_stats;\n\treturn 0;\n}\n\nstatic int nft_counter_obj_init(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nlattr * const tb[],\n\t\t\t\tstruct nft_object *obj)\n{\n\tstruct nft_counter_percpu_priv *priv = nft_obj_data(obj);\n\n\treturn nft_counter_do_init(tb, priv);\n}\n\nstatic void nft_counter_do_destroy(struct nft_counter_percpu_priv *priv)\n{\n\tfree_percpu(priv->counter);\n}\n\nstatic void nft_counter_obj_destroy(const struct nft_ctx *ctx,\n\t\t\t\t    struct nft_object *obj)\n{\n\tstruct nft_counter_percpu_priv *priv = nft_obj_data(obj);\n\n\tnft_counter_do_destroy(priv);\n}\n\nstatic void nft_counter_reset(struct nft_counter_percpu_priv *priv,\n\t\t\t      struct nft_counter *total)\n{\n\tstruct nft_counter *this_cpu;\n\n\tlocal_bh_disable();\n\tthis_cpu = this_cpu_ptr(priv->counter);\n\tthis_cpu->packets -= total->packets;\n\tthis_cpu->bytes -= total->bytes;\n\tlocal_bh_enable();\n}\n\nstatic void nft_counter_fetch(struct nft_counter_percpu_priv *priv,\n\t\t\t      struct nft_counter *total)\n{\n\tstruct nft_counter *this_cpu;\n\tconst seqcount_t *myseq;\n\tu64 bytes, packets;\n\tunsigned int seq;\n\tint cpu;\n\n\tmemset(total, 0, sizeof(*total));\n\tfor_each_possible_cpu(cpu) {\n\t\tmyseq = per_cpu_ptr(&nft_counter_seq, cpu);\n\t\tthis_cpu = per_cpu_ptr(priv->counter, cpu);\n\t\tdo {\n\t\t\tseq\t= read_seqcount_begin(myseq);\n\t\t\tbytes\t= this_cpu->bytes;\n\t\t\tpackets\t= this_cpu->packets;\n\t\t} while (read_seqcount_retry(myseq, seq));\n\n\t\ttotal->bytes\t+= bytes;\n\t\ttotal->packets\t+= packets;\n\t}\n}\n\nstatic int nft_counter_do_dump(struct sk_buff *skb,\n\t\t\t       struct nft_counter_percpu_priv *priv,\n\t\t\t       bool reset)\n{\n\tstruct nft_counter total;\n\n\tnft_counter_fetch(priv, &total);\n\n\tif (nla_put_be64(skb, NFTA_COUNTER_BYTES, cpu_to_be64(total.bytes),\n\t\t\t NFTA_COUNTER_PAD) ||\n\t    nla_put_be64(skb, NFTA_COUNTER_PACKETS, cpu_to_be64(total.packets),\n\t\t\t NFTA_COUNTER_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (reset)\n\t\tnft_counter_reset(priv, &total);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_counter_obj_dump(struct sk_buff *skb,\n\t\t\t\tstruct nft_object *obj, bool reset)\n{\n\tstruct nft_counter_percpu_priv *priv = nft_obj_data(obj);\n\n\treturn nft_counter_do_dump(skb, priv, reset);\n}\n\nstatic const struct nla_policy nft_counter_policy[NFTA_COUNTER_MAX + 1] = {\n\t[NFTA_COUNTER_PACKETS]\t= { .type = NLA_U64 },\n\t[NFTA_COUNTER_BYTES]\t= { .type = NLA_U64 },\n};\n\nstruct nft_object_type nft_counter_obj_type;\nstatic const struct nft_object_ops nft_counter_obj_ops = {\n\t.type\t\t= &nft_counter_obj_type,\n\t.size\t\t= sizeof(struct nft_counter_percpu_priv),\n\t.eval\t\t= nft_counter_obj_eval,\n\t.init\t\t= nft_counter_obj_init,\n\t.destroy\t= nft_counter_obj_destroy,\n\t.dump\t\t= nft_counter_obj_dump,\n};\n\nstruct nft_object_type nft_counter_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_COUNTER,\n\t.ops\t\t= &nft_counter_obj_ops,\n\t.maxattr\t= NFTA_COUNTER_MAX,\n\t.policy\t\t= nft_counter_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n\nvoid nft_counter_eval(const struct nft_expr *expr, struct nft_regs *regs,\n\t\t      const struct nft_pktinfo *pkt)\n{\n\tstruct nft_counter_percpu_priv *priv = nft_expr_priv(expr);\n\n\tnft_counter_do_eval(priv, regs, pkt);\n}\n\nstatic int nft_counter_dump(struct sk_buff *skb,\n\t\t\t    const struct nft_expr *expr, bool reset)\n{\n\tstruct nft_counter_percpu_priv *priv = nft_expr_priv(expr);\n\n\treturn nft_counter_do_dump(skb, priv, reset);\n}\n\nstatic int nft_counter_init(const struct nft_ctx *ctx,\n\t\t\t    const struct nft_expr *expr,\n\t\t\t    const struct nlattr * const tb[])\n{\n\tstruct nft_counter_percpu_priv *priv = nft_expr_priv(expr);\n\n\treturn nft_counter_do_init(tb, priv);\n}\n\nstatic void nft_counter_destroy(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_counter_percpu_priv *priv = nft_expr_priv(expr);\n\n\tnft_counter_do_destroy(priv);\n}\n\nstatic int nft_counter_clone(struct nft_expr *dst, const struct nft_expr *src)\n{\n\tstruct nft_counter_percpu_priv *priv = nft_expr_priv(src);\n\tstruct nft_counter_percpu_priv *priv_clone = nft_expr_priv(dst);\n\tstruct nft_counter __percpu *cpu_stats;\n\tstruct nft_counter *this_cpu;\n\tstruct nft_counter total;\n\n\tnft_counter_fetch(priv, &total);\n\n\tcpu_stats = alloc_percpu_gfp(struct nft_counter, GFP_ATOMIC);\n\tif (cpu_stats == NULL)\n\t\treturn -ENOMEM;\n\n\tpreempt_disable();\n\tthis_cpu = this_cpu_ptr(cpu_stats);\n\tthis_cpu->packets = total.packets;\n\tthis_cpu->bytes = total.bytes;\n\tpreempt_enable();\n\n\tpriv_clone->counter = cpu_stats;\n\treturn 0;\n}\n\nstatic int nft_counter_offload(struct nft_offload_ctx *ctx,\n\t\t\t       struct nft_flow_rule *flow,\n\t\t\t       const struct nft_expr *expr)\n{\n\t \n\treturn 0;\n}\n\nstatic void nft_counter_offload_stats(struct nft_expr *expr,\n\t\t\t\t      const struct flow_stats *stats)\n{\n\tstruct nft_counter_percpu_priv *priv = nft_expr_priv(expr);\n\tstruct nft_counter *this_cpu;\n\tseqcount_t *myseq;\n\n\tpreempt_disable();\n\tthis_cpu = this_cpu_ptr(priv->counter);\n\tmyseq = this_cpu_ptr(&nft_counter_seq);\n\n\twrite_seqcount_begin(myseq);\n\tthis_cpu->packets += stats->pkts;\n\tthis_cpu->bytes += stats->bytes;\n\twrite_seqcount_end(myseq);\n\tpreempt_enable();\n}\n\nvoid nft_counter_init_seqcount(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(per_cpu_ptr(&nft_counter_seq, cpu));\n}\n\nstruct nft_expr_type nft_counter_type;\nstatic const struct nft_expr_ops nft_counter_ops = {\n\t.type\t\t= &nft_counter_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_counter_percpu_priv)),\n\t.eval\t\t= nft_counter_eval,\n\t.init\t\t= nft_counter_init,\n\t.destroy\t= nft_counter_destroy,\n\t.destroy_clone\t= nft_counter_destroy,\n\t.dump\t\t= nft_counter_dump,\n\t.clone\t\t= nft_counter_clone,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n\t.offload\t= nft_counter_offload,\n\t.offload_stats\t= nft_counter_offload_stats,\n};\n\nstruct nft_expr_type nft_counter_type __read_mostly = {\n\t.name\t\t= \"counter\",\n\t.ops\t\t= &nft_counter_ops,\n\t.policy\t\t= nft_counter_policy,\n\t.maxattr\t= NFTA_COUNTER_MAX,\n\t.flags\t\t= NFT_EXPR_STATEFUL,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}