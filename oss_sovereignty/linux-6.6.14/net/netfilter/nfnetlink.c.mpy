{
  "module_name": "nfnetlink.c",
  "hash_id": "e36f9ff7643a4f4d6b9385f53a1662c9939dc8f21ff0985cbf5ca2421b10bdb2",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nfnetlink.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/uaccess.h>\n#include <net/sock.h>\n#include <linux/init.h>\n#include <linux/sched/signal.h>\n\n#include <net/netlink.h>\n#include <net/netns/generic.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_NETFILTER);\nMODULE_DESCRIPTION(\"Netfilter messages via netlink socket\");\n\n#define nfnl_dereference_protected(id) \\\n\trcu_dereference_protected(table[(id)].subsys, \\\n\t\t\t\t  lockdep_nfnl_is_held((id)))\n\n#define NFNL_MAX_ATTR_COUNT\t32\n\nstatic unsigned int nfnetlink_pernet_id __read_mostly;\n\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\nstatic DEFINE_SPINLOCK(nfnl_grp_active_lock);\n#endif\n\nstruct nfnl_net {\n\tstruct sock *nfnl;\n};\n\nstatic struct {\n\tstruct mutex\t\t\t\tmutex;\n\tconst struct nfnetlink_subsystem __rcu\t*subsys;\n} table[NFNL_SUBSYS_COUNT];\n\nstatic struct lock_class_key nfnl_lockdep_keys[NFNL_SUBSYS_COUNT];\n\nstatic const char *const nfnl_lockdep_names[NFNL_SUBSYS_COUNT] = {\n\t[NFNL_SUBSYS_NONE] = \"nfnl_subsys_none\",\n\t[NFNL_SUBSYS_CTNETLINK] = \"nfnl_subsys_ctnetlink\",\n\t[NFNL_SUBSYS_CTNETLINK_EXP] = \"nfnl_subsys_ctnetlink_exp\",\n\t[NFNL_SUBSYS_QUEUE] = \"nfnl_subsys_queue\",\n\t[NFNL_SUBSYS_ULOG] = \"nfnl_subsys_ulog\",\n\t[NFNL_SUBSYS_OSF] = \"nfnl_subsys_osf\",\n\t[NFNL_SUBSYS_IPSET] = \"nfnl_subsys_ipset\",\n\t[NFNL_SUBSYS_ACCT] = \"nfnl_subsys_acct\",\n\t[NFNL_SUBSYS_CTNETLINK_TIMEOUT] = \"nfnl_subsys_cttimeout\",\n\t[NFNL_SUBSYS_CTHELPER] = \"nfnl_subsys_cthelper\",\n\t[NFNL_SUBSYS_NFTABLES] = \"nfnl_subsys_nftables\",\n\t[NFNL_SUBSYS_NFT_COMPAT] = \"nfnl_subsys_nftcompat\",\n\t[NFNL_SUBSYS_HOOK] = \"nfnl_subsys_hook\",\n};\n\nstatic const int nfnl_group2type[NFNLGRP_MAX+1] = {\n\t[NFNLGRP_CONNTRACK_NEW]\t\t= NFNL_SUBSYS_CTNETLINK,\n\t[NFNLGRP_CONNTRACK_UPDATE]\t= NFNL_SUBSYS_CTNETLINK,\n\t[NFNLGRP_CONNTRACK_DESTROY]\t= NFNL_SUBSYS_CTNETLINK,\n\t[NFNLGRP_CONNTRACK_EXP_NEW]\t= NFNL_SUBSYS_CTNETLINK_EXP,\n\t[NFNLGRP_CONNTRACK_EXP_UPDATE]\t= NFNL_SUBSYS_CTNETLINK_EXP,\n\t[NFNLGRP_CONNTRACK_EXP_DESTROY] = NFNL_SUBSYS_CTNETLINK_EXP,\n\t[NFNLGRP_NFTABLES]\t\t= NFNL_SUBSYS_NFTABLES,\n\t[NFNLGRP_ACCT_QUOTA]\t\t= NFNL_SUBSYS_ACCT,\n\t[NFNLGRP_NFTRACE]\t\t= NFNL_SUBSYS_NFTABLES,\n};\n\nstatic struct nfnl_net *nfnl_pernet(struct net *net)\n{\n\treturn net_generic(net, nfnetlink_pernet_id);\n}\n\nvoid nfnl_lock(__u8 subsys_id)\n{\n\tmutex_lock(&table[subsys_id].mutex);\n}\nEXPORT_SYMBOL_GPL(nfnl_lock);\n\nvoid nfnl_unlock(__u8 subsys_id)\n{\n\tmutex_unlock(&table[subsys_id].mutex);\n}\nEXPORT_SYMBOL_GPL(nfnl_unlock);\n\n#ifdef CONFIG_PROVE_LOCKING\nbool lockdep_nfnl_is_held(u8 subsys_id)\n{\n\treturn lockdep_is_held(&table[subsys_id].mutex);\n}\nEXPORT_SYMBOL_GPL(lockdep_nfnl_is_held);\n#endif\n\nint nfnetlink_subsys_register(const struct nfnetlink_subsystem *n)\n{\n\tu8 cb_id;\n\n\t \n\tfor (cb_id = 0; cb_id < n->cb_count; cb_id++)\n\t\tif (WARN_ON(n->cb[cb_id].attr_count > NFNL_MAX_ATTR_COUNT))\n\t\t\treturn -EINVAL;\n\n\tnfnl_lock(n->subsys_id);\n\tif (table[n->subsys_id].subsys) {\n\t\tnfnl_unlock(n->subsys_id);\n\t\treturn -EBUSY;\n\t}\n\trcu_assign_pointer(table[n->subsys_id].subsys, n);\n\tnfnl_unlock(n->subsys_id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfnetlink_subsys_register);\n\nint nfnetlink_subsys_unregister(const struct nfnetlink_subsystem *n)\n{\n\tnfnl_lock(n->subsys_id);\n\ttable[n->subsys_id].subsys = NULL;\n\tnfnl_unlock(n->subsys_id);\n\tsynchronize_rcu();\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfnetlink_subsys_unregister);\n\nstatic inline const struct nfnetlink_subsystem *nfnetlink_get_subsys(u16 type)\n{\n\tu8 subsys_id = NFNL_SUBSYS_ID(type);\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn NULL;\n\n\treturn rcu_dereference(table[subsys_id].subsys);\n}\n\nstatic inline const struct nfnl_callback *\nnfnetlink_find_client(u16 type, const struct nfnetlink_subsystem *ss)\n{\n\tu8 cb_id = NFNL_MSG_TYPE(type);\n\n\tif (cb_id >= ss->cb_count)\n\t\treturn NULL;\n\n\treturn &ss->cb[cb_id];\n}\n\nint nfnetlink_has_listeners(struct net *net, unsigned int group)\n{\n\tstruct nfnl_net *nfnlnet = nfnl_pernet(net);\n\n\treturn netlink_has_listeners(nfnlnet->nfnl, group);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_has_listeners);\n\nint nfnetlink_send(struct sk_buff *skb, struct net *net, u32 portid,\n\t\t   unsigned int group, int echo, gfp_t flags)\n{\n\tstruct nfnl_net *nfnlnet = nfnl_pernet(net);\n\n\treturn nlmsg_notify(nfnlnet->nfnl, skb, portid, group, echo, flags);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_send);\n\nint nfnetlink_set_err(struct net *net, u32 portid, u32 group, int error)\n{\n\tstruct nfnl_net *nfnlnet = nfnl_pernet(net);\n\n\treturn netlink_set_err(nfnlnet->nfnl, portid, group, error);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_set_err);\n\nint nfnetlink_unicast(struct sk_buff *skb, struct net *net, u32 portid)\n{\n\tstruct nfnl_net *nfnlnet = nfnl_pernet(net);\n\tint err;\n\n\terr = nlmsg_unicast(nfnlnet->nfnl, skb, portid);\n\tif (err == -EAGAIN)\n\t\terr = -ENOBUFS;\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfnetlink_unicast);\n\nvoid nfnetlink_broadcast(struct net *net, struct sk_buff *skb, __u32 portid,\n\t\t\t __u32 group, gfp_t allocation)\n{\n\tstruct nfnl_net *nfnlnet = nfnl_pernet(net);\n\n\tnetlink_broadcast(nfnlnet->nfnl, skb, portid, group, allocation);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_broadcast);\n\n \nstatic int nfnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnl_callback *nc;\n\tconst struct nfnetlink_subsystem *ss;\n\tint type, err;\n\n\t \n\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg))\n\t\treturn 0;\n\n\ttype = nlh->nlmsg_type;\nreplay:\n\trcu_read_lock();\n\n\tss = nfnetlink_get_subsys(type);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\trcu_read_unlock();\n\t\trequest_module(\"nfnetlink-subsys-%d\", NFNL_SUBSYS_ID(type));\n\t\trcu_read_lock();\n\t\tss = nfnetlink_get_subsys(type);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\trcu_read_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnc = nfnetlink_find_client(type, ss);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t{\n\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\tstruct nfnl_net *nfnlnet = nfnl_pernet(net);\n\t\tu8 cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\tstruct nlattr *cda[NFNL_MAX_ATTR_COUNT + 1];\n\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\tint attrlen = nlh->nlmsg_len - min_len;\n\t\t__u8 subsys_id = NFNL_SUBSYS_ID(type);\n\t\tstruct nfnl_info info = {\n\t\t\t.net\t= net,\n\t\t\t.sk\t= nfnlnet->nfnl,\n\t\t\t.nlh\t= nlh,\n\t\t\t.nfmsg\t= nlmsg_data(nlh),\n\t\t\t.extack\t= extack,\n\t\t};\n\n\t\t \n\t\tif (ss->cb[cb_id].attr_count > NFNL_MAX_ATTR_COUNT) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = nla_parse_deprecated(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\t   attr, attrlen,\n\t\t\t\t\t   ss->cb[cb_id].policy, extack);\n\t\tif (err < 0) {\n\t\t\trcu_read_unlock();\n\t\t\treturn err;\n\t\t}\n\n\t\tif (!nc->call) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (nc->type) {\n\t\tcase NFNL_CB_RCU:\n\t\t\terr = nc->call(skb, &info, (const struct nlattr **)cda);\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase NFNL_CB_MUTEX:\n\t\t\trcu_read_unlock();\n\t\t\tnfnl_lock(subsys_id);\n\t\t\tif (nfnl_dereference_protected(subsys_id) != ss ||\n\t\t\t    nfnetlink_find_client(type, ss) != nc) {\n\t\t\t\tnfnl_unlock(subsys_id);\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = nc->call(skb, &info, (const struct nlattr **)cda);\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trcu_read_unlock();\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (err == -EAGAIN)\n\t\t\tgoto replay;\n\t\treturn err;\n\t}\n}\n\nstruct nfnl_err {\n\tstruct list_head\thead;\n\tstruct nlmsghdr\t\t*nlh;\n\tint\t\t\terr;\n\tstruct netlink_ext_ack\textack;\n};\n\nstatic int nfnl_err_add(struct list_head *list, struct nlmsghdr *nlh, int err,\n\t\t\tconst struct netlink_ext_ack *extack)\n{\n\tstruct nfnl_err *nfnl_err;\n\n\tnfnl_err = kmalloc(sizeof(struct nfnl_err), GFP_KERNEL);\n\tif (nfnl_err == NULL)\n\t\treturn -ENOMEM;\n\n\tnfnl_err->nlh = nlh;\n\tnfnl_err->err = err;\n\tnfnl_err->extack = *extack;\n\tlist_add_tail(&nfnl_err->head, list);\n\n\treturn 0;\n}\n\nstatic void nfnl_err_del(struct nfnl_err *nfnl_err)\n{\n\tlist_del(&nfnl_err->head);\n\tkfree(nfnl_err);\n}\n\nstatic void nfnl_err_reset(struct list_head *err_list)\n{\n\tstruct nfnl_err *nfnl_err, *next;\n\n\tlist_for_each_entry_safe(nfnl_err, next, err_list, head)\n\t\tnfnl_err_del(nfnl_err);\n}\n\nstatic void nfnl_err_deliver(struct list_head *err_list, struct sk_buff *skb)\n{\n\tstruct nfnl_err *nfnl_err, *next;\n\n\tlist_for_each_entry_safe(nfnl_err, next, err_list, head) {\n\t\tnetlink_ack(skb, nfnl_err->nlh, nfnl_err->err,\n\t\t\t    &nfnl_err->extack);\n\t\tnfnl_err_del(nfnl_err);\n\t}\n}\n\nenum {\n\tNFNL_BATCH_FAILURE\t= (1 << 0),\n\tNFNL_BATCH_DONE\t\t= (1 << 1),\n\tNFNL_BATCH_REPLAY\t= (1 << 2),\n};\n\nstatic void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu16 subsys_id, u32 genid)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstruct netlink_ext_ack extack;\n\tLIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL, NULL);\nreplay:\n\tstatus = 0;\nreplay_abort:\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM, NULL);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP, NULL);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->valid_genid || !ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP, NULL);\n\t\treturn kfree_skb(skb);\n\t}\n\n\tif (!try_module_get(ss->owner)) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP, NULL);\n\t\treturn kfree_skb(skb);\n\t}\n\n\tif (!ss->valid_genid(net, genid)) {\n\t\tmodule_put(ss->owner);\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -ERESTART, NULL);\n\t\treturn kfree_skb(skb);\n\t}\n\n\tnfnl_unlock(subsys_id);\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\terr = -EINTR;\n\t\t\tstatus = NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\tmemset(&extack, 0, sizeof(extack));\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t\t    skb->len < nlh->nlmsg_len ||\n\t\t    nlmsg_len(nlh) < sizeof(struct nfgenmsg)) {\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t \n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t \n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tif (nc->type != NFNL_CB_BATCH) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tstruct nfnl_net *nfnlnet = nfnl_pernet(net);\n\t\t\tstruct nlattr *cda[NFNL_MAX_ATTR_COUNT + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tu8 cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\t\t\tstruct nfnl_info info = {\n\t\t\t\t.net\t= net,\n\t\t\t\t.sk\t= nfnlnet->nfnl,\n\t\t\t\t.nlh\t= nlh,\n\t\t\t\t.nfmsg\t= nlmsg_data(nlh),\n\t\t\t\t.extack\t= &extack,\n\t\t\t};\n\n\t\t\t \n\t\t\tif (ss->cb[cb_id].attr_count > NFNL_MAX_ATTR_COUNT) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\terr = nla_parse_deprecated(cda,\n\t\t\t\t\t\t   ss->cb[cb_id].attr_count,\n\t\t\t\t\t\t   attr, attrlen,\n\t\t\t\t\t\t   ss->cb[cb_id].policy, NULL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\terr = nc->call(skb, &info, (const struct nlattr **)cda);\n\n\t\t\t \n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t \n\t\t\tif (err == -ENOMEM ||\n\t\t\t    nfnl_err_add(&err_list, nlh, err, &extack) < 0) {\n\t\t\t\t \n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM,\n\t\t\t\t\t    NULL);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t \n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\n\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb, NFNL_ABORT_AUTOLOAD);\n\t\tnfnl_err_reset(&err_list);\n\t\tkfree_skb(skb);\n\t\tmodule_put(ss->owner);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\terr = ss->commit(net, oskb);\n\t\tif (err == -EAGAIN) {\n\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\tgoto done;\n\t\t} else if (err) {\n\t\t\tss->abort(net, oskb, NFNL_ABORT_NONE);\n\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), err, NULL);\n\t\t}\n\t} else {\n\t\tenum nfnl_abort_action abort_action;\n\n\t\tif (status & NFNL_BATCH_FAILURE)\n\t\t\tabort_action = NFNL_ABORT_NONE;\n\t\telse\n\t\t\tabort_action = NFNL_ABORT_VALIDATE;\n\n\t\terr = ss->abort(net, oskb, abort_action);\n\t\tif (err == -EAGAIN) {\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tkfree_skb(skb);\n\t\t\tmodule_put(ss->owner);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto replay_abort;\n\t\t}\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tkfree_skb(skb);\n\tmodule_put(ss->owner);\n}\n\nstatic const struct nla_policy nfnl_batch_policy[NFNL_BATCH_MAX + 1] = {\n\t[NFNL_BATCH_GENID]\t= { .type = NLA_U32 },\n};\n\nstatic void nfnetlink_rcv_skb_batch(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\tstruct nlattr *attr = (void *)nlh + min_len;\n\tstruct nlattr *cda[NFNL_BATCH_MAX + 1];\n\tint attrlen = nlh->nlmsg_len - min_len;\n\tstruct nfgenmsg *nfgenmsg;\n\tint msglen, err;\n\tu32 gen_id = 0;\n\tu16 res_id;\n\n\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\tif (msglen > skb->len)\n\t\tmsglen = skb->len;\n\n\tif (skb->len < NLMSG_HDRLEN + sizeof(struct nfgenmsg))\n\t\treturn;\n\n\terr = nla_parse_deprecated(cda, NFNL_BATCH_MAX, attr, attrlen,\n\t\t\t\t   nfnl_batch_policy, NULL);\n\tif (err < 0) {\n\t\tnetlink_ack(skb, nlh, err, NULL);\n\t\treturn;\n\t}\n\tif (cda[NFNL_BATCH_GENID])\n\t\tgen_id = ntohl(nla_get_be32(cda[NFNL_BATCH_GENID]));\n\n\tnfgenmsg = nlmsg_data(nlh);\n\tskb_pull(skb, msglen);\n\t \n\tif (nfgenmsg->res_id == (__force __be16)NFNL_SUBSYS_NFTABLES)\n\t\tres_id = NFNL_SUBSYS_NFTABLES;\n\telse\n\t\tres_id = ntohs(nfgenmsg->res_id);\n\n\tnfnetlink_rcv_batch(skb, nlh, res_id, gen_id);\n}\n\nstatic void nfnetlink_rcv(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\n\tif (skb->len < NLMSG_HDRLEN ||\n\t    nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t    skb->len < nlh->nlmsg_len)\n\t\treturn;\n\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN)) {\n\t\tnetlink_ack(skb, nlh, -EPERM, NULL);\n\t\treturn;\n\t}\n\n\tif (nlh->nlmsg_type == NFNL_MSG_BATCH_BEGIN)\n\t\tnfnetlink_rcv_skb_batch(skb, nlh);\n\telse\n\t\tnetlink_rcv_skb(skb, nfnetlink_rcv_msg);\n}\n\nstatic void nfnetlink_bind_event(struct net *net, unsigned int group)\n{\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tint type, group_bit;\n\tu8 v;\n\n\t \n\tif (group >= 8)\n\t\treturn;\n\n\ttype = nfnl_group2type[group];\n\n\tswitch (type) {\n\tcase NFNL_SUBSYS_CTNETLINK:\n\t\tbreak;\n\tcase NFNL_SUBSYS_CTNETLINK_EXP:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tgroup_bit = (1 << group);\n\n\tspin_lock(&nfnl_grp_active_lock);\n\tv = READ_ONCE(nf_ctnetlink_has_listener);\n\tif ((v & group_bit) == 0) {\n\t\tv |= group_bit;\n\n\t\t \n\t\tWRITE_ONCE(nf_ctnetlink_has_listener, v);\n\t}\n\n\tspin_unlock(&nfnl_grp_active_lock);\n#endif\n}\n\nstatic int nfnetlink_bind(struct net *net, int group)\n{\n\tconst struct nfnetlink_subsystem *ss;\n\tint type;\n\n\tif (group <= NFNLGRP_NONE || group > NFNLGRP_MAX)\n\t\treturn 0;\n\n\ttype = nfnl_group2type[group];\n\n\trcu_read_lock();\n\tss = nfnetlink_get_subsys(type << 8);\n\trcu_read_unlock();\n\tif (!ss)\n\t\trequest_module_nowait(\"nfnetlink-subsys-%d\", type);\n\n\tnfnetlink_bind_event(net, group);\n\treturn 0;\n}\n\nstatic void nfnetlink_unbind(struct net *net, int group)\n{\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tint type, group_bit;\n\n\tif (group <= NFNLGRP_NONE || group > NFNLGRP_MAX)\n\t\treturn;\n\n\ttype = nfnl_group2type[group];\n\n\tswitch (type) {\n\tcase NFNL_SUBSYS_CTNETLINK:\n\t\tbreak;\n\tcase NFNL_SUBSYS_CTNETLINK_EXP:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tif (group >= 8)\n\t\treturn;\n\n\tgroup_bit = (1 << group);\n\n\tspin_lock(&nfnl_grp_active_lock);\n\tif (!nfnetlink_has_listeners(net, group)) {\n\t\tu8 v = READ_ONCE(nf_ctnetlink_has_listener);\n\n\t\tv &= ~group_bit;\n\n\t\t \n\t\tWRITE_ONCE(nf_ctnetlink_has_listener, v);\n\t}\n\tspin_unlock(&nfnl_grp_active_lock);\n#endif\n}\n\nstatic int __net_init nfnetlink_net_init(struct net *net)\n{\n\tstruct nfnl_net *nfnlnet = nfnl_pernet(net);\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= NFNLGRP_MAX,\n\t\t.input\t= nfnetlink_rcv,\n\t\t.bind\t= nfnetlink_bind,\n\t\t.unbind\t= nfnetlink_unbind,\n\t};\n\n\tnfnlnet->nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);\n\tif (!nfnlnet->nfnl)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __net_exit nfnetlink_net_exit_batch(struct list_head *net_exit_list)\n{\n\tstruct nfnl_net *nfnlnet;\n\tstruct net *net;\n\n\tlist_for_each_entry(net, net_exit_list, exit_list) {\n\t\tnfnlnet = nfnl_pernet(net);\n\n\t\tnetlink_kernel_release(nfnlnet->nfnl);\n\t}\n}\n\nstatic struct pernet_operations nfnetlink_net_ops = {\n\t.init\t\t= nfnetlink_net_init,\n\t.exit_batch\t= nfnetlink_net_exit_batch,\n\t.id\t\t= &nfnetlink_pernet_id,\n\t.size\t\t= sizeof(struct nfnl_net),\n};\n\nstatic int __init nfnetlink_init(void)\n{\n\tint i;\n\n\tfor (i = NFNLGRP_NONE + 1; i <= NFNLGRP_MAX; i++)\n\t\tBUG_ON(nfnl_group2type[i] == NFNL_SUBSYS_NONE);\n\n\tfor (i=0; i<NFNL_SUBSYS_COUNT; i++)\n\t\t__mutex_init(&table[i].mutex, nfnl_lockdep_names[i], &nfnl_lockdep_keys[i]);\n\n\treturn register_pernet_subsys(&nfnetlink_net_ops);\n}\n\nstatic void __exit nfnetlink_exit(void)\n{\n\tunregister_pernet_subsys(&nfnetlink_net_ops);\n}\nmodule_init(nfnetlink_init);\nmodule_exit(nfnetlink_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}