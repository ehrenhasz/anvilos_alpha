{
  "module_name": "ip_set_bitmap_port.c",
  "hash_id": "0a2e3a35bea466823a62332fbedab59272c69114239377ae141af2e00c5ae4e9",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipset/ip_set_bitmap_port.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/netlink.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <net/netlink.h>\n\n#include <linux/netfilter/ipset/ip_set.h>\n#include <linux/netfilter/ipset/ip_set_bitmap.h>\n#include <linux/netfilter/ipset/ip_set_getport.h>\n\n#define IPSET_TYPE_REV_MIN\t0\n \n \n#define IPSET_TYPE_REV_MAX\t3\t \n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jozsef Kadlecsik <kadlec@netfilter.org>\");\nIP_SET_MODULE_DESC(\"bitmap:port\", IPSET_TYPE_REV_MIN, IPSET_TYPE_REV_MAX);\nMODULE_ALIAS(\"ip_set_bitmap:port\");\n\n#define MTYPE\t\tbitmap_port\n\n \nstruct bitmap_port {\n\tunsigned long *members;\t \n\tu16 first_port;\t\t \n\tu16 last_port;\t\t \n\tu32 elements;\t\t \n\tsize_t memsize;\t\t \n\tstruct timer_list gc;\t \n\tstruct ip_set *set;\t \n\tunsigned char extensions[]\t \n\t\t__aligned(__alignof__(u64));\n};\n\n \nstruct bitmap_port_adt_elem {\n\tu16 id;\n};\n\nstatic u16\nport_to_id(const struct bitmap_port *m, u16 port)\n{\n\treturn port - m->first_port;\n}\n\n \n\nstatic int\nbitmap_port_do_test(const struct bitmap_port_adt_elem *e,\n\t\t    const struct bitmap_port *map, size_t dsize)\n{\n\treturn !!test_bit(e->id, map->members);\n}\n\nstatic int\nbitmap_port_gc_test(u16 id, const struct bitmap_port *map, size_t dsize)\n{\n\treturn !!test_bit(id, map->members);\n}\n\nstatic int\nbitmap_port_do_add(const struct bitmap_port_adt_elem *e,\n\t\t   struct bitmap_port *map, u32 flags, size_t dsize)\n{\n\treturn !!test_bit(e->id, map->members);\n}\n\nstatic int\nbitmap_port_do_del(const struct bitmap_port_adt_elem *e,\n\t\t   struct bitmap_port *map)\n{\n\treturn !test_and_clear_bit(e->id, map->members);\n}\n\nstatic int\nbitmap_port_do_list(struct sk_buff *skb, const struct bitmap_port *map, u32 id,\n\t\t    size_t dsize)\n{\n\treturn nla_put_net16(skb, IPSET_ATTR_PORT,\n\t\t\t     htons(map->first_port + id));\n}\n\nstatic int\nbitmap_port_do_head(struct sk_buff *skb, const struct bitmap_port *map)\n{\n\treturn nla_put_net16(skb, IPSET_ATTR_PORT, htons(map->first_port)) ||\n\t       nla_put_net16(skb, IPSET_ATTR_PORT_TO, htons(map->last_port));\n}\n\nstatic bool\nip_set_get_ip_port(const struct sk_buff *skb, u8 pf, bool src, __be16 *port)\n{\n\tbool ret;\n\tu8 proto;\n\n\tswitch (pf) {\n\tcase NFPROTO_IPV4:\n\t\tret = ip_set_get_ip4_port(skb, src, port, &proto);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tret = ip_set_get_ip6_port(skb, src, port, &proto);\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\tif (!ret)\n\t\treturn ret;\n\tswitch (proto) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int\nbitmap_port_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t\t const struct xt_action_param *par,\n\t\t enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tstruct bitmap_port *map = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct bitmap_port_adt_elem e = { .id = 0 };\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\t__be16 __port;\n\tu16 port = 0;\n\n\tif (!ip_set_get_ip_port(skb, opt->family,\n\t\t\t\topt->flags & IPSET_DIM_ONE_SRC, &__port))\n\t\treturn -EINVAL;\n\n\tport = ntohs(__port);\n\n\tif (port < map->first_port || port > map->last_port)\n\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\n\te.id = port_to_id(map, port);\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic int\nbitmap_port_uadt(struct ip_set *set, struct nlattr *tb[],\n\t\t enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tstruct bitmap_port *map = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct bitmap_port_adt_elem e = { .id = 0 };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tu32 port;\t \n\tu16 port_to;\n\tint ret = 0;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\tif (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tport = ip_set_get_h16(tb[IPSET_ATTR_PORT]);\n\tif (port < map->first_port || port > map->last_port)\n\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adt == IPSET_TEST) {\n\t\te.id = port_to_id(map, port);\n\t\treturn adtfn(set, &e, &ext, &ext, flags);\n\t}\n\n\tif (tb[IPSET_ATTR_PORT_TO]) {\n\t\tport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\n\t\tif (port > port_to) {\n\t\t\tswap(port, port_to);\n\t\t\tif (port < map->first_port)\n\t\t\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\t\t}\n\t} else {\n\t\tport_to = port;\n\t}\n\n\tif (port_to > map->last_port)\n\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\n\tfor (; port <= port_to; port++) {\n\t\te.id = port_to_id(map, port);\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\n\t\tif (ret && !ip_set_eexist(ret, flags))\n\t\t\treturn ret;\n\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic bool\nbitmap_port_same_set(const struct ip_set *a, const struct ip_set *b)\n{\n\tconst struct bitmap_port *x = a->data;\n\tconst struct bitmap_port *y = b->data;\n\n\treturn x->first_port == y->first_port &&\n\t       x->last_port == y->last_port &&\n\t       a->timeout == b->timeout &&\n\t       a->extensions == b->extensions;\n}\n\n \n\nstruct bitmap_port_elem {\n};\n\n#include \"ip_set_bitmap_gen.h\"\n\n \n\nstatic bool\ninit_map_port(struct ip_set *set, struct bitmap_port *map,\n\t      u16 first_port, u16 last_port)\n{\n\tmap->members = bitmap_zalloc(map->elements, GFP_KERNEL | __GFP_NOWARN);\n\tif (!map->members)\n\t\treturn false;\n\tmap->first_port = first_port;\n\tmap->last_port = last_port;\n\tset->timeout = IPSET_NO_TIMEOUT;\n\n\tmap->set = set;\n\tset->data = map;\n\tset->family = NFPROTO_UNSPEC;\n\n\treturn true;\n}\n\nstatic int\nbitmap_port_create(struct net *net, struct ip_set *set, struct nlattr *tb[],\n\t\t   u32 flags)\n{\n\tstruct bitmap_port *map;\n\tu16 first_port, last_port;\n\tu32 elements;\n\n\tif (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\n\t\t     !ip_set_attr_netorder(tb, IPSET_ATTR_PORT_TO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tfirst_port = ip_set_get_h16(tb[IPSET_ATTR_PORT]);\n\tlast_port = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\n\tif (first_port > last_port)\n\t\tswap(first_port, last_port);\n\n\telements = last_port - first_port + 1;\n\tset->dsize = ip_set_elem_len(set, tb, 0, 0);\n\tmap = ip_set_alloc(sizeof(*map) + elements * set->dsize);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->elements = elements;\n\tmap->memsize = BITS_TO_LONGS(elements) * sizeof(unsigned long);\n\tset->variant = &bitmap_port;\n\tif (!init_map_port(set, map, first_port, last_port)) {\n\t\tip_set_free(map);\n\t\treturn -ENOMEM;\n\t}\n\tif (tb[IPSET_ATTR_TIMEOUT]) {\n\t\tset->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\n\t\tbitmap_port_gc_init(set, bitmap_port_gc);\n\t}\n\treturn 0;\n}\n\nstatic struct ip_set_type bitmap_port_type = {\n\t.name\t\t= \"bitmap:port\",\n\t.protocol\t= IPSET_PROTOCOL,\n\t.features\t= IPSET_TYPE_PORT,\n\t.dimension\t= IPSET_DIM_ONE,\n\t.family\t\t= NFPROTO_UNSPEC,\n\t.revision_min\t= IPSET_TYPE_REV_MIN,\n\t.revision_max\t= IPSET_TYPE_REV_MAX,\n\t.create\t\t= bitmap_port_create,\n\t.create_policy\t= {\n\t\t[IPSET_ATTR_PORT]\t= { .type = NLA_U16 },\n\t\t[IPSET_ATTR_PORT_TO]\t= { .type = NLA_U16 },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t},\n\t.adt_policy\t= {\n\t\t[IPSET_ATTR_PORT]\t= { .type = NLA_U16 },\n\t\t[IPSET_ATTR_PORT_TO]\t= { .type = NLA_U16 },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_LINENO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BYTES]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_PACKETS]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_COMMENT]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len  = IPSET_MAX_COMMENT_SIZE },\n\t\t[IPSET_ATTR_SKBMARK]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_SKBPRIO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_SKBQUEUE]\t= { .type = NLA_U16 },\n\t},\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init\nbitmap_port_init(void)\n{\n\treturn ip_set_type_register(&bitmap_port_type);\n}\n\nstatic void __exit\nbitmap_port_fini(void)\n{\n\trcu_barrier();\n\tip_set_type_unregister(&bitmap_port_type);\n}\n\nmodule_init(bitmap_port_init);\nmodule_exit(bitmap_port_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}