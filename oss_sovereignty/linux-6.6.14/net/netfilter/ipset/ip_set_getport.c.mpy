{
  "module_name": "ip_set_getport.c",
  "hash_id": "70adb1c5cc240d62b3ca04018890747165d74223f6a0d39c9a9631d8f780eab1",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipset/ip_set_getport.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/ip.h>\n#include <linux/skbuff.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/sctp.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n\n#include <linux/netfilter/ipset/ip_set_getport.h>\n#include <linux/export.h>\n\n \nstatic bool\nget_port(const struct sk_buff *skb, int protocol, unsigned int protooff,\n\t bool src, __be16 *port, u8 *proto)\n{\n\tswitch (protocol) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr _tcph;\n\t\tconst struct tcphdr *th;\n\n\t\tth = skb_header_pointer(skb, protooff, sizeof(_tcph), &_tcph);\n\t\tif (!th)\n\t\t\t \n\t\t\treturn false;\n\n\t\t*port = src ? th->source : th->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr _sh;\n\t\tconst struct sctphdr *sh;\n\n\t\tsh = skb_header_pointer(skb, protooff, sizeof(_sh), &_sh);\n\t\tif (!sh)\n\t\t\t \n\t\t\treturn false;\n\n\t\t*port = src ? sh->source : sh->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE: {\n\t\tstruct udphdr _udph;\n\t\tconst struct udphdr *uh;\n\n\t\tuh = skb_header_pointer(skb, protooff, sizeof(_udph), &_udph);\n\t\tif (!uh)\n\t\t\t \n\t\t\treturn false;\n\n\t\t*port = src ? uh->source : uh->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_ICMP: {\n\t\tstruct icmphdr _ich;\n\t\tconst struct icmphdr *ic;\n\n\t\tic = skb_header_pointer(skb, protooff, sizeof(_ich), &_ich);\n\t\tif (!ic)\n\t\t\treturn false;\n\n\t\t*port = (__force __be16)htons((ic->type << 8) | ic->code);\n\t\tbreak;\n\t}\n\tcase IPPROTO_ICMPV6: {\n\t\tstruct icmp6hdr _ich;\n\t\tconst struct icmp6hdr *ic;\n\n\t\tic = skb_header_pointer(skb, protooff, sizeof(_ich), &_ich);\n\t\tif (!ic)\n\t\t\treturn false;\n\n\t\t*port = (__force __be16)\n\t\t\thtons((ic->icmp6_type << 8) | ic->icmp6_code);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\t*proto = protocol;\n\n\treturn true;\n}\n\nbool\nip_set_get_ip4_port(const struct sk_buff *skb, bool src,\n\t\t    __be16 *port, u8 *proto)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned int protooff = skb_network_offset(skb) + ip_hdrlen(skb);\n\tint protocol = iph->protocol;\n\n\t \n\tif (protocol <= 0)\n\t\treturn false;\n\n\tif (ntohs(iph->frag_off) & IP_OFFSET)\n\t\tswitch (protocol) {\n\t\tcase IPPROTO_TCP:\n\t\tcase IPPROTO_SCTP:\n\t\tcase IPPROTO_UDP:\n\t\tcase IPPROTO_UDPLITE:\n\t\tcase IPPROTO_ICMP:\n\t\t\t \n\t\t\treturn false;\n\t\tdefault:\n\t\t\t \n\t\t\t*proto = protocol;\n\t\t\treturn true;\n\t\t}\n\n\treturn get_port(skb, protocol, protooff, src, port, proto);\n}\nEXPORT_SYMBOL_GPL(ip_set_get_ip4_port);\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nbool\nip_set_get_ip6_port(const struct sk_buff *skb, bool src,\n\t\t    __be16 *port, u8 *proto)\n{\n\tint protoff;\n\tu8 nexthdr;\n\t__be16 frag_off = 0;\n\n\tnexthdr = ipv6_hdr(skb)->nexthdr;\n\tprotoff = ipv6_skip_exthdr(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t\tsizeof(struct ipv6hdr), &nexthdr,\n\t\t\t\t   &frag_off);\n\tif (protoff < 0 || (frag_off & htons(~0x7)) != 0)\n\t\treturn false;\n\n\treturn get_port(skb, nexthdr, protoff, src, port, proto);\n}\nEXPORT_SYMBOL_GPL(ip_set_get_ip6_port);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}