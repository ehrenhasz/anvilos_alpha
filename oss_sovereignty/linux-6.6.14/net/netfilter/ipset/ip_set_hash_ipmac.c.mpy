{
  "module_name": "ip_set_hash_ipmac.c",
  "hash_id": "682e96c2376485b5b4ebffb0b9469cbd8aa9db910ec48b5a085023daeef46325",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipset/ip_set_hash_ipmac.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/jhash.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/random.h>\n#include <linux/if_ether.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/netlink.h>\n#include <net/tcp.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter/ipset/pfxlen.h>\n#include <linux/netfilter/ipset/ip_set.h>\n#include <linux/netfilter/ipset/ip_set_hash.h>\n\n#define IPSET_TYPE_REV_MIN\t0\n#define IPSET_TYPE_REV_MAX\t1\t \n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tomasz Chilinski <tomasz.chilinski@chilan.com>\");\nIP_SET_MODULE_DESC(\"hash:ip,mac\", IPSET_TYPE_REV_MIN, IPSET_TYPE_REV_MAX);\nMODULE_ALIAS(\"ip_set_hash:ip,mac\");\n\n \n#define HTYPE\t\thash_ipmac\n\n \n\n \nstruct hash_ipmac4_elem {\n\t \n\t__be32 ip;\n\tunion {\n\t\tunsigned char ether[ETH_ALEN];\n\t\t__be32 foo[2];\n\t};\n};\n\n \n\nstatic bool\nhash_ipmac4_data_equal(const struct hash_ipmac4_elem *e1,\n\t\t       const struct hash_ipmac4_elem *e2,\n\t\t       u32 *multi)\n{\n\treturn e1->ip == e2->ip && ether_addr_equal(e1->ether, e2->ether);\n}\n\nstatic bool\nhash_ipmac4_data_list(struct sk_buff *skb, const struct hash_ipmac4_elem *e)\n{\n\tif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, e->ip) ||\n\t    nla_put(skb, IPSET_ATTR_ETHER, ETH_ALEN, e->ether))\n\t\tgoto nla_put_failure;\n\treturn false;\n\nnla_put_failure:\n\treturn true;\n}\n\nstatic void\nhash_ipmac4_data_next(struct hash_ipmac4_elem *next,\n\t\t      const struct hash_ipmac4_elem *e)\n{\n\tnext->ip = e->ip;\n}\n\n#define MTYPE\t\thash_ipmac4\n#define PF\t\t4\n#define HOST_MASK\t32\n#define HKEY_DATALEN\tsizeof(struct hash_ipmac4_elem)\n#include \"ip_set_hash_gen.h\"\n\nstatic int\nhash_ipmac4_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t\t const struct xt_action_param *par,\n\t\t enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_ipmac4_elem e = { .ip = 0, { .foo[0] = 0, .foo[1] = 0 } };\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\n\tif (skb_mac_header(skb) < skb->head ||\n\t    (skb_mac_header(skb) + ETH_HLEN) > skb->data)\n\t\treturn -EINVAL;\n\n\tif (opt->flags & IPSET_DIM_TWO_SRC)\n\t\tether_addr_copy(e.ether, eth_hdr(skb)->h_source);\n\telse\n\t\tether_addr_copy(e.ether, eth_hdr(skb)->h_dest);\n\n\tif (is_zero_ether_addr(e.ether))\n\t\treturn -EINVAL;\n\n\tip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip);\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic int\nhash_ipmac4_uadt(struct ip_set *set, struct nlattr *tb[],\n\t\t enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_ipmac4_elem e = { .ip = 0, { .foo[0] = 0, .foo[1] = 0 } };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tint ret;\n\n\tif (unlikely(!tb[IPSET_ATTR_IP] ||\n\t\t     !tb[IPSET_ATTR_ETHER] ||\n\t\t     nla_len(tb[IPSET_ATTR_ETHER]) != ETH_ALEN ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES)   ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_SKBMARK) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_SKBPRIO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_SKBQUEUE)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\tret = ip_set_get_ipaddr4(tb[IPSET_ATTR_IP], &e.ip) ||\n\t\tip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\tmemcpy(e.ether, nla_data(tb[IPSET_ATTR_ETHER]), ETH_ALEN);\n\tif (is_zero_ether_addr(e.ether))\n\t\treturn -IPSET_ERR_HASH_ELEM;\n\n\treturn adtfn(set, &e, &ext, &ext, flags);\n}\n\n \n\n \nstruct hash_ipmac6_elem {\n\t \n\tunion nf_inet_addr ip;\n\tunion {\n\t\tunsigned char ether[ETH_ALEN];\n\t\t__be32 foo[2];\n\t};\n};\n\n \n\nstatic bool\nhash_ipmac6_data_equal(const struct hash_ipmac6_elem *e1,\n\t\t       const struct hash_ipmac6_elem *e2,\n\t\t       u32 *multi)\n{\n\treturn ipv6_addr_equal(&e1->ip.in6, &e2->ip.in6) &&\n\t\tether_addr_equal(e1->ether, e2->ether);\n}\n\nstatic bool\nhash_ipmac6_data_list(struct sk_buff *skb, const struct hash_ipmac6_elem *e)\n{\n\tif (nla_put_ipaddr6(skb, IPSET_ATTR_IP, &e->ip.in6) ||\n\t    nla_put(skb, IPSET_ATTR_ETHER, ETH_ALEN, e->ether))\n\t\tgoto nla_put_failure;\n\treturn false;\n\nnla_put_failure:\n\treturn true;\n}\n\nstatic void\nhash_ipmac6_data_next(struct hash_ipmac6_elem *next,\n\t\t      const struct hash_ipmac6_elem *e)\n{\n}\n\n#undef MTYPE\n#undef PF\n#undef HOST_MASK\n#undef HKEY_DATALEN\n\n#define MTYPE\t\thash_ipmac6\n#define PF\t\t6\n#define HOST_MASK\t128\n#define HKEY_DATALEN\tsizeof(struct hash_ipmac6_elem)\n#define IP_SET_EMIT_CREATE\n#include \"ip_set_hash_gen.h\"\n\nstatic int\nhash_ipmac6_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t\t const struct xt_action_param *par,\n\t\t enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_ipmac6_elem e = {\n\t\t{ .all = { 0 } },\n\t\t{ .foo[0] = 0, .foo[1] = 0 }\n\t};\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\n\tif (skb_mac_header(skb) < skb->head ||\n\t    (skb_mac_header(skb) + ETH_HLEN) > skb->data)\n\t\treturn -EINVAL;\n\n\tif (opt->flags & IPSET_DIM_TWO_SRC)\n\t\tether_addr_copy(e.ether, eth_hdr(skb)->h_source);\n\telse\n\t\tether_addr_copy(e.ether, eth_hdr(skb)->h_dest);\n\n\tif (is_zero_ether_addr(e.ether))\n\t\treturn -EINVAL;\n\n\tip6addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip.in6);\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic int\nhash_ipmac6_uadt(struct ip_set *set, struct nlattr *tb[],\n\t\t enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_ipmac6_elem e = {\n\t\t{ .all = { 0 } },\n\t\t{ .foo[0] = 0, .foo[1] = 0 }\n\t};\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tint ret;\n\n\tif (unlikely(!tb[IPSET_ATTR_IP] ||\n\t\t     !tb[IPSET_ATTR_ETHER] ||\n\t\t     nla_len(tb[IPSET_ATTR_ETHER]) != ETH_ALEN ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES)   ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_SKBMARK) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_SKBPRIO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_SKBQUEUE)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\tret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP], &e.ip) ||\n\t\tip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(e.ether, nla_data(tb[IPSET_ATTR_ETHER]), ETH_ALEN);\n\tif (is_zero_ether_addr(e.ether))\n\t\treturn -IPSET_ERR_HASH_ELEM;\n\n\treturn adtfn(set, &e, &ext, &ext, flags);\n}\n\nstatic struct ip_set_type hash_ipmac_type __read_mostly = {\n\t.name\t\t= \"hash:ip,mac\",\n\t.protocol\t= IPSET_PROTOCOL,\n\t.features\t= IPSET_TYPE_IP | IPSET_TYPE_MAC,\n\t.dimension\t= IPSET_DIM_TWO,\n\t.family\t\t= NFPROTO_UNSPEC,\n\t.revision_min\t= IPSET_TYPE_REV_MIN,\n\t.revision_max\t= IPSET_TYPE_REV_MAX,\n\t.create_flags[IPSET_TYPE_REV_MAX] = IPSET_CREATE_FLAG_BUCKETSIZE,\n\t.create\t\t= hash_ipmac_create,\n\t.create_policy\t= {\n\t\t[IPSET_ATTR_HASHSIZE]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_MAXELEM]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_INITVAL]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BUCKETSIZE]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_RESIZE]\t= { .type = NLA_U8  },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t},\n\t.adt_policy\t= {\n\t\t[IPSET_ATTR_IP]\t\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_ETHER]\t= { .type = NLA_BINARY,\n\t\t\t\t.len  = ETH_ALEN },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_LINENO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BYTES]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_PACKETS]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_COMMENT]\t= { .type = NLA_NUL_STRING },\n\t\t[IPSET_ATTR_SKBMARK]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_SKBPRIO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_SKBQUEUE]\t= { .type = NLA_U16 },\n\t},\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init\nhash_ipmac_init(void)\n{\n\treturn ip_set_type_register(&hash_ipmac_type);\n}\n\nstatic void __exit\nhash_ipmac_fini(void)\n{\n\tip_set_type_unregister(&hash_ipmac_type);\n}\n\nmodule_init(hash_ipmac_init);\nmodule_exit(hash_ipmac_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}