{
  "module_name": "ip_set_core.c",
  "hash_id": "947d1d457fb696bd9cd172630603c54b07404eb2d369e7bf5ae2362a1a135bfc",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipset/ip_set_core.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/ip.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/rculist.h>\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/ipset/ip_set.h>\n\nstatic LIST_HEAD(ip_set_type_list);\t\t \nstatic DEFINE_MUTEX(ip_set_type_mutex);\t\t \nstatic DEFINE_RWLOCK(ip_set_ref_lock);\t\t \n\nstruct ip_set_net {\n\tstruct ip_set * __rcu *ip_set_list;\t \n\tip_set_id_t\tip_set_max;\t \n\tbool\t\tis_deleted;\t \n\tbool\t\tis_destroyed;\t \n};\n\nstatic unsigned int ip_set_net_id __read_mostly;\n\nstatic struct ip_set_net *ip_set_pernet(struct net *net)\n{\n\treturn net_generic(net, ip_set_net_id);\n}\n\n#define IP_SET_INC\t64\n#define STRNCMP(a, b)\t(strncmp(a, b, IPSET_MAXNAMELEN) == 0)\n\nstatic unsigned int max_sets;\n\nmodule_param(max_sets, int, 0600);\nMODULE_PARM_DESC(max_sets, \"maximal number of sets\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jozsef Kadlecsik <kadlec@netfilter.org>\");\nMODULE_DESCRIPTION(\"core IP set support\");\nMODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_IPSET);\n\n \n#define ip_set_dereference(p)\t\t\\\n\trcu_dereference_protected(p,\t\\\n\t\tlockdep_nfnl_is_held(NFNL_SUBSYS_IPSET) || \\\n\t\tlockdep_is_held(&ip_set_ref_lock))\n#define ip_set(inst, id)\t\t\\\n\tip_set_dereference((inst)->ip_set_list)[id]\n#define ip_set_ref_netlink(inst,id)\t\\\n\trcu_dereference_raw((inst)->ip_set_list)[id]\n#define ip_set_dereference_nfnl(p)\t\\\n\trcu_dereference_check(p, lockdep_nfnl_is_held(NFNL_SUBSYS_IPSET))\n\n \n\nstatic void\nip_set_type_lock(void)\n{\n\tmutex_lock(&ip_set_type_mutex);\n}\n\nstatic void\nip_set_type_unlock(void)\n{\n\tmutex_unlock(&ip_set_type_mutex);\n}\n\n \n\nstatic struct ip_set_type *\nfind_set_type(const char *name, u8 family, u8 revision)\n{\n\tstruct ip_set_type *type;\n\n\tlist_for_each_entry_rcu(type, &ip_set_type_list, list,\n\t\t\t\tlockdep_is_held(&ip_set_type_mutex))\n\t\tif (STRNCMP(type->name, name) &&\n\t\t    (type->family == family ||\n\t\t     type->family == NFPROTO_UNSPEC) &&\n\t\t    revision >= type->revision_min &&\n\t\t    revision <= type->revision_max)\n\t\t\treturn type;\n\treturn NULL;\n}\n\n \nstatic bool\nload_settype(const char *name)\n{\n\tnfnl_unlock(NFNL_SUBSYS_IPSET);\n\tpr_debug(\"try to load ip_set_%s\\n\", name);\n\tif (request_module(\"ip_set_%s\", name) < 0) {\n\t\tpr_warn(\"Can't find ip_set type %s\\n\", name);\n\t\tnfnl_lock(NFNL_SUBSYS_IPSET);\n\t\treturn false;\n\t}\n\tnfnl_lock(NFNL_SUBSYS_IPSET);\n\treturn true;\n}\n\n \n#define find_set_type_get(name, family, revision, found)\t\\\n\t__find_set_type_get(name, family, revision, found, false)\n\nstatic int\n__find_set_type_get(const char *name, u8 family, u8 revision,\n\t\t    struct ip_set_type **found, bool retry)\n{\n\tstruct ip_set_type *type;\n\tint err;\n\n\tif (retry && !load_settype(name))\n\t\treturn -IPSET_ERR_FIND_TYPE;\n\n\trcu_read_lock();\n\t*found = find_set_type(name, family, revision);\n\tif (*found) {\n\t\terr = !try_module_get((*found)->me) ? -EFAULT : 0;\n\t\tgoto unlock;\n\t}\n\t \n\tlist_for_each_entry_rcu(type, &ip_set_type_list, list)\n\t\tif (STRNCMP(type->name, name)) {\n\t\t\terr = -IPSET_ERR_FIND_TYPE;\n\t\t\tgoto unlock;\n\t\t}\n\trcu_read_unlock();\n\n\treturn retry ? -IPSET_ERR_FIND_TYPE :\n\t\t__find_set_type_get(name, family, revision, found, true);\n\nunlock:\n\trcu_read_unlock();\n\treturn err;\n}\n\n \n#define find_set_type_minmax(name, family, min, max) \\\n\t__find_set_type_minmax(name, family, min, max, false)\n\nstatic int\n__find_set_type_minmax(const char *name, u8 family, u8 *min, u8 *max,\n\t\t       bool retry)\n{\n\tstruct ip_set_type *type;\n\tbool found = false;\n\n\tif (retry && !load_settype(name))\n\t\treturn -IPSET_ERR_FIND_TYPE;\n\n\t*min = 255; *max = 0;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(type, &ip_set_type_list, list)\n\t\tif (STRNCMP(type->name, name) &&\n\t\t    (type->family == family ||\n\t\t     type->family == NFPROTO_UNSPEC)) {\n\t\t\tfound = true;\n\t\t\tif (type->revision_min < *min)\n\t\t\t\t*min = type->revision_min;\n\t\t\tif (type->revision_max > *max)\n\t\t\t\t*max = type->revision_max;\n\t\t}\n\trcu_read_unlock();\n\tif (found)\n\t\treturn 0;\n\n\treturn retry ? -IPSET_ERR_FIND_TYPE :\n\t\t__find_set_type_minmax(name, family, min, max, true);\n}\n\n#define family_name(f)\t((f) == NFPROTO_IPV4 ? \"inet\" : \\\n\t\t\t (f) == NFPROTO_IPV6 ? \"inet6\" : \"any\")\n\n \nint\nip_set_type_register(struct ip_set_type *type)\n{\n\tint ret = 0;\n\n\tif (type->protocol != IPSET_PROTOCOL) {\n\t\tpr_warn(\"ip_set type %s, family %s, revision %u:%u uses wrong protocol version %u (want %u)\\n\",\n\t\t\ttype->name, family_name(type->family),\n\t\t\ttype->revision_min, type->revision_max,\n\t\t\ttype->protocol, IPSET_PROTOCOL);\n\t\treturn -EINVAL;\n\t}\n\n\tip_set_type_lock();\n\tif (find_set_type(type->name, type->family, type->revision_min)) {\n\t\t \n\t\tpr_warn(\"ip_set type %s, family %s with revision min %u already registered!\\n\",\n\t\t\ttype->name, family_name(type->family),\n\t\t\ttype->revision_min);\n\t\tip_set_type_unlock();\n\t\treturn -EINVAL;\n\t}\n\tlist_add_rcu(&type->list, &ip_set_type_list);\n\tpr_debug(\"type %s, family %s, revision %u:%u registered.\\n\",\n\t\t type->name, family_name(type->family),\n\t\t type->revision_min, type->revision_max);\n\tip_set_type_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ip_set_type_register);\n\n \nvoid\nip_set_type_unregister(struct ip_set_type *type)\n{\n\tip_set_type_lock();\n\tif (!find_set_type(type->name, type->family, type->revision_min)) {\n\t\tpr_warn(\"ip_set type %s, family %s with revision min %u not registered\\n\",\n\t\t\ttype->name, family_name(type->family),\n\t\t\ttype->revision_min);\n\t\tip_set_type_unlock();\n\t\treturn;\n\t}\n\tlist_del_rcu(&type->list);\n\tpr_debug(\"type %s, family %s with revision min %u unregistered.\\n\",\n\t\t type->name, family_name(type->family), type->revision_min);\n\tip_set_type_unlock();\n\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL_GPL(ip_set_type_unregister);\n\n \nvoid *\nip_set_alloc(size_t size)\n{\n\treturn kvzalloc(size, GFP_KERNEL_ACCOUNT);\n}\nEXPORT_SYMBOL_GPL(ip_set_alloc);\n\nvoid\nip_set_free(void *members)\n{\n\tpr_debug(\"%p: free with %s\\n\", members,\n\t\t is_vmalloc_addr(members) ? \"vfree\" : \"kfree\");\n\tkvfree(members);\n}\nEXPORT_SYMBOL_GPL(ip_set_free);\n\nstatic bool\nflag_nested(const struct nlattr *nla)\n{\n\treturn nla->nla_type & NLA_F_NESTED;\n}\n\nstatic const struct nla_policy ipaddr_policy[IPSET_ATTR_IPADDR_MAX + 1] = {\n\t[IPSET_ATTR_IPADDR_IPV4]\t= { .type = NLA_U32 },\n\t[IPSET_ATTR_IPADDR_IPV6]\t= NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),\n};\n\nint\nip_set_get_ipaddr4(struct nlattr *nla,  __be32 *ipaddr)\n{\n\tstruct nlattr *tb[IPSET_ATTR_IPADDR_MAX + 1];\n\n\tif (unlikely(!flag_nested(nla)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\tif (nla_parse_nested(tb, IPSET_ATTR_IPADDR_MAX, nla,\n\t\t\t     ipaddr_policy, NULL))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\tif (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_IPADDR_IPV4)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\t*ipaddr = nla_get_be32(tb[IPSET_ATTR_IPADDR_IPV4]);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ip_set_get_ipaddr4);\n\nint\nip_set_get_ipaddr6(struct nlattr *nla, union nf_inet_addr *ipaddr)\n{\n\tstruct nlattr *tb[IPSET_ATTR_IPADDR_MAX + 1];\n\n\tif (unlikely(!flag_nested(nla)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tif (nla_parse_nested(tb, IPSET_ATTR_IPADDR_MAX, nla,\n\t\t\t     ipaddr_policy, NULL))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\tif (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_IPADDR_IPV6)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tmemcpy(ipaddr, nla_data(tb[IPSET_ATTR_IPADDR_IPV6]),\n\t       sizeof(struct in6_addr));\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ip_set_get_ipaddr6);\n\nstatic u32\nip_set_timeout_get(const unsigned long *timeout)\n{\n\tu32 t;\n\n\tif (*timeout == IPSET_ELEM_PERMANENT)\n\t\treturn 0;\n\n\tt = jiffies_to_msecs(*timeout - jiffies) / MSEC_PER_SEC;\n\t \n\treturn t == 0 ? 1 : t;\n}\n\nstatic char *\nip_set_comment_uget(struct nlattr *tb)\n{\n\treturn nla_data(tb);\n}\n\n \nvoid\nip_set_init_comment(struct ip_set *set, struct ip_set_comment *comment,\n\t\t    const struct ip_set_ext *ext)\n{\n\tstruct ip_set_comment_rcu *c = rcu_dereference_protected(comment->c, 1);\n\tsize_t len = ext->comment ? strlen(ext->comment) : 0;\n\n\tif (unlikely(c)) {\n\t\tset->ext_size -= sizeof(*c) + strlen(c->str) + 1;\n\t\tkfree_rcu(c, rcu);\n\t\trcu_assign_pointer(comment->c, NULL);\n\t}\n\tif (!len)\n\t\treturn;\n\tif (unlikely(len > IPSET_MAX_COMMENT_SIZE))\n\t\tlen = IPSET_MAX_COMMENT_SIZE;\n\tc = kmalloc(sizeof(*c) + len + 1, GFP_ATOMIC);\n\tif (unlikely(!c))\n\t\treturn;\n\tstrscpy(c->str, ext->comment, len + 1);\n\tset->ext_size += sizeof(*c) + strlen(c->str) + 1;\n\trcu_assign_pointer(comment->c, c);\n}\nEXPORT_SYMBOL_GPL(ip_set_init_comment);\n\n \nstatic int\nip_set_put_comment(struct sk_buff *skb, const struct ip_set_comment *comment)\n{\n\tstruct ip_set_comment_rcu *c = rcu_dereference(comment->c);\n\n\tif (!c)\n\t\treturn 0;\n\treturn nla_put_string(skb, IPSET_ATTR_COMMENT, c->str);\n}\n\n \nstatic void\nip_set_comment_free(struct ip_set *set, void *ptr)\n{\n\tstruct ip_set_comment *comment = ptr;\n\tstruct ip_set_comment_rcu *c;\n\n\tc = rcu_dereference_protected(comment->c, 1);\n\tif (unlikely(!c))\n\t\treturn;\n\tset->ext_size -= sizeof(*c) + strlen(c->str) + 1;\n\tkfree_rcu(c, rcu);\n\trcu_assign_pointer(comment->c, NULL);\n}\n\ntypedef void (*destroyer)(struct ip_set *, void *);\n \n\nconst struct ip_set_ext_type ip_set_extensions[] = {\n\t[IPSET_EXT_ID_COUNTER] = {\n\t\t.type\t= IPSET_EXT_COUNTER,\n\t\t.flag\t= IPSET_FLAG_WITH_COUNTERS,\n\t\t.len\t= sizeof(struct ip_set_counter),\n\t\t.align\t= __alignof__(struct ip_set_counter),\n\t},\n\t[IPSET_EXT_ID_TIMEOUT] = {\n\t\t.type\t= IPSET_EXT_TIMEOUT,\n\t\t.len\t= sizeof(unsigned long),\n\t\t.align\t= __alignof__(unsigned long),\n\t},\n\t[IPSET_EXT_ID_SKBINFO] = {\n\t\t.type\t= IPSET_EXT_SKBINFO,\n\t\t.flag\t= IPSET_FLAG_WITH_SKBINFO,\n\t\t.len\t= sizeof(struct ip_set_skbinfo),\n\t\t.align\t= __alignof__(struct ip_set_skbinfo),\n\t},\n\t[IPSET_EXT_ID_COMMENT] = {\n\t\t.type\t = IPSET_EXT_COMMENT | IPSET_EXT_DESTROY,\n\t\t.flag\t = IPSET_FLAG_WITH_COMMENT,\n\t\t.len\t = sizeof(struct ip_set_comment),\n\t\t.align\t = __alignof__(struct ip_set_comment),\n\t\t.destroy = ip_set_comment_free,\n\t},\n};\nEXPORT_SYMBOL_GPL(ip_set_extensions);\n\nstatic bool\nadd_extension(enum ip_set_ext_id id, u32 flags, struct nlattr *tb[])\n{\n\treturn ip_set_extensions[id].flag ?\n\t\t(flags & ip_set_extensions[id].flag) :\n\t\t!!tb[IPSET_ATTR_TIMEOUT];\n}\n\nsize_t\nip_set_elem_len(struct ip_set *set, struct nlattr *tb[], size_t len,\n\t\tsize_t align)\n{\n\tenum ip_set_ext_id id;\n\tu32 cadt_flags = 0;\n\n\tif (tb[IPSET_ATTR_CADT_FLAGS])\n\t\tcadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\n\tif (cadt_flags & IPSET_FLAG_WITH_FORCEADD)\n\t\tset->flags |= IPSET_CREATE_FLAG_FORCEADD;\n\tif (!align)\n\t\talign = 1;\n\tfor (id = 0; id < IPSET_EXT_ID_MAX; id++) {\n\t\tif (!add_extension(id, cadt_flags, tb))\n\t\t\tcontinue;\n\t\tif (align < ip_set_extensions[id].align)\n\t\t\talign = ip_set_extensions[id].align;\n\t\tlen = ALIGN(len, ip_set_extensions[id].align);\n\t\tset->offset[id] = len;\n\t\tset->extensions |= ip_set_extensions[id].type;\n\t\tlen += ip_set_extensions[id].len;\n\t}\n\treturn ALIGN(len, align);\n}\nEXPORT_SYMBOL_GPL(ip_set_elem_len);\n\nint\nip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],\n\t\t      struct ip_set_ext *ext)\n{\n\tu64 fullmark;\n\n\tif (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_SKBMARK) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_SKBPRIO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_SKBQUEUE)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tif (tb[IPSET_ATTR_TIMEOUT]) {\n\t\tif (!SET_WITH_TIMEOUT(set))\n\t\t\treturn -IPSET_ERR_TIMEOUT;\n\t\text->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\n\t}\n\tif (tb[IPSET_ATTR_BYTES] || tb[IPSET_ATTR_PACKETS]) {\n\t\tif (!SET_WITH_COUNTER(set))\n\t\t\treturn -IPSET_ERR_COUNTER;\n\t\tif (tb[IPSET_ATTR_BYTES])\n\t\t\text->bytes = be64_to_cpu(nla_get_be64(\n\t\t\t\t\t\t tb[IPSET_ATTR_BYTES]));\n\t\tif (tb[IPSET_ATTR_PACKETS])\n\t\t\text->packets = be64_to_cpu(nla_get_be64(\n\t\t\t\t\t\t   tb[IPSET_ATTR_PACKETS]));\n\t}\n\tif (tb[IPSET_ATTR_COMMENT]) {\n\t\tif (!SET_WITH_COMMENT(set))\n\t\t\treturn -IPSET_ERR_COMMENT;\n\t\text->comment = ip_set_comment_uget(tb[IPSET_ATTR_COMMENT]);\n\t}\n\tif (tb[IPSET_ATTR_SKBMARK]) {\n\t\tif (!SET_WITH_SKBINFO(set))\n\t\t\treturn -IPSET_ERR_SKBINFO;\n\t\tfullmark = be64_to_cpu(nla_get_be64(tb[IPSET_ATTR_SKBMARK]));\n\t\text->skbinfo.skbmark = fullmark >> 32;\n\t\text->skbinfo.skbmarkmask = fullmark & 0xffffffff;\n\t}\n\tif (tb[IPSET_ATTR_SKBPRIO]) {\n\t\tif (!SET_WITH_SKBINFO(set))\n\t\t\treturn -IPSET_ERR_SKBINFO;\n\t\text->skbinfo.skbprio =\n\t\t\tbe32_to_cpu(nla_get_be32(tb[IPSET_ATTR_SKBPRIO]));\n\t}\n\tif (tb[IPSET_ATTR_SKBQUEUE]) {\n\t\tif (!SET_WITH_SKBINFO(set))\n\t\t\treturn -IPSET_ERR_SKBINFO;\n\t\text->skbinfo.skbqueue =\n\t\t\tbe16_to_cpu(nla_get_be16(tb[IPSET_ATTR_SKBQUEUE]));\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ip_set_get_extensions);\n\nstatic u64\nip_set_get_bytes(const struct ip_set_counter *counter)\n{\n\treturn (u64)atomic64_read(&(counter)->bytes);\n}\n\nstatic u64\nip_set_get_packets(const struct ip_set_counter *counter)\n{\n\treturn (u64)atomic64_read(&(counter)->packets);\n}\n\nstatic bool\nip_set_put_counter(struct sk_buff *skb, const struct ip_set_counter *counter)\n{\n\treturn nla_put_net64(skb, IPSET_ATTR_BYTES,\n\t\t\t     cpu_to_be64(ip_set_get_bytes(counter)),\n\t\t\t     IPSET_ATTR_PAD) ||\n\t       nla_put_net64(skb, IPSET_ATTR_PACKETS,\n\t\t\t     cpu_to_be64(ip_set_get_packets(counter)),\n\t\t\t     IPSET_ATTR_PAD);\n}\n\nstatic bool\nip_set_put_skbinfo(struct sk_buff *skb, const struct ip_set_skbinfo *skbinfo)\n{\n\t \n\treturn ((skbinfo->skbmark || skbinfo->skbmarkmask) &&\n\t\tnla_put_net64(skb, IPSET_ATTR_SKBMARK,\n\t\t\t      cpu_to_be64((u64)skbinfo->skbmark << 32 |\n\t\t\t\t\t  skbinfo->skbmarkmask),\n\t\t\t      IPSET_ATTR_PAD)) ||\n\t       (skbinfo->skbprio &&\n\t\tnla_put_net32(skb, IPSET_ATTR_SKBPRIO,\n\t\t\t      cpu_to_be32(skbinfo->skbprio))) ||\n\t       (skbinfo->skbqueue &&\n\t\tnla_put_net16(skb, IPSET_ATTR_SKBQUEUE,\n\t\t\t      cpu_to_be16(skbinfo->skbqueue)));\n}\n\nint\nip_set_put_extensions(struct sk_buff *skb, const struct ip_set *set,\n\t\t      const void *e, bool active)\n{\n\tif (SET_WITH_TIMEOUT(set)) {\n\t\tunsigned long *timeout = ext_timeout(e, set);\n\n\t\tif (nla_put_net32(skb, IPSET_ATTR_TIMEOUT,\n\t\t\thtonl(active ? ip_set_timeout_get(timeout)\n\t\t\t\t: *timeout)))\n\t\t\treturn -EMSGSIZE;\n\t}\n\tif (SET_WITH_COUNTER(set) &&\n\t    ip_set_put_counter(skb, ext_counter(e, set)))\n\t\treturn -EMSGSIZE;\n\tif (SET_WITH_COMMENT(set) &&\n\t    ip_set_put_comment(skb, ext_comment(e, set)))\n\t\treturn -EMSGSIZE;\n\tif (SET_WITH_SKBINFO(set) &&\n\t    ip_set_put_skbinfo(skb, ext_skbinfo(e, set)))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ip_set_put_extensions);\n\nstatic bool\nip_set_match_counter(u64 counter, u64 match, u8 op)\n{\n\tswitch (op) {\n\tcase IPSET_COUNTER_NONE:\n\t\treturn true;\n\tcase IPSET_COUNTER_EQ:\n\t\treturn counter == match;\n\tcase IPSET_COUNTER_NE:\n\t\treturn counter != match;\n\tcase IPSET_COUNTER_LT:\n\t\treturn counter < match;\n\tcase IPSET_COUNTER_GT:\n\t\treturn counter > match;\n\t}\n\treturn false;\n}\n\nstatic void\nip_set_add_bytes(u64 bytes, struct ip_set_counter *counter)\n{\n\tatomic64_add((long long)bytes, &(counter)->bytes);\n}\n\nstatic void\nip_set_add_packets(u64 packets, struct ip_set_counter *counter)\n{\n\tatomic64_add((long long)packets, &(counter)->packets);\n}\n\nstatic void\nip_set_update_counter(struct ip_set_counter *counter,\n\t\t      const struct ip_set_ext *ext, u32 flags)\n{\n\tif (ext->packets != ULLONG_MAX &&\n\t    !(flags & IPSET_FLAG_SKIP_COUNTER_UPDATE)) {\n\t\tip_set_add_bytes(ext->bytes, counter);\n\t\tip_set_add_packets(ext->packets, counter);\n\t}\n}\n\nstatic void\nip_set_get_skbinfo(struct ip_set_skbinfo *skbinfo,\n\t\t   const struct ip_set_ext *ext,\n\t\t   struct ip_set_ext *mext, u32 flags)\n{\n\tmext->skbinfo = *skbinfo;\n}\n\nbool\nip_set_match_extensions(struct ip_set *set, const struct ip_set_ext *ext,\n\t\t\tstruct ip_set_ext *mext, u32 flags, void *data)\n{\n\tif (SET_WITH_TIMEOUT(set) &&\n\t    ip_set_timeout_expired(ext_timeout(data, set)))\n\t\treturn false;\n\tif (SET_WITH_COUNTER(set)) {\n\t\tstruct ip_set_counter *counter = ext_counter(data, set);\n\n\t\tip_set_update_counter(counter, ext, flags);\n\n\t\tif (flags & IPSET_FLAG_MATCH_COUNTERS &&\n\t\t    !(ip_set_match_counter(ip_set_get_packets(counter),\n\t\t\t\tmext->packets, mext->packets_op) &&\n\t\t      ip_set_match_counter(ip_set_get_bytes(counter),\n\t\t\t\tmext->bytes, mext->bytes_op)))\n\t\t\treturn false;\n\t}\n\tif (SET_WITH_SKBINFO(set))\n\t\tip_set_get_skbinfo(ext_skbinfo(data, set),\n\t\t\t\t   ext, mext, flags);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(ip_set_match_extensions);\n\n \n\nstatic void\n__ip_set_get(struct ip_set *set)\n{\n\twrite_lock_bh(&ip_set_ref_lock);\n\tset->ref++;\n\twrite_unlock_bh(&ip_set_ref_lock);\n}\n\nstatic void\n__ip_set_put(struct ip_set *set)\n{\n\twrite_lock_bh(&ip_set_ref_lock);\n\tBUG_ON(set->ref == 0);\n\tset->ref--;\n\twrite_unlock_bh(&ip_set_ref_lock);\n}\n\n \nstatic void\n__ip_set_get_netlink(struct ip_set *set)\n{\n\twrite_lock_bh(&ip_set_ref_lock);\n\tset->ref_netlink++;\n\twrite_unlock_bh(&ip_set_ref_lock);\n}\n\nstatic void\n__ip_set_put_netlink(struct ip_set *set)\n{\n\twrite_lock_bh(&ip_set_ref_lock);\n\tBUG_ON(set->ref_netlink == 0);\n\tset->ref_netlink--;\n\twrite_unlock_bh(&ip_set_ref_lock);\n}\n\n \n\nstatic struct ip_set *\nip_set_rcu_get(struct net *net, ip_set_id_t index)\n{\n\tstruct ip_set_net *inst = ip_set_pernet(net);\n\n\t \n\treturn ip_set_dereference_nfnl(inst->ip_set_list)[index];\n}\n\nstatic inline void\nip_set_lock(struct ip_set *set)\n{\n\tif (!set->variant->region_lock)\n\t\tspin_lock_bh(&set->lock);\n}\n\nstatic inline void\nip_set_unlock(struct ip_set *set)\n{\n\tif (!set->variant->region_lock)\n\t\tspin_unlock_bh(&set->lock);\n}\n\nint\nip_set_test(ip_set_id_t index, const struct sk_buff *skb,\n\t    const struct xt_action_param *par, struct ip_set_adt_opt *opt)\n{\n\tstruct ip_set *set = ip_set_rcu_get(xt_net(par), index);\n\tint ret = 0;\n\n\tBUG_ON(!set);\n\tpr_debug(\"set %s, index %u\\n\", set->name, index);\n\n\tif (opt->dim < set->type->dimension ||\n\t    !(opt->family == set->family || set->family == NFPROTO_UNSPEC))\n\t\treturn 0;\n\n\tret = set->variant->kadt(set, skb, par, IPSET_TEST, opt);\n\n\tif (ret == -EAGAIN) {\n\t\t \n\t\tpr_debug(\"element must be completed, ADD is triggered\\n\");\n\t\tip_set_lock(set);\n\t\tset->variant->kadt(set, skb, par, IPSET_ADD, opt);\n\t\tip_set_unlock(set);\n\t\tret = 1;\n\t} else {\n\t\t \n\t\tif ((opt->cmdflags & IPSET_FLAG_RETURN_NOMATCH) &&\n\t\t    (set->type->features & IPSET_TYPE_NOMATCH) &&\n\t\t    (ret > 0 || ret == -ENOTEMPTY))\n\t\t\tret = -ret;\n\t}\n\n\t \n\treturn (ret < 0 ? 0 : ret);\n}\nEXPORT_SYMBOL_GPL(ip_set_test);\n\nint\nip_set_add(ip_set_id_t index, const struct sk_buff *skb,\n\t   const struct xt_action_param *par, struct ip_set_adt_opt *opt)\n{\n\tstruct ip_set *set = ip_set_rcu_get(xt_net(par), index);\n\tint ret;\n\n\tBUG_ON(!set);\n\tpr_debug(\"set %s, index %u\\n\", set->name, index);\n\n\tif (opt->dim < set->type->dimension ||\n\t    !(opt->family == set->family || set->family == NFPROTO_UNSPEC))\n\t\treturn -IPSET_ERR_TYPE_MISMATCH;\n\n\tip_set_lock(set);\n\tret = set->variant->kadt(set, skb, par, IPSET_ADD, opt);\n\tip_set_unlock(set);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ip_set_add);\n\nint\nip_set_del(ip_set_id_t index, const struct sk_buff *skb,\n\t   const struct xt_action_param *par, struct ip_set_adt_opt *opt)\n{\n\tstruct ip_set *set = ip_set_rcu_get(xt_net(par), index);\n\tint ret = 0;\n\n\tBUG_ON(!set);\n\tpr_debug(\"set %s, index %u\\n\", set->name, index);\n\n\tif (opt->dim < set->type->dimension ||\n\t    !(opt->family == set->family || set->family == NFPROTO_UNSPEC))\n\t\treturn -IPSET_ERR_TYPE_MISMATCH;\n\n\tip_set_lock(set);\n\tret = set->variant->kadt(set, skb, par, IPSET_DEL, opt);\n\tip_set_unlock(set);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ip_set_del);\n\n \nip_set_id_t\nip_set_get_byname(struct net *net, const char *name, struct ip_set **set)\n{\n\tip_set_id_t i, index = IPSET_INVALID_ID;\n\tstruct ip_set *s;\n\tstruct ip_set_net *inst = ip_set_pernet(net);\n\n\trcu_read_lock();\n\tfor (i = 0; i < inst->ip_set_max; i++) {\n\t\ts = rcu_dereference(inst->ip_set_list)[i];\n\t\tif (s && STRNCMP(s->name, name)) {\n\t\t\t__ip_set_get(s);\n\t\t\tindex = i;\n\t\t\t*set = s;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn index;\n}\nEXPORT_SYMBOL_GPL(ip_set_get_byname);\n\n \n\nstatic void\n__ip_set_put_byindex(struct ip_set_net *inst, ip_set_id_t index)\n{\n\tstruct ip_set *set;\n\n\trcu_read_lock();\n\tset = rcu_dereference(inst->ip_set_list)[index];\n\tif (set)\n\t\t__ip_set_put(set);\n\trcu_read_unlock();\n}\n\nvoid\nip_set_put_byindex(struct net *net, ip_set_id_t index)\n{\n\tstruct ip_set_net *inst = ip_set_pernet(net);\n\n\t__ip_set_put_byindex(inst, index);\n}\nEXPORT_SYMBOL_GPL(ip_set_put_byindex);\n\n \nvoid\nip_set_name_byindex(struct net *net, ip_set_id_t index, char *name)\n{\n\tstruct ip_set *set = ip_set_rcu_get(net, index);\n\n\tBUG_ON(!set);\n\n\tread_lock_bh(&ip_set_ref_lock);\n\tstrscpy_pad(name, set->name, IPSET_MAXNAMELEN);\n\tread_unlock_bh(&ip_set_ref_lock);\n}\nEXPORT_SYMBOL_GPL(ip_set_name_byindex);\n\n \n\n \nip_set_id_t\nip_set_nfnl_get_byindex(struct net *net, ip_set_id_t index)\n{\n\tstruct ip_set *set;\n\tstruct ip_set_net *inst = ip_set_pernet(net);\n\n\tif (index >= inst->ip_set_max)\n\t\treturn IPSET_INVALID_ID;\n\n\tnfnl_lock(NFNL_SUBSYS_IPSET);\n\tset = ip_set(inst, index);\n\tif (set)\n\t\t__ip_set_get(set);\n\telse\n\t\tindex = IPSET_INVALID_ID;\n\tnfnl_unlock(NFNL_SUBSYS_IPSET);\n\n\treturn index;\n}\nEXPORT_SYMBOL_GPL(ip_set_nfnl_get_byindex);\n\n \nvoid\nip_set_nfnl_put(struct net *net, ip_set_id_t index)\n{\n\tstruct ip_set *set;\n\tstruct ip_set_net *inst = ip_set_pernet(net);\n\n\tnfnl_lock(NFNL_SUBSYS_IPSET);\n\tif (!inst->is_deleted) {  \n\t\tset = ip_set(inst, index);\n\t\tif (set)\n\t\t\t__ip_set_put(set);\n\t}\n\tnfnl_unlock(NFNL_SUBSYS_IPSET);\n}\nEXPORT_SYMBOL_GPL(ip_set_nfnl_put);\n\n \n\nstatic inline u8 protocol(const struct nlattr * const tb[])\n{\n\treturn nla_get_u8(tb[IPSET_ATTR_PROTOCOL]);\n}\n\nstatic inline bool\nprotocol_failed(const struct nlattr * const tb[])\n{\n\treturn !tb[IPSET_ATTR_PROTOCOL] || protocol(tb) != IPSET_PROTOCOL;\n}\n\nstatic inline bool\nprotocol_min_failed(const struct nlattr * const tb[])\n{\n\treturn !tb[IPSET_ATTR_PROTOCOL] || protocol(tb) < IPSET_PROTOCOL_MIN;\n}\n\nstatic inline u32\nflag_exist(const struct nlmsghdr *nlh)\n{\n\treturn nlh->nlmsg_flags & NLM_F_EXCL ? 0 : IPSET_FLAG_EXIST;\n}\n\nstatic struct nlmsghdr *\nstart_msg(struct sk_buff *skb, u32 portid, u32 seq, unsigned int flags,\n\t  enum ipset_cmd cmd)\n{\n\treturn nfnl_msg_put(skb, portid, seq,\n\t\t\t    nfnl_msg_type(NFNL_SUBSYS_IPSET, cmd), flags,\n\t\t\t    NFPROTO_IPV4, NFNETLINK_V0, 0);\n}\n\n \n\nstatic const struct nla_policy ip_set_create_policy[IPSET_ATTR_CMD_MAX + 1] = {\n\t[IPSET_ATTR_PROTOCOL]\t= { .type = NLA_U8 },\n\t[IPSET_ATTR_SETNAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = IPSET_MAXNAMELEN - 1 },\n\t[IPSET_ATTR_TYPENAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = IPSET_MAXNAMELEN - 1},\n\t[IPSET_ATTR_REVISION]\t= { .type = NLA_U8 },\n\t[IPSET_ATTR_FAMILY]\t= { .type = NLA_U8 },\n\t[IPSET_ATTR_DATA]\t= { .type = NLA_NESTED },\n};\n\nstatic struct ip_set *\nfind_set_and_id(struct ip_set_net *inst, const char *name, ip_set_id_t *id)\n{\n\tstruct ip_set *set = NULL;\n\tip_set_id_t i;\n\n\t*id = IPSET_INVALID_ID;\n\tfor (i = 0; i < inst->ip_set_max; i++) {\n\t\tset = ip_set(inst, i);\n\t\tif (set && STRNCMP(set->name, name)) {\n\t\t\t*id = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (*id == IPSET_INVALID_ID ? NULL : set);\n}\n\nstatic inline struct ip_set *\nfind_set(struct ip_set_net *inst, const char *name)\n{\n\tip_set_id_t id;\n\n\treturn find_set_and_id(inst, name, &id);\n}\n\nstatic int\nfind_free_id(struct ip_set_net *inst, const char *name, ip_set_id_t *index,\n\t     struct ip_set **set)\n{\n\tstruct ip_set *s;\n\tip_set_id_t i;\n\n\t*index = IPSET_INVALID_ID;\n\tfor (i = 0;  i < inst->ip_set_max; i++) {\n\t\ts = ip_set(inst, i);\n\t\tif (!s) {\n\t\t\tif (*index == IPSET_INVALID_ID)\n\t\t\t\t*index = i;\n\t\t} else if (STRNCMP(name, s->name)) {\n\t\t\t \n\t\t\t*set = s;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tif (*index == IPSET_INVALID_ID)\n\t\t \n\t\treturn -IPSET_ERR_MAX_SETS;\n\treturn 0;\n}\n\nstatic int ip_set_none(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t       const struct nlattr * const attr[])\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ip_set_create(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t const struct nlattr * const attr[])\n{\n\tstruct ip_set_net *inst = ip_set_pernet(info->net);\n\tstruct ip_set *set, *clash = NULL;\n\tip_set_id_t index = IPSET_INVALID_ID;\n\tstruct nlattr *tb[IPSET_ATTR_CREATE_MAX + 1] = {};\n\tconst char *name, *typename;\n\tu8 family, revision;\n\tu32 flags = flag_exist(info->nlh);\n\tint ret = 0;\n\n\tif (unlikely(protocol_min_failed(attr) ||\n\t\t     !attr[IPSET_ATTR_SETNAME] ||\n\t\t     !attr[IPSET_ATTR_TYPENAME] ||\n\t\t     !attr[IPSET_ATTR_REVISION] ||\n\t\t     !attr[IPSET_ATTR_FAMILY] ||\n\t\t     (attr[IPSET_ATTR_DATA] &&\n\t\t      !flag_nested(attr[IPSET_ATTR_DATA]))))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tname = nla_data(attr[IPSET_ATTR_SETNAME]);\n\ttypename = nla_data(attr[IPSET_ATTR_TYPENAME]);\n\tfamily = nla_get_u8(attr[IPSET_ATTR_FAMILY]);\n\trevision = nla_get_u8(attr[IPSET_ATTR_REVISION]);\n\tpr_debug(\"setname: %s, typename: %s, family: %s, revision: %u\\n\",\n\t\t name, typename, family_name(family), revision);\n\n\t \n\tset = kzalloc(sizeof(*set), GFP_KERNEL);\n\tif (!set)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&set->lock);\n\tstrscpy(set->name, name, IPSET_MAXNAMELEN);\n\tset->family = family;\n\tset->revision = revision;\n\n\t \n\tret = find_set_type_get(typename, family, revision, &set->type);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (attr[IPSET_ATTR_DATA] &&\n\t    nla_parse_nested(tb, IPSET_ATTR_CREATE_MAX, attr[IPSET_ATTR_DATA],\n\t\t\t     set->type->create_policy, NULL)) {\n\t\tret = -IPSET_ERR_PROTOCOL;\n\t\tgoto put_out;\n\t}\n\t \n\tset->flags |= set->type->create_flags[revision];\n\n\tret = set->type->create(info->net, set, tb, flags);\n\tif (ret != 0)\n\t\tgoto put_out;\n\n\t \n\n\t \n\tret = find_free_id(inst, set->name, &index, &clash);\n\tif (ret == -EEXIST) {\n\t\t \n\t\tif ((flags & IPSET_FLAG_EXIST) &&\n\t\t    STRNCMP(set->type->name, clash->type->name) &&\n\t\t    set->type->family == clash->type->family &&\n\t\t    set->type->revision_min == clash->type->revision_min &&\n\t\t    set->type->revision_max == clash->type->revision_max &&\n\t\t    set->variant->same_set(set, clash))\n\t\t\tret = 0;\n\t\tgoto cleanup;\n\t} else if (ret == -IPSET_ERR_MAX_SETS) {\n\t\tstruct ip_set **list, **tmp;\n\t\tip_set_id_t i = inst->ip_set_max + IP_SET_INC;\n\n\t\tif (i < inst->ip_set_max || i == IPSET_INVALID_ID)\n\t\t\t \n\t\t\tgoto cleanup;\n\n\t\tlist = kvcalloc(i, sizeof(struct ip_set *), GFP_KERNEL);\n\t\tif (!list)\n\t\t\tgoto cleanup;\n\t\t \n\t\ttmp = ip_set_dereference(inst->ip_set_list);\n\t\tmemcpy(list, tmp, sizeof(struct ip_set *) * inst->ip_set_max);\n\t\trcu_assign_pointer(inst->ip_set_list, list);\n\t\t \n\t\tsynchronize_net();\n\t\t \n\t\tindex = inst->ip_set_max;\n\t\tinst->ip_set_max = i;\n\t\tkvfree(tmp);\n\t\tret = 0;\n\t} else if (ret) {\n\t\tgoto cleanup;\n\t}\n\n\t \n\tpr_debug(\"create: '%s' created with index %u!\\n\", set->name, index);\n\tip_set(inst, index) = set;\n\n\treturn ret;\n\ncleanup:\n\tset->variant->destroy(set);\nput_out:\n\tmodule_put(set->type->me);\nout:\n\tkfree(set);\n\treturn ret;\n}\n\n \n\nstatic const struct nla_policy\nip_set_setname_policy[IPSET_ATTR_CMD_MAX + 1] = {\n\t[IPSET_ATTR_PROTOCOL]\t= { .type = NLA_U8 },\n\t[IPSET_ATTR_SETNAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = IPSET_MAXNAMELEN - 1 },\n};\n\nstatic void\nip_set_destroy_set(struct ip_set *set)\n{\n\tpr_debug(\"set: %s\\n\",  set->name);\n\n\t \n\tset->variant->destroy(set);\n\tmodule_put(set->type->me);\n\tkfree(set);\n}\n\nstatic int ip_set_destroy(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t  const struct nlattr * const attr[])\n{\n\tstruct ip_set_net *inst = ip_set_pernet(info->net);\n\tstruct ip_set *s;\n\tip_set_id_t i;\n\tint ret = 0;\n\n\tif (unlikely(protocol_min_failed(attr)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\t \n\trcu_barrier();\n\n\t \n\tread_lock_bh(&ip_set_ref_lock);\n\tif (!attr[IPSET_ATTR_SETNAME]) {\n\t\tfor (i = 0; i < inst->ip_set_max; i++) {\n\t\t\ts = ip_set(inst, i);\n\t\t\tif (s && (s->ref || s->ref_netlink)) {\n\t\t\t\tret = -IPSET_ERR_BUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tinst->is_destroyed = true;\n\t\tread_unlock_bh(&ip_set_ref_lock);\n\t\tfor (i = 0; i < inst->ip_set_max; i++) {\n\t\t\ts = ip_set(inst, i);\n\t\t\tif (s) {\n\t\t\t\tip_set(inst, i) = NULL;\n\t\t\t\tip_set_destroy_set(s);\n\t\t\t}\n\t\t}\n\t\t \n\t\tinst->is_destroyed = false;\n\t} else {\n\t\tu32 flags = flag_exist(info->nlh);\n\t\ts = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME]),\n\t\t\t\t    &i);\n\t\tif (!s) {\n\t\t\tif (!(flags & IPSET_FLAG_EXIST))\n\t\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t} else if (s->ref || s->ref_netlink) {\n\t\t\tret = -IPSET_ERR_BUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tip_set(inst, i) = NULL;\n\t\tread_unlock_bh(&ip_set_ref_lock);\n\n\t\tip_set_destroy_set(s);\n\t}\n\treturn 0;\nout:\n\tread_unlock_bh(&ip_set_ref_lock);\n\treturn ret;\n}\n\n \n\nstatic void\nip_set_flush_set(struct ip_set *set)\n{\n\tpr_debug(\"set: %s\\n\",  set->name);\n\n\tip_set_lock(set);\n\tset->variant->flush(set);\n\tip_set_unlock(set);\n}\n\nstatic int ip_set_flush(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\tconst struct nlattr * const attr[])\n{\n\tstruct ip_set_net *inst = ip_set_pernet(info->net);\n\tstruct ip_set *s;\n\tip_set_id_t i;\n\n\tif (unlikely(protocol_min_failed(attr)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tif (!attr[IPSET_ATTR_SETNAME]) {\n\t\tfor (i = 0; i < inst->ip_set_max; i++) {\n\t\t\ts = ip_set(inst, i);\n\t\t\tif (s)\n\t\t\t\tip_set_flush_set(s);\n\t\t}\n\t} else {\n\t\ts = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME]));\n\t\tif (!s)\n\t\t\treturn -ENOENT;\n\n\t\tip_set_flush_set(s);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct nla_policy\nip_set_setname2_policy[IPSET_ATTR_CMD_MAX + 1] = {\n\t[IPSET_ATTR_PROTOCOL]\t= { .type = NLA_U8 },\n\t[IPSET_ATTR_SETNAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = IPSET_MAXNAMELEN - 1 },\n\t[IPSET_ATTR_SETNAME2]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = IPSET_MAXNAMELEN - 1 },\n};\n\nstatic int ip_set_rename(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t const struct nlattr * const attr[])\n{\n\tstruct ip_set_net *inst = ip_set_pernet(info->net);\n\tstruct ip_set *set, *s;\n\tconst char *name2;\n\tip_set_id_t i;\n\tint ret = 0;\n\n\tif (unlikely(protocol_min_failed(attr) ||\n\t\t     !attr[IPSET_ATTR_SETNAME] ||\n\t\t     !attr[IPSET_ATTR_SETNAME2]))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tset = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME]));\n\tif (!set)\n\t\treturn -ENOENT;\n\n\twrite_lock_bh(&ip_set_ref_lock);\n\tif (set->ref != 0 || set->ref_netlink != 0) {\n\t\tret = -IPSET_ERR_REFERENCED;\n\t\tgoto out;\n\t}\n\n\tname2 = nla_data(attr[IPSET_ATTR_SETNAME2]);\n\tfor (i = 0; i < inst->ip_set_max; i++) {\n\t\ts = ip_set(inst, i);\n\t\tif (s && STRNCMP(s->name, name2)) {\n\t\t\tret = -IPSET_ERR_EXIST_SETNAME2;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tstrscpy_pad(set->name, name2, IPSET_MAXNAMELEN);\n\nout:\n\twrite_unlock_bh(&ip_set_ref_lock);\n\treturn ret;\n}\n\n \n\nstatic int ip_set_swap(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t       const struct nlattr * const attr[])\n{\n\tstruct ip_set_net *inst = ip_set_pernet(info->net);\n\tstruct ip_set *from, *to;\n\tip_set_id_t from_id, to_id;\n\tchar from_name[IPSET_MAXNAMELEN];\n\n\tif (unlikely(protocol_min_failed(attr) ||\n\t\t     !attr[IPSET_ATTR_SETNAME] ||\n\t\t     !attr[IPSET_ATTR_SETNAME2]))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tfrom = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME]),\n\t\t\t       &from_id);\n\tif (!from)\n\t\treturn -ENOENT;\n\n\tto = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME2]),\n\t\t\t     &to_id);\n\tif (!to)\n\t\treturn -IPSET_ERR_EXIST_SETNAME2;\n\n\t \n\tif (!(from->type->features == to->type->features &&\n\t      from->family == to->family))\n\t\treturn -IPSET_ERR_TYPE_MISMATCH;\n\n\twrite_lock_bh(&ip_set_ref_lock);\n\n\tif (from->ref_netlink || to->ref_netlink) {\n\t\twrite_unlock_bh(&ip_set_ref_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tstrscpy_pad(from_name, from->name, IPSET_MAXNAMELEN);\n\tstrscpy_pad(from->name, to->name, IPSET_MAXNAMELEN);\n\tstrscpy_pad(to->name, from_name, IPSET_MAXNAMELEN);\n\n\tswap(from->ref, to->ref);\n\tip_set(inst, from_id) = to;\n\tip_set(inst, to_id) = from;\n\twrite_unlock_bh(&ip_set_ref_lock);\n\n\t \n\tsynchronize_rcu();\n\n\treturn 0;\n}\n\n \n\n#define DUMP_INIT\t0\n#define DUMP_ALL\t1\n#define DUMP_ONE\t2\n#define DUMP_LAST\t3\n\n#define DUMP_TYPE(arg)\t\t(((u32)(arg)) & 0x0000FFFF)\n#define DUMP_FLAGS(arg)\t\t(((u32)(arg)) >> 16)\n\nint\nip_set_put_flags(struct sk_buff *skb, struct ip_set *set)\n{\n\tu32 cadt_flags = 0;\n\n\tif (SET_WITH_TIMEOUT(set))\n\t\tif (unlikely(nla_put_net32(skb, IPSET_ATTR_TIMEOUT,\n\t\t\t\t\t   htonl(set->timeout))))\n\t\t\treturn -EMSGSIZE;\n\tif (SET_WITH_COUNTER(set))\n\t\tcadt_flags |= IPSET_FLAG_WITH_COUNTERS;\n\tif (SET_WITH_COMMENT(set))\n\t\tcadt_flags |= IPSET_FLAG_WITH_COMMENT;\n\tif (SET_WITH_SKBINFO(set))\n\t\tcadt_flags |= IPSET_FLAG_WITH_SKBINFO;\n\tif (SET_WITH_FORCEADD(set))\n\t\tcadt_flags |= IPSET_FLAG_WITH_FORCEADD;\n\n\tif (!cadt_flags)\n\t\treturn 0;\n\treturn nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(cadt_flags));\n}\nEXPORT_SYMBOL_GPL(ip_set_put_flags);\n\nstatic int\nip_set_dump_done(struct netlink_callback *cb)\n{\n\tif (cb->args[IPSET_CB_ARG0]) {\n\t\tstruct ip_set_net *inst =\n\t\t\t(struct ip_set_net *)cb->args[IPSET_CB_NET];\n\t\tip_set_id_t index = (ip_set_id_t)cb->args[IPSET_CB_INDEX];\n\t\tstruct ip_set *set = ip_set_ref_netlink(inst, index);\n\n\t\tif (set->variant->uref)\n\t\t\tset->variant->uref(set, cb, false);\n\t\tpr_debug(\"release set %s\\n\", set->name);\n\t\t__ip_set_put_netlink(set);\n\t}\n\treturn 0;\n}\n\nstatic inline void\ndump_attrs(struct nlmsghdr *nlh)\n{\n\tconst struct nlattr *attr;\n\tint rem;\n\n\tpr_debug(\"dump nlmsg\\n\");\n\tnlmsg_for_each_attr(attr, nlh, sizeof(struct nfgenmsg), rem) {\n\t\tpr_debug(\"type: %u, len %u\\n\", nla_type(attr), attr->nla_len);\n\t}\n}\n\nstatic const struct nla_policy\nip_set_dump_policy[IPSET_ATTR_CMD_MAX + 1] = {\n\t[IPSET_ATTR_PROTOCOL]\t= { .type = NLA_U8 },\n\t[IPSET_ATTR_SETNAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = IPSET_MAXNAMELEN - 1 },\n\t[IPSET_ATTR_FLAGS]\t= { .type = NLA_U32 },\n};\n\nstatic int\nip_set_dump_start(struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(cb->skb);\n\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\tstruct nlattr *cda[IPSET_ATTR_CMD_MAX + 1];\n\tstruct nlattr *attr = (void *)nlh + min_len;\n\tstruct sk_buff *skb = cb->skb;\n\tstruct ip_set_net *inst = ip_set_pernet(sock_net(skb->sk));\n\tu32 dump_type;\n\tint ret;\n\n\tret = nla_parse(cda, IPSET_ATTR_CMD_MAX, attr,\n\t\t\tnlh->nlmsg_len - min_len,\n\t\t\tip_set_dump_policy, NULL);\n\tif (ret)\n\t\tgoto error;\n\n\tcb->args[IPSET_CB_PROTO] = nla_get_u8(cda[IPSET_ATTR_PROTOCOL]);\n\tif (cda[IPSET_ATTR_SETNAME]) {\n\t\tip_set_id_t index;\n\t\tstruct ip_set *set;\n\n\t\tset = find_set_and_id(inst, nla_data(cda[IPSET_ATTR_SETNAME]),\n\t\t\t\t      &index);\n\t\tif (!set) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\t\tdump_type = DUMP_ONE;\n\t\tcb->args[IPSET_CB_INDEX] = index;\n\t} else {\n\t\tdump_type = DUMP_ALL;\n\t}\n\n\tif (cda[IPSET_ATTR_FLAGS]) {\n\t\tu32 f = ip_set_get_h32(cda[IPSET_ATTR_FLAGS]);\n\n\t\tdump_type |= (f << 16);\n\t}\n\tcb->args[IPSET_CB_NET] = (unsigned long)inst;\n\tcb->args[IPSET_CB_DUMP] = dump_type;\n\n\treturn 0;\n\nerror:\n\t \n\tif (nlh->nlmsg_flags & NLM_F_ACK) {\n\t\tnetlink_ack(cb->skb, nlh, ret, NULL);\n\t}\n\treturn ret;\n}\n\nstatic int\nip_set_dump_do(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tip_set_id_t index = IPSET_INVALID_ID, max;\n\tstruct ip_set *set = NULL;\n\tstruct nlmsghdr *nlh = NULL;\n\tunsigned int flags = NETLINK_CB(cb->skb).portid ? NLM_F_MULTI : 0;\n\tstruct ip_set_net *inst = ip_set_pernet(sock_net(skb->sk));\n\tu32 dump_type, dump_flags;\n\tbool is_destroyed;\n\tint ret = 0;\n\n\tif (!cb->args[IPSET_CB_DUMP])\n\t\treturn -EINVAL;\n\n\tif (cb->args[IPSET_CB_INDEX] >= inst->ip_set_max)\n\t\tgoto out;\n\n\tdump_type = DUMP_TYPE(cb->args[IPSET_CB_DUMP]);\n\tdump_flags = DUMP_FLAGS(cb->args[IPSET_CB_DUMP]);\n\tmax = dump_type == DUMP_ONE ? cb->args[IPSET_CB_INDEX] + 1\n\t\t\t\t    : inst->ip_set_max;\ndump_last:\n\tpr_debug(\"dump type, flag: %u %u index: %ld\\n\",\n\t\t dump_type, dump_flags, cb->args[IPSET_CB_INDEX]);\n\tfor (; cb->args[IPSET_CB_INDEX] < max; cb->args[IPSET_CB_INDEX]++) {\n\t\tindex = (ip_set_id_t)cb->args[IPSET_CB_INDEX];\n\t\twrite_lock_bh(&ip_set_ref_lock);\n\t\tset = ip_set(inst, index);\n\t\tis_destroyed = inst->is_destroyed;\n\t\tif (!set || is_destroyed) {\n\t\t\twrite_unlock_bh(&ip_set_ref_lock);\n\t\t\tif (dump_type == DUMP_ONE) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_destroyed) {\n\t\t\t\t \n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (dump_type != DUMP_ONE &&\n\t\t    ((dump_type == DUMP_ALL) ==\n\t\t     !!(set->type->features & IPSET_DUMP_LAST))) {\n\t\t\twrite_unlock_bh(&ip_set_ref_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_debug(\"List set: %s\\n\", set->name);\n\t\tif (!cb->args[IPSET_CB_ARG0]) {\n\t\t\t \n\t\t\tpr_debug(\"reference set\\n\");\n\t\t\tset->ref_netlink++;\n\t\t}\n\t\twrite_unlock_bh(&ip_set_ref_lock);\n\t\tnlh = start_msg(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, flags,\n\t\t\t\tIPSET_CMD_LIST);\n\t\tif (!nlh) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto release_refcount;\n\t\t}\n\t\tif (nla_put_u8(skb, IPSET_ATTR_PROTOCOL,\n\t\t\t       cb->args[IPSET_CB_PROTO]) ||\n\t\t    nla_put_string(skb, IPSET_ATTR_SETNAME, set->name))\n\t\t\tgoto nla_put_failure;\n\t\tif (dump_flags & IPSET_FLAG_LIST_SETNAME)\n\t\t\tgoto next_set;\n\t\tswitch (cb->args[IPSET_CB_ARG0]) {\n\t\tcase 0:\n\t\t\t \n\t\t\tif (nla_put_string(skb, IPSET_ATTR_TYPENAME,\n\t\t\t\t\t   set->type->name) ||\n\t\t\t    nla_put_u8(skb, IPSET_ATTR_FAMILY,\n\t\t\t\t       set->family) ||\n\t\t\t    nla_put_u8(skb, IPSET_ATTR_REVISION,\n\t\t\t\t       set->revision))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (cb->args[IPSET_CB_PROTO] > IPSET_PROTOCOL_MIN &&\n\t\t\t    nla_put_net16(skb, IPSET_ATTR_INDEX, htons(index)))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tret = set->variant->head(set, skb);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto release_refcount;\n\t\t\tif (dump_flags & IPSET_FLAG_LIST_HEADER)\n\t\t\t\tgoto next_set;\n\t\t\tif (set->variant->uref)\n\t\t\t\tset->variant->uref(set, cb, true);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tret = set->variant->list(set, skb, cb);\n\t\t\tif (!cb->args[IPSET_CB_ARG0])\n\t\t\t\t \n\t\t\t\tgoto next_set;\n\t\t\tgoto release_refcount;\n\t\t}\n\t}\n\t \n\tif (dump_type == DUMP_ALL) {\n\t\tdump_type = DUMP_LAST;\n\t\tcb->args[IPSET_CB_DUMP] = dump_type | (dump_flags << 16);\n\t\tcb->args[IPSET_CB_INDEX] = 0;\n\t\tif (set && set->variant->uref)\n\t\t\tset->variant->uref(set, cb, false);\n\t\tgoto dump_last;\n\t}\n\tgoto out;\n\nnla_put_failure:\n\tret = -EFAULT;\nnext_set:\n\tif (dump_type == DUMP_ONE)\n\t\tcb->args[IPSET_CB_INDEX] = IPSET_INVALID_ID;\n\telse\n\t\tcb->args[IPSET_CB_INDEX]++;\nrelease_refcount:\n\t \n\tif (ret || !cb->args[IPSET_CB_ARG0]) {\n\t\tset = ip_set_ref_netlink(inst, index);\n\t\tif (set->variant->uref)\n\t\t\tset->variant->uref(set, cb, false);\n\t\tpr_debug(\"release set %s\\n\", set->name);\n\t\t__ip_set_put_netlink(set);\n\t\tcb->args[IPSET_CB_ARG0] = 0;\n\t}\nout:\n\tif (nlh) {\n\t\tnlmsg_end(skb, nlh);\n\t\tpr_debug(\"nlmsg_len: %u\\n\", nlh->nlmsg_len);\n\t\tdump_attrs(nlh);\n\t}\n\n\treturn ret < 0 ? ret : skb->len;\n}\n\nstatic int ip_set_dump(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t       const struct nlattr * const attr[])\n{\n\tif (unlikely(protocol_min_failed(attr)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\t{\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = ip_set_dump_start,\n\t\t\t.dump = ip_set_dump_do,\n\t\t\t.done = ip_set_dump_done,\n\t\t};\n\t\treturn netlink_dump_start(info->sk, skb, info->nlh, &c);\n\t}\n}\n\n \n\nstatic const struct nla_policy ip_set_adt_policy[IPSET_ATTR_CMD_MAX + 1] = {\n\t[IPSET_ATTR_PROTOCOL]\t= { .type = NLA_U8 },\n\t[IPSET_ATTR_SETNAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = IPSET_MAXNAMELEN - 1 },\n\t[IPSET_ATTR_LINENO]\t= { .type = NLA_U32 },\n\t[IPSET_ATTR_DATA]\t= { .type = NLA_NESTED },\n\t[IPSET_ATTR_ADT]\t= { .type = NLA_NESTED },\n};\n\nstatic int\ncall_ad(struct net *net, struct sock *ctnl, struct sk_buff *skb,\n\tstruct ip_set *set, struct nlattr *tb[], enum ipset_adt adt,\n\tu32 flags, bool use_lineno)\n{\n\tint ret;\n\tu32 lineno = 0;\n\tbool eexist = flags & IPSET_FLAG_EXIST, retried = false;\n\n\tdo {\n\t\tif (retried) {\n\t\t\t__ip_set_get_netlink(set);\n\t\t\tnfnl_unlock(NFNL_SUBSYS_IPSET);\n\t\t\tcond_resched();\n\t\t\tnfnl_lock(NFNL_SUBSYS_IPSET);\n\t\t\t__ip_set_put_netlink(set);\n\t\t}\n\n\t\tip_set_lock(set);\n\t\tret = set->variant->uadt(set, tb, adt, &lineno, flags, retried);\n\t\tip_set_unlock(set);\n\t\tretried = true;\n\t} while (ret == -ERANGE ||\n\t\t (ret == -EAGAIN &&\n\t\t  set->variant->resize &&\n\t\t  (ret = set->variant->resize(set, retried)) == 0));\n\n\tif (!ret || (ret == -IPSET_ERR_EXIST && eexist))\n\t\treturn 0;\n\tif (lineno && use_lineno) {\n\t\t \n\t\tstruct nlmsghdr *rep, *nlh = nlmsg_hdr(skb);\n\t\tstruct sk_buff *skb2;\n\t\tstruct nlmsgerr *errmsg;\n\t\tsize_t payload = min(SIZE_MAX,\n\t\t\t\t     sizeof(*errmsg) + nlmsg_len(nlh));\n\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\tstruct nlattr *cda[IPSET_ATTR_CMD_MAX + 1];\n\t\tstruct nlattr *cmdattr;\n\t\tu32 *errline;\n\n\t\tskb2 = nlmsg_new(payload, GFP_KERNEL);\n\t\tif (!skb2)\n\t\t\treturn -ENOMEM;\n\t\trep = nlmsg_put(skb2, NETLINK_CB(skb).portid,\n\t\t\t\tnlh->nlmsg_seq, NLMSG_ERROR, payload, 0);\n\t\terrmsg = nlmsg_data(rep);\n\t\terrmsg->error = ret;\n\t\tunsafe_memcpy(&errmsg->msg, nlh, nlh->nlmsg_len,\n\t\t\t       );\n\n\t\tcmdattr = (void *)&errmsg->msg + min_len;\n\n\t\tret = nla_parse(cda, IPSET_ATTR_CMD_MAX, cmdattr,\n\t\t\t\tnlh->nlmsg_len - min_len, ip_set_adt_policy,\n\t\t\t\tNULL);\n\n\t\tif (ret) {\n\t\t\tnlmsg_free(skb2);\n\t\t\treturn ret;\n\t\t}\n\t\terrline = nla_data(cda[IPSET_ATTR_LINENO]);\n\n\t\t*errline = lineno;\n\n\t\tnfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);\n\t\t \n\t\treturn -EINTR;\n\t}\n\n\treturn ret;\n}\n\nstatic int ip_set_ad(struct net *net, struct sock *ctnl,\n\t\t     struct sk_buff *skb,\n\t\t     enum ipset_adt adt,\n\t\t     const struct nlmsghdr *nlh,\n\t\t     const struct nlattr * const attr[],\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ip_set_net *inst = ip_set_pernet(net);\n\tstruct ip_set *set;\n\tstruct nlattr *tb[IPSET_ATTR_ADT_MAX + 1] = {};\n\tconst struct nlattr *nla;\n\tu32 flags = flag_exist(nlh);\n\tbool use_lineno;\n\tint ret = 0;\n\n\tif (unlikely(protocol_min_failed(attr) ||\n\t\t     !attr[IPSET_ATTR_SETNAME] ||\n\t\t     !((attr[IPSET_ATTR_DATA] != NULL) ^\n\t\t       (attr[IPSET_ATTR_ADT] != NULL)) ||\n\t\t     (attr[IPSET_ATTR_DATA] &&\n\t\t      !flag_nested(attr[IPSET_ATTR_DATA])) ||\n\t\t     (attr[IPSET_ATTR_ADT] &&\n\t\t      (!flag_nested(attr[IPSET_ATTR_ADT]) ||\n\t\t       !attr[IPSET_ATTR_LINENO]))))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tset = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME]));\n\tif (!set)\n\t\treturn -ENOENT;\n\n\tuse_lineno = !!attr[IPSET_ATTR_LINENO];\n\tif (attr[IPSET_ATTR_DATA]) {\n\t\tif (nla_parse_nested(tb, IPSET_ATTR_ADT_MAX,\n\t\t\t\t     attr[IPSET_ATTR_DATA],\n\t\t\t\t     set->type->adt_policy, NULL))\n\t\t\treturn -IPSET_ERR_PROTOCOL;\n\t\tret = call_ad(net, ctnl, skb, set, tb, adt, flags,\n\t\t\t      use_lineno);\n\t} else {\n\t\tint nla_rem;\n\n\t\tnla_for_each_nested(nla, attr[IPSET_ATTR_ADT], nla_rem) {\n\t\t\tif (nla_type(nla) != IPSET_ATTR_DATA ||\n\t\t\t    !flag_nested(nla) ||\n\t\t\t    nla_parse_nested(tb, IPSET_ATTR_ADT_MAX, nla,\n\t\t\t\t\t     set->type->adt_policy, NULL))\n\t\t\t\treturn -IPSET_ERR_PROTOCOL;\n\t\t\tret = call_ad(net, ctnl, skb, set, tb, adt,\n\t\t\t\t      flags, use_lineno);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int ip_set_uadd(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t       const struct nlattr * const attr[])\n{\n\treturn ip_set_ad(info->net, info->sk, skb,\n\t\t\t IPSET_ADD, info->nlh, attr, info->extack);\n}\n\nstatic int ip_set_udel(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t       const struct nlattr * const attr[])\n{\n\treturn ip_set_ad(info->net, info->sk, skb,\n\t\t\t IPSET_DEL, info->nlh, attr, info->extack);\n}\n\nstatic int ip_set_utest(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\tconst struct nlattr * const attr[])\n{\n\tstruct ip_set_net *inst = ip_set_pernet(info->net);\n\tstruct ip_set *set;\n\tstruct nlattr *tb[IPSET_ATTR_ADT_MAX + 1] = {};\n\tint ret = 0;\n\tu32 lineno;\n\n\tif (unlikely(protocol_min_failed(attr) ||\n\t\t     !attr[IPSET_ATTR_SETNAME] ||\n\t\t     !attr[IPSET_ATTR_DATA] ||\n\t\t     !flag_nested(attr[IPSET_ATTR_DATA])))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tset = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME]));\n\tif (!set)\n\t\treturn -ENOENT;\n\n\tif (nla_parse_nested(tb, IPSET_ATTR_ADT_MAX, attr[IPSET_ATTR_DATA],\n\t\t\t     set->type->adt_policy, NULL))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\trcu_read_lock_bh();\n\tret = set->variant->uadt(set, tb, IPSET_TEST, &lineno, 0, 0);\n\trcu_read_unlock_bh();\n\t \n\tif (ret == -EAGAIN)\n\t\tret = 1;\n\n\treturn ret > 0 ? 0 : -IPSET_ERR_EXIST;\n}\n\n \n\nstatic int ip_set_header(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t const struct nlattr * const attr[])\n{\n\tstruct ip_set_net *inst = ip_set_pernet(info->net);\n\tconst struct ip_set *set;\n\tstruct sk_buff *skb2;\n\tstruct nlmsghdr *nlh2;\n\n\tif (unlikely(protocol_min_failed(attr) ||\n\t\t     !attr[IPSET_ATTR_SETNAME]))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tset = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME]));\n\tif (!set)\n\t\treturn -ENOENT;\n\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\tnlh2 = start_msg(skb2, NETLINK_CB(skb).portid, info->nlh->nlmsg_seq, 0,\n\t\t\t IPSET_CMD_HEADER);\n\tif (!nlh2)\n\t\tgoto nlmsg_failure;\n\tif (nla_put_u8(skb2, IPSET_ATTR_PROTOCOL, protocol(attr)) ||\n\t    nla_put_string(skb2, IPSET_ATTR_SETNAME, set->name) ||\n\t    nla_put_string(skb2, IPSET_ATTR_TYPENAME, set->type->name) ||\n\t    nla_put_u8(skb2, IPSET_ATTR_FAMILY, set->family) ||\n\t    nla_put_u8(skb2, IPSET_ATTR_REVISION, set->revision))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb2, nlh2);\n\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n\nnla_put_failure:\n\tnlmsg_cancel(skb2, nlh2);\nnlmsg_failure:\n\tkfree_skb(skb2);\n\treturn -EMSGSIZE;\n}\n\n \n\nstatic const struct nla_policy ip_set_type_policy[IPSET_ATTR_CMD_MAX + 1] = {\n\t[IPSET_ATTR_PROTOCOL]\t= { .type = NLA_U8 },\n\t[IPSET_ATTR_TYPENAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = IPSET_MAXNAMELEN - 1 },\n\t[IPSET_ATTR_FAMILY]\t= { .type = NLA_U8 },\n};\n\nstatic int ip_set_type(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t       const struct nlattr * const attr[])\n{\n\tstruct sk_buff *skb2;\n\tstruct nlmsghdr *nlh2;\n\tu8 family, min, max;\n\tconst char *typename;\n\tint ret = 0;\n\n\tif (unlikely(protocol_min_failed(attr) ||\n\t\t     !attr[IPSET_ATTR_TYPENAME] ||\n\t\t     !attr[IPSET_ATTR_FAMILY]))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tfamily = nla_get_u8(attr[IPSET_ATTR_FAMILY]);\n\ttypename = nla_data(attr[IPSET_ATTR_TYPENAME]);\n\tret = find_set_type_minmax(typename, family, &min, &max);\n\tif (ret)\n\t\treturn ret;\n\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\tnlh2 = start_msg(skb2, NETLINK_CB(skb).portid, info->nlh->nlmsg_seq, 0,\n\t\t\t IPSET_CMD_TYPE);\n\tif (!nlh2)\n\t\tgoto nlmsg_failure;\n\tif (nla_put_u8(skb2, IPSET_ATTR_PROTOCOL, protocol(attr)) ||\n\t    nla_put_string(skb2, IPSET_ATTR_TYPENAME, typename) ||\n\t    nla_put_u8(skb2, IPSET_ATTR_FAMILY, family) ||\n\t    nla_put_u8(skb2, IPSET_ATTR_REVISION, max) ||\n\t    nla_put_u8(skb2, IPSET_ATTR_REVISION_MIN, min))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb2, nlh2);\n\n\tpr_debug(\"Send TYPE, nlmsg_len: %u\\n\", nlh2->nlmsg_len);\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n\nnla_put_failure:\n\tnlmsg_cancel(skb2, nlh2);\nnlmsg_failure:\n\tkfree_skb(skb2);\n\treturn -EMSGSIZE;\n}\n\n \n\nstatic const struct nla_policy\nip_set_protocol_policy[IPSET_ATTR_CMD_MAX + 1] = {\n\t[IPSET_ATTR_PROTOCOL]\t= { .type = NLA_U8 },\n};\n\nstatic int ip_set_protocol(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t   const struct nlattr * const attr[])\n{\n\tstruct sk_buff *skb2;\n\tstruct nlmsghdr *nlh2;\n\n\tif (unlikely(!attr[IPSET_ATTR_PROTOCOL]))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\tnlh2 = start_msg(skb2, NETLINK_CB(skb).portid, info->nlh->nlmsg_seq, 0,\n\t\t\t IPSET_CMD_PROTOCOL);\n\tif (!nlh2)\n\t\tgoto nlmsg_failure;\n\tif (nla_put_u8(skb2, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb2, IPSET_ATTR_PROTOCOL_MIN, IPSET_PROTOCOL_MIN))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb2, nlh2);\n\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n\nnla_put_failure:\n\tnlmsg_cancel(skb2, nlh2);\nnlmsg_failure:\n\tkfree_skb(skb2);\n\treturn -EMSGSIZE;\n}\n\n \n\nstatic int ip_set_byname(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t const struct nlattr * const attr[])\n{\n\tstruct ip_set_net *inst = ip_set_pernet(info->net);\n\tstruct sk_buff *skb2;\n\tstruct nlmsghdr *nlh2;\n\tip_set_id_t id = IPSET_INVALID_ID;\n\tconst struct ip_set *set;\n\n\tif (unlikely(protocol_failed(attr) ||\n\t\t     !attr[IPSET_ATTR_SETNAME]))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tset = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME]), &id);\n\tif (id == IPSET_INVALID_ID)\n\t\treturn -ENOENT;\n\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\tnlh2 = start_msg(skb2, NETLINK_CB(skb).portid, info->nlh->nlmsg_seq, 0,\n\t\t\t IPSET_CMD_GET_BYNAME);\n\tif (!nlh2)\n\t\tgoto nlmsg_failure;\n\tif (nla_put_u8(skb2, IPSET_ATTR_PROTOCOL, protocol(attr)) ||\n\t    nla_put_u8(skb2, IPSET_ATTR_FAMILY, set->family) ||\n\t    nla_put_net16(skb2, IPSET_ATTR_INDEX, htons(id)))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb2, nlh2);\n\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n\nnla_put_failure:\n\tnlmsg_cancel(skb2, nlh2);\nnlmsg_failure:\n\tkfree_skb(skb2);\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy ip_set_index_policy[IPSET_ATTR_CMD_MAX + 1] = {\n\t[IPSET_ATTR_PROTOCOL]\t= { .type = NLA_U8 },\n\t[IPSET_ATTR_INDEX]\t= { .type = NLA_U16 },\n};\n\nstatic int ip_set_byindex(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t  const struct nlattr * const attr[])\n{\n\tstruct ip_set_net *inst = ip_set_pernet(info->net);\n\tstruct sk_buff *skb2;\n\tstruct nlmsghdr *nlh2;\n\tip_set_id_t id = IPSET_INVALID_ID;\n\tconst struct ip_set *set;\n\n\tif (unlikely(protocol_failed(attr) ||\n\t\t     !attr[IPSET_ATTR_INDEX]))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tid = ip_set_get_h16(attr[IPSET_ATTR_INDEX]);\n\tif (id >= inst->ip_set_max)\n\t\treturn -ENOENT;\n\tset = ip_set(inst, id);\n\tif (set == NULL)\n\t\treturn -ENOENT;\n\n\tskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\tnlh2 = start_msg(skb2, NETLINK_CB(skb).portid, info->nlh->nlmsg_seq, 0,\n\t\t\t IPSET_CMD_GET_BYINDEX);\n\tif (!nlh2)\n\t\tgoto nlmsg_failure;\n\tif (nla_put_u8(skb2, IPSET_ATTR_PROTOCOL, protocol(attr)) ||\n\t    nla_put_string(skb2, IPSET_ATTR_SETNAME, set->name))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb2, nlh2);\n\n\treturn nfnetlink_unicast(skb2, info->net, NETLINK_CB(skb).portid);\n\nnla_put_failure:\n\tnlmsg_cancel(skb2, nlh2);\nnlmsg_failure:\n\tkfree_skb(skb2);\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nfnl_callback ip_set_netlink_subsys_cb[IPSET_MSG_MAX] = {\n\t[IPSET_CMD_NONE]\t= {\n\t\t.call\t\t= ip_set_none,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t},\n\t[IPSET_CMD_CREATE]\t= {\n\t\t.call\t\t= ip_set_create,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_create_policy,\n\t},\n\t[IPSET_CMD_DESTROY]\t= {\n\t\t.call\t\t= ip_set_destroy,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_setname_policy,\n\t},\n\t[IPSET_CMD_FLUSH]\t= {\n\t\t.call\t\t= ip_set_flush,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_setname_policy,\n\t},\n\t[IPSET_CMD_RENAME]\t= {\n\t\t.call\t\t= ip_set_rename,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_setname2_policy,\n\t},\n\t[IPSET_CMD_SWAP]\t= {\n\t\t.call\t\t= ip_set_swap,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_setname2_policy,\n\t},\n\t[IPSET_CMD_LIST]\t= {\n\t\t.call\t\t= ip_set_dump,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_dump_policy,\n\t},\n\t[IPSET_CMD_SAVE]\t= {\n\t\t.call\t\t= ip_set_dump,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_setname_policy,\n\t},\n\t[IPSET_CMD_ADD]\t= {\n\t\t.call\t\t= ip_set_uadd,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_adt_policy,\n\t},\n\t[IPSET_CMD_DEL]\t= {\n\t\t.call\t\t= ip_set_udel,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_adt_policy,\n\t},\n\t[IPSET_CMD_TEST]\t= {\n\t\t.call\t\t= ip_set_utest,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_adt_policy,\n\t},\n\t[IPSET_CMD_HEADER]\t= {\n\t\t.call\t\t= ip_set_header,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_setname_policy,\n\t},\n\t[IPSET_CMD_TYPE]\t= {\n\t\t.call\t\t= ip_set_type,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_type_policy,\n\t},\n\t[IPSET_CMD_PROTOCOL]\t= {\n\t\t.call\t\t= ip_set_protocol,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_protocol_policy,\n\t},\n\t[IPSET_CMD_GET_BYNAME]\t= {\n\t\t.call\t\t= ip_set_byname,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_setname_policy,\n\t},\n\t[IPSET_CMD_GET_BYINDEX]\t= {\n\t\t.call\t\t= ip_set_byindex,\n\t\t.type\t\t= NFNL_CB_MUTEX,\n\t\t.attr_count\t= IPSET_ATTR_CMD_MAX,\n\t\t.policy\t\t= ip_set_index_policy,\n\t},\n};\n\nstatic struct nfnetlink_subsystem ip_set_netlink_subsys __read_mostly = {\n\t.name\t\t= \"ip_set\",\n\t.subsys_id\t= NFNL_SUBSYS_IPSET,\n\t.cb_count\t= IPSET_MSG_MAX,\n\t.cb\t\t= ip_set_netlink_subsys_cb,\n};\n\n \n\nstatic int\nip_set_sockfn_get(struct sock *sk, int optval, void __user *user, int *len)\n{\n\tunsigned int *op;\n\tvoid *data;\n\tint copylen = *len, ret = 0;\n\tstruct net *net = sock_net(sk);\n\tstruct ip_set_net *inst = ip_set_pernet(net);\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (optval != SO_IP_SET)\n\t\treturn -EBADF;\n\tif (*len < sizeof(unsigned int))\n\t\treturn -EINVAL;\n\n\tdata = vmalloc(*len);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(data, user, *len) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto done;\n\t}\n\top = data;\n\n\tif (*op < IP_SET_OP_VERSION) {\n\t\t \n\t\tstruct ip_set_req_version *req_version = data;\n\n\t\tif (*len < sizeof(struct ip_set_req_version)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (req_version->version < IPSET_PROTOCOL_MIN) {\n\t\t\tret = -EPROTO;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tswitch (*op) {\n\tcase IP_SET_OP_VERSION: {\n\t\tstruct ip_set_req_version *req_version = data;\n\n\t\tif (*len != sizeof(struct ip_set_req_version)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\treq_version->version = IPSET_PROTOCOL;\n\t\tif (copy_to_user(user, req_version,\n\t\t\t\t sizeof(struct ip_set_req_version)))\n\t\t\tret = -EFAULT;\n\t\tgoto done;\n\t}\n\tcase IP_SET_OP_GET_BYNAME: {\n\t\tstruct ip_set_req_get_set *req_get = data;\n\t\tip_set_id_t id;\n\n\t\tif (*len != sizeof(struct ip_set_req_get_set)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\treq_get->set.name[IPSET_MAXNAMELEN - 1] = '\\0';\n\t\tnfnl_lock(NFNL_SUBSYS_IPSET);\n\t\tfind_set_and_id(inst, req_get->set.name, &id);\n\t\treq_get->set.index = id;\n\t\tnfnl_unlock(NFNL_SUBSYS_IPSET);\n\t\tgoto copy;\n\t}\n\tcase IP_SET_OP_GET_FNAME: {\n\t\tstruct ip_set_req_get_set_family *req_get = data;\n\t\tip_set_id_t id;\n\n\t\tif (*len != sizeof(struct ip_set_req_get_set_family)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\treq_get->set.name[IPSET_MAXNAMELEN - 1] = '\\0';\n\t\tnfnl_lock(NFNL_SUBSYS_IPSET);\n\t\tfind_set_and_id(inst, req_get->set.name, &id);\n\t\treq_get->set.index = id;\n\t\tif (id != IPSET_INVALID_ID)\n\t\t\treq_get->family = ip_set(inst, id)->family;\n\t\tnfnl_unlock(NFNL_SUBSYS_IPSET);\n\t\tgoto copy;\n\t}\n\tcase IP_SET_OP_GET_BYINDEX: {\n\t\tstruct ip_set_req_get_set *req_get = data;\n\t\tstruct ip_set *set;\n\n\t\tif (*len != sizeof(struct ip_set_req_get_set) ||\n\t\t    req_get->set.index >= inst->ip_set_max) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tnfnl_lock(NFNL_SUBSYS_IPSET);\n\t\tset = ip_set(inst, req_get->set.index);\n\t\tret = strscpy(req_get->set.name, set ? set->name : \"\",\n\t\t\t      IPSET_MAXNAMELEN);\n\t\tnfnl_unlock(NFNL_SUBSYS_IPSET);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tgoto copy;\n\t}\n\tdefault:\n\t\tret = -EBADMSG;\n\t\tgoto done;\n\t}\t \n\ncopy:\n\tif (copy_to_user(user, data, copylen))\n\t\tret = -EFAULT;\n\ndone:\n\tvfree(data);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic struct nf_sockopt_ops so_set __read_mostly = {\n\t.pf\t\t= PF_INET,\n\t.get_optmin\t= SO_IP_SET,\n\t.get_optmax\t= SO_IP_SET + 1,\n\t.get\t\t= ip_set_sockfn_get,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __net_init\nip_set_net_init(struct net *net)\n{\n\tstruct ip_set_net *inst = ip_set_pernet(net);\n\tstruct ip_set **list;\n\n\tinst->ip_set_max = max_sets ? max_sets : CONFIG_IP_SET_MAX;\n\tif (inst->ip_set_max >= IPSET_INVALID_ID)\n\t\tinst->ip_set_max = IPSET_INVALID_ID - 1;\n\n\tlist = kvcalloc(inst->ip_set_max, sizeof(struct ip_set *), GFP_KERNEL);\n\tif (!list)\n\t\treturn -ENOMEM;\n\tinst->is_deleted = false;\n\tinst->is_destroyed = false;\n\trcu_assign_pointer(inst->ip_set_list, list);\n\treturn 0;\n}\n\nstatic void __net_exit\nip_set_net_exit(struct net *net)\n{\n\tstruct ip_set_net *inst = ip_set_pernet(net);\n\n\tstruct ip_set *set = NULL;\n\tip_set_id_t i;\n\n\tinst->is_deleted = true;  \n\n\tnfnl_lock(NFNL_SUBSYS_IPSET);\n\tfor (i = 0; i < inst->ip_set_max; i++) {\n\t\tset = ip_set(inst, i);\n\t\tif (set) {\n\t\t\tip_set(inst, i) = NULL;\n\t\t\tip_set_destroy_set(set);\n\t\t}\n\t}\n\tnfnl_unlock(NFNL_SUBSYS_IPSET);\n\tkvfree(rcu_dereference_protected(inst->ip_set_list, 1));\n}\n\nstatic struct pernet_operations ip_set_net_ops = {\n\t.init\t= ip_set_net_init,\n\t.exit   = ip_set_net_exit,\n\t.id\t= &ip_set_net_id,\n\t.size\t= sizeof(struct ip_set_net),\n};\n\nstatic int __init\nip_set_init(void)\n{\n\tint ret = register_pernet_subsys(&ip_set_net_ops);\n\n\tif (ret) {\n\t\tpr_err(\"ip_set: cannot register pernet_subsys.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = nfnetlink_subsys_register(&ip_set_netlink_subsys);\n\tif (ret != 0) {\n\t\tpr_err(\"ip_set: cannot register with nfnetlink.\\n\");\n\t\tunregister_pernet_subsys(&ip_set_net_ops);\n\t\treturn ret;\n\t}\n\n\tret = nf_register_sockopt(&so_set);\n\tif (ret != 0) {\n\t\tpr_err(\"SO_SET registry failed: %d\\n\", ret);\n\t\tnfnetlink_subsys_unregister(&ip_set_netlink_subsys);\n\t\tunregister_pernet_subsys(&ip_set_net_ops);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit\nip_set_fini(void)\n{\n\tnf_unregister_sockopt(&so_set);\n\tnfnetlink_subsys_unregister(&ip_set_netlink_subsys);\n\n\tunregister_pernet_subsys(&ip_set_net_ops);\n\tpr_debug(\"these are the famous last words\\n\");\n}\n\nmodule_init(ip_set_init);\nmodule_exit(ip_set_fini);\n\nMODULE_DESCRIPTION(\"ip_set: protocol \" __stringify(IPSET_PROTOCOL));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}