{
  "module_name": "ip_set_hash_netportnet.c",
  "hash_id": "7438ea5569cbb0d5116c278d0901dc849bd855c8e24b1c4cb0c4dad404d6d381",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipset/ip_set_hash_netportnet.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/jhash.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/random.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/netlink.h>\n#include <net/tcp.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter/ipset/pfxlen.h>\n#include <linux/netfilter/ipset/ip_set.h>\n#include <linux/netfilter/ipset/ip_set_getport.h>\n#include <linux/netfilter/ipset/ip_set_hash.h>\n\n#define IPSET_TYPE_REV_MIN\t0\n \n \n \n#define IPSET_TYPE_REV_MAX\t3  \n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Oliver Smith <oliver@8.c.9.b.0.7.4.0.1.0.0.2.ip6.arpa>\");\nIP_SET_MODULE_DESC(\"hash:net,port,net\", IPSET_TYPE_REV_MIN, IPSET_TYPE_REV_MAX);\nMODULE_ALIAS(\"ip_set_hash:net,port,net\");\n\n \n#define HTYPE\t\thash_netportnet\n#define IP_SET_HASH_WITH_PROTO\n#define IP_SET_HASH_WITH_NETS\n#define IPSET_NET_COUNT 2\n#define IP_SET_HASH_WITH_NET0\n\n \n\n \nstruct hash_netportnet4_elem {\n\tunion {\n\t\t__be32 ip[2];\n\t\t__be64 ipcmp;\n\t};\n\t__be16 port;\n\tunion {\n\t\tu8 cidr[2];\n\t\tu16 ccmp;\n\t};\n\tu16 padding;\n\tu8 nomatch;\n\tu8 proto;\n};\n\n \n\nstatic bool\nhash_netportnet4_data_equal(const struct hash_netportnet4_elem *ip1,\n\t\t\t    const struct hash_netportnet4_elem *ip2,\n\t\t\t    u32 *multi)\n{\n\treturn ip1->ipcmp == ip2->ipcmp &&\n\t       ip1->ccmp == ip2->ccmp &&\n\t       ip1->port == ip2->port &&\n\t       ip1->proto == ip2->proto;\n}\n\nstatic int\nhash_netportnet4_do_data_match(const struct hash_netportnet4_elem *elem)\n{\n\treturn elem->nomatch ? -ENOTEMPTY : 1;\n}\n\nstatic void\nhash_netportnet4_data_set_flags(struct hash_netportnet4_elem *elem, u32 flags)\n{\n\telem->nomatch = !!((flags >> 16) & IPSET_FLAG_NOMATCH);\n}\n\nstatic void\nhash_netportnet4_data_reset_flags(struct hash_netportnet4_elem *elem, u8 *flags)\n{\n\tswap(*flags, elem->nomatch);\n}\n\nstatic void\nhash_netportnet4_data_reset_elem(struct hash_netportnet4_elem *elem,\n\t\t\t\t struct hash_netportnet4_elem *orig)\n{\n\telem->ip[1] = orig->ip[1];\n}\n\nstatic void\nhash_netportnet4_data_netmask(struct hash_netportnet4_elem *elem,\n\t\t\t      u8 cidr, bool inner)\n{\n\tif (inner) {\n\t\telem->ip[1] &= ip_set_netmask(cidr);\n\t\telem->cidr[1] = cidr;\n\t} else {\n\t\telem->ip[0] &= ip_set_netmask(cidr);\n\t\telem->cidr[0] = cidr;\n\t}\n}\n\nstatic bool\nhash_netportnet4_data_list(struct sk_buff *skb,\n\t\t\t   const struct hash_netportnet4_elem *data)\n{\n\tu32 flags = data->nomatch ? IPSET_FLAG_NOMATCH : 0;\n\n\tif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, data->ip[0]) ||\n\t    nla_put_ipaddr4(skb, IPSET_ATTR_IP2, data->ip[1]) ||\n\t    nla_put_net16(skb, IPSET_ATTR_PORT, data->port) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr[0]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR2, data->cidr[1]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_PROTO, data->proto) ||\n\t    (flags &&\n\t     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))))\n\t\tgoto nla_put_failure;\n\treturn false;\n\nnla_put_failure:\n\treturn true;\n}\n\nstatic void\nhash_netportnet4_data_next(struct hash_netportnet4_elem *next,\n\t\t\t   const struct hash_netportnet4_elem *d)\n{\n\tnext->ipcmp = d->ipcmp;\n\tnext->port = d->port;\n}\n\n#define MTYPE\t\thash_netportnet4\n#define HOST_MASK\t32\n#include \"ip_set_hash_gen.h\"\n\nstatic void\nhash_netportnet4_init(struct hash_netportnet4_elem *e)\n{\n\te->cidr[0] = HOST_MASK;\n\te->cidr[1] = HOST_MASK;\n}\n\nstatic int\nhash_netportnet4_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t\t      const struct xt_action_param *par,\n\t\t      enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tconst struct hash_netportnet4 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet4_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\n\te.cidr[0] = INIT_CIDR(h->nets[0].cidr[0], HOST_MASK);\n\te.cidr[1] = INIT_CIDR(h->nets[0].cidr[1], HOST_MASK);\n\tif (adt == IPSET_TEST)\n\t\te.ccmp = (HOST_MASK << (sizeof(e.cidr[0]) * 8)) | HOST_MASK;\n\n\tif (!ip_set_get_ip4_port(skb, opt->flags & IPSET_DIM_TWO_SRC,\n\t\t\t\t &e.port, &e.proto))\n\t\treturn -EINVAL;\n\n\tip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip[0]);\n\tip4addrptr(skb, opt->flags & IPSET_DIM_THREE_SRC, &e.ip[1]);\n\te.ip[0] &= ip_set_netmask(e.cidr[0]);\n\te.ip[1] &= ip_set_netmask(e.cidr[1]);\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic u32\nhash_netportnet4_range_to_cidr(u32 from, u32 to, u8 *cidr)\n{\n\tif (from == 0 && to == UINT_MAX) {\n\t\t*cidr = 0;\n\t\treturn to;\n\t}\n\treturn ip_set_range_to_cidr(from, to, cidr);\n}\n\nstatic int\nhash_netportnet4_uadt(struct ip_set *set, struct nlattr *tb[],\n\t\t      enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tstruct hash_netportnet4 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet4_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tu32 ip = 0, ip_to = 0, p = 0, port, port_to;\n\tu32 ip2_from = 0, ip2_to = 0, ip2, i = 0;\n\tbool with_ports = false;\n\tint ret;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\thash_netportnet4_init(&e);\n\tif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\n\t\t     !ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP2], &ip2_from);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[IPSET_ATTR_CIDR]) {\n\t\te.cidr[0] = nla_get_u8(tb[IPSET_ATTR_CIDR]);\n\t\tif (e.cidr[0] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\tif (tb[IPSET_ATTR_CIDR2]) {\n\t\te.cidr[1] = nla_get_u8(tb[IPSET_ATTR_CIDR2]);\n\t\tif (e.cidr[1] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\te.port = nla_get_be16(tb[IPSET_ATTR_PORT]);\n\n\tif (tb[IPSET_ATTR_PROTO]) {\n\t\te.proto = nla_get_u8(tb[IPSET_ATTR_PROTO]);\n\t\twith_ports = ip_set_proto_with_ports(e.proto);\n\n\t\tif (e.proto == 0)\n\t\t\treturn -IPSET_ERR_INVALID_PROTO;\n\t} else {\n\t\treturn -IPSET_ERR_MISSING_PROTO;\n\t}\n\n\tif (!(with_ports || e.proto == IPPROTO_ICMP))\n\t\te.port = 0;\n\n\tif (tb[IPSET_ATTR_CADT_FLAGS]) {\n\t\tu32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\n\n\t\tif (cadt_flags & IPSET_FLAG_NOMATCH)\n\t\t\tflags |= (IPSET_FLAG_NOMATCH << 16);\n\t}\n\n\twith_ports = with_ports && tb[IPSET_ATTR_PORT_TO];\n\tif (adt == IPSET_TEST ||\n\t    !(tb[IPSET_ATTR_IP_TO] || with_ports || tb[IPSET_ATTR_IP2_TO])) {\n\t\te.ip[0] = htonl(ip & ip_set_hostmask(e.cidr[0]));\n\t\te.ip[1] = htonl(ip2_from & ip_set_hostmask(e.cidr[1]));\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\t\treturn ip_set_enomatch(ret, flags, adt, set) ? -ret :\n\t\t       ip_set_eexist(ret, flags) ? 0 : ret;\n\t}\n\n\tip_to = ip;\n\tif (tb[IPSET_ATTR_IP_TO]) {\n\t\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (ip > ip_to)\n\t\t\tswap(ip, ip_to);\n\t\tif (unlikely(ip + UINT_MAX == ip_to))\n\t\t\treturn -IPSET_ERR_HASH_RANGE;\n\t} else {\n\t\tip_set_mask_from_to(ip, ip_to, e.cidr[0]);\n\t}\n\n\tport_to = port = ntohs(e.port);\n\tif (tb[IPSET_ATTR_PORT_TO]) {\n\t\tport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\n\t\tif (port > port_to)\n\t\t\tswap(port, port_to);\n\t}\n\n\tip2_to = ip2_from;\n\tif (tb[IPSET_ATTR_IP2_TO]) {\n\t\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP2_TO], &ip2_to);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (ip2_from > ip2_to)\n\t\t\tswap(ip2_from, ip2_to);\n\t\tif (unlikely(ip2_from + UINT_MAX == ip2_to))\n\t\t\treturn -IPSET_ERR_HASH_RANGE;\n\t} else {\n\t\tip_set_mask_from_to(ip2_from, ip2_to, e.cidr[1]);\n\t}\n\n\tif (retried) {\n\t\tip = ntohl(h->next.ip[0]);\n\t\tp = ntohs(h->next.port);\n\t\tip2 = ntohl(h->next.ip[1]);\n\t} else {\n\t\tp = port;\n\t\tip2 = ip2_from;\n\t}\n\n\tdo {\n\t\te.ip[0] = htonl(ip);\n\t\tip = hash_netportnet4_range_to_cidr(ip, ip_to, &e.cidr[0]);\n\t\tfor (; p <= port_to; p++) {\n\t\t\te.port = htons(p);\n\t\t\tdo {\n\t\t\t\ti++;\n\t\t\t\te.ip[1] = htonl(ip2);\n\t\t\t\tif (i > IPSET_MAX_RANGE) {\n\t\t\t\t\thash_netportnet4_data_next(&h->next,\n\t\t\t\t\t\t\t\t   &e);\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\t}\n\t\t\t\tip2 = hash_netportnet4_range_to_cidr(ip2,\n\t\t\t\t\t\t\tip2_to, &e.cidr[1]);\n\t\t\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\t\t\t\tif (ret && !ip_set_eexist(ret, flags))\n\t\t\t\t\treturn ret;\n\n\t\t\t\tret = 0;\n\t\t\t} while (ip2++ < ip2_to);\n\t\t\tip2 = ip2_from;\n\t\t}\n\t\tp = port;\n\t} while (ip++ < ip_to);\n\treturn ret;\n}\n\n \n\nstruct hash_netportnet6_elem {\n\tunion nf_inet_addr ip[2];\n\t__be16 port;\n\tunion {\n\t\tu8 cidr[2];\n\t\tu16 ccmp;\n\t};\n\tu16 padding;\n\tu8 nomatch;\n\tu8 proto;\n};\n\n \n\nstatic bool\nhash_netportnet6_data_equal(const struct hash_netportnet6_elem *ip1,\n\t\t\t    const struct hash_netportnet6_elem *ip2,\n\t\t\t    u32 *multi)\n{\n\treturn ipv6_addr_equal(&ip1->ip[0].in6, &ip2->ip[0].in6) &&\n\t       ipv6_addr_equal(&ip1->ip[1].in6, &ip2->ip[1].in6) &&\n\t       ip1->ccmp == ip2->ccmp &&\n\t       ip1->port == ip2->port &&\n\t       ip1->proto == ip2->proto;\n}\n\nstatic int\nhash_netportnet6_do_data_match(const struct hash_netportnet6_elem *elem)\n{\n\treturn elem->nomatch ? -ENOTEMPTY : 1;\n}\n\nstatic void\nhash_netportnet6_data_set_flags(struct hash_netportnet6_elem *elem, u32 flags)\n{\n\telem->nomatch = !!((flags >> 16) & IPSET_FLAG_NOMATCH);\n}\n\nstatic void\nhash_netportnet6_data_reset_flags(struct hash_netportnet6_elem *elem, u8 *flags)\n{\n\tswap(*flags, elem->nomatch);\n}\n\nstatic void\nhash_netportnet6_data_reset_elem(struct hash_netportnet6_elem *elem,\n\t\t\t\t struct hash_netportnet6_elem *orig)\n{\n\telem->ip[1] = orig->ip[1];\n}\n\nstatic void\nhash_netportnet6_data_netmask(struct hash_netportnet6_elem *elem,\n\t\t\t      u8 cidr, bool inner)\n{\n\tif (inner) {\n\t\tip6_netmask(&elem->ip[1], cidr);\n\t\telem->cidr[1] = cidr;\n\t} else {\n\t\tip6_netmask(&elem->ip[0], cidr);\n\t\telem->cidr[0] = cidr;\n\t}\n}\n\nstatic bool\nhash_netportnet6_data_list(struct sk_buff *skb,\n\t\t\t   const struct hash_netportnet6_elem *data)\n{\n\tu32 flags = data->nomatch ? IPSET_FLAG_NOMATCH : 0;\n\n\tif (nla_put_ipaddr6(skb, IPSET_ATTR_IP, &data->ip[0].in6) ||\n\t    nla_put_ipaddr6(skb, IPSET_ATTR_IP2, &data->ip[1].in6) ||\n\t    nla_put_net16(skb, IPSET_ATTR_PORT, data->port) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr[0]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR2, data->cidr[1]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_PROTO, data->proto) ||\n\t    (flags &&\n\t     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))))\n\t\tgoto nla_put_failure;\n\treturn false;\n\nnla_put_failure:\n\treturn true;\n}\n\nstatic void\nhash_netportnet6_data_next(struct hash_netportnet6_elem *next,\n\t\t\t   const struct hash_netportnet6_elem *d)\n{\n\tnext->port = d->port;\n}\n\n#undef MTYPE\n#undef HOST_MASK\n\n#define MTYPE\t\thash_netportnet6\n#define HOST_MASK\t128\n#define IP_SET_EMIT_CREATE\n#include \"ip_set_hash_gen.h\"\n\nstatic void\nhash_netportnet6_init(struct hash_netportnet6_elem *e)\n{\n\te->cidr[0] = HOST_MASK;\n\te->cidr[1] = HOST_MASK;\n}\n\nstatic int\nhash_netportnet6_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t\t      const struct xt_action_param *par,\n\t\t      enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tconst struct hash_netportnet6 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet6_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\n\te.cidr[0] = INIT_CIDR(h->nets[0].cidr[0], HOST_MASK);\n\te.cidr[1] = INIT_CIDR(h->nets[0].cidr[1], HOST_MASK);\n\tif (adt == IPSET_TEST)\n\t\te.ccmp = (HOST_MASK << (sizeof(u8) * 8)) | HOST_MASK;\n\n\tif (!ip_set_get_ip6_port(skb, opt->flags & IPSET_DIM_TWO_SRC,\n\t\t\t\t &e.port, &e.proto))\n\t\treturn -EINVAL;\n\n\tip6addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip[0].in6);\n\tip6addrptr(skb, opt->flags & IPSET_DIM_THREE_SRC, &e.ip[1].in6);\n\tip6_netmask(&e.ip[0], e.cidr[0]);\n\tip6_netmask(&e.ip[1], e.cidr[1]);\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic int\nhash_netportnet6_uadt(struct ip_set *set, struct nlattr *tb[],\n\t\t      enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tconst struct hash_netportnet6 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet6_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tu32 port, port_to;\n\tbool with_ports = false;\n\tint ret;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\thash_netportnet6_init(&e);\n\tif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\n\t\t     !ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\tif (unlikely(tb[IPSET_ATTR_IP_TO] || tb[IPSET_ATTR_IP2_TO]))\n\t\treturn -IPSET_ERR_HASH_RANGE_UNSUPPORTED;\n\n\tret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP], &e.ip[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP2], &e.ip[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[IPSET_ATTR_CIDR]) {\n\t\te.cidr[0] = nla_get_u8(tb[IPSET_ATTR_CIDR]);\n\t\tif (e.cidr[0] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\tif (tb[IPSET_ATTR_CIDR2]) {\n\t\te.cidr[1] = nla_get_u8(tb[IPSET_ATTR_CIDR2]);\n\t\tif (e.cidr[1] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\tip6_netmask(&e.ip[0], e.cidr[0]);\n\tip6_netmask(&e.ip[1], e.cidr[1]);\n\n\te.port = nla_get_be16(tb[IPSET_ATTR_PORT]);\n\n\tif (tb[IPSET_ATTR_PROTO]) {\n\t\te.proto = nla_get_u8(tb[IPSET_ATTR_PROTO]);\n\t\twith_ports = ip_set_proto_with_ports(e.proto);\n\n\t\tif (e.proto == 0)\n\t\t\treturn -IPSET_ERR_INVALID_PROTO;\n\t} else {\n\t\treturn -IPSET_ERR_MISSING_PROTO;\n\t}\n\n\tif (!(with_ports || e.proto == IPPROTO_ICMPV6))\n\t\te.port = 0;\n\n\tif (tb[IPSET_ATTR_CADT_FLAGS]) {\n\t\tu32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\n\n\t\tif (cadt_flags & IPSET_FLAG_NOMATCH)\n\t\t\tflags |= (IPSET_FLAG_NOMATCH << 16);\n\t}\n\n\tif (adt == IPSET_TEST || !with_ports || !tb[IPSET_ATTR_PORT_TO]) {\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\t\treturn ip_set_enomatch(ret, flags, adt, set) ? -ret :\n\t\t       ip_set_eexist(ret, flags) ? 0 : ret;\n\t}\n\n\tport = ntohs(e.port);\n\tport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\n\tif (port > port_to)\n\t\tswap(port, port_to);\n\n\tif (retried)\n\t\tport = ntohs(h->next.port);\n\tfor (; port <= port_to; port++) {\n\t\te.port = htons(port);\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\n\t\tif (ret && !ip_set_eexist(ret, flags))\n\t\t\treturn ret;\n\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic struct ip_set_type hash_netportnet_type __read_mostly = {\n\t.name\t\t= \"hash:net,port,net\",\n\t.protocol\t= IPSET_PROTOCOL,\n\t.features\t= IPSET_TYPE_IP | IPSET_TYPE_PORT | IPSET_TYPE_IP2 |\n\t\t\t  IPSET_TYPE_NOMATCH,\n\t.dimension\t= IPSET_DIM_THREE,\n\t.family\t\t= NFPROTO_UNSPEC,\n\t.revision_min\t= IPSET_TYPE_REV_MIN,\n\t.revision_max\t= IPSET_TYPE_REV_MAX,\n\t.create_flags[IPSET_TYPE_REV_MAX] = IPSET_CREATE_FLAG_BUCKETSIZE,\n\t.create\t\t= hash_netportnet_create,\n\t.create_policy\t= {\n\t\t[IPSET_ATTR_HASHSIZE]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_MAXELEM]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_INITVAL]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BUCKETSIZE]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_RESIZE]\t= { .type = NLA_U8  },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t},\n\t.adt_policy\t= {\n\t\t[IPSET_ATTR_IP]\t\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP_TO]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP2]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP2_TO]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_PORT]\t= { .type = NLA_U16 },\n\t\t[IPSET_ATTR_PORT_TO]\t= { .type = NLA_U16 },\n\t\t[IPSET_ATTR_CIDR]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_CIDR2]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_PROTO]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_LINENO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BYTES]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_PACKETS]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_COMMENT]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len  = IPSET_MAX_COMMENT_SIZE },\n\t\t[IPSET_ATTR_SKBMARK]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_SKBPRIO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_SKBQUEUE]\t= { .type = NLA_U16 },\n\t},\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init\nhash_netportnet_init(void)\n{\n\treturn ip_set_type_register(&hash_netportnet_type);\n}\n\nstatic void __exit\nhash_netportnet_fini(void)\n{\n\trcu_barrier();\n\tip_set_type_unregister(&hash_netportnet_type);\n}\n\nmodule_init(hash_netportnet_init);\nmodule_exit(hash_netportnet_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}