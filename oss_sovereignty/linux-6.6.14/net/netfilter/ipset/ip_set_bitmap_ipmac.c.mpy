{
  "module_name": "ip_set_bitmap_ipmac.c",
  "hash_id": "0a5cf5036ec41189d7592e6a30674fea769afd58ae46c3c815340a39d3c7cabe",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipset/ip_set_bitmap_ipmac.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/if_ether.h>\n#include <linux/netlink.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <net/netlink.h>\n\n#include <linux/netfilter/ipset/pfxlen.h>\n#include <linux/netfilter/ipset/ip_set.h>\n#include <linux/netfilter/ipset/ip_set_bitmap.h>\n\n#define IPSET_TYPE_REV_MIN\t0\n \n \n#define IPSET_TYPE_REV_MAX\t3\t \n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jozsef Kadlecsik <kadlec@netfilter.org>\");\nIP_SET_MODULE_DESC(\"bitmap:ip,mac\", IPSET_TYPE_REV_MIN, IPSET_TYPE_REV_MAX);\nMODULE_ALIAS(\"ip_set_bitmap:ip,mac\");\n\n#define MTYPE\t\tbitmap_ipmac\n#define HOST_MASK\t32\n#define IP_SET_BITMAP_STORED_TIMEOUT\n\nenum {\n\tMAC_UNSET,\t\t \n\tMAC_FILLED,\t\t \n};\n\n \nstruct bitmap_ipmac {\n\tunsigned long *members;\t \n\tu32 first_ip;\t\t \n\tu32 last_ip;\t\t \n\tu32 elements;\t\t \n\tsize_t memsize;\t\t \n\tstruct timer_list gc;\t \n\tstruct ip_set *set;\t \n\tunsigned char extensions[]\t \n\t\t__aligned(__alignof__(u64));\n};\n\n \nstruct bitmap_ipmac_adt_elem {\n\tunsigned char ether[ETH_ALEN] __aligned(2);\n\tu16 id;\n\tu16 add_mac;\n};\n\nstruct bitmap_ipmac_elem {\n\tunsigned char ether[ETH_ALEN];\n\tunsigned char filled;\n} __aligned(__alignof__(u64));\n\nstatic u32\nip_to_id(const struct bitmap_ipmac *m, u32 ip)\n{\n\treturn ip - m->first_ip;\n}\n\n#define get_elem(extensions, id, dsize)\t\t\\\n\t(struct bitmap_ipmac_elem *)(extensions + (id) * (dsize))\n\n#define get_const_elem(extensions, id, dsize)\t\\\n\t(const struct bitmap_ipmac_elem *)(extensions + (id) * (dsize))\n\n \n\nstatic int\nbitmap_ipmac_do_test(const struct bitmap_ipmac_adt_elem *e,\n\t\t     const struct bitmap_ipmac *map, size_t dsize)\n{\n\tconst struct bitmap_ipmac_elem *elem;\n\n\tif (!test_bit(e->id, map->members))\n\t\treturn 0;\n\telem = get_const_elem(map->extensions, e->id, dsize);\n\tif (e->add_mac && elem->filled == MAC_FILLED)\n\t\treturn ether_addr_equal(e->ether, elem->ether);\n\t \n\treturn -EAGAIN;\n}\n\nstatic int\nbitmap_ipmac_gc_test(u16 id, const struct bitmap_ipmac *map, size_t dsize)\n{\n\tconst struct bitmap_ipmac_elem *elem;\n\n\tif (!test_bit(id, map->members))\n\t\treturn 0;\n\telem = get_const_elem(map->extensions, id, dsize);\n\t \n\treturn elem->filled == MAC_FILLED;\n}\n\nstatic int\nbitmap_ipmac_is_filled(const struct bitmap_ipmac_elem *elem)\n{\n\treturn elem->filled == MAC_FILLED;\n}\n\nstatic int\nbitmap_ipmac_add_timeout(unsigned long *timeout,\n\t\t\t const struct bitmap_ipmac_adt_elem *e,\n\t\t\t const struct ip_set_ext *ext, struct ip_set *set,\n\t\t\t struct bitmap_ipmac *map, int mode)\n{\n\tu32 t = ext->timeout;\n\n\tif (mode == IPSET_ADD_START_STORED_TIMEOUT) {\n\t\tif (t == set->timeout)\n\t\t\t \n\t\t\tt = *timeout;\n\t\tip_set_timeout_set(timeout, t);\n\t} else {\n\t\t \n\t\tif (e->add_mac)\n\t\t\tip_set_timeout_set(timeout, t);\n\t\telse\n\t\t\t*timeout = t;\n\t}\n\treturn 0;\n}\n\nstatic int\nbitmap_ipmac_do_add(const struct bitmap_ipmac_adt_elem *e,\n\t\t    struct bitmap_ipmac *map, u32 flags, size_t dsize)\n{\n\tstruct bitmap_ipmac_elem *elem;\n\n\telem = get_elem(map->extensions, e->id, dsize);\n\tif (test_bit(e->id, map->members)) {\n\t\tif (elem->filled == MAC_FILLED) {\n\t\t\tif (e->add_mac &&\n\t\t\t    (flags & IPSET_FLAG_EXIST) &&\n\t\t\t    !ether_addr_equal(e->ether, elem->ether)) {\n\t\t\t\t \n\t\t\t\tclear_bit(e->id, map->members);\n\t\t\t\tsmp_mb__after_atomic();\n\t\t\t\tether_addr_copy(elem->ether, e->ether);\n\t\t\t}\n\t\t\treturn IPSET_ADD_FAILED;\n\t\t} else if (!e->add_mac)\n\t\t\t \n\t\t\treturn IPSET_ADD_FAILED;\n\t\t \n\t\tclear_bit(e->id, map->members);\n\t\tsmp_mb__after_atomic();\n\t\tether_addr_copy(elem->ether, e->ether);\n\t\telem->filled = MAC_FILLED;\n\t\treturn IPSET_ADD_START_STORED_TIMEOUT;\n\t} else if (e->add_mac) {\n\t\t \n\t\tether_addr_copy(elem->ether, e->ether);\n\t\telem->filled = MAC_FILLED;\n\t\treturn 0;\n\t}\n\telem->filled = MAC_UNSET;\n\t \n\treturn IPSET_ADD_STORE_PLAIN_TIMEOUT;\n}\n\nstatic int\nbitmap_ipmac_do_del(const struct bitmap_ipmac_adt_elem *e,\n\t\t    struct bitmap_ipmac *map)\n{\n\treturn !test_and_clear_bit(e->id, map->members);\n}\n\nstatic int\nbitmap_ipmac_do_list(struct sk_buff *skb, const struct bitmap_ipmac *map,\n\t\t     u32 id, size_t dsize)\n{\n\tconst struct bitmap_ipmac_elem *elem =\n\t\tget_const_elem(map->extensions, id, dsize);\n\n\treturn nla_put_ipaddr4(skb, IPSET_ATTR_IP,\n\t\t\t       htonl(map->first_ip + id)) ||\n\t       (elem->filled == MAC_FILLED &&\n\t\tnla_put(skb, IPSET_ATTR_ETHER, ETH_ALEN, elem->ether));\n}\n\nstatic int\nbitmap_ipmac_do_head(struct sk_buff *skb, const struct bitmap_ipmac *map)\n{\n\treturn nla_put_ipaddr4(skb, IPSET_ATTR_IP, htonl(map->first_ip)) ||\n\t       nla_put_ipaddr4(skb, IPSET_ATTR_IP_TO, htonl(map->last_ip));\n}\n\nstatic int\nbitmap_ipmac_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t\t  const struct xt_action_param *par,\n\t\t  enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tstruct bitmap_ipmac *map = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct bitmap_ipmac_adt_elem e = { .id = 0, .add_mac = 1 };\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\tu32 ip;\n\n\tip = ntohl(ip4addr(skb, opt->flags & IPSET_DIM_ONE_SRC));\n\tif (ip < map->first_ip || ip > map->last_ip)\n\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\n\t \n\tif (skb_mac_header(skb) < skb->head ||\n\t    (skb_mac_header(skb) + ETH_HLEN) > skb->data)\n\t\treturn -EINVAL;\n\n\te.id = ip_to_id(map, ip);\n\n\tif (opt->flags & IPSET_DIM_TWO_SRC)\n\t\tether_addr_copy(e.ether, eth_hdr(skb)->h_source);\n\telse\n\t\tether_addr_copy(e.ether, eth_hdr(skb)->h_dest);\n\n\tif (is_zero_ether_addr(e.ether))\n\t\treturn -EINVAL;\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic int\nbitmap_ipmac_uadt(struct ip_set *set, struct nlattr *tb[],\n\t\t  enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tconst struct bitmap_ipmac *map = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct bitmap_ipmac_adt_elem e = { .id = 0 };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tu32 ip = 0;\n\tint ret = 0;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\tif (unlikely(!tb[IPSET_ATTR_IP]))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ip < map->first_ip || ip > map->last_ip)\n\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\n\te.id = ip_to_id(map, ip);\n\tif (tb[IPSET_ATTR_ETHER]) {\n\t\tif (nla_len(tb[IPSET_ATTR_ETHER]) != ETH_ALEN)\n\t\t\treturn -IPSET_ERR_PROTOCOL;\n\t\tmemcpy(e.ether, nla_data(tb[IPSET_ATTR_ETHER]), ETH_ALEN);\n\t\te.add_mac = 1;\n\t}\n\tret = adtfn(set, &e, &ext, &ext, flags);\n\n\treturn ip_set_eexist(ret, flags) ? 0 : ret;\n}\n\nstatic bool\nbitmap_ipmac_same_set(const struct ip_set *a, const struct ip_set *b)\n{\n\tconst struct bitmap_ipmac *x = a->data;\n\tconst struct bitmap_ipmac *y = b->data;\n\n\treturn x->first_ip == y->first_ip &&\n\t       x->last_ip == y->last_ip &&\n\t       a->timeout == b->timeout &&\n\t       a->extensions == b->extensions;\n}\n\n \n\n#include \"ip_set_bitmap_gen.h\"\n\n \n\nstatic bool\ninit_map_ipmac(struct ip_set *set, struct bitmap_ipmac *map,\n\t       u32 first_ip, u32 last_ip, u32 elements)\n{\n\tmap->members = bitmap_zalloc(elements, GFP_KERNEL | __GFP_NOWARN);\n\tif (!map->members)\n\t\treturn false;\n\tmap->first_ip = first_ip;\n\tmap->last_ip = last_ip;\n\tmap->elements = elements;\n\tset->timeout = IPSET_NO_TIMEOUT;\n\n\tmap->set = set;\n\tset->data = map;\n\tset->family = NFPROTO_IPV4;\n\n\treturn true;\n}\n\nstatic int\nbitmap_ipmac_create(struct net *net, struct ip_set *set, struct nlattr *tb[],\n\t\t    u32 flags)\n{\n\tu32 first_ip = 0, last_ip = 0;\n\tu64 elements;\n\tstruct bitmap_ipmac *map;\n\tint ret;\n\n\tif (unlikely(!tb[IPSET_ATTR_IP] ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &first_ip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[IPSET_ATTR_IP_TO]) {\n\t\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &last_ip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (first_ip > last_ip)\n\t\t\tswap(first_ip, last_ip);\n\t} else if (tb[IPSET_ATTR_CIDR]) {\n\t\tu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\n\n\t\tif (cidr >= HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t\tip_set_mask_from_to(first_ip, last_ip, cidr);\n\t} else {\n\t\treturn -IPSET_ERR_PROTOCOL;\n\t}\n\n\telements = (u64)last_ip - first_ip + 1;\n\n\tif (elements > IPSET_BITMAP_MAX_RANGE + 1)\n\t\treturn -IPSET_ERR_BITMAP_RANGE_SIZE;\n\n\tset->dsize = ip_set_elem_len(set, tb,\n\t\t\t\t     sizeof(struct bitmap_ipmac_elem),\n\t\t\t\t     __alignof__(struct bitmap_ipmac_elem));\n\tmap = ip_set_alloc(sizeof(*map) + elements * set->dsize);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->memsize = BITS_TO_LONGS(elements) * sizeof(unsigned long);\n\tset->variant = &bitmap_ipmac;\n\tif (!init_map_ipmac(set, map, first_ip, last_ip, elements)) {\n\t\tip_set_free(map);\n\t\treturn -ENOMEM;\n\t}\n\tif (tb[IPSET_ATTR_TIMEOUT]) {\n\t\tset->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\n\t\tbitmap_ipmac_gc_init(set, bitmap_ipmac_gc);\n\t}\n\treturn 0;\n}\n\nstatic struct ip_set_type bitmap_ipmac_type = {\n\t.name\t\t= \"bitmap:ip,mac\",\n\t.protocol\t= IPSET_PROTOCOL,\n\t.features\t= IPSET_TYPE_IP | IPSET_TYPE_MAC,\n\t.dimension\t= IPSET_DIM_TWO,\n\t.family\t\t= NFPROTO_IPV4,\n\t.revision_min\t= IPSET_TYPE_REV_MIN,\n\t.revision_max\t= IPSET_TYPE_REV_MAX,\n\t.create\t\t= bitmap_ipmac_create,\n\t.create_policy\t= {\n\t\t[IPSET_ATTR_IP]\t\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP_TO]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_CIDR]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t},\n\t.adt_policy\t= {\n\t\t[IPSET_ATTR_IP]\t\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_ETHER]\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len  = ETH_ALEN },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_LINENO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BYTES]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_PACKETS]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_COMMENT]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len  = IPSET_MAX_COMMENT_SIZE },\n\t\t[IPSET_ATTR_SKBMARK]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_SKBPRIO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_SKBQUEUE]\t= { .type = NLA_U16 },\n\t},\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init\nbitmap_ipmac_init(void)\n{\n\treturn ip_set_type_register(&bitmap_ipmac_type);\n}\n\nstatic void __exit\nbitmap_ipmac_fini(void)\n{\n\trcu_barrier();\n\tip_set_type_unregister(&bitmap_ipmac_type);\n}\n\nmodule_init(bitmap_ipmac_init);\nmodule_exit(bitmap_ipmac_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}