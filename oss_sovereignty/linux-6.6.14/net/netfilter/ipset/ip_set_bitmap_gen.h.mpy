{
  "module_name": "ip_set_bitmap_gen.h",
  "hash_id": "28bff92b1c8cece97790f99a264450afc5cd6a3e852ca11a5cc3afb22aab41f5",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipset/ip_set_bitmap_gen.h",
  "human_readable_source": " \n \n\n#ifndef __IP_SET_BITMAP_IP_GEN_H\n#define __IP_SET_BITMAP_IP_GEN_H\n\n#define mtype_do_test\t\tIPSET_TOKEN(MTYPE, _do_test)\n#define mtype_gc_test\t\tIPSET_TOKEN(MTYPE, _gc_test)\n#define mtype_is_filled\t\tIPSET_TOKEN(MTYPE, _is_filled)\n#define mtype_do_add\t\tIPSET_TOKEN(MTYPE, _do_add)\n#define mtype_ext_cleanup\tIPSET_TOKEN(MTYPE, _ext_cleanup)\n#define mtype_do_del\t\tIPSET_TOKEN(MTYPE, _do_del)\n#define mtype_do_list\t\tIPSET_TOKEN(MTYPE, _do_list)\n#define mtype_do_head\t\tIPSET_TOKEN(MTYPE, _do_head)\n#define mtype_adt_elem\t\tIPSET_TOKEN(MTYPE, _adt_elem)\n#define mtype_add_timeout\tIPSET_TOKEN(MTYPE, _add_timeout)\n#define mtype_gc_init\t\tIPSET_TOKEN(MTYPE, _gc_init)\n#define mtype_kadt\t\tIPSET_TOKEN(MTYPE, _kadt)\n#define mtype_uadt\t\tIPSET_TOKEN(MTYPE, _uadt)\n#define mtype_destroy\t\tIPSET_TOKEN(MTYPE, _destroy)\n#define mtype_memsize\t\tIPSET_TOKEN(MTYPE, _memsize)\n#define mtype_flush\t\tIPSET_TOKEN(MTYPE, _flush)\n#define mtype_head\t\tIPSET_TOKEN(MTYPE, _head)\n#define mtype_same_set\t\tIPSET_TOKEN(MTYPE, _same_set)\n#define mtype_elem\t\tIPSET_TOKEN(MTYPE, _elem)\n#define mtype_test\t\tIPSET_TOKEN(MTYPE, _test)\n#define mtype_add\t\tIPSET_TOKEN(MTYPE, _add)\n#define mtype_del\t\tIPSET_TOKEN(MTYPE, _del)\n#define mtype_list\t\tIPSET_TOKEN(MTYPE, _list)\n#define mtype_gc\t\tIPSET_TOKEN(MTYPE, _gc)\n#define mtype\t\t\tMTYPE\n\n#define get_ext(set, map, id)\t((map)->extensions + ((set)->dsize * (id)))\n\nstatic void\nmtype_gc_init(struct ip_set *set, void (*gc)(struct timer_list *t))\n{\n\tstruct mtype *map = set->data;\n\n\ttimer_setup(&map->gc, gc, 0);\n\tmod_timer(&map->gc, jiffies + IPSET_GC_PERIOD(set->timeout) * HZ);\n}\n\nstatic void\nmtype_ext_cleanup(struct ip_set *set)\n{\n\tstruct mtype *map = set->data;\n\tu32 id;\n\n\tfor (id = 0; id < map->elements; id++)\n\t\tif (test_bit(id, map->members))\n\t\t\tip_set_ext_destroy(set, get_ext(set, map, id));\n}\n\nstatic void\nmtype_destroy(struct ip_set *set)\n{\n\tstruct mtype *map = set->data;\n\n\tif (SET_WITH_TIMEOUT(set))\n\t\tdel_timer_sync(&map->gc);\n\n\tif (set->dsize && set->extensions & IPSET_EXT_DESTROY)\n\t\tmtype_ext_cleanup(set);\n\tip_set_free(map->members);\n\tip_set_free(map);\n\n\tset->data = NULL;\n}\n\nstatic void\nmtype_flush(struct ip_set *set)\n{\n\tstruct mtype *map = set->data;\n\n\tif (set->extensions & IPSET_EXT_DESTROY)\n\t\tmtype_ext_cleanup(set);\n\tbitmap_zero(map->members, map->elements);\n\tset->elements = 0;\n\tset->ext_size = 0;\n}\n\n \nstatic size_t\nmtype_memsize(const struct mtype *map, size_t dsize)\n{\n\treturn sizeof(*map) + map->memsize +\n\t       map->elements * dsize;\n}\n\nstatic int\nmtype_head(struct ip_set *set, struct sk_buff *skb)\n{\n\tconst struct mtype *map = set->data;\n\tstruct nlattr *nested;\n\tsize_t memsize = mtype_memsize(map, set->dsize) + set->ext_size;\n\n\tnested = nla_nest_start(skb, IPSET_ATTR_DATA);\n\tif (!nested)\n\t\tgoto nla_put_failure;\n\tif (mtype_do_head(skb, map) ||\n\t    nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref)) ||\n\t    nla_put_net32(skb, IPSET_ATTR_MEMSIZE, htonl(memsize)) ||\n\t    nla_put_net32(skb, IPSET_ATTR_ELEMENTS, htonl(set->elements)))\n\t\tgoto nla_put_failure;\n\tif (unlikely(ip_set_put_flags(skb, set)))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nested);\n\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int\nmtype_test(struct ip_set *set, void *value, const struct ip_set_ext *ext,\n\t   struct ip_set_ext *mext, u32 flags)\n{\n\tstruct mtype *map = set->data;\n\tconst struct mtype_adt_elem *e = value;\n\tvoid *x = get_ext(set, map, e->id);\n\tint ret = mtype_do_test(e, map, set->dsize);\n\n\tif (ret <= 0)\n\t\treturn ret;\n\treturn ip_set_match_extensions(set, ext, mext, flags, x);\n}\n\nstatic int\nmtype_add(struct ip_set *set, void *value, const struct ip_set_ext *ext,\n\t  struct ip_set_ext *mext, u32 flags)\n{\n\tstruct mtype *map = set->data;\n\tconst struct mtype_adt_elem *e = value;\n\tvoid *x = get_ext(set, map, e->id);\n\tint ret = mtype_do_add(e, map, flags, set->dsize);\n\n\tif (ret == IPSET_ADD_FAILED) {\n\t\tif (SET_WITH_TIMEOUT(set) &&\n\t\t    ip_set_timeout_expired(ext_timeout(x, set))) {\n\t\t\tset->elements--;\n\t\t\tret = 0;\n\t\t} else if (!(flags & IPSET_FLAG_EXIST)) {\n\t\t\tset_bit(e->id, map->members);\n\t\t\treturn -IPSET_ERR_EXIST;\n\t\t}\n\t\t \n\t\tip_set_ext_destroy(set, x);\n\t}\n\tif (ret > 0)\n\t\tset->elements--;\n\n\tif (SET_WITH_TIMEOUT(set))\n#ifdef IP_SET_BITMAP_STORED_TIMEOUT\n\t\tmtype_add_timeout(ext_timeout(x, set), e, ext, set, map, ret);\n#else\n\t\tip_set_timeout_set(ext_timeout(x, set), ext->timeout);\n#endif\n\n\tif (SET_WITH_COUNTER(set))\n\t\tip_set_init_counter(ext_counter(x, set), ext);\n\tif (SET_WITH_COMMENT(set))\n\t\tip_set_init_comment(set, ext_comment(x, set), ext);\n\tif (SET_WITH_SKBINFO(set))\n\t\tip_set_init_skbinfo(ext_skbinfo(x, set), ext);\n\n\t \n\tset_bit(e->id, map->members);\n\tset->elements++;\n\n\treturn 0;\n}\n\nstatic int\nmtype_del(struct ip_set *set, void *value, const struct ip_set_ext *ext,\n\t  struct ip_set_ext *mext, u32 flags)\n{\n\tstruct mtype *map = set->data;\n\tconst struct mtype_adt_elem *e = value;\n\tvoid *x = get_ext(set, map, e->id);\n\n\tif (mtype_do_del(e, map))\n\t\treturn -IPSET_ERR_EXIST;\n\n\tip_set_ext_destroy(set, x);\n\tset->elements--;\n\tif (SET_WITH_TIMEOUT(set) &&\n\t    ip_set_timeout_expired(ext_timeout(x, set)))\n\t\treturn -IPSET_ERR_EXIST;\n\n\treturn 0;\n}\n\n#ifndef IP_SET_BITMAP_STORED_TIMEOUT\nstatic bool\nmtype_is_filled(const struct mtype_elem *x)\n{\n\treturn true;\n}\n#endif\n\nstatic int\nmtype_list(const struct ip_set *set,\n\t   struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct mtype *map = set->data;\n\tstruct nlattr *adt, *nested;\n\tvoid *x;\n\tu32 id, first = cb->args[IPSET_CB_ARG0];\n\tint ret = 0;\n\n\tadt = nla_nest_start(skb, IPSET_ATTR_ADT);\n\tif (!adt)\n\t\treturn -EMSGSIZE;\n\t \n\trcu_read_lock();\n\tfor (; cb->args[IPSET_CB_ARG0] < map->elements;\n\t     cb->args[IPSET_CB_ARG0]++) {\n\t\tcond_resched_rcu();\n\t\tid = cb->args[IPSET_CB_ARG0];\n\t\tx = get_ext(set, map, id);\n\t\tif (!test_bit(id, map->members) ||\n\t\t    (SET_WITH_TIMEOUT(set) &&\n#ifdef IP_SET_BITMAP_STORED_TIMEOUT\n\t\t     mtype_is_filled(x) &&\n#endif\n\t\t     ip_set_timeout_expired(ext_timeout(x, set))))\n\t\t\tcontinue;\n\t\tnested = nla_nest_start(skb, IPSET_ATTR_DATA);\n\t\tif (!nested) {\n\t\t\tif (id == first) {\n\t\t\t\tnla_nest_cancel(skb, adt);\n\t\t\t\tret = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tif (mtype_do_list(skb, map, id, set->dsize))\n\t\t\tgoto nla_put_failure;\n\t\tif (ip_set_put_extensions(skb, set, x, mtype_is_filled(x)))\n\t\t\tgoto nla_put_failure;\n\t\tnla_nest_end(skb, nested);\n\t}\n\tnla_nest_end(skb, adt);\n\n\t \n\tcb->args[IPSET_CB_ARG0] = 0;\n\n\tgoto out;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nested);\n\tif (unlikely(id == first)) {\n\t\tcb->args[IPSET_CB_ARG0] = 0;\n\t\tret = -EMSGSIZE;\n\t}\n\tnla_nest_end(skb, adt);\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic void\nmtype_gc(struct timer_list *t)\n{\n\tstruct mtype *map = from_timer(map, t, gc);\n\tstruct ip_set *set = map->set;\n\tvoid *x;\n\tu32 id;\n\n\t \n\tspin_lock_bh(&set->lock);\n\tfor (id = 0; id < map->elements; id++)\n\t\tif (mtype_gc_test(id, map, set->dsize)) {\n\t\t\tx = get_ext(set, map, id);\n\t\t\tif (ip_set_timeout_expired(ext_timeout(x, set))) {\n\t\t\t\tclear_bit(id, map->members);\n\t\t\t\tip_set_ext_destroy(set, x);\n\t\t\t\tset->elements--;\n\t\t\t}\n\t\t}\n\tspin_unlock_bh(&set->lock);\n\n\tmap->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;\n\tadd_timer(&map->gc);\n}\n\nstatic const struct ip_set_type_variant mtype = {\n\t.kadt\t= mtype_kadt,\n\t.uadt\t= mtype_uadt,\n\t.adt\t= {\n\t\t[IPSET_ADD] = mtype_add,\n\t\t[IPSET_DEL] = mtype_del,\n\t\t[IPSET_TEST] = mtype_test,\n\t},\n\t.destroy = mtype_destroy,\n\t.flush\t= mtype_flush,\n\t.head\t= mtype_head,\n\t.list\t= mtype_list,\n\t.same_set = mtype_same_set,\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}