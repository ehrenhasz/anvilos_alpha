{
  "module_name": "ip_set_list_set.c",
  "hash_id": "b18d88e6fea7880327f8300f14804c4b4c2b9e4f38c3e198c4af712a3eeec738",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipset/ip_set_list_set.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n\n#include <linux/netfilter/ipset/ip_set.h>\n#include <linux/netfilter/ipset/ip_set_list.h>\n\n#define IPSET_TYPE_REV_MIN\t0\n \n \n#define IPSET_TYPE_REV_MAX\t3  \n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jozsef Kadlecsik <kadlec@netfilter.org>\");\nIP_SET_MODULE_DESC(\"list:set\", IPSET_TYPE_REV_MIN, IPSET_TYPE_REV_MAX);\nMODULE_ALIAS(\"ip_set_list:set\");\n\n \nstruct set_elem {\n\tstruct rcu_head rcu;\n\tstruct list_head list;\n\tstruct ip_set *set;\t \n\tip_set_id_t id;\n} __aligned(__alignof__(u64));\n\nstruct set_adt_elem {\n\tip_set_id_t id;\n\tip_set_id_t refid;\n\tint before;\n};\n\n \nstruct list_set {\n\tu32 size;\t\t \n\tstruct timer_list gc;\t \n\tstruct ip_set *set;\t \n\tstruct net *net;\t \n\tstruct list_head members;  \n};\n\nstatic int\nlist_set_ktest(struct ip_set *set, const struct sk_buff *skb,\n\t       const struct xt_action_param *par,\n\t       struct ip_set_adt_opt *opt, const struct ip_set_ext *ext)\n{\n\tstruct list_set *map = set->data;\n\tstruct ip_set_ext *mext = &opt->ext;\n\tstruct set_elem *e;\n\tu32 flags = opt->cmdflags;\n\tint ret;\n\n\t \n\topt->cmdflags &= ~IPSET_FLAG_MATCH_COUNTERS;\n\tif (opt->cmdflags & IPSET_FLAG_SKIP_SUBCOUNTER_UPDATE)\n\t\topt->cmdflags |= IPSET_FLAG_SKIP_COUNTER_UPDATE;\n\tlist_for_each_entry_rcu(e, &map->members, list) {\n\t\tret = ip_set_test(e->id, skb, par, opt);\n\t\tif (ret <= 0)\n\t\t\tcontinue;\n\t\tif (ip_set_match_extensions(set, ext, mext, flags, e))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\nlist_set_kadd(struct ip_set *set, const struct sk_buff *skb,\n\t      const struct xt_action_param *par,\n\t      struct ip_set_adt_opt *opt, const struct ip_set_ext *ext)\n{\n\tstruct list_set *map = set->data;\n\tstruct set_elem *e;\n\tint ret;\n\n\tlist_for_each_entry(e, &map->members, list) {\n\t\tif (SET_WITH_TIMEOUT(set) &&\n\t\t    ip_set_timeout_expired(ext_timeout(e, set)))\n\t\t\tcontinue;\n\t\tret = ip_set_add(e->id, skb, par, opt);\n\t\tif (ret == 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int\nlist_set_kdel(struct ip_set *set, const struct sk_buff *skb,\n\t      const struct xt_action_param *par,\n\t      struct ip_set_adt_opt *opt, const struct ip_set_ext *ext)\n{\n\tstruct list_set *map = set->data;\n\tstruct set_elem *e;\n\tint ret;\n\n\tlist_for_each_entry(e, &map->members, list) {\n\t\tif (SET_WITH_TIMEOUT(set) &&\n\t\t    ip_set_timeout_expired(ext_timeout(e, set)))\n\t\t\tcontinue;\n\t\tret = ip_set_del(e->id, skb, par, opt);\n\t\tif (ret == 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int\nlist_set_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t      const struct xt_action_param *par,\n\t      enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\tint ret = -EINVAL;\n\n\trcu_read_lock();\n\tswitch (adt) {\n\tcase IPSET_TEST:\n\t\tret = list_set_ktest(set, skb, par, opt, &ext);\n\t\tbreak;\n\tcase IPSET_ADD:\n\t\tret = list_set_kadd(set, skb, par, opt, &ext);\n\t\tbreak;\n\tcase IPSET_DEL:\n\t\tret = list_set_kdel(set, skb, par, opt, &ext);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n \n\nstatic void\n__list_set_del_rcu(struct rcu_head * rcu)\n{\n\tstruct set_elem *e = container_of(rcu, struct set_elem, rcu);\n\tstruct ip_set *set = e->set;\n\n\tip_set_ext_destroy(set, e);\n\tkfree(e);\n}\n\nstatic void\nlist_set_del(struct ip_set *set, struct set_elem *e)\n{\n\tstruct list_set *map = set->data;\n\n\tset->elements--;\n\tlist_del_rcu(&e->list);\n\tip_set_put_byindex(map->net, e->id);\n\tcall_rcu(&e->rcu, __list_set_del_rcu);\n}\n\nstatic void\nlist_set_replace(struct ip_set *set, struct set_elem *e, struct set_elem *old)\n{\n\tstruct list_set *map = set->data;\n\n\tlist_replace_rcu(&old->list, &e->list);\n\tip_set_put_byindex(map->net, old->id);\n\tcall_rcu(&old->rcu, __list_set_del_rcu);\n}\n\nstatic void\nset_cleanup_entries(struct ip_set *set)\n{\n\tstruct list_set *map = set->data;\n\tstruct set_elem *e, *n;\n\n\tlist_for_each_entry_safe(e, n, &map->members, list)\n\t\tif (ip_set_timeout_expired(ext_timeout(e, set)))\n\t\t\tlist_set_del(set, e);\n}\n\nstatic int\nlist_set_utest(struct ip_set *set, void *value, const struct ip_set_ext *ext,\n\t       struct ip_set_ext *mext, u32 flags)\n{\n\tstruct list_set *map = set->data;\n\tstruct set_adt_elem *d = value;\n\tstruct set_elem *e, *next, *prev = NULL;\n\tint ret;\n\n\tlist_for_each_entry(e, &map->members, list) {\n\t\tif (SET_WITH_TIMEOUT(set) &&\n\t\t    ip_set_timeout_expired(ext_timeout(e, set)))\n\t\t\tcontinue;\n\t\telse if (e->id != d->id) {\n\t\t\tprev = e;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (d->before == 0) {\n\t\t\tret = 1;\n\t\t} else if (d->before > 0) {\n\t\t\tnext = list_next_entry(e, list);\n\t\t\tret = !list_is_last(&e->list, &map->members) &&\n\t\t\t      next->id == d->refid;\n\t\t} else {\n\t\t\tret = prev && prev->id == d->refid;\n\t\t}\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void\nlist_set_init_extensions(struct ip_set *set, const struct ip_set_ext *ext,\n\t\t\t struct set_elem *e)\n{\n\tif (SET_WITH_COUNTER(set))\n\t\tip_set_init_counter(ext_counter(e, set), ext);\n\tif (SET_WITH_COMMENT(set))\n\t\tip_set_init_comment(set, ext_comment(e, set), ext);\n\tif (SET_WITH_SKBINFO(set))\n\t\tip_set_init_skbinfo(ext_skbinfo(e, set), ext);\n\t \n\tif (SET_WITH_TIMEOUT(set))\n\t\tip_set_timeout_set(ext_timeout(e, set), ext->timeout);\n}\n\nstatic int\nlist_set_uadd(struct ip_set *set, void *value, const struct ip_set_ext *ext,\n\t      struct ip_set_ext *mext, u32 flags)\n{\n\tstruct list_set *map = set->data;\n\tstruct set_adt_elem *d = value;\n\tstruct set_elem *e, *n, *prev, *next;\n\tbool flag_exist = flags & IPSET_FLAG_EXIST;\n\n\t \n\tn = prev = next = NULL;\n\tlist_for_each_entry(e, &map->members, list) {\n\t\tif (SET_WITH_TIMEOUT(set) &&\n\t\t    ip_set_timeout_expired(ext_timeout(e, set)))\n\t\t\tcontinue;\n\t\telse if (d->id == e->id)\n\t\t\tn = e;\n\t\telse if (d->before == 0 || e->id != d->refid)\n\t\t\tcontinue;\n\t\telse if (d->before > 0)\n\t\t\tnext = e;\n\t\telse\n\t\t\tprev = e;\n\t}\n\n\t \n\tif ((d->before > 0 && !next) ||\n\t    (d->before < 0 && !prev))\n\t\treturn -IPSET_ERR_REF_EXIST;\n\n\t \n\tif (n) {\n\t\tif (!flag_exist)\n\t\t\treturn -IPSET_ERR_EXIST;\n\t\t \n\t\tip_set_ext_destroy(set, n);\n\t\tlist_set_init_extensions(set, ext, n);\n\n\t\t \n\t\tip_set_put_byindex(map->net, d->id);\n\t\treturn 0;\n\t}\n\t \n\tif (d->before == 0) {\n\t\t \n\t\tn = list_empty(&map->members) ? NULL :\n\t\t    list_last_entry(&map->members, struct set_elem, list);\n\t} else if (d->before > 0) {\n\t\t \n\t\tif (!list_is_last(&next->list, &map->members))\n\t\t\tn = list_next_entry(next, list);\n\t} else {\n\t\t \n\t\tif (prev->list.prev != &map->members)\n\t\t\tn = list_prev_entry(prev, list);\n\t}\n\t \n\tif (n &&\n\t    !(SET_WITH_TIMEOUT(set) &&\n\t      ip_set_timeout_expired(ext_timeout(n, set))))\n\t\tn = NULL;\n\n\te = kzalloc(set->dsize, GFP_ATOMIC);\n\tif (!e)\n\t\treturn -ENOMEM;\n\te->id = d->id;\n\te->set = set;\n\tINIT_LIST_HEAD(&e->list);\n\tlist_set_init_extensions(set, ext, e);\n\tif (n)\n\t\tlist_set_replace(set, e, n);\n\telse if (next)\n\t\tlist_add_tail_rcu(&e->list, &next->list);\n\telse if (prev)\n\t\tlist_add_rcu(&e->list, &prev->list);\n\telse\n\t\tlist_add_tail_rcu(&e->list, &map->members);\n\tset->elements++;\n\n\treturn 0;\n}\n\nstatic int\nlist_set_udel(struct ip_set *set, void *value, const struct ip_set_ext *ext,\n\t      struct ip_set_ext *mext, u32 flags)\n{\n\tstruct list_set *map = set->data;\n\tstruct set_adt_elem *d = value;\n\tstruct set_elem *e, *next, *prev = NULL;\n\n\tlist_for_each_entry(e, &map->members, list) {\n\t\tif (SET_WITH_TIMEOUT(set) &&\n\t\t    ip_set_timeout_expired(ext_timeout(e, set)))\n\t\t\tcontinue;\n\t\telse if (e->id != d->id) {\n\t\t\tprev = e;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (d->before > 0) {\n\t\t\tnext = list_next_entry(e, list);\n\t\t\tif (list_is_last(&e->list, &map->members) ||\n\t\t\t    next->id != d->refid)\n\t\t\t\treturn -IPSET_ERR_REF_EXIST;\n\t\t} else if (d->before < 0) {\n\t\t\tif (!prev || prev->id != d->refid)\n\t\t\t\treturn -IPSET_ERR_REF_EXIST;\n\t\t}\n\t\tlist_set_del(set, e);\n\t\treturn 0;\n\t}\n\treturn d->before != 0 ? -IPSET_ERR_REF_EXIST : -IPSET_ERR_EXIST;\n}\n\nstatic int\nlist_set_uadt(struct ip_set *set, struct nlattr *tb[],\n\t      enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tstruct list_set *map = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct set_adt_elem e = { .refid = IPSET_INVALID_ID };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tstruct ip_set *s;\n\tint ret = 0;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\tif (unlikely(!tb[IPSET_ATTR_NAME] ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\te.id = ip_set_get_byname(map->net, nla_data(tb[IPSET_ATTR_NAME]), &s);\n\tif (e.id == IPSET_INVALID_ID)\n\t\treturn -IPSET_ERR_NAME;\n\t \n\tif (s->type->features & IPSET_TYPE_NAME) {\n\t\tret = -IPSET_ERR_LOOP;\n\t\tgoto finish;\n\t}\n\n\tif (tb[IPSET_ATTR_CADT_FLAGS]) {\n\t\tu32 f = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\n\n\t\te.before = f & IPSET_FLAG_BEFORE;\n\t}\n\n\tif (e.before && !tb[IPSET_ATTR_NAMEREF]) {\n\t\tret = -IPSET_ERR_BEFORE;\n\t\tgoto finish;\n\t}\n\n\tif (tb[IPSET_ATTR_NAMEREF]) {\n\t\te.refid = ip_set_get_byname(map->net,\n\t\t\t\t\t    nla_data(tb[IPSET_ATTR_NAMEREF]),\n\t\t\t\t\t    &s);\n\t\tif (e.refid == IPSET_INVALID_ID) {\n\t\t\tret = -IPSET_ERR_NAMEREF;\n\t\t\tgoto finish;\n\t\t}\n\t\tif (!e.before)\n\t\t\te.before = -1;\n\t}\n\tif (adt != IPSET_TEST && SET_WITH_TIMEOUT(set))\n\t\tset_cleanup_entries(set);\n\n\tret = adtfn(set, &e, &ext, &ext, flags);\n\nfinish:\n\tif (e.refid != IPSET_INVALID_ID)\n\t\tip_set_put_byindex(map->net, e.refid);\n\tif (adt != IPSET_ADD || ret)\n\t\tip_set_put_byindex(map->net, e.id);\n\n\treturn ip_set_eexist(ret, flags) ? 0 : ret;\n}\n\nstatic void\nlist_set_flush(struct ip_set *set)\n{\n\tstruct list_set *map = set->data;\n\tstruct set_elem *e, *n;\n\n\tlist_for_each_entry_safe(e, n, &map->members, list)\n\t\tlist_set_del(set, e);\n\tset->elements = 0;\n\tset->ext_size = 0;\n}\n\nstatic void\nlist_set_destroy(struct ip_set *set)\n{\n\tstruct list_set *map = set->data;\n\tstruct set_elem *e, *n;\n\n\tif (SET_WITH_TIMEOUT(set))\n\t\ttimer_shutdown_sync(&map->gc);\n\n\tlist_for_each_entry_safe(e, n, &map->members, list) {\n\t\tlist_del(&e->list);\n\t\tip_set_put_byindex(map->net, e->id);\n\t\tip_set_ext_destroy(set, e);\n\t\tkfree(e);\n\t}\n\tkfree(map);\n\n\tset->data = NULL;\n}\n\n \nstatic size_t\nlist_set_memsize(const struct list_set *map, size_t dsize)\n{\n\tstruct set_elem *e;\n\tu32 n = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &map->members, list)\n\t\tn++;\n\trcu_read_unlock();\n\n\treturn (sizeof(*map) + n * dsize);\n}\n\nstatic int\nlist_set_head(struct ip_set *set, struct sk_buff *skb)\n{\n\tconst struct list_set *map = set->data;\n\tstruct nlattr *nested;\n\tsize_t memsize = list_set_memsize(map, set->dsize) + set->ext_size;\n\n\tnested = nla_nest_start(skb, IPSET_ATTR_DATA);\n\tif (!nested)\n\t\tgoto nla_put_failure;\n\tif (nla_put_net32(skb, IPSET_ATTR_SIZE, htonl(map->size)) ||\n\t    nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref)) ||\n\t    nla_put_net32(skb, IPSET_ATTR_MEMSIZE, htonl(memsize)) ||\n\t    nla_put_net32(skb, IPSET_ATTR_ELEMENTS, htonl(set->elements)))\n\t\tgoto nla_put_failure;\n\tif (unlikely(ip_set_put_flags(skb, set)))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nested);\n\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int\nlist_set_list(const struct ip_set *set,\n\t      struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct list_set *map = set->data;\n\tstruct nlattr *atd, *nested;\n\tu32 i = 0, first = cb->args[IPSET_CB_ARG0];\n\tchar name[IPSET_MAXNAMELEN];\n\tstruct set_elem *e;\n\tint ret = 0;\n\n\tatd = nla_nest_start(skb, IPSET_ATTR_ADT);\n\tif (!atd)\n\t\treturn -EMSGSIZE;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &map->members, list) {\n\t\tif (i < first ||\n\t\t    (SET_WITH_TIMEOUT(set) &&\n\t\t     ip_set_timeout_expired(ext_timeout(e, set)))) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tnested = nla_nest_start(skb, IPSET_ATTR_DATA);\n\t\tif (!nested)\n\t\t\tgoto nla_put_failure;\n\t\tip_set_name_byindex(map->net, e->id, name);\n\t\tif (nla_put_string(skb, IPSET_ATTR_NAME, name))\n\t\t\tgoto nla_put_failure;\n\t\tif (ip_set_put_extensions(skb, set, e, true))\n\t\t\tgoto nla_put_failure;\n\t\tnla_nest_end(skb, nested);\n\t\ti++;\n\t}\n\n\tnla_nest_end(skb, atd);\n\t \n\tcb->args[IPSET_CB_ARG0] = 0;\n\tgoto out;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nested);\n\tif (unlikely(i == first)) {\n\t\tnla_nest_cancel(skb, atd);\n\t\tcb->args[IPSET_CB_ARG0] = 0;\n\t\tret = -EMSGSIZE;\n\t} else {\n\t\tcb->args[IPSET_CB_ARG0] = i;\n\t\tnla_nest_end(skb, atd);\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic bool\nlist_set_same_set(const struct ip_set *a, const struct ip_set *b)\n{\n\tconst struct list_set *x = a->data;\n\tconst struct list_set *y = b->data;\n\n\treturn x->size == y->size &&\n\t       a->timeout == b->timeout &&\n\t       a->extensions == b->extensions;\n}\n\nstatic const struct ip_set_type_variant set_variant = {\n\t.kadt\t= list_set_kadt,\n\t.uadt\t= list_set_uadt,\n\t.adt\t= {\n\t\t[IPSET_ADD] = list_set_uadd,\n\t\t[IPSET_DEL] = list_set_udel,\n\t\t[IPSET_TEST] = list_set_utest,\n\t},\n\t.destroy = list_set_destroy,\n\t.flush\t= list_set_flush,\n\t.head\t= list_set_head,\n\t.list\t= list_set_list,\n\t.same_set = list_set_same_set,\n};\n\nstatic void\nlist_set_gc(struct timer_list *t)\n{\n\tstruct list_set *map = from_timer(map, t, gc);\n\tstruct ip_set *set = map->set;\n\n\tspin_lock_bh(&set->lock);\n\tset_cleanup_entries(set);\n\tspin_unlock_bh(&set->lock);\n\n\tmap->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;\n\tadd_timer(&map->gc);\n}\n\nstatic void\nlist_set_gc_init(struct ip_set *set, void (*gc)(struct timer_list *t))\n{\n\tstruct list_set *map = set->data;\n\n\ttimer_setup(&map->gc, gc, 0);\n\tmod_timer(&map->gc, jiffies + IPSET_GC_PERIOD(set->timeout) * HZ);\n}\n\n \n\nstatic bool\ninit_list_set(struct net *net, struct ip_set *set, u32 size)\n{\n\tstruct list_set *map;\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn false;\n\n\tmap->size = size;\n\tmap->net = net;\n\tmap->set = set;\n\tINIT_LIST_HEAD(&map->members);\n\tset->data = map;\n\n\treturn true;\n}\n\nstatic int\nlist_set_create(struct net *net, struct ip_set *set, struct nlattr *tb[],\n\t\tu32 flags)\n{\n\tu32 size = IP_SET_LIST_DEFAULT_SIZE;\n\n\tif (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_SIZE) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tif (tb[IPSET_ATTR_SIZE])\n\t\tsize = ip_set_get_h32(tb[IPSET_ATTR_SIZE]);\n\tif (size < IP_SET_LIST_MIN_SIZE)\n\t\tsize = IP_SET_LIST_MIN_SIZE;\n\n\tset->variant = &set_variant;\n\tset->dsize = ip_set_elem_len(set, tb, sizeof(struct set_elem),\n\t\t\t\t     __alignof__(struct set_elem));\n\tif (!init_list_set(net, set, size))\n\t\treturn -ENOMEM;\n\tif (tb[IPSET_ATTR_TIMEOUT]) {\n\t\tset->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\n\t\tlist_set_gc_init(set, list_set_gc);\n\t}\n\treturn 0;\n}\n\nstatic struct ip_set_type list_set_type __read_mostly = {\n\t.name\t\t= \"list:set\",\n\t.protocol\t= IPSET_PROTOCOL,\n\t.features\t= IPSET_TYPE_NAME | IPSET_DUMP_LAST,\n\t.dimension\t= IPSET_DIM_ONE,\n\t.family\t\t= NFPROTO_UNSPEC,\n\t.revision_min\t= IPSET_TYPE_REV_MIN,\n\t.revision_max\t= IPSET_TYPE_REV_MAX,\n\t.create\t\t= list_set_create,\n\t.create_policy\t= {\n\t\t[IPSET_ATTR_SIZE]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t},\n\t.adt_policy\t= {\n\t\t[IPSET_ATTR_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = IPSET_MAXNAMELEN },\n\t\t[IPSET_ATTR_NAMEREF]\t= { .type = NLA_STRING,\n\t\t\t\t\t    .len = IPSET_MAXNAMELEN },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_LINENO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BYTES]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_PACKETS]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_COMMENT]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len  = IPSET_MAX_COMMENT_SIZE },\n\t\t[IPSET_ATTR_SKBMARK]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_SKBPRIO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_SKBQUEUE]\t= { .type = NLA_U16 },\n\t},\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init\nlist_set_init(void)\n{\n\treturn ip_set_type_register(&list_set_type);\n}\n\nstatic void __exit\nlist_set_fini(void)\n{\n\trcu_barrier();\n\tip_set_type_unregister(&list_set_type);\n}\n\nmodule_init(list_set_init);\nmodule_exit(list_set_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}