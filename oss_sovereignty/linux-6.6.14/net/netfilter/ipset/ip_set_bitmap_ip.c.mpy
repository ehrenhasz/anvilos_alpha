{
  "module_name": "ip_set_bitmap_ip.c",
  "hash_id": "e2f281670c969a88cf5b93b68a71b1e2fefc196ec2b35869607e38603c73cb97",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipset/ip_set_bitmap_ip.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/spinlock.h>\n#include <linux/netlink.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <net/netlink.h>\n#include <net/tcp.h>\n\n#include <linux/netfilter/ipset/pfxlen.h>\n#include <linux/netfilter/ipset/ip_set.h>\n#include <linux/netfilter/ipset/ip_set_bitmap.h>\n\n#define IPSET_TYPE_REV_MIN\t0\n \n \n#define IPSET_TYPE_REV_MAX\t3\t \n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jozsef Kadlecsik <kadlec@netfilter.org>\");\nIP_SET_MODULE_DESC(\"bitmap:ip\", IPSET_TYPE_REV_MIN, IPSET_TYPE_REV_MAX);\nMODULE_ALIAS(\"ip_set_bitmap:ip\");\n\n#define MTYPE\t\tbitmap_ip\n#define HOST_MASK\t32\n\n \nstruct bitmap_ip {\n\tunsigned long *members;\t \n\tu32 first_ip;\t\t \n\tu32 last_ip;\t\t \n\tu32 elements;\t\t \n\tu32 hosts;\t\t \n\tsize_t memsize;\t\t \n\tu8 netmask;\t\t \n\tstruct timer_list gc;\t \n\tstruct ip_set *set;\t \n\tunsigned char extensions[]\t \n\t\t__aligned(__alignof__(u64));\n};\n\n \nstruct bitmap_ip_adt_elem {\n\tu16 id;\n};\n\nstatic u32\nip_to_id(const struct bitmap_ip *m, u32 ip)\n{\n\treturn ((ip & ip_set_hostmask(m->netmask)) - m->first_ip) / m->hosts;\n}\n\n \n\nstatic int\nbitmap_ip_do_test(const struct bitmap_ip_adt_elem *e,\n\t\t  struct bitmap_ip *map, size_t dsize)\n{\n\treturn !!test_bit(e->id, map->members);\n}\n\nstatic int\nbitmap_ip_gc_test(u16 id, const struct bitmap_ip *map, size_t dsize)\n{\n\treturn !!test_bit(id, map->members);\n}\n\nstatic int\nbitmap_ip_do_add(const struct bitmap_ip_adt_elem *e, struct bitmap_ip *map,\n\t\t u32 flags, size_t dsize)\n{\n\treturn !!test_bit(e->id, map->members);\n}\n\nstatic int\nbitmap_ip_do_del(const struct bitmap_ip_adt_elem *e, struct bitmap_ip *map)\n{\n\treturn !test_and_clear_bit(e->id, map->members);\n}\n\nstatic int\nbitmap_ip_do_list(struct sk_buff *skb, const struct bitmap_ip *map, u32 id,\n\t\t  size_t dsize)\n{\n\treturn nla_put_ipaddr4(skb, IPSET_ATTR_IP,\n\t\t\thtonl(map->first_ip + id * map->hosts));\n}\n\nstatic int\nbitmap_ip_do_head(struct sk_buff *skb, const struct bitmap_ip *map)\n{\n\treturn nla_put_ipaddr4(skb, IPSET_ATTR_IP, htonl(map->first_ip)) ||\n\t       nla_put_ipaddr4(skb, IPSET_ATTR_IP_TO, htonl(map->last_ip)) ||\n\t       (map->netmask != 32 &&\n\t\tnla_put_u8(skb, IPSET_ATTR_NETMASK, map->netmask));\n}\n\nstatic int\nbitmap_ip_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t       const struct xt_action_param *par,\n\t       enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tstruct bitmap_ip *map = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct bitmap_ip_adt_elem e = { .id = 0 };\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\tu32 ip;\n\n\tip = ntohl(ip4addr(skb, opt->flags & IPSET_DIM_ONE_SRC));\n\tif (ip < map->first_ip || ip > map->last_ip)\n\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\n\te.id = ip_to_id(map, ip);\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic int\nbitmap_ip_uadt(struct ip_set *set, struct nlattr *tb[],\n\t       enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tstruct bitmap_ip *map = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tu32 ip = 0, ip_to = 0;\n\tstruct bitmap_ip_adt_elem e = { .id = 0 };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tint ret = 0;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\tif (unlikely(!tb[IPSET_ATTR_IP]))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ip < map->first_ip || ip > map->last_ip)\n\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\n\tif (adt == IPSET_TEST) {\n\t\te.id = ip_to_id(map, ip);\n\t\treturn adtfn(set, &e, &ext, &ext, flags);\n\t}\n\n\tif (tb[IPSET_ATTR_IP_TO]) {\n\t\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (ip > ip_to) {\n\t\t\tswap(ip, ip_to);\n\t\t\tif (ip < map->first_ip)\n\t\t\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\t\t}\n\t} else if (tb[IPSET_ATTR_CIDR]) {\n\t\tu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\n\n\t\tif (!cidr || cidr > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t\tip_set_mask_from_to(ip, ip_to, cidr);\n\t} else {\n\t\tip_to = ip;\n\t}\n\n\tif (ip_to > map->last_ip)\n\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\n\tfor (; !before(ip_to, ip); ip += map->hosts) {\n\t\te.id = ip_to_id(map, ip);\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\n\t\tif (ret && !ip_set_eexist(ret, flags))\n\t\t\treturn ret;\n\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic bool\nbitmap_ip_same_set(const struct ip_set *a, const struct ip_set *b)\n{\n\tconst struct bitmap_ip *x = a->data;\n\tconst struct bitmap_ip *y = b->data;\n\n\treturn x->first_ip == y->first_ip &&\n\t       x->last_ip == y->last_ip &&\n\t       x->netmask == y->netmask &&\n\t       a->timeout == b->timeout &&\n\t       a->extensions == b->extensions;\n}\n\n \n\nstruct bitmap_ip_elem {\n};\n\n#include \"ip_set_bitmap_gen.h\"\n\n \n\nstatic bool\ninit_map_ip(struct ip_set *set, struct bitmap_ip *map,\n\t    u32 first_ip, u32 last_ip,\n\t    u32 elements, u32 hosts, u8 netmask)\n{\n\tmap->members = bitmap_zalloc(elements, GFP_KERNEL | __GFP_NOWARN);\n\tif (!map->members)\n\t\treturn false;\n\tmap->first_ip = first_ip;\n\tmap->last_ip = last_ip;\n\tmap->elements = elements;\n\tmap->hosts = hosts;\n\tmap->netmask = netmask;\n\tset->timeout = IPSET_NO_TIMEOUT;\n\n\tmap->set = set;\n\tset->data = map;\n\tset->family = NFPROTO_IPV4;\n\n\treturn true;\n}\n\nstatic u32\nrange_to_mask(u32 from, u32 to, u8 *bits)\n{\n\tu32 mask = 0xFFFFFFFE;\n\n\t*bits = 32;\n\twhile (--(*bits) > 0 && mask && (to & mask) != from)\n\t\tmask <<= 1;\n\n\treturn mask;\n}\n\nstatic int\nbitmap_ip_create(struct net *net, struct ip_set *set, struct nlattr *tb[],\n\t\t u32 flags)\n{\n\tstruct bitmap_ip *map;\n\tu32 first_ip = 0, last_ip = 0, hosts;\n\tu64 elements;\n\tu8 netmask = 32;\n\tint ret;\n\n\tif (unlikely(!tb[IPSET_ATTR_IP] ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &first_ip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[IPSET_ATTR_IP_TO]) {\n\t\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &last_ip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (first_ip > last_ip)\n\t\t\tswap(first_ip, last_ip);\n\t} else if (tb[IPSET_ATTR_CIDR]) {\n\t\tu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\n\n\t\tif (cidr >= HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t\tip_set_mask_from_to(first_ip, last_ip, cidr);\n\t} else {\n\t\treturn -IPSET_ERR_PROTOCOL;\n\t}\n\n\tif (tb[IPSET_ATTR_NETMASK]) {\n\t\tnetmask = nla_get_u8(tb[IPSET_ATTR_NETMASK]);\n\n\t\tif (netmask > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_NETMASK;\n\n\t\tfirst_ip &= ip_set_hostmask(netmask);\n\t\tlast_ip |= ~ip_set_hostmask(netmask);\n\t}\n\n\tif (netmask == 32) {\n\t\thosts = 1;\n\t\telements = (u64)last_ip - first_ip + 1;\n\t} else {\n\t\tu8 mask_bits;\n\t\tu32 mask;\n\n\t\tmask = range_to_mask(first_ip, last_ip, &mask_bits);\n\n\t\tif ((!mask && (first_ip || last_ip != 0xFFFFFFFF)) ||\n\t\t    netmask <= mask_bits)\n\t\t\treturn -IPSET_ERR_BITMAP_RANGE;\n\n\t\tpr_debug(\"mask_bits %u, netmask %u\\n\", mask_bits, netmask);\n\t\thosts = 2U << (32 - netmask - 1);\n\t\telements = 2UL << (netmask - mask_bits - 1);\n\t}\n\tif (elements > IPSET_BITMAP_MAX_RANGE + 1)\n\t\treturn -IPSET_ERR_BITMAP_RANGE_SIZE;\n\n\tpr_debug(\"hosts %u, elements %llu\\n\",\n\t\t hosts, (unsigned long long)elements);\n\n\tset->dsize = ip_set_elem_len(set, tb, 0, 0);\n\tmap = ip_set_alloc(sizeof(*map) + elements * set->dsize);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->memsize = BITS_TO_LONGS(elements) * sizeof(unsigned long);\n\tset->variant = &bitmap_ip;\n\tif (!init_map_ip(set, map, first_ip, last_ip,\n\t\t\t elements, hosts, netmask)) {\n\t\tip_set_free(map);\n\t\treturn -ENOMEM;\n\t}\n\tif (tb[IPSET_ATTR_TIMEOUT]) {\n\t\tset->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\n\t\tbitmap_ip_gc_init(set, bitmap_ip_gc);\n\t}\n\treturn 0;\n}\n\nstatic struct ip_set_type bitmap_ip_type __read_mostly = {\n\t.name\t\t= \"bitmap:ip\",\n\t.protocol\t= IPSET_PROTOCOL,\n\t.features\t= IPSET_TYPE_IP,\n\t.dimension\t= IPSET_DIM_ONE,\n\t.family\t\t= NFPROTO_IPV4,\n\t.revision_min\t= IPSET_TYPE_REV_MIN,\n\t.revision_max\t= IPSET_TYPE_REV_MAX,\n\t.create\t\t= bitmap_ip_create,\n\t.create_policy\t= {\n\t\t[IPSET_ATTR_IP]\t\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP_TO]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_CIDR]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_NETMASK]\t= { .type = NLA_U8  },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t},\n\t.adt_policy\t= {\n\t\t[IPSET_ATTR_IP]\t\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP_TO]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_CIDR]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_LINENO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BYTES]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_PACKETS]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_COMMENT]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len  = IPSET_MAX_COMMENT_SIZE },\n\t\t[IPSET_ATTR_SKBMARK]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_SKBPRIO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_SKBQUEUE]\t= { .type = NLA_U16 },\n\t},\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init\nbitmap_ip_init(void)\n{\n\treturn ip_set_type_register(&bitmap_ip_type);\n}\n\nstatic void __exit\nbitmap_ip_fini(void)\n{\n\trcu_barrier();\n\tip_set_type_unregister(&bitmap_ip_type);\n}\n\nmodule_init(bitmap_ip_init);\nmodule_exit(bitmap_ip_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}