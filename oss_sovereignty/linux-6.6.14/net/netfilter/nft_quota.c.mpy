{
  "module_name": "nft_quota.c",
  "hash_id": "c82c1700efbb0fbd141326222b85a8cf215d98790602e6185623f8c9686ff76a",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_quota.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n\nstruct nft_quota {\n\tatomic64_t\tquota;\n\tunsigned long\tflags;\n\tatomic64_t\t*consumed;\n};\n\nstatic inline bool nft_overquota(struct nft_quota *priv,\n\t\t\t\t const struct sk_buff *skb)\n{\n\treturn atomic64_add_return(skb->len, priv->consumed) >=\n\t       atomic64_read(&priv->quota);\n}\n\nstatic inline bool nft_quota_invert(struct nft_quota *priv)\n{\n\treturn priv->flags & NFT_QUOTA_F_INV;\n}\n\nstatic inline void nft_quota_do_eval(struct nft_quota *priv,\n\t\t\t\t     struct nft_regs *regs,\n\t\t\t\t     const struct nft_pktinfo *pkt)\n{\n\tif (nft_overquota(priv, pkt->skb) ^ nft_quota_invert(priv))\n\t\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic const struct nla_policy nft_quota_policy[NFTA_QUOTA_MAX + 1] = {\n\t[NFTA_QUOTA_BYTES]\t= { .type = NLA_U64 },\n\t[NFTA_QUOTA_FLAGS]\t= { .type = NLA_U32 },\n\t[NFTA_QUOTA_CONSUMED]\t= { .type = NLA_U64 },\n};\n\n#define NFT_QUOTA_DEPLETED_BIT\t1\t \n\nstatic void nft_quota_obj_eval(struct nft_object *obj,\n\t\t\t       struct nft_regs *regs,\n\t\t\t       const struct nft_pktinfo *pkt)\n{\n\tstruct nft_quota *priv = nft_obj_data(obj);\n\tbool overquota;\n\n\toverquota = nft_overquota(priv, pkt->skb);\n\tif (overquota ^ nft_quota_invert(priv))\n\t\tregs->verdict.code = NFT_BREAK;\n\n\tif (overquota &&\n\t    !test_and_set_bit(NFT_QUOTA_DEPLETED_BIT, &priv->flags))\n\t\tnft_obj_notify(nft_net(pkt), obj->key.table, obj, 0, 0,\n\t\t\t       NFT_MSG_NEWOBJ, 0, nft_pf(pkt), 0, GFP_ATOMIC);\n}\n\nstatic int nft_quota_do_init(const struct nlattr * const tb[],\n\t\t\t     struct nft_quota *priv)\n{\n\tunsigned long flags = 0;\n\tu64 quota, consumed = 0;\n\n\tif (!tb[NFTA_QUOTA_BYTES])\n\t\treturn -EINVAL;\n\n\tquota = be64_to_cpu(nla_get_be64(tb[NFTA_QUOTA_BYTES]));\n\tif (quota > S64_MAX)\n\t\treturn -EOVERFLOW;\n\n\tif (tb[NFTA_QUOTA_CONSUMED]) {\n\t\tconsumed = be64_to_cpu(nla_get_be64(tb[NFTA_QUOTA_CONSUMED]));\n\t\tif (consumed > quota)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NFTA_QUOTA_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(tb[NFTA_QUOTA_FLAGS]));\n\t\tif (flags & ~NFT_QUOTA_F_INV)\n\t\t\treturn -EINVAL;\n\t\tif (flags & NFT_QUOTA_F_DEPLETED)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->consumed = kmalloc(sizeof(*priv->consumed), GFP_KERNEL_ACCOUNT);\n\tif (!priv->consumed)\n\t\treturn -ENOMEM;\n\n\tatomic64_set(&priv->quota, quota);\n\tpriv->flags = flags;\n\tatomic64_set(priv->consumed, consumed);\n\n\treturn 0;\n}\n\nstatic void nft_quota_do_destroy(const struct nft_ctx *ctx,\n\t\t\t\t struct nft_quota *priv)\n{\n\tkfree(priv->consumed);\n}\n\nstatic int nft_quota_obj_init(const struct nft_ctx *ctx,\n\t\t\t      const struct nlattr * const tb[],\n\t\t\t      struct nft_object *obj)\n{\n\tstruct nft_quota *priv = nft_obj_data(obj);\n\n\treturn nft_quota_do_init(tb, priv);\n}\n\nstatic void nft_quota_obj_update(struct nft_object *obj,\n\t\t\t\t struct nft_object *newobj)\n{\n\tstruct nft_quota *newpriv = nft_obj_data(newobj);\n\tstruct nft_quota *priv = nft_obj_data(obj);\n\tu64 newquota;\n\n\tnewquota = atomic64_read(&newpriv->quota);\n\tatomic64_set(&priv->quota, newquota);\n\tpriv->flags = newpriv->flags;\n}\n\nstatic int nft_quota_do_dump(struct sk_buff *skb, struct nft_quota *priv,\n\t\t\t     bool reset)\n{\n\tu64 consumed, consumed_cap, quota;\n\tu32 flags = priv->flags;\n\n\t \n\tconsumed = atomic64_read(priv->consumed);\n\tquota = atomic64_read(&priv->quota);\n\tif (consumed >= quota) {\n\t\tconsumed_cap = quota;\n\t\tflags |= NFT_QUOTA_F_DEPLETED;\n\t} else {\n\t\tconsumed_cap = consumed;\n\t}\n\n\tif (nla_put_be64(skb, NFTA_QUOTA_BYTES, cpu_to_be64(quota),\n\t\t\t NFTA_QUOTA_PAD) ||\n\t    nla_put_be64(skb, NFTA_QUOTA_CONSUMED, cpu_to_be64(consumed_cap),\n\t\t\t NFTA_QUOTA_PAD) ||\n\t    nla_put_be32(skb, NFTA_QUOTA_FLAGS, htonl(flags)))\n\t\tgoto nla_put_failure;\n\n\tif (reset) {\n\t\tatomic64_sub(consumed, priv->consumed);\n\t\tclear_bit(NFT_QUOTA_DEPLETED_BIT, &priv->flags);\n\t}\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_quota_obj_dump(struct sk_buff *skb, struct nft_object *obj,\n\t\t\t      bool reset)\n{\n\tstruct nft_quota *priv = nft_obj_data(obj);\n\n\treturn nft_quota_do_dump(skb, priv, reset);\n}\n\nstatic void nft_quota_obj_destroy(const struct nft_ctx *ctx,\n\t\t\t\t  struct nft_object *obj)\n{\n\tstruct nft_quota *priv = nft_obj_data(obj);\n\n\treturn nft_quota_do_destroy(ctx, priv);\n}\n\nstatic struct nft_object_type nft_quota_obj_type;\nstatic const struct nft_object_ops nft_quota_obj_ops = {\n\t.type\t\t= &nft_quota_obj_type,\n\t.size\t\t= sizeof(struct nft_quota),\n\t.init\t\t= nft_quota_obj_init,\n\t.destroy\t= nft_quota_obj_destroy,\n\t.eval\t\t= nft_quota_obj_eval,\n\t.dump\t\t= nft_quota_obj_dump,\n\t.update\t\t= nft_quota_obj_update,\n};\n\nstatic struct nft_object_type nft_quota_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_QUOTA,\n\t.ops\t\t= &nft_quota_obj_ops,\n\t.maxattr\t= NFTA_QUOTA_MAX,\n\t.policy\t\t= nft_quota_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void nft_quota_eval(const struct nft_expr *expr,\n\t\t\t   struct nft_regs *regs,\n\t\t\t   const struct nft_pktinfo *pkt)\n{\n\tstruct nft_quota *priv = nft_expr_priv(expr);\n\n\tnft_quota_do_eval(priv, regs, pkt);\n}\n\nstatic int nft_quota_init(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_quota *priv = nft_expr_priv(expr);\n\n\treturn nft_quota_do_init(tb, priv);\n}\n\nstatic int nft_quota_dump(struct sk_buff *skb,\n\t\t\t  const struct nft_expr *expr, bool reset)\n{\n\tstruct nft_quota *priv = nft_expr_priv(expr);\n\n\treturn nft_quota_do_dump(skb, priv, reset);\n}\n\nstatic void nft_quota_destroy(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr)\n{\n\tstruct nft_quota *priv = nft_expr_priv(expr);\n\n\treturn nft_quota_do_destroy(ctx, priv);\n}\n\nstatic int nft_quota_clone(struct nft_expr *dst, const struct nft_expr *src)\n{\n\tstruct nft_quota *priv_dst = nft_expr_priv(dst);\n\tstruct nft_quota *priv_src = nft_expr_priv(src);\n\n\tpriv_dst->quota = priv_src->quota;\n\tpriv_dst->flags = priv_src->flags;\n\n\tpriv_dst->consumed = kmalloc(sizeof(*priv_dst->consumed), GFP_ATOMIC);\n\tif (!priv_dst->consumed)\n\t\treturn -ENOMEM;\n\n\t*priv_dst->consumed = *priv_src->consumed;\n\n\treturn 0;\n}\n\nstatic struct nft_expr_type nft_quota_type;\nstatic const struct nft_expr_ops nft_quota_ops = {\n\t.type\t\t= &nft_quota_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_quota)),\n\t.eval\t\t= nft_quota_eval,\n\t.init\t\t= nft_quota_init,\n\t.destroy\t= nft_quota_destroy,\n\t.clone\t\t= nft_quota_clone,\n\t.dump\t\t= nft_quota_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_quota_type __read_mostly = {\n\t.name\t\t= \"quota\",\n\t.ops\t\t= &nft_quota_ops,\n\t.policy\t\t= nft_quota_policy,\n\t.maxattr\t= NFTA_QUOTA_MAX,\n\t.flags\t\t= NFT_EXPR_STATEFUL,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_quota_module_init(void)\n{\n\tint err;\n\n\terr = nft_register_obj(&nft_quota_obj_type);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_register_expr(&nft_quota_type);\n\tif (err < 0)\n\t\tgoto err1;\n\n\treturn 0;\nerr1:\n\tnft_unregister_obj(&nft_quota_obj_type);\n\treturn err;\n}\n\nstatic void __exit nft_quota_module_exit(void)\n{\n\tnft_unregister_expr(&nft_quota_type);\n\tnft_unregister_obj(&nft_quota_obj_type);\n}\n\nmodule_init(nft_quota_module_init);\nmodule_exit(nft_quota_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_ALIAS_NFT_EXPR(\"quota\");\nMODULE_ALIAS_NFT_OBJ(NFT_OBJECT_QUOTA);\nMODULE_DESCRIPTION(\"Netfilter nftables quota module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}