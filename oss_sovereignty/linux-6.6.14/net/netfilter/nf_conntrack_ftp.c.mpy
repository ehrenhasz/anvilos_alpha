{
  "module_name": "nf_conntrack_ftp.c",
  "hash_id": "614a30553e52c5e828d2438904a59ff6cd1a53e5579856143af930aa689b1771",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_ftp.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/netfilter.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/ipv6.h>\n#include <linux/ctype.h>\n#include <linux/inet.h>\n#include <net/checksum.h>\n#include <net/tcp.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <linux/netfilter/nf_conntrack_ftp.h>\n\n#define HELPER_NAME \"ftp\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Rusty Russell <rusty@rustcorp.com.au>\");\nMODULE_DESCRIPTION(\"ftp connection tracking helper\");\nMODULE_ALIAS(\"ip_conntrack_ftp\");\nMODULE_ALIAS_NFCT_HELPER(HELPER_NAME);\nstatic DEFINE_SPINLOCK(nf_ftp_lock);\n\n#define MAX_PORTS 8\nstatic u_int16_t ports[MAX_PORTS];\nstatic unsigned int ports_c;\nmodule_param_array(ports, ushort, &ports_c, 0400);\n\nstatic bool loose;\nmodule_param(loose, bool, 0600);\n\nunsigned int (*nf_nat_ftp_hook)(struct sk_buff *skb,\n\t\t\t\tenum ip_conntrack_info ctinfo,\n\t\t\t\tenum nf_ct_ftp_type type,\n\t\t\t\tunsigned int protoff,\n\t\t\t\tunsigned int matchoff,\n\t\t\t\tunsigned int matchlen,\n\t\t\t\tstruct nf_conntrack_expect *exp);\nEXPORT_SYMBOL_GPL(nf_nat_ftp_hook);\n\nstatic int try_rfc959(const char *, size_t, struct nf_conntrack_man *,\n\t\t      char, unsigned int *);\nstatic int try_rfc1123(const char *, size_t, struct nf_conntrack_man *,\n\t\t       char, unsigned int *);\nstatic int try_eprt(const char *, size_t, struct nf_conntrack_man *,\n\t\t    char, unsigned int *);\nstatic int try_epsv_response(const char *, size_t, struct nf_conntrack_man *,\n\t\t\t     char, unsigned int *);\n\nstatic struct ftp_search {\n\tconst char *pattern;\n\tsize_t plen;\n\tchar skip;\n\tchar term;\n\tenum nf_ct_ftp_type ftptype;\n\tint (*getnum)(const char *, size_t, struct nf_conntrack_man *, char, unsigned int *);\n} search[IP_CT_DIR_MAX][2] = {\n\t[IP_CT_DIR_ORIGINAL] = {\n\t\t{\n\t\t\t.pattern\t= \"PORT\",\n\t\t\t.plen\t\t= sizeof(\"PORT\") - 1,\n\t\t\t.skip\t\t= ' ',\n\t\t\t.term\t\t= '\\r',\n\t\t\t.ftptype\t= NF_CT_FTP_PORT,\n\t\t\t.getnum\t\t= try_rfc959,\n\t\t},\n\t\t{\n\t\t\t.pattern\t= \"EPRT\",\n\t\t\t.plen\t\t= sizeof(\"EPRT\") - 1,\n\t\t\t.skip\t\t= ' ',\n\t\t\t.term\t\t= '\\r',\n\t\t\t.ftptype\t= NF_CT_FTP_EPRT,\n\t\t\t.getnum\t\t= try_eprt,\n\t\t},\n\t},\n\t[IP_CT_DIR_REPLY] = {\n\t\t{\n\t\t\t.pattern\t= \"227 \",\n\t\t\t.plen\t\t= sizeof(\"227 \") - 1,\n\t\t\t.ftptype\t= NF_CT_FTP_PASV,\n\t\t\t.getnum\t\t= try_rfc1123,\n\t\t},\n\t\t{\n\t\t\t.pattern\t= \"229 \",\n\t\t\t.plen\t\t= sizeof(\"229 \") - 1,\n\t\t\t.skip\t\t= '(',\n\t\t\t.term\t\t= ')',\n\t\t\t.ftptype\t= NF_CT_FTP_EPSV,\n\t\t\t.getnum\t\t= try_epsv_response,\n\t\t},\n\t},\n};\n\nstatic int\nget_ipv6_addr(const char *src, size_t dlen, struct in6_addr *dst, u_int8_t term)\n{\n\tconst char *end;\n\tint ret = in6_pton(src, min_t(size_t, dlen, 0xffff), (u8 *)dst, term, &end);\n\tif (ret > 0)\n\t\treturn (int)(end - src);\n\treturn 0;\n}\n\nstatic int try_number(const char *data, size_t dlen, u_int32_t array[],\n\t\t      int array_size, char sep, char term)\n{\n\tu_int32_t i, len;\n\n\tmemset(array, 0, sizeof(array[0])*array_size);\n\n\t \n\tfor (i = 0, len = 0; len < dlen && i < array_size; len++, data++) {\n\t\tif (*data >= '0' && *data <= '9') {\n\t\t\tarray[i] = array[i]*10 + *data - '0';\n\t\t}\n\t\telse if (*data == sep)\n\t\t\ti++;\n\t\telse {\n\t\t\t \n\t\t\tif ((*data == term || !term) && i == array_size - 1)\n\t\t\t\treturn len;\n\n\t\t\tpr_debug(\"Char %u (got %u nums) `%u' unexpected\\n\",\n\t\t\t\t len, i, *data);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tpr_debug(\"Failed to fill %u numbers separated by %c\\n\",\n\t\t array_size, sep);\n\treturn 0;\n}\n\n \nstatic int try_rfc959(const char *data, size_t dlen,\n\t\t      struct nf_conntrack_man *cmd, char term,\n\t\t      unsigned int *offset)\n{\n\tint length;\n\tu_int32_t array[6];\n\n\tlength = try_number(data, dlen, array, 6, ',', term);\n\tif (length == 0)\n\t\treturn 0;\n\n\tcmd->u3.ip = htonl((array[0] << 24) | (array[1] << 16) |\n\t\t\t\t    (array[2] << 8) | array[3]);\n\tcmd->u.tcp.port = htons((array[4] << 8) | array[5]);\n\treturn length;\n}\n\n \nstatic int try_rfc1123(const char *data, size_t dlen,\n\t\t       struct nf_conntrack_man *cmd, char term,\n\t\t       unsigned int *offset)\n{\n\tint i;\n\tfor (i = 0; i < dlen; i++)\n\t\tif (isdigit(data[i]))\n\t\t\tbreak;\n\n\tif (i == dlen)\n\t\treturn 0;\n\n\t*offset += i;\n\n\treturn try_rfc959(data + i, dlen - i, cmd, 0, offset);\n}\n\n \nstatic int get_port(const char *data, int start, size_t dlen, char delim,\n\t\t    __be16 *port)\n{\n\tu_int16_t tmp_port = 0;\n\tint i;\n\n\tfor (i = start; i < dlen; i++) {\n\t\t \n\t\tif (data[i] == delim) {\n\t\t\tif (tmp_port == 0)\n\t\t\t\tbreak;\n\t\t\t*port = htons(tmp_port);\n\t\t\tpr_debug(\"get_port: return %d\\n\", tmp_port);\n\t\t\treturn i + 1;\n\t\t}\n\t\telse if (data[i] >= '0' && data[i] <= '9')\n\t\t\ttmp_port = tmp_port*10 + data[i] - '0';\n\t\telse {  \n\t\t\tpr_debug(\"get_port: invalid char.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int try_eprt(const char *data, size_t dlen, struct nf_conntrack_man *cmd,\n\t\t    char term, unsigned int *offset)\n{\n\tchar delim;\n\tint length;\n\n\t \n\tif (dlen <= 3) {\n\t\tpr_debug(\"EPRT: too short\\n\");\n\t\treturn 0;\n\t}\n\tdelim = data[0];\n\tif (isdigit(delim) || delim < 33 || delim > 126 || data[2] != delim) {\n\t\tpr_debug(\"try_eprt: invalid delimiter.\\n\");\n\t\treturn 0;\n\t}\n\n\tif ((cmd->l3num == PF_INET && data[1] != '1') ||\n\t    (cmd->l3num == PF_INET6 && data[1] != '2')) {\n\t\tpr_debug(\"EPRT: invalid protocol number.\\n\");\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"EPRT: Got %c%c%c\\n\", delim, data[1], delim);\n\n\tif (data[1] == '1') {\n\t\tu_int32_t array[4];\n\n\t\t \n\t\tlength = try_number(data + 3, dlen - 3, array, 4, '.', delim);\n\t\tif (length != 0)\n\t\t\tcmd->u3.ip = htonl((array[0] << 24) | (array[1] << 16)\n\t\t\t\t\t   | (array[2] << 8) | array[3]);\n\t} else {\n\t\t \n\t\tlength = get_ipv6_addr(data + 3, dlen - 3,\n\t\t\t\t       (struct in6_addr *)cmd->u3.ip6, delim);\n\t}\n\n\tif (length == 0)\n\t\treturn 0;\n\tpr_debug(\"EPRT: Got IP address!\\n\");\n\t \n\treturn get_port(data, 3 + length + 1, dlen, delim, &cmd->u.tcp.port);\n}\n\n \nstatic int try_epsv_response(const char *data, size_t dlen,\n\t\t\t     struct nf_conntrack_man *cmd, char term,\n\t\t\t     unsigned int *offset)\n{\n\tchar delim;\n\n\t \n\tif (dlen <= 3) return 0;\n\tdelim = data[0];\n\tif (isdigit(delim) || delim < 33 || delim > 126 ||\n\t    data[1] != delim || data[2] != delim)\n\t\treturn 0;\n\n\treturn get_port(data, 3, dlen, delim, &cmd->u.tcp.port);\n}\n\n \nstatic int find_pattern(const char *data, size_t dlen,\n\t\t\tconst char *pattern, size_t plen,\n\t\t\tchar skip, char term,\n\t\t\tunsigned int *numoff,\n\t\t\tunsigned int *numlen,\n\t\t\tstruct nf_conntrack_man *cmd,\n\t\t\tint (*getnum)(const char *, size_t,\n\t\t\t\t      struct nf_conntrack_man *, char,\n\t\t\t\t      unsigned int *))\n{\n\tsize_t i = plen;\n\n\tpr_debug(\"find_pattern `%s': dlen = %zu\\n\", pattern, dlen);\n\n\tif (dlen <= plen) {\n\t\t \n\t\tif (strncasecmp(data, pattern, dlen) == 0)\n\t\t\treturn -1;\n\t\telse return 0;\n\t}\n\n\tif (strncasecmp(data, pattern, plen) != 0)\n\t\treturn 0;\n\n\tpr_debug(\"Pattern matches!\\n\");\n\t \n\tif (skip) {\n\t\tfor (i = plen; data[i] != skip; i++)\n\t\t\tif (i == dlen - 1) return -1;\n\n\t\t \n\t\ti++;\n\t}\n\n\tpr_debug(\"Skipped up to 0x%hhx delimiter!\\n\", skip);\n\n\t*numoff = i;\n\t*numlen = getnum(data + i, dlen - i, cmd, term, numoff);\n\tif (!*numlen)\n\t\treturn -1;\n\n\tpr_debug(\"Match succeeded!\\n\");\n\treturn 1;\n}\n\n \nstatic int find_nl_seq(u32 seq, const struct nf_ct_ftp_master *info, int dir)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < info->seq_aft_nl_num[dir]; i++)\n\t\tif (info->seq_aft_nl[dir][i] == seq)\n\t\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic void update_nl_seq(struct nf_conn *ct, u32 nl_seq,\n\t\t\t  struct nf_ct_ftp_master *info, int dir,\n\t\t\t  struct sk_buff *skb)\n{\n\tunsigned int i, oldest;\n\n\t \n\tfor (i = 0; i < info->seq_aft_nl_num[dir]; i++) {\n\t\tif (info->seq_aft_nl[dir][i] == nl_seq)\n\t\t\treturn;\n\t}\n\n\tif (info->seq_aft_nl_num[dir] < NUM_SEQ_TO_REMEMBER) {\n\t\tinfo->seq_aft_nl[dir][info->seq_aft_nl_num[dir]++] = nl_seq;\n\t} else {\n\t\tif (before(info->seq_aft_nl[dir][0], info->seq_aft_nl[dir][1]))\n\t\t\toldest = 0;\n\t\telse\n\t\t\toldest = 1;\n\n\t\tif (after(nl_seq, info->seq_aft_nl[dir][oldest]))\n\t\t\tinfo->seq_aft_nl[dir][oldest] = nl_seq;\n\t}\n}\n\nstatic int help(struct sk_buff *skb,\n\t\tunsigned int protoff,\n\t\tstruct nf_conn *ct,\n\t\tenum ip_conntrack_info ctinfo)\n{\n\tunsigned int dataoff, datalen;\n\tconst struct tcphdr *th;\n\tstruct tcphdr _tcph;\n\tconst char *fb_ptr;\n\tint ret;\n\tu32 seq;\n\tint dir = CTINFO2DIR(ctinfo);\n\tunsigned int matchlen, matchoff;\n\tstruct nf_ct_ftp_master *ct_ftp_info = nfct_help_data(ct);\n\tstruct nf_conntrack_expect *exp;\n\tunion nf_inet_addr *daddr;\n\tstruct nf_conntrack_man cmd = {};\n\tunsigned int i;\n\tint found = 0, ends_in_nl;\n\ttypeof(nf_nat_ftp_hook) nf_nat_ftp;\n\n\t \n\tif (ctinfo != IP_CT_ESTABLISHED &&\n\t    ctinfo != IP_CT_ESTABLISHED_REPLY) {\n\t\tpr_debug(\"ftp: Conntrackinfo = %u\\n\", ctinfo);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tif (unlikely(skb_linearize(skb)))\n\t\treturn NF_DROP;\n\n\tth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\n\tif (th == NULL)\n\t\treturn NF_ACCEPT;\n\n\tdataoff = protoff + th->doff * 4;\n\t \n\tif (dataoff >= skb->len) {\n\t\tpr_debug(\"ftp: dataoff(%u) >= skblen(%u)\\n\", dataoff,\n\t\t\t skb->len);\n\t\treturn NF_ACCEPT;\n\t}\n\tdatalen = skb->len - dataoff;\n\n\t \n\tspin_lock_bh(&nf_ftp_lock);\n\tfb_ptr = skb->data + dataoff;\n\n\tends_in_nl = (fb_ptr[datalen - 1] == '\\n');\n\tseq = ntohl(th->seq) + datalen;\n\n\t \n\tif (!find_nl_seq(ntohl(th->seq), ct_ftp_info, dir)) {\n\t\t \n\t\tif (unlikely(ct_ftp_info->flags[dir] & NF_CT_FTP_SEQ_PICKUP)) {\n\t\t\tct_ftp_info->flags[dir] ^= NF_CT_FTP_SEQ_PICKUP;\n\t\t\tgoto skip_nl_seq;\n\t\t}\n\n\t\t \n\t\tpr_debug(\"nf_conntrack_ftp: wrong seq pos %s(%u) or %s(%u)\\n\",\n\t\t\t ct_ftp_info->seq_aft_nl_num[dir] > 0 ? \"\" : \"(UNSET)\",\n\t\t\t ct_ftp_info->seq_aft_nl[dir][0],\n\t\t\t ct_ftp_info->seq_aft_nl_num[dir] > 1 ? \"\" : \"(UNSET)\",\n\t\t\t ct_ftp_info->seq_aft_nl[dir][1]);\n\t\tret = NF_ACCEPT;\n\t\tgoto out_update_nl;\n\t}\n\nskip_nl_seq:\n\t \n\tcmd.l3num = nf_ct_l3num(ct);\n\tmemcpy(cmd.u3.all, &ct->tuplehash[dir].tuple.src.u3.all,\n\t       sizeof(cmd.u3.all));\n\n\tfor (i = 0; i < ARRAY_SIZE(search[dir]); i++) {\n\t\tfound = find_pattern(fb_ptr, datalen,\n\t\t\t\t     search[dir][i].pattern,\n\t\t\t\t     search[dir][i].plen,\n\t\t\t\t     search[dir][i].skip,\n\t\t\t\t     search[dir][i].term,\n\t\t\t\t     &matchoff, &matchlen,\n\t\t\t\t     &cmd,\n\t\t\t\t     search[dir][i].getnum);\n\t\tif (found) break;\n\t}\n\tif (found == -1) {\n\t\t \n\t\tnf_ct_helper_log(skb, ct, \"partial matching of `%s'\",\n\t\t\t         search[dir][i].pattern);\n\t\tret = NF_DROP;\n\t\tgoto out;\n\t} else if (found == 0) {  \n\t\tret = NF_ACCEPT;\n\t\tgoto out_update_nl;\n\t}\n\n\tpr_debug(\"conntrack_ftp: match `%.*s' (%u bytes at %u)\\n\",\n\t\t matchlen, fb_ptr + matchoff,\n\t\t matchlen, ntohl(th->seq) + matchoff);\n\n\texp = nf_ct_expect_alloc(ct);\n\tif (exp == NULL) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot alloc expectation\");\n\t\tret = NF_DROP;\n\t\tgoto out;\n\t}\n\n\t \n\tdaddr = &ct->tuplehash[!dir].tuple.dst.u3;\n\n\t \n\tif ((cmd.l3num == nf_ct_l3num(ct)) &&\n\t    memcmp(&cmd.u3.all, &ct->tuplehash[dir].tuple.src.u3.all,\n\t\t     sizeof(cmd.u3.all))) {\n\t\t \n\t\tif (cmd.l3num == PF_INET) {\n\t\t\tpr_debug(\"NOT RECORDING: %pI4 != %pI4\\n\",\n\t\t\t\t &cmd.u3.ip,\n\t\t\t\t &ct->tuplehash[dir].tuple.src.u3.ip);\n\t\t} else {\n\t\t\tpr_debug(\"NOT RECORDING: %pI6 != %pI6\\n\",\n\t\t\t\t cmd.u3.ip6,\n\t\t\t\t ct->tuplehash[dir].tuple.src.u3.ip6);\n\t\t}\n\n\t\t \n\t\tif (!loose) {\n\t\t\tret = NF_ACCEPT;\n\t\t\tgoto out_put_expect;\n\t\t}\n\t\tdaddr = &cmd.u3;\n\t}\n\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, cmd.l3num,\n\t\t\t  &ct->tuplehash[!dir].tuple.src.u3, daddr,\n\t\t\t  IPPROTO_TCP, NULL, &cmd.u.tcp.port);\n\n\t \n\tnf_nat_ftp = rcu_dereference(nf_nat_ftp_hook);\n\tif (nf_nat_ftp && ct->status & IPS_NAT_MASK)\n\t\tret = nf_nat_ftp(skb, ctinfo, search[dir][i].ftptype,\n\t\t\t\t protoff, matchoff, matchlen, exp);\n\telse {\n\t\t \n\t\tif (nf_ct_expect_related(exp, 0) != 0) {\n\t\t\tnf_ct_helper_log(skb, ct, \"cannot add expectation\");\n\t\t\tret = NF_DROP;\n\t\t} else\n\t\t\tret = NF_ACCEPT;\n\t}\n\nout_put_expect:\n\tnf_ct_expect_put(exp);\n\nout_update_nl:\n\t \n\tif (ends_in_nl)\n\t\tupdate_nl_seq(ct, seq, ct_ftp_info, dir, skb);\n out:\n\tspin_unlock_bh(&nf_ftp_lock);\n\treturn ret;\n}\n\nstatic int nf_ct_ftp_from_nlattr(struct nlattr *attr, struct nf_conn *ct)\n{\n\tstruct nf_ct_ftp_master *ftp = nfct_help_data(ct);\n\n\t \n\tftp->flags[IP_CT_DIR_ORIGINAL] |= NF_CT_FTP_SEQ_PICKUP;\n\tftp->flags[IP_CT_DIR_REPLY] |= NF_CT_FTP_SEQ_PICKUP;\n\treturn 0;\n}\n\nstatic struct nf_conntrack_helper ftp[MAX_PORTS * 2] __read_mostly;\n\nstatic const struct nf_conntrack_expect_policy ftp_exp_policy = {\n\t.max_expected\t= 1,\n\t.timeout\t= 5 * 60,\n};\n\nstatic void __exit nf_conntrack_ftp_fini(void)\n{\n\tnf_conntrack_helpers_unregister(ftp, ports_c * 2);\n}\n\nstatic int __init nf_conntrack_ftp_init(void)\n{\n\tint i, ret = 0;\n\n\tNF_CT_HELPER_BUILD_BUG_ON(sizeof(struct nf_ct_ftp_master));\n\n\tif (ports_c == 0)\n\t\tports[ports_c++] = FTP_PORT;\n\n\t \n\tfor (i = 0; i < ports_c; i++) {\n\t\tnf_ct_helper_init(&ftp[2 * i], AF_INET, IPPROTO_TCP,\n\t\t\t\t  HELPER_NAME, FTP_PORT, ports[i], ports[i],\n\t\t\t\t  &ftp_exp_policy, 0, help,\n\t\t\t\t  nf_ct_ftp_from_nlattr, THIS_MODULE);\n\t\tnf_ct_helper_init(&ftp[2 * i + 1], AF_INET6, IPPROTO_TCP,\n\t\t\t\t  HELPER_NAME, FTP_PORT, ports[i], ports[i],\n\t\t\t\t  &ftp_exp_policy, 0, help,\n\t\t\t\t  nf_ct_ftp_from_nlattr, THIS_MODULE);\n\t}\n\n\tret = nf_conntrack_helpers_register(ftp, ports_c * 2);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to register helpers\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nmodule_init(nf_conntrack_ftp_init);\nmodule_exit(nf_conntrack_ftp_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}