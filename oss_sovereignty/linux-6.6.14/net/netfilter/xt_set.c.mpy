{
  "module_name": "xt_set.c",
  "hash_id": "b559ba5b5af5dbd33ad114eb089ab94ceb799f893dbde9b10e2aab193d7cd194",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_set.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/ipset/ip_set.h>\n#include <uapi/linux/netfilter/xt_set.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jozsef Kadlecsik <kadlec@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: IP set match and target module\");\nMODULE_ALIAS(\"xt_SET\");\nMODULE_ALIAS(\"ipt_set\");\nMODULE_ALIAS(\"ip6t_set\");\nMODULE_ALIAS(\"ipt_SET\");\nMODULE_ALIAS(\"ip6t_SET\");\n\nstatic inline int\nmatch_set(ip_set_id_t index, const struct sk_buff *skb,\n\t  const struct xt_action_param *par,\n\t  struct ip_set_adt_opt *opt, int inv)\n{\n\tif (ip_set_test(index, skb, par, opt))\n\t\tinv = !inv;\n\treturn inv;\n}\n\n#define ADT_OPT(n, f, d, fs, cfs, t, p, b, po, bo)\t\\\nstruct ip_set_adt_opt n = {\t\t\t\t\\\n\t.family\t= f,\t\t\t\t\t\\\n\t.dim = d,\t\t\t\t\t\\\n\t.flags = fs,\t\t\t\t\t\\\n\t.cmdflags = cfs,\t\t\t\t\\\n\t.ext.timeout = t,\t\t\t\t\\\n\t.ext.packets = p,\t\t\t\t\\\n\t.ext.bytes = b,\t\t\t\t\t\\\n\t.ext.packets_op = po,\t\t\t\t\\\n\t.ext.bytes_op = bo,\t\t\t\t\\\n}\n\n \n\nstatic bool\nset_match_v0(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_set_info_match_v0 *info = par->matchinfo;\n\n\tADT_OPT(opt, xt_family(par), info->match_set.u.compat.dim,\n\t\tinfo->match_set.u.compat.flags, 0, UINT_MAX,\n\t\t0, 0, 0, 0);\n\n\treturn match_set(info->match_set.index, skb, par, &opt,\n\t\t\t info->match_set.u.compat.flags & IPSET_INV_MATCH);\n}\n\nstatic void\ncompat_flags(struct xt_set_info_v0 *info)\n{\n\tu_int8_t i;\n\n\t \n\tinfo->u.compat.dim = IPSET_DIM_ZERO;\n\tif (info->u.flags[0] & IPSET_MATCH_INV)\n\t\tinfo->u.compat.flags |= IPSET_INV_MATCH;\n\tfor (i = 0; i < IPSET_DIM_MAX - 1 && info->u.flags[i]; i++) {\n\t\tinfo->u.compat.dim++;\n\t\tif (info->u.flags[i] & IPSET_SRC)\n\t\t\tinfo->u.compat.flags |= (1 << info->u.compat.dim);\n\t}\n}\n\nstatic int\nset_match_v0_checkentry(const struct xt_mtchk_param *par)\n{\n\tstruct xt_set_info_match_v0 *info = par->matchinfo;\n\tip_set_id_t index;\n\n\tindex = ip_set_nfnl_get_byindex(par->net, info->match_set.index);\n\n\tif (index == IPSET_INVALID_ID) {\n\t\tpr_info_ratelimited(\"Cannot find set identified by id %u to match\\n\",\n\t\t\t\t    info->match_set.index);\n\t\treturn -ENOENT;\n\t}\n\tif (info->match_set.u.flags[IPSET_DIM_MAX - 1] != 0) {\n\t\tpr_info_ratelimited(\"set match dimension is over the limit!\\n\");\n\t\tip_set_nfnl_put(par->net, info->match_set.index);\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tcompat_flags(&info->match_set);\n\n\treturn 0;\n}\n\nstatic void\nset_match_v0_destroy(const struct xt_mtdtor_param *par)\n{\n\tstruct xt_set_info_match_v0 *info = par->matchinfo;\n\n\tip_set_nfnl_put(par->net, info->match_set.index);\n}\n\n \n\nstatic bool\nset_match_v1(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_set_info_match_v1 *info = par->matchinfo;\n\n\tADT_OPT(opt, xt_family(par), info->match_set.dim,\n\t\tinfo->match_set.flags, 0, UINT_MAX,\n\t\t0, 0, 0, 0);\n\n\tif (opt.flags & IPSET_RETURN_NOMATCH)\n\t\topt.cmdflags |= IPSET_FLAG_RETURN_NOMATCH;\n\n\treturn match_set(info->match_set.index, skb, par, &opt,\n\t\t\t info->match_set.flags & IPSET_INV_MATCH);\n}\n\nstatic int\nset_match_v1_checkentry(const struct xt_mtchk_param *par)\n{\n\tstruct xt_set_info_match_v1 *info = par->matchinfo;\n\tip_set_id_t index;\n\n\tindex = ip_set_nfnl_get_byindex(par->net, info->match_set.index);\n\n\tif (index == IPSET_INVALID_ID) {\n\t\tpr_info_ratelimited(\"Cannot find set identified by id %u to match\\n\",\n\t\t\t\t    info->match_set.index);\n\t\treturn -ENOENT;\n\t}\n\tif (info->match_set.dim > IPSET_DIM_MAX) {\n\t\tpr_info_ratelimited(\"set match dimension is over the limit!\\n\");\n\t\tip_set_nfnl_put(par->net, info->match_set.index);\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nset_match_v1_destroy(const struct xt_mtdtor_param *par)\n{\n\tstruct xt_set_info_match_v1 *info = par->matchinfo;\n\n\tip_set_nfnl_put(par->net, info->match_set.index);\n}\n\n \n\nstatic bool\nset_match_v3(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_set_info_match_v3 *info = par->matchinfo;\n\n\tADT_OPT(opt, xt_family(par), info->match_set.dim,\n\t\tinfo->match_set.flags, info->flags, UINT_MAX,\n\t\tinfo->packets.value, info->bytes.value,\n\t\tinfo->packets.op, info->bytes.op);\n\n\tif (info->packets.op != IPSET_COUNTER_NONE ||\n\t    info->bytes.op != IPSET_COUNTER_NONE)\n\t\topt.cmdflags |= IPSET_FLAG_MATCH_COUNTERS;\n\n\treturn match_set(info->match_set.index, skb, par, &opt,\n\t\t\t info->match_set.flags & IPSET_INV_MATCH);\n}\n\n#define set_match_v3_checkentry\tset_match_v1_checkentry\n#define set_match_v3_destroy\tset_match_v1_destroy\n\n \n\nstatic bool\nset_match_v4(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_set_info_match_v4 *info = par->matchinfo;\n\n\tADT_OPT(opt, xt_family(par), info->match_set.dim,\n\t\tinfo->match_set.flags, info->flags, UINT_MAX,\n\t\tinfo->packets.value, info->bytes.value,\n\t\tinfo->packets.op, info->bytes.op);\n\n\tif (info->packets.op != IPSET_COUNTER_NONE ||\n\t    info->bytes.op != IPSET_COUNTER_NONE)\n\t\topt.cmdflags |= IPSET_FLAG_MATCH_COUNTERS;\n\n\treturn match_set(info->match_set.index, skb, par, &opt,\n\t\t\t info->match_set.flags & IPSET_INV_MATCH);\n}\n\n#define set_match_v4_checkentry\tset_match_v1_checkentry\n#define set_match_v4_destroy\tset_match_v1_destroy\n\n \n\nstatic unsigned int\nset_target_v0(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_set_info_target_v0 *info = par->targinfo;\n\n\tADT_OPT(add_opt, xt_family(par), info->add_set.u.compat.dim,\n\t\tinfo->add_set.u.compat.flags, 0, UINT_MAX,\n\t\t0, 0, 0, 0);\n\tADT_OPT(del_opt, xt_family(par), info->del_set.u.compat.dim,\n\t\tinfo->del_set.u.compat.flags, 0, UINT_MAX,\n\t\t0, 0, 0, 0);\n\n\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\tip_set_add(info->add_set.index, skb, par, &add_opt);\n\tif (info->del_set.index != IPSET_INVALID_ID)\n\t\tip_set_del(info->del_set.index, skb, par, &del_opt);\n\n\treturn XT_CONTINUE;\n}\n\nstatic int\nset_target_v0_checkentry(const struct xt_tgchk_param *par)\n{\n\tstruct xt_set_info_target_v0 *info = par->targinfo;\n\tip_set_id_t index;\n\n\tif (info->add_set.index != IPSET_INVALID_ID) {\n\t\tindex = ip_set_nfnl_get_byindex(par->net, info->add_set.index);\n\t\tif (index == IPSET_INVALID_ID) {\n\t\t\tpr_info_ratelimited(\"Cannot find add_set index %u as target\\n\",\n\t\t\t\t\t    info->add_set.index);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (info->del_set.index != IPSET_INVALID_ID) {\n\t\tindex = ip_set_nfnl_get_byindex(par->net, info->del_set.index);\n\t\tif (index == IPSET_INVALID_ID) {\n\t\t\tpr_info_ratelimited(\"Cannot find del_set index %u as target\\n\",\n\t\t\t\t\t    info->del_set.index);\n\t\t\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\t\t\tip_set_nfnl_put(par->net, info->add_set.index);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tif (info->add_set.u.flags[IPSET_DIM_MAX - 1] != 0 ||\n\t    info->del_set.u.flags[IPSET_DIM_MAX - 1] != 0) {\n\t\tpr_info_ratelimited(\"SET target dimension over the limit!\\n\");\n\t\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\t\tip_set_nfnl_put(par->net, info->add_set.index);\n\t\tif (info->del_set.index != IPSET_INVALID_ID)\n\t\t\tip_set_nfnl_put(par->net, info->del_set.index);\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tcompat_flags(&info->add_set);\n\tcompat_flags(&info->del_set);\n\n\treturn 0;\n}\n\nstatic void\nset_target_v0_destroy(const struct xt_tgdtor_param *par)\n{\n\tconst struct xt_set_info_target_v0 *info = par->targinfo;\n\n\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\tip_set_nfnl_put(par->net, info->add_set.index);\n\tif (info->del_set.index != IPSET_INVALID_ID)\n\t\tip_set_nfnl_put(par->net, info->del_set.index);\n}\n\n \n\nstatic unsigned int\nset_target_v1(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_set_info_target_v1 *info = par->targinfo;\n\n\tADT_OPT(add_opt, xt_family(par), info->add_set.dim,\n\t\tinfo->add_set.flags, 0, UINT_MAX,\n\t\t0, 0, 0, 0);\n\tADT_OPT(del_opt, xt_family(par), info->del_set.dim,\n\t\tinfo->del_set.flags, 0, UINT_MAX,\n\t\t0, 0, 0, 0);\n\n\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\tip_set_add(info->add_set.index, skb, par, &add_opt);\n\tif (info->del_set.index != IPSET_INVALID_ID)\n\t\tip_set_del(info->del_set.index, skb, par, &del_opt);\n\n\treturn XT_CONTINUE;\n}\n\nstatic int\nset_target_v1_checkentry(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_set_info_target_v1 *info = par->targinfo;\n\tip_set_id_t index;\n\n\tif (info->add_set.index != IPSET_INVALID_ID) {\n\t\tindex = ip_set_nfnl_get_byindex(par->net, info->add_set.index);\n\t\tif (index == IPSET_INVALID_ID) {\n\t\t\tpr_info_ratelimited(\"Cannot find add_set index %u as target\\n\",\n\t\t\t\t\t    info->add_set.index);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (info->del_set.index != IPSET_INVALID_ID) {\n\t\tindex = ip_set_nfnl_get_byindex(par->net, info->del_set.index);\n\t\tif (index == IPSET_INVALID_ID) {\n\t\t\tpr_info_ratelimited(\"Cannot find del_set index %u as target\\n\",\n\t\t\t\t\t    info->del_set.index);\n\t\t\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\t\t\tip_set_nfnl_put(par->net, info->add_set.index);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tif (info->add_set.dim > IPSET_DIM_MAX ||\n\t    info->del_set.dim > IPSET_DIM_MAX) {\n\t\tpr_info_ratelimited(\"SET target dimension over the limit!\\n\");\n\t\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\t\tip_set_nfnl_put(par->net, info->add_set.index);\n\t\tif (info->del_set.index != IPSET_INVALID_ID)\n\t\t\tip_set_nfnl_put(par->net, info->del_set.index);\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nset_target_v1_destroy(const struct xt_tgdtor_param *par)\n{\n\tconst struct xt_set_info_target_v1 *info = par->targinfo;\n\n\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\tip_set_nfnl_put(par->net, info->add_set.index);\n\tif (info->del_set.index != IPSET_INVALID_ID)\n\t\tip_set_nfnl_put(par->net, info->del_set.index);\n}\n\n \n\nstatic unsigned int\nset_target_v2(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_set_info_target_v2 *info = par->targinfo;\n\n\tADT_OPT(add_opt, xt_family(par), info->add_set.dim,\n\t\tinfo->add_set.flags, info->flags, info->timeout,\n\t\t0, 0, 0, 0);\n\tADT_OPT(del_opt, xt_family(par), info->del_set.dim,\n\t\tinfo->del_set.flags, 0, UINT_MAX,\n\t\t0, 0, 0, 0);\n\n\t \n\tif (add_opt.ext.timeout != IPSET_NO_TIMEOUT &&\n\t    add_opt.ext.timeout > IPSET_MAX_TIMEOUT)\n\t\tadd_opt.ext.timeout = IPSET_MAX_TIMEOUT;\n\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\tip_set_add(info->add_set.index, skb, par, &add_opt);\n\tif (info->del_set.index != IPSET_INVALID_ID)\n\t\tip_set_del(info->del_set.index, skb, par, &del_opt);\n\n\treturn XT_CONTINUE;\n}\n\n#define set_target_v2_checkentry\tset_target_v1_checkentry\n#define set_target_v2_destroy\t\tset_target_v1_destroy\n\n \n\n#define MOPT(opt, member)\t((opt).ext.skbinfo.member)\n\nstatic unsigned int\nset_target_v3(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_set_info_target_v3 *info = par->targinfo;\n\tint ret;\n\n\tADT_OPT(add_opt, xt_family(par), info->add_set.dim,\n\t\tinfo->add_set.flags, info->flags, info->timeout,\n\t\t0, 0, 0, 0);\n\tADT_OPT(del_opt, xt_family(par), info->del_set.dim,\n\t\tinfo->del_set.flags, 0, UINT_MAX,\n\t\t0, 0, 0, 0);\n\tADT_OPT(map_opt, xt_family(par), info->map_set.dim,\n\t\tinfo->map_set.flags, 0, UINT_MAX,\n\t\t0, 0, 0, 0);\n\n\t \n\tif (add_opt.ext.timeout != IPSET_NO_TIMEOUT &&\n\t    add_opt.ext.timeout > IPSET_MAX_TIMEOUT)\n\t\tadd_opt.ext.timeout = IPSET_MAX_TIMEOUT;\n\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\tip_set_add(info->add_set.index, skb, par, &add_opt);\n\tif (info->del_set.index != IPSET_INVALID_ID)\n\t\tip_set_del(info->del_set.index, skb, par, &del_opt);\n\tif (info->map_set.index != IPSET_INVALID_ID) {\n\t\tmap_opt.cmdflags |= info->flags & (IPSET_FLAG_MAP_SKBMARK |\n\t\t\t\t\t\t   IPSET_FLAG_MAP_SKBPRIO |\n\t\t\t\t\t\t   IPSET_FLAG_MAP_SKBQUEUE);\n\t\tret = match_set(info->map_set.index, skb, par, &map_opt,\n\t\t\t\tinfo->map_set.flags & IPSET_INV_MATCH);\n\t\tif (!ret)\n\t\t\treturn XT_CONTINUE;\n\t\tif (map_opt.cmdflags & IPSET_FLAG_MAP_SKBMARK)\n\t\t\tskb->mark = (skb->mark & ~MOPT(map_opt,skbmarkmask))\n\t\t\t\t    ^ MOPT(map_opt, skbmark);\n\t\tif (map_opt.cmdflags & IPSET_FLAG_MAP_SKBPRIO)\n\t\t\tskb->priority = MOPT(map_opt, skbprio);\n\t\tif ((map_opt.cmdflags & IPSET_FLAG_MAP_SKBQUEUE) &&\n\t\t    skb->dev &&\n\t\t    skb->dev->real_num_tx_queues > MOPT(map_opt, skbqueue))\n\t\t\tskb_set_queue_mapping(skb, MOPT(map_opt, skbqueue));\n\t}\n\treturn XT_CONTINUE;\n}\n\nstatic int\nset_target_v3_checkentry(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_set_info_target_v3 *info = par->targinfo;\n\tip_set_id_t index;\n\tint ret = 0;\n\n\tif (info->add_set.index != IPSET_INVALID_ID) {\n\t\tindex = ip_set_nfnl_get_byindex(par->net,\n\t\t\t\t\t\tinfo->add_set.index);\n\t\tif (index == IPSET_INVALID_ID) {\n\t\t\tpr_info_ratelimited(\"Cannot find add_set index %u as target\\n\",\n\t\t\t\t\t    info->add_set.index);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (info->del_set.index != IPSET_INVALID_ID) {\n\t\tindex = ip_set_nfnl_get_byindex(par->net,\n\t\t\t\t\t\tinfo->del_set.index);\n\t\tif (index == IPSET_INVALID_ID) {\n\t\t\tpr_info_ratelimited(\"Cannot find del_set index %u as target\\n\",\n\t\t\t\t\t    info->del_set.index);\n\t\t\tret = -ENOENT;\n\t\t\tgoto cleanup_add;\n\t\t}\n\t}\n\n\tif (info->map_set.index != IPSET_INVALID_ID) {\n\t\tif (strncmp(par->table, \"mangle\", 7)) {\n\t\t\tpr_info_ratelimited(\"--map-set only usable from mangle table\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto cleanup_del;\n\t\t}\n\t\tif (((info->flags & IPSET_FLAG_MAP_SKBPRIO) |\n\t\t     (info->flags & IPSET_FLAG_MAP_SKBQUEUE)) &&\n\t\t     (par->hook_mask & ~(1 << NF_INET_FORWARD |\n\t\t\t\t\t 1 << NF_INET_LOCAL_OUT |\n\t\t\t\t\t 1 << NF_INET_POST_ROUTING))) {\n\t\t\tpr_info_ratelimited(\"mapping of prio or/and queue is allowed only from OUTPUT/FORWARD/POSTROUTING chains\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto cleanup_del;\n\t\t}\n\t\tindex = ip_set_nfnl_get_byindex(par->net,\n\t\t\t\t\t\tinfo->map_set.index);\n\t\tif (index == IPSET_INVALID_ID) {\n\t\t\tpr_info_ratelimited(\"Cannot find map_set index %u as target\\n\",\n\t\t\t\t\t    info->map_set.index);\n\t\t\tret = -ENOENT;\n\t\t\tgoto cleanup_del;\n\t\t}\n\t}\n\n\tif (info->add_set.dim > IPSET_DIM_MAX ||\n\t    info->del_set.dim > IPSET_DIM_MAX ||\n\t    info->map_set.dim > IPSET_DIM_MAX) {\n\t\tpr_info_ratelimited(\"SET target dimension over the limit!\\n\");\n\t\tret = -ERANGE;\n\t\tgoto cleanup_mark;\n\t}\n\n\treturn 0;\ncleanup_mark:\n\tif (info->map_set.index != IPSET_INVALID_ID)\n\t\tip_set_nfnl_put(par->net, info->map_set.index);\ncleanup_del:\n\tif (info->del_set.index != IPSET_INVALID_ID)\n\t\tip_set_nfnl_put(par->net, info->del_set.index);\ncleanup_add:\n\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\tip_set_nfnl_put(par->net, info->add_set.index);\n\treturn ret;\n}\n\nstatic void\nset_target_v3_destroy(const struct xt_tgdtor_param *par)\n{\n\tconst struct xt_set_info_target_v3 *info = par->targinfo;\n\n\tif (info->add_set.index != IPSET_INVALID_ID)\n\t\tip_set_nfnl_put(par->net, info->add_set.index);\n\tif (info->del_set.index != IPSET_INVALID_ID)\n\t\tip_set_nfnl_put(par->net, info->del_set.index);\n\tif (info->map_set.index != IPSET_INVALID_ID)\n\t\tip_set_nfnl_put(par->net, info->map_set.index);\n}\n\nstatic struct xt_match set_matches[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"set\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.revision\t= 0,\n\t\t.match\t\t= set_match_v0,\n\t\t.matchsize\t= sizeof(struct xt_set_info_match_v0),\n\t\t.checkentry\t= set_match_v0_checkentry,\n\t\t.destroy\t= set_match_v0_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"set\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.revision\t= 1,\n\t\t.match\t\t= set_match_v1,\n\t\t.matchsize\t= sizeof(struct xt_set_info_match_v1),\n\t\t.checkentry\t= set_match_v1_checkentry,\n\t\t.destroy\t= set_match_v1_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"set\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.revision\t= 1,\n\t\t.match\t\t= set_match_v1,\n\t\t.matchsize\t= sizeof(struct xt_set_info_match_v1),\n\t\t.checkentry\t= set_match_v1_checkentry,\n\t\t.destroy\t= set_match_v1_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t \n\t{\n\t\t.name\t\t= \"set\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.revision\t= 2,\n\t\t.match\t\t= set_match_v1,\n\t\t.matchsize\t= sizeof(struct xt_set_info_match_v1),\n\t\t.checkentry\t= set_match_v1_checkentry,\n\t\t.destroy\t= set_match_v1_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"set\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.revision\t= 2,\n\t\t.match\t\t= set_match_v1,\n\t\t.matchsize\t= sizeof(struct xt_set_info_match_v1),\n\t\t.checkentry\t= set_match_v1_checkentry,\n\t\t.destroy\t= set_match_v1_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t \n\t{\n\t\t.name\t\t= \"set\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.revision\t= 3,\n\t\t.match\t\t= set_match_v3,\n\t\t.matchsize\t= sizeof(struct xt_set_info_match_v3),\n\t\t.checkentry\t= set_match_v3_checkentry,\n\t\t.destroy\t= set_match_v3_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"set\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.revision\t= 3,\n\t\t.match\t\t= set_match_v3,\n\t\t.matchsize\t= sizeof(struct xt_set_info_match_v3),\n\t\t.checkentry\t= set_match_v3_checkentry,\n\t\t.destroy\t= set_match_v3_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t \n\t{\n\t\t.name\t\t= \"set\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.revision\t= 4,\n\t\t.match\t\t= set_match_v4,\n\t\t.matchsize\t= sizeof(struct xt_set_info_match_v4),\n\t\t.checkentry\t= set_match_v4_checkentry,\n\t\t.destroy\t= set_match_v4_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"set\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.revision\t= 4,\n\t\t.match\t\t= set_match_v4,\n\t\t.matchsize\t= sizeof(struct xt_set_info_match_v4),\n\t\t.checkentry\t= set_match_v4_checkentry,\n\t\t.destroy\t= set_match_v4_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n};\n\nstatic struct xt_target set_targets[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"SET\",\n\t\t.revision\t= 0,\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.target\t\t= set_target_v0,\n\t\t.targetsize\t= sizeof(struct xt_set_info_target_v0),\n\t\t.checkentry\t= set_target_v0_checkentry,\n\t\t.destroy\t= set_target_v0_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"SET\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.target\t\t= set_target_v1,\n\t\t.targetsize\t= sizeof(struct xt_set_info_target_v1),\n\t\t.checkentry\t= set_target_v1_checkentry,\n\t\t.destroy\t= set_target_v1_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"SET\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.target\t\t= set_target_v1,\n\t\t.targetsize\t= sizeof(struct xt_set_info_target_v1),\n\t\t.checkentry\t= set_target_v1_checkentry,\n\t\t.destroy\t= set_target_v1_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t \n\t{\n\t\t.name\t\t= \"SET\",\n\t\t.revision\t= 2,\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.target\t\t= set_target_v2,\n\t\t.targetsize\t= sizeof(struct xt_set_info_target_v2),\n\t\t.checkentry\t= set_target_v2_checkentry,\n\t\t.destroy\t= set_target_v2_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"SET\",\n\t\t.revision\t= 2,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.target\t\t= set_target_v2,\n\t\t.targetsize\t= sizeof(struct xt_set_info_target_v2),\n\t\t.checkentry\t= set_target_v2_checkentry,\n\t\t.destroy\t= set_target_v2_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t \n\t{\n\t\t.name\t\t= \"SET\",\n\t\t.revision\t= 3,\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.target\t\t= set_target_v3,\n\t\t.targetsize\t= sizeof(struct xt_set_info_target_v3),\n\t\t.checkentry\t= set_target_v3_checkentry,\n\t\t.destroy\t= set_target_v3_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"SET\",\n\t\t.revision\t= 3,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.target\t\t= set_target_v3,\n\t\t.targetsize\t= sizeof(struct xt_set_info_target_v3),\n\t\t.checkentry\t= set_target_v3_checkentry,\n\t\t.destroy\t= set_target_v3_destroy,\n\t\t.me\t\t= THIS_MODULE\n\t},\n};\n\nstatic int __init xt_set_init(void)\n{\n\tint ret = xt_register_matches(set_matches, ARRAY_SIZE(set_matches));\n\n\tif (!ret) {\n\t\tret = xt_register_targets(set_targets,\n\t\t\t\t\t  ARRAY_SIZE(set_targets));\n\t\tif (ret)\n\t\t\txt_unregister_matches(set_matches,\n\t\t\t\t\t      ARRAY_SIZE(set_matches));\n\t}\n\treturn ret;\n}\n\nstatic void __exit xt_set_fini(void)\n{\n\txt_unregister_matches(set_matches, ARRAY_SIZE(set_matches));\n\txt_unregister_targets(set_targets, ARRAY_SIZE(set_targets));\n}\n\nmodule_init(xt_set_init);\nmodule_exit(xt_set_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}