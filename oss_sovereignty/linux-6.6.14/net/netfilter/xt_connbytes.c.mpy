{
  "module_name": "xt_connbytes.c",
  "hash_id": "47eaa2c511d7f9d5eef2d6e67d38c3fac72f4997d3fc366fc463172d1fa5162e",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_connbytes.c",
  "human_readable_source": " \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/skbuff.h>\n#include <linux/math64.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_connbytes.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_acct.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: Number of packets/bytes per connection matching\");\nMODULE_ALIAS(\"ipt_connbytes\");\nMODULE_ALIAS(\"ip6t_connbytes\");\n\nstatic bool\nconnbytes_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_connbytes_info *sinfo = par->matchinfo;\n\tconst struct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\tu_int64_t what = 0;\t \n\tu_int64_t bytes = 0;\n\tu_int64_t pkts = 0;\n\tconst struct nf_conn_acct *acct;\n\tconst struct nf_conn_counter *counters;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (!ct)\n\t\treturn false;\n\n\tacct = nf_conn_acct_find(ct);\n\tif (!acct)\n\t\treturn false;\n\n\tcounters = acct->counter;\n\tswitch (sinfo->what) {\n\tcase XT_CONNBYTES_PKTS:\n\t\tswitch (sinfo->direction) {\n\t\tcase XT_CONNBYTES_DIR_ORIGINAL:\n\t\t\twhat = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].packets);\n\t\t\tbreak;\n\t\tcase XT_CONNBYTES_DIR_REPLY:\n\t\t\twhat = atomic64_read(&counters[IP_CT_DIR_REPLY].packets);\n\t\t\tbreak;\n\t\tcase XT_CONNBYTES_DIR_BOTH:\n\t\t\twhat = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].packets);\n\t\t\twhat += atomic64_read(&counters[IP_CT_DIR_REPLY].packets);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase XT_CONNBYTES_BYTES:\n\t\tswitch (sinfo->direction) {\n\t\tcase XT_CONNBYTES_DIR_ORIGINAL:\n\t\t\twhat = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].bytes);\n\t\t\tbreak;\n\t\tcase XT_CONNBYTES_DIR_REPLY:\n\t\t\twhat = atomic64_read(&counters[IP_CT_DIR_REPLY].bytes);\n\t\t\tbreak;\n\t\tcase XT_CONNBYTES_DIR_BOTH:\n\t\t\twhat = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].bytes);\n\t\t\twhat += atomic64_read(&counters[IP_CT_DIR_REPLY].bytes);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase XT_CONNBYTES_AVGPKT:\n\t\tswitch (sinfo->direction) {\n\t\tcase XT_CONNBYTES_DIR_ORIGINAL:\n\t\t\tbytes = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].bytes);\n\t\t\tpkts  = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].packets);\n\t\t\tbreak;\n\t\tcase XT_CONNBYTES_DIR_REPLY:\n\t\t\tbytes = atomic64_read(&counters[IP_CT_DIR_REPLY].bytes);\n\t\t\tpkts  = atomic64_read(&counters[IP_CT_DIR_REPLY].packets);\n\t\t\tbreak;\n\t\tcase XT_CONNBYTES_DIR_BOTH:\n\t\t\tbytes = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].bytes) +\n\t\t\t\tatomic64_read(&counters[IP_CT_DIR_REPLY].bytes);\n\t\t\tpkts  = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].packets) +\n\t\t\t\tatomic64_read(&counters[IP_CT_DIR_REPLY].packets);\n\t\t\tbreak;\n\t\t}\n\t\tif (pkts != 0)\n\t\t\twhat = div64_u64(bytes, pkts);\n\t\tbreak;\n\t}\n\n\tif (sinfo->count.to >= sinfo->count.from)\n\t\treturn what <= sinfo->count.to && what >= sinfo->count.from;\n\telse  \n\t\treturn what < sinfo->count.to || what > sinfo->count.from;\n}\n\nstatic int connbytes_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_connbytes_info *sinfo = par->matchinfo;\n\tint ret;\n\n\tif (sinfo->what != XT_CONNBYTES_PKTS &&\n\t    sinfo->what != XT_CONNBYTES_BYTES &&\n\t    sinfo->what != XT_CONNBYTES_AVGPKT)\n\t\treturn -EINVAL;\n\n\tif (sinfo->direction != XT_CONNBYTES_DIR_ORIGINAL &&\n\t    sinfo->direction != XT_CONNBYTES_DIR_REPLY &&\n\t    sinfo->direction != XT_CONNBYTES_DIR_BOTH)\n\t\treturn -EINVAL;\n\n\tret = nf_ct_netns_get(par->net, par->family);\n\tif (ret < 0)\n\t\tpr_info_ratelimited(\"cannot load conntrack support for proto=%u\\n\",\n\t\t\t\t    par->family);\n\n\t \n\tif (!nf_ct_acct_enabled(par->net)) {\n\t\tpr_warn(\"Forcing CT accounting to be enabled\\n\");\n\t\tnf_ct_set_acct(par->net, true);\n\t}\n\n\treturn ret;\n}\n\nstatic void connbytes_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tnf_ct_netns_put(par->net, par->family);\n}\n\nstatic struct xt_match connbytes_mt_reg __read_mostly = {\n\t.name       = \"connbytes\",\n\t.revision   = 0,\n\t.family     = NFPROTO_UNSPEC,\n\t.checkentry = connbytes_mt_check,\n\t.match      = connbytes_mt,\n\t.destroy    = connbytes_mt_destroy,\n\t.matchsize  = sizeof(struct xt_connbytes_info),\n\t.me         = THIS_MODULE,\n};\n\nstatic int __init connbytes_mt_init(void)\n{\n\treturn xt_register_match(&connbytes_mt_reg);\n}\n\nstatic void __exit connbytes_mt_exit(void)\n{\n\txt_unregister_match(&connbytes_mt_reg);\n}\n\nmodule_init(connbytes_mt_init);\nmodule_exit(connbytes_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}