{
  "module_name": "nft_log.c",
  "hash_id": "41910b251826d79dc52784c36068609812262a3eea523e3e5230b57728c9d1a3",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_log.c",
  "human_readable_source": "\n \n\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_log.h>\n#include <linux/netdevice.h>\n\nstatic const char *nft_log_null_prefix = \"\";\n\nstruct nft_log {\n\tstruct nf_loginfo\tloginfo;\n\tchar\t\t\t*prefix;\n};\n\nstatic bool audit_ip4(struct audit_buffer *ab, struct sk_buff *skb)\n{\n\tstruct iphdr _iph;\n\tconst struct iphdr *ih;\n\n\tih = skb_header_pointer(skb, skb_network_offset(skb), sizeof(_iph), &_iph);\n\tif (!ih)\n\t\treturn false;\n\n\taudit_log_format(ab, \" saddr=%pI4 daddr=%pI4 proto=%hhu\",\n\t\t\t &ih->saddr, &ih->daddr, ih->protocol);\n\n\treturn true;\n}\n\nstatic bool audit_ip6(struct audit_buffer *ab, struct sk_buff *skb)\n{\n\tstruct ipv6hdr _ip6h;\n\tconst struct ipv6hdr *ih;\n\tu8 nexthdr;\n\t__be16 frag_off;\n\n\tih = skb_header_pointer(skb, skb_network_offset(skb), sizeof(_ip6h), &_ip6h);\n\tif (!ih)\n\t\treturn false;\n\n\tnexthdr = ih->nexthdr;\n\tipv6_skip_exthdr(skb, skb_network_offset(skb) + sizeof(_ip6h), &nexthdr, &frag_off);\n\n\taudit_log_format(ab, \" saddr=%pI6c daddr=%pI6c proto=%hhu\",\n\t\t\t &ih->saddr, &ih->daddr, nexthdr);\n\n\treturn true;\n}\n\nstatic void nft_log_eval_audit(const struct nft_pktinfo *pkt)\n{\n\tstruct sk_buff *skb = pkt->skb;\n\tstruct audit_buffer *ab;\n\tint fam = -1;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_ATOMIC, AUDIT_NETFILTER_PKT);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"mark=%#x\", skb->mark);\n\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_BRIDGE:\n\t\tswitch (eth_hdr(skb)->h_proto) {\n\t\tcase htons(ETH_P_IP):\n\t\t\tfam = audit_ip4(ab, skb) ? NFPROTO_IPV4 : -1;\n\t\t\tbreak;\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tfam = audit_ip6(ab, skb) ? NFPROTO_IPV6 : -1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NFPROTO_IPV4:\n\t\tfam = audit_ip4(ab, skb) ? NFPROTO_IPV4 : -1;\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tfam = audit_ip6(ab, skb) ? NFPROTO_IPV6 : -1;\n\t\tbreak;\n\t}\n\n\tif (fam == -1)\n\t\taudit_log_format(ab, \" saddr=? daddr=? proto=-1\");\n\n\taudit_log_end(ab);\n}\n\nstatic void nft_log_eval(const struct nft_expr *expr,\n\t\t\t struct nft_regs *regs,\n\t\t\t const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_log *priv = nft_expr_priv(expr);\n\n\tif (priv->loginfo.type == NF_LOG_TYPE_LOG &&\n\t    priv->loginfo.u.log.level == NFT_LOGLEVEL_AUDIT) {\n\t\tnft_log_eval_audit(pkt);\n\t\treturn;\n\t}\n\n\tnf_log_packet(nft_net(pkt), nft_pf(pkt), nft_hook(pkt), pkt->skb,\n\t\t      nft_in(pkt), nft_out(pkt), &priv->loginfo, \"%s\",\n\t\t      priv->prefix);\n}\n\nstatic const struct nla_policy nft_log_policy[NFTA_LOG_MAX + 1] = {\n\t[NFTA_LOG_GROUP]\t= { .type = NLA_U16 },\n\t[NFTA_LOG_PREFIX]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NF_LOG_PREFIXLEN - 1 },\n\t[NFTA_LOG_SNAPLEN]\t= { .type = NLA_U32 },\n\t[NFTA_LOG_QTHRESHOLD]\t= { .type = NLA_U16 },\n\t[NFTA_LOG_LEVEL]\t= { .type = NLA_U32 },\n\t[NFTA_LOG_FLAGS]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_log_modprobe(struct net *net, enum nf_log_type t)\n{\n\tswitch (t) {\n\tcase NF_LOG_TYPE_LOG:\n\t\treturn nft_request_module(net, \"%s\", \"nf_log_syslog\");\n\tcase NF_LOG_TYPE_ULOG:\n\t\treturn nft_request_module(net, \"%s\", \"nfnetlink_log\");\n\tcase NF_LOG_TYPE_MAX:\n\t\tbreak;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int nft_log_init(const struct nft_ctx *ctx,\n\t\t\tconst struct nft_expr *expr,\n\t\t\tconst struct nlattr * const tb[])\n{\n\tstruct nft_log *priv = nft_expr_priv(expr);\n\tstruct nf_loginfo *li = &priv->loginfo;\n\tconst struct nlattr *nla;\n\tint err;\n\n\tli->type = NF_LOG_TYPE_LOG;\n\tif (tb[NFTA_LOG_LEVEL] != NULL &&\n\t    tb[NFTA_LOG_GROUP] != NULL)\n\t\treturn -EINVAL;\n\tif (tb[NFTA_LOG_GROUP] != NULL) {\n\t\tli->type = NF_LOG_TYPE_ULOG;\n\t\tif (tb[NFTA_LOG_FLAGS] != NULL)\n\t\t\treturn -EINVAL;\n\t}\n\n\tnla = tb[NFTA_LOG_PREFIX];\n\tif (nla != NULL) {\n\t\tpriv->prefix = kmalloc(nla_len(nla) + 1, GFP_KERNEL);\n\t\tif (priv->prefix == NULL)\n\t\t\treturn -ENOMEM;\n\t\tnla_strscpy(priv->prefix, nla, nla_len(nla) + 1);\n\t} else {\n\t\tpriv->prefix = (char *)nft_log_null_prefix;\n\t}\n\n\tswitch (li->type) {\n\tcase NF_LOG_TYPE_LOG:\n\t\tif (tb[NFTA_LOG_LEVEL] != NULL) {\n\t\t\tli->u.log.level =\n\t\t\t\tntohl(nla_get_be32(tb[NFTA_LOG_LEVEL]));\n\t\t} else {\n\t\t\tli->u.log.level = NFT_LOGLEVEL_WARNING;\n\t\t}\n\t\tif (li->u.log.level > NFT_LOGLEVEL_AUDIT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err1;\n\t\t}\n\n\t\tif (tb[NFTA_LOG_FLAGS] != NULL) {\n\t\t\tli->u.log.logflags =\n\t\t\t\tntohl(nla_get_be32(tb[NFTA_LOG_FLAGS]));\n\t\t\tif (li->u.log.logflags & ~NF_LOG_MASK) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NF_LOG_TYPE_ULOG:\n\t\tli->u.ulog.group = ntohs(nla_get_be16(tb[NFTA_LOG_GROUP]));\n\t\tif (tb[NFTA_LOG_SNAPLEN] != NULL) {\n\t\t\tli->u.ulog.flags |= NF_LOG_F_COPY_LEN;\n\t\t\tli->u.ulog.copy_len =\n\t\t\t\tntohl(nla_get_be32(tb[NFTA_LOG_SNAPLEN]));\n\t\t}\n\t\tif (tb[NFTA_LOG_QTHRESHOLD] != NULL) {\n\t\t\tli->u.ulog.qthreshold =\n\t\t\t\tntohs(nla_get_be16(tb[NFTA_LOG_QTHRESHOLD]));\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (li->u.log.level == NFT_LOGLEVEL_AUDIT)\n\t\treturn 0;\n\n\terr = nf_logger_find_get(ctx->family, li->type);\n\tif (err < 0) {\n\t\tif (nft_log_modprobe(ctx->net, li->type) == -EAGAIN)\n\t\t\terr = -EAGAIN;\n\n\t\tgoto err1;\n\t}\n\n\treturn 0;\n\nerr1:\n\tif (priv->prefix != nft_log_null_prefix)\n\t\tkfree(priv->prefix);\n\treturn err;\n}\n\nstatic void nft_log_destroy(const struct nft_ctx *ctx,\n\t\t\t    const struct nft_expr *expr)\n{\n\tstruct nft_log *priv = nft_expr_priv(expr);\n\tstruct nf_loginfo *li = &priv->loginfo;\n\n\tif (priv->prefix != nft_log_null_prefix)\n\t\tkfree(priv->prefix);\n\n\tif (li->u.log.level == NFT_LOGLEVEL_AUDIT)\n\t\treturn;\n\n\tnf_logger_put(ctx->family, li->type);\n}\n\nstatic int nft_log_dump(struct sk_buff *skb,\n\t\t\tconst struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_log *priv = nft_expr_priv(expr);\n\tconst struct nf_loginfo *li = &priv->loginfo;\n\n\tif (priv->prefix != nft_log_null_prefix)\n\t\tif (nla_put_string(skb, NFTA_LOG_PREFIX, priv->prefix))\n\t\t\tgoto nla_put_failure;\n\tswitch (li->type) {\n\tcase NF_LOG_TYPE_LOG:\n\t\tif (nla_put_be32(skb, NFTA_LOG_LEVEL, htonl(li->u.log.level)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (li->u.log.logflags) {\n\t\t\tif (nla_put_be32(skb, NFTA_LOG_FLAGS,\n\t\t\t\t\t htonl(li->u.log.logflags)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tbreak;\n\tcase NF_LOG_TYPE_ULOG:\n\t\tif (nla_put_be16(skb, NFTA_LOG_GROUP, htons(li->u.ulog.group)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (li->u.ulog.flags & NF_LOG_F_COPY_LEN) {\n\t\t\tif (nla_put_be32(skb, NFTA_LOG_SNAPLEN,\n\t\t\t\t\t htonl(li->u.ulog.copy_len)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tif (li->u.ulog.qthreshold) {\n\t\t\tif (nla_put_be16(skb, NFTA_LOG_QTHRESHOLD,\n\t\t\t\t\t htons(li->u.ulog.qthreshold)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic struct nft_expr_type nft_log_type;\nstatic const struct nft_expr_ops nft_log_ops = {\n\t.type\t\t= &nft_log_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_log)),\n\t.eval\t\t= nft_log_eval,\n\t.init\t\t= nft_log_init,\n\t.destroy\t= nft_log_destroy,\n\t.dump\t\t= nft_log_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_log_type __read_mostly = {\n\t.name\t\t= \"log\",\n\t.ops\t\t= &nft_log_ops,\n\t.policy\t\t= nft_log_policy,\n\t.maxattr\t= NFTA_LOG_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_log_module_init(void)\n{\n\treturn nft_register_expr(&nft_log_type);\n}\n\nstatic void __exit nft_log_module_exit(void)\n{\n\tnft_unregister_expr(&nft_log_type);\n}\n\nmodule_init(nft_log_module_init);\nmodule_exit(nft_log_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_ALIAS_NFT_EXPR(\"log\");\nMODULE_DESCRIPTION(\"Netfilter nf_tables log module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}