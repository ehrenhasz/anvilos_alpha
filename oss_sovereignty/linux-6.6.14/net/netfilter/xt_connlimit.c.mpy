{
  "module_name": "xt_connlimit.c",
  "hash_id": "efc0665ab16d066422b595aa2e015d6afcbd893a0f77632ae8e3a3e7134512ec",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_connlimit.c",
  "human_readable_source": " \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_connlimit.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_tuple.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/nf_conntrack_count.h>\n\nstatic bool\nconnlimit_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tstruct net *net = xt_net(par);\n\tconst struct xt_connlimit_info *info = par->matchinfo;\n\tstruct nf_conntrack_tuple tuple;\n\tconst struct nf_conntrack_tuple *tuple_ptr = &tuple;\n\tconst struct nf_conntrack_zone *zone = &nf_ct_zone_dflt;\n\tenum ip_conntrack_info ctinfo;\n\tconst struct nf_conn *ct;\n\tunsigned int connections;\n\tu32 key[5];\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct != NULL) {\n\t\ttuple_ptr = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\t\tzone = nf_ct_zone(ct);\n\t} else if (!nf_ct_get_tuplepr(skb, skb_network_offset(skb),\n\t\t\t\t      xt_family(par), net, &tuple)) {\n\t\tgoto hotdrop;\n\t}\n\n\tif (xt_family(par) == NFPROTO_IPV6) {\n\t\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\t\tunion nf_inet_addr addr;\n\t\tunsigned int i;\n\n\t\tmemcpy(&addr.ip6, (info->flags & XT_CONNLIMIT_DADDR) ?\n\t\t       &iph->daddr : &iph->saddr, sizeof(addr.ip6));\n\n\t\tfor (i = 0; i < ARRAY_SIZE(addr.ip6); ++i)\n\t\t\taddr.ip6[i] &= info->mask.ip6[i];\n\t\tmemcpy(key, &addr, sizeof(addr.ip6));\n\t\tkey[4] = zone->id;\n\t} else {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\n\t\tkey[0] = (info->flags & XT_CONNLIMIT_DADDR) ?\n\t\t\t (__force __u32)iph->daddr : (__force __u32)iph->saddr;\n\t\tkey[0] &= (__force __u32)info->mask.ip;\n\t\tkey[1] = zone->id;\n\t}\n\n\tconnections = nf_conncount_count(net, info->data, key, tuple_ptr,\n\t\t\t\t\t zone);\n\tif (connections == 0)\n\t\t \n\t\tgoto hotdrop;\n\n\treturn (connections > info->limit) ^ !!(info->flags & XT_CONNLIMIT_INVERT);\n\n hotdrop:\n\tpar->hotdrop = true;\n\treturn false;\n}\n\nstatic int connlimit_mt_check(const struct xt_mtchk_param *par)\n{\n\tstruct xt_connlimit_info *info = par->matchinfo;\n\tunsigned int keylen;\n\n\tkeylen = sizeof(u32);\n\tif (par->family == NFPROTO_IPV6)\n\t\tkeylen += sizeof(struct in6_addr);\n\telse\n\t\tkeylen += sizeof(struct in_addr);\n\n\t \n\tinfo->data = nf_conncount_init(par->net, par->family, keylen);\n\n\treturn PTR_ERR_OR_ZERO(info->data);\n}\n\nstatic void connlimit_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tconst struct xt_connlimit_info *info = par->matchinfo;\n\n\tnf_conncount_destroy(par->net, par->family, info->data);\n}\n\nstatic struct xt_match connlimit_mt_reg __read_mostly = {\n\t.name       = \"connlimit\",\n\t.revision   = 1,\n\t.family     = NFPROTO_UNSPEC,\n\t.checkentry = connlimit_mt_check,\n\t.match      = connlimit_mt,\n\t.matchsize  = sizeof(struct xt_connlimit_info),\n\t.usersize   = offsetof(struct xt_connlimit_info, data),\n\t.destroy    = connlimit_mt_destroy,\n\t.me         = THIS_MODULE,\n};\n\nstatic int __init connlimit_mt_init(void)\n{\n\treturn xt_register_match(&connlimit_mt_reg);\n}\n\nstatic void __exit connlimit_mt_exit(void)\n{\n\txt_unregister_match(&connlimit_mt_reg);\n}\n\nmodule_init(connlimit_mt_init);\nmodule_exit(connlimit_mt_exit);\nMODULE_AUTHOR(\"Jan Engelhardt <jengelh@medozas.de>\");\nMODULE_DESCRIPTION(\"Xtables: Number of connections matching\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ipt_connlimit\");\nMODULE_ALIAS(\"ip6t_connlimit\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}