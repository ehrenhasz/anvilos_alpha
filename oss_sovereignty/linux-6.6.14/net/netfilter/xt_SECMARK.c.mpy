{
  "module_name": "xt_SECMARK.c",
  "hash_id": "9d9b04decbe1f25c4fb0c0ec5ae80263e2b1dd37d99e07cad26ca9b562c813f8",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_SECMARK.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_SECMARK.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Morris <jmorris@redhat.com>\");\nMODULE_DESCRIPTION(\"Xtables: packet security mark modification\");\nMODULE_ALIAS(\"ipt_SECMARK\");\nMODULE_ALIAS(\"ip6t_SECMARK\");\n\nstatic u8 mode;\n\nstatic unsigned int\nsecmark_tg(struct sk_buff *skb, const struct xt_secmark_target_info_v1 *info)\n{\n\tu32 secmark = 0;\n\n\tswitch (mode) {\n\tcase SECMARK_MODE_SEL:\n\t\tsecmark = info->secid;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tskb->secmark = secmark;\n\treturn XT_CONTINUE;\n}\n\nstatic int checkentry_lsm(struct xt_secmark_target_info_v1 *info)\n{\n\tint err;\n\n\tinfo->secctx[SECMARK_SECCTX_MAX - 1] = '\\0';\n\tinfo->secid = 0;\n\n\terr = security_secctx_to_secid(info->secctx, strlen(info->secctx),\n\t\t\t\t       &info->secid);\n\tif (err) {\n\t\tif (err == -EINVAL)\n\t\t\tpr_info_ratelimited(\"invalid security context \\'%s\\'\\n\",\n\t\t\t\t\t    info->secctx);\n\t\treturn err;\n\t}\n\n\tif (!info->secid) {\n\t\tpr_info_ratelimited(\"unable to map security context \\'%s\\'\\n\",\n\t\t\t\t    info->secctx);\n\t\treturn -ENOENT;\n\t}\n\n\terr = security_secmark_relabel_packet(info->secid);\n\tif (err) {\n\t\tpr_info_ratelimited(\"unable to obtain relabeling permission\\n\");\n\t\treturn err;\n\t}\n\n\tsecurity_secmark_refcount_inc();\n\treturn 0;\n}\n\nstatic int\nsecmark_tg_check(const char *table, struct xt_secmark_target_info_v1 *info)\n{\n\tint err;\n\n\tif (strcmp(table, \"mangle\") != 0 &&\n\t    strcmp(table, \"security\") != 0) {\n\t\tpr_info_ratelimited(\"only valid in \\'mangle\\' or \\'security\\' table, not \\'%s\\'\\n\",\n\t\t\t\t    table);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode && mode != info->mode) {\n\t\tpr_info_ratelimited(\"mode already set to %hu cannot mix with rules for mode %hu\\n\",\n\t\t\t\t    mode, info->mode);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (info->mode) {\n\tcase SECMARK_MODE_SEL:\n\t\tbreak;\n\tdefault:\n\t\tpr_info_ratelimited(\"invalid mode: %hu\\n\", info->mode);\n\t\treturn -EINVAL;\n\t}\n\n\terr = checkentry_lsm(info);\n\tif (err)\n\t\treturn err;\n\n\tif (!mode)\n\t\tmode = info->mode;\n\treturn 0;\n}\n\nstatic void secmark_tg_destroy(const struct xt_tgdtor_param *par)\n{\n\tswitch (mode) {\n\tcase SECMARK_MODE_SEL:\n\t\tsecurity_secmark_refcount_dec();\n\t}\n}\n\nstatic int secmark_tg_check_v0(const struct xt_tgchk_param *par)\n{\n\tstruct xt_secmark_target_info *info = par->targinfo;\n\tstruct xt_secmark_target_info_v1 newinfo = {\n\t\t.mode\t= info->mode,\n\t};\n\tint ret;\n\n\tmemcpy(newinfo.secctx, info->secctx, SECMARK_SECCTX_MAX);\n\n\tret = secmark_tg_check(par->table, &newinfo);\n\tinfo->secid = newinfo.secid;\n\n\treturn ret;\n}\n\nstatic unsigned int\nsecmark_tg_v0(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct xt_secmark_target_info *info = par->targinfo;\n\tstruct xt_secmark_target_info_v1 newinfo = {\n\t\t.secid\t= info->secid,\n\t};\n\n\treturn secmark_tg(skb, &newinfo);\n}\n\nstatic int secmark_tg_check_v1(const struct xt_tgchk_param *par)\n{\n\treturn secmark_tg_check(par->table, par->targinfo);\n}\n\nstatic unsigned int\nsecmark_tg_v1(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\treturn secmark_tg(skb, par->targinfo);\n}\n\nstatic struct xt_target secmark_tg_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"SECMARK\",\n\t\t.revision\t= 0,\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.checkentry\t= secmark_tg_check_v0,\n\t\t.destroy\t= secmark_tg_destroy,\n\t\t.target\t\t= secmark_tg_v0,\n\t\t.targetsize\t= sizeof(struct xt_secmark_target_info),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"SECMARK\",\n\t\t.revision\t= 1,\n\t\t.family\t\t= NFPROTO_UNSPEC,\n\t\t.checkentry\t= secmark_tg_check_v1,\n\t\t.destroy\t= secmark_tg_destroy,\n\t\t.target\t\t= secmark_tg_v1,\n\t\t.targetsize\t= sizeof(struct xt_secmark_target_info_v1),\n\t\t.usersize\t= offsetof(struct xt_secmark_target_info_v1, secid),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init secmark_tg_init(void)\n{\n\treturn xt_register_targets(secmark_tg_reg, ARRAY_SIZE(secmark_tg_reg));\n}\n\nstatic void __exit secmark_tg_exit(void)\n{\n\txt_unregister_targets(secmark_tg_reg, ARRAY_SIZE(secmark_tg_reg));\n}\n\nmodule_init(secmark_tg_init);\nmodule_exit(secmark_tg_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}