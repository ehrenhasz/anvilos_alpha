{
  "module_name": "nf_nat_ovs.c",
  "hash_id": "543c01104cf515c3c37553a5bafc0b2a5e036c45f7f96c84a29ad74a8ca33ee7",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_nat_ovs.c",
  "human_readable_source": "\n \n\n#include <net/netfilter/nf_nat.h>\n\n \nstatic int nf_ct_nat_execute(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t     enum ip_conntrack_info ctinfo, int *action,\n\t\t\t     const struct nf_nat_range2 *range,\n\t\t\t     enum nf_nat_manip_type maniptype)\n{\n\t__be16 proto = skb_protocol(skb, true);\n\tint hooknum, err = NF_ACCEPT;\n\n\t \n\tif (maniptype == NF_NAT_MANIP_SRC)\n\t\thooknum = NF_INET_LOCAL_IN;  \n\telse\n\t\thooknum = NF_INET_LOCAL_OUT;  \n\n\tswitch (ctinfo) {\n\tcase IP_CT_RELATED:\n\tcase IP_CT_RELATED_REPLY:\n\t\tif (proto == htons(ETH_P_IP) &&\n\t\t    ip_hdr(skb)->protocol == IPPROTO_ICMP) {\n\t\t\tif (!nf_nat_icmp_reply_translation(skb, ct, ctinfo,\n\t\t\t\t\t\t\t   hooknum))\n\t\t\t\terr = NF_DROP;\n\t\t\tgoto out;\n\t\t} else if (IS_ENABLED(CONFIG_IPV6) && proto == htons(ETH_P_IPV6)) {\n\t\t\t__be16 frag_off;\n\t\t\tu8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\t\t\tint hdrlen = ipv6_skip_exthdr(skb,\n\t\t\t\t\t\t      sizeof(struct ipv6hdr),\n\t\t\t\t\t\t      &nexthdr, &frag_off);\n\n\t\t\tif (hdrlen >= 0 && nexthdr == IPPROTO_ICMPV6) {\n\t\t\t\tif (!nf_nat_icmpv6_reply_translation(skb, ct,\n\t\t\t\t\t\t\t\t     ctinfo,\n\t\t\t\t\t\t\t\t     hooknum,\n\t\t\t\t\t\t\t\t     hdrlen))\n\t\t\t\t\terr = NF_DROP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t \n\t\tfallthrough;\n\tcase IP_CT_NEW:\n\t\t \n\t\tif (!nf_nat_initialized(ct, maniptype)) {\n\t\t\t \n\t\t\terr = (range && range->flags & NF_NAT_RANGE_MAP_IPS)\n\t\t\t\t \n\t\t\t\t? nf_nat_setup_info(ct, range, maniptype)\n\t\t\t\t: nf_nat_alloc_null_binding(ct, hooknum);\n\t\t\tif (err != NF_ACCEPT)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase IP_CT_ESTABLISHED:\n\tcase IP_CT_ESTABLISHED_REPLY:\n\t\tbreak;\n\n\tdefault:\n\t\terr = NF_DROP;\n\t\tgoto out;\n\t}\n\n\terr = nf_nat_packet(ct, ctinfo, hooknum, skb);\nout:\n\tif (err == NF_ACCEPT)\n\t\t*action |= BIT(maniptype);\n\n\treturn err;\n}\n\nint nf_ct_nat(struct sk_buff *skb, struct nf_conn *ct,\n\t      enum ip_conntrack_info ctinfo, int *action,\n\t      const struct nf_nat_range2 *range, bool commit)\n{\n\tenum nf_nat_manip_type maniptype;\n\tint err, ct_action = *action;\n\n\t*action = 0;\n\n\t \n\tif (!nf_ct_is_confirmed(ct) && !nf_ct_nat_ext_add(ct))\n\t\treturn NF_DROP;    \n\n\tif (ctinfo != IP_CT_NEW && (ct->status & IPS_NAT_MASK) &&\n\t    (ctinfo != IP_CT_RELATED || commit)) {\n\t\t \n\t\tif (CTINFO2DIR(ctinfo) == IP_CT_DIR_REPLY)\n\t\t\t \n\t\t\tmaniptype = ct->status & IPS_SRC_NAT\n\t\t\t\t? NF_NAT_MANIP_DST : NF_NAT_MANIP_SRC;\n\t\telse\n\t\t\tmaniptype = ct->status & IPS_SRC_NAT\n\t\t\t\t? NF_NAT_MANIP_SRC : NF_NAT_MANIP_DST;\n\t} else if (ct_action & BIT(NF_NAT_MANIP_SRC)) {\n\t\tmaniptype = NF_NAT_MANIP_SRC;\n\t} else if (ct_action & BIT(NF_NAT_MANIP_DST)) {\n\t\tmaniptype = NF_NAT_MANIP_DST;\n\t} else {\n\t\treturn NF_ACCEPT;\n\t}\n\n\terr = nf_ct_nat_execute(skb, ct, ctinfo, action, range, maniptype);\n\tif (err == NF_ACCEPT && ct->status & IPS_DST_NAT) {\n\t\tif (ct->status & IPS_SRC_NAT) {\n\t\t\tif (maniptype == NF_NAT_MANIP_SRC)\n\t\t\t\tmaniptype = NF_NAT_MANIP_DST;\n\t\t\telse\n\t\t\t\tmaniptype = NF_NAT_MANIP_SRC;\n\n\t\t\terr = nf_ct_nat_execute(skb, ct, ctinfo, action, range,\n\t\t\t\t\t\tmaniptype);\n\t\t} else if (CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) {\n\t\t\terr = nf_ct_nat_execute(skb, ct, ctinfo, action, NULL,\n\t\t\t\t\t\tNF_NAT_MANIP_SRC);\n\t\t}\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nf_ct_nat);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}