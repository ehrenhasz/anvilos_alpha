{
  "module_name": "nft_queue.c",
  "hash_id": "793907661f702ff2846cfebe70df97d7df3c2292c270b9627de27266575534e2",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_queue.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/jhash.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_queue.h>\n\nstatic u32 jhash_initval __read_mostly;\n\nstruct nft_queue {\n\tu8\tsreg_qnum;\n\tu16\tqueuenum;\n\tu16\tqueues_total;\n\tu16\tflags;\n};\n\nstatic void nft_queue_eval(const struct nft_expr *expr,\n\t\t\t   struct nft_regs *regs,\n\t\t\t   const struct nft_pktinfo *pkt)\n{\n\tstruct nft_queue *priv = nft_expr_priv(expr);\n\tu32 queue = priv->queuenum;\n\tu32 ret;\n\n\tif (priv->queues_total > 1) {\n\t\tif (priv->flags & NFT_QUEUE_FLAG_CPU_FANOUT) {\n\t\t\tint cpu = raw_smp_processor_id();\n\n\t\t\tqueue = priv->queuenum + cpu % priv->queues_total;\n\t\t} else {\n\t\t\tqueue = nfqueue_hash(pkt->skb, queue,\n\t\t\t\t\t     priv->queues_total, nft_pf(pkt),\n\t\t\t\t\t     jhash_initval);\n\t\t}\n\t}\n\n\tret = NF_QUEUE_NR(queue);\n\tif (priv->flags & NFT_QUEUE_FLAG_BYPASS)\n\t\tret |= NF_VERDICT_FLAG_QUEUE_BYPASS;\n\n\tregs->verdict.code = ret;\n}\n\nstatic void nft_queue_sreg_eval(const struct nft_expr *expr,\n\t\t\t\tstruct nft_regs *regs,\n\t\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tstruct nft_queue *priv = nft_expr_priv(expr);\n\tu32 queue, ret;\n\n\tqueue = regs->data[priv->sreg_qnum];\n\n\tret = NF_QUEUE_NR(queue);\n\tif (priv->flags & NFT_QUEUE_FLAG_BYPASS)\n\t\tret |= NF_VERDICT_FLAG_QUEUE_BYPASS;\n\n\tregs->verdict.code = ret;\n}\n\nstatic int nft_queue_validate(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr,\n\t\t\t      const struct nft_data **data)\n{\n\tstatic const unsigned int supported_hooks = ((1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t\t\t     (1 << NF_INET_LOCAL_IN) |\n\t\t\t\t\t\t     (1 << NF_INET_FORWARD) |\n\t\t\t\t\t\t     (1 << NF_INET_LOCAL_OUT) |\n\t\t\t\t\t\t     (1 << NF_INET_POST_ROUTING));\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\tcase NFPROTO_BRIDGE:\n\t\tbreak;\n\tcase NFPROTO_NETDEV:  \n\t\tfallthrough;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, supported_hooks);\n}\n\nstatic const struct nla_policy nft_queue_policy[NFTA_QUEUE_MAX + 1] = {\n\t[NFTA_QUEUE_NUM]\t= { .type = NLA_U16 },\n\t[NFTA_QUEUE_TOTAL]\t= { .type = NLA_U16 },\n\t[NFTA_QUEUE_FLAGS]\t= { .type = NLA_U16 },\n\t[NFTA_QUEUE_SREG_QNUM]\t= { .type = NLA_U32 },\n};\n\nstatic int nft_queue_init(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_queue *priv = nft_expr_priv(expr);\n\tu32 maxid;\n\n\tpriv->queuenum = ntohs(nla_get_be16(tb[NFTA_QUEUE_NUM]));\n\n\tif (tb[NFTA_QUEUE_TOTAL])\n\t\tpriv->queues_total = ntohs(nla_get_be16(tb[NFTA_QUEUE_TOTAL]));\n\telse\n\t\tpriv->queues_total = 1;\n\n\tif (priv->queues_total == 0)\n\t\treturn -EINVAL;\n\n\tmaxid = priv->queues_total - 1 + priv->queuenum;\n\tif (maxid > U16_MAX)\n\t\treturn -ERANGE;\n\n\tif (tb[NFTA_QUEUE_FLAGS]) {\n\t\tpriv->flags = ntohs(nla_get_be16(tb[NFTA_QUEUE_FLAGS]));\n\t\tif (priv->flags & ~NFT_QUEUE_FLAG_MASK)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int nft_queue_sreg_init(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nlattr * const tb[])\n{\n\tstruct nft_queue *priv = nft_expr_priv(expr);\n\tint err;\n\n\terr = nft_parse_register_load(tb[NFTA_QUEUE_SREG_QNUM],\n\t\t\t\t      &priv->sreg_qnum, sizeof(u32));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_QUEUE_FLAGS]) {\n\t\tpriv->flags = ntohs(nla_get_be16(tb[NFTA_QUEUE_FLAGS]));\n\t\tif (priv->flags & ~NFT_QUEUE_FLAG_MASK)\n\t\t\treturn -EINVAL;\n\t\tif (priv->flags & NFT_QUEUE_FLAG_CPU_FANOUT)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int nft_queue_dump(struct sk_buff *skb,\n\t\t\t  const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_queue *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be16(skb, NFTA_QUEUE_NUM, htons(priv->queuenum)) ||\n\t    nla_put_be16(skb, NFTA_QUEUE_TOTAL, htons(priv->queues_total)) ||\n\t    nla_put_be16(skb, NFTA_QUEUE_FLAGS, htons(priv->flags)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int\nnft_queue_sreg_dump(struct sk_buff *skb,\n\t\t    const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_queue *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_QUEUE_SREG_QNUM, priv->sreg_qnum) ||\n\t    nla_put_be16(skb, NFTA_QUEUE_FLAGS, htons(priv->flags)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic struct nft_expr_type nft_queue_type;\nstatic const struct nft_expr_ops nft_queue_ops = {\n\t.type\t\t= &nft_queue_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_queue)),\n\t.eval\t\t= nft_queue_eval,\n\t.init\t\t= nft_queue_init,\n\t.dump\t\t= nft_queue_dump,\n\t.validate\t= nft_queue_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic const struct nft_expr_ops nft_queue_sreg_ops = {\n\t.type\t\t= &nft_queue_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_queue)),\n\t.eval\t\t= nft_queue_sreg_eval,\n\t.init\t\t= nft_queue_sreg_init,\n\t.dump\t\t= nft_queue_sreg_dump,\n\t.validate\t= nft_queue_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic const struct nft_expr_ops *\nnft_queue_select_ops(const struct nft_ctx *ctx,\n\t\t     const struct nlattr * const tb[])\n{\n\tif (tb[NFTA_QUEUE_NUM] && tb[NFTA_QUEUE_SREG_QNUM])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tinit_hashrandom(&jhash_initval);\n\n\tif (tb[NFTA_QUEUE_NUM])\n\t\treturn &nft_queue_ops;\n\n\tif (tb[NFTA_QUEUE_SREG_QNUM])\n\t\treturn &nft_queue_sreg_ops;\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct nft_expr_type nft_queue_type __read_mostly = {\n\t.name\t\t= \"queue\",\n\t.select_ops\t= nft_queue_select_ops,\n\t.policy\t\t= nft_queue_policy,\n\t.maxattr\t= NFTA_QUEUE_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_queue_module_init(void)\n{\n\treturn nft_register_expr(&nft_queue_type);\n}\n\nstatic void __exit nft_queue_module_exit(void)\n{\n\tnft_unregister_expr(&nft_queue_type);\n}\n\nmodule_init(nft_queue_module_init);\nmodule_exit(nft_queue_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Eric Leblond <eric@regit.org>\");\nMODULE_ALIAS_NFT_EXPR(\"queue\");\nMODULE_DESCRIPTION(\"Netfilter nftables queue module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}