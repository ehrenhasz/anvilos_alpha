{
  "module_name": "ip_vs_conn.c",
  "hash_id": "c9be25e7f9ba51eb39d3da8c08704079f050597c90c975de77cad3ac500591d7",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_conn.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\t\t \n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n\n#include <net/net_namespace.h>\n#include <net/ip_vs.h>\n\n\n#ifndef CONFIG_IP_VS_TAB_BITS\n#define CONFIG_IP_VS_TAB_BITS\t12\n#endif\n\n \nstatic int ip_vs_conn_tab_bits = CONFIG_IP_VS_TAB_BITS;\nmodule_param_named(conn_tab_bits, ip_vs_conn_tab_bits, int, 0444);\nMODULE_PARM_DESC(conn_tab_bits, \"Set connections' hash size\");\n\n \nint ip_vs_conn_tab_size __read_mostly;\nstatic int ip_vs_conn_tab_mask __read_mostly;\n\n \nstatic struct hlist_head *ip_vs_conn_tab __read_mostly;\n\n \nstatic struct kmem_cache *ip_vs_conn_cachep __read_mostly;\n\n \nstatic atomic_t ip_vs_conn_no_cport_cnt = ATOMIC_INIT(0);\n\n \nstatic unsigned int ip_vs_conn_rnd __read_mostly;\n\n \n#define CT_LOCKARRAY_BITS  5\n#define CT_LOCKARRAY_SIZE  (1<<CT_LOCKARRAY_BITS)\n#define CT_LOCKARRAY_MASK  (CT_LOCKARRAY_SIZE-1)\n\n \n#ifdef CONFIG_IP_VS_IPV6\n#define IP_VS_ADDRSTRLEN INET6_ADDRSTRLEN\n#else\n#define IP_VS_ADDRSTRLEN (8+1)\n#endif\n\nstruct ip_vs_aligned_lock\n{\n\tspinlock_t\tl;\n} __attribute__((__aligned__(SMP_CACHE_BYTES)));\n\n \nstatic struct ip_vs_aligned_lock\n__ip_vs_conntbl_lock_array[CT_LOCKARRAY_SIZE] __cacheline_aligned;\n\nstatic inline void ct_write_lock_bh(unsigned int key)\n{\n\tspin_lock_bh(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);\n}\n\nstatic inline void ct_write_unlock_bh(unsigned int key)\n{\n\tspin_unlock_bh(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);\n}\n\nstatic void ip_vs_conn_expire(struct timer_list *t);\n\n \nstatic unsigned int ip_vs_conn_hashkey(struct netns_ipvs *ipvs, int af, unsigned int proto,\n\t\t\t\t       const union nf_inet_addr *addr,\n\t\t\t\t       __be16 port)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\treturn (jhash_3words(jhash(addr, 16, ip_vs_conn_rnd),\n\t\t\t\t    (__force u32)port, proto, ip_vs_conn_rnd) ^\n\t\t\t((size_t)ipvs>>8)) & ip_vs_conn_tab_mask;\n#endif\n\treturn (jhash_3words((__force u32)addr->ip, (__force u32)port, proto,\n\t\t\t    ip_vs_conn_rnd) ^\n\t\t((size_t)ipvs>>8)) & ip_vs_conn_tab_mask;\n}\n\nstatic unsigned int ip_vs_conn_hashkey_param(const struct ip_vs_conn_param *p,\n\t\t\t\t\t     bool inverse)\n{\n\tconst union nf_inet_addr *addr;\n\t__be16 port;\n\n\tif (p->pe_data && p->pe->hashkey_raw)\n\t\treturn p->pe->hashkey_raw(p, ip_vs_conn_rnd, inverse) &\n\t\t\tip_vs_conn_tab_mask;\n\n\tif (likely(!inverse)) {\n\t\taddr = p->caddr;\n\t\tport = p->cport;\n\t} else {\n\t\taddr = p->vaddr;\n\t\tport = p->vport;\n\t}\n\n\treturn ip_vs_conn_hashkey(p->ipvs, p->af, p->protocol, addr, port);\n}\n\nstatic unsigned int ip_vs_conn_hashkey_conn(const struct ip_vs_conn *cp)\n{\n\tstruct ip_vs_conn_param p;\n\n\tip_vs_conn_fill_param(cp->ipvs, cp->af, cp->protocol,\n\t\t\t      &cp->caddr, cp->cport, NULL, 0, &p);\n\n\tif (cp->pe) {\n\t\tp.pe = cp->pe;\n\t\tp.pe_data = cp->pe_data;\n\t\tp.pe_data_len = cp->pe_data_len;\n\t}\n\n\treturn ip_vs_conn_hashkey_param(&p, false);\n}\n\n \nstatic inline int ip_vs_conn_hash(struct ip_vs_conn *cp)\n{\n\tunsigned int hash;\n\tint ret;\n\n\tif (cp->flags & IP_VS_CONN_F_ONE_PACKET)\n\t\treturn 0;\n\n\t \n\thash = ip_vs_conn_hashkey_conn(cp);\n\n\tct_write_lock_bh(hash);\n\tspin_lock(&cp->lock);\n\n\tif (!(cp->flags & IP_VS_CONN_F_HASHED)) {\n\t\tcp->flags |= IP_VS_CONN_F_HASHED;\n\t\trefcount_inc(&cp->refcnt);\n\t\thlist_add_head_rcu(&cp->c_list, &ip_vs_conn_tab[hash]);\n\t\tret = 1;\n\t} else {\n\t\tpr_err(\"%s(): request for already hashed, called from %pS\\n\",\n\t\t       __func__, __builtin_return_address(0));\n\t\tret = 0;\n\t}\n\n\tspin_unlock(&cp->lock);\n\tct_write_unlock_bh(hash);\n\n\treturn ret;\n}\n\n\n \nstatic inline int ip_vs_conn_unhash(struct ip_vs_conn *cp)\n{\n\tunsigned int hash;\n\tint ret;\n\n\t \n\thash = ip_vs_conn_hashkey_conn(cp);\n\n\tct_write_lock_bh(hash);\n\tspin_lock(&cp->lock);\n\n\tif (cp->flags & IP_VS_CONN_F_HASHED) {\n\t\thlist_del_rcu(&cp->c_list);\n\t\tcp->flags &= ~IP_VS_CONN_F_HASHED;\n\t\trefcount_dec(&cp->refcnt);\n\t\tret = 1;\n\t} else\n\t\tret = 0;\n\n\tspin_unlock(&cp->lock);\n\tct_write_unlock_bh(hash);\n\n\treturn ret;\n}\n\n \nstatic inline bool ip_vs_conn_unlink(struct ip_vs_conn *cp)\n{\n\tunsigned int hash;\n\tbool ret = false;\n\n\tif (cp->flags & IP_VS_CONN_F_ONE_PACKET)\n\t\treturn refcount_dec_if_one(&cp->refcnt);\n\n\thash = ip_vs_conn_hashkey_conn(cp);\n\n\tct_write_lock_bh(hash);\n\tspin_lock(&cp->lock);\n\n\tif (cp->flags & IP_VS_CONN_F_HASHED) {\n\t\t \n\t\tif (refcount_dec_if_one(&cp->refcnt)) {\n\t\t\thlist_del_rcu(&cp->c_list);\n\t\t\tcp->flags &= ~IP_VS_CONN_F_HASHED;\n\t\t\tret = true;\n\t\t}\n\t}\n\n\tspin_unlock(&cp->lock);\n\tct_write_unlock_bh(hash);\n\n\treturn ret;\n}\n\n\n \nstatic inline struct ip_vs_conn *\n__ip_vs_conn_in_get(const struct ip_vs_conn_param *p)\n{\n\tunsigned int hash;\n\tstruct ip_vs_conn *cp;\n\n\thash = ip_vs_conn_hashkey_param(p, false);\n\n\trcu_read_lock();\n\n\thlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[hash], c_list) {\n\t\tif (p->cport == cp->cport && p->vport == cp->vport &&\n\t\t    cp->af == p->af &&\n\t\t    ip_vs_addr_equal(p->af, p->caddr, &cp->caddr) &&\n\t\t    ip_vs_addr_equal(p->af, p->vaddr, &cp->vaddr) &&\n\t\t    ((!p->cport) ^ (!(cp->flags & IP_VS_CONN_F_NO_CPORT))) &&\n\t\t    p->protocol == cp->protocol &&\n\t\t    cp->ipvs == p->ipvs) {\n\t\t\tif (!__ip_vs_conn_get(cp))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\trcu_read_unlock();\n\t\t\treturn cp;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstruct ip_vs_conn *ip_vs_conn_in_get(const struct ip_vs_conn_param *p)\n{\n\tstruct ip_vs_conn *cp;\n\n\tcp = __ip_vs_conn_in_get(p);\n\tif (!cp && atomic_read(&ip_vs_conn_no_cport_cnt)) {\n\t\tstruct ip_vs_conn_param cport_zero_p = *p;\n\t\tcport_zero_p.cport = 0;\n\t\tcp = __ip_vs_conn_in_get(&cport_zero_p);\n\t}\n\n\tIP_VS_DBG_BUF(9, \"lookup/in %s %s:%d->%s:%d %s\\n\",\n\t\t      ip_vs_proto_name(p->protocol),\n\t\t      IP_VS_DBG_ADDR(p->af, p->caddr), ntohs(p->cport),\n\t\t      IP_VS_DBG_ADDR(p->af, p->vaddr), ntohs(p->vport),\n\t\t      cp ? \"hit\" : \"not hit\");\n\n\treturn cp;\n}\n\nstatic int\nip_vs_conn_fill_param_proto(struct netns_ipvs *ipvs,\n\t\t\t    int af, const struct sk_buff *skb,\n\t\t\t    const struct ip_vs_iphdr *iph,\n\t\t\t    struct ip_vs_conn_param *p)\n{\n\t__be16 _ports[2], *pptr;\n\n\tpptr = frag_safe_skb_hp(skb, iph->len, sizeof(_ports), _ports);\n\tif (pptr == NULL)\n\t\treturn 1;\n\n\tif (likely(!ip_vs_iph_inverse(iph)))\n\t\tip_vs_conn_fill_param(ipvs, af, iph->protocol, &iph->saddr,\n\t\t\t\t      pptr[0], &iph->daddr, pptr[1], p);\n\telse\n\t\tip_vs_conn_fill_param(ipvs, af, iph->protocol, &iph->daddr,\n\t\t\t\t      pptr[1], &iph->saddr, pptr[0], p);\n\treturn 0;\n}\n\nstruct ip_vs_conn *\nip_vs_conn_in_get_proto(struct netns_ipvs *ipvs, int af,\n\t\t\tconst struct sk_buff *skb,\n\t\t\tconst struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_conn_param p;\n\n\tif (ip_vs_conn_fill_param_proto(ipvs, af, skb, iph, &p))\n\t\treturn NULL;\n\n\treturn ip_vs_conn_in_get(&p);\n}\nEXPORT_SYMBOL_GPL(ip_vs_conn_in_get_proto);\n\n \nstruct ip_vs_conn *ip_vs_ct_in_get(const struct ip_vs_conn_param *p)\n{\n\tunsigned int hash;\n\tstruct ip_vs_conn *cp;\n\n\thash = ip_vs_conn_hashkey_param(p, false);\n\n\trcu_read_lock();\n\n\thlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[hash], c_list) {\n\t\tif (unlikely(p->pe_data && p->pe->ct_match)) {\n\t\t\tif (cp->ipvs != p->ipvs)\n\t\t\t\tcontinue;\n\t\t\tif (p->pe == cp->pe && p->pe->ct_match(p, cp)) {\n\t\t\t\tif (__ip_vs_conn_get(cp))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cp->af == p->af &&\n\t\t    ip_vs_addr_equal(p->af, p->caddr, &cp->caddr) &&\n\t\t     \n\t\t    ip_vs_addr_equal(p->protocol == IPPROTO_IP ? AF_UNSPEC :\n\t\t\t\t     p->af, p->vaddr, &cp->vaddr) &&\n\t\t    p->vport == cp->vport && p->cport == cp->cport &&\n\t\t    cp->flags & IP_VS_CONN_F_TEMPLATE &&\n\t\t    p->protocol == cp->protocol &&\n\t\t    cp->ipvs == p->ipvs) {\n\t\t\tif (__ip_vs_conn_get(cp))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tcp = NULL;\n\n  out:\n\trcu_read_unlock();\n\n\tIP_VS_DBG_BUF(9, \"template lookup/in %s %s:%d->%s:%d %s\\n\",\n\t\t      ip_vs_proto_name(p->protocol),\n\t\t      IP_VS_DBG_ADDR(p->af, p->caddr), ntohs(p->cport),\n\t\t      IP_VS_DBG_ADDR(p->af, p->vaddr), ntohs(p->vport),\n\t\t      cp ? \"hit\" : \"not hit\");\n\n\treturn cp;\n}\n\n \nstruct ip_vs_conn *ip_vs_conn_out_get(const struct ip_vs_conn_param *p)\n{\n\tunsigned int hash;\n\tstruct ip_vs_conn *cp, *ret=NULL;\n\tconst union nf_inet_addr *saddr;\n\t__be16 sport;\n\n\t \n\thash = ip_vs_conn_hashkey_param(p, true);\n\n\trcu_read_lock();\n\n\thlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[hash], c_list) {\n\t\tif (p->vport != cp->cport)\n\t\t\tcontinue;\n\n\t\tif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ) {\n\t\t\tsport = cp->vport;\n\t\t\tsaddr = &cp->vaddr;\n\t\t} else {\n\t\t\tsport = cp->dport;\n\t\t\tsaddr = &cp->daddr;\n\t\t}\n\n\t\tif (p->cport == sport && cp->af == p->af &&\n\t\t    ip_vs_addr_equal(p->af, p->vaddr, &cp->caddr) &&\n\t\t    ip_vs_addr_equal(p->af, p->caddr, saddr) &&\n\t\t    p->protocol == cp->protocol &&\n\t\t    cp->ipvs == p->ipvs) {\n\t\t\tif (!__ip_vs_conn_get(cp))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tret = cp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tIP_VS_DBG_BUF(9, \"lookup/out %s %s:%d->%s:%d %s\\n\",\n\t\t      ip_vs_proto_name(p->protocol),\n\t\t      IP_VS_DBG_ADDR(p->af, p->caddr), ntohs(p->cport),\n\t\t      IP_VS_DBG_ADDR(p->af, p->vaddr), ntohs(p->vport),\n\t\t      ret ? \"hit\" : \"not hit\");\n\n\treturn ret;\n}\n\nstruct ip_vs_conn *\nip_vs_conn_out_get_proto(struct netns_ipvs *ipvs, int af,\n\t\t\t const struct sk_buff *skb,\n\t\t\t const struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_conn_param p;\n\n\tif (ip_vs_conn_fill_param_proto(ipvs, af, skb, iph, &p))\n\t\treturn NULL;\n\n\treturn ip_vs_conn_out_get(&p);\n}\nEXPORT_SYMBOL_GPL(ip_vs_conn_out_get_proto);\n\n \nstatic void __ip_vs_conn_put_timer(struct ip_vs_conn *cp)\n{\n\tunsigned long t = (cp->flags & IP_VS_CONN_F_ONE_PACKET) ?\n\t\t0 : cp->timeout;\n\tmod_timer(&cp->timer, jiffies+t);\n\n\t__ip_vs_conn_put(cp);\n}\n\nvoid ip_vs_conn_put(struct ip_vs_conn *cp)\n{\n\tif ((cp->flags & IP_VS_CONN_F_ONE_PACKET) &&\n\t    (refcount_read(&cp->refcnt) == 1) &&\n\t    !timer_pending(&cp->timer))\n\t\t \n\t\tip_vs_conn_expire(&cp->timer);\n\telse\n\t\t__ip_vs_conn_put_timer(cp);\n}\n\n \nvoid ip_vs_conn_fill_cport(struct ip_vs_conn *cp, __be16 cport)\n{\n\tif (ip_vs_conn_unhash(cp)) {\n\t\tspin_lock_bh(&cp->lock);\n\t\tif (cp->flags & IP_VS_CONN_F_NO_CPORT) {\n\t\t\tatomic_dec(&ip_vs_conn_no_cport_cnt);\n\t\t\tcp->flags &= ~IP_VS_CONN_F_NO_CPORT;\n\t\t\tcp->cport = cport;\n\t\t}\n\t\tspin_unlock_bh(&cp->lock);\n\n\t\t \n\t\tip_vs_conn_hash(cp);\n\t}\n}\n\n\n \nstatic inline void ip_vs_bind_xmit(struct ip_vs_conn *cp)\n{\n\tswitch (IP_VS_FWD_METHOD(cp)) {\n\tcase IP_VS_CONN_F_MASQ:\n\t\tcp->packet_xmit = ip_vs_nat_xmit;\n\t\tbreak;\n\n\tcase IP_VS_CONN_F_TUNNEL:\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (cp->daf == AF_INET6)\n\t\t\tcp->packet_xmit = ip_vs_tunnel_xmit_v6;\n\t\telse\n#endif\n\t\t\tcp->packet_xmit = ip_vs_tunnel_xmit;\n\t\tbreak;\n\n\tcase IP_VS_CONN_F_DROUTE:\n\t\tcp->packet_xmit = ip_vs_dr_xmit;\n\t\tbreak;\n\n\tcase IP_VS_CONN_F_LOCALNODE:\n\t\tcp->packet_xmit = ip_vs_null_xmit;\n\t\tbreak;\n\n\tcase IP_VS_CONN_F_BYPASS:\n\t\tcp->packet_xmit = ip_vs_bypass_xmit;\n\t\tbreak;\n\t}\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nstatic inline void ip_vs_bind_xmit_v6(struct ip_vs_conn *cp)\n{\n\tswitch (IP_VS_FWD_METHOD(cp)) {\n\tcase IP_VS_CONN_F_MASQ:\n\t\tcp->packet_xmit = ip_vs_nat_xmit_v6;\n\t\tbreak;\n\n\tcase IP_VS_CONN_F_TUNNEL:\n\t\tif (cp->daf == AF_INET6)\n\t\t\tcp->packet_xmit = ip_vs_tunnel_xmit_v6;\n\t\telse\n\t\t\tcp->packet_xmit = ip_vs_tunnel_xmit;\n\t\tbreak;\n\n\tcase IP_VS_CONN_F_DROUTE:\n\t\tcp->packet_xmit = ip_vs_dr_xmit_v6;\n\t\tbreak;\n\n\tcase IP_VS_CONN_F_LOCALNODE:\n\t\tcp->packet_xmit = ip_vs_null_xmit;\n\t\tbreak;\n\n\tcase IP_VS_CONN_F_BYPASS:\n\t\tcp->packet_xmit = ip_vs_bypass_xmit_v6;\n\t\tbreak;\n\t}\n}\n#endif\n\n\nstatic inline int ip_vs_dest_totalconns(struct ip_vs_dest *dest)\n{\n\treturn atomic_read(&dest->activeconns)\n\t\t+ atomic_read(&dest->inactconns);\n}\n\n \nstatic inline void\nip_vs_bind_dest(struct ip_vs_conn *cp, struct ip_vs_dest *dest)\n{\n\tunsigned int conn_flags;\n\t__u32 flags;\n\n\t \n\tif (!dest)\n\t\treturn;\n\n\t \n\tip_vs_dest_hold(dest);\n\n\tconn_flags = atomic_read(&dest->conn_flags);\n\tif (cp->protocol != IPPROTO_UDP)\n\t\tconn_flags &= ~IP_VS_CONN_F_ONE_PACKET;\n\tflags = cp->flags;\n\t \n\tif (flags & IP_VS_CONN_F_SYNC) {\n\t\t \n\t\tif (!(flags & IP_VS_CONN_F_TEMPLATE))\n\t\t\tconn_flags &= ~IP_VS_CONN_F_INACTIVE;\n\t\t \n\t\tflags &= ~(IP_VS_CONN_F_FWD_MASK | IP_VS_CONN_F_NOOUTPUT);\n\t}\n\tflags |= conn_flags;\n\tcp->flags = flags;\n\tcp->dest = dest;\n\n\tIP_VS_DBG_BUF(7, \"Bind-dest %s c:%s:%d v:%s:%d \"\n\t\t      \"d:%s:%d fwd:%c s:%u conn->flags:%X conn->refcnt:%d \"\n\t\t      \"dest->refcnt:%d\\n\",\n\t\t      ip_vs_proto_name(cp->protocol),\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr), ntohs(cp->cport),\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr), ntohs(cp->vport),\n\t\t      IP_VS_DBG_ADDR(cp->daf, &cp->daddr), ntohs(cp->dport),\n\t\t      ip_vs_fwd_tag(cp), cp->state,\n\t\t      cp->flags, refcount_read(&cp->refcnt),\n\t\t      refcount_read(&dest->refcnt));\n\n\t \n\tif (!(flags & IP_VS_CONN_F_TEMPLATE)) {\n\t\t \n\t\tif (!(flags & IP_VS_CONN_F_INACTIVE))\n\t\t\tatomic_inc(&dest->activeconns);\n\t\telse\n\t\t\tatomic_inc(&dest->inactconns);\n\t} else {\n\t\t \n\t\tatomic_inc(&dest->persistconns);\n\t}\n\n\tif (dest->u_threshold != 0 &&\n\t    ip_vs_dest_totalconns(dest) >= dest->u_threshold)\n\t\tdest->flags |= IP_VS_DEST_F_OVERLOAD;\n}\n\n\n \nvoid ip_vs_try_bind_dest(struct ip_vs_conn *cp)\n{\n\tstruct ip_vs_dest *dest;\n\n\trcu_read_lock();\n\n\t \n\tdest = ip_vs_find_dest(cp->ipvs, cp->af, cp->af, &cp->daddr,\n\t\t\t       cp->dport, &cp->vaddr, cp->vport,\n\t\t\t       cp->protocol, cp->fwmark, cp->flags);\n\tif (dest) {\n\t\tstruct ip_vs_proto_data *pd;\n\n\t\tspin_lock_bh(&cp->lock);\n\t\tif (cp->dest) {\n\t\t\tspin_unlock_bh(&cp->lock);\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (cp->app)\n\t\t\tip_vs_unbind_app(cp);\n\n\t\tip_vs_bind_dest(cp, dest);\n\t\tspin_unlock_bh(&cp->lock);\n\n\t\t \n\t\tcp->packet_xmit = NULL;\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (cp->af == AF_INET6)\n\t\t\tip_vs_bind_xmit_v6(cp);\n\t\telse\n#endif\n\t\t\tip_vs_bind_xmit(cp);\n\n\t\tpd = ip_vs_proto_data_get(cp->ipvs, cp->protocol);\n\t\tif (pd && atomic_read(&pd->appcnt))\n\t\t\tip_vs_bind_app(cp, pd->pp);\n\t}\n\trcu_read_unlock();\n}\n\n\n \nstatic inline void ip_vs_unbind_dest(struct ip_vs_conn *cp)\n{\n\tstruct ip_vs_dest *dest = cp->dest;\n\n\tif (!dest)\n\t\treturn;\n\n\tIP_VS_DBG_BUF(7, \"Unbind-dest %s c:%s:%d v:%s:%d \"\n\t\t      \"d:%s:%d fwd:%c s:%u conn->flags:%X conn->refcnt:%d \"\n\t\t      \"dest->refcnt:%d\\n\",\n\t\t      ip_vs_proto_name(cp->protocol),\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr), ntohs(cp->cport),\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr), ntohs(cp->vport),\n\t\t      IP_VS_DBG_ADDR(cp->daf, &cp->daddr), ntohs(cp->dport),\n\t\t      ip_vs_fwd_tag(cp), cp->state,\n\t\t      cp->flags, refcount_read(&cp->refcnt),\n\t\t      refcount_read(&dest->refcnt));\n\n\t \n\tif (!(cp->flags & IP_VS_CONN_F_TEMPLATE)) {\n\t\t \n\t\tif (cp->flags & IP_VS_CONN_F_INACTIVE) {\n\t\t\tatomic_dec(&dest->inactconns);\n\t\t} else {\n\t\t\tatomic_dec(&dest->activeconns);\n\t\t}\n\t} else {\n\t\t \n\t\tatomic_dec(&dest->persistconns);\n\t}\n\n\tif (dest->l_threshold != 0) {\n\t\tif (ip_vs_dest_totalconns(dest) < dest->l_threshold)\n\t\t\tdest->flags &= ~IP_VS_DEST_F_OVERLOAD;\n\t} else if (dest->u_threshold != 0) {\n\t\tif (ip_vs_dest_totalconns(dest) * 4 < dest->u_threshold * 3)\n\t\t\tdest->flags &= ~IP_VS_DEST_F_OVERLOAD;\n\t} else {\n\t\tif (dest->flags & IP_VS_DEST_F_OVERLOAD)\n\t\t\tdest->flags &= ~IP_VS_DEST_F_OVERLOAD;\n\t}\n\n\tip_vs_dest_put(dest);\n}\n\nstatic int expire_quiescent_template(struct netns_ipvs *ipvs,\n\t\t\t\t     struct ip_vs_dest *dest)\n{\n#ifdef CONFIG_SYSCTL\n\treturn ipvs->sysctl_expire_quiescent_template &&\n\t\t(atomic_read(&dest->weight) == 0);\n#else\n\treturn 0;\n#endif\n}\n\n \nint ip_vs_check_template(struct ip_vs_conn *ct, struct ip_vs_dest *cdest)\n{\n\tstruct ip_vs_dest *dest = ct->dest;\n\tstruct netns_ipvs *ipvs = ct->ipvs;\n\n\t \n\tif ((dest == NULL) ||\n\t    !(dest->flags & IP_VS_DEST_F_AVAILABLE) ||\n\t    expire_quiescent_template(ipvs, dest) ||\n\t    (cdest && (dest != cdest))) {\n\t\tIP_VS_DBG_BUF(9, \"check_template: dest not available for \"\n\t\t\t      \"protocol %s s:%s:%d v:%s:%d \"\n\t\t\t      \"-> d:%s:%d\\n\",\n\t\t\t      ip_vs_proto_name(ct->protocol),\n\t\t\t      IP_VS_DBG_ADDR(ct->af, &ct->caddr),\n\t\t\t      ntohs(ct->cport),\n\t\t\t      IP_VS_DBG_ADDR(ct->af, &ct->vaddr),\n\t\t\t      ntohs(ct->vport),\n\t\t\t      IP_VS_DBG_ADDR(ct->daf, &ct->daddr),\n\t\t\t      ntohs(ct->dport));\n\n\t\t \n\t\tif (ct->vport != htons(0xffff)) {\n\t\t\tif (ip_vs_conn_unhash(ct)) {\n\t\t\t\tct->dport = htons(0xffff);\n\t\t\t\tct->vport = htons(0xffff);\n\t\t\t\tct->cport = 0;\n\t\t\t\tip_vs_conn_hash(ct);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\t__ip_vs_conn_put(ct);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void ip_vs_conn_rcu_free(struct rcu_head *head)\n{\n\tstruct ip_vs_conn *cp = container_of(head, struct ip_vs_conn,\n\t\t\t\t\t     rcu_head);\n\n\tip_vs_pe_put(cp->pe);\n\tkfree(cp->pe_data);\n\tkmem_cache_free(ip_vs_conn_cachep, cp);\n}\n\n \nstatic void ip_vs_conn_del(struct ip_vs_conn *cp)\n{\n\tif (del_timer(&cp->timer)) {\n\t\t \n\t\tif (cp->control)\n\t\t\tcp->timeout = 0;\n\t\tip_vs_conn_expire(&cp->timer);\n\t}\n}\n\n \nstatic void ip_vs_conn_del_put(struct ip_vs_conn *cp)\n{\n\tif (del_timer(&cp->timer)) {\n\t\t \n\t\tif (cp->control)\n\t\t\tcp->timeout = 0;\n\t\t__ip_vs_conn_put(cp);\n\t\tip_vs_conn_expire(&cp->timer);\n\t} else {\n\t\t__ip_vs_conn_put(cp);\n\t}\n}\n\nstatic void ip_vs_conn_expire(struct timer_list *t)\n{\n\tstruct ip_vs_conn *cp = from_timer(cp, t, timer);\n\tstruct netns_ipvs *ipvs = cp->ipvs;\n\n\t \n\tif (atomic_read(&cp->n_control))\n\t\tgoto expire_later;\n\n\t \n\tif (likely(ip_vs_conn_unlink(cp))) {\n\t\tstruct ip_vs_conn *ct = cp->control;\n\n\t\t \n\t\tdel_timer(&cp->timer);\n\n\t\t \n\t\tif (ct) {\n\t\t\tbool has_ref = !cp->timeout && __ip_vs_conn_get(ct);\n\n\t\t\tip_vs_control_del(cp);\n\t\t\t \n\t\t\tif (has_ref && !atomic_read(&ct->n_control) &&\n\t\t\t    (!(ct->flags & IP_VS_CONN_F_TEMPLATE) ||\n\t\t\t     !(ct->state & IP_VS_CTPL_S_ASSURED))) {\n\t\t\t\tIP_VS_DBG(4, \"drop controlling connection\\n\");\n\t\t\t\tip_vs_conn_del_put(ct);\n\t\t\t} else if (has_ref) {\n\t\t\t\t__ip_vs_conn_put(ct);\n\t\t\t}\n\t\t}\n\n\t\tif ((cp->flags & IP_VS_CONN_F_NFCT) &&\n\t\t    !(cp->flags & IP_VS_CONN_F_ONE_PACKET)) {\n\t\t\t \n\t\t\tsmp_rmb();\n\t\t\tif (ipvs->enable)\n\t\t\t\tip_vs_conn_drop_conntrack(cp);\n\t\t}\n\n\t\tif (unlikely(cp->app != NULL))\n\t\t\tip_vs_unbind_app(cp);\n\t\tip_vs_unbind_dest(cp);\n\t\tif (cp->flags & IP_VS_CONN_F_NO_CPORT)\n\t\t\tatomic_dec(&ip_vs_conn_no_cport_cnt);\n\t\tif (cp->flags & IP_VS_CONN_F_ONE_PACKET)\n\t\t\tip_vs_conn_rcu_free(&cp->rcu_head);\n\t\telse\n\t\t\tcall_rcu(&cp->rcu_head, ip_vs_conn_rcu_free);\n\t\tatomic_dec(&ipvs->conn_count);\n\t\treturn;\n\t}\n\n  expire_later:\n\tIP_VS_DBG(7, \"delayed: conn->refcnt=%d conn->n_control=%d\\n\",\n\t\t  refcount_read(&cp->refcnt),\n\t\t  atomic_read(&cp->n_control));\n\n\trefcount_inc(&cp->refcnt);\n\tcp->timeout = 60*HZ;\n\n\tif (ipvs->sync_state & IP_VS_STATE_MASTER)\n\t\tip_vs_sync_conn(ipvs, cp, sysctl_sync_threshold(ipvs));\n\n\t__ip_vs_conn_put_timer(cp);\n}\n\n \nvoid ip_vs_conn_expire_now(struct ip_vs_conn *cp)\n{\n\t \n\tif (timer_pending(&cp->timer) &&\n\t    time_after(cp->timer.expires, jiffies))\n\t\tmod_timer_pending(&cp->timer, jiffies);\n}\n\n\n \nstruct ip_vs_conn *\nip_vs_conn_new(const struct ip_vs_conn_param *p, int dest_af,\n\t       const union nf_inet_addr *daddr, __be16 dport, unsigned int flags,\n\t       struct ip_vs_dest *dest, __u32 fwmark)\n{\n\tstruct ip_vs_conn *cp;\n\tstruct netns_ipvs *ipvs = p->ipvs;\n\tstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(p->ipvs,\n\t\t\t\t\t\t\t   p->protocol);\n\n\tcp = kmem_cache_alloc(ip_vs_conn_cachep, GFP_ATOMIC);\n\tif (cp == NULL) {\n\t\tIP_VS_ERR_RL(\"%s(): no memory\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tINIT_HLIST_NODE(&cp->c_list);\n\ttimer_setup(&cp->timer, ip_vs_conn_expire, 0);\n\tcp->ipvs\t   = ipvs;\n\tcp->af\t\t   = p->af;\n\tcp->daf\t\t   = dest_af;\n\tcp->protocol\t   = p->protocol;\n\tip_vs_addr_set(p->af, &cp->caddr, p->caddr);\n\tcp->cport\t   = p->cport;\n\t \n\tip_vs_addr_set(p->protocol == IPPROTO_IP ? AF_UNSPEC : p->af,\n\t\t       &cp->vaddr, p->vaddr);\n\tcp->vport\t   = p->vport;\n\tip_vs_addr_set(cp->daf, &cp->daddr, daddr);\n\tcp->dport          = dport;\n\tcp->flags\t   = flags;\n\tcp->fwmark         = fwmark;\n\tif (flags & IP_VS_CONN_F_TEMPLATE && p->pe) {\n\t\tip_vs_pe_get(p->pe);\n\t\tcp->pe = p->pe;\n\t\tcp->pe_data = p->pe_data;\n\t\tcp->pe_data_len = p->pe_data_len;\n\t} else {\n\t\tcp->pe = NULL;\n\t\tcp->pe_data = NULL;\n\t\tcp->pe_data_len = 0;\n\t}\n\tspin_lock_init(&cp->lock);\n\n\t \n\trefcount_set(&cp->refcnt, 1);\n\n\tcp->control = NULL;\n\tatomic_set(&cp->n_control, 0);\n\tatomic_set(&cp->in_pkts, 0);\n\n\tcp->packet_xmit = NULL;\n\tcp->app = NULL;\n\tcp->app_data = NULL;\n\t \n\tcp->in_seq.delta = 0;\n\tcp->out_seq.delta = 0;\n\n\tatomic_inc(&ipvs->conn_count);\n\tif (flags & IP_VS_CONN_F_NO_CPORT)\n\t\tatomic_inc(&ip_vs_conn_no_cport_cnt);\n\n\t \n\tcp->dest = NULL;\n\tip_vs_bind_dest(cp, dest);\n\n\t \n\tcp->state = 0;\n\tcp->old_state = 0;\n\tcp->timeout = 3*HZ;\n\tcp->sync_endtime = jiffies & ~3UL;\n\n\t \n#ifdef CONFIG_IP_VS_IPV6\n\tif (p->af == AF_INET6)\n\t\tip_vs_bind_xmit_v6(cp);\n\telse\n#endif\n\t\tip_vs_bind_xmit(cp);\n\n\tif (unlikely(pd && atomic_read(&pd->appcnt)))\n\t\tip_vs_bind_app(cp, pd->pp);\n\n\t \n\n\tif (ip_vs_conntrack_enabled(ipvs))\n\t\tcp->flags |= IP_VS_CONN_F_NFCT;\n\n\t \n\tip_vs_conn_hash(cp);\n\n\treturn cp;\n}\n\n \n#ifdef CONFIG_PROC_FS\nstruct ip_vs_iter_state {\n\tstruct seq_net_private\tp;\n\tstruct hlist_head\t*l;\n};\n\nstatic void *ip_vs_conn_array(struct seq_file *seq, loff_t pos)\n{\n\tint idx;\n\tstruct ip_vs_conn *cp;\n\tstruct ip_vs_iter_state *iter = seq->private;\n\n\tfor (idx = 0; idx < ip_vs_conn_tab_size; idx++) {\n\t\thlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[idx], c_list) {\n\t\t\t \n\t\t\tif (pos-- == 0) {\n\t\t\t\titer->l = &ip_vs_conn_tab[idx];\n\t\t\t\treturn cp;\n\t\t\t}\n\t\t}\n\t\tcond_resched_rcu();\n\t}\n\n\treturn NULL;\n}\n\nstatic void *ip_vs_conn_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct ip_vs_iter_state *iter = seq->private;\n\n\titer->l = NULL;\n\trcu_read_lock();\n\treturn *pos ? ip_vs_conn_array(seq, *pos - 1) :SEQ_START_TOKEN;\n}\n\nstatic void *ip_vs_conn_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ip_vs_conn *cp = v;\n\tstruct ip_vs_iter_state *iter = seq->private;\n\tstruct hlist_node *e;\n\tstruct hlist_head *l = iter->l;\n\tint idx;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn ip_vs_conn_array(seq, 0);\n\n\t \n\te = rcu_dereference(hlist_next_rcu(&cp->c_list));\n\tif (e)\n\t\treturn hlist_entry(e, struct ip_vs_conn, c_list);\n\n\tidx = l - ip_vs_conn_tab;\n\twhile (++idx < ip_vs_conn_tab_size) {\n\t\thlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[idx], c_list) {\n\t\t\titer->l = &ip_vs_conn_tab[idx];\n\t\t\treturn cp;\n\t\t}\n\t\tcond_resched_rcu();\n\t}\n\titer->l = NULL;\n\treturn NULL;\n}\n\nstatic void ip_vs_conn_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\nstatic int ip_vs_conn_seq_show(struct seq_file *seq, void *v)\n{\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n   \"Pro FromIP   FPrt ToIP     TPrt DestIP   DPrt State       Expires PEName PEData\\n\");\n\telse {\n\t\tconst struct ip_vs_conn *cp = v;\n\t\tstruct net *net = seq_file_net(seq);\n\t\tchar pe_data[IP_VS_PENAME_MAXLEN + IP_VS_PEDATA_MAXLEN + 3];\n\t\tsize_t len = 0;\n\t\tchar dbuf[IP_VS_ADDRSTRLEN];\n\n\t\tif (!net_eq(cp->ipvs->net, net))\n\t\t\treturn 0;\n\t\tif (cp->pe_data) {\n\t\t\tpe_data[0] = ' ';\n\t\t\tlen = strlen(cp->pe->name);\n\t\t\tmemcpy(pe_data + 1, cp->pe->name, len);\n\t\t\tpe_data[len + 1] = ' ';\n\t\t\tlen += 2;\n\t\t\tlen += cp->pe->show_pe_data(cp, pe_data + len);\n\t\t}\n\t\tpe_data[len] = '\\0';\n\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (cp->daf == AF_INET6)\n\t\t\tsnprintf(dbuf, sizeof(dbuf), \"%pI6\", &cp->daddr.in6);\n\t\telse\n#endif\n\t\t\tsnprintf(dbuf, sizeof(dbuf), \"%08X\",\n\t\t\t\t ntohl(cp->daddr.ip));\n\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (cp->af == AF_INET6)\n\t\t\tseq_printf(seq, \"%-3s %pI6 %04X %pI6 %04X \"\n\t\t\t\t\"%s %04X %-11s %7u%s\\n\",\n\t\t\t\tip_vs_proto_name(cp->protocol),\n\t\t\t\t&cp->caddr.in6, ntohs(cp->cport),\n\t\t\t\t&cp->vaddr.in6, ntohs(cp->vport),\n\t\t\t\tdbuf, ntohs(cp->dport),\n\t\t\t\tip_vs_state_name(cp),\n\t\t\t\tjiffies_delta_to_msecs(cp->timer.expires -\n\t\t\t\t\t\t       jiffies) / 1000,\n\t\t\t\tpe_data);\n\t\telse\n#endif\n\t\t\tseq_printf(seq,\n\t\t\t\t\"%-3s %08X %04X %08X %04X\"\n\t\t\t\t\" %s %04X %-11s %7u%s\\n\",\n\t\t\t\tip_vs_proto_name(cp->protocol),\n\t\t\t\tntohl(cp->caddr.ip), ntohs(cp->cport),\n\t\t\t\tntohl(cp->vaddr.ip), ntohs(cp->vport),\n\t\t\t\tdbuf, ntohs(cp->dport),\n\t\t\t\tip_vs_state_name(cp),\n\t\t\t\tjiffies_delta_to_msecs(cp->timer.expires -\n\t\t\t\t\t\t       jiffies) / 1000,\n\t\t\t\tpe_data);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ip_vs_conn_seq_ops = {\n\t.start = ip_vs_conn_seq_start,\n\t.next  = ip_vs_conn_seq_next,\n\t.stop  = ip_vs_conn_seq_stop,\n\t.show  = ip_vs_conn_seq_show,\n};\n\nstatic const char *ip_vs_origin_name(unsigned int flags)\n{\n\tif (flags & IP_VS_CONN_F_SYNC)\n\t\treturn \"SYNC\";\n\telse\n\t\treturn \"LOCAL\";\n}\n\nstatic int ip_vs_conn_sync_seq_show(struct seq_file *seq, void *v)\n{\n\tchar dbuf[IP_VS_ADDRSTRLEN];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n   \"Pro FromIP   FPrt ToIP     TPrt DestIP   DPrt State       Origin Expires\\n\");\n\telse {\n\t\tconst struct ip_vs_conn *cp = v;\n\t\tstruct net *net = seq_file_net(seq);\n\n\t\tif (!net_eq(cp->ipvs->net, net))\n\t\t\treturn 0;\n\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (cp->daf == AF_INET6)\n\t\t\tsnprintf(dbuf, sizeof(dbuf), \"%pI6\", &cp->daddr.in6);\n\t\telse\n#endif\n\t\t\tsnprintf(dbuf, sizeof(dbuf), \"%08X\",\n\t\t\t\t ntohl(cp->daddr.ip));\n\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (cp->af == AF_INET6)\n\t\t\tseq_printf(seq, \"%-3s %pI6 %04X %pI6 %04X \"\n\t\t\t\t\"%s %04X %-11s %-6s %7u\\n\",\n\t\t\t\tip_vs_proto_name(cp->protocol),\n\t\t\t\t&cp->caddr.in6, ntohs(cp->cport),\n\t\t\t\t&cp->vaddr.in6, ntohs(cp->vport),\n\t\t\t\tdbuf, ntohs(cp->dport),\n\t\t\t\tip_vs_state_name(cp),\n\t\t\t\tip_vs_origin_name(cp->flags),\n\t\t\t\tjiffies_delta_to_msecs(cp->timer.expires -\n\t\t\t\t\t\t       jiffies) / 1000);\n\t\telse\n#endif\n\t\t\tseq_printf(seq,\n\t\t\t\t\"%-3s %08X %04X %08X %04X \"\n\t\t\t\t\"%s %04X %-11s %-6s %7u\\n\",\n\t\t\t\tip_vs_proto_name(cp->protocol),\n\t\t\t\tntohl(cp->caddr.ip), ntohs(cp->cport),\n\t\t\t\tntohl(cp->vaddr.ip), ntohs(cp->vport),\n\t\t\t\tdbuf, ntohs(cp->dport),\n\t\t\t\tip_vs_state_name(cp),\n\t\t\t\tip_vs_origin_name(cp->flags),\n\t\t\t\tjiffies_delta_to_msecs(cp->timer.expires -\n\t\t\t\t\t\t       jiffies) / 1000);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ip_vs_conn_sync_seq_ops = {\n\t.start = ip_vs_conn_seq_start,\n\t.next  = ip_vs_conn_seq_next,\n\t.stop  = ip_vs_conn_seq_stop,\n\t.show  = ip_vs_conn_sync_seq_show,\n};\n#endif\n\n\n \nstatic inline int todrop_entry(struct ip_vs_conn *cp)\n{\n\t \n\tstatic const signed char todrop_rate[9] = {0, 1, 2, 3, 4, 5, 6, 7, 8};\n\tstatic signed char todrop_counter[9] = {0};\n\tint i;\n\n\t \n\tif (time_before(cp->timeout + jiffies, cp->timer.expires + 60*HZ))\n\t\treturn 0;\n\n\t \n\ti = atomic_read(&cp->in_pkts);\n\tif (i > 8 || i < 0) return 0;\n\n\tif (!todrop_rate[i]) return 0;\n\tif (--todrop_counter[i] > 0) return 0;\n\n\ttodrop_counter[i] = todrop_rate[i];\n\treturn 1;\n}\n\nstatic inline bool ip_vs_conn_ops_mode(struct ip_vs_conn *cp)\n{\n\tstruct ip_vs_service *svc;\n\n\tif (!cp->dest)\n\t\treturn false;\n\tsvc = rcu_dereference(cp->dest->svc);\n\treturn svc && (svc->flags & IP_VS_SVC_F_ONEPACKET);\n}\n\n \nvoid ip_vs_random_dropentry(struct netns_ipvs *ipvs)\n{\n\tint idx;\n\tstruct ip_vs_conn *cp;\n\n\trcu_read_lock();\n\t \n\tfor (idx = 0; idx < (ip_vs_conn_tab_size>>5); idx++) {\n\t\tunsigned int hash = get_random_u32() & ip_vs_conn_tab_mask;\n\n\t\thlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[hash], c_list) {\n\t\t\tif (cp->ipvs != ipvs)\n\t\t\t\tcontinue;\n\t\t\tif (atomic_read(&cp->n_control))\n\t\t\t\tcontinue;\n\t\t\tif (cp->flags & IP_VS_CONN_F_TEMPLATE) {\n\t\t\t\t \n\t\t\t\tif (ip_vs_conn_ops_mode(cp))\n\t\t\t\t\tgoto try_drop;\n\t\t\t\tif (!(cp->state & IP_VS_CTPL_S_ASSURED))\n\t\t\t\t\tgoto drop;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cp->protocol == IPPROTO_TCP) {\n\t\t\t\tswitch(cp->state) {\n\t\t\t\tcase IP_VS_TCP_S_SYN_RECV:\n\t\t\t\tcase IP_VS_TCP_S_SYNACK:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IP_VS_TCP_S_ESTABLISHED:\n\t\t\t\t\tif (todrop_entry(cp))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (cp->protocol == IPPROTO_SCTP) {\n\t\t\t\tswitch (cp->state) {\n\t\t\t\tcase IP_VS_SCTP_S_INIT1:\n\t\t\t\tcase IP_VS_SCTP_S_INIT:\n\t\t\t\t\tbreak;\n\t\t\t\tcase IP_VS_SCTP_S_ESTABLISHED:\n\t\t\t\t\tif (todrop_entry(cp))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\ntry_drop:\n\t\t\t\tif (!todrop_entry(cp))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\ndrop:\n\t\t\tIP_VS_DBG(4, \"drop connection\\n\");\n\t\t\tip_vs_conn_del(cp);\n\t\t}\n\t\tcond_resched_rcu();\n\t}\n\trcu_read_unlock();\n}\n\n\n \nstatic void ip_vs_conn_flush(struct netns_ipvs *ipvs)\n{\n\tint idx;\n\tstruct ip_vs_conn *cp, *cp_c;\n\nflush_again:\n\trcu_read_lock();\n\tfor (idx = 0; idx < ip_vs_conn_tab_size; idx++) {\n\n\t\thlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[idx], c_list) {\n\t\t\tif (cp->ipvs != ipvs)\n\t\t\t\tcontinue;\n\t\t\tif (atomic_read(&cp->n_control))\n\t\t\t\tcontinue;\n\t\t\tcp_c = cp->control;\n\t\t\tIP_VS_DBG(4, \"del connection\\n\");\n\t\t\tip_vs_conn_del(cp);\n\t\t\tif (cp_c && !atomic_read(&cp_c->n_control)) {\n\t\t\t\tIP_VS_DBG(4, \"del controlling connection\\n\");\n\t\t\t\tip_vs_conn_del(cp_c);\n\t\t\t}\n\t\t}\n\t\tcond_resched_rcu();\n\t}\n\trcu_read_unlock();\n\n\t \n\tif (atomic_read(&ipvs->conn_count) != 0) {\n\t\tschedule();\n\t\tgoto flush_again;\n\t}\n}\n\n#ifdef CONFIG_SYSCTL\nvoid ip_vs_expire_nodest_conn_flush(struct netns_ipvs *ipvs)\n{\n\tint idx;\n\tstruct ip_vs_conn *cp, *cp_c;\n\tstruct ip_vs_dest *dest;\n\n\trcu_read_lock();\n\tfor (idx = 0; idx < ip_vs_conn_tab_size; idx++) {\n\t\thlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[idx], c_list) {\n\t\t\tif (cp->ipvs != ipvs)\n\t\t\t\tcontinue;\n\n\t\t\tdest = cp->dest;\n\t\t\tif (!dest || (dest->flags & IP_VS_DEST_F_AVAILABLE))\n\t\t\t\tcontinue;\n\n\t\t\tif (atomic_read(&cp->n_control))\n\t\t\t\tcontinue;\n\n\t\t\tcp_c = cp->control;\n\t\t\tIP_VS_DBG(4, \"del connection\\n\");\n\t\t\tip_vs_conn_del(cp);\n\t\t\tif (cp_c && !atomic_read(&cp_c->n_control)) {\n\t\t\t\tIP_VS_DBG(4, \"del controlling connection\\n\");\n\t\t\t\tip_vs_conn_del(cp_c);\n\t\t\t}\n\t\t}\n\t\tcond_resched_rcu();\n\n\t\t \n\t\tif (!ipvs->enable)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\n#endif\n\n \nint __net_init ip_vs_conn_net_init(struct netns_ipvs *ipvs)\n{\n\tatomic_set(&ipvs->conn_count, 0);\n\n#ifdef CONFIG_PROC_FS\n\tif (!proc_create_net(\"ip_vs_conn\", 0, ipvs->net->proc_net,\n\t\t\t     &ip_vs_conn_seq_ops,\n\t\t\t     sizeof(struct ip_vs_iter_state)))\n\t\tgoto err_conn;\n\n\tif (!proc_create_net(\"ip_vs_conn_sync\", 0, ipvs->net->proc_net,\n\t\t\t     &ip_vs_conn_sync_seq_ops,\n\t\t\t     sizeof(struct ip_vs_iter_state)))\n\t\tgoto err_conn_sync;\n#endif\n\n\treturn 0;\n\n#ifdef CONFIG_PROC_FS\nerr_conn_sync:\n\tremove_proc_entry(\"ip_vs_conn\", ipvs->net->proc_net);\nerr_conn:\n\treturn -ENOMEM;\n#endif\n}\n\nvoid __net_exit ip_vs_conn_net_cleanup(struct netns_ipvs *ipvs)\n{\n\t \n\tip_vs_conn_flush(ipvs);\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ip_vs_conn\", ipvs->net->proc_net);\n\tremove_proc_entry(\"ip_vs_conn_sync\", ipvs->net->proc_net);\n#endif\n}\n\nint __init ip_vs_conn_init(void)\n{\n\tsize_t tab_array_size;\n\tint max_avail;\n#if BITS_PER_LONG > 32\n\tint max = 27;\n#else\n\tint max = 20;\n#endif\n\tint min = 8;\n\tint idx;\n\n\tmax_avail = order_base_2(totalram_pages()) + PAGE_SHIFT;\n\tmax_avail -= 2;\t\t \n\tmax_avail -= 1;\t\t \n\tmax_avail -= order_base_2(sizeof(struct ip_vs_conn));\n\tmax = clamp(max, min, max_avail);\n\tip_vs_conn_tab_bits = clamp_val(ip_vs_conn_tab_bits, min, max);\n\tip_vs_conn_tab_size = 1 << ip_vs_conn_tab_bits;\n\tip_vs_conn_tab_mask = ip_vs_conn_tab_size - 1;\n\n\t \n\ttab_array_size = array_size(ip_vs_conn_tab_size,\n\t\t\t\t    sizeof(*ip_vs_conn_tab));\n\tip_vs_conn_tab = kvmalloc_array(ip_vs_conn_tab_size,\n\t\t\t\t\tsizeof(*ip_vs_conn_tab), GFP_KERNEL);\n\tif (!ip_vs_conn_tab)\n\t\treturn -ENOMEM;\n\n\t \n\tip_vs_conn_cachep = kmem_cache_create(\"ip_vs_conn\",\n\t\t\t\t\t      sizeof(struct ip_vs_conn), 0,\n\t\t\t\t\t      SLAB_HWCACHE_ALIGN, NULL);\n\tif (!ip_vs_conn_cachep) {\n\t\tkvfree(ip_vs_conn_tab);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_info(\"Connection hash table configured (size=%d, memory=%zdKbytes)\\n\",\n\t\tip_vs_conn_tab_size, tab_array_size / 1024);\n\tIP_VS_DBG(0, \"Each connection entry needs %zd bytes at least\\n\",\n\t\t  sizeof(struct ip_vs_conn));\n\n\tfor (idx = 0; idx < ip_vs_conn_tab_size; idx++)\n\t\tINIT_HLIST_HEAD(&ip_vs_conn_tab[idx]);\n\n\tfor (idx = 0; idx < CT_LOCKARRAY_SIZE; idx++)  {\n\t\tspin_lock_init(&__ip_vs_conntbl_lock_array[idx].l);\n\t}\n\n\t \n\tget_random_bytes(&ip_vs_conn_rnd, sizeof(ip_vs_conn_rnd));\n\n\treturn 0;\n}\n\nvoid ip_vs_conn_cleanup(void)\n{\n\t \n\trcu_barrier();\n\t \n\tkmem_cache_destroy(ip_vs_conn_cachep);\n\tkvfree(ip_vs_conn_tab);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}