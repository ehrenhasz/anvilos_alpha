{
  "module_name": "ip_vs_lblc.c",
  "hash_id": "ec3c079079fee416b8fef35fa851a5fe1969411753ac6e9168a4ac245de33325",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_lblc.c",
  "human_readable_source": "\n \n\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/jiffies.h>\n#include <linux/hash.h>\n\n \n#include <linux/fs.h>\n#include <linux/sysctl.h>\n\n#include <net/ip_vs.h>\n\n\n \n#define CHECK_EXPIRE_INTERVAL   (60*HZ)\n#define ENTRY_TIMEOUT           (6*60*HZ)\n\n#define DEFAULT_EXPIRATION\t(24*60*60*HZ)\n\n \n#define COUNT_FOR_FULL_EXPIRATION   30\n\n\n \n#ifndef CONFIG_IP_VS_LBLC_TAB_BITS\n#define CONFIG_IP_VS_LBLC_TAB_BITS      10\n#endif\n#define IP_VS_LBLC_TAB_BITS     CONFIG_IP_VS_LBLC_TAB_BITS\n#define IP_VS_LBLC_TAB_SIZE     (1 << IP_VS_LBLC_TAB_BITS)\n#define IP_VS_LBLC_TAB_MASK     (IP_VS_LBLC_TAB_SIZE - 1)\n\n\n \nstruct ip_vs_lblc_entry {\n\tstruct hlist_node\tlist;\n\tint\t\t\taf;\t\t \n\tunion nf_inet_addr      addr;            \n\tstruct ip_vs_dest\t*dest;           \n\tunsigned long           lastuse;         \n\tstruct rcu_head\t\trcu_head;\n};\n\n\n \nstruct ip_vs_lblc_table {\n\tstruct rcu_head\t\trcu_head;\n\tstruct hlist_head\tbucket[IP_VS_LBLC_TAB_SIZE];   \n\tstruct timer_list       periodic_timer;  \n\tstruct ip_vs_service\t*svc;\t\t \n\tatomic_t                entries;         \n\tint                     max_size;        \n\tint                     rover;           \n\tint                     counter;         \n\tbool\t\t\tdead;\n};\n\n\n \n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table vs_vars_table[] = {\n\t{\n\t\t.procname\t= \"lblc_expiration\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ }\n};\n#endif\n\nstatic void ip_vs_lblc_rcu_free(struct rcu_head *head)\n{\n\tstruct ip_vs_lblc_entry *en = container_of(head,\n\t\t\t\t\t\t   struct ip_vs_lblc_entry,\n\t\t\t\t\t\t   rcu_head);\n\n\tip_vs_dest_put_and_free(en->dest);\n\tkfree(en);\n}\n\nstatic inline void ip_vs_lblc_del(struct ip_vs_lblc_entry *en)\n{\n\thlist_del_rcu(&en->list);\n\tcall_rcu(&en->rcu_head, ip_vs_lblc_rcu_free);\n}\n\n \nstatic inline unsigned int\nip_vs_lblc_hashkey(int af, const union nf_inet_addr *addr)\n{\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\treturn hash_32(ntohl(addr_fold), IP_VS_LBLC_TAB_BITS);\n}\n\n\n \nstatic void\nip_vs_lblc_hash(struct ip_vs_lblc_table *tbl, struct ip_vs_lblc_entry *en)\n{\n\tunsigned int hash = ip_vs_lblc_hashkey(en->af, &en->addr);\n\n\thlist_add_head_rcu(&en->list, &tbl->bucket[hash]);\n\tatomic_inc(&tbl->entries);\n}\n\n\n \nstatic inline struct ip_vs_lblc_entry *\nip_vs_lblc_get(int af, struct ip_vs_lblc_table *tbl,\n\t       const union nf_inet_addr *addr)\n{\n\tunsigned int hash = ip_vs_lblc_hashkey(af, addr);\n\tstruct ip_vs_lblc_entry *en;\n\n\thlist_for_each_entry_rcu(en, &tbl->bucket[hash], list)\n\t\tif (ip_vs_addr_equal(af, &en->addr, addr))\n\t\t\treturn en;\n\n\treturn NULL;\n}\n\n\n \nstatic inline struct ip_vs_lblc_entry *\nip_vs_lblc_new(struct ip_vs_lblc_table *tbl, const union nf_inet_addr *daddr,\n\t       u16 af, struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_lblc_entry *en;\n\n\ten = ip_vs_lblc_get(af, tbl, daddr);\n\tif (en) {\n\t\tif (en->dest == dest)\n\t\t\treturn en;\n\t\tip_vs_lblc_del(en);\n\t}\n\ten = kmalloc(sizeof(*en), GFP_ATOMIC);\n\tif (!en)\n\t\treturn NULL;\n\n\ten->af = af;\n\tip_vs_addr_copy(af, &en->addr, daddr);\n\ten->lastuse = jiffies;\n\n\tip_vs_dest_hold(dest);\n\ten->dest = dest;\n\n\tip_vs_lblc_hash(tbl, en);\n\n\treturn en;\n}\n\n\n \nstatic void ip_vs_lblc_flush(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_lblc_table *tbl = svc->sched_data;\n\tstruct ip_vs_lblc_entry *en;\n\tstruct hlist_node *next;\n\tint i;\n\n\tspin_lock_bh(&svc->sched_lock);\n\ttbl->dead = true;\n\tfor (i = 0; i < IP_VS_LBLC_TAB_SIZE; i++) {\n\t\thlist_for_each_entry_safe(en, next, &tbl->bucket[i], list) {\n\t\t\tip_vs_lblc_del(en);\n\t\t\tatomic_dec(&tbl->entries);\n\t\t}\n\t}\n\tspin_unlock_bh(&svc->sched_lock);\n}\n\nstatic int sysctl_lblc_expiration(struct ip_vs_service *svc)\n{\n#ifdef CONFIG_SYSCTL\n\treturn svc->ipvs->sysctl_lblc_expiration;\n#else\n\treturn DEFAULT_EXPIRATION;\n#endif\n}\n\nstatic inline void ip_vs_lblc_full_check(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_lblc_table *tbl = svc->sched_data;\n\tstruct ip_vs_lblc_entry *en;\n\tstruct hlist_node *next;\n\tunsigned long now = jiffies;\n\tint i, j;\n\n\tfor (i = 0, j = tbl->rover; i < IP_VS_LBLC_TAB_SIZE; i++) {\n\t\tj = (j + 1) & IP_VS_LBLC_TAB_MASK;\n\n\t\tspin_lock(&svc->sched_lock);\n\t\thlist_for_each_entry_safe(en, next, &tbl->bucket[j], list) {\n\t\t\tif (time_before(now,\n\t\t\t\t\ten->lastuse +\n\t\t\t\t\tsysctl_lblc_expiration(svc)))\n\t\t\t\tcontinue;\n\n\t\t\tip_vs_lblc_del(en);\n\t\t\tatomic_dec(&tbl->entries);\n\t\t}\n\t\tspin_unlock(&svc->sched_lock);\n\t}\n\ttbl->rover = j;\n}\n\n\n \nstatic void ip_vs_lblc_check_expire(struct timer_list *t)\n{\n\tstruct ip_vs_lblc_table *tbl = from_timer(tbl, t, periodic_timer);\n\tstruct ip_vs_service *svc = tbl->svc;\n\tunsigned long now = jiffies;\n\tint goal;\n\tint i, j;\n\tstruct ip_vs_lblc_entry *en;\n\tstruct hlist_node *next;\n\n\tif ((tbl->counter % COUNT_FOR_FULL_EXPIRATION) == 0) {\n\t\t \n\t\tip_vs_lblc_full_check(svc);\n\t\ttbl->counter = 1;\n\t\tgoto out;\n\t}\n\n\tif (atomic_read(&tbl->entries) <= tbl->max_size) {\n\t\ttbl->counter++;\n\t\tgoto out;\n\t}\n\n\tgoal = (atomic_read(&tbl->entries) - tbl->max_size)*4/3;\n\tif (goal > tbl->max_size/2)\n\t\tgoal = tbl->max_size/2;\n\n\tfor (i = 0, j = tbl->rover; i < IP_VS_LBLC_TAB_SIZE; i++) {\n\t\tj = (j + 1) & IP_VS_LBLC_TAB_MASK;\n\n\t\tspin_lock(&svc->sched_lock);\n\t\thlist_for_each_entry_safe(en, next, &tbl->bucket[j], list) {\n\t\t\tif (time_before(now, en->lastuse + ENTRY_TIMEOUT))\n\t\t\t\tcontinue;\n\n\t\t\tip_vs_lblc_del(en);\n\t\t\tatomic_dec(&tbl->entries);\n\t\t\tgoal--;\n\t\t}\n\t\tspin_unlock(&svc->sched_lock);\n\t\tif (goal <= 0)\n\t\t\tbreak;\n\t}\n\ttbl->rover = j;\n\n  out:\n\tmod_timer(&tbl->periodic_timer, jiffies + CHECK_EXPIRE_INTERVAL);\n}\n\n\nstatic int ip_vs_lblc_init_svc(struct ip_vs_service *svc)\n{\n\tint i;\n\tstruct ip_vs_lblc_table *tbl;\n\n\t \n\ttbl = kmalloc(sizeof(*tbl), GFP_KERNEL);\n\tif (tbl == NULL)\n\t\treturn -ENOMEM;\n\n\tsvc->sched_data = tbl;\n\tIP_VS_DBG(6, \"LBLC hash table (memory=%zdbytes) allocated for \"\n\t\t  \"current service\\n\", sizeof(*tbl));\n\n\t \n\tfor (i = 0; i < IP_VS_LBLC_TAB_SIZE; i++) {\n\t\tINIT_HLIST_HEAD(&tbl->bucket[i]);\n\t}\n\ttbl->max_size = IP_VS_LBLC_TAB_SIZE*16;\n\ttbl->rover = 0;\n\ttbl->counter = 1;\n\ttbl->dead = false;\n\ttbl->svc = svc;\n\tatomic_set(&tbl->entries, 0);\n\n\t \n\ttimer_setup(&tbl->periodic_timer, ip_vs_lblc_check_expire, 0);\n\tmod_timer(&tbl->periodic_timer, jiffies + CHECK_EXPIRE_INTERVAL);\n\n\treturn 0;\n}\n\n\nstatic void ip_vs_lblc_done_svc(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_lblc_table *tbl = svc->sched_data;\n\n\t \n\ttimer_shutdown_sync(&tbl->periodic_timer);\n\n\t \n\tip_vs_lblc_flush(svc);\n\n\t \n\tkfree_rcu(tbl, rcu_head);\n\tIP_VS_DBG(6, \"LBLC hash table (memory=%zdbytes) released\\n\",\n\t\t  sizeof(*tbl));\n}\n\n\nstatic inline struct ip_vs_dest *\n__ip_vs_lblc_schedule(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dest *dest, *least;\n\tint loh, doh;\n\n\t \n\tlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\n\t\tif (dest->flags & IP_VS_DEST_F_OVERLOAD)\n\t\t\tcontinue;\n\t\tif (atomic_read(&dest->weight) > 0) {\n\t\t\tleast = dest;\n\t\t\tloh = ip_vs_dest_conn_overhead(least);\n\t\t\tgoto nextstage;\n\t\t}\n\t}\n\treturn NULL;\n\n\t \n  nextstage:\n\tlist_for_each_entry_continue_rcu(dest, &svc->destinations, n_list) {\n\t\tif (dest->flags & IP_VS_DEST_F_OVERLOAD)\n\t\t\tcontinue;\n\n\t\tdoh = ip_vs_dest_conn_overhead(dest);\n\t\tif ((__s64)loh * atomic_read(&dest->weight) >\n\t\t    (__s64)doh * atomic_read(&least->weight)) {\n\t\t\tleast = dest;\n\t\t\tloh = doh;\n\t\t}\n\t}\n\n\tIP_VS_DBG_BUF(6, \"LBLC: server %s:%d \"\n\t\t      \"activeconns %d refcnt %d weight %d overhead %d\\n\",\n\t\t      IP_VS_DBG_ADDR(least->af, &least->addr),\n\t\t      ntohs(least->port),\n\t\t      atomic_read(&least->activeconns),\n\t\t      refcount_read(&least->refcnt),\n\t\t      atomic_read(&least->weight), loh);\n\n\treturn least;\n}\n\n\n \nstatic inline int\nis_overloaded(struct ip_vs_dest *dest, struct ip_vs_service *svc)\n{\n\tif (atomic_read(&dest->activeconns) > atomic_read(&dest->weight)) {\n\t\tstruct ip_vs_dest *d;\n\n\t\tlist_for_each_entry_rcu(d, &svc->destinations, n_list) {\n\t\t\tif (atomic_read(&d->activeconns)*2\n\t\t\t    < atomic_read(&d->weight)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \nstatic struct ip_vs_dest *\nip_vs_lblc_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\n\t\t    struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_lblc_table *tbl = svc->sched_data;\n\tstruct ip_vs_dest *dest = NULL;\n\tstruct ip_vs_lblc_entry *en;\n\n\tIP_VS_DBG(6, \"%s(): Scheduling...\\n\", __func__);\n\n\t \n\ten = ip_vs_lblc_get(svc->af, tbl, &iph->daddr);\n\tif (en) {\n\t\t \n\t\ten->lastuse = jiffies;\n\n\t\t \n\n\t\tdest = en->dest;\n\t\tif ((dest->flags & IP_VS_DEST_F_AVAILABLE) &&\n\t\t    atomic_read(&dest->weight) > 0 && !is_overloaded(dest, svc))\n\t\t\tgoto out;\n\t}\n\n\t \n\tdest = __ip_vs_lblc_schedule(svc);\n\tif (!dest) {\n\t\tip_vs_scheduler_err(svc, \"no destination available\");\n\t\treturn NULL;\n\t}\n\n\t \n\tspin_lock_bh(&svc->sched_lock);\n\tif (!tbl->dead)\n\t\tip_vs_lblc_new(tbl, &iph->daddr, svc->af, dest);\n\tspin_unlock_bh(&svc->sched_lock);\n\nout:\n\tIP_VS_DBG_BUF(6, \"LBLC: destination IP address %s --> server %s:%d\\n\",\n\t\t      IP_VS_DBG_ADDR(svc->af, &iph->daddr),\n\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr), ntohs(dest->port));\n\n\treturn dest;\n}\n\n\n \nstatic struct ip_vs_scheduler ip_vs_lblc_scheduler = {\n\t.name =\t\t\t\"lblc\",\n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list =\t\tLIST_HEAD_INIT(ip_vs_lblc_scheduler.n_list),\n\t.init_service =\t\tip_vs_lblc_init_svc,\n\t.done_service =\t\tip_vs_lblc_done_svc,\n\t.schedule =\t\tip_vs_lblc_schedule,\n};\n\n \n#ifdef CONFIG_SYSCTL\nstatic int __net_init __ip_vs_lblc_init(struct net *net)\n{\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\tsize_t vars_table_size = ARRAY_SIZE(vs_vars_table);\n\n\tif (!ipvs)\n\t\treturn -ENOENT;\n\n\tif (!net_eq(net, &init_net)) {\n\t\tipvs->lblc_ctl_table = kmemdup(vs_vars_table,\n\t\t\t\t\t\tsizeof(vs_vars_table),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (ipvs->lblc_ctl_table == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tif (net->user_ns != &init_user_ns) {\n\t\t\tipvs->lblc_ctl_table[0].procname = NULL;\n\t\t\tvars_table_size = 0;\n\t\t}\n\n\t} else\n\t\tipvs->lblc_ctl_table = vs_vars_table;\n\tipvs->sysctl_lblc_expiration = DEFAULT_EXPIRATION;\n\tipvs->lblc_ctl_table[0].data = &ipvs->sysctl_lblc_expiration;\n\n\tipvs->lblc_ctl_header = register_net_sysctl_sz(net, \"net/ipv4/vs\",\n\t\t\t\t\t\t       ipvs->lblc_ctl_table,\n\t\t\t\t\t\t       vars_table_size);\n\tif (!ipvs->lblc_ctl_header) {\n\t\tif (!net_eq(net, &init_net))\n\t\t\tkfree(ipvs->lblc_ctl_table);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void __net_exit __ip_vs_lblc_exit(struct net *net)\n{\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tunregister_net_sysctl_table(ipvs->lblc_ctl_header);\n\n\tif (!net_eq(net, &init_net))\n\t\tkfree(ipvs->lblc_ctl_table);\n}\n\n#else\n\nstatic int __net_init __ip_vs_lblc_init(struct net *net) { return 0; }\nstatic void __net_exit __ip_vs_lblc_exit(struct net *net) { }\n\n#endif\n\nstatic struct pernet_operations ip_vs_lblc_ops = {\n\t.init = __ip_vs_lblc_init,\n\t.exit = __ip_vs_lblc_exit,\n};\n\nstatic int __init ip_vs_lblc_init(void)\n{\n\tint ret;\n\n\tret = register_pernet_subsys(&ip_vs_lblc_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_ip_vs_scheduler(&ip_vs_lblc_scheduler);\n\tif (ret)\n\t\tunregister_pernet_subsys(&ip_vs_lblc_ops);\n\treturn ret;\n}\n\nstatic void __exit ip_vs_lblc_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_lblc_scheduler);\n\tunregister_pernet_subsys(&ip_vs_lblc_ops);\n\trcu_barrier();\n}\n\n\nmodule_init(ip_vs_lblc_init);\nmodule_exit(ip_vs_lblc_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}