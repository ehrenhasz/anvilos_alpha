{
  "module_name": "ip_vs_xmit.c",
  "hash_id": "4cb8a40232b11351798b113015fb4d6fa3521502300853332f32987a4a58ba40",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_xmit.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/tcp.h>                   \n#include <net/ip.h>\n#include <net/gue.h>\n#include <net/gre.h>\n#include <net/tcp.h>                     \n#include <net/udp.h>\n#include <net/icmp.h>                    \n#include <net/route.h>                   \n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/ip_tunnels.h>\n#include <net/ip6_checksum.h>\n#include <net/addrconf.h>\n#include <linux/icmpv6.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n\n#include <net/ip_vs.h>\n\nenum {\n\tIP_VS_RT_MODE_LOCAL\t= 1,  \n\tIP_VS_RT_MODE_NON_LOCAL\t= 2,  \n\tIP_VS_RT_MODE_RDR\t= 4,  \n\tIP_VS_RT_MODE_CONNECT\t= 8,  \n\tIP_VS_RT_MODE_KNOWN_NH\t= 16, \n\tIP_VS_RT_MODE_TUNNEL\t= 32, \n};\n\nstatic inline struct ip_vs_dest_dst *ip_vs_dest_dst_alloc(void)\n{\n\treturn kmalloc(sizeof(struct ip_vs_dest_dst), GFP_ATOMIC);\n}\n\nstatic inline void ip_vs_dest_dst_free(struct ip_vs_dest_dst *dest_dst)\n{\n\tkfree(dest_dst);\n}\n\n \nstatic inline void\n__ip_vs_dst_set(struct ip_vs_dest *dest, struct ip_vs_dest_dst *dest_dst,\n\t\tstruct dst_entry *dst, u32 dst_cookie)\n{\n\tstruct ip_vs_dest_dst *old;\n\n\told = rcu_dereference_protected(dest->dest_dst,\n\t\t\t\t\tlockdep_is_held(&dest->dst_lock));\n\n\tif (dest_dst) {\n\t\tdest_dst->dst_cache = dst;\n\t\tdest_dst->dst_cookie = dst_cookie;\n\t}\n\trcu_assign_pointer(dest->dest_dst, dest_dst);\n\n\tif (old)\n\t\tcall_rcu(&old->rcu_head, ip_vs_dest_dst_rcu_free);\n}\n\nstatic inline struct ip_vs_dest_dst *\n__ip_vs_dst_check(struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_dest_dst *dest_dst = rcu_dereference(dest->dest_dst);\n\tstruct dst_entry *dst;\n\n\tif (!dest_dst)\n\t\treturn NULL;\n\tdst = dest_dst->dst_cache;\n\tif (dst->obsolete &&\n\t    dst->ops->check(dst, dest_dst->dst_cookie) == NULL)\n\t\treturn NULL;\n\treturn dest_dst;\n}\n\nstatic inline bool\n__mtu_check_toobig_v6(const struct sk_buff *skb, u32 mtu)\n{\n\tif (IP6CB(skb)->frag_max_size) {\n\t\t \n\t\tif (IP6CB(skb)->frag_max_size > mtu)\n\t\t\treturn true;  \n\t}\n\telse if (skb->len > mtu && !skb_is_gso(skb)) {\n\t\treturn true;  \n\t}\n\treturn false;\n}\n\n \nstatic struct rtable *do_output_route4(struct net *net, __be32 daddr,\n\t\t\t\t       int rt_mode, __be32 *saddr)\n{\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tbool loop = false;\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = daddr;\n\tfl4.flowi4_flags = (rt_mode & IP_VS_RT_MODE_KNOWN_NH) ?\n\t\t\t   FLOWI_FLAG_KNOWN_NH : 0;\n\nretry:\n\trt = ip_route_output_key(net, &fl4);\n\tif (IS_ERR(rt)) {\n\t\t \n\t\tif (PTR_ERR(rt) == -EINVAL && *saddr &&\n\t\t    rt_mode & IP_VS_RT_MODE_CONNECT && !loop) {\n\t\t\t*saddr = 0;\n\t\t\tflowi4_update_output(&fl4, 0, daddr, 0);\n\t\t\tgoto retry;\n\t\t}\n\t\tIP_VS_DBG_RL(\"ip_route_output error, dest: %pI4\\n\", &daddr);\n\t\treturn NULL;\n\t} else if (!*saddr && rt_mode & IP_VS_RT_MODE_CONNECT && fl4.saddr) {\n\t\tip_rt_put(rt);\n\t\t*saddr = fl4.saddr;\n\t\tflowi4_update_output(&fl4, 0, daddr, fl4.saddr);\n\t\tloop = true;\n\t\tgoto retry;\n\t}\n\t*saddr = fl4.saddr;\n\treturn rt;\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nstatic inline int __ip_vs_is_local_route6(struct rt6_info *rt)\n{\n\treturn rt->dst.dev && rt->dst.dev->flags & IFF_LOOPBACK;\n}\n#endif\n\nstatic inline bool crosses_local_route_boundary(int skb_af, struct sk_buff *skb,\n\t\t\t\t\t\tint rt_mode,\n\t\t\t\t\t\tbool new_rt_is_local)\n{\n\tbool rt_mode_allow_local = !!(rt_mode & IP_VS_RT_MODE_LOCAL);\n\tbool rt_mode_allow_non_local = !!(rt_mode & IP_VS_RT_MODE_NON_LOCAL);\n\tbool rt_mode_allow_redirect = !!(rt_mode & IP_VS_RT_MODE_RDR);\n\tbool source_is_loopback;\n\tbool old_rt_is_local;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (skb_af == AF_INET6) {\n\t\tint addr_type = ipv6_addr_type(&ipv6_hdr(skb)->saddr);\n\n\t\tsource_is_loopback =\n\t\t\t(!skb->dev || skb->dev->flags & IFF_LOOPBACK) &&\n\t\t\t(addr_type & IPV6_ADDR_LOOPBACK);\n\t\told_rt_is_local = __ip_vs_is_local_route6(\n\t\t\t(struct rt6_info *)skb_dst(skb));\n\t} else\n#endif\n\t{\n\t\tsource_is_loopback = ipv4_is_loopback(ip_hdr(skb)->saddr);\n\t\told_rt_is_local = skb_rtable(skb)->rt_flags & RTCF_LOCAL;\n\t}\n\n\tif (unlikely(new_rt_is_local)) {\n\t\tif (!rt_mode_allow_local)\n\t\t\treturn true;\n\t\tif (!rt_mode_allow_redirect && !old_rt_is_local)\n\t\t\treturn true;\n\t} else {\n\t\tif (!rt_mode_allow_non_local)\n\t\t\treturn true;\n\t\tif (source_is_loopback)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline void maybe_update_pmtu(int skb_af, struct sk_buff *skb, int mtu)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct rtable *ort = skb_rtable(skb);\n\n\tif (!skb->dev && sk && sk_fullsock(sk))\n\t\tort->dst.ops->update_pmtu(&ort->dst, sk, NULL, mtu, true);\n}\n\nstatic inline bool ensure_mtu_is_adequate(struct netns_ipvs *ipvs, int skb_af,\n\t\t\t\t\t  int rt_mode,\n\t\t\t\t\t  struct ip_vs_iphdr *ipvsh,\n\t\t\t\t\t  struct sk_buff *skb, int mtu)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (skb_af == AF_INET6) {\n\t\tstruct net *net = ipvs->net;\n\n\t\tif (unlikely(__mtu_check_toobig_v6(skb, mtu))) {\n\t\t\tif (!skb->dev)\n\t\t\t\tskb->dev = net->loopback_dev;\n\t\t\t \n\t\t\tif (!ipvsh->fragoffs && !ip_vs_iph_icmp(ipvsh))\n\t\t\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t\tIP_VS_DBG(1, \"frag needed for %pI6c\\n\",\n\t\t\t\t  &ipv6_hdr(skb)->saddr);\n\t\t\treturn false;\n\t\t}\n\t} else\n#endif\n\t{\n\t\t \n\t\tif ((rt_mode & IP_VS_RT_MODE_TUNNEL) && !sysctl_pmtu_disc(ipvs))\n\t\t\treturn true;\n\n\t\tif (unlikely(ip_hdr(skb)->frag_off & htons(IP_DF) &&\n\t\t\t     skb->len > mtu && !skb_is_gso(skb) &&\n\t\t\t     !ip_vs_iph_icmp(ipvsh))) {\n\t\t\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\n\t\t\t\t  htonl(mtu));\n\t\t\tIP_VS_DBG(1, \"frag needed for %pI4\\n\",\n\t\t\t\t  &ip_hdr(skb)->saddr);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic inline bool decrement_ttl(struct netns_ipvs *ipvs,\n\t\t\t\t int skb_af,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct net *net = ipvs->net;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (skb_af == AF_INET6) {\n\t\tstruct dst_entry *dst = skb_dst(skb);\n\n\t\t \n\t\tif (ipv6_hdr(skb)->hop_limit <= 1) {\n\t\t\tstruct inet6_dev *idev = __in6_dev_get_safely(skb->dev);\n\n\t\t\t \n\t\t\tskb->dev = dst->dev;\n\t\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED,\n\t\t\t\t    ICMPV6_EXC_HOPLIMIT, 0);\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tif (skb_ensure_writable(skb, sizeof(struct ipv6hdr)))\n\t\t\treturn false;\n\n\t\tipv6_hdr(skb)->hop_limit--;\n\t} else\n#endif\n\t{\n\t\tif (ip_hdr(skb)->ttl <= 1) {\n\t\t\t \n\t\t\tIP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tif (skb_ensure_writable(skb, sizeof(struct iphdr)))\n\t\t\treturn false;\n\n\t\t \n\t\tip_decrease_ttl(ip_hdr(skb));\n\t}\n\n\treturn true;\n}\n\n \nstatic int\n__ip_vs_get_out_rt(struct netns_ipvs *ipvs, int skb_af, struct sk_buff *skb,\n\t\t   struct ip_vs_dest *dest,\n\t\t   __be32 daddr, int rt_mode, __be32 *ret_saddr,\n\t\t   struct ip_vs_iphdr *ipvsh)\n{\n\tstruct net *net = ipvs->net;\n\tstruct ip_vs_dest_dst *dest_dst;\n\tstruct rtable *rt;\t\t\t \n\tint mtu;\n\tint local, noref = 1;\n\n\tif (dest) {\n\t\tdest_dst = __ip_vs_dst_check(dest);\n\t\tif (likely(dest_dst))\n\t\t\trt = (struct rtable *) dest_dst->dst_cache;\n\t\telse {\n\t\t\tdest_dst = ip_vs_dest_dst_alloc();\n\t\t\tspin_lock_bh(&dest->dst_lock);\n\t\t\tif (!dest_dst) {\n\t\t\t\t__ip_vs_dst_set(dest, NULL, NULL, 0);\n\t\t\t\tspin_unlock_bh(&dest->dst_lock);\n\t\t\t\tgoto err_unreach;\n\t\t\t}\n\t\t\trt = do_output_route4(net, dest->addr.ip, rt_mode,\n\t\t\t\t\t      &dest_dst->dst_saddr.ip);\n\t\t\tif (!rt) {\n\t\t\t\t__ip_vs_dst_set(dest, NULL, NULL, 0);\n\t\t\t\tspin_unlock_bh(&dest->dst_lock);\n\t\t\t\tip_vs_dest_dst_free(dest_dst);\n\t\t\t\tgoto err_unreach;\n\t\t\t}\n\t\t\t__ip_vs_dst_set(dest, dest_dst, &rt->dst, 0);\n\t\t\tspin_unlock_bh(&dest->dst_lock);\n\t\t\tIP_VS_DBG(10, \"new dst %pI4, src %pI4, refcnt=%d\\n\",\n\t\t\t\t  &dest->addr.ip, &dest_dst->dst_saddr.ip,\n\t\t\t\t  rcuref_read(&rt->dst.__rcuref));\n\t\t}\n\t\tif (ret_saddr)\n\t\t\t*ret_saddr = dest_dst->dst_saddr.ip;\n\t} else {\n\t\t__be32 saddr = htonl(INADDR_ANY);\n\n\t\tnoref = 0;\n\n\t\t \n\t\trt_mode &= ~IP_VS_RT_MODE_CONNECT;\n\t\trt = do_output_route4(net, daddr, rt_mode, &saddr);\n\t\tif (!rt)\n\t\t\tgoto err_unreach;\n\t\tif (ret_saddr)\n\t\t\t*ret_saddr = saddr;\n\t}\n\n\tlocal = (rt->rt_flags & RTCF_LOCAL) ? 1 : 0;\n\tif (unlikely(crosses_local_route_boundary(skb_af, skb, rt_mode,\n\t\t\t\t\t\t  local))) {\n\t\tIP_VS_DBG_RL(\"We are crossing local and non-local addresses\"\n\t\t\t     \" daddr=%pI4\\n\", &daddr);\n\t\tgoto err_put;\n\t}\n\n\tif (unlikely(local)) {\n\t\t \n\t\tif (!noref)\n\t\t\tip_rt_put(rt);\n\t\treturn local;\n\t}\n\n\tif (!decrement_ttl(ipvs, skb_af, skb))\n\t\tgoto err_put;\n\n\tif (likely(!(rt_mode & IP_VS_RT_MODE_TUNNEL))) {\n\t\tmtu = dst_mtu(&rt->dst);\n\t} else {\n\t\tmtu = dst_mtu(&rt->dst) - sizeof(struct iphdr);\n\t\tif (!dest)\n\t\t\tgoto err_put;\n\t\tif (dest->tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\t\tmtu -= sizeof(struct udphdr) + sizeof(struct guehdr);\n\t\t\tif ((dest->tun_flags &\n\t\t\t     IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM) &&\n\t\t\t    skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\t\tmtu -= GUE_PLEN_REMCSUM + GUE_LEN_PRIV;\n\t\t} else if (dest->tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GRE) {\n\t\t\t__be16 tflags = 0;\n\n\t\t\tif (dest->tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM)\n\t\t\t\ttflags |= TUNNEL_CSUM;\n\t\t\tmtu -= gre_calc_hlen(tflags);\n\t\t}\n\t\tif (mtu < 68) {\n\t\t\tIP_VS_DBG_RL(\"%s(): mtu less than 68\\n\", __func__);\n\t\t\tgoto err_put;\n\t\t}\n\t\tmaybe_update_pmtu(skb_af, skb, mtu);\n\t}\n\n\tif (!ensure_mtu_is_adequate(ipvs, skb_af, rt_mode, ipvsh, skb, mtu))\n\t\tgoto err_put;\n\n\tskb_dst_drop(skb);\n\tif (noref)\n\t\tskb_dst_set_noref(skb, &rt->dst);\n\telse\n\t\tskb_dst_set(skb, &rt->dst);\n\n\treturn local;\n\nerr_put:\n\tif (!noref)\n\t\tip_rt_put(rt);\n\treturn -1;\n\nerr_unreach:\n\tdst_link_failure(skb);\n\treturn -1;\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nstatic struct dst_entry *\n__ip_vs_route_output_v6(struct net *net, struct in6_addr *daddr,\n\t\t\tstruct in6_addr *ret_saddr, int do_xfrm, int rt_mode)\n{\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6 = {\n\t\t.daddr = *daddr,\n\t};\n\n\tif (rt_mode & IP_VS_RT_MODE_KNOWN_NH)\n\t\tfl6.flowi6_flags = FLOWI_FLAG_KNOWN_NH;\n\n\tdst = ip6_route_output(net, NULL, &fl6);\n\tif (dst->error)\n\t\tgoto out_err;\n\tif (!ret_saddr)\n\t\treturn dst;\n\tif (ipv6_addr_any(&fl6.saddr) &&\n\t    ipv6_dev_get_saddr(net, ip6_dst_idev(dst)->dev,\n\t\t\t       &fl6.daddr, 0, &fl6.saddr) < 0)\n\t\tgoto out_err;\n\tif (do_xfrm) {\n\t\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\n\t\tif (IS_ERR(dst)) {\n\t\t\tdst = NULL;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\t*ret_saddr = fl6.saddr;\n\treturn dst;\n\nout_err:\n\tdst_release(dst);\n\tIP_VS_DBG_RL(\"ip6_route_output error, dest: %pI6\\n\", daddr);\n\treturn NULL;\n}\n\n \nstatic int\n__ip_vs_get_out_rt_v6(struct netns_ipvs *ipvs, int skb_af, struct sk_buff *skb,\n\t\t      struct ip_vs_dest *dest,\n\t\t      struct in6_addr *daddr, struct in6_addr *ret_saddr,\n\t\t      struct ip_vs_iphdr *ipvsh, int do_xfrm, int rt_mode)\n{\n\tstruct net *net = ipvs->net;\n\tstruct ip_vs_dest_dst *dest_dst;\n\tstruct rt6_info *rt;\t\t\t \n\tstruct dst_entry *dst;\n\tint mtu;\n\tint local, noref = 1;\n\n\tif (dest) {\n\t\tdest_dst = __ip_vs_dst_check(dest);\n\t\tif (likely(dest_dst))\n\t\t\trt = (struct rt6_info *) dest_dst->dst_cache;\n\t\telse {\n\t\t\tu32 cookie;\n\n\t\t\tdest_dst = ip_vs_dest_dst_alloc();\n\t\t\tspin_lock_bh(&dest->dst_lock);\n\t\t\tif (!dest_dst) {\n\t\t\t\t__ip_vs_dst_set(dest, NULL, NULL, 0);\n\t\t\t\tspin_unlock_bh(&dest->dst_lock);\n\t\t\t\tgoto err_unreach;\n\t\t\t}\n\t\t\tdst = __ip_vs_route_output_v6(net, &dest->addr.in6,\n\t\t\t\t\t\t      &dest_dst->dst_saddr.in6,\n\t\t\t\t\t\t      do_xfrm, rt_mode);\n\t\t\tif (!dst) {\n\t\t\t\t__ip_vs_dst_set(dest, NULL, NULL, 0);\n\t\t\t\tspin_unlock_bh(&dest->dst_lock);\n\t\t\t\tip_vs_dest_dst_free(dest_dst);\n\t\t\t\tgoto err_unreach;\n\t\t\t}\n\t\t\trt = (struct rt6_info *) dst;\n\t\t\tcookie = rt6_get_cookie(rt);\n\t\t\t__ip_vs_dst_set(dest, dest_dst, &rt->dst, cookie);\n\t\t\tspin_unlock_bh(&dest->dst_lock);\n\t\t\tIP_VS_DBG(10, \"new dst %pI6, src %pI6, refcnt=%d\\n\",\n\t\t\t\t  &dest->addr.in6, &dest_dst->dst_saddr.in6,\n\t\t\t\t  rcuref_read(&rt->dst.__rcuref));\n\t\t}\n\t\tif (ret_saddr)\n\t\t\t*ret_saddr = dest_dst->dst_saddr.in6;\n\t} else {\n\t\tnoref = 0;\n\t\tdst = __ip_vs_route_output_v6(net, daddr, ret_saddr, do_xfrm,\n\t\t\t\t\t      rt_mode);\n\t\tif (!dst)\n\t\t\tgoto err_unreach;\n\t\trt = (struct rt6_info *) dst;\n\t}\n\n\tlocal = __ip_vs_is_local_route6(rt);\n\n\tif (unlikely(crosses_local_route_boundary(skb_af, skb, rt_mode,\n\t\t\t\t\t\t  local))) {\n\t\tIP_VS_DBG_RL(\"We are crossing local and non-local addresses\"\n\t\t\t     \" daddr=%pI6\\n\", daddr);\n\t\tgoto err_put;\n\t}\n\n\tif (unlikely(local)) {\n\t\t \n\t\tif (!noref)\n\t\t\tdst_release(&rt->dst);\n\t\treturn local;\n\t}\n\n\tif (!decrement_ttl(ipvs, skb_af, skb))\n\t\tgoto err_put;\n\n\t \n\tif (likely(!(rt_mode & IP_VS_RT_MODE_TUNNEL)))\n\t\tmtu = dst_mtu(&rt->dst);\n\telse {\n\t\tmtu = dst_mtu(&rt->dst) - sizeof(struct ipv6hdr);\n\t\tif (!dest)\n\t\t\tgoto err_put;\n\t\tif (dest->tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\t\tmtu -= sizeof(struct udphdr) + sizeof(struct guehdr);\n\t\t\tif ((dest->tun_flags &\n\t\t\t     IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM) &&\n\t\t\t    skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\t\tmtu -= GUE_PLEN_REMCSUM + GUE_LEN_PRIV;\n\t\t} else if (dest->tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GRE) {\n\t\t\t__be16 tflags = 0;\n\n\t\t\tif (dest->tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM)\n\t\t\t\ttflags |= TUNNEL_CSUM;\n\t\t\tmtu -= gre_calc_hlen(tflags);\n\t\t}\n\t\tif (mtu < IPV6_MIN_MTU) {\n\t\t\tIP_VS_DBG_RL(\"%s(): mtu less than %d\\n\", __func__,\n\t\t\t\t     IPV6_MIN_MTU);\n\t\t\tgoto err_put;\n\t\t}\n\t\tmaybe_update_pmtu(skb_af, skb, mtu);\n\t}\n\n\tif (!ensure_mtu_is_adequate(ipvs, skb_af, rt_mode, ipvsh, skb, mtu))\n\t\tgoto err_put;\n\n\tskb_dst_drop(skb);\n\tif (noref)\n\t\tskb_dst_set_noref(skb, &rt->dst);\n\telse\n\t\tskb_dst_set(skb, &rt->dst);\n\n\treturn local;\n\nerr_put:\n\tif (!noref)\n\t\tdst_release(&rt->dst);\n\treturn -1;\n\nerr_unreach:\n\t \n\tif (!skb->dev)\n\t\tskb->dev = skb_dst(skb)->dev;\n\n\tdst_link_failure(skb);\n\treturn -1;\n}\n#endif\n\n\n \nstatic inline int ip_vs_tunnel_xmit_prepare(struct sk_buff *skb,\n\t\t\t\t\t    struct ip_vs_conn *cp)\n{\n\tint ret = NF_ACCEPT;\n\n\tskb->ipvs_property = 1;\n\tif (unlikely(cp->flags & IP_VS_CONN_F_NFCT))\n\t\tret = ip_vs_confirm_conntrack(skb);\n\tif (ret == NF_ACCEPT) {\n\t\tnf_reset_ct(skb);\n\t\tskb_forward_csum(skb);\n\t\tif (skb->dev)\n\t\t\tskb_clear_tstamp(skb);\n\t}\n\treturn ret;\n}\n\n \nstatic inline void ip_vs_drop_early_demux_sk(struct sk_buff *skb)\n{\n\t \n\tif (skb->dev)\n\t\tskb_orphan(skb);\n}\n\n \nstatic inline int ip_vs_nat_send_or_cont(int pf, struct sk_buff *skb,\n\t\t\t\t\t struct ip_vs_conn *cp, int local)\n{\n\tint ret = NF_STOLEN;\n\n\tskb->ipvs_property = 1;\n\tif (likely(!(cp->flags & IP_VS_CONN_F_NFCT)))\n\t\tip_vs_notrack(skb);\n\telse\n\t\tip_vs_update_conntrack(skb, cp, 1);\n\n\t \n\tif (!local || cp->vport != cp->dport ||\n\t    !ip_vs_addr_equal(cp->af, &cp->vaddr, &cp->daddr))\n\t\tip_vs_drop_early_demux_sk(skb);\n\n\tif (!local) {\n\t\tskb_forward_csum(skb);\n\t\tif (skb->dev)\n\t\t\tskb_clear_tstamp(skb);\n\t\tNF_HOOK(pf, NF_INET_LOCAL_OUT, cp->ipvs->net, NULL, skb,\n\t\t\tNULL, skb_dst(skb)->dev, dst_output);\n\t} else\n\t\tret = NF_ACCEPT;\n\n\treturn ret;\n}\n\n \nstatic inline int ip_vs_send_or_cont(int pf, struct sk_buff *skb,\n\t\t\t\t     struct ip_vs_conn *cp, int local)\n{\n\tint ret = NF_STOLEN;\n\n\tskb->ipvs_property = 1;\n\tif (likely(!(cp->flags & IP_VS_CONN_F_NFCT)))\n\t\tip_vs_notrack(skb);\n\tif (!local) {\n\t\tip_vs_drop_early_demux_sk(skb);\n\t\tskb_forward_csum(skb);\n\t\tif (skb->dev)\n\t\t\tskb_clear_tstamp(skb);\n\t\tNF_HOOK(pf, NF_INET_LOCAL_OUT, cp->ipvs->net, NULL, skb,\n\t\t\tNULL, skb_dst(skb)->dev, dst_output);\n\t} else\n\t\tret = NF_ACCEPT;\n\treturn ret;\n}\n\n\n \nint\nip_vs_null_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\tstruct ip_vs_protocol *pp, struct ip_vs_iphdr *ipvsh)\n{\n\t \n\treturn ip_vs_send_or_cont(NFPROTO_IPV4, skb, cp, 1);\n}\n\n\n \nint\nip_vs_bypass_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t  struct ip_vs_protocol *pp, struct ip_vs_iphdr *ipvsh)\n{\n\tstruct iphdr  *iph = ip_hdr(skb);\n\n\tif (__ip_vs_get_out_rt(cp->ipvs, cp->af, skb, NULL, iph->daddr,\n\t\t\t       IP_VS_RT_MODE_NON_LOCAL, NULL, ipvsh) < 0)\n\t\tgoto tx_error;\n\n\tip_send_check(iph);\n\n\t \n\tskb->ignore_df = 1;\n\n\tip_vs_send_or_cont(NFPROTO_IPV4, skb, cp, 0);\n\n\treturn NF_STOLEN;\n\n tx_error:\n\tkfree_skb(skb);\n\treturn NF_STOLEN;\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nint\nip_vs_bypass_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t     struct ip_vs_protocol *pp, struct ip_vs_iphdr *ipvsh)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\n\tif (__ip_vs_get_out_rt_v6(cp->ipvs, cp->af, skb, NULL,\n\t\t\t\t  &iph->daddr, NULL,\n\t\t\t\t  ipvsh, 0, IP_VS_RT_MODE_NON_LOCAL) < 0)\n\t\tgoto tx_error;\n\n\t \n\tskb->ignore_df = 1;\n\n\tip_vs_send_or_cont(NFPROTO_IPV6, skb, cp, 0);\n\n\treturn NF_STOLEN;\n\n tx_error:\n\tkfree_skb(skb);\n\treturn NF_STOLEN;\n}\n#endif\n\n \nint\nip_vs_nat_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t       struct ip_vs_protocol *pp, struct ip_vs_iphdr *ipvsh)\n{\n\tstruct rtable *rt;\t\t \n\tint local, rc, was_input;\n\n\t \n\tif (unlikely(cp->flags & IP_VS_CONN_F_NO_CPORT)) {\n\t\t__be16 _pt, *p;\n\n\t\tp = skb_header_pointer(skb, ipvsh->len, sizeof(_pt), &_pt);\n\t\tif (p == NULL)\n\t\t\tgoto tx_error;\n\t\tip_vs_conn_fill_cport(cp, *p);\n\t\tIP_VS_DBG(10, \"filled cport=%d\\n\", ntohs(*p));\n\t}\n\n\twas_input = rt_is_input_route(skb_rtable(skb));\n\tlocal = __ip_vs_get_out_rt(cp->ipvs, cp->af, skb, cp->dest, cp->daddr.ip,\n\t\t\t\t   IP_VS_RT_MODE_LOCAL |\n\t\t\t\t   IP_VS_RT_MODE_NON_LOCAL |\n\t\t\t\t   IP_VS_RT_MODE_RDR, NULL, ipvsh);\n\tif (local < 0)\n\t\tgoto tx_error;\n\trt = skb_rtable(skb);\n\t \n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (cp->flags & IP_VS_CONN_F_SYNC && local) {\n\t\tenum ip_conntrack_info ctinfo;\n\t\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\n\t\tif (ct) {\n\t\t\tIP_VS_DBG_RL_PKT(10, AF_INET, pp, skb, ipvsh->off,\n\t\t\t\t\t \"ip_vs_nat_xmit(): \"\n\t\t\t\t\t \"stopping DNAT to local address\");\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n#endif\n\n\t \n\tif (local && ipv4_is_loopback(cp->daddr.ip) && was_input) {\n\t\tIP_VS_DBG_RL_PKT(1, AF_INET, pp, skb, ipvsh->off,\n\t\t\t\t \"ip_vs_nat_xmit(): stopping DNAT to loopback \"\n\t\t\t\t \"address\");\n\t\tgoto tx_error;\n\t}\n\n\t \n\tif (skb_ensure_writable(skb, sizeof(struct iphdr)))\n\t\tgoto tx_error;\n\n\tif (skb_cow(skb, rt->dst.dev->hard_header_len))\n\t\tgoto tx_error;\n\n\t \n\tif (pp->dnat_handler && !pp->dnat_handler(skb, pp, cp, ipvsh))\n\t\tgoto tx_error;\n\tip_hdr(skb)->daddr = cp->daddr.ip;\n\tip_send_check(ip_hdr(skb));\n\n\tIP_VS_DBG_PKT(10, AF_INET, pp, skb, ipvsh->off, \"After DNAT\");\n\n\t \n\n\t \n\tskb->ignore_df = 1;\n\n\trc = ip_vs_nat_send_or_cont(NFPROTO_IPV4, skb, cp, local);\n\n\treturn rc;\n\n  tx_error:\n\tkfree_skb(skb);\n\treturn NF_STOLEN;\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nint\nip_vs_nat_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t  struct ip_vs_protocol *pp, struct ip_vs_iphdr *ipvsh)\n{\n\tstruct rt6_info *rt;\t\t \n\tint local, rc;\n\n\t \n\tif (unlikely(cp->flags & IP_VS_CONN_F_NO_CPORT && !ipvsh->fragoffs)) {\n\t\t__be16 _pt, *p;\n\t\tp = skb_header_pointer(skb, ipvsh->len, sizeof(_pt), &_pt);\n\t\tif (p == NULL)\n\t\t\tgoto tx_error;\n\t\tip_vs_conn_fill_cport(cp, *p);\n\t\tIP_VS_DBG(10, \"filled cport=%d\\n\", ntohs(*p));\n\t}\n\n\tlocal = __ip_vs_get_out_rt_v6(cp->ipvs, cp->af, skb, cp->dest,\n\t\t\t\t      &cp->daddr.in6,\n\t\t\t\t      NULL, ipvsh, 0,\n\t\t\t\t      IP_VS_RT_MODE_LOCAL |\n\t\t\t\t      IP_VS_RT_MODE_NON_LOCAL |\n\t\t\t\t      IP_VS_RT_MODE_RDR);\n\tif (local < 0)\n\t\tgoto tx_error;\n\trt = (struct rt6_info *) skb_dst(skb);\n\t \n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (cp->flags & IP_VS_CONN_F_SYNC && local) {\n\t\tenum ip_conntrack_info ctinfo;\n\t\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\n\t\tif (ct) {\n\t\t\tIP_VS_DBG_RL_PKT(10, AF_INET6, pp, skb, ipvsh->off,\n\t\t\t\t\t \"ip_vs_nat_xmit_v6(): \"\n\t\t\t\t\t \"stopping DNAT to local address\");\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n#endif\n\n\t \n\tif (local && skb->dev && !(skb->dev->flags & IFF_LOOPBACK) &&\n\t    ipv6_addr_type(&cp->daddr.in6) & IPV6_ADDR_LOOPBACK) {\n\t\tIP_VS_DBG_RL_PKT(1, AF_INET6, pp, skb, ipvsh->off,\n\t\t\t\t \"ip_vs_nat_xmit_v6(): \"\n\t\t\t\t \"stopping DNAT to loopback address\");\n\t\tgoto tx_error;\n\t}\n\n\t \n\tif (skb_ensure_writable(skb, sizeof(struct ipv6hdr)))\n\t\tgoto tx_error;\n\n\tif (skb_cow(skb, rt->dst.dev->hard_header_len))\n\t\tgoto tx_error;\n\n\t \n\tif (pp->dnat_handler && !pp->dnat_handler(skb, pp, cp, ipvsh))\n\t\tgoto tx_error;\n\tipv6_hdr(skb)->daddr = cp->daddr.in6;\n\n\tIP_VS_DBG_PKT(10, AF_INET6, pp, skb, ipvsh->off, \"After DNAT\");\n\n\t \n\n\t \n\tskb->ignore_df = 1;\n\n\trc = ip_vs_nat_send_or_cont(NFPROTO_IPV6, skb, cp, local);\n\n\treturn rc;\n\ntx_error:\n\tkfree_skb(skb);\n\treturn NF_STOLEN;\n}\n#endif\n\n \nstatic struct sk_buff *\nip_vs_prepare_tunneled_skb(struct sk_buff *skb, int skb_af,\n\t\t\t   unsigned int max_headroom, __u8 *next_protocol,\n\t\t\t   __u32 *payload_len, __u8 *dsfield, __u8 *ttl,\n\t\t\t   __be16 *df)\n{\n\tstruct sk_buff *new_skb = NULL;\n\tstruct iphdr *old_iph = NULL;\n\t__u8 old_dsfield;\n#ifdef CONFIG_IP_VS_IPV6\n\tstruct ipv6hdr *old_ipv6h = NULL;\n#endif\n\n\tip_vs_drop_early_demux_sk(skb);\n\n\tif (skb_headroom(skb) < max_headroom || skb_cloned(skb)) {\n\t\tnew_skb = skb_realloc_headroom(skb, max_headroom);\n\t\tif (!new_skb)\n\t\t\tgoto error;\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tconsume_skb(skb);\n\t\tskb = new_skb;\n\t}\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (skb_af == AF_INET6) {\n\t\told_ipv6h = ipv6_hdr(skb);\n\t\t*next_protocol = IPPROTO_IPV6;\n\t\tif (payload_len)\n\t\t\t*payload_len =\n\t\t\t\tntohs(old_ipv6h->payload_len) +\n\t\t\t\tsizeof(*old_ipv6h);\n\t\told_dsfield = ipv6_get_dsfield(old_ipv6h);\n\t\t*ttl = old_ipv6h->hop_limit;\n\t\tif (df)\n\t\t\t*df = 0;\n\t} else\n#endif\n\t{\n\t\told_iph = ip_hdr(skb);\n\t\t \n\t\tif (df)\n\t\t\t*df = (old_iph->frag_off & htons(IP_DF));\n\t\t*next_protocol = IPPROTO_IPIP;\n\n\t\t \n\t\tip_send_check(old_iph);\n\t\told_dsfield = ipv4_get_dsfield(old_iph);\n\t\t*ttl = old_iph->ttl;\n\t\tif (payload_len)\n\t\t\t*payload_len = skb_ip_totlen(skb);\n\t}\n\n\t \n\t*dsfield = INET_ECN_encapsulate(old_dsfield, old_dsfield);\n\n\treturn skb;\nerror:\n\tkfree_skb(skb);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic inline int __tun_gso_type_mask(int encaps_af, int orig_af)\n{\n\tswitch (encaps_af) {\n\tcase AF_INET:\n\t\treturn SKB_GSO_IPXIP4;\n\tcase AF_INET6:\n\t\treturn SKB_GSO_IPXIP6;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nipvs_gue_encap(struct net *net, struct sk_buff *skb,\n\t       struct ip_vs_conn *cp, __u8 *next_protocol)\n{\n\t__be16 dport;\n\t__be16 sport = udp_flow_src_port(net, skb, 0, 0, false);\n\tstruct udphdr  *udph;\t \n\tstruct guehdr  *gueh;\t \n\tsize_t hdrlen, optlen = 0;\n\tvoid *data;\n\tbool need_priv = false;\n\n\tif ((cp->dest->tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM) &&\n\t    skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\toptlen += GUE_PLEN_REMCSUM + GUE_LEN_PRIV;\n\t\tneed_priv = true;\n\t}\n\n\thdrlen = sizeof(struct guehdr) + optlen;\n\n\tskb_push(skb, hdrlen);\n\n\tgueh = (struct guehdr *)skb->data;\n\n\tgueh->control = 0;\n\tgueh->version = 0;\n\tgueh->hlen = optlen >> 2;\n\tgueh->flags = 0;\n\tgueh->proto_ctype = *next_protocol;\n\n\tdata = &gueh[1];\n\n\tif (need_priv) {\n\t\t__be32 *flags = data;\n\t\tu16 csum_start = skb_checksum_start_offset(skb);\n\t\t__be16 *pd;\n\n\t\tgueh->flags |= GUE_FLAG_PRIV;\n\t\t*flags = 0;\n\t\tdata += GUE_LEN_PRIV;\n\n\t\tif (csum_start < hdrlen)\n\t\t\treturn -EINVAL;\n\n\t\tcsum_start -= hdrlen;\n\t\tpd = data;\n\t\tpd[0] = htons(csum_start);\n\t\tpd[1] = htons(csum_start + skb->csum_offset);\n\n\t\tif (!skb_is_gso(skb)) {\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->encapsulation = 0;\n\t\t}\n\n\t\t*flags |= GUE_PFLAG_REMCSUM;\n\t\tdata += GUE_PLEN_REMCSUM;\n\t}\n\n\tskb_push(skb, sizeof(struct udphdr));\n\tskb_reset_transport_header(skb);\n\n\tudph = udp_hdr(skb);\n\n\tdport = cp->dest->tun_port;\n\tudph->dest = dport;\n\tudph->source = sport;\n\tudph->len = htons(skb->len);\n\tudph->check = 0;\n\n\t*next_protocol = IPPROTO_UDP;\n\n\treturn 0;\n}\n\nstatic void\nipvs_gre_encap(struct net *net, struct sk_buff *skb,\n\t       struct ip_vs_conn *cp, __u8 *next_protocol)\n{\n\t__be16 proto = *next_protocol == IPPROTO_IPIP ?\n\t\t\t\thtons(ETH_P_IP) : htons(ETH_P_IPV6);\n\t__be16 tflags = 0;\n\tsize_t hdrlen;\n\n\tif (cp->dest->tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM)\n\t\ttflags |= TUNNEL_CSUM;\n\n\thdrlen = gre_calc_hlen(tflags);\n\tgre_build_header(skb, hdrlen, tflags, proto, 0, 0);\n\n\t*next_protocol = IPPROTO_GRE;\n}\n\n \nint\nip_vs_tunnel_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t  struct ip_vs_protocol *pp, struct ip_vs_iphdr *ipvsh)\n{\n\tstruct netns_ipvs *ipvs = cp->ipvs;\n\tstruct net *net = ipvs->net;\n\tstruct rtable *rt;\t\t\t \n\t__be32 saddr;\t\t\t\t \n\tstruct net_device *tdev;\t\t \n\t__u8 next_protocol = 0;\n\t__u8 dsfield = 0;\n\t__u8 ttl = 0;\n\t__be16 df = 0;\n\t__be16 *dfp = NULL;\n\tstruct iphdr  *iph;\t\t\t \n\tunsigned int max_headroom;\t\t \n\tint ret, local;\n\tint tun_type, gso_type;\n\tint tun_flags;\n\n\tlocal = __ip_vs_get_out_rt(ipvs, cp->af, skb, cp->dest, cp->daddr.ip,\n\t\t\t\t   IP_VS_RT_MODE_LOCAL |\n\t\t\t\t   IP_VS_RT_MODE_NON_LOCAL |\n\t\t\t\t   IP_VS_RT_MODE_CONNECT |\n\t\t\t\t   IP_VS_RT_MODE_TUNNEL, &saddr, ipvsh);\n\tif (local < 0)\n\t\tgoto tx_error;\n\tif (local)\n\t\treturn ip_vs_send_or_cont(NFPROTO_IPV4, skb, cp, 1);\n\n\trt = skb_rtable(skb);\n\ttdev = rt->dst.dev;\n\n\t \n\tmax_headroom = LL_RESERVED_SPACE(tdev) + sizeof(struct iphdr);\n\n\ttun_type = cp->dest->tun_type;\n\ttun_flags = cp->dest->tun_flags;\n\n\tif (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\tsize_t gue_hdrlen, gue_optlen = 0;\n\n\t\tif ((tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM) &&\n\t\t    skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tgue_optlen += GUE_PLEN_REMCSUM + GUE_LEN_PRIV;\n\t\t}\n\t\tgue_hdrlen = sizeof(struct guehdr) + gue_optlen;\n\n\t\tmax_headroom += sizeof(struct udphdr) + gue_hdrlen;\n\t} else if (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GRE) {\n\t\tsize_t gre_hdrlen;\n\t\t__be16 tflags = 0;\n\n\t\tif (tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM)\n\t\t\ttflags |= TUNNEL_CSUM;\n\t\tgre_hdrlen = gre_calc_hlen(tflags);\n\n\t\tmax_headroom += gre_hdrlen;\n\t}\n\n\t \n\tdfp = sysctl_pmtu_disc(ipvs) ? &df : NULL;\n\tskb = ip_vs_prepare_tunneled_skb(skb, cp->af, max_headroom,\n\t\t\t\t\t &next_protocol, NULL, &dsfield,\n\t\t\t\t\t &ttl, dfp);\n\tif (IS_ERR(skb))\n\t\treturn NF_STOLEN;\n\n\tgso_type = __tun_gso_type_mask(AF_INET, cp->af);\n\tif (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\tif ((tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM) ||\n\t\t    (tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM))\n\t\t\tgso_type |= SKB_GSO_UDP_TUNNEL_CSUM;\n\t\telse\n\t\t\tgso_type |= SKB_GSO_UDP_TUNNEL;\n\t\tif ((tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM) &&\n\t\t    skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tgso_type |= SKB_GSO_TUNNEL_REMCSUM;\n\t\t}\n\t} else if (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GRE) {\n\t\tif (tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM)\n\t\t\tgso_type |= SKB_GSO_GRE_CSUM;\n\t\telse\n\t\t\tgso_type |= SKB_GSO_GRE;\n\t}\n\n\tif (iptunnel_handle_offloads(skb, gso_type))\n\t\tgoto tx_error;\n\n\tskb->transport_header = skb->network_header;\n\n\tskb_set_inner_ipproto(skb, next_protocol);\n\tskb_set_inner_mac_header(skb, skb_inner_network_offset(skb));\n\n\tif (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\tbool check = false;\n\n\t\tif (ipvs_gue_encap(net, skb, cp, &next_protocol))\n\t\t\tgoto tx_error;\n\n\t\tif ((tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM) ||\n\t\t    (tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM))\n\t\t\tcheck = true;\n\n\t\tudp_set_csum(!check, skb, saddr, cp->daddr.ip, skb->len);\n\t} else if (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GRE)\n\t\tipvs_gre_encap(net, skb, cp, &next_protocol);\n\n\tskb_push(skb, sizeof(struct iphdr));\n\tskb_reset_network_header(skb);\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\n\t \n\tiph\t\t\t=\tip_hdr(skb);\n\tiph->version\t\t=\t4;\n\tiph->ihl\t\t=\tsizeof(struct iphdr)>>2;\n\tiph->frag_off\t\t=\tdf;\n\tiph->protocol\t\t=\tnext_protocol;\n\tiph->tos\t\t=\tdsfield;\n\tiph->daddr\t\t=\tcp->daddr.ip;\n\tiph->saddr\t\t=\tsaddr;\n\tiph->ttl\t\t=\tttl;\n\tip_select_ident(net, skb, NULL);\n\n\t \n\tskb->ignore_df = 1;\n\n\tret = ip_vs_tunnel_xmit_prepare(skb, cp);\n\tif (ret == NF_ACCEPT)\n\t\tip_local_out(net, skb->sk, skb);\n\telse if (ret == NF_DROP)\n\t\tkfree_skb(skb);\n\n\treturn NF_STOLEN;\n\n  tx_error:\n\tkfree_skb(skb);\n\treturn NF_STOLEN;\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nint\nip_vs_tunnel_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t     struct ip_vs_protocol *pp, struct ip_vs_iphdr *ipvsh)\n{\n\tstruct netns_ipvs *ipvs = cp->ipvs;\n\tstruct net *net = ipvs->net;\n\tstruct rt6_info *rt;\t\t \n\tstruct in6_addr saddr;\t\t \n\tstruct net_device *tdev;\t \n\t__u8 next_protocol = 0;\n\t__u32 payload_len = 0;\n\t__u8 dsfield = 0;\n\t__u8 ttl = 0;\n\tstruct ipv6hdr  *iph;\t\t \n\tunsigned int max_headroom;\t \n\tint ret, local;\n\tint tun_type, gso_type;\n\tint tun_flags;\n\n\tlocal = __ip_vs_get_out_rt_v6(ipvs, cp->af, skb, cp->dest,\n\t\t\t\t      &cp->daddr.in6,\n\t\t\t\t      &saddr, ipvsh, 1,\n\t\t\t\t      IP_VS_RT_MODE_LOCAL |\n\t\t\t\t      IP_VS_RT_MODE_NON_LOCAL |\n\t\t\t\t      IP_VS_RT_MODE_TUNNEL);\n\tif (local < 0)\n\t\tgoto tx_error;\n\tif (local)\n\t\treturn ip_vs_send_or_cont(NFPROTO_IPV6, skb, cp, 1);\n\n\trt = (struct rt6_info *) skb_dst(skb);\n\ttdev = rt->dst.dev;\n\n\t \n\tmax_headroom = LL_RESERVED_SPACE(tdev) + sizeof(struct ipv6hdr);\n\n\ttun_type = cp->dest->tun_type;\n\ttun_flags = cp->dest->tun_flags;\n\n\tif (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\tsize_t gue_hdrlen, gue_optlen = 0;\n\n\t\tif ((tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM) &&\n\t\t    skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tgue_optlen += GUE_PLEN_REMCSUM + GUE_LEN_PRIV;\n\t\t}\n\t\tgue_hdrlen = sizeof(struct guehdr) + gue_optlen;\n\n\t\tmax_headroom += sizeof(struct udphdr) + gue_hdrlen;\n\t} else if (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GRE) {\n\t\tsize_t gre_hdrlen;\n\t\t__be16 tflags = 0;\n\n\t\tif (tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM)\n\t\t\ttflags |= TUNNEL_CSUM;\n\t\tgre_hdrlen = gre_calc_hlen(tflags);\n\n\t\tmax_headroom += gre_hdrlen;\n\t}\n\n\tskb = ip_vs_prepare_tunneled_skb(skb, cp->af, max_headroom,\n\t\t\t\t\t &next_protocol, &payload_len,\n\t\t\t\t\t &dsfield, &ttl, NULL);\n\tif (IS_ERR(skb))\n\t\treturn NF_STOLEN;\n\n\tgso_type = __tun_gso_type_mask(AF_INET6, cp->af);\n\tif (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\tif ((tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM) ||\n\t\t    (tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM))\n\t\t\tgso_type |= SKB_GSO_UDP_TUNNEL_CSUM;\n\t\telse\n\t\t\tgso_type |= SKB_GSO_UDP_TUNNEL;\n\t\tif ((tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM) &&\n\t\t    skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tgso_type |= SKB_GSO_TUNNEL_REMCSUM;\n\t\t}\n\t} else if (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GRE) {\n\t\tif (tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM)\n\t\t\tgso_type |= SKB_GSO_GRE_CSUM;\n\t\telse\n\t\t\tgso_type |= SKB_GSO_GRE;\n\t}\n\n\tif (iptunnel_handle_offloads(skb, gso_type))\n\t\tgoto tx_error;\n\n\tskb->transport_header = skb->network_header;\n\n\tskb_set_inner_ipproto(skb, next_protocol);\n\tskb_set_inner_mac_header(skb, skb_inner_network_offset(skb));\n\n\tif (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\tbool check = false;\n\n\t\tif (ipvs_gue_encap(net, skb, cp, &next_protocol))\n\t\t\tgoto tx_error;\n\n\t\tif ((tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_CSUM) ||\n\t\t    (tun_flags & IP_VS_TUNNEL_ENCAP_FLAG_REMCSUM))\n\t\t\tcheck = true;\n\n\t\tudp6_set_csum(!check, skb, &saddr, &cp->daddr.in6, skb->len);\n\t} else if (tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GRE)\n\t\tipvs_gre_encap(net, skb, cp, &next_protocol);\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\n\t \n\tiph\t\t\t=\tipv6_hdr(skb);\n\tiph->version\t\t=\t6;\n\tiph->nexthdr\t\t=\tnext_protocol;\n\tiph->payload_len\t=\thtons(payload_len);\n\tmemset(&iph->flow_lbl, 0, sizeof(iph->flow_lbl));\n\tipv6_change_dsfield(iph, 0, dsfield);\n\tiph->daddr = cp->daddr.in6;\n\tiph->saddr = saddr;\n\tiph->hop_limit\t\t=\tttl;\n\n\t \n\tskb->ignore_df = 1;\n\n\tret = ip_vs_tunnel_xmit_prepare(skb, cp);\n\tif (ret == NF_ACCEPT)\n\t\tip6_local_out(net, skb->sk, skb);\n\telse if (ret == NF_DROP)\n\t\tkfree_skb(skb);\n\n\treturn NF_STOLEN;\n\ntx_error:\n\tkfree_skb(skb);\n\treturn NF_STOLEN;\n}\n#endif\n\n\n \nint\nip_vs_dr_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t      struct ip_vs_protocol *pp, struct ip_vs_iphdr *ipvsh)\n{\n\tint local;\n\n\tlocal = __ip_vs_get_out_rt(cp->ipvs, cp->af, skb, cp->dest, cp->daddr.ip,\n\t\t\t\t   IP_VS_RT_MODE_LOCAL |\n\t\t\t\t   IP_VS_RT_MODE_NON_LOCAL |\n\t\t\t\t   IP_VS_RT_MODE_KNOWN_NH, NULL, ipvsh);\n\tif (local < 0)\n\t\tgoto tx_error;\n\tif (local)\n\t\treturn ip_vs_send_or_cont(NFPROTO_IPV4, skb, cp, 1);\n\n\tip_send_check(ip_hdr(skb));\n\n\t \n\tskb->ignore_df = 1;\n\n\tip_vs_send_or_cont(NFPROTO_IPV4, skb, cp, 0);\n\n\treturn NF_STOLEN;\n\n  tx_error:\n\tkfree_skb(skb);\n\treturn NF_STOLEN;\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nint\nip_vs_dr_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t struct ip_vs_protocol *pp, struct ip_vs_iphdr *ipvsh)\n{\n\tint local;\n\n\tlocal = __ip_vs_get_out_rt_v6(cp->ipvs, cp->af, skb, cp->dest,\n\t\t\t\t      &cp->daddr.in6,\n\t\t\t\t      NULL, ipvsh, 0,\n\t\t\t\t      IP_VS_RT_MODE_LOCAL |\n\t\t\t\t      IP_VS_RT_MODE_NON_LOCAL |\n\t\t\t\t      IP_VS_RT_MODE_KNOWN_NH);\n\tif (local < 0)\n\t\tgoto tx_error;\n\tif (local)\n\t\treturn ip_vs_send_or_cont(NFPROTO_IPV6, skb, cp, 1);\n\n\t \n\tskb->ignore_df = 1;\n\n\tip_vs_send_or_cont(NFPROTO_IPV6, skb, cp, 0);\n\n\treturn NF_STOLEN;\n\ntx_error:\n\tkfree_skb(skb);\n\treturn NF_STOLEN;\n}\n#endif\n\n\n \nint\nip_vs_icmp_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\tstruct ip_vs_protocol *pp, int offset, unsigned int hooknum,\n\t\tstruct ip_vs_iphdr *iph)\n{\n\tstruct rtable\t*rt;\t \n\tint rc;\n\tint local;\n\tint rt_mode, was_input;\n\n\t \n\tif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ) {\n\t\tif (cp->packet_xmit)\n\t\t\trc = cp->packet_xmit(skb, cp, pp, iph);\n\t\telse\n\t\t\trc = NF_ACCEPT;\n\t\t \n\t\tatomic_inc(&cp->in_pkts);\n\t\treturn rc;\n\t}\n\n\t \n\twas_input = rt_is_input_route(skb_rtable(skb));\n\n\t \n\trt_mode = (hooknum != NF_INET_FORWARD) ?\n\t\t  IP_VS_RT_MODE_LOCAL | IP_VS_RT_MODE_NON_LOCAL |\n\t\t  IP_VS_RT_MODE_RDR : IP_VS_RT_MODE_NON_LOCAL;\n\tlocal = __ip_vs_get_out_rt(cp->ipvs, cp->af, skb, cp->dest, cp->daddr.ip, rt_mode,\n\t\t\t\t   NULL, iph);\n\tif (local < 0)\n\t\tgoto tx_error;\n\trt = skb_rtable(skb);\n\n\t \n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (cp->flags & IP_VS_CONN_F_SYNC && local) {\n\t\tenum ip_conntrack_info ctinfo;\n\t\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\n\t\tif (ct) {\n\t\t\tIP_VS_DBG(10, \"%s(): \"\n\t\t\t\t  \"stopping DNAT to local address %pI4\\n\",\n\t\t\t\t  __func__, &cp->daddr.ip);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n#endif\n\n\t \n\tif (local && ipv4_is_loopback(cp->daddr.ip) && was_input) {\n\t\tIP_VS_DBG(1, \"%s(): \"\n\t\t\t  \"stopping DNAT to loopback %pI4\\n\",\n\t\t\t  __func__, &cp->daddr.ip);\n\t\tgoto tx_error;\n\t}\n\n\t \n\tif (skb_ensure_writable(skb, offset))\n\t\tgoto tx_error;\n\n\tif (skb_cow(skb, rt->dst.dev->hard_header_len))\n\t\tgoto tx_error;\n\n\tip_vs_nat_icmp(skb, pp, cp, 0);\n\n\t \n\tskb->ignore_df = 1;\n\n\treturn ip_vs_nat_send_or_cont(NFPROTO_IPV4, skb, cp, local);\n\n  tx_error:\n\tkfree_skb(skb);\n\trc = NF_STOLEN;\n\treturn rc;\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nint\nip_vs_icmp_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\tstruct ip_vs_protocol *pp, int offset, unsigned int hooknum,\n\t\tstruct ip_vs_iphdr *ipvsh)\n{\n\tstruct rt6_info\t*rt;\t \n\tint rc;\n\tint local;\n\tint rt_mode;\n\n\t \n\tif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ) {\n\t\tif (cp->packet_xmit)\n\t\t\trc = cp->packet_xmit(skb, cp, pp, ipvsh);\n\t\telse\n\t\t\trc = NF_ACCEPT;\n\t\t \n\t\tatomic_inc(&cp->in_pkts);\n\t\treturn rc;\n\t}\n\n\t \n\n\t \n\trt_mode = (hooknum != NF_INET_FORWARD) ?\n\t\t  IP_VS_RT_MODE_LOCAL | IP_VS_RT_MODE_NON_LOCAL |\n\t\t  IP_VS_RT_MODE_RDR : IP_VS_RT_MODE_NON_LOCAL;\n\tlocal = __ip_vs_get_out_rt_v6(cp->ipvs, cp->af, skb, cp->dest,\n\t\t\t\t      &cp->daddr.in6, NULL, ipvsh, 0, rt_mode);\n\tif (local < 0)\n\t\tgoto tx_error;\n\trt = (struct rt6_info *) skb_dst(skb);\n\t \n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (cp->flags & IP_VS_CONN_F_SYNC && local) {\n\t\tenum ip_conntrack_info ctinfo;\n\t\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\n\t\tif (ct) {\n\t\t\tIP_VS_DBG(10, \"%s(): \"\n\t\t\t\t  \"stopping DNAT to local address %pI6\\n\",\n\t\t\t\t  __func__, &cp->daddr.in6);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n#endif\n\n\t \n\tif (local && skb->dev && !(skb->dev->flags & IFF_LOOPBACK) &&\n\t    ipv6_addr_type(&cp->daddr.in6) & IPV6_ADDR_LOOPBACK) {\n\t\tIP_VS_DBG(1, \"%s(): \"\n\t\t\t  \"stopping DNAT to loopback %pI6\\n\",\n\t\t\t  __func__, &cp->daddr.in6);\n\t\tgoto tx_error;\n\t}\n\n\t \n\tif (skb_ensure_writable(skb, offset))\n\t\tgoto tx_error;\n\n\tif (skb_cow(skb, rt->dst.dev->hard_header_len))\n\t\tgoto tx_error;\n\n\tip_vs_nat_icmp_v6(skb, pp, cp, 0);\n\n\t \n\tskb->ignore_df = 1;\n\n\treturn ip_vs_nat_send_or_cont(NFPROTO_IPV6, skb, cp, local);\n\ntx_error:\n\tkfree_skb(skb);\n\trc = NF_STOLEN;\n\treturn rc;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}