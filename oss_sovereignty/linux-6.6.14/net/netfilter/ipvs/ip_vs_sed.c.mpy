{
  "module_name": "ip_vs_sed.c",
  "hash_id": "2dbc1cbb692696dcc3eb9f0f4a737648699097d512ea1b04b088972ff4790185",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_sed.c",
  "human_readable_source": "\n \n\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <net/ip_vs.h>\n\n\nstatic inline int\nip_vs_sed_dest_overhead(struct ip_vs_dest *dest)\n{\n\t \n\treturn atomic_read(&dest->activeconns) + 1;\n}\n\n\n \nstatic struct ip_vs_dest *\nip_vs_sed_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\n\t\t   struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_dest *dest, *least;\n\tint loh, doh;\n\n\tIP_VS_DBG(6, \"%s(): Scheduling...\\n\", __func__);\n\n\t \n\n\tlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\n\t\tif (!(dest->flags & IP_VS_DEST_F_OVERLOAD) &&\n\t\t    atomic_read(&dest->weight) > 0) {\n\t\t\tleast = dest;\n\t\t\tloh = ip_vs_sed_dest_overhead(least);\n\t\t\tgoto nextstage;\n\t\t}\n\t}\n\tip_vs_scheduler_err(svc, \"no destination available\");\n\treturn NULL;\n\n\t \n  nextstage:\n\tlist_for_each_entry_continue_rcu(dest, &svc->destinations, n_list) {\n\t\tif (dest->flags & IP_VS_DEST_F_OVERLOAD)\n\t\t\tcontinue;\n\t\tdoh = ip_vs_sed_dest_overhead(dest);\n\t\tif ((__s64)loh * atomic_read(&dest->weight) >\n\t\t    (__s64)doh * atomic_read(&least->weight)) {\n\t\t\tleast = dest;\n\t\t\tloh = doh;\n\t\t}\n\t}\n\n\tIP_VS_DBG_BUF(6, \"SED: server %s:%u \"\n\t\t      \"activeconns %d refcnt %d weight %d overhead %d\\n\",\n\t\t      IP_VS_DBG_ADDR(least->af, &least->addr),\n\t\t      ntohs(least->port),\n\t\t      atomic_read(&least->activeconns),\n\t\t      refcount_read(&least->refcnt),\n\t\t      atomic_read(&least->weight), loh);\n\n\treturn least;\n}\n\n\nstatic struct ip_vs_scheduler ip_vs_sed_scheduler =\n{\n\t.name =\t\t\t\"sed\",\n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list =\t\tLIST_HEAD_INIT(ip_vs_sed_scheduler.n_list),\n\t.schedule =\t\tip_vs_sed_schedule,\n};\n\n\nstatic int __init ip_vs_sed_init(void)\n{\n\treturn register_ip_vs_scheduler(&ip_vs_sed_scheduler);\n}\n\nstatic void __exit ip_vs_sed_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_sed_scheduler);\n\tsynchronize_rcu();\n}\n\nmodule_init(ip_vs_sed_init);\nmodule_exit(ip_vs_sed_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}