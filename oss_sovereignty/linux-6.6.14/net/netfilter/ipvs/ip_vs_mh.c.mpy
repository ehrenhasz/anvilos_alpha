{
  "module_name": "ip_vs_mh.c",
  "hash_id": "28c16d541fc2e14eed2bf2de9eebb78432a3e6a40396120cc095314a3a3adb5a",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_mh.c",
  "human_readable_source": "\n \n\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n\n#include <net/ip_vs.h>\n\n#include <linux/siphash.h>\n#include <linux/bitops.h>\n#include <linux/gcd.h>\n\n#define IP_VS_SVC_F_SCHED_MH_FALLBACK\tIP_VS_SVC_F_SCHED1  \n#define IP_VS_SVC_F_SCHED_MH_PORT\tIP_VS_SVC_F_SCHED2  \n\nstruct ip_vs_mh_lookup {\n\tstruct ip_vs_dest __rcu\t*dest;\t \n};\n\nstruct ip_vs_mh_dest_setup {\n\tunsigned int\toffset;  \n\tunsigned int\tskip;\t \n\tunsigned int\tperm;\t \n\tint\t\tturns;\t \n};\n\n \nstatic int primes[] = {251, 509, 1021, 2039, 4093,\n\t\t       8191, 16381, 32749, 65521, 131071};\n\n \n#ifndef CONFIG_IP_VS_MH_TAB_INDEX\n#define CONFIG_IP_VS_MH_TAB_INDEX\t12\n#endif\n#define IP_VS_MH_TAB_BITS\t\t(CONFIG_IP_VS_MH_TAB_INDEX / 2)\n#define IP_VS_MH_TAB_INDEX\t\t(CONFIG_IP_VS_MH_TAB_INDEX - 8)\n#define IP_VS_MH_TAB_SIZE               primes[IP_VS_MH_TAB_INDEX]\n\nstruct ip_vs_mh_state {\n\tstruct rcu_head\t\t\trcu_head;\n\tstruct ip_vs_mh_lookup\t\t*lookup;\n\tstruct ip_vs_mh_dest_setup\t*dest_setup;\n\thsiphash_key_t\t\t\thash1, hash2;\n\tint\t\t\t\tgcd;\n\tint\t\t\t\trshift;\n};\n\nstatic inline void generate_hash_secret(hsiphash_key_t *hash1,\n\t\t\t\t\thsiphash_key_t *hash2)\n{\n\thash1->key[0] = 2654435761UL;\n\thash1->key[1] = 2654435761UL;\n\n\thash2->key[0] = 2654446892UL;\n\thash2->key[1] = 2654446892UL;\n}\n\n \nstatic inline bool is_unavailable(struct ip_vs_dest *dest)\n{\n\treturn atomic_read(&dest->weight) <= 0 ||\n\t       dest->flags & IP_VS_DEST_F_OVERLOAD;\n}\n\n \nstatic inline unsigned int\nip_vs_mh_hashkey(int af, const union nf_inet_addr *addr,\n\t\t __be16 port, hsiphash_key_t *key, unsigned int offset)\n{\n\tunsigned int v;\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0] ^ addr->ip6[1] ^\n\t\t\t    addr->ip6[2] ^ addr->ip6[3];\n#endif\n\tv = (offset + ntohs(port) + ntohl(addr_fold));\n\treturn hsiphash(&v, sizeof(v), key);\n}\n\n \nstatic void ip_vs_mh_reset(struct ip_vs_mh_state *s)\n{\n\tint i;\n\tstruct ip_vs_mh_lookup *l;\n\tstruct ip_vs_dest *dest;\n\n\tl = &s->lookup[0];\n\tfor (i = 0; i < IP_VS_MH_TAB_SIZE; i++) {\n\t\tdest = rcu_dereference_protected(l->dest, 1);\n\t\tif (dest) {\n\t\t\tip_vs_dest_put(dest);\n\t\t\tRCU_INIT_POINTER(l->dest, NULL);\n\t\t}\n\t\tl++;\n\t}\n}\n\nstatic int ip_vs_mh_permutate(struct ip_vs_mh_state *s,\n\t\t\t      struct ip_vs_service *svc)\n{\n\tstruct list_head *p;\n\tstruct ip_vs_mh_dest_setup *ds;\n\tstruct ip_vs_dest *dest;\n\tint lw;\n\n\t \n\tif (s->gcd < 1)\n\t\treturn 0;\n\n\t \n\tp = &svc->destinations;\n\tds = &s->dest_setup[0];\n\twhile ((p = p->next) != &svc->destinations) {\n\t\tdest = list_entry(p, struct ip_vs_dest, n_list);\n\n\t\tds->offset = ip_vs_mh_hashkey(svc->af, &dest->addr,\n\t\t\t\t\t      dest->port, &s->hash1, 0) %\n\t\t\t\t\t      IP_VS_MH_TAB_SIZE;\n\t\tds->skip = ip_vs_mh_hashkey(svc->af, &dest->addr,\n\t\t\t\t\t    dest->port, &s->hash2, 0) %\n\t\t\t\t\t    (IP_VS_MH_TAB_SIZE - 1) + 1;\n\t\tds->perm = ds->offset;\n\n\t\tlw = atomic_read(&dest->last_weight);\n\t\tds->turns = ((lw / s->gcd) >> s->rshift) ? : (lw != 0);\n\t\tds++;\n\t}\n\n\treturn 0;\n}\n\nstatic int ip_vs_mh_populate(struct ip_vs_mh_state *s,\n\t\t\t     struct ip_vs_service *svc)\n{\n\tint n, c, dt_count;\n\tunsigned long *table;\n\tstruct list_head *p;\n\tstruct ip_vs_mh_dest_setup *ds;\n\tstruct ip_vs_dest *dest, *new_dest;\n\n\t \n\tif (s->gcd < 1) {\n\t\tip_vs_mh_reset(s);\n\t\treturn 0;\n\t}\n\n\ttable = bitmap_zalloc(IP_VS_MH_TAB_SIZE, GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tp = &svc->destinations;\n\tn = 0;\n\tdt_count = 0;\n\twhile (n < IP_VS_MH_TAB_SIZE) {\n\t\tif (p == &svc->destinations)\n\t\t\tp = p->next;\n\n\t\tds = &s->dest_setup[0];\n\t\twhile (p != &svc->destinations) {\n\t\t\t \n\t\t\tif (ds->turns < 1) {\n\t\t\t\tp = p->next;\n\t\t\t\tds++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tc = ds->perm;\n\t\t\twhile (test_bit(c, table)) {\n\t\t\t\t \n\t\t\t\tds->perm += ds->skip;\n\t\t\t\tif (ds->perm >= IP_VS_MH_TAB_SIZE)\n\t\t\t\t\tds->perm -= IP_VS_MH_TAB_SIZE;\n\t\t\t\tc = ds->perm;\n\t\t\t}\n\n\t\t\t__set_bit(c, table);\n\n\t\t\tdest = rcu_dereference_protected(s->lookup[c].dest, 1);\n\t\t\tnew_dest = list_entry(p, struct ip_vs_dest, n_list);\n\t\t\tif (dest != new_dest) {\n\t\t\t\tif (dest)\n\t\t\t\t\tip_vs_dest_put(dest);\n\t\t\t\tip_vs_dest_hold(new_dest);\n\t\t\t\tRCU_INIT_POINTER(s->lookup[c].dest, new_dest);\n\t\t\t}\n\n\t\t\tif (++n == IP_VS_MH_TAB_SIZE)\n\t\t\t\tgoto out;\n\n\t\t\tif (++dt_count >= ds->turns) {\n\t\t\t\tdt_count = 0;\n\t\t\t\tp = p->next;\n\t\t\t\tds++;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tbitmap_free(table);\n\treturn 0;\n}\n\n \nstatic inline struct ip_vs_dest *\nip_vs_mh_get(struct ip_vs_service *svc, struct ip_vs_mh_state *s,\n\t     const union nf_inet_addr *addr, __be16 port)\n{\n\tunsigned int hash = ip_vs_mh_hashkey(svc->af, addr, port, &s->hash1, 0)\n\t\t\t\t\t     % IP_VS_MH_TAB_SIZE;\n\tstruct ip_vs_dest *dest = rcu_dereference(s->lookup[hash].dest);\n\n\treturn (!dest || is_unavailable(dest)) ? NULL : dest;\n}\n\n \nstatic inline struct ip_vs_dest *\nip_vs_mh_get_fallback(struct ip_vs_service *svc, struct ip_vs_mh_state *s,\n\t\t      const union nf_inet_addr *addr, __be16 port)\n{\n\tunsigned int offset, roffset;\n\tunsigned int hash, ihash;\n\tstruct ip_vs_dest *dest;\n\n\t \n\tihash = ip_vs_mh_hashkey(svc->af, addr, port,\n\t\t\t\t &s->hash1, 0) % IP_VS_MH_TAB_SIZE;\n\tdest = rcu_dereference(s->lookup[ihash].dest);\n\tif (!dest)\n\t\treturn NULL;\n\tif (!is_unavailable(dest))\n\t\treturn dest;\n\n\tIP_VS_DBG_BUF(6, \"MH: selected unavailable server %s:%u, reselecting\",\n\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr), ntohs(dest->port));\n\n\t \n\tfor (offset = 0; offset < IP_VS_MH_TAB_SIZE; offset++) {\n\t\troffset = (offset + ihash) % IP_VS_MH_TAB_SIZE;\n\t\thash = ip_vs_mh_hashkey(svc->af, addr, port, &s->hash1,\n\t\t\t\t\troffset) % IP_VS_MH_TAB_SIZE;\n\t\tdest = rcu_dereference(s->lookup[hash].dest);\n\t\tif (!dest)\n\t\t\tbreak;\n\t\tif (!is_unavailable(dest))\n\t\t\treturn dest;\n\t\tIP_VS_DBG_BUF(6,\n\t\t\t      \"MH: selected unavailable server %s:%u (offset %u), reselecting\",\n\t\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t\t      ntohs(dest->port), roffset);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int ip_vs_mh_reassign(struct ip_vs_mh_state *s,\n\t\t\t     struct ip_vs_service *svc)\n{\n\tint ret;\n\n\tif (svc->num_dests > IP_VS_MH_TAB_SIZE)\n\t\treturn -EINVAL;\n\n\tif (svc->num_dests >= 1) {\n\t\ts->dest_setup = kcalloc(svc->num_dests,\n\t\t\t\t\tsizeof(struct ip_vs_mh_dest_setup),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!s->dest_setup)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tip_vs_mh_permutate(s, svc);\n\n\tret = ip_vs_mh_populate(s, svc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tIP_VS_DBG_BUF(6, \"MH: reassign lookup table of %s:%u\\n\",\n\t\t      IP_VS_DBG_ADDR(svc->af, &svc->addr),\n\t\t      ntohs(svc->port));\n\nout:\n\tif (svc->num_dests >= 1) {\n\t\tkfree(s->dest_setup);\n\t\ts->dest_setup = NULL;\n\t}\n\treturn ret;\n}\n\nstatic int ip_vs_mh_gcd_weight(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dest *dest;\n\tint weight;\n\tint g = 0;\n\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tweight = atomic_read(&dest->last_weight);\n\t\tif (weight > 0) {\n\t\t\tif (g > 0)\n\t\t\t\tg = gcd(weight, g);\n\t\t\telse\n\t\t\t\tg = weight;\n\t\t}\n\t}\n\treturn g;\n}\n\n \nstatic int ip_vs_mh_shift_weight(struct ip_vs_service *svc, int gcd)\n{\n\tstruct ip_vs_dest *dest;\n\tint new_weight, weight = 0;\n\tint mw, shift;\n\n\t \n\tif (gcd < 1)\n\t\treturn 0;\n\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tnew_weight = atomic_read(&dest->last_weight);\n\t\tif (new_weight > weight)\n\t\t\tweight = new_weight;\n\t}\n\n\t \n\tmw = weight / gcd;\n\n\t \n\tshift = fls(mw) - IP_VS_MH_TAB_BITS;\n\treturn (shift >= 0) ? shift : 0;\n}\n\nstatic void ip_vs_mh_state_free(struct rcu_head *head)\n{\n\tstruct ip_vs_mh_state *s;\n\n\ts = container_of(head, struct ip_vs_mh_state, rcu_head);\n\tkfree(s->lookup);\n\tkfree(s);\n}\n\nstatic int ip_vs_mh_init_svc(struct ip_vs_service *svc)\n{\n\tint ret;\n\tstruct ip_vs_mh_state *s;\n\n\t \n\ts = kzalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ts->lookup = kcalloc(IP_VS_MH_TAB_SIZE, sizeof(struct ip_vs_mh_lookup),\n\t\t\t    GFP_KERNEL);\n\tif (!s->lookup) {\n\t\tkfree(s);\n\t\treturn -ENOMEM;\n\t}\n\n\tgenerate_hash_secret(&s->hash1, &s->hash2);\n\ts->gcd = ip_vs_mh_gcd_weight(svc);\n\ts->rshift = ip_vs_mh_shift_weight(svc, s->gcd);\n\n\tIP_VS_DBG(6,\n\t\t  \"MH lookup table (memory=%zdbytes) allocated for current service\\n\",\n\t\t  sizeof(struct ip_vs_mh_lookup) * IP_VS_MH_TAB_SIZE);\n\n\t \n\tret = ip_vs_mh_reassign(s, svc);\n\tif (ret < 0) {\n\t\tip_vs_mh_reset(s);\n\t\tip_vs_mh_state_free(&s->rcu_head);\n\t\treturn ret;\n\t}\n\n\t \n\tsvc->sched_data = s;\n\treturn 0;\n}\n\nstatic void ip_vs_mh_done_svc(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_mh_state *s = svc->sched_data;\n\n\t \n\tip_vs_mh_reset(s);\n\n\tcall_rcu(&s->rcu_head, ip_vs_mh_state_free);\n\tIP_VS_DBG(6, \"MH lookup table (memory=%zdbytes) released\\n\",\n\t\t  sizeof(struct ip_vs_mh_lookup) * IP_VS_MH_TAB_SIZE);\n}\n\nstatic int ip_vs_mh_dest_changed(struct ip_vs_service *svc,\n\t\t\t\t struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_mh_state *s = svc->sched_data;\n\n\ts->gcd = ip_vs_mh_gcd_weight(svc);\n\ts->rshift = ip_vs_mh_shift_weight(svc, s->gcd);\n\n\t \n\treturn ip_vs_mh_reassign(s, svc);\n}\n\n \nstatic inline __be16\nip_vs_mh_get_port(const struct sk_buff *skb, struct ip_vs_iphdr *iph)\n{\n\t__be16 _ports[2], *ports;\n\n\t \n\tswitch (iph->protocol) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_SCTP:\n\t\tports = skb_header_pointer(skb, iph->len, sizeof(_ports),\n\t\t\t\t\t   &_ports);\n\t\tif (unlikely(!ports))\n\t\t\treturn 0;\n\n\t\tif (likely(!ip_vs_iph_inverse(iph)))\n\t\t\treturn ports[0];\n\t\telse\n\t\t\treturn ports[1];\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic struct ip_vs_dest *\nip_vs_mh_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\n\t\t  struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_dest *dest;\n\tstruct ip_vs_mh_state *s;\n\t__be16 port = 0;\n\tconst union nf_inet_addr *hash_addr;\n\n\thash_addr = ip_vs_iph_inverse(iph) ? &iph->daddr : &iph->saddr;\n\n\tIP_VS_DBG(6, \"%s : Scheduling...\\n\", __func__);\n\n\tif (svc->flags & IP_VS_SVC_F_SCHED_MH_PORT)\n\t\tport = ip_vs_mh_get_port(skb, iph);\n\n\ts = (struct ip_vs_mh_state *)svc->sched_data;\n\n\tif (svc->flags & IP_VS_SVC_F_SCHED_MH_FALLBACK)\n\t\tdest = ip_vs_mh_get_fallback(svc, s, hash_addr, port);\n\telse\n\t\tdest = ip_vs_mh_get(svc, s, hash_addr, port);\n\n\tif (!dest) {\n\t\tip_vs_scheduler_err(svc, \"no destination available\");\n\t\treturn NULL;\n\t}\n\n\tIP_VS_DBG_BUF(6, \"MH: source IP address %s:%u --> server %s:%u\\n\",\n\t\t      IP_VS_DBG_ADDR(svc->af, hash_addr),\n\t\t      ntohs(port),\n\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t      ntohs(dest->port));\n\n\treturn dest;\n}\n\n \nstatic struct ip_vs_scheduler ip_vs_mh_scheduler = {\n\t.name =\t\t\t\"mh\",\n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list\t =\t\tLIST_HEAD_INIT(ip_vs_mh_scheduler.n_list),\n\t.init_service =\t\tip_vs_mh_init_svc,\n\t.done_service =\t\tip_vs_mh_done_svc,\n\t.add_dest =\t\tip_vs_mh_dest_changed,\n\t.del_dest =\t\tip_vs_mh_dest_changed,\n\t.upd_dest =\t\tip_vs_mh_dest_changed,\n\t.schedule =\t\tip_vs_mh_schedule,\n};\n\nstatic int __init ip_vs_mh_init(void)\n{\n\treturn register_ip_vs_scheduler(&ip_vs_mh_scheduler);\n}\n\nstatic void __exit ip_vs_mh_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_mh_scheduler);\n\trcu_barrier();\n}\n\nmodule_init(ip_vs_mh_init);\nmodule_exit(ip_vs_mh_cleanup);\nMODULE_DESCRIPTION(\"Maglev hashing ipvs scheduler\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Inju Song <inju.song@navercorp.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}