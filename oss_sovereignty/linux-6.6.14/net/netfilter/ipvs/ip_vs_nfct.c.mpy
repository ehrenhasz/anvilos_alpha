{
  "module_name": "ip_vs_nfct.c",
  "hash_id": "d34ce3cd9d006b42c7aa9f4771c54968c54e97bad105aacb14d9310f2238511a",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_nfct.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <net/ip.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <net/ip_vs.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n\n\n#define FMT_TUPLE\t\"%s:%u->%s:%u/%u\"\n#define ARG_TUPLE(T)\tIP_VS_DBG_ADDR((T)->src.l3num, &(T)->src.u3),\t\\\n\t\t\tntohs((T)->src.u.all),\t\t\t\t\\\n\t\t\tIP_VS_DBG_ADDR((T)->src.l3num, &(T)->dst.u3),\t\\\n\t\t\tntohs((T)->dst.u.all),\t\t\t\t\\\n\t\t\t(T)->dst.protonum\n\n#define FMT_CONN\t\"%s:%u->%s:%u->%s:%u/%u:%u\"\n#define ARG_CONN(C)\tIP_VS_DBG_ADDR((C)->af, &((C)->caddr)),\t\t\\\n\t\t\tntohs((C)->cport),\t\t\t\t\\\n\t\t\tIP_VS_DBG_ADDR((C)->af, &((C)->vaddr)),\t\t\\\n\t\t\tntohs((C)->vport),\t\t\t\t\\\n\t\t\tIP_VS_DBG_ADDR((C)->daf, &((C)->daddr)),\t\\\n\t\t\tntohs((C)->dport),\t\t\t\t\\\n\t\t\t(C)->protocol, (C)->state\n\nvoid\nip_vs_update_conntrack(struct sk_buff *skb, struct ip_vs_conn *cp, int outin)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\tstruct nf_conntrack_tuple new_tuple;\n\n\tif (ct == NULL || nf_ct_is_confirmed(ct) ||\n\t    nf_ct_is_dying(ct))\n\t\treturn;\n\n\t \n\tif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)\n\t\treturn;\n\n\t \n\tif (cp->flags & IP_VS_CONN_F_ONE_PACKET)\n\t\treturn;\n\n\t \n\tif (CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)\n\t\treturn;\n\n\t \n\tif (cp->app && nf_ct_protonum(ct) == IPPROTO_TCP &&\n\t    !nfct_seqadj(ct) && !nfct_seqadj_ext_add(ct))\n\t\treturn;\n\n\t \n\tnew_tuple = ct->tuplehash[IP_CT_DIR_REPLY].tuple;\n\t \n\tif (outin) {\n\t\tnew_tuple.src.u3 = cp->daddr;\n\t\tif (new_tuple.dst.protonum != IPPROTO_ICMP &&\n\t\t    new_tuple.dst.protonum != IPPROTO_ICMPV6)\n\t\t\tnew_tuple.src.u.tcp.port = cp->dport;\n\t} else {\n\t\tnew_tuple.dst.u3 = cp->vaddr;\n\t\tif (new_tuple.dst.protonum != IPPROTO_ICMP &&\n\t\t    new_tuple.dst.protonum != IPPROTO_ICMPV6)\n\t\t\tnew_tuple.dst.u.tcp.port = cp->vport;\n\t}\n\tIP_VS_DBG_BUF(7, \"%s: Updating conntrack ct=%p, status=0x%lX, \"\n\t\t      \"ctinfo=%d, old reply=\" FMT_TUPLE \"\\n\",\n\t\t      __func__, ct, ct->status, ctinfo,\n\t\t      ARG_TUPLE(&ct->tuplehash[IP_CT_DIR_REPLY].tuple));\n\tIP_VS_DBG_BUF(7, \"%s: Updating conntrack ct=%p, status=0x%lX, \"\n\t\t      \"ctinfo=%d, new reply=\" FMT_TUPLE \"\\n\",\n\t\t      __func__, ct, ct->status, ctinfo,\n\t\t      ARG_TUPLE(&new_tuple));\n\tnf_conntrack_alter_reply(ct, &new_tuple);\n\tIP_VS_DBG_BUF(7, \"%s: Updated conntrack ct=%p for cp=\" FMT_CONN \"\\n\",\n\t\t      __func__, ct, ARG_CONN(cp));\n}\n\nint ip_vs_confirm_conntrack(struct sk_buff *skb)\n{\n\treturn nf_conntrack_confirm(skb);\n}\n\n \nstatic void ip_vs_nfct_expect_callback(struct nf_conn *ct,\n\tstruct nf_conntrack_expect *exp)\n{\n\tstruct nf_conntrack_tuple *orig, new_reply;\n\tstruct ip_vs_conn *cp;\n\tstruct ip_vs_conn_param p;\n\tstruct net *net = nf_ct_net(ct);\n\n\t \n\n\t \n\torig = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\tip_vs_conn_fill_param(net_ipvs(net), exp->tuple.src.l3num, orig->dst.protonum,\n\t\t\t      &orig->src.u3, orig->src.u.tcp.port,\n\t\t\t      &orig->dst.u3, orig->dst.u.tcp.port, &p);\n\tcp = ip_vs_conn_out_get(&p);\n\tif (cp) {\n\t\t \n\t\tIP_VS_DBG_BUF(7, \"%s: for ct=%p, status=0x%lX found inout cp=\"\n\t\t\t      FMT_CONN \"\\n\",\n\t\t\t      __func__, ct, ct->status, ARG_CONN(cp));\n\t\tnew_reply = ct->tuplehash[IP_CT_DIR_REPLY].tuple;\n\t\tIP_VS_DBG_BUF(7, \"%s: ct=%p before alter: reply tuple=\"\n\t\t\t      FMT_TUPLE \"\\n\",\n\t\t\t      __func__, ct, ARG_TUPLE(&new_reply));\n\t\tnew_reply.dst.u3 = cp->vaddr;\n\t\tnew_reply.dst.u.tcp.port = cp->vport;\n\t\tgoto alter;\n\t}\n\n\t \n\tcp = ip_vs_conn_in_get(&p);\n\tif (cp) {\n\t\t \n\t\tIP_VS_DBG_BUF(7, \"%s: for ct=%p, status=0x%lX found outin cp=\"\n\t\t\t      FMT_CONN \"\\n\",\n\t\t\t      __func__, ct, ct->status, ARG_CONN(cp));\n\t\tnew_reply = ct->tuplehash[IP_CT_DIR_REPLY].tuple;\n\t\tIP_VS_DBG_BUF(7, \"%s: ct=%p before alter: reply tuple=\"\n\t\t\t      FMT_TUPLE \"\\n\",\n\t\t\t      __func__, ct, ARG_TUPLE(&new_reply));\n\t\tnew_reply.src.u3 = cp->daddr;\n\t\tnew_reply.src.u.tcp.port = cp->dport;\n\t\tgoto alter;\n\t}\n\n\tIP_VS_DBG_BUF(7, \"%s: ct=%p, status=0x%lX, tuple=\" FMT_TUPLE\n\t\t      \" - unknown expect\\n\",\n\t\t      __func__, ct, ct->status, ARG_TUPLE(orig));\n\treturn;\n\nalter:\n\t \n\tif (IP_VS_FWD_METHOD(cp) == IP_VS_CONN_F_MASQ)\n\t\tnf_conntrack_alter_reply(ct, &new_reply);\n\tip_vs_conn_put(cp);\n\treturn;\n}\n\n \nvoid ip_vs_nfct_expect_related(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t       struct ip_vs_conn *cp, u_int8_t proto,\n\t\t\t       const __be16 port, int from_rs)\n{\n\tstruct nf_conntrack_expect *exp;\n\n\tif (ct == NULL)\n\t\treturn;\n\n\texp = nf_ct_expect_alloc(ct);\n\tif (!exp)\n\t\treturn;\n\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\tfrom_rs ? &cp->daddr : &cp->caddr,\n\t\t\tfrom_rs ? &cp->caddr : &cp->vaddr,\n\t\t\tproto, port ? &port : NULL,\n\t\t\tfrom_rs ? &cp->cport : &cp->vport);\n\n\texp->expectfn = ip_vs_nfct_expect_callback;\n\n\tIP_VS_DBG_BUF(7, \"%s: ct=%p, expect tuple=\" FMT_TUPLE \"\\n\",\n\t\t      __func__, ct, ARG_TUPLE(&exp->tuple));\n\tnf_ct_expect_related(exp, 0);\n\tnf_ct_expect_put(exp);\n}\nEXPORT_SYMBOL(ip_vs_nfct_expect_related);\n\n \nvoid ip_vs_conn_drop_conntrack(struct ip_vs_conn *cp)\n{\n\tstruct nf_conntrack_tuple_hash *h;\n\tstruct nf_conn *ct;\n\tstruct nf_conntrack_tuple tuple;\n\n\tif (!cp->cport)\n\t\treturn;\n\n\ttuple = (struct nf_conntrack_tuple) {\n\t\t.dst = { .protonum = cp->protocol, .dir = IP_CT_DIR_ORIGINAL } };\n\ttuple.src.u3 = cp->caddr;\n\ttuple.src.u.all = cp->cport;\n\ttuple.src.l3num = cp->af;\n\ttuple.dst.u3 = cp->vaddr;\n\ttuple.dst.u.all = cp->vport;\n\n\tIP_VS_DBG_BUF(7, \"%s: dropping conntrack for conn \" FMT_CONN \"\\n\",\n\t\t      __func__, ARG_CONN(cp));\n\n\th = nf_conntrack_find_get(cp->ipvs->net, &nf_ct_zone_dflt, &tuple);\n\tif (h) {\n\t\tct = nf_ct_tuplehash_to_ctrack(h);\n\t\tif (nf_ct_kill(ct)) {\n\t\t\tIP_VS_DBG_BUF(7, \"%s: ct=%p deleted for tuple=\"\n\t\t\t\t      FMT_TUPLE \"\\n\",\n\t\t\t\t      __func__, ct, ARG_TUPLE(&tuple));\n\t\t} else {\n\t\t\tIP_VS_DBG_BUF(7, \"%s: ct=%p, no conntrack for tuple=\"\n\t\t\t\t      FMT_TUPLE \"\\n\",\n\t\t\t\t      __func__, ct, ARG_TUPLE(&tuple));\n\t\t}\n\t\tnf_ct_put(ct);\n\t} else {\n\t\tIP_VS_DBG_BUF(7, \"%s: no conntrack for tuple=\" FMT_TUPLE \"\\n\",\n\t\t\t      __func__, ARG_TUPLE(&tuple));\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}