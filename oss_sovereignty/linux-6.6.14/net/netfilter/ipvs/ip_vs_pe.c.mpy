{
  "module_name": "ip_vs_pe.c",
  "hash_id": "c470f30f28e6860d62dd3f54db3317ca4ae57e2633b3e606cdf168a43b360e21",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_pe.c",
  "human_readable_source": "\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <asm/string.h>\n#include <linux/kmod.h>\n#include <linux/sysctl.h>\n\n#include <net/ip_vs.h>\n\n \nstatic LIST_HEAD(ip_vs_pe);\n\n \nstatic DEFINE_MUTEX(ip_vs_pe_mutex);\n\n \nstruct ip_vs_pe *__ip_vs_pe_getbyname(const char *pe_name)\n{\n\tstruct ip_vs_pe *pe;\n\n\tIP_VS_DBG(10, \"%s(): pe_name \\\"%s\\\"\\n\", __func__,\n\t\t  pe_name);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pe, &ip_vs_pe, n_list) {\n\t\t \n\t\tif (pe->module &&\n\t\t    !try_module_get(pe->module)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(pe_name, pe->name)==0) {\n\t\t\t \n\t\t\trcu_read_unlock();\n\t\t\treturn pe;\n\t\t}\n\t\tmodule_put(pe->module);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\n \nstruct ip_vs_pe *ip_vs_pe_getbyname(const char *name)\n{\n\tstruct ip_vs_pe *pe;\n\n\t \n\tpe = __ip_vs_pe_getbyname(name);\n\n\t \n\tif (!pe) {\n\t\trequest_module(\"ip_vs_pe_%s\", name);\n\t\tpe = __ip_vs_pe_getbyname(name);\n\t}\n\n\treturn pe;\n}\n\n \nint register_ip_vs_pe(struct ip_vs_pe *pe)\n{\n\tstruct ip_vs_pe *tmp;\n\n\t \n\tif (!ip_vs_use_count_inc())\n\t\treturn -ENOENT;\n\n\tmutex_lock(&ip_vs_pe_mutex);\n\t \n\tlist_for_each_entry(tmp, &ip_vs_pe, n_list) {\n\t\tif (strcmp(tmp->name, pe->name) == 0) {\n\t\t\tmutex_unlock(&ip_vs_pe_mutex);\n\t\t\tip_vs_use_count_dec();\n\t\t\tpr_err(\"%s(): [%s] pe already existed \"\n\t\t\t       \"in the system\\n\", __func__, pe->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tlist_add_rcu(&pe->n_list, &ip_vs_pe);\n\tmutex_unlock(&ip_vs_pe_mutex);\n\n\tpr_info(\"[%s] pe registered.\\n\", pe->name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(register_ip_vs_pe);\n\n \nint unregister_ip_vs_pe(struct ip_vs_pe *pe)\n{\n\tmutex_lock(&ip_vs_pe_mutex);\n\t \n\tlist_del_rcu(&pe->n_list);\n\tmutex_unlock(&ip_vs_pe_mutex);\n\n\t \n\tip_vs_use_count_dec();\n\n\tpr_info(\"[%s] pe unregistered.\\n\", pe->name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(unregister_ip_vs_pe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}