{
  "module_name": "ip_vs_twos.c",
  "hash_id": "596e8e468d79866f1f5499c371bfc721c211e263770d27b1ac01fafe350156c0",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_twos.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/random.h>\n\n#include <net/ip_vs.h>\n\n \nstatic struct ip_vs_dest *ip_vs_twos_schedule(struct ip_vs_service *svc,\n\t\t\t\t\t      const struct sk_buff *skb,\n\t\t\t\t\t      struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_dest *dest, *choice1 = NULL, *choice2 = NULL;\n\tint rweight1, rweight2, weight1 = -1, weight2 = -1, overhead1 = 0;\n\tint overhead2, total_weight = 0, weight;\n\n\tIP_VS_DBG(6, \"%s(): Scheduling...\\n\", __func__);\n\n\t \n\tlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\n\t\tif (!(dest->flags & IP_VS_DEST_F_OVERLOAD)) {\n\t\t\tweight = atomic_read(&dest->weight);\n\t\t\tif (weight > 0) {\n\t\t\t\ttotal_weight += weight;\n\t\t\t\tchoice1 = dest;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!choice1) {\n\t\tip_vs_scheduler_err(svc, \"no destination available\");\n\t\treturn NULL;\n\t}\n\n\t \n\ttotal_weight += 1;\n\trweight1 = get_random_u32_below(total_weight);\n\trweight2 = get_random_u32_below(total_weight);\n\n\t \n\tlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\n\t\tif (dest->flags & IP_VS_DEST_F_OVERLOAD)\n\t\t\tcontinue;\n\n\t\tweight = atomic_read(&dest->weight);\n\t\tif (weight <= 0)\n\t\t\tcontinue;\n\n\t\trweight1 -= weight;\n\t\trweight2 -= weight;\n\n\t\tif (rweight1 <= 0 && weight1 == -1) {\n\t\t\tchoice1 = dest;\n\t\t\tweight1 = weight;\n\t\t\toverhead1 = ip_vs_dest_conn_overhead(dest);\n\t\t}\n\n\t\tif (rweight2 <= 0 && weight2 == -1) {\n\t\t\tchoice2 = dest;\n\t\t\tweight2 = weight;\n\t\t\toverhead2 = ip_vs_dest_conn_overhead(dest);\n\t\t}\n\n\t\tif (weight1 != -1 && weight2 != -1)\n\t\t\tgoto nextstage;\n\t}\n\nnextstage:\n\tif (choice2 && (weight2 * overhead1) > (weight1 * overhead2))\n\t\tchoice1 = choice2;\n\n\tIP_VS_DBG_BUF(6, \"twos: server %s:%u conns %d refcnt %d weight %d\\n\",\n\t\t      IP_VS_DBG_ADDR(choice1->af, &choice1->addr),\n\t\t      ntohs(choice1->port), atomic_read(&choice1->activeconns),\n\t\t      refcount_read(&choice1->refcnt),\n\t\t      atomic_read(&choice1->weight));\n\n\treturn choice1;\n}\n\nstatic struct ip_vs_scheduler ip_vs_twos_scheduler = {\n\t.name = \"twos\",\n\t.refcnt = ATOMIC_INIT(0),\n\t.module = THIS_MODULE,\n\t.n_list = LIST_HEAD_INIT(ip_vs_twos_scheduler.n_list),\n\t.schedule = ip_vs_twos_schedule,\n};\n\nstatic int __init ip_vs_twos_init(void)\n{\n\treturn register_ip_vs_scheduler(&ip_vs_twos_scheduler);\n}\n\nstatic void __exit ip_vs_twos_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_twos_scheduler);\n\tsynchronize_rcu();\n}\n\nmodule_init(ip_vs_twos_init);\nmodule_exit(ip_vs_twos_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}