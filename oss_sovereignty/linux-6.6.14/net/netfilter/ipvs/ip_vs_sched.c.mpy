{
  "module_name": "ip_vs_sched.c",
  "hash_id": "ccb48ec0b638e4019217da36b9d679a1ca73d42dea0e6cb38478f949965b736e",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_sched.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <asm/string.h>\n#include <linux/kmod.h>\n#include <linux/sysctl.h>\n\n#include <net/ip_vs.h>\n\nEXPORT_SYMBOL(ip_vs_scheduler_err);\n \nstatic LIST_HEAD(ip_vs_schedulers);\n\n \nstatic DEFINE_MUTEX(ip_vs_sched_mutex);\n\n\n \nint ip_vs_bind_scheduler(struct ip_vs_service *svc,\n\t\t\t struct ip_vs_scheduler *scheduler)\n{\n\tint ret;\n\n\tif (scheduler->init_service) {\n\t\tret = scheduler->init_service(svc);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s(): init error\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\trcu_assign_pointer(svc->scheduler, scheduler);\n\treturn 0;\n}\n\n\n \nvoid ip_vs_unbind_scheduler(struct ip_vs_service *svc,\n\t\t\t    struct ip_vs_scheduler *sched)\n{\n\tstruct ip_vs_scheduler *cur_sched;\n\n\tcur_sched = rcu_dereference_protected(svc->scheduler, 1);\n\t \n\tif (!cur_sched)\n\t\treturn;\n\n\tif (sched->done_service)\n\t\tsched->done_service(svc);\n\t \n}\n\n\n \nstatic struct ip_vs_scheduler *ip_vs_sched_getbyname(const char *sched_name)\n{\n\tstruct ip_vs_scheduler *sched;\n\n\tIP_VS_DBG(2, \"%s(): sched_name \\\"%s\\\"\\n\", __func__, sched_name);\n\n\tmutex_lock(&ip_vs_sched_mutex);\n\n\tlist_for_each_entry(sched, &ip_vs_schedulers, n_list) {\n\t\t \n\t\tif (sched->module && !try_module_get(sched->module)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(sched_name, sched->name)==0) {\n\t\t\t \n\t\t\tmutex_unlock(&ip_vs_sched_mutex);\n\t\t\treturn sched;\n\t\t}\n\t\tmodule_put(sched->module);\n\t}\n\n\tmutex_unlock(&ip_vs_sched_mutex);\n\treturn NULL;\n}\n\n\n \nstruct ip_vs_scheduler *ip_vs_scheduler_get(const char *sched_name)\n{\n\tstruct ip_vs_scheduler *sched;\n\n\t \n\tsched = ip_vs_sched_getbyname(sched_name);\n\n\t \n\tif (sched == NULL) {\n\t\trequest_module(\"ip_vs_%s\", sched_name);\n\t\tsched = ip_vs_sched_getbyname(sched_name);\n\t}\n\n\treturn sched;\n}\n\nvoid ip_vs_scheduler_put(struct ip_vs_scheduler *scheduler)\n{\n\tif (scheduler)\n\t\tmodule_put(scheduler->module);\n}\n\n \n\nvoid ip_vs_scheduler_err(struct ip_vs_service *svc, const char *msg)\n{\n\tstruct ip_vs_scheduler *sched = rcu_dereference(svc->scheduler);\n\tchar *sched_name = sched ? sched->name : \"none\";\n\n\tif (svc->fwmark) {\n\t\tIP_VS_ERR_RL(\"%s: FWM %u 0x%08X - %s\\n\",\n\t\t\t     sched_name, svc->fwmark, svc->fwmark, msg);\n#ifdef CONFIG_IP_VS_IPV6\n\t} else if (svc->af == AF_INET6) {\n\t\tIP_VS_ERR_RL(\"%s: %s [%pI6c]:%d - %s\\n\",\n\t\t\t     sched_name, ip_vs_proto_name(svc->protocol),\n\t\t\t     &svc->addr.in6, ntohs(svc->port), msg);\n#endif\n\t} else {\n\t\tIP_VS_ERR_RL(\"%s: %s %pI4:%d - %s\\n\",\n\t\t\t     sched_name, ip_vs_proto_name(svc->protocol),\n\t\t\t     &svc->addr.ip, ntohs(svc->port), msg);\n\t}\n}\n\n \nint register_ip_vs_scheduler(struct ip_vs_scheduler *scheduler)\n{\n\tstruct ip_vs_scheduler *sched;\n\n\tif (!scheduler) {\n\t\tpr_err(\"%s(): NULL arg\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!scheduler->name) {\n\t\tpr_err(\"%s(): NULL scheduler_name\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!ip_vs_use_count_inc())\n\t\treturn -ENOENT;\n\n\tmutex_lock(&ip_vs_sched_mutex);\n\n\tif (!list_empty(&scheduler->n_list)) {\n\t\tmutex_unlock(&ip_vs_sched_mutex);\n\t\tip_vs_use_count_dec();\n\t\tpr_err(\"%s(): [%s] scheduler already linked\\n\",\n\t\t       __func__, scheduler->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlist_for_each_entry(sched, &ip_vs_schedulers, n_list) {\n\t\tif (strcmp(scheduler->name, sched->name) == 0) {\n\t\t\tmutex_unlock(&ip_vs_sched_mutex);\n\t\t\tip_vs_use_count_dec();\n\t\t\tpr_err(\"%s(): [%s] scheduler already existed \"\n\t\t\t       \"in the system\\n\", __func__, scheduler->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tlist_add(&scheduler->n_list, &ip_vs_schedulers);\n\tmutex_unlock(&ip_vs_sched_mutex);\n\n\tpr_info(\"[%s] scheduler registered.\\n\", scheduler->name);\n\n\treturn 0;\n}\n\n\n \nint unregister_ip_vs_scheduler(struct ip_vs_scheduler *scheduler)\n{\n\tif (!scheduler) {\n\t\tpr_err(\"%s(): NULL arg\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ip_vs_sched_mutex);\n\tif (list_empty(&scheduler->n_list)) {\n\t\tmutex_unlock(&ip_vs_sched_mutex);\n\t\tpr_err(\"%s(): [%s] scheduler is not in the list. failed\\n\",\n\t\t       __func__, scheduler->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlist_del(&scheduler->n_list);\n\tmutex_unlock(&ip_vs_sched_mutex);\n\n\t \n\tip_vs_use_count_dec();\n\n\tpr_info(\"[%s] scheduler unregistered.\\n\", scheduler->name);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}