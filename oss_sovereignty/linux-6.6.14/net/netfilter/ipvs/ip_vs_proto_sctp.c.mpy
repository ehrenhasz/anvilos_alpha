{
  "module_name": "ip_vs_proto_sctp.c",
  "hash_id": "347eb5ad06ca6830f9ef45582416cf58b6a17eae21d5bb55b78ff72773608d6c",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_proto_sctp.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/sctp.h>\n#include <net/ip.h>\n#include <net/ip6_checksum.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <net/sctp/checksum.h>\n#include <net/ip_vs.h>\n\nstatic int\nsctp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp);\n\nstatic int\nsctp_conn_schedule(struct netns_ipvs *ipvs, int af, struct sk_buff *skb,\n\t\t   struct ip_vs_proto_data *pd,\n\t\t   int *verdict, struct ip_vs_conn **cpp,\n\t\t   struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_service *svc;\n\tstruct sctp_chunkhdr _schunkh, *sch;\n\tstruct sctphdr *sh, _sctph;\n\t__be16 _ports[2], *ports = NULL;\n\n\tif (likely(!ip_vs_iph_icmp(iph))) {\n\t\tsh = skb_header_pointer(skb, iph->len, sizeof(_sctph), &_sctph);\n\t\tif (sh) {\n\t\t\tsch = skb_header_pointer(skb, iph->len + sizeof(_sctph),\n\t\t\t\t\t\t sizeof(_schunkh), &_schunkh);\n\t\t\tif (sch) {\n\t\t\t\tif (sch->type == SCTP_CID_ABORT ||\n\t\t\t\t    !(sysctl_sloppy_sctp(ipvs) ||\n\t\t\t\t      sch->type == SCTP_CID_INIT))\n\t\t\t\t\treturn 1;\n\t\t\t\tports = &sh->source;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tports = skb_header_pointer(\n\t\t\tskb, iph->len, sizeof(_ports), &_ports);\n\t}\n\n\tif (!ports) {\n\t\t*verdict = NF_DROP;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ip_vs_iph_inverse(iph)))\n\t\tsvc = ip_vs_service_find(ipvs, af, skb->mark, iph->protocol,\n\t\t\t\t\t &iph->daddr, ports[1]);\n\telse\n\t\tsvc = ip_vs_service_find(ipvs, af, skb->mark, iph->protocol,\n\t\t\t\t\t &iph->saddr, ports[0]);\n\tif (svc) {\n\t\tint ignored;\n\n\t\tif (ip_vs_todrop(ipvs)) {\n\t\t\t \n\t\t\t*verdict = NF_DROP;\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\t*cpp = ip_vs_schedule(svc, skb, pd, &ignored, iph);\n\t\tif (!*cpp && ignored <= 0) {\n\t\t\tif (!ignored)\n\t\t\t\t*verdict = ip_vs_leave(svc, skb, pd, iph);\n\t\t\telse\n\t\t\t\t*verdict = NF_DROP;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\treturn 1;\n}\n\nstatic void sctp_nat_csum(struct sk_buff *skb, struct sctphdr *sctph,\n\t\t\t  unsigned int sctphoff)\n{\n\tsctph->checksum = sctp_compute_cksum(skb, sctphoff);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n}\n\nstatic int\nsctp_snat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t  struct ip_vs_conn *cp, struct ip_vs_iphdr *iph)\n{\n\tstruct sctphdr *sctph;\n\tunsigned int sctphoff = iph->len;\n\tbool payload_csum = false;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (cp->af == AF_INET6 && iph->fragoffs)\n\t\treturn 1;\n#endif\n\n\t \n\tif (skb_ensure_writable(skb, sctphoff + sizeof(*sctph)))\n\t\treturn 0;\n\n\tif (unlikely(cp->app != NULL)) {\n\t\tint ret;\n\n\t\t \n\t\tif (!sctp_csum_check(cp->af, skb, pp))\n\t\t\treturn 0;\n\n\t\t \n\t\tret = ip_vs_app_pkt_out(cp, skb, iph);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\t \n\t\tif (ret == 2)\n\t\t\tpayload_csum = true;\n\t}\n\n\tsctph = (void *) skb_network_header(skb) + sctphoff;\n\n\t \n\tif (sctph->source != cp->vport || payload_csum ||\n\t    skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tsctph->source = cp->vport;\n\t\tsctp_nat_csum(skb, sctph, sctphoff);\n\t} else {\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsctp_dnat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t  struct ip_vs_conn *cp, struct ip_vs_iphdr *iph)\n{\n\tstruct sctphdr *sctph;\n\tunsigned int sctphoff = iph->len;\n\tbool payload_csum = false;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (cp->af == AF_INET6 && iph->fragoffs)\n\t\treturn 1;\n#endif\n\n\t \n\tif (skb_ensure_writable(skb, sctphoff + sizeof(*sctph)))\n\t\treturn 0;\n\n\tif (unlikely(cp->app != NULL)) {\n\t\tint ret;\n\n\t\t \n\t\tif (!sctp_csum_check(cp->af, skb, pp))\n\t\t\treturn 0;\n\n\t\t \n\t\tret = ip_vs_app_pkt_in(cp, skb, iph);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\t \n\t\tif (ret == 2)\n\t\t\tpayload_csum = true;\n\t}\n\n\tsctph = (void *) skb_network_header(skb) + sctphoff;\n\n\t \n\tif (sctph->dest != cp->dport || payload_csum ||\n\t    (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t     !(skb_dst(skb)->dev->features & NETIF_F_SCTP_CRC))) {\n\t\tsctph->dest = cp->dport;\n\t\tsctp_nat_csum(skb, sctph, sctphoff);\n\t} else if (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsctp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)\n{\n\tunsigned int sctphoff;\n\tstruct sctphdr *sh;\n\t__le32 cmp, val;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\tsctphoff = sizeof(struct ipv6hdr);\n\telse\n#endif\n\t\tsctphoff = ip_hdrlen(skb);\n\n\tsh = (struct sctphdr *)(skb->data + sctphoff);\n\tcmp = sh->checksum;\n\tval = sctp_compute_cksum(skb, sctphoff);\n\n\tif (val != cmp) {\n\t\t \n\t\tIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\n\t\t\t\t\"Failed checksum for\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nenum ipvs_sctp_event_t {\n\tIP_VS_SCTP_DATA = 0,\t\t \n\tIP_VS_SCTP_INIT,\n\tIP_VS_SCTP_INIT_ACK,\n\tIP_VS_SCTP_COOKIE_ECHO,\n\tIP_VS_SCTP_COOKIE_ACK,\n\tIP_VS_SCTP_SHUTDOWN,\n\tIP_VS_SCTP_SHUTDOWN_ACK,\n\tIP_VS_SCTP_SHUTDOWN_COMPLETE,\n\tIP_VS_SCTP_ERROR,\n\tIP_VS_SCTP_ABORT,\n\tIP_VS_SCTP_EVENT_LAST\n};\n\n \nstatic __u8 sctp_events[] = {\n\t[SCTP_CID_DATA]\t\t\t= IP_VS_SCTP_DATA,\n\t[SCTP_CID_INIT]\t\t\t= IP_VS_SCTP_INIT,\n\t[SCTP_CID_INIT_ACK]\t\t= IP_VS_SCTP_INIT_ACK,\n\t[SCTP_CID_SACK]\t\t\t= IP_VS_SCTP_DATA,\n\t[SCTP_CID_HEARTBEAT]\t\t= IP_VS_SCTP_DATA,\n\t[SCTP_CID_HEARTBEAT_ACK]\t= IP_VS_SCTP_DATA,\n\t[SCTP_CID_ABORT]\t\t= IP_VS_SCTP_ABORT,\n\t[SCTP_CID_SHUTDOWN]\t\t= IP_VS_SCTP_SHUTDOWN,\n\t[SCTP_CID_SHUTDOWN_ACK]\t\t= IP_VS_SCTP_SHUTDOWN_ACK,\n\t[SCTP_CID_ERROR]\t\t= IP_VS_SCTP_ERROR,\n\t[SCTP_CID_COOKIE_ECHO]\t\t= IP_VS_SCTP_COOKIE_ECHO,\n\t[SCTP_CID_COOKIE_ACK]\t\t= IP_VS_SCTP_COOKIE_ACK,\n\t[SCTP_CID_ECN_ECNE]\t\t= IP_VS_SCTP_DATA,\n\t[SCTP_CID_ECN_CWR]\t\t= IP_VS_SCTP_DATA,\n\t[SCTP_CID_SHUTDOWN_COMPLETE]\t= IP_VS_SCTP_SHUTDOWN_COMPLETE,\n};\n\n \n\n#define sNO IP_VS_SCTP_S_NONE\n#define sI1 IP_VS_SCTP_S_INIT1\n#define sIN IP_VS_SCTP_S_INIT\n#define sCS IP_VS_SCTP_S_COOKIE_SENT\n#define sCR IP_VS_SCTP_S_COOKIE_REPLIED\n#define sCW IP_VS_SCTP_S_COOKIE_WAIT\n#define sCO IP_VS_SCTP_S_COOKIE\n#define sCE IP_VS_SCTP_S_COOKIE_ECHOED\n#define sES IP_VS_SCTP_S_ESTABLISHED\n#define sSS IP_VS_SCTP_S_SHUTDOWN_SENT\n#define sSR IP_VS_SCTP_S_SHUTDOWN_RECEIVED\n#define sSA IP_VS_SCTP_S_SHUTDOWN_ACK_SENT\n#define sRJ IP_VS_SCTP_S_REJECTED\n#define sCL IP_VS_SCTP_S_CLOSED\n\nstatic const __u8 sctp_states\n\t[IP_VS_DIR_LAST][IP_VS_SCTP_EVENT_LAST][IP_VS_SCTP_S_LAST] = {\n\t{  \n \n {sES, sI1, sIN, sCS, sCR, sCW, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sI1, sIN, sIN, sCS, sCR, sCW, sCO, sCE, sES, sSS, sSR, sSA, sIN, sIN},\n {sCW, sCW, sCW, sCS, sCR, sCO, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sCR, sIN, sIN, sCR, sCR, sCW, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sES, sI1, sIN, sCS, sCR, sCW, sCO, sES, sES, sSS, sSR, sSA, sRJ, sCL},\n {sSR, sI1, sIN, sCS, sCR, sCW, sCO, sCE, sSR, sSS, sSR, sSA, sRJ, sCL},\n {sCL, sIN, sIN, sCS, sCR, sCW, sCO, sCE, sES, sCL, sSR, sCL, sRJ, sCL},\n {sCL, sCL, sCL, sCS, sCR, sCW, sCO, sCE, sES, sSS, sSR, sCL, sRJ, sCL},\n {sCL, sI1, sIN, sCS, sCR, sCW, sCO, sCL, sES, sSS, sSR, sSA, sRJ, sCL},\n {sCL, sCL, sCL, sCL, sCL, sRJ, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL},\n\t},\n\t{  \n \n {sES, sI1, sIN, sCS, sCR, sCW, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sCW, sCW, sCW, sCW, sCW, sCW, sCW, sCW, sES, sCW, sCW, sCW, sCW, sCW},\n {sCS, sCS, sCS, sCS, sCR, sCW, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sCE, sCE, sCE, sCE, sCE, sCE, sCE, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sES, sES, sES, sES, sES, sES, sES, sES, sES, sSS, sSR, sSA, sRJ, sCL},\n {sSS, sSS, sSS, sSS, sSS, sSS, sSS, sSS, sSS, sSS, sSR, sSA, sRJ, sCL},\n {sSA, sSA, sSA, sSA, sSA, sCW, sCO, sCE, sES, sSA, sSA, sSA, sRJ, sCL},\n {sCL, sI1, sIN, sCS, sCR, sCW, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sCL, sCL, sCL, sCL, sCL, sCW, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sCL, sRJ, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL},\n\t},\n\t{  \n \n {sES, sI1, sIN, sCS, sCR, sES, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sI1, sIN, sIN, sIN, sIN, sIN, sCO, sCE, sES, sSS, sSR, sSA, sIN, sIN},\n {sCE, sCE, sCE, sCE, sCE, sCE, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sES, sES, sES, sES, sES, sES, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sES, sI1, sIN, sES, sES, sCW, sES, sES, sES, sSS, sSR, sSA, sRJ, sCL},\n {sSR, sI1, sIN, sCS, sCR, sCW, sCO, sCE, sSR, sSS, sSR, sSA, sRJ, sCL},\n {sCL, sIN, sIN, sCS, sCR, sCW, sCO, sCE, sCL, sCL, sSR, sCL, sRJ, sCL},\n {sCL, sCL, sCL, sCL, sCL, sCW, sCO, sCE, sES, sSS, sCL, sCL, sRJ, sCL},\n {sCL, sI1, sIN, sCS, sCR, sCW, sCO, sCE, sES, sSS, sSR, sSA, sRJ, sCL},\n {sCL, sCL, sCL, sCL, sCL, sRJ, sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL},\n\t},\n};\n\n#define IP_VS_SCTP_MAX_RTO\t((60 + 1) * HZ)\n\n \nstatic const int sctp_timeouts[IP_VS_SCTP_S_LAST + 1] = {\n\t[IP_VS_SCTP_S_NONE]\t\t\t= 2 * HZ,\n\t[IP_VS_SCTP_S_INIT1]\t\t\t= (0 + 3 + 1) * HZ,\n\t[IP_VS_SCTP_S_INIT]\t\t\t= IP_VS_SCTP_MAX_RTO,\n\t[IP_VS_SCTP_S_COOKIE_SENT]\t\t= IP_VS_SCTP_MAX_RTO,\n\t[IP_VS_SCTP_S_COOKIE_REPLIED]\t\t= IP_VS_SCTP_MAX_RTO,\n\t[IP_VS_SCTP_S_COOKIE_WAIT]\t\t= IP_VS_SCTP_MAX_RTO,\n\t[IP_VS_SCTP_S_COOKIE]\t\t\t= IP_VS_SCTP_MAX_RTO,\n\t[IP_VS_SCTP_S_COOKIE_ECHOED]\t\t= IP_VS_SCTP_MAX_RTO,\n\t[IP_VS_SCTP_S_ESTABLISHED]\t\t= 15 * 60 * HZ,\n\t[IP_VS_SCTP_S_SHUTDOWN_SENT]\t\t= IP_VS_SCTP_MAX_RTO,\n\t[IP_VS_SCTP_S_SHUTDOWN_RECEIVED]\t= IP_VS_SCTP_MAX_RTO,\n\t[IP_VS_SCTP_S_SHUTDOWN_ACK_SENT]\t= IP_VS_SCTP_MAX_RTO,\n\t[IP_VS_SCTP_S_REJECTED]\t\t\t= (0 + 3 + 1) * HZ,\n\t[IP_VS_SCTP_S_CLOSED]\t\t\t= IP_VS_SCTP_MAX_RTO,\n\t[IP_VS_SCTP_S_LAST]\t\t\t= 2 * HZ,\n};\n\nstatic const char *sctp_state_name_table[IP_VS_SCTP_S_LAST + 1] = {\n\t[IP_VS_SCTP_S_NONE]\t\t\t= \"NONE\",\n\t[IP_VS_SCTP_S_INIT1]\t\t\t= \"INIT1\",\n\t[IP_VS_SCTP_S_INIT]\t\t\t= \"INIT\",\n\t[IP_VS_SCTP_S_COOKIE_SENT]\t\t= \"C-SENT\",\n\t[IP_VS_SCTP_S_COOKIE_REPLIED]\t\t= \"C-REPLIED\",\n\t[IP_VS_SCTP_S_COOKIE_WAIT]\t\t= \"C-WAIT\",\n\t[IP_VS_SCTP_S_COOKIE]\t\t\t= \"COOKIE\",\n\t[IP_VS_SCTP_S_COOKIE_ECHOED]\t\t= \"C-ECHOED\",\n\t[IP_VS_SCTP_S_ESTABLISHED]\t\t= \"ESTABLISHED\",\n\t[IP_VS_SCTP_S_SHUTDOWN_SENT]\t\t= \"S-SENT\",\n\t[IP_VS_SCTP_S_SHUTDOWN_RECEIVED]\t= \"S-RECEIVED\",\n\t[IP_VS_SCTP_S_SHUTDOWN_ACK_SENT]\t= \"S-ACK-SENT\",\n\t[IP_VS_SCTP_S_REJECTED]\t\t\t= \"REJECTED\",\n\t[IP_VS_SCTP_S_CLOSED]\t\t\t= \"CLOSED\",\n\t[IP_VS_SCTP_S_LAST]\t\t\t= \"BUG!\",\n};\n\n\nstatic const char *sctp_state_name(int state)\n{\n\tif (state >= IP_VS_SCTP_S_LAST)\n\t\treturn \"ERR!\";\n\tif (sctp_state_name_table[state])\n\t\treturn sctp_state_name_table[state];\n\treturn \"?\";\n}\n\nstatic inline void\nset_sctp_state(struct ip_vs_proto_data *pd, struct ip_vs_conn *cp,\n\t\tint direction, const struct sk_buff *skb)\n{\n\tstruct sctp_chunkhdr _sctpch, *sch;\n\tunsigned char chunk_type;\n\tint event, next_state;\n\tint ihl, cofs;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tihl = cp->af == AF_INET ? ip_hdrlen(skb) : sizeof(struct ipv6hdr);\n#else\n\tihl = ip_hdrlen(skb);\n#endif\n\n\tcofs = ihl + sizeof(struct sctphdr);\n\tsch = skb_header_pointer(skb, cofs, sizeof(_sctpch), &_sctpch);\n\tif (sch == NULL)\n\t\treturn;\n\n\tchunk_type = sch->type;\n\t \n\tif ((sch->type == SCTP_CID_COOKIE_ECHO) ||\n\t    (sch->type == SCTP_CID_COOKIE_ACK)) {\n\t\tint clen = ntohs(sch->length);\n\n\t\tif (clen >= sizeof(_sctpch)) {\n\t\t\tsch = skb_header_pointer(skb, cofs + ALIGN(clen, 4),\n\t\t\t\t\t\t sizeof(_sctpch), &_sctpch);\n\t\t\tif (sch && sch->type == SCTP_CID_ABORT)\n\t\t\t\tchunk_type = sch->type;\n\t\t}\n\t}\n\n\tevent = (chunk_type < sizeof(sctp_events)) ?\n\t\tsctp_events[chunk_type] : IP_VS_SCTP_DATA;\n\n\t \n\tif (cp->flags & IP_VS_CONN_F_NOOUTPUT) {\n\t\tif (direction == IP_VS_DIR_OUTPUT)\n\t\t\tcp->flags &= ~IP_VS_CONN_F_NOOUTPUT;\n\t\telse\n\t\t\tdirection = IP_VS_DIR_INPUT_ONLY;\n\t}\n\n\tnext_state = sctp_states[direction][event][cp->state];\n\n\tif (next_state != cp->state) {\n\t\tstruct ip_vs_dest *dest = cp->dest;\n\n\t\tIP_VS_DBG_BUF(8, \"%s %s  %s:%d->\"\n\t\t\t\t\"%s:%d state: %s->%s conn->refcnt:%d\\n\",\n\t\t\t\tpd->pp->name,\n\t\t\t\t((direction == IP_VS_DIR_OUTPUT) ?\n\t\t\t\t \"output \" : \"input \"),\n\t\t\t\tIP_VS_DBG_ADDR(cp->daf, &cp->daddr),\n\t\t\t\tntohs(cp->dport),\n\t\t\t\tIP_VS_DBG_ADDR(cp->af, &cp->caddr),\n\t\t\t\tntohs(cp->cport),\n\t\t\t\tsctp_state_name(cp->state),\n\t\t\t\tsctp_state_name(next_state),\n\t\t\t\trefcount_read(&cp->refcnt));\n\t\tif (dest) {\n\t\t\tif (!(cp->flags & IP_VS_CONN_F_INACTIVE) &&\n\t\t\t\t(next_state != IP_VS_SCTP_S_ESTABLISHED)) {\n\t\t\t\tatomic_dec(&dest->activeconns);\n\t\t\t\tatomic_inc(&dest->inactconns);\n\t\t\t\tcp->flags |= IP_VS_CONN_F_INACTIVE;\n\t\t\t} else if ((cp->flags & IP_VS_CONN_F_INACTIVE) &&\n\t\t\t\t   (next_state == IP_VS_SCTP_S_ESTABLISHED)) {\n\t\t\t\tatomic_inc(&dest->activeconns);\n\t\t\t\tatomic_dec(&dest->inactconns);\n\t\t\t\tcp->flags &= ~IP_VS_CONN_F_INACTIVE;\n\t\t\t}\n\t\t}\n\t\tif (next_state == IP_VS_SCTP_S_ESTABLISHED)\n\t\t\tip_vs_control_assure_ct(cp);\n\t}\n\tif (likely(pd))\n\t\tcp->timeout = pd->timeout_table[cp->state = next_state];\n\telse\t \n\t\tcp->timeout = sctp_timeouts[cp->state = next_state];\n}\n\nstatic void\nsctp_state_transition(struct ip_vs_conn *cp, int direction,\n\t\tconst struct sk_buff *skb, struct ip_vs_proto_data *pd)\n{\n\tspin_lock_bh(&cp->lock);\n\tset_sctp_state(pd, cp, direction, skb);\n\tspin_unlock_bh(&cp->lock);\n}\n\nstatic inline __u16 sctp_app_hashkey(__be16 port)\n{\n\treturn (((__force u16)port >> SCTP_APP_TAB_BITS) ^ (__force u16)port)\n\t\t& SCTP_APP_TAB_MASK;\n}\n\nstatic int sctp_register_app(struct netns_ipvs *ipvs, struct ip_vs_app *inc)\n{\n\tstruct ip_vs_app *i;\n\t__u16 hash;\n\t__be16 port = inc->port;\n\tint ret = 0;\n\tstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(ipvs, IPPROTO_SCTP);\n\n\thash = sctp_app_hashkey(port);\n\n\tlist_for_each_entry(i, &ipvs->sctp_apps[hash], p_list) {\n\t\tif (i->port == port) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlist_add_rcu(&inc->p_list, &ipvs->sctp_apps[hash]);\n\tatomic_inc(&pd->appcnt);\nout:\n\n\treturn ret;\n}\n\nstatic void sctp_unregister_app(struct netns_ipvs *ipvs, struct ip_vs_app *inc)\n{\n\tstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(ipvs, IPPROTO_SCTP);\n\n\tatomic_dec(&pd->appcnt);\n\tlist_del_rcu(&inc->p_list);\n}\n\nstatic int sctp_app_conn_bind(struct ip_vs_conn *cp)\n{\n\tstruct netns_ipvs *ipvs = cp->ipvs;\n\tint hash;\n\tstruct ip_vs_app *inc;\n\tint result = 0;\n\n\t \n\tif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)\n\t\treturn 0;\n\t \n\thash = sctp_app_hashkey(cp->vport);\n\n\tlist_for_each_entry_rcu(inc, &ipvs->sctp_apps[hash], p_list) {\n\t\tif (inc->port == cp->vport) {\n\t\t\tif (unlikely(!ip_vs_app_inc_get(inc)))\n\t\t\t\tbreak;\n\n\t\t\tIP_VS_DBG_BUF(9, \"%s: Binding conn %s:%u->\"\n\t\t\t\t\t\"%s:%u to app %s on port %u\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tIP_VS_DBG_ADDR(cp->af, &cp->caddr),\n\t\t\t\t\tntohs(cp->cport),\n\t\t\t\t\tIP_VS_DBG_ADDR(cp->af, &cp->vaddr),\n\t\t\t\t\tntohs(cp->vport),\n\t\t\t\t\tinc->name, ntohs(inc->port));\n\t\t\tcp->app = inc;\n\t\t\tif (inc->init_conn)\n\t\t\t\tresult = inc->init_conn(inc, cp);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n \nstatic int __ip_vs_sctp_init(struct netns_ipvs *ipvs, struct ip_vs_proto_data *pd)\n{\n\tip_vs_init_hash_table(ipvs->sctp_apps, SCTP_APP_TAB_SIZE);\n\tpd->timeout_table = ip_vs_create_timeout_table((int *)sctp_timeouts,\n\t\t\t\t\t\t\tsizeof(sctp_timeouts));\n\tif (!pd->timeout_table)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __ip_vs_sctp_exit(struct netns_ipvs *ipvs, struct ip_vs_proto_data *pd)\n{\n\tkfree(pd->timeout_table);\n}\n\nstruct ip_vs_protocol ip_vs_protocol_sctp = {\n\t.name\t\t= \"SCTP\",\n\t.protocol\t= IPPROTO_SCTP,\n\t.num_states\t= IP_VS_SCTP_S_LAST,\n\t.dont_defrag\t= 0,\n\t.init\t\t= NULL,\n\t.exit\t\t= NULL,\n\t.init_netns\t= __ip_vs_sctp_init,\n\t.exit_netns\t= __ip_vs_sctp_exit,\n\t.register_app\t= sctp_register_app,\n\t.unregister_app = sctp_unregister_app,\n\t.conn_schedule\t= sctp_conn_schedule,\n\t.conn_in_get\t= ip_vs_conn_in_get_proto,\n\t.conn_out_get\t= ip_vs_conn_out_get_proto,\n\t.snat_handler\t= sctp_snat_handler,\n\t.dnat_handler\t= sctp_dnat_handler,\n\t.state_name\t= sctp_state_name,\n\t.state_transition = sctp_state_transition,\n\t.app_conn_bind\t= sctp_app_conn_bind,\n\t.debug_packet\t= ip_vs_tcpudp_debug_packet,\n\t.timeout_change\t= NULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}