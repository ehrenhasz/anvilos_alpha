{
  "module_name": "ip_vs_lc.c",
  "hash_id": "0359dba0ceb9d92f8dbf1b2137af721de593ff3618db954e6c61296ec6fcaf88",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_lc.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <net/ip_vs.h>\n\n \nstatic struct ip_vs_dest *\nip_vs_lc_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\n\t\t  struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_dest *dest, *least = NULL;\n\tunsigned int loh = 0, doh;\n\n\tIP_VS_DBG(6, \"%s(): Scheduling...\\n\", __func__);\n\n\t \n\n\tlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\n\t\tif ((dest->flags & IP_VS_DEST_F_OVERLOAD) ||\n\t\t    atomic_read(&dest->weight) == 0)\n\t\t\tcontinue;\n\t\tdoh = ip_vs_dest_conn_overhead(dest);\n\t\tif (!least || doh < loh) {\n\t\t\tleast = dest;\n\t\t\tloh = doh;\n\t\t}\n\t}\n\n\tif (!least)\n\t\tip_vs_scheduler_err(svc, \"no destination available\");\n\telse\n\t\tIP_VS_DBG_BUF(6, \"LC: server %s:%u activeconns %d \"\n\t\t\t      \"inactconns %d\\n\",\n\t\t\t      IP_VS_DBG_ADDR(least->af, &least->addr),\n\t\t\t      ntohs(least->port),\n\t\t\t      atomic_read(&least->activeconns),\n\t\t\t      atomic_read(&least->inactconns));\n\n\treturn least;\n}\n\n\nstatic struct ip_vs_scheduler ip_vs_lc_scheduler = {\n\t.name =\t\t\t\"lc\",\n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list =\t\tLIST_HEAD_INIT(ip_vs_lc_scheduler.n_list),\n\t.schedule =\t\tip_vs_lc_schedule,\n};\n\n\nstatic int __init ip_vs_lc_init(void)\n{\n\treturn register_ip_vs_scheduler(&ip_vs_lc_scheduler) ;\n}\n\nstatic void __exit ip_vs_lc_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_lc_scheduler);\n\tsynchronize_rcu();\n}\n\nmodule_init(ip_vs_lc_init);\nmodule_exit(ip_vs_lc_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}