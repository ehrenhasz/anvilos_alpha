{
  "module_name": "Kconfig",
  "hash_id": "a89f780659da28f77a440f138e1de18db366a5d511d744f650dcfe7dcbf8e49f",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# IP Virtual Server configuration\n#\nmenuconfig IP_VS\n\ttristate \"IP virtual server support\"\n\tdepends on INET && NETFILTER\n\tdepends on (NF_CONNTRACK || NF_CONNTRACK=n)\n\thelp\n\t  IP Virtual Server support will let you build a high-performance\n\t  virtual server based on cluster of two or more real servers. This\n\t  option must be enabled for at least one of the clustered computers\n\t  that will take care of intercepting incoming connections to a\n\t  single IP address and scheduling them to real servers.\n\n\t  Three request dispatching techniques are implemented, they are\n\t  virtual server via NAT, virtual server via tunneling and virtual\n\t  server via direct routing. The several scheduling algorithms can\n\t  be used to choose which server the connection is directed to,\n\t  thus load balancing can be achieved among the servers.  For more\n\t  information and its administration program, please visit the\n\t  following URL: <http://www.linuxvirtualserver.org/>.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nif IP_VS\n\nconfig\tIP_VS_IPV6\n\tbool \"IPv6 support for IPVS\"\n\tdepends on IPV6 = y || IP_VS = IPV6\n\tselect NF_DEFRAG_IPV6\n\thelp\n\t  Add IPv6 support to IPVS.\n\n\t  Say Y if unsure.\n\nconfig\tIP_VS_DEBUG\n\tbool \"IP virtual server debugging\"\n\thelp\n\t  Say Y here if you want to get additional messages useful in\n\t  debugging the IP virtual server code. You can change the debug\n\t  level in /proc/sys/net/ipv4/vs/debug_level\n\nconfig\tIP_VS_TAB_BITS\n\tint \"IPVS connection table size (the Nth power of 2)\"\n\trange 8 20 if !64BIT\n\trange 8 27 if 64BIT\n\tdefault 12\n\thelp\n\t  The IPVS connection hash table uses the chaining scheme to handle\n\t  hash collisions. Using a big IPVS connection hash table will greatly\n\t  reduce conflicts when there are hundreds of thousands of connections\n\t  in the hash table.\n\n\t  Note the table size must be power of 2. The table size will be the\n\t  value of 2 to the your input number power. The number to choose is\n\t  from 8 to 27 for 64BIT(20 otherwise), the default number is 12,\n\t  which means the table size is 4096. Don't input the number too\n\t  small, otherwise you will lose performance on it. You can adapt the\n\t  table size yourself, according to your virtual server application.\n\t  It is good to set the table size not far less than the number of\n\t  connections per second multiplying average lasting time of\n\t  connection in the table.  For example, your virtual server gets 200\n\t  connections per second, the connection lasts for 200 seconds in\n\t  average in the connection table, the table size should be not far\n\t  less than 200x200, it is good to set the table size 32768 (2**15).\n\n\t  Another note that each connection occupies 128 bytes effectively and\n\t  each hash entry uses 8 bytes, so you can estimate how much memory is\n\t  needed for your box.\n\n\t  You can overwrite this number setting conn_tab_bits module parameter\n\t  or by appending ip_vs.conn_tab_bits=? to the kernel command line if\n\t  IP VS was compiled built-in.\n\ncomment \"IPVS transport protocol load balancing support\"\n\nconfig\tIP_VS_PROTO_TCP\n\tbool \"TCP load balancing support\"\n\thelp\n\t  This option enables support for load balancing TCP transport\n\t  protocol. Say Y if unsure.\n\nconfig\tIP_VS_PROTO_UDP\n\tbool \"UDP load balancing support\"\n\thelp\n\t  This option enables support for load balancing UDP transport\n\t  protocol. Say Y if unsure.\n\nconfig\tIP_VS_PROTO_AH_ESP\n\tdef_bool IP_VS_PROTO_ESP || IP_VS_PROTO_AH\n\nconfig\tIP_VS_PROTO_ESP\n\tbool \"ESP load balancing support\"\n\thelp\n\t  This option enables support for load balancing ESP (Encapsulation\n\t  Security Payload) transport protocol. Say Y if unsure.\n\nconfig\tIP_VS_PROTO_AH\n\tbool \"AH load balancing support\"\n\thelp\n\t  This option enables support for load balancing AH (Authentication\n\t  Header) transport protocol. Say Y if unsure.\n\nconfig  IP_VS_PROTO_SCTP\n\tbool \"SCTP load balancing support\"\n\tselect LIBCRC32C\n\thelp\n\t  This option enables support for load balancing SCTP transport\n\t  protocol. Say Y if unsure.\n\ncomment \"IPVS scheduler\"\n\nconfig\tIP_VS_RR\n\ttristate \"round-robin scheduling\"\n\thelp\n\t  The robin-robin scheduling algorithm simply directs network\n\t  connections to different real servers in a round-robin manner.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n \nconfig\tIP_VS_WRR\n\ttristate \"weighted round-robin scheduling\"\n\thelp\n\t  The weighted robin-robin scheduling algorithm directs network\n\t  connections to different real servers based on server weights\n\t  in a round-robin manner. Servers with higher weights receive\n\t  new connections first than those with less weights, and servers\n\t  with higher weights get more connections than those with less\n\t  weights and servers with equal weights get equal connections.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig\tIP_VS_LC\n\ttristate \"least-connection scheduling\"\n\thelp\n\t  The least-connection scheduling algorithm directs network\n\t  connections to the server with the least number of active \n\t  connections.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig\tIP_VS_WLC\n\ttristate \"weighted least-connection scheduling\"\n\thelp\n\t  The weighted least-connection scheduling algorithm directs network\n\t  connections to the server with the least active connections\n\t  normalized by the server weight.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig  IP_VS_FO\n\t\ttristate \"weighted failover scheduling\"\n\thelp\n\t  The weighted failover scheduling algorithm directs network\n\t  connections to the server with the highest weight that is\n\t  currently available.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig  IP_VS_OVF\n\ttristate \"weighted overflow scheduling\"\n\thelp\n\t  The weighted overflow scheduling algorithm directs network\n\t  connections to the server with the highest weight that is\n\t  currently available and overflows to the next when active\n\t  connections exceed the node's weight.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig\tIP_VS_LBLC\n\ttristate \"locality-based least-connection scheduling\"\n\thelp\n\t  The locality-based least-connection scheduling algorithm is for\n\t  destination IP load balancing. It is usually used in cache cluster.\n\t  This algorithm usually directs packet destined for an IP address to\n\t  its server if the server is alive and under load. If the server is\n\t  overloaded (its active connection numbers is larger than its weight)\n\t  and there is a server in its half load, then allocate the weighted\n\t  least-connection server to this IP address.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig  IP_VS_LBLCR\n\ttristate \"locality-based least-connection with replication scheduling\"\n\thelp\n\t  The locality-based least-connection with replication scheduling\n\t  algorithm is also for destination IP load balancing. It is \n\t  usually used in cache cluster. It differs from the LBLC scheduling\n\t  as follows: the load balancer maintains mappings from a target\n\t  to a set of server nodes that can serve the target. Requests for\n\t  a target are assigned to the least-connection node in the target's\n\t  server set. If all the node in the server set are over loaded,\n\t  it picks up a least-connection node in the cluster and adds it\n\t  in the sever set for the target. If the server set has not been\n\t  modified for the specified time, the most loaded node is removed\n\t  from the server set, in order to avoid high degree of replication.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig\tIP_VS_DH\n\ttristate \"destination hashing scheduling\"\n\thelp\n\t  The destination hashing scheduling algorithm assigns network\n\t  connections to the servers through looking up a statically assigned\n\t  hash table by their destination IP addresses.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig\tIP_VS_SH\n\ttristate \"source hashing scheduling\"\n\thelp\n\t  The source hashing scheduling algorithm assigns network\n\t  connections to the servers through looking up a statically assigned\n\t  hash table by their source IP addresses.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig\tIP_VS_MH\n\ttristate \"maglev hashing scheduling\"\n\thelp\n\t  The maglev consistent hashing scheduling algorithm provides the\n\t  Google's Maglev hashing algorithm as a IPVS scheduler. It assigns\n\t  network connections to the servers through looking up a statically\n\t  assigned special hash table called the lookup table. Maglev hashing\n\t  is to assign a preference list of all the lookup table positions\n\t  to each destination.\n\n\t  Through this operation, The maglev hashing gives an almost equal\n\t  share of the lookup table to each of the destinations and provides\n\t  minimal disruption by using the lookup table. When the set of\n\t  destinations changes, a connection will likely be sent to the same\n\t  destination as it was before.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig\tIP_VS_SED\n\ttristate \"shortest expected delay scheduling\"\n\thelp\n\t  The shortest expected delay scheduling algorithm assigns network\n\t  connections to the server with the shortest expected delay. The \n\t  expected delay that the job will experience is (Ci + 1) / Ui if \n\t  sent to the ith server, in which Ci is the number of connections\n\t  on the ith server and Ui is the fixed service rate (weight)\n\t  of the ith server.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig\tIP_VS_NQ\n\ttristate \"never queue scheduling\"\n\thelp\n\t  The never queue scheduling algorithm adopts a two-speed model.\n\t  When there is an idle server available, the job will be sent to\n\t  the idle server, instead of waiting for a fast one. When there\n\t  is no idle server available, the job will be sent to the server\n\t  that minimize its expected delay (The Shortest Expected Delay\n\t  scheduling algorithm).\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig\tIP_VS_TWOS\n\ttristate \"weighted random twos choice least-connection scheduling\"\n\thelp\n\t  The weighted random twos choice least-connection scheduling\n\t  algorithm picks two random real servers and directs network\n\t  connections to the server with the least active connections\n\t  normalized by the server weight.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\ncomment 'IPVS SH scheduler'\n\nconfig IP_VS_SH_TAB_BITS\n\tint \"IPVS source hashing table size (the Nth power of 2)\"\n\trange 4 20\n\tdefault 8\n\thelp\n\t  The source hashing scheduler maps source IPs to destinations\n\t  stored in a hash table. This table is tiled by each destination\n\t  until all slots in the table are filled. When using weights to\n\t  allow destinations to receive more connections, the table is\n\t  tiled an amount proportional to the weights specified. The table\n\t  needs to be large enough to effectively fit all the destinations\n\t  multiplied by their respective weights.\n\ncomment 'IPVS MH scheduler'\n\nconfig IP_VS_MH_TAB_INDEX\n\tint \"IPVS maglev hashing table index of size (the prime numbers)\"\n\trange 8 17\n\tdefault 12\n\thelp\n\t  The maglev hashing scheduler maps source IPs to destinations\n\t  stored in a hash table. This table is assigned by a preference\n\t  list of the positions to each destination until all slots in\n\t  the table are filled. The index determines the prime for size of\n\t  the table as\u00a0251, 509, 1021, 2039, 4093, 8191, 16381, 32749,\n\t  65521 or 131071.\u00a0When using weights to allow destinations to\n\t  receive more connections,\u00a0the table is assigned an amount\n\t  proportional to the weights specified.\u00a0The table needs to be large\n\t  enough to effectively fit all the destinations multiplied by their\n\t  respective weights.\n\ncomment 'IPVS application helper'\n\nconfig\tIP_VS_FTP\n\ttristate \"FTP protocol helper\"\n\tdepends on IP_VS_PROTO_TCP && NF_CONNTRACK && NF_NAT && \\\n\t\tNF_CONNTRACK_FTP\n\tselect IP_VS_NFCT\n\thelp\n\t  FTP is a protocol that transfers IP address and/or port number in\n\t  the payload. In the virtual server via Network Address Translation,\n\t  the IP address and port number of real servers cannot be sent to\n\t  clients in ftp connections directly, so FTP protocol helper is\n\t  required for tracking the connection and mangling it back to that of\n\t  virtual service.\n\n\t  If you want to compile it in kernel, say Y. To compile it as a\n\t  module, choose M here. If unsure, say N.\n\nconfig\tIP_VS_NFCT\n\tbool \"Netfilter connection tracking\"\n\tdepends on NF_CONNTRACK\n\thelp\n\t  The Netfilter connection tracking support allows the IPVS\n\t  connection state to be exported to the Netfilter framework\n\t  for filtering purposes.\n\nconfig\tIP_VS_PE_SIP\n\ttristate \"SIP persistence engine\"\n\tdepends on IP_VS_PROTO_UDP\n\tdepends on NF_CONNTRACK_SIP\n\thelp\n\t  Allow persistence based on the SIP Call-ID\n\nendif # IP_VS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}