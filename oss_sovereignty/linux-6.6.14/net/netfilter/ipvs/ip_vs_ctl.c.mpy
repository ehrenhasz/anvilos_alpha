{
  "module_name": "ip_vs_ctl.c",
  "hash_id": "02e79e206a07c4ad4828a5ad32768c812d1cfbcdd3e1b5a7daab9ec25e5829d5",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_ctl.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/sysctl.h>\n#include <linux/proc_fs.h>\n#include <linux/workqueue.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/mutex.h>\n\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <net/ip.h>\n#ifdef CONFIG_IP_VS_IPV6\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n#endif\n#include <net/route.h>\n#include <net/sock.h>\n#include <net/genetlink.h>\n\n#include <linux/uaccess.h>\n\n#include <net/ip_vs.h>\n\nMODULE_ALIAS_GENL_FAMILY(IPVS_GENL_NAME);\n\nDEFINE_MUTEX(__ip_vs_mutex);  \n\n \n\n#ifdef CONFIG_IP_VS_DEBUG\nstatic int sysctl_ip_vs_debug_level = 0;\n\nint ip_vs_get_debug_level(void)\n{\n\treturn sysctl_ip_vs_debug_level;\n}\n#endif\n\n\n \nstatic void __ip_vs_del_service(struct ip_vs_service *svc, bool cleanup);\n\n\n#ifdef CONFIG_IP_VS_IPV6\n \nstatic bool __ip_vs_addr_is_local_v6(struct net *net,\n\t\t\t\t     const struct in6_addr *addr)\n{\n\tstruct flowi6 fl6 = {\n\t\t.daddr = *addr,\n\t};\n\tstruct dst_entry *dst = ip6_route_output(net, NULL, &fl6);\n\tbool is_local;\n\n\tis_local = !dst->error && dst->dev && (dst->dev->flags & IFF_LOOPBACK);\n\n\tdst_release(dst);\n\treturn is_local;\n}\n#endif\n\n#ifdef CONFIG_SYSCTL\n \nstatic void update_defense_level(struct netns_ipvs *ipvs)\n{\n\tstruct sysinfo i;\n\tint availmem;\n\tint nomem;\n\tint to_change = -1;\n\n\t \n\tsi_meminfo(&i);\n\tavailmem = i.freeram + i.bufferram;\n\t \n\t \n\t \n\n\tnomem = (availmem < ipvs->sysctl_amemthresh);\n\n\tlocal_bh_disable();\n\n\t \n\tspin_lock(&ipvs->dropentry_lock);\n\tswitch (ipvs->sysctl_drop_entry) {\n\tcase 0:\n\t\tatomic_set(&ipvs->dropentry, 0);\n\t\tbreak;\n\tcase 1:\n\t\tif (nomem) {\n\t\t\tatomic_set(&ipvs->dropentry, 1);\n\t\t\tipvs->sysctl_drop_entry = 2;\n\t\t} else {\n\t\t\tatomic_set(&ipvs->dropentry, 0);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (nomem) {\n\t\t\tatomic_set(&ipvs->dropentry, 1);\n\t\t} else {\n\t\t\tatomic_set(&ipvs->dropentry, 0);\n\t\t\tipvs->sysctl_drop_entry = 1;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tatomic_set(&ipvs->dropentry, 1);\n\t\tbreak;\n\t}\n\tspin_unlock(&ipvs->dropentry_lock);\n\n\t \n\tspin_lock(&ipvs->droppacket_lock);\n\tswitch (ipvs->sysctl_drop_packet) {\n\tcase 0:\n\t\tipvs->drop_rate = 0;\n\t\tbreak;\n\tcase 1:\n\t\tif (nomem) {\n\t\t\tipvs->drop_rate = ipvs->drop_counter\n\t\t\t\t= ipvs->sysctl_amemthresh /\n\t\t\t\t(ipvs->sysctl_amemthresh-availmem);\n\t\t\tipvs->sysctl_drop_packet = 2;\n\t\t} else {\n\t\t\tipvs->drop_rate = 0;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (nomem) {\n\t\t\tipvs->drop_rate = ipvs->drop_counter\n\t\t\t\t= ipvs->sysctl_amemthresh /\n\t\t\t\t(ipvs->sysctl_amemthresh-availmem);\n\t\t} else {\n\t\t\tipvs->drop_rate = 0;\n\t\t\tipvs->sysctl_drop_packet = 1;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tipvs->drop_rate = ipvs->sysctl_am_droprate;\n\t\tbreak;\n\t}\n\tspin_unlock(&ipvs->droppacket_lock);\n\n\t \n\tspin_lock(&ipvs->securetcp_lock);\n\tswitch (ipvs->sysctl_secure_tcp) {\n\tcase 0:\n\t\tif (ipvs->old_secure_tcp >= 2)\n\t\t\tto_change = 0;\n\t\tbreak;\n\tcase 1:\n\t\tif (nomem) {\n\t\t\tif (ipvs->old_secure_tcp < 2)\n\t\t\t\tto_change = 1;\n\t\t\tipvs->sysctl_secure_tcp = 2;\n\t\t} else {\n\t\t\tif (ipvs->old_secure_tcp >= 2)\n\t\t\t\tto_change = 0;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (nomem) {\n\t\t\tif (ipvs->old_secure_tcp < 2)\n\t\t\t\tto_change = 1;\n\t\t} else {\n\t\t\tif (ipvs->old_secure_tcp >= 2)\n\t\t\t\tto_change = 0;\n\t\t\tipvs->sysctl_secure_tcp = 1;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif (ipvs->old_secure_tcp < 2)\n\t\t\tto_change = 1;\n\t\tbreak;\n\t}\n\tipvs->old_secure_tcp = ipvs->sysctl_secure_tcp;\n\tif (to_change >= 0)\n\t\tip_vs_protocol_timeout_change(ipvs,\n\t\t\t\t\t      ipvs->sysctl_secure_tcp > 1);\n\tspin_unlock(&ipvs->securetcp_lock);\n\n\tlocal_bh_enable();\n}\n\n \nstatic void expire_nodest_conn_handler(struct work_struct *work)\n{\n\tstruct netns_ipvs *ipvs;\n\n\tipvs = container_of(work, struct netns_ipvs,\n\t\t\t    expire_nodest_conn_work.work);\n\tip_vs_expire_nodest_conn_flush(ipvs);\n}\n\n \n#define DEFENSE_TIMER_PERIOD\t1*HZ\n\nstatic void defense_work_handler(struct work_struct *work)\n{\n\tstruct netns_ipvs *ipvs =\n\t\tcontainer_of(work, struct netns_ipvs, defense_work.work);\n\n\tupdate_defense_level(ipvs);\n\tif (atomic_read(&ipvs->dropentry))\n\t\tip_vs_random_dropentry(ipvs);\n\tqueue_delayed_work(system_long_wq, &ipvs->defense_work,\n\t\t\t   DEFENSE_TIMER_PERIOD);\n}\n#endif\n\nstatic void est_reload_work_handler(struct work_struct *work)\n{\n\tstruct netns_ipvs *ipvs =\n\t\tcontainer_of(work, struct netns_ipvs, est_reload_work.work);\n\tint genid_done = atomic_read(&ipvs->est_genid_done);\n\tunsigned long delay = HZ / 10;\t \n\tbool repeat = false;\n\tint genid;\n\tint id;\n\n\tmutex_lock(&ipvs->est_mutex);\n\tgenid = atomic_read(&ipvs->est_genid);\n\tfor (id = 0; id < ipvs->est_kt_count; id++) {\n\t\tstruct ip_vs_est_kt_data *kd = ipvs->est_kt_arr[id];\n\n\t\t \n\t\tif (!ipvs->enable)\n\t\t\tgoto unlock;\n\t\tif (!kd)\n\t\t\tcontinue;\n\t\t \n\t\tif (genid != genid_done)\n\t\t\tip_vs_est_kthread_stop(kd);\n\t\tif (!kd->task && !ip_vs_est_stopped(ipvs)) {\n\t\t\t \n\t\t\tif ((!id || !ipvs->est_calc_phase) &&\n\t\t\t    ip_vs_est_kthread_start(ipvs, kd) < 0)\n\t\t\t\trepeat = true;\n\t\t}\n\t}\n\n\tatomic_set(&ipvs->est_genid_done, genid);\n\n\tif (repeat)\n\t\tqueue_delayed_work(system_long_wq, &ipvs->est_reload_work,\n\t\t\t\t   delay);\n\nunlock:\n\tmutex_unlock(&ipvs->est_mutex);\n}\n\nint\nip_vs_use_count_inc(void)\n{\n\treturn try_module_get(THIS_MODULE);\n}\n\nvoid\nip_vs_use_count_dec(void)\n{\n\tmodule_put(THIS_MODULE);\n}\n\n\n \n#define IP_VS_SVC_TAB_BITS 8\n#define IP_VS_SVC_TAB_SIZE (1 << IP_VS_SVC_TAB_BITS)\n#define IP_VS_SVC_TAB_MASK (IP_VS_SVC_TAB_SIZE - 1)\n\n \nstatic struct hlist_head ip_vs_svc_table[IP_VS_SVC_TAB_SIZE];\n \nstatic struct hlist_head ip_vs_svc_fwm_table[IP_VS_SVC_TAB_SIZE];\n\n\n \nstatic inline unsigned int\nip_vs_svc_hashkey(struct netns_ipvs *ipvs, int af, unsigned int proto,\n\t\t  const union nf_inet_addr *addr, __be16 port)\n{\n\tunsigned int porth = ntohs(port);\n\t__be32 addr_fold = addr->ip;\n\t__u32 ahash;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\tahash = ntohl(addr_fold);\n\tahash ^= ((size_t) ipvs >> 8);\n\n\treturn (proto ^ ahash ^ (porth >> IP_VS_SVC_TAB_BITS) ^ porth) &\n\t       IP_VS_SVC_TAB_MASK;\n}\n\n \nstatic inline unsigned int ip_vs_svc_fwm_hashkey(struct netns_ipvs *ipvs, __u32 fwmark)\n{\n\treturn (((size_t)ipvs>>8) ^ fwmark) & IP_VS_SVC_TAB_MASK;\n}\n\n \nstatic int ip_vs_svc_hash(struct ip_vs_service *svc)\n{\n\tunsigned int hash;\n\n\tif (svc->flags & IP_VS_SVC_F_HASHED) {\n\t\tpr_err(\"%s(): request for already hashed, called from %pS\\n\",\n\t\t       __func__, __builtin_return_address(0));\n\t\treturn 0;\n\t}\n\n\tif (svc->fwmark == 0) {\n\t\t \n\t\thash = ip_vs_svc_hashkey(svc->ipvs, svc->af, svc->protocol,\n\t\t\t\t\t &svc->addr, svc->port);\n\t\thlist_add_head_rcu(&svc->s_list, &ip_vs_svc_table[hash]);\n\t} else {\n\t\t \n\t\thash = ip_vs_svc_fwm_hashkey(svc->ipvs, svc->fwmark);\n\t\thlist_add_head_rcu(&svc->f_list, &ip_vs_svc_fwm_table[hash]);\n\t}\n\n\tsvc->flags |= IP_VS_SVC_F_HASHED;\n\t \n\tatomic_inc(&svc->refcnt);\n\treturn 1;\n}\n\n\n \nstatic int ip_vs_svc_unhash(struct ip_vs_service *svc)\n{\n\tif (!(svc->flags & IP_VS_SVC_F_HASHED)) {\n\t\tpr_err(\"%s(): request for unhash flagged, called from %pS\\n\",\n\t\t       __func__, __builtin_return_address(0));\n\t\treturn 0;\n\t}\n\n\tif (svc->fwmark == 0) {\n\t\t \n\t\thlist_del_rcu(&svc->s_list);\n\t} else {\n\t\t \n\t\thlist_del_rcu(&svc->f_list);\n\t}\n\n\tsvc->flags &= ~IP_VS_SVC_F_HASHED;\n\tatomic_dec(&svc->refcnt);\n\treturn 1;\n}\n\n\n \nstatic inline struct ip_vs_service *\n__ip_vs_service_find(struct netns_ipvs *ipvs, int af, __u16 protocol,\n\t\t     const union nf_inet_addr *vaddr, __be16 vport)\n{\n\tunsigned int hash;\n\tstruct ip_vs_service *svc;\n\n\t \n\thash = ip_vs_svc_hashkey(ipvs, af, protocol, vaddr, vport);\n\n\thlist_for_each_entry_rcu(svc, &ip_vs_svc_table[hash], s_list) {\n\t\tif ((svc->af == af)\n\t\t    && ip_vs_addr_equal(af, &svc->addr, vaddr)\n\t\t    && (svc->port == vport)\n\t\t    && (svc->protocol == protocol)\n\t\t    && (svc->ipvs == ipvs)) {\n\t\t\t \n\t\t\treturn svc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n \nstatic inline struct ip_vs_service *\n__ip_vs_svc_fwm_find(struct netns_ipvs *ipvs, int af, __u32 fwmark)\n{\n\tunsigned int hash;\n\tstruct ip_vs_service *svc;\n\n\t \n\thash = ip_vs_svc_fwm_hashkey(ipvs, fwmark);\n\n\thlist_for_each_entry_rcu(svc, &ip_vs_svc_fwm_table[hash], f_list) {\n\t\tif (svc->fwmark == fwmark && svc->af == af\n\t\t    && (svc->ipvs == ipvs)) {\n\t\t\t \n\t\t\treturn svc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstruct ip_vs_service *\nip_vs_service_find(struct netns_ipvs *ipvs, int af, __u32 fwmark, __u16 protocol,\n\t\t   const union nf_inet_addr *vaddr, __be16 vport)\n{\n\tstruct ip_vs_service *svc;\n\n\t \n\tif (fwmark) {\n\t\tsvc = __ip_vs_svc_fwm_find(ipvs, af, fwmark);\n\t\tif (svc)\n\t\t\tgoto out;\n\t}\n\n\t \n\tsvc = __ip_vs_service_find(ipvs, af, protocol, vaddr, vport);\n\n\tif (!svc && protocol == IPPROTO_TCP &&\n\t    atomic_read(&ipvs->ftpsvc_counter) &&\n\t    (vport == FTPDATA || !inet_port_requires_bind_service(ipvs->net, ntohs(vport)))) {\n\t\t \n\t\tsvc = __ip_vs_service_find(ipvs, af, protocol, vaddr, FTPPORT);\n\t}\n\n\tif (svc == NULL\n\t    && atomic_read(&ipvs->nullsvc_counter)) {\n\t\t \n\t\tsvc = __ip_vs_service_find(ipvs, af, protocol, vaddr, 0);\n\t}\n\n  out:\n\tIP_VS_DBG_BUF(9, \"lookup service: fwm %u %s %s:%u %s\\n\",\n\t\t      fwmark, ip_vs_proto_name(protocol),\n\t\t      IP_VS_DBG_ADDR(af, vaddr), ntohs(vport),\n\t\t      svc ? \"hit\" : \"not hit\");\n\n\treturn svc;\n}\n\n\nstatic inline void\n__ip_vs_bind_svc(struct ip_vs_dest *dest, struct ip_vs_service *svc)\n{\n\tatomic_inc(&svc->refcnt);\n\trcu_assign_pointer(dest->svc, svc);\n}\n\nstatic void ip_vs_service_free(struct ip_vs_service *svc)\n{\n\tip_vs_stats_release(&svc->stats);\n\tkfree(svc);\n}\n\nstatic void ip_vs_service_rcu_free(struct rcu_head *head)\n{\n\tstruct ip_vs_service *svc;\n\n\tsvc = container_of(head, struct ip_vs_service, rcu_head);\n\tip_vs_service_free(svc);\n}\n\nstatic void __ip_vs_svc_put(struct ip_vs_service *svc)\n{\n\tif (atomic_dec_and_test(&svc->refcnt)) {\n\t\tIP_VS_DBG_BUF(3, \"Removing service %u/%s:%u\\n\",\n\t\t\t      svc->fwmark,\n\t\t\t      IP_VS_DBG_ADDR(svc->af, &svc->addr),\n\t\t\t      ntohs(svc->port));\n\t\tcall_rcu(&svc->rcu_head, ip_vs_service_rcu_free);\n\t}\n}\n\n\n \nstatic inline unsigned int ip_vs_rs_hashkey(int af,\n\t\t\t\t\t    const union nf_inet_addr *addr,\n\t\t\t\t\t    __be16 port)\n{\n\tunsigned int porth = ntohs(port);\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\n\treturn (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)\n\t\t& IP_VS_RTAB_MASK;\n}\n\n \nstatic void ip_vs_rs_hash(struct netns_ipvs *ipvs, struct ip_vs_dest *dest)\n{\n\tunsigned int hash;\n\t__be16 port;\n\n\tif (dest->in_rs_table)\n\t\treturn;\n\n\tswitch (IP_VS_DFWD_METHOD(dest)) {\n\tcase IP_VS_CONN_F_MASQ:\n\t\tport = dest->port;\n\t\tbreak;\n\tcase IP_VS_CONN_F_TUNNEL:\n\t\tswitch (dest->tun_type) {\n\t\tcase IP_VS_CONN_F_TUNNEL_TYPE_GUE:\n\t\t\tport = dest->tun_port;\n\t\t\tbreak;\n\t\tcase IP_VS_CONN_F_TUNNEL_TYPE_IPIP:\n\t\tcase IP_VS_CONN_F_TUNNEL_TYPE_GRE:\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\thash = ip_vs_rs_hashkey(dest->af, &dest->addr, port);\n\n\thlist_add_head_rcu(&dest->d_list, &ipvs->rs_table[hash]);\n\tdest->in_rs_table = 1;\n}\n\n \nstatic void ip_vs_rs_unhash(struct ip_vs_dest *dest)\n{\n\t \n\tif (dest->in_rs_table) {\n\t\thlist_del_rcu(&dest->d_list);\n\t\tdest->in_rs_table = 0;\n\t}\n}\n\n \nbool ip_vs_has_real_service(struct netns_ipvs *ipvs, int af, __u16 protocol,\n\t\t\t    const union nf_inet_addr *daddr, __be16 dport)\n{\n\tunsigned int hash;\n\tstruct ip_vs_dest *dest;\n\n\t \n\thash = ip_vs_rs_hashkey(af, daddr, dport);\n\n\thlist_for_each_entry_rcu(dest, &ipvs->rs_table[hash], d_list) {\n\t\tif (dest->port == dport &&\n\t\t    dest->af == af &&\n\t\t    ip_vs_addr_equal(af, &dest->addr, daddr) &&\n\t\t    (dest->protocol == protocol || dest->vfwmark) &&\n\t\t    IP_VS_DFWD_METHOD(dest) == IP_VS_CONN_F_MASQ) {\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstruct ip_vs_dest *ip_vs_find_real_service(struct netns_ipvs *ipvs, int af,\n\t\t\t\t\t   __u16 protocol,\n\t\t\t\t\t   const union nf_inet_addr *daddr,\n\t\t\t\t\t   __be16 dport)\n{\n\tunsigned int hash;\n\tstruct ip_vs_dest *dest;\n\n\t \n\thash = ip_vs_rs_hashkey(af, daddr, dport);\n\n\thlist_for_each_entry_rcu(dest, &ipvs->rs_table[hash], d_list) {\n\t\tif (dest->port == dport &&\n\t\t    dest->af == af &&\n\t\t    ip_vs_addr_equal(af, &dest->addr, daddr) &&\n\t\t    (dest->protocol == protocol || dest->vfwmark) &&\n\t\t    IP_VS_DFWD_METHOD(dest) == IP_VS_CONN_F_MASQ) {\n\t\t\t \n\t\t\treturn dest;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstruct ip_vs_dest *ip_vs_find_tunnel(struct netns_ipvs *ipvs, int af,\n\t\t\t\t     const union nf_inet_addr *daddr,\n\t\t\t\t     __be16 tun_port)\n{\n\tstruct ip_vs_dest *dest;\n\tunsigned int hash;\n\n\t \n\thash = ip_vs_rs_hashkey(af, daddr, tun_port);\n\n\thlist_for_each_entry_rcu(dest, &ipvs->rs_table[hash], d_list) {\n\t\tif (dest->tun_port == tun_port &&\n\t\t    dest->af == af &&\n\t\t    ip_vs_addr_equal(af, &dest->addr, daddr) &&\n\t\t    IP_VS_DFWD_METHOD(dest) == IP_VS_CONN_F_TUNNEL) {\n\t\t\t \n\t\t\treturn dest;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct ip_vs_dest *\nip_vs_lookup_dest(struct ip_vs_service *svc, int dest_af,\n\t\t  const union nf_inet_addr *daddr, __be16 dport)\n{\n\tstruct ip_vs_dest *dest;\n\n\t \n\tlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\n\t\tif ((dest->af == dest_af) &&\n\t\t    ip_vs_addr_equal(dest_af, &dest->addr, daddr) &&\n\t\t    (dest->port == dport)) {\n\t\t\t \n\t\t\treturn dest;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstruct ip_vs_dest *ip_vs_find_dest(struct netns_ipvs *ipvs, int svc_af, int dest_af,\n\t\t\t\t   const union nf_inet_addr *daddr,\n\t\t\t\t   __be16 dport,\n\t\t\t\t   const union nf_inet_addr *vaddr,\n\t\t\t\t   __be16 vport, __u16 protocol, __u32 fwmark,\n\t\t\t\t   __u32 flags)\n{\n\tstruct ip_vs_dest *dest;\n\tstruct ip_vs_service *svc;\n\t__be16 port = dport;\n\n\tsvc = ip_vs_service_find(ipvs, svc_af, fwmark, protocol, vaddr, vport);\n\tif (!svc)\n\t\treturn NULL;\n\tif (fwmark && (flags & IP_VS_CONN_F_FWD_MASK) != IP_VS_CONN_F_MASQ)\n\t\tport = 0;\n\tdest = ip_vs_lookup_dest(svc, dest_af, daddr, port);\n\tif (!dest)\n\t\tdest = ip_vs_lookup_dest(svc, dest_af, daddr, port ^ dport);\n\treturn dest;\n}\n\nvoid ip_vs_dest_dst_rcu_free(struct rcu_head *head)\n{\n\tstruct ip_vs_dest_dst *dest_dst = container_of(head,\n\t\t\t\t\t\t       struct ip_vs_dest_dst,\n\t\t\t\t\t\t       rcu_head);\n\n\tdst_release(dest_dst->dst_cache);\n\tkfree(dest_dst);\n}\n\n \nstatic void __ip_vs_dst_cache_reset(struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_dest_dst *old;\n\n\told = rcu_dereference_protected(dest->dest_dst, 1);\n\tif (old) {\n\t\tRCU_INIT_POINTER(dest->dest_dst, NULL);\n\t\tcall_rcu(&old->rcu_head, ip_vs_dest_dst_rcu_free);\n\t}\n}\n\n \nstatic struct ip_vs_dest *\nip_vs_trash_get_dest(struct ip_vs_service *svc, int dest_af,\n\t\t     const union nf_inet_addr *daddr, __be16 dport)\n{\n\tstruct ip_vs_dest *dest;\n\tstruct netns_ipvs *ipvs = svc->ipvs;\n\n\t \n\tspin_lock_bh(&ipvs->dest_trash_lock);\n\tlist_for_each_entry(dest, &ipvs->dest_trash, t_list) {\n\t\tIP_VS_DBG_BUF(3, \"Destination %u/%s:%u still in trash, \"\n\t\t\t      \"dest->refcnt=%d\\n\",\n\t\t\t      dest->vfwmark,\n\t\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t\t      ntohs(dest->port),\n\t\t\t      refcount_read(&dest->refcnt));\n\t\tif (dest->af == dest_af &&\n\t\t    ip_vs_addr_equal(dest_af, &dest->addr, daddr) &&\n\t\t    dest->port == dport &&\n\t\t    dest->vfwmark == svc->fwmark &&\n\t\t    dest->protocol == svc->protocol &&\n\t\t    (svc->fwmark ||\n\t\t     (ip_vs_addr_equal(svc->af, &dest->vaddr, &svc->addr) &&\n\t\t      dest->vport == svc->port))) {\n\t\t\t \n\t\t\tlist_del(&dest->t_list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdest = NULL;\n\nout:\n\tspin_unlock_bh(&ipvs->dest_trash_lock);\n\n\treturn dest;\n}\n\nstatic void ip_vs_dest_rcu_free(struct rcu_head *head)\n{\n\tstruct ip_vs_dest *dest;\n\n\tdest = container_of(head, struct ip_vs_dest, rcu_head);\n\tip_vs_stats_release(&dest->stats);\n\tip_vs_dest_put_and_free(dest);\n}\n\nstatic void ip_vs_dest_free(struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_service *svc = rcu_dereference_protected(dest->svc, 1);\n\n\t__ip_vs_dst_cache_reset(dest);\n\t__ip_vs_svc_put(svc);\n\tcall_rcu(&dest->rcu_head, ip_vs_dest_rcu_free);\n}\n\n \nstatic void ip_vs_trash_cleanup(struct netns_ipvs *ipvs)\n{\n\tstruct ip_vs_dest *dest, *nxt;\n\n\tdel_timer_sync(&ipvs->dest_trash_timer);\n\t \n\tlist_for_each_entry_safe(dest, nxt, &ipvs->dest_trash, t_list) {\n\t\tlist_del(&dest->t_list);\n\t\tip_vs_dest_free(dest);\n\t}\n}\n\nstatic void ip_vs_stats_rcu_free(struct rcu_head *head)\n{\n\tstruct ip_vs_stats_rcu *rs = container_of(head,\n\t\t\t\t\t\t  struct ip_vs_stats_rcu,\n\t\t\t\t\t\t  rcu_head);\n\n\tip_vs_stats_release(&rs->s);\n\tkfree(rs);\n}\n\nstatic void\nip_vs_copy_stats(struct ip_vs_kstats *dst, struct ip_vs_stats *src)\n{\n#define IP_VS_SHOW_STATS_COUNTER(c) dst->c = src->kstats.c - src->kstats0.c\n\n\tspin_lock(&src->lock);\n\n\tIP_VS_SHOW_STATS_COUNTER(conns);\n\tIP_VS_SHOW_STATS_COUNTER(inpkts);\n\tIP_VS_SHOW_STATS_COUNTER(outpkts);\n\tIP_VS_SHOW_STATS_COUNTER(inbytes);\n\tIP_VS_SHOW_STATS_COUNTER(outbytes);\n\n\tip_vs_read_estimator(dst, src);\n\n\tspin_unlock(&src->lock);\n}\n\nstatic void\nip_vs_export_stats_user(struct ip_vs_stats_user *dst, struct ip_vs_kstats *src)\n{\n\tdst->conns = (u32)src->conns;\n\tdst->inpkts = (u32)src->inpkts;\n\tdst->outpkts = (u32)src->outpkts;\n\tdst->inbytes = src->inbytes;\n\tdst->outbytes = src->outbytes;\n\tdst->cps = (u32)src->cps;\n\tdst->inpps = (u32)src->inpps;\n\tdst->outpps = (u32)src->outpps;\n\tdst->inbps = (u32)src->inbps;\n\tdst->outbps = (u32)src->outbps;\n}\n\nstatic void\nip_vs_zero_stats(struct ip_vs_stats *stats)\n{\n\tspin_lock(&stats->lock);\n\n\t \n\n#define IP_VS_ZERO_STATS_COUNTER(c) stats->kstats0.c = stats->kstats.c\n\n\tIP_VS_ZERO_STATS_COUNTER(conns);\n\tIP_VS_ZERO_STATS_COUNTER(inpkts);\n\tIP_VS_ZERO_STATS_COUNTER(outpkts);\n\tIP_VS_ZERO_STATS_COUNTER(inbytes);\n\tIP_VS_ZERO_STATS_COUNTER(outbytes);\n\n\tip_vs_zero_estimator(stats);\n\n\tspin_unlock(&stats->lock);\n}\n\n \nint ip_vs_stats_init_alloc(struct ip_vs_stats *s)\n{\n\tint i;\n\n\tspin_lock_init(&s->lock);\n\ts->cpustats = alloc_percpu(struct ip_vs_cpu_stats);\n\tif (!s->cpustats)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct ip_vs_cpu_stats *cs = per_cpu_ptr(s->cpustats, i);\n\n\t\tu64_stats_init(&cs->syncp);\n\t}\n\treturn 0;\n}\n\nstruct ip_vs_stats *ip_vs_stats_alloc(void)\n{\n\tstruct ip_vs_stats *s = kzalloc(sizeof(*s), GFP_KERNEL);\n\n\tif (s && ip_vs_stats_init_alloc(s) >= 0)\n\t\treturn s;\n\tkfree(s);\n\treturn NULL;\n}\n\nvoid ip_vs_stats_release(struct ip_vs_stats *stats)\n{\n\tfree_percpu(stats->cpustats);\n}\n\nvoid ip_vs_stats_free(struct ip_vs_stats *stats)\n{\n\tif (stats) {\n\t\tip_vs_stats_release(stats);\n\t\tkfree(stats);\n\t}\n}\n\n \nstatic void\n__ip_vs_update_dest(struct ip_vs_service *svc, struct ip_vs_dest *dest,\n\t\t    struct ip_vs_dest_user_kern *udest, int add)\n{\n\tstruct netns_ipvs *ipvs = svc->ipvs;\n\tstruct ip_vs_service *old_svc;\n\tstruct ip_vs_scheduler *sched;\n\tint conn_flags;\n\n\t \n\tBUG_ON(!add && udest->af != dest->af);\n\n\tif (add && udest->af != svc->af)\n\t\tipvs->mixed_address_family_dests++;\n\n\t \n\tif (add || udest->weight != 0)\n\t\tatomic_set(&dest->last_weight, udest->weight);\n\n\t \n\tatomic_set(&dest->weight, udest->weight);\n\tconn_flags = udest->conn_flags & IP_VS_CONN_F_DEST_MASK;\n\tconn_flags |= IP_VS_CONN_F_INACTIVE;\n\n\t \n\tif ((udest->conn_flags & IP_VS_CONN_F_FWD_MASK) !=\n\t    IP_VS_DFWD_METHOD(dest) ||\n\t    udest->tun_type != dest->tun_type ||\n\t    udest->tun_port != dest->tun_port)\n\t\tip_vs_rs_unhash(dest);\n\n\t \n\tdest->tun_type = udest->tun_type;\n\tdest->tun_port = udest->tun_port;\n\tdest->tun_flags = udest->tun_flags;\n\n\t \n\tif ((conn_flags & IP_VS_CONN_F_FWD_MASK) != IP_VS_CONN_F_MASQ) {\n\t\tconn_flags |= IP_VS_CONN_F_NOOUTPUT;\n\t} else {\n\t\t \n\t\tif (svc->port == FTPPORT)\n\t\t\tip_vs_register_conntrack(svc);\n\t}\n\tatomic_set(&dest->conn_flags, conn_flags);\n\t \n\tip_vs_rs_hash(ipvs, dest);\n\n\t \n\told_svc = rcu_dereference_protected(dest->svc, 1);\n\tif (!old_svc) {\n\t\t__ip_vs_bind_svc(dest, svc);\n\t} else {\n\t\tif (old_svc != svc) {\n\t\t\tip_vs_zero_stats(&dest->stats);\n\t\t\t__ip_vs_bind_svc(dest, svc);\n\t\t\t__ip_vs_svc_put(old_svc);\n\t\t}\n\t}\n\n\t \n\tdest->flags |= IP_VS_DEST_F_AVAILABLE;\n\n\tif (udest->u_threshold == 0 || udest->u_threshold > dest->u_threshold)\n\t\tdest->flags &= ~IP_VS_DEST_F_OVERLOAD;\n\tdest->u_threshold = udest->u_threshold;\n\tdest->l_threshold = udest->l_threshold;\n\n\tdest->af = udest->af;\n\n\tspin_lock_bh(&dest->dst_lock);\n\t__ip_vs_dst_cache_reset(dest);\n\tspin_unlock_bh(&dest->dst_lock);\n\n\tif (add) {\n\t\tlist_add_rcu(&dest->n_list, &svc->destinations);\n\t\tsvc->num_dests++;\n\t\tsched = rcu_dereference_protected(svc->scheduler, 1);\n\t\tif (sched && sched->add_dest)\n\t\t\tsched->add_dest(svc, dest);\n\t} else {\n\t\tsched = rcu_dereference_protected(svc->scheduler, 1);\n\t\tif (sched && sched->upd_dest)\n\t\t\tsched->upd_dest(svc, dest);\n\t}\n}\n\n\n \nstatic int\nip_vs_new_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\n{\n\tstruct ip_vs_dest *dest;\n\tunsigned int atype;\n\tint ret;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (udest->af == AF_INET6) {\n\t\tatype = ipv6_addr_type(&udest->addr.in6);\n\t\tif ((!(atype & IPV6_ADDR_UNICAST) ||\n\t\t\tatype & IPV6_ADDR_LINKLOCAL) &&\n\t\t\t!__ip_vs_addr_is_local_v6(svc->ipvs->net, &udest->addr.in6))\n\t\t\treturn -EINVAL;\n\n\t\tret = nf_defrag_ipv6_enable(svc->ipvs->net);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n#endif\n\t{\n\t\tatype = inet_addr_type(svc->ipvs->net, udest->addr.ip);\n\t\tif (atype != RTN_LOCAL && atype != RTN_UNICAST)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdest = kzalloc(sizeof(struct ip_vs_dest), GFP_KERNEL);\n\tif (dest == NULL)\n\t\treturn -ENOMEM;\n\n\tret = ip_vs_stats_init_alloc(&dest->stats);\n\tif (ret < 0)\n\t\tgoto err_alloc;\n\n\tret = ip_vs_start_estimator(svc->ipvs, &dest->stats);\n\tif (ret < 0)\n\t\tgoto err_stats;\n\n\tdest->af = udest->af;\n\tdest->protocol = svc->protocol;\n\tdest->vaddr = svc->addr;\n\tdest->vport = svc->port;\n\tdest->vfwmark = svc->fwmark;\n\tip_vs_addr_copy(udest->af, &dest->addr, &udest->addr);\n\tdest->port = udest->port;\n\n\tatomic_set(&dest->activeconns, 0);\n\tatomic_set(&dest->inactconns, 0);\n\tatomic_set(&dest->persistconns, 0);\n\trefcount_set(&dest->refcnt, 1);\n\n\tINIT_HLIST_NODE(&dest->d_list);\n\tspin_lock_init(&dest->dst_lock);\n\t__ip_vs_update_dest(svc, dest, udest, 1);\n\n\treturn 0;\n\nerr_stats:\n\tip_vs_stats_release(&dest->stats);\n\nerr_alloc:\n\tkfree(dest);\n\treturn ret;\n}\n\n\n \nstatic int\nip_vs_add_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\n{\n\tstruct ip_vs_dest *dest;\n\tunion nf_inet_addr daddr;\n\t__be16 dport = udest->port;\n\tint ret;\n\n\tif (udest->weight < 0) {\n\t\tpr_err(\"%s(): server weight less than zero\\n\", __func__);\n\t\treturn -ERANGE;\n\t}\n\n\tif (udest->l_threshold > udest->u_threshold) {\n\t\tpr_err(\"%s(): lower threshold is higher than upper threshold\\n\",\n\t\t\t__func__);\n\t\treturn -ERANGE;\n\t}\n\n\tif (udest->tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\tif (udest->tun_port == 0) {\n\t\t\tpr_err(\"%s(): tunnel port is zero\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tip_vs_addr_copy(udest->af, &daddr, &udest->addr);\n\n\t \n\trcu_read_lock();\n\tdest = ip_vs_lookup_dest(svc, udest->af, &daddr, dport);\n\trcu_read_unlock();\n\n\tif (dest != NULL) {\n\t\tIP_VS_DBG(1, \"%s(): dest already exists\\n\", __func__);\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tdest = ip_vs_trash_get_dest(svc, udest->af, &daddr, dport);\n\n\tif (dest != NULL) {\n\t\tIP_VS_DBG_BUF(3, \"Get destination %s:%u from trash, \"\n\t\t\t      \"dest->refcnt=%d, service %u/%s:%u\\n\",\n\t\t\t      IP_VS_DBG_ADDR(udest->af, &daddr), ntohs(dport),\n\t\t\t      refcount_read(&dest->refcnt),\n\t\t\t      dest->vfwmark,\n\t\t\t      IP_VS_DBG_ADDR(svc->af, &dest->vaddr),\n\t\t\t      ntohs(dest->vport));\n\n\t\tret = ip_vs_start_estimator(svc->ipvs, &dest->stats);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t__ip_vs_update_dest(svc, dest, udest, 1);\n\t} else {\n\t\t \n\t\tret = ip_vs_new_dest(svc, udest);\n\t}\n\n\treturn ret;\n}\n\n\n \nstatic int\nip_vs_edit_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\n{\n\tstruct ip_vs_dest *dest;\n\tunion nf_inet_addr daddr;\n\t__be16 dport = udest->port;\n\n\tif (udest->weight < 0) {\n\t\tpr_err(\"%s(): server weight less than zero\\n\", __func__);\n\t\treturn -ERANGE;\n\t}\n\n\tif (udest->l_threshold > udest->u_threshold) {\n\t\tpr_err(\"%s(): lower threshold is higher than upper threshold\\n\",\n\t\t\t__func__);\n\t\treturn -ERANGE;\n\t}\n\n\tif (udest->tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\tif (udest->tun_port == 0) {\n\t\t\tpr_err(\"%s(): tunnel port is zero\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tip_vs_addr_copy(udest->af, &daddr, &udest->addr);\n\n\t \n\trcu_read_lock();\n\tdest = ip_vs_lookup_dest(svc, udest->af, &daddr, dport);\n\trcu_read_unlock();\n\n\tif (dest == NULL) {\n\t\tIP_VS_DBG(1, \"%s(): dest doesn't exist\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\t__ip_vs_update_dest(svc, dest, udest, 0);\n\n\treturn 0;\n}\n\n \nstatic void __ip_vs_del_dest(struct netns_ipvs *ipvs, struct ip_vs_dest *dest,\n\t\t\t     bool cleanup)\n{\n\tip_vs_stop_estimator(ipvs, &dest->stats);\n\n\t \n\tip_vs_rs_unhash(dest);\n\n\tspin_lock_bh(&ipvs->dest_trash_lock);\n\tIP_VS_DBG_BUF(3, \"Moving dest %s:%u into trash, dest->refcnt=%d\\n\",\n\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr), ntohs(dest->port),\n\t\t      refcount_read(&dest->refcnt));\n\tif (list_empty(&ipvs->dest_trash) && !cleanup)\n\t\tmod_timer(&ipvs->dest_trash_timer,\n\t\t\t  jiffies + (IP_VS_DEST_TRASH_PERIOD >> 1));\n\t \n\tlist_add(&dest->t_list, &ipvs->dest_trash);\n\tdest->idle_start = 0;\n\tspin_unlock_bh(&ipvs->dest_trash_lock);\n\n\t \n\tif (!cleanup)\n\t\tip_vs_enqueue_expire_nodest_conns(ipvs);\n}\n\n\n \nstatic void __ip_vs_unlink_dest(struct ip_vs_service *svc,\n\t\t\t\tstruct ip_vs_dest *dest,\n\t\t\t\tint svcupd)\n{\n\tdest->flags &= ~IP_VS_DEST_F_AVAILABLE;\n\n\t \n\tlist_del_rcu(&dest->n_list);\n\tsvc->num_dests--;\n\n\tif (dest->af != svc->af)\n\t\tsvc->ipvs->mixed_address_family_dests--;\n\n\tif (svcupd) {\n\t\tstruct ip_vs_scheduler *sched;\n\n\t\tsched = rcu_dereference_protected(svc->scheduler, 1);\n\t\tif (sched && sched->del_dest)\n\t\t\tsched->del_dest(svc, dest);\n\t}\n}\n\n\n \nstatic int\nip_vs_del_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\n{\n\tstruct ip_vs_dest *dest;\n\t__be16 dport = udest->port;\n\n\t \n\trcu_read_lock();\n\tdest = ip_vs_lookup_dest(svc, udest->af, &udest->addr, dport);\n\trcu_read_unlock();\n\n\tif (dest == NULL) {\n\t\tIP_VS_DBG(1, \"%s(): destination not found!\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\t__ip_vs_unlink_dest(svc, dest, 1);\n\n\t \n\t__ip_vs_del_dest(svc->ipvs, dest, false);\n\n\treturn 0;\n}\n\nstatic void ip_vs_dest_trash_expire(struct timer_list *t)\n{\n\tstruct netns_ipvs *ipvs = from_timer(ipvs, t, dest_trash_timer);\n\tstruct ip_vs_dest *dest, *next;\n\tunsigned long now = jiffies;\n\n\tspin_lock(&ipvs->dest_trash_lock);\n\tlist_for_each_entry_safe(dest, next, &ipvs->dest_trash, t_list) {\n\t\tif (refcount_read(&dest->refcnt) > 1)\n\t\t\tcontinue;\n\t\tif (dest->idle_start) {\n\t\t\tif (time_before(now, dest->idle_start +\n\t\t\t\t\t     IP_VS_DEST_TRASH_PERIOD))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tdest->idle_start = max(1UL, now);\n\t\t\tcontinue;\n\t\t}\n\t\tIP_VS_DBG_BUF(3, \"Removing destination %u/%s:%u from trash\\n\",\n\t\t\t      dest->vfwmark,\n\t\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t\t      ntohs(dest->port));\n\t\tlist_del(&dest->t_list);\n\t\tip_vs_dest_free(dest);\n\t}\n\tif (!list_empty(&ipvs->dest_trash))\n\t\tmod_timer(&ipvs->dest_trash_timer,\n\t\t\t  jiffies + (IP_VS_DEST_TRASH_PERIOD >> 1));\n\tspin_unlock(&ipvs->dest_trash_lock);\n}\n\n \nstatic int\nip_vs_add_service(struct netns_ipvs *ipvs, struct ip_vs_service_user_kern *u,\n\t\t  struct ip_vs_service **svc_p)\n{\n\tint ret = 0;\n\tstruct ip_vs_scheduler *sched = NULL;\n\tstruct ip_vs_pe *pe = NULL;\n\tstruct ip_vs_service *svc = NULL;\n\tint ret_hooks = -1;\n\n\t \n\tif (!ip_vs_use_count_inc())\n\t\treturn -ENOPROTOOPT;\n\n\t \n\tif (strcmp(u->sched_name, \"none\")) {\n\t\tsched = ip_vs_scheduler_get(u->sched_name);\n\t\tif (!sched) {\n\t\t\tpr_info(\"Scheduler module ip_vs_%s not found\\n\",\n\t\t\t\tu->sched_name);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (u->pe_name && *u->pe_name) {\n\t\tpe = ip_vs_pe_getbyname(u->pe_name);\n\t\tif (pe == NULL) {\n\t\t\tpr_info(\"persistence engine module ip_vs_pe_%s \"\n\t\t\t\t\"not found\\n\", u->pe_name);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (u->af == AF_INET6) {\n\t\t__u32 plen = (__force __u32) u->netmask;\n\n\t\tif (plen < 1 || plen > 128) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tret = nf_defrag_ipv6_enable(ipvs->net);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n#endif\n\n\tif ((u->af == AF_INET && !ipvs->num_services) ||\n\t    (u->af == AF_INET6 && !ipvs->num_services6)) {\n\t\tret = ip_vs_register_hooks(ipvs, u->af);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t\tret_hooks = ret;\n\t}\n\n\tsvc = kzalloc(sizeof(struct ip_vs_service), GFP_KERNEL);\n\tif (svc == NULL) {\n\t\tIP_VS_DBG(1, \"%s(): no memory\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tret = ip_vs_stats_init_alloc(&svc->stats);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\t \n\tatomic_set(&svc->refcnt, 0);\n\n\tsvc->af = u->af;\n\tsvc->protocol = u->protocol;\n\tip_vs_addr_copy(svc->af, &svc->addr, &u->addr);\n\tsvc->port = u->port;\n\tsvc->fwmark = u->fwmark;\n\tsvc->flags = u->flags & ~IP_VS_SVC_F_HASHED;\n\tsvc->timeout = u->timeout * HZ;\n\tsvc->netmask = u->netmask;\n\tsvc->ipvs = ipvs;\n\n\tINIT_LIST_HEAD(&svc->destinations);\n\tspin_lock_init(&svc->sched_lock);\n\n\t \n\tif (sched) {\n\t\tret = ip_vs_bind_scheduler(svc, sched);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t\tsched = NULL;\n\t}\n\n\tret = ip_vs_start_estimator(ipvs, &svc->stats);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\t \n\tRCU_INIT_POINTER(svc->pe, pe);\n\tpe = NULL;\n\n\t \n\tif (svc->port == FTPPORT)\n\t\tatomic_inc(&ipvs->ftpsvc_counter);\n\telse if (svc->port == 0)\n\t\tatomic_inc(&ipvs->nullsvc_counter);\n\tif (svc->pe && svc->pe->conn_out)\n\t\tatomic_inc(&ipvs->conn_out_counter);\n\n\t \n\tif (svc->af == AF_INET)\n\t\tipvs->num_services++;\n\telse if (svc->af == AF_INET6)\n\t\tipvs->num_services6++;\n\n\t \n\tip_vs_svc_hash(svc);\n\n\t*svc_p = svc;\n\n\tif (!ipvs->enable) {\n\t\t \n\t\tipvs->enable = 1;\n\n\t\t \n\t\tip_vs_est_reload_start(ipvs);\n\t}\n\n\treturn 0;\n\n\n out_err:\n\tif (ret_hooks >= 0)\n\t\tip_vs_unregister_hooks(ipvs, u->af);\n\tif (svc != NULL) {\n\t\tip_vs_unbind_scheduler(svc, sched);\n\t\tip_vs_service_free(svc);\n\t}\n\tip_vs_scheduler_put(sched);\n\tip_vs_pe_put(pe);\n\n\t \n\tip_vs_use_count_dec();\n\n\treturn ret;\n}\n\n\n \nstatic int\nip_vs_edit_service(struct ip_vs_service *svc, struct ip_vs_service_user_kern *u)\n{\n\tstruct ip_vs_scheduler *sched = NULL, *old_sched;\n\tstruct ip_vs_pe *pe = NULL, *old_pe = NULL;\n\tint ret = 0;\n\tbool new_pe_conn_out, old_pe_conn_out;\n\n\t \n\tif (strcmp(u->sched_name, \"none\")) {\n\t\tsched = ip_vs_scheduler_get(u->sched_name);\n\t\tif (!sched) {\n\t\t\tpr_info(\"Scheduler module ip_vs_%s not found\\n\",\n\t\t\t\tu->sched_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\told_sched = sched;\n\n\tif (u->pe_name && *u->pe_name) {\n\t\tpe = ip_vs_pe_getbyname(u->pe_name);\n\t\tif (pe == NULL) {\n\t\t\tpr_info(\"persistence engine module ip_vs_pe_%s \"\n\t\t\t\t\"not found\\n\", u->pe_name);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\told_pe = pe;\n\t}\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (u->af == AF_INET6) {\n\t\t__u32 plen = (__force __u32) u->netmask;\n\n\t\tif (plen < 1 || plen > 128) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n#endif\n\n\told_sched = rcu_dereference_protected(svc->scheduler, 1);\n\tif (sched != old_sched) {\n\t\tif (old_sched) {\n\t\t\tip_vs_unbind_scheduler(svc, old_sched);\n\t\t\tRCU_INIT_POINTER(svc->scheduler, NULL);\n\t\t\t \n\t\t\tsynchronize_rcu();\n\t\t}\n\t\t \n\t\tif (sched) {\n\t\t\tret = ip_vs_bind_scheduler(svc, sched);\n\t\t\tif (ret) {\n\t\t\t\tip_vs_scheduler_put(sched);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tsvc->flags = u->flags | IP_VS_SVC_F_HASHED;\n\tsvc->timeout = u->timeout * HZ;\n\tsvc->netmask = u->netmask;\n\n\told_pe = rcu_dereference_protected(svc->pe, 1);\n\tif (pe != old_pe) {\n\t\trcu_assign_pointer(svc->pe, pe);\n\t\t \n\t\tnew_pe_conn_out = (pe && pe->conn_out) ? true : false;\n\t\told_pe_conn_out = (old_pe && old_pe->conn_out) ? true : false;\n\t\tif (new_pe_conn_out && !old_pe_conn_out)\n\t\t\tatomic_inc(&svc->ipvs->conn_out_counter);\n\t\tif (old_pe_conn_out && !new_pe_conn_out)\n\t\t\tatomic_dec(&svc->ipvs->conn_out_counter);\n\t}\n\nout:\n\tip_vs_scheduler_put(old_sched);\n\tip_vs_pe_put(old_pe);\n\treturn ret;\n}\n\n \nstatic void __ip_vs_del_service(struct ip_vs_service *svc, bool cleanup)\n{\n\tstruct ip_vs_dest *dest, *nxt;\n\tstruct ip_vs_scheduler *old_sched;\n\tstruct ip_vs_pe *old_pe;\n\tstruct netns_ipvs *ipvs = svc->ipvs;\n\n\tif (svc->af == AF_INET) {\n\t\tipvs->num_services--;\n\t\tif (!ipvs->num_services)\n\t\t\tip_vs_unregister_hooks(ipvs, svc->af);\n\t} else if (svc->af == AF_INET6) {\n\t\tipvs->num_services6--;\n\t\tif (!ipvs->num_services6)\n\t\t\tip_vs_unregister_hooks(ipvs, svc->af);\n\t}\n\n\tip_vs_stop_estimator(svc->ipvs, &svc->stats);\n\n\t \n\told_sched = rcu_dereference_protected(svc->scheduler, 1);\n\tip_vs_unbind_scheduler(svc, old_sched);\n\tip_vs_scheduler_put(old_sched);\n\n\t \n\told_pe = rcu_dereference_protected(svc->pe, 1);\n\tif (old_pe && old_pe->conn_out)\n\t\tatomic_dec(&ipvs->conn_out_counter);\n\tip_vs_pe_put(old_pe);\n\n\t \n\tlist_for_each_entry_safe(dest, nxt, &svc->destinations, n_list) {\n\t\t__ip_vs_unlink_dest(svc, dest, 0);\n\t\t__ip_vs_del_dest(svc->ipvs, dest, cleanup);\n\t}\n\n\t \n\tif (svc->port == FTPPORT)\n\t\tatomic_dec(&ipvs->ftpsvc_counter);\n\telse if (svc->port == 0)\n\t\tatomic_dec(&ipvs->nullsvc_counter);\n\n\t \n\t__ip_vs_svc_put(svc);\n\n\t \n\tip_vs_use_count_dec();\n}\n\n \nstatic void ip_vs_unlink_service(struct ip_vs_service *svc, bool cleanup)\n{\n\tip_vs_unregister_conntrack(svc);\n\t \n\tatomic_inc(&svc->refcnt);\n\t \n\tip_vs_svc_unhash(svc);\n\n\t__ip_vs_del_service(svc, cleanup);\n}\n\n \nstatic int ip_vs_del_service(struct ip_vs_service *svc)\n{\n\tif (svc == NULL)\n\t\treturn -EEXIST;\n\tip_vs_unlink_service(svc, false);\n\n\treturn 0;\n}\n\n\n \nstatic int ip_vs_flush(struct netns_ipvs *ipvs, bool cleanup)\n{\n\tint idx;\n\tstruct ip_vs_service *svc;\n\tstruct hlist_node *n;\n\n\t \n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\thlist_for_each_entry_safe(svc, n, &ip_vs_svc_table[idx],\n\t\t\t\t\t  s_list) {\n\t\t\tif (svc->ipvs == ipvs)\n\t\t\t\tip_vs_unlink_service(svc, cleanup);\n\t\t}\n\t}\n\n\t \n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\thlist_for_each_entry_safe(svc, n, &ip_vs_svc_fwm_table[idx],\n\t\t\t\t\t  f_list) {\n\t\t\tif (svc->ipvs == ipvs)\n\t\t\t\tip_vs_unlink_service(svc, cleanup);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nvoid ip_vs_service_nets_cleanup(struct list_head *net_list)\n{\n\tstruct netns_ipvs *ipvs;\n\tstruct net *net;\n\n\t \n\tmutex_lock(&__ip_vs_mutex);\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tipvs = net_ipvs(net);\n\t\tip_vs_flush(ipvs, true);\n\t}\n\tmutex_unlock(&__ip_vs_mutex);\n}\n\n \nstatic inline void\nip_vs_forget_dev(struct ip_vs_dest *dest, struct net_device *dev)\n{\n\tstruct ip_vs_dest_dst *dest_dst;\n\n\tspin_lock_bh(&dest->dst_lock);\n\tdest_dst = rcu_dereference_protected(dest->dest_dst, 1);\n\tif (dest_dst && dest_dst->dst_cache->dev == dev) {\n\t\tIP_VS_DBG_BUF(3, \"Reset dev:%s dest %s:%u ,dest->refcnt=%d\\n\",\n\t\t\t      dev->name,\n\t\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t\t      ntohs(dest->port),\n\t\t\t      refcount_read(&dest->refcnt));\n\t\t__ip_vs_dst_cache_reset(dest);\n\t}\n\tspin_unlock_bh(&dest->dst_lock);\n\n}\n \nstatic int ip_vs_dst_event(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest *dest;\n\tunsigned int idx;\n\n\tif (event != NETDEV_DOWN || !ipvs)\n\t\treturn NOTIFY_DONE;\n\tIP_VS_DBG(3, \"%s() dev=%s\\n\", __func__, dev->name);\n\tmutex_lock(&__ip_vs_mutex);\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\thlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\n\t\t\tif (svc->ipvs == ipvs) {\n\t\t\t\tlist_for_each_entry(dest, &svc->destinations,\n\t\t\t\t\t\t    n_list) {\n\t\t\t\t\tip_vs_forget_dev(dest, dev);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\tif (svc->ipvs == ipvs) {\n\t\t\t\tlist_for_each_entry(dest, &svc->destinations,\n\t\t\t\t\t\t    n_list) {\n\t\t\t\t\tip_vs_forget_dev(dest, dev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tspin_lock_bh(&ipvs->dest_trash_lock);\n\tlist_for_each_entry(dest, &ipvs->dest_trash, t_list) {\n\t\tip_vs_forget_dev(dest, dev);\n\t}\n\tspin_unlock_bh(&ipvs->dest_trash_lock);\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn NOTIFY_DONE;\n}\n\n \nstatic int ip_vs_zero_service(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dest *dest;\n\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tip_vs_zero_stats(&dest->stats);\n\t}\n\tip_vs_zero_stats(&svc->stats);\n\treturn 0;\n}\n\nstatic int ip_vs_zero_all(struct netns_ipvs *ipvs)\n{\n\tint idx;\n\tstruct ip_vs_service *svc;\n\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\thlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\n\t\t\tif (svc->ipvs == ipvs)\n\t\t\t\tip_vs_zero_service(svc);\n\t\t}\n\t}\n\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\thlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\tif (svc->ipvs == ipvs)\n\t\t\t\tip_vs_zero_service(svc);\n\t\t}\n\t}\n\n\tip_vs_zero_stats(&ipvs->tot_stats->s);\n\treturn 0;\n}\n\n#ifdef CONFIG_SYSCTL\n\nstatic int\nproc_do_defense_mode(struct ctl_table *table, int write,\n\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct netns_ipvs *ipvs = table->extra2;\n\tint *valp = table->data;\n\tint val = *valp;\n\tint rc;\n\n\tstruct ctl_table tmp = {\n\t\t.data = &val,\n\t\t.maxlen = sizeof(int),\n\t\t.mode = table->mode,\n\t};\n\n\trc = proc_dointvec(&tmp, write, buffer, lenp, ppos);\n\tif (write && (*valp != val)) {\n\t\tif (val < 0 || val > 3) {\n\t\t\trc = -EINVAL;\n\t\t} else {\n\t\t\t*valp = val;\n\t\t\tupdate_defense_level(ipvs);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int\nproc_do_sync_threshold(struct ctl_table *table, int write,\n\t\t       void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct netns_ipvs *ipvs = table->extra2;\n\tint *valp = table->data;\n\tint val[2];\n\tint rc;\n\tstruct ctl_table tmp = {\n\t\t.data = &val,\n\t\t.maxlen = table->maxlen,\n\t\t.mode = table->mode,\n\t};\n\n\tmutex_lock(&ipvs->sync_mutex);\n\tmemcpy(val, valp, sizeof(val));\n\trc = proc_dointvec(&tmp, write, buffer, lenp, ppos);\n\tif (write) {\n\t\tif (val[0] < 0 || val[1] < 0 ||\n\t\t    (val[0] >= val[1] && val[1]))\n\t\t\trc = -EINVAL;\n\t\telse\n\t\t\tmemcpy(valp, val, sizeof(val));\n\t}\n\tmutex_unlock(&ipvs->sync_mutex);\n\treturn rc;\n}\n\nstatic int\nproc_do_sync_ports(struct ctl_table *table, int write,\n\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = table->data;\n\tint val = *valp;\n\tint rc;\n\n\tstruct ctl_table tmp = {\n\t\t.data = &val,\n\t\t.maxlen = sizeof(int),\n\t\t.mode = table->mode,\n\t};\n\n\trc = proc_dointvec(&tmp, write, buffer, lenp, ppos);\n\tif (write && (*valp != val)) {\n\t\tif (val < 1 || !is_power_of_2(val))\n\t\t\trc = -EINVAL;\n\t\telse\n\t\t\t*valp = val;\n\t}\n\treturn rc;\n}\n\nstatic int ipvs_proc_est_cpumask_set(struct ctl_table *table, void *buffer)\n{\n\tstruct netns_ipvs *ipvs = table->extra2;\n\tcpumask_var_t *valp = table->data;\n\tcpumask_var_t newmask;\n\tint ret;\n\n\tif (!zalloc_cpumask_var(&newmask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = cpulist_parse(buffer, newmask);\n\tif (ret)\n\t\tgoto out;\n\n\tmutex_lock(&ipvs->est_mutex);\n\n\tif (!ipvs->est_cpulist_valid) {\n\t\tif (!zalloc_cpumask_var(valp, GFP_KERNEL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\t\tipvs->est_cpulist_valid = 1;\n\t}\n\tcpumask_and(newmask, newmask, &current->cpus_mask);\n\tcpumask_copy(*valp, newmask);\n\t \n\tipvs->est_max_threads = ip_vs_est_max_threads(ipvs);\n\tipvs->est_calc_phase = 1;\n\tip_vs_est_reload_start(ipvs);\n\nunlock:\n\tmutex_unlock(&ipvs->est_mutex);\n\nout:\n\tfree_cpumask_var(newmask);\n\treturn ret;\n}\n\nstatic int ipvs_proc_est_cpumask_get(struct ctl_table *table, void *buffer,\n\t\t\t\t     size_t size)\n{\n\tstruct netns_ipvs *ipvs = table->extra2;\n\tcpumask_var_t *valp = table->data;\n\tstruct cpumask *mask;\n\tint ret;\n\n\tmutex_lock(&ipvs->est_mutex);\n\n\tif (ipvs->est_cpulist_valid)\n\t\tmask = *valp;\n\telse\n\t\tmask = (struct cpumask *)housekeeping_cpumask(HK_TYPE_KTHREAD);\n\tret = scnprintf(buffer, size, \"%*pbl\\n\", cpumask_pr_args(mask));\n\n\tmutex_unlock(&ipvs->est_mutex);\n\n\treturn ret;\n}\n\nstatic int ipvs_proc_est_cpulist(struct ctl_table *table, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\t \n\tif (*ppos || !*lenp) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\tif (write) {\n\t\t \n\t\tret = ipvs_proc_est_cpumask_set(table, buffer);\n\t\tif (ret >= 0)\n\t\t\t*ppos += *lenp;\n\t} else {\n\t\t \n\t\tret = ipvs_proc_est_cpumask_get(table, buffer, *lenp + 1);\n\t\tif (ret >= 0) {\n\t\t\t*lenp = ret;\n\t\t\t*ppos += *lenp;\n\t\t\tret = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int ipvs_proc_est_nice(struct ctl_table *table, int write,\n\t\t\t      void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct netns_ipvs *ipvs = table->extra2;\n\tint *valp = table->data;\n\tint val = *valp;\n\tint ret;\n\n\tstruct ctl_table tmp_table = {\n\t\t.data = &val,\n\t\t.maxlen = sizeof(int),\n\t\t.mode = table->mode,\n\t};\n\n\tret = proc_dointvec(&tmp_table, write, buffer, lenp, ppos);\n\tif (write && ret >= 0) {\n\t\tif (val < MIN_NICE || val > MAX_NICE) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tmutex_lock(&ipvs->est_mutex);\n\t\t\tif (*valp != val) {\n\t\t\t\t*valp = val;\n\t\t\t\tip_vs_est_reload_start(ipvs);\n\t\t\t}\n\t\t\tmutex_unlock(&ipvs->est_mutex);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int ipvs_proc_run_estimation(struct ctl_table *table, int write,\n\t\t\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct netns_ipvs *ipvs = table->extra2;\n\tint *valp = table->data;\n\tint val = *valp;\n\tint ret;\n\n\tstruct ctl_table tmp_table = {\n\t\t.data = &val,\n\t\t.maxlen = sizeof(int),\n\t\t.mode = table->mode,\n\t};\n\n\tret = proc_dointvec(&tmp_table, write, buffer, lenp, ppos);\n\tif (write && ret >= 0) {\n\t\tmutex_lock(&ipvs->est_mutex);\n\t\tif (*valp != val) {\n\t\t\t*valp = val;\n\t\t\tip_vs_est_reload_start(ipvs);\n\t\t}\n\t\tmutex_unlock(&ipvs->est_mutex);\n\t}\n\treturn ret;\n}\n\n \n\nstatic struct ctl_table vs_vars[] = {\n\t{\n\t\t.procname\t= \"amemthresh\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"am_droprate\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"drop_entry\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_defense_mode,\n\t},\n\t{\n\t\t.procname\t= \"drop_packet\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_defense_mode,\n\t},\n#ifdef CONFIG_IP_VS_NFCT\n\t{\n\t\t.procname\t= \"conntrack\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= &proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"secure_tcp\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_defense_mode,\n\t},\n\t{\n\t\t.procname\t= \"snat_reroute\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= &proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sync_version\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"sync_ports\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_sync_ports,\n\t},\n\t{\n\t\t.procname\t= \"sync_persist_mode\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sync_qlen_max\",\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"sync_sock_size\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"cache_bypass\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"expire_nodest_conn\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sloppy_tcp\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sloppy_sctp\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"expire_quiescent_template\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sync_threshold\",\n\t\t.maxlen\t\t=\n\t\t\tsizeof(((struct netns_ipvs *)0)->sysctl_sync_threshold),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_sync_threshold,\n\t},\n\t{\n\t\t.procname\t= \"sync_refresh_period\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"sync_retries\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_THREE,\n\t},\n\t{\n\t\t.procname\t= \"nat_icmp_send\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"pmtu_disc\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"backup_only\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"conn_reuse_mode\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"schedule_icmp\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"ignore_tunneled\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"run_estimation\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= ipvs_proc_run_estimation,\n\t},\n\t{\n\t\t.procname\t= \"est_cpulist\",\n\t\t.maxlen\t\t= NR_CPUS,\t \n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= ipvs_proc_est_cpulist,\n\t},\n\t{\n\t\t.procname\t= \"est_nice\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= ipvs_proc_est_nice,\n\t},\n#ifdef CONFIG_IP_VS_DEBUG\n\t{\n\t\t.procname\t= \"debug_level\",\n\t\t.data\t\t= &sysctl_ip_vs_debug_level,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{ }\n};\n\n#endif\n\n#ifdef CONFIG_PROC_FS\n\nstruct ip_vs_iter {\n\tstruct seq_net_private p;   \n\tstruct hlist_head *table;\n\tint bucket;\n};\n\n \nstatic inline const char *ip_vs_fwd_name(unsigned int flags)\n{\n\tswitch (flags & IP_VS_CONN_F_FWD_MASK) {\n\tcase IP_VS_CONN_F_LOCALNODE:\n\t\treturn \"Local\";\n\tcase IP_VS_CONN_F_TUNNEL:\n\t\treturn \"Tunnel\";\n\tcase IP_VS_CONN_F_DROUTE:\n\t\treturn \"Route\";\n\tdefault:\n\t\treturn \"Masq\";\n\t}\n}\n\n\n \nstatic struct ip_vs_service *ip_vs_info_array(struct seq_file *seq, loff_t pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\tstruct ip_vs_iter *iter = seq->private;\n\tint idx;\n\tstruct ip_vs_service *svc;\n\n\t \n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\thlist_for_each_entry_rcu(svc, &ip_vs_svc_table[idx], s_list) {\n\t\t\tif ((svc->ipvs == ipvs) && pos-- == 0) {\n\t\t\t\titer->table = ip_vs_svc_table;\n\t\t\t\titer->bucket = idx;\n\t\t\t\treturn svc;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\thlist_for_each_entry_rcu(svc, &ip_vs_svc_fwm_table[idx],\n\t\t\t\t\t f_list) {\n\t\t\tif ((svc->ipvs == ipvs) && pos-- == 0) {\n\t\t\t\titer->table = ip_vs_svc_fwm_table;\n\t\t\t\titer->bucket = idx;\n\t\t\t\treturn svc;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void *ip_vs_info_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\trcu_read_lock();\n\treturn *pos ? ip_vs_info_array(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\n\nstatic void *ip_vs_info_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct hlist_node *e;\n\tstruct ip_vs_iter *iter;\n\tstruct ip_vs_service *svc;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn ip_vs_info_array(seq,0);\n\n\tsvc = v;\n\titer = seq->private;\n\n\tif (iter->table == ip_vs_svc_table) {\n\t\t \n\t\te = rcu_dereference(hlist_next_rcu(&svc->s_list));\n\t\tif (e)\n\t\t\treturn hlist_entry(e, struct ip_vs_service, s_list);\n\n\t\twhile (++iter->bucket < IP_VS_SVC_TAB_SIZE) {\n\t\t\thlist_for_each_entry_rcu(svc,\n\t\t\t\t\t\t &ip_vs_svc_table[iter->bucket],\n\t\t\t\t\t\t s_list) {\n\t\t\t\treturn svc;\n\t\t\t}\n\t\t}\n\n\t\titer->table = ip_vs_svc_fwm_table;\n\t\titer->bucket = -1;\n\t\tgoto scan_fwmark;\n\t}\n\n\t \n\te = rcu_dereference(hlist_next_rcu(&svc->f_list));\n\tif (e)\n\t\treturn hlist_entry(e, struct ip_vs_service, f_list);\n\n scan_fwmark:\n\twhile (++iter->bucket < IP_VS_SVC_TAB_SIZE) {\n\t\thlist_for_each_entry_rcu(svc,\n\t\t\t\t\t &ip_vs_svc_fwm_table[iter->bucket],\n\t\t\t\t\t f_list)\n\t\t\treturn svc;\n\t}\n\n\treturn NULL;\n}\n\nstatic void ip_vs_info_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\n\nstatic int ip_vs_info_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq,\n\t\t\t\"IP Virtual Server version %d.%d.%d (size=%d)\\n\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);\n\t\tseq_puts(seq,\n\t\t\t \"Prot LocalAddress:Port Scheduler Flags\\n\");\n\t\tseq_puts(seq,\n\t\t\t \"  -> RemoteAddress:Port Forward Weight ActiveConn InActConn\\n\");\n\t} else {\n\t\tstruct net *net = seq_file_net(seq);\n\t\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\t\tconst struct ip_vs_service *svc = v;\n\t\tconst struct ip_vs_iter *iter = seq->private;\n\t\tconst struct ip_vs_dest *dest;\n\t\tstruct ip_vs_scheduler *sched = rcu_dereference(svc->scheduler);\n\t\tchar *sched_name = sched ? sched->name : \"none\";\n\n\t\tif (svc->ipvs != ipvs)\n\t\t\treturn 0;\n\t\tif (iter->table == ip_vs_svc_table) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\t\tif (svc->af == AF_INET6)\n\t\t\t\tseq_printf(seq, \"%s  [%pI6]:%04X %s \",\n\t\t\t\t\t   ip_vs_proto_name(svc->protocol),\n\t\t\t\t\t   &svc->addr.in6,\n\t\t\t\t\t   ntohs(svc->port),\n\t\t\t\t\t   sched_name);\n\t\t\telse\n#endif\n\t\t\t\tseq_printf(seq, \"%s  %08X:%04X %s %s \",\n\t\t\t\t\t   ip_vs_proto_name(svc->protocol),\n\t\t\t\t\t   ntohl(svc->addr.ip),\n\t\t\t\t\t   ntohs(svc->port),\n\t\t\t\t\t   sched_name,\n\t\t\t\t\t   (svc->flags & IP_VS_SVC_F_ONEPACKET)?\"ops \":\"\");\n\t\t} else {\n\t\t\tseq_printf(seq, \"FWM  %08X %s %s\",\n\t\t\t\t   svc->fwmark, sched_name,\n\t\t\t\t   (svc->flags & IP_VS_SVC_F_ONEPACKET)?\"ops \":\"\");\n\t\t}\n\n\t\tif (svc->flags & IP_VS_SVC_F_PERSISTENT)\n\t\t\tseq_printf(seq, \"persistent %d %08X\\n\",\n\t\t\t\tsvc->timeout,\n\t\t\t\tntohl(svc->netmask));\n\t\telse\n\t\t\tseq_putc(seq, '\\n');\n\n\t\tlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\t\tif (dest->af == AF_INET6)\n\t\t\t\tseq_printf(seq,\n\t\t\t\t\t   \"  -> [%pI6]:%04X\"\n\t\t\t\t\t   \"      %-7s %-6d %-10d %-10d\\n\",\n\t\t\t\t\t   &dest->addr.in6,\n\t\t\t\t\t   ntohs(dest->port),\n\t\t\t\t\t   ip_vs_fwd_name(atomic_read(&dest->conn_flags)),\n\t\t\t\t\t   atomic_read(&dest->weight),\n\t\t\t\t\t   atomic_read(&dest->activeconns),\n\t\t\t\t\t   atomic_read(&dest->inactconns));\n\t\t\telse\n#endif\n\t\t\t\tseq_printf(seq,\n\t\t\t\t\t   \"  -> %08X:%04X      \"\n\t\t\t\t\t   \"%-7s %-6d %-10d %-10d\\n\",\n\t\t\t\t\t   ntohl(dest->addr.ip),\n\t\t\t\t\t   ntohs(dest->port),\n\t\t\t\t\t   ip_vs_fwd_name(atomic_read(&dest->conn_flags)),\n\t\t\t\t\t   atomic_read(&dest->weight),\n\t\t\t\t\t   atomic_read(&dest->activeconns),\n\t\t\t\t\t   atomic_read(&dest->inactconns));\n\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ip_vs_info_seq_ops = {\n\t.start = ip_vs_info_seq_start,\n\t.next  = ip_vs_info_seq_next,\n\t.stop  = ip_vs_info_seq_stop,\n\t.show  = ip_vs_info_seq_show,\n};\n\nstatic int ip_vs_stats_show(struct seq_file *seq, void *v)\n{\n\tstruct net *net = seq_file_single_net(seq);\n\tstruct ip_vs_kstats show;\n\n \n\tseq_puts(seq,\n\t\t \"   Total Incoming Outgoing         Incoming         Outgoing\\n\");\n\tseq_puts(seq,\n\t\t \"   Conns  Packets  Packets            Bytes            Bytes\\n\");\n\n\tip_vs_copy_stats(&show, &net_ipvs(net)->tot_stats->s);\n\tseq_printf(seq, \"%8LX %8LX %8LX %16LX %16LX\\n\\n\",\n\t\t   (unsigned long long)show.conns,\n\t\t   (unsigned long long)show.inpkts,\n\t\t   (unsigned long long)show.outpkts,\n\t\t   (unsigned long long)show.inbytes,\n\t\t   (unsigned long long)show.outbytes);\n\n \n\tseq_puts(seq,\n\t\t \" Conns/s   Pkts/s   Pkts/s          Bytes/s          Bytes/s\\n\");\n\tseq_printf(seq, \"%8LX %8LX %8LX %16LX %16LX\\n\",\n\t\t   (unsigned long long)show.cps,\n\t\t   (unsigned long long)show.inpps,\n\t\t   (unsigned long long)show.outpps,\n\t\t   (unsigned long long)show.inbps,\n\t\t   (unsigned long long)show.outbps);\n\n\treturn 0;\n}\n\nstatic int ip_vs_stats_percpu_show(struct seq_file *seq, void *v)\n{\n\tstruct net *net = seq_file_single_net(seq);\n\tstruct ip_vs_stats *tot_stats = &net_ipvs(net)->tot_stats->s;\n\tstruct ip_vs_cpu_stats __percpu *cpustats = tot_stats->cpustats;\n\tstruct ip_vs_kstats kstats;\n\tint i;\n\n \n\tseq_puts(seq,\n\t\t \"       Total Incoming Outgoing         Incoming         Outgoing\\n\");\n\tseq_puts(seq,\n\t\t \"CPU    Conns  Packets  Packets            Bytes            Bytes\\n\");\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct ip_vs_cpu_stats *u = per_cpu_ptr(cpustats, i);\n\t\tunsigned int start;\n\t\tu64 conns, inpkts, outpkts, inbytes, outbytes;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&u->syncp);\n\t\t\tconns = u64_stats_read(&u->cnt.conns);\n\t\t\tinpkts = u64_stats_read(&u->cnt.inpkts);\n\t\t\toutpkts = u64_stats_read(&u->cnt.outpkts);\n\t\t\tinbytes = u64_stats_read(&u->cnt.inbytes);\n\t\t\toutbytes = u64_stats_read(&u->cnt.outbytes);\n\t\t} while (u64_stats_fetch_retry(&u->syncp, start));\n\n\t\tseq_printf(seq, \"%3X %8LX %8LX %8LX %16LX %16LX\\n\",\n\t\t\t   i, (u64)conns, (u64)inpkts,\n\t\t\t   (u64)outpkts, (u64)inbytes,\n\t\t\t   (u64)outbytes);\n\t}\n\n\tip_vs_copy_stats(&kstats, tot_stats);\n\n\tseq_printf(seq, \"  ~ %8LX %8LX %8LX %16LX %16LX\\n\\n\",\n\t\t   (unsigned long long)kstats.conns,\n\t\t   (unsigned long long)kstats.inpkts,\n\t\t   (unsigned long long)kstats.outpkts,\n\t\t   (unsigned long long)kstats.inbytes,\n\t\t   (unsigned long long)kstats.outbytes);\n\n \n\tseq_puts(seq,\n\t\t \"     Conns/s   Pkts/s   Pkts/s          Bytes/s          Bytes/s\\n\");\n\tseq_printf(seq, \"    %8LX %8LX %8LX %16LX %16LX\\n\",\n\t\t   kstats.cps,\n\t\t   kstats.inpps,\n\t\t   kstats.outpps,\n\t\t   kstats.inbps,\n\t\t   kstats.outbps);\n\n\treturn 0;\n}\n#endif\n\n \nstatic int ip_vs_set_timeout(struct netns_ipvs *ipvs, struct ip_vs_timeout_user *u)\n{\n#if defined(CONFIG_IP_VS_PROTO_TCP) || defined(CONFIG_IP_VS_PROTO_UDP)\n\tstruct ip_vs_proto_data *pd;\n#endif\n\n\tIP_VS_DBG(2, \"Setting timeout tcp:%d tcpfin:%d udp:%d\\n\",\n\t\t  u->tcp_timeout,\n\t\t  u->tcp_fin_timeout,\n\t\t  u->udp_timeout);\n\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\tif (u->tcp_timeout < 0 || u->tcp_timeout > (INT_MAX / HZ) ||\n\t    u->tcp_fin_timeout < 0 || u->tcp_fin_timeout > (INT_MAX / HZ)) {\n\t\treturn -EINVAL;\n\t}\n#endif\n\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\tif (u->udp_timeout < 0 || u->udp_timeout > (INT_MAX / HZ))\n\t\treturn -EINVAL;\n#endif\n\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\tif (u->tcp_timeout) {\n\t\tpd = ip_vs_proto_data_get(ipvs, IPPROTO_TCP);\n\t\tpd->timeout_table[IP_VS_TCP_S_ESTABLISHED]\n\t\t\t= u->tcp_timeout * HZ;\n\t}\n\n\tif (u->tcp_fin_timeout) {\n\t\tpd = ip_vs_proto_data_get(ipvs, IPPROTO_TCP);\n\t\tpd->timeout_table[IP_VS_TCP_S_FIN_WAIT]\n\t\t\t= u->tcp_fin_timeout * HZ;\n\t}\n#endif\n\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\tif (u->udp_timeout) {\n\t\tpd = ip_vs_proto_data_get(ipvs, IPPROTO_UDP);\n\t\tpd->timeout_table[IP_VS_UDP_S_NORMAL]\n\t\t\t= u->udp_timeout * HZ;\n\t}\n#endif\n\treturn 0;\n}\n\n#define CMDID(cmd)\t\t(cmd - IP_VS_BASE_CTL)\n\nstruct ip_vs_svcdest_user {\n\tstruct ip_vs_service_user\ts;\n\tstruct ip_vs_dest_user\t\td;\n};\n\nstatic const unsigned char set_arglen[CMDID(IP_VS_SO_SET_MAX) + 1] = {\n\t[CMDID(IP_VS_SO_SET_ADD)]         = sizeof(struct ip_vs_service_user),\n\t[CMDID(IP_VS_SO_SET_EDIT)]        = sizeof(struct ip_vs_service_user),\n\t[CMDID(IP_VS_SO_SET_DEL)]         = sizeof(struct ip_vs_service_user),\n\t[CMDID(IP_VS_SO_SET_ADDDEST)]     = sizeof(struct ip_vs_svcdest_user),\n\t[CMDID(IP_VS_SO_SET_DELDEST)]     = sizeof(struct ip_vs_svcdest_user),\n\t[CMDID(IP_VS_SO_SET_EDITDEST)]    = sizeof(struct ip_vs_svcdest_user),\n\t[CMDID(IP_VS_SO_SET_TIMEOUT)]     = sizeof(struct ip_vs_timeout_user),\n\t[CMDID(IP_VS_SO_SET_STARTDAEMON)] = sizeof(struct ip_vs_daemon_user),\n\t[CMDID(IP_VS_SO_SET_STOPDAEMON)]  = sizeof(struct ip_vs_daemon_user),\n\t[CMDID(IP_VS_SO_SET_ZERO)]        = sizeof(struct ip_vs_service_user),\n};\n\nunion ip_vs_set_arglen {\n\tstruct ip_vs_service_user\tfield_IP_VS_SO_SET_ADD;\n\tstruct ip_vs_service_user\tfield_IP_VS_SO_SET_EDIT;\n\tstruct ip_vs_service_user\tfield_IP_VS_SO_SET_DEL;\n\tstruct ip_vs_svcdest_user\tfield_IP_VS_SO_SET_ADDDEST;\n\tstruct ip_vs_svcdest_user\tfield_IP_VS_SO_SET_DELDEST;\n\tstruct ip_vs_svcdest_user\tfield_IP_VS_SO_SET_EDITDEST;\n\tstruct ip_vs_timeout_user\tfield_IP_VS_SO_SET_TIMEOUT;\n\tstruct ip_vs_daemon_user\tfield_IP_VS_SO_SET_STARTDAEMON;\n\tstruct ip_vs_daemon_user\tfield_IP_VS_SO_SET_STOPDAEMON;\n\tstruct ip_vs_service_user\tfield_IP_VS_SO_SET_ZERO;\n};\n\n#define MAX_SET_ARGLEN\tsizeof(union ip_vs_set_arglen)\n\nstatic void ip_vs_copy_usvc_compat(struct ip_vs_service_user_kern *usvc,\n\t\t\t\t  struct ip_vs_service_user *usvc_compat)\n{\n\tmemset(usvc, 0, sizeof(*usvc));\n\n\tusvc->af\t\t= AF_INET;\n\tusvc->protocol\t\t= usvc_compat->protocol;\n\tusvc->addr.ip\t\t= usvc_compat->addr;\n\tusvc->port\t\t= usvc_compat->port;\n\tusvc->fwmark\t\t= usvc_compat->fwmark;\n\n\t \n\tusvc->sched_name\t= usvc_compat->sched_name;\n\n\tusvc->flags\t\t= usvc_compat->flags;\n\tusvc->timeout\t\t= usvc_compat->timeout;\n\tusvc->netmask\t\t= usvc_compat->netmask;\n}\n\nstatic void ip_vs_copy_udest_compat(struct ip_vs_dest_user_kern *udest,\n\t\t\t\t   struct ip_vs_dest_user *udest_compat)\n{\n\tmemset(udest, 0, sizeof(*udest));\n\n\tudest->addr.ip\t\t= udest_compat->addr;\n\tudest->port\t\t= udest_compat->port;\n\tudest->conn_flags\t= udest_compat->conn_flags;\n\tudest->weight\t\t= udest_compat->weight;\n\tudest->u_threshold\t= udest_compat->u_threshold;\n\tudest->l_threshold\t= udest_compat->l_threshold;\n\tudest->af\t\t= AF_INET;\n\tudest->tun_type\t\t= IP_VS_CONN_F_TUNNEL_TYPE_IPIP;\n}\n\nstatic int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, sockptr_t ptr, unsigned int len)\n{\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tunsigned char arg[MAX_SET_ARGLEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tBUILD_BUG_ON(sizeof(arg) > 255);\n\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n\t\treturn -EINVAL;\n\tif (len != set_arglen[CMDID(cmd)]) {\n\t\tIP_VS_DBG(1, \"set_ctl: len %u != %u\\n\",\n\t\t\t  len, set_arglen[CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_sockptr(arg, ptr, len) != 0)\n\t\treturn -EFAULT;\n\n\t \n\tif (cmd == IP_VS_SO_SET_STARTDAEMON ||\n\t    cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\n\t\tif (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\t\tstruct ipvs_sync_daemon_cfg cfg;\n\n\t\t\tmemset(&cfg, 0, sizeof(cfg));\n\t\t\tret = -EINVAL;\n\t\t\tif (strscpy(cfg.mcast_ifn, dm->mcast_ifn,\n\t\t\t\t    sizeof(cfg.mcast_ifn)) <= 0)\n\t\t\t\treturn ret;\n\t\t\tcfg.syncid = dm->syncid;\n\t\t\tret = start_sync_thread(ipvs, &cfg, dm->state);\n\t\t} else {\n\t\t\tret = stop_sync_thread(ipvs, dm->state);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&__ip_vs_mutex);\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t \n\t\tret = ip_vs_flush(ipvs, false);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t \n\t\tret = ip_vs_set_timeout(ipvs, (struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (!len) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t \n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t \n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all(ipvs);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif ((cmd == IP_VS_SO_SET_ADD || cmd == IP_VS_SO_SET_EDIT) &&\n\t    strnlen(usvc.sched_name, IP_VS_SCHEDNAME_MAXLEN) ==\n\t    IP_VS_SCHEDNAME_MAXLEN) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP &&\n\t    usvc.protocol != IPPROTO_SCTP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port));\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\trcu_read_lock();\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_find(ipvs, usvc.af, usvc.protocol,\n\t\t\t\t\t   &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_find(ipvs, usvc.af, usvc.fwmark);\n\trcu_read_unlock();\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(ipvs, &usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n\n\nstatic void\nip_vs_copy_service(struct ip_vs_service_entry *dst, struct ip_vs_service *src)\n{\n\tstruct ip_vs_scheduler *sched;\n\tstruct ip_vs_kstats kstats;\n\tchar *sched_name;\n\n\tsched = rcu_dereference_protected(src->scheduler, 1);\n\tsched_name = sched ? sched->name : \"none\";\n\tdst->protocol = src->protocol;\n\tdst->addr = src->addr.ip;\n\tdst->port = src->port;\n\tdst->fwmark = src->fwmark;\n\tstrscpy(dst->sched_name, sched_name, sizeof(dst->sched_name));\n\tdst->flags = src->flags;\n\tdst->timeout = src->timeout / HZ;\n\tdst->netmask = src->netmask;\n\tdst->num_dests = src->num_dests;\n\tip_vs_copy_stats(&kstats, &src->stats);\n\tip_vs_export_stats_user(&dst->stats, &kstats);\n}\n\nstatic inline int\n__ip_vs_get_service_entries(struct netns_ipvs *ipvs,\n\t\t\t    const struct ip_vs_get_services *get,\n\t\t\t    struct ip_vs_get_services __user *uptr)\n{\n\tint idx, count=0;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_service_entry entry;\n\tint ret = 0;\n\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\thlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\n\t\t\t \n\t\t\tif (svc->af != AF_INET || (svc->ipvs != ipvs))\n\t\t\t\tcontinue;\n\n\t\t\tif (count >= get->num_services)\n\t\t\t\tgoto out;\n\t\t\tmemset(&entry, 0, sizeof(entry));\n\t\t\tip_vs_copy_service(&entry, svc);\n\t\t\tif (copy_to_user(&uptr->entrytable[count],\n\t\t\t\t\t &entry, sizeof(entry))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\thlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\t \n\t\t\tif (svc->af != AF_INET || (svc->ipvs != ipvs))\n\t\t\t\tcontinue;\n\n\t\t\tif (count >= get->num_services)\n\t\t\t\tgoto out;\n\t\t\tmemset(&entry, 0, sizeof(entry));\n\t\t\tip_vs_copy_service(&entry, svc);\n\t\t\tif (copy_to_user(&uptr->entrytable[count],\n\t\t\t\t\t &entry, sizeof(entry))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\nstatic inline int\n__ip_vs_get_dest_entries(struct netns_ipvs *ipvs, const struct ip_vs_get_dests *get,\n\t\t\t struct ip_vs_get_dests __user *uptr)\n{\n\tstruct ip_vs_service *svc;\n\tunion nf_inet_addr addr = { .ip = get->addr };\n\tint ret = 0;\n\n\trcu_read_lock();\n\tif (get->fwmark)\n\t\tsvc = __ip_vs_svc_fwm_find(ipvs, AF_INET, get->fwmark);\n\telse\n\t\tsvc = __ip_vs_service_find(ipvs, AF_INET, get->protocol, &addr,\n\t\t\t\t\t   get->port);\n\trcu_read_unlock();\n\n\tif (svc) {\n\t\tint count = 0;\n\t\tstruct ip_vs_dest *dest;\n\t\tstruct ip_vs_dest_entry entry;\n\t\tstruct ip_vs_kstats kstats;\n\n\t\tmemset(&entry, 0, sizeof(entry));\n\t\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\t\tif (count >= get->num_dests)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (dest->af != svc->af)\n\t\t\t\tcontinue;\n\n\t\t\tentry.addr = dest->addr.ip;\n\t\t\tentry.port = dest->port;\n\t\t\tentry.conn_flags = atomic_read(&dest->conn_flags);\n\t\t\tentry.weight = atomic_read(&dest->weight);\n\t\t\tentry.u_threshold = dest->u_threshold;\n\t\t\tentry.l_threshold = dest->l_threshold;\n\t\t\tentry.activeconns = atomic_read(&dest->activeconns);\n\t\t\tentry.inactconns = atomic_read(&dest->inactconns);\n\t\t\tentry.persistconns = atomic_read(&dest->persistconns);\n\t\t\tip_vs_copy_stats(&kstats, &dest->stats);\n\t\t\tip_vs_export_stats_user(&entry.stats, &kstats);\n\t\t\tif (copy_to_user(&uptr->entrytable[count],\n\t\t\t\t\t &entry, sizeof(entry))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t} else\n\t\tret = -ESRCH;\n\treturn ret;\n}\n\nstatic inline void\n__ip_vs_get_timeouts(struct netns_ipvs *ipvs, struct ip_vs_timeout_user *u)\n{\n#if defined(CONFIG_IP_VS_PROTO_TCP) || defined(CONFIG_IP_VS_PROTO_UDP)\n\tstruct ip_vs_proto_data *pd;\n#endif\n\n\tmemset(u, 0, sizeof (*u));\n\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\tpd = ip_vs_proto_data_get(ipvs, IPPROTO_TCP);\n\tu->tcp_timeout = pd->timeout_table[IP_VS_TCP_S_ESTABLISHED] / HZ;\n\tu->tcp_fin_timeout = pd->timeout_table[IP_VS_TCP_S_FIN_WAIT] / HZ;\n#endif\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\tpd = ip_vs_proto_data_get(ipvs, IPPROTO_UDP);\n\tu->udp_timeout =\n\t\t\tpd->timeout_table[IP_VS_UDP_S_NORMAL] / HZ;\n#endif\n}\n\nstatic const unsigned char get_arglen[CMDID(IP_VS_SO_GET_MAX) + 1] = {\n\t[CMDID(IP_VS_SO_GET_VERSION)]  = 64,\n\t[CMDID(IP_VS_SO_GET_INFO)]     = sizeof(struct ip_vs_getinfo),\n\t[CMDID(IP_VS_SO_GET_SERVICES)] = sizeof(struct ip_vs_get_services),\n\t[CMDID(IP_VS_SO_GET_SERVICE)]  = sizeof(struct ip_vs_service_entry),\n\t[CMDID(IP_VS_SO_GET_DESTS)]    = sizeof(struct ip_vs_get_dests),\n\t[CMDID(IP_VS_SO_GET_TIMEOUT)]  = sizeof(struct ip_vs_timeout_user),\n\t[CMDID(IP_VS_SO_GET_DAEMON)]   = 2 * sizeof(struct ip_vs_daemon_user),\n};\n\nunion ip_vs_get_arglen {\n\tchar\t\t\t\tfield_IP_VS_SO_GET_VERSION[64];\n\tstruct ip_vs_getinfo\t\tfield_IP_VS_SO_GET_INFO;\n\tstruct ip_vs_get_services\tfield_IP_VS_SO_GET_SERVICES;\n\tstruct ip_vs_service_entry\tfield_IP_VS_SO_GET_SERVICE;\n\tstruct ip_vs_get_dests\t\tfield_IP_VS_SO_GET_DESTS;\n\tstruct ip_vs_timeout_user\tfield_IP_VS_SO_GET_TIMEOUT;\n\tstruct ip_vs_daemon_user\tfield_IP_VS_SO_GET_DAEMON[2];\n};\n\n#define MAX_GET_ARGLEN\tsizeof(union ip_vs_get_arglen)\n\nstatic int\ndo_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[MAX_GET_ARGLEN];\n\tint ret = 0;\n\tunsigned int copylen;\n\tstruct net *net = sock_net(sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tBUG_ON(!net);\n\tBUILD_BUG_ON(sizeof(arg) > 255);\n\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n\t\treturn -EINVAL;\n\n\tcopylen = get_arglen[CMDID(cmd)];\n\tif (*len < (int) copylen) {\n\t\tIP_VS_DBG(1, \"get_ctl: len %d < %u\\n\", *len, copylen);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, copylen) != 0)\n\t\treturn -EFAULT;\n\t \n\tif (cmd == IP_VS_SO_GET_DAEMON) {\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tmutex_lock(&ipvs->sync_mutex);\n\t\tif (ipvs->sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrscpy(d[0].mcast_ifn, ipvs->mcfg.mcast_ifn,\n\t\t\t\tsizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ipvs->mcfg.syncid;\n\t\t}\n\t\tif (ipvs->sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrscpy(d[1].mcast_ifn, ipvs->bcfg.mcast_ifn,\n\t\t\t\tsizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ipvs->bcfg.syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t\tmutex_unlock(&ipvs->sync_mutex);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&__ip_vs_mutex);\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = ip_vs_conn_tab_size;\n\t\tinfo.num_services = ipvs->num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = struct_size(get, entrytable, get->num_services);\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(ipvs, get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\trcu_read_lock();\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_find(ipvs, AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_find(ipvs, AF_INET,\n\t\t\t\t\t\t   entry->protocol, &addr,\n\t\t\t\t\t\t   entry->port);\n\t\trcu_read_unlock();\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = struct_size(get, entrytable, get->num_dests);\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(ipvs, get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(ipvs, &t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n\n\nstatic struct nf_sockopt_ops ip_vs_sockopts = {\n\t.pf\t\t= PF_INET,\n\t.set_optmin\t= IP_VS_BASE_CTL,\n\t.set_optmax\t= IP_VS_SO_SET_MAX+1,\n\t.set\t\t= do_ip_vs_set_ctl,\n\t.get_optmin\t= IP_VS_BASE_CTL,\n\t.get_optmax\t= IP_VS_SO_GET_MAX+1,\n\t.get\t\t= do_ip_vs_get_ctl,\n\t.owner\t\t= THIS_MODULE,\n};\n\n \n\n \nstatic struct genl_family ip_vs_genl_family;\n\n \nstatic const struct nla_policy ip_vs_cmd_policy[IPVS_CMD_ATTR_MAX + 1] = {\n\t[IPVS_CMD_ATTR_SERVICE]\t\t= { .type = NLA_NESTED },\n\t[IPVS_CMD_ATTR_DEST]\t\t= { .type = NLA_NESTED },\n\t[IPVS_CMD_ATTR_DAEMON]\t\t= { .type = NLA_NESTED },\n\t[IPVS_CMD_ATTR_TIMEOUT_TCP]\t= { .type = NLA_U32 },\n\t[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN]\t= { .type = NLA_U32 },\n\t[IPVS_CMD_ATTR_TIMEOUT_UDP]\t= { .type = NLA_U32 },\n};\n\n \nstatic const struct nla_policy ip_vs_daemon_policy[IPVS_DAEMON_ATTR_MAX + 1] = {\n\t[IPVS_DAEMON_ATTR_STATE]\t= { .type = NLA_U32 },\n\t[IPVS_DAEMON_ATTR_MCAST_IFN]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len = IP_VS_IFNAME_MAXLEN - 1 },\n\t[IPVS_DAEMON_ATTR_SYNC_ID]\t= { .type = NLA_U32 },\n\t[IPVS_DAEMON_ATTR_SYNC_MAXLEN]\t= { .type = NLA_U16 },\n\t[IPVS_DAEMON_ATTR_MCAST_GROUP]\t= { .type = NLA_U32 },\n\t[IPVS_DAEMON_ATTR_MCAST_GROUP6]\t= { .len = sizeof(struct in6_addr) },\n\t[IPVS_DAEMON_ATTR_MCAST_PORT]\t= { .type = NLA_U16 },\n\t[IPVS_DAEMON_ATTR_MCAST_TTL]\t= { .type = NLA_U8 },\n};\n\n \nstatic const struct nla_policy ip_vs_svc_policy[IPVS_SVC_ATTR_MAX + 1] = {\n\t[IPVS_SVC_ATTR_AF]\t\t= { .type = NLA_U16 },\n\t[IPVS_SVC_ATTR_PROTOCOL]\t= { .type = NLA_U16 },\n\t[IPVS_SVC_ATTR_ADDR]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof(union nf_inet_addr) },\n\t[IPVS_SVC_ATTR_PORT]\t\t= { .type = NLA_U16 },\n\t[IPVS_SVC_ATTR_FWMARK]\t\t= { .type = NLA_U32 },\n\t[IPVS_SVC_ATTR_SCHED_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len = IP_VS_SCHEDNAME_MAXLEN - 1 },\n\t[IPVS_SVC_ATTR_PE_NAME]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len = IP_VS_PENAME_MAXLEN },\n\t[IPVS_SVC_ATTR_FLAGS]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof(struct ip_vs_flags) },\n\t[IPVS_SVC_ATTR_TIMEOUT]\t\t= { .type = NLA_U32 },\n\t[IPVS_SVC_ATTR_NETMASK]\t\t= { .type = NLA_U32 },\n\t[IPVS_SVC_ATTR_STATS]\t\t= { .type = NLA_NESTED },\n};\n\n \nstatic const struct nla_policy ip_vs_dest_policy[IPVS_DEST_ATTR_MAX + 1] = {\n\t[IPVS_DEST_ATTR_ADDR]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof(union nf_inet_addr) },\n\t[IPVS_DEST_ATTR_PORT]\t\t= { .type = NLA_U16 },\n\t[IPVS_DEST_ATTR_FWD_METHOD]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_WEIGHT]\t\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_U_THRESH]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_L_THRESH]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_ACTIVE_CONNS]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_INACT_CONNS]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_PERSIST_CONNS]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_STATS]\t\t= { .type = NLA_NESTED },\n\t[IPVS_DEST_ATTR_ADDR_FAMILY]\t= { .type = NLA_U16 },\n\t[IPVS_DEST_ATTR_TUN_TYPE]\t= { .type = NLA_U8 },\n\t[IPVS_DEST_ATTR_TUN_PORT]\t= { .type = NLA_U16 },\n\t[IPVS_DEST_ATTR_TUN_FLAGS]\t= { .type = NLA_U16 },\n};\n\nstatic int ip_vs_genl_fill_stats(struct sk_buff *skb, int container_type,\n\t\t\t\t struct ip_vs_kstats *kstats)\n{\n\tstruct nlattr *nl_stats = nla_nest_start_noflag(skb, container_type);\n\n\tif (!nl_stats)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, IPVS_STATS_ATTR_CONNS, (u32)kstats->conns) ||\n\t    nla_put_u32(skb, IPVS_STATS_ATTR_INPKTS, (u32)kstats->inpkts) ||\n\t    nla_put_u32(skb, IPVS_STATS_ATTR_OUTPKTS, (u32)kstats->outpkts) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_INBYTES, kstats->inbytes,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_OUTBYTES, kstats->outbytes,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u32(skb, IPVS_STATS_ATTR_CPS, (u32)kstats->cps) ||\n\t    nla_put_u32(skb, IPVS_STATS_ATTR_INPPS, (u32)kstats->inpps) ||\n\t    nla_put_u32(skb, IPVS_STATS_ATTR_OUTPPS, (u32)kstats->outpps) ||\n\t    nla_put_u32(skb, IPVS_STATS_ATTR_INBPS, (u32)kstats->inbps) ||\n\t    nla_put_u32(skb, IPVS_STATS_ATTR_OUTBPS, (u32)kstats->outbps))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nl_stats);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_stats);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_fill_stats64(struct sk_buff *skb, int container_type,\n\t\t\t\t   struct ip_vs_kstats *kstats)\n{\n\tstruct nlattr *nl_stats = nla_nest_start_noflag(skb, container_type);\n\n\tif (!nl_stats)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u64_64bit(skb, IPVS_STATS_ATTR_CONNS, kstats->conns,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_INPKTS, kstats->inpkts,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_OUTPKTS, kstats->outpkts,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_INBYTES, kstats->inbytes,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_OUTBYTES, kstats->outbytes,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_CPS, kstats->cps,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_INPPS, kstats->inpps,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_OUTPPS, kstats->outpps,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_INBPS, kstats->inbps,\n\t\t\t      IPVS_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, IPVS_STATS_ATTR_OUTBPS, kstats->outbps,\n\t\t\t      IPVS_STATS_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nl_stats);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_stats);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_fill_service(struct sk_buff *skb,\n\t\t\t\t   struct ip_vs_service *svc)\n{\n\tstruct ip_vs_scheduler *sched;\n\tstruct ip_vs_pe *pe;\n\tstruct nlattr *nl_service;\n\tstruct ip_vs_flags flags = { .flags = svc->flags,\n\t\t\t\t     .mask = ~0 };\n\tstruct ip_vs_kstats kstats;\n\tchar *sched_name;\n\n\tnl_service = nla_nest_start_noflag(skb, IPVS_CMD_ATTR_SERVICE);\n\tif (!nl_service)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u16(skb, IPVS_SVC_ATTR_AF, svc->af))\n\t\tgoto nla_put_failure;\n\tif (svc->fwmark) {\n\t\tif (nla_put_u32(skb, IPVS_SVC_ATTR_FWMARK, svc->fwmark))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tif (nla_put_u16(skb, IPVS_SVC_ATTR_PROTOCOL, svc->protocol) ||\n\t\t    nla_put(skb, IPVS_SVC_ATTR_ADDR, sizeof(svc->addr), &svc->addr) ||\n\t\t    nla_put_be16(skb, IPVS_SVC_ATTR_PORT, svc->port))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tsched = rcu_dereference_protected(svc->scheduler, 1);\n\tsched_name = sched ? sched->name : \"none\";\n\tpe = rcu_dereference_protected(svc->pe, 1);\n\tif (nla_put_string(skb, IPVS_SVC_ATTR_SCHED_NAME, sched_name) ||\n\t    (pe && nla_put_string(skb, IPVS_SVC_ATTR_PE_NAME, pe->name)) ||\n\t    nla_put(skb, IPVS_SVC_ATTR_FLAGS, sizeof(flags), &flags) ||\n\t    nla_put_u32(skb, IPVS_SVC_ATTR_TIMEOUT, svc->timeout / HZ) ||\n\t    nla_put_be32(skb, IPVS_SVC_ATTR_NETMASK, svc->netmask))\n\t\tgoto nla_put_failure;\n\tip_vs_copy_stats(&kstats, &svc->stats);\n\tif (ip_vs_genl_fill_stats(skb, IPVS_SVC_ATTR_STATS, &kstats))\n\t\tgoto nla_put_failure;\n\tif (ip_vs_genl_fill_stats64(skb, IPVS_SVC_ATTR_STATS64, &kstats))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nl_service);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_service);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_service(struct sk_buff *skb,\n\t\t\t\t   struct ip_vs_service *svc,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &ip_vs_genl_family, NLM_F_MULTI,\n\t\t\t  IPVS_CMD_NEW_SERVICE);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (ip_vs_genl_fill_service(skb, svc) < 0)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_services(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tint idx = 0, i;\n\tint start = cb->args[0];\n\tstruct ip_vs_service *svc;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tmutex_lock(&__ip_vs_mutex);\n\tfor (i = 0; i < IP_VS_SVC_TAB_SIZE; i++) {\n\t\thlist_for_each_entry(svc, &ip_vs_svc_table[i], s_list) {\n\t\t\tif (++idx <= start || (svc->ipvs != ipvs))\n\t\t\t\tcontinue;\n\t\t\tif (ip_vs_genl_dump_service(skb, svc, cb) < 0) {\n\t\t\t\tidx--;\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < IP_VS_SVC_TAB_SIZE; i++) {\n\t\thlist_for_each_entry(svc, &ip_vs_svc_fwm_table[i], f_list) {\n\t\t\tif (++idx <= start || (svc->ipvs != ipvs))\n\t\t\t\tcontinue;\n\t\t\tif (ip_vs_genl_dump_service(skb, svc, cb) < 0) {\n\t\t\t\tidx--;\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\t}\n\nnla_put_failure:\n\tmutex_unlock(&__ip_vs_mutex);\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}\n\nstatic bool ip_vs_is_af_valid(int af)\n{\n\tif (af == AF_INET)\n\t\treturn true;\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6 && ipv6_mod_enabled())\n\t\treturn true;\n#endif\n\treturn false;\n}\n\nstatic int ip_vs_genl_parse_service(struct netns_ipvs *ipvs,\n\t\t\t\t    struct ip_vs_service_user_kern *usvc,\n\t\t\t\t    struct nlattr *nla, bool full_entry,\n\t\t\t\t    struct ip_vs_service **ret_svc)\n{\n\tstruct nlattr *attrs[IPVS_SVC_ATTR_MAX + 1];\n\tstruct nlattr *nla_af, *nla_port, *nla_fwmark, *nla_protocol, *nla_addr;\n\tstruct ip_vs_service *svc;\n\n\t \n\tif (nla == NULL ||\n\t    nla_parse_nested_deprecated(attrs, IPVS_SVC_ATTR_MAX, nla, ip_vs_svc_policy, NULL))\n\t\treturn -EINVAL;\n\n\tnla_af\t\t= attrs[IPVS_SVC_ATTR_AF];\n\tnla_protocol\t= attrs[IPVS_SVC_ATTR_PROTOCOL];\n\tnla_addr\t= attrs[IPVS_SVC_ATTR_ADDR];\n\tnla_port\t= attrs[IPVS_SVC_ATTR_PORT];\n\tnla_fwmark\t= attrs[IPVS_SVC_ATTR_FWMARK];\n\n\tif (!(nla_af && (nla_fwmark || (nla_port && nla_protocol && nla_addr))))\n\t\treturn -EINVAL;\n\n\tmemset(usvc, 0, sizeof(*usvc));\n\n\tusvc->af = nla_get_u16(nla_af);\n\tif (!ip_vs_is_af_valid(usvc->af))\n\t\treturn -EAFNOSUPPORT;\n\n\tif (nla_fwmark) {\n\t\tusvc->protocol = IPPROTO_TCP;\n\t\tusvc->fwmark = nla_get_u32(nla_fwmark);\n\t} else {\n\t\tusvc->protocol = nla_get_u16(nla_protocol);\n\t\tnla_memcpy(&usvc->addr, nla_addr, sizeof(usvc->addr));\n\t\tusvc->port = nla_get_be16(nla_port);\n\t\tusvc->fwmark = 0;\n\t}\n\n\trcu_read_lock();\n\tif (usvc->fwmark)\n\t\tsvc = __ip_vs_svc_fwm_find(ipvs, usvc->af, usvc->fwmark);\n\telse\n\t\tsvc = __ip_vs_service_find(ipvs, usvc->af, usvc->protocol,\n\t\t\t\t\t   &usvc->addr, usvc->port);\n\trcu_read_unlock();\n\t*ret_svc = svc;\n\n\t \n\tif (full_entry) {\n\t\tstruct nlattr *nla_sched, *nla_flags, *nla_pe, *nla_timeout,\n\t\t\t      *nla_netmask;\n\t\tstruct ip_vs_flags flags;\n\n\t\tnla_sched = attrs[IPVS_SVC_ATTR_SCHED_NAME];\n\t\tnla_pe = attrs[IPVS_SVC_ATTR_PE_NAME];\n\t\tnla_flags = attrs[IPVS_SVC_ATTR_FLAGS];\n\t\tnla_timeout = attrs[IPVS_SVC_ATTR_TIMEOUT];\n\t\tnla_netmask = attrs[IPVS_SVC_ATTR_NETMASK];\n\n\t\tif (!(nla_sched && nla_flags && nla_timeout && nla_netmask))\n\t\t\treturn -EINVAL;\n\n\t\tnla_memcpy(&flags, nla_flags, sizeof(flags));\n\n\t\t \n\t\tif (svc)\n\t\t\tusvc->flags = svc->flags;\n\n\t\t \n\t\tusvc->flags = (usvc->flags & ~flags.mask) |\n\t\t\t      (flags.flags & flags.mask);\n\t\tusvc->sched_name = nla_data(nla_sched);\n\t\tusvc->pe_name = nla_pe ? nla_data(nla_pe) : NULL;\n\t\tusvc->timeout = nla_get_u32(nla_timeout);\n\t\tusvc->netmask = nla_get_be32(nla_netmask);\n\t}\n\n\treturn 0;\n}\n\nstatic struct ip_vs_service *ip_vs_genl_find_service(struct netns_ipvs *ipvs,\n\t\t\t\t\t\t     struct nlattr *nla)\n{\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tint ret;\n\n\tret = ip_vs_genl_parse_service(ipvs, &usvc, nla, false, &svc);\n\treturn ret ? ERR_PTR(ret) : svc;\n}\n\nstatic int ip_vs_genl_fill_dest(struct sk_buff *skb, struct ip_vs_dest *dest)\n{\n\tstruct nlattr *nl_dest;\n\tstruct ip_vs_kstats kstats;\n\n\tnl_dest = nla_nest_start_noflag(skb, IPVS_CMD_ATTR_DEST);\n\tif (!nl_dest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put(skb, IPVS_DEST_ATTR_ADDR, sizeof(dest->addr), &dest->addr) ||\n\t    nla_put_be16(skb, IPVS_DEST_ATTR_PORT, dest->port) ||\n\t    nla_put_u32(skb, IPVS_DEST_ATTR_FWD_METHOD,\n\t\t\t(atomic_read(&dest->conn_flags) &\n\t\t\t IP_VS_CONN_F_FWD_MASK)) ||\n\t    nla_put_u32(skb, IPVS_DEST_ATTR_WEIGHT,\n\t\t\tatomic_read(&dest->weight)) ||\n\t    nla_put_u8(skb, IPVS_DEST_ATTR_TUN_TYPE,\n\t\t       dest->tun_type) ||\n\t    nla_put_be16(skb, IPVS_DEST_ATTR_TUN_PORT,\n\t\t\t dest->tun_port) ||\n\t    nla_put_u16(skb, IPVS_DEST_ATTR_TUN_FLAGS,\n\t\t\tdest->tun_flags) ||\n\t    nla_put_u32(skb, IPVS_DEST_ATTR_U_THRESH, dest->u_threshold) ||\n\t    nla_put_u32(skb, IPVS_DEST_ATTR_L_THRESH, dest->l_threshold) ||\n\t    nla_put_u32(skb, IPVS_DEST_ATTR_ACTIVE_CONNS,\n\t\t\tatomic_read(&dest->activeconns)) ||\n\t    nla_put_u32(skb, IPVS_DEST_ATTR_INACT_CONNS,\n\t\t\tatomic_read(&dest->inactconns)) ||\n\t    nla_put_u32(skb, IPVS_DEST_ATTR_PERSIST_CONNS,\n\t\t\tatomic_read(&dest->persistconns)) ||\n\t    nla_put_u16(skb, IPVS_DEST_ATTR_ADDR_FAMILY, dest->af))\n\t\tgoto nla_put_failure;\n\tip_vs_copy_stats(&kstats, &dest->stats);\n\tif (ip_vs_genl_fill_stats(skb, IPVS_DEST_ATTR_STATS, &kstats))\n\t\tgoto nla_put_failure;\n\tif (ip_vs_genl_fill_stats64(skb, IPVS_DEST_ATTR_STATS64, &kstats))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nl_dest);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_dest);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_dest(struct sk_buff *skb, struct ip_vs_dest *dest,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &ip_vs_genl_family, NLM_F_MULTI,\n\t\t\t  IPVS_CMD_NEW_DEST);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (ip_vs_genl_fill_dest(skb, dest) < 0)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_dests(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tint idx = 0;\n\tint start = cb->args[0];\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest *dest;\n\tstruct nlattr *attrs[IPVS_CMD_ATTR_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tmutex_lock(&__ip_vs_mutex);\n\n\t \n\tif (nlmsg_parse_deprecated(cb->nlh, GENL_HDRLEN, attrs, IPVS_CMD_ATTR_MAX, ip_vs_cmd_policy, cb->extack))\n\t\tgoto out_err;\n\n\n\tsvc = ip_vs_genl_find_service(ipvs, attrs[IPVS_CMD_ATTR_SERVICE]);\n\tif (IS_ERR_OR_NULL(svc))\n\t\tgoto out_err;\n\n\t \n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (ip_vs_genl_dump_dest(skb, dest, cb) < 0) {\n\t\t\tidx--;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\nnla_put_failure:\n\tcb->args[0] = idx;\n\nout_err:\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn skb->len;\n}\n\nstatic int ip_vs_genl_parse_dest(struct ip_vs_dest_user_kern *udest,\n\t\t\t\t struct nlattr *nla, bool full_entry)\n{\n\tstruct nlattr *attrs[IPVS_DEST_ATTR_MAX + 1];\n\tstruct nlattr *nla_addr, *nla_port;\n\tstruct nlattr *nla_addr_family;\n\n\t \n\tif (nla == NULL ||\n\t    nla_parse_nested_deprecated(attrs, IPVS_DEST_ATTR_MAX, nla, ip_vs_dest_policy, NULL))\n\t\treturn -EINVAL;\n\n\tnla_addr\t= attrs[IPVS_DEST_ATTR_ADDR];\n\tnla_port\t= attrs[IPVS_DEST_ATTR_PORT];\n\tnla_addr_family\t= attrs[IPVS_DEST_ATTR_ADDR_FAMILY];\n\n\tif (!(nla_addr && nla_port))\n\t\treturn -EINVAL;\n\n\tmemset(udest, 0, sizeof(*udest));\n\n\tnla_memcpy(&udest->addr, nla_addr, sizeof(udest->addr));\n\tudest->port = nla_get_be16(nla_port);\n\n\tif (nla_addr_family)\n\t\tudest->af = nla_get_u16(nla_addr_family);\n\telse\n\t\tudest->af = 0;\n\n\t \n\tif (full_entry) {\n\t\tstruct nlattr *nla_fwd, *nla_weight, *nla_u_thresh,\n\t\t\t      *nla_l_thresh, *nla_tun_type, *nla_tun_port,\n\t\t\t      *nla_tun_flags;\n\n\t\tnla_fwd\t\t= attrs[IPVS_DEST_ATTR_FWD_METHOD];\n\t\tnla_weight\t= attrs[IPVS_DEST_ATTR_WEIGHT];\n\t\tnla_u_thresh\t= attrs[IPVS_DEST_ATTR_U_THRESH];\n\t\tnla_l_thresh\t= attrs[IPVS_DEST_ATTR_L_THRESH];\n\t\tnla_tun_type\t= attrs[IPVS_DEST_ATTR_TUN_TYPE];\n\t\tnla_tun_port\t= attrs[IPVS_DEST_ATTR_TUN_PORT];\n\t\tnla_tun_flags\t= attrs[IPVS_DEST_ATTR_TUN_FLAGS];\n\n\t\tif (!(nla_fwd && nla_weight && nla_u_thresh && nla_l_thresh))\n\t\t\treturn -EINVAL;\n\n\t\tudest->conn_flags = nla_get_u32(nla_fwd)\n\t\t\t\t    & IP_VS_CONN_F_FWD_MASK;\n\t\tudest->weight = nla_get_u32(nla_weight);\n\t\tudest->u_threshold = nla_get_u32(nla_u_thresh);\n\t\tudest->l_threshold = nla_get_u32(nla_l_thresh);\n\n\t\tif (nla_tun_type)\n\t\t\tudest->tun_type = nla_get_u8(nla_tun_type);\n\n\t\tif (nla_tun_port)\n\t\t\tudest->tun_port = nla_get_be16(nla_tun_port);\n\n\t\tif (nla_tun_flags)\n\t\t\tudest->tun_flags = nla_get_u16(nla_tun_flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int ip_vs_genl_fill_daemon(struct sk_buff *skb, __u32 state,\n\t\t\t\t  struct ipvs_sync_daemon_cfg *c)\n{\n\tstruct nlattr *nl_daemon;\n\n\tnl_daemon = nla_nest_start_noflag(skb, IPVS_CMD_ATTR_DAEMON);\n\tif (!nl_daemon)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, IPVS_DAEMON_ATTR_STATE, state) ||\n\t    nla_put_string(skb, IPVS_DAEMON_ATTR_MCAST_IFN, c->mcast_ifn) ||\n\t    nla_put_u32(skb, IPVS_DAEMON_ATTR_SYNC_ID, c->syncid) ||\n\t    nla_put_u16(skb, IPVS_DAEMON_ATTR_SYNC_MAXLEN, c->sync_maxlen) ||\n\t    nla_put_u16(skb, IPVS_DAEMON_ATTR_MCAST_PORT, c->mcast_port) ||\n\t    nla_put_u8(skb, IPVS_DAEMON_ATTR_MCAST_TTL, c->mcast_ttl))\n\t\tgoto nla_put_failure;\n#ifdef CONFIG_IP_VS_IPV6\n\tif (c->mcast_af == AF_INET6) {\n\t\tif (nla_put_in6_addr(skb, IPVS_DAEMON_ATTR_MCAST_GROUP6,\n\t\t\t\t     &c->mcast_group.in6))\n\t\t\tgoto nla_put_failure;\n\t} else\n#endif\n\t\tif (c->mcast_af == AF_INET &&\n\t\t    nla_put_in_addr(skb, IPVS_DAEMON_ATTR_MCAST_GROUP,\n\t\t\t\t    c->mcast_group.ip))\n\t\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nl_daemon);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_daemon);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_daemon(struct sk_buff *skb, __u32 state,\n\t\t\t\t  struct ipvs_sync_daemon_cfg *c,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\tvoid *hdr;\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &ip_vs_genl_family, NLM_F_MULTI,\n\t\t\t  IPVS_CMD_NEW_DAEMON);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (ip_vs_genl_fill_daemon(skb, state, c))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_daemons(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tmutex_lock(&ipvs->sync_mutex);\n\tif ((ipvs->sync_state & IP_VS_STATE_MASTER) && !cb->args[0]) {\n\t\tif (ip_vs_genl_dump_daemon(skb, IP_VS_STATE_MASTER,\n\t\t\t\t\t   &ipvs->mcfg, cb) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tcb->args[0] = 1;\n\t}\n\n\tif ((ipvs->sync_state & IP_VS_STATE_BACKUP) && !cb->args[1]) {\n\t\tif (ip_vs_genl_dump_daemon(skb, IP_VS_STATE_BACKUP,\n\t\t\t\t\t   &ipvs->bcfg, cb) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tcb->args[1] = 1;\n\t}\n\nnla_put_failure:\n\tmutex_unlock(&ipvs->sync_mutex);\n\n\treturn skb->len;\n}\n\nstatic int ip_vs_genl_new_daemon(struct netns_ipvs *ipvs, struct nlattr **attrs)\n{\n\tstruct ipvs_sync_daemon_cfg c;\n\tstruct nlattr *a;\n\tint ret;\n\n\tmemset(&c, 0, sizeof(c));\n\tif (!(attrs[IPVS_DAEMON_ATTR_STATE] &&\n\t      attrs[IPVS_DAEMON_ATTR_MCAST_IFN] &&\n\t      attrs[IPVS_DAEMON_ATTR_SYNC_ID]))\n\t\treturn -EINVAL;\n\tstrscpy(c.mcast_ifn, nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),\n\t\tsizeof(c.mcast_ifn));\n\tc.syncid = nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]);\n\n\ta = attrs[IPVS_DAEMON_ATTR_SYNC_MAXLEN];\n\tif (a)\n\t\tc.sync_maxlen = nla_get_u16(a);\n\n\ta = attrs[IPVS_DAEMON_ATTR_MCAST_GROUP];\n\tif (a) {\n\t\tc.mcast_af = AF_INET;\n\t\tc.mcast_group.ip = nla_get_in_addr(a);\n\t\tif (!ipv4_is_multicast(c.mcast_group.ip))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\ta = attrs[IPVS_DAEMON_ATTR_MCAST_GROUP6];\n\t\tif (a) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\t\tint addr_type;\n\n\t\t\tc.mcast_af = AF_INET6;\n\t\t\tc.mcast_group.in6 = nla_get_in6_addr(a);\n\t\t\taddr_type = ipv6_addr_type(&c.mcast_group.in6);\n\t\t\tif (!(addr_type & IPV6_ADDR_MULTICAST))\n\t\t\t\treturn -EINVAL;\n#else\n\t\t\treturn -EAFNOSUPPORT;\n#endif\n\t\t}\n\t}\n\n\ta = attrs[IPVS_DAEMON_ATTR_MCAST_PORT];\n\tif (a)\n\t\tc.mcast_port = nla_get_u16(a);\n\n\ta = attrs[IPVS_DAEMON_ATTR_MCAST_TTL];\n\tif (a)\n\t\tc.mcast_ttl = nla_get_u8(a);\n\n\t \n\tif (ipvs->mixed_address_family_dests > 0)\n\t\treturn -EINVAL;\n\n\tret = start_sync_thread(ipvs, &c,\n\t\t\t\tnla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]));\n\treturn ret;\n}\n\nstatic int ip_vs_genl_del_daemon(struct netns_ipvs *ipvs, struct nlattr **attrs)\n{\n\tint ret;\n\n\tif (!attrs[IPVS_DAEMON_ATTR_STATE])\n\t\treturn -EINVAL;\n\n\tret = stop_sync_thread(ipvs,\n\t\t\t       nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]));\n\treturn ret;\n}\n\nstatic int ip_vs_genl_set_config(struct netns_ipvs *ipvs, struct nlattr **attrs)\n{\n\tstruct ip_vs_timeout_user t;\n\n\t__ip_vs_get_timeouts(ipvs, &t);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP])\n\t\tt.tcp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP]);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN])\n\t\tt.tcp_fin_timeout =\n\t\t\tnla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN]);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_UDP])\n\t\tt.udp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_UDP]);\n\n\treturn ip_vs_set_timeout(ipvs, &t);\n}\n\nstatic int ip_vs_genl_set_daemon(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret = -EINVAL, cmd;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tcmd = info->genlhdr->cmd;\n\n\tif (cmd == IPVS_CMD_NEW_DAEMON || cmd == IPVS_CMD_DEL_DAEMON) {\n\t\tstruct nlattr *daemon_attrs[IPVS_DAEMON_ATTR_MAX + 1];\n\n\t\tif (!info->attrs[IPVS_CMD_ATTR_DAEMON] ||\n\t\t    nla_parse_nested_deprecated(daemon_attrs, IPVS_DAEMON_ATTR_MAX, info->attrs[IPVS_CMD_ATTR_DAEMON], ip_vs_daemon_policy, info->extack))\n\t\t\tgoto out;\n\n\t\tif (cmd == IPVS_CMD_NEW_DAEMON)\n\t\t\tret = ip_vs_genl_new_daemon(ipvs, daemon_attrs);\n\t\telse\n\t\t\tret = ip_vs_genl_del_daemon(ipvs, daemon_attrs);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int ip_vs_genl_set_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tbool need_full_svc = false, need_full_dest = false;\n\tstruct ip_vs_service *svc = NULL;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_dest_user_kern udest;\n\tint ret = 0, cmd;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tcmd = info->genlhdr->cmd;\n\n\tmutex_lock(&__ip_vs_mutex);\n\n\tif (cmd == IPVS_CMD_FLUSH) {\n\t\tret = ip_vs_flush(ipvs, false);\n\t\tgoto out;\n\t} else if (cmd == IPVS_CMD_SET_CONFIG) {\n\t\tret = ip_vs_genl_set_config(ipvs, info->attrs);\n\t\tgoto out;\n\t} else if (cmd == IPVS_CMD_ZERO &&\n\t\t   !info->attrs[IPVS_CMD_ATTR_SERVICE]) {\n\t\tret = ip_vs_zero_all(ipvs);\n\t\tgoto out;\n\t}\n\n\t \n\tif (cmd == IPVS_CMD_NEW_SERVICE || cmd == IPVS_CMD_SET_SERVICE)\n\t\tneed_full_svc = true;\n\n\tret = ip_vs_genl_parse_service(ipvs, &usvc,\n\t\t\t\t       info->attrs[IPVS_CMD_ATTR_SERVICE],\n\t\t\t\t       need_full_svc, &svc);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif ((cmd != IPVS_CMD_NEW_SERVICE) && (svc == NULL)) {\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\t \n\tif (cmd == IPVS_CMD_NEW_DEST || cmd == IPVS_CMD_SET_DEST ||\n\t    cmd == IPVS_CMD_DEL_DEST) {\n\t\tif (cmd != IPVS_CMD_DEL_DEST)\n\t\t\tneed_full_dest = true;\n\n\t\tret = ip_vs_genl_parse_dest(&udest,\n\t\t\t\t\t    info->attrs[IPVS_CMD_ATTR_DEST],\n\t\t\t\t\t    need_full_dest);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (udest.af == 0)\n\t\t\tudest.af = svc->af;\n\n\t\tif (!ip_vs_is_af_valid(udest.af)) {\n\t\t\tret = -EAFNOSUPPORT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (udest.af != svc->af && cmd != IPVS_CMD_DEL_DEST) {\n\t\t\t \n\t\t\tif (ipvs->sync_state) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tswitch (udest.conn_flags) {\n\t\t\tcase IP_VS_CONN_F_TUNNEL:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (cmd) {\n\tcase IPVS_CMD_NEW_SERVICE:\n\t\tif (svc == NULL)\n\t\t\tret = ip_vs_add_service(ipvs, &usvc, &svc);\n\t\telse\n\t\t\tret = -EEXIST;\n\t\tbreak;\n\tcase IPVS_CMD_SET_SERVICE:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IPVS_CMD_DEL_SERVICE:\n\t\tret = ip_vs_del_service(svc);\n\t\t \n\t\tbreak;\n\tcase IPVS_CMD_NEW_DEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IPVS_CMD_SET_DEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IPVS_CMD_DEL_DEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tcase IPVS_CMD_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn ret;\n}\n\nstatic int ip_vs_genl_get_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tvoid *reply;\n\tint ret, cmd, reply_cmd;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tcmd = info->genlhdr->cmd;\n\n\tif (cmd == IPVS_CMD_GET_SERVICE)\n\t\treply_cmd = IPVS_CMD_NEW_SERVICE;\n\telse if (cmd == IPVS_CMD_GET_INFO)\n\t\treply_cmd = IPVS_CMD_SET_INFO;\n\telse if (cmd == IPVS_CMD_GET_CONFIG)\n\t\treply_cmd = IPVS_CMD_SET_CONFIG;\n\telse {\n\t\tpr_err(\"unknown Generic Netlink command\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&__ip_vs_mutex);\n\n\treply = genlmsg_put_reply(msg, info, &ip_vs_genl_family, 0, reply_cmd);\n\tif (reply == NULL)\n\t\tgoto nla_put_failure;\n\n\tswitch (cmd) {\n\tcase IPVS_CMD_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service *svc;\n\n\t\tsvc = ip_vs_genl_find_service(ipvs,\n\t\t\t\t\t      info->attrs[IPVS_CMD_ATTR_SERVICE]);\n\t\tif (IS_ERR(svc)) {\n\t\t\tret = PTR_ERR(svc);\n\t\t\tgoto out_err;\n\t\t} else if (svc) {\n\t\t\tret = ip_vs_genl_fill_service(msg, svc);\n\t\t\tif (ret)\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\tret = -ESRCH;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase IPVS_CMD_GET_CONFIG:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(ipvs, &t);\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\t\tif (nla_put_u32(msg, IPVS_CMD_ATTR_TIMEOUT_TCP,\n\t\t\t\tt.tcp_timeout) ||\n\t\t    nla_put_u32(msg, IPVS_CMD_ATTR_TIMEOUT_TCP_FIN,\n\t\t\t\tt.tcp_fin_timeout))\n\t\t\tgoto nla_put_failure;\n#endif\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\t\tif (nla_put_u32(msg, IPVS_CMD_ATTR_TIMEOUT_UDP, t.udp_timeout))\n\t\t\tgoto nla_put_failure;\n#endif\n\n\t\tbreak;\n\t}\n\n\tcase IPVS_CMD_GET_INFO:\n\t\tif (nla_put_u32(msg, IPVS_INFO_ATTR_VERSION,\n\t\t\t\tIP_VS_VERSION_CODE) ||\n\t\t    nla_put_u32(msg, IPVS_INFO_ATTR_CONN_TAB_SIZE,\n\t\t\t\tip_vs_conn_tab_size))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\n\tgenlmsg_end(msg, reply);\n\tret = genlmsg_reply(msg, info);\n\tgoto out;\n\nnla_put_failure:\n\tpr_err(\"not enough space in Netlink message\\n\");\n\tret = -EMSGSIZE;\n\nout_err:\n\tnlmsg_free(msg);\nout:\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn ret;\n}\n\n\nstatic const struct genl_small_ops ip_vs_genl_ops[] = {\n\t{\n\t\t.cmd\t= IPVS_CMD_NEW_SERVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_SET_SERVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_DEL_SERVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_SERVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_get_cmd,\n\t\t.dumpit\t= ip_vs_genl_dump_services,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_NEW_DEST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_SET_DEST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_DEL_DEST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_DEST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.dumpit\t= ip_vs_genl_dump_dests,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_NEW_DAEMON,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_daemon,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_DEL_DAEMON,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_daemon,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_DAEMON,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.dumpit\t= ip_vs_genl_dump_daemons,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_SET_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_get_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_INFO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_get_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_ZERO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_FLUSH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n};\n\nstatic struct genl_family ip_vs_genl_family __ro_after_init = {\n\t.hdrsize\t= 0,\n\t.name\t\t= IPVS_GENL_NAME,\n\t.version\t= IPVS_GENL_VERSION,\n\t.maxattr\t= IPVS_CMD_ATTR_MAX,\n\t.policy = ip_vs_cmd_policy,\n\t.netnsok        = true,          \n\t.module\t\t= THIS_MODULE,\n\t.small_ops\t= ip_vs_genl_ops,\n\t.n_small_ops\t= ARRAY_SIZE(ip_vs_genl_ops),\n\t.resv_start_op\t= IPVS_CMD_FLUSH + 1,\n};\n\nstatic int __init ip_vs_genl_register(void)\n{\n\treturn genl_register_family(&ip_vs_genl_family);\n}\n\nstatic void ip_vs_genl_unregister(void)\n{\n\tgenl_unregister_family(&ip_vs_genl_family);\n}\n\n \n\n \n#ifdef CONFIG_SYSCTL\nstatic int __net_init ip_vs_control_net_init_sysctl(struct netns_ipvs *ipvs)\n{\n\tstruct net *net = ipvs->net;\n\tstruct ctl_table *tbl;\n\tint idx, ret;\n\tsize_t ctl_table_size = ARRAY_SIZE(vs_vars);\n\n\tatomic_set(&ipvs->dropentry, 0);\n\tspin_lock_init(&ipvs->dropentry_lock);\n\tspin_lock_init(&ipvs->droppacket_lock);\n\tspin_lock_init(&ipvs->securetcp_lock);\n\tINIT_DELAYED_WORK(&ipvs->defense_work, defense_work_handler);\n\tINIT_DELAYED_WORK(&ipvs->expire_nodest_conn_work,\n\t\t\t  expire_nodest_conn_handler);\n\tipvs->est_stopped = 0;\n\n\tif (!net_eq(net, &init_net)) {\n\t\ttbl = kmemdup(vs_vars, sizeof(vs_vars), GFP_KERNEL);\n\t\tif (tbl == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tif (net->user_ns != &init_user_ns) {\n\t\t\ttbl[0].procname = NULL;\n\t\t\tctl_table_size = 0;\n\t\t}\n\t} else\n\t\ttbl = vs_vars;\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(vs_vars); idx++) {\n\t\tif (tbl[idx].proc_handler == proc_do_defense_mode)\n\t\t\ttbl[idx].extra2 = ipvs;\n\t}\n\tidx = 0;\n\tipvs->sysctl_amemthresh = 1024;\n\ttbl[idx++].data = &ipvs->sysctl_amemthresh;\n\tipvs->sysctl_am_droprate = 10;\n\ttbl[idx++].data = &ipvs->sysctl_am_droprate;\n\ttbl[idx++].data = &ipvs->sysctl_drop_entry;\n\ttbl[idx++].data = &ipvs->sysctl_drop_packet;\n#ifdef CONFIG_IP_VS_NFCT\n\ttbl[idx++].data = &ipvs->sysctl_conntrack;\n#endif\n\ttbl[idx++].data = &ipvs->sysctl_secure_tcp;\n\tipvs->sysctl_snat_reroute = 1;\n\ttbl[idx++].data = &ipvs->sysctl_snat_reroute;\n\tipvs->sysctl_sync_ver = 1;\n\ttbl[idx++].data = &ipvs->sysctl_sync_ver;\n\tipvs->sysctl_sync_ports = 1;\n\ttbl[idx++].data = &ipvs->sysctl_sync_ports;\n\ttbl[idx++].data = &ipvs->sysctl_sync_persist_mode;\n\tipvs->sysctl_sync_qlen_max = nr_free_buffer_pages() / 32;\n\ttbl[idx++].data = &ipvs->sysctl_sync_qlen_max;\n\tipvs->sysctl_sync_sock_size = 0;\n\ttbl[idx++].data = &ipvs->sysctl_sync_sock_size;\n\ttbl[idx++].data = &ipvs->sysctl_cache_bypass;\n\ttbl[idx++].data = &ipvs->sysctl_expire_nodest_conn;\n\ttbl[idx++].data = &ipvs->sysctl_sloppy_tcp;\n\ttbl[idx++].data = &ipvs->sysctl_sloppy_sctp;\n\ttbl[idx++].data = &ipvs->sysctl_expire_quiescent_template;\n\tipvs->sysctl_sync_threshold[0] = DEFAULT_SYNC_THRESHOLD;\n\tipvs->sysctl_sync_threshold[1] = DEFAULT_SYNC_PERIOD;\n\ttbl[idx].data = &ipvs->sysctl_sync_threshold;\n\ttbl[idx].extra2 = ipvs;\n\ttbl[idx++].maxlen = sizeof(ipvs->sysctl_sync_threshold);\n\tipvs->sysctl_sync_refresh_period = DEFAULT_SYNC_REFRESH_PERIOD;\n\ttbl[idx++].data = &ipvs->sysctl_sync_refresh_period;\n\tipvs->sysctl_sync_retries = clamp_t(int, DEFAULT_SYNC_RETRIES, 0, 3);\n\ttbl[idx++].data = &ipvs->sysctl_sync_retries;\n\ttbl[idx++].data = &ipvs->sysctl_nat_icmp_send;\n\tipvs->sysctl_pmtu_disc = 1;\n\ttbl[idx++].data = &ipvs->sysctl_pmtu_disc;\n\ttbl[idx++].data = &ipvs->sysctl_backup_only;\n\tipvs->sysctl_conn_reuse_mode = 1;\n\ttbl[idx++].data = &ipvs->sysctl_conn_reuse_mode;\n\ttbl[idx++].data = &ipvs->sysctl_schedule_icmp;\n\ttbl[idx++].data = &ipvs->sysctl_ignore_tunneled;\n\tipvs->sysctl_run_estimation = 1;\n\ttbl[idx].extra2 = ipvs;\n\ttbl[idx++].data = &ipvs->sysctl_run_estimation;\n\n\tipvs->est_cpulist_valid = 0;\n\ttbl[idx].extra2 = ipvs;\n\ttbl[idx++].data = &ipvs->sysctl_est_cpulist;\n\n\tipvs->sysctl_est_nice = IPVS_EST_NICE;\n\ttbl[idx].extra2 = ipvs;\n\ttbl[idx++].data = &ipvs->sysctl_est_nice;\n\n#ifdef CONFIG_IP_VS_DEBUG\n\t \n\tif (!net_eq(net, &init_net))\n\t\ttbl[idx++].mode = 0444;\n#endif\n\n\tret = -ENOMEM;\n\tipvs->sysctl_hdr = register_net_sysctl_sz(net, \"net/ipv4/vs\", tbl,\n\t\t\t\t\t\t  ctl_table_size);\n\tif (!ipvs->sysctl_hdr)\n\t\tgoto err;\n\tipvs->sysctl_tbl = tbl;\n\n\tret = ip_vs_start_estimator(ipvs, &ipvs->tot_stats->s);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tqueue_delayed_work(system_long_wq, &ipvs->defense_work,\n\t\t\t   DEFENSE_TIMER_PERIOD);\n\n\treturn 0;\n\nerr:\n\tunregister_net_sysctl_table(ipvs->sysctl_hdr);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(tbl);\n\treturn ret;\n}\n\nstatic void __net_exit ip_vs_control_net_cleanup_sysctl(struct netns_ipvs *ipvs)\n{\n\tstruct net *net = ipvs->net;\n\n\tcancel_delayed_work_sync(&ipvs->expire_nodest_conn_work);\n\tcancel_delayed_work_sync(&ipvs->defense_work);\n\tcancel_work_sync(&ipvs->defense_work.work);\n\tunregister_net_sysctl_table(ipvs->sysctl_hdr);\n\tip_vs_stop_estimator(ipvs, &ipvs->tot_stats->s);\n\n\tif (ipvs->est_cpulist_valid)\n\t\tfree_cpumask_var(ipvs->sysctl_est_cpulist);\n\n\tif (!net_eq(net, &init_net))\n\t\tkfree(ipvs->sysctl_tbl);\n}\n\n#else\n\nstatic int __net_init ip_vs_control_net_init_sysctl(struct netns_ipvs *ipvs) { return 0; }\nstatic void __net_exit ip_vs_control_net_cleanup_sysctl(struct netns_ipvs *ipvs) { }\n\n#endif\n\nstatic struct notifier_block ip_vs_dst_notifier = {\n\t.notifier_call = ip_vs_dst_event,\n#ifdef CONFIG_IP_VS_IPV6\n\t.priority = ADDRCONF_NOTIFY_PRIORITY + 5,\n#endif\n};\n\nint __net_init ip_vs_control_net_init(struct netns_ipvs *ipvs)\n{\n\tint ret = -ENOMEM;\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < IP_VS_RTAB_SIZE; idx++)\n\t\tINIT_HLIST_HEAD(&ipvs->rs_table[idx]);\n\n\tINIT_LIST_HEAD(&ipvs->dest_trash);\n\tspin_lock_init(&ipvs->dest_trash_lock);\n\ttimer_setup(&ipvs->dest_trash_timer, ip_vs_dest_trash_expire, 0);\n\tatomic_set(&ipvs->ftpsvc_counter, 0);\n\tatomic_set(&ipvs->nullsvc_counter, 0);\n\tatomic_set(&ipvs->conn_out_counter, 0);\n\n\tINIT_DELAYED_WORK(&ipvs->est_reload_work, est_reload_work_handler);\n\n\t \n\tipvs->tot_stats = kzalloc(sizeof(*ipvs->tot_stats), GFP_KERNEL);\n\tif (!ipvs->tot_stats)\n\t\tgoto out;\n\tif (ip_vs_stats_init_alloc(&ipvs->tot_stats->s) < 0)\n\t\tgoto err_tot_stats;\n\n#ifdef CONFIG_PROC_FS\n\tif (!proc_create_net(\"ip_vs\", 0, ipvs->net->proc_net,\n\t\t\t     &ip_vs_info_seq_ops, sizeof(struct ip_vs_iter)))\n\t\tgoto err_vs;\n\tif (!proc_create_net_single(\"ip_vs_stats\", 0, ipvs->net->proc_net,\n\t\t\t\t    ip_vs_stats_show, NULL))\n\t\tgoto err_stats;\n\tif (!proc_create_net_single(\"ip_vs_stats_percpu\", 0,\n\t\t\t\t    ipvs->net->proc_net,\n\t\t\t\t    ip_vs_stats_percpu_show, NULL))\n\t\tgoto err_percpu;\n#endif\n\n\tret = ip_vs_control_net_init_sysctl(ipvs);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ip_vs_stats_percpu\", ipvs->net->proc_net);\n\nerr_percpu:\n\tremove_proc_entry(\"ip_vs_stats\", ipvs->net->proc_net);\n\nerr_stats:\n\tremove_proc_entry(\"ip_vs\", ipvs->net->proc_net);\n\nerr_vs:\n#endif\n\tip_vs_stats_release(&ipvs->tot_stats->s);\n\nerr_tot_stats:\n\tkfree(ipvs->tot_stats);\n\nout:\n\treturn ret;\n}\n\nvoid __net_exit ip_vs_control_net_cleanup(struct netns_ipvs *ipvs)\n{\n\tip_vs_trash_cleanup(ipvs);\n\tip_vs_control_net_cleanup_sysctl(ipvs);\n\tcancel_delayed_work_sync(&ipvs->est_reload_work);\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ip_vs_stats_percpu\", ipvs->net->proc_net);\n\tremove_proc_entry(\"ip_vs_stats\", ipvs->net->proc_net);\n\tremove_proc_entry(\"ip_vs\", ipvs->net->proc_net);\n#endif\n\tcall_rcu(&ipvs->tot_stats->rcu_head, ip_vs_stats_rcu_free);\n}\n\nint __init ip_vs_register_nl_ioctl(void)\n{\n\tint ret;\n\n\tret = nf_register_sockopt(&ip_vs_sockopts);\n\tif (ret) {\n\t\tpr_err(\"cannot register sockopt.\\n\");\n\t\tgoto err_sock;\n\t}\n\n\tret = ip_vs_genl_register();\n\tif (ret) {\n\t\tpr_err(\"cannot register Generic Netlink interface.\\n\");\n\t\tgoto err_genl;\n\t}\n\treturn 0;\n\nerr_genl:\n\tnf_unregister_sockopt(&ip_vs_sockopts);\nerr_sock:\n\treturn ret;\n}\n\nvoid ip_vs_unregister_nl_ioctl(void)\n{\n\tip_vs_genl_unregister();\n\tnf_unregister_sockopt(&ip_vs_sockopts);\n}\n\nint __init ip_vs_control_init(void)\n{\n\tint idx;\n\tint ret;\n\n\t \n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tINIT_HLIST_HEAD(&ip_vs_svc_table[idx]);\n\t\tINIT_HLIST_HEAD(&ip_vs_svc_fwm_table[idx]);\n\t}\n\n\tsmp_wmb();\t \n\n\tret = register_netdevice_notifier(&ip_vs_dst_notifier);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n\nvoid ip_vs_control_cleanup(void)\n{\n\tunregister_netdevice_notifier(&ip_vs_dst_notifier);\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}