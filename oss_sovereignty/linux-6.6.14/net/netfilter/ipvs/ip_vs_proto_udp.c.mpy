{
  "module_name": "ip_vs_proto_udp.c",
  "hash_id": "8f341a71c411904b7a0d270b960cef79d58ddd3b30400bc6d1762e2bc5d3971c",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_proto_udp.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/udp.h>\n#include <linux/indirect_call_wrapper.h>\n\n#include <net/ip_vs.h>\n#include <net/ip.h>\n#include <net/ip6_checksum.h>\n\nstatic int\nudp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp);\n\nstatic int\nudp_conn_schedule(struct netns_ipvs *ipvs, int af, struct sk_buff *skb,\n\t\t  struct ip_vs_proto_data *pd,\n\t\t  int *verdict, struct ip_vs_conn **cpp,\n\t\t  struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_service *svc;\n\tstruct udphdr _udph, *uh;\n\t__be16 _ports[2], *ports = NULL;\n\n\tif (likely(!ip_vs_iph_icmp(iph))) {\n\t\t \n\t\tuh = skb_header_pointer(skb, iph->len, sizeof(_udph), &_udph);\n\t\tif (uh)\n\t\t\tports = &uh->source;\n\t} else {\n\t\tports = skb_header_pointer(\n\t\t\tskb, iph->len, sizeof(_ports), &_ports);\n\t}\n\n\tif (!ports) {\n\t\t*verdict = NF_DROP;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ip_vs_iph_inverse(iph)))\n\t\tsvc = ip_vs_service_find(ipvs, af, skb->mark, iph->protocol,\n\t\t\t\t\t &iph->daddr, ports[1]);\n\telse\n\t\tsvc = ip_vs_service_find(ipvs, af, skb->mark, iph->protocol,\n\t\t\t\t\t &iph->saddr, ports[0]);\n\n\tif (svc) {\n\t\tint ignored;\n\n\t\tif (ip_vs_todrop(ipvs)) {\n\t\t\t \n\t\t\t*verdict = NF_DROP;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\t*cpp = ip_vs_schedule(svc, skb, pd, &ignored, iph);\n\t\tif (!*cpp && ignored <= 0) {\n\t\t\tif (!ignored)\n\t\t\t\t*verdict = ip_vs_leave(svc, skb, pd, iph);\n\t\t\telse\n\t\t\t\t*verdict = NF_DROP;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\treturn 1;\n}\n\n\nstatic inline void\nudp_fast_csum_update(int af, struct udphdr *uhdr,\n\t\t     const union nf_inet_addr *oldip,\n\t\t     const union nf_inet_addr *newip,\n\t\t     __be16 oldport, __be16 newport)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\tuhdr->check =\n\t\t\tcsum_fold(ip_vs_check_diff16(oldip->ip6, newip->ip6,\n\t\t\t\t\t ip_vs_check_diff2(oldport, newport,\n\t\t\t\t\t\t~csum_unfold(uhdr->check))));\n\telse\n#endif\n\t\tuhdr->check =\n\t\t\tcsum_fold(ip_vs_check_diff4(oldip->ip, newip->ip,\n\t\t\t\t\t ip_vs_check_diff2(oldport, newport,\n\t\t\t\t\t\t~csum_unfold(uhdr->check))));\n\tif (!uhdr->check)\n\t\tuhdr->check = CSUM_MANGLED_0;\n}\n\nstatic inline void\nudp_partial_csum_update(int af, struct udphdr *uhdr,\n\t\t     const union nf_inet_addr *oldip,\n\t\t     const union nf_inet_addr *newip,\n\t\t     __be16 oldlen, __be16 newlen)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\tuhdr->check =\n\t\t\t~csum_fold(ip_vs_check_diff16(oldip->ip6, newip->ip6,\n\t\t\t\t\t ip_vs_check_diff2(oldlen, newlen,\n\t\t\t\t\t\tcsum_unfold(uhdr->check))));\n\telse\n#endif\n\tuhdr->check =\n\t\t~csum_fold(ip_vs_check_diff4(oldip->ip, newip->ip,\n\t\t\t\tip_vs_check_diff2(oldlen, newlen,\n\t\t\t\t\t\tcsum_unfold(uhdr->check))));\n}\n\n\nINDIRECT_CALLABLE_SCOPE int\nudp_snat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t struct ip_vs_conn *cp, struct ip_vs_iphdr *iph)\n{\n\tstruct udphdr *udph;\n\tunsigned int udphoff = iph->len;\n\tbool payload_csum = false;\n\tint oldlen;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (cp->af == AF_INET6 && iph->fragoffs)\n\t\treturn 1;\n#endif\n\toldlen = skb->len - udphoff;\n\n\t \n\tif (skb_ensure_writable(skb, udphoff + sizeof(*udph)))\n\t\treturn 0;\n\n\tif (unlikely(cp->app != NULL)) {\n\t\tint ret;\n\n\t\t \n\t\tif (!udp_csum_check(cp->af, skb, pp))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!(ret = ip_vs_app_pkt_out(cp, skb, iph)))\n\t\t\treturn 0;\n\t\t \n\t\tif (ret == 1)\n\t\t\toldlen = skb->len - udphoff;\n\t\telse\n\t\t\tpayload_csum = true;\n\t}\n\n\tudph = (void *)skb_network_header(skb) + udphoff;\n\tudph->source = cp->vport;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tudp_partial_csum_update(cp->af, udph, &cp->daddr, &cp->vaddr,\n\t\t\t\t\thtons(oldlen),\n\t\t\t\t\thtons(skb->len - udphoff));\n\t} else if (!payload_csum && (udph->check != 0)) {\n\t\t \n\t\tudp_fast_csum_update(cp->af, udph, &cp->daddr, &cp->vaddr,\n\t\t\t\t     cp->dport, cp->vport);\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\t\tskb->ip_summed = cp->app ?\n\t\t\t\t\t CHECKSUM_UNNECESSARY : CHECKSUM_NONE;\n\t} else {\n\t\t \n\t\tudph->check = 0;\n\t\tskb->csum = skb_checksum(skb, udphoff, skb->len - udphoff, 0);\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (cp->af == AF_INET6)\n\t\t\tudph->check = csum_ipv6_magic(&cp->vaddr.in6,\n\t\t\t\t\t\t      &cp->caddr.in6,\n\t\t\t\t\t\t      skb->len - udphoff,\n\t\t\t\t\t\t      cp->protocol, skb->csum);\n\t\telse\n#endif\n\t\t\tudph->check = csum_tcpudp_magic(cp->vaddr.ip,\n\t\t\t\t\t\t\tcp->caddr.ip,\n\t\t\t\t\t\t\tskb->len - udphoff,\n\t\t\t\t\t\t\tcp->protocol,\n\t\t\t\t\t\t\tskb->csum);\n\t\tif (udph->check == 0)\n\t\t\tudph->check = CSUM_MANGLED_0;\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tIP_VS_DBG(11, \"O-pkt: %s O-csum=%d (+%zd)\\n\",\n\t\t\t  pp->name, udph->check,\n\t\t\t  (char*)&(udph->check) - (char*)udph);\n\t}\n\treturn 1;\n}\n\n\nstatic int\nudp_dnat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t struct ip_vs_conn *cp, struct ip_vs_iphdr *iph)\n{\n\tstruct udphdr *udph;\n\tunsigned int udphoff = iph->len;\n\tbool payload_csum = false;\n\tint oldlen;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (cp->af == AF_INET6 && iph->fragoffs)\n\t\treturn 1;\n#endif\n\toldlen = skb->len - udphoff;\n\n\t \n\tif (skb_ensure_writable(skb, udphoff + sizeof(*udph)))\n\t\treturn 0;\n\n\tif (unlikely(cp->app != NULL)) {\n\t\tint ret;\n\n\t\t \n\t\tif (!udp_csum_check(cp->af, skb, pp))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!(ret = ip_vs_app_pkt_in(cp, skb, iph)))\n\t\t\treturn 0;\n\t\t \n\t\tif (ret == 1)\n\t\t\toldlen = skb->len - udphoff;\n\t\telse\n\t\t\tpayload_csum = true;\n\t}\n\n\tudph = (void *)skb_network_header(skb) + udphoff;\n\tudph->dest = cp->dport;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tudp_partial_csum_update(cp->af, udph, &cp->vaddr, &cp->daddr,\n\t\t\t\t\thtons(oldlen),\n\t\t\t\t\thtons(skb->len - udphoff));\n\t} else if (!payload_csum && (udph->check != 0)) {\n\t\t \n\t\tudp_fast_csum_update(cp->af, udph, &cp->vaddr, &cp->daddr,\n\t\t\t\t     cp->vport, cp->dport);\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\t\tskb->ip_summed = cp->app ?\n\t\t\t\t\t CHECKSUM_UNNECESSARY : CHECKSUM_NONE;\n\t} else {\n\t\t \n\t\tudph->check = 0;\n\t\tskb->csum = skb_checksum(skb, udphoff, skb->len - udphoff, 0);\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (cp->af == AF_INET6)\n\t\t\tudph->check = csum_ipv6_magic(&cp->caddr.in6,\n\t\t\t\t\t\t      &cp->daddr.in6,\n\t\t\t\t\t\t      skb->len - udphoff,\n\t\t\t\t\t\t      cp->protocol, skb->csum);\n\t\telse\n#endif\n\t\t\tudph->check = csum_tcpudp_magic(cp->caddr.ip,\n\t\t\t\t\t\t\tcp->daddr.ip,\n\t\t\t\t\t\t\tskb->len - udphoff,\n\t\t\t\t\t\t\tcp->protocol,\n\t\t\t\t\t\t\tskb->csum);\n\t\tif (udph->check == 0)\n\t\t\tudph->check = CSUM_MANGLED_0;\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\treturn 1;\n}\n\n\nstatic int\nudp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)\n{\n\tstruct udphdr _udph, *uh;\n\tunsigned int udphoff;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\tudphoff = sizeof(struct ipv6hdr);\n\telse\n#endif\n\t\tudphoff = ip_hdrlen(skb);\n\n\tuh = skb_header_pointer(skb, udphoff, sizeof(_udph), &_udph);\n\tif (uh == NULL)\n\t\treturn 0;\n\n\tif (uh->check != 0) {\n\t\tswitch (skb->ip_summed) {\n\t\tcase CHECKSUM_NONE:\n\t\t\tskb->csum = skb_checksum(skb, udphoff,\n\t\t\t\t\t\t skb->len - udphoff, 0);\n\t\t\tfallthrough;\n\t\tcase CHECKSUM_COMPLETE:\n#ifdef CONFIG_IP_VS_IPV6\n\t\t\tif (af == AF_INET6) {\n\t\t\t\tif (csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t    skb->len - udphoff,\n\t\t\t\t\t\t    ipv6_hdr(skb)->nexthdr,\n\t\t\t\t\t\t    skb->csum)) {\n\t\t\t\t\tIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\n\t\t\t\t\t\t\t \"Failed checksum for\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else\n#endif\n\t\t\t\tif (csum_tcpudp_magic(ip_hdr(skb)->saddr,\n\t\t\t\t\t\t      ip_hdr(skb)->daddr,\n\t\t\t\t\t\t      skb->len - udphoff,\n\t\t\t\t\t\t      ip_hdr(skb)->protocol,\n\t\t\t\t\t\t      skb->csum)) {\n\t\t\t\t\tIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\n\t\t\t\t\t\t\t \"Failed checksum for\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic inline __u16 udp_app_hashkey(__be16 port)\n{\n\treturn (((__force u16)port >> UDP_APP_TAB_BITS) ^ (__force u16)port)\n\t\t& UDP_APP_TAB_MASK;\n}\n\n\nstatic int udp_register_app(struct netns_ipvs *ipvs, struct ip_vs_app *inc)\n{\n\tstruct ip_vs_app *i;\n\t__u16 hash;\n\t__be16 port = inc->port;\n\tint ret = 0;\n\tstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(ipvs, IPPROTO_UDP);\n\n\thash = udp_app_hashkey(port);\n\n\tlist_for_each_entry(i, &ipvs->udp_apps[hash], p_list) {\n\t\tif (i->port == port) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlist_add_rcu(&inc->p_list, &ipvs->udp_apps[hash]);\n\tatomic_inc(&pd->appcnt);\n\n  out:\n\treturn ret;\n}\n\n\nstatic void\nudp_unregister_app(struct netns_ipvs *ipvs, struct ip_vs_app *inc)\n{\n\tstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(ipvs, IPPROTO_UDP);\n\n\tatomic_dec(&pd->appcnt);\n\tlist_del_rcu(&inc->p_list);\n}\n\n\nstatic int udp_app_conn_bind(struct ip_vs_conn *cp)\n{\n\tstruct netns_ipvs *ipvs = cp->ipvs;\n\tint hash;\n\tstruct ip_vs_app *inc;\n\tint result = 0;\n\n\t \n\tif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)\n\t\treturn 0;\n\n\t \n\thash = udp_app_hashkey(cp->vport);\n\n\tlist_for_each_entry_rcu(inc, &ipvs->udp_apps[hash], p_list) {\n\t\tif (inc->port == cp->vport) {\n\t\t\tif (unlikely(!ip_vs_app_inc_get(inc)))\n\t\t\t\tbreak;\n\n\t\t\tIP_VS_DBG_BUF(9, \"%s(): Binding conn %s:%u->\"\n\t\t\t\t      \"%s:%u to app %s on port %u\\n\",\n\t\t\t\t      __func__,\n\t\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr),\n\t\t\t\t      ntohs(cp->cport),\n\t\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr),\n\t\t\t\t      ntohs(cp->vport),\n\t\t\t\t      inc->name, ntohs(inc->port));\n\n\t\t\tcp->app = inc;\n\t\t\tif (inc->init_conn)\n\t\t\t\tresult = inc->init_conn(inc, cp);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n\nstatic const int udp_timeouts[IP_VS_UDP_S_LAST+1] = {\n\t[IP_VS_UDP_S_NORMAL]\t\t=\t5*60*HZ,\n\t[IP_VS_UDP_S_LAST]\t\t=\t2*HZ,\n};\n\nstatic const char *const udp_state_name_table[IP_VS_UDP_S_LAST+1] = {\n\t[IP_VS_UDP_S_NORMAL]\t\t=\t\"UDP\",\n\t[IP_VS_UDP_S_LAST]\t\t=\t\"BUG!\",\n};\n\nstatic const char * udp_state_name(int state)\n{\n\tif (state >= IP_VS_UDP_S_LAST)\n\t\treturn \"ERR!\";\n\treturn udp_state_name_table[state] ? udp_state_name_table[state] : \"?\";\n}\n\nstatic void\nudp_state_transition(struct ip_vs_conn *cp, int direction,\n\t\t     const struct sk_buff *skb,\n\t\t     struct ip_vs_proto_data *pd)\n{\n\tif (unlikely(!pd)) {\n\t\tpr_err(\"UDP no ns data\\n\");\n\t\treturn;\n\t}\n\n\tcp->timeout = pd->timeout_table[IP_VS_UDP_S_NORMAL];\n\tif (direction == IP_VS_DIR_OUTPUT)\n\t\tip_vs_control_assure_ct(cp);\n}\n\nstatic int __udp_init(struct netns_ipvs *ipvs, struct ip_vs_proto_data *pd)\n{\n\tip_vs_init_hash_table(ipvs->udp_apps, UDP_APP_TAB_SIZE);\n\tpd->timeout_table = ip_vs_create_timeout_table((int *)udp_timeouts,\n\t\t\t\t\t\t\tsizeof(udp_timeouts));\n\tif (!pd->timeout_table)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __udp_exit(struct netns_ipvs *ipvs, struct ip_vs_proto_data *pd)\n{\n\tkfree(pd->timeout_table);\n}\n\n\nstruct ip_vs_protocol ip_vs_protocol_udp = {\n\t.name =\t\t\t\"UDP\",\n\t.protocol =\t\tIPPROTO_UDP,\n\t.num_states =\t\tIP_VS_UDP_S_LAST,\n\t.dont_defrag =\t\t0,\n\t.init =\t\t\tNULL,\n\t.exit =\t\t\tNULL,\n\t.init_netns =\t\t__udp_init,\n\t.exit_netns =\t\t__udp_exit,\n\t.conn_schedule =\tudp_conn_schedule,\n\t.conn_in_get =\t\tip_vs_conn_in_get_proto,\n\t.conn_out_get =\t\tip_vs_conn_out_get_proto,\n\t.snat_handler =\t\tudp_snat_handler,\n\t.dnat_handler =\t\tudp_dnat_handler,\n\t.state_transition =\tudp_state_transition,\n\t.state_name =\t\tudp_state_name,\n\t.register_app =\t\tudp_register_app,\n\t.unregister_app =\tudp_unregister_app,\n\t.app_conn_bind =\tudp_app_conn_bind,\n\t.debug_packet =\t\tip_vs_tcpudp_debug_packet,\n\t.timeout_change =\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}