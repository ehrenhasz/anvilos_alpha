{
  "module_name": "ip_vs_proto.c",
  "hash_id": "8e94e287b2cccaa746afd61740a7662c1377e57011383277f9234be6d0a657b7",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_proto.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/gfp.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <net/protocol.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n\n#include <net/ip_vs.h>\n\n\n \n\n#define IP_VS_PROTO_TAB_SIZE\t\t32\t \n#define IP_VS_PROTO_HASH(proto)\t\t((proto) & (IP_VS_PROTO_TAB_SIZE-1))\n\nstatic struct ip_vs_protocol *ip_vs_proto_table[IP_VS_PROTO_TAB_SIZE];\n\n \nstatic const char *ip_vs_ctpl_state_name_table[IP_VS_CTPL_S_LAST] = {\n\t[IP_VS_CTPL_S_NONE]\t\t\t= \"NONE\",\n\t[IP_VS_CTPL_S_ASSURED]\t\t\t= \"ASSURED\",\n};\n\n \nstatic int __used __init register_ip_vs_protocol(struct ip_vs_protocol *pp)\n{\n\tunsigned int hash = IP_VS_PROTO_HASH(pp->protocol);\n\n\tpp->next = ip_vs_proto_table[hash];\n\tip_vs_proto_table[hash] = pp;\n\n\tif (pp->init != NULL)\n\t\tpp->init(pp);\n\n\treturn 0;\n}\n\n \nstatic int\nregister_ip_vs_proto_netns(struct netns_ipvs *ipvs, struct ip_vs_protocol *pp)\n{\n\tunsigned int hash = IP_VS_PROTO_HASH(pp->protocol);\n\tstruct ip_vs_proto_data *pd =\n\t\t\tkzalloc(sizeof(struct ip_vs_proto_data), GFP_KERNEL);\n\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tpd->pp = pp;\t \n\tpd->next = ipvs->proto_data_table[hash];\n\tipvs->proto_data_table[hash] = pd;\n\tatomic_set(&pd->appcnt, 0);\t \n\n\tif (pp->init_netns != NULL) {\n\t\tint ret = pp->init_netns(ipvs, pd);\n\t\tif (ret) {\n\t\t\t \n\t\t\tipvs->proto_data_table[hash] = pd->next;\n\t\t\tkfree(pd);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int unregister_ip_vs_protocol(struct ip_vs_protocol *pp)\n{\n\tstruct ip_vs_protocol **pp_p;\n\tunsigned int hash = IP_VS_PROTO_HASH(pp->protocol);\n\n\tpp_p = &ip_vs_proto_table[hash];\n\tfor (; *pp_p; pp_p = &(*pp_p)->next) {\n\t\tif (*pp_p == pp) {\n\t\t\t*pp_p = pp->next;\n\t\t\tif (pp->exit != NULL)\n\t\t\t\tpp->exit(pp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ESRCH;\n}\n\n \nstatic int\nunregister_ip_vs_proto_netns(struct netns_ipvs *ipvs, struct ip_vs_proto_data *pd)\n{\n\tstruct ip_vs_proto_data **pd_p;\n\tunsigned int hash = IP_VS_PROTO_HASH(pd->pp->protocol);\n\n\tpd_p = &ipvs->proto_data_table[hash];\n\tfor (; *pd_p; pd_p = &(*pd_p)->next) {\n\t\tif (*pd_p == pd) {\n\t\t\t*pd_p = pd->next;\n\t\t\tif (pd->pp->exit_netns != NULL)\n\t\t\t\tpd->pp->exit_netns(ipvs, pd);\n\t\t\tkfree(pd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ESRCH;\n}\n\n \nstruct ip_vs_protocol * ip_vs_proto_get(unsigned short proto)\n{\n\tstruct ip_vs_protocol *pp;\n\tunsigned int hash = IP_VS_PROTO_HASH(proto);\n\n\tfor (pp = ip_vs_proto_table[hash]; pp; pp = pp->next) {\n\t\tif (pp->protocol == proto)\n\t\t\treturn pp;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(ip_vs_proto_get);\n\n \nstruct ip_vs_proto_data *\nip_vs_proto_data_get(struct netns_ipvs *ipvs, unsigned short proto)\n{\n\tstruct ip_vs_proto_data *pd;\n\tunsigned int hash = IP_VS_PROTO_HASH(proto);\n\n\tfor (pd = ipvs->proto_data_table[hash]; pd; pd = pd->next) {\n\t\tif (pd->pp->protocol == proto)\n\t\t\treturn pd;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(ip_vs_proto_data_get);\n\n \nvoid ip_vs_protocol_timeout_change(struct netns_ipvs *ipvs, int flags)\n{\n\tstruct ip_vs_proto_data *pd;\n\tint i;\n\n\tfor (i = 0; i < IP_VS_PROTO_TAB_SIZE; i++) {\n\t\tfor (pd = ipvs->proto_data_table[i]; pd; pd = pd->next) {\n\t\t\tif (pd->pp->timeout_change)\n\t\t\t\tpd->pp->timeout_change(pd, flags);\n\t\t}\n\t}\n}\n\n\nint *\nip_vs_create_timeout_table(int *table, int size)\n{\n\treturn kmemdup(table, size, GFP_KERNEL);\n}\n\n\nconst char *ip_vs_state_name(const struct ip_vs_conn *cp)\n{\n\tunsigned int state = cp->state;\n\tstruct ip_vs_protocol *pp;\n\n\tif (cp->flags & IP_VS_CONN_F_TEMPLATE) {\n\n\t\tif (state >= IP_VS_CTPL_S_LAST)\n\t\t\treturn \"ERR!\";\n\t\treturn ip_vs_ctpl_state_name_table[state] ? : \"?\";\n\t}\n\tpp = ip_vs_proto_get(cp->protocol);\n\tif (pp == NULL || pp->state_name == NULL)\n\t\treturn (cp->protocol == IPPROTO_IP) ? \"NONE\" : \"ERR!\";\n\treturn pp->state_name(state);\n}\n\n\nstatic void\nip_vs_tcpudp_debug_packet_v4(struct ip_vs_protocol *pp,\n\t\t\t     const struct sk_buff *skb,\n\t\t\t     int offset,\n\t\t\t     const char *msg)\n{\n\tchar buf[128];\n\tstruct iphdr _iph, *ih;\n\n\tih = skb_header_pointer(skb, offset, sizeof(_iph), &_iph);\n\tif (ih == NULL)\n\t\tsprintf(buf, \"TRUNCATED\");\n\telse if (ih->frag_off & htons(IP_OFFSET))\n\t\tsprintf(buf, \"%pI4->%pI4 frag\", &ih->saddr, &ih->daddr);\n\telse {\n\t\t__be16 _ports[2], *pptr;\n\n\t\tpptr = skb_header_pointer(skb, offset + ih->ihl*4,\n\t\t\t\t\t  sizeof(_ports), _ports);\n\t\tif (pptr == NULL)\n\t\t\tsprintf(buf, \"TRUNCATED %pI4->%pI4\",\n\t\t\t\t&ih->saddr, &ih->daddr);\n\t\telse\n\t\t\tsprintf(buf, \"%pI4:%u->%pI4:%u\",\n\t\t\t\t&ih->saddr, ntohs(pptr[0]),\n\t\t\t\t&ih->daddr, ntohs(pptr[1]));\n\t}\n\n\tpr_debug(\"%s: %s %s\\n\", msg, pp->name, buf);\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nstatic void\nip_vs_tcpudp_debug_packet_v6(struct ip_vs_protocol *pp,\n\t\t\t     const struct sk_buff *skb,\n\t\t\t     int offset,\n\t\t\t     const char *msg)\n{\n\tchar buf[192];\n\tstruct ipv6hdr _iph, *ih;\n\n\tih = skb_header_pointer(skb, offset, sizeof(_iph), &_iph);\n\tif (ih == NULL)\n\t\tsprintf(buf, \"TRUNCATED\");\n\telse if (ih->nexthdr == IPPROTO_FRAGMENT)\n\t\tsprintf(buf, \"%pI6c->%pI6c frag\", &ih->saddr, &ih->daddr);\n\telse {\n\t\t__be16 _ports[2], *pptr;\n\n\t\tpptr = skb_header_pointer(skb, offset + sizeof(struct ipv6hdr),\n\t\t\t\t\t  sizeof(_ports), _ports);\n\t\tif (pptr == NULL)\n\t\t\tsprintf(buf, \"TRUNCATED %pI6c->%pI6c\",\n\t\t\t\t&ih->saddr, &ih->daddr);\n\t\telse\n\t\t\tsprintf(buf, \"%pI6c:%u->%pI6c:%u\",\n\t\t\t\t&ih->saddr, ntohs(pptr[0]),\n\t\t\t\t&ih->daddr, ntohs(pptr[1]));\n\t}\n\n\tpr_debug(\"%s: %s %s\\n\", msg, pp->name, buf);\n}\n#endif\n\n\nvoid\nip_vs_tcpudp_debug_packet(int af, struct ip_vs_protocol *pp,\n\t\t\t  const struct sk_buff *skb,\n\t\t\t  int offset,\n\t\t\t  const char *msg)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\tip_vs_tcpudp_debug_packet_v6(pp, skb, offset, msg);\n\telse\n#endif\n\t\tip_vs_tcpudp_debug_packet_v4(pp, skb, offset, msg);\n}\n\n \nint __net_init ip_vs_protocol_net_init(struct netns_ipvs *ipvs)\n{\n\tint i, ret;\n\tstatic struct ip_vs_protocol *protos[] = {\n#ifdef CONFIG_IP_VS_PROTO_TCP\n        &ip_vs_protocol_tcp,\n#endif\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\t&ip_vs_protocol_udp,\n#endif\n#ifdef CONFIG_IP_VS_PROTO_SCTP\n\t&ip_vs_protocol_sctp,\n#endif\n#ifdef CONFIG_IP_VS_PROTO_AH\n\t&ip_vs_protocol_ah,\n#endif\n#ifdef CONFIG_IP_VS_PROTO_ESP\n\t&ip_vs_protocol_esp,\n#endif\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(protos); i++) {\n\t\tret = register_ip_vs_proto_netns(ipvs, protos[i]);\n\t\tif (ret < 0)\n\t\t\tgoto cleanup;\n\t}\n\treturn 0;\n\ncleanup:\n\tip_vs_protocol_net_cleanup(ipvs);\n\treturn ret;\n}\n\nvoid __net_exit ip_vs_protocol_net_cleanup(struct netns_ipvs *ipvs)\n{\n\tstruct ip_vs_proto_data *pd;\n\tint i;\n\n\t \n\tfor (i = 0; i < IP_VS_PROTO_TAB_SIZE; i++) {\n\t\twhile ((pd = ipvs->proto_data_table[i]) != NULL)\n\t\t\tunregister_ip_vs_proto_netns(ipvs, pd);\n\t}\n}\n\nint __init ip_vs_protocol_init(void)\n{\n\tchar protocols[64];\n#define REGISTER_PROTOCOL(p)\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tregister_ip_vs_protocol(p);\t\\\n\t\tstrcat(protocols, \", \");\t\\\n\t\tstrcat(protocols, (p)->name);\t\\\n\t} while (0)\n\n\tprotocols[0] = '\\0';\n\tprotocols[2] = '\\0';\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\tREGISTER_PROTOCOL(&ip_vs_protocol_tcp);\n#endif\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\tREGISTER_PROTOCOL(&ip_vs_protocol_udp);\n#endif\n#ifdef CONFIG_IP_VS_PROTO_SCTP\n\tREGISTER_PROTOCOL(&ip_vs_protocol_sctp);\n#endif\n#ifdef CONFIG_IP_VS_PROTO_AH\n\tREGISTER_PROTOCOL(&ip_vs_protocol_ah);\n#endif\n#ifdef CONFIG_IP_VS_PROTO_ESP\n\tREGISTER_PROTOCOL(&ip_vs_protocol_esp);\n#endif\n\tpr_info(\"Registered protocols (%s)\\n\", &protocols[2]);\n\n\treturn 0;\n}\n\n\nvoid ip_vs_protocol_cleanup(void)\n{\n\tstruct ip_vs_protocol *pp;\n\tint i;\n\n\t \n\tfor (i = 0; i < IP_VS_PROTO_TAB_SIZE; i++) {\n\t\twhile ((pp = ip_vs_proto_table[i]) != NULL)\n\t\t\tunregister_ip_vs_protocol(pp);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}