{
  "module_name": "ip_vs_core.c",
  "hash_id": "ceda5d47fbf8b9cd7983d8920794fa2d3ae8e7f8a6e365bfef377c639aff75fa",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_core.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/sctp.h>\n#include <linux/icmp.h>\n#include <linux/slab.h>\n\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/icmp.h>                    \n#include <net/gue.h>\n#include <net/gre.h>\n#include <net/route.h>\n#include <net/ip6_checksum.h>\n#include <net/netns/generic.h>\t\t \n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n\n#ifdef CONFIG_IP_VS_IPV6\n#include <net/ipv6.h>\n#include <linux/netfilter_ipv6.h>\n#include <net/ip6_route.h>\n#endif\n\n#include <net/ip_vs.h>\n#include <linux/indirect_call_wrapper.h>\n\n\nEXPORT_SYMBOL(register_ip_vs_scheduler);\nEXPORT_SYMBOL(unregister_ip_vs_scheduler);\nEXPORT_SYMBOL(ip_vs_proto_name);\nEXPORT_SYMBOL(ip_vs_conn_new);\nEXPORT_SYMBOL(ip_vs_conn_in_get);\nEXPORT_SYMBOL(ip_vs_conn_out_get);\n#ifdef CONFIG_IP_VS_PROTO_TCP\nEXPORT_SYMBOL(ip_vs_tcp_conn_listen);\n#endif\nEXPORT_SYMBOL(ip_vs_conn_put);\n#ifdef CONFIG_IP_VS_DEBUG\nEXPORT_SYMBOL(ip_vs_get_debug_level);\n#endif\nEXPORT_SYMBOL(ip_vs_new_conn_out);\n\n#if defined(CONFIG_IP_VS_PROTO_TCP) && defined(CONFIG_IP_VS_PROTO_UDP)\n#define SNAT_CALL(f, ...) \\\n\tINDIRECT_CALL_2(f, tcp_snat_handler, udp_snat_handler, __VA_ARGS__)\n#elif defined(CONFIG_IP_VS_PROTO_TCP)\n#define SNAT_CALL(f, ...) INDIRECT_CALL_1(f, tcp_snat_handler, __VA_ARGS__)\n#elif defined(CONFIG_IP_VS_PROTO_UDP)\n#define SNAT_CALL(f, ...) INDIRECT_CALL_1(f, udp_snat_handler, __VA_ARGS__)\n#else\n#define SNAT_CALL(f, ...) f(__VA_ARGS__)\n#endif\n\nstatic unsigned int ip_vs_net_id __read_mostly;\n \nstatic atomic_t ipvs_netns_cnt = ATOMIC_INIT(0);\n\n \n#define icmp_id(icmph)          (((icmph)->un).echo.id)\n#define icmpv6_id(icmph)        (icmph->icmp6_dataun.u_echo.identifier)\n\nconst char *ip_vs_proto_name(unsigned int proto)\n{\n\tstatic char buf[20];\n\n\tswitch (proto) {\n\tcase IPPROTO_IP:\n\t\treturn \"IP\";\n\tcase IPPROTO_UDP:\n\t\treturn \"UDP\";\n\tcase IPPROTO_TCP:\n\t\treturn \"TCP\";\n\tcase IPPROTO_SCTP:\n\t\treturn \"SCTP\";\n\tcase IPPROTO_ICMP:\n\t\treturn \"ICMP\";\n#ifdef CONFIG_IP_VS_IPV6\n\tcase IPPROTO_ICMPV6:\n\t\treturn \"ICMPv6\";\n#endif\n\tdefault:\n\t\tsprintf(buf, \"IP_%u\", proto);\n\t\treturn buf;\n\t}\n}\n\nvoid ip_vs_init_hash_table(struct list_head *table, int rows)\n{\n\twhile (--rows >= 0)\n\t\tINIT_LIST_HEAD(&table[rows]);\n}\n\nstatic inline void\nip_vs_in_stats(struct ip_vs_conn *cp, struct sk_buff *skb)\n{\n\tstruct ip_vs_dest *dest = cp->dest;\n\tstruct netns_ipvs *ipvs = cp->ipvs;\n\n\tif (dest && (dest->flags & IP_VS_DEST_F_AVAILABLE)) {\n\t\tstruct ip_vs_cpu_stats *s;\n\t\tstruct ip_vs_service *svc;\n\n\t\tlocal_bh_disable();\n\n\t\ts = this_cpu_ptr(dest->stats.cpustats);\n\t\tu64_stats_update_begin(&s->syncp);\n\t\tu64_stats_inc(&s->cnt.inpkts);\n\t\tu64_stats_add(&s->cnt.inbytes, skb->len);\n\t\tu64_stats_update_end(&s->syncp);\n\n\t\tsvc = rcu_dereference(dest->svc);\n\t\ts = this_cpu_ptr(svc->stats.cpustats);\n\t\tu64_stats_update_begin(&s->syncp);\n\t\tu64_stats_inc(&s->cnt.inpkts);\n\t\tu64_stats_add(&s->cnt.inbytes, skb->len);\n\t\tu64_stats_update_end(&s->syncp);\n\n\t\ts = this_cpu_ptr(ipvs->tot_stats->s.cpustats);\n\t\tu64_stats_update_begin(&s->syncp);\n\t\tu64_stats_inc(&s->cnt.inpkts);\n\t\tu64_stats_add(&s->cnt.inbytes, skb->len);\n\t\tu64_stats_update_end(&s->syncp);\n\n\t\tlocal_bh_enable();\n\t}\n}\n\n\nstatic inline void\nip_vs_out_stats(struct ip_vs_conn *cp, struct sk_buff *skb)\n{\n\tstruct ip_vs_dest *dest = cp->dest;\n\tstruct netns_ipvs *ipvs = cp->ipvs;\n\n\tif (dest && (dest->flags & IP_VS_DEST_F_AVAILABLE)) {\n\t\tstruct ip_vs_cpu_stats *s;\n\t\tstruct ip_vs_service *svc;\n\n\t\tlocal_bh_disable();\n\n\t\ts = this_cpu_ptr(dest->stats.cpustats);\n\t\tu64_stats_update_begin(&s->syncp);\n\t\tu64_stats_inc(&s->cnt.outpkts);\n\t\tu64_stats_add(&s->cnt.outbytes, skb->len);\n\t\tu64_stats_update_end(&s->syncp);\n\n\t\tsvc = rcu_dereference(dest->svc);\n\t\ts = this_cpu_ptr(svc->stats.cpustats);\n\t\tu64_stats_update_begin(&s->syncp);\n\t\tu64_stats_inc(&s->cnt.outpkts);\n\t\tu64_stats_add(&s->cnt.outbytes, skb->len);\n\t\tu64_stats_update_end(&s->syncp);\n\n\t\ts = this_cpu_ptr(ipvs->tot_stats->s.cpustats);\n\t\tu64_stats_update_begin(&s->syncp);\n\t\tu64_stats_inc(&s->cnt.outpkts);\n\t\tu64_stats_add(&s->cnt.outbytes, skb->len);\n\t\tu64_stats_update_end(&s->syncp);\n\n\t\tlocal_bh_enable();\n\t}\n}\n\n\nstatic inline void\nip_vs_conn_stats(struct ip_vs_conn *cp, struct ip_vs_service *svc)\n{\n\tstruct netns_ipvs *ipvs = svc->ipvs;\n\tstruct ip_vs_cpu_stats *s;\n\n\tlocal_bh_disable();\n\n\ts = this_cpu_ptr(cp->dest->stats.cpustats);\n\tu64_stats_update_begin(&s->syncp);\n\tu64_stats_inc(&s->cnt.conns);\n\tu64_stats_update_end(&s->syncp);\n\n\ts = this_cpu_ptr(svc->stats.cpustats);\n\tu64_stats_update_begin(&s->syncp);\n\tu64_stats_inc(&s->cnt.conns);\n\tu64_stats_update_end(&s->syncp);\n\n\ts = this_cpu_ptr(ipvs->tot_stats->s.cpustats);\n\tu64_stats_update_begin(&s->syncp);\n\tu64_stats_inc(&s->cnt.conns);\n\tu64_stats_update_end(&s->syncp);\n\n\tlocal_bh_enable();\n}\n\n\nstatic inline void\nip_vs_set_state(struct ip_vs_conn *cp, int direction,\n\t\tconst struct sk_buff *skb,\n\t\tstruct ip_vs_proto_data *pd)\n{\n\tif (likely(pd->pp->state_transition))\n\t\tpd->pp->state_transition(cp, direction, skb, pd);\n}\n\nstatic inline int\nip_vs_conn_fill_param_persist(const struct ip_vs_service *svc,\n\t\t\t      struct sk_buff *skb, int protocol,\n\t\t\t      const union nf_inet_addr *caddr, __be16 cport,\n\t\t\t      const union nf_inet_addr *vaddr, __be16 vport,\n\t\t\t      struct ip_vs_conn_param *p)\n{\n\tip_vs_conn_fill_param(svc->ipvs, svc->af, protocol, caddr, cport, vaddr,\n\t\t\t      vport, p);\n\tp->pe = rcu_dereference(svc->pe);\n\tif (p->pe && p->pe->fill_param)\n\t\treturn p->pe->fill_param(p, skb);\n\n\treturn 0;\n}\n\n \nstatic struct ip_vs_conn *\nip_vs_sched_persist(struct ip_vs_service *svc,\n\t\t    struct sk_buff *skb, __be16 src_port, __be16 dst_port,\n\t\t    int *ignored, struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_conn *cp = NULL;\n\tstruct ip_vs_dest *dest;\n\tstruct ip_vs_conn *ct;\n\t__be16 dport = 0;\t\t \n\tunsigned int flags;\n\tstruct ip_vs_conn_param param;\n\tconst union nf_inet_addr fwmark = { .ip = htonl(svc->fwmark) };\n\tunion nf_inet_addr snet;\t \n\tconst union nf_inet_addr *src_addr, *dst_addr;\n\n\tif (likely(!ip_vs_iph_inverse(iph))) {\n\t\tsrc_addr = &iph->saddr;\n\t\tdst_addr = &iph->daddr;\n\t} else {\n\t\tsrc_addr = &iph->daddr;\n\t\tdst_addr = &iph->saddr;\n\t}\n\n\n\t \n#ifdef CONFIG_IP_VS_IPV6\n\tif (svc->af == AF_INET6)\n\t\tipv6_addr_prefix(&snet.in6, &src_addr->in6,\n\t\t\t\t (__force __u32) svc->netmask);\n\telse\n#endif\n\t\tsnet.ip = src_addr->ip & svc->netmask;\n\n\tIP_VS_DBG_BUF(6, \"p-schedule: src %s:%u dest %s:%u \"\n\t\t      \"mnet %s\\n\",\n\t\t      IP_VS_DBG_ADDR(svc->af, src_addr), ntohs(src_port),\n\t\t      IP_VS_DBG_ADDR(svc->af, dst_addr), ntohs(dst_port),\n\t\t      IP_VS_DBG_ADDR(svc->af, &snet));\n\n\t \n\t{\n\t\tint protocol = iph->protocol;\n\t\tconst union nf_inet_addr *vaddr = dst_addr;\n\t\t__be16 vport = 0;\n\n\t\tif (dst_port == svc->port) {\n\t\t\t \n\t\t\tif (svc->port != FTPPORT)\n\t\t\t\tvport = dst_port;\n\t\t} else {\n\t\t\t \n\t\t\tif (svc->fwmark) {\n\t\t\t\tprotocol = IPPROTO_IP;\n\t\t\t\tvaddr = &fwmark;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (ip_vs_conn_fill_param_persist(svc, skb, protocol, &snet, 0,\n\t\t\t\t\t\t  vaddr, vport, &param) < 0) {\n\t\t\t*ignored = -1;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \n\tct = ip_vs_ct_in_get(&param);\n\tif (!ct || !ip_vs_check_template(ct, NULL)) {\n\t\tstruct ip_vs_scheduler *sched;\n\n\t\t \n\t\tsched = rcu_dereference(svc->scheduler);\n\t\tif (sched) {\n\t\t\t \n\t\t\tsmp_rmb();\n\t\t\tdest = sched->schedule(svc, skb, iph);\n\t\t} else {\n\t\t\tdest = NULL;\n\t\t}\n\t\tif (!dest) {\n\t\t\tIP_VS_DBG(1, \"p-schedule: no dest found.\\n\");\n\t\t\tkfree(param.pe_data);\n\t\t\t*ignored = 0;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (dst_port == svc->port && svc->port != FTPPORT)\n\t\t\tdport = dest->port;\n\n\t\t \n\t\tct = ip_vs_conn_new(&param, dest->af, &dest->addr, dport,\n\t\t\t\t    IP_VS_CONN_F_TEMPLATE, dest, skb->mark);\n\t\tif (ct == NULL) {\n\t\t\tkfree(param.pe_data);\n\t\t\t*ignored = -1;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tct->timeout = svc->timeout;\n\t} else {\n\t\t \n\t\tdest = ct->dest;\n\t\tkfree(param.pe_data);\n\t}\n\n\tdport = dst_port;\n\tif (dport == svc->port && dest->port)\n\t\tdport = dest->port;\n\n\tflags = (svc->flags & IP_VS_SVC_F_ONEPACKET\n\t\t && iph->protocol == IPPROTO_UDP) ?\n\t\tIP_VS_CONN_F_ONE_PACKET : 0;\n\n\t \n\tip_vs_conn_fill_param(svc->ipvs, svc->af, iph->protocol, src_addr,\n\t\t\t      src_port, dst_addr, dst_port, &param);\n\n\tcp = ip_vs_conn_new(&param, dest->af, &dest->addr, dport, flags, dest,\n\t\t\t    skb->mark);\n\tif (cp == NULL) {\n\t\tip_vs_conn_put(ct);\n\t\t*ignored = -1;\n\t\treturn NULL;\n\t}\n\n\t \n\tip_vs_control_add(cp, ct);\n\tip_vs_conn_put(ct);\n\n\tip_vs_conn_stats(cp, svc);\n\treturn cp;\n}\n\n\n \nstruct ip_vs_conn *\nip_vs_schedule(struct ip_vs_service *svc, struct sk_buff *skb,\n\t       struct ip_vs_proto_data *pd, int *ignored,\n\t       struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_protocol *pp = pd->pp;\n\tstruct ip_vs_conn *cp = NULL;\n\tstruct ip_vs_scheduler *sched;\n\tstruct ip_vs_dest *dest;\n\t__be16 _ports[2], *pptr, cport, vport;\n\tconst void *caddr, *vaddr;\n\tunsigned int flags;\n\n\t*ignored = 1;\n\t \n\tpptr = frag_safe_skb_hp(skb, iph->len, sizeof(_ports), _ports);\n\tif (pptr == NULL)\n\t\treturn NULL;\n\n\tif (likely(!ip_vs_iph_inverse(iph))) {\n\t\tcport = pptr[0];\n\t\tcaddr = &iph->saddr;\n\t\tvport = pptr[1];\n\t\tvaddr = &iph->daddr;\n\t} else {\n\t\tcport = pptr[1];\n\t\tcaddr = &iph->daddr;\n\t\tvport = pptr[0];\n\t\tvaddr = &iph->saddr;\n\t}\n\n\t \n\tif (cport == FTPDATA) {\n\t\tIP_VS_DBG_PKT(12, svc->af, pp, skb, iph->off,\n\t\t\t      \"Not scheduling FTPDATA\");\n\t\treturn NULL;\n\t}\n\n\t \n\tif ((!skb->dev || skb->dev->flags & IFF_LOOPBACK)) {\n\t\tiph->hdr_flags ^= IP_VS_HDR_INVERSE;\n\t\tcp = INDIRECT_CALL_1(pp->conn_in_get,\n\t\t\t\t     ip_vs_conn_in_get_proto, svc->ipvs,\n\t\t\t\t     svc->af, skb, iph);\n\t\tiph->hdr_flags ^= IP_VS_HDR_INVERSE;\n\n\t\tif (cp) {\n\t\t\tIP_VS_DBG_PKT(12, svc->af, pp, skb, iph->off,\n\t\t\t\t      \"Not scheduling reply for existing\"\n\t\t\t\t      \" connection\");\n\t\t\t__ip_vs_conn_put(cp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \n\tif (svc->flags & IP_VS_SVC_F_PERSISTENT)\n\t\treturn ip_vs_sched_persist(svc, skb, cport, vport, ignored,\n\t\t\t\t\t   iph);\n\n\t*ignored = 0;\n\n\t \n\tif (!svc->fwmark && vport != svc->port) {\n\t\tif (!svc->port)\n\t\t\tpr_err(\"Schedule: port zero only supported \"\n\t\t\t       \"in persistent services, \"\n\t\t\t       \"check your ipvs configuration\\n\");\n\t\treturn NULL;\n\t}\n\n\tsched = rcu_dereference(svc->scheduler);\n\tif (sched) {\n\t\t \n\t\tsmp_rmb();\n\t\tdest = sched->schedule(svc, skb, iph);\n\t} else {\n\t\tdest = NULL;\n\t}\n\tif (dest == NULL) {\n\t\tIP_VS_DBG(1, \"Schedule: no dest found.\\n\");\n\t\treturn NULL;\n\t}\n\n\tflags = (svc->flags & IP_VS_SVC_F_ONEPACKET\n\t\t && iph->protocol == IPPROTO_UDP) ?\n\t\tIP_VS_CONN_F_ONE_PACKET : 0;\n\n\t \n\t{\n\t\tstruct ip_vs_conn_param p;\n\n\t\tip_vs_conn_fill_param(svc->ipvs, svc->af, iph->protocol,\n\t\t\t\t      caddr, cport, vaddr, vport, &p);\n\t\tcp = ip_vs_conn_new(&p, dest->af, &dest->addr,\n\t\t\t\t    dest->port ? dest->port : vport,\n\t\t\t\t    flags, dest, skb->mark);\n\t\tif (!cp) {\n\t\t\t*ignored = -1;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tIP_VS_DBG_BUF(6, \"Schedule fwd:%c c:%s:%u v:%s:%u \"\n\t\t      \"d:%s:%u conn->flags:%X conn->refcnt:%d\\n\",\n\t\t      ip_vs_fwd_tag(cp),\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr), ntohs(cp->cport),\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr), ntohs(cp->vport),\n\t\t      IP_VS_DBG_ADDR(cp->daf, &cp->daddr), ntohs(cp->dport),\n\t\t      cp->flags, refcount_read(&cp->refcnt));\n\n\tip_vs_conn_stats(cp, svc);\n\treturn cp;\n}\n\nstatic inline int ip_vs_addr_is_unicast(struct net *net, int af,\n\t\t\t\t\tunion nf_inet_addr *addr)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\treturn ipv6_addr_type(&addr->in6) & IPV6_ADDR_UNICAST;\n#endif\n\treturn (inet_addr_type(net, addr->ip) == RTN_UNICAST);\n}\n\n \nint ip_vs_leave(struct ip_vs_service *svc, struct sk_buff *skb,\n\t\tstruct ip_vs_proto_data *pd, struct ip_vs_iphdr *iph)\n{\n\t__be16 _ports[2], *pptr, dport;\n\tstruct netns_ipvs *ipvs = svc->ipvs;\n\tstruct net *net = ipvs->net;\n\n\tpptr = frag_safe_skb_hp(skb, iph->len, sizeof(_ports), _ports);\n\tif (!pptr)\n\t\treturn NF_DROP;\n\tdport = likely(!ip_vs_iph_inverse(iph)) ? pptr[1] : pptr[0];\n\n\t \n\tif (sysctl_cache_bypass(ipvs) && svc->fwmark &&\n\t    !(iph->hdr_flags & (IP_VS_HDR_INVERSE | IP_VS_HDR_ICMP)) &&\n\t    ip_vs_addr_is_unicast(net, svc->af, &iph->daddr)) {\n\t\tint ret;\n\t\tstruct ip_vs_conn *cp;\n\t\tunsigned int flags = (svc->flags & IP_VS_SVC_F_ONEPACKET &&\n\t\t\t\t      iph->protocol == IPPROTO_UDP) ?\n\t\t\t\t      IP_VS_CONN_F_ONE_PACKET : 0;\n\t\tunion nf_inet_addr daddr = { .all = { 0, 0, 0, 0 } };\n\n\t\t \n\t\tIP_VS_DBG(6, \"%s(): create a cache_bypass entry\\n\", __func__);\n\t\t{\n\t\t\tstruct ip_vs_conn_param p;\n\t\t\tip_vs_conn_fill_param(svc->ipvs, svc->af, iph->protocol,\n\t\t\t\t\t      &iph->saddr, pptr[0],\n\t\t\t\t\t      &iph->daddr, pptr[1], &p);\n\t\t\tcp = ip_vs_conn_new(&p, svc->af, &daddr, 0,\n\t\t\t\t\t    IP_VS_CONN_F_BYPASS | flags,\n\t\t\t\t\t    NULL, skb->mark);\n\t\t\tif (!cp)\n\t\t\t\treturn NF_DROP;\n\t\t}\n\n\t\t \n\t\tip_vs_in_stats(cp, skb);\n\n\t\t \n\t\tip_vs_set_state(cp, IP_VS_DIR_INPUT, skb, pd);\n\n\t\t \n\t\tret = cp->packet_xmit(skb, cp, pd->pp, iph);\n\t\t \n\n\t\tif ((cp->flags & IP_VS_CONN_F_ONE_PACKET) && cp->control)\n\t\t\tatomic_inc(&cp->control->in_pkts);\n\t\telse\n\t\t\tatomic_inc(&cp->in_pkts);\n\t\tip_vs_conn_put(cp);\n\t\treturn ret;\n\t}\n\n\t \n\tif (svc->port == FTPPORT && dport != FTPPORT)\n\t\treturn NF_ACCEPT;\n\n\tif (unlikely(ip_vs_iph_icmp(iph)))\n\t\treturn NF_DROP;\n\n\t \n#ifdef CONFIG_IP_VS_IPV6\n\tif (svc->af == AF_INET6) {\n\t\tif (!skb->dev)\n\t\t\tskb->dev = net->loopback_dev;\n\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\t} else\n#endif\n\t\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\n\treturn NF_DROP;\n}\n\n#ifdef CONFIG_SYSCTL\n\nstatic int sysctl_snat_reroute(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_snat_reroute;\n}\n\nstatic int sysctl_nat_icmp_send(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_nat_icmp_send;\n}\n\n#else\n\nstatic int sysctl_snat_reroute(struct netns_ipvs *ipvs) { return 0; }\nstatic int sysctl_nat_icmp_send(struct netns_ipvs *ipvs) { return 0; }\n\n#endif\n\n__sum16 ip_vs_checksum_complete(struct sk_buff *skb, int offset)\n{\n\treturn csum_fold(skb_checksum(skb, offset, skb->len - offset, 0));\n}\n\nstatic inline enum ip_defrag_users ip_vs_defrag_user(unsigned int hooknum)\n{\n\tif (NF_INET_LOCAL_IN == hooknum)\n\t\treturn IP_DEFRAG_VS_IN;\n\tif (NF_INET_FORWARD == hooknum)\n\t\treturn IP_DEFRAG_VS_FWD;\n\treturn IP_DEFRAG_VS_OUT;\n}\n\nstatic inline int ip_vs_gather_frags(struct netns_ipvs *ipvs,\n\t\t\t\t     struct sk_buff *skb, u_int32_t user)\n{\n\tint err;\n\n\tlocal_bh_disable();\n\terr = ip_defrag(ipvs->net, skb, user);\n\tlocal_bh_enable();\n\tif (!err)\n\t\tip_send_check(ip_hdr(skb));\n\n\treturn err;\n}\n\nstatic int ip_vs_route_me_harder(struct netns_ipvs *ipvs, int af,\n\t\t\t\t struct sk_buff *skb, unsigned int hooknum)\n{\n\tif (!sysctl_snat_reroute(ipvs))\n\t\treturn 0;\n\t \n\tif (NF_INET_LOCAL_IN == hooknum)\n\t\treturn 0;\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6) {\n\t\tstruct dst_entry *dst = skb_dst(skb);\n\n\t\tif (dst->dev && !(dst->dev->flags & IFF_LOOPBACK) &&\n\t\t    ip6_route_me_harder(ipvs->net, skb->sk, skb) != 0)\n\t\t\treturn 1;\n\t} else\n#endif\n\t\tif (!(skb_rtable(skb)->rt_flags & RTCF_LOCAL) &&\n\t\t    ip_route_me_harder(ipvs->net, skb->sk, skb, RTN_LOCAL) != 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n \nvoid ip_vs_nat_icmp(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t    struct ip_vs_conn *cp, int inout)\n{\n\tstruct iphdr *iph\t = ip_hdr(skb);\n\tunsigned int icmp_offset = iph->ihl*4;\n\tstruct icmphdr *icmph\t = (struct icmphdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t      icmp_offset);\n\tstruct iphdr *ciph\t = (struct iphdr *)(icmph + 1);\n\n\tif (inout) {\n\t\tiph->saddr = cp->vaddr.ip;\n\t\tip_send_check(iph);\n\t\tciph->daddr = cp->vaddr.ip;\n\t\tip_send_check(ciph);\n\t} else {\n\t\tiph->daddr = cp->daddr.ip;\n\t\tip_send_check(iph);\n\t\tciph->saddr = cp->daddr.ip;\n\t\tip_send_check(ciph);\n\t}\n\n\t \n\tif (IPPROTO_TCP == ciph->protocol || IPPROTO_UDP == ciph->protocol ||\n\t    IPPROTO_SCTP == ciph->protocol) {\n\t\t__be16 *ports = (void *)ciph + ciph->ihl*4;\n\n\t\tif (inout)\n\t\t\tports[1] = cp->vport;\n\t\telse\n\t\t\tports[0] = cp->dport;\n\t}\n\n\t \n\ticmph->checksum = 0;\n\ticmph->checksum = ip_vs_checksum_complete(skb, icmp_offset);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (inout)\n\t\tIP_VS_DBG_PKT(11, AF_INET, pp, skb, (void *)ciph - (void *)iph,\n\t\t\t\"Forwarding altered outgoing ICMP\");\n\telse\n\t\tIP_VS_DBG_PKT(11, AF_INET, pp, skb, (void *)ciph - (void *)iph,\n\t\t\t\"Forwarding altered incoming ICMP\");\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nvoid ip_vs_nat_icmp_v6(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t    struct ip_vs_conn *cp, int inout)\n{\n\tstruct ipv6hdr *iph\t = ipv6_hdr(skb);\n\tunsigned int icmp_offset = 0;\n\tunsigned int offs\t = 0;  \n\tint protocol;\n\tstruct icmp6hdr *icmph;\n\tstruct ipv6hdr *ciph;\n\tunsigned short fragoffs;\n\n\tipv6_find_hdr(skb, &icmp_offset, IPPROTO_ICMPV6, &fragoffs, NULL);\n\ticmph = (struct icmp6hdr *)(skb_network_header(skb) + icmp_offset);\n\toffs = icmp_offset + sizeof(struct icmp6hdr);\n\tciph = (struct ipv6hdr *)(skb_network_header(skb) + offs);\n\n\tprotocol = ipv6_find_hdr(skb, &offs, -1, &fragoffs, NULL);\n\n\tif (inout) {\n\t\tiph->saddr = cp->vaddr.in6;\n\t\tciph->daddr = cp->vaddr.in6;\n\t} else {\n\t\tiph->daddr = cp->daddr.in6;\n\t\tciph->saddr = cp->daddr.in6;\n\t}\n\n\t \n\tif (!fragoffs && (IPPROTO_TCP == protocol || IPPROTO_UDP == protocol ||\n\t\t\t  IPPROTO_SCTP == protocol)) {\n\t\t__be16 *ports = (void *)(skb_network_header(skb) + offs);\n\n\t\tIP_VS_DBG(11, \"%s() changed port %d to %d\\n\", __func__,\n\t\t\t      ntohs(inout ? ports[1] : ports[0]),\n\t\t\t      ntohs(inout ? cp->vport : cp->dport));\n\t\tif (inout)\n\t\t\tports[1] = cp->vport;\n\t\telse\n\t\t\tports[0] = cp->dport;\n\t}\n\n\t \n\ticmph->icmp6_cksum = ~csum_ipv6_magic(&iph->saddr, &iph->daddr,\n\t\t\t\t\t      skb->len - icmp_offset,\n\t\t\t\t\t      IPPROTO_ICMPV6, 0);\n\tskb->csum_start = skb_network_header(skb) - skb->head + icmp_offset;\n\tskb->csum_offset = offsetof(struct icmp6hdr, icmp6_cksum);\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\n\tif (inout)\n\t\tIP_VS_DBG_PKT(11, AF_INET6, pp, skb,\n\t\t\t      (void *)ciph - (void *)iph,\n\t\t\t      \"Forwarding altered outgoing ICMPv6\");\n\telse\n\t\tIP_VS_DBG_PKT(11, AF_INET6, pp, skb,\n\t\t\t      (void *)ciph - (void *)iph,\n\t\t\t      \"Forwarding altered incoming ICMPv6\");\n}\n#endif\n\n \nstatic int handle_response_icmp(int af, struct sk_buff *skb,\n\t\t\t\tunion nf_inet_addr *snet,\n\t\t\t\t__u8 protocol, struct ip_vs_conn *cp,\n\t\t\t\tstruct ip_vs_protocol *pp,\n\t\t\t\tunsigned int offset, unsigned int ihl,\n\t\t\t\tunsigned int hooknum)\n{\n\tunsigned int verdict = NF_DROP;\n\n\tif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)\n\t\tgoto after_nat;\n\n\t \n\tif (!skb_csum_unnecessary(skb) && ip_vs_checksum_complete(skb, ihl)) {\n\t\t \n\t\tIP_VS_DBG_BUF(1, \"Forward ICMP: failed checksum from %s!\\n\",\n\t\t\t      IP_VS_DBG_ADDR(af, snet));\n\t\tgoto out;\n\t}\n\n\tif (IPPROTO_TCP == protocol || IPPROTO_UDP == protocol ||\n\t    IPPROTO_SCTP == protocol)\n\t\toffset += 2 * sizeof(__u16);\n\tif (skb_ensure_writable(skb, offset))\n\t\tgoto out;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\tip_vs_nat_icmp_v6(skb, pp, cp, 1);\n\telse\n#endif\n\t\tip_vs_nat_icmp(skb, pp, cp, 1);\n\n\tif (ip_vs_route_me_harder(cp->ipvs, af, skb, hooknum))\n\t\tgoto out;\n\nafter_nat:\n\t \n\tip_vs_out_stats(cp, skb);\n\n\tskb->ipvs_property = 1;\n\tif (!(cp->flags & IP_VS_CONN_F_NFCT))\n\t\tip_vs_notrack(skb);\n\telse\n\t\tip_vs_update_conntrack(skb, cp, 0);\n\tverdict = NF_ACCEPT;\n\nout:\n\t__ip_vs_conn_put(cp);\n\n\treturn verdict;\n}\n\n \nstatic int ip_vs_out_icmp(struct netns_ipvs *ipvs, struct sk_buff *skb,\n\t\t\t  int *related, unsigned int hooknum)\n{\n\tstruct iphdr *iph;\n\tstruct icmphdr\t_icmph, *ic;\n\tstruct iphdr\t_ciph, *cih;\t \n\tstruct ip_vs_iphdr ciph;\n\tstruct ip_vs_conn *cp;\n\tstruct ip_vs_protocol *pp;\n\tunsigned int offset, ihl;\n\tunion nf_inet_addr snet;\n\n\t*related = 1;\n\n\t \n\tif (ip_is_fragment(ip_hdr(skb))) {\n\t\tif (ip_vs_gather_frags(ipvs, skb, ip_vs_defrag_user(hooknum)))\n\t\t\treturn NF_STOLEN;\n\t}\n\n\tiph = ip_hdr(skb);\n\toffset = ihl = iph->ihl * 4;\n\tic = skb_header_pointer(skb, offset, sizeof(_icmph), &_icmph);\n\tif (ic == NULL)\n\t\treturn NF_DROP;\n\n\tIP_VS_DBG(12, \"Outgoing ICMP (%d,%d) %pI4->%pI4\\n\",\n\t\t  ic->type, ntohs(icmp_id(ic)),\n\t\t  &iph->saddr, &iph->daddr);\n\n\t \n\tif ((ic->type != ICMP_DEST_UNREACH) &&\n\t    (ic->type != ICMP_SOURCE_QUENCH) &&\n\t    (ic->type != ICMP_TIME_EXCEEDED)) {\n\t\t*related = 0;\n\t\treturn NF_ACCEPT;\n\t}\n\n\t \n\toffset += sizeof(_icmph);\n\tcih = skb_header_pointer(skb, offset, sizeof(_ciph), &_ciph);\n\tif (cih == NULL)\n\t\treturn NF_ACCEPT;  \n\n\tpp = ip_vs_proto_get(cih->protocol);\n\tif (!pp)\n\t\treturn NF_ACCEPT;\n\n\t \n\tif (unlikely(cih->frag_off & htons(IP_OFFSET) &&\n\t\t     pp->dont_defrag))\n\t\treturn NF_ACCEPT;\n\n\tIP_VS_DBG_PKT(11, AF_INET, pp, skb, offset,\n\t\t      \"Checking outgoing ICMP for\");\n\n\tip_vs_fill_iph_skb_icmp(AF_INET, skb, offset, true, &ciph);\n\n\t \n\tcp = INDIRECT_CALL_1(pp->conn_out_get, ip_vs_conn_out_get_proto,\n\t\t\t     ipvs, AF_INET, skb, &ciph);\n\tif (!cp)\n\t\treturn NF_ACCEPT;\n\n\tsnet.ip = iph->saddr;\n\treturn handle_response_icmp(AF_INET, skb, &snet, cih->protocol, cp,\n\t\t\t\t    pp, ciph.len, ihl, hooknum);\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nstatic int ip_vs_out_icmp_v6(struct netns_ipvs *ipvs, struct sk_buff *skb,\n\t\t\t     int *related,  unsigned int hooknum,\n\t\t\t     struct ip_vs_iphdr *ipvsh)\n{\n\tstruct icmp6hdr\t_icmph, *ic;\n\tstruct ip_vs_iphdr ciph = {.flags = 0, .fragoffs = 0}; \n\tstruct ip_vs_conn *cp;\n\tstruct ip_vs_protocol *pp;\n\tunion nf_inet_addr snet;\n\tunsigned int offset;\n\n\t*related = 1;\n\tic = frag_safe_skb_hp(skb, ipvsh->len, sizeof(_icmph), &_icmph);\n\tif (ic == NULL)\n\t\treturn NF_DROP;\n\n\t \n\tif (ic->icmp6_type & ICMPV6_INFOMSG_MASK) {\n\t\t*related = 0;\n\t\treturn NF_ACCEPT;\n\t}\n\t \n\tif (ipvsh->flags & IP6_FH_F_FRAG)\n\t\treturn NF_DROP;\n\n\tIP_VS_DBG(8, \"Outgoing ICMPv6 (%d,%d) %pI6c->%pI6c\\n\",\n\t\t  ic->icmp6_type, ntohs(icmpv6_id(ic)),\n\t\t  &ipvsh->saddr, &ipvsh->daddr);\n\n\tif (!ip_vs_fill_iph_skb_icmp(AF_INET6, skb, ipvsh->len + sizeof(_icmph),\n\t\t\t\t     true, &ciph))\n\t\treturn NF_ACCEPT;  \n\n\tpp = ip_vs_proto_get(ciph.protocol);\n\tif (!pp)\n\t\treturn NF_ACCEPT;\n\n\t \n\tcp = INDIRECT_CALL_1(pp->conn_out_get, ip_vs_conn_out_get_proto,\n\t\t\t     ipvs, AF_INET6, skb, &ciph);\n\tif (!cp)\n\t\treturn NF_ACCEPT;\n\n\tsnet.in6 = ciph.saddr.in6;\n\toffset = ciph.len;\n\treturn handle_response_icmp(AF_INET6, skb, &snet, ciph.protocol, cp,\n\t\t\t\t    pp, offset, sizeof(struct ipv6hdr),\n\t\t\t\t    hooknum);\n}\n#endif\n\n \nstatic inline int is_sctp_abort(const struct sk_buff *skb, int nh_len)\n{\n\tstruct sctp_chunkhdr *sch, schunk;\n\tsch = skb_header_pointer(skb, nh_len + sizeof(struct sctphdr),\n\t\t\t\t sizeof(schunk), &schunk);\n\tif (sch == NULL)\n\t\treturn 0;\n\tif (sch->type == SCTP_CID_ABORT)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int is_tcp_reset(const struct sk_buff *skb, int nh_len)\n{\n\tstruct tcphdr _tcph, *th;\n\n\tth = skb_header_pointer(skb, nh_len, sizeof(_tcph), &_tcph);\n\tif (th == NULL)\n\t\treturn 0;\n\treturn th->rst;\n}\n\nstatic inline bool is_new_conn(const struct sk_buff *skb,\n\t\t\t       struct ip_vs_iphdr *iph)\n{\n\tswitch (iph->protocol) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr _tcph, *th;\n\n\t\tth = skb_header_pointer(skb, iph->len, sizeof(_tcph), &_tcph);\n\t\tif (th == NULL)\n\t\t\treturn false;\n\t\treturn th->syn;\n\t}\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctp_chunkhdr *sch, schunk;\n\n\t\tsch = skb_header_pointer(skb, iph->len + sizeof(struct sctphdr),\n\t\t\t\t\t sizeof(schunk), &schunk);\n\t\tif (sch == NULL)\n\t\t\treturn false;\n\t\treturn sch->type == SCTP_CID_INIT;\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline bool is_new_conn_expected(const struct ip_vs_conn *cp,\n\t\t\t\t\tint conn_reuse_mode)\n{\n\t \n\tif (cp->control)\n\t\treturn false;\n\n\tswitch (cp->protocol) {\n\tcase IPPROTO_TCP:\n\t\treturn (cp->state == IP_VS_TCP_S_TIME_WAIT) ||\n\t\t       (cp->state == IP_VS_TCP_S_CLOSE) ||\n\t\t\t((conn_reuse_mode & 2) &&\n\t\t\t (cp->state == IP_VS_TCP_S_FIN_WAIT) &&\n\t\t\t (cp->flags & IP_VS_CONN_F_NOOUTPUT));\n\tcase IPPROTO_SCTP:\n\t\treturn cp->state == IP_VS_SCTP_S_CLOSED;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstruct ip_vs_conn *ip_vs_new_conn_out(struct ip_vs_service *svc,\n\t\t\t\t      struct ip_vs_dest *dest,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const struct ip_vs_iphdr *iph,\n\t\t\t\t      __be16 dport,\n\t\t\t\t      __be16 cport)\n{\n\tstruct ip_vs_conn_param param;\n\tstruct ip_vs_conn *ct = NULL, *cp = NULL;\n\tconst union nf_inet_addr *vaddr, *daddr, *caddr;\n\tunion nf_inet_addr snet;\n\t__be16 vport;\n\tunsigned int flags;\n\n\tvaddr = &svc->addr;\n\tvport = svc->port;\n\tdaddr = &iph->saddr;\n\tcaddr = &iph->daddr;\n\n\t \n\tif (svc->fwmark)\n\t\treturn NULL;\n\tif (!vport || !dport)\n\t\treturn NULL;\n\n\t \n\tif (svc->flags & IP_VS_SVC_F_PERSISTENT) {\n\t\t \n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (svc->af == AF_INET6)\n\t\t\tipv6_addr_prefix(&snet.in6, &caddr->in6,\n\t\t\t\t\t (__force __u32)svc->netmask);\n\t\telse\n#endif\n\t\t\tsnet.ip = caddr->ip & svc->netmask;\n\t\t \n\t\tif (ip_vs_conn_fill_param_persist(svc, skb, iph->protocol,\n\t\t\t\t\t\t  &snet, 0, vaddr,\n\t\t\t\t\t\t  vport, &param) < 0)\n\t\t\treturn NULL;\n\t\tct = ip_vs_ct_in_get(&param);\n\t\t \n\t\tif (!ct || !ip_vs_check_template(ct, dest)) {\n\t\t\tct = ip_vs_conn_new(&param, dest->af, daddr, dport,\n\t\t\t\t\t    IP_VS_CONN_F_TEMPLATE, dest, 0);\n\t\t\tif (!ct) {\n\t\t\t\tkfree(param.pe_data);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tct->timeout = svc->timeout;\n\t\t} else {\n\t\t\tkfree(param.pe_data);\n\t\t}\n\t}\n\n\t \n\tflags = ((svc->flags & IP_VS_SVC_F_ONEPACKET) &&\n\t\t iph->protocol == IPPROTO_UDP) ? IP_VS_CONN_F_ONE_PACKET : 0;\n\t \n\tip_vs_conn_fill_param(svc->ipvs, svc->af, iph->protocol,\n\t\t\t      caddr, cport, vaddr, vport, &param);\n\tcp = ip_vs_conn_new(&param, dest->af, daddr, dport, flags, dest, 0);\n\tif (!cp) {\n\t\tif (ct)\n\t\t\tip_vs_conn_put(ct);\n\t\treturn NULL;\n\t}\n\tif (ct) {\n\t\tip_vs_control_add(cp, ct);\n\t\tip_vs_conn_put(ct);\n\t}\n\tip_vs_conn_stats(cp, svc);\n\n\t \n\tIP_VS_DBG_BUF(6, \"New connection RS-initiated:%c c:%s:%u v:%s:%u \"\n\t\t      \"d:%s:%u conn->flags:%X conn->refcnt:%d\\n\",\n\t\t      ip_vs_fwd_tag(cp),\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr), ntohs(cp->cport),\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr), ntohs(cp->vport),\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->daddr), ntohs(cp->dport),\n\t\t      cp->flags, refcount_read(&cp->refcnt));\n\treturn cp;\n}\n\n \nstatic struct ip_vs_conn *__ip_vs_rs_conn_out(unsigned int hooknum,\n\t\t\t\t\t      struct netns_ipvs *ipvs,\n\t\t\t\t\t      int af, struct sk_buff *skb,\n\t\t\t\t\t      const struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_dest *dest;\n\tstruct ip_vs_conn *cp = NULL;\n\t__be16 _ports[2], *pptr;\n\n\tif (hooknum == NF_INET_LOCAL_IN)\n\t\treturn NULL;\n\n\tpptr = frag_safe_skb_hp(skb, iph->len,\n\t\t\t\tsizeof(_ports), _ports);\n\tif (!pptr)\n\t\treturn NULL;\n\n\tdest = ip_vs_find_real_service(ipvs, af, iph->protocol,\n\t\t\t\t       &iph->saddr, pptr[0]);\n\tif (dest) {\n\t\tstruct ip_vs_service *svc;\n\t\tstruct ip_vs_pe *pe;\n\n\t\tsvc = rcu_dereference(dest->svc);\n\t\tif (svc) {\n\t\t\tpe = rcu_dereference(svc->pe);\n\t\t\tif (pe && pe->conn_out)\n\t\t\t\tcp = pe->conn_out(svc, dest, skb, iph,\n\t\t\t\t\t\t  pptr[0], pptr[1]);\n\t\t}\n\t}\n\n\treturn cp;\n}\n\n \nstatic unsigned int\nhandle_response(int af, struct sk_buff *skb, struct ip_vs_proto_data *pd,\n\t\tstruct ip_vs_conn *cp, struct ip_vs_iphdr *iph,\n\t\tunsigned int hooknum)\n{\n\tstruct ip_vs_protocol *pp = pd->pp;\n\n\tif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)\n\t\tgoto after_nat;\n\n\tIP_VS_DBG_PKT(11, af, pp, skb, iph->off, \"Outgoing packet\");\n\n\tif (skb_ensure_writable(skb, iph->len))\n\t\tgoto drop;\n\n\t \n\tif (pp->snat_handler &&\n\t    !SNAT_CALL(pp->snat_handler, skb, pp, cp, iph))\n\t\tgoto drop;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\tipv6_hdr(skb)->saddr = cp->vaddr.in6;\n\telse\n#endif\n\t{\n\t\tip_hdr(skb)->saddr = cp->vaddr.ip;\n\t\tip_send_check(ip_hdr(skb));\n\t}\n\n\t \n\n\t \n\tif (ip_vs_route_me_harder(cp->ipvs, af, skb, hooknum))\n\t\tgoto drop;\n\n\tIP_VS_DBG_PKT(10, af, pp, skb, iph->off, \"After SNAT\");\n\nafter_nat:\n\tip_vs_out_stats(cp, skb);\n\tip_vs_set_state(cp, IP_VS_DIR_OUTPUT, skb, pd);\n\tskb->ipvs_property = 1;\n\tif (!(cp->flags & IP_VS_CONN_F_NFCT))\n\t\tip_vs_notrack(skb);\n\telse\n\t\tip_vs_update_conntrack(skb, cp, 0);\n\tip_vs_conn_put(cp);\n\n\treturn NF_ACCEPT;\n\ndrop:\n\tip_vs_conn_put(cp);\n\tkfree_skb(skb);\n\treturn NF_STOLEN;\n}\n\n \nstatic unsigned int\nip_vs_out_hook(void *priv, struct sk_buff *skb, const struct nf_hook_state *state)\n{\n\tstruct netns_ipvs *ipvs = net_ipvs(state->net);\n\tunsigned int hooknum = state->hook;\n\tstruct ip_vs_iphdr iph;\n\tstruct ip_vs_protocol *pp;\n\tstruct ip_vs_proto_data *pd;\n\tstruct ip_vs_conn *cp;\n\tint af = state->pf;\n\tstruct sock *sk;\n\n\t \n\tif (skb->ipvs_property)\n\t\treturn NF_ACCEPT;\n\n\tsk = skb_to_full_sk(skb);\n\t \n\tif (unlikely(sk && hooknum == NF_INET_LOCAL_OUT &&\n\t\t     af == AF_INET)) {\n\n\t\tif (sk->sk_family == PF_INET && inet_test_bit(NODEFRAG, sk))\n\t\t\treturn NF_ACCEPT;\n\t}\n\n\tif (unlikely(!skb_dst(skb)))\n\t\treturn NF_ACCEPT;\n\n\tif (!ipvs->enable)\n\t\treturn NF_ACCEPT;\n\n\tip_vs_fill_iph_skb(af, skb, false, &iph);\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6) {\n\t\tif (unlikely(iph.protocol == IPPROTO_ICMPV6)) {\n\t\t\tint related;\n\t\t\tint verdict = ip_vs_out_icmp_v6(ipvs, skb, &related,\n\t\t\t\t\t\t\thooknum, &iph);\n\n\t\t\tif (related)\n\t\t\t\treturn verdict;\n\t\t}\n\t} else\n#endif\n\t\tif (unlikely(iph.protocol == IPPROTO_ICMP)) {\n\t\t\tint related;\n\t\t\tint verdict = ip_vs_out_icmp(ipvs, skb, &related, hooknum);\n\n\t\t\tif (related)\n\t\t\t\treturn verdict;\n\t\t}\n\n\tpd = ip_vs_proto_data_get(ipvs, iph.protocol);\n\tif (unlikely(!pd))\n\t\treturn NF_ACCEPT;\n\tpp = pd->pp;\n\n\t \n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET)\n#endif\n\t\tif (unlikely(ip_is_fragment(ip_hdr(skb)) && !pp->dont_defrag)) {\n\t\t\tif (ip_vs_gather_frags(ipvs, skb,\n\t\t\t\t\t       ip_vs_defrag_user(hooknum)))\n\t\t\t\treturn NF_STOLEN;\n\n\t\t\tip_vs_fill_iph_skb(AF_INET, skb, false, &iph);\n\t\t}\n\n\t \n\tcp = INDIRECT_CALL_1(pp->conn_out_get, ip_vs_conn_out_get_proto,\n\t\t\t     ipvs, af, skb, &iph);\n\n\tif (likely(cp))\n\t\treturn handle_response(af, skb, pd, cp, &iph, hooknum);\n\n\t \n\tif (atomic_read(&ipvs->conn_out_counter)) {\n\t\t \n\t\tif (pp->protocol == IPPROTO_UDP) {\n\t\t\tcp = __ip_vs_rs_conn_out(hooknum, ipvs, af, skb, &iph);\n\t\t\tif (likely(cp))\n\t\t\t\treturn handle_response(af, skb, pd, cp, &iph,\n\t\t\t\t\t\t       hooknum);\n\t\t}\n\t}\n\n\tif (sysctl_nat_icmp_send(ipvs) &&\n\t    (pp->protocol == IPPROTO_TCP ||\n\t     pp->protocol == IPPROTO_UDP ||\n\t     pp->protocol == IPPROTO_SCTP)) {\n\t\t__be16 _ports[2], *pptr;\n\n\t\tpptr = frag_safe_skb_hp(skb, iph.len,\n\t\t\t\t\t sizeof(_ports), _ports);\n\t\tif (pptr == NULL)\n\t\t\treturn NF_ACCEPT;\t \n\t\tif (ip_vs_has_real_service(ipvs, af, iph.protocol, &iph.saddr,\n\t\t\t\t\t   pptr[0])) {\n\t\t\t \n\t\t\tif ((iph.protocol != IPPROTO_TCP &&\n\t\t\t     iph.protocol != IPPROTO_SCTP)\n\t\t\t     || ((iph.protocol == IPPROTO_TCP\n\t\t\t\t  && !is_tcp_reset(skb, iph.len))\n\t\t\t\t || (iph.protocol == IPPROTO_SCTP\n\t\t\t\t\t&& !is_sctp_abort(skb,\n\t\t\t\t\t\tiph.len)))) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\t\t\tif (af == AF_INET6) {\n\t\t\t\t\tif (!skb->dev)\n\t\t\t\t\t\tskb->dev = ipvs->net->loopback_dev;\n\t\t\t\t\ticmpv6_send(skb,\n\t\t\t\t\t\t    ICMPV6_DEST_UNREACH,\n\t\t\t\t\t\t    ICMPV6_PORT_UNREACH,\n\t\t\t\t\t\t    0);\n\t\t\t\t} else\n#endif\n\t\t\t\t\ticmp_send(skb,\n\t\t\t\t\t\t  ICMP_DEST_UNREACH,\n\t\t\t\t\t\t  ICMP_PORT_UNREACH, 0);\n\t\t\t\treturn NF_DROP;\n\t\t\t}\n\t\t}\n\t}\n\n\tIP_VS_DBG_PKT(12, af, pp, skb, iph.off,\n\t\t      \"ip_vs_out: packet continues traversal as normal\");\n\treturn NF_ACCEPT;\n}\n\nstatic unsigned int\nip_vs_try_to_schedule(struct netns_ipvs *ipvs, int af, struct sk_buff *skb,\n\t\t      struct ip_vs_proto_data *pd,\n\t\t      int *verdict, struct ip_vs_conn **cpp,\n\t\t      struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_protocol *pp = pd->pp;\n\n\tif (!iph->fragoffs) {\n\t\t \n\n\t\t \n\t\tif (!pp->conn_schedule(ipvs, af, skb, pd, verdict, cpp, iph))\n\t\t\treturn 0;\n\t}\n\n\tif (unlikely(!*cpp)) {\n\t\t \n\t\tIP_VS_DBG_PKT(12, af, pp, skb, iph->off,\n\t\t\t      \"ip_vs_in: packet continues traversal as normal\");\n\n\t\t \n\t\tif (iph->fragoffs)\n\t\t\tIP_VS_DBG_PKT(7, af, pp, skb, iph->off,\n\t\t\t\t      \"unhandled fragment\");\n\n\t\t*verdict = NF_ACCEPT;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int ipvs_udp_decap(struct netns_ipvs *ipvs, struct sk_buff *skb,\n\t\t\t  unsigned int offset, __u16 af,\n\t\t\t  const union nf_inet_addr *daddr, __u8 *proto)\n{\n\tstruct udphdr _udph, *udph;\n\tstruct ip_vs_dest *dest;\n\n\tudph = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\tif (!udph)\n\t\tgoto unk;\n\toffset += sizeof(struct udphdr);\n\tdest = ip_vs_find_tunnel(ipvs, af, daddr, udph->dest);\n\tif (!dest)\n\t\tgoto unk;\n\tif (dest->tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GUE) {\n\t\tstruct guehdr _gueh, *gueh;\n\n\t\tgueh = skb_header_pointer(skb, offset, sizeof(_gueh), &_gueh);\n\t\tif (!gueh)\n\t\t\tgoto unk;\n\t\tif (gueh->control != 0 || gueh->version != 0)\n\t\t\tgoto unk;\n\t\t \n\t\tif (gueh->proto_ctype != IPPROTO_IPIP)\n\t\t\tgoto unk;\n\t\t*proto = gueh->proto_ctype;\n\t\treturn sizeof(struct udphdr) + sizeof(struct guehdr) +\n\t\t       (gueh->hlen << 2);\n\t}\n\nunk:\n\treturn 0;\n}\n\n \nstatic int ipvs_gre_decap(struct netns_ipvs *ipvs, struct sk_buff *skb,\n\t\t\t  unsigned int offset, __u16 af,\n\t\t\t  const union nf_inet_addr *daddr, __u8 *proto)\n{\n\tstruct gre_base_hdr _greh, *greh;\n\tstruct ip_vs_dest *dest;\n\n\tgreh = skb_header_pointer(skb, offset, sizeof(_greh), &_greh);\n\tif (!greh)\n\t\tgoto unk;\n\tdest = ip_vs_find_tunnel(ipvs, af, daddr, 0);\n\tif (!dest)\n\t\tgoto unk;\n\tif (dest->tun_type == IP_VS_CONN_F_TUNNEL_TYPE_GRE) {\n\t\t__be16 type;\n\n\t\t \n\t\tif ((greh->flags & ~GRE_CSUM) != 0)\n\t\t\tgoto unk;\n\t\ttype = greh->protocol;\n\t\t \n\t\tif (type != htons(ETH_P_IP))\n\t\t\tgoto unk;\n\t\t*proto = IPPROTO_IPIP;\n\t\treturn gre_calc_hlen(gre_flags_to_tnl_flags(greh->flags));\n\t}\n\nunk:\n\treturn 0;\n}\n\n \nstatic int\nip_vs_in_icmp(struct netns_ipvs *ipvs, struct sk_buff *skb, int *related,\n\t      unsigned int hooknum)\n{\n\tstruct iphdr *iph;\n\tstruct icmphdr\t_icmph, *ic;\n\tstruct iphdr\t_ciph, *cih;\t \n\tstruct ip_vs_iphdr ciph;\n\tstruct ip_vs_conn *cp;\n\tstruct ip_vs_protocol *pp;\n\tstruct ip_vs_proto_data *pd;\n\tunsigned int offset, offset2, ihl, verdict;\n\tbool tunnel, new_cp = false;\n\tunion nf_inet_addr *raddr;\n\tchar *outer_proto = \"IPIP\";\n\n\t*related = 1;\n\n\t \n\tif (ip_is_fragment(ip_hdr(skb))) {\n\t\tif (ip_vs_gather_frags(ipvs, skb, ip_vs_defrag_user(hooknum)))\n\t\t\treturn NF_STOLEN;\n\t}\n\n\tiph = ip_hdr(skb);\n\toffset = ihl = iph->ihl * 4;\n\tic = skb_header_pointer(skb, offset, sizeof(_icmph), &_icmph);\n\tif (ic == NULL)\n\t\treturn NF_DROP;\n\n\tIP_VS_DBG(12, \"Incoming ICMP (%d,%d) %pI4->%pI4\\n\",\n\t\t  ic->type, ntohs(icmp_id(ic)),\n\t\t  &iph->saddr, &iph->daddr);\n\n\t \n\tif ((ic->type != ICMP_DEST_UNREACH) &&\n\t    (ic->type != ICMP_SOURCE_QUENCH) &&\n\t    (ic->type != ICMP_TIME_EXCEEDED)) {\n\t\t*related = 0;\n\t\treturn NF_ACCEPT;\n\t}\n\n\t \n\toffset += sizeof(_icmph);\n\tcih = skb_header_pointer(skb, offset, sizeof(_ciph), &_ciph);\n\tif (cih == NULL)\n\t\treturn NF_ACCEPT;  \n\traddr = (union nf_inet_addr *)&cih->daddr;\n\n\t \n\ttunnel = false;\n\tif (cih->protocol == IPPROTO_IPIP) {\n\t\tstruct ip_vs_dest *dest;\n\n\t\tif (unlikely(cih->frag_off & htons(IP_OFFSET)))\n\t\t\treturn NF_ACCEPT;\n\t\t \n\t\tif (!(skb_rtable(skb)->rt_flags & RTCF_LOCAL))\n\t\t\treturn NF_ACCEPT;\n\t\tdest = ip_vs_find_tunnel(ipvs, AF_INET, raddr, 0);\n\t\t \n\t\tif (!dest || dest->tun_type != IP_VS_CONN_F_TUNNEL_TYPE_IPIP)\n\t\t\treturn NF_ACCEPT;\n\t\toffset += cih->ihl * 4;\n\t\tcih = skb_header_pointer(skb, offset, sizeof(_ciph), &_ciph);\n\t\tif (cih == NULL)\n\t\t\treturn NF_ACCEPT;  \n\t\ttunnel = true;\n\t} else if ((cih->protocol == IPPROTO_UDP ||\t \n\t\t    cih->protocol == IPPROTO_GRE) &&\t \n\t\t    \n\t\t   (skb_rtable(skb)->rt_flags & RTCF_LOCAL)) {\n\t\t__u8 iproto;\n\t\tint ulen;\n\n\t\t \n\t\tif (unlikely(cih->frag_off & htons(IP_OFFSET)))\n\t\t\treturn NF_ACCEPT;\n\t\toffset2 = offset + cih->ihl * 4;\n\t\tif (cih->protocol == IPPROTO_UDP) {\n\t\t\tulen = ipvs_udp_decap(ipvs, skb, offset2, AF_INET,\n\t\t\t\t\t      raddr, &iproto);\n\t\t\touter_proto = \"UDP\";\n\t\t} else {\n\t\t\tulen = ipvs_gre_decap(ipvs, skb, offset2, AF_INET,\n\t\t\t\t\t      raddr, &iproto);\n\t\t\touter_proto = \"GRE\";\n\t\t}\n\t\tif (ulen > 0) {\n\t\t\t \n\t\t\toffset = offset2 + ulen;\n\t\t\t \n\t\t\tcih = skb_header_pointer(skb, offset, sizeof(_ciph),\n\t\t\t\t\t\t &_ciph);\n\t\t\tif (cih && cih->version == 4 && cih->ihl >= 5 &&\n\t\t\t    iproto == IPPROTO_IPIP)\n\t\t\t\ttunnel = true;\n\t\t\telse\n\t\t\t\treturn NF_ACCEPT;\n\t\t}\n\t}\n\n\tpd = ip_vs_proto_data_get(ipvs, cih->protocol);\n\tif (!pd)\n\t\treturn NF_ACCEPT;\n\tpp = pd->pp;\n\n\t \n\tif (unlikely(cih->frag_off & htons(IP_OFFSET) &&\n\t\t     pp->dont_defrag))\n\t\treturn NF_ACCEPT;\n\n\tIP_VS_DBG_PKT(11, AF_INET, pp, skb, offset,\n\t\t      \"Checking incoming ICMP for\");\n\n\toffset2 = offset;\n\tip_vs_fill_iph_skb_icmp(AF_INET, skb, offset, !tunnel, &ciph);\n\toffset = ciph.len;\n\n\t \n\tcp = INDIRECT_CALL_1(pp->conn_in_get, ip_vs_conn_in_get_proto,\n\t\t\t     ipvs, AF_INET, skb, &ciph);\n\n\tif (!cp) {\n\t\tint v;\n\n\t\tif (tunnel || !sysctl_schedule_icmp(ipvs))\n\t\t\treturn NF_ACCEPT;\n\n\t\tif (!ip_vs_try_to_schedule(ipvs, AF_INET, skb, pd, &v, &cp, &ciph))\n\t\t\treturn v;\n\t\tnew_cp = true;\n\t}\n\n\tverdict = NF_DROP;\n\n\t \n\tif (!skb_csum_unnecessary(skb) && ip_vs_checksum_complete(skb, ihl)) {\n\t\t \n\t\tIP_VS_DBG(1, \"Incoming ICMP: failed checksum from %pI4!\\n\",\n\t\t\t  &iph->saddr);\n\t\tgoto out;\n\t}\n\n\tif (tunnel) {\n\t\t__be32 info = ic->un.gateway;\n\t\t__u8 type = ic->type;\n\t\t__u8 code = ic->code;\n\n\t\t \n\t\tif (ic->type == ICMP_DEST_UNREACH &&\n\t\t    ic->code == ICMP_FRAG_NEEDED) {\n\t\t\tstruct ip_vs_dest *dest = cp->dest;\n\t\t\tu32 mtu = ntohs(ic->un.frag.mtu);\n\t\t\t__be16 frag_off = cih->frag_off;\n\n\t\t\t \n\t\t\tif (pskb_pull(skb, ihl + sizeof(_icmph)) == NULL)\n\t\t\t\tgoto ignore_tunnel;\n\t\t\toffset2 -= ihl + sizeof(_icmph);\n\t\t\tskb_reset_network_header(skb);\n\t\t\tIP_VS_DBG(12, \"ICMP for %s %pI4->%pI4: mtu=%u\\n\",\n\t\t\t\t  outer_proto, &ip_hdr(skb)->saddr,\n\t\t\t\t  &ip_hdr(skb)->daddr, mtu);\n\t\t\tipv4_update_pmtu(skb, ipvs->net, mtu, 0, 0);\n\t\t\t \n\t\t\tif (!(frag_off & htons(IP_DF)))\n\t\t\t\tgoto ignore_tunnel;\n\t\t\t \n\t\t\tif (dest) {\n\t\t\t\tstruct ip_vs_dest_dst *dest_dst;\n\n\t\t\t\tdest_dst = rcu_dereference(dest->dest_dst);\n\t\t\t\tif (dest_dst)\n\t\t\t\t\tmtu = dst_mtu(dest_dst->dst_cache);\n\t\t\t}\n\t\t\tif (mtu > 68 + sizeof(struct iphdr))\n\t\t\t\tmtu -= sizeof(struct iphdr);\n\t\t\tinfo = htonl(mtu);\n\t\t}\n\t\t \n\t\tif (pskb_pull(skb, offset2) == NULL)\n\t\t\tgoto ignore_tunnel;\n\t\tskb_reset_network_header(skb);\n\t\tIP_VS_DBG(12, \"Sending ICMP for %pI4->%pI4: t=%u, c=%u, i=%u\\n\",\n\t\t\t&ip_hdr(skb)->saddr, &ip_hdr(skb)->daddr,\n\t\t\ttype, code, ntohl(info));\n\t\ticmp_send(skb, type, code, info);\n\t\t \n\t\tip_vs_out_stats(cp, skb);\n\nignore_tunnel:\n\t\tconsume_skb(skb);\n\t\tverdict = NF_STOLEN;\n\t\tgoto out;\n\t}\n\n\t \n\tip_vs_in_stats(cp, skb);\n\tif (IPPROTO_TCP == cih->protocol || IPPROTO_UDP == cih->protocol ||\n\t    IPPROTO_SCTP == cih->protocol)\n\t\toffset += 2 * sizeof(__u16);\n\tverdict = ip_vs_icmp_xmit(skb, cp, pp, offset, hooknum, &ciph);\n\nout:\n\tif (likely(!new_cp))\n\t\t__ip_vs_conn_put(cp);\n\telse\n\t\tip_vs_conn_put(cp);\n\n\treturn verdict;\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nstatic int ip_vs_in_icmp_v6(struct netns_ipvs *ipvs, struct sk_buff *skb,\n\t\t\t    int *related, unsigned int hooknum,\n\t\t\t    struct ip_vs_iphdr *iph)\n{\n\tstruct icmp6hdr\t_icmph, *ic;\n\tstruct ip_vs_iphdr ciph = {.flags = 0, .fragoffs = 0}; \n\tstruct ip_vs_conn *cp;\n\tstruct ip_vs_protocol *pp;\n\tstruct ip_vs_proto_data *pd;\n\tunsigned int offset, verdict;\n\tbool new_cp = false;\n\n\t*related = 1;\n\n\tic = frag_safe_skb_hp(skb, iph->len, sizeof(_icmph), &_icmph);\n\tif (ic == NULL)\n\t\treturn NF_DROP;\n\n\t \n\tif (ic->icmp6_type & ICMPV6_INFOMSG_MASK) {\n\t\t*related = 0;\n\t\treturn NF_ACCEPT;\n\t}\n\t \n\tif (iph->flags & IP6_FH_F_FRAG)\n\t\treturn NF_DROP;\n\n\tIP_VS_DBG(8, \"Incoming ICMPv6 (%d,%d) %pI6c->%pI6c\\n\",\n\t\t  ic->icmp6_type, ntohs(icmpv6_id(ic)),\n\t\t  &iph->saddr, &iph->daddr);\n\n\toffset = iph->len + sizeof(_icmph);\n\tif (!ip_vs_fill_iph_skb_icmp(AF_INET6, skb, offset, true, &ciph))\n\t\treturn NF_ACCEPT;\n\n\tpd = ip_vs_proto_data_get(ipvs, ciph.protocol);\n\tif (!pd)\n\t\treturn NF_ACCEPT;\n\tpp = pd->pp;\n\n\t \n\tif (ciph.fragoffs)\n\t\treturn NF_ACCEPT;\n\n\tIP_VS_DBG_PKT(11, AF_INET6, pp, skb, offset,\n\t\t      \"Checking incoming ICMPv6 for\");\n\n\t \n\tcp = INDIRECT_CALL_1(pp->conn_in_get, ip_vs_conn_in_get_proto,\n\t\t\t     ipvs, AF_INET6, skb, &ciph);\n\n\tif (!cp) {\n\t\tint v;\n\n\t\tif (!sysctl_schedule_icmp(ipvs))\n\t\t\treturn NF_ACCEPT;\n\n\t\tif (!ip_vs_try_to_schedule(ipvs, AF_INET6, skb, pd, &v, &cp, &ciph))\n\t\t\treturn v;\n\n\t\tnew_cp = true;\n\t}\n\n\t \n\tif ((hooknum == NF_INET_LOCAL_OUT) &&\n\t    (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)) {\n\t\tverdict = NF_ACCEPT;\n\t\tgoto out;\n\t}\n\n\t \n\tip_vs_in_stats(cp, skb);\n\n\t \n\toffset = ciph.len;\n\tif (IPPROTO_TCP == ciph.protocol || IPPROTO_UDP == ciph.protocol ||\n\t    IPPROTO_SCTP == ciph.protocol)\n\t\toffset += 2 * sizeof(__u16);  \n\n\tverdict = ip_vs_icmp_xmit_v6(skb, cp, pp, offset, hooknum, &ciph);\n\nout:\n\tif (likely(!new_cp))\n\t\t__ip_vs_conn_put(cp);\n\telse\n\t\tip_vs_conn_put(cp);\n\n\treturn verdict;\n}\n#endif\n\n\n \nstatic unsigned int\nip_vs_in_hook(void *priv, struct sk_buff *skb, const struct nf_hook_state *state)\n{\n\tstruct netns_ipvs *ipvs = net_ipvs(state->net);\n\tunsigned int hooknum = state->hook;\n\tstruct ip_vs_iphdr iph;\n\tstruct ip_vs_protocol *pp;\n\tstruct ip_vs_proto_data *pd;\n\tstruct ip_vs_conn *cp;\n\tint ret, pkts;\n\tstruct sock *sk;\n\tint af = state->pf;\n\n\t \n\tif (skb->ipvs_property)\n\t\treturn NF_ACCEPT;\n\n\t \n\tif (unlikely((skb->pkt_type != PACKET_HOST &&\n\t\t      hooknum != NF_INET_LOCAL_OUT) ||\n\t\t     !skb_dst(skb))) {\n\t\tip_vs_fill_iph_skb(af, skb, false, &iph);\n\t\tIP_VS_DBG_BUF(12, \"packet type=%d proto=%d daddr=%s\"\n\t\t\t      \" ignored in hook %u\\n\",\n\t\t\t      skb->pkt_type, iph.protocol,\n\t\t\t      IP_VS_DBG_ADDR(af, &iph.daddr), hooknum);\n\t\treturn NF_ACCEPT;\n\t}\n\t \n\tif (unlikely(sysctl_backup_only(ipvs) || !ipvs->enable))\n\t\treturn NF_ACCEPT;\n\n\tip_vs_fill_iph_skb(af, skb, false, &iph);\n\n\t \n\tsk = skb_to_full_sk(skb);\n\tif (unlikely(sk && hooknum == NF_INET_LOCAL_OUT &&\n\t\t     af == AF_INET)) {\n\n\t\tif (sk->sk_family == PF_INET && inet_test_bit(NODEFRAG, sk))\n\t\t\treturn NF_ACCEPT;\n\t}\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6) {\n\t\tif (unlikely(iph.protocol == IPPROTO_ICMPV6)) {\n\t\t\tint related;\n\t\t\tint verdict = ip_vs_in_icmp_v6(ipvs, skb, &related,\n\t\t\t\t\t\t       hooknum, &iph);\n\n\t\t\tif (related)\n\t\t\t\treturn verdict;\n\t\t}\n\t} else\n#endif\n\t\tif (unlikely(iph.protocol == IPPROTO_ICMP)) {\n\t\t\tint related;\n\t\t\tint verdict = ip_vs_in_icmp(ipvs, skb, &related,\n\t\t\t\t\t\t    hooknum);\n\n\t\t\tif (related)\n\t\t\t\treturn verdict;\n\t\t}\n\n\t \n\tpd = ip_vs_proto_data_get(ipvs, iph.protocol);\n\tif (unlikely(!pd)) {\n\t\t \n\t\tif (sysctl_ignore_tunneled(ipvs))\n\t\t\tskb->ipvs_property = 1;\n\n\t\treturn NF_ACCEPT;\n\t}\n\tpp = pd->pp;\n\t \n\tcp = INDIRECT_CALL_1(pp->conn_in_get, ip_vs_conn_in_get_proto,\n\t\t\t     ipvs, af, skb, &iph);\n\n\tif (!iph.fragoffs && is_new_conn(skb, &iph) && cp) {\n\t\tint conn_reuse_mode = sysctl_conn_reuse_mode(ipvs);\n\t\tbool old_ct = false, resched = false;\n\n\t\tif (unlikely(sysctl_expire_nodest_conn(ipvs)) && cp->dest &&\n\t\t    unlikely(!atomic_read(&cp->dest->weight))) {\n\t\t\tresched = true;\n\t\t\told_ct = ip_vs_conn_uses_old_conntrack(cp, skb);\n\t\t} else if (conn_reuse_mode &&\n\t\t\t   is_new_conn_expected(cp, conn_reuse_mode)) {\n\t\t\told_ct = ip_vs_conn_uses_old_conntrack(cp, skb);\n\t\t\tif (!atomic_read(&cp->n_control)) {\n\t\t\t\tresched = true;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tresched = !old_ct;\n\t\t\t}\n\t\t}\n\n\t\tif (resched) {\n\t\t\tif (!old_ct)\n\t\t\t\tcp->flags &= ~IP_VS_CONN_F_NFCT;\n\t\t\tif (!atomic_read(&cp->n_control))\n\t\t\t\tip_vs_conn_expire_now(cp);\n\t\t\t__ip_vs_conn_put(cp);\n\t\t\tif (old_ct)\n\t\t\t\treturn NF_DROP;\n\t\t\tcp = NULL;\n\t\t}\n\t}\n\n\t \n\tif (cp && cp->dest && !(cp->dest->flags & IP_VS_DEST_F_AVAILABLE)) {\n\t\t \n\t\tif (sysctl_expire_nodest_conn(ipvs)) {\n\t\t\tbool old_ct = ip_vs_conn_uses_old_conntrack(cp, skb);\n\n\t\t\tif (!old_ct)\n\t\t\t\tcp->flags &= ~IP_VS_CONN_F_NFCT;\n\n\t\t\tip_vs_conn_expire_now(cp);\n\t\t\t__ip_vs_conn_put(cp);\n\t\t\tif (old_ct)\n\t\t\t\treturn NF_DROP;\n\t\t\tcp = NULL;\n\t\t} else {\n\t\t\t__ip_vs_conn_put(cp);\n\t\t\treturn NF_DROP;\n\t\t}\n\t}\n\n\tif (unlikely(!cp)) {\n\t\tint v;\n\n\t\tif (!ip_vs_try_to_schedule(ipvs, af, skb, pd, &v, &cp, &iph))\n\t\t\treturn v;\n\t}\n\n\tIP_VS_DBG_PKT(11, af, pp, skb, iph.off, \"Incoming packet\");\n\n\tip_vs_in_stats(cp, skb);\n\tip_vs_set_state(cp, IP_VS_DIR_INPUT, skb, pd);\n\tif (cp->packet_xmit)\n\t\tret = cp->packet_xmit(skb, cp, pp, &iph);\n\t\t \n\telse {\n\t\tIP_VS_DBG_RL(\"warning: packet_xmit is null\");\n\t\tret = NF_ACCEPT;\n\t}\n\n\t \n\n\tif (cp->flags & IP_VS_CONN_F_ONE_PACKET)\n\t\tpkts = sysctl_sync_threshold(ipvs);\n\telse\n\t\tpkts = atomic_inc_return(&cp->in_pkts);\n\n\tif (ipvs->sync_state & IP_VS_STATE_MASTER)\n\t\tip_vs_sync_conn(ipvs, cp, pkts);\n\telse if ((cp->flags & IP_VS_CONN_F_ONE_PACKET) && cp->control)\n\t\t \n\t\tatomic_inc(&cp->control->in_pkts);\n\n\tip_vs_conn_put(cp);\n\treturn ret;\n}\n\n \nstatic unsigned int\nip_vs_forward_icmp(void *priv, struct sk_buff *skb,\n\t\t   const struct nf_hook_state *state)\n{\n\tstruct netns_ipvs *ipvs = net_ipvs(state->net);\n\tint r;\n\n\t \n\tif (unlikely(sysctl_backup_only(ipvs) || !ipvs->enable))\n\t\treturn NF_ACCEPT;\n\n\tif (state->pf == NFPROTO_IPV4) {\n\t\tif (ip_hdr(skb)->protocol != IPPROTO_ICMP)\n\t\t\treturn NF_ACCEPT;\n#ifdef CONFIG_IP_VS_IPV6\n\t} else {\n\t\tstruct ip_vs_iphdr iphdr;\n\n\t\tip_vs_fill_iph_skb(AF_INET6, skb, false, &iphdr);\n\n\t\tif (iphdr.protocol != IPPROTO_ICMPV6)\n\t\t\treturn NF_ACCEPT;\n\n\t\treturn ip_vs_in_icmp_v6(ipvs, skb, &r, state->hook, &iphdr);\n#endif\n\t}\n\n\treturn ip_vs_in_icmp(ipvs, skb, &r, state->hook);\n}\n\nstatic const struct nf_hook_ops ip_vs_ops4[] = {\n\t \n\t{\n\t\t.hook\t\t= ip_vs_out_hook,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_LOCAL_IN,\n\t\t.priority\t= NF_IP_PRI_NAT_SRC - 2,\n\t},\n\t \n\t{\n\t\t.hook\t\t= ip_vs_in_hook,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_LOCAL_IN,\n\t\t.priority\t= NF_IP_PRI_NAT_SRC - 1,\n\t},\n\t \n\t{\n\t\t.hook\t\t= ip_vs_out_hook,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_LOCAL_OUT,\n\t\t.priority\t= NF_IP_PRI_NAT_DST + 1,\n\t},\n\t \n\t{\n\t\t.hook\t\t= ip_vs_in_hook,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_LOCAL_OUT,\n\t\t.priority\t= NF_IP_PRI_NAT_DST + 2,\n\t},\n\t \n\t{\n\t\t.hook\t\t= ip_vs_forward_icmp,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_FORWARD,\n\t\t.priority\t= 99,\n\t},\n\t \n\t{\n\t\t.hook\t\t= ip_vs_out_hook,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_FORWARD,\n\t\t.priority\t= 100,\n\t},\n};\n\n#ifdef CONFIG_IP_VS_IPV6\nstatic const struct nf_hook_ops ip_vs_ops6[] = {\n\t \n\t{\n\t\t.hook\t\t= ip_vs_out_hook,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_LOCAL_IN,\n\t\t.priority\t= NF_IP6_PRI_NAT_SRC - 2,\n\t},\n\t \n\t{\n\t\t.hook\t\t= ip_vs_in_hook,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_LOCAL_IN,\n\t\t.priority\t= NF_IP6_PRI_NAT_SRC - 1,\n\t},\n\t \n\t{\n\t\t.hook\t\t= ip_vs_out_hook,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_LOCAL_OUT,\n\t\t.priority\t= NF_IP6_PRI_NAT_DST + 1,\n\t},\n\t \n\t{\n\t\t.hook\t\t= ip_vs_in_hook,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_LOCAL_OUT,\n\t\t.priority\t= NF_IP6_PRI_NAT_DST + 2,\n\t},\n\t \n\t{\n\t\t.hook\t\t= ip_vs_forward_icmp,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_FORWARD,\n\t\t.priority\t= 99,\n\t},\n\t \n\t{\n\t\t.hook\t\t= ip_vs_out_hook,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_FORWARD,\n\t\t.priority\t= 100,\n\t},\n};\n#endif\n\nint ip_vs_register_hooks(struct netns_ipvs *ipvs, unsigned int af)\n{\n\tconst struct nf_hook_ops *ops;\n\tunsigned int count;\n\tunsigned int afmask;\n\tint ret = 0;\n\n\tif (af == AF_INET6) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\tops = ip_vs_ops6;\n\t\tcount = ARRAY_SIZE(ip_vs_ops6);\n\t\tafmask = 2;\n#else\n\t\treturn -EINVAL;\n#endif\n\t} else {\n\t\tops = ip_vs_ops4;\n\t\tcount = ARRAY_SIZE(ip_vs_ops4);\n\t\tafmask = 1;\n\t}\n\n\tif (!(ipvs->hooks_afmask & afmask)) {\n\t\tret = nf_register_net_hooks(ipvs->net, ops, count);\n\t\tif (ret >= 0)\n\t\t\tipvs->hooks_afmask |= afmask;\n\t}\n\treturn ret;\n}\n\nvoid ip_vs_unregister_hooks(struct netns_ipvs *ipvs, unsigned int af)\n{\n\tconst struct nf_hook_ops *ops;\n\tunsigned int count;\n\tunsigned int afmask;\n\n\tif (af == AF_INET6) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\tops = ip_vs_ops6;\n\t\tcount = ARRAY_SIZE(ip_vs_ops6);\n\t\tafmask = 2;\n#else\n\t\treturn;\n#endif\n\t} else {\n\t\tops = ip_vs_ops4;\n\t\tcount = ARRAY_SIZE(ip_vs_ops4);\n\t\tafmask = 1;\n\t}\n\n\tif (ipvs->hooks_afmask & afmask) {\n\t\tnf_unregister_net_hooks(ipvs->net, ops, count);\n\t\tipvs->hooks_afmask &= ~afmask;\n\t}\n}\n\n \nstatic int __net_init __ip_vs_init(struct net *net)\n{\n\tstruct netns_ipvs *ipvs;\n\n\tipvs = net_generic(net, ip_vs_net_id);\n\tif (ipvs == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tipvs->enable = 0;\n\tipvs->net = net;\n\t \n\tipvs->gen = atomic_read(&ipvs_netns_cnt);\n\tatomic_inc(&ipvs_netns_cnt);\n\tnet->ipvs = ipvs;\n\n\tif (ip_vs_estimator_net_init(ipvs) < 0)\n\t\tgoto estimator_fail;\n\n\tif (ip_vs_control_net_init(ipvs) < 0)\n\t\tgoto control_fail;\n\n\tif (ip_vs_protocol_net_init(ipvs) < 0)\n\t\tgoto protocol_fail;\n\n\tif (ip_vs_app_net_init(ipvs) < 0)\n\t\tgoto app_fail;\n\n\tif (ip_vs_conn_net_init(ipvs) < 0)\n\t\tgoto conn_fail;\n\n\tif (ip_vs_sync_net_init(ipvs) < 0)\n\t\tgoto sync_fail;\n\n\treturn 0;\n \n\nsync_fail:\n\tip_vs_conn_net_cleanup(ipvs);\nconn_fail:\n\tip_vs_app_net_cleanup(ipvs);\napp_fail:\n\tip_vs_protocol_net_cleanup(ipvs);\nprotocol_fail:\n\tip_vs_control_net_cleanup(ipvs);\ncontrol_fail:\n\tip_vs_estimator_net_cleanup(ipvs);\nestimator_fail:\n\tnet->ipvs = NULL;\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit __ip_vs_cleanup_batch(struct list_head *net_list)\n{\n\tstruct netns_ipvs *ipvs;\n\tstruct net *net;\n\n\tip_vs_service_nets_cleanup(net_list);\t \n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tipvs = net_ipvs(net);\n\t\tip_vs_conn_net_cleanup(ipvs);\n\t\tip_vs_app_net_cleanup(ipvs);\n\t\tip_vs_protocol_net_cleanup(ipvs);\n\t\tip_vs_control_net_cleanup(ipvs);\n\t\tip_vs_estimator_net_cleanup(ipvs);\n\t\tIP_VS_DBG(2, \"ipvs netns %d released\\n\", ipvs->gen);\n\t\tnet->ipvs = NULL;\n\t}\n}\n\nstatic void __net_exit __ip_vs_dev_cleanup_batch(struct list_head *net_list)\n{\n\tstruct netns_ipvs *ipvs;\n\tstruct net *net;\n\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tipvs = net_ipvs(net);\n\t\tip_vs_unregister_hooks(ipvs, AF_INET);\n\t\tip_vs_unregister_hooks(ipvs, AF_INET6);\n\t\tipvs->enable = 0;\t \n\t\tsmp_wmb();\n\t\tip_vs_sync_net_cleanup(ipvs);\n\t}\n}\n\nstatic struct pernet_operations ipvs_core_ops = {\n\t.init = __ip_vs_init,\n\t.exit_batch = __ip_vs_cleanup_batch,\n\t.id   = &ip_vs_net_id,\n\t.size = sizeof(struct netns_ipvs),\n};\n\nstatic struct pernet_operations ipvs_core_dev_ops = {\n\t.exit_batch = __ip_vs_dev_cleanup_batch,\n};\n\n \nstatic int __init ip_vs_init(void)\n{\n\tint ret;\n\n\tret = ip_vs_control_init();\n\tif (ret < 0) {\n\t\tpr_err(\"can't setup control.\\n\");\n\t\tgoto exit;\n\t}\n\n\tip_vs_protocol_init();\n\n\tret = ip_vs_conn_init();\n\tif (ret < 0) {\n\t\tpr_err(\"can't setup connection table.\\n\");\n\t\tgoto cleanup_protocol;\n\t}\n\n\tret = register_pernet_subsys(&ipvs_core_ops);\t \n\tif (ret < 0)\n\t\tgoto cleanup_conn;\n\n\tret = register_pernet_device(&ipvs_core_dev_ops);\n\tif (ret < 0)\n\t\tgoto cleanup_sub;\n\n\tret = ip_vs_register_nl_ioctl();\n\tif (ret < 0) {\n\t\tpr_err(\"can't register netlink/ioctl.\\n\");\n\t\tgoto cleanup_dev;\n\t}\n\n\tpr_info(\"ipvs loaded.\\n\");\n\n\treturn ret;\n\ncleanup_dev:\n\tunregister_pernet_device(&ipvs_core_dev_ops);\ncleanup_sub:\n\tunregister_pernet_subsys(&ipvs_core_ops);\ncleanup_conn:\n\tip_vs_conn_cleanup();\ncleanup_protocol:\n\tip_vs_protocol_cleanup();\n\tip_vs_control_cleanup();\nexit:\n\treturn ret;\n}\n\nstatic void __exit ip_vs_cleanup(void)\n{\n\tip_vs_unregister_nl_ioctl();\n\tunregister_pernet_device(&ipvs_core_dev_ops);\n\tunregister_pernet_subsys(&ipvs_core_ops);\t \n\tip_vs_conn_cleanup();\n\tip_vs_protocol_cleanup();\n\tip_vs_control_cleanup();\n\t \n\trcu_barrier();\n\tpr_info(\"ipvs unloaded.\\n\");\n}\n\nmodule_init(ip_vs_init);\nmodule_exit(ip_vs_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}