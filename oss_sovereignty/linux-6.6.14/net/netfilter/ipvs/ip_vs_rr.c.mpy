{
  "module_name": "ip_vs_rr.c",
  "hash_id": "ebaeeb896b23d79bb005de2926c99853bde212cd04fd63e1b0848e0c4de08749",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_rr.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <net/ip_vs.h>\n\n\nstatic int ip_vs_rr_init_svc(struct ip_vs_service *svc)\n{\n\tsvc->sched_data = &svc->destinations;\n\treturn 0;\n}\n\n\nstatic int ip_vs_rr_del_dest(struct ip_vs_service *svc, struct ip_vs_dest *dest)\n{\n\tstruct list_head *p;\n\n\tspin_lock_bh(&svc->sched_lock);\n\tp = (struct list_head *) svc->sched_data;\n\t \n\tif (p == &dest->n_list)\n\t\tsvc->sched_data = p->next->prev;\n\tspin_unlock_bh(&svc->sched_lock);\n\treturn 0;\n}\n\n\n \nstatic struct ip_vs_dest *\nip_vs_rr_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\n\t\t  struct ip_vs_iphdr *iph)\n{\n\tstruct list_head *p;\n\tstruct ip_vs_dest *dest, *last;\n\tint pass = 0;\n\n\tIP_VS_DBG(6, \"%s(): Scheduling...\\n\", __func__);\n\n\tspin_lock_bh(&svc->sched_lock);\n\tp = (struct list_head *) svc->sched_data;\n\tlast = dest = list_entry(p, struct ip_vs_dest, n_list);\n\n\tdo {\n\t\tlist_for_each_entry_continue_rcu(dest,\n\t\t\t\t\t\t &svc->destinations,\n\t\t\t\t\t\t n_list) {\n\t\t\tif (!(dest->flags & IP_VS_DEST_F_OVERLOAD) &&\n\t\t\t    atomic_read(&dest->weight) > 0)\n\t\t\t\t \n\t\t\t\tgoto out;\n\t\t\tif (dest == last)\n\t\t\t\tgoto stop;\n\t\t}\n\t\tpass++;\n\t\t \n\t} while (pass < 2 && p != &svc->destinations);\n\nstop:\n\tspin_unlock_bh(&svc->sched_lock);\n\tip_vs_scheduler_err(svc, \"no destination available\");\n\treturn NULL;\n\n  out:\n\tsvc->sched_data = &dest->n_list;\n\tspin_unlock_bh(&svc->sched_lock);\n\tIP_VS_DBG_BUF(6, \"RR: server %s:%u \"\n\t\t      \"activeconns %d refcnt %d weight %d\\n\",\n\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr), ntohs(dest->port),\n\t\t      atomic_read(&dest->activeconns),\n\t\t      refcount_read(&dest->refcnt), atomic_read(&dest->weight));\n\n\treturn dest;\n}\n\n\nstatic struct ip_vs_scheduler ip_vs_rr_scheduler = {\n\t.name =\t\t\t\"rr\",\t\t\t \n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list =\t\tLIST_HEAD_INIT(ip_vs_rr_scheduler.n_list),\n\t.init_service =\t\tip_vs_rr_init_svc,\n\t.add_dest =\t\tNULL,\n\t.del_dest =\t\tip_vs_rr_del_dest,\n\t.schedule =\t\tip_vs_rr_schedule,\n};\n\nstatic int __init ip_vs_rr_init(void)\n{\n\treturn register_ip_vs_scheduler(&ip_vs_rr_scheduler);\n}\n\nstatic void __exit ip_vs_rr_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_rr_scheduler);\n\tsynchronize_rcu();\n}\n\nmodule_init(ip_vs_rr_init);\nmodule_exit(ip_vs_rr_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}