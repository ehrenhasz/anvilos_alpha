{
  "module_name": "ip_vs_pe_sip.c",
  "hash_id": "0172df0ba688fac7834f2ad42c63e1341335d6731864f1bcbd9a835224f8cd94",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_pe_sip.c",
  "human_readable_source": "\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <net/ip_vs.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <linux/netfilter/nf_conntrack_sip.h>\n\n#ifdef CONFIG_IP_VS_DEBUG\nstatic const char *ip_vs_dbg_callid(char *buf, size_t buf_len,\n\t\t\t\t    const char *callid, size_t callid_len,\n\t\t\t\t    int *idx)\n{\n\tsize_t max_len = 64;\n\tsize_t len = min3(max_len, callid_len, buf_len - *idx - 1);\n\tmemcpy(buf + *idx, callid, len);\n\tbuf[*idx+len] = '\\0';\n\t*idx += len + 1;\n\treturn buf + *idx - len;\n}\n\n#define IP_VS_DEBUG_CALLID(callid, len)\t\t\t\t\t\\\n\tip_vs_dbg_callid(ip_vs_dbg_buf, sizeof(ip_vs_dbg_buf),\t\t\\\n\t\t\t callid, len, &ip_vs_dbg_idx)\n#endif\n\nstatic int get_callid(const char *dptr, unsigned int dataoff,\n\t\t      unsigned int datalen,\n\t\t      unsigned int *matchoff, unsigned int *matchlen)\n{\n\t \n\twhile (1) {\n\t\tint ret = ct_sip_get_header(NULL, dptr, dataoff, datalen,\n\t\t\t\t\t    SIP_HDR_CALL_ID, matchoff,\n\t\t\t\t\t    matchlen);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t\tif (!ret)\n\t\t\treturn -EINVAL;\n\t\tdataoff += *matchoff;\n\t}\n\n\t \n\tif (*matchlen > IP_VS_PEDATA_MAXLEN)\n\t\treturn -EINVAL;\n\n\t \n\tif (*matchoff + *matchlen == datalen)\n\t\treturn -EINVAL;\n\n\t \n\tif (*(dptr + *matchoff + *matchlen) != '\\r' &&\n\t    *(dptr + *matchoff + *matchlen) != '\\n')\n\t\treturn -EINVAL;\n\n\tIP_VS_DBG_BUF(9, \"SIP callid %s (%d bytes)\\n\",\n\t\t      IP_VS_DEBUG_CALLID(dptr + *matchoff, *matchlen),\n\t\t      *matchlen);\n\treturn 0;\n}\n\nstatic int\nip_vs_sip_fill_param(struct ip_vs_conn_param *p, struct sk_buff *skb)\n{\n\tstruct ip_vs_iphdr iph;\n\tunsigned int dataoff, datalen, matchoff, matchlen;\n\tconst char *dptr;\n\tint retc;\n\n\tretc = ip_vs_fill_iph_skb(p->af, skb, false, &iph);\n\n\t \n\tif (!retc || iph.protocol != IPPROTO_UDP)\n\t\treturn -EINVAL;\n\t \n\tdataoff = iph.len + sizeof(struct udphdr);\n\n\tif (dataoff >= skb->len)\n\t\treturn -EINVAL;\n\tretc = skb_linearize(skb);\n\tif (retc < 0)\n\t\treturn retc;\n\tdptr = skb->data + dataoff;\n\tdatalen = skb->len - dataoff;\n\n\tif (get_callid(dptr, 0, datalen, &matchoff, &matchlen))\n\t\treturn -EINVAL;\n\n\t \n\tp->pe_data = kmemdup(dptr + matchoff, matchlen, GFP_ATOMIC);\n\tif (!p->pe_data)\n\t\treturn -ENOMEM;\n\n\tp->pe_data_len = matchlen;\n\n\treturn 0;\n}\n\nstatic bool ip_vs_sip_ct_match(const struct ip_vs_conn_param *p,\n\t\t\t\t  struct ip_vs_conn *ct)\n\n{\n\tbool ret = false;\n\n\tif (ct->af == p->af &&\n\t    ip_vs_addr_equal(p->af, p->caddr, &ct->caddr) &&\n\t     \n\t    ip_vs_addr_equal(p->protocol == IPPROTO_IP ? AF_UNSPEC : p->af,\n\t\t\t     p->vaddr, &ct->vaddr) &&\n\t    ct->vport == p->vport &&\n\t    ct->flags & IP_VS_CONN_F_TEMPLATE &&\n\t    ct->protocol == p->protocol &&\n\t    ct->pe_data && ct->pe_data_len == p->pe_data_len &&\n\t    !memcmp(ct->pe_data, p->pe_data, p->pe_data_len))\n\t\tret = true;\n\n\tIP_VS_DBG_BUF(9, \"SIP template match %s %s->%s:%d %s\\n\",\n\t\t      ip_vs_proto_name(p->protocol),\n\t\t      IP_VS_DEBUG_CALLID(p->pe_data, p->pe_data_len),\n\t\t      IP_VS_DBG_ADDR(p->af, p->vaddr), ntohs(p->vport),\n\t\t      ret ? \"hit\" : \"not hit\");\n\n\treturn ret;\n}\n\nstatic u32 ip_vs_sip_hashkey_raw(const struct ip_vs_conn_param *p,\n\t\t\t\t u32 initval, bool inverse)\n{\n\treturn jhash(p->pe_data, p->pe_data_len, initval);\n}\n\nstatic int ip_vs_sip_show_pe_data(const struct ip_vs_conn *cp, char *buf)\n{\n\tmemcpy(buf, cp->pe_data, cp->pe_data_len);\n\treturn cp->pe_data_len;\n}\n\nstatic struct ip_vs_conn *\nip_vs_sip_conn_out(struct ip_vs_service *svc,\n\t\t   struct ip_vs_dest *dest,\n\t\t   struct sk_buff *skb,\n\t\t   const struct ip_vs_iphdr *iph,\n\t\t   __be16 dport,\n\t\t   __be16 cport)\n{\n\tif (likely(iph->protocol == IPPROTO_UDP))\n\t\treturn ip_vs_new_conn_out(svc, dest, skb, iph, dport, cport);\n\t \n\treturn NULL;\n}\n\nstatic struct ip_vs_pe ip_vs_sip_pe =\n{\n\t.name =\t\t\t\"sip\",\n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list =\t\tLIST_HEAD_INIT(ip_vs_sip_pe.n_list),\n\t.fill_param =\t\tip_vs_sip_fill_param,\n\t.ct_match =\t\tip_vs_sip_ct_match,\n\t.hashkey_raw =\t\tip_vs_sip_hashkey_raw,\n\t.show_pe_data =\t\tip_vs_sip_show_pe_data,\n\t.conn_out =\t\tip_vs_sip_conn_out,\n};\n\nstatic int __init ip_vs_sip_init(void)\n{\n\treturn register_ip_vs_pe(&ip_vs_sip_pe);\n}\n\nstatic void __exit ip_vs_sip_cleanup(void)\n{\n\tunregister_ip_vs_pe(&ip_vs_sip_pe);\n\tsynchronize_rcu();\n}\n\nmodule_init(ip_vs_sip_init);\nmodule_exit(ip_vs_sip_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}