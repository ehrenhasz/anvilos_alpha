{
  "module_name": "ip_vs_ftp.c",
  "hash_id": "29c57d66d18aba8de7458aa59dadc45053c699207766a7f3cbf78c264bf4101f",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_ftp.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/ctype.h>\n#include <linux/inet.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/netfilter.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_nat_helper.h>\n#include <linux/gfp.h>\n#include <net/protocol.h>\n#include <net/tcp.h>\n#include <asm/unaligned.h>\n\n#include <net/ip_vs.h>\n\n\n#define SERVER_STRING_PASV \"227 \"\n#define CLIENT_STRING_PORT \"PORT\"\n#define SERVER_STRING_EPSV \"229 \"\n#define CLIENT_STRING_EPRT \"EPRT\"\n\nenum {\n\tIP_VS_FTP_ACTIVE = 0,\n\tIP_VS_FTP_PORT = 0,\n\tIP_VS_FTP_PASV,\n\tIP_VS_FTP_EPRT,\n\tIP_VS_FTP_EPSV,\n};\n\n \nstatic unsigned int ports_count = 1;\nstatic unsigned short ports[IP_VS_APP_MAX_PORTS] = {21, 0};\nmodule_param_array(ports, ushort, &ports_count, 0444);\nMODULE_PARM_DESC(ports, \"Ports to monitor for FTP control commands\");\n\n\nstatic char *ip_vs_ftp_data_ptr(struct sk_buff *skb, struct ip_vs_iphdr *ipvsh)\n{\n\tstruct tcphdr *th = (struct tcphdr *)((char *)skb->data + ipvsh->len);\n\n\tif ((th->doff << 2) < sizeof(struct tcphdr))\n\t\treturn NULL;\n\n\treturn (char *)th + (th->doff << 2);\n}\n\nstatic int\nip_vs_ftp_init_conn(struct ip_vs_app *app, struct ip_vs_conn *cp)\n{\n\t \n\tcp->flags |= IP_VS_CONN_F_NFCT;\n\treturn 0;\n}\n\n\nstatic int\nip_vs_ftp_done_conn(struct ip_vs_app *app, struct ip_vs_conn *cp)\n{\n\treturn 0;\n}\n\n\n \nstatic int ip_vs_ftp_get_addrport(char *data, char *data_limit,\n\t\t\t\t  const char *pattern, size_t plen,\n\t\t\t\t  char skip, bool ext, int mode,\n\t\t\t\t  union nf_inet_addr *addr, __be16 *port,\n\t\t\t\t  __u16 af, char **start, char **end)\n{\n\tchar *s, c;\n\tunsigned char p[6];\n\tchar edelim;\n\t__u16 hport;\n\tint i = 0;\n\n\tif (data_limit - data < plen) {\n\t\t \n\t\tif (strncasecmp(data, pattern, data_limit - data) == 0)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (strncasecmp(data, pattern, plen) != 0) {\n\t\treturn 0;\n\t}\n\ts = data + plen;\n\tif (skip) {\n\t\tbool found = false;\n\n\t\tfor (;; s++) {\n\t\t\tif (s == data_limit)\n\t\t\t\treturn -1;\n\t\t\tif (!found) {\n\t\t\t\t \n\t\t\t\tif (!ext && isdigit(*s))\n\t\t\t\t\tbreak;\n\t\t\t\tif (*s == skip)\n\t\t\t\t\tfound = true;\n\t\t\t} else if (*s != skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (!ext) {\n\t\tp[0] = 0;\n\t\tfor (data = s; ; data++) {\n\t\t\tif (data == data_limit)\n\t\t\t\treturn -1;\n\t\t\tc = *data;\n\t\t\tif (isdigit(c)) {\n\t\t\t\tp[i] = p[i]*10 + c - '0';\n\t\t\t} else if (c == ',' && i < 5) {\n\t\t\t\ti++;\n\t\t\t\tp[i] = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i != 5)\n\t\t\treturn -1;\n\n\t\t*start = s;\n\t\t*end = data;\n\t\taddr->ip = get_unaligned((__be32 *) p);\n\t\t*port = get_unaligned((__be16 *) (p + 4));\n\t\treturn 1;\n\t}\n\tif (s == data_limit)\n\t\treturn -1;\n\t*start = s;\n\tedelim = *s++;\n\tif (edelim < 33 || edelim > 126)\n\t\treturn -1;\n\tif (s == data_limit)\n\t\treturn -1;\n\tif (*s == edelim) {\n\t\t \n\t\tif (mode != IP_VS_FTP_EPSV)\n\t\t\treturn -1;\n\t\ts++;\n\t\tif (s == data_limit)\n\t\t\treturn -1;\n\t\t \n\t\tif (*s != edelim)\n\t\t\treturn -1;\n\t\t \n\t\ts++;\n\t} else {\n\t\tconst char *ep;\n\n\t\t \n\t\tif (af == AF_INET6 && *s != '2')\n\t\t\treturn -1;\n\t\tif (af == AF_INET && *s != '1')\n\t\t\treturn -1;\n\t\ts++;\n\t\tif (s == data_limit)\n\t\t\treturn -1;\n\t\tif (*s != edelim)\n\t\t\treturn -1;\n\t\ts++;\n\t\tif (s == data_limit)\n\t\t\treturn -1;\n\t\tif (af == AF_INET6) {\n\t\t\tif (in6_pton(s, data_limit - s, (u8 *)addr, edelim,\n\t\t\t\t     &ep) <= 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (in4_pton(s, data_limit - s, (u8 *)addr, edelim,\n\t\t\t\t     &ep) <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\ts = (char *) ep;\n\t\tif (s == data_limit)\n\t\t\treturn -1;\n\t\tif (*s != edelim)\n\t\t\treturn -1;\n\t\ts++;\n\t}\n\tfor (hport = 0; ; s++)\n\t{\n\t\tif (s == data_limit)\n\t\t\treturn -1;\n\t\tif (!isdigit(*s))\n\t\t\tbreak;\n\t\thport = hport * 10 + *s - '0';\n\t}\n\tif (s == data_limit || !hport || *s != edelim)\n\t\treturn -1;\n\ts++;\n\t*end = s;\n\t*port = htons(hport);\n\treturn 1;\n}\n\n \nstatic int ip_vs_ftp_out(struct ip_vs_app *app, struct ip_vs_conn *cp,\n\t\t\t struct sk_buff *skb, int *diff,\n\t\t\t struct ip_vs_iphdr *ipvsh)\n{\n\tchar *data, *data_limit;\n\tchar *start, *end;\n\tunion nf_inet_addr from;\n\t__be16 port;\n\tstruct ip_vs_conn *n_cp;\n\tchar buf[24];\t\t \n\tunsigned int buf_len;\n\tint ret = 0;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\t*diff = 0;\n\n\t \n\tif (cp->state != IP_VS_TCP_S_ESTABLISHED)\n\t\treturn 1;\n\n\t \n\tif (skb_ensure_writable(skb, skb->len))\n\t\treturn 0;\n\n\tif (cp->app_data == (void *) IP_VS_FTP_PASV) {\n\t\tdata = ip_vs_ftp_data_ptr(skb, ipvsh);\n\t\tdata_limit = skb_tail_pointer(skb);\n\n\t\tif (!data || data >= data_limit)\n\t\t\treturn 1;\n\n\t\tif (ip_vs_ftp_get_addrport(data, data_limit,\n\t\t\t\t\t   SERVER_STRING_PASV,\n\t\t\t\t\t   sizeof(SERVER_STRING_PASV)-1,\n\t\t\t\t\t   '(', false, IP_VS_FTP_PASV,\n\t\t\t\t\t   &from, &port, cp->af,\n\t\t\t\t\t   &start, &end) != 1)\n\t\t\treturn 1;\n\n\t\tIP_VS_DBG(7, \"PASV response (%pI4:%u) -> %pI4:%u detected\\n\",\n\t\t\t  &from.ip, ntohs(port), &cp->caddr.ip, 0);\n\t} else if (cp->app_data == (void *) IP_VS_FTP_EPSV) {\n\t\tdata = ip_vs_ftp_data_ptr(skb, ipvsh);\n\t\tdata_limit = skb_tail_pointer(skb);\n\n\t\tif (!data || data >= data_limit)\n\t\t\treturn 1;\n\n\t\t \n\t\tfrom = cp->daddr;\n\t\tif (ip_vs_ftp_get_addrport(data, data_limit,\n\t\t\t\t\t   SERVER_STRING_EPSV,\n\t\t\t\t\t   sizeof(SERVER_STRING_EPSV)-1,\n\t\t\t\t\t   '(', true, IP_VS_FTP_EPSV,\n\t\t\t\t\t   &from, &port, cp->af,\n\t\t\t\t\t   &start, &end) != 1)\n\t\t\treturn 1;\n\n\t\tIP_VS_DBG_BUF(7, \"EPSV response (%s:%u) -> %s:%u detected\\n\",\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &from), ntohs(port),\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr), 0);\n\t} else {\n\t\treturn 1;\n\t}\n\n\t \n\t{\n\t\tstruct ip_vs_conn_param p;\n\n\t\tip_vs_conn_fill_param(cp->ipvs, cp->af,\n\t\t\t\t      ipvsh->protocol, &from, port,\n\t\t\t\t      &cp->caddr, 0, &p);\n\t\tn_cp = ip_vs_conn_out_get(&p);\n\t}\n\tif (!n_cp) {\n\t\tstruct ip_vs_conn_param p;\n\n\t\tip_vs_conn_fill_param(cp->ipvs,\n\t\t\t\t      cp->af, ipvsh->protocol, &cp->caddr,\n\t\t\t\t      0, &cp->vaddr, port, &p);\n\t\tn_cp = ip_vs_conn_new(&p, cp->af, &from, port,\n\t\t\t\t      IP_VS_CONN_F_NO_CPORT |\n\t\t\t\t      IP_VS_CONN_F_NFCT,\n\t\t\t\t      cp->dest, skb->mark);\n\t\tif (!n_cp)\n\t\t\treturn 0;\n\n\t\t \n\t\tip_vs_control_add(n_cp, cp);\n\t}\n\n\t \n\tif (cp->app_data == (void *) IP_VS_FTP_PASV) {\n\t\tfrom.ip = n_cp->vaddr.ip;\n\t\tport = n_cp->vport;\n\t\tsnprintf(buf, sizeof(buf), \"%u,%u,%u,%u,%u,%u\",\n\t\t\t ((unsigned char *)&from.ip)[0],\n\t\t\t ((unsigned char *)&from.ip)[1],\n\t\t\t ((unsigned char *)&from.ip)[2],\n\t\t\t ((unsigned char *)&from.ip)[3],\n\t\t\t ntohs(port) >> 8,\n\t\t\t ntohs(port) & 0xFF);\n\t} else if (cp->app_data == (void *) IP_VS_FTP_EPSV) {\n\t\tfrom = n_cp->vaddr;\n\t\tport = n_cp->vport;\n\t\t \n\t\tsnprintf(buf, sizeof(buf), \"|||%u|\",\n\t\t\t ntohs(port));\n\t} else {\n\t\t*buf = 0;\n\t}\n\tbuf_len = strlen(buf);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct) {\n\t\tbool mangled;\n\n\t\t \n\t\tmangled = nf_nat_mangle_tcp_packet(skb, ct, ctinfo,\n\t\t\t\t\t\t   ipvsh->len,\n\t\t\t\t\t\t   start - data,\n\t\t\t\t\t\t   end - start,\n\t\t\t\t\t\t   buf, buf_len);\n\t\tif (mangled) {\n\t\t\tip_vs_nfct_expect_related(skb, ct, n_cp,\n\t\t\t\t\t\t  ipvsh->protocol, 0, 0);\n\t\t\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t \n\t\t\tret = 1;\n\t\t}\n\t}\n\n\t \n\n\tcp->app_data = (void *) IP_VS_FTP_ACTIVE;\n\tip_vs_tcp_conn_listen(n_cp);\n\tip_vs_conn_put(n_cp);\n\treturn ret;\n}\n\n\n \nstatic int ip_vs_ftp_in(struct ip_vs_app *app, struct ip_vs_conn *cp,\n\t\t\tstruct sk_buff *skb, int *diff,\n\t\t\tstruct ip_vs_iphdr *ipvsh)\n{\n\tchar *data, *data_start, *data_limit;\n\tchar *start, *end;\n\tunion nf_inet_addr to;\n\t__be16 port;\n\tstruct ip_vs_conn *n_cp;\n\n\t \n\t*diff = 0;\n\n\t \n\tif (cp->state != IP_VS_TCP_S_ESTABLISHED)\n\t\treturn 1;\n\n\t \n\tif (skb_ensure_writable(skb, skb->len))\n\t\treturn 0;\n\n\tdata = data_start = ip_vs_ftp_data_ptr(skb, ipvsh);\n\tdata_limit = skb_tail_pointer(skb);\n\tif (!data || data >= data_limit)\n\t\treturn 1;\n\n\twhile (data <= data_limit - 6) {\n\t\tif (cp->af == AF_INET &&\n\t\t    strncasecmp(data, \"PASV\\r\\n\", 6) == 0) {\n\t\t\t \n\t\t\tIP_VS_DBG(7, \"got PASV at %td of %td\\n\",\n\t\t\t\t  data - data_start,\n\t\t\t\t  data_limit - data_start);\n\t\t\tcp->app_data = (void *) IP_VS_FTP_PASV;\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tif (strncasecmp(data, \"EPSV\", 4) == 0 &&\n\t\t    (data[4] == ' ' || data[4] == '\\r')) {\n\t\t\tif (data[4] == ' ') {\n\t\t\t\tchar proto = data[5];\n\n\t\t\t\tif (data > data_limit - 7 || data[6] != '\\r')\n\t\t\t\t\treturn 1;\n\n#ifdef CONFIG_IP_VS_IPV6\n\t\t\t\tif (cp->af == AF_INET6 && proto == '2') {\n\t\t\t\t} else\n#endif\n\t\t\t\tif (cp->af == AF_INET && proto == '1') {\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tIP_VS_DBG(7, \"got EPSV at %td of %td\\n\",\n\t\t\t\t  data - data_start,\n\t\t\t\t  data_limit - data_start);\n\t\t\tcp->app_data = (void *) IP_VS_FTP_EPSV;\n\t\t\treturn 1;\n\t\t}\n\n\t\tdata++;\n\t}\n\n\t \n\tif (cp->af == AF_INET &&\n\t    ip_vs_ftp_get_addrport(data_start, data_limit,\n\t\t\t\t   CLIENT_STRING_PORT,\n\t\t\t\t   sizeof(CLIENT_STRING_PORT)-1,\n\t\t\t\t   ' ', false, IP_VS_FTP_PORT,\n\t\t\t\t   &to, &port, cp->af,\n\t\t\t\t   &start, &end) == 1) {\n\n\t\tIP_VS_DBG(7, \"PORT %pI4:%u detected\\n\", &to.ip, ntohs(port));\n\n\t\t \n\t\tIP_VS_DBG(7, \"protocol %s %pI4:%u %pI4:%u\\n\",\n\t\t\t  ip_vs_proto_name(ipvsh->protocol),\n\t\t\t  &to.ip, ntohs(port), &cp->vaddr.ip,\n\t\t\t  ntohs(cp->vport)-1);\n\t} else if (ip_vs_ftp_get_addrport(data_start, data_limit,\n\t\t\t\t\t  CLIENT_STRING_EPRT,\n\t\t\t\t\t  sizeof(CLIENT_STRING_EPRT)-1,\n\t\t\t\t\t  ' ', true, IP_VS_FTP_EPRT,\n\t\t\t\t\t  &to, &port, cp->af,\n\t\t\t\t\t  &start, &end) == 1) {\n\n\t\tIP_VS_DBG_BUF(7, \"EPRT %s:%u detected\\n\",\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &to), ntohs(port));\n\n\t\t \n\t\tIP_VS_DBG_BUF(7, \"protocol %s %s:%u %s:%u\\n\",\n\t\t\t      ip_vs_proto_name(ipvsh->protocol),\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &to), ntohs(port),\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr),\n\t\t\t      ntohs(cp->vport)-1);\n\t} else {\n\t\treturn 1;\n\t}\n\n\t \n\tcp->app_data = (void *) IP_VS_FTP_ACTIVE;\n\n\t{\n\t\tstruct ip_vs_conn_param p;\n\t\tip_vs_conn_fill_param(cp->ipvs, cp->af,\n\t\t\t\t      ipvsh->protocol, &to, port, &cp->vaddr,\n\t\t\t\t      htons(ntohs(cp->vport)-1), &p);\n\t\tn_cp = ip_vs_conn_in_get(&p);\n\t\tif (!n_cp) {\n\t\t\tn_cp = ip_vs_conn_new(&p, cp->af, &cp->daddr,\n\t\t\t\t\t      htons(ntohs(cp->dport)-1),\n\t\t\t\t\t      IP_VS_CONN_F_NFCT, cp->dest,\n\t\t\t\t\t      skb->mark);\n\t\t\tif (!n_cp)\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tip_vs_control_add(n_cp, cp);\n\t\t}\n\t}\n\n\t \n\tip_vs_tcp_conn_listen(n_cp);\n\tip_vs_conn_put(n_cp);\n\n\treturn 1;\n}\n\n\nstatic struct ip_vs_app ip_vs_ftp = {\n\t.name =\t\t\"ftp\",\n\t.type =\t\tIP_VS_APP_TYPE_FTP,\n\t.protocol =\tIPPROTO_TCP,\n\t.module =\tTHIS_MODULE,\n\t.incs_list =\tLIST_HEAD_INIT(ip_vs_ftp.incs_list),\n\t.init_conn =\tip_vs_ftp_init_conn,\n\t.done_conn =\tip_vs_ftp_done_conn,\n\t.bind_conn =\tNULL,\n\t.unbind_conn =\tNULL,\n\t.pkt_out =\tip_vs_ftp_out,\n\t.pkt_in =\tip_vs_ftp_in,\n};\n\n \nstatic int __net_init __ip_vs_ftp_init(struct net *net)\n{\n\tint i, ret;\n\tstruct ip_vs_app *app;\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tif (!ipvs)\n\t\treturn -ENOENT;\n\n\tapp = register_ip_vs_app(ipvs, &ip_vs_ftp);\n\tif (IS_ERR(app))\n\t\treturn PTR_ERR(app);\n\n\tfor (i = 0; i < ports_count; i++) {\n\t\tif (!ports[i])\n\t\t\tcontinue;\n\t\tret = register_ip_vs_app_inc(ipvs, app, app->protocol, ports[i]);\n\t\tif (ret)\n\t\t\tgoto err_unreg;\n\t}\n\treturn 0;\n\nerr_unreg:\n\tunregister_ip_vs_app(ipvs, &ip_vs_ftp);\n\treturn ret;\n}\n \nstatic void __ip_vs_ftp_exit(struct net *net)\n{\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tif (!ipvs)\n\t\treturn;\n\n\tunregister_ip_vs_app(ipvs, &ip_vs_ftp);\n}\n\nstatic struct pernet_operations ip_vs_ftp_ops = {\n\t.init = __ip_vs_ftp_init,\n\t.exit = __ip_vs_ftp_exit,\n};\n\nstatic int __init ip_vs_ftp_init(void)\n{\n\t \n\treturn register_pernet_subsys(&ip_vs_ftp_ops);\n}\n\n \nstatic void __exit ip_vs_ftp_exit(void)\n{\n\tunregister_pernet_subsys(&ip_vs_ftp_ops);\n\t \n}\n\n\nmodule_init(ip_vs_ftp_init);\nmodule_exit(ip_vs_ftp_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}