{
  "module_name": "ip_vs_sh.c",
  "hash_id": "a3068881506935e63f5b831d0f362c228357068671a997107ecc08596f5b90e3",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_sh.c",
  "human_readable_source": "\n \n\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n\n#include <net/ip_vs.h>\n\n#include <net/tcp.h>\n#include <linux/udp.h>\n#include <linux/sctp.h>\n\n\n \nstruct ip_vs_sh_bucket {\n\tstruct ip_vs_dest __rcu\t*dest;\t \n};\n\n \n#ifndef CONFIG_IP_VS_SH_TAB_BITS\n#define CONFIG_IP_VS_SH_TAB_BITS        8\n#endif\n#define IP_VS_SH_TAB_BITS               CONFIG_IP_VS_SH_TAB_BITS\n#define IP_VS_SH_TAB_SIZE               (1 << IP_VS_SH_TAB_BITS)\n#define IP_VS_SH_TAB_MASK               (IP_VS_SH_TAB_SIZE - 1)\n\nstruct ip_vs_sh_state {\n\tstruct rcu_head\t\t\trcu_head;\n\tstruct ip_vs_sh_bucket\t\tbuckets[IP_VS_SH_TAB_SIZE];\n};\n\n \nstatic inline bool is_unavailable(struct ip_vs_dest *dest)\n{\n\treturn atomic_read(&dest->weight) <= 0 ||\n\t       dest->flags & IP_VS_DEST_F_OVERLOAD;\n}\n\n \nstatic inline unsigned int\nip_vs_sh_hashkey(int af, const union nf_inet_addr *addr,\n\t\t __be16 port, unsigned int offset)\n{\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\treturn (offset + hash_32(ntohs(port) + ntohl(addr_fold),\n\t\t\t\t IP_VS_SH_TAB_BITS)) &\n\t\tIP_VS_SH_TAB_MASK;\n}\n\n\n \nstatic inline struct ip_vs_dest *\nip_vs_sh_get(struct ip_vs_service *svc, struct ip_vs_sh_state *s,\n\t     const union nf_inet_addr *addr, __be16 port)\n{\n\tunsigned int hash = ip_vs_sh_hashkey(svc->af, addr, port, 0);\n\tstruct ip_vs_dest *dest = rcu_dereference(s->buckets[hash].dest);\n\n\treturn (!dest || is_unavailable(dest)) ? NULL : dest;\n}\n\n\n \nstatic inline struct ip_vs_dest *\nip_vs_sh_get_fallback(struct ip_vs_service *svc, struct ip_vs_sh_state *s,\n\t\t      const union nf_inet_addr *addr, __be16 port)\n{\n\tunsigned int offset, roffset;\n\tunsigned int hash, ihash;\n\tstruct ip_vs_dest *dest;\n\n\t \n\tihash = ip_vs_sh_hashkey(svc->af, addr, port, 0);\n\tdest = rcu_dereference(s->buckets[ihash].dest);\n\tif (!dest)\n\t\treturn NULL;\n\tif (!is_unavailable(dest))\n\t\treturn dest;\n\n\tIP_VS_DBG_BUF(6, \"SH: selected unavailable server %s:%d, reselecting\",\n\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr), ntohs(dest->port));\n\n\t \n\tfor (offset = 0; offset < IP_VS_SH_TAB_SIZE; offset++) {\n\t\troffset = (offset + ihash) % IP_VS_SH_TAB_SIZE;\n\t\thash = ip_vs_sh_hashkey(svc->af, addr, port, roffset);\n\t\tdest = rcu_dereference(s->buckets[hash].dest);\n\t\tif (!dest)\n\t\t\tbreak;\n\t\tif (!is_unavailable(dest))\n\t\t\treturn dest;\n\t\tIP_VS_DBG_BUF(6, \"SH: selected unavailable \"\n\t\t\t      \"server %s:%d (offset %d), reselecting\",\n\t\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t\t      ntohs(dest->port), roffset);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int\nip_vs_sh_reassign(struct ip_vs_sh_state *s, struct ip_vs_service *svc)\n{\n\tint i;\n\tstruct ip_vs_sh_bucket *b;\n\tstruct list_head *p;\n\tstruct ip_vs_dest *dest;\n\tint d_count;\n\tbool empty;\n\n\tb = &s->buckets[0];\n\tp = &svc->destinations;\n\tempty = list_empty(p);\n\td_count = 0;\n\tfor (i=0; i<IP_VS_SH_TAB_SIZE; i++) {\n\t\tdest = rcu_dereference_protected(b->dest, 1);\n\t\tif (dest)\n\t\t\tip_vs_dest_put(dest);\n\t\tif (empty)\n\t\t\tRCU_INIT_POINTER(b->dest, NULL);\n\t\telse {\n\t\t\tif (p == &svc->destinations)\n\t\t\t\tp = p->next;\n\n\t\t\tdest = list_entry(p, struct ip_vs_dest, n_list);\n\t\t\tip_vs_dest_hold(dest);\n\t\t\tRCU_INIT_POINTER(b->dest, dest);\n\n\t\t\tIP_VS_DBG_BUF(6, \"assigned i: %d dest: %s weight: %d\\n\",\n\t\t\t\t      i, IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t\t\t      atomic_read(&dest->weight));\n\n\t\t\t \n\t\t\tif (++d_count >= atomic_read(&dest->weight)) {\n\t\t\t\tp = p->next;\n\t\t\t\td_count = 0;\n\t\t\t}\n\n\t\t}\n\t\tb++;\n\t}\n\treturn 0;\n}\n\n\n \nstatic void ip_vs_sh_flush(struct ip_vs_sh_state *s)\n{\n\tint i;\n\tstruct ip_vs_sh_bucket *b;\n\tstruct ip_vs_dest *dest;\n\n\tb = &s->buckets[0];\n\tfor (i=0; i<IP_VS_SH_TAB_SIZE; i++) {\n\t\tdest = rcu_dereference_protected(b->dest, 1);\n\t\tif (dest) {\n\t\t\tip_vs_dest_put(dest);\n\t\t\tRCU_INIT_POINTER(b->dest, NULL);\n\t\t}\n\t\tb++;\n\t}\n}\n\n\nstatic int ip_vs_sh_init_svc(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_sh_state *s;\n\n\t \n\ts = kzalloc(sizeof(struct ip_vs_sh_state), GFP_KERNEL);\n\tif (s == NULL)\n\t\treturn -ENOMEM;\n\n\tsvc->sched_data = s;\n\tIP_VS_DBG(6, \"SH hash table (memory=%zdbytes) allocated for \"\n\t\t  \"current service\\n\",\n\t\t  sizeof(struct ip_vs_sh_bucket)*IP_VS_SH_TAB_SIZE);\n\n\t \n\tip_vs_sh_reassign(s, svc);\n\n\treturn 0;\n}\n\n\nstatic void ip_vs_sh_done_svc(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_sh_state *s = svc->sched_data;\n\n\t \n\tip_vs_sh_flush(s);\n\n\t \n\tkfree_rcu(s, rcu_head);\n\tIP_VS_DBG(6, \"SH hash table (memory=%zdbytes) released\\n\",\n\t\t  sizeof(struct ip_vs_sh_bucket)*IP_VS_SH_TAB_SIZE);\n}\n\n\nstatic int ip_vs_sh_dest_changed(struct ip_vs_service *svc,\n\t\t\t\t struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_sh_state *s = svc->sched_data;\n\n\t \n\tip_vs_sh_reassign(s, svc);\n\n\treturn 0;\n}\n\n\n \nstatic inline __be16\nip_vs_sh_get_port(const struct sk_buff *skb, struct ip_vs_iphdr *iph)\n{\n\t__be16 _ports[2], *ports;\n\n\t \n\tswitch (iph->protocol) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_SCTP:\n\t\tports = skb_header_pointer(skb, iph->len, sizeof(_ports),\n\t\t\t\t\t   &_ports);\n\t\tif (unlikely(!ports))\n\t\t\treturn 0;\n\n\t\tif (likely(!ip_vs_iph_inverse(iph)))\n\t\t\treturn ports[0];\n\t\telse\n\t\t\treturn ports[1];\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n \nstatic struct ip_vs_dest *\nip_vs_sh_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\n\t\t  struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_dest *dest;\n\tstruct ip_vs_sh_state *s;\n\t__be16 port = 0;\n\tconst union nf_inet_addr *hash_addr;\n\n\thash_addr = ip_vs_iph_inverse(iph) ? &iph->daddr : &iph->saddr;\n\n\tIP_VS_DBG(6, \"ip_vs_sh_schedule(): Scheduling...\\n\");\n\n\tif (svc->flags & IP_VS_SVC_F_SCHED_SH_PORT)\n\t\tport = ip_vs_sh_get_port(skb, iph);\n\n\ts = (struct ip_vs_sh_state *) svc->sched_data;\n\n\tif (svc->flags & IP_VS_SVC_F_SCHED_SH_FALLBACK)\n\t\tdest = ip_vs_sh_get_fallback(svc, s, hash_addr, port);\n\telse\n\t\tdest = ip_vs_sh_get(svc, s, hash_addr, port);\n\n\tif (!dest) {\n\t\tip_vs_scheduler_err(svc, \"no destination available\");\n\t\treturn NULL;\n\t}\n\n\tIP_VS_DBG_BUF(6, \"SH: source IP address %s --> server %s:%d\\n\",\n\t\t      IP_VS_DBG_ADDR(svc->af, hash_addr),\n\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t      ntohs(dest->port));\n\n\treturn dest;\n}\n\n\n \nstatic struct ip_vs_scheduler ip_vs_sh_scheduler =\n{\n\t.name =\t\t\t\"sh\",\n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list\t =\t\tLIST_HEAD_INIT(ip_vs_sh_scheduler.n_list),\n\t.init_service =\t\tip_vs_sh_init_svc,\n\t.done_service =\t\tip_vs_sh_done_svc,\n\t.add_dest =\t\tip_vs_sh_dest_changed,\n\t.del_dest =\t\tip_vs_sh_dest_changed,\n\t.upd_dest =\t\tip_vs_sh_dest_changed,\n\t.schedule =\t\tip_vs_sh_schedule,\n};\n\n\nstatic int __init ip_vs_sh_init(void)\n{\n\treturn register_ip_vs_scheduler(&ip_vs_sh_scheduler);\n}\n\n\nstatic void __exit ip_vs_sh_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_sh_scheduler);\n\tsynchronize_rcu();\n}\n\n\nmodule_init(ip_vs_sh_init);\nmodule_exit(ip_vs_sh_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}