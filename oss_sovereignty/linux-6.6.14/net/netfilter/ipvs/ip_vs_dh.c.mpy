{
  "module_name": "ip_vs_dh.c",
  "hash_id": "9dc081783d266e28eed4588217a9afbda5b86f35d9ce998e898efc2229681f17",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_dh.c",
  "human_readable_source": "\n \n\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/hash.h>\n\n#include <net/ip_vs.h>\n\n\n \nstruct ip_vs_dh_bucket {\n\tstruct ip_vs_dest __rcu\t*dest;\t \n};\n\n \n#ifndef CONFIG_IP_VS_DH_TAB_BITS\n#define CONFIG_IP_VS_DH_TAB_BITS        8\n#endif\n#define IP_VS_DH_TAB_BITS               CONFIG_IP_VS_DH_TAB_BITS\n#define IP_VS_DH_TAB_SIZE               (1 << IP_VS_DH_TAB_BITS)\n#define IP_VS_DH_TAB_MASK               (IP_VS_DH_TAB_SIZE - 1)\n\nstruct ip_vs_dh_state {\n\tstruct ip_vs_dh_bucket\t\tbuckets[IP_VS_DH_TAB_SIZE];\n\tstruct rcu_head\t\t\trcu_head;\n};\n\n \nstatic inline unsigned int ip_vs_dh_hashkey(int af, const union nf_inet_addr *addr)\n{\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\treturn hash_32(ntohl(addr_fold), IP_VS_DH_TAB_BITS);\n}\n\n\n \nstatic inline struct ip_vs_dest *\nip_vs_dh_get(int af, struct ip_vs_dh_state *s, const union nf_inet_addr *addr)\n{\n\treturn rcu_dereference(s->buckets[ip_vs_dh_hashkey(af, addr)].dest);\n}\n\n\n \nstatic int\nip_vs_dh_reassign(struct ip_vs_dh_state *s, struct ip_vs_service *svc)\n{\n\tint i;\n\tstruct ip_vs_dh_bucket *b;\n\tstruct list_head *p;\n\tstruct ip_vs_dest *dest;\n\tbool empty;\n\n\tb = &s->buckets[0];\n\tp = &svc->destinations;\n\tempty = list_empty(p);\n\tfor (i=0; i<IP_VS_DH_TAB_SIZE; i++) {\n\t\tdest = rcu_dereference_protected(b->dest, 1);\n\t\tif (dest)\n\t\t\tip_vs_dest_put(dest);\n\t\tif (empty)\n\t\t\tRCU_INIT_POINTER(b->dest, NULL);\n\t\telse {\n\t\t\tif (p == &svc->destinations)\n\t\t\t\tp = p->next;\n\n\t\t\tdest = list_entry(p, struct ip_vs_dest, n_list);\n\t\t\tip_vs_dest_hold(dest);\n\t\t\tRCU_INIT_POINTER(b->dest, dest);\n\n\t\t\tp = p->next;\n\t\t}\n\t\tb++;\n\t}\n\treturn 0;\n}\n\n\n \nstatic void ip_vs_dh_flush(struct ip_vs_dh_state *s)\n{\n\tint i;\n\tstruct ip_vs_dh_bucket *b;\n\tstruct ip_vs_dest *dest;\n\n\tb = &s->buckets[0];\n\tfor (i=0; i<IP_VS_DH_TAB_SIZE; i++) {\n\t\tdest = rcu_dereference_protected(b->dest, 1);\n\t\tif (dest) {\n\t\t\tip_vs_dest_put(dest);\n\t\t\tRCU_INIT_POINTER(b->dest, NULL);\n\t\t}\n\t\tb++;\n\t}\n}\n\n\nstatic int ip_vs_dh_init_svc(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dh_state *s;\n\n\t \n\ts = kzalloc(sizeof(struct ip_vs_dh_state), GFP_KERNEL);\n\tif (s == NULL)\n\t\treturn -ENOMEM;\n\n\tsvc->sched_data = s;\n\tIP_VS_DBG(6, \"DH hash table (memory=%zdbytes) allocated for \"\n\t\t  \"current service\\n\",\n\t\t  sizeof(struct ip_vs_dh_bucket)*IP_VS_DH_TAB_SIZE);\n\n\t \n\tip_vs_dh_reassign(s, svc);\n\n\treturn 0;\n}\n\n\nstatic void ip_vs_dh_done_svc(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dh_state *s = svc->sched_data;\n\n\t \n\tip_vs_dh_flush(s);\n\n\t \n\tkfree_rcu(s, rcu_head);\n\tIP_VS_DBG(6, \"DH hash table (memory=%zdbytes) released\\n\",\n\t\t  sizeof(struct ip_vs_dh_bucket)*IP_VS_DH_TAB_SIZE);\n}\n\n\nstatic int ip_vs_dh_dest_changed(struct ip_vs_service *svc,\n\t\t\t\t struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_dh_state *s = svc->sched_data;\n\n\t \n\tip_vs_dh_reassign(s, svc);\n\n\treturn 0;\n}\n\n\n \nstatic inline int is_overloaded(struct ip_vs_dest *dest)\n{\n\treturn dest->flags & IP_VS_DEST_F_OVERLOAD;\n}\n\n\n \nstatic struct ip_vs_dest *\nip_vs_dh_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\n\t\t  struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_dest *dest;\n\tstruct ip_vs_dh_state *s;\n\n\tIP_VS_DBG(6, \"%s(): Scheduling...\\n\", __func__);\n\n\ts = (struct ip_vs_dh_state *) svc->sched_data;\n\tdest = ip_vs_dh_get(svc->af, s, &iph->daddr);\n\tif (!dest\n\t    || !(dest->flags & IP_VS_DEST_F_AVAILABLE)\n\t    || atomic_read(&dest->weight) <= 0\n\t    || is_overloaded(dest)) {\n\t\tip_vs_scheduler_err(svc, \"no destination available\");\n\t\treturn NULL;\n\t}\n\n\tIP_VS_DBG_BUF(6, \"DH: destination IP address %s --> server %s:%d\\n\",\n\t\t      IP_VS_DBG_ADDR(svc->af, &iph->daddr),\n\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t      ntohs(dest->port));\n\n\treturn dest;\n}\n\n\n \nstatic struct ip_vs_scheduler ip_vs_dh_scheduler =\n{\n\t.name =\t\t\t\"dh\",\n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list =\t\tLIST_HEAD_INIT(ip_vs_dh_scheduler.n_list),\n\t.init_service =\t\tip_vs_dh_init_svc,\n\t.done_service =\t\tip_vs_dh_done_svc,\n\t.add_dest =\t\tip_vs_dh_dest_changed,\n\t.del_dest =\t\tip_vs_dh_dest_changed,\n\t.schedule =\t\tip_vs_dh_schedule,\n};\n\n\nstatic int __init ip_vs_dh_init(void)\n{\n\treturn register_ip_vs_scheduler(&ip_vs_dh_scheduler);\n}\n\n\nstatic void __exit ip_vs_dh_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_dh_scheduler);\n\tsynchronize_rcu();\n}\n\n\nmodule_init(ip_vs_dh_init);\nmodule_exit(ip_vs_dh_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}