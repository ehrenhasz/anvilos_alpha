{
  "module_name": "ip_vs_nq.c",
  "hash_id": "9532a260d475d8ef60de33ec76ab820d871432e37fe7438690b6371ceb82013d",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_nq.c",
  "human_readable_source": "\n \n\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <net/ip_vs.h>\n\n\nstatic inline int\nip_vs_nq_dest_overhead(struct ip_vs_dest *dest)\n{\n\t \n\treturn atomic_read(&dest->activeconns) + 1;\n}\n\n\n \nstatic struct ip_vs_dest *\nip_vs_nq_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\n\t\t  struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_dest *dest, *least = NULL;\n\tint loh = 0, doh;\n\n\tIP_VS_DBG(6, \"%s(): Scheduling...\\n\", __func__);\n\n\t \n\n\tlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\n\n\t\tif (dest->flags & IP_VS_DEST_F_OVERLOAD ||\n\t\t    !atomic_read(&dest->weight))\n\t\t\tcontinue;\n\n\t\tdoh = ip_vs_nq_dest_overhead(dest);\n\n\t\t \n\t\tif (atomic_read(&dest->activeconns) == 0) {\n\t\t\tleast = dest;\n\t\t\tloh = doh;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!least ||\n\t\t    ((__s64)loh * atomic_read(&dest->weight) >\n\t\t     (__s64)doh * atomic_read(&least->weight))) {\n\t\t\tleast = dest;\n\t\t\tloh = doh;\n\t\t}\n\t}\n\n\tif (!least) {\n\t\tip_vs_scheduler_err(svc, \"no destination available\");\n\t\treturn NULL;\n\t}\n\n  out:\n\tIP_VS_DBG_BUF(6, \"NQ: server %s:%u \"\n\t\t      \"activeconns %d refcnt %d weight %d overhead %d\\n\",\n\t\t      IP_VS_DBG_ADDR(least->af, &least->addr),\n\t\t      ntohs(least->port),\n\t\t      atomic_read(&least->activeconns),\n\t\t      refcount_read(&least->refcnt),\n\t\t      atomic_read(&least->weight), loh);\n\n\treturn least;\n}\n\n\nstatic struct ip_vs_scheduler ip_vs_nq_scheduler =\n{\n\t.name =\t\t\t\"nq\",\n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list =\t\tLIST_HEAD_INIT(ip_vs_nq_scheduler.n_list),\n\t.schedule =\t\tip_vs_nq_schedule,\n};\n\n\nstatic int __init ip_vs_nq_init(void)\n{\n\treturn register_ip_vs_scheduler(&ip_vs_nq_scheduler);\n}\n\nstatic void __exit ip_vs_nq_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_nq_scheduler);\n\tsynchronize_rcu();\n}\n\nmodule_init(ip_vs_nq_init);\nmodule_exit(ip_vs_nq_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}