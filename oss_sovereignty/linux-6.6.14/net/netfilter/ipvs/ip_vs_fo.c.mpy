{
  "module_name": "ip_vs_fo.c",
  "hash_id": "fce942e646775119c486708e30376da1355031987ccbb3e00193a303b4289b82",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_fo.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <net/ip_vs.h>\n\n \nstatic struct ip_vs_dest *\nip_vs_fo_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\n\t\t  struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_dest *dest, *hweight = NULL;\n\tint hw = 0;  \n\n\tIP_VS_DBG(6, \"ip_vs_fo_schedule(): Scheduling...\\n\");\n\n\t \n\tlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\n\t\tif (!(dest->flags & IP_VS_DEST_F_OVERLOAD) &&\n\t\t    atomic_read(&dest->weight) > hw) {\n\t\t\thweight = dest;\n\t\t\thw = atomic_read(&dest->weight);\n\t\t}\n\t}\n\n\tif (hweight) {\n\t\tIP_VS_DBG_BUF(6, \"FO: server %s:%u activeconns %d weight %d\\n\",\n\t\t\t      IP_VS_DBG_ADDR(hweight->af, &hweight->addr),\n\t\t\t      ntohs(hweight->port),\n\t\t\t      atomic_read(&hweight->activeconns),\n\t\t\t      atomic_read(&hweight->weight));\n\t\treturn hweight;\n\t}\n\n\tip_vs_scheduler_err(svc, \"no destination available\");\n\treturn NULL;\n}\n\nstatic struct ip_vs_scheduler ip_vs_fo_scheduler = {\n\t.name =\t\t\t\"fo\",\n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list =\t\tLIST_HEAD_INIT(ip_vs_fo_scheduler.n_list),\n\t.schedule =\t\tip_vs_fo_schedule,\n};\n\nstatic int __init ip_vs_fo_init(void)\n{\n\treturn register_ip_vs_scheduler(&ip_vs_fo_scheduler);\n}\n\nstatic void __exit ip_vs_fo_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_fo_scheduler);\n\tsynchronize_rcu();\n}\n\nmodule_init(ip_vs_fo_init);\nmodule_exit(ip_vs_fo_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}