{
  "module_name": "ip_vs_app.c",
  "hash_id": "4056230ec816c73a5484cc933d6e4e4856fda3fc70148a253e98cbd02bf6dedb",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_app.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n#include <net/net_namespace.h>\n#include <net/protocol.h>\n#include <net/tcp.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n\n#include <net/ip_vs.h>\n\nEXPORT_SYMBOL(register_ip_vs_app);\nEXPORT_SYMBOL(unregister_ip_vs_app);\nEXPORT_SYMBOL(register_ip_vs_app_inc);\n\nstatic DEFINE_MUTEX(__ip_vs_app_mutex);\n\n \nstatic inline int ip_vs_app_get(struct ip_vs_app *app)\n{\n\treturn try_module_get(app->module);\n}\n\n\nstatic inline void ip_vs_app_put(struct ip_vs_app *app)\n{\n\tmodule_put(app->module);\n}\n\nstatic void ip_vs_app_inc_destroy(struct ip_vs_app *inc)\n{\n\tkfree(inc->timeout_table);\n\tkfree(inc);\n}\n\nstatic void ip_vs_app_inc_rcu_free(struct rcu_head *head)\n{\n\tstruct ip_vs_app *inc = container_of(head, struct ip_vs_app, rcu_head);\n\n\tip_vs_app_inc_destroy(inc);\n}\n\n \nstatic int\nip_vs_app_inc_new(struct netns_ipvs *ipvs, struct ip_vs_app *app, __u16 proto,\n\t\t  __u16 port)\n{\n\tstruct ip_vs_protocol *pp;\n\tstruct ip_vs_app *inc;\n\tint ret;\n\n\tif (!(pp = ip_vs_proto_get(proto)))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (!pp->unregister_app)\n\t\treturn -EOPNOTSUPP;\n\n\tinc = kmemdup(app, sizeof(*inc), GFP_KERNEL);\n\tif (!inc)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&inc->p_list);\n\tINIT_LIST_HEAD(&inc->incs_list);\n\tinc->app = app;\n\tinc->port = htons(port);\n\tatomic_set(&inc->usecnt, 0);\n\n\tif (app->timeouts) {\n\t\tinc->timeout_table =\n\t\t\tip_vs_create_timeout_table(app->timeouts,\n\t\t\t\t\t\t   app->timeouts_size);\n\t\tif (!inc->timeout_table) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = pp->register_app(ipvs, inc);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_add(&inc->a_list, &app->incs_list);\n\tIP_VS_DBG(9, \"%s App %s:%u registered\\n\",\n\t\t  pp->name, inc->name, ntohs(inc->port));\n\n\treturn 0;\n\n  out:\n\tip_vs_app_inc_destroy(inc);\n\treturn ret;\n}\n\n\n \nstatic void\nip_vs_app_inc_release(struct netns_ipvs *ipvs, struct ip_vs_app *inc)\n{\n\tstruct ip_vs_protocol *pp;\n\n\tif (!(pp = ip_vs_proto_get(inc->protocol)))\n\t\treturn;\n\n\tif (pp->unregister_app)\n\t\tpp->unregister_app(ipvs, inc);\n\n\tIP_VS_DBG(9, \"%s App %s:%u unregistered\\n\",\n\t\t  pp->name, inc->name, ntohs(inc->port));\n\n\tlist_del(&inc->a_list);\n\n\tcall_rcu(&inc->rcu_head, ip_vs_app_inc_rcu_free);\n}\n\n\n \nint ip_vs_app_inc_get(struct ip_vs_app *inc)\n{\n\tint result;\n\n\tresult = ip_vs_app_get(inc->app);\n\tif (result)\n\t\tatomic_inc(&inc->usecnt);\n\treturn result;\n}\n\n\n \nvoid ip_vs_app_inc_put(struct ip_vs_app *inc)\n{\n\tatomic_dec(&inc->usecnt);\n\tip_vs_app_put(inc->app);\n}\n\n\n \nint\nregister_ip_vs_app_inc(struct netns_ipvs *ipvs, struct ip_vs_app *app, __u16 proto,\n\t\t       __u16 port)\n{\n\tint result;\n\n\tmutex_lock(&__ip_vs_app_mutex);\n\n\tresult = ip_vs_app_inc_new(ipvs, app, proto, port);\n\n\tmutex_unlock(&__ip_vs_app_mutex);\n\n\treturn result;\n}\n\n\n \nstruct ip_vs_app *register_ip_vs_app(struct netns_ipvs *ipvs, struct ip_vs_app *app)\n{\n\tstruct ip_vs_app *a;\n\tint err = 0;\n\n\tmutex_lock(&__ip_vs_app_mutex);\n\n\t \n\tif (!ip_vs_use_count_inc()) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_for_each_entry(a, &ipvs->app_list, a_list) {\n\t\tif (!strcmp(app->name, a->name)) {\n\t\t\terr = -EEXIST;\n\t\t\t \n\t\t\tip_vs_use_count_dec();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\ta = kmemdup(app, sizeof(*app), GFP_KERNEL);\n\tif (!a) {\n\t\terr = -ENOMEM;\n\t\t \n\t\tip_vs_use_count_dec();\n\t\tgoto out_unlock;\n\t}\n\tINIT_LIST_HEAD(&a->incs_list);\n\tlist_add(&a->a_list, &ipvs->app_list);\n\nout_unlock:\n\tmutex_unlock(&__ip_vs_app_mutex);\n\n\treturn err ? ERR_PTR(err) : a;\n}\n\n\n \nvoid unregister_ip_vs_app(struct netns_ipvs *ipvs, struct ip_vs_app *app)\n{\n\tstruct ip_vs_app *a, *anxt, *inc, *nxt;\n\n\tmutex_lock(&__ip_vs_app_mutex);\n\n\tlist_for_each_entry_safe(a, anxt, &ipvs->app_list, a_list) {\n\t\tif (app && strcmp(app->name, a->name))\n\t\t\tcontinue;\n\t\tlist_for_each_entry_safe(inc, nxt, &a->incs_list, a_list) {\n\t\t\tip_vs_app_inc_release(ipvs, inc);\n\t\t}\n\n\t\tlist_del(&a->a_list);\n\t\tkfree(a);\n\n\t\t \n\t\tip_vs_use_count_dec();\n\t}\n\n\tmutex_unlock(&__ip_vs_app_mutex);\n}\n\n\n \nint ip_vs_bind_app(struct ip_vs_conn *cp,\n\t\t   struct ip_vs_protocol *pp)\n{\n\treturn pp->app_conn_bind(cp);\n}\n\n\n \nvoid ip_vs_unbind_app(struct ip_vs_conn *cp)\n{\n\tstruct ip_vs_app *inc = cp->app;\n\n\tif (!inc)\n\t\treturn;\n\n\tif (inc->unbind_conn)\n\t\tinc->unbind_conn(inc, cp);\n\tif (inc->done_conn)\n\t\tinc->done_conn(inc, cp);\n\tip_vs_app_inc_put(inc);\n\tcp->app = NULL;\n}\n\n\n \nstatic inline void vs_fix_seq(const struct ip_vs_seq *vseq, struct tcphdr *th)\n{\n\t__u32 seq = ntohl(th->seq);\n\n\t \n\tif (vseq->delta || vseq->previous_delta) {\n\t\tif(after(seq, vseq->init_seq)) {\n\t\t\tth->seq = htonl(seq + vseq->delta);\n\t\t\tIP_VS_DBG(9, \"%s(): added delta (%d) to seq\\n\",\n\t\t\t\t  __func__, vseq->delta);\n\t\t} else {\n\t\t\tth->seq = htonl(seq + vseq->previous_delta);\n\t\t\tIP_VS_DBG(9, \"%s(): added previous_delta (%d) to seq\\n\",\n\t\t\t\t  __func__, vseq->previous_delta);\n\t\t}\n\t}\n}\n\n\n \nstatic inline void\nvs_fix_ack_seq(const struct ip_vs_seq *vseq, struct tcphdr *th)\n{\n\t__u32 ack_seq = ntohl(th->ack_seq);\n\n\t \n\tif (vseq->delta || vseq->previous_delta) {\n\t\t \n\t\tif(after(ack_seq, vseq->init_seq+vseq->delta)) {\n\t\t\tth->ack_seq = htonl(ack_seq - vseq->delta);\n\t\t\tIP_VS_DBG(9, \"%s(): subtracted delta \"\n\t\t\t\t  \"(%d) from ack_seq\\n\", __func__, vseq->delta);\n\n\t\t} else {\n\t\t\tth->ack_seq = htonl(ack_seq - vseq->previous_delta);\n\t\t\tIP_VS_DBG(9, \"%s(): subtracted \"\n\t\t\t\t  \"previous_delta (%d) from ack_seq\\n\",\n\t\t\t\t  __func__, vseq->previous_delta);\n\t\t}\n\t}\n}\n\n\n \nstatic inline void vs_seq_update(struct ip_vs_conn *cp, struct ip_vs_seq *vseq,\n\t\t\t\t unsigned int flag, __u32 seq, int diff)\n{\n\t \n\tspin_lock_bh(&cp->lock);\n\tif (!(cp->flags & flag) || after(seq, vseq->init_seq)) {\n\t\tvseq->previous_delta = vseq->delta;\n\t\tvseq->delta += diff;\n\t\tvseq->init_seq = seq;\n\t\tcp->flags |= flag;\n\t}\n\tspin_unlock_bh(&cp->lock);\n}\n\nstatic inline int app_tcp_pkt_out(struct ip_vs_conn *cp, struct sk_buff *skb,\n\t\t\t\t  struct ip_vs_app *app,\n\t\t\t\t  struct ip_vs_iphdr *ipvsh)\n{\n\tint diff;\n\tconst unsigned int tcp_offset = ip_hdrlen(skb);\n\tstruct tcphdr *th;\n\t__u32 seq;\n\n\tif (skb_ensure_writable(skb, tcp_offset + sizeof(*th)))\n\t\treturn 0;\n\n\tth = (struct tcphdr *)(skb_network_header(skb) + tcp_offset);\n\n\t \n\tseq = ntohl(th->seq);\n\n\t \n\tif (cp->flags & IP_VS_CONN_F_OUT_SEQ)\n\t\tvs_fix_seq(&cp->out_seq, th);\n\tif (cp->flags & IP_VS_CONN_F_IN_SEQ)\n\t\tvs_fix_ack_seq(&cp->in_seq, th);\n\n\t \n\tif (app->pkt_out == NULL)\n\t\treturn 1;\n\n\tif (!app->pkt_out(app, cp, skb, &diff, ipvsh))\n\t\treturn 0;\n\n\t \n\tif (diff != 0)\n\t\tvs_seq_update(cp, &cp->out_seq,\n\t\t\t      IP_VS_CONN_F_OUT_SEQ, seq, diff);\n\n\treturn 1;\n}\n\n \nint ip_vs_app_pkt_out(struct ip_vs_conn *cp, struct sk_buff *skb,\n\t\t      struct ip_vs_iphdr *ipvsh)\n{\n\tstruct ip_vs_app *app;\n\n\t \n\tif ((app = cp->app) == NULL)\n\t\treturn 1;\n\n\t \n\tif (cp->protocol == IPPROTO_TCP)\n\t\treturn app_tcp_pkt_out(cp, skb, app, ipvsh);\n\n\t \n\tif (app->pkt_out == NULL)\n\t\treturn 1;\n\n\treturn app->pkt_out(app, cp, skb, NULL, ipvsh);\n}\n\n\nstatic inline int app_tcp_pkt_in(struct ip_vs_conn *cp, struct sk_buff *skb,\n\t\t\t\t struct ip_vs_app *app,\n\t\t\t\t struct ip_vs_iphdr *ipvsh)\n{\n\tint diff;\n\tconst unsigned int tcp_offset = ip_hdrlen(skb);\n\tstruct tcphdr *th;\n\t__u32 seq;\n\n\tif (skb_ensure_writable(skb, tcp_offset + sizeof(*th)))\n\t\treturn 0;\n\n\tth = (struct tcphdr *)(skb_network_header(skb) + tcp_offset);\n\n\t \n\tseq = ntohl(th->seq);\n\n\t \n\tif (cp->flags & IP_VS_CONN_F_IN_SEQ)\n\t\tvs_fix_seq(&cp->in_seq, th);\n\tif (cp->flags & IP_VS_CONN_F_OUT_SEQ)\n\t\tvs_fix_ack_seq(&cp->out_seq, th);\n\n\t \n\tif (app->pkt_in == NULL)\n\t\treturn 1;\n\n\tif (!app->pkt_in(app, cp, skb, &diff, ipvsh))\n\t\treturn 0;\n\n\t \n\tif (diff != 0)\n\t\tvs_seq_update(cp, &cp->in_seq,\n\t\t\t      IP_VS_CONN_F_IN_SEQ, seq, diff);\n\n\treturn 1;\n}\n\n \nint ip_vs_app_pkt_in(struct ip_vs_conn *cp, struct sk_buff *skb,\n\t\t     struct ip_vs_iphdr *ipvsh)\n{\n\tstruct ip_vs_app *app;\n\n\t \n\tif ((app = cp->app) == NULL)\n\t\treturn 1;\n\n\t \n\tif (cp->protocol == IPPROTO_TCP)\n\t\treturn app_tcp_pkt_in(cp, skb, app, ipvsh);\n\n\t \n\tif (app->pkt_in == NULL)\n\t\treturn 1;\n\n\treturn app->pkt_in(app, cp, skb, NULL, ipvsh);\n}\n\n\n#ifdef CONFIG_PROC_FS\n \n\nstatic struct ip_vs_app *ip_vs_app_idx(struct netns_ipvs *ipvs, loff_t pos)\n{\n\tstruct ip_vs_app *app, *inc;\n\n\tlist_for_each_entry(app, &ipvs->app_list, a_list) {\n\t\tlist_for_each_entry(inc, &app->incs_list, a_list) {\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn inc;\n\t\t}\n\t}\n\treturn NULL;\n\n}\n\nstatic void *ip_vs_app_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tmutex_lock(&__ip_vs_app_mutex);\n\n\treturn *pos ? ip_vs_app_idx(ipvs, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *ip_vs_app_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ip_vs_app *inc, *app;\n\tstruct list_head *e;\n\tstruct net *net = seq_file_net(seq);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn ip_vs_app_idx(ipvs, 0);\n\n\tinc = v;\n\tapp = inc->app;\n\n\tif ((e = inc->a_list.next) != &app->incs_list)\n\t\treturn list_entry(e, struct ip_vs_app, a_list);\n\n\t \n\tfor (e = app->a_list.next; e != &ipvs->app_list; e = e->next) {\n\t\tapp = list_entry(e, struct ip_vs_app, a_list);\n\t\tlist_for_each_entry(inc, &app->incs_list, a_list) {\n\t\t\treturn inc;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void ip_vs_app_seq_stop(struct seq_file *seq, void *v)\n{\n\tmutex_unlock(&__ip_vs_app_mutex);\n}\n\nstatic int ip_vs_app_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"prot port    usecnt name\\n\");\n\telse {\n\t\tconst struct ip_vs_app *inc = v;\n\n\t\tseq_printf(seq, \"%-3s  %-7u %-6d %-17s\\n\",\n\t\t\t   ip_vs_proto_name(inc->protocol),\n\t\t\t   ntohs(inc->port),\n\t\t\t   atomic_read(&inc->usecnt),\n\t\t\t   inc->name);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ip_vs_app_seq_ops = {\n\t.start = ip_vs_app_seq_start,\n\t.next  = ip_vs_app_seq_next,\n\t.stop  = ip_vs_app_seq_stop,\n\t.show  = ip_vs_app_seq_show,\n};\n#endif\n\nint __net_init ip_vs_app_net_init(struct netns_ipvs *ipvs)\n{\n\tINIT_LIST_HEAD(&ipvs->app_list);\n#ifdef CONFIG_PROC_FS\n\tif (!proc_create_net(\"ip_vs_app\", 0, ipvs->net->proc_net,\n\t\t\t     &ip_vs_app_seq_ops,\n\t\t\t     sizeof(struct seq_net_private)))\n\t\treturn -ENOMEM;\n#endif\n\treturn 0;\n}\n\nvoid __net_exit ip_vs_app_net_cleanup(struct netns_ipvs *ipvs)\n{\n\tunregister_ip_vs_app(ipvs, NULL  );\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ip_vs_app\", ipvs->net->proc_net);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}