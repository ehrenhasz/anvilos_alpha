{
  "module_name": "ip_vs_sync.c",
  "hash_id": "a918127c889d733247ca7411fb6238d4cb338576a36505fdb0fd2c1507dd5e74",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_sync.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/inetdevice.h>\n#include <linux/net.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/skbuff.h>\n#include <linux/in.h>\n#include <linux/igmp.h>                  \n#include <linux/udp.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n\n#include <asm/unaligned.h>\t\t \n\n#include <net/ip.h>\n#include <net/sock.h>\n\n#include <net/ip_vs.h>\n\n#define IP_VS_SYNC_GROUP 0xe0000051     \n#define IP_VS_SYNC_PORT  8848           \n\n#define SYNC_PROTO_VER  1\t\t \n\nstatic struct lock_class_key __ipvs_sync_key;\n \nstruct ip_vs_sync_conn_v0 {\n\t__u8\t\t\treserved;\n\n\t \n\t__u8\t\t\tprotocol;        \n\t__be16\t\t\tcport;\n\t__be16                  vport;\n\t__be16                  dport;\n\t__be32                  caddr;           \n\t__be32                  vaddr;           \n\t__be32                  daddr;           \n\n\t \n\t__be16                  flags;           \n\t__be16                  state;           \n\n\t \n};\n\nstruct ip_vs_sync_conn_options {\n\tstruct ip_vs_seq        in_seq;          \n\tstruct ip_vs_seq        out_seq;         \n};\n\n \n\n \nstruct ip_vs_sync_v4 {\n\t__u8\t\t\ttype;\n\t__u8\t\t\tprotocol;\t \n\t__be16\t\t\tver_size;\t \n\t \n\t__be32\t\t\tflags;\t\t \n\t__be16\t\t\tstate;\t\t \n\t \n\t__be16\t\t\tcport;\n\t__be16\t\t\tvport;\n\t__be16\t\t\tdport;\n\t__be32\t\t\tfwmark;\t\t \n\t__be32\t\t\ttimeout;\t \n\t__be32\t\t\tcaddr;\t\t \n\t__be32\t\t\tvaddr;\t\t \n\t__be32\t\t\tdaddr;\t\t \n\t \n\t \n};\n \nstruct ip_vs_sync_v6 {\n\t__u8\t\t\ttype;\n\t__u8\t\t\tprotocol;\t \n\t__be16\t\t\tver_size;\t \n\t \n\t__be32\t\t\tflags;\t\t \n\t__be16\t\t\tstate;\t\t \n\t \n\t__be16\t\t\tcport;\n\t__be16\t\t\tvport;\n\t__be16\t\t\tdport;\n\t__be32\t\t\tfwmark;\t\t \n\t__be32\t\t\ttimeout;\t \n\tstruct in6_addr\t\tcaddr;\t\t \n\tstruct in6_addr\t\tvaddr;\t\t \n\tstruct in6_addr\t\tdaddr;\t\t \n\t \n\t \n};\n\nunion ip_vs_sync_conn {\n\tstruct ip_vs_sync_v4\tv4;\n\tstruct ip_vs_sync_v6\tv6;\n};\n\n \n#define STYPE_INET6\t\t0\n#define STYPE_F_INET6\t\t(1 << STYPE_INET6)\n\n#define SVER_SHIFT\t\t12\t\t \n#define SVER_MASK\t\t0x0fff\t\t \n\n#define IPVS_OPT_SEQ_DATA\t1\n#define IPVS_OPT_PE_DATA\t2\n#define IPVS_OPT_PE_NAME\t3\n#define IPVS_OPT_PARAM\t\t7\n\n#define IPVS_OPT_F_SEQ_DATA\t(1 << (IPVS_OPT_SEQ_DATA-1))\n#define IPVS_OPT_F_PE_DATA\t(1 << (IPVS_OPT_PE_DATA-1))\n#define IPVS_OPT_F_PE_NAME\t(1 << (IPVS_OPT_PE_NAME-1))\n#define IPVS_OPT_F_PARAM\t(1 << (IPVS_OPT_PARAM-1))\n\nstruct ip_vs_sync_thread_data {\n\tstruct task_struct *task;\n\tstruct netns_ipvs *ipvs;\n\tstruct socket *sock;\n\tchar *buf;\n\tint id;\n};\n\n \n#define SIMPLE_CONN_SIZE  (sizeof(struct ip_vs_sync_conn_v0))\n#define FULL_CONN_SIZE  \\\n(sizeof(struct ip_vs_sync_conn_v0) + sizeof(struct ip_vs_sync_conn_options))\n\n\n \n\n \nstruct ip_vs_sync_mesg_v0 {\n\t__u8                    nr_conns;\n\t__u8                    syncid;\n\t__be16                  size;\n\n\t \n};\n\n \nstruct ip_vs_sync_mesg {\n\t__u8\t\t\treserved;\t \n\t__u8\t\t\tsyncid;\n\t__be16\t\t\tsize;\n\t__u8\t\t\tnr_conns;\n\t__s8\t\t\tversion;\t \n\t__u16\t\t\tspare;\n\t \n};\n\nunion ipvs_sockaddr {\n\tstruct sockaddr_in\tin;\n\tstruct sockaddr_in6\tin6;\n};\n\nstruct ip_vs_sync_buff {\n\tstruct list_head        list;\n\tunsigned long           firstuse;\n\n\t \n\tstruct ip_vs_sync_mesg  *mesg;\n\tunsigned char           *head;\n\tunsigned char           *end;\n};\n\n \nstatic void ntoh_seq(struct ip_vs_seq *no, struct ip_vs_seq *ho)\n{\n\tmemset(ho, 0, sizeof(*ho));\n\tho->init_seq       = get_unaligned_be32(&no->init_seq);\n\tho->delta          = get_unaligned_be32(&no->delta);\n\tho->previous_delta = get_unaligned_be32(&no->previous_delta);\n}\n\n \nstatic void hton_seq(struct ip_vs_seq *ho, struct ip_vs_seq *no)\n{\n\tput_unaligned_be32(ho->init_seq, &no->init_seq);\n\tput_unaligned_be32(ho->delta, &no->delta);\n\tput_unaligned_be32(ho->previous_delta, &no->previous_delta);\n}\n\nstatic inline struct ip_vs_sync_buff *\nsb_dequeue(struct netns_ipvs *ipvs, struct ipvs_master_sync_state *ms)\n{\n\tstruct ip_vs_sync_buff *sb;\n\n\tspin_lock_bh(&ipvs->sync_lock);\n\tif (list_empty(&ms->sync_queue)) {\n\t\tsb = NULL;\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t} else {\n\t\tsb = list_entry(ms->sync_queue.next, struct ip_vs_sync_buff,\n\t\t\t\tlist);\n\t\tlist_del(&sb->list);\n\t\tms->sync_queue_len--;\n\t\tif (!ms->sync_queue_len)\n\t\t\tms->sync_queue_delay = 0;\n\t}\n\tspin_unlock_bh(&ipvs->sync_lock);\n\n\treturn sb;\n}\n\n \nstatic inline struct ip_vs_sync_buff *\nip_vs_sync_buff_create(struct netns_ipvs *ipvs, unsigned int len)\n{\n\tstruct ip_vs_sync_buff *sb;\n\n\tif (!(sb=kmalloc(sizeof(struct ip_vs_sync_buff), GFP_ATOMIC)))\n\t\treturn NULL;\n\n\tlen = max_t(unsigned int, len + sizeof(struct ip_vs_sync_mesg),\n\t\t    ipvs->mcfg.sync_maxlen);\n\tsb->mesg = kmalloc(len, GFP_ATOMIC);\n\tif (!sb->mesg) {\n\t\tkfree(sb);\n\t\treturn NULL;\n\t}\n\tsb->mesg->reserved = 0;   \n\tsb->mesg->version = SYNC_PROTO_VER;\n\tsb->mesg->syncid = ipvs->mcfg.syncid;\n\tsb->mesg->size = htons(sizeof(struct ip_vs_sync_mesg));\n\tsb->mesg->nr_conns = 0;\n\tsb->mesg->spare = 0;\n\tsb->head = (unsigned char *)sb->mesg + sizeof(struct ip_vs_sync_mesg);\n\tsb->end = (unsigned char *)sb->mesg + len;\n\n\tsb->firstuse = jiffies;\n\treturn sb;\n}\n\nstatic inline void ip_vs_sync_buff_release(struct ip_vs_sync_buff *sb)\n{\n\tkfree(sb->mesg);\n\tkfree(sb);\n}\n\nstatic inline void sb_queue_tail(struct netns_ipvs *ipvs,\n\t\t\t\t struct ipvs_master_sync_state *ms)\n{\n\tstruct ip_vs_sync_buff *sb = ms->sync_buff;\n\n\tspin_lock(&ipvs->sync_lock);\n\tif (ipvs->sync_state & IP_VS_STATE_MASTER &&\n\t    ms->sync_queue_len < sysctl_sync_qlen_max(ipvs)) {\n\t\tif (!ms->sync_queue_len)\n\t\t\tschedule_delayed_work(&ms->master_wakeup_work,\n\t\t\t\t\t      max(IPVS_SYNC_SEND_DELAY, 1));\n\t\tms->sync_queue_len++;\n\t\tlist_add_tail(&sb->list, &ms->sync_queue);\n\t\tif ((++ms->sync_queue_delay) == IPVS_SYNC_WAKEUP_RATE) {\n\t\t\tint id = (int)(ms - ipvs->ms);\n\n\t\t\twake_up_process(ipvs->master_tinfo[id].task);\n\t\t}\n\t} else\n\t\tip_vs_sync_buff_release(sb);\n\tspin_unlock(&ipvs->sync_lock);\n}\n\n \nstatic inline struct ip_vs_sync_buff *\nget_curr_sync_buff(struct netns_ipvs *ipvs, struct ipvs_master_sync_state *ms,\n\t\t   unsigned long time)\n{\n\tstruct ip_vs_sync_buff *sb;\n\n\tspin_lock_bh(&ipvs->sync_buff_lock);\n\tsb = ms->sync_buff;\n\tif (sb && time_after_eq(jiffies - sb->firstuse, time)) {\n\t\tms->sync_buff = NULL;\n\t\t__set_current_state(TASK_RUNNING);\n\t} else\n\t\tsb = NULL;\n\tspin_unlock_bh(&ipvs->sync_buff_lock);\n\treturn sb;\n}\n\nstatic inline int\nselect_master_thread_id(struct netns_ipvs *ipvs, struct ip_vs_conn *cp)\n{\n\treturn ((long) cp >> (1 + ilog2(sizeof(*cp)))) & ipvs->threads_mask;\n}\n\n \nstatic inline struct ip_vs_sync_buff *\nip_vs_sync_buff_create_v0(struct netns_ipvs *ipvs, unsigned int len)\n{\n\tstruct ip_vs_sync_buff *sb;\n\tstruct ip_vs_sync_mesg_v0 *mesg;\n\n\tif (!(sb=kmalloc(sizeof(struct ip_vs_sync_buff), GFP_ATOMIC)))\n\t\treturn NULL;\n\n\tlen = max_t(unsigned int, len + sizeof(struct ip_vs_sync_mesg_v0),\n\t\t    ipvs->mcfg.sync_maxlen);\n\tsb->mesg = kmalloc(len, GFP_ATOMIC);\n\tif (!sb->mesg) {\n\t\tkfree(sb);\n\t\treturn NULL;\n\t}\n\tmesg = (struct ip_vs_sync_mesg_v0 *)sb->mesg;\n\tmesg->nr_conns = 0;\n\tmesg->syncid = ipvs->mcfg.syncid;\n\tmesg->size = htons(sizeof(struct ip_vs_sync_mesg_v0));\n\tsb->head = (unsigned char *)mesg + sizeof(struct ip_vs_sync_mesg_v0);\n\tsb->end = (unsigned char *)mesg + len;\n\tsb->firstuse = jiffies;\n\treturn sb;\n}\n\n \nstatic inline bool in_persistence(struct ip_vs_conn *cp)\n{\n\tfor (cp = cp->control; cp; cp = cp->control) {\n\t\tif (cp->flags & IP_VS_CONN_F_TEMPLATE)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic int ip_vs_sync_conn_needed(struct netns_ipvs *ipvs,\n\t\t\t\t  struct ip_vs_conn *cp, int pkts)\n{\n\tunsigned long orig = READ_ONCE(cp->sync_endtime);\n\tunsigned long now = jiffies;\n\tunsigned long n = (now + cp->timeout) & ~3UL;\n\tunsigned int sync_refresh_period;\n\tint sync_period;\n\tint force;\n\n\t \n\tif (unlikely(cp->flags & IP_VS_CONN_F_TEMPLATE))\n\t\tforce = 0;\n\telse if (unlikely(sysctl_sync_persist_mode(ipvs) && in_persistence(cp)))\n\t\treturn 0;\n\telse if (likely(cp->protocol == IPPROTO_TCP)) {\n\t\tif (!((1 << cp->state) &\n\t\t      ((1 << IP_VS_TCP_S_ESTABLISHED) |\n\t\t       (1 << IP_VS_TCP_S_FIN_WAIT) |\n\t\t       (1 << IP_VS_TCP_S_CLOSE) |\n\t\t       (1 << IP_VS_TCP_S_CLOSE_WAIT) |\n\t\t       (1 << IP_VS_TCP_S_TIME_WAIT))))\n\t\t\treturn 0;\n\t\tforce = cp->state != cp->old_state;\n\t\tif (force && cp->state != IP_VS_TCP_S_ESTABLISHED)\n\t\t\tgoto set;\n\t} else if (unlikely(cp->protocol == IPPROTO_SCTP)) {\n\t\tif (!((1 << cp->state) &\n\t\t      ((1 << IP_VS_SCTP_S_ESTABLISHED) |\n\t\t       (1 << IP_VS_SCTP_S_SHUTDOWN_SENT) |\n\t\t       (1 << IP_VS_SCTP_S_SHUTDOWN_RECEIVED) |\n\t\t       (1 << IP_VS_SCTP_S_SHUTDOWN_ACK_SENT) |\n\t\t       (1 << IP_VS_SCTP_S_CLOSED))))\n\t\t\treturn 0;\n\t\tforce = cp->state != cp->old_state;\n\t\tif (force && cp->state != IP_VS_SCTP_S_ESTABLISHED)\n\t\t\tgoto set;\n\t} else {\n\t\t \n\t\tforce = 0;\n\t}\n\n\tsync_refresh_period = sysctl_sync_refresh_period(ipvs);\n\tif (sync_refresh_period > 0) {\n\t\tlong diff = n - orig;\n\t\tlong min_diff = max(cp->timeout >> 1, 10UL * HZ);\n\n\t\t \n\t\tif (abs(diff) < min_t(long, sync_refresh_period, min_diff)) {\n\t\t\tint retries = orig & 3;\n\n\t\t\tif (retries >= sysctl_sync_retries(ipvs))\n\t\t\t\treturn 0;\n\t\t\tif (time_before(now, orig - cp->timeout +\n\t\t\t\t\t(sync_refresh_period >> 3)))\n\t\t\t\treturn 0;\n\t\t\tn |= retries + 1;\n\t\t}\n\t}\n\tsync_period = sysctl_sync_period(ipvs);\n\tif (sync_period > 0) {\n\t\tif (!(cp->flags & IP_VS_CONN_F_TEMPLATE) &&\n\t\t    pkts % sync_period != sysctl_sync_threshold(ipvs))\n\t\t\treturn 0;\n\t} else if (!sync_refresh_period &&\n\t\t   pkts != sysctl_sync_threshold(ipvs))\n\t\treturn 0;\n\nset:\n\tcp->old_state = cp->state;\n\tn = cmpxchg(&cp->sync_endtime, orig, n);\n\treturn n == orig || force;\n}\n\n \nstatic void ip_vs_sync_conn_v0(struct netns_ipvs *ipvs, struct ip_vs_conn *cp,\n\t\t\t       int pkts)\n{\n\tstruct ip_vs_sync_mesg_v0 *m;\n\tstruct ip_vs_sync_conn_v0 *s;\n\tstruct ip_vs_sync_buff *buff;\n\tstruct ipvs_master_sync_state *ms;\n\tint id;\n\tunsigned int len;\n\n\tif (unlikely(cp->af != AF_INET))\n\t\treturn;\n\t \n\tif (cp->flags & IP_VS_CONN_F_ONE_PACKET)\n\t\treturn;\n\n\tif (!ip_vs_sync_conn_needed(ipvs, cp, pkts))\n\t\treturn;\n\n\tspin_lock_bh(&ipvs->sync_buff_lock);\n\tif (!(ipvs->sync_state & IP_VS_STATE_MASTER)) {\n\t\tspin_unlock_bh(&ipvs->sync_buff_lock);\n\t\treturn;\n\t}\n\n\tid = select_master_thread_id(ipvs, cp);\n\tms = &ipvs->ms[id];\n\tbuff = ms->sync_buff;\n\tlen = (cp->flags & IP_VS_CONN_F_SEQ_MASK) ? FULL_CONN_SIZE :\n\t\tSIMPLE_CONN_SIZE;\n\tif (buff) {\n\t\tm = (struct ip_vs_sync_mesg_v0 *) buff->mesg;\n\t\t \n\t\tif (buff->head + len > buff->end || !m->nr_conns) {\n\t\t\tsb_queue_tail(ipvs, ms);\n\t\t\tms->sync_buff = NULL;\n\t\t\tbuff = NULL;\n\t\t}\n\t}\n\tif (!buff) {\n\t\tbuff = ip_vs_sync_buff_create_v0(ipvs, len);\n\t\tif (!buff) {\n\t\t\tspin_unlock_bh(&ipvs->sync_buff_lock);\n\t\t\tpr_err(\"ip_vs_sync_buff_create failed.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tms->sync_buff = buff;\n\t}\n\n\tm = (struct ip_vs_sync_mesg_v0 *) buff->mesg;\n\ts = (struct ip_vs_sync_conn_v0 *) buff->head;\n\n\t \n\ts->reserved = 0;\n\ts->protocol = cp->protocol;\n\ts->cport = cp->cport;\n\ts->vport = cp->vport;\n\ts->dport = cp->dport;\n\ts->caddr = cp->caddr.ip;\n\ts->vaddr = cp->vaddr.ip;\n\ts->daddr = cp->daddr.ip;\n\ts->flags = htons(cp->flags & ~IP_VS_CONN_F_HASHED);\n\ts->state = htons(cp->state);\n\tif (cp->flags & IP_VS_CONN_F_SEQ_MASK) {\n\t\tstruct ip_vs_sync_conn_options *opt =\n\t\t\t(struct ip_vs_sync_conn_options *)&s[1];\n\t\tmemcpy(opt, &cp->sync_conn_opt, sizeof(*opt));\n\t}\n\n\tm->nr_conns++;\n\tm->size = htons(ntohs(m->size) + len);\n\tbuff->head += len;\n\tspin_unlock_bh(&ipvs->sync_buff_lock);\n\n\t \n\tcp = cp->control;\n\tif (cp) {\n\t\tif (cp->flags & IP_VS_CONN_F_TEMPLATE)\n\t\t\tpkts = atomic_inc_return(&cp->in_pkts);\n\t\telse\n\t\t\tpkts = sysctl_sync_threshold(ipvs);\n\t\tip_vs_sync_conn(ipvs, cp, pkts);\n\t}\n}\n\n \nvoid ip_vs_sync_conn(struct netns_ipvs *ipvs, struct ip_vs_conn *cp, int pkts)\n{\n\tstruct ip_vs_sync_mesg *m;\n\tunion ip_vs_sync_conn *s;\n\tstruct ip_vs_sync_buff *buff;\n\tstruct ipvs_master_sync_state *ms;\n\tint id;\n\t__u8 *p;\n\tunsigned int len, pe_name_len, pad;\n\n\t \n\tif (sysctl_sync_ver(ipvs) == 0) {\n\t\tip_vs_sync_conn_v0(ipvs, cp, pkts);\n\t\treturn;\n\t}\n\t \n\tif (cp->flags & IP_VS_CONN_F_ONE_PACKET)\n\t\tgoto control;\nsloop:\n\tif (!ip_vs_sync_conn_needed(ipvs, cp, pkts))\n\t\tgoto control;\n\n\t \n\tpe_name_len = 0;\n\tif (cp->pe_data_len) {\n\t\tif (!cp->pe_data || !cp->dest) {\n\t\t\tIP_VS_ERR_RL(\"SYNC, connection pe_data invalid\\n\");\n\t\t\treturn;\n\t\t}\n\t\tpe_name_len = strnlen(cp->pe->name, IP_VS_PENAME_MAXLEN);\n\t}\n\n\tspin_lock_bh(&ipvs->sync_buff_lock);\n\tif (!(ipvs->sync_state & IP_VS_STATE_MASTER)) {\n\t\tspin_unlock_bh(&ipvs->sync_buff_lock);\n\t\treturn;\n\t}\n\n\tid = select_master_thread_id(ipvs, cp);\n\tms = &ipvs->ms[id];\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (cp->af == AF_INET6)\n\t\tlen = sizeof(struct ip_vs_sync_v6);\n\telse\n#endif\n\t\tlen = sizeof(struct ip_vs_sync_v4);\n\n\tif (cp->flags & IP_VS_CONN_F_SEQ_MASK)\n\t\tlen += sizeof(struct ip_vs_sync_conn_options) + 2;\n\n\tif (cp->pe_data_len)\n\t\tlen += cp->pe_data_len + 2;\t \n\tif (pe_name_len)\n\t\tlen += pe_name_len + 2;\n\n\t \n\tpad = 0;\n\tbuff = ms->sync_buff;\n\tif (buff) {\n\t\tm = buff->mesg;\n\t\tpad = (4 - (size_t) buff->head) & 3;\n\t\t \n\t\tif (buff->head + len + pad > buff->end || m->reserved) {\n\t\t\tsb_queue_tail(ipvs, ms);\n\t\t\tms->sync_buff = NULL;\n\t\t\tbuff = NULL;\n\t\t\tpad = 0;\n\t\t}\n\t}\n\n\tif (!buff) {\n\t\tbuff = ip_vs_sync_buff_create(ipvs, len);\n\t\tif (!buff) {\n\t\t\tspin_unlock_bh(&ipvs->sync_buff_lock);\n\t\t\tpr_err(\"ip_vs_sync_buff_create failed.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tms->sync_buff = buff;\n\t\tm = buff->mesg;\n\t}\n\n\tp = buff->head;\n\tbuff->head += pad + len;\n\tm->size = htons(ntohs(m->size) + pad + len);\n\t \n\twhile (pad--)\n\t\t*(p++) = 0;\n\n\ts = (union ip_vs_sync_conn *)p;\n\n\t \n\ts->v4.type = (cp->af == AF_INET6 ? STYPE_F_INET6 : 0);\n\ts->v4.ver_size = htons(len & SVER_MASK);\t \n\ts->v4.flags = htonl(cp->flags & ~IP_VS_CONN_F_HASHED);\n\ts->v4.state = htons(cp->state);\n\ts->v4.protocol = cp->protocol;\n\ts->v4.cport = cp->cport;\n\ts->v4.vport = cp->vport;\n\ts->v4.dport = cp->dport;\n\ts->v4.fwmark = htonl(cp->fwmark);\n\ts->v4.timeout = htonl(cp->timeout / HZ);\n\tm->nr_conns++;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (cp->af == AF_INET6) {\n\t\tp += sizeof(struct ip_vs_sync_v6);\n\t\ts->v6.caddr = cp->caddr.in6;\n\t\ts->v6.vaddr = cp->vaddr.in6;\n\t\ts->v6.daddr = cp->daddr.in6;\n\t} else\n#endif\n\t{\n\t\tp += sizeof(struct ip_vs_sync_v4);\t \n\t\ts->v4.caddr = cp->caddr.ip;\n\t\ts->v4.vaddr = cp->vaddr.ip;\n\t\ts->v4.daddr = cp->daddr.ip;\n\t}\n\tif (cp->flags & IP_VS_CONN_F_SEQ_MASK) {\n\t\t*(p++) = IPVS_OPT_SEQ_DATA;\n\t\t*(p++) = sizeof(struct ip_vs_sync_conn_options);\n\t\thton_seq((struct ip_vs_seq *)p, &cp->in_seq);\n\t\tp += sizeof(struct ip_vs_seq);\n\t\thton_seq((struct ip_vs_seq *)p, &cp->out_seq);\n\t\tp += sizeof(struct ip_vs_seq);\n\t}\n\t \n\tif (cp->pe_data_len && cp->pe_data) {\n\t\t*(p++) = IPVS_OPT_PE_DATA;\n\t\t*(p++) = cp->pe_data_len;\n\t\tmemcpy(p, cp->pe_data, cp->pe_data_len);\n\t\tp += cp->pe_data_len;\n\t\tif (pe_name_len) {\n\t\t\t \n\t\t\t*(p++) = IPVS_OPT_PE_NAME;\n\t\t\t*(p++) = pe_name_len;\n\t\t\tmemcpy(p, cp->pe->name, pe_name_len);\n\t\t\tp += pe_name_len;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&ipvs->sync_buff_lock);\n\ncontrol:\n\t \n\tcp = cp->control;\n\tif (!cp)\n\t\treturn;\n\tif (cp->flags & IP_VS_CONN_F_TEMPLATE)\n\t\tpkts = atomic_inc_return(&cp->in_pkts);\n\telse\n\t\tpkts = sysctl_sync_threshold(ipvs);\n\tgoto sloop;\n}\n\n \nstatic inline int\nip_vs_conn_fill_param_sync(struct netns_ipvs *ipvs, int af, union ip_vs_sync_conn *sc,\n\t\t\t   struct ip_vs_conn_param *p,\n\t\t\t   __u8 *pe_data, unsigned int pe_data_len,\n\t\t\t   __u8 *pe_name, unsigned int pe_name_len)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\tip_vs_conn_fill_param(ipvs, af, sc->v6.protocol,\n\t\t\t\t      (const union nf_inet_addr *)&sc->v6.caddr,\n\t\t\t\t      sc->v6.cport,\n\t\t\t\t      (const union nf_inet_addr *)&sc->v6.vaddr,\n\t\t\t\t      sc->v6.vport, p);\n\telse\n#endif\n\t\tip_vs_conn_fill_param(ipvs, af, sc->v4.protocol,\n\t\t\t\t      (const union nf_inet_addr *)&sc->v4.caddr,\n\t\t\t\t      sc->v4.cport,\n\t\t\t\t      (const union nf_inet_addr *)&sc->v4.vaddr,\n\t\t\t\t      sc->v4.vport, p);\n\t \n\tif (pe_data_len) {\n\t\tif (pe_name_len) {\n\t\t\tchar buff[IP_VS_PENAME_MAXLEN+1];\n\n\t\t\tmemcpy(buff, pe_name, pe_name_len);\n\t\t\tbuff[pe_name_len]=0;\n\t\t\tp->pe = __ip_vs_pe_getbyname(buff);\n\t\t\tif (!p->pe) {\n\t\t\t\tIP_VS_DBG(3, \"BACKUP, no %s engine found/loaded\\n\",\n\t\t\t\t\t     buff);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tIP_VS_ERR_RL(\"BACKUP, Invalid PE parameters\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tp->pe_data = kmemdup(pe_data, pe_data_len, GFP_ATOMIC);\n\t\tif (!p->pe_data) {\n\t\t\tmodule_put(p->pe->module);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tp->pe_data_len = pe_data_len;\n\t}\n\treturn 0;\n}\n\n \nstatic void ip_vs_proc_conn(struct netns_ipvs *ipvs, struct ip_vs_conn_param *param,\n\t\t\t    unsigned int flags, unsigned int state,\n\t\t\t    unsigned int protocol, unsigned int type,\n\t\t\t    const union nf_inet_addr *daddr, __be16 dport,\n\t\t\t    unsigned long timeout, __u32 fwmark,\n\t\t\t    struct ip_vs_sync_conn_options *opt)\n{\n\tstruct ip_vs_dest *dest;\n\tstruct ip_vs_conn *cp;\n\n\tif (!(flags & IP_VS_CONN_F_TEMPLATE)) {\n\t\tcp = ip_vs_conn_in_get(param);\n\t\tif (cp && ((cp->dport != dport) ||\n\t\t\t   !ip_vs_addr_equal(cp->daf, &cp->daddr, daddr))) {\n\t\t\tif (!(flags & IP_VS_CONN_F_INACTIVE)) {\n\t\t\t\tip_vs_conn_expire_now(cp);\n\t\t\t\t__ip_vs_conn_put(cp);\n\t\t\t\tcp = NULL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t__ip_vs_conn_put(cp);\n\t\t\t\tkfree(param->pe_data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcp = ip_vs_ct_in_get(param);\n\t}\n\n\tif (cp) {\n\t\t \n\t\tkfree(param->pe_data);\n\n\t\tdest = cp->dest;\n\t\tspin_lock_bh(&cp->lock);\n\t\tif ((cp->flags ^ flags) & IP_VS_CONN_F_INACTIVE &&\n\t\t    !(flags & IP_VS_CONN_F_TEMPLATE) && dest) {\n\t\t\tif (flags & IP_VS_CONN_F_INACTIVE) {\n\t\t\t\tatomic_dec(&dest->activeconns);\n\t\t\t\tatomic_inc(&dest->inactconns);\n\t\t\t} else {\n\t\t\t\tatomic_inc(&dest->activeconns);\n\t\t\t\tatomic_dec(&dest->inactconns);\n\t\t\t}\n\t\t}\n\t\tflags &= IP_VS_CONN_F_BACKUP_UPD_MASK;\n\t\tflags |= cp->flags & ~IP_VS_CONN_F_BACKUP_UPD_MASK;\n\t\tcp->flags = flags;\n\t\tspin_unlock_bh(&cp->lock);\n\t\tif (!dest)\n\t\t\tip_vs_try_bind_dest(cp);\n\t} else {\n\t\t \n\t\trcu_read_lock();\n\t\t \n\t\tdest = ip_vs_find_dest(ipvs, type, type, daddr, dport,\n\t\t\t\t       param->vaddr, param->vport, protocol,\n\t\t\t\t       fwmark, flags);\n\n\t\tcp = ip_vs_conn_new(param, type, daddr, dport, flags, dest,\n\t\t\t\t    fwmark);\n\t\trcu_read_unlock();\n\t\tif (!cp) {\n\t\t\tkfree(param->pe_data);\n\t\t\tIP_VS_DBG(2, \"BACKUP, add new conn. failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (!(flags & IP_VS_CONN_F_TEMPLATE))\n\t\t\tkfree(param->pe_data);\n\t}\n\n\tif (opt) {\n\t\tcp->in_seq = opt->in_seq;\n\t\tcp->out_seq = opt->out_seq;\n\t}\n\tatomic_set(&cp->in_pkts, sysctl_sync_threshold(ipvs));\n\tcp->state = state;\n\tcp->old_state = cp->state;\n\t \n\tif (timeout) {\n\t\tif (timeout > MAX_SCHEDULE_TIMEOUT / HZ)\n\t\t\ttimeout = MAX_SCHEDULE_TIMEOUT / HZ;\n\t\tcp->timeout = timeout*HZ;\n\t} else {\n\t\tstruct ip_vs_proto_data *pd;\n\n\t\tpd = ip_vs_proto_data_get(ipvs, protocol);\n\t\tif (!(flags & IP_VS_CONN_F_TEMPLATE) && pd && pd->timeout_table)\n\t\t\tcp->timeout = pd->timeout_table[state];\n\t\telse\n\t\t\tcp->timeout = (3*60*HZ);\n\t}\n\tip_vs_conn_put(cp);\n}\n\n \nstatic void ip_vs_process_message_v0(struct netns_ipvs *ipvs, const char *buffer,\n\t\t\t\t     const size_t buflen)\n{\n\tstruct ip_vs_sync_mesg_v0 *m = (struct ip_vs_sync_mesg_v0 *)buffer;\n\tstruct ip_vs_sync_conn_v0 *s;\n\tstruct ip_vs_sync_conn_options *opt;\n\tstruct ip_vs_protocol *pp;\n\tstruct ip_vs_conn_param param;\n\tchar *p;\n\tint i;\n\n\tp = (char *)buffer + sizeof(struct ip_vs_sync_mesg_v0);\n\tfor (i=0; i<m->nr_conns; i++) {\n\t\tunsigned int flags, state;\n\n\t\tif (p + SIMPLE_CONN_SIZE > buffer+buflen) {\n\t\t\tIP_VS_ERR_RL(\"BACKUP v0, bogus conn\\n\");\n\t\t\treturn;\n\t\t}\n\t\ts = (struct ip_vs_sync_conn_v0 *) p;\n\t\tflags = ntohs(s->flags) | IP_VS_CONN_F_SYNC;\n\t\tflags &= ~IP_VS_CONN_F_HASHED;\n\t\tif (flags & IP_VS_CONN_F_SEQ_MASK) {\n\t\t\topt = (struct ip_vs_sync_conn_options *)&s[1];\n\t\t\tp += FULL_CONN_SIZE;\n\t\t\tif (p > buffer+buflen) {\n\t\t\t\tIP_VS_ERR_RL(\"BACKUP v0, Dropping buffer bogus conn options\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\topt = NULL;\n\t\t\tp += SIMPLE_CONN_SIZE;\n\t\t}\n\n\t\tstate = ntohs(s->state);\n\t\tif (!(flags & IP_VS_CONN_F_TEMPLATE)) {\n\t\t\tpp = ip_vs_proto_get(s->protocol);\n\t\t\tif (!pp) {\n\t\t\t\tIP_VS_DBG(2, \"BACKUP v0, Unsupported protocol %u\\n\",\n\t\t\t\t\ts->protocol);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (state >= pp->num_states) {\n\t\t\t\tIP_VS_DBG(2, \"BACKUP v0, Invalid %s state %u\\n\",\n\t\t\t\t\tpp->name, state);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (state >= IP_VS_CTPL_S_LAST)\n\t\t\t\tIP_VS_DBG(7, \"BACKUP v0, Invalid tpl state %u\\n\",\n\t\t\t\t\t  state);\n\t\t}\n\n\t\tip_vs_conn_fill_param(ipvs, AF_INET, s->protocol,\n\t\t\t\t      (const union nf_inet_addr *)&s->caddr,\n\t\t\t\t      s->cport,\n\t\t\t\t      (const union nf_inet_addr *)&s->vaddr,\n\t\t\t\t      s->vport, &param);\n\n\t\t \n\t\tip_vs_proc_conn(ipvs, &param, flags, state, s->protocol, AF_INET,\n\t\t\t\t(union nf_inet_addr *)&s->daddr, s->dport,\n\t\t\t\t0, 0, opt);\n\t}\n}\n\n \nstatic inline int ip_vs_proc_seqopt(__u8 *p, unsigned int plen,\n\t\t\t\t    __u32 *opt_flags,\n\t\t\t\t    struct ip_vs_sync_conn_options *opt)\n{\n\tstruct ip_vs_sync_conn_options *topt;\n\n\ttopt = (struct ip_vs_sync_conn_options *)p;\n\n\tif (plen != sizeof(struct ip_vs_sync_conn_options)) {\n\t\tIP_VS_DBG(2, \"BACKUP, bogus conn options length\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (*opt_flags & IPVS_OPT_F_SEQ_DATA) {\n\t\tIP_VS_DBG(2, \"BACKUP, conn options found twice\\n\");\n\t\treturn -EINVAL;\n\t}\n\tntoh_seq(&topt->in_seq, &opt->in_seq);\n\tntoh_seq(&topt->out_seq, &opt->out_seq);\n\t*opt_flags |= IPVS_OPT_F_SEQ_DATA;\n\treturn 0;\n}\n\nstatic int ip_vs_proc_str(__u8 *p, unsigned int plen, unsigned int *data_len,\n\t\t\t  __u8 **data, unsigned int maxlen,\n\t\t\t  __u32 *opt_flags, __u32 flag)\n{\n\tif (plen > maxlen) {\n\t\tIP_VS_DBG(2, \"BACKUP, bogus par.data len > %d\\n\", maxlen);\n\t\treturn -EINVAL;\n\t}\n\tif (*opt_flags & flag) {\n\t\tIP_VS_DBG(2, \"BACKUP, Par.data found twice 0x%x\\n\", flag);\n\t\treturn -EINVAL;\n\t}\n\t*data_len = plen;\n\t*data = p;\n\t*opt_flags |= flag;\n\treturn 0;\n}\n \nstatic inline int ip_vs_proc_sync_conn(struct netns_ipvs *ipvs, __u8 *p, __u8 *msg_end)\n{\n\tstruct ip_vs_sync_conn_options opt;\n\tunion  ip_vs_sync_conn *s;\n\tstruct ip_vs_protocol *pp;\n\tstruct ip_vs_conn_param param;\n\t__u32 flags;\n\tunsigned int af, state, pe_data_len=0, pe_name_len=0;\n\t__u8 *pe_data=NULL, *pe_name=NULL;\n\t__u32 opt_flags=0;\n\tint retc=0;\n\n\ts = (union ip_vs_sync_conn *) p;\n\n\tif (s->v6.type & STYPE_F_INET6) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\taf = AF_INET6;\n\t\tp += sizeof(struct ip_vs_sync_v6);\n#else\n\t\tIP_VS_DBG(3,\"BACKUP, IPv6 msg received, and IPVS is not compiled for IPv6\\n\");\n\t\tretc = 10;\n\t\tgoto out;\n#endif\n\t} else if (!s->v4.type) {\n\t\taf = AF_INET;\n\t\tp += sizeof(struct ip_vs_sync_v4);\n\t} else {\n\t\treturn -10;\n\t}\n\tif (p > msg_end)\n\t\treturn -20;\n\n\t \n\twhile (p < msg_end) {\n\t\tint ptype;\n\t\tint plen;\n\n\t\tif (p+2 > msg_end)\n\t\t\treturn -30;\n\t\tptype = *(p++);\n\t\tplen  = *(p++);\n\n\t\tif (!plen || ((p + plen) > msg_end))\n\t\t\treturn -40;\n\t\t \n\t\tswitch (ptype & ~IPVS_OPT_F_PARAM) {\n\t\tcase IPVS_OPT_SEQ_DATA:\n\t\t\tif (ip_vs_proc_seqopt(p, plen, &opt_flags, &opt))\n\t\t\t\treturn -50;\n\t\t\tbreak;\n\n\t\tcase IPVS_OPT_PE_DATA:\n\t\t\tif (ip_vs_proc_str(p, plen, &pe_data_len, &pe_data,\n\t\t\t\t\t   IP_VS_PEDATA_MAXLEN, &opt_flags,\n\t\t\t\t\t   IPVS_OPT_F_PE_DATA))\n\t\t\t\treturn -60;\n\t\t\tbreak;\n\n\t\tcase IPVS_OPT_PE_NAME:\n\t\t\tif (ip_vs_proc_str(p, plen,&pe_name_len, &pe_name,\n\t\t\t\t\t   IP_VS_PENAME_MAXLEN, &opt_flags,\n\t\t\t\t\t   IPVS_OPT_F_PE_NAME))\n\t\t\t\treturn -70;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tif (!(ptype & IPVS_OPT_F_PARAM)) {\n\t\t\t\tIP_VS_DBG(3, \"BACKUP, Unknown mandatory param %d found\\n\",\n\t\t\t\t\t  ptype & ~IPVS_OPT_F_PARAM);\n\t\t\t\tretc = 20;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tp += plen;   \n\t}\n\n\t \n\tflags  = ntohl(s->v4.flags) & IP_VS_CONN_F_BACKUP_MASK;\n\tflags |= IP_VS_CONN_F_SYNC;\n\tstate = ntohs(s->v4.state);\n\n\tif (!(flags & IP_VS_CONN_F_TEMPLATE)) {\n\t\tpp = ip_vs_proto_get(s->v4.protocol);\n\t\tif (!pp) {\n\t\t\tIP_VS_DBG(3,\"BACKUP, Unsupported protocol %u\\n\",\n\t\t\t\ts->v4.protocol);\n\t\t\tretc = 30;\n\t\t\tgoto out;\n\t\t}\n\t\tif (state >= pp->num_states) {\n\t\t\tIP_VS_DBG(3, \"BACKUP, Invalid %s state %u\\n\",\n\t\t\t\tpp->name, state);\n\t\t\tretc = 40;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (state >= IP_VS_CTPL_S_LAST)\n\t\t\tIP_VS_DBG(7, \"BACKUP, Invalid tpl state %u\\n\",\n\t\t\t\t  state);\n\t}\n\tif (ip_vs_conn_fill_param_sync(ipvs, af, s, &param, pe_data,\n\t\t\t\t       pe_data_len, pe_name, pe_name_len)) {\n\t\tretc = 50;\n\t\tgoto out;\n\t}\n\t \n\tif (af == AF_INET)\n\t\tip_vs_proc_conn(ipvs, &param, flags, state, s->v4.protocol, af,\n\t\t\t\t(union nf_inet_addr *)&s->v4.daddr, s->v4.dport,\n\t\t\t\tntohl(s->v4.timeout), ntohl(s->v4.fwmark),\n\t\t\t\t(opt_flags & IPVS_OPT_F_SEQ_DATA ? &opt : NULL)\n\t\t\t\t);\n#ifdef CONFIG_IP_VS_IPV6\n\telse\n\t\tip_vs_proc_conn(ipvs, &param, flags, state, s->v6.protocol, af,\n\t\t\t\t(union nf_inet_addr *)&s->v6.daddr, s->v6.dport,\n\t\t\t\tntohl(s->v6.timeout), ntohl(s->v6.fwmark),\n\t\t\t\t(opt_flags & IPVS_OPT_F_SEQ_DATA ? &opt : NULL)\n\t\t\t\t);\n#endif\n\tip_vs_pe_put(param.pe);\n\treturn 0;\n\t \nout:\n\tIP_VS_DBG(2, \"BACKUP, Single msg dropped err:%d\\n\", retc);\n\treturn retc;\n\n}\n \nstatic void ip_vs_process_message(struct netns_ipvs *ipvs, __u8 *buffer,\n\t\t\t\t  const size_t buflen)\n{\n\tstruct ip_vs_sync_mesg *m2 = (struct ip_vs_sync_mesg *)buffer;\n\t__u8 *p, *msg_end;\n\tint i, nr_conns;\n\n\tif (buflen < sizeof(struct ip_vs_sync_mesg_v0)) {\n\t\tIP_VS_DBG(2, \"BACKUP, message header too short\\n\");\n\t\treturn;\n\t}\n\n\tif (buflen != ntohs(m2->size)) {\n\t\tIP_VS_DBG(2, \"BACKUP, bogus message size\\n\");\n\t\treturn;\n\t}\n\t \n\tif (ipvs->bcfg.syncid != 0 && m2->syncid != ipvs->bcfg.syncid) {\n\t\tIP_VS_DBG(7, \"BACKUP, Ignoring syncid = %d\\n\", m2->syncid);\n\t\treturn;\n\t}\n\t \n\tif ((m2->version == SYNC_PROTO_VER) && (m2->reserved == 0)\n\t    && (m2->spare == 0)) {\n\n\t\tmsg_end = buffer + sizeof(struct ip_vs_sync_mesg);\n\t\tnr_conns = m2->nr_conns;\n\n\t\tfor (i=0; i<nr_conns; i++) {\n\t\t\tunion ip_vs_sync_conn *s;\n\t\t\tunsigned int size;\n\t\t\tint retc;\n\n\t\t\tp = msg_end;\n\t\t\tif (p + sizeof(s->v4) > buffer+buflen) {\n\t\t\t\tIP_VS_ERR_RL(\"BACKUP, Dropping buffer, too small\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ts = (union ip_vs_sync_conn *)p;\n\t\t\tsize = ntohs(s->v4.ver_size) & SVER_MASK;\n\t\t\tmsg_end = p + size;\n\t\t\t \n\t\t\tif (msg_end  > buffer+buflen) {\n\t\t\t\tIP_VS_ERR_RL(\"BACKUP, Dropping buffer, msg > buffer\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ntohs(s->v4.ver_size) >> SVER_SHIFT) {\n\t\t\t\tIP_VS_ERR_RL(\"BACKUP, Dropping buffer, Unknown version %d\\n\",\n\t\t\t\t\t      ntohs(s->v4.ver_size) >> SVER_SHIFT);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tretc = ip_vs_proc_sync_conn(ipvs, p, msg_end);\n\t\t\tif (retc < 0) {\n\t\t\t\tIP_VS_ERR_RL(\"BACKUP, Dropping buffer, Err: %d in decoding\\n\",\n\t\t\t\t\t     retc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tmsg_end = p + ((size + 3) & ~3);\n\t\t}\n\t} else {\n\t\t \n\t\tip_vs_process_message_v0(ipvs, buffer, buflen);\n\t\treturn;\n\t}\n}\n\n\n \nstatic void set_sock_size(struct sock *sk, int mode, int val)\n{\n\t \n\t \n\tlock_sock(sk);\n\tif (mode) {\n\t\tval = clamp_t(int, val, (SOCK_MIN_SNDBUF + 1) / 2,\n\t\t\t      READ_ONCE(sysctl_wmem_max));\n\t\tsk->sk_sndbuf = val * 2;\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t} else {\n\t\tval = clamp_t(int, val, (SOCK_MIN_RCVBUF + 1) / 2,\n\t\t\t      READ_ONCE(sysctl_rmem_max));\n\t\tsk->sk_rcvbuf = val * 2;\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t}\n\trelease_sock(sk);\n}\n\n \nstatic void set_mcast_loop(struct sock *sk, u_char loop)\n{\n\t \n\tlock_sock(sk);\n\tinet_assign_bit(MC_LOOP, sk, loop);\n#ifdef CONFIG_IP_VS_IPV6\n\tif (sk->sk_family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\t\t \n\t\tnp->mc_loop = loop ? 1 : 0;\n\t}\n#endif\n\trelease_sock(sk);\n}\n\n \nstatic void set_mcast_ttl(struct sock *sk, u_char ttl)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t \n\tlock_sock(sk);\n\tinet->mc_ttl = ttl;\n#ifdef CONFIG_IP_VS_IPV6\n\tif (sk->sk_family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\t\t \n\t\tnp->mcast_hops = ttl;\n\t}\n#endif\n\trelease_sock(sk);\n}\n\n \nstatic void set_mcast_pmtudisc(struct sock *sk, int val)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t \n\tlock_sock(sk);\n\tinet->pmtudisc = val;\n#ifdef CONFIG_IP_VS_IPV6\n\tif (sk->sk_family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\t\t \n\t\tnp->pmtudisc = val;\n\t}\n#endif\n\trelease_sock(sk);\n}\n\n \nstatic int set_mcast_if(struct sock *sk, struct net_device *dev)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\tif (sk->sk_bound_dev_if && dev->ifindex != sk->sk_bound_dev_if)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tinet->mc_index = dev->ifindex;\n\t \n#ifdef CONFIG_IP_VS_IPV6\n\tif (sk->sk_family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\t\t \n\t\tnp->mcast_oif = dev->ifindex;\n\t}\n#endif\n\trelease_sock(sk);\n\n\treturn 0;\n}\n\n\n \nstatic int\njoin_mcast_group(struct sock *sk, struct in_addr *addr, struct net_device *dev)\n{\n\tstruct ip_mreqn mreq;\n\tint ret;\n\n\tmemset(&mreq, 0, sizeof(mreq));\n\tmemcpy(&mreq.imr_multiaddr, addr, sizeof(struct in_addr));\n\n\tif (sk->sk_bound_dev_if && dev->ifindex != sk->sk_bound_dev_if)\n\t\treturn -EINVAL;\n\n\tmreq.imr_ifindex = dev->ifindex;\n\n\tlock_sock(sk);\n\tret = ip_mc_join_group(sk, &mreq);\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nstatic int join_mcast_group6(struct sock *sk, struct in6_addr *addr,\n\t\t\t     struct net_device *dev)\n{\n\tint ret;\n\n\tif (sk->sk_bound_dev_if && dev->ifindex != sk->sk_bound_dev_if)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tret = ipv6_sock_mc_join(sk, dev->ifindex, addr);\n\trelease_sock(sk);\n\n\treturn ret;\n}\n#endif\n\nstatic int bind_mcastif_addr(struct socket *sock, struct net_device *dev)\n{\n\t__be32 addr;\n\tstruct sockaddr_in sin;\n\n\taddr = inet_select_addr(dev, 0, RT_SCOPE_UNIVERSE);\n\tif (!addr)\n\t\tpr_err(\"You probably need to specify IP address on \"\n\t\t       \"multicast interface.\\n\");\n\n\tIP_VS_DBG(7, \"binding socket with (%s) %pI4\\n\",\n\t\t  dev->name, &addr);\n\n\t \n\tsin.sin_family\t     = AF_INET;\n\tsin.sin_addr.s_addr  = addr;\n\tsin.sin_port         = 0;\n\n\treturn kernel_bind(sock, (struct sockaddr *)&sin, sizeof(sin));\n}\n\nstatic void get_mcast_sockaddr(union ipvs_sockaddr *sa, int *salen,\n\t\t\t       struct ipvs_sync_daemon_cfg *c, int id)\n{\n\tif (AF_INET6 == c->mcast_af) {\n\t\tsa->in6 = (struct sockaddr_in6) {\n\t\t\t.sin6_family = AF_INET6,\n\t\t\t.sin6_port = htons(c->mcast_port + id),\n\t\t};\n\t\tsa->in6.sin6_addr = c->mcast_group.in6;\n\t\t*salen = sizeof(sa->in6);\n\t} else {\n\t\tsa->in = (struct sockaddr_in) {\n\t\t\t.sin_family = AF_INET,\n\t\t\t.sin_port = htons(c->mcast_port + id),\n\t\t};\n\t\tsa->in.sin_addr = c->mcast_group.in;\n\t\t*salen = sizeof(sa->in);\n\t}\n}\n\n \nstatic int make_send_sock(struct netns_ipvs *ipvs, int id,\n\t\t\t  struct net_device *dev, struct socket **sock_ret)\n{\n\t \n\tunion ipvs_sockaddr mcast_addr;\n\tstruct socket *sock;\n\tint result, salen;\n\n\t \n\tresult = sock_create_kern(ipvs->net, ipvs->mcfg.mcast_af, SOCK_DGRAM,\n\t\t\t\t  IPPROTO_UDP, &sock);\n\tif (result < 0) {\n\t\tpr_err(\"Error during creation of socket; terminating\\n\");\n\t\tgoto error;\n\t}\n\t*sock_ret = sock;\n\tresult = set_mcast_if(sock->sk, dev);\n\tif (result < 0) {\n\t\tpr_err(\"Error setting outbound mcast interface\\n\");\n\t\tgoto error;\n\t}\n\n\tset_mcast_loop(sock->sk, 0);\n\tset_mcast_ttl(sock->sk, ipvs->mcfg.mcast_ttl);\n\t \n\tset_mcast_pmtudisc(sock->sk, IP_PMTUDISC_DONT);\n\tresult = sysctl_sync_sock_size(ipvs);\n\tif (result > 0)\n\t\tset_sock_size(sock->sk, 1, result);\n\n\tif (AF_INET == ipvs->mcfg.mcast_af)\n\t\tresult = bind_mcastif_addr(sock, dev);\n\telse\n\t\tresult = 0;\n\tif (result < 0) {\n\t\tpr_err(\"Error binding address of the mcast interface\\n\");\n\t\tgoto error;\n\t}\n\n\tget_mcast_sockaddr(&mcast_addr, &salen, &ipvs->mcfg, id);\n\tresult = kernel_connect(sock, (struct sockaddr *)&mcast_addr,\n\t\t\t\tsalen, 0);\n\tif (result < 0) {\n\t\tpr_err(\"Error connecting to the multicast addr\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\treturn result;\n}\n\n\n \nstatic int make_receive_sock(struct netns_ipvs *ipvs, int id,\n\t\t\t     struct net_device *dev, struct socket **sock_ret)\n{\n\t \n\tunion ipvs_sockaddr mcast_addr;\n\tstruct socket *sock;\n\tint result, salen;\n\n\t \n\tresult = sock_create_kern(ipvs->net, ipvs->bcfg.mcast_af, SOCK_DGRAM,\n\t\t\t\t  IPPROTO_UDP, &sock);\n\tif (result < 0) {\n\t\tpr_err(\"Error during creation of socket; terminating\\n\");\n\t\tgoto error;\n\t}\n\t*sock_ret = sock;\n\t \n\tsock->sk->sk_reuse = SK_CAN_REUSE;\n\tresult = sysctl_sync_sock_size(ipvs);\n\tif (result > 0)\n\t\tset_sock_size(sock->sk, 0, result);\n\n\tget_mcast_sockaddr(&mcast_addr, &salen, &ipvs->bcfg, id);\n\tsock->sk->sk_bound_dev_if = dev->ifindex;\n\tresult = kernel_bind(sock, (struct sockaddr *)&mcast_addr, salen);\n\tif (result < 0) {\n\t\tpr_err(\"Error binding to the multicast addr\\n\");\n\t\tgoto error;\n\t}\n\n\t \n#ifdef CONFIG_IP_VS_IPV6\n\tif (ipvs->bcfg.mcast_af == AF_INET6)\n\t\tresult = join_mcast_group6(sock->sk, &mcast_addr.in6.sin6_addr,\n\t\t\t\t\t   dev);\n\telse\n#endif\n\t\tresult = join_mcast_group(sock->sk, &mcast_addr.in.sin_addr,\n\t\t\t\t\t  dev);\n\tif (result < 0) {\n\t\tpr_err(\"Error joining to the multicast group\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\treturn result;\n}\n\n\nstatic int\nip_vs_send_async(struct socket *sock, const char *buffer, const size_t length)\n{\n\tstruct msghdr\tmsg = {.msg_flags = MSG_DONTWAIT|MSG_NOSIGNAL};\n\tstruct kvec\tiov;\n\tint\t\tlen;\n\n\tiov.iov_base     = (void *)buffer;\n\tiov.iov_len      = length;\n\n\tlen = kernel_sendmsg(sock, &msg, &iov, 1, (size_t)(length));\n\n\treturn len;\n}\n\nstatic int\nip_vs_send_sync_msg(struct socket *sock, struct ip_vs_sync_mesg *msg)\n{\n\tint msize;\n\tint ret;\n\n\tmsize = ntohs(msg->size);\n\n\tret = ip_vs_send_async(sock, (char *)msg, msize);\n\tif (ret >= 0 || ret == -EAGAIN)\n\t\treturn ret;\n\tpr_err(\"ip_vs_send_async error %d\\n\", ret);\n\treturn 0;\n}\n\nstatic int\nip_vs_receive(struct socket *sock, char *buffer, const size_t buflen)\n{\n\tstruct msghdr\t\tmsg = {NULL,};\n\tstruct kvec\t\tiov = {buffer, buflen};\n\tint\t\t\tlen;\n\n\t \n\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, &iov, 1, buflen);\n\tlen = sock_recvmsg(sock, &msg, MSG_DONTWAIT);\n\tif (len < 0)\n\t\treturn len;\n\n\treturn len;\n}\n\n \nstatic void master_wakeup_work_handler(struct work_struct *work)\n{\n\tstruct ipvs_master_sync_state *ms =\n\t\tcontainer_of(work, struct ipvs_master_sync_state,\n\t\t\t     master_wakeup_work.work);\n\tstruct netns_ipvs *ipvs = ms->ipvs;\n\n\tspin_lock_bh(&ipvs->sync_lock);\n\tif (ms->sync_queue_len &&\n\t    ms->sync_queue_delay < IPVS_SYNC_WAKEUP_RATE) {\n\t\tint id = (int)(ms - ipvs->ms);\n\n\t\tms->sync_queue_delay = IPVS_SYNC_WAKEUP_RATE;\n\t\twake_up_process(ipvs->master_tinfo[id].task);\n\t}\n\tspin_unlock_bh(&ipvs->sync_lock);\n}\n\n \nstatic inline struct ip_vs_sync_buff *\nnext_sync_buff(struct netns_ipvs *ipvs, struct ipvs_master_sync_state *ms)\n{\n\tstruct ip_vs_sync_buff *sb;\n\n\tsb = sb_dequeue(ipvs, ms);\n\tif (sb)\n\t\treturn sb;\n\t \n\treturn get_curr_sync_buff(ipvs, ms, IPVS_SYNC_FLUSH_TIME);\n}\n\nstatic int sync_thread_master(void *data)\n{\n\tstruct ip_vs_sync_thread_data *tinfo = data;\n\tstruct netns_ipvs *ipvs = tinfo->ipvs;\n\tstruct ipvs_master_sync_state *ms = &ipvs->ms[tinfo->id];\n\tstruct sock *sk = tinfo->sock->sk;\n\tstruct ip_vs_sync_buff *sb;\n\n\tpr_info(\"sync thread started: state = MASTER, mcast_ifn = %s, \"\n\t\t\"syncid = %d, id = %d\\n\",\n\t\tipvs->mcfg.mcast_ifn, ipvs->mcfg.syncid, tinfo->id);\n\n\tfor (;;) {\n\t\tsb = next_sync_buff(ipvs, ms);\n\t\tif (unlikely(kthread_should_stop()))\n\t\t\tbreak;\n\t\tif (!sb) {\n\t\t\tschedule_timeout(IPVS_SYNC_CHECK_PERIOD);\n\t\t\tcontinue;\n\t\t}\n\t\twhile (ip_vs_send_sync_msg(tinfo->sock, sb->mesg) < 0) {\n\t\t\t \n\t\t\t__wait_event_interruptible(*sk_sleep(sk),\n\t\t\t\t\t\t   sock_writeable(sk) ||\n\t\t\t\t\t\t   kthread_should_stop());\n\t\t\tif (unlikely(kthread_should_stop()))\n\t\t\t\tgoto done;\n\t\t}\n\t\tip_vs_sync_buff_release(sb);\n\t}\n\ndone:\n\t__set_current_state(TASK_RUNNING);\n\tif (sb)\n\t\tip_vs_sync_buff_release(sb);\n\n\t \n\twhile ((sb = sb_dequeue(ipvs, ms)))\n\t\tip_vs_sync_buff_release(sb);\n\t__set_current_state(TASK_RUNNING);\n\n\t \n\tsb = get_curr_sync_buff(ipvs, ms, 0);\n\tif (sb)\n\t\tip_vs_sync_buff_release(sb);\n\n\treturn 0;\n}\n\n\nstatic int sync_thread_backup(void *data)\n{\n\tstruct ip_vs_sync_thread_data *tinfo = data;\n\tstruct netns_ipvs *ipvs = tinfo->ipvs;\n\tstruct sock *sk = tinfo->sock->sk;\n\tstruct udp_sock *up = udp_sk(sk);\n\tint len;\n\n\tpr_info(\"sync thread started: state = BACKUP, mcast_ifn = %s, \"\n\t\t\"syncid = %d, id = %d\\n\",\n\t\tipvs->bcfg.mcast_ifn, ipvs->bcfg.syncid, tinfo->id);\n\n\twhile (!kthread_should_stop()) {\n\t\twait_event_interruptible(*sk_sleep(sk),\n\t\t\t\t\t !skb_queue_empty_lockless(&sk->sk_receive_queue) ||\n\t\t\t\t\t !skb_queue_empty_lockless(&up->reader_queue) ||\n\t\t\t\t\t kthread_should_stop());\n\n\t\t \n\t\twhile (!skb_queue_empty_lockless(&sk->sk_receive_queue) ||\n\t\t       !skb_queue_empty_lockless(&up->reader_queue)) {\n\t\t\tlen = ip_vs_receive(tinfo->sock, tinfo->buf,\n\t\t\t\t\tipvs->bcfg.sync_maxlen);\n\t\t\tif (len <= 0) {\n\t\t\t\tif (len != -EAGAIN)\n\t\t\t\t\tpr_err(\"receiving message error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tip_vs_process_message(ipvs, tinfo->buf, len);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint start_sync_thread(struct netns_ipvs *ipvs, struct ipvs_sync_daemon_cfg *c,\n\t\t      int state)\n{\n\tstruct ip_vs_sync_thread_data *ti = NULL, *tinfo;\n\tstruct task_struct *task;\n\tstruct net_device *dev;\n\tchar *name;\n\tint (*threadfn)(void *data);\n\tint id = 0, count, hlen;\n\tint result = -ENOMEM;\n\tu16 mtu, min_mtu;\n\n\tIP_VS_DBG(7, \"%s(): pid %d\\n\", __func__, task_pid_nr(current));\n\tIP_VS_DBG(7, \"Each ip_vs_sync_conn entry needs %zd bytes\\n\",\n\t\t  sizeof(struct ip_vs_sync_conn_v0));\n\n\t \n\tif (!ip_vs_use_count_inc())\n\t\treturn -ENOPROTOOPT;\n\n\t \n\tfor (;;) {\n\t\trtnl_lock();\n\t\tif (mutex_trylock(&ipvs->sync_mutex))\n\t\t\tbreak;\n\t\trtnl_unlock();\n\t\tmutex_lock(&ipvs->sync_mutex);\n\t\tif (rtnl_trylock())\n\t\t\tbreak;\n\t\tmutex_unlock(&ipvs->sync_mutex);\n\t}\n\n\tif (!ipvs->sync_state) {\n\t\tcount = clamp(sysctl_sync_ports(ipvs), 1, IPVS_SYNC_PORTS_MAX);\n\t\tipvs->threads_mask = count - 1;\n\t} else\n\t\tcount = ipvs->threads_mask + 1;\n\n\tif (c->mcast_af == AF_UNSPEC) {\n\t\tc->mcast_af = AF_INET;\n\t\tc->mcast_group.ip = cpu_to_be32(IP_VS_SYNC_GROUP);\n\t}\n\tif (!c->mcast_port)\n\t\tc->mcast_port = IP_VS_SYNC_PORT;\n\tif (!c->mcast_ttl)\n\t\tc->mcast_ttl = 1;\n\n\tdev = __dev_get_by_name(ipvs->net, c->mcast_ifn);\n\tif (!dev) {\n\t\tpr_err(\"Unknown mcast interface: %s\\n\", c->mcast_ifn);\n\t\tresult = -ENODEV;\n\t\tgoto out_early;\n\t}\n\thlen = (AF_INET6 == c->mcast_af) ?\n\t       sizeof(struct ipv6hdr) + sizeof(struct udphdr) :\n\t       sizeof(struct iphdr) + sizeof(struct udphdr);\n\tmtu = (state == IP_VS_STATE_BACKUP) ?\n\t\t  clamp(dev->mtu, 1500U, 65535U) : 1500U;\n\tmin_mtu = (state == IP_VS_STATE_BACKUP) ? 1024 : 1;\n\n\tif (c->sync_maxlen)\n\t\tc->sync_maxlen = clamp_t(unsigned int,\n\t\t\t\t\t c->sync_maxlen, min_mtu,\n\t\t\t\t\t 65535 - hlen);\n\telse\n\t\tc->sync_maxlen = mtu - hlen;\n\n\tif (state == IP_VS_STATE_MASTER) {\n\t\tresult = -EEXIST;\n\t\tif (ipvs->ms)\n\t\t\tgoto out_early;\n\n\t\tipvs->mcfg = *c;\n\t\tname = \"ipvs-m:%d:%d\";\n\t\tthreadfn = sync_thread_master;\n\t} else if (state == IP_VS_STATE_BACKUP) {\n\t\tresult = -EEXIST;\n\t\tif (ipvs->backup_tinfo)\n\t\t\tgoto out_early;\n\n\t\tipvs->bcfg = *c;\n\t\tname = \"ipvs-b:%d:%d\";\n\t\tthreadfn = sync_thread_backup;\n\t} else {\n\t\tresult = -EINVAL;\n\t\tgoto out_early;\n\t}\n\n\tif (state == IP_VS_STATE_MASTER) {\n\t\tstruct ipvs_master_sync_state *ms;\n\n\t\tresult = -ENOMEM;\n\t\tipvs->ms = kcalloc(count, sizeof(ipvs->ms[0]), GFP_KERNEL);\n\t\tif (!ipvs->ms)\n\t\t\tgoto out;\n\t\tms = ipvs->ms;\n\t\tfor (id = 0; id < count; id++, ms++) {\n\t\t\tINIT_LIST_HEAD(&ms->sync_queue);\n\t\t\tms->sync_queue_len = 0;\n\t\t\tms->sync_queue_delay = 0;\n\t\t\tINIT_DELAYED_WORK(&ms->master_wakeup_work,\n\t\t\t\t\t  master_wakeup_work_handler);\n\t\t\tms->ipvs = ipvs;\n\t\t}\n\t}\n\tresult = -ENOMEM;\n\tti = kcalloc(count, sizeof(struct ip_vs_sync_thread_data),\n\t\t     GFP_KERNEL);\n\tif (!ti)\n\t\tgoto out;\n\n\tfor (id = 0; id < count; id++) {\n\t\ttinfo = &ti[id];\n\t\ttinfo->ipvs = ipvs;\n\t\tif (state == IP_VS_STATE_BACKUP) {\n\t\t\tresult = -ENOMEM;\n\t\t\ttinfo->buf = kmalloc(ipvs->bcfg.sync_maxlen,\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!tinfo->buf)\n\t\t\t\tgoto out;\n\t\t}\n\t\ttinfo->id = id;\n\t\tif (state == IP_VS_STATE_MASTER)\n\t\t\tresult = make_send_sock(ipvs, id, dev, &tinfo->sock);\n\t\telse\n\t\t\tresult = make_receive_sock(ipvs, id, dev, &tinfo->sock);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\ttask = kthread_run(threadfn, tinfo, name, ipvs->gen, id);\n\t\tif (IS_ERR(task)) {\n\t\t\tresult = PTR_ERR(task);\n\t\t\tgoto out;\n\t\t}\n\t\ttinfo->task = task;\n\t}\n\n\t \n\n\tif (state == IP_VS_STATE_MASTER)\n\t\tipvs->master_tinfo = ti;\n\telse\n\t\tipvs->backup_tinfo = ti;\n\tspin_lock_bh(&ipvs->sync_buff_lock);\n\tipvs->sync_state |= state;\n\tspin_unlock_bh(&ipvs->sync_buff_lock);\n\n\tmutex_unlock(&ipvs->sync_mutex);\n\trtnl_unlock();\n\n\treturn 0;\n\nout:\n\t \n\trtnl_unlock();\n\tid = min(id, count - 1);\n\tif (ti) {\n\t\tfor (tinfo = ti + id; tinfo >= ti; tinfo--) {\n\t\t\tif (tinfo->task)\n\t\t\t\tkthread_stop(tinfo->task);\n\t\t}\n\t}\n\tif (!(ipvs->sync_state & IP_VS_STATE_MASTER)) {\n\t\tkfree(ipvs->ms);\n\t\tipvs->ms = NULL;\n\t}\n\tmutex_unlock(&ipvs->sync_mutex);\n\n\t \n\tif (ti) {\n\t\tfor (tinfo = ti + id; tinfo >= ti; tinfo--) {\n\t\t\tif (tinfo->sock)\n\t\t\t\tsock_release(tinfo->sock);\n\t\t\tkfree(tinfo->buf);\n\t\t}\n\t\tkfree(ti);\n\t}\n\n\t \n\tip_vs_use_count_dec();\n\treturn result;\n\nout_early:\n\tmutex_unlock(&ipvs->sync_mutex);\n\trtnl_unlock();\n\n\t \n\tip_vs_use_count_dec();\n\treturn result;\n}\n\n\nint stop_sync_thread(struct netns_ipvs *ipvs, int state)\n{\n\tstruct ip_vs_sync_thread_data *ti, *tinfo;\n\tint id;\n\tint retc = -EINVAL;\n\n\tIP_VS_DBG(7, \"%s(): pid %d\\n\", __func__, task_pid_nr(current));\n\n\tmutex_lock(&ipvs->sync_mutex);\n\tif (state == IP_VS_STATE_MASTER) {\n\t\tretc = -ESRCH;\n\t\tif (!ipvs->ms)\n\t\t\tgoto err;\n\t\tti = ipvs->master_tinfo;\n\n\t\t \n\n\t\tspin_lock_bh(&ipvs->sync_buff_lock);\n\t\tspin_lock(&ipvs->sync_lock);\n\t\tipvs->sync_state &= ~IP_VS_STATE_MASTER;\n\t\tspin_unlock(&ipvs->sync_lock);\n\t\tspin_unlock_bh(&ipvs->sync_buff_lock);\n\n\t\tretc = 0;\n\t\tfor (id = ipvs->threads_mask; id >= 0; id--) {\n\t\t\tstruct ipvs_master_sync_state *ms = &ipvs->ms[id];\n\t\t\tint ret;\n\n\t\t\ttinfo = &ti[id];\n\t\t\tpr_info(\"stopping master sync thread %d ...\\n\",\n\t\t\t\ttask_pid_nr(tinfo->task));\n\t\t\tcancel_delayed_work_sync(&ms->master_wakeup_work);\n\t\t\tret = kthread_stop(tinfo->task);\n\t\t\tif (retc >= 0)\n\t\t\t\tretc = ret;\n\t\t}\n\t\tkfree(ipvs->ms);\n\t\tipvs->ms = NULL;\n\t\tipvs->master_tinfo = NULL;\n\t} else if (state == IP_VS_STATE_BACKUP) {\n\t\tretc = -ESRCH;\n\t\tif (!ipvs->backup_tinfo)\n\t\t\tgoto err;\n\t\tti = ipvs->backup_tinfo;\n\n\t\tipvs->sync_state &= ~IP_VS_STATE_BACKUP;\n\t\tretc = 0;\n\t\tfor (id = ipvs->threads_mask; id >= 0; id--) {\n\t\t\tint ret;\n\n\t\t\ttinfo = &ti[id];\n\t\t\tpr_info(\"stopping backup sync thread %d ...\\n\",\n\t\t\t\ttask_pid_nr(tinfo->task));\n\t\t\tret = kthread_stop(tinfo->task);\n\t\t\tif (retc >= 0)\n\t\t\t\tretc = ret;\n\t\t}\n\t\tipvs->backup_tinfo = NULL;\n\t} else {\n\t\tgoto err;\n\t}\n\tid = ipvs->threads_mask;\n\tmutex_unlock(&ipvs->sync_mutex);\n\n\t \n\tfor (tinfo = ti + id; tinfo >= ti; tinfo--) {\n\t\tif (tinfo->sock)\n\t\t\tsock_release(tinfo->sock);\n\t\tkfree(tinfo->buf);\n\t}\n\tkfree(ti);\n\n\t \n\tip_vs_use_count_dec();\n\treturn retc;\n\nerr:\n\tmutex_unlock(&ipvs->sync_mutex);\n\treturn retc;\n}\n\n \nint __net_init ip_vs_sync_net_init(struct netns_ipvs *ipvs)\n{\n\t__mutex_init(&ipvs->sync_mutex, \"ipvs->sync_mutex\", &__ipvs_sync_key);\n\tspin_lock_init(&ipvs->sync_lock);\n\tspin_lock_init(&ipvs->sync_buff_lock);\n\treturn 0;\n}\n\nvoid ip_vs_sync_net_cleanup(struct netns_ipvs *ipvs)\n{\n\tint retc;\n\n\tretc = stop_sync_thread(ipvs, IP_VS_STATE_MASTER);\n\tif (retc && retc != -ESRCH)\n\t\tpr_err(\"Failed to stop Master Daemon\\n\");\n\n\tretc = stop_sync_thread(ipvs, IP_VS_STATE_BACKUP);\n\tif (retc && retc != -ESRCH)\n\t\tpr_err(\"Failed to stop Backup Daemon\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}