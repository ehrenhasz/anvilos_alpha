{
  "module_name": "ip_vs_wrr.c",
  "hash_id": "404a13a785c2368aa05ffb74dad847ea7957f5bab77abdd7c6aab92bd6c466fe",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_wrr.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/net.h>\n#include <linux/gcd.h>\n\n#include <net/ip_vs.h>\n\n \n\n \nstruct ip_vs_wrr_mark {\n\tstruct ip_vs_dest *cl;\t \n\tint cw;\t\t\t \n\tint mw;\t\t\t \n\tint di;\t\t\t \n\tstruct rcu_head\t\trcu_head;\n};\n\n\nstatic int ip_vs_wrr_gcd_weight(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dest *dest;\n\tint weight;\n\tint g = 0;\n\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tweight = atomic_read(&dest->weight);\n\t\tif (weight > 0) {\n\t\t\tif (g > 0)\n\t\t\t\tg = gcd(weight, g);\n\t\t\telse\n\t\t\t\tg = weight;\n\t\t}\n\t}\n\treturn g ? g : 1;\n}\n\n\n \nstatic int ip_vs_wrr_max_weight(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dest *dest;\n\tint new_weight, weight = 0;\n\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tnew_weight = atomic_read(&dest->weight);\n\t\tif (new_weight > weight)\n\t\t\tweight = new_weight;\n\t}\n\n\treturn weight;\n}\n\n\nstatic int ip_vs_wrr_init_svc(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_wrr_mark *mark;\n\n\t \n\tmark = kmalloc(sizeof(struct ip_vs_wrr_mark), GFP_KERNEL);\n\tif (mark == NULL)\n\t\treturn -ENOMEM;\n\n\tmark->cl = list_entry(&svc->destinations, struct ip_vs_dest, n_list);\n\tmark->di = ip_vs_wrr_gcd_weight(svc);\n\tmark->mw = ip_vs_wrr_max_weight(svc) - (mark->di - 1);\n\tmark->cw = mark->mw;\n\tsvc->sched_data = mark;\n\n\treturn 0;\n}\n\n\nstatic void ip_vs_wrr_done_svc(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_wrr_mark *mark = svc->sched_data;\n\n\t \n\tkfree_rcu(mark, rcu_head);\n}\n\n\nstatic int ip_vs_wrr_dest_changed(struct ip_vs_service *svc,\n\t\t\t\t  struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_wrr_mark *mark = svc->sched_data;\n\n\tspin_lock_bh(&svc->sched_lock);\n\tmark->cl = list_entry(&svc->destinations, struct ip_vs_dest, n_list);\n\tmark->di = ip_vs_wrr_gcd_weight(svc);\n\tmark->mw = ip_vs_wrr_max_weight(svc) - (mark->di - 1);\n\tif (mark->cw > mark->mw || !mark->cw)\n\t\tmark->cw = mark->mw;\n\telse if (mark->di > 1)\n\t\tmark->cw = (mark->cw / mark->di) * mark->di + 1;\n\tspin_unlock_bh(&svc->sched_lock);\n\treturn 0;\n}\n\n\n \nstatic struct ip_vs_dest *\nip_vs_wrr_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\n\t\t   struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_dest *dest, *last, *stop = NULL;\n\tstruct ip_vs_wrr_mark *mark = svc->sched_data;\n\tbool last_pass = false, restarted = false;\n\n\tIP_VS_DBG(6, \"%s(): Scheduling...\\n\", __func__);\n\n\tspin_lock_bh(&svc->sched_lock);\n\tdest = mark->cl;\n\t \n\tif (mark->mw == 0)\n\t\tgoto err_noavail;\n\tlast = dest;\n\t \n\twhile (1) {\n\t\tlist_for_each_entry_continue_rcu(dest,\n\t\t\t\t\t\t &svc->destinations,\n\t\t\t\t\t\t n_list) {\n\t\t\tif (!(dest->flags & IP_VS_DEST_F_OVERLOAD) &&\n\t\t\t    atomic_read(&dest->weight) >= mark->cw)\n\t\t\t\tgoto found;\n\t\t\tif (dest == stop)\n\t\t\t\tgoto err_over;\n\t\t}\n\t\tmark->cw -= mark->di;\n\t\tif (mark->cw <= 0) {\n\t\t\tmark->cw = mark->mw;\n\t\t\t \n\t\t\tif (last_pass ||\n\t\t\t    &last->n_list == &svc->destinations)\n\t\t\t\tgoto err_over;\n\t\t\trestarted = true;\n\t\t}\n\t\tlast_pass = mark->cw <= mark->di;\n\t\tif (last_pass && restarted &&\n\t\t    &last->n_list != &svc->destinations) {\n\t\t\t \n\t\t\tstop = last;\n\t\t}\n\t}\n\nfound:\n\tIP_VS_DBG_BUF(6, \"WRR: server %s:%u \"\n\t\t      \"activeconns %d refcnt %d weight %d\\n\",\n\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr), ntohs(dest->port),\n\t\t      atomic_read(&dest->activeconns),\n\t\t      refcount_read(&dest->refcnt),\n\t\t      atomic_read(&dest->weight));\n\tmark->cl = dest;\n\n  out:\n\tspin_unlock_bh(&svc->sched_lock);\n\treturn dest;\n\nerr_noavail:\n\tmark->cl = dest;\n\tdest = NULL;\n\tip_vs_scheduler_err(svc, \"no destination available\");\n\tgoto out;\n\nerr_over:\n\tmark->cl = dest;\n\tdest = NULL;\n\tip_vs_scheduler_err(svc, \"no destination available: \"\n\t\t\t    \"all destinations are overloaded\");\n\tgoto out;\n}\n\n\nstatic struct ip_vs_scheduler ip_vs_wrr_scheduler = {\n\t.name =\t\t\t\"wrr\",\n\t.refcnt =\t\tATOMIC_INIT(0),\n\t.module =\t\tTHIS_MODULE,\n\t.n_list =\t\tLIST_HEAD_INIT(ip_vs_wrr_scheduler.n_list),\n\t.init_service =\t\tip_vs_wrr_init_svc,\n\t.done_service =\t\tip_vs_wrr_done_svc,\n\t.add_dest =\t\tip_vs_wrr_dest_changed,\n\t.del_dest =\t\tip_vs_wrr_dest_changed,\n\t.upd_dest =\t\tip_vs_wrr_dest_changed,\n\t.schedule =\t\tip_vs_wrr_schedule,\n};\n\nstatic int __init ip_vs_wrr_init(void)\n{\n\treturn register_ip_vs_scheduler(&ip_vs_wrr_scheduler) ;\n}\n\nstatic void __exit ip_vs_wrr_cleanup(void)\n{\n\tunregister_ip_vs_scheduler(&ip_vs_wrr_scheduler);\n\tsynchronize_rcu();\n}\n\nmodule_init(ip_vs_wrr_init);\nmodule_exit(ip_vs_wrr_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}