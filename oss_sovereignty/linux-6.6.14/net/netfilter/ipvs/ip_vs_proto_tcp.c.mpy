{
  "module_name": "ip_vs_proto_tcp.c",
  "hash_id": "6eda883b8b123aab48cd784412cdbb9a2b69a0d9b26fb1593c74a72c5dbe8043",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/ipvs/ip_vs_proto_tcp.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>                   \n#include <net/ip.h>\n#include <net/tcp.h>                     \n#include <net/ip6_checksum.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/indirect_call_wrapper.h>\n\n#include <net/ip_vs.h>\n\nstatic int\ntcp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp);\n\nstatic int\ntcp_conn_schedule(struct netns_ipvs *ipvs, int af, struct sk_buff *skb,\n\t\t  struct ip_vs_proto_data *pd,\n\t\t  int *verdict, struct ip_vs_conn **cpp,\n\t\t  struct ip_vs_iphdr *iph)\n{\n\tstruct ip_vs_service *svc;\n\tstruct tcphdr _tcph, *th;\n\t__be16 _ports[2], *ports = NULL;\n\n\t \n\tif (likely(!ip_vs_iph_icmp(iph))) {\n\t\tth = skb_header_pointer(skb, iph->len, sizeof(_tcph), &_tcph);\n\t\tif (th) {\n\t\t\tif (th->rst || !(sysctl_sloppy_tcp(ipvs) || th->syn))\n\t\t\t\treturn 1;\n\t\t\tports = &th->source;\n\t\t}\n\t} else {\n\t\tports = skb_header_pointer(\n\t\t\tskb, iph->len, sizeof(_ports), &_ports);\n\t}\n\n\tif (!ports) {\n\t\t*verdict = NF_DROP;\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (likely(!ip_vs_iph_inverse(iph)))\n\t\tsvc = ip_vs_service_find(ipvs, af, skb->mark, iph->protocol,\n\t\t\t\t\t &iph->daddr, ports[1]);\n\telse\n\t\tsvc = ip_vs_service_find(ipvs, af, skb->mark, iph->protocol,\n\t\t\t\t\t &iph->saddr, ports[0]);\n\n\tif (svc) {\n\t\tint ignored;\n\n\t\tif (ip_vs_todrop(ipvs)) {\n\t\t\t \n\t\t\t*verdict = NF_DROP;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\t*cpp = ip_vs_schedule(svc, skb, pd, &ignored, iph);\n\t\tif (!*cpp && ignored <= 0) {\n\t\t\tif (!ignored)\n\t\t\t\t*verdict = ip_vs_leave(svc, skb, pd, iph);\n\t\t\telse\n\t\t\t\t*verdict = NF_DROP;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\treturn 1;\n}\n\n\nstatic inline void\ntcp_fast_csum_update(int af, struct tcphdr *tcph,\n\t\t     const union nf_inet_addr *oldip,\n\t\t     const union nf_inet_addr *newip,\n\t\t     __be16 oldport, __be16 newport)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\ttcph->check =\n\t\t\tcsum_fold(ip_vs_check_diff16(oldip->ip6, newip->ip6,\n\t\t\t\t\t ip_vs_check_diff2(oldport, newport,\n\t\t\t\t\t\t~csum_unfold(tcph->check))));\n\telse\n#endif\n\ttcph->check =\n\t\tcsum_fold(ip_vs_check_diff4(oldip->ip, newip->ip,\n\t\t\t\t ip_vs_check_diff2(oldport, newport,\n\t\t\t\t\t\t~csum_unfold(tcph->check))));\n}\n\n\nstatic inline void\ntcp_partial_csum_update(int af, struct tcphdr *tcph,\n\t\t     const union nf_inet_addr *oldip,\n\t\t     const union nf_inet_addr *newip,\n\t\t     __be16 oldlen, __be16 newlen)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\ttcph->check =\n\t\t\t~csum_fold(ip_vs_check_diff16(oldip->ip6, newip->ip6,\n\t\t\t\t\t ip_vs_check_diff2(oldlen, newlen,\n\t\t\t\t\t\tcsum_unfold(tcph->check))));\n\telse\n#endif\n\ttcph->check =\n\t\t~csum_fold(ip_vs_check_diff4(oldip->ip, newip->ip,\n\t\t\t\tip_vs_check_diff2(oldlen, newlen,\n\t\t\t\t\t\tcsum_unfold(tcph->check))));\n}\n\n\nINDIRECT_CALLABLE_SCOPE int\ntcp_snat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t struct ip_vs_conn *cp, struct ip_vs_iphdr *iph)\n{\n\tstruct tcphdr *tcph;\n\tunsigned int tcphoff = iph->len;\n\tbool payload_csum = false;\n\tint oldlen;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (cp->af == AF_INET6 && iph->fragoffs)\n\t\treturn 1;\n#endif\n\toldlen = skb->len - tcphoff;\n\n\t \n\tif (skb_ensure_writable(skb, tcphoff + sizeof(*tcph)))\n\t\treturn 0;\n\n\tif (unlikely(cp->app != NULL)) {\n\t\tint ret;\n\n\t\t \n\t\tif (!tcp_csum_check(cp->af, skb, pp))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!(ret = ip_vs_app_pkt_out(cp, skb, iph)))\n\t\t\treturn 0;\n\t\t \n\t\tif (ret == 1)\n\t\t\toldlen = skb->len - tcphoff;\n\t\telse\n\t\t\tpayload_csum = true;\n\t}\n\n\ttcph = (void *)skb_network_header(skb) + tcphoff;\n\ttcph->source = cp->vport;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\ttcp_partial_csum_update(cp->af, tcph, &cp->daddr, &cp->vaddr,\n\t\t\t\t\thtons(oldlen),\n\t\t\t\t\thtons(skb->len - tcphoff));\n\t} else if (!payload_csum) {\n\t\t \n\t\ttcp_fast_csum_update(cp->af, tcph, &cp->daddr, &cp->vaddr,\n\t\t\t\t     cp->dport, cp->vport);\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\t\tskb->ip_summed = cp->app ?\n\t\t\t\t\t CHECKSUM_UNNECESSARY : CHECKSUM_NONE;\n\t} else {\n\t\t \n\t\ttcph->check = 0;\n\t\tskb->csum = skb_checksum(skb, tcphoff, skb->len - tcphoff, 0);\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (cp->af == AF_INET6)\n\t\t\ttcph->check = csum_ipv6_magic(&cp->vaddr.in6,\n\t\t\t\t\t\t      &cp->caddr.in6,\n\t\t\t\t\t\t      skb->len - tcphoff,\n\t\t\t\t\t\t      cp->protocol, skb->csum);\n\t\telse\n#endif\n\t\t\ttcph->check = csum_tcpudp_magic(cp->vaddr.ip,\n\t\t\t\t\t\t\tcp->caddr.ip,\n\t\t\t\t\t\t\tskb->len - tcphoff,\n\t\t\t\t\t\t\tcp->protocol,\n\t\t\t\t\t\t\tskb->csum);\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\tIP_VS_DBG(11, \"O-pkt: %s O-csum=%d (+%zd)\\n\",\n\t\t\t  pp->name, tcph->check,\n\t\t\t  (char*)&(tcph->check) - (char*)tcph);\n\t}\n\treturn 1;\n}\n\n\nstatic int\ntcp_dnat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t struct ip_vs_conn *cp, struct ip_vs_iphdr *iph)\n{\n\tstruct tcphdr *tcph;\n\tunsigned int tcphoff = iph->len;\n\tbool payload_csum = false;\n\tint oldlen;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (cp->af == AF_INET6 && iph->fragoffs)\n\t\treturn 1;\n#endif\n\toldlen = skb->len - tcphoff;\n\n\t \n\tif (skb_ensure_writable(skb, tcphoff + sizeof(*tcph)))\n\t\treturn 0;\n\n\tif (unlikely(cp->app != NULL)) {\n\t\tint ret;\n\n\t\t \n\t\tif (!tcp_csum_check(cp->af, skb, pp))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!(ret = ip_vs_app_pkt_in(cp, skb, iph)))\n\t\t\treturn 0;\n\t\t \n\t\tif (ret == 1)\n\t\t\toldlen = skb->len - tcphoff;\n\t\telse\n\t\t\tpayload_csum = true;\n\t}\n\n\ttcph = (void *)skb_network_header(skb) + tcphoff;\n\ttcph->dest = cp->dport;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\ttcp_partial_csum_update(cp->af, tcph, &cp->vaddr, &cp->daddr,\n\t\t\t\t\thtons(oldlen),\n\t\t\t\t\thtons(skb->len - tcphoff));\n\t} else if (!payload_csum) {\n\t\t \n\t\ttcp_fast_csum_update(cp->af, tcph, &cp->vaddr, &cp->daddr,\n\t\t\t\t     cp->vport, cp->dport);\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\t\tskb->ip_summed = cp->app ?\n\t\t\t\t\t CHECKSUM_UNNECESSARY : CHECKSUM_NONE;\n\t} else {\n\t\t \n\t\ttcph->check = 0;\n\t\tskb->csum = skb_checksum(skb, tcphoff, skb->len - tcphoff, 0);\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (cp->af == AF_INET6)\n\t\t\ttcph->check = csum_ipv6_magic(&cp->caddr.in6,\n\t\t\t\t\t\t      &cp->daddr.in6,\n\t\t\t\t\t\t      skb->len - tcphoff,\n\t\t\t\t\t\t      cp->protocol, skb->csum);\n\t\telse\n#endif\n\t\t\ttcph->check = csum_tcpudp_magic(cp->caddr.ip,\n\t\t\t\t\t\t\tcp->daddr.ip,\n\t\t\t\t\t\t\tskb->len - tcphoff,\n\t\t\t\t\t\t\tcp->protocol,\n\t\t\t\t\t\t\tskb->csum);\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\treturn 1;\n}\n\n\nstatic int\ntcp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)\n{\n\tunsigned int tcphoff;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\ttcphoff = sizeof(struct ipv6hdr);\n\telse\n#endif\n\t\ttcphoff = ip_hdrlen(skb);\n\n\tswitch (skb->ip_summed) {\n\tcase CHECKSUM_NONE:\n\t\tskb->csum = skb_checksum(skb, tcphoff, skb->len - tcphoff, 0);\n\t\tfallthrough;\n\tcase CHECKSUM_COMPLETE:\n#ifdef CONFIG_IP_VS_IPV6\n\t\tif (af == AF_INET6) {\n\t\t\tif (csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t    skb->len - tcphoff,\n\t\t\t\t\t    ipv6_hdr(skb)->nexthdr,\n\t\t\t\t\t    skb->csum)) {\n\t\t\t\tIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\n\t\t\t\t\t\t \"Failed checksum for\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else\n#endif\n\t\t\tif (csum_tcpudp_magic(ip_hdr(skb)->saddr,\n\t\t\t\t\t      ip_hdr(skb)->daddr,\n\t\t\t\t\t      skb->len - tcphoff,\n\t\t\t\t\t      ip_hdr(skb)->protocol,\n\t\t\t\t\t      skb->csum)) {\n\t\t\t\tIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\n\t\t\t\t\t\t \"Failed checksum for\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n\n#define TCP_DIR_INPUT\t\t0\n#define TCP_DIR_OUTPUT\t\t4\n#define TCP_DIR_INPUT_ONLY\t8\n\nstatic const int tcp_state_off[IP_VS_DIR_LAST] = {\n\t[IP_VS_DIR_INPUT]\t\t=\tTCP_DIR_INPUT,\n\t[IP_VS_DIR_OUTPUT]\t\t=\tTCP_DIR_OUTPUT,\n\t[IP_VS_DIR_INPUT_ONLY]\t\t=\tTCP_DIR_INPUT_ONLY,\n};\n\n \nstatic const int tcp_timeouts[IP_VS_TCP_S_LAST+1] = {\n\t[IP_VS_TCP_S_NONE]\t\t=\t2*HZ,\n\t[IP_VS_TCP_S_ESTABLISHED]\t=\t15*60*HZ,\n\t[IP_VS_TCP_S_SYN_SENT]\t\t=\t2*60*HZ,\n\t[IP_VS_TCP_S_SYN_RECV]\t\t=\t1*60*HZ,\n\t[IP_VS_TCP_S_FIN_WAIT]\t\t=\t2*60*HZ,\n\t[IP_VS_TCP_S_TIME_WAIT]\t\t=\t2*60*HZ,\n\t[IP_VS_TCP_S_CLOSE]\t\t=\t10*HZ,\n\t[IP_VS_TCP_S_CLOSE_WAIT]\t=\t60*HZ,\n\t[IP_VS_TCP_S_LAST_ACK]\t\t=\t30*HZ,\n\t[IP_VS_TCP_S_LISTEN]\t\t=\t2*60*HZ,\n\t[IP_VS_TCP_S_SYNACK]\t\t=\t120*HZ,\n\t[IP_VS_TCP_S_LAST]\t\t=\t2*HZ,\n};\n\nstatic const char *const tcp_state_name_table[IP_VS_TCP_S_LAST+1] = {\n\t[IP_VS_TCP_S_NONE]\t\t=\t\"NONE\",\n\t[IP_VS_TCP_S_ESTABLISHED]\t=\t\"ESTABLISHED\",\n\t[IP_VS_TCP_S_SYN_SENT]\t\t=\t\"SYN_SENT\",\n\t[IP_VS_TCP_S_SYN_RECV]\t\t=\t\"SYN_RECV\",\n\t[IP_VS_TCP_S_FIN_WAIT]\t\t=\t\"FIN_WAIT\",\n\t[IP_VS_TCP_S_TIME_WAIT]\t\t=\t\"TIME_WAIT\",\n\t[IP_VS_TCP_S_CLOSE]\t\t=\t\"CLOSE\",\n\t[IP_VS_TCP_S_CLOSE_WAIT]\t=\t\"CLOSE_WAIT\",\n\t[IP_VS_TCP_S_LAST_ACK]\t\t=\t\"LAST_ACK\",\n\t[IP_VS_TCP_S_LISTEN]\t\t=\t\"LISTEN\",\n\t[IP_VS_TCP_S_SYNACK]\t\t=\t\"SYNACK\",\n\t[IP_VS_TCP_S_LAST]\t\t=\t\"BUG!\",\n};\n\nstatic const bool tcp_state_active_table[IP_VS_TCP_S_LAST] = {\n\t[IP_VS_TCP_S_NONE]\t\t=\tfalse,\n\t[IP_VS_TCP_S_ESTABLISHED]\t=\ttrue,\n\t[IP_VS_TCP_S_SYN_SENT]\t\t=\ttrue,\n\t[IP_VS_TCP_S_SYN_RECV]\t\t=\ttrue,\n\t[IP_VS_TCP_S_FIN_WAIT]\t\t=\tfalse,\n\t[IP_VS_TCP_S_TIME_WAIT]\t\t=\tfalse,\n\t[IP_VS_TCP_S_CLOSE]\t\t=\tfalse,\n\t[IP_VS_TCP_S_CLOSE_WAIT]\t=\tfalse,\n\t[IP_VS_TCP_S_LAST_ACK]\t\t=\tfalse,\n\t[IP_VS_TCP_S_LISTEN]\t\t=\tfalse,\n\t[IP_VS_TCP_S_SYNACK]\t\t=\ttrue,\n};\n\n#define sNO IP_VS_TCP_S_NONE\n#define sES IP_VS_TCP_S_ESTABLISHED\n#define sSS IP_VS_TCP_S_SYN_SENT\n#define sSR IP_VS_TCP_S_SYN_RECV\n#define sFW IP_VS_TCP_S_FIN_WAIT\n#define sTW IP_VS_TCP_S_TIME_WAIT\n#define sCL IP_VS_TCP_S_CLOSE\n#define sCW IP_VS_TCP_S_CLOSE_WAIT\n#define sLA IP_VS_TCP_S_LAST_ACK\n#define sLI IP_VS_TCP_S_LISTEN\n#define sSA IP_VS_TCP_S_SYNACK\n\nstruct tcp_states_t {\n\tint next_state[IP_VS_TCP_S_LAST];\n};\n\nstatic const char * tcp_state_name(int state)\n{\n\tif (state >= IP_VS_TCP_S_LAST)\n\t\treturn \"ERR!\";\n\treturn tcp_state_name_table[state] ? tcp_state_name_table[state] : \"?\";\n}\n\nstatic bool tcp_state_active(int state)\n{\n\tif (state >= IP_VS_TCP_S_LAST)\n\t\treturn false;\n\treturn tcp_state_active_table[state];\n}\n\nstatic struct tcp_states_t tcp_states[] = {\n \n \n  {{sSR, sES, sES, sSR, sSR, sSR, sSR, sSR, sSR, sSR, sSR }},\n  {{sCL, sCW, sSS, sTW, sTW, sTW, sCL, sCW, sLA, sLI, sTW }},\n  {{sES, sES, sSS, sES, sFW, sTW, sCL, sCW, sCL, sLI, sES }},\n  {{sCL, sCL, sCL, sSR, sCL, sCL, sCL, sCL, sLA, sLI, sSR }},\n\n \n \n  {{sSS, sES, sSS, sSR, sSS, sSS, sSS, sSS, sSS, sLI, sSR }},\n  {{sTW, sFW, sSS, sTW, sFW, sTW, sCL, sTW, sLA, sLI, sTW }},\n  {{sES, sES, sSS, sES, sFW, sTW, sCL, sCW, sLA, sES, sES }},\n  {{sCL, sCL, sSS, sCL, sCL, sTW, sCL, sCL, sCL, sCL, sCL }},\n\n \n \n  {{sSR, sES, sES, sSR, sSR, sSR, sSR, sSR, sSR, sSR, sSR }},\n  {{sCL, sFW, sSS, sTW, sFW, sTW, sCL, sCW, sLA, sLI, sTW }},\n  {{sES, sES, sSS, sES, sFW, sTW, sCL, sCW, sCL, sLI, sES }},\n  {{sCL, sCL, sCL, sSR, sCL, sCL, sCL, sCL, sLA, sLI, sCL }},\n};\n\nstatic struct tcp_states_t tcp_states_dos[] = {\n \n \n  {{sSR, sES, sES, sSR, sSR, sSR, sSR, sSR, sSR, sSR, sSA }},\n  {{sCL, sCW, sSS, sTW, sTW, sTW, sCL, sCW, sLA, sLI, sSA }},\n  {{sES, sES, sSS, sSR, sFW, sTW, sCL, sCW, sCL, sLI, sSA }},\n  {{sCL, sCL, sCL, sSR, sCL, sCL, sCL, sCL, sLA, sLI, sCL }},\n\n \n \n  {{sSS, sES, sSS, sSA, sSS, sSS, sSS, sSS, sSS, sLI, sSA }},\n  {{sTW, sFW, sSS, sTW, sFW, sTW, sCL, sTW, sLA, sLI, sTW }},\n  {{sES, sES, sSS, sES, sFW, sTW, sCL, sCW, sLA, sES, sES }},\n  {{sCL, sCL, sSS, sCL, sCL, sTW, sCL, sCL, sCL, sCL, sCL }},\n\n \n \n  {{sSA, sES, sES, sSR, sSA, sSA, sSA, sSA, sSA, sSA, sSA }},\n  {{sCL, sFW, sSS, sTW, sFW, sTW, sCL, sCW, sLA, sLI, sTW }},\n  {{sES, sES, sSS, sES, sFW, sTW, sCL, sCW, sCL, sLI, sES }},\n  {{sCL, sCL, sCL, sSR, sCL, sCL, sCL, sCL, sLA, sLI, sCL }},\n};\n\nstatic void tcp_timeout_change(struct ip_vs_proto_data *pd, int flags)\n{\n\tint on = (flags & 1);\t\t \n\n\t \n\tpd->tcp_state_table = (on ? tcp_states_dos : tcp_states);\n}\n\nstatic inline int tcp_state_idx(struct tcphdr *th)\n{\n\tif (th->rst)\n\t\treturn 3;\n\tif (th->syn)\n\t\treturn 0;\n\tif (th->fin)\n\t\treturn 1;\n\tif (th->ack)\n\t\treturn 2;\n\treturn -1;\n}\n\nstatic inline void\nset_tcp_state(struct ip_vs_proto_data *pd, struct ip_vs_conn *cp,\n\t      int direction, struct tcphdr *th)\n{\n\tint state_idx;\n\tint new_state = IP_VS_TCP_S_CLOSE;\n\tint state_off = tcp_state_off[direction];\n\n\t \n\tif (cp->flags & IP_VS_CONN_F_NOOUTPUT) {\n\t\tif (state_off == TCP_DIR_OUTPUT)\n\t\t\tcp->flags &= ~IP_VS_CONN_F_NOOUTPUT;\n\t\telse\n\t\t\tstate_off = TCP_DIR_INPUT_ONLY;\n\t}\n\n\tif ((state_idx = tcp_state_idx(th)) < 0) {\n\t\tIP_VS_DBG(8, \"tcp_state_idx=%d!!!\\n\", state_idx);\n\t\tgoto tcp_state_out;\n\t}\n\n\tnew_state =\n\t\tpd->tcp_state_table[state_off+state_idx].next_state[cp->state];\n\n  tcp_state_out:\n\tif (new_state != cp->state) {\n\t\tstruct ip_vs_dest *dest = cp->dest;\n\n\t\tIP_VS_DBG_BUF(8, \"%s %s [%c%c%c%c] c:%s:%d v:%s:%d \"\n\t\t\t      \"d:%s:%d state: %s->%s conn->refcnt:%d\\n\",\n\t\t\t      pd->pp->name,\n\t\t\t      ((state_off == TCP_DIR_OUTPUT) ?\n\t\t\t       \"output \" : \"input \"),\n\t\t\t      th->syn ? 'S' : '.',\n\t\t\t      th->fin ? 'F' : '.',\n\t\t\t      th->ack ? 'A' : '.',\n\t\t\t      th->rst ? 'R' : '.',\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr),\n\t\t\t      ntohs(cp->cport),\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr),\n\t\t\t      ntohs(cp->vport),\n\t\t\t      IP_VS_DBG_ADDR(cp->daf, &cp->daddr),\n\t\t\t      ntohs(cp->dport),\n\t\t\t      tcp_state_name(cp->state),\n\t\t\t      tcp_state_name(new_state),\n\t\t\t      refcount_read(&cp->refcnt));\n\n\t\tif (dest) {\n\t\t\tif (!(cp->flags & IP_VS_CONN_F_INACTIVE) &&\n\t\t\t    !tcp_state_active(new_state)) {\n\t\t\t\tatomic_dec(&dest->activeconns);\n\t\t\t\tatomic_inc(&dest->inactconns);\n\t\t\t\tcp->flags |= IP_VS_CONN_F_INACTIVE;\n\t\t\t} else if ((cp->flags & IP_VS_CONN_F_INACTIVE) &&\n\t\t\t\t   tcp_state_active(new_state)) {\n\t\t\t\tatomic_inc(&dest->activeconns);\n\t\t\t\tatomic_dec(&dest->inactconns);\n\t\t\t\tcp->flags &= ~IP_VS_CONN_F_INACTIVE;\n\t\t\t}\n\t\t}\n\t\tif (new_state == IP_VS_TCP_S_ESTABLISHED)\n\t\t\tip_vs_control_assure_ct(cp);\n\t}\n\n\tif (likely(pd))\n\t\tcp->timeout = pd->timeout_table[cp->state = new_state];\n\telse\t \n\t\tcp->timeout = tcp_timeouts[cp->state = new_state];\n}\n\n \nstatic void\ntcp_state_transition(struct ip_vs_conn *cp, int direction,\n\t\t     const struct sk_buff *skb,\n\t\t     struct ip_vs_proto_data *pd)\n{\n\tstruct tcphdr _tcph, *th;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tint ihl = cp->af == AF_INET ? ip_hdrlen(skb) : sizeof(struct ipv6hdr);\n#else\n\tint ihl = ip_hdrlen(skb);\n#endif\n\n\tth = skb_header_pointer(skb, ihl, sizeof(_tcph), &_tcph);\n\tif (th == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&cp->lock);\n\tset_tcp_state(pd, cp, direction, th);\n\tspin_unlock_bh(&cp->lock);\n}\n\nstatic inline __u16 tcp_app_hashkey(__be16 port)\n{\n\treturn (((__force u16)port >> TCP_APP_TAB_BITS) ^ (__force u16)port)\n\t\t& TCP_APP_TAB_MASK;\n}\n\n\nstatic int tcp_register_app(struct netns_ipvs *ipvs, struct ip_vs_app *inc)\n{\n\tstruct ip_vs_app *i;\n\t__u16 hash;\n\t__be16 port = inc->port;\n\tint ret = 0;\n\tstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(ipvs, IPPROTO_TCP);\n\n\thash = tcp_app_hashkey(port);\n\n\tlist_for_each_entry(i, &ipvs->tcp_apps[hash], p_list) {\n\t\tif (i->port == port) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlist_add_rcu(&inc->p_list, &ipvs->tcp_apps[hash]);\n\tatomic_inc(&pd->appcnt);\n\n  out:\n\treturn ret;\n}\n\n\nstatic void\ntcp_unregister_app(struct netns_ipvs *ipvs, struct ip_vs_app *inc)\n{\n\tstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(ipvs, IPPROTO_TCP);\n\n\tatomic_dec(&pd->appcnt);\n\tlist_del_rcu(&inc->p_list);\n}\n\n\nstatic int\ntcp_app_conn_bind(struct ip_vs_conn *cp)\n{\n\tstruct netns_ipvs *ipvs = cp->ipvs;\n\tint hash;\n\tstruct ip_vs_app *inc;\n\tint result = 0;\n\n\t \n\tif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)\n\t\treturn 0;\n\n\t \n\thash = tcp_app_hashkey(cp->vport);\n\n\tlist_for_each_entry_rcu(inc, &ipvs->tcp_apps[hash], p_list) {\n\t\tif (inc->port == cp->vport) {\n\t\t\tif (unlikely(!ip_vs_app_inc_get(inc)))\n\t\t\t\tbreak;\n\n\t\t\tIP_VS_DBG_BUF(9, \"%s(): Binding conn %s:%u->\"\n\t\t\t\t      \"%s:%u to app %s on port %u\\n\",\n\t\t\t\t      __func__,\n\t\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr),\n\t\t\t\t      ntohs(cp->cport),\n\t\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr),\n\t\t\t\t      ntohs(cp->vport),\n\t\t\t\t      inc->name, ntohs(inc->port));\n\n\t\t\tcp->app = inc;\n\t\t\tif (inc->init_conn)\n\t\t\t\tresult = inc->init_conn(inc, cp);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n\n \nvoid ip_vs_tcp_conn_listen(struct ip_vs_conn *cp)\n{\n\tstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(cp->ipvs, IPPROTO_TCP);\n\n\tspin_lock_bh(&cp->lock);\n\tcp->state = IP_VS_TCP_S_LISTEN;\n\tcp->timeout = (pd ? pd->timeout_table[IP_VS_TCP_S_LISTEN]\n\t\t\t   : tcp_timeouts[IP_VS_TCP_S_LISTEN]);\n\tspin_unlock_bh(&cp->lock);\n}\n\n \nstatic int __ip_vs_tcp_init(struct netns_ipvs *ipvs, struct ip_vs_proto_data *pd)\n{\n\tip_vs_init_hash_table(ipvs->tcp_apps, TCP_APP_TAB_SIZE);\n\tpd->timeout_table = ip_vs_create_timeout_table((int *)tcp_timeouts,\n\t\t\t\t\t\t\tsizeof(tcp_timeouts));\n\tif (!pd->timeout_table)\n\t\treturn -ENOMEM;\n\tpd->tcp_state_table = tcp_states;\n\treturn 0;\n}\n\nstatic void __ip_vs_tcp_exit(struct netns_ipvs *ipvs, struct ip_vs_proto_data *pd)\n{\n\tkfree(pd->timeout_table);\n}\n\n\nstruct ip_vs_protocol ip_vs_protocol_tcp = {\n\t.name =\t\t\t\"TCP\",\n\t.protocol =\t\tIPPROTO_TCP,\n\t.num_states =\t\tIP_VS_TCP_S_LAST,\n\t.dont_defrag =\t\t0,\n\t.init =\t\t\tNULL,\n\t.exit =\t\t\tNULL,\n\t.init_netns =\t\t__ip_vs_tcp_init,\n\t.exit_netns =\t\t__ip_vs_tcp_exit,\n\t.register_app =\t\ttcp_register_app,\n\t.unregister_app =\ttcp_unregister_app,\n\t.conn_schedule =\ttcp_conn_schedule,\n\t.conn_in_get =\t\tip_vs_conn_in_get_proto,\n\t.conn_out_get =\t\tip_vs_conn_out_get_proto,\n\t.snat_handler =\t\ttcp_snat_handler,\n\t.dnat_handler =\t\ttcp_dnat_handler,\n\t.state_name =\t\ttcp_state_name,\n\t.state_transition =\ttcp_state_transition,\n\t.app_conn_bind =\ttcp_app_conn_bind,\n\t.debug_packet =\t\tip_vs_tcpudp_debug_packet,\n\t.timeout_change =\ttcp_timeout_change,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}