{
  "module_name": "nft_redir.c",
  "hash_id": "38e1198a5bb1449a031ad6128b7f13a92c7dc1f11cd2aca0758b5019bc4425d2",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_redir.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_nat_redirect.h>\n#include <net/netfilter/nf_tables.h>\n\nstruct nft_redir {\n\tu8\t\t\tsreg_proto_min;\n\tu8\t\t\tsreg_proto_max;\n\tu16\t\t\tflags;\n};\n\nstatic const struct nla_policy nft_redir_policy[NFTA_REDIR_MAX + 1] = {\n\t[NFTA_REDIR_REG_PROTO_MIN]\t= { .type = NLA_U32 },\n\t[NFTA_REDIR_REG_PROTO_MAX]\t= { .type = NLA_U32 },\n\t[NFTA_REDIR_FLAGS]\t\t=\n\t\tNLA_POLICY_MASK(NLA_BE32, NF_NAT_RANGE_MASK),\n};\n\nstatic int nft_redir_validate(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr,\n\t\t\t      const struct nft_data **data)\n{\n\tint err;\n\n\terr = nft_chain_validate_dependency(ctx->chain, NFT_CHAIN_T_NAT);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn nft_chain_validate_hooks(ctx->chain,\n\t\t\t\t\t(1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t\t(1 << NF_INET_LOCAL_OUT));\n}\n\nstatic int nft_redir_init(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_redir *priv = nft_expr_priv(expr);\n\tunsigned int plen;\n\tint err;\n\n\tplen = sizeof_field(struct nf_nat_range, min_proto.all);\n\tif (tb[NFTA_REDIR_REG_PROTO_MIN]) {\n\t\terr = nft_parse_register_load(tb[NFTA_REDIR_REG_PROTO_MIN],\n\t\t\t\t\t      &priv->sreg_proto_min, plen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tb[NFTA_REDIR_REG_PROTO_MAX]) {\n\t\t\terr = nft_parse_register_load(tb[NFTA_REDIR_REG_PROTO_MAX],\n\t\t\t\t\t\t      &priv->sreg_proto_max,\n\t\t\t\t\t\t      plen);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tpriv->sreg_proto_max = priv->sreg_proto_min;\n\t\t}\n\n\t\tpriv->flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\n\t}\n\n\tif (tb[NFTA_REDIR_FLAGS])\n\t\tpriv->flags = ntohl(nla_get_be32(tb[NFTA_REDIR_FLAGS]));\n\n\treturn nf_ct_netns_get(ctx->net, ctx->family);\n}\n\nstatic int nft_redir_dump(struct sk_buff *skb,\n\t\t\t  const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_redir *priv = nft_expr_priv(expr);\n\n\tif (priv->sreg_proto_min) {\n\t\tif (nft_dump_register(skb, NFTA_REDIR_REG_PROTO_MIN,\n\t\t\t\t      priv->sreg_proto_min))\n\t\t\tgoto nla_put_failure;\n\t\tif (nft_dump_register(skb, NFTA_REDIR_REG_PROTO_MAX,\n\t\t\t\t      priv->sreg_proto_max))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (priv->flags != 0 &&\n\t    nla_put_be32(skb, NFTA_REDIR_FLAGS, htonl(priv->flags)))\n\t\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic void nft_redir_eval(const struct nft_expr *expr,\n\t\t\t   struct nft_regs *regs,\n\t\t\t   const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_redir *priv = nft_expr_priv(expr);\n\tstruct nf_nat_range2 range;\n\n\tmemset(&range, 0, sizeof(range));\n\trange.flags = priv->flags;\n\tif (priv->sreg_proto_min) {\n\t\trange.min_proto.all = (__force __be16)\n\t\t\tnft_reg_load16(&regs->data[priv->sreg_proto_min]);\n\t\trange.max_proto.all = (__force __be16)\n\t\t\tnft_reg_load16(&regs->data[priv->sreg_proto_max]);\n\t}\n\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tregs->verdict.code = nf_nat_redirect_ipv4(pkt->skb, &range,\n\t\t\t\t\t\t\t  nft_hook(pkt));\n\t\tbreak;\n#ifdef CONFIG_NF_TABLES_IPV6\n\tcase NFPROTO_IPV6:\n\t\tregs->verdict.code = nf_nat_redirect_ipv6(pkt->skb, &range,\n\t\t\t\t\t\t\t  nft_hook(pkt));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}\n\nstatic void\nnft_redir_ipv4_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\n{\n\tnf_ct_netns_put(ctx->net, NFPROTO_IPV4);\n}\n\nstatic struct nft_expr_type nft_redir_ipv4_type;\nstatic const struct nft_expr_ops nft_redir_ipv4_ops = {\n\t.type\t\t= &nft_redir_ipv4_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_redir)),\n\t.eval\t\t= nft_redir_eval,\n\t.init\t\t= nft_redir_init,\n\t.destroy\t= nft_redir_ipv4_destroy,\n\t.dump\t\t= nft_redir_dump,\n\t.validate\t= nft_redir_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_redir_ipv4_type __read_mostly = {\n\t.family\t\t= NFPROTO_IPV4,\n\t.name\t\t= \"redir\",\n\t.ops\t\t= &nft_redir_ipv4_ops,\n\t.policy\t\t= nft_redir_policy,\n\t.maxattr\t= NFTA_REDIR_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_NF_TABLES_IPV6\nstatic void\nnft_redir_ipv6_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\n{\n\tnf_ct_netns_put(ctx->net, NFPROTO_IPV6);\n}\n\nstatic struct nft_expr_type nft_redir_ipv6_type;\nstatic const struct nft_expr_ops nft_redir_ipv6_ops = {\n\t.type\t\t= &nft_redir_ipv6_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_redir)),\n\t.eval\t\t= nft_redir_eval,\n\t.init\t\t= nft_redir_init,\n\t.destroy\t= nft_redir_ipv6_destroy,\n\t.dump\t\t= nft_redir_dump,\n\t.validate\t= nft_redir_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_redir_ipv6_type __read_mostly = {\n\t.family\t\t= NFPROTO_IPV6,\n\t.name\t\t= \"redir\",\n\t.ops\t\t= &nft_redir_ipv6_ops,\n\t.policy\t\t= nft_redir_policy,\n\t.maxattr\t= NFTA_REDIR_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n#endif\n\n#ifdef CONFIG_NF_TABLES_INET\nstatic void\nnft_redir_inet_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\n{\n\tnf_ct_netns_put(ctx->net, NFPROTO_INET);\n}\n\nstatic struct nft_expr_type nft_redir_inet_type;\nstatic const struct nft_expr_ops nft_redir_inet_ops = {\n\t.type\t\t= &nft_redir_inet_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_redir)),\n\t.eval\t\t= nft_redir_eval,\n\t.init\t\t= nft_redir_init,\n\t.destroy\t= nft_redir_inet_destroy,\n\t.dump\t\t= nft_redir_dump,\n\t.validate\t= nft_redir_validate,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic struct nft_expr_type nft_redir_inet_type __read_mostly = {\n\t.family\t\t= NFPROTO_INET,\n\t.name\t\t= \"redir\",\n\t.ops\t\t= &nft_redir_inet_ops,\n\t.policy\t\t= nft_redir_policy,\n\t.maxattr\t= NFTA_REDIR_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_redir_module_init_inet(void)\n{\n\treturn nft_register_expr(&nft_redir_inet_type);\n}\n#else\nstatic inline int nft_redir_module_init_inet(void) { return 0; }\n#endif\n\nstatic int __init nft_redir_module_init(void)\n{\n\tint ret = nft_register_expr(&nft_redir_ipv4_type);\n\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_NF_TABLES_IPV6\n\tret = nft_register_expr(&nft_redir_ipv6_type);\n\tif (ret) {\n\t\tnft_unregister_expr(&nft_redir_ipv4_type);\n\t\treturn ret;\n\t}\n#endif\n\n\tret = nft_redir_module_init_inet();\n\tif (ret < 0) {\n\t\tnft_unregister_expr(&nft_redir_ipv4_type);\n#ifdef CONFIG_NF_TABLES_IPV6\n\t\tnft_unregister_expr(&nft_redir_ipv6_type);\n#endif\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit nft_redir_module_exit(void)\n{\n\tnft_unregister_expr(&nft_redir_ipv4_type);\n#ifdef CONFIG_NF_TABLES_IPV6\n\tnft_unregister_expr(&nft_redir_ipv6_type);\n#endif\n#ifdef CONFIG_NF_TABLES_INET\n\tnft_unregister_expr(&nft_redir_inet_type);\n#endif\n}\n\nmodule_init(nft_redir_module_init);\nmodule_exit(nft_redir_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arturo Borrero Gonzalez <arturo@debian.org>\");\nMODULE_ALIAS_NFT_EXPR(\"redir\");\nMODULE_DESCRIPTION(\"Netfilter nftables redirect support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}