{
  "module_name": "nf_conntrack_ovs.c",
  "hash_id": "0cf8187b36245f58ec1ae70cc0d03238596c53ecdc1ec40785c7133427f63057",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_ovs.c",
  "human_readable_source": "\n \n\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n#include <net/ipv6_frag.h>\n#include <net/ip.h>\n#include <linux/netfilter_ipv6.h>\n\n \nint nf_ct_helper(struct sk_buff *skb, struct nf_conn *ct,\n\t\t enum ip_conntrack_info ctinfo, u16 proto)\n{\n\tconst struct nf_conntrack_helper *helper;\n\tconst struct nf_conn_help *help;\n\tunsigned int protoff;\n\tint err;\n\n\tif (ctinfo == IP_CT_RELATED_REPLY)\n\t\treturn NF_ACCEPT;\n\n\thelp = nfct_help(ct);\n\tif (!help)\n\t\treturn NF_ACCEPT;\n\n\thelper = rcu_dereference(help->helper);\n\tif (!helper)\n\t\treturn NF_ACCEPT;\n\n\tif (helper->tuple.src.l3num != NFPROTO_UNSPEC &&\n\t    helper->tuple.src.l3num != proto)\n\t\treturn NF_ACCEPT;\n\n\tswitch (proto) {\n\tcase NFPROTO_IPV4:\n\t\tprotoff = ip_hdrlen(skb);\n\t\tproto = ip_hdr(skb)->protocol;\n\t\tbreak;\n\tcase NFPROTO_IPV6: {\n\t\tu8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\t\t__be16 frag_off;\n\t\tint ofs;\n\n\t\tofs = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr,\n\t\t\t\t       &frag_off);\n\t\tif (ofs < 0 || (frag_off & htons(~0x7)) != 0) {\n\t\t\tpr_debug(\"proto header not found\\n\");\n\t\t\treturn NF_ACCEPT;\n\t\t}\n\t\tprotoff = ofs;\n\t\tproto = nexthdr;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ONCE(1, \"helper invoked on non-IP family!\");\n\t\treturn NF_DROP;\n\t}\n\n\tif (helper->tuple.dst.protonum != proto)\n\t\treturn NF_ACCEPT;\n\n\terr = helper->help(skb, protoff, ct, ctinfo);\n\tif (err != NF_ACCEPT)\n\t\treturn err;\n\n\t \n\tif (test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) &&\n\t    !nf_ct_seq_adjust(skb, ct, ctinfo, protoff))\n\t\treturn NF_DROP;\n\treturn NF_ACCEPT;\n}\nEXPORT_SYMBOL_GPL(nf_ct_helper);\n\nint nf_ct_add_helper(struct nf_conn *ct, const char *name, u8 family,\n\t\t     u8 proto, bool nat, struct nf_conntrack_helper **hp)\n{\n\tstruct nf_conntrack_helper *helper;\n\tstruct nf_conn_help *help;\n\tint ret = 0;\n\n\thelper = nf_conntrack_helper_try_module_get(name, family, proto);\n\tif (!helper)\n\t\treturn -EINVAL;\n\n\thelp = nf_ct_helper_ext_add(ct, GFP_KERNEL);\n\tif (!help) {\n\t\tnf_conntrack_helper_put(helper);\n\t\treturn -ENOMEM;\n\t}\n#if IS_ENABLED(CONFIG_NF_NAT)\n\tif (nat) {\n\t\tret = nf_nat_helper_try_module_get(name, family, proto);\n\t\tif (ret) {\n\t\t\tnf_conntrack_helper_put(helper);\n\t\t\treturn ret;\n\t\t}\n\t}\n#endif\n\trcu_assign_pointer(help->helper, helper);\n\t*hp = helper;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nf_ct_add_helper);\n\n \nint nf_ct_skb_network_trim(struct sk_buff *skb, int family)\n{\n\tunsigned int len;\n\n\tswitch (family) {\n\tcase NFPROTO_IPV4:\n\t\tlen = skb_ip_totlen(skb);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tlen = ntohs(ipv6_hdr(skb)->payload_len);\n\t\tif (ipv6_hdr(skb)->nexthdr == NEXTHDR_HOP) {\n\t\t\tint err = nf_ip6_check_hbh_len(skb, &len);\n\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tlen += sizeof(struct ipv6hdr);\n\t\tbreak;\n\tdefault:\n\t\tlen = skb->len;\n\t}\n\n\treturn pskb_trim_rcsum(skb, len);\n}\nEXPORT_SYMBOL_GPL(nf_ct_skb_network_trim);\n\n \nint nf_ct_handle_fragments(struct net *net, struct sk_buff *skb,\n\t\t\t   u16 zone, u8 family, u8 *proto, u16 *mru)\n{\n\tint err;\n\n\tif (family == NFPROTO_IPV4) {\n\t\tenum ip_defrag_users user = IP_DEFRAG_CONNTRACK_IN + zone;\n\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\tlocal_bh_disable();\n\t\terr = ip_defrag(net, skb, user);\n\t\tlocal_bh_enable();\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*mru = IPCB(skb)->frag_max_size;\n#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV6)\n\t} else if (family == NFPROTO_IPV6) {\n\t\tenum ip6_defrag_users user = IP6_DEFRAG_CONNTRACK_IN + zone;\n\n\t\tmemset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));\n\t\terr = nf_ct_frag6_gather(net, skb, user);\n\t\tif (err) {\n\t\t\tif (err != -EINPROGRESS)\n\t\t\t\tkfree_skb(skb);\n\t\t\treturn err;\n\t\t}\n\n\t\t*proto = ipv6_hdr(skb)->nexthdr;\n\t\t*mru = IP6CB(skb)->frag_max_size;\n#endif\n\t} else {\n\t\tkfree_skb(skb);\n\t\treturn -EPFNOSUPPORT;\n\t}\n\n\tskb_clear_hash(skb);\n\tskb->ignore_df = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_ct_handle_fragments);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}