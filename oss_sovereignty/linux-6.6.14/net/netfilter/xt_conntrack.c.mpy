{
  "module_name": "xt_conntrack.c",
  "hash_id": "78774e0727cd6e5f9bfcd833e40cf271d857af8f160d95a796b4eff15f1b8a27",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_conntrack.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <net/ipv6.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_conntrack.h>\n#include <net/netfilter/nf_conntrack.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Marc Boucher <marc@mbsi.ca>\");\nMODULE_AUTHOR(\"Jan Engelhardt <jengelh@medozas.de>\");\nMODULE_DESCRIPTION(\"Xtables: connection tracking state match\");\nMODULE_ALIAS(\"ipt_conntrack\");\nMODULE_ALIAS(\"ip6t_conntrack\");\n\nstatic bool\nconntrack_addrcmp(const union nf_inet_addr *kaddr,\n                  const union nf_inet_addr *uaddr,\n                  const union nf_inet_addr *umask, unsigned int l3proto)\n{\n\tif (l3proto == NFPROTO_IPV4)\n\t\treturn ((kaddr->ip ^ uaddr->ip) & umask->ip) == 0;\n\telse if (l3proto == NFPROTO_IPV6)\n\t\treturn ipv6_masked_addr_cmp(&kaddr->in6, &umask->in6,\n\t\t       &uaddr->in6) == 0;\n\telse\n\t\treturn false;\n}\n\nstatic inline bool\nconntrack_mt_origsrc(const struct nf_conn *ct,\n                     const struct xt_conntrack_mtinfo2 *info,\n\t\t     u_int8_t family)\n{\n\treturn conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3,\n\t       &info->origsrc_addr, &info->origsrc_mask, family);\n}\n\nstatic inline bool\nconntrack_mt_origdst(const struct nf_conn *ct,\n                     const struct xt_conntrack_mtinfo2 *info,\n\t\t     u_int8_t family)\n{\n\treturn conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3,\n\t       &info->origdst_addr, &info->origdst_mask, family);\n}\n\nstatic inline bool\nconntrack_mt_replsrc(const struct nf_conn *ct,\n                     const struct xt_conntrack_mtinfo2 *info,\n\t\t     u_int8_t family)\n{\n\treturn conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3,\n\t       &info->replsrc_addr, &info->replsrc_mask, family);\n}\n\nstatic inline bool\nconntrack_mt_repldst(const struct nf_conn *ct,\n                     const struct xt_conntrack_mtinfo2 *info,\n\t\t     u_int8_t family)\n{\n\treturn conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3,\n\t       &info->repldst_addr, &info->repldst_mask, family);\n}\n\nstatic inline bool\nct_proto_port_check(const struct xt_conntrack_mtinfo2 *info,\n                    const struct nf_conn *ct)\n{\n\tconst struct nf_conntrack_tuple *tuple;\n\n\ttuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\tif ((info->match_flags & XT_CONNTRACK_PROTO) &&\n\t    (nf_ct_protonum(ct) == info->l4proto) ^\n\t    !(info->invert_flags & XT_CONNTRACK_PROTO))\n\t\treturn false;\n\n\t \n\tif ((info->match_flags & XT_CONNTRACK_ORIGSRC_PORT) &&\n\t    (tuple->src.u.all == info->origsrc_port) ^\n\t    !(info->invert_flags & XT_CONNTRACK_ORIGSRC_PORT))\n\t\treturn false;\n\n\tif ((info->match_flags & XT_CONNTRACK_ORIGDST_PORT) &&\n\t    (tuple->dst.u.all == info->origdst_port) ^\n\t    !(info->invert_flags & XT_CONNTRACK_ORIGDST_PORT))\n\t\treturn false;\n\n\ttuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;\n\n\tif ((info->match_flags & XT_CONNTRACK_REPLSRC_PORT) &&\n\t    (tuple->src.u.all == info->replsrc_port) ^\n\t    !(info->invert_flags & XT_CONNTRACK_REPLSRC_PORT))\n\t\treturn false;\n\n\tif ((info->match_flags & XT_CONNTRACK_REPLDST_PORT) &&\n\t    (tuple->dst.u.all == info->repldst_port) ^\n\t    !(info->invert_flags & XT_CONNTRACK_REPLDST_PORT))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline bool\nport_match(u16 min, u16 max, u16 port, bool invert)\n{\n\treturn (port >= min && port <= max) ^ invert;\n}\n\nstatic inline bool\nct_proto_port_check_v3(const struct xt_conntrack_mtinfo3 *info,\n\t\t       const struct nf_conn *ct)\n{\n\tconst struct nf_conntrack_tuple *tuple;\n\n\ttuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\tif ((info->match_flags & XT_CONNTRACK_PROTO) &&\n\t    (nf_ct_protonum(ct) == info->l4proto) ^\n\t    !(info->invert_flags & XT_CONNTRACK_PROTO))\n\t\treturn false;\n\n\t \n\tif ((info->match_flags & XT_CONNTRACK_ORIGSRC_PORT) &&\n\t    !port_match(info->origsrc_port, info->origsrc_port_high,\n\t\t\tntohs(tuple->src.u.all),\n\t\t\tinfo->invert_flags & XT_CONNTRACK_ORIGSRC_PORT))\n\t\treturn false;\n\n\tif ((info->match_flags & XT_CONNTRACK_ORIGDST_PORT) &&\n\t    !port_match(info->origdst_port, info->origdst_port_high,\n\t\t\tntohs(tuple->dst.u.all),\n\t\t\tinfo->invert_flags & XT_CONNTRACK_ORIGDST_PORT))\n\t\treturn false;\n\n\ttuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;\n\n\tif ((info->match_flags & XT_CONNTRACK_REPLSRC_PORT) &&\n\t    !port_match(info->replsrc_port, info->replsrc_port_high,\n\t\t\tntohs(tuple->src.u.all),\n\t\t\tinfo->invert_flags & XT_CONNTRACK_REPLSRC_PORT))\n\t\treturn false;\n\n\tif ((info->match_flags & XT_CONNTRACK_REPLDST_PORT) &&\n\t    !port_match(info->repldst_port, info->repldst_port_high,\n\t\t\tntohs(tuple->dst.u.all),\n\t\t\tinfo->invert_flags & XT_CONNTRACK_REPLDST_PORT))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nconntrack_mt(const struct sk_buff *skb, struct xt_action_param *par,\n             u16 state_mask, u16 status_mask)\n{\n\tconst struct xt_conntrack_mtinfo2 *info = par->matchinfo;\n\tenum ip_conntrack_info ctinfo;\n\tconst struct nf_conn *ct;\n\tunsigned int statebit;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\n\tif (ct)\n\t\tstatebit = XT_CONNTRACK_STATE_BIT(ctinfo);\n\telse if (ctinfo == IP_CT_UNTRACKED)\n\t\tstatebit = XT_CONNTRACK_STATE_UNTRACKED;\n\telse\n\t\tstatebit = XT_CONNTRACK_STATE_INVALID;\n\n\tif (info->match_flags & XT_CONNTRACK_STATE) {\n\t\tif (ct != NULL) {\n\t\t\tif (test_bit(IPS_SRC_NAT_BIT, &ct->status))\n\t\t\t\tstatebit |= XT_CONNTRACK_STATE_SNAT;\n\t\t\tif (test_bit(IPS_DST_NAT_BIT, &ct->status))\n\t\t\t\tstatebit |= XT_CONNTRACK_STATE_DNAT;\n\t\t}\n\t\tif (!!(state_mask & statebit) ^\n\t\t    !(info->invert_flags & XT_CONNTRACK_STATE))\n\t\t\treturn false;\n\t}\n\n\tif (ct == NULL)\n\t\treturn info->match_flags & XT_CONNTRACK_STATE;\n\tif ((info->match_flags & XT_CONNTRACK_DIRECTION) &&\n\t    (CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) ^\n\t    !(info->invert_flags & XT_CONNTRACK_DIRECTION))\n\t\treturn false;\n\n\tif (info->match_flags & XT_CONNTRACK_ORIGSRC)\n\t\tif (conntrack_mt_origsrc(ct, info, xt_family(par)) ^\n\t\t    !(info->invert_flags & XT_CONNTRACK_ORIGSRC))\n\t\t\treturn false;\n\n\tif (info->match_flags & XT_CONNTRACK_ORIGDST)\n\t\tif (conntrack_mt_origdst(ct, info, xt_family(par)) ^\n\t\t    !(info->invert_flags & XT_CONNTRACK_ORIGDST))\n\t\t\treturn false;\n\n\tif (info->match_flags & XT_CONNTRACK_REPLSRC)\n\t\tif (conntrack_mt_replsrc(ct, info, xt_family(par)) ^\n\t\t    !(info->invert_flags & XT_CONNTRACK_REPLSRC))\n\t\t\treturn false;\n\n\tif (info->match_flags & XT_CONNTRACK_REPLDST)\n\t\tif (conntrack_mt_repldst(ct, info, xt_family(par)) ^\n\t\t    !(info->invert_flags & XT_CONNTRACK_REPLDST))\n\t\t\treturn false;\n\n\tif (par->match->revision != 3) {\n\t\tif (!ct_proto_port_check(info, ct))\n\t\t\treturn false;\n\t} else {\n\t\tif (!ct_proto_port_check_v3(par->matchinfo, ct))\n\t\t\treturn false;\n\t}\n\n\tif ((info->match_flags & XT_CONNTRACK_STATUS) &&\n\t    (!!(status_mask & ct->status) ^\n\t    !(info->invert_flags & XT_CONNTRACK_STATUS)))\n\t\treturn false;\n\n\tif (info->match_flags & XT_CONNTRACK_EXPIRES) {\n\t\tunsigned long expires = nf_ct_expires(ct) / HZ;\n\n\t\tif ((expires >= info->expires_min &&\n\t\t    expires <= info->expires_max) ^\n\t\t    !(info->invert_flags & XT_CONNTRACK_EXPIRES))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool\nconntrack_mt_v1(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_conntrack_mtinfo1 *info = par->matchinfo;\n\n\treturn conntrack_mt(skb, par, info->state_mask, info->status_mask);\n}\n\nstatic bool\nconntrack_mt_v2(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_conntrack_mtinfo2 *info = par->matchinfo;\n\n\treturn conntrack_mt(skb, par, info->state_mask, info->status_mask);\n}\n\nstatic bool\nconntrack_mt_v3(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_conntrack_mtinfo3 *info = par->matchinfo;\n\n\treturn conntrack_mt(skb, par, info->state_mask, info->status_mask);\n}\n\nstatic int conntrack_mt_check(const struct xt_mtchk_param *par)\n{\n\tint ret;\n\n\tret = nf_ct_netns_get(par->net, par->family);\n\tif (ret < 0)\n\t\tpr_info_ratelimited(\"cannot load conntrack support for proto=%u\\n\",\n\t\t\t\t    par->family);\n\treturn ret;\n}\n\nstatic void conntrack_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tnf_ct_netns_put(par->net, par->family);\n}\n\nstatic struct xt_match conntrack_mt_reg[] __read_mostly = {\n\t{\n\t\t.name       = \"conntrack\",\n\t\t.revision   = 1,\n\t\t.family     = NFPROTO_UNSPEC,\n\t\t.matchsize  = sizeof(struct xt_conntrack_mtinfo1),\n\t\t.match      = conntrack_mt_v1,\n\t\t.checkentry = conntrack_mt_check,\n\t\t.destroy    = conntrack_mt_destroy,\n\t\t.me         = THIS_MODULE,\n\t},\n\t{\n\t\t.name       = \"conntrack\",\n\t\t.revision   = 2,\n\t\t.family     = NFPROTO_UNSPEC,\n\t\t.matchsize  = sizeof(struct xt_conntrack_mtinfo2),\n\t\t.match      = conntrack_mt_v2,\n\t\t.checkentry = conntrack_mt_check,\n\t\t.destroy    = conntrack_mt_destroy,\n\t\t.me         = THIS_MODULE,\n\t},\n\t{\n\t\t.name       = \"conntrack\",\n\t\t.revision   = 3,\n\t\t.family     = NFPROTO_UNSPEC,\n\t\t.matchsize  = sizeof(struct xt_conntrack_mtinfo3),\n\t\t.match      = conntrack_mt_v3,\n\t\t.checkentry = conntrack_mt_check,\n\t\t.destroy    = conntrack_mt_destroy,\n\t\t.me         = THIS_MODULE,\n\t},\n};\n\nstatic int __init conntrack_mt_init(void)\n{\n\treturn xt_register_matches(conntrack_mt_reg,\n\t       ARRAY_SIZE(conntrack_mt_reg));\n}\n\nstatic void __exit conntrack_mt_exit(void)\n{\n\txt_unregister_matches(conntrack_mt_reg, ARRAY_SIZE(conntrack_mt_reg));\n}\n\nmodule_init(conntrack_mt_init);\nmodule_exit(conntrack_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}