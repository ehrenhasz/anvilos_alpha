{
  "module_name": "xt_mac.c",
  "hash_id": "ac6e82bc185551fd73d2ad0d85e5e3ae21ebb27e3b4a08aa17b34bea72738c48",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_mac.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/etherdevice.h>\n\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter/xt_mac.h>\n#include <linux/netfilter/x_tables.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Netfilter Core Team <coreteam@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: MAC address match\");\nMODULE_ALIAS(\"ipt_mac\");\nMODULE_ALIAS(\"ip6t_mac\");\n\nstatic bool mac_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_mac_info *info = par->matchinfo;\n\tbool ret;\n\n\tif (skb->dev == NULL || skb->dev->type != ARPHRD_ETHER)\n\t\treturn false;\n\tif (skb_mac_header(skb) < skb->head)\n\t\treturn false;\n\tif (skb_mac_header(skb) + ETH_HLEN > skb->data)\n\t\treturn false;\n\tret  = ether_addr_equal(eth_hdr(skb)->h_source, info->srcaddr);\n\tret ^= info->invert;\n\treturn ret;\n}\n\nstatic struct xt_match mac_mt_reg __read_mostly = {\n\t.name      = \"mac\",\n\t.revision  = 0,\n\t.family    = NFPROTO_UNSPEC,\n\t.match     = mac_mt,\n\t.matchsize = sizeof(struct xt_mac_info),\n\t.hooks     = (1 << NF_INET_PRE_ROUTING) | (1 << NF_INET_LOCAL_IN) |\n\t             (1 << NF_INET_FORWARD),\n\t.me        = THIS_MODULE,\n};\n\nstatic int __init mac_mt_init(void)\n{\n\treturn xt_register_match(&mac_mt_reg);\n}\n\nstatic void __exit mac_mt_exit(void)\n{\n\txt_unregister_match(&mac_mt_reg);\n}\n\nmodule_init(mac_mt_init);\nmodule_exit(mac_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}