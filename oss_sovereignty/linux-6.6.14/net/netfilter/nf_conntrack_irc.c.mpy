{
  "module_name": "nf_conntrack_irc.c",
  "hash_id": "ddc0fd6b0c4c8f6de5dab95eef258ebee13cb67a26228912a0724d307eb816d9",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_irc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/skbuff.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <linux/netfilter/nf_conntrack_irc.h>\n\n#define MAX_PORTS 8\nstatic unsigned short ports[MAX_PORTS];\nstatic unsigned int ports_c;\nstatic unsigned int max_dcc_channels = 8;\nstatic unsigned int dcc_timeout __read_mostly = 300;\n \nstatic char *irc_buffer;\nstatic DEFINE_SPINLOCK(irc_buffer_lock);\n\nunsigned int (*nf_nat_irc_hook)(struct sk_buff *skb,\n\t\t\t\tenum ip_conntrack_info ctinfo,\n\t\t\t\tunsigned int protoff,\n\t\t\t\tunsigned int matchoff,\n\t\t\t\tunsigned int matchlen,\n\t\t\t\tstruct nf_conntrack_expect *exp) __read_mostly;\nEXPORT_SYMBOL_GPL(nf_nat_irc_hook);\n\n#define HELPER_NAME \"irc\"\n#define MAX_SEARCH_SIZE\t4095\n\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_DESCRIPTION(\"IRC (DCC) connection tracking helper\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"ip_conntrack_irc\");\nMODULE_ALIAS_NFCT_HELPER(HELPER_NAME);\n\nmodule_param_array(ports, ushort, &ports_c, 0400);\nMODULE_PARM_DESC(ports, \"port numbers of IRC servers\");\nmodule_param(max_dcc_channels, uint, 0400);\nMODULE_PARM_DESC(max_dcc_channels, \"max number of expected DCC channels per \"\n\t\t\t\t   \"IRC session\");\nmodule_param(dcc_timeout, uint, 0400);\nMODULE_PARM_DESC(dcc_timeout, \"timeout on for unestablished DCC channels\");\n\nstatic const char *const dccprotos[] = {\n\t\"SEND \", \"CHAT \", \"MOVE \", \"TSEND \", \"SCHAT \"\n};\n\n#define MINMATCHLEN\t5\n\n \nstatic int parse_dcc(char *data, const char *data_end, __be32 *ip,\n\t\t     u_int16_t *port, char **ad_beg_p, char **ad_end_p)\n{\n\tchar *tmp;\n\n\t \n\twhile (*data++ != ' ')\n\t\tif (data > data_end - 12)\n\t\t\treturn -1;\n\n\t \n\tfor (tmp = data; tmp <= data_end; tmp++)\n\t\tif (*tmp == '\\n')\n\t\t\tbreak;\n\tif (tmp > data_end || *tmp != '\\n')\n\t\treturn -1;\n\n\t*ad_beg_p = data;\n\t*ip = cpu_to_be32(simple_strtoul(data, &data, 10));\n\n\t \n\twhile (*data == ' ') {\n\t\tif (data >= data_end)\n\t\t\treturn -1;\n\t\tdata++;\n\t}\n\n\t*port = simple_strtoul(data, &data, 10);\n\t*ad_end_p = data;\n\n\treturn 0;\n}\n\nstatic int help(struct sk_buff *skb, unsigned int protoff,\n\t\tstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\n{\n\tunsigned int dataoff;\n\tconst struct iphdr *iph;\n\tconst struct tcphdr *th;\n\tstruct tcphdr _tcph;\n\tconst char *data_limit;\n\tchar *data, *ib_ptr;\n\tint dir = CTINFO2DIR(ctinfo);\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conntrack_tuple *tuple;\n\t__be32 dcc_ip;\n\tu_int16_t dcc_port;\n\t__be16 port;\n\tint i, ret = NF_ACCEPT;\n\tchar *addr_beg_p, *addr_end_p;\n\ttypeof(nf_nat_irc_hook) nf_nat_irc;\n\tunsigned int datalen;\n\n\t \n\tif (dir == IP_CT_DIR_REPLY)\n\t\treturn NF_ACCEPT;\n\n\t \n\tif (ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED_REPLY)\n\t\treturn NF_ACCEPT;\n\n\t \n\tth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\n\tif (th == NULL)\n\t\treturn NF_ACCEPT;\n\n\t \n\tdataoff = protoff + th->doff*4;\n\tif (dataoff >= skb->len)\n\t\treturn NF_ACCEPT;\n\n\tdatalen = skb->len - dataoff;\n\tif (datalen > MAX_SEARCH_SIZE)\n\t\tdatalen = MAX_SEARCH_SIZE;\n\n\tspin_lock_bh(&irc_buffer_lock);\n\tib_ptr = skb_header_pointer(skb, dataoff, datalen,\n\t\t\t\t    irc_buffer);\n\tif (!ib_ptr) {\n\t\tspin_unlock_bh(&irc_buffer_lock);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tdata = ib_ptr;\n\tdata_limit = ib_ptr + datalen;\n\n\t \n\twhile (data < data_limit - 10) {\n\t\tif (*data == ' ' || *data == '\\r' || *data == '\\n')\n\t\t\tdata++;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t \n\tif (data < data_limit - 10) {\n\t\tif (strncasecmp(\"PRIVMSG \", data, 8))\n\t\t\tgoto out;\n\t\tdata += 8;\n\t}\n\n\t \n\twhile (data < data_limit - (21 + MINMATCHLEN)) {\n\t\t \n\t\tif (memcmp(data, \" :\", 2)) {\n\t\t\tdata++;\n\t\t\tcontinue;\n\t\t}\n\t\tdata += 2;\n\n\t\t \n\t\tif (memcmp(data, \"\\1DCC \", 5))\n\t\t\tgoto out;\n\t\tdata += 5;\n\t\t \n\n\t\tiph = ip_hdr(skb);\n\t\tpr_debug(\"DCC found in master %pI4:%u %pI4:%u\\n\",\n\t\t\t &iph->saddr, ntohs(th->source),\n\t\t\t &iph->daddr, ntohs(th->dest));\n\n\t\tfor (i = 0; i < ARRAY_SIZE(dccprotos); i++) {\n\t\t\tif (memcmp(data, dccprotos[i], strlen(dccprotos[i]))) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdata += strlen(dccprotos[i]);\n\t\t\tpr_debug(\"DCC %s detected\\n\", dccprotos[i]);\n\n\t\t\t \n\t\t\tif (parse_dcc(data, data_limit, &dcc_ip,\n\t\t\t\t       &dcc_port, &addr_beg_p, &addr_end_p)) {\n\t\t\t\tpr_debug(\"unable to parse dcc command\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpr_debug(\"DCC bound ip/port: %pI4:%u\\n\",\n\t\t\t\t &dcc_ip, dcc_port);\n\n\t\t\t \n\t\t\ttuple = &ct->tuplehash[dir].tuple;\n\t\t\tif ((tuple->src.u3.ip != dcc_ip &&\n\t\t\t     ct->tuplehash[!dir].tuple.dst.u3.ip != dcc_ip) ||\n\t\t\t    dcc_port == 0) {\n\t\t\t\tnet_warn_ratelimited(\"Forged DCC command from %pI4: %pI4:%u\\n\",\n\t\t\t\t\t\t     &tuple->src.u3.ip,\n\t\t\t\t\t\t     &dcc_ip, dcc_port);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texp = nf_ct_expect_alloc(ct);\n\t\t\tif (exp == NULL) {\n\t\t\t\tnf_ct_helper_log(skb, ct,\n\t\t\t\t\t\t \"cannot alloc expectation\");\n\t\t\t\tret = NF_DROP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttuple = &ct->tuplehash[!dir].tuple;\n\t\t\tport = htons(dcc_port);\n\t\t\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT,\n\t\t\t\t\t  tuple->src.l3num,\n\t\t\t\t\t  NULL, &tuple->dst.u3,\n\t\t\t\t\t  IPPROTO_TCP, NULL, &port);\n\n\t\t\tnf_nat_irc = rcu_dereference(nf_nat_irc_hook);\n\t\t\tif (nf_nat_irc && ct->status & IPS_NAT_MASK)\n\t\t\t\tret = nf_nat_irc(skb, ctinfo, protoff,\n\t\t\t\t\t\t addr_beg_p - ib_ptr,\n\t\t\t\t\t\t addr_end_p - addr_beg_p,\n\t\t\t\t\t\t exp);\n\t\t\telse if (nf_ct_expect_related(exp, 0) != 0) {\n\t\t\t\tnf_ct_helper_log(skb, ct,\n\t\t\t\t\t\t \"cannot add expectation\");\n\t\t\t\tret = NF_DROP;\n\t\t\t}\n\t\t\tnf_ct_expect_put(exp);\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tspin_unlock_bh(&irc_buffer_lock);\n\treturn ret;\n}\n\nstatic struct nf_conntrack_helper irc[MAX_PORTS] __read_mostly;\nstatic struct nf_conntrack_expect_policy irc_exp_policy;\n\nstatic int __init nf_conntrack_irc_init(void)\n{\n\tint i, ret;\n\n\tif (max_dcc_channels < 1) {\n\t\tpr_err(\"max_dcc_channels must not be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (max_dcc_channels > NF_CT_EXPECT_MAX_CNT) {\n\t\tpr_err(\"max_dcc_channels must not be more than %u\\n\",\n\t\t       NF_CT_EXPECT_MAX_CNT);\n\t\treturn -EINVAL;\n\t}\n\n\tirc_exp_policy.max_expected = max_dcc_channels;\n\tirc_exp_policy.timeout = dcc_timeout;\n\n\tirc_buffer = kmalloc(MAX_SEARCH_SIZE + 1, GFP_KERNEL);\n\tif (!irc_buffer)\n\t\treturn -ENOMEM;\n\n\t \n\tif (ports_c == 0)\n\t\tports[ports_c++] = IRC_PORT;\n\n\tfor (i = 0; i < ports_c; i++) {\n\t\tnf_ct_helper_init(&irc[i], AF_INET, IPPROTO_TCP, HELPER_NAME,\n\t\t\t\t  IRC_PORT, ports[i], i, &irc_exp_policy,\n\t\t\t\t  0, help, NULL, THIS_MODULE);\n\t}\n\n\tret = nf_conntrack_helpers_register(&irc[0], ports_c);\n\tif (ret) {\n\t\tpr_err(\"failed to register helpers\\n\");\n\t\tkfree(irc_buffer);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit nf_conntrack_irc_fini(void)\n{\n\tnf_conntrack_helpers_unregister(irc, ports_c);\n\tkfree(irc_buffer);\n}\n\nmodule_init(nf_conntrack_irc_init);\nmodule_exit(nf_conntrack_irc_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}