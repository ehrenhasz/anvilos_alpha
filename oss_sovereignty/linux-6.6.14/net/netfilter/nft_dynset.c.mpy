{
  "module_name": "nft_dynset.c",
  "hash_id": "f3000ca39b6f90b98eabbfacb91d8c5c2d5fb392cfa0a35f4ef867f0d324f407",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_dynset.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n\nstruct nft_dynset {\n\tstruct nft_set\t\t\t*set;\n\tstruct nft_set_ext_tmpl\t\ttmpl;\n\tenum nft_dynset_ops\t\top:8;\n\tu8\t\t\t\tsreg_key;\n\tu8\t\t\t\tsreg_data;\n\tbool\t\t\t\tinvert;\n\tbool\t\t\t\texpr;\n\tu8\t\t\t\tnum_exprs;\n\tu64\t\t\t\ttimeout;\n\tstruct nft_expr\t\t\t*expr_array[NFT_SET_EXPR_MAX];\n\tstruct nft_set_binding\t\tbinding;\n};\n\nstatic int nft_dynset_expr_setup(const struct nft_dynset *priv,\n\t\t\t\t const struct nft_set_ext *ext)\n{\n\tstruct nft_set_elem_expr *elem_expr = nft_set_ext_expr(ext);\n\tstruct nft_expr *expr;\n\tint i;\n\n\tfor (i = 0; i < priv->num_exprs; i++) {\n\t\texpr = nft_setelem_expr_at(elem_expr, elem_expr->size);\n\t\tif (nft_expr_clone(expr, priv->expr_array[i]) < 0)\n\t\t\treturn -1;\n\n\t\telem_expr->size += priv->expr_array[i]->ops->size;\n\t}\n\n\treturn 0;\n}\n\nstatic void *nft_dynset_new(struct nft_set *set, const struct nft_expr *expr,\n\t\t\t    struct nft_regs *regs)\n{\n\tconst struct nft_dynset *priv = nft_expr_priv(expr);\n\tstruct nft_set_ext *ext;\n\tu64 timeout;\n\tvoid *elem;\n\n\tif (!atomic_add_unless(&set->nelems, 1, set->size))\n\t\treturn NULL;\n\n\ttimeout = priv->timeout ? : set->timeout;\n\telem = nft_set_elem_init(set, &priv->tmpl,\n\t\t\t\t &regs->data[priv->sreg_key], NULL,\n\t\t\t\t &regs->data[priv->sreg_data],\n\t\t\t\t timeout, 0, GFP_ATOMIC);\n\tif (IS_ERR(elem))\n\t\tgoto err1;\n\n\text = nft_set_elem_ext(set, elem);\n\tif (priv->num_exprs && nft_dynset_expr_setup(priv, ext) < 0)\n\t\tgoto err2;\n\n\treturn elem;\n\nerr2:\n\tnft_set_elem_destroy(set, elem, false);\nerr1:\n\tif (set->size)\n\t\tatomic_dec(&set->nelems);\n\treturn NULL;\n}\n\nvoid nft_dynset_eval(const struct nft_expr *expr,\n\t\t     struct nft_regs *regs, const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_dynset *priv = nft_expr_priv(expr);\n\tstruct nft_set *set = priv->set;\n\tconst struct nft_set_ext *ext;\n\tu64 timeout;\n\n\tif (priv->op == NFT_DYNSET_OP_DELETE) {\n\t\tset->ops->delete(set, &regs->data[priv->sreg_key]);\n\t\treturn;\n\t}\n\n\tif (set->ops->update(set, &regs->data[priv->sreg_key], nft_dynset_new,\n\t\t\t     expr, regs, &ext)) {\n\t\tif (priv->op == NFT_DYNSET_OP_UPDATE &&\n\t\t    nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {\n\t\t\ttimeout = priv->timeout ? : set->timeout;\n\t\t\t*nft_set_ext_expiration(ext) = get_jiffies_64() + timeout;\n\t\t}\n\n\t\tnft_set_elem_update_expr(ext, regs, pkt);\n\n\t\tif (priv->invert)\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tif (!priv->invert)\n\t\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic void nft_dynset_ext_add_expr(struct nft_dynset *priv)\n{\n\tu8 size = 0;\n\tint i;\n\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tsize += priv->expr_array[i]->ops->size;\n\n\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_EXPRESSIONS,\n\t\t\t       sizeof(struct nft_set_elem_expr) + size);\n}\n\nstatic struct nft_expr *\nnft_dynset_expr_alloc(const struct nft_ctx *ctx, const struct nft_set *set,\n\t\t      const struct nlattr *attr, int pos)\n{\n\tstruct nft_expr *expr;\n\tint err;\n\n\texpr = nft_set_elem_expr_alloc(ctx, set, attr);\n\tif (IS_ERR(expr))\n\t\treturn expr;\n\n\tif (set->exprs[pos] && set->exprs[pos]->ops != expr->ops) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_dynset_expr;\n\t}\n\n\treturn expr;\n\nerr_dynset_expr:\n\tnft_expr_destroy(ctx, expr);\n\treturn ERR_PTR(err);\n}\n\nstatic const struct nla_policy nft_dynset_policy[NFTA_DYNSET_MAX + 1] = {\n\t[NFTA_DYNSET_SET_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_SET_MAXNAMELEN - 1 },\n\t[NFTA_DYNSET_SET_ID]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_OP]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_DYNSET_SREG_KEY]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_SREG_DATA]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_TIMEOUT]\t= { .type = NLA_U64 },\n\t[NFTA_DYNSET_EXPR]\t= { .type = NLA_NESTED },\n\t[NFTA_DYNSET_FLAGS]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_EXPRESSIONS] = { .type = NLA_NESTED },\n};\n\nstatic int nft_dynset_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set *set;\n\tu64 timeout;\n\tint err, i;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\tif (tb[NFTA_DYNSET_SET_NAME] == NULL ||\n\t    tb[NFTA_DYNSET_OP] == NULL ||\n\t    tb[NFTA_DYNSET_SREG_KEY] == NULL)\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_FLAGS]) {\n\t\tu32 flags = ntohl(nla_get_be32(tb[NFTA_DYNSET_FLAGS]));\n\t\tif (flags & ~(NFT_DYNSET_F_INV | NFT_DYNSET_F_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (flags & NFT_DYNSET_F_INV)\n\t\t\tpriv->invert = true;\n\t\tif (flags & NFT_DYNSET_F_EXPR)\n\t\t\tpriv->expr = true;\n\t}\n\n\tset = nft_set_lookup_global(ctx->net, ctx->table,\n\t\t\t\t    tb[NFTA_DYNSET_SET_NAME],\n\t\t\t\t    tb[NFTA_DYNSET_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tif (set->flags & NFT_SET_OBJECT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->ops->update == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tpriv->op = ntohl(nla_get_be32(tb[NFTA_DYNSET_OP]));\n\tif (priv->op > NFT_DYNSET_OP_DELETE)\n\t\treturn -EOPNOTSUPP;\n\n\ttimeout = 0;\n\tif (tb[NFTA_DYNSET_TIMEOUT] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nf_msecs_to_jiffies64(tb[NFTA_DYNSET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_KEY], &priv->sreg_key,\n\t\t\t\t      set->klen);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_DYNSET_SREG_DATA] != NULL) {\n\t\tif (!(set->flags & NFT_SET_MAP))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (set->dtype == NFT_DATA_VERDICT)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_DATA],\n\t\t\t\t\t      &priv->sreg_data, set->dlen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (set->flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif ((tb[NFTA_DYNSET_EXPR] || tb[NFTA_DYNSET_EXPRESSIONS]) &&\n\t    !(set->flags & NFT_SET_EVAL))\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_EXPR]) {\n\t\tstruct nft_expr *dynset_expr;\n\n\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set,\n\t\t\t\t\t\t    tb[NFTA_DYNSET_EXPR], 0);\n\t\tif (IS_ERR(dynset_expr))\n\t\t\treturn PTR_ERR(dynset_expr);\n\n\t\tpriv->num_exprs++;\n\t\tpriv->expr_array[0] = dynset_expr;\n\n\t\tif (set->num_exprs > 1 ||\n\t\t    (set->num_exprs == 1 &&\n\t\t     dynset_expr->ops != set->exprs[0]->ops)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (tb[NFTA_DYNSET_EXPRESSIONS]) {\n\t\tstruct nft_expr *dynset_expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!priv->expr)\n\t\t\treturn -EINVAL;\n\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, tb[NFTA_DYNSET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set, tmp, i);\n\t\t\tif (IS_ERR(dynset_expr)) {\n\t\t\t\terr = PTR_ERR(dynset_expr);\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tpriv->expr_array[i] = dynset_expr;\n\t\t\tpriv->num_exprs++;\n\n\t\t\tif (set->num_exprs) {\n\t\t\t\tif (i >= set->num_exprs) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err_expr_free;\n\t\t\t\t}\n\t\t\t\tif (dynset_expr->ops != set->exprs[i]->ops) {\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto err_expr_free;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (set->num_exprs && set->num_exprs != i) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (set->num_exprs > 0) {\n\t\terr = nft_set_elem_expr_clone(ctx, set, priv->expr_array);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tpriv->num_exprs = set->num_exprs;\n\t}\n\n\tnft_set_ext_prepare(&priv->tmpl);\n\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_KEY, set->klen);\n\tif (set->flags & NFT_SET_MAP)\n\t\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_DATA, set->dlen);\n\n\tif (priv->num_exprs)\n\t\tnft_dynset_ext_add_expr(priv);\n\n\tif (set->flags & NFT_SET_TIMEOUT) {\n\t\tif (timeout || set->timeout) {\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_TIMEOUT);\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_EXPIRATION);\n\t\t}\n\t}\n\n\tpriv->timeout = timeout;\n\n\terr = nf_tables_bind_set(ctx, set, &priv->binding);\n\tif (err < 0)\n\t\tgoto err_expr_free;\n\n\tif (set->size == 0)\n\t\tset->size = 0xffff;\n\n\tpriv->set = set;\n\treturn 0;\n\nerr_expr_free:\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, priv->expr_array[i]);\n\treturn err;\n}\n\nstatic void nft_dynset_deactivate(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nft_expr *expr,\n\t\t\t\t  enum nft_trans_phase phase)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\n\tnf_tables_deactivate_set(ctx, priv->set, &priv->binding, phase);\n}\n\nstatic void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\n\tnf_tables_activate_set(ctx, priv->set);\n}\n\nstatic void nft_dynset_destroy(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tint i;\n\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, priv->expr_array[i]);\n\n\tnf_tables_destroy_set(ctx, priv->set);\n}\n\nstatic int nft_dynset_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_dynset *priv = nft_expr_priv(expr);\n\tu32 flags = priv->invert ? NFT_DYNSET_F_INV : 0;\n\tint i;\n\n\tif (nft_dump_register(skb, NFTA_DYNSET_SREG_KEY, priv->sreg_key))\n\t\tgoto nla_put_failure;\n\tif (priv->set->flags & NFT_SET_MAP &&\n\t    nft_dump_register(skb, NFTA_DYNSET_SREG_DATA, priv->sreg_data))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_DYNSET_OP, htonl(priv->op)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_DYNSET_SET_NAME, priv->set->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be64(skb, NFTA_DYNSET_TIMEOUT,\n\t\t\t nf_jiffies64_to_msecs(priv->timeout),\n\t\t\t NFTA_DYNSET_PAD))\n\t\tgoto nla_put_failure;\n\tif (priv->set->num_exprs == 0) {\n\t\tif (priv->num_exprs == 1) {\n\t\t\tif (nft_expr_dump(skb, NFTA_DYNSET_EXPR,\n\t\t\t\t\t  priv->expr_array[0], reset))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else if (priv->num_exprs > 1) {\n\t\t\tstruct nlattr *nest;\n\n\t\t\tnest = nla_nest_start_noflag(skb, NFTA_DYNSET_EXPRESSIONS);\n\t\t\tif (!nest)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < priv->num_exprs; i++) {\n\t\t\t\tif (nft_expr_dump(skb, NFTA_LIST_ELEM,\n\t\t\t\t\t\t  priv->expr_array[i], reset))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\t}\n\tif (nla_put_be32(skb, NFTA_DYNSET_FLAGS, htonl(flags)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic const struct nft_expr_ops nft_dynset_ops = {\n\t.type\t\t= &nft_dynset_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_dynset)),\n\t.eval\t\t= nft_dynset_eval,\n\t.init\t\t= nft_dynset_init,\n\t.destroy\t= nft_dynset_destroy,\n\t.activate\t= nft_dynset_activate,\n\t.deactivate\t= nft_dynset_deactivate,\n\t.dump\t\t= nft_dynset_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstruct nft_expr_type nft_dynset_type __read_mostly = {\n\t.name\t\t= \"dynset\",\n\t.ops\t\t= &nft_dynset_ops,\n\t.policy\t\t= nft_dynset_policy,\n\t.maxattr\t= NFTA_DYNSET_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}