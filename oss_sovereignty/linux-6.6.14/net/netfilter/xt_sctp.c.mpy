{
  "module_name": "xt_sctp.c",
  "hash_id": "c36786c5d6b262d6de234fba4d6650b3c7b0df64ad4407f45a8fca5fb6e3a8e0",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_sctp.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <linux/sctp.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_sctp.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kiran Kumar Immidi\");\nMODULE_DESCRIPTION(\"Xtables: SCTP protocol packet match\");\nMODULE_ALIAS(\"ipt_sctp\");\nMODULE_ALIAS(\"ip6t_sctp\");\n\n#define SCCHECK(cond, option, flag, invflag) (!((flag) & (option)) \\\n\t\t\t\t\t      || (!!((invflag) & (option)) ^ (cond)))\n\nstatic bool\nmatch_flags(const struct xt_sctp_flag_info *flag_info,\n\t    const int flag_count,\n\t    u_int8_t chunktype,\n\t    u_int8_t chunkflags)\n{\n\tint i;\n\n\tfor (i = 0; i < flag_count; i++)\n\t\tif (flag_info[i].chunktype == chunktype)\n\t\t\treturn (chunkflags & flag_info[i].flag_mask) == flag_info[i].flag;\n\n\treturn true;\n}\n\nstatic inline bool\nmatch_packet(const struct sk_buff *skb,\n\t     unsigned int offset,\n\t     const struct xt_sctp_info *info,\n\t     bool *hotdrop)\n{\n\tu_int32_t chunkmapcopy[256 / sizeof (u_int32_t)];\n\tconst struct sctp_chunkhdr *sch;\n\tstruct sctp_chunkhdr _sch;\n\tint chunk_match_type = info->chunk_match_type;\n\tconst struct xt_sctp_flag_info *flag_info = info->flag_info;\n\tint flag_count = info->flag_count;\n\n#ifdef DEBUG\n\tint i = 0;\n#endif\n\n\tif (chunk_match_type == SCTP_CHUNK_MATCH_ALL)\n\t\tSCTP_CHUNKMAP_COPY(chunkmapcopy, info->chunkmap);\n\n\tdo {\n\t\tsch = skb_header_pointer(skb, offset, sizeof(_sch), &_sch);\n\t\tif (sch == NULL || sch->length == 0) {\n\t\t\tpr_debug(\"Dropping invalid SCTP packet.\\n\");\n\t\t\t*hotdrop = true;\n\t\t\treturn false;\n\t\t}\n#ifdef DEBUG\n\t\tpr_debug(\"Chunk num: %d\\toffset: %d\\ttype: %d\\tlength: %d\"\n\t\t\t \"\\tflags: %x\\n\",\n\t\t\t ++i, offset, sch->type, htons(sch->length),\n\t\t\t sch->flags);\n#endif\n\t\toffset += SCTP_PAD4(ntohs(sch->length));\n\n\t\tpr_debug(\"skb->len: %d\\toffset: %d\\n\", skb->len, offset);\n\n\t\tif (SCTP_CHUNKMAP_IS_SET(info->chunkmap, sch->type)) {\n\t\t\tswitch (chunk_match_type) {\n\t\t\tcase SCTP_CHUNK_MATCH_ANY:\n\t\t\t\tif (match_flags(flag_info, flag_count,\n\t\t\t\t\tsch->type, sch->flags)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase SCTP_CHUNK_MATCH_ALL:\n\t\t\t\tif (match_flags(flag_info, flag_count,\n\t\t\t\t    sch->type, sch->flags))\n\t\t\t\t\tSCTP_CHUNKMAP_CLEAR(chunkmapcopy, sch->type);\n\t\t\t\tbreak;\n\n\t\t\tcase SCTP_CHUNK_MATCH_ONLY:\n\t\t\t\tif (!match_flags(flag_info, flag_count,\n\t\t\t\t    sch->type, sch->flags))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (chunk_match_type) {\n\t\t\tcase SCTP_CHUNK_MATCH_ONLY:\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} while (offset < skb->len);\n\n\tswitch (chunk_match_type) {\n\tcase SCTP_CHUNK_MATCH_ALL:\n\t\treturn SCTP_CHUNKMAP_IS_CLEAR(chunkmapcopy);\n\tcase SCTP_CHUNK_MATCH_ANY:\n\t\treturn false;\n\tcase SCTP_CHUNK_MATCH_ONLY:\n\t\treturn true;\n\t}\n\n\t \n\treturn false;\n}\n\nstatic bool\nsctp_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_sctp_info *info = par->matchinfo;\n\tconst struct sctphdr *sh;\n\tstruct sctphdr _sh;\n\n\tif (par->fragoff != 0) {\n\t\tpr_debug(\"Dropping non-first fragment.. FIXME\\n\");\n\t\treturn false;\n\t}\n\n\tsh = skb_header_pointer(skb, par->thoff, sizeof(_sh), &_sh);\n\tif (sh == NULL) {\n\t\tpr_debug(\"Dropping evil TCP offset=0 tinygram.\\n\");\n\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\tpr_debug(\"spt: %d\\tdpt: %d\\n\", ntohs(sh->source), ntohs(sh->dest));\n\n\treturn  SCCHECK(ntohs(sh->source) >= info->spts[0]\n\t\t\t&& ntohs(sh->source) <= info->spts[1],\n\t\t\tXT_SCTP_SRC_PORTS, info->flags, info->invflags) &&\n\t\tSCCHECK(ntohs(sh->dest) >= info->dpts[0]\n\t\t\t&& ntohs(sh->dest) <= info->dpts[1],\n\t\t\tXT_SCTP_DEST_PORTS, info->flags, info->invflags) &&\n\t\tSCCHECK(match_packet(skb, par->thoff + sizeof(_sh),\n\t\t\t\t     info, &par->hotdrop),\n\t\t\tXT_SCTP_CHUNK_TYPES, info->flags, info->invflags);\n}\n\nstatic int sctp_mt_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_sctp_info *info = par->matchinfo;\n\n\tif (info->flag_count > ARRAY_SIZE(info->flag_info))\n\t\treturn -EINVAL;\n\tif (info->flags & ~XT_SCTP_VALID_FLAGS)\n\t\treturn -EINVAL;\n\tif (info->invflags & ~XT_SCTP_VALID_FLAGS)\n\t\treturn -EINVAL;\n\tif (info->invflags & ~info->flags)\n\t\treturn -EINVAL;\n\tif (!(info->flags & XT_SCTP_CHUNK_TYPES))\n\t\treturn 0;\n\tif (info->chunk_match_type & (SCTP_CHUNK_MATCH_ALL |\n\t    SCTP_CHUNK_MATCH_ANY | SCTP_CHUNK_MATCH_ONLY))\n\t\treturn 0;\n\treturn -EINVAL;\n}\n\nstatic struct xt_match sctp_mt_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"sctp\",\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.checkentry\t= sctp_mt_check,\n\t\t.match\t\t= sctp_mt,\n\t\t.matchsize\t= sizeof(struct xt_sctp_info),\n\t\t.proto\t\t= IPPROTO_SCTP,\n\t\t.me\t\t= THIS_MODULE\n\t},\n\t{\n\t\t.name\t\t= \"sctp\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.checkentry\t= sctp_mt_check,\n\t\t.match\t\t= sctp_mt,\n\t\t.matchsize\t= sizeof(struct xt_sctp_info),\n\t\t.proto\t\t= IPPROTO_SCTP,\n\t\t.me\t\t= THIS_MODULE\n\t},\n};\n\nstatic int __init sctp_mt_init(void)\n{\n\treturn xt_register_matches(sctp_mt_reg, ARRAY_SIZE(sctp_mt_reg));\n}\n\nstatic void __exit sctp_mt_exit(void)\n{\n\txt_unregister_matches(sctp_mt_reg, ARRAY_SIZE(sctp_mt_reg));\n}\n\nmodule_init(sctp_mt_init);\nmodule_exit(sctp_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}