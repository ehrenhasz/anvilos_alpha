{
  "module_name": "nft_chain_route.c",
  "hash_id": "6bc8d3ca05b1ce76613653748a77763f9bf8e6474ee056bad53ab1cdb10974b6",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_chain_route.c",
  "human_readable_source": "\n\n#include <linux/skbuff.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_ipv4.h>\n#include <net/netfilter/nf_tables_ipv6.h>\n#include <net/route.h>\n#include <net/ip.h>\n\n#ifdef CONFIG_NF_TABLES_IPV4\nstatic unsigned int nf_route_table_hook4(void *priv,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t const struct nf_hook_state *state)\n{\n\tconst struct iphdr *iph;\n\tstruct nft_pktinfo pkt;\n\t__be32 saddr, daddr;\n\tunsigned int ret;\n\tu32 mark;\n\tint err;\n\tu8 tos;\n\n\tnft_set_pktinfo(&pkt, skb, state);\n\tnft_set_pktinfo_ipv4(&pkt);\n\n\tmark = skb->mark;\n\tiph = ip_hdr(skb);\n\tsaddr = iph->saddr;\n\tdaddr = iph->daddr;\n\ttos = iph->tos;\n\n\tret = nft_do_chain(&pkt, priv);\n\tif (ret == NF_ACCEPT) {\n\t\tiph = ip_hdr(skb);\n\n\t\tif (iph->saddr != saddr ||\n\t\t    iph->daddr != daddr ||\n\t\t    skb->mark != mark ||\n\t\t    iph->tos != tos) {\n\t\t\terr = ip_route_me_harder(state->net, state->sk, skb, RTN_UNSPEC);\n\t\t\tif (err < 0)\n\t\t\t\tret = NF_DROP_ERR(err);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic const struct nft_chain_type nft_chain_route_ipv4 = {\n\t.name\t\t= \"route\",\n\t.type\t\t= NFT_CHAIN_T_ROUTE,\n\t.family\t\t= NFPROTO_IPV4,\n\t.hook_mask\t= (1 << NF_INET_LOCAL_OUT),\n\t.hooks\t\t= {\n\t\t[NF_INET_LOCAL_OUT]\t= nf_route_table_hook4,\n\t},\n};\n#endif\n\n#ifdef CONFIG_NF_TABLES_IPV6\nstatic unsigned int nf_route_table_hook6(void *priv,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t const struct nf_hook_state *state)\n{\n\tstruct in6_addr saddr, daddr;\n\tstruct nft_pktinfo pkt;\n\tu32 mark, flowlabel;\n\tunsigned int ret;\n\tu8 hop_limit;\n\tint err;\n\n\tnft_set_pktinfo(&pkt, skb, state);\n\tnft_set_pktinfo_ipv6(&pkt);\n\n\t \n\tmemcpy(&saddr, &ipv6_hdr(skb)->saddr, sizeof(saddr));\n\tmemcpy(&daddr, &ipv6_hdr(skb)->daddr, sizeof(daddr));\n\tmark = skb->mark;\n\thop_limit = ipv6_hdr(skb)->hop_limit;\n\n\t \n\tflowlabel = *((u32 *)ipv6_hdr(skb));\n\n\tret = nft_do_chain(&pkt, priv);\n\tif (ret == NF_ACCEPT &&\n\t    (memcmp(&ipv6_hdr(skb)->saddr, &saddr, sizeof(saddr)) ||\n\t     memcmp(&ipv6_hdr(skb)->daddr, &daddr, sizeof(daddr)) ||\n\t     skb->mark != mark ||\n\t     ipv6_hdr(skb)->hop_limit != hop_limit ||\n\t     flowlabel != *((u32 *)ipv6_hdr(skb)))) {\n\t\terr = nf_ip6_route_me_harder(state->net, state->sk, skb);\n\t\tif (err < 0)\n\t\t\tret = NF_DROP_ERR(err);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nft_chain_type nft_chain_route_ipv6 = {\n\t.name\t\t= \"route\",\n\t.type\t\t= NFT_CHAIN_T_ROUTE,\n\t.family\t\t= NFPROTO_IPV6,\n\t.hook_mask\t= (1 << NF_INET_LOCAL_OUT),\n\t.hooks\t\t= {\n\t\t[NF_INET_LOCAL_OUT]\t= nf_route_table_hook6,\n\t},\n};\n#endif\n\n#ifdef CONFIG_NF_TABLES_INET\nstatic unsigned int nf_route_table_inet(void *priv,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tconst struct nf_hook_state *state)\n{\n\tstruct nft_pktinfo pkt;\n\n\tswitch (state->pf) {\n\tcase NFPROTO_IPV4:\n\t\treturn nf_route_table_hook4(priv, skb, state);\n\tcase NFPROTO_IPV6:\n\t\treturn nf_route_table_hook6(priv, skb, state);\n\tdefault:\n\t\tnft_set_pktinfo(&pkt, skb, state);\n\t\tbreak;\n\t}\n\n\treturn nft_do_chain(&pkt, priv);\n}\n\nstatic const struct nft_chain_type nft_chain_route_inet = {\n\t.name\t\t= \"route\",\n\t.type\t\t= NFT_CHAIN_T_ROUTE,\n\t.family\t\t= NFPROTO_INET,\n\t.hook_mask\t= (1 << NF_INET_LOCAL_OUT),\n\t.hooks\t\t= {\n\t\t[NF_INET_LOCAL_OUT]\t= nf_route_table_inet,\n\t},\n};\n#endif\n\nvoid __init nft_chain_route_init(void)\n{\n#ifdef CONFIG_NF_TABLES_IPV6\n\tnft_register_chain_type(&nft_chain_route_ipv6);\n#endif\n#ifdef CONFIG_NF_TABLES_IPV4\n\tnft_register_chain_type(&nft_chain_route_ipv4);\n#endif\n#ifdef CONFIG_NF_TABLES_INET\n\tnft_register_chain_type(&nft_chain_route_inet);\n#endif\n}\n\nvoid __exit nft_chain_route_fini(void)\n{\n#ifdef CONFIG_NF_TABLES_IPV6\n\tnft_unregister_chain_type(&nft_chain_route_ipv6);\n#endif\n#ifdef CONFIG_NF_TABLES_IPV4\n\tnft_unregister_chain_type(&nft_chain_route_ipv4);\n#endif\n#ifdef CONFIG_NF_TABLES_INET\n\tnft_unregister_chain_type(&nft_chain_route_inet);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}