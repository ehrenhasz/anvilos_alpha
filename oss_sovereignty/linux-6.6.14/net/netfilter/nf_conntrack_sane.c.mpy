{
  "module_name": "nf_conntrack_sane.c",
  "hash_id": "c89d2b0463589cc26089e55d5eafe7d3abb1c4e99a0be0ae5fa09f5ff141578a",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_sane.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <linux/netfilter/nf_conntrack_sane.h>\n\n#define HELPER_NAME \"sane\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michal Schmidt <mschmidt@redhat.com>\");\nMODULE_DESCRIPTION(\"SANE connection tracking helper\");\nMODULE_ALIAS_NFCT_HELPER(HELPER_NAME);\n\n#define MAX_PORTS 8\nstatic u_int16_t ports[MAX_PORTS];\nstatic unsigned int ports_c;\nmodule_param_array(ports, ushort, &ports_c, 0400);\n\nstruct sane_request {\n\t__be32 RPC_code;\n#define SANE_NET_START      7    \n\n\t__be32 handle;\n};\n\nstruct sane_reply_net_start {\n\t__be32 status;\n#define SANE_STATUS_SUCCESS 0\n\n\t__be16 zero;\n\t__be16 port;\n\t \n};\n\nstatic int help(struct sk_buff *skb,\n\t\tunsigned int protoff,\n\t\tstruct nf_conn *ct,\n\t\tenum ip_conntrack_info ctinfo)\n{\n\tunsigned int dataoff, datalen;\n\tconst struct tcphdr *th;\n\tstruct tcphdr _tcph;\n\tint ret = NF_ACCEPT;\n\tint dir = CTINFO2DIR(ctinfo);\n\tstruct nf_ct_sane_master *ct_sane_info = nfct_help_data(ct);\n\tstruct nf_conntrack_expect *exp;\n\tstruct nf_conntrack_tuple *tuple;\n\tstruct sane_reply_net_start *reply;\n\tunion {\n\t\tstruct sane_request req;\n\t\tstruct sane_reply_net_start repl;\n\t} buf;\n\n\t \n\tif (ctinfo != IP_CT_ESTABLISHED &&\n\t    ctinfo != IP_CT_ESTABLISHED_REPLY)\n\t\treturn NF_ACCEPT;\n\n\t \n\tth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\n\tif (th == NULL)\n\t\treturn NF_ACCEPT;\n\n\t \n\tdataoff = protoff + th->doff * 4;\n\tif (dataoff >= skb->len)\n\t\treturn NF_ACCEPT;\n\n\tdatalen = skb->len - dataoff;\n\tif (dir == IP_CT_DIR_ORIGINAL) {\n\t\tconst struct sane_request *req;\n\n\t\tif (datalen != sizeof(struct sane_request))\n\t\t\treturn NF_ACCEPT;\n\n\t\treq = skb_header_pointer(skb, dataoff, datalen, &buf.req);\n\t\tif (!req)\n\t\t\treturn NF_ACCEPT;\n\n\t\tif (req->RPC_code != htonl(SANE_NET_START)) {\n\t\t\t \n\t\t\tWRITE_ONCE(ct_sane_info->state, SANE_STATE_NORMAL);\n\t\t\treturn NF_ACCEPT;\n\t\t}\n\n\t\t \n\t\tWRITE_ONCE(ct_sane_info->state, SANE_STATE_START_REQUESTED);\n\t\treturn NF_ACCEPT;\n\t}\n\n\t \n\n\t \n\tif (READ_ONCE(ct_sane_info->state) != SANE_STATE_START_REQUESTED)\n\t\treturn NF_ACCEPT;\n\n\t \n\tWRITE_ONCE(ct_sane_info->state, SANE_STATE_NORMAL);\n\n\tif (datalen < sizeof(struct sane_reply_net_start)) {\n\t\tpr_debug(\"NET_START reply too short\\n\");\n\t\treturn NF_ACCEPT;\n\t}\n\n\tdatalen = sizeof(struct sane_reply_net_start);\n\n\treply = skb_header_pointer(skb, dataoff, datalen, &buf.repl);\n\tif (!reply)\n\t\treturn NF_ACCEPT;\n\n\tif (reply->status != htonl(SANE_STATUS_SUCCESS)) {\n\t\t \n\t\tpr_debug(\"unsuccessful SANE_STATUS = %u\\n\",\n\t\t\t ntohl(reply->status));\n\t\treturn NF_ACCEPT;\n\t}\n\n\t \n\tif (reply->zero != 0)\n\t\treturn NF_ACCEPT;\n\n\texp = nf_ct_expect_alloc(ct);\n\tif (exp == NULL) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot alloc expectation\");\n\t\treturn NF_DROP;\n\t}\n\n\ttuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\tnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\n\t\t\t  &tuple->src.u3, &tuple->dst.u3,\n\t\t\t  IPPROTO_TCP, NULL, &reply->port);\n\n\tpr_debug(\"expect: \");\n\tnf_ct_dump_tuple(&exp->tuple);\n\n\t \n\tif (nf_ct_expect_related(exp, 0) != 0) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot add expectation\");\n\t\tret = NF_DROP;\n\t}\n\n\tnf_ct_expect_put(exp);\n\treturn ret;\n}\n\nstatic struct nf_conntrack_helper sane[MAX_PORTS * 2] __read_mostly;\n\nstatic const struct nf_conntrack_expect_policy sane_exp_policy = {\n\t.max_expected\t= 1,\n\t.timeout\t= 5 * 60,\n};\n\nstatic void __exit nf_conntrack_sane_fini(void)\n{\n\tnf_conntrack_helpers_unregister(sane, ports_c * 2);\n}\n\nstatic int __init nf_conntrack_sane_init(void)\n{\n\tint i, ret = 0;\n\n\tNF_CT_HELPER_BUILD_BUG_ON(sizeof(struct nf_ct_sane_master));\n\n\tif (ports_c == 0)\n\t\tports[ports_c++] = SANE_PORT;\n\n\t \n\tfor (i = 0; i < ports_c; i++) {\n\t\tnf_ct_helper_init(&sane[2 * i], AF_INET, IPPROTO_TCP,\n\t\t\t\t  HELPER_NAME, SANE_PORT, ports[i], ports[i],\n\t\t\t\t  &sane_exp_policy, 0, help, NULL,\n\t\t\t\t  THIS_MODULE);\n\t\tnf_ct_helper_init(&sane[2 * i + 1], AF_INET6, IPPROTO_TCP,\n\t\t\t\t  HELPER_NAME, SANE_PORT, ports[i], ports[i],\n\t\t\t\t  &sane_exp_policy, 0, help, NULL,\n\t\t\t\t  THIS_MODULE);\n\t}\n\n\tret = nf_conntrack_helpers_register(sane, ports_c * 2);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to register helpers\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nmodule_init(nf_conntrack_sane_init);\nmodule_exit(nf_conntrack_sane_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}