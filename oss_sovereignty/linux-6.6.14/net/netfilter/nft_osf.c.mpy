{
  "module_name": "nft_osf.c",
  "hash_id": "f93f4cb9f29b7f04de698c5e9be9137c76ca085ae11e88d1d62e8dfa3f7b2d3c",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nft_osf.c",
  "human_readable_source": "\n#include <net/ip.h>\n#include <net/tcp.h>\n\n#include <net/netfilter/nf_tables.h>\n#include <linux/netfilter/nfnetlink_osf.h>\n\nstruct nft_osf {\n\tu8\t\t\tdreg;\n\tu8\t\t\tttl;\n\tu32\t\t\tflags;\n};\n\nstatic const struct nla_policy nft_osf_policy[NFTA_OSF_MAX + 1] = {\n\t[NFTA_OSF_DREG]\t\t= { .type = NLA_U32 },\n\t[NFTA_OSF_TTL]\t\t= { .type = NLA_U8 },\n\t[NFTA_OSF_FLAGS]\t= { .type = NLA_U32 },\n};\n\nstatic void nft_osf_eval(const struct nft_expr *expr, struct nft_regs *regs,\n\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct nft_osf *priv = nft_expr_priv(expr);\n\tu32 *dest = &regs->data[priv->dreg];\n\tstruct sk_buff *skb = pkt->skb;\n\tchar os_match[NFT_OSF_MAXGENRELEN];\n\tconst struct tcphdr *tcp;\n\tstruct nf_osf_data data;\n\tstruct tcphdr _tcph;\n\n\tif (pkt->tprot != IPPROTO_TCP) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\ttcp = skb_header_pointer(skb, ip_hdrlen(skb),\n\t\t\t\t sizeof(struct tcphdr), &_tcph);\n\tif (!tcp) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\tif (!tcp->syn) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tif (!nf_osf_find(skb, nf_osf_fingers, priv->ttl, &data)) {\n\t\tstrscpy_pad((char *)dest, \"unknown\", NFT_OSF_MAXGENRELEN);\n\t} else {\n\t\tif (priv->flags & NFT_OSF_F_VERSION)\n\t\t\tsnprintf(os_match, NFT_OSF_MAXGENRELEN, \"%s:%s\",\n\t\t\t\t data.genre, data.version);\n\t\telse\n\t\t\tstrscpy(os_match, data.genre, NFT_OSF_MAXGENRELEN);\n\n\t\tstrscpy_pad((char *)dest, os_match, NFT_OSF_MAXGENRELEN);\n\t}\n}\n\nstatic int nft_osf_init(const struct nft_ctx *ctx,\n\t\t\tconst struct nft_expr *expr,\n\t\t\tconst struct nlattr * const tb[])\n{\n\tstruct nft_osf *priv = nft_expr_priv(expr);\n\tu32 flags;\n\tint err;\n\tu8 ttl;\n\n\tif (!tb[NFTA_OSF_DREG])\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_OSF_TTL]) {\n\t\tttl = nla_get_u8(tb[NFTA_OSF_TTL]);\n\t\tif (ttl > 2)\n\t\t\treturn -EINVAL;\n\t\tpriv->ttl = ttl;\n\t}\n\n\tif (tb[NFTA_OSF_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(tb[NFTA_OSF_FLAGS]));\n\t\tif (flags != NFT_OSF_F_VERSION)\n\t\t\treturn -EINVAL;\n\t\tpriv->flags = flags;\n\t}\n\n\terr = nft_parse_register_store(ctx, tb[NFTA_OSF_DREG], &priv->dreg,\n\t\t\t\t       NULL, NFT_DATA_VALUE,\n\t\t\t\t       NFT_OSF_MAXGENRELEN);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int nft_osf_dump(struct sk_buff *skb,\n\t\t\tconst struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_osf *priv = nft_expr_priv(expr);\n\n\tif (nla_put_u8(skb, NFTA_OSF_TTL, priv->ttl))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, NFTA_OSF_FLAGS, ntohl((__force __be32)priv->flags)))\n\t\tgoto nla_put_failure;\n\n\tif (nft_dump_register(skb, NFTA_OSF_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic int nft_osf_validate(const struct nft_ctx *ctx,\n\t\t\t    const struct nft_expr *expr,\n\t\t\t    const struct nft_data **data)\n{\n\tunsigned int hooks;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\thooks = (1 << NF_INET_LOCAL_IN) |\n\t\t\t(1 << NF_INET_PRE_ROUTING) |\n\t\t\t(1 << NF_INET_FORWARD);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\n\nstatic bool nft_osf_reduce(struct nft_regs_track *track,\n\t\t\t   const struct nft_expr *expr)\n{\n\tstruct nft_osf *priv = nft_expr_priv(expr);\n\tstruct nft_osf *osf;\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, NFT_OSF_MAXGENRELEN);\n\t\treturn false;\n\t}\n\n\tosf = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->flags != osf->flags ||\n\t    priv->ttl != osf->ttl) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, NFT_OSF_MAXGENRELEN);\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct nft_expr_type nft_osf_type;\nstatic const struct nft_expr_ops nft_osf_op = {\n\t.eval\t\t= nft_osf_eval,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_osf)),\n\t.init\t\t= nft_osf_init,\n\t.dump\t\t= nft_osf_dump,\n\t.type\t\t= &nft_osf_type,\n\t.validate\t= nft_osf_validate,\n\t.reduce\t\t= nft_osf_reduce,\n};\n\nstatic struct nft_expr_type nft_osf_type __read_mostly = {\n\t.ops\t\t= &nft_osf_op,\n\t.name\t\t= \"osf\",\n\t.owner\t\t= THIS_MODULE,\n\t.policy\t\t= nft_osf_policy,\n\t.maxattr\t= NFTA_OSF_MAX,\n};\n\nstatic int __init nft_osf_module_init(void)\n{\n\treturn nft_register_expr(&nft_osf_type);\n}\n\nstatic void __exit nft_osf_module_exit(void)\n{\n\treturn nft_unregister_expr(&nft_osf_type);\n}\n\nmodule_init(nft_osf_module_init);\nmodule_exit(nft_osf_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Fernando Fernandez <ffmancera@riseup.net>\");\nMODULE_ALIAS_NFT_EXPR(\"osf\");\nMODULE_DESCRIPTION(\"nftables passive OS fingerprint support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}