{
  "module_name": "xt_hashlimit.c",
  "hash_id": "b9a84bf9ced4709c040133048fd3730ebd3f0ae072d3bf254554362f1d819bd3",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/xt_hashlimit.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/skbuff.h>\n#include <linux/mm.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n#include <linux/ipv6.h>\n#include <net/ipv6.h>\n#endif\n\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/refcount.h>\n#include <uapi/linux/netfilter/xt_hashlimit.h>\n\n#define XT_HASHLIMIT_ALL (XT_HASHLIMIT_HASH_DIP | XT_HASHLIMIT_HASH_DPT | \\\n\t\t\t  XT_HASHLIMIT_HASH_SIP | XT_HASHLIMIT_HASH_SPT | \\\n\t\t\t  XT_HASHLIMIT_INVERT | XT_HASHLIMIT_BYTES |\\\n\t\t\t  XT_HASHLIMIT_RATE_MATCH)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_AUTHOR(\"Jan Engelhardt <jengelh@medozas.de>\");\nMODULE_DESCRIPTION(\"Xtables: per hash-bucket rate-limit match\");\nMODULE_ALIAS(\"ipt_hashlimit\");\nMODULE_ALIAS(\"ip6t_hashlimit\");\n\nstruct hashlimit_net {\n\tstruct hlist_head\thtables;\n\tstruct proc_dir_entry\t*ipt_hashlimit;\n\tstruct proc_dir_entry\t*ip6t_hashlimit;\n};\n\nstatic unsigned int hashlimit_net_id;\nstatic inline struct hashlimit_net *hashlimit_pernet(struct net *net)\n{\n\treturn net_generic(net, hashlimit_net_id);\n}\n\n \nstatic const struct seq_operations dl_seq_ops_v2;\nstatic const struct seq_operations dl_seq_ops_v1;\nstatic const struct seq_operations dl_seq_ops;\n\n \nstruct dsthash_dst {\n\tunion {\n\t\tstruct {\n\t\t\t__be32 src;\n\t\t\t__be32 dst;\n\t\t} ip;\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\t\tstruct {\n\t\t\t__be32 src[4];\n\t\t\t__be32 dst[4];\n\t\t} ip6;\n#endif\n\t};\n\t__be16 src_port;\n\t__be16 dst_port;\n};\n\nstruct dsthash_ent {\n\t \n\tstruct hlist_node node;\n\tstruct dsthash_dst dst;\n\n\t \n\tspinlock_t lock;\n\tunsigned long expires;\t\t \n\tstruct {\n\t\tunsigned long prev;\t \n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tu_int64_t credit;\n\t\t\t\tu_int64_t credit_cap;\n\t\t\t\tu_int64_t cost;\n\t\t\t};\n\t\t\tstruct {\n\t\t\t\tu_int32_t interval, prev_window;\n\t\t\t\tu_int64_t current_rate;\n\t\t\t\tu_int64_t rate;\n\t\t\t\tint64_t burst;\n\t\t\t};\n\t\t};\n\t} rateinfo;\n\tstruct rcu_head rcu;\n};\n\nstruct xt_hashlimit_htable {\n\tstruct hlist_node node;\t\t \n\trefcount_t use;\n\tu_int8_t family;\n\tbool rnd_initialized;\n\n\tstruct hashlimit_cfg3 cfg;\t \n\n\t \n\tspinlock_t lock;\t\t \n\tu_int32_t rnd;\t\t\t \n\tunsigned int count;\t\t \n\tstruct delayed_work gc_work;\n\n\t \n\tstruct proc_dir_entry *pde;\n\tconst char *name;\n\tstruct net *net;\n\n\tstruct hlist_head hash[];\t \n};\n\nstatic int\ncfg_copy(struct hashlimit_cfg3 *to, const void *from, int revision)\n{\n\tif (revision == 1) {\n\t\tstruct hashlimit_cfg1 *cfg = (struct hashlimit_cfg1 *)from;\n\n\t\tto->mode = cfg->mode;\n\t\tto->avg = cfg->avg;\n\t\tto->burst = cfg->burst;\n\t\tto->size = cfg->size;\n\t\tto->max = cfg->max;\n\t\tto->gc_interval = cfg->gc_interval;\n\t\tto->expire = cfg->expire;\n\t\tto->srcmask = cfg->srcmask;\n\t\tto->dstmask = cfg->dstmask;\n\t} else if (revision == 2) {\n\t\tstruct hashlimit_cfg2 *cfg = (struct hashlimit_cfg2 *)from;\n\n\t\tto->mode = cfg->mode;\n\t\tto->avg = cfg->avg;\n\t\tto->burst = cfg->burst;\n\t\tto->size = cfg->size;\n\t\tto->max = cfg->max;\n\t\tto->gc_interval = cfg->gc_interval;\n\t\tto->expire = cfg->expire;\n\t\tto->srcmask = cfg->srcmask;\n\t\tto->dstmask = cfg->dstmask;\n\t} else if (revision == 3) {\n\t\tmemcpy(to, from, sizeof(struct hashlimit_cfg3));\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(hashlimit_mutex);\t \nstatic struct kmem_cache *hashlimit_cachep __read_mostly;\n\nstatic inline bool dst_cmp(const struct dsthash_ent *ent,\n\t\t\t   const struct dsthash_dst *b)\n{\n\treturn !memcmp(&ent->dst, b, sizeof(ent->dst));\n}\n\nstatic u_int32_t\nhash_dst(const struct xt_hashlimit_htable *ht, const struct dsthash_dst *dst)\n{\n\tu_int32_t hash = jhash2((const u32 *)dst,\n\t\t\t\tsizeof(*dst)/sizeof(u32),\n\t\t\t\tht->rnd);\n\t \n\treturn reciprocal_scale(hash, ht->cfg.size);\n}\n\nstatic struct dsthash_ent *\ndsthash_find(const struct xt_hashlimit_htable *ht,\n\t     const struct dsthash_dst *dst)\n{\n\tstruct dsthash_ent *ent;\n\tu_int32_t hash = hash_dst(ht, dst);\n\n\tif (!hlist_empty(&ht->hash[hash])) {\n\t\thlist_for_each_entry_rcu(ent, &ht->hash[hash], node)\n\t\t\tif (dst_cmp(ent, dst)) {\n\t\t\t\tspin_lock(&ent->lock);\n\t\t\t\treturn ent;\n\t\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic struct dsthash_ent *\ndsthash_alloc_init(struct xt_hashlimit_htable *ht,\n\t\t   const struct dsthash_dst *dst, bool *race)\n{\n\tstruct dsthash_ent *ent;\n\n\tspin_lock(&ht->lock);\n\n\t \n\tent = dsthash_find(ht, dst);\n\tif (ent != NULL) {\n\t\tspin_unlock(&ht->lock);\n\t\t*race = true;\n\t\treturn ent;\n\t}\n\n\t \n\tif (unlikely(!ht->rnd_initialized)) {\n\t\tget_random_bytes(&ht->rnd, sizeof(ht->rnd));\n\t\tht->rnd_initialized = true;\n\t}\n\n\tif (ht->cfg.max && ht->count >= ht->cfg.max) {\n\t\t \n\t\tnet_err_ratelimited(\"max count of %u reached\\n\", ht->cfg.max);\n\t\tent = NULL;\n\t} else\n\t\tent = kmem_cache_alloc(hashlimit_cachep, GFP_ATOMIC);\n\tif (ent) {\n\t\tmemcpy(&ent->dst, dst, sizeof(ent->dst));\n\t\tspin_lock_init(&ent->lock);\n\n\t\tspin_lock(&ent->lock);\n\t\thlist_add_head_rcu(&ent->node, &ht->hash[hash_dst(ht, dst)]);\n\t\tht->count++;\n\t}\n\tspin_unlock(&ht->lock);\n\treturn ent;\n}\n\nstatic void dsthash_free_rcu(struct rcu_head *head)\n{\n\tstruct dsthash_ent *ent = container_of(head, struct dsthash_ent, rcu);\n\n\tkmem_cache_free(hashlimit_cachep, ent);\n}\n\nstatic inline void\ndsthash_free(struct xt_hashlimit_htable *ht, struct dsthash_ent *ent)\n{\n\thlist_del_rcu(&ent->node);\n\tcall_rcu(&ent->rcu, dsthash_free_rcu);\n\tht->count--;\n}\nstatic void htable_gc(struct work_struct *work);\n\nstatic int htable_create(struct net *net, struct hashlimit_cfg3 *cfg,\n\t\t\t const char *name, u_int8_t family,\n\t\t\t struct xt_hashlimit_htable **out_hinfo,\n\t\t\t int revision)\n{\n\tstruct hashlimit_net *hashlimit_net = hashlimit_pernet(net);\n\tstruct xt_hashlimit_htable *hinfo;\n\tconst struct seq_operations *ops;\n\tunsigned int size, i;\n\tunsigned long nr_pages = totalram_pages();\n\tint ret;\n\n\tif (cfg->size) {\n\t\tsize = cfg->size;\n\t} else {\n\t\tsize = (nr_pages << PAGE_SHIFT) / 16384 /\n\t\t       sizeof(struct hlist_head);\n\t\tif (nr_pages > 1024 * 1024 * 1024 / PAGE_SIZE)\n\t\t\tsize = 8192;\n\t\tif (size < 16)\n\t\t\tsize = 16;\n\t}\n\t \n\thinfo = vmalloc(struct_size(hinfo, hash, size));\n\tif (hinfo == NULL)\n\t\treturn -ENOMEM;\n\t*out_hinfo = hinfo;\n\n\t \n\tret = cfg_copy(&hinfo->cfg, (void *)cfg, 3);\n\tif (ret) {\n\t\tvfree(hinfo);\n\t\treturn ret;\n\t}\n\n\thinfo->cfg.size = size;\n\tif (hinfo->cfg.max == 0)\n\t\thinfo->cfg.max = 8 * hinfo->cfg.size;\n\telse if (hinfo->cfg.max < hinfo->cfg.size)\n\t\thinfo->cfg.max = hinfo->cfg.size;\n\n\tfor (i = 0; i < hinfo->cfg.size; i++)\n\t\tINIT_HLIST_HEAD(&hinfo->hash[i]);\n\n\trefcount_set(&hinfo->use, 1);\n\thinfo->count = 0;\n\thinfo->family = family;\n\thinfo->rnd_initialized = false;\n\thinfo->name = kstrdup(name, GFP_KERNEL);\n\tif (!hinfo->name) {\n\t\tvfree(hinfo);\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_init(&hinfo->lock);\n\n\tswitch (revision) {\n\tcase 1:\n\t\tops = &dl_seq_ops_v1;\n\t\tbreak;\n\tcase 2:\n\t\tops = &dl_seq_ops_v2;\n\t\tbreak;\n\tdefault:\n\t\tops = &dl_seq_ops;\n\t}\n\n\thinfo->pde = proc_create_seq_data(name, 0,\n\t\t(family == NFPROTO_IPV4) ?\n\t\thashlimit_net->ipt_hashlimit : hashlimit_net->ip6t_hashlimit,\n\t\tops, hinfo);\n\tif (hinfo->pde == NULL) {\n\t\tkfree(hinfo->name);\n\t\tvfree(hinfo);\n\t\treturn -ENOMEM;\n\t}\n\thinfo->net = net;\n\n\tINIT_DEFERRABLE_WORK(&hinfo->gc_work, htable_gc);\n\tqueue_delayed_work(system_power_efficient_wq, &hinfo->gc_work,\n\t\t\t   msecs_to_jiffies(hinfo->cfg.gc_interval));\n\n\thlist_add_head(&hinfo->node, &hashlimit_net->htables);\n\n\treturn 0;\n}\n\nstatic void htable_selective_cleanup(struct xt_hashlimit_htable *ht, bool select_all)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ht->cfg.size; i++) {\n\t\tstruct dsthash_ent *dh;\n\t\tstruct hlist_node *n;\n\n\t\tspin_lock_bh(&ht->lock);\n\t\thlist_for_each_entry_safe(dh, n, &ht->hash[i], node) {\n\t\t\tif (time_after_eq(jiffies, dh->expires) || select_all)\n\t\t\t\tdsthash_free(ht, dh);\n\t\t}\n\t\tspin_unlock_bh(&ht->lock);\n\t\tcond_resched();\n\t}\n}\n\nstatic void htable_gc(struct work_struct *work)\n{\n\tstruct xt_hashlimit_htable *ht;\n\n\tht = container_of(work, struct xt_hashlimit_htable, gc_work.work);\n\n\thtable_selective_cleanup(ht, false);\n\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &ht->gc_work, msecs_to_jiffies(ht->cfg.gc_interval));\n}\n\nstatic void htable_remove_proc_entry(struct xt_hashlimit_htable *hinfo)\n{\n\tstruct hashlimit_net *hashlimit_net = hashlimit_pernet(hinfo->net);\n\tstruct proc_dir_entry *parent;\n\n\tif (hinfo->family == NFPROTO_IPV4)\n\t\tparent = hashlimit_net->ipt_hashlimit;\n\telse\n\t\tparent = hashlimit_net->ip6t_hashlimit;\n\n\tif (parent != NULL)\n\t\tremove_proc_entry(hinfo->name, parent);\n}\n\nstatic struct xt_hashlimit_htable *htable_find_get(struct net *net,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   u_int8_t family)\n{\n\tstruct hashlimit_net *hashlimit_net = hashlimit_pernet(net);\n\tstruct xt_hashlimit_htable *hinfo;\n\n\thlist_for_each_entry(hinfo, &hashlimit_net->htables, node) {\n\t\tif (!strcmp(name, hinfo->name) &&\n\t\t    hinfo->family == family) {\n\t\t\trefcount_inc(&hinfo->use);\n\t\t\treturn hinfo;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void htable_put(struct xt_hashlimit_htable *hinfo)\n{\n\tif (refcount_dec_and_mutex_lock(&hinfo->use, &hashlimit_mutex)) {\n\t\thlist_del(&hinfo->node);\n\t\thtable_remove_proc_entry(hinfo);\n\t\tmutex_unlock(&hashlimit_mutex);\n\n\t\tcancel_delayed_work_sync(&hinfo->gc_work);\n\t\thtable_selective_cleanup(hinfo, true);\n\t\tkfree(hinfo->name);\n\t\tvfree(hinfo);\n\t}\n}\n\n \n\n \n#define MAX_CPJ_v1 (0xFFFFFFFF / (HZ*60*60*24))\n#define MAX_CPJ (0xFFFFFFFFFFFFFFFFULL / (HZ*60*60*24))\n\n \n#define _POW2_BELOW2(x) ((x)|((x)>>1))\n#define _POW2_BELOW4(x) (_POW2_BELOW2(x)|_POW2_BELOW2((x)>>2))\n#define _POW2_BELOW8(x) (_POW2_BELOW4(x)|_POW2_BELOW4((x)>>4))\n#define _POW2_BELOW16(x) (_POW2_BELOW8(x)|_POW2_BELOW8((x)>>8))\n#define _POW2_BELOW32(x) (_POW2_BELOW16(x)|_POW2_BELOW16((x)>>16))\n#define _POW2_BELOW64(x) (_POW2_BELOW32(x)|_POW2_BELOW32((x)>>32))\n#define POW2_BELOW32(x) ((_POW2_BELOW32(x)>>1) + 1)\n#define POW2_BELOW64(x) ((_POW2_BELOW64(x)>>1) + 1)\n\n#define CREDITS_PER_JIFFY POW2_BELOW64(MAX_CPJ)\n#define CREDITS_PER_JIFFY_v1 POW2_BELOW32(MAX_CPJ_v1)\n\n \n#define MAX_CPJ_BYTES (0xFFFFFFFF / HZ)\n#define CREDITS_PER_JIFFY_BYTES POW2_BELOW32(MAX_CPJ_BYTES)\n\nstatic u32 xt_hashlimit_len_to_chunks(u32 len)\n{\n\treturn (len >> XT_HASHLIMIT_BYTE_SHIFT) + 1;\n}\n\n \nstatic u64 user2credits(u64 user, int revision)\n{\n\tu64 scale = (revision == 1) ?\n\t\tXT_HASHLIMIT_SCALE : XT_HASHLIMIT_SCALE_v2;\n\tu64 cpj = (revision == 1) ?\n\t\tCREDITS_PER_JIFFY_v1 : CREDITS_PER_JIFFY;\n\n\t \n\tif (scale >= HZ * cpj)\n\t\treturn div64_u64(user, div64_u64(scale, HZ * cpj));\n\n\treturn user * div64_u64(HZ * cpj, scale);\n}\n\nstatic u32 user2credits_byte(u32 user)\n{\n\tu64 us = user;\n\tus *= HZ * CREDITS_PER_JIFFY_BYTES;\n\treturn (u32) (us >> 32);\n}\n\nstatic u64 user2rate(u64 user)\n{\n\tif (user != 0) {\n\t\treturn div64_u64(XT_HASHLIMIT_SCALE_v2, user);\n\t} else {\n\t\tpr_info_ratelimited(\"invalid rate from userspace: %llu\\n\",\n\t\t\t\t    user);\n\t\treturn 0;\n\t}\n}\n\nstatic u64 user2rate_bytes(u32 user)\n{\n\tu64 r;\n\n\tr = user ? U32_MAX / user : U32_MAX;\n\treturn (r - 1) << XT_HASHLIMIT_BYTE_SHIFT;\n}\n\nstatic void rateinfo_recalc(struct dsthash_ent *dh, unsigned long now,\n\t\t\t    u32 mode, int revision)\n{\n\tunsigned long delta = now - dh->rateinfo.prev;\n\tu64 cap, cpj;\n\n\tif (delta == 0)\n\t\treturn;\n\n\tif (revision >= 3 && mode & XT_HASHLIMIT_RATE_MATCH) {\n\t\tu64 interval = dh->rateinfo.interval * HZ;\n\n\t\tif (delta < interval)\n\t\t\treturn;\n\n\t\tdh->rateinfo.prev = now;\n\t\tdh->rateinfo.prev_window =\n\t\t\t((dh->rateinfo.current_rate * interval) >\n\t\t\t (delta * dh->rateinfo.rate));\n\t\tdh->rateinfo.current_rate = 0;\n\n\t\treturn;\n\t}\n\n\tdh->rateinfo.prev = now;\n\n\tif (mode & XT_HASHLIMIT_BYTES) {\n\t\tu64 tmp = dh->rateinfo.credit;\n\t\tdh->rateinfo.credit += CREDITS_PER_JIFFY_BYTES * delta;\n\t\tcap = CREDITS_PER_JIFFY_BYTES * HZ;\n\t\tif (tmp >= dh->rateinfo.credit) { \n\t\t\tdh->rateinfo.credit = cap;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tcpj = (revision == 1) ?\n\t\t\tCREDITS_PER_JIFFY_v1 : CREDITS_PER_JIFFY;\n\t\tdh->rateinfo.credit += delta * cpj;\n\t\tcap = dh->rateinfo.credit_cap;\n\t}\n\tif (dh->rateinfo.credit > cap)\n\t\tdh->rateinfo.credit = cap;\n}\n\nstatic void rateinfo_init(struct dsthash_ent *dh,\n\t\t\t  struct xt_hashlimit_htable *hinfo, int revision)\n{\n\tdh->rateinfo.prev = jiffies;\n\tif (revision >= 3 && hinfo->cfg.mode & XT_HASHLIMIT_RATE_MATCH) {\n\t\tdh->rateinfo.prev_window = 0;\n\t\tdh->rateinfo.current_rate = 0;\n\t\tif (hinfo->cfg.mode & XT_HASHLIMIT_BYTES) {\n\t\t\tdh->rateinfo.rate =\n\t\t\t\tuser2rate_bytes((u32)hinfo->cfg.avg);\n\t\t\tif (hinfo->cfg.burst)\n\t\t\t\tdh->rateinfo.burst =\n\t\t\t\t\thinfo->cfg.burst * dh->rateinfo.rate;\n\t\t\telse\n\t\t\t\tdh->rateinfo.burst = dh->rateinfo.rate;\n\t\t} else {\n\t\t\tdh->rateinfo.rate = user2rate(hinfo->cfg.avg);\n\t\t\tdh->rateinfo.burst =\n\t\t\t\thinfo->cfg.burst + dh->rateinfo.rate;\n\t\t}\n\t\tdh->rateinfo.interval = hinfo->cfg.interval;\n\t} else if (hinfo->cfg.mode & XT_HASHLIMIT_BYTES) {\n\t\tdh->rateinfo.credit = CREDITS_PER_JIFFY_BYTES * HZ;\n\t\tdh->rateinfo.cost = user2credits_byte(hinfo->cfg.avg);\n\t\tdh->rateinfo.credit_cap = hinfo->cfg.burst;\n\t} else {\n\t\tdh->rateinfo.credit = user2credits(hinfo->cfg.avg *\n\t\t\t\t\t\t   hinfo->cfg.burst, revision);\n\t\tdh->rateinfo.cost = user2credits(hinfo->cfg.avg, revision);\n\t\tdh->rateinfo.credit_cap = dh->rateinfo.credit;\n\t}\n}\n\nstatic inline __be32 maskl(__be32 a, unsigned int l)\n{\n\treturn l ? htonl(ntohl(a) & ~0 << (32 - l)) : 0;\n}\n\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nstatic void hashlimit_ipv6_mask(__be32 *i, unsigned int p)\n{\n\tswitch (p) {\n\tcase 0 ... 31:\n\t\ti[0] = maskl(i[0], p);\n\t\ti[1] = i[2] = i[3] = 0;\n\t\tbreak;\n\tcase 32 ... 63:\n\t\ti[1] = maskl(i[1], p - 32);\n\t\ti[2] = i[3] = 0;\n\t\tbreak;\n\tcase 64 ... 95:\n\t\ti[2] = maskl(i[2], p - 64);\n\t\ti[3] = 0;\n\t\tbreak;\n\tcase 96 ... 127:\n\t\ti[3] = maskl(i[3], p - 96);\n\t\tbreak;\n\tcase 128:\n\t\tbreak;\n\t}\n}\n#endif\n\nstatic int\nhashlimit_init_dst(const struct xt_hashlimit_htable *hinfo,\n\t\t   struct dsthash_dst *dst,\n\t\t   const struct sk_buff *skb, unsigned int protoff)\n{\n\t__be16 _ports[2], *ports;\n\tu8 nexthdr;\n\tint poff;\n\n\tmemset(dst, 0, sizeof(*dst));\n\n\tswitch (hinfo->family) {\n\tcase NFPROTO_IPV4:\n\t\tif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_DIP)\n\t\t\tdst->ip.dst = maskl(ip_hdr(skb)->daddr,\n\t\t\t              hinfo->cfg.dstmask);\n\t\tif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_SIP)\n\t\t\tdst->ip.src = maskl(ip_hdr(skb)->saddr,\n\t\t\t              hinfo->cfg.srcmask);\n\n\t\tif (!(hinfo->cfg.mode &\n\t\t      (XT_HASHLIMIT_HASH_DPT | XT_HASHLIMIT_HASH_SPT)))\n\t\t\treturn 0;\n\t\tnexthdr = ip_hdr(skb)->protocol;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\tcase NFPROTO_IPV6:\n\t{\n\t\t__be16 frag_off;\n\n\t\tif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_DIP) {\n\t\t\tmemcpy(&dst->ip6.dst, &ipv6_hdr(skb)->daddr,\n\t\t\t       sizeof(dst->ip6.dst));\n\t\t\thashlimit_ipv6_mask(dst->ip6.dst, hinfo->cfg.dstmask);\n\t\t}\n\t\tif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_SIP) {\n\t\t\tmemcpy(&dst->ip6.src, &ipv6_hdr(skb)->saddr,\n\t\t\t       sizeof(dst->ip6.src));\n\t\t\thashlimit_ipv6_mask(dst->ip6.src, hinfo->cfg.srcmask);\n\t\t}\n\n\t\tif (!(hinfo->cfg.mode &\n\t\t      (XT_HASHLIMIT_HASH_DPT | XT_HASHLIMIT_HASH_SPT)))\n\t\t\treturn 0;\n\t\tnexthdr = ipv6_hdr(skb)->nexthdr;\n\t\tprotoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr, &frag_off);\n\t\tif ((int)protoff < 0)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\tpoff = proto_ports_offset(nexthdr);\n\tif (poff >= 0) {\n\t\tports = skb_header_pointer(skb, protoff + poff, sizeof(_ports),\n\t\t\t\t\t   &_ports);\n\t} else {\n\t\t_ports[0] = _ports[1] = 0;\n\t\tports = _ports;\n\t}\n\tif (!ports)\n\t\treturn -1;\n\tif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_SPT)\n\t\tdst->src_port = ports[0];\n\tif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_DPT)\n\t\tdst->dst_port = ports[1];\n\treturn 0;\n}\n\nstatic u32 hashlimit_byte_cost(unsigned int len, struct dsthash_ent *dh)\n{\n\tu64 tmp = xt_hashlimit_len_to_chunks(len);\n\ttmp = tmp * dh->rateinfo.cost;\n\n\tif (unlikely(tmp > CREDITS_PER_JIFFY_BYTES * HZ))\n\t\ttmp = CREDITS_PER_JIFFY_BYTES * HZ;\n\n\tif (dh->rateinfo.credit < tmp && dh->rateinfo.credit_cap) {\n\t\tdh->rateinfo.credit_cap--;\n\t\tdh->rateinfo.credit = CREDITS_PER_JIFFY_BYTES * HZ;\n\t}\n\treturn (u32) tmp;\n}\n\nstatic bool\nhashlimit_mt_common(const struct sk_buff *skb, struct xt_action_param *par,\n\t\t    struct xt_hashlimit_htable *hinfo,\n\t\t    const struct hashlimit_cfg3 *cfg, int revision)\n{\n\tunsigned long now = jiffies;\n\tstruct dsthash_ent *dh;\n\tstruct dsthash_dst dst;\n\tbool race = false;\n\tu64 cost;\n\n\tif (hashlimit_init_dst(hinfo, &dst, skb, par->thoff) < 0)\n\t\tgoto hotdrop;\n\n\tlocal_bh_disable();\n\tdh = dsthash_find(hinfo, &dst);\n\tif (dh == NULL) {\n\t\tdh = dsthash_alloc_init(hinfo, &dst, &race);\n\t\tif (dh == NULL) {\n\t\t\tlocal_bh_enable();\n\t\t\tgoto hotdrop;\n\t\t} else if (race) {\n\t\t\t \n\t\t\tdh->expires = now + msecs_to_jiffies(hinfo->cfg.expire);\n\t\t\trateinfo_recalc(dh, now, hinfo->cfg.mode, revision);\n\t\t} else {\n\t\t\tdh->expires = jiffies + msecs_to_jiffies(hinfo->cfg.expire);\n\t\t\trateinfo_init(dh, hinfo, revision);\n\t\t}\n\t} else {\n\t\t \n\t\tdh->expires = now + msecs_to_jiffies(hinfo->cfg.expire);\n\t\trateinfo_recalc(dh, now, hinfo->cfg.mode, revision);\n\t}\n\n\tif (cfg->mode & XT_HASHLIMIT_RATE_MATCH) {\n\t\tcost = (cfg->mode & XT_HASHLIMIT_BYTES) ? skb->len : 1;\n\t\tdh->rateinfo.current_rate += cost;\n\n\t\tif (!dh->rateinfo.prev_window &&\n\t\t    (dh->rateinfo.current_rate <= dh->rateinfo.burst)) {\n\t\t\tspin_unlock(&dh->lock);\n\t\t\tlocal_bh_enable();\n\t\t\treturn !(cfg->mode & XT_HASHLIMIT_INVERT);\n\t\t} else {\n\t\t\tgoto overlimit;\n\t\t}\n\t}\n\n\tif (cfg->mode & XT_HASHLIMIT_BYTES)\n\t\tcost = hashlimit_byte_cost(skb->len, dh);\n\telse\n\t\tcost = dh->rateinfo.cost;\n\n\tif (dh->rateinfo.credit >= cost) {\n\t\t \n\t\tdh->rateinfo.credit -= cost;\n\t\tspin_unlock(&dh->lock);\n\t\tlocal_bh_enable();\n\t\treturn !(cfg->mode & XT_HASHLIMIT_INVERT);\n\t}\n\noverlimit:\n\tspin_unlock(&dh->lock);\n\tlocal_bh_enable();\n\t \n\treturn cfg->mode & XT_HASHLIMIT_INVERT;\n\n hotdrop:\n\tpar->hotdrop = true;\n\treturn false;\n}\n\nstatic bool\nhashlimit_mt_v1(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_hashlimit_mtinfo1 *info = par->matchinfo;\n\tstruct xt_hashlimit_htable *hinfo = info->hinfo;\n\tstruct hashlimit_cfg3 cfg = {};\n\tint ret;\n\n\tret = cfg_copy(&cfg, (void *)&info->cfg, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hashlimit_mt_common(skb, par, hinfo, &cfg, 1);\n}\n\nstatic bool\nhashlimit_mt_v2(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_hashlimit_mtinfo2 *info = par->matchinfo;\n\tstruct xt_hashlimit_htable *hinfo = info->hinfo;\n\tstruct hashlimit_cfg3 cfg = {};\n\tint ret;\n\n\tret = cfg_copy(&cfg, (void *)&info->cfg, 2);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hashlimit_mt_common(skb, par, hinfo, &cfg, 2);\n}\n\nstatic bool\nhashlimit_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_hashlimit_mtinfo3 *info = par->matchinfo;\n\tstruct xt_hashlimit_htable *hinfo = info->hinfo;\n\n\treturn hashlimit_mt_common(skb, par, hinfo, &info->cfg, 3);\n}\n\n#define HASHLIMIT_MAX_SIZE 1048576\n\nstatic int hashlimit_mt_check_common(const struct xt_mtchk_param *par,\n\t\t\t\t     struct xt_hashlimit_htable **hinfo,\n\t\t\t\t     struct hashlimit_cfg3 *cfg,\n\t\t\t\t     const char *name, int revision)\n{\n\tstruct net *net = par->net;\n\tint ret;\n\n\tif (cfg->gc_interval == 0 || cfg->expire == 0)\n\t\treturn -EINVAL;\n\tif (cfg->size > HASHLIMIT_MAX_SIZE) {\n\t\tcfg->size = HASHLIMIT_MAX_SIZE;\n\t\tpr_info_ratelimited(\"size too large, truncated to %u\\n\", cfg->size);\n\t}\n\tif (cfg->max > HASHLIMIT_MAX_SIZE) {\n\t\tcfg->max = HASHLIMIT_MAX_SIZE;\n\t\tpr_info_ratelimited(\"max too large, truncated to %u\\n\", cfg->max);\n\t}\n\tif (par->family == NFPROTO_IPV4) {\n\t\tif (cfg->srcmask > 32 || cfg->dstmask > 32)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (cfg->srcmask > 128 || cfg->dstmask > 128)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->mode & ~XT_HASHLIMIT_ALL) {\n\t\tpr_info_ratelimited(\"Unknown mode mask %X, kernel too old?\\n\",\n\t\t\t\t    cfg->mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (revision >= 3 && cfg->mode & XT_HASHLIMIT_RATE_MATCH) {\n\t\tif (cfg->avg == 0 || cfg->avg > U32_MAX) {\n\t\t\tpr_info_ratelimited(\"invalid rate\\n\");\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tif (cfg->interval == 0) {\n\t\t\tpr_info_ratelimited(\"invalid interval\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (cfg->mode & XT_HASHLIMIT_BYTES) {\n\t\tif (user2credits_byte(cfg->avg) == 0) {\n\t\t\tpr_info_ratelimited(\"overflow, rate too high: %llu\\n\",\n\t\t\t\t\t    cfg->avg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (cfg->burst == 0 ||\n\t\t   user2credits(cfg->avg * cfg->burst, revision) <\n\t\t   user2credits(cfg->avg, revision)) {\n\t\tpr_info_ratelimited(\"overflow, try lower: %llu/%llu\\n\",\n\t\t\t\t    cfg->avg, cfg->burst);\n\t\treturn -ERANGE;\n\t}\n\n\tmutex_lock(&hashlimit_mutex);\n\t*hinfo = htable_find_get(net, name, par->family);\n\tif (*hinfo == NULL) {\n\t\tret = htable_create(net, cfg, name, par->family,\n\t\t\t\t    hinfo, revision);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&hashlimit_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&hashlimit_mutex);\n\n\treturn 0;\n}\n\nstatic int hashlimit_mt_check_v1(const struct xt_mtchk_param *par)\n{\n\tstruct xt_hashlimit_mtinfo1 *info = par->matchinfo;\n\tstruct hashlimit_cfg3 cfg = {};\n\tint ret;\n\n\tret = xt_check_proc_name(info->name, sizeof(info->name));\n\tif (ret)\n\t\treturn ret;\n\n\tret = cfg_copy(&cfg, (void *)&info->cfg, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hashlimit_mt_check_common(par, &info->hinfo,\n\t\t\t\t\t &cfg, info->name, 1);\n}\n\nstatic int hashlimit_mt_check_v2(const struct xt_mtchk_param *par)\n{\n\tstruct xt_hashlimit_mtinfo2 *info = par->matchinfo;\n\tstruct hashlimit_cfg3 cfg = {};\n\tint ret;\n\n\tret = xt_check_proc_name(info->name, sizeof(info->name));\n\tif (ret)\n\t\treturn ret;\n\n\tret = cfg_copy(&cfg, (void *)&info->cfg, 2);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hashlimit_mt_check_common(par, &info->hinfo,\n\t\t\t\t\t &cfg, info->name, 2);\n}\n\nstatic int hashlimit_mt_check(const struct xt_mtchk_param *par)\n{\n\tstruct xt_hashlimit_mtinfo3 *info = par->matchinfo;\n\tint ret;\n\n\tret = xt_check_proc_name(info->name, sizeof(info->name));\n\tif (ret)\n\t\treturn ret;\n\n\treturn hashlimit_mt_check_common(par, &info->hinfo, &info->cfg,\n\t\t\t\t\t info->name, 3);\n}\n\nstatic void hashlimit_mt_destroy_v2(const struct xt_mtdtor_param *par)\n{\n\tconst struct xt_hashlimit_mtinfo2 *info = par->matchinfo;\n\n\thtable_put(info->hinfo);\n}\n\nstatic void hashlimit_mt_destroy_v1(const struct xt_mtdtor_param *par)\n{\n\tconst struct xt_hashlimit_mtinfo1 *info = par->matchinfo;\n\n\thtable_put(info->hinfo);\n}\n\nstatic void hashlimit_mt_destroy(const struct xt_mtdtor_param *par)\n{\n\tconst struct xt_hashlimit_mtinfo3 *info = par->matchinfo;\n\n\thtable_put(info->hinfo);\n}\n\nstatic struct xt_match hashlimit_mt_reg[] __read_mostly = {\n\t{\n\t\t.name           = \"hashlimit\",\n\t\t.revision       = 1,\n\t\t.family         = NFPROTO_IPV4,\n\t\t.match          = hashlimit_mt_v1,\n\t\t.matchsize      = sizeof(struct xt_hashlimit_mtinfo1),\n\t\t.usersize\t= offsetof(struct xt_hashlimit_mtinfo1, hinfo),\n\t\t.checkentry     = hashlimit_mt_check_v1,\n\t\t.destroy        = hashlimit_mt_destroy_v1,\n\t\t.me             = THIS_MODULE,\n\t},\n\t{\n\t\t.name           = \"hashlimit\",\n\t\t.revision       = 2,\n\t\t.family         = NFPROTO_IPV4,\n\t\t.match          = hashlimit_mt_v2,\n\t\t.matchsize      = sizeof(struct xt_hashlimit_mtinfo2),\n\t\t.usersize\t= offsetof(struct xt_hashlimit_mtinfo2, hinfo),\n\t\t.checkentry     = hashlimit_mt_check_v2,\n\t\t.destroy        = hashlimit_mt_destroy_v2,\n\t\t.me             = THIS_MODULE,\n\t},\n\t{\n\t\t.name           = \"hashlimit\",\n\t\t.revision       = 3,\n\t\t.family         = NFPROTO_IPV4,\n\t\t.match          = hashlimit_mt,\n\t\t.matchsize      = sizeof(struct xt_hashlimit_mtinfo3),\n\t\t.usersize\t= offsetof(struct xt_hashlimit_mtinfo3, hinfo),\n\t\t.checkentry     = hashlimit_mt_check,\n\t\t.destroy        = hashlimit_mt_destroy,\n\t\t.me             = THIS_MODULE,\n\t},\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\t{\n\t\t.name           = \"hashlimit\",\n\t\t.revision       = 1,\n\t\t.family         = NFPROTO_IPV6,\n\t\t.match          = hashlimit_mt_v1,\n\t\t.matchsize      = sizeof(struct xt_hashlimit_mtinfo1),\n\t\t.usersize\t= offsetof(struct xt_hashlimit_mtinfo1, hinfo),\n\t\t.checkentry     = hashlimit_mt_check_v1,\n\t\t.destroy        = hashlimit_mt_destroy_v1,\n\t\t.me             = THIS_MODULE,\n\t},\n\t{\n\t\t.name           = \"hashlimit\",\n\t\t.revision       = 2,\n\t\t.family         = NFPROTO_IPV6,\n\t\t.match          = hashlimit_mt_v2,\n\t\t.matchsize      = sizeof(struct xt_hashlimit_mtinfo2),\n\t\t.usersize\t= offsetof(struct xt_hashlimit_mtinfo2, hinfo),\n\t\t.checkentry     = hashlimit_mt_check_v2,\n\t\t.destroy        = hashlimit_mt_destroy_v2,\n\t\t.me             = THIS_MODULE,\n\t},\n\t{\n\t\t.name           = \"hashlimit\",\n\t\t.revision       = 3,\n\t\t.family         = NFPROTO_IPV6,\n\t\t.match          = hashlimit_mt,\n\t\t.matchsize      = sizeof(struct xt_hashlimit_mtinfo3),\n\t\t.usersize\t= offsetof(struct xt_hashlimit_mtinfo3, hinfo),\n\t\t.checkentry     = hashlimit_mt_check,\n\t\t.destroy        = hashlimit_mt_destroy,\n\t\t.me             = THIS_MODULE,\n\t},\n#endif\n};\n\n \nstatic void *dl_seq_start(struct seq_file *s, loff_t *pos)\n\t__acquires(htable->lock)\n{\n\tstruct xt_hashlimit_htable *htable = pde_data(file_inode(s->file));\n\tunsigned int *bucket;\n\n\tspin_lock_bh(&htable->lock);\n\tif (*pos >= htable->cfg.size)\n\t\treturn NULL;\n\n\tbucket = kmalloc(sizeof(unsigned int), GFP_ATOMIC);\n\tif (!bucket)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t*bucket = *pos;\n\treturn bucket;\n}\n\nstatic void *dl_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct xt_hashlimit_htable *htable = pde_data(file_inode(s->file));\n\tunsigned int *bucket = v;\n\n\t*pos = ++(*bucket);\n\tif (*pos >= htable->cfg.size) {\n\t\tkfree(v);\n\t\treturn NULL;\n\t}\n\treturn bucket;\n}\n\nstatic void dl_seq_stop(struct seq_file *s, void *v)\n\t__releases(htable->lock)\n{\n\tstruct xt_hashlimit_htable *htable = pde_data(file_inode(s->file));\n\tunsigned int *bucket = v;\n\n\tif (!IS_ERR(bucket))\n\t\tkfree(bucket);\n\tspin_unlock_bh(&htable->lock);\n}\n\nstatic void dl_seq_print(struct dsthash_ent *ent, u_int8_t family,\n\t\t\t struct seq_file *s)\n{\n\tswitch (family) {\n\tcase NFPROTO_IPV4:\n\t\tseq_printf(s, \"%ld %pI4:%u->%pI4:%u %llu %llu %llu\\n\",\n\t\t\t   (long)(ent->expires - jiffies)/HZ,\n\t\t\t   &ent->dst.ip.src,\n\t\t\t   ntohs(ent->dst.src_port),\n\t\t\t   &ent->dst.ip.dst,\n\t\t\t   ntohs(ent->dst.dst_port),\n\t\t\t   ent->rateinfo.credit, ent->rateinfo.credit_cap,\n\t\t\t   ent->rateinfo.cost);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\tcase NFPROTO_IPV6:\n\t\tseq_printf(s, \"%ld %pI6:%u->%pI6:%u %llu %llu %llu\\n\",\n\t\t\t   (long)(ent->expires - jiffies)/HZ,\n\t\t\t   &ent->dst.ip6.src,\n\t\t\t   ntohs(ent->dst.src_port),\n\t\t\t   &ent->dst.ip6.dst,\n\t\t\t   ntohs(ent->dst.dst_port),\n\t\t\t   ent->rateinfo.credit, ent->rateinfo.credit_cap,\n\t\t\t   ent->rateinfo.cost);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic int dl_seq_real_show_v2(struct dsthash_ent *ent, u_int8_t family,\n\t\t\t       struct seq_file *s)\n{\n\tstruct xt_hashlimit_htable *ht = pde_data(file_inode(s->file));\n\n\tspin_lock(&ent->lock);\n\t \n\trateinfo_recalc(ent, jiffies, ht->cfg.mode, 2);\n\n\tdl_seq_print(ent, family, s);\n\n\tspin_unlock(&ent->lock);\n\treturn seq_has_overflowed(s);\n}\n\nstatic int dl_seq_real_show_v1(struct dsthash_ent *ent, u_int8_t family,\n\t\t\t       struct seq_file *s)\n{\n\tstruct xt_hashlimit_htable *ht = pde_data(file_inode(s->file));\n\n\tspin_lock(&ent->lock);\n\t \n\trateinfo_recalc(ent, jiffies, ht->cfg.mode, 1);\n\n\tdl_seq_print(ent, family, s);\n\n\tspin_unlock(&ent->lock);\n\treturn seq_has_overflowed(s);\n}\n\nstatic int dl_seq_real_show(struct dsthash_ent *ent, u_int8_t family,\n\t\t\t    struct seq_file *s)\n{\n\tstruct xt_hashlimit_htable *ht = pde_data(file_inode(s->file));\n\n\tspin_lock(&ent->lock);\n\t \n\trateinfo_recalc(ent, jiffies, ht->cfg.mode, 3);\n\n\tdl_seq_print(ent, family, s);\n\n\tspin_unlock(&ent->lock);\n\treturn seq_has_overflowed(s);\n}\n\nstatic int dl_seq_show_v2(struct seq_file *s, void *v)\n{\n\tstruct xt_hashlimit_htable *htable = pde_data(file_inode(s->file));\n\tunsigned int *bucket = (unsigned int *)v;\n\tstruct dsthash_ent *ent;\n\n\tif (!hlist_empty(&htable->hash[*bucket])) {\n\t\thlist_for_each_entry(ent, &htable->hash[*bucket], node)\n\t\t\tif (dl_seq_real_show_v2(ent, htable->family, s))\n\t\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int dl_seq_show_v1(struct seq_file *s, void *v)\n{\n\tstruct xt_hashlimit_htable *htable = pde_data(file_inode(s->file));\n\tunsigned int *bucket = v;\n\tstruct dsthash_ent *ent;\n\n\tif (!hlist_empty(&htable->hash[*bucket])) {\n\t\thlist_for_each_entry(ent, &htable->hash[*bucket], node)\n\t\t\tif (dl_seq_real_show_v1(ent, htable->family, s))\n\t\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int dl_seq_show(struct seq_file *s, void *v)\n{\n\tstruct xt_hashlimit_htable *htable = pde_data(file_inode(s->file));\n\tunsigned int *bucket = v;\n\tstruct dsthash_ent *ent;\n\n\tif (!hlist_empty(&htable->hash[*bucket])) {\n\t\thlist_for_each_entry(ent, &htable->hash[*bucket], node)\n\t\t\tif (dl_seq_real_show(ent, htable->family, s))\n\t\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations dl_seq_ops_v1 = {\n\t.start = dl_seq_start,\n\t.next  = dl_seq_next,\n\t.stop  = dl_seq_stop,\n\t.show  = dl_seq_show_v1\n};\n\nstatic const struct seq_operations dl_seq_ops_v2 = {\n\t.start = dl_seq_start,\n\t.next  = dl_seq_next,\n\t.stop  = dl_seq_stop,\n\t.show  = dl_seq_show_v2\n};\n\nstatic const struct seq_operations dl_seq_ops = {\n\t.start = dl_seq_start,\n\t.next  = dl_seq_next,\n\t.stop  = dl_seq_stop,\n\t.show  = dl_seq_show\n};\n\nstatic int __net_init hashlimit_proc_net_init(struct net *net)\n{\n\tstruct hashlimit_net *hashlimit_net = hashlimit_pernet(net);\n\n\thashlimit_net->ipt_hashlimit = proc_mkdir(\"ipt_hashlimit\", net->proc_net);\n\tif (!hashlimit_net->ipt_hashlimit)\n\t\treturn -ENOMEM;\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\thashlimit_net->ip6t_hashlimit = proc_mkdir(\"ip6t_hashlimit\", net->proc_net);\n\tif (!hashlimit_net->ip6t_hashlimit) {\n\t\tremove_proc_entry(\"ipt_hashlimit\", net->proc_net);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void __net_exit hashlimit_proc_net_exit(struct net *net)\n{\n\tstruct xt_hashlimit_htable *hinfo;\n\tstruct hashlimit_net *hashlimit_net = hashlimit_pernet(net);\n\n\t \n\tmutex_lock(&hashlimit_mutex);\n\thlist_for_each_entry(hinfo, &hashlimit_net->htables, node)\n\t\thtable_remove_proc_entry(hinfo);\n\thashlimit_net->ipt_hashlimit = NULL;\n\thashlimit_net->ip6t_hashlimit = NULL;\n\tmutex_unlock(&hashlimit_mutex);\n\n\tremove_proc_entry(\"ipt_hashlimit\", net->proc_net);\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\tremove_proc_entry(\"ip6t_hashlimit\", net->proc_net);\n#endif\n}\n\nstatic int __net_init hashlimit_net_init(struct net *net)\n{\n\tstruct hashlimit_net *hashlimit_net = hashlimit_pernet(net);\n\n\tINIT_HLIST_HEAD(&hashlimit_net->htables);\n\treturn hashlimit_proc_net_init(net);\n}\n\nstatic void __net_exit hashlimit_net_exit(struct net *net)\n{\n\thashlimit_proc_net_exit(net);\n}\n\nstatic struct pernet_operations hashlimit_net_ops = {\n\t.init\t= hashlimit_net_init,\n\t.exit\t= hashlimit_net_exit,\n\t.id\t= &hashlimit_net_id,\n\t.size\t= sizeof(struct hashlimit_net),\n};\n\nstatic int __init hashlimit_mt_init(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&hashlimit_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\terr = xt_register_matches(hashlimit_mt_reg,\n\t      ARRAY_SIZE(hashlimit_mt_reg));\n\tif (err < 0)\n\t\tgoto err1;\n\n\terr = -ENOMEM;\n\thashlimit_cachep = kmem_cache_create(\"xt_hashlimit\",\n\t\t\t\t\t    sizeof(struct dsthash_ent), 0, 0,\n\t\t\t\t\t    NULL);\n\tif (!hashlimit_cachep) {\n\t\tpr_warn(\"unable to create slab cache\\n\");\n\t\tgoto err2;\n\t}\n\treturn 0;\n\nerr2:\n\txt_unregister_matches(hashlimit_mt_reg, ARRAY_SIZE(hashlimit_mt_reg));\nerr1:\n\tunregister_pernet_subsys(&hashlimit_net_ops);\n\treturn err;\n\n}\n\nstatic void __exit hashlimit_mt_exit(void)\n{\n\txt_unregister_matches(hashlimit_mt_reg, ARRAY_SIZE(hashlimit_mt_reg));\n\tunregister_pernet_subsys(&hashlimit_net_ops);\n\n\trcu_barrier();\n\tkmem_cache_destroy(hashlimit_cachep);\n}\n\nmodule_init(hashlimit_mt_init);\nmodule_exit(hashlimit_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}