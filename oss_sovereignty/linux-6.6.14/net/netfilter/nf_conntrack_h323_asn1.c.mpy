{
  "module_name": "nf_conntrack_h323_asn1.c",
  "hash_id": "d363d3fdc6559aec07e68ef7b78c8e632ddbaacf310efee497167d0f5114b4a6",
  "original_prompt": "Ingested from linux-6.6.14/net/netfilter/nf_conntrack_h323_asn1.c",
  "human_readable_source": "\n \n\n#ifdef __KERNEL__\n#include <linux/kernel.h>\n#else\n#include <stdio.h>\n#endif\n#include <linux/netfilter/nf_conntrack_h323_asn1.h>\n\n \n#ifndef H323_TRACE\n#define H323_TRACE 0\n#endif\n\n#if H323_TRACE\n#define TAB_SIZE 4\n#define IFTHEN(cond, act) if(cond){act;}\n#ifdef __KERNEL__\n#define PRINT printk\n#else\n#define PRINT printf\n#endif\n#define FNAME(name) name,\n#else\n#define IFTHEN(cond, act)\n#define PRINT(fmt, args...)\n#define FNAME(name)\n#endif\n\n \n#define NUL 0\n#define BOOL 1\n#define OID 2\n#define INT 3\n#define ENUM 4\n#define BITSTR 5\n#define NUMSTR 6\n#define NUMDGT 6\n#define TBCDSTR 6\n#define OCTSTR 7\n#define PRTSTR 7\n#define IA5STR 7\n#define GENSTR 7\n#define BMPSTR 8\n#define SEQ 9\n#define SET 9\n#define SEQOF 10\n#define SETOF 10\n#define CHOICE 11\n\n \n#define FIXD 0\n \n#define BYTE 9\n#define WORD 10\n#define CONS 11\n#define SEMI 12\n#define UNCO 13\n\n \n#define SKIP 0\n#define STOP 1\n#define DECODE 2\n#define EXT 4\n#define OPEN 8\n#define OPT 16\n\n\n \ntypedef struct field_t {\n#if H323_TRACE\n\tchar *name;\n#endif\n\tunsigned char type;\n\tunsigned char sz;\n\tunsigned char lb;\n\tunsigned char ub;\n\tunsigned short attr;\n\tunsigned short offset;\n\tconst struct field_t *fields;\n} field_t;\n\n \nstruct bitstr {\n\tunsigned char *buf;\n\tunsigned char *beg;\n\tunsigned char *end;\n\tunsigned char *cur;\n\tunsigned int bit;\n};\n\n \n#define INC_BIT(bs) if((++(bs)->bit)>7){(bs)->cur++;(bs)->bit=0;}\n#define INC_BITS(bs,b) if(((bs)->bit+=(b))>7){(bs)->cur+=(bs)->bit>>3;(bs)->bit&=7;}\n#define BYTE_ALIGN(bs) if((bs)->bit){(bs)->cur++;(bs)->bit=0;}\nstatic unsigned int get_len(struct bitstr *bs);\nstatic unsigned int get_bit(struct bitstr *bs);\nstatic unsigned int get_bits(struct bitstr *bs, unsigned int b);\nstatic unsigned int get_bitmap(struct bitstr *bs, unsigned int b);\nstatic unsigned int get_uint(struct bitstr *bs, int b);\n\n \nstatic int decode_nul(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_bool(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_oid(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_int(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_enum(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_bitstr(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_numstr(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_octstr(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_bmpstr(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_seq(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_seqof(struct bitstr *bs, const struct field_t *f, char *base, int level);\nstatic int decode_choice(struct bitstr *bs, const struct field_t *f, char *base, int level);\n\n \ntypedef int (*decoder_t)(struct bitstr *, const struct field_t *, char *, int);\nstatic const decoder_t Decoders[] = {\n\tdecode_nul,\n\tdecode_bool,\n\tdecode_oid,\n\tdecode_int,\n\tdecode_enum,\n\tdecode_bitstr,\n\tdecode_numstr,\n\tdecode_octstr,\n\tdecode_bmpstr,\n\tdecode_seq,\n\tdecode_seqof,\n\tdecode_choice,\n};\n\n \n#include \"nf_conntrack_h323_types.c\"\n\n \n\n \nstatic unsigned int get_len(struct bitstr *bs)\n{\n\tunsigned int v;\n\n\tv = *bs->cur++;\n\n\tif (v & 0x80) {\n\t\tv &= 0x3f;\n\t\tv <<= 8;\n\t\tv += *bs->cur++;\n\t}\n\n\treturn v;\n}\n\nstatic int nf_h323_error_boundary(struct bitstr *bs, size_t bytes, size_t bits)\n{\n\tbits += bs->bit;\n\tbytes += bits / BITS_PER_BYTE;\n\tif (bits % BITS_PER_BYTE > 0)\n\t\tbytes++;\n\n\tif (bs->cur + bytes > bs->end)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic unsigned int get_bit(struct bitstr *bs)\n{\n\tunsigned int b = (*bs->cur) & (0x80 >> bs->bit);\n\n\tINC_BIT(bs);\n\n\treturn b;\n}\n\n \nstatic unsigned int get_bits(struct bitstr *bs, unsigned int b)\n{\n\tunsigned int v, l;\n\n\tv = (*bs->cur) & (0xffU >> bs->bit);\n\tl = b + bs->bit;\n\n\tif (l < 8) {\n\t\tv >>= 8 - l;\n\t\tbs->bit = l;\n\t} else if (l == 8) {\n\t\tbs->cur++;\n\t\tbs->bit = 0;\n\t} else {\t\t \n\n\t\tv <<= 8;\n\t\tv += *(++bs->cur);\n\t\tv >>= 16 - l;\n\t\tbs->bit = l - 8;\n\t}\n\n\treturn v;\n}\n\n \nstatic unsigned int get_bitmap(struct bitstr *bs, unsigned int b)\n{\n\tunsigned int v, l, shift, bytes;\n\n\tif (!b)\n\t\treturn 0;\n\n\tl = bs->bit + b;\n\n\tif (l < 8) {\n\t\tv = (unsigned int)(*bs->cur) << (bs->bit + 24);\n\t\tbs->bit = l;\n\t} else if (l == 8) {\n\t\tv = (unsigned int)(*bs->cur++) << (bs->bit + 24);\n\t\tbs->bit = 0;\n\t} else {\n\t\tfor (bytes = l >> 3, shift = 24, v = 0; bytes;\n\t\t     bytes--, shift -= 8)\n\t\t\tv |= (unsigned int)(*bs->cur++) << shift;\n\n\t\tif (l < 32) {\n\t\t\tv |= (unsigned int)(*bs->cur) << shift;\n\t\t\tv <<= bs->bit;\n\t\t} else if (l > 32) {\n\t\t\tv <<= bs->bit;\n\t\t\tv |= (*bs->cur) >> (8 - bs->bit);\n\t\t}\n\n\t\tbs->bit = l & 0x7;\n\t}\n\n\tv &= 0xffffffff << (32 - b);\n\n\treturn v;\n}\n\n \nstatic unsigned int get_uint(struct bitstr *bs, int b)\n{\n\tunsigned int v = 0;\n\n\tswitch (b) {\n\tcase 4:\n\t\tv |= *bs->cur++;\n\t\tv <<= 8;\n\t\tfallthrough;\n\tcase 3:\n\t\tv |= *bs->cur++;\n\t\tv <<= 8;\n\t\tfallthrough;\n\tcase 2:\n\t\tv |= *bs->cur++;\n\t\tv <<= 8;\n\t\tfallthrough;\n\tcase 1:\n\t\tv |= *bs->cur++;\n\t\tbreak;\n\t}\n\treturn v;\n}\n\nstatic int decode_nul(struct bitstr *bs, const struct field_t *f,\n                      char *base, int level)\n{\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_bool(struct bitstr *bs, const struct field_t *f,\n                       char *base, int level)\n{\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\tINC_BIT(bs);\n\tif (nf_h323_error_boundary(bs, 0, 0))\n\t\treturn H323_ERROR_BOUND;\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_oid(struct bitstr *bs, const struct field_t *f,\n                      char *base, int level)\n{\n\tint len;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\tBYTE_ALIGN(bs);\n\tif (nf_h323_error_boundary(bs, 1, 0))\n\t\treturn H323_ERROR_BOUND;\n\n\tlen = *bs->cur++;\n\tbs->cur += len;\n\tif (nf_h323_error_boundary(bs, 0, 0))\n\t\treturn H323_ERROR_BOUND;\n\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_int(struct bitstr *bs, const struct field_t *f,\n                      char *base, int level)\n{\n\tunsigned int len;\n\n\tPRINT(\"%*.s%s\", level * TAB_SIZE, \" \", f->name);\n\n\tswitch (f->sz) {\n\tcase BYTE:\t\t \n\t\tBYTE_ALIGN(bs);\n\t\tbs->cur++;\n\t\tbreak;\n\tcase WORD:\t\t \n\t\tBYTE_ALIGN(bs);\n\t\tbs->cur += 2;\n\t\tbreak;\n\tcase CONS:\t\t \n\t\tif (nf_h323_error_boundary(bs, 0, 2))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = get_bits(bs, 2) + 1;\n\t\tBYTE_ALIGN(bs);\n\t\tif (base && (f->attr & DECODE)) {\t \n\t\t\tunsigned int v = get_uint(bs, len) + f->lb;\n\t\t\tPRINT(\" = %u\", v);\n\t\t\t*((unsigned int *)(base + f->offset)) = v;\n\t\t}\n\t\tbs->cur += len;\n\t\tbreak;\n\tcase UNCO:\n\t\tBYTE_ALIGN(bs);\n\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = get_len(bs);\n\t\tbs->cur += len;\n\t\tbreak;\n\tdefault:\t\t \n\t\tINC_BITS(bs, f->sz);\n\t\tbreak;\n\t}\n\n\tPRINT(\"\\n\");\n\n\tif (nf_h323_error_boundary(bs, 0, 0))\n\t\treturn H323_ERROR_BOUND;\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_enum(struct bitstr *bs, const struct field_t *f,\n                       char *base, int level)\n{\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\tif ((f->attr & EXT) && get_bit(bs)) {\n\t\tINC_BITS(bs, 7);\n\t} else {\n\t\tINC_BITS(bs, f->sz);\n\t}\n\n\tif (nf_h323_error_boundary(bs, 0, 0))\n\t\treturn H323_ERROR_BOUND;\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_bitstr(struct bitstr *bs, const struct field_t *f,\n                         char *base, int level)\n{\n\tunsigned int len;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\tBYTE_ALIGN(bs);\n\tswitch (f->sz) {\n\tcase FIXD:\t\t \n\t\tlen = f->lb;\n\t\tbreak;\n\tcase WORD:\t\t \n\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = (*bs->cur++) << 8;\n\t\tlen += (*bs->cur++) + f->lb;\n\t\tbreak;\n\tcase SEMI:\n\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = get_len(bs);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\n\tbs->cur += len >> 3;\n\tbs->bit = len & 7;\n\n\tif (nf_h323_error_boundary(bs, 0, 0))\n\t\treturn H323_ERROR_BOUND;\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_numstr(struct bitstr *bs, const struct field_t *f,\n                         char *base, int level)\n{\n\tunsigned int len;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\t \n\tif (nf_h323_error_boundary(bs, 0, f->sz))\n\t\treturn H323_ERROR_BOUND;\n\tlen = get_bits(bs, f->sz) + f->lb;\n\n\tBYTE_ALIGN(bs);\n\tINC_BITS(bs, (len << 2));\n\n\tif (nf_h323_error_boundary(bs, 0, 0))\n\t\treturn H323_ERROR_BOUND;\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_octstr(struct bitstr *bs, const struct field_t *f,\n                         char *base, int level)\n{\n\tunsigned int len;\n\n\tPRINT(\"%*.s%s\", level * TAB_SIZE, \" \", f->name);\n\n\tswitch (f->sz) {\n\tcase FIXD:\t\t \n\t\tif (f->lb > 2) {\n\t\t\tBYTE_ALIGN(bs);\n\t\t\tif (base && (f->attr & DECODE)) {\n\t\t\t\t \n\t\t\t\tIFTHEN(f->lb == 4,\n\t\t\t\t       PRINT(\" = %d.%d.%d.%d:%d\",\n\t\t\t\t\t     bs->cur[0], bs->cur[1],\n\t\t\t\t\t     bs->cur[2], bs->cur[3],\n\t\t\t\t\t     bs->cur[4] * 256 + bs->cur[5]));\n\t\t\t\t*((unsigned int *)(base + f->offset)) =\n\t\t\t\t    bs->cur - bs->buf;\n\t\t\t}\n\t\t}\n\t\tlen = f->lb;\n\t\tbreak;\n\tcase BYTE:\t\t \n\t\tBYTE_ALIGN(bs);\n\t\tif (nf_h323_error_boundary(bs, 1, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = (*bs->cur++) + f->lb;\n\t\tbreak;\n\tcase SEMI:\n\t\tBYTE_ALIGN(bs);\n\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = get_len(bs) + f->lb;\n\t\tbreak;\n\tdefault:\t\t \n\t\tif (nf_h323_error_boundary(bs, 0, f->sz))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = get_bits(bs, f->sz) + f->lb;\n\t\tBYTE_ALIGN(bs);\n\t\tbreak;\n\t}\n\n\tbs->cur += len;\n\n\tPRINT(\"\\n\");\n\n\tif (nf_h323_error_boundary(bs, 0, 0))\n\t\treturn H323_ERROR_BOUND;\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_bmpstr(struct bitstr *bs, const struct field_t *f,\n                         char *base, int level)\n{\n\tunsigned int len;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\tswitch (f->sz) {\n\tcase BYTE:\t\t \n\t\tBYTE_ALIGN(bs);\n\t\tif (nf_h323_error_boundary(bs, 1, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = (*bs->cur++) + f->lb;\n\t\tbreak;\n\tdefault:\t\t \n\t\tif (nf_h323_error_boundary(bs, 0, f->sz))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = get_bits(bs, f->sz) + f->lb;\n\t\tBYTE_ALIGN(bs);\n\t\tbreak;\n\t}\n\n\tbs->cur += len << 1;\n\n\tif (nf_h323_error_boundary(bs, 0, 0))\n\t\treturn H323_ERROR_BOUND;\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_seq(struct bitstr *bs, const struct field_t *f,\n                      char *base, int level)\n{\n\tunsigned int ext, bmp, i, opt, len = 0, bmp2, bmp2_len;\n\tint err;\n\tconst struct field_t *son;\n\tunsigned char *beg = NULL;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\t \n\tbase = (base && (f->attr & DECODE)) ? base + f->offset : NULL;\n\n\t \n\tif (nf_h323_error_boundary(bs, 0, 1))\n\t\treturn H323_ERROR_BOUND;\n\text = (f->attr & EXT) ? get_bit(bs) : 0;\n\n\t \n\tif (nf_h323_error_boundary(bs, 0, f->sz))\n\t\treturn H323_ERROR_BOUND;\n\tbmp = get_bitmap(bs, f->sz);\n\tif (base)\n\t\t*(unsigned int *)base = bmp;\n\n\t \n\tfor (i = opt = 0, son = f->fields; i < f->lb; i++, son++) {\n\t\tif (son->attr & STOP) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\treturn H323_ERROR_STOP;\n\t\t}\n\n\t\tif (son->attr & OPT) {\t \n\t\t\tif (!((0x80000000U >> (opt++)) & bmp))\t \n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (son->attr & OPEN) {\t \n\t\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\t\treturn H323_ERROR_BOUND;\n\t\t\tlen = get_len(bs);\n\t\t\tif (nf_h323_error_boundary(bs, len, 0))\n\t\t\t\treturn H323_ERROR_BOUND;\n\t\t\tif (!base || !(son->attr & DECODE)) {\n\t\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE,\n\t\t\t\t      \" \", son->name);\n\t\t\t\tbs->cur += len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbeg = bs->cur;\n\n\t\t\t \n\t\t\tif ((err = (Decoders[son->type]) (bs, son, base,\n\t\t\t\t\t\t\t  level + 1)) <\n\t\t\t    H323_ERROR_NONE)\n\t\t\t\treturn err;\n\n\t\t\tbs->cur = beg + len;\n\t\t\tbs->bit = 0;\n\t\t} else if ((err = (Decoders[son->type]) (bs, son, base,\n\t\t\t\t\t\t\t level + 1)) <\n\t\t\t   H323_ERROR_NONE)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!ext)\n\t\treturn H323_ERROR_NONE;\n\n\t \n\tif (nf_h323_error_boundary(bs, 0, 7))\n\t\treturn H323_ERROR_BOUND;\n\tbmp2_len = get_bits(bs, 7) + 1;\n\tif (nf_h323_error_boundary(bs, 0, bmp2_len))\n\t\treturn H323_ERROR_BOUND;\n\tbmp2 = get_bitmap(bs, bmp2_len);\n\tbmp |= bmp2 >> f->sz;\n\tif (base)\n\t\t*(unsigned int *)base = bmp;\n\tBYTE_ALIGN(bs);\n\n\t \n\tfor (opt = 0; opt < bmp2_len; opt++, i++, son++) {\n\t\t \n\t\tif (i >= f->ub) {\t \n\t\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\t\treturn H323_ERROR_BOUND;\n\t\t\tlen = get_len(bs);\n\t\t\tif (nf_h323_error_boundary(bs, len, 0))\n\t\t\t\treturn H323_ERROR_BOUND;\n\t\t\tbs->cur += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (son->attr & STOP) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\treturn H323_ERROR_STOP;\n\t\t}\n\n\t\tif (!((0x80000000 >> opt) & bmp2))\t \n\t\t\tcontinue;\n\n\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = get_len(bs);\n\t\tif (nf_h323_error_boundary(bs, len, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tif (!base || !(son->attr & DECODE)) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\tbs->cur += len;\n\t\t\tcontinue;\n\t\t}\n\t\tbeg = bs->cur;\n\n\t\tif ((err = (Decoders[son->type]) (bs, son, base,\n\t\t\t\t\t\t  level + 1)) <\n\t\t    H323_ERROR_NONE)\n\t\t\treturn err;\n\n\t\tbs->cur = beg + len;\n\t\tbs->bit = 0;\n\t}\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_seqof(struct bitstr *bs, const struct field_t *f,\n                        char *base, int level)\n{\n\tunsigned int count, effective_count = 0, i, len = 0;\n\tint err;\n\tconst struct field_t *son;\n\tunsigned char *beg = NULL;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\t \n\tbase = (base && (f->attr & DECODE)) ? base + f->offset : NULL;\n\n\t \n\tswitch (f->sz) {\n\tcase BYTE:\n\t\tBYTE_ALIGN(bs);\n\t\tif (nf_h323_error_boundary(bs, 1, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tcount = *bs->cur++;\n\t\tbreak;\n\tcase WORD:\n\t\tBYTE_ALIGN(bs);\n\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tcount = *bs->cur++;\n\t\tcount <<= 8;\n\t\tcount += *bs->cur++;\n\t\tbreak;\n\tcase SEMI:\n\t\tBYTE_ALIGN(bs);\n\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tcount = get_len(bs);\n\t\tbreak;\n\tdefault:\n\t\tif (nf_h323_error_boundary(bs, 0, f->sz))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tcount = get_bits(bs, f->sz);\n\t\tbreak;\n\t}\n\tcount += f->lb;\n\n\t \n\tif (base) {\n\t\teffective_count = count > f->ub ? f->ub : count;\n\t\t*(unsigned int *)base = effective_count;\n\t\tbase += sizeof(unsigned int);\n\t}\n\n\t \n\tson = f->fields;\n\tif (base)\n\t\tbase -= son->offset;\n\tfor (i = 0; i < count; i++) {\n\t\tif (son->attr & OPEN) {\n\t\t\tBYTE_ALIGN(bs);\n\t\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\t\treturn H323_ERROR_BOUND;\n\t\t\tlen = get_len(bs);\n\t\t\tif (nf_h323_error_boundary(bs, len, 0))\n\t\t\t\treturn H323_ERROR_BOUND;\n\t\t\tif (!base || !(son->attr & DECODE)) {\n\t\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE,\n\t\t\t\t      \" \", son->name);\n\t\t\t\tbs->cur += len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbeg = bs->cur;\n\n\t\t\tif ((err = (Decoders[son->type]) (bs, son,\n\t\t\t\t\t\t\t  i <\n\t\t\t\t\t\t\t  effective_count ?\n\t\t\t\t\t\t\t  base : NULL,\n\t\t\t\t\t\t\t  level + 1)) <\n\t\t\t    H323_ERROR_NONE)\n\t\t\t\treturn err;\n\n\t\t\tbs->cur = beg + len;\n\t\t\tbs->bit = 0;\n\t\t} else\n\t\t\tif ((err = (Decoders[son->type]) (bs, son,\n\t\t\t\t\t\t\t  i <\n\t\t\t\t\t\t\t  effective_count ?\n\t\t\t\t\t\t\t  base : NULL,\n\t\t\t\t\t\t\t  level + 1)) <\n\t\t\t    H323_ERROR_NONE)\n\t\t\t\treturn err;\n\n\t\tif (base)\n\t\t\tbase += son->offset;\n\t}\n\n\treturn H323_ERROR_NONE;\n}\n\nstatic int decode_choice(struct bitstr *bs, const struct field_t *f,\n                         char *base, int level)\n{\n\tunsigned int type, ext, len = 0;\n\tint err;\n\tconst struct field_t *son;\n\tunsigned char *beg = NULL;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\t \n\tbase = (base && (f->attr & DECODE)) ? base + f->offset : NULL;\n\n\t \n\tif (nf_h323_error_boundary(bs, 0, 1))\n\t\treturn H323_ERROR_BOUND;\n\tif ((f->attr & EXT) && get_bit(bs)) {\n\t\text = 1;\n\t\tif (nf_h323_error_boundary(bs, 0, 7))\n\t\t\treturn H323_ERROR_BOUND;\n\t\ttype = get_bits(bs, 7) + f->lb;\n\t} else {\n\t\text = 0;\n\t\tif (nf_h323_error_boundary(bs, 0, f->sz))\n\t\t\treturn H323_ERROR_BOUND;\n\t\ttype = get_bits(bs, f->sz);\n\t\tif (type >= f->lb)\n\t\t\treturn H323_ERROR_RANGE;\n\t}\n\n\t \n\tif (base)\n\t\t*(unsigned int *)base = type;\n\n\t \n\tif (type >= f->ub) {\t \n\t\tBYTE_ALIGN(bs);\n\t\tif (nf_h323_error_boundary(bs, 2, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = get_len(bs);\n\t\tif (nf_h323_error_boundary(bs, len, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tbs->cur += len;\n\t\treturn H323_ERROR_NONE;\n\t}\n\n\t \n\tson = &f->fields[type];\n\tif (son->attr & STOP) {\n\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \", son->name);\n\t\treturn H323_ERROR_STOP;\n\t}\n\n\tif (ext || (son->attr & OPEN)) {\n\t\tBYTE_ALIGN(bs);\n\t\tif (nf_h323_error_boundary(bs, len, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tlen = get_len(bs);\n\t\tif (nf_h323_error_boundary(bs, len, 0))\n\t\t\treturn H323_ERROR_BOUND;\n\t\tif (!base || !(son->attr & DECODE)) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\tbs->cur += len;\n\t\t\treturn H323_ERROR_NONE;\n\t\t}\n\t\tbeg = bs->cur;\n\n\t\tif ((err = (Decoders[son->type]) (bs, son, base, level + 1)) <\n\t\t    H323_ERROR_NONE)\n\t\t\treturn err;\n\n\t\tbs->cur = beg + len;\n\t\tbs->bit = 0;\n\t} else if ((err = (Decoders[son->type]) (bs, son, base, level + 1)) <\n\t\t   H323_ERROR_NONE)\n\t\treturn err;\n\n\treturn H323_ERROR_NONE;\n}\n\nint DecodeRasMessage(unsigned char *buf, size_t sz, RasMessage *ras)\n{\n\tstatic const struct field_t ras_message = {\n\t\tFNAME(\"RasMessage\") CHOICE, 5, 24, 32, DECODE | EXT,\n\t\t0, _RasMessage\n\t};\n\tstruct bitstr bs;\n\n\tbs.buf = bs.beg = bs.cur = buf;\n\tbs.end = buf + sz;\n\tbs.bit = 0;\n\n\treturn decode_choice(&bs, &ras_message, (char *) ras, 0);\n}\n\nstatic int DecodeH323_UserInformation(unsigned char *buf, unsigned char *beg,\n\t\t\t\t      size_t sz, H323_UserInformation *uuie)\n{\n\tstatic const struct field_t h323_userinformation = {\n\t\tFNAME(\"H323-UserInformation\") SEQ, 1, 2, 2, DECODE | EXT,\n\t\t0, _H323_UserInformation\n\t};\n\tstruct bitstr bs;\n\n\tbs.buf = buf;\n\tbs.beg = bs.cur = beg;\n\tbs.end = beg + sz;\n\tbs.bit = 0;\n\n\treturn decode_seq(&bs, &h323_userinformation, (char *) uuie, 0);\n}\n\nint DecodeMultimediaSystemControlMessage(unsigned char *buf, size_t sz,\n\t\t\t\t\t MultimediaSystemControlMessage *\n\t\t\t\t\t mscm)\n{\n\tstatic const struct field_t multimediasystemcontrolmessage = {\n\t\tFNAME(\"MultimediaSystemControlMessage\") CHOICE, 2, 4, 4,\n\t\tDECODE | EXT, 0, _MultimediaSystemControlMessage\n\t};\n\tstruct bitstr bs;\n\n\tbs.buf = bs.beg = bs.cur = buf;\n\tbs.end = buf + sz;\n\tbs.bit = 0;\n\n\treturn decode_choice(&bs, &multimediasystemcontrolmessage,\n\t\t\t     (char *) mscm, 0);\n}\n\nint DecodeQ931(unsigned char *buf, size_t sz, Q931 *q931)\n{\n\tunsigned char *p = buf;\n\tint len;\n\n\tif (!p || sz < 1)\n\t\treturn H323_ERROR_BOUND;\n\n\t \n\tif (*p != 0x08) {\n\t\tPRINT(\"Unknown Protocol Discriminator\\n\");\n\t\treturn H323_ERROR_RANGE;\n\t}\n\tp++;\n\tsz--;\n\n\t \n\tif (sz < 1)\n\t\treturn H323_ERROR_BOUND;\n\tlen = *p++;\n\tsz--;\n\tif (sz < len)\n\t\treturn H323_ERROR_BOUND;\n\tp += len;\n\tsz -= len;\n\n\t \n\tif (sz < 2)\n\t\treturn H323_ERROR_BOUND;\n\tq931->MessageType = *p++;\n\tsz--;\n\tPRINT(\"MessageType = %02X\\n\", q931->MessageType);\n\tif (*p & 0x80) {\n\t\tp++;\n\t\tsz--;\n\t}\n\n\t \n\twhile (sz > 0) {\n\t\tif (*p == 0x7e) {\t \n\t\t\tif (sz < 3)\n\t\t\t\tbreak;\n\t\t\tp++;\n\t\t\tlen = *p++ << 8;\n\t\t\tlen |= *p++;\n\t\t\tsz -= 3;\n\t\t\tif (sz < len)\n\t\t\t\tbreak;\n\t\t\tp++;\n\t\t\tlen--;\n\t\t\treturn DecodeH323_UserInformation(buf, p, len,\n\t\t\t\t\t\t\t  &q931->UUIE);\n\t\t}\n\t\tp++;\n\t\tsz--;\n\t\tif (sz < 1)\n\t\t\tbreak;\n\t\tlen = *p++;\n\t\tsz--;\n\t\tif (sz < len)\n\t\t\tbreak;\n\t\tp += len;\n\t\tsz -= len;\n\t}\n\n\tPRINT(\"Q.931 UUIE not found\\n\");\n\n\treturn H323_ERROR_BOUND;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}