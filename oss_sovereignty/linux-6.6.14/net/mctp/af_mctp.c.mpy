{
  "module_name": "af_mctp.c",
  "hash_id": "92998a0b8cd0184eaab4129f795cae27464d99a2ad7b1ecc2328ff2b705683b3",
  "original_prompt": "Ingested from linux-6.6.14/net/mctp/af_mctp.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/if_arp.h>\n#include <linux/net.h>\n#include <linux/mctp.h>\n#include <linux/module.h>\n#include <linux/socket.h>\n\n#include <net/mctp.h>\n#include <net/mctpdevice.h>\n#include <net/sock.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/mctp.h>\n\n \n\nstatic void mctp_sk_expire_keys(struct timer_list *timer);\n\nstatic int mctp_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk) {\n\t\tsock->sk = NULL;\n\t\tsk->sk_prot->close(sk, 0);\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool mctp_sockaddr_is_ok(const struct sockaddr_mctp *addr)\n{\n\treturn !addr->__smctp_pad0 && !addr->__smctp_pad1;\n}\n\nstatic bool mctp_sockaddr_ext_is_ok(const struct sockaddr_mctp_ext *addr)\n{\n\treturn !addr->__smctp_pad0[0] &&\n\t       !addr->__smctp_pad0[1] &&\n\t       !addr->__smctp_pad0[2];\n}\n\nstatic int mctp_bind(struct socket *sock, struct sockaddr *addr, int addrlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct mctp_sock *msk = container_of(sk, struct mctp_sock, sk);\n\tstruct sockaddr_mctp *smctp;\n\tint rc;\n\n\tif (addrlen < sizeof(*smctp))\n\t\treturn -EINVAL;\n\n\tif (addr->sa_family != AF_MCTP)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (!capable(CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\t \n\tsmctp = (struct sockaddr_mctp *)addr;\n\n\tif (!mctp_sockaddr_is_ok(smctp))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\t \n\tif (sk_hashed(sk)) {\n\t\trc = -EADDRINUSE;\n\t\tgoto out_release;\n\t}\n\tmsk->bind_net = smctp->smctp_network;\n\tmsk->bind_addr = smctp->smctp_addr.s_addr;\n\tmsk->bind_type = smctp->smctp_type & 0x7f;  \n\n\trc = sk->sk_prot->hash(sk);\n\nout_release:\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int mctp_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_mctp *, addr, msg->msg_name);\n\tint rc, addrlen = msg->msg_namelen;\n\tstruct sock *sk = sock->sk;\n\tstruct mctp_sock *msk = container_of(sk, struct mctp_sock, sk);\n\tstruct mctp_skb_cb *cb;\n\tstruct mctp_route *rt;\n\tstruct sk_buff *skb = NULL;\n\tint hlen;\n\n\tif (addr) {\n\t\tconst u8 tagbits = MCTP_TAG_MASK | MCTP_TAG_OWNER |\n\t\t\tMCTP_TAG_PREALLOC;\n\n\t\tif (addrlen < sizeof(struct sockaddr_mctp))\n\t\t\treturn -EINVAL;\n\t\tif (addr->smctp_family != AF_MCTP)\n\t\t\treturn -EINVAL;\n\t\tif (!mctp_sockaddr_is_ok(addr))\n\t\t\treturn -EINVAL;\n\t\tif (addr->smctp_tag & ~tagbits)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (addr->smctp_tag & MCTP_TAG_PREALLOC &&\n\t\t    !(addr->smctp_tag & MCTP_TAG_OWNER))\n\t\t\treturn -EINVAL;\n\n\t} else {\n\t\t \n\t\treturn -EDESTADDRREQ;\n\t}\n\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EACCES;\n\n\tif (addr->smctp_network == MCTP_NET_ANY)\n\t\taddr->smctp_network = mctp_default_net(sock_net(sk));\n\n\t \n\tif (msk->addr_ext && addrlen >= sizeof(struct sockaddr_mctp_ext)) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_mctp_ext *,\n\t\t\t\t extaddr, msg->msg_name);\n\t\tstruct net_device *dev;\n\n\t\trc = -EINVAL;\n\t\trcu_read_lock();\n\t\tdev = dev_get_by_index_rcu(sock_net(sk), extaddr->smctp_ifindex);\n\t\t \n\t\tif (dev && extaddr->smctp_halen == dev->addr_len) {\n\t\t\thlen = LL_RESERVED_SPACE(dev) + sizeof(struct mctp_hdr);\n\t\t\trc = 0;\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (rc)\n\t\t\tgoto err_free;\n\t\trt = NULL;\n\t} else {\n\t\trt = mctp_route_lookup(sock_net(sk), addr->smctp_network,\n\t\t\t\t       addr->smctp_addr.s_addr);\n\t\tif (!rt) {\n\t\t\trc = -EHOSTUNREACH;\n\t\t\tgoto err_free;\n\t\t}\n\t\thlen = LL_RESERVED_SPACE(rt->dev->dev) + sizeof(struct mctp_hdr);\n\t}\n\n\tskb = sock_alloc_send_skb(sk, hlen + 1 + len,\n\t\t\t\t  msg->msg_flags & MSG_DONTWAIT, &rc);\n\tif (!skb)\n\t\treturn rc;\n\n\tskb_reserve(skb, hlen);\n\n\t \n\t*(u8 *)skb_put(skb, 1) = addr->smctp_type;\n\n\trc = memcpy_from_msg((void *)skb_put(skb, len), msg, len);\n\tif (rc < 0)\n\t\tgoto err_free;\n\n\t \n\tcb = __mctp_cb(skb);\n\tcb->net = addr->smctp_network;\n\n\tif (!rt) {\n\t\t \n\t\tDECLARE_SOCKADDR(struct sockaddr_mctp_ext *,\n\t\t\t\t extaddr, msg->msg_name);\n\n\t\tif (!mctp_sockaddr_ext_is_ok(extaddr) ||\n\t\t    extaddr->smctp_halen > sizeof(cb->haddr)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tcb->ifindex = extaddr->smctp_ifindex;\n\t\t \n\t\tcb->halen = extaddr->smctp_halen;\n\t\tmemcpy(cb->haddr, extaddr->smctp_haddr, cb->halen);\n\t}\n\n\trc = mctp_local_output(sk, rt, skb, addr->smctp_addr.s_addr,\n\t\t\t       addr->smctp_tag);\n\n\treturn rc ? : len;\n\nerr_free:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\nstatic int mctp_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\tint flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_mctp *, addr, msg->msg_name);\n\tstruct sock *sk = sock->sk;\n\tstruct mctp_sock *msk = container_of(sk, struct mctp_sock, sk);\n\tstruct sk_buff *skb;\n\tsize_t msglen;\n\tu8 type;\n\tint rc;\n\n\tif (flags & ~(MSG_DONTWAIT | MSG_TRUNC | MSG_PEEK))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, &rc);\n\tif (!skb)\n\t\treturn rc;\n\n\tif (!skb->len) {\n\t\trc = 0;\n\t\tgoto out_free;\n\t}\n\n\t \n\ttype = *((u8 *)skb->data);\n\tmsglen = skb->len - 1;\n\n\tif (len < msglen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\telse\n\t\tlen = msglen;\n\n\trc = skb_copy_datagram_msg(skb, 1, msg, len);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tsock_recv_cmsgs(msg, sk, skb);\n\n\tif (addr) {\n\t\tstruct mctp_skb_cb *cb = mctp_cb(skb);\n\t\t \n\t\tstruct mctp_hdr *hdr = mctp_hdr(skb);\n\n\t\taddr = msg->msg_name;\n\t\taddr->smctp_family = AF_MCTP;\n\t\taddr->__smctp_pad0 = 0;\n\t\taddr->smctp_network = cb->net;\n\t\taddr->smctp_addr.s_addr = hdr->src;\n\t\taddr->smctp_type = type;\n\t\taddr->smctp_tag = hdr->flags_seq_tag &\n\t\t\t\t\t(MCTP_HDR_TAG_MASK | MCTP_HDR_FLAG_TO);\n\t\taddr->__smctp_pad1 = 0;\n\t\tmsg->msg_namelen = sizeof(*addr);\n\n\t\tif (msk->addr_ext) {\n\t\t\tDECLARE_SOCKADDR(struct sockaddr_mctp_ext *, ae,\n\t\t\t\t\t msg->msg_name);\n\t\t\tmsg->msg_namelen = sizeof(*ae);\n\t\t\tae->smctp_ifindex = cb->ifindex;\n\t\t\tae->smctp_halen = cb->halen;\n\t\t\tmemset(ae->__smctp_pad0, 0x0, sizeof(ae->__smctp_pad0));\n\t\t\tmemset(ae->smctp_haddr, 0x0, sizeof(ae->smctp_haddr));\n\t\t\tmemcpy(ae->smctp_haddr, cb->haddr, cb->halen);\n\t\t}\n\t}\n\n\trc = len;\n\n\tif (flags & MSG_TRUNC)\n\t\trc = msglen;\n\nout_free:\n\tskb_free_datagram(sk, skb);\n\treturn rc;\n}\n\n \nstatic void __mctp_key_remove(struct mctp_sk_key *key, struct net *net,\n\t\t\t      unsigned long flags, unsigned long reason)\n__releases(&key->lock)\n__must_hold(&net->mctp.keys_lock)\n{\n\tstruct sk_buff *skb;\n\n\ttrace_mctp_key_release(key, reason);\n\tskb = key->reasm_head;\n\tkey->reasm_head = NULL;\n\tkey->reasm_dead = true;\n\tkey->valid = false;\n\tmctp_dev_release_key(key->dev, key);\n\tspin_unlock_irqrestore(&key->lock, flags);\n\n\tif (!hlist_unhashed(&key->hlist)) {\n\t\thlist_del_init(&key->hlist);\n\t\thlist_del_init(&key->sklist);\n\t\t \n\t\tmctp_key_unref(key);\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic int mctp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t   sockptr_t optval, unsigned int optlen)\n{\n\tstruct mctp_sock *msk = container_of(sock->sk, struct mctp_sock, sk);\n\tint val;\n\n\tif (level != SOL_MCTP)\n\t\treturn -EINVAL;\n\n\tif (optname == MCTP_OPT_ADDR_EXT) {\n\t\tif (optlen != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tmsk->addr_ext = val;\n\t\treturn 0;\n\t}\n\n\treturn -ENOPROTOOPT;\n}\n\nstatic int mctp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct mctp_sock *msk = container_of(sock->sk, struct mctp_sock, sk);\n\tint len, val;\n\n\tif (level != SOL_MCTP)\n\t\treturn -EINVAL;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (optname == MCTP_OPT_ADDR_EXT) {\n\t\tif (len != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tval = !!msk->addr_ext;\n\t\tif (copy_to_user(optval, &val, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mctp_ioctl_alloctag(struct mctp_sock *msk, unsigned long arg)\n{\n\tstruct net *net = sock_net(&msk->sk);\n\tstruct mctp_sk_key *key = NULL;\n\tstruct mctp_ioc_tag_ctl ctl;\n\tunsigned long flags;\n\tu8 tag;\n\n\tif (copy_from_user(&ctl, (void __user *)arg, sizeof(ctl)))\n\t\treturn -EFAULT;\n\n\tif (ctl.tag)\n\t\treturn -EINVAL;\n\n\tif (ctl.flags)\n\t\treturn -EINVAL;\n\n\tkey = mctp_alloc_local_tag(msk, ctl.peer_addr, MCTP_ADDR_ANY,\n\t\t\t\t   true, &tag);\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\tctl.tag = tag | MCTP_TAG_OWNER | MCTP_TAG_PREALLOC;\n\tif (copy_to_user((void __user *)arg, &ctl, sizeof(ctl))) {\n\t\tunsigned long fl2;\n\t\t \n\t\tspin_lock_irqsave(&net->mctp.keys_lock, flags);\n\t\tspin_lock_irqsave(&key->lock, fl2);\n\t\t__mctp_key_remove(key, net, fl2, MCTP_TRACE_KEY_DROPPED);\n\t\tmctp_key_unref(key);\n\t\tspin_unlock_irqrestore(&net->mctp.keys_lock, flags);\n\t\treturn -EFAULT;\n\t}\n\n\tmctp_key_unref(key);\n\treturn 0;\n}\n\nstatic int mctp_ioctl_droptag(struct mctp_sock *msk, unsigned long arg)\n{\n\tstruct net *net = sock_net(&msk->sk);\n\tstruct mctp_ioc_tag_ctl ctl;\n\tunsigned long flags, fl2;\n\tstruct mctp_sk_key *key;\n\tstruct hlist_node *tmp;\n\tint rc;\n\tu8 tag;\n\n\tif (copy_from_user(&ctl, (void __user *)arg, sizeof(ctl)))\n\t\treturn -EFAULT;\n\n\tif (ctl.flags)\n\t\treturn -EINVAL;\n\n\t \n\tif ((ctl.tag & ~MCTP_TAG_MASK) != (MCTP_TAG_OWNER | MCTP_TAG_PREALLOC))\n\t\treturn -EINVAL;\n\n\ttag = ctl.tag & MCTP_TAG_MASK;\n\trc = -EINVAL;\n\n\tspin_lock_irqsave(&net->mctp.keys_lock, flags);\n\thlist_for_each_entry_safe(key, tmp, &msk->keys, sklist) {\n\t\t \n\t\tspin_lock_irqsave(&key->lock, fl2);\n\t\tif (key->manual_alloc &&\n\t\t    ctl.peer_addr == key->peer_addr &&\n\t\t    tag == key->tag) {\n\t\t\t__mctp_key_remove(key, net, fl2,\n\t\t\t\t\t  MCTP_TRACE_KEY_DROPPED);\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&key->lock, fl2);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&net->mctp.keys_lock, flags);\n\n\treturn rc;\n}\n\nstatic int mctp_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct mctp_sock *msk = container_of(sock->sk, struct mctp_sock, sk);\n\n\tswitch (cmd) {\n\tcase SIOCMCTPALLOCTAG:\n\t\treturn mctp_ioctl_alloctag(msk, arg);\n\tcase SIOCMCTPDROPTAG:\n\t\treturn mctp_ioctl_droptag(msk, arg);\n\t}\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int mctp_compat_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\n\tswitch (cmd) {\n\t \n\tcase SIOCMCTPALLOCTAG:\n\tcase SIOCMCTPDROPTAG:\n\t\treturn mctp_ioctl(sock, cmd, (unsigned long)argp);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n#endif\n\nstatic const struct proto_ops mctp_dgram_ops = {\n\t.family\t\t= PF_MCTP,\n\t.release\t= mctp_release,\n\t.bind\t\t= mctp_bind,\n\t.connect\t= sock_no_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= sock_no_getname,\n\t.poll\t\t= datagram_poll,\n\t.ioctl\t\t= mctp_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.setsockopt\t= mctp_setsockopt,\n\t.getsockopt\t= mctp_getsockopt,\n\t.sendmsg\t= mctp_sendmsg,\n\t.recvmsg\t= mctp_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= mctp_compat_ioctl,\n#endif\n};\n\nstatic void mctp_sk_expire_keys(struct timer_list *timer)\n{\n\tstruct mctp_sock *msk = container_of(timer, struct mctp_sock,\n\t\t\t\t\t     key_expiry);\n\tstruct net *net = sock_net(&msk->sk);\n\tunsigned long next_expiry, flags, fl2;\n\tstruct mctp_sk_key *key;\n\tstruct hlist_node *tmp;\n\tbool next_expiry_valid = false;\n\n\tspin_lock_irqsave(&net->mctp.keys_lock, flags);\n\n\thlist_for_each_entry_safe(key, tmp, &msk->keys, sklist) {\n\t\t \n\t\tif (key->manual_alloc)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&key->lock, fl2);\n\t\tif (!time_after_eq(key->expiry, jiffies)) {\n\t\t\t__mctp_key_remove(key, net, fl2,\n\t\t\t\t\t  MCTP_TRACE_KEY_TIMEOUT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (next_expiry_valid) {\n\t\t\tif (time_before(key->expiry, next_expiry))\n\t\t\t\tnext_expiry = key->expiry;\n\t\t} else {\n\t\t\tnext_expiry = key->expiry;\n\t\t\tnext_expiry_valid = true;\n\t\t}\n\t\tspin_unlock_irqrestore(&key->lock, fl2);\n\t}\n\n\tspin_unlock_irqrestore(&net->mctp.keys_lock, flags);\n\n\tif (next_expiry_valid)\n\t\tmod_timer(timer, next_expiry);\n}\n\nstatic int mctp_sk_init(struct sock *sk)\n{\n\tstruct mctp_sock *msk = container_of(sk, struct mctp_sock, sk);\n\n\tINIT_HLIST_HEAD(&msk->keys);\n\ttimer_setup(&msk->key_expiry, mctp_sk_expire_keys, 0);\n\treturn 0;\n}\n\nstatic void mctp_sk_close(struct sock *sk, long timeout)\n{\n\tsk_common_release(sk);\n}\n\nstatic int mctp_sk_hash(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\n\tmutex_lock(&net->mctp.bind_lock);\n\tsk_add_node_rcu(sk, &net->mctp.binds);\n\tmutex_unlock(&net->mctp.bind_lock);\n\n\treturn 0;\n}\n\nstatic void mctp_sk_unhash(struct sock *sk)\n{\n\tstruct mctp_sock *msk = container_of(sk, struct mctp_sock, sk);\n\tstruct net *net = sock_net(sk);\n\tunsigned long flags, fl2;\n\tstruct mctp_sk_key *key;\n\tstruct hlist_node *tmp;\n\n\t \n\tmutex_lock(&net->mctp.bind_lock);\n\tsk_del_node_init_rcu(sk);\n\tmutex_unlock(&net->mctp.bind_lock);\n\n\t \n\tspin_lock_irqsave(&net->mctp.keys_lock, flags);\n\thlist_for_each_entry_safe(key, tmp, &msk->keys, sklist) {\n\t\tspin_lock_irqsave(&key->lock, fl2);\n\t\t__mctp_key_remove(key, net, fl2, MCTP_TRACE_KEY_CLOSED);\n\t}\n\tsock_set_flag(sk, SOCK_DEAD);\n\tspin_unlock_irqrestore(&net->mctp.keys_lock, flags);\n\n\t \n\tdel_timer_sync(&msk->key_expiry);\n}\n\nstatic void mctp_sk_destruct(struct sock *sk)\n{\n\tskb_queue_purge(&sk->sk_receive_queue);\n}\n\nstatic struct proto mctp_proto = {\n\t.name\t\t= \"MCTP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct mctp_sock),\n\t.init\t\t= mctp_sk_init,\n\t.close\t\t= mctp_sk_close,\n\t.hash\t\t= mctp_sk_hash,\n\t.unhash\t\t= mctp_sk_unhash,\n};\n\nstatic int mctp_pf_create(struct net *net, struct socket *sock,\n\t\t\t  int protocol, int kern)\n{\n\tconst struct proto_ops *ops;\n\tstruct proto *proto;\n\tstruct sock *sk;\n\tint rc;\n\n\tif (protocol)\n\t\treturn -EPROTONOSUPPORT;\n\n\t \n\tif (sock->type != SOCK_DGRAM)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tproto = &mctp_proto;\n\tops = &mctp_dgram_ops;\n\n\tsock->state = SS_UNCONNECTED;\n\tsock->ops = ops;\n\n\tsk = sk_alloc(net, PF_MCTP, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = mctp_sk_destruct;\n\n\trc = 0;\n\tif (sk->sk_prot->init)\n\t\trc = sk->sk_prot->init(sk);\n\n\tif (rc)\n\t\tgoto err_sk_put;\n\n\treturn 0;\n\nerr_sk_put:\n\tsock_orphan(sk);\n\tsock_put(sk);\n\treturn rc;\n}\n\nstatic struct net_proto_family mctp_pf = {\n\t.family = PF_MCTP,\n\t.create = mctp_pf_create,\n\t.owner = THIS_MODULE,\n};\n\nstatic __init int mctp_init(void)\n{\n\tint rc;\n\n\t \n\tBUILD_BUG_ON(MCTP_TAG_OWNER != MCTP_HDR_FLAG_TO);\n\tBUILD_BUG_ON(MCTP_TAG_MASK != MCTP_HDR_TAG_MASK);\n\n\tpr_info(\"mctp: management component transport protocol core\\n\");\n\n\trc = sock_register(&mctp_pf);\n\tif (rc)\n\t\treturn rc;\n\n\trc = proto_register(&mctp_proto, 0);\n\tif (rc)\n\t\tgoto err_unreg_sock;\n\n\trc = mctp_routes_init();\n\tif (rc)\n\t\tgoto err_unreg_proto;\n\n\trc = mctp_neigh_init();\n\tif (rc)\n\t\tgoto err_unreg_routes;\n\n\tmctp_device_init();\n\n\treturn 0;\n\nerr_unreg_routes:\n\tmctp_routes_exit();\nerr_unreg_proto:\n\tproto_unregister(&mctp_proto);\nerr_unreg_sock:\n\tsock_unregister(PF_MCTP);\n\n\treturn rc;\n}\n\nstatic __exit void mctp_exit(void)\n{\n\tmctp_device_exit();\n\tmctp_neigh_exit();\n\tmctp_routes_exit();\n\tproto_unregister(&mctp_proto);\n\tsock_unregister(PF_MCTP);\n}\n\nsubsys_initcall(mctp_init);\nmodule_exit(mctp_exit);\n\nMODULE_DESCRIPTION(\"MCTP core\");\nMODULE_AUTHOR(\"Jeremy Kerr <jk@codeconstruct.com.au>\");\n\nMODULE_ALIAS_NETPROTO(PF_MCTP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}