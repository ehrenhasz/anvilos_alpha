{
  "module_name": "route.c",
  "hash_id": "15f63426a8f28d32420dfded0c3d2612d5a119717a1f6862ec6dbde774b69e31",
  "original_prompt": "Ingested from linux-6.6.14/net/mctp/route.c",
  "human_readable_source": "\n \n\n#include <linux/idr.h>\n#include <linux/kconfig.h>\n#include <linux/mctp.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n\n#include <uapi/linux/if_arp.h>\n\n#include <net/mctp.h>\n#include <net/mctpdevice.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n\n#include <trace/events/mctp.h>\n\nstatic const unsigned int mctp_message_maxlen = 64 * 1024;\nstatic const unsigned long mctp_key_lifetime = 6 * CONFIG_HZ;\n\nstatic void mctp_flow_prepare_output(struct sk_buff *skb, struct mctp_dev *dev);\n\n \nstatic int mctp_route_discard(struct mctp_route *route, struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic struct mctp_sock *mctp_lookup_bind(struct net *net, struct sk_buff *skb)\n{\n\tstruct mctp_skb_cb *cb = mctp_cb(skb);\n\tstruct mctp_hdr *mh;\n\tstruct sock *sk;\n\tu8 type;\n\n\tWARN_ON(!rcu_read_lock_held());\n\n\t \n\tmh = mctp_hdr(skb);\n\n\tif (!skb_headlen(skb))\n\t\treturn NULL;\n\n\ttype = (*(u8 *)skb->data) & 0x7f;\n\n\tsk_for_each_rcu(sk, &net->mctp.binds) {\n\t\tstruct mctp_sock *msk = container_of(sk, struct mctp_sock, sk);\n\n\t\tif (msk->bind_net != MCTP_NET_ANY && msk->bind_net != cb->net)\n\t\t\tcontinue;\n\n\t\tif (msk->bind_type != type)\n\t\t\tcontinue;\n\n\t\tif (!mctp_address_matches(msk->bind_addr, mh->dest))\n\t\t\tcontinue;\n\n\t\treturn msk;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool mctp_key_match(struct mctp_sk_key *key, mctp_eid_t local,\n\t\t\t   mctp_eid_t peer, u8 tag)\n{\n\tif (!mctp_address_matches(key->local_addr, local))\n\t\treturn false;\n\n\tif (key->peer_addr != peer)\n\t\treturn false;\n\n\tif (key->tag != tag)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic struct mctp_sk_key *mctp_lookup_key(struct net *net, struct sk_buff *skb,\n\t\t\t\t\t   mctp_eid_t peer,\n\t\t\t\t\t   unsigned long *irqflags)\n\t__acquires(&key->lock)\n{\n\tstruct mctp_sk_key *key, *ret;\n\tunsigned long flags;\n\tstruct mctp_hdr *mh;\n\tu8 tag;\n\n\tmh = mctp_hdr(skb);\n\ttag = mh->flags_seq_tag & (MCTP_HDR_TAG_MASK | MCTP_HDR_FLAG_TO);\n\n\tret = NULL;\n\tspin_lock_irqsave(&net->mctp.keys_lock, flags);\n\n\thlist_for_each_entry(key, &net->mctp.keys, hlist) {\n\t\tif (!mctp_key_match(key, mh->dest, peer, tag))\n\t\t\tcontinue;\n\n\t\tspin_lock(&key->lock);\n\t\tif (key->valid) {\n\t\t\trefcount_inc(&key->refs);\n\t\t\tret = key;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&key->lock);\n\t}\n\n\tif (ret) {\n\t\tspin_unlock(&net->mctp.keys_lock);\n\t\t*irqflags = flags;\n\t} else {\n\t\tspin_unlock_irqrestore(&net->mctp.keys_lock, flags);\n\t}\n\n\treturn ret;\n}\n\nstatic struct mctp_sk_key *mctp_key_alloc(struct mctp_sock *msk,\n\t\t\t\t\t  mctp_eid_t local, mctp_eid_t peer,\n\t\t\t\t\t  u8 tag, gfp_t gfp)\n{\n\tstruct mctp_sk_key *key;\n\n\tkey = kzalloc(sizeof(*key), gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tkey->peer_addr = peer;\n\tkey->local_addr = local;\n\tkey->tag = tag;\n\tkey->sk = &msk->sk;\n\tkey->valid = true;\n\tspin_lock_init(&key->lock);\n\trefcount_set(&key->refs, 1);\n\tsock_hold(key->sk);\n\n\treturn key;\n}\n\nvoid mctp_key_unref(struct mctp_sk_key *key)\n{\n\tunsigned long flags;\n\n\tif (!refcount_dec_and_test(&key->refs))\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&key->lock, flags);\n\tmctp_dev_release_key(key->dev, key);\n\tspin_unlock_irqrestore(&key->lock, flags);\n\n\tsock_put(key->sk);\n\tkfree(key);\n}\n\nstatic int mctp_key_add(struct mctp_sk_key *key, struct mctp_sock *msk)\n{\n\tstruct net *net = sock_net(&msk->sk);\n\tstruct mctp_sk_key *tmp;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&net->mctp.keys_lock, flags);\n\n\tif (sock_flag(&msk->sk, SOCK_DEAD)) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\thlist_for_each_entry(tmp, &net->mctp.keys, hlist) {\n\t\tif (mctp_key_match(tmp, key->local_addr, key->peer_addr,\n\t\t\t\t   key->tag)) {\n\t\t\tspin_lock(&tmp->lock);\n\t\t\tif (tmp->valid)\n\t\t\t\trc = -EEXIST;\n\t\t\tspin_unlock(&tmp->lock);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rc) {\n\t\trefcount_inc(&key->refs);\n\t\tkey->expiry = jiffies + mctp_key_lifetime;\n\t\ttimer_reduce(&msk->key_expiry, key->expiry);\n\n\t\thlist_add_head(&key->hlist, &net->mctp.keys);\n\t\thlist_add_head(&key->sklist, &msk->keys);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&net->mctp.keys_lock, flags);\n\n\treturn rc;\n}\n\n \nstatic void __mctp_key_done_in(struct mctp_sk_key *key, struct net *net,\n\t\t\t       unsigned long flags, unsigned long reason)\n__releases(&key->lock)\n{\n\tstruct sk_buff *skb;\n\n\ttrace_mctp_key_release(key, reason);\n\tskb = key->reasm_head;\n\tkey->reasm_head = NULL;\n\n\tif (!key->manual_alloc) {\n\t\tkey->reasm_dead = true;\n\t\tkey->valid = false;\n\t\tmctp_dev_release_key(key->dev, key);\n\t}\n\tspin_unlock_irqrestore(&key->lock, flags);\n\n\tif (!key->manual_alloc) {\n\t\tspin_lock_irqsave(&net->mctp.keys_lock, flags);\n\t\tif (!hlist_unhashed(&key->hlist)) {\n\t\t\thlist_del_init(&key->hlist);\n\t\t\thlist_del_init(&key->sklist);\n\t\t\tmctp_key_unref(key);\n\t\t}\n\t\tspin_unlock_irqrestore(&net->mctp.keys_lock, flags);\n\t}\n\n\t \n\tmctp_key_unref(key);\n\n\tkfree_skb(skb);\n}\n\n#ifdef CONFIG_MCTP_FLOWS\nstatic void mctp_skb_set_flow(struct sk_buff *skb, struct mctp_sk_key *key)\n{\n\tstruct mctp_flow *flow;\n\n\tflow = skb_ext_add(skb, SKB_EXT_MCTP);\n\tif (!flow)\n\t\treturn;\n\n\trefcount_inc(&key->refs);\n\tflow->key = key;\n}\n\nstatic void mctp_flow_prepare_output(struct sk_buff *skb, struct mctp_dev *dev)\n{\n\tstruct mctp_sk_key *key;\n\tstruct mctp_flow *flow;\n\n\tflow = skb_ext_find(skb, SKB_EXT_MCTP);\n\tif (!flow)\n\t\treturn;\n\n\tkey = flow->key;\n\n\tif (WARN_ON(key->dev && key->dev != dev))\n\t\treturn;\n\n\tmctp_dev_set_key(dev, key);\n}\n#else\nstatic void mctp_skb_set_flow(struct sk_buff *skb, struct mctp_sk_key *key) {}\nstatic void mctp_flow_prepare_output(struct sk_buff *skb, struct mctp_dev *dev) {}\n#endif\n\nstatic int mctp_frag_queue(struct mctp_sk_key *key, struct sk_buff *skb)\n{\n\tstruct mctp_hdr *hdr = mctp_hdr(skb);\n\tu8 exp_seq, this_seq;\n\n\tthis_seq = (hdr->flags_seq_tag >> MCTP_HDR_SEQ_SHIFT)\n\t\t& MCTP_HDR_SEQ_MASK;\n\n\tif (!key->reasm_head) {\n\t\tkey->reasm_head = skb;\n\t\tkey->reasm_tailp = &(skb_shinfo(skb)->frag_list);\n\t\tkey->last_seq = this_seq;\n\t\treturn 0;\n\t}\n\n\texp_seq = (key->last_seq + 1) & MCTP_HDR_SEQ_MASK;\n\n\tif (this_seq != exp_seq)\n\t\treturn -EINVAL;\n\n\tif (key->reasm_head->len + skb->len > mctp_message_maxlen)\n\t\treturn -EINVAL;\n\n\tskb->next = NULL;\n\tskb->sk = NULL;\n\t*key->reasm_tailp = skb;\n\tkey->reasm_tailp = &skb->next;\n\n\tkey->last_seq = this_seq;\n\n\tkey->reasm_head->data_len += skb->len;\n\tkey->reasm_head->len += skb->len;\n\tkey->reasm_head->truesize += skb->truesize;\n\n\treturn 0;\n}\n\nstatic int mctp_route_input(struct mctp_route *route, struct sk_buff *skb)\n{\n\tstruct mctp_sk_key *key, *any_key = NULL;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct mctp_sock *msk;\n\tstruct mctp_hdr *mh;\n\tunsigned long f;\n\tu8 tag, flags;\n\tint rc;\n\n\tmsk = NULL;\n\trc = -EINVAL;\n\n\t \n\tskb_orphan(skb);\n\n\t \n\tif (skb->len < sizeof(struct mctp_hdr) + 1)\n\t\tgoto out;\n\n\t \n\tmh = mctp_hdr(skb);\n\tskb_pull(skb, sizeof(struct mctp_hdr));\n\n\tif (mh->ver != 1)\n\t\tgoto out;\n\n\tflags = mh->flags_seq_tag & (MCTP_HDR_FLAG_SOM | MCTP_HDR_FLAG_EOM);\n\ttag = mh->flags_seq_tag & (MCTP_HDR_TAG_MASK | MCTP_HDR_FLAG_TO);\n\n\trcu_read_lock();\n\n\t \n\tkey = mctp_lookup_key(net, skb, mh->src, &f);\n\n\tif (flags & MCTP_HDR_FLAG_SOM) {\n\t\tif (key) {\n\t\t\tmsk = container_of(key->sk, struct mctp_sock, sk);\n\t\t} else {\n\t\t\t \n\t\t\tany_key = mctp_lookup_key(net, skb, MCTP_ADDR_ANY, &f);\n\t\t\tif (any_key) {\n\t\t\t\tmsk = container_of(any_key->sk,\n\t\t\t\t\t\t   struct mctp_sock, sk);\n\t\t\t\tspin_unlock_irqrestore(&any_key->lock, f);\n\t\t\t}\n\t\t}\n\n\t\tif (!key && !msk && (tag & MCTP_HDR_FLAG_TO))\n\t\t\tmsk = mctp_lookup_bind(net, skb);\n\n\t\tif (!msk) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (flags & MCTP_HDR_FLAG_EOM) {\n\t\t\tsock_queue_rcv_skb(&msk->sk, skb);\n\t\t\tif (key) {\n\t\t\t\t \n\t\t\t\t__mctp_key_done_in(key, net, f,\n\t\t\t\t\t\t   MCTP_TRACE_KEY_REPLIED);\n\t\t\t\tkey = NULL;\n\t\t\t}\n\t\t\trc = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (!key) {\n\t\t\tkey = mctp_key_alloc(msk, mh->dest, mh->src,\n\t\t\t\t\t     tag, GFP_ATOMIC);\n\t\t\tif (!key) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\t \n\t\t\tmctp_frag_queue(key, skb);\n\n\t\t\t \n\t\t\trc = mctp_key_add(key, msk);\n\t\t\tif (!rc)\n\t\t\t\ttrace_mctp_key_acquire(key);\n\n\t\t\t \n\t\t\tmctp_key_unref(key);\n\t\t\tkey = NULL;\n\n\t\t} else {\n\t\t\tif (key->reasm_head || key->reasm_dead) {\n\t\t\t\t \n\t\t\t\t__mctp_key_done_in(key, net, f,\n\t\t\t\t\t\t   MCTP_TRACE_KEY_INVALIDATED);\n\t\t\t\trc = -EEXIST;\n\t\t\t\tkey = NULL;\n\t\t\t} else {\n\t\t\t\trc = mctp_frag_queue(key, skb);\n\t\t\t}\n\t\t}\n\n\t} else if (key) {\n\t\t \n\n\t\t \n\t\tif (!key->reasm_head)\n\t\t\trc = -EINVAL;\n\t\telse\n\t\t\trc = mctp_frag_queue(key, skb);\n\n\t\t \n\t\tif (!rc && flags & MCTP_HDR_FLAG_EOM) {\n\t\t\tsock_queue_rcv_skb(key->sk, key->reasm_head);\n\t\t\tkey->reasm_head = NULL;\n\t\t\t__mctp_key_done_in(key, net, f, MCTP_TRACE_KEY_REPLIED);\n\t\t\tkey = NULL;\n\t\t}\n\n\t} else {\n\t\t \n\t\trc = -ENOENT;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\n\tif (key) {\n\t\tspin_unlock_irqrestore(&key->lock, f);\n\t\tmctp_key_unref(key);\n\t}\n\tif (any_key)\n\t\tmctp_key_unref(any_key);\nout:\n\tif (rc)\n\t\tkfree_skb(skb);\n\treturn rc;\n}\n\nstatic unsigned int mctp_route_mtu(struct mctp_route *rt)\n{\n\treturn rt->mtu ?: READ_ONCE(rt->dev->dev->mtu);\n}\n\nstatic int mctp_route_output(struct mctp_route *route, struct sk_buff *skb)\n{\n\tstruct mctp_skb_cb *cb = mctp_cb(skb);\n\tstruct mctp_hdr *hdr = mctp_hdr(skb);\n\tchar daddr_buf[MAX_ADDR_LEN];\n\tchar *daddr = NULL;\n\tunsigned int mtu;\n\tint rc;\n\n\tskb->protocol = htons(ETH_P_MCTP);\n\n\tmtu = READ_ONCE(skb->dev->mtu);\n\tif (skb->len > mtu) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (cb->ifindex) {\n\t\t \n\t\tif (cb->halen != skb->dev->addr_len) {\n\t\t\t \n\t\t\tkfree_skb(skb);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t\tdaddr = cb->haddr;\n\t} else {\n\t\t \n\t\tif (mctp_neigh_lookup(route->dev, hdr->dest, daddr_buf) == 0)\n\t\t\tdaddr = daddr_buf;\n\t}\n\n\trc = dev_hard_header(skb, skb->dev, ntohs(skb->protocol),\n\t\t\t     daddr, skb->dev->dev_addr, skb->len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EHOSTUNREACH;\n\t}\n\n\tmctp_flow_prepare_output(skb, route->dev);\n\n\trc = dev_queue_xmit(skb);\n\tif (rc)\n\t\trc = net_xmit_errno(rc);\n\n\treturn rc;\n}\n\n \nstatic void mctp_route_release(struct mctp_route *rt)\n{\n\tif (refcount_dec_and_test(&rt->refs)) {\n\t\tmctp_dev_put(rt->dev);\n\t\tkfree_rcu(rt, rcu);\n\t}\n}\n\n \nstatic struct mctp_route *mctp_route_alloc(void)\n{\n\tstruct mctp_route *rt;\n\n\trt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\tif (!rt)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rt->list);\n\trefcount_set(&rt->refs, 1);\n\trt->output = mctp_route_discard;\n\n\treturn rt;\n}\n\nunsigned int mctp_default_net(struct net *net)\n{\n\treturn READ_ONCE(net->mctp.default_net);\n}\n\nint mctp_default_net_set(struct net *net, unsigned int index)\n{\n\tif (index == 0)\n\t\treturn -EINVAL;\n\tWRITE_ONCE(net->mctp.default_net, index);\n\treturn 0;\n}\n\n \nstatic void mctp_reserve_tag(struct net *net, struct mctp_sk_key *key,\n\t\t\t     struct mctp_sock *msk)\n{\n\tstruct netns_mctp *mns = &net->mctp;\n\n\tlockdep_assert_held(&mns->keys_lock);\n\n\tkey->expiry = jiffies + mctp_key_lifetime;\n\ttimer_reduce(&msk->key_expiry, key->expiry);\n\n\t \n\thlist_add_head_rcu(&key->hlist, &mns->keys);\n\thlist_add_head_rcu(&key->sklist, &msk->keys);\n\trefcount_inc(&key->refs);\n}\n\n \nstruct mctp_sk_key *mctp_alloc_local_tag(struct mctp_sock *msk,\n\t\t\t\t\t mctp_eid_t daddr, mctp_eid_t saddr,\n\t\t\t\t\t bool manual, u8 *tagp)\n{\n\tstruct net *net = sock_net(&msk->sk);\n\tstruct netns_mctp *mns = &net->mctp;\n\tstruct mctp_sk_key *key, *tmp;\n\tunsigned long flags;\n\tu8 tagbits;\n\n\t \n\tif (daddr == MCTP_ADDR_NULL)\n\t\tdaddr = MCTP_ADDR_ANY;\n\n\t \n\tkey = mctp_key_alloc(msk, saddr, daddr, 0, GFP_KERNEL);\n\tif (!key)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\ttagbits = 0xff;\n\n\tspin_lock_irqsave(&mns->keys_lock, flags);\n\n\t \n\thlist_for_each_entry(tmp, &mns->keys, hlist) {\n\t\t \n\n\t\t \n\t\tif (tmp->tag & MCTP_HDR_FLAG_TO)\n\t\t\tcontinue;\n\n\t\tif (!(mctp_address_matches(tmp->peer_addr, daddr) &&\n\t\t      mctp_address_matches(tmp->local_addr, saddr)))\n\t\t\tcontinue;\n\n\t\tspin_lock(&tmp->lock);\n\t\t \n\t\tif (tmp->valid)\n\t\t\ttagbits &= ~(1 << tmp->tag);\n\t\tspin_unlock(&tmp->lock);\n\n\t\tif (!tagbits)\n\t\t\tbreak;\n\t}\n\n\tif (tagbits) {\n\t\tkey->tag = __ffs(tagbits);\n\t\tmctp_reserve_tag(net, key, msk);\n\t\ttrace_mctp_key_acquire(key);\n\n\t\tkey->manual_alloc = manual;\n\t\t*tagp = key->tag;\n\t}\n\n\tspin_unlock_irqrestore(&mns->keys_lock, flags);\n\n\tif (!tagbits) {\n\t\tkfree(key);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\treturn key;\n}\n\nstatic struct mctp_sk_key *mctp_lookup_prealloc_tag(struct mctp_sock *msk,\n\t\t\t\t\t\t    mctp_eid_t daddr,\n\t\t\t\t\t\t    u8 req_tag, u8 *tagp)\n{\n\tstruct net *net = sock_net(&msk->sk);\n\tstruct netns_mctp *mns = &net->mctp;\n\tstruct mctp_sk_key *key, *tmp;\n\tunsigned long flags;\n\n\treq_tag &= ~(MCTP_TAG_PREALLOC | MCTP_TAG_OWNER);\n\tkey = NULL;\n\n\tspin_lock_irqsave(&mns->keys_lock, flags);\n\n\thlist_for_each_entry(tmp, &mns->keys, hlist) {\n\t\tif (tmp->tag != req_tag)\n\t\t\tcontinue;\n\n\t\tif (!mctp_address_matches(tmp->peer_addr, daddr))\n\t\t\tcontinue;\n\n\t\tif (!tmp->manual_alloc)\n\t\t\tcontinue;\n\n\t\tspin_lock(&tmp->lock);\n\t\tif (tmp->valid) {\n\t\t\tkey = tmp;\n\t\t\trefcount_inc(&key->refs);\n\t\t\tspin_unlock(&tmp->lock);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&tmp->lock);\n\t}\n\tspin_unlock_irqrestore(&mns->keys_lock, flags);\n\n\tif (!key)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (tagp)\n\t\t*tagp = key->tag;\n\n\treturn key;\n}\n\n \nstatic bool mctp_rt_match_eid(struct mctp_route *rt,\n\t\t\t      unsigned int net, mctp_eid_t eid)\n{\n\treturn READ_ONCE(rt->dev->net) == net &&\n\t\trt->min <= eid && rt->max >= eid;\n}\n\n \nstatic bool mctp_rt_compare_exact(struct mctp_route *rt1,\n\t\t\t\t  struct mctp_route *rt2)\n{\n\tASSERT_RTNL();\n\treturn rt1->dev->net == rt2->dev->net &&\n\t\trt1->min == rt2->min &&\n\t\trt1->max == rt2->max;\n}\n\nstruct mctp_route *mctp_route_lookup(struct net *net, unsigned int dnet,\n\t\t\t\t     mctp_eid_t daddr)\n{\n\tstruct mctp_route *tmp, *rt = NULL;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(tmp, &net->mctp.routes, list) {\n\t\t \n\t\tif (mctp_rt_match_eid(tmp, dnet, daddr)) {\n\t\t\tif (refcount_inc_not_zero(&tmp->refs)) {\n\t\t\t\trt = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn rt;\n}\n\nstatic struct mctp_route *mctp_route_lookup_null(struct net *net,\n\t\t\t\t\t\t struct net_device *dev)\n{\n\tstruct mctp_route *tmp, *rt = NULL;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(tmp, &net->mctp.routes, list) {\n\t\tif (tmp->dev->dev == dev && tmp->type == RTN_LOCAL &&\n\t\t    refcount_inc_not_zero(&tmp->refs)) {\n\t\t\trt = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn rt;\n}\n\nstatic int mctp_do_fragment_route(struct mctp_route *rt, struct sk_buff *skb,\n\t\t\t\t  unsigned int mtu, u8 tag)\n{\n\tconst unsigned int hlen = sizeof(struct mctp_hdr);\n\tstruct mctp_hdr *hdr, *hdr2;\n\tunsigned int pos, size, headroom;\n\tstruct sk_buff *skb2;\n\tint rc;\n\tu8 seq;\n\n\thdr = mctp_hdr(skb);\n\tseq = 0;\n\trc = 0;\n\n\tif (mtu < hlen + 1) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\theadroom = skb_headroom(skb);\n\n\t \n\tskb_pull(skb, hlen);\n\n\tfor (pos = 0; pos < skb->len;) {\n\t\t \n\t\tsize = min(mtu - hlen, skb->len - pos);\n\n\t\tskb2 = alloc_skb(headroom + hlen + size, GFP_KERNEL);\n\t\tif (!skb2) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tskb2->protocol = skb->protocol;\n\t\tskb2->priority = skb->priority;\n\t\tskb2->dev = skb->dev;\n\t\tmemcpy(skb2->cb, skb->cb, sizeof(skb2->cb));\n\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(skb2, skb->sk);\n\n\t\t \n\t\tskb_reserve(skb2, headroom);\n\t\tskb_reset_network_header(skb2);\n\t\tskb_put(skb2, hlen + size);\n\t\tskb2->transport_header = skb2->network_header + hlen;\n\n\t\t \n\t\thdr2 = mctp_hdr(skb2);\n\t\thdr2->ver = hdr->ver;\n\t\thdr2->dest = hdr->dest;\n\t\thdr2->src = hdr->src;\n\t\thdr2->flags_seq_tag = tag &\n\t\t\t(MCTP_HDR_TAG_MASK | MCTP_HDR_FLAG_TO);\n\n\t\tif (pos == 0)\n\t\t\thdr2->flags_seq_tag |= MCTP_HDR_FLAG_SOM;\n\n\t\tif (pos + size == skb->len)\n\t\t\thdr2->flags_seq_tag |= MCTP_HDR_FLAG_EOM;\n\n\t\thdr2->flags_seq_tag |= seq << MCTP_HDR_SEQ_SHIFT;\n\n\t\t \n\t\tskb_copy_bits(skb, pos, skb_transport_header(skb2), size);\n\n\t\t \n\t\trc = rt->output(rt, skb2);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tseq = (seq + 1) & MCTP_HDR_SEQ_MASK;\n\t\tpos += size;\n\t}\n\n\tconsume_skb(skb);\n\treturn rc;\n}\n\nint mctp_local_output(struct sock *sk, struct mctp_route *rt,\n\t\t      struct sk_buff *skb, mctp_eid_t daddr, u8 req_tag)\n{\n\tstruct mctp_sock *msk = container_of(sk, struct mctp_sock, sk);\n\tstruct mctp_skb_cb *cb = mctp_cb(skb);\n\tstruct mctp_route tmp_rt = {0};\n\tstruct mctp_sk_key *key;\n\tstruct mctp_hdr *hdr;\n\tunsigned long flags;\n\tunsigned int mtu;\n\tmctp_eid_t saddr;\n\tbool ext_rt;\n\tint rc;\n\tu8 tag;\n\n\trc = -ENODEV;\n\n\tif (rt) {\n\t\text_rt = false;\n\t\tif (WARN_ON(!rt->dev))\n\t\t\tgoto out_release;\n\n\t} else if (cb->ifindex) {\n\t\tstruct net_device *dev;\n\n\t\text_rt = true;\n\t\trt = &tmp_rt;\n\n\t\trcu_read_lock();\n\t\tdev = dev_get_by_index_rcu(sock_net(sk), cb->ifindex);\n\t\tif (!dev) {\n\t\t\trcu_read_unlock();\n\t\t\treturn rc;\n\t\t}\n\t\trt->dev = __mctp_dev_get(dev);\n\t\trcu_read_unlock();\n\n\t\tif (!rt->dev)\n\t\t\tgoto out_release;\n\n\t\t \n\t\trt->output = mctp_route_output;\n\t\trt->mtu = 0;\n\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&rt->dev->addrs_lock, flags);\n\tif (rt->dev->num_addrs == 0) {\n\t\trc = -EHOSTUNREACH;\n\t} else {\n\t\t \n\t\tsaddr = rt->dev->addrs[0];\n\t\trc = 0;\n\t}\n\tspin_unlock_irqrestore(&rt->dev->addrs_lock, flags);\n\n\tif (rc)\n\t\tgoto out_release;\n\n\tif (req_tag & MCTP_TAG_OWNER) {\n\t\tif (req_tag & MCTP_TAG_PREALLOC)\n\t\t\tkey = mctp_lookup_prealloc_tag(msk, daddr,\n\t\t\t\t\t\t       req_tag, &tag);\n\t\telse\n\t\t\tkey = mctp_alloc_local_tag(msk, daddr, saddr,\n\t\t\t\t\t\t   false, &tag);\n\n\t\tif (IS_ERR(key)) {\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_release;\n\t\t}\n\t\tmctp_skb_set_flow(skb, key);\n\t\t \n\t\tmctp_key_unref(key);\n\t\ttag |= MCTP_HDR_FLAG_TO;\n\t} else {\n\t\tkey = NULL;\n\t\ttag = req_tag & MCTP_TAG_MASK;\n\t}\n\n\tskb->protocol = htons(ETH_P_MCTP);\n\tskb->priority = 0;\n\tskb_reset_transport_header(skb);\n\tskb_push(skb, sizeof(struct mctp_hdr));\n\tskb_reset_network_header(skb);\n\tskb->dev = rt->dev->dev;\n\n\t \n\tcb->src = saddr;\n\n\t \n\thdr = mctp_hdr(skb);\n\thdr->ver = 1;\n\thdr->dest = daddr;\n\thdr->src = saddr;\n\n\tmtu = mctp_route_mtu(rt);\n\n\tif (skb->len + sizeof(struct mctp_hdr) <= mtu) {\n\t\thdr->flags_seq_tag = MCTP_HDR_FLAG_SOM |\n\t\t\tMCTP_HDR_FLAG_EOM | tag;\n\t\trc = rt->output(rt, skb);\n\t} else {\n\t\trc = mctp_do_fragment_route(rt, skb, mtu, tag);\n\t}\n\nout_release:\n\tif (!ext_rt)\n\t\tmctp_route_release(rt);\n\n\tmctp_dev_put(tmp_rt.dev);\n\n\treturn rc;\n}\n\n \nstatic int mctp_route_add(struct mctp_dev *mdev, mctp_eid_t daddr_start,\n\t\t\t  unsigned int daddr_extent, unsigned int mtu,\n\t\t\t  unsigned char type)\n{\n\tint (*rtfn)(struct mctp_route *rt, struct sk_buff *skb);\n\tstruct net *net = dev_net(mdev->dev);\n\tstruct mctp_route *rt, *ert;\n\n\tif (!mctp_address_unicast(daddr_start))\n\t\treturn -EINVAL;\n\n\tif (daddr_extent > 0xff || daddr_start + daddr_extent >= 255)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase RTN_LOCAL:\n\t\trtfn = mctp_route_input;\n\t\tbreak;\n\tcase RTN_UNICAST:\n\t\trtfn = mctp_route_output;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trt = mctp_route_alloc();\n\tif (!rt)\n\t\treturn -ENOMEM;\n\n\trt->min = daddr_start;\n\trt->max = daddr_start + daddr_extent;\n\trt->mtu = mtu;\n\trt->dev = mdev;\n\tmctp_dev_hold(rt->dev);\n\trt->type = type;\n\trt->output = rtfn;\n\n\tASSERT_RTNL();\n\t \n\tlist_for_each_entry(ert, &net->mctp.routes, list) {\n\t\tif (mctp_rt_compare_exact(rt, ert)) {\n\t\t\tmctp_route_release(rt);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tlist_add_rcu(&rt->list, &net->mctp.routes);\n\n\treturn 0;\n}\n\nstatic int mctp_route_remove(struct mctp_dev *mdev, mctp_eid_t daddr_start,\n\t\t\t     unsigned int daddr_extent, unsigned char type)\n{\n\tstruct net *net = dev_net(mdev->dev);\n\tstruct mctp_route *rt, *tmp;\n\tmctp_eid_t daddr_end;\n\tbool dropped;\n\n\tif (daddr_extent > 0xff || daddr_start + daddr_extent >= 255)\n\t\treturn -EINVAL;\n\n\tdaddr_end = daddr_start + daddr_extent;\n\tdropped = false;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry_safe(rt, tmp, &net->mctp.routes, list) {\n\t\tif (rt->dev == mdev &&\n\t\t    rt->min == daddr_start && rt->max == daddr_end &&\n\t\t    rt->type == type) {\n\t\t\tlist_del_rcu(&rt->list);\n\t\t\t \n\t\t\tmctp_route_release(rt);\n\t\t\tdropped = true;\n\t\t}\n\t}\n\n\treturn dropped ? 0 : -ENOENT;\n}\n\nint mctp_route_add_local(struct mctp_dev *mdev, mctp_eid_t addr)\n{\n\treturn mctp_route_add(mdev, addr, 0, 0, RTN_LOCAL);\n}\n\nint mctp_route_remove_local(struct mctp_dev *mdev, mctp_eid_t addr)\n{\n\treturn mctp_route_remove(mdev, addr, 0, RTN_LOCAL);\n}\n\n \nvoid mctp_route_remove_dev(struct mctp_dev *mdev)\n{\n\tstruct net *net = dev_net(mdev->dev);\n\tstruct mctp_route *rt, *tmp;\n\n\tASSERT_RTNL();\n\tlist_for_each_entry_safe(rt, tmp, &net->mctp.routes, list) {\n\t\tif (rt->dev == mdev) {\n\t\t\tlist_del_rcu(&rt->list);\n\t\t\t \n\t\t\tmctp_route_release(rt);\n\t\t}\n\t}\n}\n\n \n\nstatic int mctp_pkttype_receive(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\tstruct packet_type *pt,\n\t\t\t\tstruct net_device *orig_dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct mctp_dev *mdev;\n\tstruct mctp_skb_cb *cb;\n\tstruct mctp_route *rt;\n\tstruct mctp_hdr *mh;\n\n\trcu_read_lock();\n\tmdev = __mctp_dev_get(dev);\n\trcu_read_unlock();\n\tif (!mdev) {\n\t\t \n\t\tgoto err_drop;\n\t}\n\n\tif (!pskb_may_pull(skb, sizeof(struct mctp_hdr)))\n\t\tgoto err_drop;\n\n\tskb_reset_transport_header(skb);\n\tskb_reset_network_header(skb);\n\n\t \n\tmh = mctp_hdr(skb);\n\tif (mh->ver < MCTP_VER_MIN || mh->ver > MCTP_VER_MAX)\n\t\tgoto err_drop;\n\n\t \n\tif (!(mctp_address_unicast(mh->src) || mctp_address_null(mh->src)))\n\t\tgoto err_drop;\n\n\t \n\tif (!(mctp_address_unicast(mh->dest) || mctp_address_null(mh->dest) ||\n\t      mctp_address_broadcast(mh->dest)))\n\t\tgoto err_drop;\n\n\t \n\tif (dev->type == ARPHRD_MCTP) {\n\t\tcb = mctp_cb(skb);\n\t} else {\n\t\tcb = __mctp_cb(skb);\n\t\tcb->halen = 0;\n\t}\n\tcb->net = READ_ONCE(mdev->net);\n\tcb->ifindex = dev->ifindex;\n\n\trt = mctp_route_lookup(net, cb->net, mh->dest);\n\n\t \n\tif (!rt && mh->dest == MCTP_ADDR_NULL && skb->pkt_type == PACKET_HOST)\n\t\trt = mctp_route_lookup_null(net, dev);\n\n\tif (!rt)\n\t\tgoto err_drop;\n\n\trt->output(rt, skb);\n\tmctp_route_release(rt);\n\tmctp_dev_put(mdev);\n\n\treturn NET_RX_SUCCESS;\n\nerr_drop:\n\tkfree_skb(skb);\n\tmctp_dev_put(mdev);\n\treturn NET_RX_DROP;\n}\n\nstatic struct packet_type mctp_packet_type = {\n\t.type = cpu_to_be16(ETH_P_MCTP),\n\t.func = mctp_pkttype_receive,\n};\n\n \n\nstatic const struct nla_policy rta_mctp_policy[RTA_MAX + 1] = {\n\t[RTA_DST]\t\t= { .type = NLA_U8 },\n\t[RTA_METRICS]\t\t= { .type = NLA_NESTED },\n\t[RTA_OIF]\t\t= { .type = NLA_U32 },\n};\n\n \nstatic int mctp_route_nlparse(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      struct nlattr **tb, struct rtmsg **rtm,\n\t\t\t      struct mctp_dev **mdev, mctp_eid_t *daddr_start)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tunsigned int ifindex;\n\tint rc;\n\n\trc = nlmsg_parse(nlh, sizeof(struct rtmsg), tb, RTA_MAX,\n\t\t\t rta_mctp_policy, extack);\n\tif (rc < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"incorrect format\");\n\t\treturn rc;\n\t}\n\n\tif (!tb[RTA_DST]) {\n\t\tNL_SET_ERR_MSG(extack, \"dst EID missing\");\n\t\treturn -EINVAL;\n\t}\n\t*daddr_start = nla_get_u8(tb[RTA_DST]);\n\n\tif (!tb[RTA_OIF]) {\n\t\tNL_SET_ERR_MSG(extack, \"ifindex missing\");\n\t\treturn -EINVAL;\n\t}\n\tifindex = nla_get_u32(tb[RTA_OIF]);\n\n\t*rtm = nlmsg_data(nlh);\n\tif ((*rtm)->rtm_family != AF_MCTP) {\n\t\tNL_SET_ERR_MSG(extack, \"route family must be AF_MCTP\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ifindex);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"bad ifindex\");\n\t\treturn -ENODEV;\n\t}\n\t*mdev = mctp_dev_get_rtnl(dev);\n\tif (!*mdev)\n\t\treturn -ENODEV;\n\n\tif (dev->flags & IFF_LOOPBACK) {\n\t\tNL_SET_ERR_MSG(extack, \"no routes to loopback\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nla_policy rta_metrics_policy[RTAX_MAX + 1] = {\n\t[RTAX_MTU]\t\t= { .type = NLA_U32 },\n};\n\nstatic int mctp_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RTA_MAX + 1];\n\tstruct nlattr *tbx[RTAX_MAX + 1];\n\tmctp_eid_t daddr_start;\n\tstruct mctp_dev *mdev;\n\tstruct rtmsg *rtm;\n\tunsigned int mtu;\n\tint rc;\n\n\trc = mctp_route_nlparse(skb, nlh, extack, tb,\n\t\t\t\t&rtm, &mdev, &daddr_start);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (rtm->rtm_type != RTN_UNICAST) {\n\t\tNL_SET_ERR_MSG(extack, \"rtm_type must be RTN_UNICAST\");\n\t\treturn -EINVAL;\n\t}\n\n\tmtu = 0;\n\tif (tb[RTA_METRICS]) {\n\t\trc = nla_parse_nested(tbx, RTAX_MAX, tb[RTA_METRICS],\n\t\t\t\t      rta_metrics_policy, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (tbx[RTAX_MTU])\n\t\t\tmtu = nla_get_u32(tbx[RTAX_MTU]);\n\t}\n\n\trc = mctp_route_add(mdev, daddr_start, rtm->rtm_dst_len, mtu,\n\t\t\t    rtm->rtm_type);\n\treturn rc;\n}\n\nstatic int mctp_delroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RTA_MAX + 1];\n\tmctp_eid_t daddr_start;\n\tstruct mctp_dev *mdev;\n\tstruct rtmsg *rtm;\n\tint rc;\n\n\trc = mctp_route_nlparse(skb, nlh, extack, tb,\n\t\t\t\t&rtm, &mdev, &daddr_start);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (rtm->rtm_type != RTN_UNICAST)\n\t\treturn -EINVAL;\n\n\trc = mctp_route_remove(mdev, daddr_start, rtm->rtm_dst_len, RTN_UNICAST);\n\treturn rc;\n}\n\nstatic int mctp_fill_rtinfo(struct sk_buff *skb, struct mctp_route *rt,\n\t\t\t    u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct rtmsg *hdr;\n\tvoid *metrics;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*hdr), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\thdr = nlmsg_data(nlh);\n\thdr->rtm_family = AF_MCTP;\n\n\t \n\thdr->rtm_dst_len = rt->max - rt->min;\n\thdr->rtm_src_len = 0;\n\thdr->rtm_tos = 0;\n\thdr->rtm_table = RT_TABLE_DEFAULT;\n\thdr->rtm_protocol = RTPROT_STATIC;  \n\thdr->rtm_scope = RT_SCOPE_LINK;  \n\thdr->rtm_type = rt->type;\n\n\tif (nla_put_u8(skb, RTA_DST, rt->min))\n\t\tgoto cancel;\n\n\tmetrics = nla_nest_start_noflag(skb, RTA_METRICS);\n\tif (!metrics)\n\t\tgoto cancel;\n\n\tif (rt->mtu) {\n\t\tif (nla_put_u32(skb, RTAX_MTU, rt->mtu))\n\t\t\tgoto cancel;\n\t}\n\n\tnla_nest_end(skb, metrics);\n\n\tif (rt->dev) {\n\t\tif (nla_put_u32(skb, RTA_OIF, rt->dev->dev->ifindex))\n\t\t\tgoto cancel;\n\t}\n\n\t \n\n\tnlmsg_end(skb, nlh);\n\n\treturn 0;\n\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int mctp_dump_rtinfo(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct mctp_route *rt;\n\tint s_idx, idx;\n\n\t \n\n\t \n\ts_idx = cb->args[0];\n\tidx = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(rt, &net->mctp.routes, list) {\n\t\tif (idx++ < s_idx)\n\t\t\tcontinue;\n\t\tif (mctp_fill_rtinfo(skb, rt,\n\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t     cb->nlh->nlmsg_seq,\n\t\t\t\t     RTM_NEWROUTE, NLM_F_MULTI) < 0)\n\t\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}\n\n \nstatic int __net_init mctp_routes_net_init(struct net *net)\n{\n\tstruct netns_mctp *ns = &net->mctp;\n\n\tINIT_LIST_HEAD(&ns->routes);\n\tINIT_HLIST_HEAD(&ns->binds);\n\tmutex_init(&ns->bind_lock);\n\tINIT_HLIST_HEAD(&ns->keys);\n\tspin_lock_init(&ns->keys_lock);\n\tWARN_ON(mctp_default_net_set(net, MCTP_INITIAL_DEFAULT_NET));\n\treturn 0;\n}\n\nstatic void __net_exit mctp_routes_net_exit(struct net *net)\n{\n\tstruct mctp_route *rt;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(rt, &net->mctp.routes, list)\n\t\tmctp_route_release(rt);\n\trcu_read_unlock();\n}\n\nstatic struct pernet_operations mctp_net_ops = {\n\t.init = mctp_routes_net_init,\n\t.exit = mctp_routes_net_exit,\n};\n\nint __init mctp_routes_init(void)\n{\n\tdev_add_pack(&mctp_packet_type);\n\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_GETROUTE,\n\t\t\t     NULL, mctp_dump_rtinfo, 0);\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_NEWROUTE,\n\t\t\t     mctp_newroute, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_DELROUTE,\n\t\t\t     mctp_delroute, NULL, 0);\n\n\treturn register_pernet_subsys(&mctp_net_ops);\n}\n\nvoid mctp_routes_exit(void)\n{\n\tunregister_pernet_subsys(&mctp_net_ops);\n\trtnl_unregister(PF_MCTP, RTM_DELROUTE);\n\trtnl_unregister(PF_MCTP, RTM_NEWROUTE);\n\trtnl_unregister(PF_MCTP, RTM_GETROUTE);\n\tdev_remove_pack(&mctp_packet_type);\n}\n\n#if IS_ENABLED(CONFIG_MCTP_TEST)\n#include \"test/route-test.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}