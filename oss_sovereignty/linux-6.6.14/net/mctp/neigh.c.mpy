{
  "module_name": "neigh.c",
  "hash_id": "d3abc514816b25a60c2dfb5db180b277aa35da58b26eea7cdd45e4005337509b",
  "original_prompt": "Ingested from linux-6.6.14/net/mctp/neigh.c",
  "human_readable_source": "\n \n\n#include <linux/idr.h>\n#include <linux/mctp.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n\n#include <net/mctp.h>\n#include <net/mctpdevice.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n\nstatic int mctp_neigh_add(struct mctp_dev *mdev, mctp_eid_t eid,\n\t\t\t  enum mctp_neigh_source source,\n\t\t\t  size_t lladdr_len, const void *lladdr)\n{\n\tstruct net *net = dev_net(mdev->dev);\n\tstruct mctp_neigh *neigh;\n\tint rc;\n\n\tmutex_lock(&net->mctp.neigh_lock);\n\tif (mctp_neigh_lookup(mdev, eid, NULL) == 0) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (lladdr_len > sizeof(neigh->ha)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tneigh = kzalloc(sizeof(*neigh), GFP_KERNEL);\n\tif (!neigh) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tINIT_LIST_HEAD(&neigh->list);\n\tneigh->dev = mdev;\n\tmctp_dev_hold(neigh->dev);\n\tneigh->eid = eid;\n\tneigh->source = source;\n\tmemcpy(neigh->ha, lladdr, lladdr_len);\n\n\tlist_add_rcu(&neigh->list, &net->mctp.neighbours);\n\trc = 0;\nout:\n\tmutex_unlock(&net->mctp.neigh_lock);\n\treturn rc;\n}\n\nstatic void __mctp_neigh_free(struct rcu_head *rcu)\n{\n\tstruct mctp_neigh *neigh = container_of(rcu, struct mctp_neigh, rcu);\n\n\tmctp_dev_put(neigh->dev);\n\tkfree(neigh);\n}\n\n \nvoid mctp_neigh_remove_dev(struct mctp_dev *mdev)\n{\n\tstruct net *net = dev_net(mdev->dev);\n\tstruct mctp_neigh *neigh, *tmp;\n\n\tmutex_lock(&net->mctp.neigh_lock);\n\tlist_for_each_entry_safe(neigh, tmp, &net->mctp.neighbours, list) {\n\t\tif (neigh->dev == mdev) {\n\t\t\tlist_del_rcu(&neigh->list);\n\t\t\t \n\t\t\tcall_rcu(&neigh->rcu, __mctp_neigh_free);\n\t\t}\n\t}\n\n\tmutex_unlock(&net->mctp.neigh_lock);\n}\n\nstatic int mctp_neigh_remove(struct mctp_dev *mdev, mctp_eid_t eid,\n\t\t\t     enum mctp_neigh_source source)\n{\n\tstruct net *net = dev_net(mdev->dev);\n\tstruct mctp_neigh *neigh, *tmp;\n\tbool dropped = false;\n\n\tmutex_lock(&net->mctp.neigh_lock);\n\tlist_for_each_entry_safe(neigh, tmp, &net->mctp.neighbours, list) {\n\t\tif (neigh->dev == mdev && neigh->eid == eid &&\n\t\t    neigh->source == source) {\n\t\t\tlist_del_rcu(&neigh->list);\n\t\t\t \n\t\t\tcall_rcu(&neigh->rcu, __mctp_neigh_free);\n\t\t\tdropped = true;\n\t\t}\n\t}\n\n\tmutex_unlock(&net->mctp.neigh_lock);\n\treturn dropped ? 0 : -ENOENT;\n}\n\nstatic const struct nla_policy nd_mctp_policy[NDA_MAX + 1] = {\n\t[NDA_DST]\t\t= { .type = NLA_U8 },\n\t[NDA_LLADDR]\t\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n};\n\nstatic int mctp_rtm_newneigh(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tstruct mctp_dev *mdev;\n\tstruct ndmsg *ndm;\n\tstruct nlattr *tb[NDA_MAX + 1];\n\tint rc;\n\tmctp_eid_t eid;\n\tvoid *lladdr;\n\tint lladdr_len;\n\n\trc = nlmsg_parse(nlh, sizeof(*ndm), tb, NDA_MAX, nd_mctp_policy,\n\t\t\t extack);\n\tif (rc < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"lladdr too large?\");\n\t\treturn rc;\n\t}\n\n\tif (!tb[NDA_DST]) {\n\t\tNL_SET_ERR_MSG(extack, \"Neighbour EID must be specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tb[NDA_LLADDR]) {\n\t\tNL_SET_ERR_MSG(extack, \"Neighbour lladdr must be specified\");\n\t\treturn -EINVAL;\n\t}\n\n\teid = nla_get_u8(tb[NDA_DST]);\n\tif (!mctp_address_unicast(eid)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid neighbour EID\");\n\t\treturn -EINVAL;\n\t}\n\n\tlladdr = nla_data(tb[NDA_LLADDR]);\n\tlladdr_len = nla_len(tb[NDA_LLADDR]);\n\n\tndm = nlmsg_data(nlh);\n\n\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (!mdev)\n\t\treturn -ENODEV;\n\n\tif (lladdr_len != dev->addr_len) {\n\t\tNL_SET_ERR_MSG(extack, \"Wrong lladdr length\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn mctp_neigh_add(mdev, eid, MCTP_NEIGH_STATIC,\n\t\t\tlladdr_len, lladdr);\n}\n\nstatic int mctp_rtm_delneigh(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[NDA_MAX + 1];\n\tstruct net_device *dev;\n\tstruct mctp_dev *mdev;\n\tstruct ndmsg *ndm;\n\tint rc;\n\tmctp_eid_t eid;\n\n\trc = nlmsg_parse(nlh, sizeof(*ndm), tb, NDA_MAX, nd_mctp_policy,\n\t\t\t extack);\n\tif (rc < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"incorrect format\");\n\t\treturn rc;\n\t}\n\n\tif (!tb[NDA_DST]) {\n\t\tNL_SET_ERR_MSG(extack, \"Neighbour EID must be specified\");\n\t\treturn -EINVAL;\n\t}\n\teid = nla_get_u8(tb[NDA_DST]);\n\n\tndm = nlmsg_data(nlh);\n\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (!mdev)\n\t\treturn -ENODEV;\n\n\treturn mctp_neigh_remove(mdev, eid, MCTP_NEIGH_STATIC);\n}\n\nstatic int mctp_fill_neigh(struct sk_buff *skb, u32 portid, u32 seq, int event,\n\t\t\t   unsigned int flags, struct mctp_neigh *neigh)\n{\n\tstruct net_device *dev = neigh->dev->dev;\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *hdr;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*hdr), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\thdr = nlmsg_data(nlh);\n\thdr->ndm_family = AF_MCTP;\n\thdr->ndm_ifindex = dev->ifindex;\n\thdr->ndm_state = 0; \n\tif (neigh->source == MCTP_NEIGH_STATIC)\n\t\thdr->ndm_state |= NUD_PERMANENT;\n\thdr->ndm_flags = 0;\n\thdr->ndm_type = RTN_UNICAST; \n\n\tif (nla_put_u8(skb, NDA_DST, neigh->eid))\n\t\tgoto cancel;\n\n\tif (nla_put(skb, NDA_LLADDR, dev->addr_len, neigh->ha))\n\t\tgoto cancel;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn 0;\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int mctp_rtm_getneigh(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint rc, idx, req_ifindex;\n\tstruct mctp_neigh *neigh;\n\tstruct ndmsg *ndmsg;\n\tstruct {\n\t\tint idx;\n\t} *cbctx = (void *)cb->ctx;\n\n\tndmsg = nlmsg_data(cb->nlh);\n\treq_ifindex = ndmsg->ndm_ifindex;\n\n\tidx = 0;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(neigh, &net->mctp.neighbours, list) {\n\t\tif (idx < cbctx->idx)\n\t\t\tgoto cont;\n\n\t\trc = 0;\n\t\tif (req_ifindex == 0 || req_ifindex == neigh->dev->dev->ifindex)\n\t\t\trc = mctp_fill_neigh(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t     cb->nlh->nlmsg_seq,\n\t\t\t\t\t     RTM_NEWNEIGH, NLM_F_MULTI, neigh);\n\n\t\tif (rc)\n\t\t\tbreak;\ncont:\n\t\tidx++;\n\t}\n\trcu_read_unlock();\n\n\tcbctx->idx = idx;\n\treturn skb->len;\n}\n\nint mctp_neigh_lookup(struct mctp_dev *mdev, mctp_eid_t eid, void *ret_hwaddr)\n{\n\tstruct net *net = dev_net(mdev->dev);\n\tstruct mctp_neigh *neigh;\n\tint rc = -EHOSTUNREACH; \n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(neigh, &net->mctp.neighbours, list) {\n\t\tif (mdev == neigh->dev && eid == neigh->eid) {\n\t\t\tif (ret_hwaddr)\n\t\t\t\tmemcpy(ret_hwaddr, neigh->ha,\n\t\t\t\t       sizeof(neigh->ha));\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn rc;\n}\n\n \nstatic int __net_init mctp_neigh_net_init(struct net *net)\n{\n\tstruct netns_mctp *ns = &net->mctp;\n\n\tINIT_LIST_HEAD(&ns->neighbours);\n\tmutex_init(&ns->neigh_lock);\n\treturn 0;\n}\n\nstatic void __net_exit mctp_neigh_net_exit(struct net *net)\n{\n\tstruct netns_mctp *ns = &net->mctp;\n\tstruct mctp_neigh *neigh;\n\n\tlist_for_each_entry(neigh, &ns->neighbours, list)\n\t\tcall_rcu(&neigh->rcu, __mctp_neigh_free);\n}\n\n \n\nstatic struct pernet_operations mctp_net_ops = {\n\t.init = mctp_neigh_net_init,\n\t.exit = mctp_neigh_net_exit,\n};\n\nint __init mctp_neigh_init(void)\n{\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_NEWNEIGH,\n\t\t\t     mctp_rtm_newneigh, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_DELNEIGH,\n\t\t\t     mctp_rtm_delneigh, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_GETNEIGH,\n\t\t\t     NULL, mctp_rtm_getneigh, 0);\n\n\treturn register_pernet_subsys(&mctp_net_ops);\n}\n\nvoid __exit mctp_neigh_exit(void)\n{\n\tunregister_pernet_subsys(&mctp_net_ops);\n\trtnl_unregister(PF_MCTP, RTM_GETNEIGH);\n\trtnl_unregister(PF_MCTP, RTM_DELNEIGH);\n\trtnl_unregister(PF_MCTP, RTM_NEWNEIGH);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}