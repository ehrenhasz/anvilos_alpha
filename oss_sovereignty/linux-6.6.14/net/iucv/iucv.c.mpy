{
  "module_name": "iucv.c",
  "hash_id": "9bdab776230eae42f06b1532e6f7c56657a4e7d1a49ccf8c2570a9cc65dc055e",
  "original_prompt": "Ingested from linux-6.6.14/net/iucv/iucv.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"iucv\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kernel_stat.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/cpu.h>\n#include <linux/reboot.h>\n#include <net/iucv/iucv.h>\n#include <linux/atomic.h>\n#include <asm/ebcdic.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/smp.h>\n\n \n#define IUCV_IPSRCCLS\t0x01\n#define IUCV_IPTRGCLS\t0x01\n#define IUCV_IPFGPID\t0x02\n#define IUCV_IPFGMID\t0x04\n#define IUCV_IPNORPY\t0x10\n#define IUCV_IPALL\t0x80\n\nstatic int iucv_bus_match(struct device *dev, struct device_driver *drv)\n{\n\treturn 0;\n}\n\nstruct bus_type iucv_bus = {\n\t.name = \"iucv\",\n\t.match = iucv_bus_match,\n};\nEXPORT_SYMBOL(iucv_bus);\n\nstruct device *iucv_root;\nEXPORT_SYMBOL(iucv_root);\n\nstatic int iucv_available;\n\n \nstruct iucv_irq_data {\n\tu16 ippathid;\n\tu8  ipflags1;\n\tu8  iptype;\n\tu32 res2[9];\n};\n\nstruct iucv_irq_list {\n\tstruct list_head list;\n\tstruct iucv_irq_data data;\n};\n\nstatic struct iucv_irq_data *iucv_irq_data[NR_CPUS];\nstatic cpumask_t iucv_buffer_cpumask = { CPU_BITS_NONE };\nstatic cpumask_t iucv_irq_cpumask = { CPU_BITS_NONE };\n\n \nstatic LIST_HEAD(iucv_task_queue);\n\n \nstatic void iucv_tasklet_fn(unsigned long);\nstatic DECLARE_TASKLET_OLD(iucv_tasklet, iucv_tasklet_fn);\n\n \nstatic LIST_HEAD(iucv_work_queue);\n\n \nstatic void iucv_work_fn(struct work_struct *work);\nstatic DECLARE_WORK(iucv_work, iucv_work_fn);\n\n \nstatic DEFINE_SPINLOCK(iucv_queue_lock);\n\nenum iucv_command_codes {\n\tIUCV_QUERY = 0,\n\tIUCV_RETRIEVE_BUFFER = 2,\n\tIUCV_SEND = 4,\n\tIUCV_RECEIVE = 5,\n\tIUCV_REPLY = 6,\n\tIUCV_REJECT = 8,\n\tIUCV_PURGE = 9,\n\tIUCV_ACCEPT = 10,\n\tIUCV_CONNECT = 11,\n\tIUCV_DECLARE_BUFFER = 12,\n\tIUCV_QUIESCE = 13,\n\tIUCV_RESUME = 14,\n\tIUCV_SEVER = 15,\n\tIUCV_SETMASK = 16,\n\tIUCV_SETCONTROLMASK = 17,\n};\n\n \nstatic char iucv_error_no_listener[16] = \"NO LISTENER\";\nstatic char iucv_error_no_memory[16] = \"NO MEMORY\";\nstatic char iucv_error_pathid[16] = \"INVALID PATHID\";\n\n \nstatic LIST_HEAD(iucv_handler_list);\n\n \nstatic struct iucv_path **iucv_path_table;\nstatic unsigned long iucv_max_pathid;\n\n \nstatic DEFINE_SPINLOCK(iucv_table_lock);\n\n \nstatic int iucv_active_cpu = -1;\n\n \nstatic DEFINE_MUTEX(iucv_register_mutex);\n\n \nstatic int iucv_nonsmp_handler;\n\n \nstruct iucv_cmd_control {\n\tu16 ippathid;\n\tu8  ipflags1;\n\tu8  iprcode;\n\tu16 ipmsglim;\n\tu16 res1;\n\tu8  ipvmid[8];\n\tu8  ipuser[16];\n\tu8  iptarget[8];\n} __attribute__ ((packed,aligned(8)));\n\n \nstruct iucv_cmd_dpl {\n\tu16 ippathid;\n\tu8  ipflags1;\n\tu8  iprcode;\n\tu32 ipmsgid;\n\tu32 iptrgcls;\n\tu8  iprmmsg[8];\n\tu32 ipsrccls;\n\tu32 ipmsgtag;\n\tu32 ipbfadr2;\n\tu32 ipbfln2f;\n\tu32 res;\n} __attribute__ ((packed,aligned(8)));\n\n \nstruct iucv_cmd_db {\n\tu16 ippathid;\n\tu8  ipflags1;\n\tu8  iprcode;\n\tu32 ipmsgid;\n\tu32 iptrgcls;\n\tu32 ipbfadr1;\n\tu32 ipbfln1f;\n\tu32 ipsrccls;\n\tu32 ipmsgtag;\n\tu32 ipbfadr2;\n\tu32 ipbfln2f;\n\tu32 res;\n} __attribute__ ((packed,aligned(8)));\n\n \nstruct iucv_cmd_purge {\n\tu16 ippathid;\n\tu8  ipflags1;\n\tu8  iprcode;\n\tu32 ipmsgid;\n\tu8  ipaudit[3];\n\tu8  res1[5];\n\tu32 res2;\n\tu32 ipsrccls;\n\tu32 ipmsgtag;\n\tu32 res3[3];\n} __attribute__ ((packed,aligned(8)));\n\n \nstruct iucv_cmd_set_mask {\n\tu8  ipmask;\n\tu8  res1[2];\n\tu8  iprcode;\n\tu32 res2[9];\n} __attribute__ ((packed,aligned(8)));\n\nunion iucv_param {\n\tstruct iucv_cmd_control ctrl;\n\tstruct iucv_cmd_dpl dpl;\n\tstruct iucv_cmd_db db;\n\tstruct iucv_cmd_purge purge;\n\tstruct iucv_cmd_set_mask set_mask;\n};\n\n \nstatic union iucv_param *iucv_param[NR_CPUS];\nstatic union iucv_param *iucv_param_irq[NR_CPUS];\n\n \nstatic inline int __iucv_call_b2f0(int command, union iucv_param *parm)\n{\n\tint cc;\n\n\tasm volatile(\n\t\t\"\tlgr\t0,%[reg0]\\n\"\n\t\t\"\tlgr\t1,%[reg1]\\n\"\n\t\t\"\t.long\t0xb2f01000\\n\"\n\t\t\"\tipm\t%[cc]\\n\"\n\t\t\"\tsrl\t%[cc],28\\n\"\n\t\t: [cc] \"=&d\" (cc), \"+m\" (*parm)\n\t\t: [reg0] \"d\" ((unsigned long)command),\n\t\t  [reg1] \"d\" ((unsigned long)parm)\n\t\t: \"cc\", \"0\", \"1\");\n\treturn cc;\n}\n\nstatic inline int iucv_call_b2f0(int command, union iucv_param *parm)\n{\n\tint ccode;\n\n\tccode = __iucv_call_b2f0(command, parm);\n\treturn ccode == 1 ? parm->ctrl.iprcode : ccode;\n}\n\n \nstatic int __iucv_query_maxconn(void *param, unsigned long *max_pathid)\n{\n\tunsigned long reg1 = virt_to_phys(param);\n\tint cc;\n\n\tasm volatile (\n\t\t\"\tlghi\t0,%[cmd]\\n\"\n\t\t\"\tlgr\t1,%[reg1]\\n\"\n\t\t\"\t.long\t0xb2f01000\\n\"\n\t\t\"\tipm\t%[cc]\\n\"\n\t\t\"\tsrl\t%[cc],28\\n\"\n\t\t\"\tlgr\t%[reg1],1\\n\"\n\t\t: [cc] \"=&d\" (cc), [reg1] \"+&d\" (reg1)\n\t\t: [cmd] \"K\" (IUCV_QUERY)\n\t\t: \"cc\", \"0\", \"1\");\n\t*max_pathid = reg1;\n\treturn cc;\n}\n\nstatic int iucv_query_maxconn(void)\n{\n\tunsigned long max_pathid;\n\tvoid *param;\n\tint ccode;\n\n\tparam = kzalloc(sizeof(union iucv_param), GFP_KERNEL | GFP_DMA);\n\tif (!param)\n\t\treturn -ENOMEM;\n\tccode = __iucv_query_maxconn(param, &max_pathid);\n\tif (ccode == 0)\n\t\tiucv_max_pathid = max_pathid;\n\tkfree(param);\n\treturn ccode ? -EPERM : 0;\n}\n\n \nstatic void iucv_allow_cpu(void *data)\n{\n\tint cpu = smp_processor_id();\n\tunion iucv_param *parm;\n\n\t \n\tparm = iucv_param_irq[cpu];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tparm->set_mask.ipmask = 0xf8;\n\tiucv_call_b2f0(IUCV_SETMASK, parm);\n\n\t \n\tmemset(parm, 0, sizeof(union iucv_param));\n\tparm->set_mask.ipmask = 0xf8;\n\tiucv_call_b2f0(IUCV_SETCONTROLMASK, parm);\n\t \n\tcpumask_set_cpu(cpu, &iucv_irq_cpumask);\n}\n\n \nstatic void iucv_block_cpu(void *data)\n{\n\tint cpu = smp_processor_id();\n\tunion iucv_param *parm;\n\n\t \n\tparm = iucv_param_irq[cpu];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tiucv_call_b2f0(IUCV_SETMASK, parm);\n\n\t \n\tcpumask_clear_cpu(cpu, &iucv_irq_cpumask);\n}\n\n \nstatic void iucv_declare_cpu(void *data)\n{\n\tint cpu = smp_processor_id();\n\tunion iucv_param *parm;\n\tint rc;\n\n\tif (cpumask_test_cpu(cpu, &iucv_buffer_cpumask))\n\t\treturn;\n\n\t \n\tparm = iucv_param_irq[cpu];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tparm->db.ipbfadr1 = virt_to_phys(iucv_irq_data[cpu]);\n\trc = iucv_call_b2f0(IUCV_DECLARE_BUFFER, parm);\n\tif (rc) {\n\t\tchar *err = \"Unknown\";\n\t\tswitch (rc) {\n\t\tcase 0x03:\n\t\t\terr = \"Directory error\";\n\t\t\tbreak;\n\t\tcase 0x0a:\n\t\t\terr = \"Invalid length\";\n\t\t\tbreak;\n\t\tcase 0x13:\n\t\t\terr = \"Buffer already exists\";\n\t\t\tbreak;\n\t\tcase 0x3e:\n\t\t\terr = \"Buffer overlap\";\n\t\t\tbreak;\n\t\tcase 0x5c:\n\t\t\terr = \"Paging or storage error\";\n\t\t\tbreak;\n\t\t}\n\t\tpr_warn(\"Defining an interrupt buffer on CPU %i failed with 0x%02x (%s)\\n\",\n\t\t\tcpu, rc, err);\n\t\treturn;\n\t}\n\n\t \n\tcpumask_set_cpu(cpu, &iucv_buffer_cpumask);\n\n\tif (iucv_nonsmp_handler == 0 || cpumask_empty(&iucv_irq_cpumask))\n\t\t \n\t\tiucv_allow_cpu(NULL);\n\telse\n\t\t \n\t\tiucv_block_cpu(NULL);\n}\n\n \nstatic void iucv_retrieve_cpu(void *data)\n{\n\tint cpu = smp_processor_id();\n\tunion iucv_param *parm;\n\n\tif (!cpumask_test_cpu(cpu, &iucv_buffer_cpumask))\n\t\treturn;\n\n\t \n\tiucv_block_cpu(NULL);\n\n\t \n\tparm = iucv_param_irq[cpu];\n\tiucv_call_b2f0(IUCV_RETRIEVE_BUFFER, parm);\n\n\t \n\tcpumask_clear_cpu(cpu, &iucv_buffer_cpumask);\n}\n\n \nstatic void iucv_setmask_mp(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu)\n\t\t \n\t\tif (cpumask_test_cpu(cpu, &iucv_buffer_cpumask) &&\n\t\t    !cpumask_test_cpu(cpu, &iucv_irq_cpumask))\n\t\t\tsmp_call_function_single(cpu, iucv_allow_cpu,\n\t\t\t\t\t\t NULL, 1);\n\tcpus_read_unlock();\n}\n\n \nstatic void iucv_setmask_up(void)\n{\n\tcpumask_t cpumask;\n\tint cpu;\n\n\t \n\tcpumask_copy(&cpumask, &iucv_irq_cpumask);\n\tcpumask_clear_cpu(cpumask_first(&iucv_irq_cpumask), &cpumask);\n\tfor_each_cpu(cpu, &cpumask)\n\t\tsmp_call_function_single(cpu, iucv_block_cpu, NULL, 1);\n}\n\n \nstatic int iucv_enable(void)\n{\n\tsize_t alloc_size;\n\tint cpu, rc;\n\n\tcpus_read_lock();\n\trc = -ENOMEM;\n\talloc_size = iucv_max_pathid * sizeof(struct iucv_path);\n\tiucv_path_table = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!iucv_path_table)\n\t\tgoto out;\n\t \n\trc = -EIO;\n\tfor_each_online_cpu(cpu)\n\t\tsmp_call_function_single(cpu, iucv_declare_cpu, NULL, 1);\n\tif (cpumask_empty(&iucv_buffer_cpumask))\n\t\t \n\t\tgoto out;\n\tcpus_read_unlock();\n\treturn 0;\nout:\n\tkfree(iucv_path_table);\n\tiucv_path_table = NULL;\n\tcpus_read_unlock();\n\treturn rc;\n}\n\n \nstatic void iucv_disable(void)\n{\n\tcpus_read_lock();\n\ton_each_cpu(iucv_retrieve_cpu, NULL, 1);\n\tkfree(iucv_path_table);\n\tiucv_path_table = NULL;\n\tcpus_read_unlock();\n}\n\nstatic int iucv_cpu_dead(unsigned int cpu)\n{\n\tkfree(iucv_param_irq[cpu]);\n\tiucv_param_irq[cpu] = NULL;\n\tkfree(iucv_param[cpu]);\n\tiucv_param[cpu] = NULL;\n\tkfree(iucv_irq_data[cpu]);\n\tiucv_irq_data[cpu] = NULL;\n\treturn 0;\n}\n\nstatic int iucv_cpu_prepare(unsigned int cpu)\n{\n\t \n\tiucv_irq_data[cpu] = kmalloc_node(sizeof(struct iucv_irq_data),\n\t\t\t     GFP_KERNEL|GFP_DMA, cpu_to_node(cpu));\n\tif (!iucv_irq_data[cpu])\n\t\tgoto out_free;\n\n\t \n\tiucv_param[cpu] = kmalloc_node(sizeof(union iucv_param),\n\t\t\t  GFP_KERNEL|GFP_DMA, cpu_to_node(cpu));\n\tif (!iucv_param[cpu])\n\t\tgoto out_free;\n\n\tiucv_param_irq[cpu] = kmalloc_node(sizeof(union iucv_param),\n\t\t\t  GFP_KERNEL|GFP_DMA, cpu_to_node(cpu));\n\tif (!iucv_param_irq[cpu])\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_free:\n\tiucv_cpu_dead(cpu);\n\treturn -ENOMEM;\n}\n\nstatic int iucv_cpu_online(unsigned int cpu)\n{\n\tif (!iucv_path_table)\n\t\treturn 0;\n\tiucv_declare_cpu(NULL);\n\treturn 0;\n}\n\nstatic int iucv_cpu_down_prep(unsigned int cpu)\n{\n\tcpumask_t cpumask;\n\n\tif (!iucv_path_table)\n\t\treturn 0;\n\n\tcpumask_copy(&cpumask, &iucv_buffer_cpumask);\n\tcpumask_clear_cpu(cpu, &cpumask);\n\tif (cpumask_empty(&cpumask))\n\t\t \n\t\treturn -EINVAL;\n\n\tiucv_retrieve_cpu(NULL);\n\tif (!cpumask_empty(&iucv_irq_cpumask))\n\t\treturn 0;\n\tsmp_call_function_single(cpumask_first(&iucv_buffer_cpumask),\n\t\t\t\t iucv_allow_cpu, NULL, 1);\n\treturn 0;\n}\n\n \nstatic int iucv_sever_pathid(u16 pathid, u8 *userdata)\n{\n\tunion iucv_param *parm;\n\n\tparm = iucv_param_irq[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tif (userdata)\n\t\tmemcpy(parm->ctrl.ipuser, userdata, sizeof(parm->ctrl.ipuser));\n\tparm->ctrl.ippathid = pathid;\n\treturn iucv_call_b2f0(IUCV_SEVER, parm);\n}\n\n \nstatic void __iucv_cleanup_queue(void *dummy)\n{\n}\n\n \nstatic void iucv_cleanup_queue(void)\n{\n\tstruct iucv_irq_list *p, *n;\n\n\t \n\tsmp_call_function(__iucv_cleanup_queue, NULL, 1);\n\tspin_lock_irq(&iucv_queue_lock);\n\tlist_for_each_entry_safe(p, n, &iucv_task_queue, list) {\n\t\t \n\t\tif (iucv_path_table[p->data.ippathid] == NULL) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t}\n\t}\n\tspin_unlock_irq(&iucv_queue_lock);\n}\n\n \nint iucv_register(struct iucv_handler *handler, int smp)\n{\n\tint rc;\n\n\tif (!iucv_available)\n\t\treturn -ENOSYS;\n\tmutex_lock(&iucv_register_mutex);\n\tif (!smp)\n\t\tiucv_nonsmp_handler++;\n\tif (list_empty(&iucv_handler_list)) {\n\t\trc = iucv_enable();\n\t\tif (rc)\n\t\t\tgoto out_mutex;\n\t} else if (!smp && iucv_nonsmp_handler == 1)\n\t\tiucv_setmask_up();\n\tINIT_LIST_HEAD(&handler->paths);\n\n\tspin_lock_bh(&iucv_table_lock);\n\tlist_add_tail(&handler->list, &iucv_handler_list);\n\tspin_unlock_bh(&iucv_table_lock);\n\trc = 0;\nout_mutex:\n\tmutex_unlock(&iucv_register_mutex);\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_register);\n\n \nvoid iucv_unregister(struct iucv_handler *handler, int smp)\n{\n\tstruct iucv_path *p, *n;\n\n\tmutex_lock(&iucv_register_mutex);\n\tspin_lock_bh(&iucv_table_lock);\n\t \n\tlist_del_init(&handler->list);\n\t \n\tlist_for_each_entry_safe(p, n, &handler->paths, list) {\n\t\tiucv_sever_pathid(p->pathid, NULL);\n\t\tiucv_path_table[p->pathid] = NULL;\n\t\tlist_del(&p->list);\n\t\tiucv_path_free(p);\n\t}\n\tspin_unlock_bh(&iucv_table_lock);\n\tif (!smp)\n\t\tiucv_nonsmp_handler--;\n\tif (list_empty(&iucv_handler_list))\n\t\tiucv_disable();\n\telse if (!smp && iucv_nonsmp_handler == 0)\n\t\tiucv_setmask_mp();\n\tmutex_unlock(&iucv_register_mutex);\n}\nEXPORT_SYMBOL(iucv_unregister);\n\nstatic int iucv_reboot_event(struct notifier_block *this,\n\t\t\t     unsigned long event, void *ptr)\n{\n\tint i;\n\n\tif (cpumask_empty(&iucv_irq_cpumask))\n\t\treturn NOTIFY_DONE;\n\n\tcpus_read_lock();\n\ton_each_cpu_mask(&iucv_irq_cpumask, iucv_block_cpu, NULL, 1);\n\tpreempt_disable();\n\tfor (i = 0; i < iucv_max_pathid; i++) {\n\t\tif (iucv_path_table[i])\n\t\t\tiucv_sever_pathid(i, NULL);\n\t}\n\tpreempt_enable();\n\tcpus_read_unlock();\n\tiucv_disable();\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block iucv_reboot_notifier = {\n\t.notifier_call = iucv_reboot_event,\n};\n\n \nint iucv_path_accept(struct iucv_path *path, struct iucv_handler *handler,\n\t\t     u8 *userdata, void *private)\n{\n\tunion iucv_param *parm;\n\tint rc;\n\n\tlocal_bh_disable();\n\tif (cpumask_empty(&iucv_buffer_cpumask)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\t \n\tparm = iucv_param[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tparm->ctrl.ippathid = path->pathid;\n\tparm->ctrl.ipmsglim = path->msglim;\n\tif (userdata)\n\t\tmemcpy(parm->ctrl.ipuser, userdata, sizeof(parm->ctrl.ipuser));\n\tparm->ctrl.ipflags1 = path->flags;\n\n\trc = iucv_call_b2f0(IUCV_ACCEPT, parm);\n\tif (!rc) {\n\t\tpath->private = private;\n\t\tpath->msglim = parm->ctrl.ipmsglim;\n\t\tpath->flags = parm->ctrl.ipflags1;\n\t}\nout:\n\tlocal_bh_enable();\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_path_accept);\n\n \nint iucv_path_connect(struct iucv_path *path, struct iucv_handler *handler,\n\t\t      u8 *userid, u8 *system, u8 *userdata,\n\t\t      void *private)\n{\n\tunion iucv_param *parm;\n\tint rc;\n\n\tspin_lock_bh(&iucv_table_lock);\n\tiucv_cleanup_queue();\n\tif (cpumask_empty(&iucv_buffer_cpumask)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tparm = iucv_param[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tparm->ctrl.ipmsglim = path->msglim;\n\tparm->ctrl.ipflags1 = path->flags;\n\tif (userid) {\n\t\tmemcpy(parm->ctrl.ipvmid, userid, sizeof(parm->ctrl.ipvmid));\n\t\tASCEBC(parm->ctrl.ipvmid, sizeof(parm->ctrl.ipvmid));\n\t\tEBC_TOUPPER(parm->ctrl.ipvmid, sizeof(parm->ctrl.ipvmid));\n\t}\n\tif (system) {\n\t\tmemcpy(parm->ctrl.iptarget, system,\n\t\t       sizeof(parm->ctrl.iptarget));\n\t\tASCEBC(parm->ctrl.iptarget, sizeof(parm->ctrl.iptarget));\n\t\tEBC_TOUPPER(parm->ctrl.iptarget, sizeof(parm->ctrl.iptarget));\n\t}\n\tif (userdata)\n\t\tmemcpy(parm->ctrl.ipuser, userdata, sizeof(parm->ctrl.ipuser));\n\n\trc = iucv_call_b2f0(IUCV_CONNECT, parm);\n\tif (!rc) {\n\t\tif (parm->ctrl.ippathid < iucv_max_pathid) {\n\t\t\tpath->pathid = parm->ctrl.ippathid;\n\t\t\tpath->msglim = parm->ctrl.ipmsglim;\n\t\t\tpath->flags = parm->ctrl.ipflags1;\n\t\t\tpath->handler = handler;\n\t\t\tpath->private = private;\n\t\t\tlist_add_tail(&path->list, &handler->paths);\n\t\t\tiucv_path_table[path->pathid] = path;\n\t\t} else {\n\t\t\tiucv_sever_pathid(parm->ctrl.ippathid,\n\t\t\t\t\t  iucv_error_pathid);\n\t\t\trc = -EIO;\n\t\t}\n\t}\nout:\n\tspin_unlock_bh(&iucv_table_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_path_connect);\n\n \nint iucv_path_quiesce(struct iucv_path *path, u8 *userdata)\n{\n\tunion iucv_param *parm;\n\tint rc;\n\n\tlocal_bh_disable();\n\tif (cpumask_empty(&iucv_buffer_cpumask)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tparm = iucv_param[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tif (userdata)\n\t\tmemcpy(parm->ctrl.ipuser, userdata, sizeof(parm->ctrl.ipuser));\n\tparm->ctrl.ippathid = path->pathid;\n\trc = iucv_call_b2f0(IUCV_QUIESCE, parm);\nout:\n\tlocal_bh_enable();\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_path_quiesce);\n\n \nint iucv_path_resume(struct iucv_path *path, u8 *userdata)\n{\n\tunion iucv_param *parm;\n\tint rc;\n\n\tlocal_bh_disable();\n\tif (cpumask_empty(&iucv_buffer_cpumask)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tparm = iucv_param[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tif (userdata)\n\t\tmemcpy(parm->ctrl.ipuser, userdata, sizeof(parm->ctrl.ipuser));\n\tparm->ctrl.ippathid = path->pathid;\n\trc = iucv_call_b2f0(IUCV_RESUME, parm);\nout:\n\tlocal_bh_enable();\n\treturn rc;\n}\n\n \nint iucv_path_sever(struct iucv_path *path, u8 *userdata)\n{\n\tint rc;\n\n\tpreempt_disable();\n\tif (cpumask_empty(&iucv_buffer_cpumask)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (iucv_active_cpu != smp_processor_id())\n\t\tspin_lock_bh(&iucv_table_lock);\n\trc = iucv_sever_pathid(path->pathid, userdata);\n\tiucv_path_table[path->pathid] = NULL;\n\tlist_del_init(&path->list);\n\tif (iucv_active_cpu != smp_processor_id())\n\t\tspin_unlock_bh(&iucv_table_lock);\nout:\n\tpreempt_enable();\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_path_sever);\n\n \nint iucv_message_purge(struct iucv_path *path, struct iucv_message *msg,\n\t\t       u32 srccls)\n{\n\tunion iucv_param *parm;\n\tint rc;\n\n\tlocal_bh_disable();\n\tif (cpumask_empty(&iucv_buffer_cpumask)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tparm = iucv_param[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tparm->purge.ippathid = path->pathid;\n\tparm->purge.ipmsgid = msg->id;\n\tparm->purge.ipsrccls = srccls;\n\tparm->purge.ipflags1 = IUCV_IPSRCCLS | IUCV_IPFGMID | IUCV_IPFGPID;\n\trc = iucv_call_b2f0(IUCV_PURGE, parm);\n\tif (!rc) {\n\t\tmsg->audit = (*(u32 *) &parm->purge.ipaudit) >> 8;\n\t\tmsg->tag = parm->purge.ipmsgtag;\n\t}\nout:\n\tlocal_bh_enable();\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_message_purge);\n\n \nstatic int iucv_message_receive_iprmdata(struct iucv_path *path,\n\t\t\t\t\t struct iucv_message *msg,\n\t\t\t\t\t u8 flags, void *buffer,\n\t\t\t\t\t size_t size, size_t *residual)\n{\n\tstruct iucv_array *array;\n\tu8 *rmmsg;\n\tsize_t copy;\n\n\t \n\tif (residual)\n\t\t*residual = abs(size - 8);\n\trmmsg = msg->rmmsg;\n\tif (flags & IUCV_IPBUFLST) {\n\t\t \n\t\tsize = (size < 8) ? size : 8;\n\t\tfor (array = buffer; size > 0; array++) {\n\t\t\tcopy = min_t(size_t, size, array->length);\n\t\t\tmemcpy((u8 *)(addr_t) array->address,\n\t\t\t\trmmsg, copy);\n\t\t\trmmsg += copy;\n\t\t\tsize -= copy;\n\t\t}\n\t} else {\n\t\t \n\t\tmemcpy(buffer, rmmsg, min_t(size_t, size, 8));\n\t}\n\treturn 0;\n}\n\n \nint __iucv_message_receive(struct iucv_path *path, struct iucv_message *msg,\n\t\t\t   u8 flags, void *buffer, size_t size, size_t *residual)\n{\n\tunion iucv_param *parm;\n\tint rc;\n\n\tif (msg->flags & IUCV_IPRMDATA)\n\t\treturn iucv_message_receive_iprmdata(path, msg, flags,\n\t\t\t\t\t\t     buffer, size, residual);\n\tif (cpumask_empty(&iucv_buffer_cpumask))\n\t\treturn -EIO;\n\n\tparm = iucv_param[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tparm->db.ipbfadr1 = (u32)(addr_t) buffer;\n\tparm->db.ipbfln1f = (u32) size;\n\tparm->db.ipmsgid = msg->id;\n\tparm->db.ippathid = path->pathid;\n\tparm->db.iptrgcls = msg->class;\n\tparm->db.ipflags1 = (flags | IUCV_IPFGPID |\n\t\t\t     IUCV_IPFGMID | IUCV_IPTRGCLS);\n\trc = iucv_call_b2f0(IUCV_RECEIVE, parm);\n\tif (!rc || rc == 5) {\n\t\tmsg->flags = parm->db.ipflags1;\n\t\tif (residual)\n\t\t\t*residual = parm->db.ipbfln1f;\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL(__iucv_message_receive);\n\n \nint iucv_message_receive(struct iucv_path *path, struct iucv_message *msg,\n\t\t\t u8 flags, void *buffer, size_t size, size_t *residual)\n{\n\tint rc;\n\n\tif (msg->flags & IUCV_IPRMDATA)\n\t\treturn iucv_message_receive_iprmdata(path, msg, flags,\n\t\t\t\t\t\t     buffer, size, residual);\n\tlocal_bh_disable();\n\trc = __iucv_message_receive(path, msg, flags, buffer, size, residual);\n\tlocal_bh_enable();\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_message_receive);\n\n \nint iucv_message_reject(struct iucv_path *path, struct iucv_message *msg)\n{\n\tunion iucv_param *parm;\n\tint rc;\n\n\tlocal_bh_disable();\n\tif (cpumask_empty(&iucv_buffer_cpumask)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tparm = iucv_param[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tparm->db.ippathid = path->pathid;\n\tparm->db.ipmsgid = msg->id;\n\tparm->db.iptrgcls = msg->class;\n\tparm->db.ipflags1 = (IUCV_IPTRGCLS | IUCV_IPFGMID | IUCV_IPFGPID);\n\trc = iucv_call_b2f0(IUCV_REJECT, parm);\nout:\n\tlocal_bh_enable();\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_message_reject);\n\n \nint iucv_message_reply(struct iucv_path *path, struct iucv_message *msg,\n\t\t       u8 flags, void *reply, size_t size)\n{\n\tunion iucv_param *parm;\n\tint rc;\n\n\tlocal_bh_disable();\n\tif (cpumask_empty(&iucv_buffer_cpumask)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tparm = iucv_param[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tif (flags & IUCV_IPRMDATA) {\n\t\tparm->dpl.ippathid = path->pathid;\n\t\tparm->dpl.ipflags1 = flags;\n\t\tparm->dpl.ipmsgid = msg->id;\n\t\tparm->dpl.iptrgcls = msg->class;\n\t\tmemcpy(parm->dpl.iprmmsg, reply, min_t(size_t, size, 8));\n\t} else {\n\t\tparm->db.ipbfadr1 = (u32)(addr_t) reply;\n\t\tparm->db.ipbfln1f = (u32) size;\n\t\tparm->db.ippathid = path->pathid;\n\t\tparm->db.ipflags1 = flags;\n\t\tparm->db.ipmsgid = msg->id;\n\t\tparm->db.iptrgcls = msg->class;\n\t}\n\trc = iucv_call_b2f0(IUCV_REPLY, parm);\nout:\n\tlocal_bh_enable();\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_message_reply);\n\n \nint __iucv_message_send(struct iucv_path *path, struct iucv_message *msg,\n\t\t      u8 flags, u32 srccls, void *buffer, size_t size)\n{\n\tunion iucv_param *parm;\n\tint rc;\n\n\tif (cpumask_empty(&iucv_buffer_cpumask)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tparm = iucv_param[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tif (flags & IUCV_IPRMDATA) {\n\t\t \n\t\tparm->dpl.ippathid = path->pathid;\n\t\tparm->dpl.ipflags1 = flags | IUCV_IPNORPY;\n\t\tparm->dpl.iptrgcls = msg->class;\n\t\tparm->dpl.ipsrccls = srccls;\n\t\tparm->dpl.ipmsgtag = msg->tag;\n\t\tmemcpy(parm->dpl.iprmmsg, buffer, 8);\n\t} else {\n\t\tparm->db.ipbfadr1 = (u32)(addr_t) buffer;\n\t\tparm->db.ipbfln1f = (u32) size;\n\t\tparm->db.ippathid = path->pathid;\n\t\tparm->db.ipflags1 = flags | IUCV_IPNORPY;\n\t\tparm->db.iptrgcls = msg->class;\n\t\tparm->db.ipsrccls = srccls;\n\t\tparm->db.ipmsgtag = msg->tag;\n\t}\n\trc = iucv_call_b2f0(IUCV_SEND, parm);\n\tif (!rc)\n\t\tmsg->id = parm->db.ipmsgid;\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL(__iucv_message_send);\n\n \nint iucv_message_send(struct iucv_path *path, struct iucv_message *msg,\n\t\t      u8 flags, u32 srccls, void *buffer, size_t size)\n{\n\tint rc;\n\n\tlocal_bh_disable();\n\trc = __iucv_message_send(path, msg, flags, srccls, buffer, size);\n\tlocal_bh_enable();\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_message_send);\n\n \nint iucv_message_send2way(struct iucv_path *path, struct iucv_message *msg,\n\t\t\t  u8 flags, u32 srccls, void *buffer, size_t size,\n\t\t\t  void *answer, size_t asize, size_t *residual)\n{\n\tunion iucv_param *parm;\n\tint rc;\n\n\tlocal_bh_disable();\n\tif (cpumask_empty(&iucv_buffer_cpumask)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tparm = iucv_param[smp_processor_id()];\n\tmemset(parm, 0, sizeof(union iucv_param));\n\tif (flags & IUCV_IPRMDATA) {\n\t\tparm->dpl.ippathid = path->pathid;\n\t\tparm->dpl.ipflags1 = path->flags;\t \n\t\tparm->dpl.iptrgcls = msg->class;\n\t\tparm->dpl.ipsrccls = srccls;\n\t\tparm->dpl.ipmsgtag = msg->tag;\n\t\tparm->dpl.ipbfadr2 = (u32)(addr_t) answer;\n\t\tparm->dpl.ipbfln2f = (u32) asize;\n\t\tmemcpy(parm->dpl.iprmmsg, buffer, 8);\n\t} else {\n\t\tparm->db.ippathid = path->pathid;\n\t\tparm->db.ipflags1 = path->flags;\t \n\t\tparm->db.iptrgcls = msg->class;\n\t\tparm->db.ipsrccls = srccls;\n\t\tparm->db.ipmsgtag = msg->tag;\n\t\tparm->db.ipbfadr1 = (u32)(addr_t) buffer;\n\t\tparm->db.ipbfln1f = (u32) size;\n\t\tparm->db.ipbfadr2 = (u32)(addr_t) answer;\n\t\tparm->db.ipbfln2f = (u32) asize;\n\t}\n\trc = iucv_call_b2f0(IUCV_SEND, parm);\n\tif (!rc)\n\t\tmsg->id = parm->db.ipmsgid;\nout:\n\tlocal_bh_enable();\n\treturn rc;\n}\nEXPORT_SYMBOL(iucv_message_send2way);\n\nstruct iucv_path_pending {\n\tu16 ippathid;\n\tu8  ipflags1;\n\tu8  iptype;\n\tu16 ipmsglim;\n\tu16 res1;\n\tu8  ipvmid[8];\n\tu8  ipuser[16];\n\tu32 res3;\n\tu8  ippollfg;\n\tu8  res4[3];\n} __packed;\n\n \nstatic void iucv_path_pending(struct iucv_irq_data *data)\n{\n\tstruct iucv_path_pending *ipp = (void *) data;\n\tstruct iucv_handler *handler;\n\tstruct iucv_path *path;\n\tchar *error;\n\n\tBUG_ON(iucv_path_table[ipp->ippathid]);\n\t \n\terror = iucv_error_no_memory;\n\tpath = iucv_path_alloc(ipp->ipmsglim, ipp->ipflags1, GFP_ATOMIC);\n\tif (!path)\n\t\tgoto out_sever;\n\tpath->pathid = ipp->ippathid;\n\tiucv_path_table[path->pathid] = path;\n\tEBCASC(ipp->ipvmid, 8);\n\n\t \n\tlist_for_each_entry(handler, &iucv_handler_list, list) {\n\t\tif (!handler->path_pending)\n\t\t\tcontinue;\n\t\t \n\t\tlist_add(&path->list, &handler->paths);\n\t\tpath->handler = handler;\n\t\tif (!handler->path_pending(path, ipp->ipvmid, ipp->ipuser))\n\t\t\treturn;\n\t\tlist_del(&path->list);\n\t\tpath->handler = NULL;\n\t}\n\t \n\tiucv_path_table[path->pathid] = NULL;\n\tiucv_path_free(path);\n\terror = iucv_error_no_listener;\nout_sever:\n\tiucv_sever_pathid(ipp->ippathid, error);\n}\n\nstruct iucv_path_complete {\n\tu16 ippathid;\n\tu8  ipflags1;\n\tu8  iptype;\n\tu16 ipmsglim;\n\tu16 res1;\n\tu8  res2[8];\n\tu8  ipuser[16];\n\tu32 res3;\n\tu8  ippollfg;\n\tu8  res4[3];\n} __packed;\n\n \nstatic void iucv_path_complete(struct iucv_irq_data *data)\n{\n\tstruct iucv_path_complete *ipc = (void *) data;\n\tstruct iucv_path *path = iucv_path_table[ipc->ippathid];\n\n\tif (path)\n\t\tpath->flags = ipc->ipflags1;\n\tif (path && path->handler && path->handler->path_complete)\n\t\tpath->handler->path_complete(path, ipc->ipuser);\n}\n\nstruct iucv_path_severed {\n\tu16 ippathid;\n\tu8  res1;\n\tu8  iptype;\n\tu32 res2;\n\tu8  res3[8];\n\tu8  ipuser[16];\n\tu32 res4;\n\tu8  ippollfg;\n\tu8  res5[3];\n} __packed;\n\n \nstatic void iucv_path_severed(struct iucv_irq_data *data)\n{\n\tstruct iucv_path_severed *ips = (void *) data;\n\tstruct iucv_path *path = iucv_path_table[ips->ippathid];\n\n\tif (!path || !path->handler)\t \n\t\treturn;\n\tif (path->handler->path_severed)\n\t\tpath->handler->path_severed(path, ips->ipuser);\n\telse {\n\t\tiucv_sever_pathid(path->pathid, NULL);\n\t\tiucv_path_table[path->pathid] = NULL;\n\t\tlist_del(&path->list);\n\t\tiucv_path_free(path);\n\t}\n}\n\nstruct iucv_path_quiesced {\n\tu16 ippathid;\n\tu8  res1;\n\tu8  iptype;\n\tu32 res2;\n\tu8  res3[8];\n\tu8  ipuser[16];\n\tu32 res4;\n\tu8  ippollfg;\n\tu8  res5[3];\n} __packed;\n\n \nstatic void iucv_path_quiesced(struct iucv_irq_data *data)\n{\n\tstruct iucv_path_quiesced *ipq = (void *) data;\n\tstruct iucv_path *path = iucv_path_table[ipq->ippathid];\n\n\tif (path && path->handler && path->handler->path_quiesced)\n\t\tpath->handler->path_quiesced(path, ipq->ipuser);\n}\n\nstruct iucv_path_resumed {\n\tu16 ippathid;\n\tu8  res1;\n\tu8  iptype;\n\tu32 res2;\n\tu8  res3[8];\n\tu8  ipuser[16];\n\tu32 res4;\n\tu8  ippollfg;\n\tu8  res5[3];\n} __packed;\n\n \nstatic void iucv_path_resumed(struct iucv_irq_data *data)\n{\n\tstruct iucv_path_resumed *ipr = (void *) data;\n\tstruct iucv_path *path = iucv_path_table[ipr->ippathid];\n\n\tif (path && path->handler && path->handler->path_resumed)\n\t\tpath->handler->path_resumed(path, ipr->ipuser);\n}\n\nstruct iucv_message_complete {\n\tu16 ippathid;\n\tu8  ipflags1;\n\tu8  iptype;\n\tu32 ipmsgid;\n\tu32 ipaudit;\n\tu8  iprmmsg[8];\n\tu32 ipsrccls;\n\tu32 ipmsgtag;\n\tu32 res;\n\tu32 ipbfln2f;\n\tu8  ippollfg;\n\tu8  res2[3];\n} __packed;\n\n \nstatic void iucv_message_complete(struct iucv_irq_data *data)\n{\n\tstruct iucv_message_complete *imc = (void *) data;\n\tstruct iucv_path *path = iucv_path_table[imc->ippathid];\n\tstruct iucv_message msg;\n\n\tif (path && path->handler && path->handler->message_complete) {\n\t\tmsg.flags = imc->ipflags1;\n\t\tmsg.id = imc->ipmsgid;\n\t\tmsg.audit = imc->ipaudit;\n\t\tmemcpy(msg.rmmsg, imc->iprmmsg, 8);\n\t\tmsg.class = imc->ipsrccls;\n\t\tmsg.tag = imc->ipmsgtag;\n\t\tmsg.length = imc->ipbfln2f;\n\t\tpath->handler->message_complete(path, &msg);\n\t}\n}\n\nstruct iucv_message_pending {\n\tu16 ippathid;\n\tu8  ipflags1;\n\tu8  iptype;\n\tu32 ipmsgid;\n\tu32 iptrgcls;\n\tstruct {\n\t\tunion {\n\t\t\tu32 iprmmsg1_u32;\n\t\t\tu8  iprmmsg1[4];\n\t\t} ln1msg1;\n\t\tunion {\n\t\t\tu32 ipbfln1f;\n\t\t\tu8  iprmmsg2[4];\n\t\t} ln1msg2;\n\t} rmmsg;\n\tu32 res1[3];\n\tu32 ipbfln2f;\n\tu8  ippollfg;\n\tu8  res2[3];\n} __packed;\n\n \nstatic void iucv_message_pending(struct iucv_irq_data *data)\n{\n\tstruct iucv_message_pending *imp = (void *) data;\n\tstruct iucv_path *path = iucv_path_table[imp->ippathid];\n\tstruct iucv_message msg;\n\n\tif (path && path->handler && path->handler->message_pending) {\n\t\tmsg.flags = imp->ipflags1;\n\t\tmsg.id = imp->ipmsgid;\n\t\tmsg.class = imp->iptrgcls;\n\t\tif (imp->ipflags1 & IUCV_IPRMDATA) {\n\t\t\tmemcpy(msg.rmmsg, &imp->rmmsg, 8);\n\t\t\tmsg.length = 8;\n\t\t} else\n\t\t\tmsg.length = imp->rmmsg.ln1msg2.ipbfln1f;\n\t\tmsg.reply_size = imp->ipbfln2f;\n\t\tpath->handler->message_pending(path, &msg);\n\t}\n}\n\n \nstatic void iucv_tasklet_fn(unsigned long ignored)\n{\n\ttypedef void iucv_irq_fn(struct iucv_irq_data *);\n\tstatic iucv_irq_fn *irq_fn[] = {\n\t\t[0x02] = iucv_path_complete,\n\t\t[0x03] = iucv_path_severed,\n\t\t[0x04] = iucv_path_quiesced,\n\t\t[0x05] = iucv_path_resumed,\n\t\t[0x06] = iucv_message_complete,\n\t\t[0x07] = iucv_message_complete,\n\t\t[0x08] = iucv_message_pending,\n\t\t[0x09] = iucv_message_pending,\n\t};\n\tLIST_HEAD(task_queue);\n\tstruct iucv_irq_list *p, *n;\n\n\t \n\tif (!spin_trylock(&iucv_table_lock)) {\n\t\ttasklet_schedule(&iucv_tasklet);\n\t\treturn;\n\t}\n\tiucv_active_cpu = smp_processor_id();\n\n\tspin_lock_irq(&iucv_queue_lock);\n\tlist_splice_init(&iucv_task_queue, &task_queue);\n\tspin_unlock_irq(&iucv_queue_lock);\n\n\tlist_for_each_entry_safe(p, n, &task_queue, list) {\n\t\tlist_del_init(&p->list);\n\t\tirq_fn[p->data.iptype](&p->data);\n\t\tkfree(p);\n\t}\n\n\tiucv_active_cpu = -1;\n\tspin_unlock(&iucv_table_lock);\n}\n\n \nstatic void iucv_work_fn(struct work_struct *work)\n{\n\tLIST_HEAD(work_queue);\n\tstruct iucv_irq_list *p, *n;\n\n\t \n\tspin_lock_bh(&iucv_table_lock);\n\tiucv_active_cpu = smp_processor_id();\n\n\tspin_lock_irq(&iucv_queue_lock);\n\tlist_splice_init(&iucv_work_queue, &work_queue);\n\tspin_unlock_irq(&iucv_queue_lock);\n\n\tiucv_cleanup_queue();\n\tlist_for_each_entry_safe(p, n, &work_queue, list) {\n\t\tlist_del_init(&p->list);\n\t\tiucv_path_pending(&p->data);\n\t\tkfree(p);\n\t}\n\n\tiucv_active_cpu = -1;\n\tspin_unlock_bh(&iucv_table_lock);\n}\n\n \nstatic void iucv_external_interrupt(struct ext_code ext_code,\n\t\t\t\t    unsigned int param32, unsigned long param64)\n{\n\tstruct iucv_irq_data *p;\n\tstruct iucv_irq_list *work;\n\n\tinc_irq_stat(IRQEXT_IUC);\n\tp = iucv_irq_data[smp_processor_id()];\n\tif (p->ippathid >= iucv_max_pathid) {\n\t\tWARN_ON(p->ippathid >= iucv_max_pathid);\n\t\tiucv_sever_pathid(p->ippathid, iucv_error_no_listener);\n\t\treturn;\n\t}\n\tBUG_ON(p->iptype  < 0x01 || p->iptype > 0x09);\n\twork = kmalloc(sizeof(struct iucv_irq_list), GFP_ATOMIC);\n\tif (!work) {\n\t\tpr_warn(\"iucv_external_interrupt: out of memory\\n\");\n\t\treturn;\n\t}\n\tmemcpy(&work->data, p, sizeof(work->data));\n\tspin_lock(&iucv_queue_lock);\n\tif (p->iptype == 0x01) {\n\t\t \n\t\tlist_add_tail(&work->list, &iucv_work_queue);\n\t\tschedule_work(&iucv_work);\n\t} else {\n\t\t \n\t\tlist_add_tail(&work->list, &iucv_task_queue);\n\t\ttasklet_schedule(&iucv_tasklet);\n\t}\n\tspin_unlock(&iucv_queue_lock);\n}\n\nstruct iucv_interface iucv_if = {\n\t.message_receive = iucv_message_receive,\n\t.__message_receive = __iucv_message_receive,\n\t.message_reply = iucv_message_reply,\n\t.message_reject = iucv_message_reject,\n\t.message_send = iucv_message_send,\n\t.__message_send = __iucv_message_send,\n\t.message_send2way = iucv_message_send2way,\n\t.message_purge = iucv_message_purge,\n\t.path_accept = iucv_path_accept,\n\t.path_connect = iucv_path_connect,\n\t.path_quiesce = iucv_path_quiesce,\n\t.path_resume = iucv_path_resume,\n\t.path_sever = iucv_path_sever,\n\t.iucv_register = iucv_register,\n\t.iucv_unregister = iucv_unregister,\n\t.bus = NULL,\n\t.root = NULL,\n};\nEXPORT_SYMBOL(iucv_if);\n\nstatic enum cpuhp_state iucv_online;\n \nstatic int __init iucv_init(void)\n{\n\tint rc;\n\n\tif (!MACHINE_IS_VM) {\n\t\trc = -EPROTONOSUPPORT;\n\t\tgoto out;\n\t}\n\tctl_set_bit(0, 1);\n\trc = iucv_query_maxconn();\n\tif (rc)\n\t\tgoto out_ctl;\n\trc = register_external_irq(EXT_IRQ_IUCV, iucv_external_interrupt);\n\tif (rc)\n\t\tgoto out_ctl;\n\tiucv_root = root_device_register(\"iucv\");\n\tif (IS_ERR(iucv_root)) {\n\t\trc = PTR_ERR(iucv_root);\n\t\tgoto out_int;\n\t}\n\n\trc = cpuhp_setup_state(CPUHP_NET_IUCV_PREPARE, \"net/iucv:prepare\",\n\t\t\t       iucv_cpu_prepare, iucv_cpu_dead);\n\tif (rc)\n\t\tgoto out_dev;\n\trc = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"net/iucv:online\",\n\t\t\t       iucv_cpu_online, iucv_cpu_down_prep);\n\tif (rc < 0)\n\t\tgoto out_prep;\n\tiucv_online = rc;\n\n\trc = register_reboot_notifier(&iucv_reboot_notifier);\n\tif (rc)\n\t\tgoto out_remove_hp;\n\tASCEBC(iucv_error_no_listener, 16);\n\tASCEBC(iucv_error_no_memory, 16);\n\tASCEBC(iucv_error_pathid, 16);\n\tiucv_available = 1;\n\trc = bus_register(&iucv_bus);\n\tif (rc)\n\t\tgoto out_reboot;\n\tiucv_if.root = iucv_root;\n\tiucv_if.bus = &iucv_bus;\n\treturn 0;\n\nout_reboot:\n\tunregister_reboot_notifier(&iucv_reboot_notifier);\nout_remove_hp:\n\tcpuhp_remove_state(iucv_online);\nout_prep:\n\tcpuhp_remove_state(CPUHP_NET_IUCV_PREPARE);\nout_dev:\n\troot_device_unregister(iucv_root);\nout_int:\n\tunregister_external_irq(EXT_IRQ_IUCV, iucv_external_interrupt);\nout_ctl:\n\tctl_clear_bit(0, 1);\nout:\n\treturn rc;\n}\n\n \nstatic void __exit iucv_exit(void)\n{\n\tstruct iucv_irq_list *p, *n;\n\n\tspin_lock_irq(&iucv_queue_lock);\n\tlist_for_each_entry_safe(p, n, &iucv_task_queue, list)\n\t\tkfree(p);\n\tlist_for_each_entry_safe(p, n, &iucv_work_queue, list)\n\t\tkfree(p);\n\tspin_unlock_irq(&iucv_queue_lock);\n\tunregister_reboot_notifier(&iucv_reboot_notifier);\n\n\tcpuhp_remove_state_nocalls(iucv_online);\n\tcpuhp_remove_state(CPUHP_NET_IUCV_PREPARE);\n\troot_device_unregister(iucv_root);\n\tbus_unregister(&iucv_bus);\n\tunregister_external_irq(EXT_IRQ_IUCV, iucv_external_interrupt);\n}\n\nsubsys_initcall(iucv_init);\nmodule_exit(iucv_exit);\n\nMODULE_AUTHOR(\"(C) 2001 IBM Corp. by Fritz Elfert (felfert@millenux.com)\");\nMODULE_DESCRIPTION(\"Linux for S/390 IUCV lowlevel driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}