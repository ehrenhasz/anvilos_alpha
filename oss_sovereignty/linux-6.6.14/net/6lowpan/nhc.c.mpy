{
  "module_name": "nhc.c",
  "hash_id": "1bfce625d3eda5da21c96a83065fd0840de8f934b81445a8eac72f0ef5e2fe84",
  "original_prompt": "Ingested from linux-6.6.14/net/6lowpan/nhc.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n\n#include <net/ipv6.h>\n\n#include \"nhc.h\"\n\nstatic const struct lowpan_nhc *lowpan_nexthdr_nhcs[NEXTHDR_MAX + 1];\nstatic DEFINE_SPINLOCK(lowpan_nhc_lock);\n\nstatic const struct lowpan_nhc *lowpan_nhc_by_nhcid(struct sk_buff *skb)\n{\n\tconst struct lowpan_nhc *nhc;\n\tint i;\n\tu8 id;\n\n\tif (!pskb_may_pull(skb, 1))\n\t\treturn NULL;\n\n\tid = *skb->data;\n\n\tfor (i = 0; i < NEXTHDR_MAX + 1; i++) {\n\t\tnhc = lowpan_nexthdr_nhcs[i];\n\t\tif (!nhc)\n\t\t\tcontinue;\n\n\t\tif ((id & nhc->idmask) == nhc->id)\n\t\t\treturn nhc;\n\t}\n\n\treturn NULL;\n}\n\nint lowpan_nhc_check_compression(struct sk_buff *skb,\n\t\t\t\t const struct ipv6hdr *hdr, u8 **hc_ptr)\n{\n\tconst struct lowpan_nhc *nhc;\n\tint ret = 0;\n\n\tspin_lock_bh(&lowpan_nhc_lock);\n\n\tnhc = lowpan_nexthdr_nhcs[hdr->nexthdr];\n\tif (!(nhc && nhc->compress))\n\t\tret = -ENOENT;\n\n\tspin_unlock_bh(&lowpan_nhc_lock);\n\n\treturn ret;\n}\n\nint lowpan_nhc_do_compression(struct sk_buff *skb, const struct ipv6hdr *hdr,\n\t\t\t      u8 **hc_ptr)\n{\n\tint ret;\n\tconst struct lowpan_nhc *nhc;\n\n\tspin_lock_bh(&lowpan_nhc_lock);\n\n\tnhc = lowpan_nexthdr_nhcs[hdr->nexthdr];\n\t \n\tif (unlikely(!nhc || !nhc->compress)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (skb->transport_header == skb->network_header)\n\t\tskb_set_transport_header(skb, sizeof(struct ipv6hdr));\n\n\tret = nhc->compress(skb, hc_ptr);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tskb_pull(skb, nhc->nexthdrlen);\n\nout:\n\tspin_unlock_bh(&lowpan_nhc_lock);\n\n\treturn ret;\n}\n\nint lowpan_nhc_do_uncompression(struct sk_buff *skb,\n\t\t\t\tconst struct net_device *dev,\n\t\t\t\tstruct ipv6hdr *hdr)\n{\n\tconst struct lowpan_nhc *nhc;\n\tint ret;\n\n\tspin_lock_bh(&lowpan_nhc_lock);\n\n\tnhc = lowpan_nhc_by_nhcid(skb);\n\tif (nhc) {\n\t\tif (nhc->uncompress) {\n\t\t\tret = nhc->uncompress(skb, sizeof(struct ipv6hdr) +\n\t\t\t\t\t      nhc->nexthdrlen);\n\t\t\tif (ret < 0) {\n\t\t\t\tspin_unlock_bh(&lowpan_nhc_lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock_bh(&lowpan_nhc_lock);\n\t\t\tnetdev_warn(dev, \"received nhc id for %s which is not implemented.\\n\",\n\t\t\t\t    nhc->name);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t} else {\n\t\tspin_unlock_bh(&lowpan_nhc_lock);\n\t\tnetdev_warn(dev, \"received unknown nhc id which was not found.\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\thdr->nexthdr = nhc->nexthdr;\n\tskb_reset_transport_header(skb);\n\traw_dump_table(__func__, \"raw transport header dump\",\n\t\t       skb_transport_header(skb), nhc->nexthdrlen);\n\n\tspin_unlock_bh(&lowpan_nhc_lock);\n\n\treturn 0;\n}\n\nint lowpan_nhc_add(const struct lowpan_nhc *nhc)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&lowpan_nhc_lock);\n\n\tif (lowpan_nexthdr_nhcs[nhc->nexthdr]) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tlowpan_nexthdr_nhcs[nhc->nexthdr] = nhc;\nout:\n\tspin_unlock_bh(&lowpan_nhc_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(lowpan_nhc_add);\n\nvoid lowpan_nhc_del(const struct lowpan_nhc *nhc)\n{\n\tspin_lock_bh(&lowpan_nhc_lock);\n\n\tlowpan_nexthdr_nhcs[nhc->nexthdr] = NULL;\n\n\tspin_unlock_bh(&lowpan_nhc_lock);\n\n\tsynchronize_net();\n}\nEXPORT_SYMBOL(lowpan_nhc_del);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}