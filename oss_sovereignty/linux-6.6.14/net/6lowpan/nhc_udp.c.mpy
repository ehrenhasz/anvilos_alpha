{
  "module_name": "nhc_udp.c",
  "hash_id": "7262083fe56b756ed6e92ef103b223252a7a85156ccbb3f6c8d5eb7fa3d70318",
  "original_prompt": "Ingested from linux-6.6.14/net/6lowpan/nhc_udp.c",
  "human_readable_source": "\n \n\n#include \"nhc.h\"\n\n#define LOWPAN_NHC_UDP_MASK\t\t0xF8\n#define LOWPAN_NHC_UDP_ID\t\t0xF0\n\n#define LOWPAN_NHC_UDP_4BIT_PORT\t0xF0B0\n#define LOWPAN_NHC_UDP_4BIT_MASK\t0xFFF0\n#define LOWPAN_NHC_UDP_8BIT_PORT\t0xF000\n#define LOWPAN_NHC_UDP_8BIT_MASK\t0xFF00\n\n \n\n \n#define LOWPAN_NHC_UDP_CS_P_00\t0xF0\n \n#define LOWPAN_NHC_UDP_CS_P_01\t0xF1\n \n#define LOWPAN_NHC_UDP_CS_P_10\t0xF2\n \n#define LOWPAN_NHC_UDP_CS_P_11\t0xF3\n \n#define LOWPAN_NHC_UDP_CS_C\t0x04\n\nstatic int udp_uncompress(struct sk_buff *skb, size_t needed)\n{\n\tu8 tmp = 0, val = 0;\n\tstruct udphdr uh;\n\tbool fail;\n\tint err;\n\n\tfail = lowpan_fetch_skb(skb, &tmp, sizeof(tmp));\n\n\tpr_debug(\"UDP header uncompression\\n\");\n\tswitch (tmp & LOWPAN_NHC_UDP_CS_P_11) {\n\tcase LOWPAN_NHC_UDP_CS_P_00:\n\t\tfail |= lowpan_fetch_skb(skb, &uh.source, sizeof(uh.source));\n\t\tfail |= lowpan_fetch_skb(skb, &uh.dest, sizeof(uh.dest));\n\t\tbreak;\n\tcase LOWPAN_NHC_UDP_CS_P_01:\n\t\tfail |= lowpan_fetch_skb(skb, &uh.source, sizeof(uh.source));\n\t\tfail |= lowpan_fetch_skb(skb, &val, sizeof(val));\n\t\tuh.dest = htons(val + LOWPAN_NHC_UDP_8BIT_PORT);\n\t\tbreak;\n\tcase LOWPAN_NHC_UDP_CS_P_10:\n\t\tfail |= lowpan_fetch_skb(skb, &val, sizeof(val));\n\t\tuh.source = htons(val + LOWPAN_NHC_UDP_8BIT_PORT);\n\t\tfail |= lowpan_fetch_skb(skb, &uh.dest, sizeof(uh.dest));\n\t\tbreak;\n\tcase LOWPAN_NHC_UDP_CS_P_11:\n\t\tfail |= lowpan_fetch_skb(skb, &val, sizeof(val));\n\t\tuh.source = htons(LOWPAN_NHC_UDP_4BIT_PORT + (val >> 4));\n\t\tuh.dest = htons(LOWPAN_NHC_UDP_4BIT_PORT + (val & 0x0f));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tpr_debug(\"uncompressed UDP ports: src = %d, dst = %d\\n\",\n\t\t ntohs(uh.source), ntohs(uh.dest));\n\n\t \n\tif (tmp & LOWPAN_NHC_UDP_CS_C) {\n\t\tpr_debug_ratelimited(\"checksum elided currently not supported\\n\");\n\t\tfail = true;\n\t} else {\n\t\tfail |= lowpan_fetch_skb(skb, &uh.check, sizeof(uh.check));\n\t}\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (lowpan_dev(skb->dev)->lltype) {\n\tcase LOWPAN_LLTYPE_IEEE802154:\n\t\tif (lowpan_802154_cb(skb)->d_size)\n\t\t\tuh.len = htons(lowpan_802154_cb(skb)->d_size -\n\t\t\t\t       sizeof(struct ipv6hdr));\n\t\telse\n\t\t\tuh.len = htons(skb->len + sizeof(struct udphdr));\n\t\tbreak;\n\tdefault:\n\t\tuh.len = htons(skb->len + sizeof(struct udphdr));\n\t\tbreak;\n\t}\n\tpr_debug(\"uncompressed UDP length: src = %d\", ntohs(uh.len));\n\n\t \n\terr = skb_cow(skb, needed);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tskb_push(skb, sizeof(struct udphdr));\n\tskb_copy_to_linear_data(skb, &uh, sizeof(struct udphdr));\n\n\treturn 0;\n}\n\nstatic int udp_compress(struct sk_buff *skb, u8 **hc_ptr)\n{\n\tconst struct udphdr *uh = udp_hdr(skb);\n\tu8 tmp;\n\n\tif (((ntohs(uh->source) & LOWPAN_NHC_UDP_4BIT_MASK) ==\n\t     LOWPAN_NHC_UDP_4BIT_PORT) &&\n\t    ((ntohs(uh->dest) & LOWPAN_NHC_UDP_4BIT_MASK) ==\n\t     LOWPAN_NHC_UDP_4BIT_PORT)) {\n\t\tpr_debug(\"UDP header: both ports compression to 4 bits\\n\");\n\t\t \n\t\ttmp = LOWPAN_NHC_UDP_CS_P_11;\n\t\tlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\n\t\t \n\t\ttmp = ntohs(uh->dest) - LOWPAN_NHC_UDP_4BIT_PORT +\n\t\t      ((ntohs(uh->source) - LOWPAN_NHC_UDP_4BIT_PORT) << 4);\n\t\tlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\n\t} else if ((ntohs(uh->dest) & LOWPAN_NHC_UDP_8BIT_MASK) ==\n\t\t\tLOWPAN_NHC_UDP_8BIT_PORT) {\n\t\tpr_debug(\"UDP header: remove 8 bits of dest\\n\");\n\t\t \n\t\ttmp = LOWPAN_NHC_UDP_CS_P_01;\n\t\tlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\n\t\t \n\t\tlowpan_push_hc_data(hc_ptr, &uh->source, sizeof(uh->source));\n\t\t \n\t\ttmp = ntohs(uh->dest) - LOWPAN_NHC_UDP_8BIT_PORT;\n\t\tlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\n\t} else if ((ntohs(uh->source) & LOWPAN_NHC_UDP_8BIT_MASK) ==\n\t\t\tLOWPAN_NHC_UDP_8BIT_PORT) {\n\t\tpr_debug(\"UDP header: remove 8 bits of source\\n\");\n\t\t \n\t\ttmp = LOWPAN_NHC_UDP_CS_P_10;\n\t\tlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\n\t\t \n\t\ttmp = ntohs(uh->source) - LOWPAN_NHC_UDP_8BIT_PORT;\n\t\tlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\n\t\t \n\t\tlowpan_push_hc_data(hc_ptr, &uh->dest, sizeof(uh->dest));\n\t} else {\n\t\tpr_debug(\"UDP header: can't compress\\n\");\n\t\t \n\t\ttmp = LOWPAN_NHC_UDP_CS_P_00;\n\t\tlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\n\t\t \n\t\tlowpan_push_hc_data(hc_ptr, &uh->source, sizeof(uh->source));\n\t\t \n\t\tlowpan_push_hc_data(hc_ptr, &uh->dest, sizeof(uh->dest));\n\t}\n\n\t \n\tlowpan_push_hc_data(hc_ptr, &uh->check, sizeof(uh->check));\n\n\treturn 0;\n}\n\nLOWPAN_NHC(nhc_udp, \"RFC6282 UDP\", NEXTHDR_UDP, sizeof(struct udphdr),\n\t   LOWPAN_NHC_UDP_ID, LOWPAN_NHC_UDP_MASK, udp_uncompress, udp_compress);\n\nmodule_lowpan_nhc(nhc_udp);\nMODULE_DESCRIPTION(\"6LoWPAN next header RFC6282 UDP compression\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}