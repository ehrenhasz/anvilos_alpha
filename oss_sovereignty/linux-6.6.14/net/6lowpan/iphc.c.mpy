{
  "module_name": "iphc.c",
  "hash_id": "3ef1e1d822e99353e8cf84351bf117ea5b60202fb7ce2e435e668228d8a57add",
  "original_prompt": "Ingested from linux-6.6.14/net/6lowpan/iphc.c",
  "human_readable_source": " \n\n \n\n \n\n#include <linux/bitops.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n\n#include <net/6lowpan.h>\n#include <net/ipv6.h>\n\n#include \"6lowpan_i.h\"\n#include \"nhc.h\"\n\n \n#define LOWPAN_IPHC_TF_MASK\t0x18\n#define LOWPAN_IPHC_TF_00\t0x00\n#define LOWPAN_IPHC_TF_01\t0x08\n#define LOWPAN_IPHC_TF_10\t0x10\n#define LOWPAN_IPHC_TF_11\t0x18\n\n#define LOWPAN_IPHC_NH\t\t0x04\n\n#define LOWPAN_IPHC_HLIM_MASK\t0x03\n#define LOWPAN_IPHC_HLIM_00\t0x00\n#define LOWPAN_IPHC_HLIM_01\t0x01\n#define LOWPAN_IPHC_HLIM_10\t0x02\n#define LOWPAN_IPHC_HLIM_11\t0x03\n\n \n#define LOWPAN_IPHC_CID\t\t0x80\n\n#define LOWPAN_IPHC_SAC\t\t0x40\n\n#define LOWPAN_IPHC_SAM_MASK\t0x30\n#define LOWPAN_IPHC_SAM_00\t0x00\n#define LOWPAN_IPHC_SAM_01\t0x10\n#define LOWPAN_IPHC_SAM_10\t0x20\n#define LOWPAN_IPHC_SAM_11\t0x30\n\n#define LOWPAN_IPHC_M\t\t0x08\n\n#define LOWPAN_IPHC_DAC\t\t0x04\n\n#define LOWPAN_IPHC_DAM_MASK\t0x03\n#define LOWPAN_IPHC_DAM_00\t0x00\n#define LOWPAN_IPHC_DAM_01\t0x01\n#define LOWPAN_IPHC_DAM_10\t0x02\n#define LOWPAN_IPHC_DAM_11\t0x03\n\n \n#define is_addr_mac_addr_based(a, m) \\\n\t((((a)->s6_addr[8])  == (((m)[0]) ^ 0x02)) &&\t\\\n\t (((a)->s6_addr[9])  == (m)[1]) &&\t\t\\\n\t (((a)->s6_addr[10]) == (m)[2]) &&\t\t\\\n\t (((a)->s6_addr[11]) == (m)[3]) &&\t\t\\\n\t (((a)->s6_addr[12]) == (m)[4]) &&\t\t\\\n\t (((a)->s6_addr[13]) == (m)[5]) &&\t\t\\\n\t (((a)->s6_addr[14]) == (m)[6]) &&\t\t\\\n\t (((a)->s6_addr[15]) == (m)[7]))\n\n \n#define lowpan_is_iid_16_bit_compressable(a)\t\\\n\t((((a)->s6_addr16[4]) == 0) &&\t\t\\\n\t (((a)->s6_addr[10]) == 0) &&\t\t\\\n\t (((a)->s6_addr[11]) == 0xff) &&\t\\\n\t (((a)->s6_addr[12]) == 0xfe) &&\t\\\n\t (((a)->s6_addr[13]) == 0))\n\n \n\n \n#define lowpan_is_mcast_addr_compressable48(a)\t\\\n\t((((a)->s6_addr16[1]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[2]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[3]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[4]) == 0) &&\t\t\\\n\t (((a)->s6_addr[10]) == 0))\n\n \n#define lowpan_is_mcast_addr_compressable32(a)\t\\\n\t((((a)->s6_addr16[1]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[2]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[3]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[4]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[5]) == 0) &&\t\t\\\n\t (((a)->s6_addr[12]) == 0))\n\n \n#define lowpan_is_mcast_addr_compressable8(a)\t\\\n\t((((a)->s6_addr[1])  == 2) &&\t\t\\\n\t (((a)->s6_addr16[1]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[2]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[3]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[4]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[5]) == 0) &&\t\t\\\n\t (((a)->s6_addr16[6]) == 0) &&\t\t\\\n\t (((a)->s6_addr[14]) == 0))\n\n#define lowpan_is_linklocal_zero_padded(a)\t\\\n\t(!(hdr->saddr.s6_addr[1] & 0x3f) &&\t\\\n\t !hdr->saddr.s6_addr16[1] &&\t\t\\\n\t !hdr->saddr.s6_addr32[1])\n\n#define LOWPAN_IPHC_CID_DCI(cid)\t(cid & 0x0f)\n#define LOWPAN_IPHC_CID_SCI(cid)\t((cid & 0xf0) >> 4)\n\nstatic inline void\nlowpan_iphc_uncompress_802154_lladdr(struct in6_addr *ipaddr,\n\t\t\t\t     const void *lladdr)\n{\n\tconst struct ieee802154_addr *addr = lladdr;\n\tu8 eui64[EUI64_ADDR_LEN];\n\n\tswitch (addr->mode) {\n\tcase IEEE802154_ADDR_LONG:\n\t\tieee802154_le64_to_be64(eui64, &addr->extended_addr);\n\t\tlowpan_iphc_uncompress_eui64_lladdr(ipaddr, eui64);\n\t\tbreak;\n\tcase IEEE802154_ADDR_SHORT:\n\t\t \n\t\tipaddr->s6_addr[0] = 0xFE;\n\t\tipaddr->s6_addr[1] = 0x80;\n\t\tipaddr->s6_addr[11] = 0xFF;\n\t\tipaddr->s6_addr[12] = 0xFE;\n\t\tieee802154_le16_to_be16(&ipaddr->s6_addr16[7],\n\t\t\t\t\t&addr->short_addr);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}\n\nstatic struct lowpan_iphc_ctx *\nlowpan_iphc_ctx_get_by_id(const struct net_device *dev, u8 id)\n{\n\tstruct lowpan_iphc_ctx *ret = &lowpan_dev(dev)->ctx.table[id];\n\n\tif (!lowpan_iphc_ctx_is_active(ret))\n\t\treturn NULL;\n\n\treturn ret;\n}\n\nstatic struct lowpan_iphc_ctx *\nlowpan_iphc_ctx_get_by_addr(const struct net_device *dev,\n\t\t\t    const struct in6_addr *addr)\n{\n\tstruct lowpan_iphc_ctx *table = lowpan_dev(dev)->ctx.table;\n\tstruct lowpan_iphc_ctx *ret = NULL;\n\tstruct in6_addr addr_pfx;\n\tu8 addr_plen;\n\tint i;\n\n\tfor (i = 0; i < LOWPAN_IPHC_CTX_TABLE_SIZE; i++) {\n\t\t \n\t\tif (!lowpan_iphc_ctx_is_active(&table[i]) ||\n\t\t    !lowpan_iphc_ctx_is_compression(&table[i]))\n\t\t\tcontinue;\n\n\t\tipv6_addr_prefix(&addr_pfx, addr, table[i].plen);\n\n\t\t \n\t\tif (table[i].plen < 64)\n\t\t\taddr_plen = 64;\n\t\telse\n\t\t\taddr_plen = table[i].plen;\n\n\t\tif (ipv6_prefix_equal(&addr_pfx, &table[i].pfx, addr_plen)) {\n\t\t\t \n\t\t\tif (!ret) {\n\t\t\t\tret = &table[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (table[i].plen > ret->plen)\n\t\t\t\tret = &table[i];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic struct lowpan_iphc_ctx *\nlowpan_iphc_ctx_get_by_mcast_addr(const struct net_device *dev,\n\t\t\t\t  const struct in6_addr *addr)\n{\n\tstruct lowpan_iphc_ctx *table = lowpan_dev(dev)->ctx.table;\n\tstruct lowpan_iphc_ctx *ret = NULL;\n\tstruct in6_addr addr_mcast, network_pfx = {};\n\tint i;\n\n\t \n\tmemcpy(&addr_mcast, addr, sizeof(*addr));\n\n\tfor (i = 0; i < LOWPAN_IPHC_CTX_TABLE_SIZE; i++) {\n\t\t \n\t\tif (!lowpan_iphc_ctx_is_active(&table[i]) ||\n\t\t    !lowpan_iphc_ctx_is_compression(&table[i]))\n\t\t\tcontinue;\n\n\t\t \n\t\taddr_mcast.s6_addr[3] = table[i].plen;\n\t\t \n\t\tipv6_addr_prefix(&network_pfx, &table[i].pfx,\n\t\t\t\t table[i].plen);\n\t\t \n\t\tmemcpy(&addr_mcast.s6_addr[4], &network_pfx, 8);\n\n\t\tif (ipv6_addr_equal(addr, &addr_mcast)) {\n\t\t\tret = &table[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void lowpan_iphc_uncompress_lladdr(const struct net_device *dev,\n\t\t\t\t\t  struct in6_addr *ipaddr,\n\t\t\t\t\t  const void *lladdr)\n{\n\tswitch (dev->addr_len) {\n\tcase ETH_ALEN:\n\t\tlowpan_iphc_uncompress_eui48_lladdr(ipaddr, lladdr);\n\t\tbreak;\n\tcase EUI64_ADDR_LEN:\n\t\tlowpan_iphc_uncompress_eui64_lladdr(ipaddr, lladdr);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}\n\n \nstatic int lowpan_iphc_uncompress_addr(struct sk_buff *skb,\n\t\t\t\t       const struct net_device *dev,\n\t\t\t\t       struct in6_addr *ipaddr,\n\t\t\t\t       u8 address_mode, const void *lladdr)\n{\n\tbool fail;\n\n\tswitch (address_mode) {\n\t \n\tcase LOWPAN_IPHC_DAM_00:\n\t\t \n\t\tfail = lowpan_fetch_skb(skb, ipaddr->s6_addr, 16);\n\t\tbreak;\n\tcase LOWPAN_IPHC_SAM_01:\n\tcase LOWPAN_IPHC_DAM_01:\n\t\t \n\t\tipaddr->s6_addr[0] = 0xFE;\n\t\tipaddr->s6_addr[1] = 0x80;\n\t\tfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[8], 8);\n\t\tbreak;\n\tcase LOWPAN_IPHC_SAM_10:\n\tcase LOWPAN_IPHC_DAM_10:\n\t\t \n\t\tipaddr->s6_addr[0] = 0xFE;\n\t\tipaddr->s6_addr[1] = 0x80;\n\t\tipaddr->s6_addr[11] = 0xFF;\n\t\tipaddr->s6_addr[12] = 0xFE;\n\t\tfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[14], 2);\n\t\tbreak;\n\tcase LOWPAN_IPHC_SAM_11:\n\tcase LOWPAN_IPHC_DAM_11:\n\t\tfail = false;\n\t\tswitch (lowpan_dev(dev)->lltype) {\n\t\tcase LOWPAN_LLTYPE_IEEE802154:\n\t\t\tlowpan_iphc_uncompress_802154_lladdr(ipaddr, lladdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlowpan_iphc_uncompress_lladdr(dev, ipaddr, lladdr);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Invalid address mode value: 0x%x\\n\", address_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fail) {\n\t\tpr_debug(\"Failed to fetch skb data\\n\");\n\t\treturn -EIO;\n\t}\n\n\traw_dump_inline(NULL, \"Reconstructed ipv6 addr is\",\n\t\t\tipaddr->s6_addr, 16);\n\n\treturn 0;\n}\n\n \nstatic int lowpan_iphc_uncompress_ctx_addr(struct sk_buff *skb,\n\t\t\t\t\t   const struct net_device *dev,\n\t\t\t\t\t   const struct lowpan_iphc_ctx *ctx,\n\t\t\t\t\t   struct in6_addr *ipaddr,\n\t\t\t\t\t   u8 address_mode, const void *lladdr)\n{\n\tbool fail;\n\n\tswitch (address_mode) {\n\t \n\tcase LOWPAN_IPHC_DAM_00:\n\t\tfail = false;\n\t\t \n\t\tbreak;\n\tcase LOWPAN_IPHC_SAM_01:\n\tcase LOWPAN_IPHC_DAM_01:\n\t\tfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[8], 8);\n\t\tipv6_addr_prefix_copy(ipaddr, &ctx->pfx, ctx->plen);\n\t\tbreak;\n\tcase LOWPAN_IPHC_SAM_10:\n\tcase LOWPAN_IPHC_DAM_10:\n\t\tipaddr->s6_addr[11] = 0xFF;\n\t\tipaddr->s6_addr[12] = 0xFE;\n\t\tfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[14], 2);\n\t\tipv6_addr_prefix_copy(ipaddr, &ctx->pfx, ctx->plen);\n\t\tbreak;\n\tcase LOWPAN_IPHC_SAM_11:\n\tcase LOWPAN_IPHC_DAM_11:\n\t\tfail = false;\n\t\tswitch (lowpan_dev(dev)->lltype) {\n\t\tcase LOWPAN_LLTYPE_IEEE802154:\n\t\t\tlowpan_iphc_uncompress_802154_lladdr(ipaddr, lladdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlowpan_iphc_uncompress_lladdr(dev, ipaddr, lladdr);\n\t\t\tbreak;\n\t\t}\n\t\tipv6_addr_prefix_copy(ipaddr, &ctx->pfx, ctx->plen);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Invalid sam value: 0x%x\\n\", address_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fail) {\n\t\tpr_debug(\"Failed to fetch skb data\\n\");\n\t\treturn -EIO;\n\t}\n\n\traw_dump_inline(NULL,\n\t\t\t\"Reconstructed context based ipv6 src addr is\",\n\t\t\tipaddr->s6_addr, 16);\n\n\treturn 0;\n}\n\n \nstatic int lowpan_uncompress_multicast_daddr(struct sk_buff *skb,\n\t\t\t\t\t     struct in6_addr *ipaddr,\n\t\t\t\t\t     u8 address_mode)\n{\n\tbool fail;\n\n\tswitch (address_mode) {\n\tcase LOWPAN_IPHC_DAM_00:\n\t\t \n\t\tfail = lowpan_fetch_skb(skb, ipaddr->s6_addr, 16);\n\t\tbreak;\n\tcase LOWPAN_IPHC_DAM_01:\n\t\t \n\t\tipaddr->s6_addr[0] = 0xFF;\n\t\tfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[1], 1);\n\t\tfail |= lowpan_fetch_skb(skb, &ipaddr->s6_addr[11], 5);\n\t\tbreak;\n\tcase LOWPAN_IPHC_DAM_10:\n\t\t \n\t\tipaddr->s6_addr[0] = 0xFF;\n\t\tfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[1], 1);\n\t\tfail |= lowpan_fetch_skb(skb, &ipaddr->s6_addr[13], 3);\n\t\tbreak;\n\tcase LOWPAN_IPHC_DAM_11:\n\t\t \n\t\tipaddr->s6_addr[0] = 0xFF;\n\t\tipaddr->s6_addr[1] = 0x02;\n\t\tfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[15], 1);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"DAM value has a wrong value: 0x%x\\n\", address_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fail) {\n\t\tpr_debug(\"Failed to fetch skb data\\n\");\n\t\treturn -EIO;\n\t}\n\n\traw_dump_inline(NULL, \"Reconstructed ipv6 multicast addr is\",\n\t\t\tipaddr->s6_addr, 16);\n\n\treturn 0;\n}\n\nstatic int lowpan_uncompress_multicast_ctx_daddr(struct sk_buff *skb,\n\t\t\t\t\t\t struct lowpan_iphc_ctx *ctx,\n\t\t\t\t\t\t struct in6_addr *ipaddr,\n\t\t\t\t\t\t u8 address_mode)\n{\n\tstruct in6_addr network_pfx = {};\n\tbool fail;\n\n\tipaddr->s6_addr[0] = 0xFF;\n\tfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[1], 2);\n\tfail |= lowpan_fetch_skb(skb, &ipaddr->s6_addr[12], 4);\n\tif (fail)\n\t\treturn -EIO;\n\n\t \n\tipaddr->s6_addr[3] = ctx->plen;\n\t \n\tipv6_addr_prefix(&network_pfx, &ctx->pfx, ctx->plen);\n\t \n\tmemcpy(&ipaddr->s6_addr[4], &network_pfx, 8);\n\n\treturn 0;\n}\n\n \nstatic inline void lowpan_iphc_tf_set_ecn(struct ipv6hdr *hdr, const u8 *tf)\n{\n\t \n\tu8 ecn = tf[0] & 0xc0;\n\n\t \n\thdr->flow_lbl[0] |= (ecn >> 2);\n}\n\n \nstatic inline void lowpan_iphc_tf_set_dscp(struct ipv6hdr *hdr, const u8 *tf)\n{\n\t \n\tu8 dscp = tf[0] & 0x3f;\n\n\t \n\thdr->priority |= ((dscp & 0x3c) >> 2);\n\t \n\thdr->flow_lbl[0] |= ((dscp & 0x03) << 6);\n}\n\n \nstatic inline void lowpan_iphc_tf_set_lbl(struct ipv6hdr *hdr, const u8 *lbl)\n{\n\t \n\thdr->flow_lbl[0] |= lbl[0] & 0x0f;\n\tmemcpy(&hdr->flow_lbl[1], &lbl[1], 2);\n}\n\n \nstatic int lowpan_iphc_tf_decompress(struct sk_buff *skb, struct ipv6hdr *hdr,\n\t\t\t\t     u8 val)\n{\n\tu8 tf[4];\n\n\t \n\tswitch (val) {\n\tcase LOWPAN_IPHC_TF_00:\n\t\t \n\t\tif (lowpan_fetch_skb(skb, tf, 4))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tlowpan_iphc_tf_set_ecn(hdr, tf);\n\t\tlowpan_iphc_tf_set_dscp(hdr, tf);\n\t\tlowpan_iphc_tf_set_lbl(hdr, &tf[1]);\n\t\tbreak;\n\tcase LOWPAN_IPHC_TF_01:\n\t\t \n\t\tif (lowpan_fetch_skb(skb, tf, 3))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tlowpan_iphc_tf_set_ecn(hdr, tf);\n\t\tlowpan_iphc_tf_set_lbl(hdr, &tf[0]);\n\t\tbreak;\n\tcase LOWPAN_IPHC_TF_10:\n\t\t \n\t\tif (lowpan_fetch_skb(skb, tf, 1))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tlowpan_iphc_tf_set_ecn(hdr, tf);\n\t\tlowpan_iphc_tf_set_dscp(hdr, tf);\n\t\tbreak;\n\tcase LOWPAN_IPHC_TF_11:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const u8 lowpan_ttl_values[] = {\n\t[LOWPAN_IPHC_HLIM_01] = 1,\n\t[LOWPAN_IPHC_HLIM_10] = 64,\n\t[LOWPAN_IPHC_HLIM_11] = 255,\n};\n\nint lowpan_header_decompress(struct sk_buff *skb, const struct net_device *dev,\n\t\t\t     const void *daddr, const void *saddr)\n{\n\tstruct ipv6hdr hdr = {};\n\tstruct lowpan_iphc_ctx *ci;\n\tu8 iphc0, iphc1, cid = 0;\n\tint err;\n\n\traw_dump_table(__func__, \"raw skb data dump uncompressed\",\n\t\t       skb->data, skb->len);\n\n\tif (lowpan_fetch_skb(skb, &iphc0, sizeof(iphc0)) ||\n\t    lowpan_fetch_skb(skb, &iphc1, sizeof(iphc1)))\n\t\treturn -EINVAL;\n\n\thdr.version = 6;\n\n\t \n\tif (iphc1 & LOWPAN_IPHC_CID) {\n\t\tif (lowpan_fetch_skb(skb, &cid, sizeof(cid)))\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = lowpan_iphc_tf_decompress(skb, &hdr,\n\t\t\t\t\tiphc0 & LOWPAN_IPHC_TF_MASK);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!(iphc0 & LOWPAN_IPHC_NH)) {\n\t\t \n\t\tif (lowpan_fetch_skb(skb, &hdr.nexthdr, sizeof(hdr.nexthdr)))\n\t\t\treturn -EINVAL;\n\n\t\tpr_debug(\"NH flag is set, next header carried inline: %02x\\n\",\n\t\t\t hdr.nexthdr);\n\t}\n\n\t \n\tif ((iphc0 & LOWPAN_IPHC_HLIM_MASK) != LOWPAN_IPHC_HLIM_00) {\n\t\thdr.hop_limit = lowpan_ttl_values[iphc0 & LOWPAN_IPHC_HLIM_MASK];\n\t} else {\n\t\tif (lowpan_fetch_skb(skb, &hdr.hop_limit,\n\t\t\t\t     sizeof(hdr.hop_limit)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (iphc1 & LOWPAN_IPHC_SAC) {\n\t\tspin_lock_bh(&lowpan_dev(dev)->ctx.lock);\n\t\tci = lowpan_iphc_ctx_get_by_id(dev, LOWPAN_IPHC_CID_SCI(cid));\n\t\tif (!ci) {\n\t\t\tspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpr_debug(\"SAC bit is set. Handle context based source address.\\n\");\n\t\terr = lowpan_iphc_uncompress_ctx_addr(skb, dev, ci, &hdr.saddr,\n\t\t\t\t\t\t      iphc1 & LOWPAN_IPHC_SAM_MASK,\n\t\t\t\t\t\t      saddr);\n\t\tspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\n\t} else {\n\t\t \n\t\tpr_debug(\"source address stateless compression\\n\");\n\t\terr = lowpan_iphc_uncompress_addr(skb, dev, &hdr.saddr,\n\t\t\t\t\t\t  iphc1 & LOWPAN_IPHC_SAM_MASK,\n\t\t\t\t\t\t  saddr);\n\t}\n\n\t \n\tif (err)\n\t\treturn -EINVAL;\n\n\tswitch (iphc1 & (LOWPAN_IPHC_M | LOWPAN_IPHC_DAC)) {\n\tcase LOWPAN_IPHC_M | LOWPAN_IPHC_DAC:\n\t\tskb->pkt_type = PACKET_BROADCAST;\n\n\t\tspin_lock_bh(&lowpan_dev(dev)->ctx.lock);\n\t\tci = lowpan_iphc_ctx_get_by_id(dev, LOWPAN_IPHC_CID_DCI(cid));\n\t\tif (!ci) {\n\t\t\tspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tpr_debug(\"dest: context-based mcast compression\\n\");\n\t\terr = lowpan_uncompress_multicast_ctx_daddr(skb, ci,\n\t\t\t\t\t\t\t    &hdr.daddr,\n\t\t\t\t\t\t\t    iphc1 & LOWPAN_IPHC_DAM_MASK);\n\t\tspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\n\t\tbreak;\n\tcase LOWPAN_IPHC_M:\n\t\tskb->pkt_type = PACKET_BROADCAST;\n\n\t\t \n\t\terr = lowpan_uncompress_multicast_daddr(skb, &hdr.daddr,\n\t\t\t\t\t\t\tiphc1 & LOWPAN_IPHC_DAM_MASK);\n\t\tbreak;\n\tcase LOWPAN_IPHC_DAC:\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\tspin_lock_bh(&lowpan_dev(dev)->ctx.lock);\n\t\tci = lowpan_iphc_ctx_get_by_id(dev, LOWPAN_IPHC_CID_DCI(cid));\n\t\tif (!ci) {\n\t\t\tspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tpr_debug(\"DAC bit is set. Handle context based destination address.\\n\");\n\t\terr = lowpan_iphc_uncompress_ctx_addr(skb, dev, ci, &hdr.daddr,\n\t\t\t\t\t\t      iphc1 & LOWPAN_IPHC_DAM_MASK,\n\t\t\t\t\t\t      daddr);\n\t\tspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\n\t\tbreak;\n\tdefault:\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\terr = lowpan_iphc_uncompress_addr(skb, dev, &hdr.daddr,\n\t\t\t\t\t\t  iphc1 & LOWPAN_IPHC_DAM_MASK,\n\t\t\t\t\t\t  daddr);\n\t\tpr_debug(\"dest: stateless compression mode %d dest %pI6c\\n\",\n\t\t\t iphc1 & LOWPAN_IPHC_DAM_MASK, &hdr.daddr);\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn -EINVAL;\n\n\t \n\tif (iphc0 & LOWPAN_IPHC_NH) {\n\t\terr = lowpan_nhc_do_uncompression(skb, dev, &hdr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\terr = skb_cow(skb, sizeof(hdr));\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t}\n\n\tswitch (lowpan_dev(dev)->lltype) {\n\tcase LOWPAN_LLTYPE_IEEE802154:\n\t\tif (lowpan_802154_cb(skb)->d_size)\n\t\t\thdr.payload_len = htons(lowpan_802154_cb(skb)->d_size -\n\t\t\t\t\t\tsizeof(struct ipv6hdr));\n\t\telse\n\t\t\thdr.payload_len = htons(skb->len);\n\t\tbreak;\n\tdefault:\n\t\thdr.payload_len = htons(skb->len);\n\t\tbreak;\n\t}\n\n\tpr_debug(\"skb headroom size = %d, data length = %d\\n\",\n\t\t skb_headroom(skb), skb->len);\n\n\tpr_debug(\"IPv6 header dump:\\n\\tversion = %d\\n\\tlength  = %d\\n\\t\"\n\t\t \"nexthdr = 0x%02x\\n\\thop_lim = %d\\n\\tdest    = %pI6c\\n\",\n\t\thdr.version, ntohs(hdr.payload_len), hdr.nexthdr,\n\t\thdr.hop_limit, &hdr.daddr);\n\n\tskb_push(skb, sizeof(hdr));\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tskb_copy_to_linear_data(skb, &hdr, sizeof(hdr));\n\n\traw_dump_table(__func__, \"raw header dump\", (u8 *)&hdr, sizeof(hdr));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lowpan_header_decompress);\n\nstatic const u8 lowpan_iphc_dam_to_sam_value[] = {\n\t[LOWPAN_IPHC_DAM_00] = LOWPAN_IPHC_SAM_00,\n\t[LOWPAN_IPHC_DAM_01] = LOWPAN_IPHC_SAM_01,\n\t[LOWPAN_IPHC_DAM_10] = LOWPAN_IPHC_SAM_10,\n\t[LOWPAN_IPHC_DAM_11] = LOWPAN_IPHC_SAM_11,\n};\n\nstatic inline bool\nlowpan_iphc_compress_ctx_802154_lladdr(const struct in6_addr *ipaddr,\n\t\t\t\t       const struct lowpan_iphc_ctx *ctx,\n\t\t\t\t       const void *lladdr)\n{\n\tconst struct ieee802154_addr *addr = lladdr;\n\tunsigned char extended_addr[EUI64_ADDR_LEN];\n\tbool lladdr_compress = false;\n\tstruct in6_addr tmp = {};\n\n\tswitch (addr->mode) {\n\tcase IEEE802154_ADDR_LONG:\n\t\tieee802154_le64_to_be64(&extended_addr, &addr->extended_addr);\n\t\t \n\t\tmemcpy(&tmp.s6_addr[8], &extended_addr, EUI64_ADDR_LEN);\n\t\t \n\t\ttmp.s6_addr[8] ^= 0x02;\n\t\t \n\t\tipv6_addr_prefix_copy(&tmp, &ctx->pfx, ctx->plen);\n\t\tif (ipv6_addr_equal(&tmp, ipaddr))\n\t\t\tlladdr_compress = true;\n\t\tbreak;\n\tcase IEEE802154_ADDR_SHORT:\n\t\ttmp.s6_addr[11] = 0xFF;\n\t\ttmp.s6_addr[12] = 0xFE;\n\t\tieee802154_le16_to_be16(&tmp.s6_addr16[7],\n\t\t\t\t\t&addr->short_addr);\n\t\t \n\t\tipv6_addr_prefix_copy(&tmp, &ctx->pfx, ctx->plen);\n\t\tif (ipv6_addr_equal(&tmp, ipaddr))\n\t\t\tlladdr_compress = true;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn lladdr_compress;\n}\n\nstatic bool lowpan_iphc_addr_equal(const struct net_device *dev,\n\t\t\t\t   const struct lowpan_iphc_ctx *ctx,\n\t\t\t\t   const struct in6_addr *ipaddr,\n\t\t\t\t   const void *lladdr)\n{\n\tstruct in6_addr tmp = {};\n\n\tlowpan_iphc_uncompress_lladdr(dev, &tmp, lladdr);\n\n\tif (ctx)\n\t\tipv6_addr_prefix_copy(&tmp, &ctx->pfx, ctx->plen);\n\n\treturn ipv6_addr_equal(&tmp, ipaddr);\n}\n\nstatic u8 lowpan_compress_ctx_addr(u8 **hc_ptr, const struct net_device *dev,\n\t\t\t\t   const struct in6_addr *ipaddr,\n\t\t\t\t   const struct lowpan_iphc_ctx *ctx,\n\t\t\t\t   const unsigned char *lladdr, bool sam)\n{\n\tstruct in6_addr tmp;\n\tu8 dam;\n\n\tswitch (lowpan_dev(dev)->lltype) {\n\tcase LOWPAN_LLTYPE_IEEE802154:\n\t\tif (lowpan_iphc_compress_ctx_802154_lladdr(ipaddr, ctx,\n\t\t\t\t\t\t\t   lladdr)) {\n\t\t\tdam = LOWPAN_IPHC_DAM_11;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (lowpan_iphc_addr_equal(dev, ctx, ipaddr, lladdr)) {\n\t\t\tdam = LOWPAN_IPHC_DAM_11;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\t \n\ttmp.s6_addr[11] = 0xFF;\n\ttmp.s6_addr[12] = 0xFE;\n\tmemcpy(&tmp.s6_addr[14], &ipaddr->s6_addr[14], 2);\n\t \n\tipv6_addr_prefix_copy(&tmp, &ctx->pfx, ctx->plen);\n\tif (ipv6_addr_equal(&tmp, ipaddr)) {\n\t\tlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[14], 2);\n\t\tdam = LOWPAN_IPHC_DAM_10;\n\t\tgoto out;\n\t}\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\t \n\tmemcpy(&tmp.s6_addr[8], &ipaddr->s6_addr[8], 8);\n\t \n\tipv6_addr_prefix_copy(&tmp, &ctx->pfx, ctx->plen);\n\tif (ipv6_addr_equal(&tmp, ipaddr)) {\n\t\tlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[8], 8);\n\t\tdam = LOWPAN_IPHC_DAM_01;\n\t\tgoto out;\n\t}\n\n\tWARN_ONCE(1, \"context found but no address mode matched\\n\");\n\treturn LOWPAN_IPHC_DAM_00;\nout:\n\n\tif (sam)\n\t\treturn lowpan_iphc_dam_to_sam_value[dam];\n\telse\n\t\treturn dam;\n}\n\nstatic inline bool\nlowpan_iphc_compress_802154_lladdr(const struct in6_addr *ipaddr,\n\t\t\t\t   const void *lladdr)\n{\n\tconst struct ieee802154_addr *addr = lladdr;\n\tunsigned char extended_addr[EUI64_ADDR_LEN];\n\tbool lladdr_compress = false;\n\tstruct in6_addr tmp = {};\n\n\tswitch (addr->mode) {\n\tcase IEEE802154_ADDR_LONG:\n\t\tieee802154_le64_to_be64(&extended_addr, &addr->extended_addr);\n\t\tif (is_addr_mac_addr_based(ipaddr, extended_addr))\n\t\t\tlladdr_compress = true;\n\t\tbreak;\n\tcase IEEE802154_ADDR_SHORT:\n\t\t \n\t\ttmp.s6_addr[0] = 0xFE;\n\t\ttmp.s6_addr[1] = 0x80;\n\t\ttmp.s6_addr[11] = 0xFF;\n\t\ttmp.s6_addr[12] = 0xFE;\n\t\tieee802154_le16_to_be16(&tmp.s6_addr16[7],\n\t\t\t\t\t&addr->short_addr);\n\t\tif (ipv6_addr_equal(&tmp, ipaddr))\n\t\t\tlladdr_compress = true;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn lladdr_compress;\n}\n\nstatic u8 lowpan_compress_addr_64(u8 **hc_ptr, const struct net_device *dev,\n\t\t\t\t  const struct in6_addr *ipaddr,\n\t\t\t\t  const unsigned char *lladdr, bool sam)\n{\n\tu8 dam = LOWPAN_IPHC_DAM_01;\n\n\tswitch (lowpan_dev(dev)->lltype) {\n\tcase LOWPAN_LLTYPE_IEEE802154:\n\t\tif (lowpan_iphc_compress_802154_lladdr(ipaddr, lladdr)) {\n\t\t\tdam = LOWPAN_IPHC_DAM_11;  \n\t\t\tpr_debug(\"address compression 0 bits\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (lowpan_iphc_addr_equal(dev, NULL, ipaddr, lladdr)) {\n\t\t\tdam = LOWPAN_IPHC_DAM_11;\n\t\t\tpr_debug(\"address compression 0 bits\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (lowpan_is_iid_16_bit_compressable(ipaddr)) {\n\t\t \n\t\tlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr16[7], 2);\n\t\tdam = LOWPAN_IPHC_DAM_10;  \n\t\traw_dump_inline(NULL, \"Compressed ipv6 addr is (16 bits)\",\n\t\t\t\t*hc_ptr - 2, 2);\n\t\tgoto out;\n\t}\n\n\t \n\tlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr16[4], 8);\n\traw_dump_inline(NULL, \"Compressed ipv6 addr is (64 bits)\",\n\t\t\t*hc_ptr - 8, 8);\n\nout:\n\n\tif (sam)\n\t\treturn lowpan_iphc_dam_to_sam_value[dam];\n\telse\n\t\treturn dam;\n}\n\n \nstatic inline u8 lowpan_iphc_get_tc(const struct ipv6hdr *hdr)\n{\n\tu8 dscp, ecn;\n\n\t \n\tdscp = (hdr->priority << 2) | ((hdr->flow_lbl[0] & 0xc0) >> 6);\n\t \n\tecn = (hdr->flow_lbl[0] & 0x30);\n\t \n\tpr_debug(\"ecn 0x%02x dscp 0x%02x\\n\", ecn >> 4, dscp);\n\t \n\treturn (ecn << 2) | dscp;\n}\n\n \nstatic inline bool lowpan_iphc_is_flow_lbl_zero(const struct ipv6hdr *hdr)\n{\n\treturn ((!(hdr->flow_lbl[0] & 0x0f)) &&\n\t\t!hdr->flow_lbl[1] && !hdr->flow_lbl[2]);\n}\n\n \nstatic u8 lowpan_iphc_tf_compress(u8 **hc_ptr, const struct ipv6hdr *hdr)\n{\n\t \n\tu8 tc = lowpan_iphc_get_tc(hdr), tf[4], val;\n\n\t \n\tpr_debug(\"tc 0x%02x\\n\", tc);\n\n\tif (lowpan_iphc_is_flow_lbl_zero(hdr)) {\n\t\tif (!tc) {\n\t\t\t \n\t\t\tval = LOWPAN_IPHC_TF_11;\n\t\t} else {\n\t\t\t \n\t\t\tlowpan_push_hc_data(hc_ptr, &tc, sizeof(tc));\n\t\t\tval = LOWPAN_IPHC_TF_10;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!(tc & 0x3f)) {\n\t\t\t \n\t\t\tmemcpy(&tf[0], &hdr->flow_lbl[0], 3);\n\t\t\t \n\t\t\ttf[0] &= ~0xf0;\n\t\t\t \n\t\t\ttf[0] |= (tc & 0xc0);\n\n\t\t\tlowpan_push_hc_data(hc_ptr, tf, 3);\n\t\t\tval = LOWPAN_IPHC_TF_01;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(&tf[0], &tc, sizeof(tc));\n\t\t\t \n\t\t\tmemcpy(&tf[1], &hdr->flow_lbl[0], 3);\n\t\t\t \n\t\t\ttf[1] &= ~0xf0;\n\n\t\t\tlowpan_push_hc_data(hc_ptr, tf, 4);\n\t\t\tval = LOWPAN_IPHC_TF_00;\n\t\t}\n\t}\n\n\treturn val;\n}\n\nstatic u8 lowpan_iphc_mcast_ctx_addr_compress(u8 **hc_ptr,\n\t\t\t\t\t      const struct lowpan_iphc_ctx *ctx,\n\t\t\t\t\t      const struct in6_addr *ipaddr)\n{\n\tu8 data[6];\n\n\t \n\tmemcpy(data, &ipaddr->s6_addr[1], 2);\n\t \n\tmemcpy(&data[1], &ipaddr->s6_addr[11], 4);\n\tlowpan_push_hc_data(hc_ptr, data, 6);\n\n\treturn LOWPAN_IPHC_DAM_00;\n}\n\nstatic u8 lowpan_iphc_mcast_addr_compress(u8 **hc_ptr,\n\t\t\t\t\t  const struct in6_addr *ipaddr)\n{\n\tu8 val;\n\n\tif (lowpan_is_mcast_addr_compressable8(ipaddr)) {\n\t\tpr_debug(\"compressed to 1 octet\\n\");\n\t\t \n\t\tlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[15], 1);\n\t\tval = LOWPAN_IPHC_DAM_11;\n\t} else if (lowpan_is_mcast_addr_compressable32(ipaddr)) {\n\t\tpr_debug(\"compressed to 4 octets\\n\");\n\t\t \n\t\tlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[1], 1);\n\t\tlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[13], 3);\n\t\tval = LOWPAN_IPHC_DAM_10;\n\t} else if (lowpan_is_mcast_addr_compressable48(ipaddr)) {\n\t\tpr_debug(\"compressed to 6 octets\\n\");\n\t\t \n\t\tlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[1], 1);\n\t\tlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[11], 5);\n\t\tval = LOWPAN_IPHC_DAM_01;\n\t} else {\n\t\tpr_debug(\"using full address\\n\");\n\t\tlowpan_push_hc_data(hc_ptr, ipaddr->s6_addr, 16);\n\t\tval = LOWPAN_IPHC_DAM_00;\n\t}\n\n\treturn val;\n}\n\nint lowpan_header_compress(struct sk_buff *skb, const struct net_device *dev,\n\t\t\t   const void *daddr, const void *saddr)\n{\n\tu8 iphc0, iphc1, *hc_ptr, cid = 0;\n\tstruct ipv6hdr *hdr;\n\tu8 head[LOWPAN_IPHC_MAX_HC_BUF_LEN] = {};\n\tstruct lowpan_iphc_ctx *dci, *sci, dci_entry, sci_entry;\n\tint ret, ipv6_daddr_type, ipv6_saddr_type;\n\n\tif (skb->protocol != htons(ETH_P_IPV6))\n\t\treturn -EINVAL;\n\n\thdr = ipv6_hdr(skb);\n\thc_ptr = head + 2;\n\n\tpr_debug(\"IPv6 header dump:\\n\\tversion = %d\\n\\tlength  = %d\\n\"\n\t\t \"\\tnexthdr = 0x%02x\\n\\thop_lim = %d\\n\\tdest    = %pI6c\\n\",\n\t\t hdr->version, ntohs(hdr->payload_len), hdr->nexthdr,\n\t\t hdr->hop_limit, &hdr->daddr);\n\n\traw_dump_table(__func__, \"raw skb network header dump\",\n\t\t       skb_network_header(skb), sizeof(struct ipv6hdr));\n\n\t \n\tiphc0 = LOWPAN_DISPATCH_IPHC;\n\tiphc1 = 0;\n\n\traw_dump_table(__func__, \"sending raw skb network uncompressed packet\",\n\t\t       skb->data, skb->len);\n\n\tipv6_daddr_type = ipv6_addr_type(&hdr->daddr);\n\tspin_lock_bh(&lowpan_dev(dev)->ctx.lock);\n\tif (ipv6_daddr_type & IPV6_ADDR_MULTICAST)\n\t\tdci = lowpan_iphc_ctx_get_by_mcast_addr(dev, &hdr->daddr);\n\telse\n\t\tdci = lowpan_iphc_ctx_get_by_addr(dev, &hdr->daddr);\n\tif (dci) {\n\t\tmemcpy(&dci_entry, dci, sizeof(*dci));\n\t\tcid |= dci->id;\n\t}\n\tspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\n\n\tspin_lock_bh(&lowpan_dev(dev)->ctx.lock);\n\tsci = lowpan_iphc_ctx_get_by_addr(dev, &hdr->saddr);\n\tif (sci) {\n\t\tmemcpy(&sci_entry, sci, sizeof(*sci));\n\t\tcid |= (sci->id << 4);\n\t}\n\tspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\n\n\t \n\tif (cid) {\n\t\tiphc1 |= LOWPAN_IPHC_CID;\n\t\tlowpan_push_hc_data(&hc_ptr, &cid, sizeof(cid));\n\t}\n\n\t \n\tiphc0 |= lowpan_iphc_tf_compress(&hc_ptr, hdr);\n\n\t \n\n\t \n\tret = lowpan_nhc_check_compression(skb, hdr, &hc_ptr);\n\tif (ret == -ENOENT)\n\t\tlowpan_push_hc_data(&hc_ptr, &hdr->nexthdr,\n\t\t\t\t    sizeof(hdr->nexthdr));\n\telse\n\t\tiphc0 |= LOWPAN_IPHC_NH;\n\n\t \n\tswitch (hdr->hop_limit) {\n\tcase 1:\n\t\tiphc0 |= LOWPAN_IPHC_HLIM_01;\n\t\tbreak;\n\tcase 64:\n\t\tiphc0 |= LOWPAN_IPHC_HLIM_10;\n\t\tbreak;\n\tcase 255:\n\t\tiphc0 |= LOWPAN_IPHC_HLIM_11;\n\t\tbreak;\n\tdefault:\n\t\tlowpan_push_hc_data(&hc_ptr, &hdr->hop_limit,\n\t\t\t\t    sizeof(hdr->hop_limit));\n\t}\n\n\tipv6_saddr_type = ipv6_addr_type(&hdr->saddr);\n\t \n\tif (ipv6_saddr_type == IPV6_ADDR_ANY) {\n\t\tpr_debug(\"source address is unspecified, setting SAC\\n\");\n\t\tiphc1 |= LOWPAN_IPHC_SAC;\n\t} else {\n\t\tif (sci) {\n\t\t\tiphc1 |= lowpan_compress_ctx_addr(&hc_ptr, dev,\n\t\t\t\t\t\t\t  &hdr->saddr,\n\t\t\t\t\t\t\t  &sci_entry, saddr,\n\t\t\t\t\t\t\t  true);\n\t\t\tiphc1 |= LOWPAN_IPHC_SAC;\n\t\t} else {\n\t\t\tif (ipv6_saddr_type & IPV6_ADDR_LINKLOCAL &&\n\t\t\t    lowpan_is_linklocal_zero_padded(hdr->saddr)) {\n\t\t\t\tiphc1 |= lowpan_compress_addr_64(&hc_ptr, dev,\n\t\t\t\t\t\t\t\t &hdr->saddr,\n\t\t\t\t\t\t\t\t saddr, true);\n\t\t\t\tpr_debug(\"source address unicast link-local %pI6c iphc1 0x%02x\\n\",\n\t\t\t\t\t &hdr->saddr, iphc1);\n\t\t\t} else {\n\t\t\t\tpr_debug(\"send the full source address\\n\");\n\t\t\t\tlowpan_push_hc_data(&hc_ptr,\n\t\t\t\t\t\t    hdr->saddr.s6_addr, 16);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ipv6_daddr_type & IPV6_ADDR_MULTICAST) {\n\t\tpr_debug(\"destination address is multicast: \");\n\t\tiphc1 |= LOWPAN_IPHC_M;\n\t\tif (dci) {\n\t\t\tiphc1 |= lowpan_iphc_mcast_ctx_addr_compress(&hc_ptr,\n\t\t\t\t\t\t\t\t     &dci_entry,\n\t\t\t\t\t\t\t\t     &hdr->daddr);\n\t\t\tiphc1 |= LOWPAN_IPHC_DAC;\n\t\t} else {\n\t\t\tiphc1 |= lowpan_iphc_mcast_addr_compress(&hc_ptr,\n\t\t\t\t\t\t\t\t &hdr->daddr);\n\t\t}\n\t} else {\n\t\tif (dci) {\n\t\t\tiphc1 |= lowpan_compress_ctx_addr(&hc_ptr, dev,\n\t\t\t\t\t\t\t  &hdr->daddr,\n\t\t\t\t\t\t\t  &dci_entry, daddr,\n\t\t\t\t\t\t\t  false);\n\t\t\tiphc1 |= LOWPAN_IPHC_DAC;\n\t\t} else {\n\t\t\tif (ipv6_daddr_type & IPV6_ADDR_LINKLOCAL &&\n\t\t\t    lowpan_is_linklocal_zero_padded(hdr->daddr)) {\n\t\t\t\tiphc1 |= lowpan_compress_addr_64(&hc_ptr, dev,\n\t\t\t\t\t\t\t\t &hdr->daddr,\n\t\t\t\t\t\t\t\t daddr, false);\n\t\t\t\tpr_debug(\"dest address unicast link-local %pI6c iphc1 0x%02x\\n\",\n\t\t\t\t\t &hdr->daddr, iphc1);\n\t\t\t} else {\n\t\t\t\tpr_debug(\"dest address unicast %pI6c\\n\",\n\t\t\t\t\t &hdr->daddr);\n\t\t\t\tlowpan_push_hc_data(&hc_ptr,\n\t\t\t\t\t\t    hdr->daddr.s6_addr, 16);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (iphc0 & LOWPAN_IPHC_NH) {\n\t\tret = lowpan_nhc_do_compression(skb, hdr, &hc_ptr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\thead[0] = iphc0;\n\thead[1] = iphc1;\n\n\tskb_pull(skb, sizeof(struct ipv6hdr));\n\tskb_reset_transport_header(skb);\n\tmemcpy(skb_push(skb, hc_ptr - head), head, hc_ptr - head);\n\tskb_reset_network_header(skb);\n\n\tpr_debug(\"header len %d skb %u\\n\", (int)(hc_ptr - head), skb->len);\n\n\traw_dump_table(__func__, \"raw skb data dump compressed\",\n\t\t       skb->data, skb->len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lowpan_header_compress);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}