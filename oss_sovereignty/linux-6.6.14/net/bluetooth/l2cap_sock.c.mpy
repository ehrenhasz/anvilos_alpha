{
  "module_name": "l2cap_sock.c",
  "hash_id": "d94ca89112d1c9a73db4dbee0f3b84fb376abf4055ed95263dac2dafe0f2ec1a",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/l2cap_sock.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/filter.h>\n#include <linux/sched/signal.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"smp.h\"\n\nstatic struct bt_sock_list l2cap_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)\n};\n\nstatic const struct proto_ops l2cap_sock_ops;\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent);\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t     int proto, gfp_t prio, int kern);\nstatic void l2cap_sock_cleanup_listen(struct sock *parent);\n\nbool l2cap_is_socket(struct socket *sock)\n{\n\treturn sock && sock->ops == &l2cap_sock_ops;\n}\nEXPORT_SYMBOL(l2cap_is_socket);\n\nstatic int l2cap_validate_bredr_psm(u16 psm)\n{\n\t \n\tif ((psm & 0x0101) != 0x0001)\n\t\treturn -EINVAL;\n\n\t \n\tif (psm < L2CAP_PSM_DYN_START && !capable(CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int l2cap_validate_le_psm(u16 psm)\n{\n\t \n\tif (psm > L2CAP_PSM_LE_DYN_END)\n\t\treturn -EINVAL;\n\n\t \n\tif (psm < L2CAP_PSM_LE_DYN_START && !capable(CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\n\tif (la.l2_cid && la.l2_psm)\n\t\treturn -EINVAL;\n\n\tif (!bdaddr_type_is_valid(la.l2_bdaddr_type))\n\t\treturn -EINVAL;\n\n\tif (bdaddr_type_is_le(la.l2_bdaddr_type)) {\n\t\t \n\t\tif (la.l2_cid &&\n\t\t    la.l2_cid != cpu_to_le16(L2CAP_CID_ATT))\n\t\t\treturn -EINVAL;\n\t}\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (la.l2_psm) {\n\t\t__u16 psm = __le16_to_cpu(la.l2_psm);\n\n\t\tif (la.l2_bdaddr_type == BDADDR_BREDR)\n\t\t\terr = l2cap_validate_bredr_psm(psm);\n\t\telse\n\t\t\terr = l2cap_validate_le_psm(psm);\n\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tbacpy(&chan->src, &la.l2_bdaddr);\n\tchan->src_type = la.l2_bdaddr_type;\n\n\tif (la.l2_cid)\n\t\terr = l2cap_add_scid(chan, __le16_to_cpu(la.l2_cid));\n\telse\n\t\terr = l2cap_add_psm(chan, &la.l2_bdaddr, la.l2_psm);\n\n\tif (err < 0)\n\t\tgoto done;\n\n\tswitch (chan->chan_type) {\n\tcase L2CAP_CHAN_CONN_LESS:\n\t\tif (__le16_to_cpu(la.l2_psm) == L2CAP_PSM_3DSP)\n\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\tbreak;\n\tcase L2CAP_CHAN_CONN_ORIENTED:\n\t\tif (__le16_to_cpu(la.l2_psm) == L2CAP_PSM_SDP ||\n\t\t    __le16_to_cpu(la.l2_psm) == L2CAP_PSM_RFCOMM)\n\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\tbreak;\n\tcase L2CAP_CHAN_RAW:\n\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\tbreak;\n\tcase L2CAP_CHAN_FIXED:\n\t\t \n\t\tset_bit(FLAG_HOLD_HCI_CONN, &chan->flags);\n\t\tbreak;\n\t}\n\n\t \n\tif (chan->psm && bdaddr_type_is_le(chan->src_type) &&\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL)\n\t\tchan->mode = L2CAP_MODE_LE_FLOWCTL;\n\n\tchan->state = BT_BOUND;\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\tbool zapped;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\tzapped = sock_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\n\tif (zapped)\n\t\treturn -EINVAL;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\n\tif (la.l2_cid && la.l2_psm)\n\t\treturn -EINVAL;\n\n\tif (!bdaddr_type_is_valid(la.l2_bdaddr_type))\n\t\treturn -EINVAL;\n\n\t \n\tif (chan->src_type == BDADDR_BREDR && bacmp(&chan->src, BDADDR_ANY) &&\n\t    bdaddr_type_is_le(la.l2_bdaddr_type)) {\n\t\t \n\t\tif (chan->scid != L2CAP_CID_ATT ||\n\t\t    la.l2_cid != cpu_to_le16(L2CAP_CID_ATT))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tchan->src_type = BDADDR_LE_PUBLIC;\n\t}\n\n\tif (chan->src_type != BDADDR_BREDR && la.l2_bdaddr_type == BDADDR_BREDR)\n\t\treturn -EINVAL;\n\n\tif (bdaddr_type_is_le(la.l2_bdaddr_type)) {\n\t\t \n\t\tif (la.l2_cid &&\n\t\t    la.l2_cid != cpu_to_le16(L2CAP_CID_ATT))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chan->psm && bdaddr_type_is_le(chan->src_type) &&\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL)\n\t\tchan->mode = L2CAP_MODE_LE_FLOWCTL;\n\n\terr = l2cap_chan_connect(chan, la.l2_psm, __le16_to_cpu(la.l2_cid),\n\t\t\t\t &la.l2_bdaddr, la.l2_bdaddr_type);\n\tif (err)\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\t\t sock_sndtimeo(sk, flags & O_NONBLOCK));\n\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int l2cap_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\tbreak;\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (!enable_ecred) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (!disable_ertm)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\t \n\tatomic_set(&chan->nesting, L2CAP_NESTING_PARENT);\n\n\tchan->state = BT_LISTEN;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_accept(struct socket *sock, struct socket *newsock,\n\t\t\t     int flags, bool kern)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = sock->sk, *nsk;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock_nested(sk, L2CAP_NESTING_PARENT);\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t \n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tnsk = bt_accept_dequeue(sk, newsock);\n\t\tif (nsk)\n\t\t\tbreak;\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\n\t\tlock_sock_nested(sk, L2CAP_NESTING_PARENT);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", nsk);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (peer && sk->sk_state != BT_CONNECTED &&\n\t    sk->sk_state != BT_CONNECT && sk->sk_state != BT_CONNECT2 &&\n\t    sk->sk_state != BT_CONFIG)\n\t\treturn -ENOTCONN;\n\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\taddr->sa_family = AF_BLUETOOTH;\n\n\tla->l2_psm = chan->psm;\n\n\tif (peer) {\n\t\tbacpy(&la->l2_bdaddr, &chan->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t\tla->l2_bdaddr_type = chan->dst_type;\n\t} else {\n\t\tbacpy(&la->l2_bdaddr, &chan->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t\tla->l2_bdaddr_type = chan->src_type;\n\t}\n\n\treturn sizeof(struct sockaddr_l2);\n}\n\nstatic int l2cap_get_mode(struct l2cap_chan *chan)\n{\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\treturn BT_MODE_BASIC;\n\tcase L2CAP_MODE_ERTM:\n\t\treturn BT_MODE_ERTM;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn BT_MODE_STREAMING;\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\treturn BT_MODE_LE_FLOWCTL;\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\treturn BT_MODE_EXT_FLOWCTL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int l2cap_sock_getsockopt_old(struct socket *sock, int optname,\n\t\t\t\t     char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct l2cap_options opts;\n\tstruct l2cap_conninfo cinfo;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase L2CAP_OPTIONS:\n\t\t \n\t\tif (bdaddr_type_is_le(chan->src_type) &&\n\t\t    chan->scid != L2CAP_CID_ATT) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (chan->mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\tcase L2CAP_MODE_ERTM:\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tmemset(&opts, 0, sizeof(opts));\n\t\topts.imtu     = chan->imtu;\n\t\topts.omtu     = chan->omtu;\n\t\topts.flush_to = chan->flush_to;\n\t\topts.mode     = chan->mode;\n\t\topts.fcs      = chan->fcs;\n\t\topts.max_tx   = chan->max_tx;\n\t\topts.txwin_size = chan->tx_win;\n\n\t\tBT_DBG(\"mode 0x%2.2x\", chan->mode);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *) &opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase L2CAP_LM:\n\t\tswitch (chan->sec_level) {\n\t\tcase BT_SECURITY_LOW:\n\t\t\topt = L2CAP_LM_AUTH;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_HIGH:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |\n\t\t\t      L2CAP_LM_SECURE;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_FIPS:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |\n\t\t\t      L2CAP_LM_SECURE | L2CAP_LM_FIPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\topt = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (test_bit(FLAG_ROLE_SWITCH, &chan->flags))\n\t\t\topt |= L2CAP_LM_MASTER;\n\n\t\tif (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))\n\t\t\topt |= L2CAP_LM_RELIABLE;\n\n\t\tif (put_user(opt, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase L2CAP_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t    !(sk->sk_state == BT_CONNECT2 &&\n\t\t      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = chan->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, chan->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *) &cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct bt_security sec;\n\tstruct bt_power pwr;\n\tu32 phys;\n\tint len, mode, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t    chan->chan_type != L2CAP_CHAN_FIXED &&\n\t\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&sec, 0, sizeof(sec));\n\t\tif (chan->conn) {\n\t\t\tsec.level = chan->conn->hcon->sec_level;\n\n\t\t\tif (sk->sk_state == BT_CONNECTED)\n\t\t\t\tsec.key_size = chan->conn->hcon->enc_key_size;\n\t\t} else {\n\t\t\tsec.level = chan->sec_level;\n\t\t}\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_FLUSHABLE:\n\t\tif (put_user(test_bit(FLAG_FLUSHABLE, &chan->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_POWER:\n\t\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM\n\t\t    && sk->sk_type != SOCK_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpwr.force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\n\t\tlen = min_t(unsigned int, len, sizeof(pwr));\n\t\tif (copy_to_user(optval, (char *) &pwr, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_CHANNEL_POLICY:\n\t\tif (put_user(chan->chan_policy, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_SNDMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(chan->omtu, (u16 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_RCVMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(chan->imtu, (u16 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_PHY:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tphys = hci_conn_get_phy(chan->conn->hcon);\n\n\t\tif (put_user(phys, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_MODE:\n\t\tif (!enable_ecred) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmode = l2cap_get_mode(chan);\n\t\tif (mode < 0) {\n\t\t\terr = mode;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(mode, (u8 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic bool l2cap_valid_mtu(struct l2cap_chan *chan, u16 mtu)\n{\n\tswitch (chan->scid) {\n\tcase L2CAP_CID_ATT:\n\t\tif (mtu < L2CAP_LE_MIN_MTU)\n\t\t\treturn false;\n\t\tbreak;\n\n\tdefault:\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int l2cap_sock_setsockopt_old(struct socket *sock, int optname,\n\t\t\t\t     sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct l2cap_options opts;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase L2CAP_OPTIONS:\n\t\tif (bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_state == BT_CONNECTED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.imtu     = chan->imtu;\n\t\topts.omtu     = chan->omtu;\n\t\topts.flush_to = chan->flush_to;\n\t\topts.mode     = chan->mode;\n\t\topts.fcs      = chan->fcs;\n\t\topts.max_tx   = chan->max_tx;\n\t\topts.txwin_size = chan->tx_win;\n\n\t\tlen = min_t(unsigned int, sizeof(opts), optlen);\n\t\tif (copy_from_sockptr(&opts, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opts.txwin_size > L2CAP_DEFAULT_EXT_WINDOW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!l2cap_valid_mtu(chan, opts.imtu)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (opts.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tclear_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\t\tbreak;\n\t\tcase L2CAP_MODE_ERTM:\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tif (!disable_ertm)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tchan->mode = opts.mode;\n\n\t\tBT_DBG(\"mode 0x%2.2x\", chan->mode);\n\n\t\tchan->imtu = opts.imtu;\n\t\tchan->omtu = opts.omtu;\n\t\tchan->fcs  = opts.fcs;\n\t\tchan->max_tx = opts.max_tx;\n\t\tchan->tx_win = opts.txwin_size;\n\t\tchan->flush_to = opts.flush_to;\n\t\tbreak;\n\n\tcase L2CAP_LM:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & L2CAP_LM_FIPS) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & L2CAP_LM_AUTH)\n\t\t\tchan->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & L2CAP_LM_ENCRYPT)\n\t\t\tchan->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & L2CAP_LM_SECURE)\n\t\t\tchan->sec_level = BT_SECURITY_HIGH;\n\n\t\tif (opt & L2CAP_LM_MASTER)\n\t\t\tset_bit(FLAG_ROLE_SWITCH, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_ROLE_SWITCH, &chan->flags);\n\n\t\tif (opt & L2CAP_LM_RELIABLE)\n\t\t\tset_bit(FLAG_FORCE_RELIABLE, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_FORCE_RELIABLE, &chan->flags);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_set_mode(struct l2cap_chan *chan, u8 mode)\n{\n\tswitch (mode) {\n\tcase BT_MODE_BASIC:\n\t\tif (bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_BASIC;\n\t\tclear_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\tbreak;\n\tcase BT_MODE_ERTM:\n\t\tif (!disable_ertm || bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_ERTM;\n\t\tbreak;\n\tcase BT_MODE_STREAMING:\n\t\tif (!disable_ertm || bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_STREAMING;\n\t\tbreak;\n\tcase BT_MODE_LE_FLOWCTL:\n\t\tif (!bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_LE_FLOWCTL;\n\t\tbreak;\n\tcase BT_MODE_EXT_FLOWCTL:\n\t\t \n\t\tif (!bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_EXT_FLOWCTL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tchan->mode = mode;\n\n\treturn 0;\n}\n\nstatic int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct bt_security sec;\n\tstruct bt_power pwr;\n\tstruct l2cap_conn *conn;\n\tint len, err = 0;\n\tu32 opt;\n\tu16 mtu;\n\tu8 mode;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t    chan->chan_type != L2CAP_CHAN_FIXED &&\n\t\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_sockptr(&sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level < BT_SECURITY_LOW ||\n\t\t    sec.level > BT_SECURITY_FIPS) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->sec_level = sec.level;\n\n\t\tif (!chan->conn)\n\t\t\tbreak;\n\n\t\tconn = chan->conn;\n\n\t\t \n\t\tif (chan->scid == L2CAP_CID_ATT) {\n\t\t\tif (smp_conn_security(conn->hcon, sec.level)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tset_bit(FLAG_PENDING_SECURITY, &chan->flags);\n\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\tchan->state = BT_CONFIG;\n\n\t\t \n\t\t} else if ((sk->sk_state == BT_CONNECT2 &&\n\t\t\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) ||\n\t\t\t   sk->sk_state == BT_CONNECTED) {\n\t\t\tif (!l2cap_chan_check_security(chan, true))\n\t\t\t\tset_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\t\t\telse\n\t\t\t\tsk->sk_state_change(sk);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt) {\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\t\tset_bit(FLAG_DEFER_SETUP, &chan->flags);\n\t\t} else {\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\t\tclear_bit(FLAG_DEFER_SETUP, &chan->flags);\n\t\t}\n\t\tbreak;\n\n\tcase BT_FLUSHABLE:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > BT_FLUSHABLE_ON) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt == BT_FLUSHABLE_OFF) {\n\t\t\tconn = chan->conn;\n\t\t\t \n\t\t\tif (!conn || !lmp_no_flush_capable(conn->hcon->hdev)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(FLAG_FLUSHABLE, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_FLUSHABLE, &chan->flags);\n\t\tbreak;\n\n\tcase BT_POWER:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpwr.force_active = BT_POWER_FORCE_ACTIVE_ON;\n\n\t\tlen = min_t(unsigned int, sizeof(pwr), optlen);\n\t\tif (copy_from_sockptr(&pwr, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pwr.force_active)\n\t\t\tset_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\t\tbreak;\n\n\tcase BT_CHANNEL_POLICY:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > BT_CHANNEL_POLICY_AMP_PREFERRED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->mode != L2CAP_MODE_ERTM &&\n\t\t    chan->mode != L2CAP_MODE_STREAMING) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->chan_policy = (u8) opt;\n\n\t\tif (sk->sk_state == BT_CONNECTED &&\n\t\t    chan->move_role == L2CAP_MOVE_ROLE_NONE)\n\t\t\tl2cap_move_start(chan);\n\n\t\tbreak;\n\n\tcase BT_SNDMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = -EPERM;\n\t\tbreak;\n\n\tcase BT_RCVMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->mode == L2CAP_MODE_LE_FLOWCTL &&\n\t\t    sk->sk_state == BT_CONNECTED) {\n\t\t\terr = -EISCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&mtu, optval, sizeof(u16))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->mode == L2CAP_MODE_EXT_FLOWCTL &&\n\t\t    sk->sk_state == BT_CONNECTED)\n\t\t\terr = l2cap_chan_reconfigure(chan, mtu);\n\t\telse\n\t\t\tchan->imtu = mtu;\n\n\t\tbreak;\n\n\tcase BT_MODE:\n\t\tif (!enable_ecred) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\n\t\tBT_DBG(\"sk->sk_state %u\", sk->sk_state);\n\n\t\tif (sk->sk_state != BT_BOUND) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&mode, optval, sizeof(u8))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tBT_DBG(\"mode %u\", mode);\n\n\t\terr = l2cap_set_mode(chan, mode);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tBT_DBG(\"mode 0x%2.2x\", chan->mode);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state != BT_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tlock_sock(sk);\n\terr = bt_sock_wait_ready(sk, msg->msg_flags);\n\trelease_sock(sk);\n\tif (err)\n\t\treturn err;\n\n\tl2cap_chan_lock(chan);\n\terr = l2cap_chan_send(chan, msg, len);\n\tl2cap_chan_unlock(chan);\n\n\treturn err;\n}\n\nstatic int l2cap_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tint err;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 && test_bit(BT_SK_DEFER_SETUP,\n\t\t\t\t\t\t    &bt_sk(sk)->flags)) {\n\t\tif (pi->chan->mode == L2CAP_MODE_EXT_FLOWCTL) {\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\t\tpi->chan->state = BT_CONNECTED;\n\t\t\t__l2cap_ecred_conn_rsp_defer(pi->chan);\n\t\t} else if (bdaddr_type_is_le(pi->chan->src_type)) {\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\t\tpi->chan->state = BT_CONNECTED;\n\t\t\t__l2cap_le_connect_rsp_defer(pi->chan);\n\t\t} else {\n\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\tpi->chan->state = BT_CONFIG;\n\t\t\t__l2cap_connect_rsp_defer(pi->chan);\n\t\t}\n\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\trelease_sock(sk);\n\n\tif (sock->type == SOCK_STREAM)\n\t\terr = bt_sock_stream_recvmsg(sock, msg, len, flags);\n\telse\n\t\terr = bt_sock_recvmsg(sock, msg, len, flags);\n\n\tif (pi->chan->mode != L2CAP_MODE_ERTM)\n\t\treturn err;\n\n\t \n\n\tlock_sock(sk);\n\n\tif (!test_bit(CONN_LOCAL_BUSY, &pi->chan->conn_state))\n\t\tgoto done;\n\n\tif (pi->rx_busy_skb) {\n\t\tif (!__sock_queue_rcv_skb(sk, pi->rx_busy_skb))\n\t\t\tpi->rx_busy_skb = NULL;\n\t\telse\n\t\t\tgoto done;\n\t}\n\n\t \n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf >> 1)\n\t\tl2cap_chan_busy(pi->chan, 0);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\n \nstatic void l2cap_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %s\", sk, state_to_string(sk->sk_state));\n\n\t \n\n\tl2cap_chan_put(l2cap_pi(sk)->chan);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic int __l2cap_wait_ack(struct sock *sk, struct l2cap_chan *chan)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint err = 0;\n\tint timeo = L2CAP_WAIT_ACK_POLL_PERIOD;\n\t \n\tunsigned long timeout = jiffies + L2CAP_WAIT_ACK_TIMEOUT;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tdo {\n\t\tBT_DBG(\"Waiting for %d ACKs, timeout %04d ms\",\n\t\t       chan->unacked_frames, time_after(jiffies, timeout) ? 0 :\n\t\t       jiffies_to_msecs(timeout - jiffies));\n\n\t\tif (!timeo)\n\t\t\ttimeo = L2CAP_WAIT_ACK_POLL_PERIOD;\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\terr = -ENOLINK;\n\t\t\tbreak;\n\t\t}\n\n\t} while (chan->unacked_frames > 0 &&\n\t\t chan->state == BT_CONNECTED);\n\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn err;\n}\n\nstatic int l2cap_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan;\n\tstruct l2cap_conn *conn;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p, how %d\", sock, sk, how);\n\n\t \n\thow++;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\n\tif ((sk->sk_shutdown & how) == how)\n\t\tgoto shutdown_already;\n\n\tBT_DBG(\"Handling sock shutdown\");\n\n\t \n\tsock_hold(sk);\n\n\tchan = l2cap_pi(sk)->chan;\n\t \n\tl2cap_chan_hold(chan);\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\tif (chan->mode == L2CAP_MODE_ERTM &&\n\t    chan->unacked_frames > 0 &&\n\t    chan->state == BT_CONNECTED) {\n\t\terr = __l2cap_wait_ack(sk, chan);\n\n\t\t \n\t\tif ((sk->sk_shutdown & how) == how)\n\t\t\tgoto shutdown_matched;\n\t}\n\n\t \n\tif ((how & RCV_SHUTDOWN) && !(sk->sk_shutdown & RCV_SHUTDOWN)) {\n\t\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\t\tif ((sk->sk_shutdown & how) == how)\n\t\t\tgoto shutdown_matched;\n\t}\n\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\trelease_sock(sk);\n\n\tl2cap_chan_lock(chan);\n\tconn = chan->conn;\n\tif (conn)\n\t\t \n\t\tl2cap_conn_get(conn);\n\tl2cap_chan_unlock(chan);\n\n\tif (conn)\n\t\t \n\t\tmutex_lock(&conn->chan_lock);\n\n\tl2cap_chan_lock(chan);\n\tl2cap_chan_close(chan, 0);\n\tl2cap_chan_unlock(chan);\n\n\tif (conn) {\n\t\tmutex_unlock(&conn->chan_lock);\n\t\tl2cap_conn_put(conn);\n\t}\n\n\tlock_sock(sk);\n\n\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t    !(current->flags & PF_EXITING))\n\t\terr = bt_sock_wait_state(sk, BT_CLOSED,\n\t\t\t\t\t sk->sk_lingertime);\n\nshutdown_matched:\n\tl2cap_chan_put(chan);\n\tsock_put(sk);\n\nshutdown_already:\n\tif (!err && sk->sk_err)\n\t\terr = -sk->sk_err;\n\n\trelease_sock(sk);\n\n\tBT_DBG(\"Sock shutdown complete err: %d\", err);\n\n\treturn err;\n}\n\nstatic int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tl2cap_sock_cleanup_listen(sk);\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\n\terr = l2cap_sock_shutdown(sock, SHUT_RDWR);\n\tchan = l2cap_pi(sk)->chan;\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn err;\n}\n\nstatic void l2cap_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p state %s\", parent,\n\t       state_to_string(parent->sk_state));\n\n\t \n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\t\tBT_DBG(\"child chan %p state %s\", chan,\n\t\t       state_to_string(chan->state));\n\n\t\tl2cap_chan_hold(chan);\n\t\tl2cap_chan_lock(chan);\n\n\t\t__clear_chan_timer(chan);\n\t\tl2cap_chan_close(chan, ECONNRESET);\n\t\tl2cap_sock_kill(sk);\n\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t}\n}\n\nstatic struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk, *parent = chan->data;\n\n\tlock_sock(parent);\n\n\t \n\tif (sk_acceptq_is_full(parent)) {\n\t\tBT_DBG(\"backlog full %d\", parent->sk_ack_backlog);\n\t\trelease_sock(parent);\n\t\treturn NULL;\n\t}\n\n\tsk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,\n\t\t\t      GFP_ATOMIC, 0);\n\tif (!sk) {\n\t\trelease_sock(parent);\n\t\treturn NULL;\n        }\n\n\tbt_sock_reclassify_lock(sk, BTPROTO_L2CAP);\n\n\tl2cap_sock_init(sk, parent);\n\n\tbt_accept_enqueue(parent, sk, false);\n\n\trelease_sock(parent);\n\n\treturn l2cap_pi(sk)->chan;\n}\n\nstatic int l2cap_sock_recv_cb(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = chan->data;\n\tint err;\n\n\tlock_sock(sk);\n\n\tif (l2cap_pi(sk)->rx_busy_skb) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tif (chan->mode != L2CAP_MODE_ERTM &&\n\t    chan->mode != L2CAP_MODE_STREAMING) {\n\t\t \n\t\terr = sk_filter(sk, skb);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\terr = __sock_queue_rcv_skb(sk, skb);\n\n\t \n\tif (err < 0 && chan->mode == L2CAP_MODE_ERTM) {\n\t\tl2cap_pi(sk)->rx_busy_skb = skb;\n\t\tl2cap_chan_busy(chan, 1);\n\t\terr = 0;\n\t}\n\ndone:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic void l2cap_sock_close_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tif (!sk)\n\t\treturn;\n\n\tl2cap_sock_kill(sk);\n}\n\nstatic void l2cap_sock_teardown_cb(struct l2cap_chan *chan, int err)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\t \n\tlock_sock_nested(sk, atomic_read(&chan->nesting));\n\n\tparent = bt_sk(sk)->parent;\n\n\tswitch (chan->state) {\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\tcase BT_CLOSED:\n\t\tbreak;\n\tcase BT_LISTEN:\n\t\tl2cap_sock_cleanup_listen(sk);\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tbreak;\n\tdefault:\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tsk->sk_err = err;\n\n\t\tif (parent) {\n\t\t\tbt_accept_unlink(sk);\n\t\t\tparent->sk_data_ready(parent);\n\t\t} else {\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\t \n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n}\n\nstatic void l2cap_sock_state_change_cb(struct l2cap_chan *chan, int state,\n\t\t\t\t       int err)\n{\n\tstruct sock *sk = chan->data;\n\n\tsk->sk_state = state;\n\n\tif (err)\n\t\tsk->sk_err = err;\n}\n\nstatic struct sk_buff *l2cap_sock_alloc_skb_cb(struct l2cap_chan *chan,\n\t\t\t\t\t       unsigned long hdr_len,\n\t\t\t\t\t       unsigned long len, int nb)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tl2cap_chan_unlock(chan);\n\tskb = bt_skb_send_alloc(sk, hdr_len + len, nb, &err);\n\tl2cap_chan_lock(chan);\n\n\tif (!skb)\n\t\treturn ERR_PTR(err);\n\n\t \n\tif (chan->state != BT_CONNECTED) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-ENOTCONN);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\n\tbt_cb(skb)->l2cap.chan = chan;\n\n\treturn skb;\n}\n\nstatic void l2cap_sock_ready_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tlock_sock(sk);\n\n\tparent = bt_sk(sk)->parent;\n\n\tBT_DBG(\"sk %p, parent %p\", sk, parent);\n\n\tsk->sk_state = BT_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tif (parent)\n\t\tparent->sk_data_ready(parent);\n\n\trelease_sock(sk);\n}\n\nstatic void l2cap_sock_defer_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *parent, *sk = chan->data;\n\n\tlock_sock(sk);\n\n\tparent = bt_sk(sk)->parent;\n\tif (parent)\n\t\tparent->sk_data_ready(parent);\n\n\trelease_sock(sk);\n}\n\nstatic void l2cap_sock_resume_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tif (test_and_clear_bit(FLAG_PENDING_SECURITY, &chan->flags)) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tchan->state = BT_CONNECTED;\n\t}\n\n\tclear_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\tsk->sk_state_change(sk);\n}\n\nstatic void l2cap_sock_set_shutdown_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\trelease_sock(sk);\n}\n\nstatic long l2cap_sock_get_sndtimeo_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\treturn sk->sk_sndtimeo;\n}\n\nstatic struct pid *l2cap_sock_get_peer_pid_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\treturn sk->sk_peer_pid;\n}\n\nstatic void l2cap_sock_suspend_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tset_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\tsk->sk_state_change(sk);\n}\n\nstatic int l2cap_sock_filter(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = chan->data;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn sk_filter(sk, skb);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct l2cap_ops l2cap_chan_ops = {\n\t.name\t\t\t= \"L2CAP Socket Interface\",\n\t.new_connection\t\t= l2cap_sock_new_connection_cb,\n\t.recv\t\t\t= l2cap_sock_recv_cb,\n\t.close\t\t\t= l2cap_sock_close_cb,\n\t.teardown\t\t= l2cap_sock_teardown_cb,\n\t.state_change\t\t= l2cap_sock_state_change_cb,\n\t.ready\t\t\t= l2cap_sock_ready_cb,\n\t.defer\t\t\t= l2cap_sock_defer_cb,\n\t.resume\t\t\t= l2cap_sock_resume_cb,\n\t.suspend\t\t= l2cap_sock_suspend_cb,\n\t.set_shutdown\t\t= l2cap_sock_set_shutdown_cb,\n\t.get_sndtimeo\t\t= l2cap_sock_get_sndtimeo_cb,\n\t.get_peer_pid\t\t= l2cap_sock_get_peer_pid_cb,\n\t.alloc_skb\t\t= l2cap_sock_alloc_skb_cb,\n\t.filter\t\t\t= l2cap_sock_filter,\n};\n\nstatic void l2cap_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (l2cap_pi(sk)->chan) {\n\t\tl2cap_pi(sk)->chan->data = NULL;\n\t\tl2cap_chan_put(l2cap_pi(sk)->chan);\n\t}\n\n\tif (l2cap_pi(sk)->rx_busy_skb) {\n\t\tkfree_skb(l2cap_pi(sk)->rx_busy_skb);\n\t\tl2cap_pi(sk)->rx_busy_skb = NULL;\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void l2cap_skb_msg_name(struct sk_buff *skb, void *msg_name,\n\t\t\t       int *msg_namelen)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_l2 *, la, msg_name);\n\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\tla->l2_family = AF_BLUETOOTH;\n\tla->l2_psm = bt_cb(skb)->l2cap.psm;\n\tbacpy(&la->l2_bdaddr, &bt_cb(skb)->l2cap.bdaddr);\n\n\t*msg_namelen = sizeof(struct sockaddr_l2);\n}\n\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tstruct l2cap_chan *pchan = l2cap_pi(parent)->chan;\n\n\t\tsk->sk_type = parent->sk_type;\n\t\tbt_sk(sk)->flags = bt_sk(parent)->flags;\n\n\t\tchan->chan_type = pchan->chan_type;\n\t\tchan->imtu = pchan->imtu;\n\t\tchan->omtu = pchan->omtu;\n\t\tchan->conf_state = pchan->conf_state;\n\t\tchan->mode = pchan->mode;\n\t\tchan->fcs  = pchan->fcs;\n\t\tchan->max_tx = pchan->max_tx;\n\t\tchan->tx_win = pchan->tx_win;\n\t\tchan->tx_win_max = pchan->tx_win_max;\n\t\tchan->sec_level = pchan->sec_level;\n\t\tchan->flags = pchan->flags;\n\t\tchan->tx_credits = pchan->tx_credits;\n\t\tchan->rx_credits = pchan->rx_credits;\n\n\t\tif (chan->chan_type == L2CAP_CHAN_FIXED) {\n\t\t\tchan->scid = pchan->scid;\n\t\t\tchan->dcid = pchan->scid;\n\t\t}\n\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tswitch (sk->sk_type) {\n\t\tcase SOCK_RAW:\n\t\t\tchan->chan_type = L2CAP_CHAN_RAW;\n\t\t\tbreak;\n\t\tcase SOCK_DGRAM:\n\t\t\tchan->chan_type = L2CAP_CHAN_CONN_LESS;\n\t\t\tbt_sk(sk)->skb_msg_name = l2cap_skb_msg_name;\n\t\t\tbreak;\n\t\tcase SOCK_SEQPACKET:\n\t\tcase SOCK_STREAM:\n\t\t\tchan->chan_type = L2CAP_CHAN_CONN_ORIENTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->imtu = L2CAP_DEFAULT_MTU;\n\t\tchan->omtu = 0;\n\t\tif (!disable_ertm && sk->sk_type == SOCK_STREAM) {\n\t\t\tchan->mode = L2CAP_MODE_ERTM;\n\t\t\tset_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\t} else {\n\t\t\tchan->mode = L2CAP_MODE_BASIC;\n\t\t}\n\n\t\tl2cap_chan_set_defaults(chan);\n\t}\n\n\t \n\tchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n\n\tchan->data = sk;\n\tchan->ops = &l2cap_chan_ops;\n}\n\nstatic struct proto l2cap_proto = {\n\t.name\t\t= \"L2CAP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct l2cap_pinfo)\n};\n\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t     int proto, gfp_t prio, int kern)\n{\n\tstruct sock *sk;\n\tstruct l2cap_chan *chan;\n\n\tsk = bt_sock_alloc(net, sock, &l2cap_proto, proto, prio, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsk->sk_destruct = l2cap_sock_destruct;\n\tsk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;\n\n\tchan = l2cap_chan_create();\n\tif (!chan) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\tl2cap_chan_hold(chan);\n\n\tl2cap_pi(sk)->chan = chan;\n\n\treturn sk;\n}\n\nstatic int l2cap_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t     int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsock->ops = &l2cap_sock_ops;\n\n\tsk = l2cap_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tl2cap_sock_init(sk, NULL);\n\tbt_sock_link(&l2cap_sk_list, sk);\n\treturn 0;\n}\n\nstatic const struct proto_ops l2cap_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= l2cap_sock_release,\n\t.bind\t\t= l2cap_sock_bind,\n\t.connect\t= l2cap_sock_connect,\n\t.listen\t\t= l2cap_sock_listen,\n\t.accept\t\t= l2cap_sock_accept,\n\t.getname\t= l2cap_sock_getname,\n\t.sendmsg\t= l2cap_sock_sendmsg,\n\t.recvmsg\t= l2cap_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= l2cap_sock_shutdown,\n\t.setsockopt\t= l2cap_sock_setsockopt,\n\t.getsockopt\t= l2cap_sock_getsockopt\n};\n\nstatic const struct net_proto_family l2cap_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= l2cap_sock_create,\n};\n\nint __init l2cap_init_sockets(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_l2) > sizeof(struct sockaddr));\n\n\terr = proto_register(&l2cap_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_L2CAP, &l2cap_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"L2CAP socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"l2cap\", &l2cap_sk_list,\n\t\t\t     NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create L2CAP proc file\");\n\t\tbt_sock_unregister(BTPROTO_L2CAP);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"L2CAP socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&l2cap_proto);\n\treturn err;\n}\n\nvoid l2cap_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"l2cap\");\n\tbt_sock_unregister(BTPROTO_L2CAP);\n\tproto_unregister(&l2cap_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}