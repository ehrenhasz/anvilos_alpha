{
  "module_name": "eir.h",
  "hash_id": "675f6554e7af7838924bbae25c821e57dd663c5353c365be8a0f1f5581045018",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/eir.h",
  "human_readable_source": " \n \n\n#include <asm/unaligned.h>\n\nvoid eir_create(struct hci_dev *hdev, u8 *data);\n\nu8 eir_create_adv_data(struct hci_dev *hdev, u8 instance, u8 *ptr);\nu8 eir_create_scan_rsp(struct hci_dev *hdev, u8 instance, u8 *ptr);\nu8 eir_create_per_adv_data(struct hci_dev *hdev, u8 instance, u8 *ptr);\n\nu8 eir_append_local_name(struct hci_dev *hdev, u8 *eir, u8 ad_len);\nu8 eir_append_appearance(struct hci_dev *hdev, u8 *ptr, u8 ad_len);\nu8 eir_append_service_data(u8 *eir, u16 eir_len, u16 uuid, u8 *data,\n\t\t\t   u8 data_len);\n\nstatic inline u16 eir_precalc_len(u8 data_len)\n{\n\treturn sizeof(u8) * 2 + data_len;\n}\n\nstatic inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type,\n\t\t\t\t  u8 *data, u8 data_len)\n{\n\teir[eir_len++] = sizeof(type) + data_len;\n\teir[eir_len++] = type;\n\tmemcpy(&eir[eir_len], data, data_len);\n\teir_len += data_len;\n\n\treturn eir_len;\n}\n\nstatic inline u16 eir_append_le16(u8 *eir, u16 eir_len, u8 type, u16 data)\n{\n\teir[eir_len++] = sizeof(type) + sizeof(data);\n\teir[eir_len++] = type;\n\tput_unaligned_le16(data, &eir[eir_len]);\n\teir_len += sizeof(data);\n\n\treturn eir_len;\n}\n\nstatic inline u16 eir_skb_put_data(struct sk_buff *skb, u8 type, u8 *data, u8 data_len)\n{\n\tu8 *eir;\n\tu16 eir_len;\n\n\teir_len\t= eir_precalc_len(data_len);\n\teir = skb_put(skb, eir_len);\n\tWARN_ON(sizeof(type) + data_len > U8_MAX);\n\teir[0] = sizeof(type) + data_len;\n\teir[1] = type;\n\tmemcpy(&eir[2], data, data_len);\n\n\treturn eir_len;\n}\n\nstatic inline void *eir_get_data(u8 *eir, size_t eir_len, u8 type,\n\t\t\t\t size_t *data_len)\n{\n\tsize_t parsed = 0;\n\n\tif (eir_len < 2)\n\t\treturn NULL;\n\n\twhile (parsed < eir_len - 1) {\n\t\tu8 field_len = eir[0];\n\n\t\tif (field_len == 0)\n\t\t\tbreak;\n\n\t\tparsed += field_len + 1;\n\n\t\tif (parsed > eir_len)\n\t\t\tbreak;\n\n\t\tif (eir[1] != type) {\n\t\t\teir += field_len + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (field_len == 1)\n\t\t\treturn NULL;\n\n\t\tif (data_len)\n\t\t\t*data_len = field_len - 1;\n\n\t\treturn &eir[2];\n\t}\n\n\treturn NULL;\n}\n\nvoid *eir_get_service_data(u8 *eir, size_t eir_len, u16 uuid, size_t *len);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}