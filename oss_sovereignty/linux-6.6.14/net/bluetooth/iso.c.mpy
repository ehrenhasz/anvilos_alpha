{
  "module_name": "iso.c",
  "hash_id": "725c167f9c7de2b72fa3c4c680dcdaf46bf7a455e0e9b5d05a967965f34e782d",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/iso.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/signal.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/iso.h>\n\nstatic const struct proto_ops iso_sock_ops;\n\nstatic struct bt_sock_list iso_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(iso_sk_list.lock)\n};\n\n \nstruct iso_conn {\n\tstruct hci_conn\t*hcon;\n\n\t \n\tspinlock_t\tlock;\n\tstruct sock\t*sk;\n\n\tstruct delayed_work\ttimeout_work;\n\n\tstruct sk_buff\t*rx_skb;\n\t__u32\t\trx_len;\n\t__u16\t\ttx_sn;\n};\n\n#define iso_conn_lock(c)\tspin_lock(&(c)->lock)\n#define iso_conn_unlock(c)\tspin_unlock(&(c)->lock)\n\nstatic void iso_sock_close(struct sock *sk);\nstatic void iso_sock_kill(struct sock *sk);\n\n \n#define iso_pi(sk) ((struct iso_pinfo *)sk)\n\n#define EIR_SERVICE_DATA_LENGTH 4\n#define BASE_MAX_LENGTH (HCI_MAX_PER_AD_LENGTH - EIR_SERVICE_DATA_LENGTH)\n\n \nenum {\n\tBT_SK_BIG_SYNC,\n\tBT_SK_PA_SYNC,\n};\n\nstruct iso_pinfo {\n\tstruct bt_sock\t\tbt;\n\tbdaddr_t\t\tsrc;\n\t__u8\t\t\tsrc_type;\n\tbdaddr_t\t\tdst;\n\t__u8\t\t\tdst_type;\n\t__u8\t\t\tbc_sid;\n\t__u8\t\t\tbc_num_bis;\n\t__u8\t\t\tbc_bis[ISO_MAX_NUM_BIS];\n\t__u16\t\t\tsync_handle;\n\tunsigned long\t\tflags;\n\tstruct bt_iso_qos\tqos;\n\tbool\t\t\tqos_user_set;\n\t__u8\t\t\tbase_len;\n\t__u8\t\t\tbase[BASE_MAX_LENGTH];\n\tstruct iso_conn\t\t*conn;\n};\n\nstatic struct bt_iso_qos default_qos;\n\nstatic bool check_ucast_qos(struct bt_iso_qos *qos);\nstatic bool check_bcast_qos(struct bt_iso_qos *qos);\nstatic bool iso_match_sid(struct sock *sk, void *data);\nstatic bool iso_match_sync_handle(struct sock *sk, void *data);\nstatic void iso_sock_disconn(struct sock *sk);\n\n \n#define ISO_CONN_TIMEOUT\t(HZ * 40)\n#define ISO_DISCONN_TIMEOUT\t(HZ * 2)\n\nstatic void iso_sock_timeout(struct work_struct *work)\n{\n\tstruct iso_conn *conn = container_of(work, struct iso_conn,\n\t\t\t\t\t     timeout_work.work);\n\tstruct sock *sk;\n\n\tiso_conn_lock(conn);\n\tsk = conn->sk;\n\tif (sk)\n\t\tsock_hold(sk);\n\tiso_conn_unlock(conn);\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\n\tlock_sock(sk);\n\tsk->sk_err = ETIMEDOUT;\n\tsk->sk_state_change(sk);\n\trelease_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void iso_sock_set_timer(struct sock *sk, long timeout)\n{\n\tif (!iso_pi(sk)->conn)\n\t\treturn;\n\n\tBT_DBG(\"sock %p state %d timeout %ld\", sk, sk->sk_state, timeout);\n\tcancel_delayed_work(&iso_pi(sk)->conn->timeout_work);\n\tschedule_delayed_work(&iso_pi(sk)->conn->timeout_work, timeout);\n}\n\nstatic void iso_sock_clear_timer(struct sock *sk)\n{\n\tif (!iso_pi(sk)->conn)\n\t\treturn;\n\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tcancel_delayed_work(&iso_pi(sk)->conn->timeout_work);\n}\n\n \nstatic struct iso_conn *iso_conn_add(struct hci_conn *hcon)\n{\n\tstruct iso_conn *conn = hcon->iso_data;\n\n\tif (conn) {\n\t\tif (!conn->hcon)\n\t\t\tconn->hcon = hcon;\n\t\treturn conn;\n\t}\n\n\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\n\tspin_lock_init(&conn->lock);\n\tINIT_DELAYED_WORK(&conn->timeout_work, iso_sock_timeout);\n\n\thcon->iso_data = conn;\n\tconn->hcon = hcon;\n\tconn->tx_sn = 0;\n\n\tBT_DBG(\"hcon %p conn %p\", hcon, conn);\n\n\treturn conn;\n}\n\n \nstatic void iso_chan_del(struct sock *sk, int err)\n{\n\tstruct iso_conn *conn;\n\tstruct sock *parent;\n\n\tconn = iso_pi(sk)->conn;\n\n\tBT_DBG(\"sk %p, conn %p, err %d\", sk, conn, err);\n\n\tif (conn) {\n\t\tiso_conn_lock(conn);\n\t\tconn->sk = NULL;\n\t\tiso_pi(sk)->conn = NULL;\n\t\tiso_conn_unlock(conn);\n\n\t\tif (conn->hcon)\n\t\t\thci_conn_drop(conn->hcon);\n\t}\n\n\tsk->sk_state = BT_CLOSED;\n\tsk->sk_err   = err;\n\n\tparent = bt_sk(sk)->parent;\n\tif (parent) {\n\t\tbt_accept_unlink(sk);\n\t\tparent->sk_data_ready(parent);\n\t} else {\n\t\tsk->sk_state_change(sk);\n\t}\n\n\tsock_set_flag(sk, SOCK_ZAPPED);\n}\n\nstatic void iso_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct iso_conn *conn = hcon->iso_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\t \n\tiso_conn_lock(conn);\n\tsk = conn->sk;\n\tif (sk)\n\t\tsock_hold(sk);\n\tiso_conn_unlock(conn);\n\n\tif (sk) {\n\t\tlock_sock(sk);\n\t\tiso_sock_clear_timer(sk);\n\t\tiso_chan_del(sk, err);\n\t\trelease_sock(sk);\n\t\tsock_put(sk);\n\t}\n\n\t \n\tcancel_delayed_work_sync(&conn->timeout_work);\n\n\thcon->iso_data = NULL;\n\tkfree(conn);\n}\n\nstatic int __iso_chan_add(struct iso_conn *conn, struct sock *sk,\n\t\t\t  struct sock *parent)\n{\n\tBT_DBG(\"conn %p\", conn);\n\n\tif (iso_pi(sk)->conn == conn && conn->sk == sk)\n\t\treturn 0;\n\n\tif (conn->sk) {\n\t\tBT_ERR(\"conn->sk already set\");\n\t\treturn -EBUSY;\n\t}\n\n\tiso_pi(sk)->conn = conn;\n\tconn->sk = sk;\n\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk, true);\n\n\treturn 0;\n}\n\nstatic int iso_chan_add(struct iso_conn *conn, struct sock *sk,\n\t\t\tstruct sock *parent)\n{\n\tint err;\n\n\tiso_conn_lock(conn);\n\terr = __iso_chan_add(conn, sk, parent);\n\tiso_conn_unlock(conn);\n\n\treturn err;\n}\n\nstatic inline u8 le_addr_type(u8 bdaddr_type)\n{\n\tif (bdaddr_type == BDADDR_LE_PUBLIC)\n\t\treturn ADDR_LE_DEV_PUBLIC;\n\telse\n\t\treturn ADDR_LE_DEV_RANDOM;\n}\n\nstatic int iso_connect_bis(struct sock *sk)\n{\n\tstruct iso_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev  *hdev;\n\tint err;\n\n\tBT_DBG(\"%pMR\", &iso_pi(sk)->src);\n\n\thdev = hci_get_route(&iso_pi(sk)->dst, &iso_pi(sk)->src,\n\t\t\t     iso_pi(sk)->src_type);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\n\thci_dev_lock(hdev);\n\n\tif (!bis_capable(hdev)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (iso_pi(sk)->qos_user_set && !check_bcast_qos(&iso_pi(sk)->qos)) {\n\t\tiso_pi(sk)->qos = default_qos;\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (!iso_pi(sk)->qos.bcast.out.phy) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\thcon = hci_bind_bis(hdev, &iso_pi(sk)->dst,\n\t\t\t\t    &iso_pi(sk)->qos, iso_pi(sk)->base_len,\n\t\t\t\t    iso_pi(sk)->base);\n\t\tif (IS_ERR(hcon)) {\n\t\t\terr = PTR_ERR(hcon);\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\thcon = hci_connect_bis(hdev, &iso_pi(sk)->dst,\n\t\t\t\t       le_addr_type(iso_pi(sk)->dst_type),\n\t\t\t\t       &iso_pi(sk)->qos, iso_pi(sk)->base_len,\n\t\t\t\t       iso_pi(sk)->base);\n\t\tif (IS_ERR(hcon)) {\n\t\t\terr = PTR_ERR(hcon);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tconn = iso_conn_add(hcon);\n\tif (!conn) {\n\t\thci_conn_drop(hcon);\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tlock_sock(sk);\n\n\terr = iso_chan_add(conn, sk, NULL);\n\tif (err) {\n\t\trelease_sock(sk);\n\t\tgoto unlock;\n\t}\n\n\t \n\tbacpy(&iso_pi(sk)->src, &hcon->src);\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tiso_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else if (test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tiso_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECT;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tiso_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\n\n\trelease_sock(sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}\n\nstatic int iso_connect_cis(struct sock *sk)\n{\n\tstruct iso_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev  *hdev;\n\tint err;\n\n\tBT_DBG(\"%pMR -> %pMR\", &iso_pi(sk)->src, &iso_pi(sk)->dst);\n\n\thdev = hci_get_route(&iso_pi(sk)->dst, &iso_pi(sk)->src,\n\t\t\t     iso_pi(sk)->src_type);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\n\thci_dev_lock(hdev);\n\n\tif (!cis_central_capable(hdev)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (iso_pi(sk)->qos_user_set && !check_ucast_qos(&iso_pi(sk)->qos)) {\n\t\tiso_pi(sk)->qos = default_qos;\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (!iso_pi(sk)->qos.ucast.in.phy && !iso_pi(sk)->qos.ucast.out.phy) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\thcon = hci_bind_cis(hdev, &iso_pi(sk)->dst,\n\t\t\t\t    le_addr_type(iso_pi(sk)->dst_type),\n\t\t\t\t    &iso_pi(sk)->qos);\n\t\tif (IS_ERR(hcon)) {\n\t\t\terr = PTR_ERR(hcon);\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\thcon = hci_connect_cis(hdev, &iso_pi(sk)->dst,\n\t\t\t\t       le_addr_type(iso_pi(sk)->dst_type),\n\t\t\t\t       &iso_pi(sk)->qos);\n\t\tif (IS_ERR(hcon)) {\n\t\t\terr = PTR_ERR(hcon);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tconn = iso_conn_add(hcon);\n\tif (!conn) {\n\t\thci_conn_drop(hcon);\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tlock_sock(sk);\n\n\terr = iso_chan_add(conn, sk, NULL);\n\tif (err) {\n\t\trelease_sock(sk);\n\t\tgoto unlock;\n\t}\n\n\t \n\tbacpy(&iso_pi(sk)->src, &hcon->src);\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tiso_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else if (test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tiso_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECT;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tiso_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\n\n\trelease_sock(sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}\n\nstatic struct bt_iso_qos *iso_sock_get_qos(struct sock *sk)\n{\n\tif (sk->sk_state == BT_CONNECTED || sk->sk_state == BT_CONNECT2)\n\t\treturn &iso_pi(sk)->conn->hcon->iso_qos;\n\n\treturn &iso_pi(sk)->qos;\n}\n\nstatic int iso_send_frame(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct iso_conn *conn = iso_pi(sk)->conn;\n\tstruct bt_iso_qos *qos = iso_sock_get_qos(sk);\n\tstruct hci_iso_data_hdr *hdr;\n\tint len = 0;\n\n\tBT_DBG(\"sk %p len %d\", sk, skb->len);\n\n\tif (skb->len > qos->ucast.out.sdu)\n\t\treturn -EMSGSIZE;\n\n\tlen = skb->len;\n\n\t \n\thdr = skb_push(skb, HCI_ISO_DATA_HDR_SIZE);\n\thdr->sn = cpu_to_le16(conn->tx_sn++);\n\thdr->slen = cpu_to_le16(hci_iso_data_len_pack(len,\n\t\t\t\t\t\t      HCI_ISO_STATUS_VALID));\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\thci_send_iso(conn->hcon, skb);\n\telse\n\t\tlen = -ENOTCONN;\n\n\treturn len;\n}\n\nstatic void iso_recv_frame(struct iso_conn *conn, struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\n\tiso_conn_lock(conn);\n\tsk = conn->sk;\n\tiso_conn_unlock(conn);\n\n\tif (!sk)\n\t\tgoto drop;\n\n\tBT_DBG(\"sk %p len %d\", sk, skb->len);\n\n\tif (sk->sk_state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (!sock_queue_rcv_skb(sk, skb))\n\t\treturn;\n\ndrop:\n\tkfree_skb(skb);\n}\n\n \nstatic struct sock *__iso_get_sock_listen_by_addr(bdaddr_t *src, bdaddr_t *dst)\n{\n\tstruct sock *sk;\n\n\tsk_for_each(sk, &iso_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (bacmp(&iso_pi(sk)->dst, dst))\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&iso_pi(sk)->src, src))\n\t\t\treturn sk;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct sock *__iso_get_sock_listen_by_sid(bdaddr_t *ba, bdaddr_t *bc,\n\t\t\t\t\t\t __u8 sid)\n{\n\tstruct sock *sk;\n\n\tsk_for_each(sk, &iso_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (bacmp(&iso_pi(sk)->src, ba))\n\t\t\tcontinue;\n\n\t\tif (bacmp(&iso_pi(sk)->dst, bc))\n\t\t\tcontinue;\n\n\t\tif (iso_pi(sk)->bc_sid == sid)\n\t\t\treturn sk;\n\t}\n\n\treturn NULL;\n}\n\ntypedef bool (*iso_sock_match_t)(struct sock *sk, void *data);\n\n \nstatic struct sock *iso_get_sock_listen(bdaddr_t *src, bdaddr_t *dst,\n\t\t\t\t\tiso_sock_match_t match, void *data)\n{\n\tstruct sock *sk = NULL, *sk1 = NULL;\n\n\tread_lock(&iso_sk_list.lock);\n\n\tsk_for_each(sk, &iso_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (bacmp(dst, BDADDR_ANY) && bacmp(&iso_pi(sk)->dst, dst))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (match && !match(sk, data))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!bacmp(&iso_pi(sk)->src, src))\n\t\t\tbreak;\n\n\t\t \n\t\tif (!bacmp(&iso_pi(sk)->src, BDADDR_ANY))\n\t\t\tsk1 = sk;\n\t}\n\n\tread_unlock(&iso_sk_list.lock);\n\n\treturn sk ? sk : sk1;\n}\n\nstatic void iso_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void iso_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t \n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tiso_sock_close(sk);\n\t\tiso_sock_kill(sk);\n\t}\n\n\t \n\tif (iso_pi(parent)->conn && iso_pi(parent)->conn->hcon &&\n\t    test_bit(HCI_CONN_PA_SYNC, &iso_pi(parent)->conn->hcon->flags)) {\n\t\tiso_sock_disconn(parent);\n\t\treturn;\n\t}\n\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}\n\n \nstatic void iso_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket ||\n\t    sock_flag(sk, SOCK_DEAD))\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %d\", sk, sk->sk_state);\n\n\t \n\tbt_sock_unlink(&iso_sk_list, sk);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic void iso_sock_disconn(struct sock *sk)\n{\n\tsk->sk_state = BT_DISCONN;\n\tiso_sock_set_timer(sk, ISO_DISCONN_TIMEOUT);\n\tiso_conn_lock(iso_pi(sk)->conn);\n\thci_conn_drop(iso_pi(sk)->conn->hcon);\n\tiso_pi(sk)->conn->hcon = NULL;\n\tiso_conn_unlock(iso_pi(sk)->conn);\n}\n\nstatic void __iso_sock_close(struct sock *sk)\n{\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\tiso_sock_cleanup_listen(sk);\n\t\tbreak;\n\n\tcase BT_CONNECT:\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\t\tif (iso_pi(sk)->conn->hcon)\n\t\t\tiso_sock_disconn(sk);\n\t\telse\n\t\t\tiso_chan_del(sk, ECONNRESET);\n\t\tbreak;\n\n\tcase BT_CONNECT2:\n\t\tif (iso_pi(sk)->conn->hcon &&\n\t\t    (test_bit(HCI_CONN_PA_SYNC, &iso_pi(sk)->conn->hcon->flags) ||\n\t\t    test_bit(HCI_CONN_PA_SYNC_FAILED, &iso_pi(sk)->conn->hcon->flags)))\n\t\t\tiso_sock_disconn(sk);\n\t\telse\n\t\t\tiso_chan_del(sk, ECONNRESET);\n\t\tbreak;\n\tcase BT_DISCONN:\n\t\tiso_chan_del(sk, ECONNRESET);\n\t\tbreak;\n\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}\n\n \nstatic void iso_sock_close(struct sock *sk)\n{\n\tiso_sock_clear_timer(sk);\n\tlock_sock(sk);\n\t__iso_sock_close(sk);\n\trelease_sock(sk);\n\tiso_sock_kill(sk);\n}\n\nstatic void iso_sock_init(struct sock *sk, struct sock *parent)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tsk->sk_type = parent->sk_type;\n\t\tbt_sk(sk)->flags = bt_sk(parent)->flags;\n\t\tsecurity_sk_clone(parent, sk);\n\t}\n}\n\nstatic struct proto iso_proto = {\n\t.name\t\t= \"ISO\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct iso_pinfo)\n};\n\n#define DEFAULT_IO_QOS \\\n{ \\\n\t.interval\t= 10000u, \\\n\t.latency\t= 10u, \\\n\t.sdu\t\t= 40u, \\\n\t.phy\t\t= BT_ISO_PHY_2M, \\\n\t.rtn\t\t= 2u, \\\n}\n\nstatic struct bt_iso_qos default_qos = {\n\t.bcast = {\n\t\t.big\t\t\t= BT_ISO_QOS_BIG_UNSET,\n\t\t.bis\t\t\t= BT_ISO_QOS_BIS_UNSET,\n\t\t.sync_factor\t\t= 0x01,\n\t\t.packing\t\t= 0x00,\n\t\t.framing\t\t= 0x00,\n\t\t.in\t\t\t= DEFAULT_IO_QOS,\n\t\t.out\t\t\t= DEFAULT_IO_QOS,\n\t\t.encryption\t\t= 0x00,\n\t\t.bcode\t\t\t= {0x00},\n\t\t.options\t\t= 0x00,\n\t\t.skip\t\t\t= 0x0000,\n\t\t.sync_timeout\t\t= 0x4000,\n\t\t.sync_cte_type\t\t= 0x00,\n\t\t.mse\t\t\t= 0x00,\n\t\t.timeout\t\t= 0x4000,\n\t},\n};\n\nstatic struct sock *iso_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t   int proto, gfp_t prio, int kern)\n{\n\tstruct sock *sk;\n\n\tsk = bt_sock_alloc(net, sock, &iso_proto, proto, prio, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsk->sk_destruct = iso_sock_destruct;\n\tsk->sk_sndtimeo = ISO_CONN_TIMEOUT;\n\n\t \n\tiso_pi(sk)->src_type = BDADDR_LE_PUBLIC;\n\n\tiso_pi(sk)->qos = default_qos;\n\n\tbt_sock_link(&iso_sk_list, sk);\n\treturn sk;\n}\n\nstatic int iso_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t   int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &iso_sock_ops;\n\n\tsk = iso_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tiso_sock_init(sk, NULL);\n\treturn 0;\n}\n\nstatic int iso_sock_bind_bc(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int addr_len)\n{\n\tstruct sockaddr_iso *sa = (struct sockaddr_iso *)addr;\n\tstruct sock *sk = sock->sk;\n\tint i;\n\n\tBT_DBG(\"sk %p bc_sid %u bc_num_bis %u\", sk, sa->iso_bc->bc_sid,\n\t       sa->iso_bc->bc_num_bis);\n\n\tif (addr_len > sizeof(*sa) + sizeof(*sa->iso_bc) ||\n\t    sa->iso_bc->bc_num_bis < 0x01 || sa->iso_bc->bc_num_bis > 0x1f)\n\t\treturn -EINVAL;\n\n\tbacpy(&iso_pi(sk)->dst, &sa->iso_bc->bc_bdaddr);\n\tiso_pi(sk)->dst_type = sa->iso_bc->bc_bdaddr_type;\n\tiso_pi(sk)->sync_handle = -1;\n\tiso_pi(sk)->bc_sid = sa->iso_bc->bc_sid;\n\tiso_pi(sk)->bc_num_bis = sa->iso_bc->bc_num_bis;\n\n\tfor (i = 0; i < iso_pi(sk)->bc_num_bis; i++) {\n\t\tif (sa->iso_bc->bc_bis[i] < 0x01 ||\n\t\t    sa->iso_bc->bc_bis[i] > 0x1f)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(iso_pi(sk)->bc_bis, sa->iso_bc->bc_bis,\n\t\t       iso_pi(sk)->bc_num_bis);\n\t}\n\n\treturn 0;\n}\n\nstatic int iso_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_iso *sa = (struct sockaddr_iso *)addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR type %u\", sk, &sa->iso_bdaddr, sa->iso_bdaddr_type);\n\n\tif (!addr || addr_len < sizeof(struct sockaddr_iso) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!bdaddr_type_is_le(sa->iso_bdaddr_type)) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tbacpy(&iso_pi(sk)->src, &sa->iso_bdaddr);\n\tiso_pi(sk)->src_type = sa->iso_bdaddr_type;\n\n\t \n\tif (addr_len > sizeof(*sa)) {\n\t\terr = iso_sock_bind_bc(sock, addr, addr_len);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int iso_sock_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int alen, int flags)\n{\n\tstruct sockaddr_iso *sa = (struct sockaddr_iso *)addr;\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (alen < sizeof(struct sockaddr_iso) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)\n\t\treturn -EBADFD;\n\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\treturn -EINVAL;\n\n\t \n\tif (!bdaddr_type_is_le(sa->iso_bdaddr_type))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tbacpy(&iso_pi(sk)->dst, &sa->iso_bdaddr);\n\tiso_pi(sk)->dst_type = sa->iso_bdaddr_type;\n\n\trelease_sock(sk);\n\n\tif (bacmp(&iso_pi(sk)->dst, BDADDR_ANY))\n\t\terr = iso_connect_cis(sk);\n\telse\n\t\terr = iso_connect_bis(sk);\n\n\tif (err)\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\tif (!test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\t\t\t sock_sndtimeo(sk, flags & O_NONBLOCK));\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int iso_listen_bis(struct sock *sk)\n{\n\tstruct hci_dev *hdev;\n\tint err = 0;\n\n\tBT_DBG(\"%pMR -> %pMR (SID 0x%2.2x)\", &iso_pi(sk)->src,\n\t       &iso_pi(sk)->dst, iso_pi(sk)->bc_sid);\n\n\twrite_lock(&iso_sk_list.lock);\n\n\tif (__iso_get_sock_listen_by_sid(&iso_pi(sk)->src, &iso_pi(sk)->dst,\n\t\t\t\t\t iso_pi(sk)->bc_sid))\n\t\terr = -EADDRINUSE;\n\n\twrite_unlock(&iso_sk_list.lock);\n\n\tif (err)\n\t\treturn err;\n\n\thdev = hci_get_route(&iso_pi(sk)->dst, &iso_pi(sk)->src,\n\t\t\t     iso_pi(sk)->src_type);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\n\t \n\tif (iso_pi(sk)->qos_user_set && !check_bcast_qos(&iso_pi(sk)->qos)) {\n\t\tiso_pi(sk)->qos = default_qos;\n\t\treturn -EINVAL;\n\t}\n\n\terr = hci_pa_create_sync(hdev, &iso_pi(sk)->dst,\n\t\t\t\t le_addr_type(iso_pi(sk)->dst_type),\n\t\t\t\t iso_pi(sk)->bc_sid, &iso_pi(sk)->qos);\n\n\thci_dev_put(hdev);\n\n\treturn err;\n}\n\nstatic int iso_listen_cis(struct sock *sk)\n{\n\tint err = 0;\n\n\tBT_DBG(\"%pMR\", &iso_pi(sk)->src);\n\n\twrite_lock(&iso_sk_list.lock);\n\n\tif (__iso_get_sock_listen_by_addr(&iso_pi(sk)->src, &iso_pi(sk)->dst))\n\t\terr = -EADDRINUSE;\n\n\twrite_unlock(&iso_sk_list.lock);\n\n\treturn err;\n}\n\nstatic int iso_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (!bacmp(&iso_pi(sk)->dst, BDADDR_ANY))\n\t\terr = iso_listen_cis(sk);\n\telse\n\t\terr = iso_listen_bis(sk);\n\n\tif (err)\n\t\tgoto done;\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int iso_sock_accept(struct socket *sock, struct socket *newsock,\n\t\t\t   int flags, bool kern)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = sock->sk, *ch;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock(sk);\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t \n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tch = bt_accept_dequeue(sk, newsock);\n\t\tif (ch)\n\t\t\tbreak;\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\t\tlock_sock(sk);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", ch);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int iso_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int peer)\n{\n\tstruct sockaddr_iso *sa = (struct sockaddr_iso *)addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\taddr->sa_family = AF_BLUETOOTH;\n\n\tif (peer) {\n\t\tbacpy(&sa->iso_bdaddr, &iso_pi(sk)->dst);\n\t\tsa->iso_bdaddr_type = iso_pi(sk)->dst_type;\n\t} else {\n\t\tbacpy(&sa->iso_bdaddr, &iso_pi(sk)->src);\n\t\tsa->iso_bdaddr_type = iso_pi(sk)->src_type;\n\t}\n\n\treturn sizeof(struct sockaddr_iso);\n}\n\nstatic int iso_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb, **frag;\n\tsize_t mtu;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_CONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\tmtu = iso_pi(sk)->conn->hcon->hdev->iso_mtu;\n\n\trelease_sock(sk);\n\n\tskb = bt_skb_sendmsg(sk, msg, len, mtu, HCI_ISO_DATA_HDR_SIZE, 0);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tlen -= skb->len;\n\n\tBT_DBG(\"skb %p len %d\", sk, skb->len);\n\n\t \n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tstruct sk_buff *tmp;\n\n\t\ttmp = bt_skb_sendmsg(sk, msg, len, mtu, 0, 0);\n\t\tif (IS_ERR(tmp)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn PTR_ERR(tmp);\n\t\t}\n\n\t\t*frag = tmp;\n\n\t\tlen  -= tmp->len;\n\n\t\tskb->len += tmp->len;\n\t\tskb->data_len += tmp->len;\n\n\t\tBT_DBG(\"frag %p len %d\", *frag, tmp->len);\n\n\t\tfrag = &(*frag)->next;\n\t}\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = iso_send_frame(sk, skb);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\n\tif (err < 0)\n\t\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic void iso_conn_defer_accept(struct hci_conn *conn)\n{\n\tstruct hci_cp_le_accept_cis cp;\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tconn->state = BT_CONFIG;\n\n\tcp.handle = cpu_to_le16(conn->handle);\n\n\thci_send_cmd(hdev, HCI_OP_LE_ACCEPT_CIS, sizeof(cp), &cp);\n}\n\nstatic void iso_conn_big_sync(struct sock *sk)\n{\n\tint err;\n\tstruct hci_dev *hdev;\n\n\thdev = hci_get_route(&iso_pi(sk)->dst, &iso_pi(sk)->src,\n\t\t\t     iso_pi(sk)->src_type);\n\n\tif (!hdev)\n\t\treturn;\n\n\tif (!test_and_set_bit(BT_SK_BIG_SYNC, &iso_pi(sk)->flags)) {\n\t\terr = hci_le_big_create_sync(hdev, iso_pi(sk)->conn->hcon,\n\t\t\t\t\t     &iso_pi(sk)->qos,\n\t\t\t\t\t     iso_pi(sk)->sync_handle,\n\t\t\t\t\t     iso_pi(sk)->bc_num_bis,\n\t\t\t\t\t     iso_pi(sk)->bc_bis);\n\t\tif (err)\n\t\t\tbt_dev_err(hdev, \"hci_le_big_create_sync: %d\",\n\t\t\t\t   err);\n\t}\n}\n\nstatic int iso_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct iso_pinfo *pi = iso_pi(sk);\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (test_and_clear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tlock_sock(sk);\n\t\tswitch (sk->sk_state) {\n\t\tcase BT_CONNECT2:\n\t\t\tif (pi->conn->hcon &&\n\t\t\t    test_bit(HCI_CONN_PA_SYNC, &pi->conn->hcon->flags)) {\n\t\t\t\tiso_conn_big_sync(sk);\n\t\t\t\tsk->sk_state = BT_LISTEN;\n\t\t\t} else {\n\t\t\t\tiso_conn_defer_accept(pi->conn->hcon);\n\t\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\t}\n\t\t\trelease_sock(sk);\n\t\t\treturn 0;\n\t\tcase BT_CONNECT:\n\t\t\trelease_sock(sk);\n\t\t\treturn iso_connect_cis(sk);\n\t\tdefault:\n\t\t\trelease_sock(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bt_sock_recvmsg(sock, msg, len, flags);\n}\n\nstatic bool check_io_qos(struct bt_iso_io_qos *qos)\n{\n\t \n\tif (!qos->phy && qos->sdu)\n\t\treturn false;\n\n\tif (qos->interval && (qos->interval < 0xff || qos->interval > 0xfffff))\n\t\treturn false;\n\n\tif (qos->latency && (qos->latency < 0x05 || qos->latency > 0xfa0))\n\t\treturn false;\n\n\tif (qos->phy > BT_ISO_PHY_ANY)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool check_ucast_qos(struct bt_iso_qos *qos)\n{\n\tif (qos->ucast.cig > 0xef && qos->ucast.cig != BT_ISO_QOS_CIG_UNSET)\n\t\treturn false;\n\n\tif (qos->ucast.cis > 0xef && qos->ucast.cis != BT_ISO_QOS_CIS_UNSET)\n\t\treturn false;\n\n\tif (qos->ucast.sca > 0x07)\n\t\treturn false;\n\n\tif (qos->ucast.packing > 0x01)\n\t\treturn false;\n\n\tif (qos->ucast.framing > 0x01)\n\t\treturn false;\n\n\tif (!check_io_qos(&qos->ucast.in))\n\t\treturn false;\n\n\tif (!check_io_qos(&qos->ucast.out))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool check_bcast_qos(struct bt_iso_qos *qos)\n{\n\tif (qos->bcast.sync_factor == 0x00)\n\t\treturn false;\n\n\tif (qos->bcast.packing > 0x01)\n\t\treturn false;\n\n\tif (qos->bcast.framing > 0x01)\n\t\treturn false;\n\n\tif (!check_io_qos(&qos->bcast.in))\n\t\treturn false;\n\n\tif (!check_io_qos(&qos->bcast.out))\n\t\treturn false;\n\n\tif (qos->bcast.encryption > 0x01)\n\t\treturn false;\n\n\tif (qos->bcast.options > 0x07)\n\t\treturn false;\n\n\tif (qos->bcast.skip > 0x01f3)\n\t\treturn false;\n\n\tif (qos->bcast.sync_timeout < 0x000a || qos->bcast.sync_timeout > 0x4000)\n\t\treturn false;\n\n\tif (qos->bcast.sync_cte_type > 0x1f)\n\t\treturn false;\n\n\tif (qos->bcast.mse > 0x1f)\n\t\treturn false;\n\n\tif (qos->bcast.timeout < 0x000a || qos->bcast.timeout > 0x4000)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int iso_sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_iso_qos qos = default_qos;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\tbreak;\n\n\tcase BT_PKT_STATUS:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags);\n\t\telse\n\t\t\tclear_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags);\n\t\tbreak;\n\n\tcase BT_ISO_QOS:\n\t\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND &&\n\t\t    sk->sk_state != BT_CONNECT2) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = min_t(unsigned int, sizeof(qos), optlen);\n\n\t\tif (copy_from_sockptr(&qos, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (len == sizeof(qos.ucast) && !check_ucast_qos(&qos)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tiso_pi(sk)->qos = qos;\n\t\tiso_pi(sk)->qos_user_set = true;\n\n\t\tbreak;\n\n\tcase BT_ISO_BASE:\n\t\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND &&\n\t\t    sk->sk_state != BT_CONNECT2) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (optlen > sizeof(iso_pi(sk)->base)) {\n\t\t\terr = -EOVERFLOW;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = min_t(unsigned int, sizeof(iso_pi(sk)->base), optlen);\n\n\t\tif (copy_from_sockptr(iso_pi(sk)->base, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tiso_pi(sk)->base_len = len;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int iso_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_iso_qos *qos;\n\tu8 base_len;\n\tu8 *base;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state == BT_CONNECTED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_PKT_STATUS:\n\t\tif (put_user(test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags),\n\t\t\t     (int __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_ISO_QOS:\n\t\tqos = iso_sock_get_qos(sk);\n\n\t\tlen = min_t(unsigned int, len, sizeof(*qos));\n\t\tif (copy_to_user(optval, qos, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_ISO_BASE:\n\t\tif (sk->sk_state == BT_CONNECTED &&\n\t\t    !bacmp(&iso_pi(sk)->dst, BDADDR_ANY)) {\n\t\t\tbase_len = iso_pi(sk)->conn->hcon->le_per_adv_data_len;\n\t\t\tbase = iso_pi(sk)->conn->hcon->le_per_adv_data;\n\t\t} else {\n\t\t\tbase_len = iso_pi(sk)->base_len;\n\t\t\tbase = iso_pi(sk)->base;\n\t\t}\n\n\t\tlen = min_t(unsigned int, len, base_len);\n\t\tif (copy_to_user(optval, base, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int iso_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p, how %d\", sock, sk, how);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\n\tswitch (how) {\n\tcase SHUT_RD:\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tgoto unlock;\n\t\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\t\tbreak;\n\tcase SHUT_WR:\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tgoto unlock;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tbreak;\n\tcase SHUT_RDWR:\n\t\tif (sk->sk_shutdown & SHUTDOWN_MASK)\n\t\t\tgoto unlock;\n\t\tsk->sk_shutdown |= SHUTDOWN_MASK;\n\t\tbreak;\n\t}\n\n\tiso_sock_clear_timer(sk);\n\t__iso_sock_close(sk);\n\n\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t    !(current->flags & PF_EXITING))\n\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\nunlock:\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn err;\n}\n\nstatic int iso_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tiso_sock_close(sk);\n\n\tif (sock_flag(sk, SOCK_LINGER) && READ_ONCE(sk->sk_lingertime) &&\n\t    !(current->flags & PF_EXITING)) {\n\t\tlock_sock(sk);\n\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t\trelease_sock(sk);\n\t}\n\n\tsock_orphan(sk);\n\tiso_sock_kill(sk);\n\treturn err;\n}\n\nstatic void iso_sock_ready(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (!sk)\n\t\treturn;\n\n\tlock_sock(sk);\n\tiso_sock_clear_timer(sk);\n\tsk->sk_state = BT_CONNECTED;\n\tsk->sk_state_change(sk);\n\trelease_sock(sk);\n}\n\nstruct iso_list_data {\n\tstruct hci_conn *hcon;\n\tint count;\n};\n\nstatic bool iso_match_big(struct sock *sk, void *data)\n{\n\tstruct hci_evt_le_big_sync_estabilished *ev = data;\n\n\treturn ev->handle == iso_pi(sk)->qos.bcast.big;\n}\n\nstatic bool iso_match_pa_sync_flag(struct sock *sk, void *data)\n{\n\treturn test_bit(BT_SK_PA_SYNC, &iso_pi(sk)->flags);\n}\n\nstatic void iso_conn_ready(struct iso_conn *conn)\n{\n\tstruct sock *parent = NULL;\n\tstruct sock *sk = conn->sk;\n\tstruct hci_ev_le_big_sync_estabilished *ev = NULL;\n\tstruct hci_ev_le_pa_sync_established *ev2 = NULL;\n\tstruct hci_evt_le_big_info_adv_report *ev3 = NULL;\n\tstruct hci_conn *hcon;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tif (sk) {\n\t\tiso_sock_ready(conn->sk);\n\t} else {\n\t\thcon = conn->hcon;\n\t\tif (!hcon)\n\t\t\treturn;\n\n\t\tif (test_bit(HCI_CONN_BIG_SYNC, &hcon->flags) ||\n\t\t    test_bit(HCI_CONN_BIG_SYNC_FAILED, &hcon->flags)) {\n\t\t\tev = hci_recv_event_data(hcon->hdev,\n\t\t\t\t\t\t HCI_EVT_LE_BIG_SYNC_ESTABILISHED);\n\n\t\t\t \n\t\t\tparent = iso_get_sock_listen(&hcon->src,\n\t\t\t\t\t\t     &hcon->dst,\n\t\t\t\t\t\t     iso_match_pa_sync_flag, NULL);\n\t\t\tif (!parent && ev)\n\t\t\t\tparent = iso_get_sock_listen(&hcon->src,\n\t\t\t\t\t\t\t     &hcon->dst,\n\t\t\t\t\t\t\t     iso_match_big, ev);\n\t\t} else if (test_bit(HCI_CONN_PA_SYNC_FAILED, &hcon->flags)) {\n\t\t\tev2 = hci_recv_event_data(hcon->hdev,\n\t\t\t\t\t\t  HCI_EV_LE_PA_SYNC_ESTABLISHED);\n\t\t\tif (ev2)\n\t\t\t\tparent = iso_get_sock_listen(&hcon->src,\n\t\t\t\t\t\t\t     &hcon->dst,\n\t\t\t\t\t\t\t     iso_match_sid, ev2);\n\t\t} else if (test_bit(HCI_CONN_PA_SYNC, &hcon->flags)) {\n\t\t\tev3 = hci_recv_event_data(hcon->hdev,\n\t\t\t\t\t\t  HCI_EVT_LE_BIG_INFO_ADV_REPORT);\n\t\t\tif (ev3)\n\t\t\t\tparent = iso_get_sock_listen(&hcon->src,\n\t\t\t\t\t\t\t     &hcon->dst,\n\t\t\t\t\t\t\t     iso_match_sync_handle, ev3);\n\t\t}\n\n\t\tif (!parent)\n\t\t\tparent = iso_get_sock_listen(&hcon->src,\n\t\t\t\t\t\t\tBDADDR_ANY, NULL, NULL);\n\n\t\tif (!parent)\n\t\t\treturn;\n\n\t\tlock_sock(parent);\n\n\t\tsk = iso_sock_alloc(sock_net(parent), NULL,\n\t\t\t\t    BTPROTO_ISO, GFP_ATOMIC, 0);\n\t\tif (!sk) {\n\t\t\trelease_sock(parent);\n\t\t\treturn;\n\t\t}\n\n\t\tiso_sock_init(sk, parent);\n\n\t\tbacpy(&iso_pi(sk)->src, &hcon->src);\n\n\t\t \n\t\tif (hcon->src_type == ADDR_LE_DEV_PUBLIC)\n\t\t\tiso_pi(sk)->src_type = BDADDR_LE_PUBLIC;\n\t\telse\n\t\t\tiso_pi(sk)->src_type = BDADDR_LE_RANDOM;\n\n\t\t \n\t\tif (!bacmp(&hcon->dst, BDADDR_ANY)) {\n\t\t\tbacpy(&hcon->dst, &iso_pi(parent)->dst);\n\t\t\thcon->dst_type = iso_pi(parent)->dst_type;\n\t\t\thcon->sync_handle = iso_pi(parent)->sync_handle;\n\t\t}\n\n\t\tif (ev3) {\n\t\t\tiso_pi(sk)->qos = iso_pi(parent)->qos;\n\t\t\tiso_pi(sk)->qos.bcast.encryption = ev3->encryption;\n\t\t\thcon->iso_qos = iso_pi(sk)->qos;\n\t\t\tiso_pi(sk)->bc_num_bis = iso_pi(parent)->bc_num_bis;\n\t\t\tmemcpy(iso_pi(sk)->bc_bis, iso_pi(parent)->bc_bis, ISO_MAX_NUM_BIS);\n\t\t\tset_bit(BT_SK_PA_SYNC, &iso_pi(sk)->flags);\n\t\t}\n\n\t\tbacpy(&iso_pi(sk)->dst, &hcon->dst);\n\t\tiso_pi(sk)->dst_type = hcon->dst_type;\n\t\tiso_pi(sk)->sync_handle = iso_pi(parent)->sync_handle;\n\t\tmemcpy(iso_pi(sk)->base, iso_pi(parent)->base, iso_pi(parent)->base_len);\n\t\tiso_pi(sk)->base_len = iso_pi(parent)->base_len;\n\n\t\thci_conn_hold(hcon);\n\t\tiso_chan_add(conn, sk, parent);\n\n\t\tif ((ev && ((struct hci_evt_le_big_sync_estabilished *)ev)->status) ||\n\t\t    (ev2 && ev2->status)) {\n\t\t\t \n\t\t\tsk->sk_err = ECONNREFUSED;\n\t\t\tsk->sk_error_report(sk);\n\t\t}\n\n\t\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))\n\t\t\tsk->sk_state = BT_CONNECT2;\n\t\telse\n\t\t\tsk->sk_state = BT_CONNECTED;\n\n\t\t \n\t\tparent->sk_data_ready(parent);\n\n\t\trelease_sock(parent);\n\t}\n}\n\nstatic bool iso_match_sid(struct sock *sk, void *data)\n{\n\tstruct hci_ev_le_pa_sync_established *ev = data;\n\n\treturn ev->sid == iso_pi(sk)->bc_sid;\n}\n\nstatic bool iso_match_sync_handle(struct sock *sk, void *data)\n{\n\tstruct hci_evt_le_big_info_adv_report *ev = data;\n\n\treturn le16_to_cpu(ev->sync_handle) == iso_pi(sk)->sync_handle;\n}\n\nstatic bool iso_match_sync_handle_pa_report(struct sock *sk, void *data)\n{\n\tstruct hci_ev_le_per_adv_report *ev = data;\n\n\treturn le16_to_cpu(ev->sync_handle) == iso_pi(sk)->sync_handle;\n}\n\n \n\nint iso_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags)\n{\n\tstruct hci_ev_le_pa_sync_established *ev1;\n\tstruct hci_evt_le_big_info_adv_report *ev2;\n\tstruct hci_ev_le_per_adv_report *ev3;\n\tstruct sock *sk;\n\tint lm = 0;\n\n\tbt_dev_dbg(hdev, \"bdaddr %pMR\", bdaddr);\n\n\t \n\tev1 = hci_recv_event_data(hdev, HCI_EV_LE_PA_SYNC_ESTABLISHED);\n\tif (ev1) {\n\t\tsk = iso_get_sock_listen(&hdev->bdaddr, bdaddr, iso_match_sid,\n\t\t\t\t\t ev1);\n\t\tif (sk && !ev1->status)\n\t\t\tiso_pi(sk)->sync_handle = le16_to_cpu(ev1->handle);\n\n\t\tgoto done;\n\t}\n\n\tev2 = hci_recv_event_data(hdev, HCI_EVT_LE_BIG_INFO_ADV_REPORT);\n\tif (ev2) {\n\t\t \n\t\tsk = iso_get_sock_listen(&hdev->bdaddr, bdaddr,\n\t\t\t\t\t\tiso_match_pa_sync_flag, NULL);\n\t\tif (!sk)\n\t\t\tsk = iso_get_sock_listen(&hdev->bdaddr, bdaddr,\n\t\t\t\t\t\t iso_match_sync_handle, ev2);\n\t\tif (sk) {\n\t\t\tint err;\n\n\t\t\tif (ev2->num_bis < iso_pi(sk)->bc_num_bis)\n\t\t\t\tiso_pi(sk)->bc_num_bis = ev2->num_bis;\n\n\t\t\tif (!test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags) &&\n\t\t\t    !test_and_set_bit(BT_SK_BIG_SYNC, &iso_pi(sk)->flags)) {\n\t\t\t\terr = hci_le_big_create_sync(hdev, NULL,\n\t\t\t\t\t\t\t     &iso_pi(sk)->qos,\n\t\t\t\t\t\t\t     iso_pi(sk)->sync_handle,\n\t\t\t\t\t\t\t     iso_pi(sk)->bc_num_bis,\n\t\t\t\t\t\t\t     iso_pi(sk)->bc_bis);\n\t\t\t\tif (err) {\n\t\t\t\t\tbt_dev_err(hdev, \"hci_le_big_create_sync: %d\",\n\t\t\t\t\t\t   err);\n\t\t\t\t\tsk = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tev3 = hci_recv_event_data(hdev, HCI_EV_LE_PER_ADV_REPORT);\n\tif (ev3) {\n\t\tsk = iso_get_sock_listen(&hdev->bdaddr, bdaddr,\n\t\t\t\t\t iso_match_sync_handle_pa_report, ev3);\n\n\t\tif (sk) {\n\t\t\tmemcpy(iso_pi(sk)->base, ev3->data, ev3->length);\n\t\t\tiso_pi(sk)->base_len = ev3->length;\n\t\t}\n\t} else {\n\t\tsk = iso_get_sock_listen(&hdev->bdaddr, BDADDR_ANY, NULL, NULL);\n\t}\n\ndone:\n\tif (!sk)\n\t\treturn lm;\n\n\tlm |= HCI_LM_ACCEPT;\n\n\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))\n\t\t*flags |= HCI_PROTO_DEFER;\n\n\treturn lm;\n}\n\nstatic void iso_connect_cfm(struct hci_conn *hcon, __u8 status)\n{\n\tif (hcon->type != ISO_LINK) {\n\t\tif (hcon->type != LE_LINK)\n\t\t\treturn;\n\n\t\t \n\t\tif (status) {\n\t\t\tstruct hci_link *link, *t;\n\n\t\t\tlist_for_each_entry_safe(link, t, &hcon->link_list,\n\t\t\t\t\t\t list)\n\t\t\t\tiso_conn_del(link->conn, bt_to_errno(status));\n\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\thci_le_create_cis_pending(hcon->hdev);\n\t\treturn;\n\t}\n\n\tBT_DBG(\"hcon %p bdaddr %pMR status %d\", hcon, &hcon->dst, status);\n\n\t \n\tif (!status || test_bit(HCI_CONN_BIG_SYNC_FAILED, &hcon->flags) ||\n\t    test_bit(HCI_CONN_PA_SYNC_FAILED, &hcon->flags)) {\n\t\tstruct iso_conn *conn;\n\n\t\tconn = iso_conn_add(hcon);\n\t\tif (conn)\n\t\t\tiso_conn_ready(conn);\n\t} else {\n\t\tiso_conn_del(hcon, bt_to_errno(status));\n\t}\n}\n\nstatic void iso_disconn_cfm(struct hci_conn *hcon, __u8 reason)\n{\n\tif (hcon->type != ISO_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p reason %d\", hcon, reason);\n\n\tiso_conn_del(hcon, bt_to_errno(reason));\n}\n\nvoid iso_recv(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)\n{\n\tstruct iso_conn *conn = hcon->iso_data;\n\t__u16 pb, ts, len;\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tpb     = hci_iso_flags_pb(flags);\n\tts     = hci_iso_flags_ts(flags);\n\n\tBT_DBG(\"conn %p len %d pb 0x%x ts 0x%x\", conn, skb->len, pb, ts);\n\n\tswitch (pb) {\n\tcase ISO_START:\n\tcase ISO_SINGLE:\n\t\tif (conn->rx_len) {\n\t\t\tBT_ERR(\"Unexpected start frame (len %d)\", skb->len);\n\t\t\tkfree_skb(conn->rx_skb);\n\t\t\tconn->rx_skb = NULL;\n\t\t\tconn->rx_len = 0;\n\t\t}\n\n\t\tif (ts) {\n\t\t\tstruct hci_iso_ts_data_hdr *hdr;\n\n\t\t\t \n\t\t\thdr = skb_pull_data(skb, HCI_ISO_TS_DATA_HDR_SIZE);\n\t\t\tif (!hdr) {\n\t\t\t\tBT_ERR(\"Frame is too short (len %d)\", skb->len);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tlen = __le16_to_cpu(hdr->slen);\n\t\t} else {\n\t\t\tstruct hci_iso_data_hdr *hdr;\n\n\t\t\thdr = skb_pull_data(skb, HCI_ISO_DATA_HDR_SIZE);\n\t\t\tif (!hdr) {\n\t\t\t\tBT_ERR(\"Frame is too short (len %d)\", skb->len);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tlen = __le16_to_cpu(hdr->slen);\n\t\t}\n\n\t\tflags  = hci_iso_data_flags(len);\n\t\tlen    = hci_iso_data_len(len);\n\n\t\tBT_DBG(\"Start: total len %d, frag len %d flags 0x%4.4x\", len,\n\t\t       skb->len, flags);\n\n\t\tif (len == skb->len) {\n\t\t\t \n\t\t\thci_skb_pkt_status(skb) = flags & 0x03;\n\t\t\tiso_recv_frame(conn, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tif (pb == ISO_SINGLE) {\n\t\t\tBT_ERR(\"Frame malformed (len %d, expected len %d)\",\n\t\t\t       skb->len, len);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (skb->len > len) {\n\t\t\tBT_ERR(\"Frame is too long (len %d, expected len %d)\",\n\t\t\t       skb->len, len);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tconn->rx_skb = bt_skb_alloc(len, GFP_KERNEL);\n\t\tif (!conn->rx_skb)\n\t\t\tgoto drop;\n\n\t\thci_skb_pkt_status(conn->rx_skb) = flags & 0x03;\n\t\tskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),\n\t\t\t\t\t  skb->len);\n\t\tconn->rx_len = len - skb->len;\n\t\tbreak;\n\n\tcase ISO_CONT:\n\t\tBT_DBG(\"Cont: frag len %d (expecting %d)\", skb->len,\n\t\t       conn->rx_len);\n\n\t\tif (!conn->rx_len) {\n\t\t\tBT_ERR(\"Unexpected continuation frame (len %d)\",\n\t\t\t       skb->len);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (skb->len > conn->rx_len) {\n\t\t\tBT_ERR(\"Fragment is too long (len %d, expected %d)\",\n\t\t\t       skb->len, conn->rx_len);\n\t\t\tkfree_skb(conn->rx_skb);\n\t\t\tconn->rx_skb = NULL;\n\t\t\tconn->rx_len = 0;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),\n\t\t\t\t\t  skb->len);\n\t\tconn->rx_len -= skb->len;\n\t\treturn;\n\n\tcase ISO_END:\n\t\tskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),\n\t\t\t\t\t  skb->len);\n\t\tconn->rx_len -= skb->len;\n\n\t\tif (!conn->rx_len) {\n\t\t\tstruct sk_buff *rx_skb = conn->rx_skb;\n\n\t\t\t \n\t\t\tconn->rx_skb = NULL;\n\t\t\tiso_recv_frame(conn, rx_skb);\n\t\t}\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic struct hci_cb iso_cb = {\n\t.name\t\t= \"ISO\",\n\t.connect_cfm\t= iso_connect_cfm,\n\t.disconn_cfm\t= iso_disconn_cfm,\n};\n\nstatic int iso_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct sock *sk;\n\n\tread_lock(&iso_sk_list.lock);\n\n\tsk_for_each(sk, &iso_sk_list.head) {\n\t\tseq_printf(f, \"%pMR %pMR %d\\n\", &iso_pi(sk)->src,\n\t\t\t   &iso_pi(sk)->dst, sk->sk_state);\n\t}\n\n\tread_unlock(&iso_sk_list.lock);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(iso_debugfs);\n\nstatic struct dentry *iso_debugfs;\n\nstatic const struct proto_ops iso_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= iso_sock_release,\n\t.bind\t\t= iso_sock_bind,\n\t.connect\t= iso_sock_connect,\n\t.listen\t\t= iso_sock_listen,\n\t.accept\t\t= iso_sock_accept,\n\t.getname\t= iso_sock_getname,\n\t.sendmsg\t= iso_sock_sendmsg,\n\t.recvmsg\t= iso_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= iso_sock_shutdown,\n\t.setsockopt\t= iso_sock_setsockopt,\n\t.getsockopt\t= iso_sock_getsockopt\n};\n\nstatic const struct net_proto_family iso_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= iso_sock_create,\n};\n\nstatic bool iso_inited;\n\nbool iso_enabled(void)\n{\n\treturn iso_inited;\n}\n\nint iso_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_iso) > sizeof(struct sockaddr));\n\n\tif (iso_inited)\n\t\treturn -EALREADY;\n\n\terr = proto_register(&iso_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_ISO, &iso_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"ISO socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"iso\", &iso_sk_list, NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create ISO proc file\");\n\t\tbt_sock_unregister(BTPROTO_ISO);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"ISO socket layer initialized\");\n\n\thci_register_cb(&iso_cb);\n\n\tif (IS_ERR_OR_NULL(bt_debugfs))\n\t\treturn 0;\n\n\tif (!iso_debugfs) {\n\t\tiso_debugfs = debugfs_create_file(\"iso\", 0444, bt_debugfs,\n\t\t\t\t\t\t  NULL, &iso_debugfs_fops);\n\t}\n\n\tiso_inited = true;\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&iso_proto);\n\treturn err;\n}\n\nint iso_exit(void)\n{\n\tif (!iso_inited)\n\t\treturn -EALREADY;\n\n\tbt_procfs_cleanup(&init_net, \"iso\");\n\n\tdebugfs_remove(iso_debugfs);\n\tiso_debugfs = NULL;\n\n\thci_unregister_cb(&iso_cb);\n\n\tbt_sock_unregister(BTPROTO_ISO);\n\n\tproto_unregister(&iso_proto);\n\n\tiso_inited = false;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}