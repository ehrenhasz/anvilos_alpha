{
  "module_name": "msft.c",
  "hash_id": "6294fc69d9d914a3797ceaaaa72192f88725c29dc3d255bb939c3a7fa1492bc9",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/msft.c",
  "human_readable_source": "\n \n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/mgmt.h>\n\n#include \"hci_request.h\"\n#include \"mgmt_util.h\"\n#include \"msft.h\"\n\n#define MSFT_RSSI_THRESHOLD_VALUE_MIN\t\t-127\n#define MSFT_RSSI_THRESHOLD_VALUE_MAX\t\t20\n#define MSFT_RSSI_LOW_TIMEOUT_MAX\t\t0x3C\n\n#define MSFT_OP_READ_SUPPORTED_FEATURES\t\t0x00\nstruct msft_cp_read_supported_features {\n\t__u8   sub_opcode;\n} __packed;\n\nstruct msft_rp_read_supported_features {\n\t__u8   status;\n\t__u8   sub_opcode;\n\t__le64 features;\n\t__u8   evt_prefix_len;\n\t__u8   evt_prefix[];\n} __packed;\n\n#define MSFT_OP_LE_MONITOR_ADVERTISEMENT\t0x03\n#define MSFT_MONITOR_ADVERTISEMENT_TYPE_PATTERN\t0x01\nstruct msft_le_monitor_advertisement_pattern {\n\t__u8 length;\n\t__u8 data_type;\n\t__u8 start_byte;\n\t__u8 pattern[];\n};\n\nstruct msft_le_monitor_advertisement_pattern_data {\n\t__u8 count;\n\t__u8 data[];\n};\n\nstruct msft_cp_le_monitor_advertisement {\n\t__u8 sub_opcode;\n\t__s8 rssi_high;\n\t__s8 rssi_low;\n\t__u8 rssi_low_interval;\n\t__u8 rssi_sampling_period;\n\t__u8 cond_type;\n\t__u8 data[];\n} __packed;\n\nstruct msft_rp_le_monitor_advertisement {\n\t__u8 status;\n\t__u8 sub_opcode;\n\t__u8 handle;\n} __packed;\n\n#define MSFT_OP_LE_CANCEL_MONITOR_ADVERTISEMENT\t0x04\nstruct msft_cp_le_cancel_monitor_advertisement {\n\t__u8 sub_opcode;\n\t__u8 handle;\n} __packed;\n\nstruct msft_rp_le_cancel_monitor_advertisement {\n\t__u8 status;\n\t__u8 sub_opcode;\n} __packed;\n\n#define MSFT_OP_LE_SET_ADVERTISEMENT_FILTER_ENABLE\t0x05\nstruct msft_cp_le_set_advertisement_filter_enable {\n\t__u8 sub_opcode;\n\t__u8 enable;\n} __packed;\n\nstruct msft_rp_le_set_advertisement_filter_enable {\n\t__u8 status;\n\t__u8 sub_opcode;\n} __packed;\n\n#define MSFT_EV_LE_MONITOR_DEVICE\t0x02\nstruct msft_ev_le_monitor_device {\n\t__u8     addr_type;\n\tbdaddr_t bdaddr;\n\t__u8     monitor_handle;\n\t__u8     monitor_state;\n} __packed;\n\nstruct msft_monitor_advertisement_handle_data {\n\t__u8  msft_handle;\n\t__u16 mgmt_handle;\n\t__s8 rssi_high;\n\t__s8 rssi_low;\n\t__u8 rssi_low_interval;\n\t__u8 rssi_sampling_period;\n\t__u8 cond_type;\n\tstruct list_head list;\n};\n\nenum monitor_addr_filter_state {\n\tAF_STATE_IDLE,\n\tAF_STATE_ADDING,\n\tAF_STATE_ADDED,\n\tAF_STATE_REMOVING,\n};\n\n#define MSFT_MONITOR_ADVERTISEMENT_TYPE_ADDR\t0x04\nstruct msft_monitor_addr_filter_data {\n\t__u8     msft_handle;\n\t__u8     pattern_handle;  \n\t__u16    mgmt_handle;\n\tint      state;\n\t__s8     rssi_high;\n\t__s8     rssi_low;\n\t__u8     rssi_low_interval;\n\t__u8     rssi_sampling_period;\n\t__u8     addr_type;\n\tbdaddr_t bdaddr;\n\tstruct list_head list;\n};\n\nstruct msft_data {\n\t__u64 features;\n\t__u8  evt_prefix_len;\n\t__u8  *evt_prefix;\n\tstruct list_head handle_map;\n\tstruct list_head address_filters;\n\t__u8 resuming;\n\t__u8 suspending;\n\t__u8 filter_enabled;\n\t \n\tstruct mutex filter_lock;\n};\n\nbool msft_monitor_supported(struct hci_dev *hdev)\n{\n\treturn !!(msft_get_features(hdev) & MSFT_FEATURE_MASK_LE_ADV_MONITOR);\n}\n\nstatic bool read_supported_features(struct hci_dev *hdev,\n\t\t\t\t    struct msft_data *msft)\n{\n\tstruct msft_cp_read_supported_features cp;\n\tstruct msft_rp_read_supported_features *rp;\n\tstruct sk_buff *skb;\n\n\tcp.sub_opcode = MSFT_OP_READ_SUPPORTED_FEATURES;\n\n\tskb = __hci_cmd_sync(hdev, hdev->msft_opcode, sizeof(cp), &cp,\n\t\t\t     HCI_CMD_TIMEOUT);\n\tif (IS_ERR_OR_NULL(skb)) {\n\t\tif (!skb)\n\t\t\tskb = ERR_PTR(-EIO);\n\n\t\tbt_dev_err(hdev, \"Failed to read MSFT supported features (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn false;\n\t}\n\n\tif (skb->len < sizeof(*rp)) {\n\t\tbt_dev_err(hdev, \"MSFT supported features length mismatch\");\n\t\tgoto failed;\n\t}\n\n\trp = (struct msft_rp_read_supported_features *)skb->data;\n\n\tif (rp->sub_opcode != MSFT_OP_READ_SUPPORTED_FEATURES)\n\t\tgoto failed;\n\n\tif (rp->evt_prefix_len > 0) {\n\t\tmsft->evt_prefix = kmemdup(rp->evt_prefix, rp->evt_prefix_len,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!msft->evt_prefix)\n\t\t\tgoto failed;\n\t}\n\n\tmsft->evt_prefix_len = rp->evt_prefix_len;\n\tmsft->features = __le64_to_cpu(rp->features);\n\n\tif (msft->features & MSFT_FEATURE_MASK_CURVE_VALIDITY)\n\t\thdev->msft_curve_validity = true;\n\n\tkfree_skb(skb);\n\treturn true;\n\nfailed:\n\tkfree_skb(skb);\n\treturn false;\n}\n\n \nstatic struct msft_monitor_advertisement_handle_data *msft_find_handle_data\n\t\t\t\t(struct hci_dev *hdev, u16 handle, bool is_mgmt)\n{\n\tstruct msft_monitor_advertisement_handle_data *entry;\n\tstruct msft_data *msft = hdev->msft_data;\n\n\tlist_for_each_entry(entry, &msft->handle_map, list) {\n\t\tif (is_mgmt && entry->mgmt_handle == handle)\n\t\t\treturn entry;\n\t\tif (!is_mgmt && entry->msft_handle == handle)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct msft_monitor_addr_filter_data *msft_find_address_data\n\t\t\t(struct hci_dev *hdev, u8 addr_type, bdaddr_t *addr,\n\t\t\t u8 pattern_handle)\n{\n\tstruct msft_monitor_addr_filter_data *entry;\n\tstruct msft_data *msft = hdev->msft_data;\n\n\tlist_for_each_entry(entry, &msft->address_filters, list) {\n\t\tif (entry->pattern_handle == pattern_handle &&\n\t\t    addr_type == entry->addr_type &&\n\t\t    !bacmp(addr, &entry->bdaddr))\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int msft_monitor_device_del(struct hci_dev *hdev, __u16 mgmt_handle,\n\t\t\t\t   bdaddr_t *bdaddr, __u8 addr_type,\n\t\t\t\t   bool notify)\n{\n\tstruct monitored_device *dev, *tmp;\n\tint count = 0;\n\n\tlist_for_each_entry_safe(dev, tmp, &hdev->monitored_devices, list) {\n\t\t \n\t\tif ((!mgmt_handle || dev->handle == mgmt_handle) &&\n\t\t    (!bdaddr || (!bacmp(bdaddr, &dev->bdaddr) &&\n\t\t\t\t addr_type == dev->addr_type))) {\n\t\t\tif (notify && dev->notified) {\n\t\t\t\tmgmt_adv_monitor_device_lost(hdev, dev->handle,\n\t\t\t\t\t\t\t     &dev->bdaddr,\n\t\t\t\t\t\t\t     dev->addr_type);\n\t\t\t}\n\n\t\t\tlist_del(&dev->list);\n\t\t\tkfree(dev);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic int msft_le_monitor_advertisement_cb(struct hci_dev *hdev, u16 opcode,\n\t\t\t\t\t    struct adv_monitor *monitor,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct msft_rp_le_monitor_advertisement *rp;\n\tstruct msft_monitor_advertisement_handle_data *handle_data;\n\tstruct msft_data *msft = hdev->msft_data;\n\tint status = 0;\n\n\thci_dev_lock(hdev);\n\n\trp = (struct msft_rp_le_monitor_advertisement *)skb->data;\n\tif (skb->len < sizeof(*rp)) {\n\t\tstatus = HCI_ERROR_UNSPECIFIED;\n\t\tgoto unlock;\n\t}\n\n\tstatus = rp->status;\n\tif (status)\n\t\tgoto unlock;\n\n\thandle_data = kmalloc(sizeof(*handle_data), GFP_KERNEL);\n\tif (!handle_data) {\n\t\tstatus = HCI_ERROR_UNSPECIFIED;\n\t\tgoto unlock;\n\t}\n\n\thandle_data->mgmt_handle = monitor->handle;\n\thandle_data->msft_handle = rp->handle;\n\thandle_data->cond_type   = MSFT_MONITOR_ADVERTISEMENT_TYPE_PATTERN;\n\tINIT_LIST_HEAD(&handle_data->list);\n\tlist_add(&handle_data->list, &msft->handle_map);\n\n\tmonitor->state = ADV_MONITOR_STATE_OFFLOADED;\n\nunlock:\n\tif (status)\n\t\thci_free_adv_monitor(hdev, monitor);\n\n\thci_dev_unlock(hdev);\n\n\treturn status;\n}\n\n \nstatic void msft_remove_addr_filters_sync(struct hci_dev *hdev, u8 handle)\n{\n\tstruct msft_monitor_addr_filter_data *address_filter, *n;\n\tstruct msft_cp_le_cancel_monitor_advertisement cp;\n\tstruct msft_data *msft = hdev->msft_data;\n\tstruct list_head head;\n\tstruct sk_buff *skb;\n\n\tINIT_LIST_HEAD(&head);\n\n\t \n\tmutex_lock(&msft->filter_lock);\n\n\tlist_for_each_entry_safe(address_filter, n, &msft->address_filters,\n\t\t\t\t list) {\n\t\tif (address_filter->pattern_handle != handle)\n\t\t\tcontinue;\n\n\t\tlist_del(&address_filter->list);\n\n\t\t \n\t\tif (address_filter->state == AF_STATE_ADDING) {\n\t\t\taddress_filter->state = AF_STATE_REMOVING;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (address_filter->state == AF_STATE_REMOVING)\n\t\t\tcontinue;\n\n\t\tlist_add_tail(&address_filter->list, &head);\n\t}\n\n\tmutex_unlock(&msft->filter_lock);\n\n\tlist_for_each_entry_safe(address_filter, n, &head, list) {\n\t\tlist_del(&address_filter->list);\n\n\t\tcp.sub_opcode = MSFT_OP_LE_CANCEL_MONITOR_ADVERTISEMENT;\n\t\tcp.handle = address_filter->msft_handle;\n\n\t\tskb = __hci_cmd_sync(hdev, hdev->msft_opcode, sizeof(cp), &cp,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n\t\tif (IS_ERR_OR_NULL(skb)) {\n\t\t\tkfree(address_filter);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkfree_skb(skb);\n\n\t\tbt_dev_dbg(hdev, \"MSFT: Canceled device %pMR address filter\",\n\t\t\t   &address_filter->bdaddr);\n\n\t\tkfree(address_filter);\n\t}\n}\n\nstatic int msft_le_cancel_monitor_advertisement_cb(struct hci_dev *hdev,\n\t\t\t\t\t\t   u16 opcode,\n\t\t\t\t\t\t   struct adv_monitor *monitor,\n\t\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct msft_rp_le_cancel_monitor_advertisement *rp;\n\tstruct msft_monitor_advertisement_handle_data *handle_data;\n\tstruct msft_data *msft = hdev->msft_data;\n\tint status = 0;\n\tu8 msft_handle;\n\n\trp = (struct msft_rp_le_cancel_monitor_advertisement *)skb->data;\n\tif (skb->len < sizeof(*rp)) {\n\t\tstatus = HCI_ERROR_UNSPECIFIED;\n\t\tgoto done;\n\t}\n\n\tstatus = rp->status;\n\tif (status)\n\t\tgoto done;\n\n\thci_dev_lock(hdev);\n\n\thandle_data = msft_find_handle_data(hdev, monitor->handle, true);\n\n\tif (handle_data) {\n\t\tif (monitor->state == ADV_MONITOR_STATE_OFFLOADED)\n\t\t\tmonitor->state = ADV_MONITOR_STATE_REGISTERED;\n\n\t\t \n\t\tif (!msft->suspending) {\n\t\t\thci_free_adv_monitor(hdev, monitor);\n\n\t\t\t \n\t\t\tmsft_monitor_device_del(hdev, handle_data->mgmt_handle,\n\t\t\t\t\t\tNULL, 0, false);\n\t\t}\n\n\t\tmsft_handle = handle_data->msft_handle;\n\n\t\tlist_del(&handle_data->list);\n\t\tkfree(handle_data);\n\n\t\thci_dev_unlock(hdev);\n\n\t\tmsft_remove_addr_filters_sync(hdev, msft_handle);\n\t} else {\n\t\thci_dev_unlock(hdev);\n\t}\n\ndone:\n\treturn status;\n}\n\n \nstatic int msft_remove_monitor_sync(struct hci_dev *hdev,\n\t\t\t\t    struct adv_monitor *monitor)\n{\n\tstruct msft_cp_le_cancel_monitor_advertisement cp;\n\tstruct msft_monitor_advertisement_handle_data *handle_data;\n\tstruct sk_buff *skb;\n\n\thandle_data = msft_find_handle_data(hdev, monitor->handle, true);\n\n\t \n\tif (!handle_data)\n\t\treturn -ENOENT;\n\n\tcp.sub_opcode = MSFT_OP_LE_CANCEL_MONITOR_ADVERTISEMENT;\n\tcp.handle = handle_data->msft_handle;\n\n\tskb = __hci_cmd_sync(hdev, hdev->msft_opcode, sizeof(cp), &cp,\n\t\t\t     HCI_CMD_TIMEOUT);\n\tif (IS_ERR_OR_NULL(skb)) {\n\t\tif (!skb)\n\t\t\treturn -EIO;\n\t\treturn PTR_ERR(skb);\n\t}\n\n\treturn msft_le_cancel_monitor_advertisement_cb(hdev, hdev->msft_opcode,\n\t\t\t\t\t\t       monitor, skb);\n}\n\n \nint msft_suspend_sync(struct hci_dev *hdev)\n{\n\tstruct msft_data *msft = hdev->msft_data;\n\tstruct adv_monitor *monitor;\n\tint handle = 0;\n\n\tif (!msft || !msft_monitor_supported(hdev))\n\t\treturn 0;\n\n\tmsft->suspending = true;\n\n\twhile (1) {\n\t\tmonitor = idr_get_next(&hdev->adv_monitors_idr, &handle);\n\t\tif (!monitor)\n\t\t\tbreak;\n\n\t\tmsft_remove_monitor_sync(hdev, monitor);\n\n\t\thandle++;\n\t}\n\n\t \n\tmsft->suspending = false;\n\n\treturn 0;\n}\n\nstatic bool msft_monitor_rssi_valid(struct adv_monitor *monitor)\n{\n\tstruct adv_rssi_thresholds *r = &monitor->rssi;\n\n\tif (r->high_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||\n\t    r->high_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX ||\n\t    r->low_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||\n\t    r->low_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX)\n\t\treturn false;\n\n\t \n\tif (r->high_threshold_timeout != 0)\n\t\treturn false;\n\n\tif (r->low_threshold_timeout > MSFT_RSSI_LOW_TIMEOUT_MAX)\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nstatic bool msft_monitor_pattern_valid(struct adv_monitor *monitor)\n{\n\treturn msft_monitor_rssi_valid(monitor);\n\t \n}\n\nstatic int msft_add_monitor_sync(struct hci_dev *hdev,\n\t\t\t\t struct adv_monitor *monitor)\n{\n\tstruct msft_cp_le_monitor_advertisement *cp;\n\tstruct msft_le_monitor_advertisement_pattern_data *pattern_data;\n\tstruct msft_monitor_advertisement_handle_data *handle_data;\n\tstruct msft_le_monitor_advertisement_pattern *pattern;\n\tstruct adv_pattern *entry;\n\tsize_t total_size = sizeof(*cp) + sizeof(*pattern_data);\n\tptrdiff_t offset = 0;\n\tu8 pattern_count = 0;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (!msft_monitor_pattern_valid(monitor))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(entry, &monitor->patterns, list) {\n\t\tpattern_count++;\n\t\ttotal_size += sizeof(*pattern) + entry->length;\n\t}\n\n\tcp = kmalloc(total_size, GFP_KERNEL);\n\tif (!cp)\n\t\treturn -ENOMEM;\n\n\tcp->sub_opcode = MSFT_OP_LE_MONITOR_ADVERTISEMENT;\n\tcp->rssi_high = monitor->rssi.high_threshold;\n\tcp->rssi_low = monitor->rssi.low_threshold;\n\tcp->rssi_low_interval = (u8)monitor->rssi.low_threshold_timeout;\n\tcp->rssi_sampling_period = monitor->rssi.sampling_period;\n\n\tcp->cond_type = MSFT_MONITOR_ADVERTISEMENT_TYPE_PATTERN;\n\n\tpattern_data = (void *)cp->data;\n\tpattern_data->count = pattern_count;\n\n\tlist_for_each_entry(entry, &monitor->patterns, list) {\n\t\tpattern = (void *)(pattern_data->data + offset);\n\t\t \n\t\tpattern->length = entry->length + 2;\n\t\tpattern->data_type = entry->ad_type;\n\t\tpattern->start_byte = entry->offset;\n\t\tmemcpy(pattern->pattern, entry->value, entry->length);\n\t\toffset += sizeof(*pattern) + entry->length;\n\t}\n\n\tskb = __hci_cmd_sync(hdev, hdev->msft_opcode, total_size, cp,\n\t\t\t     HCI_CMD_TIMEOUT);\n\n\tif (IS_ERR_OR_NULL(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tgoto out_free;\n\t}\n\n\terr = msft_le_monitor_advertisement_cb(hdev, hdev->msft_opcode,\n\t\t\t\t\t       monitor, skb);\n\tif (err)\n\t\tgoto out_free;\n\n\thandle_data = msft_find_handle_data(hdev, monitor->handle, true);\n\tif (!handle_data) {\n\t\terr = -ENODATA;\n\t\tgoto out_free;\n\t}\n\n\thandle_data->rssi_high\t= cp->rssi_high;\n\thandle_data->rssi_low\t= cp->rssi_low;\n\thandle_data->rssi_low_interval\t  = cp->rssi_low_interval;\n\thandle_data->rssi_sampling_period = cp->rssi_sampling_period;\n\nout_free:\n\tkfree(cp);\n\treturn err;\n}\n\n \nstatic void reregister_monitor(struct hci_dev *hdev)\n{\n\tstruct adv_monitor *monitor;\n\tstruct msft_data *msft = hdev->msft_data;\n\tint handle = 0;\n\n\tif (!msft)\n\t\treturn;\n\n\tmsft->resuming = true;\n\n\twhile (1) {\n\t\tmonitor = idr_get_next(&hdev->adv_monitors_idr, &handle);\n\t\tif (!monitor)\n\t\t\tbreak;\n\n\t\tmsft_add_monitor_sync(hdev, monitor);\n\n\t\thandle++;\n\t}\n\n\t \n\tmsft->resuming = false;\n}\n\n \nint msft_resume_sync(struct hci_dev *hdev)\n{\n\tstruct msft_data *msft = hdev->msft_data;\n\n\tif (!msft || !msft_monitor_supported(hdev))\n\t\treturn 0;\n\n\thci_dev_lock(hdev);\n\n\t \n\thdev->advmon_pend_notify = false;\n\tmsft_monitor_device_del(hdev, 0, NULL, 0, true);\n\n\thci_dev_unlock(hdev);\n\n\treregister_monitor(hdev);\n\n\treturn 0;\n}\n\n \nvoid msft_do_open(struct hci_dev *hdev)\n{\n\tstruct msft_data *msft = hdev->msft_data;\n\n\tif (hdev->msft_opcode == HCI_OP_NOP)\n\t\treturn;\n\n\tif (!msft) {\n\t\tbt_dev_err(hdev, \"MSFT extension not registered\");\n\t\treturn;\n\t}\n\n\tbt_dev_dbg(hdev, \"Initialize MSFT extension\");\n\n\t \n\tkfree(msft->evt_prefix);\n\tmsft->evt_prefix = NULL;\n\tmsft->evt_prefix_len = 0;\n\tmsft->features = 0;\n\n\tif (!read_supported_features(hdev, msft)) {\n\t\thdev->msft_data = NULL;\n\t\tkfree(msft);\n\t\treturn;\n\t}\n\n\tif (msft_monitor_supported(hdev)) {\n\t\tmsft->resuming = true;\n\t\tmsft_set_filter_enable(hdev, true);\n\t\t \n\t\treregister_monitor(hdev);\n\t}\n}\n\nvoid msft_do_close(struct hci_dev *hdev)\n{\n\tstruct msft_data *msft = hdev->msft_data;\n\tstruct msft_monitor_advertisement_handle_data *handle_data, *tmp;\n\tstruct msft_monitor_addr_filter_data *address_filter, *n;\n\tstruct adv_monitor *monitor;\n\n\tif (!msft)\n\t\treturn;\n\n\tbt_dev_dbg(hdev, \"Cleanup of MSFT extension\");\n\n\t \n\tlist_for_each_entry_safe(handle_data, tmp, &msft->handle_map, list) {\n\t\tmonitor = idr_find(&hdev->adv_monitors_idr,\n\t\t\t\t   handle_data->mgmt_handle);\n\n\t\tif (monitor && monitor->state == ADV_MONITOR_STATE_OFFLOADED)\n\t\t\tmonitor->state = ADV_MONITOR_STATE_REGISTERED;\n\n\t\tlist_del(&handle_data->list);\n\t\tkfree(handle_data);\n\t}\n\n\tmutex_lock(&msft->filter_lock);\n\tlist_for_each_entry_safe(address_filter, n, &msft->address_filters,\n\t\t\t\t list) {\n\t\tlist_del(&address_filter->list);\n\t\tkfree(address_filter);\n\t}\n\tmutex_unlock(&msft->filter_lock);\n\n\thci_dev_lock(hdev);\n\n\t \n\thdev->advmon_pend_notify = false;\n\tmsft_monitor_device_del(hdev, 0, NULL, 0, true);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic int msft_cancel_address_filter_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct msft_monitor_addr_filter_data *address_filter = data;\n\tstruct msft_cp_le_cancel_monitor_advertisement cp;\n\tstruct msft_data *msft = hdev->msft_data;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tif (!msft) {\n\t\tbt_dev_err(hdev, \"MSFT: msft data is freed\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn 0;\n\n\tmutex_lock(&msft->filter_lock);\n\tlist_del(&address_filter->list);\n\tmutex_unlock(&msft->filter_lock);\n\n\tcp.sub_opcode = MSFT_OP_LE_CANCEL_MONITOR_ADVERTISEMENT;\n\tcp.handle = address_filter->msft_handle;\n\n\tskb = __hci_cmd_sync(hdev, hdev->msft_opcode, sizeof(cp), &cp,\n\t\t\t     HCI_CMD_TIMEOUT);\n\tif (IS_ERR_OR_NULL(skb)) {\n\t\tbt_dev_err(hdev, \"MSFT: Failed to cancel address (%pMR) filter\",\n\t\t\t   &address_filter->bdaddr);\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\tkfree_skb(skb);\n\n\tbt_dev_dbg(hdev, \"MSFT: Canceled device %pMR address filter\",\n\t\t   &address_filter->bdaddr);\n\ndone:\n\tkfree(address_filter);\n\n\treturn err;\n}\n\nvoid msft_register(struct hci_dev *hdev)\n{\n\tstruct msft_data *msft = NULL;\n\n\tbt_dev_dbg(hdev, \"Register MSFT extension\");\n\n\tmsft = kzalloc(sizeof(*msft), GFP_KERNEL);\n\tif (!msft) {\n\t\tbt_dev_err(hdev, \"Failed to register MSFT extension\");\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&msft->handle_map);\n\tINIT_LIST_HEAD(&msft->address_filters);\n\thdev->msft_data = msft;\n\tmutex_init(&msft->filter_lock);\n}\n\nvoid msft_unregister(struct hci_dev *hdev)\n{\n\tstruct msft_data *msft = hdev->msft_data;\n\n\tif (!msft)\n\t\treturn;\n\n\tbt_dev_dbg(hdev, \"Unregister MSFT extension\");\n\n\thdev->msft_data = NULL;\n\n\tkfree(msft->evt_prefix);\n\tmutex_destroy(&msft->filter_lock);\n\tkfree(msft);\n}\n\n \nstatic void msft_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      __u8 addr_type, __u16 mgmt_handle)\n{\n\tstruct monitored_device *dev;\n\n\tdev = kmalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tbt_dev_err(hdev, \"MSFT vendor event %u: no memory\",\n\t\t\t   MSFT_EV_LE_MONITOR_DEVICE);\n\t\treturn;\n\t}\n\n\tbacpy(&dev->bdaddr, bdaddr);\n\tdev->addr_type = addr_type;\n\tdev->handle = mgmt_handle;\n\tdev->notified = false;\n\n\tINIT_LIST_HEAD(&dev->list);\n\tlist_add(&dev->list, &hdev->monitored_devices);\n\thdev->advmon_pend_notify = true;\n}\n\n \nstatic void msft_device_lost(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t     __u8 addr_type, __u16 mgmt_handle)\n{\n\tif (!msft_monitor_device_del(hdev, mgmt_handle, bdaddr, addr_type,\n\t\t\t\t     true)) {\n\t\tbt_dev_err(hdev, \"MSFT vendor event %u: dev %pMR not in list\",\n\t\t\t   MSFT_EV_LE_MONITOR_DEVICE, bdaddr);\n\t}\n}\n\nstatic void *msft_skb_pull(struct hci_dev *hdev, struct sk_buff *skb,\n\t\t\t   u8 ev, size_t len)\n{\n\tvoid *data;\n\n\tdata = skb_pull_data(skb, len);\n\tif (!data)\n\t\tbt_dev_err(hdev, \"Malformed MSFT vendor event: 0x%02x\", ev);\n\n\treturn data;\n}\n\nstatic int msft_add_address_filter_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct msft_monitor_addr_filter_data *address_filter = data;\n\tstruct msft_rp_le_monitor_advertisement *rp;\n\tstruct msft_cp_le_monitor_advertisement *cp;\n\tstruct msft_data *msft = hdev->msft_data;\n\tstruct sk_buff *skb = NULL;\n\tbool remove = false;\n\tsize_t size;\n\n\tif (!msft) {\n\t\tbt_dev_err(hdev, \"MSFT: msft data is freed\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENODEV;\n\n\t \n\n\tif (address_filter->state == AF_STATE_REMOVING) {\n\t\tmutex_lock(&msft->filter_lock);\n\t\tlist_del(&address_filter->list);\n\t\tmutex_unlock(&msft->filter_lock);\n\t\tkfree(address_filter);\n\t\treturn 0;\n\t}\n\n\tsize = sizeof(*cp) +\n\t       sizeof(address_filter->addr_type) +\n\t       sizeof(address_filter->bdaddr);\n\tcp = kzalloc(size, GFP_KERNEL);\n\tif (!cp) {\n\t\tbt_dev_err(hdev, \"MSFT: Alloc cmd param err\");\n\t\tremove = true;\n\t\tgoto done;\n\t}\n\tcp->sub_opcode           = MSFT_OP_LE_MONITOR_ADVERTISEMENT;\n\tcp->rssi_high\t\t = address_filter->rssi_high;\n\tcp->rssi_low\t\t = address_filter->rssi_low;\n\tcp->rssi_low_interval    = address_filter->rssi_low_interval;\n\tcp->rssi_sampling_period = address_filter->rssi_sampling_period;\n\tcp->cond_type            = MSFT_MONITOR_ADVERTISEMENT_TYPE_ADDR;\n\tcp->data[0]              = address_filter->addr_type;\n\tmemcpy(&cp->data[1], &address_filter->bdaddr,\n\t       sizeof(address_filter->bdaddr));\n\n\tskb = __hci_cmd_sync(hdev, hdev->msft_opcode, size, cp,\n\t\t\t     HCI_CMD_TIMEOUT);\n\tif (IS_ERR_OR_NULL(skb)) {\n\t\tbt_dev_err(hdev, \"Failed to enable address %pMR filter\",\n\t\t\t   &address_filter->bdaddr);\n\t\tskb = NULL;\n\t\tremove = true;\n\t\tgoto done;\n\t}\n\n\trp = skb_pull_data(skb, sizeof(*rp));\n\tif (!rp || rp->sub_opcode != MSFT_OP_LE_MONITOR_ADVERTISEMENT ||\n\t    rp->status)\n\t\tremove = true;\n\ndone:\n\tmutex_lock(&msft->filter_lock);\n\n\tif (remove) {\n\t\tbt_dev_warn(hdev, \"MSFT: Remove address (%pMR) filter\",\n\t\t\t    &address_filter->bdaddr);\n\t\tlist_del(&address_filter->list);\n\t\tkfree(address_filter);\n\t} else {\n\t\taddress_filter->state = AF_STATE_ADDED;\n\t\taddress_filter->msft_handle = rp->handle;\n\t\tbt_dev_dbg(hdev, \"MSFT: Address %pMR filter enabled\",\n\t\t\t   &address_filter->bdaddr);\n\t}\n\tmutex_unlock(&msft->filter_lock);\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\n \nstatic struct msft_monitor_addr_filter_data *msft_add_address_filter\n\t\t(struct hci_dev *hdev, u8 addr_type, bdaddr_t *bdaddr,\n\t\t struct msft_monitor_advertisement_handle_data *handle_data)\n{\n\tstruct msft_monitor_addr_filter_data *address_filter = NULL;\n\tstruct msft_data *msft = hdev->msft_data;\n\tint err;\n\n\taddress_filter = kzalloc(sizeof(*address_filter), GFP_KERNEL);\n\tif (!address_filter)\n\t\treturn NULL;\n\n\taddress_filter->state             = AF_STATE_ADDING;\n\taddress_filter->msft_handle       = 0xff;\n\taddress_filter->pattern_handle    = handle_data->msft_handle;\n\taddress_filter->mgmt_handle       = handle_data->mgmt_handle;\n\taddress_filter->rssi_high         = handle_data->rssi_high;\n\taddress_filter->rssi_low          = handle_data->rssi_low;\n\taddress_filter->rssi_low_interval = handle_data->rssi_low_interval;\n\taddress_filter->rssi_sampling_period = handle_data->rssi_sampling_period;\n\taddress_filter->addr_type            = addr_type;\n\tbacpy(&address_filter->bdaddr, bdaddr);\n\n\t \n\tlist_add_tail(&address_filter->list, &msft->address_filters);\n\n\terr = hci_cmd_sync_queue(hdev, msft_add_address_filter_sync,\n\t\t\t\t address_filter, NULL);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"MSFT: Add address %pMR filter err\", bdaddr);\n\t\tlist_del(&address_filter->list);\n\t\tkfree(address_filter);\n\t\treturn NULL;\n\t}\n\n\tbt_dev_dbg(hdev, \"MSFT: Add device %pMR address filter\",\n\t\t   &address_filter->bdaddr);\n\n\treturn address_filter;\n}\n\n \nstatic void msft_monitor_device_evt(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct msft_monitor_addr_filter_data *n, *address_filter = NULL;\n\tstruct msft_ev_le_monitor_device *ev;\n\tstruct msft_monitor_advertisement_handle_data *handle_data;\n\tstruct msft_data *msft = hdev->msft_data;\n\tu16 mgmt_handle = 0xffff;\n\tu8 addr_type;\n\n\tev = msft_skb_pull(hdev, skb, MSFT_EV_LE_MONITOR_DEVICE, sizeof(*ev));\n\tif (!ev)\n\t\treturn;\n\n\tbt_dev_dbg(hdev,\n\t\t   \"MSFT vendor event 0x%02x: handle 0x%04x state %d addr %pMR\",\n\t\t   MSFT_EV_LE_MONITOR_DEVICE, ev->monitor_handle,\n\t\t   ev->monitor_state, &ev->bdaddr);\n\n\thandle_data = msft_find_handle_data(hdev, ev->monitor_handle, false);\n\n\tif (!test_bit(HCI_QUIRK_USE_MSFT_EXT_ADDRESS_FILTER, &hdev->quirks)) {\n\t\tif (!handle_data)\n\t\t\treturn;\n\t\tmgmt_handle = handle_data->mgmt_handle;\n\t\tgoto report_state;\n\t}\n\n\tif (handle_data) {\n\t\t \n\n\t\taddress_filter = msft_find_address_data(hdev, ev->addr_type,\n\t\t\t\t\t\t\t&ev->bdaddr,\n\t\t\t\t\t\t\thandle_data->msft_handle);\n\t\tif (address_filter)\n\t\t\treturn;\n\n\t\tif (ev->monitor_state && handle_data->cond_type ==\n\t\t\t\tMSFT_MONITOR_ADVERTISEMENT_TYPE_PATTERN)\n\t\t\tmsft_add_address_filter(hdev, ev->addr_type,\n\t\t\t\t\t\t&ev->bdaddr, handle_data);\n\n\t\treturn;\n\t}\n\n\t \n\tlist_for_each_entry(n, &msft->address_filters, list) {\n\t\tif (n->state == AF_STATE_ADDED &&\n\t\t    n->msft_handle == ev->monitor_handle) {\n\t\t\tmgmt_handle = n->mgmt_handle;\n\t\t\taddress_filter = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!address_filter) {\n\t\tbt_dev_warn(hdev, \"MSFT: Unexpected device event %pMR, %u, %u\",\n\t\t\t    &ev->bdaddr, ev->monitor_handle, ev->monitor_state);\n\t\treturn;\n\t}\n\nreport_state:\n\tswitch (ev->addr_type) {\n\tcase ADDR_LE_DEV_PUBLIC:\n\t\taddr_type = BDADDR_LE_PUBLIC;\n\t\tbreak;\n\n\tcase ADDR_LE_DEV_RANDOM:\n\t\taddr_type = BDADDR_LE_RANDOM;\n\t\tbreak;\n\n\tdefault:\n\t\tbt_dev_err(hdev,\n\t\t\t   \"MSFT vendor event 0x%02x: unknown addr type 0x%02x\",\n\t\t\t   MSFT_EV_LE_MONITOR_DEVICE, ev->addr_type);\n\t\treturn;\n\t}\n\n\tif (ev->monitor_state) {\n\t\tmsft_device_found(hdev, &ev->bdaddr, addr_type, mgmt_handle);\n\t} else {\n\t\tif (address_filter && address_filter->state == AF_STATE_ADDED) {\n\t\t\taddress_filter->state = AF_STATE_REMOVING;\n\t\t\thci_cmd_sync_queue(hdev,\n\t\t\t\t\t   msft_cancel_address_filter_sync,\n\t\t\t\t\t   address_filter,\n\t\t\t\t\t   NULL);\n\t\t}\n\t\tmsft_device_lost(hdev, &ev->bdaddr, addr_type, mgmt_handle);\n\t}\n}\n\nvoid msft_vendor_evt(struct hci_dev *hdev, void *data, struct sk_buff *skb)\n{\n\tstruct msft_data *msft = hdev->msft_data;\n\tu8 *evt_prefix;\n\tu8 *evt;\n\n\tif (!msft)\n\t\treturn;\n\n\t \n\tif (msft->evt_prefix_len > 0) {\n\t\tevt_prefix = msft_skb_pull(hdev, skb, 0, msft->evt_prefix_len);\n\t\tif (!evt_prefix)\n\t\t\treturn;\n\n\t\tif (memcmp(evt_prefix, msft->evt_prefix, msft->evt_prefix_len))\n\t\t\treturn;\n\t}\n\n\t \n\tif (skb->len < 1)\n\t\treturn;\n\n\tevt = msft_skb_pull(hdev, skb, 0, sizeof(*evt));\n\tif (!evt)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tswitch (*evt) {\n\tcase MSFT_EV_LE_MONITOR_DEVICE:\n\t\tmutex_lock(&msft->filter_lock);\n\t\tmsft_monitor_device_evt(hdev, skb);\n\t\tmutex_unlock(&msft->filter_lock);\n\t\tbreak;\n\n\tdefault:\n\t\tbt_dev_dbg(hdev, \"MSFT vendor event 0x%02x\", *evt);\n\t\tbreak;\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\n__u64 msft_get_features(struct hci_dev *hdev)\n{\n\tstruct msft_data *msft = hdev->msft_data;\n\n\treturn msft ? msft->features : 0;\n}\n\nstatic void msft_le_set_advertisement_filter_enable_cb(struct hci_dev *hdev,\n\t\t\t\t\t\t       void *user_data,\n\t\t\t\t\t\t       u8 status)\n{\n\tstruct msft_cp_le_set_advertisement_filter_enable *cp = user_data;\n\tstruct msft_data *msft = hdev->msft_data;\n\n\t \n\tif (status != 0x00 && status != 0x0C)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tmsft->filter_enabled = cp->enable;\n\n\tif (status == 0x0C)\n\t\tbt_dev_warn(hdev, \"MSFT filter_enable is already %s\",\n\t\t\t    cp->enable ? \"on\" : \"off\");\n\n\thci_dev_unlock(hdev);\n}\n\n \nint msft_add_monitor_pattern(struct hci_dev *hdev, struct adv_monitor *monitor)\n{\n\tstruct msft_data *msft = hdev->msft_data;\n\n\tif (!msft)\n\t\treturn -EOPNOTSUPP;\n\n\tif (msft->resuming || msft->suspending)\n\t\treturn -EBUSY;\n\n\treturn msft_add_monitor_sync(hdev, monitor);\n}\n\n \nint msft_remove_monitor(struct hci_dev *hdev, struct adv_monitor *monitor)\n{\n\tstruct msft_data *msft = hdev->msft_data;\n\n\tif (!msft)\n\t\treturn -EOPNOTSUPP;\n\n\tif (msft->resuming || msft->suspending)\n\t\treturn -EBUSY;\n\n\treturn msft_remove_monitor_sync(hdev, monitor);\n}\n\nint msft_set_filter_enable(struct hci_dev *hdev, bool enable)\n{\n\tstruct msft_cp_le_set_advertisement_filter_enable cp;\n\tstruct msft_data *msft = hdev->msft_data;\n\tint err;\n\n\tif (!msft)\n\t\treturn -EOPNOTSUPP;\n\n\tcp.sub_opcode = MSFT_OP_LE_SET_ADVERTISEMENT_FILTER_ENABLE;\n\tcp.enable = enable;\n\terr = __hci_cmd_sync_status(hdev, hdev->msft_opcode, sizeof(cp), &cp,\n\t\t\t\t    HCI_CMD_TIMEOUT);\n\n\tmsft_le_set_advertisement_filter_enable_cb(hdev, &cp, err);\n\n\treturn 0;\n}\n\nbool msft_curve_validity(struct hci_dev *hdev)\n{\n\treturn hdev->msft_curve_validity;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}