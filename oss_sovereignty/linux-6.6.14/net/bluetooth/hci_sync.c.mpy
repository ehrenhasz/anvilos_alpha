{
  "module_name": "hci_sync.c",
  "hash_id": "148961a3019e68176451552f5bd058d47dfe0907e5537510ead02ba153536890",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/hci_sync.c",
  "human_readable_source": "\n \n\n#include <linux/property.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/mgmt.h>\n\n#include \"hci_request.h\"\n#include \"hci_codec.h\"\n#include \"hci_debugfs.h\"\n#include \"smp.h\"\n#include \"eir.h\"\n#include \"msft.h\"\n#include \"aosp.h\"\n#include \"leds.h\"\n\nstatic void hci_cmd_sync_complete(struct hci_dev *hdev, u8 result, u16 opcode,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tbt_dev_dbg(hdev, \"result 0x%2.2x\", result);\n\n\tif (hdev->req_status != HCI_REQ_PEND)\n\t\treturn;\n\n\thdev->req_result = result;\n\thdev->req_status = HCI_REQ_DONE;\n\n\tif (skb) {\n\t\tstruct sock *sk = hci_skb_sk(skb);\n\n\t\t \n\t\tif (sk)\n\t\t\tsock_put(sk);\n\n\t\thdev->req_skb = skb_get(skb);\n\t}\n\n\twake_up_interruptible(&hdev->req_wait_q);\n}\n\nstatic struct sk_buff *hci_cmd_sync_alloc(struct hci_dev *hdev, u16 opcode,\n\t\t\t\t\t  u32 plen, const void *param,\n\t\t\t\t\t  struct sock *sk)\n{\n\tint len = HCI_COMMAND_HDR_SIZE + plen;\n\tstruct hci_command_hdr *hdr;\n\tstruct sk_buff *skb;\n\n\tskb = bt_skb_alloc(len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = skb_put(skb, HCI_COMMAND_HDR_SIZE);\n\thdr->opcode = cpu_to_le16(opcode);\n\thdr->plen   = plen;\n\n\tif (plen)\n\t\tskb_put_data(skb, param, plen);\n\n\tbt_dev_dbg(hdev, \"skb len %d\", skb->len);\n\n\thci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\n\thci_skb_opcode(skb) = opcode;\n\n\t \n\tif (sk) {\n\t\thci_skb_sk(skb) = sk;\n\t\tsock_hold(sk);\n\t}\n\n\treturn skb;\n}\n\nstatic void hci_cmd_sync_add(struct hci_request *req, u16 opcode, u32 plen,\n\t\t\t     const void *param, u8 event, struct sock *sk)\n{\n\tstruct hci_dev *hdev = req->hdev;\n\tstruct sk_buff *skb;\n\n\tbt_dev_dbg(hdev, \"opcode 0x%4.4x plen %d\", opcode, plen);\n\n\t \n\tif (req->err)\n\t\treturn;\n\n\tskb = hci_cmd_sync_alloc(hdev, opcode, plen, param, sk);\n\tif (!skb) {\n\t\tbt_dev_err(hdev, \"no memory for command (opcode 0x%4.4x)\",\n\t\t\t   opcode);\n\t\treq->err = -ENOMEM;\n\t\treturn;\n\t}\n\n\tif (skb_queue_empty(&req->cmd_q))\n\t\tbt_cb(skb)->hci.req_flags |= HCI_REQ_START;\n\n\thci_skb_event(skb) = event;\n\n\tskb_queue_tail(&req->cmd_q, skb);\n}\n\nstatic int hci_cmd_sync_run(struct hci_request *req)\n{\n\tstruct hci_dev *hdev = req->hdev;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\tbt_dev_dbg(hdev, \"length %u\", skb_queue_len(&req->cmd_q));\n\n\t \n\tif (req->err) {\n\t\tskb_queue_purge(&req->cmd_q);\n\t\treturn req->err;\n\t}\n\n\t \n\tif (skb_queue_empty(&req->cmd_q))\n\t\treturn -ENODATA;\n\n\tskb = skb_peek_tail(&req->cmd_q);\n\tbt_cb(skb)->hci.req_complete_skb = hci_cmd_sync_complete;\n\tbt_cb(skb)->hci.req_flags |= HCI_REQ_SKB;\n\n\tspin_lock_irqsave(&hdev->cmd_q.lock, flags);\n\tskb_queue_splice_tail(&req->cmd_q, &hdev->cmd_q);\n\tspin_unlock_irqrestore(&hdev->cmd_q.lock, flags);\n\n\tqueue_work(hdev->workqueue, &hdev->cmd_work);\n\n\treturn 0;\n}\n\n \nstruct sk_buff *__hci_cmd_sync_sk(struct hci_dev *hdev, u16 opcode, u32 plen,\n\t\t\t\t  const void *param, u8 event, u32 timeout,\n\t\t\t\t  struct sock *sk)\n{\n\tstruct hci_request req;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tbt_dev_dbg(hdev, \"Opcode 0x%4.4x\", opcode);\n\n\thci_req_init(&req, hdev);\n\n\thci_cmd_sync_add(&req, opcode, plen, param, event, sk);\n\n\thdev->req_status = HCI_REQ_PEND;\n\n\terr = hci_cmd_sync_run(&req);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\terr = wait_event_interruptible_timeout(hdev->req_wait_q,\n\t\t\t\t\t       hdev->req_status != HCI_REQ_PEND,\n\t\t\t\t\t       timeout);\n\n\tif (err == -ERESTARTSYS)\n\t\treturn ERR_PTR(-EINTR);\n\n\tswitch (hdev->req_status) {\n\tcase HCI_REQ_DONE:\n\t\terr = -bt_to_errno(hdev->req_result);\n\t\tbreak;\n\n\tcase HCI_REQ_CANCELED:\n\t\terr = -hdev->req_result;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ETIMEDOUT;\n\t\tbreak;\n\t}\n\n\thdev->req_status = 0;\n\thdev->req_result = 0;\n\tskb = hdev->req_skb;\n\thdev->req_skb = NULL;\n\n\tbt_dev_dbg(hdev, \"end: err %d\", err);\n\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\nEXPORT_SYMBOL(__hci_cmd_sync_sk);\n\n \nstruct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,\n\t\t\t       const void *param, u32 timeout)\n{\n\treturn __hci_cmd_sync_sk(hdev, opcode, plen, param, 0, timeout, NULL);\n}\nEXPORT_SYMBOL(__hci_cmd_sync);\n\n \nstruct sk_buff *hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,\n\t\t\t     const void *param, u32 timeout)\n{\n\tstruct sk_buff *skb;\n\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn ERR_PTR(-ENETDOWN);\n\n\tbt_dev_dbg(hdev, \"opcode 0x%4.4x plen %d\", opcode, plen);\n\n\thci_req_sync_lock(hdev);\n\tskb = __hci_cmd_sync(hdev, opcode, plen, param, timeout);\n\thci_req_sync_unlock(hdev);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(hci_cmd_sync);\n\n \nstruct sk_buff *__hci_cmd_sync_ev(struct hci_dev *hdev, u16 opcode, u32 plen,\n\t\t\t\t  const void *param, u8 event, u32 timeout)\n{\n\treturn __hci_cmd_sync_sk(hdev, opcode, plen, param, event, timeout,\n\t\t\t\t NULL);\n}\nEXPORT_SYMBOL(__hci_cmd_sync_ev);\n\n \nint __hci_cmd_sync_status_sk(struct hci_dev *hdev, u16 opcode, u32 plen,\n\t\t\t     const void *param, u8 event, u32 timeout,\n\t\t\t     struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tu8 status;\n\n\tskb = __hci_cmd_sync_sk(hdev, opcode, plen, param, event, timeout, sk);\n\tif (IS_ERR(skb)) {\n\t\tif (!event)\n\t\t\tbt_dev_err(hdev, \"Opcode 0x%4.4x failed: %ld\", opcode,\n\t\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\t \n\tif (!skb)\n\t\treturn 0;\n\n\tstatus = skb->data[0];\n\n\tkfree_skb(skb);\n\n\treturn status;\n}\nEXPORT_SYMBOL(__hci_cmd_sync_status_sk);\n\nint __hci_cmd_sync_status(struct hci_dev *hdev, u16 opcode, u32 plen,\n\t\t\t  const void *param, u32 timeout)\n{\n\treturn __hci_cmd_sync_status_sk(hdev, opcode, plen, param, 0, timeout,\n\t\t\t\t\tNULL);\n}\nEXPORT_SYMBOL(__hci_cmd_sync_status);\n\nstatic void hci_cmd_sync_work(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev, cmd_sync_work);\n\n\tbt_dev_dbg(hdev, \"\");\n\n\t \n\twhile (1) {\n\t\tstruct hci_cmd_sync_work_entry *entry;\n\n\t\tmutex_lock(&hdev->cmd_sync_work_lock);\n\t\tentry = list_first_entry_or_null(&hdev->cmd_sync_work_list,\n\t\t\t\t\t\t struct hci_cmd_sync_work_entry,\n\t\t\t\t\t\t list);\n\t\tif (entry)\n\t\t\tlist_del(&entry->list);\n\t\tmutex_unlock(&hdev->cmd_sync_work_lock);\n\n\t\tif (!entry)\n\t\t\tbreak;\n\n\t\tbt_dev_dbg(hdev, \"entry %p\", entry);\n\n\t\tif (entry->func) {\n\t\t\tint err;\n\n\t\t\thci_req_sync_lock(hdev);\n\t\t\terr = entry->func(hdev, entry->data);\n\t\t\tif (entry->destroy)\n\t\t\t\tentry->destroy(hdev, entry->data, err);\n\t\t\thci_req_sync_unlock(hdev);\n\t\t}\n\n\t\tkfree(entry);\n\t}\n}\n\nstatic void hci_cmd_sync_cancel_work(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev, cmd_sync_cancel_work);\n\n\tcancel_delayed_work_sync(&hdev->cmd_timer);\n\tcancel_delayed_work_sync(&hdev->ncmd_timer);\n\tatomic_set(&hdev->cmd_cnt, 1);\n\n\twake_up_interruptible(&hdev->req_wait_q);\n}\n\nstatic int hci_scan_disable_sync(struct hci_dev *hdev);\nstatic int scan_disable_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_scan_disable_sync(hdev);\n}\n\nstatic int hci_inquiry_sync(struct hci_dev *hdev, u8 length);\nstatic int interleaved_inquiry_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_inquiry_sync(hdev, DISCOV_INTERLEAVED_INQUIRY_LEN);\n}\n\nstatic void le_scan_disable(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev,\n\t\t\t\t\t    le_scan_disable.work);\n\tint status;\n\n\tbt_dev_dbg(hdev, \"\");\n\thci_dev_lock(hdev);\n\n\tif (!hci_dev_test_flag(hdev, HCI_LE_SCAN))\n\t\tgoto _return;\n\n\tcancel_delayed_work(&hdev->le_scan_restart);\n\n\tstatus = hci_cmd_sync_queue(hdev, scan_disable_sync, NULL, NULL);\n\tif (status) {\n\t\tbt_dev_err(hdev, \"failed to disable LE scan: %d\", status);\n\t\tgoto _return;\n\t}\n\n\thdev->discovery.scan_start = 0;\n\n\t \n\n\tif (hdev->discovery.type == DISCOV_TYPE_LE)\n\t\tgoto discov_stopped;\n\n\tif (hdev->discovery.type != DISCOV_TYPE_INTERLEAVED)\n\t\tgoto _return;\n\n\tif (test_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks)) {\n\t\tif (!test_bit(HCI_INQUIRY, &hdev->flags) &&\n\t\t    hdev->discovery.state != DISCOVERY_RESOLVING)\n\t\t\tgoto discov_stopped;\n\n\t\tgoto _return;\n\t}\n\n\tstatus = hci_cmd_sync_queue(hdev, interleaved_inquiry_sync, NULL, NULL);\n\tif (status) {\n\t\tbt_dev_err(hdev, \"inquiry failed: status %d\", status);\n\t\tgoto discov_stopped;\n\t}\n\n\tgoto _return;\n\ndiscov_stopped:\n\thci_discovery_set_state(hdev, DISCOVERY_STOPPED);\n\n_return:\n\thci_dev_unlock(hdev);\n}\n\nstatic int hci_le_set_scan_enable_sync(struct hci_dev *hdev, u8 val,\n\t\t\t\t       u8 filter_dup);\nstatic int hci_le_scan_restart_sync(struct hci_dev *hdev)\n{\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_SCAN))\n\t\treturn 0;\n\n\tif (hdev->scanning_paused) {\n\t\tbt_dev_dbg(hdev, \"Scanning is paused for suspend\");\n\t\treturn 0;\n\t}\n\n\thci_le_set_scan_enable_sync(hdev, LE_SCAN_DISABLE, 0x00);\n\treturn hci_le_set_scan_enable_sync(hdev, LE_SCAN_ENABLE,\n\t\t\t\t\t   LE_SCAN_FILTER_DUP_ENABLE);\n}\n\nstatic void le_scan_restart(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev,\n\t\t\t\t\t    le_scan_restart.work);\n\tunsigned long timeout, duration, scan_start, now;\n\tint status;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tstatus = hci_le_scan_restart_sync(hdev);\n\tif (status) {\n\t\tbt_dev_err(hdev, \"failed to restart LE scan: status %d\",\n\t\t\t   status);\n\t\treturn;\n\t}\n\n\thci_dev_lock(hdev);\n\n\tif (!test_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks) ||\n\t    !hdev->discovery.scan_start)\n\t\tgoto unlock;\n\n\t \n\tduration = hdev->discovery.scan_duration;\n\tscan_start = hdev->discovery.scan_start;\n\tnow = jiffies;\n\tif (now - scan_start <= duration) {\n\t\tint elapsed;\n\n\t\tif (now >= scan_start)\n\t\t\telapsed = now - scan_start;\n\t\telse\n\t\t\telapsed = ULONG_MAX - scan_start + now;\n\n\t\ttimeout = duration - elapsed;\n\t} else {\n\t\ttimeout = 0;\n\t}\n\n\tqueue_delayed_work(hdev->req_workqueue,\n\t\t\t   &hdev->le_scan_disable, timeout);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int reenable_adv_sync(struct hci_dev *hdev, void *data)\n{\n\tbt_dev_dbg(hdev, \"\");\n\n\tif (!hci_dev_test_flag(hdev, HCI_ADVERTISING) &&\n\t    list_empty(&hdev->adv_instances))\n\t\treturn 0;\n\n\tif (hdev->cur_adv_instance) {\n\t\treturn hci_schedule_adv_instance_sync(hdev,\n\t\t\t\t\t\t      hdev->cur_adv_instance,\n\t\t\t\t\t\t      true);\n\t} else {\n\t\tif (ext_adv_capable(hdev)) {\n\t\t\thci_start_ext_adv_sync(hdev, 0x00);\n\t\t} else {\n\t\t\thci_update_adv_data_sync(hdev, 0x00);\n\t\t\thci_update_scan_rsp_data_sync(hdev, 0x00);\n\t\t\thci_enable_advertising_sync(hdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void reenable_adv(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev,\n\t\t\t\t\t    reenable_adv_work);\n\tint status;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\tstatus = hci_cmd_sync_queue(hdev, reenable_adv_sync, NULL, NULL);\n\tif (status)\n\t\tbt_dev_err(hdev, \"failed to reenable ADV: %d\", status);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void cancel_adv_timeout(struct hci_dev *hdev)\n{\n\tif (hdev->adv_instance_timeout) {\n\t\thdev->adv_instance_timeout = 0;\n\t\tcancel_delayed_work(&hdev->adv_instance_expire);\n\t}\n}\n\n \nint hci_clear_adv_instance_sync(struct hci_dev *hdev, struct sock *sk,\n\t\t\t\tu8 instance, bool force)\n{\n\tstruct adv_info *adv_instance, *n, *next_instance = NULL;\n\tint err;\n\tu8 rem_inst;\n\n\t \n\tif (!instance || hdev->cur_adv_instance == instance)\n\t\tcancel_adv_timeout(hdev);\n\n\t \n\tif (instance && hdev->cur_adv_instance == instance)\n\t\tnext_instance = hci_get_next_instance(hdev, instance);\n\n\tif (instance == 0x00) {\n\t\tlist_for_each_entry_safe(adv_instance, n, &hdev->adv_instances,\n\t\t\t\t\t list) {\n\t\t\tif (!(force || adv_instance->timeout))\n\t\t\t\tcontinue;\n\n\t\t\trem_inst = adv_instance->instance;\n\t\t\terr = hci_remove_adv_instance(hdev, rem_inst);\n\t\t\tif (!err)\n\t\t\t\tmgmt_advertising_removed(sk, hdev, rem_inst);\n\t\t}\n\t} else {\n\t\tadv_instance = hci_find_adv_instance(hdev, instance);\n\n\t\tif (force || (adv_instance && adv_instance->timeout &&\n\t\t\t      !adv_instance->remaining_time)) {\n\t\t\t \n\t\t\tif (next_instance &&\n\t\t\t    next_instance->instance == instance)\n\t\t\t\tnext_instance = NULL;\n\n\t\t\terr = hci_remove_adv_instance(hdev, instance);\n\t\t\tif (!err)\n\t\t\t\tmgmt_advertising_removed(sk, hdev, instance);\n\t\t}\n\t}\n\n\tif (!hdev_is_powered(hdev) || hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\treturn 0;\n\n\tif (next_instance && !ext_adv_capable(hdev))\n\t\treturn hci_schedule_adv_instance_sync(hdev,\n\t\t\t\t\t\t      next_instance->instance,\n\t\t\t\t\t\t      false);\n\n\treturn 0;\n}\n\nstatic int adv_timeout_expire_sync(struct hci_dev *hdev, void *data)\n{\n\tu8 instance = *(u8 *)data;\n\n\tkfree(data);\n\n\thci_clear_adv_instance_sync(hdev, NULL, instance, false);\n\n\tif (list_empty(&hdev->adv_instances))\n\t\treturn hci_disable_advertising_sync(hdev);\n\n\treturn 0;\n}\n\nstatic void adv_timeout_expire(struct work_struct *work)\n{\n\tu8 *inst_ptr;\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev,\n\t\t\t\t\t    adv_instance_expire.work);\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\thdev->adv_instance_timeout = 0;\n\n\tif (hdev->cur_adv_instance == 0x00)\n\t\tgoto unlock;\n\n\tinst_ptr = kmalloc(1, GFP_KERNEL);\n\tif (!inst_ptr)\n\t\tgoto unlock;\n\n\t*inst_ptr = hdev->cur_adv_instance;\n\thci_cmd_sync_queue(hdev, adv_timeout_expire_sync, inst_ptr, NULL);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nvoid hci_cmd_sync_init(struct hci_dev *hdev)\n{\n\tINIT_WORK(&hdev->cmd_sync_work, hci_cmd_sync_work);\n\tINIT_LIST_HEAD(&hdev->cmd_sync_work_list);\n\tmutex_init(&hdev->cmd_sync_work_lock);\n\tmutex_init(&hdev->unregister_lock);\n\n\tINIT_WORK(&hdev->cmd_sync_cancel_work, hci_cmd_sync_cancel_work);\n\tINIT_WORK(&hdev->reenable_adv_work, reenable_adv);\n\tINIT_DELAYED_WORK(&hdev->le_scan_disable, le_scan_disable);\n\tINIT_DELAYED_WORK(&hdev->le_scan_restart, le_scan_restart);\n\tINIT_DELAYED_WORK(&hdev->adv_instance_expire, adv_timeout_expire);\n}\n\nvoid hci_cmd_sync_clear(struct hci_dev *hdev)\n{\n\tstruct hci_cmd_sync_work_entry *entry, *tmp;\n\n\tcancel_work_sync(&hdev->cmd_sync_work);\n\tcancel_work_sync(&hdev->reenable_adv_work);\n\n\tmutex_lock(&hdev->cmd_sync_work_lock);\n\tlist_for_each_entry_safe(entry, tmp, &hdev->cmd_sync_work_list, list) {\n\t\tif (entry->destroy)\n\t\t\tentry->destroy(hdev, entry->data, -ECANCELED);\n\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&hdev->cmd_sync_work_lock);\n}\n\nvoid __hci_cmd_sync_cancel(struct hci_dev *hdev, int err)\n{\n\tbt_dev_dbg(hdev, \"err 0x%2.2x\", err);\n\n\tif (hdev->req_status == HCI_REQ_PEND) {\n\t\thdev->req_result = err;\n\t\thdev->req_status = HCI_REQ_CANCELED;\n\n\t\tcancel_delayed_work_sync(&hdev->cmd_timer);\n\t\tcancel_delayed_work_sync(&hdev->ncmd_timer);\n\t\tatomic_set(&hdev->cmd_cnt, 1);\n\n\t\twake_up_interruptible(&hdev->req_wait_q);\n\t}\n}\n\nvoid hci_cmd_sync_cancel(struct hci_dev *hdev, int err)\n{\n\tbt_dev_dbg(hdev, \"err 0x%2.2x\", err);\n\n\tif (hdev->req_status == HCI_REQ_PEND) {\n\t\thdev->req_result = err;\n\t\thdev->req_status = HCI_REQ_CANCELED;\n\n\t\tqueue_work(hdev->workqueue, &hdev->cmd_sync_cancel_work);\n\t}\n}\nEXPORT_SYMBOL(hci_cmd_sync_cancel);\n\n \nint hci_cmd_sync_submit(struct hci_dev *hdev, hci_cmd_sync_work_func_t func,\n\t\t\tvoid *data, hci_cmd_sync_work_destroy_t destroy)\n{\n\tstruct hci_cmd_sync_work_entry *entry;\n\tint err = 0;\n\n\tmutex_lock(&hdev->unregister_lock);\n\tif (hci_dev_test_flag(hdev, HCI_UNREGISTER)) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tentry->func = func;\n\tentry->data = data;\n\tentry->destroy = destroy;\n\n\tmutex_lock(&hdev->cmd_sync_work_lock);\n\tlist_add_tail(&entry->list, &hdev->cmd_sync_work_list);\n\tmutex_unlock(&hdev->cmd_sync_work_lock);\n\n\tqueue_work(hdev->req_workqueue, &hdev->cmd_sync_work);\n\nunlock:\n\tmutex_unlock(&hdev->unregister_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(hci_cmd_sync_submit);\n\n \nint hci_cmd_sync_queue(struct hci_dev *hdev, hci_cmd_sync_work_func_t func,\n\t\t       void *data, hci_cmd_sync_work_destroy_t destroy)\n{\n\t \n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n\treturn hci_cmd_sync_submit(hdev, func, data, destroy);\n}\nEXPORT_SYMBOL(hci_cmd_sync_queue);\n\nint hci_update_eir_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_write_eir cp;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tif (!hdev_is_powered(hdev))\n\t\treturn 0;\n\n\tif (!lmp_ext_inq_capable(hdev))\n\t\treturn 0;\n\n\tif (!hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\n\t\treturn 0;\n\n\tif (hci_dev_test_flag(hdev, HCI_SERVICE_CACHE))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\teir_create(hdev, cp.data);\n\n\tif (memcmp(cp.data, hdev->eir, sizeof(cp.data)) == 0)\n\t\treturn 0;\n\n\tmemcpy(hdev->eir, cp.data, sizeof(cp.data));\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\nstatic u8 get_service_classes(struct hci_dev *hdev)\n{\n\tstruct bt_uuid *uuid;\n\tu8 val = 0;\n\n\tlist_for_each_entry(uuid, &hdev->uuids, list)\n\t\tval |= uuid->svc_hint;\n\n\treturn val;\n}\n\nint hci_update_class_sync(struct hci_dev *hdev)\n{\n\tu8 cod[3];\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tif (!hdev_is_powered(hdev))\n\t\treturn 0;\n\n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn 0;\n\n\tif (hci_dev_test_flag(hdev, HCI_SERVICE_CACHE))\n\t\treturn 0;\n\n\tcod[0] = hdev->minor_class;\n\tcod[1] = hdev->major_class;\n\tcod[2] = get_service_classes(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_LIMITED_DISCOVERABLE))\n\t\tcod[1] |= 0x20;\n\n\tif (memcmp(cod, hdev->dev_class, 3) == 0)\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_CLASS_OF_DEV,\n\t\t\t\t     sizeof(cod), cod, HCI_CMD_TIMEOUT);\n}\n\nstatic bool is_advertising_allowed(struct hci_dev *hdev, bool connectable)\n{\n\t \n\tif (hci_conn_num(hdev, LE_LINK) == 0)\n\t\treturn true;\n\n\t \n\tif (hdev->conn_hash.le_num_peripheral > 0) {\n\t\t \n\t\tif (!connectable && !(hdev->le_states[2] & 0x10))\n\t\t\treturn false;\n\n\t\t \n\t\tif (connectable && (!(hdev->le_states[4] & 0x40) ||\n\t\t\t\t    !(hdev->le_states[2] & 0x20)))\n\t\t\treturn false;\n\t}\n\n\t \n\tif (hci_conn_num(hdev, LE_LINK) != hdev->conn_hash.le_num_peripheral) {\n\t\t \n\t\tif (!connectable && !(hdev->le_states[2] & 0x02))\n\t\t\treturn false;\n\n\t\t \n\t\tif (connectable && (!(hdev->le_states[4] & 0x08) ||\n\t\t\t\t    !(hdev->le_states[2] & 0x08)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool adv_use_rpa(struct hci_dev *hdev, uint32_t flags)\n{\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_PRIVACY))\n\t\treturn false;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LIMITED_PRIVACY))\n\t\treturn true;\n\n\t \n\tif ((flags & MGMT_ADV_FLAG_DISCOV) &&\n\t    hci_dev_test_flag(hdev, HCI_BONDABLE))\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nstatic int hci_set_random_addr_sync(struct hci_dev *hdev, bdaddr_t *rpa)\n{\n\t \n\tif (hci_dev_test_flag(hdev, HCI_LE_ADV) ||\n\t    hci_lookup_le_connect(hdev)) {\n\t\tbt_dev_dbg(hdev, \"Deferring random address update\");\n\t\thci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\n\t\treturn 0;\n\t}\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_RANDOM_ADDR,\n\t\t\t\t     6, rpa, HCI_CMD_TIMEOUT);\n}\n\nint hci_update_random_address_sync(struct hci_dev *hdev, bool require_privacy,\n\t\t\t\t   bool rpa, u8 *own_addr_type)\n{\n\tint err;\n\n\t \n\tif (rpa) {\n\t\t \n\t\tif (use_ll_privacy(hdev))\n\t\t\t*own_addr_type = ADDR_LE_DEV_RANDOM_RESOLVED;\n\t\telse\n\t\t\t*own_addr_type = ADDR_LE_DEV_RANDOM;\n\n\t\t \n\t\tif (rpa_valid(hdev))\n\t\t\treturn 0;\n\n\t\terr = smp_generate_rpa(hdev, hdev->irk, &hdev->rpa);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"failed to generate new RPA\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = hci_set_random_addr_sync(hdev, &hdev->rpa);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (require_privacy) {\n\t\tbdaddr_t nrpa;\n\n\t\twhile (true) {\n\t\t\t \n\t\t\tget_random_bytes(&nrpa, 6);\n\t\t\tnrpa.b[5] &= 0x3f;\n\n\t\t\t \n\t\t\tif (bacmp(&hdev->bdaddr, &nrpa))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t*own_addr_type = ADDR_LE_DEV_RANDOM;\n\n\t\treturn hci_set_random_addr_sync(hdev, &nrpa);\n\t}\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||\n\t    !bacmp(&hdev->bdaddr, BDADDR_ANY) ||\n\t    (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\n\t     bacmp(&hdev->static_addr, BDADDR_ANY))) {\n\t\t*own_addr_type = ADDR_LE_DEV_RANDOM;\n\t\tif (bacmp(&hdev->static_addr, &hdev->random_addr))\n\t\t\treturn hci_set_random_addr_sync(hdev,\n\t\t\t\t\t\t\t&hdev->static_addr);\n\t\treturn 0;\n\t}\n\n\t \n\t*own_addr_type = ADDR_LE_DEV_PUBLIC;\n\n\treturn 0;\n}\n\nstatic int hci_disable_ext_adv_instance_sync(struct hci_dev *hdev, u8 instance)\n{\n\tstruct hci_cp_le_set_ext_adv_enable *cp;\n\tstruct hci_cp_ext_adv_set *set;\n\tu8 data[sizeof(*cp) + sizeof(*set) * 1];\n\tu8 size;\n\n\t \n\tif (instance > 0) {\n\t\tstruct adv_info *adv;\n\n\t\tadv = hci_find_adv_instance(hdev, instance);\n\t\tif (!adv)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!adv->enabled)\n\t\t\treturn 0;\n\t}\n\n\tmemset(data, 0, sizeof(data));\n\n\tcp = (void *)data;\n\tset = (void *)cp->data;\n\n\t \n\tcp->num_of_sets = !!instance;\n\tcp->enable = 0x00;\n\n\tset->handle = instance;\n\n\tsize = sizeof(*cp) + sizeof(*set) * cp->num_of_sets;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_EXT_ADV_ENABLE,\n\t\t\t\t     size, data, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_set_adv_set_random_addr_sync(struct hci_dev *hdev, u8 instance,\n\t\t\t\t\t    bdaddr_t *random_addr)\n{\n\tstruct hci_cp_le_set_adv_set_rand_addr cp;\n\tint err;\n\n\tif (!instance) {\n\t\t \n\t\terr = hci_set_random_addr_sync(hdev, random_addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tcp.handle = instance;\n\tbacpy(&cp.bdaddr, random_addr);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_ADV_SET_RAND_ADDR,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_setup_ext_adv_instance_sync(struct hci_dev *hdev, u8 instance)\n{\n\tstruct hci_cp_le_set_ext_adv_params cp;\n\tbool connectable;\n\tu32 flags;\n\tbdaddr_t random_addr;\n\tu8 own_addr_type;\n\tint err;\n\tstruct adv_info *adv;\n\tbool secondary_adv;\n\n\tif (instance > 0) {\n\t\tadv = hci_find_adv_instance(hdev, instance);\n\t\tif (!adv)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tadv = NULL;\n\t}\n\n\t \n\tif (adv && !adv->pending) {\n\t\terr = hci_disable_ext_adv_instance_sync(hdev, instance);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tflags = hci_adv_instance_flags(hdev, instance);\n\n\t \n\tconnectable = (flags & MGMT_ADV_FLAG_CONNECTABLE) ||\n\t\t      mgmt_get_connectable(hdev);\n\n\tif (!is_advertising_allowed(hdev, connectable))\n\t\treturn -EPERM;\n\n\t \n\terr = hci_get_random_address(hdev, !connectable,\n\t\t\t\t     adv_use_rpa(hdev, flags), adv,\n\t\t\t\t     &own_addr_type, &random_addr);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tif (adv) {\n\t\thci_cpu_to_le24(adv->min_interval, cp.min_interval);\n\t\thci_cpu_to_le24(adv->max_interval, cp.max_interval);\n\t\tcp.tx_power = adv->tx_power;\n\t} else {\n\t\thci_cpu_to_le24(hdev->le_adv_min_interval, cp.min_interval);\n\t\thci_cpu_to_le24(hdev->le_adv_max_interval, cp.max_interval);\n\t\tcp.tx_power = HCI_ADV_TX_POWER_NO_PREFERENCE;\n\t}\n\n\tsecondary_adv = (flags & MGMT_ADV_FLAG_SEC_MASK);\n\n\tif (connectable) {\n\t\tif (secondary_adv)\n\t\t\tcp.evt_properties = cpu_to_le16(LE_EXT_ADV_CONN_IND);\n\t\telse\n\t\t\tcp.evt_properties = cpu_to_le16(LE_LEGACY_ADV_IND);\n\t} else if (hci_adv_instance_is_scannable(hdev, instance) ||\n\t\t   (flags & MGMT_ADV_PARAM_SCAN_RSP)) {\n\t\tif (secondary_adv)\n\t\t\tcp.evt_properties = cpu_to_le16(LE_EXT_ADV_SCAN_IND);\n\t\telse\n\t\t\tcp.evt_properties = cpu_to_le16(LE_LEGACY_ADV_SCAN_IND);\n\t} else {\n\t\tif (secondary_adv)\n\t\t\tcp.evt_properties = cpu_to_le16(LE_EXT_ADV_NON_CONN_IND);\n\t\telse\n\t\t\tcp.evt_properties = cpu_to_le16(LE_LEGACY_NONCONN_IND);\n\t}\n\n\t \n\tif (own_addr_type == ADDR_LE_DEV_RANDOM_RESOLVED)\n\t\thci_copy_identity_address(hdev, &cp.peer_addr,\n\t\t\t\t\t  &cp.peer_addr_type);\n\n\tcp.own_addr_type = own_addr_type;\n\tcp.channel_map = hdev->le_adv_channel_map;\n\tcp.handle = instance;\n\n\tif (flags & MGMT_ADV_FLAG_SEC_2M) {\n\t\tcp.primary_phy = HCI_ADV_PHY_1M;\n\t\tcp.secondary_phy = HCI_ADV_PHY_2M;\n\t} else if (flags & MGMT_ADV_FLAG_SEC_CODED) {\n\t\tcp.primary_phy = HCI_ADV_PHY_CODED;\n\t\tcp.secondary_phy = HCI_ADV_PHY_CODED;\n\t} else {\n\t\t \n\t\tcp.primary_phy = HCI_ADV_PHY_1M;\n\t\tcp.secondary_phy = HCI_ADV_PHY_1M;\n\t}\n\n\terr = __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_EXT_ADV_PARAMS,\n\t\t\t\t    sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n\tif (err)\n\t\treturn err;\n\n\tif ((own_addr_type == ADDR_LE_DEV_RANDOM ||\n\t     own_addr_type == ADDR_LE_DEV_RANDOM_RESOLVED) &&\n\t    bacmp(&random_addr, BDADDR_ANY)) {\n\t\t \n\t\tif (adv) {\n\t\t\tif (!bacmp(&random_addr, &adv->random_addr))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!bacmp(&random_addr, &hdev->random_addr))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\treturn hci_set_adv_set_random_addr_sync(hdev, instance,\n\t\t\t\t\t\t\t&random_addr);\n\t}\n\n\treturn 0;\n}\n\nstatic int hci_set_ext_scan_rsp_data_sync(struct hci_dev *hdev, u8 instance)\n{\n\tstruct {\n\t\tstruct hci_cp_le_set_ext_scan_rsp_data cp;\n\t\tu8 data[HCI_MAX_EXT_AD_LENGTH];\n\t} pdu;\n\tu8 len;\n\tstruct adv_info *adv = NULL;\n\tint err;\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\tif (instance) {\n\t\tadv = hci_find_adv_instance(hdev, instance);\n\t\tif (!adv || !adv->scan_rsp_changed)\n\t\t\treturn 0;\n\t}\n\n\tlen = eir_create_scan_rsp(hdev, instance, pdu.data);\n\n\tpdu.cp.handle = instance;\n\tpdu.cp.length = len;\n\tpdu.cp.operation = LE_SET_ADV_DATA_OP_COMPLETE;\n\tpdu.cp.frag_pref = LE_SET_ADV_DATA_NO_FRAG;\n\n\terr = __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_EXT_SCAN_RSP_DATA,\n\t\t\t\t    sizeof(pdu.cp) + len, &pdu.cp,\n\t\t\t\t    HCI_CMD_TIMEOUT);\n\tif (err)\n\t\treturn err;\n\n\tif (adv) {\n\t\tadv->scan_rsp_changed = false;\n\t} else {\n\t\tmemcpy(hdev->scan_rsp_data, pdu.data, len);\n\t\thdev->scan_rsp_data_len = len;\n\t}\n\n\treturn 0;\n}\n\nstatic int __hci_set_scan_rsp_data_sync(struct hci_dev *hdev, u8 instance)\n{\n\tstruct hci_cp_le_set_scan_rsp_data cp;\n\tu8 len;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tlen = eir_create_scan_rsp(hdev, instance, cp.data);\n\n\tif (hdev->scan_rsp_data_len == len &&\n\t    !memcmp(cp.data, hdev->scan_rsp_data, len))\n\t\treturn 0;\n\n\tmemcpy(hdev->scan_rsp_data, cp.data, sizeof(cp.data));\n\thdev->scan_rsp_data_len = len;\n\n\tcp.length = len;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_SCAN_RSP_DATA,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_update_scan_rsp_data_sync(struct hci_dev *hdev, u8 instance)\n{\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn 0;\n\n\tif (ext_adv_capable(hdev))\n\t\treturn hci_set_ext_scan_rsp_data_sync(hdev, instance);\n\n\treturn __hci_set_scan_rsp_data_sync(hdev, instance);\n}\n\nint hci_enable_ext_advertising_sync(struct hci_dev *hdev, u8 instance)\n{\n\tstruct hci_cp_le_set_ext_adv_enable *cp;\n\tstruct hci_cp_ext_adv_set *set;\n\tu8 data[sizeof(*cp) + sizeof(*set) * 1];\n\tstruct adv_info *adv;\n\n\tif (instance > 0) {\n\t\tadv = hci_find_adv_instance(hdev, instance);\n\t\tif (!adv)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (adv->enabled)\n\t\t\treturn 0;\n\t} else {\n\t\tadv = NULL;\n\t}\n\n\tcp = (void *)data;\n\tset = (void *)cp->data;\n\n\tmemset(cp, 0, sizeof(*cp));\n\n\tcp->enable = 0x01;\n\tcp->num_of_sets = 0x01;\n\n\tmemset(set, 0, sizeof(*set));\n\n\tset->handle = instance;\n\n\t \n\tif (adv && adv->timeout) {\n\t\tu16 duration = adv->timeout * MSEC_PER_SEC;\n\n\t\t \n\t\tset->duration = cpu_to_le16(duration / 10);\n\t}\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_EXT_ADV_ENABLE,\n\t\t\t\t     sizeof(*cp) +\n\t\t\t\t     sizeof(*set) * cp->num_of_sets,\n\t\t\t\t     data, HCI_CMD_TIMEOUT);\n}\n\nint hci_start_ext_adv_sync(struct hci_dev *hdev, u8 instance)\n{\n\tint err;\n\n\terr = hci_setup_ext_adv_instance_sync(hdev, instance);\n\tif (err)\n\t\treturn err;\n\n\terr = hci_set_ext_scan_rsp_data_sync(hdev, instance);\n\tif (err)\n\t\treturn err;\n\n\treturn hci_enable_ext_advertising_sync(hdev, instance);\n}\n\nstatic int hci_disable_per_advertising_sync(struct hci_dev *hdev, u8 instance)\n{\n\tstruct hci_cp_le_set_per_adv_enable cp;\n\tstruct adv_info *adv = NULL;\n\n\t \n\tadv = hci_find_adv_instance(hdev, instance);\n\tif (!adv || !adv->periodic || !adv->enabled)\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tcp.enable = 0x00;\n\tcp.handle = instance;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_PER_ADV_ENABLE,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_set_per_adv_params_sync(struct hci_dev *hdev, u8 instance,\n\t\t\t\t       u16 min_interval, u16 max_interval)\n{\n\tstruct hci_cp_le_set_per_adv_params cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tif (!min_interval)\n\t\tmin_interval = DISCOV_LE_PER_ADV_INT_MIN;\n\n\tif (!max_interval)\n\t\tmax_interval = DISCOV_LE_PER_ADV_INT_MAX;\n\n\tcp.handle = instance;\n\tcp.min_interval = cpu_to_le16(min_interval);\n\tcp.max_interval = cpu_to_le16(max_interval);\n\tcp.periodic_properties = 0x0000;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_PER_ADV_PARAMS,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_set_per_adv_data_sync(struct hci_dev *hdev, u8 instance)\n{\n\tstruct {\n\t\tstruct hci_cp_le_set_per_adv_data cp;\n\t\tu8 data[HCI_MAX_PER_AD_LENGTH];\n\t} pdu;\n\tu8 len;\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\tif (instance) {\n\t\tstruct adv_info *adv = hci_find_adv_instance(hdev, instance);\n\n\t\tif (!adv || !adv->periodic)\n\t\t\treturn 0;\n\t}\n\n\tlen = eir_create_per_adv_data(hdev, instance, pdu.data);\n\n\tpdu.cp.length = len;\n\tpdu.cp.handle = instance;\n\tpdu.cp.operation = LE_SET_ADV_DATA_OP_COMPLETE;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_PER_ADV_DATA,\n\t\t\t\t     sizeof(pdu.cp) + len, &pdu,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_enable_per_advertising_sync(struct hci_dev *hdev, u8 instance)\n{\n\tstruct hci_cp_le_set_per_adv_enable cp;\n\tstruct adv_info *adv = NULL;\n\n\t \n\tadv = hci_find_adv_instance(hdev, instance);\n\tif (adv && adv->periodic && adv->enabled)\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tcp.enable = 0x01;\n\tcp.handle = instance;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_PER_ADV_ENABLE,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_adv_bcast_annoucement(struct hci_dev *hdev, struct adv_info *adv)\n{\n\tu8 bid[3];\n\tu8 ad[4 + 3];\n\n\t \n\tif (!adv)\n\t\treturn 0;\n\n\t \n\tif (!eir_get_service_data(adv->per_adv_data, adv->per_adv_data_len,\n\t\t\t\t  0x1851, NULL))\n\t\treturn 0;\n\n\t \n\tif (eir_get_service_data(adv->adv_data, adv->adv_data_len, 0x1852,\n\t\t\t\t NULL))\n\t\treturn 0;\n\n\t \n\tget_random_bytes(bid, sizeof(bid));\n\teir_append_service_data(ad, 0, 0x1852, bid, sizeof(bid));\n\thci_set_adv_instance_data(hdev, adv->instance, sizeof(ad), ad, 0, NULL);\n\n\treturn hci_update_adv_data_sync(hdev, adv->instance);\n}\n\nint hci_start_per_adv_sync(struct hci_dev *hdev, u8 instance, u8 data_len,\n\t\t\t   u8 *data, u32 flags, u16 min_interval,\n\t\t\t   u16 max_interval, u16 sync_interval)\n{\n\tstruct adv_info *adv = NULL;\n\tint err;\n\tbool added = false;\n\n\thci_disable_per_advertising_sync(hdev, instance);\n\n\tif (instance) {\n\t\tadv = hci_find_adv_instance(hdev, instance);\n\t\t \n\t\tif (!adv) {\n\t\t\tadv = hci_add_per_instance(hdev, instance, flags,\n\t\t\t\t\t\t   data_len, data,\n\t\t\t\t\t\t   sync_interval,\n\t\t\t\t\t\t   sync_interval);\n\t\t\tif (IS_ERR(adv))\n\t\t\t\treturn PTR_ERR(adv);\n\t\t\tadv->pending = false;\n\t\t\tadded = true;\n\t\t}\n\t}\n\n\t \n\terr = hci_start_ext_adv_sync(hdev, instance);\n\tif (err < 0)\n\t\tgoto fail;\n\n\terr = hci_adv_bcast_annoucement(hdev, adv);\n\tif (err < 0)\n\t\tgoto fail;\n\n\terr = hci_set_per_adv_params_sync(hdev, instance, min_interval,\n\t\t\t\t\t  max_interval);\n\tif (err < 0)\n\t\tgoto fail;\n\n\terr = hci_set_per_adv_data_sync(hdev, instance);\n\tif (err < 0)\n\t\tgoto fail;\n\n\terr = hci_enable_per_advertising_sync(hdev, instance);\n\tif (err < 0)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tif (added)\n\t\thci_remove_adv_instance(hdev, instance);\n\n\treturn err;\n}\n\nstatic int hci_start_adv_sync(struct hci_dev *hdev, u8 instance)\n{\n\tint err;\n\n\tif (ext_adv_capable(hdev))\n\t\treturn hci_start_ext_adv_sync(hdev, instance);\n\n\terr = hci_update_adv_data_sync(hdev, instance);\n\tif (err)\n\t\treturn err;\n\n\terr = hci_update_scan_rsp_data_sync(hdev, instance);\n\tif (err)\n\t\treturn err;\n\n\treturn hci_enable_advertising_sync(hdev);\n}\n\nint hci_enable_advertising_sync(struct hci_dev *hdev)\n{\n\tstruct adv_info *adv_instance;\n\tstruct hci_cp_le_set_adv_param cp;\n\tu8 own_addr_type, enable = 0x01;\n\tbool connectable;\n\tu16 adv_min_interval, adv_max_interval;\n\tu32 flags;\n\tu8 status;\n\n\tif (ext_adv_capable(hdev))\n\t\treturn hci_enable_ext_advertising_sync(hdev,\n\t\t\t\t\t\t       hdev->cur_adv_instance);\n\n\tflags = hci_adv_instance_flags(hdev, hdev->cur_adv_instance);\n\tadv_instance = hci_find_adv_instance(hdev, hdev->cur_adv_instance);\n\n\t \n\tconnectable = (flags & MGMT_ADV_FLAG_CONNECTABLE) ||\n\t\t      mgmt_get_connectable(hdev);\n\n\tif (!is_advertising_allowed(hdev, connectable))\n\t\treturn -EINVAL;\n\n\tstatus = hci_disable_advertising_sync(hdev);\n\tif (status)\n\t\treturn status;\n\n\t \n\thci_dev_clear_flag(hdev, HCI_LE_ADV);\n\n\t \n\tstatus = hci_update_random_address_sync(hdev, !connectable,\n\t\t\t\t\t\tadv_use_rpa(hdev, flags),\n\t\t\t\t\t\t&own_addr_type);\n\tif (status)\n\t\treturn status;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tif (adv_instance) {\n\t\tadv_min_interval = adv_instance->min_interval;\n\t\tadv_max_interval = adv_instance->max_interval;\n\t} else {\n\t\tadv_min_interval = hdev->le_adv_min_interval;\n\t\tadv_max_interval = hdev->le_adv_max_interval;\n\t}\n\n\tif (connectable) {\n\t\tcp.type = LE_ADV_IND;\n\t} else {\n\t\tif (hci_adv_instance_is_scannable(hdev, hdev->cur_adv_instance))\n\t\t\tcp.type = LE_ADV_SCAN_IND;\n\t\telse\n\t\t\tcp.type = LE_ADV_NONCONN_IND;\n\n\t\tif (!hci_dev_test_flag(hdev, HCI_DISCOVERABLE) ||\n\t\t    hci_dev_test_flag(hdev, HCI_LIMITED_DISCOVERABLE)) {\n\t\t\tadv_min_interval = DISCOV_LE_FAST_ADV_INT_MIN;\n\t\t\tadv_max_interval = DISCOV_LE_FAST_ADV_INT_MAX;\n\t\t}\n\t}\n\n\tcp.min_interval = cpu_to_le16(adv_min_interval);\n\tcp.max_interval = cpu_to_le16(adv_max_interval);\n\tcp.own_address_type = own_addr_type;\n\tcp.channel_map = hdev->le_adv_channel_map;\n\n\tstatus = __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_ADV_PARAM,\n\t\t\t\t       sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n\tif (status)\n\t\treturn status;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_ADV_ENABLE,\n\t\t\t\t     sizeof(enable), &enable, HCI_CMD_TIMEOUT);\n}\n\nstatic int enable_advertising_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_enable_advertising_sync(hdev);\n}\n\nint hci_enable_advertising(struct hci_dev *hdev)\n{\n\tif (!hci_dev_test_flag(hdev, HCI_ADVERTISING) &&\n\t    list_empty(&hdev->adv_instances))\n\t\treturn 0;\n\n\treturn hci_cmd_sync_queue(hdev, enable_advertising_sync, NULL, NULL);\n}\n\nint hci_remove_ext_adv_instance_sync(struct hci_dev *hdev, u8 instance,\n\t\t\t\t     struct sock *sk)\n{\n\tint err;\n\n\tif (!ext_adv_capable(hdev))\n\t\treturn 0;\n\n\terr = hci_disable_ext_adv_instance_sync(hdev, instance);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (instance > 0 && !hci_find_adv_instance(hdev, instance))\n\t\treturn -EINVAL;\n\n\treturn __hci_cmd_sync_status_sk(hdev, HCI_OP_LE_REMOVE_ADV_SET,\n\t\t\t\t\tsizeof(instance), &instance, 0,\n\t\t\t\t\tHCI_CMD_TIMEOUT, sk);\n}\n\nstatic int remove_ext_adv_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct adv_info *adv = data;\n\tu8 instance = 0;\n\n\tif (adv)\n\t\tinstance = adv->instance;\n\n\treturn hci_remove_ext_adv_instance_sync(hdev, instance, NULL);\n}\n\nint hci_remove_ext_adv_instance(struct hci_dev *hdev, u8 instance)\n{\n\tstruct adv_info *adv = NULL;\n\n\tif (instance) {\n\t\tadv = hci_find_adv_instance(hdev, instance);\n\t\tif (!adv)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn hci_cmd_sync_queue(hdev, remove_ext_adv_sync, adv, NULL);\n}\n\nint hci_le_terminate_big_sync(struct hci_dev *hdev, u8 handle, u8 reason)\n{\n\tstruct hci_cp_le_term_big cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.handle = handle;\n\tcp.reason = reason;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_TERM_BIG,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_set_ext_adv_data_sync(struct hci_dev *hdev, u8 instance)\n{\n\tstruct {\n\t\tstruct hci_cp_le_set_ext_adv_data cp;\n\t\tu8 data[HCI_MAX_EXT_AD_LENGTH];\n\t} pdu;\n\tu8 len;\n\tstruct adv_info *adv = NULL;\n\tint err;\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\tif (instance) {\n\t\tadv = hci_find_adv_instance(hdev, instance);\n\t\tif (!adv || !adv->adv_data_changed)\n\t\t\treturn 0;\n\t}\n\n\tlen = eir_create_adv_data(hdev, instance, pdu.data);\n\n\tpdu.cp.length = len;\n\tpdu.cp.handle = instance;\n\tpdu.cp.operation = LE_SET_ADV_DATA_OP_COMPLETE;\n\tpdu.cp.frag_pref = LE_SET_ADV_DATA_NO_FRAG;\n\n\terr = __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_EXT_ADV_DATA,\n\t\t\t\t    sizeof(pdu.cp) + len, &pdu.cp,\n\t\t\t\t    HCI_CMD_TIMEOUT);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (adv) {\n\t\tadv->adv_data_changed = false;\n\t} else {\n\t\tmemcpy(hdev->adv_data, pdu.data, len);\n\t\thdev->adv_data_len = len;\n\t}\n\n\treturn 0;\n}\n\nstatic int hci_set_adv_data_sync(struct hci_dev *hdev, u8 instance)\n{\n\tstruct hci_cp_le_set_adv_data cp;\n\tu8 len;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tlen = eir_create_adv_data(hdev, instance, cp.data);\n\n\t \n\tif (hdev->adv_data_len == len &&\n\t    memcmp(cp.data, hdev->adv_data, len) == 0)\n\t\treturn 0;\n\n\tmemcpy(hdev->adv_data, cp.data, sizeof(cp.data));\n\thdev->adv_data_len = len;\n\n\tcp.length = len;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_ADV_DATA,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_update_adv_data_sync(struct hci_dev *hdev, u8 instance)\n{\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn 0;\n\n\tif (ext_adv_capable(hdev))\n\t\treturn hci_set_ext_adv_data_sync(hdev, instance);\n\n\treturn hci_set_adv_data_sync(hdev, instance);\n}\n\nint hci_schedule_adv_instance_sync(struct hci_dev *hdev, u8 instance,\n\t\t\t\t   bool force)\n{\n\tstruct adv_info *adv = NULL;\n\tu16 timeout;\n\n\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING) && !ext_adv_capable(hdev))\n\t\treturn -EPERM;\n\n\tif (hdev->adv_instance_timeout)\n\t\treturn -EBUSY;\n\n\tadv = hci_find_adv_instance(hdev, instance);\n\tif (!adv)\n\t\treturn -ENOENT;\n\n\t \n\tif (adv->timeout == 0 || adv->duration <= adv->remaining_time)\n\t\ttimeout = adv->duration;\n\telse\n\t\ttimeout = adv->remaining_time;\n\n\t \n\tif (adv->timeout)\n\t\tadv->remaining_time = adv->remaining_time - timeout;\n\n\t \n\tif (!ext_adv_capable(hdev)) {\n\t\thdev->adv_instance_timeout = timeout;\n\t\tqueue_delayed_work(hdev->req_workqueue,\n\t\t\t\t   &hdev->adv_instance_expire,\n\t\t\t\t   msecs_to_jiffies(timeout * 1000));\n\t}\n\n\t \n\tif (!force && hdev->cur_adv_instance == instance &&\n\t    hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\treturn 0;\n\n\thdev->cur_adv_instance = instance;\n\n\treturn hci_start_adv_sync(hdev, instance);\n}\n\nstatic int hci_clear_adv_sets_sync(struct hci_dev *hdev, struct sock *sk)\n{\n\tint err;\n\n\tif (!ext_adv_capable(hdev))\n\t\treturn 0;\n\n\t \n\terr = hci_disable_ext_adv_instance_sync(hdev, 0x00);\n\tif (err)\n\t\treturn err;\n\n\treturn __hci_cmd_sync_status_sk(hdev, HCI_OP_LE_CLEAR_ADV_SETS,\n\t\t\t\t\t0, NULL, 0, HCI_CMD_TIMEOUT, sk);\n}\n\nstatic int hci_clear_adv_sync(struct hci_dev *hdev, struct sock *sk, bool force)\n{\n\tstruct adv_info *adv, *n;\n\tint err = 0;\n\n\tif (ext_adv_capable(hdev))\n\t\t \n\t\terr = hci_clear_adv_sets_sync(hdev, sk);\n\tif (ext_adv_capable(hdev))\n\t\treturn err;\n\n\t \n\thci_dev_lock(hdev);\n\n\t \n\tlist_for_each_entry_safe(adv, n, &hdev->adv_instances, list) {\n\t\tu8 instance = adv->instance;\n\t\tint err;\n\n\t\tif (!(force || adv->timeout))\n\t\t\tcontinue;\n\n\t\terr = hci_remove_adv_instance(hdev, instance);\n\t\tif (!err)\n\t\t\tmgmt_advertising_removed(sk, hdev, instance);\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int hci_remove_adv_sync(struct hci_dev *hdev, u8 instance,\n\t\t\t       struct sock *sk)\n{\n\tint err = 0;\n\n\t \n\tif (ext_adv_capable(hdev))\n\t\terr = hci_remove_ext_adv_instance_sync(hdev, instance, sk);\n\tif (ext_adv_capable(hdev))\n\t\treturn err;\n\n\t \n\thci_dev_lock(hdev);\n\n\terr = hci_remove_adv_instance(hdev, instance);\n\tif (!err)\n\t\tmgmt_advertising_removed(sk, hdev, instance);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\n \nint hci_remove_advertising_sync(struct hci_dev *hdev, struct sock *sk,\n\t\t\t\tu8 instance, bool force)\n{\n\tstruct adv_info *next = NULL;\n\tint err;\n\n\t \n\tif (!instance || hdev->cur_adv_instance == instance)\n\t\tcancel_adv_timeout(hdev);\n\n\t \n\tif (hdev->cur_adv_instance == instance)\n\t\tnext = hci_get_next_instance(hdev, instance);\n\n\tif (!instance) {\n\t\terr = hci_clear_adv_sync(hdev, sk, force);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tstruct adv_info *adv = hci_find_adv_instance(hdev, instance);\n\n\t\tif (force || (adv && adv->timeout && !adv->remaining_time)) {\n\t\t\t \n\t\t\tif (next && next->instance == instance)\n\t\t\t\tnext = NULL;\n\n\t\t\terr = hci_remove_adv_sync(hdev, instance, sk);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!hdev_is_powered(hdev) || hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\treturn 0;\n\n\tif (next && !ext_adv_capable(hdev))\n\t\thci_schedule_adv_instance_sync(hdev, next->instance, false);\n\n\treturn 0;\n}\n\nint hci_read_rssi_sync(struct hci_dev *hdev, __le16 handle)\n{\n\tstruct hci_cp_read_rssi cp;\n\n\tcp.handle = handle;\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_RSSI,\n\t\t\t\t\tsizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_read_clock_sync(struct hci_dev *hdev, struct hci_cp_read_clock *cp)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_CLOCK,\n\t\t\t\t\tsizeof(*cp), cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_read_tx_power_sync(struct hci_dev *hdev, __le16 handle, u8 type)\n{\n\tstruct hci_cp_read_tx_power cp;\n\n\tcp.handle = handle;\n\tcp.type = type;\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_TX_POWER,\n\t\t\t\t\tsizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_disable_advertising_sync(struct hci_dev *hdev)\n{\n\tu8 enable = 0x00;\n\tint err = 0;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\treturn 0;\n\n\tif (ext_adv_capable(hdev))\n\t\terr = hci_disable_ext_adv_instance_sync(hdev, 0x00);\n\tif (ext_adv_capable(hdev))\n\t\treturn err;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_ADV_ENABLE,\n\t\t\t\t     sizeof(enable), &enable, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_le_set_ext_scan_enable_sync(struct hci_dev *hdev, u8 val,\n\t\t\t\t\t   u8 filter_dup)\n{\n\tstruct hci_cp_le_set_ext_scan_enable cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.enable = val;\n\n\tif (hci_dev_test_flag(hdev, HCI_MESH))\n\t\tcp.filter_dup = LE_SCAN_FILTER_DUP_DISABLE;\n\telse\n\t\tcp.filter_dup = filter_dup;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_EXT_SCAN_ENABLE,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_le_set_scan_enable_sync(struct hci_dev *hdev, u8 val,\n\t\t\t\t       u8 filter_dup)\n{\n\tstruct hci_cp_le_set_scan_enable cp;\n\n\tif (use_ext_scan(hdev))\n\t\treturn hci_le_set_ext_scan_enable_sync(hdev, val, filter_dup);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.enable = val;\n\n\tif (val && hci_dev_test_flag(hdev, HCI_MESH))\n\t\tcp.filter_dup = LE_SCAN_FILTER_DUP_DISABLE;\n\telse\n\t\tcp.filter_dup = filter_dup;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_SCAN_ENABLE,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_le_set_addr_resolution_enable_sync(struct hci_dev *hdev, u8 val)\n{\n\tif (!use_ll_privacy(hdev))\n\t\treturn 0;\n\n\t \n\tif (val == hci_dev_test_flag(hdev, HCI_LL_RPA_RESOLUTION))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_ADDR_RESOLV_ENABLE,\n\t\t\t\t     sizeof(val), &val, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_scan_disable_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_SCAN))\n\t\treturn 0;\n\n\tif (hdev->scanning_paused) {\n\t\tbt_dev_dbg(hdev, \"Scanning is paused for suspend\");\n\t\treturn 0;\n\t}\n\n\terr = hci_le_set_scan_enable_sync(hdev, LE_SCAN_DISABLE, 0x00);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Unable to disable scanning: %d\", err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic bool scan_use_rpa(struct hci_dev *hdev)\n{\n\treturn hci_dev_test_flag(hdev, HCI_PRIVACY);\n}\n\nstatic void hci_start_interleave_scan(struct hci_dev *hdev)\n{\n\thdev->interleave_scan_state = INTERLEAVE_SCAN_NO_FILTER;\n\tqueue_delayed_work(hdev->req_workqueue,\n\t\t\t   &hdev->interleave_scan, 0);\n}\n\nstatic bool is_interleave_scanning(struct hci_dev *hdev)\n{\n\treturn hdev->interleave_scan_state != INTERLEAVE_SCAN_NONE;\n}\n\nstatic void cancel_interleave_scan(struct hci_dev *hdev)\n{\n\tbt_dev_dbg(hdev, \"cancelling interleave scan\");\n\n\tcancel_delayed_work_sync(&hdev->interleave_scan);\n\n\thdev->interleave_scan_state = INTERLEAVE_SCAN_NONE;\n}\n\n \nstatic bool hci_update_interleaved_scan_sync(struct hci_dev *hdev)\n{\n\t \n\tbool use_interleaving = hci_is_adv_monitoring(hdev) &&\n\t\t\t\t!(list_empty(&hdev->pend_le_conns) &&\n\t\t\t\t  list_empty(&hdev->pend_le_reports)) &&\n\t\t\t\thci_get_adv_monitor_offload_ext(hdev) ==\n\t\t\t\t    HCI_ADV_MONITOR_EXT_NONE;\n\tbool is_interleaving = is_interleave_scanning(hdev);\n\n\tif (use_interleaving && !is_interleaving) {\n\t\thci_start_interleave_scan(hdev);\n\t\tbt_dev_dbg(hdev, \"starting interleave scan\");\n\t\treturn true;\n\t}\n\n\tif (!use_interleaving && is_interleaving)\n\t\tcancel_interleave_scan(hdev);\n\n\treturn false;\n}\n\n \nstatic int hci_le_del_resolve_list_sync(struct hci_dev *hdev,\n\t\t\t\t\tbdaddr_t *bdaddr, u8 bdaddr_type)\n{\n\tstruct hci_cp_le_del_from_resolv_list cp;\n\tstruct bdaddr_list_with_irk *entry;\n\n\tif (!use_ll_privacy(hdev))\n\t\treturn 0;\n\n\t \n\tentry = hci_bdaddr_list_lookup_with_irk(&hdev->le_resolv_list, bdaddr,\n\t\t\t\t\t\tbdaddr_type);\n\tif (!entry)\n\t\treturn 0;\n\n\tcp.bdaddr_type = bdaddr_type;\n\tbacpy(&cp.bdaddr, bdaddr);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_DEL_FROM_RESOLV_LIST,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_le_del_accept_list_sync(struct hci_dev *hdev,\n\t\t\t\t       bdaddr_t *bdaddr, u8 bdaddr_type)\n{\n\tstruct hci_cp_le_del_from_accept_list cp;\n\tint err;\n\n\t \n\tif (!hci_bdaddr_list_lookup(&hdev->le_accept_list, bdaddr, bdaddr_type))\n\t\treturn 0;\n\n\tcp.bdaddr_type = bdaddr_type;\n\tbacpy(&cp.bdaddr, bdaddr);\n\n\t \n\thci_le_del_resolve_list_sync(hdev, &cp.bdaddr, cp.bdaddr_type);\n\n\terr = __hci_cmd_sync_status(hdev, HCI_OP_LE_DEL_FROM_ACCEPT_LIST,\n\t\t\t\t    sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Unable to remove from allow list: %d\", err);\n\t\treturn err;\n\t}\n\n\tbt_dev_dbg(hdev, \"Remove %pMR (0x%x) from allow list\", &cp.bdaddr,\n\t\t   cp.bdaddr_type);\n\n\treturn 0;\n}\n\nstruct conn_params {\n\tbdaddr_t addr;\n\tu8 addr_type;\n\thci_conn_flags_t flags;\n\tu8 privacy_mode;\n};\n\n \nstatic int hci_le_add_resolve_list_sync(struct hci_dev *hdev,\n\t\t\t\t\tstruct conn_params *params)\n{\n\tstruct hci_cp_le_add_to_resolv_list cp;\n\tstruct smp_irk *irk;\n\tstruct bdaddr_list_with_irk *entry;\n\tstruct hci_conn_params *p;\n\n\tif (!use_ll_privacy(hdev))\n\t\treturn 0;\n\n\t \n\tif (!params) {\n\t\tif (!hci_dev_test_flag(hdev, HCI_PRIVACY))\n\t\t\treturn 0;\n\n\t\thci_copy_identity_address(hdev, &cp.bdaddr, &cp.bdaddr_type);\n\t\tmemcpy(cp.peer_irk, hdev->irk, 16);\n\t\tgoto done;\n\t}\n\n\tirk = hci_find_irk_by_addr(hdev, &params->addr, params->addr_type);\n\tif (!irk)\n\t\treturn 0;\n\n\t \n\tentry = hci_bdaddr_list_lookup_with_irk(&hdev->le_resolv_list,\n\t\t\t\t\t\t&params->addr,\n\t\t\t\t\t\tparams->addr_type);\n\tif (entry)\n\t\treturn 0;\n\n\tcp.bdaddr_type = params->addr_type;\n\tbacpy(&cp.bdaddr, &params->addr);\n\tmemcpy(cp.peer_irk, irk->val, 16);\n\n\t \n\tparams->privacy_mode = HCI_NETWORK_PRIVACY;\n\n\trcu_read_lock();\n\tp = hci_pend_le_action_lookup(&hdev->pend_le_conns,\n\t\t\t\t      &params->addr, params->addr_type);\n\tif (!p)\n\t\tp = hci_pend_le_action_lookup(&hdev->pend_le_reports,\n\t\t\t\t\t      &params->addr, params->addr_type);\n\tif (p)\n\t\tWRITE_ONCE(p->privacy_mode, HCI_NETWORK_PRIVACY);\n\trcu_read_unlock();\n\ndone:\n\tif (hci_dev_test_flag(hdev, HCI_PRIVACY))\n\t\tmemcpy(cp.local_irk, hdev->irk, 16);\n\telse\n\t\tmemset(cp.local_irk, 0, 16);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_ADD_TO_RESOLV_LIST,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_set_privacy_mode_sync(struct hci_dev *hdev,\n\t\t\t\t\tstruct conn_params *params)\n{\n\tstruct hci_cp_le_set_privacy_mode cp;\n\tstruct smp_irk *irk;\n\n\t \n\tif (params->privacy_mode == HCI_DEVICE_PRIVACY)\n\t\treturn 0;\n\n\t \n\tif (!(params->flags & HCI_CONN_FLAG_DEVICE_PRIVACY))\n\t\treturn 0;\n\n\tirk = hci_find_irk_by_addr(hdev, &params->addr, params->addr_type);\n\tif (!irk)\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.bdaddr_type = irk->addr_type;\n\tbacpy(&cp.bdaddr, &irk->bdaddr);\n\tcp.mode = HCI_DEVICE_PRIVACY;\n\n\t \n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_PRIVACY_MODE,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_add_accept_list_sync(struct hci_dev *hdev,\n\t\t\t\t       struct conn_params *params,\n\t\t\t\t       u8 *num_entries)\n{\n\tstruct hci_cp_le_add_to_accept_list cp;\n\tint err;\n\n\t \n\tif (hdev->suspended &&\n\t    !(params->flags & HCI_CONN_FLAG_REMOTE_WAKEUP))\n\t\treturn 0;\n\n\t \n\tif (*num_entries >= hdev->le_accept_list_size)\n\t\treturn -ENOSPC;\n\n\t \n\tif (!use_ll_privacy(hdev) &&\n\t    hci_find_irk_by_addr(hdev, &params->addr, params->addr_type))\n\t\treturn -EINVAL;\n\n\t \n\terr = hci_le_add_resolve_list_sync(hdev, params);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Unable to add to resolve list: %d\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = hci_le_set_privacy_mode_sync(hdev, params);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Unable to set privacy mode: %d\", err);\n\t\treturn err;\n\t}\n\n\t \n\tif (hci_bdaddr_list_lookup(&hdev->le_accept_list, &params->addr,\n\t\t\t\t   params->addr_type))\n\t\treturn 0;\n\n\t*num_entries += 1;\n\tcp.bdaddr_type = params->addr_type;\n\tbacpy(&cp.bdaddr, &params->addr);\n\n\terr = __hci_cmd_sync_status(hdev, HCI_OP_LE_ADD_TO_ACCEPT_LIST,\n\t\t\t\t    sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Unable to add to allow list: %d\", err);\n\t\t \n\t\thci_le_del_resolve_list_sync(hdev, &cp.bdaddr, cp.bdaddr_type);\n\t\treturn err;\n\t}\n\n\tbt_dev_dbg(hdev, \"Add %pMR (0x%x) to allow list\", &cp.bdaddr,\n\t\t   cp.bdaddr_type);\n\n\treturn 0;\n}\n\n \nstatic int hci_pause_advertising_sync(struct hci_dev *hdev)\n{\n\tint err;\n\tint old_state;\n\n\t \n\tif (hdev->advertising_paused)\n\t\treturn 0;\n\n\tbt_dev_dbg(hdev, \"Pausing directed advertising\");\n\n\t \n\told_state = hci_dev_test_flag(hdev, HCI_ADVERTISING);\n\tif (old_state) {\n\t\t \n\t\thci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\t\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\t\thdev->discov_timeout = 0;\n\t}\n\n\tbt_dev_dbg(hdev, \"Pausing advertising instances\");\n\n\t \n\terr = hci_disable_advertising_sync(hdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!ext_adv_capable(hdev))\n\t\tcancel_adv_timeout(hdev);\n\n\thdev->advertising_paused = true;\n\thdev->advertising_old_state = old_state;\n\n\treturn 0;\n}\n\n \nstatic int hci_resume_advertising_sync(struct hci_dev *hdev)\n{\n\tstruct adv_info *adv, *tmp;\n\tint err;\n\n\t \n\tif (!hdev->advertising_paused)\n\t\treturn 0;\n\n\t \n\thdev->advertising_paused = false;\n\tif (hdev->advertising_old_state) {\n\t\thci_dev_set_flag(hdev, HCI_ADVERTISING);\n\t\thdev->advertising_old_state = 0;\n\t}\n\n\tbt_dev_dbg(hdev, \"Resuming advertising instances\");\n\n\tif (ext_adv_capable(hdev)) {\n\t\t \n\t\tlist_for_each_entry_safe(adv, tmp, &hdev->adv_instances, list) {\n\t\t\terr = hci_enable_ext_advertising_sync(hdev,\n\t\t\t\t\t\t\t      adv->instance);\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\thci_remove_ext_adv_instance_sync(hdev, adv->instance,\n\t\t\t\t\t\t\t NULL);\n\t\t}\n\t} else {\n\t\t \n\t\terr = hci_schedule_adv_instance_sync(hdev,\n\t\t\t\t\t\t     hdev->cur_adv_instance,\n\t\t\t\t\t\t     true);\n\t}\n\n\thdev->advertising_paused = false;\n\n\treturn err;\n}\n\nstatic int hci_pause_addr_resolution(struct hci_dev *hdev)\n{\n\tint err;\n\n\tif (!use_ll_privacy(hdev))\n\t\treturn 0;\n\n\tif (!hci_dev_test_flag(hdev, HCI_LL_RPA_RESOLUTION))\n\t\treturn 0;\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_LE_SCAN) ||\n\t    hci_lookup_le_connect(hdev)) {\n\t\tbt_dev_err(hdev, \"Command not allowed when scan/LE connect\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\terr = hci_pause_advertising_sync(hdev);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Pause advertising failed: %d\", err);\n\t\treturn err;\n\t}\n\n\terr = hci_le_set_addr_resolution_enable_sync(hdev, 0x00);\n\tif (err)\n\t\tbt_dev_err(hdev, \"Unable to disable Address Resolution: %d\",\n\t\t\t   err);\n\n\t \n\tif (!err && scan_use_rpa(hdev))\n\t\treturn 0;\n\n\thci_resume_advertising_sync(hdev);\n\treturn err;\n}\n\nstruct sk_buff *hci_read_local_oob_data_sync(struct hci_dev *hdev,\n\t\t\t\t\t     bool extended, struct sock *sk)\n{\n\tu16 opcode = extended ? HCI_OP_READ_LOCAL_OOB_EXT_DATA :\n\t\t\t\t\tHCI_OP_READ_LOCAL_OOB_DATA;\n\n\treturn __hci_cmd_sync_sk(hdev, opcode, 0, NULL, 0, HCI_CMD_TIMEOUT, sk);\n}\n\nstatic struct conn_params *conn_params_copy(struct list_head *list, size_t *n)\n{\n\tstruct hci_conn_params *params;\n\tstruct conn_params *p;\n\tsize_t i;\n\n\trcu_read_lock();\n\n\ti = 0;\n\tlist_for_each_entry_rcu(params, list, action)\n\t\t++i;\n\t*n = i;\n\n\trcu_read_unlock();\n\n\tp = kvcalloc(*n, sizeof(struct conn_params), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\ti = 0;\n\tlist_for_each_entry_rcu(params, list, action) {\n\t\t \n\t\tif (i >= *n)\n\t\t\tbreak;\n\n\t\t \n\t\tbacpy(&p[i].addr, &params->addr);\n\t\tp[i].addr_type = params->addr_type;\n\t\tp[i].flags = READ_ONCE(params->flags);\n\t\tp[i].privacy_mode = READ_ONCE(params->privacy_mode);\n\t\t++i;\n\t}\n\n\trcu_read_unlock();\n\n\t*n = i;\n\treturn p;\n}\n\n \nstatic u8 hci_update_accept_list_sync(struct hci_dev *hdev)\n{\n\tstruct conn_params *params;\n\tstruct bdaddr_list *b, *t;\n\tu8 num_entries = 0;\n\tbool pend_conn, pend_report;\n\tu8 filter_policy;\n\tsize_t i, n;\n\tint err;\n\n\t \n\tif (use_ll_privacy(hdev)) {\n\t\terr = hci_pause_advertising_sync(hdev);\n\t\tif (err) {\n\t\t\tbt_dev_err(hdev, \"pause advertising failed: %d\", err);\n\t\t\treturn 0x00;\n\t\t}\n\t}\n\n\t \n\terr = hci_le_set_addr_resolution_enable_sync(hdev, 0x00);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Unable to disable LL privacy: %d\", err);\n\t\tgoto done;\n\t}\n\n\t \n\tlist_for_each_entry_safe(b, t, &hdev->le_accept_list, list) {\n\t\tif (hci_conn_hash_lookup_le(hdev, &b->bdaddr, b->bdaddr_type))\n\t\t\tcontinue;\n\n\t\t \n\t\tpend_conn = hci_pend_le_action_lookup(&hdev->pend_le_conns,\n\t\t\t\t\t\t      &b->bdaddr,\n\t\t\t\t\t\t      b->bdaddr_type);\n\t\tpend_report = hci_pend_le_action_lookup(&hdev->pend_le_reports,\n\t\t\t\t\t\t\t&b->bdaddr,\n\t\t\t\t\t\t\tb->bdaddr_type);\n\n\t\t \n\t\tif (!pend_conn && !pend_report) {\n\t\t\thci_le_del_accept_list_sync(hdev, &b->bdaddr,\n\t\t\t\t\t\t    b->bdaddr_type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_entries++;\n\t}\n\n\t \n\n\tparams = conn_params_copy(&hdev->pend_le_conns, &n);\n\tif (!params) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < n; ++i) {\n\t\terr = hci_le_add_accept_list_sync(hdev, &params[i],\n\t\t\t\t\t\t  &num_entries);\n\t\tif (err) {\n\t\t\tkvfree(params);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tkvfree(params);\n\n\t \n\n\tparams = conn_params_copy(&hdev->pend_le_reports, &n);\n\tif (!params) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < n; ++i) {\n\t\terr = hci_le_add_accept_list_sync(hdev, &params[i],\n\t\t\t\t\t\t  &num_entries);\n\t\tif (err) {\n\t\t\tkvfree(params);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tkvfree(params);\n\n\t \n\tif (!idr_is_empty(&hdev->adv_monitors_idr) && !hdev->suspended &&\n\t    hci_get_adv_monitor_offload_ext(hdev) == HCI_ADV_MONITOR_EXT_NONE &&\n\t    hdev->interleave_scan_state != INTERLEAVE_SCAN_ALLOWLIST)\n\t\terr = -EINVAL;\n\ndone:\n\tfilter_policy = err ? 0x00 : 0x01;\n\n\t \n\terr = hci_le_set_addr_resolution_enable_sync(hdev, 0x01);\n\tif (err)\n\t\tbt_dev_err(hdev, \"Unable to enable LL privacy: %d\", err);\n\n\t \n\tif (use_ll_privacy(hdev))\n\t\thci_resume_advertising_sync(hdev);\n\n\t \n\treturn filter_policy;\n}\n\nstatic int hci_le_set_ext_scan_param_sync(struct hci_dev *hdev, u8 type,\n\t\t\t\t\t  u16 interval, u16 window,\n\t\t\t\t\t  u8 own_addr_type, u8 filter_policy)\n{\n\tstruct hci_cp_le_set_ext_scan_params *cp;\n\tstruct hci_cp_le_scan_phy_params *phy;\n\tu8 data[sizeof(*cp) + sizeof(*phy) * 2];\n\tu8 num_phy = 0;\n\n\tcp = (void *)data;\n\tphy = (void *)cp->data;\n\n\tmemset(data, 0, sizeof(data));\n\n\tcp->own_addr_type = own_addr_type;\n\tcp->filter_policy = filter_policy;\n\n\tif (scan_1m(hdev) || scan_2m(hdev)) {\n\t\tcp->scanning_phys |= LE_SCAN_PHY_1M;\n\n\t\tphy->type = type;\n\t\tphy->interval = cpu_to_le16(interval);\n\t\tphy->window = cpu_to_le16(window);\n\n\t\tnum_phy++;\n\t\tphy++;\n\t}\n\n\tif (scan_coded(hdev)) {\n\t\tcp->scanning_phys |= LE_SCAN_PHY_CODED;\n\n\t\tphy->type = type;\n\t\tphy->interval = cpu_to_le16(interval);\n\t\tphy->window = cpu_to_le16(window);\n\n\t\tnum_phy++;\n\t\tphy++;\n\t}\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_EXT_SCAN_PARAMS,\n\t\t\t\t     sizeof(*cp) + sizeof(*phy) * num_phy,\n\t\t\t\t     data, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_le_set_scan_param_sync(struct hci_dev *hdev, u8 type,\n\t\t\t\t      u16 interval, u16 window,\n\t\t\t\t      u8 own_addr_type, u8 filter_policy)\n{\n\tstruct hci_cp_le_set_scan_param cp;\n\n\tif (use_ext_scan(hdev))\n\t\treturn hci_le_set_ext_scan_param_sync(hdev, type, interval,\n\t\t\t\t\t\t      window, own_addr_type,\n\t\t\t\t\t\t      filter_policy);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.type = type;\n\tcp.interval = cpu_to_le16(interval);\n\tcp.window = cpu_to_le16(window);\n\tcp.own_address_type = own_addr_type;\n\tcp.filter_policy = filter_policy;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_SCAN_PARAM,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_start_scan_sync(struct hci_dev *hdev, u8 type, u16 interval,\n\t\t\t       u16 window, u8 own_addr_type, u8 filter_policy,\n\t\t\t       u8 filter_dup)\n{\n\tint err;\n\n\tif (hdev->scanning_paused) {\n\t\tbt_dev_dbg(hdev, \"Scanning is paused for suspend\");\n\t\treturn 0;\n\t}\n\n\terr = hci_le_set_scan_param_sync(hdev, type, interval, window,\n\t\t\t\t\t own_addr_type, filter_policy);\n\tif (err)\n\t\treturn err;\n\n\treturn hci_le_set_scan_enable_sync(hdev, LE_SCAN_ENABLE, filter_dup);\n}\n\nstatic int hci_passive_scan_sync(struct hci_dev *hdev)\n{\n\tu8 own_addr_type;\n\tu8 filter_policy;\n\tu16 window, interval;\n\tu8 filter_dups = LE_SCAN_FILTER_DUP_ENABLE;\n\tint err;\n\n\tif (hdev->scanning_paused) {\n\t\tbt_dev_dbg(hdev, \"Scanning is paused for suspend\");\n\t\treturn 0;\n\t}\n\n\terr = hci_scan_disable_sync(hdev);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"disable scanning failed: %d\", err);\n\t\treturn err;\n\t}\n\n\t \n\tif (hci_update_random_address_sync(hdev, false, scan_use_rpa(hdev),\n\t\t\t\t\t   &own_addr_type))\n\t\treturn 0;\n\n\tif (hdev->enable_advmon_interleave_scan &&\n\t    hci_update_interleaved_scan_sync(hdev))\n\t\treturn 0;\n\n\tbt_dev_dbg(hdev, \"interleave state %d\", hdev->interleave_scan_state);\n\n\t \n\tfilter_policy = hci_update_accept_list_sync(hdev);\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_PRIVACY) &&\n\t    (hdev->le_features[0] & HCI_LE_EXT_SCAN_POLICY))\n\t\tfilter_policy |= 0x02;\n\n\tif (hdev->suspended) {\n\t\twindow = hdev->le_scan_window_suspend;\n\t\tinterval = hdev->le_scan_int_suspend;\n\t} else if (hci_is_le_conn_scanning(hdev)) {\n\t\twindow = hdev->le_scan_window_connect;\n\t\tinterval = hdev->le_scan_int_connect;\n\t} else if (hci_is_adv_monitoring(hdev)) {\n\t\twindow = hdev->le_scan_window_adv_monitor;\n\t\tinterval = hdev->le_scan_int_adv_monitor;\n\t} else {\n\t\twindow = hdev->le_scan_window;\n\t\tinterval = hdev->le_scan_interval;\n\t}\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_MESH)) {\n\t\tfilter_policy = 0;\n\t\tfilter_dups = LE_SCAN_FILTER_DUP_DISABLE;\n\t}\n\n\tbt_dev_dbg(hdev, \"LE passive scan with acceptlist = %d\", filter_policy);\n\n\treturn hci_start_scan_sync(hdev, LE_SCAN_PASSIVE, interval, window,\n\t\t\t\t   own_addr_type, filter_policy, filter_dups);\n}\n\n \nint hci_update_passive_scan_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\tif (!test_bit(HCI_UP, &hdev->flags) ||\n\t    test_bit(HCI_INIT, &hdev->flags) ||\n\t    hci_dev_test_flag(hdev, HCI_SETUP) ||\n\t    hci_dev_test_flag(hdev, HCI_CONFIG) ||\n\t    hci_dev_test_flag(hdev, HCI_AUTO_OFF) ||\n\t    hci_dev_test_flag(hdev, HCI_UNREGISTER))\n\t\treturn 0;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn 0;\n\n\t \n\tif (hdev->discovery.state != DISCOVERY_STOPPED)\n\t\treturn 0;\n\n\t \n\thci_discovery_filter_clear(hdev);\n\n\tbt_dev_dbg(hdev, \"ADV monitoring is %s\",\n\t\t   hci_is_adv_monitoring(hdev) ? \"on\" : \"off\");\n\n\tif (!hci_dev_test_flag(hdev, HCI_MESH) &&\n\t    list_empty(&hdev->pend_le_conns) &&\n\t    list_empty(&hdev->pend_le_reports) &&\n\t    !hci_is_adv_monitoring(hdev) &&\n\t    !hci_dev_test_flag(hdev, HCI_PA_SYNC)) {\n\t\t \n\n\t\tbt_dev_dbg(hdev, \"stopping background scanning\");\n\n\t\terr = hci_scan_disable_sync(hdev);\n\t\tif (err)\n\t\t\tbt_dev_err(hdev, \"stop background scanning failed: %d\",\n\t\t\t\t   err);\n\t} else {\n\t\t \n\n\t\t \n\t\tif (hci_lookup_le_connect(hdev))\n\t\t\treturn 0;\n\n\t\tbt_dev_dbg(hdev, \"start background scanning\");\n\n\t\terr = hci_passive_scan_sync(hdev);\n\t\tif (err)\n\t\t\tbt_dev_err(hdev, \"start background scanning failed: %d\",\n\t\t\t\t   err);\n\t}\n\n\treturn err;\n}\n\nstatic int update_scan_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_update_scan_sync(hdev);\n}\n\nint hci_update_scan(struct hci_dev *hdev)\n{\n\treturn hci_cmd_sync_queue(hdev, update_scan_sync, NULL, NULL);\n}\n\nstatic int update_passive_scan_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_update_passive_scan_sync(hdev);\n}\n\nint hci_update_passive_scan(struct hci_dev *hdev)\n{\n\t \n\tif (!test_bit(HCI_UP, &hdev->flags) ||\n\t    test_bit(HCI_INIT, &hdev->flags) ||\n\t    hci_dev_test_flag(hdev, HCI_SETUP) ||\n\t    hci_dev_test_flag(hdev, HCI_CONFIG) ||\n\t    hci_dev_test_flag(hdev, HCI_AUTO_OFF) ||\n\t    hci_dev_test_flag(hdev, HCI_UNREGISTER))\n\t\treturn 0;\n\n\treturn hci_cmd_sync_queue(hdev, update_passive_scan_sync, NULL, NULL);\n}\n\nint hci_write_sc_support_sync(struct hci_dev *hdev, u8 val)\n{\n\tint err;\n\n\tif (!bredr_sc_enabled(hdev) || lmp_host_sc_capable(hdev))\n\t\treturn 0;\n\n\terr = __hci_cmd_sync_status(hdev, HCI_OP_WRITE_SC_SUPPORT,\n\t\t\t\t    sizeof(val), &val, HCI_CMD_TIMEOUT);\n\n\tif (!err) {\n\t\tif (val) {\n\t\t\thdev->features[1][0] |= LMP_HOST_SC;\n\t\t\thci_dev_set_flag(hdev, HCI_SC_ENABLED);\n\t\t} else {\n\t\t\thdev->features[1][0] &= ~LMP_HOST_SC;\n\t\t\thci_dev_clear_flag(hdev, HCI_SC_ENABLED);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint hci_write_ssp_mode_sync(struct hci_dev *hdev, u8 mode)\n{\n\tint err;\n\n\tif (!hci_dev_test_flag(hdev, HCI_SSP_ENABLED) ||\n\t    lmp_host_ssp_capable(hdev))\n\t\treturn 0;\n\n\tif (!mode && hci_dev_test_flag(hdev, HCI_USE_DEBUG_KEYS)) {\n\t\t__hci_cmd_sync_status(hdev, HCI_OP_WRITE_SSP_DEBUG_MODE,\n\t\t\t\t      sizeof(mode), &mode, HCI_CMD_TIMEOUT);\n\t}\n\n\terr = __hci_cmd_sync_status(hdev, HCI_OP_WRITE_SSP_MODE,\n\t\t\t\t    sizeof(mode), &mode, HCI_CMD_TIMEOUT);\n\tif (err)\n\t\treturn err;\n\n\treturn hci_write_sc_support_sync(hdev, 0x01);\n}\n\nint hci_write_le_host_supported_sync(struct hci_dev *hdev, u8 le, u8 simul)\n{\n\tstruct hci_cp_write_le_host_supported cp;\n\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED) ||\n\t    !lmp_bredr_capable(hdev))\n\t\treturn 0;\n\n\t \n\tif (le == lmp_host_le_capable(hdev) &&\n\t    simul == lmp_host_le_br_capable(hdev))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tcp.le = le;\n\tcp.simul = simul;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_powered_update_adv_sync(struct hci_dev *hdev)\n{\n\tstruct adv_info *adv, *tmp;\n\tint err;\n\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn 0;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LL_RPA_RESOLUTION)) {\n\t\thci_le_add_resolve_list_sync(hdev, NULL);\n\t\thci_le_set_addr_resolution_enable_sync(hdev, 0x01);\n\t}\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING) ||\n\t    list_empty(&hdev->adv_instances)) {\n\t\tif (ext_adv_capable(hdev)) {\n\t\t\terr = hci_setup_ext_adv_instance_sync(hdev, 0x00);\n\t\t\tif (!err)\n\t\t\t\thci_update_scan_rsp_data_sync(hdev, 0x00);\n\t\t} else {\n\t\t\terr = hci_update_adv_data_sync(hdev, 0x00);\n\t\t\tif (!err)\n\t\t\t\thci_update_scan_rsp_data_sync(hdev, 0x00);\n\t\t}\n\n\t\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\t\thci_enable_advertising_sync(hdev);\n\t}\n\n\t \n\tlist_for_each_entry_safe(adv, tmp, &hdev->adv_instances, list)\n\t\thci_schedule_adv_instance_sync(hdev, adv->instance, true);\n\n\treturn 0;\n}\n\nstatic int hci_write_auth_enable_sync(struct hci_dev *hdev)\n{\n\tu8 link_sec;\n\n\tlink_sec = hci_dev_test_flag(hdev, HCI_LINK_SECURITY);\n\tif (link_sec == test_bit(HCI_AUTH, &hdev->flags))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_AUTH_ENABLE,\n\t\t\t\t     sizeof(link_sec), &link_sec,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\nint hci_write_fast_connectable_sync(struct hci_dev *hdev, bool enable)\n{\n\tstruct hci_cp_write_page_scan_activity cp;\n\tu8 type;\n\tint err = 0;\n\n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn 0;\n\n\tif (hdev->hci_ver < BLUETOOTH_VER_1_2)\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tif (enable) {\n\t\ttype = PAGE_SCAN_TYPE_INTERLACED;\n\n\t\t \n\t\tcp.interval = cpu_to_le16(0x0100);\n\t} else {\n\t\ttype = hdev->def_page_scan_type;\n\t\tcp.interval = cpu_to_le16(hdev->def_page_scan_int);\n\t}\n\n\tcp.window = cpu_to_le16(hdev->def_page_scan_window);\n\n\tif (__cpu_to_le16(hdev->page_scan_interval) != cp.interval ||\n\t    __cpu_to_le16(hdev->page_scan_window) != cp.window) {\n\t\terr = __hci_cmd_sync_status(hdev,\n\t\t\t\t\t    HCI_OP_WRITE_PAGE_SCAN_ACTIVITY,\n\t\t\t\t\t    sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (hdev->page_scan_type != type)\n\t\terr = __hci_cmd_sync_status(hdev,\n\t\t\t\t\t    HCI_OP_WRITE_PAGE_SCAN_TYPE,\n\t\t\t\t\t    sizeof(type), &type,\n\t\t\t\t\t    HCI_CMD_TIMEOUT);\n\n\treturn err;\n}\n\nstatic bool disconnected_accept_list_entries(struct hci_dev *hdev)\n{\n\tstruct bdaddr_list *b;\n\n\tlist_for_each_entry(b, &hdev->accept_list, list) {\n\t\tstruct hci_conn *conn;\n\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &b->bdaddr);\n\t\tif (!conn)\n\t\t\treturn true;\n\n\t\tif (conn->state != BT_CONNECTED && conn->state != BT_CONFIG)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int hci_write_scan_enable_sync(struct hci_dev *hdev, u8 val)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_SCAN_ENABLE,\n\t\t\t\t\t    sizeof(val), &val,\n\t\t\t\t\t    HCI_CMD_TIMEOUT);\n}\n\nint hci_update_scan_sync(struct hci_dev *hdev)\n{\n\tu8 scan;\n\n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn 0;\n\n\tif (!hdev_is_powered(hdev))\n\t\treturn 0;\n\n\tif (mgmt_powering_down(hdev))\n\t\treturn 0;\n\n\tif (hdev->scanning_paused)\n\t\treturn 0;\n\n\tif (hci_dev_test_flag(hdev, HCI_CONNECTABLE) ||\n\t    disconnected_accept_list_entries(hdev))\n\t\tscan = SCAN_PAGE;\n\telse\n\t\tscan = SCAN_DISABLED;\n\n\tif (hci_dev_test_flag(hdev, HCI_DISCOVERABLE))\n\t\tscan |= SCAN_INQUIRY;\n\n\tif (test_bit(HCI_PSCAN, &hdev->flags) == !!(scan & SCAN_PAGE) &&\n\t    test_bit(HCI_ISCAN, &hdev->flags) == !!(scan & SCAN_INQUIRY))\n\t\treturn 0;\n\n\treturn hci_write_scan_enable_sync(hdev, scan);\n}\n\nint hci_update_name_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_write_local_name cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tmemcpy(cp.name, hdev->dev_name, sizeof(cp.name));\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_LOCAL_NAME,\n\t\t\t\t\t    sizeof(cp), &cp,\n\t\t\t\t\t    HCI_CMD_TIMEOUT);\n}\n\n \nint hci_powered_update_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\t \n\tsmp_register(hdev);\n\n\terr = hci_write_ssp_mode_sync(hdev, 0x01);\n\tif (err)\n\t\treturn err;\n\n\terr = hci_write_le_host_supported_sync(hdev, 0x01, 0x00);\n\tif (err)\n\t\treturn err;\n\n\terr = hci_powered_update_adv_sync(hdev);\n\tif (err)\n\t\treturn err;\n\n\terr = hci_write_auth_enable_sync(hdev);\n\tif (err)\n\t\treturn err;\n\n\tif (lmp_bredr_capable(hdev)) {\n\t\tif (hci_dev_test_flag(hdev, HCI_FAST_CONNECTABLE))\n\t\t\thci_write_fast_connectable_sync(hdev, true);\n\t\telse\n\t\t\thci_write_fast_connectable_sync(hdev, false);\n\t\thci_update_scan_sync(hdev);\n\t\thci_update_class_sync(hdev);\n\t\thci_update_name_sync(hdev);\n\t\thci_update_eir_sync(hdev);\n\t}\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||\n\t    (!bacmp(&hdev->bdaddr, BDADDR_ANY) &&\n\t    !hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))) {\n\t\tif (bacmp(&hdev->static_addr, BDADDR_ANY))\n\t\t\treturn hci_set_random_addr_sync(hdev,\n\t\t\t\t\t\t\t&hdev->static_addr);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void hci_dev_get_bd_addr_from_property(struct hci_dev *hdev)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(hdev->dev.parent);\n\tbdaddr_t ba;\n\tint ret;\n\n\tret = fwnode_property_read_u8_array(fwnode, \"local-bd-address\",\n\t\t\t\t\t    (u8 *)&ba, sizeof(ba));\n\tif (ret < 0 || !bacmp(&ba, BDADDR_ANY))\n\t\treturn;\n\n\tbacpy(&hdev->public_addr, &ba);\n}\n\nstruct hci_init_stage {\n\tint (*func)(struct hci_dev *hdev);\n};\n\n \nstatic int hci_init_stage_sync(struct hci_dev *hdev,\n\t\t\t       const struct hci_init_stage *stage)\n{\n\tsize_t i;\n\n\tfor (i = 0; stage[i].func; i++) {\n\t\tint err;\n\n\t\terr = stage[i].func(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hci_read_local_version_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_LOCAL_VERSION,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_bd_addr_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_BD_ADDR,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n#define HCI_INIT(_func) \\\n{ \\\n\t.func = _func, \\\n}\n\nstatic const struct hci_init_stage hci_init0[] = {\n\t \n\tHCI_INIT(hci_read_local_version_sync),\n\t \n\tHCI_INIT(hci_read_bd_addr_sync),\n\t{}\n};\n\nint hci_reset_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\tset_bit(HCI_RESET, &hdev->flags);\n\n\terr = __hci_cmd_sync_status(hdev, HCI_OP_RESET, 0, NULL,\n\t\t\t\t    HCI_CMD_TIMEOUT);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int hci_init0_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\t \n\tif (!test_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks)) {\n\t\terr = hci_reset_sync(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn hci_init_stage_sync(hdev, hci_init0);\n}\n\nstatic int hci_unconf_init_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))\n\t\treturn 0;\n\n\terr = hci_init0_sync(hdev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (hci_dev_test_flag(hdev, HCI_SETUP))\n\t\thci_debugfs_create_basic(hdev);\n\n\treturn 0;\n}\n\n \nstatic int hci_read_local_features_sync(struct hci_dev *hdev)\n{\n\t  \n\tif (hdev->dev_type == HCI_AMP && !(hdev->commands[14] & 0x20))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_LOCAL_FEATURES,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic const struct hci_init_stage br_init1[] = {\n\t \n\tHCI_INIT(hci_read_local_features_sync),\n\t \n\tHCI_INIT(hci_read_local_version_sync),\n\t \n\tHCI_INIT(hci_read_bd_addr_sync),\n\t{}\n};\n\n \nstatic int hci_read_local_cmds_sync(struct hci_dev *hdev)\n{\n\t \n\tif (hdev->hci_ver > BLUETOOTH_VER_1_1 &&\n\t    !test_bit(HCI_QUIRK_BROKEN_LOCAL_COMMANDS, &hdev->quirks))\n\t\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_LOCAL_COMMANDS,\n\t\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n\n\treturn 0;\n}\n\n \nstatic int hci_read_local_amp_info_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_LOCAL_AMP_INFO,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_data_block_size_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_DATA_BLOCK_SIZE,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_flow_control_mode_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_FLOW_CONTROL_MODE,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_location_data_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_LOCATION_DATA,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic const struct hci_init_stage amp_init1[] = {\n\t \n\tHCI_INIT(hci_read_local_version_sync),\n\t \n\tHCI_INIT(hci_read_local_cmds_sync),\n\t \n\tHCI_INIT(hci_read_local_amp_info_sync),\n\t \n\tHCI_INIT(hci_read_data_block_size_sync),\n\t \n\tHCI_INIT(hci_read_flow_control_mode_sync),\n\t \n\tHCI_INIT(hci_read_location_data_sync),\n\t{}\n};\n\nstatic int hci_init1_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\t \n\tif (!test_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks)) {\n\t\terr = hci_reset_sync(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tswitch (hdev->dev_type) {\n\tcase HCI_PRIMARY:\n\t\thdev->flow_ctl_mode = HCI_FLOW_CTL_MODE_PACKET_BASED;\n\t\treturn hci_init_stage_sync(hdev, br_init1);\n\tcase HCI_AMP:\n\t\thdev->flow_ctl_mode = HCI_FLOW_CTL_MODE_BLOCK_BASED;\n\t\treturn hci_init_stage_sync(hdev, amp_init1);\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unknown device type %d\", hdev->dev_type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct hci_init_stage amp_init2[] = {\n\t \n\tHCI_INIT(hci_read_local_features_sync),\n\t{}\n};\n\n \nstatic int hci_read_buffer_size_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_BUFFER_SIZE,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_dev_class_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_CLASS_OF_DEV,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_local_name_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_LOCAL_NAME,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_voice_setting_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_VOICE_SETTING,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_num_supported_iac_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_NUM_SUPPORTED_IAC,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_current_iac_lap_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_CURRENT_IAC_LAP,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_set_event_filter_sync(struct hci_dev *hdev, u8 flt_type,\n\t\t\t\t     u8 cond_type, bdaddr_t *bdaddr,\n\t\t\t\t     u8 auto_accept)\n{\n\tstruct hci_cp_set_event_filter cp;\n\n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn 0;\n\n\tif (test_bit(HCI_QUIRK_BROKEN_FILTER_CLEAR_ALL, &hdev->quirks))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.flt_type = flt_type;\n\n\tif (flt_type != HCI_FLT_CLEAR_ALL) {\n\t\tcp.cond_type = cond_type;\n\t\tbacpy(&cp.addr_conn_flt.bdaddr, bdaddr);\n\t\tcp.addr_conn_flt.auto_accept = auto_accept;\n\t}\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_SET_EVENT_FLT,\n\t\t\t\t     flt_type == HCI_FLT_CLEAR_ALL ?\n\t\t\t\t     sizeof(cp.flt_type) : sizeof(cp), &cp,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_clear_event_filter_sync(struct hci_dev *hdev)\n{\n\tif (!hci_dev_test_flag(hdev, HCI_EVENT_FILTER_CONFIGURED))\n\t\treturn 0;\n\n\t \n\tif (test_bit(HCI_QUIRK_BROKEN_FILTER_CLEAR_ALL, &hdev->quirks))\n\t\treturn 0;\n\n\treturn hci_set_event_filter_sync(hdev, HCI_FLT_CLEAR_ALL, 0x00,\n\t\t\t\t\t BDADDR_ANY, 0x00);\n}\n\n \nstatic int hci_write_ca_timeout_sync(struct hci_dev *hdev)\n{\n\t__le16 param = cpu_to_le16(0x7d00);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_CA_TIMEOUT,\n\t\t\t\t     sizeof(param), &param, HCI_CMD_TIMEOUT);\n}\n\n \nstatic const struct hci_init_stage br_init2[] = {\n\t \n\tHCI_INIT(hci_read_buffer_size_sync),\n\t \n\tHCI_INIT(hci_read_dev_class_sync),\n\t \n\tHCI_INIT(hci_read_local_name_sync),\n\t \n\tHCI_INIT(hci_read_voice_setting_sync),\n\t \n\tHCI_INIT(hci_read_num_supported_iac_sync),\n\t \n\tHCI_INIT(hci_read_current_iac_lap_sync),\n\t \n\tHCI_INIT(hci_clear_event_filter_sync),\n\t \n\tHCI_INIT(hci_write_ca_timeout_sync),\n\t{}\n};\n\nstatic int hci_write_ssp_mode_1_sync(struct hci_dev *hdev)\n{\n\tu8 mode = 0x01;\n\n\tif (!lmp_ssp_capable(hdev) || !hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\n\t\treturn 0;\n\n\t \n\thdev->max_page = 0x01;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_SSP_MODE,\n\t\t\t\t     sizeof(mode), &mode, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_write_eir_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_write_eir cp;\n\n\tif (!lmp_ssp_capable(hdev) || hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\n\t\treturn 0;\n\n\tmemset(hdev->eir, 0, sizeof(hdev->eir));\n\tmemset(&cp, 0, sizeof(cp));\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_write_inquiry_mode_sync(struct hci_dev *hdev)\n{\n\tu8 mode;\n\n\tif (!lmp_inq_rssi_capable(hdev) &&\n\t    !test_bit(HCI_QUIRK_FIXUP_INQUIRY_MODE, &hdev->quirks))\n\t\treturn 0;\n\n\t \n\tmode = lmp_ext_inq_capable(hdev) ? 0x02 : 0x01;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_INQUIRY_MODE,\n\t\t\t\t     sizeof(mode), &mode, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_read_inq_rsp_tx_power_sync(struct hci_dev *hdev)\n{\n\tif (!lmp_inq_tx_pwr_capable(hdev))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_INQ_RSP_TX_POWER,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_read_local_ext_features_sync(struct hci_dev *hdev, u8 page)\n{\n\tstruct hci_cp_read_local_ext_features cp;\n\n\tif (!lmp_ext_feat_capable(hdev))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.page = page;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_read_local_ext_features_1_sync(struct hci_dev *hdev)\n{\n\treturn hci_read_local_ext_features_sync(hdev, 0x01);\n}\n\n \nstatic const struct hci_init_stage hci_init2[] = {\n\t \n\tHCI_INIT(hci_read_local_cmds_sync),\n\t \n\tHCI_INIT(hci_write_ssp_mode_1_sync),\n\t \n\tHCI_INIT(hci_write_eir_sync),\n\t \n\tHCI_INIT(hci_write_inquiry_mode_sync),\n\t \n\tHCI_INIT(hci_read_inq_rsp_tx_power_sync),\n\t \n\tHCI_INIT(hci_read_local_ext_features_1_sync),\n\t \n\tHCI_INIT(hci_write_auth_enable_sync),\n\t{}\n};\n\n \nstatic int hci_le_read_buffer_size_sync(struct hci_dev *hdev)\n{\n\t \n\tif (iso_capable(hdev) && hdev->commands[41] & 0x20)\n\t\treturn __hci_cmd_sync_status(hdev,\n\t\t\t\t\t     HCI_OP_LE_READ_BUFFER_SIZE_V2,\n\t\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_READ_BUFFER_SIZE,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_read_local_features_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_READ_LOCAL_FEATURES,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_read_supported_states_sync(struct hci_dev *hdev)\n{\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_READ_SUPPORTED_STATES,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic const struct hci_init_stage le_init2[] = {\n\t \n\tHCI_INIT(hci_le_read_local_features_sync),\n\t \n\tHCI_INIT(hci_le_read_buffer_size_sync),\n\t \n\tHCI_INIT(hci_le_read_supported_states_sync),\n\t{}\n};\n\nstatic int hci_init2_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tif (hdev->dev_type == HCI_AMP)\n\t\treturn hci_init_stage_sync(hdev, amp_init2);\n\n\terr = hci_init_stage_sync(hdev, hci_init2);\n\tif (err)\n\t\treturn err;\n\n\tif (lmp_bredr_capable(hdev)) {\n\t\terr = hci_init_stage_sync(hdev, br_init2);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\thci_dev_clear_flag(hdev, HCI_BREDR_ENABLED);\n\t}\n\n\tif (lmp_le_capable(hdev)) {\n\t\terr = hci_init_stage_sync(hdev, le_init2);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\tif (!lmp_bredr_capable(hdev))\n\t\t\thci_dev_set_flag(hdev, HCI_LE_ENABLED);\n\t}\n\n\treturn 0;\n}\n\nstatic int hci_set_event_mask_sync(struct hci_dev *hdev)\n{\n\t \n\tu8 events[8] = { 0xff, 0xff, 0xfb, 0xff, 0x00, 0x00, 0x00, 0x00 };\n\n\t \n\tif (hdev->hci_ver < BLUETOOTH_VER_1_2)\n\t\treturn 0;\n\n\tif (lmp_bredr_capable(hdev)) {\n\t\tevents[4] |= 0x01;  \n\n\t\t \n\t\tif (hdev->suspended)\n\t\t\tevents[0] &= 0xef;\n\t} else {\n\t\t \n\t\tmemset(events, 0, sizeof(events));\n\t\tevents[1] |= 0x20;  \n\t\tevents[1] |= 0x40;  \n\t\tevents[1] |= 0x80;  \n\n\t\t \n\t\tif (hdev->commands[0] & 0x20) {\n\t\t\t \n\t\t\tif (!hdev->suspended)\n\t\t\t\tevents[0] |= 0x10;  \n\t\t\tevents[2] |= 0x04;  \n\t\t\tevents[3] |= 0x02;  \n\t\t}\n\n\t\t \n\t\tif (hdev->commands[2] & 0x80)\n\t\t\tevents[1] |= 0x08;  \n\n\t\tif (hdev->le_features[0] & HCI_LE_ENCRYPTION) {\n\t\t\tevents[0] |= 0x80;  \n\t\t\tevents[5] |= 0x80;  \n\t\t}\n\t}\n\n\tif (lmp_inq_rssi_capable(hdev) ||\n\t    test_bit(HCI_QUIRK_FIXUP_INQUIRY_MODE, &hdev->quirks))\n\t\tevents[4] |= 0x02;  \n\n\tif (lmp_ext_feat_capable(hdev))\n\t\tevents[4] |= 0x04;  \n\n\tif (lmp_esco_capable(hdev)) {\n\t\tevents[5] |= 0x08;  \n\t\tevents[5] |= 0x10;  \n\t}\n\n\tif (lmp_sniffsubr_capable(hdev))\n\t\tevents[5] |= 0x20;  \n\n\tif (lmp_pause_enc_capable(hdev))\n\t\tevents[5] |= 0x80;  \n\n\tif (lmp_ext_inq_capable(hdev))\n\t\tevents[5] |= 0x40;  \n\n\tif (lmp_no_flush_capable(hdev))\n\t\tevents[7] |= 0x01;  \n\n\tif (lmp_lsto_capable(hdev))\n\t\tevents[6] |= 0x80;  \n\n\tif (lmp_ssp_capable(hdev)) {\n\t\tevents[6] |= 0x01;\t \n\t\tevents[6] |= 0x02;\t \n\t\tevents[6] |= 0x04;\t \n\t\tevents[6] |= 0x08;\t \n\t\tevents[6] |= 0x10;\t \n\t\tevents[6] |= 0x20;\t \n\t\tevents[7] |= 0x04;\t \n\t\tevents[7] |= 0x08;\t \n\t\tevents[7] |= 0x10;\t \n\t}\n\n\tif (lmp_le_capable(hdev))\n\t\tevents[7] |= 0x20;\t \n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_SET_EVENT_MASK,\n\t\t\t\t     sizeof(events), events, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_read_stored_link_key_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_read_stored_link_key cp;\n\n\tif (!(hdev->commands[6] & 0x20) ||\n\t    test_bit(HCI_QUIRK_BROKEN_STORED_LINK_KEY, &hdev->quirks))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.bdaddr, BDADDR_ANY);\n\tcp.read_all = 0x01;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_STORED_LINK_KEY,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_setup_link_policy_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_write_def_link_policy cp;\n\tu16 link_policy = 0;\n\n\tif (!(hdev->commands[5] & 0x10))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tif (lmp_rswitch_capable(hdev))\n\t\tlink_policy |= HCI_LP_RSWITCH;\n\tif (lmp_hold_capable(hdev))\n\t\tlink_policy |= HCI_LP_HOLD;\n\tif (lmp_sniff_capable(hdev))\n\t\tlink_policy |= HCI_LP_SNIFF;\n\tif (lmp_park_capable(hdev))\n\t\tlink_policy |= HCI_LP_PARK;\n\n\tcp.policy = cpu_to_le16(link_policy);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_DEF_LINK_POLICY,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_read_page_scan_activity_sync(struct hci_dev *hdev)\n{\n\tif (!(hdev->commands[8] & 0x01))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_PAGE_SCAN_ACTIVITY,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_read_def_err_data_reporting_sync(struct hci_dev *hdev)\n{\n\tif (!(hdev->commands[18] & 0x04) ||\n\t    !(hdev->features[0][6] & LMP_ERR_DATA_REPORTING) ||\n\t    test_bit(HCI_QUIRK_BROKEN_ERR_DATA_REPORTING, &hdev->quirks))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_DEF_ERR_DATA_REPORTING,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_read_page_scan_type_sync(struct hci_dev *hdev)\n{\n\t \n\tif (!(hdev->commands[13] & 0x01))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_PAGE_SCAN_TYPE,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_local_ext_features_all_sync(struct hci_dev *hdev)\n{\n\tu8 page;\n\tint err;\n\n\tif (!lmp_ext_feat_capable(hdev))\n\t\treturn 0;\n\n\tfor (page = 2; page < HCI_MAX_PAGES && page <= hdev->max_page;\n\t     page++) {\n\t\terr = hci_read_local_ext_features_sync(hdev, page);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct hci_init_stage hci_init3[] = {\n\t \n\tHCI_INIT(hci_set_event_mask_sync),\n\t \n\tHCI_INIT(hci_read_stored_link_key_sync),\n\t \n\tHCI_INIT(hci_setup_link_policy_sync),\n\t \n\tHCI_INIT(hci_read_page_scan_activity_sync),\n\t \n\tHCI_INIT(hci_read_def_err_data_reporting_sync),\n\t \n\tHCI_INIT(hci_read_page_scan_type_sync),\n\t \n\tHCI_INIT(hci_read_local_ext_features_all_sync),\n\t{}\n};\n\nstatic int hci_le_set_event_mask_sync(struct hci_dev *hdev)\n{\n\tu8 events[8];\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn 0;\n\n\tmemset(events, 0, sizeof(events));\n\n\tif (hdev->le_features[0] & HCI_LE_ENCRYPTION)\n\t\tevents[0] |= 0x10;\t \n\n\t \n\tif (hdev->le_features[0] & HCI_LE_CONN_PARAM_REQ_PROC)\n\t\t \n\t\tevents[0] |= 0x20;\n\n\t \n\tif (hdev->le_features[0] & HCI_LE_DATA_LEN_EXT)\n\t\tevents[0] |= 0x40;\t \n\n\t \n\tif (use_enhanced_conn_complete(hdev))\n\t\tevents[1] |= 0x02;\t \n\n\t \n\tif (hdev->le_features[0] & HCI_LE_EXT_SCAN_POLICY)\n\t\tevents[1] |= 0x04;\t \n\n\t \n\tif (hdev->le_features[1] & HCI_LE_CHAN_SEL_ALG2)\n\t\tevents[2] |= 0x08;\t \n\n\t \n\tif (hdev->commands[26] & 0x08)\n\t\tevents[0] |= 0x02;\t \n\n\t \n\tif (hdev->commands[26] & 0x10)\n\t\tevents[0] |= 0x01;\t \n\n\t \n\tif (hdev->commands[27] & 0x04)\n\t\tevents[0] |= 0x04;\t \n\n\t \n\tif (hdev->commands[27] & 0x20)\n\t\t \n\t\tevents[0] |= 0x08;\n\n\t \n\tif (hdev->commands[34] & 0x02)\n\t\t \n\t\tevents[0] |= 0x80;\n\n\t \n\tif (hdev->commands[34] & 0x04)\n\t\tevents[1] |= 0x01;\t \n\n\t \n\tif (hdev->commands[35] & (0x20 | 0x40))\n\t\tevents[1] |= 0x08;         \n\n\t \n\tif (use_ext_scan(hdev))\n\t\tevents[1] |= 0x10;\t \n\n\t \n\tif (ext_adv_capable(hdev))\n\t\tevents[2] |= 0x02;\t \n\n\tif (cis_capable(hdev)) {\n\t\tevents[3] |= 0x01;\t \n\t\tif (cis_peripheral_capable(hdev))\n\t\t\tevents[3] |= 0x02;  \n\t}\n\n\tif (bis_capable(hdev)) {\n\t\tevents[1] |= 0x20;\t \n\t\tevents[1] |= 0x40;\t \n\t\tevents[3] |= 0x04;\t \n\t\tevents[3] |= 0x08;\t \n\t\tevents[3] |= 0x10;\t \n\t\tevents[3] |= 0x20;\t \n\t\tevents[4] |= 0x02;\t \n\t}\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_EVENT_MASK,\n\t\t\t\t     sizeof(events), events, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_read_adv_tx_power_sync(struct hci_dev *hdev)\n{\n\tif ((hdev->commands[25] & 0x40) && !ext_adv_capable(hdev)) {\n\t\t \n\t\treturn __hci_cmd_sync_status(hdev,\n\t\t\t\t\t       HCI_OP_LE_READ_ADV_TX_POWER,\n\t\t\t\t\t       0, NULL, HCI_CMD_TIMEOUT);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hci_le_read_tx_power_sync(struct hci_dev *hdev)\n{\n\tif (!(hdev->commands[38] & 0x80) ||\n\t    test_bit(HCI_QUIRK_BROKEN_READ_TRANSMIT_POWER, &hdev->quirks))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_READ_TRANSMIT_POWER,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_read_accept_list_size_sync(struct hci_dev *hdev)\n{\n\tif (!(hdev->commands[26] & 0x40))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_READ_ACCEPT_LIST_SIZE,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_clear_accept_list_sync(struct hci_dev *hdev)\n{\n\tif (!(hdev->commands[26] & 0x80))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_CLEAR_ACCEPT_LIST, 0, NULL,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_read_resolv_list_size_sync(struct hci_dev *hdev)\n{\n\tif (!(hdev->commands[34] & 0x40))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_READ_RESOLV_LIST_SIZE,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_clear_resolv_list_sync(struct hci_dev *hdev)\n{\n\tif (!(hdev->commands[34] & 0x20))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_CLEAR_RESOLV_LIST, 0, NULL,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_set_rpa_timeout_sync(struct hci_dev *hdev)\n{\n\t__le16 timeout = cpu_to_le16(hdev->rpa_timeout);\n\n\tif (!(hdev->commands[35] & 0x04) ||\n\t    test_bit(HCI_QUIRK_BROKEN_SET_RPA_TIMEOUT, &hdev->quirks))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_RPA_TIMEOUT,\n\t\t\t\t     sizeof(timeout), &timeout,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_read_max_data_len_sync(struct hci_dev *hdev)\n{\n\tif (!(hdev->le_features[0] & HCI_LE_DATA_LEN_EXT))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_READ_MAX_DATA_LEN, 0, NULL,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_read_def_data_len_sync(struct hci_dev *hdev)\n{\n\tif (!(hdev->le_features[0] & HCI_LE_DATA_LEN_EXT))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_READ_DEF_DATA_LEN, 0, NULL,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_read_num_support_adv_sets_sync(struct hci_dev *hdev)\n{\n\tif (!ext_adv_capable(hdev))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev,\n\t\t\t\t     HCI_OP_LE_READ_NUM_SUPPORTED_ADV_SETS,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_set_le_support_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_write_le_host_supported cp;\n\n\t \n\tif (!lmp_bredr_capable(hdev))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tif (hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\n\t\tcp.le = 0x01;\n\t\tcp.simul = 0x00;\n\t}\n\n\tif (cp.le == lmp_host_le_capable(hdev))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_set_host_feature_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_le_set_host_feature cp;\n\n\tif (!iso_capable(hdev))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\t \n\tcp.bit_number = 32;\n\tcp.bit_value = 1;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_HOST_FEATURE,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\n \nstatic const struct hci_init_stage le_init3[] = {\n\t \n\tHCI_INIT(hci_le_set_event_mask_sync),\n\t \n\tHCI_INIT(hci_le_read_adv_tx_power_sync),\n\t \n\tHCI_INIT(hci_le_read_tx_power_sync),\n\t \n\tHCI_INIT(hci_le_read_accept_list_size_sync),\n\t \n\tHCI_INIT(hci_le_clear_accept_list_sync),\n\t \n\tHCI_INIT(hci_le_read_resolv_list_size_sync),\n\t \n\tHCI_INIT(hci_le_clear_resolv_list_sync),\n\t \n\tHCI_INIT(hci_le_set_rpa_timeout_sync),\n\t \n\tHCI_INIT(hci_le_read_max_data_len_sync),\n\t \n\tHCI_INIT(hci_le_read_def_data_len_sync),\n\t \n\tHCI_INIT(hci_le_read_num_support_adv_sets_sync),\n\t \n\tHCI_INIT(hci_set_le_support_sync),\n\t \n\tHCI_INIT(hci_le_set_host_feature_sync),\n\t{}\n};\n\nstatic int hci_init3_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\terr = hci_init_stage_sync(hdev, hci_init3);\n\tif (err)\n\t\treturn err;\n\n\tif (lmp_le_capable(hdev))\n\t\treturn hci_init_stage_sync(hdev, le_init3);\n\n\treturn 0;\n}\n\nstatic int hci_delete_stored_link_key_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_delete_stored_link_key cp;\n\n\t \n\tif (!(hdev->commands[6] & 0x80) ||\n\t    test_bit(HCI_QUIRK_BROKEN_STORED_LINK_KEY, &hdev->quirks))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.bdaddr, BDADDR_ANY);\n\tcp.delete_all = 0x01;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_DELETE_STORED_LINK_KEY,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_set_event_mask_page_2_sync(struct hci_dev *hdev)\n{\n\tu8 events[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tbool changed = false;\n\n\t \n\tif (!(hdev->commands[22] & 0x04))\n\t\treturn 0;\n\n\t \n\tif (lmp_cpb_central_capable(hdev)) {\n\t\tevents[1] |= 0x40;\t \n\t\tevents[1] |= 0x80;\t \n\t\tevents[2] |= 0x08;\t \n\t\tevents[2] |= 0x20;\t \n\t\tchanged = true;\n\t}\n\n\t \n\tif (lmp_cpb_peripheral_capable(hdev)) {\n\t\tevents[2] |= 0x01;\t \n\t\tevents[2] |= 0x02;\t \n\t\tevents[2] |= 0x04;\t \n\t\tevents[2] |= 0x10;\t \n\t\tchanged = true;\n\t}\n\n\t \n\tif (lmp_ping_capable(hdev) || hdev->le_features[0] & HCI_LE_PING) {\n\t\tevents[2] |= 0x80;\n\t\tchanged = true;\n\t}\n\n\t \n\tif (!changed)\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_SET_EVENT_MASK_PAGE_2,\n\t\t\t\t     sizeof(events), events, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_local_codecs_sync(struct hci_dev *hdev)\n{\n\tif (hdev->commands[45] & 0x04)\n\t\thci_read_supported_codecs_v2(hdev);\n\telse if (hdev->commands[29] & 0x20)\n\t\thci_read_supported_codecs(hdev);\n\n\treturn 0;\n}\n\n \nstatic int hci_read_local_pairing_opts_sync(struct hci_dev *hdev)\n{\n\tif (!(hdev->commands[41] & 0x08))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_LOCAL_PAIRING_OPTS,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_get_mws_transport_config_sync(struct hci_dev *hdev)\n{\n\tif (!mws_transport_config_capable(hdev))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_GET_MWS_TRANSPORT_CONFIG,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_read_sync_train_params_sync(struct hci_dev *hdev)\n{\n\tif (!lmp_sync_train_capable(hdev))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_READ_SYNC_TRAIN_PARAMS,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_write_sc_support_1_sync(struct hci_dev *hdev)\n{\n\tu8 support = 0x01;\n\n\tif (!hci_dev_test_flag(hdev, HCI_SSP_ENABLED) ||\n\t    !bredr_sc_enabled(hdev))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_SC_SUPPORT,\n\t\t\t\t     sizeof(support), &support,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_set_err_data_report_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_write_def_err_data_reporting cp;\n\tbool enabled = hci_dev_test_flag(hdev, HCI_WIDEBAND_SPEECH_ENABLED);\n\n\tif (!(hdev->commands[18] & 0x08) ||\n\t    !(hdev->features[0][6] & LMP_ERR_DATA_REPORTING) ||\n\t    test_bit(HCI_QUIRK_BROKEN_ERR_DATA_REPORTING, &hdev->quirks))\n\t\treturn 0;\n\n\tif (enabled == hdev->err_data_reporting)\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.err_data_reporting = enabled ? ERR_DATA_REPORTING_ENABLED :\n\t\t\t\tERR_DATA_REPORTING_DISABLED;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_DEF_ERR_DATA_REPORTING,\n\t\t\t\t    sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic const struct hci_init_stage hci_init4[] = {\n\t  \n\tHCI_INIT(hci_delete_stored_link_key_sync),\n\t \n\tHCI_INIT(hci_set_event_mask_page_2_sync),\n\t \n\tHCI_INIT(hci_read_local_codecs_sync),\n\t  \n\tHCI_INIT(hci_read_local_pairing_opts_sync),\n\t  \n\tHCI_INIT(hci_get_mws_transport_config_sync),\n\t  \n\tHCI_INIT(hci_read_sync_train_params_sync),\n\t \n\tHCI_INIT(hci_write_sc_support_1_sync),\n\t \n\tHCI_INIT(hci_set_err_data_report_sync),\n\t{}\n};\n\n \nstatic int hci_le_set_write_def_data_len_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_le_write_def_data_len cp;\n\n\tif (!(hdev->le_features[0] & HCI_LE_DATA_LEN_EXT))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.tx_len = cpu_to_le16(hdev->le_max_tx_len);\n\tcp.tx_time = cpu_to_le16(hdev->le_max_tx_time);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_WRITE_DEF_DATA_LEN,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\n \nstatic int hci_le_set_default_phy_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_le_set_default_phy cp;\n\n\tif (!(hdev->commands[35] & 0x20)) {\n\t\t \n\t\thdev->le_tx_def_phys = HCI_LE_SET_PHY_1M;\n\t\thdev->le_rx_def_phys = HCI_LE_SET_PHY_1M;\n\t\treturn 0;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.all_phys = 0x00;\n\tcp.tx_phys = HCI_LE_SET_PHY_1M;\n\tcp.rx_phys = HCI_LE_SET_PHY_1M;\n\n\t \n\tif (le_2m_capable(hdev)) {\n\t\tcp.tx_phys |= HCI_LE_SET_PHY_2M;\n\t\tcp.rx_phys |= HCI_LE_SET_PHY_2M;\n\t}\n\n\t \n\tif (le_coded_capable(hdev)) {\n\t\tcp.tx_phys |= HCI_LE_SET_PHY_CODED;\n\t\tcp.rx_phys |= HCI_LE_SET_PHY_CODED;\n\t}\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_DEFAULT_PHY,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic const struct hci_init_stage le_init4[] = {\n\t \n\tHCI_INIT(hci_le_set_write_def_data_len_sync),\n\t \n\tHCI_INIT(hci_le_set_default_phy_sync),\n\t{}\n};\n\nstatic int hci_init4_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\terr = hci_init_stage_sync(hdev, hci_init4);\n\tif (err)\n\t\treturn err;\n\n\tif (lmp_le_capable(hdev))\n\t\treturn hci_init_stage_sync(hdev, le_init4);\n\n\treturn 0;\n}\n\nstatic int hci_init_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\terr = hci_init1_sync(hdev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (hci_dev_test_flag(hdev, HCI_SETUP))\n\t\thci_debugfs_create_basic(hdev);\n\n\terr = hci_init2_sync(hdev);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (hdev->dev_type != HCI_PRIMARY)\n\t\treturn 0;\n\n\terr = hci_init3_sync(hdev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = hci_init4_sync(hdev);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_SETUP) &&\n\t    !hci_dev_test_flag(hdev, HCI_CONFIG))\n\t\treturn 0;\n\n\tif (hci_dev_test_and_set_flag(hdev, HCI_DEBUGFS_CREATED))\n\t\treturn 0;\n\n\thci_debugfs_create_common(hdev);\n\n\tif (lmp_bredr_capable(hdev))\n\t\thci_debugfs_create_bredr(hdev);\n\n\tif (lmp_le_capable(hdev))\n\t\thci_debugfs_create_le(hdev);\n\n\treturn 0;\n}\n\n#define HCI_QUIRK_BROKEN(_quirk, _desc) { HCI_QUIRK_BROKEN_##_quirk, _desc }\n\nstatic const struct {\n\tunsigned long quirk;\n\tconst char *desc;\n} hci_broken_table[] = {\n\tHCI_QUIRK_BROKEN(LOCAL_COMMANDS,\n\t\t\t \"HCI Read Local Supported Commands not supported\"),\n\tHCI_QUIRK_BROKEN(STORED_LINK_KEY,\n\t\t\t \"HCI Delete Stored Link Key command is advertised, \"\n\t\t\t \"but not supported.\"),\n\tHCI_QUIRK_BROKEN(ERR_DATA_REPORTING,\n\t\t\t \"HCI Read Default Erroneous Data Reporting command is \"\n\t\t\t \"advertised, but not supported.\"),\n\tHCI_QUIRK_BROKEN(READ_TRANSMIT_POWER,\n\t\t\t \"HCI Read Transmit Power Level command is advertised, \"\n\t\t\t \"but not supported.\"),\n\tHCI_QUIRK_BROKEN(FILTER_CLEAR_ALL,\n\t\t\t \"HCI Set Event Filter command not supported.\"),\n\tHCI_QUIRK_BROKEN(ENHANCED_SETUP_SYNC_CONN,\n\t\t\t \"HCI Enhanced Setup Synchronous Connection command is \"\n\t\t\t \"advertised, but not supported.\"),\n\tHCI_QUIRK_BROKEN(SET_RPA_TIMEOUT,\n\t\t\t \"HCI LE Set Random Private Address Timeout command is \"\n\t\t\t \"advertised, but not supported.\"),\n\tHCI_QUIRK_BROKEN(LE_CODED,\n\t\t\t \"HCI LE Coded PHY feature bit is set, \"\n\t\t\t \"but its usage is not supported.\")\n};\n\n \nstatic int hci_dev_setup_sync(struct hci_dev *hdev)\n{\n\tint ret = 0;\n\tbool invalid_bdaddr;\n\tsize_t i;\n\n\tif (!hci_dev_test_flag(hdev, HCI_SETUP) &&\n\t    !test_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks))\n\t\treturn 0;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_sock_dev_event(hdev, HCI_DEV_SETUP);\n\n\tif (hdev->setup)\n\t\tret = hdev->setup(hdev);\n\n\tfor (i = 0; i < ARRAY_SIZE(hci_broken_table); i++) {\n\t\tif (test_bit(hci_broken_table[i].quirk, &hdev->quirks))\n\t\t\tbt_dev_warn(hdev, \"%s\", hci_broken_table[i].desc);\n\t}\n\n\t \n\tinvalid_bdaddr = test_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks) ||\n\t\t\t test_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks);\n\tif (!ret) {\n\t\tif (test_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks) &&\n\t\t    !bacmp(&hdev->public_addr, BDADDR_ANY))\n\t\t\thci_dev_get_bd_addr_from_property(hdev);\n\n\t\tif (invalid_bdaddr && bacmp(&hdev->public_addr, BDADDR_ANY) &&\n\t\t    hdev->set_bdaddr) {\n\t\t\tret = hdev->set_bdaddr(hdev, &hdev->public_addr);\n\t\t\tif (!ret)\n\t\t\t\tinvalid_bdaddr = false;\n\t\t}\n\t}\n\n\t \n\tif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) ||\n\t    invalid_bdaddr)\n\t\thci_dev_set_flag(hdev, HCI_UNCONFIGURED);\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED))\n\t\treturn hci_unconf_init_sync(hdev);\n\n\treturn ret;\n}\n\n \nstatic int hci_dev_init_sync(struct hci_dev *hdev)\n{\n\tint ret;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tatomic_set(&hdev->cmd_cnt, 1);\n\tset_bit(HCI_INIT, &hdev->flags);\n\n\tret = hci_dev_setup_sync(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_CONFIG)) {\n\t\t \n\t\tif (bacmp(&hdev->public_addr, BDADDR_ANY) &&\n\t\t    hdev->set_bdaddr)\n\t\t\tret = hdev->set_bdaddr(hdev, &hdev->public_addr);\n\t\telse\n\t\t\tret = -EADDRNOTAVAIL;\n\t}\n\n\tif (!ret) {\n\t\tif (!hci_dev_test_flag(hdev, HCI_UNCONFIGURED) &&\n\t\t    !hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\n\t\t\tret = hci_init_sync(hdev);\n\t\t\tif (!ret && hdev->post_init)\n\t\t\t\tret = hdev->post_init(hdev);\n\t\t}\n\t}\n\n\t \n\tif (test_bit(HCI_QUIRK_NON_PERSISTENT_DIAG, &hdev->quirks) &&\n\t    !hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&\n\t    hci_dev_test_flag(hdev, HCI_VENDOR_DIAG) && hdev->set_diag)\n\t\tret = hdev->set_diag(hdev, true);\n\n\tif (!hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\n\t\tmsft_do_open(hdev);\n\t\taosp_do_open(hdev);\n\t}\n\n\tclear_bit(HCI_INIT, &hdev->flags);\n\n\treturn ret;\n}\n\nint hci_dev_open_sync(struct hci_dev *hdev)\n{\n\tint ret;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tif (hci_dev_test_flag(hdev, HCI_UNREGISTER)) {\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (!hci_dev_test_flag(hdev, HCI_SETUP) &&\n\t    !hci_dev_test_flag(hdev, HCI_CONFIG)) {\n\t\t \n\t\tif (hci_dev_test_flag(hdev, HCI_RFKILLED)) {\n\t\t\tret = -ERFKILL;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (!hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&\n\t\t    hdev->dev_type == HCI_PRIMARY &&\n\t\t    !bacmp(&hdev->bdaddr, BDADDR_ANY) &&\n\t\t    !bacmp(&hdev->static_addr, BDADDR_ANY)) {\n\t\t\tret = -EADDRNOTAVAIL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (test_bit(HCI_UP, &hdev->flags)) {\n\t\tret = -EALREADY;\n\t\tgoto done;\n\t}\n\n\tif (hdev->open(hdev)) {\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\thci_devcd_reset(hdev);\n\n\tset_bit(HCI_RUNNING, &hdev->flags);\n\thci_sock_dev_event(hdev, HCI_DEV_OPEN);\n\n\tret = hci_dev_init_sync(hdev);\n\tif (!ret) {\n\t\thci_dev_hold(hdev);\n\t\thci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\n\t\thci_adv_instances_set_rpa_expired(hdev, true);\n\t\tset_bit(HCI_UP, &hdev->flags);\n\t\thci_sock_dev_event(hdev, HCI_DEV_UP);\n\t\thci_leds_update_powered(hdev, true);\n\t\tif (!hci_dev_test_flag(hdev, HCI_SETUP) &&\n\t\t    !hci_dev_test_flag(hdev, HCI_CONFIG) &&\n\t\t    !hci_dev_test_flag(hdev, HCI_UNCONFIGURED) &&\n\t\t    !hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&\n\t\t    hci_dev_test_flag(hdev, HCI_MGMT) &&\n\t\t    hdev->dev_type == HCI_PRIMARY) {\n\t\t\tret = hci_powered_update_sync(hdev);\n\t\t\tmgmt_power_on(hdev, ret);\n\t\t}\n\t} else {\n\t\t \n\t\tflush_work(&hdev->tx_work);\n\n\t\t \n\t\tflush_work(&hdev->rx_work);\n\t\tflush_work(&hdev->cmd_work);\n\n\t\tskb_queue_purge(&hdev->cmd_q);\n\t\tskb_queue_purge(&hdev->rx_q);\n\n\t\tif (hdev->flush)\n\t\t\thdev->flush(hdev);\n\n\t\tif (hdev->sent_cmd) {\n\t\t\tcancel_delayed_work_sync(&hdev->cmd_timer);\n\t\t\tkfree_skb(hdev->sent_cmd);\n\t\t\thdev->sent_cmd = NULL;\n\t\t}\n\n\t\tclear_bit(HCI_RUNNING, &hdev->flags);\n\t\thci_sock_dev_event(hdev, HCI_DEV_CLOSE);\n\n\t\thdev->close(hdev);\n\t\thdev->flags &= BIT(HCI_RAW);\n\t}\n\ndone:\n\treturn ret;\n}\n\n \nstatic void hci_pend_le_actions_clear(struct hci_dev *hdev)\n{\n\tstruct hci_conn_params *p;\n\n\tlist_for_each_entry(p, &hdev->le_conn_params, list) {\n\t\thci_pend_le_list_del_init(p);\n\t\tif (p->conn) {\n\t\t\thci_conn_drop(p->conn);\n\t\t\thci_conn_put(p->conn);\n\t\t\tp->conn = NULL;\n\t\t}\n\t}\n\n\tBT_DBG(\"All LE pending actions cleared\");\n}\n\nstatic int hci_dev_shutdown(struct hci_dev *hdev)\n{\n\tint err = 0;\n\t \n\tbool was_userchannel =\n\t\thci_dev_test_and_clear_flag(hdev, HCI_USER_CHANNEL);\n\n\tif (!hci_dev_test_flag(hdev, HCI_UNREGISTER) &&\n\t    test_bit(HCI_UP, &hdev->flags)) {\n\t\t \n\t\tif (hdev->shutdown)\n\t\t\terr = hdev->shutdown(hdev);\n\t}\n\n\tif (was_userchannel)\n\t\thci_dev_set_flag(hdev, HCI_USER_CHANNEL);\n\n\treturn err;\n}\n\nint hci_dev_close_sync(struct hci_dev *hdev)\n{\n\tbool auto_off;\n\tint err = 0;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tcancel_delayed_work(&hdev->power_off);\n\tcancel_delayed_work(&hdev->ncmd_timer);\n\tcancel_delayed_work(&hdev->le_scan_disable);\n\tcancel_delayed_work(&hdev->le_scan_restart);\n\n\thci_request_cancel_all(hdev);\n\n\tif (hdev->adv_instance_timeout) {\n\t\tcancel_delayed_work_sync(&hdev->adv_instance_expire);\n\t\thdev->adv_instance_timeout = 0;\n\t}\n\n\terr = hci_dev_shutdown(hdev);\n\n\tif (!test_and_clear_bit(HCI_UP, &hdev->flags)) {\n\t\tcancel_delayed_work_sync(&hdev->cmd_timer);\n\t\treturn err;\n\t}\n\n\thci_leds_update_powered(hdev, false);\n\n\t \n\tflush_work(&hdev->tx_work);\n\tflush_work(&hdev->rx_work);\n\n\tif (hdev->discov_timeout > 0) {\n\t\thdev->discov_timeout = 0;\n\t\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\t\thci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\t}\n\n\tif (hci_dev_test_and_clear_flag(hdev, HCI_SERVICE_CACHE))\n\t\tcancel_delayed_work(&hdev->service_cache);\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT)) {\n\t\tstruct adv_info *adv_instance;\n\n\t\tcancel_delayed_work_sync(&hdev->rpa_expired);\n\n\t\tlist_for_each_entry(adv_instance, &hdev->adv_instances, list)\n\t\t\tcancel_delayed_work_sync(&adv_instance->rpa_expired_cb);\n\t}\n\n\t \n\tdrain_workqueue(hdev->workqueue);\n\n\thci_dev_lock(hdev);\n\n\thci_discovery_set_state(hdev, DISCOVERY_STOPPED);\n\n\tauto_off = hci_dev_test_and_clear_flag(hdev, HCI_AUTO_OFF);\n\n\tif (!auto_off && hdev->dev_type == HCI_PRIMARY &&\n\t    !hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&\n\t    hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t__mgmt_power_off(hdev);\n\n\thci_inquiry_cache_flush(hdev);\n\thci_pend_le_actions_clear(hdev);\n\thci_conn_hash_flush(hdev);\n\t \n\tsmp_unregister(hdev);\n\thci_dev_unlock(hdev);\n\n\thci_sock_dev_event(hdev, HCI_DEV_DOWN);\n\n\tif (!hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\n\t\taosp_do_close(hdev);\n\t\tmsft_do_close(hdev);\n\t}\n\n\tif (hdev->flush)\n\t\thdev->flush(hdev);\n\n\t \n\tskb_queue_purge(&hdev->cmd_q);\n\tatomic_set(&hdev->cmd_cnt, 1);\n\tif (test_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks) &&\n\t    !auto_off && !hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\n\t\tset_bit(HCI_INIT, &hdev->flags);\n\t\thci_reset_sync(hdev);\n\t\tclear_bit(HCI_INIT, &hdev->flags);\n\t}\n\n\t \n\tflush_work(&hdev->cmd_work);\n\n\t \n\tskb_queue_purge(&hdev->rx_q);\n\tskb_queue_purge(&hdev->cmd_q);\n\tskb_queue_purge(&hdev->raw_q);\n\n\t \n\tif (hdev->sent_cmd) {\n\t\tcancel_delayed_work_sync(&hdev->cmd_timer);\n\t\tkfree_skb(hdev->sent_cmd);\n\t\thdev->sent_cmd = NULL;\n\t}\n\n\tclear_bit(HCI_RUNNING, &hdev->flags);\n\thci_sock_dev_event(hdev, HCI_DEV_CLOSE);\n\n\t \n\thdev->close(hdev);\n\n\t \n\thdev->flags &= BIT(HCI_RAW);\n\thci_dev_clear_volatile_flags(hdev);\n\n\t \n\thdev->amp_status = AMP_STATUS_POWERED_DOWN;\n\n\tmemset(hdev->eir, 0, sizeof(hdev->eir));\n\tmemset(hdev->dev_class, 0, sizeof(hdev->dev_class));\n\tbacpy(&hdev->random_addr, BDADDR_ANY);\n\thci_codec_list_clear(&hdev->local_codecs);\n\n\thci_dev_put(hdev);\n\treturn err;\n}\n\n \nstatic int hci_power_on_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\tif (test_bit(HCI_UP, &hdev->flags) &&\n\t    hci_dev_test_flag(hdev, HCI_MGMT) &&\n\t    hci_dev_test_and_clear_flag(hdev, HCI_AUTO_OFF)) {\n\t\tcancel_delayed_work(&hdev->power_off);\n\t\treturn hci_powered_update_sync(hdev);\n\t}\n\n\terr = hci_dev_open_sync(hdev);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_RFKILLED) ||\n\t    hci_dev_test_flag(hdev, HCI_UNCONFIGURED) ||\n\t    (hdev->dev_type == HCI_PRIMARY &&\n\t     !bacmp(&hdev->bdaddr, BDADDR_ANY) &&\n\t     !bacmp(&hdev->static_addr, BDADDR_ANY))) {\n\t\thci_dev_clear_flag(hdev, HCI_AUTO_OFF);\n\t\thci_dev_close_sync(hdev);\n\t} else if (hci_dev_test_flag(hdev, HCI_AUTO_OFF)) {\n\t\tqueue_delayed_work(hdev->req_workqueue, &hdev->power_off,\n\t\t\t\t   HCI_AUTO_OFF_TIMEOUT);\n\t}\n\n\tif (hci_dev_test_and_clear_flag(hdev, HCI_SETUP)) {\n\t\t \n\t\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED))\n\t\t\tset_bit(HCI_RAW, &hdev->flags);\n\n\t\t \n\t\tmgmt_index_added(hdev);\n\t} else if (hci_dev_test_and_clear_flag(hdev, HCI_CONFIG)) {\n\t\t \n\t\tif (!hci_dev_test_flag(hdev, HCI_UNCONFIGURED))\n\t\t\tclear_bit(HCI_RAW, &hdev->flags);\n\n\t\t \n\t\tmgmt_index_added(hdev);\n\t}\n\n\treturn 0;\n}\n\nstatic int hci_remote_name_cancel_sync(struct hci_dev *hdev, bdaddr_t *addr)\n{\n\tstruct hci_cp_remote_name_req_cancel cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.bdaddr, addr);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_REMOTE_NAME_REQ_CANCEL,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_stop_discovery_sync(struct hci_dev *hdev)\n{\n\tstruct discovery_state *d = &hdev->discovery;\n\tstruct inquiry_entry *e;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"state %u\", hdev->discovery.state);\n\n\tif (d->state == DISCOVERY_FINDING || d->state == DISCOVERY_STOPPING) {\n\t\tif (test_bit(HCI_INQUIRY, &hdev->flags)) {\n\t\t\terr = __hci_cmd_sync_status(hdev, HCI_OP_INQUIRY_CANCEL,\n\t\t\t\t\t\t    0, NULL, HCI_CMD_TIMEOUT);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (hci_dev_test_flag(hdev, HCI_LE_SCAN)) {\n\t\t\tcancel_delayed_work(&hdev->le_scan_disable);\n\t\t\tcancel_delayed_work(&hdev->le_scan_restart);\n\n\t\t\terr = hci_scan_disable_sync(hdev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t} else {\n\t\terr = hci_scan_disable_sync(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (use_ll_privacy(hdev))\n\t\thci_resume_advertising_sync(hdev);\n\n\t \n\tif (d->type == DISCOV_TYPE_LE)\n\t\treturn 0;\n\n\tif (d->state == DISCOVERY_RESOLVING || d->state == DISCOVERY_STOPPING) {\n\t\te = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY,\n\t\t\t\t\t\t     NAME_PENDING);\n\t\tif (!e)\n\t\t\treturn 0;\n\n\t\treturn hci_remote_name_cancel_sync(hdev, &e->data.bdaddr);\n\t}\n\n\treturn 0;\n}\n\nstatic int hci_disconnect_phy_link_sync(struct hci_dev *hdev, u16 handle,\n\t\t\t\t\tu8 reason)\n{\n\tstruct hci_cp_disconn_phy_link cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.phy_handle = HCI_PHY_HANDLE(handle);\n\tcp.reason = reason;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_DISCONN_PHY_LINK,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_disconnect_sync(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t       u8 reason)\n{\n\tstruct hci_cp_disconnect cp;\n\n\tif (conn->type == AMP_LINK)\n\t\treturn hci_disconnect_phy_link_sync(hdev, conn->handle, reason);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.handle = cpu_to_le16(conn->handle);\n\tcp.reason = reason;\n\n\t \n\tif (reason != HCI_ERROR_REMOTE_POWER_OFF)\n\t\treturn __hci_cmd_sync_status_sk(hdev, HCI_OP_DISCONNECT,\n\t\t\t\t\t\tsizeof(cp), &cp,\n\t\t\t\t\t\tHCI_EV_DISCONN_COMPLETE,\n\t\t\t\t\t\tHCI_CMD_TIMEOUT, NULL);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_le_connect_cancel_sync(struct hci_dev *hdev,\n\t\t\t\t      struct hci_conn *conn, u8 reason)\n{\n\t \n\tif (test_bit(HCI_CONN_SCANNING, &conn->flags))\n\t\treturn reason;\n\n\tif (conn->role == HCI_ROLE_SLAVE ||\n\t    test_and_set_bit(HCI_CONN_CANCEL, &conn->flags))\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_CREATE_CONN_CANCEL,\n\t\t\t\t     0, NULL, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_connect_cancel_sync(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t\t   u8 reason)\n{\n\tif (conn->type == LE_LINK)\n\t\treturn hci_le_connect_cancel_sync(hdev, conn, reason);\n\n\tif (conn->type == ISO_LINK) {\n\t\t \n\t\tif (test_bit(HCI_CONN_CREATE_CIS, &conn->flags))\n\t\t\treturn hci_disconnect_sync(hdev, conn, reason);\n\n\t\t \n\t\tif (bacmp(&conn->dst, BDADDR_ANY))\n\t\t\treturn HCI_ERROR_LOCAL_HOST_TERM;\n\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (hdev->hci_ver < BLUETOOTH_VER_1_2)\n\t\treturn 0;\n\n\t \n\tif (reason != HCI_ERROR_REMOTE_POWER_OFF)\n\t\treturn __hci_cmd_sync_status_sk(hdev, HCI_OP_CREATE_CONN_CANCEL,\n\t\t\t\t\t\t6, &conn->dst,\n\t\t\t\t\t\tHCI_EV_CONN_COMPLETE,\n\t\t\t\t\t\tHCI_CMD_TIMEOUT, NULL);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_CREATE_CONN_CANCEL,\n\t\t\t\t     6, &conn->dst, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_reject_sco_sync(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t       u8 reason)\n{\n\tstruct hci_cp_reject_sync_conn_req cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.bdaddr, &conn->dst);\n\tcp.reason = reason;\n\n\t \n\tif (reason < 0x0d || reason > 0x0f)\n\t\tcp.reason = HCI_ERROR_REJ_LIMITED_RESOURCES;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_REJECT_SYNC_CONN_REQ,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_le_reject_cis_sync(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t\t  u8 reason)\n{\n\tstruct hci_cp_le_reject_cis cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.handle = cpu_to_le16(conn->handle);\n\tcp.reason = reason;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_REJECT_CIS,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_reject_conn_sync(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t\tu8 reason)\n{\n\tstruct hci_cp_reject_conn_req cp;\n\n\tif (conn->type == ISO_LINK)\n\t\treturn hci_le_reject_cis_sync(hdev, conn, reason);\n\n\tif (conn->type == SCO_LINK || conn->type == ESCO_LINK)\n\t\treturn hci_reject_sco_sync(hdev, conn, reason);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.bdaddr, &conn->dst);\n\tcp.reason = reason;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_REJECT_CONN_REQ,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_abort_conn_sync(struct hci_dev *hdev, struct hci_conn *conn, u8 reason)\n{\n\tint err = 0;\n\tu16 handle = conn->handle;\n\tbool disconnect = false;\n\tstruct hci_conn *c;\n\n\tswitch (conn->state) {\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\t\terr = hci_disconnect_sync(hdev, conn, reason);\n\t\tbreak;\n\tcase BT_CONNECT:\n\t\terr = hci_connect_cancel_sync(hdev, conn, reason);\n\t\tbreak;\n\tcase BT_CONNECT2:\n\t\terr = hci_reject_conn_sync(hdev, conn, reason);\n\t\tbreak;\n\tcase BT_OPEN:\n\t\thci_dev_lock(hdev);\n\n\t\t \n\t\tif (test_and_clear_bit(HCI_CONN_BIG_SYNC_FAILED, &conn->flags) ||\n\t\t    test_and_clear_bit(HCI_CONN_PA_SYNC_FAILED, &conn->flags)) {\n\t\t\thci_conn_failed(conn, reason);\n\t\t} else if (test_bit(HCI_CONN_PA_SYNC, &conn->flags) ||\n\t\t\t   test_bit(HCI_CONN_BIG_SYNC, &conn->flags)) {\n\t\t\tconn->state = BT_CLOSED;\n\t\t\thci_disconn_cfm(conn, reason);\n\t\t\thci_conn_del(conn);\n\t\t}\n\n\t\thci_dev_unlock(hdev);\n\t\treturn 0;\n\tcase BT_BOUND:\n\t\tbreak;\n\tdefault:\n\t\tdisconnect = true;\n\t\tbreak;\n\t}\n\n\thci_dev_lock(hdev);\n\n\t \n\tc = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (!c || c != conn) {\n\t\terr = 0;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (disconnect) {\n\t\tconn->state = BT_CLOSED;\n\t\thci_disconn_cfm(conn, reason);\n\t\thci_conn_del(conn);\n\t} else {\n\t\thci_conn_failed(conn, reason);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int hci_disconnect_all_sync(struct hci_dev *hdev, u8 reason)\n{\n\tstruct list_head *head = &hdev->conn_hash.list;\n\tstruct hci_conn *conn;\n\n\trcu_read_lock();\n\twhile ((conn = list_first_or_null_rcu(head, struct hci_conn, list))) {\n\t\t \n\t\tconn = hci_conn_get(conn);\n\t\trcu_read_unlock();\n\t\t \n\t\thci_abort_conn_sync(hdev, conn, reason);\n\t\thci_conn_put(conn);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\n \nstatic int hci_power_off_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\t \n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn 0;\n\n\tif (test_bit(HCI_ISCAN, &hdev->flags) ||\n\t    test_bit(HCI_PSCAN, &hdev->flags)) {\n\t\terr = hci_write_scan_enable_sync(hdev, 0x00);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = hci_clear_adv_sync(hdev, NULL, false);\n\tif (err)\n\t\treturn err;\n\n\terr = hci_stop_discovery_sync(hdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = hci_disconnect_all_sync(hdev, HCI_ERROR_REMOTE_POWER_OFF);\n\tif (err)\n\t\treturn err;\n\n\treturn hci_dev_close_sync(hdev);\n}\n\nint hci_set_powered_sync(struct hci_dev *hdev, u8 val)\n{\n\tif (val)\n\t\treturn hci_power_on_sync(hdev);\n\n\treturn hci_power_off_sync(hdev);\n}\n\nstatic int hci_write_iac_sync(struct hci_dev *hdev)\n{\n\tstruct hci_cp_write_current_iac_lap cp;\n\n\tif (!hci_dev_test_flag(hdev, HCI_DISCOVERABLE))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tif (hci_dev_test_flag(hdev, HCI_LIMITED_DISCOVERABLE)) {\n\t\t \n\t\tcp.num_iac = min_t(u8, hdev->num_iac, 2);\n\t\tcp.iac_lap[0] = 0x00;\t \n\t\tcp.iac_lap[1] = 0x8b;\n\t\tcp.iac_lap[2] = 0x9e;\n\t\tcp.iac_lap[3] = 0x33;\t \n\t\tcp.iac_lap[4] = 0x8b;\n\t\tcp.iac_lap[5] = 0x9e;\n\t} else {\n\t\t \n\t\tcp.num_iac = 1;\n\t\tcp.iac_lap[0] = 0x33;\t \n\t\tcp.iac_lap[1] = 0x8b;\n\t\tcp.iac_lap[2] = 0x9e;\n\t}\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_WRITE_CURRENT_IAC_LAP,\n\t\t\t\t     (cp.num_iac * 3) + 1, &cp,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\nint hci_update_discoverable_sync(struct hci_dev *hdev)\n{\n\tint err = 0;\n\n\tif (hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\n\t\terr = hci_write_iac_sync(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = hci_update_scan_sync(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = hci_update_class_sync(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING)) {\n\t\terr = hci_update_adv_data_sync(hdev, 0x00);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (hci_dev_test_flag(hdev, HCI_LIMITED_PRIVACY)) {\n\t\t\tif (ext_adv_capable(hdev))\n\t\t\t\terr = hci_start_ext_adv_sync(hdev, 0x00);\n\t\t\telse\n\t\t\t\terr = hci_enable_advertising_sync(hdev);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int update_discoverable_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_update_discoverable_sync(hdev);\n}\n\nint hci_update_discoverable(struct hci_dev *hdev)\n{\n\t \n\tif (hdev_is_powered(hdev) &&\n\t    hci_dev_test_flag(hdev, HCI_ADVERTISING) &&\n\t    hci_dev_test_flag(hdev, HCI_DISCOVERABLE) &&\n\t    hci_dev_test_flag(hdev, HCI_LIMITED_PRIVACY))\n\t\treturn hci_cmd_sync_queue(hdev, update_discoverable_sync, NULL,\n\t\t\t\t\t  NULL);\n\n\treturn 0;\n}\n\nint hci_update_connectable_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\terr = hci_update_scan_sync(hdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\terr = hci_update_adv_data_sync(hdev, hdev->cur_adv_instance);\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING) ||\n\t    !list_empty(&hdev->adv_instances)) {\n\t\tif (ext_adv_capable(hdev))\n\t\t\terr = hci_start_ext_adv_sync(hdev,\n\t\t\t\t\t\t     hdev->cur_adv_instance);\n\t\telse\n\t\t\terr = hci_enable_advertising_sync(hdev);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn hci_update_passive_scan_sync(hdev);\n}\n\nstatic int hci_inquiry_sync(struct hci_dev *hdev, u8 length)\n{\n\tconst u8 giac[3] = { 0x33, 0x8b, 0x9e };\n\tconst u8 liac[3] = { 0x00, 0x8b, 0x9e };\n\tstruct hci_cp_inquiry cp;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tif (hci_dev_test_flag(hdev, HCI_INQUIRY))\n\t\treturn 0;\n\n\thci_dev_lock(hdev);\n\thci_inquiry_cache_flush(hdev);\n\thci_dev_unlock(hdev);\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tif (hdev->discovery.limited)\n\t\tmemcpy(&cp.lap, liac, sizeof(cp.lap));\n\telse\n\t\tmemcpy(&cp.lap, giac, sizeof(cp.lap));\n\n\tcp.length = length;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_INQUIRY,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nstatic int hci_active_scan_sync(struct hci_dev *hdev, uint16_t interval)\n{\n\tu8 own_addr_type;\n\t \n\tu8 filter_policy = 0x00;\n\t \n\tu8 filter_dup = LE_SCAN_FILTER_DUP_ENABLE;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\t \n\terr = hci_scan_disable_sync(hdev);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Unable to disable scanning: %d\", err);\n\t\treturn err;\n\t}\n\n\tcancel_interleave_scan(hdev);\n\n\t \n\terr = hci_pause_addr_resolution(hdev);\n\tif (err)\n\t\tgoto failed;\n\n\t \n\terr = hci_update_random_address_sync(hdev, true, scan_use_rpa(hdev),\n\t\t\t\t\t     &own_addr_type);\n\tif (err < 0)\n\t\town_addr_type = ADDR_LE_DEV_PUBLIC;\n\n\tif (hci_is_adv_monitoring(hdev)) {\n\t\t \n\t\tfilter_dup = LE_SCAN_FILTER_DUP_DISABLE;\n\t}\n\n\terr = hci_start_scan_sync(hdev, LE_SCAN_ACTIVE, interval,\n\t\t\t\t  hdev->le_scan_window_discovery,\n\t\t\t\t  own_addr_type, filter_policy, filter_dup);\n\tif (!err)\n\t\treturn err;\n\nfailed:\n\t \n\tif (use_ll_privacy(hdev))\n\t\thci_resume_advertising_sync(hdev);\n\n\t \n\thci_update_passive_scan_sync(hdev);\n\treturn err;\n}\n\nstatic int hci_start_interleaved_discovery_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\terr = hci_active_scan_sync(hdev, hdev->le_scan_int_discovery * 2);\n\tif (err)\n\t\treturn err;\n\n\treturn hci_inquiry_sync(hdev, DISCOV_BREDR_INQUIRY_LEN);\n}\n\nint hci_start_discovery_sync(struct hci_dev *hdev)\n{\n\tunsigned long timeout;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"type %u\", hdev->discovery.type);\n\n\tswitch (hdev->discovery.type) {\n\tcase DISCOV_TYPE_BREDR:\n\t\treturn hci_inquiry_sync(hdev, DISCOV_BREDR_INQUIRY_LEN);\n\tcase DISCOV_TYPE_INTERLEAVED:\n\t\t \n\t\tif (test_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY,\n\t\t\t     &hdev->quirks)) {\n\t\t\ttimeout = msecs_to_jiffies(DISCOV_LE_TIMEOUT);\n\t\t\t \n\t\t\terr = hci_start_interleaved_discovery_sync(hdev);\n\t\t\tbreak;\n\t\t}\n\n\t\ttimeout = msecs_to_jiffies(hdev->discov_interleaved_timeout);\n\t\terr = hci_active_scan_sync(hdev, hdev->le_scan_int_discovery);\n\t\tbreak;\n\tcase DISCOV_TYPE_LE:\n\t\ttimeout = msecs_to_jiffies(DISCOV_LE_TIMEOUT);\n\t\terr = hci_active_scan_sync(hdev, hdev->le_scan_int_discovery);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tbt_dev_dbg(hdev, \"timeout %u ms\", jiffies_to_msecs(timeout));\n\n\t \n\tif (test_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks) &&\n\t    hdev->discovery.result_filtering) {\n\t\thdev->discovery.scan_start = jiffies;\n\t\thdev->discovery.scan_duration = timeout;\n\t}\n\n\tqueue_delayed_work(hdev->req_workqueue, &hdev->le_scan_disable,\n\t\t\t   timeout);\n\treturn 0;\n}\n\nstatic void hci_suspend_monitor_sync(struct hci_dev *hdev)\n{\n\tswitch (hci_get_adv_monitor_offload_ext(hdev)) {\n\tcase HCI_ADV_MONITOR_EXT_MSFT:\n\t\tmsft_suspend_sync(hdev);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nstatic int hci_pause_discovery_sync(struct hci_dev *hdev)\n{\n\tint old_state = hdev->discovery.state;\n\tint err;\n\n\t \n\tif (old_state == DISCOVERY_STOPPED || old_state == DISCOVERY_STOPPING ||\n\t    hdev->discovery_paused)\n\t\treturn 0;\n\n\thci_discovery_set_state(hdev, DISCOVERY_STOPPING);\n\terr = hci_stop_discovery_sync(hdev);\n\tif (err)\n\t\treturn err;\n\n\thdev->discovery_paused = true;\n\thdev->discovery_old_state = old_state;\n\thci_discovery_set_state(hdev, DISCOVERY_STOPPED);\n\n\treturn 0;\n}\n\nstatic int hci_update_event_filter_sync(struct hci_dev *hdev)\n{\n\tstruct bdaddr_list_with_flags *b;\n\tu8 scan = SCAN_DISABLED;\n\tbool scanning = test_bit(HCI_PSCAN, &hdev->flags);\n\tint err;\n\n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn 0;\n\n\t \n\tif (test_bit(HCI_QUIRK_BROKEN_FILTER_CLEAR_ALL, &hdev->quirks))\n\t\treturn 0;\n\n\t \n\thci_clear_event_filter_sync(hdev);\n\n\tlist_for_each_entry(b, &hdev->accept_list, list) {\n\t\tif (!(b->flags & HCI_CONN_FLAG_REMOTE_WAKEUP))\n\t\t\tcontinue;\n\n\t\tbt_dev_dbg(hdev, \"Adding event filters for %pMR\", &b->bdaddr);\n\n\t\terr =  hci_set_event_filter_sync(hdev, HCI_FLT_CONN_SETUP,\n\t\t\t\t\t\t HCI_CONN_SETUP_ALLOW_BDADDR,\n\t\t\t\t\t\t &b->bdaddr,\n\t\t\t\t\t\t HCI_CONN_SETUP_AUTO_ON);\n\t\tif (err)\n\t\t\tbt_dev_dbg(hdev, \"Failed to set event filter for %pMR\",\n\t\t\t\t   &b->bdaddr);\n\t\telse\n\t\t\tscan = SCAN_PAGE;\n\t}\n\n\tif (scan && !scanning)\n\t\thci_write_scan_enable_sync(hdev, scan);\n\telse if (!scan && scanning)\n\t\thci_write_scan_enable_sync(hdev, scan);\n\n\treturn 0;\n}\n\n \nstatic int hci_pause_scan_sync(struct hci_dev *hdev)\n{\n\tif (hdev->scanning_paused)\n\t\treturn 0;\n\n\t \n\tif (test_bit(HCI_PSCAN, &hdev->flags))\n\t\thci_write_scan_enable_sync(hdev, SCAN_DISABLED);\n\n\thci_scan_disable_sync(hdev);\n\n\thdev->scanning_paused = true;\n\n\treturn 0;\n}\n\n \nint hci_suspend_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\t \n\tif (hdev->suspended)\n\t\treturn 0;\n\n\t \n\thdev->suspended = true;\n\n\t \n\thci_pause_discovery_sync(hdev);\n\n\t \n\thci_pause_advertising_sync(hdev);\n\n\t \n\thci_suspend_monitor_sync(hdev);\n\n\t \n\thci_pause_scan_sync(hdev);\n\n\tif (hci_conn_count(hdev)) {\n\t\t \n\t\terr = hci_disconnect_all_sync(hdev, HCI_ERROR_REMOTE_POWER_OFF);\n\t\tif (err) {\n\t\t\t \n\t\t\thdev->suspend_state = BT_RUNNING;\n\t\t\thci_resume_sync(hdev);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\thci_set_event_mask_sync(hdev);\n\t}\n\n\t \n\tif (!hdev->wakeup || !hdev->wakeup(hdev)) {\n\t\thdev->suspend_state = BT_SUSPEND_DISCONNECT;\n\t\treturn 0;\n\t}\n\n\t \n\thdev->scanning_paused = false;\n\n\t \n\thci_update_event_filter_sync(hdev);\n\n\t \n\thci_update_passive_scan_sync(hdev);\n\n\t \n\thdev->scanning_paused = true;\n\n\thdev->suspend_state = BT_SUSPEND_CONFIGURE_WAKE;\n\n\treturn 0;\n}\n\n \nstatic int hci_resume_discovery_sync(struct hci_dev *hdev)\n{\n\tint err;\n\n\t \n\tif (!hdev->discovery_paused)\n\t\treturn 0;\n\n\thdev->discovery_paused = false;\n\n\thci_discovery_set_state(hdev, DISCOVERY_STARTING);\n\n\terr = hci_start_discovery_sync(hdev);\n\n\thci_discovery_set_state(hdev, err ? DISCOVERY_STOPPED :\n\t\t\t\tDISCOVERY_FINDING);\n\n\treturn err;\n}\n\nstatic void hci_resume_monitor_sync(struct hci_dev *hdev)\n{\n\tswitch (hci_get_adv_monitor_offload_ext(hdev)) {\n\tcase HCI_ADV_MONITOR_EXT_MSFT:\n\t\tmsft_resume_sync(hdev);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nstatic int hci_resume_scan_sync(struct hci_dev *hdev)\n{\n\tif (!hdev->scanning_paused)\n\t\treturn 0;\n\n\thdev->scanning_paused = false;\n\n\thci_update_scan_sync(hdev);\n\n\t \n\thci_update_passive_scan_sync(hdev);\n\n\treturn 0;\n}\n\n \nint hci_resume_sync(struct hci_dev *hdev)\n{\n\t \n\tif (!hdev->suspended)\n\t\treturn 0;\n\n\thdev->suspended = false;\n\n\t \n\thci_set_event_mask_sync(hdev);\n\n\t \n\thci_clear_event_filter_sync(hdev);\n\n\t \n\thci_resume_scan_sync(hdev);\n\n\t \n\thci_resume_monitor_sync(hdev);\n\n\t \n\thci_resume_advertising_sync(hdev);\n\n\t \n\thci_resume_discovery_sync(hdev);\n\n\treturn 0;\n}\n\nstatic bool conn_use_rpa(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\treturn hci_dev_test_flag(hdev, HCI_PRIVACY);\n}\n\nstatic int hci_le_ext_directed_advertising_sync(struct hci_dev *hdev,\n\t\t\t\t\t\tstruct hci_conn *conn)\n{\n\tstruct hci_cp_le_set_ext_adv_params cp;\n\tint err;\n\tbdaddr_t random_addr;\n\tu8 own_addr_type;\n\n\terr = hci_update_random_address_sync(hdev, false, conn_use_rpa(conn),\n\t\t\t\t\t     &own_addr_type);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = hci_get_random_address(hdev, false, conn_use_rpa(conn), NULL,\n\t\t\t\t     &own_addr_type, &random_addr);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tcp.evt_properties = cpu_to_le16(LE_LEGACY_ADV_DIRECT_IND);\n\tcp.channel_map = hdev->le_adv_channel_map;\n\tcp.tx_power = HCI_TX_POWER_INVALID;\n\tcp.primary_phy = HCI_ADV_PHY_1M;\n\tcp.secondary_phy = HCI_ADV_PHY_1M;\n\tcp.handle = 0x00;  \n\tcp.own_addr_type = own_addr_type;\n\tcp.peer_addr_type = conn->dst_type;\n\tbacpy(&cp.peer_addr, &conn->dst);\n\n\t \n\terr = hci_remove_ext_adv_instance_sync(hdev, cp.handle, NULL);\n\tif (err)\n\t\treturn err;\n\n\terr = __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_EXT_ADV_PARAMS,\n\t\t\t\t    sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (own_addr_type == ADDR_LE_DEV_RANDOM &&\n\t    bacmp(&random_addr, BDADDR_ANY) &&\n\t    bacmp(&random_addr, &hdev->random_addr)) {\n\t\terr = hci_set_adv_set_random_addr_sync(hdev, 0x00,\n\t\t\t\t\t\t       &random_addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn hci_enable_ext_advertising_sync(hdev, 0x00);\n}\n\nstatic int hci_le_directed_advertising_sync(struct hci_dev *hdev,\n\t\t\t\t\t    struct hci_conn *conn)\n{\n\tstruct hci_cp_le_set_adv_param cp;\n\tu8 status;\n\tu8 own_addr_type;\n\tu8 enable;\n\n\tif (ext_adv_capable(hdev))\n\t\treturn hci_le_ext_directed_advertising_sync(hdev, conn);\n\n\t \n\thci_dev_clear_flag(hdev, HCI_LE_ADV);\n\n\t \n\tstatus = hci_update_random_address_sync(hdev, false, conn_use_rpa(conn),\n\t\t\t\t\t\t&own_addr_type);\n\tif (status)\n\t\treturn status;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\t \n\tcp.min_interval = cpu_to_le16(0x0020);\n\tcp.max_interval = cpu_to_le16(0x0020);\n\n\tcp.type = LE_ADV_DIRECT_IND;\n\tcp.own_address_type = own_addr_type;\n\tcp.direct_addr_type = conn->dst_type;\n\tbacpy(&cp.direct_addr, &conn->dst);\n\tcp.channel_map = hdev->le_adv_channel_map;\n\n\tstatus = __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_ADV_PARAM,\n\t\t\t\t       sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n\tif (status)\n\t\treturn status;\n\n\tenable = 0x01;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_ADV_ENABLE,\n\t\t\t\t     sizeof(enable), &enable, HCI_CMD_TIMEOUT);\n}\n\nstatic void set_ext_conn_params(struct hci_conn *conn,\n\t\t\t\tstruct hci_cp_le_ext_conn_param *p)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tmemset(p, 0, sizeof(*p));\n\n\tp->scan_interval = cpu_to_le16(hdev->le_scan_int_connect);\n\tp->scan_window = cpu_to_le16(hdev->le_scan_window_connect);\n\tp->conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);\n\tp->conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);\n\tp->conn_latency = cpu_to_le16(conn->le_conn_latency);\n\tp->supervision_timeout = cpu_to_le16(conn->le_supv_timeout);\n\tp->min_ce_len = cpu_to_le16(0x0000);\n\tp->max_ce_len = cpu_to_le16(0x0000);\n}\n\nstatic int hci_le_ext_create_conn_sync(struct hci_dev *hdev,\n\t\t\t\t       struct hci_conn *conn, u8 own_addr_type)\n{\n\tstruct hci_cp_le_ext_create_conn *cp;\n\tstruct hci_cp_le_ext_conn_param *p;\n\tu8 data[sizeof(*cp) + sizeof(*p) * 3];\n\tu32 plen;\n\n\tcp = (void *)data;\n\tp = (void *)cp->data;\n\n\tmemset(cp, 0, sizeof(*cp));\n\n\tbacpy(&cp->peer_addr, &conn->dst);\n\tcp->peer_addr_type = conn->dst_type;\n\tcp->own_addr_type = own_addr_type;\n\n\tplen = sizeof(*cp);\n\n\tif (scan_1m(hdev)) {\n\t\tcp->phys |= LE_SCAN_PHY_1M;\n\t\tset_ext_conn_params(conn, p);\n\n\t\tp++;\n\t\tplen += sizeof(*p);\n\t}\n\n\tif (scan_2m(hdev)) {\n\t\tcp->phys |= LE_SCAN_PHY_2M;\n\t\tset_ext_conn_params(conn, p);\n\n\t\tp++;\n\t\tplen += sizeof(*p);\n\t}\n\n\tif (scan_coded(hdev)) {\n\t\tcp->phys |= LE_SCAN_PHY_CODED;\n\t\tset_ext_conn_params(conn, p);\n\n\t\tplen += sizeof(*p);\n\t}\n\n\treturn __hci_cmd_sync_status_sk(hdev, HCI_OP_LE_EXT_CREATE_CONN,\n\t\t\t\t\tplen, data,\n\t\t\t\t\tHCI_EV_LE_ENHANCED_CONN_COMPLETE,\n\t\t\t\t\tconn->conn_timeout, NULL);\n}\n\nint hci_le_create_conn_sync(struct hci_dev *hdev, struct hci_conn *conn)\n{\n\tstruct hci_cp_le_create_conn cp;\n\tstruct hci_conn_params *params;\n\tu8 own_addr_type;\n\tint err;\n\n\t \n\tif (conn->role == HCI_ROLE_SLAVE) {\n\t\t \n\t\tif (hci_dev_test_flag(hdev, HCI_LE_SCAN) &&\n\t\t    hdev->le_scan_type == LE_SCAN_ACTIVE &&\n\t\t    !hci_dev_test_flag(hdev, HCI_LE_SIMULTANEOUS_ROLES)) {\n\t\t\thci_conn_del(conn);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\thci_pause_advertising_sync(hdev);\n\n\t\terr = hci_le_directed_advertising_sync(hdev, conn);\n\t\tgoto done;\n\t}\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_SIMULTANEOUS_ROLES))\n\t\thci_pause_advertising_sync(hdev);\n\n\tparams = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);\n\tif (params) {\n\t\tconn->le_conn_min_interval = params->conn_min_interval;\n\t\tconn->le_conn_max_interval = params->conn_max_interval;\n\t\tconn->le_conn_latency = params->conn_latency;\n\t\tconn->le_supv_timeout = params->supervision_timeout;\n\t} else {\n\t\tconn->le_conn_min_interval = hdev->le_conn_min_interval;\n\t\tconn->le_conn_max_interval = hdev->le_conn_max_interval;\n\t\tconn->le_conn_latency = hdev->le_conn_latency;\n\t\tconn->le_supv_timeout = hdev->le_supv_timeout;\n\t}\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_LE_SCAN)) {\n\t\thci_scan_disable_sync(hdev);\n\t\thci_dev_set_flag(hdev, HCI_LE_SCAN_INTERRUPTED);\n\t}\n\n\t \n\terr = hci_update_random_address_sync(hdev, false, conn_use_rpa(conn),\n\t\t\t\t\t     &own_addr_type);\n\tif (err)\n\t\tgoto done;\n\n\tif (use_ext_conn(hdev)) {\n\t\terr = hci_le_ext_create_conn_sync(hdev, conn, own_addr_type);\n\t\tgoto done;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tcp.scan_interval = cpu_to_le16(hdev->le_scan_int_connect);\n\tcp.scan_window = cpu_to_le16(hdev->le_scan_window_connect);\n\n\tbacpy(&cp.peer_addr, &conn->dst);\n\tcp.peer_addr_type = conn->dst_type;\n\tcp.own_address_type = own_addr_type;\n\tcp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);\n\tcp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);\n\tcp.conn_latency = cpu_to_le16(conn->le_conn_latency);\n\tcp.supervision_timeout = cpu_to_le16(conn->le_supv_timeout);\n\tcp.min_ce_len = cpu_to_le16(0x0000);\n\tcp.max_ce_len = cpu_to_le16(0x0000);\n\n\t \n\terr = __hci_cmd_sync_status_sk(hdev, HCI_OP_LE_CREATE_CONN,\n\t\t\t\t       sizeof(cp), &cp,\n\t\t\t\t       use_enhanced_conn_complete(hdev) ?\n\t\t\t\t       HCI_EV_LE_ENHANCED_CONN_COMPLETE :\n\t\t\t\t       HCI_EV_LE_CONN_COMPLETE,\n\t\t\t\t       conn->conn_timeout, NULL);\n\ndone:\n\tif (err == -ETIMEDOUT)\n\t\thci_le_connect_cancel_sync(hdev, conn, 0x00);\n\n\t \n\thci_resume_advertising_sync(hdev);\n\treturn err;\n}\n\nint hci_le_create_cis_sync(struct hci_dev *hdev)\n{\n\tstruct {\n\t\tstruct hci_cp_le_create_cis cp;\n\t\tstruct hci_cis cis[0x1f];\n\t} cmd;\n\tstruct hci_conn *conn;\n\tu8 cig = BT_ISO_QOS_CIG_UNSET;\n\n\t \n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\thci_dev_lock(hdev);\n\n\trcu_read_lock();\n\n\t \n\tlist_for_each_entry_rcu(conn, &hdev->conn_hash.list, list) {\n\t\tif (test_bit(HCI_CONN_CREATE_CIS, &conn->flags))\n\t\t\tgoto done;\n\t}\n\n\t \n\tlist_for_each_entry_rcu(conn, &hdev->conn_hash.list, list) {\n\t\tstruct hci_conn *link;\n\n\t\tif (hci_conn_check_create_cis(conn))\n\t\t\tcontinue;\n\n\t\tcig = conn->iso_qos.ucast.cig;\n\n\t\tlist_for_each_entry_rcu(link, &hdev->conn_hash.list, list) {\n\t\t\tif (hci_conn_check_create_cis(link) > 0 &&\n\t\t\t    link->iso_qos.ucast.cig == cig &&\n\t\t\t    link->state != BT_CONNECTED) {\n\t\t\t\tcig = BT_ISO_QOS_CIG_UNSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cig != BT_ISO_QOS_CIG_UNSET)\n\t\t\tbreak;\n\t}\n\n\tif (cig == BT_ISO_QOS_CIG_UNSET)\n\t\tgoto done;\n\n\tlist_for_each_entry_rcu(conn, &hdev->conn_hash.list, list) {\n\t\tstruct hci_cis *cis = &cmd.cis[cmd.cp.num_cis];\n\n\t\tif (hci_conn_check_create_cis(conn) ||\n\t\t    conn->iso_qos.ucast.cig != cig)\n\t\t\tcontinue;\n\n\t\tset_bit(HCI_CONN_CREATE_CIS, &conn->flags);\n\t\tcis->acl_handle = cpu_to_le16(conn->parent->handle);\n\t\tcis->cis_handle = cpu_to_le16(conn->handle);\n\t\tcmd.cp.num_cis++;\n\n\t\tif (cmd.cp.num_cis >= ARRAY_SIZE(cmd.cis))\n\t\t\tbreak;\n\t}\n\ndone:\n\trcu_read_unlock();\n\n\thci_dev_unlock(hdev);\n\n\tif (!cmd.cp.num_cis)\n\t\treturn 0;\n\n\t \n\treturn __hci_cmd_sync_status_sk(hdev, HCI_OP_LE_CREATE_CIS,\n\t\t\t\t\tsizeof(cmd.cp) + sizeof(cmd.cis[0]) *\n\t\t\t\t\tcmd.cp.num_cis, &cmd,\n\t\t\t\t\tHCI_EVT_LE_CIS_ESTABLISHED,\n\t\t\t\t\tconn->conn_timeout, NULL);\n}\n\nint hci_le_remove_cig_sync(struct hci_dev *hdev, u8 handle)\n{\n\tstruct hci_cp_le_remove_cig cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.cig_id = handle;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_REMOVE_CIG, sizeof(cp),\n\t\t\t\t     &cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_le_big_terminate_sync(struct hci_dev *hdev, u8 handle)\n{\n\tstruct hci_cp_le_big_term_sync cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.handle = handle;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_BIG_TERM_SYNC,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_le_pa_terminate_sync(struct hci_dev *hdev, u16 handle)\n{\n\tstruct hci_cp_le_pa_term_sync cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.handle = cpu_to_le16(handle);\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_PA_TERM_SYNC,\n\t\t\t\t     sizeof(cp), &cp, HCI_CMD_TIMEOUT);\n}\n\nint hci_get_random_address(struct hci_dev *hdev, bool require_privacy,\n\t\t\t   bool use_rpa, struct adv_info *adv_instance,\n\t\t\t   u8 *own_addr_type, bdaddr_t *rand_addr)\n{\n\tint err;\n\n\tbacpy(rand_addr, BDADDR_ANY);\n\n\t \n\tif (use_rpa) {\n\t\t \n\t\tif (use_ll_privacy(hdev))\n\t\t\t*own_addr_type = ADDR_LE_DEV_RANDOM_RESOLVED;\n\t\telse\n\t\t\t*own_addr_type = ADDR_LE_DEV_RANDOM;\n\n\t\tif (adv_instance) {\n\t\t\tif (adv_rpa_valid(adv_instance))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (rpa_valid(hdev))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\terr = smp_generate_rpa(hdev, hdev->irk, &hdev->rpa);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"failed to generate new RPA\");\n\t\t\treturn err;\n\t\t}\n\n\t\tbacpy(rand_addr, &hdev->rpa);\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (require_privacy) {\n\t\tbdaddr_t nrpa;\n\n\t\twhile (true) {\n\t\t\t \n\t\t\tget_random_bytes(&nrpa, 6);\n\t\t\tnrpa.b[5] &= 0x3f;\n\n\t\t\t \n\t\t\tif (bacmp(&hdev->bdaddr, &nrpa))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t*own_addr_type = ADDR_LE_DEV_RANDOM;\n\t\tbacpy(rand_addr, &nrpa);\n\n\t\treturn 0;\n\t}\n\n\t \n\t*own_addr_type = ADDR_LE_DEV_PUBLIC;\n\n\treturn 0;\n}\n\nstatic int _update_adv_data_sync(struct hci_dev *hdev, void *data)\n{\n\tu8 instance = PTR_UINT(data);\n\n\treturn hci_update_adv_data_sync(hdev, instance);\n}\n\nint hci_update_adv_data(struct hci_dev *hdev, u8 instance)\n{\n\treturn hci_cmd_sync_queue(hdev, _update_adv_data_sync,\n\t\t\t\t  UINT_PTR(instance), NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}