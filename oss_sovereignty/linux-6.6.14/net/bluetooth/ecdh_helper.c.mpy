{
  "module_name": "ecdh_helper.c",
  "hash_id": "1d590b2e04d86f2c28338baf569dd55fbbb149375b46890ad115acfa73d39d18",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/ecdh_helper.c",
  "human_readable_source": " \n#include \"ecdh_helper.h\"\n\n#include <linux/scatterlist.h>\n#include <crypto/ecdh.h>\n\nstatic inline void swap_digits(u64 *in, u64 *out, unsigned int ndigits)\n{\n\tint i;\n\n\tfor (i = 0; i < ndigits; i++)\n\t\tout[i] = __swab64(in[ndigits - 1 - i]);\n}\n\n \nint compute_ecdh_secret(struct crypto_kpp *tfm, const u8 public_key[64],\n\t\t\tu8 secret[32])\n{\n\tDECLARE_CRYPTO_WAIT(result);\n\tstruct kpp_request *req;\n\tu8 *tmp;\n\tstruct scatterlist src, dst;\n\tint err;\n\n\ttmp = kmalloc(64, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\treq = kpp_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\terr = -ENOMEM;\n\t\tgoto free_tmp;\n\t}\n\n\tswap_digits((u64 *)public_key, (u64 *)tmp, 4);  \n\tswap_digits((u64 *)&public_key[32], (u64 *)&tmp[32], 4);  \n\n\tsg_init_one(&src, tmp, 64);\n\tsg_init_one(&dst, secret, 32);\n\tkpp_request_set_input(req, &src, 64);\n\tkpp_request_set_output(req, &dst, 32);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t crypto_req_done, &result);\n\terr = crypto_kpp_compute_shared_secret(req);\n\terr = crypto_wait_req(err, &result);\n\tif (err < 0) {\n\t\tpr_err(\"alg: ecdh: compute shared secret failed. err %d\\n\",\n\t\t       err);\n\t\tgoto free_all;\n\t}\n\n\tswap_digits((u64 *)secret, (u64 *)tmp, 4);\n\tmemcpy(secret, tmp, 32);\n\nfree_all:\n\tkpp_request_free(req);\nfree_tmp:\n\tkfree_sensitive(tmp);\n\treturn err;\n}\n\n \nint set_ecdh_privkey(struct crypto_kpp *tfm, const u8 private_key[32])\n{\n\tu8 *buf, *tmp = NULL;\n\tunsigned int buf_len;\n\tint err;\n\tstruct ecdh p = {0};\n\n\tif (private_key) {\n\t\ttmp = kmalloc(32, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\tswap_digits((u64 *)private_key, (u64 *)tmp, 4);\n\t\tp.key = tmp;\n\t\tp.key_size = 32;\n\t}\n\n\tbuf_len = crypto_ecdh_key_len(&p);\n\tbuf = kmalloc(buf_len, GFP_KERNEL);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto free_tmp;\n\t}\n\n\terr = crypto_ecdh_encode_key(buf, buf_len, &p);\n\tif (err)\n\t\tgoto free_all;\n\n\terr = crypto_kpp_set_secret(tfm, buf, buf_len);\n\t \nfree_all:\n\tkfree_sensitive(buf);\nfree_tmp:\n\tkfree_sensitive(tmp);\n\treturn err;\n}\n\n \nint generate_ecdh_public_key(struct crypto_kpp *tfm, u8 public_key[64])\n{\n\tDECLARE_CRYPTO_WAIT(result);\n\tstruct kpp_request *req;\n\tu8 *tmp;\n\tstruct scatterlist dst;\n\tint err;\n\n\ttmp = kmalloc(64, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\treq = kpp_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\terr = -ENOMEM;\n\t\tgoto free_tmp;\n\t}\n\n\tsg_init_one(&dst, tmp, 64);\n\tkpp_request_set_input(req, NULL, 0);\n\tkpp_request_set_output(req, &dst, 64);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t crypto_req_done, &result);\n\n\terr = crypto_kpp_generate_public_key(req);\n\terr = crypto_wait_req(err, &result);\n\tif (err < 0)\n\t\tgoto free_all;\n\n\t \n\tswap_digits((u64 *)tmp, (u64 *)public_key, 4);  \n\tswap_digits((u64 *)&tmp[32], (u64 *)&public_key[32], 4);  \n\nfree_all:\n\tkpp_request_free(req);\nfree_tmp:\n\tkfree(tmp);\n\treturn err;\n}\n\n \nint generate_ecdh_keys(struct crypto_kpp *tfm, u8 public_key[64])\n{\n\tint err;\n\n\terr = set_ecdh_privkey(tfm, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn generate_ecdh_public_key(tfm, public_key);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}