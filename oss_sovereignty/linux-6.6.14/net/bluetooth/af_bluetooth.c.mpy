{
  "module_name": "af_bluetooth.c",
  "hash_id": "128d21c2c631a35b2d6a750ce773c4e40365e34bb535a22c57a382c94162d348",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/af_bluetooth.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/stringify.h>\n#include <linux/sched/signal.h>\n\n#include <asm/ioctls.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <linux/proc_fs.h>\n\n#include \"leds.h\"\n#include \"selftest.h\"\n\n \n#define BT_MAX_PROTO\t(BTPROTO_LAST + 1)\nstatic const struct net_proto_family *bt_proto[BT_MAX_PROTO];\nstatic DEFINE_RWLOCK(bt_proto_lock);\n\nstatic struct lock_class_key bt_lock_key[BT_MAX_PROTO];\nstatic const char *const bt_key_strings[BT_MAX_PROTO] = {\n\t\"sk_lock-AF_BLUETOOTH-BTPROTO_L2CAP\",\n\t\"sk_lock-AF_BLUETOOTH-BTPROTO_HCI\",\n\t\"sk_lock-AF_BLUETOOTH-BTPROTO_SCO\",\n\t\"sk_lock-AF_BLUETOOTH-BTPROTO_RFCOMM\",\n\t\"sk_lock-AF_BLUETOOTH-BTPROTO_BNEP\",\n\t\"sk_lock-AF_BLUETOOTH-BTPROTO_CMTP\",\n\t\"sk_lock-AF_BLUETOOTH-BTPROTO_HIDP\",\n\t\"sk_lock-AF_BLUETOOTH-BTPROTO_AVDTP\",\n\t\"sk_lock-AF_BLUETOOTH-BTPROTO_ISO\",\n};\n\nstatic struct lock_class_key bt_slock_key[BT_MAX_PROTO];\nstatic const char *const bt_slock_key_strings[BT_MAX_PROTO] = {\n\t\"slock-AF_BLUETOOTH-BTPROTO_L2CAP\",\n\t\"slock-AF_BLUETOOTH-BTPROTO_HCI\",\n\t\"slock-AF_BLUETOOTH-BTPROTO_SCO\",\n\t\"slock-AF_BLUETOOTH-BTPROTO_RFCOMM\",\n\t\"slock-AF_BLUETOOTH-BTPROTO_BNEP\",\n\t\"slock-AF_BLUETOOTH-BTPROTO_CMTP\",\n\t\"slock-AF_BLUETOOTH-BTPROTO_HIDP\",\n\t\"slock-AF_BLUETOOTH-BTPROTO_AVDTP\",\n\t\"slock-AF_BLUETOOTH-BTPROTO_ISO\",\n};\n\nvoid bt_sock_reclassify_lock(struct sock *sk, int proto)\n{\n\tBUG_ON(!sk);\n\tBUG_ON(!sock_allow_reclassification(sk));\n\n\tsock_lock_init_class_and_name(sk,\n\t\t\t\t      bt_slock_key_strings[proto], &bt_slock_key[proto],\n\t\t\t\t      bt_key_strings[proto], &bt_lock_key[proto]);\n}\nEXPORT_SYMBOL(bt_sock_reclassify_lock);\n\nint bt_sock_register(int proto, const struct net_proto_family *ops)\n{\n\tint err = 0;\n\n\tif (proto < 0 || proto >= BT_MAX_PROTO)\n\t\treturn -EINVAL;\n\n\twrite_lock(&bt_proto_lock);\n\n\tif (bt_proto[proto])\n\t\terr = -EEXIST;\n\telse\n\t\tbt_proto[proto] = ops;\n\n\twrite_unlock(&bt_proto_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(bt_sock_register);\n\nvoid bt_sock_unregister(int proto)\n{\n\tif (proto < 0 || proto >= BT_MAX_PROTO)\n\t\treturn;\n\n\twrite_lock(&bt_proto_lock);\n\tbt_proto[proto] = NULL;\n\twrite_unlock(&bt_proto_lock);\n}\nEXPORT_SYMBOL(bt_sock_unregister);\n\nstatic int bt_sock_create(struct net *net, struct socket *sock, int proto,\n\t\t\t  int kern)\n{\n\tint err;\n\n\tif (net != &init_net)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (proto < 0 || proto >= BT_MAX_PROTO)\n\t\treturn -EINVAL;\n\n\tif (!bt_proto[proto])\n\t\trequest_module(\"bt-proto-%d\", proto);\n\n\terr = -EPROTONOSUPPORT;\n\n\tread_lock(&bt_proto_lock);\n\n\tif (bt_proto[proto] && try_module_get(bt_proto[proto]->owner)) {\n\t\terr = bt_proto[proto]->create(net, sock, proto, kern);\n\t\tif (!err)\n\t\t\tbt_sock_reclassify_lock(sock->sk, proto);\n\t\tmodule_put(bt_proto[proto]->owner);\n\t}\n\n\tread_unlock(&bt_proto_lock);\n\n\treturn err;\n}\n\nstruct sock *bt_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t   struct proto *prot, int proto, gfp_t prio, int kern)\n{\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, prot, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\n\t \n\tif (!kern) {\n\t\tspin_lock(&sk->sk_peer_lock);\n\t\tsk->sk_peer_pid  = get_pid(task_tgid(current));\n\t\tsk->sk_peer_cred = get_current_cred();\n\t\tspin_unlock(&sk->sk_peer_lock);\n\t}\n\n\treturn sk;\n}\nEXPORT_SYMBOL(bt_sock_alloc);\n\nvoid bt_sock_link(struct bt_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock(&l->lock);\n}\nEXPORT_SYMBOL(bt_sock_link);\n\nvoid bt_sock_unlink(struct bt_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_del_node_init(sk);\n\twrite_unlock(&l->lock);\n}\nEXPORT_SYMBOL(bt_sock_unlink);\n\nvoid bt_accept_enqueue(struct sock *parent, struct sock *sk, bool bh)\n{\n\tconst struct cred *old_cred;\n\tstruct pid *old_pid;\n\n\tBT_DBG(\"parent %p, sk %p\", parent, sk);\n\n\tsock_hold(sk);\n\n\tif (bh)\n\t\tbh_lock_sock_nested(sk);\n\telse\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tlist_add_tail(&bt_sk(sk)->accept_q, &bt_sk(parent)->accept_q);\n\tbt_sk(sk)->parent = parent;\n\n\t \n\tspin_lock(&sk->sk_peer_lock);\n\told_pid = sk->sk_peer_pid;\n\told_cred = sk->sk_peer_cred;\n\tsk->sk_peer_pid = get_pid(parent->sk_peer_pid);\n\tsk->sk_peer_cred = get_cred(parent->sk_peer_cred);\n\tspin_unlock(&sk->sk_peer_lock);\n\n\tput_pid(old_pid);\n\tput_cred(old_cred);\n\n\tif (bh)\n\t\tbh_unlock_sock(sk);\n\telse\n\t\trelease_sock(sk);\n\n\tsk_acceptq_added(parent);\n}\nEXPORT_SYMBOL(bt_accept_enqueue);\n\n \nvoid bt_accept_unlink(struct sock *sk)\n{\n\tBT_DBG(\"sk %p state %d\", sk, sk->sk_state);\n\n\tlist_del_init(&bt_sk(sk)->accept_q);\n\tsk_acceptq_removed(bt_sk(sk)->parent);\n\tbt_sk(sk)->parent = NULL;\n\tsock_put(sk);\n}\nEXPORT_SYMBOL(bt_accept_unlink);\n\nstruct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock)\n{\n\tstruct bt_sock *s, *n;\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\nrestart:\n\tlist_for_each_entry_safe(s, n, &bt_sk(parent)->accept_q, accept_q) {\n\t\tsk = (struct sock *)s;\n\n\t\t \n\t\tsock_hold(sk);\n\t\tlock_sock(sk);\n\n\t\t \n\t\tif (!bt_sk(sk)->parent) {\n\t\t\tBT_DBG(\"sk %p, already unlinked\", sk);\n\t\t\trelease_sock(sk);\n\t\t\tsock_put(sk);\n\n\t\t\t \n\t\t\tgoto restart;\n\t\t}\n\n\t\t \n\t\tsock_put(sk);\n\n\t\t \n\t\tif (sk->sk_state == BT_CLOSED) {\n\t\t\tbt_accept_unlink(sk);\n\t\t\trelease_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == BT_CONNECTED || !newsock ||\n\t\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags)) {\n\t\t\tbt_accept_unlink(sk);\n\t\t\tif (newsock)\n\t\t\t\tsock_graft(sk, newsock);\n\n\t\t\trelease_sock(sk);\n\t\t\treturn sk;\n\t\t}\n\n\t\trelease_sock(sk);\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(bt_accept_dequeue);\n\nint bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t    int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\terr = 0;\n\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err == 0) {\n\t\tsock_recv_cmsgs(msg, sk, skb);\n\n\t\tif (msg->msg_name && bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\n\treturn err ? : copied;\n}\nEXPORT_SYMBOL(bt_sock_recvmsg);\n\nstatic long bt_sock_data_wait(struct sock *sk, long timeo)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\t\tbreak;\n\n\t\tif (sk->sk_err || (sk->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tbreak;\n\n\t\tif (signal_pending(current) || !timeo)\n\t\t\tbreak;\n\n\t\tsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn timeo;\n}\n\nint bt_sock_stream_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t   size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tsize_t target, copied = 0;\n\tlong timeo;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tBT_DBG(\"sk %p size %zu\", sk, size);\n\n\tlock_sock(sk);\n\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n\ttimeo  = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\tdo {\n\t\tstruct sk_buff *skb;\n\t\tint chunk;\n\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tif (!skb) {\n\t\t\tif (copied >= target)\n\t\t\t\tbreak;\n\n\t\t\terr = sock_error(sk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\n\t\t\terr = -EAGAIN;\n\t\t\tif (!timeo)\n\t\t\t\tbreak;\n\n\t\t\ttimeo = bt_sock_data_wait(sk, timeo);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeo);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tchunk = min_t(unsigned int, skb->len, size);\n\t\tif (skb_copy_datagram_msg(skb, 0, msg, chunk)) {\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize   -= chunk;\n\n\t\tsock_recv_cmsgs(msg, sk, skb);\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tint skb_len = skb_headlen(skb);\n\n\t\t\tif (chunk <= skb_len) {\n\t\t\t\t__skb_pull(skb, chunk);\n\t\t\t} else {\n\t\t\t\tstruct sk_buff *frag;\n\n\t\t\t\t__skb_pull(skb, skb_len);\n\t\t\t\tchunk -= skb_len;\n\n\t\t\t\tskb_walk_frags(skb, frag) {\n\t\t\t\t\tif (chunk <= frag->len) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tskb->len -= chunk;\n\t\t\t\t\t\tskb->data_len -= chunk;\n\t\t\t\t\t\t__skb_pull(frag, chunk);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (frag->len) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tchunk -= frag->len;\n\t\t\t\t\t\tskb->len -= frag->len;\n\t\t\t\t\t\tskb->data_len -= frag->len;\n\t\t\t\t\t\t__skb_pull(frag, frag->len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkfree_skb(skb);\n\n\t\t} else {\n\t\t\t \n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tbreak;\n\t\t}\n\t} while (size);\n\nout:\n\trelease_sock(sk);\n\treturn copied ? : err;\n}\nEXPORT_SYMBOL(bt_sock_stream_recvmsg);\n\nstatic inline __poll_t bt_accept_poll(struct sock *parent)\n{\n\tstruct bt_sock *s, *n;\n\tstruct sock *sk;\n\n\tlist_for_each_entry_safe(s, n, &bt_sk(parent)->accept_q, accept_q) {\n\t\tsk = (struct sock *)s;\n\t\tif (sk->sk_state == BT_CONNECTED ||\n\t\t    (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags) &&\n\t\t     sk->sk_state == BT_CONNECT2))\n\t\t\treturn EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn 0;\n}\n\n__poll_t bt_sock_poll(struct file *file, struct socket *sock,\n\t\t      poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, sk_sleep(sk), wait);\n\n\tif (sk->sk_state == BT_LISTEN)\n\t\treturn bt_accept_poll(sk);\n\n\tif (sk->sk_err || !skb_queue_empty_lockless(&sk->sk_error_queue))\n\t\tmask |= EPOLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? EPOLLPRI : 0);\n\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= EPOLLRDHUP | EPOLLIN | EPOLLRDNORM;\n\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= EPOLLHUP;\n\n\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tif (sk->sk_state == BT_CLOSED)\n\t\tmask |= EPOLLHUP;\n\n\tif (sk->sk_state == BT_CONNECT ||\n\t    sk->sk_state == BT_CONNECT2 ||\n\t    sk->sk_state == BT_CONFIG)\n\t\treturn mask;\n\n\tif (!test_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags) && sock_writeable(sk))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;\n\telse\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\treturn mask;\n}\nEXPORT_SYMBOL(bt_sock_poll);\n\nint bt_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tlong amount;\n\tint err;\n\n\tBT_DBG(\"sk %p cmd %x arg %lx\", sk, cmd, arg);\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\tif (sk->sk_state == BT_LISTEN)\n\t\t\treturn -EINVAL;\n\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\terr = put_user(amount, (int __user *)arg);\n\t\tbreak;\n\n\tcase TIOCINQ:\n\t\tif (sk->sk_state == BT_LISTEN)\n\t\t\treturn -EINVAL;\n\n\t\tlock_sock(sk);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tamount = skb ? skb->len : 0;\n\t\trelease_sock(sk);\n\t\terr = put_user(amount, (int __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL(bt_sock_ioctl);\n\n \nint bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (sk->sk_state != state) {\n\t\tif (!timeo) {\n\t\t\terr = -EINPROGRESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn err;\n}\nEXPORT_SYMBOL(bt_sock_wait_state);\n\n \nint bt_sock_wait_ready(struct sock *sk, unsigned int msg_flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long timeo;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\ttimeo = sock_sndtimeo(sk, !!(msg_flags & MSG_DONTWAIT));\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (test_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\treturn err;\n}\nEXPORT_SYMBOL(bt_sock_wait_ready);\n\n#ifdef CONFIG_PROC_FS\nstatic void *bt_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(seq->private->l->lock)\n{\n\tstruct bt_sock_list *l = pde_data(file_inode(seq->file));\n\n\tread_lock(&l->lock);\n\treturn seq_hlist_start_head(&l->head, *pos);\n}\n\nstatic void *bt_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bt_sock_list *l = pde_data(file_inode(seq->file));\n\n\treturn seq_hlist_next(v, &l->head, pos);\n}\n\nstatic void bt_seq_stop(struct seq_file *seq, void *v)\n\t__releases(seq->private->l->lock)\n{\n\tstruct bt_sock_list *l = pde_data(file_inode(seq->file));\n\n\tread_unlock(&l->lock);\n}\n\nstatic int bt_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct bt_sock_list *l = pde_data(file_inode(seq->file));\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"sk               RefCnt Rmem   Wmem   User   Inode  Parent\");\n\n\t\tif (l->custom_seq_show) {\n\t\t\tseq_putc(seq, ' ');\n\t\t\tl->custom_seq_show(seq, v);\n\t\t}\n\n\t\tseq_putc(seq, '\\n');\n\t} else {\n\t\tstruct sock *sk = sk_entry(v);\n\t\tstruct bt_sock *bt = bt_sk(sk);\n\n\t\tseq_printf(seq,\n\t\t\t   \"%pK %-6d %-6u %-6u %-6u %-6lu %-6lu\",\n\t\t\t   sk,\n\t\t\t   refcount_read(&sk->sk_refcnt),\n\t\t\t   sk_rmem_alloc_get(sk),\n\t\t\t   sk_wmem_alloc_get(sk),\n\t\t\t   from_kuid(seq_user_ns(seq), sock_i_uid(sk)),\n\t\t\t   sock_i_ino(sk),\n\t\t\t   bt->parent ? sock_i_ino(bt->parent) : 0LU);\n\n\t\tif (l->custom_seq_show) {\n\t\t\tseq_putc(seq, ' ');\n\t\t\tl->custom_seq_show(seq, v);\n\t\t}\n\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations bt_seq_ops = {\n\t.start = bt_seq_start,\n\t.next  = bt_seq_next,\n\t.stop  = bt_seq_stop,\n\t.show  = bt_seq_show,\n};\n\nint bt_procfs_init(struct net *net, const char *name,\n\t\t   struct bt_sock_list *sk_list,\n\t\t   int (*seq_show)(struct seq_file *, void *))\n{\n\tsk_list->custom_seq_show = seq_show;\n\n\tif (!proc_create_seq_data(name, 0, net->proc_net, &bt_seq_ops, sk_list))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid bt_procfs_cleanup(struct net *net, const char *name)\n{\n\tremove_proc_entry(name, net->proc_net);\n}\n#else\nint bt_procfs_init(struct net *net, const char *name,\n\t\t   struct bt_sock_list *sk_list,\n\t\t   int (*seq_show)(struct seq_file *, void *))\n{\n\treturn 0;\n}\n\nvoid bt_procfs_cleanup(struct net *net, const char *name)\n{\n}\n#endif\nEXPORT_SYMBOL(bt_procfs_init);\nEXPORT_SYMBOL(bt_procfs_cleanup);\n\nstatic const struct net_proto_family bt_sock_family_ops = {\n\t.owner\t= THIS_MODULE,\n\t.family\t= PF_BLUETOOTH,\n\t.create\t= bt_sock_create,\n};\n\nstruct dentry *bt_debugfs;\nEXPORT_SYMBOL_GPL(bt_debugfs);\n\n#define VERSION __stringify(BT_SUBSYS_VERSION) \".\" \\\n\t\t__stringify(BT_SUBSYS_REVISION)\n\nstatic int __init bt_init(void)\n{\n\tint err;\n\n\tsock_skb_cb_check_size(sizeof(struct bt_skb_cb));\n\n\tBT_INFO(\"Core ver %s\", VERSION);\n\n\terr = bt_selftest();\n\tif (err < 0)\n\t\treturn err;\n\n\tbt_debugfs = debugfs_create_dir(\"bluetooth\", NULL);\n\n\tbt_leds_init();\n\n\terr = bt_sysfs_init();\n\tif (err < 0)\n\t\tgoto cleanup_led;\n\n\terr = sock_register(&bt_sock_family_ops);\n\tif (err)\n\t\tgoto cleanup_sysfs;\n\n\tBT_INFO(\"HCI device and connection manager initialized\");\n\n\terr = hci_sock_init();\n\tif (err)\n\t\tgoto unregister_socket;\n\n\terr = l2cap_init();\n\tif (err)\n\t\tgoto cleanup_socket;\n\n\terr = sco_init();\n\tif (err)\n\t\tgoto cleanup_cap;\n\n\terr = mgmt_init();\n\tif (err)\n\t\tgoto cleanup_sco;\n\n\treturn 0;\n\ncleanup_sco:\n\tsco_exit();\ncleanup_cap:\n\tl2cap_exit();\ncleanup_socket:\n\thci_sock_cleanup();\nunregister_socket:\n\tsock_unregister(PF_BLUETOOTH);\ncleanup_sysfs:\n\tbt_sysfs_cleanup();\ncleanup_led:\n\tbt_leds_cleanup();\n\treturn err;\n}\n\nstatic void __exit bt_exit(void)\n{\n\tmgmt_exit();\n\n\tsco_exit();\n\n\tl2cap_exit();\n\n\thci_sock_cleanup();\n\n\tsock_unregister(PF_BLUETOOTH);\n\n\tbt_sysfs_cleanup();\n\n\tbt_leds_cleanup();\n\n\tdebugfs_remove_recursive(bt_debugfs);\n}\n\nsubsys_initcall(bt_init);\nmodule_exit(bt_exit);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth Core ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_BLUETOOTH);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}