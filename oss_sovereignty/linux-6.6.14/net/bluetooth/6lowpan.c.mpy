{
  "module_name": "6lowpan.c",
  "hash_id": "63fb68742200ec9eb65a47cf5c148060de1f2812cf65eb3554aebff5ca5a453a",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/6lowpan.c",
  "human_readable_source": "\n \n\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/pkt_sched.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include <net/6lowpan.h>  \n\n#define VERSION \"0.1\"\n\nstatic struct dentry *lowpan_enable_debugfs;\nstatic struct dentry *lowpan_control_debugfs;\n\n#define IFACE_NAME_TEMPLATE \"bt%d\"\n\nstruct skb_cb {\n\tstruct in6_addr addr;\n\tstruct in6_addr gw;\n\tstruct l2cap_chan *chan;\n};\n#define lowpan_cb(skb) ((struct skb_cb *)((skb)->cb))\n\n \nstatic LIST_HEAD(bt_6lowpan_devices);\nstatic DEFINE_SPINLOCK(devices_lock);\n\nstatic bool enable_6lowpan;\n\n \nstatic struct l2cap_chan *listen_chan;\nstatic DEFINE_MUTEX(set_lock);\n\nstruct lowpan_peer {\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n\tstruct l2cap_chan *chan;\n\n\t \n\tunsigned char lladdr[ETH_ALEN];\n\tstruct in6_addr peer_addr;\n};\n\nstruct lowpan_btle_dev {\n\tstruct list_head list;\n\n\tstruct hci_dev *hdev;\n\tstruct net_device *netdev;\n\tstruct list_head peers;\n\tatomic_t peer_count;  \n\n\tstruct work_struct delete_netdev;\n\tstruct delayed_work notify_peers;\n};\n\nstatic inline struct lowpan_btle_dev *\nlowpan_btle_dev(const struct net_device *netdev)\n{\n\treturn (struct lowpan_btle_dev *)lowpan_dev(netdev)->priv;\n}\n\nstatic inline void peer_add(struct lowpan_btle_dev *dev,\n\t\t\t    struct lowpan_peer *peer)\n{\n\tlist_add_rcu(&peer->list, &dev->peers);\n\tatomic_inc(&dev->peer_count);\n}\n\nstatic inline bool peer_del(struct lowpan_btle_dev *dev,\n\t\t\t    struct lowpan_peer *peer)\n{\n\tlist_del_rcu(&peer->list);\n\tkfree_rcu(peer, rcu);\n\n\tmodule_put(THIS_MODULE);\n\n\tif (atomic_dec_and_test(&dev->peer_count)) {\n\t\tBT_DBG(\"last peer\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline struct lowpan_peer *\n__peer_lookup_chan(struct lowpan_btle_dev *dev, struct l2cap_chan *chan)\n{\n\tstruct lowpan_peer *peer;\n\n\tlist_for_each_entry_rcu(peer, &dev->peers, list) {\n\t\tif (peer->chan == chan)\n\t\t\treturn peer;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline struct lowpan_peer *\n__peer_lookup_conn(struct lowpan_btle_dev *dev, struct l2cap_conn *conn)\n{\n\tstruct lowpan_peer *peer;\n\n\tlist_for_each_entry_rcu(peer, &dev->peers, list) {\n\t\tif (peer->chan->conn == conn)\n\t\t\treturn peer;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline struct lowpan_peer *peer_lookup_dst(struct lowpan_btle_dev *dev,\n\t\t\t\t\t\t  struct in6_addr *daddr,\n\t\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\tint count = atomic_read(&dev->peer_count);\n\tconst struct in6_addr *nexthop;\n\tstruct lowpan_peer *peer;\n\tstruct neighbour *neigh;\n\n\tBT_DBG(\"peers %d addr %pI6c rt %p\", count, daddr, rt);\n\n\tif (!rt) {\n\t\tif (ipv6_addr_any(&lowpan_cb(skb)->gw)) {\n\t\t\t \n\t\t\tnexthop = daddr;\n\t\t} else {\n\t\t\t \n\t\t\tnexthop = &lowpan_cb(skb)->gw;\n\t\t}\n\t} else {\n\t\tnexthop = rt6_nexthop(rt, daddr);\n\n\t\t \n\t\tmemcpy(&lowpan_cb(skb)->gw, nexthop, sizeof(struct in6_addr));\n\t}\n\n\tBT_DBG(\"gw %pI6c\", nexthop);\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(peer, &dev->peers, list) {\n\t\tBT_DBG(\"dst addr %pMR dst type %u ip %pI6c\",\n\t\t       &peer->chan->dst, peer->chan->dst_type,\n\t\t       &peer->peer_addr);\n\n\t\tif (!ipv6_addr_cmp(&peer->peer_addr, nexthop)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn peer;\n\t\t}\n\t}\n\n\t \n\tneigh = __ipv6_neigh_lookup(dev->netdev, nexthop);\n\tif (neigh) {\n\t\tlist_for_each_entry_rcu(peer, &dev->peers, list) {\n\t\t\tif (!memcmp(neigh->ha, peer->lladdr, ETH_ALEN)) {\n\t\t\t\tneigh_release(neigh);\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn peer;\n\t\t\t}\n\t\t}\n\t\tneigh_release(neigh);\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic struct lowpan_peer *lookup_peer(struct l2cap_conn *conn)\n{\n\tstruct lowpan_btle_dev *entry;\n\tstruct lowpan_peer *peer = NULL;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(entry, &bt_6lowpan_devices, list) {\n\t\tpeer = __peer_lookup_conn(entry, conn);\n\t\tif (peer)\n\t\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\treturn peer;\n}\n\nstatic struct lowpan_btle_dev *lookup_dev(struct l2cap_conn *conn)\n{\n\tstruct lowpan_btle_dev *entry;\n\tstruct lowpan_btle_dev *dev = NULL;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(entry, &bt_6lowpan_devices, list) {\n\t\tif (conn->hcon->hdev == entry->hdev) {\n\t\t\tdev = entry;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn dev;\n}\n\nstatic int give_skb_to_upper(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sk_buff *skb_cp;\n\n\tskb_cp = skb_copy(skb, GFP_ATOMIC);\n\tif (!skb_cp)\n\t\treturn NET_RX_DROP;\n\n\treturn netif_rx(skb_cp);\n}\n\nstatic int iphc_decompress(struct sk_buff *skb, struct net_device *netdev,\n\t\t\t   struct lowpan_peer *peer)\n{\n\tconst u8 *saddr;\n\n\tsaddr = peer->lladdr;\n\n\treturn lowpan_header_decompress(skb, netdev, netdev->dev_addr, saddr);\n}\n\nstatic int recv_pkt(struct sk_buff *skb, struct net_device *dev,\n\t\t    struct lowpan_peer *peer)\n{\n\tstruct sk_buff *local_skb;\n\tint ret;\n\n\tif (!netif_running(dev))\n\t\tgoto drop;\n\n\tif (dev->type != ARPHRD_6LOWPAN || !skb->len)\n\t\tgoto drop;\n\n\tskb_reset_network_header(skb);\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop;\n\n\t \n\tif (lowpan_is_ipv6(*skb_network_header(skb))) {\n\t\t \n\t\tskb_pull(skb, 1);\n\n\t\t \n\t\tlocal_skb = skb_copy_expand(skb, NET_SKB_PAD - 1,\n\t\t\t\t\t    skb_tailroom(skb), GFP_ATOMIC);\n\t\tif (!local_skb)\n\t\t\tgoto drop;\n\n\t\tlocal_skb->protocol = htons(ETH_P_IPV6);\n\t\tlocal_skb->pkt_type = PACKET_HOST;\n\t\tlocal_skb->dev = dev;\n\n\t\tskb_set_transport_header(local_skb, sizeof(struct ipv6hdr));\n\n\t\tif (give_skb_to_upper(local_skb, dev) != NET_RX_SUCCESS) {\n\t\t\tkfree_skb(local_skb);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tdev->stats.rx_bytes += skb->len;\n\t\tdev->stats.rx_packets++;\n\n\t\tconsume_skb(local_skb);\n\t\tconsume_skb(skb);\n\t} else if (lowpan_is_iphc(*skb_network_header(skb))) {\n\t\tlocal_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!local_skb)\n\t\t\tgoto drop;\n\n\t\tlocal_skb->dev = dev;\n\n\t\tret = iphc_decompress(local_skb, dev, peer);\n\t\tif (ret < 0) {\n\t\t\tBT_DBG(\"iphc_decompress failed: %d\", ret);\n\t\t\tkfree_skb(local_skb);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tlocal_skb->protocol = htons(ETH_P_IPV6);\n\t\tlocal_skb->pkt_type = PACKET_HOST;\n\n\t\tif (give_skb_to_upper(local_skb, dev)\n\t\t\t\t!= NET_RX_SUCCESS) {\n\t\t\tkfree_skb(local_skb);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tdev->stats.rx_bytes += skb->len;\n\t\tdev->stats.rx_packets++;\n\n\t\tconsume_skb(local_skb);\n\t\tconsume_skb(skb);\n\t} else {\n\t\tBT_DBG(\"unknown packet type\");\n\t\tgoto drop;\n\t}\n\n\treturn NET_RX_SUCCESS;\n\ndrop:\n\tdev->stats.rx_dropped++;\n\treturn NET_RX_DROP;\n}\n\n \nstatic int chan_recv_cb(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct lowpan_btle_dev *dev;\n\tstruct lowpan_peer *peer;\n\tint err;\n\n\tpeer = lookup_peer(chan->conn);\n\tif (!peer)\n\t\treturn -ENOENT;\n\n\tdev = lookup_dev(chan->conn);\n\tif (!dev || !dev->netdev)\n\t\treturn -ENOENT;\n\n\terr = recv_pkt(skb, dev->netdev, peer);\n\tif (err) {\n\t\tBT_DBG(\"recv pkt %d\", err);\n\t\terr = -EAGAIN;\n\t}\n\n\treturn err;\n}\n\nstatic int setup_header(struct sk_buff *skb, struct net_device *netdev,\n\t\t\tbdaddr_t *peer_addr, u8 *peer_addr_type)\n{\n\tstruct in6_addr ipv6_daddr;\n\tstruct ipv6hdr *hdr;\n\tstruct lowpan_btle_dev *dev;\n\tstruct lowpan_peer *peer;\n\tu8 *daddr;\n\tint err, status = 0;\n\n\thdr = ipv6_hdr(skb);\n\n\tdev = lowpan_btle_dev(netdev);\n\n\tmemcpy(&ipv6_daddr, &hdr->daddr, sizeof(ipv6_daddr));\n\n\tif (ipv6_addr_is_multicast(&ipv6_daddr)) {\n\t\tlowpan_cb(skb)->chan = NULL;\n\t\tdaddr = NULL;\n\t} else {\n\t\tBT_DBG(\"dest IP %pI6c\", &ipv6_daddr);\n\n\t\t \n\t\tpeer = peer_lookup_dst(dev, &ipv6_daddr, skb);\n\t\tif (!peer) {\n\t\t\tBT_DBG(\"no such peer\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tdaddr = peer->lladdr;\n\t\t*peer_addr = peer->chan->dst;\n\t\t*peer_addr_type = peer->chan->dst_type;\n\t\tlowpan_cb(skb)->chan = peer->chan;\n\n\t\tstatus = 1;\n\t}\n\n\tlowpan_header_compress(skb, netdev, daddr, dev->netdev->dev_addr);\n\n\terr = dev_hard_header(skb, netdev, ETH_P_IPV6, NULL, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn status;\n}\n\nstatic int header_create(struct sk_buff *skb, struct net_device *netdev,\n\t\t\t unsigned short type, const void *_daddr,\n\t\t\t const void *_saddr, unsigned int len)\n{\n\tif (type != ETH_P_IPV6)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int send_pkt(struct l2cap_chan *chan, struct sk_buff *skb,\n\t\t    struct net_device *netdev)\n{\n\tstruct msghdr msg;\n\tstruct kvec iv;\n\tint err;\n\n\t \n\tchan->data = skb;\n\n\tiv.iov_base = skb->data;\n\tiv.iov_len = skb->len;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tiov_iter_kvec(&msg.msg_iter, ITER_SOURCE, &iv, 1, skb->len);\n\n\terr = l2cap_chan_send(chan, &msg, skb->len);\n\tif (err > 0) {\n\t\tnetdev->stats.tx_bytes += err;\n\t\tnetdev->stats.tx_packets++;\n\t\treturn 0;\n\t}\n\n\tif (err < 0)\n\t\tnetdev->stats.tx_errors++;\n\n\treturn err;\n}\n\nstatic int send_mcast_pkt(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct sk_buff *local_skb;\n\tstruct lowpan_btle_dev *entry;\n\tint err = 0;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(entry, &bt_6lowpan_devices, list) {\n\t\tstruct lowpan_peer *pentry;\n\t\tstruct lowpan_btle_dev *dev;\n\n\t\tif (entry->netdev != netdev)\n\t\t\tcontinue;\n\n\t\tdev = lowpan_btle_dev(entry->netdev);\n\n\t\tlist_for_each_entry_rcu(pentry, &dev->peers, list) {\n\t\t\tint ret;\n\n\t\t\tlocal_skb = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\tBT_DBG(\"xmit %s to %pMR type %u IP %pI6c chan %p\",\n\t\t\t       netdev->name,\n\t\t\t       &pentry->chan->dst, pentry->chan->dst_type,\n\t\t\t       &pentry->peer_addr, pentry->chan);\n\t\t\tret = send_pkt(pentry->chan, local_skb, netdev);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\n\t\t\tkfree_skb(local_skb);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic netdev_tx_t bt_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tint err = 0;\n\tbdaddr_t addr;\n\tu8 addr_type;\n\n\t \n\tskb = skb_unshare(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NET_XMIT_DROP;\n\n\t \n\terr = setup_header(skb, netdev, &addr, &addr_type);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\tif (err) {\n\t\tif (lowpan_cb(skb)->chan) {\n\t\t\tBT_DBG(\"xmit %s to %pMR type %u IP %pI6c chan %p\",\n\t\t\t       netdev->name, &addr, addr_type,\n\t\t\t       &lowpan_cb(skb)->addr, lowpan_cb(skb)->chan);\n\t\t\terr = send_pkt(lowpan_cb(skb)->chan, skb, netdev);\n\t\t} else {\n\t\t\terr = -ENOENT;\n\t\t}\n\t} else {\n\t\t \n\t\terr = send_mcast_pkt(skb, netdev);\n\t}\n\n\tdev_kfree_skb(skb);\n\n\tif (err)\n\t\tBT_DBG(\"ERROR: xmit failed (%d)\", err);\n\n\treturn err < 0 ? NET_XMIT_DROP : err;\n}\n\nstatic int bt_dev_init(struct net_device *dev)\n{\n\tnetdev_lockdep_set_classes(dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_init\t\t= bt_dev_init,\n\t.ndo_start_xmit\t\t= bt_xmit,\n};\n\nstatic const struct header_ops header_ops = {\n\t.create\t= header_create,\n};\n\nstatic void netdev_setup(struct net_device *dev)\n{\n\tdev->hard_header_len\t= 0;\n\tdev->needed_tailroom\t= 0;\n\tdev->flags\t\t= IFF_RUNNING | IFF_MULTICAST;\n\tdev->watchdog_timeo\t= 0;\n\tdev->tx_queue_len\t= DEFAULT_TX_QUEUE_LEN;\n\n\tdev->netdev_ops\t\t= &netdev_ops;\n\tdev->header_ops\t\t= &header_ops;\n\tdev->needs_free_netdev\t= true;\n}\n\nstatic struct device_type bt_type = {\n\t.name\t= \"bluetooth\",\n};\n\nstatic void ifup(struct net_device *netdev)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = dev_open(netdev, NULL);\n\tif (err < 0)\n\t\tBT_INFO(\"iface %s cannot be opened (%d)\", netdev->name, err);\n\trtnl_unlock();\n}\n\nstatic void ifdown(struct net_device *netdev)\n{\n\trtnl_lock();\n\tdev_close(netdev);\n\trtnl_unlock();\n}\n\nstatic void do_notify_peers(struct work_struct *work)\n{\n\tstruct lowpan_btle_dev *dev = container_of(work, struct lowpan_btle_dev,\n\t\t\t\t\t\t   notify_peers.work);\n\n\tnetdev_notify_peers(dev->netdev);  \n}\n\nstatic bool is_bt_6lowpan(struct hci_conn *hcon)\n{\n\tif (hcon->type != LE_LINK)\n\t\treturn false;\n\n\tif (!enable_6lowpan)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct l2cap_chan *chan_create(void)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = l2cap_chan_create();\n\tif (!chan)\n\t\treturn NULL;\n\n\tl2cap_chan_set_defaults(chan);\n\n\tchan->chan_type = L2CAP_CHAN_CONN_ORIENTED;\n\tchan->mode = L2CAP_MODE_LE_FLOWCTL;\n\tchan->imtu = 1280;\n\n\treturn chan;\n}\n\nstatic struct l2cap_chan *add_peer_chan(struct l2cap_chan *chan,\n\t\t\t\t\tstruct lowpan_btle_dev *dev,\n\t\t\t\t\tbool new_netdev)\n{\n\tstruct lowpan_peer *peer;\n\n\tpeer = kzalloc(sizeof(*peer), GFP_ATOMIC);\n\tif (!peer)\n\t\treturn NULL;\n\n\tpeer->chan = chan;\n\n\tbaswap((void *)peer->lladdr, &chan->dst);\n\n\tlowpan_iphc_uncompress_eui48_lladdr(&peer->peer_addr, peer->lladdr);\n\n\tspin_lock(&devices_lock);\n\tINIT_LIST_HEAD(&peer->list);\n\tpeer_add(dev, peer);\n\tspin_unlock(&devices_lock);\n\n\t \n\tif (new_netdev)\n\t\tINIT_DELAYED_WORK(&dev->notify_peers, do_notify_peers);\n\tschedule_delayed_work(&dev->notify_peers, msecs_to_jiffies(100));\n\n\treturn peer->chan;\n}\n\nstatic int setup_netdev(struct l2cap_chan *chan, struct lowpan_btle_dev **dev)\n{\n\tstruct net_device *netdev;\n\tbdaddr_t addr;\n\tint err;\n\n\tnetdev = alloc_netdev(LOWPAN_PRIV_SIZE(sizeof(struct lowpan_btle_dev)),\n\t\t\t      IFACE_NAME_TEMPLATE, NET_NAME_UNKNOWN,\n\t\t\t      netdev_setup);\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tnetdev->addr_assign_type = NET_ADDR_PERM;\n\tbaswap(&addr, &chan->src);\n\t__dev_addr_set(netdev, &addr, sizeof(addr));\n\n\tnetdev->netdev_ops = &netdev_ops;\n\tSET_NETDEV_DEV(netdev, &chan->conn->hcon->hdev->dev);\n\tSET_NETDEV_DEVTYPE(netdev, &bt_type);\n\n\t*dev = lowpan_btle_dev(netdev);\n\t(*dev)->netdev = netdev;\n\t(*dev)->hdev = chan->conn->hcon->hdev;\n\tINIT_LIST_HEAD(&(*dev)->peers);\n\n\tspin_lock(&devices_lock);\n\tINIT_LIST_HEAD(&(*dev)->list);\n\tlist_add_rcu(&(*dev)->list, &bt_6lowpan_devices);\n\tspin_unlock(&devices_lock);\n\n\terr = lowpan_register_netdev(netdev, LOWPAN_LLTYPE_BTLE);\n\tif (err < 0) {\n\t\tBT_INFO(\"register_netdev failed %d\", err);\n\t\tspin_lock(&devices_lock);\n\t\tlist_del_rcu(&(*dev)->list);\n\t\tspin_unlock(&devices_lock);\n\t\tfree_netdev(netdev);\n\t\tgoto out;\n\t}\n\n\tBT_DBG(\"ifindex %d peer bdaddr %pMR type %d my addr %pMR type %d\",\n\t       netdev->ifindex, &chan->dst, chan->dst_type,\n\t       &chan->src, chan->src_type);\n\tset_bit(__LINK_STATE_PRESENT, &netdev->state);\n\n\treturn 0;\n\nout:\n\treturn err;\n}\n\nstatic inline void chan_ready_cb(struct l2cap_chan *chan)\n{\n\tstruct lowpan_btle_dev *dev;\n\tbool new_netdev = false;\n\n\tdev = lookup_dev(chan->conn);\n\n\tBT_DBG(\"chan %p conn %p dev %p\", chan, chan->conn, dev);\n\n\tif (!dev) {\n\t\tif (setup_netdev(chan, &dev) < 0) {\n\t\t\tl2cap_chan_del(chan, -ENOENT);\n\t\t\treturn;\n\t\t}\n\t\tnew_netdev = true;\n\t}\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn;\n\n\tadd_peer_chan(chan, dev, new_netdev);\n\tifup(dev->netdev);\n}\n\nstatic inline struct l2cap_chan *chan_new_conn_cb(struct l2cap_chan *pchan)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = chan_create();\n\tif (!chan)\n\t\treturn NULL;\n\n\tchan->ops = pchan->ops;\n\n\tBT_DBG(\"chan %p pchan %p\", chan, pchan);\n\n\treturn chan;\n}\n\nstatic void delete_netdev(struct work_struct *work)\n{\n\tstruct lowpan_btle_dev *entry = container_of(work,\n\t\t\t\t\t\t     struct lowpan_btle_dev,\n\t\t\t\t\t\t     delete_netdev);\n\n\tlowpan_unregister_netdev(entry->netdev);\n\n\t \n}\n\nstatic void chan_close_cb(struct l2cap_chan *chan)\n{\n\tstruct lowpan_btle_dev *entry;\n\tstruct lowpan_btle_dev *dev = NULL;\n\tstruct lowpan_peer *peer;\n\tint err = -ENOENT;\n\tbool last = false, remove = true;\n\n\tBT_DBG(\"chan %p conn %p\", chan, chan->conn);\n\n\tif (chan->conn && chan->conn->hcon) {\n\t\tif (!is_bt_6lowpan(chan->conn->hcon))\n\t\t\treturn;\n\n\t\t \n\t\tremove = false;\n\t}\n\n\tspin_lock(&devices_lock);\n\n\tlist_for_each_entry_rcu(entry, &bt_6lowpan_devices, list) {\n\t\tdev = lowpan_btle_dev(entry->netdev);\n\t\tpeer = __peer_lookup_chan(dev, chan);\n\t\tif (peer) {\n\t\t\tlast = peer_del(dev, peer);\n\t\t\terr = 0;\n\n\t\t\tBT_DBG(\"dev %p removing %speer %p\", dev,\n\t\t\t       last ? \"last \" : \"1 \", peer);\n\t\t\tBT_DBG(\"chan %p orig refcnt %u\", chan,\n\t\t\t       kref_read(&chan->kref));\n\n\t\t\tl2cap_chan_put(chan);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!err && last && dev && !atomic_read(&dev->peer_count)) {\n\t\tspin_unlock(&devices_lock);\n\n\t\tcancel_delayed_work_sync(&dev->notify_peers);\n\n\t\tifdown(dev->netdev);\n\n\t\tif (remove) {\n\t\t\tINIT_WORK(&entry->delete_netdev, delete_netdev);\n\t\t\tschedule_work(&entry->delete_netdev);\n\t\t}\n\t} else {\n\t\tspin_unlock(&devices_lock);\n\t}\n}\n\nstatic void chan_state_change_cb(struct l2cap_chan *chan, int state, int err)\n{\n\tBT_DBG(\"chan %p conn %p state %s err %d\", chan, chan->conn,\n\t       state_to_string(state), err);\n}\n\nstatic struct sk_buff *chan_alloc_skb_cb(struct l2cap_chan *chan,\n\t\t\t\t\t unsigned long hdr_len,\n\t\t\t\t\t unsigned long len, int nb)\n{\n\t \n\treturn bt_skb_alloc(hdr_len + len, GFP_ATOMIC);\n}\n\nstatic void chan_suspend_cb(struct l2cap_chan *chan)\n{\n\tstruct lowpan_btle_dev *dev;\n\n\tBT_DBG(\"chan %p suspend\", chan);\n\n\tdev = lookup_dev(chan->conn);\n\tif (!dev || !dev->netdev)\n\t\treturn;\n\n\tnetif_stop_queue(dev->netdev);\n}\n\nstatic void chan_resume_cb(struct l2cap_chan *chan)\n{\n\tstruct lowpan_btle_dev *dev;\n\n\tBT_DBG(\"chan %p resume\", chan);\n\n\tdev = lookup_dev(chan->conn);\n\tif (!dev || !dev->netdev)\n\t\treturn;\n\n\tnetif_wake_queue(dev->netdev);\n}\n\nstatic long chan_get_sndtimeo_cb(struct l2cap_chan *chan)\n{\n\treturn L2CAP_CONN_TIMEOUT;\n}\n\nstatic const struct l2cap_ops bt_6lowpan_chan_ops = {\n\t.name\t\t\t= \"L2CAP 6LoWPAN channel\",\n\t.new_connection\t\t= chan_new_conn_cb,\n\t.recv\t\t\t= chan_recv_cb,\n\t.close\t\t\t= chan_close_cb,\n\t.state_change\t\t= chan_state_change_cb,\n\t.ready\t\t\t= chan_ready_cb,\n\t.resume\t\t\t= chan_resume_cb,\n\t.suspend\t\t= chan_suspend_cb,\n\t.get_sndtimeo\t\t= chan_get_sndtimeo_cb,\n\t.alloc_skb\t\t= chan_alloc_skb_cb,\n\n\t.teardown\t\t= l2cap_chan_no_teardown,\n\t.defer\t\t\t= l2cap_chan_no_defer,\n\t.set_shutdown\t\t= l2cap_chan_no_set_shutdown,\n};\n\nstatic int bt_6lowpan_connect(bdaddr_t *addr, u8 dst_type)\n{\n\tstruct l2cap_chan *chan;\n\tint err;\n\n\tchan = chan_create();\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tchan->ops = &bt_6lowpan_chan_ops;\n\n\terr = l2cap_chan_connect(chan, cpu_to_le16(L2CAP_PSM_IPSP), 0,\n\t\t\t\t addr, dst_type);\n\n\tBT_DBG(\"chan %p err %d\", chan, err);\n\tif (err < 0)\n\t\tl2cap_chan_put(chan);\n\n\treturn err;\n}\n\nstatic int bt_6lowpan_disconnect(struct l2cap_conn *conn, u8 dst_type)\n{\n\tstruct lowpan_peer *peer;\n\n\tBT_DBG(\"conn %p dst type %u\", conn, dst_type);\n\n\tpeer = lookup_peer(conn);\n\tif (!peer)\n\t\treturn -ENOENT;\n\n\tBT_DBG(\"peer %p chan %p\", peer, peer->chan);\n\n\tl2cap_chan_close(peer->chan, ENOENT);\n\n\treturn 0;\n}\n\nstatic struct l2cap_chan *bt_6lowpan_listen(void)\n{\n\tbdaddr_t *addr = BDADDR_ANY;\n\tstruct l2cap_chan *chan;\n\tint err;\n\n\tif (!enable_6lowpan)\n\t\treturn NULL;\n\n\tchan = chan_create();\n\tif (!chan)\n\t\treturn NULL;\n\n\tchan->ops = &bt_6lowpan_chan_ops;\n\tchan->state = BT_LISTEN;\n\tchan->src_type = BDADDR_LE_PUBLIC;\n\n\tatomic_set(&chan->nesting, L2CAP_NESTING_PARENT);\n\n\tBT_DBG(\"chan %p src type %u\", chan, chan->src_type);\n\n\terr = l2cap_add_psm(chan, addr, cpu_to_le16(L2CAP_PSM_IPSP));\n\tif (err) {\n\t\tl2cap_chan_put(chan);\n\t\tBT_ERR(\"psm cannot be added err %d\", err);\n\t\treturn NULL;\n\t}\n\n\treturn chan;\n}\n\nstatic int get_l2cap_conn(char *buf, bdaddr_t *addr, u8 *addr_type,\n\t\t\t  struct l2cap_conn **conn)\n{\n\tstruct hci_conn *hcon;\n\tstruct hci_dev *hdev;\n\tint n;\n\n\tn = sscanf(buf, \"%hhx:%hhx:%hhx:%hhx:%hhx:%hhx %hhu\",\n\t\t   &addr->b[5], &addr->b[4], &addr->b[3],\n\t\t   &addr->b[2], &addr->b[1], &addr->b[0],\n\t\t   addr_type);\n\n\tif (n < 7)\n\t\treturn -EINVAL;\n\n\t \n\thdev = hci_get_route(addr, BDADDR_ANY, BDADDR_LE_PUBLIC);\n\tif (!hdev)\n\t\treturn -ENOENT;\n\n\thci_dev_lock(hdev);\n\thcon = hci_conn_hash_lookup_le(hdev, addr, *addr_type);\n\thci_dev_unlock(hdev);\n\thci_dev_put(hdev);\n\n\tif (!hcon)\n\t\treturn -ENOENT;\n\n\t*conn = (struct l2cap_conn *)hcon->l2cap_data;\n\n\tBT_DBG(\"conn %p dst %pMR type %u\", *conn, &hcon->dst, hcon->dst_type);\n\n\treturn 0;\n}\n\nstatic void disconnect_all_peers(void)\n{\n\tstruct lowpan_btle_dev *entry;\n\tstruct lowpan_peer *peer, *tmp_peer, *new_peer;\n\tstruct list_head peers;\n\n\tINIT_LIST_HEAD(&peers);\n\n\t \n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(entry, &bt_6lowpan_devices, list) {\n\t\tlist_for_each_entry_rcu(peer, &entry->peers, list) {\n\t\t\tnew_peer = kmalloc(sizeof(*new_peer), GFP_ATOMIC);\n\t\t\tif (!new_peer)\n\t\t\t\tbreak;\n\n\t\t\tnew_peer->chan = peer->chan;\n\t\t\tINIT_LIST_HEAD(&new_peer->list);\n\n\t\t\tlist_add(&new_peer->list, &peers);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tspin_lock(&devices_lock);\n\tlist_for_each_entry_safe(peer, tmp_peer, &peers, list) {\n\t\tl2cap_chan_close(peer->chan, ENOENT);\n\n\t\tlist_del_rcu(&peer->list);\n\t\tkfree_rcu(peer, rcu);\n\t}\n\tspin_unlock(&devices_lock);\n}\n\nstruct set_enable {\n\tstruct work_struct work;\n\tbool flag;\n};\n\nstatic void do_enable_set(struct work_struct *work)\n{\n\tstruct set_enable *set_enable = container_of(work,\n\t\t\t\t\t\t     struct set_enable, work);\n\n\tif (!set_enable->flag || enable_6lowpan != set_enable->flag)\n\t\t \n\t\tdisconnect_all_peers();\n\n\tenable_6lowpan = set_enable->flag;\n\n\tmutex_lock(&set_lock);\n\tif (listen_chan) {\n\t\tl2cap_chan_close(listen_chan, 0);\n\t\tl2cap_chan_put(listen_chan);\n\t}\n\n\tlisten_chan = bt_6lowpan_listen();\n\tmutex_unlock(&set_lock);\n\n\tkfree(set_enable);\n}\n\nstatic int lowpan_enable_set(void *data, u64 val)\n{\n\tstruct set_enable *set_enable;\n\n\tset_enable = kzalloc(sizeof(*set_enable), GFP_KERNEL);\n\tif (!set_enable)\n\t\treturn -ENOMEM;\n\n\tset_enable->flag = !!val;\n\tINIT_WORK(&set_enable->work, do_enable_set);\n\n\tschedule_work(&set_enable->work);\n\n\treturn 0;\n}\n\nstatic int lowpan_enable_get(void *data, u64 *val)\n{\n\t*val = enable_6lowpan;\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(lowpan_enable_fops, lowpan_enable_get,\n\t\t\t lowpan_enable_set, \"%llu\\n\");\n\nstatic ssize_t lowpan_control_write(struct file *fp,\n\t\t\t\t    const char __user *user_buffer,\n\t\t\t\t    size_t count,\n\t\t\t\t    loff_t *position)\n{\n\tchar buf[32];\n\tsize_t buf_size = min(count, sizeof(buf) - 1);\n\tint ret;\n\tbdaddr_t addr;\n\tu8 addr_type;\n\tstruct l2cap_conn *conn = NULL;\n\n\tif (copy_from_user(buf, user_buffer, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size] = '\\0';\n\n\tif (memcmp(buf, \"connect \", 8) == 0) {\n\t\tret = get_l2cap_conn(&buf[8], &addr, &addr_type, &conn);\n\t\tif (ret == -EINVAL)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&set_lock);\n\t\tif (listen_chan) {\n\t\t\tl2cap_chan_close(listen_chan, 0);\n\t\t\tl2cap_chan_put(listen_chan);\n\t\t\tlisten_chan = NULL;\n\t\t}\n\t\tmutex_unlock(&set_lock);\n\n\t\tif (conn) {\n\t\t\tstruct lowpan_peer *peer;\n\n\t\t\tif (!is_bt_6lowpan(conn->hcon))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tpeer = lookup_peer(conn);\n\t\t\tif (peer) {\n\t\t\t\tBT_DBG(\"6LoWPAN connection already exists\");\n\t\t\t\treturn -EALREADY;\n\t\t\t}\n\n\t\t\tBT_DBG(\"conn %p dst %pMR type %d user %u\", conn,\n\t\t\t       &conn->hcon->dst, conn->hcon->dst_type,\n\t\t\t       addr_type);\n\t\t}\n\n\t\tret = bt_6lowpan_connect(&addr, addr_type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn count;\n\t}\n\n\tif (memcmp(buf, \"disconnect \", 11) == 0) {\n\t\tret = get_l2cap_conn(&buf[11], &addr, &addr_type, &conn);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = bt_6lowpan_disconnect(conn, addr_type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn count;\n\t}\n\n\treturn count;\n}\n\nstatic int lowpan_control_show(struct seq_file *f, void *ptr)\n{\n\tstruct lowpan_btle_dev *entry;\n\tstruct lowpan_peer *peer;\n\n\tspin_lock(&devices_lock);\n\n\tlist_for_each_entry(entry, &bt_6lowpan_devices, list) {\n\t\tlist_for_each_entry(peer, &entry->peers, list)\n\t\t\tseq_printf(f, \"%pMR (type %u)\\n\",\n\t\t\t\t   &peer->chan->dst, peer->chan->dst_type);\n\t}\n\n\tspin_unlock(&devices_lock);\n\n\treturn 0;\n}\n\nstatic int lowpan_control_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lowpan_control_show, inode->i_private);\n}\n\nstatic const struct file_operations lowpan_control_fops = {\n\t.open\t\t= lowpan_control_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= lowpan_control_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic void disconnect_devices(void)\n{\n\tstruct lowpan_btle_dev *entry, *tmp, *new_dev;\n\tstruct list_head devices;\n\n\tINIT_LIST_HEAD(&devices);\n\n\t \n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(entry, &bt_6lowpan_devices, list) {\n\t\tnew_dev = kmalloc(sizeof(*new_dev), GFP_ATOMIC);\n\t\tif (!new_dev)\n\t\t\tbreak;\n\n\t\tnew_dev->netdev = entry->netdev;\n\t\tINIT_LIST_HEAD(&new_dev->list);\n\n\t\tlist_add_rcu(&new_dev->list, &devices);\n\t}\n\n\trcu_read_unlock();\n\n\tlist_for_each_entry_safe(entry, tmp, &devices, list) {\n\t\tifdown(entry->netdev);\n\t\tBT_DBG(\"Unregistering netdev %s %p\",\n\t\t       entry->netdev->name, entry->netdev);\n\t\tlowpan_unregister_netdev(entry->netdev);\n\t\tkfree(entry);\n\t}\n}\n\nstatic int device_event(struct notifier_block *unused,\n\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\tstruct lowpan_btle_dev *entry;\n\n\tif (netdev->type != ARPHRD_6LOWPAN)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tspin_lock(&devices_lock);\n\t\tlist_for_each_entry(entry, &bt_6lowpan_devices, list) {\n\t\t\tif (entry->netdev == netdev) {\n\t\t\t\tBT_DBG(\"Unregistered netdev %s %p\",\n\t\t\t\t       netdev->name, netdev);\n\t\t\t\tlist_del(&entry->list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&devices_lock);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block bt_6lowpan_dev_notifier = {\n\t.notifier_call = device_event,\n};\n\nstatic int __init bt_6lowpan_init(void)\n{\n\tlowpan_enable_debugfs = debugfs_create_file_unsafe(\"6lowpan_enable\",\n\t\t\t\t\t\t\t   0644, bt_debugfs,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   &lowpan_enable_fops);\n\tlowpan_control_debugfs = debugfs_create_file(\"6lowpan_control\", 0644,\n\t\t\t\t\t\t     bt_debugfs, NULL,\n\t\t\t\t\t\t     &lowpan_control_fops);\n\n\treturn register_netdevice_notifier(&bt_6lowpan_dev_notifier);\n}\n\nstatic void __exit bt_6lowpan_exit(void)\n{\n\tdebugfs_remove(lowpan_enable_debugfs);\n\tdebugfs_remove(lowpan_control_debugfs);\n\n\tif (listen_chan) {\n\t\tl2cap_chan_close(listen_chan, 0);\n\t\tl2cap_chan_put(listen_chan);\n\t}\n\n\tdisconnect_devices();\n\n\tunregister_netdevice_notifier(&bt_6lowpan_dev_notifier);\n}\n\nmodule_init(bt_6lowpan_init);\nmodule_exit(bt_6lowpan_exit);\n\nMODULE_AUTHOR(\"Jukka Rissanen <jukka.rissanen@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Bluetooth 6LoWPAN\");\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}