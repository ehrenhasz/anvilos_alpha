{
  "module_name": "hci_debugfs.c",
  "hash_id": "9b1c1012748fa6f922187124f47d858689e81cc633b7b7ad815c00d71d23299b",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/hci_debugfs.c",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n#include <linux/kstrtox.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"smp.h\"\n#include \"hci_request.h\"\n#include \"hci_debugfs.h\"\n\n#define DEFINE_QUIRK_ATTRIBUTE(__name, __quirk)\t\t\t\t      \\\nstatic ssize_t __name ## _read(struct file *file,\t\t\t      \\\n\t\t\t\tchar __user *user_buf,\t\t\t      \\\n\t\t\t\tsize_t count, loff_t *ppos)\t\t      \\\n{\t\t\t\t\t\t\t\t\t      \\\n\tstruct hci_dev *hdev = file->private_data;\t\t\t      \\\n\tchar buf[3];\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tbuf[0] = test_bit(__quirk, &hdev->quirks) ? 'Y' : 'N';\t\t      \\\n\tbuf[1] = '\\n';\t\t\t\t\t\t\t      \\\n\tbuf[2] = '\\0';\t\t\t\t\t\t\t      \\\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nstatic ssize_t __name ## _write(struct file *file,\t\t\t      \\\n\t\t\t\t const char __user *user_buf,\t\t      \\\n\t\t\t\t size_t count, loff_t *ppos)\t\t      \\\n{\t\t\t\t\t\t\t\t\t      \\\n\tstruct hci_dev *hdev = file->private_data;\t\t\t      \\\n\tbool enable;\t\t\t\t\t\t\t      \\\n\tint err;\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (test_bit(HCI_UP, &hdev->flags))\t\t\t\t      \\\n\t\treturn -EBUSY;\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\terr = kstrtobool_from_user(user_buf, count, &enable);\t\t      \\\n\tif (err)\t\t\t\t\t\t\t      \\\n\t\treturn err;\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (enable == test_bit(__quirk, &hdev->quirks))\t\t\t      \\\n\t\treturn -EALREADY;\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tchange_bit(__quirk, &hdev->quirks);\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\treturn count;\t\t\t\t\t\t\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nstatic const struct file_operations __name ## _fops = {\t\t\t      \\\n\t.open\t\t= simple_open,\t\t\t\t\t      \\\n\t.read\t\t= __name ## _read,\t\t\t\t      \\\n\t.write\t\t= __name ## _write,\t\t\t\t      \\\n\t.llseek\t\t= default_llseek,\t\t\t\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\n\n#define DEFINE_INFO_ATTRIBUTE(__name, __field)\t\t\t\t      \\\nstatic int __name ## _show(struct seq_file *f, void *ptr)\t\t      \\\n{\t\t\t\t\t\t\t\t\t      \\\n\tstruct hci_dev *hdev = f->private;\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\thci_dev_lock(hdev);\t\t\t\t\t\t      \\\n\tseq_printf(f, \"%s\\n\", hdev->__field ? : \"\");\t\t\t      \\\n\thci_dev_unlock(hdev);\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\treturn 0;\t\t\t\t\t\t\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nDEFINE_SHOW_ATTRIBUTE(__name)\n\nstatic int features_show(struct seq_file *f, void *ptr)\n{\n\tstruct hci_dev *hdev = f->private;\n\tu8 p;\n\n\thci_dev_lock(hdev);\n\tfor (p = 0; p < HCI_MAX_PAGES && p <= hdev->max_page; p++)\n\t\tseq_printf(f, \"%2u: %8ph\\n\", p, hdev->features[p]);\n\tif (lmp_le_capable(hdev))\n\t\tseq_printf(f, \"LE: %8ph\\n\", hdev->le_features);\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(features);\n\nstatic int device_id_show(struct seq_file *f, void *ptr)\n{\n\tstruct hci_dev *hdev = f->private;\n\n\thci_dev_lock(hdev);\n\tseq_printf(f, \"%4.4x:%4.4x:%4.4x:%4.4x\\n\", hdev->devid_source,\n\t\t  hdev->devid_vendor, hdev->devid_product, hdev->devid_version);\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(device_id);\n\nstatic int device_list_show(struct seq_file *f, void *ptr)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct hci_conn_params *p;\n\tstruct bdaddr_list *b;\n\n\thci_dev_lock(hdev);\n\tlist_for_each_entry(b, &hdev->accept_list, list)\n\t\tseq_printf(f, \"%pMR (type %u)\\n\", &b->bdaddr, b->bdaddr_type);\n\tlist_for_each_entry(p, &hdev->le_conn_params, list) {\n\t\tseq_printf(f, \"%pMR (type %u) %u\\n\", &p->addr, p->addr_type,\n\t\t\t   p->auto_connect);\n\t}\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(device_list);\n\nstatic int blacklist_show(struct seq_file *f, void *p)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct bdaddr_list *b;\n\n\thci_dev_lock(hdev);\n\tlist_for_each_entry(b, &hdev->reject_list, list)\n\t\tseq_printf(f, \"%pMR (type %u)\\n\", &b->bdaddr, b->bdaddr_type);\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(blacklist);\n\nstatic int blocked_keys_show(struct seq_file *f, void *p)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct blocked_key *key;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(key, &hdev->blocked_keys, list)\n\t\tseq_printf(f, \"%u %*phN\\n\", key->type, 16, key->val);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(blocked_keys);\n\nstatic int uuids_show(struct seq_file *f, void *p)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct bt_uuid *uuid;\n\n\thci_dev_lock(hdev);\n\tlist_for_each_entry(uuid, &hdev->uuids, list) {\n\t\tu8 i, val[16];\n\n\t\t \n\t\tfor (i = 0; i < 16; i++)\n\t\t\tval[i] = uuid->uuid[15 - i];\n\n\t\tseq_printf(f, \"%pUb\\n\", val);\n\t}\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(uuids);\n\nstatic int remote_oob_show(struct seq_file *f, void *ptr)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct oob_data *data;\n\n\thci_dev_lock(hdev);\n\tlist_for_each_entry(data, &hdev->remote_oob_data, list) {\n\t\tseq_printf(f, \"%pMR (type %u) %u %*phN %*phN %*phN %*phN\\n\",\n\t\t\t   &data->bdaddr, data->bdaddr_type, data->present,\n\t\t\t   16, data->hash192, 16, data->rand192,\n\t\t\t   16, data->hash256, 16, data->rand256);\n\t}\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(remote_oob);\n\nstatic int conn_info_min_age_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val == 0 || val > hdev->conn_info_max_age)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->conn_info_min_age = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int conn_info_min_age_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->conn_info_min_age;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(conn_info_min_age_fops, conn_info_min_age_get,\n\t\t\t  conn_info_min_age_set, \"%llu\\n\");\n\nstatic int conn_info_max_age_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val == 0 || val < hdev->conn_info_min_age)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->conn_info_max_age = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int conn_info_max_age_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->conn_info_max_age;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(conn_info_max_age_fops, conn_info_max_age_get,\n\t\t\t  conn_info_max_age_set, \"%llu\\n\");\n\nstatic ssize_t use_debug_keys_read(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = hci_dev_test_flag(hdev, HCI_USE_DEBUG_KEYS) ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic const struct file_operations use_debug_keys_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= use_debug_keys_read,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic ssize_t sc_only_mode_read(struct file *file, char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = hci_dev_test_flag(hdev, HCI_SC_ONLY) ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic const struct file_operations sc_only_mode_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= sc_only_mode_read,\n\t.llseek\t\t= default_llseek,\n};\n\nDEFINE_INFO_ATTRIBUTE(hardware_info, hw_info);\nDEFINE_INFO_ATTRIBUTE(firmware_info, fw_info);\n\nvoid hci_debugfs_create_common(struct hci_dev *hdev)\n{\n\tdebugfs_create_file(\"features\", 0444, hdev->debugfs, hdev,\n\t\t\t    &features_fops);\n\tdebugfs_create_u16(\"manufacturer\", 0444, hdev->debugfs,\n\t\t\t   &hdev->manufacturer);\n\tdebugfs_create_u8(\"hci_version\", 0444, hdev->debugfs, &hdev->hci_ver);\n\tdebugfs_create_u16(\"hci_revision\", 0444, hdev->debugfs, &hdev->hci_rev);\n\tdebugfs_create_u8(\"hardware_error\", 0444, hdev->debugfs,\n\t\t\t  &hdev->hw_error_code);\n\tdebugfs_create_file(\"device_id\", 0444, hdev->debugfs, hdev,\n\t\t\t    &device_id_fops);\n\n\tdebugfs_create_file(\"device_list\", 0444, hdev->debugfs, hdev,\n\t\t\t    &device_list_fops);\n\tdebugfs_create_file(\"blacklist\", 0444, hdev->debugfs, hdev,\n\t\t\t    &blacklist_fops);\n\tdebugfs_create_file(\"blocked_keys\", 0444, hdev->debugfs, hdev,\n\t\t\t    &blocked_keys_fops);\n\tdebugfs_create_file(\"uuids\", 0444, hdev->debugfs, hdev, &uuids_fops);\n\tdebugfs_create_file(\"remote_oob\", 0400, hdev->debugfs, hdev,\n\t\t\t    &remote_oob_fops);\n\n\tdebugfs_create_file(\"conn_info_min_age\", 0644, hdev->debugfs, hdev,\n\t\t\t    &conn_info_min_age_fops);\n\tdebugfs_create_file(\"conn_info_max_age\", 0644, hdev->debugfs, hdev,\n\t\t\t    &conn_info_max_age_fops);\n\n\tif (lmp_ssp_capable(hdev) || lmp_le_capable(hdev))\n\t\tdebugfs_create_file(\"use_debug_keys\", 0444, hdev->debugfs,\n\t\t\t\t    hdev, &use_debug_keys_fops);\n\n\tif (lmp_sc_capable(hdev) || lmp_le_capable(hdev))\n\t\tdebugfs_create_file(\"sc_only_mode\", 0444, hdev->debugfs,\n\t\t\t\t    hdev, &sc_only_mode_fops);\n\n\tif (hdev->hw_info)\n\t\tdebugfs_create_file(\"hardware_info\", 0444, hdev->debugfs,\n\t\t\t\t    hdev, &hardware_info_fops);\n\n\tif (hdev->fw_info)\n\t\tdebugfs_create_file(\"firmware_info\", 0444, hdev->debugfs,\n\t\t\t\t    hdev, &firmware_info_fops);\n}\n\nstatic int inquiry_cache_show(struct seq_file *f, void *p)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct discovery_state *cache = &hdev->discovery;\n\tstruct inquiry_entry *e;\n\n\thci_dev_lock(hdev);\n\n\tlist_for_each_entry(e, &cache->all, all) {\n\t\tstruct inquiry_data *data = &e->data;\n\t\tseq_printf(f, \"%pMR %d %d %d 0x%.2x%.2x%.2x 0x%.4x %d %d %u\\n\",\n\t\t\t   &data->bdaddr,\n\t\t\t   data->pscan_rep_mode, data->pscan_period_mode,\n\t\t\t   data->pscan_mode, data->dev_class[2],\n\t\t\t   data->dev_class[1], data->dev_class[0],\n\t\t\t   __le16_to_cpu(data->clock_offset),\n\t\t\t   data->rssi, data->ssp_mode, e->timestamp);\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(inquiry_cache);\n\nstatic int link_keys_show(struct seq_file *f, void *ptr)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct link_key *key;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(key, &hdev->link_keys, list)\n\t\tseq_printf(f, \"%pMR %u %*phN %u\\n\", &key->bdaddr, key->type,\n\t\t\t   HCI_LINK_KEY_SIZE, key->val, key->pin_len);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(link_keys);\n\nstatic int dev_class_show(struct seq_file *f, void *ptr)\n{\n\tstruct hci_dev *hdev = f->private;\n\n\thci_dev_lock(hdev);\n\tseq_printf(f, \"0x%.2x%.2x%.2x\\n\", hdev->dev_class[2],\n\t\t   hdev->dev_class[1], hdev->dev_class[0]);\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(dev_class);\n\nstatic int voice_setting_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->voice_setting;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(voice_setting_fops, voice_setting_get,\n\t\t\t  NULL, \"0x%4.4llx\\n\");\n\nstatic ssize_t ssp_debug_mode_read(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = hdev->ssp_debug_mode ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic const struct file_operations ssp_debug_mode_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= ssp_debug_mode_read,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic int auto_accept_delay_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\thdev->auto_accept_delay = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int min_encrypt_key_size_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val < 1 || val > 16)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->min_enc_key_size = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int min_encrypt_key_size_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->min_enc_key_size;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(min_encrypt_key_size_fops,\n\t\t\t  min_encrypt_key_size_get,\n\t\t\t  min_encrypt_key_size_set, \"%llu\\n\");\n\nstatic int auto_accept_delay_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->auto_accept_delay;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(auto_accept_delay_fops, auto_accept_delay_get,\n\t\t\t  auto_accept_delay_set, \"%llu\\n\");\n\nstatic ssize_t force_bredr_smp_read(struct file *file,\n\t\t\t\t    char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = hci_dev_test_flag(hdev, HCI_FORCE_BREDR_SMP) ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t force_bredr_smp_write(struct file *file,\n\t\t\t\t     const char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tbool enable;\n\tint err;\n\n\terr = kstrtobool_from_user(user_buf, count, &enable);\n\tif (err)\n\t\treturn err;\n\n\terr = smp_force_bredr(hdev, enable);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic const struct file_operations force_bredr_smp_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= force_bredr_smp_read,\n\t.write\t\t= force_bredr_smp_write,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic int idle_timeout_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val != 0 && (val < 500 || val > 3600000))\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->idle_timeout = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int idle_timeout_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->idle_timeout;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(idle_timeout_fops, idle_timeout_get,\n\t\t\t  idle_timeout_set, \"%llu\\n\");\n\nstatic int sniff_min_interval_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val == 0 || val % 2 || val > hdev->sniff_max_interval)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->sniff_min_interval = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int sniff_min_interval_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->sniff_min_interval;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(sniff_min_interval_fops, sniff_min_interval_get,\n\t\t\t  sniff_min_interval_set, \"%llu\\n\");\n\nstatic int sniff_max_interval_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val == 0 || val % 2 || val < hdev->sniff_min_interval)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->sniff_max_interval = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int sniff_max_interval_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->sniff_max_interval;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(sniff_max_interval_fops, sniff_max_interval_get,\n\t\t\t  sniff_max_interval_set, \"%llu\\n\");\n\nvoid hci_debugfs_create_bredr(struct hci_dev *hdev)\n{\n\tdebugfs_create_file(\"inquiry_cache\", 0444, hdev->debugfs, hdev,\n\t\t\t    &inquiry_cache_fops);\n\tdebugfs_create_file(\"link_keys\", 0400, hdev->debugfs, hdev,\n\t\t\t    &link_keys_fops);\n\tdebugfs_create_file(\"dev_class\", 0444, hdev->debugfs, hdev,\n\t\t\t    &dev_class_fops);\n\tdebugfs_create_file(\"voice_setting\", 0444, hdev->debugfs, hdev,\n\t\t\t    &voice_setting_fops);\n\n\t \n\tif (!lmp_sc_capable(hdev))\n\t\tdebugfs_create_file(\"force_bredr_smp\", 0644, hdev->debugfs,\n\t\t\t\t    hdev, &force_bredr_smp_fops);\n\n\tif (lmp_ssp_capable(hdev)) {\n\t\tdebugfs_create_file(\"ssp_debug_mode\", 0444, hdev->debugfs,\n\t\t\t\t    hdev, &ssp_debug_mode_fops);\n\t\tdebugfs_create_file(\"min_encrypt_key_size\", 0644, hdev->debugfs,\n\t\t\t\t    hdev, &min_encrypt_key_size_fops);\n\t\tdebugfs_create_file(\"auto_accept_delay\", 0644, hdev->debugfs,\n\t\t\t\t    hdev, &auto_accept_delay_fops);\n\t}\n\n\tif (lmp_sniff_capable(hdev)) {\n\t\tdebugfs_create_file(\"idle_timeout\", 0644, hdev->debugfs,\n\t\t\t\t    hdev, &idle_timeout_fops);\n\t\tdebugfs_create_file(\"sniff_min_interval\", 0644, hdev->debugfs,\n\t\t\t\t    hdev, &sniff_min_interval_fops);\n\t\tdebugfs_create_file(\"sniff_max_interval\", 0644, hdev->debugfs,\n\t\t\t\t    hdev, &sniff_max_interval_fops);\n\t}\n}\n\nstatic int identity_show(struct seq_file *f, void *p)\n{\n\tstruct hci_dev *hdev = f->private;\n\tbdaddr_t addr;\n\tu8 addr_type;\n\n\thci_dev_lock(hdev);\n\n\thci_copy_identity_address(hdev, &addr, &addr_type);\n\n\tseq_printf(f, \"%pMR (type %u) %*phN %pMR\\n\", &addr, addr_type,\n\t\t   16, hdev->irk, &hdev->rpa);\n\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(identity);\n\nstatic int rpa_timeout_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\t \n\tif (val < 30 || val > (60 * 60 * 24))\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->rpa_timeout = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int rpa_timeout_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->rpa_timeout;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(rpa_timeout_fops, rpa_timeout_get,\n\t\t\t  rpa_timeout_set, \"%llu\\n\");\n\nstatic int random_address_show(struct seq_file *f, void *p)\n{\n\tstruct hci_dev *hdev = f->private;\n\n\thci_dev_lock(hdev);\n\tseq_printf(f, \"%pMR\\n\", &hdev->random_addr);\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(random_address);\n\nstatic int static_address_show(struct seq_file *f, void *p)\n{\n\tstruct hci_dev *hdev = f->private;\n\n\thci_dev_lock(hdev);\n\tseq_printf(f, \"%pMR\\n\", &hdev->static_addr);\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(static_address);\n\nstatic ssize_t force_static_address_read(struct file *file,\n\t\t\t\t\t char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t force_static_address_write(struct file *file,\n\t\t\t\t\t  const char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tbool enable;\n\tint err;\n\n\tif (hdev_is_powered(hdev))\n\t\treturn -EBUSY;\n\n\terr = kstrtobool_from_user(user_buf, count, &enable);\n\tif (err)\n\t\treturn err;\n\n\tif (enable == hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR))\n\t\treturn -EALREADY;\n\n\thci_dev_change_flag(hdev, HCI_FORCE_STATIC_ADDR);\n\n\treturn count;\n}\n\nstatic const struct file_operations force_static_address_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= force_static_address_read,\n\t.write\t\t= force_static_address_write,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic int white_list_show(struct seq_file *f, void *ptr)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct bdaddr_list *b;\n\n\thci_dev_lock(hdev);\n\tlist_for_each_entry(b, &hdev->le_accept_list, list)\n\t\tseq_printf(f, \"%pMR (type %u)\\n\", &b->bdaddr, b->bdaddr_type);\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(white_list);\n\nstatic int resolv_list_show(struct seq_file *f, void *ptr)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct bdaddr_list *b;\n\n\thci_dev_lock(hdev);\n\tlist_for_each_entry(b, &hdev->le_resolv_list, list)\n\t\tseq_printf(f, \"%pMR (type %u)\\n\", &b->bdaddr, b->bdaddr_type);\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(resolv_list);\n\nstatic int identity_resolving_keys_show(struct seq_file *f, void *ptr)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct smp_irk *irk;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(irk, &hdev->identity_resolving_keys, list) {\n\t\tseq_printf(f, \"%pMR (type %u) %*phN %pMR\\n\",\n\t\t\t   &irk->bdaddr, irk->addr_type,\n\t\t\t   16, irk->val, &irk->rpa);\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(identity_resolving_keys);\n\nstatic int long_term_keys_show(struct seq_file *f, void *ptr)\n{\n\tstruct hci_dev *hdev = f->private;\n\tstruct smp_ltk *ltk;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ltk, &hdev->long_term_keys, list)\n\t\tseq_printf(f, \"%pMR (type %u) %u 0x%02x %u %.4x %.16llx %*phN\\n\",\n\t\t\t   &ltk->bdaddr, ltk->bdaddr_type, ltk->authenticated,\n\t\t\t   ltk->type, ltk->enc_size, __le16_to_cpu(ltk->ediv),\n\t\t\t   __le64_to_cpu(ltk->rand), 16, ltk->val);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(long_term_keys);\n\nstatic int conn_min_interval_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val < 0x0006 || val > 0x0c80 || val > hdev->le_conn_max_interval)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->le_conn_min_interval = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int conn_min_interval_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->le_conn_min_interval;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(conn_min_interval_fops, conn_min_interval_get,\n\t\t\t  conn_min_interval_set, \"%llu\\n\");\n\nstatic int conn_max_interval_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val < 0x0006 || val > 0x0c80 || val < hdev->le_conn_min_interval)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->le_conn_max_interval = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int conn_max_interval_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->le_conn_max_interval;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(conn_max_interval_fops, conn_max_interval_get,\n\t\t\t  conn_max_interval_set, \"%llu\\n\");\n\nstatic int conn_latency_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val > 0x01f3)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->le_conn_latency = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int conn_latency_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->le_conn_latency;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(conn_latency_fops, conn_latency_get,\n\t\t\t  conn_latency_set, \"%llu\\n\");\n\nstatic int supervision_timeout_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val < 0x000a || val > 0x0c80)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->le_supv_timeout = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int supervision_timeout_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->le_supv_timeout;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(supervision_timeout_fops, supervision_timeout_get,\n\t\t\t  supervision_timeout_set, \"%llu\\n\");\n\nstatic int adv_channel_map_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val < 0x01 || val > 0x07)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->le_adv_channel_map = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int adv_channel_map_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->le_adv_channel_map;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(adv_channel_map_fops, adv_channel_map_get,\n\t\t\t  adv_channel_map_set, \"%llu\\n\");\n\nstatic int adv_min_interval_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val < 0x0020 || val > 0x4000 || val > hdev->le_adv_max_interval)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->le_adv_min_interval = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int adv_min_interval_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->le_adv_min_interval;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(adv_min_interval_fops, adv_min_interval_get,\n\t\t\t  adv_min_interval_set, \"%llu\\n\");\n\nstatic int adv_max_interval_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val < 0x0020 || val > 0x4000 || val < hdev->le_adv_min_interval)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->le_adv_max_interval = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int adv_max_interval_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->le_adv_max_interval;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(adv_max_interval_fops, adv_max_interval_get,\n\t\t\t  adv_max_interval_set, \"%llu\\n\");\n\nstatic int min_key_size_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\tif (val > hdev->le_max_key_size || val < SMP_MIN_ENC_KEY_SIZE) {\n\t\thci_dev_unlock(hdev);\n\t\treturn -EINVAL;\n\t}\n\n\thdev->le_min_key_size = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int min_key_size_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->le_min_key_size;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(min_key_size_fops, min_key_size_get,\n\t\t\t  min_key_size_set, \"%llu\\n\");\n\nstatic int max_key_size_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\tif (val > SMP_MAX_ENC_KEY_SIZE || val < hdev->le_min_key_size) {\n\t\thci_dev_unlock(hdev);\n\t\treturn -EINVAL;\n\t}\n\n\thdev->le_max_key_size = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int max_key_size_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->le_max_key_size;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(max_key_size_fops, max_key_size_get,\n\t\t\t  max_key_size_set, \"%llu\\n\");\n\nstatic int auth_payload_timeout_set(void *data, u64 val)\n{\n\tstruct hci_dev *hdev = data;\n\n\tif (val < 0x0001 || val > 0xffff)\n\t\treturn -EINVAL;\n\n\thci_dev_lock(hdev);\n\thdev->auth_payload_timeout = val;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int auth_payload_timeout_get(void *data, u64 *val)\n{\n\tstruct hci_dev *hdev = data;\n\n\thci_dev_lock(hdev);\n\t*val = hdev->auth_payload_timeout;\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(auth_payload_timeout_fops,\n\t\t\t  auth_payload_timeout_get,\n\t\t\t  auth_payload_timeout_set, \"%llu\\n\");\n\nstatic ssize_t force_no_mitm_read(struct file *file,\n\t\t\t\t  char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = hci_dev_test_flag(hdev, HCI_FORCE_NO_MITM) ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t force_no_mitm_write(struct file *file,\n\t\t\t\t   const char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tchar buf[32];\n\tsize_t buf_size = min(count, (sizeof(buf) - 1));\n\tbool enable;\n\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size] = '\\0';\n\tif (kstrtobool(buf, &enable))\n\t\treturn -EINVAL;\n\n\tif (enable == hci_dev_test_flag(hdev, HCI_FORCE_NO_MITM))\n\t\treturn -EALREADY;\n\n\thci_dev_change_flag(hdev, HCI_FORCE_NO_MITM);\n\n\treturn count;\n}\n\nstatic const struct file_operations force_no_mitm_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= force_no_mitm_read,\n\t.write\t\t= force_no_mitm_write,\n\t.llseek\t\t= default_llseek,\n};\n\nDEFINE_QUIRK_ATTRIBUTE(quirk_strict_duplicate_filter,\n\t\t       HCI_QUIRK_STRICT_DUPLICATE_FILTER);\nDEFINE_QUIRK_ATTRIBUTE(quirk_simultaneous_discovery,\n\t\t       HCI_QUIRK_SIMULTANEOUS_DISCOVERY);\n\nvoid hci_debugfs_create_le(struct hci_dev *hdev)\n{\n\tdebugfs_create_file(\"identity\", 0400, hdev->debugfs, hdev,\n\t\t\t    &identity_fops);\n\tdebugfs_create_file(\"rpa_timeout\", 0644, hdev->debugfs, hdev,\n\t\t\t    &rpa_timeout_fops);\n\tdebugfs_create_file(\"random_address\", 0444, hdev->debugfs, hdev,\n\t\t\t    &random_address_fops);\n\tdebugfs_create_file(\"static_address\", 0444, hdev->debugfs, hdev,\n\t\t\t    &static_address_fops);\n\n\t \n\tif (bacmp(&hdev->bdaddr, BDADDR_ANY))\n\t\tdebugfs_create_file(\"force_static_address\", 0644,\n\t\t\t\t    hdev->debugfs, hdev,\n\t\t\t\t    &force_static_address_fops);\n\n\tdebugfs_create_u8(\"white_list_size\", 0444, hdev->debugfs,\n\t\t\t  &hdev->le_accept_list_size);\n\tdebugfs_create_file(\"white_list\", 0444, hdev->debugfs, hdev,\n\t\t\t    &white_list_fops);\n\tdebugfs_create_u8(\"resolv_list_size\", 0444, hdev->debugfs,\n\t\t\t  &hdev->le_resolv_list_size);\n\tdebugfs_create_file(\"resolv_list\", 0444, hdev->debugfs, hdev,\n\t\t\t    &resolv_list_fops);\n\tdebugfs_create_file(\"identity_resolving_keys\", 0400, hdev->debugfs,\n\t\t\t    hdev, &identity_resolving_keys_fops);\n\tdebugfs_create_file(\"long_term_keys\", 0400, hdev->debugfs, hdev,\n\t\t\t    &long_term_keys_fops);\n\tdebugfs_create_file(\"conn_min_interval\", 0644, hdev->debugfs, hdev,\n\t\t\t    &conn_min_interval_fops);\n\tdebugfs_create_file(\"conn_max_interval\", 0644, hdev->debugfs, hdev,\n\t\t\t    &conn_max_interval_fops);\n\tdebugfs_create_file(\"conn_latency\", 0644, hdev->debugfs, hdev,\n\t\t\t    &conn_latency_fops);\n\tdebugfs_create_file(\"supervision_timeout\", 0644, hdev->debugfs, hdev,\n\t\t\t    &supervision_timeout_fops);\n\tdebugfs_create_file(\"adv_channel_map\", 0644, hdev->debugfs, hdev,\n\t\t\t    &adv_channel_map_fops);\n\tdebugfs_create_file(\"adv_min_interval\", 0644, hdev->debugfs, hdev,\n\t\t\t    &adv_min_interval_fops);\n\tdebugfs_create_file(\"adv_max_interval\", 0644, hdev->debugfs, hdev,\n\t\t\t    &adv_max_interval_fops);\n\tdebugfs_create_u16(\"discov_interleaved_timeout\", 0644, hdev->debugfs,\n\t\t\t   &hdev->discov_interleaved_timeout);\n\tdebugfs_create_file(\"min_key_size\", 0644, hdev->debugfs, hdev,\n\t\t\t    &min_key_size_fops);\n\tdebugfs_create_file(\"max_key_size\", 0644, hdev->debugfs, hdev,\n\t\t\t    &max_key_size_fops);\n\tdebugfs_create_file(\"auth_payload_timeout\", 0644, hdev->debugfs, hdev,\n\t\t\t    &auth_payload_timeout_fops);\n\tdebugfs_create_file(\"force_no_mitm\", 0644, hdev->debugfs, hdev,\n\t\t\t    &force_no_mitm_fops);\n\n\tdebugfs_create_file(\"quirk_strict_duplicate_filter\", 0644,\n\t\t\t    hdev->debugfs, hdev,\n\t\t\t    &quirk_strict_duplicate_filter_fops);\n\tdebugfs_create_file(\"quirk_simultaneous_discovery\", 0644,\n\t\t\t    hdev->debugfs, hdev,\n\t\t\t    &quirk_simultaneous_discovery_fops);\n}\n\nvoid hci_debugfs_create_conn(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tchar name[6];\n\n\tif (IS_ERR_OR_NULL(hdev->debugfs) || conn->debugfs)\n\t\treturn;\n\n\tsnprintf(name, sizeof(name), \"%u\", conn->handle);\n\tconn->debugfs = debugfs_create_dir(name, hdev->debugfs);\n}\n\nstatic ssize_t dut_mode_read(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = hci_dev_test_flag(hdev, HCI_DUT_MODE) ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t dut_mode_write(struct file *file, const char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tstruct sk_buff *skb;\n\tbool enable;\n\tint err;\n\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n\terr = kstrtobool_from_user(user_buf, count, &enable);\n\tif (err)\n\t\treturn err;\n\n\tif (enable == hci_dev_test_flag(hdev, HCI_DUT_MODE))\n\t\treturn -EALREADY;\n\n\thci_req_sync_lock(hdev);\n\tif (enable)\n\t\tskb = __hci_cmd_sync(hdev, HCI_OP_ENABLE_DUT_MODE, 0, NULL,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n\telse\n\t\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n\thci_req_sync_unlock(hdev);\n\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tkfree_skb(skb);\n\n\thci_dev_change_flag(hdev, HCI_DUT_MODE);\n\n\treturn count;\n}\n\nstatic const struct file_operations dut_mode_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= dut_mode_read,\n\t.write\t\t= dut_mode_write,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic ssize_t vendor_diag_read(struct file *file, char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = hci_dev_test_flag(hdev, HCI_VENDOR_DIAG) ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t vendor_diag_write(struct file *file, const char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct hci_dev *hdev = file->private_data;\n\tbool enable;\n\tint err;\n\n\terr = kstrtobool_from_user(user_buf, count, &enable);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (test_bit(HCI_QUIRK_NON_PERSISTENT_DIAG, &hdev->quirks) &&\n\t    (!test_bit(HCI_RUNNING, &hdev->flags) ||\n\t     hci_dev_test_flag(hdev, HCI_USER_CHANNEL)))\n\t\tgoto done;\n\n\thci_req_sync_lock(hdev);\n\terr = hdev->set_diag(hdev, enable);\n\thci_req_sync_unlock(hdev);\n\n\tif (err < 0)\n\t\treturn err;\n\ndone:\n\tif (enable)\n\t\thci_dev_set_flag(hdev, HCI_VENDOR_DIAG);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_VENDOR_DIAG);\n\n\treturn count;\n}\n\nstatic const struct file_operations vendor_diag_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= vendor_diag_read,\n\t.write\t\t= vendor_diag_write,\n\t.llseek\t\t= default_llseek,\n};\n\nvoid hci_debugfs_create_basic(struct hci_dev *hdev)\n{\n\tdebugfs_create_file(\"dut_mode\", 0644, hdev->debugfs, hdev,\n\t\t\t    &dut_mode_fops);\n\n\tif (hdev->set_diag)\n\t\tdebugfs_create_file(\"vendor_diag\", 0644, hdev->debugfs, hdev,\n\t\t\t\t    &vendor_diag_fops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}