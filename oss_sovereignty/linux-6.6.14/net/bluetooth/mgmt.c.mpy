{
  "module_name": "mgmt.c",
  "hash_id": "e5e56822b02ac34da9a5db62e7ef5852606829a001e488dcee245d5d69bc85d7",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/mgmt.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/hci_sock.h>\n#include <net/bluetooth/l2cap.h>\n#include <net/bluetooth/mgmt.h>\n\n#include \"hci_request.h\"\n#include \"smp.h\"\n#include \"mgmt_util.h\"\n#include \"mgmt_config.h\"\n#include \"msft.h\"\n#include \"eir.h\"\n#include \"aosp.h\"\n\n#define MGMT_VERSION\t1\n#define MGMT_REVISION\t22\n\nstatic const u16 mgmt_commands[] = {\n\tMGMT_OP_READ_INDEX_LIST,\n\tMGMT_OP_READ_INFO,\n\tMGMT_OP_SET_POWERED,\n\tMGMT_OP_SET_DISCOVERABLE,\n\tMGMT_OP_SET_CONNECTABLE,\n\tMGMT_OP_SET_FAST_CONNECTABLE,\n\tMGMT_OP_SET_BONDABLE,\n\tMGMT_OP_SET_LINK_SECURITY,\n\tMGMT_OP_SET_SSP,\n\tMGMT_OP_SET_HS,\n\tMGMT_OP_SET_LE,\n\tMGMT_OP_SET_DEV_CLASS,\n\tMGMT_OP_SET_LOCAL_NAME,\n\tMGMT_OP_ADD_UUID,\n\tMGMT_OP_REMOVE_UUID,\n\tMGMT_OP_LOAD_LINK_KEYS,\n\tMGMT_OP_LOAD_LONG_TERM_KEYS,\n\tMGMT_OP_DISCONNECT,\n\tMGMT_OP_GET_CONNECTIONS,\n\tMGMT_OP_PIN_CODE_REPLY,\n\tMGMT_OP_PIN_CODE_NEG_REPLY,\n\tMGMT_OP_SET_IO_CAPABILITY,\n\tMGMT_OP_PAIR_DEVICE,\n\tMGMT_OP_CANCEL_PAIR_DEVICE,\n\tMGMT_OP_UNPAIR_DEVICE,\n\tMGMT_OP_USER_CONFIRM_REPLY,\n\tMGMT_OP_USER_CONFIRM_NEG_REPLY,\n\tMGMT_OP_USER_PASSKEY_REPLY,\n\tMGMT_OP_USER_PASSKEY_NEG_REPLY,\n\tMGMT_OP_READ_LOCAL_OOB_DATA,\n\tMGMT_OP_ADD_REMOTE_OOB_DATA,\n\tMGMT_OP_REMOVE_REMOTE_OOB_DATA,\n\tMGMT_OP_START_DISCOVERY,\n\tMGMT_OP_STOP_DISCOVERY,\n\tMGMT_OP_CONFIRM_NAME,\n\tMGMT_OP_BLOCK_DEVICE,\n\tMGMT_OP_UNBLOCK_DEVICE,\n\tMGMT_OP_SET_DEVICE_ID,\n\tMGMT_OP_SET_ADVERTISING,\n\tMGMT_OP_SET_BREDR,\n\tMGMT_OP_SET_STATIC_ADDRESS,\n\tMGMT_OP_SET_SCAN_PARAMS,\n\tMGMT_OP_SET_SECURE_CONN,\n\tMGMT_OP_SET_DEBUG_KEYS,\n\tMGMT_OP_SET_PRIVACY,\n\tMGMT_OP_LOAD_IRKS,\n\tMGMT_OP_GET_CONN_INFO,\n\tMGMT_OP_GET_CLOCK_INFO,\n\tMGMT_OP_ADD_DEVICE,\n\tMGMT_OP_REMOVE_DEVICE,\n\tMGMT_OP_LOAD_CONN_PARAM,\n\tMGMT_OP_READ_UNCONF_INDEX_LIST,\n\tMGMT_OP_READ_CONFIG_INFO,\n\tMGMT_OP_SET_EXTERNAL_CONFIG,\n\tMGMT_OP_SET_PUBLIC_ADDRESS,\n\tMGMT_OP_START_SERVICE_DISCOVERY,\n\tMGMT_OP_READ_LOCAL_OOB_EXT_DATA,\n\tMGMT_OP_READ_EXT_INDEX_LIST,\n\tMGMT_OP_READ_ADV_FEATURES,\n\tMGMT_OP_ADD_ADVERTISING,\n\tMGMT_OP_REMOVE_ADVERTISING,\n\tMGMT_OP_GET_ADV_SIZE_INFO,\n\tMGMT_OP_START_LIMITED_DISCOVERY,\n\tMGMT_OP_READ_EXT_INFO,\n\tMGMT_OP_SET_APPEARANCE,\n\tMGMT_OP_GET_PHY_CONFIGURATION,\n\tMGMT_OP_SET_PHY_CONFIGURATION,\n\tMGMT_OP_SET_BLOCKED_KEYS,\n\tMGMT_OP_SET_WIDEBAND_SPEECH,\n\tMGMT_OP_READ_CONTROLLER_CAP,\n\tMGMT_OP_READ_EXP_FEATURES_INFO,\n\tMGMT_OP_SET_EXP_FEATURE,\n\tMGMT_OP_READ_DEF_SYSTEM_CONFIG,\n\tMGMT_OP_SET_DEF_SYSTEM_CONFIG,\n\tMGMT_OP_READ_DEF_RUNTIME_CONFIG,\n\tMGMT_OP_SET_DEF_RUNTIME_CONFIG,\n\tMGMT_OP_GET_DEVICE_FLAGS,\n\tMGMT_OP_SET_DEVICE_FLAGS,\n\tMGMT_OP_READ_ADV_MONITOR_FEATURES,\n\tMGMT_OP_ADD_ADV_PATTERNS_MONITOR,\n\tMGMT_OP_REMOVE_ADV_MONITOR,\n\tMGMT_OP_ADD_EXT_ADV_PARAMS,\n\tMGMT_OP_ADD_EXT_ADV_DATA,\n\tMGMT_OP_ADD_ADV_PATTERNS_MONITOR_RSSI,\n\tMGMT_OP_SET_MESH_RECEIVER,\n\tMGMT_OP_MESH_READ_FEATURES,\n\tMGMT_OP_MESH_SEND,\n\tMGMT_OP_MESH_SEND_CANCEL,\n};\n\nstatic const u16 mgmt_events[] = {\n\tMGMT_EV_CONTROLLER_ERROR,\n\tMGMT_EV_INDEX_ADDED,\n\tMGMT_EV_INDEX_REMOVED,\n\tMGMT_EV_NEW_SETTINGS,\n\tMGMT_EV_CLASS_OF_DEV_CHANGED,\n\tMGMT_EV_LOCAL_NAME_CHANGED,\n\tMGMT_EV_NEW_LINK_KEY,\n\tMGMT_EV_NEW_LONG_TERM_KEY,\n\tMGMT_EV_DEVICE_CONNECTED,\n\tMGMT_EV_DEVICE_DISCONNECTED,\n\tMGMT_EV_CONNECT_FAILED,\n\tMGMT_EV_PIN_CODE_REQUEST,\n\tMGMT_EV_USER_CONFIRM_REQUEST,\n\tMGMT_EV_USER_PASSKEY_REQUEST,\n\tMGMT_EV_AUTH_FAILED,\n\tMGMT_EV_DEVICE_FOUND,\n\tMGMT_EV_DISCOVERING,\n\tMGMT_EV_DEVICE_BLOCKED,\n\tMGMT_EV_DEVICE_UNBLOCKED,\n\tMGMT_EV_DEVICE_UNPAIRED,\n\tMGMT_EV_PASSKEY_NOTIFY,\n\tMGMT_EV_NEW_IRK,\n\tMGMT_EV_NEW_CSRK,\n\tMGMT_EV_DEVICE_ADDED,\n\tMGMT_EV_DEVICE_REMOVED,\n\tMGMT_EV_NEW_CONN_PARAM,\n\tMGMT_EV_UNCONF_INDEX_ADDED,\n\tMGMT_EV_UNCONF_INDEX_REMOVED,\n\tMGMT_EV_NEW_CONFIG_OPTIONS,\n\tMGMT_EV_EXT_INDEX_ADDED,\n\tMGMT_EV_EXT_INDEX_REMOVED,\n\tMGMT_EV_LOCAL_OOB_DATA_UPDATED,\n\tMGMT_EV_ADVERTISING_ADDED,\n\tMGMT_EV_ADVERTISING_REMOVED,\n\tMGMT_EV_EXT_INFO_CHANGED,\n\tMGMT_EV_PHY_CONFIGURATION_CHANGED,\n\tMGMT_EV_EXP_FEATURE_CHANGED,\n\tMGMT_EV_DEVICE_FLAGS_CHANGED,\n\tMGMT_EV_ADV_MONITOR_ADDED,\n\tMGMT_EV_ADV_MONITOR_REMOVED,\n\tMGMT_EV_CONTROLLER_SUSPEND,\n\tMGMT_EV_CONTROLLER_RESUME,\n\tMGMT_EV_ADV_MONITOR_DEVICE_FOUND,\n\tMGMT_EV_ADV_MONITOR_DEVICE_LOST,\n};\n\nstatic const u16 mgmt_untrusted_commands[] = {\n\tMGMT_OP_READ_INDEX_LIST,\n\tMGMT_OP_READ_INFO,\n\tMGMT_OP_READ_UNCONF_INDEX_LIST,\n\tMGMT_OP_READ_CONFIG_INFO,\n\tMGMT_OP_READ_EXT_INDEX_LIST,\n\tMGMT_OP_READ_EXT_INFO,\n\tMGMT_OP_READ_CONTROLLER_CAP,\n\tMGMT_OP_READ_EXP_FEATURES_INFO,\n\tMGMT_OP_READ_DEF_SYSTEM_CONFIG,\n\tMGMT_OP_READ_DEF_RUNTIME_CONFIG,\n};\n\nstatic const u16 mgmt_untrusted_events[] = {\n\tMGMT_EV_INDEX_ADDED,\n\tMGMT_EV_INDEX_REMOVED,\n\tMGMT_EV_NEW_SETTINGS,\n\tMGMT_EV_CLASS_OF_DEV_CHANGED,\n\tMGMT_EV_LOCAL_NAME_CHANGED,\n\tMGMT_EV_UNCONF_INDEX_ADDED,\n\tMGMT_EV_UNCONF_INDEX_REMOVED,\n\tMGMT_EV_NEW_CONFIG_OPTIONS,\n\tMGMT_EV_EXT_INDEX_ADDED,\n\tMGMT_EV_EXT_INDEX_REMOVED,\n\tMGMT_EV_EXT_INFO_CHANGED,\n\tMGMT_EV_EXP_FEATURE_CHANGED,\n};\n\n#define CACHE_TIMEOUT\tmsecs_to_jiffies(2 * 1000)\n\n#define ZERO_KEY \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n\t\t \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n \nstatic const u8 mgmt_status_table[] = {\n\tMGMT_STATUS_SUCCESS,\n\tMGMT_STATUS_UNKNOWN_COMMAND,\t \n\tMGMT_STATUS_NOT_CONNECTED,\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_CONNECT_FAILED,\t \n\tMGMT_STATUS_AUTH_FAILED,\t \n\tMGMT_STATUS_AUTH_FAILED,\t \n\tMGMT_STATUS_NO_RESOURCES,\t \n\tMGMT_STATUS_TIMEOUT,\t\t \n\tMGMT_STATUS_NO_RESOURCES,\t \n\tMGMT_STATUS_NO_RESOURCES,\t \n\tMGMT_STATUS_ALREADY_CONNECTED,\t \n\tMGMT_STATUS_BUSY,\t\t \n\tMGMT_STATUS_NO_RESOURCES,\t \n\tMGMT_STATUS_REJECTED,\t\t \n\tMGMT_STATUS_REJECTED,\t\t \n\tMGMT_STATUS_TIMEOUT,\t\t \n\tMGMT_STATUS_NOT_SUPPORTED,\t \n\tMGMT_STATUS_INVALID_PARAMS,\t \n\tMGMT_STATUS_DISCONNECTED,\t \n\tMGMT_STATUS_NO_RESOURCES,\t \n\tMGMT_STATUS_DISCONNECTED,\t \n\tMGMT_STATUS_DISCONNECTED,\t \n\tMGMT_STATUS_BUSY,\t\t \n\tMGMT_STATUS_REJECTED,\t\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_NOT_SUPPORTED,\t \n\tMGMT_STATUS_REJECTED,\t\t \n\tMGMT_STATUS_REJECTED,\t\t \n\tMGMT_STATUS_REJECTED,\t\t \n\tMGMT_STATUS_INVALID_PARAMS,\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_NOT_SUPPORTED,\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_TIMEOUT,\t\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_REJECTED,\t\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_NOT_SUPPORTED,\t \n\tMGMT_STATUS_TIMEOUT,\t\t \n\tMGMT_STATUS_NOT_SUPPORTED,\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_INVALID_PARAMS,\t \n\tMGMT_STATUS_REJECTED,\t\t \n\tMGMT_STATUS_NOT_SUPPORTED,\t \n\tMGMT_STATUS_REJECTED,\t\t \n\tMGMT_STATUS_INVALID_PARAMS,\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_BUSY,\t\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_FAILED,\t\t \n\tMGMT_STATUS_INVALID_PARAMS,\t \n\tMGMT_STATUS_NOT_SUPPORTED,\t \n\tMGMT_STATUS_BUSY,\t\t \n\tMGMT_STATUS_REJECTED,\t\t \n\tMGMT_STATUS_BUSY,\t\t \n\tMGMT_STATUS_INVALID_PARAMS,\t \n\tMGMT_STATUS_TIMEOUT,\t\t \n\tMGMT_STATUS_AUTH_FAILED,\t \n\tMGMT_STATUS_CONNECT_FAILED,\t \n\tMGMT_STATUS_CONNECT_FAILED,\t \n};\n\nstatic u8 mgmt_errno_status(int err)\n{\n\tswitch (err) {\n\tcase 0:\n\t\treturn MGMT_STATUS_SUCCESS;\n\tcase -EPERM:\n\t\treturn MGMT_STATUS_REJECTED;\n\tcase -EINVAL:\n\t\treturn MGMT_STATUS_INVALID_PARAMS;\n\tcase -EOPNOTSUPP:\n\t\treturn MGMT_STATUS_NOT_SUPPORTED;\n\tcase -EBUSY:\n\t\treturn MGMT_STATUS_BUSY;\n\tcase -ETIMEDOUT:\n\t\treturn MGMT_STATUS_AUTH_FAILED;\n\tcase -ENOMEM:\n\t\treturn MGMT_STATUS_NO_RESOURCES;\n\tcase -EISCONN:\n\t\treturn MGMT_STATUS_ALREADY_CONNECTED;\n\tcase -ENOTCONN:\n\t\treturn MGMT_STATUS_DISCONNECTED;\n\t}\n\n\treturn MGMT_STATUS_FAILED;\n}\n\nstatic u8 mgmt_status(int err)\n{\n\tif (err < 0)\n\t\treturn mgmt_errno_status(err);\n\n\tif (err < ARRAY_SIZE(mgmt_status_table))\n\t\treturn mgmt_status_table[err];\n\n\treturn MGMT_STATUS_FAILED;\n}\n\nstatic int mgmt_index_event(u16 event, struct hci_dev *hdev, void *data,\n\t\t\t    u16 len, int flag)\n{\n\treturn mgmt_send_event(event, hdev, HCI_CHANNEL_CONTROL, data, len,\n\t\t\t       flag, NULL);\n}\n\nstatic int mgmt_limited_event(u16 event, struct hci_dev *hdev, void *data,\n\t\t\t      u16 len, int flag, struct sock *skip_sk)\n{\n\treturn mgmt_send_event(event, hdev, HCI_CHANNEL_CONTROL, data, len,\n\t\t\t       flag, skip_sk);\n}\n\nstatic int mgmt_event(u16 event, struct hci_dev *hdev, void *data, u16 len,\n\t\t      struct sock *skip_sk)\n{\n\treturn mgmt_send_event(event, hdev, HCI_CHANNEL_CONTROL, data, len,\n\t\t\t       HCI_SOCK_TRUSTED, skip_sk);\n}\n\nstatic int mgmt_event_skb(struct sk_buff *skb, struct sock *skip_sk)\n{\n\treturn mgmt_send_event_skb(HCI_CHANNEL_CONTROL, skb, HCI_SOCK_TRUSTED,\n\t\t\t\t   skip_sk);\n}\n\nstatic u8 le_addr_type(u8 mgmt_addr_type)\n{\n\tif (mgmt_addr_type == BDADDR_LE_PUBLIC)\n\t\treturn ADDR_LE_DEV_PUBLIC;\n\telse\n\t\treturn ADDR_LE_DEV_RANDOM;\n}\n\nvoid mgmt_fill_version_info(void *ver)\n{\n\tstruct mgmt_rp_read_version *rp = ver;\n\n\trp->version = MGMT_VERSION;\n\trp->revision = cpu_to_le16(MGMT_REVISION);\n}\n\nstatic int read_version(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\tu16 data_len)\n{\n\tstruct mgmt_rp_read_version rp;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmgmt_fill_version_info(&rp);\n\n\treturn mgmt_cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_VERSION, 0,\n\t\t\t\t &rp, sizeof(rp));\n}\n\nstatic int read_commands(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 data_len)\n{\n\tstruct mgmt_rp_read_commands *rp;\n\tu16 num_commands, num_events;\n\tsize_t rp_size;\n\tint i, err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (hci_sock_test_flag(sk, HCI_SOCK_TRUSTED)) {\n\t\tnum_commands = ARRAY_SIZE(mgmt_commands);\n\t\tnum_events = ARRAY_SIZE(mgmt_events);\n\t} else {\n\t\tnum_commands = ARRAY_SIZE(mgmt_untrusted_commands);\n\t\tnum_events = ARRAY_SIZE(mgmt_untrusted_events);\n\t}\n\n\trp_size = sizeof(*rp) + ((num_commands + num_events) * sizeof(u16));\n\n\trp = kmalloc(rp_size, GFP_KERNEL);\n\tif (!rp)\n\t\treturn -ENOMEM;\n\n\trp->num_commands = cpu_to_le16(num_commands);\n\trp->num_events = cpu_to_le16(num_events);\n\n\tif (hci_sock_test_flag(sk, HCI_SOCK_TRUSTED)) {\n\t\t__le16 *opcode = rp->opcodes;\n\n\t\tfor (i = 0; i < num_commands; i++, opcode++)\n\t\t\tput_unaligned_le16(mgmt_commands[i], opcode);\n\n\t\tfor (i = 0; i < num_events; i++, opcode++)\n\t\t\tput_unaligned_le16(mgmt_events[i], opcode);\n\t} else {\n\t\t__le16 *opcode = rp->opcodes;\n\n\t\tfor (i = 0; i < num_commands; i++, opcode++)\n\t\t\tput_unaligned_le16(mgmt_untrusted_commands[i], opcode);\n\n\t\tfor (i = 0; i < num_events; i++, opcode++)\n\t\t\tput_unaligned_le16(mgmt_untrusted_events[i], opcode);\n\t}\n\n\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_COMMANDS, 0,\n\t\t\t\trp, rp_size);\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic int read_index_list(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t   u16 data_len)\n{\n\tstruct mgmt_rp_read_index_list *rp;\n\tstruct hci_dev *d;\n\tsize_t rp_len;\n\tu16 count;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tread_lock(&hci_dev_list_lock);\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (d->dev_type == HCI_PRIMARY &&\n\t\t    !hci_dev_test_flag(d, HCI_UNCONFIGURED))\n\t\t\tcount++;\n\t}\n\n\trp_len = sizeof(*rp) + (2 * count);\n\trp = kmalloc(rp_len, GFP_ATOMIC);\n\tif (!rp) {\n\t\tread_unlock(&hci_dev_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (hci_dev_test_flag(d, HCI_SETUP) ||\n\t\t    hci_dev_test_flag(d, HCI_CONFIG) ||\n\t\t    hci_dev_test_flag(d, HCI_USER_CHANNEL))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &d->quirks))\n\t\t\tcontinue;\n\n\t\tif (d->dev_type == HCI_PRIMARY &&\n\t\t    !hci_dev_test_flag(d, HCI_UNCONFIGURED)) {\n\t\t\trp->index[count++] = cpu_to_le16(d->id);\n\t\t\tbt_dev_dbg(hdev, \"Added hci%u\", d->id);\n\t\t}\n\t}\n\n\trp->num_controllers = cpu_to_le16(count);\n\trp_len = sizeof(*rp) + (2 * count);\n\n\tread_unlock(&hci_dev_list_lock);\n\n\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_INDEX_LIST,\n\t\t\t\t0, rp, rp_len);\n\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic int read_unconf_index_list(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  void *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_unconf_index_list *rp;\n\tstruct hci_dev *d;\n\tsize_t rp_len;\n\tu16 count;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tread_lock(&hci_dev_list_lock);\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (d->dev_type == HCI_PRIMARY &&\n\t\t    hci_dev_test_flag(d, HCI_UNCONFIGURED))\n\t\t\tcount++;\n\t}\n\n\trp_len = sizeof(*rp) + (2 * count);\n\trp = kmalloc(rp_len, GFP_ATOMIC);\n\tif (!rp) {\n\t\tread_unlock(&hci_dev_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (hci_dev_test_flag(d, HCI_SETUP) ||\n\t\t    hci_dev_test_flag(d, HCI_CONFIG) ||\n\t\t    hci_dev_test_flag(d, HCI_USER_CHANNEL))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &d->quirks))\n\t\t\tcontinue;\n\n\t\tif (d->dev_type == HCI_PRIMARY &&\n\t\t    hci_dev_test_flag(d, HCI_UNCONFIGURED)) {\n\t\t\trp->index[count++] = cpu_to_le16(d->id);\n\t\t\tbt_dev_dbg(hdev, \"Added hci%u\", d->id);\n\t\t}\n\t}\n\n\trp->num_controllers = cpu_to_le16(count);\n\trp_len = sizeof(*rp) + (2 * count);\n\n\tread_unlock(&hci_dev_list_lock);\n\n\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,\n\t\t\t\tMGMT_OP_READ_UNCONF_INDEX_LIST, 0, rp, rp_len);\n\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic int read_ext_index_list(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_ext_index_list *rp;\n\tstruct hci_dev *d;\n\tu16 count;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tread_lock(&hci_dev_list_lock);\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (d->dev_type == HCI_PRIMARY || d->dev_type == HCI_AMP)\n\t\t\tcount++;\n\t}\n\n\trp = kmalloc(struct_size(rp, entry, count), GFP_ATOMIC);\n\tif (!rp) {\n\t\tread_unlock(&hci_dev_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (hci_dev_test_flag(d, HCI_SETUP) ||\n\t\t    hci_dev_test_flag(d, HCI_CONFIG) ||\n\t\t    hci_dev_test_flag(d, HCI_USER_CHANNEL))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &d->quirks))\n\t\t\tcontinue;\n\n\t\tif (d->dev_type == HCI_PRIMARY) {\n\t\t\tif (hci_dev_test_flag(d, HCI_UNCONFIGURED))\n\t\t\t\trp->entry[count].type = 0x01;\n\t\t\telse\n\t\t\t\trp->entry[count].type = 0x00;\n\t\t} else if (d->dev_type == HCI_AMP) {\n\t\t\trp->entry[count].type = 0x02;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\trp->entry[count].bus = d->bus;\n\t\trp->entry[count++].index = cpu_to_le16(d->id);\n\t\tbt_dev_dbg(hdev, \"Added hci%u\", d->id);\n\t}\n\n\trp->num_controllers = cpu_to_le16(count);\n\n\tread_unlock(&hci_dev_list_lock);\n\n\t \n\thci_sock_set_flag(sk, HCI_MGMT_EXT_INDEX_EVENTS);\n\thci_sock_clear_flag(sk, HCI_MGMT_INDEX_EVENTS);\n\thci_sock_clear_flag(sk, HCI_MGMT_UNCONF_INDEX_EVENTS);\n\n\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,\n\t\t\t\tMGMT_OP_READ_EXT_INDEX_LIST, 0, rp,\n\t\t\t\tstruct_size(rp, entry, count));\n\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic bool is_configured(struct hci_dev *hdev)\n{\n\tif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) &&\n\t    !hci_dev_test_flag(hdev, HCI_EXT_CONFIGURED))\n\t\treturn false;\n\n\tif ((test_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks) ||\n\t     test_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks)) &&\n\t    !bacmp(&hdev->public_addr, BDADDR_ANY))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic __le32 get_missing_options(struct hci_dev *hdev)\n{\n\tu32 options = 0;\n\n\tif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) &&\n\t    !hci_dev_test_flag(hdev, HCI_EXT_CONFIGURED))\n\t\toptions |= MGMT_OPTION_EXTERNAL_CONFIG;\n\n\tif ((test_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks) ||\n\t     test_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks)) &&\n\t    !bacmp(&hdev->public_addr, BDADDR_ANY))\n\t\toptions |= MGMT_OPTION_PUBLIC_ADDRESS;\n\n\treturn cpu_to_le32(options);\n}\n\nstatic int new_options(struct hci_dev *hdev, struct sock *skip)\n{\n\t__le32 options = get_missing_options(hdev);\n\n\treturn mgmt_limited_event(MGMT_EV_NEW_CONFIG_OPTIONS, hdev, &options,\n\t\t\t\t  sizeof(options), HCI_MGMT_OPTION_EVENTS, skip);\n}\n\nstatic int send_options_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev)\n{\n\t__le32 options = get_missing_options(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, opcode, 0, &options,\n\t\t\t\t sizeof(options));\n}\n\nstatic int read_config_info(struct sock *sk, struct hci_dev *hdev,\n\t\t\t    void *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_config_info rp;\n\tu32 options = 0;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tmemset(&rp, 0, sizeof(rp));\n\trp.manufacturer = cpu_to_le16(hdev->manufacturer);\n\n\tif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks))\n\t\toptions |= MGMT_OPTION_EXTERNAL_CONFIG;\n\n\tif (hdev->set_bdaddr)\n\t\toptions |= MGMT_OPTION_PUBLIC_ADDRESS;\n\n\trp.supported_options = cpu_to_le32(options);\n\trp.missing_options = get_missing_options(hdev);\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_CONFIG_INFO, 0,\n\t\t\t\t &rp, sizeof(rp));\n}\n\nstatic u32 get_supported_phys(struct hci_dev *hdev)\n{\n\tu32 supported_phys = 0;\n\n\tif (lmp_bredr_capable(hdev)) {\n\t\tsupported_phys |= MGMT_PHY_BR_1M_1SLOT;\n\n\t\tif (hdev->features[0][0] & LMP_3SLOT)\n\t\t\tsupported_phys |= MGMT_PHY_BR_1M_3SLOT;\n\n\t\tif (hdev->features[0][0] & LMP_5SLOT)\n\t\t\tsupported_phys |= MGMT_PHY_BR_1M_5SLOT;\n\n\t\tif (lmp_edr_2m_capable(hdev)) {\n\t\t\tsupported_phys |= MGMT_PHY_EDR_2M_1SLOT;\n\n\t\t\tif (lmp_edr_3slot_capable(hdev))\n\t\t\t\tsupported_phys |= MGMT_PHY_EDR_2M_3SLOT;\n\n\t\t\tif (lmp_edr_5slot_capable(hdev))\n\t\t\t\tsupported_phys |= MGMT_PHY_EDR_2M_5SLOT;\n\n\t\t\tif (lmp_edr_3m_capable(hdev)) {\n\t\t\t\tsupported_phys |= MGMT_PHY_EDR_3M_1SLOT;\n\n\t\t\t\tif (lmp_edr_3slot_capable(hdev))\n\t\t\t\t\tsupported_phys |= MGMT_PHY_EDR_3M_3SLOT;\n\n\t\t\t\tif (lmp_edr_5slot_capable(hdev))\n\t\t\t\t\tsupported_phys |= MGMT_PHY_EDR_3M_5SLOT;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lmp_le_capable(hdev)) {\n\t\tsupported_phys |= MGMT_PHY_LE_1M_TX;\n\t\tsupported_phys |= MGMT_PHY_LE_1M_RX;\n\n\t\tif (hdev->le_features[1] & HCI_LE_PHY_2M) {\n\t\t\tsupported_phys |= MGMT_PHY_LE_2M_TX;\n\t\t\tsupported_phys |= MGMT_PHY_LE_2M_RX;\n\t\t}\n\n\t\tif (hdev->le_features[1] & HCI_LE_PHY_CODED) {\n\t\t\tsupported_phys |= MGMT_PHY_LE_CODED_TX;\n\t\t\tsupported_phys |= MGMT_PHY_LE_CODED_RX;\n\t\t}\n\t}\n\n\treturn supported_phys;\n}\n\nstatic u32 get_selected_phys(struct hci_dev *hdev)\n{\n\tu32 selected_phys = 0;\n\n\tif (lmp_bredr_capable(hdev)) {\n\t\tselected_phys |= MGMT_PHY_BR_1M_1SLOT;\n\n\t\tif (hdev->pkt_type & (HCI_DM3 | HCI_DH3))\n\t\t\tselected_phys |= MGMT_PHY_BR_1M_3SLOT;\n\n\t\tif (hdev->pkt_type & (HCI_DM5 | HCI_DH5))\n\t\t\tselected_phys |= MGMT_PHY_BR_1M_5SLOT;\n\n\t\tif (lmp_edr_2m_capable(hdev)) {\n\t\t\tif (!(hdev->pkt_type & HCI_2DH1))\n\t\t\t\tselected_phys |= MGMT_PHY_EDR_2M_1SLOT;\n\n\t\t\tif (lmp_edr_3slot_capable(hdev) &&\n\t\t\t    !(hdev->pkt_type & HCI_2DH3))\n\t\t\t\tselected_phys |= MGMT_PHY_EDR_2M_3SLOT;\n\n\t\t\tif (lmp_edr_5slot_capable(hdev) &&\n\t\t\t    !(hdev->pkt_type & HCI_2DH5))\n\t\t\t\tselected_phys |= MGMT_PHY_EDR_2M_5SLOT;\n\n\t\t\tif (lmp_edr_3m_capable(hdev)) {\n\t\t\t\tif (!(hdev->pkt_type & HCI_3DH1))\n\t\t\t\t\tselected_phys |= MGMT_PHY_EDR_3M_1SLOT;\n\n\t\t\t\tif (lmp_edr_3slot_capable(hdev) &&\n\t\t\t\t    !(hdev->pkt_type & HCI_3DH3))\n\t\t\t\t\tselected_phys |= MGMT_PHY_EDR_3M_3SLOT;\n\n\t\t\t\tif (lmp_edr_5slot_capable(hdev) &&\n\t\t\t\t    !(hdev->pkt_type & HCI_3DH5))\n\t\t\t\t\tselected_phys |= MGMT_PHY_EDR_3M_5SLOT;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lmp_le_capable(hdev)) {\n\t\tif (hdev->le_tx_def_phys & HCI_LE_SET_PHY_1M)\n\t\t\tselected_phys |= MGMT_PHY_LE_1M_TX;\n\n\t\tif (hdev->le_rx_def_phys & HCI_LE_SET_PHY_1M)\n\t\t\tselected_phys |= MGMT_PHY_LE_1M_RX;\n\n\t\tif (hdev->le_tx_def_phys & HCI_LE_SET_PHY_2M)\n\t\t\tselected_phys |= MGMT_PHY_LE_2M_TX;\n\n\t\tif (hdev->le_rx_def_phys & HCI_LE_SET_PHY_2M)\n\t\t\tselected_phys |= MGMT_PHY_LE_2M_RX;\n\n\t\tif (hdev->le_tx_def_phys & HCI_LE_SET_PHY_CODED)\n\t\t\tselected_phys |= MGMT_PHY_LE_CODED_TX;\n\n\t\tif (hdev->le_rx_def_phys & HCI_LE_SET_PHY_CODED)\n\t\t\tselected_phys |= MGMT_PHY_LE_CODED_RX;\n\t}\n\n\treturn selected_phys;\n}\n\nstatic u32 get_configurable_phys(struct hci_dev *hdev)\n{\n\treturn (get_supported_phys(hdev) & ~MGMT_PHY_BR_1M_1SLOT &\n\t\t~MGMT_PHY_LE_1M_TX & ~MGMT_PHY_LE_1M_RX);\n}\n\nstatic u32 get_supported_settings(struct hci_dev *hdev)\n{\n\tu32 settings = 0;\n\n\tsettings |= MGMT_SETTING_POWERED;\n\tsettings |= MGMT_SETTING_BONDABLE;\n\tsettings |= MGMT_SETTING_DEBUG_KEYS;\n\tsettings |= MGMT_SETTING_CONNECTABLE;\n\tsettings |= MGMT_SETTING_DISCOVERABLE;\n\n\tif (lmp_bredr_capable(hdev)) {\n\t\tif (hdev->hci_ver >= BLUETOOTH_VER_1_2)\n\t\t\tsettings |= MGMT_SETTING_FAST_CONNECTABLE;\n\t\tsettings |= MGMT_SETTING_BREDR;\n\t\tsettings |= MGMT_SETTING_LINK_SECURITY;\n\n\t\tif (lmp_ssp_capable(hdev)) {\n\t\t\tsettings |= MGMT_SETTING_SSP;\n\t\t\tif (IS_ENABLED(CONFIG_BT_HS))\n\t\t\t\tsettings |= MGMT_SETTING_HS;\n\t\t}\n\n\t\tif (lmp_sc_capable(hdev))\n\t\t\tsettings |= MGMT_SETTING_SECURE_CONN;\n\n\t\tif (test_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED,\n\t\t\t     &hdev->quirks))\n\t\t\tsettings |= MGMT_SETTING_WIDEBAND_SPEECH;\n\t}\n\n\tif (lmp_le_capable(hdev)) {\n\t\tsettings |= MGMT_SETTING_LE;\n\t\tsettings |= MGMT_SETTING_SECURE_CONN;\n\t\tsettings |= MGMT_SETTING_PRIVACY;\n\t\tsettings |= MGMT_SETTING_STATIC_ADDRESS;\n\t\tsettings |= MGMT_SETTING_ADVERTISING;\n\t}\n\n\tif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) ||\n\t    hdev->set_bdaddr)\n\t\tsettings |= MGMT_SETTING_CONFIGURATION;\n\n\tif (cis_central_capable(hdev))\n\t\tsettings |= MGMT_SETTING_CIS_CENTRAL;\n\n\tif (cis_peripheral_capable(hdev))\n\t\tsettings |= MGMT_SETTING_CIS_PERIPHERAL;\n\n\tsettings |= MGMT_SETTING_PHY_CONFIGURATION;\n\n\treturn settings;\n}\n\nstatic u32 get_current_settings(struct hci_dev *hdev)\n{\n\tu32 settings = 0;\n\n\tif (hdev_is_powered(hdev))\n\t\tsettings |= MGMT_SETTING_POWERED;\n\n\tif (hci_dev_test_flag(hdev, HCI_CONNECTABLE))\n\t\tsettings |= MGMT_SETTING_CONNECTABLE;\n\n\tif (hci_dev_test_flag(hdev, HCI_FAST_CONNECTABLE))\n\t\tsettings |= MGMT_SETTING_FAST_CONNECTABLE;\n\n\tif (hci_dev_test_flag(hdev, HCI_DISCOVERABLE))\n\t\tsettings |= MGMT_SETTING_DISCOVERABLE;\n\n\tif (hci_dev_test_flag(hdev, HCI_BONDABLE))\n\t\tsettings |= MGMT_SETTING_BONDABLE;\n\n\tif (hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\tsettings |= MGMT_SETTING_BREDR;\n\n\tif (hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\tsettings |= MGMT_SETTING_LE;\n\n\tif (hci_dev_test_flag(hdev, HCI_LINK_SECURITY))\n\t\tsettings |= MGMT_SETTING_LINK_SECURITY;\n\n\tif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\n\t\tsettings |= MGMT_SETTING_SSP;\n\n\tif (hci_dev_test_flag(hdev, HCI_HS_ENABLED))\n\t\tsettings |= MGMT_SETTING_HS;\n\n\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\tsettings |= MGMT_SETTING_ADVERTISING;\n\n\tif (hci_dev_test_flag(hdev, HCI_SC_ENABLED))\n\t\tsettings |= MGMT_SETTING_SECURE_CONN;\n\n\tif (hci_dev_test_flag(hdev, HCI_KEEP_DEBUG_KEYS))\n\t\tsettings |= MGMT_SETTING_DEBUG_KEYS;\n\n\tif (hci_dev_test_flag(hdev, HCI_PRIVACY))\n\t\tsettings |= MGMT_SETTING_PRIVACY;\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||\n\t    !hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) ||\n\t    !bacmp(&hdev->bdaddr, BDADDR_ANY)) {\n\t\tif (bacmp(&hdev->static_addr, BDADDR_ANY))\n\t\t\tsettings |= MGMT_SETTING_STATIC_ADDRESS;\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_WIDEBAND_SPEECH_ENABLED))\n\t\tsettings |= MGMT_SETTING_WIDEBAND_SPEECH;\n\n\tif (cis_central_capable(hdev))\n\t\tsettings |= MGMT_SETTING_CIS_CENTRAL;\n\n\tif (cis_peripheral_capable(hdev))\n\t\tsettings |= MGMT_SETTING_CIS_PERIPHERAL;\n\n\tif (bis_capable(hdev))\n\t\tsettings |= MGMT_SETTING_ISO_BROADCASTER;\n\n\tif (sync_recv_capable(hdev))\n\t\tsettings |= MGMT_SETTING_ISO_SYNC_RECEIVER;\n\n\treturn settings;\n}\n\nstatic struct mgmt_pending_cmd *pending_find(u16 opcode, struct hci_dev *hdev)\n{\n\treturn mgmt_pending_find(HCI_CHANNEL_CONTROL, opcode, hdev);\n}\n\nu8 mgmt_get_adv_discov_flags(struct hci_dev *hdev)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\t \n\tcmd = pending_find(MGMT_OP_SET_DISCOVERABLE, hdev);\n\tif (cmd) {\n\t\tstruct mgmt_mode *cp = cmd->param;\n\t\tif (cp->val == 0x01)\n\t\t\treturn LE_AD_GENERAL;\n\t\telse if (cp->val == 0x02)\n\t\t\treturn LE_AD_LIMITED;\n\t} else {\n\t\tif (hci_dev_test_flag(hdev, HCI_LIMITED_DISCOVERABLE))\n\t\t\treturn LE_AD_LIMITED;\n\t\telse if (hci_dev_test_flag(hdev, HCI_DISCOVERABLE))\n\t\t\treturn LE_AD_GENERAL;\n\t}\n\n\treturn 0;\n}\n\nbool mgmt_get_connectable(struct hci_dev *hdev)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\t \n\tcmd = pending_find(MGMT_OP_SET_CONNECTABLE, hdev);\n\tif (cmd) {\n\t\tstruct mgmt_mode *cp = cmd->param;\n\n\t\treturn cp->val;\n\t}\n\n\treturn hci_dev_test_flag(hdev, HCI_CONNECTABLE);\n}\n\nstatic int service_cache_sync(struct hci_dev *hdev, void *data)\n{\n\thci_update_eir_sync(hdev);\n\thci_update_class_sync(hdev);\n\n\treturn 0;\n}\n\nstatic void service_cache_off(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev,\n\t\t\t\t\t    service_cache.work);\n\n\tif (!hci_dev_test_and_clear_flag(hdev, HCI_SERVICE_CACHE))\n\t\treturn;\n\n\thci_cmd_sync_queue(hdev, service_cache_sync, NULL, NULL);\n}\n\nstatic int rpa_expired_sync(struct hci_dev *hdev, void *data)\n{\n\t \n\tif (ext_adv_capable(hdev))\n\t\treturn hci_start_ext_adv_sync(hdev, hdev->cur_adv_instance);\n\telse\n\t\treturn hci_enable_advertising_sync(hdev);\n}\n\nstatic void rpa_expired(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev,\n\t\t\t\t\t    rpa_expired.work);\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\n\n\tif (!hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\treturn;\n\n\thci_cmd_sync_queue(hdev, rpa_expired_sync, NULL, NULL);\n}\n\nstatic void discov_off(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev,\n\t\t\t\t\t    discov_off.work);\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\t \n\thci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\thdev->discov_timeout = 0;\n\n\thci_update_discoverable(hdev);\n\n\tmgmt_new_settings(hdev);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic int send_settings_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev);\n\nstatic void mesh_send_complete(struct hci_dev *hdev,\n\t\t\t       struct mgmt_mesh_tx *mesh_tx, bool silent)\n{\n\tu8 handle = mesh_tx->handle;\n\n\tif (!silent)\n\t\tmgmt_event(MGMT_EV_MESH_PACKET_CMPLT, hdev, &handle,\n\t\t\t   sizeof(handle), NULL);\n\n\tmgmt_mesh_remove(mesh_tx);\n}\n\nstatic int mesh_send_done_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_mesh_tx *mesh_tx;\n\n\thci_dev_clear_flag(hdev, HCI_MESH_SENDING);\n\thci_disable_advertising_sync(hdev);\n\tmesh_tx = mgmt_mesh_next(hdev, NULL);\n\n\tif (mesh_tx)\n\t\tmesh_send_complete(hdev, mesh_tx, false);\n\n\treturn 0;\n}\n\nstatic int mesh_send_sync(struct hci_dev *hdev, void *data);\nstatic void mesh_send_start_complete(struct hci_dev *hdev, void *data, int err);\nstatic void mesh_next(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_mesh_tx *mesh_tx = mgmt_mesh_next(hdev, NULL);\n\n\tif (!mesh_tx)\n\t\treturn;\n\n\terr = hci_cmd_sync_queue(hdev, mesh_send_sync, mesh_tx,\n\t\t\t\t mesh_send_start_complete);\n\n\tif (err < 0)\n\t\tmesh_send_complete(hdev, mesh_tx, false);\n\telse\n\t\thci_dev_set_flag(hdev, HCI_MESH_SENDING);\n}\n\nstatic void mesh_send_done(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev,\n\t\t\t\t\t    mesh_send_done.work);\n\n\tif (!hci_dev_test_flag(hdev, HCI_MESH_SENDING))\n\t\treturn;\n\n\thci_cmd_sync_queue(hdev, mesh_send_done_sync, NULL, mesh_next);\n}\n\nstatic void mgmt_init_hdev(struct sock *sk, struct hci_dev *hdev)\n{\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\treturn;\n\n\tBT_INFO(\"MGMT ver %d.%d\", MGMT_VERSION, MGMT_REVISION);\n\n\tINIT_DELAYED_WORK(&hdev->discov_off, discov_off);\n\tINIT_DELAYED_WORK(&hdev->service_cache, service_cache_off);\n\tINIT_DELAYED_WORK(&hdev->rpa_expired, rpa_expired);\n\tINIT_DELAYED_WORK(&hdev->mesh_send_done, mesh_send_done);\n\n\t \n\thci_dev_clear_flag(hdev, HCI_BONDABLE);\n\n\thci_dev_set_flag(hdev, HCI_MGMT);\n}\n\nstatic int read_controller_info(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\tvoid *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_info rp;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tmemset(&rp, 0, sizeof(rp));\n\n\tbacpy(&rp.bdaddr, &hdev->bdaddr);\n\n\trp.version = hdev->hci_ver;\n\trp.manufacturer = cpu_to_le16(hdev->manufacturer);\n\n\trp.supported_settings = cpu_to_le32(get_supported_settings(hdev));\n\trp.current_settings = cpu_to_le32(get_current_settings(hdev));\n\n\tmemcpy(rp.dev_class, hdev->dev_class, 3);\n\n\tmemcpy(rp.name, hdev->dev_name, sizeof(hdev->dev_name));\n\tmemcpy(rp.short_name, hdev->short_name, sizeof(hdev->short_name));\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_INFO, 0, &rp,\n\t\t\t\t sizeof(rp));\n}\n\nstatic u16 append_eir_data_to_buf(struct hci_dev *hdev, u8 *eir)\n{\n\tu16 eir_len = 0;\n\tsize_t name_len;\n\n\tif (hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\teir_len = eir_append_data(eir, eir_len, EIR_CLASS_OF_DEV,\n\t\t\t\t\t  hdev->dev_class, 3);\n\n\tif (hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\teir_len = eir_append_le16(eir, eir_len, EIR_APPEARANCE,\n\t\t\t\t\t  hdev->appearance);\n\n\tname_len = strnlen(hdev->dev_name, sizeof(hdev->dev_name));\n\teir_len = eir_append_data(eir, eir_len, EIR_NAME_COMPLETE,\n\t\t\t\t  hdev->dev_name, name_len);\n\n\tname_len = strnlen(hdev->short_name, sizeof(hdev->short_name));\n\teir_len = eir_append_data(eir, eir_len, EIR_NAME_SHORT,\n\t\t\t\t  hdev->short_name, name_len);\n\n\treturn eir_len;\n}\n\nstatic int read_ext_controller_info(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t    void *data, u16 data_len)\n{\n\tchar buf[512];\n\tstruct mgmt_rp_read_ext_info *rp = (void *)buf;\n\tu16 eir_len;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\thci_dev_lock(hdev);\n\n\tbacpy(&rp->bdaddr, &hdev->bdaddr);\n\n\trp->version = hdev->hci_ver;\n\trp->manufacturer = cpu_to_le16(hdev->manufacturer);\n\n\trp->supported_settings = cpu_to_le32(get_supported_settings(hdev));\n\trp->current_settings = cpu_to_le32(get_current_settings(hdev));\n\n\n\teir_len = append_eir_data_to_buf(hdev, rp->eir);\n\trp->eir_len = cpu_to_le16(eir_len);\n\n\thci_dev_unlock(hdev);\n\n\t \n\thci_sock_set_flag(sk, HCI_MGMT_EXT_INFO_EVENTS);\n\thci_sock_clear_flag(sk, HCI_MGMT_DEV_CLASS_EVENTS);\n\thci_sock_clear_flag(sk, HCI_MGMT_LOCAL_NAME_EVENTS);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_EXT_INFO, 0, rp,\n\t\t\t\t sizeof(*rp) + eir_len);\n}\n\nstatic int ext_info_changed(struct hci_dev *hdev, struct sock *skip)\n{\n\tchar buf[512];\n\tstruct mgmt_ev_ext_info_changed *ev = (void *)buf;\n\tu16 eir_len;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\teir_len = append_eir_data_to_buf(hdev, ev->eir);\n\tev->eir_len = cpu_to_le16(eir_len);\n\n\treturn mgmt_limited_event(MGMT_EV_EXT_INFO_CHANGED, hdev, ev,\n\t\t\t\t  sizeof(*ev) + eir_len,\n\t\t\t\t  HCI_MGMT_EXT_INFO_EVENTS, skip);\n}\n\nstatic int send_settings_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev)\n{\n\t__le32 settings = cpu_to_le32(get_current_settings(hdev));\n\n\treturn mgmt_cmd_complete(sk, hdev->id, opcode, 0, &settings,\n\t\t\t\t sizeof(settings));\n}\n\nvoid mgmt_advertising_added(struct sock *sk, struct hci_dev *hdev, u8 instance)\n{\n\tstruct mgmt_ev_advertising_added ev;\n\n\tev.instance = instance;\n\n\tmgmt_event(MGMT_EV_ADVERTISING_ADDED, hdev, &ev, sizeof(ev), sk);\n}\n\nvoid mgmt_advertising_removed(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      u8 instance)\n{\n\tstruct mgmt_ev_advertising_removed ev;\n\n\tev.instance = instance;\n\n\tmgmt_event(MGMT_EV_ADVERTISING_REMOVED, hdev, &ev, sizeof(ev), sk);\n}\n\nstatic void cancel_adv_timeout(struct hci_dev *hdev)\n{\n\tif (hdev->adv_instance_timeout) {\n\t\thdev->adv_instance_timeout = 0;\n\t\tcancel_delayed_work(&hdev->adv_instance_expire);\n\t}\n}\n\n \nstatic void restart_le_actions(struct hci_dev *hdev)\n{\n\tstruct hci_conn_params *p;\n\n\tlist_for_each_entry(p, &hdev->le_conn_params, list) {\n\t\t \n\t\thci_pend_le_list_del_init(p);\n\n\t\tswitch (p->auto_connect) {\n\t\tcase HCI_AUTO_CONN_DIRECT:\n\t\tcase HCI_AUTO_CONN_ALWAYS:\n\t\t\thci_pend_le_list_add(p, &hdev->pend_le_conns);\n\t\t\tbreak;\n\t\tcase HCI_AUTO_CONN_REPORT:\n\t\t\thci_pend_le_list_add(p, &hdev->pend_le_reports);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int new_settings(struct hci_dev *hdev, struct sock *skip)\n{\n\t__le32 ev = cpu_to_le32(get_current_settings(hdev));\n\n\treturn mgmt_limited_event(MGMT_EV_NEW_SETTINGS, hdev, &ev,\n\t\t\t\t  sizeof(ev), HCI_MGMT_SETTING_EVENTS, skip);\n}\n\nstatic void mgmt_set_powered_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_mode *cp;\n\n\t \n\tif (cmd != pending_find(MGMT_OP_SET_POWERED, hdev))\n\t\treturn;\n\n\tcp = cmd->param;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tif (!err) {\n\t\tif (cp->val) {\n\t\t\thci_dev_lock(hdev);\n\t\t\trestart_le_actions(hdev);\n\t\t\thci_update_passive_scan(hdev);\n\t\t\thci_dev_unlock(hdev);\n\t\t}\n\n\t\tsend_settings_rsp(cmd->sk, cmd->opcode, hdev);\n\n\t\t \n\t\tif (cp->val)\n\t\t\tnew_settings(hdev, cmd->sk);\n\t} else {\n\t\tmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_POWERED,\n\t\t\t\tmgmt_status(err));\n\t}\n\n\tmgmt_pending_remove(cmd);\n}\n\nstatic int set_powered_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_mode *cp = cmd->param;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\treturn hci_set_powered_sync(hdev, cp->val);\n}\n\nstatic int set_powered(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t       u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_POWERED,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_find(MGMT_OP_SET_POWERED, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_POWERED,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tif (!!cp->val == hdev_is_powered(hdev)) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_POWERED, hdev);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_POWERED, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\t \n\tif (cp->val == 0x00) {\n\t\t__hci_cmd_sync_cancel(hdev, -EHOSTDOWN);\n\t\terr = hci_cmd_sync_queue(hdev, set_powered_sync, cmd,\n\t\t\t\t\t mgmt_set_powered_complete);\n\t} else {\n\t\t \n\t\terr = hci_cmd_sync_submit(hdev, set_powered_sync, cmd,\n\t\t\t\t\t  mgmt_set_powered_complete);\n\t}\n\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nint mgmt_new_settings(struct hci_dev *hdev)\n{\n\treturn new_settings(hdev, NULL);\n}\n\nstruct cmd_lookup {\n\tstruct sock *sk;\n\tstruct hci_dev *hdev;\n\tu8 mgmt_status;\n};\n\nstatic void settings_rsp(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tstruct cmd_lookup *match = data;\n\n\tsend_settings_rsp(cmd->sk, cmd->opcode, match->hdev);\n\n\tlist_del(&cmd->list);\n\n\tif (match->sk == NULL) {\n\t\tmatch->sk = cmd->sk;\n\t\tsock_hold(match->sk);\n\t}\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic void cmd_status_rsp(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tu8 *status = data;\n\n\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, *status);\n\tmgmt_pending_remove(cmd);\n}\n\nstatic void cmd_complete_rsp(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tif (cmd->cmd_complete) {\n\t\tu8 *status = data;\n\n\t\tcmd->cmd_complete(cmd, *status);\n\t\tmgmt_pending_remove(cmd);\n\n\t\treturn;\n\t}\n\n\tcmd_status_rsp(cmd, data);\n}\n\nstatic int generic_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)\n{\n\treturn mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status,\n\t\t\t\t cmd->param, cmd->param_len);\n}\n\nstatic int addr_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)\n{\n\treturn mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status,\n\t\t\t\t cmd->param, sizeof(struct mgmt_addr_info));\n}\n\nstatic u8 mgmt_bredr_support(struct hci_dev *hdev)\n{\n\tif (!lmp_bredr_capable(hdev))\n\t\treturn MGMT_STATUS_NOT_SUPPORTED;\n\telse if (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn MGMT_STATUS_REJECTED;\n\telse\n\t\treturn MGMT_STATUS_SUCCESS;\n}\n\nstatic u8 mgmt_le_support(struct hci_dev *hdev)\n{\n\tif (!lmp_le_capable(hdev))\n\t\treturn MGMT_STATUS_NOT_SUPPORTED;\n\telse if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn MGMT_STATUS_REJECTED;\n\telse\n\t\treturn MGMT_STATUS_SUCCESS;\n}\n\nstatic void mgmt_set_discoverable_complete(struct hci_dev *hdev, void *data,\n\t\t\t\t\t   int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\t \n\tif (cmd != pending_find(MGMT_OP_SET_DISCOVERABLE, hdev))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tif (err) {\n\t\tu8 mgmt_err = mgmt_status(err);\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);\n\t\thci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\t\tgoto done;\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_DISCOVERABLE) &&\n\t    hdev->discov_timeout > 0) {\n\t\tint to = msecs_to_jiffies(hdev->discov_timeout * 1000);\n\t\tqueue_delayed_work(hdev->req_workqueue, &hdev->discov_off, to);\n\t}\n\n\tsend_settings_rsp(cmd->sk, MGMT_OP_SET_DISCOVERABLE, hdev);\n\tnew_settings(hdev, cmd->sk);\n\ndone:\n\tmgmt_pending_remove(cmd);\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_discoverable_sync(struct hci_dev *hdev, void *data)\n{\n\tBT_DBG(\"%s\", hdev->name);\n\n\treturn hci_update_discoverable_sync(hdev);\n}\n\nstatic int set_discoverable(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t    u16 len)\n{\n\tstruct mgmt_cp_set_discoverable *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu16 timeout;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED) &&\n\t    !hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\ttimeout = __le16_to_cpu(cp->timeout);\n\n\t \n\tif ((cp->val == 0x00 && timeout > 0) ||\n\t    (cp->val == 0x02 && timeout == 0))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev) && timeout > 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t      MGMT_STATUS_NOT_POWERED);\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||\n\t    pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tif (!hci_dev_test_flag(hdev, HCI_CONNECTABLE)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto failed;\n\t}\n\n\tif (hdev->advertising_paused) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tif (!hdev_is_powered(hdev)) {\n\t\tbool changed = false;\n\n\t\t \n\t\tif (!!cp->val != hci_dev_test_flag(hdev, HCI_DISCOVERABLE)) {\n\t\t\thci_dev_change_flag(hdev, HCI_DISCOVERABLE);\n\t\t\tchanged = true;\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto failed;\n\t}\n\n\t \n\tif (!!cp->val == hci_dev_test_flag(hdev, HCI_DISCOVERABLE) &&\n\t    (cp->val == 0x02) == hci_dev_test_flag(hdev,\n\t\t\t\t\t\t   HCI_LIMITED_DISCOVERABLE)) {\n\t\tcancel_delayed_work(&hdev->discov_off);\n\t\thdev->discov_timeout = timeout;\n\n\t\tif (cp->val && hdev->discov_timeout > 0) {\n\t\t\tint to = msecs_to_jiffies(hdev->discov_timeout * 1000);\n\t\t\tqueue_delayed_work(hdev->req_workqueue,\n\t\t\t\t\t   &hdev->discov_off, to);\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_DISCOVERABLE, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\t \n\tcancel_delayed_work(&hdev->discov_off);\n\thdev->discov_timeout = timeout;\n\n\tif (cp->val)\n\t\thci_dev_set_flag(hdev, HCI_DISCOVERABLE);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\n\t \n\tif (cp->val == 0x02)\n\t\thci_dev_set_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\n\terr = hci_cmd_sync_queue(hdev, set_discoverable_sync, cmd,\n\t\t\t\t mgmt_set_discoverable_complete);\n\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void mgmt_set_connectable_complete(struct hci_dev *hdev, void *data,\n\t\t\t\t\t  int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\t \n\tif (cmd != pending_find(MGMT_OP_SET_CONNECTABLE, hdev))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tif (err) {\n\t\tu8 mgmt_err = mgmt_status(err);\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);\n\t\tgoto done;\n\t}\n\n\tsend_settings_rsp(cmd->sk, MGMT_OP_SET_CONNECTABLE, hdev);\n\tnew_settings(hdev, cmd->sk);\n\ndone:\n\tif (cmd)\n\t\tmgmt_pending_remove(cmd);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_connectable_update_settings(struct hci_dev *hdev,\n\t\t\t\t\t   struct sock *sk, u8 val)\n{\n\tbool changed = false;\n\tint err;\n\n\tif (!!val != hci_dev_test_flag(hdev, HCI_CONNECTABLE))\n\t\tchanged = true;\n\n\tif (val) {\n\t\thci_dev_set_flag(hdev, HCI_CONNECTABLE);\n\t} else {\n\t\thci_dev_clear_flag(hdev, HCI_CONNECTABLE);\n\t\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\t}\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_CONNECTABLE, hdev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (changed) {\n\t\thci_update_scan(hdev);\n\t\thci_update_passive_scan(hdev);\n\t\treturn new_settings(hdev, sk);\n\t}\n\n\treturn 0;\n}\n\nstatic int set_connectable_sync(struct hci_dev *hdev, void *data)\n{\n\tBT_DBG(\"%s\", hdev->name);\n\n\treturn hci_update_connectable_sync(hdev);\n}\n\nstatic int set_connectable(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t   u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED) &&\n\t    !hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = set_connectable_update_settings(hdev, sk, cp->val);\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||\n\t    pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tif (cp->val) {\n\t\thci_dev_set_flag(hdev, HCI_CONNECTABLE);\n\t} else {\n\t\tif (hdev->discov_timeout > 0)\n\t\t\tcancel_delayed_work(&hdev->discov_off);\n\n\t\thci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\t\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\t\thci_dev_clear_flag(hdev, HCI_CONNECTABLE);\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, set_connectable_sync, cmd,\n\t\t\t\t mgmt_set_connectable_complete);\n\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_bondable(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\tu16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tbool changed;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BONDABLE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->val)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_BONDABLE);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_BONDABLE);\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_BONDABLE, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (changed) {\n\t\t \n\t\thci_update_discoverable(hdev);\n\n\t\terr = new_settings(hdev, sk);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_link_security(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t     u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 val, status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tstatus = mgmt_bredr_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\n\t\t\t\t       status);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\tbool changed = false;\n\n\t\tif (!!cp->val != hci_dev_test_flag(hdev, HCI_LINK_SECURITY)) {\n\t\t\thci_dev_change_flag(hdev, HCI_LINK_SECURITY);\n\t\t\tchanged = true;\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_LINK_SECURITY, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tval = !!cp->val;\n\n\tif (test_bit(HCI_AUTH, &hdev->flags) == val) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_LINK_SECURITY, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\terr = hci_send_cmd(hdev, HCI_OP_WRITE_AUTH_ENABLE, sizeof(val), &val);\n\tif (err < 0) {\n\t\tmgmt_pending_remove(cmd);\n\t\tgoto failed;\n\t}\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void set_ssp_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_mode *cp = cmd->param;\n\tu8 enable = cp->val;\n\tbool changed;\n\n\t \n\tif (cmd != pending_find(MGMT_OP_SET_SSP, hdev))\n\t\treturn;\n\n\tif (err) {\n\t\tu8 mgmt_err = mgmt_status(err);\n\n\t\tif (enable && hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t  HCI_SSP_ENABLED)) {\n\t\t\thci_dev_clear_flag(hdev, HCI_HS_ENABLED);\n\t\t\tnew_settings(hdev, NULL);\n\t\t}\n\n\t\tmgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, cmd_status_rsp,\n\t\t\t\t     &mgmt_err);\n\t\treturn;\n\t}\n\n\tif (enable) {\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_SSP_ENABLED);\n\t} else {\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_SSP_ENABLED);\n\n\t\tif (!changed)\n\t\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t      HCI_HS_ENABLED);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_HS_ENABLED);\n\t}\n\n\tmgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, settings_rsp, &match);\n\n\tif (changed)\n\t\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n\n\thci_update_eir_sync(hdev);\n}\n\nstatic int set_ssp_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_mode *cp = cmd->param;\n\tbool changed = false;\n\tint err;\n\n\tif (cp->val)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_SSP_ENABLED);\n\n\terr = hci_write_ssp_mode_sync(hdev, cp->val);\n\n\tif (!err && changed)\n\t\thci_dev_clear_flag(hdev, HCI_SSP_ENABLED);\n\n\treturn err;\n}\n\nstatic int set_ssp(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tstatus = mgmt_bredr_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP, status);\n\n\tif (!lmp_ssp_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\tbool changed;\n\n\t\tif (cp->val) {\n\t\t\tchanged = !hci_dev_test_and_set_flag(hdev,\n\t\t\t\t\t\t\t     HCI_SSP_ENABLED);\n\t\t} else {\n\t\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t      HCI_SSP_ENABLED);\n\t\t\tif (!changed)\n\t\t\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t\t      HCI_HS_ENABLED);\n\t\t\telse\n\t\t\t\thci_dev_clear_flag(hdev, HCI_HS_ENABLED);\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_SSP, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tif (!!cp->val == hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_SSP, hdev, data, len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, set_ssp_sync, cmd,\n\t\t\t\t\t set_ssp_complete);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\n\t\tif (cmd)\n\t\t\tmgmt_pending_remove(cmd);\n\t}\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_hs(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tbool changed;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!IS_ENABLED(CONFIG_BT_HS))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tstatus = mgmt_bredr_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS, status);\n\n\tif (!lmp_ssp_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (!hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_find(MGMT_OP_SET_SSP, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (cp->val) {\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_HS_ENABLED);\n\t} else {\n\t\tif (hdev_is_powered(hdev)) {\n\t\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_HS_ENABLED);\n\t}\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_HS, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (changed)\n\t\terr = new_settings(hdev, sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void set_le_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\tu8 status = mgmt_status(err);\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tif (status) {\n\t\tmgmt_pending_foreach(MGMT_OP_SET_LE, hdev, cmd_status_rsp,\n\t\t\t\t\t\t\t&status);\n\t\treturn;\n\t}\n\n\tmgmt_pending_foreach(MGMT_OP_SET_LE, hdev, settings_rsp, &match);\n\n\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n}\n\nstatic int set_le_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_mode *cp = cmd->param;\n\tu8 val = !!cp->val;\n\tint err;\n\n\tif (!val) {\n\t\thci_clear_adv_instance_sync(hdev, NULL, 0x00, true);\n\n\t\tif (hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\t\thci_disable_advertising_sync(hdev);\n\n\t\tif (ext_adv_capable(hdev))\n\t\t\thci_remove_ext_adv_instance_sync(hdev, 0, cmd->sk);\n\t} else {\n\t\thci_dev_set_flag(hdev, HCI_LE_ENABLED);\n\t}\n\n\terr = hci_write_le_host_supported_sync(hdev, val, 0);\n\n\t \n\tif (!err && hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\n\t\tif (ext_adv_capable(hdev)) {\n\t\t\tint status;\n\n\t\t\tstatus = hci_setup_ext_adv_instance_sync(hdev, 0x00);\n\t\t\tif (!status)\n\t\t\t\thci_update_scan_rsp_data_sync(hdev, 0x00);\n\t\t} else {\n\t\t\thci_update_adv_data_sync(hdev, 0x00);\n\t\t\thci_update_scan_rsp_data_sync(hdev, 0x00);\n\t\t}\n\n\t\thci_update_passive_scan(hdev);\n\t}\n\n\treturn err;\n}\n\nstatic void set_mesh_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tu8 status = mgmt_status(err);\n\tstruct sock *sk = cmd->sk;\n\n\tif (status) {\n\t\tmgmt_pending_foreach(MGMT_OP_SET_MESH_RECEIVER, hdev,\n\t\t\t\t     cmd_status_rsp, &status);\n\t\treturn;\n\t}\n\n\tmgmt_pending_remove(cmd);\n\tmgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_MESH_RECEIVER, 0, NULL, 0);\n}\n\nstatic int set_mesh_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_set_mesh *cp = cmd->param;\n\tsize_t len = cmd->param_len;\n\n\tmemset(hdev->mesh_ad_types, 0, sizeof(hdev->mesh_ad_types));\n\n\tif (cp->enable)\n\t\thci_dev_set_flag(hdev, HCI_MESH);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_MESH);\n\n\tlen -= sizeof(*cp);\n\n\t \n\tif (len <= sizeof(hdev->mesh_ad_types))\n\t\tmemcpy(hdev->mesh_ad_types, cp->ad_types, len);\n\n\thci_update_passive_scan_sync(hdev);\n\treturn 0;\n}\n\nstatic int set_mesh(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_cp_set_mesh *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err = 0;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev) ||\n\t    !hci_dev_test_flag(hdev, HCI_MESH_EXPERIMENTAL))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_MESH_RECEIVER,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->enable != 0x00 && cp->enable != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_MESH_RECEIVER,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_MESH_RECEIVER, hdev, data, len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, set_mesh_sync, cmd,\n\t\t\t\t\t set_mesh_complete);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_MESH_RECEIVER,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\n\t\tif (cmd)\n\t\t\tmgmt_pending_remove(cmd);\n\t}\n\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void mesh_send_start_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_mesh_tx *mesh_tx = data;\n\tstruct mgmt_cp_mesh_send *send = (void *)mesh_tx->param;\n\tunsigned long mesh_send_interval;\n\tu8 mgmt_err = mgmt_status(err);\n\n\t \n\n\tif (mgmt_err) {\n\t\thci_dev_clear_flag(hdev, HCI_MESH_SENDING);\n\t\t \n\t\tmesh_send_complete(hdev, mesh_tx, false);\n\t\treturn;\n\t}\n\n\tmesh_send_interval = msecs_to_jiffies((send->cnt) * 25);\n\tqueue_delayed_work(hdev->req_workqueue, &hdev->mesh_send_done,\n\t\t\t   mesh_send_interval);\n}\n\nstatic int mesh_send_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_mesh_tx *mesh_tx = data;\n\tstruct mgmt_cp_mesh_send *send = (void *)mesh_tx->param;\n\tstruct adv_info *adv, *next_instance;\n\tu8 instance = hdev->le_num_of_adv_sets + 1;\n\tu16 timeout, duration;\n\tint err = 0;\n\n\tif (hdev->le_num_of_adv_sets <= hdev->adv_instance_cnt)\n\t\treturn MGMT_STATUS_BUSY;\n\n\ttimeout = 1000;\n\tduration = send->cnt * INTERVAL_TO_MS(hdev->le_adv_max_interval);\n\tadv = hci_add_adv_instance(hdev, instance, 0,\n\t\t\t\t   send->adv_data_len, send->adv_data,\n\t\t\t\t   0, NULL,\n\t\t\t\t   timeout, duration,\n\t\t\t\t   HCI_ADV_TX_POWER_NO_PREFERENCE,\n\t\t\t\t   hdev->le_adv_min_interval,\n\t\t\t\t   hdev->le_adv_max_interval,\n\t\t\t\t   mesh_tx->handle);\n\n\tif (!IS_ERR(adv))\n\t\tmesh_tx->instance = instance;\n\telse\n\t\terr = PTR_ERR(adv);\n\n\tif (hdev->cur_adv_instance == instance) {\n\t\t \n\t\tcancel_adv_timeout(hdev);\n\n\t\tnext_instance = hci_get_next_instance(hdev, instance);\n\t\tif (next_instance)\n\t\t\tinstance = next_instance->instance;\n\t\telse\n\t\t\tinstance = 0;\n\t} else if (hdev->adv_instance_timeout) {\n\t\t \n\t\tinstance = 0;\n\t}\n\n\tif (instance)\n\t\treturn hci_schedule_adv_instance_sync(hdev, instance, true);\n\n\treturn err;\n}\n\nstatic void send_count(struct mgmt_mesh_tx *mesh_tx, void *data)\n{\n\tstruct mgmt_rp_mesh_read_features *rp = data;\n\n\tif (rp->used_handles >= rp->max_handles)\n\t\treturn;\n\n\trp->handles[rp->used_handles++] = mesh_tx->handle;\n}\n\nstatic int mesh_features(struct sock *sk, struct hci_dev *hdev,\n\t\t\t void *data, u16 len)\n{\n\tstruct mgmt_rp_mesh_read_features rp;\n\n\tif (!lmp_le_capable(hdev) ||\n\t    !hci_dev_test_flag(hdev, HCI_MESH_EXPERIMENTAL))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_MESH_READ_FEATURES,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tmemset(&rp, 0, sizeof(rp));\n\trp.index = cpu_to_le16(hdev->id);\n\tif (hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\trp.max_handles = MESH_HANDLES_MAX;\n\n\thci_dev_lock(hdev);\n\n\tif (rp.max_handles)\n\t\tmgmt_mesh_foreach(hdev, send_count, &rp, sk);\n\n\tmgmt_cmd_complete(sk, hdev->id, MGMT_OP_MESH_READ_FEATURES, 0, &rp,\n\t\t\t  rp.used_handles + sizeof(rp) - MESH_HANDLES_MAX);\n\n\thci_dev_unlock(hdev);\n\treturn 0;\n}\n\nstatic int send_cancel(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_mesh_send_cancel *cancel = (void *)cmd->param;\n\tstruct mgmt_mesh_tx *mesh_tx;\n\n\tif (!cancel->handle) {\n\t\tdo {\n\t\t\tmesh_tx = mgmt_mesh_next(hdev, cmd->sk);\n\n\t\t\tif (mesh_tx)\n\t\t\t\tmesh_send_complete(hdev, mesh_tx, false);\n\t\t} while (mesh_tx);\n\t} else {\n\t\tmesh_tx = mgmt_mesh_find(hdev, cancel->handle);\n\n\t\tif (mesh_tx && mesh_tx->sk == cmd->sk)\n\t\t\tmesh_send_complete(hdev, mesh_tx, false);\n\t}\n\n\tmgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_MESH_SEND_CANCEL,\n\t\t\t  0, NULL, 0);\n\tmgmt_pending_free(cmd);\n\n\treturn 0;\n}\n\nstatic int mesh_send_cancel(struct sock *sk, struct hci_dev *hdev,\n\t\t\t    void *data, u16 len)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tif (!lmp_le_capable(hdev) ||\n\t    !hci_dev_test_flag(hdev, HCI_MESH_EXPERIMENTAL))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_MESH_SEND_CANCEL,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_MESH_SEND_CANCEL,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\thci_dev_lock(hdev);\n\tcmd = mgmt_pending_new(sk, MGMT_OP_MESH_SEND_CANCEL, hdev, data, len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, send_cancel, cmd, NULL);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_MESH_SEND_CANCEL,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\n\t\tif (cmd)\n\t\t\tmgmt_pending_free(cmd);\n\t}\n\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int mesh_send(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_mesh_tx *mesh_tx;\n\tstruct mgmt_cp_mesh_send *send = data;\n\tstruct mgmt_rp_mesh_read_features rp;\n\tbool sending;\n\tint err = 0;\n\n\tif (!lmp_le_capable(hdev) ||\n\t    !hci_dev_test_flag(hdev, HCI_MESH_EXPERIMENTAL))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_MESH_SEND,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED) ||\n\t    len <= MGMT_MESH_SEND_SIZE ||\n\t    len > (MGMT_MESH_SEND_SIZE + 31))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_MESH_SEND,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\thci_dev_lock(hdev);\n\n\tmemset(&rp, 0, sizeof(rp));\n\trp.max_handles = MESH_HANDLES_MAX;\n\n\tmgmt_mesh_foreach(hdev, send_count, &rp, sk);\n\n\tif (rp.max_handles <= rp.used_handles) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_MESH_SEND,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto done;\n\t}\n\n\tsending = hci_dev_test_flag(hdev, HCI_MESH_SENDING);\n\tmesh_tx = mgmt_mesh_add(sk, hdev, send, len);\n\n\tif (!mesh_tx)\n\t\terr = -ENOMEM;\n\telse if (!sending)\n\t\terr = hci_cmd_sync_queue(hdev, mesh_send_sync, mesh_tx,\n\t\t\t\t\t mesh_send_start_complete);\n\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Send Mesh Failed %d\", err);\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_MESH_SEND,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\n\t\tif (mesh_tx) {\n\t\t\tif (sending)\n\t\t\t\tmgmt_mesh_remove(mesh_tx);\n\t\t}\n\t} else {\n\t\thci_dev_set_flag(hdev, HCI_MESH_SENDING);\n\n\t\tmgmt_cmd_complete(sk, hdev->id, MGMT_OP_MESH_SEND, 0,\n\t\t\t\t  &mesh_tx->handle, 1);\n\t}\n\ndone:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_le(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\tu8 val, enabled;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\n\t\tif (cp->val == 0x01)\n\t\t\treturn send_settings_rsp(sk, MGMT_OP_SET_LE, hdev);\n\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\t}\n\n\thci_dev_lock(hdev);\n\n\tval = !!cp->val;\n\tenabled = lmp_host_le_capable(hdev);\n\n\tif (!hdev_is_powered(hdev) || val == enabled) {\n\t\tbool changed = false;\n\n\t\tif (val != hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\n\t\t\thci_dev_change_flag(hdev, HCI_LE_ENABLED);\n\t\t\tchanged = true;\n\t\t}\n\n\t\tif (!val && hci_dev_test_flag(hdev, HCI_ADVERTISING)) {\n\t\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING);\n\t\t\tchanged = true;\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_LE, hdev);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto unlock;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_LE, hdev) ||\n\t    pending_find(MGMT_OP_SET_ADVERTISING, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_LE, hdev, data, len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, set_le_sync, cmd,\n\t\t\t\t\t set_le_complete);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\n\t\tif (cmd)\n\t\t\tmgmt_pending_remove(cmd);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\n \nstatic bool pending_eir_or_class(struct hci_dev *hdev)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\n\t\tswitch (cmd->opcode) {\n\t\tcase MGMT_OP_ADD_UUID:\n\t\tcase MGMT_OP_REMOVE_UUID:\n\t\tcase MGMT_OP_SET_DEV_CLASS:\n\t\tcase MGMT_OP_SET_POWERED:\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic const u8 bluetooth_base_uuid[] = {\n\t\t\t0xfb, 0x34, 0x9b, 0x5f, 0x80, 0x00, 0x00, 0x80,\n\t\t\t0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n};\n\nstatic u8 get_uuid_size(const u8 *uuid)\n{\n\tu32 val;\n\n\tif (memcmp(uuid, bluetooth_base_uuid, 12))\n\t\treturn 128;\n\n\tval = get_unaligned_le32(&uuid[12]);\n\tif (val > 0xffff)\n\t\treturn 32;\n\n\treturn 16;\n}\n\nstatic void mgmt_class_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t  mgmt_status(err), hdev->dev_class, 3);\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic int add_uuid_sync(struct hci_dev *hdev, void *data)\n{\n\tint err;\n\n\terr = hci_update_class_sync(hdev);\n\tif (err)\n\t\treturn err;\n\n\treturn hci_update_eir_sync(hdev);\n}\n\nstatic int add_uuid(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_cp_add_uuid *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct bt_uuid *uuid;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_eir_or_class(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_UUID,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tuuid = kmalloc(sizeof(*uuid), GFP_KERNEL);\n\tif (!uuid) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tmemcpy(uuid->uuid, cp->uuid, 16);\n\tuuid->svc_hint = cp->svc_hint;\n\tuuid->size = get_uuid_size(cp->uuid);\n\n\tlist_add_tail(&uuid->list, &hdev->uuids);\n\n\tcmd = mgmt_pending_new(sk, MGMT_OP_ADD_UUID, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, add_uuid_sync, cmd, mgmt_class_complete);\n\tif (err < 0) {\n\t\tmgmt_pending_free(cmd);\n\t\tgoto failed;\n\t}\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic bool enable_service_cache(struct hci_dev *hdev)\n{\n\tif (!hdev_is_powered(hdev))\n\t\treturn false;\n\n\tif (!hci_dev_test_and_set_flag(hdev, HCI_SERVICE_CACHE)) {\n\t\tqueue_delayed_work(hdev->workqueue, &hdev->service_cache,\n\t\t\t\t   CACHE_TIMEOUT);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int remove_uuid_sync(struct hci_dev *hdev, void *data)\n{\n\tint err;\n\n\terr = hci_update_class_sync(hdev);\n\tif (err)\n\t\treturn err;\n\n\treturn hci_update_eir_sync(hdev);\n}\n\nstatic int remove_uuid(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t       u16 len)\n{\n\tstruct mgmt_cp_remove_uuid *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct bt_uuid *match, *tmp;\n\tstatic const u8 bt_uuid_any[] = {\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n\t};\n\tint err, found;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_eir_or_class(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (memcmp(cp->uuid, bt_uuid_any, 16) == 0) {\n\t\thci_uuids_clear(hdev);\n\n\t\tif (enable_service_cache(hdev)) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_UUID,\n\t\t\t\t\t\t0, hdev->dev_class, 3);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tgoto update_class;\n\t}\n\n\tfound = 0;\n\n\tlist_for_each_entry_safe(match, tmp, &hdev->uuids, list) {\n\t\tif (memcmp(match->uuid, cp->uuid, 16) != 0)\n\t\t\tcontinue;\n\n\t\tlist_del(&match->list);\n\t\tkfree(match);\n\t\tfound++;\n\t}\n\n\tif (found == 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\nupdate_class:\n\tcmd = mgmt_pending_new(sk, MGMT_OP_REMOVE_UUID, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, remove_uuid_sync, cmd,\n\t\t\t\t mgmt_class_complete);\n\tif (err < 0)\n\t\tmgmt_pending_free(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_class_sync(struct hci_dev *hdev, void *data)\n{\n\tint err = 0;\n\n\tif (hci_dev_test_and_clear_flag(hdev, HCI_SERVICE_CACHE)) {\n\t\tcancel_delayed_work_sync(&hdev->service_cache);\n\t\terr = hci_update_eir_sync(hdev);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\treturn hci_update_class_sync(hdev);\n}\n\nstatic int set_dev_class(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 len)\n{\n\tstruct mgmt_cp_set_dev_class *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_bredr_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_eir_or_class(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif ((cp->minor & 0x03) != 0 || (cp->major & 0xe0) != 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\thdev->major_class = cp->major;\n\thdev->minor_class = cp->minor;\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,\n\t\t\t\t\thdev->dev_class, 3);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_new(sk, MGMT_OP_SET_DEV_CLASS, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, set_class_sync, cmd,\n\t\t\t\t mgmt_class_complete);\n\tif (err < 0)\n\t\tmgmt_pending_free(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int load_link_keys(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct mgmt_cp_load_link_keys *cp = data;\n\tconst u16 max_key_count = ((U16_MAX - sizeof(*cp)) /\n\t\t\t\t   sizeof(struct mgmt_link_key_info));\n\tu16 key_count, expected_len;\n\tbool changed;\n\tint i;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_bredr_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tkey_count = __le16_to_cpu(cp->key_count);\n\tif (key_count > max_key_count) {\n\t\tbt_dev_err(hdev, \"load_link_keys: too big key_count value %u\",\n\t\t\t   key_count);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\texpected_len = struct_size(cp, keys, key_count);\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"load_link_keys: expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\tif (cp->debug_keys != 0x00 && cp->debug_keys != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tbt_dev_dbg(hdev, \"debug_keys %u key_count %u\", cp->debug_keys,\n\t\t   key_count);\n\n\tfor (i = 0; i < key_count; i++) {\n\t\tstruct mgmt_link_key_info *key = &cp->keys[i];\n\n\t\t \n\t\tif (key->type > 0x08)\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\thci_dev_lock(hdev);\n\n\thci_link_keys_clear(hdev);\n\n\tif (cp->debug_keys)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_KEEP_DEBUG_KEYS);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t      HCI_KEEP_DEBUG_KEYS);\n\n\tif (changed)\n\t\tnew_settings(hdev, NULL);\n\n\tfor (i = 0; i < key_count; i++) {\n\t\tstruct mgmt_link_key_info *key = &cp->keys[i];\n\n\t\tif (hci_is_blocked_key(hdev,\n\t\t\t\t       HCI_BLOCKED_KEY_TYPE_LINKKEY,\n\t\t\t\t       key->val)) {\n\t\t\tbt_dev_warn(hdev, \"Skipping blocked link key for %pMR\",\n\t\t\t\t    &key->addr.bdaddr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (key->type == HCI_LK_DEBUG_COMBINATION)\n\t\t\tcontinue;\n\n\t\thci_add_link_key(hdev, NULL, &key->addr.bdaddr, key->val,\n\t\t\t\t key->type, key->pin_len, NULL);\n\t}\n\n\tmgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS, 0, NULL, 0);\n\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int device_unpaired(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t   u8 addr_type, struct sock *skip_sk)\n{\n\tstruct mgmt_ev_device_unpaired ev;\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = addr_type;\n\n\treturn mgmt_event(MGMT_EV_DEVICE_UNPAIRED, hdev, &ev, sizeof(ev),\n\t\t\t  skip_sk);\n}\n\nstatic void unpair_device_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_unpair_device *cp = cmd->param;\n\n\tif (!err)\n\t\tdevice_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, cmd->sk);\n\n\tcmd->cmd_complete(cmd, err);\n\tmgmt_pending_free(cmd);\n}\n\nstatic int unpair_device_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_unpair_device *cp = cmd->param;\n\tstruct hci_conn *conn;\n\n\tif (cp->addr.type == BDADDR_BREDR)\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\n\t\t\t\t\t       &cp->addr.bdaddr);\n\telse\n\t\tconn = hci_conn_hash_lookup_le(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t       le_addr_type(cp->addr.type));\n\n\tif (!conn)\n\t\treturn 0;\n\n\treturn hci_abort_conn_sync(hdev, conn, HCI_ERROR_REMOTE_USER_TERM);\n}\n\nstatic int unpair_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 len)\n{\n\tstruct mgmt_cp_unpair_device *cp = data;\n\tstruct mgmt_rp_unpair_device rp;\n\tstruct hci_conn_params *params;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\tu8 addr_type;\n\tint err;\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\tif (cp->disconnect != 0x00 && cp->disconnect != 0x01)\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\t \n\t\tif (cp->disconnect)\n\t\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\n\t\t\t\t\t\t       &cp->addr.bdaddr);\n\t\telse\n\t\t\tconn = NULL;\n\n\t\terr = hci_remove_link_key(hdev, &cp->addr.bdaddr);\n\t\tif (err < 0) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_UNPAIR_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_NOT_PAIRED, &rp,\n\t\t\t\t\t\tsizeof(rp));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\t \n\taddr_type = le_addr_type(cp->addr.type);\n\n\t \n\terr = smp_cancel_and_remove_pairing(hdev, &cp->addr.bdaddr, addr_type);\n\tif (err < 0) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_NOT_PAIRED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tconn = hci_conn_hash_lookup_le(hdev, &cp->addr.bdaddr, addr_type);\n\tif (!conn) {\n\t\thci_conn_params_del(hdev, &cp->addr.bdaddr, addr_type);\n\t\tgoto done;\n\t}\n\n\n\t \n\tset_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags);\n\n\t \n\tparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr, addr_type);\n\tif (params) {\n\t\tif (params->explicit_connect)\n\t\t\tparams->auto_connect = HCI_AUTO_CONN_EXPLICIT;\n\t\telse\n\t\t\tparams->auto_connect = HCI_AUTO_CONN_DISABLED;\n\t}\n\n\t \n\tif (!cp->disconnect)\n\t\tconn = NULL;\n\ndone:\n\t \n\tif (!conn) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE, 0,\n\t\t\t\t\t&rp, sizeof(rp));\n\t\tdevice_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, sk);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_new(sk, MGMT_OP_UNPAIR_DEVICE, hdev, cp,\n\t\t\t       sizeof(*cp));\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tcmd->cmd_complete = addr_cmd_complete;\n\n\terr = hci_cmd_sync_queue(hdev, unpair_device_sync, cmd,\n\t\t\t\t unpair_device_complete);\n\tif (err < 0)\n\t\tmgmt_pending_free(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int disconnect(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t      u16 len)\n{\n\tstruct mgmt_cp_disconnect *cp = data;\n\tstruct mgmt_rp_disconnect rp;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!test_bit(HCI_UP, &hdev->flags)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_DISCONNECT, hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\n\t\t\t\t\tMGMT_STATUS_BUSY, &rp, sizeof(rp));\n\t\tgoto failed;\n\t}\n\n\tif (cp->addr.type == BDADDR_BREDR)\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\n\t\t\t\t\t       &cp->addr.bdaddr);\n\telse\n\t\tconn = hci_conn_hash_lookup_le(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t       le_addr_type(cp->addr.type));\n\n\tif (!conn || conn->state == BT_OPEN || conn->state == BT_CLOSED) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\n\t\t\t\t\tMGMT_STATUS_NOT_CONNECTED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_DISCONNECT, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tcmd->cmd_complete = generic_cmd_complete;\n\n\terr = hci_disconnect(conn, HCI_ERROR_REMOTE_USER_TERM);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic u8 link_to_bdaddr(u8 link_type, u8 addr_type)\n{\n\tswitch (link_type) {\n\tcase LE_LINK:\n\t\tswitch (addr_type) {\n\t\tcase ADDR_LE_DEV_PUBLIC:\n\t\t\treturn BDADDR_LE_PUBLIC;\n\n\t\tdefault:\n\t\t\t \n\t\t\treturn BDADDR_LE_RANDOM;\n\t\t}\n\n\tdefault:\n\t\t \n\t\treturn BDADDR_BREDR;\n\t}\n}\n\nstatic int get_connections(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t   u16 data_len)\n{\n\tstruct mgmt_rp_get_connections *rp;\n\tstruct hci_conn *c;\n\tint err;\n\tu16 i;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_CONNECTIONS,\n\t\t\t\t      MGMT_STATUS_NOT_POWERED);\n\t\tgoto unlock;\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(c, &hdev->conn_hash.list, list) {\n\t\tif (test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))\n\t\t\ti++;\n\t}\n\n\trp = kmalloc(struct_size(rp, addr, i), GFP_KERNEL);\n\tif (!rp) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(c, &hdev->conn_hash.list, list) {\n\t\tif (!test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))\n\t\t\tcontinue;\n\t\tbacpy(&rp->addr[i].bdaddr, &c->dst);\n\t\trp->addr[i].type = link_to_bdaddr(c->type, c->dst_type);\n\t\tif (c->type == SCO_LINK || c->type == ESCO_LINK)\n\t\t\tcontinue;\n\t\ti++;\n\t}\n\n\trp->conn_count = cpu_to_le16(i);\n\n\t \n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONNECTIONS, 0, rp,\n\t\t\t\tstruct_size(rp, addr, i));\n\n\tkfree(rp);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int send_pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   struct mgmt_cp_pin_code_neg_reply *cp)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, hdev, cp,\n\t\t\t       sizeof(*cp));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->cmd_complete = addr_cmd_complete;\n\n\terr = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,\n\t\t\t   sizeof(cp->addr.bdaddr), &cp->addr.bdaddr);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\n\treturn err;\n}\n\nstatic int pin_code_reply(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct hci_conn *conn;\n\tstruct mgmt_cp_pin_code_reply *cp = data;\n\tstruct hci_cp_pin_code_reply reply;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\n\t\t\t\t      MGMT_STATUS_NOT_POWERED);\n\t\tgoto failed;\n\t}\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->addr.bdaddr);\n\tif (!conn) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\n\t\t\t\t      MGMT_STATUS_NOT_CONNECTED);\n\t\tgoto failed;\n\t}\n\n\tif (conn->pending_sec_level == BT_SECURITY_HIGH && cp->pin_len != 16) {\n\t\tstruct mgmt_cp_pin_code_neg_reply ncp;\n\n\t\tmemcpy(&ncp.addr, &cp->addr, sizeof(ncp.addr));\n\n\t\tbt_dev_err(hdev, \"PIN code is not 16 bytes long\");\n\n\t\terr = send_pin_code_neg_reply(sk, hdev, &ncp);\n\t\tif (err >= 0)\n\t\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\n\t\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_REPLY, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tcmd->cmd_complete = addr_cmd_complete;\n\n\tbacpy(&reply.bdaddr, &cp->addr.bdaddr);\n\treply.pin_len = cp->pin_len;\n\tmemcpy(reply.pin_code, cp->pin_code, sizeof(reply.pin_code));\n\n\terr = hci_send_cmd(hdev, HCI_OP_PIN_CODE_REPLY, sizeof(reply), &reply);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_io_capability(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t     u16 len)\n{\n\tstruct mgmt_cp_set_io_capability *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (cp->io_capability > SMP_IO_KEYBOARD_DISPLAY)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_IO_CAPABILITY,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\thdev->io_capability = cp->io_capability;\n\n\tbt_dev_dbg(hdev, \"IO capability set to 0x%02x\", hdev->io_capability);\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_IO_CAPABILITY, 0,\n\t\t\t\t NULL, 0);\n}\n\nstatic struct mgmt_pending_cmd *find_pairing(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\n\t\tif (cmd->opcode != MGMT_OP_PAIR_DEVICE)\n\t\t\tcontinue;\n\n\t\tif (cmd->user_data != conn)\n\t\t\tcontinue;\n\n\t\treturn cmd;\n\t}\n\n\treturn NULL;\n}\n\nstatic int pairing_complete(struct mgmt_pending_cmd *cmd, u8 status)\n{\n\tstruct mgmt_rp_pair_device rp;\n\tstruct hci_conn *conn = cmd->user_data;\n\tint err;\n\n\tbacpy(&rp.addr.bdaddr, &conn->dst);\n\trp.addr.type = link_to_bdaddr(conn->type, conn->dst_type);\n\n\terr = mgmt_cmd_complete(cmd->sk, cmd->index, MGMT_OP_PAIR_DEVICE,\n\t\t\t\tstatus, &rp, sizeof(rp));\n\n\t \n\tconn->connect_cfm_cb = NULL;\n\tconn->security_cfm_cb = NULL;\n\tconn->disconn_cfm_cb = NULL;\n\n\thci_conn_drop(conn);\n\n\t \n\tclear_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags);\n\n\thci_conn_put(conn);\n\n\treturn err;\n}\n\nvoid mgmt_smp_complete(struct hci_conn *conn, bool complete)\n{\n\tu8 status = complete ? MGMT_STATUS_SUCCESS : MGMT_STATUS_FAILED;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tcmd = find_pairing(conn);\n\tif (cmd) {\n\t\tcmd->cmd_complete(cmd, status);\n\t\tmgmt_pending_remove(cmd);\n\t}\n}\n\nstatic void pairing_complete_cb(struct hci_conn *conn, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tBT_DBG(\"status %u\", status);\n\n\tcmd = find_pairing(conn);\n\tif (!cmd) {\n\t\tBT_DBG(\"Unable to find a pending command\");\n\t\treturn;\n\t}\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n}\n\nstatic void le_pairing_complete_cb(struct hci_conn *conn, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tBT_DBG(\"status %u\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcmd = find_pairing(conn);\n\tif (!cmd) {\n\t\tBT_DBG(\"Unable to find a pending command\");\n\t\treturn;\n\t}\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n}\n\nstatic int pair_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t       u16 len)\n{\n\tstruct mgmt_cp_pair_device *cp = data;\n\tstruct mgmt_rp_pair_device rp;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 sec_level, auth_type;\n\tstruct hci_conn *conn;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\tif (cp->io_cap > SMP_IO_KEYBOARD_DISPLAY)\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (hci_bdaddr_is_paired(hdev, &cp->addr.bdaddr, cp->addr.type)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_ALREADY_PAIRED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tsec_level = BT_SECURITY_MEDIUM;\n\tauth_type = HCI_AT_DEDICATED_BONDING;\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\tconn = hci_connect_acl(hdev, &cp->addr.bdaddr, sec_level,\n\t\t\t\t       auth_type, CONN_REASON_PAIR_DEVICE);\n\t} else {\n\t\tu8 addr_type = le_addr_type(cp->addr.type);\n\t\tstruct hci_conn_params *p;\n\n\t\t \n\t\tp = hci_conn_params_add(hdev, &cp->addr.bdaddr, addr_type);\n\n\t\tif (p->auto_connect == HCI_AUTO_CONN_EXPLICIT)\n\t\t\tp->auto_connect = HCI_AUTO_CONN_DISABLED;\n\n\t\tconn = hci_connect_le_scan(hdev, &cp->addr.bdaddr, addr_type,\n\t\t\t\t\t   sec_level, HCI_LE_CONN_TIMEOUT,\n\t\t\t\t\t   CONN_REASON_PAIR_DEVICE);\n\t}\n\n\tif (IS_ERR(conn)) {\n\t\tint status;\n\n\t\tif (PTR_ERR(conn) == -EBUSY)\n\t\t\tstatus = MGMT_STATUS_BUSY;\n\t\telse if (PTR_ERR(conn) == -EOPNOTSUPP)\n\t\t\tstatus = MGMT_STATUS_NOT_SUPPORTED;\n\t\telse if (PTR_ERR(conn) == -ECONNREFUSED)\n\t\t\tstatus = MGMT_STATUS_REJECTED;\n\t\telse\n\t\t\tstatus = MGMT_STATUS_CONNECT_FAILED;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tstatus, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (conn->connect_cfm_cb) {\n\t\thci_conn_drop(conn);\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_BUSY, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\thci_conn_drop(conn);\n\t\tgoto unlock;\n\t}\n\n\tcmd->cmd_complete = pairing_complete;\n\n\t \n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\tconn->connect_cfm_cb = pairing_complete_cb;\n\t\tconn->security_cfm_cb = pairing_complete_cb;\n\t\tconn->disconn_cfm_cb = pairing_complete_cb;\n\t} else {\n\t\tconn->connect_cfm_cb = le_pairing_complete_cb;\n\t\tconn->security_cfm_cb = le_pairing_complete_cb;\n\t\tconn->disconn_cfm_cb = le_pairing_complete_cb;\n\t}\n\n\tconn->io_capability = cp->io_cap;\n\tcmd->user_data = hci_conn_get(conn);\n\n\tif ((conn->state == BT_CONNECTED || conn->state == BT_CONFIG) &&\n\t    hci_conn_security(conn, sec_level, auth_type, true)) {\n\t\tcmd->cmd_complete(cmd, 0);\n\t\tmgmt_pending_remove(cmd);\n\t}\n\n\terr = 0;\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int cancel_pair_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t      u16 len)\n{\n\tstruct mgmt_addr_info *addr = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\n\t\t\t\t      MGMT_STATUS_NOT_POWERED);\n\t\tgoto unlock;\n\t}\n\n\tcmd = pending_find(MGMT_OP_PAIR_DEVICE, hdev);\n\tif (!cmd) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\tconn = cmd->user_data;\n\n\tif (bacmp(&addr->bdaddr, &conn->dst) != 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\tcmd->cmd_complete(cmd, MGMT_STATUS_CANCELLED);\n\tmgmt_pending_remove(cmd);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE, 0,\n\t\t\t\taddr, sizeof(*addr));\n\n\t \n\tif (addr->type == BDADDR_BREDR)\n\t\thci_remove_link_key(hdev, &addr->bdaddr);\n\telse\n\t\tsmp_cancel_and_remove_pairing(hdev, &addr->bdaddr,\n\t\t\t\t\t      le_addr_type(addr->type));\n\n\tif (conn->conn_reason == CONN_REASON_PAIR_DEVICE)\n\t\thci_abort_conn(conn, HCI_ERROR_REMOTE_USER_TERM);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int user_pairing_resp(struct sock *sk, struct hci_dev *hdev,\n\t\t\t     struct mgmt_addr_info *addr, u16 mgmt_op,\n\t\t\t     u16 hci_op, __le32 passkey)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\tint err;\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, addr,\n\t\t\t\t\tsizeof(*addr));\n\t\tgoto done;\n\t}\n\n\tif (addr->type == BDADDR_BREDR)\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &addr->bdaddr);\n\telse\n\t\tconn = hci_conn_hash_lookup_le(hdev, &addr->bdaddr,\n\t\t\t\t\t       le_addr_type(addr->type));\n\n\tif (!conn) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\n\t\t\t\t\tMGMT_STATUS_NOT_CONNECTED, addr,\n\t\t\t\t\tsizeof(*addr));\n\t\tgoto done;\n\t}\n\n\tif (addr->type == BDADDR_LE_PUBLIC || addr->type == BDADDR_LE_RANDOM) {\n\t\terr = smp_user_confirm_reply(conn, mgmt_op, passkey);\n\t\tif (!err)\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\n\t\t\t\t\t\tMGMT_STATUS_SUCCESS, addr,\n\t\t\t\t\t\tsizeof(*addr));\n\t\telse\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\n\t\t\t\t\t\tMGMT_STATUS_FAILED, addr,\n\t\t\t\t\t\tsizeof(*addr));\n\n\t\tgoto done;\n\t}\n\n\tcmd = mgmt_pending_add(sk, mgmt_op, hdev, addr, sizeof(*addr));\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tcmd->cmd_complete = addr_cmd_complete;\n\n\t \n\tif (hci_op == HCI_OP_USER_PASSKEY_REPLY) {\n\t\tstruct hci_cp_user_passkey_reply cp;\n\n\t\tbacpy(&cp.bdaddr, &addr->bdaddr);\n\t\tcp.passkey = passkey;\n\t\terr = hci_send_cmd(hdev, hci_op, sizeof(cp), &cp);\n\t} else\n\t\terr = hci_send_cmd(hdev, hci_op, sizeof(addr->bdaddr),\n\t\t\t\t   &addr->bdaddr);\n\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\ndone:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 len)\n{\n\tstruct mgmt_cp_pin_code_neg_reply *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\treturn user_pairing_resp(sk, hdev, &cp->addr,\n\t\t\t\tMGMT_OP_PIN_CODE_NEG_REPLY,\n\t\t\t\tHCI_OP_PIN_CODE_NEG_REPLY, 0);\n}\n\nstatic int user_confirm_reply(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t      u16 len)\n{\n\tstruct mgmt_cp_user_confirm_reply *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (len != sizeof(*cp))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_USER_CONFIRM_REPLY,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\treturn user_pairing_resp(sk, hdev, &cp->addr,\n\t\t\t\t MGMT_OP_USER_CONFIRM_REPLY,\n\t\t\t\t HCI_OP_USER_CONFIRM_REPLY, 0);\n}\n\nstatic int user_confirm_neg_reply(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  void *data, u16 len)\n{\n\tstruct mgmt_cp_user_confirm_neg_reply *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\treturn user_pairing_resp(sk, hdev, &cp->addr,\n\t\t\t\t MGMT_OP_USER_CONFIRM_NEG_REPLY,\n\t\t\t\t HCI_OP_USER_CONFIRM_NEG_REPLY, 0);\n}\n\nstatic int user_passkey_reply(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t      u16 len)\n{\n\tstruct mgmt_cp_user_passkey_reply *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\treturn user_pairing_resp(sk, hdev, &cp->addr,\n\t\t\t\t MGMT_OP_USER_PASSKEY_REPLY,\n\t\t\t\t HCI_OP_USER_PASSKEY_REPLY, cp->passkey);\n}\n\nstatic int user_passkey_neg_reply(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  void *data, u16 len)\n{\n\tstruct mgmt_cp_user_passkey_neg_reply *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\treturn user_pairing_resp(sk, hdev, &cp->addr,\n\t\t\t\t MGMT_OP_USER_PASSKEY_NEG_REPLY,\n\t\t\t\t HCI_OP_USER_PASSKEY_NEG_REPLY, 0);\n}\n\nstatic int adv_expire_sync(struct hci_dev *hdev, u32 flags)\n{\n\tstruct adv_info *adv_instance;\n\n\tadv_instance = hci_find_adv_instance(hdev, hdev->cur_adv_instance);\n\tif (!adv_instance)\n\t\treturn 0;\n\n\t \n\tif (!(adv_instance->flags & flags))\n\t\treturn 0;\n\n\tcancel_adv_timeout(hdev);\n\n\tadv_instance = hci_get_next_instance(hdev, adv_instance->instance);\n\tif (!adv_instance)\n\t\treturn 0;\n\n\thci_schedule_adv_instance_sync(hdev, adv_instance->instance, true);\n\n\treturn 0;\n}\n\nstatic int name_changed_sync(struct hci_dev *hdev, void *data)\n{\n\treturn adv_expire_sync(hdev, MGMT_ADV_FLAG_LOCAL_NAME);\n}\n\nstatic void set_name_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_set_local_name *cp = cmd->param;\n\tu8 status = mgmt_status(err);\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tif (cmd != pending_find(MGMT_OP_SET_LOCAL_NAME, hdev))\n\t\treturn;\n\n\tif (status) {\n\t\tmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME,\n\t\t\t\tstatus);\n\t} else {\n\t\tmgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\n\t\t\t\t  cp, sizeof(*cp));\n\n\t\tif (hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\t\thci_cmd_sync_queue(hdev, name_changed_sync, NULL, NULL);\n\t}\n\n\tmgmt_pending_remove(cmd);\n}\n\nstatic int set_name_sync(struct hci_dev *hdev, void *data)\n{\n\tif (lmp_bredr_capable(hdev)) {\n\t\thci_update_name_sync(hdev);\n\t\thci_update_eir_sync(hdev);\n\t}\n\n\t \n\tif (lmp_le_capable(hdev) && hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\thci_update_scan_rsp_data_sync(hdev, hdev->cur_adv_instance);\n\n\treturn 0;\n}\n\nstatic int set_local_name(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct mgmt_cp_set_local_name *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\t \n\tif (!memcmp(hdev->dev_name, cp->name, sizeof(hdev->dev_name)) &&\n\t    !memcmp(hdev->short_name, cp->short_name,\n\t\t    sizeof(hdev->short_name))) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\n\t\t\t\t\tdata, len);\n\t\tgoto failed;\n\t}\n\n\tmemcpy(hdev->short_name, cp->short_name, sizeof(hdev->short_name));\n\n\tif (!hdev_is_powered(hdev)) {\n\t\tmemcpy(hdev->dev_name, cp->name, sizeof(hdev->dev_name));\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\n\t\t\t\t\tdata, len);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\terr = mgmt_limited_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, data,\n\t\t\t\t\t len, HCI_MGMT_LOCAL_NAME_EVENTS, sk);\n\t\text_info_changed(hdev, sk);\n\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_LOCAL_NAME, hdev, data, len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, set_name_sync, cmd,\n\t\t\t\t\t set_name_complete);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\n\t\tif (cmd)\n\t\t\tmgmt_pending_remove(cmd);\n\n\t\tgoto failed;\n\t}\n\n\tmemcpy(hdev->dev_name, cp->name, sizeof(hdev->dev_name));\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int appearance_changed_sync(struct hci_dev *hdev, void *data)\n{\n\treturn adv_expire_sync(hdev, MGMT_ADV_FLAG_APPEARANCE);\n}\n\nstatic int set_appearance(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct mgmt_cp_set_appearance *cp = data;\n\tu16 appearance;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_APPEARANCE,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tappearance = le16_to_cpu(cp->appearance);\n\n\thci_dev_lock(hdev);\n\n\tif (hdev->appearance != appearance) {\n\t\thdev->appearance = appearance;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\t\thci_cmd_sync_queue(hdev, appearance_changed_sync, NULL,\n\t\t\t\t\t   NULL);\n\n\t\text_info_changed(hdev, sk);\n\t}\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_APPEARANCE, 0, NULL,\n\t\t\t\t0);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int get_phy_configuration(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t void *data, u16 len)\n{\n\tstruct mgmt_rp_get_phy_configuration rp;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tmemset(&rp, 0, sizeof(rp));\n\n\trp.supported_phys = cpu_to_le32(get_supported_phys(hdev));\n\trp.selected_phys = cpu_to_le32(get_selected_phys(hdev));\n\trp.configurable_phys = cpu_to_le32(get_configurable_phys(hdev));\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_PHY_CONFIGURATION, 0,\n\t\t\t\t &rp, sizeof(rp));\n}\n\nint mgmt_phy_configuration_changed(struct hci_dev *hdev, struct sock *skip)\n{\n\tstruct mgmt_ev_phy_configuration_changed ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tev.selected_phys = cpu_to_le32(get_selected_phys(hdev));\n\n\treturn mgmt_event(MGMT_EV_PHY_CONFIGURATION_CHANGED, hdev, &ev,\n\t\t\t  sizeof(ev), skip);\n}\n\nstatic void set_default_phy_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct sk_buff *skb = cmd->skb;\n\tu8 status = mgmt_status(err);\n\n\tif (cmd != pending_find(MGMT_OP_SET_PHY_CONFIGURATION, hdev))\n\t\treturn;\n\n\tif (!status) {\n\t\tif (!skb)\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\telse if (IS_ERR(skb))\n\t\t\tstatus = mgmt_status(PTR_ERR(skb));\n\t\telse\n\t\t\tstatus = mgmt_status(skb->data[0]);\n\t}\n\n\tbt_dev_dbg(hdev, \"status %d\", status);\n\n\tif (status) {\n\t\tmgmt_cmd_status(cmd->sk, hdev->id,\n\t\t\t\tMGMT_OP_SET_PHY_CONFIGURATION, status);\n\t} else {\n\t\tmgmt_cmd_complete(cmd->sk, hdev->id,\n\t\t\t\t  MGMT_OP_SET_PHY_CONFIGURATION, 0,\n\t\t\t\t  NULL, 0);\n\n\t\tmgmt_phy_configuration_changed(hdev, cmd->sk);\n\t}\n\n\tif (skb && !IS_ERR(skb))\n\t\tkfree_skb(skb);\n\n\tmgmt_pending_remove(cmd);\n}\n\nstatic int set_default_phy_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_set_phy_configuration *cp = cmd->param;\n\tstruct hci_cp_le_set_default_phy cp_phy;\n\tu32 selected_phys = __le32_to_cpu(cp->selected_phys);\n\n\tmemset(&cp_phy, 0, sizeof(cp_phy));\n\n\tif (!(selected_phys & MGMT_PHY_LE_TX_MASK))\n\t\tcp_phy.all_phys |= 0x01;\n\n\tif (!(selected_phys & MGMT_PHY_LE_RX_MASK))\n\t\tcp_phy.all_phys |= 0x02;\n\n\tif (selected_phys & MGMT_PHY_LE_1M_TX)\n\t\tcp_phy.tx_phys |= HCI_LE_SET_PHY_1M;\n\n\tif (selected_phys & MGMT_PHY_LE_2M_TX)\n\t\tcp_phy.tx_phys |= HCI_LE_SET_PHY_2M;\n\n\tif (selected_phys & MGMT_PHY_LE_CODED_TX)\n\t\tcp_phy.tx_phys |= HCI_LE_SET_PHY_CODED;\n\n\tif (selected_phys & MGMT_PHY_LE_1M_RX)\n\t\tcp_phy.rx_phys |= HCI_LE_SET_PHY_1M;\n\n\tif (selected_phys & MGMT_PHY_LE_2M_RX)\n\t\tcp_phy.rx_phys |= HCI_LE_SET_PHY_2M;\n\n\tif (selected_phys & MGMT_PHY_LE_CODED_RX)\n\t\tcp_phy.rx_phys |= HCI_LE_SET_PHY_CODED;\n\n\tcmd->skb =  __hci_cmd_sync(hdev, HCI_OP_LE_SET_DEFAULT_PHY,\n\t\t\t\t   sizeof(cp_phy), &cp_phy, HCI_CMD_TIMEOUT);\n\n\treturn 0;\n}\n\nstatic int set_phy_configuration(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t void *data, u16 len)\n{\n\tstruct mgmt_cp_set_phy_configuration *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu32 selected_phys, configurable_phys, supported_phys, unconfigure_phys;\n\tu16 pkt_type = (HCI_DH1 | HCI_DM1);\n\tbool changed = false;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tconfigurable_phys = get_configurable_phys(hdev);\n\tsupported_phys = get_supported_phys(hdev);\n\tselected_phys = __le32_to_cpu(cp->selected_phys);\n\n\tif (selected_phys & ~supported_phys)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tunconfigure_phys = supported_phys & ~configurable_phys;\n\n\tif ((selected_phys & unconfigure_phys) != unconfigure_phys)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (selected_phys == get_selected_phys(hdev))\n\t\treturn mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t\t 0, NULL, 0);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto unlock;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_PHY_CONFIGURATION, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (selected_phys & MGMT_PHY_BR_1M_3SLOT)\n\t\tpkt_type |= (HCI_DH3 | HCI_DM3);\n\telse\n\t\tpkt_type &= ~(HCI_DH3 | HCI_DM3);\n\n\tif (selected_phys & MGMT_PHY_BR_1M_5SLOT)\n\t\tpkt_type |= (HCI_DH5 | HCI_DM5);\n\telse\n\t\tpkt_type &= ~(HCI_DH5 | HCI_DM5);\n\n\tif (selected_phys & MGMT_PHY_EDR_2M_1SLOT)\n\t\tpkt_type &= ~HCI_2DH1;\n\telse\n\t\tpkt_type |= HCI_2DH1;\n\n\tif (selected_phys & MGMT_PHY_EDR_2M_3SLOT)\n\t\tpkt_type &= ~HCI_2DH3;\n\telse\n\t\tpkt_type |= HCI_2DH3;\n\n\tif (selected_phys & MGMT_PHY_EDR_2M_5SLOT)\n\t\tpkt_type &= ~HCI_2DH5;\n\telse\n\t\tpkt_type |= HCI_2DH5;\n\n\tif (selected_phys & MGMT_PHY_EDR_3M_1SLOT)\n\t\tpkt_type &= ~HCI_3DH1;\n\telse\n\t\tpkt_type |= HCI_3DH1;\n\n\tif (selected_phys & MGMT_PHY_EDR_3M_3SLOT)\n\t\tpkt_type &= ~HCI_3DH3;\n\telse\n\t\tpkt_type |= HCI_3DH3;\n\n\tif (selected_phys & MGMT_PHY_EDR_3M_5SLOT)\n\t\tpkt_type &= ~HCI_3DH5;\n\telse\n\t\tpkt_type |= HCI_3DH5;\n\n\tif (pkt_type != hdev->pkt_type) {\n\t\thdev->pkt_type = pkt_type;\n\t\tchanged = true;\n\t}\n\n\tif ((selected_phys & MGMT_PHY_LE_MASK) ==\n\t    (get_selected_phys(hdev) & MGMT_PHY_LE_MASK)) {\n\t\tif (changed)\n\t\t\tmgmt_phy_configuration_changed(hdev, sk);\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t\t0, NULL, 0);\n\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_PHY_CONFIGURATION, hdev, data,\n\t\t\t       len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, set_default_phy_sync, cmd,\n\t\t\t\t\t set_default_phy_complete);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\n\t\tif (cmd)\n\t\t\tmgmt_pending_remove(cmd);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int set_blocked_keys(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t    u16 len)\n{\n\tint err = MGMT_STATUS_SUCCESS;\n\tstruct mgmt_cp_set_blocked_keys *keys = data;\n\tconst u16 max_key_count = ((U16_MAX - sizeof(*keys)) /\n\t\t\t\t   sizeof(struct mgmt_blocked_key_info));\n\tu16 key_count, expected_len;\n\tint i;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tkey_count = __le16_to_cpu(keys->key_count);\n\tif (key_count > max_key_count) {\n\t\tbt_dev_err(hdev, \"too big key_count value %u\", key_count);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\texpected_len = struct_size(keys, keys, key_count);\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\thci_dev_lock(hdev);\n\n\thci_blocked_keys_clear(hdev);\n\n\tfor (i = 0; i < key_count; ++i) {\n\t\tstruct blocked_key *b = kzalloc(sizeof(*b), GFP_KERNEL);\n\n\t\tif (!b) {\n\t\t\terr = MGMT_STATUS_NO_RESOURCES;\n\t\t\tbreak;\n\t\t}\n\n\t\tb->type = keys->keys[i].type;\n\t\tmemcpy(b->val, keys->keys[i].val, sizeof(b->val));\n\t\tlist_add_rcu(&b->list, &hdev->blocked_keys);\n\t}\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,\n\t\t\t\terr, NULL, 0);\n}\n\nstatic int set_wideband_speech(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tint err;\n\tbool changed = false;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!test_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks))\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_WIDEBAND_SPEECH,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_WIDEBAND_SPEECH,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (hdev_is_powered(hdev) &&\n\t    !!cp->val != hci_dev_test_flag(hdev,\n\t\t\t\t\t   HCI_WIDEBAND_SPEECH_ENABLED)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_SET_WIDEBAND_SPEECH,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto unlock;\n\t}\n\n\tif (cp->val)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev,\n\t\t\t\t\t\t   HCI_WIDEBAND_SPEECH_ENABLED);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t   HCI_WIDEBAND_SPEECH_ENABLED);\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_WIDEBAND_SPEECH, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (changed)\n\t\terr = new_settings(hdev, sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int read_controller_cap(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 data_len)\n{\n\tchar buf[20];\n\tstruct mgmt_rp_read_controller_cap *rp = (void *)buf;\n\tu16 cap_len = 0;\n\tu8 flags = 0;\n\tu8 tx_power_range[2];\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\thci_dev_lock(hdev);\n\n\t \n\tif ((hdev->commands[41] & 0x08) || msft_curve_validity(hdev))\n\t\tflags |= 0x01;\t \n\n\tflags |= 0x02;\t\t \n\n\t \n\tif (hdev->commands[20] & 0x10)\n\t\tflags |= 0x04;\t \n\n\tflags |= 0x08;\t\t \n\n\tcap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_SEC_FLAGS,\n\t\t\t\t  &flags, 1);\n\n\t \n\tif (hdev->commands[41] & 0x08)\n\t\tcap_len = eir_append_le16(rp->cap, cap_len,\n\t\t\t\t\t  MGMT_CAP_MAX_ENC_KEY_SIZE,\n\t\t\t\t\t  hdev->max_enc_key_size);\n\n\tcap_len = eir_append_le16(rp->cap, cap_len,\n\t\t\t\t  MGMT_CAP_SMP_MAX_ENC_KEY_SIZE,\n\t\t\t\t  SMP_MAX_ENC_KEY_SIZE);\n\n\t \n\tif (hdev->commands[38] & 0x80) {\n\t\tmemcpy(&tx_power_range[0], &hdev->min_le_tx_power, 1);\n\t\tmemcpy(&tx_power_range[1], &hdev->max_le_tx_power, 1);\n\t\tcap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_LE_TX_PWR,\n\t\t\t\t\t  tx_power_range, 2);\n\t}\n\n\trp->cap_len = cpu_to_le16(cap_len);\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_CONTROLLER_CAP, 0,\n\t\t\t\t rp, sizeof(*rp) + cap_len);\n}\n\n#ifdef CONFIG_BT_FEATURE_DEBUG\n \nstatic const u8 debug_uuid[16] = {\n\t0x1c, 0xda, 0x47, 0x1c, 0x48, 0x6c, 0x01, 0xab,\n\t0x9f, 0x46, 0xec, 0xb9, 0x30, 0x25, 0x99, 0xd4,\n};\n#endif\n\n \nstatic const u8 quality_report_uuid[16] = {\n\t0x7f, 0x03, 0x14, 0x06, 0x6f, 0x9a, 0x70, 0x93,\n\t0x2d, 0x49, 0x06, 0x75, 0xbc, 0x59, 0x08, 0x33,\n};\n\n \nstatic const u8 offload_codecs_uuid[16] = {\n\t0xaf, 0x29, 0xc6, 0x66, 0xac, 0x5f, 0x1a, 0x88,\n\t0xb9, 0x4f, 0x7f, 0xee, 0xce, 0x5a, 0x69, 0xa6,\n};\n\n \nstatic const u8 le_simultaneous_roles_uuid[16] = {\n\t0xd6, 0x49, 0xb0, 0xd1, 0x28, 0xeb, 0x27, 0x92,\n\t0x96, 0x46, 0xc0, 0x42, 0xb5, 0x10, 0x1b, 0x67,\n};\n\n \nstatic const u8 rpa_resolution_uuid[16] = {\n\t0x04, 0x00, 0x13, 0xac, 0x42, 0x02, 0xde, 0xb3,\n\t0xea, 0x11, 0x73, 0xc2, 0x48, 0xa1, 0xc0, 0x15,\n};\n\n \nstatic const u8 iso_socket_uuid[16] = {\n\t0x3e, 0xe0, 0xb4, 0xfd, 0xdd, 0xd6, 0x85, 0x98,\n\t0x6a, 0x49, 0xe0, 0x05, 0x88, 0xf1, 0xba, 0x6f,\n};\n\n \nstatic const u8 mgmt_mesh_uuid[16] = {\n\t0x76, 0x6e, 0xf3, 0xe8, 0x24, 0x5f, 0x05, 0xbf,\n\t0x8d, 0x4d, 0x03, 0x7a, 0xd7, 0x63, 0xe4, 0x2c,\n};\n\nstatic int read_exp_features_info(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  void *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_exp_features_info *rp;\n\tsize_t len;\n\tu16 idx = 0;\n\tu32 flags;\n\tint status;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\t \n\tlen = sizeof(*rp) + (sizeof(rp->features[0]) * 7);\n\trp = kzalloc(len, GFP_KERNEL);\n\tif (!rp)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_BT_FEATURE_DEBUG\n\tif (!hdev) {\n\t\tflags = bt_dbg_get() ? BIT(0) : 0;\n\n\t\tmemcpy(rp->features[idx].uuid, debug_uuid, 16);\n\t\trp->features[idx].flags = cpu_to_le32(flags);\n\t\tidx++;\n\t}\n#endif\n\n\tif (hdev && hci_dev_le_state_simultaneous(hdev)) {\n\t\tif (hci_dev_test_flag(hdev, HCI_LE_SIMULTANEOUS_ROLES))\n\t\t\tflags = BIT(0);\n\t\telse\n\t\t\tflags = 0;\n\n\t\tmemcpy(rp->features[idx].uuid, le_simultaneous_roles_uuid, 16);\n\t\trp->features[idx].flags = cpu_to_le32(flags);\n\t\tidx++;\n\t}\n\n\tif (hdev && ll_privacy_capable(hdev)) {\n\t\tif (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))\n\t\t\tflags = BIT(0) | BIT(1);\n\t\telse\n\t\t\tflags = BIT(1);\n\n\t\tmemcpy(rp->features[idx].uuid, rpa_resolution_uuid, 16);\n\t\trp->features[idx].flags = cpu_to_le32(flags);\n\t\tidx++;\n\t}\n\n\tif (hdev && (aosp_has_quality_report(hdev) ||\n\t\t     hdev->set_quality_report)) {\n\t\tif (hci_dev_test_flag(hdev, HCI_QUALITY_REPORT))\n\t\t\tflags = BIT(0);\n\t\telse\n\t\t\tflags = 0;\n\n\t\tmemcpy(rp->features[idx].uuid, quality_report_uuid, 16);\n\t\trp->features[idx].flags = cpu_to_le32(flags);\n\t\tidx++;\n\t}\n\n\tif (hdev && hdev->get_data_path_id) {\n\t\tif (hci_dev_test_flag(hdev, HCI_OFFLOAD_CODECS_ENABLED))\n\t\t\tflags = BIT(0);\n\t\telse\n\t\t\tflags = 0;\n\n\t\tmemcpy(rp->features[idx].uuid, offload_codecs_uuid, 16);\n\t\trp->features[idx].flags = cpu_to_le32(flags);\n\t\tidx++;\n\t}\n\n\tif (IS_ENABLED(CONFIG_BT_LE)) {\n\t\tflags = iso_enabled() ? BIT(0) : 0;\n\t\tmemcpy(rp->features[idx].uuid, iso_socket_uuid, 16);\n\t\trp->features[idx].flags = cpu_to_le32(flags);\n\t\tidx++;\n\t}\n\n\tif (hdev && lmp_le_capable(hdev)) {\n\t\tif (hci_dev_test_flag(hdev, HCI_MESH_EXPERIMENTAL))\n\t\t\tflags = BIT(0);\n\t\telse\n\t\t\tflags = 0;\n\n\t\tmemcpy(rp->features[idx].uuid, mgmt_mesh_uuid, 16);\n\t\trp->features[idx].flags = cpu_to_le32(flags);\n\t\tidx++;\n\t}\n\n\trp->feature_count = cpu_to_le16(idx);\n\n\t \n\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\tstatus = mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,\n\t\t\t\t   MGMT_OP_READ_EXP_FEATURES_INFO,\n\t\t\t\t   0, rp, sizeof(*rp) + (20 * idx));\n\n\tkfree(rp);\n\treturn status;\n}\n\nstatic int exp_ll_privacy_feature_changed(bool enabled, struct hci_dev *hdev,\n\t\t\t\t\t  struct sock *skip)\n{\n\tstruct mgmt_ev_exp_feature_changed ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tmemcpy(ev.uuid, rpa_resolution_uuid, 16);\n\tev.flags = cpu_to_le32((enabled ? BIT(0) : 0) | BIT(1));\n\n\t\n\tif (enabled && privacy_mode_capable(hdev))\n\t\thdev->conn_flags |= HCI_CONN_FLAG_DEVICE_PRIVACY;\n\telse\n\t\thdev->conn_flags &= ~HCI_CONN_FLAG_DEVICE_PRIVACY;\n\n\treturn mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, hdev,\n\t\t\t\t  &ev, sizeof(ev),\n\t\t\t\t  HCI_MGMT_EXP_FEATURE_EVENTS, skip);\n\n}\n\nstatic int exp_feature_changed(struct hci_dev *hdev, const u8 *uuid,\n\t\t\t       bool enabled, struct sock *skip)\n{\n\tstruct mgmt_ev_exp_feature_changed ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tmemcpy(ev.uuid, uuid, 16);\n\tev.flags = cpu_to_le32(enabled ? BIT(0) : 0);\n\n\treturn mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, hdev,\n\t\t\t\t  &ev, sizeof(ev),\n\t\t\t\t  HCI_MGMT_EXP_FEATURE_EVENTS, skip);\n}\n\n#define EXP_FEAT(_uuid, _set_func)\t\\\n{\t\t\t\t\t\\\n\t.uuid = _uuid,\t\t\t\\\n\t.set_func = _set_func,\t\t\\\n}\n\n \nstatic int set_zero_key_func(struct sock *sk, struct hci_dev *hdev,\n\t\t\t     struct mgmt_cp_set_exp_feature *cp, u16 data_len)\n{\n\tstruct mgmt_rp_set_exp_feature rp;\n\n\tmemset(rp.uuid, 0, 16);\n\trp.flags = cpu_to_le32(0);\n\n#ifdef CONFIG_BT_FEATURE_DEBUG\n\tif (!hdev) {\n\t\tbool changed = bt_dbg_get();\n\n\t\tbt_dbg_set(false);\n\n\t\tif (changed)\n\t\t\texp_feature_changed(NULL, ZERO_KEY, false, sk);\n\t}\n#endif\n\n\tif (hdev && use_ll_privacy(hdev) && !hdev_is_powered(hdev)) {\n\t\tbool changed;\n\n\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t      HCI_ENABLE_LL_PRIVACY);\n\t\tif (changed)\n\t\t\texp_feature_changed(hdev, rpa_resolution_uuid, false,\n\t\t\t\t\t    sk);\n\t}\n\n\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\treturn mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,\n\t\t\t\t MGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t &rp, sizeof(rp));\n}\n\n#ifdef CONFIG_BT_FEATURE_DEBUG\nstatic int set_debug_func(struct sock *sk, struct hci_dev *hdev,\n\t\t\t  struct mgmt_cp_set_exp_feature *cp, u16 data_len)\n{\n\tstruct mgmt_rp_set_exp_feature rp;\n\n\tbool val, changed;\n\tint err;\n\n\t \n\tif (hdev)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_INDEX);\n\n\t \n\tif (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)\n\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t \n\tif (cp->param[0] != 0x00 && cp->param[0] != 0x01)\n\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tval = !!cp->param[0];\n\tchanged = val ? !bt_dbg_get() : bt_dbg_get();\n\tbt_dbg_set(val);\n\n\tmemcpy(rp.uuid, debug_uuid, 16);\n\trp.flags = cpu_to_le32(val ? BIT(0) : 0);\n\n\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,\n\t\t\t\tMGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t&rp, sizeof(rp));\n\n\tif (changed)\n\t\texp_feature_changed(hdev, debug_uuid, val, sk);\n\n\treturn err;\n}\n#endif\n\nstatic int set_mgmt_mesh_func(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      struct mgmt_cp_set_exp_feature *cp, u16 data_len)\n{\n\tstruct mgmt_rp_set_exp_feature rp;\n\tbool val, changed;\n\tint err;\n\n\t \n\tif (!hdev)\n\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_INDEX);\n\n\t \n\tif (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t \n\tif (cp->param[0] != 0x00 && cp->param[0] != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tval = !!cp->param[0];\n\n\tif (val) {\n\t\tchanged = !hci_dev_test_and_set_flag(hdev,\n\t\t\t\t\t\t     HCI_MESH_EXPERIMENTAL);\n\t} else {\n\t\thci_dev_clear_flag(hdev, HCI_MESH);\n\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t      HCI_MESH_EXPERIMENTAL);\n\t}\n\n\tmemcpy(rp.uuid, mgmt_mesh_uuid, 16);\n\trp.flags = cpu_to_le32(val ? BIT(0) : 0);\n\n\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\tMGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t&rp, sizeof(rp));\n\n\tif (changed)\n\t\texp_feature_changed(hdev, mgmt_mesh_uuid, val, sk);\n\n\treturn err;\n}\n\nstatic int set_rpa_resolution_func(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   struct mgmt_cp_set_exp_feature *cp,\n\t\t\t\t   u16 data_len)\n{\n\tstruct mgmt_rp_set_exp_feature rp;\n\tbool val, changed;\n\tint err;\n\tu32 flags;\n\n\t \n\tif (!hdev)\n\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_INDEX);\n\n\t \n\tif (hdev_is_powered(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\t \n\tif (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t \n\tif (cp->param[0] != 0x00 && cp->param[0] != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tval = !!cp->param[0];\n\n\tif (val) {\n\t\tchanged = !hci_dev_test_and_set_flag(hdev,\n\t\t\t\t\t\t     HCI_ENABLE_LL_PRIVACY);\n\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING);\n\n\t\t \n\t\tflags = BIT(0) | BIT(1);\n\t} else {\n\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t      HCI_ENABLE_LL_PRIVACY);\n\n\t\t \n\t\tflags = BIT(1);\n\t}\n\n\tmemcpy(rp.uuid, rpa_resolution_uuid, 16);\n\trp.flags = cpu_to_le32(flags);\n\n\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\tMGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t&rp, sizeof(rp));\n\n\tif (changed)\n\t\texp_ll_privacy_feature_changed(val, hdev, sk);\n\n\treturn err;\n}\n\nstatic int set_quality_report_func(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   struct mgmt_cp_set_exp_feature *cp,\n\t\t\t\t   u16 data_len)\n{\n\tstruct mgmt_rp_set_exp_feature rp;\n\tbool val, changed;\n\tint err;\n\n\t \n\tif (!hdev)\n\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_INDEX);\n\n\t \n\tif (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t \n\tif (cp->param[0] != 0x00 && cp->param[0] != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_req_sync_lock(hdev);\n\n\tval = !!cp->param[0];\n\tchanged = (val != hci_dev_test_flag(hdev, HCI_QUALITY_REPORT));\n\n\tif (!aosp_has_quality_report(hdev) && !hdev->set_quality_report) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t      MGMT_STATUS_NOT_SUPPORTED);\n\t\tgoto unlock_quality_report;\n\t}\n\n\tif (changed) {\n\t\tif (hdev->set_quality_report)\n\t\t\terr = hdev->set_quality_report(hdev, val);\n\t\telse\n\t\t\terr = aosp_set_quality_report(hdev, val);\n\n\t\tif (err) {\n\t\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t      MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t\t      MGMT_STATUS_FAILED);\n\t\t\tgoto unlock_quality_report;\n\t\t}\n\n\t\tif (val)\n\t\t\thci_dev_set_flag(hdev, HCI_QUALITY_REPORT);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_QUALITY_REPORT);\n\t}\n\n\tbt_dev_dbg(hdev, \"quality report enable %d changed %d\", val, changed);\n\n\tmemcpy(rp.uuid, quality_report_uuid, 16);\n\trp.flags = cpu_to_le32(val ? BIT(0) : 0);\n\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t&rp, sizeof(rp));\n\n\tif (changed)\n\t\texp_feature_changed(hdev, quality_report_uuid, val, sk);\n\nunlock_quality_report:\n\thci_req_sync_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_offload_codec_func(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  struct mgmt_cp_set_exp_feature *cp,\n\t\t\t\t  u16 data_len)\n{\n\tbool val, changed;\n\tint err;\n\tstruct mgmt_rp_set_exp_feature rp;\n\n\t \n\tif (!hdev)\n\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_INDEX);\n\n\t \n\tif (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t \n\tif (cp->param[0] != 0x00 && cp->param[0] != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tval = !!cp->param[0];\n\tchanged = (val != hci_dev_test_flag(hdev, HCI_OFFLOAD_CODECS_ENABLED));\n\n\tif (!hdev->get_data_path_id) {\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\t}\n\n\tif (changed) {\n\t\tif (val)\n\t\t\thci_dev_set_flag(hdev, HCI_OFFLOAD_CODECS_ENABLED);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_OFFLOAD_CODECS_ENABLED);\n\t}\n\n\tbt_dev_info(hdev, \"offload codecs enable %d changed %d\",\n\t\t    val, changed);\n\n\tmemcpy(rp.uuid, offload_codecs_uuid, 16);\n\trp.flags = cpu_to_le32(val ? BIT(0) : 0);\n\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\tMGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t&rp, sizeof(rp));\n\n\tif (changed)\n\t\texp_feature_changed(hdev, offload_codecs_uuid, val, sk);\n\n\treturn err;\n}\n\nstatic int set_le_simultaneous_roles_func(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t\t  struct mgmt_cp_set_exp_feature *cp,\n\t\t\t\t\t  u16 data_len)\n{\n\tbool val, changed;\n\tint err;\n\tstruct mgmt_rp_set_exp_feature rp;\n\n\t \n\tif (!hdev)\n\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_INDEX);\n\n\t \n\tif (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t \n\tif (cp->param[0] != 0x00 && cp->param[0] != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tval = !!cp->param[0];\n\tchanged = (val != hci_dev_test_flag(hdev, HCI_LE_SIMULTANEOUS_ROLES));\n\n\tif (!hci_dev_le_state_simultaneous(hdev)) {\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\t}\n\n\tif (changed) {\n\t\tif (val)\n\t\t\thci_dev_set_flag(hdev, HCI_LE_SIMULTANEOUS_ROLES);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_LE_SIMULTANEOUS_ROLES);\n\t}\n\n\tbt_dev_info(hdev, \"LE simultaneous roles enable %d changed %d\",\n\t\t    val, changed);\n\n\tmemcpy(rp.uuid, le_simultaneous_roles_uuid, 16);\n\trp.flags = cpu_to_le32(val ? BIT(0) : 0);\n\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\tMGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t&rp, sizeof(rp));\n\n\tif (changed)\n\t\texp_feature_changed(hdev, le_simultaneous_roles_uuid, val, sk);\n\n\treturn err;\n}\n\n#ifdef CONFIG_BT_LE\nstatic int set_iso_socket_func(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       struct mgmt_cp_set_exp_feature *cp, u16 data_len)\n{\n\tstruct mgmt_rp_set_exp_feature rp;\n\tbool val, changed = false;\n\tint err;\n\n\t \n\tif (hdev)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_INDEX);\n\n\t \n\tif (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)\n\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t \n\tif (cp->param[0] != 0x00 && cp->param[0] != 0x01)\n\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tval = cp->param[0] ? true : false;\n\tif (val)\n\t\terr = iso_init();\n\telse\n\t\terr = iso_exit();\n\n\tif (!err)\n\t\tchanged = true;\n\n\tmemcpy(rp.uuid, iso_socket_uuid, 16);\n\trp.flags = cpu_to_le32(val ? BIT(0) : 0);\n\n\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,\n\t\t\t\tMGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t&rp, sizeof(rp));\n\n\tif (changed)\n\t\texp_feature_changed(hdev, iso_socket_uuid, val, sk);\n\n\treturn err;\n}\n#endif\n\nstatic const struct mgmt_exp_feature {\n\tconst u8 *uuid;\n\tint (*set_func)(struct sock *sk, struct hci_dev *hdev,\n\t\t\tstruct mgmt_cp_set_exp_feature *cp, u16 data_len);\n} exp_features[] = {\n\tEXP_FEAT(ZERO_KEY, set_zero_key_func),\n#ifdef CONFIG_BT_FEATURE_DEBUG\n\tEXP_FEAT(debug_uuid, set_debug_func),\n#endif\n\tEXP_FEAT(mgmt_mesh_uuid, set_mgmt_mesh_func),\n\tEXP_FEAT(rpa_resolution_uuid, set_rpa_resolution_func),\n\tEXP_FEAT(quality_report_uuid, set_quality_report_func),\n\tEXP_FEAT(offload_codecs_uuid, set_offload_codec_func),\n\tEXP_FEAT(le_simultaneous_roles_uuid, set_le_simultaneous_roles_func),\n#ifdef CONFIG_BT_LE\n\tEXP_FEAT(iso_socket_uuid, set_iso_socket_func),\n#endif\n\n\t \n\tEXP_FEAT(NULL, NULL)\n};\n\nstatic int set_exp_feature(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   void *data, u16 data_len)\n{\n\tstruct mgmt_cp_set_exp_feature *cp = data;\n\tsize_t i = 0;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tfor (i = 0; exp_features[i].uuid; i++) {\n\t\tif (!memcmp(cp->uuid, exp_features[i].uuid, 16))\n\t\t\treturn exp_features[i].set_func(sk, hdev, cp, data_len);\n\t}\n\n\treturn mgmt_cmd_status(sk, hdev ? hdev->id : MGMT_INDEX_NONE,\n\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n}\n\nstatic u32 get_params_flags(struct hci_dev *hdev,\n\t\t\t    struct hci_conn_params *params)\n{\n\tu32 flags = hdev->conn_flags;\n\n\t \n\tif ((flags & HCI_CONN_FLAG_REMOTE_WAKEUP) && !use_ll_privacy(hdev) &&\n\t    hci_find_irk_by_addr(hdev, &params->addr, params->addr_type))\n\t\tflags &= ~HCI_CONN_FLAG_REMOTE_WAKEUP;\n\n\treturn flags;\n}\n\nstatic int get_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t    u16 data_len)\n{\n\tstruct mgmt_cp_get_device_flags *cp = data;\n\tstruct mgmt_rp_get_device_flags rp;\n\tstruct bdaddr_list_with_flags *br_params;\n\tstruct hci_conn_params *params;\n\tu32 supported_flags;\n\tu32 current_flags = 0;\n\tu8 status = MGMT_STATUS_INVALID_PARAMS;\n\n\tbt_dev_dbg(hdev, \"Get device flags %pMR (type 0x%x)\\n\",\n\t\t   &cp->addr.bdaddr, cp->addr.type);\n\n\thci_dev_lock(hdev);\n\n\tsupported_flags = hdev->conn_flags;\n\n\tmemset(&rp, 0, sizeof(rp));\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\tbr_params = hci_bdaddr_list_lookup_with_flags(&hdev->accept_list,\n\t\t\t\t\t\t\t      &cp->addr.bdaddr,\n\t\t\t\t\t\t\t      cp->addr.type);\n\t\tif (!br_params)\n\t\t\tgoto done;\n\n\t\tcurrent_flags = br_params->flags;\n\t} else {\n\t\tparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t\tle_addr_type(cp->addr.type));\n\t\tif (!params)\n\t\t\tgoto done;\n\n\t\tsupported_flags = get_params_flags(hdev, params);\n\t\tcurrent_flags = params->flags;\n\t}\n\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\trp.supported_flags = cpu_to_le32(supported_flags);\n\trp.current_flags = cpu_to_le32(current_flags);\n\n\tstatus = MGMT_STATUS_SUCCESS;\n\ndone:\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_DEVICE_FLAGS, status,\n\t\t\t\t&rp, sizeof(rp));\n}\n\nstatic void device_flags_changed(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t bdaddr_t *bdaddr, u8 bdaddr_type,\n\t\t\t\t u32 supported_flags, u32 current_flags)\n{\n\tstruct mgmt_ev_device_flags_changed ev;\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = bdaddr_type;\n\tev.supported_flags = cpu_to_le32(supported_flags);\n\tev.current_flags = cpu_to_le32(current_flags);\n\n\tmgmt_event(MGMT_EV_DEVICE_FLAGS_CHANGED, hdev, &ev, sizeof(ev), sk);\n}\n\nstatic int set_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t    u16 len)\n{\n\tstruct mgmt_cp_set_device_flags *cp = data;\n\tstruct bdaddr_list_with_flags *br_params;\n\tstruct hci_conn_params *params;\n\tu8 status = MGMT_STATUS_INVALID_PARAMS;\n\tu32 supported_flags;\n\tu32 current_flags = __le32_to_cpu(cp->current_flags);\n\n\tbt_dev_dbg(hdev, \"Set device flags %pMR (type 0x%x) = 0x%x\",\n\t\t   &cp->addr.bdaddr, cp->addr.type, current_flags);\n\n\t\n\tsupported_flags = hdev->conn_flags;\n\n\tif ((supported_flags | current_flags) != supported_flags) {\n\t\tbt_dev_warn(hdev, \"Bad flag given (0x%x) vs supported (0x%0x)\",\n\t\t\t    current_flags, supported_flags);\n\t\tgoto done;\n\t}\n\n\thci_dev_lock(hdev);\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\tbr_params = hci_bdaddr_list_lookup_with_flags(&hdev->accept_list,\n\t\t\t\t\t\t\t      &cp->addr.bdaddr,\n\t\t\t\t\t\t\t      cp->addr.type);\n\n\t\tif (br_params) {\n\t\t\tbr_params->flags = current_flags;\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\t\t} else {\n\t\t\tbt_dev_warn(hdev, \"No such BR/EDR device %pMR (0x%x)\",\n\t\t\t\t    &cp->addr.bdaddr, cp->addr.type);\n\t\t}\n\n\t\tgoto unlock;\n\t}\n\n\tparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,\n\t\t\t\t\tle_addr_type(cp->addr.type));\n\tif (!params) {\n\t\tbt_dev_warn(hdev, \"No such LE device %pMR (0x%x)\",\n\t\t\t    &cp->addr.bdaddr, le_addr_type(cp->addr.type));\n\t\tgoto unlock;\n\t}\n\n\tsupported_flags = get_params_flags(hdev, params);\n\n\tif ((supported_flags | current_flags) != supported_flags) {\n\t\tbt_dev_warn(hdev, \"Bad flag given (0x%x) vs supported (0x%0x)\",\n\t\t\t    current_flags, supported_flags);\n\t\tgoto unlock;\n\t}\n\n\tWRITE_ONCE(params->flags, current_flags);\n\tstatus = MGMT_STATUS_SUCCESS;\n\n\t \n\tif (params->flags & HCI_CONN_FLAG_DEVICE_PRIVACY)\n\t\thci_update_passive_scan(hdev);\n\nunlock:\n\thci_dev_unlock(hdev);\n\ndone:\n\tif (status == MGMT_STATUS_SUCCESS)\n\t\tdevice_flags_changed(sk, hdev, &cp->addr.bdaddr, cp->addr.type,\n\t\t\t\t     supported_flags, current_flags);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_FLAGS, status,\n\t\t\t\t &cp->addr, sizeof(cp->addr));\n}\n\nstatic void mgmt_adv_monitor_added(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   u16 handle)\n{\n\tstruct mgmt_ev_adv_monitor_added ev;\n\n\tev.monitor_handle = cpu_to_le16(handle);\n\n\tmgmt_event(MGMT_EV_ADV_MONITOR_ADDED, hdev, &ev, sizeof(ev), sk);\n}\n\nvoid mgmt_adv_monitor_removed(struct hci_dev *hdev, u16 handle)\n{\n\tstruct mgmt_ev_adv_monitor_removed ev;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct sock *sk_skip = NULL;\n\tstruct mgmt_cp_remove_adv_monitor *cp;\n\n\tcmd = pending_find(MGMT_OP_REMOVE_ADV_MONITOR, hdev);\n\tif (cmd) {\n\t\tcp = cmd->param;\n\n\t\tif (cp->monitor_handle)\n\t\t\tsk_skip = cmd->sk;\n\t}\n\n\tev.monitor_handle = cpu_to_le16(handle);\n\n\tmgmt_event(MGMT_EV_ADV_MONITOR_REMOVED, hdev, &ev, sizeof(ev), sk_skip);\n}\n\nstatic int read_adv_mon_features(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t void *data, u16 len)\n{\n\tstruct adv_monitor *monitor = NULL;\n\tstruct mgmt_rp_read_adv_monitor_features *rp = NULL;\n\tint handle, err;\n\tsize_t rp_size = 0;\n\t__u32 supported = 0;\n\t__u32 enabled = 0;\n\t__u16 num_handles = 0;\n\t__u16 handles[HCI_MAX_ADV_MONITOR_NUM_HANDLES];\n\n\tBT_DBG(\"request for %s\", hdev->name);\n\n\thci_dev_lock(hdev);\n\n\tif (msft_monitor_supported(hdev))\n\t\tsupported |= MGMT_ADV_MONITOR_FEATURE_MASK_OR_PATTERNS;\n\n\tidr_for_each_entry(&hdev->adv_monitors_idr, monitor, handle)\n\t\thandles[num_handles++] = monitor->handle;\n\n\thci_dev_unlock(hdev);\n\n\trp_size = sizeof(*rp) + (num_handles * sizeof(u16));\n\trp = kmalloc(rp_size, GFP_KERNEL);\n\tif (!rp)\n\t\treturn -ENOMEM;\n\n\t \n\tenabled = supported;\n\n\trp->supported_features = cpu_to_le32(supported);\n\trp->enabled_features = cpu_to_le32(enabled);\n\trp->max_num_handles = cpu_to_le16(HCI_MAX_ADV_MONITOR_NUM_HANDLES);\n\trp->max_num_patterns = HCI_MAX_ADV_MONITOR_NUM_PATTERNS;\n\trp->num_handles = cpu_to_le16(num_handles);\n\tif (num_handles)\n\t\tmemcpy(&rp->handles, &handles, (num_handles * sizeof(u16)));\n\n\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\tMGMT_OP_READ_ADV_MONITOR_FEATURES,\n\t\t\t\tMGMT_STATUS_SUCCESS, rp, rp_size);\n\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic void mgmt_add_adv_patterns_monitor_complete(struct hci_dev *hdev,\n\t\t\t\t\t\t   void *data, int status)\n{\n\tstruct mgmt_rp_add_adv_patterns_monitor rp;\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct adv_monitor *monitor = cmd->user_data;\n\n\thci_dev_lock(hdev);\n\n\trp.monitor_handle = cpu_to_le16(monitor->handle);\n\n\tif (!status) {\n\t\tmgmt_adv_monitor_added(cmd->sk, hdev, monitor->handle);\n\t\thdev->adv_monitors_cnt++;\n\t\tif (monitor->state == ADV_MONITOR_STATE_NOT_REGISTERED)\n\t\t\tmonitor->state = ADV_MONITOR_STATE_REGISTERED;\n\t\thci_update_passive_scan(hdev);\n\t}\n\n\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t  mgmt_status(status), &rp, sizeof(rp));\n\tmgmt_pending_remove(cmd);\n\n\thci_dev_unlock(hdev);\n\tbt_dev_dbg(hdev, \"add monitor %d complete, status %d\",\n\t\t   rp.monitor_handle, status);\n}\n\nstatic int mgmt_add_adv_patterns_monitor_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct adv_monitor *monitor = cmd->user_data;\n\n\treturn hci_add_adv_monitor(hdev, monitor);\n}\n\nstatic int __add_adv_patterns_monitor(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t      struct adv_monitor *m, u8 status,\n\t\t\t\t      void *data, u16 len, u16 op)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\thci_dev_lock(hdev);\n\n\tif (status)\n\t\tgoto unlock;\n\n\tif (pending_find(MGMT_OP_SET_LE, hdev) ||\n\t    pending_find(MGMT_OP_ADD_ADV_PATTERNS_MONITOR, hdev) ||\n\t    pending_find(MGMT_OP_ADD_ADV_PATTERNS_MONITOR_RSSI, hdev) ||\n\t    pending_find(MGMT_OP_REMOVE_ADV_MONITOR, hdev)) {\n\t\tstatus = MGMT_STATUS_BUSY;\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, op, hdev, data, len);\n\tif (!cmd) {\n\t\tstatus = MGMT_STATUS_NO_RESOURCES;\n\t\tgoto unlock;\n\t}\n\n\tcmd->user_data = m;\n\terr = hci_cmd_sync_queue(hdev, mgmt_add_adv_patterns_monitor_sync, cmd,\n\t\t\t\t mgmt_add_adv_patterns_monitor_complete);\n\tif (err) {\n\t\tif (err == -ENOMEM)\n\t\t\tstatus = MGMT_STATUS_NO_RESOURCES;\n\t\telse\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\n\t\tgoto unlock;\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n\nunlock:\n\thci_free_adv_monitor(hdev, m);\n\thci_dev_unlock(hdev);\n\treturn mgmt_cmd_status(sk, hdev->id, op, status);\n}\n\nstatic void parse_adv_monitor_rssi(struct adv_monitor *m,\n\t\t\t\t   struct mgmt_adv_rssi_thresholds *rssi)\n{\n\tif (rssi) {\n\t\tm->rssi.low_threshold = rssi->low_threshold;\n\t\tm->rssi.low_threshold_timeout =\n\t\t    __le16_to_cpu(rssi->low_threshold_timeout);\n\t\tm->rssi.high_threshold = rssi->high_threshold;\n\t\tm->rssi.high_threshold_timeout =\n\t\t    __le16_to_cpu(rssi->high_threshold_timeout);\n\t\tm->rssi.sampling_period = rssi->sampling_period;\n\t} else {\n\t\t \n\t\tm->rssi.low_threshold = -127;\n\t\tm->rssi.low_threshold_timeout = 60;\n\t\tm->rssi.high_threshold = -127;\n\t\tm->rssi.high_threshold_timeout = 0;\n\t\tm->rssi.sampling_period = 0;\n\t}\n}\n\nstatic u8 parse_adv_monitor_pattern(struct adv_monitor *m, u8 pattern_count,\n\t\t\t\t    struct mgmt_adv_pattern *patterns)\n{\n\tu8 offset = 0, length = 0;\n\tstruct adv_pattern *p = NULL;\n\tint i;\n\n\tfor (i = 0; i < pattern_count; i++) {\n\t\toffset = patterns[i].offset;\n\t\tlength = patterns[i].length;\n\t\tif (offset >= HCI_MAX_EXT_AD_LENGTH ||\n\t\t    length > HCI_MAX_EXT_AD_LENGTH ||\n\t\t    (offset + length) > HCI_MAX_EXT_AD_LENGTH)\n\t\t\treturn MGMT_STATUS_INVALID_PARAMS;\n\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn MGMT_STATUS_NO_RESOURCES;\n\n\t\tp->ad_type = patterns[i].ad_type;\n\t\tp->offset = patterns[i].offset;\n\t\tp->length = patterns[i].length;\n\t\tmemcpy(p->value, patterns[i].value, p->length);\n\n\t\tINIT_LIST_HEAD(&p->list);\n\t\tlist_add(&p->list, &m->patterns);\n\t}\n\n\treturn MGMT_STATUS_SUCCESS;\n}\n\nstatic int add_adv_patterns_monitor(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t    void *data, u16 len)\n{\n\tstruct mgmt_cp_add_adv_patterns_monitor *cp = data;\n\tstruct adv_monitor *m = NULL;\n\tu8 status = MGMT_STATUS_SUCCESS;\n\tsize_t expected_size = sizeof(*cp);\n\n\tBT_DBG(\"request for %s\", hdev->name);\n\n\tif (len <= sizeof(*cp)) {\n\t\tstatus = MGMT_STATUS_INVALID_PARAMS;\n\t\tgoto done;\n\t}\n\n\texpected_size += cp->pattern_count * sizeof(struct mgmt_adv_pattern);\n\tif (len != expected_size) {\n\t\tstatus = MGMT_STATUS_INVALID_PARAMS;\n\t\tgoto done;\n\t}\n\n\tm = kzalloc(sizeof(*m), GFP_KERNEL);\n\tif (!m) {\n\t\tstatus = MGMT_STATUS_NO_RESOURCES;\n\t\tgoto done;\n\t}\n\n\tINIT_LIST_HEAD(&m->patterns);\n\n\tparse_adv_monitor_rssi(m, NULL);\n\tstatus = parse_adv_monitor_pattern(m, cp->pattern_count, cp->patterns);\n\ndone:\n\treturn __add_adv_patterns_monitor(sk, hdev, m, status, data, len,\n\t\t\t\t\t  MGMT_OP_ADD_ADV_PATTERNS_MONITOR);\n}\n\nstatic int add_adv_patterns_monitor_rssi(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t\t void *data, u16 len)\n{\n\tstruct mgmt_cp_add_adv_patterns_monitor_rssi *cp = data;\n\tstruct adv_monitor *m = NULL;\n\tu8 status = MGMT_STATUS_SUCCESS;\n\tsize_t expected_size = sizeof(*cp);\n\n\tBT_DBG(\"request for %s\", hdev->name);\n\n\tif (len <= sizeof(*cp)) {\n\t\tstatus = MGMT_STATUS_INVALID_PARAMS;\n\t\tgoto done;\n\t}\n\n\texpected_size += cp->pattern_count * sizeof(struct mgmt_adv_pattern);\n\tif (len != expected_size) {\n\t\tstatus = MGMT_STATUS_INVALID_PARAMS;\n\t\tgoto done;\n\t}\n\n\tm = kzalloc(sizeof(*m), GFP_KERNEL);\n\tif (!m) {\n\t\tstatus = MGMT_STATUS_NO_RESOURCES;\n\t\tgoto done;\n\t}\n\n\tINIT_LIST_HEAD(&m->patterns);\n\n\tparse_adv_monitor_rssi(m, &cp->rssi);\n\tstatus = parse_adv_monitor_pattern(m, cp->pattern_count, cp->patterns);\n\ndone:\n\treturn __add_adv_patterns_monitor(sk, hdev, m, status, data, len,\n\t\t\t\t\t MGMT_OP_ADD_ADV_PATTERNS_MONITOR_RSSI);\n}\n\nstatic void mgmt_remove_adv_monitor_complete(struct hci_dev *hdev,\n\t\t\t\t\t     void *data, int status)\n{\n\tstruct mgmt_rp_remove_adv_monitor rp;\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_remove_adv_monitor *cp = cmd->param;\n\n\thci_dev_lock(hdev);\n\n\trp.monitor_handle = cp->monitor_handle;\n\n\tif (!status)\n\t\thci_update_passive_scan(hdev);\n\n\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t  mgmt_status(status), &rp, sizeof(rp));\n\tmgmt_pending_remove(cmd);\n\n\thci_dev_unlock(hdev);\n\tbt_dev_dbg(hdev, \"remove monitor %d complete, status %d\",\n\t\t   rp.monitor_handle, status);\n}\n\nstatic int mgmt_remove_adv_monitor_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_remove_adv_monitor *cp = cmd->param;\n\tu16 handle = __le16_to_cpu(cp->monitor_handle);\n\n\tif (!handle)\n\t\treturn hci_remove_all_adv_monitor(hdev);\n\n\treturn hci_remove_single_adv_monitor(hdev, handle);\n}\n\nstatic int remove_adv_monitor(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 len)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tint err, status;\n\n\thci_dev_lock(hdev);\n\n\tif (pending_find(MGMT_OP_SET_LE, hdev) ||\n\t    pending_find(MGMT_OP_REMOVE_ADV_MONITOR, hdev) ||\n\t    pending_find(MGMT_OP_ADD_ADV_PATTERNS_MONITOR, hdev) ||\n\t    pending_find(MGMT_OP_ADD_ADV_PATTERNS_MONITOR_RSSI, hdev)) {\n\t\tstatus = MGMT_STATUS_BUSY;\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_ADV_MONITOR, hdev, data, len);\n\tif (!cmd) {\n\t\tstatus = MGMT_STATUS_NO_RESOURCES;\n\t\tgoto unlock;\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, mgmt_remove_adv_monitor_sync, cmd,\n\t\t\t\t mgmt_remove_adv_monitor_complete);\n\n\tif (err) {\n\t\tmgmt_pending_remove(cmd);\n\n\t\tif (err == -ENOMEM)\n\t\t\tstatus = MGMT_STATUS_NO_RESOURCES;\n\t\telse\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\n\t\tgoto unlock;\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADV_MONITOR,\n\t\t\t       status);\n}\n\nstatic void read_local_oob_data_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_rp_read_local_oob_data mgmt_rp;\n\tsize_t rp_size = sizeof(mgmt_rp);\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct sk_buff *skb = cmd->skb;\n\tu8 status = mgmt_status(err);\n\n\tif (!status) {\n\t\tif (!skb)\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\telse if (IS_ERR(skb))\n\t\t\tstatus = mgmt_status(PTR_ERR(skb));\n\t\telse\n\t\t\tstatus = mgmt_status(skb->data[0]);\n\t}\n\n\tbt_dev_dbg(hdev, \"status %d\", status);\n\n\tif (status) {\n\t\tmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA, status);\n\t\tgoto remove;\n\t}\n\n\tmemset(&mgmt_rp, 0, sizeof(mgmt_rp));\n\n\tif (!bredr_sc_enabled(hdev)) {\n\t\tstruct hci_rp_read_local_oob_data *rp = (void *) skb->data;\n\n\t\tif (skb->len < sizeof(*rp)) {\n\t\t\tmgmt_cmd_status(cmd->sk, hdev->id,\n\t\t\t\t\tMGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\t\tMGMT_STATUS_FAILED);\n\t\t\tgoto remove;\n\t\t}\n\n\t\tmemcpy(mgmt_rp.hash192, rp->hash, sizeof(rp->hash));\n\t\tmemcpy(mgmt_rp.rand192, rp->rand, sizeof(rp->rand));\n\n\t\trp_size -= sizeof(mgmt_rp.hash256) + sizeof(mgmt_rp.rand256);\n\t} else {\n\t\tstruct hci_rp_read_local_oob_ext_data *rp = (void *) skb->data;\n\n\t\tif (skb->len < sizeof(*rp)) {\n\t\t\tmgmt_cmd_status(cmd->sk, hdev->id,\n\t\t\t\t\tMGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\t\tMGMT_STATUS_FAILED);\n\t\t\tgoto remove;\n\t\t}\n\n\t\tmemcpy(mgmt_rp.hash192, rp->hash192, sizeof(rp->hash192));\n\t\tmemcpy(mgmt_rp.rand192, rp->rand192, sizeof(rp->rand192));\n\n\t\tmemcpy(mgmt_rp.hash256, rp->hash256, sizeof(rp->hash256));\n\t\tmemcpy(mgmt_rp.rand256, rp->rand256, sizeof(rp->rand256));\n\t}\n\n\tmgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t  MGMT_STATUS_SUCCESS, &mgmt_rp, rp_size);\n\nremove:\n\tif (skb && !IS_ERR(skb))\n\t\tkfree_skb(skb);\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic int read_local_oob_data_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\n\tif (bredr_sc_enabled(hdev))\n\t\tcmd->skb = hci_read_local_oob_data_sync(hdev, true, cmd->sk);\n\telse\n\t\tcmd->skb = hci_read_local_oob_data_sync(hdev, false, cmd->sk);\n\n\tif (IS_ERR(cmd->skb))\n\t\treturn PTR_ERR(cmd->skb);\n\telse\n\t\treturn 0;\n}\n\nstatic int read_local_oob_data(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 data_len)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\t      MGMT_STATUS_NOT_POWERED);\n\t\tgoto unlock;\n\t}\n\n\tif (!lmp_ssp_capable(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\t      MGMT_STATUS_NOT_SUPPORTED);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_new(sk, MGMT_OP_READ_LOCAL_OOB_DATA, hdev, NULL, 0);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, read_local_oob_data_sync, cmd,\n\t\t\t\t\t read_local_oob_data_complete);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\n\t\tif (cmd)\n\t\t\tmgmt_pending_free(cmd);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int add_remote_oob_data(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 len)\n{\n\tstruct mgmt_addr_info *addr = data;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!bdaddr_type_is_valid(addr->type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t MGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t addr, sizeof(*addr));\n\n\thci_dev_lock(hdev);\n\n\tif (len == MGMT_ADD_REMOTE_OOB_DATA_SIZE) {\n\t\tstruct mgmt_cp_add_remote_oob_data *cp = data;\n\t\tu8 status;\n\n\t\tif (cp->addr.type != BDADDR_BREDR) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t      cp->addr.type, cp->hash,\n\t\t\t\t\t      cp->rand, NULL, NULL);\n\t\tif (err < 0)\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\telse\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_ADD_REMOTE_OOB_DATA, status,\n\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t} else if (len == MGMT_ADD_REMOTE_OOB_EXT_DATA_SIZE) {\n\t\tstruct mgmt_cp_add_remote_oob_ext_data *cp = data;\n\t\tu8 *rand192, *hash192, *rand256, *hash256;\n\t\tu8 status;\n\n\t\tif (bdaddr_type_is_le(cp->addr.type)) {\n\t\t\t \n\t\t\tif (memcmp(cp->rand192, ZERO_KEY, 16) ||\n\t\t\t    memcmp(cp->hash192, ZERO_KEY, 16)) {\n\t\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\t\tMGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t\taddr, sizeof(*addr));\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\trand192 = NULL;\n\t\t\thash192 = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tif (!memcmp(cp->rand192, ZERO_KEY, 16) ||\n\t\t\t    !memcmp(cp->hash192, ZERO_KEY, 16)) {\n\t\t\t\trand192 = NULL;\n\t\t\t\thash192 = NULL;\n\t\t\t} else {\n\t\t\t\trand192 = cp->rand192;\n\t\t\t\thash192 = cp->hash192;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!memcmp(cp->rand256, ZERO_KEY, 16) ||\n\t\t    !memcmp(cp->hash256, ZERO_KEY, 16)) {\n\t\t\trand256 = NULL;\n\t\t\thash256 = NULL;\n\t\t} else {\n\t\t\trand256 = cp->rand256;\n\t\t\thash256 = cp->hash256;\n\t\t}\n\n\t\terr = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t      cp->addr.type, hash192, rand192,\n\t\t\t\t\t      hash256, rand256);\n\t\tif (err < 0)\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\telse\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\t\tstatus, &cp->addr, sizeof(cp->addr));\n\t} else {\n\t\tbt_dev_err(hdev, \"add_remote_oob_data: invalid len of %u bytes\",\n\t\t\t   len);\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int remove_remote_oob_data(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  void *data, u16 len)\n{\n\tstruct mgmt_cp_remove_remote_oob_data *cp = data;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (cp->addr.type != BDADDR_BREDR)\n\t\treturn mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t MGMT_OP_REMOVE_REMOTE_OOB_DATA,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &cp->addr, sizeof(cp->addr));\n\n\thci_dev_lock(hdev);\n\n\tif (!bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {\n\t\thci_remote_oob_data_clear(hdev);\n\t\tstatus = MGMT_STATUS_SUCCESS;\n\t\tgoto done;\n\t}\n\n\terr = hci_remove_remote_oob_data(hdev, &cp->addr.bdaddr, cp->addr.type);\n\tif (err < 0)\n\t\tstatus = MGMT_STATUS_INVALID_PARAMS;\n\telse\n\t\tstatus = MGMT_STATUS_SUCCESS;\n\ndone:\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_REMOTE_OOB_DATA,\n\t\t\t\tstatus, &cp->addr, sizeof(cp->addr));\n\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nvoid mgmt_start_discovery_complete(struct hci_dev *hdev, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status %u\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_START_DISCOVERY, hdev);\n\tif (!cmd)\n\t\tcmd = pending_find(MGMT_OP_START_SERVICE_DISCOVERY, hdev);\n\n\tif (!cmd)\n\t\tcmd = pending_find(MGMT_OP_START_LIMITED_DISCOVERY, hdev);\n\n\tif (cmd) {\n\t\tcmd->cmd_complete(cmd, mgmt_status(status));\n\t\tmgmt_pending_remove(cmd);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic bool discovery_type_is_valid(struct hci_dev *hdev, uint8_t type,\n\t\t\t\t    uint8_t *mgmt_status)\n{\n\tswitch (type) {\n\tcase DISCOV_TYPE_LE:\n\t\t*mgmt_status = mgmt_le_support(hdev);\n\t\tif (*mgmt_status)\n\t\t\treturn false;\n\t\tbreak;\n\tcase DISCOV_TYPE_INTERLEAVED:\n\t\t*mgmt_status = mgmt_le_support(hdev);\n\t\tif (*mgmt_status)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase DISCOV_TYPE_BREDR:\n\t\t*mgmt_status = mgmt_bredr_support(hdev);\n\t\tif (*mgmt_status)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\t*mgmt_status = MGMT_STATUS_INVALID_PARAMS;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void start_discovery_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\n\tif (cmd != pending_find(MGMT_OP_START_DISCOVERY, hdev) &&\n\t    cmd != pending_find(MGMT_OP_START_LIMITED_DISCOVERY, hdev) &&\n\t    cmd != pending_find(MGMT_OP_START_SERVICE_DISCOVERY, hdev))\n\t\treturn;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, mgmt_status(err),\n\t\t\t  cmd->param, 1);\n\tmgmt_pending_remove(cmd);\n\n\thci_discovery_set_state(hdev, err ? DISCOVERY_STOPPED:\n\t\t\t\tDISCOVERY_FINDING);\n}\n\nstatic int start_discovery_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_start_discovery_sync(hdev);\n}\n\nstatic int start_discovery_internal(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t    u16 op, void *data, u16 len)\n{\n\tstruct mgmt_cp_start_discovery *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, op,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED,\n\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tif (hdev->discovery.state != DISCOVERY_STOPPED ||\n\t    hci_dev_test_flag(hdev, HCI_PERIODIC_INQ)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, op, MGMT_STATUS_BUSY,\n\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tif (!discovery_type_is_valid(hdev, cp->type, &status)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, op, status,\n\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\t \n\tif (hdev->discovery_paused) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, op, MGMT_STATUS_BUSY,\n\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\t \n\thci_discovery_filter_clear(hdev);\n\n\thdev->discovery.type = cp->type;\n\thdev->discovery.report_invalid_rssi = false;\n\tif (op == MGMT_OP_START_LIMITED_DISCOVERY)\n\t\thdev->discovery.limited = true;\n\telse\n\t\thdev->discovery.limited = false;\n\n\tcmd = mgmt_pending_add(sk, op, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, start_discovery_sync, cmd,\n\t\t\t\t start_discovery_complete);\n\tif (err < 0) {\n\t\tmgmt_pending_remove(cmd);\n\t\tgoto failed;\n\t}\n\n\thci_discovery_set_state(hdev, DISCOVERY_STARTING);\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int start_discovery(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   void *data, u16 len)\n{\n\treturn start_discovery_internal(sk, hdev, MGMT_OP_START_DISCOVERY,\n\t\t\t\t\tdata, len);\n}\n\nstatic int start_limited_discovery(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   void *data, u16 len)\n{\n\treturn start_discovery_internal(sk, hdev,\n\t\t\t\t\tMGMT_OP_START_LIMITED_DISCOVERY,\n\t\t\t\t\tdata, len);\n}\n\nstatic int start_service_discovery(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   void *data, u16 len)\n{\n\tstruct mgmt_cp_start_service_discovery *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tconst u16 max_uuid_count = ((U16_MAX - sizeof(*cp)) / 16);\n\tu16 uuid_count, expected_len;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED,\n\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tif (hdev->discovery.state != DISCOVERY_STOPPED ||\n\t    hci_dev_test_flag(hdev, HCI_PERIODIC_INQ)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_BUSY, &cp->type,\n\t\t\t\t\tsizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tif (hdev->discovery_paused) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_BUSY, &cp->type,\n\t\t\t\t\tsizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tuuid_count = __le16_to_cpu(cp->uuid_count);\n\tif (uuid_count > max_uuid_count) {\n\t\tbt_dev_err(hdev, \"service_discovery: too big uuid_count value %u\",\n\t\t\t   uuid_count);\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS, &cp->type,\n\t\t\t\t\tsizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\texpected_len = sizeof(*cp) + uuid_count * 16;\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"service_discovery: expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS, &cp->type,\n\t\t\t\t\tsizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tif (!discovery_type_is_valid(hdev, cp->type, &status)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tstatus, &cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t       hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\t \n\thci_discovery_filter_clear(hdev);\n\n\thdev->discovery.result_filtering = true;\n\thdev->discovery.type = cp->type;\n\thdev->discovery.rssi = cp->rssi;\n\thdev->discovery.uuid_count = uuid_count;\n\n\tif (uuid_count > 0) {\n\t\thdev->discovery.uuids = kmemdup(cp->uuids, uuid_count * 16,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!hdev->discovery.uuids) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\t\tMGMT_STATUS_FAILED,\n\t\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\t\tmgmt_pending_remove(cmd);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, start_discovery_sync, cmd,\n\t\t\t\t start_discovery_complete);\n\tif (err < 0) {\n\t\tmgmt_pending_remove(cmd);\n\t\tgoto failed;\n\t}\n\n\thci_discovery_set_state(hdev, DISCOVERY_STARTING);\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nvoid mgmt_stop_discovery_complete(struct hci_dev *hdev, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status %u\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_STOP_DISCOVERY, hdev);\n\tif (cmd) {\n\t\tcmd->cmd_complete(cmd, mgmt_status(status));\n\t\tmgmt_pending_remove(cmd);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void stop_discovery_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\n\tif (cmd != pending_find(MGMT_OP_STOP_DISCOVERY, hdev))\n\t\treturn;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, mgmt_status(err),\n\t\t\t  cmd->param, 1);\n\tmgmt_pending_remove(cmd);\n\n\tif (!err)\n\t\thci_discovery_set_state(hdev, DISCOVERY_STOPPED);\n}\n\nstatic int stop_discovery_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_stop_discovery_sync(hdev);\n}\n\nstatic int stop_discovery(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct mgmt_cp_stop_discovery *mgmt_cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hci_discovery_active(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_REJECTED, &mgmt_cp->type,\n\t\t\t\t\tsizeof(mgmt_cp->type));\n\t\tgoto unlock;\n\t}\n\n\tif (hdev->discovery.type != mgmt_cp->type) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t&mgmt_cp->type, sizeof(mgmt_cp->type));\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_STOP_DISCOVERY, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, stop_discovery_sync, cmd,\n\t\t\t\t stop_discovery_complete);\n\tif (err < 0) {\n\t\tmgmt_pending_remove(cmd);\n\t\tgoto unlock;\n\t}\n\n\thci_discovery_set_state(hdev, DISCOVERY_STOPPING);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int confirm_name(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\tu16 len)\n{\n\tstruct mgmt_cp_confirm_name *cp = data;\n\tstruct inquiry_entry *e;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hci_discovery_active(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CONFIRM_NAME,\n\t\t\t\t\tMGMT_STATUS_FAILED, &cp->addr,\n\t\t\t\t\tsizeof(cp->addr));\n\t\tgoto failed;\n\t}\n\n\te = hci_inquiry_cache_lookup_unknown(hdev, &cp->addr.bdaddr);\n\tif (!e) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CONFIRM_NAME,\n\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS, &cp->addr,\n\t\t\t\t\tsizeof(cp->addr));\n\t\tgoto failed;\n\t}\n\n\tif (cp->name_known) {\n\t\te->name_state = NAME_KNOWN;\n\t\tlist_del(&e->list);\n\t} else {\n\t\te->name_state = NAME_NEEDED;\n\t\thci_inquiry_cache_update_resolve(hdev, e);\n\t}\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CONFIRM_NAME, 0,\n\t\t\t\t&cp->addr, sizeof(cp->addr));\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int block_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\tu16 len)\n{\n\tstruct mgmt_cp_block_device *cp = data;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_BLOCK_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &cp->addr, sizeof(cp->addr));\n\n\thci_dev_lock(hdev);\n\n\terr = hci_bdaddr_list_add(&hdev->reject_list, &cp->addr.bdaddr,\n\t\t\t\t  cp->addr.type);\n\tif (err < 0) {\n\t\tstatus = MGMT_STATUS_FAILED;\n\t\tgoto done;\n\t}\n\n\tmgmt_event(MGMT_EV_DEVICE_BLOCKED, hdev, &cp->addr, sizeof(cp->addr),\n\t\t   sk);\n\tstatus = MGMT_STATUS_SUCCESS;\n\ndone:\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_BLOCK_DEVICE, status,\n\t\t\t\t&cp->addr, sizeof(cp->addr));\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int unblock_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct mgmt_cp_unblock_device *cp = data;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNBLOCK_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &cp->addr, sizeof(cp->addr));\n\n\thci_dev_lock(hdev);\n\n\terr = hci_bdaddr_list_del(&hdev->reject_list, &cp->addr.bdaddr,\n\t\t\t\t  cp->addr.type);\n\tif (err < 0) {\n\t\tstatus = MGMT_STATUS_INVALID_PARAMS;\n\t\tgoto done;\n\t}\n\n\tmgmt_event(MGMT_EV_DEVICE_UNBLOCKED, hdev, &cp->addr, sizeof(cp->addr),\n\t\t   sk);\n\tstatus = MGMT_STATUS_SUCCESS;\n\ndone:\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNBLOCK_DEVICE, status,\n\t\t\t\t&cp->addr, sizeof(cp->addr));\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int set_device_id_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_update_eir_sync(hdev);\n}\n\nstatic int set_device_id(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 len)\n{\n\tstruct mgmt_cp_set_device_id *cp = data;\n\tint err;\n\t__u16 source;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tsource = __le16_to_cpu(cp->source);\n\n\tif (source > 0x0002)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEVICE_ID,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\thdev->devid_source = source;\n\thdev->devid_vendor = __le16_to_cpu(cp->vendor);\n\thdev->devid_product = __le16_to_cpu(cp->product);\n\thdev->devid_version = __le16_to_cpu(cp->version);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_ID, 0,\n\t\t\t\tNULL, 0);\n\n\thci_cmd_sync_queue(hdev, set_device_id_sync, NULL, NULL);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void enable_advertising_instance(struct hci_dev *hdev, int err)\n{\n\tif (err)\n\t\tbt_dev_err(hdev, \"failed to re-configure advertising %d\", err);\n\telse\n\t\tbt_dev_dbg(hdev, \"status %d\", err);\n}\n\nstatic void set_advertising_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\tu8 instance;\n\tstruct adv_info *adv_instance;\n\tu8 status = mgmt_status(err);\n\n\tif (status) {\n\t\tmgmt_pending_foreach(MGMT_OP_SET_ADVERTISING, hdev,\n\t\t\t\t     cmd_status_rsp, &status);\n\t\treturn;\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\thci_dev_set_flag(hdev, HCI_ADVERTISING);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING);\n\n\tmgmt_pending_foreach(MGMT_OP_SET_ADVERTISING, hdev, settings_rsp,\n\t\t\t     &match);\n\n\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING) ||\n\t    list_empty(&hdev->adv_instances))\n\t\treturn;\n\n\tinstance = hdev->cur_adv_instance;\n\tif (!instance) {\n\t\tadv_instance = list_first_entry_or_null(&hdev->adv_instances,\n\t\t\t\t\t\t\tstruct adv_info, list);\n\t\tif (!adv_instance)\n\t\t\treturn;\n\n\t\tinstance = adv_instance->instance;\n\t}\n\n\terr = hci_schedule_adv_instance_sync(hdev, instance, true);\n\n\tenable_advertising_instance(hdev, err);\n}\n\nstatic int set_adv_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_mode *cp = cmd->param;\n\tu8 val = !!cp->val;\n\n\tif (cp->val == 0x02)\n\t\thci_dev_set_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\n\n\tcancel_adv_timeout(hdev);\n\n\tif (val) {\n\t\t \n\t\thdev->cur_adv_instance = 0x00;\n\n\t\tif (ext_adv_capable(hdev)) {\n\t\t\thci_start_ext_adv_sync(hdev, 0x00);\n\t\t} else {\n\t\t\thci_update_adv_data_sync(hdev, 0x00);\n\t\t\thci_update_scan_rsp_data_sync(hdev, 0x00);\n\t\t\thci_enable_advertising_sync(hdev);\n\t\t}\n\t} else {\n\t\thci_disable_advertising_sync(hdev);\n\t}\n\n\treturn 0;\n}\n\nstatic int set_advertising(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t   u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 val, status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tstatus = mgmt_le_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t       status);\n\n\tif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (hdev->advertising_paused)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_BUSY);\n\n\thci_dev_lock(hdev);\n\n\tval = !!cp->val;\n\n\t \n\tif (!hdev_is_powered(hdev) ||\n\t    (val == hci_dev_test_flag(hdev, HCI_ADVERTISING) &&\n\t     (cp->val == 0x02) == hci_dev_test_flag(hdev, HCI_ADVERTISING_CONNECTABLE)) ||\n\t    hci_dev_test_flag(hdev, HCI_MESH) ||\n\t    hci_conn_num(hdev, LE_LINK) > 0 ||\n\t    (hci_dev_test_flag(hdev, HCI_LE_SCAN) &&\n\t     hdev->le_scan_type == LE_SCAN_ACTIVE)) {\n\t\tbool changed;\n\n\t\tif (cp->val) {\n\t\t\thdev->cur_adv_instance = 0x00;\n\t\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_ADVERTISING);\n\t\t\tif (cp->val == 0x02)\n\t\t\t\thci_dev_set_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\n\t\t\telse\n\t\t\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\n\t\t} else {\n\t\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_ADVERTISING);\n\t\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_ADVERTISING, hdev);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto unlock;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_ADVERTISING, hdev) ||\n\t    pending_find(MGMT_OP_SET_LE, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_ADVERTISING, hdev, data, len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, set_adv_sync, cmd,\n\t\t\t\t\t set_advertising_complete);\n\n\tif (err < 0 && cmd)\n\t\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_static_address(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 len)\n{\n\tstruct mgmt_cp_set_static_address *cp = data;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_STATIC_ADDRESS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (hdev_is_powered(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_STATIC_ADDRESS,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (bacmp(&cp->bdaddr, BDADDR_ANY)) {\n\t\tif (!bacmp(&cp->bdaddr, BDADDR_NONE))\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_SET_STATIC_ADDRESS,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t\t \n\t\tif ((cp->bdaddr.b[5] & 0xc0) != 0xc0)\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_SET_STATIC_ADDRESS,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\thci_dev_lock(hdev);\n\n\tbacpy(&hdev->static_addr, &cp->bdaddr);\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_STATIC_ADDRESS, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\terr = new_settings(hdev, sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_scan_params(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   void *data, u16 len)\n{\n\tstruct mgmt_cp_set_scan_params *cp = data;\n\t__u16 interval, window;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tinterval = __le16_to_cpu(cp->interval);\n\n\tif (interval < 0x0004 || interval > 0x4000)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\twindow = __le16_to_cpu(cp->window);\n\n\tif (window < 0x0004 || window > 0x4000)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (window > interval)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\thdev->le_scan_interval = interval;\n\thdev->le_scan_window = window;\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS, 0,\n\t\t\t\tNULL, 0);\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_LE_SCAN) &&\n\t    hdev->discovery.state == DISCOVERY_STOPPED)\n\t\thci_update_passive_scan(hdev);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void fast_connectable_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tif (err) {\n\t\tmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t\tmgmt_status(err));\n\t} else {\n\t\tstruct mgmt_mode *cp = cmd->param;\n\n\t\tif (cp->val)\n\t\t\thci_dev_set_flag(hdev, HCI_FAST_CONNECTABLE);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_FAST_CONNECTABLE);\n\n\t\tsend_settings_rsp(cmd->sk, MGMT_OP_SET_FAST_CONNECTABLE, hdev);\n\t\tnew_settings(hdev, cmd->sk);\n\t}\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic int write_fast_connectable_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_mode *cp = cmd->param;\n\n\treturn hci_write_fast_connectable_sync(hdev, cp->val);\n}\n\nstatic int set_fast_connectable(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\tvoid *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) ||\n\t    hdev->hci_ver < BLUETOOTH_VER_1_2)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!!cp->val == hci_dev_test_flag(hdev, HCI_FAST_CONNECTABLE)) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_FAST_CONNECTABLE, hdev);\n\t\tgoto unlock;\n\t}\n\n\tif (!hdev_is_powered(hdev)) {\n\t\thci_dev_change_flag(hdev, HCI_FAST_CONNECTABLE);\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_FAST_CONNECTABLE, hdev);\n\t\tnew_settings(hdev, sk);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_new(sk, MGMT_OP_SET_FAST_CONNECTABLE, hdev, data,\n\t\t\t       len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, write_fast_connectable_sync, cmd,\n\t\t\t\t\t fast_connectable_complete);\n\n\tif (err < 0) {\n\t\tmgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t\tMGMT_STATUS_FAILED);\n\n\t\tif (cmd)\n\t\t\tmgmt_pending_free(cmd);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void set_bredr_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tif (err) {\n\t\tu8 mgmt_err = mgmt_status(err);\n\n\t\t \n\t\thci_dev_clear_flag(hdev, HCI_BREDR_ENABLED);\n\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);\n\t} else {\n\t\tsend_settings_rsp(cmd->sk, MGMT_OP_SET_BREDR, hdev);\n\t\tnew_settings(hdev, cmd->sk);\n\t}\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic int set_bredr_sync(struct hci_dev *hdev, void *data)\n{\n\tint status;\n\n\tstatus = hci_write_fast_connectable_sync(hdev, false);\n\n\tif (!status)\n\t\tstatus = hci_update_scan_sync(hdev);\n\n\t \n\tif (!status)\n\t\tstatus = hci_update_adv_data_sync(hdev, hdev->cur_adv_instance);\n\n\treturn status;\n}\n\nstatic int set_bredr(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_bredr_capable(hdev) || !lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->val == hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_BREDR, hdev);\n\t\tgoto unlock;\n\t}\n\n\tif (!hdev_is_powered(hdev)) {\n\t\tif (!cp->val) {\n\t\t\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\t\t\thci_dev_clear_flag(hdev, HCI_SSP_ENABLED);\n\t\t\thci_dev_clear_flag(hdev, HCI_LINK_SECURITY);\n\t\t\thci_dev_clear_flag(hdev, HCI_FAST_CONNECTABLE);\n\t\t\thci_dev_clear_flag(hdev, HCI_HS_ENABLED);\n\t\t}\n\n\t\thci_dev_change_flag(hdev, HCI_BREDR_ENABLED);\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_BREDR, hdev);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\terr = new_settings(hdev, sk);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (!cp->val) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto unlock;\n\t} else {\n\t\t \n\t\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\n\t\t    (bacmp(&hdev->static_addr, BDADDR_ANY) ||\n\t\t     hci_dev_test_flag(hdev, HCI_SC_ENABLED))) {\n\t\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tcmd = mgmt_pending_new(sk, MGMT_OP_SET_BREDR, hdev, data, len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, set_bredr_sync, cmd,\n\t\t\t\t\t set_bredr_complete);\n\n\tif (err < 0) {\n\t\tmgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\tMGMT_STATUS_FAILED);\n\t\tif (cmd)\n\t\t\tmgmt_pending_free(cmd);\n\n\t\tgoto unlock;\n\t}\n\n\t \n\thci_dev_set_flag(hdev, HCI_BREDR_ENABLED);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void set_secure_conn_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_mode *cp;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tif (err) {\n\t\tu8 mgmt_err = mgmt_status(err);\n\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);\n\t\tgoto done;\n\t}\n\n\tcp = cmd->param;\n\n\tswitch (cp->val) {\n\tcase 0x00:\n\t\thci_dev_clear_flag(hdev, HCI_SC_ENABLED);\n\t\thci_dev_clear_flag(hdev, HCI_SC_ONLY);\n\t\tbreak;\n\tcase 0x01:\n\t\thci_dev_set_flag(hdev, HCI_SC_ENABLED);\n\t\thci_dev_clear_flag(hdev, HCI_SC_ONLY);\n\t\tbreak;\n\tcase 0x02:\n\t\thci_dev_set_flag(hdev, HCI_SC_ENABLED);\n\t\thci_dev_set_flag(hdev, HCI_SC_ONLY);\n\t\tbreak;\n\t}\n\n\tsend_settings_rsp(cmd->sk, cmd->opcode, hdev);\n\tnew_settings(hdev, cmd->sk);\n\ndone:\n\tmgmt_pending_free(cmd);\n}\n\nstatic int set_secure_conn_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_mode *cp = cmd->param;\n\tu8 val = !!cp->val;\n\n\t \n\thci_dev_set_flag(hdev, HCI_SC_ENABLED);\n\n\treturn hci_write_sc_support_sync(hdev, val);\n}\n\nstatic int set_secure_conn(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 val;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_sc_capable(hdev) &&\n\t    !hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\n\t    lmp_sc_capable(hdev) &&\n\t    !hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev) || !lmp_sc_capable(hdev) ||\n\t    !hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\n\t\tbool changed;\n\n\t\tif (cp->val) {\n\t\t\tchanged = !hci_dev_test_and_set_flag(hdev,\n\t\t\t\t\t\t\t     HCI_SC_ENABLED);\n\t\t\tif (cp->val == 0x02)\n\t\t\t\thci_dev_set_flag(hdev, HCI_SC_ONLY);\n\t\t\telse\n\t\t\t\thci_dev_clear_flag(hdev, HCI_SC_ONLY);\n\t\t} else {\n\t\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t      HCI_SC_ENABLED);\n\t\t\thci_dev_clear_flag(hdev, HCI_SC_ONLY);\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_SECURE_CONN, hdev);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto failed;\n\t}\n\n\tval = !!cp->val;\n\n\tif (val == hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&\n\t    (cp->val == 0x02) == hci_dev_test_flag(hdev, HCI_SC_ONLY)) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_SECURE_CONN, hdev);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_new(sk, MGMT_OP_SET_SECURE_CONN, hdev, data, len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, set_secure_conn_sync, cmd,\n\t\t\t\t\t set_secure_conn_complete);\n\n\tif (err < 0) {\n\t\tmgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\n\t\t\t\tMGMT_STATUS_FAILED);\n\t\tif (cmd)\n\t\t\tmgmt_pending_free(cmd);\n\t}\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_debug_keys(struct sock *sk, struct hci_dev *hdev,\n\t\t\t  void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tbool changed, use_changed;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEBUG_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->val)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_KEEP_DEBUG_KEYS);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t      HCI_KEEP_DEBUG_KEYS);\n\n\tif (cp->val == 0x02)\n\t\tuse_changed = !hci_dev_test_and_set_flag(hdev,\n\t\t\t\t\t\t\t HCI_USE_DEBUG_KEYS);\n\telse\n\t\tuse_changed = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t  HCI_USE_DEBUG_KEYS);\n\n\tif (hdev_is_powered(hdev) && use_changed &&\n\t    hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\n\t\tu8 mode = (cp->val == 0x02) ? 0x01 : 0x00;\n\t\thci_send_cmd(hdev, HCI_OP_WRITE_SSP_DEBUG_MODE,\n\t\t\t     sizeof(mode), &mode);\n\t}\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_DEBUG_KEYS, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (changed)\n\t\terr = new_settings(hdev, sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_privacy(struct sock *sk, struct hci_dev *hdev, void *cp_data,\n\t\t       u16 len)\n{\n\tstruct mgmt_cp_set_privacy *cp = cp_data;\n\tbool changed;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PRIVACY,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->privacy != 0x00 && cp->privacy != 0x01 && cp->privacy != 0x02)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PRIVACY,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (hdev_is_powered(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PRIVACY,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\thci_dev_lock(hdev);\n\n\t \n\thci_dev_set_flag(hdev, HCI_RPA_RESOLVING);\n\n\tif (cp->privacy) {\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_PRIVACY);\n\t\tmemcpy(hdev->irk, cp->irk, sizeof(hdev->irk));\n\t\thci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\n\t\thci_adv_instances_set_rpa_expired(hdev, true);\n\t\tif (cp->privacy == 0x02)\n\t\t\thci_dev_set_flag(hdev, HCI_LIMITED_PRIVACY);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_LIMITED_PRIVACY);\n\t} else {\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_PRIVACY);\n\t\tmemset(hdev->irk, 0, sizeof(hdev->irk));\n\t\thci_dev_clear_flag(hdev, HCI_RPA_EXPIRED);\n\t\thci_adv_instances_set_rpa_expired(hdev, false);\n\t\thci_dev_clear_flag(hdev, HCI_LIMITED_PRIVACY);\n\t}\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_PRIVACY, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (changed)\n\t\terr = new_settings(hdev, sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic bool irk_is_valid(struct mgmt_irk_info *irk)\n{\n\tswitch (irk->addr.type) {\n\tcase BDADDR_LE_PUBLIC:\n\t\treturn true;\n\n\tcase BDADDR_LE_RANDOM:\n\t\t \n\t\tif ((irk->addr.bdaddr.b[5] & 0xc0) != 0xc0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int load_irks(struct sock *sk, struct hci_dev *hdev, void *cp_data,\n\t\t     u16 len)\n{\n\tstruct mgmt_cp_load_irks *cp = cp_data;\n\tconst u16 max_irk_count = ((U16_MAX - sizeof(*cp)) /\n\t\t\t\t   sizeof(struct mgmt_irk_info));\n\tu16 irk_count, expected_len;\n\tint i, err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_IRKS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tirk_count = __le16_to_cpu(cp->irk_count);\n\tif (irk_count > max_irk_count) {\n\t\tbt_dev_err(hdev, \"load_irks: too big irk_count value %u\",\n\t\t\t   irk_count);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_IRKS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\texpected_len = struct_size(cp, irks, irk_count);\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"load_irks: expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_IRKS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\tbt_dev_dbg(hdev, \"irk_count %u\", irk_count);\n\n\tfor (i = 0; i < irk_count; i++) {\n\t\tstruct mgmt_irk_info *key = &cp->irks[i];\n\n\t\tif (!irk_is_valid(key))\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_LOAD_IRKS,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\thci_dev_lock(hdev);\n\n\thci_smp_irks_clear(hdev);\n\n\tfor (i = 0; i < irk_count; i++) {\n\t\tstruct mgmt_irk_info *irk = &cp->irks[i];\n\t\tu8 addr_type = le_addr_type(irk->addr.type);\n\n\t\tif (hci_is_blocked_key(hdev,\n\t\t\t\t       HCI_BLOCKED_KEY_TYPE_IRK,\n\t\t\t\t       irk->val)) {\n\t\t\tbt_dev_warn(hdev, \"Skipping blocked IRK for %pMR\",\n\t\t\t\t    &irk->addr.bdaddr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (irk->addr.type == BDADDR_BREDR)\n\t\t\taddr_type = BDADDR_BREDR;\n\n\t\thci_add_irk(hdev, &irk->addr.bdaddr,\n\t\t\t    addr_type, irk->val,\n\t\t\t    BDADDR_ANY);\n\t}\n\n\thci_dev_set_flag(hdev, HCI_RPA_RESOLVING);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_IRKS, 0, NULL, 0);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic bool ltk_is_valid(struct mgmt_ltk_info *key)\n{\n\tif (key->initiator != 0x00 && key->initiator != 0x01)\n\t\treturn false;\n\n\tswitch (key->addr.type) {\n\tcase BDADDR_LE_PUBLIC:\n\t\treturn true;\n\n\tcase BDADDR_LE_RANDOM:\n\t\t \n\t\tif ((key->addr.bdaddr.b[5] & 0xc0) != 0xc0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int load_long_term_keys(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *cp_data, u16 len)\n{\n\tstruct mgmt_cp_load_long_term_keys *cp = cp_data;\n\tconst u16 max_key_count = ((U16_MAX - sizeof(*cp)) /\n\t\t\t\t   sizeof(struct mgmt_ltk_info));\n\tu16 key_count, expected_len;\n\tint i, err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tkey_count = __le16_to_cpu(cp->key_count);\n\tif (key_count > max_key_count) {\n\t\tbt_dev_err(hdev, \"load_ltks: too big key_count value %u\",\n\t\t\t   key_count);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\texpected_len = struct_size(cp, keys, key_count);\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"load_keys: expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\tbt_dev_dbg(hdev, \"key_count %u\", key_count);\n\n\tfor (i = 0; i < key_count; i++) {\n\t\tstruct mgmt_ltk_info *key = &cp->keys[i];\n\n\t\tif (!ltk_is_valid(key))\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_LOAD_LONG_TERM_KEYS,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\thci_dev_lock(hdev);\n\n\thci_smp_ltks_clear(hdev);\n\n\tfor (i = 0; i < key_count; i++) {\n\t\tstruct mgmt_ltk_info *key = &cp->keys[i];\n\t\tu8 type, authenticated;\n\t\tu8 addr_type = le_addr_type(key->addr.type);\n\n\t\tif (hci_is_blocked_key(hdev,\n\t\t\t\t       HCI_BLOCKED_KEY_TYPE_LTK,\n\t\t\t\t       key->val)) {\n\t\t\tbt_dev_warn(hdev, \"Skipping blocked LTK for %pMR\",\n\t\t\t\t    &key->addr.bdaddr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (key->type) {\n\t\tcase MGMT_LTK_UNAUTHENTICATED:\n\t\t\tauthenticated = 0x00;\n\t\t\ttype = key->initiator ? SMP_LTK : SMP_LTK_RESPONDER;\n\t\t\tbreak;\n\t\tcase MGMT_LTK_AUTHENTICATED:\n\t\t\tauthenticated = 0x01;\n\t\t\ttype = key->initiator ? SMP_LTK : SMP_LTK_RESPONDER;\n\t\t\tbreak;\n\t\tcase MGMT_LTK_P256_UNAUTH:\n\t\t\tauthenticated = 0x00;\n\t\t\ttype = SMP_LTK_P256;\n\t\t\tbreak;\n\t\tcase MGMT_LTK_P256_AUTH:\n\t\t\tauthenticated = 0x01;\n\t\t\ttype = SMP_LTK_P256;\n\t\t\tbreak;\n\t\tcase MGMT_LTK_P256_DEBUG:\n\t\t\tauthenticated = 0x00;\n\t\t\ttype = SMP_LTK_P256_DEBUG;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (key->addr.type == BDADDR_BREDR)\n\t\t\taddr_type = BDADDR_BREDR;\n\n\t\thci_add_ltk(hdev, &key->addr.bdaddr,\n\t\t\t    addr_type, type, authenticated,\n\t\t\t    key->val, key->enc_size, key->ediv, key->rand);\n\t}\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS, 0,\n\t\t\t   NULL, 0);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void get_conn_info_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct hci_conn *conn = cmd->user_data;\n\tstruct mgmt_cp_get_conn_info *cp = cmd->param;\n\tstruct mgmt_rp_get_conn_info rp;\n\tu8 status;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tmemcpy(&rp.addr, &cp->addr, sizeof(rp.addr));\n\n\tstatus = mgmt_status(err);\n\tif (status == MGMT_STATUS_SUCCESS) {\n\t\trp.rssi = conn->rssi;\n\t\trp.tx_power = conn->tx_power;\n\t\trp.max_tx_power = conn->max_tx_power;\n\t} else {\n\t\trp.rssi = HCI_RSSI_INVALID;\n\t\trp.tx_power = HCI_TX_POWER_INVALID;\n\t\trp.max_tx_power = HCI_TX_POWER_INVALID;\n\t}\n\n\tmgmt_cmd_complete(cmd->sk, cmd->index, MGMT_OP_GET_CONN_INFO, status,\n\t\t\t  &rp, sizeof(rp));\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic int get_conn_info_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_get_conn_info *cp = cmd->param;\n\tstruct hci_conn *conn;\n\tint err;\n\t__le16   handle;\n\n\t \n\tif (cp->addr.type == BDADDR_BREDR)\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\n\t\t\t\t\t       &cp->addr.bdaddr);\n\telse\n\t\tconn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->addr.bdaddr);\n\n\tif (!conn || conn->state != BT_CONNECTED)\n\t\treturn MGMT_STATUS_NOT_CONNECTED;\n\n\tcmd->user_data = conn;\n\thandle = cpu_to_le16(conn->handle);\n\n\t \n\terr = hci_read_rssi_sync(hdev, handle);\n\n\t \n\tif (!err && (!bdaddr_type_is_le(cp->addr.type) ||\n\t\t     conn->tx_power == HCI_TX_POWER_INVALID))\n\t\terr = hci_read_tx_power_sync(hdev, handle, 0x00);\n\n\t \n\tif (!err && conn->max_tx_power == HCI_TX_POWER_INVALID)\n\t\terr = hci_read_tx_power_sync(hdev, handle, 0x01);\n\n\treturn err;\n}\n\nstatic int get_conn_info(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 len)\n{\n\tstruct mgmt_cp_get_conn_info *cp = data;\n\tstruct mgmt_rp_get_conn_info rp;\n\tstruct hci_conn *conn;\n\tunsigned long conn_info_age;\n\tint err = 0;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (cp->addr.type == BDADDR_BREDR)\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\n\t\t\t\t\t       &cp->addr.bdaddr);\n\telse\n\t\tconn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->addr.bdaddr);\n\n\tif (!conn || conn->state != BT_CONNECTED) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\n\t\t\t\t\tMGMT_STATUS_NOT_CONNECTED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\t \n\tconn_info_age = get_random_u32_inclusive(hdev->conn_info_min_age,\n\t\t\t\t\t\t hdev->conn_info_max_age - 1);\n\n\t \n\tif (time_after(jiffies, conn->conn_info_timestamp +\n\t\t       msecs_to_jiffies(conn_info_age)) ||\n\t    !conn->conn_info_timestamp) {\n\t\tstruct mgmt_pending_cmd *cmd;\n\n\t\tcmd = mgmt_pending_new(sk, MGMT_OP_GET_CONN_INFO, hdev, data,\n\t\t\t\t       len);\n\t\tif (!cmd) {\n\t\t\terr = -ENOMEM;\n\t\t} else {\n\t\t\terr = hci_cmd_sync_queue(hdev, get_conn_info_sync,\n\t\t\t\t\t\t cmd, get_conn_info_complete);\n\t\t}\n\n\t\tif (err < 0) {\n\t\t\tmgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\n\t\t\t\t\t  MGMT_STATUS_FAILED, &rp, sizeof(rp));\n\n\t\t\tif (cmd)\n\t\t\t\tmgmt_pending_free(cmd);\n\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tconn->conn_info_timestamp = jiffies;\n\t} else {\n\t\t \n\t\trp.rssi = conn->rssi;\n\t\trp.tx_power = conn->tx_power;\n\t\trp.max_tx_power = conn->max_tx_power;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\n\t\t\t\t\tMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void get_clock_info_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_get_clock_info *cp = cmd->param;\n\tstruct mgmt_rp_get_clock_info rp;\n\tstruct hci_conn *conn = cmd->user_data;\n\tu8 status = mgmt_status(err);\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (err)\n\t\tgoto complete;\n\n\trp.local_clock = cpu_to_le32(hdev->clock);\n\n\tif (conn) {\n\t\trp.piconet_clock = cpu_to_le32(conn->clock);\n\t\trp.accuracy = cpu_to_le16(conn->clock_accuracy);\n\t}\n\ncomplete:\n\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status, &rp,\n\t\t\t  sizeof(rp));\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic int get_clock_info_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_get_clock_info *cp = cmd->param;\n\tstruct hci_cp_read_clock hci_cp;\n\tstruct hci_conn *conn;\n\n\tmemset(&hci_cp, 0, sizeof(hci_cp));\n\thci_read_clock_sync(hdev, &hci_cp);\n\n\t \n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->addr.bdaddr);\n\tif (!conn || conn->state != BT_CONNECTED)\n\t\treturn MGMT_STATUS_NOT_CONNECTED;\n\n\tcmd->user_data = conn;\n\thci_cp.handle = cpu_to_le16(conn->handle);\n\thci_cp.which = 0x01;  \n\n\treturn hci_read_clock_sync(hdev, &hci_cp);\n}\n\nstatic int get_clock_info(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t\t\t\t\t\tu16 len)\n{\n\tstruct mgmt_cp_get_clock_info *cp = data;\n\tstruct mgmt_rp_get_clock_info rp;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (cp->addr.type != BDADDR_BREDR)\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CLOCK_INFO,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CLOCK_INFO,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\n\t\t\t\t\t       &cp->addr.bdaddr);\n\t\tif (!conn || conn->state != BT_CONNECTED) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_GET_CLOCK_INFO,\n\t\t\t\t\t\tMGMT_STATUS_NOT_CONNECTED,\n\t\t\t\t\t\t&rp, sizeof(rp));\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tconn = NULL;\n\t}\n\n\tcmd = mgmt_pending_new(sk, MGMT_OP_GET_CLOCK_INFO, hdev, data, len);\n\tif (!cmd)\n\t\terr = -ENOMEM;\n\telse\n\t\terr = hci_cmd_sync_queue(hdev, get_clock_info_sync, cmd,\n\t\t\t\t\t get_clock_info_complete);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CLOCK_INFO,\n\t\t\t\t\tMGMT_STATUS_FAILED, &rp, sizeof(rp));\n\n\t\tif (cmd)\n\t\t\tmgmt_pending_free(cmd);\n\t}\n\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)\n{\n\tstruct hci_conn *conn;\n\n\tconn = hci_conn_hash_lookup_ba(hdev, LE_LINK, addr);\n\tif (!conn)\n\t\treturn false;\n\n\tif (conn->dst_type != type)\n\t\treturn false;\n\n\tif (conn->state != BT_CONNECTED)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr,\n\t\t\t       u8 addr_type, u8 auto_connect)\n{\n\tstruct hci_conn_params *params;\n\n\tparams = hci_conn_params_add(hdev, addr, addr_type);\n\tif (!params)\n\t\treturn -EIO;\n\n\tif (params->auto_connect == auto_connect)\n\t\treturn 0;\n\n\thci_pend_le_list_del_init(params);\n\n\tswitch (auto_connect) {\n\tcase HCI_AUTO_CONN_DISABLED:\n\tcase HCI_AUTO_CONN_LINK_LOSS:\n\t\t \n\t\tif (params->explicit_connect)\n\t\t\thci_pend_le_list_add(params, &hdev->pend_le_conns);\n\t\tbreak;\n\tcase HCI_AUTO_CONN_REPORT:\n\t\tif (params->explicit_connect)\n\t\t\thci_pend_le_list_add(params, &hdev->pend_le_conns);\n\t\telse\n\t\t\thci_pend_le_list_add(params, &hdev->pend_le_reports);\n\t\tbreak;\n\tcase HCI_AUTO_CONN_DIRECT:\n\tcase HCI_AUTO_CONN_ALWAYS:\n\t\tif (!is_connected(hdev, addr, addr_type))\n\t\t\thci_pend_le_list_add(params, &hdev->pend_le_conns);\n\t\tbreak;\n\t}\n\n\tparams->auto_connect = auto_connect;\n\n\tbt_dev_dbg(hdev, \"addr %pMR (type %u) auto_connect %u\",\n\t\t   addr, addr_type, auto_connect);\n\n\treturn 0;\n}\n\nstatic void device_added(struct sock *sk, struct hci_dev *hdev,\n\t\t\t bdaddr_t *bdaddr, u8 type, u8 action)\n{\n\tstruct mgmt_ev_device_added ev;\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = type;\n\tev.action = action;\n\n\tmgmt_event(MGMT_EV_DEVICE_ADDED, hdev, &ev, sizeof(ev), sk);\n}\n\nstatic int add_device_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_update_passive_scan_sync(hdev);\n}\n\nstatic int add_device(struct sock *sk, struct hci_dev *hdev,\n\t\t      void *data, u16 len)\n{\n\tstruct mgmt_cp_add_device *cp = data;\n\tu8 auto_conn, addr_type;\n\tstruct hci_conn_params *params;\n\tint err;\n\tu32 current_flags = 0;\n\tu32 supported_flags;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!bdaddr_type_is_valid(cp->addr.type) ||\n\t    !bacmp(&cp->addr.bdaddr, BDADDR_ANY))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &cp->addr, sizeof(cp->addr));\n\n\tif (cp->action != 0x00 && cp->action != 0x01 && cp->action != 0x02)\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &cp->addr, sizeof(cp->addr));\n\n\thci_dev_lock(hdev);\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\t \n\t\tif (cp->action != 0x01) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_ADD_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = hci_bdaddr_list_add_with_flags(&hdev->accept_list,\n\t\t\t\t\t\t     &cp->addr.bdaddr,\n\t\t\t\t\t\t     cp->addr.type, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\thci_update_scan(hdev);\n\n\t\tgoto added;\n\t}\n\n\taddr_type = le_addr_type(cp->addr.type);\n\n\tif (cp->action == 0x02)\n\t\tauto_conn = HCI_AUTO_CONN_ALWAYS;\n\telse if (cp->action == 0x01)\n\t\tauto_conn = HCI_AUTO_CONN_DIRECT;\n\telse\n\t\tauto_conn = HCI_AUTO_CONN_REPORT;\n\n\t \n\tif (!hci_is_identity_address(&cp->addr.bdaddr, addr_type)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\n\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (hci_conn_params_set(hdev, &cp->addr.bdaddr, addr_type,\n\t\t\t\tauto_conn) < 0) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\n\t\t\t\t\tMGMT_STATUS_FAILED, &cp->addr,\n\t\t\t\t\tsizeof(cp->addr));\n\t\tgoto unlock;\n\t} else {\n\t\tparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t\taddr_type);\n\t\tif (params)\n\t\t\tcurrent_flags = params->flags;\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, add_device_sync, NULL, NULL);\n\tif (err < 0)\n\t\tgoto unlock;\n\nadded:\n\tdevice_added(sk, hdev, &cp->addr.bdaddr, cp->addr.type, cp->action);\n\tsupported_flags = hdev->conn_flags;\n\tdevice_flags_changed(NULL, hdev, &cp->addr.bdaddr, cp->addr.type,\n\t\t\t     supported_flags, current_flags);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\n\t\t\t\tMGMT_STATUS_SUCCESS, &cp->addr,\n\t\t\t\tsizeof(cp->addr));\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void device_removed(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   bdaddr_t *bdaddr, u8 type)\n{\n\tstruct mgmt_ev_device_removed ev;\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = type;\n\n\tmgmt_event(MGMT_EV_DEVICE_REMOVED, hdev, &ev, sizeof(ev), sk);\n}\n\nstatic int remove_device_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_update_passive_scan_sync(hdev);\n}\n\nstatic int remove_device(struct sock *sk, struct hci_dev *hdev,\n\t\t\t void *data, u16 len)\n{\n\tstruct mgmt_cp_remove_device *cp = data;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {\n\t\tstruct hci_conn_params *params;\n\t\tu8 addr_type;\n\n\t\tif (!bdaddr_type_is_valid(cp->addr.type)) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (cp->addr.type == BDADDR_BREDR) {\n\t\t\terr = hci_bdaddr_list_del(&hdev->accept_list,\n\t\t\t\t\t\t  &cp->addr.bdaddr,\n\t\t\t\t\t\t  cp->addr.type);\n\t\t\tif (err) {\n\t\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t\t&cp->addr,\n\t\t\t\t\t\t\tsizeof(cp->addr));\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\thci_update_scan(hdev);\n\n\t\t\tdevice_removed(sk, hdev, &cp->addr.bdaddr,\n\t\t\t\t       cp->addr.type);\n\t\t\tgoto complete;\n\t\t}\n\n\t\taddr_type = le_addr_type(cp->addr.type);\n\n\t\t \n\t\tif (!hci_is_identity_address(&cp->addr.bdaddr, addr_type)) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t\taddr_type);\n\t\tif (!params) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (params->auto_connect == HCI_AUTO_CONN_DISABLED ||\n\t\t    params->auto_connect == HCI_AUTO_CONN_EXPLICIT) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\thci_conn_params_free(params);\n\n\t\tdevice_removed(sk, hdev, &cp->addr.bdaddr, cp->addr.type);\n\t} else {\n\t\tstruct hci_conn_params *p, *tmp;\n\t\tstruct bdaddr_list *b, *btmp;\n\n\t\tif (cp->addr.type) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tlist_for_each_entry_safe(b, btmp, &hdev->accept_list, list) {\n\t\t\tdevice_removed(sk, hdev, &b->bdaddr, b->bdaddr_type);\n\t\t\tlist_del(&b->list);\n\t\t\tkfree(b);\n\t\t}\n\n\t\thci_update_scan(hdev);\n\n\t\tlist_for_each_entry_safe(p, tmp, &hdev->le_conn_params, list) {\n\t\t\tif (p->auto_connect == HCI_AUTO_CONN_DISABLED)\n\t\t\t\tcontinue;\n\t\t\tdevice_removed(sk, hdev, &p->addr, p->addr_type);\n\t\t\tif (p->explicit_connect) {\n\t\t\t\tp->auto_connect = HCI_AUTO_CONN_EXPLICIT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thci_conn_params_free(p);\n\t\t}\n\n\t\tbt_dev_dbg(hdev, \"All LE connection parameters were removed\");\n\t}\n\n\thci_cmd_sync_queue(hdev, remove_device_sync, NULL, NULL);\n\ncomplete:\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_DEVICE,\n\t\t\t\tMGMT_STATUS_SUCCESS, &cp->addr,\n\t\t\t\tsizeof(cp->addr));\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int load_conn_param(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t   u16 len)\n{\n\tstruct mgmt_cp_load_conn_param *cp = data;\n\tconst u16 max_param_count = ((U16_MAX - sizeof(*cp)) /\n\t\t\t\t     sizeof(struct mgmt_conn_param));\n\tu16 param_count, expected_len;\n\tint i;\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tparam_count = __le16_to_cpu(cp->param_count);\n\tif (param_count > max_param_count) {\n\t\tbt_dev_err(hdev, \"load_conn_param: too big param_count value %u\",\n\t\t\t   param_count);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\texpected_len = struct_size(cp, params, param_count);\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"load_conn_param: expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\tbt_dev_dbg(hdev, \"param_count %u\", param_count);\n\n\thci_dev_lock(hdev);\n\n\thci_conn_params_clear_disabled(hdev);\n\n\tfor (i = 0; i < param_count; i++) {\n\t\tstruct mgmt_conn_param *param = &cp->params[i];\n\t\tstruct hci_conn_params *hci_param;\n\t\tu16 min, max, latency, timeout;\n\t\tu8 addr_type;\n\n\t\tbt_dev_dbg(hdev, \"Adding %pMR (type %u)\", &param->addr.bdaddr,\n\t\t\t   param->addr.type);\n\n\t\tif (param->addr.type == BDADDR_LE_PUBLIC) {\n\t\t\taddr_type = ADDR_LE_DEV_PUBLIC;\n\t\t} else if (param->addr.type == BDADDR_LE_RANDOM) {\n\t\t\taddr_type = ADDR_LE_DEV_RANDOM;\n\t\t} else {\n\t\t\tbt_dev_err(hdev, \"ignoring invalid connection parameters\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tmin = le16_to_cpu(param->min_interval);\n\t\tmax = le16_to_cpu(param->max_interval);\n\t\tlatency = le16_to_cpu(param->latency);\n\t\ttimeout = le16_to_cpu(param->timeout);\n\n\t\tbt_dev_dbg(hdev, \"min 0x%04x max 0x%04x latency 0x%04x timeout 0x%04x\",\n\t\t\t   min, max, latency, timeout);\n\n\t\tif (hci_check_conn_params(min, max, latency, timeout) < 0) {\n\t\t\tbt_dev_err(hdev, \"ignoring invalid connection parameters\");\n\t\t\tcontinue;\n\t\t}\n\n\t\thci_param = hci_conn_params_add(hdev, &param->addr.bdaddr,\n\t\t\t\t\t\taddr_type);\n\t\tif (!hci_param) {\n\t\t\tbt_dev_err(hdev, \"failed to add connection parameters\");\n\t\t\tcontinue;\n\t\t}\n\n\t\thci_param->conn_min_interval = min;\n\t\thci_param->conn_max_interval = max;\n\t\thci_param->conn_latency = latency;\n\t\thci_param->supervision_timeout = timeout;\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM, 0,\n\t\t\t\t NULL, 0);\n}\n\nstatic int set_external_config(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 len)\n{\n\tstruct mgmt_cp_set_external_config *cp = data;\n\tbool changed;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (hdev_is_powered(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->config != 0x00 && cp->config != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,\n\t\t\t\t         MGMT_STATUS_INVALID_PARAMS);\n\n\tif (!test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->config)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_EXT_CONFIGURED);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_EXT_CONFIGURED);\n\n\terr = send_options_rsp(sk, MGMT_OP_SET_EXTERNAL_CONFIG, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (!changed)\n\t\tgoto unlock;\n\n\terr = new_options(hdev, sk);\n\n\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED) == is_configured(hdev)) {\n\t\tmgmt_index_removed(hdev);\n\n\t\tif (hci_dev_test_and_change_flag(hdev, HCI_UNCONFIGURED)) {\n\t\t\thci_dev_set_flag(hdev, HCI_CONFIG);\n\t\t\thci_dev_set_flag(hdev, HCI_AUTO_OFF);\n\n\t\t\tqueue_work(hdev->req_workqueue, &hdev->power_on);\n\t\t} else {\n\t\t\tset_bit(HCI_RAW, &hdev->flags);\n\t\t\tmgmt_index_added(hdev);\n\t\t}\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_public_address(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 len)\n{\n\tstruct mgmt_cp_set_public_address *cp = data;\n\tbool changed;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (hdev_is_powered(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (!bacmp(&cp->bdaddr, BDADDR_ANY))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (!hdev->set_bdaddr)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\thci_dev_lock(hdev);\n\n\tchanged = !!bacmp(&hdev->public_addr, &cp->bdaddr);\n\tbacpy(&hdev->public_addr, &cp->bdaddr);\n\n\terr = send_options_rsp(sk, MGMT_OP_SET_PUBLIC_ADDRESS, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (!changed)\n\t\tgoto unlock;\n\n\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED))\n\t\terr = new_options(hdev, sk);\n\n\tif (is_configured(hdev)) {\n\t\tmgmt_index_removed(hdev);\n\n\t\thci_dev_clear_flag(hdev, HCI_UNCONFIGURED);\n\n\t\thci_dev_set_flag(hdev, HCI_CONFIG);\n\t\thci_dev_set_flag(hdev, HCI_AUTO_OFF);\n\n\t\tqueue_work(hdev->req_workqueue, &hdev->power_on);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void read_local_oob_ext_data_complete(struct hci_dev *hdev, void *data,\n\t\t\t\t\t     int err)\n{\n\tconst struct mgmt_cp_read_local_oob_ext_data *mgmt_cp;\n\tstruct mgmt_rp_read_local_oob_ext_data *mgmt_rp;\n\tu8 *h192, *r192, *h256, *r256;\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct sk_buff *skb = cmd->skb;\n\tu8 status = mgmt_status(err);\n\tu16 eir_len;\n\n\tif (cmd != pending_find(MGMT_OP_READ_LOCAL_OOB_EXT_DATA, hdev))\n\t\treturn;\n\n\tif (!status) {\n\t\tif (!skb)\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\telse if (IS_ERR(skb))\n\t\t\tstatus = mgmt_status(PTR_ERR(skb));\n\t\telse\n\t\t\tstatus = mgmt_status(skb->data[0]);\n\t}\n\n\tbt_dev_dbg(hdev, \"status %u\", status);\n\n\tmgmt_cp = cmd->param;\n\n\tif (status) {\n\t\tstatus = mgmt_status(status);\n\t\teir_len = 0;\n\n\t\th192 = NULL;\n\t\tr192 = NULL;\n\t\th256 = NULL;\n\t\tr256 = NULL;\n\t} else if (!bredr_sc_enabled(hdev)) {\n\t\tstruct hci_rp_read_local_oob_data *rp;\n\n\t\tif (skb->len != sizeof(*rp)) {\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\t\teir_len = 0;\n\t\t} else {\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\t\t\trp = (void *)skb->data;\n\n\t\t\teir_len = 5 + 18 + 18;\n\t\t\th192 = rp->hash;\n\t\t\tr192 = rp->rand;\n\t\t\th256 = NULL;\n\t\t\tr256 = NULL;\n\t\t}\n\t} else {\n\t\tstruct hci_rp_read_local_oob_ext_data *rp;\n\n\t\tif (skb->len != sizeof(*rp)) {\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\t\teir_len = 0;\n\t\t} else {\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\t\t\trp = (void *)skb->data;\n\n\t\t\tif (hci_dev_test_flag(hdev, HCI_SC_ONLY)) {\n\t\t\t\teir_len = 5 + 18 + 18;\n\t\t\t\th192 = NULL;\n\t\t\t\tr192 = NULL;\n\t\t\t} else {\n\t\t\t\teir_len = 5 + 18 + 18 + 18 + 18;\n\t\t\t\th192 = rp->hash192;\n\t\t\t\tr192 = rp->rand192;\n\t\t\t}\n\n\t\t\th256 = rp->hash256;\n\t\t\tr256 = rp->rand256;\n\t\t}\n\t}\n\n\tmgmt_rp = kmalloc(sizeof(*mgmt_rp) + eir_len, GFP_KERNEL);\n\tif (!mgmt_rp)\n\t\tgoto done;\n\n\tif (eir_len == 0)\n\t\tgoto send_rsp;\n\n\teir_len = eir_append_data(mgmt_rp->eir, 0, EIR_CLASS_OF_DEV,\n\t\t\t\t  hdev->dev_class, 3);\n\n\tif (h192 && r192) {\n\t\teir_len = eir_append_data(mgmt_rp->eir, eir_len,\n\t\t\t\t\t  EIR_SSP_HASH_C192, h192, 16);\n\t\teir_len = eir_append_data(mgmt_rp->eir, eir_len,\n\t\t\t\t\t  EIR_SSP_RAND_R192, r192, 16);\n\t}\n\n\tif (h256 && r256) {\n\t\teir_len = eir_append_data(mgmt_rp->eir, eir_len,\n\t\t\t\t\t  EIR_SSP_HASH_C256, h256, 16);\n\t\teir_len = eir_append_data(mgmt_rp->eir, eir_len,\n\t\t\t\t\t  EIR_SSP_RAND_R256, r256, 16);\n\t}\n\nsend_rsp:\n\tmgmt_rp->type = mgmt_cp->type;\n\tmgmt_rp->eir_len = cpu_to_le16(eir_len);\n\n\terr = mgmt_cmd_complete(cmd->sk, hdev->id,\n\t\t\t\tMGMT_OP_READ_LOCAL_OOB_EXT_DATA, status,\n\t\t\t\tmgmt_rp, sizeof(*mgmt_rp) + eir_len);\n\tif (err < 0 || status)\n\t\tgoto done;\n\n\thci_sock_set_flag(cmd->sk, HCI_MGMT_OOB_DATA_EVENTS);\n\n\terr = mgmt_limited_event(MGMT_EV_LOCAL_OOB_DATA_UPDATED, hdev,\n\t\t\t\t mgmt_rp, sizeof(*mgmt_rp) + eir_len,\n\t\t\t\t HCI_MGMT_OOB_DATA_EVENTS, cmd->sk);\ndone:\n\tif (skb && !IS_ERR(skb))\n\t\tkfree_skb(skb);\n\n\tkfree(mgmt_rp);\n\tmgmt_pending_remove(cmd);\n}\n\nstatic int read_local_ssp_oob_req(struct hci_dev *hdev, struct sock *sk,\n\t\t\t\t  struct mgmt_cp_read_local_oob_ext_data *cp)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_EXT_DATA, hdev,\n\t\t\t       cp, sizeof(*cp));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\terr = hci_cmd_sync_queue(hdev, read_local_oob_data_sync, cmd,\n\t\t\t\t read_local_oob_ext_data_complete);\n\n\tif (err < 0) {\n\t\tmgmt_pending_remove(cmd);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_local_oob_ext_data(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   void *data, u16 data_len)\n{\n\tstruct mgmt_cp_read_local_oob_ext_data *cp = data;\n\tstruct mgmt_rp_read_local_oob_ext_data *rp;\n\tsize_t rp_len;\n\tu16 eir_len;\n\tu8 status, flags, role, addr[7], hash[16], rand[16];\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (hdev_is_powered(hdev)) {\n\t\tswitch (cp->type) {\n\t\tcase BIT(BDADDR_BREDR):\n\t\t\tstatus = mgmt_bredr_support(hdev);\n\t\t\tif (status)\n\t\t\t\teir_len = 0;\n\t\t\telse\n\t\t\t\teir_len = 5;\n\t\t\tbreak;\n\t\tcase (BIT(BDADDR_LE_PUBLIC) | BIT(BDADDR_LE_RANDOM)):\n\t\t\tstatus = mgmt_le_support(hdev);\n\t\t\tif (status)\n\t\t\t\teir_len = 0;\n\t\t\telse\n\t\t\t\teir_len = 9 + 3 + 18 + 18 + 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = MGMT_STATUS_INVALID_PARAMS;\n\t\t\teir_len = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tstatus = MGMT_STATUS_NOT_POWERED;\n\t\teir_len = 0;\n\t}\n\n\trp_len = sizeof(*rp) + eir_len;\n\trp = kmalloc(rp_len, GFP_ATOMIC);\n\tif (!rp)\n\t\treturn -ENOMEM;\n\n\tif (!status && !lmp_ssp_capable(hdev)) {\n\t\tstatus = MGMT_STATUS_NOT_SUPPORTED;\n\t\teir_len = 0;\n\t}\n\n\tif (status)\n\t\tgoto complete;\n\n\thci_dev_lock(hdev);\n\n\teir_len = 0;\n\tswitch (cp->type) {\n\tcase BIT(BDADDR_BREDR):\n\t\tif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\n\t\t\terr = read_local_ssp_oob_req(hdev, sk, cp);\n\t\t\thci_dev_unlock(hdev);\n\t\t\tif (!err)\n\t\t\t\tgoto done;\n\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\t\tgoto complete;\n\t\t} else {\n\t\t\teir_len = eir_append_data(rp->eir, eir_len,\n\t\t\t\t\t\t  EIR_CLASS_OF_DEV,\n\t\t\t\t\t\t  hdev->dev_class, 3);\n\t\t}\n\t\tbreak;\n\tcase (BIT(BDADDR_LE_PUBLIC) | BIT(BDADDR_LE_RANDOM)):\n\t\tif (hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&\n\t\t    smp_generate_oob(hdev, hash, rand) < 0) {\n\t\t\thci_dev_unlock(hdev);\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\t\tgoto complete;\n\t\t}\n\n\t\t \n\t\tif (hci_dev_test_flag(hdev, HCI_PRIVACY)) {\n\t\t\thci_dev_unlock(hdev);\n\t\t\tstatus = MGMT_STATUS_REJECTED;\n\t\t\tgoto complete;\n\t\t}\n\n\t\tif (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||\n\t\t   !bacmp(&hdev->bdaddr, BDADDR_ANY) ||\n\t\t   (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\n\t\t    bacmp(&hdev->static_addr, BDADDR_ANY))) {\n\t\t\tmemcpy(addr, &hdev->static_addr, 6);\n\t\t\taddr[6] = 0x01;\n\t\t} else {\n\t\t\tmemcpy(addr, &hdev->bdaddr, 6);\n\t\t\taddr[6] = 0x00;\n\t\t}\n\n\t\teir_len = eir_append_data(rp->eir, eir_len, EIR_LE_BDADDR,\n\t\t\t\t\t  addr, sizeof(addr));\n\n\t\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\t\trole = 0x02;\n\t\telse\n\t\t\trole = 0x01;\n\n\t\teir_len = eir_append_data(rp->eir, eir_len, EIR_LE_ROLE,\n\t\t\t\t\t  &role, sizeof(role));\n\n\t\tif (hci_dev_test_flag(hdev, HCI_SC_ENABLED)) {\n\t\t\teir_len = eir_append_data(rp->eir, eir_len,\n\t\t\t\t\t\t  EIR_LE_SC_CONFIRM,\n\t\t\t\t\t\t  hash, sizeof(hash));\n\n\t\t\teir_len = eir_append_data(rp->eir, eir_len,\n\t\t\t\t\t\t  EIR_LE_SC_RANDOM,\n\t\t\t\t\t\t  rand, sizeof(rand));\n\t\t}\n\n\t\tflags = mgmt_get_adv_discov_flags(hdev);\n\n\t\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\t\tflags |= LE_AD_NO_BREDR;\n\n\t\teir_len = eir_append_data(rp->eir, eir_len, EIR_FLAGS,\n\t\t\t\t\t  &flags, sizeof(flags));\n\t\tbreak;\n\t}\n\n\thci_dev_unlock(hdev);\n\n\thci_sock_set_flag(sk, HCI_MGMT_OOB_DATA_EVENTS);\n\n\tstatus = MGMT_STATUS_SUCCESS;\n\ncomplete:\n\trp->type = cp->type;\n\trp->eir_len = cpu_to_le16(eir_len);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_EXT_DATA,\n\t\t\t\tstatus, rp, sizeof(*rp) + eir_len);\n\tif (err < 0 || status)\n\t\tgoto done;\n\n\terr = mgmt_limited_event(MGMT_EV_LOCAL_OOB_DATA_UPDATED, hdev,\n\t\t\t\t rp, sizeof(*rp) + eir_len,\n\t\t\t\t HCI_MGMT_OOB_DATA_EVENTS, sk);\n\ndone:\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic u32 get_supported_adv_flags(struct hci_dev *hdev)\n{\n\tu32 flags = 0;\n\n\tflags |= MGMT_ADV_FLAG_CONNECTABLE;\n\tflags |= MGMT_ADV_FLAG_DISCOV;\n\tflags |= MGMT_ADV_FLAG_LIMITED_DISCOV;\n\tflags |= MGMT_ADV_FLAG_MANAGED_FLAGS;\n\tflags |= MGMT_ADV_FLAG_APPEARANCE;\n\tflags |= MGMT_ADV_FLAG_LOCAL_NAME;\n\tflags |= MGMT_ADV_PARAM_DURATION;\n\tflags |= MGMT_ADV_PARAM_TIMEOUT;\n\tflags |= MGMT_ADV_PARAM_INTERVALS;\n\tflags |= MGMT_ADV_PARAM_TX_POWER;\n\tflags |= MGMT_ADV_PARAM_SCAN_RSP;\n\n\t \n\tif (hdev->adv_tx_power != HCI_TX_POWER_INVALID || ext_adv_capable(hdev))\n\t\tflags |= MGMT_ADV_FLAG_TX_POWER;\n\n\tif (ext_adv_capable(hdev)) {\n\t\tflags |= MGMT_ADV_FLAG_SEC_1M;\n\t\tflags |= MGMT_ADV_FLAG_HW_OFFLOAD;\n\t\tflags |= MGMT_ADV_FLAG_CAN_SET_TX_POWER;\n\n\t\tif (le_2m_capable(hdev))\n\t\t\tflags |= MGMT_ADV_FLAG_SEC_2M;\n\n\t\tif (le_coded_capable(hdev))\n\t\t\tflags |= MGMT_ADV_FLAG_SEC_CODED;\n\t}\n\n\treturn flags;\n}\n\nstatic int read_adv_features(struct sock *sk, struct hci_dev *hdev,\n\t\t\t     void *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_adv_features *rp;\n\tsize_t rp_len;\n\tint err;\n\tstruct adv_info *adv_instance;\n\tu32 supported_flags;\n\tu8 *instance;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_ADV_FEATURES,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\thci_dev_lock(hdev);\n\n\trp_len = sizeof(*rp) + hdev->adv_instance_cnt;\n\trp = kmalloc(rp_len, GFP_ATOMIC);\n\tif (!rp) {\n\t\thci_dev_unlock(hdev);\n\t\treturn -ENOMEM;\n\t}\n\n\tsupported_flags = get_supported_adv_flags(hdev);\n\n\trp->supported_flags = cpu_to_le32(supported_flags);\n\trp->max_adv_data_len = max_adv_len(hdev);\n\trp->max_scan_rsp_len = max_adv_len(hdev);\n\trp->max_instances = hdev->le_num_of_adv_sets;\n\trp->num_instances = hdev->adv_instance_cnt;\n\n\tinstance = rp->instance;\n\tlist_for_each_entry(adv_instance, &hdev->adv_instances, list) {\n\t\t \n\t\tif (adv_instance->instance <= hdev->adv_instance_cnt) {\n\t\t\t*instance = adv_instance->instance;\n\t\t\tinstance++;\n\t\t} else {\n\t\t\trp->num_instances--;\n\t\t\trp_len--;\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_ADV_FEATURES,\n\t\t\t\tMGMT_STATUS_SUCCESS, rp, rp_len);\n\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic u8 calculate_name_len(struct hci_dev *hdev)\n{\n\tu8 buf[HCI_MAX_SHORT_NAME_LENGTH + 3];\n\n\treturn eir_append_local_name(hdev, buf, 0);\n}\n\nstatic u8 tlv_data_max_len(struct hci_dev *hdev, u32 adv_flags,\n\t\t\t   bool is_adv_data)\n{\n\tu8 max_len = max_adv_len(hdev);\n\n\tif (is_adv_data) {\n\t\tif (adv_flags & (MGMT_ADV_FLAG_DISCOV |\n\t\t\t\t MGMT_ADV_FLAG_LIMITED_DISCOV |\n\t\t\t\t MGMT_ADV_FLAG_MANAGED_FLAGS))\n\t\t\tmax_len -= 3;\n\n\t\tif (adv_flags & MGMT_ADV_FLAG_TX_POWER)\n\t\t\tmax_len -= 3;\n\t} else {\n\t\tif (adv_flags & MGMT_ADV_FLAG_LOCAL_NAME)\n\t\t\tmax_len -= calculate_name_len(hdev);\n\n\t\tif (adv_flags & (MGMT_ADV_FLAG_APPEARANCE))\n\t\t\tmax_len -= 4;\n\t}\n\n\treturn max_len;\n}\n\nstatic bool flags_managed(u32 adv_flags)\n{\n\treturn adv_flags & (MGMT_ADV_FLAG_DISCOV |\n\t\t\t    MGMT_ADV_FLAG_LIMITED_DISCOV |\n\t\t\t    MGMT_ADV_FLAG_MANAGED_FLAGS);\n}\n\nstatic bool tx_power_managed(u32 adv_flags)\n{\n\treturn adv_flags & MGMT_ADV_FLAG_TX_POWER;\n}\n\nstatic bool name_managed(u32 adv_flags)\n{\n\treturn adv_flags & MGMT_ADV_FLAG_LOCAL_NAME;\n}\n\nstatic bool appearance_managed(u32 adv_flags)\n{\n\treturn adv_flags & MGMT_ADV_FLAG_APPEARANCE;\n}\n\nstatic bool tlv_data_is_valid(struct hci_dev *hdev, u32 adv_flags, u8 *data,\n\t\t\t      u8 len, bool is_adv_data)\n{\n\tint i, cur_len;\n\tu8 max_len;\n\n\tmax_len = tlv_data_max_len(hdev, adv_flags, is_adv_data);\n\n\tif (len > max_len)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < len; i += (cur_len + 1)) {\n\t\tcur_len = data[i];\n\n\t\tif (!cur_len)\n\t\t\tcontinue;\n\n\t\tif (data[i + 1] == EIR_FLAGS &&\n\t\t    (!is_adv_data || flags_managed(adv_flags)))\n\t\t\treturn false;\n\n\t\tif (data[i + 1] == EIR_TX_POWER && tx_power_managed(adv_flags))\n\t\t\treturn false;\n\n\t\tif (data[i + 1] == EIR_NAME_COMPLETE && name_managed(adv_flags))\n\t\t\treturn false;\n\n\t\tif (data[i + 1] == EIR_NAME_SHORT && name_managed(adv_flags))\n\t\t\treturn false;\n\n\t\tif (data[i + 1] == EIR_APPEARANCE &&\n\t\t    appearance_managed(adv_flags))\n\t\t\treturn false;\n\n\t\t \n\t\tif (i + cur_len >= len)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool requested_adv_flags_are_valid(struct hci_dev *hdev, u32 adv_flags)\n{\n\tu32 supported_flags, phy_flags;\n\n\t \n\tsupported_flags = get_supported_adv_flags(hdev);\n\tphy_flags = adv_flags & MGMT_ADV_FLAG_SEC_MASK;\n\tif (adv_flags & ~supported_flags ||\n\t    ((phy_flags && (phy_flags ^ (phy_flags & -phy_flags)))))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool adv_busy(struct hci_dev *hdev)\n{\n\treturn pending_find(MGMT_OP_SET_LE, hdev);\n}\n\nstatic void add_adv_complete(struct hci_dev *hdev, struct sock *sk, u8 instance,\n\t\t\t     int err)\n{\n\tstruct adv_info *adv, *n;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\thci_dev_lock(hdev);\n\n\tlist_for_each_entry_safe(adv, n, &hdev->adv_instances, list) {\n\t\tu8 instance;\n\n\t\tif (!adv->pending)\n\t\t\tcontinue;\n\n\t\tif (!err) {\n\t\t\tadv->pending = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinstance = adv->instance;\n\n\t\tif (hdev->cur_adv_instance == instance)\n\t\t\tcancel_adv_timeout(hdev);\n\n\t\thci_remove_adv_instance(hdev, instance);\n\t\tmgmt_advertising_removed(sk, hdev, instance);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void add_advertising_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_add_advertising *cp = cmd->param;\n\tstruct mgmt_rp_add_advertising rp;\n\n\tmemset(&rp, 0, sizeof(rp));\n\n\trp.instance = cp->instance;\n\n\tif (err)\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\tmgmt_status(err));\n\telse\n\t\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\t  mgmt_status(err), &rp, sizeof(rp));\n\n\tadd_adv_complete(hdev, cmd->sk, cp->instance, err);\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic int add_advertising_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_add_advertising *cp = cmd->param;\n\n\treturn hci_schedule_adv_instance_sync(hdev, cp->instance, true);\n}\n\nstatic int add_advertising(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   void *data, u16 data_len)\n{\n\tstruct mgmt_cp_add_advertising *cp = data;\n\tstruct mgmt_rp_add_advertising rp;\n\tu32 flags;\n\tu8 status;\n\tu16 timeout, duration;\n\tunsigned int prev_instance_cnt;\n\tu8 schedule_instance = 0;\n\tstruct adv_info *adv, *next_instance;\n\tint err;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tstatus = mgmt_le_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t       status);\n\n\tif (cp->instance < 1 || cp->instance > hdev->le_num_of_adv_sets)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (data_len != sizeof(*cp) + cp->adv_data_len + cp->scan_rsp_len)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tflags = __le32_to_cpu(cp->flags);\n\ttimeout = __le16_to_cpu(cp->timeout);\n\tduration = __le16_to_cpu(cp->duration);\n\n\tif (!requested_adv_flags_are_valid(hdev, flags))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (timeout && !hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto unlock;\n\t}\n\n\tif (adv_busy(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (!tlv_data_is_valid(hdev, flags, cp->data, cp->adv_data_len, true) ||\n\t    !tlv_data_is_valid(hdev, flags, cp->data + cp->adv_data_len,\n\t\t\t       cp->scan_rsp_len, false)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\tprev_instance_cnt = hdev->adv_instance_cnt;\n\n\tadv = hci_add_adv_instance(hdev, cp->instance, flags,\n\t\t\t\t   cp->adv_data_len, cp->data,\n\t\t\t\t   cp->scan_rsp_len,\n\t\t\t\t   cp->data + cp->adv_data_len,\n\t\t\t\t   timeout, duration,\n\t\t\t\t   HCI_ADV_TX_POWER_NO_PREFERENCE,\n\t\t\t\t   hdev->le_adv_min_interval,\n\t\t\t\t   hdev->le_adv_max_interval, 0);\n\tif (IS_ERR(adv)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (hdev->adv_instance_cnt > prev_instance_cnt)\n\t\tmgmt_advertising_added(sk, hdev, cp->instance);\n\n\tif (hdev->cur_adv_instance == cp->instance) {\n\t\t \n\t\tcancel_adv_timeout(hdev);\n\n\t\tnext_instance = hci_get_next_instance(hdev, cp->instance);\n\t\tif (next_instance)\n\t\t\tschedule_instance = next_instance->instance;\n\t} else if (!hdev->adv_instance_timeout) {\n\t\t \n\t\tschedule_instance = cp->instance;\n\t}\n\n\t \n\tif (!hdev_is_powered(hdev) ||\n\t    hci_dev_test_flag(hdev, HCI_ADVERTISING) ||\n\t    !schedule_instance) {\n\t\trp.instance = cp->instance;\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t\tMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\t \n\tcmd = mgmt_pending_new(sk, MGMT_OP_ADD_ADVERTISING, hdev, data,\n\t\t\t       data_len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tcp->instance = schedule_instance;\n\n\terr = hci_cmd_sync_queue(hdev, add_advertising_sync, cmd,\n\t\t\t\t add_advertising_complete);\n\tif (err < 0)\n\t\tmgmt_pending_free(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void add_ext_adv_params_complete(struct hci_dev *hdev, void *data,\n\t\t\t\t\tint err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_add_ext_adv_params *cp = cmd->param;\n\tstruct mgmt_rp_add_ext_adv_params rp;\n\tstruct adv_info *adv;\n\tu32 flags;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\thci_dev_lock(hdev);\n\n\tadv = hci_find_adv_instance(hdev, cp->instance);\n\tif (!adv)\n\t\tgoto unlock;\n\n\trp.instance = cp->instance;\n\trp.tx_power = adv->tx_power;\n\n\t \n\tflags = __le32_to_cpu(cp->flags);\n\trp.max_adv_data_len = tlv_data_max_len(hdev, flags, true);\n\trp.max_scan_rsp_len = tlv_data_max_len(hdev, flags, false);\n\n\tif (err) {\n\t\t \n\t\tif (!adv->pending)\n\t\t\tmgmt_advertising_removed(cmd->sk, hdev, cp->instance);\n\n\t\thci_remove_adv_instance(hdev, cp->instance);\n\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\tmgmt_status(err));\n\t} else {\n\t\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\t  mgmt_status(err), &rp, sizeof(rp));\n\t}\n\nunlock:\n\tif (cmd)\n\t\tmgmt_pending_free(cmd);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic int add_ext_adv_params_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_add_ext_adv_params *cp = cmd->param;\n\n\treturn hci_setup_ext_adv_instance_sync(hdev, cp->instance);\n}\n\nstatic int add_ext_adv_params(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 data_len)\n{\n\tstruct mgmt_cp_add_ext_adv_params *cp = data;\n\tstruct mgmt_rp_add_ext_adv_params rp;\n\tstruct mgmt_pending_cmd *cmd = NULL;\n\tstruct adv_info *adv;\n\tu32 flags, min_interval, max_interval;\n\tu16 timeout, duration;\n\tu8 status;\n\ts8 tx_power;\n\tint err;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tstatus = mgmt_le_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t       status);\n\n\tif (cp->instance < 1 || cp->instance > hdev->le_num_of_adv_sets)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t \n\tif (data_len < MGMT_ADD_EXT_ADV_PARAMS_MIN_SIZE)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tflags = __le32_to_cpu(cp->flags);\n\n\tif (!requested_adv_flags_are_valid(hdev, flags))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\t \n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto unlock;\n\t}\n\n\tif (adv_busy(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\t \n\ttimeout = (flags & MGMT_ADV_PARAM_TIMEOUT) ?\n\t\t  __le16_to_cpu(cp->timeout) : 0;\n\n\tduration = (flags & MGMT_ADV_PARAM_DURATION) ?\n\t\t   __le16_to_cpu(cp->duration) :\n\t\t   hdev->def_multi_adv_rotation_duration;\n\n\tmin_interval = (flags & MGMT_ADV_PARAM_INTERVALS) ?\n\t\t       __le32_to_cpu(cp->min_interval) :\n\t\t       hdev->le_adv_min_interval;\n\n\tmax_interval = (flags & MGMT_ADV_PARAM_INTERVALS) ?\n\t\t       __le32_to_cpu(cp->max_interval) :\n\t\t       hdev->le_adv_max_interval;\n\n\ttx_power = (flags & MGMT_ADV_PARAM_TX_POWER) ?\n\t\t   cp->tx_power :\n\t\t   HCI_ADV_TX_POWER_NO_PREFERENCE;\n\n\t \n\tadv = hci_add_adv_instance(hdev, cp->instance, flags, 0, NULL, 0, NULL,\n\t\t\t\t   timeout, duration, tx_power, min_interval,\n\t\t\t\t   max_interval, 0);\n\n\tif (IS_ERR(adv)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (ext_adv_capable(hdev)) {\n\t\tcmd = mgmt_pending_new(sk, MGMT_OP_ADD_EXT_ADV_PARAMS, hdev,\n\t\t\t\t       data, data_len);\n\t\tif (!cmd) {\n\t\t\terr = -ENOMEM;\n\t\t\thci_remove_adv_instance(hdev, cp->instance);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = hci_cmd_sync_queue(hdev, add_ext_adv_params_sync, cmd,\n\t\t\t\t\t add_ext_adv_params_complete);\n\t\tif (err < 0)\n\t\t\tmgmt_pending_free(cmd);\n\t} else {\n\t\trp.instance = cp->instance;\n\t\trp.tx_power = HCI_ADV_TX_POWER_NO_PREFERENCE;\n\t\trp.max_adv_data_len = tlv_data_max_len(hdev, flags, true);\n\t\trp.max_scan_rsp_len = tlv_data_max_len(hdev, flags, false);\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t\tMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void add_ext_adv_data_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_add_ext_adv_data *cp = cmd->param;\n\tstruct mgmt_rp_add_advertising rp;\n\n\tadd_adv_complete(hdev, cmd->sk, cp->instance, err);\n\n\tmemset(&rp, 0, sizeof(rp));\n\n\trp.instance = cp->instance;\n\n\tif (err)\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\tmgmt_status(err));\n\telse\n\t\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\t  mgmt_status(err), &rp, sizeof(rp));\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic int add_ext_adv_data_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_add_ext_adv_data *cp = cmd->param;\n\tint err;\n\n\tif (ext_adv_capable(hdev)) {\n\t\terr = hci_update_adv_data_sync(hdev, cp->instance);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = hci_update_scan_rsp_data_sync(hdev, cp->instance);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn hci_enable_ext_advertising_sync(hdev, cp->instance);\n\t}\n\n\treturn hci_schedule_adv_instance_sync(hdev, cp->instance, true);\n}\n\nstatic int add_ext_adv_data(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t    u16 data_len)\n{\n\tstruct mgmt_cp_add_ext_adv_data *cp = data;\n\tstruct mgmt_rp_add_ext_adv_data rp;\n\tu8 schedule_instance = 0;\n\tstruct adv_info *next_instance;\n\tstruct adv_info *adv_instance;\n\tint err = 0;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\thci_dev_lock(hdev);\n\n\tadv_instance = hci_find_adv_instance(hdev, cp->instance);\n\n\tif (!adv_instance) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto clear_new_instance;\n\t}\n\n\tif (adv_busy(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto clear_new_instance;\n\t}\n\n\t \n\tif (!tlv_data_is_valid(hdev, adv_instance->flags, cp->data,\n\t\t\t       cp->adv_data_len, true) ||\n\t    !tlv_data_is_valid(hdev, adv_instance->flags, cp->data +\n\t\t\t       cp->adv_data_len, cp->scan_rsp_len, false)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto clear_new_instance;\n\t}\n\n\t \n\thci_set_adv_instance_data(hdev, cp->instance, cp->adv_data_len,\n\t\t\t\t  cp->data, cp->scan_rsp_len,\n\t\t\t\t  cp->data + cp->adv_data_len);\n\n\t \n\tif (hdev->cur_adv_instance == cp->instance) {\n\t\t \n\t\tcancel_adv_timeout(hdev);\n\n\t\tnext_instance = hci_get_next_instance(hdev, cp->instance);\n\t\tif (next_instance)\n\t\t\tschedule_instance = next_instance->instance;\n\t} else if (!hdev->adv_instance_timeout) {\n\t\t \n\t\tschedule_instance = cp->instance;\n\t}\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING) || !schedule_instance) {\n\t\tif (adv_instance->pending) {\n\t\t\tmgmt_advertising_added(sk, hdev, cp->instance);\n\t\t\tadv_instance->pending = false;\n\t\t}\n\t\trp.instance = cp->instance;\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t\tMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_new(sk, MGMT_OP_ADD_EXT_ADV_DATA, hdev, data,\n\t\t\t       data_len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto clear_new_instance;\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, add_ext_adv_data_sync, cmd,\n\t\t\t\t add_ext_adv_data_complete);\n\tif (err < 0) {\n\t\tmgmt_pending_free(cmd);\n\t\tgoto clear_new_instance;\n\t}\n\n\t \n\tif (adv_instance->pending)\n\t\tmgmt_advertising_added(sk, hdev, cp->instance);\n\n\tgoto unlock;\n\nclear_new_instance:\n\thci_remove_adv_instance(hdev, cp->instance);\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void remove_advertising_complete(struct hci_dev *hdev, void *data,\n\t\t\t\t\tint err)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_remove_advertising *cp = cmd->param;\n\tstruct mgmt_rp_remove_advertising rp;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\tmemset(&rp, 0, sizeof(rp));\n\trp.instance = cp->instance;\n\n\tif (err)\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\tmgmt_status(err));\n\telse\n\t\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\t  MGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic int remove_advertising_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct mgmt_pending_cmd *cmd = data;\n\tstruct mgmt_cp_remove_advertising *cp = cmd->param;\n\tint err;\n\n\terr = hci_remove_advertising_sync(hdev, cmd->sk, cp->instance, true);\n\tif (err)\n\t\treturn err;\n\n\tif (list_empty(&hdev->adv_instances))\n\t\terr = hci_disable_advertising_sync(hdev);\n\n\treturn err;\n}\n\nstatic int remove_advertising(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 data_len)\n{\n\tstruct mgmt_cp_remove_advertising *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->instance && !hci_find_adv_instance(hdev, cp->instance)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_REMOVE_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_LE, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (list_empty(&hdev->adv_instances)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_new(sk, MGMT_OP_REMOVE_ADVERTISING, hdev, data,\n\t\t\t       data_len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\terr = hci_cmd_sync_queue(hdev, remove_advertising_sync, cmd,\n\t\t\t\t remove_advertising_complete);\n\tif (err < 0)\n\t\tmgmt_pending_free(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int get_adv_size_info(struct sock *sk, struct hci_dev *hdev,\n\t\t\t     void *data, u16 data_len)\n{\n\tstruct mgmt_cp_get_adv_size_info *cp = data;\n\tstruct mgmt_rp_get_adv_size_info rp;\n\tu32 flags, supported_flags;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->instance < 1 || cp->instance > hdev->le_num_of_adv_sets)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tflags = __le32_to_cpu(cp->flags);\n\n\t \n\tsupported_flags = get_supported_adv_flags(hdev);\n\tif (flags & ~supported_flags)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\trp.instance = cp->instance;\n\trp.flags = cp->flags;\n\trp.max_adv_data_len = tlv_data_max_len(hdev, flags, true);\n\trp.max_scan_rsp_len = tlv_data_max_len(hdev, flags, false);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\n\t\t\t\t MGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n}\n\nstatic const struct hci_mgmt_handler mgmt_handlers[] = {\n\t{ NULL },  \n\t{ read_version,            MGMT_READ_VERSION_SIZE,\n\t\t\t\t\t\tHCI_MGMT_NO_HDEV |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_commands,           MGMT_READ_COMMANDS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_NO_HDEV |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_index_list,         MGMT_READ_INDEX_LIST_SIZE,\n\t\t\t\t\t\tHCI_MGMT_NO_HDEV |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_controller_info,    MGMT_READ_INFO_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ set_powered,             MGMT_SETTING_SIZE },\n\t{ set_discoverable,        MGMT_SET_DISCOVERABLE_SIZE },\n\t{ set_connectable,         MGMT_SETTING_SIZE },\n\t{ set_fast_connectable,    MGMT_SETTING_SIZE },\n\t{ set_bondable,            MGMT_SETTING_SIZE },\n\t{ set_link_security,       MGMT_SETTING_SIZE },\n\t{ set_ssp,                 MGMT_SETTING_SIZE },\n\t{ set_hs,                  MGMT_SETTING_SIZE },\n\t{ set_le,                  MGMT_SETTING_SIZE },\n\t{ set_dev_class,           MGMT_SET_DEV_CLASS_SIZE },\n\t{ set_local_name,          MGMT_SET_LOCAL_NAME_SIZE },\n\t{ add_uuid,                MGMT_ADD_UUID_SIZE },\n\t{ remove_uuid,             MGMT_REMOVE_UUID_SIZE },\n\t{ load_link_keys,          MGMT_LOAD_LINK_KEYS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ load_long_term_keys,     MGMT_LOAD_LONG_TERM_KEYS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ disconnect,              MGMT_DISCONNECT_SIZE },\n\t{ get_connections,         MGMT_GET_CONNECTIONS_SIZE },\n\t{ pin_code_reply,          MGMT_PIN_CODE_REPLY_SIZE },\n\t{ pin_code_neg_reply,      MGMT_PIN_CODE_NEG_REPLY_SIZE },\n\t{ set_io_capability,       MGMT_SET_IO_CAPABILITY_SIZE },\n\t{ pair_device,             MGMT_PAIR_DEVICE_SIZE },\n\t{ cancel_pair_device,      MGMT_CANCEL_PAIR_DEVICE_SIZE },\n\t{ unpair_device,           MGMT_UNPAIR_DEVICE_SIZE },\n\t{ user_confirm_reply,      MGMT_USER_CONFIRM_REPLY_SIZE },\n\t{ user_confirm_neg_reply,  MGMT_USER_CONFIRM_NEG_REPLY_SIZE },\n\t{ user_passkey_reply,      MGMT_USER_PASSKEY_REPLY_SIZE },\n\t{ user_passkey_neg_reply,  MGMT_USER_PASSKEY_NEG_REPLY_SIZE },\n\t{ read_local_oob_data,     MGMT_READ_LOCAL_OOB_DATA_SIZE },\n\t{ add_remote_oob_data,     MGMT_ADD_REMOTE_OOB_DATA_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ remove_remote_oob_data,  MGMT_REMOVE_REMOTE_OOB_DATA_SIZE },\n\t{ start_discovery,         MGMT_START_DISCOVERY_SIZE },\n\t{ stop_discovery,          MGMT_STOP_DISCOVERY_SIZE },\n\t{ confirm_name,            MGMT_CONFIRM_NAME_SIZE },\n\t{ block_device,            MGMT_BLOCK_DEVICE_SIZE },\n\t{ unblock_device,          MGMT_UNBLOCK_DEVICE_SIZE },\n\t{ set_device_id,           MGMT_SET_DEVICE_ID_SIZE },\n\t{ set_advertising,         MGMT_SETTING_SIZE },\n\t{ set_bredr,               MGMT_SETTING_SIZE },\n\t{ set_static_address,      MGMT_SET_STATIC_ADDRESS_SIZE },\n\t{ set_scan_params,         MGMT_SET_SCAN_PARAMS_SIZE },\n\t{ set_secure_conn,         MGMT_SETTING_SIZE },\n\t{ set_debug_keys,          MGMT_SETTING_SIZE },\n\t{ set_privacy,             MGMT_SET_PRIVACY_SIZE },\n\t{ load_irks,               MGMT_LOAD_IRKS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ get_conn_info,           MGMT_GET_CONN_INFO_SIZE },\n\t{ get_clock_info,          MGMT_GET_CLOCK_INFO_SIZE },\n\t{ add_device,              MGMT_ADD_DEVICE_SIZE },\n\t{ remove_device,           MGMT_REMOVE_DEVICE_SIZE },\n\t{ load_conn_param,         MGMT_LOAD_CONN_PARAM_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ read_unconf_index_list,  MGMT_READ_UNCONF_INDEX_LIST_SIZE,\n\t\t\t\t\t\tHCI_MGMT_NO_HDEV |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_config_info,        MGMT_READ_CONFIG_INFO_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNCONFIGURED |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ set_external_config,     MGMT_SET_EXTERNAL_CONFIG_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNCONFIGURED },\n\t{ set_public_address,      MGMT_SET_PUBLIC_ADDRESS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNCONFIGURED },\n\t{ start_service_discovery, MGMT_START_SERVICE_DISCOVERY_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ read_local_oob_ext_data, MGMT_READ_LOCAL_OOB_EXT_DATA_SIZE },\n\t{ read_ext_index_list,     MGMT_READ_EXT_INDEX_LIST_SIZE,\n\t\t\t\t\t\tHCI_MGMT_NO_HDEV |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_adv_features,       MGMT_READ_ADV_FEATURES_SIZE },\n\t{ add_advertising,\t   MGMT_ADD_ADVERTISING_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ remove_advertising,\t   MGMT_REMOVE_ADVERTISING_SIZE },\n\t{ get_adv_size_info,       MGMT_GET_ADV_SIZE_INFO_SIZE },\n\t{ start_limited_discovery, MGMT_START_DISCOVERY_SIZE },\n\t{ read_ext_controller_info,MGMT_READ_EXT_INFO_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ set_appearance,\t   MGMT_SET_APPEARANCE_SIZE },\n\t{ get_phy_configuration,   MGMT_GET_PHY_CONFIGURATION_SIZE },\n\t{ set_phy_configuration,   MGMT_SET_PHY_CONFIGURATION_SIZE },\n\t{ set_blocked_keys,\t   MGMT_OP_SET_BLOCKED_KEYS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ set_wideband_speech,\t   MGMT_SETTING_SIZE },\n\t{ read_controller_cap,     MGMT_READ_CONTROLLER_CAP_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_exp_features_info,  MGMT_READ_EXP_FEATURES_INFO_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED |\n\t\t\t\t\t\tHCI_MGMT_HDEV_OPTIONAL },\n\t{ set_exp_feature,         MGMT_SET_EXP_FEATURE_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN |\n\t\t\t\t\t\tHCI_MGMT_HDEV_OPTIONAL },\n\t{ read_def_system_config,  MGMT_READ_DEF_SYSTEM_CONFIG_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ set_def_system_config,   MGMT_SET_DEF_SYSTEM_CONFIG_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ read_def_runtime_config, MGMT_READ_DEF_RUNTIME_CONFIG_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ set_def_runtime_config,  MGMT_SET_DEF_RUNTIME_CONFIG_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ get_device_flags,        MGMT_GET_DEVICE_FLAGS_SIZE },\n\t{ set_device_flags,        MGMT_SET_DEVICE_FLAGS_SIZE },\n\t{ read_adv_mon_features,   MGMT_READ_ADV_MONITOR_FEATURES_SIZE },\n\t{ add_adv_patterns_monitor,MGMT_ADD_ADV_PATTERNS_MONITOR_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ remove_adv_monitor,      MGMT_REMOVE_ADV_MONITOR_SIZE },\n\t{ add_ext_adv_params,      MGMT_ADD_EXT_ADV_PARAMS_MIN_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ add_ext_adv_data,        MGMT_ADD_EXT_ADV_DATA_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ add_adv_patterns_monitor_rssi,\n\t\t\t\t   MGMT_ADD_ADV_PATTERNS_MONITOR_RSSI_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ set_mesh,                MGMT_SET_MESH_RECEIVER_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ mesh_features,           MGMT_MESH_READ_FEATURES_SIZE },\n\t{ mesh_send,               MGMT_MESH_SEND_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ mesh_send_cancel,        MGMT_MESH_SEND_CANCEL_SIZE },\n};\n\nvoid mgmt_index_added(struct hci_dev *hdev)\n{\n\tstruct mgmt_ev_ext_index ev;\n\n\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))\n\t\treturn;\n\n\tswitch (hdev->dev_type) {\n\tcase HCI_PRIMARY:\n\t\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\n\t\t\tmgmt_index_event(MGMT_EV_UNCONF_INDEX_ADDED, hdev,\n\t\t\t\t\t NULL, 0, HCI_MGMT_UNCONF_INDEX_EVENTS);\n\t\t\tev.type = 0x01;\n\t\t} else {\n\t\t\tmgmt_index_event(MGMT_EV_INDEX_ADDED, hdev, NULL, 0,\n\t\t\t\t\t HCI_MGMT_INDEX_EVENTS);\n\t\t\tev.type = 0x00;\n\t\t}\n\t\tbreak;\n\tcase HCI_AMP:\n\t\tev.type = 0x02;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tev.bus = hdev->bus;\n\n\tmgmt_index_event(MGMT_EV_EXT_INDEX_ADDED, hdev, &ev, sizeof(ev),\n\t\t\t HCI_MGMT_EXT_INDEX_EVENTS);\n}\n\nvoid mgmt_index_removed(struct hci_dev *hdev)\n{\n\tstruct mgmt_ev_ext_index ev;\n\tu8 status = MGMT_STATUS_INVALID_INDEX;\n\n\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))\n\t\treturn;\n\n\tswitch (hdev->dev_type) {\n\tcase HCI_PRIMARY:\n\t\tmgmt_pending_foreach(0, hdev, cmd_complete_rsp, &status);\n\n\t\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\n\t\t\tmgmt_index_event(MGMT_EV_UNCONF_INDEX_REMOVED, hdev,\n\t\t\t\t\t NULL, 0, HCI_MGMT_UNCONF_INDEX_EVENTS);\n\t\t\tev.type = 0x01;\n\t\t} else {\n\t\t\tmgmt_index_event(MGMT_EV_INDEX_REMOVED, hdev, NULL, 0,\n\t\t\t\t\t HCI_MGMT_INDEX_EVENTS);\n\t\t\tev.type = 0x00;\n\t\t}\n\t\tbreak;\n\tcase HCI_AMP:\n\t\tev.type = 0x02;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tev.bus = hdev->bus;\n\n\tmgmt_index_event(MGMT_EV_EXT_INDEX_REMOVED, hdev, &ev, sizeof(ev),\n\t\t\t HCI_MGMT_EXT_INDEX_EVENTS);\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_MGMT))\n\t\treturn;\n\tcancel_delayed_work_sync(&hdev->discov_off);\n\tcancel_delayed_work_sync(&hdev->service_cache);\n\tcancel_delayed_work_sync(&hdev->rpa_expired);\n}\n\nvoid mgmt_power_on(struct hci_dev *hdev, int err)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\thci_dev_lock(hdev);\n\n\tif (!err) {\n\t\trestart_le_actions(hdev);\n\t\thci_update_passive_scan(hdev);\n\t}\n\n\tmgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);\n\n\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n\n\thci_dev_unlock(hdev);\n}\n\nvoid __mgmt_power_off(struct hci_dev *hdev)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\tu8 status, zero_cod[] = { 0, 0, 0 };\n\n\tmgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_UNREGISTER))\n\t\tstatus = MGMT_STATUS_INVALID_INDEX;\n\telse\n\t\tstatus = MGMT_STATUS_NOT_POWERED;\n\n\tmgmt_pending_foreach(0, hdev, cmd_complete_rsp, &status);\n\n\tif (memcmp(hdev->dev_class, zero_cod, sizeof(zero_cod)) != 0) {\n\t\tmgmt_limited_event(MGMT_EV_CLASS_OF_DEV_CHANGED, hdev,\n\t\t\t\t   zero_cod, sizeof(zero_cod),\n\t\t\t\t   HCI_MGMT_DEV_CLASS_EVENTS, NULL);\n\t\text_info_changed(hdev, NULL);\n\t}\n\n\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n}\n\nvoid mgmt_set_powered_failed(struct hci_dev *hdev, int err)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 status;\n\n\tcmd = pending_find(MGMT_OP_SET_POWERED, hdev);\n\tif (!cmd)\n\t\treturn;\n\n\tif (err == -ERFKILL)\n\t\tstatus = MGMT_STATUS_RFKILLED;\n\telse\n\t\tstatus = MGMT_STATUS_FAILED;\n\n\tmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_POWERED, status);\n\n\tmgmt_pending_remove(cmd);\n}\n\nvoid mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,\n\t\t       bool persistent)\n{\n\tstruct mgmt_ev_new_link_key ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tev.store_hint = persistent;\n\tbacpy(&ev.key.addr.bdaddr, &key->bdaddr);\n\tev.key.addr.type = link_to_bdaddr(key->link_type, key->bdaddr_type);\n\tev.key.type = key->type;\n\tmemcpy(ev.key.val, key->val, HCI_LINK_KEY_SIZE);\n\tev.key.pin_len = key->pin_len;\n\n\tmgmt_event(MGMT_EV_NEW_LINK_KEY, hdev, &ev, sizeof(ev), NULL);\n}\n\nstatic u8 mgmt_ltk_type(struct smp_ltk *ltk)\n{\n\tswitch (ltk->type) {\n\tcase SMP_LTK:\n\tcase SMP_LTK_RESPONDER:\n\t\tif (ltk->authenticated)\n\t\t\treturn MGMT_LTK_AUTHENTICATED;\n\t\treturn MGMT_LTK_UNAUTHENTICATED;\n\tcase SMP_LTK_P256:\n\t\tif (ltk->authenticated)\n\t\t\treturn MGMT_LTK_P256_AUTH;\n\t\treturn MGMT_LTK_P256_UNAUTH;\n\tcase SMP_LTK_P256_DEBUG:\n\t\treturn MGMT_LTK_P256_DEBUG;\n\t}\n\n\treturn MGMT_LTK_UNAUTHENTICATED;\n}\n\nvoid mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, bool persistent)\n{\n\tstruct mgmt_ev_new_long_term_key ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\t \n\tif (key->bdaddr_type == ADDR_LE_DEV_RANDOM &&\n\t    (key->bdaddr.b[5] & 0xc0) != 0xc0)\n\t\tev.store_hint = 0x00;\n\telse\n\t\tev.store_hint = persistent;\n\n\tbacpy(&ev.key.addr.bdaddr, &key->bdaddr);\n\tev.key.addr.type = link_to_bdaddr(key->link_type, key->bdaddr_type);\n\tev.key.type = mgmt_ltk_type(key);\n\tev.key.enc_size = key->enc_size;\n\tev.key.ediv = key->ediv;\n\tev.key.rand = key->rand;\n\n\tif (key->type == SMP_LTK)\n\t\tev.key.initiator = 1;\n\n\t \n\tmemcpy(ev.key.val, key->val, key->enc_size);\n\tmemset(ev.key.val + key->enc_size, 0,\n\t       sizeof(ev.key.val) - key->enc_size);\n\n\tmgmt_event(MGMT_EV_NEW_LONG_TERM_KEY, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk, bool persistent)\n{\n\tstruct mgmt_ev_new_irk ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tev.store_hint = persistent;\n\n\tbacpy(&ev.rpa, &irk->rpa);\n\tbacpy(&ev.irk.addr.bdaddr, &irk->bdaddr);\n\tev.irk.addr.type = link_to_bdaddr(irk->link_type, irk->addr_type);\n\tmemcpy(ev.irk.val, irk->val, sizeof(irk->val));\n\n\tmgmt_event(MGMT_EV_NEW_IRK, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,\n\t\t   bool persistent)\n{\n\tstruct mgmt_ev_new_csrk ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\t \n\tif (csrk->bdaddr_type == ADDR_LE_DEV_RANDOM &&\n\t    (csrk->bdaddr.b[5] & 0xc0) != 0xc0)\n\t\tev.store_hint = 0x00;\n\telse\n\t\tev.store_hint = persistent;\n\n\tbacpy(&ev.key.addr.bdaddr, &csrk->bdaddr);\n\tev.key.addr.type = link_to_bdaddr(csrk->link_type, csrk->bdaddr_type);\n\tev.key.type = csrk->type;\n\tmemcpy(ev.key.val, csrk->val, sizeof(csrk->val));\n\n\tmgmt_event(MGMT_EV_NEW_CSRK, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t u8 bdaddr_type, u8 store_hint, u16 min_interval,\n\t\t\t u16 max_interval, u16 latency, u16 timeout)\n{\n\tstruct mgmt_ev_new_conn_param ev;\n\n\tif (!hci_is_identity_address(bdaddr, bdaddr_type))\n\t\treturn;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(LE_LINK, bdaddr_type);\n\tev.store_hint = store_hint;\n\tev.min_interval = cpu_to_le16(min_interval);\n\tev.max_interval = cpu_to_le16(max_interval);\n\tev.latency = cpu_to_le16(latency);\n\tev.timeout = cpu_to_le16(timeout);\n\n\tmgmt_event(MGMT_EV_NEW_CONN_PARAM, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_device_connected(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t   u8 *name, u8 name_len)\n{\n\tstruct sk_buff *skb;\n\tstruct mgmt_ev_device_connected *ev;\n\tu16 eir_len = 0;\n\tu32 flags = 0;\n\n\t \n\tif (conn->le_adv_data_len > 0)\n\t\tskb = mgmt_alloc_skb(hdev, MGMT_EV_DEVICE_CONNECTED,\n\t\t\t\t     sizeof(*ev) + conn->le_adv_data_len);\n\telse\n\t\tskb = mgmt_alloc_skb(hdev, MGMT_EV_DEVICE_CONNECTED,\n\t\t\t\t     sizeof(*ev) + (name ? eir_precalc_len(name_len) : 0) +\n\t\t\t\t     eir_precalc_len(sizeof(conn->dev_class)));\n\n\tev = skb_put(skb, sizeof(*ev));\n\tbacpy(&ev->addr.bdaddr, &conn->dst);\n\tev->addr.type = link_to_bdaddr(conn->type, conn->dst_type);\n\n\tif (conn->out)\n\t\tflags |= MGMT_DEV_FOUND_INITIATED_CONN;\n\n\tev->flags = __cpu_to_le32(flags);\n\n\t \n\tif (conn->le_adv_data_len > 0) {\n\t\tskb_put_data(skb, conn->le_adv_data, conn->le_adv_data_len);\n\t\teir_len = conn->le_adv_data_len;\n\t} else {\n\t\tif (name)\n\t\t\teir_len += eir_skb_put_data(skb, EIR_NAME_COMPLETE, name, name_len);\n\n\t\tif (memcmp(conn->dev_class, \"\\0\\0\\0\", sizeof(conn->dev_class)))\n\t\t\teir_len += eir_skb_put_data(skb, EIR_CLASS_OF_DEV,\n\t\t\t\t\t\t    conn->dev_class, sizeof(conn->dev_class));\n\t}\n\n\tev->eir_len = cpu_to_le16(eir_len);\n\n\tmgmt_event_skb(skb, NULL);\n}\n\nstatic void disconnect_rsp(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tstruct sock **sk = data;\n\n\tcmd->cmd_complete(cmd, 0);\n\n\t*sk = cmd->sk;\n\tsock_hold(*sk);\n\n\tmgmt_pending_remove(cmd);\n}\n\nstatic void unpair_device_rsp(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tstruct hci_dev *hdev = data;\n\tstruct mgmt_cp_unpair_device *cp = cmd->param;\n\n\tdevice_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, cmd->sk);\n\n\tcmd->cmd_complete(cmd, 0);\n\tmgmt_pending_remove(cmd);\n}\n\nbool mgmt_powering_down(struct hci_dev *hdev)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct mgmt_mode *cp;\n\n\tcmd = pending_find(MGMT_OP_SET_POWERED, hdev);\n\tif (!cmd)\n\t\treturn false;\n\n\tcp = cmd->param;\n\tif (!cp->val)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      u8 link_type, u8 addr_type, u8 reason,\n\t\t\t      bool mgmt_connected)\n{\n\tstruct mgmt_ev_device_disconnected ev;\n\tstruct sock *sk = NULL;\n\n\t \n\tif (mgmt_powering_down(hdev) && hci_conn_count(hdev) == 1) {\n\t\tcancel_delayed_work(&hdev->power_off);\n\t\tqueue_work(hdev->req_workqueue, &hdev->power_off.work);\n\t}\n\n\tif (!mgmt_connected)\n\t\treturn;\n\n\tif (link_type != ACL_LINK && link_type != LE_LINK)\n\t\treturn;\n\n\tmgmt_pending_foreach(MGMT_OP_DISCONNECT, hdev, disconnect_rsp, &sk);\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(link_type, addr_type);\n\tev.reason = reason;\n\n\t \n\tif (hdev->suspended)\n\t\tev.reason = MGMT_DEV_DISCONN_LOCAL_HOST_SUSPEND;\n\n\tmgmt_event(MGMT_EV_DEVICE_DISCONNECTED, hdev, &ev, sizeof(ev), sk);\n\n\tif (sk)\n\t\tsock_put(sk);\n\n\tmgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,\n\t\t\t     hdev);\n}\n\nvoid mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t    u8 link_type, u8 addr_type, u8 status)\n{\n\tu8 bdaddr_type = link_to_bdaddr(link_type, addr_type);\n\tstruct mgmt_cp_disconnect *cp;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tmgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,\n\t\t\t     hdev);\n\n\tcmd = pending_find(MGMT_OP_DISCONNECT, hdev);\n\tif (!cmd)\n\t\treturn;\n\n\tcp = cmd->param;\n\n\tif (bacmp(bdaddr, &cp->addr.bdaddr))\n\t\treturn;\n\n\tif (cp->addr.type != bdaddr_type)\n\t\treturn;\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n}\n\nvoid mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\n\t\t\t u8 addr_type, u8 status)\n{\n\tstruct mgmt_ev_connect_failed ev;\n\n\t \n\tif (mgmt_powering_down(hdev) && hci_conn_count(hdev) == 1) {\n\t\tcancel_delayed_work(&hdev->power_off);\n\t\tqueue_work(hdev->req_workqueue, &hdev->power_off.work);\n\t}\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(link_type, addr_type);\n\tev.status = mgmt_status(status);\n\n\tmgmt_event(MGMT_EV_CONNECT_FAILED, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure)\n{\n\tstruct mgmt_ev_pin_code_request ev;\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = BDADDR_BREDR;\n\tev.secure = secure;\n\n\tmgmt_event(MGMT_EV_PIN_CODE_REQUEST, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t  u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tcmd = pending_find(MGMT_OP_PIN_CODE_REPLY, hdev);\n\tif (!cmd)\n\t\treturn;\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n}\n\nvoid mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t      u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tcmd = pending_find(MGMT_OP_PIN_CODE_NEG_REPLY, hdev);\n\tif (!cmd)\n\t\treturn;\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n}\n\nint mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      u8 link_type, u8 addr_type, u32 value,\n\t\t\t      u8 confirm_hint)\n{\n\tstruct mgmt_ev_user_confirm_request ev;\n\n\tbt_dev_dbg(hdev, \"bdaddr %pMR\", bdaddr);\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(link_type, addr_type);\n\tev.confirm_hint = confirm_hint;\n\tev.value = cpu_to_le32(value);\n\n\treturn mgmt_event(MGMT_EV_USER_CONFIRM_REQUEST, hdev, &ev, sizeof(ev),\n\t\t\t  NULL);\n}\n\nint mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      u8 link_type, u8 addr_type)\n{\n\tstruct mgmt_ev_user_passkey_request ev;\n\n\tbt_dev_dbg(hdev, \"bdaddr %pMR\", bdaddr);\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(link_type, addr_type);\n\n\treturn mgmt_event(MGMT_EV_USER_PASSKEY_REQUEST, hdev, &ev, sizeof(ev),\n\t\t\t  NULL);\n}\n\nstatic int user_pairing_resp_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t      u8 link_type, u8 addr_type, u8 status,\n\t\t\t\t      u8 opcode)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tcmd = pending_find(opcode, hdev);\n\tif (!cmd)\n\t\treturn -ENOENT;\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n\n\treturn 0;\n}\n\nint mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t     u8 link_type, u8 addr_type, u8 status)\n{\n\treturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\n\t\t\t\t\t  status, MGMT_OP_USER_CONFIRM_REPLY);\n}\n\nint mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t\t u8 link_type, u8 addr_type, u8 status)\n{\n\treturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\n\t\t\t\t\t  status,\n\t\t\t\t\t  MGMT_OP_USER_CONFIRM_NEG_REPLY);\n}\n\nint mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t     u8 link_type, u8 addr_type, u8 status)\n{\n\treturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\n\t\t\t\t\t  status, MGMT_OP_USER_PASSKEY_REPLY);\n}\n\nint mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t\t u8 link_type, u8 addr_type, u8 status)\n{\n\treturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\n\t\t\t\t\t  status,\n\t\t\t\t\t  MGMT_OP_USER_PASSKEY_NEG_REPLY);\n}\n\nint mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t     u8 link_type, u8 addr_type, u32 passkey,\n\t\t\t     u8 entered)\n{\n\tstruct mgmt_ev_passkey_notify ev;\n\n\tbt_dev_dbg(hdev, \"bdaddr %pMR\", bdaddr);\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(link_type, addr_type);\n\tev.passkey = __cpu_to_le32(passkey);\n\tev.entered = entered;\n\n\treturn mgmt_event(MGMT_EV_PASSKEY_NOTIFY, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_auth_failed(struct hci_conn *conn, u8 hci_status)\n{\n\tstruct mgmt_ev_auth_failed ev;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 status = mgmt_status(hci_status);\n\n\tbacpy(&ev.addr.bdaddr, &conn->dst);\n\tev.addr.type = link_to_bdaddr(conn->type, conn->dst_type);\n\tev.status = status;\n\n\tcmd = find_pairing(conn);\n\n\tmgmt_event(MGMT_EV_AUTH_FAILED, conn->hdev, &ev, sizeof(ev),\n\t\t    cmd ? cmd->sk : NULL);\n\n\tif (cmd) {\n\t\tcmd->cmd_complete(cmd, status);\n\t\tmgmt_pending_remove(cmd);\n\t}\n}\n\nvoid mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\tbool changed;\n\n\tif (status) {\n\t\tu8 mgmt_err = mgmt_status(status);\n\t\tmgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev,\n\t\t\t\t     cmd_status_rsp, &mgmt_err);\n\t\treturn;\n\t}\n\n\tif (test_bit(HCI_AUTH, &hdev->flags))\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_LINK_SECURITY);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_LINK_SECURITY);\n\n\tmgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev, settings_rsp,\n\t\t\t     &match);\n\n\tif (changed)\n\t\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n}\n\nstatic void sk_lookup(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tstruct cmd_lookup *match = data;\n\n\tif (match->sk == NULL) {\n\t\tmatch->sk = cmd->sk;\n\t\tsock_hold(match->sk);\n\t}\n}\n\nvoid mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,\n\t\t\t\t    u8 status)\n{\n\tstruct cmd_lookup match = { NULL, hdev, mgmt_status(status) };\n\n\tmgmt_pending_foreach(MGMT_OP_SET_DEV_CLASS, hdev, sk_lookup, &match);\n\tmgmt_pending_foreach(MGMT_OP_ADD_UUID, hdev, sk_lookup, &match);\n\tmgmt_pending_foreach(MGMT_OP_REMOVE_UUID, hdev, sk_lookup, &match);\n\n\tif (!status) {\n\t\tmgmt_limited_event(MGMT_EV_CLASS_OF_DEV_CHANGED, hdev, dev_class,\n\t\t\t\t   3, HCI_MGMT_DEV_CLASS_EVENTS, NULL);\n\t\text_info_changed(hdev, NULL);\n\t}\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n}\n\nvoid mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status)\n{\n\tstruct mgmt_cp_set_local_name ev;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tif (status)\n\t\treturn;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tmemcpy(ev.name, name, HCI_MAX_NAME_LENGTH);\n\tmemcpy(ev.short_name, hdev->short_name, HCI_MAX_SHORT_NAME_LENGTH);\n\n\tcmd = pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);\n\tif (!cmd) {\n\t\tmemcpy(hdev->dev_name, name, sizeof(hdev->dev_name));\n\n\t\t \n\t\tif (pending_find(MGMT_OP_SET_POWERED, hdev))\n\t\t\treturn;\n\t}\n\n\tmgmt_limited_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, &ev, sizeof(ev),\n\t\t\t   HCI_MGMT_LOCAL_NAME_EVENTS, cmd ? cmd->sk : NULL);\n\text_info_changed(hdev, cmd ? cmd->sk : NULL);\n}\n\nstatic inline bool has_uuid(u8 *uuid, u16 uuid_count, u8 (*uuids)[16])\n{\n\tint i;\n\n\tfor (i = 0; i < uuid_count; i++) {\n\t\tif (!memcmp(uuid, uuids[i], 16))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool eir_has_uuids(u8 *eir, u16 eir_len, u16 uuid_count, u8 (*uuids)[16])\n{\n\tu16 parsed = 0;\n\n\twhile (parsed < eir_len) {\n\t\tu8 field_len = eir[0];\n\t\tu8 uuid[16];\n\t\tint i;\n\n\t\tif (field_len == 0)\n\t\t\tbreak;\n\n\t\tif (eir_len - parsed < field_len + 1)\n\t\t\tbreak;\n\n\t\tswitch (eir[1]) {\n\t\tcase EIR_UUID16_ALL:\n\t\tcase EIR_UUID16_SOME:\n\t\t\tfor (i = 0; i + 3 <= field_len; i += 2) {\n\t\t\t\tmemcpy(uuid, bluetooth_base_uuid, 16);\n\t\t\t\tuuid[13] = eir[i + 3];\n\t\t\t\tuuid[12] = eir[i + 2];\n\t\t\t\tif (has_uuid(uuid, uuid_count, uuids))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EIR_UUID32_ALL:\n\t\tcase EIR_UUID32_SOME:\n\t\t\tfor (i = 0; i + 5 <= field_len; i += 4) {\n\t\t\t\tmemcpy(uuid, bluetooth_base_uuid, 16);\n\t\t\t\tuuid[15] = eir[i + 5];\n\t\t\t\tuuid[14] = eir[i + 4];\n\t\t\t\tuuid[13] = eir[i + 3];\n\t\t\t\tuuid[12] = eir[i + 2];\n\t\t\t\tif (has_uuid(uuid, uuid_count, uuids))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EIR_UUID128_ALL:\n\t\tcase EIR_UUID128_SOME:\n\t\t\tfor (i = 0; i + 17 <= field_len; i += 16) {\n\t\t\t\tmemcpy(uuid, eir + i + 2, 16);\n\t\t\t\tif (has_uuid(uuid, uuid_count, uuids))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tparsed += field_len + 1;\n\t\teir += field_len + 1;\n\t}\n\n\treturn false;\n}\n\nstatic void restart_le_scan(struct hci_dev *hdev)\n{\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_SCAN))\n\t\treturn;\n\n\tif (time_after(jiffies + DISCOV_LE_RESTART_DELAY,\n\t\t       hdev->discovery.scan_start +\n\t\t       hdev->discovery.scan_duration))\n\t\treturn;\n\n\tqueue_delayed_work(hdev->req_workqueue, &hdev->le_scan_restart,\n\t\t\t   DISCOV_LE_RESTART_DELAY);\n}\n\nstatic bool is_filter_match(struct hci_dev *hdev, s8 rssi, u8 *eir,\n\t\t\t    u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len)\n{\n\t \n\tif (hdev->discovery.rssi != HCI_RSSI_INVALID &&\n\t    (rssi == HCI_RSSI_INVALID ||\n\t    (rssi < hdev->discovery.rssi &&\n\t     !test_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks))))\n\t\treturn  false;\n\n\tif (hdev->discovery.uuid_count != 0) {\n\t\t \n\t\tif (!eir_has_uuids(eir, eir_len, hdev->discovery.uuid_count,\n\t\t\t\t   hdev->discovery.uuids) &&\n\t\t    !eir_has_uuids(scan_rsp, scan_rsp_len,\n\t\t\t\t   hdev->discovery.uuid_count,\n\t\t\t\t   hdev->discovery.uuids))\n\t\t\treturn false;\n\t}\n\n\t \n\tif (test_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks)) {\n\t\trestart_le_scan(hdev);\n\n\t\t \n\t\tif (hdev->discovery.rssi != HCI_RSSI_INVALID &&\n\t\t    rssi < hdev->discovery.rssi)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid mgmt_adv_monitor_device_lost(struct hci_dev *hdev, u16 handle,\n\t\t\t\t  bdaddr_t *bdaddr, u8 addr_type)\n{\n\tstruct mgmt_ev_adv_monitor_device_lost ev;\n\n\tev.monitor_handle = cpu_to_le16(handle);\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = addr_type;\n\n\tmgmt_event(MGMT_EV_ADV_MONITOR_DEVICE_LOST, hdev, &ev, sizeof(ev),\n\t\t   NULL);\n}\n\nstatic void mgmt_send_adv_monitor_device_found(struct hci_dev *hdev,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       struct sock *skip_sk,\n\t\t\t\t\t       u16 handle)\n{\n\tstruct sk_buff *advmon_skb;\n\tsize_t advmon_skb_len;\n\t__le16 *monitor_handle;\n\n\tif (!skb)\n\t\treturn;\n\n\tadvmon_skb_len = (sizeof(struct mgmt_ev_adv_monitor_device_found) -\n\t\t\t  sizeof(struct mgmt_ev_device_found)) + skb->len;\n\tadvmon_skb = mgmt_alloc_skb(hdev, MGMT_EV_ADV_MONITOR_DEVICE_FOUND,\n\t\t\t\t    advmon_skb_len);\n\tif (!advmon_skb)\n\t\treturn;\n\n\t \n\tmonitor_handle = skb_put(advmon_skb, sizeof(*monitor_handle));\n\t*monitor_handle = cpu_to_le16(handle);\n\tskb_put_data(advmon_skb, skb->data, skb->len);\n\n\tmgmt_event_skb(advmon_skb, skip_sk);\n}\n\nstatic void mgmt_adv_monitor_device_found(struct hci_dev *hdev,\n\t\t\t\t\t  bdaddr_t *bdaddr, bool report_device,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct sock *skip_sk)\n{\n\tstruct monitored_device *dev, *tmp;\n\tbool matched = false;\n\tbool notified = false;\n\n\t \n\tif (report_device && !hdev->advmon_pend_notify) {\n\t\tmgmt_event_skb(skb, skip_sk);\n\t\treturn;\n\t}\n\n\thdev->advmon_pend_notify = false;\n\n\tlist_for_each_entry_safe(dev, tmp, &hdev->monitored_devices, list) {\n\t\tif (!bacmp(&dev->bdaddr, bdaddr)) {\n\t\t\tmatched = true;\n\n\t\t\tif (!dev->notified) {\n\t\t\t\tmgmt_send_adv_monitor_device_found(hdev, skb,\n\t\t\t\t\t\t\t\t   skip_sk,\n\t\t\t\t\t\t\t\t   dev->handle);\n\t\t\t\tnotified = true;\n\t\t\t\tdev->notified = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!dev->notified)\n\t\t\thdev->advmon_pend_notify = true;\n\t}\n\n\tif (!report_device &&\n\t    ((matched && !notified) || !msft_monitor_supported(hdev))) {\n\t\t \n\t\tmgmt_send_adv_monitor_device_found(hdev, skb, skip_sk, 0);\n\t}\n\n\tif (report_device)\n\t\tmgmt_event_skb(skb, skip_sk);\n\telse\n\t\tkfree_skb(skb);\n}\n\nstatic void mesh_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      u8 addr_type, s8 rssi, u32 flags, u8 *eir,\n\t\t\t      u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len,\n\t\t\t      u64 instant)\n{\n\tstruct sk_buff *skb;\n\tstruct mgmt_ev_mesh_device_found *ev;\n\tint i, j;\n\n\tif (!hdev->mesh_ad_types[0])\n\t\tgoto accepted;\n\n\t \n\tif (eir_len > 0) {\n\t\tfor (i = 0; i + 1 < eir_len; i += eir[i] + 1) {\n\t\t\tfor (j = 0; j < sizeof(hdev->mesh_ad_types); j++) {\n\t\t\t\tif (!hdev->mesh_ad_types[j])\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (hdev->mesh_ad_types[j] == eir[i + 1])\n\t\t\t\t\tgoto accepted;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scan_rsp_len > 0) {\n\t\tfor (i = 0; i + 1 < scan_rsp_len; i += scan_rsp[i] + 1) {\n\t\t\tfor (j = 0; j < sizeof(hdev->mesh_ad_types); j++) {\n\t\t\t\tif (!hdev->mesh_ad_types[j])\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (hdev->mesh_ad_types[j] == scan_rsp[i + 1])\n\t\t\t\t\tgoto accepted;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n\naccepted:\n\tskb = mgmt_alloc_skb(hdev, MGMT_EV_MESH_DEVICE_FOUND,\n\t\t\t     sizeof(*ev) + eir_len + scan_rsp_len);\n\tif (!skb)\n\t\treturn;\n\n\tev = skb_put(skb, sizeof(*ev));\n\n\tbacpy(&ev->addr.bdaddr, bdaddr);\n\tev->addr.type = link_to_bdaddr(LE_LINK, addr_type);\n\tev->rssi = rssi;\n\tev->flags = cpu_to_le32(flags);\n\tev->instant = cpu_to_le64(instant);\n\n\tif (eir_len > 0)\n\t\t \n\t\tskb_put_data(skb, eir, eir_len);\n\n\tif (scan_rsp_len > 0)\n\t\t \n\t\tskb_put_data(skb, scan_rsp, scan_rsp_len);\n\n\tev->eir_len = cpu_to_le16(eir_len + scan_rsp_len);\n\n\tmgmt_event_skb(skb, NULL);\n}\n\nvoid mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\n\t\t       u8 addr_type, u8 *dev_class, s8 rssi, u32 flags,\n\t\t       u8 *eir, u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len,\n\t\t       u64 instant)\n{\n\tstruct sk_buff *skb;\n\tstruct mgmt_ev_device_found *ev;\n\tbool report_device = hci_discovery_active(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_MESH) && link_type == LE_LINK)\n\t\tmesh_device_found(hdev, bdaddr, addr_type, rssi, flags,\n\t\t\t\t  eir, eir_len, scan_rsp, scan_rsp_len,\n\t\t\t\t  instant);\n\n\t \n\tif (!hci_discovery_active(hdev)) {\n\t\tif (link_type == ACL_LINK)\n\t\t\treturn;\n\t\tif (link_type == LE_LINK && !list_empty(&hdev->pend_le_reports))\n\t\t\treport_device = true;\n\t\telse if (!hci_is_adv_monitoring(hdev))\n\t\t\treturn;\n\t}\n\n\tif (hdev->discovery.result_filtering) {\n\t\t \n\t\tif (!is_filter_match(hdev, rssi, eir, eir_len, scan_rsp,\n\t\t\t\t     scan_rsp_len))\n\t\t\treturn;\n\t}\n\n\tif (hdev->discovery.limited) {\n\t\t \n\t\tif (dev_class) {\n\t\t\tif (!(dev_class[1] & 0x20))\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tu8 *flags = eir_get_data(eir, eir_len, EIR_FLAGS, NULL);\n\t\t\tif (!flags || !(flags[0] & LE_AD_LIMITED))\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tskb = mgmt_alloc_skb(hdev, MGMT_EV_DEVICE_FOUND,\n\t\t\t     sizeof(*ev) + eir_len + scan_rsp_len + 5);\n\tif (!skb)\n\t\treturn;\n\n\tev = skb_put(skb, sizeof(*ev));\n\n\t \n\tif (rssi == HCI_RSSI_INVALID && !hdev->discovery.report_invalid_rssi &&\n\t    link_type == ACL_LINK)\n\t\trssi = 0;\n\n\tbacpy(&ev->addr.bdaddr, bdaddr);\n\tev->addr.type = link_to_bdaddr(link_type, addr_type);\n\tev->rssi = rssi;\n\tev->flags = cpu_to_le32(flags);\n\n\tif (eir_len > 0)\n\t\t \n\t\tskb_put_data(skb, eir, eir_len);\n\n\tif (dev_class && !eir_get_data(eir, eir_len, EIR_CLASS_OF_DEV, NULL)) {\n\t\tu8 eir_cod[5];\n\n\t\teir_len += eir_append_data(eir_cod, 0, EIR_CLASS_OF_DEV,\n\t\t\t\t\t   dev_class, 3);\n\t\tskb_put_data(skb, eir_cod, sizeof(eir_cod));\n\t}\n\n\tif (scan_rsp_len > 0)\n\t\t \n\t\tskb_put_data(skb, scan_rsp, scan_rsp_len);\n\n\tev->eir_len = cpu_to_le16(eir_len + scan_rsp_len);\n\n\tmgmt_adv_monitor_device_found(hdev, bdaddr, report_device, skb, NULL);\n}\n\nvoid mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\n\t\t      u8 addr_type, s8 rssi, u8 *name, u8 name_len)\n{\n\tstruct sk_buff *skb;\n\tstruct mgmt_ev_device_found *ev;\n\tu16 eir_len = 0;\n\tu32 flags = 0;\n\n\tskb = mgmt_alloc_skb(hdev, MGMT_EV_DEVICE_FOUND,\n\t\t\t     sizeof(*ev) + (name ? eir_precalc_len(name_len) : 0));\n\n\tev = skb_put(skb, sizeof(*ev));\n\tbacpy(&ev->addr.bdaddr, bdaddr);\n\tev->addr.type = link_to_bdaddr(link_type, addr_type);\n\tev->rssi = rssi;\n\n\tif (name)\n\t\teir_len += eir_skb_put_data(skb, EIR_NAME_COMPLETE, name, name_len);\n\telse\n\t\tflags = MGMT_DEV_FOUND_NAME_REQUEST_FAILED;\n\n\tev->eir_len = cpu_to_le16(eir_len);\n\tev->flags = cpu_to_le32(flags);\n\n\tmgmt_event_skb(skb, NULL);\n}\n\nvoid mgmt_discovering(struct hci_dev *hdev, u8 discovering)\n{\n\tstruct mgmt_ev_discovering ev;\n\n\tbt_dev_dbg(hdev, \"discovering %u\", discovering);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = hdev->discovery.type;\n\tev.discovering = discovering;\n\n\tmgmt_event(MGMT_EV_DISCOVERING, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_suspending(struct hci_dev *hdev, u8 state)\n{\n\tstruct mgmt_ev_controller_suspend ev;\n\n\tev.suspend_state = state;\n\tmgmt_event(MGMT_EV_CONTROLLER_SUSPEND, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_resuming(struct hci_dev *hdev, u8 reason, bdaddr_t *bdaddr,\n\t\t   u8 addr_type)\n{\n\tstruct mgmt_ev_controller_resume ev;\n\n\tev.wake_reason = reason;\n\tif (bdaddr) {\n\t\tbacpy(&ev.addr.bdaddr, bdaddr);\n\t\tev.addr.type = addr_type;\n\t} else {\n\t\tmemset(&ev.addr, 0, sizeof(ev.addr));\n\t}\n\n\tmgmt_event(MGMT_EV_CONTROLLER_RESUME, hdev, &ev, sizeof(ev), NULL);\n}\n\nstatic struct hci_mgmt_chan chan = {\n\t.channel\t= HCI_CHANNEL_CONTROL,\n\t.handler_count\t= ARRAY_SIZE(mgmt_handlers),\n\t.handlers\t= mgmt_handlers,\n\t.hdev_init\t= mgmt_init_hdev,\n};\n\nint mgmt_init(void)\n{\n\treturn hci_mgmt_chan_register(&chan);\n}\n\nvoid mgmt_exit(void)\n{\n\thci_mgmt_chan_unregister(&chan);\n}\n\nvoid mgmt_cleanup(struct sock *sk)\n{\n\tstruct mgmt_mesh_tx *mesh_tx;\n\tstruct hci_dev *hdev;\n\n\tread_lock(&hci_dev_list_lock);\n\n\tlist_for_each_entry(hdev, &hci_dev_list, list) {\n\t\tdo {\n\t\t\tmesh_tx = mgmt_mesh_next(hdev, sk);\n\n\t\t\tif (mesh_tx)\n\t\t\t\tmesh_send_complete(hdev, mesh_tx, true);\n\t\t} while (mesh_tx);\n\t}\n\n\tread_unlock(&hci_dev_list_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}