{
  "module_name": "mgmt_util.c",
  "hash_id": "c5e301dabb39cc59bed703a192e0ac018bce9037218af2d7e0ae264064cedf02",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/mgmt_util.c",
  "human_readable_source": " \n\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/hci_mon.h>\n#include <net/bluetooth/mgmt.h>\n\n#include \"mgmt_util.h\"\n\nstatic struct sk_buff *create_monitor_ctrl_event(__le16 index, u32 cookie,\n\t\t\t\t\t\t u16 opcode, u16 len, void *buf)\n{\n\tstruct hci_mon_hdr *hdr;\n\tstruct sk_buff *skb;\n\n\tskb = bt_skb_alloc(6 + len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\tput_unaligned_le32(cookie, skb_put(skb, 4));\n\tput_unaligned_le16(opcode, skb_put(skb, 2));\n\n\tif (buf)\n\t\tskb_put_data(skb, buf, len);\n\n\t__net_timestamp(skb);\n\n\thdr = skb_push(skb, HCI_MON_HDR_SIZE);\n\thdr->opcode = cpu_to_le16(HCI_MON_CTRL_EVENT);\n\thdr->index = index;\n\thdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);\n\n\treturn skb;\n}\n\nstruct sk_buff *mgmt_alloc_skb(struct hci_dev *hdev, u16 opcode,\n\t\t\t       unsigned int size)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(sizeof(struct mgmt_hdr) + size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn skb;\n\n\tskb_reserve(skb, sizeof(struct mgmt_hdr));\n\tbt_cb(skb)->mgmt.hdev = hdev;\n\tbt_cb(skb)->mgmt.opcode = opcode;\n\n\treturn skb;\n}\n\nint mgmt_send_event_skb(unsigned short channel, struct sk_buff *skb, int flag,\n\t\t\tstruct sock *skip_sk)\n{\n\tstruct hci_dev *hdev;\n\tstruct mgmt_hdr *hdr;\n\tint len;\n\n\tif (!skb)\n\t\treturn -EINVAL;\n\n\tlen = skb->len;\n\thdev = bt_cb(skb)->mgmt.hdev;\n\n\t \n\t__net_timestamp(skb);\n\n\t \n\tif (channel == HCI_CHANNEL_CONTROL)\n\t\thci_send_monitor_ctrl_event(hdev, bt_cb(skb)->mgmt.opcode,\n\t\t\t\t\t    skb->data, skb->len,\n\t\t\t\t\t    skb_get_ktime(skb), flag, skip_sk);\n\n\thdr = skb_push(skb, sizeof(*hdr));\n\thdr->opcode = cpu_to_le16(bt_cb(skb)->mgmt.opcode);\n\tif (hdev)\n\t\thdr->index = cpu_to_le16(hdev->id);\n\telse\n\t\thdr->index = cpu_to_le16(MGMT_INDEX_NONE);\n\thdr->len = cpu_to_le16(len);\n\n\thci_send_to_channel(channel, skb, flag, skip_sk);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nint mgmt_send_event(u16 event, struct hci_dev *hdev, unsigned short channel,\n\t\t    void *data, u16 data_len, int flag, struct sock *skip_sk)\n{\n\tstruct sk_buff *skb;\n\n\tskb = mgmt_alloc_skb(hdev, event, data_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (data)\n\t\tskb_put_data(skb, data, data_len);\n\n\treturn mgmt_send_event_skb(channel, skb, flag, skip_sk);\n}\n\nint mgmt_cmd_status(struct sock *sk, u16 index, u16 cmd, u8 status)\n{\n\tstruct sk_buff *skb, *mskb;\n\tstruct mgmt_hdr *hdr;\n\tstruct mgmt_ev_cmd_status *ev;\n\tint err;\n\n\tBT_DBG(\"sock %p, index %u, cmd %u, status %u\", sk, index, cmd, status);\n\n\tskb = alloc_skb(sizeof(*hdr) + sizeof(*ev), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\n\thdr->opcode = cpu_to_le16(MGMT_EV_CMD_STATUS);\n\thdr->index = cpu_to_le16(index);\n\thdr->len = cpu_to_le16(sizeof(*ev));\n\n\tev = skb_put(skb, sizeof(*ev));\n\tev->status = status;\n\tev->opcode = cpu_to_le16(cmd);\n\n\tmskb = create_monitor_ctrl_event(hdr->index, hci_sock_get_cookie(sk),\n\t\t\t\t\t MGMT_EV_CMD_STATUS, sizeof(*ev), ev);\n\tif (mskb)\n\t\tskb->tstamp = mskb->tstamp;\n\telse\n\t\t__net_timestamp(skb);\n\n\terr = sock_queue_rcv_skb(sk, skb);\n\tif (err < 0)\n\t\tkfree_skb(skb);\n\n\tif (mskb) {\n\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, mskb,\n\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\tkfree_skb(mskb);\n\t}\n\n\treturn err;\n}\n\nint mgmt_cmd_complete(struct sock *sk, u16 index, u16 cmd, u8 status,\n\t\t      void *rp, size_t rp_len)\n{\n\tstruct sk_buff *skb, *mskb;\n\tstruct mgmt_hdr *hdr;\n\tstruct mgmt_ev_cmd_complete *ev;\n\tint err;\n\n\tBT_DBG(\"sock %p\", sk);\n\n\tskb = alloc_skb(sizeof(*hdr) + sizeof(*ev) + rp_len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\n\thdr->opcode = cpu_to_le16(MGMT_EV_CMD_COMPLETE);\n\thdr->index = cpu_to_le16(index);\n\thdr->len = cpu_to_le16(sizeof(*ev) + rp_len);\n\n\tev = skb_put(skb, sizeof(*ev) + rp_len);\n\tev->opcode = cpu_to_le16(cmd);\n\tev->status = status;\n\n\tif (rp)\n\t\tmemcpy(ev->data, rp, rp_len);\n\n\tmskb = create_monitor_ctrl_event(hdr->index, hci_sock_get_cookie(sk),\n\t\t\t\t\t MGMT_EV_CMD_COMPLETE,\n\t\t\t\t\t sizeof(*ev) + rp_len, ev);\n\tif (mskb)\n\t\tskb->tstamp = mskb->tstamp;\n\telse\n\t\t__net_timestamp(skb);\n\n\terr = sock_queue_rcv_skb(sk, skb);\n\tif (err < 0)\n\t\tkfree_skb(skb);\n\n\tif (mskb) {\n\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, mskb,\n\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\tkfree_skb(mskb);\n\t}\n\n\treturn err;\n}\n\nstruct mgmt_pending_cmd *mgmt_pending_find(unsigned short channel, u16 opcode,\n\t\t\t\t\t   struct hci_dev *hdev)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\n\t\tif (hci_sock_get_channel(cmd->sk) != channel)\n\t\t\tcontinue;\n\t\tif (cmd->opcode == opcode)\n\t\t\treturn cmd;\n\t}\n\n\treturn NULL;\n}\n\nstruct mgmt_pending_cmd *mgmt_pending_find_data(unsigned short channel,\n\t\t\t\t\t\tu16 opcode,\n\t\t\t\t\t\tstruct hci_dev *hdev,\n\t\t\t\t\t\tconst void *data)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\n\t\tif (cmd->user_data != data)\n\t\t\tcontinue;\n\t\tif (cmd->opcode == opcode)\n\t\t\treturn cmd;\n\t}\n\n\treturn NULL;\n}\n\nvoid mgmt_pending_foreach(u16 opcode, struct hci_dev *hdev,\n\t\t\t  void (*cb)(struct mgmt_pending_cmd *cmd, void *data),\n\t\t\t  void *data)\n{\n\tstruct mgmt_pending_cmd *cmd, *tmp;\n\n\tlist_for_each_entry_safe(cmd, tmp, &hdev->mgmt_pending, list) {\n\t\tif (opcode > 0 && cmd->opcode != opcode)\n\t\t\tcontinue;\n\n\t\tcb(cmd, data);\n\t}\n}\n\nstruct mgmt_pending_cmd *mgmt_pending_new(struct sock *sk, u16 opcode,\n\t\t\t\t\t  struct hci_dev *hdev,\n\t\t\t\t\t  void *data, u16 len)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn NULL;\n\n\tcmd->opcode = opcode;\n\tcmd->index = hdev->id;\n\n\tcmd->param = kmemdup(data, len, GFP_KERNEL);\n\tif (!cmd->param) {\n\t\tkfree(cmd);\n\t\treturn NULL;\n\t}\n\n\tcmd->param_len = len;\n\n\tcmd->sk = sk;\n\tsock_hold(sk);\n\n\treturn cmd;\n}\n\nstruct mgmt_pending_cmd *mgmt_pending_add(struct sock *sk, u16 opcode,\n\t\t\t\t\t  struct hci_dev *hdev,\n\t\t\t\t\t  void *data, u16 len)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tcmd = mgmt_pending_new(sk, opcode, hdev, data, len);\n\tif (!cmd)\n\t\treturn NULL;\n\n\tlist_add_tail(&cmd->list, &hdev->mgmt_pending);\n\n\treturn cmd;\n}\n\nvoid mgmt_pending_free(struct mgmt_pending_cmd *cmd)\n{\n\tsock_put(cmd->sk);\n\tkfree(cmd->param);\n\tkfree(cmd);\n}\n\nvoid mgmt_pending_remove(struct mgmt_pending_cmd *cmd)\n{\n\tlist_del(&cmd->list);\n\tmgmt_pending_free(cmd);\n}\n\nvoid mgmt_mesh_foreach(struct hci_dev *hdev,\n\t\t       void (*cb)(struct mgmt_mesh_tx *mesh_tx, void *data),\n\t\t       void *data, struct sock *sk)\n{\n\tstruct mgmt_mesh_tx *mesh_tx, *tmp;\n\n\tlist_for_each_entry_safe(mesh_tx, tmp, &hdev->mgmt_pending, list) {\n\t\tif (!sk || mesh_tx->sk == sk)\n\t\t\tcb(mesh_tx, data);\n\t}\n}\n\nstruct mgmt_mesh_tx *mgmt_mesh_next(struct hci_dev *hdev, struct sock *sk)\n{\n\tstruct mgmt_mesh_tx *mesh_tx;\n\n\tif (list_empty(&hdev->mesh_pending))\n\t\treturn NULL;\n\n\tlist_for_each_entry(mesh_tx, &hdev->mesh_pending, list) {\n\t\tif (!sk || mesh_tx->sk == sk)\n\t\t\treturn mesh_tx;\n\t}\n\n\treturn NULL;\n}\n\nstruct mgmt_mesh_tx *mgmt_mesh_find(struct hci_dev *hdev, u8 handle)\n{\n\tstruct mgmt_mesh_tx *mesh_tx;\n\n\tif (list_empty(&hdev->mesh_pending))\n\t\treturn NULL;\n\n\tlist_for_each_entry(mesh_tx, &hdev->mesh_pending, list) {\n\t\tif (mesh_tx->handle == handle)\n\t\t\treturn mesh_tx;\n\t}\n\n\treturn NULL;\n}\n\nstruct mgmt_mesh_tx *mgmt_mesh_add(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   void *data, u16 len)\n{\n\tstruct mgmt_mesh_tx *mesh_tx;\n\n\tmesh_tx = kzalloc(sizeof(*mesh_tx), GFP_KERNEL);\n\tif (!mesh_tx)\n\t\treturn NULL;\n\n\thdev->mesh_send_ref++;\n\tif (!hdev->mesh_send_ref)\n\t\thdev->mesh_send_ref++;\n\n\tmesh_tx->handle = hdev->mesh_send_ref;\n\tmesh_tx->index = hdev->id;\n\tmemcpy(mesh_tx->param, data, len);\n\tmesh_tx->param_len = len;\n\tmesh_tx->sk = sk;\n\tsock_hold(sk);\n\n\tlist_add_tail(&mesh_tx->list, &hdev->mesh_pending);\n\n\treturn mesh_tx;\n}\n\nvoid mgmt_mesh_remove(struct mgmt_mesh_tx *mesh_tx)\n{\n\tlist_del(&mesh_tx->list);\n\tsock_put(mesh_tx->sk);\n\tkfree(mesh_tx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}