{
  "module_name": "amp.c",
  "hash_id": "e92601fade37bf76c1997c7d946e9bd911f4ad9741831abb66195be045464c15",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/amp.c",
  "human_readable_source": "\n \n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci.h>\n#include <net/bluetooth/hci_core.h>\n#include <crypto/hash.h>\n\n#include \"hci_request.h\"\n#include \"a2mp.h\"\n#include \"amp.h\"\n\n \nvoid amp_ctrl_get(struct amp_ctrl *ctrl)\n{\n\tBT_DBG(\"ctrl %p orig refcnt %d\", ctrl,\n\t       kref_read(&ctrl->kref));\n\n\tkref_get(&ctrl->kref);\n}\n\nstatic void amp_ctrl_destroy(struct kref *kref)\n{\n\tstruct amp_ctrl *ctrl = container_of(kref, struct amp_ctrl, kref);\n\n\tBT_DBG(\"ctrl %p\", ctrl);\n\n\tkfree(ctrl->assoc);\n\tkfree(ctrl);\n}\n\nint amp_ctrl_put(struct amp_ctrl *ctrl)\n{\n\tBT_DBG(\"ctrl %p orig refcnt %d\", ctrl,\n\t       kref_read(&ctrl->kref));\n\n\treturn kref_put(&ctrl->kref, &amp_ctrl_destroy);\n}\n\nstruct amp_ctrl *amp_ctrl_add(struct amp_mgr *mgr, u8 id)\n{\n\tstruct amp_ctrl *ctrl;\n\n\tctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn NULL;\n\n\tkref_init(&ctrl->kref);\n\tctrl->id = id;\n\n\tmutex_lock(&mgr->amp_ctrls_lock);\n\tlist_add(&ctrl->list, &mgr->amp_ctrls);\n\tmutex_unlock(&mgr->amp_ctrls_lock);\n\n\tBT_DBG(\"mgr %p ctrl %p\", mgr, ctrl);\n\n\treturn ctrl;\n}\n\nvoid amp_ctrl_list_flush(struct amp_mgr *mgr)\n{\n\tstruct amp_ctrl *ctrl, *n;\n\n\tBT_DBG(\"mgr %p\", mgr);\n\n\tmutex_lock(&mgr->amp_ctrls_lock);\n\tlist_for_each_entry_safe(ctrl, n, &mgr->amp_ctrls, list) {\n\t\tlist_del(&ctrl->list);\n\t\tamp_ctrl_put(ctrl);\n\t}\n\tmutex_unlock(&mgr->amp_ctrls_lock);\n}\n\nstruct amp_ctrl *amp_ctrl_lookup(struct amp_mgr *mgr, u8 id)\n{\n\tstruct amp_ctrl *ctrl;\n\n\tBT_DBG(\"mgr %p id %u\", mgr, id);\n\n\tmutex_lock(&mgr->amp_ctrls_lock);\n\tlist_for_each_entry(ctrl, &mgr->amp_ctrls, list) {\n\t\tif (ctrl->id == id) {\n\t\t\tamp_ctrl_get(ctrl);\n\t\t\tmutex_unlock(&mgr->amp_ctrls_lock);\n\t\t\treturn ctrl;\n\t\t}\n\t}\n\tmutex_unlock(&mgr->amp_ctrls_lock);\n\n\treturn NULL;\n}\n\n \nstatic u8 __next_handle(struct amp_mgr *mgr)\n{\n\tif (++mgr->handle == 0)\n\t\tmgr->handle = 1;\n\n\treturn mgr->handle;\n}\n\nstruct hci_conn *phylink_add(struct hci_dev *hdev, struct amp_mgr *mgr,\n\t\t\t     u8 remote_id, bool out)\n{\n\tbdaddr_t *dst = &mgr->l2cap_conn->hcon->dst;\n\tstruct hci_conn *hcon;\n\tu8 role = out ? HCI_ROLE_MASTER : HCI_ROLE_SLAVE;\n\n\thcon = hci_conn_add(hdev, AMP_LINK, dst, role, __next_handle(mgr));\n\tif (!hcon)\n\t\treturn NULL;\n\n\tBT_DBG(\"hcon %p dst %pMR\", hcon, dst);\n\n\thcon->state = BT_CONNECT;\n\thcon->attempt++;\n\thcon->remote_id = remote_id;\n\thcon->amp_mgr = amp_mgr_get(mgr);\n\n\treturn hcon;\n}\n\n \nstatic int hmac_sha256(u8 *key, u8 ksize, char *plaintext, u8 psize, u8 *output)\n{\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *shash;\n\tint ret;\n\n\tif (!ksize)\n\t\treturn -EINVAL;\n\n\ttfm = crypto_alloc_shash(\"hmac(sha256)\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tBT_DBG(\"crypto_alloc_ahash failed: err %ld\", PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\tret = crypto_shash_setkey(tfm, key, ksize);\n\tif (ret) {\n\t\tBT_DBG(\"crypto_ahash_setkey failed: err %d\", ret);\n\t\tgoto failed;\n\t}\n\n\tshash = kzalloc(sizeof(*shash) + crypto_shash_descsize(tfm),\n\t\t\tGFP_KERNEL);\n\tif (!shash) {\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tshash->tfm = tfm;\n\n\tret = crypto_shash_digest(shash, plaintext, psize, output);\n\n\tkfree(shash);\n\nfailed:\n\tcrypto_free_shash(tfm);\n\treturn ret;\n}\n\nint phylink_gen_key(struct hci_conn *conn, u8 *data, u8 *len, u8 *type)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct link_key *key;\n\tu8 keybuf[HCI_AMP_LINK_KEY_SIZE];\n\tu8 gamp_key[HCI_AMP_LINK_KEY_SIZE];\n\tint err;\n\n\tif (!hci_conn_check_link_mode(conn))\n\t\treturn -EACCES;\n\n\tBT_DBG(\"conn %p key_type %d\", conn, conn->key_type);\n\n\t \n\tif (conn->key_type < 3) {\n\t\tbt_dev_err(hdev, \"legacy key type %u\", conn->key_type);\n\t\treturn -EACCES;\n\t}\n\n\t*type = conn->key_type;\n\t*len = HCI_AMP_LINK_KEY_SIZE;\n\n\tkey = hci_find_link_key(hdev, &conn->dst);\n\tif (!key) {\n\t\tBT_DBG(\"No Link key for conn %p dst %pMR\", conn, &conn->dst);\n\t\treturn -EACCES;\n\t}\n\n\t \n\tmemcpy(&keybuf[0], key->val, HCI_LINK_KEY_SIZE);\n\tmemcpy(&keybuf[HCI_LINK_KEY_SIZE], key->val, HCI_LINK_KEY_SIZE);\n\n\t \n\terr = hmac_sha256(keybuf, HCI_AMP_LINK_KEY_SIZE, \"gamp\", 4, gamp_key);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"could not derive Generic AMP Key: err %d\", err);\n\t\treturn err;\n\t}\n\n\tif (conn->key_type == HCI_LK_DEBUG_COMBINATION) {\n\t\tBT_DBG(\"Use Generic AMP Key (gamp)\");\n\t\tmemcpy(data, gamp_key, HCI_AMP_LINK_KEY_SIZE);\n\t\treturn err;\n\t}\n\n\t \n\treturn hmac_sha256(gamp_key, HCI_AMP_LINK_KEY_SIZE, \"802b\", 4, data);\n}\n\nstatic void read_local_amp_assoc_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t\t  u16 opcode, struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_amp_assoc *rp = (void *)skb->data;\n\tstruct amp_assoc *assoc = &hdev->loc_assoc;\n\tsize_t rem_len, frag_len;\n\n\tBT_DBG(\"%s status 0x%2.2x\", hdev->name, rp->status);\n\n\tif (rp->status)\n\t\tgoto send_rsp;\n\n\tfrag_len = skb->len - sizeof(*rp);\n\trem_len = __le16_to_cpu(rp->rem_len);\n\n\tif (rem_len > frag_len) {\n\t\tBT_DBG(\"frag_len %zu rem_len %zu\", frag_len, rem_len);\n\n\t\tmemcpy(assoc->data + assoc->offset, rp->frag, frag_len);\n\t\tassoc->offset += frag_len;\n\n\t\t \n\t\tamp_read_loc_assoc_frag(hdev, rp->phy_handle);\n\n\t\treturn;\n\t}\n\n\tmemcpy(assoc->data + assoc->offset, rp->frag, rem_len);\n\tassoc->len = assoc->offset + rem_len;\n\tassoc->offset = 0;\n\nsend_rsp:\n\t \n\ta2mp_send_getampassoc_rsp(hdev, rp->status);\n\ta2mp_send_create_phy_link_req(hdev, rp->status);\n}\n\nvoid amp_read_loc_assoc_frag(struct hci_dev *hdev, u8 phy_handle)\n{\n\tstruct hci_cp_read_local_amp_assoc cp;\n\tstruct amp_assoc *loc_assoc = &hdev->loc_assoc;\n\tstruct hci_request req;\n\tint err;\n\n\tBT_DBG(\"%s handle %u\", hdev->name, phy_handle);\n\n\tcp.phy_handle = phy_handle;\n\tcp.max_len = cpu_to_le16(hdev->amp_assoc_size);\n\tcp.len_so_far = cpu_to_le16(loc_assoc->offset);\n\n\thci_req_init(&req, hdev);\n\thci_req_add(&req, HCI_OP_READ_LOCAL_AMP_ASSOC, sizeof(cp), &cp);\n\terr = hci_req_run_skb(&req, read_local_amp_assoc_complete);\n\tif (err < 0)\n\t\ta2mp_send_getampassoc_rsp(hdev, A2MP_STATUS_INVALID_CTRL_ID);\n}\n\nvoid amp_read_loc_assoc(struct hci_dev *hdev, struct amp_mgr *mgr)\n{\n\tstruct hci_cp_read_local_amp_assoc cp;\n\tstruct hci_request req;\n\tint err;\n\n\tmemset(&hdev->loc_assoc, 0, sizeof(struct amp_assoc));\n\tmemset(&cp, 0, sizeof(cp));\n\n\tcp.max_len = cpu_to_le16(hdev->amp_assoc_size);\n\n\tset_bit(READ_LOC_AMP_ASSOC, &mgr->state);\n\thci_req_init(&req, hdev);\n\thci_req_add(&req, HCI_OP_READ_LOCAL_AMP_ASSOC, sizeof(cp), &cp);\n\terr = hci_req_run_skb(&req, read_local_amp_assoc_complete);\n\tif (err < 0)\n\t\ta2mp_send_getampassoc_rsp(hdev, A2MP_STATUS_INVALID_CTRL_ID);\n}\n\nvoid amp_read_loc_assoc_final_data(struct hci_dev *hdev,\n\t\t\t\t   struct hci_conn *hcon)\n{\n\tstruct hci_cp_read_local_amp_assoc cp;\n\tstruct amp_mgr *mgr = hcon->amp_mgr;\n\tstruct hci_request req;\n\tint err;\n\n\tif (!mgr)\n\t\treturn;\n\n\tcp.phy_handle = hcon->handle;\n\tcp.len_so_far = cpu_to_le16(0);\n\tcp.max_len = cpu_to_le16(hdev->amp_assoc_size);\n\n\tset_bit(READ_LOC_AMP_ASSOC_FINAL, &mgr->state);\n\n\t \n\thci_req_init(&req, hdev);\n\thci_req_add(&req, HCI_OP_READ_LOCAL_AMP_ASSOC, sizeof(cp), &cp);\n\terr = hci_req_run_skb(&req, read_local_amp_assoc_complete);\n\tif (err < 0)\n\t\ta2mp_send_getampassoc_rsp(hdev, A2MP_STATUS_INVALID_CTRL_ID);\n}\n\nstatic void write_remote_amp_assoc_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t\t    u16 opcode, struct sk_buff *skb)\n{\n\tstruct hci_rp_write_remote_amp_assoc *rp = (void *)skb->data;\n\n\tBT_DBG(\"%s status 0x%2.2x phy_handle 0x%2.2x\",\n\t       hdev->name, rp->status, rp->phy_handle);\n\n\tif (rp->status)\n\t\treturn;\n\n\tamp_write_rem_assoc_continue(hdev, rp->phy_handle);\n}\n\n \nstatic bool amp_write_rem_assoc_frag(struct hci_dev *hdev,\n\t\t\t\t     struct hci_conn *hcon)\n{\n\tstruct hci_cp_write_remote_amp_assoc *cp;\n\tstruct amp_mgr *mgr = hcon->amp_mgr;\n\tstruct amp_ctrl *ctrl;\n\tstruct hci_request req;\n\tu16 frag_len, len;\n\n\tctrl = amp_ctrl_lookup(mgr, hcon->remote_id);\n\tif (!ctrl)\n\t\treturn false;\n\n\tif (!ctrl->assoc_rem_len) {\n\t\tBT_DBG(\"all fragments are written\");\n\t\tctrl->assoc_rem_len = ctrl->assoc_len;\n\t\tctrl->assoc_len_so_far = 0;\n\n\t\tamp_ctrl_put(ctrl);\n\t\treturn true;\n\t}\n\n\tfrag_len = min_t(u16, 248, ctrl->assoc_rem_len);\n\tlen = frag_len + sizeof(*cp);\n\n\tcp = kzalloc(len, GFP_KERNEL);\n\tif (!cp) {\n\t\tamp_ctrl_put(ctrl);\n\t\treturn false;\n\t}\n\n\tBT_DBG(\"hcon %p ctrl %p frag_len %u assoc_len %u rem_len %u\",\n\t       hcon, ctrl, frag_len, ctrl->assoc_len, ctrl->assoc_rem_len);\n\n\tcp->phy_handle = hcon->handle;\n\tcp->len_so_far = cpu_to_le16(ctrl->assoc_len_so_far);\n\tcp->rem_len = cpu_to_le16(ctrl->assoc_rem_len);\n\tmemcpy(cp->frag, ctrl->assoc, frag_len);\n\n\tctrl->assoc_len_so_far += frag_len;\n\tctrl->assoc_rem_len -= frag_len;\n\n\tamp_ctrl_put(ctrl);\n\n\thci_req_init(&req, hdev);\n\thci_req_add(&req, HCI_OP_WRITE_REMOTE_AMP_ASSOC, len, cp);\n\thci_req_run_skb(&req, write_remote_amp_assoc_complete);\n\n\tkfree(cp);\n\n\treturn false;\n}\n\nvoid amp_write_rem_assoc_continue(struct hci_dev *hdev, u8 handle)\n{\n\tstruct hci_conn *hcon;\n\n\tBT_DBG(\"%s phy handle 0x%2.2x\", hdev->name, handle);\n\n\thcon = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (!hcon)\n\t\treturn;\n\n\t \n\tif (amp_write_rem_assoc_frag(hdev, hcon))\n\t\ta2mp_send_create_phy_link_rsp(hdev, 0);\n}\n\nvoid amp_write_remote_assoc(struct hci_dev *hdev, u8 handle)\n{\n\tstruct hci_conn *hcon;\n\n\tBT_DBG(\"%s phy handle 0x%2.2x\", hdev->name, handle);\n\n\thcon = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (!hcon)\n\t\treturn;\n\n\tBT_DBG(\"%s phy handle 0x%2.2x hcon %p\", hdev->name, handle, hcon);\n\n\tamp_write_rem_assoc_frag(hdev, hcon);\n}\n\nstatic void create_phylink_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t    u16 opcode)\n{\n\tstruct hci_cp_create_phy_link *cp;\n\n\tBT_DBG(\"%s status 0x%2.2x\", hdev->name, status);\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_CREATE_PHY_LINK);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tif (status) {\n\t\tstruct hci_conn *hcon;\n\n\t\thcon = hci_conn_hash_lookup_handle(hdev, cp->phy_handle);\n\t\tif (hcon)\n\t\t\thci_conn_del(hcon);\n\t} else {\n\t\tamp_write_remote_assoc(hdev, cp->phy_handle);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nvoid amp_create_phylink(struct hci_dev *hdev, struct amp_mgr *mgr,\n\t\t\tstruct hci_conn *hcon)\n{\n\tstruct hci_cp_create_phy_link cp;\n\tstruct hci_request req;\n\n\tcp.phy_handle = hcon->handle;\n\n\tBT_DBG(\"%s hcon %p phy handle 0x%2.2x\", hdev->name, hcon,\n\t       hcon->handle);\n\n\tif (phylink_gen_key(mgr->l2cap_conn->hcon, cp.key, &cp.key_len,\n\t\t\t    &cp.key_type)) {\n\t\tBT_DBG(\"Cannot create link key\");\n\t\treturn;\n\t}\n\n\thci_req_init(&req, hdev);\n\thci_req_add(&req, HCI_OP_CREATE_PHY_LINK, sizeof(cp), &cp);\n\thci_req_run(&req, create_phylink_complete);\n}\n\nstatic void accept_phylink_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t    u16 opcode)\n{\n\tstruct hci_cp_accept_phy_link *cp;\n\n\tBT_DBG(\"%s status 0x%2.2x\", hdev->name, status);\n\n\tif (status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_ACCEPT_PHY_LINK);\n\tif (!cp)\n\t\treturn;\n\n\tamp_write_remote_assoc(hdev, cp->phy_handle);\n}\n\nvoid amp_accept_phylink(struct hci_dev *hdev, struct amp_mgr *mgr,\n\t\t\tstruct hci_conn *hcon)\n{\n\tstruct hci_cp_accept_phy_link cp;\n\tstruct hci_request req;\n\n\tcp.phy_handle = hcon->handle;\n\n\tBT_DBG(\"%s hcon %p phy handle 0x%2.2x\", hdev->name, hcon,\n\t       hcon->handle);\n\n\tif (phylink_gen_key(mgr->l2cap_conn->hcon, cp.key, &cp.key_len,\n\t\t\t    &cp.key_type)) {\n\t\tBT_DBG(\"Cannot create link key\");\n\t\treturn;\n\t}\n\n\thci_req_init(&req, hdev);\n\thci_req_add(&req, HCI_OP_ACCEPT_PHY_LINK, sizeof(cp), &cp);\n\thci_req_run(&req, accept_phylink_complete);\n}\n\nvoid amp_physical_cfm(struct hci_conn *bredr_hcon, struct hci_conn *hs_hcon)\n{\n\tstruct hci_dev *bredr_hdev = hci_dev_hold(bredr_hcon->hdev);\n\tstruct amp_mgr *mgr = hs_hcon->amp_mgr;\n\tstruct l2cap_chan *bredr_chan;\n\n\tBT_DBG(\"bredr_hcon %p hs_hcon %p mgr %p\", bredr_hcon, hs_hcon, mgr);\n\n\tif (!bredr_hdev || !mgr || !mgr->bredr_chan)\n\t\treturn;\n\n\tbredr_chan = mgr->bredr_chan;\n\n\tl2cap_chan_lock(bredr_chan);\n\n\tset_bit(FLAG_EFS_ENABLE, &bredr_chan->flags);\n\tbredr_chan->remote_amp_id = hs_hcon->remote_id;\n\tbredr_chan->local_amp_id = hs_hcon->hdev->id;\n\tbredr_chan->hs_hcon = hs_hcon;\n\tbredr_chan->conn->mtu = hs_hcon->hdev->block_mtu;\n\n\t__l2cap_physical_cfm(bredr_chan, 0);\n\n\tl2cap_chan_unlock(bredr_chan);\n\n\thci_dev_put(bredr_hdev);\n}\n\nvoid amp_create_logical_link(struct l2cap_chan *chan)\n{\n\tstruct hci_conn *hs_hcon = chan->hs_hcon;\n\tstruct hci_cp_create_accept_logical_link cp;\n\tstruct hci_dev *hdev;\n\n\tBT_DBG(\"chan %p hs_hcon %p dst %pMR\", chan, hs_hcon,\n\t       &chan->conn->hcon->dst);\n\n\tif (!hs_hcon)\n\t\treturn;\n\n\thdev = hci_dev_hold(chan->hs_hcon->hdev);\n\tif (!hdev)\n\t\treturn;\n\n\tcp.phy_handle = hs_hcon->handle;\n\n\tcp.tx_flow_spec.id = chan->local_id;\n\tcp.tx_flow_spec.stype = chan->local_stype;\n\tcp.tx_flow_spec.msdu = cpu_to_le16(chan->local_msdu);\n\tcp.tx_flow_spec.sdu_itime = cpu_to_le32(chan->local_sdu_itime);\n\tcp.tx_flow_spec.acc_lat = cpu_to_le32(chan->local_acc_lat);\n\tcp.tx_flow_spec.flush_to = cpu_to_le32(chan->local_flush_to);\n\n\tcp.rx_flow_spec.id = chan->remote_id;\n\tcp.rx_flow_spec.stype = chan->remote_stype;\n\tcp.rx_flow_spec.msdu = cpu_to_le16(chan->remote_msdu);\n\tcp.rx_flow_spec.sdu_itime = cpu_to_le32(chan->remote_sdu_itime);\n\tcp.rx_flow_spec.acc_lat = cpu_to_le32(chan->remote_acc_lat);\n\tcp.rx_flow_spec.flush_to = cpu_to_le32(chan->remote_flush_to);\n\n\tif (hs_hcon->out)\n\t\thci_send_cmd(hdev, HCI_OP_CREATE_LOGICAL_LINK, sizeof(cp),\n\t\t\t     &cp);\n\telse\n\t\thci_send_cmd(hdev, HCI_OP_ACCEPT_LOGICAL_LINK, sizeof(cp),\n\t\t\t     &cp);\n\n\thci_dev_put(hdev);\n}\n\nvoid amp_disconnect_logical_link(struct hci_chan *hchan)\n{\n\tstruct hci_conn *hcon = hchan->conn;\n\tstruct hci_cp_disconn_logical_link cp;\n\n\tif (hcon->state != BT_CONNECTED) {\n\t\tBT_DBG(\"hchan %p not connected\", hchan);\n\t\treturn;\n\t}\n\n\tcp.log_handle = cpu_to_le16(hchan->handle);\n\thci_send_cmd(hcon->hdev, HCI_OP_DISCONN_LOGICAL_LINK, sizeof(cp), &cp);\n}\n\nvoid amp_destroy_logical_link(struct hci_chan *hchan, u8 reason)\n{\n\tBT_DBG(\"hchan %p\", hchan);\n\n\thci_chan_del(hchan);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}