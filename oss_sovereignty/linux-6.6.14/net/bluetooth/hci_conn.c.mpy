{
  "module_name": "hci_conn.c",
  "hash_id": "e88f981ce9588350a183797890f17d6c02c0a856d771780f6540c301006a3fa7",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/hci_conn.c",
  "human_readable_source": " \n\n \n\n#include <linux/export.h>\n#include <linux/debugfs.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n#include <net/bluetooth/iso.h>\n#include <net/bluetooth/mgmt.h>\n\n#include \"hci_request.h\"\n#include \"smp.h\"\n#include \"a2mp.h\"\n#include \"eir.h\"\n\nstruct sco_param {\n\tu16 pkt_type;\n\tu16 max_latency;\n\tu8  retrans_effort;\n};\n\nstruct conn_handle_t {\n\tstruct hci_conn *conn;\n\t__u16 handle;\n};\n\nstatic const struct sco_param esco_param_cvsd[] = {\n\t{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000a,\t0x01 },  \n\t{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x0007,\t0x01 },  \n\t{ EDR_ESCO_MASK | ESCO_EV3,   0x0007,\t0x01 },  \n\t{ EDR_ESCO_MASK | ESCO_HV3,   0xffff,\t0x01 },  \n\t{ EDR_ESCO_MASK | ESCO_HV1,   0xffff,\t0x01 },  \n};\n\nstatic const struct sco_param sco_param_cvsd[] = {\n\t{ EDR_ESCO_MASK | ESCO_HV3,   0xffff,\t0xff },  \n\t{ EDR_ESCO_MASK | ESCO_HV1,   0xffff,\t0xff },  \n};\n\nstatic const struct sco_param esco_param_msbc[] = {\n\t{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000d,\t0x02 },  \n\t{ EDR_ESCO_MASK | ESCO_EV3,   0x0008,\t0x02 },  \n};\n\n \nstatic void hci_connect_le_scan_cleanup(struct hci_conn *conn, u8 status)\n{\n\tstruct hci_conn_params *params;\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct smp_irk *irk;\n\tbdaddr_t *bdaddr;\n\tu8 bdaddr_type;\n\n\tbdaddr = &conn->dst;\n\tbdaddr_type = conn->dst_type;\n\n\t \n\tirk = hci_get_irk(hdev, bdaddr, bdaddr_type);\n\tif (irk) {\n\t\tbdaddr = &irk->bdaddr;\n\t\tbdaddr_type = irk->addr_type;\n\t}\n\n\tparams = hci_pend_le_action_lookup(&hdev->pend_le_conns, bdaddr,\n\t\t\t\t\t   bdaddr_type);\n\tif (!params)\n\t\treturn;\n\n\tif (params->conn) {\n\t\thci_conn_drop(params->conn);\n\t\thci_conn_put(params->conn);\n\t\tparams->conn = NULL;\n\t}\n\n\tif (!params->explicit_connect)\n\t\treturn;\n\n\t \n\tif (status && status != HCI_ERROR_UNKNOWN_CONN_ID)\n\t\tmgmt_connect_failed(hdev, &conn->dst, conn->type,\n\t\t\t\t    conn->dst_type, status);\n\n\t \n\tparams->explicit_connect = false;\n\n\thci_pend_le_list_del_init(params);\n\n\tswitch (params->auto_connect) {\n\tcase HCI_AUTO_CONN_EXPLICIT:\n\t\thci_conn_params_del(hdev, bdaddr, bdaddr_type);\n\t\t \n\t\treturn;\n\tcase HCI_AUTO_CONN_DIRECT:\n\tcase HCI_AUTO_CONN_ALWAYS:\n\t\thci_pend_le_list_add(params, &hdev->pend_le_conns);\n\t\tbreak;\n\tcase HCI_AUTO_CONN_REPORT:\n\t\thci_pend_le_list_add(params, &hdev->pend_le_reports);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\thci_update_passive_scan(hdev);\n}\n\nstatic void hci_conn_cleanup(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tif (test_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags))\n\t\thci_conn_params_del(conn->hdev, &conn->dst, conn->dst_type);\n\n\tif (test_and_clear_bit(HCI_CONN_FLUSH_KEY, &conn->flags))\n\t\thci_remove_link_key(hdev, &conn->dst);\n\n\thci_chan_list_flush(conn);\n\n\thci_conn_hash_del(hdev, conn);\n\n\tif (HCI_CONN_HANDLE_UNSET(conn->handle))\n\t\tida_free(&hdev->unset_handle_ida, conn->handle);\n\n\tif (conn->cleanup)\n\t\tconn->cleanup(conn);\n\n\tif (conn->type == SCO_LINK || conn->type == ESCO_LINK) {\n\t\tswitch (conn->setting & SCO_AIRMODE_MASK) {\n\t\tcase SCO_AIRMODE_CVSD:\n\t\tcase SCO_AIRMODE_TRANSP:\n\t\t\tif (hdev->notify)\n\t\t\t\thdev->notify(hdev, HCI_NOTIFY_DISABLE_SCO);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (hdev->notify)\n\t\t\thdev->notify(hdev, HCI_NOTIFY_CONN_DEL);\n\t}\n\n\tdebugfs_remove_recursive(conn->debugfs);\n\n\thci_conn_del_sysfs(conn);\n\n\thci_dev_put(hdev);\n}\n\nstatic void hci_acl_create_connection(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct inquiry_entry *ie;\n\tstruct hci_cp_create_conn cp;\n\n\tBT_DBG(\"hcon %p\", conn);\n\n\t \n\tif (test_bit(HCI_INQUIRY, &hdev->flags)) {\n\t\t \n\t\tconn->state = BT_CONNECT2;\n\t\thci_send_cmd(hdev, HCI_OP_INQUIRY_CANCEL, 0, NULL);\n\t\treturn;\n\t}\n\n\tconn->state = BT_CONNECT;\n\tconn->out = true;\n\tconn->role = HCI_ROLE_MASTER;\n\n\tconn->attempt++;\n\n\tconn->link_policy = hdev->link_policy;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.bdaddr, &conn->dst);\n\tcp.pscan_rep_mode = 0x02;\n\n\tie = hci_inquiry_cache_lookup(hdev, &conn->dst);\n\tif (ie) {\n\t\tif (inquiry_entry_age(ie) <= INQUIRY_ENTRY_AGE_MAX) {\n\t\t\tcp.pscan_rep_mode = ie->data.pscan_rep_mode;\n\t\t\tcp.pscan_mode     = ie->data.pscan_mode;\n\t\t\tcp.clock_offset   = ie->data.clock_offset |\n\t\t\t\t\t    cpu_to_le16(0x8000);\n\t\t}\n\n\t\tmemcpy(conn->dev_class, ie->data.dev_class, 3);\n\t}\n\n\tcp.pkt_type = cpu_to_le16(conn->pkt_type);\n\tif (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))\n\t\tcp.role_switch = 0x01;\n\telse\n\t\tcp.role_switch = 0x00;\n\n\thci_send_cmd(hdev, HCI_OP_CREATE_CONN, sizeof(cp), &cp);\n}\n\nint hci_disconnect(struct hci_conn *conn, __u8 reason)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\n\t \n\tif (conn->type == ACL_LINK && conn->role == HCI_ROLE_MASTER &&\n\t    (conn->state == BT_CONNECTED || conn->state == BT_CONFIG)) {\n\t\tstruct hci_dev *hdev = conn->hdev;\n\t\tstruct hci_cp_read_clock_offset clkoff_cp;\n\n\t\tclkoff_cp.handle = cpu_to_le16(conn->handle);\n\t\thci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET, sizeof(clkoff_cp),\n\t\t\t     &clkoff_cp);\n\t}\n\n\treturn hci_abort_conn(conn, reason);\n}\n\nstatic void hci_add_sco(struct hci_conn *conn, __u16 handle)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct hci_cp_add_sco cp;\n\n\tBT_DBG(\"hcon %p\", conn);\n\n\tconn->state = BT_CONNECT;\n\tconn->out = true;\n\n\tconn->attempt++;\n\n\tcp.handle   = cpu_to_le16(handle);\n\tcp.pkt_type = cpu_to_le16(conn->pkt_type);\n\n\thci_send_cmd(hdev, HCI_OP_ADD_SCO, sizeof(cp), &cp);\n}\n\nstatic bool find_next_esco_param(struct hci_conn *conn,\n\t\t\t\t const struct sco_param *esco_param, int size)\n{\n\tif (!conn->parent)\n\t\treturn false;\n\n\tfor (; conn->attempt <= size; conn->attempt++) {\n\t\tif (lmp_esco_2m_capable(conn->parent) ||\n\t\t    (esco_param[conn->attempt - 1].pkt_type & ESCO_2EV3))\n\t\t\tbreak;\n\t\tBT_DBG(\"hcon %p skipped attempt %d, eSCO 2M not supported\",\n\t\t       conn, conn->attempt);\n\t}\n\n\treturn conn->attempt <= size;\n}\n\nstatic int configure_datapath_sync(struct hci_dev *hdev, struct bt_codec *codec)\n{\n\tint err;\n\t__u8 vnd_len, *vnd_data = NULL;\n\tstruct hci_op_configure_data_path *cmd = NULL;\n\n\terr = hdev->get_codec_config_data(hdev, ESCO_LINK, codec, &vnd_len,\n\t\t\t\t\t  &vnd_data);\n\tif (err < 0)\n\t\tgoto error;\n\n\tcmd = kzalloc(sizeof(*cmd) + vnd_len, GFP_KERNEL);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\terr = hdev->get_data_path_id(hdev, &cmd->data_path_id);\n\tif (err < 0)\n\t\tgoto error;\n\n\tcmd->vnd_len = vnd_len;\n\tmemcpy(cmd->vnd_data, vnd_data, vnd_len);\n\n\tcmd->direction = 0x00;\n\t__hci_cmd_sync_status(hdev, HCI_CONFIGURE_DATA_PATH,\n\t\t\t      sizeof(*cmd) + vnd_len, cmd, HCI_CMD_TIMEOUT);\n\n\tcmd->direction = 0x01;\n\terr = __hci_cmd_sync_status(hdev, HCI_CONFIGURE_DATA_PATH,\n\t\t\t\t    sizeof(*cmd) + vnd_len, cmd,\n\t\t\t\t    HCI_CMD_TIMEOUT);\nerror:\n\n\tkfree(cmd);\n\tkfree(vnd_data);\n\treturn err;\n}\n\nstatic int hci_enhanced_setup_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct conn_handle_t *conn_handle = data;\n\tstruct hci_conn *conn = conn_handle->conn;\n\t__u16 handle = conn_handle->handle;\n\tstruct hci_cp_enhanced_setup_sync_conn cp;\n\tconst struct sco_param *param;\n\n\tkfree(conn_handle);\n\n\tbt_dev_dbg(hdev, \"hcon %p\", conn);\n\n\t \n\tif (conn->codec.data_path)\n\t\tconfigure_datapath_sync(hdev, &conn->codec);\n\n\tconn->state = BT_CONNECT;\n\tconn->out = true;\n\n\tconn->attempt++;\n\n\tmemset(&cp, 0x00, sizeof(cp));\n\n\tcp.handle   = cpu_to_le16(handle);\n\n\tcp.tx_bandwidth   = cpu_to_le32(0x00001f40);\n\tcp.rx_bandwidth   = cpu_to_le32(0x00001f40);\n\n\tswitch (conn->codec.id) {\n\tcase BT_CODEC_MSBC:\n\t\tif (!find_next_esco_param(conn, esco_param_msbc,\n\t\t\t\t\t  ARRAY_SIZE(esco_param_msbc)))\n\t\t\treturn -EINVAL;\n\n\t\tparam = &esco_param_msbc[conn->attempt - 1];\n\t\tcp.tx_coding_format.id = 0x05;\n\t\tcp.rx_coding_format.id = 0x05;\n\t\tcp.tx_codec_frame_size = __cpu_to_le16(60);\n\t\tcp.rx_codec_frame_size = __cpu_to_le16(60);\n\t\tcp.in_bandwidth = __cpu_to_le32(32000);\n\t\tcp.out_bandwidth = __cpu_to_le32(32000);\n\t\tcp.in_coding_format.id = 0x04;\n\t\tcp.out_coding_format.id = 0x04;\n\t\tcp.in_coded_data_size = __cpu_to_le16(16);\n\t\tcp.out_coded_data_size = __cpu_to_le16(16);\n\t\tcp.in_pcm_data_format = 2;\n\t\tcp.out_pcm_data_format = 2;\n\t\tcp.in_pcm_sample_payload_msb_pos = 0;\n\t\tcp.out_pcm_sample_payload_msb_pos = 0;\n\t\tcp.in_data_path = conn->codec.data_path;\n\t\tcp.out_data_path = conn->codec.data_path;\n\t\tcp.in_transport_unit_size = 1;\n\t\tcp.out_transport_unit_size = 1;\n\t\tbreak;\n\n\tcase BT_CODEC_TRANSPARENT:\n\t\tif (!find_next_esco_param(conn, esco_param_msbc,\n\t\t\t\t\t  ARRAY_SIZE(esco_param_msbc)))\n\t\t\treturn false;\n\t\tparam = &esco_param_msbc[conn->attempt - 1];\n\t\tcp.tx_coding_format.id = 0x03;\n\t\tcp.rx_coding_format.id = 0x03;\n\t\tcp.tx_codec_frame_size = __cpu_to_le16(60);\n\t\tcp.rx_codec_frame_size = __cpu_to_le16(60);\n\t\tcp.in_bandwidth = __cpu_to_le32(0x1f40);\n\t\tcp.out_bandwidth = __cpu_to_le32(0x1f40);\n\t\tcp.in_coding_format.id = 0x03;\n\t\tcp.out_coding_format.id = 0x03;\n\t\tcp.in_coded_data_size = __cpu_to_le16(16);\n\t\tcp.out_coded_data_size = __cpu_to_le16(16);\n\t\tcp.in_pcm_data_format = 2;\n\t\tcp.out_pcm_data_format = 2;\n\t\tcp.in_pcm_sample_payload_msb_pos = 0;\n\t\tcp.out_pcm_sample_payload_msb_pos = 0;\n\t\tcp.in_data_path = conn->codec.data_path;\n\t\tcp.out_data_path = conn->codec.data_path;\n\t\tcp.in_transport_unit_size = 1;\n\t\tcp.out_transport_unit_size = 1;\n\t\tbreak;\n\n\tcase BT_CODEC_CVSD:\n\t\tif (conn->parent && lmp_esco_capable(conn->parent)) {\n\t\t\tif (!find_next_esco_param(conn, esco_param_cvsd,\n\t\t\t\t\t\t  ARRAY_SIZE(esco_param_cvsd)))\n\t\t\t\treturn -EINVAL;\n\t\t\tparam = &esco_param_cvsd[conn->attempt - 1];\n\t\t} else {\n\t\t\tif (conn->attempt > ARRAY_SIZE(sco_param_cvsd))\n\t\t\t\treturn -EINVAL;\n\t\t\tparam = &sco_param_cvsd[conn->attempt - 1];\n\t\t}\n\t\tcp.tx_coding_format.id = 2;\n\t\tcp.rx_coding_format.id = 2;\n\t\tcp.tx_codec_frame_size = __cpu_to_le16(60);\n\t\tcp.rx_codec_frame_size = __cpu_to_le16(60);\n\t\tcp.in_bandwidth = __cpu_to_le32(16000);\n\t\tcp.out_bandwidth = __cpu_to_le32(16000);\n\t\tcp.in_coding_format.id = 4;\n\t\tcp.out_coding_format.id = 4;\n\t\tcp.in_coded_data_size = __cpu_to_le16(16);\n\t\tcp.out_coded_data_size = __cpu_to_le16(16);\n\t\tcp.in_pcm_data_format = 2;\n\t\tcp.out_pcm_data_format = 2;\n\t\tcp.in_pcm_sample_payload_msb_pos = 0;\n\t\tcp.out_pcm_sample_payload_msb_pos = 0;\n\t\tcp.in_data_path = conn->codec.data_path;\n\t\tcp.out_data_path = conn->codec.data_path;\n\t\tcp.in_transport_unit_size = 16;\n\t\tcp.out_transport_unit_size = 16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcp.retrans_effort = param->retrans_effort;\n\tcp.pkt_type = __cpu_to_le16(param->pkt_type);\n\tcp.max_latency = __cpu_to_le16(param->max_latency);\n\n\tif (hci_send_cmd(hdev, HCI_OP_ENHANCED_SETUP_SYNC_CONN, sizeof(cp), &cp) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic bool hci_setup_sync_conn(struct hci_conn *conn, __u16 handle)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct hci_cp_setup_sync_conn cp;\n\tconst struct sco_param *param;\n\n\tbt_dev_dbg(hdev, \"hcon %p\", conn);\n\n\tconn->state = BT_CONNECT;\n\tconn->out = true;\n\n\tconn->attempt++;\n\n\tcp.handle   = cpu_to_le16(handle);\n\n\tcp.tx_bandwidth   = cpu_to_le32(0x00001f40);\n\tcp.rx_bandwidth   = cpu_to_le32(0x00001f40);\n\tcp.voice_setting  = cpu_to_le16(conn->setting);\n\n\tswitch (conn->setting & SCO_AIRMODE_MASK) {\n\tcase SCO_AIRMODE_TRANSP:\n\t\tif (!find_next_esco_param(conn, esco_param_msbc,\n\t\t\t\t\t  ARRAY_SIZE(esco_param_msbc)))\n\t\t\treturn false;\n\t\tparam = &esco_param_msbc[conn->attempt - 1];\n\t\tbreak;\n\tcase SCO_AIRMODE_CVSD:\n\t\tif (conn->parent && lmp_esco_capable(conn->parent)) {\n\t\t\tif (!find_next_esco_param(conn, esco_param_cvsd,\n\t\t\t\t\t\t  ARRAY_SIZE(esco_param_cvsd)))\n\t\t\t\treturn false;\n\t\t\tparam = &esco_param_cvsd[conn->attempt - 1];\n\t\t} else {\n\t\t\tif (conn->attempt > ARRAY_SIZE(sco_param_cvsd))\n\t\t\t\treturn false;\n\t\t\tparam = &sco_param_cvsd[conn->attempt - 1];\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tcp.retrans_effort = param->retrans_effort;\n\tcp.pkt_type = __cpu_to_le16(param->pkt_type);\n\tcp.max_latency = __cpu_to_le16(param->max_latency);\n\n\tif (hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool hci_setup_sync(struct hci_conn *conn, __u16 handle)\n{\n\tint result;\n\tstruct conn_handle_t *conn_handle;\n\n\tif (enhanced_sync_conn_capable(conn->hdev)) {\n\t\tconn_handle = kzalloc(sizeof(*conn_handle), GFP_KERNEL);\n\n\t\tif (!conn_handle)\n\t\t\treturn false;\n\n\t\tconn_handle->conn = conn;\n\t\tconn_handle->handle = handle;\n\t\tresult = hci_cmd_sync_queue(conn->hdev, hci_enhanced_setup_sync,\n\t\t\t\t\t    conn_handle, NULL);\n\t\tif (result < 0)\n\t\t\tkfree(conn_handle);\n\n\t\treturn result == 0;\n\t}\n\n\treturn hci_setup_sync_conn(conn, handle);\n}\n\nu8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,\n\t\t      u16 to_multiplier)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct hci_conn_params *params;\n\tstruct hci_cp_le_conn_update cp;\n\n\thci_dev_lock(hdev);\n\n\tparams = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);\n\tif (params) {\n\t\tparams->conn_min_interval = min;\n\t\tparams->conn_max_interval = max;\n\t\tparams->conn_latency = latency;\n\t\tparams->supervision_timeout = to_multiplier;\n\t}\n\n\thci_dev_unlock(hdev);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.handle\t\t= cpu_to_le16(conn->handle);\n\tcp.conn_interval_min\t= cpu_to_le16(min);\n\tcp.conn_interval_max\t= cpu_to_le16(max);\n\tcp.conn_latency\t\t= cpu_to_le16(latency);\n\tcp.supervision_timeout\t= cpu_to_le16(to_multiplier);\n\tcp.min_ce_len\t\t= cpu_to_le16(0x0000);\n\tcp.max_ce_len\t\t= cpu_to_le16(0x0000);\n\n\thci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);\n\n\tif (params)\n\t\treturn 0x01;\n\n\treturn 0x00;\n}\n\nvoid hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,\n\t\t      __u8 ltk[16], __u8 key_size)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct hci_cp_le_start_enc cp;\n\n\tBT_DBG(\"hcon %p\", conn);\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tcp.handle = cpu_to_le16(conn->handle);\n\tcp.rand = rand;\n\tcp.ediv = ediv;\n\tmemcpy(cp.ltk, ltk, key_size);\n\n\thci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);\n}\n\n \nvoid hci_sco_setup(struct hci_conn *conn, __u8 status)\n{\n\tstruct hci_link *link;\n\n\tlink = list_first_entry_or_null(&conn->link_list, struct hci_link, list);\n\tif (!link || !link->conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p\", conn);\n\n\tif (!status) {\n\t\tif (lmp_esco_capable(conn->hdev))\n\t\t\thci_setup_sync(link->conn, conn->handle);\n\t\telse\n\t\t\thci_add_sco(link->conn, conn->handle);\n\t} else {\n\t\thci_connect_cfm(link->conn, status);\n\t\thci_conn_del(link->conn);\n\t}\n}\n\nstatic void hci_conn_timeout(struct work_struct *work)\n{\n\tstruct hci_conn *conn = container_of(work, struct hci_conn,\n\t\t\t\t\t     disc_work.work);\n\tint refcnt = atomic_read(&conn->refcnt);\n\n\tBT_DBG(\"hcon %p state %s\", conn, state_to_string(conn->state));\n\n\tWARN_ON(refcnt < 0);\n\n\t \n\tif (refcnt > 0)\n\t\treturn;\n\n\thci_abort_conn(conn, hci_proto_disconn_ind(conn));\n}\n\n \nstatic void hci_conn_idle(struct work_struct *work)\n{\n\tstruct hci_conn *conn = container_of(work, struct hci_conn,\n\t\t\t\t\t     idle_work.work);\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tBT_DBG(\"hcon %p mode %d\", conn, conn->mode);\n\n\tif (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))\n\t\treturn;\n\n\tif (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))\n\t\treturn;\n\n\tif (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {\n\t\tstruct hci_cp_sniff_subrate cp;\n\t\tcp.handle             = cpu_to_le16(conn->handle);\n\t\tcp.max_latency        = cpu_to_le16(0);\n\t\tcp.min_remote_timeout = cpu_to_le16(0);\n\t\tcp.min_local_timeout  = cpu_to_le16(0);\n\t\thci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);\n\t}\n\n\tif (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {\n\t\tstruct hci_cp_sniff_mode cp;\n\t\tcp.handle       = cpu_to_le16(conn->handle);\n\t\tcp.max_interval = cpu_to_le16(hdev->sniff_max_interval);\n\t\tcp.min_interval = cpu_to_le16(hdev->sniff_min_interval);\n\t\tcp.attempt      = cpu_to_le16(4);\n\t\tcp.timeout      = cpu_to_le16(1);\n\t\thci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);\n\t}\n}\n\nstatic void hci_conn_auto_accept(struct work_struct *work)\n{\n\tstruct hci_conn *conn = container_of(work, struct hci_conn,\n\t\t\t\t\t     auto_accept_work.work);\n\n\thci_send_cmd(conn->hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),\n\t\t     &conn->dst);\n}\n\nstatic void le_disable_advertising(struct hci_dev *hdev)\n{\n\tif (ext_adv_capable(hdev)) {\n\t\tstruct hci_cp_le_set_ext_adv_enable cp;\n\n\t\tcp.enable = 0x00;\n\t\tcp.num_of_sets = 0x00;\n\n\t\thci_send_cmd(hdev, HCI_OP_LE_SET_EXT_ADV_ENABLE, sizeof(cp),\n\t\t\t     &cp);\n\t} else {\n\t\tu8 enable = 0x00;\n\t\thci_send_cmd(hdev, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),\n\t\t\t     &enable);\n\t}\n}\n\nstatic void le_conn_timeout(struct work_struct *work)\n{\n\tstruct hci_conn *conn = container_of(work, struct hci_conn,\n\t\t\t\t\t     le_conn_timeout.work);\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tBT_DBG(\"\");\n\n\t \n\tif (conn->role == HCI_ROLE_SLAVE) {\n\t\t \n\t\tle_disable_advertising(hdev);\n\t\thci_dev_lock(hdev);\n\t\thci_conn_failed(conn, HCI_ERROR_ADVERTISING_TIMEOUT);\n\t\thci_dev_unlock(hdev);\n\t\treturn;\n\t}\n\n\thci_abort_conn(conn, HCI_ERROR_REMOTE_USER_TERM);\n}\n\nstruct iso_cig_params {\n\tstruct hci_cp_le_set_cig_params cp;\n\tstruct hci_cis_params cis[0x1f];\n};\n\nstruct iso_list_data {\n\tunion {\n\t\tu8  cig;\n\t\tu8  big;\n\t};\n\tunion {\n\t\tu8  cis;\n\t\tu8  bis;\n\t\tu16 sync_handle;\n\t};\n\tint count;\n\tbool big_term;\n\tbool pa_sync_term;\n\tbool big_sync_term;\n};\n\nstatic void bis_list(struct hci_conn *conn, void *data)\n{\n\tstruct iso_list_data *d = data;\n\n\t \n\tif (bacmp(&conn->dst, BDADDR_ANY))\n\t\treturn;\n\n\tif (d->big != conn->iso_qos.bcast.big || d->bis == BT_ISO_QOS_BIS_UNSET ||\n\t    d->bis != conn->iso_qos.bcast.bis)\n\t\treturn;\n\n\td->count++;\n}\n\nstatic int terminate_big_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct iso_list_data *d = data;\n\n\tbt_dev_dbg(hdev, \"big 0x%2.2x bis 0x%2.2x\", d->big, d->bis);\n\n\thci_remove_ext_adv_instance_sync(hdev, d->bis, NULL);\n\n\t \n\tif (!d->big_term)\n\t\treturn 0;\n\n\treturn hci_le_terminate_big_sync(hdev, d->big,\n\t\t\t\t\t HCI_ERROR_LOCAL_HOST_TERM);\n}\n\nstatic void terminate_big_destroy(struct hci_dev *hdev, void *data, int err)\n{\n\tkfree(data);\n}\n\nstatic int hci_le_terminate_big(struct hci_dev *hdev, struct hci_conn *conn)\n{\n\tstruct iso_list_data *d;\n\tint ret;\n\n\tbt_dev_dbg(hdev, \"big 0x%2.2x bis 0x%2.2x\", conn->iso_qos.bcast.big,\n\t\t   conn->iso_qos.bcast.bis);\n\n\td = kzalloc(sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\td->big = conn->iso_qos.bcast.big;\n\td->bis = conn->iso_qos.bcast.bis;\n\td->big_term = test_and_clear_bit(HCI_CONN_BIG_CREATED, &conn->flags);\n\n\tret = hci_cmd_sync_queue(hdev, terminate_big_sync, d,\n\t\t\t\t terminate_big_destroy);\n\tif (ret)\n\t\tkfree(d);\n\n\treturn ret;\n}\n\nstatic int big_terminate_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct iso_list_data *d = data;\n\n\tbt_dev_dbg(hdev, \"big 0x%2.2x sync_handle 0x%4.4x\", d->big,\n\t\t   d->sync_handle);\n\n\tif (d->big_sync_term)\n\t\thci_le_big_terminate_sync(hdev, d->big);\n\n\tif (d->pa_sync_term)\n\t\treturn hci_le_pa_terminate_sync(hdev, d->sync_handle);\n\n\treturn 0;\n}\n\nstatic int hci_le_big_terminate(struct hci_dev *hdev, u8 big, struct hci_conn *conn)\n{\n\tstruct iso_list_data *d;\n\tint ret;\n\n\tbt_dev_dbg(hdev, \"big 0x%2.2x sync_handle 0x%4.4x\", big, conn->sync_handle);\n\n\td = kzalloc(sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\td->big = big;\n\td->sync_handle = conn->sync_handle;\n\td->pa_sync_term = test_and_clear_bit(HCI_CONN_PA_SYNC, &conn->flags);\n\td->big_sync_term = test_and_clear_bit(HCI_CONN_BIG_SYNC, &conn->flags);\n\n\tret = hci_cmd_sync_queue(hdev, big_terminate_sync, d,\n\t\t\t\t terminate_big_destroy);\n\tif (ret)\n\t\tkfree(d);\n\n\treturn ret;\n}\n\n \nstatic void bis_cleanup(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct hci_conn *bis;\n\n\tbt_dev_dbg(hdev, \"conn %p\", conn);\n\n\tif (conn->role == HCI_ROLE_MASTER) {\n\t\tif (!test_and_clear_bit(HCI_CONN_PER_ADV, &conn->flags))\n\t\t\treturn;\n\n\t\t \n\t\tbis = hci_conn_hash_lookup_big(hdev, conn->iso_qos.bcast.big);\n\t\tif (bis)\n\t\t\treturn;\n\n\t\thci_le_terminate_big(hdev, conn);\n\t} else {\n\t\tbis = hci_conn_hash_lookup_big_any_dst(hdev,\n\t\t\t\t\t\t       conn->iso_qos.bcast.big);\n\n\t\tif (bis)\n\t\t\treturn;\n\n\t\thci_le_big_terminate(hdev, conn->iso_qos.bcast.big,\n\t\t\t\t     conn);\n\t}\n}\n\nstatic int remove_cig_sync(struct hci_dev *hdev, void *data)\n{\n\tu8 handle = PTR_UINT(data);\n\n\treturn hci_le_remove_cig_sync(hdev, handle);\n}\n\nstatic int hci_le_remove_cig(struct hci_dev *hdev, u8 handle)\n{\n\tbt_dev_dbg(hdev, \"handle 0x%2.2x\", handle);\n\n\treturn hci_cmd_sync_queue(hdev, remove_cig_sync, UINT_PTR(handle),\n\t\t\t\t  NULL);\n}\n\nstatic void find_cis(struct hci_conn *conn, void *data)\n{\n\tstruct iso_list_data *d = data;\n\n\t \n\tif (!bacmp(&conn->dst, BDADDR_ANY) || d->cig != conn->iso_qos.ucast.cig)\n\t\treturn;\n\n\td->count++;\n}\n\n \nstatic void cis_cleanup(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct iso_list_data d;\n\n\tif (conn->iso_qos.ucast.cig == BT_ISO_QOS_CIG_UNSET)\n\t\treturn;\n\n\tmemset(&d, 0, sizeof(d));\n\td.cig = conn->iso_qos.ucast.cig;\n\n\t \n\thci_conn_hash_list_state(hdev, find_cis, ISO_LINK, BT_BOUND, &d);\n\thci_conn_hash_list_state(hdev, find_cis, ISO_LINK, BT_CONNECT, &d);\n\thci_conn_hash_list_state(hdev, find_cis, ISO_LINK, BT_CONNECTED, &d);\n\tif (d.count)\n\t\treturn;\n\n\thci_le_remove_cig(hdev, conn->iso_qos.ucast.cig);\n}\n\nstatic int hci_conn_hash_alloc_unset(struct hci_dev *hdev)\n{\n\treturn ida_alloc_range(&hdev->unset_handle_ida, HCI_CONN_HANDLE_MAX + 1,\n\t\t\t       U16_MAX, GFP_ATOMIC);\n}\n\nstruct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,\n\t\t\t      u8 role, u16 handle)\n{\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"dst %pMR handle 0x%4.4x\", dst, handle);\n\n\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\n\tbacpy(&conn->dst, dst);\n\tbacpy(&conn->src, &hdev->bdaddr);\n\tconn->handle = handle;\n\tconn->hdev  = hdev;\n\tconn->type  = type;\n\tconn->role  = role;\n\tconn->mode  = HCI_CM_ACTIVE;\n\tconn->state = BT_OPEN;\n\tconn->auth_type = HCI_AT_GENERAL_BONDING;\n\tconn->io_capability = hdev->io_capability;\n\tconn->remote_auth = 0xff;\n\tconn->key_type = 0xff;\n\tconn->rssi = HCI_RSSI_INVALID;\n\tconn->tx_power = HCI_TX_POWER_INVALID;\n\tconn->max_tx_power = HCI_TX_POWER_INVALID;\n\tconn->sync_handle = HCI_SYNC_HANDLE_INVALID;\n\n\tset_bit(HCI_CONN_POWER_SAVE, &conn->flags);\n\tconn->disc_timeout = HCI_DISCONN_TIMEOUT;\n\n\t \n\tconn->auth_payload_timeout = DEFAULT_AUTH_PAYLOAD_TIMEOUT;\n\n\tif (conn->role == HCI_ROLE_MASTER)\n\t\tconn->out = true;\n\n\tswitch (type) {\n\tcase ACL_LINK:\n\t\tconn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;\n\t\tbreak;\n\tcase LE_LINK:\n\t\t \n\t\thci_copy_identity_address(hdev, &conn->src, &conn->src_type);\n\t\tbreak;\n\tcase ISO_LINK:\n\t\t \n\t\thci_copy_identity_address(hdev, &conn->src, &conn->src_type);\n\n\t\t \n\t\tif (!bacmp(dst, BDADDR_ANY))\n\t\t\tconn->cleanup = bis_cleanup;\n\t\telse if (conn->role == HCI_ROLE_MASTER)\n\t\t\tconn->cleanup = cis_cleanup;\n\n\t\tbreak;\n\tcase SCO_LINK:\n\t\tif (lmp_esco_capable(hdev))\n\t\t\tconn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |\n\t\t\t\t\t(hdev->esco_type & EDR_ESCO_MASK);\n\t\telse\n\t\t\tconn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;\n\t\tbreak;\n\tcase ESCO_LINK:\n\t\tconn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;\n\t\tbreak;\n\t}\n\n\tskb_queue_head_init(&conn->data_q);\n\n\tINIT_LIST_HEAD(&conn->chan_list);\n\tINIT_LIST_HEAD(&conn->link_list);\n\n\tINIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);\n\tINIT_DELAYED_WORK(&conn->auto_accept_work, hci_conn_auto_accept);\n\tINIT_DELAYED_WORK(&conn->idle_work, hci_conn_idle);\n\tINIT_DELAYED_WORK(&conn->le_conn_timeout, le_conn_timeout);\n\n\tatomic_set(&conn->refcnt, 0);\n\n\thci_dev_hold(hdev);\n\n\thci_conn_hash_add(hdev, conn);\n\n\t \n\tif (conn->type != SCO_LINK && conn->type != ESCO_LINK) {\n\t\tif (hdev->notify)\n\t\t\thdev->notify(hdev, HCI_NOTIFY_CONN_ADD);\n\t}\n\n\thci_conn_init_sysfs(conn);\n\n\treturn conn;\n}\n\nstruct hci_conn *hci_conn_add_unset(struct hci_dev *hdev, int type,\n\t\t\t\t    bdaddr_t *dst, u8 role)\n{\n\tint handle;\n\n\tbt_dev_dbg(hdev, \"dst %pMR\", dst);\n\n\thandle = hci_conn_hash_alloc_unset(hdev);\n\tif (unlikely(handle < 0))\n\t\treturn NULL;\n\n\treturn hci_conn_add(hdev, type, dst, role, handle);\n}\n\nstatic void hci_conn_cleanup_child(struct hci_conn *conn, u8 reason)\n{\n\tif (!reason)\n\t\treason = HCI_ERROR_REMOTE_USER_TERM;\n\n\t \n\tswitch (conn->type) {\n\tcase SCO_LINK:\n\tcase ESCO_LINK:\n\t\tif (HCI_CONN_HANDLE_UNSET(conn->handle))\n\t\t\thci_conn_failed(conn, reason);\n\t\tbreak;\n\tcase ISO_LINK:\n\t\tif (conn->state != BT_CONNECTED &&\n\t\t    !test_bit(HCI_CONN_CREATE_CIS, &conn->flags))\n\t\t\thci_conn_failed(conn, reason);\n\t\tbreak;\n\t}\n}\n\nstatic void hci_conn_unlink(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tbt_dev_dbg(hdev, \"hcon %p\", conn);\n\n\tif (!conn->parent) {\n\t\tstruct hci_link *link, *t;\n\n\t\tlist_for_each_entry_safe(link, t, &conn->link_list, list) {\n\t\t\tstruct hci_conn *child = link->conn;\n\n\t\t\thci_conn_unlink(child);\n\n\t\t\t \n\t\t\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\t\t\tcontinue;\n\n\t\t\thci_conn_cleanup_child(child, conn->abort_reason);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (!conn->link)\n\t\treturn;\n\n\tlist_del_rcu(&conn->link->list);\n\tsynchronize_rcu();\n\n\thci_conn_drop(conn->parent);\n\thci_conn_put(conn->parent);\n\tconn->parent = NULL;\n\n\tkfree(conn->link);\n\tconn->link = NULL;\n}\n\nvoid hci_conn_del(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tBT_DBG(\"%s hcon %p handle %d\", hdev->name, conn, conn->handle);\n\n\thci_conn_unlink(conn);\n\n\tcancel_delayed_work_sync(&conn->disc_work);\n\tcancel_delayed_work_sync(&conn->auto_accept_work);\n\tcancel_delayed_work_sync(&conn->idle_work);\n\n\tif (conn->type == ACL_LINK) {\n\t\t \n\t\thdev->acl_cnt += conn->sent;\n\t} else if (conn->type == LE_LINK) {\n\t\tcancel_delayed_work(&conn->le_conn_timeout);\n\n\t\tif (hdev->le_pkts)\n\t\t\thdev->le_cnt += conn->sent;\n\t\telse\n\t\t\thdev->acl_cnt += conn->sent;\n\t} else {\n\t\t \n\t\tif (conn->type == ISO_LINK) {\n\t\t\tif (hdev->iso_pkts)\n\t\t\t\thdev->iso_cnt += conn->sent;\n\t\t\telse if (hdev->le_pkts)\n\t\t\t\thdev->le_cnt += conn->sent;\n\t\t\telse\n\t\t\t\thdev->acl_cnt += conn->sent;\n\t\t}\n\t}\n\n\tif (conn->amp_mgr)\n\t\tamp_mgr_put(conn->amp_mgr);\n\n\tskb_queue_purge(&conn->data_q);\n\n\t \n\thci_conn_cleanup(conn);\n}\n\nstruct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src, uint8_t src_type)\n{\n\tint use_src = bacmp(src, BDADDR_ANY);\n\tstruct hci_dev *hdev = NULL, *d;\n\n\tBT_DBG(\"%pMR -> %pMR\", src, dst);\n\n\tread_lock(&hci_dev_list_lock);\n\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (!test_bit(HCI_UP, &d->flags) ||\n\t\t    hci_dev_test_flag(d, HCI_USER_CHANNEL) ||\n\t\t    d->dev_type != HCI_PRIMARY)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tif (use_src) {\n\t\t\tbdaddr_t id_addr;\n\t\t\tu8 id_addr_type;\n\n\t\t\tif (src_type == BDADDR_BREDR) {\n\t\t\t\tif (!lmp_bredr_capable(d))\n\t\t\t\t\tcontinue;\n\t\t\t\tbacpy(&id_addr, &d->bdaddr);\n\t\t\t\tid_addr_type = BDADDR_BREDR;\n\t\t\t} else {\n\t\t\t\tif (!lmp_le_capable(d))\n\t\t\t\t\tcontinue;\n\n\t\t\t\thci_copy_identity_address(d, &id_addr,\n\t\t\t\t\t\t\t  &id_addr_type);\n\n\t\t\t\t \n\t\t\t\tif (id_addr_type == ADDR_LE_DEV_PUBLIC)\n\t\t\t\t\tid_addr_type = BDADDR_LE_PUBLIC;\n\t\t\t\telse\n\t\t\t\t\tid_addr_type = BDADDR_LE_RANDOM;\n\t\t\t}\n\n\t\t\tif (!bacmp(&id_addr, src) && id_addr_type == src_type) {\n\t\t\t\thdev = d; break;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bacmp(&d->bdaddr, dst)) {\n\t\t\t\thdev = d; break;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hdev)\n\t\thdev = hci_dev_hold(hdev);\n\n\tread_unlock(&hci_dev_list_lock);\n\treturn hdev;\n}\nEXPORT_SYMBOL(hci_get_route);\n\n \nstatic void hci_le_conn_failed(struct hci_conn *conn, u8 status)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\thci_connect_le_scan_cleanup(conn, status);\n\n\t \n\thci_enable_advertising(hdev);\n}\n\n \nvoid hci_conn_failed(struct hci_conn *conn, u8 status)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tswitch (conn->type) {\n\tcase LE_LINK:\n\t\thci_le_conn_failed(conn, status);\n\t\tbreak;\n\tcase ACL_LINK:\n\t\tmgmt_connect_failed(hdev, &conn->dst, conn->type,\n\t\t\t\t    conn->dst_type, status);\n\t\tbreak;\n\t}\n\n\tconn->state = BT_CLOSED;\n\thci_connect_cfm(conn, status);\n\thci_conn_del(conn);\n}\n\n \nu8 hci_conn_set_handle(struct hci_conn *conn, u16 handle)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tbt_dev_dbg(hdev, \"hcon %p handle 0x%4.4x\", conn, handle);\n\n\tif (conn->handle == handle)\n\t\treturn 0;\n\n\tif (handle > HCI_CONN_HANDLE_MAX) {\n\t\tbt_dev_err(hdev, \"Invalid handle: 0x%4.4x > 0x%4.4x\",\n\t\t\t   handle, HCI_CONN_HANDLE_MAX);\n\t\treturn HCI_ERROR_INVALID_PARAMETERS;\n\t}\n\n\t \n\tif (conn->abort_reason)\n\t\treturn conn->abort_reason;\n\n\tif (HCI_CONN_HANDLE_UNSET(conn->handle))\n\t\tida_free(&hdev->unset_handle_ida, conn->handle);\n\n\tconn->handle = handle;\n\n\treturn 0;\n}\n\nstatic void create_le_conn_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct hci_conn *conn;\n\tu16 handle = PTR_UINT(data);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (!conn)\n\t\treturn;\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\thci_dev_lock(hdev);\n\n\tif (!err) {\n\t\thci_connect_le_scan_cleanup(conn, 0x00);\n\t\tgoto done;\n\t}\n\n\t \n\tif (conn != hci_lookup_le_connect(hdev))\n\t\tgoto done;\n\n\t \n\tflush_delayed_work(&conn->le_conn_timeout);\n\thci_conn_failed(conn, bt_status(err));\n\ndone:\n\thci_dev_unlock(hdev);\n}\n\nstatic int hci_connect_le_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct hci_conn *conn;\n\tu16 handle = PTR_UINT(data);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (!conn)\n\t\treturn 0;\n\n\tbt_dev_dbg(hdev, \"conn %p\", conn);\n\n\tclear_bit(HCI_CONN_SCANNING, &conn->flags);\n\tconn->state = BT_CONNECT;\n\n\treturn hci_le_create_conn_sync(hdev, conn);\n}\n\nstruct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\tu8 dst_type, bool dst_resolved, u8 sec_level,\n\t\t\t\tu16 conn_timeout, u8 role)\n{\n\tstruct hci_conn *conn;\n\tstruct smp_irk *irk;\n\tint err;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\n\t\tif (lmp_le_capable(hdev))\n\t\t\treturn ERR_PTR(-ECONNREFUSED);\n\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\t \n\tif (hci_lookup_le_connect(hdev))\n\t\treturn ERR_PTR(-EBUSY);\n\n\t \n\tconn = hci_conn_hash_lookup_le(hdev, dst, dst_type);\n\tif (conn && !test_bit(HCI_CONN_SCANNING, &conn->flags)) {\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\t \n\tif (!dst_resolved) {\n\t\t \n\t\tirk = hci_find_irk_by_addr(hdev, dst, dst_type);\n\t\tif (irk && bacmp(&irk->rpa, BDADDR_ANY)) {\n\t\t\tdst = &irk->rpa;\n\t\t\tdst_type = ADDR_LE_DEV_RANDOM;\n\t\t}\n\t}\n\n\tif (conn) {\n\t\tbacpy(&conn->dst, dst);\n\t} else {\n\t\tconn = hci_conn_add_unset(hdev, LE_LINK, dst, role);\n\t\tif (!conn)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\thci_conn_hold(conn);\n\t\tconn->pending_sec_level = sec_level;\n\t}\n\n\tconn->dst_type = dst_type;\n\tconn->sec_level = BT_SECURITY_LOW;\n\tconn->conn_timeout = conn_timeout;\n\n\terr = hci_cmd_sync_queue(hdev, hci_connect_le_sync,\n\t\t\t\t UINT_PTR(conn->handle),\n\t\t\t\t create_le_conn_complete);\n\tif (err) {\n\t\thci_conn_del(conn);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn conn;\n}\n\nstatic bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)\n{\n\tstruct hci_conn *conn;\n\n\tconn = hci_conn_hash_lookup_le(hdev, addr, type);\n\tif (!conn)\n\t\treturn false;\n\n\tif (conn->state != BT_CONNECTED)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int hci_explicit_conn_params_set(struct hci_dev *hdev,\n\t\t\t\t\tbdaddr_t *addr, u8 addr_type)\n{\n\tstruct hci_conn_params *params;\n\n\tif (is_connected(hdev, addr, addr_type))\n\t\treturn -EISCONN;\n\n\tparams = hci_conn_params_lookup(hdev, addr, addr_type);\n\tif (!params) {\n\t\tparams = hci_conn_params_add(hdev, addr, addr_type);\n\t\tif (!params)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tparams->auto_connect = HCI_AUTO_CONN_EXPLICIT;\n\t}\n\n\t \n\tif (params->auto_connect == HCI_AUTO_CONN_DISABLED ||\n\t    params->auto_connect == HCI_AUTO_CONN_REPORT ||\n\t    params->auto_connect == HCI_AUTO_CONN_EXPLICIT) {\n\t\thci_pend_le_list_del_init(params);\n\t\thci_pend_le_list_add(params, &hdev->pend_le_conns);\n\t}\n\n\tparams->explicit_connect = true;\n\n\tBT_DBG(\"addr %pMR (type %u) auto_connect %u\", addr, addr_type,\n\t       params->auto_connect);\n\n\treturn 0;\n}\n\nstatic int qos_set_big(struct hci_dev *hdev, struct bt_iso_qos *qos)\n{\n\tstruct hci_conn *conn;\n\tu8  big;\n\n\t \n\tif (qos->bcast.big == BT_ISO_QOS_BIG_UNSET) {\n\t\tfor (big = 0x00; big < 0xef; big++) {\n\n\t\t\tconn = hci_conn_hash_lookup_big(hdev, big);\n\t\t\tif (!conn)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (big == 0xef)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\t \n\t\tqos->bcast.big = big;\n\t}\n\n\treturn 0;\n}\n\nstatic int qos_set_bis(struct hci_dev *hdev, struct bt_iso_qos *qos)\n{\n\tstruct hci_conn *conn;\n\tu8  bis;\n\n\t \n\tif (qos->bcast.bis == BT_ISO_QOS_BIS_UNSET) {\n\t\t \n\t\tfor (bis = 0x01; bis < hdev->le_num_of_adv_sets;\n\t\t     bis++) {\n\n\t\t\tconn = hci_conn_hash_lookup_bis(hdev, BDADDR_ANY, bis);\n\t\t\tif (!conn)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (bis == hdev->le_num_of_adv_sets)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\t \n\t\tqos->bcast.bis = bis;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct hci_conn *hci_add_bis(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\t    struct bt_iso_qos *qos, __u8 base_len,\n\t\t\t\t    __u8 *base)\n{\n\tstruct hci_conn *conn;\n\tint err;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\n\t\tif (lmp_le_capable(hdev))\n\t\t\treturn ERR_PTR(-ECONNREFUSED);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\terr = qos_set_big(hdev, qos);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terr = qos_set_bis(hdev, qos);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t \n\tconn = hci_conn_hash_lookup_per_adv_bis(hdev, dst, qos->bcast.big,\n\t\t\t\t\t\tqos->bcast.big);\n\tif (conn)\n\t\treturn ERR_PTR(-EADDRINUSE);\n\n\t \n\tconn = hci_conn_hash_lookup_big(hdev, qos->bcast.big);\n\n\tif (conn && (memcmp(qos, &conn->iso_qos, sizeof(*qos)) ||\n\t\t     base_len != conn->le_per_adv_data_len ||\n\t\t     memcmp(conn->le_per_adv_data, base, base_len)))\n\t\treturn ERR_PTR(-EADDRINUSE);\n\n\tconn = hci_conn_add_unset(hdev, ISO_LINK, dst, HCI_ROLE_MASTER);\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconn->state = BT_CONNECT;\n\n\thci_conn_hold(conn);\n\treturn conn;\n}\n\n \nstruct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\t     u8 dst_type, u8 sec_level,\n\t\t\t\t     u16 conn_timeout,\n\t\t\t\t     enum conn_reasons conn_reason)\n{\n\tstruct hci_conn *conn;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\n\t\tif (lmp_le_capable(hdev))\n\t\t\treturn ERR_PTR(-ECONNREFUSED);\n\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\t \n\tconn = hci_conn_hash_lookup_le(hdev, dst, dst_type);\n\tif (conn) {\n\t\tif (conn->pending_sec_level < sec_level)\n\t\t\tconn->pending_sec_level = sec_level;\n\t\tgoto done;\n\t}\n\n\tBT_DBG(\"requesting refresh of dst_addr\");\n\n\tconn = hci_conn_add_unset(hdev, LE_LINK, dst, HCI_ROLE_MASTER);\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (hci_explicit_conn_params_set(hdev, dst, dst_type) < 0) {\n\t\thci_conn_del(conn);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tconn->state = BT_CONNECT;\n\tset_bit(HCI_CONN_SCANNING, &conn->flags);\n\tconn->dst_type = dst_type;\n\tconn->sec_level = BT_SECURITY_LOW;\n\tconn->pending_sec_level = sec_level;\n\tconn->conn_timeout = conn_timeout;\n\tconn->conn_reason = conn_reason;\n\n\thci_update_passive_scan(hdev);\n\ndone:\n\thci_conn_hold(conn);\n\treturn conn;\n}\n\nstruct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\t u8 sec_level, u8 auth_type,\n\t\t\t\t enum conn_reasons conn_reason)\n{\n\tstruct hci_conn *acl;\n\n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\n\t\tif (lmp_bredr_capable(hdev))\n\t\t\treturn ERR_PTR(-ECONNREFUSED);\n\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\t \n\tif (!bacmp(&hdev->bdaddr, dst)) {\n\t\tbt_dev_dbg(hdev, \"Reject connection with same BD_ADDR %pMR\\n\",\n\t\t\t   dst);\n\t\treturn ERR_PTR(-ECONNREFUSED);\n\t}\n\n\tacl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);\n\tif (!acl) {\n\t\tacl = hci_conn_add_unset(hdev, ACL_LINK, dst, HCI_ROLE_MASTER);\n\t\tif (!acl)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\thci_conn_hold(acl);\n\n\tacl->conn_reason = conn_reason;\n\tif (acl->state == BT_OPEN || acl->state == BT_CLOSED) {\n\t\tacl->sec_level = BT_SECURITY_LOW;\n\t\tacl->pending_sec_level = sec_level;\n\t\tacl->auth_type = auth_type;\n\t\thci_acl_create_connection(acl);\n\t}\n\n\treturn acl;\n}\n\nstatic struct hci_link *hci_conn_link(struct hci_conn *parent,\n\t\t\t\t      struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = parent->hdev;\n\tstruct hci_link *link;\n\n\tbt_dev_dbg(hdev, \"parent %p hcon %p\", parent, conn);\n\n\tif (conn->link)\n\t\treturn conn->link;\n\n\tif (conn->parent)\n\t\treturn NULL;\n\n\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn NULL;\n\n\tlink->conn = hci_conn_hold(conn);\n\tconn->link = link;\n\tconn->parent = hci_conn_get(parent);\n\n\t \n\tlist_add_tail_rcu(&link->list, &parent->link_list);\n\n\treturn link;\n}\n\nstruct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,\n\t\t\t\t __u16 setting, struct bt_codec *codec)\n{\n\tstruct hci_conn *acl;\n\tstruct hci_conn *sco;\n\tstruct hci_link *link;\n\n\tacl = hci_connect_acl(hdev, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING,\n\t\t\t      CONN_REASON_SCO_CONNECT);\n\tif (IS_ERR(acl))\n\t\treturn acl;\n\n\tsco = hci_conn_hash_lookup_ba(hdev, type, dst);\n\tif (!sco) {\n\t\tsco = hci_conn_add_unset(hdev, type, dst, HCI_ROLE_MASTER);\n\t\tif (!sco) {\n\t\t\thci_conn_drop(acl);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tlink = hci_conn_link(acl, sco);\n\tif (!link) {\n\t\thci_conn_drop(acl);\n\t\thci_conn_drop(sco);\n\t\treturn ERR_PTR(-ENOLINK);\n\t}\n\n\tsco->setting = setting;\n\tsco->codec = *codec;\n\n\tif (acl->state == BT_CONNECTED &&\n\t    (sco->state == BT_OPEN || sco->state == BT_CLOSED)) {\n\t\tset_bit(HCI_CONN_POWER_SAVE, &acl->flags);\n\t\thci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);\n\n\t\tif (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->flags)) {\n\t\t\t \n\t\t\tset_bit(HCI_CONN_SCO_SETUP_PEND, &acl->flags);\n\t\t\treturn sco;\n\t\t}\n\n\t\thci_sco_setup(acl, 0x00);\n\t}\n\n\treturn sco;\n}\n\nstatic int hci_le_create_big(struct hci_conn *conn, struct bt_iso_qos *qos)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct hci_cp_le_create_big cp;\n\tstruct iso_list_data data;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tdata.big = qos->bcast.big;\n\tdata.bis = qos->bcast.bis;\n\tdata.count = 0;\n\n\t \n\thci_conn_hash_list_state(hdev, bis_list, ISO_LINK,\n\t\t\t\t BT_BOUND, &data);\n\n\tcp.handle = qos->bcast.big;\n\tcp.adv_handle = qos->bcast.bis;\n\tcp.num_bis  = data.count;\n\thci_cpu_to_le24(qos->bcast.out.interval, cp.bis.sdu_interval);\n\tcp.bis.sdu = cpu_to_le16(qos->bcast.out.sdu);\n\tcp.bis.latency =  cpu_to_le16(qos->bcast.out.latency);\n\tcp.bis.rtn  = qos->bcast.out.rtn;\n\tcp.bis.phy  = qos->bcast.out.phy;\n\tcp.bis.packing = qos->bcast.packing;\n\tcp.bis.framing = qos->bcast.framing;\n\tcp.bis.encryption = qos->bcast.encryption;\n\tmemcpy(cp.bis.bcode, qos->bcast.bcode, sizeof(cp.bis.bcode));\n\n\treturn hci_send_cmd(hdev, HCI_OP_LE_CREATE_BIG, sizeof(cp), &cp);\n}\n\nstatic int set_cig_params_sync(struct hci_dev *hdev, void *data)\n{\n\tu8 cig_id = PTR_UINT(data);\n\tstruct hci_conn *conn;\n\tstruct bt_iso_qos *qos;\n\tstruct iso_cig_params pdu;\n\tu8 cis_id;\n\n\tconn = hci_conn_hash_lookup_cig(hdev, cig_id);\n\tif (!conn)\n\t\treturn 0;\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\tqos = &conn->iso_qos;\n\tpdu.cp.cig_id = cig_id;\n\thci_cpu_to_le24(qos->ucast.out.interval, pdu.cp.c_interval);\n\thci_cpu_to_le24(qos->ucast.in.interval, pdu.cp.p_interval);\n\tpdu.cp.sca = qos->ucast.sca;\n\tpdu.cp.packing = qos->ucast.packing;\n\tpdu.cp.framing = qos->ucast.framing;\n\tpdu.cp.c_latency = cpu_to_le16(qos->ucast.out.latency);\n\tpdu.cp.p_latency = cpu_to_le16(qos->ucast.in.latency);\n\n\t \n\tfor (cis_id = 0x00; cis_id < 0xf0 &&\n\t     pdu.cp.num_cis < ARRAY_SIZE(pdu.cis); cis_id++) {\n\t\tstruct hci_cis_params *cis;\n\n\t\tconn = hci_conn_hash_lookup_cis(hdev, NULL, 0, cig_id, cis_id);\n\t\tif (!conn)\n\t\t\tcontinue;\n\n\t\tqos = &conn->iso_qos;\n\n\t\tcis = &pdu.cis[pdu.cp.num_cis++];\n\t\tcis->cis_id = cis_id;\n\t\tcis->c_sdu  = cpu_to_le16(conn->iso_qos.ucast.out.sdu);\n\t\tcis->p_sdu  = cpu_to_le16(conn->iso_qos.ucast.in.sdu);\n\t\tcis->c_phy  = qos->ucast.out.phy ? qos->ucast.out.phy :\n\t\t\t      qos->ucast.in.phy;\n\t\tcis->p_phy  = qos->ucast.in.phy ? qos->ucast.in.phy :\n\t\t\t      qos->ucast.out.phy;\n\t\tcis->c_rtn  = qos->ucast.out.rtn;\n\t\tcis->p_rtn  = qos->ucast.in.rtn;\n\t}\n\n\tif (!pdu.cp.num_cis)\n\t\treturn 0;\n\n\treturn __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_CIG_PARAMS,\n\t\t\t\t     sizeof(pdu.cp) +\n\t\t\t\t     pdu.cp.num_cis * sizeof(pdu.cis[0]), &pdu,\n\t\t\t\t     HCI_CMD_TIMEOUT);\n}\n\nstatic bool hci_le_set_cig_params(struct hci_conn *conn, struct bt_iso_qos *qos)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct iso_list_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\n\t \n\tif (qos->ucast.cig == BT_ISO_QOS_CIG_UNSET) {\n\t\tfor (data.cig = 0x00; data.cig < 0xf0; data.cig++) {\n\t\t\tdata.count = 0;\n\n\t\t\thci_conn_hash_list_state(hdev, find_cis, ISO_LINK,\n\t\t\t\t\t\t BT_CONNECT, &data);\n\t\t\tif (data.count)\n\t\t\t\tcontinue;\n\n\t\t\thci_conn_hash_list_state(hdev, find_cis, ISO_LINK,\n\t\t\t\t\t\t BT_CONNECTED, &data);\n\t\t\tif (!data.count)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (data.cig == 0xf0)\n\t\t\treturn false;\n\n\t\t \n\t\tqos->ucast.cig = data.cig;\n\t}\n\n\tif (qos->ucast.cis != BT_ISO_QOS_CIS_UNSET) {\n\t\tif (hci_conn_hash_lookup_cis(hdev, NULL, 0, qos->ucast.cig,\n\t\t\t\t\t     qos->ucast.cis))\n\t\t\treturn false;\n\t\tgoto done;\n\t}\n\n\t \n\tfor (data.cig = qos->ucast.cig, data.cis = 0x00; data.cis < 0xf0;\n\t     data.cis++) {\n\t\tif (!hci_conn_hash_lookup_cis(hdev, NULL, 0, data.cig,\n\t\t\t\t\t      data.cis)) {\n\t\t\t \n\t\t\tqos->ucast.cis = data.cis;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (qos->ucast.cis == BT_ISO_QOS_CIS_UNSET)\n\t\treturn false;\n\ndone:\n\tif (hci_cmd_sync_queue(hdev, set_cig_params_sync,\n\t\t\t       UINT_PTR(qos->ucast.cig), NULL) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstruct hci_conn *hci_bind_cis(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t      __u8 dst_type, struct bt_iso_qos *qos)\n{\n\tstruct hci_conn *cis;\n\n\tcis = hci_conn_hash_lookup_cis(hdev, dst, dst_type, qos->ucast.cig,\n\t\t\t\t       qos->ucast.cis);\n\tif (!cis) {\n\t\tcis = hci_conn_add_unset(hdev, ISO_LINK, dst, HCI_ROLE_MASTER);\n\t\tif (!cis)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tcis->cleanup = cis_cleanup;\n\t\tcis->dst_type = dst_type;\n\t\tcis->iso_qos.ucast.cig = BT_ISO_QOS_CIG_UNSET;\n\t\tcis->iso_qos.ucast.cis = BT_ISO_QOS_CIS_UNSET;\n\t}\n\n\tif (cis->state == BT_CONNECTED)\n\t\treturn cis;\n\n\t \n\tif (cis->state == BT_BOUND &&\n\t    !memcmp(&cis->iso_qos, qos, sizeof(*qos)))\n\t\treturn cis;\n\n\t \n\tcis->le_tx_phy = qos->ucast.out.phy;\n\tcis->le_rx_phy = qos->ucast.in.phy;\n\n\t \n\tif (!qos->ucast.out.interval)\n\t\tqos->ucast.out.interval = qos->ucast.in.interval;\n\n\t \n\tif (!qos->ucast.in.interval)\n\t\tqos->ucast.in.interval = qos->ucast.out.interval;\n\n\t \n\tif (!qos->ucast.out.latency)\n\t\tqos->ucast.out.latency = qos->ucast.in.latency;\n\n\t \n\tif (!qos->ucast.in.latency)\n\t\tqos->ucast.in.latency = qos->ucast.out.latency;\n\n\tif (!hci_le_set_cig_params(cis, qos)) {\n\t\thci_conn_drop(cis);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\thci_conn_hold(cis);\n\n\tcis->iso_qos = *qos;\n\tcis->state = BT_BOUND;\n\n\treturn cis;\n}\n\nbool hci_iso_setup_path(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct hci_cp_le_setup_iso_path cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tif (conn->iso_qos.ucast.out.sdu) {\n\t\tcmd.handle = cpu_to_le16(conn->handle);\n\t\tcmd.direction = 0x00;  \n\t\tcmd.path = 0x00;  \n\t\tcmd.codec = 0x03;  \n\n\t\tif (hci_send_cmd(hdev, HCI_OP_LE_SETUP_ISO_PATH, sizeof(cmd),\n\t\t\t\t &cmd) < 0)\n\t\t\treturn false;\n\t}\n\n\tif (conn->iso_qos.ucast.in.sdu) {\n\t\tcmd.handle = cpu_to_le16(conn->handle);\n\t\tcmd.direction = 0x01;  \n\t\tcmd.path = 0x00;  \n\t\tcmd.codec = 0x03;  \n\n\t\tif (hci_send_cmd(hdev, HCI_OP_LE_SETUP_ISO_PATH, sizeof(cmd),\n\t\t\t\t &cmd) < 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint hci_conn_check_create_cis(struct hci_conn *conn)\n{\n\tif (conn->type != ISO_LINK || !bacmp(&conn->dst, BDADDR_ANY))\n\t\treturn -EINVAL;\n\n\tif (!conn->parent || conn->parent->state != BT_CONNECTED ||\n\t    conn->state != BT_CONNECT || HCI_CONN_HANDLE_UNSET(conn->handle))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int hci_create_cis_sync(struct hci_dev *hdev, void *data)\n{\n\treturn hci_le_create_cis_sync(hdev);\n}\n\nint hci_le_create_cis_pending(struct hci_dev *hdev)\n{\n\tstruct hci_conn *conn;\n\tbool pending = false;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(conn, &hdev->conn_hash.list, list) {\n\t\tif (test_bit(HCI_CONN_CREATE_CIS, &conn->flags)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (!hci_conn_check_create_cis(conn))\n\t\t\tpending = true;\n\t}\n\n\trcu_read_unlock();\n\n\tif (!pending)\n\t\treturn 0;\n\n\t \n\treturn hci_cmd_sync_queue(hdev, hci_create_cis_sync, NULL, NULL);\n}\n\nstatic void hci_iso_qos_setup(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t      struct bt_iso_io_qos *qos, __u8 phy)\n{\n\t \n\tif (!qos->sdu && qos->phy) {\n\t\tif (hdev->iso_mtu > 0)\n\t\t\tqos->sdu = hdev->iso_mtu;\n\t\telse if (hdev->le_mtu > 0)\n\t\t\tqos->sdu = hdev->le_mtu;\n\t\telse\n\t\t\tqos->sdu = hdev->acl_mtu;\n\t}\n\n\t \n\tif (qos->phy == BT_ISO_PHY_ANY)\n\t\tqos->phy = phy;\n\n\t \n\tif (!qos->interval)\n\t\t \n\t\tqos->interval = conn->le_conn_interval * 1250;\n\n\t \n\tif (!qos->latency)\n\t\tqos->latency = conn->le_conn_latency;\n}\n\nstatic int create_big_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct hci_conn *conn = data;\n\tstruct bt_iso_qos *qos = &conn->iso_qos;\n\tu16 interval, sync_interval = 0;\n\tu32 flags = 0;\n\tint err;\n\n\tif (qos->bcast.out.phy == 0x02)\n\t\tflags |= MGMT_ADV_FLAG_SEC_2M;\n\n\t \n\tinterval = (qos->bcast.out.interval / 1250) * qos->bcast.sync_factor;\n\n\tif (qos->bcast.bis)\n\t\tsync_interval = interval * 4;\n\n\terr = hci_start_per_adv_sync(hdev, qos->bcast.bis, conn->le_per_adv_data_len,\n\t\t\t\t     conn->le_per_adv_data, flags, interval,\n\t\t\t\t     interval, sync_interval);\n\tif (err)\n\t\treturn err;\n\n\treturn hci_le_create_big(conn, &conn->iso_qos);\n}\n\nstatic void create_pa_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct hci_cp_le_pa_create_sync *cp = data;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tif (err)\n\t\tbt_dev_err(hdev, \"Unable to create PA: %d\", err);\n\n\tkfree(cp);\n}\n\nstatic int create_pa_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct hci_cp_le_pa_create_sync *cp = data;\n\tint err;\n\n\terr = __hci_cmd_sync_status(hdev, HCI_OP_LE_PA_CREATE_SYNC,\n\t\t\t\t    sizeof(*cp), cp, HCI_CMD_TIMEOUT);\n\tif (err) {\n\t\thci_dev_clear_flag(hdev, HCI_PA_SYNC);\n\t\treturn err;\n\t}\n\n\treturn hci_update_passive_scan_sync(hdev);\n}\n\nint hci_pa_create_sync(struct hci_dev *hdev, bdaddr_t *dst, __u8 dst_type,\n\t\t       __u8 sid, struct bt_iso_qos *qos)\n{\n\tstruct hci_cp_le_pa_create_sync *cp;\n\n\tif (hci_dev_test_and_set_flag(hdev, HCI_PA_SYNC))\n\t\treturn -EBUSY;\n\n\tcp = kzalloc(sizeof(*cp), GFP_KERNEL);\n\tif (!cp) {\n\t\thci_dev_clear_flag(hdev, HCI_PA_SYNC);\n\t\treturn -ENOMEM;\n\t}\n\n\tcp->options = qos->bcast.options;\n\tcp->sid = sid;\n\tcp->addr_type = dst_type;\n\tbacpy(&cp->addr, dst);\n\tcp->skip = cpu_to_le16(qos->bcast.skip);\n\tcp->sync_timeout = cpu_to_le16(qos->bcast.sync_timeout);\n\tcp->sync_cte_type = qos->bcast.sync_cte_type;\n\n\t \n\treturn hci_cmd_sync_queue(hdev, create_pa_sync, cp, create_pa_complete);\n}\n\nint hci_le_big_create_sync(struct hci_dev *hdev, struct hci_conn *hcon,\n\t\t\t   struct bt_iso_qos *qos,\n\t\t\t   __u16 sync_handle, __u8 num_bis, __u8 bis[])\n{\n\tstruct _packed {\n\t\tstruct hci_cp_le_big_create_sync cp;\n\t\t__u8  bis[0x11];\n\t} pdu;\n\tint err;\n\n\tif (num_bis > sizeof(pdu.bis))\n\t\treturn -EINVAL;\n\n\terr = qos_set_big(hdev, qos);\n\tif (err)\n\t\treturn err;\n\n\tif (hcon)\n\t\thcon->iso_qos.bcast.big = qos->bcast.big;\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\tpdu.cp.handle = qos->bcast.big;\n\tpdu.cp.sync_handle = cpu_to_le16(sync_handle);\n\tpdu.cp.encryption = qos->bcast.encryption;\n\tmemcpy(pdu.cp.bcode, qos->bcast.bcode, sizeof(pdu.cp.bcode));\n\tpdu.cp.mse = qos->bcast.mse;\n\tpdu.cp.timeout = cpu_to_le16(qos->bcast.timeout);\n\tpdu.cp.num_bis = num_bis;\n\tmemcpy(pdu.bis, bis, num_bis);\n\n\treturn hci_send_cmd(hdev, HCI_OP_LE_BIG_CREATE_SYNC,\n\t\t\t    sizeof(pdu.cp) + num_bis, &pdu);\n}\n\nstatic void create_big_complete(struct hci_dev *hdev, void *data, int err)\n{\n\tstruct hci_conn *conn = data;\n\n\tbt_dev_dbg(hdev, \"conn %p\", conn);\n\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Unable to create BIG: %d\", err);\n\t\thci_connect_cfm(conn, err);\n\t\thci_conn_del(conn);\n\t}\n}\n\nstruct hci_conn *hci_bind_bis(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t      struct bt_iso_qos *qos,\n\t\t\t      __u8 base_len, __u8 *base)\n{\n\tstruct hci_conn *conn;\n\t__u8 eir[HCI_MAX_PER_AD_LENGTH];\n\n\tif (base_len && base)\n\t\tbase_len = eir_append_service_data(eir, 0,  0x1851,\n\t\t\t\t\t\t   base, base_len);\n\n\t \n\tconn = hci_add_bis(hdev, dst, qos, base_len, eir);\n\tif (IS_ERR(conn))\n\t\treturn conn;\n\n\t \n\tconn->le_tx_phy = qos->bcast.out.phy;\n\tconn->le_tx_phy = qos->bcast.out.phy;\n\n\t \n\tif (base_len && base) {\n\t\tmemcpy(conn->le_per_adv_data,  eir, sizeof(eir));\n\t\tconn->le_per_adv_data_len = base_len;\n\t}\n\n\thci_iso_qos_setup(hdev, conn, &qos->bcast.out,\n\t\t\t  conn->le_tx_phy ? conn->le_tx_phy :\n\t\t\t  hdev->le_tx_def_phys);\n\n\tconn->iso_qos = *qos;\n\tconn->state = BT_BOUND;\n\n\treturn conn;\n}\n\nstatic void bis_mark_per_adv(struct hci_conn *conn, void *data)\n{\n\tstruct iso_list_data *d = data;\n\n\t \n\tif (bacmp(&conn->dst, BDADDR_ANY))\n\t\treturn;\n\n\tif (d->big != conn->iso_qos.bcast.big ||\n\t    d->bis == BT_ISO_QOS_BIS_UNSET ||\n\t    d->bis != conn->iso_qos.bcast.bis)\n\t\treturn;\n\n\tset_bit(HCI_CONN_PER_ADV, &conn->flags);\n}\n\nstruct hci_conn *hci_connect_bis(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\t __u8 dst_type, struct bt_iso_qos *qos,\n\t\t\t\t __u8 base_len, __u8 *base)\n{\n\tstruct hci_conn *conn;\n\tint err;\n\tstruct iso_list_data data;\n\n\tconn = hci_bind_bis(hdev, dst, qos, base_len, base);\n\tif (IS_ERR(conn))\n\t\treturn conn;\n\n\tdata.big = qos->bcast.big;\n\tdata.bis = qos->bcast.bis;\n\n\t \n\thci_conn_hash_list_state(hdev, bis_mark_per_adv, ISO_LINK,\n\t\t\t\t BT_BOUND, &data);\n\n\t \n\terr = hci_cmd_sync_queue(hdev, create_big_sync, conn,\n\t\t\t\t create_big_complete);\n\tif (err < 0) {\n\t\thci_conn_drop(conn);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn conn;\n}\n\nstruct hci_conn *hci_connect_cis(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\t __u8 dst_type, struct bt_iso_qos *qos)\n{\n\tstruct hci_conn *le;\n\tstruct hci_conn *cis;\n\tstruct hci_link *link;\n\n\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\tle = hci_connect_le(hdev, dst, dst_type, false,\n\t\t\t\t    BT_SECURITY_LOW,\n\t\t\t\t    HCI_LE_CONN_TIMEOUT,\n\t\t\t\t    HCI_ROLE_SLAVE);\n\telse\n\t\tle = hci_connect_le_scan(hdev, dst, dst_type,\n\t\t\t\t\t BT_SECURITY_LOW,\n\t\t\t\t\t HCI_LE_CONN_TIMEOUT,\n\t\t\t\t\t CONN_REASON_ISO_CONNECT);\n\tif (IS_ERR(le))\n\t\treturn le;\n\n\thci_iso_qos_setup(hdev, le, &qos->ucast.out,\n\t\t\t  le->le_tx_phy ? le->le_tx_phy : hdev->le_tx_def_phys);\n\thci_iso_qos_setup(hdev, le, &qos->ucast.in,\n\t\t\t  le->le_rx_phy ? le->le_rx_phy : hdev->le_rx_def_phys);\n\n\tcis = hci_bind_cis(hdev, dst, dst_type, qos);\n\tif (IS_ERR(cis)) {\n\t\thci_conn_drop(le);\n\t\treturn cis;\n\t}\n\n\tlink = hci_conn_link(le, cis);\n\tif (!link) {\n\t\thci_conn_drop(le);\n\t\thci_conn_drop(cis);\n\t\treturn ERR_PTR(-ENOLINK);\n\t}\n\n\t \n\thci_conn_drop(cis);\n\n\tcis->state = BT_CONNECT;\n\n\thci_le_create_cis_pending(hdev);\n\n\treturn cis;\n}\n\n \nint hci_conn_check_link_mode(struct hci_conn *conn)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\n\t \n\tif (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {\n\t\tif (!hci_conn_sc_enabled(conn) ||\n\t\t    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||\n\t\t    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)\n\t\t\treturn 0;\n\t}\n\n\t  \n\tif (conn->sec_level == BT_SECURITY_FIPS &&\n\t    !test_bit(HCI_CONN_AES_CCM, &conn->flags)) {\n\t\tbt_dev_err(conn->hdev,\n\t\t\t   \"Invalid security: Missing AES-CCM usage\");\n\t\treturn 0;\n\t}\n\n\tif (hci_conn_ssp_enabled(conn) &&\n\t    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\n\tif (conn->pending_sec_level > sec_level)\n\t\tsec_level = conn->pending_sec_level;\n\n\tif (sec_level > conn->sec_level)\n\t\tconn->pending_sec_level = sec_level;\n\telse if (test_bit(HCI_CONN_AUTH, &conn->flags))\n\t\treturn 1;\n\n\t \n\tauth_type |= (conn->auth_type & 0x01);\n\n\tconn->auth_type = auth_type;\n\n\tif (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {\n\t\tstruct hci_cp_auth_requested cp;\n\n\t\tcp.handle = cpu_to_le16(conn->handle);\n\t\thci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,\n\t\t\t     sizeof(cp), &cp);\n\n\t\t \n\t\tif (!test_bit(HCI_CONN_ENCRYPT, &conn->flags))\n\t\t\tset_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void hci_conn_encrypt(struct hci_conn *conn)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\n\tif (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {\n\t\tstruct hci_cp_set_conn_encrypt cp;\n\t\tcp.handle  = cpu_to_le16(conn->handle);\n\t\tcp.encrypt = 0x01;\n\t\thci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),\n\t\t\t     &cp);\n\t}\n}\n\n \nint hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,\n\t\t      bool initiator)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\n\tif (conn->type == LE_LINK)\n\t\treturn smp_conn_security(conn, sec_level);\n\n\t \n\tif (sec_level == BT_SECURITY_SDP)\n\t\treturn 1;\n\n\t \n\tif (sec_level == BT_SECURITY_LOW && !hci_conn_ssp_enabled(conn))\n\t\treturn 1;\n\n\t \n\tif (!test_bit(HCI_CONN_AUTH, &conn->flags))\n\t\tgoto auth;\n\n\tswitch (conn->key_type) {\n\tcase HCI_LK_AUTH_COMBINATION_P256:\n\t\t \n\t\tif (sec_level <= BT_SECURITY_FIPS)\n\t\t\tgoto encrypt;\n\t\tbreak;\n\tcase HCI_LK_AUTH_COMBINATION_P192:\n\t\t \n\t\tif (sec_level <= BT_SECURITY_HIGH)\n\t\t\tgoto encrypt;\n\t\tbreak;\n\tcase HCI_LK_UNAUTH_COMBINATION_P192:\n\tcase HCI_LK_UNAUTH_COMBINATION_P256:\n\t\t \n\t\tif (sec_level <= BT_SECURITY_MEDIUM)\n\t\t\tgoto encrypt;\n\t\tbreak;\n\tcase HCI_LK_COMBINATION:\n\t\t \n\t\tif (sec_level <= BT_SECURITY_MEDIUM || conn->pin_length == 16)\n\t\t\tgoto encrypt;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nauth:\n\tif (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))\n\t\treturn 0;\n\n\tif (initiator)\n\t\tset_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags);\n\n\tif (!hci_conn_auth(conn, sec_level, auth_type))\n\t\treturn 0;\n\nencrypt:\n\tif (test_bit(HCI_CONN_ENCRYPT, &conn->flags)) {\n\t\t \n\t\tif (!conn->enc_key_size)\n\t\t\treturn 0;\n\n\t\t \n\t\treturn 1;\n\t}\n\n\thci_conn_encrypt(conn);\n\treturn 0;\n}\nEXPORT_SYMBOL(hci_conn_security);\n\n \nint hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\n\t \n\tif (sec_level != BT_SECURITY_HIGH && sec_level != BT_SECURITY_FIPS)\n\t\treturn 1;\n\n\t \n\tif (conn->sec_level == BT_SECURITY_HIGH ||\n\t    conn->sec_level == BT_SECURITY_FIPS)\n\t\treturn 1;\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL(hci_conn_check_secure);\n\n \nint hci_conn_switch_role(struct hci_conn *conn, __u8 role)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\n\tif (role == conn->role)\n\t\treturn 1;\n\n\tif (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->flags)) {\n\t\tstruct hci_cp_switch_role cp;\n\t\tbacpy(&cp.bdaddr, &conn->dst);\n\t\tcp.role = role;\n\t\thci_send_cmd(conn->hdev, HCI_OP_SWITCH_ROLE, sizeof(cp), &cp);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hci_conn_switch_role);\n\n \nvoid hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tBT_DBG(\"hcon %p mode %d\", conn, conn->mode);\n\n\tif (conn->mode != HCI_CM_SNIFF)\n\t\tgoto timer;\n\n\tif (!test_bit(HCI_CONN_POWER_SAVE, &conn->flags) && !force_active)\n\t\tgoto timer;\n\n\tif (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {\n\t\tstruct hci_cp_exit_sniff_mode cp;\n\t\tcp.handle = cpu_to_le16(conn->handle);\n\t\thci_send_cmd(hdev, HCI_OP_EXIT_SNIFF_MODE, sizeof(cp), &cp);\n\t}\n\ntimer:\n\tif (hdev->idle_timeout > 0)\n\t\tqueue_delayed_work(hdev->workqueue, &conn->idle_work,\n\t\t\t\t   msecs_to_jiffies(hdev->idle_timeout));\n}\n\n \nvoid hci_conn_hash_flush(struct hci_dev *hdev)\n{\n\tstruct list_head *head = &hdev->conn_hash.list;\n\tstruct hci_conn *conn;\n\n\tBT_DBG(\"hdev %s\", hdev->name);\n\n\t \n\twhile ((conn = list_first_entry_or_null(head,\n\t\t\t\t\t\tstruct hci_conn,\n\t\t\t\t\t\tlist)) != NULL) {\n\t\tconn->state = BT_CLOSED;\n\t\thci_disconn_cfm(conn, HCI_ERROR_LOCAL_HOST_TERM);\n\t\thci_conn_del(conn);\n\t}\n}\n\n \nvoid hci_conn_check_pending(struct hci_dev *hdev)\n{\n\tstruct hci_conn *conn;\n\n\tBT_DBG(\"hdev %s\", hdev->name);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_state(hdev, ACL_LINK, BT_CONNECT2);\n\tif (conn)\n\t\thci_acl_create_connection(conn);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic u32 get_link_mode(struct hci_conn *conn)\n{\n\tu32 link_mode = 0;\n\n\tif (conn->role == HCI_ROLE_MASTER)\n\t\tlink_mode |= HCI_LM_MASTER;\n\n\tif (test_bit(HCI_CONN_ENCRYPT, &conn->flags))\n\t\tlink_mode |= HCI_LM_ENCRYPT;\n\n\tif (test_bit(HCI_CONN_AUTH, &conn->flags))\n\t\tlink_mode |= HCI_LM_AUTH;\n\n\tif (test_bit(HCI_CONN_SECURE, &conn->flags))\n\t\tlink_mode |= HCI_LM_SECURE;\n\n\tif (test_bit(HCI_CONN_FIPS, &conn->flags))\n\t\tlink_mode |= HCI_LM_FIPS;\n\n\treturn link_mode;\n}\n\nint hci_get_conn_list(void __user *arg)\n{\n\tstruct hci_conn *c;\n\tstruct hci_conn_list_req req, *cl;\n\tstruct hci_conn_info *ci;\n\tstruct hci_dev *hdev;\n\tint n = 0, size, err;\n\n\tif (copy_from_user(&req, arg, sizeof(req)))\n\t\treturn -EFAULT;\n\n\tif (!req.conn_num || req.conn_num > (PAGE_SIZE * 2) / sizeof(*ci))\n\t\treturn -EINVAL;\n\n\tsize = sizeof(req) + req.conn_num * sizeof(*ci);\n\n\tcl = kmalloc(size, GFP_KERNEL);\n\tif (!cl)\n\t\treturn -ENOMEM;\n\n\thdev = hci_dev_get(req.dev_id);\n\tif (!hdev) {\n\t\tkfree(cl);\n\t\treturn -ENODEV;\n\t}\n\n\tci = cl->conn_info;\n\n\thci_dev_lock(hdev);\n\tlist_for_each_entry(c, &hdev->conn_hash.list, list) {\n\t\tbacpy(&(ci + n)->bdaddr, &c->dst);\n\t\t(ci + n)->handle = c->handle;\n\t\t(ci + n)->type  = c->type;\n\t\t(ci + n)->out   = c->out;\n\t\t(ci + n)->state = c->state;\n\t\t(ci + n)->link_mode = get_link_mode(c);\n\t\tif (++n >= req.conn_num)\n\t\t\tbreak;\n\t}\n\thci_dev_unlock(hdev);\n\n\tcl->dev_id = hdev->id;\n\tcl->conn_num = n;\n\tsize = sizeof(req) + n * sizeof(*ci);\n\n\thci_dev_put(hdev);\n\n\terr = copy_to_user(arg, cl, size);\n\tkfree(cl);\n\n\treturn err ? -EFAULT : 0;\n}\n\nint hci_get_conn_info(struct hci_dev *hdev, void __user *arg)\n{\n\tstruct hci_conn_info_req req;\n\tstruct hci_conn_info ci;\n\tstruct hci_conn *conn;\n\tchar __user *ptr = arg + sizeof(req);\n\n\tif (copy_from_user(&req, arg, sizeof(req)))\n\t\treturn -EFAULT;\n\n\thci_dev_lock(hdev);\n\tconn = hci_conn_hash_lookup_ba(hdev, req.type, &req.bdaddr);\n\tif (conn) {\n\t\tbacpy(&ci.bdaddr, &conn->dst);\n\t\tci.handle = conn->handle;\n\t\tci.type  = conn->type;\n\t\tci.out   = conn->out;\n\t\tci.state = conn->state;\n\t\tci.link_mode = get_link_mode(conn);\n\t}\n\thci_dev_unlock(hdev);\n\n\tif (!conn)\n\t\treturn -ENOENT;\n\n\treturn copy_to_user(ptr, &ci, sizeof(ci)) ? -EFAULT : 0;\n}\n\nint hci_get_auth_info(struct hci_dev *hdev, void __user *arg)\n{\n\tstruct hci_auth_info_req req;\n\tstruct hci_conn *conn;\n\n\tif (copy_from_user(&req, arg, sizeof(req)))\n\t\treturn -EFAULT;\n\n\thci_dev_lock(hdev);\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);\n\tif (conn)\n\t\treq.type = conn->auth_type;\n\thci_dev_unlock(hdev);\n\n\tif (!conn)\n\t\treturn -ENOENT;\n\n\treturn copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;\n}\n\nstruct hci_chan *hci_chan_create(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct hci_chan *chan;\n\n\tBT_DBG(\"%s hcon %p\", hdev->name, conn);\n\n\tif (test_bit(HCI_CONN_DROP, &conn->flags)) {\n\t\tBT_DBG(\"Refusing to create new hci_chan\");\n\t\treturn NULL;\n\t}\n\n\tchan = kzalloc(sizeof(*chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn NULL;\n\n\tchan->conn = hci_conn_get(conn);\n\tskb_queue_head_init(&chan->data_q);\n\tchan->state = BT_CONNECTED;\n\n\tlist_add_rcu(&chan->list, &conn->chan_list);\n\n\treturn chan;\n}\n\nvoid hci_chan_del(struct hci_chan *chan)\n{\n\tstruct hci_conn *conn = chan->conn;\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tBT_DBG(\"%s hcon %p chan %p\", hdev->name, conn, chan);\n\n\tlist_del_rcu(&chan->list);\n\n\tsynchronize_rcu();\n\n\t \n\tset_bit(HCI_CONN_DROP, &conn->flags);\n\n\thci_conn_put(conn);\n\n\tskb_queue_purge(&chan->data_q);\n\tkfree(chan);\n}\n\nvoid hci_chan_list_flush(struct hci_conn *conn)\n{\n\tstruct hci_chan *chan, *n;\n\n\tBT_DBG(\"hcon %p\", conn);\n\n\tlist_for_each_entry_safe(chan, n, &conn->chan_list, list)\n\t\thci_chan_del(chan);\n}\n\nstatic struct hci_chan *__hci_chan_lookup_handle(struct hci_conn *hcon,\n\t\t\t\t\t\t __u16 handle)\n{\n\tstruct hci_chan *hchan;\n\n\tlist_for_each_entry(hchan, &hcon->chan_list, list) {\n\t\tif (hchan->handle == handle)\n\t\t\treturn hchan;\n\t}\n\n\treturn NULL;\n}\n\nstruct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn *hcon;\n\tstruct hci_chan *hchan = NULL;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(hcon, &h->list, list) {\n\t\thchan = __hci_chan_lookup_handle(hcon, handle);\n\t\tif (hchan)\n\t\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\treturn hchan;\n}\n\nu32 hci_conn_get_phy(struct hci_conn *conn)\n{\n\tu32 phys = 0;\n\n\t \n\tswitch (conn->type) {\n\tcase SCO_LINK:\n\t\t \n\t\tphys |= BT_PHY_BR_1M_1SLOT;\n\n\t\tbreak;\n\n\tcase ACL_LINK:\n\t\t \n\t\tphys |= BT_PHY_BR_1M_1SLOT;\n\n\t\tif (conn->pkt_type & (HCI_DM3 | HCI_DH3))\n\t\t\tphys |= BT_PHY_BR_1M_3SLOT;\n\n\t\tif (conn->pkt_type & (HCI_DM5 | HCI_DH5))\n\t\t\tphys |= BT_PHY_BR_1M_5SLOT;\n\n\t\t \n\t\tif (!(conn->pkt_type & HCI_2DH1))\n\t\t\tphys |= BT_PHY_EDR_2M_1SLOT;\n\n\t\tif (!(conn->pkt_type & HCI_2DH3))\n\t\t\tphys |= BT_PHY_EDR_2M_3SLOT;\n\n\t\tif (!(conn->pkt_type & HCI_2DH5))\n\t\t\tphys |= BT_PHY_EDR_2M_5SLOT;\n\n\t\t \n\t\tif (!(conn->pkt_type & HCI_3DH1))\n\t\t\tphys |= BT_PHY_EDR_3M_1SLOT;\n\n\t\tif (!(conn->pkt_type & HCI_3DH3))\n\t\t\tphys |= BT_PHY_EDR_3M_3SLOT;\n\n\t\tif (!(conn->pkt_type & HCI_3DH5))\n\t\t\tphys |= BT_PHY_EDR_3M_5SLOT;\n\n\t\tbreak;\n\n\tcase ESCO_LINK:\n\t\t \n\t\tphys |= BT_PHY_BR_1M_1SLOT;\n\n\t\tif (!(conn->pkt_type & (ESCO_EV4 | ESCO_EV5)))\n\t\t\tphys |= BT_PHY_BR_1M_3SLOT;\n\n\t\t \n\t\tif (!(conn->pkt_type & ESCO_2EV3))\n\t\t\tphys |= BT_PHY_EDR_2M_1SLOT;\n\n\t\tif (!(conn->pkt_type & ESCO_2EV5))\n\t\t\tphys |= BT_PHY_EDR_2M_3SLOT;\n\n\t\t \n\t\tif (!(conn->pkt_type & ESCO_3EV3))\n\t\t\tphys |= BT_PHY_EDR_3M_1SLOT;\n\n\t\tif (!(conn->pkt_type & ESCO_3EV5))\n\t\t\tphys |= BT_PHY_EDR_3M_3SLOT;\n\n\t\tbreak;\n\n\tcase LE_LINK:\n\t\tif (conn->le_tx_phy & HCI_LE_SET_PHY_1M)\n\t\t\tphys |= BT_PHY_LE_1M_TX;\n\n\t\tif (conn->le_rx_phy & HCI_LE_SET_PHY_1M)\n\t\t\tphys |= BT_PHY_LE_1M_RX;\n\n\t\tif (conn->le_tx_phy & HCI_LE_SET_PHY_2M)\n\t\t\tphys |= BT_PHY_LE_2M_TX;\n\n\t\tif (conn->le_rx_phy & HCI_LE_SET_PHY_2M)\n\t\t\tphys |= BT_PHY_LE_2M_RX;\n\n\t\tif (conn->le_tx_phy & HCI_LE_SET_PHY_CODED)\n\t\t\tphys |= BT_PHY_LE_CODED_TX;\n\n\t\tif (conn->le_rx_phy & HCI_LE_SET_PHY_CODED)\n\t\t\tphys |= BT_PHY_LE_CODED_RX;\n\n\t\tbreak;\n\t}\n\n\treturn phys;\n}\n\nstatic int abort_conn_sync(struct hci_dev *hdev, void *data)\n{\n\tstruct hci_conn *conn;\n\tu16 handle = PTR_UINT(data);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (!conn)\n\t\treturn 0;\n\n\treturn hci_abort_conn_sync(hdev, conn, conn->abort_reason);\n}\n\nint hci_abort_conn(struct hci_conn *conn, u8 reason)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\t \n\tif (conn->abort_reason)\n\t\treturn 0;\n\n\tbt_dev_dbg(hdev, \"handle 0x%2.2x reason 0x%2.2x\", conn->handle, reason);\n\n\tconn->abort_reason = reason;\n\n\t \n\tif (conn->state == BT_CONNECT && hdev->req_status == HCI_REQ_PEND) {\n\t\tswitch (hci_skb_event(hdev->sent_cmd)) {\n\t\tcase HCI_EV_LE_CONN_COMPLETE:\n\t\tcase HCI_EV_LE_ENHANCED_CONN_COMPLETE:\n\t\tcase HCI_EVT_LE_CIS_ESTABLISHED:\n\t\t\thci_cmd_sync_cancel(hdev, -ECANCELED);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn hci_cmd_sync_queue(hdev, abort_conn_sync, UINT_PTR(conn->handle),\n\t\t\t\t  NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}