{
  "module_name": "eir.c",
  "hash_id": "760734b132ba28676986f427448958b221ace12934fd810ae86b0a953b53f582",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/eir.c",
  "human_readable_source": "\n \n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/mgmt.h>\n\n#include \"eir.h\"\n\n#define PNP_INFO_SVCLASS_ID\t\t0x1200\n\nstatic u8 eir_append_name(u8 *eir, u16 eir_len, u8 type, u8 *data, u8 data_len)\n{\n\tu8 name[HCI_MAX_SHORT_NAME_LENGTH + 1];\n\n\t \n\tif (data[data_len - 1] == '\\0')\n\t\treturn eir_append_data(eir, eir_len, type, data, data_len);\n\n\tmemcpy(name, data, HCI_MAX_SHORT_NAME_LENGTH);\n\tname[HCI_MAX_SHORT_NAME_LENGTH] = '\\0';\n\n\treturn eir_append_data(eir, eir_len, type, name, sizeof(name));\n}\n\nu8 eir_append_local_name(struct hci_dev *hdev, u8 *ptr, u8 ad_len)\n{\n\tsize_t short_len;\n\tsize_t complete_len;\n\n\t \n\tif ((max_adv_len(hdev) - ad_len) < HCI_MAX_SHORT_NAME_LENGTH + 3)\n\t\treturn ad_len;\n\n\t \n\tcomplete_len = strnlen(hdev->dev_name, sizeof(hdev->dev_name));\n\tif (complete_len && complete_len <= HCI_MAX_SHORT_NAME_LENGTH)\n\t\treturn eir_append_name(ptr, ad_len, EIR_NAME_COMPLETE,\n\t\t\t\t       hdev->dev_name, complete_len + 1);\n\n\t \n\tshort_len = strnlen(hdev->short_name, sizeof(hdev->short_name));\n\tif (short_len)\n\t\treturn eir_append_name(ptr, ad_len, EIR_NAME_SHORT,\n\t\t\t\t       hdev->short_name,\n\t\t\t\t       short_len == HCI_MAX_SHORT_NAME_LENGTH ?\n\t\t\t\t       short_len : short_len + 1);\n\n\t \n\tif (complete_len)\n\t\treturn eir_append_name(ptr, ad_len, EIR_NAME_SHORT,\n\t\t\t\t       hdev->dev_name,\n\t\t\t\t       HCI_MAX_SHORT_NAME_LENGTH);\n\n\treturn ad_len;\n}\n\nu8 eir_append_appearance(struct hci_dev *hdev, u8 *ptr, u8 ad_len)\n{\n\treturn eir_append_le16(ptr, ad_len, EIR_APPEARANCE, hdev->appearance);\n}\n\nu8 eir_append_service_data(u8 *eir, u16 eir_len, u16 uuid, u8 *data,\n\t\t\t   u8 data_len)\n{\n\teir[eir_len++] = sizeof(u8) + sizeof(uuid) + data_len;\n\teir[eir_len++] = EIR_SERVICE_DATA;\n\tput_unaligned_le16(uuid, &eir[eir_len]);\n\teir_len += sizeof(uuid);\n\tmemcpy(&eir[eir_len], data, data_len);\n\teir_len += data_len;\n\n\treturn eir_len;\n}\n\nstatic u8 *create_uuid16_list(struct hci_dev *hdev, u8 *data, ptrdiff_t len)\n{\n\tu8 *ptr = data, *uuids_start = NULL;\n\tstruct bt_uuid *uuid;\n\n\tif (len < 4)\n\t\treturn ptr;\n\n\tlist_for_each_entry(uuid, &hdev->uuids, list) {\n\t\tu16 uuid16;\n\n\t\tif (uuid->size != 16)\n\t\t\tcontinue;\n\n\t\tuuid16 = get_unaligned_le16(&uuid->uuid[12]);\n\t\tif (uuid16 < 0x1100)\n\t\t\tcontinue;\n\n\t\tif (uuid16 == PNP_INFO_SVCLASS_ID)\n\t\t\tcontinue;\n\n\t\tif (!uuids_start) {\n\t\t\tuuids_start = ptr;\n\t\t\tuuids_start[0] = 1;\n\t\t\tuuids_start[1] = EIR_UUID16_ALL;\n\t\t\tptr += 2;\n\t\t}\n\n\t\t \n\t\tif ((ptr - data) + sizeof(u16) > len) {\n\t\t\tuuids_start[1] = EIR_UUID16_SOME;\n\t\t\tbreak;\n\t\t}\n\n\t\t*ptr++ = (uuid16 & 0x00ff);\n\t\t*ptr++ = (uuid16 & 0xff00) >> 8;\n\t\tuuids_start[0] += sizeof(uuid16);\n\t}\n\n\treturn ptr;\n}\n\nstatic u8 *create_uuid32_list(struct hci_dev *hdev, u8 *data, ptrdiff_t len)\n{\n\tu8 *ptr = data, *uuids_start = NULL;\n\tstruct bt_uuid *uuid;\n\n\tif (len < 6)\n\t\treturn ptr;\n\n\tlist_for_each_entry(uuid, &hdev->uuids, list) {\n\t\tif (uuid->size != 32)\n\t\t\tcontinue;\n\n\t\tif (!uuids_start) {\n\t\t\tuuids_start = ptr;\n\t\t\tuuids_start[0] = 1;\n\t\t\tuuids_start[1] = EIR_UUID32_ALL;\n\t\t\tptr += 2;\n\t\t}\n\n\t\t \n\t\tif ((ptr - data) + sizeof(u32) > len) {\n\t\t\tuuids_start[1] = EIR_UUID32_SOME;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(ptr, &uuid->uuid[12], sizeof(u32));\n\t\tptr += sizeof(u32);\n\t\tuuids_start[0] += sizeof(u32);\n\t}\n\n\treturn ptr;\n}\n\nstatic u8 *create_uuid128_list(struct hci_dev *hdev, u8 *data, ptrdiff_t len)\n{\n\tu8 *ptr = data, *uuids_start = NULL;\n\tstruct bt_uuid *uuid;\n\n\tif (len < 18)\n\t\treturn ptr;\n\n\tlist_for_each_entry(uuid, &hdev->uuids, list) {\n\t\tif (uuid->size != 128)\n\t\t\tcontinue;\n\n\t\tif (!uuids_start) {\n\t\t\tuuids_start = ptr;\n\t\t\tuuids_start[0] = 1;\n\t\t\tuuids_start[1] = EIR_UUID128_ALL;\n\t\t\tptr += 2;\n\t\t}\n\n\t\t \n\t\tif ((ptr - data) + 16 > len) {\n\t\t\tuuids_start[1] = EIR_UUID128_SOME;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(ptr, uuid->uuid, 16);\n\t\tptr += 16;\n\t\tuuids_start[0] += 16;\n\t}\n\n\treturn ptr;\n}\n\nvoid eir_create(struct hci_dev *hdev, u8 *data)\n{\n\tu8 *ptr = data;\n\tsize_t name_len;\n\n\tname_len = strnlen(hdev->dev_name, sizeof(hdev->dev_name));\n\n\tif (name_len > 0) {\n\t\t \n\t\tif (name_len > 48) {\n\t\t\tname_len = 48;\n\t\t\tptr[1] = EIR_NAME_SHORT;\n\t\t} else {\n\t\t\tptr[1] = EIR_NAME_COMPLETE;\n\t\t}\n\n\t\t \n\t\tptr[0] = name_len + 1;\n\n\t\tmemcpy(ptr + 2, hdev->dev_name, name_len);\n\n\t\tptr += (name_len + 2);\n\t}\n\n\tif (hdev->inq_tx_power != HCI_TX_POWER_INVALID) {\n\t\tptr[0] = 2;\n\t\tptr[1] = EIR_TX_POWER;\n\t\tptr[2] = (u8)hdev->inq_tx_power;\n\n\t\tptr += 3;\n\t}\n\n\tif (hdev->devid_source > 0) {\n\t\tptr[0] = 9;\n\t\tptr[1] = EIR_DEVICE_ID;\n\n\t\tput_unaligned_le16(hdev->devid_source, ptr + 2);\n\t\tput_unaligned_le16(hdev->devid_vendor, ptr + 4);\n\t\tput_unaligned_le16(hdev->devid_product, ptr + 6);\n\t\tput_unaligned_le16(hdev->devid_version, ptr + 8);\n\n\t\tptr += 10;\n\t}\n\n\tptr = create_uuid16_list(hdev, ptr, HCI_MAX_EIR_LENGTH - (ptr - data));\n\tptr = create_uuid32_list(hdev, ptr, HCI_MAX_EIR_LENGTH - (ptr - data));\n\tptr = create_uuid128_list(hdev, ptr, HCI_MAX_EIR_LENGTH - (ptr - data));\n}\n\nu8 eir_create_per_adv_data(struct hci_dev *hdev, u8 instance, u8 *ptr)\n{\n\tstruct adv_info *adv = NULL;\n\tu8 ad_len = 0;\n\n\t \n\tif (instance) {\n\t\tadv = hci_find_adv_instance(hdev, instance);\n\t\tif (!adv)\n\t\t\treturn 0;\n\t}\n\n\tif (adv) {\n\t\tmemcpy(ptr, adv->per_adv_data, adv->per_adv_data_len);\n\t\tad_len += adv->per_adv_data_len;\n\t\tptr += adv->per_adv_data_len;\n\t}\n\n\treturn ad_len;\n}\n\nu8 eir_create_adv_data(struct hci_dev *hdev, u8 instance, u8 *ptr)\n{\n\tstruct adv_info *adv = NULL;\n\tu8 ad_len = 0, flags = 0;\n\tu32 instance_flags;\n\n\t \n\tif (instance) {\n\t\tadv = hci_find_adv_instance(hdev, instance);\n\t\tif (!adv)\n\t\t\treturn 0;\n\t}\n\n\tinstance_flags = hci_adv_instance_flags(hdev, instance);\n\n\t \n\tif (adv && eir_get_data(adv->adv_data, adv->adv_data_len, EIR_FLAGS,\n\t\t\t\tNULL))\n\t\tgoto skip_flags;\n\n\t \n\tif (instance_flags & MGMT_ADV_FLAG_DISCOV)\n\t\tflags |= LE_AD_GENERAL;\n\n\tif (instance_flags & MGMT_ADV_FLAG_LIMITED_DISCOV)\n\t\tflags |= LE_AD_LIMITED;\n\n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\tflags |= LE_AD_NO_BREDR;\n\n\tif (flags || (instance_flags & MGMT_ADV_FLAG_MANAGED_FLAGS)) {\n\t\t \n\t\tif (!flags)\n\t\t\tflags |= mgmt_get_adv_discov_flags(hdev);\n\n\t\t \n\t\tif (flags) {\n\t\t\tptr[0] = 0x02;\n\t\t\tptr[1] = EIR_FLAGS;\n\t\t\tptr[2] = flags;\n\n\t\t\tad_len += 3;\n\t\t\tptr += 3;\n\t\t}\n\t}\n\nskip_flags:\n\tif (adv) {\n\t\tmemcpy(ptr, adv->adv_data, adv->adv_data_len);\n\t\tad_len += adv->adv_data_len;\n\t\tptr += adv->adv_data_len;\n\t}\n\n\tif (instance_flags & MGMT_ADV_FLAG_TX_POWER) {\n\t\ts8 adv_tx_power;\n\n\t\tif (ext_adv_capable(hdev)) {\n\t\t\tif (adv)\n\t\t\t\tadv_tx_power = adv->tx_power;\n\t\t\telse\n\t\t\t\tadv_tx_power = hdev->adv_tx_power;\n\t\t} else {\n\t\t\tadv_tx_power = hdev->adv_tx_power;\n\t\t}\n\n\t\t \n\t\tif (adv_tx_power != HCI_TX_POWER_INVALID) {\n\t\t\tptr[0] = 0x02;\n\t\t\tptr[1] = EIR_TX_POWER;\n\t\t\tptr[2] = (u8)adv_tx_power;\n\n\t\t\tad_len += 3;\n\t\t\tptr += 3;\n\t\t}\n\t}\n\n\treturn ad_len;\n}\n\nstatic u8 create_default_scan_rsp(struct hci_dev *hdev, u8 *ptr)\n{\n\tu8 scan_rsp_len = 0;\n\n\tif (hdev->appearance)\n\t\tscan_rsp_len = eir_append_appearance(hdev, ptr, scan_rsp_len);\n\n\treturn eir_append_local_name(hdev, ptr, scan_rsp_len);\n}\n\nu8 eir_create_scan_rsp(struct hci_dev *hdev, u8 instance, u8 *ptr)\n{\n\tstruct adv_info *adv;\n\tu8 scan_rsp_len = 0;\n\n\tif (!instance)\n\t\treturn create_default_scan_rsp(hdev, ptr);\n\n\tadv = hci_find_adv_instance(hdev, instance);\n\tif (!adv)\n\t\treturn 0;\n\n\tif ((adv->flags & MGMT_ADV_FLAG_APPEARANCE) && hdev->appearance)\n\t\tscan_rsp_len = eir_append_appearance(hdev, ptr, scan_rsp_len);\n\n\tmemcpy(&ptr[scan_rsp_len], adv->scan_rsp_data, adv->scan_rsp_len);\n\n\tscan_rsp_len += adv->scan_rsp_len;\n\n\tif (adv->flags & MGMT_ADV_FLAG_LOCAL_NAME)\n\t\tscan_rsp_len = eir_append_local_name(hdev, ptr, scan_rsp_len);\n\n\treturn scan_rsp_len;\n}\n\nvoid *eir_get_service_data(u8 *eir, size_t eir_len, u16 uuid, size_t *len)\n{\n\twhile ((eir = eir_get_data(eir, eir_len, EIR_SERVICE_DATA, len))) {\n\t\tu16 value = get_unaligned_le16(eir);\n\n\t\tif (uuid == value) {\n\t\t\tif (len)\n\t\t\t\t*len -= 2;\n\t\t\treturn &eir[2];\n\t\t}\n\n\t\teir += *len;\n\t\teir_len -= *len;\n\t}\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}