{
  "module_name": "smp.c",
  "hash_id": "850b3696d35d67d9628bee3122a6f53ee6c7f6b23cace939ab2c4234314f3ed5",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/smp.c",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <crypto/aes.h>\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <crypto/kpp.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n#include <net/bluetooth/mgmt.h>\n\n#include \"ecdh_helper.h\"\n#include \"smp.h\"\n\n#define SMP_DEV(hdev) \\\n\t((struct smp_dev *)((struct l2cap_chan *)((hdev)->smp_data))->data)\n\n \n#ifdef DEBUG\n#define SMP_DBG(fmt, ...) printk(KERN_DEBUG \"%s: \" fmt, __func__, \\\n\t\t\t\t ##__VA_ARGS__)\n#else\n#define SMP_DBG(fmt, ...) no_printk(KERN_DEBUG \"%s: \" fmt, __func__, \\\n\t\t\t\t    ##__VA_ARGS__)\n#endif\n\n#define SMP_ALLOW_CMD(smp, code)\tset_bit(code, &smp->allow_cmd)\n\n \n#define SMP_SC_NO_DIST (SMP_DIST_ENC_KEY | SMP_DIST_LINK_KEY)\n\n#define SMP_TIMEOUT\tmsecs_to_jiffies(30000)\n\n#define ID_ADDR_TIMEOUT\tmsecs_to_jiffies(200)\n\n#define AUTH_REQ_MASK(dev)\t(hci_dev_test_flag(dev, HCI_SC_ENABLED) ? \\\n\t\t\t\t 0x3f : 0x07)\n#define KEY_DIST_MASK\t\t0x07\n\n \n#define CMAC_MSG_MAX\t80\n\nenum {\n\tSMP_FLAG_TK_VALID,\n\tSMP_FLAG_CFM_PENDING,\n\tSMP_FLAG_MITM_AUTH,\n\tSMP_FLAG_COMPLETE,\n\tSMP_FLAG_INITIATOR,\n\tSMP_FLAG_SC,\n\tSMP_FLAG_REMOTE_PK,\n\tSMP_FLAG_DEBUG_KEY,\n\tSMP_FLAG_WAIT_USER,\n\tSMP_FLAG_DHKEY_PENDING,\n\tSMP_FLAG_REMOTE_OOB,\n\tSMP_FLAG_LOCAL_OOB,\n\tSMP_FLAG_CT2,\n};\n\nstruct smp_dev {\n\t \n\tbool\t\t\tlocal_oob;\n\tu8\t\t\tlocal_pk[64];\n\tu8\t\t\tlocal_rand[16];\n\tbool\t\t\tdebug_key;\n\n\tstruct crypto_shash\t*tfm_cmac;\n\tstruct crypto_kpp\t*tfm_ecdh;\n};\n\nstruct smp_chan {\n\tstruct l2cap_conn\t*conn;\n\tstruct delayed_work\tsecurity_timer;\n\tunsigned long           allow_cmd;  \n\n\tu8\t\tpreq[7];  \n\tu8\t\tprsp[7];  \n\tu8\t\tprnd[16];  \n\tu8\t\trrnd[16];  \n\tu8\t\tpcnf[16];  \n\tu8\t\ttk[16];  \n\tu8\t\trr[16];  \n\tu8\t\tlr[16];  \n\tu8\t\tenc_key_size;\n\tu8\t\tremote_key_dist;\n\tbdaddr_t\tid_addr;\n\tu8\t\tid_addr_type;\n\tu8\t\tirk[16];\n\tstruct smp_csrk\t*csrk;\n\tstruct smp_csrk\t*responder_csrk;\n\tstruct smp_ltk\t*ltk;\n\tstruct smp_ltk\t*responder_ltk;\n\tstruct smp_irk\t*remote_irk;\n\tu8\t\t*link_key;\n\tunsigned long\tflags;\n\tu8\t\tmethod;\n\tu8\t\tpasskey_round;\n\n\t \n\tu8\t\t\tlocal_pk[64];\n\tu8\t\t\tremote_pk[64];\n\tu8\t\t\tdhkey[32];\n\tu8\t\t\tmackey[16];\n\n\tstruct crypto_shash\t*tfm_cmac;\n\tstruct crypto_kpp\t*tfm_ecdh;\n};\n\n \nstatic const u8 debug_pk[64] = {\n\t\t0xe6, 0x9d, 0x35, 0x0e, 0x48, 0x01, 0x03, 0xcc,\n\t\t0xdb, 0xfd, 0xf4, 0xac, 0x11, 0x91, 0xf4, 0xef,\n\t\t0xb9, 0xa5, 0xf9, 0xe9, 0xa7, 0x83, 0x2c, 0x5e,\n\t\t0x2c, 0xbe, 0x97, 0xf2, 0xd2, 0x03, 0xb0, 0x20,\n\n\t\t0x8b, 0xd2, 0x89, 0x15, 0xd0, 0x8e, 0x1c, 0x74,\n\t\t0x24, 0x30, 0xed, 0x8f, 0xc2, 0x45, 0x63, 0x76,\n\t\t0x5c, 0x15, 0x52, 0x5a, 0xbf, 0x9a, 0x32, 0x63,\n\t\t0x6d, 0xeb, 0x2a, 0x65, 0x49, 0x9c, 0x80, 0xdc,\n};\n\nstatic const u8 debug_sk[32] = {\n\t\t0xbd, 0x1a, 0x3c, 0xcd, 0xa6, 0xb8, 0x99, 0x58,\n\t\t0x99, 0xb7, 0x40, 0xeb, 0x7b, 0x60, 0xff, 0x4a,\n\t\t0x50, 0x3f, 0x10, 0xd2, 0xe3, 0xb3, 0xc9, 0x74,\n\t\t0x38, 0x5f, 0xc5, 0xa3, 0xd4, 0xf6, 0x49, 0x3f,\n};\n\nstatic inline void swap_buf(const u8 *src, u8 *dst, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[len - 1 - i] = src[i];\n}\n\n \n\nstatic int aes_cmac(struct crypto_shash *tfm, const u8 k[16], const u8 *m,\n\t\t    size_t len, u8 mac[16])\n{\n\tuint8_t tmp[16], mac_msb[16], msg_msb[CMAC_MSG_MAX];\n\tint err;\n\n\tif (len > CMAC_MSG_MAX)\n\t\treturn -EFBIG;\n\n\tif (!tfm) {\n\t\tBT_ERR(\"tfm %p\", tfm);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswap_buf(k, tmp, 16);\n\tswap_buf(m, msg_msb, len);\n\n\tSMP_DBG(\"msg (len %zu) %*phN\", len, (int) len, m);\n\tSMP_DBG(\"key %16phN\", k);\n\n\terr = crypto_shash_setkey(tfm, tmp, 16);\n\tif (err) {\n\t\tBT_ERR(\"cipher setkey failed: %d\", err);\n\t\treturn err;\n\t}\n\n\terr = crypto_shash_tfm_digest(tfm, msg_msb, len, mac_msb);\n\tif (err) {\n\t\tBT_ERR(\"Hash computation error %d\", err);\n\t\treturn err;\n\t}\n\n\tswap_buf(mac_msb, mac, 16);\n\n\tSMP_DBG(\"mac %16phN\", mac);\n\n\treturn 0;\n}\n\nstatic int smp_f4(struct crypto_shash *tfm_cmac, const u8 u[32],\n\t\t  const u8 v[32], const u8 x[16], u8 z, u8 res[16])\n{\n\tu8 m[65];\n\tint err;\n\n\tSMP_DBG(\"u %32phN\", u);\n\tSMP_DBG(\"v %32phN\", v);\n\tSMP_DBG(\"x %16phN z %02x\", x, z);\n\n\tm[0] = z;\n\tmemcpy(m + 1, v, 32);\n\tmemcpy(m + 33, u, 32);\n\n\terr = aes_cmac(tfm_cmac, x, m, sizeof(m), res);\n\tif (err)\n\t\treturn err;\n\n\tSMP_DBG(\"res %16phN\", res);\n\n\treturn err;\n}\n\nstatic int smp_f5(struct crypto_shash *tfm_cmac, const u8 w[32],\n\t\t  const u8 n1[16], const u8 n2[16], const u8 a1[7],\n\t\t  const u8 a2[7], u8 mackey[16], u8 ltk[16])\n{\n\t \n\tconst u8 btle[4] = { 0x65, 0x6c, 0x74, 0x62 };\n\tconst u8 salt[16] = { 0xbe, 0x83, 0x60, 0x5a, 0xdb, 0x0b, 0x37, 0x60,\n\t\t\t      0x38, 0xa5, 0xf5, 0xaa, 0x91, 0x83, 0x88, 0x6c };\n\tconst u8 length[2] = { 0x00, 0x01 };\n\tu8 m[53], t[16];\n\tint err;\n\n\tSMP_DBG(\"w %32phN\", w);\n\tSMP_DBG(\"n1 %16phN n2 %16phN\", n1, n2);\n\tSMP_DBG(\"a1 %7phN a2 %7phN\", a1, a2);\n\n\terr = aes_cmac(tfm_cmac, salt, w, 32, t);\n\tif (err)\n\t\treturn err;\n\n\tSMP_DBG(\"t %16phN\", t);\n\n\tmemcpy(m, length, 2);\n\tmemcpy(m + 2, a2, 7);\n\tmemcpy(m + 9, a1, 7);\n\tmemcpy(m + 16, n2, 16);\n\tmemcpy(m + 32, n1, 16);\n\tmemcpy(m + 48, btle, 4);\n\n\tm[52] = 0;  \n\n\terr = aes_cmac(tfm_cmac, t, m, sizeof(m), mackey);\n\tif (err)\n\t\treturn err;\n\n\tSMP_DBG(\"mackey %16phN\", mackey);\n\n\tm[52] = 1;  \n\n\terr = aes_cmac(tfm_cmac, t, m, sizeof(m), ltk);\n\tif (err)\n\t\treturn err;\n\n\tSMP_DBG(\"ltk %16phN\", ltk);\n\n\treturn 0;\n}\n\nstatic int smp_f6(struct crypto_shash *tfm_cmac, const u8 w[16],\n\t\t  const u8 n1[16], const u8 n2[16], const u8 r[16],\n\t\t  const u8 io_cap[3], const u8 a1[7], const u8 a2[7],\n\t\t  u8 res[16])\n{\n\tu8 m[65];\n\tint err;\n\n\tSMP_DBG(\"w %16phN\", w);\n\tSMP_DBG(\"n1 %16phN n2 %16phN\", n1, n2);\n\tSMP_DBG(\"r %16phN io_cap %3phN a1 %7phN a2 %7phN\", r, io_cap, a1, a2);\n\n\tmemcpy(m, a2, 7);\n\tmemcpy(m + 7, a1, 7);\n\tmemcpy(m + 14, io_cap, 3);\n\tmemcpy(m + 17, r, 16);\n\tmemcpy(m + 33, n2, 16);\n\tmemcpy(m + 49, n1, 16);\n\n\terr = aes_cmac(tfm_cmac, w, m, sizeof(m), res);\n\tif (err)\n\t\treturn err;\n\n\tSMP_DBG(\"res %16phN\", res);\n\n\treturn err;\n}\n\nstatic int smp_g2(struct crypto_shash *tfm_cmac, const u8 u[32], const u8 v[32],\n\t\t  const u8 x[16], const u8 y[16], u32 *val)\n{\n\tu8 m[80], tmp[16];\n\tint err;\n\n\tSMP_DBG(\"u %32phN\", u);\n\tSMP_DBG(\"v %32phN\", v);\n\tSMP_DBG(\"x %16phN y %16phN\", x, y);\n\n\tmemcpy(m, y, 16);\n\tmemcpy(m + 16, v, 32);\n\tmemcpy(m + 48, u, 32);\n\n\terr = aes_cmac(tfm_cmac, x, m, sizeof(m), tmp);\n\tif (err)\n\t\treturn err;\n\n\t*val = get_unaligned_le32(tmp);\n\t*val %= 1000000;\n\n\tSMP_DBG(\"val %06u\", *val);\n\n\treturn 0;\n}\n\nstatic int smp_h6(struct crypto_shash *tfm_cmac, const u8 w[16],\n\t\t  const u8 key_id[4], u8 res[16])\n{\n\tint err;\n\n\tSMP_DBG(\"w %16phN key_id %4phN\", w, key_id);\n\n\terr = aes_cmac(tfm_cmac, w, key_id, 4, res);\n\tif (err)\n\t\treturn err;\n\n\tSMP_DBG(\"res %16phN\", res);\n\n\treturn err;\n}\n\nstatic int smp_h7(struct crypto_shash *tfm_cmac, const u8 w[16],\n\t\t  const u8 salt[16], u8 res[16])\n{\n\tint err;\n\n\tSMP_DBG(\"w %16phN salt %16phN\", w, salt);\n\n\terr = aes_cmac(tfm_cmac, salt, w, 16, res);\n\tif (err)\n\t\treturn err;\n\n\tSMP_DBG(\"res %16phN\", res);\n\n\treturn err;\n}\n\n \n\nstatic int smp_e(const u8 *k, u8 *r)\n{\n\tstruct crypto_aes_ctx ctx;\n\tuint8_t tmp[16], data[16];\n\tint err;\n\n\tSMP_DBG(\"k %16phN r %16phN\", k, r);\n\n\t \n\tswap_buf(k, tmp, 16);\n\n\terr = aes_expandkey(&ctx, tmp, 16);\n\tif (err) {\n\t\tBT_ERR(\"cipher setkey failed: %d\", err);\n\t\treturn err;\n\t}\n\n\t \n\tswap_buf(r, data, 16);\n\n\taes_encrypt(&ctx, data, data);\n\n\t \n\tswap_buf(data, r, 16);\n\n\tSMP_DBG(\"r %16phN\", r);\n\n\tmemzero_explicit(&ctx, sizeof(ctx));\n\treturn err;\n}\n\nstatic int smp_c1(const u8 k[16],\n\t\t  const u8 r[16], const u8 preq[7], const u8 pres[7], u8 _iat,\n\t\t  const bdaddr_t *ia, u8 _rat, const bdaddr_t *ra, u8 res[16])\n{\n\tu8 p1[16], p2[16];\n\tint err;\n\n\tSMP_DBG(\"k %16phN r %16phN\", k, r);\n\tSMP_DBG(\"iat %u ia %6phN rat %u ra %6phN\", _iat, ia, _rat, ra);\n\tSMP_DBG(\"preq %7phN pres %7phN\", preq, pres);\n\n\tmemset(p1, 0, 16);\n\n\t \n\tp1[0] = _iat;\n\tp1[1] = _rat;\n\tmemcpy(p1 + 2, preq, 7);\n\tmemcpy(p1 + 9, pres, 7);\n\n\tSMP_DBG(\"p1 %16phN\", p1);\n\n\t \n\tcrypto_xor_cpy(res, r, p1, sizeof(p1));\n\n\t \n\terr = smp_e(k, res);\n\tif (err) {\n\t\tBT_ERR(\"Encrypt data error\");\n\t\treturn err;\n\t}\n\n\t \n\tmemcpy(p2, ra, 6);\n\tmemcpy(p2 + 6, ia, 6);\n\tmemset(p2 + 12, 0, 4);\n\n\tSMP_DBG(\"p2 %16phN\", p2);\n\n\t \n\tcrypto_xor(res, p2, sizeof(p2));\n\n\t \n\terr = smp_e(k, res);\n\tif (err)\n\t\tBT_ERR(\"Encrypt data error\");\n\n\treturn err;\n}\n\nstatic int smp_s1(const u8 k[16],\n\t\t  const u8 r1[16], const u8 r2[16], u8 _r[16])\n{\n\tint err;\n\n\t \n\tmemcpy(_r, r2, 8);\n\tmemcpy(_r + 8, r1, 8);\n\n\terr = smp_e(k, _r);\n\tif (err)\n\t\tBT_ERR(\"Encrypt data error\");\n\n\treturn err;\n}\n\nstatic int smp_ah(const u8 irk[16], const u8 r[3], u8 res[3])\n{\n\tu8 _res[16];\n\tint err;\n\n\t \n\tmemcpy(_res, r, 3);\n\tmemset(_res + 3, 0, 13);\n\n\terr = smp_e(irk, _res);\n\tif (err) {\n\t\tBT_ERR(\"Encrypt error\");\n\t\treturn err;\n\t}\n\n\t \n\tmemcpy(res, _res, 3);\n\n\treturn 0;\n}\n\nbool smp_irk_matches(struct hci_dev *hdev, const u8 irk[16],\n\t\t     const bdaddr_t *bdaddr)\n{\n\tstruct l2cap_chan *chan = hdev->smp_data;\n\tu8 hash[3];\n\tint err;\n\n\tif (!chan || !chan->data)\n\t\treturn false;\n\n\tbt_dev_dbg(hdev, \"RPA %pMR IRK %*phN\", bdaddr, 16, irk);\n\n\terr = smp_ah(irk, &bdaddr->b[3], hash);\n\tif (err)\n\t\treturn false;\n\n\treturn !crypto_memneq(bdaddr->b, hash, 3);\n}\n\nint smp_generate_rpa(struct hci_dev *hdev, const u8 irk[16], bdaddr_t *rpa)\n{\n\tstruct l2cap_chan *chan = hdev->smp_data;\n\tint err;\n\n\tif (!chan || !chan->data)\n\t\treturn -EOPNOTSUPP;\n\n\tget_random_bytes(&rpa->b[3], 3);\n\n\trpa->b[5] &= 0x3f;\t \n\trpa->b[5] |= 0x40;\t \n\n\terr = smp_ah(irk, &rpa->b[3], rpa->b);\n\tif (err < 0)\n\t\treturn err;\n\n\tbt_dev_dbg(hdev, \"RPA %pMR\", rpa);\n\n\treturn 0;\n}\n\nint smp_generate_oob(struct hci_dev *hdev, u8 hash[16], u8 rand[16])\n{\n\tstruct l2cap_chan *chan = hdev->smp_data;\n\tstruct smp_dev *smp;\n\tint err;\n\n\tif (!chan || !chan->data)\n\t\treturn -EOPNOTSUPP;\n\n\tsmp = chan->data;\n\n\tif (hci_dev_test_flag(hdev, HCI_USE_DEBUG_KEYS)) {\n\t\tbt_dev_dbg(hdev, \"Using debug keys\");\n\t\terr = set_ecdh_privkey(smp->tfm_ecdh, debug_sk);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmemcpy(smp->local_pk, debug_pk, 64);\n\t\tsmp->debug_key = true;\n\t} else {\n\t\twhile (true) {\n\t\t\t \n\t\t\terr = generate_ecdh_keys(smp->tfm_ecdh, smp->local_pk);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\tif (crypto_memneq(smp->local_pk, debug_pk, 64))\n\t\t\t\tbreak;\n\t\t}\n\t\tsmp->debug_key = false;\n\t}\n\n\tSMP_DBG(\"OOB Public Key X: %32phN\", smp->local_pk);\n\tSMP_DBG(\"OOB Public Key Y: %32phN\", smp->local_pk + 32);\n\n\tget_random_bytes(smp->local_rand, 16);\n\n\terr = smp_f4(smp->tfm_cmac, smp->local_pk, smp->local_pk,\n\t\t     smp->local_rand, 0, hash);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemcpy(rand, smp->local_rand, 16);\n\n\tsmp->local_oob = true;\n\n\treturn 0;\n}\n\nstatic void smp_send_cmd(struct l2cap_conn *conn, u8 code, u16 len, void *data)\n{\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp;\n\tstruct kvec iv[2];\n\tstruct msghdr msg;\n\n\tif (!chan)\n\t\treturn;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"code 0x%2.2x\", code);\n\n\tiv[0].iov_base = &code;\n\tiv[0].iov_len = 1;\n\n\tiv[1].iov_base = data;\n\tiv[1].iov_len = len;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tiov_iter_kvec(&msg.msg_iter, ITER_SOURCE, iv, 2, 1 + len);\n\n\tl2cap_chan_send(chan, &msg, 1 + len);\n\n\tif (!chan->data)\n\t\treturn;\n\n\tsmp = chan->data;\n\n\tcancel_delayed_work_sync(&smp->security_timer);\n\tschedule_delayed_work(&smp->security_timer, SMP_TIMEOUT);\n}\n\nstatic u8 authreq_to_seclevel(u8 authreq)\n{\n\tif (authreq & SMP_AUTH_MITM) {\n\t\tif (authreq & SMP_AUTH_SC)\n\t\t\treturn BT_SECURITY_FIPS;\n\t\telse\n\t\t\treturn BT_SECURITY_HIGH;\n\t} else {\n\t\treturn BT_SECURITY_MEDIUM;\n\t}\n}\n\nstatic __u8 seclevel_to_authreq(__u8 sec_level)\n{\n\tswitch (sec_level) {\n\tcase BT_SECURITY_FIPS:\n\tcase BT_SECURITY_HIGH:\n\t\treturn SMP_AUTH_MITM | SMP_AUTH_BONDING;\n\tcase BT_SECURITY_MEDIUM:\n\t\treturn SMP_AUTH_BONDING;\n\tdefault:\n\t\treturn SMP_AUTH_NONE;\n\t}\n}\n\nstatic void build_pairing_cmd(struct l2cap_conn *conn,\n\t\t\t      struct smp_cmd_pairing *req,\n\t\t\t      struct smp_cmd_pairing *rsp, __u8 authreq)\n{\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\tu8 local_dist = 0, remote_dist = 0, oob_flag = SMP_OOB_NOT_PRESENT;\n\n\tif (hci_dev_test_flag(hdev, HCI_BONDABLE)) {\n\t\tlocal_dist = SMP_DIST_ENC_KEY | SMP_DIST_SIGN;\n\t\tremote_dist = SMP_DIST_ENC_KEY | SMP_DIST_SIGN;\n\t\tauthreq |= SMP_AUTH_BONDING;\n\t} else {\n\t\tauthreq &= ~SMP_AUTH_BONDING;\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_RPA_RESOLVING))\n\t\tremote_dist |= SMP_DIST_ID_KEY;\n\n\tif (hci_dev_test_flag(hdev, HCI_PRIVACY))\n\t\tlocal_dist |= SMP_DIST_ID_KEY;\n\n\tif (hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&\n\t    (authreq & SMP_AUTH_SC)) {\n\t\tstruct oob_data *oob_data;\n\t\tu8 bdaddr_type;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\n\t\t\tlocal_dist |= SMP_DIST_LINK_KEY;\n\t\t\tremote_dist |= SMP_DIST_LINK_KEY;\n\t\t}\n\n\t\tif (hcon->dst_type == ADDR_LE_DEV_PUBLIC)\n\t\t\tbdaddr_type = BDADDR_LE_PUBLIC;\n\t\telse\n\t\t\tbdaddr_type = BDADDR_LE_RANDOM;\n\n\t\toob_data = hci_find_remote_oob_data(hdev, &hcon->dst,\n\t\t\t\t\t\t    bdaddr_type);\n\t\tif (oob_data && oob_data->present) {\n\t\t\tset_bit(SMP_FLAG_REMOTE_OOB, &smp->flags);\n\t\t\toob_flag = SMP_OOB_PRESENT;\n\t\t\tmemcpy(smp->rr, oob_data->rand256, 16);\n\t\t\tmemcpy(smp->pcnf, oob_data->hash256, 16);\n\t\t\tSMP_DBG(\"OOB Remote Confirmation: %16phN\", smp->pcnf);\n\t\t\tSMP_DBG(\"OOB Remote Random: %16phN\", smp->rr);\n\t\t}\n\n\t} else {\n\t\tauthreq &= ~SMP_AUTH_SC;\n\t}\n\n\tif (rsp == NULL) {\n\t\treq->io_capability = conn->hcon->io_capability;\n\t\treq->oob_flag = oob_flag;\n\t\treq->max_key_size = hdev->le_max_key_size;\n\t\treq->init_key_dist = local_dist;\n\t\treq->resp_key_dist = remote_dist;\n\t\treq->auth_req = (authreq & AUTH_REQ_MASK(hdev));\n\n\t\tsmp->remote_key_dist = remote_dist;\n\t\treturn;\n\t}\n\n\trsp->io_capability = conn->hcon->io_capability;\n\trsp->oob_flag = oob_flag;\n\trsp->max_key_size = hdev->le_max_key_size;\n\trsp->init_key_dist = req->init_key_dist & remote_dist;\n\trsp->resp_key_dist = req->resp_key_dist & local_dist;\n\trsp->auth_req = (authreq & AUTH_REQ_MASK(hdev));\n\n\tsmp->remote_key_dist = rsp->init_key_dist;\n}\n\nstatic u8 check_enc_key_size(struct l2cap_conn *conn, __u8 max_key_size)\n{\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tstruct smp_chan *smp = chan->data;\n\n\tif (conn->hcon->pending_sec_level == BT_SECURITY_FIPS &&\n\t    max_key_size != SMP_MAX_ENC_KEY_SIZE)\n\t\treturn SMP_ENC_KEY_SIZE;\n\n\tif (max_key_size > hdev->le_max_key_size ||\n\t    max_key_size < SMP_MIN_ENC_KEY_SIZE)\n\t\treturn SMP_ENC_KEY_SIZE;\n\n\tsmp->enc_key_size = max_key_size;\n\n\treturn 0;\n}\n\nstatic void smp_chan_destroy(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tbool complete;\n\n\tBUG_ON(!smp);\n\n\tcancel_delayed_work_sync(&smp->security_timer);\n\n\tcomplete = test_bit(SMP_FLAG_COMPLETE, &smp->flags);\n\tmgmt_smp_complete(hcon, complete);\n\n\tkfree_sensitive(smp->csrk);\n\tkfree_sensitive(smp->responder_csrk);\n\tkfree_sensitive(smp->link_key);\n\n\tcrypto_free_shash(smp->tfm_cmac);\n\tcrypto_free_kpp(smp->tfm_ecdh);\n\n\t \n\tif (smp->ltk && smp->ltk->type == SMP_LTK_P256_DEBUG &&\n\t    !hci_dev_test_flag(hcon->hdev, HCI_KEEP_DEBUG_KEYS)) {\n\t\tlist_del_rcu(&smp->ltk->list);\n\t\tkfree_rcu(smp->ltk, rcu);\n\t\tsmp->ltk = NULL;\n\t}\n\n\t \n\tif (!complete) {\n\t\tif (smp->ltk) {\n\t\t\tlist_del_rcu(&smp->ltk->list);\n\t\t\tkfree_rcu(smp->ltk, rcu);\n\t\t}\n\n\t\tif (smp->responder_ltk) {\n\t\t\tlist_del_rcu(&smp->responder_ltk->list);\n\t\t\tkfree_rcu(smp->responder_ltk, rcu);\n\t\t}\n\n\t\tif (smp->remote_irk) {\n\t\t\tlist_del_rcu(&smp->remote_irk->list);\n\t\t\tkfree_rcu(smp->remote_irk, rcu);\n\t\t}\n\t}\n\n\tchan->data = NULL;\n\tkfree_sensitive(smp);\n\thci_conn_drop(hcon);\n}\n\nstatic void smp_failure(struct l2cap_conn *conn, u8 reason)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan = conn->smp;\n\n\tif (reason)\n\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason),\n\t\t\t     &reason);\n\n\tmgmt_auth_failed(hcon, HCI_ERROR_AUTH_FAILURE);\n\n\tif (chan->data)\n\t\tsmp_chan_destroy(conn);\n}\n\n#define JUST_WORKS\t0x00\n#define JUST_CFM\t0x01\n#define REQ_PASSKEY\t0x02\n#define CFM_PASSKEY\t0x03\n#define REQ_OOB\t\t0x04\n#define DSP_PASSKEY\t0x05\n#define OVERLAP\t\t0xFF\n\nstatic const u8 gen_method[5][5] = {\n\t{ JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY },\n\t{ JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY },\n\t{ CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, CFM_PASSKEY },\n\t{ JUST_WORKS,  JUST_CFM,    JUST_WORKS,  JUST_WORKS, JUST_CFM    },\n\t{ CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, OVERLAP     },\n};\n\nstatic const u8 sc_method[5][5] = {\n\t{ JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY },\n\t{ JUST_WORKS,  CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, CFM_PASSKEY },\n\t{ DSP_PASSKEY, DSP_PASSKEY, REQ_PASSKEY, JUST_WORKS, DSP_PASSKEY },\n\t{ JUST_WORKS,  JUST_CFM,    JUST_WORKS,  JUST_WORKS, JUST_CFM    },\n\t{ DSP_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, CFM_PASSKEY },\n};\n\nstatic u8 get_auth_method(struct smp_chan *smp, u8 local_io, u8 remote_io)\n{\n\t \n\tif (local_io > SMP_IO_KEYBOARD_DISPLAY ||\n\t    remote_io > SMP_IO_KEYBOARD_DISPLAY)\n\t\treturn JUST_CFM;\n\n\tif (test_bit(SMP_FLAG_SC, &smp->flags))\n\t\treturn sc_method[remote_io][local_io];\n\n\treturn gen_method[remote_io][local_io];\n}\n\nstatic int tk_request(struct l2cap_conn *conn, u8 remote_oob, u8 auth,\n\t\t\t\t\t\tu8 local_io, u8 remote_io)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tu32 passkey = 0;\n\tint ret;\n\n\t \n\tmemset(smp->tk, 0, sizeof(smp->tk));\n\tclear_bit(SMP_FLAG_TK_VALID, &smp->flags);\n\n\tbt_dev_dbg(hcon->hdev, \"auth:%u lcl:%u rem:%u\", auth, local_io,\n\t\t   remote_io);\n\n\t \n\tif (!(auth & SMP_AUTH_MITM))\n\t\tsmp->method = JUST_CFM;\n\telse\n\t\tsmp->method = get_auth_method(smp, local_io, remote_io);\n\n\t \n\tif (smp->method == JUST_CFM && test_bit(SMP_FLAG_INITIATOR,\n\t\t\t\t\t\t&smp->flags))\n\t\tsmp->method = JUST_WORKS;\n\n\t \n\tif (smp->method == JUST_CFM &&\n\t    hcon->io_capability == HCI_IO_NO_INPUT_OUTPUT)\n\t\tsmp->method = JUST_WORKS;\n\n\t \n\tif (smp->method == JUST_WORKS) {\n\t\tret = mgmt_user_confirm_request(hcon->hdev, &hcon->dst,\n\t\t\t\t\t\thcon->type,\n\t\t\t\t\t\thcon->dst_type,\n\t\t\t\t\t\tpasskey, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tset_bit(SMP_FLAG_WAIT_USER, &smp->flags);\n\t\treturn 0;\n\t}\n\n\t \n\tif (test_bit(SMP_FLAG_SC, &smp->flags))\n\t\treturn -EINVAL;\n\n\t \n\tif (smp->method != JUST_CFM) {\n\t\tset_bit(SMP_FLAG_MITM_AUTH, &smp->flags);\n\t\tif (hcon->pending_sec_level < BT_SECURITY_HIGH)\n\t\t\thcon->pending_sec_level = BT_SECURITY_HIGH;\n\t}\n\n\t \n\tif (smp->method == OVERLAP) {\n\t\tif (hcon->role == HCI_ROLE_MASTER)\n\t\t\tsmp->method = CFM_PASSKEY;\n\t\telse\n\t\t\tsmp->method = REQ_PASSKEY;\n\t}\n\n\t \n\tif (smp->method == CFM_PASSKEY) {\n\t\tmemset(smp->tk, 0, sizeof(smp->tk));\n\t\tget_random_bytes(&passkey, sizeof(passkey));\n\t\tpasskey %= 1000000;\n\t\tput_unaligned_le32(passkey, smp->tk);\n\t\tbt_dev_dbg(hcon->hdev, \"PassKey: %u\", passkey);\n\t\tset_bit(SMP_FLAG_TK_VALID, &smp->flags);\n\t}\n\n\tif (smp->method == REQ_PASSKEY)\n\t\tret = mgmt_user_passkey_request(hcon->hdev, &hcon->dst,\n\t\t\t\t\t\thcon->type, hcon->dst_type);\n\telse if (smp->method == JUST_CFM)\n\t\tret = mgmt_user_confirm_request(hcon->hdev, &hcon->dst,\n\t\t\t\t\t\thcon->type, hcon->dst_type,\n\t\t\t\t\t\tpasskey, 1);\n\telse\n\t\tret = mgmt_user_passkey_notify(hcon->hdev, &hcon->dst,\n\t\t\t\t\t\thcon->type, hcon->dst_type,\n\t\t\t\t\t\tpasskey, 0);\n\n\treturn ret;\n}\n\nstatic u8 smp_confirm(struct smp_chan *smp)\n{\n\tstruct l2cap_conn *conn = smp->conn;\n\tstruct smp_cmd_pairing_confirm cp;\n\tint ret;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"conn %p\", conn);\n\n\tret = smp_c1(smp->tk, smp->prnd, smp->preq, smp->prsp,\n\t\t     conn->hcon->init_addr_type, &conn->hcon->init_addr,\n\t\t     conn->hcon->resp_addr_type, &conn->hcon->resp_addr,\n\t\t     cp.confirm_val);\n\tif (ret)\n\t\treturn SMP_UNSPECIFIED;\n\n\tclear_bit(SMP_FLAG_CFM_PENDING, &smp->flags);\n\n\tsmp_send_cmd(smp->conn, SMP_CMD_PAIRING_CONFIRM, sizeof(cp), &cp);\n\n\tif (conn->hcon->out)\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_CONFIRM);\n\telse\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_RANDOM);\n\n\treturn 0;\n}\n\nstatic u8 smp_random(struct smp_chan *smp)\n{\n\tstruct l2cap_conn *conn = smp->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu8 confirm[16];\n\tint ret;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"conn %p %s\", conn,\n\t\t   conn->hcon->out ? \"initiator\" : \"responder\");\n\n\tret = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,\n\t\t     hcon->init_addr_type, &hcon->init_addr,\n\t\t     hcon->resp_addr_type, &hcon->resp_addr, confirm);\n\tif (ret)\n\t\treturn SMP_UNSPECIFIED;\n\n\tif (crypto_memneq(smp->pcnf, confirm, sizeof(smp->pcnf))) {\n\t\tbt_dev_err(hcon->hdev, \"pairing failed \"\n\t\t\t   \"(confirmation values mismatch)\");\n\t\treturn SMP_CONFIRM_FAILED;\n\t}\n\n\tif (hcon->out) {\n\t\tu8 stk[16];\n\t\t__le64 rand = 0;\n\t\t__le16 ediv = 0;\n\n\t\tsmp_s1(smp->tk, smp->rrnd, smp->prnd, stk);\n\n\t\tif (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->flags))\n\t\t\treturn SMP_UNSPECIFIED;\n\n\t\thci_le_start_enc(hcon, ediv, rand, stk, smp->enc_key_size);\n\t\thcon->enc_key_size = smp->enc_key_size;\n\t\tset_bit(HCI_CONN_STK_ENCRYPT, &hcon->flags);\n\t} else {\n\t\tu8 stk[16], auth;\n\t\t__le64 rand = 0;\n\t\t__le16 ediv = 0;\n\n\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(smp->prnd),\n\t\t\t     smp->prnd);\n\n\t\tsmp_s1(smp->tk, smp->prnd, smp->rrnd, stk);\n\n\t\tif (hcon->pending_sec_level == BT_SECURITY_HIGH)\n\t\t\tauth = 1;\n\t\telse\n\t\t\tauth = 0;\n\n\t\t \n\t\thci_add_ltk(hcon->hdev, &hcon->dst, hcon->dst_type,\n\t\t\t    SMP_STK, auth, stk, smp->enc_key_size, ediv, rand);\n\t}\n\n\treturn 0;\n}\n\nstatic void smp_notify_keys(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct smp_cmd_pairing *req = (void *) &smp->preq[1];\n\tstruct smp_cmd_pairing *rsp = (void *) &smp->prsp[1];\n\tbool persistent;\n\n\tif (hcon->type == ACL_LINK) {\n\t\tif (hcon->key_type == HCI_LK_DEBUG_COMBINATION)\n\t\t\tpersistent = false;\n\t\telse\n\t\t\tpersistent = !test_bit(HCI_CONN_FLUSH_KEY,\n\t\t\t\t\t       &hcon->flags);\n\t} else {\n\t\t \n\t\tpersistent = !!((req->auth_req & rsp->auth_req) &\n\t\t\t\tSMP_AUTH_BONDING);\n\t}\n\n\tif (smp->remote_irk) {\n\t\tsmp->remote_irk->link_type = hcon->type;\n\t\tmgmt_new_irk(hdev, smp->remote_irk, persistent);\n\n\t\t \n\t\tif (hcon->type == LE_LINK) {\n\t\t\tbacpy(&hcon->dst, &smp->remote_irk->bdaddr);\n\t\t\thcon->dst_type = smp->remote_irk->addr_type;\n\t\t\t \n\t\t\tqueue_delayed_work(hdev->workqueue,\n\t\t\t\t\t   &conn->id_addr_timer,\n\t\t\t\t\t   ID_ADDR_TIMEOUT);\n\t\t}\n\t}\n\n\tif (smp->csrk) {\n\t\tsmp->csrk->link_type = hcon->type;\n\t\tsmp->csrk->bdaddr_type = hcon->dst_type;\n\t\tbacpy(&smp->csrk->bdaddr, &hcon->dst);\n\t\tmgmt_new_csrk(hdev, smp->csrk, persistent);\n\t}\n\n\tif (smp->responder_csrk) {\n\t\tsmp->responder_csrk->link_type = hcon->type;\n\t\tsmp->responder_csrk->bdaddr_type = hcon->dst_type;\n\t\tbacpy(&smp->responder_csrk->bdaddr, &hcon->dst);\n\t\tmgmt_new_csrk(hdev, smp->responder_csrk, persistent);\n\t}\n\n\tif (smp->ltk) {\n\t\tsmp->ltk->link_type = hcon->type;\n\t\tsmp->ltk->bdaddr_type = hcon->dst_type;\n\t\tbacpy(&smp->ltk->bdaddr, &hcon->dst);\n\t\tmgmt_new_ltk(hdev, smp->ltk, persistent);\n\t}\n\n\tif (smp->responder_ltk) {\n\t\tsmp->responder_ltk->link_type = hcon->type;\n\t\tsmp->responder_ltk->bdaddr_type = hcon->dst_type;\n\t\tbacpy(&smp->responder_ltk->bdaddr, &hcon->dst);\n\t\tmgmt_new_ltk(hdev, smp->responder_ltk, persistent);\n\t}\n\n\tif (smp->link_key) {\n\t\tstruct link_key *key;\n\t\tu8 type;\n\n\t\tif (test_bit(SMP_FLAG_DEBUG_KEY, &smp->flags))\n\t\t\ttype = HCI_LK_DEBUG_COMBINATION;\n\t\telse if (hcon->sec_level == BT_SECURITY_FIPS)\n\t\t\ttype = HCI_LK_AUTH_COMBINATION_P256;\n\t\telse\n\t\t\ttype = HCI_LK_UNAUTH_COMBINATION_P256;\n\n\t\tkey = hci_add_link_key(hdev, smp->conn->hcon, &hcon->dst,\n\t\t\t\t       smp->link_key, type, 0, &persistent);\n\t\tif (key) {\n\t\t\tkey->link_type = hcon->type;\n\t\t\tkey->bdaddr_type = hcon->dst_type;\n\t\t\tmgmt_new_link_key(hdev, key, persistent);\n\n\t\t\t \n\t\t\tif (!hci_dev_test_flag(hdev, HCI_KEEP_DEBUG_KEYS) &&\n\t\t\t    key->type == HCI_LK_DEBUG_COMBINATION) {\n\t\t\t\tlist_del_rcu(&key->list);\n\t\t\t\tkfree_rcu(key, rcu);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void sc_add_ltk(struct smp_chan *smp)\n{\n\tstruct hci_conn *hcon = smp->conn->hcon;\n\tu8 key_type, auth;\n\n\tif (test_bit(SMP_FLAG_DEBUG_KEY, &smp->flags))\n\t\tkey_type = SMP_LTK_P256_DEBUG;\n\telse\n\t\tkey_type = SMP_LTK_P256;\n\n\tif (hcon->pending_sec_level == BT_SECURITY_FIPS)\n\t\tauth = 1;\n\telse\n\t\tauth = 0;\n\n\tsmp->ltk = hci_add_ltk(hcon->hdev, &hcon->dst, hcon->dst_type,\n\t\t\t       key_type, auth, smp->tk, smp->enc_key_size,\n\t\t\t       0, 0);\n}\n\nstatic void sc_generate_link_key(struct smp_chan *smp)\n{\n\t \n\tconst u8 lebr[4] = { 0x72, 0x62, 0x65, 0x6c };\n\n\tsmp->link_key = kzalloc(16, GFP_KERNEL);\n\tif (!smp->link_key)\n\t\treturn;\n\n\tif (test_bit(SMP_FLAG_CT2, &smp->flags)) {\n\t\t \n\t\tconst u8 salt[16] = { 0x31, 0x70, 0x6d, 0x74 };\n\n\t\tif (smp_h7(smp->tfm_cmac, smp->tk, salt, smp->link_key)) {\n\t\t\tkfree_sensitive(smp->link_key);\n\t\t\tsmp->link_key = NULL;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t \n\t\tconst u8 tmp1[4] = { 0x31, 0x70, 0x6d, 0x74 };\n\n\t\tif (smp_h6(smp->tfm_cmac, smp->tk, tmp1, smp->link_key)) {\n\t\t\tkfree_sensitive(smp->link_key);\n\t\t\tsmp->link_key = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (smp_h6(smp->tfm_cmac, smp->link_key, lebr, smp->link_key)) {\n\t\tkfree_sensitive(smp->link_key);\n\t\tsmp->link_key = NULL;\n\t\treturn;\n\t}\n}\n\nstatic void smp_allow_key_dist(struct smp_chan *smp)\n{\n\t \n\tif (smp->remote_key_dist & SMP_DIST_ENC_KEY)\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_ENCRYPT_INFO);\n\telse if (smp->remote_key_dist & SMP_DIST_ID_KEY)\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_IDENT_INFO);\n\telse if (smp->remote_key_dist & SMP_DIST_SIGN)\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_SIGN_INFO);\n}\n\nstatic void sc_generate_ltk(struct smp_chan *smp)\n{\n\t \n\tconst u8 brle[4] = { 0x65, 0x6c, 0x72, 0x62 };\n\tstruct hci_conn *hcon = smp->conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct link_key *key;\n\n\tkey = hci_find_link_key(hdev, &hcon->dst);\n\tif (!key) {\n\t\tbt_dev_err(hdev, \"no Link Key found to generate LTK\");\n\t\treturn;\n\t}\n\n\tif (key->type == HCI_LK_DEBUG_COMBINATION)\n\t\tset_bit(SMP_FLAG_DEBUG_KEY, &smp->flags);\n\n\tif (test_bit(SMP_FLAG_CT2, &smp->flags)) {\n\t\t \n\t\tconst u8 salt[16] = { 0x32, 0x70, 0x6d, 0x74 };\n\n\t\tif (smp_h7(smp->tfm_cmac, key->val, salt, smp->tk))\n\t\t\treturn;\n\t} else {\n\t\t \n\t\tconst u8 tmp2[4] = { 0x32, 0x70, 0x6d, 0x74 };\n\n\t\tif (smp_h6(smp->tfm_cmac, key->val, tmp2, smp->tk))\n\t\t\treturn;\n\t}\n\n\tif (smp_h6(smp->tfm_cmac, smp->tk, brle, smp->tk))\n\t\treturn;\n\n\tsc_add_ltk(smp);\n}\n\nstatic void smp_distribute_keys(struct smp_chan *smp)\n{\n\tstruct smp_cmd_pairing *req, *rsp;\n\tstruct l2cap_conn *conn = smp->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\t__u8 *keydist;\n\n\tbt_dev_dbg(hdev, \"conn %p\", conn);\n\n\trsp = (void *) &smp->prsp[1];\n\n\t \n\tif (hcon->out && (smp->remote_key_dist & KEY_DIST_MASK)) {\n\t\tsmp_allow_key_dist(smp);\n\t\treturn;\n\t}\n\n\treq = (void *) &smp->preq[1];\n\n\tif (hcon->out) {\n\t\tkeydist = &rsp->init_key_dist;\n\t\t*keydist &= req->init_key_dist;\n\t} else {\n\t\tkeydist = &rsp->resp_key_dist;\n\t\t*keydist &= req->resp_key_dist;\n\t}\n\n\tif (test_bit(SMP_FLAG_SC, &smp->flags)) {\n\t\tif (hcon->type == LE_LINK && (*keydist & SMP_DIST_LINK_KEY))\n\t\t\tsc_generate_link_key(smp);\n\t\tif (hcon->type == ACL_LINK && (*keydist & SMP_DIST_ENC_KEY))\n\t\t\tsc_generate_ltk(smp);\n\n\t\t \n\t\t*keydist &= ~SMP_SC_NO_DIST;\n\t}\n\n\tbt_dev_dbg(hdev, \"keydist 0x%x\", *keydist);\n\n\tif (*keydist & SMP_DIST_ENC_KEY) {\n\t\tstruct smp_cmd_encrypt_info enc;\n\t\tstruct smp_cmd_initiator_ident ident;\n\t\tstruct smp_ltk *ltk;\n\t\tu8 authenticated;\n\t\t__le16 ediv;\n\t\t__le64 rand;\n\n\t\t \n\t\tget_random_bytes(enc.ltk, smp->enc_key_size);\n\t\tmemset(enc.ltk + smp->enc_key_size, 0,\n\t\t       sizeof(enc.ltk) - smp->enc_key_size);\n\n\t\tget_random_bytes(&ediv, sizeof(ediv));\n\t\tget_random_bytes(&rand, sizeof(rand));\n\n\t\tsmp_send_cmd(conn, SMP_CMD_ENCRYPT_INFO, sizeof(enc), &enc);\n\n\t\tauthenticated = hcon->sec_level == BT_SECURITY_HIGH;\n\t\tltk = hci_add_ltk(hdev, &hcon->dst, hcon->dst_type,\n\t\t\t\t  SMP_LTK_RESPONDER, authenticated, enc.ltk,\n\t\t\t\t  smp->enc_key_size, ediv, rand);\n\t\tsmp->responder_ltk = ltk;\n\n\t\tident.ediv = ediv;\n\t\tident.rand = rand;\n\n\t\tsmp_send_cmd(conn, SMP_CMD_INITIATOR_IDENT, sizeof(ident),\n\t\t\t     &ident);\n\n\t\t*keydist &= ~SMP_DIST_ENC_KEY;\n\t}\n\n\tif (*keydist & SMP_DIST_ID_KEY) {\n\t\tstruct smp_cmd_ident_addr_info addrinfo;\n\t\tstruct smp_cmd_ident_info idinfo;\n\n\t\tmemcpy(idinfo.irk, hdev->irk, sizeof(idinfo.irk));\n\n\t\tsmp_send_cmd(conn, SMP_CMD_IDENT_INFO, sizeof(idinfo), &idinfo);\n\n\t\t \n\t\tbacpy(&addrinfo.bdaddr, &hcon->src);\n\t\taddrinfo.addr_type = hcon->src_type;\n\n\t\tsmp_send_cmd(conn, SMP_CMD_IDENT_ADDR_INFO, sizeof(addrinfo),\n\t\t\t     &addrinfo);\n\n\t\t*keydist &= ~SMP_DIST_ID_KEY;\n\t}\n\n\tif (*keydist & SMP_DIST_SIGN) {\n\t\tstruct smp_cmd_sign_info sign;\n\t\tstruct smp_csrk *csrk;\n\n\t\t \n\t\tget_random_bytes(sign.csrk, sizeof(sign.csrk));\n\n\t\tcsrk = kzalloc(sizeof(*csrk), GFP_KERNEL);\n\t\tif (csrk) {\n\t\t\tif (hcon->sec_level > BT_SECURITY_MEDIUM)\n\t\t\t\tcsrk->type = MGMT_CSRK_LOCAL_AUTHENTICATED;\n\t\t\telse\n\t\t\t\tcsrk->type = MGMT_CSRK_LOCAL_UNAUTHENTICATED;\n\t\t\tmemcpy(csrk->val, sign.csrk, sizeof(csrk->val));\n\t\t}\n\t\tsmp->responder_csrk = csrk;\n\n\t\tsmp_send_cmd(conn, SMP_CMD_SIGN_INFO, sizeof(sign), &sign);\n\n\t\t*keydist &= ~SMP_DIST_SIGN;\n\t}\n\n\t \n\tif (smp->remote_key_dist & KEY_DIST_MASK) {\n\t\tsmp_allow_key_dist(smp);\n\t\treturn;\n\t}\n\n\tset_bit(SMP_FLAG_COMPLETE, &smp->flags);\n\tsmp_notify_keys(conn);\n\n\tsmp_chan_destroy(conn);\n}\n\nstatic void smp_timeout(struct work_struct *work)\n{\n\tstruct smp_chan *smp = container_of(work, struct smp_chan,\n\t\t\t\t\t    security_timer.work);\n\tstruct l2cap_conn *conn = smp->conn;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"conn %p\", conn);\n\n\thci_disconnect(conn->hcon, HCI_ERROR_REMOTE_USER_TERM);\n}\n\nstatic struct smp_chan *smp_chan_create(struct l2cap_conn *conn)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp;\n\n\tsmp = kzalloc(sizeof(*smp), GFP_ATOMIC);\n\tif (!smp)\n\t\treturn NULL;\n\n\tsmp->tfm_cmac = crypto_alloc_shash(\"cmac(aes)\", 0, 0);\n\tif (IS_ERR(smp->tfm_cmac)) {\n\t\tbt_dev_err(hcon->hdev, \"Unable to create CMAC crypto context\");\n\t\tgoto zfree_smp;\n\t}\n\n\tsmp->tfm_ecdh = crypto_alloc_kpp(\"ecdh-nist-p256\", 0, 0);\n\tif (IS_ERR(smp->tfm_ecdh)) {\n\t\tbt_dev_err(hcon->hdev, \"Unable to create ECDH crypto context\");\n\t\tgoto free_shash;\n\t}\n\n\tsmp->conn = conn;\n\tchan->data = smp;\n\n\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_FAIL);\n\n\tINIT_DELAYED_WORK(&smp->security_timer, smp_timeout);\n\n\thci_conn_hold(hcon);\n\n\treturn smp;\n\nfree_shash:\n\tcrypto_free_shash(smp->tfm_cmac);\nzfree_smp:\n\tkfree_sensitive(smp);\n\treturn NULL;\n}\n\nstatic int sc_mackey_and_ltk(struct smp_chan *smp, u8 mackey[16], u8 ltk[16])\n{\n\tstruct hci_conn *hcon = smp->conn->hcon;\n\tu8 *na, *nb, a[7], b[7];\n\n\tif (hcon->out) {\n\t\tna   = smp->prnd;\n\t\tnb   = smp->rrnd;\n\t} else {\n\t\tna   = smp->rrnd;\n\t\tnb   = smp->prnd;\n\t}\n\n\tmemcpy(a, &hcon->init_addr, 6);\n\tmemcpy(b, &hcon->resp_addr, 6);\n\ta[6] = hcon->init_addr_type;\n\tb[6] = hcon->resp_addr_type;\n\n\treturn smp_f5(smp->tfm_cmac, smp->dhkey, na, nb, a, b, mackey, ltk);\n}\n\nstatic void sc_dhkey_check(struct smp_chan *smp)\n{\n\tstruct hci_conn *hcon = smp->conn->hcon;\n\tstruct smp_cmd_dhkey_check check;\n\tu8 a[7], b[7], *local_addr, *remote_addr;\n\tu8 io_cap[3], r[16];\n\n\tmemcpy(a, &hcon->init_addr, 6);\n\tmemcpy(b, &hcon->resp_addr, 6);\n\ta[6] = hcon->init_addr_type;\n\tb[6] = hcon->resp_addr_type;\n\n\tif (hcon->out) {\n\t\tlocal_addr = a;\n\t\tremote_addr = b;\n\t\tmemcpy(io_cap, &smp->preq[1], 3);\n\t} else {\n\t\tlocal_addr = b;\n\t\tremote_addr = a;\n\t\tmemcpy(io_cap, &smp->prsp[1], 3);\n\t}\n\n\tmemset(r, 0, sizeof(r));\n\n\tif (smp->method == REQ_PASSKEY || smp->method == DSP_PASSKEY)\n\t\tput_unaligned_le32(hcon->passkey_notify, r);\n\n\tif (smp->method == REQ_OOB)\n\t\tmemcpy(r, smp->rr, 16);\n\n\tsmp_f6(smp->tfm_cmac, smp->mackey, smp->prnd, smp->rrnd, r, io_cap,\n\t       local_addr, remote_addr, check.e);\n\n\tsmp_send_cmd(smp->conn, SMP_CMD_DHKEY_CHECK, sizeof(check), &check);\n}\n\nstatic u8 sc_passkey_send_confirm(struct smp_chan *smp)\n{\n\tstruct l2cap_conn *conn = smp->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct smp_cmd_pairing_confirm cfm;\n\tu8 r;\n\n\tr = ((hcon->passkey_notify >> smp->passkey_round) & 0x01);\n\tr |= 0x80;\n\n\tget_random_bytes(smp->prnd, sizeof(smp->prnd));\n\n\tif (smp_f4(smp->tfm_cmac, smp->local_pk, smp->remote_pk, smp->prnd, r,\n\t\t   cfm.confirm_val))\n\t\treturn SMP_UNSPECIFIED;\n\n\tsmp_send_cmd(conn, SMP_CMD_PAIRING_CONFIRM, sizeof(cfm), &cfm);\n\n\treturn 0;\n}\n\nstatic u8 sc_passkey_round(struct smp_chan *smp, u8 smp_op)\n{\n\tstruct l2cap_conn *conn = smp->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\tu8 cfm[16], r;\n\n\t \n\tif (smp->passkey_round >= 20)\n\t\treturn 0;\n\n\tswitch (smp_op) {\n\tcase SMP_CMD_PAIRING_RANDOM:\n\t\tr = ((hcon->passkey_notify >> smp->passkey_round) & 0x01);\n\t\tr |= 0x80;\n\n\t\tif (smp_f4(smp->tfm_cmac, smp->remote_pk, smp->local_pk,\n\t\t\t   smp->rrnd, r, cfm))\n\t\t\treturn SMP_UNSPECIFIED;\n\n\t\tif (crypto_memneq(smp->pcnf, cfm, 16))\n\t\t\treturn SMP_CONFIRM_FAILED;\n\n\t\tsmp->passkey_round++;\n\n\t\tif (smp->passkey_round == 20) {\n\t\t\t \n\t\t\tif (sc_mackey_and_ltk(smp, smp->mackey, smp->tk))\n\t\t\t\treturn SMP_UNSPECIFIED;\n\t\t}\n\n\t\t \n\t\tif (!hcon->out) {\n\t\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM,\n\t\t\t\t     sizeof(smp->prnd), smp->prnd);\n\t\t\tif (smp->passkey_round == 20)\n\t\t\t\tSMP_ALLOW_CMD(smp, SMP_CMD_DHKEY_CHECK);\n\t\t\telse\n\t\t\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_CONFIRM);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (smp->passkey_round != 20)\n\t\t\treturn sc_passkey_round(smp, 0);\n\n\t\t \n\t\tsc_dhkey_check(smp);\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_DHKEY_CHECK);\n\n\t\tbreak;\n\n\tcase SMP_CMD_PAIRING_CONFIRM:\n\t\tif (test_bit(SMP_FLAG_WAIT_USER, &smp->flags)) {\n\t\t\tset_bit(SMP_FLAG_CFM_PENDING, &smp->flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_RANDOM);\n\n\t\tif (hcon->out) {\n\t\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM,\n\t\t\t\t     sizeof(smp->prnd), smp->prnd);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn sc_passkey_send_confirm(smp);\n\n\tcase SMP_CMD_PUBLIC_KEY:\n\tdefault:\n\t\t \n\t\tif (!hcon->out)\n\t\t\treturn 0;\n\n\t\tbt_dev_dbg(hdev, \"Starting passkey round %u\",\n\t\t\t   smp->passkey_round + 1);\n\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_CONFIRM);\n\n\t\treturn sc_passkey_send_confirm(smp);\n\t}\n\n\treturn 0;\n}\n\nstatic int sc_user_reply(struct smp_chan *smp, u16 mgmt_op, __le32 passkey)\n{\n\tstruct l2cap_conn *conn = smp->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu8 smp_op;\n\n\tclear_bit(SMP_FLAG_WAIT_USER, &smp->flags);\n\n\tswitch (mgmt_op) {\n\tcase MGMT_OP_USER_PASSKEY_NEG_REPLY:\n\t\tsmp_failure(smp->conn, SMP_PASSKEY_ENTRY_FAILED);\n\t\treturn 0;\n\tcase MGMT_OP_USER_CONFIRM_NEG_REPLY:\n\t\tsmp_failure(smp->conn, SMP_NUMERIC_COMP_FAILED);\n\t\treturn 0;\n\tcase MGMT_OP_USER_PASSKEY_REPLY:\n\t\thcon->passkey_notify = le32_to_cpu(passkey);\n\t\tsmp->passkey_round = 0;\n\n\t\tif (test_and_clear_bit(SMP_FLAG_CFM_PENDING, &smp->flags))\n\t\t\tsmp_op = SMP_CMD_PAIRING_CONFIRM;\n\t\telse\n\t\t\tsmp_op = 0;\n\n\t\tif (sc_passkey_round(smp, smp_op))\n\t\t\treturn -EIO;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (hcon->out) {\n\t\tsc_dhkey_check(smp);\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_DHKEY_CHECK);\n\t} else if (test_and_clear_bit(SMP_FLAG_DHKEY_PENDING, &smp->flags)) {\n\t\tsc_dhkey_check(smp);\n\t\tsc_add_ltk(smp);\n\t}\n\n\treturn 0;\n}\n\nint smp_user_confirm_reply(struct hci_conn *hcon, u16 mgmt_op, __le32 passkey)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan;\n\tstruct smp_chan *smp;\n\tu32 value;\n\tint err;\n\n\tif (!conn)\n\t\treturn -ENOTCONN;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"\");\n\n\tchan = conn->smp;\n\tif (!chan)\n\t\treturn -ENOTCONN;\n\n\tl2cap_chan_lock(chan);\n\tif (!chan->data) {\n\t\terr = -ENOTCONN;\n\t\tgoto unlock;\n\t}\n\n\tsmp = chan->data;\n\n\tif (test_bit(SMP_FLAG_SC, &smp->flags)) {\n\t\terr = sc_user_reply(smp, mgmt_op, passkey);\n\t\tgoto unlock;\n\t}\n\n\tswitch (mgmt_op) {\n\tcase MGMT_OP_USER_PASSKEY_REPLY:\n\t\tvalue = le32_to_cpu(passkey);\n\t\tmemset(smp->tk, 0, sizeof(smp->tk));\n\t\tbt_dev_dbg(conn->hcon->hdev, \"PassKey: %u\", value);\n\t\tput_unaligned_le32(value, smp->tk);\n\t\tfallthrough;\n\tcase MGMT_OP_USER_CONFIRM_REPLY:\n\t\tset_bit(SMP_FLAG_TK_VALID, &smp->flags);\n\t\tbreak;\n\tcase MGMT_OP_USER_PASSKEY_NEG_REPLY:\n\tcase MGMT_OP_USER_CONFIRM_NEG_REPLY:\n\t\tsmp_failure(conn, SMP_PASSKEY_ENTRY_FAILED);\n\t\terr = 0;\n\t\tgoto unlock;\n\tdefault:\n\t\tsmp_failure(conn, SMP_PASSKEY_ENTRY_FAILED);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\n\t \n\tif (test_bit(SMP_FLAG_CFM_PENDING, &smp->flags)) {\n\t\tu8 rsp = smp_confirm(smp);\n\t\tif (rsp)\n\t\t\tsmp_failure(conn, rsp);\n\t}\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\treturn err;\n}\n\nstatic void build_bredr_pairing_cmd(struct smp_chan *smp,\n\t\t\t\t    struct smp_cmd_pairing *req,\n\t\t\t\t    struct smp_cmd_pairing *rsp)\n{\n\tstruct l2cap_conn *conn = smp->conn;\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tu8 local_dist = 0, remote_dist = 0;\n\n\tif (hci_dev_test_flag(hdev, HCI_BONDABLE)) {\n\t\tlocal_dist = SMP_DIST_ENC_KEY | SMP_DIST_SIGN;\n\t\tremote_dist = SMP_DIST_ENC_KEY | SMP_DIST_SIGN;\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_RPA_RESOLVING))\n\t\tremote_dist |= SMP_DIST_ID_KEY;\n\n\tif (hci_dev_test_flag(hdev, HCI_PRIVACY))\n\t\tlocal_dist |= SMP_DIST_ID_KEY;\n\n\tif (!rsp) {\n\t\tmemset(req, 0, sizeof(*req));\n\n\t\treq->auth_req        = SMP_AUTH_CT2;\n\t\treq->init_key_dist   = local_dist;\n\t\treq->resp_key_dist   = remote_dist;\n\t\treq->max_key_size    = conn->hcon->enc_key_size;\n\n\t\tsmp->remote_key_dist = remote_dist;\n\n\t\treturn;\n\t}\n\n\tmemset(rsp, 0, sizeof(*rsp));\n\n\trsp->auth_req        = SMP_AUTH_CT2;\n\trsp->max_key_size    = conn->hcon->enc_key_size;\n\trsp->init_key_dist   = req->init_key_dist & remote_dist;\n\trsp->resp_key_dist   = req->resp_key_dist & local_dist;\n\n\tsmp->remote_key_dist = rsp->init_key_dist;\n}\n\nstatic u8 smp_cmd_pairing_req(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct smp_cmd_pairing rsp, *req = (void *) skb->data;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tstruct smp_chan *smp;\n\tu8 key_size, auth, sec_level;\n\tint ret;\n\n\tbt_dev_dbg(hdev, \"conn %p\", conn);\n\n\tif (skb->len < sizeof(*req))\n\t\treturn SMP_INVALID_PARAMS;\n\n\tif (conn->hcon->role != HCI_ROLE_SLAVE)\n\t\treturn SMP_CMD_NOTSUPP;\n\n\tif (!chan->data)\n\t\tsmp = smp_chan_create(conn);\n\telse\n\t\tsmp = chan->data;\n\n\tif (!smp)\n\t\treturn SMP_UNSPECIFIED;\n\n\t \n\tauth = req->auth_req & AUTH_REQ_MASK(hdev);\n\n\tif (!hci_dev_test_flag(hdev, HCI_BONDABLE) &&\n\t    (auth & SMP_AUTH_BONDING))\n\t\treturn SMP_PAIRING_NOTSUPP;\n\n\tif (hci_dev_test_flag(hdev, HCI_SC_ONLY) && !(auth & SMP_AUTH_SC))\n\t\treturn SMP_AUTH_REQUIREMENTS;\n\n\tsmp->preq[0] = SMP_CMD_PAIRING_REQ;\n\tmemcpy(&smp->preq[1], req, sizeof(*req));\n\tskb_pull(skb, sizeof(*req));\n\n\t \n\tif (req->oob_flag == SMP_OOB_PRESENT && SMP_DEV(hdev)->local_oob)\n\t\tset_bit(SMP_FLAG_LOCAL_OOB, &smp->flags);\n\n\t \n\tif (conn->hcon->type == ACL_LINK) {\n\t\t \n\t\tif (!test_bit(HCI_CONN_AES_CCM, &conn->hcon->flags) &&\n\t\t    !hci_dev_test_flag(hdev, HCI_FORCE_BREDR_SMP))\n\t\t\treturn SMP_CROSS_TRANSP_NOT_ALLOWED;\n\n\t\tset_bit(SMP_FLAG_SC, &smp->flags);\n\n\t\tbuild_bredr_pairing_cmd(smp, req, &rsp);\n\n\t\tif (req->auth_req & SMP_AUTH_CT2)\n\t\t\tset_bit(SMP_FLAG_CT2, &smp->flags);\n\n\t\tkey_size = min(req->max_key_size, rsp.max_key_size);\n\t\tif (check_enc_key_size(conn, key_size))\n\t\t\treturn SMP_ENC_KEY_SIZE;\n\n\t\t \n\t\tsmp->remote_key_dist &= ~SMP_SC_NO_DIST;\n\n\t\tsmp->prsp[0] = SMP_CMD_PAIRING_RSP;\n\t\tmemcpy(&smp->prsp[1], &rsp, sizeof(rsp));\n\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_RSP, sizeof(rsp), &rsp);\n\n\t\tsmp_distribute_keys(smp);\n\t\treturn 0;\n\t}\n\n\tbuild_pairing_cmd(conn, req, &rsp, auth);\n\n\tif (rsp.auth_req & SMP_AUTH_SC) {\n\t\tset_bit(SMP_FLAG_SC, &smp->flags);\n\n\t\tif (rsp.auth_req & SMP_AUTH_CT2)\n\t\t\tset_bit(SMP_FLAG_CT2, &smp->flags);\n\t}\n\n\tif (conn->hcon->io_capability == HCI_IO_NO_INPUT_OUTPUT)\n\t\tsec_level = BT_SECURITY_MEDIUM;\n\telse\n\t\tsec_level = authreq_to_seclevel(auth);\n\n\tif (sec_level > conn->hcon->pending_sec_level)\n\t\tconn->hcon->pending_sec_level = sec_level;\n\n\t \n\tif (conn->hcon->pending_sec_level >= BT_SECURITY_HIGH) {\n\t\tu8 method;\n\n\t\tmethod = get_auth_method(smp, conn->hcon->io_capability,\n\t\t\t\t\t req->io_capability);\n\t\tif (method == JUST_WORKS || method == JUST_CFM)\n\t\t\treturn SMP_AUTH_REQUIREMENTS;\n\t}\n\n\tkey_size = min(req->max_key_size, rsp.max_key_size);\n\tif (check_enc_key_size(conn, key_size))\n\t\treturn SMP_ENC_KEY_SIZE;\n\n\tget_random_bytes(smp->prnd, sizeof(smp->prnd));\n\n\tsmp->prsp[0] = SMP_CMD_PAIRING_RSP;\n\tmemcpy(&smp->prsp[1], &rsp, sizeof(rsp));\n\n\tsmp_send_cmd(conn, SMP_CMD_PAIRING_RSP, sizeof(rsp), &rsp);\n\n\tclear_bit(SMP_FLAG_INITIATOR, &smp->flags);\n\n\t \n\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_CONFIRM);\n\n\tif (test_bit(SMP_FLAG_SC, &smp->flags)) {\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PUBLIC_KEY);\n\t\t \n\t\tsmp->remote_key_dist &= ~SMP_SC_NO_DIST;\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tret = tk_request(conn, 0, auth, rsp.io_capability, req->io_capability);\n\tif (ret)\n\t\treturn SMP_UNSPECIFIED;\n\n\treturn 0;\n}\n\nstatic u8 sc_send_public_key(struct smp_chan *smp)\n{\n\tstruct hci_dev *hdev = smp->conn->hcon->hdev;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tif (test_bit(SMP_FLAG_LOCAL_OOB, &smp->flags)) {\n\t\tstruct l2cap_chan *chan = hdev->smp_data;\n\t\tstruct smp_dev *smp_dev;\n\n\t\tif (!chan || !chan->data)\n\t\t\treturn SMP_UNSPECIFIED;\n\n\t\tsmp_dev = chan->data;\n\n\t\tmemcpy(smp->local_pk, smp_dev->local_pk, 64);\n\t\tmemcpy(smp->lr, smp_dev->local_rand, 16);\n\n\t\tif (smp_dev->debug_key)\n\t\t\tset_bit(SMP_FLAG_DEBUG_KEY, &smp->flags);\n\n\t\tgoto done;\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_USE_DEBUG_KEYS)) {\n\t\tbt_dev_dbg(hdev, \"Using debug keys\");\n\t\tif (set_ecdh_privkey(smp->tfm_ecdh, debug_sk))\n\t\t\treturn SMP_UNSPECIFIED;\n\t\tmemcpy(smp->local_pk, debug_pk, 64);\n\t\tset_bit(SMP_FLAG_DEBUG_KEY, &smp->flags);\n\t} else {\n\t\twhile (true) {\n\t\t\t \n\t\t\tif (generate_ecdh_keys(smp->tfm_ecdh, smp->local_pk))\n\t\t\t\treturn SMP_UNSPECIFIED;\n\n\t\t\t \n\t\t\tif (crypto_memneq(smp->local_pk, debug_pk, 64))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tSMP_DBG(\"Local Public Key X: %32phN\", smp->local_pk);\n\tSMP_DBG(\"Local Public Key Y: %32phN\", smp->local_pk + 32);\n\n\tsmp_send_cmd(smp->conn, SMP_CMD_PUBLIC_KEY, 64, smp->local_pk);\n\n\treturn 0;\n}\n\nstatic u8 smp_cmd_pairing_rsp(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct smp_cmd_pairing *req, *rsp = (void *) skb->data;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tu8 key_size, auth;\n\tint ret;\n\n\tbt_dev_dbg(hdev, \"conn %p\", conn);\n\n\tif (skb->len < sizeof(*rsp))\n\t\treturn SMP_INVALID_PARAMS;\n\n\tif (conn->hcon->role != HCI_ROLE_MASTER)\n\t\treturn SMP_CMD_NOTSUPP;\n\n\tskb_pull(skb, sizeof(*rsp));\n\n\treq = (void *) &smp->preq[1];\n\n\tkey_size = min(req->max_key_size, rsp->max_key_size);\n\tif (check_enc_key_size(conn, key_size))\n\t\treturn SMP_ENC_KEY_SIZE;\n\n\tauth = rsp->auth_req & AUTH_REQ_MASK(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_SC_ONLY) && !(auth & SMP_AUTH_SC))\n\t\treturn SMP_AUTH_REQUIREMENTS;\n\n\t \n\tif (rsp->oob_flag == SMP_OOB_PRESENT && SMP_DEV(hdev)->local_oob)\n\t\tset_bit(SMP_FLAG_LOCAL_OOB, &smp->flags);\n\n\tsmp->prsp[0] = SMP_CMD_PAIRING_RSP;\n\tmemcpy(&smp->prsp[1], rsp, sizeof(*rsp));\n\n\t \n\tsmp->remote_key_dist &= rsp->resp_key_dist;\n\n\tif ((req->auth_req & SMP_AUTH_CT2) && (auth & SMP_AUTH_CT2))\n\t\tset_bit(SMP_FLAG_CT2, &smp->flags);\n\n\t \n\tif (conn->hcon->type == ACL_LINK) {\n\t\t \n\t\tsmp->remote_key_dist &= ~SMP_SC_NO_DIST;\n\t\tsmp_distribute_keys(smp);\n\t\treturn 0;\n\t}\n\n\tif ((req->auth_req & SMP_AUTH_SC) && (auth & SMP_AUTH_SC))\n\t\tset_bit(SMP_FLAG_SC, &smp->flags);\n\telse if (conn->hcon->pending_sec_level > BT_SECURITY_HIGH)\n\t\tconn->hcon->pending_sec_level = BT_SECURITY_HIGH;\n\n\t \n\tif (conn->hcon->pending_sec_level >= BT_SECURITY_HIGH) {\n\t\tu8 method;\n\n\t\tmethod = get_auth_method(smp, req->io_capability,\n\t\t\t\t\t rsp->io_capability);\n\t\tif (method == JUST_WORKS || method == JUST_CFM)\n\t\t\treturn SMP_AUTH_REQUIREMENTS;\n\t}\n\n\tget_random_bytes(smp->prnd, sizeof(smp->prnd));\n\n\t \n\tsmp->remote_key_dist &= rsp->resp_key_dist;\n\n\tif (test_bit(SMP_FLAG_SC, &smp->flags)) {\n\t\t \n\t\tsmp->remote_key_dist &= ~SMP_SC_NO_DIST;\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PUBLIC_KEY);\n\t\treturn sc_send_public_key(smp);\n\t}\n\n\tauth |= req->auth_req;\n\n\tret = tk_request(conn, 0, auth, req->io_capability, rsp->io_capability);\n\tif (ret)\n\t\treturn SMP_UNSPECIFIED;\n\n\tset_bit(SMP_FLAG_CFM_PENDING, &smp->flags);\n\n\t \n\tif (test_bit(SMP_FLAG_TK_VALID, &smp->flags))\n\t\treturn smp_confirm(smp);\n\n\treturn 0;\n}\n\nstatic u8 sc_check_confirm(struct smp_chan *smp)\n{\n\tstruct l2cap_conn *conn = smp->conn;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"\");\n\n\tif (smp->method == REQ_PASSKEY || smp->method == DSP_PASSKEY)\n\t\treturn sc_passkey_round(smp, SMP_CMD_PAIRING_CONFIRM);\n\n\tif (conn->hcon->out) {\n\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(smp->prnd),\n\t\t\t     smp->prnd);\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_RANDOM);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fixup_sc_false_positive(struct smp_chan *smp)\n{\n\tstruct l2cap_conn *conn = smp->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct smp_cmd_pairing *req, *rsp;\n\tu8 auth;\n\n\t \n\tif (hcon->out)\n\t\treturn SMP_UNSPECIFIED;\n\n\tif (hci_dev_test_flag(hdev, HCI_SC_ONLY)) {\n\t\tbt_dev_err(hdev, \"refusing legacy fallback in SC-only mode\");\n\t\treturn SMP_UNSPECIFIED;\n\t}\n\n\tbt_dev_err(hdev, \"trying to fall back to legacy SMP\");\n\n\treq = (void *) &smp->preq[1];\n\trsp = (void *) &smp->prsp[1];\n\n\t \n\tsmp->remote_key_dist = (req->init_key_dist & rsp->resp_key_dist);\n\n\tauth = req->auth_req & AUTH_REQ_MASK(hdev);\n\n\tif (tk_request(conn, 0, auth, rsp->io_capability, req->io_capability)) {\n\t\tbt_dev_err(hdev, \"failed to fall back to legacy SMP\");\n\t\treturn SMP_UNSPECIFIED;\n\t}\n\n\tclear_bit(SMP_FLAG_SC, &smp->flags);\n\n\treturn 0;\n}\n\nstatic u8 smp_cmd_pairing_confirm(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\n\tbt_dev_dbg(hdev, \"conn %p %s\", conn,\n\t\t   hcon->out ? \"initiator\" : \"responder\");\n\n\tif (skb->len < sizeof(smp->pcnf))\n\t\treturn SMP_INVALID_PARAMS;\n\n\tmemcpy(smp->pcnf, skb->data, sizeof(smp->pcnf));\n\tskb_pull(skb, sizeof(smp->pcnf));\n\n\tif (test_bit(SMP_FLAG_SC, &smp->flags)) {\n\t\tint ret;\n\n\t\t \n\t\tif (test_bit(SMP_FLAG_REMOTE_PK, &smp->flags))\n\t\t\treturn sc_check_confirm(smp);\n\n\t\tbt_dev_err(hdev, \"Unexpected SMP Pairing Confirm\");\n\n\t\tret = fixup_sc_false_positive(smp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (conn->hcon->out) {\n\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(smp->prnd),\n\t\t\t     smp->prnd);\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_RANDOM);\n\t\treturn 0;\n\t}\n\n\tif (test_bit(SMP_FLAG_TK_VALID, &smp->flags))\n\t\treturn smp_confirm(smp);\n\n\tset_bit(SMP_FLAG_CFM_PENDING, &smp->flags);\n\n\treturn 0;\n}\n\nstatic u8 smp_cmd_pairing_random(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu8 *pkax, *pkbx, *na, *nb, confirm_hint;\n\tu32 passkey;\n\tint err;\n\n\tbt_dev_dbg(hcon->hdev, \"conn %p\", conn);\n\n\tif (skb->len < sizeof(smp->rrnd))\n\t\treturn SMP_INVALID_PARAMS;\n\n\tmemcpy(smp->rrnd, skb->data, sizeof(smp->rrnd));\n\tskb_pull(skb, sizeof(smp->rrnd));\n\n\tif (!test_bit(SMP_FLAG_SC, &smp->flags))\n\t\treturn smp_random(smp);\n\n\tif (hcon->out) {\n\t\tpkax = smp->local_pk;\n\t\tpkbx = smp->remote_pk;\n\t\tna   = smp->prnd;\n\t\tnb   = smp->rrnd;\n\t} else {\n\t\tpkax = smp->remote_pk;\n\t\tpkbx = smp->local_pk;\n\t\tna   = smp->rrnd;\n\t\tnb   = smp->prnd;\n\t}\n\n\tif (smp->method == REQ_OOB) {\n\t\tif (!hcon->out)\n\t\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM,\n\t\t\t\t     sizeof(smp->prnd), smp->prnd);\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_DHKEY_CHECK);\n\t\tgoto mackey_and_ltk;\n\t}\n\n\t \n\tif (smp->method == REQ_PASSKEY || smp->method == DSP_PASSKEY)\n\t\treturn sc_passkey_round(smp, SMP_CMD_PAIRING_RANDOM);\n\n\tif (hcon->out) {\n\t\tu8 cfm[16];\n\n\t\terr = smp_f4(smp->tfm_cmac, smp->remote_pk, smp->local_pk,\n\t\t\t     smp->rrnd, 0, cfm);\n\t\tif (err)\n\t\t\treturn SMP_UNSPECIFIED;\n\n\t\tif (crypto_memneq(smp->pcnf, cfm, 16))\n\t\t\treturn SMP_CONFIRM_FAILED;\n\t} else {\n\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(smp->prnd),\n\t\t\t     smp->prnd);\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_DHKEY_CHECK);\n\n\t\t \n\t\tif (smp->method != JUST_WORKS)\n\t\t\tgoto mackey_and_ltk;\n\n\t\t \n\t\tif (hci_find_ltk(hcon->hdev, &hcon->dst, hcon->dst_type,\n\t\t\t\t hcon->role)) {\n\t\t\t \n\t\t\tpasskey = 0;\n\t\t\tconfirm_hint = 1;\n\t\t\tgoto confirm;\n\t\t}\n\t}\n\nmackey_and_ltk:\n\t \n\terr = sc_mackey_and_ltk(smp, smp->mackey, smp->tk);\n\tif (err)\n\t\treturn SMP_UNSPECIFIED;\n\n\tif (smp->method == REQ_OOB) {\n\t\tif (hcon->out) {\n\t\t\tsc_dhkey_check(smp);\n\t\t\tSMP_ALLOW_CMD(smp, SMP_CMD_DHKEY_CHECK);\n\t\t}\n\t\treturn 0;\n\t}\n\n\terr = smp_g2(smp->tfm_cmac, pkax, pkbx, na, nb, &passkey);\n\tif (err)\n\t\treturn SMP_UNSPECIFIED;\n\n\tconfirm_hint = 0;\n\nconfirm:\n\tif (smp->method == JUST_WORKS)\n\t\tconfirm_hint = 1;\n\n\terr = mgmt_user_confirm_request(hcon->hdev, &hcon->dst, hcon->type,\n\t\t\t\t\thcon->dst_type, passkey, confirm_hint);\n\tif (err)\n\t\treturn SMP_UNSPECIFIED;\n\n\tset_bit(SMP_FLAG_WAIT_USER, &smp->flags);\n\n\treturn 0;\n}\n\nstatic bool smp_ltk_encrypt(struct l2cap_conn *conn, u8 sec_level)\n{\n\tstruct smp_ltk *key;\n\tstruct hci_conn *hcon = conn->hcon;\n\n\tkey = hci_find_ltk(hcon->hdev, &hcon->dst, hcon->dst_type, hcon->role);\n\tif (!key)\n\t\treturn false;\n\n\tif (smp_ltk_sec_level(key) < sec_level)\n\t\treturn false;\n\n\tif (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->flags))\n\t\treturn true;\n\n\thci_le_start_enc(hcon, key->ediv, key->rand, key->val, key->enc_size);\n\thcon->enc_key_size = key->enc_size;\n\n\t \n\tclear_bit(HCI_CONN_STK_ENCRYPT, &hcon->flags);\n\n\treturn true;\n}\n\nbool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level,\n\t\t\t     enum smp_key_pref key_pref)\n{\n\tif (sec_level == BT_SECURITY_LOW)\n\t\treturn true;\n\n\t \n\tif (key_pref == SMP_USE_LTK &&\n\t    test_bit(HCI_CONN_STK_ENCRYPT, &hcon->flags) &&\n\t    hci_find_ltk(hcon->hdev, &hcon->dst, hcon->dst_type, hcon->role))\n\t\treturn false;\n\n\tif (hcon->sec_level >= sec_level)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic u8 smp_cmd_security_req(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct smp_cmd_security_req *rp = (void *) skb->data;\n\tstruct smp_cmd_pairing cp;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct smp_chan *smp;\n\tu8 sec_level, auth;\n\n\tbt_dev_dbg(hdev, \"conn %p\", conn);\n\n\tif (skb->len < sizeof(*rp))\n\t\treturn SMP_INVALID_PARAMS;\n\n\tif (hcon->role != HCI_ROLE_MASTER)\n\t\treturn SMP_CMD_NOTSUPP;\n\n\tauth = rp->auth_req & AUTH_REQ_MASK(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_SC_ONLY) && !(auth & SMP_AUTH_SC))\n\t\treturn SMP_AUTH_REQUIREMENTS;\n\n\tif (hcon->io_capability == HCI_IO_NO_INPUT_OUTPUT)\n\t\tsec_level = BT_SECURITY_MEDIUM;\n\telse\n\t\tsec_level = authreq_to_seclevel(auth);\n\n\tif (smp_sufficient_security(hcon, sec_level, SMP_USE_LTK)) {\n\t\t \n\t\tsmp_ltk_encrypt(conn, hcon->sec_level);\n\t\treturn 0;\n\t}\n\n\tif (sec_level > hcon->pending_sec_level)\n\t\thcon->pending_sec_level = sec_level;\n\n\tif (smp_ltk_encrypt(conn, hcon->pending_sec_level))\n\t\treturn 0;\n\n\tsmp = smp_chan_create(conn);\n\tif (!smp)\n\t\treturn SMP_UNSPECIFIED;\n\n\tif (!hci_dev_test_flag(hdev, HCI_BONDABLE) &&\n\t    (auth & SMP_AUTH_BONDING))\n\t\treturn SMP_PAIRING_NOTSUPP;\n\n\tskb_pull(skb, sizeof(*rp));\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbuild_pairing_cmd(conn, &cp, NULL, auth);\n\n\tsmp->preq[0] = SMP_CMD_PAIRING_REQ;\n\tmemcpy(&smp->preq[1], &cp, sizeof(cp));\n\n\tsmp_send_cmd(conn, SMP_CMD_PAIRING_REQ, sizeof(cp), &cp);\n\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_RSP);\n\n\treturn 0;\n}\n\nint smp_conn_security(struct hci_conn *hcon, __u8 sec_level)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan;\n\tstruct smp_chan *smp;\n\t__u8 authreq;\n\tint ret;\n\n\tbt_dev_dbg(hcon->hdev, \"conn %p hcon %p level 0x%2.2x\", conn, hcon,\n\t\t   sec_level);\n\n\t \n\tif (!conn)\n\t\treturn 1;\n\n\tif (!hci_dev_test_flag(hcon->hdev, HCI_LE_ENABLED))\n\t\treturn 1;\n\n\tif (smp_sufficient_security(hcon, sec_level, SMP_USE_LTK))\n\t\treturn 1;\n\n\tif (sec_level > hcon->pending_sec_level)\n\t\thcon->pending_sec_level = sec_level;\n\n\tif (hcon->role == HCI_ROLE_MASTER)\n\t\tif (smp_ltk_encrypt(conn, hcon->pending_sec_level))\n\t\t\treturn 0;\n\n\tchan = conn->smp;\n\tif (!chan) {\n\t\tbt_dev_err(hcon->hdev, \"security requested but not available\");\n\t\treturn 1;\n\t}\n\n\tl2cap_chan_lock(chan);\n\n\t \n\tif (chan->data) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\tsmp = smp_chan_create(conn);\n\tif (!smp) {\n\t\tret = 1;\n\t\tgoto unlock;\n\t}\n\n\tauthreq = seclevel_to_authreq(sec_level);\n\n\tif (hci_dev_test_flag(hcon->hdev, HCI_SC_ENABLED)) {\n\t\tauthreq |= SMP_AUTH_SC;\n\t\tif (hci_dev_test_flag(hcon->hdev, HCI_SSP_ENABLED))\n\t\t\tauthreq |= SMP_AUTH_CT2;\n\t}\n\n\t \n\tif (!hci_dev_test_flag(hcon->hdev, HCI_FORCE_NO_MITM)) {\n\t\t \n\t\tif (hcon->io_capability != HCI_IO_NO_INPUT_OUTPUT ||\n\t\t    hcon->pending_sec_level > BT_SECURITY_MEDIUM)\n\t\t\tauthreq |= SMP_AUTH_MITM;\n\t}\n\n\tif (hcon->role == HCI_ROLE_MASTER) {\n\t\tstruct smp_cmd_pairing cp;\n\n\t\tbuild_pairing_cmd(conn, &cp, NULL, authreq);\n\t\tsmp->preq[0] = SMP_CMD_PAIRING_REQ;\n\t\tmemcpy(&smp->preq[1], &cp, sizeof(cp));\n\n\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_REQ, sizeof(cp), &cp);\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_RSP);\n\t} else {\n\t\tstruct smp_cmd_security_req cp;\n\t\tcp.auth_req = authreq;\n\t\tsmp_send_cmd(conn, SMP_CMD_SECURITY_REQ, sizeof(cp), &cp);\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_REQ);\n\t}\n\n\tset_bit(SMP_FLAG_INITIATOR, &smp->flags);\n\tret = 0;\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\treturn ret;\n}\n\nint smp_cancel_and_remove_pairing(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t  u8 addr_type)\n{\n\tstruct hci_conn *hcon;\n\tstruct l2cap_conn *conn;\n\tstruct l2cap_chan *chan;\n\tstruct smp_chan *smp;\n\tint err;\n\n\terr = hci_remove_ltk(hdev, bdaddr, addr_type);\n\thci_remove_irk(hdev, bdaddr, addr_type);\n\n\thcon = hci_conn_hash_lookup_le(hdev, bdaddr, addr_type);\n\tif (!hcon)\n\t\tgoto done;\n\n\tconn = hcon->l2cap_data;\n\tif (!conn)\n\t\tgoto done;\n\n\tchan = conn->smp;\n\tif (!chan)\n\t\tgoto done;\n\n\tl2cap_chan_lock(chan);\n\n\tsmp = chan->data;\n\tif (smp) {\n\t\t \n\t\tsmp->ltk = NULL;\n\t\tsmp->responder_ltk = NULL;\n\t\tsmp->remote_irk = NULL;\n\n\t\tif (test_bit(SMP_FLAG_COMPLETE, &smp->flags))\n\t\t\tsmp_failure(conn, 0);\n\t\telse\n\t\t\tsmp_failure(conn, SMP_UNSPECIFIED);\n\t\terr = 0;\n\t}\n\n\tl2cap_chan_unlock(chan);\n\ndone:\n\treturn err;\n}\n\nstatic int smp_cmd_encrypt_info(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct smp_cmd_encrypt_info *rp = (void *) skb->data;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"conn %p\", conn);\n\n\tif (skb->len < sizeof(*rp))\n\t\treturn SMP_INVALID_PARAMS;\n\n\t \n\tif (hci_is_blocked_key(conn->hcon->hdev, HCI_BLOCKED_KEY_TYPE_LTK,\n\t\t\t       rp->ltk)) {\n\t\tbt_dev_warn_ratelimited(conn->hcon->hdev,\n\t\t\t\t\t\"LTK blocked for %pMR\",\n\t\t\t\t\t&conn->hcon->dst);\n\t\treturn SMP_INVALID_PARAMS;\n\t}\n\n\tSMP_ALLOW_CMD(smp, SMP_CMD_INITIATOR_IDENT);\n\n\tskb_pull(skb, sizeof(*rp));\n\n\tmemcpy(smp->tk, rp->ltk, sizeof(smp->tk));\n\n\treturn 0;\n}\n\nstatic int smp_cmd_initiator_ident(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct smp_cmd_initiator_ident *rp = (void *)skb->data;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct smp_ltk *ltk;\n\tu8 authenticated;\n\n\tbt_dev_dbg(hdev, \"conn %p\", conn);\n\n\tif (skb->len < sizeof(*rp))\n\t\treturn SMP_INVALID_PARAMS;\n\n\t \n\tsmp->remote_key_dist &= ~SMP_DIST_ENC_KEY;\n\n\tif (smp->remote_key_dist & SMP_DIST_ID_KEY)\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_IDENT_INFO);\n\telse if (smp->remote_key_dist & SMP_DIST_SIGN)\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_SIGN_INFO);\n\n\tskb_pull(skb, sizeof(*rp));\n\n\tauthenticated = (hcon->sec_level == BT_SECURITY_HIGH);\n\tltk = hci_add_ltk(hdev, &hcon->dst, hcon->dst_type, SMP_LTK,\n\t\t\t  authenticated, smp->tk, smp->enc_key_size,\n\t\t\t  rp->ediv, rp->rand);\n\tsmp->ltk = ltk;\n\tif (!(smp->remote_key_dist & KEY_DIST_MASK))\n\t\tsmp_distribute_keys(smp);\n\n\treturn 0;\n}\n\nstatic int smp_cmd_ident_info(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct smp_cmd_ident_info *info = (void *) skb->data;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"\");\n\n\tif (skb->len < sizeof(*info))\n\t\treturn SMP_INVALID_PARAMS;\n\n\t \n\tif (hci_is_blocked_key(conn->hcon->hdev, HCI_BLOCKED_KEY_TYPE_IRK,\n\t\t\t       info->irk)) {\n\t\tbt_dev_warn_ratelimited(conn->hcon->hdev,\n\t\t\t\t\t\"Identity key blocked for %pMR\",\n\t\t\t\t\t&conn->hcon->dst);\n\t\treturn SMP_INVALID_PARAMS;\n\t}\n\n\tSMP_ALLOW_CMD(smp, SMP_CMD_IDENT_ADDR_INFO);\n\n\tskb_pull(skb, sizeof(*info));\n\n\tmemcpy(smp->irk, info->irk, 16);\n\n\treturn 0;\n}\n\nstatic int smp_cmd_ident_addr_info(struct l2cap_conn *conn,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct smp_cmd_ident_addr_info *info = (void *) skb->data;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tbdaddr_t rpa;\n\n\tbt_dev_dbg(hcon->hdev, \"\");\n\n\tif (skb->len < sizeof(*info))\n\t\treturn SMP_INVALID_PARAMS;\n\n\t \n\tsmp->remote_key_dist &= ~SMP_DIST_ID_KEY;\n\n\tif (smp->remote_key_dist & SMP_DIST_SIGN)\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_SIGN_INFO);\n\n\tskb_pull(skb, sizeof(*info));\n\n\t \n\tif (!bacmp(&info->bdaddr, BDADDR_ANY) ||\n\t    !hci_is_identity_address(&info->bdaddr, info->addr_type)) {\n\t\tbt_dev_err(hcon->hdev, \"ignoring IRK with no identity address\");\n\t\tgoto distribute;\n\t}\n\n\t \n\tif (hci_is_identity_address(&hcon->dst, hcon->dst_type) &&\n\t    (bacmp(&info->bdaddr, &hcon->dst) ||\n\t     info->addr_type != hcon->dst_type)) {\n\t\tbt_dev_err(hcon->hdev,\n\t\t\t   \"ignoring IRK with invalid identity address\");\n\t\tgoto distribute;\n\t}\n\n\tbacpy(&smp->id_addr, &info->bdaddr);\n\tsmp->id_addr_type = info->addr_type;\n\n\tif (hci_bdaddr_is_rpa(&hcon->dst, hcon->dst_type))\n\t\tbacpy(&rpa, &hcon->dst);\n\telse\n\t\tbacpy(&rpa, BDADDR_ANY);\n\n\tsmp->remote_irk = hci_add_irk(conn->hcon->hdev, &smp->id_addr,\n\t\t\t\t      smp->id_addr_type, smp->irk, &rpa);\n\ndistribute:\n\tif (!(smp->remote_key_dist & KEY_DIST_MASK))\n\t\tsmp_distribute_keys(smp);\n\n\treturn 0;\n}\n\nstatic int smp_cmd_sign_info(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct smp_cmd_sign_info *rp = (void *) skb->data;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tstruct smp_csrk *csrk;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"conn %p\", conn);\n\n\tif (skb->len < sizeof(*rp))\n\t\treturn SMP_INVALID_PARAMS;\n\n\t \n\tsmp->remote_key_dist &= ~SMP_DIST_SIGN;\n\n\tskb_pull(skb, sizeof(*rp));\n\n\tcsrk = kzalloc(sizeof(*csrk), GFP_KERNEL);\n\tif (csrk) {\n\t\tif (conn->hcon->sec_level > BT_SECURITY_MEDIUM)\n\t\t\tcsrk->type = MGMT_CSRK_REMOTE_AUTHENTICATED;\n\t\telse\n\t\t\tcsrk->type = MGMT_CSRK_REMOTE_UNAUTHENTICATED;\n\t\tmemcpy(csrk->val, rp->csrk, sizeof(csrk->val));\n\t}\n\tsmp->csrk = csrk;\n\tsmp_distribute_keys(smp);\n\n\treturn 0;\n}\n\nstatic u8 sc_select_method(struct smp_chan *smp)\n{\n\tstruct l2cap_conn *conn = smp->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct smp_cmd_pairing *local, *remote;\n\tu8 local_mitm, remote_mitm, local_io, remote_io, method;\n\n\tif (test_bit(SMP_FLAG_REMOTE_OOB, &smp->flags) ||\n\t    test_bit(SMP_FLAG_LOCAL_OOB, &smp->flags))\n\t\treturn REQ_OOB;\n\n\t \n\tif (hcon->out) {\n\t\tlocal = (void *) &smp->preq[1];\n\t\tremote = (void *) &smp->prsp[1];\n\t} else {\n\t\tlocal = (void *) &smp->prsp[1];\n\t\tremote = (void *) &smp->preq[1];\n\t}\n\n\tlocal_io = local->io_capability;\n\tremote_io = remote->io_capability;\n\n\tlocal_mitm = (local->auth_req & SMP_AUTH_MITM);\n\tremote_mitm = (remote->auth_req & SMP_AUTH_MITM);\n\n\t \n\tif (local_mitm || remote_mitm)\n\t\tmethod = get_auth_method(smp, local_io, remote_io);\n\telse\n\t\tmethod = JUST_WORKS;\n\n\t \n\tif (method == JUST_CFM && test_bit(SMP_FLAG_INITIATOR, &smp->flags))\n\t\tmethod = JUST_WORKS;\n\n\treturn method;\n}\n\nstatic int smp_cmd_public_key(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct smp_cmd_public_key *key = (void *) skb->data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct smp_chan *smp = chan->data;\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct crypto_kpp *tfm_ecdh;\n\tstruct smp_cmd_pairing_confirm cfm;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"conn %p\", conn);\n\n\tif (skb->len < sizeof(*key))\n\t\treturn SMP_INVALID_PARAMS;\n\n\t \n\tif (!test_bit(SMP_FLAG_DEBUG_KEY, &smp->flags) &&\n\t    !crypto_memneq(key, smp->local_pk, 64)) {\n\t\tbt_dev_err(hdev, \"Remote and local public keys are identical\");\n\t\treturn SMP_UNSPECIFIED;\n\t}\n\n\tmemcpy(smp->remote_pk, key, 64);\n\n\tif (test_bit(SMP_FLAG_REMOTE_OOB, &smp->flags)) {\n\t\terr = smp_f4(smp->tfm_cmac, smp->remote_pk, smp->remote_pk,\n\t\t\t     smp->rr, 0, cfm.confirm_val);\n\t\tif (err)\n\t\t\treturn SMP_UNSPECIFIED;\n\n\t\tif (crypto_memneq(cfm.confirm_val, smp->pcnf, 16))\n\t\t\treturn SMP_CONFIRM_FAILED;\n\t}\n\n\t \n\tif (!hcon->out) {\n\t\terr = sc_send_public_key(smp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tSMP_DBG(\"Remote Public Key X: %32phN\", smp->remote_pk);\n\tSMP_DBG(\"Remote Public Key Y: %32phN\", smp->remote_pk + 32);\n\n\t \n\tif (test_bit(SMP_FLAG_LOCAL_OOB, &smp->flags)) {\n\t\tstruct l2cap_chan *hchan = hdev->smp_data;\n\t\tstruct smp_dev *smp_dev;\n\n\t\tif (!hchan || !hchan->data)\n\t\t\treturn SMP_UNSPECIFIED;\n\n\t\tsmp_dev = hchan->data;\n\n\t\ttfm_ecdh = smp_dev->tfm_ecdh;\n\t} else {\n\t\ttfm_ecdh = smp->tfm_ecdh;\n\t}\n\n\tif (compute_ecdh_secret(tfm_ecdh, smp->remote_pk, smp->dhkey))\n\t\treturn SMP_UNSPECIFIED;\n\n\tSMP_DBG(\"DHKey %32phN\", smp->dhkey);\n\n\tset_bit(SMP_FLAG_REMOTE_PK, &smp->flags);\n\n\tsmp->method = sc_select_method(smp);\n\n\tbt_dev_dbg(hdev, \"selected method 0x%02x\", smp->method);\n\n\t \n\tif (smp->method == JUST_WORKS || smp->method == JUST_CFM)\n\t\thcon->pending_sec_level = BT_SECURITY_MEDIUM;\n\telse\n\t\thcon->pending_sec_level = BT_SECURITY_FIPS;\n\n\tif (!crypto_memneq(debug_pk, smp->remote_pk, 64))\n\t\tset_bit(SMP_FLAG_DEBUG_KEY, &smp->flags);\n\n\tif (smp->method == DSP_PASSKEY) {\n\t\tget_random_bytes(&hcon->passkey_notify,\n\t\t\t\t sizeof(hcon->passkey_notify));\n\t\thcon->passkey_notify %= 1000000;\n\t\thcon->passkey_entered = 0;\n\t\tsmp->passkey_round = 0;\n\t\tif (mgmt_user_passkey_notify(hdev, &hcon->dst, hcon->type,\n\t\t\t\t\t     hcon->dst_type,\n\t\t\t\t\t     hcon->passkey_notify,\n\t\t\t\t\t     hcon->passkey_entered))\n\t\t\treturn SMP_UNSPECIFIED;\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_CONFIRM);\n\t\treturn sc_passkey_round(smp, SMP_CMD_PUBLIC_KEY);\n\t}\n\n\tif (smp->method == REQ_OOB) {\n\t\tif (hcon->out)\n\t\t\tsmp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM,\n\t\t\t\t     sizeof(smp->prnd), smp->prnd);\n\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_RANDOM);\n\n\t\treturn 0;\n\t}\n\n\tif (hcon->out)\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_CONFIRM);\n\n\tif (smp->method == REQ_PASSKEY) {\n\t\tif (mgmt_user_passkey_request(hdev, &hcon->dst, hcon->type,\n\t\t\t\t\t      hcon->dst_type))\n\t\t\treturn SMP_UNSPECIFIED;\n\t\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_CONFIRM);\n\t\tset_bit(SMP_FLAG_WAIT_USER, &smp->flags);\n\t\treturn 0;\n\t}\n\n\t \n\tif (conn->hcon->out)\n\t\treturn 0;\n\n\terr = smp_f4(smp->tfm_cmac, smp->local_pk, smp->remote_pk, smp->prnd,\n\t\t     0, cfm.confirm_val);\n\tif (err)\n\t\treturn SMP_UNSPECIFIED;\n\n\tsmp_send_cmd(conn, SMP_CMD_PAIRING_CONFIRM, sizeof(cfm), &cfm);\n\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_RANDOM);\n\n\treturn 0;\n}\n\nstatic int smp_cmd_dhkey_check(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct smp_cmd_dhkey_check *check = (void *) skb->data;\n\tstruct l2cap_chan *chan = conn->smp;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct smp_chan *smp = chan->data;\n\tu8 a[7], b[7], *local_addr, *remote_addr;\n\tu8 io_cap[3], r[16], e[16];\n\tint err;\n\n\tbt_dev_dbg(hcon->hdev, \"conn %p\", conn);\n\n\tif (skb->len < sizeof(*check))\n\t\treturn SMP_INVALID_PARAMS;\n\n\tmemcpy(a, &hcon->init_addr, 6);\n\tmemcpy(b, &hcon->resp_addr, 6);\n\ta[6] = hcon->init_addr_type;\n\tb[6] = hcon->resp_addr_type;\n\n\tif (hcon->out) {\n\t\tlocal_addr = a;\n\t\tremote_addr = b;\n\t\tmemcpy(io_cap, &smp->prsp[1], 3);\n\t} else {\n\t\tlocal_addr = b;\n\t\tremote_addr = a;\n\t\tmemcpy(io_cap, &smp->preq[1], 3);\n\t}\n\n\tmemset(r, 0, sizeof(r));\n\n\tif (smp->method == REQ_PASSKEY || smp->method == DSP_PASSKEY)\n\t\tput_unaligned_le32(hcon->passkey_notify, r);\n\telse if (smp->method == REQ_OOB)\n\t\tmemcpy(r, smp->lr, 16);\n\n\terr = smp_f6(smp->tfm_cmac, smp->mackey, smp->rrnd, smp->prnd, r,\n\t\t     io_cap, remote_addr, local_addr, e);\n\tif (err)\n\t\treturn SMP_UNSPECIFIED;\n\n\tif (crypto_memneq(check->e, e, 16))\n\t\treturn SMP_DHKEY_CHECK_FAILED;\n\n\tif (!hcon->out) {\n\t\tif (test_bit(SMP_FLAG_WAIT_USER, &smp->flags)) {\n\t\t\tset_bit(SMP_FLAG_DHKEY_PENDING, &smp->flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tsc_dhkey_check(smp);\n\t}\n\n\tsc_add_ltk(smp);\n\n\tif (hcon->out) {\n\t\thci_le_start_enc(hcon, 0, 0, smp->tk, smp->enc_key_size);\n\t\thcon->enc_key_size = smp->enc_key_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int smp_cmd_keypress_notify(struct l2cap_conn *conn,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct smp_cmd_keypress_notify *kp = (void *) skb->data;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"value 0x%02x\", kp->value);\n\n\treturn 0;\n}\n\nstatic int smp_sig_channel(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct smp_chan *smp;\n\t__u8 code, reason;\n\tint err = 0;\n\n\tif (skb->len < 1)\n\t\treturn -EILSEQ;\n\n\tif (!hci_dev_test_flag(hcon->hdev, HCI_LE_ENABLED)) {\n\t\treason = SMP_PAIRING_NOTSUPP;\n\t\tgoto done;\n\t}\n\n\tcode = skb->data[0];\n\tskb_pull(skb, sizeof(code));\n\n\tsmp = chan->data;\n\n\tif (code > SMP_CMD_MAX)\n\t\tgoto drop;\n\n\tif (smp && !test_and_clear_bit(code, &smp->allow_cmd))\n\t\tgoto drop;\n\n\t \n\tif (!smp && code != SMP_CMD_PAIRING_REQ && code != SMP_CMD_SECURITY_REQ)\n\t\tgoto drop;\n\n\tswitch (code) {\n\tcase SMP_CMD_PAIRING_REQ:\n\t\treason = smp_cmd_pairing_req(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_PAIRING_FAIL:\n\t\tsmp_failure(conn, 0);\n\t\terr = -EPERM;\n\t\tbreak;\n\n\tcase SMP_CMD_PAIRING_RSP:\n\t\treason = smp_cmd_pairing_rsp(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_SECURITY_REQ:\n\t\treason = smp_cmd_security_req(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_PAIRING_CONFIRM:\n\t\treason = smp_cmd_pairing_confirm(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_PAIRING_RANDOM:\n\t\treason = smp_cmd_pairing_random(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_ENCRYPT_INFO:\n\t\treason = smp_cmd_encrypt_info(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_INITIATOR_IDENT:\n\t\treason = smp_cmd_initiator_ident(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_IDENT_INFO:\n\t\treason = smp_cmd_ident_info(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_IDENT_ADDR_INFO:\n\t\treason = smp_cmd_ident_addr_info(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_SIGN_INFO:\n\t\treason = smp_cmd_sign_info(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_PUBLIC_KEY:\n\t\treason = smp_cmd_public_key(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_DHKEY_CHECK:\n\t\treason = smp_cmd_dhkey_check(conn, skb);\n\t\tbreak;\n\n\tcase SMP_CMD_KEYPRESS_NOTIFY:\n\t\treason = smp_cmd_keypress_notify(conn, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tbt_dev_dbg(hcon->hdev, \"Unknown command code 0x%2.2x\", code);\n\t\treason = SMP_CMD_NOTSUPP;\n\t\tgoto done;\n\t}\n\ndone:\n\tif (!err) {\n\t\tif (reason)\n\t\t\tsmp_failure(conn, reason);\n\t\tkfree_skb(skb);\n\t}\n\n\treturn err;\n\ndrop:\n\tbt_dev_err(hcon->hdev, \"unexpected SMP command 0x%02x from %pMR\",\n\t\t   code, &hcon->dst);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic void smp_teardown_cb(struct l2cap_chan *chan, int err)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tbt_dev_dbg(conn->hcon->hdev, \"chan %p\", chan);\n\n\tif (chan->data)\n\t\tsmp_chan_destroy(conn);\n\n\tconn->smp = NULL;\n\tl2cap_chan_put(chan);\n}\n\nstatic void bredr_pairing(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct smp_cmd_pairing req;\n\tstruct smp_chan *smp;\n\n\tbt_dev_dbg(hdev, \"chan %p\", chan);\n\n\t \n\tif (!test_bit(HCI_CONN_NEW_LINK_KEY, &hcon->flags))\n\t\treturn;\n\n\t \n\tif (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags))\n\t\treturn;\n\n\t \n\tif (hcon->role != HCI_ROLE_MASTER)\n\t\treturn;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_SC_ENABLED))\n\t\treturn;\n\n\t \n\tif (!test_bit(HCI_CONN_AES_CCM, &hcon->flags) &&\n\t    !hci_dev_test_flag(hdev, HCI_FORCE_BREDR_SMP))\n\t\treturn;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn;\n\n\t \n\tif (!lmp_host_le_capable(hcon))\n\t\treturn;\n\n\t \n\tif (!(conn->remote_fixed_chan & L2CAP_FC_SMP_BREDR))\n\t\treturn;\n\n\t \n\tif (chan->data)\n\t\treturn;\n\n\tsmp = smp_chan_create(conn);\n\tif (!smp) {\n\t\tbt_dev_err(hdev, \"unable to create SMP context for BR/EDR\");\n\t\treturn;\n\t}\n\n\tset_bit(SMP_FLAG_SC, &smp->flags);\n\n\tbt_dev_dbg(hdev, \"starting SMP over BR/EDR\");\n\n\t \n\tbuild_bredr_pairing_cmd(smp, &req, NULL);\n\n\tsmp->preq[0] = SMP_CMD_PAIRING_REQ;\n\tmemcpy(&smp->preq[1], &req, sizeof(req));\n\n\tsmp_send_cmd(conn, SMP_CMD_PAIRING_REQ, sizeof(req), &req);\n\tSMP_ALLOW_CMD(smp, SMP_CMD_PAIRING_RSP);\n}\n\nstatic void smp_resume_cb(struct l2cap_chan *chan)\n{\n\tstruct smp_chan *smp = chan->data;\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\n\tbt_dev_dbg(hcon->hdev, \"chan %p\", chan);\n\n\tif (hcon->type == ACL_LINK) {\n\t\tbredr_pairing(chan);\n\t\treturn;\n\t}\n\n\tif (!smp)\n\t\treturn;\n\n\tif (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags))\n\t\treturn;\n\n\tcancel_delayed_work(&smp->security_timer);\n\n\tsmp_distribute_keys(smp);\n}\n\nstatic void smp_ready_cb(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct hci_conn *hcon = conn->hcon;\n\n\tbt_dev_dbg(hcon->hdev, \"chan %p\", chan);\n\n\t \n\tconn->smp = chan;\n\n\tif (hcon->type == ACL_LINK && test_bit(HCI_CONN_ENCRYPT, &hcon->flags))\n\t\tbredr_pairing(chan);\n}\n\nstatic int smp_recv_cb(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tint err;\n\n\tbt_dev_dbg(chan->conn->hcon->hdev, \"chan %p\", chan);\n\n\terr = smp_sig_channel(chan, skb);\n\tif (err) {\n\t\tstruct smp_chan *smp = chan->data;\n\n\t\tif (smp)\n\t\t\tcancel_delayed_work_sync(&smp->security_timer);\n\n\t\thci_disconnect(chan->conn->hcon, HCI_ERROR_AUTH_FAILURE);\n\t}\n\n\treturn err;\n}\n\nstatic struct sk_buff *smp_alloc_skb_cb(struct l2cap_chan *chan,\n\t\t\t\t\tunsigned long hdr_len,\n\t\t\t\t\tunsigned long len, int nb)\n{\n\tstruct sk_buff *skb;\n\n\tskb = bt_skb_alloc(hdr_len + len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb->priority = HCI_PRIO_MAX;\n\tbt_cb(skb)->l2cap.chan = chan;\n\n\treturn skb;\n}\n\nstatic const struct l2cap_ops smp_chan_ops = {\n\t.name\t\t\t= \"Security Manager\",\n\t.ready\t\t\t= smp_ready_cb,\n\t.recv\t\t\t= smp_recv_cb,\n\t.alloc_skb\t\t= smp_alloc_skb_cb,\n\t.teardown\t\t= smp_teardown_cb,\n\t.resume\t\t\t= smp_resume_cb,\n\n\t.new_connection\t\t= l2cap_chan_no_new_connection,\n\t.state_change\t\t= l2cap_chan_no_state_change,\n\t.close\t\t\t= l2cap_chan_no_close,\n\t.defer\t\t\t= l2cap_chan_no_defer,\n\t.suspend\t\t= l2cap_chan_no_suspend,\n\t.set_shutdown\t\t= l2cap_chan_no_set_shutdown,\n\t.get_sndtimeo\t\t= l2cap_chan_no_get_sndtimeo,\n};\n\nstatic inline struct l2cap_chan *smp_new_conn_cb(struct l2cap_chan *pchan)\n{\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"pchan %p\", pchan);\n\n\tchan = l2cap_chan_create();\n\tif (!chan)\n\t\treturn NULL;\n\n\tchan->chan_type\t= pchan->chan_type;\n\tchan->ops\t= &smp_chan_ops;\n\tchan->scid\t= pchan->scid;\n\tchan->dcid\t= chan->scid;\n\tchan->imtu\t= pchan->imtu;\n\tchan->omtu\t= pchan->omtu;\n\tchan->mode\t= pchan->mode;\n\n\t \n\tatomic_set(&chan->nesting, L2CAP_NESTING_SMP);\n\n\tBT_DBG(\"created chan %p\", chan);\n\n\treturn chan;\n}\n\nstatic const struct l2cap_ops smp_root_chan_ops = {\n\t.name\t\t\t= \"Security Manager Root\",\n\t.new_connection\t\t= smp_new_conn_cb,\n\n\t \n\t.close\t\t\t= l2cap_chan_no_close,\n\t.alloc_skb\t\t= l2cap_chan_no_alloc_skb,\n\t.recv\t\t\t= l2cap_chan_no_recv,\n\t.state_change\t\t= l2cap_chan_no_state_change,\n\t.teardown\t\t= l2cap_chan_no_teardown,\n\t.ready\t\t\t= l2cap_chan_no_ready,\n\t.defer\t\t\t= l2cap_chan_no_defer,\n\t.suspend\t\t= l2cap_chan_no_suspend,\n\t.resume\t\t\t= l2cap_chan_no_resume,\n\t.set_shutdown\t\t= l2cap_chan_no_set_shutdown,\n\t.get_sndtimeo\t\t= l2cap_chan_no_get_sndtimeo,\n};\n\nstatic struct l2cap_chan *smp_add_cid(struct hci_dev *hdev, u16 cid)\n{\n\tstruct l2cap_chan *chan;\n\tstruct smp_dev *smp;\n\tstruct crypto_shash *tfm_cmac;\n\tstruct crypto_kpp *tfm_ecdh;\n\n\tif (cid == L2CAP_CID_SMP_BREDR) {\n\t\tsmp = NULL;\n\t\tgoto create_chan;\n\t}\n\n\tsmp = kzalloc(sizeof(*smp), GFP_KERNEL);\n\tif (!smp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttfm_cmac = crypto_alloc_shash(\"cmac(aes)\", 0, 0);\n\tif (IS_ERR(tfm_cmac)) {\n\t\tbt_dev_err(hdev, \"Unable to create CMAC crypto context\");\n\t\tkfree_sensitive(smp);\n\t\treturn ERR_CAST(tfm_cmac);\n\t}\n\n\ttfm_ecdh = crypto_alloc_kpp(\"ecdh-nist-p256\", 0, 0);\n\tif (IS_ERR(tfm_ecdh)) {\n\t\tbt_dev_err(hdev, \"Unable to create ECDH crypto context\");\n\t\tcrypto_free_shash(tfm_cmac);\n\t\tkfree_sensitive(smp);\n\t\treturn ERR_CAST(tfm_ecdh);\n\t}\n\n\tsmp->local_oob = false;\n\tsmp->tfm_cmac = tfm_cmac;\n\tsmp->tfm_ecdh = tfm_ecdh;\n\ncreate_chan:\n\tchan = l2cap_chan_create();\n\tif (!chan) {\n\t\tif (smp) {\n\t\t\tcrypto_free_shash(smp->tfm_cmac);\n\t\t\tcrypto_free_kpp(smp->tfm_ecdh);\n\t\t\tkfree_sensitive(smp);\n\t\t}\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tchan->data = smp;\n\n\tl2cap_add_scid(chan, cid);\n\n\tl2cap_chan_set_defaults(chan);\n\n\tif (cid == L2CAP_CID_SMP) {\n\t\tu8 bdaddr_type;\n\n\t\thci_copy_identity_address(hdev, &chan->src, &bdaddr_type);\n\n\t\tif (bdaddr_type == ADDR_LE_DEV_PUBLIC)\n\t\t\tchan->src_type = BDADDR_LE_PUBLIC;\n\t\telse\n\t\t\tchan->src_type = BDADDR_LE_RANDOM;\n\t} else {\n\t\tbacpy(&chan->src, &hdev->bdaddr);\n\t\tchan->src_type = BDADDR_BREDR;\n\t}\n\n\tchan->state = BT_LISTEN;\n\tchan->mode = L2CAP_MODE_BASIC;\n\tchan->imtu = L2CAP_DEFAULT_MTU;\n\tchan->ops = &smp_root_chan_ops;\n\n\t \n\tatomic_set(&chan->nesting, L2CAP_NESTING_PARENT);\n\n\treturn chan;\n}\n\nstatic void smp_del_chan(struct l2cap_chan *chan)\n{\n\tstruct smp_dev *smp;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tsmp = chan->data;\n\tif (smp) {\n\t\tchan->data = NULL;\n\t\tcrypto_free_shash(smp->tfm_cmac);\n\t\tcrypto_free_kpp(smp->tfm_ecdh);\n\t\tkfree_sensitive(smp);\n\t}\n\n\tl2cap_chan_put(chan);\n}\n\nint smp_force_bredr(struct hci_dev *hdev, bool enable)\n{\n\tif (enable == hci_dev_test_flag(hdev, HCI_FORCE_BREDR_SMP))\n\t\treturn -EALREADY;\n\n\tif (enable) {\n\t\tstruct l2cap_chan *chan;\n\n\t\tchan = smp_add_cid(hdev, L2CAP_CID_SMP_BREDR);\n\t\tif (IS_ERR(chan))\n\t\t\treturn PTR_ERR(chan);\n\n\t\thdev->smp_bredr_data = chan;\n\t} else {\n\t\tstruct l2cap_chan *chan;\n\n\t\tchan = hdev->smp_bredr_data;\n\t\thdev->smp_bredr_data = NULL;\n\t\tsmp_del_chan(chan);\n\t}\n\n\thci_dev_change_flag(hdev, HCI_FORCE_BREDR_SMP);\n\n\treturn 0;\n}\n\nint smp_register(struct hci_dev *hdev)\n{\n\tstruct l2cap_chan *chan;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\t \n\tif (!lmp_le_capable(hdev))\n\t\treturn 0;\n\n\tif (WARN_ON(hdev->smp_data)) {\n\t\tchan = hdev->smp_data;\n\t\thdev->smp_data = NULL;\n\t\tsmp_del_chan(chan);\n\t}\n\n\tchan = smp_add_cid(hdev, L2CAP_CID_SMP);\n\tif (IS_ERR(chan))\n\t\treturn PTR_ERR(chan);\n\n\thdev->smp_data = chan;\n\n\tif (!lmp_sc_capable(hdev)) {\n\t\t \n\t\tif (!hci_dev_test_flag(hdev, HCI_FORCE_BREDR_SMP))\n\t\t\treturn 0;\n\t}\n\n\tif (WARN_ON(hdev->smp_bredr_data)) {\n\t\tchan = hdev->smp_bredr_data;\n\t\thdev->smp_bredr_data = NULL;\n\t\tsmp_del_chan(chan);\n\t}\n\n\tchan = smp_add_cid(hdev, L2CAP_CID_SMP_BREDR);\n\tif (IS_ERR(chan)) {\n\t\tint err = PTR_ERR(chan);\n\t\tchan = hdev->smp_data;\n\t\thdev->smp_data = NULL;\n\t\tsmp_del_chan(chan);\n\t\treturn err;\n\t}\n\n\thdev->smp_bredr_data = chan;\n\n\treturn 0;\n}\n\nvoid smp_unregister(struct hci_dev *hdev)\n{\n\tstruct l2cap_chan *chan;\n\n\tif (hdev->smp_bredr_data) {\n\t\tchan = hdev->smp_bredr_data;\n\t\thdev->smp_bredr_data = NULL;\n\t\tsmp_del_chan(chan);\n\t}\n\n\tif (hdev->smp_data) {\n\t\tchan = hdev->smp_data;\n\t\thdev->smp_data = NULL;\n\t\tsmp_del_chan(chan);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_BT_SELFTEST_SMP)\n\nstatic int __init test_debug_key(struct crypto_kpp *tfm_ecdh)\n{\n\tu8 pk[64];\n\tint err;\n\n\terr = set_ecdh_privkey(tfm_ecdh, debug_sk);\n\tif (err)\n\t\treturn err;\n\n\terr = generate_ecdh_public_key(tfm_ecdh, pk);\n\tif (err)\n\t\treturn err;\n\n\tif (crypto_memneq(pk, debug_pk, 64))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init test_ah(void)\n{\n\tconst u8 irk[16] = {\n\t\t\t0x9b, 0x7d, 0x39, 0x0a, 0xa6, 0x10, 0x10, 0x34,\n\t\t\t0x05, 0xad, 0xc8, 0x57, 0xa3, 0x34, 0x02, 0xec };\n\tconst u8 r[3] = { 0x94, 0x81, 0x70 };\n\tconst u8 exp[3] = { 0xaa, 0xfb, 0x0d };\n\tu8 res[3];\n\tint err;\n\n\terr = smp_ah(irk, r, res);\n\tif (err)\n\t\treturn err;\n\n\tif (crypto_memneq(res, exp, 3))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init test_c1(void)\n{\n\tconst u8 k[16] = {\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tconst u8 r[16] = {\n\t\t\t0xe0, 0x2e, 0x70, 0xc6, 0x4e, 0x27, 0x88, 0x63,\n\t\t\t0x0e, 0x6f, 0xad, 0x56, 0x21, 0xd5, 0x83, 0x57 };\n\tconst u8 preq[7] = { 0x01, 0x01, 0x00, 0x00, 0x10, 0x07, 0x07 };\n\tconst u8 pres[7] = { 0x02, 0x03, 0x00, 0x00, 0x08, 0x00, 0x05 };\n\tconst u8 _iat = 0x01;\n\tconst u8 _rat = 0x00;\n\tconst bdaddr_t ra = { { 0xb6, 0xb5, 0xb4, 0xb3, 0xb2, 0xb1 } };\n\tconst bdaddr_t ia = { { 0xa6, 0xa5, 0xa4, 0xa3, 0xa2, 0xa1 } };\n\tconst u8 exp[16] = {\n\t\t\t0x86, 0x3b, 0xf1, 0xbe, 0xc5, 0x4d, 0xa7, 0xd2,\n\t\t\t0xea, 0x88, 0x89, 0x87, 0xef, 0x3f, 0x1e, 0x1e };\n\tu8 res[16];\n\tint err;\n\n\terr = smp_c1(k, r, preq, pres, _iat, &ia, _rat, &ra, res);\n\tif (err)\n\t\treturn err;\n\n\tif (crypto_memneq(res, exp, 16))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init test_s1(void)\n{\n\tconst u8 k[16] = {\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tconst u8 r1[16] = {\n\t\t\t0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11 };\n\tconst u8 r2[16] = {\n\t\t\t0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99 };\n\tconst u8 exp[16] = {\n\t\t\t0x62, 0xa0, 0x6d, 0x79, 0xae, 0x16, 0x42, 0x5b,\n\t\t\t0x9b, 0xf4, 0xb0, 0xe8, 0xf0, 0xe1, 0x1f, 0x9a };\n\tu8 res[16];\n\tint err;\n\n\terr = smp_s1(k, r1, r2, res);\n\tif (err)\n\t\treturn err;\n\n\tif (crypto_memneq(res, exp, 16))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init test_f4(struct crypto_shash *tfm_cmac)\n{\n\tconst u8 u[32] = {\n\t\t\t0xe6, 0x9d, 0x35, 0x0e, 0x48, 0x01, 0x03, 0xcc,\n\t\t\t0xdb, 0xfd, 0xf4, 0xac, 0x11, 0x91, 0xf4, 0xef,\n\t\t\t0xb9, 0xa5, 0xf9, 0xe9, 0xa7, 0x83, 0x2c, 0x5e,\n\t\t\t0x2c, 0xbe, 0x97, 0xf2, 0xd2, 0x03, 0xb0, 0x20 };\n\tconst u8 v[32] = {\n\t\t\t0xfd, 0xc5, 0x7f, 0xf4, 0x49, 0xdd, 0x4f, 0x6b,\n\t\t\t0xfb, 0x7c, 0x9d, 0xf1, 0xc2, 0x9a, 0xcb, 0x59,\n\t\t\t0x2a, 0xe7, 0xd4, 0xee, 0xfb, 0xfc, 0x0a, 0x90,\n\t\t\t0x9a, 0xbb, 0xf6, 0x32, 0x3d, 0x8b, 0x18, 0x55 };\n\tconst u8 x[16] = {\n\t\t\t0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,\n\t\t\t0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5 };\n\tconst u8 z = 0x00;\n\tconst u8 exp[16] = {\n\t\t\t0x2d, 0x87, 0x74, 0xa9, 0xbe, 0xa1, 0xed, 0xf1,\n\t\t\t0x1c, 0xbd, 0xa9, 0x07, 0xf1, 0x16, 0xc9, 0xf2 };\n\tu8 res[16];\n\tint err;\n\n\terr = smp_f4(tfm_cmac, u, v, x, z, res);\n\tif (err)\n\t\treturn err;\n\n\tif (crypto_memneq(res, exp, 16))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init test_f5(struct crypto_shash *tfm_cmac)\n{\n\tconst u8 w[32] = {\n\t\t\t0x98, 0xa6, 0xbf, 0x73, 0xf3, 0x34, 0x8d, 0x86,\n\t\t\t0xf1, 0x66, 0xf8, 0xb4, 0x13, 0x6b, 0x79, 0x99,\n\t\t\t0x9b, 0x7d, 0x39, 0x0a, 0xa6, 0x10, 0x10, 0x34,\n\t\t\t0x05, 0xad, 0xc8, 0x57, 0xa3, 0x34, 0x02, 0xec };\n\tconst u8 n1[16] = {\n\t\t\t0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,\n\t\t\t0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5 };\n\tconst u8 n2[16] = {\n\t\t\t0xcf, 0xc4, 0x3d, 0xff, 0xf7, 0x83, 0x65, 0x21,\n\t\t\t0x6e, 0x5f, 0xa7, 0x25, 0xcc, 0xe7, 0xe8, 0xa6 };\n\tconst u8 a1[7] = { 0xce, 0xbf, 0x37, 0x37, 0x12, 0x56, 0x00 };\n\tconst u8 a2[7] = { 0xc1, 0xcf, 0x2d, 0x70, 0x13, 0xa7, 0x00 };\n\tconst u8 exp_ltk[16] = {\n\t\t\t0x38, 0x0a, 0x75, 0x94, 0xb5, 0x22, 0x05, 0x98,\n\t\t\t0x23, 0xcd, 0xd7, 0x69, 0x11, 0x79, 0x86, 0x69 };\n\tconst u8 exp_mackey[16] = {\n\t\t\t0x20, 0x6e, 0x63, 0xce, 0x20, 0x6a, 0x3f, 0xfd,\n\t\t\t0x02, 0x4a, 0x08, 0xa1, 0x76, 0xf1, 0x65, 0x29 };\n\tu8 mackey[16], ltk[16];\n\tint err;\n\n\terr = smp_f5(tfm_cmac, w, n1, n2, a1, a2, mackey, ltk);\n\tif (err)\n\t\treturn err;\n\n\tif (crypto_memneq(mackey, exp_mackey, 16))\n\t\treturn -EINVAL;\n\n\tif (crypto_memneq(ltk, exp_ltk, 16))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init test_f6(struct crypto_shash *tfm_cmac)\n{\n\tconst u8 w[16] = {\n\t\t\t0x20, 0x6e, 0x63, 0xce, 0x20, 0x6a, 0x3f, 0xfd,\n\t\t\t0x02, 0x4a, 0x08, 0xa1, 0x76, 0xf1, 0x65, 0x29 };\n\tconst u8 n1[16] = {\n\t\t\t0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,\n\t\t\t0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5 };\n\tconst u8 n2[16] = {\n\t\t\t0xcf, 0xc4, 0x3d, 0xff, 0xf7, 0x83, 0x65, 0x21,\n\t\t\t0x6e, 0x5f, 0xa7, 0x25, 0xcc, 0xe7, 0xe8, 0xa6 };\n\tconst u8 r[16] = {\n\t\t\t0xc8, 0x0f, 0x2d, 0x0c, 0xd2, 0x42, 0xda, 0x08,\n\t\t\t0x54, 0xbb, 0x53, 0xb4, 0x3b, 0x34, 0xa3, 0x12 };\n\tconst u8 io_cap[3] = { 0x02, 0x01, 0x01 };\n\tconst u8 a1[7] = { 0xce, 0xbf, 0x37, 0x37, 0x12, 0x56, 0x00 };\n\tconst u8 a2[7] = { 0xc1, 0xcf, 0x2d, 0x70, 0x13, 0xa7, 0x00 };\n\tconst u8 exp[16] = {\n\t\t\t0x61, 0x8f, 0x95, 0xda, 0x09, 0x0b, 0x6c, 0xd2,\n\t\t\t0xc5, 0xe8, 0xd0, 0x9c, 0x98, 0x73, 0xc4, 0xe3 };\n\tu8 res[16];\n\tint err;\n\n\terr = smp_f6(tfm_cmac, w, n1, n2, r, io_cap, a1, a2, res);\n\tif (err)\n\t\treturn err;\n\n\tif (crypto_memneq(res, exp, 16))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init test_g2(struct crypto_shash *tfm_cmac)\n{\n\tconst u8 u[32] = {\n\t\t\t0xe6, 0x9d, 0x35, 0x0e, 0x48, 0x01, 0x03, 0xcc,\n\t\t\t0xdb, 0xfd, 0xf4, 0xac, 0x11, 0x91, 0xf4, 0xef,\n\t\t\t0xb9, 0xa5, 0xf9, 0xe9, 0xa7, 0x83, 0x2c, 0x5e,\n\t\t\t0x2c, 0xbe, 0x97, 0xf2, 0xd2, 0x03, 0xb0, 0x20 };\n\tconst u8 v[32] = {\n\t\t\t0xfd, 0xc5, 0x7f, 0xf4, 0x49, 0xdd, 0x4f, 0x6b,\n\t\t\t0xfb, 0x7c, 0x9d, 0xf1, 0xc2, 0x9a, 0xcb, 0x59,\n\t\t\t0x2a, 0xe7, 0xd4, 0xee, 0xfb, 0xfc, 0x0a, 0x90,\n\t\t\t0x9a, 0xbb, 0xf6, 0x32, 0x3d, 0x8b, 0x18, 0x55 };\n\tconst u8 x[16] = {\n\t\t\t0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,\n\t\t\t0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5 };\n\tconst u8 y[16] = {\n\t\t\t0xcf, 0xc4, 0x3d, 0xff, 0xf7, 0x83, 0x65, 0x21,\n\t\t\t0x6e, 0x5f, 0xa7, 0x25, 0xcc, 0xe7, 0xe8, 0xa6 };\n\tconst u32 exp_val = 0x2f9ed5ba % 1000000;\n\tu32 val;\n\tint err;\n\n\terr = smp_g2(tfm_cmac, u, v, x, y, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val != exp_val)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init test_h6(struct crypto_shash *tfm_cmac)\n{\n\tconst u8 w[16] = {\n\t\t\t0x9b, 0x7d, 0x39, 0x0a, 0xa6, 0x10, 0x10, 0x34,\n\t\t\t0x05, 0xad, 0xc8, 0x57, 0xa3, 0x34, 0x02, 0xec };\n\tconst u8 key_id[4] = { 0x72, 0x62, 0x65, 0x6c };\n\tconst u8 exp[16] = {\n\t\t\t0x99, 0x63, 0xb1, 0x80, 0xe2, 0xa9, 0xd3, 0xe8,\n\t\t\t0x1c, 0xc9, 0x6d, 0xe7, 0x02, 0xe1, 0x9a, 0x2d };\n\tu8 res[16];\n\tint err;\n\n\terr = smp_h6(tfm_cmac, w, key_id, res);\n\tif (err)\n\t\treturn err;\n\n\tif (crypto_memneq(res, exp, 16))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic char test_smp_buffer[32];\n\nstatic ssize_t test_smp_read(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(user_buf, count, ppos, test_smp_buffer,\n\t\t\t\t       strlen(test_smp_buffer));\n}\n\nstatic const struct file_operations test_smp_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= test_smp_read,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic int __init run_selftests(struct crypto_shash *tfm_cmac,\n\t\t\t\tstruct crypto_kpp *tfm_ecdh)\n{\n\tktime_t calltime, delta, rettime;\n\tunsigned long long duration;\n\tint err;\n\n\tcalltime = ktime_get();\n\n\terr = test_debug_key(tfm_ecdh);\n\tif (err) {\n\t\tBT_ERR(\"debug_key test failed\");\n\t\tgoto done;\n\t}\n\n\terr = test_ah();\n\tif (err) {\n\t\tBT_ERR(\"smp_ah test failed\");\n\t\tgoto done;\n\t}\n\n\terr = test_c1();\n\tif (err) {\n\t\tBT_ERR(\"smp_c1 test failed\");\n\t\tgoto done;\n\t}\n\n\terr = test_s1();\n\tif (err) {\n\t\tBT_ERR(\"smp_s1 test failed\");\n\t\tgoto done;\n\t}\n\n\terr = test_f4(tfm_cmac);\n\tif (err) {\n\t\tBT_ERR(\"smp_f4 test failed\");\n\t\tgoto done;\n\t}\n\n\terr = test_f5(tfm_cmac);\n\tif (err) {\n\t\tBT_ERR(\"smp_f5 test failed\");\n\t\tgoto done;\n\t}\n\n\terr = test_f6(tfm_cmac);\n\tif (err) {\n\t\tBT_ERR(\"smp_f6 test failed\");\n\t\tgoto done;\n\t}\n\n\terr = test_g2(tfm_cmac);\n\tif (err) {\n\t\tBT_ERR(\"smp_g2 test failed\");\n\t\tgoto done;\n\t}\n\n\terr = test_h6(tfm_cmac);\n\tif (err) {\n\t\tBT_ERR(\"smp_h6 test failed\");\n\t\tgoto done;\n\t}\n\n\trettime = ktime_get();\n\tdelta = ktime_sub(rettime, calltime);\n\tduration = (unsigned long long) ktime_to_ns(delta) >> 10;\n\n\tBT_INFO(\"SMP test passed in %llu usecs\", duration);\n\ndone:\n\tif (!err)\n\t\tsnprintf(test_smp_buffer, sizeof(test_smp_buffer),\n\t\t\t \"PASS (%llu usecs)\\n\", duration);\n\telse\n\t\tsnprintf(test_smp_buffer, sizeof(test_smp_buffer), \"FAIL\\n\");\n\n\tdebugfs_create_file(\"selftest_smp\", 0444, bt_debugfs, NULL,\n\t\t\t    &test_smp_fops);\n\n\treturn err;\n}\n\nint __init bt_selftest_smp(void)\n{\n\tstruct crypto_shash *tfm_cmac;\n\tstruct crypto_kpp *tfm_ecdh;\n\tint err;\n\n\ttfm_cmac = crypto_alloc_shash(\"cmac(aes)\", 0, 0);\n\tif (IS_ERR(tfm_cmac)) {\n\t\tBT_ERR(\"Unable to create CMAC crypto context\");\n\t\treturn PTR_ERR(tfm_cmac);\n\t}\n\n\ttfm_ecdh = crypto_alloc_kpp(\"ecdh-nist-p256\", 0, 0);\n\tif (IS_ERR(tfm_ecdh)) {\n\t\tBT_ERR(\"Unable to create ECDH crypto context\");\n\t\tcrypto_free_shash(tfm_cmac);\n\t\treturn PTR_ERR(tfm_ecdh);\n\t}\n\n\terr = run_selftests(tfm_cmac, tfm_ecdh);\n\n\tcrypto_free_shash(tfm_cmac);\n\tcrypto_free_kpp(tfm_ecdh);\n\n\treturn err;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}