{
  "module_name": "core.c",
  "hash_id": "fddf341d13f7cf7a59fcc69bfca0f087aa785a977eec933ef93be5410b64f139",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/rfcomm/core.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/kthread.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n#include <net/bluetooth/rfcomm.h>\n\n#include <trace/events/sock.h>\n\n#define VERSION \"1.11\"\n\nstatic bool disable_cfc;\nstatic bool l2cap_ertm;\nstatic int channel_mtu = -1;\n\nstatic struct task_struct *rfcomm_thread;\n\nstatic DEFINE_MUTEX(rfcomm_mutex);\n#define rfcomm_lock()\tmutex_lock(&rfcomm_mutex)\n#define rfcomm_unlock()\tmutex_unlock(&rfcomm_mutex)\n\n\nstatic LIST_HEAD(session_list);\n\nstatic int rfcomm_send_frame(struct rfcomm_session *s, u8 *data, int len);\nstatic int rfcomm_send_sabm(struct rfcomm_session *s, u8 dlci);\nstatic int rfcomm_send_disc(struct rfcomm_session *s, u8 dlci);\nstatic int rfcomm_queue_disc(struct rfcomm_dlc *d);\nstatic int rfcomm_send_nsc(struct rfcomm_session *s, int cr, u8 type);\nstatic int rfcomm_send_pn(struct rfcomm_session *s, int cr, struct rfcomm_dlc *d);\nstatic int rfcomm_send_msc(struct rfcomm_session *s, int cr, u8 dlci, u8 v24_sig);\nstatic int rfcomm_send_test(struct rfcomm_session *s, int cr, u8 *pattern, int len);\nstatic int rfcomm_send_credits(struct rfcomm_session *s, u8 addr, u8 credits);\nstatic void rfcomm_make_uih(struct sk_buff *skb, u8 addr);\n\nstatic void rfcomm_process_connect(struct rfcomm_session *s);\n\nstatic struct rfcomm_session *rfcomm_session_create(bdaddr_t *src,\n\t\t\t\t\t\t\tbdaddr_t *dst,\n\t\t\t\t\t\t\tu8 sec_level,\n\t\t\t\t\t\t\tint *err);\nstatic struct rfcomm_session *rfcomm_session_get(bdaddr_t *src, bdaddr_t *dst);\nstatic struct rfcomm_session *rfcomm_session_del(struct rfcomm_session *s);\n\n \n#define __get_dlci(b)     ((b & 0xfc) >> 2)\n#define __get_type(b)     ((b & 0xef))\n\n#define __test_ea(b)      ((b & 0x01))\n#define __test_cr(b)      (!!(b & 0x02))\n#define __test_pf(b)      (!!(b & 0x10))\n\n#define __session_dir(s)  ((s)->initiator ? 0x00 : 0x01)\n\n#define __addr(cr, dlci)       (((dlci & 0x3f) << 2) | (cr << 1) | 0x01)\n#define __ctrl(type, pf)       (((type & 0xef) | (pf << 4)))\n#define __dlci(dir, chn)       (((chn & 0x1f) << 1) | dir)\n#define __srv_channel(dlci)    (dlci >> 1)\n\n#define __len8(len)       (((len) << 1) | 1)\n#define __len16(len)      ((len) << 1)\n\n \n#define __mcc_type(cr, type)   (((type << 2) | (cr << 1) | 0x01))\n#define __get_mcc_type(b) ((b & 0xfc) >> 2)\n#define __get_mcc_len(b)  ((b & 0xfe) >> 1)\n\n \n#define __rpn_line_settings(data, stop, parity)  ((data & 0x3) | ((stop & 0x1) << 2) | ((parity & 0x7) << 3))\n#define __get_rpn_data_bits(line) ((line) & 0x3)\n#define __get_rpn_stop_bits(line) (((line) >> 2) & 0x1)\n#define __get_rpn_parity(line)    (((line) >> 3) & 0x7)\n\nstatic DECLARE_WAIT_QUEUE_HEAD(rfcomm_wq);\n\nstatic void rfcomm_schedule(void)\n{\n\twake_up_all(&rfcomm_wq);\n}\n\n \n\n \nstatic unsigned char rfcomm_crc_table[256] = {\n\t0x00, 0x91, 0xe3, 0x72, 0x07, 0x96, 0xe4, 0x75,\n\t0x0e, 0x9f, 0xed, 0x7c, 0x09, 0x98, 0xea, 0x7b,\n\t0x1c, 0x8d, 0xff, 0x6e, 0x1b, 0x8a, 0xf8, 0x69,\n\t0x12, 0x83, 0xf1, 0x60, 0x15, 0x84, 0xf6, 0x67,\n\n\t0x38, 0xa9, 0xdb, 0x4a, 0x3f, 0xae, 0xdc, 0x4d,\n\t0x36, 0xa7, 0xd5, 0x44, 0x31, 0xa0, 0xd2, 0x43,\n\t0x24, 0xb5, 0xc7, 0x56, 0x23, 0xb2, 0xc0, 0x51,\n\t0x2a, 0xbb, 0xc9, 0x58, 0x2d, 0xbc, 0xce, 0x5f,\n\n\t0x70, 0xe1, 0x93, 0x02, 0x77, 0xe6, 0x94, 0x05,\n\t0x7e, 0xef, 0x9d, 0x0c, 0x79, 0xe8, 0x9a, 0x0b,\n\t0x6c, 0xfd, 0x8f, 0x1e, 0x6b, 0xfa, 0x88, 0x19,\n\t0x62, 0xf3, 0x81, 0x10, 0x65, 0xf4, 0x86, 0x17,\n\n\t0x48, 0xd9, 0xab, 0x3a, 0x4f, 0xde, 0xac, 0x3d,\n\t0x46, 0xd7, 0xa5, 0x34, 0x41, 0xd0, 0xa2, 0x33,\n\t0x54, 0xc5, 0xb7, 0x26, 0x53, 0xc2, 0xb0, 0x21,\n\t0x5a, 0xcb, 0xb9, 0x28, 0x5d, 0xcc, 0xbe, 0x2f,\n\n\t0xe0, 0x71, 0x03, 0x92, 0xe7, 0x76, 0x04, 0x95,\n\t0xee, 0x7f, 0x0d, 0x9c, 0xe9, 0x78, 0x0a, 0x9b,\n\t0xfc, 0x6d, 0x1f, 0x8e, 0xfb, 0x6a, 0x18, 0x89,\n\t0xf2, 0x63, 0x11, 0x80, 0xf5, 0x64, 0x16, 0x87,\n\n\t0xd8, 0x49, 0x3b, 0xaa, 0xdf, 0x4e, 0x3c, 0xad,\n\t0xd6, 0x47, 0x35, 0xa4, 0xd1, 0x40, 0x32, 0xa3,\n\t0xc4, 0x55, 0x27, 0xb6, 0xc3, 0x52, 0x20, 0xb1,\n\t0xca, 0x5b, 0x29, 0xb8, 0xcd, 0x5c, 0x2e, 0xbf,\n\n\t0x90, 0x01, 0x73, 0xe2, 0x97, 0x06, 0x74, 0xe5,\n\t0x9e, 0x0f, 0x7d, 0xec, 0x99, 0x08, 0x7a, 0xeb,\n\t0x8c, 0x1d, 0x6f, 0xfe, 0x8b, 0x1a, 0x68, 0xf9,\n\t0x82, 0x13, 0x61, 0xf0, 0x85, 0x14, 0x66, 0xf7,\n\n\t0xa8, 0x39, 0x4b, 0xda, 0xaf, 0x3e, 0x4c, 0xdd,\n\t0xa6, 0x37, 0x45, 0xd4, 0xa1, 0x30, 0x42, 0xd3,\n\t0xb4, 0x25, 0x57, 0xc6, 0xb3, 0x22, 0x50, 0xc1,\n\t0xba, 0x2b, 0x59, 0xc8, 0xbd, 0x2c, 0x5e, 0xcf\n};\n\n \n#define __crc(data) (rfcomm_crc_table[rfcomm_crc_table[0xff ^ data[0]] ^ data[1]])\n\n \nstatic inline u8 __fcs(u8 *data)\n{\n\treturn 0xff - __crc(data);\n}\n\n \nstatic inline u8 __fcs2(u8 *data)\n{\n\treturn 0xff - rfcomm_crc_table[__crc(data) ^ data[2]];\n}\n\n \nstatic inline int __check_fcs(u8 *data, int type, u8 fcs)\n{\n\tu8 f = __crc(data);\n\n\tif (type != RFCOMM_UIH)\n\t\tf = rfcomm_crc_table[f ^ data[2]];\n\n\treturn rfcomm_crc_table[f ^ fcs] != 0xcf;\n}\n\n \nstatic void rfcomm_l2state_change(struct sock *sk)\n{\n\tBT_DBG(\"%p state %d\", sk, sk->sk_state);\n\trfcomm_schedule();\n}\n\nstatic void rfcomm_l2data_ready(struct sock *sk)\n{\n\ttrace_sk_data_ready(sk);\n\n\tBT_DBG(\"%p\", sk);\n\trfcomm_schedule();\n}\n\nstatic int rfcomm_l2sock_create(struct socket **sock)\n{\n\tint err;\n\n\tBT_DBG(\"\");\n\n\terr = sock_create_kern(&init_net, PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP, sock);\n\tif (!err) {\n\t\tstruct sock *sk = (*sock)->sk;\n\t\tsk->sk_data_ready   = rfcomm_l2data_ready;\n\t\tsk->sk_state_change = rfcomm_l2state_change;\n\t}\n\treturn err;\n}\n\nstatic int rfcomm_check_security(struct rfcomm_dlc *d)\n{\n\tstruct sock *sk = d->session->sock->sk;\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;\n\n\t__u8 auth_type;\n\n\tswitch (d->sec_level) {\n\tcase BT_SECURITY_HIGH:\n\tcase BT_SECURITY_FIPS:\n\t\tauth_type = HCI_AT_GENERAL_BONDING_MITM;\n\t\tbreak;\n\tcase BT_SECURITY_MEDIUM:\n\t\tauth_type = HCI_AT_GENERAL_BONDING;\n\t\tbreak;\n\tdefault:\n\t\tauth_type = HCI_AT_NO_BONDING;\n\t\tbreak;\n\t}\n\n\treturn hci_conn_security(conn->hcon, d->sec_level, auth_type,\n\t\t\t\t d->out);\n}\n\nstatic void rfcomm_session_timeout(struct timer_list *t)\n{\n\tstruct rfcomm_session *s = from_timer(s, t, timer);\n\n\tBT_DBG(\"session %p state %ld\", s, s->state);\n\n\tset_bit(RFCOMM_TIMED_OUT, &s->flags);\n\trfcomm_schedule();\n}\n\nstatic void rfcomm_session_set_timer(struct rfcomm_session *s, long timeout)\n{\n\tBT_DBG(\"session %p state %ld timeout %ld\", s, s->state, timeout);\n\n\tmod_timer(&s->timer, jiffies + timeout);\n}\n\nstatic void rfcomm_session_clear_timer(struct rfcomm_session *s)\n{\n\tBT_DBG(\"session %p state %ld\", s, s->state);\n\n\tdel_timer_sync(&s->timer);\n}\n\n \nstatic void rfcomm_dlc_timeout(struct timer_list *t)\n{\n\tstruct rfcomm_dlc *d = from_timer(d, t, timer);\n\n\tBT_DBG(\"dlc %p state %ld\", d, d->state);\n\n\tset_bit(RFCOMM_TIMED_OUT, &d->flags);\n\trfcomm_dlc_put(d);\n\trfcomm_schedule();\n}\n\nstatic void rfcomm_dlc_set_timer(struct rfcomm_dlc *d, long timeout)\n{\n\tBT_DBG(\"dlc %p state %ld timeout %ld\", d, d->state, timeout);\n\n\tif (!mod_timer(&d->timer, jiffies + timeout))\n\t\trfcomm_dlc_hold(d);\n}\n\nstatic void rfcomm_dlc_clear_timer(struct rfcomm_dlc *d)\n{\n\tBT_DBG(\"dlc %p state %ld\", d, d->state);\n\n\tif (del_timer(&d->timer))\n\t\trfcomm_dlc_put(d);\n}\n\nstatic void rfcomm_dlc_clear_state(struct rfcomm_dlc *d)\n{\n\tBT_DBG(\"%p\", d);\n\n\td->state      = BT_OPEN;\n\td->flags      = 0;\n\td->mscex      = 0;\n\td->sec_level  = BT_SECURITY_LOW;\n\td->mtu        = RFCOMM_DEFAULT_MTU;\n\td->v24_sig    = RFCOMM_V24_RTC | RFCOMM_V24_RTR | RFCOMM_V24_DV;\n\n\td->cfc        = RFCOMM_CFC_DISABLED;\n\td->rx_credits = RFCOMM_DEFAULT_CREDITS;\n}\n\nstruct rfcomm_dlc *rfcomm_dlc_alloc(gfp_t prio)\n{\n\tstruct rfcomm_dlc *d = kzalloc(sizeof(*d), prio);\n\n\tif (!d)\n\t\treturn NULL;\n\n\ttimer_setup(&d->timer, rfcomm_dlc_timeout, 0);\n\n\tskb_queue_head_init(&d->tx_queue);\n\tmutex_init(&d->lock);\n\trefcount_set(&d->refcnt, 1);\n\n\trfcomm_dlc_clear_state(d);\n\n\tBT_DBG(\"%p\", d);\n\n\treturn d;\n}\n\nvoid rfcomm_dlc_free(struct rfcomm_dlc *d)\n{\n\tBT_DBG(\"%p\", d);\n\n\tskb_queue_purge(&d->tx_queue);\n\tkfree(d);\n}\n\nstatic void rfcomm_dlc_link(struct rfcomm_session *s, struct rfcomm_dlc *d)\n{\n\tBT_DBG(\"dlc %p session %p\", d, s);\n\n\trfcomm_session_clear_timer(s);\n\trfcomm_dlc_hold(d);\n\tlist_add(&d->list, &s->dlcs);\n\td->session = s;\n}\n\nstatic void rfcomm_dlc_unlink(struct rfcomm_dlc *d)\n{\n\tstruct rfcomm_session *s = d->session;\n\n\tBT_DBG(\"dlc %p refcnt %d session %p\", d, refcount_read(&d->refcnt), s);\n\n\tlist_del(&d->list);\n\td->session = NULL;\n\trfcomm_dlc_put(d);\n\n\tif (list_empty(&s->dlcs))\n\t\trfcomm_session_set_timer(s, RFCOMM_IDLE_TIMEOUT);\n}\n\nstatic struct rfcomm_dlc *rfcomm_dlc_get(struct rfcomm_session *s, u8 dlci)\n{\n\tstruct rfcomm_dlc *d;\n\n\tlist_for_each_entry(d, &s->dlcs, list)\n\t\tif (d->dlci == dlci)\n\t\t\treturn d;\n\n\treturn NULL;\n}\n\nstatic int rfcomm_check_channel(u8 channel)\n{\n\treturn channel < 1 || channel > 30;\n}\n\nstatic int __rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst, u8 channel)\n{\n\tstruct rfcomm_session *s;\n\tint err = 0;\n\tu8 dlci;\n\n\tBT_DBG(\"dlc %p state %ld %pMR -> %pMR channel %d\",\n\t       d, d->state, src, dst, channel);\n\n\tif (rfcomm_check_channel(channel))\n\t\treturn -EINVAL;\n\n\tif (d->state != BT_OPEN && d->state != BT_CLOSED)\n\t\treturn 0;\n\n\ts = rfcomm_session_get(src, dst);\n\tif (!s) {\n\t\ts = rfcomm_session_create(src, dst, d->sec_level, &err);\n\t\tif (!s)\n\t\t\treturn err;\n\t}\n\n\tdlci = __dlci(__session_dir(s), channel);\n\n\t \n\tif (rfcomm_dlc_get(s, dlci))\n\t\treturn -EBUSY;\n\n\trfcomm_dlc_clear_state(d);\n\n\td->dlci     = dlci;\n\td->addr     = __addr(s->initiator, dlci);\n\td->priority = 7;\n\n\td->state = BT_CONFIG;\n\trfcomm_dlc_link(s, d);\n\n\td->out = 1;\n\n\td->mtu = s->mtu;\n\td->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;\n\n\tif (s->state == BT_CONNECTED) {\n\t\tif (rfcomm_check_security(d))\n\t\t\trfcomm_send_pn(s, 1, d);\n\t\telse\n\t\t\tset_bit(RFCOMM_AUTH_PENDING, &d->flags);\n\t}\n\n\trfcomm_dlc_set_timer(d, RFCOMM_CONN_TIMEOUT);\n\n\treturn 0;\n}\n\nint rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst, u8 channel)\n{\n\tint r;\n\n\trfcomm_lock();\n\n\tr = __rfcomm_dlc_open(d, src, dst, channel);\n\n\trfcomm_unlock();\n\treturn r;\n}\n\nstatic void __rfcomm_dlc_disconn(struct rfcomm_dlc *d)\n{\n\tstruct rfcomm_session *s = d->session;\n\n\td->state = BT_DISCONN;\n\tif (skb_queue_empty(&d->tx_queue)) {\n\t\trfcomm_send_disc(s, d->dlci);\n\t\trfcomm_dlc_set_timer(d, RFCOMM_DISC_TIMEOUT);\n\t} else {\n\t\trfcomm_queue_disc(d);\n\t\trfcomm_dlc_set_timer(d, RFCOMM_DISC_TIMEOUT * 2);\n\t}\n}\n\nstatic int __rfcomm_dlc_close(struct rfcomm_dlc *d, int err)\n{\n\tstruct rfcomm_session *s = d->session;\n\tif (!s)\n\t\treturn 0;\n\n\tBT_DBG(\"dlc %p state %ld dlci %d err %d session %p\",\n\t\t\td, d->state, d->dlci, err, s);\n\n\tswitch (d->state) {\n\tcase BT_CONNECT:\n\tcase BT_CONFIG:\n\tcase BT_OPEN:\n\tcase BT_CONNECT2:\n\t\tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n\t\t\tset_bit(RFCOMM_AUTH_REJECT, &d->flags);\n\t\t\trfcomm_schedule();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tswitch (d->state) {\n\tcase BT_CONNECT:\n\tcase BT_CONNECTED:\n\t\t__rfcomm_dlc_disconn(d);\n\t\tbreak;\n\n\tcase BT_CONFIG:\n\t\tif (s->state != BT_BOUND) {\n\t\t\t__rfcomm_dlc_disconn(d);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tfallthrough;\n\n\tdefault:\n\t\trfcomm_dlc_clear_timer(d);\n\n\t\trfcomm_dlc_lock(d);\n\t\td->state = BT_CLOSED;\n\t\td->state_change(d, err);\n\t\trfcomm_dlc_unlock(d);\n\n\t\tskb_queue_purge(&d->tx_queue);\n\t\trfcomm_dlc_unlink(d);\n\t}\n\n\treturn 0;\n}\n\nint rfcomm_dlc_close(struct rfcomm_dlc *d, int err)\n{\n\tint r = 0;\n\tstruct rfcomm_dlc *d_list;\n\tstruct rfcomm_session *s, *s_list;\n\n\tBT_DBG(\"dlc %p state %ld dlci %d err %d\", d, d->state, d->dlci, err);\n\n\trfcomm_lock();\n\n\ts = d->session;\n\tif (!s)\n\t\tgoto no_session;\n\n\t \n\tlist_for_each_entry(s_list, &session_list, list) {\n\t\tif (s_list == s) {\n\t\t\tlist_for_each_entry(d_list, &s->dlcs, list) {\n\t\t\t\tif (d_list == d) {\n\t\t\t\t\tr = __rfcomm_dlc_close(d, err);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nno_session:\n\trfcomm_unlock();\n\treturn r;\n}\n\nstruct rfcomm_dlc *rfcomm_dlc_exists(bdaddr_t *src, bdaddr_t *dst, u8 channel)\n{\n\tstruct rfcomm_session *s;\n\tstruct rfcomm_dlc *dlc = NULL;\n\tu8 dlci;\n\n\tif (rfcomm_check_channel(channel))\n\t\treturn ERR_PTR(-EINVAL);\n\n\trfcomm_lock();\n\ts = rfcomm_session_get(src, dst);\n\tif (s) {\n\t\tdlci = __dlci(__session_dir(s), channel);\n\t\tdlc = rfcomm_dlc_get(s, dlci);\n\t}\n\trfcomm_unlock();\n\treturn dlc;\n}\n\nstatic int rfcomm_dlc_send_frag(struct rfcomm_dlc *d, struct sk_buff *frag)\n{\n\tint len = frag->len;\n\n\tBT_DBG(\"dlc %p mtu %d len %d\", d, d->mtu, len);\n\n\tif (len > d->mtu)\n\t\treturn -EINVAL;\n\n\trfcomm_make_uih(frag, d->addr);\n\t__skb_queue_tail(&d->tx_queue, frag);\n\n\treturn len;\n}\n\nint rfcomm_dlc_send(struct rfcomm_dlc *d, struct sk_buff *skb)\n{\n\tunsigned long flags;\n\tstruct sk_buff *frag, *next;\n\tint len;\n\n\tif (d->state != BT_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tfrag = skb_shinfo(skb)->frag_list;\n\tskb_shinfo(skb)->frag_list = NULL;\n\n\t \n\tspin_lock_irqsave(&d->tx_queue.lock, flags);\n\n\tlen = rfcomm_dlc_send_frag(d, skb);\n\tif (len < 0 || !frag)\n\t\tgoto unlock;\n\n\tfor (; frag; frag = next) {\n\t\tint ret;\n\n\t\tnext = frag->next;\n\n\t\tret = rfcomm_dlc_send_frag(d, frag);\n\t\tif (ret < 0) {\n\t\t\tdev_kfree_skb_irq(frag);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tlen += ret;\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(&d->tx_queue.lock, flags);\n\n\tif (len > 0 && !test_bit(RFCOMM_TX_THROTTLED, &d->flags))\n\t\trfcomm_schedule();\n\treturn len;\n}\n\nvoid rfcomm_dlc_send_noerror(struct rfcomm_dlc *d, struct sk_buff *skb)\n{\n\tint len = skb->len;\n\n\tBT_DBG(\"dlc %p mtu %d len %d\", d, d->mtu, len);\n\n\trfcomm_make_uih(skb, d->addr);\n\tskb_queue_tail(&d->tx_queue, skb);\n\n\tif (d->state == BT_CONNECTED &&\n\t    !test_bit(RFCOMM_TX_THROTTLED, &d->flags))\n\t\trfcomm_schedule();\n}\n\nvoid __rfcomm_dlc_throttle(struct rfcomm_dlc *d)\n{\n\tBT_DBG(\"dlc %p state %ld\", d, d->state);\n\n\tif (!d->cfc) {\n\t\td->v24_sig |= RFCOMM_V24_FC;\n\t\tset_bit(RFCOMM_MSC_PENDING, &d->flags);\n\t}\n\trfcomm_schedule();\n}\n\nvoid __rfcomm_dlc_unthrottle(struct rfcomm_dlc *d)\n{\n\tBT_DBG(\"dlc %p state %ld\", d, d->state);\n\n\tif (!d->cfc) {\n\t\td->v24_sig &= ~RFCOMM_V24_FC;\n\t\tset_bit(RFCOMM_MSC_PENDING, &d->flags);\n\t}\n\trfcomm_schedule();\n}\n\n \nint rfcomm_dlc_set_modem_status(struct rfcomm_dlc *d, u8 v24_sig)\n{\n\tBT_DBG(\"dlc %p state %ld v24_sig 0x%x\",\n\t\t\td, d->state, v24_sig);\n\n\tif (test_bit(RFCOMM_RX_THROTTLED, &d->flags))\n\t\tv24_sig |= RFCOMM_V24_FC;\n\telse\n\t\tv24_sig &= ~RFCOMM_V24_FC;\n\n\td->v24_sig = v24_sig;\n\n\tif (!test_and_set_bit(RFCOMM_MSC_PENDING, &d->flags))\n\t\trfcomm_schedule();\n\n\treturn 0;\n}\n\nint rfcomm_dlc_get_modem_status(struct rfcomm_dlc *d, u8 *v24_sig)\n{\n\tBT_DBG(\"dlc %p state %ld v24_sig 0x%x\",\n\t\t\td, d->state, d->v24_sig);\n\n\t*v24_sig = d->v24_sig;\n\treturn 0;\n}\n\n \nstatic struct rfcomm_session *rfcomm_session_add(struct socket *sock, int state)\n{\n\tstruct rfcomm_session *s = kzalloc(sizeof(*s), GFP_KERNEL);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tBT_DBG(\"session %p sock %p\", s, sock);\n\n\ttimer_setup(&s->timer, rfcomm_session_timeout, 0);\n\n\tINIT_LIST_HEAD(&s->dlcs);\n\ts->state = state;\n\ts->sock  = sock;\n\n\ts->mtu = RFCOMM_DEFAULT_MTU;\n\ts->cfc = disable_cfc ? RFCOMM_CFC_DISABLED : RFCOMM_CFC_UNKNOWN;\n\n\t \n\tif (state != BT_LISTEN)\n\t\tif (!try_module_get(THIS_MODULE)) {\n\t\t\tkfree(s);\n\t\t\treturn NULL;\n\t\t}\n\n\tlist_add(&s->list, &session_list);\n\n\treturn s;\n}\n\nstatic struct rfcomm_session *rfcomm_session_del(struct rfcomm_session *s)\n{\n\tint state = s->state;\n\n\tBT_DBG(\"session %p state %ld\", s, s->state);\n\n\tlist_del(&s->list);\n\n\trfcomm_session_clear_timer(s);\n\tsock_release(s->sock);\n\tkfree(s);\n\n\tif (state != BT_LISTEN)\n\t\tmodule_put(THIS_MODULE);\n\n\treturn NULL;\n}\n\nstatic struct rfcomm_session *rfcomm_session_get(bdaddr_t *src, bdaddr_t *dst)\n{\n\tstruct rfcomm_session *s, *n;\n\tstruct l2cap_chan *chan;\n\tlist_for_each_entry_safe(s, n, &session_list, list) {\n\t\tchan = l2cap_pi(s->sock->sk)->chan;\n\n\t\tif ((!bacmp(src, BDADDR_ANY) || !bacmp(&chan->src, src)) &&\n\t\t    !bacmp(&chan->dst, dst))\n\t\t\treturn s;\n\t}\n\treturn NULL;\n}\n\nstatic struct rfcomm_session *rfcomm_session_close(struct rfcomm_session *s,\n\t\t\t\t\t\t   int err)\n{\n\tstruct rfcomm_dlc *d, *n;\n\n\ts->state = BT_CLOSED;\n\n\tBT_DBG(\"session %p state %ld err %d\", s, s->state, err);\n\n\t \n\tlist_for_each_entry_safe(d, n, &s->dlcs, list) {\n\t\td->state = BT_CLOSED;\n\t\t__rfcomm_dlc_close(d, err);\n\t}\n\n\trfcomm_session_clear_timer(s);\n\treturn rfcomm_session_del(s);\n}\n\nstatic struct rfcomm_session *rfcomm_session_create(bdaddr_t *src,\n\t\t\t\t\t\t\tbdaddr_t *dst,\n\t\t\t\t\t\t\tu8 sec_level,\n\t\t\t\t\t\t\tint *err)\n{\n\tstruct rfcomm_session *s = NULL;\n\tstruct sockaddr_l2 addr;\n\tstruct socket *sock;\n\tstruct sock *sk;\n\n\tBT_DBG(\"%pMR -> %pMR\", src, dst);\n\n\t*err = rfcomm_l2sock_create(&sock);\n\tif (*err < 0)\n\t\treturn NULL;\n\n\tbacpy(&addr.l2_bdaddr, src);\n\taddr.l2_family = AF_BLUETOOTH;\n\taddr.l2_psm    = 0;\n\taddr.l2_cid    = 0;\n\taddr.l2_bdaddr_type = BDADDR_BREDR;\n\t*err = kernel_bind(sock, (struct sockaddr *) &addr, sizeof(addr));\n\tif (*err < 0)\n\t\tgoto failed;\n\n\t \n\tsk = sock->sk;\n\tlock_sock(sk);\n\t \n\tl2cap_pi(sk)->chan->imtu = 0;\n\tl2cap_pi(sk)->chan->sec_level = sec_level;\n\tif (l2cap_ertm)\n\t\tl2cap_pi(sk)->chan->mode = L2CAP_MODE_ERTM;\n\trelease_sock(sk);\n\n\ts = rfcomm_session_add(sock, BT_BOUND);\n\tif (!s) {\n\t\t*err = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\ts->initiator = 1;\n\n\tbacpy(&addr.l2_bdaddr, dst);\n\taddr.l2_family = AF_BLUETOOTH;\n\taddr.l2_psm    = cpu_to_le16(L2CAP_PSM_RFCOMM);\n\taddr.l2_cid    = 0;\n\taddr.l2_bdaddr_type = BDADDR_BREDR;\n\t*err = kernel_connect(sock, (struct sockaddr *) &addr, sizeof(addr), O_NONBLOCK);\n\tif (*err == 0 || *err == -EINPROGRESS)\n\t\treturn s;\n\n\treturn rfcomm_session_del(s);\n\nfailed:\n\tsock_release(sock);\n\treturn NULL;\n}\n\nvoid rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src, bdaddr_t *dst)\n{\n\tstruct l2cap_chan *chan = l2cap_pi(s->sock->sk)->chan;\n\tif (src)\n\t\tbacpy(src, &chan->src);\n\tif (dst)\n\t\tbacpy(dst, &chan->dst);\n}\n\n \nstatic int rfcomm_send_frame(struct rfcomm_session *s, u8 *data, int len)\n{\n\tstruct kvec iv = { data, len };\n\tstruct msghdr msg;\n\n\tBT_DBG(\"session %p len %d\", s, len);\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\treturn kernel_sendmsg(s->sock, &msg, &iv, 1, len);\n}\n\nstatic int rfcomm_send_cmd(struct rfcomm_session *s, struct rfcomm_cmd *cmd)\n{\n\tBT_DBG(\"%p cmd %u\", s, cmd->ctrl);\n\n\treturn rfcomm_send_frame(s, (void *) cmd, sizeof(*cmd));\n}\n\nstatic int rfcomm_send_sabm(struct rfcomm_session *s, u8 dlci)\n{\n\tstruct rfcomm_cmd cmd;\n\n\tBT_DBG(\"%p dlci %d\", s, dlci);\n\n\tcmd.addr = __addr(s->initiator, dlci);\n\tcmd.ctrl = __ctrl(RFCOMM_SABM, 1);\n\tcmd.len  = __len8(0);\n\tcmd.fcs  = __fcs2((u8 *) &cmd);\n\n\treturn rfcomm_send_cmd(s, &cmd);\n}\n\nstatic int rfcomm_send_ua(struct rfcomm_session *s, u8 dlci)\n{\n\tstruct rfcomm_cmd cmd;\n\n\tBT_DBG(\"%p dlci %d\", s, dlci);\n\n\tcmd.addr = __addr(!s->initiator, dlci);\n\tcmd.ctrl = __ctrl(RFCOMM_UA, 1);\n\tcmd.len  = __len8(0);\n\tcmd.fcs  = __fcs2((u8 *) &cmd);\n\n\treturn rfcomm_send_cmd(s, &cmd);\n}\n\nstatic int rfcomm_send_disc(struct rfcomm_session *s, u8 dlci)\n{\n\tstruct rfcomm_cmd cmd;\n\n\tBT_DBG(\"%p dlci %d\", s, dlci);\n\n\tcmd.addr = __addr(s->initiator, dlci);\n\tcmd.ctrl = __ctrl(RFCOMM_DISC, 1);\n\tcmd.len  = __len8(0);\n\tcmd.fcs  = __fcs2((u8 *) &cmd);\n\n\treturn rfcomm_send_cmd(s, &cmd);\n}\n\nstatic int rfcomm_queue_disc(struct rfcomm_dlc *d)\n{\n\tstruct rfcomm_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"dlc %p dlci %d\", d, d->dlci);\n\n\tskb = alloc_skb(sizeof(*cmd), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = __skb_put(skb, sizeof(*cmd));\n\tcmd->addr = d->addr;\n\tcmd->ctrl = __ctrl(RFCOMM_DISC, 1);\n\tcmd->len  = __len8(0);\n\tcmd->fcs  = __fcs2((u8 *) cmd);\n\n\tskb_queue_tail(&d->tx_queue, skb);\n\trfcomm_schedule();\n\treturn 0;\n}\n\nstatic int rfcomm_send_dm(struct rfcomm_session *s, u8 dlci)\n{\n\tstruct rfcomm_cmd cmd;\n\n\tBT_DBG(\"%p dlci %d\", s, dlci);\n\n\tcmd.addr = __addr(!s->initiator, dlci);\n\tcmd.ctrl = __ctrl(RFCOMM_DM, 1);\n\tcmd.len  = __len8(0);\n\tcmd.fcs  = __fcs2((u8 *) &cmd);\n\n\treturn rfcomm_send_cmd(s, &cmd);\n}\n\nstatic int rfcomm_send_nsc(struct rfcomm_session *s, int cr, u8 type)\n{\n\tstruct rfcomm_hdr *hdr;\n\tstruct rfcomm_mcc *mcc;\n\tu8 buf[16], *ptr = buf;\n\n\tBT_DBG(\"%p cr %d type %d\", s, cr, type);\n\n\thdr = (void *) ptr; ptr += sizeof(*hdr);\n\thdr->addr = __addr(s->initiator, 0);\n\thdr->ctrl = __ctrl(RFCOMM_UIH, 0);\n\thdr->len  = __len8(sizeof(*mcc) + 1);\n\n\tmcc = (void *) ptr; ptr += sizeof(*mcc);\n\tmcc->type = __mcc_type(0, RFCOMM_NSC);\n\tmcc->len  = __len8(1);\n\n\t \n\t*ptr = __mcc_type(cr, type); ptr++;\n\n\t*ptr = __fcs(buf); ptr++;\n\n\treturn rfcomm_send_frame(s, buf, ptr - buf);\n}\n\nstatic int rfcomm_send_pn(struct rfcomm_session *s, int cr, struct rfcomm_dlc *d)\n{\n\tstruct rfcomm_hdr *hdr;\n\tstruct rfcomm_mcc *mcc;\n\tstruct rfcomm_pn  *pn;\n\tu8 buf[16], *ptr = buf;\n\n\tBT_DBG(\"%p cr %d dlci %d mtu %d\", s, cr, d->dlci, d->mtu);\n\n\thdr = (void *) ptr; ptr += sizeof(*hdr);\n\thdr->addr = __addr(s->initiator, 0);\n\thdr->ctrl = __ctrl(RFCOMM_UIH, 0);\n\thdr->len  = __len8(sizeof(*mcc) + sizeof(*pn));\n\n\tmcc = (void *) ptr; ptr += sizeof(*mcc);\n\tmcc->type = __mcc_type(cr, RFCOMM_PN);\n\tmcc->len  = __len8(sizeof(*pn));\n\n\tpn = (void *) ptr; ptr += sizeof(*pn);\n\tpn->dlci        = d->dlci;\n\tpn->priority    = d->priority;\n\tpn->ack_timer   = 0;\n\tpn->max_retrans = 0;\n\n\tif (s->cfc) {\n\t\tpn->flow_ctrl = cr ? 0xf0 : 0xe0;\n\t\tpn->credits = RFCOMM_DEFAULT_CREDITS;\n\t} else {\n\t\tpn->flow_ctrl = 0;\n\t\tpn->credits   = 0;\n\t}\n\n\tif (cr && channel_mtu >= 0)\n\t\tpn->mtu = cpu_to_le16(channel_mtu);\n\telse\n\t\tpn->mtu = cpu_to_le16(d->mtu);\n\n\t*ptr = __fcs(buf); ptr++;\n\n\treturn rfcomm_send_frame(s, buf, ptr - buf);\n}\n\nint rfcomm_send_rpn(struct rfcomm_session *s, int cr, u8 dlci,\n\t\t\tu8 bit_rate, u8 data_bits, u8 stop_bits,\n\t\t\tu8 parity, u8 flow_ctrl_settings,\n\t\t\tu8 xon_char, u8 xoff_char, u16 param_mask)\n{\n\tstruct rfcomm_hdr *hdr;\n\tstruct rfcomm_mcc *mcc;\n\tstruct rfcomm_rpn *rpn;\n\tu8 buf[16], *ptr = buf;\n\n\tBT_DBG(\"%p cr %d dlci %d bit_r 0x%x data_b 0x%x stop_b 0x%x parity 0x%x\"\n\t\t\t\" flwc_s 0x%x xon_c 0x%x xoff_c 0x%x p_mask 0x%x\",\n\t\ts, cr, dlci, bit_rate, data_bits, stop_bits, parity,\n\t\tflow_ctrl_settings, xon_char, xoff_char, param_mask);\n\n\thdr = (void *) ptr; ptr += sizeof(*hdr);\n\thdr->addr = __addr(s->initiator, 0);\n\thdr->ctrl = __ctrl(RFCOMM_UIH, 0);\n\thdr->len  = __len8(sizeof(*mcc) + sizeof(*rpn));\n\n\tmcc = (void *) ptr; ptr += sizeof(*mcc);\n\tmcc->type = __mcc_type(cr, RFCOMM_RPN);\n\tmcc->len  = __len8(sizeof(*rpn));\n\n\trpn = (void *) ptr; ptr += sizeof(*rpn);\n\trpn->dlci          = __addr(1, dlci);\n\trpn->bit_rate      = bit_rate;\n\trpn->line_settings = __rpn_line_settings(data_bits, stop_bits, parity);\n\trpn->flow_ctrl     = flow_ctrl_settings;\n\trpn->xon_char      = xon_char;\n\trpn->xoff_char     = xoff_char;\n\trpn->param_mask    = cpu_to_le16(param_mask);\n\n\t*ptr = __fcs(buf); ptr++;\n\n\treturn rfcomm_send_frame(s, buf, ptr - buf);\n}\n\nstatic int rfcomm_send_rls(struct rfcomm_session *s, int cr, u8 dlci, u8 status)\n{\n\tstruct rfcomm_hdr *hdr;\n\tstruct rfcomm_mcc *mcc;\n\tstruct rfcomm_rls *rls;\n\tu8 buf[16], *ptr = buf;\n\n\tBT_DBG(\"%p cr %d status 0x%x\", s, cr, status);\n\n\thdr = (void *) ptr; ptr += sizeof(*hdr);\n\thdr->addr = __addr(s->initiator, 0);\n\thdr->ctrl = __ctrl(RFCOMM_UIH, 0);\n\thdr->len  = __len8(sizeof(*mcc) + sizeof(*rls));\n\n\tmcc = (void *) ptr; ptr += sizeof(*mcc);\n\tmcc->type = __mcc_type(cr, RFCOMM_RLS);\n\tmcc->len  = __len8(sizeof(*rls));\n\n\trls = (void *) ptr; ptr += sizeof(*rls);\n\trls->dlci   = __addr(1, dlci);\n\trls->status = status;\n\n\t*ptr = __fcs(buf); ptr++;\n\n\treturn rfcomm_send_frame(s, buf, ptr - buf);\n}\n\nstatic int rfcomm_send_msc(struct rfcomm_session *s, int cr, u8 dlci, u8 v24_sig)\n{\n\tstruct rfcomm_hdr *hdr;\n\tstruct rfcomm_mcc *mcc;\n\tstruct rfcomm_msc *msc;\n\tu8 buf[16], *ptr = buf;\n\n\tBT_DBG(\"%p cr %d v24 0x%x\", s, cr, v24_sig);\n\n\thdr = (void *) ptr; ptr += sizeof(*hdr);\n\thdr->addr = __addr(s->initiator, 0);\n\thdr->ctrl = __ctrl(RFCOMM_UIH, 0);\n\thdr->len  = __len8(sizeof(*mcc) + sizeof(*msc));\n\n\tmcc = (void *) ptr; ptr += sizeof(*mcc);\n\tmcc->type = __mcc_type(cr, RFCOMM_MSC);\n\tmcc->len  = __len8(sizeof(*msc));\n\n\tmsc = (void *) ptr; ptr += sizeof(*msc);\n\tmsc->dlci    = __addr(1, dlci);\n\tmsc->v24_sig = v24_sig | 0x01;\n\n\t*ptr = __fcs(buf); ptr++;\n\n\treturn rfcomm_send_frame(s, buf, ptr - buf);\n}\n\nstatic int rfcomm_send_fcoff(struct rfcomm_session *s, int cr)\n{\n\tstruct rfcomm_hdr *hdr;\n\tstruct rfcomm_mcc *mcc;\n\tu8 buf[16], *ptr = buf;\n\n\tBT_DBG(\"%p cr %d\", s, cr);\n\n\thdr = (void *) ptr; ptr += sizeof(*hdr);\n\thdr->addr = __addr(s->initiator, 0);\n\thdr->ctrl = __ctrl(RFCOMM_UIH, 0);\n\thdr->len  = __len8(sizeof(*mcc));\n\n\tmcc = (void *) ptr; ptr += sizeof(*mcc);\n\tmcc->type = __mcc_type(cr, RFCOMM_FCOFF);\n\tmcc->len  = __len8(0);\n\n\t*ptr = __fcs(buf); ptr++;\n\n\treturn rfcomm_send_frame(s, buf, ptr - buf);\n}\n\nstatic int rfcomm_send_fcon(struct rfcomm_session *s, int cr)\n{\n\tstruct rfcomm_hdr *hdr;\n\tstruct rfcomm_mcc *mcc;\n\tu8 buf[16], *ptr = buf;\n\n\tBT_DBG(\"%p cr %d\", s, cr);\n\n\thdr = (void *) ptr; ptr += sizeof(*hdr);\n\thdr->addr = __addr(s->initiator, 0);\n\thdr->ctrl = __ctrl(RFCOMM_UIH, 0);\n\thdr->len  = __len8(sizeof(*mcc));\n\n\tmcc = (void *) ptr; ptr += sizeof(*mcc);\n\tmcc->type = __mcc_type(cr, RFCOMM_FCON);\n\tmcc->len  = __len8(0);\n\n\t*ptr = __fcs(buf); ptr++;\n\n\treturn rfcomm_send_frame(s, buf, ptr - buf);\n}\n\nstatic int rfcomm_send_test(struct rfcomm_session *s, int cr, u8 *pattern, int len)\n{\n\tstruct socket *sock = s->sock;\n\tstruct kvec iv[3];\n\tstruct msghdr msg;\n\tunsigned char hdr[5], crc[1];\n\n\tif (len > 125)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"%p cr %d\", s, cr);\n\n\thdr[0] = __addr(s->initiator, 0);\n\thdr[1] = __ctrl(RFCOMM_UIH, 0);\n\thdr[2] = 0x01 | ((len + 2) << 1);\n\thdr[3] = 0x01 | ((cr & 0x01) << 1) | (RFCOMM_TEST << 2);\n\thdr[4] = 0x01 | (len << 1);\n\n\tcrc[0] = __fcs(hdr);\n\n\tiv[0].iov_base = hdr;\n\tiv[0].iov_len  = 5;\n\tiv[1].iov_base = pattern;\n\tiv[1].iov_len  = len;\n\tiv[2].iov_base = crc;\n\tiv[2].iov_len  = 1;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\treturn kernel_sendmsg(sock, &msg, iv, 3, 6 + len);\n}\n\nstatic int rfcomm_send_credits(struct rfcomm_session *s, u8 addr, u8 credits)\n{\n\tstruct rfcomm_hdr *hdr;\n\tu8 buf[16], *ptr = buf;\n\n\tBT_DBG(\"%p addr %d credits %d\", s, addr, credits);\n\n\thdr = (void *) ptr; ptr += sizeof(*hdr);\n\thdr->addr = addr;\n\thdr->ctrl = __ctrl(RFCOMM_UIH, 1);\n\thdr->len  = __len8(0);\n\n\t*ptr = credits; ptr++;\n\n\t*ptr = __fcs(buf); ptr++;\n\n\treturn rfcomm_send_frame(s, buf, ptr - buf);\n}\n\nstatic void rfcomm_make_uih(struct sk_buff *skb, u8 addr)\n{\n\tstruct rfcomm_hdr *hdr;\n\tint len = skb->len;\n\tu8 *crc;\n\n\tif (len > 127) {\n\t\thdr = skb_push(skb, 4);\n\t\tput_unaligned(cpu_to_le16(__len16(len)), (__le16 *) &hdr->len);\n\t} else {\n\t\thdr = skb_push(skb, 3);\n\t\thdr->len = __len8(len);\n\t}\n\thdr->addr = addr;\n\thdr->ctrl = __ctrl(RFCOMM_UIH, 0);\n\n\tcrc = skb_put(skb, 1);\n\t*crc = __fcs((void *) hdr);\n}\n\n \nstatic struct rfcomm_session *rfcomm_recv_ua(struct rfcomm_session *s, u8 dlci)\n{\n\tBT_DBG(\"session %p state %ld dlci %d\", s, s->state, dlci);\n\n\tif (dlci) {\n\t\t \n\t\tstruct rfcomm_dlc *d = rfcomm_dlc_get(s, dlci);\n\t\tif (!d) {\n\t\t\trfcomm_send_dm(s, dlci);\n\t\t\treturn s;\n\t\t}\n\n\t\tswitch (d->state) {\n\t\tcase BT_CONNECT:\n\t\t\trfcomm_dlc_clear_timer(d);\n\n\t\t\trfcomm_dlc_lock(d);\n\t\t\td->state = BT_CONNECTED;\n\t\t\td->state_change(d, 0);\n\t\t\trfcomm_dlc_unlock(d);\n\n\t\t\trfcomm_send_msc(s, 1, dlci, d->v24_sig);\n\t\t\tbreak;\n\n\t\tcase BT_DISCONN:\n\t\t\td->state = BT_CLOSED;\n\t\t\t__rfcomm_dlc_close(d, 0);\n\n\t\t\tif (list_empty(&s->dlcs)) {\n\t\t\t\ts->state = BT_DISCONN;\n\t\t\t\trfcomm_send_disc(s, 0);\n\t\t\t\trfcomm_session_clear_timer(s);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tswitch (s->state) {\n\t\tcase BT_CONNECT:\n\t\t\ts->state = BT_CONNECTED;\n\t\t\trfcomm_process_connect(s);\n\t\t\tbreak;\n\n\t\tcase BT_DISCONN:\n\t\t\ts = rfcomm_session_close(s, ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn s;\n}\n\nstatic struct rfcomm_session *rfcomm_recv_dm(struct rfcomm_session *s, u8 dlci)\n{\n\tint err = 0;\n\n\tBT_DBG(\"session %p state %ld dlci %d\", s, s->state, dlci);\n\n\tif (dlci) {\n\t\t \n\t\tstruct rfcomm_dlc *d = rfcomm_dlc_get(s, dlci);\n\t\tif (d) {\n\t\t\tif (d->state == BT_CONNECT || d->state == BT_CONFIG)\n\t\t\t\terr = ECONNREFUSED;\n\t\t\telse\n\t\t\t\terr = ECONNRESET;\n\n\t\t\td->state = BT_CLOSED;\n\t\t\t__rfcomm_dlc_close(d, err);\n\t\t}\n\t} else {\n\t\tif (s->state == BT_CONNECT)\n\t\t\terr = ECONNREFUSED;\n\t\telse\n\t\t\terr = ECONNRESET;\n\n\t\ts = rfcomm_session_close(s, err);\n\t}\n\treturn s;\n}\n\nstatic struct rfcomm_session *rfcomm_recv_disc(struct rfcomm_session *s,\n\t\t\t\t\t       u8 dlci)\n{\n\tint err = 0;\n\n\tBT_DBG(\"session %p state %ld dlci %d\", s, s->state, dlci);\n\n\tif (dlci) {\n\t\tstruct rfcomm_dlc *d = rfcomm_dlc_get(s, dlci);\n\t\tif (d) {\n\t\t\trfcomm_send_ua(s, dlci);\n\n\t\t\tif (d->state == BT_CONNECT || d->state == BT_CONFIG)\n\t\t\t\terr = ECONNREFUSED;\n\t\t\telse\n\t\t\t\terr = ECONNRESET;\n\n\t\t\td->state = BT_CLOSED;\n\t\t\t__rfcomm_dlc_close(d, err);\n\t\t} else\n\t\t\trfcomm_send_dm(s, dlci);\n\n\t} else {\n\t\trfcomm_send_ua(s, 0);\n\n\t\tif (s->state == BT_CONNECT)\n\t\t\terr = ECONNREFUSED;\n\t\telse\n\t\t\terr = ECONNRESET;\n\n\t\ts = rfcomm_session_close(s, err);\n\t}\n\treturn s;\n}\n\nvoid rfcomm_dlc_accept(struct rfcomm_dlc *d)\n{\n\tstruct sock *sk = d->session->sock->sk;\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;\n\n\tBT_DBG(\"dlc %p\", d);\n\n\trfcomm_send_ua(d->session, d->dlci);\n\n\trfcomm_dlc_clear_timer(d);\n\n\trfcomm_dlc_lock(d);\n\td->state = BT_CONNECTED;\n\td->state_change(d, 0);\n\trfcomm_dlc_unlock(d);\n\n\tif (d->role_switch)\n\t\thci_conn_switch_role(conn->hcon, 0x00);\n\n\trfcomm_send_msc(d->session, 1, d->dlci, d->v24_sig);\n}\n\nstatic void rfcomm_check_accept(struct rfcomm_dlc *d)\n{\n\tif (rfcomm_check_security(d)) {\n\t\tif (d->defer_setup) {\n\t\t\tset_bit(RFCOMM_DEFER_SETUP, &d->flags);\n\t\t\trfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);\n\n\t\t\trfcomm_dlc_lock(d);\n\t\t\td->state = BT_CONNECT2;\n\t\t\td->state_change(d, 0);\n\t\t\trfcomm_dlc_unlock(d);\n\t\t} else\n\t\t\trfcomm_dlc_accept(d);\n\t} else {\n\t\tset_bit(RFCOMM_AUTH_PENDING, &d->flags);\n\t\trfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);\n\t}\n}\n\nstatic int rfcomm_recv_sabm(struct rfcomm_session *s, u8 dlci)\n{\n\tstruct rfcomm_dlc *d;\n\tu8 channel;\n\n\tBT_DBG(\"session %p state %ld dlci %d\", s, s->state, dlci);\n\n\tif (!dlci) {\n\t\trfcomm_send_ua(s, 0);\n\n\t\tif (s->state == BT_OPEN) {\n\t\t\ts->state = BT_CONNECTED;\n\t\t\trfcomm_process_connect(s);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\td = rfcomm_dlc_get(s, dlci);\n\tif (d) {\n\t\tif (d->state == BT_OPEN) {\n\t\t\t \n\t\t\trfcomm_check_accept(d);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tchannel = __srv_channel(dlci);\n\tif (rfcomm_connect_ind(s, channel, &d)) {\n\t\td->dlci = dlci;\n\t\td->addr = __addr(s->initiator, dlci);\n\t\trfcomm_dlc_link(s, d);\n\n\t\trfcomm_check_accept(d);\n\t} else {\n\t\trfcomm_send_dm(s, dlci);\n\t}\n\n\treturn 0;\n}\n\nstatic int rfcomm_apply_pn(struct rfcomm_dlc *d, int cr, struct rfcomm_pn *pn)\n{\n\tstruct rfcomm_session *s = d->session;\n\n\tBT_DBG(\"dlc %p state %ld dlci %d mtu %d fc 0x%x credits %d\",\n\t\t\td, d->state, d->dlci, pn->mtu, pn->flow_ctrl, pn->credits);\n\n\tif ((pn->flow_ctrl == 0xf0 && s->cfc != RFCOMM_CFC_DISABLED) ||\n\t\t\t\t\t\tpn->flow_ctrl == 0xe0) {\n\t\td->cfc = RFCOMM_CFC_ENABLED;\n\t\td->tx_credits = pn->credits;\n\t} else {\n\t\td->cfc = RFCOMM_CFC_DISABLED;\n\t\tset_bit(RFCOMM_TX_THROTTLED, &d->flags);\n\t}\n\n\tif (s->cfc == RFCOMM_CFC_UNKNOWN)\n\t\ts->cfc = d->cfc;\n\n\td->priority = pn->priority;\n\n\td->mtu = __le16_to_cpu(pn->mtu);\n\n\tif (cr && d->mtu > s->mtu)\n\t\td->mtu = s->mtu;\n\n\treturn 0;\n}\n\nstatic int rfcomm_recv_pn(struct rfcomm_session *s, int cr, struct sk_buff *skb)\n{\n\tstruct rfcomm_pn *pn = (void *) skb->data;\n\tstruct rfcomm_dlc *d;\n\tu8 dlci = pn->dlci;\n\n\tBT_DBG(\"session %p state %ld dlci %d\", s, s->state, dlci);\n\n\tif (!dlci)\n\t\treturn 0;\n\n\td = rfcomm_dlc_get(s, dlci);\n\tif (d) {\n\t\tif (cr) {\n\t\t\t \n\t\t\trfcomm_apply_pn(d, cr, pn);\n\t\t\trfcomm_send_pn(s, 0, d);\n\t\t} else {\n\t\t\t \n\t\t\tswitch (d->state) {\n\t\t\tcase BT_CONFIG:\n\t\t\t\trfcomm_apply_pn(d, cr, pn);\n\n\t\t\t\td->state = BT_CONNECT;\n\t\t\t\trfcomm_send_sabm(s, d->dlci);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tu8 channel = __srv_channel(dlci);\n\n\t\tif (!cr)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (rfcomm_connect_ind(s, channel, &d)) {\n\t\t\td->dlci = dlci;\n\t\t\td->addr = __addr(s->initiator, dlci);\n\t\t\trfcomm_dlc_link(s, d);\n\n\t\t\trfcomm_apply_pn(d, cr, pn);\n\n\t\t\td->state = BT_OPEN;\n\t\t\trfcomm_send_pn(s, 0, d);\n\t\t} else {\n\t\t\trfcomm_send_dm(s, dlci);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int rfcomm_recv_rpn(struct rfcomm_session *s, int cr, int len, struct sk_buff *skb)\n{\n\tstruct rfcomm_rpn *rpn = (void *) skb->data;\n\tu8 dlci = __get_dlci(rpn->dlci);\n\n\tu8 bit_rate  = 0;\n\tu8 data_bits = 0;\n\tu8 stop_bits = 0;\n\tu8 parity    = 0;\n\tu8 flow_ctrl = 0;\n\tu8 xon_char  = 0;\n\tu8 xoff_char = 0;\n\tu16 rpn_mask = RFCOMM_RPN_PM_ALL;\n\n\tBT_DBG(\"dlci %d cr %d len 0x%x bitr 0x%x line 0x%x flow 0x%x xonc 0x%x xoffc 0x%x pm 0x%x\",\n\t\tdlci, cr, len, rpn->bit_rate, rpn->line_settings, rpn->flow_ctrl,\n\t\trpn->xon_char, rpn->xoff_char, rpn->param_mask);\n\n\tif (!cr)\n\t\treturn 0;\n\n\tif (len == 1) {\n\t\t \n\t\tbit_rate  = RFCOMM_RPN_BR_9600;\n\t\tdata_bits = RFCOMM_RPN_DATA_8;\n\t\tstop_bits = RFCOMM_RPN_STOP_1;\n\t\tparity    = RFCOMM_RPN_PARITY_NONE;\n\t\tflow_ctrl = RFCOMM_RPN_FLOW_NONE;\n\t\txon_char  = RFCOMM_RPN_XON_CHAR;\n\t\txoff_char = RFCOMM_RPN_XOFF_CHAR;\n\t\tgoto rpn_out;\n\t}\n\n\t \n\n\tif (rpn->param_mask & cpu_to_le16(RFCOMM_RPN_PM_BITRATE)) {\n\t\tbit_rate = rpn->bit_rate;\n\t\tif (bit_rate > RFCOMM_RPN_BR_230400) {\n\t\t\tBT_DBG(\"RPN bit rate mismatch 0x%x\", bit_rate);\n\t\t\tbit_rate = RFCOMM_RPN_BR_9600;\n\t\t\trpn_mask ^= RFCOMM_RPN_PM_BITRATE;\n\t\t}\n\t}\n\n\tif (rpn->param_mask & cpu_to_le16(RFCOMM_RPN_PM_DATA)) {\n\t\tdata_bits = __get_rpn_data_bits(rpn->line_settings);\n\t\tif (data_bits != RFCOMM_RPN_DATA_8) {\n\t\t\tBT_DBG(\"RPN data bits mismatch 0x%x\", data_bits);\n\t\t\tdata_bits = RFCOMM_RPN_DATA_8;\n\t\t\trpn_mask ^= RFCOMM_RPN_PM_DATA;\n\t\t}\n\t}\n\n\tif (rpn->param_mask & cpu_to_le16(RFCOMM_RPN_PM_STOP)) {\n\t\tstop_bits = __get_rpn_stop_bits(rpn->line_settings);\n\t\tif (stop_bits != RFCOMM_RPN_STOP_1) {\n\t\t\tBT_DBG(\"RPN stop bits mismatch 0x%x\", stop_bits);\n\t\t\tstop_bits = RFCOMM_RPN_STOP_1;\n\t\t\trpn_mask ^= RFCOMM_RPN_PM_STOP;\n\t\t}\n\t}\n\n\tif (rpn->param_mask & cpu_to_le16(RFCOMM_RPN_PM_PARITY)) {\n\t\tparity = __get_rpn_parity(rpn->line_settings);\n\t\tif (parity != RFCOMM_RPN_PARITY_NONE) {\n\t\t\tBT_DBG(\"RPN parity mismatch 0x%x\", parity);\n\t\t\tparity = RFCOMM_RPN_PARITY_NONE;\n\t\t\trpn_mask ^= RFCOMM_RPN_PM_PARITY;\n\t\t}\n\t}\n\n\tif (rpn->param_mask & cpu_to_le16(RFCOMM_RPN_PM_FLOW)) {\n\t\tflow_ctrl = rpn->flow_ctrl;\n\t\tif (flow_ctrl != RFCOMM_RPN_FLOW_NONE) {\n\t\t\tBT_DBG(\"RPN flow ctrl mismatch 0x%x\", flow_ctrl);\n\t\t\tflow_ctrl = RFCOMM_RPN_FLOW_NONE;\n\t\t\trpn_mask ^= RFCOMM_RPN_PM_FLOW;\n\t\t}\n\t}\n\n\tif (rpn->param_mask & cpu_to_le16(RFCOMM_RPN_PM_XON)) {\n\t\txon_char = rpn->xon_char;\n\t\tif (xon_char != RFCOMM_RPN_XON_CHAR) {\n\t\t\tBT_DBG(\"RPN XON char mismatch 0x%x\", xon_char);\n\t\t\txon_char = RFCOMM_RPN_XON_CHAR;\n\t\t\trpn_mask ^= RFCOMM_RPN_PM_XON;\n\t\t}\n\t}\n\n\tif (rpn->param_mask & cpu_to_le16(RFCOMM_RPN_PM_XOFF)) {\n\t\txoff_char = rpn->xoff_char;\n\t\tif (xoff_char != RFCOMM_RPN_XOFF_CHAR) {\n\t\t\tBT_DBG(\"RPN XOFF char mismatch 0x%x\", xoff_char);\n\t\t\txoff_char = RFCOMM_RPN_XOFF_CHAR;\n\t\t\trpn_mask ^= RFCOMM_RPN_PM_XOFF;\n\t\t}\n\t}\n\nrpn_out:\n\trfcomm_send_rpn(s, 0, dlci, bit_rate, data_bits, stop_bits,\n\t\t\tparity, flow_ctrl, xon_char, xoff_char, rpn_mask);\n\n\treturn 0;\n}\n\nstatic int rfcomm_recv_rls(struct rfcomm_session *s, int cr, struct sk_buff *skb)\n{\n\tstruct rfcomm_rls *rls = (void *) skb->data;\n\tu8 dlci = __get_dlci(rls->dlci);\n\n\tBT_DBG(\"dlci %d cr %d status 0x%x\", dlci, cr, rls->status);\n\n\tif (!cr)\n\t\treturn 0;\n\n\t \n\n\trfcomm_send_rls(s, 0, dlci, rls->status);\n\n\treturn 0;\n}\n\nstatic int rfcomm_recv_msc(struct rfcomm_session *s, int cr, struct sk_buff *skb)\n{\n\tstruct rfcomm_msc *msc = (void *) skb->data;\n\tstruct rfcomm_dlc *d;\n\tu8 dlci = __get_dlci(msc->dlci);\n\n\tBT_DBG(\"dlci %d cr %d v24 0x%x\", dlci, cr, msc->v24_sig);\n\n\td = rfcomm_dlc_get(s, dlci);\n\tif (!d)\n\t\treturn 0;\n\n\tif (cr) {\n\t\tif (msc->v24_sig & RFCOMM_V24_FC && !d->cfc)\n\t\t\tset_bit(RFCOMM_TX_THROTTLED, &d->flags);\n\t\telse\n\t\t\tclear_bit(RFCOMM_TX_THROTTLED, &d->flags);\n\n\t\trfcomm_dlc_lock(d);\n\n\t\td->remote_v24_sig = msc->v24_sig;\n\n\t\tif (d->modem_status)\n\t\t\td->modem_status(d, msc->v24_sig);\n\n\t\trfcomm_dlc_unlock(d);\n\n\t\trfcomm_send_msc(s, 0, dlci, msc->v24_sig);\n\n\t\td->mscex |= RFCOMM_MSCEX_RX;\n\t} else\n\t\td->mscex |= RFCOMM_MSCEX_TX;\n\n\treturn 0;\n}\n\nstatic int rfcomm_recv_mcc(struct rfcomm_session *s, struct sk_buff *skb)\n{\n\tstruct rfcomm_mcc *mcc = (void *) skb->data;\n\tu8 type, cr, len;\n\n\tcr   = __test_cr(mcc->type);\n\ttype = __get_mcc_type(mcc->type);\n\tlen  = __get_mcc_len(mcc->len);\n\n\tBT_DBG(\"%p type 0x%x cr %d\", s, type, cr);\n\n\tskb_pull(skb, 2);\n\n\tswitch (type) {\n\tcase RFCOMM_PN:\n\t\trfcomm_recv_pn(s, cr, skb);\n\t\tbreak;\n\n\tcase RFCOMM_RPN:\n\t\trfcomm_recv_rpn(s, cr, len, skb);\n\t\tbreak;\n\n\tcase RFCOMM_RLS:\n\t\trfcomm_recv_rls(s, cr, skb);\n\t\tbreak;\n\n\tcase RFCOMM_MSC:\n\t\trfcomm_recv_msc(s, cr, skb);\n\t\tbreak;\n\n\tcase RFCOMM_FCOFF:\n\t\tif (cr) {\n\t\t\tset_bit(RFCOMM_TX_THROTTLED, &s->flags);\n\t\t\trfcomm_send_fcoff(s, 0);\n\t\t}\n\t\tbreak;\n\n\tcase RFCOMM_FCON:\n\t\tif (cr) {\n\t\t\tclear_bit(RFCOMM_TX_THROTTLED, &s->flags);\n\t\t\trfcomm_send_fcon(s, 0);\n\t\t}\n\t\tbreak;\n\n\tcase RFCOMM_TEST:\n\t\tif (cr)\n\t\t\trfcomm_send_test(s, 0, skb->data, skb->len);\n\t\tbreak;\n\n\tcase RFCOMM_NSC:\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown control type 0x%02x\", type);\n\t\trfcomm_send_nsc(s, cr, type);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rfcomm_recv_data(struct rfcomm_session *s, u8 dlci, int pf, struct sk_buff *skb)\n{\n\tstruct rfcomm_dlc *d;\n\n\tBT_DBG(\"session %p state %ld dlci %d pf %d\", s, s->state, dlci, pf);\n\n\td = rfcomm_dlc_get(s, dlci);\n\tif (!d) {\n\t\trfcomm_send_dm(s, dlci);\n\t\tgoto drop;\n\t}\n\n\tif (pf && d->cfc) {\n\t\tu8 credits = *(u8 *) skb->data; skb_pull(skb, 1);\n\n\t\td->tx_credits += credits;\n\t\tif (d->tx_credits)\n\t\t\tclear_bit(RFCOMM_TX_THROTTLED, &d->flags);\n\t}\n\n\tif (skb->len && d->state == BT_CONNECTED) {\n\t\trfcomm_dlc_lock(d);\n\t\td->rx_credits--;\n\t\td->data_ready(d, skb);\n\t\trfcomm_dlc_unlock(d);\n\t\treturn 0;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic struct rfcomm_session *rfcomm_recv_frame(struct rfcomm_session *s,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct rfcomm_hdr *hdr = (void *) skb->data;\n\tu8 type, dlci, fcs;\n\n\tif (!s) {\n\t\t \n\t\tkfree_skb(skb);\n\t\treturn s;\n\t}\n\n\tdlci = __get_dlci(hdr->addr);\n\ttype = __get_type(hdr->ctrl);\n\n\t \n\tskb->len--; skb->tail--;\n\tfcs = *(u8 *)skb_tail_pointer(skb);\n\n\tif (__check_fcs(skb->data, type, fcs)) {\n\t\tBT_ERR(\"bad checksum in packet\");\n\t\tkfree_skb(skb);\n\t\treturn s;\n\t}\n\n\tif (__test_ea(hdr->len))\n\t\tskb_pull(skb, 3);\n\telse\n\t\tskb_pull(skb, 4);\n\n\tswitch (type) {\n\tcase RFCOMM_SABM:\n\t\tif (__test_pf(hdr->ctrl))\n\t\t\trfcomm_recv_sabm(s, dlci);\n\t\tbreak;\n\n\tcase RFCOMM_DISC:\n\t\tif (__test_pf(hdr->ctrl))\n\t\t\ts = rfcomm_recv_disc(s, dlci);\n\t\tbreak;\n\n\tcase RFCOMM_UA:\n\t\tif (__test_pf(hdr->ctrl))\n\t\t\ts = rfcomm_recv_ua(s, dlci);\n\t\tbreak;\n\n\tcase RFCOMM_DM:\n\t\ts = rfcomm_recv_dm(s, dlci);\n\t\tbreak;\n\n\tcase RFCOMM_UIH:\n\t\tif (dlci) {\n\t\t\trfcomm_recv_data(s, dlci, __test_pf(hdr->ctrl), skb);\n\t\t\treturn s;\n\t\t}\n\t\trfcomm_recv_mcc(s, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown packet type 0x%02x\", type);\n\t\tbreak;\n\t}\n\tkfree_skb(skb);\n\treturn s;\n}\n\n \n\nstatic void rfcomm_process_connect(struct rfcomm_session *s)\n{\n\tstruct rfcomm_dlc *d, *n;\n\n\tBT_DBG(\"session %p state %ld\", s, s->state);\n\n\tlist_for_each_entry_safe(d, n, &s->dlcs, list) {\n\t\tif (d->state == BT_CONFIG) {\n\t\t\td->mtu = s->mtu;\n\t\t\tif (rfcomm_check_security(d)) {\n\t\t\t\trfcomm_send_pn(s, 1, d);\n\t\t\t} else {\n\t\t\t\tset_bit(RFCOMM_AUTH_PENDING, &d->flags);\n\t\t\t\trfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int rfcomm_process_tx(struct rfcomm_dlc *d)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tBT_DBG(\"dlc %p state %ld cfc %d rx_credits %d tx_credits %d\",\n\t\t\td, d->state, d->cfc, d->rx_credits, d->tx_credits);\n\n\t \n\tif (test_and_clear_bit(RFCOMM_MSC_PENDING, &d->flags))\n\t\trfcomm_send_msc(d->session, 1, d->dlci, d->v24_sig);\n\n\tif (d->cfc) {\n\t\t \n\t\tif (!test_bit(RFCOMM_RX_THROTTLED, &d->flags) &&\n\t\t\t\td->rx_credits <= (d->cfc >> 2)) {\n\t\t\trfcomm_send_credits(d->session, d->addr, d->cfc - d->rx_credits);\n\t\t\td->rx_credits = d->cfc;\n\t\t}\n\t} else {\n\t\t \n\t\td->tx_credits = 5;\n\t}\n\n\tif (test_bit(RFCOMM_TX_THROTTLED, &d->flags))\n\t\treturn skb_queue_len(&d->tx_queue);\n\n\twhile (d->tx_credits && (skb = skb_dequeue(&d->tx_queue))) {\n\t\terr = rfcomm_send_frame(d->session, skb->data, skb->len);\n\t\tif (err < 0) {\n\t\t\tskb_queue_head(&d->tx_queue, skb);\n\t\t\tbreak;\n\t\t}\n\t\tkfree_skb(skb);\n\t\td->tx_credits--;\n\t}\n\n\tif (d->cfc && !d->tx_credits) {\n\t\t \n\t\tset_bit(RFCOMM_TX_THROTTLED, &d->flags);\n\t}\n\n\treturn skb_queue_len(&d->tx_queue);\n}\n\nstatic void rfcomm_process_dlcs(struct rfcomm_session *s)\n{\n\tstruct rfcomm_dlc *d, *n;\n\n\tBT_DBG(\"session %p state %ld\", s, s->state);\n\n\tlist_for_each_entry_safe(d, n, &s->dlcs, list) {\n\t\tif (test_bit(RFCOMM_TIMED_OUT, &d->flags)) {\n\t\t\t__rfcomm_dlc_close(d, ETIMEDOUT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(RFCOMM_ENC_DROP, &d->flags)) {\n\t\t\t__rfcomm_dlc_close(d, ECONNREFUSED);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(RFCOMM_AUTH_ACCEPT, &d->flags)) {\n\t\t\trfcomm_dlc_clear_timer(d);\n\t\t\tif (d->out) {\n\t\t\t\trfcomm_send_pn(s, 1, d);\n\t\t\t\trfcomm_dlc_set_timer(d, RFCOMM_CONN_TIMEOUT);\n\t\t\t} else {\n\t\t\t\tif (d->defer_setup) {\n\t\t\t\t\tset_bit(RFCOMM_DEFER_SETUP, &d->flags);\n\t\t\t\t\trfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);\n\n\t\t\t\t\trfcomm_dlc_lock(d);\n\t\t\t\t\td->state = BT_CONNECT2;\n\t\t\t\t\td->state_change(d, 0);\n\t\t\t\t\trfcomm_dlc_unlock(d);\n\t\t\t\t} else\n\t\t\t\t\trfcomm_dlc_accept(d);\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (test_and_clear_bit(RFCOMM_AUTH_REJECT, &d->flags)) {\n\t\t\trfcomm_dlc_clear_timer(d);\n\t\t\tif (!d->out)\n\t\t\t\trfcomm_send_dm(s, d->dlci);\n\t\t\telse\n\t\t\t\td->state = BT_CLOSED;\n\t\t\t__rfcomm_dlc_close(d, ECONNREFUSED);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(RFCOMM_SEC_PENDING, &d->flags))\n\t\t\tcontinue;\n\n\t\tif (test_bit(RFCOMM_TX_THROTTLED, &s->flags))\n\t\t\tcontinue;\n\n\t\tif ((d->state == BT_CONNECTED || d->state == BT_DISCONN) &&\n\t\t\t\t\t\td->mscex == RFCOMM_MSCEX_OK)\n\t\t\trfcomm_process_tx(d);\n\t}\n}\n\nstatic struct rfcomm_session *rfcomm_process_rx(struct rfcomm_session *s)\n{\n\tstruct socket *sock = s->sock;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"session %p state %ld qlen %d\", s, s->state, skb_queue_len(&sk->sk_receive_queue));\n\n\t \n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue))) {\n\t\tskb_orphan(skb);\n\t\tif (!skb_linearize(skb)) {\n\t\t\ts = rfcomm_recv_frame(s, skb);\n\t\t\tif (!s)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\tif (s && (sk->sk_state == BT_CLOSED))\n\t\ts = rfcomm_session_close(s, sk->sk_err);\n\n\treturn s;\n}\n\nstatic void rfcomm_accept_connection(struct rfcomm_session *s)\n{\n\tstruct socket *sock = s->sock, *nsock;\n\tint err;\n\n\t \n\tif (list_empty(&bt_sk(sock->sk)->accept_q))\n\t\treturn;\n\n\tBT_DBG(\"session %p\", s);\n\n\terr = kernel_accept(sock, &nsock, O_NONBLOCK);\n\tif (err < 0)\n\t\treturn;\n\n\t \n\tnsock->sk->sk_data_ready   = rfcomm_l2data_ready;\n\tnsock->sk->sk_state_change = rfcomm_l2state_change;\n\n\ts = rfcomm_session_add(nsock, BT_OPEN);\n\tif (s) {\n\t\t \n\t\ts->mtu = min(l2cap_pi(nsock->sk)->chan->omtu,\n\t\t\t\tl2cap_pi(nsock->sk)->chan->imtu) - 5;\n\n\t\trfcomm_schedule();\n\t} else\n\t\tsock_release(nsock);\n}\n\nstatic struct rfcomm_session *rfcomm_check_connection(struct rfcomm_session *s)\n{\n\tstruct sock *sk = s->sock->sk;\n\n\tBT_DBG(\"%p state %ld\", s, s->state);\n\n\tswitch (sk->sk_state) {\n\tcase BT_CONNECTED:\n\t\ts->state = BT_CONNECT;\n\n\t\t \n\t\ts->mtu = min(l2cap_pi(sk)->chan->omtu, l2cap_pi(sk)->chan->imtu) - 5;\n\n\t\trfcomm_send_sabm(s, 0);\n\t\tbreak;\n\n\tcase BT_CLOSED:\n\t\ts = rfcomm_session_close(s, sk->sk_err);\n\t\tbreak;\n\t}\n\treturn s;\n}\n\nstatic void rfcomm_process_sessions(void)\n{\n\tstruct rfcomm_session *s, *n;\n\n\trfcomm_lock();\n\n\tlist_for_each_entry_safe(s, n, &session_list, list) {\n\t\tif (test_and_clear_bit(RFCOMM_TIMED_OUT, &s->flags)) {\n\t\t\ts->state = BT_DISCONN;\n\t\t\trfcomm_send_disc(s, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (s->state) {\n\t\tcase BT_LISTEN:\n\t\t\trfcomm_accept_connection(s);\n\t\t\tcontinue;\n\n\t\tcase BT_BOUND:\n\t\t\ts = rfcomm_check_connection(s);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ts = rfcomm_process_rx(s);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (s)\n\t\t\trfcomm_process_dlcs(s);\n\t}\n\n\trfcomm_unlock();\n}\n\nstatic int rfcomm_add_listener(bdaddr_t *ba)\n{\n\tstruct sockaddr_l2 addr;\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tstruct rfcomm_session *s;\n\tint    err = 0;\n\n\t \n\terr = rfcomm_l2sock_create(&sock);\n\tif (err < 0) {\n\t\tBT_ERR(\"Create socket failed %d\", err);\n\t\treturn err;\n\t}\n\n\t \n\tbacpy(&addr.l2_bdaddr, ba);\n\taddr.l2_family = AF_BLUETOOTH;\n\taddr.l2_psm    = cpu_to_le16(L2CAP_PSM_RFCOMM);\n\taddr.l2_cid    = 0;\n\taddr.l2_bdaddr_type = BDADDR_BREDR;\n\terr = kernel_bind(sock, (struct sockaddr *) &addr, sizeof(addr));\n\tif (err < 0) {\n\t\tBT_ERR(\"Bind failed %d\", err);\n\t\tgoto failed;\n\t}\n\n\t \n\tsk = sock->sk;\n\tlock_sock(sk);\n\t \n\tl2cap_pi(sk)->chan->imtu = 0;\n\trelease_sock(sk);\n\n\t \n\terr = kernel_listen(sock, 10);\n\tif (err) {\n\t\tBT_ERR(\"Listen failed %d\", err);\n\t\tgoto failed;\n\t}\n\n\t \n\ts = rfcomm_session_add(sock, BT_LISTEN);\n\tif (!s) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\treturn 0;\nfailed:\n\tsock_release(sock);\n\treturn err;\n}\n\nstatic void rfcomm_kill_listener(void)\n{\n\tstruct rfcomm_session *s, *n;\n\n\tBT_DBG(\"\");\n\n\tlist_for_each_entry_safe(s, n, &session_list, list)\n\t\trfcomm_session_del(s);\n}\n\nstatic int rfcomm_run(void *unused)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tBT_DBG(\"\");\n\n\tset_user_nice(current, -10);\n\n\trfcomm_add_listener(BDADDR_ANY);\n\n\tadd_wait_queue(&rfcomm_wq, &wait);\n\twhile (!kthread_should_stop()) {\n\n\t\t \n\t\trfcomm_process_sessions();\n\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&rfcomm_wq, &wait);\n\n\trfcomm_kill_listener();\n\n\treturn 0;\n}\n\nstatic void rfcomm_security_cfm(struct hci_conn *conn, u8 status, u8 encrypt)\n{\n\tstruct rfcomm_session *s;\n\tstruct rfcomm_dlc *d, *n;\n\n\tBT_DBG(\"conn %p status 0x%02x encrypt 0x%02x\", conn, status, encrypt);\n\n\ts = rfcomm_session_get(&conn->hdev->bdaddr, &conn->dst);\n\tif (!s)\n\t\treturn;\n\n\tlist_for_each_entry_safe(d, n, &s->dlcs, list) {\n\t\tif (test_and_clear_bit(RFCOMM_SEC_PENDING, &d->flags)) {\n\t\t\trfcomm_dlc_clear_timer(d);\n\t\t\tif (status || encrypt == 0x00) {\n\t\t\t\tset_bit(RFCOMM_ENC_DROP, &d->flags);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (d->state == BT_CONNECTED && !status && encrypt == 0x00) {\n\t\t\tif (d->sec_level == BT_SECURITY_MEDIUM) {\n\t\t\t\tset_bit(RFCOMM_SEC_PENDING, &d->flags);\n\t\t\t\trfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);\n\t\t\t\tcontinue;\n\t\t\t} else if (d->sec_level == BT_SECURITY_HIGH ||\n\t\t\t\t   d->sec_level == BT_SECURITY_FIPS) {\n\t\t\t\tset_bit(RFCOMM_ENC_DROP, &d->flags);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_and_clear_bit(RFCOMM_AUTH_PENDING, &d->flags))\n\t\t\tcontinue;\n\n\t\tif (!status && hci_conn_check_secure(conn, d->sec_level))\n\t\t\tset_bit(RFCOMM_AUTH_ACCEPT, &d->flags);\n\t\telse\n\t\t\tset_bit(RFCOMM_AUTH_REJECT, &d->flags);\n\t}\n\n\trfcomm_schedule();\n}\n\nstatic struct hci_cb rfcomm_cb = {\n\t.name\t\t= \"RFCOMM\",\n\t.security_cfm\t= rfcomm_security_cfm\n};\n\nstatic int rfcomm_dlc_debugfs_show(struct seq_file *f, void *x)\n{\n\tstruct rfcomm_session *s;\n\n\trfcomm_lock();\n\n\tlist_for_each_entry(s, &session_list, list) {\n\t\tstruct l2cap_chan *chan = l2cap_pi(s->sock->sk)->chan;\n\t\tstruct rfcomm_dlc *d;\n\t\tlist_for_each_entry(d, &s->dlcs, list) {\n\t\t\tseq_printf(f, \"%pMR %pMR %ld %d %d %d %d\\n\",\n\t\t\t\t   &chan->src, &chan->dst,\n\t\t\t\t   d->state, d->dlci, d->mtu,\n\t\t\t\t   d->rx_credits, d->tx_credits);\n\t\t}\n\t}\n\n\trfcomm_unlock();\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(rfcomm_dlc_debugfs);\n\nstatic struct dentry *rfcomm_dlc_debugfs;\n\n \nstatic int __init rfcomm_init(void)\n{\n\tint err;\n\n\thci_register_cb(&rfcomm_cb);\n\n\trfcomm_thread = kthread_run(rfcomm_run, NULL, \"krfcommd\");\n\tif (IS_ERR(rfcomm_thread)) {\n\t\terr = PTR_ERR(rfcomm_thread);\n\t\tgoto unregister;\n\t}\n\n\terr = rfcomm_init_ttys();\n\tif (err < 0)\n\t\tgoto stop;\n\n\terr = rfcomm_init_sockets();\n\tif (err < 0)\n\t\tgoto cleanup;\n\n\tBT_INFO(\"RFCOMM ver %s\", VERSION);\n\n\tif (IS_ERR_OR_NULL(bt_debugfs))\n\t\treturn 0;\n\n\trfcomm_dlc_debugfs = debugfs_create_file(\"rfcomm_dlc\", 0444,\n\t\t\t\t\t\t bt_debugfs, NULL,\n\t\t\t\t\t\t &rfcomm_dlc_debugfs_fops);\n\n\treturn 0;\n\ncleanup:\n\trfcomm_cleanup_ttys();\n\nstop:\n\tkthread_stop(rfcomm_thread);\n\nunregister:\n\thci_unregister_cb(&rfcomm_cb);\n\n\treturn err;\n}\n\nstatic void __exit rfcomm_exit(void)\n{\n\tdebugfs_remove(rfcomm_dlc_debugfs);\n\n\thci_unregister_cb(&rfcomm_cb);\n\n\tkthread_stop(rfcomm_thread);\n\n\trfcomm_cleanup_ttys();\n\n\trfcomm_cleanup_sockets();\n}\n\nmodule_init(rfcomm_init);\nmodule_exit(rfcomm_exit);\n\nmodule_param(disable_cfc, bool, 0644);\nMODULE_PARM_DESC(disable_cfc, \"Disable credit based flow control\");\n\nmodule_param(channel_mtu, int, 0644);\nMODULE_PARM_DESC(channel_mtu, \"Default MTU for the RFCOMM channel\");\n\nmodule_param(l2cap_ertm, bool, 0644);\nMODULE_PARM_DESC(l2cap_ertm, \"Use L2CAP ERTM mode for connection\");\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth RFCOMM ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"bt-proto-3\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}