{
  "module_name": "tty.c",
  "hash_id": "0e2abc324cae927ddaa2267e6fd0fc64891e3f15147119bb41d993e3b2e06487",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/rfcomm/tty.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/rfcomm.h>\n\n#define RFCOMM_TTY_PORTS RFCOMM_MAX_DEV\t \n#define RFCOMM_TTY_MAJOR 216\t\t \n#define RFCOMM_TTY_MINOR 0\n\nstatic DEFINE_MUTEX(rfcomm_ioctl_mutex);\nstatic struct tty_driver *rfcomm_tty_driver;\n\nstruct rfcomm_dev {\n\tstruct tty_port\t\tport;\n\tstruct list_head\tlist;\n\n\tchar\t\t\tname[12];\n\tint\t\t\tid;\n\tunsigned long\t\tflags;\n\tint\t\t\terr;\n\n\tunsigned long\t\tstatus;\t\t \n\n\tbdaddr_t\t\tsrc;\n\tbdaddr_t\t\tdst;\n\tu8\t\t\tchannel;\n\n\tuint\t\t\tmodem_status;\n\n\tstruct rfcomm_dlc\t*dlc;\n\n\tstruct device\t\t*tty_dev;\n\n\tatomic_t\t\twmem_alloc;\n\n\tstruct sk_buff_head\tpending;\n};\n\nstatic LIST_HEAD(rfcomm_dev_list);\nstatic DEFINE_MUTEX(rfcomm_dev_lock);\n\nstatic void rfcomm_dev_data_ready(struct rfcomm_dlc *dlc, struct sk_buff *skb);\nstatic void rfcomm_dev_state_change(struct rfcomm_dlc *dlc, int err);\nstatic void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig);\n\n \n\nstatic void rfcomm_dev_destruct(struct tty_port *port)\n{\n\tstruct rfcomm_dev *dev = container_of(port, struct rfcomm_dev, port);\n\tstruct rfcomm_dlc *dlc = dev->dlc;\n\n\tBT_DBG(\"dev %p dlc %p\", dev, dlc);\n\n\trfcomm_dlc_lock(dlc);\n\t \n\tif (dlc->owner == dev)\n\t\tdlc->owner = NULL;\n\trfcomm_dlc_unlock(dlc);\n\n\trfcomm_dlc_put(dlc);\n\n\tif (dev->tty_dev)\n\t\ttty_unregister_device(rfcomm_tty_driver, dev->id);\n\n\tmutex_lock(&rfcomm_dev_lock);\n\tlist_del(&dev->list);\n\tmutex_unlock(&rfcomm_dev_lock);\n\n\tkfree(dev);\n\n\t \n\tmodule_put(THIS_MODULE);\n}\n\n \nstatic int rfcomm_dev_activate(struct tty_port *port, struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = container_of(port, struct rfcomm_dev, port);\n\tint err;\n\n\terr = rfcomm_dlc_open(dev->dlc, &dev->src, &dev->dst, dev->channel);\n\tif (err)\n\t\tset_bit(TTY_IO_ERROR, &tty->flags);\n\treturn err;\n}\n\n \nstatic bool rfcomm_dev_carrier_raised(struct tty_port *port)\n{\n\tstruct rfcomm_dev *dev = container_of(port, struct rfcomm_dev, port);\n\n\treturn (dev->dlc->state == BT_CONNECTED);\n}\n\n \nstatic void rfcomm_dev_shutdown(struct tty_port *port)\n{\n\tstruct rfcomm_dev *dev = container_of(port, struct rfcomm_dev, port);\n\n\tif (dev->tty_dev->parent)\n\t\tdevice_move(dev->tty_dev, NULL, DPM_ORDER_DEV_LAST);\n\n\t \n\trfcomm_dlc_close(dev->dlc, 0);\n}\n\nstatic const struct tty_port_operations rfcomm_port_ops = {\n\t.destruct = rfcomm_dev_destruct,\n\t.activate = rfcomm_dev_activate,\n\t.shutdown = rfcomm_dev_shutdown,\n\t.carrier_raised = rfcomm_dev_carrier_raised,\n};\n\nstatic struct rfcomm_dev *__rfcomm_dev_lookup(int id)\n{\n\tstruct rfcomm_dev *dev;\n\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list)\n\t\tif (dev->id == id)\n\t\t\treturn dev;\n\n\treturn NULL;\n}\n\nstatic struct rfcomm_dev *rfcomm_dev_get(int id)\n{\n\tstruct rfcomm_dev *dev;\n\n\tmutex_lock(&rfcomm_dev_lock);\n\n\tdev = __rfcomm_dev_lookup(id);\n\n\tif (dev && !tty_port_get(&dev->port))\n\t\tdev = NULL;\n\n\tmutex_unlock(&rfcomm_dev_lock);\n\n\treturn dev;\n}\n\nstatic void rfcomm_reparent_device(struct rfcomm_dev *dev)\n{\n\tstruct hci_dev *hdev;\n\tstruct hci_conn *conn;\n\n\thdev = hci_get_route(&dev->dst, &dev->src, BDADDR_BREDR);\n\tif (!hdev)\n\t\treturn;\n\n\t \n\thci_dev_lock(hdev);\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &dev->dst);\n\n\t \n\tif (conn && device_is_registered(&conn->dev))\n\t\tdevice_move(dev->tty_dev, &conn->dev, DPM_ORDER_DEV_AFTER_PARENT);\n\n\thci_dev_unlock(hdev);\n\thci_dev_put(hdev);\n}\n\nstatic ssize_t address_show(struct device *tty_dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct rfcomm_dev *dev = dev_get_drvdata(tty_dev);\n\treturn sprintf(buf, \"%pMR\\n\", &dev->dst);\n}\n\nstatic ssize_t channel_show(struct device *tty_dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct rfcomm_dev *dev = dev_get_drvdata(tty_dev);\n\treturn sprintf(buf, \"%d\\n\", dev->channel);\n}\n\nstatic DEVICE_ATTR_RO(address);\nstatic DEVICE_ATTR_RO(channel);\n\nstatic struct rfcomm_dev *__rfcomm_dev_add(struct rfcomm_dev_req *req,\n\t\t\t\t\t   struct rfcomm_dlc *dlc)\n{\n\tstruct rfcomm_dev *dev, *entry;\n\tstruct list_head *head = &rfcomm_dev_list;\n\tint err = 0;\n\n\tdev = kzalloc(sizeof(struct rfcomm_dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&rfcomm_dev_lock);\n\n\tif (req->dev_id < 0) {\n\t\tdev->id = 0;\n\n\t\tlist_for_each_entry(entry, &rfcomm_dev_list, list) {\n\t\t\tif (entry->id != dev->id)\n\t\t\t\tbreak;\n\n\t\t\tdev->id++;\n\t\t\thead = &entry->list;\n\t\t}\n\t} else {\n\t\tdev->id = req->dev_id;\n\n\t\tlist_for_each_entry(entry, &rfcomm_dev_list, list) {\n\t\t\tif (entry->id == dev->id) {\n\t\t\t\terr = -EADDRINUSE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (entry->id > dev->id - 1)\n\t\t\t\tbreak;\n\n\t\t\thead = &entry->list;\n\t\t}\n\t}\n\n\tif ((dev->id < 0) || (dev->id > RFCOMM_MAX_DEV - 1)) {\n\t\terr = -ENFILE;\n\t\tgoto out;\n\t}\n\n\tsprintf(dev->name, \"rfcomm%d\", dev->id);\n\n\tlist_add(&dev->list, head);\n\n\tbacpy(&dev->src, &req->src);\n\tbacpy(&dev->dst, &req->dst);\n\tdev->channel = req->channel;\n\n\tdev->flags = req->flags &\n\t\t((1 << RFCOMM_RELEASE_ONHUP) | (1 << RFCOMM_REUSE_DLC));\n\n\ttty_port_init(&dev->port);\n\tdev->port.ops = &rfcomm_port_ops;\n\n\tskb_queue_head_init(&dev->pending);\n\n\trfcomm_dlc_lock(dlc);\n\n\tif (req->flags & (1 << RFCOMM_REUSE_DLC)) {\n\t\tstruct sock *sk = dlc->owner;\n\t\tstruct sk_buff *skb;\n\n\t\tBUG_ON(!sk);\n\n\t\trfcomm_dlc_throttle(dlc);\n\n\t\twhile ((skb = skb_dequeue(&sk->sk_receive_queue))) {\n\t\t\tskb_orphan(skb);\n\t\t\tskb_queue_tail(&dev->pending, skb);\n\t\t\tatomic_sub(skb->len, &sk->sk_rmem_alloc);\n\t\t}\n\t}\n\n\tdlc->data_ready   = rfcomm_dev_data_ready;\n\tdlc->state_change = rfcomm_dev_state_change;\n\tdlc->modem_status = rfcomm_dev_modem_status;\n\n\tdlc->owner = dev;\n\tdev->dlc   = dlc;\n\n\trfcomm_dev_modem_status(dlc, dlc->remote_v24_sig);\n\n\trfcomm_dlc_unlock(dlc);\n\n\t \n\t__module_get(THIS_MODULE);\n\n\tmutex_unlock(&rfcomm_dev_lock);\n\treturn dev;\n\nout:\n\tmutex_unlock(&rfcomm_dev_lock);\n\tkfree(dev);\n\treturn ERR_PTR(err);\n}\n\nstatic int rfcomm_dev_add(struct rfcomm_dev_req *req, struct rfcomm_dlc *dlc)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct device *tty;\n\n\tBT_DBG(\"id %d channel %d\", req->dev_id, req->channel);\n\n\tdev = __rfcomm_dev_add(req, dlc);\n\tif (IS_ERR(dev)) {\n\t\trfcomm_dlc_put(dlc);\n\t\treturn PTR_ERR(dev);\n\t}\n\n\ttty = tty_port_register_device(&dev->port, rfcomm_tty_driver,\n\t\t\tdev->id, NULL);\n\tif (IS_ERR(tty)) {\n\t\ttty_port_put(&dev->port);\n\t\treturn PTR_ERR(tty);\n\t}\n\n\tdev->tty_dev = tty;\n\trfcomm_reparent_device(dev);\n\tdev_set_drvdata(dev->tty_dev, dev);\n\n\tif (device_create_file(dev->tty_dev, &dev_attr_address) < 0)\n\t\tBT_ERR(\"Failed to create address attribute\");\n\n\tif (device_create_file(dev->tty_dev, &dev_attr_channel) < 0)\n\t\tBT_ERR(\"Failed to create channel attribute\");\n\n\treturn dev->id;\n}\n\n \nstatic inline unsigned int rfcomm_room(struct rfcomm_dev *dev)\n{\n\tstruct rfcomm_dlc *dlc = dev->dlc;\n\n\t \n\tint pending = 40 - atomic_read(&dev->wmem_alloc);\n\n\treturn max(0, pending) * dlc->mtu;\n}\n\nstatic void rfcomm_wfree(struct sk_buff *skb)\n{\n\tstruct rfcomm_dev *dev = (void *) skb->sk;\n\tatomic_dec(&dev->wmem_alloc);\n\tif (test_bit(RFCOMM_TTY_ATTACHED, &dev->flags))\n\t\ttty_port_tty_wakeup(&dev->port);\n\ttty_port_put(&dev->port);\n}\n\nstatic void rfcomm_set_owner_w(struct sk_buff *skb, struct rfcomm_dev *dev)\n{\n\ttty_port_get(&dev->port);\n\tatomic_inc(&dev->wmem_alloc);\n\tskb->sk = (void *) dev;\n\tskb->destructor = rfcomm_wfree;\n}\n\nstatic struct sk_buff *rfcomm_wmalloc(struct rfcomm_dev *dev, unsigned long size, gfp_t priority)\n{\n\tstruct sk_buff *skb = alloc_skb(size, priority);\n\tif (skb)\n\t\trfcomm_set_owner_w(skb, dev);\n\treturn skb;\n}\n\n \n\n#define NOCAP_FLAGS ((1 << RFCOMM_REUSE_DLC) | (1 << RFCOMM_RELEASE_ONHUP))\n\nstatic int __rfcomm_create_dev(struct sock *sk, void __user *arg)\n{\n\tstruct rfcomm_dev_req req;\n\tstruct rfcomm_dlc *dlc;\n\tint id;\n\n\tif (copy_from_user(&req, arg, sizeof(req)))\n\t\treturn -EFAULT;\n\n\tBT_DBG(\"sk %p dev_id %d flags 0x%x\", sk, req.dev_id, req.flags);\n\n\tif (req.flags != NOCAP_FLAGS && !capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (req.flags & (1 << RFCOMM_REUSE_DLC)) {\n\t\t \n\t\tif (sk->sk_state != BT_CONNECTED)\n\t\t\treturn -EBADFD;\n\n\t\tdlc = rfcomm_pi(sk)->dlc;\n\t\trfcomm_dlc_hold(dlc);\n\t} else {\n\t\t \n\t\tdlc = rfcomm_dlc_exists(&req.src, &req.dst, req.channel);\n\t\tif (IS_ERR(dlc))\n\t\t\treturn PTR_ERR(dlc);\n\t\tif (dlc)\n\t\t\treturn -EBUSY;\n\t\tdlc = rfcomm_dlc_alloc(GFP_KERNEL);\n\t\tif (!dlc)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tid = rfcomm_dev_add(&req, dlc);\n\tif (id < 0)\n\t\treturn id;\n\n\tif (req.flags & (1 << RFCOMM_REUSE_DLC)) {\n\t\t \n\t\tsk->sk_state = BT_CLOSED;\n\t}\n\n\treturn id;\n}\n\nstatic int __rfcomm_release_dev(void __user *arg)\n{\n\tstruct rfcomm_dev_req req;\n\tstruct rfcomm_dev *dev;\n\tstruct tty_struct *tty;\n\n\tif (copy_from_user(&req, arg, sizeof(req)))\n\t\treturn -EFAULT;\n\n\tBT_DBG(\"dev_id %d flags 0x%x\", req.dev_id, req.flags);\n\n\tdev = rfcomm_dev_get(req.dev_id);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (dev->flags != NOCAP_FLAGS && !capable(CAP_NET_ADMIN)) {\n\t\ttty_port_put(&dev->port);\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (test_and_set_bit(RFCOMM_DEV_RELEASED, &dev->status)) {\n\t\ttty_port_put(&dev->port);\n\t\treturn -EALREADY;\n\t}\n\n\tif (req.flags & (1 << RFCOMM_HANGUP_NOW))\n\t\trfcomm_dlc_close(dev->dlc, 0);\n\n\t \n\ttty = tty_port_tty_get(&dev->port);\n\tif (tty) {\n\t\ttty_vhangup(tty);\n\t\ttty_kref_put(tty);\n\t}\n\n\tif (!test_bit(RFCOMM_TTY_OWNED, &dev->status))\n\t\ttty_port_put(&dev->port);\n\n\ttty_port_put(&dev->port);\n\treturn 0;\n}\n\nstatic int rfcomm_create_dev(struct sock *sk, void __user *arg)\n{\n\tint ret;\n\n\tmutex_lock(&rfcomm_ioctl_mutex);\n\tret = __rfcomm_create_dev(sk, arg);\n\tmutex_unlock(&rfcomm_ioctl_mutex);\n\n\treturn ret;\n}\n\nstatic int rfcomm_release_dev(void __user *arg)\n{\n\tint ret;\n\n\tmutex_lock(&rfcomm_ioctl_mutex);\n\tret = __rfcomm_release_dev(arg);\n\tmutex_unlock(&rfcomm_ioctl_mutex);\n\n\treturn ret;\n}\n\nstatic int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\n\tBT_DBG(\"\");\n\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n\n\tsize = sizeof(*dl) + dev_num * sizeof(*di);\n\n\tdl = kzalloc(size, GFP_KERNEL);\n\tif (!dl)\n\t\treturn -ENOMEM;\n\n\tdi = dl->dev_info;\n\n\tmutex_lock(&rfcomm_dev_lock);\n\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (!tty_port_get(&dev->port))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\ttty_port_put(&dev->port);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&rfcomm_dev_lock);\n\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\n\treturn err ? -EFAULT : 0;\n}\n\nstatic int rfcomm_get_dev_info(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_info di;\n\tint err = 0;\n\n\tBT_DBG(\"\");\n\n\tif (copy_from_user(&di, arg, sizeof(di)))\n\t\treturn -EFAULT;\n\n\tdev = rfcomm_dev_get(di.id);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdi.flags   = dev->flags;\n\tdi.channel = dev->channel;\n\tdi.state   = dev->dlc->state;\n\tbacpy(&di.src, &dev->src);\n\tbacpy(&di.dst, &dev->dst);\n\n\tif (copy_to_user(arg, &di, sizeof(di)))\n\t\terr = -EFAULT;\n\n\ttty_port_put(&dev->port);\n\treturn err;\n}\n\nint rfcomm_dev_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)\n{\n\tBT_DBG(\"cmd %d arg %p\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase RFCOMMCREATEDEV:\n\t\treturn rfcomm_create_dev(sk, arg);\n\n\tcase RFCOMMRELEASEDEV:\n\t\treturn rfcomm_release_dev(arg);\n\n\tcase RFCOMMGETDEVLIST:\n\t\treturn rfcomm_get_dev_list(arg);\n\n\tcase RFCOMMGETDEVINFO:\n\t\treturn rfcomm_get_dev_info(arg);\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic void rfcomm_dev_data_ready(struct rfcomm_dlc *dlc, struct sk_buff *skb)\n{\n\tstruct rfcomm_dev *dev = dlc->owner;\n\n\tif (!dev) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (!skb_queue_empty(&dev->pending)) {\n\t\tskb_queue_tail(&dev->pending, skb);\n\t\treturn;\n\t}\n\n\tBT_DBG(\"dlc %p len %d\", dlc, skb->len);\n\n\ttty_insert_flip_string(&dev->port, skb->data, skb->len);\n\ttty_flip_buffer_push(&dev->port);\n\n\tkfree_skb(skb);\n}\n\nstatic void rfcomm_dev_state_change(struct rfcomm_dlc *dlc, int err)\n{\n\tstruct rfcomm_dev *dev = dlc->owner;\n\tif (!dev)\n\t\treturn;\n\n\tBT_DBG(\"dlc %p dev %p err %d\", dlc, dev, err);\n\n\tdev->err = err;\n\tif (dlc->state == BT_CONNECTED) {\n\t\trfcomm_reparent_device(dev);\n\n\t\twake_up_interruptible(&dev->port.open_wait);\n\t} else if (dlc->state == BT_CLOSED)\n\t\ttty_port_tty_hangup(&dev->port, false);\n}\n\nstatic void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig)\n{\n\tstruct rfcomm_dev *dev = dlc->owner;\n\tif (!dev)\n\t\treturn;\n\n\tBT_DBG(\"dlc %p dev %p v24_sig 0x%02x\", dlc, dev, v24_sig);\n\n\tif ((dev->modem_status & TIOCM_CD) && !(v24_sig & RFCOMM_V24_DV))\n\t\ttty_port_tty_hangup(&dev->port, true);\n\n\tdev->modem_status =\n\t\t((v24_sig & RFCOMM_V24_RTC) ? (TIOCM_DSR | TIOCM_DTR) : 0) |\n\t\t((v24_sig & RFCOMM_V24_RTR) ? (TIOCM_RTS | TIOCM_CTS) : 0) |\n\t\t((v24_sig & RFCOMM_V24_IC)  ? TIOCM_RI : 0) |\n\t\t((v24_sig & RFCOMM_V24_DV)  ? TIOCM_CD : 0);\n}\n\n \nstatic void rfcomm_tty_copy_pending(struct rfcomm_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tint inserted = 0;\n\n\tBT_DBG(\"dev %p\", dev);\n\n\trfcomm_dlc_lock(dev->dlc);\n\n\twhile ((skb = skb_dequeue(&dev->pending))) {\n\t\tinserted += tty_insert_flip_string(&dev->port, skb->data,\n\t\t\t\tskb->len);\n\t\tkfree_skb(skb);\n\t}\n\n\trfcomm_dlc_unlock(dev->dlc);\n\n\tif (inserted > 0)\n\t\ttty_flip_buffer_push(&dev->port);\n}\n\n \nstatic void rfcomm_tty_cleanup(struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\n\tclear_bit(RFCOMM_TTY_ATTACHED, &dev->flags);\n\n\trfcomm_dlc_lock(dev->dlc);\n\ttty->driver_data = NULL;\n\trfcomm_dlc_unlock(dev->dlc);\n\n\t \n\tskb_queue_purge(&dev->dlc->tx_queue);\n\n\ttty_port_put(&dev->port);\n}\n\n \nstatic int rfcomm_tty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dlc *dlc;\n\tint err;\n\n\tdev = rfcomm_dev_get(tty->index);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdlc = dev->dlc;\n\n\t \n\trfcomm_dlc_lock(dlc);\n\ttty->driver_data = dev;\n\trfcomm_dlc_unlock(dlc);\n\tset_bit(RFCOMM_TTY_ATTACHED, &dev->flags);\n\n\t \n\terr = tty_port_install(&dev->port, driver, tty);\n\tif (err) {\n\t\trfcomm_tty_cleanup(tty);\n\t\treturn err;\n\t}\n\n\t \n\tif (test_bit(RFCOMM_RELEASE_ONHUP, &dev->flags)) {\n\t\tset_bit(RFCOMM_TTY_OWNED, &dev->status);\n\t\ttty_port_put(&dev->port);\n\t}\n\n\treturn 0;\n}\n\nstatic int rfcomm_tty_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\tint err;\n\n\tBT_DBG(\"tty %p id %d\", tty, tty->index);\n\n\tBT_DBG(\"dev %p dst %pMR channel %d opened %d\", dev, &dev->dst,\n\t       dev->channel, dev->port.count);\n\n\terr = tty_port_open(&dev->port, tty, filp);\n\tif (err)\n\t\treturn err;\n\n\t \n\trfcomm_tty_copy_pending(dev);\n\n\trfcomm_dlc_unthrottle(dev->dlc);\n\n\treturn 0;\n}\n\nstatic void rfcomm_tty_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\n\tBT_DBG(\"tty %p dev %p dlc %p opened %d\", tty, dev, dev->dlc,\n\t\t\t\t\t\tdev->port.count);\n\n\ttty_port_close(&dev->port, tty, filp);\n}\n\nstatic ssize_t rfcomm_tty_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\tstruct rfcomm_dlc *dlc = dev->dlc;\n\tstruct sk_buff *skb;\n\tsize_t sent = 0, size;\n\n\tBT_DBG(\"tty %p count %zu\", tty, count);\n\n\twhile (count) {\n\t\tsize = min_t(size_t, count, dlc->mtu);\n\n\t\tskb = rfcomm_wmalloc(dev, size + RFCOMM_SKB_RESERVE, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tskb_reserve(skb, RFCOMM_SKB_HEAD_RESERVE);\n\n\t\tskb_put_data(skb, buf + sent, size);\n\n\t\trfcomm_dlc_send_noerror(dlc, skb);\n\n\t\tsent  += size;\n\t\tcount -= size;\n\t}\n\n\treturn sent;\n}\n\nstatic unsigned int rfcomm_tty_write_room(struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\tint room = 0;\n\n\tif (dev && dev->dlc)\n\t\troom = rfcomm_room(dev);\n\n\tBT_DBG(\"tty %p room %d\", tty, room);\n\n\treturn room;\n}\n\nstatic int rfcomm_tty_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\n{\n\tBT_DBG(\"tty %p cmd 0x%02x\", tty, cmd);\n\n\tswitch (cmd) {\n\tcase TCGETS:\n\t\tBT_DBG(\"TCGETS is not supported\");\n\t\treturn -ENOIOCTLCMD;\n\n\tcase TCSETS:\n\t\tBT_DBG(\"TCSETS is not supported\");\n\t\treturn -ENOIOCTLCMD;\n\n\tcase TIOCMIWAIT:\n\t\tBT_DBG(\"TIOCMIWAIT\");\n\t\tbreak;\n\n\tcase TIOCSERGETLSR:\n\t\tBT_ERR(\"TIOCSERGETLSR is not supported\");\n\t\treturn -ENOIOCTLCMD;\n\n\tcase TIOCSERCONFIG:\n\t\tBT_ERR(\"TIOCSERCONFIG is not supported\");\n\t\treturn -ENOIOCTLCMD;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\t \n\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic void rfcomm_tty_set_termios(struct tty_struct *tty,\n\t\t\t\t   const struct ktermios *old)\n{\n\tstruct ktermios *new = &tty->termios;\n\tint old_baud_rate = tty_termios_baud_rate(old);\n\tint new_baud_rate = tty_termios_baud_rate(new);\n\n\tu8 baud, data_bits, stop_bits, parity, x_on, x_off;\n\tu16 changes = 0;\n\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\n\tBT_DBG(\"tty %p termios %p\", tty, old);\n\n\tif (!dev || !dev->dlc || !dev->dlc->session)\n\t\treturn;\n\n\t \n\tif ((old->c_cflag & CRTSCTS) && !(new->c_cflag & CRTSCTS))\n\t\tBT_DBG(\"Turning off CRTSCTS unsupported\");\n\n\t \n\tif (((old->c_cflag & PARENB) != (new->c_cflag & PARENB)) ||\n\t\t\t((old->c_cflag & PARODD) != (new->c_cflag & PARODD))) {\n\t\tchanges |= RFCOMM_RPN_PM_PARITY;\n\t\tBT_DBG(\"Parity change detected.\");\n\t}\n\n\t \n\tif (new->c_cflag & PARENB) {\n\t\tif (new->c_cflag & PARODD) {\n\t\t\tBT_DBG(\"Parity is ODD\");\n\t\t\tparity = RFCOMM_RPN_PARITY_ODD;\n\t\t} else {\n\t\t\tBT_DBG(\"Parity is EVEN\");\n\t\t\tparity = RFCOMM_RPN_PARITY_EVEN;\n\t\t}\n\t} else {\n\t\tBT_DBG(\"Parity is OFF\");\n\t\tparity = RFCOMM_RPN_PARITY_NONE;\n\t}\n\n\t \n\tif (old->c_cc[VSTOP] != new->c_cc[VSTOP]) {\n\t\tBT_DBG(\"XOFF custom\");\n\t\tx_on = new->c_cc[VSTOP];\n\t\tchanges |= RFCOMM_RPN_PM_XON;\n\t} else {\n\t\tBT_DBG(\"XOFF default\");\n\t\tx_on = RFCOMM_RPN_XON_CHAR;\n\t}\n\n\tif (old->c_cc[VSTART] != new->c_cc[VSTART]) {\n\t\tBT_DBG(\"XON custom\");\n\t\tx_off = new->c_cc[VSTART];\n\t\tchanges |= RFCOMM_RPN_PM_XOFF;\n\t} else {\n\t\tBT_DBG(\"XON default\");\n\t\tx_off = RFCOMM_RPN_XOFF_CHAR;\n\t}\n\n\t \n\tif ((old->c_cflag & CSTOPB) != (new->c_cflag & CSTOPB))\n\t\tchanges |= RFCOMM_RPN_PM_STOP;\n\n\t \n\tif (new->c_cflag & CSTOPB)\n\t\tstop_bits = RFCOMM_RPN_STOP_15;\n\telse\n\t\tstop_bits = RFCOMM_RPN_STOP_1;\n\n\t \n\tif ((old->c_cflag & CSIZE) != (new->c_cflag & CSIZE))\n\t\tchanges |= RFCOMM_RPN_PM_DATA;\n\n\tswitch (new->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tdata_bits = RFCOMM_RPN_DATA_5;\n\t\tbreak;\n\tcase CS6:\n\t\tdata_bits = RFCOMM_RPN_DATA_6;\n\t\tbreak;\n\tcase CS7:\n\t\tdata_bits = RFCOMM_RPN_DATA_7;\n\t\tbreak;\n\tcase CS8:\n\t\tdata_bits = RFCOMM_RPN_DATA_8;\n\t\tbreak;\n\tdefault:\n\t\tdata_bits = RFCOMM_RPN_DATA_8;\n\t\tbreak;\n\t}\n\n\t \n\tif (old_baud_rate != new_baud_rate)\n\t\tchanges |= RFCOMM_RPN_PM_BITRATE;\n\n\tswitch (new_baud_rate) {\n\tcase 2400:\n\t\tbaud = RFCOMM_RPN_BR_2400;\n\t\tbreak;\n\tcase 4800:\n\t\tbaud = RFCOMM_RPN_BR_4800;\n\t\tbreak;\n\tcase 7200:\n\t\tbaud = RFCOMM_RPN_BR_7200;\n\t\tbreak;\n\tcase 9600:\n\t\tbaud = RFCOMM_RPN_BR_9600;\n\t\tbreak;\n\tcase 19200:\n\t\tbaud = RFCOMM_RPN_BR_19200;\n\t\tbreak;\n\tcase 38400:\n\t\tbaud = RFCOMM_RPN_BR_38400;\n\t\tbreak;\n\tcase 57600:\n\t\tbaud = RFCOMM_RPN_BR_57600;\n\t\tbreak;\n\tcase 115200:\n\t\tbaud = RFCOMM_RPN_BR_115200;\n\t\tbreak;\n\tcase 230400:\n\t\tbaud = RFCOMM_RPN_BR_230400;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbaud = RFCOMM_RPN_BR_9600;\n\t\tbreak;\n\n\t}\n\n\tif (changes)\n\t\trfcomm_send_rpn(dev->dlc->session, 1, dev->dlc->dlci, baud,\n\t\t\t\tdata_bits, stop_bits, parity,\n\t\t\t\tRFCOMM_RPN_FLOW_NONE, x_on, x_off, changes);\n}\n\nstatic void rfcomm_tty_throttle(struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\n\tBT_DBG(\"tty %p dev %p\", tty, dev);\n\n\trfcomm_dlc_throttle(dev->dlc);\n}\n\nstatic void rfcomm_tty_unthrottle(struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\n\tBT_DBG(\"tty %p dev %p\", tty, dev);\n\n\trfcomm_dlc_unthrottle(dev->dlc);\n}\n\nstatic unsigned int rfcomm_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\n\tBT_DBG(\"tty %p dev %p\", tty, dev);\n\n\tif (!dev || !dev->dlc)\n\t\treturn 0;\n\n\tif (!skb_queue_empty(&dev->dlc->tx_queue))\n\t\treturn dev->dlc->mtu;\n\n\treturn 0;\n}\n\nstatic void rfcomm_tty_flush_buffer(struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\n\tBT_DBG(\"tty %p dev %p\", tty, dev);\n\n\tif (!dev || !dev->dlc)\n\t\treturn;\n\n\tskb_queue_purge(&dev->dlc->tx_queue);\n\ttty_wakeup(tty);\n}\n\nstatic void rfcomm_tty_send_xchar(struct tty_struct *tty, char ch)\n{\n\tBT_DBG(\"tty %p ch %c\", tty, ch);\n}\n\nstatic void rfcomm_tty_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\tBT_DBG(\"tty %p timeout %d\", tty, timeout);\n}\n\nstatic void rfcomm_tty_hangup(struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\n\tBT_DBG(\"tty %p dev %p\", tty, dev);\n\n\ttty_port_hangup(&dev->port);\n}\n\nstatic int rfcomm_tty_tiocmget(struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\n\tBT_DBG(\"tty %p dev %p\", tty, dev);\n\n\treturn dev->modem_status;\n}\n\nstatic int rfcomm_tty_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear)\n{\n\tstruct rfcomm_dev *dev = tty->driver_data;\n\tstruct rfcomm_dlc *dlc = dev->dlc;\n\tu8 v24_sig;\n\n\tBT_DBG(\"tty %p dev %p set 0x%02x clear 0x%02x\", tty, dev, set, clear);\n\n\trfcomm_dlc_get_modem_status(dlc, &v24_sig);\n\n\tif (set & TIOCM_DSR || set & TIOCM_DTR)\n\t\tv24_sig |= RFCOMM_V24_RTC;\n\tif (set & TIOCM_RTS || set & TIOCM_CTS)\n\t\tv24_sig |= RFCOMM_V24_RTR;\n\tif (set & TIOCM_RI)\n\t\tv24_sig |= RFCOMM_V24_IC;\n\tif (set & TIOCM_CD)\n\t\tv24_sig |= RFCOMM_V24_DV;\n\n\tif (clear & TIOCM_DSR || clear & TIOCM_DTR)\n\t\tv24_sig &= ~RFCOMM_V24_RTC;\n\tif (clear & TIOCM_RTS || clear & TIOCM_CTS)\n\t\tv24_sig &= ~RFCOMM_V24_RTR;\n\tif (clear & TIOCM_RI)\n\t\tv24_sig &= ~RFCOMM_V24_IC;\n\tif (clear & TIOCM_CD)\n\t\tv24_sig &= ~RFCOMM_V24_DV;\n\n\trfcomm_dlc_set_modem_status(dlc, v24_sig);\n\n\treturn 0;\n}\n\n \n\nstatic const struct tty_operations rfcomm_ops = {\n\t.open\t\t\t= rfcomm_tty_open,\n\t.close\t\t\t= rfcomm_tty_close,\n\t.write\t\t\t= rfcomm_tty_write,\n\t.write_room\t\t= rfcomm_tty_write_room,\n\t.chars_in_buffer\t= rfcomm_tty_chars_in_buffer,\n\t.flush_buffer\t\t= rfcomm_tty_flush_buffer,\n\t.ioctl\t\t\t= rfcomm_tty_ioctl,\n\t.throttle\t\t= rfcomm_tty_throttle,\n\t.unthrottle\t\t= rfcomm_tty_unthrottle,\n\t.set_termios\t\t= rfcomm_tty_set_termios,\n\t.send_xchar\t\t= rfcomm_tty_send_xchar,\n\t.hangup\t\t\t= rfcomm_tty_hangup,\n\t.wait_until_sent\t= rfcomm_tty_wait_until_sent,\n\t.tiocmget\t\t= rfcomm_tty_tiocmget,\n\t.tiocmset\t\t= rfcomm_tty_tiocmset,\n\t.install                = rfcomm_tty_install,\n\t.cleanup                = rfcomm_tty_cleanup,\n};\n\nint __init rfcomm_init_ttys(void)\n{\n\tint error;\n\n\trfcomm_tty_driver = tty_alloc_driver(RFCOMM_TTY_PORTS,\n\t\t\tTTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(rfcomm_tty_driver))\n\t\treturn PTR_ERR(rfcomm_tty_driver);\n\n\trfcomm_tty_driver->driver_name\t= \"rfcomm\";\n\trfcomm_tty_driver->name\t\t= \"rfcomm\";\n\trfcomm_tty_driver->major\t= RFCOMM_TTY_MAJOR;\n\trfcomm_tty_driver->minor_start\t= RFCOMM_TTY_MINOR;\n\trfcomm_tty_driver->type\t\t= TTY_DRIVER_TYPE_SERIAL;\n\trfcomm_tty_driver->subtype\t= SERIAL_TYPE_NORMAL;\n\trfcomm_tty_driver->init_termios\t= tty_std_termios;\n\trfcomm_tty_driver->init_termios.c_cflag\t= B9600 | CS8 | CREAD | HUPCL;\n\trfcomm_tty_driver->init_termios.c_lflag &= ~ICANON;\n\ttty_set_operations(rfcomm_tty_driver, &rfcomm_ops);\n\n\terror = tty_register_driver(rfcomm_tty_driver);\n\tif (error) {\n\t\tBT_ERR(\"Can't register RFCOMM TTY driver\");\n\t\ttty_driver_kref_put(rfcomm_tty_driver);\n\t\treturn error;\n\t}\n\n\tBT_INFO(\"RFCOMM TTY layer initialized\");\n\n\treturn 0;\n}\n\nvoid rfcomm_cleanup_ttys(void)\n{\n\ttty_unregister_driver(rfcomm_tty_driver);\n\ttty_driver_kref_put(rfcomm_tty_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}