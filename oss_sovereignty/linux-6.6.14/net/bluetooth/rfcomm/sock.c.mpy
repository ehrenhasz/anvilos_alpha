{
  "module_name": "sock.c",
  "hash_id": "78e7a786605aa86165443a0a45190473bf9edde2735425801349a6ebbe4c99a4",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/rfcomm/sock.c",
  "human_readable_source": " \n\n \n#include <linux/compat.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/sched/signal.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n#include <net/bluetooth/rfcomm.h>\n\nstatic const struct proto_ops rfcomm_sock_ops;\n\nstatic struct bt_sock_list rfcomm_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(rfcomm_sk_list.lock)\n};\n\nstatic void rfcomm_sock_close(struct sock *sk);\nstatic void rfcomm_sock_kill(struct sock *sk);\n\n \nstatic void rfcomm_sk_data_ready(struct rfcomm_dlc *d, struct sk_buff *skb)\n{\n\tstruct sock *sk = d->owner;\n\tif (!sk)\n\t\treturn;\n\n\tatomic_add(skb->len, &sk->sk_rmem_alloc);\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_data_ready(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\trfcomm_dlc_throttle(d);\n}\n\nstatic void rfcomm_sk_state_change(struct rfcomm_dlc *d, int err)\n{\n\tstruct sock *sk = d->owner, *parent;\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"dlc %p state %ld err %d\", d, d->state, err);\n\n\tlock_sock(sk);\n\n\tif (err)\n\t\tsk->sk_err = err;\n\n\tsk->sk_state = d->state;\n\n\tparent = bt_sk(sk)->parent;\n\tif (parent) {\n\t\tif (d->state == BT_CLOSED) {\n\t\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\t\tbt_accept_unlink(sk);\n\t\t}\n\t\tparent->sk_data_ready(parent);\n\t} else {\n\t\tif (d->state == BT_CONNECTED)\n\t\t\trfcomm_session_getaddr(d->session,\n\t\t\t\t\t       &rfcomm_pi(sk)->src, NULL);\n\t\tsk->sk_state_change(sk);\n\t}\n\n\trelease_sock(sk);\n\n\tif (parent && sock_flag(sk, SOCK_ZAPPED)) {\n\t\t \n\t\trfcomm_dlc_unlock(d);\n\t\trfcomm_sock_kill(sk);\n\t\trfcomm_dlc_lock(d);\n\t}\n}\n\n \nstatic struct sock *__rfcomm_get_listen_sock_by_addr(u8 channel, bdaddr_t *src)\n{\n\tstruct sock *sk = NULL;\n\n\tsk_for_each(sk, &rfcomm_sk_list.head) {\n\t\tif (rfcomm_pi(sk)->channel != channel)\n\t\t\tcontinue;\n\n\t\tif (bacmp(&rfcomm_pi(sk)->src, src))\n\t\t\tcontinue;\n\n\t\tif (sk->sk_state == BT_BOUND || sk->sk_state == BT_LISTEN)\n\t\t\tbreak;\n\t}\n\n\treturn sk ? sk : NULL;\n}\n\n \nstatic struct sock *rfcomm_get_sock_by_channel(int state, u8 channel, bdaddr_t *src)\n{\n\tstruct sock *sk = NULL, *sk1 = NULL;\n\n\tread_lock(&rfcomm_sk_list.lock);\n\n\tsk_for_each(sk, &rfcomm_sk_list.head) {\n\t\tif (state && sk->sk_state != state)\n\t\t\tcontinue;\n\n\t\tif (rfcomm_pi(sk)->channel == channel) {\n\t\t\t \n\t\t\tif (!bacmp(&rfcomm_pi(sk)->src, src))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (!bacmp(&rfcomm_pi(sk)->src, BDADDR_ANY))\n\t\t\t\tsk1 = sk;\n\t\t}\n\t}\n\n\tread_unlock(&rfcomm_sk_list.lock);\n\n\treturn sk ? sk : sk1;\n}\n\nstatic void rfcomm_sock_destruct(struct sock *sk)\n{\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\n\tBT_DBG(\"sk %p dlc %p\", sk, d);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n\n\trfcomm_dlc_lock(d);\n\trfcomm_pi(sk)->dlc = NULL;\n\n\t \n\tif (d->owner == sk)\n\t\td->owner = NULL;\n\trfcomm_dlc_unlock(d);\n\n\trfcomm_dlc_put(d);\n}\n\nstatic void rfcomm_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t \n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\trfcomm_sock_close(sk);\n\t\trfcomm_sock_kill(sk);\n\t}\n\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}\n\n \nstatic void rfcomm_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %d refcnt %d\", sk, sk->sk_state, refcount_read(&sk->sk_refcnt));\n\n\t \n\tbt_sock_unlink(&rfcomm_sk_list, sk);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic void __rfcomm_sock_close(struct sock *sk)\n{\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\trfcomm_sock_cleanup_listen(sk);\n\t\tbreak;\n\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\tcase BT_CONNECTED:\n\t\trfcomm_dlc_close(d, 0);\n\t\tfallthrough;\n\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}\n\n \nstatic void rfcomm_sock_close(struct sock *sk)\n{\n\tlock_sock(sk);\n\t__rfcomm_sock_close(sk);\n\trelease_sock(sk);\n}\n\nstatic void rfcomm_sock_init(struct sock *sk, struct sock *parent)\n{\n\tstruct rfcomm_pinfo *pi = rfcomm_pi(sk);\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tsk->sk_type = parent->sk_type;\n\t\tpi->dlc->defer_setup = test_bit(BT_SK_DEFER_SETUP,\n\t\t\t\t\t\t&bt_sk(parent)->flags);\n\n\t\tpi->sec_level = rfcomm_pi(parent)->sec_level;\n\t\tpi->role_switch = rfcomm_pi(parent)->role_switch;\n\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tpi->dlc->defer_setup = 0;\n\n\t\tpi->sec_level = BT_SECURITY_LOW;\n\t\tpi->role_switch = 0;\n\t}\n\n\tpi->dlc->sec_level = pi->sec_level;\n\tpi->dlc->role_switch = pi->role_switch;\n}\n\nstatic struct proto rfcomm_proto = {\n\t.name\t\t= \"RFCOMM\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct rfcomm_pinfo)\n};\n\nstatic struct sock *rfcomm_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t      int proto, gfp_t prio, int kern)\n{\n\tstruct rfcomm_dlc *d;\n\tstruct sock *sk;\n\n\tsk = bt_sock_alloc(net, sock, &rfcomm_proto, proto, prio, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\td = rfcomm_dlc_alloc(prio);\n\tif (!d) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\td->data_ready   = rfcomm_sk_data_ready;\n\td->state_change = rfcomm_sk_state_change;\n\n\trfcomm_pi(sk)->dlc = d;\n\td->owner = sk;\n\n\tsk->sk_destruct = rfcomm_sock_destruct;\n\tsk->sk_sndtimeo = RFCOMM_CONN_TIMEOUT;\n\n\tsk->sk_sndbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsk->sk_rcvbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\n\tbt_sock_link(&rfcomm_sk_list, sk);\n\n\tBT_DBG(\"sk %p\", sk);\n\treturn sk;\n}\n\nstatic int rfcomm_sock_create(struct net *net, struct socket *sock,\n\t\t\t      int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &rfcomm_sock_ops;\n\n\tsk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\trfcomm_sock_init(sk, NULL);\n\treturn 0;\n}\n\nstatic int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc sa;\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\n\tif (!addr || addr_len < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tlen = min_t(unsigned int, sizeof(sa), addr_len);\n\tmemcpy(&sa, addr, len);\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa.rc_bdaddr);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&rfcomm_sk_list.lock);\n\n\tif (sa.rc_channel &&\n\t    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t \n\t\tbacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = sa.rc_channel;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (alen < sizeof(struct sockaddr_rc) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tsk->sk_state = BT_CONNECT;\n\tbacpy(&rfcomm_pi(sk)->dst, &sa->rc_bdaddr);\n\trfcomm_pi(sk)->channel = sa->rc_channel;\n\n\td->sec_level = rfcomm_pi(sk)->sec_level;\n\td->role_switch = rfcomm_pi(sk)->role_switch;\n\n\t \n\trelease_sock(sk);\n\terr = rfcomm_dlc_open(d, &rfcomm_pi(sk)->src, &sa->rc_bdaddr,\n\t\t\t      sa->rc_channel);\n\tlock_sock(sk);\n\tif (!err && !sock_flag(sk, SOCK_ZAPPED))\n\t\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\n\ndone:\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (!rfcomm_pi(sk)->channel) {\n\t\tbdaddr_t *src = &rfcomm_pi(sk)->src;\n\t\tu8 channel;\n\n\t\terr = -EINVAL;\n\n\t\twrite_lock(&rfcomm_sk_list.lock);\n\n\t\tfor (channel = 1; channel < 31; channel++)\n\t\t\tif (!__rfcomm_get_listen_sock_by_addr(channel, src)) {\n\t\t\t\trfcomm_pi(sk)->channel = channel;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\twrite_unlock(&rfcomm_sk_list.lock);\n\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t\t      bool kern)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = sock->sk, *nsk;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t \n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tnsk = bt_accept_dequeue(sk, newsock);\n\t\tif (nsk)\n\t\t\tbreak;\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", nsk);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (peer && sk->sk_state != BT_CONNECTED &&\n\t    sk->sk_state != BT_CONNECT && sk->sk_state != BT_CONNECT2)\n\t\treturn -ENOTCONN;\n\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->rc_family  = AF_BLUETOOTH;\n\tsa->rc_channel = rfcomm_pi(sk)->channel;\n\tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &rfcomm_pi(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &rfcomm_pi(sk)->src);\n\n\treturn sizeof(struct sockaddr_rc);\n}\n\nstatic int rfcomm_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tstruct sk_buff *skb;\n\tint sent;\n\n\tif (test_bit(RFCOMM_DEFER_SETUP, &d->flags))\n\t\treturn -ENOTCONN;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\treturn -EPIPE;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tlock_sock(sk);\n\n\tsent = bt_sock_wait_ready(sk, msg->msg_flags);\n\n\trelease_sock(sk);\n\n\tif (sent)\n\t\treturn sent;\n\n\tskb = bt_skb_sendmmsg(sk, msg, len, d->mtu, RFCOMM_SKB_HEAD_RESERVE,\n\t\t\t      RFCOMM_SKB_TAIL_RESERVE);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tsent = rfcomm_dlc_send(d, skb);\n\tif (sent < 0)\n\t\tkfree_skb(skb);\n\n\treturn sent;\n}\n\nstatic int rfcomm_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint len;\n\n\tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n\t\trfcomm_dlc_accept(d);\n\t\treturn 0;\n\t}\n\n\tlen = bt_sock_stream_recvmsg(sock, msg, size, flags);\n\n\tlock_sock(sk);\n\tif (!(flags & MSG_PEEK) && len > 0)\n\t\tatomic_sub(len, &sk->sk_rmem_alloc);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= (sk->sk_rcvbuf >> 2))\n\t\trfcomm_dlc_unthrottle(rfcomm_pi(sk)->dlc);\n\trelease_sock(sk);\n\n\treturn len;\n}\n\nstatic int rfcomm_sock_setsockopt_old(struct socket *sock, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase RFCOMM_LM:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_FIPS) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_AUTH)\n\t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & RFCOMM_LM_ENCRYPT)\n\t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & RFCOMM_LM_SECURE)\n\t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\trfcomm_pi(sk)->role_switch = (opt & RFCOMM_LM_MASTER);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t len;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_sockptr(&sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level > BT_SECURITY_HIGH) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\trfcomm_pi(sk)->sec_level = sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sock *l2cap_sk;\n\tstruct l2cap_conn *conn;\n\tstruct rfcomm_conninfo cinfo;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase RFCOMM_LM:\n\t\tswitch (rfcomm_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_LOW:\n\t\t\topt = RFCOMM_LM_AUTH;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_HIGH:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |\n\t\t\t      RFCOMM_LM_SECURE;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_FIPS:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |\n\t\t\t      RFCOMM_LM_SECURE | RFCOMM_LM_FIPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\topt = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rfcomm_pi(sk)->role_switch)\n\t\t\topt |= RFCOMM_LM_MASTER;\n\n\t\tif (put_user(opt, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase RFCOMM_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t\t\t\t!rfcomm_pi(sk)->dlc->defer_setup) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_sk = rfcomm_pi(sk)->dlc->session->sock->sk;\n\t\tconn = l2cap_pi(l2cap_sk)->chan->conn;\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *) &cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = rfcomm_pi(sk)->sec_level;\n\t\tsec.key_size = 0;\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk __maybe_unused = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sk %p cmd %x arg %lx\", sk, cmd, arg);\n\n\terr = bt_sock_ioctl(sock, cmd, arg);\n\n\tif (err == -ENOIOCTLCMD) {\n#ifdef CONFIG_BT_RFCOMM_TTY\n\t\tlock_sock(sk);\n\t\terr = rfcomm_dev_ioctl(sk, cmd, (void __user *) arg);\n\t\trelease_sock(sk);\n#else\n\t\terr = -EOPNOTSUPP;\n#endif\n\t}\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int rfcomm_sock_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\treturn rfcomm_sock_ioctl(sock, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic int rfcomm_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\n\t\trelease_sock(sk);\n\t\t__rfcomm_sock_close(sk);\n\t\tlock_sock(sk);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t\t    !(current->flags & PF_EXITING))\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t}\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\terr = rfcomm_sock_shutdown(sock, 2);\n\n\tsock_orphan(sk);\n\trfcomm_sock_kill(sk);\n\treturn err;\n}\n\n \nint rfcomm_connect_ind(struct rfcomm_session *s, u8 channel, struct rfcomm_dlc **d)\n{\n\tstruct sock *sk, *parent;\n\tbdaddr_t src, dst;\n\tint result = 0;\n\n\tBT_DBG(\"session %p channel %d\", s, channel);\n\n\trfcomm_session_getaddr(s, &src, &dst);\n\n\t \n\tparent = rfcomm_get_sock_by_channel(BT_LISTEN, channel, &src);\n\tif (!parent)\n\t\treturn 0;\n\n\tlock_sock(parent);\n\n\t \n\tif (sk_acceptq_is_full(parent)) {\n\t\tBT_DBG(\"backlog full %d\", parent->sk_ack_backlog);\n\t\tgoto done;\n\t}\n\n\tsk = rfcomm_sock_alloc(sock_net(parent), NULL, BTPROTO_RFCOMM, GFP_ATOMIC, 0);\n\tif (!sk)\n\t\tgoto done;\n\n\tbt_sock_reclassify_lock(sk, BTPROTO_RFCOMM);\n\n\trfcomm_sock_init(sk, parent);\n\tbacpy(&rfcomm_pi(sk)->src, &src);\n\tbacpy(&rfcomm_pi(sk)->dst, &dst);\n\trfcomm_pi(sk)->channel = channel;\n\n\tsk->sk_state = BT_CONFIG;\n\tbt_accept_enqueue(parent, sk, true);\n\n\t \n\t*d = rfcomm_pi(sk)->dlc;\n\tresult = 1;\n\ndone:\n\trelease_sock(parent);\n\n\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))\n\t\tparent->sk_state_change(parent);\n\n\treturn result;\n}\n\nstatic int rfcomm_sock_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct sock *sk;\n\n\tread_lock(&rfcomm_sk_list.lock);\n\n\tsk_for_each(sk, &rfcomm_sk_list.head) {\n\t\tseq_printf(f, \"%pMR %pMR %d %d\\n\",\n\t\t\t   &rfcomm_pi(sk)->src, &rfcomm_pi(sk)->dst,\n\t\t\t   sk->sk_state, rfcomm_pi(sk)->channel);\n\t}\n\n\tread_unlock(&rfcomm_sk_list.lock);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(rfcomm_sock_debugfs);\n\nstatic struct dentry *rfcomm_sock_debugfs;\n\nstatic const struct proto_ops rfcomm_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= rfcomm_sock_release,\n\t.bind\t\t= rfcomm_sock_bind,\n\t.connect\t= rfcomm_sock_connect,\n\t.listen\t\t= rfcomm_sock_listen,\n\t.accept\t\t= rfcomm_sock_accept,\n\t.getname\t= rfcomm_sock_getname,\n\t.sendmsg\t= rfcomm_sock_sendmsg,\n\t.recvmsg\t= rfcomm_sock_recvmsg,\n\t.shutdown\t= rfcomm_sock_shutdown,\n\t.setsockopt\t= rfcomm_sock_setsockopt,\n\t.getsockopt\t= rfcomm_sock_getsockopt,\n\t.ioctl\t\t= rfcomm_sock_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.poll\t\t= bt_sock_poll,\n\t.socketpair\t= sock_no_socketpair,\n\t.mmap\t\t= sock_no_mmap,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= rfcomm_sock_compat_ioctl,\n#endif\n};\n\nstatic const struct net_proto_family rfcomm_sock_family_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.create\t\t= rfcomm_sock_create\n};\n\nint __init rfcomm_init_sockets(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_rc) > sizeof(struct sockaddr));\n\n\terr = proto_register(&rfcomm_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_RFCOMM, &rfcomm_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"RFCOMM socket layer registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"rfcomm\", &rfcomm_sk_list, NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create RFCOMM proc file\");\n\t\tbt_sock_unregister(BTPROTO_RFCOMM);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"RFCOMM socket layer initialized\");\n\n\tif (IS_ERR_OR_NULL(bt_debugfs))\n\t\treturn 0;\n\n\trfcomm_sock_debugfs = debugfs_create_file(\"rfcomm\", 0444,\n\t\t\t\t\t\t  bt_debugfs, NULL,\n\t\t\t\t\t\t  &rfcomm_sock_debugfs_fops);\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&rfcomm_proto);\n\treturn err;\n}\n\nvoid __exit rfcomm_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"rfcomm\");\n\n\tdebugfs_remove(rfcomm_sock_debugfs);\n\n\tbt_sock_unregister(BTPROTO_RFCOMM);\n\n\tproto_unregister(&rfcomm_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}