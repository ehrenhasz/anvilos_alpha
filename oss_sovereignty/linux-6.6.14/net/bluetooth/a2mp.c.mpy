{
  "module_name": "a2mp.c",
  "hash_id": "a8a9f243a49d9ec5aa1d8fd96ef40232d7fa1d14c2fb4a2374cf36fc27d0cdf8",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/a2mp.c",
  "human_readable_source": "\n \n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"hci_request.h\"\n#include \"a2mp.h\"\n#include \"amp.h\"\n\n#define A2MP_FEAT_EXT\t0x8000\n\n \nstatic LIST_HEAD(amp_mgr_list);\nstatic DEFINE_MUTEX(amp_mgr_list_lock);\n\n \nstatic struct a2mp_cmd *__a2mp_build(u8 code, u8 ident, u16 len, void *data)\n{\n\tstruct a2mp_cmd *cmd;\n\tint plen;\n\n\tplen = sizeof(*cmd) + len;\n\tcmd = kzalloc(plen, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn NULL;\n\n\tcmd->code = code;\n\tcmd->ident = ident;\n\tcmd->len = cpu_to_le16(len);\n\n\tmemcpy(cmd->data, data, len);\n\n\treturn cmd;\n}\n\nstatic void a2mp_send(struct amp_mgr *mgr, u8 code, u8 ident, u16 len, void *data)\n{\n\tstruct l2cap_chan *chan = mgr->a2mp_chan;\n\tstruct a2mp_cmd *cmd;\n\tu16 total_len = len + sizeof(*cmd);\n\tstruct kvec iv;\n\tstruct msghdr msg;\n\n\tcmd = __a2mp_build(code, ident, len, data);\n\tif (!cmd)\n\t\treturn;\n\n\tiv.iov_base = cmd;\n\tiv.iov_len = total_len;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tiov_iter_kvec(&msg.msg_iter, ITER_SOURCE, &iv, 1, total_len);\n\n\tl2cap_chan_send(chan, &msg, total_len);\n\n\tkfree(cmd);\n}\n\nstatic u8 __next_ident(struct amp_mgr *mgr)\n{\n\tif (++mgr->ident == 0)\n\t\tmgr->ident = 1;\n\n\treturn mgr->ident;\n}\n\nstatic struct amp_mgr *amp_mgr_lookup_by_state(u8 state)\n{\n\tstruct amp_mgr *mgr;\n\n\tmutex_lock(&amp_mgr_list_lock);\n\tlist_for_each_entry(mgr, &amp_mgr_list, list) {\n\t\tif (test_and_clear_bit(state, &mgr->state)) {\n\t\t\tamp_mgr_get(mgr);\n\t\t\tmutex_unlock(&amp_mgr_list_lock);\n\t\t\treturn mgr;\n\t\t}\n\t}\n\tmutex_unlock(&amp_mgr_list_lock);\n\n\treturn NULL;\n}\n\n \nstatic void __a2mp_add_cl(struct amp_mgr *mgr, struct a2mp_cl *cl)\n{\n\tstruct hci_dev *hdev;\n\tint i = 1;\n\n\tcl[0].id = AMP_ID_BREDR;\n\tcl[0].type = AMP_TYPE_BREDR;\n\tcl[0].status = AMP_STATUS_BLUETOOTH_ONLY;\n\n\tlist_for_each_entry(hdev, &hci_dev_list, list) {\n\t\tif (hdev->dev_type == HCI_AMP) {\n\t\t\tcl[i].id = hdev->id;\n\t\t\tcl[i].type = hdev->amp_type;\n\t\t\tif (test_bit(HCI_UP, &hdev->flags))\n\t\t\t\tcl[i].status = hdev->amp_status;\n\t\t\telse\n\t\t\t\tcl[i].status = AMP_STATUS_POWERED_DOWN;\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n \nstatic int a2mp_command_rej(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t    struct a2mp_cmd *hdr)\n{\n\tstruct a2mp_cmd_rej *rej = (void *) skb->data;\n\n\tif (le16_to_cpu(hdr->len) < sizeof(*rej))\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"ident %u reason %d\", hdr->ident, le16_to_cpu(rej->reason));\n\n\tskb_pull(skb, sizeof(*rej));\n\n\treturn 0;\n}\n\nstatic int a2mp_discover_req(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t     struct a2mp_cmd *hdr)\n{\n\tstruct a2mp_discov_req *req = (void *) skb->data;\n\tu16 len = le16_to_cpu(hdr->len);\n\tstruct a2mp_discov_rsp *rsp;\n\tu16 ext_feat;\n\tu8 num_ctrl;\n\tstruct hci_dev *hdev;\n\n\tif (len < sizeof(*req))\n\t\treturn -EINVAL;\n\n\tskb_pull(skb, sizeof(*req));\n\n\text_feat = le16_to_cpu(req->ext_feat);\n\n\tBT_DBG(\"mtu %d efm 0x%4.4x\", le16_to_cpu(req->mtu), ext_feat);\n\n\t \n\twhile (ext_feat & A2MP_FEAT_EXT) {\n\t\tif (len < sizeof(ext_feat))\n\t\t\treturn -EINVAL;\n\n\t\text_feat = get_unaligned_le16(skb->data);\n\t\tBT_DBG(\"efm 0x%4.4x\", ext_feat);\n\t\tlen -= sizeof(ext_feat);\n\t\tskb_pull(skb, sizeof(ext_feat));\n\t}\n\n\tread_lock(&hci_dev_list_lock);\n\n\t \n\tnum_ctrl = 1;\n\n\tlist_for_each_entry(hdev, &hci_dev_list, list) {\n\t\tif (hdev->dev_type == HCI_AMP)\n\t\t\tnum_ctrl++;\n\t}\n\n\tlen = struct_size(rsp, cl, num_ctrl);\n\trsp = kmalloc(len, GFP_ATOMIC);\n\tif (!rsp) {\n\t\tread_unlock(&hci_dev_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\trsp->mtu = cpu_to_le16(L2CAP_A2MP_DEFAULT_MTU);\n\trsp->ext_feat = 0;\n\n\t__a2mp_add_cl(mgr, rsp->cl);\n\n\tread_unlock(&hci_dev_list_lock);\n\n\ta2mp_send(mgr, A2MP_DISCOVER_RSP, hdr->ident, len, rsp);\n\n\tkfree(rsp);\n\treturn 0;\n}\n\nstatic int a2mp_discover_rsp(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t     struct a2mp_cmd *hdr)\n{\n\tstruct a2mp_discov_rsp *rsp = (void *) skb->data;\n\tu16 len = le16_to_cpu(hdr->len);\n\tstruct a2mp_cl *cl;\n\tu16 ext_feat;\n\tbool found = false;\n\n\tif (len < sizeof(*rsp))\n\t\treturn -EINVAL;\n\n\tlen -= sizeof(*rsp);\n\tskb_pull(skb, sizeof(*rsp));\n\n\text_feat = le16_to_cpu(rsp->ext_feat);\n\n\tBT_DBG(\"mtu %d efm 0x%4.4x\", le16_to_cpu(rsp->mtu), ext_feat);\n\n\t \n\twhile (ext_feat & A2MP_FEAT_EXT) {\n\t\tif (len < sizeof(ext_feat))\n\t\t\treturn -EINVAL;\n\n\t\text_feat = get_unaligned_le16(skb->data);\n\t\tBT_DBG(\"efm 0x%4.4x\", ext_feat);\n\t\tlen -= sizeof(ext_feat);\n\t\tskb_pull(skb, sizeof(ext_feat));\n\t}\n\n\tcl = (void *) skb->data;\n\twhile (len >= sizeof(*cl)) {\n\t\tBT_DBG(\"Remote AMP id %u type %u status %u\", cl->id, cl->type,\n\t\t       cl->status);\n\n\t\tif (cl->id != AMP_ID_BREDR && cl->type != AMP_TYPE_BREDR) {\n\t\t\tstruct a2mp_info_req req;\n\n\t\t\tfound = true;\n\n\t\t\tmemset(&req, 0, sizeof(req));\n\n\t\t\treq.id = cl->id;\n\t\t\ta2mp_send(mgr, A2MP_GETINFO_REQ, __next_ident(mgr),\n\t\t\t\t  sizeof(req), &req);\n\t\t}\n\n\t\tlen -= sizeof(*cl);\n\t\tcl = skb_pull(skb, sizeof(*cl));\n\t}\n\n\t \n\tif (!found) {\n\t\tstruct l2cap_conn *conn = mgr->l2cap_conn;\n\t\tstruct l2cap_chan *chan;\n\n\t\tmutex_lock(&conn->chan_lock);\n\n\t\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\n\t\t\tBT_DBG(\"chan %p state %s\", chan,\n\t\t\t       state_to_string(chan->state));\n\n\t\t\tif (chan->scid == L2CAP_CID_A2MP)\n\t\t\t\tcontinue;\n\n\t\t\tl2cap_chan_lock(chan);\n\n\t\t\tif (chan->state == BT_CONNECT)\n\t\t\t\tl2cap_send_conn_req(chan);\n\n\t\t\tl2cap_chan_unlock(chan);\n\t\t}\n\n\t\tmutex_unlock(&conn->chan_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int a2mp_change_notify(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t      struct a2mp_cmd *hdr)\n{\n\tstruct a2mp_cl *cl = (void *) skb->data;\n\n\twhile (skb->len >= sizeof(*cl)) {\n\t\tBT_DBG(\"Controller id %u type %u status %u\", cl->id, cl->type,\n\t\t       cl->status);\n\t\tcl = skb_pull(skb, sizeof(*cl));\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic void read_local_amp_info_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t\t u16 opcode)\n{\n\tBT_DBG(\"%s status 0x%2.2x\", hdev->name, status);\n\n\ta2mp_send_getinfo_rsp(hdev);\n}\n\nstatic int a2mp_getinfo_req(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t    struct a2mp_cmd *hdr)\n{\n\tstruct a2mp_info_req *req  = (void *) skb->data;\n\tstruct hci_dev *hdev;\n\tstruct hci_request hreq;\n\tint err = 0;\n\n\tif (le16_to_cpu(hdr->len) < sizeof(*req))\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"id %u\", req->id);\n\n\thdev = hci_dev_get(req->id);\n\tif (!hdev || hdev->dev_type != HCI_AMP) {\n\t\tstruct a2mp_info_rsp rsp;\n\n\t\tmemset(&rsp, 0, sizeof(rsp));\n\n\t\trsp.id = req->id;\n\t\trsp.status = A2MP_STATUS_INVALID_CTRL_ID;\n\n\t\ta2mp_send(mgr, A2MP_GETINFO_RSP, hdr->ident, sizeof(rsp),\n\t\t\t  &rsp);\n\n\t\tgoto done;\n\t}\n\n\tset_bit(READ_LOC_AMP_INFO, &mgr->state);\n\thci_req_init(&hreq, hdev);\n\thci_req_add(&hreq, HCI_OP_READ_LOCAL_AMP_INFO, 0, NULL);\n\terr = hci_req_run(&hreq, read_local_amp_info_complete);\n\tif (err < 0)\n\t\ta2mp_send_getinfo_rsp(hdev);\n\ndone:\n\tif (hdev)\n\t\thci_dev_put(hdev);\n\n\tskb_pull(skb, sizeof(*req));\n\treturn 0;\n}\n\nstatic int a2mp_getinfo_rsp(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t    struct a2mp_cmd *hdr)\n{\n\tstruct a2mp_info_rsp *rsp = (struct a2mp_info_rsp *) skb->data;\n\tstruct a2mp_amp_assoc_req req;\n\tstruct amp_ctrl *ctrl;\n\n\tif (le16_to_cpu(hdr->len) < sizeof(*rsp))\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"id %u status 0x%2.2x\", rsp->id, rsp->status);\n\n\tif (rsp->status)\n\t\treturn -EINVAL;\n\n\tctrl = amp_ctrl_add(mgr, rsp->id);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.id = rsp->id;\n\ta2mp_send(mgr, A2MP_GETAMPASSOC_REQ, __next_ident(mgr), sizeof(req),\n\t\t  &req);\n\n\tskb_pull(skb, sizeof(*rsp));\n\treturn 0;\n}\n\nstatic int a2mp_getampassoc_req(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t\tstruct a2mp_cmd *hdr)\n{\n\tstruct a2mp_amp_assoc_req *req = (void *) skb->data;\n\tstruct hci_dev *hdev;\n\tstruct amp_mgr *tmp;\n\n\tif (le16_to_cpu(hdr->len) < sizeof(*req))\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"id %u\", req->id);\n\n\t \n\ttmp = amp_mgr_lookup_by_state(READ_LOC_AMP_ASSOC);\n\n\thdev = hci_dev_get(req->id);\n\tif (!hdev || hdev->amp_type == AMP_TYPE_BREDR || tmp) {\n\t\tstruct a2mp_amp_assoc_rsp rsp;\n\n\t\tmemset(&rsp, 0, sizeof(rsp));\n\t\trsp.id = req->id;\n\n\t\tif (tmp) {\n\t\t\trsp.status = A2MP_STATUS_COLLISION_OCCURED;\n\t\t\tamp_mgr_put(tmp);\n\t\t} else {\n\t\t\trsp.status = A2MP_STATUS_INVALID_CTRL_ID;\n\t\t}\n\n\t\ta2mp_send(mgr, A2MP_GETAMPASSOC_RSP, hdr->ident, sizeof(rsp),\n\t\t\t  &rsp);\n\n\t\tgoto done;\n\t}\n\n\tamp_read_loc_assoc(hdev, mgr);\n\ndone:\n\tif (hdev)\n\t\thci_dev_put(hdev);\n\n\tskb_pull(skb, sizeof(*req));\n\treturn 0;\n}\n\nstatic int a2mp_getampassoc_rsp(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t\tstruct a2mp_cmd *hdr)\n{\n\tstruct a2mp_amp_assoc_rsp *rsp = (void *) skb->data;\n\tu16 len = le16_to_cpu(hdr->len);\n\tstruct hci_dev *hdev;\n\tstruct amp_ctrl *ctrl;\n\tstruct hci_conn *hcon;\n\tsize_t assoc_len;\n\n\tif (len < sizeof(*rsp))\n\t\treturn -EINVAL;\n\n\tassoc_len = len - sizeof(*rsp);\n\n\tBT_DBG(\"id %u status 0x%2.2x assoc len %zu\", rsp->id, rsp->status,\n\t       assoc_len);\n\n\tif (rsp->status)\n\t\treturn -EINVAL;\n\n\t \n\tctrl = amp_ctrl_lookup(mgr, rsp->id);\n\tif (ctrl) {\n\t\tu8 *assoc;\n\n\t\tassoc = kmemdup(rsp->amp_assoc, assoc_len, GFP_KERNEL);\n\t\tif (!assoc) {\n\t\t\tamp_ctrl_put(ctrl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tctrl->assoc = assoc;\n\t\tctrl->assoc_len = assoc_len;\n\t\tctrl->assoc_rem_len = assoc_len;\n\t\tctrl->assoc_len_so_far = 0;\n\n\t\tamp_ctrl_put(ctrl);\n\t}\n\n\t \n\thdev = hci_dev_get(rsp->id);\n\tif (!hdev)\n\t\treturn -EINVAL;\n\n\thcon = phylink_add(hdev, mgr, rsp->id, true);\n\tif (!hcon)\n\t\tgoto done;\n\n\tBT_DBG(\"Created hcon %p: loc:%u -> rem:%u\", hcon, hdev->id, rsp->id);\n\n\tmgr->bredr_chan->remote_amp_id = rsp->id;\n\n\tamp_create_phylink(hdev, mgr, hcon);\n\ndone:\n\thci_dev_put(hdev);\n\tskb_pull(skb, len);\n\treturn 0;\n}\n\nstatic int a2mp_createphyslink_req(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t\t   struct a2mp_cmd *hdr)\n{\n\tstruct a2mp_physlink_req *req = (void *) skb->data;\n\tstruct a2mp_physlink_rsp rsp;\n\tstruct hci_dev *hdev;\n\tstruct hci_conn *hcon;\n\tstruct amp_ctrl *ctrl;\n\n\tif (le16_to_cpu(hdr->len) < sizeof(*req))\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"local_id %u, remote_id %u\", req->local_id, req->remote_id);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\trsp.local_id = req->remote_id;\n\trsp.remote_id = req->local_id;\n\n\thdev = hci_dev_get(req->remote_id);\n\tif (!hdev || hdev->amp_type == AMP_TYPE_BREDR) {\n\t\trsp.status = A2MP_STATUS_INVALID_CTRL_ID;\n\t\tgoto send_rsp;\n\t}\n\n\tctrl = amp_ctrl_lookup(mgr, rsp.remote_id);\n\tif (!ctrl) {\n\t\tctrl = amp_ctrl_add(mgr, rsp.remote_id);\n\t\tif (ctrl) {\n\t\t\tamp_ctrl_get(ctrl);\n\t\t} else {\n\t\t\trsp.status = A2MP_STATUS_UNABLE_START_LINK_CREATION;\n\t\t\tgoto send_rsp;\n\t\t}\n\t}\n\n\tif (ctrl) {\n\t\tsize_t assoc_len = le16_to_cpu(hdr->len) - sizeof(*req);\n\t\tu8 *assoc;\n\n\t\tassoc = kmemdup(req->amp_assoc, assoc_len, GFP_KERNEL);\n\t\tif (!assoc) {\n\t\t\tamp_ctrl_put(ctrl);\n\t\t\thci_dev_put(hdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tctrl->assoc = assoc;\n\t\tctrl->assoc_len = assoc_len;\n\t\tctrl->assoc_rem_len = assoc_len;\n\t\tctrl->assoc_len_so_far = 0;\n\n\t\tamp_ctrl_put(ctrl);\n\t}\n\n\thcon = phylink_add(hdev, mgr, req->local_id, false);\n\tif (hcon) {\n\t\tamp_accept_phylink(hdev, mgr, hcon);\n\t\trsp.status = A2MP_STATUS_SUCCESS;\n\t} else {\n\t\trsp.status = A2MP_STATUS_UNABLE_START_LINK_CREATION;\n\t}\n\nsend_rsp:\n\tif (hdev)\n\t\thci_dev_put(hdev);\n\n\t \n\tif (rsp.status != A2MP_STATUS_SUCCESS) {\n\t\ta2mp_send(mgr, A2MP_CREATEPHYSLINK_RSP, hdr->ident,\n\t\t\t  sizeof(rsp), &rsp);\n\t} else {\n\t\tset_bit(WRITE_REMOTE_AMP_ASSOC, &mgr->state);\n\t\tmgr->ident = hdr->ident;\n\t}\n\n\tskb_pull(skb, le16_to_cpu(hdr->len));\n\treturn 0;\n}\n\nstatic int a2mp_discphyslink_req(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t\t struct a2mp_cmd *hdr)\n{\n\tstruct a2mp_physlink_req *req = (void *) skb->data;\n\tstruct a2mp_physlink_rsp rsp;\n\tstruct hci_dev *hdev;\n\tstruct hci_conn *hcon;\n\n\tif (le16_to_cpu(hdr->len) < sizeof(*req))\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"local_id %u remote_id %u\", req->local_id, req->remote_id);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\trsp.local_id = req->remote_id;\n\trsp.remote_id = req->local_id;\n\trsp.status = A2MP_STATUS_SUCCESS;\n\n\thdev = hci_dev_get(req->remote_id);\n\tif (!hdev) {\n\t\trsp.status = A2MP_STATUS_INVALID_CTRL_ID;\n\t\tgoto send_rsp;\n\t}\n\n\thcon = hci_conn_hash_lookup_ba(hdev, AMP_LINK,\n\t\t\t\t       &mgr->l2cap_conn->hcon->dst);\n\tif (!hcon) {\n\t\tbt_dev_err(hdev, \"no phys link exist\");\n\t\trsp.status = A2MP_STATUS_NO_PHYSICAL_LINK_EXISTS;\n\t\tgoto clean;\n\t}\n\n\t \n\nclean:\n\thci_dev_put(hdev);\n\nsend_rsp:\n\ta2mp_send(mgr, A2MP_DISCONNPHYSLINK_RSP, hdr->ident, sizeof(rsp), &rsp);\n\n\tskb_pull(skb, sizeof(*req));\n\treturn 0;\n}\n\nstatic inline int a2mp_cmd_rsp(struct amp_mgr *mgr, struct sk_buff *skb,\n\t\t\t       struct a2mp_cmd *hdr)\n{\n\tBT_DBG(\"ident %u code 0x%2.2x\", hdr->ident, hdr->code);\n\n\tskb_pull(skb, le16_to_cpu(hdr->len));\n\treturn 0;\n}\n\n \nstatic int a2mp_chan_recv_cb(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct a2mp_cmd *hdr;\n\tstruct amp_mgr *mgr = chan->data;\n\tint err = 0;\n\n\tamp_mgr_get(mgr);\n\n\twhile (skb->len >= sizeof(*hdr)) {\n\t\tu16 len;\n\n\t\thdr = (void *) skb->data;\n\t\tlen = le16_to_cpu(hdr->len);\n\n\t\tBT_DBG(\"code 0x%2.2x id %u len %u\", hdr->code, hdr->ident, len);\n\n\t\tskb_pull(skb, sizeof(*hdr));\n\n\t\tif (len > skb->len || !hdr->ident) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmgr->ident = hdr->ident;\n\n\t\tswitch (hdr->code) {\n\t\tcase A2MP_COMMAND_REJ:\n\t\t\ta2mp_command_rej(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tcase A2MP_DISCOVER_REQ:\n\t\t\terr = a2mp_discover_req(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tcase A2MP_CHANGE_NOTIFY:\n\t\t\terr = a2mp_change_notify(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tcase A2MP_GETINFO_REQ:\n\t\t\terr = a2mp_getinfo_req(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tcase A2MP_GETAMPASSOC_REQ:\n\t\t\terr = a2mp_getampassoc_req(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tcase A2MP_CREATEPHYSLINK_REQ:\n\t\t\terr = a2mp_createphyslink_req(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tcase A2MP_DISCONNPHYSLINK_REQ:\n\t\t\terr = a2mp_discphyslink_req(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tcase A2MP_DISCOVER_RSP:\n\t\t\terr = a2mp_discover_rsp(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tcase A2MP_GETINFO_RSP:\n\t\t\terr = a2mp_getinfo_rsp(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tcase A2MP_GETAMPASSOC_RSP:\n\t\t\terr = a2mp_getampassoc_rsp(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tcase A2MP_CHANGE_RSP:\n\t\tcase A2MP_CREATEPHYSLINK_RSP:\n\t\tcase A2MP_DISCONNPHYSLINK_RSP:\n\t\t\terr = a2mp_cmd_rsp(mgr, skb, hdr);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBT_ERR(\"Unknown A2MP sig cmd 0x%2.2x\", hdr->code);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (err) {\n\t\tstruct a2mp_cmd_rej rej;\n\n\t\tmemset(&rej, 0, sizeof(rej));\n\n\t\trej.reason = cpu_to_le16(0);\n\t\thdr = (void *) skb->data;\n\n\t\tBT_DBG(\"Send A2MP Rej: cmd 0x%2.2x err %d\", hdr->code, err);\n\n\t\ta2mp_send(mgr, A2MP_COMMAND_REJ, hdr->ident, sizeof(rej),\n\t\t\t  &rej);\n\t}\n\n\t \n\tkfree_skb(skb);\n\n\tamp_mgr_put(mgr);\n\n\treturn 0;\n}\n\nstatic void a2mp_chan_close_cb(struct l2cap_chan *chan)\n{\n\tl2cap_chan_put(chan);\n}\n\nstatic void a2mp_chan_state_change_cb(struct l2cap_chan *chan, int state,\n\t\t\t\t      int err)\n{\n\tstruct amp_mgr *mgr = chan->data;\n\n\tif (!mgr)\n\t\treturn;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(state));\n\n\tchan->state = state;\n\n\tswitch (state) {\n\tcase BT_CLOSED:\n\t\tif (mgr)\n\t\t\tamp_mgr_put(mgr);\n\t\tbreak;\n\t}\n}\n\nstatic struct sk_buff *a2mp_chan_alloc_skb_cb(struct l2cap_chan *chan,\n\t\t\t\t\t      unsigned long hdr_len,\n\t\t\t\t\t      unsigned long len, int nb)\n{\n\tstruct sk_buff *skb;\n\n\tskb = bt_skb_alloc(hdr_len + len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn skb;\n}\n\nstatic const struct l2cap_ops a2mp_chan_ops = {\n\t.name = \"L2CAP A2MP channel\",\n\t.recv = a2mp_chan_recv_cb,\n\t.close = a2mp_chan_close_cb,\n\t.state_change = a2mp_chan_state_change_cb,\n\t.alloc_skb = a2mp_chan_alloc_skb_cb,\n\n\t \n\t.new_connection = l2cap_chan_no_new_connection,\n\t.teardown = l2cap_chan_no_teardown,\n\t.ready = l2cap_chan_no_ready,\n\t.defer = l2cap_chan_no_defer,\n\t.resume = l2cap_chan_no_resume,\n\t.set_shutdown = l2cap_chan_no_set_shutdown,\n\t.get_sndtimeo = l2cap_chan_no_get_sndtimeo,\n};\n\nstatic struct l2cap_chan *a2mp_chan_open(struct l2cap_conn *conn, bool locked)\n{\n\tstruct l2cap_chan *chan;\n\tint err;\n\n\tchan = l2cap_chan_create();\n\tif (!chan)\n\t\treturn NULL;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tchan->chan_type = L2CAP_CHAN_FIXED;\n\tchan->scid = L2CAP_CID_A2MP;\n\tchan->dcid = L2CAP_CID_A2MP;\n\tchan->omtu = L2CAP_A2MP_DEFAULT_MTU;\n\tchan->imtu = L2CAP_A2MP_DEFAULT_MTU;\n\tchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n\n\tchan->ops = &a2mp_chan_ops;\n\n\tl2cap_chan_set_defaults(chan);\n\tchan->remote_max_tx = chan->max_tx;\n\tchan->remote_tx_win = chan->tx_win;\n\n\tchan->retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\n\tchan->monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\n\n\tskb_queue_head_init(&chan->tx_q);\n\n\tchan->mode = L2CAP_MODE_ERTM;\n\n\terr = l2cap_ertm_init(chan);\n\tif (err < 0) {\n\t\tl2cap_chan_del(chan, 0);\n\t\treturn NULL;\n\t}\n\n\tchan->conf_state = 0;\n\n\tif (locked)\n\t\t__l2cap_chan_add(conn, chan);\n\telse\n\t\tl2cap_chan_add(conn, chan);\n\n\tchan->remote_mps = chan->omtu;\n\tchan->mps = chan->omtu;\n\n\tchan->state = BT_CONNECTED;\n\n\treturn chan;\n}\n\n \nstruct amp_mgr *amp_mgr_get(struct amp_mgr *mgr)\n{\n\tBT_DBG(\"mgr %p orig refcnt %d\", mgr, kref_read(&mgr->kref));\n\n\tkref_get(&mgr->kref);\n\n\treturn mgr;\n}\n\nstatic void amp_mgr_destroy(struct kref *kref)\n{\n\tstruct amp_mgr *mgr = container_of(kref, struct amp_mgr, kref);\n\n\tBT_DBG(\"mgr %p\", mgr);\n\n\tmutex_lock(&amp_mgr_list_lock);\n\tlist_del(&mgr->list);\n\tmutex_unlock(&amp_mgr_list_lock);\n\n\tamp_ctrl_list_flush(mgr);\n\tkfree(mgr);\n}\n\nint amp_mgr_put(struct amp_mgr *mgr)\n{\n\tBT_DBG(\"mgr %p orig refcnt %d\", mgr, kref_read(&mgr->kref));\n\n\treturn kref_put(&mgr->kref, &amp_mgr_destroy);\n}\n\nstatic struct amp_mgr *amp_mgr_create(struct l2cap_conn *conn, bool locked)\n{\n\tstruct amp_mgr *mgr;\n\tstruct l2cap_chan *chan;\n\n\tmgr = kzalloc(sizeof(*mgr), GFP_KERNEL);\n\tif (!mgr)\n\t\treturn NULL;\n\n\tBT_DBG(\"conn %p mgr %p\", conn, mgr);\n\n\tmgr->l2cap_conn = conn;\n\n\tchan = a2mp_chan_open(conn, locked);\n\tif (!chan) {\n\t\tkfree(mgr);\n\t\treturn NULL;\n\t}\n\n\tmgr->a2mp_chan = chan;\n\tchan->data = mgr;\n\n\tconn->hcon->amp_mgr = mgr;\n\n\tkref_init(&mgr->kref);\n\n\t \n\tINIT_LIST_HEAD(&mgr->amp_ctrls);\n\tmutex_init(&mgr->amp_ctrls_lock);\n\n\tmutex_lock(&amp_mgr_list_lock);\n\tlist_add(&mgr->list, &amp_mgr_list);\n\tmutex_unlock(&amp_mgr_list_lock);\n\n\treturn mgr;\n}\n\nstruct l2cap_chan *a2mp_channel_create(struct l2cap_conn *conn,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct amp_mgr *mgr;\n\n\tif (conn->hcon->type != ACL_LINK)\n\t\treturn NULL;\n\n\tmgr = amp_mgr_create(conn, false);\n\tif (!mgr) {\n\t\tBT_ERR(\"Could not create AMP manager\");\n\t\treturn NULL;\n\t}\n\n\tBT_DBG(\"mgr: %p chan %p\", mgr, mgr->a2mp_chan);\n\n\treturn mgr->a2mp_chan;\n}\n\nvoid a2mp_send_getinfo_rsp(struct hci_dev *hdev)\n{\n\tstruct amp_mgr *mgr;\n\tstruct a2mp_info_rsp rsp;\n\n\tmgr = amp_mgr_lookup_by_state(READ_LOC_AMP_INFO);\n\tif (!mgr)\n\t\treturn;\n\n\tBT_DBG(\"%s mgr %p\", hdev->name, mgr);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\trsp.id = hdev->id;\n\trsp.status = A2MP_STATUS_INVALID_CTRL_ID;\n\n\tif (hdev->amp_type != AMP_TYPE_BREDR) {\n\t\trsp.status = 0;\n\t\trsp.total_bw = cpu_to_le32(hdev->amp_total_bw);\n\t\trsp.max_bw = cpu_to_le32(hdev->amp_max_bw);\n\t\trsp.min_latency = cpu_to_le32(hdev->amp_min_latency);\n\t\trsp.pal_cap = cpu_to_le16(hdev->amp_pal_cap);\n\t\trsp.assoc_size = cpu_to_le16(hdev->amp_assoc_size);\n\t}\n\n\ta2mp_send(mgr, A2MP_GETINFO_RSP, mgr->ident, sizeof(rsp), &rsp);\n\tamp_mgr_put(mgr);\n}\n\nvoid a2mp_send_getampassoc_rsp(struct hci_dev *hdev, u8 status)\n{\n\tstruct amp_mgr *mgr;\n\tstruct amp_assoc *loc_assoc = &hdev->loc_assoc;\n\tstruct a2mp_amp_assoc_rsp *rsp;\n\tsize_t len;\n\n\tmgr = amp_mgr_lookup_by_state(READ_LOC_AMP_ASSOC);\n\tif (!mgr)\n\t\treturn;\n\n\tBT_DBG(\"%s mgr %p\", hdev->name, mgr);\n\n\tlen = sizeof(struct a2mp_amp_assoc_rsp) + loc_assoc->len;\n\trsp = kzalloc(len, GFP_KERNEL);\n\tif (!rsp) {\n\t\tamp_mgr_put(mgr);\n\t\treturn;\n\t}\n\n\trsp->id = hdev->id;\n\n\tif (status) {\n\t\trsp->status = A2MP_STATUS_INVALID_CTRL_ID;\n\t} else {\n\t\trsp->status = A2MP_STATUS_SUCCESS;\n\t\tmemcpy(rsp->amp_assoc, loc_assoc->data, loc_assoc->len);\n\t}\n\n\ta2mp_send(mgr, A2MP_GETAMPASSOC_RSP, mgr->ident, len, rsp);\n\tamp_mgr_put(mgr);\n\tkfree(rsp);\n}\n\nvoid a2mp_send_create_phy_link_req(struct hci_dev *hdev, u8 status)\n{\n\tstruct amp_mgr *mgr;\n\tstruct amp_assoc *loc_assoc = &hdev->loc_assoc;\n\tstruct a2mp_physlink_req *req;\n\tstruct l2cap_chan *bredr_chan;\n\tsize_t len;\n\n\tmgr = amp_mgr_lookup_by_state(READ_LOC_AMP_ASSOC_FINAL);\n\tif (!mgr)\n\t\treturn;\n\n\tlen = sizeof(*req) + loc_assoc->len;\n\n\tBT_DBG(\"%s mgr %p assoc_len %zu\", hdev->name, mgr, len);\n\n\treq = kzalloc(len, GFP_KERNEL);\n\tif (!req) {\n\t\tamp_mgr_put(mgr);\n\t\treturn;\n\t}\n\n\tbredr_chan = mgr->bredr_chan;\n\tif (!bredr_chan)\n\t\tgoto clean;\n\n\treq->local_id = hdev->id;\n\treq->remote_id = bredr_chan->remote_amp_id;\n\tmemcpy(req->amp_assoc, loc_assoc->data, loc_assoc->len);\n\n\ta2mp_send(mgr, A2MP_CREATEPHYSLINK_REQ, __next_ident(mgr), len, req);\n\nclean:\n\tamp_mgr_put(mgr);\n\tkfree(req);\n}\n\nvoid a2mp_send_create_phy_link_rsp(struct hci_dev *hdev, u8 status)\n{\n\tstruct amp_mgr *mgr;\n\tstruct a2mp_physlink_rsp rsp;\n\tstruct hci_conn *hs_hcon;\n\n\tmgr = amp_mgr_lookup_by_state(WRITE_REMOTE_AMP_ASSOC);\n\tif (!mgr)\n\t\treturn;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\ths_hcon = hci_conn_hash_lookup_state(hdev, AMP_LINK, BT_CONNECT);\n\tif (!hs_hcon) {\n\t\trsp.status = A2MP_STATUS_UNABLE_START_LINK_CREATION;\n\t} else {\n\t\trsp.remote_id = hs_hcon->remote_id;\n\t\trsp.status = A2MP_STATUS_SUCCESS;\n\t}\n\n\tBT_DBG(\"%s mgr %p hs_hcon %p status %u\", hdev->name, mgr, hs_hcon,\n\t       status);\n\n\trsp.local_id = hdev->id;\n\ta2mp_send(mgr, A2MP_CREATEPHYSLINK_RSP, mgr->ident, sizeof(rsp), &rsp);\n\tamp_mgr_put(mgr);\n}\n\nvoid a2mp_discover_amp(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct amp_mgr *mgr = conn->hcon->amp_mgr;\n\tstruct a2mp_discov_req req;\n\n\tBT_DBG(\"chan %p conn %p mgr %p\", chan, conn, mgr);\n\n\tif (!mgr) {\n\t\tmgr = amp_mgr_create(conn, true);\n\t\tif (!mgr)\n\t\t\treturn;\n\t}\n\n\tmgr->bredr_chan = chan;\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.mtu = cpu_to_le16(L2CAP_A2MP_DEFAULT_MTU);\n\treq.ext_feat = 0;\n\ta2mp_send(mgr, A2MP_DISCOVER_REQ, 1, sizeof(req), &req);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}