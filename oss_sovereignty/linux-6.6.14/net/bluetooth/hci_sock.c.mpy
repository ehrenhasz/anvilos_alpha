{
  "module_name": "hci_sock.c",
  "hash_id": "462903efe08126dbd05bde7c38d84b192283f58a2c3b3e38353bb9605a854da2",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/hci_sock.c",
  "human_readable_source": " \n\n \n#include <linux/compat.h>\n#include <linux/export.h>\n#include <linux/utsname.h>\n#include <linux/sched.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/hci_mon.h>\n#include <net/bluetooth/mgmt.h>\n\n#include \"mgmt_util.h\"\n\nstatic LIST_HEAD(mgmt_chan_list);\nstatic DEFINE_MUTEX(mgmt_chan_list_lock);\n\nstatic DEFINE_IDA(sock_cookie_ida);\n\nstatic atomic_t monitor_promisc = ATOMIC_INIT(0);\n\n \n\n \n#define hci_pi(sk) ((struct hci_pinfo *) sk)\n\nstruct hci_pinfo {\n\tstruct bt_sock    bt;\n\tstruct hci_dev    *hdev;\n\tstruct hci_filter filter;\n\t__u8              cmsg_mask;\n\tunsigned short    channel;\n\tunsigned long     flags;\n\t__u32             cookie;\n\tchar              comm[TASK_COMM_LEN];\n\t__u16             mtu;\n};\n\nstatic struct hci_dev *hci_hdev_from_sock(struct sock *sk)\n{\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\n\tif (!hdev)\n\t\treturn ERR_PTR(-EBADFD);\n\tif (hci_dev_test_flag(hdev, HCI_UNREGISTER))\n\t\treturn ERR_PTR(-EPIPE);\n\treturn hdev;\n}\n\nvoid hci_sock_set_flag(struct sock *sk, int nr)\n{\n\tset_bit(nr, &hci_pi(sk)->flags);\n}\n\nvoid hci_sock_clear_flag(struct sock *sk, int nr)\n{\n\tclear_bit(nr, &hci_pi(sk)->flags);\n}\n\nint hci_sock_test_flag(struct sock *sk, int nr)\n{\n\treturn test_bit(nr, &hci_pi(sk)->flags);\n}\n\nunsigned short hci_sock_get_channel(struct sock *sk)\n{\n\treturn hci_pi(sk)->channel;\n}\n\nu32 hci_sock_get_cookie(struct sock *sk)\n{\n\treturn hci_pi(sk)->cookie;\n}\n\nstatic bool hci_sock_gen_cookie(struct sock *sk)\n{\n\tint id = hci_pi(sk)->cookie;\n\n\tif (!id) {\n\t\tid = ida_simple_get(&sock_cookie_ida, 1, 0, GFP_KERNEL);\n\t\tif (id < 0)\n\t\t\tid = 0xffffffff;\n\n\t\thci_pi(sk)->cookie = id;\n\t\tget_task_comm(hci_pi(sk)->comm, current);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void hci_sock_free_cookie(struct sock *sk)\n{\n\tint id = hci_pi(sk)->cookie;\n\n\tif (id) {\n\t\thci_pi(sk)->cookie = 0xffffffff;\n\t\tida_simple_remove(&sock_cookie_ida, id);\n\t}\n}\n\nstatic inline int hci_test_bit(int nr, const void *addr)\n{\n\treturn *((const __u32 *) addr + (nr >> 5)) & ((__u32) 1 << (nr & 31));\n}\n\n \n#define HCI_SFLT_MAX_OGF  5\n\nstruct hci_sec_filter {\n\t__u32 type_mask;\n\t__u32 event_mask[2];\n\t__u32 ocf_mask[HCI_SFLT_MAX_OGF + 1][4];\n};\n\nstatic const struct hci_sec_filter hci_sec_filter = {\n\t \n\t0x10,\n\t \n\t{ 0x1000d9fe, 0x0000b00c },\n\t \n\t{\n\t\t{ 0x0 },\n\t\t \n\t\t{ 0xbe000006, 0x00000001, 0x00000000, 0x00 },\n\t\t \n\t\t{ 0x00005200, 0x00000000, 0x00000000, 0x00 },\n\t\t \n\t\t{ 0xaab00200, 0x2b402aaa, 0x05220154, 0x00 },\n\t\t \n\t\t{ 0x000002be, 0x00000000, 0x00000000, 0x00 },\n\t\t \n\t\t{ 0x000000ea, 0x00000000, 0x00000000, 0x00 }\n\t}\n};\n\nstatic struct bt_sock_list hci_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(hci_sk_list.lock)\n};\n\nstatic bool is_filtered_packet(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct hci_filter *flt;\n\tint flt_type, flt_event;\n\n\t \n\tflt = &hci_pi(sk)->filter;\n\n\tflt_type = hci_skb_pkt_type(skb) & HCI_FLT_TYPE_BITS;\n\n\tif (!test_bit(flt_type, &flt->type_mask))\n\t\treturn true;\n\n\t \n\tif (hci_skb_pkt_type(skb) != HCI_EVENT_PKT)\n\t\treturn false;\n\n\tflt_event = (*(__u8 *)skb->data & HCI_FLT_EVENT_BITS);\n\n\tif (!hci_test_bit(flt_event, &flt->event_mask))\n\t\treturn true;\n\n\t \n\tif (!flt->opcode)\n\t\treturn false;\n\n\tif (flt_event == HCI_EV_CMD_COMPLETE &&\n\t    flt->opcode != get_unaligned((__le16 *)(skb->data + 3)))\n\t\treturn true;\n\n\tif (flt_event == HCI_EV_CMD_STATUS &&\n\t    flt->opcode != get_unaligned((__le16 *)(skb->data + 4)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nvoid hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct sk_buff *skb_copy = NULL;\n\n\tBT_DBG(\"hdev %p len %d\", hdev, skb->len);\n\n\tread_lock(&hci_sk_list.lock);\n\n\tsk_for_each(sk, &hci_sk_list.head) {\n\t\tstruct sk_buff *nskb;\n\n\t\tif (sk->sk_state != BT_BOUND || hci_pi(sk)->hdev != hdev)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (skb->sk == sk)\n\t\t\tcontinue;\n\n\t\tif (hci_pi(sk)->channel == HCI_CHANNEL_RAW) {\n\t\t\tif (hci_skb_pkt_type(skb) != HCI_COMMAND_PKT &&\n\t\t\t    hci_skb_pkt_type(skb) != HCI_EVENT_PKT &&\n\t\t\t    hci_skb_pkt_type(skb) != HCI_ACLDATA_PKT &&\n\t\t\t    hci_skb_pkt_type(skb) != HCI_SCODATA_PKT &&\n\t\t\t    hci_skb_pkt_type(skb) != HCI_ISODATA_PKT)\n\t\t\t\tcontinue;\n\t\t\tif (is_filtered_packet(sk, skb))\n\t\t\t\tcontinue;\n\t\t} else if (hci_pi(sk)->channel == HCI_CHANNEL_USER) {\n\t\t\tif (!bt_cb(skb)->incoming)\n\t\t\t\tcontinue;\n\t\t\tif (hci_skb_pkt_type(skb) != HCI_EVENT_PKT &&\n\t\t\t    hci_skb_pkt_type(skb) != HCI_ACLDATA_PKT &&\n\t\t\t    hci_skb_pkt_type(skb) != HCI_SCODATA_PKT &&\n\t\t\t    hci_skb_pkt_type(skb) != HCI_ISODATA_PKT)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!skb_copy) {\n\t\t\t \n\t\t\tskb_copy = __pskb_copy_fclone(skb, 1, GFP_ATOMIC, true);\n\t\t\tif (!skb_copy)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tmemcpy(skb_push(skb_copy, 1), &hci_skb_pkt_type(skb), 1);\n\t\t}\n\n\t\tnskb = skb_clone(skb_copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tread_unlock(&hci_sk_list.lock);\n\n\tkfree_skb(skb_copy);\n}\n\nstatic void hci_sock_copy_creds(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct scm_creds *creds;\n\n\tif (!sk || WARN_ON(!skb))\n\t\treturn;\n\n\tcreds = &bt_cb(skb)->creds;\n\n\t \n\tif (!sk->sk_peer_pid) {\n\t\t \n\t\tif (bt_sk(sk)->parent && bt_sk(sk)->parent->sk_peer_pid)\n\t\t\tsk = bt_sk(sk)->parent;\n\t\telse\n\t\t\treturn;\n\t}\n\n\t \n\tif (creds->pid == pid_vnr(sk->sk_peer_pid))\n\t\treturn;\n\n\tmemset(creds, 0, sizeof(*creds));\n\n\tcreds->pid = pid_vnr(sk->sk_peer_pid);\n\tif (sk->sk_peer_cred) {\n\t\tcreds->uid = sk->sk_peer_cred->uid;\n\t\tcreds->gid = sk->sk_peer_cred->gid;\n\t}\n}\n\nstatic struct sk_buff *hci_skb_clone(struct sk_buff *skb)\n{\n\tstruct sk_buff *nskb;\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn NULL;\n\n\thci_sock_copy_creds(skb->sk, nskb);\n\n\treturn nskb;\n}\n\n \nstatic void __hci_send_to_channel(unsigned short channel, struct sk_buff *skb,\n\t\t\t\t  int flag, struct sock *skip_sk)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"channel %u len %d\", channel, skb->len);\n\n\tsk_for_each(sk, &hci_sk_list.head) {\n\t\tstruct sk_buff *nskb;\n\n\t\t \n\t\tif (!hci_sock_test_flag(sk, flag))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sk == skip_sk)\n\t\t\tcontinue;\n\n\t\tif (sk->sk_state != BT_BOUND)\n\t\t\tcontinue;\n\n\t\tif (hci_pi(sk)->channel != channel)\n\t\t\tcontinue;\n\n\t\tnskb = hci_skb_clone(skb);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n}\n\nvoid hci_send_to_channel(unsigned short channel, struct sk_buff *skb,\n\t\t\t int flag, struct sock *skip_sk)\n{\n\tread_lock(&hci_sk_list.lock);\n\t__hci_send_to_channel(channel, skb, flag, skip_sk);\n\tread_unlock(&hci_sk_list.lock);\n}\n\n \nvoid hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct sk_buff *skb_copy = NULL;\n\tstruct hci_mon_hdr *hdr;\n\t__le16 opcode;\n\n\tif (!atomic_read(&monitor_promisc))\n\t\treturn;\n\n\tBT_DBG(\"hdev %p len %d\", hdev, skb->len);\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\topcode = cpu_to_le16(HCI_MON_COMMAND_PKT);\n\t\tbreak;\n\tcase HCI_EVENT_PKT:\n\t\topcode = cpu_to_le16(HCI_MON_EVENT_PKT);\n\t\tbreak;\n\tcase HCI_ACLDATA_PKT:\n\t\tif (bt_cb(skb)->incoming)\n\t\t\topcode = cpu_to_le16(HCI_MON_ACL_RX_PKT);\n\t\telse\n\t\t\topcode = cpu_to_le16(HCI_MON_ACL_TX_PKT);\n\t\tbreak;\n\tcase HCI_SCODATA_PKT:\n\t\tif (bt_cb(skb)->incoming)\n\t\t\topcode = cpu_to_le16(HCI_MON_SCO_RX_PKT);\n\t\telse\n\t\t\topcode = cpu_to_le16(HCI_MON_SCO_TX_PKT);\n\t\tbreak;\n\tcase HCI_ISODATA_PKT:\n\t\tif (bt_cb(skb)->incoming)\n\t\t\topcode = cpu_to_le16(HCI_MON_ISO_RX_PKT);\n\t\telse\n\t\t\topcode = cpu_to_le16(HCI_MON_ISO_TX_PKT);\n\t\tbreak;\n\tcase HCI_DIAG_PKT:\n\t\topcode = cpu_to_le16(HCI_MON_VENDOR_DIAG);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tskb_copy = __pskb_copy_fclone(skb, HCI_MON_HDR_SIZE, GFP_ATOMIC, true);\n\tif (!skb_copy)\n\t\treturn;\n\n\thci_sock_copy_creds(skb->sk, skb_copy);\n\n\t \n\thdr = skb_push(skb_copy, HCI_MON_HDR_SIZE);\n\thdr->opcode = opcode;\n\thdr->index = cpu_to_le16(hdev->id);\n\thdr->len = cpu_to_le16(skb->len);\n\n\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb_copy,\n\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\tkfree_skb(skb_copy);\n}\n\nvoid hci_send_monitor_ctrl_event(struct hci_dev *hdev, u16 event,\n\t\t\t\t void *data, u16 data_len, ktime_t tstamp,\n\t\t\t\t int flag, struct sock *skip_sk)\n{\n\tstruct sock *sk;\n\t__le16 index;\n\n\tif (hdev)\n\t\tindex = cpu_to_le16(hdev->id);\n\telse\n\t\tindex = cpu_to_le16(MGMT_INDEX_NONE);\n\n\tread_lock(&hci_sk_list.lock);\n\n\tsk_for_each(sk, &hci_sk_list.head) {\n\t\tstruct hci_mon_hdr *hdr;\n\t\tstruct sk_buff *skb;\n\n\t\tif (hci_pi(sk)->channel != HCI_CHANNEL_CONTROL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!hci_sock_test_flag(sk, flag))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sk == skip_sk)\n\t\t\tcontinue;\n\n\t\tskb = bt_skb_alloc(6 + data_len, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tput_unaligned_le32(hci_pi(sk)->cookie, skb_put(skb, 4));\n\t\tput_unaligned_le16(event, skb_put(skb, 2));\n\n\t\tif (data)\n\t\t\tskb_put_data(skb, data, data_len);\n\n\t\tskb->tstamp = tstamp;\n\n\t\thdr = skb_push(skb, HCI_MON_HDR_SIZE);\n\t\thdr->opcode = cpu_to_le16(HCI_MON_CTRL_EVENT);\n\t\thdr->index = index;\n\t\thdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);\n\n\t\t__hci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n\t\t\t\t      HCI_SOCK_TRUSTED, NULL);\n\t\tkfree_skb(skb);\n\t}\n\n\tread_unlock(&hci_sk_list.lock);\n}\n\nstatic struct sk_buff *create_monitor_event(struct hci_dev *hdev, int event)\n{\n\tstruct hci_mon_hdr *hdr;\n\tstruct hci_mon_new_index *ni;\n\tstruct hci_mon_index_info *ii;\n\tstruct sk_buff *skb;\n\t__le16 opcode;\n\n\tswitch (event) {\n\tcase HCI_DEV_REG:\n\t\tskb = bt_skb_alloc(HCI_MON_NEW_INDEX_SIZE, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\tni = skb_put(skb, HCI_MON_NEW_INDEX_SIZE);\n\t\tni->type = hdev->dev_type;\n\t\tni->bus = hdev->bus;\n\t\tbacpy(&ni->bdaddr, &hdev->bdaddr);\n\t\tmemcpy_and_pad(ni->name, sizeof(ni->name), hdev->name,\n\t\t\t       strnlen(hdev->name, sizeof(ni->name)), '\\0');\n\n\t\topcode = cpu_to_le16(HCI_MON_NEW_INDEX);\n\t\tbreak;\n\n\tcase HCI_DEV_UNREG:\n\t\tskb = bt_skb_alloc(0, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\topcode = cpu_to_le16(HCI_MON_DEL_INDEX);\n\t\tbreak;\n\n\tcase HCI_DEV_SETUP:\n\t\tif (hdev->manufacturer == 0xffff)\n\t\t\treturn NULL;\n\t\tfallthrough;\n\n\tcase HCI_DEV_UP:\n\t\tskb = bt_skb_alloc(HCI_MON_INDEX_INFO_SIZE, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\tii = skb_put(skb, HCI_MON_INDEX_INFO_SIZE);\n\t\tbacpy(&ii->bdaddr, &hdev->bdaddr);\n\t\tii->manufacturer = cpu_to_le16(hdev->manufacturer);\n\n\t\topcode = cpu_to_le16(HCI_MON_INDEX_INFO);\n\t\tbreak;\n\n\tcase HCI_DEV_OPEN:\n\t\tskb = bt_skb_alloc(0, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\topcode = cpu_to_le16(HCI_MON_OPEN_INDEX);\n\t\tbreak;\n\n\tcase HCI_DEV_CLOSE:\n\t\tskb = bt_skb_alloc(0, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\topcode = cpu_to_le16(HCI_MON_CLOSE_INDEX);\n\t\tbreak;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t__net_timestamp(skb);\n\n\thdr = skb_push(skb, HCI_MON_HDR_SIZE);\n\thdr->opcode = opcode;\n\thdr->index = cpu_to_le16(hdev->id);\n\thdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *create_monitor_ctrl_open(struct sock *sk)\n{\n\tstruct hci_mon_hdr *hdr;\n\tstruct sk_buff *skb;\n\tu16 format;\n\tu8 ver[3];\n\tu32 flags;\n\n\t \n\tif (!hci_pi(sk)->cookie)\n\t\treturn NULL;\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\tformat = 0x0000;\n\t\tver[0] = BT_SUBSYS_VERSION;\n\t\tput_unaligned_le16(BT_SUBSYS_REVISION, ver + 1);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\t\tformat = 0x0001;\n\t\tver[0] = BT_SUBSYS_VERSION;\n\t\tput_unaligned_le16(BT_SUBSYS_REVISION, ver + 1);\n\t\tbreak;\n\tcase HCI_CHANNEL_CONTROL:\n\t\tformat = 0x0002;\n\t\tmgmt_fill_version_info(ver);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn NULL;\n\t}\n\n\tskb = bt_skb_alloc(14 + TASK_COMM_LEN, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\thci_sock_copy_creds(sk, skb);\n\n\tflags = hci_sock_test_flag(sk, HCI_SOCK_TRUSTED) ? 0x1 : 0x0;\n\n\tput_unaligned_le32(hci_pi(sk)->cookie, skb_put(skb, 4));\n\tput_unaligned_le16(format, skb_put(skb, 2));\n\tskb_put_data(skb, ver, sizeof(ver));\n\tput_unaligned_le32(flags, skb_put(skb, 4));\n\tskb_put_u8(skb, TASK_COMM_LEN);\n\tskb_put_data(skb, hci_pi(sk)->comm, TASK_COMM_LEN);\n\n\t__net_timestamp(skb);\n\n\thdr = skb_push(skb, HCI_MON_HDR_SIZE);\n\thdr->opcode = cpu_to_le16(HCI_MON_CTRL_OPEN);\n\tif (hci_pi(sk)->hdev)\n\t\thdr->index = cpu_to_le16(hci_pi(sk)->hdev->id);\n\telse\n\t\thdr->index = cpu_to_le16(HCI_DEV_NONE);\n\thdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *create_monitor_ctrl_close(struct sock *sk)\n{\n\tstruct hci_mon_hdr *hdr;\n\tstruct sk_buff *skb;\n\n\t \n\tif (!hci_pi(sk)->cookie)\n\t\treturn NULL;\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn NULL;\n\t}\n\n\tskb = bt_skb_alloc(4, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\thci_sock_copy_creds(sk, skb);\n\n\tput_unaligned_le32(hci_pi(sk)->cookie, skb_put(skb, 4));\n\n\t__net_timestamp(skb);\n\n\thdr = skb_push(skb, HCI_MON_HDR_SIZE);\n\thdr->opcode = cpu_to_le16(HCI_MON_CTRL_CLOSE);\n\tif (hci_pi(sk)->hdev)\n\t\thdr->index = cpu_to_le16(hci_pi(sk)->hdev->id);\n\telse\n\t\thdr->index = cpu_to_le16(HCI_DEV_NONE);\n\thdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *create_monitor_ctrl_command(struct sock *sk, u16 index,\n\t\t\t\t\t\t   u16 opcode, u16 len,\n\t\t\t\t\t\t   const void *buf)\n{\n\tstruct hci_mon_hdr *hdr;\n\tstruct sk_buff *skb;\n\n\tskb = bt_skb_alloc(6 + len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\thci_sock_copy_creds(sk, skb);\n\n\tput_unaligned_le32(hci_pi(sk)->cookie, skb_put(skb, 4));\n\tput_unaligned_le16(opcode, skb_put(skb, 2));\n\n\tif (buf)\n\t\tskb_put_data(skb, buf, len);\n\n\t__net_timestamp(skb);\n\n\thdr = skb_push(skb, HCI_MON_HDR_SIZE);\n\thdr->opcode = cpu_to_le16(HCI_MON_CTRL_COMMAND);\n\thdr->index = cpu_to_le16(index);\n\thdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);\n\n\treturn skb;\n}\n\nstatic void __printf(2, 3)\nsend_monitor_note(struct sock *sk, const char *fmt, ...)\n{\n\tsize_t len;\n\tstruct hci_mon_hdr *hdr;\n\tstruct sk_buff *skb;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tlen = vsnprintf(NULL, 0, fmt, args);\n\tva_end(args);\n\n\tskb = bt_skb_alloc(len + 1, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\thci_sock_copy_creds(sk, skb);\n\n\tva_start(args, fmt);\n\tvsprintf(skb_put(skb, len), fmt, args);\n\t*(u8 *)skb_put(skb, 1) = 0;\n\tva_end(args);\n\n\t__net_timestamp(skb);\n\n\thdr = (void *)skb_push(skb, HCI_MON_HDR_SIZE);\n\thdr->opcode = cpu_to_le16(HCI_MON_SYSTEM_NOTE);\n\thdr->index = cpu_to_le16(HCI_DEV_NONE);\n\thdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);\n\n\tif (sock_queue_rcv_skb(sk, skb))\n\t\tkfree_skb(skb);\n}\n\nstatic void send_monitor_replay(struct sock *sk)\n{\n\tstruct hci_dev *hdev;\n\n\tread_lock(&hci_dev_list_lock);\n\n\tlist_for_each_entry(hdev, &hci_dev_list, list) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = create_monitor_event(hdev, HCI_DEV_REG);\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, skb))\n\t\t\tkfree_skb(skb);\n\n\t\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\t\tcontinue;\n\n\t\tskb = create_monitor_event(hdev, HCI_DEV_OPEN);\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, skb))\n\t\t\tkfree_skb(skb);\n\n\t\tif (test_bit(HCI_UP, &hdev->flags))\n\t\t\tskb = create_monitor_event(hdev, HCI_DEV_UP);\n\t\telse if (hci_dev_test_flag(hdev, HCI_SETUP))\n\t\t\tskb = create_monitor_event(hdev, HCI_DEV_SETUP);\n\t\telse\n\t\t\tskb = NULL;\n\n\t\tif (skb) {\n\t\t\tif (sock_queue_rcv_skb(sk, skb))\n\t\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\tread_unlock(&hci_dev_list_lock);\n}\n\nstatic void send_monitor_control_replay(struct sock *mon_sk)\n{\n\tstruct sock *sk;\n\n\tread_lock(&hci_sk_list.lock);\n\n\tsk_for_each(sk, &hci_sk_list.head) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = create_monitor_ctrl_open(sk);\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(mon_sk, skb))\n\t\t\tkfree_skb(skb);\n\t}\n\n\tread_unlock(&hci_sk_list.lock);\n}\n\n \nstatic void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data)\n{\n\tstruct hci_event_hdr *hdr;\n\tstruct hci_ev_stack_internal *ev;\n\tstruct sk_buff *skb;\n\n\tskb = bt_skb_alloc(HCI_EVENT_HDR_SIZE + sizeof(*ev) + dlen, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\thdr = skb_put(skb, HCI_EVENT_HDR_SIZE);\n\thdr->evt  = HCI_EV_STACK_INTERNAL;\n\thdr->plen = sizeof(*ev) + dlen;\n\n\tev = skb_put(skb, sizeof(*ev) + dlen);\n\tev->type = type;\n\tmemcpy(ev->data, data, dlen);\n\n\tbt_cb(skb)->incoming = 1;\n\t__net_timestamp(skb);\n\n\thci_skb_pkt_type(skb) = HCI_EVENT_PKT;\n\thci_send_to_sock(hdev, skb);\n\tkfree_skb(skb);\n}\n\nvoid hci_sock_dev_event(struct hci_dev *hdev, int event)\n{\n\tBT_DBG(\"hdev %s event %d\", hdev->name, event);\n\n\tif (atomic_read(&monitor_promisc)) {\n\t\tstruct sk_buff *skb;\n\n\t\t \n\t\tskb = create_monitor_event(hdev, event);\n\t\tif (skb) {\n\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n\t\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\tif (event <= HCI_DEV_DOWN) {\n\t\tstruct hci_ev_si_device ev;\n\n\t\t \n\t\tev.event  = event;\n\t\tev.dev_id = hdev->id;\n\t\thci_si_event(NULL, HCI_EV_SI_DEVICE, sizeof(ev), &ev);\n\t}\n\n\tif (event == HCI_DEV_UNREG) {\n\t\tstruct sock *sk;\n\n\t\t \n\t\tread_lock(&hci_sk_list.lock);\n\t\tsk_for_each(sk, &hci_sk_list.head) {\n\t\t\tif (hci_pi(sk)->hdev == hdev) {\n\t\t\t\tsk->sk_err = EPIPE;\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t}\n\t\t}\n\t\tread_unlock(&hci_sk_list.lock);\n\t}\n}\n\nstatic struct hci_mgmt_chan *__hci_mgmt_chan_find(unsigned short channel)\n{\n\tstruct hci_mgmt_chan *c;\n\n\tlist_for_each_entry(c, &mgmt_chan_list, list) {\n\t\tif (c->channel == channel)\n\t\t\treturn c;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct hci_mgmt_chan *hci_mgmt_chan_find(unsigned short channel)\n{\n\tstruct hci_mgmt_chan *c;\n\n\tmutex_lock(&mgmt_chan_list_lock);\n\tc = __hci_mgmt_chan_find(channel);\n\tmutex_unlock(&mgmt_chan_list_lock);\n\n\treturn c;\n}\n\nint hci_mgmt_chan_register(struct hci_mgmt_chan *c)\n{\n\tif (c->channel < HCI_CHANNEL_CONTROL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mgmt_chan_list_lock);\n\tif (__hci_mgmt_chan_find(c->channel)) {\n\t\tmutex_unlock(&mgmt_chan_list_lock);\n\t\treturn -EALREADY;\n\t}\n\n\tlist_add_tail(&c->list, &mgmt_chan_list);\n\n\tmutex_unlock(&mgmt_chan_list_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hci_mgmt_chan_register);\n\nvoid hci_mgmt_chan_unregister(struct hci_mgmt_chan *c)\n{\n\tmutex_lock(&mgmt_chan_list_lock);\n\tlist_del(&c->list);\n\tmutex_unlock(&mgmt_chan_list_lock);\n}\nEXPORT_SYMBOL(hci_mgmt_chan_unregister);\n\nstatic int hci_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev;\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_MONITOR:\n\t\tatomic_dec(&monitor_promisc);\n\t\tbreak;\n\tcase HCI_CHANNEL_RAW:\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\t\t \n\t\tskb = create_monitor_ctrl_close(sk);\n\t\tif (skb) {\n\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n\t\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\t\tkfree_skb(skb);\n\t\t}\n\n\t\thci_sock_free_cookie(sk);\n\t\tbreak;\n\t}\n\n\tbt_sock_unlink(&hci_sk_list, sk);\n\n\thdev = hci_pi(sk)->hdev;\n\tif (hdev) {\n\t\tif (hci_pi(sk)->channel == HCI_CHANNEL_USER &&\n\t\t    !hci_dev_test_flag(hdev, HCI_UNREGISTER)) {\n\t\t\t \n\t\t\thci_dev_do_close(hdev);\n\t\t\thci_dev_clear_flag(hdev, HCI_USER_CHANNEL);\n\t\t\tmgmt_index_added(hdev);\n\t\t}\n\n\t\tatomic_dec(&hdev->promisc);\n\t\thci_dev_put(hdev);\n\t}\n\n\tsock_orphan(sk);\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}\n\nstatic int hci_sock_reject_list_add(struct hci_dev *hdev, void __user *arg)\n{\n\tbdaddr_t bdaddr;\n\tint err;\n\n\tif (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))\n\t\treturn -EFAULT;\n\n\thci_dev_lock(hdev);\n\n\terr = hci_bdaddr_list_add(&hdev->reject_list, &bdaddr, BDADDR_BREDR);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int hci_sock_reject_list_del(struct hci_dev *hdev, void __user *arg)\n{\n\tbdaddr_t bdaddr;\n\tint err;\n\n\tif (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))\n\t\treturn -EFAULT;\n\n\thci_dev_lock(hdev);\n\n\terr = hci_bdaddr_list_del(&hdev->reject_list, &bdaddr, BDADDR_BREDR);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\n \nstatic int hci_sock_bound_ioctl(struct sock *sk, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct hci_dev *hdev = hci_hdev_from_sock(sk);\n\n\tif (IS_ERR(hdev))\n\t\treturn PTR_ERR(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_USER_CHANNEL))\n\t\treturn -EBUSY;\n\n\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED))\n\t\treturn -EOPNOTSUPP;\n\n\tif (hdev->dev_type != HCI_PRIMARY)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd) {\n\tcase HCISETRAW:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn -EOPNOTSUPP;\n\n\tcase HCIGETCONNINFO:\n\t\treturn hci_get_conn_info(hdev, (void __user *)arg);\n\n\tcase HCIGETAUTHINFO:\n\t\treturn hci_get_auth_info(hdev, (void __user *)arg);\n\n\tcase HCIBLOCKADDR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn hci_sock_reject_list_add(hdev, (void __user *)arg);\n\n\tcase HCIUNBLOCKADDR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn hci_sock_reject_list_del(hdev, (void __user *)arg);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic int hci_sock_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\n\t \n\tswitch (cmd) {\n\tcase HCIGETDEVLIST:\n\tcase HCIGETDEVINFO:\n\tcase HCIGETCONNLIST:\n\tcase HCIDEVUP:\n\tcase HCIDEVDOWN:\n\tcase HCIDEVRESET:\n\tcase HCIDEVRESTAT:\n\tcase HCISETSCAN:\n\tcase HCISETAUTH:\n\tcase HCISETENCRYPT:\n\tcase HCISETPTYPE:\n\tcase HCISETLINKPOL:\n\tcase HCISETLINKMODE:\n\tcase HCISETACLMTU:\n\tcase HCISETSCOMTU:\n\tcase HCIINQUIRY:\n\tcase HCISETRAW:\n\tcase HCIGETCONNINFO:\n\tcase HCIGETAUTHINFO:\n\tcase HCIBLOCKADDR:\n\tcase HCIUNBLOCKADDR:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\tlock_sock(sk);\n\n\tif (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\t \n\tif (hci_sock_gen_cookie(sk)) {\n\t\tstruct sk_buff *skb;\n\n\t\t \n\t\tif (sk_capable(sk, CAP_NET_ADMIN))\n\t\t\thci_sock_set_flag(sk, HCI_SOCK_TRUSTED);\n\n\t\t \n\t\tskb = create_monitor_ctrl_open(sk);\n\t\tif (skb) {\n\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n\t\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\trelease_sock(sk);\n\n\tswitch (cmd) {\n\tcase HCIGETDEVLIST:\n\t\treturn hci_get_dev_list(argp);\n\n\tcase HCIGETDEVINFO:\n\t\treturn hci_get_dev_info(argp);\n\n\tcase HCIGETCONNLIST:\n\t\treturn hci_get_conn_list(argp);\n\n\tcase HCIDEVUP:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn hci_dev_open(arg);\n\n\tcase HCIDEVDOWN:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn hci_dev_close(arg);\n\n\tcase HCIDEVRESET:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn hci_dev_reset(arg);\n\n\tcase HCIDEVRESTAT:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn hci_dev_reset_stat(arg);\n\n\tcase HCISETSCAN:\n\tcase HCISETAUTH:\n\tcase HCISETENCRYPT:\n\tcase HCISETPTYPE:\n\tcase HCISETLINKPOL:\n\tcase HCISETLINKMODE:\n\tcase HCISETACLMTU:\n\tcase HCISETSCOMTU:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn hci_dev_cmd(cmd, argp);\n\n\tcase HCIINQUIRY:\n\t\treturn hci_inquiry(argp);\n\t}\n\n\tlock_sock(sk);\n\n\terr = hci_sock_bound_ioctl(sk, cmd, arg);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int hci_sock_compat_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase HCIDEVUP:\n\tcase HCIDEVDOWN:\n\tcase HCIDEVRESET:\n\tcase HCIDEVRESTAT:\n\t\treturn hci_sock_ioctl(sock, cmd, arg);\n\t}\n\n\treturn hci_sock_ioctl(sock, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic int hci_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_hci haddr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = NULL;\n\tstruct sk_buff *skb;\n\tint len, err = 0;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!addr)\n\t\treturn -EINVAL;\n\n\tmemset(&haddr, 0, sizeof(haddr));\n\tlen = min_t(unsigned int, sizeof(haddr), addr_len);\n\tmemcpy(&haddr, addr, len);\n\n\tif (haddr.hci_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\t \n\thdev = hci_pi(sk)->hdev;\n\tif (hdev && hci_dev_test_flag(hdev, HCI_UNREGISTER)) {\n\t\thci_pi(sk)->hdev = NULL;\n\t\tsk->sk_state = BT_OPEN;\n\t\thci_dev_put(hdev);\n\t}\n\thdev = NULL;\n\n\tif (sk->sk_state == BT_BOUND) {\n\t\terr = -EALREADY;\n\t\tgoto done;\n\t}\n\n\tswitch (haddr.hci_channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\tif (hci_pi(sk)->hdev) {\n\t\t\terr = -EALREADY;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (haddr.hci_dev != HCI_DEV_NONE) {\n\t\t\thdev = hci_dev_get(haddr.hci_dev);\n\t\t\tif (!hdev) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tatomic_inc(&hdev->promisc);\n\t\t}\n\n\t\thci_pi(sk)->channel = haddr.hci_channel;\n\n\t\tif (!hci_sock_gen_cookie(sk)) {\n\t\t\t \n\t\t\tskb = create_monitor_ctrl_close(sk);\n\t\t\tif (skb) {\n\t\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n\t\t\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t}\n\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\thci_sock_set_flag(sk, HCI_SOCK_TRUSTED);\n\n\t\thci_pi(sk)->hdev = hdev;\n\n\t\t \n\t\tskb = create_monitor_ctrl_open(sk);\n\t\tif (skb) {\n\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n\t\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\tbreak;\n\n\tcase HCI_CHANNEL_USER:\n\t\tif (hci_pi(sk)->hdev) {\n\t\t\terr = -EALREADY;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (haddr.hci_dev == HCI_DEV_NONE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\n\t\thdev = hci_dev_get(haddr.hci_dev);\n\t\tif (!hdev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (test_bit(HCI_INIT, &hdev->flags) ||\n\t\t    hci_dev_test_flag(hdev, HCI_SETUP) ||\n\t\t    hci_dev_test_flag(hdev, HCI_CONFIG) ||\n\t\t    (!hci_dev_test_flag(hdev, HCI_AUTO_OFF) &&\n\t\t     test_bit(HCI_UP, &hdev->flags))) {\n\t\t\terr = -EBUSY;\n\t\t\thci_dev_put(hdev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (hci_dev_test_and_set_flag(hdev, HCI_USER_CHANNEL)) {\n\t\t\terr = -EUSERS;\n\t\t\thci_dev_put(hdev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tmgmt_index_removed(hdev);\n\n\t\terr = hci_dev_open(hdev->id);\n\t\tif (err) {\n\t\t\tif (err == -EALREADY) {\n\t\t\t\t \n\t\t\t\terr = 0;\n\t\t\t} else {\n\t\t\t\thci_dev_clear_flag(hdev, HCI_USER_CHANNEL);\n\t\t\t\tmgmt_index_added(hdev);\n\t\t\t\thci_dev_put(hdev);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\thci_pi(sk)->channel = haddr.hci_channel;\n\n\t\tif (!hci_sock_gen_cookie(sk)) {\n\t\t\t \n\t\t\tskb = create_monitor_ctrl_close(sk);\n\t\t\tif (skb) {\n\t\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n\t\t\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\thci_sock_set_flag(sk, HCI_SOCK_TRUSTED);\n\n\t\thci_pi(sk)->hdev = hdev;\n\n\t\t \n\t\tskb = create_monitor_ctrl_open(sk);\n\t\tif (skb) {\n\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n\t\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\t\tkfree_skb(skb);\n\t\t}\n\n\t\tatomic_inc(&hdev->promisc);\n\t\tbreak;\n\n\tcase HCI_CHANNEL_MONITOR:\n\t\tif (haddr.hci_dev != HCI_DEV_NONE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\n\t\thci_pi(sk)->channel = haddr.hci_channel;\n\n\t\t \n\t\thci_sock_set_flag(sk, HCI_SOCK_TRUSTED);\n\n\t\tsend_monitor_note(sk, \"Linux version %s (%s)\",\n\t\t\t\t  init_utsname()->release,\n\t\t\t\t  init_utsname()->machine);\n\t\tsend_monitor_note(sk, \"Bluetooth subsystem version %u.%u\",\n\t\t\t\t  BT_SUBSYS_VERSION, BT_SUBSYS_REVISION);\n\t\tsend_monitor_replay(sk);\n\t\tsend_monitor_control_replay(sk);\n\n\t\tatomic_inc(&monitor_promisc);\n\t\tbreak;\n\n\tcase HCI_CHANNEL_LOGGING:\n\t\tif (haddr.hci_dev != HCI_DEV_NONE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\n\t\thci_pi(sk)->channel = haddr.hci_channel;\n\t\tbreak;\n\n\tdefault:\n\t\tif (!hci_mgmt_chan_find(haddr.hci_channel)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (haddr.hci_dev != HCI_DEV_NONE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\thci_sock_set_flag(sk, HCI_SOCK_TRUSTED);\n\n\t\thci_pi(sk)->channel = haddr.hci_channel;\n\n\t\t \n\t\tif (hci_pi(sk)->channel == HCI_CHANNEL_CONTROL) {\n\t\t\tif (!hci_sock_gen_cookie(sk)) {\n\t\t\t\t \n\t\t\t\tskb = create_monitor_ctrl_close(sk);\n\t\t\t\tif (skb) {\n\t\t\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n\t\t\t\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tskb = create_monitor_ctrl_open(sk);\n\t\t\tif (skb) {\n\t\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb,\n\t\t\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\n\t\t\thci_sock_set_flag(sk, HCI_MGMT_INDEX_EVENTS);\n\t\t\thci_sock_set_flag(sk, HCI_MGMT_UNCONF_INDEX_EVENTS);\n\t\t\thci_sock_set_flag(sk, HCI_MGMT_OPTION_EVENTS);\n\t\t\thci_sock_set_flag(sk, HCI_MGMT_SETTING_EVENTS);\n\t\t\thci_sock_set_flag(sk, HCI_MGMT_DEV_CLASS_EVENTS);\n\t\t\thci_sock_set_flag(sk, HCI_MGMT_LOCAL_NAME_EVENTS);\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (!hci_pi(sk)->mtu)\n\t\thci_pi(sk)->mtu = HCI_MAX_FRAME_SIZE;\n\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *)addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\thdev = hci_hdev_from_sock(sk);\n\tif (IS_ERR(hdev)) {\n\t\terr = PTR_ERR(hdev);\n\t\tgoto done;\n\t}\n\n\thaddr->hci_family = AF_BLUETOOTH;\n\thaddr->hci_dev    = hdev->id;\n\thaddr->hci_channel= hci_pi(sk)->channel;\n\terr = sizeof(*haddr);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic void hci_sock_cmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct sk_buff *skb)\n{\n\t__u8 mask = hci_pi(sk)->cmsg_mask;\n\n\tif (mask & HCI_CMSG_DIR) {\n\t\tint incoming = bt_cb(skb)->incoming;\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_DIR, sizeof(incoming),\n\t\t\t &incoming);\n\t}\n\n\tif (mask & HCI_CMSG_TSTAMP) {\n#ifdef CONFIG_COMPAT\n\t\tstruct old_timeval32 ctv;\n#endif\n\t\tstruct __kernel_old_timeval tv;\n\t\tvoid *data;\n\t\tint len;\n\n\t\tskb_get_timestamp(skb, &tv);\n\n\t\tdata = &tv;\n\t\tlen = sizeof(tv);\n#ifdef CONFIG_COMPAT\n\t\tif (!COMPAT_USE_64BIT_TIME &&\n\t\t    (msg->msg_flags & MSG_CMSG_COMPAT)) {\n\t\t\tctv.tv_sec = tv.tv_sec;\n\t\t\tctv.tv_usec = tv.tv_usec;\n\t\t\tdata = &ctv;\n\t\t\tlen = sizeof(ctv);\n\t\t}\n#endif\n\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_TSTAMP, len, data);\n\t}\n}\n\nstatic int hci_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len, int flags)\n{\n\tstruct scm_cookie scm;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\tunsigned int skblen;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hci_pi(sk)->channel == HCI_CHANNEL_LOGGING)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\tdefault:\n\t\tif (hci_mgmt_chan_find(hci_pi(sk)->channel))\n\t\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\n\tmemset(&scm, 0, sizeof(scm));\n\tscm.creds = bt_cb(skb)->creds;\n\n\tskb_free_datagram(sk, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\n\tscm_recv(sock, msg, &scm, flags);\n\n\treturn err ? : copied;\n}\n\nstatic int hci_mgmt_cmd(struct hci_mgmt_chan *chan, struct sock *sk,\n\t\t\tstruct sk_buff *skb)\n{\n\tu8 *cp;\n\tstruct mgmt_hdr *hdr;\n\tu16 opcode, index, len;\n\tstruct hci_dev *hdev = NULL;\n\tconst struct hci_mgmt_handler *handler;\n\tbool var_len, no_hdev;\n\tint err;\n\n\tBT_DBG(\"got %d bytes\", skb->len);\n\n\tif (skb->len < sizeof(*hdr))\n\t\treturn -EINVAL;\n\n\thdr = (void *)skb->data;\n\topcode = __le16_to_cpu(hdr->opcode);\n\tindex = __le16_to_cpu(hdr->index);\n\tlen = __le16_to_cpu(hdr->len);\n\n\tif (len != skb->len - sizeof(*hdr)) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (chan->channel == HCI_CHANNEL_CONTROL) {\n\t\tstruct sk_buff *cmd;\n\n\t\t \n\t\tcmd = create_monitor_ctrl_command(sk, index, opcode, len,\n\t\t\t\t\t\t  skb->data + sizeof(*hdr));\n\t\tif (cmd) {\n\t\t\thci_send_to_channel(HCI_CHANNEL_MONITOR, cmd,\n\t\t\t\t\t    HCI_SOCK_TRUSTED, NULL);\n\t\t\tkfree_skb(cmd);\n\t\t}\n\t}\n\n\tif (opcode >= chan->handler_count ||\n\t    chan->handlers[opcode].func == NULL) {\n\t\tBT_DBG(\"Unknown op %u\", opcode);\n\t\terr = mgmt_cmd_status(sk, index, opcode,\n\t\t\t\t      MGMT_STATUS_UNKNOWN_COMMAND);\n\t\tgoto done;\n\t}\n\n\thandler = &chan->handlers[opcode];\n\n\tif (!hci_sock_test_flag(sk, HCI_SOCK_TRUSTED) &&\n\t    !(handler->flags & HCI_MGMT_UNTRUSTED)) {\n\t\terr = mgmt_cmd_status(sk, index, opcode,\n\t\t\t\t      MGMT_STATUS_PERMISSION_DENIED);\n\t\tgoto done;\n\t}\n\n\tif (index != MGMT_INDEX_NONE) {\n\t\thdev = hci_dev_get(index);\n\t\tif (!hdev) {\n\t\t\terr = mgmt_cmd_status(sk, index, opcode,\n\t\t\t\t\t      MGMT_STATUS_INVALID_INDEX);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (hci_dev_test_flag(hdev, HCI_SETUP) ||\n\t\t    hci_dev_test_flag(hdev, HCI_CONFIG) ||\n\t\t    hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\n\t\t\terr = mgmt_cmd_status(sk, index, opcode,\n\t\t\t\t\t      MGMT_STATUS_INVALID_INDEX);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED) &&\n\t\t    !(handler->flags & HCI_MGMT_UNCONFIGURED)) {\n\t\t\terr = mgmt_cmd_status(sk, index, opcode,\n\t\t\t\t\t      MGMT_STATUS_INVALID_INDEX);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (!(handler->flags & HCI_MGMT_HDEV_OPTIONAL)) {\n\t\tno_hdev = (handler->flags & HCI_MGMT_NO_HDEV);\n\t\tif (no_hdev != !hdev) {\n\t\t\terr = mgmt_cmd_status(sk, index, opcode,\n\t\t\t\t\t      MGMT_STATUS_INVALID_INDEX);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tvar_len = (handler->flags & HCI_MGMT_VAR_LEN);\n\tif ((var_len && len < handler->data_len) ||\n\t    (!var_len && len != handler->data_len)) {\n\t\terr = mgmt_cmd_status(sk, index, opcode,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto done;\n\t}\n\n\tif (hdev && chan->hdev_init)\n\t\tchan->hdev_init(sk, hdev);\n\n\tcp = skb->data + sizeof(*hdr);\n\n\terr = handler->func(sk, hdev, cp, len);\n\tif (err < 0)\n\t\tgoto done;\n\n\terr = skb->len;\n\ndone:\n\tif (hdev)\n\t\thci_dev_put(hdev);\n\n\treturn err;\n}\n\nstatic int hci_logging_frame(struct sock *sk, struct sk_buff *skb,\n\t\t\t     unsigned int flags)\n{\n\tstruct hci_mon_hdr *hdr;\n\tstruct hci_dev *hdev;\n\tu16 index;\n\tint err;\n\n\t \n\tif (skb->len < sizeof(*hdr) + 3)\n\t\treturn -EINVAL;\n\n\thdr = (void *)skb->data;\n\n\tif (__le16_to_cpu(hdr->len) != skb->len - sizeof(*hdr))\n\t\treturn -EINVAL;\n\n\tif (__le16_to_cpu(hdr->opcode) == 0x0000) {\n\t\t__u8 priority = skb->data[sizeof(*hdr)];\n\t\t__u8 ident_len = skb->data[sizeof(*hdr) + 1];\n\n\t\t \n\t\tif (priority > 7 || skb->data[skb->len - 1] != 0x00 ||\n\t\t    ident_len > skb->len - sizeof(*hdr) - 3 ||\n\t\t    skb->data[sizeof(*hdr) + ident_len + 1] != 0x00)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tindex = __le16_to_cpu(hdr->index);\n\n\tif (index != MGMT_INDEX_NONE) {\n\t\thdev = hci_dev_get(index);\n\t\tif (!hdev)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\thdev = NULL;\n\t}\n\n\thdr->opcode = cpu_to_le16(HCI_MON_USER_LOGGING);\n\n\thci_send_to_channel(HCI_CHANNEL_MONITOR, skb, HCI_SOCK_TRUSTED, NULL);\n\terr = skb->len;\n\n\tif (hdev)\n\t\thci_dev_put(hdev);\n\n\treturn err;\n}\n\nstatic int hci_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct hci_mgmt_chan *chan;\n\tstruct hci_dev *hdev;\n\tstruct sk_buff *skb;\n\tint err;\n\tconst unsigned int flags = msg->msg_flags;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & ~(MSG_DONTWAIT | MSG_NOSIGNAL | MSG_ERRQUEUE | MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (len < 4 || len > hci_pi(sk)->mtu)\n\t\treturn -EINVAL;\n\n\tskb = bt_skb_sendmsg(sk, msg, len, len, 0, 0);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tlock_sock(sk);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\tcase HCI_CHANNEL_USER:\n\t\tbreak;\n\tcase HCI_CHANNEL_MONITOR:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto drop;\n\tcase HCI_CHANNEL_LOGGING:\n\t\terr = hci_logging_frame(sk, skb, flags);\n\t\tgoto drop;\n\tdefault:\n\t\tmutex_lock(&mgmt_chan_list_lock);\n\t\tchan = __hci_mgmt_chan_find(hci_pi(sk)->channel);\n\t\tif (chan)\n\t\t\terr = hci_mgmt_cmd(chan, sk, skb);\n\t\telse\n\t\t\terr = -EINVAL;\n\n\t\tmutex_unlock(&mgmt_chan_list_lock);\n\t\tgoto drop;\n\t}\n\n\thdev = hci_hdev_from_sock(sk);\n\tif (IS_ERR(hdev)) {\n\t\terr = PTR_ERR(hdev);\n\t\tgoto drop;\n\t}\n\n\tif (!test_bit(HCI_UP, &hdev->flags)) {\n\t\terr = -ENETDOWN;\n\t\tgoto drop;\n\t}\n\n\thci_skb_pkt_type(skb) = skb->data[0];\n\tskb_pull(skb, 1);\n\n\tif (hci_pi(sk)->channel == HCI_CHANNEL_USER) {\n\t\t \n\t\tif (hci_skb_pkt_type(skb) != HCI_COMMAND_PKT &&\n\t\t    hci_skb_pkt_type(skb) != HCI_ACLDATA_PKT &&\n\t\t    hci_skb_pkt_type(skb) != HCI_SCODATA_PKT &&\n\t\t    hci_skb_pkt_type(skb) != HCI_ISODATA_PKT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t} else if (hci_skb_pkt_type(skb) == HCI_COMMAND_PKT) {\n\t\tu16 opcode = get_unaligned_le16(skb->data);\n\t\tu16 ogf = hci_opcode_ogf(opcode);\n\t\tu16 ocf = hci_opcode_ocf(opcode);\n\n\t\tif (((ogf > HCI_SFLT_MAX_OGF) ||\n\t\t     !hci_test_bit(ocf & HCI_FLT_OCF_BITS,\n\t\t\t\t   &hci_sec_filter.ocf_mask[ogf])) &&\n\t\t    !capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\thci_skb_opcode(skb) = opcode;\n\n\t\tif (ogf == 0x3f) {\n\t\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t\t} else {\n\t\t\t \n\t\t\tbt_cb(skb)->hci.req_flags |= HCI_REQ_START;\n\n\t\t\tskb_queue_tail(&hdev->cmd_q, skb);\n\t\t\tqueue_work(hdev->workqueue, &hdev->cmd_work);\n\t\t}\n\t} else {\n\t\tif (!capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (hci_skb_pkt_type(skb) != HCI_ACLDATA_PKT &&\n\t\t    hci_skb_pkt_type(skb) != HCI_SCODATA_PKT &&\n\t\t    hci_skb_pkt_type(skb) != HCI_ISODATA_PKT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t}\n\n\terr = len;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n\ndrop:\n\tkfree_skb(skb);\n\tgoto done;\n}\n\nstatic int hci_sock_setsockopt_old(struct socket *sock, int level, int optname,\n\t\t\t\t   sockptr_t optval, unsigned int len)\n{\n\tstruct hci_ufilter uf = { .opcode = 0 };\n\tstruct sock *sk = sock->sk;\n\tint err = 0, opt = 0;\n\n\tBT_DBG(\"sk %p, opt %d\", sk, optname);\n\n\tlock_sock(sk);\n\n\tif (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tswitch (optname) {\n\tcase HCI_DATA_DIR:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(opt))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\thci_pi(sk)->cmsg_mask |= HCI_CMSG_DIR;\n\t\telse\n\t\t\thci_pi(sk)->cmsg_mask &= ~HCI_CMSG_DIR;\n\t\tbreak;\n\n\tcase HCI_TIME_STAMP:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(opt))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\thci_pi(sk)->cmsg_mask |= HCI_CMSG_TSTAMP;\n\t\telse\n\t\t\thci_pi(sk)->cmsg_mask &= ~HCI_CMSG_TSTAMP;\n\t\tbreak;\n\n\tcase HCI_FILTER:\n\t\t{\n\t\t\tstruct hci_filter *f = &hci_pi(sk)->filter;\n\n\t\t\tuf.type_mask = f->type_mask;\n\t\t\tuf.opcode    = f->opcode;\n\t\t\tuf.event_mask[0] = *((u32 *) f->event_mask + 0);\n\t\t\tuf.event_mask[1] = *((u32 *) f->event_mask + 1);\n\t\t}\n\n\t\tlen = min_t(unsigned int, len, sizeof(uf));\n\t\tif (copy_from_sockptr(&uf, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!capable(CAP_NET_RAW)) {\n\t\t\tuf.type_mask &= hci_sec_filter.type_mask;\n\t\t\tuf.event_mask[0] &= *((u32 *) hci_sec_filter.event_mask + 0);\n\t\t\tuf.event_mask[1] &= *((u32 *) hci_sec_filter.event_mask + 1);\n\t\t}\n\n\t\t{\n\t\t\tstruct hci_filter *f = &hci_pi(sk)->filter;\n\n\t\t\tf->type_mask = uf.type_mask;\n\t\t\tf->opcode    = uf.opcode;\n\t\t\t*((u32 *) f->event_mask + 0) = uf.event_mask[0];\n\t\t\t*((u32 *) f->event_mask + 1) = uf.event_mask[1];\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int hci_sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tu16 opt;\n\n\tBT_DBG(\"sk %p, opt %d\", sk, optname);\n\n\tif (level == SOL_HCI)\n\t\treturn hci_sock_setsockopt_old(sock, level, optname, optval,\n\t\t\t\t\t       len);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SNDMTU:\n\tcase BT_RCVMTU:\n\t\tswitch (hci_pi(sk)->channel) {\n\t\t \n\t\tcase HCI_CHANNEL_RAW:\n\t\tcase HCI_CHANNEL_USER:\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(opt))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\thci_pi(sk)->mtu = opt;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int hci_sock_getsockopt_old(struct socket *sock, int level, int optname,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct hci_ufilter uf;\n\tstruct sock *sk = sock->sk;\n\tint len, opt, err = 0;\n\n\tBT_DBG(\"sk %p, opt %d\", sk, optname);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tif (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tswitch (optname) {\n\tcase HCI_DATA_DIR:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_DIR)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase HCI_TIME_STAMP:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_TSTAMP)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase HCI_FILTER:\n\t\t{\n\t\t\tstruct hci_filter *f = &hci_pi(sk)->filter;\n\n\t\t\tmemset(&uf, 0, sizeof(uf));\n\t\t\tuf.type_mask = f->type_mask;\n\t\t\tuf.opcode    = f->opcode;\n\t\t\tuf.event_mask[0] = *((u32 *) f->event_mask + 0);\n\t\t\tuf.event_mask[1] = *((u32 *) f->event_mask + 1);\n\t\t}\n\n\t\tlen = min_t(unsigned int, len, sizeof(uf));\n\t\tif (copy_to_user(optval, &uf, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int hci_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p, opt %d\", sk, optname);\n\n\tif (level == SOL_HCI)\n\t\treturn hci_sock_getsockopt_old(sock, level, optname, optval,\n\t\t\t\t\t       optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SNDMTU:\n\tcase BT_RCVMTU:\n\t\tif (put_user(hci_pi(sk)->mtu, (u16 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic void hci_sock_destruct(struct sock *sk)\n{\n\tmgmt_cleanup(sk);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic const struct proto_ops hci_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= hci_sock_release,\n\t.bind\t\t= hci_sock_bind,\n\t.getname\t= hci_sock_getname,\n\t.sendmsg\t= hci_sock_sendmsg,\n\t.recvmsg\t= hci_sock_recvmsg,\n\t.ioctl\t\t= hci_sock_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= hci_sock_compat_ioctl,\n#endif\n\t.poll\t\t= datagram_poll,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.setsockopt\t= hci_sock_setsockopt,\n\t.getsockopt\t= hci_sock_getsockopt,\n\t.connect\t= sock_no_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.mmap\t\t= sock_no_mmap\n};\n\nstatic struct proto hci_sk_proto = {\n\t.name\t\t= \"HCI\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct hci_pinfo)\n};\n\nstatic int hci_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t   int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &hci_sock_ops;\n\n\tsk = bt_sock_alloc(net, sock, &hci_sk_proto, protocol, GFP_ATOMIC,\n\t\t\t   kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock->state = SS_UNCONNECTED;\n\tsk->sk_destruct = hci_sock_destruct;\n\n\tbt_sock_link(&hci_sk_list, sk);\n\treturn 0;\n}\n\nstatic const struct net_proto_family hci_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= hci_sock_create,\n};\n\nint __init hci_sock_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_hci) > sizeof(struct sockaddr));\n\n\terr = proto_register(&hci_sk_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_HCI, &hci_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"HCI socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"hci\", &hci_sk_list, NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create HCI proc file\");\n\t\tbt_sock_unregister(BTPROTO_HCI);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"HCI socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&hci_sk_proto);\n\treturn err;\n}\n\nvoid hci_sock_cleanup(void)\n{\n\tbt_procfs_cleanup(&init_net, \"hci\");\n\tbt_sock_unregister(BTPROTO_HCI);\n\tproto_unregister(&hci_sk_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}