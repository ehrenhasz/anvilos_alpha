{
  "module_name": "smp.h",
  "hash_id": "f33456e2fce3ca930a0ef00ac137e48295f4d9aefab5a089bb7e5c8e79df299e",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/smp.h",
  "human_readable_source": " \n\n#ifndef __SMP_H\n#define __SMP_H\n\nstruct smp_command_hdr {\n\t__u8\tcode;\n} __packed;\n\n#define SMP_CMD_PAIRING_REQ\t0x01\n#define SMP_CMD_PAIRING_RSP\t0x02\nstruct smp_cmd_pairing {\n\t__u8\tio_capability;\n\t__u8\toob_flag;\n\t__u8\tauth_req;\n\t__u8\tmax_key_size;\n\t__u8\tinit_key_dist;\n\t__u8\tresp_key_dist;\n} __packed;\n\n#define SMP_IO_DISPLAY_ONLY\t0x00\n#define SMP_IO_DISPLAY_YESNO\t0x01\n#define SMP_IO_KEYBOARD_ONLY\t0x02\n#define SMP_IO_NO_INPUT_OUTPUT\t0x03\n#define SMP_IO_KEYBOARD_DISPLAY\t0x04\n\n#define SMP_OOB_NOT_PRESENT\t0x00\n#define SMP_OOB_PRESENT\t\t0x01\n\n#define SMP_DIST_ENC_KEY\t0x01\n#define SMP_DIST_ID_KEY\t\t0x02\n#define SMP_DIST_SIGN\t\t0x04\n#define SMP_DIST_LINK_KEY\t0x08\n\n#define SMP_AUTH_NONE\t\t0x00\n#define SMP_AUTH_BONDING\t0x01\n#define SMP_AUTH_MITM\t\t0x04\n#define SMP_AUTH_SC\t\t0x08\n#define SMP_AUTH_KEYPRESS\t0x10\n#define SMP_AUTH_CT2\t\t0x20\n\n#define SMP_CMD_PAIRING_CONFIRM\t0x03\nstruct smp_cmd_pairing_confirm {\n\t__u8\tconfirm_val[16];\n} __packed;\n\n#define SMP_CMD_PAIRING_RANDOM\t0x04\nstruct smp_cmd_pairing_random {\n\t__u8\trand_val[16];\n} __packed;\n\n#define SMP_CMD_PAIRING_FAIL\t0x05\nstruct smp_cmd_pairing_fail {\n\t__u8\treason;\n} __packed;\n\n#define SMP_CMD_ENCRYPT_INFO\t0x06\nstruct smp_cmd_encrypt_info {\n\t__u8\tltk[16];\n} __packed;\n\n#define SMP_CMD_INITIATOR_IDENT\t0x07\nstruct smp_cmd_initiator_ident {\n\t__le16\tediv;\n\t__le64\trand;\n} __packed;\n\n#define SMP_CMD_IDENT_INFO\t0x08\nstruct smp_cmd_ident_info {\n\t__u8\tirk[16];\n} __packed;\n\n#define SMP_CMD_IDENT_ADDR_INFO\t0x09\nstruct smp_cmd_ident_addr_info {\n\t__u8\taddr_type;\n\tbdaddr_t bdaddr;\n} __packed;\n\n#define SMP_CMD_SIGN_INFO\t0x0a\nstruct smp_cmd_sign_info {\n\t__u8\tcsrk[16];\n} __packed;\n\n#define SMP_CMD_SECURITY_REQ\t0x0b\nstruct smp_cmd_security_req {\n\t__u8\tauth_req;\n} __packed;\n\n#define SMP_CMD_PUBLIC_KEY\t0x0c\nstruct smp_cmd_public_key {\n\t__u8\tx[32];\n\t__u8\ty[32];\n} __packed;\n\n#define SMP_CMD_DHKEY_CHECK\t0x0d\nstruct smp_cmd_dhkey_check {\n\t__u8\te[16];\n} __packed;\n\n#define SMP_CMD_KEYPRESS_NOTIFY\t0x0e\nstruct smp_cmd_keypress_notify {\n\t__u8\tvalue;\n} __packed;\n\n#define SMP_CMD_MAX\t\t0x0e\n\n#define SMP_PASSKEY_ENTRY_FAILED\t0x01\n#define SMP_OOB_NOT_AVAIL\t\t0x02\n#define SMP_AUTH_REQUIREMENTS\t\t0x03\n#define SMP_CONFIRM_FAILED\t\t0x04\n#define SMP_PAIRING_NOTSUPP\t\t0x05\n#define SMP_ENC_KEY_SIZE\t\t0x06\n#define SMP_CMD_NOTSUPP\t\t\t0x07\n#define SMP_UNSPECIFIED\t\t\t0x08\n#define SMP_REPEATED_ATTEMPTS\t\t0x09\n#define SMP_INVALID_PARAMS\t\t0x0a\n#define SMP_DHKEY_CHECK_FAILED\t\t0x0b\n#define SMP_NUMERIC_COMP_FAILED\t\t0x0c\n#define SMP_BREDR_PAIRING_IN_PROGRESS\t0x0d\n#define SMP_CROSS_TRANSP_NOT_ALLOWED\t0x0e\n\n#define SMP_MIN_ENC_KEY_SIZE\t\t7\n#define SMP_MAX_ENC_KEY_SIZE\t\t16\n\n \nenum {\n\tSMP_STK,\n\tSMP_LTK,\n\tSMP_LTK_RESPONDER,\n\tSMP_LTK_P256,\n\tSMP_LTK_P256_DEBUG,\n};\n\nstatic inline bool smp_ltk_is_sc(struct smp_ltk *key)\n{\n\tswitch (key->type) {\n\tcase SMP_LTK_P256:\n\tcase SMP_LTK_P256_DEBUG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline u8 smp_ltk_sec_level(struct smp_ltk *key)\n{\n\tif (key->authenticated) {\n\t\tif (smp_ltk_is_sc(key))\n\t\t\treturn BT_SECURITY_FIPS;\n\t\telse\n\t\t\treturn BT_SECURITY_HIGH;\n\t}\n\n\treturn BT_SECURITY_MEDIUM;\n}\n\n \nenum smp_key_pref {\n\tSMP_ALLOW_STK,\n\tSMP_USE_LTK,\n};\n\n \nint smp_cancel_and_remove_pairing(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t  u8 addr_type);\nbool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level,\n\t\t\t     enum smp_key_pref key_pref);\nint smp_conn_security(struct hci_conn *hcon, __u8 sec_level);\nint smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);\n\nbool smp_irk_matches(struct hci_dev *hdev, const u8 irk[16],\n\t\t     const bdaddr_t *bdaddr);\nint smp_generate_rpa(struct hci_dev *hdev, const u8 irk[16], bdaddr_t *rpa);\nint smp_generate_oob(struct hci_dev *hdev, u8 hash[16], u8 rand[16]);\n\nint smp_force_bredr(struct hci_dev *hdev, bool enable);\n\nint smp_register(struct hci_dev *hdev);\nvoid smp_unregister(struct hci_dev *hdev);\n\n#if IS_ENABLED(CONFIG_BT_SELFTEST_SMP)\n\nint bt_selftest_smp(void);\n\n#else\n\nstatic inline int bt_selftest_smp(void)\n{\n\treturn 0;\n}\n\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}