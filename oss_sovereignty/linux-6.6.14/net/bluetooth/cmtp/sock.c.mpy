{
  "module_name": "sock.c",
  "hash_id": "dc80098b8d7d17cef0fe6f4a1e441a16884073c7870871da92497d8792594255",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/cmtp/sock.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n\n#include <linux/types.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/poll.h>\n#include <linux/fcntl.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/ioctl.h>\n#include <linux/file.h>\n#include <linux/compat.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <net/sock.h>\n\n#include <linux/isdn/capilli.h>\n\n\n#include \"cmtp.h\"\n\nstatic struct bt_sock_list cmtp_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(cmtp_sk_list.lock)\n};\n\nstatic int cmtp_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tbt_sock_unlink(&cmtp_sk_list, sk);\n\n\tsock_orphan(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int do_cmtp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct cmtp_connadd_req ca;\n\tstruct cmtp_conndel_req cd;\n\tstruct cmtp_connlist_req cl;\n\tstruct cmtp_conninfo ci;\n\tstruct socket *nsock;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\n\tswitch (cmd) {\n\tcase CMTPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n\t\t\tsockfd_put(nsock);\n\t\t\treturn -EBADFD;\n\t\t}\n\n\t\terr = cmtp_add_connection(&ca, nsock);\n\t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\n\t\treturn err;\n\n\tcase CMTPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn cmtp_del_connection(&cd);\n\n\tcase CMTPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = cmtp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase CMTPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = cmtp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cmtp_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\treturn do_cmtp_sock_ioctl(sock, cmd, (void __user *)arg);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int cmtp_sock_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tif (cmd == CMTPGETCONNLIST) {\n\t\tstruct cmtp_connlist_req cl;\n\t\tu32 __user *p = argp;\n\t\tu32 uci;\n\t\tint err;\n\n\t\tif (get_user(cl.cnum, p) || get_user(uci, p + 1))\n\t\t\treturn -EFAULT;\n\n\t\tcl.ci = compat_ptr(uci);\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = cmtp_get_connlist(&cl);\n\n\t\tif (!err && put_user(cl.cnum, p))\n\t\t\terr = -EFAULT;\n\n\t\treturn err;\n\t}\n\n\treturn do_cmtp_sock_ioctl(sock, cmd, argp);\n}\n#endif\n\nstatic const struct proto_ops cmtp_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= cmtp_sock_release,\n\t.ioctl\t\t= cmtp_sock_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= cmtp_sock_compat_ioctl,\n#endif\n\t.bind\t\t= sock_no_bind,\n\t.getname\t= sock_no_getname,\n\t.sendmsg\t= sock_no_sendmsg,\n\t.recvmsg\t= sock_no_recvmsg,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.connect\t= sock_no_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.mmap\t\t= sock_no_mmap\n};\n\nstatic struct proto cmtp_proto = {\n\t.name\t\t= \"CMTP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct bt_sock)\n};\n\nstatic int cmtp_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t    int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, GFP_ATOMIC, &cmtp_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\n\tsock->ops = &cmtp_sock_ops;\n\n\tsock->state = SS_UNCONNECTED;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = BT_OPEN;\n\n\tbt_sock_link(&cmtp_sk_list, sk);\n\n\treturn 0;\n}\n\nstatic const struct net_proto_family cmtp_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= cmtp_sock_create\n};\n\nint cmtp_init_sockets(void)\n{\n\tint err;\n\n\terr = proto_register(&cmtp_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_CMTP, &cmtp_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"Can't register CMTP socket\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"cmtp\", &cmtp_sk_list, NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create CMTP proc file\");\n\t\tbt_sock_unregister(BTPROTO_HIDP);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"CMTP socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&cmtp_proto);\n\treturn err;\n}\n\nvoid cmtp_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"cmtp\");\n\tbt_sock_unregister(BTPROTO_CMTP);\n\tproto_unregister(&cmtp_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}