{
  "module_name": "capi.c",
  "hash_id": "8cc93de601490927df631c088ca97aae2986ea330b06ef41cb9803b7d2281de9",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/cmtp/capi.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fcntl.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/ioctl.h>\n#include <linux/file.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <net/sock.h>\n\n#include <linux/isdn/capilli.h>\n#include <linux/isdn/capicmd.h>\n#include <linux/isdn/capiutil.h>\n\n#include \"cmtp.h\"\n\n#define CAPI_INTEROPERABILITY\t\t0x20\n\n#define CAPI_INTEROPERABILITY_REQ\tCAPICMD(CAPI_INTEROPERABILITY, CAPI_REQ)\n#define CAPI_INTEROPERABILITY_CONF\tCAPICMD(CAPI_INTEROPERABILITY, CAPI_CONF)\n#define CAPI_INTEROPERABILITY_IND\tCAPICMD(CAPI_INTEROPERABILITY, CAPI_IND)\n#define CAPI_INTEROPERABILITY_RESP\tCAPICMD(CAPI_INTEROPERABILITY, CAPI_RESP)\n\n#define CAPI_INTEROPERABILITY_REQ_LEN\t(CAPI_MSG_BASELEN + 2)\n#define CAPI_INTEROPERABILITY_CONF_LEN\t(CAPI_MSG_BASELEN + 4)\n#define CAPI_INTEROPERABILITY_IND_LEN\t(CAPI_MSG_BASELEN + 2)\n#define CAPI_INTEROPERABILITY_RESP_LEN\t(CAPI_MSG_BASELEN + 2)\n\n#define CAPI_FUNCTION_REGISTER\t\t0\n#define CAPI_FUNCTION_RELEASE\t\t1\n#define CAPI_FUNCTION_GET_PROFILE\t2\n#define CAPI_FUNCTION_GET_MANUFACTURER\t3\n#define CAPI_FUNCTION_GET_VERSION\t4\n#define CAPI_FUNCTION_GET_SERIAL_NUMBER\t5\n#define CAPI_FUNCTION_MANUFACTURER\t6\n#define CAPI_FUNCTION_LOOPBACK\t\t7\n\n\n#define CMTP_MSGNUM\t1\n#define CMTP_APPLID\t2\n#define CMTP_MAPPING\t3\n\nstatic struct cmtp_application *cmtp_application_add(struct cmtp_session *session, __u16 appl)\n{\n\tstruct cmtp_application *app = kzalloc(sizeof(*app), GFP_KERNEL);\n\n\tBT_DBG(\"session %p application %p appl %u\", session, app, appl);\n\n\tif (!app)\n\t\treturn NULL;\n\n\tapp->state = BT_OPEN;\n\tapp->appl = appl;\n\n\tlist_add_tail(&app->list, &session->applications);\n\n\treturn app;\n}\n\nstatic void cmtp_application_del(struct cmtp_session *session, struct cmtp_application *app)\n{\n\tBT_DBG(\"session %p application %p\", session, app);\n\n\tif (app) {\n\t\tlist_del(&app->list);\n\t\tkfree(app);\n\t}\n}\n\nstatic struct cmtp_application *cmtp_application_get(struct cmtp_session *session, int pattern, __u16 value)\n{\n\tstruct cmtp_application *app;\n\n\tlist_for_each_entry(app, &session->applications, list) {\n\t\tswitch (pattern) {\n\t\tcase CMTP_MSGNUM:\n\t\t\tif (app->msgnum == value)\n\t\t\t\treturn app;\n\t\t\tbreak;\n\t\tcase CMTP_APPLID:\n\t\t\tif (app->appl == value)\n\t\t\t\treturn app;\n\t\t\tbreak;\n\t\tcase CMTP_MAPPING:\n\t\t\tif (app->mapping == value)\n\t\t\t\treturn app;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int cmtp_msgnum_get(struct cmtp_session *session)\n{\n\tsession->msgnum++;\n\n\tif ((session->msgnum & 0xff) > 200)\n\t\tsession->msgnum = CMTP_INITIAL_MSGNUM + 1;\n\n\treturn session->msgnum;\n}\n\nstatic void cmtp_send_capimsg(struct cmtp_session *session, struct sk_buff *skb)\n{\n\tstruct cmtp_scb *scb = (void *) skb->cb;\n\n\tBT_DBG(\"session %p skb %p len %u\", session, skb, skb->len);\n\n\tscb->id = -1;\n\tscb->data = (CAPIMSG_COMMAND(skb->data) == CAPI_DATA_B3);\n\n\tskb_queue_tail(&session->transmit, skb);\n\n\twake_up_interruptible(sk_sleep(session->sock->sk));\n}\n\nstatic void cmtp_send_interopmsg(struct cmtp_session *session,\n\t\t\t\t\t__u8 subcmd, __u16 appl, __u16 msgnum,\n\t\t\t\t\t__u16 function, unsigned char *buf, int len)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *s;\n\n\tBT_DBG(\"session %p subcmd 0x%02x appl %u msgnum %u\", session, subcmd, appl, msgnum);\n\n\tskb = alloc_skb(CAPI_MSG_BASELEN + 6 + len, GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR(\"Can't allocate memory for interoperability packet\");\n\t\treturn;\n\t}\n\n\ts = skb_put(skb, CAPI_MSG_BASELEN + 6 + len);\n\n\tcapimsg_setu16(s, 0, CAPI_MSG_BASELEN + 6 + len);\n\tcapimsg_setu16(s, 2, appl);\n\tcapimsg_setu8 (s, 4, CAPI_INTEROPERABILITY);\n\tcapimsg_setu8 (s, 5, subcmd);\n\tcapimsg_setu16(s, 6, msgnum);\n\n\t \n\tcapimsg_setu16(s, 8, 0x0001);\n\n\tcapimsg_setu8 (s, 10, 3 + len);\n\tcapimsg_setu16(s, 11, function);\n\tcapimsg_setu8 (s, 13, len);\n\n\tif (len > 0)\n\t\tmemcpy(s + 14, buf, len);\n\n\tcmtp_send_capimsg(session, skb);\n}\n\nstatic void cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb)\n{\n\tstruct capi_ctr *ctrl = &session->ctrl;\n\tstruct cmtp_application *application;\n\t__u16 appl, msgnum, func, info;\n\t__u32 controller;\n\n\tBT_DBG(\"session %p skb %p len %u\", session, skb, skb->len);\n\n\tswitch (CAPIMSG_SUBCOMMAND(skb->data)) {\n\tcase CAPI_CONF:\n\t\tif (skb->len < CAPI_MSG_BASELEN + 10)\n\t\t\tbreak;\n\n\t\tfunc = CAPIMSG_U16(skb->data, CAPI_MSG_BASELEN + 5);\n\t\tinfo = CAPIMSG_U16(skb->data, CAPI_MSG_BASELEN + 8);\n\n\t\tswitch (func) {\n\t\tcase CAPI_FUNCTION_REGISTER:\n\t\t\tmsgnum = CAPIMSG_MSGID(skb->data);\n\n\t\t\tapplication = cmtp_application_get(session, CMTP_MSGNUM, msgnum);\n\t\t\tif (application) {\n\t\t\t\tapplication->state = BT_CONNECTED;\n\t\t\t\tapplication->msgnum = 0;\n\t\t\t\tapplication->mapping = CAPIMSG_APPID(skb->data);\n\t\t\t\twake_up_interruptible(&session->wait);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CAPI_FUNCTION_RELEASE:\n\t\t\tappl = CAPIMSG_APPID(skb->data);\n\n\t\t\tapplication = cmtp_application_get(session, CMTP_MAPPING, appl);\n\t\t\tif (application) {\n\t\t\t\tapplication->state = BT_CLOSED;\n\t\t\t\tapplication->msgnum = 0;\n\t\t\t\twake_up_interruptible(&session->wait);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CAPI_FUNCTION_GET_PROFILE:\n\t\t\tif (skb->len < CAPI_MSG_BASELEN + 11 + sizeof(capi_profile))\n\t\t\t\tbreak;\n\n\t\t\tcontroller = CAPIMSG_U16(skb->data, CAPI_MSG_BASELEN + 11);\n\t\t\tmsgnum = CAPIMSG_MSGID(skb->data);\n\n\t\t\tif (!info && (msgnum == CMTP_INITIAL_MSGNUM)) {\n\t\t\t\tsession->ncontroller = controller;\n\t\t\t\twake_up_interruptible(&session->wait);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!info && ctrl) {\n\t\t\t\tmemcpy(&ctrl->profile,\n\t\t\t\t\tskb->data + CAPI_MSG_BASELEN + 11,\n\t\t\t\t\tsizeof(capi_profile));\n\t\t\t\tsession->state = BT_CONNECTED;\n\t\t\t\tcapi_ctr_ready(ctrl);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CAPI_FUNCTION_GET_MANUFACTURER:\n\t\t\tif (skb->len < CAPI_MSG_BASELEN + 15)\n\t\t\t\tbreak;\n\n\t\t\tif (!info && ctrl) {\n\t\t\t\tint len = min_t(uint, CAPI_MANUFACTURER_LEN,\n\t\t\t\t\t\tskb->data[CAPI_MSG_BASELEN + 14]);\n\n\t\t\t\tmemset(ctrl->manu, 0, CAPI_MANUFACTURER_LEN);\n\t\t\t\tstrncpy(ctrl->manu,\n\t\t\t\t\tskb->data + CAPI_MSG_BASELEN + 15, len);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CAPI_FUNCTION_GET_VERSION:\n\t\t\tif (skb->len < CAPI_MSG_BASELEN + 32)\n\t\t\t\tbreak;\n\n\t\t\tif (!info && ctrl) {\n\t\t\t\tctrl->version.majorversion = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 16);\n\t\t\t\tctrl->version.minorversion = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 20);\n\t\t\t\tctrl->version.majormanuversion = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 24);\n\t\t\t\tctrl->version.minormanuversion = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 28);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CAPI_FUNCTION_GET_SERIAL_NUMBER:\n\t\t\tif (skb->len < CAPI_MSG_BASELEN + 17)\n\t\t\t\tbreak;\n\n\t\t\tif (!info && ctrl) {\n\t\t\t\tint len = min_t(uint, CAPI_SERIAL_LEN,\n\t\t\t\t\t\tskb->data[CAPI_MSG_BASELEN + 16]);\n\n\t\t\t\tmemset(ctrl->serial, 0, CAPI_SERIAL_LEN);\n\t\t\t\tstrncpy(ctrl->serial,\n\t\t\t\t\tskb->data + CAPI_MSG_BASELEN + 17, len);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase CAPI_IND:\n\t\tif (skb->len < CAPI_MSG_BASELEN + 6)\n\t\t\tbreak;\n\n\t\tfunc = CAPIMSG_U16(skb->data, CAPI_MSG_BASELEN + 3);\n\n\t\tif (func == CAPI_FUNCTION_LOOPBACK) {\n\t\t\tint len = min_t(uint, skb->len - CAPI_MSG_BASELEN - 6,\n\t\t\t\t\t\tskb->data[CAPI_MSG_BASELEN + 5]);\n\t\t\tappl = CAPIMSG_APPID(skb->data);\n\t\t\tmsgnum = CAPIMSG_MSGID(skb->data);\n\t\t\tcmtp_send_interopmsg(session, CAPI_RESP, appl, msgnum, func,\n\t\t\t\t\t\tskb->data + CAPI_MSG_BASELEN + 6, len);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tkfree_skb(skb);\n}\n\nvoid cmtp_recv_capimsg(struct cmtp_session *session, struct sk_buff *skb)\n{\n\tstruct capi_ctr *ctrl = &session->ctrl;\n\tstruct cmtp_application *application;\n\t__u16 appl;\n\t__u32 contr;\n\n\tBT_DBG(\"session %p skb %p len %u\", session, skb, skb->len);\n\n\tif (skb->len < CAPI_MSG_BASELEN)\n\t\treturn;\n\n\tif (CAPIMSG_COMMAND(skb->data) == CAPI_INTEROPERABILITY) {\n\t\tcmtp_recv_interopmsg(session, skb);\n\t\treturn;\n\t}\n\n\tif (session->flags & BIT(CMTP_LOOPBACK)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tappl = CAPIMSG_APPID(skb->data);\n\tcontr = CAPIMSG_CONTROL(skb->data);\n\n\tapplication = cmtp_application_get(session, CMTP_MAPPING, appl);\n\tif (application) {\n\t\tappl = application->appl;\n\t\tCAPIMSG_SETAPPID(skb->data, appl);\n\t} else {\n\t\tBT_ERR(\"Can't find application with id %u\", appl);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif ((contr & 0x7f) == 0x01) {\n\t\tcontr = (contr & 0xffffff80) | session->num;\n\t\tCAPIMSG_SETCONTROL(skb->data, contr);\n\t}\n\n\tcapi_ctr_handle_message(ctrl, appl, skb);\n}\n\nstatic int cmtp_load_firmware(struct capi_ctr *ctrl, capiloaddata *data)\n{\n\tBT_DBG(\"ctrl %p data %p\", ctrl, data);\n\n\treturn 0;\n}\n\nstatic void cmtp_reset_ctr(struct capi_ctr *ctrl)\n{\n\tstruct cmtp_session *session = ctrl->driverdata;\n\n\tBT_DBG(\"ctrl %p\", ctrl);\n\n\tcapi_ctr_down(ctrl);\n\n\tatomic_inc(&session->terminate);\n\twake_up_process(session->task);\n}\n\nstatic void cmtp_register_appl(struct capi_ctr *ctrl, __u16 appl, capi_register_params *rp)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct cmtp_session *session = ctrl->driverdata;\n\tstruct cmtp_application *application;\n\tunsigned long timeo = CMTP_INTEROP_TIMEOUT;\n\tunsigned char buf[8];\n\tint err = 0, nconn, want = rp->level3cnt;\n\n\tBT_DBG(\"ctrl %p appl %u level3cnt %u datablkcnt %u datablklen %u\",\n\t       ctrl, appl, rp->level3cnt, rp->datablkcnt, rp->datablklen);\n\n\tapplication = cmtp_application_add(session, appl);\n\tif (!application) {\n\t\tBT_ERR(\"Can't allocate memory for new application\");\n\t\treturn;\n\t}\n\n\tif (want < 0)\n\t\tnconn = ctrl->profile.nbchannel * -want;\n\telse\n\t\tnconn = want;\n\n\tif (nconn == 0)\n\t\tnconn = ctrl->profile.nbchannel;\n\n\tcapimsg_setu16(buf, 0, nconn);\n\tcapimsg_setu16(buf, 2, rp->datablkcnt);\n\tcapimsg_setu16(buf, 4, rp->datablklen);\n\n\tapplication->state = BT_CONFIG;\n\tapplication->msgnum = cmtp_msgnum_get(session);\n\n\tcmtp_send_interopmsg(session, CAPI_REQ, 0x0000, application->msgnum,\n\t\t\t\tCAPI_FUNCTION_REGISTER, buf, 6);\n\n\tadd_wait_queue(&session->wait, &wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (application->state == BT_CLOSED) {\n\t\t\terr = -application->err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (application->state == BT_CONNECTED)\n\t\t\tbreak;\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\ttimeo = schedule_timeout(timeo);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&session->wait, &wait);\n\n\tif (err) {\n\t\tcmtp_application_del(session, application);\n\t\treturn;\n\t}\n}\n\nstatic void cmtp_release_appl(struct capi_ctr *ctrl, __u16 appl)\n{\n\tstruct cmtp_session *session = ctrl->driverdata;\n\tstruct cmtp_application *application;\n\n\tBT_DBG(\"ctrl %p appl %u\", ctrl, appl);\n\n\tapplication = cmtp_application_get(session, CMTP_APPLID, appl);\n\tif (!application) {\n\t\tBT_ERR(\"Can't find application\");\n\t\treturn;\n\t}\n\n\tapplication->msgnum = cmtp_msgnum_get(session);\n\n\tcmtp_send_interopmsg(session, CAPI_REQ, application->mapping, application->msgnum,\n\t\t\t\tCAPI_FUNCTION_RELEASE, NULL, 0);\n\n\twait_event_interruptible_timeout(session->wait,\n\t\t\t(application->state == BT_CLOSED), CMTP_INTEROP_TIMEOUT);\n\n\tcmtp_application_del(session, application);\n}\n\nstatic u16 cmtp_send_message(struct capi_ctr *ctrl, struct sk_buff *skb)\n{\n\tstruct cmtp_session *session = ctrl->driverdata;\n\tstruct cmtp_application *application;\n\t__u16 appl;\n\t__u32 contr;\n\n\tBT_DBG(\"ctrl %p skb %p\", ctrl, skb);\n\n\tappl = CAPIMSG_APPID(skb->data);\n\tcontr = CAPIMSG_CONTROL(skb->data);\n\n\tapplication = cmtp_application_get(session, CMTP_APPLID, appl);\n\tif ((!application) || (application->state != BT_CONNECTED)) {\n\t\tBT_ERR(\"Can't find application with id %u\", appl);\n\t\treturn CAPI_ILLAPPNR;\n\t}\n\n\tCAPIMSG_SETAPPID(skb->data, application->mapping);\n\n\tif ((contr & 0x7f) == session->num) {\n\t\tcontr = (contr & 0xffffff80) | 0x01;\n\t\tCAPIMSG_SETCONTROL(skb->data, contr);\n\t}\n\n\tcmtp_send_capimsg(session, skb);\n\n\treturn CAPI_NOERROR;\n}\n\nstatic char *cmtp_procinfo(struct capi_ctr *ctrl)\n{\n\treturn \"CAPI Message Transport Protocol\";\n}\n\nstatic int cmtp_proc_show(struct seq_file *m, void *v)\n{\n\tstruct capi_ctr *ctrl = m->private;\n\tstruct cmtp_session *session = ctrl->driverdata;\n\tstruct cmtp_application *app;\n\n\tseq_printf(m, \"%s\\n\\n\", cmtp_procinfo(ctrl));\n\tseq_printf(m, \"addr %s\\n\", session->name);\n\tseq_printf(m, \"ctrl %d\\n\", session->num);\n\n\tlist_for_each_entry(app, &session->applications, list) {\n\t\tseq_printf(m, \"appl %u -> %u\\n\", app->appl, app->mapping);\n\t}\n\n\treturn 0;\n}\n\nint cmtp_attach_device(struct cmtp_session *session)\n{\n\tunsigned char buf[4];\n\tlong ret;\n\n\tBT_DBG(\"session %p\", session);\n\n\tcapimsg_setu32(buf, 0, 0);\n\n\tcmtp_send_interopmsg(session, CAPI_REQ, 0xffff, CMTP_INITIAL_MSGNUM,\n\t\t\t\tCAPI_FUNCTION_GET_PROFILE, buf, 4);\n\n\tret = wait_event_interruptible_timeout(session->wait,\n\t\t\tsession->ncontroller, CMTP_INTEROP_TIMEOUT);\n\n\tBT_INFO(\"Found %d CAPI controller(s) on device %s\", session->ncontroller, session->name);\n\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tif (!session->ncontroller)\n\t\treturn -ENODEV;\n\n\tif (session->ncontroller > 1)\n\t\tBT_INFO(\"Setting up only CAPI controller 1\");\n\n\tsession->ctrl.owner      = THIS_MODULE;\n\tsession->ctrl.driverdata = session;\n\tstrcpy(session->ctrl.name, session->name);\n\n\tsession->ctrl.driver_name   = \"cmtp\";\n\tsession->ctrl.load_firmware = cmtp_load_firmware;\n\tsession->ctrl.reset_ctr     = cmtp_reset_ctr;\n\tsession->ctrl.register_appl = cmtp_register_appl;\n\tsession->ctrl.release_appl  = cmtp_release_appl;\n\tsession->ctrl.send_message  = cmtp_send_message;\n\n\tsession->ctrl.procinfo      = cmtp_procinfo;\n\tsession->ctrl.proc_show     = cmtp_proc_show;\n\n\tif (attach_capi_ctr(&session->ctrl) < 0) {\n\t\tBT_ERR(\"Can't attach new controller\");\n\t\treturn -EBUSY;\n\t}\n\n\tsession->num = session->ctrl.cnr;\n\n\tBT_DBG(\"session %p num %d\", session, session->num);\n\n\tcapimsg_setu32(buf, 0, 1);\n\n\tcmtp_send_interopmsg(session, CAPI_REQ, 0xffff, cmtp_msgnum_get(session),\n\t\t\t\tCAPI_FUNCTION_GET_MANUFACTURER, buf, 4);\n\n\tcmtp_send_interopmsg(session, CAPI_REQ, 0xffff, cmtp_msgnum_get(session),\n\t\t\t\tCAPI_FUNCTION_GET_VERSION, buf, 4);\n\n\tcmtp_send_interopmsg(session, CAPI_REQ, 0xffff, cmtp_msgnum_get(session),\n\t\t\t\tCAPI_FUNCTION_GET_SERIAL_NUMBER, buf, 4);\n\n\tcmtp_send_interopmsg(session, CAPI_REQ, 0xffff, cmtp_msgnum_get(session),\n\t\t\t\tCAPI_FUNCTION_GET_PROFILE, buf, 4);\n\n\treturn 0;\n}\n\nvoid cmtp_detach_device(struct cmtp_session *session)\n{\n\tBT_DBG(\"session %p\", session);\n\n\tdetach_capi_ctr(&session->ctrl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}