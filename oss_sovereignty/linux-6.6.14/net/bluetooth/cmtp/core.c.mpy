{
  "module_name": "core.c",
  "hash_id": "004ce432a9b9d5c129ccffa9edd054f268930fbf8adf94d48782736c157b380c",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/cmtp/core.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fcntl.h>\n#include <linux/freezer.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/ioctl.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <net/sock.h>\n\n#include <linux/isdn/capilli.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"cmtp.h\"\n\n#define VERSION \"1.0\"\n\nstatic DECLARE_RWSEM(cmtp_session_sem);\nstatic LIST_HEAD(cmtp_session_list);\n\nstatic struct cmtp_session *__cmtp_get_session(bdaddr_t *bdaddr)\n{\n\tstruct cmtp_session *session;\n\n\tBT_DBG(\"\");\n\n\tlist_for_each_entry(session, &cmtp_session_list, list)\n\t\tif (!bacmp(bdaddr, &session->bdaddr))\n\t\t\treturn session;\n\n\treturn NULL;\n}\n\nstatic void __cmtp_link_session(struct cmtp_session *session)\n{\n\tlist_add(&session->list, &cmtp_session_list);\n}\n\nstatic void __cmtp_unlink_session(struct cmtp_session *session)\n{\n\tlist_del(&session->list);\n}\n\nstatic void __cmtp_copy_session(struct cmtp_session *session, struct cmtp_conninfo *ci)\n{\n\tu32 valid_flags = BIT(CMTP_LOOPBACK);\n\tmemset(ci, 0, sizeof(*ci));\n\tbacpy(&ci->bdaddr, &session->bdaddr);\n\n\tci->flags = session->flags & valid_flags;\n\tci->state = session->state;\n\n\tci->num = session->num;\n}\n\n\nstatic inline int cmtp_alloc_block_id(struct cmtp_session *session)\n{\n\tint i, id = -1;\n\n\tfor (i = 0; i < 16; i++)\n\t\tif (!test_and_set_bit(i, &session->blockids)) {\n\t\t\tid = i;\n\t\t\tbreak;\n\t\t}\n\n\treturn id;\n}\n\nstatic inline void cmtp_free_block_id(struct cmtp_session *session, int id)\n{\n\tclear_bit(id, &session->blockids);\n}\n\nstatic inline void cmtp_add_msgpart(struct cmtp_session *session, int id, const unsigned char *buf, int count)\n{\n\tstruct sk_buff *skb = session->reassembly[id], *nskb;\n\tint size;\n\n\tBT_DBG(\"session %p buf %p count %d\", session, buf, count);\n\n\tsize = (skb) ? skb->len + count : count;\n\n\tnskb = alloc_skb(size, GFP_ATOMIC);\n\tif (!nskb) {\n\t\tBT_ERR(\"Can't allocate memory for CAPI message\");\n\t\treturn;\n\t}\n\n\tif (skb && (skb->len > 0))\n\t\tskb_copy_from_linear_data(skb, skb_put(nskb, skb->len), skb->len);\n\n\tskb_put_data(nskb, buf, count);\n\n\tsession->reassembly[id] = nskb;\n\n\tkfree_skb(skb);\n}\n\nstatic inline int cmtp_recv_frame(struct cmtp_session *session, struct sk_buff *skb)\n{\n\t__u8 hdr, hdrlen, id;\n\t__u16 len;\n\n\tBT_DBG(\"session %p skb %p len %d\", session, skb, skb->len);\n\n\twhile (skb->len > 0) {\n\t\thdr = skb->data[0];\n\n\t\tswitch (hdr & 0xc0) {\n\t\tcase 0x40:\n\t\t\thdrlen = 2;\n\t\t\tlen = skb->data[1];\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\thdrlen = 3;\n\t\t\tlen = skb->data[1] | (skb->data[2] << 8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thdrlen = 1;\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tid = (hdr & 0x3c) >> 2;\n\n\t\tBT_DBG(\"hdr 0x%02x hdrlen %d len %d id %d\", hdr, hdrlen, len, id);\n\n\t\tif (hdrlen + len > skb->len) {\n\t\t\tBT_ERR(\"Wrong size or header information in CMTP frame\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (len == 0) {\n\t\t\tskb_pull(skb, hdrlen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (hdr & 0x03) {\n\t\tcase 0x00:\n\t\t\tcmtp_add_msgpart(session, id, skb->data + hdrlen, len);\n\t\t\tcmtp_recv_capimsg(session, session->reassembly[id]);\n\t\t\tsession->reassembly[id] = NULL;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tcmtp_add_msgpart(session, id, skb->data + hdrlen, len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkfree_skb(session->reassembly[id]);\n\t\t\tsession->reassembly[id] = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tskb_pull(skb, hdrlen + len);\n\t}\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int cmtp_send_frame(struct cmtp_session *session, unsigned char *data, int len)\n{\n\tstruct socket *sock = session->sock;\n\tstruct kvec iv = { data, len };\n\tstruct msghdr msg;\n\n\tBT_DBG(\"session %p data %p len %d\", session, data, len);\n\n\tif (!len)\n\t\treturn 0;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\treturn kernel_sendmsg(sock, &msg, &iv, 1, len);\n}\n\nstatic void cmtp_process_transmit(struct cmtp_session *session)\n{\n\tstruct sk_buff *skb, *nskb;\n\tunsigned char *hdr;\n\tunsigned int size, tail;\n\n\tBT_DBG(\"session %p\", session);\n\n\tnskb = alloc_skb(session->mtu, GFP_ATOMIC);\n\tif (!nskb) {\n\t\tBT_ERR(\"Can't allocate memory for new frame\");\n\t\treturn;\n\t}\n\n\twhile ((skb = skb_dequeue(&session->transmit))) {\n\t\tstruct cmtp_scb *scb = (void *) skb->cb;\n\n\t\ttail = session->mtu - nskb->len;\n\t\tif (tail < 5) {\n\t\t\tcmtp_send_frame(session, nskb->data, nskb->len);\n\t\t\tskb_trim(nskb, 0);\n\t\t\ttail = session->mtu;\n\t\t}\n\n\t\tsize = min_t(uint, ((tail < 258) ? (tail - 2) : (tail - 3)), skb->len);\n\n\t\tif (scb->id < 0) {\n\t\t\tscb->id = cmtp_alloc_block_id(session);\n\t\t\tif (scb->id < 0) {\n\t\t\t\tskb_queue_head(&session->transmit, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (size < 256) {\n\t\t\thdr = skb_put(nskb, 2);\n\t\t\thdr[0] = 0x40\n\t\t\t\t| ((scb->id << 2) & 0x3c)\n\t\t\t\t| ((skb->len == size) ? 0x00 : 0x01);\n\t\t\thdr[1] = size;\n\t\t} else {\n\t\t\thdr = skb_put(nskb, 3);\n\t\t\thdr[0] = 0x80\n\t\t\t\t| ((scb->id << 2) & 0x3c)\n\t\t\t\t| ((skb->len == size) ? 0x00 : 0x01);\n\t\t\thdr[1] = size & 0xff;\n\t\t\thdr[2] = size >> 8;\n\t\t}\n\n\t\tskb_copy_from_linear_data(skb, skb_put(nskb, size), size);\n\t\tskb_pull(skb, size);\n\n\t\tif (skb->len > 0) {\n\t\t\tskb_queue_head(&session->transmit, skb);\n\t\t} else {\n\t\t\tcmtp_free_block_id(session, scb->id);\n\t\t\tif (scb->data) {\n\t\t\t\tcmtp_send_frame(session, nskb->data, nskb->len);\n\t\t\t\tskb_trim(nskb, 0);\n\t\t\t}\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\tcmtp_send_frame(session, nskb->data, nskb->len);\n\n\tkfree_skb(nskb);\n}\n\nstatic int cmtp_session(void *arg)\n{\n\tstruct cmtp_session *session = arg;\n\tstruct sock *sk = session->sock->sk;\n\tstruct sk_buff *skb;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tBT_DBG(\"session %p\", session);\n\n\tset_user_nice(current, -15);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (atomic_read(&session->terminate))\n\t\t\tbreak;\n\t\tif (sk->sk_state != BT_CONNECTED)\n\t\t\tbreak;\n\n\t\twhile ((skb = skb_dequeue(&sk->sk_receive_queue))) {\n\t\t\tskb_orphan(skb);\n\t\t\tif (!skb_linearize(skb))\n\t\t\t\tcmtp_recv_frame(session, skb);\n\t\t\telse\n\t\t\t\tkfree_skb(skb);\n\t\t}\n\n\t\tcmtp_process_transmit(session);\n\n\t\t \n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tdown_write(&cmtp_session_sem);\n\n\tif (!(session->flags & BIT(CMTP_LOOPBACK)))\n\t\tcmtp_detach_device(session);\n\n\tfput(session->sock->file);\n\n\t__cmtp_unlink_session(session);\n\n\tup_write(&cmtp_session_sem);\n\n\tkfree(session);\n\tmodule_put_and_kthread_exit(0);\n\treturn 0;\n}\n\nint cmtp_add_connection(struct cmtp_connadd_req *req, struct socket *sock)\n{\n\tu32 valid_flags = BIT(CMTP_LOOPBACK);\n\tstruct cmtp_session *session, *s;\n\tint i, err;\n\n\tBT_DBG(\"\");\n\n\tif (!l2cap_is_socket(sock))\n\t\treturn -EBADFD;\n\n\tif (req->flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\tsession = kzalloc(sizeof(struct cmtp_session), GFP_KERNEL);\n\tif (!session)\n\t\treturn -ENOMEM;\n\n\tdown_write(&cmtp_session_sem);\n\n\ts = __cmtp_get_session(&l2cap_pi(sock->sk)->chan->dst);\n\tif (s && s->state == BT_CONNECTED) {\n\t\terr = -EEXIST;\n\t\tgoto failed;\n\t}\n\n\tbacpy(&session->bdaddr, &l2cap_pi(sock->sk)->chan->dst);\n\n\tsession->mtu = min_t(uint, l2cap_pi(sock->sk)->chan->omtu,\n\t\t\t\t\tl2cap_pi(sock->sk)->chan->imtu);\n\n\tBT_DBG(\"mtu %d\", session->mtu);\n\n\tsprintf(session->name, \"%pMR\", &session->bdaddr);\n\n\tsession->sock  = sock;\n\tsession->state = BT_CONFIG;\n\n\tinit_waitqueue_head(&session->wait);\n\n\tsession->msgnum = CMTP_INITIAL_MSGNUM;\n\n\tINIT_LIST_HEAD(&session->applications);\n\n\tskb_queue_head_init(&session->transmit);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsession->reassembly[i] = NULL;\n\n\tsession->flags = req->flags;\n\n\t__cmtp_link_session(session);\n\n\t__module_get(THIS_MODULE);\n\tsession->task = kthread_run(cmtp_session, session, \"kcmtpd_ctr_%d\",\n\t\t\t\t\t\t\t\tsession->num);\n\tif (IS_ERR(session->task)) {\n\t\tmodule_put(THIS_MODULE);\n\t\terr = PTR_ERR(session->task);\n\t\tgoto unlink;\n\t}\n\n\tif (!(session->flags & BIT(CMTP_LOOPBACK))) {\n\t\terr = cmtp_attach_device(session);\n\t\tif (err < 0) {\n\t\t\t \n\t\t\tget_file(session->sock->file);\n\n\t\t\tatomic_inc(&session->terminate);\n\t\t\twake_up_interruptible(sk_sleep(session->sock->sk));\n\t\t\tup_write(&cmtp_session_sem);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tup_write(&cmtp_session_sem);\n\treturn 0;\n\nunlink:\n\t__cmtp_unlink_session(session);\n\nfailed:\n\tup_write(&cmtp_session_sem);\n\tkfree(session);\n\treturn err;\n}\n\nint cmtp_del_connection(struct cmtp_conndel_req *req)\n{\n\tu32 valid_flags = 0;\n\tstruct cmtp_session *session;\n\tint err = 0;\n\n\tBT_DBG(\"\");\n\n\tif (req->flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\tdown_read(&cmtp_session_sem);\n\n\tsession = __cmtp_get_session(&req->bdaddr);\n\tif (session) {\n\t\t \n\t\tskb_queue_purge(&session->transmit);\n\n\t\t \n\t\tatomic_inc(&session->terminate);\n\n\t\t \n\t\twake_up_interruptible(sk_sleep(session->sock->sk));\n\t} else\n\t\terr = -ENOENT;\n\n\tup_read(&cmtp_session_sem);\n\treturn err;\n}\n\nint cmtp_get_connlist(struct cmtp_connlist_req *req)\n{\n\tstruct cmtp_session *session;\n\tint err = 0, n = 0;\n\n\tBT_DBG(\"\");\n\n\tdown_read(&cmtp_session_sem);\n\n\tlist_for_each_entry(session, &cmtp_session_list, list) {\n\t\tstruct cmtp_conninfo ci;\n\n\t\t__cmtp_copy_session(session, &ci);\n\n\t\tif (copy_to_user(req->ci, &ci, sizeof(ci))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (++n >= req->cnum)\n\t\t\tbreak;\n\n\t\treq->ci++;\n\t}\n\treq->cnum = n;\n\n\tup_read(&cmtp_session_sem);\n\treturn err;\n}\n\nint cmtp_get_conninfo(struct cmtp_conninfo *ci)\n{\n\tstruct cmtp_session *session;\n\tint err = 0;\n\n\tdown_read(&cmtp_session_sem);\n\n\tsession = __cmtp_get_session(&ci->bdaddr);\n\tif (session)\n\t\t__cmtp_copy_session(session, ci);\n\telse\n\t\terr = -ENOENT;\n\n\tup_read(&cmtp_session_sem);\n\treturn err;\n}\n\n\nstatic int __init cmtp_init(void)\n{\n\tBT_INFO(\"CMTP (CAPI Emulation) ver %s\", VERSION);\n\n\treturn cmtp_init_sockets();\n}\n\nstatic void __exit cmtp_exit(void)\n{\n\tcmtp_cleanup_sockets();\n}\n\nmodule_init(cmtp_init);\nmodule_exit(cmtp_exit);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth CMTP ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"bt-proto-5\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}