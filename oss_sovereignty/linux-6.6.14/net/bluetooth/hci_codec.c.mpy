{
  "module_name": "hci_codec.c",
  "hash_id": "08dd4fe45ddbe02d68ffa2276122efc0f7c31bc1294dc847a005a86904a54a46",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/hci_codec.c",
  "human_readable_source": "\n\n \n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include \"hci_codec.h\"\n\nstatic int hci_codec_list_add(struct list_head *list,\n\t\t\t      struct hci_op_read_local_codec_caps *sent,\n\t\t\t      struct hci_rp_read_local_codec_caps *rp,\n\t\t\t      void *caps,\n\t\t\t      __u32 len)\n{\n\tstruct codec_list *entry;\n\n\tentry = kzalloc(sizeof(*entry) + len, GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->id = sent->id;\n\tif (sent->id == 0xFF) {\n\t\tentry->cid = __le16_to_cpu(sent->cid);\n\t\tentry->vid = __le16_to_cpu(sent->vid);\n\t}\n\tentry->transport = sent->transport;\n\tentry->len = len;\n\tentry->num_caps = 0;\n\tif (rp) {\n\t\tentry->num_caps = rp->num_caps;\n\t\tmemcpy(entry->caps, caps, len);\n\t}\n\tlist_add(&entry->list, list);\n\n\treturn 0;\n}\n\nvoid hci_codec_list_clear(struct list_head *codec_list)\n{\n\tstruct codec_list *c, *n;\n\n\tlist_for_each_entry_safe(c, n, codec_list, list) {\n\t\tlist_del(&c->list);\n\t\tkfree(c);\n\t}\n}\n\nstatic void hci_read_codec_capabilities(struct hci_dev *hdev, __u8 transport,\n\t\t\t\t\tstruct hci_op_read_local_codec_caps\n\t\t\t\t\t*cmd)\n{\n\t__u8 i;\n\n\tfor (i = 0; i < TRANSPORT_TYPE_MAX; i++) {\n\t\tif (transport & BIT(i)) {\n\t\t\tstruct hci_rp_read_local_codec_caps *rp;\n\t\t\tstruct hci_codec_caps *caps;\n\t\t\tstruct sk_buff *skb;\n\t\t\t__u8 j;\n\t\t\t__u32 len;\n\n\t\t\tcmd->transport = i;\n\n\t\t\t \n\t\t\tif (!(hdev->commands[45] & 0x08)) {\n\t\t\t\thci_dev_lock(hdev);\n\t\t\t\thci_codec_list_add(&hdev->local_codecs, cmd,\n\t\t\t\t\t\t   NULL, NULL, 0);\n\t\t\t\thci_dev_unlock(hdev);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tskb = __hci_cmd_sync_sk(hdev, HCI_OP_READ_LOCAL_CODEC_CAPS,\n\t\t\t\t\t\tsizeof(*cmd), cmd, 0, HCI_CMD_TIMEOUT, NULL);\n\t\t\tif (IS_ERR(skb)) {\n\t\t\t\tbt_dev_err(hdev, \"Failed to read codec capabilities (%ld)\",\n\t\t\t\t\t   PTR_ERR(skb));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (skb->len < sizeof(*rp))\n\t\t\t\tgoto error;\n\n\t\t\trp = (void *)skb->data;\n\n\t\t\tif (rp->status)\n\t\t\t\tgoto error;\n\n\t\t\tif (!rp->num_caps) {\n\t\t\t\tlen = 0;\n\t\t\t\t \n\t\t\t\tgoto skip_caps_parse;\n\t\t\t}\n\n\t\t\tskb_pull(skb, sizeof(*rp));\n\n\t\t\tfor (j = 0, len = 0; j < rp->num_caps; j++) {\n\t\t\t\tcaps = (void *)skb->data;\n\t\t\t\tif (skb->len < sizeof(*caps))\n\t\t\t\t\tgoto error;\n\t\t\t\tif (skb->len < caps->len)\n\t\t\t\t\tgoto error;\n\t\t\t\tlen += sizeof(caps->len) + caps->len;\n\t\t\t\tskb_pull(skb,  sizeof(caps->len) + caps->len);\n\t\t\t}\n\nskip_caps_parse:\n\t\t\thci_dev_lock(hdev);\n\t\t\thci_codec_list_add(&hdev->local_codecs, cmd, rp,\n\t\t\t\t\t   (__u8 *)rp + sizeof(*rp), len);\n\t\t\thci_dev_unlock(hdev);\nerror:\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}\n\nvoid hci_read_supported_codecs(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tstruct hci_rp_read_local_supported_codecs *rp;\n\tstruct hci_std_codecs *std_codecs;\n\tstruct hci_vnd_codecs *vnd_codecs;\n\tstruct hci_op_read_local_codec_caps caps;\n\t__u8 i;\n\n\tskb = __hci_cmd_sync_sk(hdev, HCI_OP_READ_LOCAL_CODECS, 0, NULL,\n\t\t\t\t0, HCI_CMD_TIMEOUT, NULL);\n\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Failed to read local supported codecs (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn;\n\t}\n\n\tif (skb->len < sizeof(*rp))\n\t\tgoto error;\n\n\trp = (void *)skb->data;\n\n\tif (rp->status)\n\t\tgoto error;\n\n\tskb_pull(skb, sizeof(rp->status));\n\n\tstd_codecs = (void *)skb->data;\n\n\t \n\tif (skb->len < flex_array_size(std_codecs, codec, std_codecs->num)\n\t    + sizeof(std_codecs->num))\n\t\tgoto error;\n\n\t \n\tmemset(&caps, 0, sizeof(caps));\n\tfor (i = 0; i < std_codecs->num; i++) {\n\t\tcaps.id = std_codecs->codec[i];\n\t\tcaps.direction = 0x00;\n\t\thci_read_codec_capabilities(hdev,\n\t\t\t\t\t    LOCAL_CODEC_ACL_MASK | LOCAL_CODEC_SCO_MASK, &caps);\n\t}\n\n\tskb_pull(skb, flex_array_size(std_codecs, codec, std_codecs->num)\n\t\t + sizeof(std_codecs->num));\n\n\tvnd_codecs = (void *)skb->data;\n\n\t \n\tif (skb->len <\n\t    flex_array_size(vnd_codecs, codec, vnd_codecs->num)\n\t    + sizeof(vnd_codecs->num))\n\t\tgoto error;\n\n\t \n\tfor (i = 0; i < vnd_codecs->num; i++) {\n\t\tcaps.id = 0xFF;\n\t\tcaps.cid = vnd_codecs->codec[i].cid;\n\t\tcaps.vid = vnd_codecs->codec[i].vid;\n\t\tcaps.direction = 0x00;\n\t\thci_read_codec_capabilities(hdev,\n\t\t\t\t\t    LOCAL_CODEC_ACL_MASK | LOCAL_CODEC_SCO_MASK, &caps);\n\t}\n\nerror:\n\tkfree_skb(skb);\n}\n\nvoid hci_read_supported_codecs_v2(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tstruct hci_rp_read_local_supported_codecs_v2 *rp;\n\tstruct hci_std_codecs_v2 *std_codecs;\n\tstruct hci_vnd_codecs_v2 *vnd_codecs;\n\tstruct hci_op_read_local_codec_caps caps;\n\t__u8 i;\n\n\tskb = __hci_cmd_sync_sk(hdev, HCI_OP_READ_LOCAL_CODECS_V2, 0, NULL,\n\t\t\t\t0, HCI_CMD_TIMEOUT, NULL);\n\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Failed to read local supported codecs (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn;\n\t}\n\n\tif (skb->len < sizeof(*rp))\n\t\tgoto error;\n\n\trp = (void *)skb->data;\n\n\tif (rp->status)\n\t\tgoto error;\n\n\tskb_pull(skb, sizeof(rp->status));\n\n\tstd_codecs = (void *)skb->data;\n\n\t \n\tif (skb->len < flex_array_size(std_codecs, codec, std_codecs->num)\n\t    + sizeof(std_codecs->num))\n\t\tgoto error;\n\n\tmemset(&caps, 0, sizeof(caps));\n\n\tfor (i = 0; i < std_codecs->num; i++) {\n\t\tcaps.id = std_codecs->codec[i].id;\n\t\thci_read_codec_capabilities(hdev, std_codecs->codec[i].transport,\n\t\t\t\t\t    &caps);\n\t}\n\n\tskb_pull(skb, flex_array_size(std_codecs, codec, std_codecs->num)\n\t\t + sizeof(std_codecs->num));\n\n\tvnd_codecs = (void *)skb->data;\n\n\t \n\tif (skb->len <\n\t    flex_array_size(vnd_codecs, codec, vnd_codecs->num)\n\t    + sizeof(vnd_codecs->num))\n\t\tgoto error;\n\n\tfor (i = 0; i < vnd_codecs->num; i++) {\n\t\tcaps.id = 0xFF;\n\t\tcaps.cid = vnd_codecs->codec[i].cid;\n\t\tcaps.vid = vnd_codecs->codec[i].vid;\n\t\thci_read_codec_capabilities(hdev, vnd_codecs->codec[i].transport,\n\t\t\t\t\t    &caps);\n\t}\n\nerror:\n\tkfree_skb(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}