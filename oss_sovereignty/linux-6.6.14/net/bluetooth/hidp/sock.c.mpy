{
  "module_name": "sock.c",
  "hash_id": "bc5307ea63ed4e9505593fa1c3726f99e93dcdbdcee9af9a82fd97e3292dc984",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/hidp/sock.c",
  "human_readable_source": " \n\n#include <linux/compat.h>\n#include <linux/export.h>\n#include <linux/file.h>\n\n#include \"hidp.h\"\n\nstatic struct bt_sock_list hidp_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(hidp_sk_list.lock)\n};\n\nstatic int hidp_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tbt_sock_unlink(&hidp_sk_list, sk);\n\n\tsock_orphan(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct hidp_connadd_req ca;\n\tstruct hidp_conndel_req cd;\n\tstruct hidp_connlist_req cl;\n\tstruct hidp_conninfo ci;\n\tstruct socket *csock;\n\tstruct socket *isock;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\n\tswitch (cmd) {\n\tcase HIDPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n\t\t\tsockfd_put(csock);\n\t\t\treturn err;\n\t\t}\n\t\tca.name[sizeof(ca.name)-1] = 0;\n\n\t\terr = hidp_connection_add(&ca, csock, isock);\n\t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\terr = -EFAULT;\n\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\n\t\treturn err;\n\n\tcase HIDPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn hidp_connection_del(&cd);\n\n\tcase HIDPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = hidp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase HIDPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = hidp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int hidp_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\treturn do_hidp_sock_ioctl(sock, cmd, (void __user *)arg);\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_hidp_connadd_req {\n\tint   ctrl_sock;\t \n\tint   intr_sock;\t \n\t__u16 parser;\n\t__u16 rd_size;\n\tcompat_uptr_t rd_data;\n\t__u8  country;\n\t__u8  subclass;\n\t__u16 vendor;\n\t__u16 product;\n\t__u16 version;\n\t__u32 flags;\n\t__u32 idle_to;\n\tchar  name[128];\n};\n\nstatic int hidp_sock_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tint err;\n\n\tif (cmd == HIDPGETCONNLIST) {\n\t\tstruct hidp_connlist_req cl;\n\t\tu32 __user *p = argp;\n\t\tu32 uci;\n\n\t\tif (get_user(cl.cnum, p) || get_user(uci, p + 1))\n\t\t\treturn -EFAULT;\n\n\t\tcl.ci = compat_ptr(uci);\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = hidp_get_connlist(&cl);\n\n\t\tif (!err && put_user(cl.cnum, p))\n\t\t\terr = -EFAULT;\n\n\t\treturn err;\n\t} else if (cmd == HIDPCONNADD) {\n\t\tstruct compat_hidp_connadd_req ca32;\n\t\tstruct hidp_connadd_req ca;\n\t\tstruct socket *csock;\n\t\tstruct socket *isock;\n\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&ca32, (void __user *) arg, sizeof(ca32)))\n\t\t\treturn -EFAULT;\n\n\t\tca.ctrl_sock = ca32.ctrl_sock;\n\t\tca.intr_sock = ca32.intr_sock;\n\t\tca.parser = ca32.parser;\n\t\tca.rd_size = ca32.rd_size;\n\t\tca.rd_data = compat_ptr(ca32.rd_data);\n\t\tca.country = ca32.country;\n\t\tca.subclass = ca32.subclass;\n\t\tca.vendor = ca32.vendor;\n\t\tca.product = ca32.product;\n\t\tca.version = ca32.version;\n\t\tca.flags = ca32.flags;\n\t\tca.idle_to = ca32.idle_to;\n\t\tca32.name[sizeof(ca32.name) - 1] = '\\0';\n\t\tmemcpy(ca.name, ca32.name, 128);\n\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n\t\t\tsockfd_put(csock);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = hidp_connection_add(&ca, csock, isock);\n\t\tif (!err && copy_to_user(argp, &ca32, sizeof(ca32)))\n\t\t\terr = -EFAULT;\n\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\n\t\treturn err;\n\t}\n\n\treturn hidp_sock_ioctl(sock, cmd, arg);\n}\n#endif\n\nstatic const struct proto_ops hidp_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= hidp_sock_release,\n\t.ioctl\t\t= hidp_sock_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= hidp_sock_compat_ioctl,\n#endif\n\t.bind\t\t= sock_no_bind,\n\t.getname\t= sock_no_getname,\n\t.sendmsg\t= sock_no_sendmsg,\n\t.recvmsg\t= sock_no_recvmsg,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.connect\t= sock_no_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.mmap\t\t= sock_no_mmap\n};\n\nstatic struct proto hidp_proto = {\n\t.name\t\t= \"HIDP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct bt_sock)\n};\n\nstatic int hidp_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t    int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = bt_sock_alloc(net, sock, &hidp_proto, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock->ops = &hidp_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\n\tbt_sock_link(&hidp_sk_list, sk);\n\n\treturn 0;\n}\n\nstatic const struct net_proto_family hidp_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= hidp_sock_create\n};\n\nint __init hidp_init_sockets(void)\n{\n\tint err;\n\n\terr = proto_register(&hidp_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_HIDP, &hidp_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"Can't register HIDP socket\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"hidp\", &hidp_sk_list, NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create HIDP proc file\");\n\t\tbt_sock_unregister(BTPROTO_HIDP);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"HIDP socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&hidp_proto);\n\treturn err;\n}\n\nvoid __exit hidp_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"hidp\");\n\tbt_sock_unregister(BTPROTO_HIDP);\n\tproto_unregister(&hidp_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}