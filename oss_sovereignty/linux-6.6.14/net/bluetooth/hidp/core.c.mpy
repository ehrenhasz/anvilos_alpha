{
  "module_name": "core.c",
  "hash_id": "b0277b7fdec5dd2027a15c3caac71ba2900433d6d32fb3d36f550cb366db608d",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/hidp/core.c",
  "human_readable_source": " \n\n#include <linux/kref.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/kthread.h>\n#include <linux/hidraw.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"hidp.h\"\n\n#define VERSION \"1.2\"\n\nstatic DECLARE_RWSEM(hidp_session_sem);\nstatic DECLARE_WAIT_QUEUE_HEAD(hidp_session_wq);\nstatic LIST_HEAD(hidp_session_list);\n\nstatic unsigned char hidp_keycode[256] = {\n\t  0,   0,   0,   0,  30,  48,  46,  32,  18,  33,  34,  35,  23,  36,\n\t 37,  38,  50,  49,  24,  25,  16,  19,  31,  20,  22,  47,  17,  45,\n\t 21,  44,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  28,   1,\n\t 14,  15,  57,  12,  13,  26,  27,  43,  43,  39,  40,  41,  51,  52,\n\t 53,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  87,  88,\n\t 99,  70, 119, 110, 102, 104, 111, 107, 109, 106, 105, 108, 103,  69,\n\t 98,  55,  74,  78,  96,  79,  80,  81,  75,  76,  77,  71,  72,  73,\n\t 82,  83,  86, 127, 116, 117, 183, 184, 185, 186, 187, 188, 189, 190,\n\t191, 192, 193, 194, 134, 138, 130, 132, 128, 129, 131, 137, 133, 135,\n\t136, 113, 115, 114,   0,   0,   0, 121,   0,  89,  93, 124,  92,  94,\n\t 95,   0,   0,   0, 122, 123,  90,  91,  85,   0,   0,   0,   0,   0,\n\t  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n\t  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n\t  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n\t  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n\t  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n\t 29,  42,  56, 125,  97,  54, 100, 126, 164, 166, 165, 163, 161, 115,\n\t114, 113, 150, 158, 159, 128, 136, 177, 178, 176, 142, 152, 173, 140\n};\n\nstatic unsigned char hidp_mkeyspat[] = { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 };\n\nstatic int hidp_session_probe(struct l2cap_conn *conn,\n\t\t\t      struct l2cap_user *user);\nstatic void hidp_session_remove(struct l2cap_conn *conn,\n\t\t\t\tstruct l2cap_user *user);\nstatic int hidp_session_thread(void *arg);\nstatic void hidp_session_terminate(struct hidp_session *s);\n\nstatic void hidp_copy_session(struct hidp_session *session, struct hidp_conninfo *ci)\n{\n\tu32 valid_flags = 0;\n\tmemset(ci, 0, sizeof(*ci));\n\tbacpy(&ci->bdaddr, &session->bdaddr);\n\n\tci->flags = session->flags & valid_flags;\n\tci->state = BT_CONNECTED;\n\n\tif (session->input) {\n\t\tci->vendor  = session->input->id.vendor;\n\t\tci->product = session->input->id.product;\n\t\tci->version = session->input->id.version;\n\t\tif (session->input->name)\n\t\t\tstrscpy(ci->name, session->input->name, 128);\n\t\telse\n\t\t\tstrscpy(ci->name, \"HID Boot Device\", 128);\n\t} else if (session->hid) {\n\t\tci->vendor  = session->hid->vendor;\n\t\tci->product = session->hid->product;\n\t\tci->version = session->hid->version;\n\t\tstrscpy(ci->name, session->hid->name, 128);\n\t}\n}\n\n \nstatic int hidp_send_message(struct hidp_session *session, struct socket *sock,\n\t\t\t     struct sk_buff_head *transmit, unsigned char hdr,\n\t\t\t     const unsigned char *data, int size)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\tint ret;\n\n\tBT_DBG(\"session %p data %p size %d\", session, data, size);\n\n\tif (atomic_read(&session->terminate))\n\t\treturn -EIO;\n\n\tskb = alloc_skb(size + 1, GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR(\"Can't allocate memory for new frame\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put_u8(skb, hdr);\n\tif (data && size > 0) {\n\t\tskb_put_data(skb, data, size);\n\t\tret = size;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tskb_queue_tail(transmit, skb);\n\twake_up_interruptible(sk_sleep(sk));\n\n\treturn ret;\n}\n\nstatic int hidp_send_ctrl_message(struct hidp_session *session,\n\t\t\t\t  unsigned char hdr, const unsigned char *data,\n\t\t\t\t  int size)\n{\n\treturn hidp_send_message(session, session->ctrl_sock,\n\t\t\t\t &session->ctrl_transmit, hdr, data, size);\n}\n\nstatic int hidp_send_intr_message(struct hidp_session *session,\n\t\t\t\t  unsigned char hdr, const unsigned char *data,\n\t\t\t\t  int size)\n{\n\treturn hidp_send_message(session, session->intr_sock,\n\t\t\t\t &session->intr_transmit, hdr, data, size);\n}\n\nstatic int hidp_input_event(struct input_dev *dev, unsigned int type,\n\t\t\t    unsigned int code, int value)\n{\n\tstruct hidp_session *session = input_get_drvdata(dev);\n\tunsigned char newleds;\n\tunsigned char hdr, data[2];\n\n\tBT_DBG(\"session %p type %d code %d value %d\",\n\t       session, type, code, value);\n\n\tif (type != EV_LED)\n\t\treturn -1;\n\n\tnewleds = (!!test_bit(LED_KANA,    dev->led) << 3) |\n\t\t  (!!test_bit(LED_COMPOSE, dev->led) << 3) |\n\t\t  (!!test_bit(LED_SCROLLL, dev->led) << 2) |\n\t\t  (!!test_bit(LED_CAPSL,   dev->led) << 1) |\n\t\t  (!!test_bit(LED_NUML,    dev->led) << 0);\n\n\tif (session->leds == newleds)\n\t\treturn 0;\n\n\tsession->leds = newleds;\n\n\thdr = HIDP_TRANS_DATA | HIDP_DATA_RTYPE_OUPUT;\n\tdata[0] = 0x01;\n\tdata[1] = newleds;\n\n\treturn hidp_send_intr_message(session, hdr, data, 2);\n}\n\nstatic void hidp_input_report(struct hidp_session *session, struct sk_buff *skb)\n{\n\tstruct input_dev *dev = session->input;\n\tunsigned char *keys = session->keys;\n\tunsigned char *udata = skb->data + 1;\n\tsigned char *sdata = skb->data + 1;\n\tint i, size = skb->len - 1;\n\n\tswitch (skb->data[0]) {\n\tcase 0x01:\t \n\t\tfor (i = 0; i < 8; i++)\n\t\t\tinput_report_key(dev, hidp_keycode[i + 224], (udata[0] >> i) & 1);\n\n\t\t \n\t\tif (!memcmp(udata + 2, hidp_mkeyspat, 6))\n\t\t\tbreak;\n\n\t\tfor (i = 2; i < 8; i++) {\n\t\t\tif (keys[i] > 3 && memscan(udata + 2, keys[i], 6) == udata + 8) {\n\t\t\t\tif (hidp_keycode[keys[i]])\n\t\t\t\t\tinput_report_key(dev, hidp_keycode[keys[i]], 0);\n\t\t\t\telse\n\t\t\t\t\tBT_ERR(\"Unknown key (scancode %#x) released.\", keys[i]);\n\t\t\t}\n\n\t\t\tif (udata[i] > 3 && memscan(keys + 2, udata[i], 6) == keys + 8) {\n\t\t\t\tif (hidp_keycode[udata[i]])\n\t\t\t\t\tinput_report_key(dev, hidp_keycode[udata[i]], 1);\n\t\t\t\telse\n\t\t\t\t\tBT_ERR(\"Unknown key (scancode %#x) pressed.\", udata[i]);\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(keys, udata, 8);\n\t\tbreak;\n\n\tcase 0x02:\t \n\t\tinput_report_key(dev, BTN_LEFT,   sdata[0] & 0x01);\n\t\tinput_report_key(dev, BTN_RIGHT,  sdata[0] & 0x02);\n\t\tinput_report_key(dev, BTN_MIDDLE, sdata[0] & 0x04);\n\t\tinput_report_key(dev, BTN_SIDE,   sdata[0] & 0x08);\n\t\tinput_report_key(dev, BTN_EXTRA,  sdata[0] & 0x10);\n\n\t\tinput_report_rel(dev, REL_X, sdata[1]);\n\t\tinput_report_rel(dev, REL_Y, sdata[2]);\n\n\t\tif (size > 3)\n\t\t\tinput_report_rel(dev, REL_WHEEL, sdata[3]);\n\t\tbreak;\n\t}\n\n\tinput_sync(dev);\n}\n\nstatic int hidp_get_raw_report(struct hid_device *hid,\n\t\tunsigned char report_number,\n\t\tunsigned char *data, size_t count,\n\t\tunsigned char report_type)\n{\n\tstruct hidp_session *session = hid->driver_data;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tint numbered_reports = hid->report_enum[report_type].numbered;\n\tint ret;\n\n\tif (atomic_read(&session->terminate))\n\t\treturn -EIO;\n\n\tswitch (report_type) {\n\tcase HID_FEATURE_REPORT:\n\t\treport_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_FEATURE;\n\t\tbreak;\n\tcase HID_INPUT_REPORT:\n\t\treport_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_INPUT;\n\t\tbreak;\n\tcase HID_OUTPUT_REPORT:\n\t\treport_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_OUPUT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (mutex_lock_interruptible(&session->report_mutex))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tsession->waiting_report_type = report_type & HIDP_DATA_RTYPE_MASK;\n\tsession->waiting_report_number = numbered_reports ? report_number : -1;\n\tset_bit(HIDP_WAITING_FOR_RETURN, &session->flags);\n\tdata[0] = report_number;\n\tret = hidp_send_ctrl_message(session, report_type, data, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\twhile (test_bit(HIDP_WAITING_FOR_RETURN, &session->flags) &&\n\t       !atomic_read(&session->terminate)) {\n\t\tint res;\n\n\t\tres = wait_event_interruptible_timeout(session->report_queue,\n\t\t\t!test_bit(HIDP_WAITING_FOR_RETURN, &session->flags)\n\t\t\t\t|| atomic_read(&session->terminate),\n\t\t\t5*HZ);\n\t\tif (res == 0) {\n\t\t\t \n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tif (res < 0) {\n\t\t\t \n\t\t\tret = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tskb = session->report_return;\n\tif (skb) {\n\t\tlen = skb->len < count ? skb->len : count;\n\t\tmemcpy(data, skb->data, len);\n\n\t\tkfree_skb(skb);\n\t\tsession->report_return = NULL;\n\t} else {\n\t\t \n\t\tlen = -EIO;\n\t}\n\n\tclear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);\n\tmutex_unlock(&session->report_mutex);\n\n\treturn len;\n\nerr:\n\tclear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);\n\tmutex_unlock(&session->report_mutex);\n\treturn ret;\n}\n\nstatic int hidp_set_raw_report(struct hid_device *hid, unsigned char reportnum,\n\t\t\t       unsigned char *data, size_t count,\n\t\t\t       unsigned char report_type)\n{\n\tstruct hidp_session *session = hid->driver_data;\n\tint ret;\n\n\tswitch (report_type) {\n\tcase HID_FEATURE_REPORT:\n\t\treport_type = HIDP_TRANS_SET_REPORT | HIDP_DATA_RTYPE_FEATURE;\n\t\tbreak;\n\tcase HID_INPUT_REPORT:\n\t\treport_type = HIDP_TRANS_SET_REPORT | HIDP_DATA_RTYPE_INPUT;\n\t\tbreak;\n\tcase HID_OUTPUT_REPORT:\n\t\treport_type = HIDP_TRANS_SET_REPORT | HIDP_DATA_RTYPE_OUPUT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (mutex_lock_interruptible(&session->report_mutex))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tdata[0] = reportnum;\n\tset_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);\n\tret = hidp_send_ctrl_message(session, report_type, data, count);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\twhile (test_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags) &&\n\t       !atomic_read(&session->terminate)) {\n\t\tint res;\n\n\t\tres = wait_event_interruptible_timeout(session->report_queue,\n\t\t\t!test_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags)\n\t\t\t\t|| atomic_read(&session->terminate),\n\t\t\t10*HZ);\n\t\tif (res == 0) {\n\t\t\t \n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tif (res < 0) {\n\t\t\t \n\t\t\tret = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (!session->output_report_success) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tret = count;\n\nerr:\n\tclear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);\n\tmutex_unlock(&session->report_mutex);\n\treturn ret;\n}\n\nstatic int hidp_output_report(struct hid_device *hid, __u8 *data, size_t count)\n{\n\tstruct hidp_session *session = hid->driver_data;\n\n\treturn hidp_send_intr_message(session,\n\t\t\t\t      HIDP_TRANS_DATA | HIDP_DATA_RTYPE_OUPUT,\n\t\t\t\t      data, count);\n}\n\nstatic int hidp_raw_request(struct hid_device *hid, unsigned char reportnum,\n\t\t\t    __u8 *buf, size_t len, unsigned char rtype,\n\t\t\t    int reqtype)\n{\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\treturn hidp_get_raw_report(hid, reportnum, buf, len, rtype);\n\tcase HID_REQ_SET_REPORT:\n\t\treturn hidp_set_raw_report(hid, reportnum, buf, len, rtype);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic void hidp_idle_timeout(struct timer_list *t)\n{\n\tstruct hidp_session *session = from_timer(session, t, timer);\n\n\t \n\n\tsession->intr_sock->sk->sk_err = EUNATCH;\n\tsession->ctrl_sock->sk->sk_err = EUNATCH;\n\twake_up_interruptible(sk_sleep(session->intr_sock->sk));\n\twake_up_interruptible(sk_sleep(session->ctrl_sock->sk));\n\n\thidp_session_terminate(session);\n}\n\nstatic void hidp_set_timer(struct hidp_session *session)\n{\n\tif (session->idle_to > 0)\n\t\tmod_timer(&session->timer, jiffies + HZ * session->idle_to);\n}\n\nstatic void hidp_del_timer(struct hidp_session *session)\n{\n\tif (session->idle_to > 0)\n\t\tdel_timer_sync(&session->timer);\n}\n\nstatic void hidp_process_report(struct hidp_session *session, int type,\n\t\t\t\tconst u8 *data, unsigned int len, int intr)\n{\n\tif (len > HID_MAX_BUFFER_SIZE)\n\t\tlen = HID_MAX_BUFFER_SIZE;\n\n\tmemcpy(session->input_buf, data, len);\n\thid_input_report(session->hid, type, session->input_buf, len, intr);\n}\n\nstatic void hidp_process_handshake(struct hidp_session *session,\n\t\t\t\t\tunsigned char param)\n{\n\tBT_DBG(\"session %p param 0x%02x\", session, param);\n\tsession->output_report_success = 0;  \n\n\tswitch (param) {\n\tcase HIDP_HSHK_SUCCESSFUL:\n\t\t \n\t\tsession->output_report_success = 1;\n\t\tbreak;\n\n\tcase HIDP_HSHK_NOT_READY:\n\tcase HIDP_HSHK_ERR_INVALID_REPORT_ID:\n\tcase HIDP_HSHK_ERR_UNSUPPORTED_REQUEST:\n\tcase HIDP_HSHK_ERR_INVALID_PARAMETER:\n\t\tif (test_and_clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags))\n\t\t\twake_up_interruptible(&session->report_queue);\n\n\t\t \n\t\tbreak;\n\n\tcase HIDP_HSHK_ERR_UNKNOWN:\n\t\tbreak;\n\n\tcase HIDP_HSHK_ERR_FATAL:\n\t\t \n\t\thidp_send_ctrl_message(session,\n\t\t\tHIDP_TRANS_HID_CONTROL | HIDP_CTRL_SOFT_RESET, NULL, 0);\n\t\tbreak;\n\n\tdefault:\n\t\thidp_send_ctrl_message(session,\n\t\t\tHIDP_TRANS_HANDSHAKE | HIDP_HSHK_ERR_INVALID_PARAMETER, NULL, 0);\n\t\tbreak;\n\t}\n\n\t \n\tif (test_and_clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags))\n\t\twake_up_interruptible(&session->report_queue);\n}\n\nstatic void hidp_process_hid_control(struct hidp_session *session,\n\t\t\t\t\tunsigned char param)\n{\n\tBT_DBG(\"session %p param 0x%02x\", session, param);\n\n\tif (param == HIDP_CTRL_VIRTUAL_CABLE_UNPLUG) {\n\t\t \n\t\tskb_queue_purge(&session->ctrl_transmit);\n\t\tskb_queue_purge(&session->intr_transmit);\n\n\t\thidp_session_terminate(session);\n\t}\n}\n\n \nstatic int hidp_process_data(struct hidp_session *session, struct sk_buff *skb,\n\t\t\t\tunsigned char param)\n{\n\tint done_with_skb = 1;\n\tBT_DBG(\"session %p skb %p len %u param 0x%02x\", session, skb, skb->len, param);\n\n\tswitch (param) {\n\tcase HIDP_DATA_RTYPE_INPUT:\n\t\thidp_set_timer(session);\n\n\t\tif (session->input)\n\t\t\thidp_input_report(session, skb);\n\n\t\tif (session->hid)\n\t\t\thidp_process_report(session, HID_INPUT_REPORT,\n\t\t\t\t\t    skb->data, skb->len, 0);\n\t\tbreak;\n\n\tcase HIDP_DATA_RTYPE_OTHER:\n\tcase HIDP_DATA_RTYPE_OUPUT:\n\tcase HIDP_DATA_RTYPE_FEATURE:\n\t\tbreak;\n\n\tdefault:\n\t\thidp_send_ctrl_message(session,\n\t\t\tHIDP_TRANS_HANDSHAKE | HIDP_HSHK_ERR_INVALID_PARAMETER, NULL, 0);\n\t}\n\n\tif (test_bit(HIDP_WAITING_FOR_RETURN, &session->flags) &&\n\t\t\t\tparam == session->waiting_report_type) {\n\t\tif (session->waiting_report_number < 0 ||\n\t\t    session->waiting_report_number == skb->data[0]) {\n\t\t\t \n\t\t\tsession->report_return = skb;\n\t\t\tdone_with_skb = 0;\n\t\t\tclear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);\n\t\t\twake_up_interruptible(&session->report_queue);\n\t\t}\n\t}\n\n\treturn done_with_skb;\n}\n\nstatic void hidp_recv_ctrl_frame(struct hidp_session *session,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tunsigned char hdr, type, param;\n\tint free_skb = 1;\n\n\tBT_DBG(\"session %p skb %p len %u\", session, skb, skb->len);\n\n\thdr = skb->data[0];\n\tskb_pull(skb, 1);\n\n\ttype = hdr & HIDP_HEADER_TRANS_MASK;\n\tparam = hdr & HIDP_HEADER_PARAM_MASK;\n\n\tswitch (type) {\n\tcase HIDP_TRANS_HANDSHAKE:\n\t\thidp_process_handshake(session, param);\n\t\tbreak;\n\n\tcase HIDP_TRANS_HID_CONTROL:\n\t\thidp_process_hid_control(session, param);\n\t\tbreak;\n\n\tcase HIDP_TRANS_DATA:\n\t\tfree_skb = hidp_process_data(session, skb, param);\n\t\tbreak;\n\n\tdefault:\n\t\thidp_send_ctrl_message(session,\n\t\t\tHIDP_TRANS_HANDSHAKE | HIDP_HSHK_ERR_UNSUPPORTED_REQUEST, NULL, 0);\n\t\tbreak;\n\t}\n\n\tif (free_skb)\n\t\tkfree_skb(skb);\n}\n\nstatic void hidp_recv_intr_frame(struct hidp_session *session,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tunsigned char hdr;\n\n\tBT_DBG(\"session %p skb %p len %u\", session, skb, skb->len);\n\n\thdr = skb->data[0];\n\tskb_pull(skb, 1);\n\n\tif (hdr == (HIDP_TRANS_DATA | HIDP_DATA_RTYPE_INPUT)) {\n\t\thidp_set_timer(session);\n\n\t\tif (session->input)\n\t\t\thidp_input_report(session, skb);\n\n\t\tif (session->hid) {\n\t\t\thidp_process_report(session, HID_INPUT_REPORT,\n\t\t\t\t\t    skb->data, skb->len, 1);\n\t\t\tBT_DBG(\"report len %d\", skb->len);\n\t\t}\n\t} else {\n\t\tBT_DBG(\"Unsupported protocol header 0x%02x\", hdr);\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic int hidp_send_frame(struct socket *sock, unsigned char *data, int len)\n{\n\tstruct kvec iv = { data, len };\n\tstruct msghdr msg;\n\n\tBT_DBG(\"sock %p data %p len %d\", sock, data, len);\n\n\tif (!len)\n\t\treturn 0;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\treturn kernel_sendmsg(sock, &msg, &iv, 1, len);\n}\n\n \nstatic void hidp_process_transmit(struct hidp_session *session,\n\t\t\t\t  struct sk_buff_head *transmit,\n\t\t\t\t  struct socket *sock)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tBT_DBG(\"session %p\", session);\n\n\twhile ((skb = skb_dequeue(transmit))) {\n\t\tret = hidp_send_frame(sock, skb->data, skb->len);\n\t\tif (ret == -EAGAIN) {\n\t\t\tskb_queue_head(transmit, skb);\n\t\t\tbreak;\n\t\t} else if (ret < 0) {\n\t\t\thidp_session_terminate(session);\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\n\t\thidp_set_timer(session);\n\t\tkfree_skb(skb);\n\t}\n}\n\nstatic int hidp_setup_input(struct hidp_session *session,\n\t\t\t\tconst struct hidp_connadd_req *req)\n{\n\tstruct input_dev *input;\n\tint i;\n\n\tinput = input_allocate_device();\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tsession->input = input;\n\n\tinput_set_drvdata(input, session);\n\n\tinput->name = \"Bluetooth HID Boot Protocol Device\";\n\n\tinput->id.bustype = BUS_BLUETOOTH;\n\tinput->id.vendor  = req->vendor;\n\tinput->id.product = req->product;\n\tinput->id.version = req->version;\n\n\tif (req->subclass & 0x40) {\n\t\tset_bit(EV_KEY, input->evbit);\n\t\tset_bit(EV_LED, input->evbit);\n\t\tset_bit(EV_REP, input->evbit);\n\n\t\tset_bit(LED_NUML,    input->ledbit);\n\t\tset_bit(LED_CAPSL,   input->ledbit);\n\t\tset_bit(LED_SCROLLL, input->ledbit);\n\t\tset_bit(LED_COMPOSE, input->ledbit);\n\t\tset_bit(LED_KANA,    input->ledbit);\n\n\t\tfor (i = 0; i < sizeof(hidp_keycode); i++)\n\t\t\tset_bit(hidp_keycode[i], input->keybit);\n\t\tclear_bit(0, input->keybit);\n\t}\n\n\tif (req->subclass & 0x80) {\n\t\tinput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\t\tinput->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\n\t\t\tBIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_MIDDLE);\n\t\tinput->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\t\tinput->keybit[BIT_WORD(BTN_MOUSE)] |= BIT_MASK(BTN_SIDE) |\n\t\t\tBIT_MASK(BTN_EXTRA);\n\t\tinput->relbit[0] |= BIT_MASK(REL_WHEEL);\n\t}\n\n\tinput->dev.parent = &session->conn->hcon->dev;\n\n\tinput->event = hidp_input_event;\n\n\treturn 0;\n}\n\nstatic int hidp_open(struct hid_device *hid)\n{\n\treturn 0;\n}\n\nstatic void hidp_close(struct hid_device *hid)\n{\n}\n\nstatic int hidp_parse(struct hid_device *hid)\n{\n\tstruct hidp_session *session = hid->driver_data;\n\n\treturn hid_parse_report(session->hid, session->rd_data,\n\t\t\tsession->rd_size);\n}\n\nstatic int hidp_start(struct hid_device *hid)\n{\n\treturn 0;\n}\n\nstatic void hidp_stop(struct hid_device *hid)\n{\n\tstruct hidp_session *session = hid->driver_data;\n\n\tskb_queue_purge(&session->ctrl_transmit);\n\tskb_queue_purge(&session->intr_transmit);\n\n\thid->claimed = 0;\n}\n\nstatic const struct hid_ll_driver hidp_hid_driver = {\n\t.parse = hidp_parse,\n\t.start = hidp_start,\n\t.stop = hidp_stop,\n\t.open  = hidp_open,\n\t.close = hidp_close,\n\t.raw_request = hidp_raw_request,\n\t.output_report = hidp_output_report,\n};\n\n \nstatic int hidp_setup_hid(struct hidp_session *session,\n\t\t\t\tconst struct hidp_connadd_req *req)\n{\n\tstruct hid_device *hid;\n\tint err;\n\n\tsession->rd_data = memdup_user(req->rd_data, req->rd_size);\n\tif (IS_ERR(session->rd_data))\n\t\treturn PTR_ERR(session->rd_data);\n\n\tsession->rd_size = req->rd_size;\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\terr = PTR_ERR(hid);\n\t\tgoto fault;\n\t}\n\n\tsession->hid = hid;\n\n\thid->driver_data = session;\n\n\thid->bus     = BUS_BLUETOOTH;\n\thid->vendor  = req->vendor;\n\thid->product = req->product;\n\thid->version = req->version;\n\thid->country = req->country;\n\n\tstrscpy(hid->name, req->name, sizeof(hid->name));\n\n\tsnprintf(hid->phys, sizeof(hid->phys), \"%pMR\",\n\t\t &l2cap_pi(session->ctrl_sock->sk)->chan->src);\n\n\t \n\tsnprintf(hid->uniq, sizeof(hid->uniq), \"%pMR\",\n\t\t &l2cap_pi(session->ctrl_sock->sk)->chan->dst);\n\n\thid->dev.parent = &session->conn->hcon->dev;\n\thid->ll_driver = &hidp_hid_driver;\n\n\t \n\tif (hid_ignore(hid)) {\n\t\thid_destroy_device(session->hid);\n\t\tsession->hid = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n\nfault:\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n\n\treturn err;\n}\n\n \nstatic int hidp_session_dev_init(struct hidp_session *session,\n\t\t\t\t const struct hidp_connadd_req *req)\n{\n\tint ret;\n\n\tif (req->rd_size > 0) {\n\t\tret = hidp_setup_hid(session, req);\n\t\tif (ret && ret != -ENODEV)\n\t\t\treturn ret;\n\t}\n\n\tif (!session->hid) {\n\t\tret = hidp_setup_input(session, req);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void hidp_session_dev_destroy(struct hidp_session *session)\n{\n\tif (session->hid)\n\t\tput_device(&session->hid->dev);\n\telse if (session->input)\n\t\tinput_put_device(session->input);\n\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n}\n\n \nstatic int hidp_session_dev_add(struct hidp_session *session)\n{\n\tint ret;\n\n\t \n\n\tif (session->hid) {\n\t\tret = hid_add_device(session->hid);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tget_device(&session->hid->dev);\n\t} else if (session->input) {\n\t\tret = input_register_device(session->input);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tinput_get_device(session->input);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void hidp_session_dev_del(struct hidp_session *session)\n{\n\tif (session->hid)\n\t\thid_destroy_device(session->hid);\n\telse if (session->input)\n\t\tinput_unregister_device(session->input);\n}\n\n \nstatic void hidp_session_dev_work(struct work_struct *work)\n{\n\tstruct hidp_session *session = container_of(work,\n\t\t\t\t\t\t    struct hidp_session,\n\t\t\t\t\t\t    dev_init);\n\tint ret;\n\n\tret = hidp_session_dev_add(session);\n\tif (!ret)\n\t\tatomic_inc(&session->state);\n\telse\n\t\thidp_session_terminate(session);\n}\n\n \nstatic int hidp_session_new(struct hidp_session **out, const bdaddr_t *bdaddr,\n\t\t\t    struct socket *ctrl_sock,\n\t\t\t    struct socket *intr_sock,\n\t\t\t    const struct hidp_connadd_req *req,\n\t\t\t    struct l2cap_conn *conn)\n{\n\tstruct hidp_session *session;\n\tint ret;\n\tstruct bt_sock *ctrl, *intr;\n\n\tctrl = bt_sk(ctrl_sock->sk);\n\tintr = bt_sk(intr_sock->sk);\n\n\tsession = kzalloc(sizeof(*session), GFP_KERNEL);\n\tif (!session)\n\t\treturn -ENOMEM;\n\n\t \n\tkref_init(&session->ref);\n\tatomic_set(&session->state, HIDP_SESSION_IDLING);\n\tinit_waitqueue_head(&session->state_queue);\n\tsession->flags = req->flags & BIT(HIDP_BLUETOOTH_VENDOR_ID);\n\n\t \n\tbacpy(&session->bdaddr, bdaddr);\n\tsession->conn = l2cap_conn_get(conn);\n\tsession->user.probe = hidp_session_probe;\n\tsession->user.remove = hidp_session_remove;\n\tINIT_LIST_HEAD(&session->user.list);\n\tsession->ctrl_sock = ctrl_sock;\n\tsession->intr_sock = intr_sock;\n\tskb_queue_head_init(&session->ctrl_transmit);\n\tskb_queue_head_init(&session->intr_transmit);\n\tsession->ctrl_mtu = min_t(uint, l2cap_pi(ctrl)->chan->omtu,\n\t\t\t\t\tl2cap_pi(ctrl)->chan->imtu);\n\tsession->intr_mtu = min_t(uint, l2cap_pi(intr)->chan->omtu,\n\t\t\t\t\tl2cap_pi(intr)->chan->imtu);\n\tsession->idle_to = req->idle_to;\n\n\t \n\tINIT_WORK(&session->dev_init, hidp_session_dev_work);\n\ttimer_setup(&session->timer, hidp_idle_timeout, 0);\n\n\t \n\tmutex_init(&session->report_mutex);\n\tinit_waitqueue_head(&session->report_queue);\n\n\tret = hidp_session_dev_init(session, req);\n\tif (ret)\n\t\tgoto err_free;\n\n\tget_file(session->intr_sock->file);\n\tget_file(session->ctrl_sock->file);\n\t*out = session;\n\treturn 0;\n\nerr_free:\n\tl2cap_conn_put(session->conn);\n\tkfree(session);\n\treturn ret;\n}\n\n \nstatic void hidp_session_get(struct hidp_session *session)\n{\n\tkref_get(&session->ref);\n}\n\n \nstatic void session_free(struct kref *ref)\n{\n\tstruct hidp_session *session = container_of(ref, struct hidp_session,\n\t\t\t\t\t\t    ref);\n\n\thidp_session_dev_destroy(session);\n\tskb_queue_purge(&session->ctrl_transmit);\n\tskb_queue_purge(&session->intr_transmit);\n\tfput(session->intr_sock->file);\n\tfput(session->ctrl_sock->file);\n\tl2cap_conn_put(session->conn);\n\tkfree(session);\n}\n\n \nstatic void hidp_session_put(struct hidp_session *session)\n{\n\tkref_put(&session->ref, session_free);\n}\n\n \nstatic struct hidp_session *__hidp_session_find(const bdaddr_t *bdaddr)\n{\n\tstruct hidp_session *session;\n\n\tlist_for_each_entry(session, &hidp_session_list, list) {\n\t\tif (!bacmp(bdaddr, &session->bdaddr))\n\t\t\treturn session;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct hidp_session *hidp_session_find(const bdaddr_t *bdaddr)\n{\n\tstruct hidp_session *session;\n\n\tdown_read(&hidp_session_sem);\n\n\tsession = __hidp_session_find(bdaddr);\n\tif (session)\n\t\thidp_session_get(session);\n\n\tup_read(&hidp_session_sem);\n\n\treturn session;\n}\n\n \nstatic int hidp_session_start_sync(struct hidp_session *session)\n{\n\tunsigned int vendor, product;\n\n\tif (session->hid) {\n\t\tvendor  = session->hid->vendor;\n\t\tproduct = session->hid->product;\n\t} else if (session->input) {\n\t\tvendor  = session->input->id.vendor;\n\t\tproduct = session->input->id.product;\n\t} else {\n\t\tvendor = 0x0000;\n\t\tproduct = 0x0000;\n\t}\n\n\tsession->task = kthread_run(hidp_session_thread, session,\n\t\t\t\t    \"khidpd_%04x%04x\", vendor, product);\n\tif (IS_ERR(session->task))\n\t\treturn PTR_ERR(session->task);\n\n\twhile (atomic_read(&session->state) <= HIDP_SESSION_IDLING)\n\t\twait_event(session->state_queue,\n\t\t\t   atomic_read(&session->state) > HIDP_SESSION_IDLING);\n\n\treturn 0;\n}\n\n \nstatic void hidp_session_terminate(struct hidp_session *session)\n{\n\tatomic_inc(&session->terminate);\n\t \n\twake_up_interruptible(&hidp_session_wq);\n}\n\n \nstatic int hidp_session_probe(struct l2cap_conn *conn,\n\t\t\t      struct l2cap_user *user)\n{\n\tstruct hidp_session *session = container_of(user,\n\t\t\t\t\t\t    struct hidp_session,\n\t\t\t\t\t\t    user);\n\tstruct hidp_session *s;\n\tint ret;\n\n\tdown_write(&hidp_session_sem);\n\n\t \n\ts = __hidp_session_find(&session->bdaddr);\n\tif (s) {\n\t\tret = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tif (session->input) {\n\t\tret = hidp_session_dev_add(session);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = hidp_session_start_sync(session);\n\tif (ret)\n\t\tgoto out_del;\n\n\t \n\tif (session->input)\n\t\tatomic_inc(&session->state);\n\telse\n\t\tschedule_work(&session->dev_init);\n\n\thidp_session_get(session);\n\tlist_add(&session->list, &hidp_session_list);\n\tret = 0;\n\tgoto out_unlock;\n\nout_del:\n\tif (session->input)\n\t\thidp_session_dev_del(session);\nout_unlock:\n\tup_write(&hidp_session_sem);\n\treturn ret;\n}\n\n \nstatic void hidp_session_remove(struct l2cap_conn *conn,\n\t\t\t\tstruct l2cap_user *user)\n{\n\tstruct hidp_session *session = container_of(user,\n\t\t\t\t\t\t    struct hidp_session,\n\t\t\t\t\t\t    user);\n\n\tdown_write(&hidp_session_sem);\n\n\thidp_session_terminate(session);\n\n\tcancel_work_sync(&session->dev_init);\n\tif (session->input ||\n\t    atomic_read(&session->state) > HIDP_SESSION_PREPARING)\n\t\thidp_session_dev_del(session);\n\n\tlist_del(&session->list);\n\n\tup_write(&hidp_session_sem);\n\n\thidp_session_put(session);\n}\n\n \nstatic void hidp_session_run(struct hidp_session *session)\n{\n\tstruct sock *ctrl_sk = session->ctrl_sock->sk;\n\tstruct sock *intr_sk = session->intr_sock->sk;\n\tstruct sk_buff *skb;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tadd_wait_queue(&hidp_session_wq, &wait);\n\tfor (;;) {\n\t\t \n\n\t\tif (atomic_read(&session->terminate))\n\t\t\tbreak;\n\n\t\tif (ctrl_sk->sk_state != BT_CONNECTED ||\n\t\t    intr_sk->sk_state != BT_CONNECTED)\n\t\t\tbreak;\n\n\t\t \n\t\twhile ((skb = skb_dequeue(&intr_sk->sk_receive_queue))) {\n\t\t\tskb_orphan(skb);\n\t\t\tif (!skb_linearize(skb))\n\t\t\t\thidp_recv_intr_frame(session, skb);\n\t\t\telse\n\t\t\t\tkfree_skb(skb);\n\t\t}\n\n\t\t \n\t\thidp_process_transmit(session, &session->intr_transmit,\n\t\t\t\t      session->intr_sock);\n\n\t\t \n\t\twhile ((skb = skb_dequeue(&ctrl_sk->sk_receive_queue))) {\n\t\t\tskb_orphan(skb);\n\t\t\tif (!skb_linearize(skb))\n\t\t\t\thidp_recv_ctrl_frame(session, skb);\n\t\t\telse\n\t\t\t\tkfree_skb(skb);\n\t\t}\n\n\t\t \n\t\thidp_process_transmit(session, &session->ctrl_transmit,\n\t\t\t\t      session->ctrl_sock);\n\n\t\t \n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&hidp_session_wq, &wait);\n\n\tatomic_inc(&session->terminate);\n}\n\nstatic int hidp_session_wake_function(wait_queue_entry_t *wait,\n\t\t\t\t      unsigned int mode,\n\t\t\t\t      int sync, void *key)\n{\n\twake_up_interruptible(&hidp_session_wq);\n\treturn false;\n}\n\n \nstatic int hidp_session_thread(void *arg)\n{\n\tstruct hidp_session *session = arg;\n\tDEFINE_WAIT_FUNC(ctrl_wait, hidp_session_wake_function);\n\tDEFINE_WAIT_FUNC(intr_wait, hidp_session_wake_function);\n\n\tBT_DBG(\"session %p\", session);\n\n\t \n\thidp_session_get(session);\n\t__module_get(THIS_MODULE);\n\tset_user_nice(current, -15);\n\thidp_set_timer(session);\n\n\tadd_wait_queue(sk_sleep(session->ctrl_sock->sk), &ctrl_wait);\n\tadd_wait_queue(sk_sleep(session->intr_sock->sk), &intr_wait);\n\t \n\tsmp_mb__before_atomic();\n\n\t \n\tatomic_inc(&session->state);\n\twake_up(&session->state_queue);\n\n\t \n\thidp_session_run(session);\n\n\t \n\tremove_wait_queue(sk_sleep(session->intr_sock->sk), &intr_wait);\n\tremove_wait_queue(sk_sleep(session->ctrl_sock->sk), &ctrl_wait);\n\twake_up_interruptible(&session->report_queue);\n\thidp_del_timer(session);\n\n\t \n\tl2cap_unregister_user(session->conn, &session->user);\n\thidp_session_put(session);\n\n\tmodule_put_and_kthread_exit(0);\n\treturn 0;\n}\n\nstatic int hidp_verify_sockets(struct socket *ctrl_sock,\n\t\t\t       struct socket *intr_sock)\n{\n\tstruct l2cap_chan *ctrl_chan, *intr_chan;\n\tstruct bt_sock *ctrl, *intr;\n\tstruct hidp_session *session;\n\n\tif (!l2cap_is_socket(ctrl_sock) || !l2cap_is_socket(intr_sock))\n\t\treturn -EINVAL;\n\n\tctrl_chan = l2cap_pi(ctrl_sock->sk)->chan;\n\tintr_chan = l2cap_pi(intr_sock->sk)->chan;\n\n\tif (bacmp(&ctrl_chan->src, &intr_chan->src) ||\n\t    bacmp(&ctrl_chan->dst, &intr_chan->dst))\n\t\treturn -ENOTUNIQ;\n\n\tctrl = bt_sk(ctrl_sock->sk);\n\tintr = bt_sk(intr_sock->sk);\n\n\tif (ctrl->sk.sk_state != BT_CONNECTED ||\n\t    intr->sk.sk_state != BT_CONNECTED)\n\t\treturn -EBADFD;\n\n\t \n\tsession = hidp_session_find(&ctrl_chan->dst);\n\tif (session) {\n\t\thidp_session_put(session);\n\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\nint hidp_connection_add(const struct hidp_connadd_req *req,\n\t\t\tstruct socket *ctrl_sock,\n\t\t\tstruct socket *intr_sock)\n{\n\tu32 valid_flags = BIT(HIDP_VIRTUAL_CABLE_UNPLUG) |\n\t\t\t  BIT(HIDP_BOOT_PROTOCOL_MODE);\n\tstruct hidp_session *session;\n\tstruct l2cap_conn *conn;\n\tstruct l2cap_chan *chan;\n\tint ret;\n\n\tret = hidp_verify_sockets(ctrl_sock, intr_sock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (req->flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\tchan = l2cap_pi(ctrl_sock->sk)->chan;\n\tconn = NULL;\n\tl2cap_chan_lock(chan);\n\tif (chan->conn)\n\t\tconn = l2cap_conn_get(chan->conn);\n\tl2cap_chan_unlock(chan);\n\n\tif (!conn)\n\t\treturn -EBADFD;\n\n\tret = hidp_session_new(&session, &chan->dst, ctrl_sock,\n\t\t\t       intr_sock, req, conn);\n\tif (ret)\n\t\tgoto out_conn;\n\n\tret = l2cap_register_user(conn, &session->user);\n\tif (ret)\n\t\tgoto out_session;\n\n\tret = 0;\n\nout_session:\n\thidp_session_put(session);\nout_conn:\n\tl2cap_conn_put(conn);\n\treturn ret;\n}\n\nint hidp_connection_del(struct hidp_conndel_req *req)\n{\n\tu32 valid_flags = BIT(HIDP_VIRTUAL_CABLE_UNPLUG);\n\tstruct hidp_session *session;\n\n\tif (req->flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\tsession = hidp_session_find(&req->bdaddr);\n\tif (!session)\n\t\treturn -ENOENT;\n\n\tif (req->flags & BIT(HIDP_VIRTUAL_CABLE_UNPLUG))\n\t\thidp_send_ctrl_message(session,\n\t\t\t\t       HIDP_TRANS_HID_CONTROL |\n\t\t\t\t         HIDP_CTRL_VIRTUAL_CABLE_UNPLUG,\n\t\t\t\t       NULL, 0);\n\telse\n\t\tl2cap_unregister_user(session->conn, &session->user);\n\n\thidp_session_put(session);\n\n\treturn 0;\n}\n\nint hidp_get_connlist(struct hidp_connlist_req *req)\n{\n\tstruct hidp_session *session;\n\tint err = 0, n = 0;\n\n\tBT_DBG(\"\");\n\n\tdown_read(&hidp_session_sem);\n\n\tlist_for_each_entry(session, &hidp_session_list, list) {\n\t\tstruct hidp_conninfo ci;\n\n\t\thidp_copy_session(session, &ci);\n\n\t\tif (copy_to_user(req->ci, &ci, sizeof(ci))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (++n >= req->cnum)\n\t\t\tbreak;\n\n\t\treq->ci++;\n\t}\n\treq->cnum = n;\n\n\tup_read(&hidp_session_sem);\n\treturn err;\n}\n\nint hidp_get_conninfo(struct hidp_conninfo *ci)\n{\n\tstruct hidp_session *session;\n\n\tsession = hidp_session_find(&ci->bdaddr);\n\tif (session) {\n\t\thidp_copy_session(session, ci);\n\t\thidp_session_put(session);\n\t}\n\n\treturn session ? 0 : -ENOENT;\n}\n\nstatic int __init hidp_init(void)\n{\n\tBT_INFO(\"HIDP (Human Interface Emulation) ver %s\", VERSION);\n\n\treturn hidp_init_sockets();\n}\n\nstatic void __exit hidp_exit(void)\n{\n\thidp_cleanup_sockets();\n}\n\nmodule_init(hidp_init);\nmodule_exit(hidp_exit);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_AUTHOR(\"David Herrmann <dh.herrmann@gmail.com>\");\nMODULE_DESCRIPTION(\"Bluetooth HIDP ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"bt-proto-6\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}