{
  "module_name": "sock.c",
  "hash_id": "908879a038a6fd1b46000a38c66bdd63499989bc1e016ef0f585f5fedebe49e2",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/bnep/sock.c",
  "human_readable_source": " \n\n#include <linux/compat.h>\n#include <linux/export.h>\n#include <linux/file.h>\n\n#include \"bnep.h\"\n\nstatic struct bt_sock_list bnep_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(bnep_sk_list.lock)\n};\n\nstatic int bnep_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tbt_sock_unlink(&bnep_sk_list, sk);\n\n\tsock_orphan(sk);\n\tsock_put(sk);\n\treturn 0;\n}\n\nstatic int do_bnep_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\t__u32 supp_feat = BIT(BNEP_SETUP_RESPONSE);\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n\t\t\tsockfd_put(nsock);\n\t\t\treturn -EBADFD;\n\t\t}\n\t\tca.device[sizeof(ca.device)-1] = 0;\n\n\t\terr = bnep_add_connection(&ca, nsock);\n\t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\n\t\treturn err;\n\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn bnep_del_connection(&cd);\n\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase BNEPGETSUPPFEAT:\n\t\tif (copy_to_user(argp, &supp_feat, sizeof(supp_feat)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\treturn do_bnep_sock_ioctl(sock, cmd, (void __user *)arg);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int bnep_sock_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tif (cmd == BNEPGETCONNLIST) {\n\t\tstruct bnep_connlist_req cl;\n\t\tunsigned __user *p = argp;\n\t\tu32 uci;\n\t\tint err;\n\n\t\tif (get_user(cl.cnum, p) || get_user(uci, p + 1))\n\t\t\treturn -EFAULT;\n\n\t\tcl.ci = compat_ptr(uci);\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = bnep_get_connlist(&cl);\n\n\t\tif (!err && put_user(cl.cnum, p))\n\t\t\terr = -EFAULT;\n\n\t\treturn err;\n\t}\n\n\treturn do_bnep_sock_ioctl(sock, cmd, argp);\n}\n#endif\n\nstatic const struct proto_ops bnep_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= bnep_sock_release,\n\t.ioctl\t\t= bnep_sock_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= bnep_sock_compat_ioctl,\n#endif\n\t.bind\t\t= sock_no_bind,\n\t.getname\t= sock_no_getname,\n\t.sendmsg\t= sock_no_sendmsg,\n\t.recvmsg\t= sock_no_recvmsg,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.connect\t= sock_no_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.mmap\t\t= sock_no_mmap\n};\n\nstatic struct proto bnep_proto = {\n\t.name\t\t= \"BNEP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct bt_sock)\n};\n\nstatic int bnep_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t    int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = bt_sock_alloc(net, sock, &bnep_proto, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock->ops = &bnep_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\n\tbt_sock_link(&bnep_sk_list, sk);\n\treturn 0;\n}\n\nstatic const struct net_proto_family bnep_sock_family_ops = {\n\t.family = PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create = bnep_sock_create\n};\n\nint __init bnep_sock_init(void)\n{\n\tint err;\n\n\terr = proto_register(&bnep_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_BNEP, &bnep_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"Can't register BNEP socket\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"bnep\", &bnep_sk_list, NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create BNEP proc file\");\n\t\tbt_sock_unregister(BTPROTO_BNEP);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"BNEP socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&bnep_proto);\n\treturn err;\n}\n\nvoid __exit bnep_sock_cleanup(void)\n{\n\tbt_procfs_cleanup(&init_net, \"bnep\");\n\tbt_sock_unregister(BTPROTO_BNEP);\n\tproto_unregister(&bnep_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}