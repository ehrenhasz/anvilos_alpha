{
  "module_name": "netdev.c",
  "hash_id": "89de84161e6b7f655d42b4da7bb76b2e658d23c8dbbb051d03e5aa1802b2b0d9",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/bnep/netdev.c",
  "human_readable_source": " \n\n#include <linux/etherdevice.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"bnep.h\"\n\n#define BNEP_TX_QUEUE_LEN 20\n\nstatic int bnep_net_open(struct net_device *dev)\n{\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic int bnep_net_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\nstatic void bnep_net_set_mc_list(struct net_device *dev)\n{\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\tstruct bnep_session *s = netdev_priv(dev);\n\tstruct sock *sk = s->sock->sk;\n\tstruct bnep_set_filter_req *r;\n\tstruct sk_buff *skb;\n\tint size;\n\n\tBT_DBG(\"%s mc_count %d\", dev->name, netdev_mc_count(dev));\n\n\tsize = sizeof(*r) + (BNEP_MAX_MULTICAST_FILTERS + 1) * ETH_ALEN * 2;\n\tskb  = alloc_skb(size, GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR(\"%s Multicast list allocation failed\", dev->name);\n\t\treturn;\n\t}\n\n\tr = (void *) skb->data;\n\t__skb_put(skb, sizeof(*r));\n\n\tr->type = BNEP_CONTROL;\n\tr->ctrl = BNEP_FILTER_MULTI_ADDR_SET;\n\n\tif (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {\n\t\tu8 start[ETH_ALEN] = { 0x01 };\n\n\t\t \n\t\t__skb_put_data(skb, start, ETH_ALEN);\n\t\t__skb_put_data(skb, dev->broadcast, ETH_ALEN);\n\t\tr->len = htons(ETH_ALEN * 2);\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint i, len = skb->len;\n\n\t\tif (dev->flags & IFF_BROADCAST) {\n\t\t\t__skb_put_data(skb, dev->broadcast, ETH_ALEN);\n\t\t\t__skb_put_data(skb, dev->broadcast, ETH_ALEN);\n\t\t}\n\n\t\t \n\n\t\ti = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tif (i == BNEP_MAX_MULTICAST_FILTERS)\n\t\t\t\tbreak;\n\t\t\t__skb_put_data(skb, ha->addr, ETH_ALEN);\n\t\t\t__skb_put_data(skb, ha->addr, ETH_ALEN);\n\n\t\t\ti++;\n\t\t}\n\t\tr->len = htons(skb->len - len);\n\t}\n\n\tskb_queue_tail(&sk->sk_write_queue, skb);\n\twake_up_interruptible(sk_sleep(sk));\n#endif\n}\n\nstatic int bnep_net_set_mac_addr(struct net_device *dev, void *arg)\n{\n\tBT_DBG(\"%s\", dev->name);\n\treturn 0;\n}\n\nstatic void bnep_net_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tBT_DBG(\"net_timeout\");\n\tnetif_wake_queue(dev);\n}\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\nstatic int bnep_net_mc_filter(struct sk_buff *skb, struct bnep_session *s)\n{\n\tstruct ethhdr *eh = (void *) skb->data;\n\n\tif ((eh->h_dest[0] & 1) && !test_bit(bnep_mc_hash(eh->h_dest), (ulong *) &s->mc_filter))\n\t\treturn 1;\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n \nstatic u16 bnep_net_eth_proto(struct sk_buff *skb)\n{\n\tstruct ethhdr *eh = (void *) skb->data;\n\tu16 proto = ntohs(eh->h_proto);\n\n\tif (proto >= ETH_P_802_3_MIN)\n\t\treturn proto;\n\n\tif (get_unaligned((__be16 *) skb->data) == htons(0xFFFF))\n\t\treturn ETH_P_802_3;\n\n\treturn ETH_P_802_2;\n}\n\nstatic int bnep_net_proto_filter(struct sk_buff *skb, struct bnep_session *s)\n{\n\tu16 proto = bnep_net_eth_proto(skb);\n\tstruct bnep_proto_filter *f = s->proto_filter;\n\tint i;\n\n\tfor (i = 0; i < BNEP_MAX_PROTO_FILTERS && f[i].end; i++) {\n\t\tif (proto >= f[i].start && proto <= f[i].end)\n\t\t\treturn 0;\n\t}\n\n\tBT_DBG(\"BNEP: filtered skb %p, proto 0x%.4x\", skb, proto);\n\treturn 1;\n}\n#endif\n\nstatic netdev_tx_t bnep_net_xmit(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct bnep_session *s = netdev_priv(dev);\n\tstruct sock *sk = s->sock->sk;\n\n\tBT_DBG(\"skb %p, dev %p\", skb, dev);\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\tif (bnep_net_mc_filter(skb, s)) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\tif (bnep_net_proto_filter(skb, s)) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n#endif\n\n\t \n\tnetif_trans_update(dev);\n\tskb_queue_tail(&sk->sk_write_queue, skb);\n\twake_up_interruptible(sk_sleep(sk));\n\n\tif (skb_queue_len(&sk->sk_write_queue) >= BNEP_TX_QUEUE_LEN) {\n\t\tBT_DBG(\"tx queue is full\");\n\n\t\t \n\t\tnetif_stop_queue(dev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops bnep_netdev_ops = {\n\t.ndo_open            = bnep_net_open,\n\t.ndo_stop            = bnep_net_close,\n\t.ndo_start_xmit\t     = bnep_net_xmit,\n\t.ndo_validate_addr   = eth_validate_addr,\n\t.ndo_set_rx_mode     = bnep_net_set_mc_list,\n\t.ndo_set_mac_address = bnep_net_set_mac_addr,\n\t.ndo_tx_timeout      = bnep_net_timeout,\n\n};\n\nvoid bnep_net_setup(struct net_device *dev)\n{\n\n\teth_broadcast_addr(dev->broadcast);\n\tdev->addr_len = ETH_ALEN;\n\n\tether_setup(dev);\n\tdev->min_mtu = 0;\n\tdev->max_mtu = ETH_MAX_MTU;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &bnep_netdev_ops;\n\n\tdev->watchdog_timeo  = HZ * 2;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}