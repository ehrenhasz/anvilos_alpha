{
  "module_name": "core.c",
  "hash_id": "66393c567f8fe89af31a5c10649495b83d9aeb34a69d6e314ddad1db4e1bcc88",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/bnep/core.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/etherdevice.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/l2cap.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"bnep.h\"\n\n#define VERSION \"1.3\"\n\nstatic bool compress_src = true;\nstatic bool compress_dst = true;\n\nstatic LIST_HEAD(bnep_session_list);\nstatic DECLARE_RWSEM(bnep_session_sem);\n\nstatic struct bnep_session *__bnep_get_session(u8 *dst)\n{\n\tstruct bnep_session *s;\n\n\tBT_DBG(\"\");\n\n\tlist_for_each_entry(s, &bnep_session_list, list)\n\t\tif (ether_addr_equal(dst, s->eh.h_source))\n\t\t\treturn s;\n\n\treturn NULL;\n}\n\nstatic void __bnep_link_session(struct bnep_session *s)\n{\n\tlist_add(&s->list, &bnep_session_list);\n}\n\nstatic void __bnep_unlink_session(struct bnep_session *s)\n{\n\tlist_del(&s->list);\n}\n\nstatic int bnep_send(struct bnep_session *s, void *data, size_t len)\n{\n\tstruct socket *sock = s->sock;\n\tstruct kvec iv = { data, len };\n\n\treturn kernel_sendmsg(sock, &s->msg, &iv, 1, len);\n}\n\nstatic int bnep_send_rsp(struct bnep_session *s, u8 ctrl, u16 resp)\n{\n\tstruct bnep_control_rsp rsp;\n\trsp.type = BNEP_CONTROL;\n\trsp.ctrl = ctrl;\n\trsp.resp = htons(resp);\n\treturn bnep_send(s, &rsp, sizeof(rsp));\n}\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\nstatic inline void bnep_set_default_proto_filter(struct bnep_session *s)\n{\n\t \n\ts->proto_filter[0].start = ETH_P_IP;\n\ts->proto_filter[0].end   = ETH_P_ARP;\n\t \n\ts->proto_filter[1].start = ETH_P_RARP;\n\ts->proto_filter[1].end   = ETH_P_AARP;\n\t \n\ts->proto_filter[2].start = ETH_P_IPX;\n\ts->proto_filter[2].end   = ETH_P_IPV6;\n}\n#endif\n\nstatic int bnep_ctrl_set_netfilter(struct bnep_session *s, __be16 *data, int len)\n{\n\tint n;\n\n\tif (len < 2)\n\t\treturn -EILSEQ;\n\n\tn = get_unaligned_be16(data);\n\tdata++;\n\tlen -= 2;\n\n\tif (len < n)\n\t\treturn -EILSEQ;\n\n\tBT_DBG(\"filter len %d\", n);\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\tn /= 4;\n\tif (n <= BNEP_MAX_PROTO_FILTERS) {\n\t\tstruct bnep_proto_filter *f = s->proto_filter;\n\t\tint i;\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tf[i].start = get_unaligned_be16(data++);\n\t\t\tf[i].end   = get_unaligned_be16(data++);\n\n\t\t\tBT_DBG(\"proto filter start %u end %u\",\n\t\t\t       f[i].start, f[i].end);\n\t\t}\n\n\t\tif (i < BNEP_MAX_PROTO_FILTERS)\n\t\t\tmemset(f + i, 0, sizeof(*f));\n\n\t\tif (n == 0)\n\t\t\tbnep_set_default_proto_filter(s);\n\n\t\tbnep_send_rsp(s, BNEP_FILTER_NET_TYPE_RSP, BNEP_SUCCESS);\n\t} else {\n\t\tbnep_send_rsp(s, BNEP_FILTER_NET_TYPE_RSP, BNEP_FILTER_LIMIT_REACHED);\n\t}\n#else\n\tbnep_send_rsp(s, BNEP_FILTER_NET_TYPE_RSP, BNEP_FILTER_UNSUPPORTED_REQ);\n#endif\n\treturn 0;\n}\n\nstatic int bnep_ctrl_set_mcfilter(struct bnep_session *s, u8 *data, int len)\n{\n\tint n;\n\n\tif (len < 2)\n\t\treturn -EILSEQ;\n\n\tn = get_unaligned_be16(data);\n\tdata += 2;\n\tlen -= 2;\n\n\tif (len < n)\n\t\treturn -EILSEQ;\n\n\tBT_DBG(\"filter len %d\", n);\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\tn /= (ETH_ALEN * 2);\n\n\tif (n > 0) {\n\t\tint i;\n\n\t\ts->mc_filter = 0;\n\n\t\t \n\t\tset_bit(bnep_mc_hash(s->dev->broadcast), (ulong *) &s->mc_filter);\n\n\t\t \n\t\tfor (; n > 0; n--) {\n\t\t\tu8 a1[6], *a2;\n\n\t\t\tmemcpy(a1, data, ETH_ALEN);\n\t\t\tdata += ETH_ALEN;\n\t\t\ta2 = data;\n\t\t\tdata += ETH_ALEN;\n\n\t\t\tBT_DBG(\"mc filter %pMR -> %pMR\", a1, a2);\n\n\t\t\t \n\t\t\tset_bit(bnep_mc_hash(a1), (ulong *) &s->mc_filter);\n\t\t\twhile (memcmp(a1, a2, 6) < 0 && s->mc_filter != ~0LL) {\n\t\t\t\t \n\t\t\t\ti = 5;\n\t\t\t\twhile (i >= 0 && ++a1[i--] == 0)\n\t\t\t\t\t;\n\n\t\t\t\tset_bit(bnep_mc_hash(a1), (ulong *) &s->mc_filter);\n\t\t\t}\n\t\t}\n\t}\n\n\tBT_DBG(\"mc filter hash 0x%llx\", s->mc_filter);\n\n\tbnep_send_rsp(s, BNEP_FILTER_MULTI_ADDR_RSP, BNEP_SUCCESS);\n#else\n\tbnep_send_rsp(s, BNEP_FILTER_MULTI_ADDR_RSP, BNEP_FILTER_UNSUPPORTED_REQ);\n#endif\n\treturn 0;\n}\n\nstatic int bnep_rx_control(struct bnep_session *s, void *data, int len)\n{\n\tu8  cmd = *(u8 *)data;\n\tint err = 0;\n\n\tdata++;\n\tlen--;\n\n\tswitch (cmd) {\n\tcase BNEP_CMD_NOT_UNDERSTOOD:\n\tcase BNEP_SETUP_CONN_RSP:\n\tcase BNEP_FILTER_NET_TYPE_RSP:\n\tcase BNEP_FILTER_MULTI_ADDR_RSP:\n\t\t \n\t\tbreak;\n\n\tcase BNEP_FILTER_NET_TYPE_SET:\n\t\terr = bnep_ctrl_set_netfilter(s, data, len);\n\t\tbreak;\n\n\tcase BNEP_FILTER_MULTI_ADDR_SET:\n\t\terr = bnep_ctrl_set_mcfilter(s, data, len);\n\t\tbreak;\n\n\tcase BNEP_SETUP_CONN_REQ:\n\t\t \n\t\tif (test_bit(BNEP_SETUP_RESPONSE, &s->flags) &&\n\t\t    !test_and_set_bit(BNEP_SETUP_RSP_SENT, &s->flags))\n\t\t\terr = bnep_send_rsp(s, BNEP_SETUP_CONN_RSP,\n\t\t\t\t\t    BNEP_SUCCESS);\n\t\telse\n\t\t\terr = bnep_send_rsp(s, BNEP_SETUP_CONN_RSP,\n\t\t\t\t\t    BNEP_CONN_NOT_ALLOWED);\n\t\tbreak;\n\n\tdefault: {\n\t\t\tu8 pkt[3];\n\t\t\tpkt[0] = BNEP_CONTROL;\n\t\t\tpkt[1] = BNEP_CMD_NOT_UNDERSTOOD;\n\t\t\tpkt[2] = cmd;\n\t\t\terr = bnep_send(s, pkt, sizeof(pkt));\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int bnep_rx_extension(struct bnep_session *s, struct sk_buff *skb)\n{\n\tstruct bnep_ext_hdr *h;\n\tint err = 0;\n\n\tdo {\n\t\th = (void *) skb->data;\n\t\tif (!skb_pull(skb, sizeof(*h))) {\n\t\t\terr = -EILSEQ;\n\t\t\tbreak;\n\t\t}\n\n\t\tBT_DBG(\"type 0x%x len %u\", h->type, h->len);\n\n\t\tswitch (h->type & BNEP_TYPE_MASK) {\n\t\tcase BNEP_EXT_CONTROL:\n\t\t\tbnep_rx_control(s, skb->data, skb->len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tif (!skb_pull(skb, h->len)) {\n\t\t\terr = -EILSEQ;\n\t\t\tbreak;\n\t\t}\n\t} while (!err && (h->type & BNEP_EXT_HEADER));\n\n\treturn err;\n}\n\nstatic u8 __bnep_rx_hlen[] = {\n\tETH_HLEN,      \n\t0,             \n\t2,             \n\tETH_ALEN + 2,  \n\tETH_ALEN + 2   \n};\n\nstatic int bnep_rx_frame(struct bnep_session *s, struct sk_buff *skb)\n{\n\tstruct net_device *dev = s->dev;\n\tstruct sk_buff *nskb;\n\tu8 type, ctrl_type;\n\n\tdev->stats.rx_bytes += skb->len;\n\n\ttype = *(u8 *) skb->data;\n\tskb_pull(skb, 1);\n\tctrl_type = *(u8 *)skb->data;\n\n\tif ((type & BNEP_TYPE_MASK) >= sizeof(__bnep_rx_hlen))\n\t\tgoto badframe;\n\n\tif ((type & BNEP_TYPE_MASK) == BNEP_CONTROL) {\n\t\tif (bnep_rx_control(s, skb->data, skb->len) < 0) {\n\t\t\tdev->stats.tx_errors++;\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!(type & BNEP_EXT_HEADER)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tswitch (ctrl_type) {\n\t\tcase BNEP_SETUP_CONN_REQ:\n\t\t\t \n\t\t\tif (!skb_pull(skb, 2 + *(u8 *)(skb->data + 1) * 2))\n\t\t\t\tgoto badframe;\n\t\t\tbreak;\n\t\tcase BNEP_FILTER_MULTI_ADDR_SET:\n\t\tcase BNEP_FILTER_NET_TYPE_SET:\n\t\t\t \n\t\t\tif (!skb_pull(skb, 3 + *(u16 *)(skb->data + 1) * 2))\n\t\t\t\tgoto badframe;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tskb_reset_mac_header(skb);\n\n\t\t \n\t\tif (!skb_pull(skb, __bnep_rx_hlen[type & BNEP_TYPE_MASK]))\n\t\t\tgoto badframe;\n\n\t\ts->eh.h_proto = get_unaligned((__be16 *) (skb->data - 2));\n\t}\n\n\tif (type & BNEP_EXT_HEADER) {\n\t\tif (bnep_rx_extension(s, skb) < 0)\n\t\t\tgoto badframe;\n\t}\n\n\t \n\tif (ntohs(s->eh.h_proto) == ETH_P_8021Q) {\n\t\tif (!skb_pull(skb, 4))\n\t\t\tgoto badframe;\n\t\ts->eh.h_proto = get_unaligned((__be16 *) (skb->data - 2));\n\t}\n\n\t \n\tnskb = alloc_skb(2 + ETH_HLEN + skb->len, GFP_KERNEL);\n\tif (!nskb) {\n\t\tdev->stats.rx_dropped++;\n\t\tkfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(nskb, 2);\n\n\t \n\tswitch (type & BNEP_TYPE_MASK) {\n\tcase BNEP_COMPRESSED:\n\t\t__skb_put_data(nskb, &s->eh, ETH_HLEN);\n\t\tbreak;\n\n\tcase BNEP_COMPRESSED_SRC_ONLY:\n\t\t__skb_put_data(nskb, s->eh.h_dest, ETH_ALEN);\n\t\t__skb_put_data(nskb, skb_mac_header(skb), ETH_ALEN);\n\t\tput_unaligned(s->eh.h_proto, (__be16 *) __skb_put(nskb, 2));\n\t\tbreak;\n\n\tcase BNEP_COMPRESSED_DST_ONLY:\n\t\t__skb_put_data(nskb, skb_mac_header(skb), ETH_ALEN);\n\t\t__skb_put_data(nskb, s->eh.h_source, ETH_ALEN + 2);\n\t\tbreak;\n\n\tcase BNEP_GENERAL:\n\t\t__skb_put_data(nskb, skb_mac_header(skb), ETH_ALEN * 2);\n\t\tput_unaligned(s->eh.h_proto, (__be16 *) __skb_put(nskb, 2));\n\t\tbreak;\n\t}\n\n\tskb_copy_from_linear_data(skb, __skb_put(nskb, skb->len), skb->len);\n\tkfree_skb(skb);\n\n\tdev->stats.rx_packets++;\n\tnskb->ip_summed = CHECKSUM_NONE;\n\tnskb->protocol  = eth_type_trans(nskb, dev);\n\tnetif_rx(nskb);\n\treturn 0;\n\nbadframe:\n\tdev->stats.rx_errors++;\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic u8 __bnep_tx_types[] = {\n\tBNEP_GENERAL,\n\tBNEP_COMPRESSED_SRC_ONLY,\n\tBNEP_COMPRESSED_DST_ONLY,\n\tBNEP_COMPRESSED\n};\n\nstatic int bnep_tx_frame(struct bnep_session *s, struct sk_buff *skb)\n{\n\tstruct ethhdr *eh = (void *) skb->data;\n\tstruct socket *sock = s->sock;\n\tstruct kvec iv[3];\n\tint len = 0, il = 0;\n\tu8 type = 0;\n\n\tBT_DBG(\"skb %p dev %p type %u\", skb, skb->dev, skb->pkt_type);\n\n\tif (!skb->dev) {\n\t\t \n\t\tgoto send;\n\t}\n\n\tiv[il++] = (struct kvec) { &type, 1 };\n\tlen++;\n\n\tif (compress_src && ether_addr_equal(eh->h_dest, s->eh.h_source))\n\t\ttype |= 0x01;\n\n\tif (compress_dst && ether_addr_equal(eh->h_source, s->eh.h_dest))\n\t\ttype |= 0x02;\n\n\tif (type)\n\t\tskb_pull(skb, ETH_ALEN * 2);\n\n\ttype = __bnep_tx_types[type];\n\tswitch (type) {\n\tcase BNEP_COMPRESSED_SRC_ONLY:\n\t\tiv[il++] = (struct kvec) { eh->h_source, ETH_ALEN };\n\t\tlen += ETH_ALEN;\n\t\tbreak;\n\n\tcase BNEP_COMPRESSED_DST_ONLY:\n\t\tiv[il++] = (struct kvec) { eh->h_dest, ETH_ALEN };\n\t\tlen += ETH_ALEN;\n\t\tbreak;\n\t}\n\nsend:\n\tiv[il++] = (struct kvec) { skb->data, skb->len };\n\tlen += skb->len;\n\n\t \n\t{\n\t\tlen = kernel_sendmsg(sock, &s->msg, iv, il, len);\n\t}\n\tkfree_skb(skb);\n\n\tif (len > 0) {\n\t\ts->dev->stats.tx_bytes += len;\n\t\ts->dev->stats.tx_packets++;\n\t\treturn 0;\n\t}\n\n\treturn len;\n}\n\nstatic int bnep_session(void *arg)\n{\n\tstruct bnep_session *s = arg;\n\tstruct net_device *dev = s->dev;\n\tstruct sock *sk = s->sock->sk;\n\tstruct sk_buff *skb;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tBT_DBG(\"\");\n\n\tset_user_nice(current, -15);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (atomic_read(&s->terminate))\n\t\t\tbreak;\n\t\t \n\t\twhile ((skb = skb_dequeue(&sk->sk_receive_queue))) {\n\t\t\tskb_orphan(skb);\n\t\t\tif (!skb_linearize(skb))\n\t\t\t\tbnep_rx_frame(s, skb);\n\t\t\telse\n\t\t\t\tkfree_skb(skb);\n\t\t}\n\n\t\tif (sk->sk_state != BT_CONNECTED)\n\t\t\tbreak;\n\n\t\t \n\t\twhile ((skb = skb_dequeue(&sk->sk_write_queue)))\n\t\t\tif (bnep_tx_frame(s, skb))\n\t\t\t\tbreak;\n\t\tnetif_wake_queue(dev);\n\n\t\t \n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\t \n\tdown_write(&bnep_session_sem);\n\n\t \n\tunregister_netdev(dev);\n\n\t \n\ts->sock->sk->sk_err = EUNATCH;\n\n\twake_up_interruptible(sk_sleep(s->sock->sk));\n\n\t \n\tfput(s->sock->file);\n\n\t__bnep_unlink_session(s);\n\n\tup_write(&bnep_session_sem);\n\tfree_netdev(dev);\n\tmodule_put_and_kthread_exit(0);\n\treturn 0;\n}\n\nstatic struct device *bnep_get_device(struct bnep_session *session)\n{\n\tstruct l2cap_conn *conn = l2cap_pi(session->sock->sk)->chan->conn;\n\n\tif (!conn || !conn->hcon)\n\t\treturn NULL;\n\n\treturn &conn->hcon->dev;\n}\n\nstatic struct device_type bnep_type = {\n\t.name\t= \"bluetooth\",\n};\n\nint bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)\n{\n\tu32 valid_flags = BIT(BNEP_SETUP_RESPONSE);\n\tstruct net_device *dev;\n\tstruct bnep_session *s, *ss;\n\tu8 dst[ETH_ALEN], src[ETH_ALEN];\n\tint err;\n\n\tBT_DBG(\"\");\n\n\tif (!l2cap_is_socket(sock))\n\t\treturn -EBADFD;\n\n\tif (req->flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\tbaswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);\n\tbaswap((void *) src, &l2cap_pi(sock->sk)->chan->src);\n\n\t \n\tdev = alloc_netdev(sizeof(struct bnep_session),\n\t\t\t   (*req->device) ? req->device : \"bnep%d\",\n\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t   bnep_net_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdown_write(&bnep_session_sem);\n\n\tss = __bnep_get_session(dst);\n\tif (ss && ss->state == BT_CONNECTED) {\n\t\terr = -EEXIST;\n\t\tgoto failed;\n\t}\n\n\ts = netdev_priv(dev);\n\n\t \n\tmemcpy(s->eh.h_dest,   &src, ETH_ALEN);\n\tmemcpy(s->eh.h_source, &dst, ETH_ALEN);\n\teth_hw_addr_set(dev, s->eh.h_dest);\n\n\ts->dev   = dev;\n\ts->sock  = sock;\n\ts->role  = req->role;\n\ts->state = BT_CONNECTED;\n\ts->flags = req->flags;\n\n\ts->msg.msg_flags = MSG_NOSIGNAL;\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\t \n\ts->mc_filter = ~0LL;\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\t \n\tbnep_set_default_proto_filter(s);\n#endif\n\n\tSET_NETDEV_DEV(dev, bnep_get_device(s));\n\tSET_NETDEV_DEVTYPE(dev, &bnep_type);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto failed;\n\n\t__bnep_link_session(s);\n\n\t__module_get(THIS_MODULE);\n\ts->task = kthread_run(bnep_session, s, \"kbnepd %s\", dev->name);\n\tif (IS_ERR(s->task)) {\n\t\t \n\t\tmodule_put(THIS_MODULE);\n\t\tunregister_netdev(dev);\n\t\t__bnep_unlink_session(s);\n\t\terr = PTR_ERR(s->task);\n\t\tgoto failed;\n\t}\n\n\tup_write(&bnep_session_sem);\n\tstrcpy(req->device, dev->name);\n\treturn 0;\n\nfailed:\n\tup_write(&bnep_session_sem);\n\tfree_netdev(dev);\n\treturn err;\n}\n\nint bnep_del_connection(struct bnep_conndel_req *req)\n{\n\tu32 valid_flags = 0;\n\tstruct bnep_session *s;\n\tint  err = 0;\n\n\tBT_DBG(\"\");\n\n\tif (req->flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\tdown_read(&bnep_session_sem);\n\n\ts = __bnep_get_session(req->dst);\n\tif (s) {\n\t\tatomic_inc(&s->terminate);\n\t\twake_up_interruptible(sk_sleep(s->sock->sk));\n\t} else\n\t\terr = -ENOENT;\n\n\tup_read(&bnep_session_sem);\n\treturn err;\n}\n\nstatic void __bnep_copy_ci(struct bnep_conninfo *ci, struct bnep_session *s)\n{\n\tu32 valid_flags = BIT(BNEP_SETUP_RESPONSE);\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemcpy(ci->dst, s->eh.h_source, ETH_ALEN);\n\tstrcpy(ci->device, s->dev->name);\n\tci->flags = s->flags & valid_flags;\n\tci->state = s->state;\n\tci->role  = s->role;\n}\n\nint bnep_get_connlist(struct bnep_connlist_req *req)\n{\n\tstruct bnep_session *s;\n\tint err = 0, n = 0;\n\n\tdown_read(&bnep_session_sem);\n\n\tlist_for_each_entry(s, &bnep_session_list, list) {\n\t\tstruct bnep_conninfo ci;\n\n\t\t__bnep_copy_ci(&ci, s);\n\n\t\tif (copy_to_user(req->ci, &ci, sizeof(ci))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (++n >= req->cnum)\n\t\t\tbreak;\n\n\t\treq->ci++;\n\t}\n\treq->cnum = n;\n\n\tup_read(&bnep_session_sem);\n\treturn err;\n}\n\nint bnep_get_conninfo(struct bnep_conninfo *ci)\n{\n\tstruct bnep_session *s;\n\tint err = 0;\n\n\tdown_read(&bnep_session_sem);\n\n\ts = __bnep_get_session(ci->dst);\n\tif (s)\n\t\t__bnep_copy_ci(ci, s);\n\telse\n\t\terr = -ENOENT;\n\n\tup_read(&bnep_session_sem);\n\treturn err;\n}\n\nstatic int __init bnep_init(void)\n{\n\tchar flt[50] = \"\";\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\tstrcat(flt, \"protocol \");\n#endif\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\tstrcat(flt, \"multicast\");\n#endif\n\n\tBT_INFO(\"BNEP (Ethernet Emulation) ver %s\", VERSION);\n\tif (flt[0])\n\t\tBT_INFO(\"BNEP filters: %s\", flt);\n\n\tbnep_sock_init();\n\treturn 0;\n}\n\nstatic void __exit bnep_exit(void)\n{\n\tbnep_sock_cleanup();\n}\n\nmodule_init(bnep_init);\nmodule_exit(bnep_exit);\n\nmodule_param(compress_src, bool, 0644);\nMODULE_PARM_DESC(compress_src, \"Compress sources headers\");\n\nmodule_param(compress_dst, bool, 0644);\nMODULE_PARM_DESC(compress_dst, \"Compress destination headers\");\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth BNEP ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"bt-proto-4\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}