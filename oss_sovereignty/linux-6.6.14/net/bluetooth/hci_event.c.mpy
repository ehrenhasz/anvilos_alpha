{
  "module_name": "hci_event.c",
  "hash_id": "52954ebde3889192ca4e1fe2beb73926a3bdb0a5e18628799db68b228d276943",
  "original_prompt": "Ingested from linux-6.6.14/net/bluetooth/hci_event.c",
  "human_readable_source": " \n\n \n\n#include <asm/unaligned.h>\n#include <linux/crypto.h>\n#include <crypto/algapi.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/mgmt.h>\n\n#include \"hci_request.h\"\n#include \"hci_debugfs.h\"\n#include \"hci_codec.h\"\n#include \"a2mp.h\"\n#include \"amp.h\"\n#include \"smp.h\"\n#include \"msft.h\"\n#include \"eir.h\"\n\n#define ZERO_KEY \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n\t\t \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n#define secs_to_jiffies(_secs) msecs_to_jiffies((_secs) * 1000)\n\n \n\nstatic void *hci_ev_skb_pull(struct hci_dev *hdev, struct sk_buff *skb,\n\t\t\t     u8 ev, size_t len)\n{\n\tvoid *data;\n\n\tdata = skb_pull_data(skb, len);\n\tif (!data)\n\t\tbt_dev_err(hdev, \"Malformed Event: 0x%2.2x\", ev);\n\n\treturn data;\n}\n\nstatic void *hci_cc_skb_pull(struct hci_dev *hdev, struct sk_buff *skb,\n\t\t\t     u16 op, size_t len)\n{\n\tvoid *data;\n\n\tdata = skb_pull_data(skb, len);\n\tif (!data)\n\t\tbt_dev_err(hdev, \"Malformed Command Complete: 0x%4.4x\", op);\n\n\treturn data;\n}\n\nstatic void *hci_le_ev_skb_pull(struct hci_dev *hdev, struct sk_buff *skb,\n\t\t\t\tu8 ev, size_t len)\n{\n\tvoid *data;\n\n\tdata = skb_pull_data(skb, len);\n\tif (!data)\n\t\tbt_dev_err(hdev, \"Malformed LE Event: 0x%2.2x\", ev);\n\n\treturn data;\n}\n\nstatic u8 hci_cc_inquiry_cancel(struct hci_dev *hdev, void *data,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\t \n\tif (rp->status == 0x0c && !test_bit(HCI_INQUIRY, &hdev->flags)) {\n\t\tbt_dev_warn(hdev, \"Ignoring error of Inquiry Cancel command\");\n\t\trp->status = 0x00;\n\t}\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tclear_bit(HCI_INQUIRY, &hdev->flags);\n\tsmp_mb__after_atomic();  \n\twake_up_bit(&hdev->flags, HCI_INQUIRY);\n\n\thci_dev_lock(hdev);\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_LE_SCAN) ||\n\t    hdev->le_scan_type != LE_SCAN_ACTIVE)\n\t\thci_discovery_set_state(hdev, DISCOVERY_STOPPED);\n\thci_dev_unlock(hdev);\n\n\thci_conn_check_pending(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_periodic_inq(struct hci_dev *hdev, void *data,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thci_dev_set_flag(hdev, HCI_PERIODIC_INQ);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_exit_periodic_inq(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thci_dev_clear_flag(hdev, HCI_PERIODIC_INQ);\n\n\thci_conn_check_pending(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_remote_name_req_cancel(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_role_discovery(struct hci_dev *hdev, void *data,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_rp_role_discovery *rp = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\n\tif (conn)\n\t\tconn->role = rp->role;\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_link_policy(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_rp_read_link_policy *rp = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\n\tif (conn)\n\t\tconn->link_policy = __le16_to_cpu(rp->policy);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_link_policy(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_rp_write_link_policy *rp = data;\n\tstruct hci_conn *conn;\n\tvoid *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LINK_POLICY);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\n\tif (conn)\n\t\tconn->link_policy = get_unaligned_le16(sent + 2);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_def_link_policy(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_rp_read_def_link_policy *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->link_policy = __le16_to_cpu(rp->policy);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_def_link_policy(struct hci_dev *hdev, void *data,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tvoid *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_DEF_LINK_POLICY);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thdev->link_policy = get_unaligned_le16(sent);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_reset(struct hci_dev *hdev, void *data, struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tclear_bit(HCI_RESET, &hdev->flags);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\t \n\thci_dev_clear_volatile_flags(hdev);\n\n\thci_discovery_set_state(hdev, DISCOVERY_STOPPED);\n\n\thdev->inq_tx_power = HCI_TX_POWER_INVALID;\n\thdev->adv_tx_power = HCI_TX_POWER_INVALID;\n\n\tmemset(hdev->adv_data, 0, sizeof(hdev->adv_data));\n\thdev->adv_data_len = 0;\n\n\tmemset(hdev->scan_rsp_data, 0, sizeof(hdev->scan_rsp_data));\n\thdev->scan_rsp_data_len = 0;\n\n\thdev->le_scan_type = LE_SCAN_PASSIVE;\n\n\thdev->ssp_debug_mode = 0;\n\n\thci_bdaddr_list_clear(&hdev->le_accept_list);\n\thci_bdaddr_list_clear(&hdev->le_resolv_list);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_stored_link_key(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_rp_read_stored_link_key *rp = data;\n\tstruct hci_cp_read_stored_link_key *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_READ_STORED_LINK_KEY);\n\tif (!sent)\n\t\treturn rp->status;\n\n\tif (!rp->status && sent->read_all == 0x01) {\n\t\thdev->stored_max_keys = le16_to_cpu(rp->max_keys);\n\t\thdev->stored_num_keys = le16_to_cpu(rp->num_keys);\n\t}\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_delete_stored_link_key(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_rp_delete_stored_link_key *rp = data;\n\tu16 num_keys;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tnum_keys = le16_to_cpu(rp->num_keys);\n\n\tif (num_keys <= hdev->stored_num_keys)\n\t\thdev->stored_num_keys -= num_keys;\n\telse\n\t\thdev->stored_num_keys = 0;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_local_name(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tvoid *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LOCAL_NAME);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_set_local_name_complete(hdev, sent, rp->status);\n\telse if (!rp->status)\n\t\tmemcpy(hdev->dev_name, sent, HCI_MAX_NAME_LENGTH);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_local_name(struct hci_dev *hdev, void *data,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_name *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tif (hci_dev_test_flag(hdev, HCI_SETUP) ||\n\t    hci_dev_test_flag(hdev, HCI_CONFIG))\n\t\tmemcpy(hdev->dev_name, rp->name, HCI_MAX_NAME_LENGTH);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_auth_enable(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tvoid *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_AUTH_ENABLE);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tif (!rp->status) {\n\t\t__u8 param = *((__u8 *) sent);\n\n\t\tif (param == AUTH_ENABLED)\n\t\t\tset_bit(HCI_AUTH, &hdev->flags);\n\t\telse\n\t\t\tclear_bit(HCI_AUTH, &hdev->flags);\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_auth_enable_complete(hdev, rp->status);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_encrypt_mode(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\t__u8 param;\n\tvoid *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_ENCRYPT_MODE);\n\tif (!sent)\n\t\treturn rp->status;\n\n\tparam = *((__u8 *) sent);\n\n\tif (param)\n\t\tset_bit(HCI_ENCRYPT, &hdev->flags);\n\telse\n\t\tclear_bit(HCI_ENCRYPT, &hdev->flags);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_scan_enable(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\t__u8 param;\n\tvoid *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_SCAN_ENABLE);\n\tif (!sent)\n\t\treturn rp->status;\n\n\tparam = *((__u8 *) sent);\n\n\thci_dev_lock(hdev);\n\n\tif (rp->status) {\n\t\thdev->discov_timeout = 0;\n\t\tgoto done;\n\t}\n\n\tif (param & SCAN_INQUIRY)\n\t\tset_bit(HCI_ISCAN, &hdev->flags);\n\telse\n\t\tclear_bit(HCI_ISCAN, &hdev->flags);\n\n\tif (param & SCAN_PAGE)\n\t\tset_bit(HCI_PSCAN, &hdev->flags);\n\telse\n\t\tclear_bit(HCI_PSCAN, &hdev->flags);\n\ndone:\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_set_event_filter(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_set_event_filter *cp;\n\tvoid *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_SET_EVENT_FLT);\n\tif (!sent)\n\t\treturn rp->status;\n\n\tcp = (struct hci_cp_set_event_filter *)sent;\n\n\tif (cp->flt_type == HCI_FLT_CLEAR_ALL)\n\t\thci_dev_clear_flag(hdev, HCI_EVENT_FILTER_CONFIGURED);\n\telse\n\t\thci_dev_set_flag(hdev, HCI_EVENT_FILTER_CONFIGURED);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_class_of_dev(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_rp_read_class_of_dev *rp = data;\n\n\tif (WARN_ON(!hdev))\n\t\treturn HCI_ERROR_UNSPECIFIED;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tmemcpy(hdev->dev_class, rp->dev_class, 3);\n\n\tbt_dev_dbg(hdev, \"class 0x%.2x%.2x%.2x\", hdev->dev_class[2],\n\t\t   hdev->dev_class[1], hdev->dev_class[0]);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_class_of_dev(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tvoid *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_CLASS_OF_DEV);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tif (!rp->status)\n\t\tmemcpy(hdev->dev_class, sent, 3);\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_set_class_of_dev_complete(hdev, sent, rp->status);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_voice_setting(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_rp_read_voice_setting *rp = data;\n\t__u16 setting;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsetting = __le16_to_cpu(rp->voice_setting);\n\n\tif (hdev->voice_setting == setting)\n\t\treturn rp->status;\n\n\thdev->voice_setting = setting;\n\n\tbt_dev_dbg(hdev, \"voice setting 0x%4.4x\", setting);\n\n\tif (hdev->notify)\n\t\thdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_voice_setting(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\t__u16 setting;\n\tvoid *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);\n\tif (!sent)\n\t\treturn rp->status;\n\n\tsetting = get_unaligned_le16(sent);\n\n\tif (hdev->voice_setting == setting)\n\t\treturn rp->status;\n\n\thdev->voice_setting = setting;\n\n\tbt_dev_dbg(hdev, \"voice setting 0x%4.4x\", setting);\n\n\tif (hdev->notify)\n\t\thdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_num_supported_iac(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_rp_read_num_supported_iac *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->num_iac = rp->num_iac;\n\n\tbt_dev_dbg(hdev, \"num iac %d\", hdev->num_iac);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_ssp_mode(struct hci_dev *hdev, void *data,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_write_ssp_mode *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_SSP_MODE);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tif (!rp->status) {\n\t\tif (sent->mode)\n\t\t\thdev->features[1][0] |= LMP_HOST_SSP;\n\t\telse\n\t\t\thdev->features[1][0] &= ~LMP_HOST_SSP;\n\t}\n\n\tif (!rp->status) {\n\t\tif (sent->mode)\n\t\t\thci_dev_set_flag(hdev, HCI_SSP_ENABLED);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_SSP_ENABLED);\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_sc_support(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_write_sc_support *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_SC_SUPPORT);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tif (!rp->status) {\n\t\tif (sent->support)\n\t\t\thdev->features[1][0] |= LMP_HOST_SC;\n\t\telse\n\t\t\thdev->features[1][0] &= ~LMP_HOST_SC;\n\t}\n\n\tif (!hci_dev_test_flag(hdev, HCI_MGMT) && !rp->status) {\n\t\tif (sent->support)\n\t\t\thci_dev_set_flag(hdev, HCI_SC_ENABLED);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_SC_ENABLED);\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_local_version(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_version *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tif (hci_dev_test_flag(hdev, HCI_SETUP) ||\n\t    hci_dev_test_flag(hdev, HCI_CONFIG)) {\n\t\thdev->hci_ver = rp->hci_ver;\n\t\thdev->hci_rev = __le16_to_cpu(rp->hci_rev);\n\t\thdev->lmp_ver = rp->lmp_ver;\n\t\thdev->manufacturer = __le16_to_cpu(rp->manufacturer);\n\t\thdev->lmp_subver = __le16_to_cpu(rp->lmp_subver);\n\t}\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_enc_key_size(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_rp_read_enc_key_size *rp = data;\n\tstruct hci_conn *conn;\n\tu16 handle;\n\tu8 status = rp->status;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\thandle = le16_to_cpu(rp->handle);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (!conn) {\n\t\tstatus = 0xFF;\n\t\tgoto done;\n\t}\n\n\t \n\tif (status) {\n\t\tbt_dev_err(hdev, \"failed to read key size for handle %u\",\n\t\t\t   handle);\n\t\tconn->enc_key_size = 0;\n\t} else {\n\t\tconn->enc_key_size = rp->key_size;\n\t\tstatus = 0;\n\n\t\tif (conn->enc_key_size < hdev->min_enc_key_size) {\n\t\t\t \n\t\t\tstatus = HCI_ERROR_AUTH_FAILURE;\n\t\t\tclear_bit(HCI_CONN_ENCRYPT, &conn->flags);\n\t\t\tclear_bit(HCI_CONN_AES_CCM, &conn->flags);\n\t\t}\n\t}\n\n\thci_encrypt_cfm(conn, status);\n\ndone:\n\thci_dev_unlock(hdev);\n\n\treturn status;\n}\n\nstatic u8 hci_cc_read_local_commands(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_commands *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tif (hci_dev_test_flag(hdev, HCI_SETUP) ||\n\t    hci_dev_test_flag(hdev, HCI_CONFIG))\n\t\tmemcpy(hdev->commands, rp->commands, sizeof(hdev->commands));\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_auth_payload_timeout(struct hci_dev *hdev, void *data,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_rp_read_auth_payload_to *rp = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\n\tif (conn)\n\t\tconn->auth_payload_timeout = __le16_to_cpu(rp->timeout);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_auth_payload_timeout(struct hci_dev *hdev, void *data,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_rp_write_auth_payload_to *rp = data;\n\tstruct hci_conn *conn;\n\tvoid *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_AUTH_PAYLOAD_TO);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\n\tif (!conn) {\n\t\trp->status = 0xff;\n\t\tgoto unlock;\n\t}\n\n\tif (!rp->status)\n\t\tconn->auth_payload_timeout = get_unaligned_le16(sent + 2);\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_local_features(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_features *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tmemcpy(hdev->features, rp->features, 8);\n\n\t \n\n\tif (hdev->features[0][0] & LMP_3SLOT)\n\t\thdev->pkt_type |= (HCI_DM3 | HCI_DH3);\n\n\tif (hdev->features[0][0] & LMP_5SLOT)\n\t\thdev->pkt_type |= (HCI_DM5 | HCI_DH5);\n\n\tif (hdev->features[0][1] & LMP_HV2) {\n\t\thdev->pkt_type  |= (HCI_HV2);\n\t\thdev->esco_type |= (ESCO_HV2);\n\t}\n\n\tif (hdev->features[0][1] & LMP_HV3) {\n\t\thdev->pkt_type  |= (HCI_HV3);\n\t\thdev->esco_type |= (ESCO_HV3);\n\t}\n\n\tif (lmp_esco_capable(hdev))\n\t\thdev->esco_type |= (ESCO_EV3);\n\n\tif (hdev->features[0][4] & LMP_EV4)\n\t\thdev->esco_type |= (ESCO_EV4);\n\n\tif (hdev->features[0][4] & LMP_EV5)\n\t\thdev->esco_type |= (ESCO_EV5);\n\n\tif (hdev->features[0][5] & LMP_EDR_ESCO_2M)\n\t\thdev->esco_type |= (ESCO_2EV3);\n\n\tif (hdev->features[0][5] & LMP_EDR_ESCO_3M)\n\t\thdev->esco_type |= (ESCO_3EV3);\n\n\tif (hdev->features[0][5] & LMP_EDR_3S_ESCO)\n\t\thdev->esco_type |= (ESCO_2EV5 | ESCO_3EV5);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_local_ext_features(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_ext_features *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tif (hdev->max_page < rp->max_page) {\n\t\tif (test_bit(HCI_QUIRK_BROKEN_LOCAL_EXT_FEATURES_PAGE_2,\n\t\t\t     &hdev->quirks))\n\t\t\tbt_dev_warn(hdev, \"broken local ext features page 2\");\n\t\telse\n\t\t\thdev->max_page = rp->max_page;\n\t}\n\n\tif (rp->page < HCI_MAX_PAGES)\n\t\tmemcpy(hdev->features[rp->page], rp->features, 8);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_flow_control_mode(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_rp_read_flow_control_mode *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->flow_ctl_mode = rp->mode;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_buffer_size(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_rp_read_buffer_size *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->acl_mtu  = __le16_to_cpu(rp->acl_mtu);\n\thdev->sco_mtu  = rp->sco_mtu;\n\thdev->acl_pkts = __le16_to_cpu(rp->acl_max_pkt);\n\thdev->sco_pkts = __le16_to_cpu(rp->sco_max_pkt);\n\n\tif (test_bit(HCI_QUIRK_FIXUP_BUFFER_SIZE, &hdev->quirks)) {\n\t\thdev->sco_mtu  = 64;\n\t\thdev->sco_pkts = 8;\n\t}\n\n\thdev->acl_cnt = hdev->acl_pkts;\n\thdev->sco_cnt = hdev->sco_pkts;\n\n\tBT_DBG(\"%s acl mtu %d:%d sco mtu %d:%d\", hdev->name, hdev->acl_mtu,\n\t       hdev->acl_pkts, hdev->sco_mtu, hdev->sco_pkts);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_bd_addr(struct hci_dev *hdev, void *data,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_rp_read_bd_addr *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tif (test_bit(HCI_INIT, &hdev->flags))\n\t\tbacpy(&hdev->bdaddr, &rp->bdaddr);\n\n\tif (hci_dev_test_flag(hdev, HCI_SETUP))\n\t\tbacpy(&hdev->setup_addr, &rp->bdaddr);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_local_pairing_opts(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_pairing_opts *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tif (hci_dev_test_flag(hdev, HCI_SETUP) ||\n\t    hci_dev_test_flag(hdev, HCI_CONFIG)) {\n\t\thdev->pairing_opts = rp->pairing_opts;\n\t\thdev->max_enc_key_size = rp->max_key_size;\n\t}\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_page_scan_activity(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_rp_read_page_scan_activity *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tif (test_bit(HCI_INIT, &hdev->flags)) {\n\t\thdev->page_scan_interval = __le16_to_cpu(rp->interval);\n\t\thdev->page_scan_window = __le16_to_cpu(rp->window);\n\t}\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_page_scan_activity(struct hci_dev *hdev, void *data,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_write_page_scan_activity *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_PAGE_SCAN_ACTIVITY);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thdev->page_scan_interval = __le16_to_cpu(sent->interval);\n\thdev->page_scan_window = __le16_to_cpu(sent->window);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_page_scan_type(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_rp_read_page_scan_type *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tif (test_bit(HCI_INIT, &hdev->flags))\n\t\thdev->page_scan_type = rp->type;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_page_scan_type(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tu8 *type;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\ttype = hci_sent_cmd_data(hdev, HCI_OP_WRITE_PAGE_SCAN_TYPE);\n\tif (type)\n\t\thdev->page_scan_type = *type;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_data_block_size(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_rp_read_data_block_size *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->block_mtu = __le16_to_cpu(rp->max_acl_len);\n\thdev->block_len = __le16_to_cpu(rp->block_len);\n\thdev->num_blocks = __le16_to_cpu(rp->num_blocks);\n\n\thdev->block_cnt = hdev->num_blocks;\n\n\tBT_DBG(\"%s blk mtu %d cnt %d len %d\", hdev->name, hdev->block_mtu,\n\t       hdev->block_cnt, hdev->block_len);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_clock(struct hci_dev *hdev, void *data,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_rp_read_clock *rp = data;\n\tstruct hci_cp_read_clock *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_READ_CLOCK);\n\tif (!cp)\n\t\tgoto unlock;\n\n\tif (cp->which == 0x00) {\n\t\thdev->clock = le32_to_cpu(rp->clock);\n\t\tgoto unlock;\n\t}\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\n\tif (conn) {\n\t\tconn->clock = le32_to_cpu(rp->clock);\n\t\tconn->clock_accuracy = le16_to_cpu(rp->accuracy);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_local_amp_info(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_amp_info *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->amp_status = rp->amp_status;\n\thdev->amp_total_bw = __le32_to_cpu(rp->total_bw);\n\thdev->amp_max_bw = __le32_to_cpu(rp->max_bw);\n\thdev->amp_min_latency = __le32_to_cpu(rp->min_latency);\n\thdev->amp_max_pdu = __le32_to_cpu(rp->max_pdu);\n\thdev->amp_type = rp->amp_type;\n\thdev->amp_pal_cap = __le16_to_cpu(rp->pal_cap);\n\thdev->amp_assoc_size = __le16_to_cpu(rp->max_assoc_size);\n\thdev->amp_be_flush_to = __le32_to_cpu(rp->be_flush_to);\n\thdev->amp_max_flush_to = __le32_to_cpu(rp->max_flush_to);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_inq_rsp_tx_power(struct hci_dev *hdev, void *data,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_rp_read_inq_rsp_tx_power *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->inq_tx_power = rp->tx_power;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_def_err_data_reporting(struct hci_dev *hdev, void *data,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_rp_read_def_err_data_reporting *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->err_data_reporting = rp->err_data_reporting;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_def_err_data_reporting(struct hci_dev *hdev, void *data,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_write_def_err_data_reporting *cp;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_WRITE_DEF_ERR_DATA_REPORTING);\n\tif (!cp)\n\t\treturn rp->status;\n\n\thdev->err_data_reporting = cp->err_data_reporting;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_pin_code_reply(struct hci_dev *hdev, void *data,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_rp_pin_code_reply *rp = data;\n\tstruct hci_cp_pin_code_reply *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\thci_dev_lock(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_pin_code_reply_complete(hdev, &rp->bdaddr, rp->status);\n\n\tif (rp->status)\n\t\tgoto unlock;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_PIN_CODE_REPLY);\n\tif (!cp)\n\t\tgoto unlock;\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);\n\tif (conn)\n\t\tconn->pin_length = cp->pin_len;\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_pin_code_neg_reply(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_rp_pin_code_neg_reply *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\thci_dev_lock(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_pin_code_neg_reply_complete(hdev, &rp->bdaddr,\n\t\t\t\t\t\t rp->status);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_read_buffer_size(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_buffer_size *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->le_mtu = __le16_to_cpu(rp->le_mtu);\n\thdev->le_pkts = rp->le_max_pkt;\n\n\thdev->le_cnt = hdev->le_pkts;\n\n\tBT_DBG(\"%s le mtu %d:%d\", hdev->name, hdev->le_mtu, hdev->le_pkts);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_read_local_features(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_local_features *rp = data;\n\n\tBT_DBG(\"%s status 0x%2.2x\", hdev->name, rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tmemcpy(hdev->le_features, rp->features, 8);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_read_adv_tx_power(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_adv_tx_power *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->adv_tx_power = rp->tx_power;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_user_confirm_reply(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_rp_user_confirm_reply *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\thci_dev_lock(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_user_confirm_reply_complete(hdev, &rp->bdaddr, ACL_LINK, 0,\n\t\t\t\t\t\t rp->status);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_user_confirm_neg_reply(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_rp_user_confirm_reply *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\thci_dev_lock(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_user_confirm_neg_reply_complete(hdev, &rp->bdaddr,\n\t\t\t\t\t\t     ACL_LINK, 0, rp->status);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_user_passkey_reply(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_rp_user_confirm_reply *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\thci_dev_lock(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_user_passkey_reply_complete(hdev, &rp->bdaddr, ACL_LINK,\n\t\t\t\t\t\t 0, rp->status);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_user_passkey_neg_reply(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_rp_user_confirm_reply *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\thci_dev_lock(hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_user_passkey_neg_reply_complete(hdev, &rp->bdaddr,\n\t\t\t\t\t\t     ACL_LINK, 0, rp->status);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_local_oob_data(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_oob_data *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_local_oob_ext_data(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_oob_ext_data *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_random_addr(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tbdaddr_t *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_RANDOM_ADDR);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tbacpy(&hdev->random_addr, sent);\n\n\tif (!bacmp(&hdev->rpa, sent)) {\n\t\thci_dev_clear_flag(hdev, HCI_RPA_EXPIRED);\n\t\tqueue_delayed_work(hdev->workqueue, &hdev->rpa_expired,\n\t\t\t\t   secs_to_jiffies(hdev->rpa_timeout));\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_default_phy(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_le_set_default_phy *cp;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_DEFAULT_PHY);\n\tif (!cp)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\thdev->le_tx_def_phys = cp->tx_phys;\n\thdev->le_rx_def_phys = cp->rx_phys;\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_adv_set_random_addr(struct hci_dev *hdev, void *data,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_le_set_adv_set_rand_addr *cp;\n\tstruct adv_info *adv;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_ADV_SET_RAND_ADDR);\n\t \n\tif (!cp || !cp->handle)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tadv = hci_find_adv_instance(hdev, cp->handle);\n\tif (adv) {\n\t\tbacpy(&adv->random_addr, &cp->bdaddr);\n\t\tif (!bacmp(&hdev->rpa, &cp->bdaddr)) {\n\t\t\tadv->rpa_expired = false;\n\t\t\tqueue_delayed_work(hdev->workqueue,\n\t\t\t\t\t   &adv->rpa_expired_cb,\n\t\t\t\t\t   secs_to_jiffies(hdev->rpa_timeout));\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_remove_adv_set(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tu8 *instance;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tinstance = hci_sent_cmd_data(hdev, HCI_OP_LE_REMOVE_ADV_SET);\n\tif (!instance)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\terr = hci_remove_adv_instance(hdev, *instance);\n\tif (!err)\n\t\tmgmt_advertising_removed(hci_skb_sk(hdev->sent_cmd), hdev,\n\t\t\t\t\t *instance);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_clear_adv_sets(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct adv_info *adv, *n;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tif (!hci_sent_cmd_data(hdev, HCI_OP_LE_CLEAR_ADV_SETS))\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tlist_for_each_entry_safe(adv, n, &hdev->adv_instances, list) {\n\t\tu8 instance = adv->instance;\n\n\t\terr = hci_remove_adv_instance(hdev, instance);\n\t\tif (!err)\n\t\t\tmgmt_advertising_removed(hci_skb_sk(hdev->sent_cmd),\n\t\t\t\t\t\t hdev, instance);\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_read_transmit_power(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_transmit_power *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->min_le_tx_power = rp->min_le_tx_power;\n\thdev->max_le_tx_power = rp->max_le_tx_power;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_privacy_mode(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_le_set_privacy_mode *cp;\n\tstruct hci_conn_params *params;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_PRIVACY_MODE);\n\tif (!cp)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tparams = hci_conn_params_lookup(hdev, &cp->bdaddr, cp->bdaddr_type);\n\tif (params)\n\t\tWRITE_ONCE(params->privacy_mode, cp->mode);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_adv_enable(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\t__u8 *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_ADV_ENABLE);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\t \n\tif (*sent) {\n\t\tstruct hci_conn *conn;\n\n\t\thci_dev_set_flag(hdev, HCI_LE_ADV);\n\n\t\tconn = hci_lookup_le_connect(hdev);\n\t\tif (conn)\n\t\t\tqueue_delayed_work(hdev->workqueue,\n\t\t\t\t\t   &conn->le_conn_timeout,\n\t\t\t\t\t   conn->conn_timeout);\n\t} else {\n\t\thci_dev_clear_flag(hdev, HCI_LE_ADV);\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_ext_adv_enable(struct hci_dev *hdev, void *data,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_cp_le_set_ext_adv_enable *cp;\n\tstruct hci_cp_ext_adv_set *set;\n\tstruct adv_info *adv = NULL, *n;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_EXT_ADV_ENABLE);\n\tif (!cp)\n\t\treturn rp->status;\n\n\tset = (void *)cp->data;\n\n\thci_dev_lock(hdev);\n\n\tif (cp->num_of_sets)\n\t\tadv = hci_find_adv_instance(hdev, set->handle);\n\n\tif (cp->enable) {\n\t\tstruct hci_conn *conn;\n\n\t\thci_dev_set_flag(hdev, HCI_LE_ADV);\n\n\t\tif (adv && !adv->periodic)\n\t\t\tadv->enabled = true;\n\n\t\tconn = hci_lookup_le_connect(hdev);\n\t\tif (conn)\n\t\t\tqueue_delayed_work(hdev->workqueue,\n\t\t\t\t\t   &conn->le_conn_timeout,\n\t\t\t\t\t   conn->conn_timeout);\n\t} else {\n\t\tif (cp->num_of_sets) {\n\t\t\tif (adv)\n\t\t\t\tadv->enabled = false;\n\n\t\t\t \n\t\t\tlist_for_each_entry_safe(adv, n, &hdev->adv_instances,\n\t\t\t\t\t\t list) {\n\t\t\t\tif (adv->enabled)\n\t\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tlist_for_each_entry_safe(adv, n, &hdev->adv_instances,\n\t\t\t\t\t\t list)\n\t\t\t\tadv->enabled = false;\n\t\t}\n\n\t\thci_dev_clear_flag(hdev, HCI_LE_ADV);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_scan_param(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_cp_le_set_scan_param *cp;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_PARAM);\n\tif (!cp)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\thdev->le_scan_type = cp->type;\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_ext_scan_param(struct hci_dev *hdev, void *data,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_cp_le_set_ext_scan_params *cp;\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_le_scan_phy_params *phy_param;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_EXT_SCAN_PARAMS);\n\tif (!cp)\n\t\treturn rp->status;\n\n\tphy_param = (void *)cp->data;\n\n\thci_dev_lock(hdev);\n\n\thdev->le_scan_type = phy_param->type;\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic bool has_pending_adv_report(struct hci_dev *hdev)\n{\n\tstruct discovery_state *d = &hdev->discovery;\n\n\treturn bacmp(&d->last_adv_addr, BDADDR_ANY);\n}\n\nstatic void clear_pending_adv_report(struct hci_dev *hdev)\n{\n\tstruct discovery_state *d = &hdev->discovery;\n\n\tbacpy(&d->last_adv_addr, BDADDR_ANY);\n\td->last_adv_data_len = 0;\n}\n\nstatic void store_pending_adv_report(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t     u8 bdaddr_type, s8 rssi, u32 flags,\n\t\t\t\t     u8 *data, u8 len)\n{\n\tstruct discovery_state *d = &hdev->discovery;\n\n\tif (len > max_adv_len(hdev))\n\t\treturn;\n\n\tbacpy(&d->last_adv_addr, bdaddr);\n\td->last_adv_addr_type = bdaddr_type;\n\td->last_adv_rssi = rssi;\n\td->last_adv_flags = flags;\n\tmemcpy(d->last_adv_data, data, len);\n\td->last_adv_data_len = len;\n}\n\nstatic void le_set_scan_enable_complete(struct hci_dev *hdev, u8 enable)\n{\n\thci_dev_lock(hdev);\n\n\tswitch (enable) {\n\tcase LE_SCAN_ENABLE:\n\t\thci_dev_set_flag(hdev, HCI_LE_SCAN);\n\t\tif (hdev->le_scan_type == LE_SCAN_ACTIVE)\n\t\t\tclear_pending_adv_report(hdev);\n\t\tif (hci_dev_test_flag(hdev, HCI_MESH))\n\t\t\thci_discovery_set_state(hdev, DISCOVERY_FINDING);\n\t\tbreak;\n\n\tcase LE_SCAN_DISABLE:\n\t\t \n\t\tif (has_pending_adv_report(hdev)) {\n\t\t\tstruct discovery_state *d = &hdev->discovery;\n\n\t\t\tmgmt_device_found(hdev, &d->last_adv_addr, LE_LINK,\n\t\t\t\t\t  d->last_adv_addr_type, NULL,\n\t\t\t\t\t  d->last_adv_rssi, d->last_adv_flags,\n\t\t\t\t\t  d->last_adv_data,\n\t\t\t\t\t  d->last_adv_data_len, NULL, 0, 0);\n\t\t}\n\n\t\t \n\t\tcancel_delayed_work(&hdev->le_scan_disable);\n\n\t\thci_dev_clear_flag(hdev, HCI_LE_SCAN);\n\n\t\t \n\t\tif (hci_dev_test_and_clear_flag(hdev, HCI_LE_SCAN_INTERRUPTED))\n\t\t\thci_discovery_set_state(hdev, DISCOVERY_STOPPED);\n\t\telse if (!hci_dev_test_flag(hdev, HCI_LE_ADV) &&\n\t\t\t hdev->discovery.state == DISCOVERY_FINDING)\n\t\t\tqueue_work(hdev->workqueue, &hdev->reenable_adv_work);\n\n\t\tbreak;\n\n\tdefault:\n\t\tbt_dev_err(hdev, \"use of reserved LE_Scan_Enable param %d\",\n\t\t\t   enable);\n\t\tbreak;\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic u8 hci_cc_le_set_scan_enable(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_cp_le_set_scan_enable *cp;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_ENABLE);\n\tif (!cp)\n\t\treturn rp->status;\n\n\tle_set_scan_enable_complete(hdev, cp->enable);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_ext_scan_enable(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_cp_le_set_ext_scan_enable *cp;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_EXT_SCAN_ENABLE);\n\tif (!cp)\n\t\treturn rp->status;\n\n\tle_set_scan_enable_complete(hdev, cp->enable);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_read_num_adv_sets(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_num_supported_adv_sets *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x No of Adv sets %u\", rp->status,\n\t\t   rp->num_of_sets);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->le_num_of_adv_sets = rp->num_of_sets;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_read_accept_list_size(struct hci_dev *hdev, void *data,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_accept_list_size *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x size %u\", rp->status, rp->size);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->le_accept_list_size = rp->size;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_clear_accept_list(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\thci_bdaddr_list_clear(&hdev->le_accept_list);\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_add_to_accept_list(struct hci_dev *hdev, void *data,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_cp_le_add_to_accept_list *sent;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_LE_ADD_TO_ACCEPT_LIST);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\thci_bdaddr_list_add(&hdev->le_accept_list, &sent->bdaddr,\n\t\t\t    sent->bdaddr_type);\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_del_from_accept_list(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_cp_le_del_from_accept_list *sent;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_LE_DEL_FROM_ACCEPT_LIST);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\thci_bdaddr_list_del(&hdev->le_accept_list, &sent->bdaddr,\n\t\t\t    sent->bdaddr_type);\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_read_supported_states(struct hci_dev *hdev, void *data,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_supported_states *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tmemcpy(hdev->le_states, rp->le_states, 8);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_read_def_data_len(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_def_data_len *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->le_def_tx_len = le16_to_cpu(rp->tx_len);\n\thdev->le_def_tx_time = le16_to_cpu(rp->tx_time);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_write_def_data_len(struct hci_dev *hdev, void *data,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_cp_le_write_def_data_len *sent;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_LE_WRITE_DEF_DATA_LEN);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thdev->le_def_tx_len = le16_to_cpu(sent->tx_len);\n\thdev->le_def_tx_time = le16_to_cpu(sent->tx_time);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_add_to_resolv_list(struct hci_dev *hdev, void *data,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_cp_le_add_to_resolv_list *sent;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_LE_ADD_TO_RESOLV_LIST);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\thci_bdaddr_list_add_with_irk(&hdev->le_resolv_list, &sent->bdaddr,\n\t\t\t\tsent->bdaddr_type, sent->peer_irk,\n\t\t\t\tsent->local_irk);\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_del_from_resolv_list(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_cp_le_del_from_resolv_list *sent;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_LE_DEL_FROM_RESOLV_LIST);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\thci_bdaddr_list_del_with_irk(&hdev->le_resolv_list, &sent->bdaddr,\n\t\t\t    sent->bdaddr_type);\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_clear_resolv_list(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\thci_bdaddr_list_clear(&hdev->le_resolv_list);\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_read_resolv_list_size(struct hci_dev *hdev, void *data,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_resolv_list_size *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x size %u\", rp->status, rp->size);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->le_resolv_list_size = rp->size;\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_addr_resolution_enable(struct hci_dev *hdev, void *data,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\t__u8 *sent;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_ADDR_RESOLV_ENABLE);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tif (*sent)\n\t\thci_dev_set_flag(hdev, HCI_LL_RPA_RESOLUTION);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_LL_RPA_RESOLUTION);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_read_max_data_len(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_max_data_len *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->le_max_tx_len = le16_to_cpu(rp->tx_len);\n\thdev->le_max_tx_time = le16_to_cpu(rp->tx_time);\n\thdev->le_max_rx_len = le16_to_cpu(rp->rx_len);\n\thdev->le_max_rx_time = le16_to_cpu(rp->rx_time);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_le_host_supported(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_cp_write_le_host_supported *sent;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tif (sent->le) {\n\t\thdev->features[1][0] |= LMP_HOST_LE;\n\t\thci_dev_set_flag(hdev, HCI_LE_ENABLED);\n\t} else {\n\t\thdev->features[1][0] &= ~LMP_HOST_LE;\n\t\thci_dev_clear_flag(hdev, HCI_LE_ENABLED);\n\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING);\n\t}\n\n\tif (sent->simul)\n\t\thdev->features[1][0] |= LMP_HOST_LE_BREDR;\n\telse\n\t\thdev->features[1][0] &= ~LMP_HOST_LE_BREDR;\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_set_adv_param(struct hci_dev *hdev, void *data,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_cp_le_set_adv_param *cp;\n\tstruct hci_ev_status *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_ADV_PARAM);\n\tif (!cp)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\thdev->adv_addr_type = cp->own_address_type;\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_set_ext_adv_param(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_rp_le_set_ext_adv_params *rp = data;\n\tstruct hci_cp_le_set_ext_adv_params *cp;\n\tstruct adv_info *adv_instance;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_EXT_ADV_PARAMS);\n\tif (!cp)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\thdev->adv_addr_type = cp->own_addr_type;\n\tif (!cp->handle) {\n\t\t \n\t\thdev->adv_tx_power = rp->tx_power;\n\t} else {\n\t\tadv_instance = hci_find_adv_instance(hdev, cp->handle);\n\t\tif (adv_instance)\n\t\t\tadv_instance->tx_power = rp->tx_power;\n\t}\n\t \n\thci_update_adv_data(hdev, cp->handle);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_rssi(struct hci_dev *hdev, void *data,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_rp_read_rssi *rp = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\n\tif (conn)\n\t\tconn->rssi = rp->rssi;\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_read_tx_power(struct hci_dev *hdev, void *data,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_cp_read_tx_power *sent;\n\tstruct hci_rp_read_tx_power *rp = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_READ_TX_POWER);\n\tif (!sent)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tswitch (sent->type) {\n\tcase 0x00:\n\t\tconn->tx_power = rp->tx_power;\n\t\tbreak;\n\tcase 0x01:\n\t\tconn->max_tx_power = rp->tx_power;\n\t\tbreak;\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_write_ssp_debug_mode(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tu8 *mode;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tmode = hci_sent_cmd_data(hdev, HCI_OP_WRITE_SSP_DEBUG_MODE);\n\tif (mode)\n\t\thdev->ssp_debug_mode = *mode;\n\n\treturn rp->status;\n}\n\nstatic void hci_cs_inquiry(struct hci_dev *hdev, __u8 status)\n{\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (status) {\n\t\thci_conn_check_pending(hdev);\n\t\treturn;\n\t}\n\n\tif (hci_sent_cmd_data(hdev, HCI_OP_INQUIRY))\n\t\tset_bit(HCI_INQUIRY, &hdev->flags);\n}\n\nstatic void hci_cs_create_conn(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_create_conn *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_CREATE_CONN);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);\n\n\tbt_dev_dbg(hdev, \"bdaddr %pMR hcon %p\", &cp->bdaddr, conn);\n\n\tif (status) {\n\t\tif (conn && conn->state == BT_CONNECT) {\n\t\t\tif (status != 0x0c || conn->attempt > 2) {\n\t\t\t\tconn->state = BT_CLOSED;\n\t\t\t\thci_connect_cfm(conn, status);\n\t\t\t\thci_conn_del(conn);\n\t\t\t} else\n\t\t\t\tconn->state = BT_CONNECT2;\n\t\t}\n\t} else {\n\t\tif (!conn) {\n\t\t\tconn = hci_conn_add_unset(hdev, ACL_LINK, &cp->bdaddr,\n\t\t\t\t\t\t  HCI_ROLE_MASTER);\n\t\t\tif (!conn)\n\t\t\t\tbt_dev_err(hdev, \"no memory for new connection\");\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_add_sco(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_add_sco *cp;\n\tstruct hci_conn *acl;\n\tstruct hci_link *link;\n\t__u16 handle;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_ADD_SCO);\n\tif (!cp)\n\t\treturn;\n\n\thandle = __le16_to_cpu(cp->handle);\n\n\tbt_dev_dbg(hdev, \"handle 0x%4.4x\", handle);\n\n\thci_dev_lock(hdev);\n\n\tacl = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (acl) {\n\t\tlink = list_first_entry_or_null(&acl->link_list,\n\t\t\t\t\t\tstruct hci_link, list);\n\t\tif (link && link->conn) {\n\t\t\tlink->conn->state = BT_CLOSED;\n\n\t\t\thci_connect_cfm(link->conn, status);\n\t\t\thci_conn_del(link->conn);\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_auth_requested(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_auth_requested *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_AUTH_REQUESTED);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\n\tif (conn) {\n\t\tif (conn->state == BT_CONFIG) {\n\t\t\thci_connect_cfm(conn, status);\n\t\t\thci_conn_drop(conn);\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_set_conn_encrypt(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_set_conn_encrypt *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_SET_CONN_ENCRYPT);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\n\tif (conn) {\n\t\tif (conn->state == BT_CONFIG) {\n\t\t\thci_connect_cfm(conn, status);\n\t\t\thci_conn_drop(conn);\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic int hci_outgoing_auth_needed(struct hci_dev *hdev,\n\t\t\t\t    struct hci_conn *conn)\n{\n\tif (conn->state != BT_CONFIG || !conn->out)\n\t\treturn 0;\n\n\tif (conn->pending_sec_level == BT_SECURITY_SDP)\n\t\treturn 0;\n\n\t \n\tif (!hci_conn_ssp_enabled(conn) && !(conn->auth_type & 0x01) &&\n\t    conn->pending_sec_level != BT_SECURITY_FIPS &&\n\t    conn->pending_sec_level != BT_SECURITY_HIGH &&\n\t    conn->pending_sec_level != BT_SECURITY_MEDIUM)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int hci_resolve_name(struct hci_dev *hdev,\n\t\t\t\t   struct inquiry_entry *e)\n{\n\tstruct hci_cp_remote_name_req cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tbacpy(&cp.bdaddr, &e->data.bdaddr);\n\tcp.pscan_rep_mode = e->data.pscan_rep_mode;\n\tcp.pscan_mode = e->data.pscan_mode;\n\tcp.clock_offset = e->data.clock_offset;\n\n\treturn hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);\n}\n\nstatic bool hci_resolve_next_name(struct hci_dev *hdev)\n{\n\tstruct discovery_state *discov = &hdev->discovery;\n\tstruct inquiry_entry *e;\n\n\tif (list_empty(&discov->resolve))\n\t\treturn false;\n\n\t \n\tif (time_after(jiffies, discov->name_resolve_timeout)) {\n\t\tbt_dev_warn_ratelimited(hdev, \"Name resolve takes too long.\");\n\t\treturn false;\n\t}\n\n\te = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY, NAME_NEEDED);\n\tif (!e)\n\t\treturn false;\n\n\tif (hci_resolve_name(hdev, e) == 0) {\n\t\te->name_state = NAME_PENDING;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void hci_check_pending_name(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t\t   bdaddr_t *bdaddr, u8 *name, u8 name_len)\n{\n\tstruct discovery_state *discov = &hdev->discovery;\n\tstruct inquiry_entry *e;\n\n\t \n\tif (conn &&\n\t    (conn->state == BT_CONFIG || conn->state == BT_CONNECTED) &&\n\t    !test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))\n\t\tmgmt_device_connected(hdev, conn, name, name_len);\n\n\tif (discov->state == DISCOVERY_STOPPED)\n\t\treturn;\n\n\tif (discov->state == DISCOVERY_STOPPING)\n\t\tgoto discov_complete;\n\n\tif (discov->state != DISCOVERY_RESOLVING)\n\t\treturn;\n\n\te = hci_inquiry_cache_lookup_resolve(hdev, bdaddr, NAME_PENDING);\n\t \n\tif (!e)\n\t\treturn;\n\n\tlist_del(&e->list);\n\n\te->name_state = name ? NAME_KNOWN : NAME_NOT_KNOWN;\n\tmgmt_remote_name(hdev, bdaddr, ACL_LINK, 0x00, e->data.rssi,\n\t\t\t name, name_len);\n\n\tif (hci_resolve_next_name(hdev))\n\t\treturn;\n\ndiscov_complete:\n\thci_discovery_set_state(hdev, DISCOVERY_STOPPED);\n}\n\nstatic void hci_cs_remote_name_req(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_remote_name_req *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\t \n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_REMOTE_NAME_REQ);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\thci_check_pending_name(hdev, conn, &cp->bdaddr, NULL, 0);\n\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (!hci_outgoing_auth_needed(hdev, conn))\n\t\tgoto unlock;\n\n\tif (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {\n\t\tstruct hci_cp_auth_requested auth_cp;\n\n\t\tset_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags);\n\n\t\tauth_cp.handle = __cpu_to_le16(conn->handle);\n\t\thci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED,\n\t\t\t     sizeof(auth_cp), &auth_cp);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_read_remote_features(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_read_remote_features *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_READ_REMOTE_FEATURES);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\n\tif (conn) {\n\t\tif (conn->state == BT_CONFIG) {\n\t\t\thci_connect_cfm(conn, status);\n\t\t\thci_conn_drop(conn);\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_read_remote_ext_features(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_read_remote_ext_features *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_READ_REMOTE_EXT_FEATURES);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\n\tif (conn) {\n\t\tif (conn->state == BT_CONFIG) {\n\t\t\thci_connect_cfm(conn, status);\n\t\t\thci_conn_drop(conn);\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_setup_sync_conn_status(struct hci_dev *hdev, __u16 handle,\n\t\t\t\t       __u8 status)\n{\n\tstruct hci_conn *acl;\n\tstruct hci_link *link;\n\n\tbt_dev_dbg(hdev, \"handle 0x%4.4x status 0x%2.2x\", handle, status);\n\n\thci_dev_lock(hdev);\n\n\tacl = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (acl) {\n\t\tlink = list_first_entry_or_null(&acl->link_list,\n\t\t\t\t\t\tstruct hci_link, list);\n\t\tif (link && link->conn) {\n\t\t\tlink->conn->state = BT_CLOSED;\n\n\t\t\thci_connect_cfm(link->conn, status);\n\t\t\thci_conn_del(link->conn);\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_setup_sync_conn(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_setup_sync_conn *cp;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_SETUP_SYNC_CONN);\n\tif (!cp)\n\t\treturn;\n\n\thci_setup_sync_conn_status(hdev, __le16_to_cpu(cp->handle), status);\n}\n\nstatic void hci_cs_enhanced_setup_sync_conn(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_enhanced_setup_sync_conn *cp;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_ENHANCED_SETUP_SYNC_CONN);\n\tif (!cp)\n\t\treturn;\n\n\thci_setup_sync_conn_status(hdev, __le16_to_cpu(cp->handle), status);\n}\n\nstatic void hci_cs_sniff_mode(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_sniff_mode *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_SNIFF_MODE);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\n\tif (conn) {\n\t\tclear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags);\n\n\t\tif (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))\n\t\t\thci_sco_setup(conn, status);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_exit_sniff_mode(struct hci_dev *hdev, __u8 status)\n{\n\tstruct hci_cp_exit_sniff_mode *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_EXIT_SNIFF_MODE);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\n\tif (conn) {\n\t\tclear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags);\n\n\t\tif (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))\n\t\t\thci_sco_setup(conn, status);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_disconnect(struct hci_dev *hdev, u8 status)\n{\n\tstruct hci_cp_disconnect *cp;\n\tstruct hci_conn_params *params;\n\tstruct hci_conn *conn;\n\tbool mgmt_conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\t \n\tif (!status && !hdev->suspended)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_DISCONNECT);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (status) {\n\t\tmgmt_disconnect_failed(hdev, &conn->dst, conn->type,\n\t\t\t\t       conn->dst_type, status);\n\n\t\tif (conn->type == LE_LINK && conn->role == HCI_ROLE_SLAVE) {\n\t\t\thdev->cur_adv_instance = conn->adv_instance;\n\t\t\thci_enable_advertising(hdev);\n\t\t}\n\n\t\t \n\t\thci_disconn_cfm(conn, HCI_ERROR_UNSPECIFIED);\n\n\t\tgoto done;\n\t}\n\n\tmgmt_conn = test_and_clear_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags);\n\n\tif (conn->type == ACL_LINK) {\n\t\tif (test_and_clear_bit(HCI_CONN_FLUSH_KEY, &conn->flags))\n\t\t\thci_remove_link_key(hdev, &conn->dst);\n\t}\n\n\tparams = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);\n\tif (params) {\n\t\tswitch (params->auto_connect) {\n\t\tcase HCI_AUTO_CONN_LINK_LOSS:\n\t\t\tif (cp->reason != HCI_ERROR_CONNECTION_TIMEOUT)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\n\t\tcase HCI_AUTO_CONN_DIRECT:\n\t\tcase HCI_AUTO_CONN_ALWAYS:\n\t\t\thci_pend_le_list_del_init(params);\n\t\t\thci_pend_le_list_add(params, &hdev->pend_le_conns);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmgmt_device_disconnected(hdev, &conn->dst, conn->type, conn->dst_type,\n\t\t\t\t cp->reason, mgmt_conn);\n\n\thci_disconn_cfm(conn, cp->reason);\n\ndone:\n\t \n\thci_conn_del(conn);\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic u8 ev_bdaddr_type(struct hci_dev *hdev, u8 type, bool *resolved)\n{\n\t \n\tswitch (type) {\n\tcase ADDR_LE_DEV_PUBLIC_RESOLVED:\n\t\tif (resolved)\n\t\t\t*resolved = true;\n\t\treturn ADDR_LE_DEV_PUBLIC;\n\tcase ADDR_LE_DEV_RANDOM_RESOLVED:\n\t\tif (resolved)\n\t\t\t*resolved = true;\n\t\treturn ADDR_LE_DEV_RANDOM;\n\t}\n\n\tif (resolved)\n\t\t*resolved = false;\n\treturn type;\n}\n\nstatic void cs_le_create_conn(struct hci_dev *hdev, bdaddr_t *peer_addr,\n\t\t\t      u8 peer_addr_type, u8 own_address_type,\n\t\t\t      u8 filter_policy)\n{\n\tstruct hci_conn *conn;\n\n\tconn = hci_conn_hash_lookup_le(hdev, peer_addr,\n\t\t\t\t       peer_addr_type);\n\tif (!conn)\n\t\treturn;\n\n\town_address_type = ev_bdaddr_type(hdev, own_address_type, NULL);\n\n\t \n\tconn->init_addr_type = own_address_type;\n\tif (own_address_type == ADDR_LE_DEV_RANDOM)\n\t\tbacpy(&conn->init_addr, &hdev->random_addr);\n\telse\n\t\tbacpy(&conn->init_addr, &hdev->bdaddr);\n\n\tconn->resp_addr_type = peer_addr_type;\n\tbacpy(&conn->resp_addr, peer_addr);\n}\n\nstatic void hci_cs_le_create_conn(struct hci_dev *hdev, u8 status)\n{\n\tstruct hci_cp_le_create_conn *cp;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\t \n\tif (status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_CREATE_CONN);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tcs_le_create_conn(hdev, &cp->peer_addr, cp->peer_addr_type,\n\t\t\t  cp->own_address_type, cp->filter_policy);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_le_ext_create_conn(struct hci_dev *hdev, u8 status)\n{\n\tstruct hci_cp_le_ext_create_conn *cp;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\t \n\tif (status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_EXT_CREATE_CONN);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tcs_le_create_conn(hdev, &cp->peer_addr, cp->peer_addr_type,\n\t\t\t  cp->own_addr_type, cp->filter_policy);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_le_read_remote_features(struct hci_dev *hdev, u8 status)\n{\n\tstruct hci_cp_le_read_remote_features *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_READ_REMOTE_FEATURES);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\n\tif (conn) {\n\t\tif (conn->state == BT_CONFIG) {\n\t\t\thci_connect_cfm(conn, status);\n\t\t\thci_conn_drop(conn);\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_le_start_enc(struct hci_dev *hdev, u8 status)\n{\n\tstruct hci_cp_le_start_enc *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_START_ENC);\n\tif (!cp)\n\t\tgoto unlock;\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (conn->state != BT_CONNECTED)\n\t\tgoto unlock;\n\n\thci_disconnect(conn, HCI_ERROR_AUTH_FAILURE);\n\thci_conn_drop(conn);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_cs_switch_role(struct hci_dev *hdev, u8 status)\n{\n\tstruct hci_cp_switch_role *cp;\n\tstruct hci_conn *conn;\n\n\tBT_DBG(\"%s status 0x%2.2x\", hdev->name, status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_SWITCH_ROLE);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);\n\tif (conn)\n\t\tclear_bit(HCI_CONN_RSWITCH_PEND, &conn->flags);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_inquiry_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_status *ev = data;\n\tstruct discovery_state *discov = &hdev->discovery;\n\tstruct inquiry_entry *e;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_conn_check_pending(hdev);\n\n\tif (!test_and_clear_bit(HCI_INQUIRY, &hdev->flags))\n\t\treturn;\n\n\tsmp_mb__after_atomic();  \n\twake_up_bit(&hdev->flags, HCI_INQUIRY);\n\n\tif (!hci_dev_test_flag(hdev, HCI_MGMT))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tif (discov->state != DISCOVERY_FINDING)\n\t\tgoto unlock;\n\n\tif (list_empty(&discov->resolve)) {\n\t\t \n\t\tif (!hci_dev_test_flag(hdev, HCI_LE_SCAN) ||\n\t\t    !test_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks))\n\t\t\thci_discovery_set_state(hdev, DISCOVERY_STOPPED);\n\t\tgoto unlock;\n\t}\n\n\te = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY, NAME_NEEDED);\n\tif (e && hci_resolve_name(hdev, e) == 0) {\n\t\te->name_state = NAME_PENDING;\n\t\thci_discovery_set_state(hdev, DISCOVERY_RESOLVING);\n\t\tdiscov->name_resolve_timeout = jiffies + NAME_RESOLVE_DURATION;\n\t} else {\n\t\t \n\t\tif (!hci_dev_test_flag(hdev, HCI_LE_SCAN) ||\n\t\t    !test_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks))\n\t\t\thci_discovery_set_state(hdev, DISCOVERY_STOPPED);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_inquiry_result_evt(struct hci_dev *hdev, void *edata,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_inquiry_result *ev = edata;\n\tstruct inquiry_data data;\n\tint i;\n\n\tif (!hci_ev_skb_pull(hdev, skb, HCI_EV_INQUIRY_RESULT,\n\t\t\t     flex_array_size(ev, info, ev->num)))\n\t\treturn;\n\n\tbt_dev_dbg(hdev, \"num %d\", ev->num);\n\n\tif (!ev->num)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (i = 0; i < ev->num; i++) {\n\t\tstruct inquiry_info *info = &ev->info[i];\n\t\tu32 flags;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= info->pscan_mode;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= HCI_RSSI_INVALID;\n\t\tdata.ssp_mode\t\t= 0x00;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, false);\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, HCI_RSSI_INVALID,\n\t\t\t\t  flags, NULL, 0, NULL, 0, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_conn_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_conn_complete *ev = data;\n\tstruct hci_conn *conn;\n\tu8 status = ev->status;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ev->link_type, &ev->bdaddr);\n\tif (!conn) {\n\t\t \n\t\tif (ev->status)\n\t\t\tgoto unlock;\n\n\t\t \n\t\tif (ev->link_type == ACL_LINK &&\n\t\t    hci_bdaddr_list_lookup_with_flags(&hdev->accept_list,\n\t\t\t\t\t\t      &ev->bdaddr,\n\t\t\t\t\t\t      BDADDR_BREDR)) {\n\t\t\tconn = hci_conn_add_unset(hdev, ev->link_type,\n\t\t\t\t\t\t  &ev->bdaddr, HCI_ROLE_SLAVE);\n\t\t\tif (!conn) {\n\t\t\t\tbt_dev_err(hdev, \"no memory for new conn\");\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ev->link_type != SCO_LINK)\n\t\t\t\tgoto unlock;\n\n\t\t\tconn = hci_conn_hash_lookup_ba(hdev, ESCO_LINK,\n\t\t\t\t\t\t       &ev->bdaddr);\n\t\t\tif (!conn)\n\t\t\t\tgoto unlock;\n\n\t\t\tconn->type = SCO_LINK;\n\t\t}\n\t}\n\n\t \n\tif (!HCI_CONN_HANDLE_UNSET(conn->handle)) {\n\t\tbt_dev_err(hdev, \"Ignoring HCI_Connection_Complete for existing connection\");\n\t\tgoto unlock;\n\t}\n\n\tif (!status) {\n\t\tstatus = hci_conn_set_handle(conn, __le16_to_cpu(ev->handle));\n\t\tif (status)\n\t\t\tgoto done;\n\n\t\tif (conn->type == ACL_LINK) {\n\t\t\tconn->state = BT_CONFIG;\n\t\t\thci_conn_hold(conn);\n\n\t\t\tif (!conn->out && !hci_conn_ssp_enabled(conn) &&\n\t\t\t    !hci_find_link_key(hdev, &ev->bdaddr))\n\t\t\t\tconn->disc_timeout = HCI_PAIRING_TIMEOUT;\n\t\t\telse\n\t\t\t\tconn->disc_timeout = HCI_DISCONN_TIMEOUT;\n\t\t} else\n\t\t\tconn->state = BT_CONNECTED;\n\n\t\thci_debugfs_create_conn(conn);\n\t\thci_conn_add_sysfs(conn);\n\n\t\tif (test_bit(HCI_AUTH, &hdev->flags))\n\t\t\tset_bit(HCI_CONN_AUTH, &conn->flags);\n\n\t\tif (test_bit(HCI_ENCRYPT, &hdev->flags))\n\t\t\tset_bit(HCI_CONN_ENCRYPT, &conn->flags);\n\n\t\t \n\t\tif (conn->type == ACL_LINK) {\n\t\t\tstruct hci_cp_read_remote_features cp;\n\t\t\tcp.handle = ev->handle;\n\t\t\thci_send_cmd(hdev, HCI_OP_READ_REMOTE_FEATURES,\n\t\t\t\t     sizeof(cp), &cp);\n\n\t\t\thci_update_scan(hdev);\n\t\t}\n\n\t\t \n\t\tif (!conn->out && hdev->hci_ver < BLUETOOTH_VER_2_0) {\n\t\t\tstruct hci_cp_change_conn_ptype cp;\n\t\t\tcp.handle = ev->handle;\n\t\t\tcp.pkt_type = cpu_to_le16(conn->pkt_type);\n\t\t\thci_send_cmd(hdev, HCI_OP_CHANGE_CONN_PTYPE, sizeof(cp),\n\t\t\t\t     &cp);\n\t\t}\n\t}\n\n\tif (conn->type == ACL_LINK)\n\t\thci_sco_setup(conn, ev->status);\n\ndone:\n\tif (status) {\n\t\thci_conn_failed(conn, status);\n\t} else if (ev->link_type == SCO_LINK) {\n\t\tswitch (conn->setting & SCO_AIRMODE_MASK) {\n\t\tcase SCO_AIRMODE_CVSD:\n\t\t\tif (hdev->notify)\n\t\t\t\thdev->notify(hdev, HCI_NOTIFY_ENABLE_SCO_CVSD);\n\t\t\tbreak;\n\t\t}\n\n\t\thci_connect_cfm(conn, status);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\thci_conn_check_pending(hdev);\n}\n\nstatic void hci_reject_conn(struct hci_dev *hdev, bdaddr_t *bdaddr)\n{\n\tstruct hci_cp_reject_conn_req cp;\n\n\tbacpy(&cp.bdaddr, bdaddr);\n\tcp.reason = HCI_ERROR_REJ_BAD_ADDR;\n\thci_send_cmd(hdev, HCI_OP_REJECT_CONN_REQ, sizeof(cp), &cp);\n}\n\nstatic void hci_conn_request_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_ev_conn_request *ev = data;\n\tint mask = hdev->link_mode;\n\tstruct inquiry_entry *ie;\n\tstruct hci_conn *conn;\n\t__u8 flags = 0;\n\n\tbt_dev_dbg(hdev, \"bdaddr %pMR type 0x%x\", &ev->bdaddr, ev->link_type);\n\n\t \n\tif (hdev && !bacmp(&hdev->bdaddr, &ev->bdaddr)) {\n\t\tbt_dev_dbg(hdev, \"Reject connection with same BD_ADDR %pMR\\n\",\n\t\t\t   &ev->bdaddr);\n\t\thci_reject_conn(hdev, &ev->bdaddr);\n\t\treturn;\n\t}\n\n\tmask |= hci_proto_connect_ind(hdev, &ev->bdaddr, ev->link_type,\n\t\t\t\t      &flags);\n\n\tif (!(mask & HCI_LM_ACCEPT)) {\n\t\thci_reject_conn(hdev, &ev->bdaddr);\n\t\treturn;\n\t}\n\n\thci_dev_lock(hdev);\n\n\tif (hci_bdaddr_list_lookup(&hdev->reject_list, &ev->bdaddr,\n\t\t\t\t   BDADDR_BREDR)) {\n\t\thci_reject_conn(hdev, &ev->bdaddr);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_MGMT) &&\n\t    !hci_dev_test_flag(hdev, HCI_CONNECTABLE) &&\n\t    !hci_bdaddr_list_lookup_with_flags(&hdev->accept_list, &ev->bdaddr,\n\t\t\t\t\t       BDADDR_BREDR)) {\n\t\thci_reject_conn(hdev, &ev->bdaddr);\n\t\tgoto unlock;\n\t}\n\n\t \n\n\tie = hci_inquiry_cache_lookup(hdev, &ev->bdaddr);\n\tif (ie)\n\t\tmemcpy(ie->data.dev_class, ev->dev_class, 3);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ev->link_type,\n\t\t\t&ev->bdaddr);\n\tif (!conn) {\n\t\tconn = hci_conn_add_unset(hdev, ev->link_type, &ev->bdaddr,\n\t\t\t\t\t  HCI_ROLE_SLAVE);\n\t\tif (!conn) {\n\t\t\tbt_dev_err(hdev, \"no memory for new connection\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tmemcpy(conn->dev_class, ev->dev_class, 3);\n\n\thci_dev_unlock(hdev);\n\n\tif (ev->link_type == ACL_LINK ||\n\t    (!(flags & HCI_PROTO_DEFER) && !lmp_esco_capable(hdev))) {\n\t\tstruct hci_cp_accept_conn_req cp;\n\t\tconn->state = BT_CONNECT;\n\n\t\tbacpy(&cp.bdaddr, &ev->bdaddr);\n\n\t\tif (lmp_rswitch_capable(hdev) && (mask & HCI_LM_MASTER))\n\t\t\tcp.role = 0x00;  \n\t\telse\n\t\t\tcp.role = 0x01;  \n\n\t\thci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ, sizeof(cp), &cp);\n\t} else if (!(flags & HCI_PROTO_DEFER)) {\n\t\tstruct hci_cp_accept_sync_conn_req cp;\n\t\tconn->state = BT_CONNECT;\n\n\t\tbacpy(&cp.bdaddr, &ev->bdaddr);\n\t\tcp.pkt_type = cpu_to_le16(conn->pkt_type);\n\n\t\tcp.tx_bandwidth   = cpu_to_le32(0x00001f40);\n\t\tcp.rx_bandwidth   = cpu_to_le32(0x00001f40);\n\t\tcp.max_latency    = cpu_to_le16(0xffff);\n\t\tcp.content_format = cpu_to_le16(hdev->voice_setting);\n\t\tcp.retrans_effort = 0xff;\n\n\t\thci_send_cmd(hdev, HCI_OP_ACCEPT_SYNC_CONN_REQ, sizeof(cp),\n\t\t\t     &cp);\n\t} else {\n\t\tconn->state = BT_CONNECT2;\n\t\thci_connect_cfm(conn, 0);\n\t}\n\n\treturn;\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic u8 hci_to_mgmt_reason(u8 err)\n{\n\tswitch (err) {\n\tcase HCI_ERROR_CONNECTION_TIMEOUT:\n\t\treturn MGMT_DEV_DISCONN_TIMEOUT;\n\tcase HCI_ERROR_REMOTE_USER_TERM:\n\tcase HCI_ERROR_REMOTE_LOW_RESOURCES:\n\tcase HCI_ERROR_REMOTE_POWER_OFF:\n\t\treturn MGMT_DEV_DISCONN_REMOTE;\n\tcase HCI_ERROR_LOCAL_HOST_TERM:\n\t\treturn MGMT_DEV_DISCONN_LOCAL_HOST;\n\tdefault:\n\t\treturn MGMT_DEV_DISCONN_UNKNOWN;\n\t}\n}\n\nstatic void hci_disconn_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_disconn_complete *ev = data;\n\tu8 reason;\n\tstruct hci_conn_params *params;\n\tstruct hci_conn *conn;\n\tbool mgmt_connected;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (ev->status) {\n\t\tmgmt_disconnect_failed(hdev, &conn->dst, conn->type,\n\t\t\t\t       conn->dst_type, ev->status);\n\t\tgoto unlock;\n\t}\n\n\tconn->state = BT_CLOSED;\n\n\tmgmt_connected = test_and_clear_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags);\n\n\tif (test_bit(HCI_CONN_AUTH_FAILURE, &conn->flags))\n\t\treason = MGMT_DEV_DISCONN_AUTH_FAILURE;\n\telse\n\t\treason = hci_to_mgmt_reason(ev->reason);\n\n\tmgmt_device_disconnected(hdev, &conn->dst, conn->type, conn->dst_type,\n\t\t\t\treason, mgmt_connected);\n\n\tif (conn->type == ACL_LINK) {\n\t\tif (test_and_clear_bit(HCI_CONN_FLUSH_KEY, &conn->flags))\n\t\t\thci_remove_link_key(hdev, &conn->dst);\n\n\t\thci_update_scan(hdev);\n\t}\n\n\tparams = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);\n\tif (params) {\n\t\tswitch (params->auto_connect) {\n\t\tcase HCI_AUTO_CONN_LINK_LOSS:\n\t\t\tif (ev->reason != HCI_ERROR_CONNECTION_TIMEOUT)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\n\t\tcase HCI_AUTO_CONN_DIRECT:\n\t\tcase HCI_AUTO_CONN_ALWAYS:\n\t\t\thci_pend_le_list_del_init(params);\n\t\t\thci_pend_le_list_add(params, &hdev->pend_le_conns);\n\t\t\thci_update_passive_scan(hdev);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thci_disconn_cfm(conn, ev->reason);\n\n\t \n\tif (conn->type == LE_LINK && conn->role == HCI_ROLE_SLAVE) {\n\t\thdev->cur_adv_instance = conn->adv_instance;\n\t\thci_enable_advertising(hdev);\n\t}\n\n\thci_conn_del(conn);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_auth_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_auth_complete *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (!ev->status) {\n\t\tclear_bit(HCI_CONN_AUTH_FAILURE, &conn->flags);\n\t\tset_bit(HCI_CONN_AUTH, &conn->flags);\n\t\tconn->sec_level = conn->pending_sec_level;\n\t} else {\n\t\tif (ev->status == HCI_ERROR_PIN_OR_KEY_MISSING)\n\t\t\tset_bit(HCI_CONN_AUTH_FAILURE, &conn->flags);\n\n\t\tmgmt_auth_failed(conn, ev->status);\n\t}\n\n\tclear_bit(HCI_CONN_AUTH_PEND, &conn->flags);\n\n\tif (conn->state == BT_CONFIG) {\n\t\tif (!ev->status && hci_conn_ssp_enabled(conn)) {\n\t\t\tstruct hci_cp_set_conn_encrypt cp;\n\t\t\tcp.handle  = ev->handle;\n\t\t\tcp.encrypt = 0x01;\n\t\t\thci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),\n\t\t\t\t     &cp);\n\t\t} else {\n\t\t\tconn->state = BT_CONNECTED;\n\t\t\thci_connect_cfm(conn, ev->status);\n\t\t\thci_conn_drop(conn);\n\t\t}\n\t} else {\n\t\thci_auth_cfm(conn, ev->status);\n\n\t\thci_conn_hold(conn);\n\t\tconn->disc_timeout = HCI_DISCONN_TIMEOUT;\n\t\thci_conn_drop(conn);\n\t}\n\n\tif (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {\n\t\tif (!ev->status) {\n\t\t\tstruct hci_cp_set_conn_encrypt cp;\n\t\t\tcp.handle  = ev->handle;\n\t\t\tcp.encrypt = 0x01;\n\t\t\thci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),\n\t\t\t\t     &cp);\n\t\t} else {\n\t\t\tclear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);\n\t\t\thci_encrypt_cfm(conn, ev->status);\n\t\t}\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_remote_name_evt(struct hci_dev *hdev, void *data,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_ev_remote_name *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_conn_check_pending(hdev);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\n\tif (!hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tgoto check_auth;\n\n\tif (ev->status == 0)\n\t\thci_check_pending_name(hdev, conn, &ev->bdaddr, ev->name,\n\t\t\t\t       strnlen(ev->name, HCI_MAX_NAME_LENGTH));\n\telse\n\t\thci_check_pending_name(hdev, conn, &ev->bdaddr, NULL, 0);\n\ncheck_auth:\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (!hci_outgoing_auth_needed(hdev, conn))\n\t\tgoto unlock;\n\n\tif (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {\n\t\tstruct hci_cp_auth_requested cp;\n\n\t\tset_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags);\n\n\t\tcp.handle = __cpu_to_le16(conn->handle);\n\t\thci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_encrypt_change_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_encrypt_change *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (!ev->status) {\n\t\tif (ev->encrypt) {\n\t\t\t \n\t\t\tset_bit(HCI_CONN_AUTH, &conn->flags);\n\t\t\tset_bit(HCI_CONN_ENCRYPT, &conn->flags);\n\t\t\tconn->sec_level = conn->pending_sec_level;\n\n\t\t\t \n\t\t\tif (conn->key_type == HCI_LK_AUTH_COMBINATION_P256)\n\t\t\t\tset_bit(HCI_CONN_FIPS, &conn->flags);\n\n\t\t\tif ((conn->type == ACL_LINK && ev->encrypt == 0x02) ||\n\t\t\t    conn->type == LE_LINK)\n\t\t\t\tset_bit(HCI_CONN_AES_CCM, &conn->flags);\n\t\t} else {\n\t\t\tclear_bit(HCI_CONN_ENCRYPT, &conn->flags);\n\t\t\tclear_bit(HCI_CONN_AES_CCM, &conn->flags);\n\t\t}\n\t}\n\n\t \n\tif (ev->status && conn->type == LE_LINK) {\n\t\thci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\n\t\thci_adv_instances_set_rpa_expired(hdev, true);\n\t}\n\n\tclear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);\n\n\t \n\tif (!hci_conn_check_link_mode(conn))\n\t\tev->status = HCI_ERROR_AUTH_FAILURE;\n\n\tif (ev->status && conn->state == BT_CONNECTED) {\n\t\tif (ev->status == HCI_ERROR_PIN_OR_KEY_MISSING)\n\t\t\tset_bit(HCI_CONN_AUTH_FAILURE, &conn->flags);\n\n\t\t \n\t\thci_encrypt_cfm(conn, ev->status);\n\t\thci_disconnect(conn, HCI_ERROR_AUTH_FAILURE);\n\t\thci_conn_drop(conn);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (!ev->status && ev->encrypt && conn->type == ACL_LINK) {\n\t\tstruct hci_cp_read_enc_key_size cp;\n\n\t\t \n\t\tif (!(hdev->commands[20] & 0x10)) {\n\t\t\tconn->enc_key_size = HCI_LINK_KEY_SIZE;\n\t\t\tgoto notify;\n\t\t}\n\n\t\tcp.handle = cpu_to_le16(conn->handle);\n\t\tif (hci_send_cmd(hdev, HCI_OP_READ_ENC_KEY_SIZE,\n\t\t\t\t sizeof(cp), &cp)) {\n\t\t\tbt_dev_err(hdev, \"sending read key size failed\");\n\t\t\tconn->enc_key_size = HCI_LINK_KEY_SIZE;\n\t\t\tgoto notify;\n\t\t}\n\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (test_bit(HCI_CONN_ENCRYPT, &conn->flags) &&\n\t    test_bit(HCI_CONN_AES_CCM, &conn->flags) &&\n\t    ((conn->type == ACL_LINK && lmp_ping_capable(hdev)) ||\n\t     (conn->type == LE_LINK && (hdev->le_features[0] & HCI_LE_PING)))) {\n\t\tstruct hci_cp_write_auth_payload_to cp;\n\n\t\tcp.handle = cpu_to_le16(conn->handle);\n\t\tcp.timeout = cpu_to_le16(hdev->auth_payload_timeout);\n\t\tif (hci_send_cmd(conn->hdev, HCI_OP_WRITE_AUTH_PAYLOAD_TO,\n\t\t\t\t sizeof(cp), &cp))\n\t\t\tbt_dev_err(hdev, \"write auth payload timeout failed\");\n\t}\n\nnotify:\n\thci_encrypt_cfm(conn, ev->status);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_change_link_key_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_change_link_key_complete *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (conn) {\n\t\tif (!ev->status)\n\t\t\tset_bit(HCI_CONN_SECURE, &conn->flags);\n\n\t\tclear_bit(HCI_CONN_AUTH_PEND, &conn->flags);\n\n\t\thci_key_change_cfm(conn, ev->status);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_remote_features_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_remote_features *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (!ev->status)\n\t\tmemcpy(conn->features[0], ev->features, 8);\n\n\tif (conn->state != BT_CONFIG)\n\t\tgoto unlock;\n\n\tif (!ev->status && lmp_ext_feat_capable(hdev) &&\n\t    lmp_ext_feat_capable(conn)) {\n\t\tstruct hci_cp_read_remote_ext_features cp;\n\t\tcp.handle = ev->handle;\n\t\tcp.page = 0x01;\n\t\thci_send_cmd(hdev, HCI_OP_READ_REMOTE_EXT_FEATURES,\n\t\t\t     sizeof(cp), &cp);\n\t\tgoto unlock;\n\t}\n\n\tif (!ev->status && !test_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags)) {\n\t\tstruct hci_cp_remote_name_req cp;\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tbacpy(&cp.bdaddr, &conn->dst);\n\t\tcp.pscan_rep_mode = 0x02;\n\t\thci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);\n\t} else if (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))\n\t\tmgmt_device_connected(hdev, conn, NULL, 0);\n\n\tif (!hci_outgoing_auth_needed(hdev, conn)) {\n\t\tconn->state = BT_CONNECTED;\n\t\thci_connect_cfm(conn, ev->status);\n\t\thci_conn_drop(conn);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic inline void handle_cmd_cnt_and_timer(struct hci_dev *hdev, u8 ncmd)\n{\n\tcancel_delayed_work(&hdev->cmd_timer);\n\n\trcu_read_lock();\n\tif (!test_bit(HCI_RESET, &hdev->flags)) {\n\t\tif (ncmd) {\n\t\t\tcancel_delayed_work(&hdev->ncmd_timer);\n\t\t\tatomic_set(&hdev->cmd_cnt, 1);\n\t\t} else {\n\t\t\tif (!hci_dev_test_flag(hdev, HCI_CMD_DRAIN_WORKQUEUE))\n\t\t\t\tqueue_delayed_work(hdev->workqueue, &hdev->ncmd_timer,\n\t\t\t\t\t\t   HCI_NCMD_TIMEOUT);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic u8 hci_cc_le_read_buffer_size_v2(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_rp_le_read_buffer_size_v2 *rp = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\thdev->le_mtu   = __le16_to_cpu(rp->acl_mtu);\n\thdev->le_pkts  = rp->acl_max_pkt;\n\thdev->iso_mtu  = __le16_to_cpu(rp->iso_mtu);\n\thdev->iso_pkts = rp->iso_max_pkt;\n\n\thdev->le_cnt  = hdev->le_pkts;\n\thdev->iso_cnt = hdev->iso_pkts;\n\n\tBT_DBG(\"%s acl mtu %d:%d iso mtu %d:%d\", hdev->name, hdev->acl_mtu,\n\t       hdev->acl_pkts, hdev->iso_mtu, hdev->iso_pkts);\n\n\treturn rp->status;\n}\n\nstatic void hci_unbound_cis_failed(struct hci_dev *hdev, u8 cig, u8 status)\n{\n\tstruct hci_conn *conn, *tmp;\n\n\tlockdep_assert_held(&hdev->lock);\n\n\tlist_for_each_entry_safe(conn, tmp, &hdev->conn_hash.list, list) {\n\t\tif (conn->type != ISO_LINK || !bacmp(&conn->dst, BDADDR_ANY) ||\n\t\t    conn->state == BT_OPEN || conn->iso_qos.ucast.cig != cig)\n\t\t\tcontinue;\n\n\t\tif (HCI_CONN_HANDLE_UNSET(conn->handle))\n\t\t\thci_conn_failed(conn, status);\n\t}\n}\n\nstatic u8 hci_cc_le_set_cig_params(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_rp_le_set_cig_params *rp = data;\n\tstruct hci_cp_le_set_cig_params *cp;\n\tstruct hci_conn *conn;\n\tu8 status = rp->status;\n\tbool pending = false;\n\tint i;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_CIG_PARAMS);\n\tif (!rp->status && (!cp || rp->num_handles != cp->num_cis ||\n\t\t\t    rp->cig_id != cp->cig_id)) {\n\t\tbt_dev_err(hdev, \"unexpected Set CIG Parameters response data\");\n\t\tstatus = HCI_ERROR_UNSPECIFIED;\n\t}\n\n\thci_dev_lock(hdev);\n\n\t \n\tif (status) {\n\t\t \n\t\thci_unbound_cis_failed(hdev, rp->cig_id, status);\n\t\tgoto unlock;\n\t}\n\n\t \n\tfor (i = 0; i < rp->num_handles; ++i) {\n\t\tconn = hci_conn_hash_lookup_cis(hdev, NULL, 0, rp->cig_id,\n\t\t\t\t\t\tcp->cis[i].cis_id);\n\t\tif (!conn || !bacmp(&conn->dst, BDADDR_ANY))\n\t\t\tcontinue;\n\n\t\tif (conn->state != BT_BOUND && conn->state != BT_CONNECT)\n\t\t\tcontinue;\n\n\t\tif (hci_conn_set_handle(conn, __le16_to_cpu(rp->handle[i])))\n\t\t\tcontinue;\n\n\t\tif (conn->state == BT_CONNECT)\n\t\t\tpending = true;\n\t}\n\nunlock:\n\tif (pending)\n\t\thci_le_create_cis_pending(hdev);\n\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_setup_iso_path(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_rp_le_setup_iso_path *rp = data;\n\tstruct hci_cp_le_setup_iso_path *cp;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SETUP_ISO_PATH);\n\tif (!cp)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (rp->status) {\n\t\thci_connect_cfm(conn, rp->status);\n\t\thci_conn_del(conn);\n\t\tgoto unlock;\n\t}\n\n\tswitch (cp->direction) {\n\t \n\tcase 0x00:\n\t\t \n\t\tif (conn->iso_qos.ucast.out.sdu && !conn->iso_qos.ucast.in.sdu)\n\t\t\thci_connect_cfm(conn, rp->status);\n\t\tbreak;\n\t \n\tcase 0x01:\n\t\t \n\t\thci_connect_cfm(conn, rp->status);\n\t\tbreak;\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn rp->status;\n}\n\nstatic void hci_cs_le_create_big(struct hci_dev *hdev, u8 status)\n{\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n}\n\nstatic u8 hci_cc_set_per_adv_param(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_le_set_per_adv_params *cp;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_PER_ADV_PARAMS);\n\tif (!cp)\n\t\treturn rp->status;\n\n\t \n\treturn rp->status;\n}\n\nstatic u8 hci_cc_le_set_per_adv_enable(struct hci_dev *hdev, void *data,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_ev_status *rp = data;\n\tstruct hci_cp_le_set_per_adv_enable *cp;\n\tstruct adv_info *adv = NULL, *n;\n\tu8 per_adv_cnt = 0;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", rp->status);\n\n\tif (rp->status)\n\t\treturn rp->status;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_PER_ADV_ENABLE);\n\tif (!cp)\n\t\treturn rp->status;\n\n\thci_dev_lock(hdev);\n\n\tadv = hci_find_adv_instance(hdev, cp->handle);\n\n\tif (cp->enable) {\n\t\thci_dev_set_flag(hdev, HCI_LE_PER_ADV);\n\n\t\tif (adv)\n\t\t\tadv->enabled = true;\n\t} else {\n\t\t \n\t\tlist_for_each_entry_safe(adv, n, &hdev->adv_instances,\n\t\t\t\t\t list) {\n\t\t\tif (adv->periodic && adv->enabled)\n\t\t\t\tper_adv_cnt++;\n\t\t}\n\n\t\tif (per_adv_cnt > 1)\n\t\t\tgoto unlock;\n\n\t\thci_dev_clear_flag(hdev, HCI_LE_PER_ADV);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn rp->status;\n}\n\n#define HCI_CC_VL(_op, _func, _min, _max) \\\n{ \\\n\t.op = _op, \\\n\t.func = _func, \\\n\t.min_len = _min, \\\n\t.max_len = _max, \\\n}\n\n#define HCI_CC(_op, _func, _len) \\\n\tHCI_CC_VL(_op, _func, _len, _len)\n\n#define HCI_CC_STATUS(_op, _func) \\\n\tHCI_CC(_op, _func, sizeof(struct hci_ev_status))\n\nstatic const struct hci_cc {\n\tu16  op;\n\tu8 (*func)(struct hci_dev *hdev, void *data, struct sk_buff *skb);\n\tu16  min_len;\n\tu16  max_len;\n} hci_cc_table[] = {\n\tHCI_CC_STATUS(HCI_OP_INQUIRY_CANCEL, hci_cc_inquiry_cancel),\n\tHCI_CC_STATUS(HCI_OP_PERIODIC_INQ, hci_cc_periodic_inq),\n\tHCI_CC_STATUS(HCI_OP_EXIT_PERIODIC_INQ, hci_cc_exit_periodic_inq),\n\tHCI_CC_STATUS(HCI_OP_REMOTE_NAME_REQ_CANCEL,\n\t\t      hci_cc_remote_name_req_cancel),\n\tHCI_CC(HCI_OP_ROLE_DISCOVERY, hci_cc_role_discovery,\n\t       sizeof(struct hci_rp_role_discovery)),\n\tHCI_CC(HCI_OP_READ_LINK_POLICY, hci_cc_read_link_policy,\n\t       sizeof(struct hci_rp_read_link_policy)),\n\tHCI_CC(HCI_OP_WRITE_LINK_POLICY, hci_cc_write_link_policy,\n\t       sizeof(struct hci_rp_write_link_policy)),\n\tHCI_CC(HCI_OP_READ_DEF_LINK_POLICY, hci_cc_read_def_link_policy,\n\t       sizeof(struct hci_rp_read_def_link_policy)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_DEF_LINK_POLICY,\n\t\t      hci_cc_write_def_link_policy),\n\tHCI_CC_STATUS(HCI_OP_RESET, hci_cc_reset),\n\tHCI_CC(HCI_OP_READ_STORED_LINK_KEY, hci_cc_read_stored_link_key,\n\t       sizeof(struct hci_rp_read_stored_link_key)),\n\tHCI_CC(HCI_OP_DELETE_STORED_LINK_KEY, hci_cc_delete_stored_link_key,\n\t       sizeof(struct hci_rp_delete_stored_link_key)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_LOCAL_NAME, hci_cc_write_local_name),\n\tHCI_CC(HCI_OP_READ_LOCAL_NAME, hci_cc_read_local_name,\n\t       sizeof(struct hci_rp_read_local_name)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_AUTH_ENABLE, hci_cc_write_auth_enable),\n\tHCI_CC_STATUS(HCI_OP_WRITE_ENCRYPT_MODE, hci_cc_write_encrypt_mode),\n\tHCI_CC_STATUS(HCI_OP_WRITE_SCAN_ENABLE, hci_cc_write_scan_enable),\n\tHCI_CC_STATUS(HCI_OP_SET_EVENT_FLT, hci_cc_set_event_filter),\n\tHCI_CC(HCI_OP_READ_CLASS_OF_DEV, hci_cc_read_class_of_dev,\n\t       sizeof(struct hci_rp_read_class_of_dev)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_CLASS_OF_DEV, hci_cc_write_class_of_dev),\n\tHCI_CC(HCI_OP_READ_VOICE_SETTING, hci_cc_read_voice_setting,\n\t       sizeof(struct hci_rp_read_voice_setting)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_VOICE_SETTING, hci_cc_write_voice_setting),\n\tHCI_CC(HCI_OP_READ_NUM_SUPPORTED_IAC, hci_cc_read_num_supported_iac,\n\t       sizeof(struct hci_rp_read_num_supported_iac)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_SSP_MODE, hci_cc_write_ssp_mode),\n\tHCI_CC_STATUS(HCI_OP_WRITE_SC_SUPPORT, hci_cc_write_sc_support),\n\tHCI_CC(HCI_OP_READ_AUTH_PAYLOAD_TO, hci_cc_read_auth_payload_timeout,\n\t       sizeof(struct hci_rp_read_auth_payload_to)),\n\tHCI_CC(HCI_OP_WRITE_AUTH_PAYLOAD_TO, hci_cc_write_auth_payload_timeout,\n\t       sizeof(struct hci_rp_write_auth_payload_to)),\n\tHCI_CC(HCI_OP_READ_LOCAL_VERSION, hci_cc_read_local_version,\n\t       sizeof(struct hci_rp_read_local_version)),\n\tHCI_CC(HCI_OP_READ_LOCAL_COMMANDS, hci_cc_read_local_commands,\n\t       sizeof(struct hci_rp_read_local_commands)),\n\tHCI_CC(HCI_OP_READ_LOCAL_FEATURES, hci_cc_read_local_features,\n\t       sizeof(struct hci_rp_read_local_features)),\n\tHCI_CC(HCI_OP_READ_LOCAL_EXT_FEATURES, hci_cc_read_local_ext_features,\n\t       sizeof(struct hci_rp_read_local_ext_features)),\n\tHCI_CC(HCI_OP_READ_BUFFER_SIZE, hci_cc_read_buffer_size,\n\t       sizeof(struct hci_rp_read_buffer_size)),\n\tHCI_CC(HCI_OP_READ_BD_ADDR, hci_cc_read_bd_addr,\n\t       sizeof(struct hci_rp_read_bd_addr)),\n\tHCI_CC(HCI_OP_READ_LOCAL_PAIRING_OPTS, hci_cc_read_local_pairing_opts,\n\t       sizeof(struct hci_rp_read_local_pairing_opts)),\n\tHCI_CC(HCI_OP_READ_PAGE_SCAN_ACTIVITY, hci_cc_read_page_scan_activity,\n\t       sizeof(struct hci_rp_read_page_scan_activity)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_PAGE_SCAN_ACTIVITY,\n\t\t      hci_cc_write_page_scan_activity),\n\tHCI_CC(HCI_OP_READ_PAGE_SCAN_TYPE, hci_cc_read_page_scan_type,\n\t       sizeof(struct hci_rp_read_page_scan_type)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_PAGE_SCAN_TYPE, hci_cc_write_page_scan_type),\n\tHCI_CC(HCI_OP_READ_DATA_BLOCK_SIZE, hci_cc_read_data_block_size,\n\t       sizeof(struct hci_rp_read_data_block_size)),\n\tHCI_CC(HCI_OP_READ_FLOW_CONTROL_MODE, hci_cc_read_flow_control_mode,\n\t       sizeof(struct hci_rp_read_flow_control_mode)),\n\tHCI_CC(HCI_OP_READ_LOCAL_AMP_INFO, hci_cc_read_local_amp_info,\n\t       sizeof(struct hci_rp_read_local_amp_info)),\n\tHCI_CC(HCI_OP_READ_CLOCK, hci_cc_read_clock,\n\t       sizeof(struct hci_rp_read_clock)),\n\tHCI_CC(HCI_OP_READ_ENC_KEY_SIZE, hci_cc_read_enc_key_size,\n\t       sizeof(struct hci_rp_read_enc_key_size)),\n\tHCI_CC(HCI_OP_READ_INQ_RSP_TX_POWER, hci_cc_read_inq_rsp_tx_power,\n\t       sizeof(struct hci_rp_read_inq_rsp_tx_power)),\n\tHCI_CC(HCI_OP_READ_DEF_ERR_DATA_REPORTING,\n\t       hci_cc_read_def_err_data_reporting,\n\t       sizeof(struct hci_rp_read_def_err_data_reporting)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_DEF_ERR_DATA_REPORTING,\n\t\t      hci_cc_write_def_err_data_reporting),\n\tHCI_CC(HCI_OP_PIN_CODE_REPLY, hci_cc_pin_code_reply,\n\t       sizeof(struct hci_rp_pin_code_reply)),\n\tHCI_CC(HCI_OP_PIN_CODE_NEG_REPLY, hci_cc_pin_code_neg_reply,\n\t       sizeof(struct hci_rp_pin_code_neg_reply)),\n\tHCI_CC(HCI_OP_READ_LOCAL_OOB_DATA, hci_cc_read_local_oob_data,\n\t       sizeof(struct hci_rp_read_local_oob_data)),\n\tHCI_CC(HCI_OP_READ_LOCAL_OOB_EXT_DATA, hci_cc_read_local_oob_ext_data,\n\t       sizeof(struct hci_rp_read_local_oob_ext_data)),\n\tHCI_CC(HCI_OP_LE_READ_BUFFER_SIZE, hci_cc_le_read_buffer_size,\n\t       sizeof(struct hci_rp_le_read_buffer_size)),\n\tHCI_CC(HCI_OP_LE_READ_LOCAL_FEATURES, hci_cc_le_read_local_features,\n\t       sizeof(struct hci_rp_le_read_local_features)),\n\tHCI_CC(HCI_OP_LE_READ_ADV_TX_POWER, hci_cc_le_read_adv_tx_power,\n\t       sizeof(struct hci_rp_le_read_adv_tx_power)),\n\tHCI_CC(HCI_OP_USER_CONFIRM_REPLY, hci_cc_user_confirm_reply,\n\t       sizeof(struct hci_rp_user_confirm_reply)),\n\tHCI_CC(HCI_OP_USER_CONFIRM_NEG_REPLY, hci_cc_user_confirm_neg_reply,\n\t       sizeof(struct hci_rp_user_confirm_reply)),\n\tHCI_CC(HCI_OP_USER_PASSKEY_REPLY, hci_cc_user_passkey_reply,\n\t       sizeof(struct hci_rp_user_confirm_reply)),\n\tHCI_CC(HCI_OP_USER_PASSKEY_NEG_REPLY, hci_cc_user_passkey_neg_reply,\n\t       sizeof(struct hci_rp_user_confirm_reply)),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_RANDOM_ADDR, hci_cc_le_set_random_addr),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_ADV_ENABLE, hci_cc_le_set_adv_enable),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_SCAN_PARAM, hci_cc_le_set_scan_param),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_SCAN_ENABLE, hci_cc_le_set_scan_enable),\n\tHCI_CC(HCI_OP_LE_READ_ACCEPT_LIST_SIZE,\n\t       hci_cc_le_read_accept_list_size,\n\t       sizeof(struct hci_rp_le_read_accept_list_size)),\n\tHCI_CC_STATUS(HCI_OP_LE_CLEAR_ACCEPT_LIST, hci_cc_le_clear_accept_list),\n\tHCI_CC_STATUS(HCI_OP_LE_ADD_TO_ACCEPT_LIST,\n\t\t      hci_cc_le_add_to_accept_list),\n\tHCI_CC_STATUS(HCI_OP_LE_DEL_FROM_ACCEPT_LIST,\n\t\t      hci_cc_le_del_from_accept_list),\n\tHCI_CC(HCI_OP_LE_READ_SUPPORTED_STATES, hci_cc_le_read_supported_states,\n\t       sizeof(struct hci_rp_le_read_supported_states)),\n\tHCI_CC(HCI_OP_LE_READ_DEF_DATA_LEN, hci_cc_le_read_def_data_len,\n\t       sizeof(struct hci_rp_le_read_def_data_len)),\n\tHCI_CC_STATUS(HCI_OP_LE_WRITE_DEF_DATA_LEN,\n\t\t      hci_cc_le_write_def_data_len),\n\tHCI_CC_STATUS(HCI_OP_LE_ADD_TO_RESOLV_LIST,\n\t\t      hci_cc_le_add_to_resolv_list),\n\tHCI_CC_STATUS(HCI_OP_LE_DEL_FROM_RESOLV_LIST,\n\t\t      hci_cc_le_del_from_resolv_list),\n\tHCI_CC_STATUS(HCI_OP_LE_CLEAR_RESOLV_LIST,\n\t\t      hci_cc_le_clear_resolv_list),\n\tHCI_CC(HCI_OP_LE_READ_RESOLV_LIST_SIZE, hci_cc_le_read_resolv_list_size,\n\t       sizeof(struct hci_rp_le_read_resolv_list_size)),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_ADDR_RESOLV_ENABLE,\n\t\t      hci_cc_le_set_addr_resolution_enable),\n\tHCI_CC(HCI_OP_LE_READ_MAX_DATA_LEN, hci_cc_le_read_max_data_len,\n\t       sizeof(struct hci_rp_le_read_max_data_len)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_LE_HOST_SUPPORTED,\n\t\t      hci_cc_write_le_host_supported),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_ADV_PARAM, hci_cc_set_adv_param),\n\tHCI_CC(HCI_OP_READ_RSSI, hci_cc_read_rssi,\n\t       sizeof(struct hci_rp_read_rssi)),\n\tHCI_CC(HCI_OP_READ_TX_POWER, hci_cc_read_tx_power,\n\t       sizeof(struct hci_rp_read_tx_power)),\n\tHCI_CC_STATUS(HCI_OP_WRITE_SSP_DEBUG_MODE, hci_cc_write_ssp_debug_mode),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_EXT_SCAN_PARAMS,\n\t\t      hci_cc_le_set_ext_scan_param),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_EXT_SCAN_ENABLE,\n\t\t      hci_cc_le_set_ext_scan_enable),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_DEFAULT_PHY, hci_cc_le_set_default_phy),\n\tHCI_CC(HCI_OP_LE_READ_NUM_SUPPORTED_ADV_SETS,\n\t       hci_cc_le_read_num_adv_sets,\n\t       sizeof(struct hci_rp_le_read_num_supported_adv_sets)),\n\tHCI_CC(HCI_OP_LE_SET_EXT_ADV_PARAMS, hci_cc_set_ext_adv_param,\n\t       sizeof(struct hci_rp_le_set_ext_adv_params)),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_EXT_ADV_ENABLE,\n\t\t      hci_cc_le_set_ext_adv_enable),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_ADV_SET_RAND_ADDR,\n\t\t      hci_cc_le_set_adv_set_random_addr),\n\tHCI_CC_STATUS(HCI_OP_LE_REMOVE_ADV_SET, hci_cc_le_remove_adv_set),\n\tHCI_CC_STATUS(HCI_OP_LE_CLEAR_ADV_SETS, hci_cc_le_clear_adv_sets),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_PER_ADV_PARAMS, hci_cc_set_per_adv_param),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_PER_ADV_ENABLE,\n\t\t      hci_cc_le_set_per_adv_enable),\n\tHCI_CC(HCI_OP_LE_READ_TRANSMIT_POWER, hci_cc_le_read_transmit_power,\n\t       sizeof(struct hci_rp_le_read_transmit_power)),\n\tHCI_CC_STATUS(HCI_OP_LE_SET_PRIVACY_MODE, hci_cc_le_set_privacy_mode),\n\tHCI_CC(HCI_OP_LE_READ_BUFFER_SIZE_V2, hci_cc_le_read_buffer_size_v2,\n\t       sizeof(struct hci_rp_le_read_buffer_size_v2)),\n\tHCI_CC_VL(HCI_OP_LE_SET_CIG_PARAMS, hci_cc_le_set_cig_params,\n\t\t  sizeof(struct hci_rp_le_set_cig_params), HCI_MAX_EVENT_SIZE),\n\tHCI_CC(HCI_OP_LE_SETUP_ISO_PATH, hci_cc_le_setup_iso_path,\n\t       sizeof(struct hci_rp_le_setup_iso_path)),\n};\n\nstatic u8 hci_cc_func(struct hci_dev *hdev, const struct hci_cc *cc,\n\t\t      struct sk_buff *skb)\n{\n\tvoid *data;\n\n\tif (skb->len < cc->min_len) {\n\t\tbt_dev_err(hdev, \"unexpected cc 0x%4.4x length: %u < %u\",\n\t\t\t   cc->op, skb->len, cc->min_len);\n\t\treturn HCI_ERROR_UNSPECIFIED;\n\t}\n\n\t \n\tif (skb->len > cc->max_len)\n\t\tbt_dev_warn(hdev, \"unexpected cc 0x%4.4x length: %u > %u\",\n\t\t\t    cc->op, skb->len, cc->max_len);\n\n\tdata = hci_cc_skb_pull(hdev, skb, cc->op, cc->min_len);\n\tif (!data)\n\t\treturn HCI_ERROR_UNSPECIFIED;\n\n\treturn cc->func(hdev, data, skb);\n}\n\nstatic void hci_cmd_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t struct sk_buff *skb, u16 *opcode, u8 *status,\n\t\t\t\t hci_req_complete_t *req_complete,\n\t\t\t\t hci_req_complete_skb_t *req_complete_skb)\n{\n\tstruct hci_ev_cmd_complete *ev = data;\n\tint i;\n\n\t*opcode = __le16_to_cpu(ev->opcode);\n\n\tbt_dev_dbg(hdev, \"opcode 0x%4.4x\", *opcode);\n\n\tfor (i = 0; i < ARRAY_SIZE(hci_cc_table); i++) {\n\t\tif (hci_cc_table[i].op == *opcode) {\n\t\t\t*status = hci_cc_func(hdev, &hci_cc_table[i], skb);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(hci_cc_table)) {\n\t\t \n\t\t*status = skb->data[0];\n\t}\n\n\thandle_cmd_cnt_and_timer(hdev, ev->ncmd);\n\n\thci_req_cmd_complete(hdev, *opcode, *status, req_complete,\n\t\t\t     req_complete_skb);\n\n\tif (hci_dev_test_flag(hdev, HCI_CMD_PENDING)) {\n\t\tbt_dev_err(hdev,\n\t\t\t   \"unexpected event for opcode 0x%4.4x\", *opcode);\n\t\treturn;\n\t}\n\n\tif (atomic_read(&hdev->cmd_cnt) && !skb_queue_empty(&hdev->cmd_q))\n\t\tqueue_work(hdev->workqueue, &hdev->cmd_work);\n}\n\nstatic void hci_cs_le_create_cis(struct hci_dev *hdev, u8 status)\n{\n\tstruct hci_cp_le_create_cis *cp;\n\tbool pending = false;\n\tint i;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_LE_CREATE_CIS);\n\tif (!cp)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\t \n\tfor (i = 0; cp->num_cis; cp->num_cis--, i++) {\n\t\tstruct hci_conn *conn;\n\t\tu16 handle;\n\n\t\thandle = __le16_to_cpu(cp->cis[i].cis_handle);\n\n\t\tconn = hci_conn_hash_lookup_handle(hdev, handle);\n\t\tif (conn) {\n\t\t\tif (test_and_clear_bit(HCI_CONN_CREATE_CIS,\n\t\t\t\t\t       &conn->flags))\n\t\t\t\tpending = true;\n\t\t\tconn->state = BT_CLOSED;\n\t\t\thci_connect_cfm(conn, status);\n\t\t\thci_conn_del(conn);\n\t\t}\n\t}\n\n\tif (pending)\n\t\thci_le_create_cis_pending(hdev);\n\n\thci_dev_unlock(hdev);\n}\n\n#define HCI_CS(_op, _func) \\\n{ \\\n\t.op = _op, \\\n\t.func = _func, \\\n}\n\nstatic const struct hci_cs {\n\tu16  op;\n\tvoid (*func)(struct hci_dev *hdev, __u8 status);\n} hci_cs_table[] = {\n\tHCI_CS(HCI_OP_INQUIRY, hci_cs_inquiry),\n\tHCI_CS(HCI_OP_CREATE_CONN, hci_cs_create_conn),\n\tHCI_CS(HCI_OP_DISCONNECT, hci_cs_disconnect),\n\tHCI_CS(HCI_OP_ADD_SCO, hci_cs_add_sco),\n\tHCI_CS(HCI_OP_AUTH_REQUESTED, hci_cs_auth_requested),\n\tHCI_CS(HCI_OP_SET_CONN_ENCRYPT, hci_cs_set_conn_encrypt),\n\tHCI_CS(HCI_OP_REMOTE_NAME_REQ, hci_cs_remote_name_req),\n\tHCI_CS(HCI_OP_READ_REMOTE_FEATURES, hci_cs_read_remote_features),\n\tHCI_CS(HCI_OP_READ_REMOTE_EXT_FEATURES,\n\t       hci_cs_read_remote_ext_features),\n\tHCI_CS(HCI_OP_SETUP_SYNC_CONN, hci_cs_setup_sync_conn),\n\tHCI_CS(HCI_OP_ENHANCED_SETUP_SYNC_CONN,\n\t       hci_cs_enhanced_setup_sync_conn),\n\tHCI_CS(HCI_OP_SNIFF_MODE, hci_cs_sniff_mode),\n\tHCI_CS(HCI_OP_EXIT_SNIFF_MODE, hci_cs_exit_sniff_mode),\n\tHCI_CS(HCI_OP_SWITCH_ROLE, hci_cs_switch_role),\n\tHCI_CS(HCI_OP_LE_CREATE_CONN, hci_cs_le_create_conn),\n\tHCI_CS(HCI_OP_LE_READ_REMOTE_FEATURES, hci_cs_le_read_remote_features),\n\tHCI_CS(HCI_OP_LE_START_ENC, hci_cs_le_start_enc),\n\tHCI_CS(HCI_OP_LE_EXT_CREATE_CONN, hci_cs_le_ext_create_conn),\n\tHCI_CS(HCI_OP_LE_CREATE_CIS, hci_cs_le_create_cis),\n\tHCI_CS(HCI_OP_LE_CREATE_BIG, hci_cs_le_create_big),\n};\n\nstatic void hci_cmd_status_evt(struct hci_dev *hdev, void *data,\n\t\t\t       struct sk_buff *skb, u16 *opcode, u8 *status,\n\t\t\t       hci_req_complete_t *req_complete,\n\t\t\t       hci_req_complete_skb_t *req_complete_skb)\n{\n\tstruct hci_ev_cmd_status *ev = data;\n\tint i;\n\n\t*opcode = __le16_to_cpu(ev->opcode);\n\t*status = ev->status;\n\n\tbt_dev_dbg(hdev, \"opcode 0x%4.4x\", *opcode);\n\n\tfor (i = 0; i < ARRAY_SIZE(hci_cs_table); i++) {\n\t\tif (hci_cs_table[i].op == *opcode) {\n\t\t\thci_cs_table[i].func(hdev, ev->status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thandle_cmd_cnt_and_timer(hdev, ev->ncmd);\n\n\t \n\tif (ev->status || (hdev->sent_cmd && !hci_skb_event(hdev->sent_cmd))) {\n\t\thci_req_cmd_complete(hdev, *opcode, ev->status, req_complete,\n\t\t\t\t     req_complete_skb);\n\t\tif (hci_dev_test_flag(hdev, HCI_CMD_PENDING)) {\n\t\t\tbt_dev_err(hdev, \"unexpected event for opcode 0x%4.4x\",\n\t\t\t\t   *opcode);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (atomic_read(&hdev->cmd_cnt) && !skb_queue_empty(&hdev->cmd_q))\n\t\tqueue_work(hdev->workqueue, &hdev->cmd_work);\n}\n\nstatic void hci_hardware_error_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_hardware_error *ev = data;\n\n\tbt_dev_dbg(hdev, \"code 0x%2.2x\", ev->code);\n\n\thdev->hw_error_code = ev->code;\n\n\tqueue_work(hdev->req_workqueue, &hdev->error_reset);\n}\n\nstatic void hci_role_change_evt(struct hci_dev *hdev, void *data,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_ev_role_change *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (conn) {\n\t\tif (!ev->status)\n\t\t\tconn->role = ev->role;\n\n\t\tclear_bit(HCI_CONN_RSWITCH_PEND, &conn->flags);\n\n\t\thci_role_switch_cfm(conn, ev->status, ev->role);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_num_comp_pkts_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_num_comp_pkts *ev = data;\n\tint i;\n\n\tif (!hci_ev_skb_pull(hdev, skb, HCI_EV_NUM_COMP_PKTS,\n\t\t\t     flex_array_size(ev, handles, ev->num)))\n\t\treturn;\n\n\tif (hdev->flow_ctl_mode != HCI_FLOW_CTL_MODE_PACKET_BASED) {\n\t\tbt_dev_err(hdev, \"wrong event for mode %d\", hdev->flow_ctl_mode);\n\t\treturn;\n\t}\n\n\tbt_dev_dbg(hdev, \"num %d\", ev->num);\n\n\tfor (i = 0; i < ev->num; i++) {\n\t\tstruct hci_comp_pkts_info *info = &ev->handles[i];\n\t\tstruct hci_conn *conn;\n\t\t__u16  handle, count;\n\n\t\thandle = __le16_to_cpu(info->handle);\n\t\tcount  = __le16_to_cpu(info->count);\n\n\t\tconn = hci_conn_hash_lookup_handle(hdev, handle);\n\t\tif (!conn)\n\t\t\tcontinue;\n\n\t\tconn->sent -= count;\n\n\t\tswitch (conn->type) {\n\t\tcase ACL_LINK:\n\t\t\thdev->acl_cnt += count;\n\t\t\tif (hdev->acl_cnt > hdev->acl_pkts)\n\t\t\t\thdev->acl_cnt = hdev->acl_pkts;\n\t\t\tbreak;\n\n\t\tcase LE_LINK:\n\t\t\tif (hdev->le_pkts) {\n\t\t\t\thdev->le_cnt += count;\n\t\t\t\tif (hdev->le_cnt > hdev->le_pkts)\n\t\t\t\t\thdev->le_cnt = hdev->le_pkts;\n\t\t\t} else {\n\t\t\t\thdev->acl_cnt += count;\n\t\t\t\tif (hdev->acl_cnt > hdev->acl_pkts)\n\t\t\t\t\thdev->acl_cnt = hdev->acl_pkts;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCO_LINK:\n\t\t\thdev->sco_cnt += count;\n\t\t\tif (hdev->sco_cnt > hdev->sco_pkts)\n\t\t\t\thdev->sco_cnt = hdev->sco_pkts;\n\t\t\tbreak;\n\n\t\tcase ISO_LINK:\n\t\t\tif (hdev->iso_pkts) {\n\t\t\t\thdev->iso_cnt += count;\n\t\t\t\tif (hdev->iso_cnt > hdev->iso_pkts)\n\t\t\t\t\thdev->iso_cnt = hdev->iso_pkts;\n\t\t\t} else if (hdev->le_pkts) {\n\t\t\t\thdev->le_cnt += count;\n\t\t\t\tif (hdev->le_cnt > hdev->le_pkts)\n\t\t\t\t\thdev->le_cnt = hdev->le_pkts;\n\t\t\t} else {\n\t\t\t\thdev->acl_cnt += count;\n\t\t\t\tif (hdev->acl_cnt > hdev->acl_pkts)\n\t\t\t\t\thdev->acl_cnt = hdev->acl_pkts;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbt_dev_err(hdev, \"unknown type %d conn %p\",\n\t\t\t\t   conn->type, conn);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tqueue_work(hdev->workqueue, &hdev->tx_work);\n}\n\nstatic struct hci_conn *__hci_conn_lookup_handle(struct hci_dev *hdev,\n\t\t\t\t\t\t __u16 handle)\n{\n\tstruct hci_chan *chan;\n\n\tswitch (hdev->dev_type) {\n\tcase HCI_PRIMARY:\n\t\treturn hci_conn_hash_lookup_handle(hdev, handle);\n\tcase HCI_AMP:\n\t\tchan = hci_chan_lookup_handle(hdev, handle);\n\t\tif (chan)\n\t\t\treturn chan->conn;\n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"unknown dev_type %d\", hdev->dev_type);\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hci_num_comp_blocks_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_num_comp_blocks *ev = data;\n\tint i;\n\n\tif (!hci_ev_skb_pull(hdev, skb, HCI_EV_NUM_COMP_BLOCKS,\n\t\t\t     flex_array_size(ev, handles, ev->num_hndl)))\n\t\treturn;\n\n\tif (hdev->flow_ctl_mode != HCI_FLOW_CTL_MODE_BLOCK_BASED) {\n\t\tbt_dev_err(hdev, \"wrong event for mode %d\",\n\t\t\t   hdev->flow_ctl_mode);\n\t\treturn;\n\t}\n\n\tbt_dev_dbg(hdev, \"num_blocks %d num_hndl %d\", ev->num_blocks,\n\t\t   ev->num_hndl);\n\n\tfor (i = 0; i < ev->num_hndl; i++) {\n\t\tstruct hci_comp_blocks_info *info = &ev->handles[i];\n\t\tstruct hci_conn *conn = NULL;\n\t\t__u16  handle, block_count;\n\n\t\thandle = __le16_to_cpu(info->handle);\n\t\tblock_count = __le16_to_cpu(info->blocks);\n\n\t\tconn = __hci_conn_lookup_handle(hdev, handle);\n\t\tif (!conn)\n\t\t\tcontinue;\n\n\t\tconn->sent -= block_count;\n\n\t\tswitch (conn->type) {\n\t\tcase ACL_LINK:\n\t\tcase AMP_LINK:\n\t\t\thdev->block_cnt += block_count;\n\t\t\tif (hdev->block_cnt > hdev->num_blocks)\n\t\t\t\thdev->block_cnt = hdev->num_blocks;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbt_dev_err(hdev, \"unknown type %d conn %p\",\n\t\t\t\t   conn->type, conn);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tqueue_work(hdev->workqueue, &hdev->tx_work);\n}\n\nstatic void hci_mode_change_evt(struct hci_dev *hdev, void *data,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_ev_mode_change *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (conn) {\n\t\tconn->mode = ev->mode;\n\n\t\tif (!test_and_clear_bit(HCI_CONN_MODE_CHANGE_PEND,\n\t\t\t\t\t&conn->flags)) {\n\t\t\tif (conn->mode == HCI_CM_ACTIVE)\n\t\t\t\tset_bit(HCI_CONN_POWER_SAVE, &conn->flags);\n\t\t\telse\n\t\t\t\tclear_bit(HCI_CONN_POWER_SAVE, &conn->flags);\n\t\t}\n\n\t\tif (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))\n\t\t\thci_sco_setup(conn, ev->status);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_pin_code_request_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_pin_code_req *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (conn->state == BT_CONNECTED) {\n\t\thci_conn_hold(conn);\n\t\tconn->disc_timeout = HCI_PAIRING_TIMEOUT;\n\t\thci_conn_drop(conn);\n\t}\n\n\tif (!hci_dev_test_flag(hdev, HCI_BONDABLE) &&\n\t    !test_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags)) {\n\t\thci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,\n\t\t\t     sizeof(ev->bdaddr), &ev->bdaddr);\n\t} else if (hci_dev_test_flag(hdev, HCI_MGMT)) {\n\t\tu8 secure;\n\n\t\tif (conn->pending_sec_level == BT_SECURITY_HIGH)\n\t\t\tsecure = 1;\n\t\telse\n\t\t\tsecure = 0;\n\n\t\tmgmt_pin_code_request(hdev, &ev->bdaddr, secure);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void conn_set_key(struct hci_conn *conn, u8 key_type, u8 pin_len)\n{\n\tif (key_type == HCI_LK_CHANGED_COMBINATION)\n\t\treturn;\n\n\tconn->pin_length = pin_len;\n\tconn->key_type = key_type;\n\n\tswitch (key_type) {\n\tcase HCI_LK_LOCAL_UNIT:\n\tcase HCI_LK_REMOTE_UNIT:\n\tcase HCI_LK_DEBUG_COMBINATION:\n\t\treturn;\n\tcase HCI_LK_COMBINATION:\n\t\tif (pin_len == 16)\n\t\t\tconn->pending_sec_level = BT_SECURITY_HIGH;\n\t\telse\n\t\t\tconn->pending_sec_level = BT_SECURITY_MEDIUM;\n\t\tbreak;\n\tcase HCI_LK_UNAUTH_COMBINATION_P192:\n\tcase HCI_LK_UNAUTH_COMBINATION_P256:\n\t\tconn->pending_sec_level = BT_SECURITY_MEDIUM;\n\t\tbreak;\n\tcase HCI_LK_AUTH_COMBINATION_P192:\n\t\tconn->pending_sec_level = BT_SECURITY_HIGH;\n\t\tbreak;\n\tcase HCI_LK_AUTH_COMBINATION_P256:\n\t\tconn->pending_sec_level = BT_SECURITY_FIPS;\n\t\tbreak;\n\t}\n}\n\nstatic void hci_link_key_request_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_link_key_req *ev = data;\n\tstruct hci_cp_link_key_reply cp;\n\tstruct hci_conn *conn;\n\tstruct link_key *key;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tif (!hci_dev_test_flag(hdev, HCI_MGMT))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tkey = hci_find_link_key(hdev, &ev->bdaddr);\n\tif (!key) {\n\t\tbt_dev_dbg(hdev, \"link key not found for %pMR\", &ev->bdaddr);\n\t\tgoto not_found;\n\t}\n\n\tbt_dev_dbg(hdev, \"found key type %u for %pMR\", key->type, &ev->bdaddr);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (conn) {\n\t\tclear_bit(HCI_CONN_NEW_LINK_KEY, &conn->flags);\n\n\t\tif ((key->type == HCI_LK_UNAUTH_COMBINATION_P192 ||\n\t\t     key->type == HCI_LK_UNAUTH_COMBINATION_P256) &&\n\t\t    conn->auth_type != 0xff && (conn->auth_type & 0x01)) {\n\t\t\tbt_dev_dbg(hdev, \"ignoring unauthenticated key\");\n\t\t\tgoto not_found;\n\t\t}\n\n\t\tif (key->type == HCI_LK_COMBINATION && key->pin_len < 16 &&\n\t\t    (conn->pending_sec_level == BT_SECURITY_HIGH ||\n\t\t     conn->pending_sec_level == BT_SECURITY_FIPS)) {\n\t\t\tbt_dev_dbg(hdev, \"ignoring key unauthenticated for high security\");\n\t\t\tgoto not_found;\n\t\t}\n\n\t\tconn_set_key(conn, key->type, key->pin_len);\n\t}\n\n\tbacpy(&cp.bdaddr, &ev->bdaddr);\n\tmemcpy(cp.link_key, key->val, HCI_LINK_KEY_SIZE);\n\n\thci_send_cmd(hdev, HCI_OP_LINK_KEY_REPLY, sizeof(cp), &cp);\n\n\thci_dev_unlock(hdev);\n\n\treturn;\n\nnot_found:\n\thci_send_cmd(hdev, HCI_OP_LINK_KEY_NEG_REPLY, 6, &ev->bdaddr);\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_link_key_notify_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_link_key_notify *ev = data;\n\tstruct hci_conn *conn;\n\tstruct link_key *key;\n\tbool persistent;\n\tu8 pin_len = 0;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (!conn)\n\t\tgoto unlock;\n\n\t \n\tif (!crypto_memneq(ev->link_key, ZERO_KEY, HCI_LINK_KEY_SIZE)) {\n\t\tbt_dev_dbg(hdev, \"Ignore NULL link key (ZERO KEY) for %pMR\",\n\t\t\t   &ev->bdaddr);\n\t\thci_disconnect(conn, HCI_ERROR_AUTH_FAILURE);\n\t\thci_conn_drop(conn);\n\t\tgoto unlock;\n\t}\n\n\thci_conn_hold(conn);\n\tconn->disc_timeout = HCI_DISCONN_TIMEOUT;\n\thci_conn_drop(conn);\n\n\tset_bit(HCI_CONN_NEW_LINK_KEY, &conn->flags);\n\tconn_set_key(conn, ev->key_type, conn->pin_length);\n\n\tif (!hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tgoto unlock;\n\n\tkey = hci_add_link_key(hdev, conn, &ev->bdaddr, ev->link_key,\n\t\t\t        ev->key_type, pin_len, &persistent);\n\tif (!key)\n\t\tgoto unlock;\n\n\t \n\tif (ev->key_type == HCI_LK_CHANGED_COMBINATION)\n\t\tconn_set_key(conn, key->type, key->pin_len);\n\n\tmgmt_new_link_key(hdev, key, persistent);\n\n\t \n\tif (key->type == HCI_LK_DEBUG_COMBINATION &&\n\t    !hci_dev_test_flag(hdev, HCI_KEEP_DEBUG_KEYS)) {\n\t\tlist_del_rcu(&key->list);\n\t\tkfree_rcu(key, rcu);\n\t\tgoto unlock;\n\t}\n\n\tif (persistent)\n\t\tclear_bit(HCI_CONN_FLUSH_KEY, &conn->flags);\n\telse\n\t\tset_bit(HCI_CONN_FLUSH_KEY, &conn->flags);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_clock_offset_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_ev_clock_offset *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (conn && !ev->status) {\n\t\tstruct inquiry_entry *ie;\n\n\t\tie = hci_inquiry_cache_lookup(hdev, &conn->dst);\n\t\tif (ie) {\n\t\t\tie->data.clock_offset = ev->clock_offset;\n\t\t\tie->timestamp = jiffies;\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_pkt_type_change_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_pkt_type_change *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (conn && !ev->status)\n\t\tconn->pkt_type = __le16_to_cpu(ev->pkt_type);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_pscan_rep_mode_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_pscan_rep_mode *ev = data;\n\tstruct inquiry_entry *ie;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\tie = hci_inquiry_cache_lookup(hdev, &ev->bdaddr);\n\tif (ie) {\n\t\tie->data.pscan_rep_mode = ev->pscan_rep_mode;\n\t\tie->timestamp = jiffies;\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_inquiry_result_with_rssi_evt(struct hci_dev *hdev, void *edata,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_inquiry_result_rssi *ev = edata;\n\tstruct inquiry_data data;\n\tint i;\n\n\tbt_dev_dbg(hdev, \"num_rsp %d\", ev->num);\n\n\tif (!ev->num)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tif (skb->len == array_size(ev->num,\n\t\t\t\t   sizeof(struct inquiry_info_rssi_pscan))) {\n\t\tstruct inquiry_info_rssi_pscan *info;\n\n\t\tfor (i = 0; i < ev->num; i++) {\n\t\t\tu32 flags;\n\n\t\t\tinfo = hci_ev_skb_pull(hdev, skb,\n\t\t\t\t\t       HCI_EV_INQUIRY_RESULT_WITH_RSSI,\n\t\t\t\t\t       sizeof(*info));\n\t\t\tif (!info) {\n\t\t\t\tbt_dev_err(hdev, \"Malformed HCI Event: 0x%2.2x\",\n\t\t\t\t\t   HCI_EV_INQUIRY_RESULT_WITH_RSSI);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\t\tdata.pscan_mode\t\t= info->pscan_mode;\n\t\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\t\tdata.clock_offset\t= info->clock_offset;\n\t\t\tdata.rssi\t\t= info->rssi;\n\t\t\tdata.ssp_mode\t\t= 0x00;\n\n\t\t\tflags = hci_inquiry_cache_update(hdev, &data, false);\n\n\t\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t\t  flags, NULL, 0, NULL, 0, 0);\n\t\t}\n\t} else if (skb->len == array_size(ev->num,\n\t\t\t\t\t  sizeof(struct inquiry_info_rssi))) {\n\t\tstruct inquiry_info_rssi *info;\n\n\t\tfor (i = 0; i < ev->num; i++) {\n\t\t\tu32 flags;\n\n\t\t\tinfo = hci_ev_skb_pull(hdev, skb,\n\t\t\t\t\t       HCI_EV_INQUIRY_RESULT_WITH_RSSI,\n\t\t\t\t\t       sizeof(*info));\n\t\t\tif (!info) {\n\t\t\t\tbt_dev_err(hdev, \"Malformed HCI Event: 0x%2.2x\",\n\t\t\t\t\t   HCI_EV_INQUIRY_RESULT_WITH_RSSI);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\t\tdata.pscan_mode\t\t= 0x00;\n\t\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\t\tdata.clock_offset\t= info->clock_offset;\n\t\t\tdata.rssi\t\t= info->rssi;\n\t\t\tdata.ssp_mode\t\t= 0x00;\n\n\t\t\tflags = hci_inquiry_cache_update(hdev, &data, false);\n\n\t\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t\t  flags, NULL, 0, NULL, 0, 0);\n\t\t}\n\t} else {\n\t\tbt_dev_err(hdev, \"Malformed HCI Event: 0x%2.2x\",\n\t\t\t   HCI_EV_INQUIRY_RESULT_WITH_RSSI);\n\t}\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_remote_ext_features_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_ev_remote_ext_features *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (ev->page < HCI_MAX_PAGES)\n\t\tmemcpy(conn->features[ev->page], ev->features, 8);\n\n\tif (!ev->status && ev->page == 0x01) {\n\t\tstruct inquiry_entry *ie;\n\n\t\tie = hci_inquiry_cache_lookup(hdev, &conn->dst);\n\t\tif (ie)\n\t\t\tie->data.ssp_mode = (ev->features[0] & LMP_HOST_SSP);\n\n\t\tif (ev->features[0] & LMP_HOST_SSP) {\n\t\t\tset_bit(HCI_CONN_SSP_ENABLED, &conn->flags);\n\t\t} else {\n\t\t\t \n\t\t\tclear_bit(HCI_CONN_SSP_ENABLED, &conn->flags);\n\t\t}\n\n\t\tif (ev->features[0] & LMP_HOST_SC)\n\t\t\tset_bit(HCI_CONN_SC_ENABLED, &conn->flags);\n\t}\n\n\tif (conn->state != BT_CONFIG)\n\t\tgoto unlock;\n\n\tif (!ev->status && !test_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags)) {\n\t\tstruct hci_cp_remote_name_req cp;\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tbacpy(&cp.bdaddr, &conn->dst);\n\t\tcp.pscan_rep_mode = 0x02;\n\t\thci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);\n\t} else if (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))\n\t\tmgmt_device_connected(hdev, conn, NULL, 0);\n\n\tif (!hci_outgoing_auth_needed(hdev, conn)) {\n\t\tconn->state = BT_CONNECTED;\n\t\thci_connect_cfm(conn, ev->status);\n\t\thci_conn_drop(conn);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_sync_conn_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_ev_sync_conn_complete *ev = data;\n\tstruct hci_conn *conn;\n\tu8 status = ev->status;\n\n\tswitch (ev->link_type) {\n\tcase SCO_LINK:\n\tcase ESCO_LINK:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbt_dev_err(hdev, \"Ignoring connect complete event for invalid link type\");\n\t\treturn;\n\t}\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ev->link_type, &ev->bdaddr);\n\tif (!conn) {\n\t\tif (ev->link_type == ESCO_LINK)\n\t\t\tgoto unlock;\n\n\t\t \n\t\tconn = hci_conn_hash_lookup_ba(hdev, ESCO_LINK, &ev->bdaddr);\n\t\tif (!conn)\n\t\t\tgoto unlock;\n\t}\n\n\t \n\tif (!HCI_CONN_HANDLE_UNSET(conn->handle)) {\n\t\tbt_dev_err(hdev, \"Ignoring HCI_Sync_Conn_Complete event for existing connection\");\n\t\tgoto unlock;\n\t}\n\n\tswitch (status) {\n\tcase 0x00:\n\t\tstatus = hci_conn_set_handle(conn, __le16_to_cpu(ev->handle));\n\t\tif (status) {\n\t\t\tconn->state = BT_CLOSED;\n\t\t\tbreak;\n\t\t}\n\n\t\tconn->state  = BT_CONNECTED;\n\t\tconn->type   = ev->link_type;\n\n\t\thci_debugfs_create_conn(conn);\n\t\thci_conn_add_sysfs(conn);\n\t\tbreak;\n\n\tcase 0x10:\t \n\tcase 0x0d:\t \n\tcase 0x11:\t \n\tcase 0x1c:\t \n\tcase 0x1a:\t \n\tcase 0x1e:\t \n\tcase 0x1f:\t \n\tcase 0x20:\t \n\t\tif (conn->out) {\n\t\t\tconn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |\n\t\t\t\t\t(hdev->esco_type & EDR_ESCO_MASK);\n\t\t\tif (hci_setup_sync(conn, conn->parent->handle))\n\t\t\t\tgoto unlock;\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\n\t\tconn->state = BT_CLOSED;\n\t\tbreak;\n\t}\n\n\tbt_dev_dbg(hdev, \"SCO connected with air mode: %02x\", ev->air_mode);\n\t \n\tif (conn->codec.data_path == 0 && hdev->notify) {\n\t\tswitch (ev->air_mode) {\n\t\tcase 0x02:\n\t\t\thdev->notify(hdev, HCI_NOTIFY_ENABLE_SCO_CVSD);\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\thdev->notify(hdev, HCI_NOTIFY_ENABLE_SCO_TRANSP);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thci_connect_cfm(conn, status);\n\tif (status)\n\t\thci_conn_del(conn);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic inline size_t eir_get_length(u8 *eir, size_t eir_len)\n{\n\tsize_t parsed = 0;\n\n\twhile (parsed < eir_len) {\n\t\tu8 field_len = eir[0];\n\n\t\tif (field_len == 0)\n\t\t\treturn parsed;\n\n\t\tparsed += field_len + 1;\n\t\teir += field_len + 1;\n\t}\n\n\treturn eir_len;\n}\n\nstatic void hci_extended_inquiry_result_evt(struct hci_dev *hdev, void *edata,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_ext_inquiry_result *ev = edata;\n\tstruct inquiry_data data;\n\tsize_t eir_len;\n\tint i;\n\n\tif (!hci_ev_skb_pull(hdev, skb, HCI_EV_EXTENDED_INQUIRY_RESULT,\n\t\t\t     flex_array_size(ev, info, ev->num)))\n\t\treturn;\n\n\tbt_dev_dbg(hdev, \"num %d\", ev->num);\n\n\tif (!ev->num)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (i = 0; i < ev->num; i++) {\n\t\tstruct extended_inquiry_info *info = &ev->info[i];\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_key_refresh_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_ev_key_refresh_complete *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x handle 0x%4.4x\", ev->status,\n\t\t   __le16_to_cpu(ev->handle));\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\t \n\tif (conn->type != LE_LINK)\n\t\tgoto unlock;\n\n\tif (!ev->status)\n\t\tconn->sec_level = conn->pending_sec_level;\n\n\tclear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);\n\n\tif (ev->status && conn->state == BT_CONNECTED) {\n\t\thci_disconnect(conn, HCI_ERROR_AUTH_FAILURE);\n\t\thci_conn_drop(conn);\n\t\tgoto unlock;\n\t}\n\n\tif (conn->state == BT_CONFIG) {\n\t\tif (!ev->status)\n\t\t\tconn->state = BT_CONNECTED;\n\n\t\thci_connect_cfm(conn, ev->status);\n\t\thci_conn_drop(conn);\n\t} else {\n\t\thci_auth_cfm(conn, ev->status);\n\n\t\thci_conn_hold(conn);\n\t\tconn->disc_timeout = HCI_DISCONN_TIMEOUT;\n\t\thci_conn_drop(conn);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic u8 hci_get_auth_req(struct hci_conn *conn)\n{\n\t \n\tif (conn->remote_auth == HCI_AT_NO_BONDING ||\n\t    conn->remote_auth == HCI_AT_NO_BONDING_MITM)\n\t\treturn conn->remote_auth | (conn->auth_type & 0x01);\n\n\t \n\tif (conn->remote_cap != HCI_IO_NO_INPUT_OUTPUT &&\n\t    conn->io_capability != HCI_IO_NO_INPUT_OUTPUT)\n\t\treturn conn->remote_auth | 0x01;\n\n\t \n\treturn (conn->remote_auth & ~0x01) | (conn->auth_type & 0x01);\n}\n\nstatic u8 bredr_oob_data_present(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct oob_data *data;\n\n\tdata = hci_find_remote_oob_data(hdev, &conn->dst, BDADDR_BREDR);\n\tif (!data)\n\t\treturn 0x00;\n\n\tif (bredr_sc_enabled(hdev)) {\n\t\t \n\t\tif (!hci_dev_test_flag(hdev, HCI_SC_ONLY))\n\t\t\treturn data->present;\n\n\t\t \n\t\tif (!crypto_memneq(data->rand256, ZERO_KEY, 16) ||\n\t\t    !crypto_memneq(data->hash256, ZERO_KEY, 16))\n\t\t\treturn 0x00;\n\n\t\treturn 0x02;\n\t}\n\n\t \n\tif (!crypto_memneq(data->rand192, ZERO_KEY, 16) ||\n\t    !crypto_memneq(data->hash192, ZERO_KEY, 16))\n\t\treturn 0x00;\n\n\treturn 0x01;\n}\n\nstatic void hci_io_capa_request_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_io_capa_request *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (!conn || !hci_conn_ssp_enabled(conn))\n\t\tgoto unlock;\n\n\thci_conn_hold(conn);\n\n\tif (!hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tgoto unlock;\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_BONDABLE) ||\n\t    test_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags) ||\n\t    (conn->remote_auth & ~0x01) == HCI_AT_NO_BONDING) {\n\t\tstruct hci_cp_io_capability_reply cp;\n\n\t\tbacpy(&cp.bdaddr, &ev->bdaddr);\n\t\t \n\t\tcp.capability = (conn->io_capability == 0x04) ?\n\t\t\t\tHCI_IO_DISPLAY_YESNO : conn->io_capability;\n\n\t\t \n\t\tif (conn->remote_auth == 0xff) {\n\t\t\t \n\t\t\tif (conn->io_capability != HCI_IO_NO_INPUT_OUTPUT &&\n\t\t\t    conn->auth_type != HCI_AT_NO_BONDING)\n\t\t\t\tconn->auth_type |= 0x01;\n\t\t} else {\n\t\t\tconn->auth_type = hci_get_auth_req(conn);\n\t\t}\n\n\t\t \n\t\tif (!hci_dev_test_flag(hdev, HCI_BONDABLE))\n\t\t\tconn->auth_type &= HCI_AT_NO_BONDING_MITM;\n\n\t\tcp.authentication = conn->auth_type;\n\t\tcp.oob_data = bredr_oob_data_present(conn);\n\n\t\thci_send_cmd(hdev, HCI_OP_IO_CAPABILITY_REPLY,\n\t\t\t     sizeof(cp), &cp);\n\t} else {\n\t\tstruct hci_cp_io_capability_neg_reply cp;\n\n\t\tbacpy(&cp.bdaddr, &ev->bdaddr);\n\t\tcp.reason = HCI_ERROR_PAIRING_NOT_ALLOWED;\n\n\t\thci_send_cmd(hdev, HCI_OP_IO_CAPABILITY_NEG_REPLY,\n\t\t\t     sizeof(cp), &cp);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_io_capa_reply_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_io_capa_reply *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (!conn)\n\t\tgoto unlock;\n\n\tconn->remote_cap = ev->capability;\n\tconn->remote_auth = ev->authentication;\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_user_confirm_request_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_ev_user_confirm_req *ev = data;\n\tint loc_mitm, rem_mitm, confirm_hint = 0;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\tif (!hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tgoto unlock;\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (!conn)\n\t\tgoto unlock;\n\n\tloc_mitm = (conn->auth_type & 0x01);\n\trem_mitm = (conn->remote_auth & 0x01);\n\n\t \n\tif (conn->pending_sec_level > BT_SECURITY_MEDIUM &&\n\t    conn->remote_cap == HCI_IO_NO_INPUT_OUTPUT) {\n\t\tbt_dev_dbg(hdev, \"Rejecting request: remote device can't provide MITM\");\n\t\thci_send_cmd(hdev, HCI_OP_USER_CONFIRM_NEG_REPLY,\n\t\t\t     sizeof(ev->bdaddr), &ev->bdaddr);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif ((!loc_mitm || conn->remote_cap == HCI_IO_NO_INPUT_OUTPUT) &&\n\t    (!rem_mitm || conn->io_capability == HCI_IO_NO_INPUT_OUTPUT)) {\n\n\t\t \n\t\tif (!test_bit(HCI_CONN_AUTH_PEND, &conn->flags) &&\n\t\t    conn->io_capability != HCI_IO_NO_INPUT_OUTPUT &&\n\t\t    (loc_mitm || rem_mitm)) {\n\t\t\tbt_dev_dbg(hdev, \"Confirming auto-accept as acceptor\");\n\t\t\tconfirm_hint = 1;\n\t\t\tgoto confirm;\n\t\t}\n\n\t\t \n\t\tif (hci_find_link_key(hdev, &ev->bdaddr)) {\n\t\t\tbt_dev_dbg(hdev, \"Local host already has link key\");\n\t\t\tconfirm_hint = 1;\n\t\t\tgoto confirm;\n\t\t}\n\n\t\tBT_DBG(\"Auto-accept of user confirmation with %ums delay\",\n\t\t       hdev->auto_accept_delay);\n\n\t\tif (hdev->auto_accept_delay > 0) {\n\t\t\tint delay = msecs_to_jiffies(hdev->auto_accept_delay);\n\t\t\tqueue_delayed_work(conn->hdev->workqueue,\n\t\t\t\t\t   &conn->auto_accept_work, delay);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\thci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY,\n\t\t\t     sizeof(ev->bdaddr), &ev->bdaddr);\n\t\tgoto unlock;\n\t}\n\nconfirm:\n\tmgmt_user_confirm_request(hdev, &ev->bdaddr, ACL_LINK, 0,\n\t\t\t\t  le32_to_cpu(ev->passkey), confirm_hint);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_user_passkey_request_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_ev_user_passkey_req *ev = data;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_user_passkey_request(hdev, &ev->bdaddr, ACL_LINK, 0);\n}\n\nstatic void hci_user_passkey_notify_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_ev_user_passkey_notify *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (!conn)\n\t\treturn;\n\n\tconn->passkey_notify = __le32_to_cpu(ev->passkey);\n\tconn->passkey_entered = 0;\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_user_passkey_notify(hdev, &conn->dst, conn->type,\n\t\t\t\t\t conn->dst_type, conn->passkey_notify,\n\t\t\t\t\t conn->passkey_entered);\n}\n\nstatic void hci_keypress_notify_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_keypress_notify *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (!conn)\n\t\treturn;\n\n\tswitch (ev->type) {\n\tcase HCI_KEYPRESS_STARTED:\n\t\tconn->passkey_entered = 0;\n\t\treturn;\n\n\tcase HCI_KEYPRESS_ENTERED:\n\t\tconn->passkey_entered++;\n\t\tbreak;\n\n\tcase HCI_KEYPRESS_ERASED:\n\t\tconn->passkey_entered--;\n\t\tbreak;\n\n\tcase HCI_KEYPRESS_CLEARED:\n\t\tconn->passkey_entered = 0;\n\t\tbreak;\n\n\tcase HCI_KEYPRESS_COMPLETED:\n\t\treturn;\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tmgmt_user_passkey_notify(hdev, &conn->dst, conn->type,\n\t\t\t\t\t conn->dst_type, conn->passkey_notify,\n\t\t\t\t\t conn->passkey_entered);\n}\n\nstatic void hci_simple_pair_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_ev_simple_pair_complete *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (!conn || !hci_conn_ssp_enabled(conn))\n\t\tgoto unlock;\n\n\t \n\tconn->remote_auth = 0xff;\n\n\t \n\tif (!test_bit(HCI_CONN_AUTH_PEND, &conn->flags) && ev->status)\n\t\tmgmt_auth_failed(conn, ev->status);\n\n\thci_conn_drop(conn);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_remote_host_features_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_ev_remote_host_features *ev = data;\n\tstruct inquiry_entry *ie;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\n\tif (conn)\n\t\tmemcpy(conn->features[1], ev->features, 8);\n\n\tie = hci_inquiry_cache_lookup(hdev, &ev->bdaddr);\n\tif (ie)\n\t\tie->data.ssp_mode = (ev->features[0] & LMP_HOST_SSP);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_remote_oob_data_request_evt(struct hci_dev *hdev, void *edata,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_remote_oob_data_request *ev = edata;\n\tstruct oob_data *data;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_lock(hdev);\n\n\tif (!hci_dev_test_flag(hdev, HCI_MGMT))\n\t\tgoto unlock;\n\n\tdata = hci_find_remote_oob_data(hdev, &ev->bdaddr, BDADDR_BREDR);\n\tif (!data) {\n\t\tstruct hci_cp_remote_oob_data_neg_reply cp;\n\n\t\tbacpy(&cp.bdaddr, &ev->bdaddr);\n\t\thci_send_cmd(hdev, HCI_OP_REMOTE_OOB_DATA_NEG_REPLY,\n\t\t\t     sizeof(cp), &cp);\n\t\tgoto unlock;\n\t}\n\n\tif (bredr_sc_enabled(hdev)) {\n\t\tstruct hci_cp_remote_oob_ext_data_reply cp;\n\n\t\tbacpy(&cp.bdaddr, &ev->bdaddr);\n\t\tif (hci_dev_test_flag(hdev, HCI_SC_ONLY)) {\n\t\t\tmemset(cp.hash192, 0, sizeof(cp.hash192));\n\t\t\tmemset(cp.rand192, 0, sizeof(cp.rand192));\n\t\t} else {\n\t\t\tmemcpy(cp.hash192, data->hash192, sizeof(cp.hash192));\n\t\t\tmemcpy(cp.rand192, data->rand192, sizeof(cp.rand192));\n\t\t}\n\t\tmemcpy(cp.hash256, data->hash256, sizeof(cp.hash256));\n\t\tmemcpy(cp.rand256, data->rand256, sizeof(cp.rand256));\n\n\t\thci_send_cmd(hdev, HCI_OP_REMOTE_OOB_EXT_DATA_REPLY,\n\t\t\t     sizeof(cp), &cp);\n\t} else {\n\t\tstruct hci_cp_remote_oob_data_reply cp;\n\n\t\tbacpy(&cp.bdaddr, &ev->bdaddr);\n\t\tmemcpy(cp.hash, data->hash192, sizeof(cp.hash));\n\t\tmemcpy(cp.rand, data->rand192, sizeof(cp.rand));\n\n\t\thci_send_cmd(hdev, HCI_OP_REMOTE_OOB_DATA_REPLY,\n\t\t\t     sizeof(cp), &cp);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\n#if IS_ENABLED(CONFIG_BT_HS)\nstatic void hci_chan_selected_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_channel_selected *ev = data;\n\tstruct hci_conn *hcon;\n\n\tbt_dev_dbg(hdev, \"handle 0x%2.2x\", ev->phy_handle);\n\n\thcon = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);\n\tif (!hcon)\n\t\treturn;\n\n\tamp_read_loc_assoc_final_data(hdev, hcon);\n}\n\nstatic void hci_phy_link_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_ev_phy_link_complete *ev = data;\n\tstruct hci_conn *hcon, *bredr_hcon;\n\n\tbt_dev_dbg(hdev, \"handle 0x%2.2x status 0x%2.2x\", ev->phy_handle,\n\t\t   ev->status);\n\n\thci_dev_lock(hdev);\n\n\thcon = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);\n\tif (!hcon)\n\t\tgoto unlock;\n\n\tif (!hcon->amp_mgr)\n\t\tgoto unlock;\n\n\tif (ev->status) {\n\t\thci_conn_del(hcon);\n\t\tgoto unlock;\n\t}\n\n\tbredr_hcon = hcon->amp_mgr->l2cap_conn->hcon;\n\n\thcon->state = BT_CONNECTED;\n\tbacpy(&hcon->dst, &bredr_hcon->dst);\n\n\thci_conn_hold(hcon);\n\thcon->disc_timeout = HCI_DISCONN_TIMEOUT;\n\thci_conn_drop(hcon);\n\n\thci_debugfs_create_conn(hcon);\n\thci_conn_add_sysfs(hcon);\n\n\tamp_physical_cfm(bredr_hcon, hcon);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_loglink_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_logical_link_complete *ev = data;\n\tstruct hci_conn *hcon;\n\tstruct hci_chan *hchan;\n\tstruct amp_mgr *mgr;\n\n\tbt_dev_dbg(hdev, \"log_handle 0x%4.4x phy_handle 0x%2.2x status 0x%2.2x\",\n\t\t   le16_to_cpu(ev->handle), ev->phy_handle, ev->status);\n\n\thcon = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);\n\tif (!hcon)\n\t\treturn;\n\n\t \n\thchan = hci_chan_create(hcon);\n\tif (!hchan)\n\t\treturn;\n\n\thchan->handle = le16_to_cpu(ev->handle);\n\thchan->amp = true;\n\n\tBT_DBG(\"hcon %p mgr %p hchan %p\", hcon, hcon->amp_mgr, hchan);\n\n\tmgr = hcon->amp_mgr;\n\tif (mgr && mgr->bredr_chan) {\n\t\tstruct l2cap_chan *bredr_chan = mgr->bredr_chan;\n\n\t\tl2cap_chan_lock(bredr_chan);\n\n\t\tbredr_chan->conn->mtu = hdev->block_mtu;\n\t\tl2cap_logical_cfm(bredr_chan, hchan, 0);\n\t\thci_conn_hold(hcon);\n\n\t\tl2cap_chan_unlock(bredr_chan);\n\t}\n}\n\nstatic void hci_disconn_loglink_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_disconn_logical_link_complete *ev = data;\n\tstruct hci_chan *hchan;\n\n\tbt_dev_dbg(hdev, \"handle 0x%4.4x status 0x%2.2x\",\n\t\t   le16_to_cpu(ev->handle), ev->status);\n\n\tif (ev->status)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\thchan = hci_chan_lookup_handle(hdev, le16_to_cpu(ev->handle));\n\tif (!hchan || !hchan->amp)\n\t\tgoto unlock;\n\n\tamp_destroy_logical_link(hchan, ev->reason);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_disconn_phylink_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_disconn_phy_link_complete *ev = data;\n\tstruct hci_conn *hcon;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\tif (ev->status)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\thcon = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);\n\tif (hcon && hcon->type == AMP_LINK) {\n\t\thcon->state = BT_CLOSED;\n\t\thci_disconn_cfm(hcon, ev->reason);\n\t\thci_conn_del(hcon);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n#endif\n\nstatic void le_conn_update_addr(struct hci_conn *conn, bdaddr_t *bdaddr,\n\t\t\t\tu8 bdaddr_type, bdaddr_t *local_rpa)\n{\n\tif (conn->out) {\n\t\tconn->dst_type = bdaddr_type;\n\t\tconn->resp_addr_type = bdaddr_type;\n\t\tbacpy(&conn->resp_addr, bdaddr);\n\n\t\t \n\t\tif (local_rpa && bacmp(local_rpa, BDADDR_ANY)) {\n\t\t\tconn->init_addr_type = ADDR_LE_DEV_RANDOM;\n\t\t\tbacpy(&conn->init_addr, local_rpa);\n\t\t} else if (hci_dev_test_flag(conn->hdev, HCI_PRIVACY)) {\n\t\t\tconn->init_addr_type = ADDR_LE_DEV_RANDOM;\n\t\t\tbacpy(&conn->init_addr, &conn->hdev->rpa);\n\t\t} else {\n\t\t\thci_copy_identity_address(conn->hdev, &conn->init_addr,\n\t\t\t\t\t\t  &conn->init_addr_type);\n\t\t}\n\t} else {\n\t\tconn->resp_addr_type = conn->hdev->adv_addr_type;\n\t\t \n\t\tif (local_rpa && bacmp(local_rpa, BDADDR_ANY)) {\n\t\t\tconn->resp_addr_type = ADDR_LE_DEV_RANDOM;\n\t\t\tbacpy(&conn->resp_addr, local_rpa);\n\t\t} else if (conn->hdev->adv_addr_type == ADDR_LE_DEV_RANDOM) {\n\t\t\t \n\t\t\tif (!ext_adv_capable(conn->hdev))\n\t\t\t\tbacpy(&conn->resp_addr,\n\t\t\t\t      &conn->hdev->random_addr);\n\t\t} else {\n\t\t\tbacpy(&conn->resp_addr, &conn->hdev->bdaddr);\n\t\t}\n\n\t\tconn->init_addr_type = bdaddr_type;\n\t\tbacpy(&conn->init_addr, bdaddr);\n\n\t\t \n\t\tconn->le_conn_min_interval = conn->hdev->le_conn_min_interval;\n\t\tconn->le_conn_max_interval = conn->hdev->le_conn_max_interval;\n\t}\n}\n\nstatic void le_conn_complete_evt(struct hci_dev *hdev, u8 status,\n\t\t\t\t bdaddr_t *bdaddr, u8 bdaddr_type,\n\t\t\t\t bdaddr_t *local_rpa, u8 role, u16 handle,\n\t\t\t\t u16 interval, u16 latency,\n\t\t\t\t u16 supervision_timeout)\n{\n\tstruct hci_conn_params *params;\n\tstruct hci_conn *conn;\n\tstruct smp_irk *irk;\n\tu8 addr_type;\n\n\thci_dev_lock(hdev);\n\n\t \n\thci_dev_clear_flag(hdev, HCI_LE_ADV);\n\n\tconn = hci_conn_hash_lookup_ba(hdev, LE_LINK, bdaddr);\n\tif (!conn) {\n\t\t \n\t\tif (status)\n\t\t\tgoto unlock;\n\n\t\tconn = hci_conn_add_unset(hdev, LE_LINK, bdaddr, role);\n\t\tif (!conn) {\n\t\t\tbt_dev_err(hdev, \"no memory for new connection\");\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tconn->dst_type = bdaddr_type;\n\n\t\t \n\t\tif (conn->out) {\n\t\t\tconn->resp_addr_type = bdaddr_type;\n\t\t\tbacpy(&conn->resp_addr, bdaddr);\n\t\t\tif (hci_dev_test_flag(hdev, HCI_PRIVACY)) {\n\t\t\t\tconn->init_addr_type = ADDR_LE_DEV_RANDOM;\n\t\t\t\tbacpy(&conn->init_addr, &hdev->rpa);\n\t\t\t} else {\n\t\t\t\thci_copy_identity_address(hdev,\n\t\t\t\t\t\t\t  &conn->init_addr,\n\t\t\t\t\t\t\t  &conn->init_addr_type);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcancel_delayed_work(&conn->le_conn_timeout);\n\t}\n\n\t \n\tif (!HCI_CONN_HANDLE_UNSET(conn->handle)) {\n\t\tbt_dev_err(hdev, \"Ignoring HCI_Connection_Complete for existing connection\");\n\t\tgoto unlock;\n\t}\n\n\tle_conn_update_addr(conn, bdaddr, bdaddr_type, local_rpa);\n\n\t \n\tirk = hci_get_irk(hdev, &conn->dst, conn->dst_type);\n\tif (irk) {\n\t\tbacpy(&conn->dst, &irk->bdaddr);\n\t\tconn->dst_type = irk->addr_type;\n\t}\n\n\tconn->dst_type = ev_bdaddr_type(hdev, conn->dst_type, NULL);\n\n\t \n\tif (status || hci_conn_set_handle(conn, handle))\n\t\tgoto unlock;\n\n\t \n\tif (test_bit(HCI_CONN_CANCEL, &conn->flags)) {\n\t\thci_conn_drop(conn);\n\t\tgoto unlock;\n\t}\n\n\tif (conn->dst_type == ADDR_LE_DEV_PUBLIC)\n\t\taddr_type = BDADDR_LE_PUBLIC;\n\telse\n\t\taddr_type = BDADDR_LE_RANDOM;\n\n\t \n\tif (hci_bdaddr_list_lookup(&hdev->reject_list, &conn->dst, addr_type)) {\n\t\thci_conn_drop(conn);\n\t\tgoto unlock;\n\t}\n\n\tif (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))\n\t\tmgmt_device_connected(hdev, conn, NULL, 0);\n\n\tconn->sec_level = BT_SECURITY_LOW;\n\tconn->state = BT_CONFIG;\n\n\t \n\tif (!ext_adv_capable(hdev))\n\t\tconn->adv_instance = hdev->cur_adv_instance;\n\n\tconn->le_conn_interval = interval;\n\tconn->le_conn_latency = latency;\n\tconn->le_supv_timeout = supervision_timeout;\n\n\thci_debugfs_create_conn(conn);\n\thci_conn_add_sysfs(conn);\n\n\t \n\tif (conn->out ||\n\t    (hdev->le_features[0] & HCI_LE_PERIPHERAL_FEATURES)) {\n\t\tstruct hci_cp_le_read_remote_features cp;\n\n\t\tcp.handle = __cpu_to_le16(conn->handle);\n\n\t\thci_send_cmd(hdev, HCI_OP_LE_READ_REMOTE_FEATURES,\n\t\t\t     sizeof(cp), &cp);\n\n\t\thci_conn_hold(conn);\n\t} else {\n\t\tconn->state = BT_CONNECTED;\n\t\thci_connect_cfm(conn, status);\n\t}\n\n\tparams = hci_pend_le_action_lookup(&hdev->pend_le_conns, &conn->dst,\n\t\t\t\t\t   conn->dst_type);\n\tif (params) {\n\t\thci_pend_le_list_del_init(params);\n\t\tif (params->conn) {\n\t\t\thci_conn_drop(params->conn);\n\t\t\thci_conn_put(params->conn);\n\t\t\tparams->conn = NULL;\n\t\t}\n\t}\n\nunlock:\n\thci_update_passive_scan(hdev);\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_le_conn_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_le_conn_complete *ev = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\tle_conn_complete_evt(hdev, ev->status, &ev->bdaddr, ev->bdaddr_type,\n\t\t\t     NULL, ev->role, le16_to_cpu(ev->handle),\n\t\t\t     le16_to_cpu(ev->interval),\n\t\t\t     le16_to_cpu(ev->latency),\n\t\t\t     le16_to_cpu(ev->supervision_timeout));\n}\n\nstatic void hci_le_enh_conn_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_ev_le_enh_conn_complete *ev = data;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\tle_conn_complete_evt(hdev, ev->status, &ev->bdaddr, ev->bdaddr_type,\n\t\t\t     &ev->local_rpa, ev->role, le16_to_cpu(ev->handle),\n\t\t\t     le16_to_cpu(ev->interval),\n\t\t\t     le16_to_cpu(ev->latency),\n\t\t\t     le16_to_cpu(ev->supervision_timeout));\n}\n\nstatic void hci_le_ext_adv_term_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_evt_le_ext_adv_set_term *ev = data;\n\tstruct hci_conn *conn;\n\tstruct adv_info *adv, *n;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\t \n\tif (ev->status == HCI_ERROR_CANCELLED_BY_HOST) {\n\t\tbt_dev_warn_ratelimited(hdev, \"Unexpected advertising set terminated event\");\n\t\treturn;\n\t}\n\n\thci_dev_lock(hdev);\n\n\tadv = hci_find_adv_instance(hdev, ev->handle);\n\n\tif (ev->status) {\n\t\tif (!adv)\n\t\t\tgoto unlock;\n\n\t\t \n\t\thci_remove_adv_instance(hdev, ev->handle);\n\t\tmgmt_advertising_removed(NULL, hdev, ev->handle);\n\n\t\tlist_for_each_entry_safe(adv, n, &hdev->adv_instances, list) {\n\t\t\tif (adv->enabled)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\t \n\t\thci_dev_clear_flag(hdev, HCI_LE_ADV);\n\t\tgoto unlock;\n\t}\n\n\tif (adv)\n\t\tadv->enabled = false;\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->conn_handle));\n\tif (conn) {\n\t\t \n\t\tconn->adv_instance = ev->handle;\n\n\t\tif (hdev->adv_addr_type != ADDR_LE_DEV_RANDOM ||\n\t\t    bacmp(&conn->resp_addr, BDADDR_ANY))\n\t\t\tgoto unlock;\n\n\t\tif (!ev->handle) {\n\t\t\tbacpy(&conn->resp_addr, &hdev->random_addr);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (adv)\n\t\t\tbacpy(&conn->resp_addr, &adv->random_addr);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_le_conn_update_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_le_conn_update_complete *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\tif (ev->status)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (conn) {\n\t\tconn->le_conn_interval = le16_to_cpu(ev->interval);\n\t\tconn->le_conn_latency = le16_to_cpu(ev->latency);\n\t\tconn->le_supv_timeout = le16_to_cpu(ev->supervision_timeout);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\n \nstatic struct hci_conn *check_pending_le_conn(struct hci_dev *hdev,\n\t\t\t\t\t      bdaddr_t *addr,\n\t\t\t\t\t      u8 addr_type, bool addr_resolved,\n\t\t\t\t\t      u8 adv_type)\n{\n\tstruct hci_conn *conn;\n\tstruct hci_conn_params *params;\n\n\t \n\tif (adv_type != LE_ADV_IND && adv_type != LE_ADV_DIRECT_IND)\n\t\treturn NULL;\n\n\t \n\tif (hci_bdaddr_list_lookup(&hdev->reject_list, addr, addr_type) ||\n\t    hdev->suspended)\n\t\treturn NULL;\n\n\t \n\tif (hdev->conn_hash.le_num_peripheral > 0 &&\n\t    (!test_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks) ||\n\t     !(hdev->le_states[3] & 0x10)))\n\t\treturn NULL;\n\n\t \n\tparams = hci_pend_le_action_lookup(&hdev->pend_le_conns, addr,\n\t\t\t\t\t   addr_type);\n\tif (!params)\n\t\treturn NULL;\n\n\tif (!params->explicit_connect) {\n\t\tswitch (params->auto_connect) {\n\t\tcase HCI_AUTO_CONN_DIRECT:\n\t\t\t \n\t\t\tif (adv_type != LE_ADV_DIRECT_IND)\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\t\tcase HCI_AUTO_CONN_ALWAYS:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tconn = hci_connect_le(hdev, addr, addr_type, addr_resolved,\n\t\t\t      BT_SECURITY_LOW, hdev->def_le_autoconnect_timeout,\n\t\t\t      HCI_ROLE_MASTER);\n\tif (!IS_ERR(conn)) {\n\t\t \n\n\t\tif (!params->explicit_connect)\n\t\t\tparams->conn = hci_conn_get(conn);\n\n\t\treturn conn;\n\t}\n\n\tswitch (PTR_ERR(conn)) {\n\tcase -EBUSY:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tBT_DBG(\"Failed to connect: err %ld\", PTR_ERR(conn));\n\t\treturn NULL;\n\t}\n\n\treturn NULL;\n}\n\nstatic void process_adv_report(struct hci_dev *hdev, u8 type, bdaddr_t *bdaddr,\n\t\t\t       u8 bdaddr_type, bdaddr_t *direct_addr,\n\t\t\t       u8 direct_addr_type, s8 rssi, u8 *data, u8 len,\n\t\t\t       bool ext_adv, bool ctl_time, u64 instant)\n{\n\tstruct discovery_state *d = &hdev->discovery;\n\tstruct smp_irk *irk;\n\tstruct hci_conn *conn;\n\tbool match, bdaddr_resolved;\n\tu32 flags;\n\tu8 *ptr;\n\n\tswitch (type) {\n\tcase LE_ADV_IND:\n\tcase LE_ADV_DIRECT_IND:\n\tcase LE_ADV_SCAN_IND:\n\tcase LE_ADV_NONCONN_IND:\n\tcase LE_ADV_SCAN_RSP:\n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err_ratelimited(hdev, \"unknown advertising packet \"\n\t\t\t\t       \"type: 0x%02x\", type);\n\t\treturn;\n\t}\n\n\tif (len > max_adv_len(hdev)) {\n\t\tbt_dev_err_ratelimited(hdev,\n\t\t\t\t       \"adv larger than maximum supported\");\n\t\treturn;\n\t}\n\n\t \n\tfor (ptr = data; ptr < data + len && *ptr; ptr += *ptr + 1) {\n\t\tif (ptr + 1 + *ptr > data + len)\n\t\t\tbreak;\n\t}\n\n\t \n\tlen = ptr - data;\n\n\t \n\tif (!hci_dev_test_flag(hdev, HCI_MESH) && direct_addr) {\n\t\tdirect_addr_type = ev_bdaddr_type(hdev, direct_addr_type,\n\t\t\t\t\t\t  &bdaddr_resolved);\n\n\t\t \n\t\tif (!hci_bdaddr_is_rpa(direct_addr, direct_addr_type))\n\t\t\treturn;\n\n\t\t \n\t\tif (!hci_dev_test_flag(hdev, HCI_PRIVACY))\n\t\t\treturn;\n\n\t\t \n\t\tif (!smp_irk_matches(hdev, hdev->irk, direct_addr))\n\t\t\treturn;\n\t}\n\n\t \n\tirk = hci_get_irk(hdev, bdaddr, bdaddr_type);\n\tif (irk) {\n\t\tbdaddr = &irk->bdaddr;\n\t\tbdaddr_type = irk->addr_type;\n\t}\n\n\tbdaddr_type = ev_bdaddr_type(hdev, bdaddr_type, &bdaddr_resolved);\n\n\t \n\tconn = check_pending_le_conn(hdev, bdaddr, bdaddr_type, bdaddr_resolved,\n\t\t\t\t     type);\n\tif (!ext_adv && conn && type == LE_ADV_IND &&\n\t    len <= max_adv_len(hdev)) {\n\t\t \n\t\tmemcpy(conn->le_adv_data, data, len);\n\t\tconn->le_adv_data_len = len;\n\t}\n\n\tif (type == LE_ADV_NONCONN_IND || type == LE_ADV_SCAN_IND)\n\t\tflags = MGMT_DEV_FOUND_NOT_CONNECTABLE;\n\telse\n\t\tflags = 0;\n\n\t \n\tif (hci_dev_test_flag(hdev, HCI_MESH)) {\n\t\tmgmt_device_found(hdev, bdaddr, LE_LINK, bdaddr_type, NULL,\n\t\t\t\t  rssi, flags, data, len, NULL, 0, instant);\n\t\treturn;\n\t}\n\n\t \n\tif (hdev->le_scan_type == LE_SCAN_PASSIVE) {\n\t\tif (type == LE_ADV_DIRECT_IND)\n\t\t\treturn;\n\n\t\tif (!hci_pend_le_action_lookup(&hdev->pend_le_reports,\n\t\t\t\t\t       bdaddr, bdaddr_type) &&\n\t\t    idr_is_empty(&hdev->adv_monitors_idr))\n\t\t\treturn;\n\n\t\tmgmt_device_found(hdev, bdaddr, LE_LINK, bdaddr_type, NULL,\n\t\t\t\t  rssi, flags, data, len, NULL, 0, 0);\n\t\treturn;\n\t}\n\n\t \n\tif (type == LE_ADV_SCAN_RSP)\n\t\tflags = MGMT_DEV_FOUND_SCAN_RSP;\n\n\t \n\tif (!ext_adv &&\t!has_pending_adv_report(hdev)) {\n\t\t \n\t\tif (type == LE_ADV_IND || type == LE_ADV_SCAN_IND) {\n\t\t\tstore_pending_adv_report(hdev, bdaddr, bdaddr_type,\n\t\t\t\t\t\t rssi, flags, data, len);\n\t\t\treturn;\n\t\t}\n\n\t\tmgmt_device_found(hdev, bdaddr, LE_LINK, bdaddr_type, NULL,\n\t\t\t\t  rssi, flags, data, len, NULL, 0, 0);\n\t\treturn;\n\t}\n\n\t \n\tmatch = (!bacmp(bdaddr, &d->last_adv_addr) &&\n\t\t bdaddr_type == d->last_adv_addr_type);\n\n\t \n\tif (type != LE_ADV_SCAN_RSP || !match) {\n\t\t \n\t\tif (!match)\n\t\t\tmgmt_device_found(hdev, &d->last_adv_addr, LE_LINK,\n\t\t\t\t\t  d->last_adv_addr_type, NULL,\n\t\t\t\t\t  d->last_adv_rssi, d->last_adv_flags,\n\t\t\t\t\t  d->last_adv_data,\n\t\t\t\t\t  d->last_adv_data_len, NULL, 0, 0);\n\n\t\t \n\t\tif (!ext_adv && (type == LE_ADV_IND ||\n\t\t\t\t type == LE_ADV_SCAN_IND)) {\n\t\t\tstore_pending_adv_report(hdev, bdaddr, bdaddr_type,\n\t\t\t\t\t\t rssi, flags, data, len);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tclear_pending_adv_report(hdev);\n\t\tmgmt_device_found(hdev, bdaddr, LE_LINK, bdaddr_type, NULL,\n\t\t\t\t  rssi, flags, data, len, NULL, 0, 0);\n\t\treturn;\n\t}\n\n\t \n\tmgmt_device_found(hdev, &d->last_adv_addr, LE_LINK,\n\t\t\t  d->last_adv_addr_type, NULL, rssi, d->last_adv_flags,\n\t\t\t  d->last_adv_data, d->last_adv_data_len, data, len, 0);\n\tclear_pending_adv_report(hdev);\n}\n\nstatic void hci_le_adv_report_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_le_advertising_report *ev = data;\n\tu64 instant = jiffies;\n\n\tif (!ev->num)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\twhile (ev->num--) {\n\t\tstruct hci_ev_le_advertising_info *info;\n\t\ts8 rssi;\n\n\t\tinfo = hci_le_ev_skb_pull(hdev, skb,\n\t\t\t\t\t  HCI_EV_LE_ADVERTISING_REPORT,\n\t\t\t\t\t  sizeof(*info));\n\t\tif (!info)\n\t\t\tbreak;\n\n\t\tif (!hci_le_ev_skb_pull(hdev, skb, HCI_EV_LE_ADVERTISING_REPORT,\n\t\t\t\t\tinfo->length + 1))\n\t\t\tbreak;\n\n\t\tif (info->length <= max_adv_len(hdev)) {\n\t\t\trssi = info->data[info->length];\n\t\t\tprocess_adv_report(hdev, info->type, &info->bdaddr,\n\t\t\t\t\t   info->bdaddr_type, NULL, 0, rssi,\n\t\t\t\t\t   info->data, info->length, false,\n\t\t\t\t\t   false, instant);\n\t\t} else {\n\t\t\tbt_dev_err(hdev, \"Dropping invalid advertising data\");\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic u8 ext_evt_type_to_legacy(struct hci_dev *hdev, u16 evt_type)\n{\n\tif (evt_type & LE_EXT_ADV_LEGACY_PDU) {\n\t\tswitch (evt_type) {\n\t\tcase LE_LEGACY_ADV_IND:\n\t\t\treturn LE_ADV_IND;\n\t\tcase LE_LEGACY_ADV_DIRECT_IND:\n\t\t\treturn LE_ADV_DIRECT_IND;\n\t\tcase LE_LEGACY_ADV_SCAN_IND:\n\t\t\treturn LE_ADV_SCAN_IND;\n\t\tcase LE_LEGACY_NONCONN_IND:\n\t\t\treturn LE_ADV_NONCONN_IND;\n\t\tcase LE_LEGACY_SCAN_RSP_ADV:\n\t\tcase LE_LEGACY_SCAN_RSP_ADV_SCAN:\n\t\t\treturn LE_ADV_SCAN_RSP;\n\t\t}\n\n\t\tgoto invalid;\n\t}\n\n\tif (evt_type & LE_EXT_ADV_CONN_IND) {\n\t\tif (evt_type & LE_EXT_ADV_DIRECT_IND)\n\t\t\treturn LE_ADV_DIRECT_IND;\n\n\t\treturn LE_ADV_IND;\n\t}\n\n\tif (evt_type & LE_EXT_ADV_SCAN_RSP)\n\t\treturn LE_ADV_SCAN_RSP;\n\n\tif (evt_type & LE_EXT_ADV_SCAN_IND)\n\t\treturn LE_ADV_SCAN_IND;\n\n\tif (evt_type == LE_EXT_ADV_NON_CONN_IND ||\n\t    evt_type & LE_EXT_ADV_DIRECT_IND)\n\t\treturn LE_ADV_NONCONN_IND;\n\ninvalid:\n\tbt_dev_err_ratelimited(hdev, \"Unknown advertising packet type: 0x%02x\",\n\t\t\t       evt_type);\n\n\treturn LE_ADV_INVALID;\n}\n\nstatic void hci_le_ext_adv_report_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_ev_le_ext_adv_report *ev = data;\n\tu64 instant = jiffies;\n\n\tif (!ev->num)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\twhile (ev->num--) {\n\t\tstruct hci_ev_le_ext_adv_info *info;\n\t\tu8 legacy_evt_type;\n\t\tu16 evt_type;\n\n\t\tinfo = hci_le_ev_skb_pull(hdev, skb, HCI_EV_LE_EXT_ADV_REPORT,\n\t\t\t\t\t  sizeof(*info));\n\t\tif (!info)\n\t\t\tbreak;\n\n\t\tif (!hci_le_ev_skb_pull(hdev, skb, HCI_EV_LE_EXT_ADV_REPORT,\n\t\t\t\t\tinfo->length))\n\t\t\tbreak;\n\n\t\tevt_type = __le16_to_cpu(info->type) & LE_EXT_ADV_EVT_TYPE_MASK;\n\t\tlegacy_evt_type = ext_evt_type_to_legacy(hdev, evt_type);\n\t\tif (legacy_evt_type != LE_ADV_INVALID) {\n\t\t\tprocess_adv_report(hdev, legacy_evt_type, &info->bdaddr,\n\t\t\t\t\t   info->bdaddr_type, NULL, 0,\n\t\t\t\t\t   info->rssi, info->data, info->length,\n\t\t\t\t\t   !(evt_type & LE_EXT_ADV_LEGACY_PDU),\n\t\t\t\t\t   false, instant);\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic int hci_le_pa_term_sync(struct hci_dev *hdev, __le16 handle)\n{\n\tstruct hci_cp_le_pa_term_sync cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.handle = handle;\n\n\treturn hci_send_cmd(hdev, HCI_OP_LE_PA_TERM_SYNC, sizeof(cp), &cp);\n}\n\nstatic void hci_le_pa_sync_estabilished_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_le_pa_sync_established *ev = data;\n\tint mask = hdev->link_mode;\n\t__u8 flags = 0;\n\tstruct hci_conn *pa_sync;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\thci_dev_clear_flag(hdev, HCI_PA_SYNC);\n\n\tmask |= hci_proto_connect_ind(hdev, &ev->bdaddr, ISO_LINK, &flags);\n\tif (!(mask & HCI_LM_ACCEPT)) {\n\t\thci_le_pa_term_sync(hdev, ev->handle);\n\t\tgoto unlock;\n\t}\n\n\tif (!(flags & HCI_PROTO_DEFER))\n\t\tgoto unlock;\n\n\tif (ev->status) {\n\t\t \n\t\tpa_sync = hci_conn_add_unset(hdev, ISO_LINK, BDADDR_ANY,\n\t\t\t\t\t     HCI_ROLE_SLAVE);\n\n\t\tif (!pa_sync)\n\t\t\tgoto unlock;\n\n\t\tset_bit(HCI_CONN_PA_SYNC_FAILED, &pa_sync->flags);\n\n\t\t \n\t\thci_connect_cfm(pa_sync, ev->status);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_le_per_adv_report_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hci_ev_le_per_adv_report *ev = data;\n\tint mask = hdev->link_mode;\n\t__u8 flags = 0;\n\n\tbt_dev_dbg(hdev, \"sync_handle 0x%4.4x\", le16_to_cpu(ev->sync_handle));\n\n\thci_dev_lock(hdev);\n\n\tmask |= hci_proto_connect_ind(hdev, BDADDR_ANY, ISO_LINK, &flags);\n\tif (!(mask & HCI_LM_ACCEPT))\n\t\thci_le_pa_term_sync(hdev, ev->sync_handle);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_le_remote_feat_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_ev_le_remote_feat_complete *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (conn) {\n\t\tif (!ev->status)\n\t\t\tmemcpy(conn->features[0], ev->features, 8);\n\n\t\tif (conn->state == BT_CONFIG) {\n\t\t\t__u8 status;\n\n\t\t\t \n\t\t\tif (!conn->out && ev->status == 0x1a &&\n\t\t\t    (hdev->le_features[0] & HCI_LE_PERIPHERAL_FEATURES))\n\t\t\t\tstatus = 0x00;\n\t\t\telse\n\t\t\t\tstatus = ev->status;\n\n\t\t\tconn->state = BT_CONNECTED;\n\t\t\thci_connect_cfm(conn, status);\n\t\t\thci_conn_drop(conn);\n\t\t}\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_le_ltk_request_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_ev_le_ltk_req *ev = data;\n\tstruct hci_cp_le_ltk_reply cp;\n\tstruct hci_cp_le_ltk_neg_reply neg;\n\tstruct hci_conn *conn;\n\tstruct smp_ltk *ltk;\n\n\tbt_dev_dbg(hdev, \"handle 0x%4.4x\", __le16_to_cpu(ev->handle));\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (conn == NULL)\n\t\tgoto not_found;\n\n\tltk = hci_find_ltk(hdev, &conn->dst, conn->dst_type, conn->role);\n\tif (!ltk)\n\t\tgoto not_found;\n\n\tif (smp_ltk_is_sc(ltk)) {\n\t\t \n\t\tif (ev->ediv || ev->rand)\n\t\t\tgoto not_found;\n\t} else {\n\t\t \n\t\tif (ev->ediv != ltk->ediv || ev->rand != ltk->rand)\n\t\t\tgoto not_found;\n\t}\n\n\tmemcpy(cp.ltk, ltk->val, ltk->enc_size);\n\tmemset(cp.ltk + ltk->enc_size, 0, sizeof(cp.ltk) - ltk->enc_size);\n\tcp.handle = cpu_to_le16(conn->handle);\n\n\tconn->pending_sec_level = smp_ltk_sec_level(ltk);\n\n\tconn->enc_key_size = ltk->enc_size;\n\n\thci_send_cmd(hdev, HCI_OP_LE_LTK_REPLY, sizeof(cp), &cp);\n\n\t \n\tif (ltk->type == SMP_STK) {\n\t\tset_bit(HCI_CONN_STK_ENCRYPT, &conn->flags);\n\t\tlist_del_rcu(&ltk->list);\n\t\tkfree_rcu(ltk, rcu);\n\t} else {\n\t\tclear_bit(HCI_CONN_STK_ENCRYPT, &conn->flags);\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn;\n\nnot_found:\n\tneg.handle = ev->handle;\n\thci_send_cmd(hdev, HCI_OP_LE_LTK_NEG_REPLY, sizeof(neg), &neg);\n\thci_dev_unlock(hdev);\n}\n\nstatic void send_conn_param_neg_reply(struct hci_dev *hdev, u16 handle,\n\t\t\t\t      u8 reason)\n{\n\tstruct hci_cp_le_conn_param_req_neg_reply cp;\n\n\tcp.handle = cpu_to_le16(handle);\n\tcp.reason = reason;\n\n\thci_send_cmd(hdev, HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, sizeof(cp),\n\t\t     &cp);\n}\n\nstatic void hci_le_remote_conn_param_req_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_ev_le_remote_conn_param_req *ev = data;\n\tstruct hci_cp_le_conn_param_req_reply cp;\n\tstruct hci_conn *hcon;\n\tu16 handle, min, max, latency, timeout;\n\n\tbt_dev_dbg(hdev, \"handle 0x%4.4x\", __le16_to_cpu(ev->handle));\n\n\thandle = le16_to_cpu(ev->handle);\n\tmin = le16_to_cpu(ev->interval_min);\n\tmax = le16_to_cpu(ev->interval_max);\n\tlatency = le16_to_cpu(ev->latency);\n\ttimeout = le16_to_cpu(ev->timeout);\n\n\thcon = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (!hcon || hcon->state != BT_CONNECTED)\n\t\treturn send_conn_param_neg_reply(hdev, handle,\n\t\t\t\t\t\t HCI_ERROR_UNKNOWN_CONN_ID);\n\n\tif (hci_check_conn_params(min, max, latency, timeout))\n\t\treturn send_conn_param_neg_reply(hdev, handle,\n\t\t\t\t\t\t HCI_ERROR_INVALID_LL_PARAMS);\n\n\tif (hcon->role == HCI_ROLE_MASTER) {\n\t\tstruct hci_conn_params *params;\n\t\tu8 store_hint;\n\n\t\thci_dev_lock(hdev);\n\n\t\tparams = hci_conn_params_lookup(hdev, &hcon->dst,\n\t\t\t\t\t\thcon->dst_type);\n\t\tif (params) {\n\t\t\tparams->conn_min_interval = min;\n\t\t\tparams->conn_max_interval = max;\n\t\t\tparams->conn_latency = latency;\n\t\t\tparams->supervision_timeout = timeout;\n\t\t\tstore_hint = 0x01;\n\t\t} else {\n\t\t\tstore_hint = 0x00;\n\t\t}\n\n\t\thci_dev_unlock(hdev);\n\n\t\tmgmt_new_conn_param(hdev, &hcon->dst, hcon->dst_type,\n\t\t\t\t    store_hint, min, max, latency, timeout);\n\t}\n\n\tcp.handle = ev->handle;\n\tcp.interval_min = ev->interval_min;\n\tcp.interval_max = ev->interval_max;\n\tcp.latency = ev->latency;\n\tcp.timeout = ev->timeout;\n\tcp.min_ce_len = 0;\n\tcp.max_ce_len = 0;\n\n\thci_send_cmd(hdev, HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(cp), &cp);\n}\n\nstatic void hci_le_direct_adv_report_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_ev_le_direct_adv_report *ev = data;\n\tu64 instant = jiffies;\n\tint i;\n\n\tif (!hci_le_ev_skb_pull(hdev, skb, HCI_EV_LE_DIRECT_ADV_REPORT,\n\t\t\t\tflex_array_size(ev, info, ev->num)))\n\t\treturn;\n\n\tif (!ev->num)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (i = 0; i < ev->num; i++) {\n\t\tstruct hci_ev_le_direct_adv_info *info = &ev->info[i];\n\n\t\tprocess_adv_report(hdev, info->type, &info->bdaddr,\n\t\t\t\t   info->bdaddr_type, &info->direct_addr,\n\t\t\t\t   info->direct_addr_type, info->rssi, NULL, 0,\n\t\t\t\t   false, false, instant);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_le_phy_update_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_le_phy_update_complete *ev = data;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\tif (ev->status)\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tconn->le_tx_phy = ev->tx_phy;\n\tconn->le_rx_phy = ev->rx_phy;\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_le_cis_estabilished_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_evt_le_cis_established *ev = data;\n\tstruct hci_conn *conn;\n\tstruct bt_iso_qos *qos;\n\tbool pending = false;\n\tu16 handle = __le16_to_cpu(ev->handle);\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (!conn) {\n\t\tbt_dev_err(hdev,\n\t\t\t   \"Unable to find connection with handle 0x%4.4x\",\n\t\t\t   handle);\n\t\tgoto unlock;\n\t}\n\n\tif (conn->type != ISO_LINK) {\n\t\tbt_dev_err(hdev,\n\t\t\t   \"Invalid connection link type handle 0x%4.4x\",\n\t\t\t   handle);\n\t\tgoto unlock;\n\t}\n\n\tqos = &conn->iso_qos;\n\n\tpending = test_and_clear_bit(HCI_CONN_CREATE_CIS, &conn->flags);\n\n\t \n\tqos->ucast.in.interval = le16_to_cpu(ev->interval) * 1250;\n\tqos->ucast.out.interval = qos->ucast.in.interval;\n\n\tswitch (conn->role) {\n\tcase HCI_ROLE_SLAVE:\n\t\t \n\t\tqos->ucast.in.latency =\n\t\t\tDIV_ROUND_CLOSEST(get_unaligned_le24(ev->c_latency),\n\t\t\t\t\t  1000);\n\t\tqos->ucast.out.latency =\n\t\t\tDIV_ROUND_CLOSEST(get_unaligned_le24(ev->p_latency),\n\t\t\t\t\t  1000);\n\t\tqos->ucast.in.sdu = le16_to_cpu(ev->c_mtu);\n\t\tqos->ucast.out.sdu = le16_to_cpu(ev->p_mtu);\n\t\tqos->ucast.in.phy = ev->c_phy;\n\t\tqos->ucast.out.phy = ev->p_phy;\n\t\tbreak;\n\tcase HCI_ROLE_MASTER:\n\t\t \n\t\tqos->ucast.out.latency =\n\t\t\tDIV_ROUND_CLOSEST(get_unaligned_le24(ev->c_latency),\n\t\t\t\t\t  1000);\n\t\tqos->ucast.in.latency =\n\t\t\tDIV_ROUND_CLOSEST(get_unaligned_le24(ev->p_latency),\n\t\t\t\t\t  1000);\n\t\tqos->ucast.out.sdu = le16_to_cpu(ev->c_mtu);\n\t\tqos->ucast.in.sdu = le16_to_cpu(ev->p_mtu);\n\t\tqos->ucast.out.phy = ev->c_phy;\n\t\tqos->ucast.in.phy = ev->p_phy;\n\t\tbreak;\n\t}\n\n\tif (!ev->status) {\n\t\tconn->state = BT_CONNECTED;\n\t\thci_debugfs_create_conn(conn);\n\t\thci_conn_add_sysfs(conn);\n\t\thci_iso_setup_path(conn);\n\t\tgoto unlock;\n\t}\n\n\tconn->state = BT_CLOSED;\n\thci_connect_cfm(conn, ev->status);\n\thci_conn_del(conn);\n\nunlock:\n\tif (pending)\n\t\thci_le_create_cis_pending(hdev);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_le_reject_cis(struct hci_dev *hdev, __le16 handle)\n{\n\tstruct hci_cp_le_reject_cis cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.handle = handle;\n\tcp.reason = HCI_ERROR_REJ_BAD_ADDR;\n\thci_send_cmd(hdev, HCI_OP_LE_REJECT_CIS, sizeof(cp), &cp);\n}\n\nstatic void hci_le_accept_cis(struct hci_dev *hdev, __le16 handle)\n{\n\tstruct hci_cp_le_accept_cis cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.handle = handle;\n\thci_send_cmd(hdev, HCI_OP_LE_ACCEPT_CIS, sizeof(cp), &cp);\n}\n\nstatic void hci_le_cis_req_evt(struct hci_dev *hdev, void *data,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_evt_le_cis_req *ev = data;\n\tu16 acl_handle, cis_handle;\n\tstruct hci_conn *acl, *cis;\n\tint mask;\n\t__u8 flags = 0;\n\n\tacl_handle = __le16_to_cpu(ev->acl_handle);\n\tcis_handle = __le16_to_cpu(ev->cis_handle);\n\n\tbt_dev_dbg(hdev, \"acl 0x%4.4x handle 0x%4.4x cig 0x%2.2x cis 0x%2.2x\",\n\t\t   acl_handle, cis_handle, ev->cig_id, ev->cis_id);\n\n\thci_dev_lock(hdev);\n\n\tacl = hci_conn_hash_lookup_handle(hdev, acl_handle);\n\tif (!acl)\n\t\tgoto unlock;\n\n\tmask = hci_proto_connect_ind(hdev, &acl->dst, ISO_LINK, &flags);\n\tif (!(mask & HCI_LM_ACCEPT)) {\n\t\thci_le_reject_cis(hdev, ev->cis_handle);\n\t\tgoto unlock;\n\t}\n\n\tcis = hci_conn_hash_lookup_handle(hdev, cis_handle);\n\tif (!cis) {\n\t\tcis = hci_conn_add(hdev, ISO_LINK, &acl->dst, HCI_ROLE_SLAVE,\n\t\t\t\t   cis_handle);\n\t\tif (!cis) {\n\t\t\thci_le_reject_cis(hdev, ev->cis_handle);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tcis->iso_qos.ucast.cig = ev->cig_id;\n\tcis->iso_qos.ucast.cis = ev->cis_id;\n\n\tif (!(flags & HCI_PROTO_DEFER)) {\n\t\thci_le_accept_cis(hdev, ev->cis_handle);\n\t} else {\n\t\tcis->state = BT_CONNECT2;\n\t\thci_connect_cfm(cis, 0);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int hci_iso_term_big_sync(struct hci_dev *hdev, void *data)\n{\n\tu8 handle = PTR_UINT(data);\n\n\treturn hci_le_terminate_big_sync(hdev, handle,\n\t\t\t\t\t HCI_ERROR_LOCAL_HOST_TERM);\n}\n\nstatic void hci_le_create_big_complete_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_evt_le_create_big_complete *ev = data;\n\tstruct hci_conn *conn;\n\t__u8 i = 0;\n\n\tBT_DBG(\"%s status 0x%2.2x\", hdev->name, ev->status);\n\n\tif (!hci_le_ev_skb_pull(hdev, skb, HCI_EVT_LE_CREATE_BIG_COMPLETE,\n\t\t\t\tflex_array_size(ev, bis_handle, ev->num_bis)))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\trcu_read_lock();\n\n\t \n\tlist_for_each_entry_rcu(conn, &hdev->conn_hash.list, list) {\n\t\tif (bacmp(&conn->dst, BDADDR_ANY) ||\n\t\t    conn->type != ISO_LINK ||\n\t\t    conn->iso_qos.bcast.big != ev->handle)\n\t\t\tcontinue;\n\n\t\tif (hci_conn_set_handle(conn,\n\t\t\t\t\t__le16_to_cpu(ev->bis_handle[i++])))\n\t\t\tcontinue;\n\n\t\tif (!ev->status) {\n\t\t\tconn->state = BT_CONNECTED;\n\t\t\tset_bit(HCI_CONN_BIG_CREATED, &conn->flags);\n\t\t\trcu_read_unlock();\n\t\t\thci_debugfs_create_conn(conn);\n\t\t\thci_conn_add_sysfs(conn);\n\t\t\thci_iso_setup_path(conn);\n\t\t\trcu_read_lock();\n\t\t\tcontinue;\n\t\t}\n\n\t\thci_connect_cfm(conn, ev->status);\n\t\trcu_read_unlock();\n\t\thci_conn_del(conn);\n\t\trcu_read_lock();\n\t}\n\n\trcu_read_unlock();\n\n\tif (!ev->status && !i)\n\t\t \n\t\thci_cmd_sync_queue(hdev, hci_iso_term_big_sync,\n\t\t\t\t   UINT_PTR(ev->handle), NULL);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_le_big_sync_established_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct hci_evt_le_big_sync_estabilished *ev = data;\n\tstruct hci_conn *bis;\n\tstruct hci_conn *pa_sync;\n\tint i;\n\n\tbt_dev_dbg(hdev, \"status 0x%2.2x\", ev->status);\n\n\tif (!hci_le_ev_skb_pull(hdev, skb, HCI_EVT_LE_BIG_SYNC_ESTABILISHED,\n\t\t\t\tflex_array_size(ev, bis, ev->num_bis)))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tif (!ev->status) {\n\t\tpa_sync = hci_conn_hash_lookup_pa_sync_big_handle(hdev, ev->handle);\n\t\tif (pa_sync)\n\t\t\t \n\t\t\tset_bit(HCI_CONN_BIG_SYNC, &pa_sync->flags);\n\t}\n\n\tfor (i = 0; i < ev->num_bis; i++) {\n\t\tu16 handle = le16_to_cpu(ev->bis[i]);\n\t\t__le32 interval;\n\n\t\tbis = hci_conn_hash_lookup_handle(hdev, handle);\n\t\tif (!bis) {\n\t\t\tbis = hci_conn_add(hdev, ISO_LINK, BDADDR_ANY,\n\t\t\t\t\t   HCI_ROLE_SLAVE, handle);\n\t\t\tif (!bis)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (ev->status != 0x42)\n\t\t\t \n\t\t\tset_bit(HCI_CONN_PA_SYNC, &bis->flags);\n\n\t\tbis->iso_qos.bcast.big = ev->handle;\n\t\tmemset(&interval, 0, sizeof(interval));\n\t\tmemcpy(&interval, ev->latency, sizeof(ev->latency));\n\t\tbis->iso_qos.bcast.in.interval = le32_to_cpu(interval);\n\t\t \n\t\tbis->iso_qos.bcast.in.latency = le16_to_cpu(ev->interval) * 125 / 100;\n\t\tbis->iso_qos.bcast.in.sdu = le16_to_cpu(ev->max_pdu);\n\n\t\tif (!ev->status) {\n\t\t\tset_bit(HCI_CONN_BIG_SYNC, &bis->flags);\n\t\t\thci_iso_setup_path(bis);\n\t\t}\n\t}\n\n\t \n\tif (ev->status)\n\t\tfor (i = 0; i < ev->num_bis; i++) {\n\t\t\tu16 handle = le16_to_cpu(ev->bis[i]);\n\n\t\t\tbis = hci_conn_hash_lookup_handle(hdev, handle);\n\n\t\t\tset_bit(HCI_CONN_BIG_SYNC_FAILED, &bis->flags);\n\t\t\thci_connect_cfm(bis, ev->status);\n\t\t}\n\n\thci_dev_unlock(hdev);\n}\n\nstatic void hci_le_big_info_adv_report_evt(struct hci_dev *hdev, void *data,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct hci_evt_le_big_info_adv_report *ev = data;\n\tint mask = hdev->link_mode;\n\t__u8 flags = 0;\n\tstruct hci_conn *pa_sync;\n\n\tbt_dev_dbg(hdev, \"sync_handle 0x%4.4x\", le16_to_cpu(ev->sync_handle));\n\n\thci_dev_lock(hdev);\n\n\tmask |= hci_proto_connect_ind(hdev, BDADDR_ANY, ISO_LINK, &flags);\n\tif (!(mask & HCI_LM_ACCEPT)) {\n\t\thci_le_pa_term_sync(hdev, ev->sync_handle);\n\t\tgoto unlock;\n\t}\n\n\tif (!(flags & HCI_PROTO_DEFER))\n\t\tgoto unlock;\n\n\tpa_sync = hci_conn_hash_lookup_pa_sync_handle\n\t\t\t(hdev,\n\t\t\tle16_to_cpu(ev->sync_handle));\n\n\tif (pa_sync)\n\t\tgoto unlock;\n\n\t \n\tpa_sync = hci_conn_add_unset(hdev, ISO_LINK, BDADDR_ANY,\n\t\t\t\t     HCI_ROLE_SLAVE);\n\n\tif (!pa_sync)\n\t\tgoto unlock;\n\n\tpa_sync->sync_handle = le16_to_cpu(ev->sync_handle);\n\tset_bit(HCI_CONN_PA_SYNC, &pa_sync->flags);\n\n\t \n\thci_connect_cfm(pa_sync, 0x00);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\n#define HCI_LE_EV_VL(_op, _func, _min_len, _max_len) \\\n[_op] = { \\\n\t.func = _func, \\\n\t.min_len = _min_len, \\\n\t.max_len = _max_len, \\\n}\n\n#define HCI_LE_EV(_op, _func, _len) \\\n\tHCI_LE_EV_VL(_op, _func, _len, _len)\n\n#define HCI_LE_EV_STATUS(_op, _func) \\\n\tHCI_LE_EV(_op, _func, sizeof(struct hci_ev_status))\n\n \nstatic const struct hci_le_ev {\n\tvoid (*func)(struct hci_dev *hdev, void *data, struct sk_buff *skb);\n\tu16  min_len;\n\tu16  max_len;\n} hci_le_ev_table[U8_MAX + 1] = {\n\t \n\tHCI_LE_EV(HCI_EV_LE_CONN_COMPLETE, hci_le_conn_complete_evt,\n\t\t  sizeof(struct hci_ev_le_conn_complete)),\n\t \n\tHCI_LE_EV_VL(HCI_EV_LE_ADVERTISING_REPORT, hci_le_adv_report_evt,\n\t\t     sizeof(struct hci_ev_le_advertising_report),\n\t\t     HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_LE_EV(HCI_EV_LE_CONN_UPDATE_COMPLETE,\n\t\t  hci_le_conn_update_complete_evt,\n\t\t  sizeof(struct hci_ev_le_conn_update_complete)),\n\t \n\tHCI_LE_EV(HCI_EV_LE_REMOTE_FEAT_COMPLETE,\n\t\t  hci_le_remote_feat_complete_evt,\n\t\t  sizeof(struct hci_ev_le_remote_feat_complete)),\n\t \n\tHCI_LE_EV(HCI_EV_LE_LTK_REQ, hci_le_ltk_request_evt,\n\t\t  sizeof(struct hci_ev_le_ltk_req)),\n\t \n\tHCI_LE_EV(HCI_EV_LE_REMOTE_CONN_PARAM_REQ,\n\t\t  hci_le_remote_conn_param_req_evt,\n\t\t  sizeof(struct hci_ev_le_remote_conn_param_req)),\n\t \n\tHCI_LE_EV(HCI_EV_LE_ENHANCED_CONN_COMPLETE,\n\t\t  hci_le_enh_conn_complete_evt,\n\t\t  sizeof(struct hci_ev_le_enh_conn_complete)),\n\t \n\tHCI_LE_EV_VL(HCI_EV_LE_DIRECT_ADV_REPORT, hci_le_direct_adv_report_evt,\n\t\t     sizeof(struct hci_ev_le_direct_adv_report),\n\t\t     HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_LE_EV(HCI_EV_LE_PHY_UPDATE_COMPLETE, hci_le_phy_update_evt,\n\t\t  sizeof(struct hci_ev_le_phy_update_complete)),\n\t \n\tHCI_LE_EV_VL(HCI_EV_LE_EXT_ADV_REPORT, hci_le_ext_adv_report_evt,\n\t\t     sizeof(struct hci_ev_le_ext_adv_report),\n\t\t     HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_LE_EV(HCI_EV_LE_PA_SYNC_ESTABLISHED,\n\t\t  hci_le_pa_sync_estabilished_evt,\n\t\t  sizeof(struct hci_ev_le_pa_sync_established)),\n\t \n\tHCI_LE_EV_VL(HCI_EV_LE_PER_ADV_REPORT,\n\t\t\t\t hci_le_per_adv_report_evt,\n\t\t\t\t sizeof(struct hci_ev_le_per_adv_report),\n\t\t\t\t HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_LE_EV(HCI_EV_LE_EXT_ADV_SET_TERM, hci_le_ext_adv_term_evt,\n\t\t  sizeof(struct hci_evt_le_ext_adv_set_term)),\n\t \n\tHCI_LE_EV(HCI_EVT_LE_CIS_ESTABLISHED, hci_le_cis_estabilished_evt,\n\t\t  sizeof(struct hci_evt_le_cis_established)),\n\t \n\tHCI_LE_EV(HCI_EVT_LE_CIS_REQ, hci_le_cis_req_evt,\n\t\t  sizeof(struct hci_evt_le_cis_req)),\n\t \n\tHCI_LE_EV_VL(HCI_EVT_LE_CREATE_BIG_COMPLETE,\n\t\t     hci_le_create_big_complete_evt,\n\t\t     sizeof(struct hci_evt_le_create_big_complete),\n\t\t     HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_LE_EV_VL(HCI_EVT_LE_BIG_SYNC_ESTABILISHED,\n\t\t     hci_le_big_sync_established_evt,\n\t\t     sizeof(struct hci_evt_le_big_sync_estabilished),\n\t\t     HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_LE_EV_VL(HCI_EVT_LE_BIG_INFO_ADV_REPORT,\n\t\t     hci_le_big_info_adv_report_evt,\n\t\t     sizeof(struct hci_evt_le_big_info_adv_report),\n\t\t     HCI_MAX_EVENT_SIZE),\n};\n\nstatic void hci_le_meta_evt(struct hci_dev *hdev, void *data,\n\t\t\t    struct sk_buff *skb, u16 *opcode, u8 *status,\n\t\t\t    hci_req_complete_t *req_complete,\n\t\t\t    hci_req_complete_skb_t *req_complete_skb)\n{\n\tstruct hci_ev_le_meta *ev = data;\n\tconst struct hci_le_ev *subev;\n\n\tbt_dev_dbg(hdev, \"subevent 0x%2.2x\", ev->subevent);\n\n\t \n\tif (hdev->sent_cmd &&\n\t    hci_opcode_ogf(hci_skb_opcode(hdev->sent_cmd)) == 0x08 &&\n\t    hci_skb_event(hdev->sent_cmd) == ev->subevent) {\n\t\t*opcode = hci_skb_opcode(hdev->sent_cmd);\n\t\thci_req_cmd_complete(hdev, *opcode, 0x00, req_complete,\n\t\t\t\t     req_complete_skb);\n\t}\n\n\tsubev = &hci_le_ev_table[ev->subevent];\n\tif (!subev->func)\n\t\treturn;\n\n\tif (skb->len < subev->min_len) {\n\t\tbt_dev_err(hdev, \"unexpected subevent 0x%2.2x length: %u < %u\",\n\t\t\t   ev->subevent, skb->len, subev->min_len);\n\t\treturn;\n\t}\n\n\t \n\tif (skb->len > subev->max_len)\n\t\tbt_dev_warn(hdev, \"unexpected subevent 0x%2.2x length: %u > %u\",\n\t\t\t    ev->subevent, skb->len, subev->max_len);\n\tdata = hci_le_ev_skb_pull(hdev, skb, ev->subevent, subev->min_len);\n\tif (!data)\n\t\treturn;\n\n\tsubev->func(hdev, data, skb);\n}\n\nstatic bool hci_get_cmd_complete(struct hci_dev *hdev, u16 opcode,\n\t\t\t\t u8 event, struct sk_buff *skb)\n{\n\tstruct hci_ev_cmd_complete *ev;\n\tstruct hci_event_hdr *hdr;\n\n\tif (!skb)\n\t\treturn false;\n\n\thdr = hci_ev_skb_pull(hdev, skb, event, sizeof(*hdr));\n\tif (!hdr)\n\t\treturn false;\n\n\tif (event) {\n\t\tif (hdr->evt != event)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t \n\tif (hdr->evt == HCI_EV_CMD_STATUS)\n\t\treturn false;\n\n\tif (hdr->evt != HCI_EV_CMD_COMPLETE) {\n\t\tbt_dev_err(hdev, \"last event is not cmd complete (0x%2.2x)\",\n\t\t\t   hdr->evt);\n\t\treturn false;\n\t}\n\n\tev = hci_cc_skb_pull(hdev, skb, opcode, sizeof(*ev));\n\tif (!ev)\n\t\treturn false;\n\n\tif (opcode != __le16_to_cpu(ev->opcode)) {\n\t\tBT_DBG(\"opcode doesn't match (0x%2.2x != 0x%2.2x)\", opcode,\n\t\t       __le16_to_cpu(ev->opcode));\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void hci_store_wake_reason(struct hci_dev *hdev, u8 event,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_ev_le_advertising_info *adv;\n\tstruct hci_ev_le_direct_adv_info *direct_adv;\n\tstruct hci_ev_le_ext_adv_info *ext_adv;\n\tconst struct hci_ev_conn_complete *conn_complete = (void *)skb->data;\n\tconst struct hci_ev_conn_request *conn_request = (void *)skb->data;\n\n\thci_dev_lock(hdev);\n\n\t \n\tif (!hdev->suspended || hdev->wake_reason)\n\t\tgoto unlock;\n\n\t \n\thdev->wake_reason = MGMT_WAKE_REASON_REMOTE_WAKE;\n\n\t \n\tif (event == HCI_EV_CONN_REQUEST) {\n\t\tbacpy(&hdev->wake_addr, &conn_complete->bdaddr);\n\t\thdev->wake_addr_type = BDADDR_BREDR;\n\t} else if (event == HCI_EV_CONN_COMPLETE) {\n\t\tbacpy(&hdev->wake_addr, &conn_request->bdaddr);\n\t\thdev->wake_addr_type = BDADDR_BREDR;\n\t} else if (event == HCI_EV_LE_META) {\n\t\tstruct hci_ev_le_meta *le_ev = (void *)skb->data;\n\t\tu8 subevent = le_ev->subevent;\n\t\tu8 *ptr = &skb->data[sizeof(*le_ev)];\n\t\tu8 num_reports = *ptr;\n\n\t\tif ((subevent == HCI_EV_LE_ADVERTISING_REPORT ||\n\t\t     subevent == HCI_EV_LE_DIRECT_ADV_REPORT ||\n\t\t     subevent == HCI_EV_LE_EXT_ADV_REPORT) &&\n\t\t    num_reports) {\n\t\t\tadv = (void *)(ptr + 1);\n\t\t\tdirect_adv = (void *)(ptr + 1);\n\t\t\text_adv = (void *)(ptr + 1);\n\n\t\t\tswitch (subevent) {\n\t\t\tcase HCI_EV_LE_ADVERTISING_REPORT:\n\t\t\t\tbacpy(&hdev->wake_addr, &adv->bdaddr);\n\t\t\t\thdev->wake_addr_type = adv->bdaddr_type;\n\t\t\t\tbreak;\n\t\t\tcase HCI_EV_LE_DIRECT_ADV_REPORT:\n\t\t\t\tbacpy(&hdev->wake_addr, &direct_adv->bdaddr);\n\t\t\t\thdev->wake_addr_type = direct_adv->bdaddr_type;\n\t\t\t\tbreak;\n\t\t\tcase HCI_EV_LE_EXT_ADV_REPORT:\n\t\t\t\tbacpy(&hdev->wake_addr, &ext_adv->bdaddr);\n\t\t\t\thdev->wake_addr_type = ext_adv->bdaddr_type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\thdev->wake_reason = MGMT_WAKE_REASON_UNEXPECTED;\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\n#define HCI_EV_VL(_op, _func, _min_len, _max_len) \\\n[_op] = { \\\n\t.req = false, \\\n\t.func = _func, \\\n\t.min_len = _min_len, \\\n\t.max_len = _max_len, \\\n}\n\n#define HCI_EV(_op, _func, _len) \\\n\tHCI_EV_VL(_op, _func, _len, _len)\n\n#define HCI_EV_STATUS(_op, _func) \\\n\tHCI_EV(_op, _func, sizeof(struct hci_ev_status))\n\n#define HCI_EV_REQ_VL(_op, _func, _min_len, _max_len) \\\n[_op] = { \\\n\t.req = true, \\\n\t.func_req = _func, \\\n\t.min_len = _min_len, \\\n\t.max_len = _max_len, \\\n}\n\n#define HCI_EV_REQ(_op, _func, _len) \\\n\tHCI_EV_REQ_VL(_op, _func, _len, _len)\n\n \nstatic const struct hci_ev {\n\tbool req;\n\tunion {\n\t\tvoid (*func)(struct hci_dev *hdev, void *data,\n\t\t\t     struct sk_buff *skb);\n\t\tvoid (*func_req)(struct hci_dev *hdev, void *data,\n\t\t\t\t struct sk_buff *skb, u16 *opcode, u8 *status,\n\t\t\t\t hci_req_complete_t *req_complete,\n\t\t\t\t hci_req_complete_skb_t *req_complete_skb);\n\t};\n\tu16  min_len;\n\tu16  max_len;\n} hci_ev_table[U8_MAX + 1] = {\n\t \n\tHCI_EV_STATUS(HCI_EV_INQUIRY_COMPLETE, hci_inquiry_complete_evt),\n\t \n\tHCI_EV_VL(HCI_EV_INQUIRY_RESULT, hci_inquiry_result_evt,\n\t\t  sizeof(struct hci_ev_inquiry_result), HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_EV(HCI_EV_CONN_COMPLETE, hci_conn_complete_evt,\n\t       sizeof(struct hci_ev_conn_complete)),\n\t \n\tHCI_EV(HCI_EV_CONN_REQUEST, hci_conn_request_evt,\n\t       sizeof(struct hci_ev_conn_request)),\n\t \n\tHCI_EV(HCI_EV_DISCONN_COMPLETE, hci_disconn_complete_evt,\n\t       sizeof(struct hci_ev_disconn_complete)),\n\t \n\tHCI_EV(HCI_EV_AUTH_COMPLETE, hci_auth_complete_evt,\n\t       sizeof(struct hci_ev_auth_complete)),\n\t \n\tHCI_EV(HCI_EV_REMOTE_NAME, hci_remote_name_evt,\n\t       sizeof(struct hci_ev_remote_name)),\n\t \n\tHCI_EV(HCI_EV_ENCRYPT_CHANGE, hci_encrypt_change_evt,\n\t       sizeof(struct hci_ev_encrypt_change)),\n\t \n\tHCI_EV(HCI_EV_CHANGE_LINK_KEY_COMPLETE,\n\t       hci_change_link_key_complete_evt,\n\t       sizeof(struct hci_ev_change_link_key_complete)),\n\t \n\tHCI_EV(HCI_EV_REMOTE_FEATURES, hci_remote_features_evt,\n\t       sizeof(struct hci_ev_remote_features)),\n\t \n\tHCI_EV_REQ_VL(HCI_EV_CMD_COMPLETE, hci_cmd_complete_evt,\n\t\t      sizeof(struct hci_ev_cmd_complete), HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_EV_REQ(HCI_EV_CMD_STATUS, hci_cmd_status_evt,\n\t\t   sizeof(struct hci_ev_cmd_status)),\n\t \n\tHCI_EV(HCI_EV_HARDWARE_ERROR, hci_hardware_error_evt,\n\t       sizeof(struct hci_ev_hardware_error)),\n\t \n\tHCI_EV(HCI_EV_ROLE_CHANGE, hci_role_change_evt,\n\t       sizeof(struct hci_ev_role_change)),\n\t \n\tHCI_EV_VL(HCI_EV_NUM_COMP_PKTS, hci_num_comp_pkts_evt,\n\t\t  sizeof(struct hci_ev_num_comp_pkts), HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_EV(HCI_EV_MODE_CHANGE, hci_mode_change_evt,\n\t       sizeof(struct hci_ev_mode_change)),\n\t \n\tHCI_EV(HCI_EV_PIN_CODE_REQ, hci_pin_code_request_evt,\n\t       sizeof(struct hci_ev_pin_code_req)),\n\t \n\tHCI_EV(HCI_EV_LINK_KEY_REQ, hci_link_key_request_evt,\n\t       sizeof(struct hci_ev_link_key_req)),\n\t \n\tHCI_EV(HCI_EV_LINK_KEY_NOTIFY, hci_link_key_notify_evt,\n\t       sizeof(struct hci_ev_link_key_notify)),\n\t \n\tHCI_EV(HCI_EV_CLOCK_OFFSET, hci_clock_offset_evt,\n\t       sizeof(struct hci_ev_clock_offset)),\n\t \n\tHCI_EV(HCI_EV_PKT_TYPE_CHANGE, hci_pkt_type_change_evt,\n\t       sizeof(struct hci_ev_pkt_type_change)),\n\t \n\tHCI_EV(HCI_EV_PSCAN_REP_MODE, hci_pscan_rep_mode_evt,\n\t       sizeof(struct hci_ev_pscan_rep_mode)),\n\t \n\tHCI_EV_VL(HCI_EV_INQUIRY_RESULT_WITH_RSSI,\n\t\t  hci_inquiry_result_with_rssi_evt,\n\t\t  sizeof(struct hci_ev_inquiry_result_rssi),\n\t\t  HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_EV(HCI_EV_REMOTE_EXT_FEATURES, hci_remote_ext_features_evt,\n\t       sizeof(struct hci_ev_remote_ext_features)),\n\t \n\tHCI_EV(HCI_EV_SYNC_CONN_COMPLETE, hci_sync_conn_complete_evt,\n\t       sizeof(struct hci_ev_sync_conn_complete)),\n\t \n\tHCI_EV_VL(HCI_EV_EXTENDED_INQUIRY_RESULT,\n\t\t  hci_extended_inquiry_result_evt,\n\t\t  sizeof(struct hci_ev_ext_inquiry_result), HCI_MAX_EVENT_SIZE),\n\t \n\tHCI_EV(HCI_EV_KEY_REFRESH_COMPLETE, hci_key_refresh_complete_evt,\n\t       sizeof(struct hci_ev_key_refresh_complete)),\n\t \n\tHCI_EV(HCI_EV_IO_CAPA_REQUEST, hci_io_capa_request_evt,\n\t       sizeof(struct hci_ev_io_capa_request)),\n\t \n\tHCI_EV(HCI_EV_IO_CAPA_REPLY, hci_io_capa_reply_evt,\n\t       sizeof(struct hci_ev_io_capa_reply)),\n\t \n\tHCI_EV(HCI_EV_USER_CONFIRM_REQUEST, hci_user_confirm_request_evt,\n\t       sizeof(struct hci_ev_user_confirm_req)),\n\t \n\tHCI_EV(HCI_EV_USER_PASSKEY_REQUEST, hci_user_passkey_request_evt,\n\t       sizeof(struct hci_ev_user_passkey_req)),\n\t \n\tHCI_EV(HCI_EV_REMOTE_OOB_DATA_REQUEST, hci_remote_oob_data_request_evt,\n\t       sizeof(struct hci_ev_remote_oob_data_request)),\n\t \n\tHCI_EV(HCI_EV_SIMPLE_PAIR_COMPLETE, hci_simple_pair_complete_evt,\n\t       sizeof(struct hci_ev_simple_pair_complete)),\n\t \n\tHCI_EV(HCI_EV_USER_PASSKEY_NOTIFY, hci_user_passkey_notify_evt,\n\t       sizeof(struct hci_ev_user_passkey_notify)),\n\t \n\tHCI_EV(HCI_EV_KEYPRESS_NOTIFY, hci_keypress_notify_evt,\n\t       sizeof(struct hci_ev_keypress_notify)),\n\t \n\tHCI_EV(HCI_EV_REMOTE_HOST_FEATURES, hci_remote_host_features_evt,\n\t       sizeof(struct hci_ev_remote_host_features)),\n\t \n\tHCI_EV_REQ_VL(HCI_EV_LE_META, hci_le_meta_evt,\n\t\t      sizeof(struct hci_ev_le_meta), HCI_MAX_EVENT_SIZE),\n#if IS_ENABLED(CONFIG_BT_HS)\n\t \n\tHCI_EV(HCI_EV_PHY_LINK_COMPLETE, hci_phy_link_complete_evt,\n\t       sizeof(struct hci_ev_phy_link_complete)),\n\t \n\tHCI_EV(HCI_EV_CHANNEL_SELECTED, hci_chan_selected_evt,\n\t       sizeof(struct hci_ev_channel_selected)),\n\t \n\tHCI_EV(HCI_EV_DISCONN_LOGICAL_LINK_COMPLETE,\n\t       hci_disconn_loglink_complete_evt,\n\t       sizeof(struct hci_ev_disconn_logical_link_complete)),\n\t \n\tHCI_EV(HCI_EV_LOGICAL_LINK_COMPLETE, hci_loglink_complete_evt,\n\t       sizeof(struct hci_ev_logical_link_complete)),\n\t \n\tHCI_EV(HCI_EV_DISCONN_PHY_LINK_COMPLETE,\n\t       hci_disconn_phylink_complete_evt,\n\t       sizeof(struct hci_ev_disconn_phy_link_complete)),\n#endif\n\t \n\tHCI_EV(HCI_EV_NUM_COMP_BLOCKS, hci_num_comp_blocks_evt,\n\t       sizeof(struct hci_ev_num_comp_blocks)),\n\t \n\tHCI_EV_VL(HCI_EV_VENDOR, msft_vendor_evt, 0, HCI_MAX_EVENT_SIZE),\n};\n\nstatic void hci_event_func(struct hci_dev *hdev, u8 event, struct sk_buff *skb,\n\t\t\t   u16 *opcode, u8 *status,\n\t\t\t   hci_req_complete_t *req_complete,\n\t\t\t   hci_req_complete_skb_t *req_complete_skb)\n{\n\tconst struct hci_ev *ev = &hci_ev_table[event];\n\tvoid *data;\n\n\tif (!ev->func)\n\t\treturn;\n\n\tif (skb->len < ev->min_len) {\n\t\tbt_dev_err(hdev, \"unexpected event 0x%2.2x length: %u < %u\",\n\t\t\t   event, skb->len, ev->min_len);\n\t\treturn;\n\t}\n\n\t \n\tif (skb->len > ev->max_len)\n\t\tbt_dev_warn_ratelimited(hdev,\n\t\t\t\t\t\"unexpected event 0x%2.2x length: %u > %u\",\n\t\t\t\t\tevent, skb->len, ev->max_len);\n\n\tdata = hci_ev_skb_pull(hdev, skb, event, ev->min_len);\n\tif (!data)\n\t\treturn;\n\n\tif (ev->req)\n\t\tev->func_req(hdev, data, skb, opcode, status, req_complete,\n\t\t\t     req_complete_skb);\n\telse\n\t\tev->func(hdev, data, skb);\n}\n\nvoid hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_event_hdr *hdr = (void *) skb->data;\n\thci_req_complete_t req_complete = NULL;\n\thci_req_complete_skb_t req_complete_skb = NULL;\n\tstruct sk_buff *orig_skb = NULL;\n\tu8 status = 0, event, req_evt = 0;\n\tu16 opcode = HCI_OP_NOP;\n\n\tif (skb->len < sizeof(*hdr)) {\n\t\tbt_dev_err(hdev, \"Malformed HCI Event\");\n\t\tgoto done;\n\t}\n\n\tkfree_skb(hdev->recv_event);\n\thdev->recv_event = skb_clone(skb, GFP_KERNEL);\n\n\tevent = hdr->evt;\n\tif (!event) {\n\t\tbt_dev_warn(hdev, \"Received unexpected HCI Event 0x%2.2x\",\n\t\t\t    event);\n\t\tgoto done;\n\t}\n\n\t \n\tif (hdev->sent_cmd &&\n\t    hci_opcode_ogf(hci_skb_opcode(hdev->sent_cmd)) != 0x08 &&\n\t    hci_skb_event(hdev->sent_cmd) == event) {\n\t\thci_req_cmd_complete(hdev, hci_skb_opcode(hdev->sent_cmd),\n\t\t\t\t     status, &req_complete, &req_complete_skb);\n\t\treq_evt = event;\n\t}\n\n\t \n\tif (req_complete_skb || event == HCI_EV_CMD_STATUS ||\n\t    event == HCI_EV_CMD_COMPLETE)\n\t\torig_skb = skb_clone(skb, GFP_KERNEL);\n\n\tskb_pull(skb, HCI_EVENT_HDR_SIZE);\n\n\t \n\thci_store_wake_reason(hdev, event, skb);\n\n\tbt_dev_dbg(hdev, \"event 0x%2.2x\", event);\n\n\thci_event_func(hdev, event, skb, &opcode, &status, &req_complete,\n\t\t       &req_complete_skb);\n\n\tif (req_complete) {\n\t\treq_complete(hdev, status, opcode);\n\t} else if (req_complete_skb) {\n\t\tif (!hci_get_cmd_complete(hdev, opcode, req_evt, orig_skb)) {\n\t\t\tkfree_skb(orig_skb);\n\t\t\torig_skb = NULL;\n\t\t}\n\t\treq_complete_skb(hdev, status, opcode, orig_skb);\n\t}\n\ndone:\n\tkfree_skb(orig_skb);\n\tkfree_skb(skb);\n\thdev->stat.evt_rx++;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}