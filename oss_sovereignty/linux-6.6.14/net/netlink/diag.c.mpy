{
  "module_name": "diag.c",
  "hash_id": "ee0f752ef4968b25e51265ed9ed645c3063d502060ce4931b78c728b6a6d32d9",
  "original_prompt": "Ingested from linux-6.6.14/net/netlink/diag.c",
  "human_readable_source": "\n#include <linux/module.h>\n\n#include <net/sock.h>\n#include <linux/netlink.h>\n#include <linux/sock_diag.h>\n#include <linux/netlink_diag.h>\n#include <linux/rhashtable.h>\n\n#include \"af_netlink.h\"\n\nstatic int sk_diag_dump_groups(struct sock *sk, struct sk_buff *nlskb)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\n\tif (nlk->groups == NULL)\n\t\treturn 0;\n\n\treturn nla_put(nlskb, NETLINK_DIAG_GROUPS, NLGRPSZ(nlk->ngroups),\n\t\t       nlk->groups);\n}\n\nstatic int sk_diag_put_flags(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tu32 flags = 0;\n\n\tif (nlk->cb_running)\n\t\tflags |= NDIAG_FLAG_CB_RUNNING;\n\tif (nlk_test_bit(RECV_PKTINFO, sk))\n\t\tflags |= NDIAG_FLAG_PKTINFO;\n\tif (nlk_test_bit(BROADCAST_SEND_ERROR, sk))\n\t\tflags |= NDIAG_FLAG_BROADCAST_ERROR;\n\tif (nlk_test_bit(RECV_NO_ENOBUFS, sk))\n\t\tflags |= NDIAG_FLAG_NO_ENOBUFS;\n\tif (nlk_test_bit(LISTEN_ALL_NSID, sk))\n\t\tflags |= NDIAG_FLAG_LISTEN_ALL_NSID;\n\tif (nlk_test_bit(CAP_ACK, sk))\n\t\tflags |= NDIAG_FLAG_CAP_ACK;\n\n\treturn nla_put_u32(skb, NETLINK_DIAG_FLAGS, flags);\n}\n\nstatic int sk_diag_fill(struct sock *sk, struct sk_buff *skb,\n\t\t\tstruct netlink_diag_req *req,\n\t\t\tu32 portid, u32 seq, u32 flags, int sk_ino)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct netlink_diag_msg *rep;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\n\tnlh = nlmsg_put(skb, portid, seq, SOCK_DIAG_BY_FAMILY, sizeof(*rep),\n\t\t\tflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\trep = nlmsg_data(nlh);\n\trep->ndiag_family\t= AF_NETLINK;\n\trep->ndiag_type\t\t= sk->sk_type;\n\trep->ndiag_protocol\t= sk->sk_protocol;\n\trep->ndiag_state\t= sk->sk_state;\n\n\trep->ndiag_ino\t\t= sk_ino;\n\trep->ndiag_portid\t= nlk->portid;\n\trep->ndiag_dst_portid\t= nlk->dst_portid;\n\trep->ndiag_dst_group\t= nlk->dst_group;\n\tsock_diag_save_cookie(sk, rep->ndiag_cookie);\n\n\tif ((req->ndiag_show & NDIAG_SHOW_GROUPS) &&\n\t    sk_diag_dump_groups(sk, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->ndiag_show & NDIAG_SHOW_MEMINFO) &&\n\t    sock_diag_put_meminfo(sk, skb, NETLINK_DIAG_MEMINFO))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->ndiag_show & NDIAG_SHOW_FLAGS) &&\n\t    sk_diag_put_flags(sk, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nout_nlmsg_trim:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int __netlink_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t\tint protocol, int s_num)\n{\n\tstruct rhashtable_iter *hti = (void *)cb->args[2];\n\tstruct netlink_table *tbl = &nl_table[protocol];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct netlink_diag_req *req;\n\tstruct netlink_sock *nlsk;\n\tunsigned long flags;\n\tstruct sock *sk;\n\tint num = 2;\n\tint ret = 0;\n\n\treq = nlmsg_data(cb->nlh);\n\n\tif (s_num > 1)\n\t\tgoto mc_list;\n\n\tnum--;\n\n\tif (!hti) {\n\t\thti = kmalloc(sizeof(*hti), GFP_KERNEL);\n\t\tif (!hti)\n\t\t\treturn -ENOMEM;\n\n\t\tcb->args[2] = (long)hti;\n\t}\n\n\tif (!s_num)\n\t\trhashtable_walk_enter(&tbl->hash, hti);\n\n\trhashtable_walk_start(hti);\n\n\twhile ((nlsk = rhashtable_walk_next(hti))) {\n\t\tif (IS_ERR(nlsk)) {\n\t\t\tret = PTR_ERR(nlsk);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tsk = (struct sock *)nlsk;\n\n\t\tif (!net_eq(sock_net(sk), net))\n\t\t\tcontinue;\n\n\t\tif (sk_diag_fill(sk, skb, req,\n\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t NLM_F_MULTI,\n\t\t\t\t sock_i_ino(sk)) < 0) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trhashtable_walk_stop(hti);\n\n\tif (ret)\n\t\tgoto done;\n\n\trhashtable_walk_exit(hti);\n\tnum++;\n\nmc_list:\n\tread_lock_irqsave(&nl_table_lock, flags);\n\tsk_for_each_bound(sk, &tbl->mc_list) {\n\t\tif (sk_hashed(sk))\n\t\t\tcontinue;\n\t\tif (!net_eq(sock_net(sk), net))\n\t\t\tcontinue;\n\t\tif (num < s_num) {\n\t\t\tnum++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk_diag_fill(sk, skb, req,\n\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t NLM_F_MULTI,\n\t\t\t\t __sock_i_ino(sk)) < 0) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\tread_unlock_irqrestore(&nl_table_lock, flags);\n\ndone:\n\tcb->args[0] = num;\n\n\treturn ret;\n}\n\nstatic int netlink_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct netlink_diag_req *req;\n\tint s_num = cb->args[0];\n\tint err = 0;\n\n\treq = nlmsg_data(cb->nlh);\n\n\tif (req->sdiag_protocol == NDIAG_PROTO_ALL) {\n\t\tint i;\n\n\t\tfor (i = cb->args[1]; i < MAX_LINKS; i++) {\n\t\t\terr = __netlink_diag_dump(skb, cb, i, s_num);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\ts_num = 0;\n\t\t}\n\t\tcb->args[1] = i;\n\t} else {\n\t\tif (req->sdiag_protocol >= MAX_LINKS)\n\t\t\treturn -ENOENT;\n\n\t\terr = __netlink_diag_dump(skb, cb, req->sdiag_protocol, s_num);\n\t}\n\n\treturn err < 0 ? err : skb->len;\n}\n\nstatic int netlink_diag_dump_done(struct netlink_callback *cb)\n{\n\tstruct rhashtable_iter *hti = (void *)cb->args[2];\n\n\tif (cb->args[0] == 1)\n\t\trhashtable_walk_exit(hti);\n\n\tkfree(hti);\n\n\treturn 0;\n}\n\nstatic int netlink_diag_handler_dump(struct sk_buff *skb, struct nlmsghdr *h)\n{\n\tint hdrlen = sizeof(struct netlink_diag_req);\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (nlmsg_len(h) < hdrlen)\n\t\treturn -EINVAL;\n\n\tif (h->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = netlink_diag_dump,\n\t\t\t.done = netlink_diag_dump_done,\n\t\t};\n\t\treturn netlink_dump_start(net->diag_nlsk, skb, h, &c);\n\t} else\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic const struct sock_diag_handler netlink_diag_handler = {\n\t.family = AF_NETLINK,\n\t.dump = netlink_diag_handler_dump,\n};\n\nstatic int __init netlink_diag_init(void)\n{\n\treturn sock_diag_register(&netlink_diag_handler);\n}\n\nstatic void __exit netlink_diag_exit(void)\n{\n\tsock_diag_unregister(&netlink_diag_handler);\n}\n\nmodule_init(netlink_diag_init);\nmodule_exit(netlink_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 16  );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}