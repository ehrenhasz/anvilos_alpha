{
  "module_name": "policy.c",
  "hash_id": "fdc0bc2310d46518190298da9e500e0b552df801b24917c5c5aa64d90e3e711a",
  "original_prompt": "Ingested from linux-6.6.14/net/netlink/policy.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <net/netlink.h>\n\n#define INITIAL_POLICIES_ALLOC\t10\n\nstruct netlink_policy_dump_state {\n\tunsigned int policy_idx;\n\tunsigned int attr_idx;\n\tunsigned int n_alloc;\n\tstruct {\n\t\tconst struct nla_policy *policy;\n\t\tunsigned int maxtype;\n\t} policies[];\n};\n\nstatic int add_policy(struct netlink_policy_dump_state **statep,\n\t\t      const struct nla_policy *policy,\n\t\t      unsigned int maxtype)\n{\n\tstruct netlink_policy_dump_state *state = *statep;\n\tunsigned int n_alloc, i;\n\n\tif (!policy || !maxtype)\n\t\treturn 0;\n\n\tfor (i = 0; i < state->n_alloc; i++) {\n\t\tif (state->policies[i].policy == policy &&\n\t\t    state->policies[i].maxtype == maxtype)\n\t\t\treturn 0;\n\n\t\tif (!state->policies[i].policy) {\n\t\t\tstate->policies[i].policy = policy;\n\t\t\tstate->policies[i].maxtype = maxtype;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tn_alloc = state->n_alloc + INITIAL_POLICIES_ALLOC;\n\tstate = krealloc(state, struct_size(state, policies, n_alloc),\n\t\t\t GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tmemset(&state->policies[state->n_alloc], 0,\n\t       flex_array_size(state, policies, n_alloc - state->n_alloc));\n\n\tstate->policies[state->n_alloc].policy = policy;\n\tstate->policies[state->n_alloc].maxtype = maxtype;\n\tstate->n_alloc = n_alloc;\n\t*statep = state;\n\n\treturn 0;\n}\n\n \nint netlink_policy_dump_get_policy_idx(struct netlink_policy_dump_state *state,\n\t\t\t\t       const struct nla_policy *policy,\n\t\t\t\t       unsigned int maxtype)\n{\n\tunsigned int i;\n\n\tif (WARN_ON(!policy || !maxtype))\n                return 0;\n\n\tfor (i = 0; i < state->n_alloc; i++) {\n\t\tif (state->policies[i].policy == policy &&\n\t\t    state->policies[i].maxtype == maxtype)\n\t\t\treturn i;\n\t}\n\n\tWARN_ON(1);\n\treturn 0;\n}\n\nstatic struct netlink_policy_dump_state *alloc_state(void)\n{\n\tstruct netlink_policy_dump_state *state;\n\n\tstate = kzalloc(struct_size(state, policies, INITIAL_POLICIES_ALLOC),\n\t\t\tGFP_KERNEL);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstate->n_alloc = INITIAL_POLICIES_ALLOC;\n\n\treturn state;\n}\n\n \nint netlink_policy_dump_add_policy(struct netlink_policy_dump_state **pstate,\n\t\t\t\t   const struct nla_policy *policy,\n\t\t\t\t   unsigned int maxtype)\n{\n\tstruct netlink_policy_dump_state *state = *pstate;\n\tunsigned int policy_idx;\n\tint err;\n\n\tif (!state) {\n\t\tstate = alloc_state();\n\t\tif (IS_ERR(state))\n\t\t\treturn PTR_ERR(state);\n\t}\n\n\t \n\n\terr = add_policy(&state, policy, maxtype);\n\tif (err)\n\t\tgoto err_try_undo;\n\n\tfor (policy_idx = 0;\n\t     policy_idx < state->n_alloc && state->policies[policy_idx].policy;\n\t     policy_idx++) {\n\t\tconst struct nla_policy *policy;\n\t\tunsigned int type;\n\n\t\tpolicy = state->policies[policy_idx].policy;\n\n\t\tfor (type = 0;\n\t\t     type <= state->policies[policy_idx].maxtype;\n\t\t     type++) {\n\t\t\tswitch (policy[type].type) {\n\t\t\tcase NLA_NESTED:\n\t\t\tcase NLA_NESTED_ARRAY:\n\t\t\t\terr = add_policy(&state,\n\t\t\t\t\t\t policy[type].nested_policy,\n\t\t\t\t\t\t policy[type].len);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto err_try_undo;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t*pstate = state;\n\treturn 0;\n\nerr_try_undo:\n\t \n\tif (!*pstate)\n\t\tnetlink_policy_dump_free(state);\n\telse\n\t\t*pstate = state;\n\treturn err;\n}\n\nstatic bool\nnetlink_policy_dump_finished(struct netlink_policy_dump_state *state)\n{\n\treturn state->policy_idx >= state->n_alloc ||\n\t       !state->policies[state->policy_idx].policy;\n}\n\n \nbool netlink_policy_dump_loop(struct netlink_policy_dump_state *state)\n{\n\treturn !netlink_policy_dump_finished(state);\n}\n\nint netlink_policy_dump_attr_size_estimate(const struct nla_policy *pt)\n{\n\t \n\tint common = 2 * nla_attr_size(sizeof(u32));\n\n\tswitch (pt->type) {\n\tcase NLA_UNSPEC:\n\tcase NLA_REJECT:\n\t\t \n\t\treturn 0;\n\tcase NLA_NESTED:\n\tcase NLA_NESTED_ARRAY:\n\t\t \n\t\treturn common + 2 * nla_attr_size(sizeof(u32));\n\tcase NLA_U8:\n\tcase NLA_U16:\n\tcase NLA_U32:\n\tcase NLA_U64:\n\tcase NLA_MSECS:\n\tcase NLA_S8:\n\tcase NLA_S16:\n\tcase NLA_S32:\n\tcase NLA_S64:\n\t\t \n\t\treturn common +\n\t\t       2 * (nla_attr_size(0) + nla_attr_size(sizeof(u64)));\n\tcase NLA_BITFIELD32:\n\t\treturn common + nla_attr_size(sizeof(u32));\n\tcase NLA_STRING:\n\tcase NLA_NUL_STRING:\n\tcase NLA_BINARY:\n\t\t \n\t\treturn common + 2 * nla_attr_size(sizeof(u32));\n\tcase NLA_FLAG:\n\t\treturn common;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int\n__netlink_policy_dump_write_attr(struct netlink_policy_dump_state *state,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t const struct nla_policy *pt,\n\t\t\t\t int nestattr)\n{\n\tint estimate = netlink_policy_dump_attr_size_estimate(pt);\n\tenum netlink_attribute_type type;\n\tstruct nlattr *attr;\n\n\tattr = nla_nest_start(skb, nestattr);\n\tif (!attr)\n\t\treturn -ENOBUFS;\n\n\tswitch (pt->type) {\n\tdefault:\n\tcase NLA_UNSPEC:\n\tcase NLA_REJECT:\n\t\t \n\t\tnla_nest_cancel(skb, attr);\n\t\treturn -ENODATA;\n\tcase NLA_NESTED:\n\t\ttype = NL_ATTR_TYPE_NESTED;\n\t\tfallthrough;\n\tcase NLA_NESTED_ARRAY:\n\t\tif (pt->type == NLA_NESTED_ARRAY)\n\t\t\ttype = NL_ATTR_TYPE_NESTED_ARRAY;\n\t\tif (state && pt->nested_policy && pt->len &&\n\t\t    (nla_put_u32(skb, NL_POLICY_TYPE_ATTR_POLICY_IDX,\n\t\t\t\t netlink_policy_dump_get_policy_idx(state,\n\t\t\t\t\t\t\t\t    pt->nested_policy,\n\t\t\t\t\t\t\t\t    pt->len)) ||\n\t\t     nla_put_u32(skb, NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE,\n\t\t\t\t pt->len)))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase NLA_U8:\n\tcase NLA_U16:\n\tcase NLA_U32:\n\tcase NLA_U64:\n\tcase NLA_MSECS: {\n\t\tstruct netlink_range_validation range;\n\n\t\tif (pt->type == NLA_U8)\n\t\t\ttype = NL_ATTR_TYPE_U8;\n\t\telse if (pt->type == NLA_U16)\n\t\t\ttype = NL_ATTR_TYPE_U16;\n\t\telse if (pt->type == NLA_U32)\n\t\t\ttype = NL_ATTR_TYPE_U32;\n\t\telse\n\t\t\ttype = NL_ATTR_TYPE_U64;\n\n\t\tif (pt->validation_type == NLA_VALIDATE_MASK) {\n\t\t\tif (nla_put_u64_64bit(skb, NL_POLICY_TYPE_ATTR_MASK,\n\t\t\t\t\t      pt->mask,\n\t\t\t\t\t      NL_POLICY_TYPE_ATTR_PAD))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tbreak;\n\t\t}\n\n\t\tnla_get_range_unsigned(pt, &range);\n\n\t\tif (nla_put_u64_64bit(skb, NL_POLICY_TYPE_ATTR_MIN_VALUE_U,\n\t\t\t\t      range.min, NL_POLICY_TYPE_ATTR_PAD) ||\n\t\t    nla_put_u64_64bit(skb, NL_POLICY_TYPE_ATTR_MAX_VALUE_U,\n\t\t\t\t      range.max, NL_POLICY_TYPE_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\tcase NLA_S8:\n\tcase NLA_S16:\n\tcase NLA_S32:\n\tcase NLA_S64: {\n\t\tstruct netlink_range_validation_signed range;\n\n\t\tif (pt->type == NLA_S8)\n\t\t\ttype = NL_ATTR_TYPE_S8;\n\t\telse if (pt->type == NLA_S16)\n\t\t\ttype = NL_ATTR_TYPE_S16;\n\t\telse if (pt->type == NLA_S32)\n\t\t\ttype = NL_ATTR_TYPE_S32;\n\t\telse\n\t\t\ttype = NL_ATTR_TYPE_S64;\n\n\t\tnla_get_range_signed(pt, &range);\n\n\t\tif (nla_put_s64(skb, NL_POLICY_TYPE_ATTR_MIN_VALUE_S,\n\t\t\t\trange.min, NL_POLICY_TYPE_ATTR_PAD) ||\n\t\t    nla_put_s64(skb, NL_POLICY_TYPE_ATTR_MAX_VALUE_S,\n\t\t\t\trange.max, NL_POLICY_TYPE_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\tcase NLA_BITFIELD32:\n\t\ttype = NL_ATTR_TYPE_BITFIELD32;\n\t\tif (nla_put_u32(skb, NL_POLICY_TYPE_ATTR_BITFIELD32_MASK,\n\t\t\t\tpt->bitfield32_valid))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase NLA_STRING:\n\tcase NLA_NUL_STRING:\n\tcase NLA_BINARY:\n\t\tif (pt->type == NLA_STRING)\n\t\t\ttype = NL_ATTR_TYPE_STRING;\n\t\telse if (pt->type == NLA_NUL_STRING)\n\t\t\ttype = NL_ATTR_TYPE_NUL_STRING;\n\t\telse\n\t\t\ttype = NL_ATTR_TYPE_BINARY;\n\n\t\tif (pt->validation_type == NLA_VALIDATE_RANGE ||\n\t\t    pt->validation_type == NLA_VALIDATE_RANGE_WARN_TOO_LONG) {\n\t\t\tstruct netlink_range_validation range;\n\n\t\t\tnla_get_range_unsigned(pt, &range);\n\n\t\t\tif (range.min &&\n\t\t\t    nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MIN_LENGTH,\n\t\t\t\t\trange.min))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (range.max < U16_MAX &&\n\t\t\t    nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MAX_LENGTH,\n\t\t\t\t\trange.max))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else if (pt->len &&\n\t\t\t   nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MAX_LENGTH,\n\t\t\t\t       pt->len)) {\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tbreak;\n\tcase NLA_FLAG:\n\t\ttype = NL_ATTR_TYPE_FLAG;\n\t\tbreak;\n\t}\n\n\tif (nla_put_u32(skb, NL_POLICY_TYPE_ATTR_TYPE, type))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, attr);\n\tWARN_ON(attr->nla_len > estimate);\n\n\treturn 0;\nnla_put_failure:\n\tnla_nest_cancel(skb, attr);\n\treturn -ENOBUFS;\n}\n\n \nint netlink_policy_dump_write_attr(struct sk_buff *skb,\n\t\t\t\t   const struct nla_policy *pt,\n\t\t\t\t   int nestattr)\n{\n\treturn __netlink_policy_dump_write_attr(NULL, skb, pt, nestattr);\n}\n\n \nint netlink_policy_dump_write(struct sk_buff *skb,\n\t\t\t      struct netlink_policy_dump_state *state)\n{\n\tconst struct nla_policy *pt;\n\tstruct nlattr *policy;\n\tbool again;\n\tint err;\n\nsend_attribute:\n\tagain = false;\n\n\tpt = &state->policies[state->policy_idx].policy[state->attr_idx];\n\n\tpolicy = nla_nest_start(skb, state->policy_idx);\n\tif (!policy)\n\t\treturn -ENOBUFS;\n\n\terr = __netlink_policy_dump_write_attr(state, skb, pt, state->attr_idx);\n\tif (err == -ENODATA) {\n\t\tnla_nest_cancel(skb, policy);\n\t\tagain = true;\n\t\tgoto next;\n\t} else if (err) {\n\t\tgoto nla_put_failure;\n\t}\n\n\t \n\tnla_nest_end(skb, policy);\n\nnext:\n\tstate->attr_idx += 1;\n\tif (state->attr_idx > state->policies[state->policy_idx].maxtype) {\n\t\tstate->attr_idx = 0;\n\t\tstate->policy_idx++;\n\t}\n\n\tif (again) {\n\t\tif (netlink_policy_dump_finished(state))\n\t\t\treturn -ENODATA;\n\t\tgoto send_attribute;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, policy);\n\treturn -ENOBUFS;\n}\n\n \nvoid netlink_policy_dump_free(struct netlink_policy_dump_state *state)\n{\n\tkfree(state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}