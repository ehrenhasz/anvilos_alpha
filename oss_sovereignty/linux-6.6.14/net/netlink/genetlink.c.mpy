{
  "module_name": "genetlink.c",
  "hash_id": "e636ed9951e3765a51c352bb3aed85b885aac91513ccb1548e27918a25ed7b5a",
  "original_prompt": "Ingested from linux-6.6.14/net/netlink/genetlink.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/string_helpers.h>\n#include <linux/skbuff.h>\n#include <linux/mutex.h>\n#include <linux/bitmap.h>\n#include <linux/rwsem.h>\n#include <linux/idr.h>\n#include <net/sock.h>\n#include <net/genetlink.h>\n\nstatic DEFINE_MUTEX(genl_mutex);  \nstatic DECLARE_RWSEM(cb_lock);\n\natomic_t genl_sk_destructing_cnt = ATOMIC_INIT(0);\nDECLARE_WAIT_QUEUE_HEAD(genl_sk_destructing_waitq);\n\nvoid genl_lock(void)\n{\n\tmutex_lock(&genl_mutex);\n}\nEXPORT_SYMBOL(genl_lock);\n\nvoid genl_unlock(void)\n{\n\tmutex_unlock(&genl_mutex);\n}\nEXPORT_SYMBOL(genl_unlock);\n\nstatic void genl_lock_all(void)\n{\n\tdown_write(&cb_lock);\n\tgenl_lock();\n}\n\nstatic void genl_unlock_all(void)\n{\n\tgenl_unlock();\n\tup_write(&cb_lock);\n}\n\nstatic void genl_op_lock(const struct genl_family *family)\n{\n\tif (!family->parallel_ops)\n\t\tgenl_lock();\n}\n\nstatic void genl_op_unlock(const struct genl_family *family)\n{\n\tif (!family->parallel_ops)\n\t\tgenl_unlock();\n}\n\nstatic DEFINE_IDR(genl_fam_idr);\n\n \nstatic unsigned long mc_group_start = 0x3 | BIT(GENL_ID_CTRL) |\n\t\t\t\t      BIT(GENL_ID_VFS_DQUOT) |\n\t\t\t\t      BIT(GENL_ID_PMCRAID);\nstatic unsigned long *mc_groups = &mc_group_start;\nstatic unsigned long mc_groups_longs = 1;\n\n \nstatic struct nla_policy genl_policy_reject_all[] = {\n\t{ .type = NLA_REJECT },\n\t{ .type = NLA_REJECT },\n};\n\nstatic int genl_ctrl_event(int event, const struct genl_family *family,\n\t\t\t   const struct genl_multicast_group *grp,\n\t\t\t   int grp_id);\n\nstatic void\ngenl_op_fill_in_reject_policy(const struct genl_family *family,\n\t\t\t      struct genl_ops *op)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(genl_policy_reject_all) - 1 != 1);\n\n\tif (op->policy || op->cmd < family->resv_start_op)\n\t\treturn;\n\n\top->policy = genl_policy_reject_all;\n\top->maxattr = 1;\n}\n\nstatic void\ngenl_op_fill_in_reject_policy_split(const struct genl_family *family,\n\t\t\t\t    struct genl_split_ops *op)\n{\n\tif (op->policy)\n\t\treturn;\n\n\top->policy = genl_policy_reject_all;\n\top->maxattr = 1;\n}\n\nstatic const struct genl_family *genl_family_find_byid(unsigned int id)\n{\n\treturn idr_find(&genl_fam_idr, id);\n}\n\nstatic const struct genl_family *genl_family_find_byname(char *name)\n{\n\tconst struct genl_family *family;\n\tunsigned int id;\n\n\tidr_for_each_entry(&genl_fam_idr, family, id)\n\t\tif (strcmp(family->name, name) == 0)\n\t\t\treturn family;\n\n\treturn NULL;\n}\n\nstruct genl_op_iter {\n\tconst struct genl_family *family;\n\tstruct genl_split_ops doit;\n\tstruct genl_split_ops dumpit;\n\tint cmd_idx;\n\tint entry_idx;\n\tu32 cmd;\n\tu8 flags;\n};\n\nstatic void genl_op_from_full(const struct genl_family *family,\n\t\t\t      unsigned int i, struct genl_ops *op)\n{\n\t*op = family->ops[i];\n\n\tif (!op->maxattr)\n\t\top->maxattr = family->maxattr;\n\tif (!op->policy)\n\t\top->policy = family->policy;\n\n\tgenl_op_fill_in_reject_policy(family, op);\n}\n\nstatic int genl_get_cmd_full(u32 cmd, const struct genl_family *family,\n\t\t\t     struct genl_ops *op)\n{\n\tint i;\n\n\tfor (i = 0; i < family->n_ops; i++)\n\t\tif (family->ops[i].cmd == cmd) {\n\t\t\tgenl_op_from_full(family, i, op);\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENOENT;\n}\n\nstatic void genl_op_from_small(const struct genl_family *family,\n\t\t\t       unsigned int i, struct genl_ops *op)\n{\n\tmemset(op, 0, sizeof(*op));\n\top->doit\t= family->small_ops[i].doit;\n\top->dumpit\t= family->small_ops[i].dumpit;\n\top->cmd\t\t= family->small_ops[i].cmd;\n\top->internal_flags = family->small_ops[i].internal_flags;\n\top->flags\t= family->small_ops[i].flags;\n\top->validate\t= family->small_ops[i].validate;\n\n\top->maxattr = family->maxattr;\n\top->policy = family->policy;\n\n\tgenl_op_fill_in_reject_policy(family, op);\n}\n\nstatic int genl_get_cmd_small(u32 cmd, const struct genl_family *family,\n\t\t\t      struct genl_ops *op)\n{\n\tint i;\n\n\tfor (i = 0; i < family->n_small_ops; i++)\n\t\tif (family->small_ops[i].cmd == cmd) {\n\t\t\tgenl_op_from_small(family, i, op);\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENOENT;\n}\n\nstatic void genl_op_from_split(struct genl_op_iter *iter)\n{\n\tconst struct genl_family *family = iter->family;\n\tint i, cnt = 0;\n\n\ti = iter->entry_idx - family->n_ops - family->n_small_ops;\n\n\tif (family->split_ops[i + cnt].flags & GENL_CMD_CAP_DO) {\n\t\titer->doit = family->split_ops[i + cnt];\n\t\tgenl_op_fill_in_reject_policy_split(family, &iter->doit);\n\t\tcnt++;\n\t} else {\n\t\tmemset(&iter->doit, 0, sizeof(iter->doit));\n\t}\n\n\tif (i + cnt < family->n_split_ops &&\n\t    family->split_ops[i + cnt].flags & GENL_CMD_CAP_DUMP) {\n\t\titer->dumpit = family->split_ops[i + cnt];\n\t\tgenl_op_fill_in_reject_policy_split(family, &iter->dumpit);\n\t\tcnt++;\n\t} else {\n\t\tmemset(&iter->dumpit, 0, sizeof(iter->dumpit));\n\t}\n\n\tWARN_ON(!cnt);\n\titer->entry_idx += cnt;\n}\n\nstatic int\ngenl_get_cmd_split(u32 cmd, u8 flag, const struct genl_family *family,\n\t\t   struct genl_split_ops *op)\n{\n\tint i;\n\n\tfor (i = 0; i < family->n_split_ops; i++)\n\t\tif (family->split_ops[i].cmd == cmd &&\n\t\t    family->split_ops[i].flags & flag) {\n\t\t\t*op = family->split_ops[i];\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENOENT;\n}\n\nstatic int\ngenl_cmd_full_to_split(struct genl_split_ops *op,\n\t\t       const struct genl_family *family,\n\t\t       const struct genl_ops *full, u8 flags)\n{\n\tif ((flags & GENL_CMD_CAP_DO && !full->doit) ||\n\t    (flags & GENL_CMD_CAP_DUMP && !full->dumpit)) {\n\t\tmemset(op, 0, sizeof(*op));\n\t\treturn -ENOENT;\n\t}\n\n\tif (flags & GENL_CMD_CAP_DUMP) {\n\t\top->start\t= full->start;\n\t\top->dumpit\t= full->dumpit;\n\t\top->done\t= full->done;\n\t} else {\n\t\top->pre_doit\t= family->pre_doit;\n\t\top->doit\t= full->doit;\n\t\top->post_doit\t= family->post_doit;\n\t}\n\n\tif (flags & GENL_CMD_CAP_DUMP &&\n\t    full->validate & GENL_DONT_VALIDATE_DUMP) {\n\t\top->policy\t= NULL;\n\t\top->maxattr\t= 0;\n\t} else {\n\t\top->policy\t= full->policy;\n\t\top->maxattr\t= full->maxattr;\n\t}\n\n\top->cmd\t\t\t= full->cmd;\n\top->internal_flags\t= full->internal_flags;\n\top->flags\t\t= full->flags;\n\top->validate\t\t= full->validate;\n\n\t \n\top->flags\t\t|= flags;\n\n\treturn 0;\n}\n\n \nstatic int\ngenl_get_cmd(u32 cmd, u8 flags, const struct genl_family *family,\n\t     struct genl_split_ops *op)\n{\n\tstruct genl_ops full;\n\tint err;\n\n\terr = genl_get_cmd_full(cmd, family, &full);\n\tif (err == -ENOENT)\n\t\terr = genl_get_cmd_small(cmd, family, &full);\n\t \n\tif (err == 0)\n\t\treturn genl_cmd_full_to_split(op, family, &full, flags);\n\n\terr = genl_get_cmd_split(cmd, flags, family, op);\n\tif (err)\n\t\tmemset(op, 0, sizeof(*op));\n\treturn err;\n}\n\n \nstatic int\ngenl_get_cmd_both(u32 cmd, const struct genl_family *family,\n\t\t  struct genl_split_ops *doit, struct genl_split_ops *dumpit)\n{\n\tint err1, err2;\n\n\terr1 = genl_get_cmd(cmd, GENL_CMD_CAP_DO, family, doit);\n\terr2 = genl_get_cmd(cmd, GENL_CMD_CAP_DUMP, family, dumpit);\n\n\treturn err1 && err2 ? -ENOENT : 0;\n}\n\nstatic bool\ngenl_op_iter_init(const struct genl_family *family, struct genl_op_iter *iter)\n{\n\titer->family = family;\n\titer->cmd_idx = 0;\n\titer->entry_idx = 0;\n\n\titer->flags = 0;\n\n\treturn iter->family->n_ops +\n\t\titer->family->n_small_ops +\n\t\titer->family->n_split_ops;\n}\n\nstatic bool genl_op_iter_next(struct genl_op_iter *iter)\n{\n\tconst struct genl_family *family = iter->family;\n\tbool legacy_op = true;\n\tstruct genl_ops op;\n\n\tif (iter->entry_idx < family->n_ops) {\n\t\tgenl_op_from_full(family, iter->entry_idx, &op);\n\t} else if (iter->entry_idx < family->n_ops + family->n_small_ops) {\n\t\tgenl_op_from_small(family, iter->entry_idx - family->n_ops,\n\t\t\t\t   &op);\n\t} else if (iter->entry_idx <\n\t\t   family->n_ops + family->n_small_ops + family->n_split_ops) {\n\t\tlegacy_op = false;\n\t\t \n\t\tgenl_op_from_split(iter);\n\t} else {\n\t\treturn false;\n\t}\n\n\titer->cmd_idx++;\n\n\tif (legacy_op) {\n\t\titer->entry_idx++;\n\n\t\tgenl_cmd_full_to_split(&iter->doit, family,\n\t\t\t\t       &op, GENL_CMD_CAP_DO);\n\t\tgenl_cmd_full_to_split(&iter->dumpit, family,\n\t\t\t\t       &op, GENL_CMD_CAP_DUMP);\n\t}\n\n\titer->cmd = iter->doit.cmd | iter->dumpit.cmd;\n\titer->flags = iter->doit.flags | iter->dumpit.flags;\n\n\treturn true;\n}\n\nstatic void\ngenl_op_iter_copy(struct genl_op_iter *dst, struct genl_op_iter *src)\n{\n\t*dst = *src;\n}\n\nstatic unsigned int genl_op_iter_idx(struct genl_op_iter *iter)\n{\n\treturn iter->cmd_idx;\n}\n\nstatic int genl_allocate_reserve_groups(int n_groups, int *first_id)\n{\n\tunsigned long *new_groups;\n\tint start = 0;\n\tint i;\n\tint id;\n\tbool fits;\n\n\tdo {\n\t\tif (start == 0)\n\t\t\tid = find_first_zero_bit(mc_groups,\n\t\t\t\t\t\t mc_groups_longs *\n\t\t\t\t\t\t BITS_PER_LONG);\n\t\telse\n\t\t\tid = find_next_zero_bit(mc_groups,\n\t\t\t\t\t\tmc_groups_longs * BITS_PER_LONG,\n\t\t\t\t\t\tstart);\n\n\t\tfits = true;\n\t\tfor (i = id;\n\t\t     i < min_t(int, id + n_groups,\n\t\t\t       mc_groups_longs * BITS_PER_LONG);\n\t\t     i++) {\n\t\t\tif (test_bit(i, mc_groups)) {\n\t\t\t\tstart = i;\n\t\t\t\tfits = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (id + n_groups > mc_groups_longs * BITS_PER_LONG) {\n\t\t\tunsigned long new_longs = mc_groups_longs +\n\t\t\t\t\t\t  BITS_TO_LONGS(n_groups);\n\t\t\tsize_t nlen = new_longs * sizeof(unsigned long);\n\n\t\t\tif (mc_groups == &mc_group_start) {\n\t\t\t\tnew_groups = kzalloc(nlen, GFP_KERNEL);\n\t\t\t\tif (!new_groups)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tmc_groups = new_groups;\n\t\t\t\t*mc_groups = mc_group_start;\n\t\t\t} else {\n\t\t\t\tnew_groups = krealloc(mc_groups, nlen,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\t\tif (!new_groups)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tmc_groups = new_groups;\n\t\t\t\tfor (i = 0; i < BITS_TO_LONGS(n_groups); i++)\n\t\t\t\t\tmc_groups[mc_groups_longs + i] = 0;\n\t\t\t}\n\t\t\tmc_groups_longs = new_longs;\n\t\t}\n\t} while (!fits);\n\n\tfor (i = id; i < id + n_groups; i++)\n\t\tset_bit(i, mc_groups);\n\t*first_id = id;\n\treturn 0;\n}\n\nstatic struct genl_family genl_ctrl;\n\nstatic int genl_validate_assign_mc_groups(struct genl_family *family)\n{\n\tint first_id;\n\tint n_groups = family->n_mcgrps;\n\tint err = 0, i;\n\tbool groups_allocated = false;\n\n\tif (!n_groups)\n\t\treturn 0;\n\n\tfor (i = 0; i < n_groups; i++) {\n\t\tconst struct genl_multicast_group *grp = &family->mcgrps[i];\n\n\t\tif (WARN_ON(grp->name[0] == '\\0'))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(!string_is_terminated(grp->name, GENL_NAMSIZ)))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (family == &genl_ctrl) {\n\t\tfirst_id = GENL_ID_CTRL;\n\t\tBUG_ON(n_groups != 1);\n\t} else if (strcmp(family->name, \"NET_DM\") == 0) {\n\t\tfirst_id = 1;\n\t\tBUG_ON(n_groups != 1);\n\t} else if (family->id == GENL_ID_VFS_DQUOT) {\n\t\tfirst_id = GENL_ID_VFS_DQUOT;\n\t\tBUG_ON(n_groups != 1);\n\t} else if (family->id == GENL_ID_PMCRAID) {\n\t\tfirst_id = GENL_ID_PMCRAID;\n\t\tBUG_ON(n_groups != 1);\n\t} else {\n\t\tgroups_allocated = true;\n\t\terr = genl_allocate_reserve_groups(n_groups, &first_id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfamily->mcgrp_offset = first_id;\n\n\t \n\tif (!init_net.genl_sock)\n\t\treturn 0;\n\n\tif (family->netnsok) {\n\t\tstruct net *net;\n\n\t\tnetlink_table_grab();\n\t\trcu_read_lock();\n\t\tfor_each_net_rcu(net) {\n\t\t\terr = __netlink_change_ngroups(net->genl_sock,\n\t\t\t\t\tmc_groups_longs * BITS_PER_LONG);\n\t\t\tif (err) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tnetlink_table_ungrab();\n\t} else {\n\t\terr = netlink_change_ngroups(init_net.genl_sock,\n\t\t\t\t\t     mc_groups_longs * BITS_PER_LONG);\n\t}\n\n\tif (groups_allocated && err) {\n\t\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\t\tclear_bit(family->mcgrp_offset + i, mc_groups);\n\t}\n\n\treturn err;\n}\n\nstatic void genl_unregister_mc_groups(const struct genl_family *family)\n{\n\tstruct net *net;\n\tint i;\n\n\tnetlink_table_grab();\n\trcu_read_lock();\n\tfor_each_net_rcu(net) {\n\t\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\t\t__netlink_clear_multicast_users(\n\t\t\t\tnet->genl_sock, family->mcgrp_offset + i);\n\t}\n\trcu_read_unlock();\n\tnetlink_table_ungrab();\n\n\tfor (i = 0; i < family->n_mcgrps; i++) {\n\t\tint grp_id = family->mcgrp_offset + i;\n\n\t\tif (grp_id != 1)\n\t\t\tclear_bit(grp_id, mc_groups);\n\t\tgenl_ctrl_event(CTRL_CMD_DELMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], grp_id);\n\t}\n}\n\nstatic bool genl_split_op_check(const struct genl_split_ops *op)\n{\n\tif (WARN_ON(hweight8(op->flags & (GENL_CMD_CAP_DO |\n\t\t\t\t\t  GENL_CMD_CAP_DUMP)) != 1))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int genl_validate_ops(const struct genl_family *family)\n{\n\tstruct genl_op_iter i, j;\n\tunsigned int s;\n\n\tif (WARN_ON(family->n_ops && !family->ops) ||\n\t    WARN_ON(family->n_small_ops && !family->small_ops) ||\n\t    WARN_ON(family->n_split_ops && !family->split_ops))\n\t\treturn -EINVAL;\n\n\tfor (genl_op_iter_init(family, &i); genl_op_iter_next(&i); ) {\n\t\tif (!(i.flags & (GENL_CMD_CAP_DO | GENL_CMD_CAP_DUMP)))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(i.cmd >= family->resv_start_op &&\n\t\t\t    (i.doit.validate || i.dumpit.validate)))\n\t\t\treturn -EINVAL;\n\n\t\tgenl_op_iter_copy(&j, &i);\n\t\twhile (genl_op_iter_next(&j)) {\n\t\t\tif (i.cmd == j.cmd)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (family->n_split_ops) {\n\t\tif (genl_split_op_check(&family->split_ops[0]))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (s = 1; s < family->n_split_ops; s++) {\n\t\tconst struct genl_split_ops *a, *b;\n\n\t\ta = &family->split_ops[s - 1];\n\t\tb = &family->split_ops[s];\n\n\t\tif (genl_split_op_check(b))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (a->cmd < b->cmd) {\n\t\t\tcontinue;\n\t\t} else if (a->cmd > b->cmd) {\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (a->internal_flags != b->internal_flags ||\n\t\t    ((a->flags ^ b->flags) & ~(GENL_CMD_CAP_DO |\n\t\t\t\t\t       GENL_CMD_CAP_DUMP))) {\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((a->flags & GENL_CMD_CAP_DO) &&\n\t\t    (b->flags & GENL_CMD_CAP_DUMP))\n\t\t\tcontinue;\n\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\n\tgenl_lock_all();\n\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\n\t \n\tif (family == &genl_ctrl) {\n\t\t \n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\n\tfamily->id = idr_alloc_cyclic(&genl_fam_idr, family,\n\t\t\t\t      start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\n\tgenl_unlock_all();\n\n\t \n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\n\treturn 0;\n\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}\nEXPORT_SYMBOL(genl_register_family);\n\n \nint genl_unregister_family(const struct genl_family *family)\n{\n\tgenl_lock_all();\n\n\tif (!genl_family_find_byid(family->id)) {\n\t\tgenl_unlock_all();\n\t\treturn -ENOENT;\n\t}\n\n\tgenl_unregister_mc_groups(family);\n\n\tidr_remove(&genl_fam_idr, family->id);\n\n\tup_write(&cb_lock);\n\twait_event(genl_sk_destructing_waitq,\n\t\t   atomic_read(&genl_sk_destructing_cnt) == 0);\n\tgenl_unlock();\n\n\tgenl_ctrl_event(CTRL_CMD_DELFAMILY, family, NULL, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genl_unregister_family);\n\n \nvoid *genlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t  const struct genl_family *family, int flags, u8 cmd)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct genlmsghdr *hdr;\n\n\tnlh = nlmsg_put(skb, portid, seq, family->id, GENL_HDRLEN +\n\t\t\tfamily->hdrsize, flags);\n\tif (nlh == NULL)\n\t\treturn NULL;\n\n\thdr = nlmsg_data(nlh);\n\thdr->cmd = cmd;\n\thdr->version = family->version;\n\thdr->reserved = 0;\n\n\treturn (char *) hdr + GENL_HDRLEN;\n}\nEXPORT_SYMBOL(genlmsg_put);\n\nstatic struct genl_dumpit_info *genl_dumpit_info_alloc(void)\n{\n\treturn kmalloc(sizeof(struct genl_dumpit_info), GFP_KERNEL);\n}\n\nstatic void genl_dumpit_info_free(const struct genl_dumpit_info *info)\n{\n\tkfree(info);\n}\n\nstatic struct nlattr **\ngenl_family_rcv_msg_attrs_parse(const struct genl_family *family,\n\t\t\t\tstruct nlmsghdr *nlh,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tconst struct genl_split_ops *ops,\n\t\t\t\tint hdrlen,\n\t\t\t\tenum genl_validate_flags no_strict_flag)\n{\n\tenum netlink_validation validate = ops->validate & no_strict_flag ?\n\t\t\t\t\t   NL_VALIDATE_LIBERAL :\n\t\t\t\t\t   NL_VALIDATE_STRICT;\n\tstruct nlattr **attrbuf;\n\tint err;\n\n\tif (!ops->maxattr)\n\t\treturn NULL;\n\n\tattrbuf = kmalloc_array(ops->maxattr + 1,\n\t\t\t\tsizeof(struct nlattr *), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = __nlmsg_parse(nlh, hdrlen, attrbuf, ops->maxattr, ops->policy,\n\t\t\t    validate, extack);\n\tif (err) {\n\t\tkfree(attrbuf);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn attrbuf;\n}\n\nstatic void genl_family_rcv_msg_attrs_free(struct nlattr **attrbuf)\n{\n\tkfree(attrbuf);\n}\n\nstruct genl_start_context {\n\tconst struct genl_family *family;\n\tstruct nlmsghdr *nlh;\n\tstruct netlink_ext_ack *extack;\n\tconst struct genl_split_ops *ops;\n\tint hdrlen;\n};\n\nstatic int genl_start(struct netlink_callback *cb)\n{\n\tstruct genl_start_context *ctx = cb->data;\n\tconst struct genl_split_ops *ops;\n\tstruct genl_dumpit_info *info;\n\tstruct nlattr **attrs = NULL;\n\tint rc = 0;\n\n\tops = ctx->ops;\n\tif (!(ops->validate & GENL_DONT_VALIDATE_DUMP) &&\n\t    ctx->nlh->nlmsg_len < nlmsg_msg_size(ctx->hdrlen))\n\t\treturn -EINVAL;\n\n\tattrs = genl_family_rcv_msg_attrs_parse(ctx->family, ctx->nlh, ctx->extack,\n\t\t\t\t\t\tops, ctx->hdrlen,\n\t\t\t\t\t\tGENL_DONT_VALIDATE_DUMP_STRICT);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tinfo = genl_dumpit_info_alloc();\n\tif (!info) {\n\t\tgenl_family_rcv_msg_attrs_free(attrs);\n\t\treturn -ENOMEM;\n\t}\n\tinfo->op = *ops;\n\tinfo->info.family\t= ctx->family;\n\tinfo->info.snd_seq\t= cb->nlh->nlmsg_seq;\n\tinfo->info.snd_portid\t= NETLINK_CB(cb->skb).portid;\n\tinfo->info.nlhdr\t= cb->nlh;\n\tinfo->info.genlhdr\t= nlmsg_data(cb->nlh);\n\tinfo->info.attrs\t= attrs;\n\tgenl_info_net_set(&info->info, sock_net(cb->skb->sk));\n\tinfo->info.extack\t= cb->extack;\n\tmemset(&info->info.user_ptr, 0, sizeof(info->info.user_ptr));\n\n\tcb->data = info;\n\tif (ops->start) {\n\t\tgenl_op_lock(ctx->family);\n\t\trc = ops->start(cb);\n\t\tgenl_op_unlock(ctx->family);\n\t}\n\n\tif (rc) {\n\t\tgenl_family_rcv_msg_attrs_free(info->info.attrs);\n\t\tgenl_dumpit_info_free(info);\n\t\tcb->data = NULL;\n\t}\n\treturn rc;\n}\n\nstatic int genl_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct genl_dumpit_info *dump_info = cb->data;\n\tconst struct genl_split_ops *ops = &dump_info->op;\n\tstruct genl_info *info = &dump_info->info;\n\tint rc;\n\n\tinfo->extack = cb->extack;\n\n\tgenl_op_lock(info->family);\n\trc = ops->dumpit(skb, cb);\n\tgenl_op_unlock(info->family);\n\treturn rc;\n}\n\nstatic int genl_done(struct netlink_callback *cb)\n{\n\tstruct genl_dumpit_info *dump_info = cb->data;\n\tconst struct genl_split_ops *ops = &dump_info->op;\n\tstruct genl_info *info = &dump_info->info;\n\tint rc = 0;\n\n\tinfo->extack = cb->extack;\n\n\tif (ops->done) {\n\t\tgenl_op_lock(info->family);\n\t\trc = ops->done(cb);\n\t\tgenl_op_unlock(info->family);\n\t}\n\tgenl_family_rcv_msg_attrs_free(info->attrs);\n\tgenl_dumpit_info_free(dump_info);\n\treturn rc;\n}\n\nstatic int genl_family_rcv_msg_dumpit(const struct genl_family *family,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct nlmsghdr *nlh,\n\t\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t\t      const struct genl_split_ops *ops,\n\t\t\t\t      int hdrlen, struct net *net)\n{\n\tstruct genl_start_context ctx;\n\tstruct netlink_dump_control c = {\n\t\t.module = family->module,\n\t\t.data = &ctx,\n\t\t.start = genl_start,\n\t\t.dump = genl_dumpit,\n\t\t.done = genl_done,\n\t\t.extack = extack,\n\t};\n\tint err;\n\n\tctx.family = family;\n\tctx.nlh = nlh;\n\tctx.extack = extack;\n\tctx.ops = ops;\n\tctx.hdrlen = hdrlen;\n\n\tgenl_op_unlock(family);\n\terr = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\n\tgenl_op_lock(family);\n\n\treturn err;\n}\n\nstatic int genl_family_rcv_msg_doit(const struct genl_family *family,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct nlmsghdr *nlh,\n\t\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t\t    const struct genl_split_ops *ops,\n\t\t\t\t    int hdrlen, struct net *net)\n{\n\tstruct nlattr **attrbuf;\n\tstruct genl_info info;\n\tint err;\n\n\tattrbuf = genl_family_rcv_msg_attrs_parse(family, nlh, extack,\n\t\t\t\t\t\t  ops, hdrlen,\n\t\t\t\t\t\t  GENL_DONT_VALIDATE_STRICT);\n\tif (IS_ERR(attrbuf))\n\t\treturn PTR_ERR(attrbuf);\n\n\tinfo.snd_seq = nlh->nlmsg_seq;\n\tinfo.snd_portid = NETLINK_CB(skb).portid;\n\tinfo.family = family;\n\tinfo.nlhdr = nlh;\n\tinfo.genlhdr = nlmsg_data(nlh);\n\tinfo.attrs = attrbuf;\n\tinfo.extack = extack;\n\tgenl_info_net_set(&info, net);\n\tmemset(&info.user_ptr, 0, sizeof(info.user_ptr));\n\n\tif (ops->pre_doit) {\n\t\terr = ops->pre_doit(ops, skb, &info);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = ops->doit(skb, &info);\n\n\tif (ops->post_doit)\n\t\tops->post_doit(ops, skb, &info);\n\nout:\n\tgenl_family_rcv_msg_attrs_free(attrbuf);\n\n\treturn err;\n}\n\nstatic int genl_header_check(const struct genl_family *family,\n\t\t\t     struct nlmsghdr *nlh, struct genlmsghdr *hdr,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu16 flags;\n\n\t \n\tif (hdr->cmd < family->resv_start_op)\n\t\treturn 0;\n\n\tif (hdr->reserved) {\n\t\tNL_SET_ERR_MSG(extack, \"genlmsghdr.reserved field is not 0\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tflags = nlh->nlmsg_flags;\n\tif ((flags & NLM_F_DUMP) == NLM_F_DUMP)  \n\t\tflags &= ~NLM_F_DUMP;\n\tif (flags & ~(NLM_F_REQUEST | NLM_F_ACK | NLM_F_ECHO)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"ambiguous or reserved bits set in nlmsg_flags\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int genl_family_rcv_msg(const struct genl_family *family,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct genlmsghdr *hdr = nlmsg_data(nlh);\n\tstruct genl_split_ops op;\n\tint hdrlen;\n\tu8 flags;\n\n\t \n\tif (!family->netnsok && !net_eq(net, &init_net))\n\t\treturn -ENOENT;\n\n\thdrlen = GENL_HDRLEN + family->hdrsize;\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\n\tif (genl_header_check(family, nlh, hdr, extack))\n\t\treturn -EINVAL;\n\n\tflags = (nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP ?\n\t\tGENL_CMD_CAP_DUMP : GENL_CMD_CAP_DO;\n\tif (genl_get_cmd(hdr->cmd, flags, family, &op))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((op.flags & GENL_ADMIN_PERM) &&\n\t    !netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((op.flags & GENL_UNS_ADMIN_PERM) &&\n\t    !netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (flags & GENL_CMD_CAP_DUMP)\n\t\treturn genl_family_rcv_msg_dumpit(family, skb, nlh, extack,\n\t\t\t\t\t\t  &op, hdrlen, net);\n\telse\n\t\treturn genl_family_rcv_msg_doit(family, skb, nlh, extack,\n\t\t\t\t\t\t&op, hdrlen, net);\n}\n\nstatic int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst struct genl_family *family;\n\tint err;\n\n\tfamily = genl_family_find_byid(nlh->nlmsg_type);\n\tif (family == NULL)\n\t\treturn -ENOENT;\n\n\tgenl_op_lock(family);\n\terr = genl_family_rcv_msg(family, skb, nlh, extack);\n\tgenl_op_unlock(family);\n\n\treturn err;\n}\n\nstatic void genl_rcv(struct sk_buff *skb)\n{\n\tdown_read(&cb_lock);\n\tnetlink_rcv_skb(skb, &genl_rcv_msg);\n\tup_read(&cb_lock);\n}\n\n \n\nstatic struct genl_family genl_ctrl;\n\nstatic int ctrl_fill_info(const struct genl_family *family, u32 portid, u32 seq,\n\t\t\t  u32 flags, struct sk_buff *skb, u8 cmd)\n{\n\tstruct genl_op_iter i;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\n\tif (hdr == NULL)\n\t\treturn -1;\n\n\tif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\n\t    nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id) ||\n\t    nla_put_u32(skb, CTRL_ATTR_VERSION, family->version) ||\n\t    nla_put_u32(skb, CTRL_ATTR_HDRSIZE, family->hdrsize) ||\n\t    nla_put_u32(skb, CTRL_ATTR_MAXATTR, family->maxattr))\n\t\tgoto nla_put_failure;\n\n\tif (genl_op_iter_init(family, &i)) {\n\t\tstruct nlattr *nla_ops;\n\n\t\tnla_ops = nla_nest_start_noflag(skb, CTRL_ATTR_OPS);\n\t\tif (nla_ops == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\twhile (genl_op_iter_next(&i)) {\n\t\t\tstruct nlattr *nest;\n\t\t\tu32 op_flags;\n\n\t\t\top_flags = i.flags;\n\t\t\tif (i.doit.policy || i.dumpit.policy)\n\t\t\t\top_flags |= GENL_CMD_CAP_HASPOL;\n\n\t\t\tnest = nla_nest_start_noflag(skb, genl_op_iter_idx(&i));\n\t\t\tif (nest == NULL)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(skb, CTRL_ATTR_OP_ID, i.cmd) ||\n\t\t\t    nla_put_u32(skb, CTRL_ATTR_OP_FLAGS, op_flags))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\n\t\tnla_nest_end(skb, nla_ops);\n\t}\n\n\tif (family->n_mcgrps) {\n\t\tstruct nlattr *nla_grps;\n\t\tint i;\n\n\t\tnla_grps = nla_nest_start_noflag(skb, CTRL_ATTR_MCAST_GROUPS);\n\t\tif (nla_grps == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < family->n_mcgrps; i++) {\n\t\t\tstruct nlattr *nest;\n\t\t\tconst struct genl_multicast_group *grp;\n\n\t\t\tgrp = &family->mcgrps[i];\n\n\t\t\tnest = nla_nest_start_noflag(skb, i + 1);\n\t\t\tif (nest == NULL)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID,\n\t\t\t\t\tfamily->mcgrp_offset + i) ||\n\t\t\t    nla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\n\t\t\t\t\t   grp->name))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\t\tnla_nest_end(skb, nla_grps);\n\t}\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ctrl_fill_mcgrp_info(const struct genl_family *family,\n\t\t\t\tconst struct genl_multicast_group *grp,\n\t\t\t\tint grp_id, u32 portid, u32 seq, u32 flags,\n\t\t\t\tstruct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\tstruct nlattr *nla_grps;\n\tstruct nlattr *nest;\n\n\thdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\n\tif (hdr == NULL)\n\t\treturn -1;\n\n\tif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\n\t    nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id))\n\t\tgoto nla_put_failure;\n\n\tnla_grps = nla_nest_start_noflag(skb, CTRL_ATTR_MCAST_GROUPS);\n\tif (nla_grps == NULL)\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, 1);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID, grp_id) ||\n\t    nla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\n\t\t\t   grp->name))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\tnla_nest_end(skb, nla_grps);\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ctrl_dumpfamily(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint n = 0;\n\tstruct genl_family *rt;\n\tstruct net *net = sock_net(skb->sk);\n\tint fams_to_skip = cb->args[0];\n\tunsigned int id;\n\n\tidr_for_each_entry(&genl_fam_idr, rt, id) {\n\t\tif (!rt->netnsok && !net_eq(net, &init_net))\n\t\t\tcontinue;\n\n\t\tif (n++ < fams_to_skip)\n\t\t\tcontinue;\n\n\t\tif (ctrl_fill_info(rt, NETLINK_CB(cb->skb).portid,\n\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t   skb, CTRL_CMD_NEWFAMILY) < 0) {\n\t\t\tn--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb->args[0] = n;\n\treturn skb->len;\n}\n\nstatic struct sk_buff *ctrl_build_family_msg(const struct genl_family *family,\n\t\t\t\t\t     u32 portid, int seq, u8 cmd)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\terr = ctrl_fill_info(family, portid, seq, 0, skb, cmd);\n\tif (err < 0) {\n\t\tnlmsg_free(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nctrl_build_mcgrp_msg(const struct genl_family *family,\n\t\t     const struct genl_multicast_group *grp,\n\t\t     int grp_id, u32 portid, int seq, u8 cmd)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\terr = ctrl_fill_mcgrp_info(family, grp, grp_id, portid,\n\t\t\t\t   seq, 0, skb, cmd);\n\tif (err < 0) {\n\t\tnlmsg_free(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic const struct nla_policy ctrl_policy_family[] = {\n\t[CTRL_ATTR_FAMILY_ID]\t= { .type = NLA_U16 },\n\t[CTRL_ATTR_FAMILY_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = GENL_NAMSIZ - 1 },\n};\n\nstatic int ctrl_getfamily(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tconst struct genl_family *res = NULL;\n\tint err = -EINVAL;\n\n\tif (info->attrs[CTRL_ATTR_FAMILY_ID]) {\n\t\tu16 id = nla_get_u16(info->attrs[CTRL_ATTR_FAMILY_ID]);\n\t\tres = genl_family_find_byid(id);\n\t\terr = -ENOENT;\n\t}\n\n\tif (info->attrs[CTRL_ATTR_FAMILY_NAME]) {\n\t\tchar *name;\n\n\t\tname = nla_data(info->attrs[CTRL_ATTR_FAMILY_NAME]);\n\t\tres = genl_family_find_byname(name);\n#ifdef CONFIG_MODULES\n\t\tif (res == NULL) {\n\t\t\tgenl_unlock();\n\t\t\tup_read(&cb_lock);\n\t\t\trequest_module(\"net-pf-%d-proto-%d-family-%s\",\n\t\t\t\t       PF_NETLINK, NETLINK_GENERIC, name);\n\t\t\tdown_read(&cb_lock);\n\t\t\tgenl_lock();\n\t\t\tres = genl_family_find_byname(name);\n\t\t}\n#endif\n\t\terr = -ENOENT;\n\t}\n\n\tif (res == NULL)\n\t\treturn err;\n\n\tif (!res->netnsok && !net_eq(genl_info_net(info), &init_net)) {\n\t\t \n\t\treturn -ENOENT;\n\t}\n\n\tmsg = ctrl_build_family_msg(res, info->snd_portid, info->snd_seq,\n\t\t\t\t    CTRL_CMD_NEWFAMILY);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int genl_ctrl_event(int event, const struct genl_family *family,\n\t\t\t   const struct genl_multicast_group *grp,\n\t\t\t   int grp_id)\n{\n\tstruct sk_buff *msg;\n\n\t \n\tif (!init_net.genl_sock)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase CTRL_CMD_NEWFAMILY:\n\tcase CTRL_CMD_DELFAMILY:\n\t\tWARN_ON(grp);\n\t\tmsg = ctrl_build_family_msg(family, 0, 0, event);\n\t\tbreak;\n\tcase CTRL_CMD_NEWMCAST_GRP:\n\tcase CTRL_CMD_DELMCAST_GRP:\n\t\tBUG_ON(!grp);\n\t\tmsg = ctrl_build_mcgrp_msg(family, grp, grp_id, 0, 0, event);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tif (!family->netnsok) {\n\t\tgenlmsg_multicast_netns(&genl_ctrl, &init_net, msg, 0,\n\t\t\t\t\t0, GFP_KERNEL);\n\t} else {\n\t\trcu_read_lock();\n\t\tgenlmsg_multicast_allns(&genl_ctrl, msg, 0,\n\t\t\t\t\t0, GFP_ATOMIC);\n\t\trcu_read_unlock();\n\t}\n\n\treturn 0;\n}\n\nstruct ctrl_dump_policy_ctx {\n\tstruct netlink_policy_dump_state *state;\n\tconst struct genl_family *rt;\n\tstruct genl_op_iter *op_iter;\n\tu32 op;\n\tu16 fam_id;\n\tu8 dump_map:1,\n\t   single_op:1;\n};\n\nstatic const struct nla_policy ctrl_policy_policy[] = {\n\t[CTRL_ATTR_FAMILY_ID]\t= { .type = NLA_U16 },\n\t[CTRL_ATTR_FAMILY_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = GENL_NAMSIZ - 1 },\n\t[CTRL_ATTR_OP]\t\t= { .type = NLA_U32 },\n};\n\nstatic int ctrl_dumppolicy_start(struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct ctrl_dump_policy_ctx *ctx = (void *)cb->ctx;\n\tstruct nlattr **tb = info->info.attrs;\n\tconst struct genl_family *rt;\n\tstruct genl_op_iter i;\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(*ctx) > sizeof(cb->ctx));\n\n\tif (!tb[CTRL_ATTR_FAMILY_ID] && !tb[CTRL_ATTR_FAMILY_NAME])\n\t\treturn -EINVAL;\n\n\tif (tb[CTRL_ATTR_FAMILY_ID]) {\n\t\tctx->fam_id = nla_get_u16(tb[CTRL_ATTR_FAMILY_ID]);\n\t} else {\n\t\trt = genl_family_find_byname(\n\t\t\tnla_data(tb[CTRL_ATTR_FAMILY_NAME]));\n\t\tif (!rt)\n\t\t\treturn -ENOENT;\n\t\tctx->fam_id = rt->id;\n\t}\n\n\trt = genl_family_find_byid(ctx->fam_id);\n\tif (!rt)\n\t\treturn -ENOENT;\n\n\tctx->rt = rt;\n\n\tif (tb[CTRL_ATTR_OP]) {\n\t\tstruct genl_split_ops doit, dump;\n\n\t\tctx->single_op = true;\n\t\tctx->op = nla_get_u32(tb[CTRL_ATTR_OP]);\n\n\t\terr = genl_get_cmd_both(ctx->op, rt, &doit, &dump);\n\t\tif (err) {\n\t\t\tNL_SET_BAD_ATTR(cb->extack, tb[CTRL_ATTR_OP]);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (doit.policy) {\n\t\t\terr = netlink_policy_dump_add_policy(&ctx->state,\n\t\t\t\t\t\t\t     doit.policy,\n\t\t\t\t\t\t\t     doit.maxattr);\n\t\t\tif (err)\n\t\t\t\tgoto err_free_state;\n\t\t}\n\t\tif (dump.policy) {\n\t\t\terr = netlink_policy_dump_add_policy(&ctx->state,\n\t\t\t\t\t\t\t     dump.policy,\n\t\t\t\t\t\t\t     dump.maxattr);\n\t\t\tif (err)\n\t\t\t\tgoto err_free_state;\n\t\t}\n\n\t\tif (!ctx->state)\n\t\t\treturn -ENODATA;\n\n\t\tctx->dump_map = 1;\n\t\treturn 0;\n\t}\n\n\tctx->op_iter = kmalloc(sizeof(*ctx->op_iter), GFP_KERNEL);\n\tif (!ctx->op_iter)\n\t\treturn -ENOMEM;\n\n\tgenl_op_iter_init(rt, ctx->op_iter);\n\tctx->dump_map = genl_op_iter_next(ctx->op_iter);\n\n\tfor (genl_op_iter_init(rt, &i); genl_op_iter_next(&i); ) {\n\t\tif (i.doit.policy) {\n\t\t\terr = netlink_policy_dump_add_policy(&ctx->state,\n\t\t\t\t\t\t\t     i.doit.policy,\n\t\t\t\t\t\t\t     i.doit.maxattr);\n\t\t\tif (err)\n\t\t\t\tgoto err_free_state;\n\t\t}\n\t\tif (i.dumpit.policy) {\n\t\t\terr = netlink_policy_dump_add_policy(&ctx->state,\n\t\t\t\t\t\t\t     i.dumpit.policy,\n\t\t\t\t\t\t\t     i.dumpit.maxattr);\n\t\t\tif (err)\n\t\t\t\tgoto err_free_state;\n\t\t}\n\t}\n\n\tif (!ctx->state) {\n\t\terr = -ENODATA;\n\t\tgoto err_free_op_iter;\n\t}\n\treturn 0;\n\nerr_free_state:\n\tnetlink_policy_dump_free(ctx->state);\nerr_free_op_iter:\n\tkfree(ctx->op_iter);\n\treturn err;\n}\n\nstatic void *ctrl_dumppolicy_prep(struct sk_buff *skb,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\tstruct ctrl_dump_policy_ctx *ctx = (void *)cb->ctx;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t  cb->nlh->nlmsg_seq, &genl_ctrl,\n\t\t\t  NLM_F_MULTI, CTRL_CMD_GETPOLICY);\n\tif (!hdr)\n\t\treturn NULL;\n\n\tif (nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, ctx->fam_id))\n\t\treturn NULL;\n\n\treturn hdr;\n}\n\nstatic int ctrl_dumppolicy_put_op(struct sk_buff *skb,\n\t\t\t\t  struct netlink_callback *cb,\n\t\t\t\t  struct genl_split_ops *doit,\n\t\t\t\t  struct genl_split_ops *dumpit)\n{\n\tstruct ctrl_dump_policy_ctx *ctx = (void *)cb->ctx;\n\tstruct nlattr *nest_pol, *nest_op;\n\tvoid *hdr;\n\tint idx;\n\n\t \n\tif (!doit->policy && !dumpit->policy)\n\t\treturn 0;\n\n\thdr = ctrl_dumppolicy_prep(skb, cb);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tnest_pol = nla_nest_start(skb, CTRL_ATTR_OP_POLICY);\n\tif (!nest_pol)\n\t\tgoto err;\n\n\tnest_op = nla_nest_start(skb, doit->cmd);\n\tif (!nest_op)\n\t\tgoto err;\n\n\tif (doit->policy) {\n\t\tidx = netlink_policy_dump_get_policy_idx(ctx->state,\n\t\t\t\t\t\t\t doit->policy,\n\t\t\t\t\t\t\t doit->maxattr);\n\n\t\tif (nla_put_u32(skb, CTRL_ATTR_POLICY_DO, idx))\n\t\t\tgoto err;\n\t}\n\tif (dumpit->policy) {\n\t\tidx = netlink_policy_dump_get_policy_idx(ctx->state,\n\t\t\t\t\t\t\t dumpit->policy,\n\t\t\t\t\t\t\t dumpit->maxattr);\n\n\t\tif (nla_put_u32(skb, CTRL_ATTR_POLICY_DUMP, idx))\n\t\t\tgoto err;\n\t}\n\n\tnla_nest_end(skb, nest_op);\n\tnla_nest_end(skb, nest_pol);\n\tgenlmsg_end(skb, hdr);\n\n\treturn 0;\nerr:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -ENOBUFS;\n}\n\nstatic int ctrl_dumppolicy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct ctrl_dump_policy_ctx *ctx = (void *)cb->ctx;\n\tvoid *hdr;\n\n\tif (ctx->dump_map) {\n\t\tif (ctx->single_op) {\n\t\t\tstruct genl_split_ops doit, dumpit;\n\n\t\t\tif (WARN_ON(genl_get_cmd_both(ctx->op, ctx->rt,\n\t\t\t\t\t\t      &doit, &dumpit)))\n\t\t\t\treturn -ENOENT;\n\n\t\t\tif (ctrl_dumppolicy_put_op(skb, cb, &doit, &dumpit))\n\t\t\t\treturn skb->len;\n\n\t\t\t \n\t\t\tctx->dump_map = 0;\n\t\t}\n\n\t\twhile (ctx->dump_map) {\n\t\t\tif (ctrl_dumppolicy_put_op(skb, cb,\n\t\t\t\t\t\t   &ctx->op_iter->doit,\n\t\t\t\t\t\t   &ctx->op_iter->dumpit))\n\t\t\t\treturn skb->len;\n\n\t\t\tctx->dump_map = genl_op_iter_next(ctx->op_iter);\n\t\t}\n\t}\n\n\twhile (netlink_policy_dump_loop(ctx->state)) {\n\t\tstruct nlattr *nest;\n\n\t\thdr = ctrl_dumppolicy_prep(skb, cb);\n\t\tif (!hdr)\n\t\t\tgoto nla_put_failure;\n\n\t\tnest = nla_nest_start(skb, CTRL_ATTR_POLICY);\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (netlink_policy_dump_write(skb, ctx->state))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, nest);\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\treturn skb->len;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn skb->len;\n}\n\nstatic int ctrl_dumppolicy_done(struct netlink_callback *cb)\n{\n\tstruct ctrl_dump_policy_ctx *ctx = (void *)cb->ctx;\n\n\tkfree(ctx->op_iter);\n\tnetlink_policy_dump_free(ctx->state);\n\treturn 0;\n}\n\nstatic const struct genl_split_ops genl_ctrl_ops[] = {\n\t{\n\t\t.cmd\t\t= CTRL_CMD_GETFAMILY,\n\t\t.validate\t= GENL_DONT_VALIDATE_STRICT,\n\t\t.policy\t\t= ctrl_policy_family,\n\t\t.maxattr\t= ARRAY_SIZE(ctrl_policy_family) - 1,\n\t\t.doit\t\t= ctrl_getfamily,\n\t\t.flags\t\t= GENL_CMD_CAP_DO,\n\t},\n\t{\n\t\t.cmd\t\t= CTRL_CMD_GETFAMILY,\n\t\t.validate\t= GENL_DONT_VALIDATE_DUMP,\n\t\t.policy\t\t= ctrl_policy_family,\n\t\t.maxattr\t= ARRAY_SIZE(ctrl_policy_family) - 1,\n\t\t.dumpit\t\t= ctrl_dumpfamily,\n\t\t.flags\t\t= GENL_CMD_CAP_DUMP,\n\t},\n\t{\n\t\t.cmd\t\t= CTRL_CMD_GETPOLICY,\n\t\t.policy\t\t= ctrl_policy_policy,\n\t\t.maxattr\t= ARRAY_SIZE(ctrl_policy_policy) - 1,\n\t\t.start\t\t= ctrl_dumppolicy_start,\n\t\t.dumpit\t\t= ctrl_dumppolicy,\n\t\t.done\t\t= ctrl_dumppolicy_done,\n\t\t.flags\t\t= GENL_CMD_CAP_DUMP,\n\t},\n};\n\nstatic const struct genl_multicast_group genl_ctrl_groups[] = {\n\t{ .name = \"notify\", },\n};\n\nstatic struct genl_family genl_ctrl __ro_after_init = {\n\t.module = THIS_MODULE,\n\t.split_ops = genl_ctrl_ops,\n\t.n_split_ops = ARRAY_SIZE(genl_ctrl_ops),\n\t.resv_start_op = CTRL_CMD_GETPOLICY + 1,\n\t.mcgrps = genl_ctrl_groups,\n\t.n_mcgrps = ARRAY_SIZE(genl_ctrl_groups),\n\t.id = GENL_ID_CTRL,\n\t.name = \"nlctrl\",\n\t.version = 0x2,\n\t.netnsok = true,\n};\n\nstatic int genl_bind(struct net *net, int group)\n{\n\tconst struct genl_family *family;\n\tunsigned int id;\n\tint ret = 0;\n\n\tdown_read(&cb_lock);\n\n\tidr_for_each_entry(&genl_fam_idr, family, id) {\n\t\tconst struct genl_multicast_group *grp;\n\t\tint i;\n\n\t\tif (family->n_mcgrps == 0)\n\t\t\tcontinue;\n\n\t\ti = group - family->mcgrp_offset;\n\t\tif (i < 0 || i >= family->n_mcgrps)\n\t\t\tcontinue;\n\n\t\tgrp = &family->mcgrps[i];\n\t\tif ((grp->flags & GENL_UNS_ADMIN_PERM) &&\n\t\t    !ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\tif (grp->cap_sys_admin &&\n\t\t    !ns_capable(net->user_ns, CAP_SYS_ADMIN))\n\t\t\tret = -EPERM;\n\n\t\tbreak;\n\t}\n\n\tup_read(&cb_lock);\n\treturn ret;\n}\n\nstatic int __net_init genl_pernet_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t\t= genl_rcv,\n\t\t.flags\t\t= NL_CFG_F_NONROOT_RECV,\n\t\t.bind\t\t= genl_bind,\n\t};\n\n\t \n\tnet->genl_sock = netlink_kernel_create(net, NETLINK_GENERIC, &cfg);\n\n\tif (!net->genl_sock && net_eq(net, &init_net))\n\t\tpanic(\"GENL: Cannot initialize generic netlink\\n\");\n\n\tif (!net->genl_sock)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit genl_pernet_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->genl_sock);\n\tnet->genl_sock = NULL;\n}\n\nstatic struct pernet_operations genl_pernet_ops = {\n\t.init = genl_pernet_init,\n\t.exit = genl_pernet_exit,\n};\n\nstatic int __init genl_init(void)\n{\n\tint err;\n\n\terr = genl_register_family(&genl_ctrl);\n\tif (err < 0)\n\t\tgoto problem;\n\n\terr = register_pernet_subsys(&genl_pernet_ops);\n\tif (err)\n\t\tgoto problem;\n\n\treturn 0;\n\nproblem:\n\tpanic(\"GENL: Cannot register controller: %d\\n\", err);\n}\n\ncore_initcall(genl_init);\n\nstatic int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group,\n\t\t\t gfp_t flags)\n{\n\tstruct sk_buff *tmp;\n\tstruct net *net, *prev = NULL;\n\tbool delivered = false;\n\tint err;\n\n\tfor_each_net_rcu(net) {\n\t\tif (prev) {\n\t\t\ttmp = skb_clone(skb, flags);\n\t\t\tif (!tmp) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = nlmsg_multicast(prev->genl_sock, tmp,\n\t\t\t\t\t      portid, group, flags);\n\t\t\tif (!err)\n\t\t\t\tdelivered = true;\n\t\t\telse if (err != -ESRCH)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tprev = net;\n\t}\n\n\terr = nlmsg_multicast(prev->genl_sock, skb, portid, group, flags);\n\tif (!err)\n\t\tdelivered = true;\n\telse if (err != -ESRCH)\n\t\treturn err;\n\treturn delivered ? 0 : -ESRCH;\n error:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nint genlmsg_multicast_allns(const struct genl_family *family,\n\t\t\t    struct sk_buff *skb, u32 portid,\n\t\t\t    unsigned int group, gfp_t flags)\n{\n\tif (WARN_ON_ONCE(group >= family->n_mcgrps))\n\t\treturn -EINVAL;\n\n\tgroup = family->mcgrp_offset + group;\n\treturn genlmsg_mcast(skb, portid, group, flags);\n}\nEXPORT_SYMBOL(genlmsg_multicast_allns);\n\nvoid genl_notify(const struct genl_family *family, struct sk_buff *skb,\n\t\t struct genl_info *info, u32 group, gfp_t flags)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct sock *sk = net->genl_sock;\n\n\tif (WARN_ON_ONCE(group >= family->n_mcgrps))\n\t\treturn;\n\n\tgroup = family->mcgrp_offset + group;\n\tnlmsg_notify(sk, skb, info->snd_portid, group,\n\t\t     nlmsg_report(info->nlhdr), flags);\n}\nEXPORT_SYMBOL(genl_notify);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}