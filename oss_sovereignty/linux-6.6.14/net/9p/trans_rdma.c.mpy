{
  "module_name": "trans_rdma.c",
  "hash_id": "7a6f0627e1fb8d543b082ad3eb9507927ff7dccdd75717d31efeb3bc2ede4fe6",
  "original_prompt": "Ingested from linux-6.6.14/net/9p/trans_rdma.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/in.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/ipv6.h>\n#include <linux/kthread.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/un.h>\n#include <linux/uaccess.h>\n#include <linux/inet.h>\n#include <linux/file.h>\n#include <linux/parser.h>\n#include <linux/semaphore.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n#include <net/9p/transport.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/rdma_cm.h>\n\n#define P9_PORT\t\t\t5640\n#define P9_RDMA_SQ_DEPTH\t32\n#define P9_RDMA_RQ_DEPTH\t32\n#define P9_RDMA_SEND_SGE\t4\n#define P9_RDMA_RECV_SGE\t4\n#define P9_RDMA_IRD\t\t0\n#define P9_RDMA_ORD\t\t0\n#define P9_RDMA_TIMEOUT\t\t30000\t\t \n#define P9_RDMA_MAXSIZE\t\t(1024*1024)\t \n\n \nstruct p9_trans_rdma {\n\tenum {\n\t\tP9_RDMA_INIT,\n\t\tP9_RDMA_ADDR_RESOLVED,\n\t\tP9_RDMA_ROUTE_RESOLVED,\n\t\tP9_RDMA_CONNECTED,\n\t\tP9_RDMA_FLUSHING,\n\t\tP9_RDMA_CLOSING,\n\t\tP9_RDMA_CLOSED,\n\t} state;\n\tstruct rdma_cm_id *cm_id;\n\tstruct ib_pd *pd;\n\tstruct ib_qp *qp;\n\tstruct ib_cq *cq;\n\tlong timeout;\n\tbool privport;\n\tu16 port;\n\tint sq_depth;\n\tstruct semaphore sq_sem;\n\tint rq_depth;\n\tstruct semaphore rq_sem;\n\tatomic_t excess_rc;\n\tstruct sockaddr_in addr;\n\tspinlock_t req_lock;\n\n\tstruct completion cm_done;\n};\n\nstruct p9_rdma_req;\n\n \nstruct p9_rdma_context {\n\tstruct ib_cqe cqe;\n\tdma_addr_t busa;\n\tunion {\n\t\tstruct p9_req_t *req;\n\t\tstruct p9_fcall rc;\n\t};\n};\n\n \nstruct p9_rdma_opts {\n\tshort port;\n\tbool privport;\n\tint sq_depth;\n\tint rq_depth;\n\tlong timeout;\n};\n\n \nenum {\n\t \n\tOpt_port, Opt_rq_depth, Opt_sq_depth, Opt_timeout,\n\t \n\tOpt_privport,\n\tOpt_err,\n};\n\nstatic match_table_t tokens = {\n\t{Opt_port, \"port=%u\"},\n\t{Opt_sq_depth, \"sq=%u\"},\n\t{Opt_rq_depth, \"rq=%u\"},\n\t{Opt_timeout, \"timeout=%u\"},\n\t{Opt_privport, \"privport\"},\n\t{Opt_err, NULL},\n};\n\nstatic int p9_rdma_show_options(struct seq_file *m, struct p9_client *clnt)\n{\n\tstruct p9_trans_rdma *rdma = clnt->trans;\n\n\tif (rdma->port != P9_PORT)\n\t\tseq_printf(m, \",port=%u\", rdma->port);\n\tif (rdma->sq_depth != P9_RDMA_SQ_DEPTH)\n\t\tseq_printf(m, \",sq=%u\", rdma->sq_depth);\n\tif (rdma->rq_depth != P9_RDMA_RQ_DEPTH)\n\t\tseq_printf(m, \",rq=%u\", rdma->rq_depth);\n\tif (rdma->timeout != P9_RDMA_TIMEOUT)\n\t\tseq_printf(m, \",timeout=%lu\", rdma->timeout);\n\tif (rdma->privport)\n\t\tseq_puts(m, \",privport\");\n\treturn 0;\n}\n\n \nstatic int parse_opts(char *params, struct p9_rdma_opts *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tchar *options, *tmp_options;\n\n\topts->port = P9_PORT;\n\topts->sq_depth = P9_RDMA_SQ_DEPTH;\n\topts->rq_depth = P9_RDMA_RQ_DEPTH;\n\topts->timeout = P9_RDMA_TIMEOUT;\n\topts->privport = false;\n\n\tif (!params)\n\t\treturn 0;\n\n\ttmp_options = kstrdup(params, GFP_KERNEL);\n\tif (!tmp_options) {\n\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t \"failed to allocate copy of option string\\n\");\n\t\treturn -ENOMEM;\n\t}\n\toptions = tmp_options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tint r;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tif ((token != Opt_err) && (token != Opt_privport)) {\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswitch (token) {\n\t\tcase Opt_port:\n\t\t\topts->port = option;\n\t\t\tbreak;\n\t\tcase Opt_sq_depth:\n\t\t\topts->sq_depth = option;\n\t\t\tbreak;\n\t\tcase Opt_rq_depth:\n\t\t\topts->rq_depth = option;\n\t\t\tbreak;\n\t\tcase Opt_timeout:\n\t\t\topts->timeout = option;\n\t\t\tbreak;\n\t\tcase Opt_privport:\n\t\t\topts->privport = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\t \n\topts->rq_depth = max(opts->rq_depth, opts->sq_depth);\n\tkfree(tmp_options);\n\treturn 0;\n}\n\nstatic int\np9_cm_event_handler(struct rdma_cm_id *id, struct rdma_cm_event *event)\n{\n\tstruct p9_client *c = id->context;\n\tstruct p9_trans_rdma *rdma = c->trans;\n\tswitch (event->event) {\n\tcase RDMA_CM_EVENT_ADDR_RESOLVED:\n\t\tBUG_ON(rdma->state != P9_RDMA_INIT);\n\t\trdma->state = P9_RDMA_ADDR_RESOLVED;\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_ROUTE_RESOLVED:\n\t\tBUG_ON(rdma->state != P9_RDMA_ADDR_RESOLVED);\n\t\trdma->state = P9_RDMA_ROUTE_RESOLVED;\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_ESTABLISHED:\n\t\tBUG_ON(rdma->state != P9_RDMA_ROUTE_RESOLVED);\n\t\trdma->state = P9_RDMA_CONNECTED;\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_DISCONNECTED:\n\t\tif (rdma)\n\t\t\trdma->state = P9_RDMA_CLOSED;\n\t\tc->status = Disconnected;\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_TIMEWAIT_EXIT:\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_ADDR_CHANGE:\n\tcase RDMA_CM_EVENT_ROUTE_ERROR:\n\tcase RDMA_CM_EVENT_DEVICE_REMOVAL:\n\tcase RDMA_CM_EVENT_MULTICAST_JOIN:\n\tcase RDMA_CM_EVENT_MULTICAST_ERROR:\n\tcase RDMA_CM_EVENT_REJECTED:\n\tcase RDMA_CM_EVENT_CONNECT_REQUEST:\n\tcase RDMA_CM_EVENT_CONNECT_RESPONSE:\n\tcase RDMA_CM_EVENT_CONNECT_ERROR:\n\tcase RDMA_CM_EVENT_ADDR_ERROR:\n\tcase RDMA_CM_EVENT_UNREACHABLE:\n\t\tc->status = Disconnected;\n\t\trdma_disconnect(rdma->cm_id);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tcomplete(&rdma->cm_done);\n\treturn 0;\n}\n\nstatic void\nrecv_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct p9_client *client = cq->cq_context;\n\tstruct p9_trans_rdma *rdma = client->trans;\n\tstruct p9_rdma_context *c =\n\t\tcontainer_of(wc->wr_cqe, struct p9_rdma_context, cqe);\n\tstruct p9_req_t *req;\n\tint err = 0;\n\tint16_t tag;\n\n\treq = NULL;\n\tib_dma_unmap_single(rdma->cm_id->device, c->busa, client->msize,\n\t\t\t\t\t\t\t DMA_FROM_DEVICE);\n\n\tif (wc->status != IB_WC_SUCCESS)\n\t\tgoto err_out;\n\n\tc->rc.size = wc->byte_len;\n\terr = p9_parse_header(&c->rc, NULL, NULL, &tag, 1);\n\tif (err)\n\t\tgoto err_out;\n\n\treq = p9_tag_lookup(client, tag);\n\tif (!req)\n\t\tgoto err_out;\n\n\t \n\tif (unlikely(req->rc.sdata)) {\n\t\tpr_err(\"Duplicate reply for request %d\", tag);\n\t\tgoto err_out;\n\t}\n\n\treq->rc.size = c->rc.size;\n\treq->rc.sdata = c->rc.sdata;\n\tp9_client_cb(client, req, REQ_STATUS_RCVD);\n\n out:\n\tup(&rdma->rq_sem);\n\tkfree(c);\n\treturn;\n\n err_out:\n\tp9_debug(P9_DEBUG_ERROR, \"req %p err %d status %d\\n\",\n\t\t\treq, err, wc->status);\n\trdma->state = P9_RDMA_FLUSHING;\n\tclient->status = Disconnected;\n\tgoto out;\n}\n\nstatic void\nsend_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct p9_client *client = cq->cq_context;\n\tstruct p9_trans_rdma *rdma = client->trans;\n\tstruct p9_rdma_context *c =\n\t\tcontainer_of(wc->wr_cqe, struct p9_rdma_context, cqe);\n\n\tib_dma_unmap_single(rdma->cm_id->device,\n\t\t\t    c->busa, c->req->tc.size,\n\t\t\t    DMA_TO_DEVICE);\n\tup(&rdma->sq_sem);\n\tp9_req_put(client, c->req);\n\tkfree(c);\n}\n\nstatic void qp_event_handler(struct ib_event *event, void *context)\n{\n\tp9_debug(P9_DEBUG_ERROR, \"QP event %d context %p\\n\",\n\t\t event->event, context);\n}\n\nstatic void rdma_destroy_trans(struct p9_trans_rdma *rdma)\n{\n\tif (!rdma)\n\t\treturn;\n\n\tif (rdma->qp && !IS_ERR(rdma->qp))\n\t\tib_destroy_qp(rdma->qp);\n\n\tif (rdma->pd && !IS_ERR(rdma->pd))\n\t\tib_dealloc_pd(rdma->pd);\n\n\tif (rdma->cq && !IS_ERR(rdma->cq))\n\t\tib_free_cq(rdma->cq);\n\n\tif (rdma->cm_id && !IS_ERR(rdma->cm_id))\n\t\trdma_destroy_id(rdma->cm_id);\n\n\tkfree(rdma);\n}\n\nstatic int\npost_recv(struct p9_client *client, struct p9_rdma_context *c)\n{\n\tstruct p9_trans_rdma *rdma = client->trans;\n\tstruct ib_recv_wr wr;\n\tstruct ib_sge sge;\n\tint ret;\n\n\tc->busa = ib_dma_map_single(rdma->cm_id->device,\n\t\t\t\t    c->rc.sdata, client->msize,\n\t\t\t\t    DMA_FROM_DEVICE);\n\tif (ib_dma_mapping_error(rdma->cm_id->device, c->busa))\n\t\tgoto error;\n\n\tc->cqe.done = recv_done;\n\n\tsge.addr = c->busa;\n\tsge.length = client->msize;\n\tsge.lkey = rdma->pd->local_dma_lkey;\n\n\twr.next = NULL;\n\twr.wr_cqe = &c->cqe;\n\twr.sg_list = &sge;\n\twr.num_sge = 1;\n\n\tret = ib_post_recv(rdma->qp, &wr, NULL);\n\tif (ret)\n\t\tib_dma_unmap_single(rdma->cm_id->device, c->busa,\n\t\t\t\t    client->msize, DMA_FROM_DEVICE);\n\treturn ret;\n\n error:\n\tp9_debug(P9_DEBUG_ERROR, \"EIO\\n\");\n\treturn -EIO;\n}\n\nstatic int rdma_request(struct p9_client *client, struct p9_req_t *req)\n{\n\tstruct p9_trans_rdma *rdma = client->trans;\n\tstruct ib_send_wr wr;\n\tstruct ib_sge sge;\n\tint err = 0;\n\tunsigned long flags;\n\tstruct p9_rdma_context *c = NULL;\n\tstruct p9_rdma_context *rpl_context = NULL;\n\n\t \n\tif (unlikely(atomic_read(&rdma->excess_rc) > 0)) {\n\t\tif ((atomic_sub_return(1, &rdma->excess_rc) >= 0)) {\n\t\t\t \n\t\t\tp9_fcall_fini(&req->rc);\n\t\t\treq->rc.sdata = NULL;\n\t\t\tgoto dont_need_post_recv;\n\t\t} else {\n\t\t\t \n\t\t\tatomic_inc(&rdma->excess_rc);\n\t\t}\n\t}\n\n\t \n\trpl_context = kmalloc(sizeof *rpl_context, GFP_NOFS);\n\tif (!rpl_context) {\n\t\terr = -ENOMEM;\n\t\tgoto recv_error;\n\t}\n\trpl_context->rc.sdata = req->rc.sdata;\n\n\t \n\tif (down_interruptible(&rdma->rq_sem)) {\n\t\terr = -EINTR;\n\t\tgoto recv_error;\n\t}\n\n\terr = post_recv(client, rpl_context);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"POST RECV failed: %d\\n\", err);\n\t\tgoto recv_error;\n\t}\n\t \n\treq->rc.sdata = NULL;\n\ndont_need_post_recv:\n\t \n\tc = kmalloc(sizeof *c, GFP_NOFS);\n\tif (!c) {\n\t\terr = -ENOMEM;\n\t\tgoto send_error;\n\t}\n\tc->req = req;\n\n\tc->busa = ib_dma_map_single(rdma->cm_id->device,\n\t\t\t\t    c->req->tc.sdata, c->req->tc.size,\n\t\t\t\t    DMA_TO_DEVICE);\n\tif (ib_dma_mapping_error(rdma->cm_id->device, c->busa)) {\n\t\terr = -EIO;\n\t\tgoto send_error;\n\t}\n\n\tc->cqe.done = send_done;\n\n\tsge.addr = c->busa;\n\tsge.length = c->req->tc.size;\n\tsge.lkey = rdma->pd->local_dma_lkey;\n\n\twr.next = NULL;\n\twr.wr_cqe = &c->cqe;\n\twr.opcode = IB_WR_SEND;\n\twr.send_flags = IB_SEND_SIGNALED;\n\twr.sg_list = &sge;\n\twr.num_sge = 1;\n\n\tif (down_interruptible(&rdma->sq_sem)) {\n\t\terr = -EINTR;\n\t\tgoto dma_unmap;\n\t}\n\n\t \n\tWRITE_ONCE(req->status, REQ_STATUS_SENT);\n\terr = ib_post_send(rdma->qp, &wr, NULL);\n\tif (err)\n\t\tgoto dma_unmap;\n\n\t \n\treturn 0;\n\ndma_unmap:\n\tib_dma_unmap_single(rdma->cm_id->device, c->busa,\n\t\t\t    c->req->tc.size, DMA_TO_DEVICE);\n  \n send_error:\n\tWRITE_ONCE(req->status, REQ_STATUS_ERROR);\n\tkfree(c);\n\tp9_debug(P9_DEBUG_ERROR, \"Error %d in rdma_request()\\n\", err);\n\n\t \n\tatomic_inc(&rdma->excess_rc);\n\treturn err;\n\n  \n recv_error:\n\tkfree(rpl_context);\n\tspin_lock_irqsave(&rdma->req_lock, flags);\n\tif (err != -EINTR && rdma->state < P9_RDMA_CLOSING) {\n\t\trdma->state = P9_RDMA_CLOSING;\n\t\tspin_unlock_irqrestore(&rdma->req_lock, flags);\n\t\trdma_disconnect(rdma->cm_id);\n\t} else\n\t\tspin_unlock_irqrestore(&rdma->req_lock, flags);\n\treturn err;\n}\n\nstatic void rdma_close(struct p9_client *client)\n{\n\tstruct p9_trans_rdma *rdma;\n\n\tif (!client)\n\t\treturn;\n\n\trdma = client->trans;\n\tif (!rdma)\n\t\treturn;\n\n\tclient->status = Disconnected;\n\trdma_disconnect(rdma->cm_id);\n\trdma_destroy_trans(rdma);\n}\n\n \nstatic struct p9_trans_rdma *alloc_rdma(struct p9_rdma_opts *opts)\n{\n\tstruct p9_trans_rdma *rdma;\n\n\trdma = kzalloc(sizeof(struct p9_trans_rdma), GFP_KERNEL);\n\tif (!rdma)\n\t\treturn NULL;\n\n\trdma->port = opts->port;\n\trdma->privport = opts->privport;\n\trdma->sq_depth = opts->sq_depth;\n\trdma->rq_depth = opts->rq_depth;\n\trdma->timeout = opts->timeout;\n\tspin_lock_init(&rdma->req_lock);\n\tinit_completion(&rdma->cm_done);\n\tsema_init(&rdma->sq_sem, rdma->sq_depth);\n\tsema_init(&rdma->rq_sem, rdma->rq_depth);\n\tatomic_set(&rdma->excess_rc, 0);\n\n\treturn rdma;\n}\n\nstatic int rdma_cancel(struct p9_client *client, struct p9_req_t *req)\n{\n\t \n\treturn 1;\n}\n\n \nstatic int rdma_cancelled(struct p9_client *client, struct p9_req_t *req)\n{\n\tstruct p9_trans_rdma *rdma = client->trans;\n\tatomic_inc(&rdma->excess_rc);\n\treturn 0;\n}\n\nstatic int p9_rdma_bind_privport(struct p9_trans_rdma *rdma)\n{\n\tstruct sockaddr_in cl = {\n\t\t.sin_family = AF_INET,\n\t\t.sin_addr.s_addr = htonl(INADDR_ANY),\n\t};\n\tint port, err = -EINVAL;\n\n\tfor (port = P9_DEF_MAX_RESVPORT; port >= P9_DEF_MIN_RESVPORT; port--) {\n\t\tcl.sin_port = htons((ushort)port);\n\t\terr = rdma_bind_addr(rdma->cm_id, (struct sockaddr *)&cl);\n\t\tif (err != -EADDRINUSE)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nstatic int\nrdma_create_trans(struct p9_client *client, const char *addr, char *args)\n{\n\tint err;\n\tstruct p9_rdma_opts opts;\n\tstruct p9_trans_rdma *rdma;\n\tstruct rdma_conn_param conn_param;\n\tstruct ib_qp_init_attr qp_attr;\n\n\tif (addr == NULL)\n\t\treturn -EINVAL;\n\n\t \n\terr = parse_opts(args, &opts);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\trdma = alloc_rdma(&opts);\n\tif (!rdma)\n\t\treturn -ENOMEM;\n\n\t \n\trdma->cm_id = rdma_create_id(&init_net, p9_cm_event_handler, client,\n\t\t\t\t     RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(rdma->cm_id))\n\t\tgoto error;\n\n\t \n\tclient->trans = rdma;\n\n\t \n\tif (opts.privport) {\n\t\terr = p9_rdma_bind_privport(rdma);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"%s (%d): problem binding to privport: %d\\n\",\n\t\t\t       __func__, task_pid_nr(current), -err);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\trdma->addr.sin_family = AF_INET;\n\trdma->addr.sin_addr.s_addr = in_aton(addr);\n\trdma->addr.sin_port = htons(opts.port);\n\terr = rdma_resolve_addr(rdma->cm_id, NULL,\n\t\t\t\t(struct sockaddr *)&rdma->addr,\n\t\t\t\trdma->timeout);\n\tif (err)\n\t\tgoto error;\n\terr = wait_for_completion_interruptible(&rdma->cm_done);\n\tif (err || (rdma->state != P9_RDMA_ADDR_RESOLVED))\n\t\tgoto error;\n\n\t \n\terr = rdma_resolve_route(rdma->cm_id, rdma->timeout);\n\tif (err)\n\t\tgoto error;\n\terr = wait_for_completion_interruptible(&rdma->cm_done);\n\tif (err || (rdma->state != P9_RDMA_ROUTE_RESOLVED))\n\t\tgoto error;\n\n\t \n\trdma->cq = ib_alloc_cq_any(rdma->cm_id->device, client,\n\t\t\t\t   opts.sq_depth + opts.rq_depth + 1,\n\t\t\t\t   IB_POLL_SOFTIRQ);\n\tif (IS_ERR(rdma->cq))\n\t\tgoto error;\n\n\t \n\trdma->pd = ib_alloc_pd(rdma->cm_id->device, 0);\n\tif (IS_ERR(rdma->pd))\n\t\tgoto error;\n\n\t \n\tmemset(&qp_attr, 0, sizeof qp_attr);\n\tqp_attr.event_handler = qp_event_handler;\n\tqp_attr.qp_context = client;\n\tqp_attr.cap.max_send_wr = opts.sq_depth;\n\tqp_attr.cap.max_recv_wr = opts.rq_depth;\n\tqp_attr.cap.max_send_sge = P9_RDMA_SEND_SGE;\n\tqp_attr.cap.max_recv_sge = P9_RDMA_RECV_SGE;\n\tqp_attr.sq_sig_type = IB_SIGNAL_REQ_WR;\n\tqp_attr.qp_type = IB_QPT_RC;\n\tqp_attr.send_cq = rdma->cq;\n\tqp_attr.recv_cq = rdma->cq;\n\terr = rdma_create_qp(rdma->cm_id, rdma->pd, &qp_attr);\n\tif (err)\n\t\tgoto error;\n\trdma->qp = rdma->cm_id->qp;\n\n\t \n\tmemset(&conn_param, 0, sizeof(conn_param));\n\tconn_param.private_data = NULL;\n\tconn_param.private_data_len = 0;\n\tconn_param.responder_resources = P9_RDMA_IRD;\n\tconn_param.initiator_depth = P9_RDMA_ORD;\n\terr = rdma_connect(rdma->cm_id, &conn_param);\n\tif (err)\n\t\tgoto error;\n\terr = wait_for_completion_interruptible(&rdma->cm_done);\n\tif (err || (rdma->state != P9_RDMA_CONNECTED))\n\t\tgoto error;\n\n\tclient->status = Connected;\n\n\treturn 0;\n\nerror:\n\trdma_destroy_trans(rdma);\n\treturn -ENOTCONN;\n}\n\nstatic struct p9_trans_module p9_rdma_trans = {\n\t.name = \"rdma\",\n\t.maxsize = P9_RDMA_MAXSIZE,\n\t.pooled_rbuffers = true,\n\t.def = 0,\n\t.owner = THIS_MODULE,\n\t.create = rdma_create_trans,\n\t.close = rdma_close,\n\t.request = rdma_request,\n\t.cancel = rdma_cancel,\n\t.cancelled = rdma_cancelled,\n\t.show_options = p9_rdma_show_options,\n};\n\n \nstatic int __init p9_trans_rdma_init(void)\n{\n\tv9fs_register_trans(&p9_rdma_trans);\n\treturn 0;\n}\n\nstatic void __exit p9_trans_rdma_exit(void)\n{\n\tv9fs_unregister_trans(&p9_rdma_trans);\n}\n\nmodule_init(p9_trans_rdma_init);\nmodule_exit(p9_trans_rdma_exit);\nMODULE_ALIAS_9P(\"rdma\");\n\nMODULE_AUTHOR(\"Tom Tucker <tom@opengridcomputing.com>\");\nMODULE_DESCRIPTION(\"RDMA Transport for 9P\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}