{
  "module_name": "trans_xen.c",
  "hash_id": "4f77283fec375284a94f43d214237b0cbc02bb9b26ff5deba18c05ecc6007453",
  "original_prompt": "Ingested from linux-6.6.14/net/9p/trans_xen.c",
  "human_readable_source": "\n \n\n#include <xen/events.h>\n#include <xen/grant_table.h>\n#include <xen/xen.h>\n#include <xen/xenbus.h>\n#include <xen/interface/io/9pfs.h>\n\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n#include <net/9p/transport.h>\n\n#define XEN_9PFS_NUM_RINGS 2\n#define XEN_9PFS_RING_ORDER 9\n#define XEN_9PFS_RING_SIZE(ring)  XEN_FLEX_RING_SIZE(ring->intf->ring_order)\n\nstruct xen_9pfs_header {\n\tuint32_t size;\n\tuint8_t id;\n\tuint16_t tag;\n\n\t \n} __attribute__((packed));\n\n \nstruct xen_9pfs_dataring {\n\tstruct xen_9pfs_front_priv *priv;\n\n\tstruct xen_9pfs_data_intf *intf;\n\tgrant_ref_t ref;\n\tint evtchn;\n\tint irq;\n\t \n\tspinlock_t lock;\n\n\tstruct xen_9pfs_data data;\n\twait_queue_head_t wq;\n\tstruct work_struct work;\n};\n\n \nstruct xen_9pfs_front_priv {\n\tstruct list_head list;\n\tstruct xenbus_device *dev;\n\tchar *tag;\n\tstruct p9_client *client;\n\n\tint num_rings;\n\tstruct xen_9pfs_dataring *rings;\n};\n\nstatic LIST_HEAD(xen_9pfs_devs);\nstatic DEFINE_RWLOCK(xen_9pfs_lock);\n\n \nstatic int p9_xen_cancel(struct p9_client *client, struct p9_req_t *req)\n{\n\treturn 1;\n}\n\nstatic int p9_xen_create(struct p9_client *client, const char *addr, char *args)\n{\n\tstruct xen_9pfs_front_priv *priv;\n\n\tif (addr == NULL)\n\t\treturn -EINVAL;\n\n\tread_lock(&xen_9pfs_lock);\n\tlist_for_each_entry(priv, &xen_9pfs_devs, list) {\n\t\tif (!strcmp(priv->tag, addr)) {\n\t\t\tpriv->client = client;\n\t\t\tread_unlock(&xen_9pfs_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_unlock(&xen_9pfs_lock);\n\treturn -EINVAL;\n}\n\nstatic void p9_xen_close(struct p9_client *client)\n{\n\tstruct xen_9pfs_front_priv *priv;\n\n\tread_lock(&xen_9pfs_lock);\n\tlist_for_each_entry(priv, &xen_9pfs_devs, list) {\n\t\tif (priv->client == client) {\n\t\t\tpriv->client = NULL;\n\t\t\tread_unlock(&xen_9pfs_lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tread_unlock(&xen_9pfs_lock);\n}\n\nstatic bool p9_xen_write_todo(struct xen_9pfs_dataring *ring, RING_IDX size)\n{\n\tRING_IDX cons, prod;\n\n\tcons = ring->intf->out_cons;\n\tprod = ring->intf->out_prod;\n\tvirt_mb();\n\n\treturn XEN_9PFS_RING_SIZE(ring) -\n\t\txen_9pfs_queued(prod, cons, XEN_9PFS_RING_SIZE(ring)) >= size;\n}\n\nstatic int p9_xen_request(struct p9_client *client, struct p9_req_t *p9_req)\n{\n\tstruct xen_9pfs_front_priv *priv;\n\tRING_IDX cons, prod, masked_cons, masked_prod;\n\tunsigned long flags;\n\tu32 size = p9_req->tc.size;\n\tstruct xen_9pfs_dataring *ring;\n\tint num;\n\n\tread_lock(&xen_9pfs_lock);\n\tlist_for_each_entry(priv, &xen_9pfs_devs, list) {\n\t\tif (priv->client == client)\n\t\t\tbreak;\n\t}\n\tread_unlock(&xen_9pfs_lock);\n\tif (list_entry_is_head(priv, &xen_9pfs_devs, list))\n\t\treturn -EINVAL;\n\n\tnum = p9_req->tc.tag % priv->num_rings;\n\tring = &priv->rings[num];\n\nagain:\n\twhile (wait_event_killable(ring->wq,\n\t\t\t\t   p9_xen_write_todo(ring, size)) != 0)\n\t\t;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\tcons = ring->intf->out_cons;\n\tprod = ring->intf->out_prod;\n\tvirt_mb();\n\n\tif (XEN_9PFS_RING_SIZE(ring) -\n\t    xen_9pfs_queued(prod, cons, XEN_9PFS_RING_SIZE(ring)) < size) {\n\t\tspin_unlock_irqrestore(&ring->lock, flags);\n\t\tgoto again;\n\t}\n\n\tmasked_prod = xen_9pfs_mask(prod, XEN_9PFS_RING_SIZE(ring));\n\tmasked_cons = xen_9pfs_mask(cons, XEN_9PFS_RING_SIZE(ring));\n\n\txen_9pfs_write_packet(ring->data.out, p9_req->tc.sdata, size,\n\t\t\t      &masked_prod, masked_cons,\n\t\t\t      XEN_9PFS_RING_SIZE(ring));\n\n\tWRITE_ONCE(p9_req->status, REQ_STATUS_SENT);\n\tvirt_wmb();\t\t\t \n\tprod += size;\n\tring->intf->out_prod = prod;\n\tspin_unlock_irqrestore(&ring->lock, flags);\n\tnotify_remote_via_irq(ring->irq);\n\tp9_req_put(client, p9_req);\n\n\treturn 0;\n}\n\nstatic void p9_xen_response(struct work_struct *work)\n{\n\tstruct xen_9pfs_front_priv *priv;\n\tstruct xen_9pfs_dataring *ring;\n\tRING_IDX cons, prod, masked_cons, masked_prod;\n\tstruct xen_9pfs_header h;\n\tstruct p9_req_t *req;\n\tint status;\n\n\tring = container_of(work, struct xen_9pfs_dataring, work);\n\tpriv = ring->priv;\n\n\twhile (1) {\n\t\tcons = ring->intf->in_cons;\n\t\tprod = ring->intf->in_prod;\n\t\tvirt_rmb();\n\n\t\tif (xen_9pfs_queued(prod, cons, XEN_9PFS_RING_SIZE(ring)) <\n\t\t    sizeof(h)) {\n\t\t\tnotify_remote_via_irq(ring->irq);\n\t\t\treturn;\n\t\t}\n\n\t\tmasked_prod = xen_9pfs_mask(prod, XEN_9PFS_RING_SIZE(ring));\n\t\tmasked_cons = xen_9pfs_mask(cons, XEN_9PFS_RING_SIZE(ring));\n\n\t\t \n\t\txen_9pfs_read_packet(&h, ring->data.in, sizeof(h),\n\t\t\t\t     masked_prod, &masked_cons,\n\t\t\t\t     XEN_9PFS_RING_SIZE(ring));\n\n\t\treq = p9_tag_lookup(priv->client, h.tag);\n\t\tif (!req || req->status != REQ_STATUS_SENT) {\n\t\t\tdev_warn(&priv->dev->dev, \"Wrong req tag=%x\\n\", h.tag);\n\t\t\tcons += h.size;\n\t\t\tvirt_mb();\n\t\t\tring->intf->in_cons = cons;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (h.size > req->rc.capacity) {\n\t\t\tdev_warn(&priv->dev->dev,\n\t\t\t\t \"requested packet size too big: %d for tag %d with capacity %zd\\n\",\n\t\t\t\t h.size, h.tag, req->rc.capacity);\n\t\t\tWRITE_ONCE(req->status, REQ_STATUS_ERROR);\n\t\t\tgoto recv_error;\n\t\t}\n\n\t\treq->rc.size = h.size;\n\t\treq->rc.id = h.id;\n\t\treq->rc.tag = h.tag;\n\t\treq->rc.offset = 0;\n\n\t\tmasked_cons = xen_9pfs_mask(cons, XEN_9PFS_RING_SIZE(ring));\n\t\t \n\t\txen_9pfs_read_packet(req->rc.sdata, ring->data.in, h.size,\n\t\t\t\t     masked_prod, &masked_cons,\n\t\t\t\t     XEN_9PFS_RING_SIZE(ring));\n\nrecv_error:\n\t\tvirt_mb();\n\t\tcons += h.size;\n\t\tring->intf->in_cons = cons;\n\n\t\tstatus = (req->status != REQ_STATUS_ERROR) ?\n\t\t\tREQ_STATUS_RCVD : REQ_STATUS_ERROR;\n\n\t\tp9_client_cb(priv->client, req, status);\n\t}\n}\n\nstatic irqreturn_t xen_9pfs_front_event_handler(int irq, void *r)\n{\n\tstruct xen_9pfs_dataring *ring = r;\n\n\tif (!ring || !ring->priv->client) {\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\twake_up_interruptible(&ring->wq);\n\tschedule_work(&ring->work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct p9_trans_module p9_xen_trans = {\n\t.name = \"xen\",\n\t.maxsize = 1 << (XEN_9PFS_RING_ORDER + XEN_PAGE_SHIFT - 2),\n\t.pooled_rbuffers = false,\n\t.def = 1,\n\t.create = p9_xen_create,\n\t.close = p9_xen_close,\n\t.request = p9_xen_request,\n\t.cancel = p9_xen_cancel,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct xenbus_device_id xen_9pfs_front_ids[] = {\n\t{ \"9pfs\" },\n\t{ \"\" }\n};\n\nstatic void xen_9pfs_front_free(struct xen_9pfs_front_priv *priv)\n{\n\tint i, j;\n\n\twrite_lock(&xen_9pfs_lock);\n\tlist_del(&priv->list);\n\twrite_unlock(&xen_9pfs_lock);\n\n\tfor (i = 0; i < priv->num_rings; i++) {\n\t\tstruct xen_9pfs_dataring *ring = &priv->rings[i];\n\n\t\tcancel_work_sync(&ring->work);\n\n\t\tif (!priv->rings[i].intf)\n\t\t\tbreak;\n\t\tif (priv->rings[i].irq > 0)\n\t\t\tunbind_from_irqhandler(priv->rings[i].irq, priv->dev);\n\t\tif (priv->rings[i].data.in) {\n\t\t\tfor (j = 0;\n\t\t\t     j < (1 << priv->rings[i].intf->ring_order);\n\t\t\t     j++) {\n\t\t\t\tgrant_ref_t ref;\n\n\t\t\t\tref = priv->rings[i].intf->ref[j];\n\t\t\t\tgnttab_end_foreign_access(ref, NULL);\n\t\t\t}\n\t\t\tfree_pages_exact(priv->rings[i].data.in,\n\t\t\t\t   1UL << (priv->rings[i].intf->ring_order +\n\t\t\t\t\t   XEN_PAGE_SHIFT));\n\t\t}\n\t\tgnttab_end_foreign_access(priv->rings[i].ref, NULL);\n\t\tfree_page((unsigned long)priv->rings[i].intf);\n\t}\n\tkfree(priv->rings);\n\tkfree(priv->tag);\n\tkfree(priv);\n}\n\nstatic void xen_9pfs_front_remove(struct xenbus_device *dev)\n{\n\tstruct xen_9pfs_front_priv *priv = dev_get_drvdata(&dev->dev);\n\n\tdev_set_drvdata(&dev->dev, NULL);\n\txen_9pfs_front_free(priv);\n}\n\nstatic int xen_9pfs_front_alloc_dataring(struct xenbus_device *dev,\n\t\t\t\t\t struct xen_9pfs_dataring *ring,\n\t\t\t\t\t unsigned int order)\n{\n\tint i = 0;\n\tint ret = -ENOMEM;\n\tvoid *bytes = NULL;\n\n\tinit_waitqueue_head(&ring->wq);\n\tspin_lock_init(&ring->lock);\n\tINIT_WORK(&ring->work, p9_xen_response);\n\n\tring->intf = (struct xen_9pfs_data_intf *)get_zeroed_page(GFP_KERNEL);\n\tif (!ring->intf)\n\t\treturn ret;\n\tret = gnttab_grant_foreign_access(dev->otherend_id,\n\t\t\t\t\t  virt_to_gfn(ring->intf), 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tring->ref = ret;\n\tbytes = alloc_pages_exact(1UL << (order + XEN_PAGE_SHIFT),\n\t\t\t\t  GFP_KERNEL | __GFP_ZERO);\n\tif (!bytes) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor (; i < (1 << order); i++) {\n\t\tret = gnttab_grant_foreign_access(\n\t\t\t\tdev->otherend_id, virt_to_gfn(bytes) + i, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tring->intf->ref[i] = ret;\n\t}\n\tring->intf->ring_order = order;\n\tring->data.in = bytes;\n\tring->data.out = bytes + XEN_FLEX_RING_SIZE(order);\n\n\tret = xenbus_alloc_evtchn(dev, &ring->evtchn);\n\tif (ret)\n\t\tgoto out;\n\tring->irq = bind_evtchn_to_irqhandler(ring->evtchn,\n\t\t\t\t\t      xen_9pfs_front_event_handler,\n\t\t\t\t\t      0, \"xen_9pfs-frontend\", ring);\n\tif (ring->irq >= 0)\n\t\treturn 0;\n\n\txenbus_free_evtchn(dev, ring->evtchn);\n\tret = ring->irq;\nout:\n\tif (bytes) {\n\t\tfor (i--; i >= 0; i--)\n\t\t\tgnttab_end_foreign_access(ring->intf->ref[i], NULL);\n\t\tfree_pages_exact(bytes, 1UL << (order + XEN_PAGE_SHIFT));\n\t}\n\tgnttab_end_foreign_access(ring->ref, NULL);\n\tfree_page((unsigned long)ring->intf);\n\treturn ret;\n}\n\nstatic int xen_9pfs_front_init(struct xenbus_device *dev)\n{\n\tint ret, i;\n\tstruct xenbus_transaction xbt;\n\tstruct xen_9pfs_front_priv *priv = dev_get_drvdata(&dev->dev);\n\tchar *versions, *v;\n\tunsigned int max_rings, max_ring_order, len = 0;\n\n\tversions = xenbus_read(XBT_NIL, dev->otherend, \"versions\", &len);\n\tif (IS_ERR(versions))\n\t\treturn PTR_ERR(versions);\n\tfor (v = versions; *v; v++) {\n\t\tif (simple_strtoul(v, &v, 10) == 1) {\n\t\t\tv = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (v) {\n\t\tkfree(versions);\n\t\treturn -EINVAL;\n\t}\n\tkfree(versions);\n\tmax_rings = xenbus_read_unsigned(dev->otherend, \"max-rings\", 0);\n\tif (max_rings < XEN_9PFS_NUM_RINGS)\n\t\treturn -EINVAL;\n\tmax_ring_order = xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t      \"max-ring-page-order\", 0);\n\tif (max_ring_order > XEN_9PFS_RING_ORDER)\n\t\tmax_ring_order = XEN_9PFS_RING_ORDER;\n\tif (p9_xen_trans.maxsize > XEN_FLEX_RING_SIZE(max_ring_order))\n\t\tp9_xen_trans.maxsize = XEN_FLEX_RING_SIZE(max_ring_order) / 2;\n\n\tpriv->num_rings = XEN_9PFS_NUM_RINGS;\n\tpriv->rings = kcalloc(priv->num_rings, sizeof(*priv->rings),\n\t\t\t      GFP_KERNEL);\n\tif (!priv->rings) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < priv->num_rings; i++) {\n\t\tpriv->rings[i].priv = priv;\n\t\tret = xen_9pfs_front_alloc_dataring(dev, &priv->rings[i],\n\t\t\t\t\t\t    max_ring_order);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n again:\n\tret = xenbus_transaction_start(&xbt);\n\tif (ret) {\n\t\txenbus_dev_fatal(dev, ret, \"starting transaction\");\n\t\tgoto error;\n\t}\n\tret = xenbus_printf(xbt, dev->nodename, \"version\", \"%u\", 1);\n\tif (ret)\n\t\tgoto error_xenbus;\n\tret = xenbus_printf(xbt, dev->nodename, \"num-rings\", \"%u\",\n\t\t\t    priv->num_rings);\n\tif (ret)\n\t\tgoto error_xenbus;\n\tfor (i = 0; i < priv->num_rings; i++) {\n\t\tchar str[16];\n\n\t\tBUILD_BUG_ON(XEN_9PFS_NUM_RINGS > 9);\n\t\tsprintf(str, \"ring-ref%d\", i);\n\t\tret = xenbus_printf(xbt, dev->nodename, str, \"%d\",\n\t\t\t\t    priv->rings[i].ref);\n\t\tif (ret)\n\t\t\tgoto error_xenbus;\n\n\t\tsprintf(str, \"event-channel-%d\", i);\n\t\tret = xenbus_printf(xbt, dev->nodename, str, \"%u\",\n\t\t\t\t    priv->rings[i].evtchn);\n\t\tif (ret)\n\t\t\tgoto error_xenbus;\n\t}\n\tpriv->tag = xenbus_read(xbt, dev->nodename, \"tag\", NULL);\n\tif (IS_ERR(priv->tag)) {\n\t\tret = PTR_ERR(priv->tag);\n\t\tgoto error_xenbus;\n\t}\n\tret = xenbus_transaction_end(xbt, 0);\n\tif (ret) {\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\t\txenbus_dev_fatal(dev, ret, \"completing transaction\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\n error_xenbus:\n\txenbus_transaction_end(xbt, 1);\n\txenbus_dev_fatal(dev, ret, \"writing xenstore\");\n error:\n\txen_9pfs_front_free(priv);\n\treturn ret;\n}\n\nstatic int xen_9pfs_front_probe(struct xenbus_device *dev,\n\t\t\t\tconst struct xenbus_device_id *id)\n{\n\tstruct xen_9pfs_front_priv *priv = NULL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tdev_set_drvdata(&dev->dev, priv);\n\n\twrite_lock(&xen_9pfs_lock);\n\tlist_add_tail(&priv->list, &xen_9pfs_devs);\n\twrite_unlock(&xen_9pfs_lock);\n\n\treturn 0;\n}\n\nstatic int xen_9pfs_front_resume(struct xenbus_device *dev)\n{\n\tdev_warn(&dev->dev, \"suspend/resume unsupported\\n\");\n\treturn 0;\n}\n\nstatic void xen_9pfs_front_changed(struct xenbus_device *dev,\n\t\t\t\t   enum xenbus_state backend_state)\n{\n\tswitch (backend_state) {\n\tcase XenbusStateReconfiguring:\n\tcase XenbusStateReconfigured:\n\tcase XenbusStateInitialising:\n\tcase XenbusStateInitialised:\n\tcase XenbusStateUnknown:\n\t\tbreak;\n\n\tcase XenbusStateInitWait:\n\t\tif (!xen_9pfs_front_init(dev))\n\t\t\txenbus_switch_state(dev, XenbusStateInitialised);\n\t\tbreak;\n\n\tcase XenbusStateConnected:\n\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateClosed:\n\t\tif (dev->state == XenbusStateClosed)\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase XenbusStateClosing:\n\t\txenbus_frontend_closed(dev);\n\t\tbreak;\n\t}\n}\n\nstatic struct xenbus_driver xen_9pfs_front_driver = {\n\t.ids = xen_9pfs_front_ids,\n\t.probe = xen_9pfs_front_probe,\n\t.remove = xen_9pfs_front_remove,\n\t.resume = xen_9pfs_front_resume,\n\t.otherend_changed = xen_9pfs_front_changed,\n};\n\nstatic int __init p9_trans_xen_init(void)\n{\n\tint rc;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tpr_info(\"Initialising Xen transport for 9pfs\\n\");\n\n\tv9fs_register_trans(&p9_xen_trans);\n\trc = xenbus_register_frontend(&xen_9pfs_front_driver);\n\tif (rc)\n\t\tv9fs_unregister_trans(&p9_xen_trans);\n\n\treturn rc;\n}\nmodule_init(p9_trans_xen_init);\nMODULE_ALIAS_9P(\"xen\");\n\nstatic void __exit p9_trans_xen_exit(void)\n{\n\tv9fs_unregister_trans(&p9_xen_trans);\n\treturn xenbus_unregister_driver(&xen_9pfs_front_driver);\n}\nmodule_exit(p9_trans_xen_exit);\n\nMODULE_ALIAS(\"xen:9pfs\");\nMODULE_AUTHOR(\"Stefano Stabellini <stefano@aporeto.com>\");\nMODULE_DESCRIPTION(\"Xen Transport for 9P\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}