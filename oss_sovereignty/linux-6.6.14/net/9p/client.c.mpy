{
  "module_name": "client.c",
  "hash_id": "bd4bd913c44c7873692ad8441d230bf200eb92b94c0c241e19351a8497300062",
  "original_prompt": "Ingested from linux-6.6.14/net/9p/client.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <net/9p/9p.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <net/9p/client.h>\n#include <net/9p/transport.h>\n#include \"protocol.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/9p.h>\n\n \n\n#define DEFAULT_MSIZE ((128 * 1024) + P9_IOHDRSZ)\n\n \n\nenum {\n\tOpt_msize,\n\tOpt_trans,\n\tOpt_legacy,\n\tOpt_version,\n\tOpt_err,\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_msize, \"msize=%u\"},\n\t{Opt_legacy, \"noextend\"},\n\t{Opt_trans, \"trans=%s\"},\n\t{Opt_version, \"version=%s\"},\n\t{Opt_err, NULL},\n};\n\ninline int p9_is_proto_dotl(struct p9_client *clnt)\n{\n\treturn clnt->proto_version == p9_proto_2000L;\n}\nEXPORT_SYMBOL(p9_is_proto_dotl);\n\ninline int p9_is_proto_dotu(struct p9_client *clnt)\n{\n\treturn clnt->proto_version == p9_proto_2000u;\n}\nEXPORT_SYMBOL(p9_is_proto_dotu);\n\nint p9_show_client_options(struct seq_file *m, struct p9_client *clnt)\n{\n\tif (clnt->msize != DEFAULT_MSIZE)\n\t\tseq_printf(m, \",msize=%u\", clnt->msize);\n\tseq_printf(m, \",trans=%s\", clnt->trans_mod->name);\n\n\tswitch (clnt->proto_version) {\n\tcase p9_proto_legacy:\n\t\tseq_puts(m, \",noextend\");\n\t\tbreak;\n\tcase p9_proto_2000u:\n\t\tseq_puts(m, \",version=9p2000.u\");\n\t\tbreak;\n\tcase p9_proto_2000L:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (clnt->trans_mod->show_options)\n\t\treturn clnt->trans_mod->show_options(m, clnt);\n\treturn 0;\n}\nEXPORT_SYMBOL(p9_show_client_options);\n\n \nstatic int safe_errno(int err)\n{\n\tif (err > 0 || err < -MAX_ERRNO) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"Invalid error code %d\\n\", err);\n\t\treturn -EPROTO;\n\t}\n\treturn err;\n}\n\n \nstatic int get_protocol_version(char *s)\n{\n\tint version = -EINVAL;\n\n\tif (!strcmp(s, \"9p2000\")) {\n\t\tversion = p9_proto_legacy;\n\t\tp9_debug(P9_DEBUG_9P, \"Protocol version: Legacy\\n\");\n\t} else if (!strcmp(s, \"9p2000.u\")) {\n\t\tversion = p9_proto_2000u;\n\t\tp9_debug(P9_DEBUG_9P, \"Protocol version: 9P2000.u\\n\");\n\t} else if (!strcmp(s, \"9p2000.L\")) {\n\t\tversion = p9_proto_2000L;\n\t\tp9_debug(P9_DEBUG_9P, \"Protocol version: 9P2000.L\\n\");\n\t} else {\n\t\tpr_info(\"Unknown protocol version %s\\n\", s);\n\t}\n\n\treturn version;\n}\n\n \n\nstatic int parse_opts(char *opts, struct p9_client *clnt)\n{\n\tchar *options, *tmp_options;\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tchar *s;\n\tint ret = 0;\n\n\tclnt->proto_version = p9_proto_2000L;\n\tclnt->msize = DEFAULT_MSIZE;\n\n\tif (!opts)\n\t\treturn 0;\n\n\ttmp_options = kstrdup(opts, GFP_KERNEL);\n\tif (!tmp_options)\n\t\treturn -ENOMEM;\n\toptions = tmp_options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, r;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_msize:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (option < 4096) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"msize should be at least 4k\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclnt->msize = option;\n\t\t\tbreak;\n\t\tcase Opt_trans:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of trans arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\n\t\t\tv9fs_put_trans(clnt->trans_mod);\n\t\t\tclnt->trans_mod = v9fs_get_trans_by_name(s);\n\t\t\tif (!clnt->trans_mod) {\n\t\t\t\tpr_info(\"Could not find request transport: %s\\n\",\n\t\t\t\t\ts);\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tkfree(s);\n\t\t\tbreak;\n\t\tcase Opt_legacy:\n\t\t\tclnt->proto_version = p9_proto_legacy;\n\t\t\tbreak;\n\t\tcase Opt_version:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of version arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tr = get_protocol_version(s);\n\t\t\tif (r < 0)\n\t\t\t\tret = r;\n\t\t\telse\n\t\t\t\tclnt->proto_version = r;\n\t\t\tkfree(s);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\nfree_and_return:\n\tif (ret)\n\t\tv9fs_put_trans(clnt->trans_mod);\n\tkfree(tmp_options);\n\treturn ret;\n}\n\nstatic int p9_fcall_init(struct p9_client *c, struct p9_fcall *fc,\n\t\t\t int alloc_msize)\n{\n\tif (likely(c->fcall_cache) && alloc_msize == c->msize) {\n\t\tfc->sdata = kmem_cache_alloc(c->fcall_cache, GFP_NOFS);\n\t\tfc->cache = c->fcall_cache;\n\t} else {\n\t\tfc->sdata = kmalloc(alloc_msize, GFP_NOFS);\n\t\tfc->cache = NULL;\n\t}\n\tif (!fc->sdata)\n\t\treturn -ENOMEM;\n\tfc->capacity = alloc_msize;\n\treturn 0;\n}\n\nvoid p9_fcall_fini(struct p9_fcall *fc)\n{\n\t \n\tif (unlikely(!fc->sdata))\n\t\treturn;\n\n\tif (fc->cache)\n\t\tkmem_cache_free(fc->cache, fc->sdata);\n\telse\n\t\tkfree(fc->sdata);\n}\nEXPORT_SYMBOL(p9_fcall_fini);\n\nstatic struct kmem_cache *p9_req_cache;\n\n \nstatic struct p9_req_t *\np9_tag_alloc(struct p9_client *c, int8_t type, uint t_size, uint r_size,\n\t      const char *fmt, va_list ap)\n{\n\tstruct p9_req_t *req = kmem_cache_alloc(p9_req_cache, GFP_NOFS);\n\tint alloc_tsize;\n\tint alloc_rsize;\n\tint tag;\n\tva_list apc;\n\n\tva_copy(apc, ap);\n\talloc_tsize = min_t(size_t, c->msize,\n\t\t\t    t_size ?: p9_msg_buf_size(c, type, fmt, apc));\n\tva_end(apc);\n\n\talloc_rsize = min_t(size_t, c->msize,\n\t\t\t    r_size ?: p9_msg_buf_size(c, type + 1, fmt, ap));\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (p9_fcall_init(c, &req->tc, alloc_tsize))\n\t\tgoto free_req;\n\tif (p9_fcall_init(c, &req->rc, alloc_rsize))\n\t\tgoto free;\n\n\tp9pdu_reset(&req->tc);\n\tp9pdu_reset(&req->rc);\n\treq->t_err = 0;\n\treq->status = REQ_STATUS_ALLOC;\n\t \n\trefcount_set(&req->refcount, 0);\n\tinit_waitqueue_head(&req->wq);\n\tINIT_LIST_HEAD(&req->req_list);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock_irq(&c->lock);\n\tif (type == P9_TVERSION)\n\t\ttag = idr_alloc(&c->reqs, req, P9_NOTAG, P9_NOTAG + 1,\n\t\t\t\tGFP_NOWAIT);\n\telse\n\t\ttag = idr_alloc(&c->reqs, req, 0, P9_NOTAG, GFP_NOWAIT);\n\treq->tc.tag = tag;\n\tspin_unlock_irq(&c->lock);\n\tidr_preload_end();\n\tif (tag < 0)\n\t\tgoto free;\n\n\t \n\trefcount_set(&req->refcount, 2);\n\n\treturn req;\n\nfree:\n\tp9_fcall_fini(&req->tc);\n\tp9_fcall_fini(&req->rc);\nfree_req:\n\tkmem_cache_free(p9_req_cache, req);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nstruct p9_req_t *p9_tag_lookup(struct p9_client *c, u16 tag)\n{\n\tstruct p9_req_t *req;\n\n\trcu_read_lock();\nagain:\n\treq = idr_find(&c->reqs, tag);\n\tif (req) {\n\t\t \n\t\tif (!p9_req_try_get(req))\n\t\t\tgoto again;\n\t\tif (req->tc.tag != tag) {\n\t\t\tp9_req_put(c, req);\n\t\t\tgoto again;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn req;\n}\nEXPORT_SYMBOL(p9_tag_lookup);\n\n \nstatic void p9_tag_remove(struct p9_client *c, struct p9_req_t *r)\n{\n\tunsigned long flags;\n\tu16 tag = r->tc.tag;\n\n\tp9_debug(P9_DEBUG_MUX, \"freeing clnt %p req %p tag: %d\\n\", c, r, tag);\n\tspin_lock_irqsave(&c->lock, flags);\n\tidr_remove(&c->reqs, tag);\n\tspin_unlock_irqrestore(&c->lock, flags);\n}\n\nint p9_req_put(struct p9_client *c, struct p9_req_t *r)\n{\n\tif (refcount_dec_and_test(&r->refcount)) {\n\t\tp9_tag_remove(c, r);\n\n\t\tp9_fcall_fini(&r->tc);\n\t\tp9_fcall_fini(&r->rc);\n\t\tkmem_cache_free(p9_req_cache, r);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(p9_req_put);\n\n \nstatic void p9_tag_cleanup(struct p9_client *c)\n{\n\tstruct p9_req_t *req;\n\tint id;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&c->reqs, req, id) {\n\t\tpr_info(\"Tag %d still in use\\n\", id);\n\t\tif (p9_req_put(c, req) == 0)\n\t\t\tpr_warn(\"Packet with tag %d has still references\",\n\t\t\t\treq->tc.tag);\n\t}\n\trcu_read_unlock();\n}\n\n \nvoid p9_client_cb(struct p9_client *c, struct p9_req_t *req, int status)\n{\n\tp9_debug(P9_DEBUG_MUX, \" tag %d\\n\", req->tc.tag);\n\n\t \n\tsmp_wmb();\n\tWRITE_ONCE(req->status, status);\n\n\twake_up(&req->wq);\n\tp9_debug(P9_DEBUG_MUX, \"wakeup: %d\\n\", req->tc.tag);\n\tp9_req_put(c, req);\n}\nEXPORT_SYMBOL(p9_client_cb);\n\n \n\nint\np9_parse_header(struct p9_fcall *pdu, int32_t *size, int8_t *type,\n\t\tint16_t *tag, int rewind)\n{\n\ts8 r_type;\n\ts16 r_tag;\n\ts32 r_size;\n\tint offset = pdu->offset;\n\tint err;\n\n\tpdu->offset = 0;\n\n\terr = p9pdu_readf(pdu, 0, \"dbw\", &r_size, &r_type, &r_tag);\n\tif (err)\n\t\tgoto rewind_and_exit;\n\n\tif (type)\n\t\t*type = r_type;\n\tif (tag)\n\t\t*tag = r_tag;\n\tif (size)\n\t\t*size = r_size;\n\n\tif (pdu->size != r_size || r_size < 7) {\n\t\terr = -EINVAL;\n\t\tgoto rewind_and_exit;\n\t}\n\n\tpdu->id = r_type;\n\tpdu->tag = r_tag;\n\n\tp9_debug(P9_DEBUG_9P, \"<<< size=%d type: %d tag: %d\\n\",\n\t\t pdu->size, pdu->id, pdu->tag);\n\nrewind_and_exit:\n\tif (rewind)\n\t\tpdu->offset = offset;\n\treturn err;\n}\nEXPORT_SYMBOL(p9_parse_header);\n\n \n\nstatic int p9_check_errors(struct p9_client *c, struct p9_req_t *req)\n{\n\ts8 type;\n\tint err;\n\tint ecode;\n\n\terr = p9_parse_header(&req->rc, NULL, &type, NULL, 0);\n\tif (req->rc.size > req->rc.capacity && !req->rc.zc) {\n\t\tpr_err(\"requested packet size too big: %d does not fit %zu (type=%d)\\n\",\n\t\t       req->rc.size, req->rc.capacity, req->rc.id);\n\t\treturn -EIO;\n\t}\n\t \n\ttrace_9p_protocol_dump(c, &req->rc);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"couldn't parse header %d\\n\", err);\n\t\treturn err;\n\t}\n\tif (type != P9_RERROR && type != P9_RLERROR)\n\t\treturn 0;\n\n\tif (!p9_is_proto_dotl(c)) {\n\t\tchar *ename = NULL;\n\n\t\terr = p9pdu_readf(&req->rc, c->proto_version, \"s?d\",\n\t\t\t\t  &ename, &ecode);\n\t\tif (err) {\n\t\t\tkfree(ename);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (p9_is_proto_dotu(c) && ecode < 512)\n\t\t\terr = -ecode;\n\n\t\tif (!err) {\n\t\t\terr = p9_errstr2errno(ename, strlen(ename));\n\n\t\t\tp9_debug(P9_DEBUG_9P, \"<<< RERROR (%d) %s\\n\",\n\t\t\t\t -ecode, ename);\n\t\t}\n\t\tkfree(ename);\n\t} else {\n\t\terr = p9pdu_readf(&req->rc, c->proto_version, \"d\", &ecode);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\terr = -ecode;\n\n\t\tp9_debug(P9_DEBUG_9P, \"<<< RLERROR (%d)\\n\", -ecode);\n\t}\n\n\treturn err;\n\nout_err:\n\tp9_debug(P9_DEBUG_ERROR, \"couldn't parse error%d\\n\", err);\n\n\treturn err;\n}\n\nstatic struct p9_req_t *\np9_client_rpc(struct p9_client *c, int8_t type, const char *fmt, ...);\n\n \n\nstatic int p9_client_flush(struct p9_client *c, struct p9_req_t *oldreq)\n{\n\tstruct p9_req_t *req;\n\ts16 oldtag;\n\tint err;\n\n\terr = p9_parse_header(&oldreq->tc, NULL, NULL, &oldtag, 1);\n\tif (err)\n\t\treturn err;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TFLUSH tag %d\\n\", oldtag);\n\n\treq = p9_client_rpc(c, P9_TFLUSH, \"w\", oldtag);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t \n\tif (READ_ONCE(oldreq->status) == REQ_STATUS_SENT) {\n\t\tif (c->trans_mod->cancelled)\n\t\t\tc->trans_mod->cancelled(c, oldreq);\n\t}\n\n\tp9_req_put(c, req);\n\treturn 0;\n}\n\nstatic struct p9_req_t *p9_client_prepare_req(struct p9_client *c,\n\t\t\t\t\t      int8_t type, uint t_size, uint r_size,\n\t\t\t\t\t      const char *fmt, va_list ap)\n{\n\tint err;\n\tstruct p9_req_t *req;\n\tva_list apc;\n\n\tp9_debug(P9_DEBUG_MUX, \"client %p op %d\\n\", c, type);\n\n\t \n\tif (c->status == Disconnected)\n\t\treturn ERR_PTR(-EIO);\n\n\t \n\tif (c->status == BeginDisconnect && type != P9_TCLUNK)\n\t\treturn ERR_PTR(-EIO);\n\n\tva_copy(apc, ap);\n\treq = p9_tag_alloc(c, type, t_size, r_size, fmt, apc);\n\tva_end(apc);\n\tif (IS_ERR(req))\n\t\treturn req;\n\n\t \n\tp9pdu_prepare(&req->tc, req->tc.tag, type);\n\terr = p9pdu_vwritef(&req->tc, c->proto_version, fmt, ap);\n\tif (err)\n\t\tgoto reterr;\n\tp9pdu_finalize(c, &req->tc);\n\ttrace_9p_client_req(c, type, req->tc.tag);\n\treturn req;\nreterr:\n\tp9_req_put(c, req);\n\t \n\tp9_req_put(c, req);\n\treturn ERR_PTR(err);\n}\n\n \n\nstatic struct p9_req_t *\np9_client_rpc(struct p9_client *c, int8_t type, const char *fmt, ...)\n{\n\tva_list ap;\n\tint sigpending, err;\n\tunsigned long flags;\n\tstruct p9_req_t *req;\n\t \n\tconst uint tsize = 0;\n\tconst uint rsize = c->trans_mod->pooled_rbuffers ? c->msize : 0;\n\n\tva_start(ap, fmt);\n\treq = p9_client_prepare_req(c, type, tsize, rsize, fmt, ap);\n\tva_end(ap);\n\tif (IS_ERR(req))\n\t\treturn req;\n\n\treq->tc.zc = false;\n\treq->rc.zc = false;\n\n\tif (signal_pending(current)) {\n\t\tsigpending = 1;\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\t} else {\n\t\tsigpending = 0;\n\t}\n\n\terr = c->trans_mod->request(c, req);\n\tif (err < 0) {\n\t\t \n\t\tp9_req_put(c, req);\n\t\tif (err != -ERESTARTSYS && err != -EFAULT)\n\t\t\tc->status = Disconnected;\n\t\tgoto recalc_sigpending;\n\t}\nagain:\n\t \n\terr = wait_event_killable(req->wq,\n\t\t\t\t  READ_ONCE(req->status) >= REQ_STATUS_RCVD);\n\n\t \n\tsmp_rmb();\n\n\tif (err == -ERESTARTSYS && c->status == Connected &&\n\t    type == P9_TFLUSH) {\n\t\tsigpending = 1;\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\tgoto again;\n\t}\n\n\tif (READ_ONCE(req->status) == REQ_STATUS_ERROR) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"req_status error %d\\n\", req->t_err);\n\t\terr = req->t_err;\n\t}\n\tif (err == -ERESTARTSYS && c->status == Connected) {\n\t\tp9_debug(P9_DEBUG_MUX, \"flushing\\n\");\n\t\tsigpending = 1;\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n\t\tif (c->trans_mod->cancel(c, req))\n\t\t\tp9_client_flush(c, req);\n\n\t\t \n\t\tif (READ_ONCE(req->status) == REQ_STATUS_RCVD)\n\t\t\terr = 0;\n\t}\nrecalc_sigpending:\n\tif (sigpending) {\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\tif (err < 0)\n\t\tgoto reterr;\n\n\terr = p9_check_errors(c, req);\n\ttrace_9p_client_res(c, type, req->rc.tag, err);\n\tif (!err)\n\t\treturn req;\nreterr:\n\tp9_req_put(c, req);\n\treturn ERR_PTR(safe_errno(err));\n}\n\n \nstatic struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,\n\t\t\t\t\t struct iov_iter *uidata,\n\t\t\t\t\t struct iov_iter *uodata,\n\t\t\t\t\t int inlen, int olen, int in_hdrlen,\n\t\t\t\t\t const char *fmt, ...)\n{\n\tva_list ap;\n\tint sigpending, err;\n\tunsigned long flags;\n\tstruct p9_req_t *req;\n\n\tva_start(ap, fmt);\n\t \n\treq = p9_client_prepare_req(c, type, P9_ZC_HDR_SZ, P9_ZC_HDR_SZ, fmt, ap);\n\tva_end(ap);\n\tif (IS_ERR(req))\n\t\treturn req;\n\n\treq->tc.zc = true;\n\treq->rc.zc = true;\n\n\tif (signal_pending(current)) {\n\t\tsigpending = 1;\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\t} else {\n\t\tsigpending = 0;\n\t}\n\n\terr = c->trans_mod->zc_request(c, req, uidata, uodata,\n\t\t\t\t       inlen, olen, in_hdrlen);\n\tif (err < 0) {\n\t\tif (err == -EIO)\n\t\t\tc->status = Disconnected;\n\t\tif (err != -ERESTARTSYS)\n\t\t\tgoto recalc_sigpending;\n\t}\n\tif (READ_ONCE(req->status) == REQ_STATUS_ERROR) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"req_status error %d\\n\", req->t_err);\n\t\terr = req->t_err;\n\t}\n\tif (err == -ERESTARTSYS && c->status == Connected) {\n\t\tp9_debug(P9_DEBUG_MUX, \"flushing\\n\");\n\t\tsigpending = 1;\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n\t\tif (c->trans_mod->cancel(c, req))\n\t\t\tp9_client_flush(c, req);\n\n\t\t \n\t\tif (READ_ONCE(req->status) == REQ_STATUS_RCVD)\n\t\t\terr = 0;\n\t}\nrecalc_sigpending:\n\tif (sigpending) {\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\tif (err < 0)\n\t\tgoto reterr;\n\n\terr = p9_check_errors(c, req);\n\ttrace_9p_client_res(c, type, req->rc.tag, err);\n\tif (!err)\n\t\treturn req;\nreterr:\n\tp9_req_put(c, req);\n\treturn ERR_PTR(safe_errno(err));\n}\n\nstatic struct p9_fid *p9_fid_create(struct p9_client *clnt)\n{\n\tint ret;\n\tstruct p9_fid *fid;\n\n\tp9_debug(P9_DEBUG_FID, \"clnt %p\\n\", clnt);\n\tfid = kzalloc(sizeof(*fid), GFP_KERNEL);\n\tif (!fid)\n\t\treturn NULL;\n\n\tfid->mode = -1;\n\tfid->uid = current_fsuid();\n\tfid->clnt = clnt;\n\trefcount_set(&fid->count, 1);\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_irq(&clnt->lock);\n\tret = idr_alloc_u32(&clnt->fids, fid, &fid->fid, P9_NOFID - 1,\n\t\t\t    GFP_NOWAIT);\n\tspin_unlock_irq(&clnt->lock);\n\tidr_preload_end();\n\tif (!ret) {\n\t\ttrace_9p_fid_ref(fid, P9_FID_REF_CREATE);\n\t\treturn fid;\n\t}\n\n\tkfree(fid);\n\treturn NULL;\n}\n\nstatic void p9_fid_destroy(struct p9_fid *fid)\n{\n\tstruct p9_client *clnt;\n\tunsigned long flags;\n\n\tp9_debug(P9_DEBUG_FID, \"fid %d\\n\", fid->fid);\n\ttrace_9p_fid_ref(fid, P9_FID_REF_DESTROY);\n\tclnt = fid->clnt;\n\tspin_lock_irqsave(&clnt->lock, flags);\n\tidr_remove(&clnt->fids, fid->fid);\n\tspin_unlock_irqrestore(&clnt->lock, flags);\n\tkfree(fid->rdir);\n\tkfree(fid);\n}\n\n \nEXPORT_TRACEPOINT_SYMBOL(9p_fid_ref);\n\nvoid do_trace_9p_fid_get(struct p9_fid *fid)\n{\n\ttrace_9p_fid_ref(fid, P9_FID_REF_GET);\n}\nEXPORT_SYMBOL(do_trace_9p_fid_get);\n\nvoid do_trace_9p_fid_put(struct p9_fid *fid)\n{\n\ttrace_9p_fid_ref(fid, P9_FID_REF_PUT);\n}\nEXPORT_SYMBOL(do_trace_9p_fid_put);\n\nstatic int p9_client_version(struct p9_client *c)\n{\n\tint err;\n\tstruct p9_req_t *req;\n\tchar *version = NULL;\n\tint msize;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TVERSION msize %d protocol %d\\n\",\n\t\t c->msize, c->proto_version);\n\n\tswitch (c->proto_version) {\n\tcase p9_proto_2000L:\n\t\treq = p9_client_rpc(c, P9_TVERSION, \"ds\",\n\t\t\t\t    c->msize, \"9P2000.L\");\n\t\tbreak;\n\tcase p9_proto_2000u:\n\t\treq = p9_client_rpc(c, P9_TVERSION, \"ds\",\n\t\t\t\t    c->msize, \"9P2000.u\");\n\t\tbreak;\n\tcase p9_proto_legacy:\n\t\treq = p9_client_rpc(c, P9_TVERSION, \"ds\",\n\t\t\t\t    c->msize, \"9P2000\");\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\terr = p9pdu_readf(&req->rc, c->proto_version, \"ds\", &msize, &version);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_9P, \"version error %d\\n\", err);\n\t\ttrace_9p_protocol_dump(c, &req->rc);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RVERSION msize %d %s\\n\", msize, version);\n\tif (!strncmp(version, \"9P2000.L\", 8)) {\n\t\tc->proto_version = p9_proto_2000L;\n\t} else if (!strncmp(version, \"9P2000.u\", 8)) {\n\t\tc->proto_version = p9_proto_2000u;\n\t} else if (!strncmp(version, \"9P2000\", 6)) {\n\t\tc->proto_version = p9_proto_legacy;\n\t} else {\n\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t \"server returned an unknown version: %s\\n\", version);\n\t\terr = -EREMOTEIO;\n\t\tgoto error;\n\t}\n\n\tif (msize < 4096) {\n\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t \"server returned a msize < 4096: %d\\n\", msize);\n\t\terr = -EREMOTEIO;\n\t\tgoto error;\n\t}\n\tif (msize < c->msize)\n\t\tc->msize = msize;\n\nerror:\n\tkfree(version);\n\tp9_req_put(c, req);\n\n\treturn err;\n}\n\nstruct p9_client *p9_client_create(const char *dev_name, char *options)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tchar *client_id;\n\n\tclnt = kmalloc(sizeof(*clnt), GFP_KERNEL);\n\tif (!clnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclnt->trans_mod = NULL;\n\tclnt->trans = NULL;\n\tclnt->fcall_cache = NULL;\n\n\tclient_id = utsname()->nodename;\n\tmemcpy(clnt->name, client_id, strlen(client_id) + 1);\n\n\tspin_lock_init(&clnt->lock);\n\tidr_init(&clnt->fids);\n\tidr_init(&clnt->reqs);\n\n\terr = parse_opts(options, clnt);\n\tif (err < 0)\n\t\tgoto free_client;\n\n\tif (!clnt->trans_mod)\n\t\tclnt->trans_mod = v9fs_get_default_trans();\n\n\tif (!clnt->trans_mod) {\n\t\terr = -EPROTONOSUPPORT;\n\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t \"No transport defined or default transport\\n\");\n\t\tgoto free_client;\n\t}\n\n\tp9_debug(P9_DEBUG_MUX, \"clnt %p trans %p msize %d protocol %d\\n\",\n\t\t clnt, clnt->trans_mod, clnt->msize, clnt->proto_version);\n\n\terr = clnt->trans_mod->create(clnt, dev_name, options);\n\tif (err)\n\t\tgoto put_trans;\n\n\tif (clnt->msize > clnt->trans_mod->maxsize) {\n\t\tclnt->msize = clnt->trans_mod->maxsize;\n\t\tpr_info(\"Limiting 'msize' to %d as this is the maximum \"\n\t\t\t\"supported by transport %s\\n\",\n\t\t\tclnt->msize, clnt->trans_mod->name\n\t\t);\n\t}\n\n\tif (clnt->msize < 4096) {\n\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t \"Please specify a msize of at least 4k\\n\");\n\t\terr = -EINVAL;\n\t\tgoto close_trans;\n\t}\n\n\terr = p9_client_version(clnt);\n\tif (err)\n\t\tgoto close_trans;\n\n\t \n\tclnt->fcall_cache =\n\t\tkmem_cache_create_usercopy(\"9p-fcall-cache\", clnt->msize,\n\t\t\t\t\t   0, 0, P9_HDRSZ + 4,\n\t\t\t\t\t   clnt->msize - (P9_HDRSZ + 4),\n\t\t\t\t\t   NULL);\n\n\treturn clnt;\n\nclose_trans:\n\tclnt->trans_mod->close(clnt);\nput_trans:\n\tv9fs_put_trans(clnt->trans_mod);\nfree_client:\n\tkfree(clnt);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(p9_client_create);\n\nvoid p9_client_destroy(struct p9_client *clnt)\n{\n\tstruct p9_fid *fid;\n\tint id;\n\n\tp9_debug(P9_DEBUG_MUX, \"clnt %p\\n\", clnt);\n\n\tif (clnt->trans_mod)\n\t\tclnt->trans_mod->close(clnt);\n\n\tv9fs_put_trans(clnt->trans_mod);\n\n\tidr_for_each_entry(&clnt->fids, fid, id) {\n\t\tpr_info(\"Found fid %d not clunked\\n\", fid->fid);\n\t\tp9_fid_destroy(fid);\n\t}\n\n\tp9_tag_cleanup(clnt);\n\n\tkmem_cache_destroy(clnt->fcall_cache);\n\tkfree(clnt);\n}\nEXPORT_SYMBOL(p9_client_destroy);\n\nvoid p9_client_disconnect(struct p9_client *clnt)\n{\n\tp9_debug(P9_DEBUG_9P, \"clnt %p\\n\", clnt);\n\tclnt->status = Disconnected;\n}\nEXPORT_SYMBOL(p9_client_disconnect);\n\nvoid p9_client_begin_disconnect(struct p9_client *clnt)\n{\n\tp9_debug(P9_DEBUG_9P, \"clnt %p\\n\", clnt);\n\tclnt->status = BeginDisconnect;\n}\nEXPORT_SYMBOL(p9_client_begin_disconnect);\n\nstruct p9_fid *p9_client_attach(struct p9_client *clnt, struct p9_fid *afid,\n\t\t\t\tconst char *uname, kuid_t n_uname,\n\t\t\t\tconst char *aname)\n{\n\tint err;\n\tstruct p9_req_t *req;\n\tstruct p9_fid *fid;\n\tstruct p9_qid qid;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TATTACH afid %d uname %s aname %s\\n\",\n\t\t afid ? afid->fid : -1, uname, aname);\n\tfid = p9_fid_create(clnt);\n\tif (!fid) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tfid->uid = n_uname;\n\n\treq = p9_client_rpc(clnt, P9_TATTACH, \"ddss?u\", fid->fid,\n\t\t\t    afid ? afid->fid : P9_NOFID, uname, aname, n_uname);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"Q\", &qid);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tp9_req_put(clnt, req);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RATTACH qid %x.%llx.%x\\n\",\n\t\t qid.type, qid.path, qid.version);\n\n\tmemmove(&fid->qid, &qid, sizeof(struct p9_qid));\n\n\tp9_req_put(clnt, req);\n\treturn fid;\n\nerror:\n\tif (fid)\n\t\tp9_fid_destroy(fid);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(p9_client_attach);\n\nstruct p9_fid *p9_client_walk(struct p9_fid *oldfid, uint16_t nwname,\n\t\t\t      const unsigned char * const *wnames, int clone)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_fid *fid;\n\tstruct p9_qid *wqids;\n\tstruct p9_req_t *req;\n\tu16 nwqids, count;\n\n\twqids = NULL;\n\tclnt = oldfid->clnt;\n\tif (clone) {\n\t\tfid = p9_fid_create(clnt);\n\t\tif (!fid) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tfid->uid = oldfid->uid;\n\t} else {\n\t\tfid = oldfid;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \">>> TWALK fids %d,%d nwname %ud wname[0] %s\\n\",\n\t\t oldfid->fid, fid->fid, nwname, wnames ? wnames[0] : NULL);\n\treq = p9_client_rpc(clnt, P9_TWALK, \"ddT\", oldfid->fid, fid->fid,\n\t\t\t    nwname, wnames);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"R\", &nwqids, &wqids);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tp9_req_put(clnt, req);\n\t\tgoto clunk_fid;\n\t}\n\tp9_req_put(clnt, req);\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RWALK nwqid %d:\\n\", nwqids);\n\n\tif (nwqids != nwname) {\n\t\terr = -ENOENT;\n\t\tgoto clunk_fid;\n\t}\n\n\tfor (count = 0; count < nwqids; count++)\n\t\tp9_debug(P9_DEBUG_9P, \"<<<     [%d] %x.%llx.%x\\n\",\n\t\t\t count, wqids[count].type,\n\t\t\t wqids[count].path,\n\t\t\t wqids[count].version);\n\n\tif (nwname)\n\t\tmemmove(&fid->qid, &wqids[nwqids - 1], sizeof(struct p9_qid));\n\telse\n\t\tmemmove(&fid->qid, &oldfid->qid, sizeof(struct p9_qid));\n\n\tkfree(wqids);\n\treturn fid;\n\nclunk_fid:\n\tkfree(wqids);\n\tp9_fid_put(fid);\n\tfid = NULL;\n\nerror:\n\tif (fid && fid != oldfid)\n\t\tp9_fid_destroy(fid);\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(p9_client_walk);\n\nint p9_client_open(struct p9_fid *fid, int mode)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\tstruct p9_qid qid;\n\tint iounit;\n\n\tclnt = fid->clnt;\n\tp9_debug(P9_DEBUG_9P, \">>> %s fid %d mode %d\\n\",\n\t\t p9_is_proto_dotl(clnt) ? \"TLOPEN\" : \"TOPEN\", fid->fid, mode);\n\n\tif (fid->mode != -1)\n\t\treturn -EINVAL;\n\n\tif (p9_is_proto_dotl(clnt))\n\t\treq = p9_client_rpc(clnt, P9_TLOPEN, \"dd\", fid->fid, mode & P9L_MODE_MASK);\n\telse\n\t\treq = p9_client_rpc(clnt, P9_TOPEN, \"db\", fid->fid, mode & P9L_MODE_MASK);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"Qd\", &qid, &iounit);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tgoto free_and_error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< %s qid %x.%llx.%x iounit %x\\n\",\n\t\t p9_is_proto_dotl(clnt) ? \"RLOPEN\" : \"ROPEN\",  qid.type,\n\t\t qid.path, qid.version, iounit);\n\n\tmemmove(&fid->qid, &qid, sizeof(struct p9_qid));\n\tfid->mode = mode;\n\tfid->iounit = iounit;\n\nfree_and_error:\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_open);\n\nint p9_client_create_dotl(struct p9_fid *ofid, const char *name, u32 flags,\n\t\t\t  u32 mode, kgid_t gid, struct p9_qid *qid)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\tint iounit;\n\n\tp9_debug(P9_DEBUG_9P,\n\t\t \">>> TLCREATE fid %d name %s flags %d mode %d gid %d\\n\",\n\t\t ofid->fid, name, flags, mode,\n\t\t from_kgid(&init_user_ns, gid));\n\tclnt = ofid->clnt;\n\n\tif (ofid->mode != -1)\n\t\treturn -EINVAL;\n\n\treq = p9_client_rpc(clnt, P9_TLCREATE, \"dsddg\", ofid->fid, name, flags,\n\t\t\t    mode & P9L_MODE_MASK, gid);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"Qd\", qid, &iounit);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tgoto free_and_error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RLCREATE qid %x.%llx.%x iounit %x\\n\",\n\t\t qid->type, qid->path, qid->version, iounit);\n\n\tmemmove(&ofid->qid, qid, sizeof(struct p9_qid));\n\tofid->mode = flags;\n\tofid->iounit = iounit;\n\nfree_and_error:\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_create_dotl);\n\nint p9_client_fcreate(struct p9_fid *fid, const char *name, u32 perm, int mode,\n\t\t     char *extension)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\tstruct p9_qid qid;\n\tint iounit;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TCREATE fid %d name %s perm %d mode %d\\n\",\n\t\t fid->fid, name, perm, mode);\n\tclnt = fid->clnt;\n\n\tif (fid->mode != -1)\n\t\treturn -EINVAL;\n\n\treq = p9_client_rpc(clnt, P9_TCREATE, \"dsdb?s\", fid->fid, name, perm,\n\t\t\t    mode & P9L_MODE_MASK, extension);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"Qd\", &qid, &iounit);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tgoto free_and_error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RCREATE qid %x.%llx.%x iounit %x\\n\",\n\t\t qid.type, qid.path, qid.version, iounit);\n\n\tmemmove(&fid->qid, &qid, sizeof(struct p9_qid));\n\tfid->mode = mode;\n\tfid->iounit = iounit;\n\nfree_and_error:\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_fcreate);\n\nint p9_client_symlink(struct p9_fid *dfid, const char *name,\n\t\t      const char *symtgt, kgid_t gid, struct p9_qid *qid)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TSYMLINK dfid %d name %s  symtgt %s\\n\",\n\t\t dfid->fid, name, symtgt);\n\tclnt = dfid->clnt;\n\n\treq = p9_client_rpc(clnt, P9_TSYMLINK, \"dssg\", dfid->fid, name, symtgt,\n\t\t\t    gid);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"Q\", qid);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tgoto free_and_error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RSYMLINK qid %x.%llx.%x\\n\",\n\t\t qid->type, qid->path, qid->version);\n\nfree_and_error:\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_symlink);\n\nint p9_client_link(struct p9_fid *dfid, struct p9_fid *oldfid, const char *newname)\n{\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TLINK dfid %d oldfid %d newname %s\\n\",\n\t\t dfid->fid, oldfid->fid, newname);\n\tclnt = dfid->clnt;\n\treq = p9_client_rpc(clnt, P9_TLINK, \"dds\", dfid->fid, oldfid->fid,\n\t\t\t    newname);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RLINK\\n\");\n\tp9_req_put(clnt, req);\n\treturn 0;\n}\nEXPORT_SYMBOL(p9_client_link);\n\nint p9_client_fsync(struct p9_fid *fid, int datasync)\n{\n\tint err = 0;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TFSYNC fid %d datasync:%d\\n\",\n\t\t fid->fid, datasync);\n\tclnt = fid->clnt;\n\n\treq = p9_client_rpc(clnt, P9_TFSYNC, \"dd\", fid->fid, datasync);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RFSYNC fid %d\\n\", fid->fid);\n\n\tp9_req_put(clnt, req);\n\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_fsync);\n\nint p9_client_clunk(struct p9_fid *fid)\n{\n\tint err = 0;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\tint retries = 0;\n\nagain:\n\tp9_debug(P9_DEBUG_9P, \">>> TCLUNK fid %d (try %d)\\n\",\n\t\t fid->fid, retries);\n\tclnt = fid->clnt;\n\n\treq = p9_client_rpc(clnt, P9_TCLUNK, \"d\", fid->fid);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RCLUNK fid %d\\n\", fid->fid);\n\n\tp9_req_put(clnt, req);\nerror:\n\t \n\tif (err == -ERESTARTSYS) {\n\t\tif (retries++ == 0)\n\t\t\tgoto again;\n\t} else {\n\t\tp9_fid_destroy(fid);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_clunk);\n\nint p9_client_remove(struct p9_fid *fid)\n{\n\tint err = 0;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TREMOVE fid %d\\n\", fid->fid);\n\tclnt = fid->clnt;\n\n\treq = p9_client_rpc(clnt, P9_TREMOVE, \"d\", fid->fid);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RREMOVE fid %d\\n\", fid->fid);\n\n\tp9_req_put(clnt, req);\nerror:\n\tif (err == -ERESTARTSYS)\n\t\tp9_fid_put(fid);\n\telse\n\t\tp9_fid_destroy(fid);\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_remove);\n\nint p9_client_unlinkat(struct p9_fid *dfid, const char *name, int flags)\n{\n\tint err = 0;\n\tstruct p9_req_t *req;\n\tstruct p9_client *clnt;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TUNLINKAT fid %d %s %d\\n\",\n\t\t dfid->fid, name, flags);\n\n\tclnt = dfid->clnt;\n\treq = p9_client_rpc(clnt, P9_TUNLINKAT, \"dsd\", dfid->fid, name, flags);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\tp9_debug(P9_DEBUG_9P, \"<<< RUNLINKAT fid %d %s\\n\", dfid->fid, name);\n\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_unlinkat);\n\nint\np9_client_read(struct p9_fid *fid, u64 offset, struct iov_iter *to, int *err)\n{\n\tint total = 0;\n\t*err = 0;\n\n\twhile (iov_iter_count(to)) {\n\t\tint count;\n\n\t\tcount = p9_client_read_once(fid, offset, to, err);\n\t\tif (!count || *err)\n\t\t\tbreak;\n\t\toffset += count;\n\t\ttotal += count;\n\t}\n\treturn total;\n}\nEXPORT_SYMBOL(p9_client_read);\n\nint\np9_client_read_once(struct p9_fid *fid, u64 offset, struct iov_iter *to,\n\t\t    int *err)\n{\n\tstruct p9_client *clnt = fid->clnt;\n\tstruct p9_req_t *req;\n\tint count = iov_iter_count(to);\n\tint rsize, received, non_zc = 0;\n\tchar *dataptr;\n\n\t*err = 0;\n\tp9_debug(P9_DEBUG_9P, \">>> TREAD fid %d offset %llu %zu\\n\",\n\t\t fid->fid, offset, iov_iter_count(to));\n\n\trsize = fid->iounit;\n\tif (!rsize || rsize > clnt->msize - P9_IOHDRSZ)\n\t\trsize = clnt->msize - P9_IOHDRSZ;\n\n\tif (count < rsize)\n\t\trsize = count;\n\n\t \n\tif (clnt->trans_mod->zc_request && rsize > 1024) {\n\t\t \n\t\treq = p9_client_zc_rpc(clnt, P9_TREAD, to, NULL, rsize,\n\t\t\t\t       0, 11, \"dqd\", fid->fid,\n\t\t\t\t       offset, rsize);\n\t} else {\n\t\tnon_zc = 1;\n\t\treq = p9_client_rpc(clnt, P9_TREAD, \"dqd\", fid->fid, offset,\n\t\t\t\t    rsize);\n\t}\n\tif (IS_ERR(req)) {\n\t\t*err = PTR_ERR(req);\n\t\tif (!non_zc)\n\t\t\tiov_iter_revert(to, count - iov_iter_count(to));\n\t\treturn 0;\n\t}\n\n\t*err = p9pdu_readf(&req->rc, clnt->proto_version,\n\t\t\t   \"D\", &received, &dataptr);\n\tif (*err) {\n\t\tif (!non_zc)\n\t\t\tiov_iter_revert(to, count - iov_iter_count(to));\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tp9_req_put(clnt, req);\n\t\treturn 0;\n\t}\n\tif (rsize < received) {\n\t\tpr_err(\"bogus RREAD count (%d > %d)\\n\", received, rsize);\n\t\treceived = rsize;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RREAD count %d\\n\", count);\n\n\tif (non_zc) {\n\t\tint n = copy_to_iter(dataptr, received, to);\n\n\t\tif (n != received) {\n\t\t\t*err = -EFAULT;\n\t\t\tp9_req_put(clnt, req);\n\t\t\treturn n;\n\t\t}\n\t} else {\n\t\tiov_iter_revert(to, count - received - iov_iter_count(to));\n\t}\n\tp9_req_put(clnt, req);\n\treturn received;\n}\nEXPORT_SYMBOL(p9_client_read_once);\n\nint\np9_client_write(struct p9_fid *fid, u64 offset, struct iov_iter *from, int *err)\n{\n\tstruct p9_client *clnt = fid->clnt;\n\tstruct p9_req_t *req;\n\tint total = 0;\n\t*err = 0;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TWRITE fid %d offset %llu count %zd\\n\",\n\t\t fid->fid, offset, iov_iter_count(from));\n\n\twhile (iov_iter_count(from)) {\n\t\tint count = iov_iter_count(from);\n\t\tint rsize = fid->iounit;\n\t\tint written;\n\n\t\tif (!rsize || rsize > clnt->msize - P9_IOHDRSZ)\n\t\t\trsize = clnt->msize - P9_IOHDRSZ;\n\n\t\tif (count < rsize)\n\t\t\trsize = count;\n\n\t\t \n\t\tif (clnt->trans_mod->zc_request && rsize > 1024) {\n\t\t\treq = p9_client_zc_rpc(clnt, P9_TWRITE, NULL, from, 0,\n\t\t\t\t\t       rsize, P9_ZC_HDR_SZ, \"dqd\",\n\t\t\t\t\t       fid->fid, offset, rsize);\n\t\t} else {\n\t\t\treq = p9_client_rpc(clnt, P9_TWRITE, \"dqV\", fid->fid,\n\t\t\t\t\t    offset, rsize, from);\n\t\t}\n\t\tif (IS_ERR(req)) {\n\t\t\tiov_iter_revert(from, count - iov_iter_count(from));\n\t\t\t*err = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\t*err = p9pdu_readf(&req->rc, clnt->proto_version, \"d\", &written);\n\t\tif (*err) {\n\t\t\tiov_iter_revert(from, count - iov_iter_count(from));\n\t\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\t\tp9_req_put(clnt, req);\n\t\t\tbreak;\n\t\t}\n\t\tif (rsize < written) {\n\t\t\tpr_err(\"bogus RWRITE count (%d > %d)\\n\", written, rsize);\n\t\t\twritten = rsize;\n\t\t}\n\n\t\tp9_debug(P9_DEBUG_9P, \"<<< RWRITE count %d\\n\", count);\n\n\t\tp9_req_put(clnt, req);\n\t\tiov_iter_revert(from, count - written - iov_iter_count(from));\n\t\ttotal += written;\n\t\toffset += written;\n\t}\n\treturn total;\n}\nEXPORT_SYMBOL(p9_client_write);\n\nstruct p9_wstat *p9_client_stat(struct p9_fid *fid)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_wstat *ret;\n\tstruct p9_req_t *req;\n\tu16 ignored;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TSTAT fid %d\\n\", fid->fid);\n\n\tret = kmalloc(sizeof(*ret), GFP_KERNEL);\n\tif (!ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclnt = fid->clnt;\n\n\treq = p9_client_rpc(clnt, P9_TSTAT, \"d\", fid->fid);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"wS\", &ignored, ret);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tp9_req_put(clnt, req);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P,\n\t\t \"<<< RSTAT sz=%x type=%x dev=%x qid=%x.%llx.%x\\n\"\n\t\t \"<<<    mode=%8.8x atime=%8.8x mtime=%8.8x length=%llx\\n\"\n\t\t \"<<<    name=%s uid=%s gid=%s muid=%s extension=(%s)\\n\"\n\t\t \"<<<    uid=%d gid=%d n_muid=%d\\n\",\n\t\t ret->size, ret->type, ret->dev, ret->qid.type, ret->qid.path,\n\t\t ret->qid.version, ret->mode,\n\t\t ret->atime, ret->mtime, ret->length,\n\t\t ret->name, ret->uid, ret->gid, ret->muid, ret->extension,\n\t\t from_kuid(&init_user_ns, ret->n_uid),\n\t\t from_kgid(&init_user_ns, ret->n_gid),\n\t\t from_kuid(&init_user_ns, ret->n_muid));\n\n\tp9_req_put(clnt, req);\n\treturn ret;\n\nerror:\n\tkfree(ret);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(p9_client_stat);\n\nstruct p9_stat_dotl *p9_client_getattr_dotl(struct p9_fid *fid,\n\t\t\t\t\t    u64 request_mask)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_stat_dotl *ret;\n\tstruct p9_req_t *req;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TGETATTR fid %d, request_mask %lld\\n\",\n\t\t fid->fid, request_mask);\n\n\tret = kmalloc(sizeof(*ret), GFP_KERNEL);\n\tif (!ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclnt = fid->clnt;\n\n\treq = p9_client_rpc(clnt, P9_TGETATTR, \"dq\", fid->fid, request_mask);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"A\", ret);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tp9_req_put(clnt, req);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RGETATTR st_result_mask=%lld\\n\"\n\t\t \"<<< qid=%x.%llx.%x\\n\"\n\t\t \"<<< st_mode=%8.8x st_nlink=%llu\\n\"\n\t\t \"<<< st_uid=%d st_gid=%d\\n\"\n\t\t \"<<< st_rdev=%llx st_size=%llx st_blksize=%llu st_blocks=%llu\\n\"\n\t\t \"<<< st_atime_sec=%lld st_atime_nsec=%lld\\n\"\n\t\t \"<<< st_mtime_sec=%lld st_mtime_nsec=%lld\\n\"\n\t\t \"<<< st_ctime_sec=%lld st_ctime_nsec=%lld\\n\"\n\t\t \"<<< st_btime_sec=%lld st_btime_nsec=%lld\\n\"\n\t\t \"<<< st_gen=%lld st_data_version=%lld\\n\",\n\t\t ret->st_result_mask,\n\t\t ret->qid.type, ret->qid.path, ret->qid.version,\n\t\t ret->st_mode, ret->st_nlink,\n\t\t from_kuid(&init_user_ns, ret->st_uid),\n\t\t from_kgid(&init_user_ns, ret->st_gid),\n\t\t ret->st_rdev, ret->st_size, ret->st_blksize, ret->st_blocks,\n\t\t ret->st_atime_sec, ret->st_atime_nsec,\n\t\t ret->st_mtime_sec, ret->st_mtime_nsec,\n\t\t ret->st_ctime_sec, ret->st_ctime_nsec,\n\t\t ret->st_btime_sec, ret->st_btime_nsec,\n\t\t ret->st_gen, ret->st_data_version);\n\n\tp9_req_put(clnt, req);\n\treturn ret;\n\nerror:\n\tkfree(ret);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(p9_client_getattr_dotl);\n\nstatic int p9_client_statsize(struct p9_wstat *wst, int proto_version)\n{\n\tint ret;\n\n\t \n\t \n\t \n\t \n\tret = 2 + 4 + 13 + 4 + 4 + 4 + 8 + 2 + 2 + 2 + 2;\n\n\tif (wst->name)\n\t\tret += strlen(wst->name);\n\tif (wst->uid)\n\t\tret += strlen(wst->uid);\n\tif (wst->gid)\n\t\tret += strlen(wst->gid);\n\tif (wst->muid)\n\t\tret += strlen(wst->muid);\n\n\tif (proto_version == p9_proto_2000u ||\n\t    proto_version == p9_proto_2000L) {\n\t\t \n\t\tret += 2 + 4 + 4 + 4;\n\t\tif (wst->extension)\n\t\t\tret += strlen(wst->extension);\n\t}\n\n\treturn ret;\n}\n\nint p9_client_wstat(struct p9_fid *fid, struct p9_wstat *wst)\n{\n\tint err = 0;\n\tstruct p9_req_t *req;\n\tstruct p9_client *clnt;\n\n\tclnt = fid->clnt;\n\twst->size = p9_client_statsize(wst, clnt->proto_version);\n\tp9_debug(P9_DEBUG_9P, \">>> TWSTAT fid %d\\n\",\n\t\t fid->fid);\n\tp9_debug(P9_DEBUG_9P,\n\t\t \"     sz=%x type=%x dev=%x qid=%x.%llx.%x\\n\"\n\t\t \"     mode=%8.8x atime=%8.8x mtime=%8.8x length=%llx\\n\"\n\t\t \"     name=%s uid=%s gid=%s muid=%s extension=(%s)\\n\"\n\t\t \"     uid=%d gid=%d n_muid=%d\\n\",\n\t\t wst->size, wst->type, wst->dev, wst->qid.type,\n\t\t wst->qid.path, wst->qid.version,\n\t\t wst->mode, wst->atime, wst->mtime, wst->length,\n\t\t wst->name, wst->uid, wst->gid, wst->muid, wst->extension,\n\t\t from_kuid(&init_user_ns, wst->n_uid),\n\t\t from_kgid(&init_user_ns, wst->n_gid),\n\t\t from_kuid(&init_user_ns, wst->n_muid));\n\n\treq = p9_client_rpc(clnt, P9_TWSTAT, \"dwS\",\n\t\t\t    fid->fid, wst->size + 2, wst);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RWSTAT fid %d\\n\", fid->fid);\n\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_wstat);\n\nint p9_client_setattr(struct p9_fid *fid, struct p9_iattr_dotl *p9attr)\n{\n\tint err = 0;\n\tstruct p9_req_t *req;\n\tstruct p9_client *clnt;\n\n\tclnt = fid->clnt;\n\tp9_debug(P9_DEBUG_9P, \">>> TSETATTR fid %d\\n\", fid->fid);\n\tp9_debug(P9_DEBUG_9P, \"    valid=%x mode=%x uid=%d gid=%d size=%lld\\n\",\n\t\t p9attr->valid, p9attr->mode,\n\t\t from_kuid(&init_user_ns, p9attr->uid),\n\t\t from_kgid(&init_user_ns, p9attr->gid),\n\t\t p9attr->size);\n\tp9_debug(P9_DEBUG_9P, \"    atime_sec=%lld atime_nsec=%lld\\n\",\n\t\t p9attr->atime_sec, p9attr->atime_nsec);\n\tp9_debug(P9_DEBUG_9P, \"    mtime_sec=%lld mtime_nsec=%lld\\n\",\n\t\t p9attr->mtime_sec, p9attr->mtime_nsec);\n\n\treq = p9_client_rpc(clnt, P9_TSETATTR, \"dI\", fid->fid, p9attr);\n\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\tp9_debug(P9_DEBUG_9P, \"<<< RSETATTR fid %d\\n\", fid->fid);\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_setattr);\n\nint p9_client_statfs(struct p9_fid *fid, struct p9_rstatfs *sb)\n{\n\tint err;\n\tstruct p9_req_t *req;\n\tstruct p9_client *clnt;\n\n\tclnt = fid->clnt;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TSTATFS fid %d\\n\", fid->fid);\n\n\treq = p9_client_rpc(clnt, P9_TSTATFS, \"d\", fid->fid);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"ddqqqqqqd\", &sb->type,\n\t\t\t  &sb->bsize, &sb->blocks, &sb->bfree, &sb->bavail,\n\t\t\t  &sb->files, &sb->ffree, &sb->fsid, &sb->namelen);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tp9_req_put(clnt, req);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P,\n\t\t \"<<< RSTATFS fid %d type 0x%x bsize %u blocks %llu bfree %llu bavail %llu files %llu ffree %llu fsid %llu namelen %u\\n\",\n\t\t fid->fid, sb->type, sb->bsize, sb->blocks, sb->bfree,\n\t\t sb->bavail, sb->files, sb->ffree, sb->fsid, sb->namelen);\n\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_statfs);\n\nint p9_client_rename(struct p9_fid *fid,\n\t\t     struct p9_fid *newdirfid, const char *name)\n{\n\tint err = 0;\n\tstruct p9_req_t *req;\n\tstruct p9_client *clnt;\n\n\tclnt = fid->clnt;\n\n\tp9_debug(P9_DEBUG_9P, \">>> TRENAME fid %d newdirfid %d name %s\\n\",\n\t\t fid->fid, newdirfid->fid, name);\n\n\treq = p9_client_rpc(clnt, P9_TRENAME, \"dds\", fid->fid,\n\t\t\t    newdirfid->fid, name);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RRENAME fid %d\\n\", fid->fid);\n\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_rename);\n\nint p9_client_renameat(struct p9_fid *olddirfid, const char *old_name,\n\t\t       struct p9_fid *newdirfid, const char *new_name)\n{\n\tint err = 0;\n\tstruct p9_req_t *req;\n\tstruct p9_client *clnt;\n\n\tclnt = olddirfid->clnt;\n\n\tp9_debug(P9_DEBUG_9P,\n\t\t \">>> TRENAMEAT olddirfid %d old name %s newdirfid %d new name %s\\n\",\n\t\t olddirfid->fid, old_name, newdirfid->fid, new_name);\n\n\treq = p9_client_rpc(clnt, P9_TRENAMEAT, \"dsds\", olddirfid->fid,\n\t\t\t    old_name, newdirfid->fid, new_name);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RRENAMEAT newdirfid %d new name %s\\n\",\n\t\t newdirfid->fid, new_name);\n\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_renameat);\n\n \nstruct p9_fid *p9_client_xattrwalk(struct p9_fid *file_fid,\n\t\t\t\t   const char *attr_name, u64 *attr_size)\n{\n\tint err;\n\tstruct p9_req_t *req;\n\tstruct p9_client *clnt;\n\tstruct p9_fid *attr_fid;\n\n\tclnt = file_fid->clnt;\n\tattr_fid = p9_fid_create(clnt);\n\tif (!attr_fid) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tp9_debug(P9_DEBUG_9P,\n\t\t \">>> TXATTRWALK file_fid %d, attr_fid %d name '%s'\\n\",\n\t\t file_fid->fid, attr_fid->fid, attr_name);\n\n\treq = p9_client_rpc(clnt, P9_TXATTRWALK, \"dds\",\n\t\t\t    file_fid->fid, attr_fid->fid, attr_name);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"q\", attr_size);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tp9_req_put(clnt, req);\n\t\tgoto clunk_fid;\n\t}\n\tp9_req_put(clnt, req);\n\tp9_debug(P9_DEBUG_9P, \"<<<  RXATTRWALK fid %d size %llu\\n\",\n\t\t attr_fid->fid, *attr_size);\n\treturn attr_fid;\nclunk_fid:\n\tp9_fid_put(attr_fid);\n\tattr_fid = NULL;\nerror:\n\tif (attr_fid && attr_fid != file_fid)\n\t\tp9_fid_destroy(attr_fid);\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(p9_client_xattrwalk);\n\nint p9_client_xattrcreate(struct p9_fid *fid, const char *name,\n\t\t\t  u64 attr_size, int flags)\n{\n\tint err = 0;\n\tstruct p9_req_t *req;\n\tstruct p9_client *clnt;\n\n\tp9_debug(P9_DEBUG_9P,\n\t\t \">>> TXATTRCREATE fid %d name  %s size %llu flag %d\\n\",\n\t\t fid->fid, name, attr_size, flags);\n\tclnt = fid->clnt;\n\treq = p9_client_rpc(clnt, P9_TXATTRCREATE, \"dsqd\",\n\t\t\t    fid->fid, name, attr_size, flags);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\tp9_debug(P9_DEBUG_9P, \"<<< RXATTRCREATE fid %d\\n\", fid->fid);\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(p9_client_xattrcreate);\n\nint p9_client_readdir(struct p9_fid *fid, char *data, u32 count, u64 offset)\n{\n\tint err, rsize, non_zc = 0;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\tchar *dataptr;\n\tstruct kvec kv = {.iov_base = data, .iov_len = count};\n\tstruct iov_iter to;\n\n\tiov_iter_kvec(&to, ITER_DEST, &kv, 1, count);\n\n\tp9_debug(P9_DEBUG_9P, \">>> TREADDIR fid %d offset %llu count %d\\n\",\n\t\t fid->fid, offset, count);\n\n\tclnt = fid->clnt;\n\n\trsize = fid->iounit;\n\tif (!rsize || rsize > clnt->msize - P9_READDIRHDRSZ)\n\t\trsize = clnt->msize - P9_READDIRHDRSZ;\n\n\tif (count < rsize)\n\t\trsize = count;\n\n\t \n\tif (clnt->trans_mod->zc_request && rsize > 1024) {\n\t\t \n\t\treq = p9_client_zc_rpc(clnt, P9_TREADDIR, &to, NULL, rsize, 0,\n\t\t\t\t       11, \"dqd\", fid->fid, offset, rsize);\n\t} else {\n\t\tnon_zc = 1;\n\t\treq = p9_client_rpc(clnt, P9_TREADDIR, \"dqd\", fid->fid,\n\t\t\t\t    offset, rsize);\n\t}\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto error;\n\t}\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"D\", &count, &dataptr);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tgoto free_and_error;\n\t}\n\tif (rsize < count) {\n\t\tpr_err(\"bogus RREADDIR count (%d > %d)\\n\", count, rsize);\n\t\tcount = rsize;\n\t}\n\n\tp9_debug(P9_DEBUG_9P, \"<<< RREADDIR count %d\\n\", count);\n\n\tif (non_zc)\n\t\tmemmove(data, dataptr, count);\n\n\tp9_req_put(clnt, req);\n\treturn count;\n\nfree_and_error:\n\tp9_req_put(clnt, req);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_readdir);\n\nint p9_client_mknod_dotl(struct p9_fid *fid, const char *name, int mode,\n\t\t\t dev_t rdev, kgid_t gid, struct p9_qid *qid)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\n\tclnt = fid->clnt;\n\tp9_debug(P9_DEBUG_9P,\n\t\t \">>> TMKNOD fid %d name %s mode %d major %d minor %d\\n\",\n\t\t fid->fid, name, mode, MAJOR(rdev), MINOR(rdev));\n\treq = p9_client_rpc(clnt, P9_TMKNOD, \"dsdddg\", fid->fid, name, mode,\n\t\t\t    MAJOR(rdev), MINOR(rdev), gid);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"Q\", qid);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tgoto error;\n\t}\n\tp9_debug(P9_DEBUG_9P, \"<<< RMKNOD qid %x.%llx.%x\\n\",\n\t\t qid->type, qid->path, qid->version);\n\nerror:\n\tp9_req_put(clnt, req);\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_mknod_dotl);\n\nint p9_client_mkdir_dotl(struct p9_fid *fid, const char *name, int mode,\n\t\t\t kgid_t gid, struct p9_qid *qid)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\n\tclnt = fid->clnt;\n\tp9_debug(P9_DEBUG_9P, \">>> TMKDIR fid %d name %s mode %d gid %d\\n\",\n\t\t fid->fid, name, mode, from_kgid(&init_user_ns, gid));\n\treq = p9_client_rpc(clnt, P9_TMKDIR, \"dsdg\",\n\t\t\t    fid->fid, name, mode, gid);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"Q\", qid);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tgoto error;\n\t}\n\tp9_debug(P9_DEBUG_9P, \"<<< RMKDIR qid %x.%llx.%x\\n\", qid->type,\n\t\t qid->path, qid->version);\n\nerror:\n\tp9_req_put(clnt, req);\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_mkdir_dotl);\n\nint p9_client_lock_dotl(struct p9_fid *fid, struct p9_flock *flock, u8 *status)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\n\tclnt = fid->clnt;\n\tp9_debug(P9_DEBUG_9P,\n\t\t \">>> TLOCK fid %d type %i flags %d start %lld length %lld proc_id %d client_id %s\\n\",\n\t\t fid->fid, flock->type, flock->flags, flock->start,\n\t\t flock->length, flock->proc_id, flock->client_id);\n\n\treq = p9_client_rpc(clnt, P9_TLOCK, \"dbdqqds\", fid->fid, flock->type,\n\t\t\t    flock->flags, flock->start, flock->length,\n\t\t\t    flock->proc_id, flock->client_id);\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"b\", status);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tgoto error;\n\t}\n\tp9_debug(P9_DEBUG_9P, \"<<< RLOCK status %i\\n\", *status);\nerror:\n\tp9_req_put(clnt, req);\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_lock_dotl);\n\nint p9_client_getlock_dotl(struct p9_fid *fid, struct p9_getlock *glock)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\n\tclnt = fid->clnt;\n\tp9_debug(P9_DEBUG_9P,\n\t\t \">>> TGETLOCK fid %d, type %i start %lld length %lld proc_id %d client_id %s\\n\",\n\t\t fid->fid, glock->type, glock->start, glock->length,\n\t\t glock->proc_id, glock->client_id);\n\n\treq = p9_client_rpc(clnt, P9_TGETLOCK, \"dbqqds\", fid->fid,\n\t\t\t    glock->type, glock->start, glock->length,\n\t\t\t    glock->proc_id, glock->client_id);\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"bqqds\", &glock->type,\n\t\t\t  &glock->start, &glock->length, &glock->proc_id,\n\t\t\t  &glock->client_id);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tgoto error;\n\t}\n\tp9_debug(P9_DEBUG_9P,\n\t\t \"<<< RGETLOCK type %i start %lld length %lld proc_id %d client_id %s\\n\",\n\t\t glock->type, glock->start, glock->length,\n\t\t glock->proc_id, glock->client_id);\nerror:\n\tp9_req_put(clnt, req);\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_getlock_dotl);\n\nint p9_client_readlink(struct p9_fid *fid, char **target)\n{\n\tint err;\n\tstruct p9_client *clnt;\n\tstruct p9_req_t *req;\n\n\tclnt = fid->clnt;\n\tp9_debug(P9_DEBUG_9P, \">>> TREADLINK fid %d\\n\", fid->fid);\n\n\treq = p9_client_rpc(clnt, P9_TREADLINK, \"d\", fid->fid);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\terr = p9pdu_readf(&req->rc, clnt->proto_version, \"s\", target);\n\tif (err) {\n\t\ttrace_9p_protocol_dump(clnt, &req->rc);\n\t\tgoto error;\n\t}\n\tp9_debug(P9_DEBUG_9P, \"<<< RREADLINK target %s\\n\", *target);\nerror:\n\tp9_req_put(clnt, req);\n\treturn err;\n}\nEXPORT_SYMBOL(p9_client_readlink);\n\nint __init p9_client_init(void)\n{\n\tp9_req_cache = KMEM_CACHE(p9_req_t, SLAB_TYPESAFE_BY_RCU);\n\treturn p9_req_cache ? 0 : -ENOMEM;\n}\n\nvoid __exit p9_client_exit(void)\n{\n\tkmem_cache_destroy(p9_req_cache);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}