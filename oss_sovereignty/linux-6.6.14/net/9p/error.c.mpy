{
  "module_name": "error.c",
  "hash_id": "2993e481b216b6415b81ba26efec2f5377f6fc10c10001f46d9c8e03f834943e",
  "original_prompt": "Ingested from linux-6.6.14/net/9p/error.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/errno.h>\n#include <net/9p/9p.h>\n\n \nstruct errormap {\n\tchar *name;\n\tint val;\n\n\tint namelen;\n\tstruct hlist_node list;\n};\n\n#define ERRHASHSZ\t\t32\nstatic struct hlist_head hash_errmap[ERRHASHSZ];\n\n \nstatic struct errormap errmap[] = {\n\t{\"Operation not permitted\", EPERM},\n\t{\"wstat prohibited\", EPERM},\n\t{\"No such file or directory\", ENOENT},\n\t{\"directory entry not found\", ENOENT},\n\t{\"file not found\", ENOENT},\n\t{\"Interrupted system call\", EINTR},\n\t{\"Input/output error\", EIO},\n\t{\"No such device or address\", ENXIO},\n\t{\"Argument list too long\", E2BIG},\n\t{\"Bad file descriptor\", EBADF},\n\t{\"Resource temporarily unavailable\", EAGAIN},\n\t{\"Cannot allocate memory\", ENOMEM},\n\t{\"Permission denied\", EACCES},\n\t{\"Bad address\", EFAULT},\n\t{\"Block device required\", ENOTBLK},\n\t{\"Device or resource busy\", EBUSY},\n\t{\"File exists\", EEXIST},\n\t{\"Invalid cross-device link\", EXDEV},\n\t{\"No such device\", ENODEV},\n\t{\"Not a directory\", ENOTDIR},\n\t{\"Is a directory\", EISDIR},\n\t{\"Invalid argument\", EINVAL},\n\t{\"Too many open files in system\", ENFILE},\n\t{\"Too many open files\", EMFILE},\n\t{\"Text file busy\", ETXTBSY},\n\t{\"File too large\", EFBIG},\n\t{\"No space left on device\", ENOSPC},\n\t{\"Illegal seek\", ESPIPE},\n\t{\"Read-only file system\", EROFS},\n\t{\"Too many links\", EMLINK},\n\t{\"Broken pipe\", EPIPE},\n\t{\"Numerical argument out of domain\", EDOM},\n\t{\"Numerical result out of range\", ERANGE},\n\t{\"Resource deadlock avoided\", EDEADLK},\n\t{\"File name too long\", ENAMETOOLONG},\n\t{\"No locks available\", ENOLCK},\n\t{\"Function not implemented\", ENOSYS},\n\t{\"Directory not empty\", ENOTEMPTY},\n\t{\"Too many levels of symbolic links\", ELOOP},\n\t{\"No message of desired type\", ENOMSG},\n\t{\"Identifier removed\", EIDRM},\n\t{\"No data available\", ENODATA},\n\t{\"Machine is not on the network\", ENONET},\n\t{\"Package not installed\", ENOPKG},\n\t{\"Object is remote\", EREMOTE},\n\t{\"Link has been severed\", ENOLINK},\n\t{\"Communication error on send\", ECOMM},\n\t{\"Protocol error\", EPROTO},\n\t{\"Bad message\", EBADMSG},\n\t{\"File descriptor in bad state\", EBADFD},\n\t{\"Streams pipe error\", ESTRPIPE},\n\t{\"Too many users\", EUSERS},\n\t{\"Socket operation on non-socket\", ENOTSOCK},\n\t{\"Message too long\", EMSGSIZE},\n\t{\"Protocol not available\", ENOPROTOOPT},\n\t{\"Protocol not supported\", EPROTONOSUPPORT},\n\t{\"Socket type not supported\", ESOCKTNOSUPPORT},\n\t{\"Operation not supported\", EOPNOTSUPP},\n\t{\"Protocol family not supported\", EPFNOSUPPORT},\n\t{\"Network is down\", ENETDOWN},\n\t{\"Network is unreachable\", ENETUNREACH},\n\t{\"Network dropped connection on reset\", ENETRESET},\n\t{\"Software caused connection abort\", ECONNABORTED},\n\t{\"Connection reset by peer\", ECONNRESET},\n\t{\"No buffer space available\", ENOBUFS},\n\t{\"Transport endpoint is already connected\", EISCONN},\n\t{\"Transport endpoint is not connected\", ENOTCONN},\n\t{\"Cannot send after transport endpoint shutdown\", ESHUTDOWN},\n\t{\"Connection timed out\", ETIMEDOUT},\n\t{\"Connection refused\", ECONNREFUSED},\n\t{\"Host is down\", EHOSTDOWN},\n\t{\"No route to host\", EHOSTUNREACH},\n\t{\"Operation already in progress\", EALREADY},\n\t{\"Operation now in progress\", EINPROGRESS},\n\t{\"Is a named type file\", EISNAM},\n\t{\"Remote I/O error\", EREMOTEIO},\n\t{\"Disk quota exceeded\", EDQUOT},\n \n\t{\"fid unknown or out of range\", EBADF},\n\t{\"permission denied\", EACCES},\n\t{\"file does not exist\", ENOENT},\n\t{\"authentication failed\", ECONNREFUSED},\n\t{\"bad offset in directory read\", ESPIPE},\n\t{\"bad use of fid\", EBADF},\n\t{\"wstat can't convert between files and directories\", EPERM},\n\t{\"directory is not empty\", ENOTEMPTY},\n\t{\"file exists\", EEXIST},\n\t{\"file already exists\", EEXIST},\n\t{\"file or directory already exists\", EEXIST},\n\t{\"fid already in use\", EBADF},\n\t{\"file in use\", ETXTBSY},\n\t{\"i/o error\", EIO},\n\t{\"file already open for I/O\", ETXTBSY},\n\t{\"illegal mode\", EINVAL},\n\t{\"illegal name\", ENAMETOOLONG},\n\t{\"not a directory\", ENOTDIR},\n\t{\"not a member of proposed group\", EPERM},\n\t{\"not owner\", EACCES},\n\t{\"only owner can change group in wstat\", EACCES},\n\t{\"read only file system\", EROFS},\n\t{\"no access to special file\", EPERM},\n\t{\"i/o count too large\", EIO},\n\t{\"unknown group\", EINVAL},\n\t{\"unknown user\", EINVAL},\n\t{\"bogus wstat buffer\", EPROTO},\n\t{\"exclusive use file already open\", EAGAIN},\n\t{\"corrupted directory entry\", EIO},\n\t{\"corrupted file entry\", EIO},\n\t{\"corrupted block label\", EIO},\n\t{\"corrupted meta data\", EIO},\n\t{\"illegal offset\", EINVAL},\n\t{\"illegal path element\", ENOENT},\n\t{\"root of file system is corrupted\", EIO},\n\t{\"corrupted super block\", EIO},\n\t{\"protocol botch\", EPROTO},\n\t{\"file system is full\", ENOSPC},\n\t{\"file is in use\", EAGAIN},\n\t{\"directory entry is not allocated\", ENOENT},\n\t{\"file is read only\", EROFS},\n\t{\"file has been removed\", EIDRM},\n\t{\"only support truncation to zero length\", EPERM},\n\t{\"cannot remove root\", EPERM},\n\t{\"file too big\", EFBIG},\n\t{\"venti i/o error\", EIO},\n\t \n\t{\"u9fs rhostsauth: no authentication required\", 0},\n\t{\"u9fs authnone: no authentication required\", 0},\n\t{NULL, -1}\n};\n\n \n\nint p9_error_init(void)\n{\n\tstruct errormap *c;\n\tint bucket;\n\n\t \n\tfor (bucket = 0; bucket < ERRHASHSZ; bucket++)\n\t\tINIT_HLIST_HEAD(&hash_errmap[bucket]);\n\n\t \n\tfor (c = errmap; c->name; c++) {\n\t\tc->namelen = strlen(c->name);\n\t\tbucket = jhash(c->name, c->namelen, 0) % ERRHASHSZ;\n\t\tINIT_HLIST_NODE(&c->list);\n\t\thlist_add_head(&c->list, &hash_errmap[bucket]);\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL(p9_error_init);\n\n \n\nint p9_errstr2errno(char *errstr, int len)\n{\n\tint errno;\n\tstruct errormap *c;\n\tint bucket;\n\n\terrno = 0;\n\tc = NULL;\n\tbucket = jhash(errstr, len, 0) % ERRHASHSZ;\n\thlist_for_each_entry(c, &hash_errmap[bucket], list) {\n\t\tif (c->namelen == len && !memcmp(c->name, errstr, len)) {\n\t\t\terrno = c->val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (errno == 0) {\n\t\t \n\t\terrstr[len] = 0;\n\t\tpr_err(\"%s: server reported unknown error %s\\n\",\n\t\t       __func__, errstr);\n\t\terrno = ESERVERFAULT;\n\t}\n\n\treturn -errno;\n}\nEXPORT_SYMBOL(p9_errstr2errno);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}