{
  "module_name": "trans_virtio.c",
  "hash_id": "0fd779f8f033d90b4d63b2aec6da65e3c29ba07eeb69eaeb18c0a05e72b24678",
  "original_prompt": "Ingested from linux-6.6.14/net/9p/trans_virtio.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/in.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/ipv6.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/un.h>\n#include <linux/uaccess.h>\n#include <linux/inet.h>\n#include <linux/file.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <net/9p/9p.h>\n#include <linux/parser.h>\n#include <net/9p/client.h>\n#include <net/9p/transport.h>\n#include <linux/scatterlist.h>\n#include <linux/swap.h>\n#include <linux/virtio.h>\n#include <linux/virtio_9p.h>\n#include \"trans_common.h\"\n\n#define VIRTQUEUE_NUM\t128\n\n \nstatic DEFINE_MUTEX(virtio_9p_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(vp_wq);\nstatic atomic_t vp_pinned = ATOMIC_INIT(0);\n\n \n\nstruct virtio_chan {\n\tbool inuse;\n\n\tspinlock_t lock;\n\n\tstruct p9_client *client;\n\tstruct virtio_device *vdev;\n\tstruct virtqueue *vq;\n\tint ring_bufs_avail;\n\twait_queue_head_t *vc_wq;\n\t \n\tunsigned long p9_max_pages;\n\t \n\tstruct scatterlist sg[VIRTQUEUE_NUM];\n\t \n\tchar *tag;\n\n\tstruct list_head chan_list;\n};\n\nstatic struct list_head virtio_chan_list;\n\n \nstatic unsigned int rest_of_page(void *data)\n{\n\treturn PAGE_SIZE - offset_in_page(data);\n}\n\n \n\nstatic void p9_virtio_close(struct p9_client *client)\n{\n\tstruct virtio_chan *chan = client->trans;\n\n\tmutex_lock(&virtio_9p_lock);\n\tif (chan)\n\t\tchan->inuse = false;\n\tmutex_unlock(&virtio_9p_lock);\n}\n\n \n\nstatic void req_done(struct virtqueue *vq)\n{\n\tstruct virtio_chan *chan = vq->vdev->priv;\n\tunsigned int len;\n\tstruct p9_req_t *req;\n\tbool need_wakeup = false;\n\tunsigned long flags;\n\n\tp9_debug(P9_DEBUG_TRANS, \": request done\\n\");\n\n\tspin_lock_irqsave(&chan->lock, flags);\n\twhile ((req = virtqueue_get_buf(chan->vq, &len)) != NULL) {\n\t\tif (!chan->ring_bufs_avail) {\n\t\t\tchan->ring_bufs_avail = 1;\n\t\t\tneed_wakeup = true;\n\t\t}\n\n\t\tif (len) {\n\t\t\treq->rc.size = len;\n\t\t\tp9_client_cb(chan->client, req, REQ_STATUS_RCVD);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chan->lock, flags);\n\t \n\tif (need_wakeup)\n\t\twake_up(chan->vc_wq);\n}\n\n \n\nstatic int pack_sg_list(struct scatterlist *sg, int start,\n\t\t\tint limit, char *data, int count)\n{\n\tint s;\n\tint index = start;\n\n\twhile (count) {\n\t\ts = rest_of_page(data);\n\t\tif (s > count)\n\t\t\ts = count;\n\t\tBUG_ON(index >= limit);\n\t\t \n\t\tsg_unmark_end(&sg[index]);\n\t\tsg_set_buf(&sg[index++], data, s);\n\t\tcount -= s;\n\t\tdata += s;\n\t}\n\tif (index-start)\n\t\tsg_mark_end(&sg[index - 1]);\n\treturn index-start;\n}\n\n \nstatic int p9_virtio_cancel(struct p9_client *client, struct p9_req_t *req)\n{\n\treturn 1;\n}\n\n \nstatic int p9_virtio_cancelled(struct p9_client *client, struct p9_req_t *req)\n{\n\tp9_req_put(client, req);\n\treturn 0;\n}\n\n \nstatic int\npack_sg_list_p(struct scatterlist *sg, int start, int limit,\n\t       struct page **pdata, int nr_pages, size_t offs, int count)\n{\n\tint i = 0, s;\n\tint data_off = offs;\n\tint index = start;\n\n\tBUG_ON(nr_pages > (limit - start));\n\t \n\twhile (nr_pages) {\n\t\ts = PAGE_SIZE - data_off;\n\t\tif (s > count)\n\t\t\ts = count;\n\t\tBUG_ON(index >= limit);\n\t\t \n\t\tsg_unmark_end(&sg[index]);\n\t\tsg_set_page(&sg[index++], pdata[i++], s, data_off);\n\t\tdata_off = 0;\n\t\tcount -= s;\n\t\tnr_pages--;\n\t}\n\n\tif (index-start)\n\t\tsg_mark_end(&sg[index - 1]);\n\treturn index - start;\n}\n\n \n\nstatic int\np9_virtio_request(struct p9_client *client, struct p9_req_t *req)\n{\n\tint err;\n\tint in, out, out_sgs, in_sgs;\n\tunsigned long flags;\n\tstruct virtio_chan *chan = client->trans;\n\tstruct scatterlist *sgs[2];\n\n\tp9_debug(P9_DEBUG_TRANS, \"9p debug: virtio request\\n\");\n\n\tWRITE_ONCE(req->status, REQ_STATUS_SENT);\nreq_retry:\n\tspin_lock_irqsave(&chan->lock, flags);\n\n\tout_sgs = in_sgs = 0;\n\t \n\tout = pack_sg_list(chan->sg, 0,\n\t\t\t   VIRTQUEUE_NUM, req->tc.sdata, req->tc.size);\n\tif (out)\n\t\tsgs[out_sgs++] = chan->sg;\n\n\tin = pack_sg_list(chan->sg, out,\n\t\t\t  VIRTQUEUE_NUM, req->rc.sdata, req->rc.capacity);\n\tif (in)\n\t\tsgs[out_sgs + in_sgs++] = chan->sg + out;\n\n\terr = virtqueue_add_sgs(chan->vq, sgs, out_sgs, in_sgs, req,\n\t\t\t\tGFP_ATOMIC);\n\tif (err < 0) {\n\t\tif (err == -ENOSPC) {\n\t\t\tchan->ring_bufs_avail = 0;\n\t\t\tspin_unlock_irqrestore(&chan->lock, flags);\n\t\t\terr = wait_event_killable(*chan->vc_wq,\n\t\t\t\t\t\t  chan->ring_bufs_avail);\n\t\t\tif (err  == -ERESTARTSYS)\n\t\t\t\treturn err;\n\n\t\t\tp9_debug(P9_DEBUG_TRANS, \"Retry virtio request\\n\");\n\t\t\tgoto req_retry;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&chan->lock, flags);\n\t\t\tp9_debug(P9_DEBUG_TRANS,\n\t\t\t\t \"virtio rpc add_sgs returned failure\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tvirtqueue_kick(chan->vq);\n\tspin_unlock_irqrestore(&chan->lock, flags);\n\n\tp9_debug(P9_DEBUG_TRANS, \"virtio request kicked\\n\");\n\treturn 0;\n}\n\nstatic int p9_get_mapped_pages(struct virtio_chan *chan,\n\t\t\t       struct page ***pages,\n\t\t\t       struct iov_iter *data,\n\t\t\t       int count,\n\t\t\t       size_t *offs,\n\t\t\t       int *need_drop)\n{\n\tint nr_pages;\n\tint err;\n\n\tif (!iov_iter_count(data))\n\t\treturn 0;\n\n\tif (!iov_iter_is_kvec(data)) {\n\t\tint n;\n\t\t \n\t\tif (atomic_read(&vp_pinned) >= chan->p9_max_pages) {\n\t\t\terr = wait_event_killable(vp_wq,\n\t\t\t      (atomic_read(&vp_pinned) < chan->p9_max_pages));\n\t\t\tif (err == -ERESTARTSYS)\n\t\t\t\treturn err;\n\t\t}\n\t\tn = iov_iter_get_pages_alloc2(data, pages, count, offs);\n\t\tif (n < 0)\n\t\t\treturn n;\n\t\t*need_drop = 1;\n\t\tnr_pages = DIV_ROUND_UP(n + *offs, PAGE_SIZE);\n\t\tatomic_add(nr_pages, &vp_pinned);\n\t\treturn n;\n\t} else {\n\t\t \n\t\tint index;\n\t\tsize_t len;\n\t\tvoid *p;\n\n\t\t \n\t\twhile (1) {\n\t\t\tlen = iov_iter_single_seg_count(data);\n\t\t\tif (likely(len)) {\n\t\t\t\tp = data->kvec->iov_base + data->iov_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiov_iter_advance(data, 0);\n\t\t}\n\t\tif (len > count)\n\t\t\tlen = count;\n\n\t\tnr_pages = DIV_ROUND_UP((unsigned long)p + len, PAGE_SIZE) -\n\t\t\t   (unsigned long)p / PAGE_SIZE;\n\n\t\t*pages = kmalloc_array(nr_pages, sizeof(struct page *),\n\t\t\t\t       GFP_NOFS);\n\t\tif (!*pages)\n\t\t\treturn -ENOMEM;\n\n\t\t*need_drop = 0;\n\t\tp -= (*offs = offset_in_page(p));\n\t\tfor (index = 0; index < nr_pages; index++) {\n\t\t\tif (is_vmalloc_addr(p))\n\t\t\t\t(*pages)[index] = vmalloc_to_page(p);\n\t\t\telse\n\t\t\t\t(*pages)[index] = kmap_to_page(p);\n\t\t\tp += PAGE_SIZE;\n\t\t}\n\t\tiov_iter_advance(data, len);\n\t\treturn len;\n\t}\n}\n\nstatic void handle_rerror(struct p9_req_t *req, int in_hdr_len,\n\t\t\t  size_t offs, struct page **pages)\n{\n\tunsigned size, n;\n\tvoid *to = req->rc.sdata + in_hdr_len;\n\n\t\n\tif (req->rc.size < in_hdr_len || !pages)\n\t\treturn;\n\n\t\n\t\n\t\n\t\n\tif (unlikely(req->rc.size > P9_ZC_HDR_SZ))\n\t\treq->rc.size = P9_ZC_HDR_SZ;\n\n\t\n\tsize = req->rc.size - in_hdr_len;\n\tn = PAGE_SIZE - offs;\n\tif (size > n) {\n\t\tmemcpy_from_page(to, *pages++, offs, n);\n\t\toffs = 0;\n\t\tto += n;\n\t\tsize -= n;\n\t}\n\tmemcpy_from_page(to, *pages, offs, size);\n}\n\n \nstatic int\np9_virtio_zc_request(struct p9_client *client, struct p9_req_t *req,\n\t\t     struct iov_iter *uidata, struct iov_iter *uodata,\n\t\t     int inlen, int outlen, int in_hdr_len)\n{\n\tint in, out, err, out_sgs, in_sgs;\n\tunsigned long flags;\n\tint in_nr_pages = 0, out_nr_pages = 0;\n\tstruct page **in_pages = NULL, **out_pages = NULL;\n\tstruct virtio_chan *chan = client->trans;\n\tstruct scatterlist *sgs[4];\n\tsize_t offs = 0;\n\tint need_drop = 0;\n\tint kicked = 0;\n\n\tp9_debug(P9_DEBUG_TRANS, \"virtio request\\n\");\n\n\tif (uodata) {\n\t\t__le32 sz;\n\t\tint n = p9_get_mapped_pages(chan, &out_pages, uodata,\n\t\t\t\t\t    outlen, &offs, &need_drop);\n\t\tif (n < 0) {\n\t\t\terr = n;\n\t\t\tgoto err_out;\n\t\t}\n\t\tout_nr_pages = DIV_ROUND_UP(n + offs, PAGE_SIZE);\n\t\tif (n != outlen) {\n\t\t\t__le32 v = cpu_to_le32(n);\n\t\t\tmemcpy(&req->tc.sdata[req->tc.size - 4], &v, 4);\n\t\t\toutlen = n;\n\t\t}\n\t\t \n\t\tsz = cpu_to_le32(req->tc.size + outlen);\n\t\tmemcpy(&req->tc.sdata[0], &sz, sizeof(sz));\n\t} else if (uidata) {\n\t\tint n = p9_get_mapped_pages(chan, &in_pages, uidata,\n\t\t\t\t\t    inlen, &offs, &need_drop);\n\t\tif (n < 0) {\n\t\t\terr = n;\n\t\t\tgoto err_out;\n\t\t}\n\t\tin_nr_pages = DIV_ROUND_UP(n + offs, PAGE_SIZE);\n\t\tif (n != inlen) {\n\t\t\t__le32 v = cpu_to_le32(n);\n\t\t\tmemcpy(&req->tc.sdata[req->tc.size - 4], &v, 4);\n\t\t\tinlen = n;\n\t\t}\n\t}\n\tWRITE_ONCE(req->status, REQ_STATUS_SENT);\nreq_retry_pinned:\n\tspin_lock_irqsave(&chan->lock, flags);\n\n\tout_sgs = in_sgs = 0;\n\n\t \n\tout = pack_sg_list(chan->sg, 0,\n\t\t\t   VIRTQUEUE_NUM, req->tc.sdata, req->tc.size);\n\n\tif (out)\n\t\tsgs[out_sgs++] = chan->sg;\n\n\tif (out_pages) {\n\t\tsgs[out_sgs++] = chan->sg + out;\n\t\tout += pack_sg_list_p(chan->sg, out, VIRTQUEUE_NUM,\n\t\t\t\t      out_pages, out_nr_pages, offs, outlen);\n\t}\n\n\t \n\tin = pack_sg_list(chan->sg, out,\n\t\t\t  VIRTQUEUE_NUM, req->rc.sdata, in_hdr_len);\n\tif (in)\n\t\tsgs[out_sgs + in_sgs++] = chan->sg + out;\n\n\tif (in_pages) {\n\t\tsgs[out_sgs + in_sgs++] = chan->sg + out + in;\n\t\tpack_sg_list_p(chan->sg, out + in, VIRTQUEUE_NUM,\n\t\t\t       in_pages, in_nr_pages, offs, inlen);\n\t}\n\n\tBUG_ON(out_sgs + in_sgs > ARRAY_SIZE(sgs));\n\terr = virtqueue_add_sgs(chan->vq, sgs, out_sgs, in_sgs, req,\n\t\t\t\tGFP_ATOMIC);\n\tif (err < 0) {\n\t\tif (err == -ENOSPC) {\n\t\t\tchan->ring_bufs_avail = 0;\n\t\t\tspin_unlock_irqrestore(&chan->lock, flags);\n\t\t\terr = wait_event_killable(*chan->vc_wq,\n\t\t\t\t\t\t  chan->ring_bufs_avail);\n\t\t\tif (err  == -ERESTARTSYS)\n\t\t\t\tgoto err_out;\n\n\t\t\tp9_debug(P9_DEBUG_TRANS, \"Retry virtio request\\n\");\n\t\t\tgoto req_retry_pinned;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&chan->lock, flags);\n\t\t\tp9_debug(P9_DEBUG_TRANS,\n\t\t\t\t \"virtio rpc add_sgs returned failure\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tvirtqueue_kick(chan->vq);\n\tspin_unlock_irqrestore(&chan->lock, flags);\n\tkicked = 1;\n\tp9_debug(P9_DEBUG_TRANS, \"virtio request kicked\\n\");\n\terr = wait_event_killable(req->wq,\n\t\t\t          READ_ONCE(req->status) >= REQ_STATUS_RCVD);\n\t \n\tif (READ_ONCE(req->status) == REQ_STATUS_RCVD &&\n\t    unlikely(req->rc.sdata[4] == P9_RERROR))\n\t\thandle_rerror(req, in_hdr_len, offs, in_pages);\n\n\t \nerr_out:\n\tif (need_drop) {\n\t\tif (in_pages) {\n\t\t\tp9_release_pages(in_pages, in_nr_pages);\n\t\t\tatomic_sub(in_nr_pages, &vp_pinned);\n\t\t}\n\t\tif (out_pages) {\n\t\t\tp9_release_pages(out_pages, out_nr_pages);\n\t\t\tatomic_sub(out_nr_pages, &vp_pinned);\n\t\t}\n\t\t \n\t\twake_up(&vp_wq);\n\t}\n\tkvfree(in_pages);\n\tkvfree(out_pages);\n\tif (!kicked) {\n\t\t \n\t\tp9_req_put(client, req);\n\t}\n\treturn err;\n}\n\nstatic ssize_t p9_mount_tag_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct virtio_chan *chan;\n\tstruct virtio_device *vdev;\n\tint tag_len;\n\n\tvdev = dev_to_virtio(dev);\n\tchan = vdev->priv;\n\ttag_len = strlen(chan->tag);\n\n\tmemcpy(buf, chan->tag, tag_len + 1);\n\n\treturn tag_len + 1;\n}\n\nstatic DEVICE_ATTR(mount_tag, 0444, p9_mount_tag_show, NULL);\n\n \n\nstatic int p9_virtio_probe(struct virtio_device *vdev)\n{\n\t__u16 tag_len;\n\tchar *tag;\n\tint err;\n\tstruct virtio_chan *chan;\n\n\tif (!vdev->config->get) {\n\t\tdev_err(&vdev->dev, \"%s failure: config access disabled\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tchan = kmalloc(sizeof(struct virtio_chan), GFP_KERNEL);\n\tif (!chan) {\n\t\tpr_err(\"Failed to allocate virtio 9P channel\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tchan->vdev = vdev;\n\n\t \n\tchan->vq = virtio_find_single_vq(vdev, req_done, \"requests\");\n\tif (IS_ERR(chan->vq)) {\n\t\terr = PTR_ERR(chan->vq);\n\t\tgoto out_free_chan;\n\t}\n\tchan->vq->vdev->priv = chan;\n\tspin_lock_init(&chan->lock);\n\n\tsg_init_table(chan->sg, VIRTQUEUE_NUM);\n\n\tchan->inuse = false;\n\tif (virtio_has_feature(vdev, VIRTIO_9P_MOUNT_TAG)) {\n\t\tvirtio_cread(vdev, struct virtio_9p_config, tag_len, &tag_len);\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out_free_vq;\n\t}\n\ttag = kzalloc(tag_len + 1, GFP_KERNEL);\n\tif (!tag) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_vq;\n\t}\n\n\tvirtio_cread_bytes(vdev, offsetof(struct virtio_9p_config, tag),\n\t\t\t   tag, tag_len);\n\tchan->tag = tag;\n\terr = sysfs_create_file(&(vdev->dev.kobj), &dev_attr_mount_tag.attr);\n\tif (err) {\n\t\tgoto out_free_tag;\n\t}\n\tchan->vc_wq = kmalloc(sizeof(wait_queue_head_t), GFP_KERNEL);\n\tif (!chan->vc_wq) {\n\t\terr = -ENOMEM;\n\t\tgoto out_remove_file;\n\t}\n\tinit_waitqueue_head(chan->vc_wq);\n\tchan->ring_bufs_avail = 1;\n\t \n\tchan->p9_max_pages = nr_free_buffer_pages()/4;\n\n\tvirtio_device_ready(vdev);\n\n\tmutex_lock(&virtio_9p_lock);\n\tlist_add_tail(&chan->chan_list, &virtio_chan_list);\n\tmutex_unlock(&virtio_9p_lock);\n\n\t \n\tkobject_uevent(&(vdev->dev.kobj), KOBJ_CHANGE);\n\n\treturn 0;\n\nout_remove_file:\n\tsysfs_remove_file(&vdev->dev.kobj, &dev_attr_mount_tag.attr);\nout_free_tag:\n\tkfree(tag);\nout_free_vq:\n\tvdev->config->del_vqs(vdev);\nout_free_chan:\n\tkfree(chan);\nfail:\n\treturn err;\n}\n\n\n \n\nstatic int\np9_virtio_create(struct p9_client *client, const char *devname, char *args)\n{\n\tstruct virtio_chan *chan;\n\tint ret = -ENOENT;\n\tint found = 0;\n\n\tif (devname == NULL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&virtio_9p_lock);\n\tlist_for_each_entry(chan, &virtio_chan_list, chan_list) {\n\t\tif (!strcmp(devname, chan->tag)) {\n\t\t\tif (!chan->inuse) {\n\t\t\t\tchan->inuse = true;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = -EBUSY;\n\t\t}\n\t}\n\tmutex_unlock(&virtio_9p_lock);\n\n\tif (!found) {\n\t\tpr_err(\"no channels available for device %s\\n\", devname);\n\t\treturn ret;\n\t}\n\n\tclient->trans = (void *)chan;\n\tclient->status = Connected;\n\tchan->client = client;\n\n\treturn 0;\n}\n\n \n\nstatic void p9_virtio_remove(struct virtio_device *vdev)\n{\n\tstruct virtio_chan *chan = vdev->priv;\n\tunsigned long warning_time;\n\n\tmutex_lock(&virtio_9p_lock);\n\n\t \n\tlist_del(&chan->chan_list);\n\twarning_time = jiffies;\n\n\t \n\twhile (chan->inuse) {\n\t\tmutex_unlock(&virtio_9p_lock);\n\t\tmsleep(250);\n\t\tif (time_after(jiffies, warning_time + 10 * HZ)) {\n\t\t\tdev_emerg(&vdev->dev,\n\t\t\t\t  \"p9_virtio_remove: waiting for device in use.\\n\");\n\t\t\twarning_time = jiffies;\n\t\t}\n\t\tmutex_lock(&virtio_9p_lock);\n\t}\n\n\tmutex_unlock(&virtio_9p_lock);\n\n\tvirtio_reset_device(vdev);\n\tvdev->config->del_vqs(vdev);\n\n\tsysfs_remove_file(&(vdev->dev.kobj), &dev_attr_mount_tag.attr);\n\tkobject_uevent(&(vdev->dev.kobj), KOBJ_CHANGE);\n\tkfree(chan->tag);\n\tkfree(chan->vc_wq);\n\tkfree(chan);\n\n}\n\nstatic struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_9P, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\nstatic unsigned int features[] = {\n\tVIRTIO_9P_MOUNT_TAG,\n};\n\n \nstatic struct virtio_driver p9_virtio_drv = {\n\t.feature_table  = features,\n\t.feature_table_size = ARRAY_SIZE(features),\n\t.driver.name    = KBUILD_MODNAME,\n\t.driver.owner\t= THIS_MODULE,\n\t.id_table\t= id_table,\n\t.probe\t\t= p9_virtio_probe,\n\t.remove\t\t= p9_virtio_remove,\n};\n\nstatic struct p9_trans_module p9_virtio_trans = {\n\t.name = \"virtio\",\n\t.create = p9_virtio_create,\n\t.close = p9_virtio_close,\n\t.request = p9_virtio_request,\n\t.zc_request = p9_virtio_zc_request,\n\t.cancel = p9_virtio_cancel,\n\t.cancelled = p9_virtio_cancelled,\n\t \n\t.maxsize = PAGE_SIZE * (VIRTQUEUE_NUM - 3),\n\t.pooled_rbuffers = false,\n\t.def = 1,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic int __init p9_virtio_init(void)\n{\n\tint rc;\n\n\tINIT_LIST_HEAD(&virtio_chan_list);\n\n\tv9fs_register_trans(&p9_virtio_trans);\n\trc = register_virtio_driver(&p9_virtio_drv);\n\tif (rc)\n\t\tv9fs_unregister_trans(&p9_virtio_trans);\n\n\treturn rc;\n}\n\nstatic void __exit p9_virtio_cleanup(void)\n{\n\tunregister_virtio_driver(&p9_virtio_drv);\n\tv9fs_unregister_trans(&p9_virtio_trans);\n}\n\nmodule_init(p9_virtio_init);\nmodule_exit(p9_virtio_cleanup);\nMODULE_ALIAS_9P(\"virtio\");\n\nMODULE_DEVICE_TABLE(virtio, id_table);\nMODULE_AUTHOR(\"Eric Van Hensbergen <ericvh@gmail.com>\");\nMODULE_DESCRIPTION(\"Virtio 9p Transport\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}