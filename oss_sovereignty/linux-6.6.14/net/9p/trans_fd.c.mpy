{
  "module_name": "trans_fd.c",
  "hash_id": "8e5bb228f21b16d0afaa8b9717ad37a74082f32e7ee0c62bbb592c7bf2b23c76",
  "original_prompt": "Ingested from linux-6.6.14/net/9p/trans_fd.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/in.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/ipv6.h>\n#include <linux/kthread.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/un.h>\n#include <linux/uaccess.h>\n#include <linux/inet.h>\n#include <linux/file.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n#include <net/9p/transport.h>\n\n#include <linux/syscalls.h>  \n\n#define P9_PORT 564\n#define MAX_SOCK_BUF (1024*1024)\n#define MAXPOLLWADDR\t2\n\nstatic struct p9_trans_module p9_tcp_trans;\nstatic struct p9_trans_module p9_fd_trans;\n\n \n\nstruct p9_fd_opts {\n\tint rfd;\n\tint wfd;\n\tu16 port;\n\tbool privport;\n};\n\n \n\nenum {\n\t \n\tOpt_port, Opt_rfdno, Opt_wfdno, Opt_err,\n\t \n\tOpt_privport,\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_port, \"port=%u\"},\n\t{Opt_rfdno, \"rfdno=%u\"},\n\t{Opt_wfdno, \"wfdno=%u\"},\n\t{Opt_privport, \"privport\"},\n\t{Opt_err, NULL},\n};\n\nenum {\n\tRworksched = 1,\t\t \n\tRpending = 2,\t\t \n\tWworksched = 4,\t\t \n\tWpending = 8,\t\t \n};\n\nstruct p9_poll_wait {\n\tstruct p9_conn *conn;\n\twait_queue_entry_t wait;\n\twait_queue_head_t *wait_addr;\n};\n\n \n\nstruct p9_conn {\n\tstruct list_head mux_list;\n\tstruct p9_client *client;\n\tint err;\n\tspinlock_t req_lock;\n\tstruct list_head req_list;\n\tstruct list_head unsent_req_list;\n\tstruct p9_req_t *rreq;\n\tstruct p9_req_t *wreq;\n\tchar tmp_buf[P9_HDRSZ];\n\tstruct p9_fcall rc;\n\tint wpos;\n\tint wsize;\n\tchar *wbuf;\n\tstruct list_head poll_pending_link;\n\tstruct p9_poll_wait poll_wait[MAXPOLLWADDR];\n\tpoll_table pt;\n\tstruct work_struct rq;\n\tstruct work_struct wq;\n\tunsigned long wsched;\n};\n\n \n\nstruct p9_trans_fd {\n\tstruct file *rd;\n\tstruct file *wr;\n\tstruct p9_conn conn;\n};\n\nstatic void p9_poll_workfn(struct work_struct *work);\n\nstatic DEFINE_SPINLOCK(p9_poll_lock);\nstatic LIST_HEAD(p9_poll_pending_list);\nstatic DECLARE_WORK(p9_poll_work, p9_poll_workfn);\n\nstatic unsigned int p9_ipport_resv_min = P9_DEF_MIN_RESVPORT;\nstatic unsigned int p9_ipport_resv_max = P9_DEF_MAX_RESVPORT;\n\nstatic void p9_mux_poll_stop(struct p9_conn *m)\n{\n\tunsigned long flags;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(m->poll_wait); i++) {\n\t\tstruct p9_poll_wait *pwait = &m->poll_wait[i];\n\n\t\tif (pwait->wait_addr) {\n\t\t\tremove_wait_queue(pwait->wait_addr, &pwait->wait);\n\t\t\tpwait->wait_addr = NULL;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&p9_poll_lock, flags);\n\tlist_del_init(&m->poll_pending_link);\n\tspin_unlock_irqrestore(&p9_poll_lock, flags);\n\n\tflush_work(&p9_poll_work);\n}\n\n \n\nstatic void p9_conn_cancel(struct p9_conn *m, int err)\n{\n\tstruct p9_req_t *req, *rtmp;\n\tLIST_HEAD(cancel_list);\n\n\tp9_debug(P9_DEBUG_ERROR, \"mux %p err %d\\n\", m, err);\n\n\tspin_lock(&m->req_lock);\n\n\tif (m->err) {\n\t\tspin_unlock(&m->req_lock);\n\t\treturn;\n\t}\n\n\tm->err = err;\n\n\tlist_for_each_entry_safe(req, rtmp, &m->req_list, req_list) {\n\t\tlist_move(&req->req_list, &cancel_list);\n\t\tWRITE_ONCE(req->status, REQ_STATUS_ERROR);\n\t}\n\tlist_for_each_entry_safe(req, rtmp, &m->unsent_req_list, req_list) {\n\t\tlist_move(&req->req_list, &cancel_list);\n\t\tWRITE_ONCE(req->status, REQ_STATUS_ERROR);\n\t}\n\n\tspin_unlock(&m->req_lock);\n\n\tlist_for_each_entry_safe(req, rtmp, &cancel_list, req_list) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"call back req %p\\n\", req);\n\t\tlist_del(&req->req_list);\n\t\tif (!req->t_err)\n\t\t\treq->t_err = err;\n\t\tp9_client_cb(m->client, req, REQ_STATUS_ERROR);\n\t}\n}\n\nstatic __poll_t\np9_fd_poll(struct p9_client *client, struct poll_table_struct *pt, int *err)\n{\n\t__poll_t ret;\n\tstruct p9_trans_fd *ts = NULL;\n\n\tif (client && client->status == Connected)\n\t\tts = client->trans;\n\n\tif (!ts) {\n\t\tif (err)\n\t\t\t*err = -EREMOTEIO;\n\t\treturn EPOLLERR;\n\t}\n\n\tret = vfs_poll(ts->rd, pt);\n\tif (ts->rd != ts->wr)\n\t\tret = (ret & ~EPOLLOUT) | (vfs_poll(ts->wr, pt) & ~EPOLLIN);\n\treturn ret;\n}\n\n \n\nstatic int p9_fd_read(struct p9_client *client, void *v, int len)\n{\n\tint ret;\n\tstruct p9_trans_fd *ts = NULL;\n\tloff_t pos;\n\n\tif (client && client->status != Disconnected)\n\t\tts = client->trans;\n\n\tif (!ts)\n\t\treturn -EREMOTEIO;\n\n\tif (!(ts->rd->f_flags & O_NONBLOCK))\n\t\tp9_debug(P9_DEBUG_ERROR, \"blocking read ...\\n\");\n\n\tpos = ts->rd->f_pos;\n\tret = kernel_read(ts->rd, v, len, &pos);\n\tif (ret <= 0 && ret != -ERESTARTSYS && ret != -EAGAIN)\n\t\tclient->status = Disconnected;\n\treturn ret;\n}\n\n \n\nstatic void p9_read_work(struct work_struct *work)\n{\n\t__poll_t n;\n\tint err;\n\tstruct p9_conn *m;\n\n\tm = container_of(work, struct p9_conn, rq);\n\n\tif (m->err < 0)\n\t\treturn;\n\n\tp9_debug(P9_DEBUG_TRANS, \"start mux %p pos %zd\\n\", m, m->rc.offset);\n\n\tif (!m->rc.sdata) {\n\t\tm->rc.sdata = m->tmp_buf;\n\t\tm->rc.offset = 0;\n\t\tm->rc.capacity = P9_HDRSZ;  \n\t}\n\n\tclear_bit(Rpending, &m->wsched);\n\tp9_debug(P9_DEBUG_TRANS, \"read mux %p pos %zd size: %zd = %zd\\n\",\n\t\t m, m->rc.offset, m->rc.capacity,\n\t\t m->rc.capacity - m->rc.offset);\n\terr = p9_fd_read(m->client, m->rc.sdata + m->rc.offset,\n\t\t\t m->rc.capacity - m->rc.offset);\n\tp9_debug(P9_DEBUG_TRANS, \"mux %p got %d bytes\\n\", m, err);\n\tif (err == -EAGAIN)\n\t\tgoto end_clear;\n\n\tif (err <= 0)\n\t\tgoto error;\n\n\tm->rc.offset += err;\n\n\t \n\tif ((!m->rreq) && (m->rc.offset == m->rc.capacity)) {\n\t\tp9_debug(P9_DEBUG_TRANS, \"got new header\\n\");\n\n\t\t \n\t\tm->rc.size = P9_HDRSZ;\n\t\terr = p9_parse_header(&m->rc, &m->rc.size, NULL, NULL, 0);\n\t\tif (err) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"error parsing header: %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\n\t\tp9_debug(P9_DEBUG_TRANS,\n\t\t\t \"mux %p pkt: size: %d bytes tag: %d\\n\",\n\t\t\t m, m->rc.size, m->rc.tag);\n\n\t\tm->rreq = p9_tag_lookup(m->client, m->rc.tag);\n\t\tif (!m->rreq || (m->rreq->status != REQ_STATUS_SENT)) {\n\t\t\tp9_debug(P9_DEBUG_ERROR, \"Unexpected packet tag %d\\n\",\n\t\t\t\t m->rc.tag);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (m->rc.size > m->rreq->rc.capacity) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"requested packet size too big: %d for tag %d with capacity %zd\\n\",\n\t\t\t\t m->rc.size, m->rc.tag, m->rreq->rc.capacity);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!m->rreq->rc.sdata) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"No recv fcall for tag %d (req %p), disconnecting!\\n\",\n\t\t\t\t m->rc.tag, m->rreq);\n\t\t\tp9_req_put(m->client, m->rreq);\n\t\t\tm->rreq = NULL;\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\t\tm->rc.sdata = m->rreq->rc.sdata;\n\t\tmemcpy(m->rc.sdata, m->tmp_buf, m->rc.capacity);\n\t\tm->rc.capacity = m->rc.size;\n\t}\n\n\t \n\tif ((m->rreq) && (m->rc.offset == m->rc.capacity)) {\n\t\tp9_debug(P9_DEBUG_TRANS, \"got new packet\\n\");\n\t\tm->rreq->rc.size = m->rc.offset;\n\t\tspin_lock(&m->req_lock);\n\t\tif (m->rreq->status == REQ_STATUS_SENT) {\n\t\t\tlist_del(&m->rreq->req_list);\n\t\t\tp9_client_cb(m->client, m->rreq, REQ_STATUS_RCVD);\n\t\t} else if (m->rreq->status == REQ_STATUS_FLSHD) {\n\t\t\t \n\t\t\tp9_debug(P9_DEBUG_TRANS,\n\t\t\t\t \"Ignore replies associated with a cancelled request\\n\");\n\t\t} else {\n\t\t\tspin_unlock(&m->req_lock);\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"Request tag %d errored out while we were reading the reply\\n\",\n\t\t\t\t m->rc.tag);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\t\tspin_unlock(&m->req_lock);\n\t\tm->rc.sdata = NULL;\n\t\tm->rc.offset = 0;\n\t\tm->rc.capacity = 0;\n\t\tp9_req_put(m->client, m->rreq);\n\t\tm->rreq = NULL;\n\t}\n\nend_clear:\n\tclear_bit(Rworksched, &m->wsched);\n\n\tif (!list_empty(&m->req_list)) {\n\t\tif (test_and_clear_bit(Rpending, &m->wsched))\n\t\t\tn = EPOLLIN;\n\t\telse\n\t\t\tn = p9_fd_poll(m->client, NULL, NULL);\n\n\t\tif ((n & EPOLLIN) && !test_and_set_bit(Rworksched, &m->wsched)) {\n\t\t\tp9_debug(P9_DEBUG_TRANS, \"sched read work %p\\n\", m);\n\t\t\tschedule_work(&m->rq);\n\t\t}\n\t}\n\n\treturn;\nerror:\n\tp9_conn_cancel(m, err);\n\tclear_bit(Rworksched, &m->wsched);\n}\n\n \n\nstatic int p9_fd_write(struct p9_client *client, void *v, int len)\n{\n\tssize_t ret;\n\tstruct p9_trans_fd *ts = NULL;\n\n\tif (client && client->status != Disconnected)\n\t\tts = client->trans;\n\n\tif (!ts)\n\t\treturn -EREMOTEIO;\n\n\tif (!(ts->wr->f_flags & O_NONBLOCK))\n\t\tp9_debug(P9_DEBUG_ERROR, \"blocking write ...\\n\");\n\n\tret = kernel_write(ts->wr, v, len, &ts->wr->f_pos);\n\tif (ret <= 0 && ret != -ERESTARTSYS && ret != -EAGAIN)\n\t\tclient->status = Disconnected;\n\treturn ret;\n}\n\n \n\nstatic void p9_write_work(struct work_struct *work)\n{\n\t__poll_t n;\n\tint err;\n\tstruct p9_conn *m;\n\tstruct p9_req_t *req;\n\n\tm = container_of(work, struct p9_conn, wq);\n\n\tif (m->err < 0) {\n\t\tclear_bit(Wworksched, &m->wsched);\n\t\treturn;\n\t}\n\n\tif (!m->wsize) {\n\t\tspin_lock(&m->req_lock);\n\t\tif (list_empty(&m->unsent_req_list)) {\n\t\t\tclear_bit(Wworksched, &m->wsched);\n\t\t\tspin_unlock(&m->req_lock);\n\t\t\treturn;\n\t\t}\n\n\t\treq = list_entry(m->unsent_req_list.next, struct p9_req_t,\n\t\t\t       req_list);\n\t\tWRITE_ONCE(req->status, REQ_STATUS_SENT);\n\t\tp9_debug(P9_DEBUG_TRANS, \"move req %p\\n\", req);\n\t\tlist_move_tail(&req->req_list, &m->req_list);\n\n\t\tm->wbuf = req->tc.sdata;\n\t\tm->wsize = req->tc.size;\n\t\tm->wpos = 0;\n\t\tp9_req_get(req);\n\t\tm->wreq = req;\n\t\tspin_unlock(&m->req_lock);\n\t}\n\n\tp9_debug(P9_DEBUG_TRANS, \"mux %p pos %d size %d\\n\",\n\t\t m, m->wpos, m->wsize);\n\tclear_bit(Wpending, &m->wsched);\n\terr = p9_fd_write(m->client, m->wbuf + m->wpos, m->wsize - m->wpos);\n\tp9_debug(P9_DEBUG_TRANS, \"mux %p sent %d bytes\\n\", m, err);\n\tif (err == -EAGAIN)\n\t\tgoto end_clear;\n\n\n\tif (err < 0)\n\t\tgoto error;\n\telse if (err == 0) {\n\t\terr = -EREMOTEIO;\n\t\tgoto error;\n\t}\n\n\tm->wpos += err;\n\tif (m->wpos == m->wsize) {\n\t\tm->wpos = m->wsize = 0;\n\t\tp9_req_put(m->client, m->wreq);\n\t\tm->wreq = NULL;\n\t}\n\nend_clear:\n\tclear_bit(Wworksched, &m->wsched);\n\n\tif (m->wsize || !list_empty(&m->unsent_req_list)) {\n\t\tif (test_and_clear_bit(Wpending, &m->wsched))\n\t\t\tn = EPOLLOUT;\n\t\telse\n\t\t\tn = p9_fd_poll(m->client, NULL, NULL);\n\n\t\tif ((n & EPOLLOUT) &&\n\t\t   !test_and_set_bit(Wworksched, &m->wsched)) {\n\t\t\tp9_debug(P9_DEBUG_TRANS, \"sched write work %p\\n\", m);\n\t\t\tschedule_work(&m->wq);\n\t\t}\n\t}\n\n\treturn;\n\nerror:\n\tp9_conn_cancel(m, err);\n\tclear_bit(Wworksched, &m->wsched);\n}\n\nstatic int p9_pollwake(wait_queue_entry_t *wait, unsigned int mode, int sync, void *key)\n{\n\tstruct p9_poll_wait *pwait =\n\t\tcontainer_of(wait, struct p9_poll_wait, wait);\n\tstruct p9_conn *m = pwait->conn;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&p9_poll_lock, flags);\n\tif (list_empty(&m->poll_pending_link))\n\t\tlist_add_tail(&m->poll_pending_link, &p9_poll_pending_list);\n\tspin_unlock_irqrestore(&p9_poll_lock, flags);\n\n\tschedule_work(&p9_poll_work);\n\treturn 1;\n}\n\n \n\nstatic void\np9_pollwait(struct file *filp, wait_queue_head_t *wait_address, poll_table *p)\n{\n\tstruct p9_conn *m = container_of(p, struct p9_conn, pt);\n\tstruct p9_poll_wait *pwait = NULL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(m->poll_wait); i++) {\n\t\tif (m->poll_wait[i].wait_addr == NULL) {\n\t\t\tpwait = &m->poll_wait[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pwait) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"not enough wait_address slots\\n\");\n\t\treturn;\n\t}\n\n\tpwait->conn = m;\n\tpwait->wait_addr = wait_address;\n\tinit_waitqueue_func_entry(&pwait->wait, p9_pollwake);\n\tadd_wait_queue(wait_address, &pwait->wait);\n}\n\n \n\nstatic void p9_conn_create(struct p9_client *client)\n{\n\t__poll_t n;\n\tstruct p9_trans_fd *ts = client->trans;\n\tstruct p9_conn *m = &ts->conn;\n\n\tp9_debug(P9_DEBUG_TRANS, \"client %p msize %d\\n\", client, client->msize);\n\n\tINIT_LIST_HEAD(&m->mux_list);\n\tm->client = client;\n\n\tspin_lock_init(&m->req_lock);\n\tINIT_LIST_HEAD(&m->req_list);\n\tINIT_LIST_HEAD(&m->unsent_req_list);\n\tINIT_WORK(&m->rq, p9_read_work);\n\tINIT_WORK(&m->wq, p9_write_work);\n\tINIT_LIST_HEAD(&m->poll_pending_link);\n\tinit_poll_funcptr(&m->pt, p9_pollwait);\n\n\tn = p9_fd_poll(client, &m->pt, NULL);\n\tif (n & EPOLLIN) {\n\t\tp9_debug(P9_DEBUG_TRANS, \"mux %p can read\\n\", m);\n\t\tset_bit(Rpending, &m->wsched);\n\t}\n\n\tif (n & EPOLLOUT) {\n\t\tp9_debug(P9_DEBUG_TRANS, \"mux %p can write\\n\", m);\n\t\tset_bit(Wpending, &m->wsched);\n\t}\n}\n\n \n\nstatic void p9_poll_mux(struct p9_conn *m)\n{\n\t__poll_t n;\n\tint err = -ECONNRESET;\n\n\tif (m->err < 0)\n\t\treturn;\n\n\tn = p9_fd_poll(m->client, NULL, &err);\n\tif (n & (EPOLLERR | EPOLLHUP | EPOLLNVAL)) {\n\t\tp9_debug(P9_DEBUG_TRANS, \"error mux %p err %d\\n\", m, n);\n\t\tp9_conn_cancel(m, err);\n\t}\n\n\tif (n & EPOLLIN) {\n\t\tset_bit(Rpending, &m->wsched);\n\t\tp9_debug(P9_DEBUG_TRANS, \"mux %p can read\\n\", m);\n\t\tif (!test_and_set_bit(Rworksched, &m->wsched)) {\n\t\t\tp9_debug(P9_DEBUG_TRANS, \"sched read work %p\\n\", m);\n\t\t\tschedule_work(&m->rq);\n\t\t}\n\t}\n\n\tif (n & EPOLLOUT) {\n\t\tset_bit(Wpending, &m->wsched);\n\t\tp9_debug(P9_DEBUG_TRANS, \"mux %p can write\\n\", m);\n\t\tif ((m->wsize || !list_empty(&m->unsent_req_list)) &&\n\t\t    !test_and_set_bit(Wworksched, &m->wsched)) {\n\t\t\tp9_debug(P9_DEBUG_TRANS, \"sched write work %p\\n\", m);\n\t\t\tschedule_work(&m->wq);\n\t\t}\n\t}\n}\n\n \n\nstatic int p9_fd_request(struct p9_client *client, struct p9_req_t *req)\n{\n\t__poll_t n;\n\tstruct p9_trans_fd *ts = client->trans;\n\tstruct p9_conn *m = &ts->conn;\n\n\tp9_debug(P9_DEBUG_TRANS, \"mux %p task %p tcall %p id %d\\n\",\n\t\t m, current, &req->tc, req->tc.id);\n\tif (m->err < 0)\n\t\treturn m->err;\n\n\tspin_lock(&m->req_lock);\n\tWRITE_ONCE(req->status, REQ_STATUS_UNSENT);\n\tlist_add_tail(&req->req_list, &m->unsent_req_list);\n\tspin_unlock(&m->req_lock);\n\n\tif (test_and_clear_bit(Wpending, &m->wsched))\n\t\tn = EPOLLOUT;\n\telse\n\t\tn = p9_fd_poll(m->client, NULL, NULL);\n\n\tif (n & EPOLLOUT && !test_and_set_bit(Wworksched, &m->wsched))\n\t\tschedule_work(&m->wq);\n\n\treturn 0;\n}\n\nstatic int p9_fd_cancel(struct p9_client *client, struct p9_req_t *req)\n{\n\tstruct p9_trans_fd *ts = client->trans;\n\tstruct p9_conn *m = &ts->conn;\n\tint ret = 1;\n\n\tp9_debug(P9_DEBUG_TRANS, \"client %p req %p\\n\", client, req);\n\n\tspin_lock(&m->req_lock);\n\n\tif (req->status == REQ_STATUS_UNSENT) {\n\t\tlist_del(&req->req_list);\n\t\tWRITE_ONCE(req->status, REQ_STATUS_FLSHD);\n\t\tp9_req_put(client, req);\n\t\tret = 0;\n\t}\n\tspin_unlock(&m->req_lock);\n\n\treturn ret;\n}\n\nstatic int p9_fd_cancelled(struct p9_client *client, struct p9_req_t *req)\n{\n\tstruct p9_trans_fd *ts = client->trans;\n\tstruct p9_conn *m = &ts->conn;\n\n\tp9_debug(P9_DEBUG_TRANS, \"client %p req %p\\n\", client, req);\n\n\tspin_lock(&m->req_lock);\n\t \n\tif (req->status == REQ_STATUS_RCVD) {\n\t\tspin_unlock(&m->req_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tlist_del(&req->req_list);\n\tWRITE_ONCE(req->status, REQ_STATUS_FLSHD);\n\tspin_unlock(&m->req_lock);\n\n\tp9_req_put(client, req);\n\n\treturn 0;\n}\n\nstatic int p9_fd_show_options(struct seq_file *m, struct p9_client *clnt)\n{\n\tif (clnt->trans_mod == &p9_tcp_trans) {\n\t\tif (clnt->trans_opts.tcp.port != P9_PORT)\n\t\t\tseq_printf(m, \",port=%u\", clnt->trans_opts.tcp.port);\n\t} else if (clnt->trans_mod == &p9_fd_trans) {\n\t\tif (clnt->trans_opts.fd.rfd != ~0)\n\t\t\tseq_printf(m, \",rfd=%u\", clnt->trans_opts.fd.rfd);\n\t\tif (clnt->trans_opts.fd.wfd != ~0)\n\t\t\tseq_printf(m, \",wfd=%u\", clnt->trans_opts.fd.wfd);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int parse_opts(char *params, struct p9_fd_opts *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tchar *options, *tmp_options;\n\n\topts->port = P9_PORT;\n\topts->rfd = ~0;\n\topts->wfd = ~0;\n\topts->privport = false;\n\n\tif (!params)\n\t\treturn 0;\n\n\ttmp_options = kstrdup(params, GFP_KERNEL);\n\tif (!tmp_options) {\n\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t \"failed to allocate copy of option string\\n\");\n\t\treturn -ENOMEM;\n\t}\n\toptions = tmp_options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tint r;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tif ((token != Opt_err) && (token != Opt_privport)) {\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswitch (token) {\n\t\tcase Opt_port:\n\t\t\topts->port = option;\n\t\t\tbreak;\n\t\tcase Opt_rfdno:\n\t\t\topts->rfd = option;\n\t\t\tbreak;\n\t\tcase Opt_wfdno:\n\t\t\topts->wfd = option;\n\t\t\tbreak;\n\t\tcase Opt_privport:\n\t\t\topts->privport = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tkfree(tmp_options);\n\treturn 0;\n}\n\nstatic int p9_fd_open(struct p9_client *client, int rfd, int wfd)\n{\n\tstruct p9_trans_fd *ts = kzalloc(sizeof(struct p9_trans_fd),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->rd = fget(rfd);\n\tif (!ts->rd)\n\t\tgoto out_free_ts;\n\tif (!(ts->rd->f_mode & FMODE_READ))\n\t\tgoto out_put_rd;\n\t \n\tdata_race(ts->rd->f_flags |= O_NONBLOCK);\n\tts->wr = fget(wfd);\n\tif (!ts->wr)\n\t\tgoto out_put_rd;\n\tif (!(ts->wr->f_mode & FMODE_WRITE))\n\t\tgoto out_put_wr;\n\tdata_race(ts->wr->f_flags |= O_NONBLOCK);\n\n\tclient->trans = ts;\n\tclient->status = Connected;\n\n\treturn 0;\n\nout_put_wr:\n\tfput(ts->wr);\nout_put_rd:\n\tfput(ts->rd);\nout_free_ts:\n\tkfree(ts);\n\treturn -EIO;\n}\n\nstatic int p9_socket_open(struct p9_client *client, struct socket *csocket)\n{\n\tstruct p9_trans_fd *p;\n\tstruct file *file;\n\n\tp = kzalloc(sizeof(struct p9_trans_fd), GFP_KERNEL);\n\tif (!p) {\n\t\tsock_release(csocket);\n\t\treturn -ENOMEM;\n\t}\n\n\tcsocket->sk->sk_allocation = GFP_NOIO;\n\tcsocket->sk->sk_use_task_frag = false;\n\tfile = sock_alloc_file(csocket, 0, NULL);\n\tif (IS_ERR(file)) {\n\t\tpr_err(\"%s (%d): failed to map fd\\n\",\n\t\t       __func__, task_pid_nr(current));\n\t\tkfree(p);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tget_file(file);\n\tp->wr = p->rd = file;\n\tclient->trans = p;\n\tclient->status = Connected;\n\n\tp->rd->f_flags |= O_NONBLOCK;\n\n\tp9_conn_create(client);\n\treturn 0;\n}\n\n \n\nstatic void p9_conn_destroy(struct p9_conn *m)\n{\n\tp9_debug(P9_DEBUG_TRANS, \"mux %p prev %p next %p\\n\",\n\t\t m, m->mux_list.prev, m->mux_list.next);\n\n\tp9_mux_poll_stop(m);\n\tcancel_work_sync(&m->rq);\n\tif (m->rreq) {\n\t\tp9_req_put(m->client, m->rreq);\n\t\tm->rreq = NULL;\n\t}\n\tcancel_work_sync(&m->wq);\n\tif (m->wreq) {\n\t\tp9_req_put(m->client, m->wreq);\n\t\tm->wreq = NULL;\n\t}\n\n\tp9_conn_cancel(m, -ECONNRESET);\n\n\tm->client = NULL;\n}\n\n \n\nstatic void p9_fd_close(struct p9_client *client)\n{\n\tstruct p9_trans_fd *ts;\n\n\tif (!client)\n\t\treturn;\n\n\tts = client->trans;\n\tif (!ts)\n\t\treturn;\n\n\tclient->status = Disconnected;\n\n\tp9_conn_destroy(&ts->conn);\n\n\tif (ts->rd)\n\t\tfput(ts->rd);\n\tif (ts->wr)\n\t\tfput(ts->wr);\n\n\tkfree(ts);\n}\n\n \nstatic inline int valid_ipaddr4(const char *buf)\n{\n\tint rc, count, in[4];\n\n\trc = sscanf(buf, \"%d.%d.%d.%d\", &in[0], &in[1], &in[2], &in[3]);\n\tif (rc != 4)\n\t\treturn -EINVAL;\n\tfor (count = 0; count < 4; count++) {\n\t\tif (in[count] > 255)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int p9_bind_privport(struct socket *sock)\n{\n\tstruct sockaddr_in cl;\n\tint port, err = -EINVAL;\n\n\tmemset(&cl, 0, sizeof(cl));\n\tcl.sin_family = AF_INET;\n\tcl.sin_addr.s_addr = htonl(INADDR_ANY);\n\tfor (port = p9_ipport_resv_max; port >= p9_ipport_resv_min; port--) {\n\t\tcl.sin_port = htons((ushort)port);\n\t\terr = kernel_bind(sock, (struct sockaddr *)&cl, sizeof(cl));\n\t\tif (err != -EADDRINUSE)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n\nstatic int\np9_fd_create_tcp(struct p9_client *client, const char *addr, char *args)\n{\n\tint err;\n\tstruct socket *csocket;\n\tstruct sockaddr_in sin_server;\n\tstruct p9_fd_opts opts;\n\n\terr = parse_opts(args, &opts);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (addr == NULL || valid_ipaddr4(addr) < 0)\n\t\treturn -EINVAL;\n\n\tcsocket = NULL;\n\n\tclient->trans_opts.tcp.port = opts.port;\n\tclient->trans_opts.tcp.privport = opts.privport;\n\tsin_server.sin_family = AF_INET;\n\tsin_server.sin_addr.s_addr = in_aton(addr);\n\tsin_server.sin_port = htons(opts.port);\n\terr = __sock_create(current->nsproxy->net_ns, PF_INET,\n\t\t\t    SOCK_STREAM, IPPROTO_TCP, &csocket, 1);\n\tif (err) {\n\t\tpr_err(\"%s (%d): problem creating socket\\n\",\n\t\t       __func__, task_pid_nr(current));\n\t\treturn err;\n\t}\n\n\tif (opts.privport) {\n\t\terr = p9_bind_privport(csocket);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"%s (%d): problem binding to privport\\n\",\n\t\t\t       __func__, task_pid_nr(current));\n\t\t\tsock_release(csocket);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = READ_ONCE(csocket->ops)->connect(csocket,\n\t\t\t\t    (struct sockaddr *)&sin_server,\n\t\t\t\t    sizeof(struct sockaddr_in), 0);\n\tif (err < 0) {\n\t\tpr_err(\"%s (%d): problem connecting socket to %s\\n\",\n\t\t       __func__, task_pid_nr(current), addr);\n\t\tsock_release(csocket);\n\t\treturn err;\n\t}\n\n\treturn p9_socket_open(client, csocket);\n}\n\nstatic int\np9_fd_create_unix(struct p9_client *client, const char *addr, char *args)\n{\n\tint err;\n\tstruct socket *csocket;\n\tstruct sockaddr_un sun_server;\n\n\tcsocket = NULL;\n\n\tif (!addr || !strlen(addr))\n\t\treturn -EINVAL;\n\n\tif (strlen(addr) >= UNIX_PATH_MAX) {\n\t\tpr_err(\"%s (%d): address too long: %s\\n\",\n\t\t       __func__, task_pid_nr(current), addr);\n\t\treturn -ENAMETOOLONG;\n\t}\n\n\tsun_server.sun_family = PF_UNIX;\n\tstrcpy(sun_server.sun_path, addr);\n\terr = __sock_create(current->nsproxy->net_ns, PF_UNIX,\n\t\t\t    SOCK_STREAM, 0, &csocket, 1);\n\tif (err < 0) {\n\t\tpr_err(\"%s (%d): problem creating socket\\n\",\n\t\t       __func__, task_pid_nr(current));\n\n\t\treturn err;\n\t}\n\terr = READ_ONCE(csocket->ops)->connect(csocket, (struct sockaddr *)&sun_server,\n\t\t\tsizeof(struct sockaddr_un) - 1, 0);\n\tif (err < 0) {\n\t\tpr_err(\"%s (%d): problem connecting socket: %s: %d\\n\",\n\t\t       __func__, task_pid_nr(current), addr, err);\n\t\tsock_release(csocket);\n\t\treturn err;\n\t}\n\n\treturn p9_socket_open(client, csocket);\n}\n\nstatic int\np9_fd_create(struct p9_client *client, const char *addr, char *args)\n{\n\tint err;\n\tstruct p9_fd_opts opts;\n\n\terr = parse_opts(args, &opts);\n\tif (err < 0)\n\t\treturn err;\n\tclient->trans_opts.fd.rfd = opts.rfd;\n\tclient->trans_opts.fd.wfd = opts.wfd;\n\n\tif (opts.rfd == ~0 || opts.wfd == ~0) {\n\t\tpr_err(\"Insufficient options for proto=fd\\n\");\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\terr = p9_fd_open(client, opts.rfd, opts.wfd);\n\tif (err < 0)\n\t\treturn err;\n\n\tp9_conn_create(client);\n\n\treturn 0;\n}\n\nstatic struct p9_trans_module p9_tcp_trans = {\n\t.name = \"tcp\",\n\t.maxsize = MAX_SOCK_BUF,\n\t.pooled_rbuffers = false,\n\t.def = 0,\n\t.create = p9_fd_create_tcp,\n\t.close = p9_fd_close,\n\t.request = p9_fd_request,\n\t.cancel = p9_fd_cancel,\n\t.cancelled = p9_fd_cancelled,\n\t.show_options = p9_fd_show_options,\n\t.owner = THIS_MODULE,\n};\nMODULE_ALIAS_9P(\"tcp\");\n\nstatic struct p9_trans_module p9_unix_trans = {\n\t.name = \"unix\",\n\t.maxsize = MAX_SOCK_BUF,\n\t.def = 0,\n\t.create = p9_fd_create_unix,\n\t.close = p9_fd_close,\n\t.request = p9_fd_request,\n\t.cancel = p9_fd_cancel,\n\t.cancelled = p9_fd_cancelled,\n\t.show_options = p9_fd_show_options,\n\t.owner = THIS_MODULE,\n};\nMODULE_ALIAS_9P(\"unix\");\n\nstatic struct p9_trans_module p9_fd_trans = {\n\t.name = \"fd\",\n\t.maxsize = MAX_SOCK_BUF,\n\t.def = 0,\n\t.create = p9_fd_create,\n\t.close = p9_fd_close,\n\t.request = p9_fd_request,\n\t.cancel = p9_fd_cancel,\n\t.cancelled = p9_fd_cancelled,\n\t.show_options = p9_fd_show_options,\n\t.owner = THIS_MODULE,\n};\nMODULE_ALIAS_9P(\"fd\");\n\n \n\nstatic void p9_poll_workfn(struct work_struct *work)\n{\n\tunsigned long flags;\n\n\tp9_debug(P9_DEBUG_TRANS, \"start %p\\n\", current);\n\n\tspin_lock_irqsave(&p9_poll_lock, flags);\n\twhile (!list_empty(&p9_poll_pending_list)) {\n\t\tstruct p9_conn *conn = list_first_entry(&p9_poll_pending_list,\n\t\t\t\t\t\t\tstruct p9_conn,\n\t\t\t\t\t\t\tpoll_pending_link);\n\t\tlist_del_init(&conn->poll_pending_link);\n\t\tspin_unlock_irqrestore(&p9_poll_lock, flags);\n\n\t\tp9_poll_mux(conn);\n\n\t\tspin_lock_irqsave(&p9_poll_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&p9_poll_lock, flags);\n\n\tp9_debug(P9_DEBUG_TRANS, \"finish\\n\");\n}\n\nstatic int __init p9_trans_fd_init(void)\n{\n\tv9fs_register_trans(&p9_tcp_trans);\n\tv9fs_register_trans(&p9_unix_trans);\n\tv9fs_register_trans(&p9_fd_trans);\n\n\treturn 0;\n}\n\nstatic void __exit p9_trans_fd_exit(void)\n{\n\tflush_work(&p9_poll_work);\n\tv9fs_unregister_trans(&p9_tcp_trans);\n\tv9fs_unregister_trans(&p9_unix_trans);\n\tv9fs_unregister_trans(&p9_fd_trans);\n}\n\nmodule_init(p9_trans_fd_init);\nmodule_exit(p9_trans_fd_exit);\n\nMODULE_AUTHOR(\"Eric Van Hensbergen <ericvh@gmail.com>\");\nMODULE_DESCRIPTION(\"Filedescriptor Transport for 9P\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}