{
  "module_name": "options.c",
  "hash_id": "2ad46f09f8c110e6e80e802be0f2080c7d03980ed888394f7f1b2c87520110b2",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/options.c",
  "human_readable_source": "\n \n#include <linux/dccp.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n\n#include \"ackvec.h\"\n#include \"ccid.h\"\n#include \"dccp.h\"\n#include \"feat.h\"\n\nu64 dccp_decode_value_var(const u8 *bf, const u8 len)\n{\n\tu64 value = 0;\n\n\tif (len >= DCCP_OPTVAL_MAXLEN)\n\t\tvalue += ((u64)*bf++) << 40;\n\tif (len > 4)\n\t\tvalue += ((u64)*bf++) << 32;\n\tif (len > 3)\n\t\tvalue += ((u64)*bf++) << 24;\n\tif (len > 2)\n\t\tvalue += ((u64)*bf++) << 16;\n\tif (len > 1)\n\t\tvalue += ((u64)*bf++) << 8;\n\tif (len > 0)\n\t\tvalue += *bf;\n\n\treturn value;\n}\n\n \nint dccp_parse_options(struct sock *sk, struct dccp_request_sock *dreq,\n\t\t       struct sk_buff *skb)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tconst struct dccp_hdr *dh = dccp_hdr(skb);\n\tconst u8 pkt_type = DCCP_SKB_CB(skb)->dccpd_type;\n\tunsigned char *options = (unsigned char *)dh + dccp_hdr_len(skb);\n\tunsigned char *opt_ptr = options;\n\tconst unsigned char *opt_end = (unsigned char *)dh +\n\t\t\t\t\t(dh->dccph_doff * 4);\n\tstruct dccp_options_received *opt_recv = &dp->dccps_options_received;\n\tunsigned char opt, len;\n\tunsigned char *value;\n\tu32 elapsed_time;\n\t__be32 opt_val;\n\tint rc;\n\tint mandatory = 0;\n\n\tmemset(opt_recv, 0, sizeof(*opt_recv));\n\n\topt = len = 0;\n\twhile (opt_ptr != opt_end) {\n\t\topt   = *opt_ptr++;\n\t\tlen   = 0;\n\t\tvalue = NULL;\n\n\t\t \n\t\tif (opt > DCCPO_MAX_RESERVED) {\n\t\t\tif (opt_ptr == opt_end)\n\t\t\t\tgoto out_nonsensical_length;\n\n\t\t\tlen = *opt_ptr++;\n\t\t\tif (len < 2)\n\t\t\t\tgoto out_nonsensical_length;\n\t\t\t \n\t\t\tlen\t-= 2;\n\t\t\tvalue\t= opt_ptr;\n\t\t\topt_ptr += len;\n\n\t\t\tif (opt_ptr > opt_end)\n\t\t\t\tgoto out_nonsensical_length;\n\t\t}\n\n\t\t \n\t\tif (dreq != NULL && (opt >= DCCPO_MIN_RX_CCID_SPECIFIC ||\n\t\t    opt == DCCPO_ACK_VECTOR_0 || opt == DCCPO_ACK_VECTOR_1))\n\t\t\tgoto ignore_option;\n\n\t\tswitch (opt) {\n\t\tcase DCCPO_PADDING:\n\t\t\tbreak;\n\t\tcase DCCPO_MANDATORY:\n\t\t\tif (mandatory)\n\t\t\t\tgoto out_invalid_option;\n\t\t\tif (pkt_type != DCCP_PKT_DATA)\n\t\t\t\tmandatory = 1;\n\t\t\tbreak;\n\t\tcase DCCPO_NDP_COUNT:\n\t\t\tif (len > 6)\n\t\t\t\tgoto out_invalid_option;\n\n\t\t\topt_recv->dccpor_ndp = dccp_decode_value_var(value, len);\n\t\t\tdccp_pr_debug(\"%s opt: NDP count=%llu\\n\", dccp_role(sk),\n\t\t\t\t      (unsigned long long)opt_recv->dccpor_ndp);\n\t\t\tbreak;\n\t\tcase DCCPO_CHANGE_L ... DCCPO_CONFIRM_R:\n\t\t\tif (pkt_type == DCCP_PKT_DATA)       \n\t\t\t\tbreak;\n\t\t\tif (len == 0)\n\t\t\t\tgoto out_invalid_option;\n\t\t\trc = dccp_feat_parse_options(sk, dreq, mandatory, opt,\n\t\t\t\t\t\t    *value, value + 1, len - 1);\n\t\t\tif (rc)\n\t\t\t\tgoto out_featneg_failed;\n\t\t\tbreak;\n\t\tcase DCCPO_TIMESTAMP:\n\t\t\tif (len != 4)\n\t\t\t\tgoto out_invalid_option;\n\t\t\t \n\t\t\topt_val = get_unaligned((__be32 *)value);\n\t\t\tif (unlikely(opt_val == 0)) {\n\t\t\t\tDCCP_WARN(\"Timestamp with zero value\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dreq != NULL) {\n\t\t\t\tdreq->dreq_timestamp_echo = ntohl(opt_val);\n\t\t\t\tdreq->dreq_timestamp_time = dccp_timestamp();\n\t\t\t} else {\n\t\t\t\topt_recv->dccpor_timestamp =\n\t\t\t\t\tdp->dccps_timestamp_echo = ntohl(opt_val);\n\t\t\t\tdp->dccps_timestamp_time = dccp_timestamp();\n\t\t\t}\n\t\t\tdccp_pr_debug(\"%s rx opt: TIMESTAMP=%u, ackno=%llu\\n\",\n\t\t\t\t      dccp_role(sk), ntohl(opt_val),\n\t\t\t\t      (unsigned long long)\n\t\t\t\t      DCCP_SKB_CB(skb)->dccpd_ack_seq);\n\t\t\t \n\t\t\tinet_csk_schedule_ack(sk);\n\t\t\tbreak;\n\t\tcase DCCPO_TIMESTAMP_ECHO:\n\t\t\tif (len != 4 && len != 6 && len != 8)\n\t\t\t\tgoto out_invalid_option;\n\n\t\t\topt_val = get_unaligned((__be32 *)value);\n\t\t\topt_recv->dccpor_timestamp_echo = ntohl(opt_val);\n\n\t\t\tdccp_pr_debug(\"%s rx opt: TIMESTAMP_ECHO=%u, len=%d, \"\n\t\t\t\t      \"ackno=%llu\", dccp_role(sk),\n\t\t\t\t      opt_recv->dccpor_timestamp_echo,\n\t\t\t\t      len + 2,\n\t\t\t\t      (unsigned long long)\n\t\t\t\t      DCCP_SKB_CB(skb)->dccpd_ack_seq);\n\n\t\t\tvalue += 4;\n\n\t\t\tif (len == 4) {\t\t \n\t\t\t\tdccp_pr_debug_cat(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (len == 6) {\t\t \n\t\t\t\t__be16 opt_val2 = get_unaligned((__be16 *)value);\n\t\t\t\telapsed_time = ntohs(opt_val2);\n\t\t\t} else {\t\t \n\t\t\t\topt_val = get_unaligned((__be32 *)value);\n\t\t\t\telapsed_time = ntohl(opt_val);\n\t\t\t}\n\n\t\t\tdccp_pr_debug_cat(\", ELAPSED_TIME=%u\\n\", elapsed_time);\n\n\t\t\t \n\t\t\tif (elapsed_time > opt_recv->dccpor_elapsed_time)\n\t\t\t\topt_recv->dccpor_elapsed_time = elapsed_time;\n\t\t\tbreak;\n\t\tcase DCCPO_ELAPSED_TIME:\n\t\t\tif (dccp_packet_without_ack(skb))    \n\t\t\t\tbreak;\n\n\t\t\tif (len == 2) {\n\t\t\t\t__be16 opt_val2 = get_unaligned((__be16 *)value);\n\t\t\t\telapsed_time = ntohs(opt_val2);\n\t\t\t} else if (len == 4) {\n\t\t\t\topt_val = get_unaligned((__be32 *)value);\n\t\t\t\telapsed_time = ntohl(opt_val);\n\t\t\t} else {\n\t\t\t\tgoto out_invalid_option;\n\t\t\t}\n\n\t\t\tif (elapsed_time > opt_recv->dccpor_elapsed_time)\n\t\t\t\topt_recv->dccpor_elapsed_time = elapsed_time;\n\n\t\t\tdccp_pr_debug(\"%s rx opt: ELAPSED_TIME=%d\\n\",\n\t\t\t\t      dccp_role(sk), elapsed_time);\n\t\t\tbreak;\n\t\tcase DCCPO_MIN_RX_CCID_SPECIFIC ... DCCPO_MAX_RX_CCID_SPECIFIC:\n\t\t\tif (ccid_hc_rx_parse_options(dp->dccps_hc_rx_ccid, sk,\n\t\t\t\t\t\t     pkt_type, opt, value, len))\n\t\t\t\tgoto out_invalid_option;\n\t\t\tbreak;\n\t\tcase DCCPO_ACK_VECTOR_0:\n\t\tcase DCCPO_ACK_VECTOR_1:\n\t\t\tif (dccp_packet_without_ack(skb))    \n\t\t\t\tbreak;\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase DCCPO_MIN_TX_CCID_SPECIFIC ... DCCPO_MAX_TX_CCID_SPECIFIC:\n\t\t\tif (ccid_hc_tx_parse_options(dp->dccps_hc_tx_ccid, sk,\n\t\t\t\t\t\t     pkt_type, opt, value, len))\n\t\t\t\tgoto out_invalid_option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDCCP_CRIT(\"DCCP(%p): option %d(len=%d) not \"\n\t\t\t\t  \"implemented, ignoring\", sk, opt, len);\n\t\t\tbreak;\n\t\t}\nignore_option:\n\t\tif (opt != DCCPO_MANDATORY)\n\t\t\tmandatory = 0;\n\t}\n\n\t \n\tif (mandatory)\n\t\tgoto out_invalid_option;\n\nout_nonsensical_length:\n\t \n\treturn 0;\n\nout_invalid_option:\n\tDCCP_INC_STATS(DCCP_MIB_INVALIDOPT);\n\trc = DCCP_RESET_CODE_OPTION_ERROR;\nout_featneg_failed:\n\tDCCP_WARN(\"DCCP(%p): Option %d (len=%d) error=%u\\n\", sk, opt, len, rc);\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = rc;\n\tDCCP_SKB_CB(skb)->dccpd_reset_data[0] = opt;\n\tDCCP_SKB_CB(skb)->dccpd_reset_data[1] = len > 0 ? value[0] : 0;\n\tDCCP_SKB_CB(skb)->dccpd_reset_data[2] = len > 1 ? value[1] : 0;\n\treturn -1;\n}\n\nEXPORT_SYMBOL_GPL(dccp_parse_options);\n\nvoid dccp_encode_value_var(const u64 value, u8 *to, const u8 len)\n{\n\tif (len >= DCCP_OPTVAL_MAXLEN)\n\t\t*to++ = (value & 0xFF0000000000ull) >> 40;\n\tif (len > 4)\n\t\t*to++ = (value & 0xFF00000000ull) >> 32;\n\tif (len > 3)\n\t\t*to++ = (value & 0xFF000000) >> 24;\n\tif (len > 2)\n\t\t*to++ = (value & 0xFF0000) >> 16;\n\tif (len > 1)\n\t\t*to++ = (value & 0xFF00) >> 8;\n\tif (len > 0)\n\t\t*to++ = (value & 0xFF);\n}\n\nstatic inline u8 dccp_ndp_len(const u64 ndp)\n{\n\tif (likely(ndp <= 0xFF))\n\t\treturn 1;\n\treturn likely(ndp <= USHRT_MAX) ? 2 : (ndp <= UINT_MAX ? 4 : 6);\n}\n\nint dccp_insert_option(struct sk_buff *skb, const unsigned char option,\n\t\t       const void *value, const unsigned char len)\n{\n\tunsigned char *to;\n\n\tif (DCCP_SKB_CB(skb)->dccpd_opt_len + len + 2 > DCCP_MAX_OPT_LEN)\n\t\treturn -1;\n\n\tDCCP_SKB_CB(skb)->dccpd_opt_len += len + 2;\n\n\tto    = skb_push(skb, len + 2);\n\t*to++ = option;\n\t*to++ = len + 2;\n\n\tmemcpy(to, value, len);\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(dccp_insert_option);\n\nstatic int dccp_insert_option_ndp(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tu64 ndp = dp->dccps_ndp_count;\n\n\tif (dccp_non_data_packet(skb))\n\t\t++dp->dccps_ndp_count;\n\telse\n\t\tdp->dccps_ndp_count = 0;\n\n\tif (ndp > 0) {\n\t\tunsigned char *ptr;\n\t\tconst int ndp_len = dccp_ndp_len(ndp);\n\t\tconst int len = ndp_len + 2;\n\n\t\tif (DCCP_SKB_CB(skb)->dccpd_opt_len + len > DCCP_MAX_OPT_LEN)\n\t\t\treturn -1;\n\n\t\tDCCP_SKB_CB(skb)->dccpd_opt_len += len;\n\n\t\tptr = skb_push(skb, len);\n\t\t*ptr++ = DCCPO_NDP_COUNT;\n\t\t*ptr++ = len;\n\t\tdccp_encode_value_var(ndp, ptr, ndp_len);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int dccp_elapsed_time_len(const u32 elapsed_time)\n{\n\treturn elapsed_time == 0 ? 0 : elapsed_time <= 0xFFFF ? 2 : 4;\n}\n\nstatic int dccp_insert_option_timestamp(struct sk_buff *skb)\n{\n\t__be32 now = htonl(dccp_timestamp());\n\t \n\n\treturn dccp_insert_option(skb, DCCPO_TIMESTAMP, &now, sizeof(now));\n}\n\nstatic int dccp_insert_option_timestamp_echo(struct dccp_sock *dp,\n\t\t\t\t\t     struct dccp_request_sock *dreq,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\t__be32 tstamp_echo;\n\tunsigned char *to;\n\tu32 elapsed_time, elapsed_time_len, len;\n\n\tif (dreq != NULL) {\n\t\telapsed_time = dccp_timestamp() - dreq->dreq_timestamp_time;\n\t\ttstamp_echo  = htonl(dreq->dreq_timestamp_echo);\n\t\tdreq->dreq_timestamp_echo = 0;\n\t} else {\n\t\telapsed_time = dccp_timestamp() - dp->dccps_timestamp_time;\n\t\ttstamp_echo  = htonl(dp->dccps_timestamp_echo);\n\t\tdp->dccps_timestamp_echo = 0;\n\t}\n\n\telapsed_time_len = dccp_elapsed_time_len(elapsed_time);\n\tlen = 6 + elapsed_time_len;\n\n\tif (DCCP_SKB_CB(skb)->dccpd_opt_len + len > DCCP_MAX_OPT_LEN)\n\t\treturn -1;\n\n\tDCCP_SKB_CB(skb)->dccpd_opt_len += len;\n\n\tto    = skb_push(skb, len);\n\t*to++ = DCCPO_TIMESTAMP_ECHO;\n\t*to++ = len;\n\n\tmemcpy(to, &tstamp_echo, 4);\n\tto += 4;\n\n\tif (elapsed_time_len == 2) {\n\t\tconst __be16 var16 = htons((u16)elapsed_time);\n\t\tmemcpy(to, &var16, 2);\n\t} else if (elapsed_time_len == 4) {\n\t\tconst __be32 var32 = htonl(elapsed_time);\n\t\tmemcpy(to, &var32, 4);\n\t}\n\n\treturn 0;\n}\n\nstatic int dccp_insert_option_ackvec(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_ackvec *av = dp->dccps_hc_rx_ackvec;\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\tconst u16 buflen = dccp_ackvec_buflen(av);\n\t \n\tconst u8 nr_opts = DIV_ROUND_UP(buflen, DCCP_SINGLE_OPT_MAXLEN);\n\tu16 len = buflen + 2 * nr_opts;\n\tu8 i, nonce = 0;\n\tconst unsigned char *tail, *from;\n\tunsigned char *to;\n\n\tif (dcb->dccpd_opt_len + len > DCCP_MAX_OPT_LEN) {\n\t\tDCCP_WARN(\"Lacking space for %u bytes on %s packet\\n\", len,\n\t\t\t  dccp_packet_name(dcb->dccpd_type));\n\t\treturn -1;\n\t}\n\t \n\tif (len > DCCPAV_MIN_OPTLEN &&\n\t    len + dcb->dccpd_opt_len + skb->len > dp->dccps_mss_cache) {\n\t\tDCCP_WARN(\"No space left for Ack Vector (%u) on skb (%u+%u), \"\n\t\t\t  \"MPS=%u ==> reduce payload size?\\n\", len, skb->len,\n\t\t\t  dcb->dccpd_opt_len, dp->dccps_mss_cache);\n\t\tdp->dccps_sync_scheduled = 1;\n\t\treturn 0;\n\t}\n\tdcb->dccpd_opt_len += len;\n\n\tto   = skb_push(skb, len);\n\tlen  = buflen;\n\tfrom = av->av_buf + av->av_buf_head;\n\ttail = av->av_buf + DCCPAV_MAX_ACKVEC_LEN;\n\n\tfor (i = 0; i < nr_opts; ++i) {\n\t\tint copylen = len;\n\n\t\tif (len > DCCP_SINGLE_OPT_MAXLEN)\n\t\t\tcopylen = DCCP_SINGLE_OPT_MAXLEN;\n\n\t\t \n\t\tnonce ^= av->av_buf_nonce[i];\n\n\t\t*to++ = DCCPO_ACK_VECTOR_0 + av->av_buf_nonce[i];\n\t\t*to++ = copylen + 2;\n\n\t\t \n\t\tif (from + copylen > tail) {\n\t\t\tconst u16 tailsize = tail - from;\n\n\t\t\tmemcpy(to, from, tailsize);\n\t\t\tto\t+= tailsize;\n\t\t\tlen\t-= tailsize;\n\t\t\tcopylen\t-= tailsize;\n\t\t\tfrom\t= av->av_buf;\n\t\t}\n\n\t\tmemcpy(to, from, copylen);\n\t\tfrom += copylen;\n\t\tto   += copylen;\n\t\tlen  -= copylen;\n\t}\n\t \n\tif (dccp_ackvec_update_records(av, dcb->dccpd_seq, nonce))\n\t\treturn -ENOBUFS;\n\treturn 0;\n}\n\n \nint dccp_insert_option_mandatory(struct sk_buff *skb)\n{\n\tif (DCCP_SKB_CB(skb)->dccpd_opt_len >= DCCP_MAX_OPT_LEN)\n\t\treturn -1;\n\n\tDCCP_SKB_CB(skb)->dccpd_opt_len++;\n\t*(u8 *)skb_push(skb, 1) = DCCPO_MANDATORY;\n\treturn 0;\n}\n\n \nint dccp_insert_fn_opt(struct sk_buff *skb, u8 type, u8 feat,\n\t\t       u8 *val, u8 len, bool repeat_first)\n{\n\tu8 tot_len, *to;\n\n\t \n\tif (len > (DCCP_SINGLE_OPT_MAXLEN - 2)) {\n\t\tDCCP_WARN(\"length %u for feature %u too large\\n\", len, feat);\n\t\treturn -1;\n\t}\n\n\tif (unlikely(val == NULL || len == 0))\n\t\tlen = repeat_first = false;\n\ttot_len = 3 + repeat_first + len;\n\n\tif (DCCP_SKB_CB(skb)->dccpd_opt_len + tot_len > DCCP_MAX_OPT_LEN) {\n\t\tDCCP_WARN(\"packet too small for feature %d option!\\n\", feat);\n\t\treturn -1;\n\t}\n\tDCCP_SKB_CB(skb)->dccpd_opt_len += tot_len;\n\n\tto    = skb_push(skb, tot_len);\n\t*to++ = type;\n\t*to++ = tot_len;\n\t*to++ = feat;\n\n\tif (repeat_first)\n\t\t*to++ = *val;\n\tif (len)\n\t\tmemcpy(to, val, len);\n\treturn 0;\n}\n\n \nstatic void dccp_insert_option_padding(struct sk_buff *skb)\n{\n\tint padding = DCCP_SKB_CB(skb)->dccpd_opt_len % 4;\n\n\tif (padding != 0) {\n\t\tpadding = 4 - padding;\n\t\tmemset(skb_push(skb, padding), 0, padding);\n\t\tDCCP_SKB_CB(skb)->dccpd_opt_len += padding;\n\t}\n}\n\nint dccp_insert_options(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\tDCCP_SKB_CB(skb)->dccpd_opt_len = 0;\n\n\tif (dp->dccps_send_ndp_count && dccp_insert_option_ndp(sk, skb))\n\t\treturn -1;\n\n\tif (DCCP_SKB_CB(skb)->dccpd_type != DCCP_PKT_DATA) {\n\n\t\t \n\t\tif (dccp_feat_insert_opts(dp, NULL, skb))\n\t\t\treturn -1;\n\n\t\tif (DCCP_SKB_CB(skb)->dccpd_type == DCCP_PKT_REQUEST) {\n\t\t\t \n\t\t\tif (dccp_insert_option_timestamp(skb))\n\t\t\t\treturn -1;\n\n\t\t} else if (dccp_ackvec_pending(sk) &&\n\t\t\t   dccp_insert_option_ackvec(sk, skb)) {\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (dp->dccps_hc_rx_insert_options) {\n\t\tif (ccid_hc_rx_insert_options(dp->dccps_hc_rx_ccid, sk, skb))\n\t\t\treturn -1;\n\t\tdp->dccps_hc_rx_insert_options = 0;\n\t}\n\n\tif (dp->dccps_timestamp_echo != 0 &&\n\t    dccp_insert_option_timestamp_echo(dp, NULL, skb))\n\t\treturn -1;\n\n\tdccp_insert_option_padding(skb);\n\treturn 0;\n}\n\nint dccp_insert_options_rsk(struct dccp_request_sock *dreq, struct sk_buff *skb)\n{\n\tDCCP_SKB_CB(skb)->dccpd_opt_len = 0;\n\n\tif (dccp_feat_insert_opts(NULL, dreq, skb))\n\t\treturn -1;\n\n\t \n\tif (dccp_insert_option_timestamp(skb))\n\t\treturn -1;\n\n\tif (dreq->dreq_timestamp_echo != 0 &&\n\t    dccp_insert_option_timestamp_echo(NULL, dreq, skb))\n\t\treturn -1;\n\n\tdccp_insert_option_padding(skb);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}