{
  "module_name": "ipv4.c",
  "hash_id": "015372762de95fb3ed321aec7f8673e842ccd78a45c4783df8ca9e0cec15fa4b",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/ipv4.c",
  "human_readable_source": "\n \n\n#include <linux/dccp.h>\n#include <linux/icmp.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n\n#include <net/icmp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/inet_sock.h>\n#include <net/protocol.h>\n#include <net/sock.h>\n#include <net/timewait_sock.h>\n#include <net/tcp_states.h>\n#include <net/xfrm.h>\n#include <net/secure_seq.h>\n#include <net/netns/generic.h>\n\n#include \"ackvec.h\"\n#include \"ccid.h\"\n#include \"dccp.h\"\n#include \"feat.h\"\n\nstruct dccp_v4_pernet {\n\tstruct sock *v4_ctl_sk;\n};\n\nstatic unsigned int dccp_v4_pernet_id __read_mostly;\n\n \n\nint dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 *fl4;\n\tstruct rtable *rt;\n\tint err;\n\tstruct ip_options_rcu *inet_opt;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     lockdep_sock_is_held(sk));\n\tif (inet_opt != NULL && inet_opt->opt.srr) {\n\t\tif (daddr == 0)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet_opt->opt.faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\tfl4 = &inet->cork.fl.u.ip4;\n\trt = ip_route_connect(fl4, nexthop, inet->inet_saddr,\n\t\t\t      sk->sk_bound_dev_if, IPPROTO_DCCP, orig_sport,\n\t\t\t      orig_dport, sk);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (inet_opt == NULL || !inet_opt->opt.srr)\n\t\tdaddr = fl4->daddr;\n\n\tif (inet->inet_saddr == 0) {\n\t\terr = inet_bhash2_update_saddr(sk,  &fl4->saddr, AF_INET);\n\t\tif (err) {\n\t\t\tip_rt_put(rt);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tsk_rcv_saddr_set(sk, inet->inet_saddr);\n\t}\n\n\tinet->inet_dport = usin->sin_port;\n\tsk_daddr_set(sk, daddr);\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n\t \n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet_hash_connect(&dccp_death_row, sk);\n\tif (err != 0)\n\t\tgoto failure;\n\n\trt = ip_route_newports(fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet->inet_sport, inet->inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t \n\tsk_setup_caps(sk, &rt->dst);\n\n\tdp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr,\n\t\t\t\t\t\t    inet->inet_daddr,\n\t\t\t\t\t\t    inet->inet_sport,\n\t\t\t\t\t\t    inet->inet_dport);\n\tatomic_set(&inet->inet_id, get_random_u16());\n\n\terr = dccp_connect(sk);\n\trt = NULL;\n\tif (err != 0)\n\t\tgoto failure;\nout:\n\treturn err;\nfailure:\n\t \n\tdccp_set_state(sk, DCCP_CLOSED);\n\tinet_bhash2_reset_saddr(sk);\n\tip_rt_put(rt);\n\tsk->sk_route_caps = 0;\n\tinet->inet_dport = 0;\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(dccp_v4_connect);\n\n \nstatic inline void dccp_do_pmtu_discovery(struct sock *sk,\n\t\t\t\t\t  const struct iphdr *iph,\n\t\t\t\t\t  u32 mtu)\n{\n\tstruct dst_entry *dst;\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\n\t \n\tif (sk->sk_state == DCCP_LISTEN)\n\t\treturn;\n\n\tdst = inet_csk_update_pmtu(sk, mtu);\n\tif (!dst)\n\t\treturn;\n\n\t \n\tif (mtu < dst_mtu(dst) && ip_dont_fragment(sk, dst))\n\t\tWRITE_ONCE(sk->sk_err_soft, EMSGSIZE);\n\n\tmtu = dst_mtu(dst);\n\n\tif (inet->pmtudisc != IP_PMTUDISC_DONT &&\n\t    ip_sk_accept_pmtu(sk) &&\n\t    inet_csk(sk)->icsk_pmtu_cookie > mtu) {\n\t\tdccp_sync_mss(sk, mtu);\n\n\t\t \n\t\tdccp_send_sync(sk, dp->dccps_gsr, DCCP_PKT_SYNC);\n\t}  \n}\n\nstatic void dccp_do_redirect(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct dst_entry *dst = __sk_dst_check(sk, 0);\n\n\tif (dst)\n\t\tdst->ops->redirect(dst, sk, skb);\n}\n\nvoid dccp_req_err(struct sock *sk, u64 seq)\n\t{\n\tstruct request_sock *req = inet_reqsk(sk);\n\tstruct net *net = sock_net(sk);\n\n\t \n\tif (!between48(seq, dccp_rsk(req)->dreq_iss, dccp_rsk(req)->dreq_gss)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t} else {\n\t\t \n\t\tinet_csk_reqsk_queue_drop(req->rsk_listener, req);\n\t}\n\treqsk_put(req);\n}\nEXPORT_SYMBOL(dccp_req_err);\n\n \nstatic int dccp_v4_err(struct sk_buff *skb, u32 info)\n{\n\tconst struct iphdr *iph = (struct iphdr *)skb->data;\n\tconst u8 offset = iph->ihl << 2;\n\tconst struct dccp_hdr *dh;\n\tstruct dccp_sock *dp;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct sock *sk;\n\t__u64 seq;\n\tint err;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (!pskb_may_pull(skb, offset + sizeof(*dh)))\n\t\treturn -EINVAL;\n\tdh = (struct dccp_hdr *)(skb->data + offset);\n\tif (!pskb_may_pull(skb, offset + __dccp_basic_hdr_len(dh)))\n\t\treturn -EINVAL;\n\tiph = (struct iphdr *)skb->data;\n\tdh = (struct dccp_hdr *)(skb->data + offset);\n\n\tsk = __inet_lookup_established(net, &dccp_hashinfo,\n\t\t\t\t       iph->daddr, dh->dccph_dport,\n\t\t\t\t       iph->saddr, ntohs(dh->dccph_sport),\n\t\t\t\t       inet_iif(skb), 0);\n\tif (!sk) {\n\t\t__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);\n\t\treturn -ENOENT;\n\t}\n\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn 0;\n\t}\n\tseq = dccp_hdr_seq(dh);\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tdccp_req_err(sk, seq);\n\t\treturn 0;\n\t}\n\n\tbh_lock_sock(sk);\n\t \n\tif (sock_owned_by_user(sk))\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == DCCP_CLOSED)\n\t\tgoto out;\n\n\tdp = dccp_sk(sk);\n\tif ((1 << sk->sk_state) & ~(DCCPF_REQUESTING | DCCPF_LISTEN) &&\n\t    !between48(seq, dp->dccps_awl, dp->dccps_awh)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase ICMP_REDIRECT:\n\t\tif (!sock_owned_by_user(sk))\n\t\t\tdccp_do_redirect(skb, sk);\n\t\tgoto out;\n\tcase ICMP_SOURCE_QUENCH:\n\t\t \n\t\tgoto out;\n\tcase ICMP_PARAMETERPROB:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase ICMP_DEST_UNREACH:\n\t\tif (code > NR_ICMP_UNREACH)\n\t\t\tgoto out;\n\n\t\tif (code == ICMP_FRAG_NEEDED) {  \n\t\t\tif (!sock_owned_by_user(sk))\n\t\t\t\tdccp_do_pmtu_discovery(sk, iph, info);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = icmp_err_convert[code].errno;\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\tcase DCCP_RESPOND:\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\t__DCCP_INC_STATS(DCCP_MIB_ATTEMPTFAILS);\n\t\t\tsk->sk_err = err;\n\n\t\t\tsk_error_report(sk);\n\n\t\t\tdccp_done(sk);\n\t\t} else {\n\t\t\tWRITE_ONCE(sk->sk_err_soft, err);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (!sock_owned_by_user(sk) && inet_test_bit(RECVERR, sk)) {\n\t\tsk->sk_err = err;\n\t\tsk_error_report(sk);\n\t} else {  \n\t\tWRITE_ONCE(sk->sk_err_soft, err);\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}\n\nstatic inline __sum16 dccp_v4_csum_finish(struct sk_buff *skb,\n\t\t\t\t      __be32 src, __be32 dst)\n{\n\treturn csum_tcpudp_magic(src, dst, skb->len, IPPROTO_DCCP, skb->csum);\n}\n\nvoid dccp_v4_send_check(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\tdccp_csum_outgoing(skb);\n\tdh->dccph_checksum = dccp_v4_csum_finish(skb,\n\t\t\t\t\t\t inet->inet_saddr,\n\t\t\t\t\t\t inet->inet_daddr);\n}\nEXPORT_SYMBOL_GPL(dccp_v4_send_check);\n\nstatic inline u64 dccp_v4_init_sequence(const struct sk_buff *skb)\n{\n\treturn secure_dccp_sequence_number(ip_hdr(skb)->daddr,\n\t\t\t\t\t   ip_hdr(skb)->saddr,\n\t\t\t\t\t   dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t   dccp_hdr(skb)->dccph_sport);\n}\n\n \nstruct sock *dccp_v4_request_recv_sock(const struct sock *sk,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst,\n\t\t\t\t       struct request_sock *req_unhash,\n\t\t\t\t       bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tsk_daddr_set(newsk, ireq->ir_rmt_addr);\n\tsk_rcv_saddr_set(newsk, ireq->ir_loc_addr);\n\tnewinet->inet_saddr\t= ireq->ir_loc_addr;\n\tRCU_INIT_POINTER(newinet->inet_opt, rcu_dereference(ireq->ireq_opt));\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tatomic_set(&newinet->inet_id, get_random_u16());\n\n\tif (dst == NULL && (dst = inet_csk_route_child_sock(sk, newsk, req)) == NULL)\n\t\tgoto put_and_exit;\n\n\tsk_setup_caps(newsk, dst);\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) < 0)\n\t\tgoto put_and_exit;\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash), NULL);\n\tif (*own_req)\n\t\tireq->ireq_opt = NULL;\n\telse\n\t\tnewinet->inet_opt = NULL;\n\treturn newsk;\n\nexit_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\nput_and_exit:\n\tnewinet->inet_opt = NULL;\n\tinet_csk_prepare_forced_close(newsk);\n\tdccp_done(newsk);\n\tgoto exit;\n}\nEXPORT_SYMBOL_GPL(dccp_v4_request_recv_sock);\n\nstatic struct dst_entry* dccp_v4_route_skb(struct net *net, struct sock *sk,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct rtable *rt;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct flowi4 fl4 = {\n\t\t.flowi4_oif = inet_iif(skb),\n\t\t.daddr = iph->saddr,\n\t\t.saddr = iph->daddr,\n\t\t.flowi4_tos = ip_sock_rt_tos(sk),\n\t\t.flowi4_scope = ip_sock_rt_scope(sk),\n\t\t.flowi4_proto = sk->sk_protocol,\n\t\t.fl4_sport = dccp_hdr(skb)->dccph_dport,\n\t\t.fl4_dport = dccp_hdr(skb)->dccph_sport,\n\t};\n\n\tsecurity_skb_classify_flow(skb, flowi4_to_flowi_common(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\tIP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);\n\t\treturn NULL;\n\t}\n\n\treturn &rt->dst;\n}\n\nstatic int dccp_v4_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tint err = -1;\n\tstruct sk_buff *skb;\n\tstruct dst_entry *dst;\n\tstruct flowi4 fl4;\n\n\tdst = inet_csk_route_req(sk, &fl4, req);\n\tif (dst == NULL)\n\t\tgoto out;\n\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\t\tdh->dccph_checksum = dccp_v4_csum_finish(skb, ireq->ir_loc_addr,\n\t\t\t\t\t\t\t      ireq->ir_rmt_addr);\n\t\trcu_read_lock();\n\t\terr = ip_build_and_send_pkt(skb, sk, ireq->ir_loc_addr,\n\t\t\t\t\t    ireq->ir_rmt_addr,\n\t\t\t\t\t    rcu_dereference(ireq->ireq_opt),\n\t\t\t\t\t    inet_sk(sk)->tos);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\nout:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic void dccp_v4_ctl_send_reset(const struct sock *sk, struct sk_buff *rxskb)\n{\n\tint err;\n\tconst struct iphdr *rxiph;\n\tstruct sk_buff *skb;\n\tstruct dst_entry *dst;\n\tstruct net *net = dev_net(skb_dst(rxskb)->dev);\n\tstruct dccp_v4_pernet *pn;\n\tstruct sock *ctl_sk;\n\n\t \n\tif (dccp_hdr(rxskb)->dccph_type == DCCP_PKT_RESET)\n\t\treturn;\n\n\tif (skb_rtable(rxskb)->rt_type != RTN_LOCAL)\n\t\treturn;\n\n\tpn = net_generic(net, dccp_v4_pernet_id);\n\tctl_sk = pn->v4_ctl_sk;\n\tdst = dccp_v4_route_skb(net, ctl_sk, rxskb);\n\tif (dst == NULL)\n\t\treturn;\n\n\tskb = dccp_ctl_make_reset(ctl_sk, rxskb);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\trxiph = ip_hdr(rxskb);\n\tdccp_hdr(skb)->dccph_checksum = dccp_v4_csum_finish(skb, rxiph->saddr,\n\t\t\t\t\t\t\t\t rxiph->daddr);\n\tskb_dst_set(skb, dst_clone(dst));\n\n\tlocal_bh_disable();\n\tbh_lock_sock(ctl_sk);\n\terr = ip_build_and_send_pkt(skb, ctl_sk,\n\t\t\t\t    rxiph->daddr, rxiph->saddr, NULL,\n\t\t\t\t    inet_sk(ctl_sk)->tos);\n\tbh_unlock_sock(ctl_sk);\n\n\tif (net_xmit_eval(err) == 0) {\n\t\t__DCCP_INC_STATS(DCCP_MIB_OUTSEGS);\n\t\t__DCCP_INC_STATS(DCCP_MIB_OUTRSTS);\n\t}\n\tlocal_bh_enable();\nout:\n\tdst_release(dst);\n}\n\nstatic void dccp_v4_reqsk_destructor(struct request_sock *req)\n{\n\tdccp_feat_list_purge(&dccp_rsk(req)->dreq_featneg);\n\tkfree(rcu_dereference_protected(inet_rsk(req)->ireq_opt, 1));\n}\n\nvoid dccp_syn_ack_timeout(const struct request_sock *req)\n{\n}\nEXPORT_SYMBOL(dccp_syn_ack_timeout);\n\nstatic struct request_sock_ops dccp_request_sock_ops __read_mostly = {\n\t.family\t\t= PF_INET,\n\t.obj_size\t= sizeof(struct dccp_request_sock),\n\t.rtx_syn_ack\t= dccp_v4_send_response,\n\t.send_ack\t= dccp_reqsk_send_ack,\n\t.destructor\t= dccp_v4_reqsk_destructor,\n\t.send_reset\t= dccp_v4_ctl_send_reset,\n\t.syn_ack_timeout = dccp_syn_ack_timeout,\n};\n\nint dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct request_sock *req;\n\tstruct dccp_request_sock *dreq;\n\tconst __be32 service = dccp_hdr_request(skb)->dccph_req_service;\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\n\t \n\tif (skb_rtable(skb)->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\treturn 0;\t \n\n\tif (dccp_bad_service_code(sk, service)) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_BAD_SERVICE_CODE;\n\t\tgoto drop;\n\t}\n\t \n\tdcb->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\n\tif (inet_csk_reqsk_queue_is_full(sk))\n\t\tgoto drop;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto drop;\n\n\treq = inet_reqsk_alloc(&dccp_request_sock_ops, sk, true);\n\tif (req == NULL)\n\t\tgoto drop;\n\n\tif (dccp_reqsk_init(req, dccp_sk(sk), skb))\n\t\tgoto drop_and_free;\n\n\tdreq = dccp_rsk(req);\n\tif (dccp_parse_options(sk, dreq, skb))\n\t\tgoto drop_and_free;\n\n\tireq = inet_rsk(req);\n\tsk_rcv_saddr_set(req_to_sk(req), ip_hdr(skb)->daddr);\n\tsk_daddr_set(req_to_sk(req), ip_hdr(skb)->saddr);\n\tireq->ir_mark = inet_request_mark(sk, skb);\n\tireq->ireq_family = AF_INET;\n\tireq->ir_iif = READ_ONCE(sk->sk_bound_dev_if);\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto drop_and_free;\n\n\t \n\tdreq->dreq_isr\t   = dcb->dccpd_seq;\n\tdreq->dreq_gsr\t   = dreq->dreq_isr;\n\tdreq->dreq_iss\t   = dccp_v4_init_sequence(skb);\n\tdreq->dreq_gss     = dreq->dreq_iss;\n\tdreq->dreq_service = service;\n\n\tif (dccp_v4_send_response(sk, req))\n\t\tgoto drop_and_free;\n\n\tinet_csk_reqsk_queue_hash_add(sk, req, DCCP_TIMEOUT_INIT);\n\treqsk_put(req);\n\treturn 0;\n\ndrop_and_free:\n\treqsk_free(req);\ndrop:\n\t__DCCP_INC_STATS(DCCP_MIB_ATTEMPTFAILS);\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(dccp_v4_conn_request);\n\nint dccp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\tif (sk->sk_state == DCCP_OPEN) {  \n\t\tif (dccp_rcv_established(sk, skb, dh, skb->len))\n\t\t\tgoto reset;\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (dccp_rcv_state_process(sk, skb, dh, skb->len))\n\t\tgoto reset;\n\treturn 0;\n\nreset:\n\tdccp_v4_ctl_send_reset(sk, skb);\n\tkfree_skb(skb);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dccp_v4_do_rcv);\n\n \nint dccp_invalid_packet(struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh;\n\tunsigned int cscov;\n\tu8 dccph_doff;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn 1;\n\n\t \n\tif (!pskb_may_pull(skb, sizeof(struct dccp_hdr))) {\n\t\tDCCP_WARN(\"pskb_may_pull failed\\n\");\n\t\treturn 1;\n\t}\n\n\tdh = dccp_hdr(skb);\n\n\t \n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tDCCP_WARN(\"invalid packet type\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tdccph_doff = dh->dccph_doff;\n\tif (dccph_doff < dccp_hdr_len(skb) / sizeof(u32)) {\n\t\tDCCP_WARN(\"P.Data Offset(%u) too small\\n\", dccph_doff);\n\t\treturn 1;\n\t}\n\t \n\tif (!pskb_may_pull(skb, dccph_doff * sizeof(u32))) {\n\t\tDCCP_WARN(\"P.Data Offset(%u) too large\\n\", dccph_doff);\n\t\treturn 1;\n\t}\n\tdh = dccp_hdr(skb);\n\t \n\tif ((dh->dccph_type < DCCP_PKT_DATA    ||\n\t    dh->dccph_type > DCCP_PKT_DATAACK) && dh->dccph_x == 0)  {\n\t\tDCCP_WARN(\"P.type (%s) not Data || [Data]Ack, while P.X == 0\\n\",\n\t\t\t  dccp_packet_name(dh->dccph_type));\n\t\treturn 1;\n\t}\n\n\t \n\tcscov = dccp_csum_coverage(skb);\n\tif (cscov > skb->len) {\n\t\tDCCP_WARN(\"P.CsCov %u exceeds packet length %d\\n\",\n\t\t\t  dh->dccph_cscov, skb->len);\n\t\treturn 1;\n\t}\n\n\t \n\tskb->csum = skb_checksum(skb, 0, cscov, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dccp_invalid_packet);\n\n \nstatic int dccp_v4_rcv(struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh;\n\tconst struct iphdr *iph;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint min_cov;\n\n\t \n\n\tif (dccp_invalid_packet(skb))\n\t\tgoto discard_it;\n\n\tiph = ip_hdr(skb);\n\t \n\tif (dccp_v4_csum_finish(skb, iph->saddr, iph->daddr)) {\n\t\tDCCP_WARN(\"dropped packet with invalid checksum\\n\");\n\t\tgoto discard_it;\n\t}\n\n\tdh = dccp_hdr(skb);\n\n\tDCCP_SKB_CB(skb)->dccpd_seq  = dccp_hdr_seq(dh);\n\tDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\n\n\tdccp_pr_debug(\"%8.8s src=%pI4@%-5d dst=%pI4@%-5d seq=%llu\",\n\t\t      dccp_packet_name(dh->dccph_type),\n\t\t      &iph->saddr, ntohs(dh->dccph_sport),\n\t\t      &iph->daddr, ntohs(dh->dccph_dport),\n\t\t      (unsigned long long) DCCP_SKB_CB(skb)->dccpd_seq);\n\n\tif (dccp_packet_without_ack(skb)) {\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\n\t\tdccp_pr_debug_cat(\"\\n\");\n\t} else {\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\n\t\tdccp_pr_debug_cat(\", ack=%llu\\n\", (unsigned long long)\n\t\t\t\t  DCCP_SKB_CB(skb)->dccpd_ack_seq);\n\t}\n\nlookup:\n\tsk = __inet_lookup_skb(&dccp_hashinfo, skb, __dccp_hdr_len(dh),\n\t\t\t       dh->dccph_sport, dh->dccph_dport, 0, &refcounted);\n\tif (!sk) {\n\t\tdccp_pr_debug(\"failed to look up flow ID in table and \"\n\t\t\t      \"get corresponding socket\\n\");\n\t\tgoto no_dccp_socket;\n\t}\n\n\t \n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tdccp_pr_debug(\"sk->sk_state == DCCP_TIME_WAIT: do_time_wait\\n\");\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto no_dccp_socket;\n\t}\n\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(sk->sk_state != DCCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = dccp_check_req(sk, skb, req);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (dccp_child_process(sk, nsk, skb)) {\n\t\t\tdccp_v4_ctl_send_reset(sk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\tmin_cov = dccp_sk(sk)->dccps_pcrlen;\n\tif (dh->dccph_cscov && (min_cov == 0 || dh->dccph_cscov < min_cov))  {\n\t\tdccp_pr_debug(\"Packet CsCov %d does not satisfy MinCsCov %d\\n\",\n\t\t\t      dh->dccph_cscov, min_cov);\n\t\t \n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\tnf_reset_ct(skb);\n\n\treturn __sk_receive_skb(sk, skb, 1, dh->dccph_doff * 4, refcounted);\n\nno_dccp_socket:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\t \n\tif (dh->dccph_type != DCCP_PKT_RESET) {\n\t\tDCCP_SKB_CB(skb)->dccpd_reset_code =\n\t\t\t\t\tDCCP_RESET_CODE_NO_CONNECTION;\n\t\tdccp_v4_ctl_send_reset(sk, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n}\n\nstatic const struct inet_connection_sock_af_ops dccp_ipv4_af_ops = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = dccp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.conn_request\t   = dccp_v4_conn_request,\n\t.syn_recv_sock\t   = dccp_v4_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ip_setsockopt,\n\t.getsockopt\t   = ip_getsockopt,\n\t.addr2sockaddr\t   = inet_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in),\n};\n\nstatic int dccp_v4_init_sock(struct sock *sk)\n{\n\tstatic __u8 dccp_v4_ctl_sock_initialized;\n\tint err = dccp_init_sock(sk, dccp_v4_ctl_sock_initialized);\n\n\tif (err == 0) {\n\t\tif (unlikely(!dccp_v4_ctl_sock_initialized))\n\t\t\tdccp_v4_ctl_sock_initialized = 1;\n\t\tinet_csk(sk)->icsk_af_ops = &dccp_ipv4_af_ops;\n\t}\n\n\treturn err;\n}\n\nstatic struct timewait_sock_ops dccp_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct inet_timewait_sock),\n};\n\nstatic struct proto dccp_v4_prot = {\n\t.name\t\t\t= \"DCCP\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= dccp_close,\n\t.connect\t\t= dccp_v4_connect,\n\t.disconnect\t\t= dccp_disconnect,\n\t.ioctl\t\t\t= dccp_ioctl,\n\t.init\t\t\t= dccp_v4_init_sock,\n\t.setsockopt\t\t= dccp_setsockopt,\n\t.getsockopt\t\t= dccp_getsockopt,\n\t.sendmsg\t\t= dccp_sendmsg,\n\t.recvmsg\t\t= dccp_recvmsg,\n\t.backlog_rcv\t\t= dccp_v4_do_rcv,\n\t.hash\t\t\t= inet_hash,\n\t.unhash\t\t\t= inet_unhash,\n\t.accept\t\t\t= inet_csk_accept,\n\t.get_port\t\t= inet_csk_get_port,\n\t.shutdown\t\t= dccp_shutdown,\n\t.destroy\t\t= dccp_destroy_sock,\n\t.orphan_count\t\t= &dccp_orphan_count,\n\t.max_header\t\t= MAX_DCCP_HEADER,\n\t.obj_size\t\t= sizeof(struct dccp_sock),\n\t.slab_flags\t\t= SLAB_TYPESAFE_BY_RCU,\n\t.rsk_prot\t\t= &dccp_request_sock_ops,\n\t.twsk_prot\t\t= &dccp_timewait_sock_ops,\n\t.h.hashinfo\t\t= &dccp_hashinfo,\n};\n\nstatic const struct net_protocol dccp_v4_protocol = {\n\t.handler\t= dccp_v4_rcv,\n\t.err_handler\t= dccp_v4_err,\n\t.no_policy\t= 1,\n\t.icmp_strict_tag_validation = 1,\n};\n\nstatic const struct proto_ops inet_dccp_ops = {\n\t.family\t\t   = PF_INET,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet_release,\n\t.bind\t\t   = inet_bind,\n\t.connect\t   = inet_stream_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = inet_getname,\n\t \n\t.poll\t\t   = dccp_poll,\n\t.ioctl\t\t   = inet_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t \n\t.listen\t\t   = inet_dccp_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n};\n\nstatic struct inet_protosw dccp_v4_protosw = {\n\t.type\t\t= SOCK_DCCP,\n\t.protocol\t= IPPROTO_DCCP,\n\t.prot\t\t= &dccp_v4_prot,\n\t.ops\t\t= &inet_dccp_ops,\n\t.flags\t\t= INET_PROTOSW_ICSK,\n};\n\nstatic int __net_init dccp_v4_init_net(struct net *net)\n{\n\tstruct dccp_v4_pernet *pn = net_generic(net, dccp_v4_pernet_id);\n\n\tif (dccp_hashinfo.bhash == NULL)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\treturn inet_ctl_sock_create(&pn->v4_ctl_sk, PF_INET,\n\t\t\t\t    SOCK_DCCP, IPPROTO_DCCP, net);\n}\n\nstatic void __net_exit dccp_v4_exit_net(struct net *net)\n{\n\tstruct dccp_v4_pernet *pn = net_generic(net, dccp_v4_pernet_id);\n\n\tinet_ctl_sock_destroy(pn->v4_ctl_sk);\n}\n\nstatic void __net_exit dccp_v4_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&dccp_hashinfo, AF_INET);\n}\n\nstatic struct pernet_operations dccp_v4_ops = {\n\t.init\t= dccp_v4_init_net,\n\t.exit\t= dccp_v4_exit_net,\n\t.exit_batch = dccp_v4_exit_batch,\n\t.id\t= &dccp_v4_pernet_id,\n\t.size   = sizeof(struct dccp_v4_pernet),\n};\n\nstatic int __init dccp_v4_init(void)\n{\n\tint err = proto_register(&dccp_v4_prot, 1);\n\n\tif (err)\n\t\tgoto out;\n\n\tinet_register_protosw(&dccp_v4_protosw);\n\n\terr = register_pernet_subsys(&dccp_v4_ops);\n\tif (err)\n\t\tgoto out_destroy_ctl_sock;\n\n\terr = inet_add_protocol(&dccp_v4_protocol, IPPROTO_DCCP);\n\tif (err)\n\t\tgoto out_proto_unregister;\n\nout:\n\treturn err;\nout_proto_unregister:\n\tunregister_pernet_subsys(&dccp_v4_ops);\nout_destroy_ctl_sock:\n\tinet_unregister_protosw(&dccp_v4_protosw);\n\tproto_unregister(&dccp_v4_prot);\n\tgoto out;\n}\n\nstatic void __exit dccp_v4_exit(void)\n{\n\tinet_del_protocol(&dccp_v4_protocol, IPPROTO_DCCP);\n\tunregister_pernet_subsys(&dccp_v4_ops);\n\tinet_unregister_protosw(&dccp_v4_protosw);\n\tproto_unregister(&dccp_v4_prot);\n}\n\nmodule_init(dccp_v4_init);\nmodule_exit(dccp_v4_exit);\n\n \nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET, 33, 6);\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET, 0, 6);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arnaldo Carvalho de Melo <acme@mandriva.com>\");\nMODULE_DESCRIPTION(\"DCCP - Datagram Congestion Controlled Protocol\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}