{
  "module_name": "ipv6.c",
  "hash_id": "4d69bd4be8b0ce38875af357148feb121ebe1261f47eea32b88fb4894f9e6a93",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/ipv6.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/xfrm.h>\n#include <linux/string.h>\n\n#include <net/addrconf.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/inet_sock.h>\n#include <net/inet6_connection_sock.h>\n#include <net/inet6_hashtables.h>\n#include <net/ip6_route.h>\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_checksum.h>\n#include <net/xfrm.h>\n#include <net/secure_seq.h>\n#include <net/netns/generic.h>\n#include <net/sock.h>\n\n#include \"dccp.h\"\n#include \"ipv6.h\"\n#include \"feat.h\"\n\nstruct dccp_v6_pernet {\n\tstruct sock *v6_ctl_sk;\n};\n\nstatic unsigned int dccp_v6_pernet_id __read_mostly;\n\n \n\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_af_ops;\n\n \nstatic inline __sum16 dccp_v6_csum_finish(struct sk_buff *skb,\n\t\t\t\t      const struct in6_addr *saddr,\n\t\t\t\t      const struct in6_addr *daddr)\n{\n\treturn csum_ipv6_magic(saddr, daddr, skb->len, IPPROTO_DCCP, skb->csum);\n}\n\nstatic inline void dccp_v6_send_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\tdccp_csum_outgoing(skb);\n\tdh->dccph_checksum = dccp_v6_csum_finish(skb, &np->saddr, &sk->sk_v6_daddr);\n}\n\nstatic inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n\n}\n\nstatic int dccp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr;\n\tconst struct dccp_hdr *dh;\n\tstruct dccp_sock *dp;\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tint err;\n\t__u64 seq;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (!pskb_may_pull(skb, offset + sizeof(*dh)))\n\t\treturn -EINVAL;\n\tdh = (struct dccp_hdr *)(skb->data + offset);\n\tif (!pskb_may_pull(skb, offset + __dccp_basic_hdr_len(dh)))\n\t\treturn -EINVAL;\n\thdr = (const struct ipv6hdr *)skb->data;\n\tdh = (struct dccp_hdr *)(skb->data + offset);\n\n\tsk = __inet6_lookup_established(net, &dccp_hashinfo,\n\t\t\t\t\t&hdr->daddr, dh->dccph_dport,\n\t\t\t\t\t&hdr->saddr, ntohs(dh->dccph_sport),\n\t\t\t\t\tinet6_iif(skb), 0);\n\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\treturn -ENOENT;\n\t}\n\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn 0;\n\t}\n\tseq = dccp_hdr_seq(dh);\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tdccp_req_err(sk, seq);\n\t\treturn 0;\n\t}\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk))\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == DCCP_CLOSED)\n\t\tgoto out;\n\n\tdp = dccp_sk(sk);\n\tif ((1 << sk->sk_state) & ~(DCCPF_REQUESTING | DCCPF_LISTEN) &&\n\t    !between48(seq, dp->dccps_awl, dp->dccps_awh)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\t\tif (dst)\n\t\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tstruct dst_entry *dst = NULL;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\tif (sock_owned_by_user(sk))\n\t\t\tgoto out;\n\t\tif ((1 << sk->sk_state) & (DCCPF_LISTEN | DCCPF_CLOSED))\n\t\t\tgoto out;\n\n\t\tdst = inet6_csk_update_pmtu(sk, ntohl(info));\n\t\tif (!dst)\n\t\t\tgoto out;\n\n\t\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst))\n\t\t\tdccp_sync_mss(sk, dst_mtu(dst));\n\t\tgoto out;\n\t}\n\n\ticmpv6_err_convert(type, code, &err);\n\n\t \n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\tcase DCCP_RESPOND:   \n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\t__DCCP_INC_STATS(DCCP_MIB_ATTEMPTFAILS);\n\t\t\tsk->sk_err = err;\n\t\t\t \n\t\t\tsk_error_report(sk);\n\t\t\tdccp_done(sk);\n\t\t} else {\n\t\t\tWRITE_ONCE(sk->sk_err_soft, err);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk_error_report(sk);\n\t} else {\n\t\tWRITE_ONCE(sk->sk_err_soft, err);\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}\n\n\nstatic int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi_common(&fl6));\n\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tstruct ipv6_txoptions *opt;\n\n\t\tdh->dccph_checksum = dccp_v6_csum_finish(skb,\n\t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n\t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\trcu_read_lock();\n\t\topt = ireq->ipv6_opt;\n\t\tif (!opt)\n\t\t\topt = rcu_dereference(np->opt);\n\t\terr = ip6_xmit(sk, skb, &fl6, READ_ONCE(sk->sk_mark), opt,\n\t\t\t       np->tclass, sk->sk_priority);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic void dccp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tdccp_feat_list_purge(&dccp_rsk(req)->dreq_featneg);\n\tkfree(inet_rsk(req)->ipv6_opt);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\nstatic void dccp_v6_ctl_send_reset(const struct sock *sk, struct sk_buff *rxskb)\n{\n\tconst struct ipv6hdr *rxip6h;\n\tstruct sk_buff *skb;\n\tstruct flowi6 fl6;\n\tstruct net *net = dev_net(skb_dst(rxskb)->dev);\n\tstruct dccp_v6_pernet *pn;\n\tstruct sock *ctl_sk;\n\tstruct dst_entry *dst;\n\n\tif (dccp_hdr(rxskb)->dccph_type == DCCP_PKT_RESET)\n\t\treturn;\n\n\tif (!ipv6_unicast_destination(rxskb))\n\t\treturn;\n\n\tpn = net_generic(net, dccp_v6_pernet_id);\n\tctl_sk = pn->v6_ctl_sk;\n\tskb = dccp_ctl_make_reset(ctl_sk, rxskb);\n\tif (skb == NULL)\n\t\treturn;\n\n\trxip6h = ipv6_hdr(rxskb);\n\tdccp_hdr(skb)->dccph_checksum = dccp_v6_csum_finish(skb, &rxip6h->saddr,\n\t\t\t\t\t\t\t    &rxip6h->daddr);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = rxip6h->saddr;\n\tfl6.saddr = rxip6h->daddr;\n\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.flowi6_oif = inet6_iif(rxskb);\n\tfl6.fl6_dport = dccp_hdr(skb)->dccph_dport;\n\tfl6.fl6_sport = dccp_hdr(skb)->dccph_sport;\n\tsecurity_skb_classify_flow(rxskb, flowi6_to_flowi_common(&fl6));\n\n\t \n\tdst = ip6_dst_lookup_flow(sock_net(ctl_sk), ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(skb, dst);\n\t\tip6_xmit(ctl_sk, skb, &fl6, 0, NULL, 0, 0);\n\t\tDCCP_INC_STATS(DCCP_MIB_OUTSEGS);\n\t\tDCCP_INC_STATS(DCCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic struct request_sock_ops dccp6_request_sock_ops = {\n\t.family\t\t= AF_INET6,\n\t.obj_size\t= sizeof(struct dccp6_request_sock),\n\t.rtx_syn_ack\t= dccp_v6_send_response,\n\t.send_ack\t= dccp_reqsk_send_ack,\n\t.destructor\t= dccp_v6_reqsk_destructor,\n\t.send_reset\t= dccp_v6_ctl_send_reset,\n\t.syn_ack_timeout = dccp_syn_ack_timeout,\n};\n\nstatic int dccp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct request_sock *req;\n\tstruct dccp_request_sock *dreq;\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tconst __be32 service = dccp_hdr_request(skb)->dccph_req_service;\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn dccp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\treturn 0;\t \n\n\tif (ipv6_addr_v4mapped(&ipv6_hdr(skb)->saddr)) {\n\t\t__IP6_INC_STATS(sock_net(sk), NULL, IPSTATS_MIB_INHDRERRORS);\n\t\treturn 0;\n\t}\n\n\tif (dccp_bad_service_code(sk, service)) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_BAD_SERVICE_CODE;\n\t\tgoto drop;\n\t}\n\t \n\tdcb->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\n\tif (inet_csk_reqsk_queue_is_full(sk))\n\t\tgoto drop;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto drop;\n\n\treq = inet_reqsk_alloc(&dccp6_request_sock_ops, sk, true);\n\tif (req == NULL)\n\t\tgoto drop;\n\n\tif (dccp_reqsk_init(req, dccp_sk(sk), skb))\n\t\tgoto drop_and_free;\n\n\tdreq = dccp_rsk(req);\n\tif (dccp_parse_options(sk, dreq, skb))\n\t\tgoto drop_and_free;\n\n\tireq = inet_rsk(req);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tireq->ireq_family = AF_INET6;\n\tireq->ir_mark = inet_request_mark(sk, skb);\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto drop_and_free;\n\n\tif (ipv6_opt_accepted(sk, skb, IP6CB(skb)) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\trefcount_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\tireq->ir_iif = READ_ONCE(sk->sk_bound_dev_if);\n\n\t \n\tif (!ireq->ir_iif &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = inet6_iif(skb);\n\n\t \n\tdreq->dreq_isr\t   = dcb->dccpd_seq;\n\tdreq->dreq_gsr     = dreq->dreq_isr;\n\tdreq->dreq_iss\t   = dccp_v6_init_sequence(skb);\n\tdreq->dreq_gss     = dreq->dreq_iss;\n\tdreq->dreq_service = service;\n\n\tif (dccp_v6_send_response(sk, req))\n\t\tgoto drop_and_free;\n\n\tinet_csk_reqsk_queue_hash_add(sk, req, DCCP_TIMEOUT_INIT);\n\treqsk_put(req);\n\treturn 0;\n\ndrop_and_free:\n\treqsk_free(req);\ndrop:\n\t__DCCP_INC_STATS(DCCP_MIB_ATTEMPTFAILS);\n\treturn -1;\n}\n\nstatic struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst,\n\t\t\t\t\t      struct request_sock *req_unhash,\n\t\t\t\t\t      bool *own_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t \n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t\t  req_unhash, own_req);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->ipv6_mc_list = NULL;\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->mcast_oif   = inet_iif(skb);\n\t\tnewnp->mcast_hops  = ip_hdr(skb)->ttl;\n\n\t\t \n\n\t\t \n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t \n\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr\t= ireq->ir_v6_rmt_addr;\n\tnewnp->saddr\t\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if\t= ireq->ir_iif;\n\n\t \n\tnewinet->inet_opt = NULL;\n\n\t \n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->ipv6_mc_list = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t \n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\tdccp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash), NULL);\n\t \n\tif (*own_req && ireq->pktopts) {\n\t\tnewnp->pktoptions = skb_clone_and_charge_r(ireq->pktopts, newsk);\n\t\tconsume_skb(ireq->pktopts);\n\t\tireq->pktopts = NULL;\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n\n \nstatic int dccp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *opt_skb = NULL;\n\n\t \n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn dccp_v4_do_rcv(sk, skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard;\n\n\t \n\n\t \n\tif (np->rxopt.all)\n\t\topt_skb = skb_clone_and_charge_r(skb, sk);\n\n\tif (sk->sk_state == DCCP_OPEN) {  \n\t\tif (dccp_rcv_established(sk, skb, dccp_hdr(skb), skb->len))\n\t\t\tgoto reset;\n\t\tif (opt_skb)\n\t\t\tgoto ipv6_pktoptions;\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (dccp_rcv_state_process(sk, skb, dccp_hdr(skb), skb->len))\n\t\tgoto reset;\n\tif (opt_skb)\n\t\tgoto ipv6_pktoptions;\n\treturn 0;\n\nreset:\n\tdccp_v6_ctl_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb != NULL)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\n\n \nipv6_pktoptions:\n\tif (!((1 << sk->sk_state) & (DCCPF_CLOSED | DCCPF_LISTEN))) {\n\t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)\n\t\t\tnp->mcast_oif = inet6_iif(opt_skb);\n\t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)\n\t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;\n\t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)\n\t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));\n\t\tif (np->repflow)\n\t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));\n\t\tif (ipv6_opt_accepted(sk, opt_skb,\n\t\t\t\t      &DCCP_SKB_CB(opt_skb)->header.h6)) {\n\t\t\tmemmove(IP6CB(opt_skb),\n\t\t\t\t&DCCP_SKB_CB(opt_skb)->header.h6,\n\t\t\t\tsizeof(struct inet6_skb_parm));\n\t\t\topt_skb = xchg(&np->pktoptions, opt_skb);\n\t\t} else {\n\t\t\t__kfree_skb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, NULL);\n\t\t}\n\t}\n\n\tkfree_skb(opt_skb);\n\treturn 0;\n}\n\nstatic int dccp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint min_cov;\n\n\t \n\n\tif (dccp_invalid_packet(skb))\n\t\tgoto discard_it;\n\n\t \n\tif (dccp_v6_csum_finish(skb, &ipv6_hdr(skb)->saddr,\n\t\t\t\t     &ipv6_hdr(skb)->daddr)) {\n\t\tDCCP_WARN(\"dropped packet with invalid checksum\\n\");\n\t\tgoto discard_it;\n\t}\n\n\tdh = dccp_hdr(skb);\n\n\tDCCP_SKB_CB(skb)->dccpd_seq  = dccp_hdr_seq(dh);\n\tDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\n\n\tif (dccp_packet_without_ack(skb))\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\n\telse\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&dccp_hashinfo, skb, __dccp_hdr_len(dh),\n\t\t\t        dh->dccph_sport, dh->dccph_dport,\n\t\t\t\tinet6_iif(skb), 0, &refcounted);\n\tif (!sk) {\n\t\tdccp_pr_debug(\"failed to look up flow ID in table and \"\n\t\t\t      \"get corresponding socket\\n\");\n\t\tgoto no_dccp_socket;\n\t}\n\n\t \n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tdccp_pr_debug(\"sk->sk_state == DCCP_TIME_WAIT: do_time_wait\\n\");\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto no_dccp_socket;\n\t}\n\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(sk->sk_state != DCCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = dccp_check_req(sk, skb, req);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (dccp_child_process(sk, nsk, skb)) {\n\t\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\tmin_cov = dccp_sk(sk)->dccps_pcrlen;\n\tif (dh->dccph_cscov  &&  (min_cov == 0 || dh->dccph_cscov < min_cov))  {\n\t\tdccp_pr_debug(\"Packet CsCov %d does not satisfy MinCsCov %d\\n\",\n\t\t\t      dh->dccph_cscov, min_cov);\n\t\t \n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\tnf_reset_ct(skb);\n\n\treturn __sk_receive_skb(sk, skb, 1, dh->dccph_doff * 4,\n\t\t\t\trefcounted) ? -1 : 0;\n\nno_dccp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\t \n\tif (dh->dccph_type != DCCP_PKT_RESET) {\n\t\tDCCP_SKB_CB(skb)->dccpd_reset_code =\n\t\t\t\t\tDCCP_RESET_CODE_NO_CONNECTION;\n\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n}\n\nstatic int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t   int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *)uaddr;\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel & IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (IS_ERR(flowlabel))\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\t \n\tif (ipv6_addr_any(&usin->sin6_addr))\n\t\tusin->sin6_addr.s6_addr[15] = 1;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t \n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t \n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t \n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\n\t\terr = dccp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &dccp_ipv6_af_ops;\n\t\t\tsk->sk_backlog_rcv = dccp_v6_do_rcv;\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(&fl6));\n\n\topt = rcu_dereference_protected(np->opt, lockdep_sock_is_held(sk));\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (saddr == NULL) {\n\t\tsaddr = &fl6.saddr;\n\n\t\terr = inet_bhash2_update_saddr(sk, saddr, AF_INET6);\n\t\tif (err)\n\t\t\tgoto failure;\n\t}\n\n\t \n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tip6_dst_store(sk, dst, NULL, NULL);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\n\tinet->inet_dport = usin->sin6_port;\n\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet6_hash_connect(&dccp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tdp->dccps_iss = secure_dccpv6_sequence_number(np->saddr.s6_addr32,\n\t\t\t\t\t\t      sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t      inet->inet_sport,\n\t\t\t\t\t\t      inet->inet_dport);\n\terr = dccp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\tdccp_set_state(sk, DCCP_CLOSED);\n\tinet_bhash2_reset_saddr(sk);\n\t__sk_dst_reset(sk);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_af_ops = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = dccp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.conn_request\t   = dccp_v6_conn_request,\n\t.syn_recv_sock\t   = dccp_v6_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n};\n\n \nstatic const struct inet_connection_sock_af_ops dccp_ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = dccp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.conn_request\t   = dccp_v6_conn_request,\n\t.syn_recv_sock\t   = dccp_v6_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n};\n\nstatic void dccp_v6_sk_destruct(struct sock *sk)\n{\n\tdccp_destruct_common(sk);\n\tinet6_sock_destruct(sk);\n}\n\n \nstatic int dccp_v6_init_sock(struct sock *sk)\n{\n\tstatic __u8 dccp_v6_ctl_sock_initialized;\n\tint err = dccp_init_sock(sk, dccp_v6_ctl_sock_initialized);\n\n\tif (err == 0) {\n\t\tif (unlikely(!dccp_v6_ctl_sock_initialized))\n\t\t\tdccp_v6_ctl_sock_initialized = 1;\n\t\tinet_csk(sk)->icsk_af_ops = &dccp_ipv6_af_ops;\n\t\tsk->sk_destruct = dccp_v6_sk_destruct;\n\t}\n\n\treturn err;\n}\n\nstatic struct timewait_sock_ops dccp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct dccp6_timewait_sock),\n};\n\nstatic struct proto dccp_v6_prot = {\n\t.name\t\t   = \"DCCPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = dccp_close,\n\t.connect\t   = dccp_v6_connect,\n\t.disconnect\t   = dccp_disconnect,\n\t.ioctl\t\t   = dccp_ioctl,\n\t.init\t\t   = dccp_v6_init_sock,\n\t.setsockopt\t   = dccp_setsockopt,\n\t.getsockopt\t   = dccp_getsockopt,\n\t.sendmsg\t   = dccp_sendmsg,\n\t.recvmsg\t   = dccp_recvmsg,\n\t.backlog_rcv\t   = dccp_v6_do_rcv,\n\t.hash\t\t   = inet6_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.accept\t\t   = inet_csk_accept,\n\t.get_port\t   = inet_csk_get_port,\n\t.shutdown\t   = dccp_shutdown,\n\t.destroy\t   = dccp_destroy_sock,\n\t.orphan_count\t   = &dccp_orphan_count,\n\t.max_header\t   = MAX_DCCP_HEADER,\n\t.obj_size\t   = sizeof(struct dccp6_sock),\n\t.ipv6_pinfo_offset = offsetof(struct dccp6_sock, inet6),\n\t.slab_flags\t   = SLAB_TYPESAFE_BY_RCU,\n\t.rsk_prot\t   = &dccp6_request_sock_ops,\n\t.twsk_prot\t   = &dccp6_timewait_sock_ops,\n\t.h.hashinfo\t   = &dccp_hashinfo,\n};\n\nstatic const struct inet6_protocol dccp_v6_protocol = {\n\t.handler\t= dccp_v6_rcv,\n\t.err_handler\t= dccp_v6_err,\n\t.flags\t\t= INET6_PROTO_NOPOLICY | INET6_PROTO_FINAL,\n};\n\nstatic const struct proto_ops inet6_dccp_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_stream_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = dccp_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = inet_dccp_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = inet6_compat_ioctl,\n#endif\n};\n\nstatic struct inet_protosw dccp_v6_protosw = {\n\t.type\t\t= SOCK_DCCP,\n\t.protocol\t= IPPROTO_DCCP,\n\t.prot\t\t= &dccp_v6_prot,\n\t.ops\t\t= &inet6_dccp_ops,\n\t.flags\t\t= INET_PROTOSW_ICSK,\n};\n\nstatic int __net_init dccp_v6_init_net(struct net *net)\n{\n\tstruct dccp_v6_pernet *pn = net_generic(net, dccp_v6_pernet_id);\n\n\tif (dccp_hashinfo.bhash == NULL)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\treturn inet_ctl_sock_create(&pn->v6_ctl_sk, PF_INET6,\n\t\t\t\t    SOCK_DCCP, IPPROTO_DCCP, net);\n}\n\nstatic void __net_exit dccp_v6_exit_net(struct net *net)\n{\n\tstruct dccp_v6_pernet *pn = net_generic(net, dccp_v6_pernet_id);\n\n\tinet_ctl_sock_destroy(pn->v6_ctl_sk);\n}\n\nstatic void __net_exit dccp_v6_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&dccp_hashinfo, AF_INET6);\n}\n\nstatic struct pernet_operations dccp_v6_ops = {\n\t.init   = dccp_v6_init_net,\n\t.exit   = dccp_v6_exit_net,\n\t.exit_batch = dccp_v6_exit_batch,\n\t.id\t= &dccp_v6_pernet_id,\n\t.size   = sizeof(struct dccp_v6_pernet),\n};\n\nstatic int __init dccp_v6_init(void)\n{\n\tint err = proto_register(&dccp_v6_prot, 1);\n\n\tif (err)\n\t\tgoto out;\n\n\tinet6_register_protosw(&dccp_v6_protosw);\n\n\terr = register_pernet_subsys(&dccp_v6_ops);\n\tif (err)\n\t\tgoto out_destroy_ctl_sock;\n\n\terr = inet6_add_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tif (err)\n\t\tgoto out_unregister_proto;\n\nout:\n\treturn err;\nout_unregister_proto:\n\tunregister_pernet_subsys(&dccp_v6_ops);\nout_destroy_ctl_sock:\n\tinet6_unregister_protosw(&dccp_v6_protosw);\n\tproto_unregister(&dccp_v6_prot);\n\tgoto out;\n}\n\nstatic void __exit dccp_v6_exit(void)\n{\n\tinet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tunregister_pernet_subsys(&dccp_v6_ops);\n\tinet6_unregister_protosw(&dccp_v6_protosw);\n\tproto_unregister(&dccp_v6_prot);\n}\n\nmodule_init(dccp_v6_init);\nmodule_exit(dccp_v6_exit);\n\n \nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 33, 6);\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 0, 6);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arnaldo Carvalho de Melo <acme@mandriva.com>\");\nMODULE_DESCRIPTION(\"DCCPv6 - Datagram Congestion Controlled Protocol\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}