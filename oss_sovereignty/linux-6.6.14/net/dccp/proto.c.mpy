{
  "module_name": "proto.c",
  "hash_id": "d5230ab6dca4ab374700fad578dbb154927dc106bf4b893a1eaf52f8331c62f3",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/proto.c",
  "human_readable_source": "\n \n\n#include <linux/dccp.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <net/checksum.h>\n\n#include <net/inet_sock.h>\n#include <net/inet_common.h>\n#include <net/sock.h>\n#include <net/xfrm.h>\n\n#include <asm/ioctls.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/poll.h>\n\n#include \"ccid.h\"\n#include \"dccp.h\"\n#include \"feat.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\nDEFINE_SNMP_STAT(struct dccp_mib, dccp_statistics) __read_mostly;\n\nEXPORT_SYMBOL_GPL(dccp_statistics);\n\nDEFINE_PER_CPU(unsigned int, dccp_orphan_count);\nEXPORT_PER_CPU_SYMBOL_GPL(dccp_orphan_count);\n\nstruct inet_hashinfo dccp_hashinfo;\nEXPORT_SYMBOL_GPL(dccp_hashinfo);\n\n \nint sysctl_dccp_tx_qlen __read_mostly = 5;\n\n#ifdef CONFIG_IP_DCCP_DEBUG\nstatic const char *dccp_state_name(const int state)\n{\n\tstatic const char *const dccp_state_names[] = {\n\t[DCCP_OPEN]\t\t= \"OPEN\",\n\t[DCCP_REQUESTING]\t= \"REQUESTING\",\n\t[DCCP_PARTOPEN]\t\t= \"PARTOPEN\",\n\t[DCCP_LISTEN]\t\t= \"LISTEN\",\n\t[DCCP_RESPOND]\t\t= \"RESPOND\",\n\t[DCCP_CLOSING]\t\t= \"CLOSING\",\n\t[DCCP_ACTIVE_CLOSEREQ]\t= \"CLOSEREQ\",\n\t[DCCP_PASSIVE_CLOSE]\t= \"PASSIVE_CLOSE\",\n\t[DCCP_PASSIVE_CLOSEREQ]\t= \"PASSIVE_CLOSEREQ\",\n\t[DCCP_TIME_WAIT]\t= \"TIME_WAIT\",\n\t[DCCP_CLOSED]\t\t= \"CLOSED\",\n\t};\n\n\tif (state >= DCCP_MAX_STATES)\n\t\treturn \"INVALID STATE!\";\n\telse\n\t\treturn dccp_state_names[state];\n}\n#endif\n\nvoid dccp_set_state(struct sock *sk, const int state)\n{\n\tconst int oldstate = sk->sk_state;\n\n\tdccp_pr_debug(\"%s(%p)  %s  -->  %s\\n\", dccp_role(sk), sk,\n\t\t      dccp_state_name(oldstate), dccp_state_name(state));\n\tWARN_ON(state == oldstate);\n\n\tswitch (state) {\n\tcase DCCP_OPEN:\n\t\tif (oldstate != DCCP_OPEN)\n\t\t\tDCCP_INC_STATS(DCCP_MIB_CURRESTAB);\n\t\t \n\t\tif (oldstate == DCCP_PARTOPEN)\n\t\t\tdccp_feat_list_purge(&dccp_sk(sk)->dccps_featneg);\n\t\tbreak;\n\n\tcase DCCP_CLOSED:\n\t\tif (oldstate == DCCP_OPEN || oldstate == DCCP_ACTIVE_CLOSEREQ ||\n\t\t    oldstate == DCCP_CLOSING)\n\t\t\tDCCP_INC_STATS(DCCP_MIB_ESTABRESETS);\n\n\t\tsk->sk_prot->unhash(sk);\n\t\tif (inet_csk(sk)->icsk_bind_hash != NULL &&\n\t\t    !(sk->sk_userlocks & SOCK_BINDPORT_LOCK))\n\t\t\tinet_put_port(sk);\n\t\tfallthrough;\n\tdefault:\n\t\tif (oldstate == DCCP_OPEN)\n\t\t\tDCCP_DEC_STATS(DCCP_MIB_CURRESTAB);\n\t}\n\n\t \n\tinet_sk_set_state(sk, state);\n}\n\nEXPORT_SYMBOL_GPL(dccp_set_state);\n\nstatic void dccp_finish_passive_close(struct sock *sk)\n{\n\tswitch (sk->sk_state) {\n\tcase DCCP_PASSIVE_CLOSE:\n\t\t \n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_CLOSED);\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\t\tbreak;\n\tcase DCCP_PASSIVE_CLOSEREQ:\n\t\t \n\t\tdccp_send_close(sk, 1);\n\t\tdccp_set_state(sk, DCCP_CLOSING);\n\t}\n}\n\nvoid dccp_done(struct sock *sk)\n{\n\tdccp_set_state(sk, DCCP_CLOSED);\n\tdccp_clear_xmit_timers(sk);\n\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_state_change(sk);\n\telse\n\t\tinet_csk_destroy_sock(sk);\n}\n\nEXPORT_SYMBOL_GPL(dccp_done);\n\nconst char *dccp_packet_name(const int type)\n{\n\tstatic const char *const dccp_packet_names[] = {\n\t\t[DCCP_PKT_REQUEST]  = \"REQUEST\",\n\t\t[DCCP_PKT_RESPONSE] = \"RESPONSE\",\n\t\t[DCCP_PKT_DATA]\t    = \"DATA\",\n\t\t[DCCP_PKT_ACK]\t    = \"ACK\",\n\t\t[DCCP_PKT_DATAACK]  = \"DATAACK\",\n\t\t[DCCP_PKT_CLOSEREQ] = \"CLOSEREQ\",\n\t\t[DCCP_PKT_CLOSE]    = \"CLOSE\",\n\t\t[DCCP_PKT_RESET]    = \"RESET\",\n\t\t[DCCP_PKT_SYNC]\t    = \"SYNC\",\n\t\t[DCCP_PKT_SYNCACK]  = \"SYNCACK\",\n\t};\n\n\tif (type >= DCCP_NR_PKT_TYPES)\n\t\treturn \"INVALID\";\n\telse\n\t\treturn dccp_packet_names[type];\n}\n\nEXPORT_SYMBOL_GPL(dccp_packet_name);\n\nvoid dccp_destruct_common(struct sock *sk)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\tccid_hc_tx_delete(dp->dccps_hc_tx_ccid, sk);\n\tdp->dccps_hc_tx_ccid = NULL;\n}\nEXPORT_SYMBOL_GPL(dccp_destruct_common);\n\nstatic void dccp_sk_destruct(struct sock *sk)\n{\n\tdccp_destruct_common(sk);\n\tinet_sock_destruct(sk);\n}\n\nint dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tpr_warn_once(\"DCCP is deprecated and scheduled to be removed in 2025, \"\n\t\t     \"please contact the netdev mailing list\\n\");\n\n\ticsk->icsk_rto\t\t= DCCP_TIMEOUT_INIT;\n\ticsk->icsk_syn_retries\t= sysctl_dccp_request_retries;\n\tsk->sk_state\t\t= DCCP_CLOSED;\n\tsk->sk_write_space\t= dccp_write_space;\n\tsk->sk_destruct\t\t= dccp_sk_destruct;\n\ticsk->icsk_sync_mss\t= dccp_sync_mss;\n\tdp->dccps_mss_cache\t= 536;\n\tdp->dccps_rate_last\t= jiffies;\n\tdp->dccps_role\t\t= DCCP_ROLE_UNDEFINED;\n\tdp->dccps_service\t= DCCP_SERVICE_CODE_IS_ABSENT;\n\tdp->dccps_tx_qlen\t= sysctl_dccp_tx_qlen;\n\n\tdccp_init_xmit_timers(sk);\n\n\tINIT_LIST_HEAD(&dp->dccps_featneg);\n\t \n\tif (likely(ctl_sock_initialized))\n\t\treturn dccp_feat_init(sk);\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(dccp_init_sock);\n\nvoid dccp_destroy_sock(struct sock *sk)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tif (sk->sk_send_head != NULL) {\n\t\tkfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\n\t \n\tif (inet_csk(sk)->icsk_bind_hash != NULL)\n\t\tinet_put_port(sk);\n\n\tkfree(dp->dccps_service_list);\n\tdp->dccps_service_list = NULL;\n\n\tif (dp->dccps_hc_rx_ackvec != NULL) {\n\t\tdccp_ackvec_free(dp->dccps_hc_rx_ackvec);\n\t\tdp->dccps_hc_rx_ackvec = NULL;\n\t}\n\tccid_hc_rx_delete(dp->dccps_hc_rx_ccid, sk);\n\tdp->dccps_hc_rx_ccid = NULL;\n\n\t \n\tdccp_feat_list_purge(&dp->dccps_featneg);\n}\n\nEXPORT_SYMBOL_GPL(dccp_destroy_sock);\n\nstatic inline int dccp_need_reset(int state)\n{\n\treturn state != DCCP_CLOSED && state != DCCP_LISTEN &&\n\t       state != DCCP_REQUESTING;\n}\n\nint dccp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tconst int old_state = sk->sk_state;\n\n\tif (old_state != DCCP_CLOSED)\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\n\t \n\tif (old_state == DCCP_LISTEN) {\n\t\tinet_csk_listen_stop(sk);\n\t} else if (dccp_need_reset(old_state)) {\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\n\t\tsk->sk_err = ECONNRESET;\n\t} else if (old_state == DCCP_REQUESTING)\n\t\tsk->sk_err = ECONNRESET;\n\n\tdccp_clear_xmit_timers(sk);\n\tccid_hc_rx_delete(dp->dccps_hc_rx_ccid, sk);\n\tdp->dccps_hc_rx_ccid = NULL;\n\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tif (sk->sk_send_head != NULL) {\n\t\t__kfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\n\tinet->inet_dport = 0;\n\n\tinet_bhash2_reset_saddr(sk);\n\n\tsk->sk_shutdown = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\n\ticsk->icsk_backoff = 0;\n\tinet_csk_delack_init(sk);\n\t__sk_dst_reset(sk);\n\n\tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\n\n\tsk_error_report(sk);\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(dccp_disconnect);\n\n \n__poll_t dccp_poll(struct file *file, struct socket *sock,\n\t\t       poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\t__poll_t mask;\n\tu8 shutdown;\n\tint state;\n\n\tsock_poll_wait(file, sock, wait);\n\n\tstate = inet_sk_state_load(sk);\n\tif (state == DCCP_LISTEN)\n\t\treturn inet_csk_listen_poll(sk);\n\n\t \n\n\tmask = 0;\n\tif (READ_ONCE(sk->sk_err))\n\t\tmask = EPOLLERR;\n\tshutdown = READ_ONCE(sk->sk_shutdown);\n\n\tif (shutdown == SHUTDOWN_MASK || state == DCCP_CLOSED)\n\t\tmask |= EPOLLHUP;\n\tif (shutdown & RCV_SHUTDOWN)\n\t\tmask |= EPOLLIN | EPOLLRDNORM | EPOLLRDHUP;\n\n\t \n\tif ((1 << state) & ~(DCCPF_REQUESTING | DCCPF_RESPOND)) {\n\t\tif (atomic_read(&sk->sk_rmem_alloc) > 0)\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\t\tif (!(shutdown & SEND_SHUTDOWN)) {\n\t\t\tif (sk_stream_is_writeable(sk)) {\n\t\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t\t\t} else {   \n\t\t\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\t\t\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\n\t\t\t\t \n\t\t\t\tif (sk_stream_is_writeable(sk))\n\t\t\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t\t\t}\n\t\t}\n\t}\n\treturn mask;\n}\nEXPORT_SYMBOL_GPL(dccp_poll);\n\nint dccp_ioctl(struct sock *sk, int cmd, int *karg)\n{\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == DCCP_LISTEN)\n\t\tgoto out;\n\n\tswitch (cmd) {\n\tcase SIOCOUTQ: {\n\t\t*karg = sk_wmem_alloc_get(sk);\n\t\t \n\n\t\trc = 0;\n\t}\n\t\tbreak;\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\t*karg = 0;\n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb != NULL) {\n\t\t\t \n\t\t\t*karg = skb->len;\n\t\t}\n\t\trc = 0;\n\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nEXPORT_SYMBOL_GPL(dccp_ioctl);\n\nstatic int dccp_setsockopt_service(struct sock *sk, const __be32 service,\n\t\t\t\t   sockptr_t optval, unsigned int optlen)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_service_list *sl = NULL;\n\n\tif (service == DCCP_SERVICE_INVALID_VALUE ||\n\t    optlen > DCCP_SERVICE_LIST_MAX_LEN * sizeof(u32))\n\t\treturn -EINVAL;\n\n\tif (optlen > sizeof(service)) {\n\t\tsl = kmalloc(optlen, GFP_KERNEL);\n\t\tif (sl == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tsl->dccpsl_nr = optlen / sizeof(u32) - 1;\n\t\tif (copy_from_sockptr_offset(sl->dccpsl_list, optval,\n\t\t\t\tsizeof(service), optlen - sizeof(service)) ||\n\t\t    dccp_list_has_service(sl, DCCP_SERVICE_INVALID_VALUE)) {\n\t\t\tkfree(sl);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\tdp->dccps_service = service;\n\n\tkfree(dp->dccps_service_list);\n\n\tdp->dccps_service_list = sl;\n\trelease_sock(sk);\n\treturn 0;\n}\n\nstatic int dccp_setsockopt_cscov(struct sock *sk, int cscov, bool rx)\n{\n\tu8 *list, len;\n\tint i, rc;\n\n\tif (cscov < 0 || cscov > 15)\n\t\treturn -EINVAL;\n\t \n\tif (cscov == 0)\n\t\treturn 0;\n\tlen = 16 - cscov;\n\n\tlist = kmalloc(len, GFP_KERNEL);\n\tif (list == NULL)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < len; i++)\n\t\tlist[i] = cscov++;\n\n\trc = dccp_feat_register_sp(sk, DCCPF_MIN_CSUM_COVER, rx, list, len);\n\n\tif (rc == 0) {\n\t\tif (rx)\n\t\t\tdccp_sk(sk)->dccps_pcrlen = cscov;\n\t\telse\n\t\t\tdccp_sk(sk)->dccps_pcslen = cscov;\n\t}\n\tkfree(list);\n\treturn rc;\n}\n\nstatic int dccp_setsockopt_ccid(struct sock *sk, int type,\n\t\t\t\tsockptr_t optval, unsigned int optlen)\n{\n\tu8 *val;\n\tint rc = 0;\n\n\tif (optlen < 1 || optlen > DCCP_FEAT_MAX_SP_VALS)\n\t\treturn -EINVAL;\n\n\tval = memdup_sockptr(optval, optlen);\n\tif (IS_ERR(val))\n\t\treturn PTR_ERR(val);\n\n\tlock_sock(sk);\n\tif (type == DCCP_SOCKOPT_TX_CCID || type == DCCP_SOCKOPT_CCID)\n\t\trc = dccp_feat_register_sp(sk, DCCPF_CCID, 1, val, optlen);\n\n\tif (!rc && (type == DCCP_SOCKOPT_RX_CCID || type == DCCP_SOCKOPT_CCID))\n\t\trc = dccp_feat_register_sp(sk, DCCPF_CCID, 0, val, optlen);\n\trelease_sock(sk);\n\n\tkfree(val);\n\treturn rc;\n}\n\nstatic int do_dccp_setsockopt(struct sock *sk, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tint val, err = 0;\n\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_PACKET_SIZE:\n\t\tDCCP_WARN(\"sockopt(PACKET_SIZE) is deprecated: fix your app\\n\");\n\t\treturn 0;\n\tcase DCCP_SOCKOPT_CHANGE_L:\n\tcase DCCP_SOCKOPT_CHANGE_R:\n\t\tDCCP_WARN(\"sockopt(CHANGE_L/R) is deprecated: fix your app\\n\");\n\t\treturn 0;\n\tcase DCCP_SOCKOPT_CCID:\n\tcase DCCP_SOCKOPT_RX_CCID:\n\tcase DCCP_SOCKOPT_TX_CCID:\n\t\treturn dccp_setsockopt_ccid(sk, optname, optval, optlen);\n\t}\n\n\tif (optlen < (int)sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&val, optval, sizeof(int)))\n\t\treturn -EFAULT;\n\n\tif (optname == DCCP_SOCKOPT_SERVICE)\n\t\treturn dccp_setsockopt_service(sk, val, optval, optlen);\n\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_SERVER_TIMEWAIT:\n\t\tif (dp->dccps_role != DCCP_ROLE_SERVER)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\tdp->dccps_server_timewait = (val != 0);\n\t\tbreak;\n\tcase DCCP_SOCKOPT_SEND_CSCOV:\n\t\terr = dccp_setsockopt_cscov(sk, val, false);\n\t\tbreak;\n\tcase DCCP_SOCKOPT_RECV_CSCOV:\n\t\terr = dccp_setsockopt_cscov(sk, val, true);\n\t\tbreak;\n\tcase DCCP_SOCKOPT_QPOLICY_ID:\n\t\tif (sk->sk_state != DCCP_CLOSED)\n\t\t\terr = -EISCONN;\n\t\telse if (val < 0 || val >= DCCPQ_POLICY_MAX)\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\tdp->dccps_qpolicy = val;\n\t\tbreak;\n\tcase DCCP_SOCKOPT_QPOLICY_TXQLEN:\n\t\tif (val < 0)\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\tdp->dccps_tx_qlen = val;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nint dccp_setsockopt(struct sock *sk, int level, int optname, sockptr_t optval,\n\t\t    unsigned int optlen)\n{\n\tif (level != SOL_DCCP)\n\t\treturn inet_csk(sk)->icsk_af_ops->setsockopt(sk, level,\n\t\t\t\t\t\t\t     optname, optval,\n\t\t\t\t\t\t\t     optlen);\n\treturn do_dccp_setsockopt(sk, level, optname, optval, optlen);\n}\n\nEXPORT_SYMBOL_GPL(dccp_setsockopt);\n\nstatic int dccp_getsockopt_service(struct sock *sk, int len,\n\t\t\t\t   __be32 __user *optval,\n\t\t\t\t   int __user *optlen)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\tconst struct dccp_service_list *sl;\n\tint err = -ENOENT, slen = 0, total_len = sizeof(u32);\n\n\tlock_sock(sk);\n\tif ((sl = dp->dccps_service_list) != NULL) {\n\t\tslen = sl->dccpsl_nr * sizeof(u32);\n\t\ttotal_len += slen;\n\t}\n\n\terr = -EINVAL;\n\tif (total_len > len)\n\t\tgoto out;\n\n\terr = 0;\n\tif (put_user(total_len, optlen) ||\n\t    put_user(dp->dccps_service, optval) ||\n\t    (sl != NULL && copy_to_user(optval + 1, sl->dccpsl_list, slen)))\n\t\terr = -EFAULT;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int do_dccp_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct dccp_sock *dp;\n\tint val, len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < (int)sizeof(int))\n\t\treturn -EINVAL;\n\n\tdp = dccp_sk(sk);\n\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_PACKET_SIZE:\n\t\tDCCP_WARN(\"sockopt(PACKET_SIZE) is deprecated: fix your app\\n\");\n\t\treturn 0;\n\tcase DCCP_SOCKOPT_SERVICE:\n\t\treturn dccp_getsockopt_service(sk, len,\n\t\t\t\t\t       (__be32 __user *)optval, optlen);\n\tcase DCCP_SOCKOPT_GET_CUR_MPS:\n\t\tval = READ_ONCE(dp->dccps_mss_cache);\n\t\tbreak;\n\tcase DCCP_SOCKOPT_AVAILABLE_CCIDS:\n\t\treturn ccid_getsockopt_builtin_ccids(sk, len, optval, optlen);\n\tcase DCCP_SOCKOPT_TX_CCID:\n\t\tval = ccid_get_current_tx_ccid(dp);\n\t\tif (val < 0)\n\t\t\treturn -ENOPROTOOPT;\n\t\tbreak;\n\tcase DCCP_SOCKOPT_RX_CCID:\n\t\tval = ccid_get_current_rx_ccid(dp);\n\t\tif (val < 0)\n\t\t\treturn -ENOPROTOOPT;\n\t\tbreak;\n\tcase DCCP_SOCKOPT_SERVER_TIMEWAIT:\n\t\tval = dp->dccps_server_timewait;\n\t\tbreak;\n\tcase DCCP_SOCKOPT_SEND_CSCOV:\n\t\tval = dp->dccps_pcslen;\n\t\tbreak;\n\tcase DCCP_SOCKOPT_RECV_CSCOV:\n\t\tval = dp->dccps_pcrlen;\n\t\tbreak;\n\tcase DCCP_SOCKOPT_QPOLICY_ID:\n\t\tval = dp->dccps_qpolicy;\n\t\tbreak;\n\tcase DCCP_SOCKOPT_QPOLICY_TXQLEN:\n\t\tval = dp->dccps_tx_qlen;\n\t\tbreak;\n\tcase 128 ... 191:\n\t\treturn ccid_hc_rx_getsockopt(dp->dccps_hc_rx_ccid, sk, optname,\n\t\t\t\t\t     len, (u32 __user *)optval, optlen);\n\tcase 192 ... 255:\n\t\treturn ccid_hc_tx_getsockopt(dp->dccps_hc_tx_ccid, sk, optname,\n\t\t\t\t\t     len, (u32 __user *)optval, optlen);\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = sizeof(val);\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nint dccp_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tif (level != SOL_DCCP)\n\t\treturn inet_csk(sk)->icsk_af_ops->getsockopt(sk, level,\n\t\t\t\t\t\t\t     optname, optval,\n\t\t\t\t\t\t\t     optlen);\n\treturn do_dccp_getsockopt(sk, level, optname, optval, optlen);\n}\n\nEXPORT_SYMBOL_GPL(dccp_getsockopt);\n\nstatic int dccp_msghdr_parse(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct cmsghdr *cmsg;\n\n\t \n\tskb->priority = 0;\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\treturn -EINVAL;\n\n\t\tif (cmsg->cmsg_level != SOL_DCCP)\n\t\t\tcontinue;\n\n\t\tif (cmsg->cmsg_type <= DCCP_SCM_QPOLICY_MAX &&\n\t\t    !dccp_qpolicy_param_ok(skb->sk, cmsg->cmsg_type))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase DCCP_SCM_PRIORITY:\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(__u32)))\n\t\t\t\treturn -EINVAL;\n\t\t\tskb->priority = *(__u32 *)CMSG_DATA(cmsg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dccp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\tconst int flags = msg->msg_flags;\n\tconst int noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb;\n\tint rc, size;\n\tlong timeo;\n\n\ttrace_dccp_probe(sk, len);\n\n\tif (len > READ_ONCE(dp->dccps_mss_cache))\n\t\treturn -EMSGSIZE;\n\n\tlock_sock(sk);\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\n\t \n\t \n\tif ((1 << sk->sk_state) & ~(DCCPF_OPEN | DCCPF_PARTOPEN))\n\t\tif ((rc = sk_stream_wait_connect(sk, &timeo)) != 0)\n\t\t\tgoto out_release;\n\n\tsize = sk->sk_prot->max_header + len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (skb == NULL)\n\t\tgoto out_release;\n\n\tif (dccp_qpolicy_full(sk)) {\n\t\trc = -EAGAIN;\n\t\tgoto out_discard;\n\t}\n\n\tif (sk->sk_state == DCCP_CLOSED) {\n\t\trc = -ENOTCONN;\n\t\tgoto out_discard;\n\t}\n\n\t \n\tif (len > dp->dccps_mss_cache) {\n\t\trc = -EMSGSIZE;\n\t\tgoto out_discard;\n\t}\n\n\tskb_reserve(skb, sk->sk_prot->max_header);\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\n\trc = dccp_msghdr_parse(msg, skb);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\n\tdccp_qpolicy_push(sk, skb);\n\t \n\tif (!timer_pending(&dp->dccps_xmit_timer))\n\t\tdccp_write_xmit(sk);\nout_release:\n\trelease_sock(sk);\n\treturn rc ? : len;\nout_discard:\n\tkfree_skb(skb);\n\tgoto out_release;\n}\n\nEXPORT_SYMBOL_GPL(dccp_sendmsg);\n\nint dccp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int flags,\n\t\t int *addr_len)\n{\n\tconst struct dccp_hdr *dh;\n\tlong timeo;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tlen = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\tdo {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\n\t\tif (skb == NULL)\n\t\t\tgoto verify_sock_status;\n\n\t\tdh = dccp_hdr(skb);\n\n\t\tswitch (dh->dccph_type) {\n\t\tcase DCCP_PKT_DATA:\n\t\tcase DCCP_PKT_DATAACK:\n\t\t\tgoto found_ok_skb;\n\n\t\tcase DCCP_PKT_CLOSE:\n\t\tcase DCCP_PKT_CLOSEREQ:\n\t\t\tif (!(flags & MSG_PEEK))\n\t\t\t\tdccp_finish_passive_close(sk);\n\t\t\tfallthrough;\n\t\tcase DCCP_PKT_RESET:\n\t\t\tdccp_pr_debug(\"found fin (%s) ok!\\n\",\n\t\t\t\t      dccp_packet_name(dh->dccph_type));\n\t\t\tlen = 0;\n\t\t\tgoto found_fin_ok;\n\t\tdefault:\n\t\t\tdccp_pr_debug(\"packet_type=%s\\n\",\n\t\t\t\t      dccp_packet_name(dh->dccph_type));\n\t\t\tsk_eat_skb(sk, skb);\n\t\t}\nverify_sock_status:\n\t\tif (sock_flag(sk, SOCK_DONE)) {\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_err) {\n\t\t\tlen = sock_error(sk);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_state == DCCP_CLOSED) {\n\t\t\tif (!sock_flag(sk, SOCK_DONE)) {\n\t\t\t\t \n\t\t\t\tlen = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!timeo) {\n\t\t\tlen = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tlen = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\tsk_wait_data(sk, &timeo, NULL);\n\t\tcontinue;\n\tfound_ok_skb:\n\t\tif (len > skb->len)\n\t\t\tlen = skb->len;\n\t\telse if (len < skb->len)\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\t\tif (skb_copy_datagram_msg(skb, 0, msg, len)) {\n\t\t\t \n\t\t\tlen = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & MSG_TRUNC)\n\t\t\tlen = skb->len;\n\tfound_fin_ok:\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tsk_eat_skb(sk, skb);\n\t\tbreak;\n\t} while (1);\nout:\n\trelease_sock(sk);\n\treturn len;\n}\n\nEXPORT_SYMBOL_GPL(dccp_recvmsg);\n\nint inet_dccp_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tunsigned char old_state;\n\tint err;\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (sock->state != SS_UNCONNECTED || sock->type != SOCK_DCCP)\n\t\tgoto out;\n\n\told_state = sk->sk_state;\n\tif (!((1 << old_state) & (DCCPF_CLOSED | DCCPF_LISTEN)))\n\t\tgoto out;\n\n\tWRITE_ONCE(sk->sk_max_ack_backlog, backlog);\n\t \n\tif (old_state != DCCP_LISTEN) {\n\t\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\t\tdp->dccps_role = DCCP_ROLE_LISTEN;\n\n\t\t \n\t\tif (dccp_feat_finalise_settings(dp)) {\n\t\t\terr = -EPROTO;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = inet_csk_listen_start(sk);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = 0;\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nEXPORT_SYMBOL_GPL(inet_dccp_listen);\n\nstatic void dccp_terminate_connection(struct sock *sk)\n{\n\tu8 next_state = DCCP_CLOSED;\n\n\tswitch (sk->sk_state) {\n\tcase DCCP_PASSIVE_CLOSE:\n\tcase DCCP_PASSIVE_CLOSEREQ:\n\t\tdccp_finish_passive_close(sk);\n\t\tbreak;\n\tcase DCCP_PARTOPEN:\n\t\tdccp_pr_debug(\"Stop PARTOPEN timer (%p)\\n\", sk);\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n\t\tfallthrough;\n\tcase DCCP_OPEN:\n\t\tdccp_send_close(sk, 1);\n\n\t\tif (dccp_sk(sk)->dccps_role == DCCP_ROLE_SERVER &&\n\t\t    !dccp_sk(sk)->dccps_server_timewait)\n\t\t\tnext_state = DCCP_ACTIVE_CLOSEREQ;\n\t\telse\n\t\t\tnext_state = DCCP_CLOSING;\n\t\tfallthrough;\n\tdefault:\n\t\tdccp_set_state(sk, next_state);\n\t}\n}\n\nvoid dccp_close(struct sock *sk, long timeout)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct sk_buff *skb;\n\tu32 data_was_unread = 0;\n\tint state;\n\n\tlock_sock(sk);\n\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\n\t\t \n\t\tinet_csk_listen_stop(sk);\n\n\t\tgoto adjudge_to_death;\n\t}\n\n\tsk_stop_timer(sk, &dp->dccps_xmit_timer);\n\n\t \n\twhile ((skb = __skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tdata_was_unread += skb->len;\n\t\t__kfree_skb(skb);\n\t}\n\n\t \n\tif (sk->sk_state == DCCP_CLOSED)\n\t\tgoto adjudge_to_death;\n\n\tif (data_was_unread) {\n\t\t \n\t\tDCCP_WARN(\"ABORT with %u bytes unread\\n\", data_was_unread);\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\t} else if (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime) {\n\t\t \n\t\tsk->sk_prot->disconnect(sk, 0);\n\t} else if (sk->sk_state != DCCP_CLOSED) {\n\t\t \n\t\tdccp_flush_write_queue(sk, &timeout);\n\t\tdccp_terminate_connection(sk);\n\t}\n\n\t \n\t__skb_queue_purge(&sk->sk_write_queue);\n\n\tsk_stream_wait_close(sk, timeout);\n\nadjudge_to_death:\n\tstate = sk->sk_state;\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\n\t \n\trelease_sock(sk);\n\t \n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\tWARN_ON(sock_owned_by_user(sk));\n\n\tthis_cpu_inc(dccp_orphan_count);\n\n\t \n\tif (state != DCCP_CLOSED && sk->sk_state == DCCP_CLOSED)\n\t\tgoto out;\n\n\tif (sk->sk_state == DCCP_CLOSED)\n\t\tinet_csk_destroy_sock(sk);\n\n\t \n\nout:\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\tsock_put(sk);\n}\n\nEXPORT_SYMBOL_GPL(dccp_close);\n\nvoid dccp_shutdown(struct sock *sk, int how)\n{\n\tdccp_pr_debug(\"called shutdown(%x)\\n\", how);\n}\n\nEXPORT_SYMBOL_GPL(dccp_shutdown);\n\nstatic inline int __init dccp_mib_init(void)\n{\n\tdccp_statistics = alloc_percpu(struct dccp_mib);\n\tif (!dccp_statistics)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void dccp_mib_exit(void)\n{\n\tfree_percpu(dccp_statistics);\n}\n\nstatic int thash_entries;\nmodule_param(thash_entries, int, 0444);\nMODULE_PARM_DESC(thash_entries, \"Number of ehash buckets\");\n\n#ifdef CONFIG_IP_DCCP_DEBUG\nbool dccp_debug;\nmodule_param(dccp_debug, bool, 0644);\nMODULE_PARM_DESC(dccp_debug, \"Enable debug messages\");\n\nEXPORT_SYMBOL_GPL(dccp_debug);\n#endif\n\nstatic int __init dccp_init(void)\n{\n\tunsigned long goal;\n\tunsigned long nr_pages = totalram_pages();\n\tint ehash_order, bhash_order, i;\n\tint rc;\n\n\tBUILD_BUG_ON(sizeof(struct dccp_skb_cb) >\n\t\t     sizeof_field(struct sk_buff, cb));\n\trc = inet_hashinfo2_init_mod(&dccp_hashinfo);\n\tif (rc)\n\t\tgoto out_fail;\n\trc = -ENOBUFS;\n\tdccp_hashinfo.bind_bucket_cachep =\n\t\tkmem_cache_create(\"dccp_bind_bucket\",\n\t\t\t\t  sizeof(struct inet_bind_bucket), 0,\n\t\t\t\t  SLAB_HWCACHE_ALIGN | SLAB_ACCOUNT, NULL);\n\tif (!dccp_hashinfo.bind_bucket_cachep)\n\t\tgoto out_free_hashinfo2;\n\tdccp_hashinfo.bind2_bucket_cachep =\n\t\tkmem_cache_create(\"dccp_bind2_bucket\",\n\t\t\t\t  sizeof(struct inet_bind2_bucket), 0,\n\t\t\t\t  SLAB_HWCACHE_ALIGN | SLAB_ACCOUNT, NULL);\n\tif (!dccp_hashinfo.bind2_bucket_cachep)\n\t\tgoto out_free_bind_bucket_cachep;\n\n\t \n\tif (nr_pages >= (128 * 1024))\n\t\tgoal = nr_pages >> (21 - PAGE_SHIFT);\n\telse\n\t\tgoal = nr_pages >> (23 - PAGE_SHIFT);\n\n\tif (thash_entries)\n\t\tgoal = (thash_entries *\n\t\t\tsizeof(struct inet_ehash_bucket)) >> PAGE_SHIFT;\n\tfor (ehash_order = 0; (1UL << ehash_order) < goal; ehash_order++)\n\t\t;\n\tdo {\n\t\tunsigned long hash_size = (1UL << ehash_order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct inet_ehash_bucket);\n\n\t\twhile (hash_size & (hash_size - 1))\n\t\t\thash_size--;\n\t\tdccp_hashinfo.ehash_mask = hash_size - 1;\n\t\tdccp_hashinfo.ehash = (struct inet_ehash_bucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, ehash_order);\n\t} while (!dccp_hashinfo.ehash && --ehash_order > 0);\n\n\tif (!dccp_hashinfo.ehash) {\n\t\tDCCP_CRIT(\"Failed to allocate DCCP established hash table\");\n\t\tgoto out_free_bind2_bucket_cachep;\n\t}\n\n\tfor (i = 0; i <= dccp_hashinfo.ehash_mask; i++)\n\t\tINIT_HLIST_NULLS_HEAD(&dccp_hashinfo.ehash[i].chain, i);\n\n\tif (inet_ehash_locks_alloc(&dccp_hashinfo))\n\t\t\tgoto out_free_dccp_ehash;\n\n\tbhash_order = ehash_order;\n\n\tdo {\n\t\tdccp_hashinfo.bhash_size = (1UL << bhash_order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct inet_bind_hashbucket);\n\t\tif ((dccp_hashinfo.bhash_size > (64 * 1024)) &&\n\t\t    bhash_order > 0)\n\t\t\tcontinue;\n\t\tdccp_hashinfo.bhash = (struct inet_bind_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, bhash_order);\n\t} while (!dccp_hashinfo.bhash && --bhash_order >= 0);\n\n\tif (!dccp_hashinfo.bhash) {\n\t\tDCCP_CRIT(\"Failed to allocate DCCP bind hash table\");\n\t\tgoto out_free_dccp_locks;\n\t}\n\n\tdccp_hashinfo.bhash2 = (struct inet_bind_hashbucket *)\n\t\t__get_free_pages(GFP_ATOMIC | __GFP_NOWARN, bhash_order);\n\n\tif (!dccp_hashinfo.bhash2) {\n\t\tDCCP_CRIT(\"Failed to allocate DCCP bind2 hash table\");\n\t\tgoto out_free_dccp_bhash;\n\t}\n\n\tfor (i = 0; i < dccp_hashinfo.bhash_size; i++) {\n\t\tspin_lock_init(&dccp_hashinfo.bhash[i].lock);\n\t\tINIT_HLIST_HEAD(&dccp_hashinfo.bhash[i].chain);\n\t\tspin_lock_init(&dccp_hashinfo.bhash2[i].lock);\n\t\tINIT_HLIST_HEAD(&dccp_hashinfo.bhash2[i].chain);\n\t}\n\n\tdccp_hashinfo.pernet = false;\n\n\trc = dccp_mib_init();\n\tif (rc)\n\t\tgoto out_free_dccp_bhash2;\n\n\trc = dccp_ackvec_init();\n\tif (rc)\n\t\tgoto out_free_dccp_mib;\n\n\trc = dccp_sysctl_init();\n\tif (rc)\n\t\tgoto out_ackvec_exit;\n\n\trc = ccid_initialize_builtins();\n\tif (rc)\n\t\tgoto out_sysctl_exit;\n\n\tdccp_timestamping_init();\n\n\treturn 0;\n\nout_sysctl_exit:\n\tdccp_sysctl_exit();\nout_ackvec_exit:\n\tdccp_ackvec_exit();\nout_free_dccp_mib:\n\tdccp_mib_exit();\nout_free_dccp_bhash2:\n\tfree_pages((unsigned long)dccp_hashinfo.bhash2, bhash_order);\nout_free_dccp_bhash:\n\tfree_pages((unsigned long)dccp_hashinfo.bhash, bhash_order);\nout_free_dccp_locks:\n\tinet_ehash_locks_free(&dccp_hashinfo);\nout_free_dccp_ehash:\n\tfree_pages((unsigned long)dccp_hashinfo.ehash, ehash_order);\nout_free_bind2_bucket_cachep:\n\tkmem_cache_destroy(dccp_hashinfo.bind2_bucket_cachep);\nout_free_bind_bucket_cachep:\n\tkmem_cache_destroy(dccp_hashinfo.bind_bucket_cachep);\nout_free_hashinfo2:\n\tinet_hashinfo2_free_mod(&dccp_hashinfo);\nout_fail:\n\tdccp_hashinfo.bhash = NULL;\n\tdccp_hashinfo.bhash2 = NULL;\n\tdccp_hashinfo.ehash = NULL;\n\tdccp_hashinfo.bind_bucket_cachep = NULL;\n\tdccp_hashinfo.bind2_bucket_cachep = NULL;\n\treturn rc;\n}\n\nstatic void __exit dccp_fini(void)\n{\n\tint bhash_order = get_order(dccp_hashinfo.bhash_size *\n\t\t\t\t    sizeof(struct inet_bind_hashbucket));\n\n\tccid_cleanup_builtins();\n\tdccp_mib_exit();\n\tfree_pages((unsigned long)dccp_hashinfo.bhash, bhash_order);\n\tfree_pages((unsigned long)dccp_hashinfo.bhash2, bhash_order);\n\tfree_pages((unsigned long)dccp_hashinfo.ehash,\n\t\t   get_order((dccp_hashinfo.ehash_mask + 1) *\n\t\t\t     sizeof(struct inet_ehash_bucket)));\n\tinet_ehash_locks_free(&dccp_hashinfo);\n\tkmem_cache_destroy(dccp_hashinfo.bind_bucket_cachep);\n\tdccp_ackvec_exit();\n\tdccp_sysctl_exit();\n\tinet_hashinfo2_free_mod(&dccp_hashinfo);\n}\n\nmodule_init(dccp_init);\nmodule_exit(dccp_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arnaldo Carvalho de Melo <acme@conectiva.com.br>\");\nMODULE_DESCRIPTION(\"DCCP - Datagram Congestion Controlled Protocol\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}