{
  "module_name": "ackvec.c",
  "hash_id": "4c14df2262264d8dc02a0ad368a6b637694da7dfc99d668dc40653ae5e1b69b4",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/ackvec.c",
  "human_readable_source": "\n \n#include \"dccp.h\"\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *dccp_ackvec_slab;\nstatic struct kmem_cache *dccp_ackvec_record_slab;\n\nstruct dccp_ackvec *dccp_ackvec_alloc(const gfp_t priority)\n{\n\tstruct dccp_ackvec *av = kmem_cache_zalloc(dccp_ackvec_slab, priority);\n\n\tif (av != NULL) {\n\t\tav->av_buf_head\t= av->av_buf_tail = DCCPAV_MAX_ACKVEC_LEN - 1;\n\t\tINIT_LIST_HEAD(&av->av_records);\n\t}\n\treturn av;\n}\n\nstatic void dccp_ackvec_purge_records(struct dccp_ackvec *av)\n{\n\tstruct dccp_ackvec_record *cur, *next;\n\n\tlist_for_each_entry_safe(cur, next, &av->av_records, avr_node)\n\t\tkmem_cache_free(dccp_ackvec_record_slab, cur);\n\tINIT_LIST_HEAD(&av->av_records);\n}\n\nvoid dccp_ackvec_free(struct dccp_ackvec *av)\n{\n\tif (likely(av != NULL)) {\n\t\tdccp_ackvec_purge_records(av);\n\t\tkmem_cache_free(dccp_ackvec_slab, av);\n\t}\n}\n\n \nint dccp_ackvec_update_records(struct dccp_ackvec *av, u64 seqno, u8 nonce_sum)\n{\n\tstruct dccp_ackvec_record *avr;\n\n\tavr = kmem_cache_alloc(dccp_ackvec_record_slab, GFP_ATOMIC);\n\tif (avr == NULL)\n\t\treturn -ENOBUFS;\n\n\tavr->avr_ack_seqno  = seqno;\n\tavr->avr_ack_ptr    = av->av_buf_head;\n\tavr->avr_ack_ackno  = av->av_buf_ackno;\n\tavr->avr_ack_nonce  = nonce_sum;\n\tavr->avr_ack_runlen = dccp_ackvec_runlen(av->av_buf + av->av_buf_head);\n\t \n\tif (av->av_overflow)\n\t\tdccp_ackvec_purge_records(av);\n\t \n\tlist_add(&avr->avr_node, &av->av_records);\n\n\tdccp_pr_debug(\"Added Vector, ack_seqno=%llu, ack_ackno=%llu (rl=%u)\\n\",\n\t\t      (unsigned long long)avr->avr_ack_seqno,\n\t\t      (unsigned long long)avr->avr_ack_ackno,\n\t\t      avr->avr_ack_runlen);\n\treturn 0;\n}\n\nstatic struct dccp_ackvec_record *dccp_ackvec_lookup(struct list_head *av_list,\n\t\t\t\t\t\t     const u64 ackno)\n{\n\tstruct dccp_ackvec_record *avr;\n\t \n\tlist_for_each_entry_reverse(avr, av_list, avr_node) {\n\t\tif (avr->avr_ack_seqno == ackno)\n\t\t\treturn avr;\n\t\tif (before48(ackno, avr->avr_ack_seqno))\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n \nstatic inline u16 __ackvec_idx_add(const u16 a, const u16 b)\n{\n\treturn (a + b) % DCCPAV_MAX_ACKVEC_LEN;\n}\n\nstatic inline u16 __ackvec_idx_sub(const u16 a, const u16 b)\n{\n\treturn __ackvec_idx_add(a, DCCPAV_MAX_ACKVEC_LEN - b);\n}\n\nu16 dccp_ackvec_buflen(const struct dccp_ackvec *av)\n{\n\tif (unlikely(av->av_overflow))\n\t\treturn DCCPAV_MAX_ACKVEC_LEN;\n\treturn __ackvec_idx_sub(av->av_buf_tail, av->av_buf_head);\n}\n\n \nstatic void dccp_ackvec_update_old(struct dccp_ackvec *av, s64 distance,\n\t\t\t\t   u64 seqno, enum dccp_ackvec_states state)\n{\n\tu16 ptr = av->av_buf_head;\n\n\tBUG_ON(distance > 0);\n\tif (unlikely(dccp_ackvec_is_empty(av)))\n\t\treturn;\n\n\tdo {\n\t\tu8 runlen = dccp_ackvec_runlen(av->av_buf + ptr);\n\n\t\tif (distance + runlen >= 0) {\n\t\t\t \n\t\t\tif (av->av_buf[ptr] == DCCPAV_NOT_RECEIVED)\n\t\t\t\tav->av_buf[ptr] = state;\n\t\t\telse\n\t\t\t\tdccp_pr_debug(\"Not changing %llu state to %u\\n\",\n\t\t\t\t\t      (unsigned long long)seqno, state);\n\t\t\tbreak;\n\t\t}\n\n\t\tdistance += runlen + 1;\n\t\tptr\t  = __ackvec_idx_add(ptr, 1);\n\n\t} while (ptr != av->av_buf_tail);\n}\n\n \nstatic void dccp_ackvec_reserve_seats(struct dccp_ackvec *av, u16 num)\n{\n\tu16 start = __ackvec_idx_add(av->av_buf_head, 1),\n\t    len\t  = DCCPAV_MAX_ACKVEC_LEN - start;\n\n\t \n\tif (num > len) {\n\t\tmemset(av->av_buf + start, DCCPAV_NOT_RECEIVED, len);\n\t\tstart = 0;\n\t\tnum  -= len;\n\t}\n\tif (num)\n\t\tmemset(av->av_buf + start, DCCPAV_NOT_RECEIVED, num);\n}\n\n \nstatic void dccp_ackvec_add_new(struct dccp_ackvec *av, u32 num_packets,\n\t\t\t\tu64 seqno, enum dccp_ackvec_states state)\n{\n\tu32 num_cells = num_packets;\n\n\tif (num_packets > DCCPAV_BURST_THRESH) {\n\t\tu32 lost_packets = num_packets - 1;\n\n\t\tDCCP_WARN(\"Warning: large burst loss (%u)\\n\", lost_packets);\n\t\t \n\t\tfor (num_packets = num_cells = 1; lost_packets; ++num_cells) {\n\t\t\tu8 len = min_t(u32, lost_packets, DCCPAV_MAX_RUNLEN);\n\n\t\t\tav->av_buf_head = __ackvec_idx_sub(av->av_buf_head, 1);\n\t\t\tav->av_buf[av->av_buf_head] = DCCPAV_NOT_RECEIVED | len;\n\n\t\t\tlost_packets -= len;\n\t\t}\n\t}\n\n\tif (num_cells + dccp_ackvec_buflen(av) >= DCCPAV_MAX_ACKVEC_LEN) {\n\t\tDCCP_CRIT(\"Ack Vector buffer overflow: dropping old entries\");\n\t\tav->av_overflow = true;\n\t}\n\n\tav->av_buf_head = __ackvec_idx_sub(av->av_buf_head, num_packets);\n\tif (av->av_overflow)\n\t\tav->av_buf_tail = av->av_buf_head;\n\n\tav->av_buf[av->av_buf_head] = state;\n\tav->av_buf_ackno\t    = seqno;\n\n\tif (num_packets > 1)\n\t\tdccp_ackvec_reserve_seats(av, num_packets - 1);\n}\n\n \nvoid dccp_ackvec_input(struct dccp_ackvec *av, struct sk_buff *skb)\n{\n\tu64 seqno = DCCP_SKB_CB(skb)->dccpd_seq;\n\tenum dccp_ackvec_states state = DCCPAV_RECEIVED;\n\n\tif (dccp_ackvec_is_empty(av)) {\n\t\tdccp_ackvec_add_new(av, 1, seqno, state);\n\t\tav->av_tail_ackno = seqno;\n\n\t} else {\n\t\ts64 num_packets = dccp_delta_seqno(av->av_buf_ackno, seqno);\n\t\tu8 *current_head = av->av_buf + av->av_buf_head;\n\n\t\tif (num_packets == 1 &&\n\t\t    dccp_ackvec_state(current_head) == state &&\n\t\t    dccp_ackvec_runlen(current_head) < DCCPAV_MAX_RUNLEN) {\n\n\t\t\t*current_head   += 1;\n\t\t\tav->av_buf_ackno = seqno;\n\n\t\t} else if (num_packets > 0) {\n\t\t\tdccp_ackvec_add_new(av, num_packets, seqno, state);\n\t\t} else {\n\t\t\tdccp_ackvec_update_old(av, num_packets, seqno, state);\n\t\t}\n\t}\n}\n\n \nvoid dccp_ackvec_clear_state(struct dccp_ackvec *av, const u64 ackno)\n{\n\tstruct dccp_ackvec_record *avr, *next;\n\tu8 runlen_now, eff_runlen;\n\ts64 delta;\n\n\tavr = dccp_ackvec_lookup(&av->av_records, ackno);\n\tif (avr == NULL)\n\t\treturn;\n\t \n\tdelta = dccp_delta_seqno(av->av_tail_ackno, avr->avr_ack_ackno);\n\tif (delta < 0)\n\t\tgoto free_records;\n\t \n\teff_runlen = delta < avr->avr_ack_runlen ? delta : avr->avr_ack_runlen;\n\n\trunlen_now = dccp_ackvec_runlen(av->av_buf + avr->avr_ack_ptr);\n\t \n\tif (runlen_now > eff_runlen) {\n\n\t\tav->av_buf[avr->avr_ack_ptr] -= eff_runlen + 1;\n\t\tav->av_buf_tail = __ackvec_idx_add(avr->avr_ack_ptr, 1);\n\n\t\t \n\t\tif (av->av_overflow)\n\t\t\tav->av_overflow = (av->av_buf_head == av->av_buf_tail);\n\t} else {\n\t\tav->av_buf_tail\t= avr->avr_ack_ptr;\n\t\t \n\t\tav->av_overflow\t= 0;\n\t}\n\n\t \n\tav->av_tail_ackno = ADD48(avr->avr_ack_ackno, 1);\n\nfree_records:\n\tlist_for_each_entry_safe_from(avr, next, &av->av_records, avr_node) {\n\t\tlist_del(&avr->avr_node);\n\t\tkmem_cache_free(dccp_ackvec_record_slab, avr);\n\t}\n}\n\n \nint dccp_ackvec_parsed_add(struct list_head *head, u8 *vec, u8 len, u8 nonce)\n{\n\tstruct dccp_ackvec_parsed *new = kmalloc(sizeof(*new), GFP_ATOMIC);\n\n\tif (new == NULL)\n\t\treturn -ENOBUFS;\n\tnew->vec   = vec;\n\tnew->len   = len;\n\tnew->nonce = nonce;\n\n\tlist_add_tail(&new->node, head);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dccp_ackvec_parsed_add);\n\nvoid dccp_ackvec_parsed_cleanup(struct list_head *parsed_chunks)\n{\n\tstruct dccp_ackvec_parsed *cur, *next;\n\n\tlist_for_each_entry_safe(cur, next, parsed_chunks, node)\n\t\tkfree(cur);\n\tINIT_LIST_HEAD(parsed_chunks);\n}\nEXPORT_SYMBOL_GPL(dccp_ackvec_parsed_cleanup);\n\nint __init dccp_ackvec_init(void)\n{\n\tdccp_ackvec_slab = kmem_cache_create(\"dccp_ackvec\",\n\t\t\t\t\t     sizeof(struct dccp_ackvec), 0,\n\t\t\t\t\t     SLAB_HWCACHE_ALIGN, NULL);\n\tif (dccp_ackvec_slab == NULL)\n\t\tgoto out_err;\n\n\tdccp_ackvec_record_slab = kmem_cache_create(\"dccp_ackvec_record\",\n\t\t\t\t\t     sizeof(struct dccp_ackvec_record),\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (dccp_ackvec_record_slab == NULL)\n\t\tgoto out_destroy_slab;\n\n\treturn 0;\n\nout_destroy_slab:\n\tkmem_cache_destroy(dccp_ackvec_slab);\n\tdccp_ackvec_slab = NULL;\nout_err:\n\tDCCP_CRIT(\"Unable to create Ack Vector slab cache\");\n\treturn -ENOBUFS;\n}\n\nvoid dccp_ackvec_exit(void)\n{\n\tkmem_cache_destroy(dccp_ackvec_slab);\n\tdccp_ackvec_slab = NULL;\n\tkmem_cache_destroy(dccp_ackvec_record_slab);\n\tdccp_ackvec_record_slab = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}