{
  "module_name": "timer.c",
  "hash_id": "07ad4c61fa666a21cc030f1146d808cf86b6d0363c8845fc825c5ceda7e9742f",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/timer.c",
  "human_readable_source": "\n \n\n#include <linux/dccp.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n\n#include \"dccp.h\"\n\n \nint  sysctl_dccp_request_retries\t__read_mostly = TCP_SYN_RETRIES;\nint  sysctl_dccp_retries1\t\t__read_mostly = TCP_RETR1;\nint  sysctl_dccp_retries2\t\t__read_mostly = TCP_RETR2;\n\nstatic void dccp_write_err(struct sock *sk)\n{\n\tsk->sk_err = READ_ONCE(sk->sk_err_soft) ? : ETIMEDOUT;\n\tsk_error_report(sk);\n\n\tdccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\n\tdccp_done(sk);\n\t__DCCP_INC_STATS(DCCP_MIB_ABORTONTIMEOUT);\n}\n\n \nstatic int dccp_write_timeout(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tint retry_until;\n\n\tif (sk->sk_state == DCCP_REQUESTING || sk->sk_state == DCCP_PARTOPEN) {\n\t\tif (icsk->icsk_retransmits != 0)\n\t\t\tdst_negative_advice(sk);\n\t\tretry_until = icsk->icsk_syn_retries ?\n\t\t\t    : sysctl_dccp_request_retries;\n\t} else {\n\t\tif (icsk->icsk_retransmits >= sysctl_dccp_retries1) {\n\t\t\t \n\n\t\t\tdst_negative_advice(sk);\n\t\t}\n\n\t\tretry_until = sysctl_dccp_retries2;\n\t\t \n\t}\n\n\tif (icsk->icsk_retransmits >= retry_until) {\n\t\t \n\t\tdccp_write_err(sk);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void dccp_retransmit_timer(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t \n\tif (dccp_write_timeout(sk))\n\t\treturn;\n\n\t \n\tif (icsk->icsk_retransmits == 0)\n\t\t__DCCP_INC_STATS(DCCP_MIB_TIMEOUTS);\n\n\tif (dccp_retransmit_skb(sk) != 0) {\n\t\t \n\t\tif (--icsk->icsk_retransmits == 0)\n\t\t\ticsk->icsk_retransmits = 1;\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\n\t\t\t\t\t  min(icsk->icsk_rto,\n\t\t\t\t\t      TCP_RESOURCE_PROBE_INTERVAL),\n\t\t\t\t\t  DCCP_RTO_MAX);\n\t\treturn;\n\t}\n\n\ticsk->icsk_backoff++;\n\n\ticsk->icsk_rto = min(icsk->icsk_rto << 1, DCCP_RTO_MAX);\n\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, icsk->icsk_rto,\n\t\t\t\t  DCCP_RTO_MAX);\n\tif (icsk->icsk_retransmits > sysctl_dccp_retries1)\n\t\t__sk_dst_reset(sk);\n}\n\nstatic void dccp_write_timer(struct timer_list *t)\n{\n\tstruct inet_connection_sock *icsk =\n\t\t\tfrom_timer(icsk, t, icsk_retransmit_timer);\n\tstruct sock *sk = &icsk->icsk_inet.sk;\n\tint event = 0;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\t \n\t\tsk_reset_timer(sk, &icsk->icsk_retransmit_timer,\n\t\t\t       jiffies + (HZ / 20));\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state == DCCP_CLOSED || !icsk->icsk_pending)\n\t\tgoto out;\n\n\tif (time_after(icsk->icsk_timeout, jiffies)) {\n\t\tsk_reset_timer(sk, &icsk->icsk_retransmit_timer,\n\t\t\t       icsk->icsk_timeout);\n\t\tgoto out;\n\t}\n\n\tevent = icsk->icsk_pending;\n\ticsk->icsk_pending = 0;\n\n\tswitch (event) {\n\tcase ICSK_TIME_RETRANS:\n\t\tdccp_retransmit_timer(sk);\n\t\tbreak;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void dccp_keepalive_timer(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\n\tpr_err(\"dccp should not use a keepalive timer !\\n\");\n\tsock_put(sk);\n}\n\n \nstatic void dccp_delack_timer(struct timer_list *t)\n{\n\tstruct inet_connection_sock *icsk =\n\t\t\tfrom_timer(icsk, t, icsk_delack_timer);\n\tstruct sock *sk = &icsk->icsk_inet.sk;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\t \n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOCKED);\n\t\tsk_reset_timer(sk, &icsk->icsk_delack_timer,\n\t\t\t       jiffies + TCP_DELACK_MIN);\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state == DCCP_CLOSED ||\n\t    !(icsk->icsk_ack.pending & ICSK_ACK_TIMER))\n\t\tgoto out;\n\tif (time_after(icsk->icsk_ack.timeout, jiffies)) {\n\t\tsk_reset_timer(sk, &icsk->icsk_delack_timer,\n\t\t\t       icsk->icsk_ack.timeout);\n\t\tgoto out;\n\t}\n\n\ticsk->icsk_ack.pending &= ~ICSK_ACK_TIMER;\n\n\tif (inet_csk_ack_scheduled(sk)) {\n\t\tif (!inet_csk_in_pingpong_mode(sk)) {\n\t\t\t \n\t\t\ticsk->icsk_ack.ato = min(icsk->icsk_ack.ato << 1,\n\t\t\t\t\t\t icsk->icsk_rto);\n\t\t} else {\n\t\t\t \n\t\t\tinet_csk_exit_pingpong_mode(sk);\n\t\t\ticsk->icsk_ack.ato = TCP_ATO_MIN;\n\t\t}\n\t\tdccp_send_ack(sk);\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKS);\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n \nstatic void dccp_write_xmitlet(struct tasklet_struct *t)\n{\n\tstruct dccp_sock *dp = from_tasklet(dp, t, dccps_xmitlet);\n\tstruct sock *sk = &dp->dccps_inet_connection.icsk_inet.sk;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk))\n\t\tsk_reset_timer(sk, &dccp_sk(sk)->dccps_xmit_timer, jiffies + 1);\n\telse\n\t\tdccp_write_xmit(sk);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void dccp_write_xmit_timer(struct timer_list *t)\n{\n\tstruct dccp_sock *dp = from_timer(dp, t, dccps_xmit_timer);\n\n\tdccp_write_xmitlet(&dp->dccps_xmitlet);\n}\n\nvoid dccp_init_xmit_timers(struct sock *sk)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\ttasklet_setup(&dp->dccps_xmitlet, dccp_write_xmitlet);\n\ttimer_setup(&dp->dccps_xmit_timer, dccp_write_xmit_timer, 0);\n\tinet_csk_init_xmit_timers(sk, &dccp_write_timer, &dccp_delack_timer,\n\t\t\t\t  &dccp_keepalive_timer);\n}\n\nstatic ktime_t dccp_timestamp_seed;\n \nu32 dccp_timestamp(void)\n{\n\tu64 delta = (u64)ktime_us_delta(ktime_get_real(), dccp_timestamp_seed);\n\n\tdo_div(delta, 10);\n\treturn delta;\n}\nEXPORT_SYMBOL_GPL(dccp_timestamp);\n\nvoid __init dccp_timestamping_init(void)\n{\n\tdccp_timestamp_seed = ktime_get_real();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}