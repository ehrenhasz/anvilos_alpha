{
  "module_name": "feat.c",
  "hash_id": "2b725db83694021c87061c40ae13823bc5d87c7560bdd3a2e10ec2aa9718db0f",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/feat.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"ccid.h\"\n#include \"feat.h\"\n\n \nunsigned long\tsysctl_dccp_sequence_window __read_mostly = 100;\nint\t\tsysctl_dccp_rx_ccid\t    __read_mostly = 2,\n\t\tsysctl_dccp_tx_ccid\t    __read_mostly = 2;\n\n \nstatic int dccp_hdlr_ccid(struct sock *sk, u64 ccid, bool rx)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct ccid *new_ccid = ccid_new(ccid, sk, rx);\n\n\tif (new_ccid == NULL)\n\t\treturn -ENOMEM;\n\n\tif (rx) {\n\t\tccid_hc_rx_delete(dp->dccps_hc_rx_ccid, sk);\n\t\tdp->dccps_hc_rx_ccid = new_ccid;\n\t} else {\n\t\tccid_hc_tx_delete(dp->dccps_hc_tx_ccid, sk);\n\t\tdp->dccps_hc_tx_ccid = new_ccid;\n\t}\n\treturn 0;\n}\n\nstatic int dccp_hdlr_seq_win(struct sock *sk, u64 seq_win, bool rx)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\tif (rx) {\n\t\tdp->dccps_r_seq_win = seq_win;\n\t\t \n\t\tdccp_update_gsr(sk, dp->dccps_gsr);\n\t} else {\n\t\tdp->dccps_l_seq_win = seq_win;\n\t\t \n\t\tdccp_update_gss(sk, dp->dccps_gss);\n\t}\n\treturn 0;\n}\n\nstatic int dccp_hdlr_ack_ratio(struct sock *sk, u64 ratio, bool rx)\n{\n\tif (rx)\n\t\tdccp_sk(sk)->dccps_r_ack_ratio = ratio;\n\telse\n\t\tdccp_sk(sk)->dccps_l_ack_ratio = ratio;\n\treturn 0;\n}\n\nstatic int dccp_hdlr_ackvec(struct sock *sk, u64 enable, bool rx)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\tif (rx) {\n\t\tif (enable && dp->dccps_hc_rx_ackvec == NULL) {\n\t\t\tdp->dccps_hc_rx_ackvec = dccp_ackvec_alloc(gfp_any());\n\t\t\tif (dp->dccps_hc_rx_ackvec == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!enable) {\n\t\t\tdccp_ackvec_free(dp->dccps_hc_rx_ackvec);\n\t\t\tdp->dccps_hc_rx_ackvec = NULL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dccp_hdlr_ndp(struct sock *sk, u64 enable, bool rx)\n{\n\tif (!rx)\n\t\tdccp_sk(sk)->dccps_send_ndp_count = (enable > 0);\n\treturn 0;\n}\n\n \nstatic int dccp_hdlr_min_cscov(struct sock *sk, u64 cscov, bool rx)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\tif (rx)\n\t\tdp->dccps_pcrlen = cscov;\n\telse {\n\t\tif (dp->dccps_pcslen == 0)\n\t\t\tdp->dccps_pcslen = cscov;\n\t\telse if (cscov > dp->dccps_pcslen)\n\t\t\tDCCP_WARN(\"CsCov %u too small, peer requires >= %u\\n\",\n\t\t\t\t  dp->dccps_pcslen, (u8)cscov);\n\t}\n\treturn 0;\n}\n\nstatic const struct {\n\tu8\t\t\tfeat_num;\t\t \n\tenum dccp_feat_type\trxtx;\t\t\t \n\tenum dccp_feat_type\treconciliation;\t\t \n\tu8\t\t\tdefault_value;\t\t \n\tint (*activation_hdlr)(struct sock *sk, u64 val, bool rx);\n \n} dccp_feat_table[] = {\n\t{ DCCPF_CCID,\t\t FEAT_AT_TX, FEAT_SP, 2,   dccp_hdlr_ccid     },\n\t{ DCCPF_SHORT_SEQNOS,\t FEAT_AT_TX, FEAT_SP, 0,   NULL },\n\t{ DCCPF_SEQUENCE_WINDOW, FEAT_AT_TX, FEAT_NN, 100, dccp_hdlr_seq_win  },\n\t{ DCCPF_ECN_INCAPABLE,\t FEAT_AT_RX, FEAT_SP, 0,   NULL },\n\t{ DCCPF_ACK_RATIO,\t FEAT_AT_TX, FEAT_NN, 2,   dccp_hdlr_ack_ratio},\n\t{ DCCPF_SEND_ACK_VECTOR, FEAT_AT_RX, FEAT_SP, 0,   dccp_hdlr_ackvec   },\n\t{ DCCPF_SEND_NDP_COUNT,  FEAT_AT_TX, FEAT_SP, 0,   dccp_hdlr_ndp      },\n\t{ DCCPF_MIN_CSUM_COVER,  FEAT_AT_RX, FEAT_SP, 0,   dccp_hdlr_min_cscov},\n\t{ DCCPF_DATA_CHECKSUM,\t FEAT_AT_RX, FEAT_SP, 0,   NULL },\n\t{ DCCPF_SEND_LEV_RATE,\t FEAT_AT_RX, FEAT_SP, 0,   NULL },\n};\n#define DCCP_FEAT_SUPPORTED_MAX\t\tARRAY_SIZE(dccp_feat_table)\n\n \nstatic int dccp_feat_index(u8 feat_num)\n{\n\t \n\tif (feat_num > DCCPF_RESERVED && feat_num <= DCCPF_DATA_CHECKSUM)\n\t\treturn feat_num - 1;\n\n\t \n\tswitch (feat_num) {\n\tcase DCCPF_SEND_LEV_RATE:\n\t\t\treturn DCCP_FEAT_SUPPORTED_MAX - 1;\n\t}\n\treturn -1;\n}\n\nstatic u8 dccp_feat_type(u8 feat_num)\n{\n\tint idx = dccp_feat_index(feat_num);\n\n\tif (idx < 0)\n\t\treturn FEAT_UNKNOWN;\n\treturn dccp_feat_table[idx].reconciliation;\n}\n\nstatic int dccp_feat_default_value(u8 feat_num)\n{\n\tint idx = dccp_feat_index(feat_num);\n\t \n\tDCCP_BUG_ON(idx < 0);\n\n\treturn idx < 0 ? 0 : dccp_feat_table[idx].default_value;\n}\n\n \nstatic const char *dccp_feat_fname(const u8 feat)\n{\n\tstatic const char *const feature_names[] = {\n\t\t[DCCPF_RESERVED]\t= \"Reserved\",\n\t\t[DCCPF_CCID]\t\t= \"CCID\",\n\t\t[DCCPF_SHORT_SEQNOS]\t= \"Allow Short Seqnos\",\n\t\t[DCCPF_SEQUENCE_WINDOW]\t= \"Sequence Window\",\n\t\t[DCCPF_ECN_INCAPABLE]\t= \"ECN Incapable\",\n\t\t[DCCPF_ACK_RATIO]\t= \"Ack Ratio\",\n\t\t[DCCPF_SEND_ACK_VECTOR]\t= \"Send ACK Vector\",\n\t\t[DCCPF_SEND_NDP_COUNT]\t= \"Send NDP Count\",\n\t\t[DCCPF_MIN_CSUM_COVER]\t= \"Min. Csum Coverage\",\n\t\t[DCCPF_DATA_CHECKSUM]\t= \"Send Data Checksum\",\n\t};\n\tif (feat > DCCPF_DATA_CHECKSUM && feat < DCCPF_MIN_CCID_SPECIFIC)\n\t\treturn feature_names[DCCPF_RESERVED];\n\n\tif (feat ==  DCCPF_SEND_LEV_RATE)\n\t\treturn \"Send Loss Event Rate\";\n\tif (feat >= DCCPF_MIN_CCID_SPECIFIC)\n\t\treturn \"CCID-specific\";\n\n\treturn feature_names[feat];\n}\n\nstatic const char *const dccp_feat_sname[] = {\n\t\"DEFAULT\", \"INITIALISING\", \"CHANGING\", \"UNSTABLE\", \"STABLE\",\n};\n\n#ifdef CONFIG_IP_DCCP_DEBUG\nstatic const char *dccp_feat_oname(const u8 opt)\n{\n\tswitch (opt) {\n\tcase DCCPO_CHANGE_L:  return \"Change_L\";\n\tcase DCCPO_CONFIRM_L: return \"Confirm_L\";\n\tcase DCCPO_CHANGE_R:  return \"Change_R\";\n\tcase DCCPO_CONFIRM_R: return \"Confirm_R\";\n\t}\n\treturn NULL;\n}\n\nstatic void dccp_feat_printval(u8 feat_num, dccp_feat_val const *val)\n{\n\tu8 i, type = dccp_feat_type(feat_num);\n\n\tif (val == NULL || (type == FEAT_SP && val->sp.vec == NULL))\n\t\tdccp_pr_debug_cat(\"(NULL)\");\n\telse if (type == FEAT_SP)\n\t\tfor (i = 0; i < val->sp.len; i++)\n\t\t\tdccp_pr_debug_cat(\"%s%u\", i ? \" \" : \"\", val->sp.vec[i]);\n\telse if (type == FEAT_NN)\n\t\tdccp_pr_debug_cat(\"%llu\", (unsigned long long)val->nn);\n\telse\n\t\tdccp_pr_debug_cat(\"unknown type %u\", type);\n}\n\nstatic void dccp_feat_printvals(u8 feat_num, u8 *list, u8 len)\n{\n\tu8 type = dccp_feat_type(feat_num);\n\tdccp_feat_val fval = { .sp.vec = list, .sp.len = len };\n\n\tif (type == FEAT_NN)\n\t\tfval.nn = dccp_decode_value_var(list, len);\n\tdccp_feat_printval(feat_num, &fval);\n}\n\nstatic void dccp_feat_print_entry(struct dccp_feat_entry const *entry)\n{\n\tdccp_debug(\"   * %s %s = \", entry->is_local ? \"local\" : \"remote\",\n\t\t\t\t    dccp_feat_fname(entry->feat_num));\n\tdccp_feat_printval(entry->feat_num, &entry->val);\n\tdccp_pr_debug_cat(\", state=%s %s\\n\", dccp_feat_sname[entry->state],\n\t\t\t  entry->needs_confirm ? \"(Confirm pending)\" : \"\");\n}\n\n#define dccp_feat_print_opt(opt, feat, val, len, mandatory)\tdo {\t      \\\n\tdccp_pr_debug(\"%s(%s, \", dccp_feat_oname(opt), dccp_feat_fname(feat));\\\n\tdccp_feat_printvals(feat, val, len);\t\t\t\t      \\\n\tdccp_pr_debug_cat(\") %s\\n\", mandatory ? \"!\" : \"\");\t} while (0)\n\n#define dccp_feat_print_fnlist(fn_list)  {\t\t\\\n\tconst struct dccp_feat_entry *___entry;\t\t\\\n\t\t\t\t\t\t\t\\\n\tdccp_pr_debug(\"List Dump:\\n\");\t\t\t\\\n\tlist_for_each_entry(___entry, fn_list, node)\t\\\n\t\tdccp_feat_print_entry(___entry);\t\\\n}\n#else\t \n#define dccp_feat_print_opt(opt, feat, val, len, mandatory)\n#define dccp_feat_print_fnlist(fn_list)\n#endif\n\nstatic int __dccp_feat_activate(struct sock *sk, const int idx,\n\t\t\t\tconst bool is_local, dccp_feat_val const *fval)\n{\n\tbool rx;\n\tu64 val;\n\n\tif (idx < 0 || idx >= DCCP_FEAT_SUPPORTED_MAX)\n\t\treturn -1;\n\tif (dccp_feat_table[idx].activation_hdlr == NULL)\n\t\treturn 0;\n\n\tif (fval == NULL) {\n\t\tval = dccp_feat_table[idx].default_value;\n\t} else if (dccp_feat_table[idx].reconciliation == FEAT_SP) {\n\t\tif (fval->sp.vec == NULL) {\n\t\t\t \n\t\t\tDCCP_CRIT(\"Feature #%d undefined: using default\", idx);\n\t\t\tval = dccp_feat_table[idx].default_value;\n\t\t} else {\n\t\t\tval = fval->sp.vec[0];\n\t\t}\n\t} else {\n\t\tval = fval->nn;\n\t}\n\n\t \n\trx = (is_local == (dccp_feat_table[idx].rxtx == FEAT_AT_RX));\n\n\tdccp_debug(\"   -> activating %s %s, %sval=%llu\\n\", rx ? \"RX\" : \"TX\",\n\t\t   dccp_feat_fname(dccp_feat_table[idx].feat_num),\n\t\t   fval ? \"\" : \"default \",  (unsigned long long)val);\n\n\treturn dccp_feat_table[idx].activation_hdlr(sk, val, rx);\n}\n\n \nstatic int dccp_feat_activate(struct sock *sk, u8 feat_num, bool local,\n\t\t\t      dccp_feat_val const *fval)\n{\n\treturn __dccp_feat_activate(sk, dccp_feat_index(feat_num), local, fval);\n}\n\n \nstatic inline int dccp_feat_must_be_understood(u8 feat_num)\n{\n\treturn\tfeat_num == DCCPF_CCID || feat_num == DCCPF_SHORT_SEQNOS ||\n\t\tfeat_num == DCCPF_SEQUENCE_WINDOW;\n}\n\n \nstatic int dccp_feat_clone_sp_val(dccp_feat_val *fval, u8 const *val, u8 len)\n{\n\tfval->sp.len = len;\n\tif (fval->sp.len > 0) {\n\t\tfval->sp.vec = kmemdup(val, len, gfp_any());\n\t\tif (fval->sp.vec == NULL) {\n\t\t\tfval->sp.len = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void dccp_feat_val_destructor(u8 feat_num, dccp_feat_val *val)\n{\n\tif (unlikely(val == NULL))\n\t\treturn;\n\tif (dccp_feat_type(feat_num) == FEAT_SP)\n\t\tkfree(val->sp.vec);\n\tmemset(val, 0, sizeof(*val));\n}\n\nstatic struct dccp_feat_entry *\n\t      dccp_feat_clone_entry(struct dccp_feat_entry const *original)\n{\n\tstruct dccp_feat_entry *new;\n\tu8 type = dccp_feat_type(original->feat_num);\n\n\tif (type == FEAT_UNKNOWN)\n\t\treturn NULL;\n\n\tnew = kmemdup(original, sizeof(struct dccp_feat_entry), gfp_any());\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tif (type == FEAT_SP && dccp_feat_clone_sp_val(&new->val,\n\t\t\t\t\t\t      original->val.sp.vec,\n\t\t\t\t\t\t      original->val.sp.len)) {\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\treturn new;\n}\n\nstatic void dccp_feat_entry_destructor(struct dccp_feat_entry *entry)\n{\n\tif (entry != NULL) {\n\t\tdccp_feat_val_destructor(entry->feat_num, &entry->val);\n\t\tkfree(entry);\n\t}\n}\n\n \nstatic struct dccp_feat_entry *dccp_feat_list_lookup(struct list_head *fn_list,\n\t\t\t\t\t\t     u8 feat_num, bool is_local)\n{\n\tstruct dccp_feat_entry *entry;\n\n\tlist_for_each_entry(entry, fn_list, node) {\n\t\tif (entry->feat_num == feat_num && entry->is_local == is_local)\n\t\t\treturn entry;\n\t\telse if (entry->feat_num > feat_num)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct dccp_feat_entry *\n\t      dccp_feat_entry_new(struct list_head *head, u8 feat, bool local)\n{\n\tstruct dccp_feat_entry *entry;\n\n\tlist_for_each_entry(entry, head, node)\n\t\tif (entry->feat_num == feat && entry->is_local == local) {\n\t\t\tdccp_feat_val_destructor(entry->feat_num, &entry->val);\n\t\t\treturn entry;\n\t\t} else if (entry->feat_num > feat) {\n\t\t\thead = &entry->node;\n\t\t\tbreak;\n\t\t}\n\n\tentry = kmalloc(sizeof(*entry), gfp_any());\n\tif (entry != NULL) {\n\t\tentry->feat_num = feat;\n\t\tentry->is_local = local;\n\t\tlist_add_tail(&entry->node, head);\n\t}\n\treturn entry;\n}\n\n \nstatic int dccp_feat_push_change(struct list_head *fn_list, u8 feat, u8 local,\n\t\t\t\t u8 mandatory, dccp_feat_val *fval)\n{\n\tstruct dccp_feat_entry *new = dccp_feat_entry_new(fn_list, feat, local);\n\n\tif (new == NULL)\n\t\treturn -ENOMEM;\n\n\tnew->feat_num\t     = feat;\n\tnew->is_local\t     = local;\n\tnew->state\t     = FEAT_INITIALISING;\n\tnew->needs_confirm   = false;\n\tnew->empty_confirm   = false;\n\tnew->val\t     = *fval;\n\tnew->needs_mandatory = mandatory;\n\n\treturn 0;\n}\n\n \nstatic int dccp_feat_push_confirm(struct list_head *fn_list, u8 feat, u8 local,\n\t\t\t\t  dccp_feat_val *fval)\n{\n\tstruct dccp_feat_entry *new = dccp_feat_entry_new(fn_list, feat, local);\n\n\tif (new == NULL)\n\t\treturn DCCP_RESET_CODE_TOO_BUSY;\n\n\tnew->feat_num\t     = feat;\n\tnew->is_local\t     = local;\n\tnew->state\t     = FEAT_STABLE;\t \n\tnew->needs_confirm   = true;\n\tnew->empty_confirm   = (fval == NULL);\n\tnew->val.nn\t     = 0;\t\t \n\tif (!new->empty_confirm)\n\t\tnew->val     = *fval;\n\tnew->needs_mandatory = false;\n\n\treturn 0;\n}\n\nstatic int dccp_push_empty_confirm(struct list_head *fn_list, u8 feat, u8 local)\n{\n\treturn dccp_feat_push_confirm(fn_list, feat, local, NULL);\n}\n\nstatic inline void dccp_feat_list_pop(struct dccp_feat_entry *entry)\n{\n\tlist_del(&entry->node);\n\tdccp_feat_entry_destructor(entry);\n}\n\nvoid dccp_feat_list_purge(struct list_head *fn_list)\n{\n\tstruct dccp_feat_entry *entry, *next;\n\n\tlist_for_each_entry_safe(entry, next, fn_list, node)\n\t\tdccp_feat_entry_destructor(entry);\n\tINIT_LIST_HEAD(fn_list);\n}\nEXPORT_SYMBOL_GPL(dccp_feat_list_purge);\n\n \nint dccp_feat_clone_list(struct list_head const *from, struct list_head *to)\n{\n\tstruct dccp_feat_entry *entry, *new;\n\n\tINIT_LIST_HEAD(to);\n\tlist_for_each_entry(entry, from, node) {\n\t\tnew = dccp_feat_clone_entry(entry);\n\t\tif (new == NULL)\n\t\t\tgoto cloning_failed;\n\t\tlist_add_tail(&new->node, to);\n\t}\n\treturn 0;\n\ncloning_failed:\n\tdccp_feat_list_purge(to);\n\treturn -ENOMEM;\n}\n\n \nstatic u8 dccp_feat_valid_nn_length(u8 feat_num)\n{\n\tif (feat_num == DCCPF_ACK_RATIO)\t \n\t\treturn 2;\n\tif (feat_num == DCCPF_SEQUENCE_WINDOW)\t \n\t\treturn 6;\n\treturn 0;\n}\n\nstatic u8 dccp_feat_is_valid_nn_val(u8 feat_num, u64 val)\n{\n\tswitch (feat_num) {\n\tcase DCCPF_ACK_RATIO:\n\t\treturn val <= DCCPF_ACK_RATIO_MAX;\n\tcase DCCPF_SEQUENCE_WINDOW:\n\t\treturn val >= DCCPF_SEQ_WMIN && val <= DCCPF_SEQ_WMAX;\n\t}\n\treturn 0;\t \n}\n\n \nstatic u8 dccp_feat_is_valid_sp_val(u8 feat_num, u8 val)\n{\n\tswitch (feat_num) {\n\tcase DCCPF_CCID:\n\t\treturn val == DCCPC_CCID2 || val == DCCPC_CCID3;\n\t \n\tcase DCCPF_SHORT_SEQNOS:\n\tcase DCCPF_ECN_INCAPABLE:\n\tcase DCCPF_SEND_ACK_VECTOR:\n\tcase DCCPF_SEND_NDP_COUNT:\n\tcase DCCPF_DATA_CHECKSUM:\n\tcase DCCPF_SEND_LEV_RATE:\n\t\treturn val < 2;\n\tcase DCCPF_MIN_CSUM_COVER:\n\t\treturn val < 16;\n\t}\n\treturn 0;\t\t\t \n}\n\nstatic u8 dccp_feat_sp_list_ok(u8 feat_num, u8 const *sp_list, u8 sp_len)\n{\n\tif (sp_list == NULL || sp_len < 1)\n\t\treturn 0;\n\twhile (sp_len--)\n\t\tif (!dccp_feat_is_valid_sp_val(feat_num, *sp_list++))\n\t\t\treturn 0;\n\treturn 1;\n}\n\n \nint dccp_feat_insert_opts(struct dccp_sock *dp, struct dccp_request_sock *dreq,\n\t\t\t  struct sk_buff *skb)\n{\n\tstruct list_head *fn = dreq ? &dreq->dreq_featneg : &dp->dccps_featneg;\n\tstruct dccp_feat_entry *pos, *next;\n\tu8 opt, type, len, *ptr, nn_in_nbo[DCCP_OPTVAL_MAXLEN];\n\tbool rpt;\n\n\t \n\tlist_for_each_entry_safe_reverse(pos, next, fn, node) {\n\t\topt  = dccp_feat_genopt(pos);\n\t\ttype = dccp_feat_type(pos->feat_num);\n\t\trpt  = false;\n\n\t\tif (pos->empty_confirm) {\n\t\t\tlen = 0;\n\t\t\tptr = NULL;\n\t\t} else {\n\t\t\tif (type == FEAT_SP) {\n\t\t\t\tlen = pos->val.sp.len;\n\t\t\t\tptr = pos->val.sp.vec;\n\t\t\t\trpt = pos->needs_confirm;\n\t\t\t} else if (type == FEAT_NN) {\n\t\t\t\tlen = dccp_feat_valid_nn_length(pos->feat_num);\n\t\t\t\tptr = nn_in_nbo;\n\t\t\t\tdccp_encode_value_var(pos->val.nn, ptr, len);\n\t\t\t} else {\n\t\t\t\tDCCP_BUG(\"unknown feature %u\", pos->feat_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdccp_feat_print_opt(opt, pos->feat_num, ptr, len, 0);\n\n\t\tif (dccp_insert_fn_opt(skb, opt, pos->feat_num, ptr, len, rpt))\n\t\t\treturn -1;\n\t\tif (pos->needs_mandatory && dccp_insert_option_mandatory(skb))\n\t\t\treturn -1;\n\n\t\tif (skb->sk->sk_state == DCCP_OPEN &&\n\t\t    (opt == DCCPO_CONFIRM_R || opt == DCCPO_CONFIRM_L)) {\n\t\t\t \n\t\t\tdccp_feat_list_pop(pos);\n\t\t} else {\n\t\t\t \n\t\t\tif (pos->state == FEAT_INITIALISING)\n\t\t\t\tpos->state = FEAT_CHANGING;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int __feat_register_nn(struct list_head *fn, u8 feat,\n\t\t\t      u8 mandatory, u64 nn_val)\n{\n\tdccp_feat_val fval = { .nn = nn_val };\n\n\tif (dccp_feat_type(feat) != FEAT_NN ||\n\t    !dccp_feat_is_valid_nn_val(feat, nn_val))\n\t\treturn -EINVAL;\n\n\t \n\tif (nn_val - (u64)dccp_feat_default_value(feat) == 0)\n\t\treturn 0;\n\n\treturn dccp_feat_push_change(fn, feat, 1, mandatory, &fval);\n}\n\n \nstatic int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\n\t\t\t      u8 mandatory, u8 const *sp_val, u8 sp_len)\n{\n\tdccp_feat_val fval;\n\n\tif (dccp_feat_type(feat) != FEAT_SP ||\n\t    !dccp_feat_sp_list_ok(feat, sp_val, sp_len))\n\t\treturn -EINVAL;\n\n\t \n\tif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\n\t\treturn -EOPNOTSUPP;\n\n\tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n\t\treturn -ENOMEM;\n\n\tif (dccp_feat_push_change(fn, feat, is_local, mandatory, &fval)) {\n\t\tkfree(fval.sp.vec);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nint dccp_feat_register_sp(struct sock *sk, u8 feat, u8 is_local,\n\t\t\t  u8 const *list, u8 len)\n{\t  \n\tif (sk->sk_state != DCCP_CLOSED)\n\t\treturn -EISCONN;\n\tif (dccp_feat_type(feat) != FEAT_SP)\n\t\treturn -EINVAL;\n\treturn __feat_register_sp(&dccp_sk(sk)->dccps_featneg, feat, is_local,\n\t\t\t\t  0, list, len);\n}\n\n \nu64 dccp_feat_nn_get(struct sock *sk, u8 feat)\n{\n\tif (dccp_feat_type(feat) == FEAT_NN) {\n\t\tstruct dccp_sock *dp = dccp_sk(sk);\n\t\tstruct dccp_feat_entry *entry;\n\n\t\tentry = dccp_feat_list_lookup(&dp->dccps_featneg, feat, 1);\n\t\tif (entry != NULL)\n\t\t\treturn entry->val.nn;\n\n\t\tswitch (feat) {\n\t\tcase DCCPF_ACK_RATIO:\n\t\t\treturn dp->dccps_l_ack_ratio;\n\t\tcase DCCPF_SEQUENCE_WINDOW:\n\t\t\treturn dp->dccps_l_seq_win;\n\t\t}\n\t}\n\tDCCP_BUG(\"attempt to look up unsupported feature %u\", feat);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dccp_feat_nn_get);\n\n \nint dccp_feat_signal_nn_change(struct sock *sk, u8 feat, u64 nn_val)\n{\n\tstruct list_head *fn = &dccp_sk(sk)->dccps_featneg;\n\tdccp_feat_val fval = { .nn = nn_val };\n\tstruct dccp_feat_entry *entry;\n\n\tif (sk->sk_state != DCCP_OPEN && sk->sk_state != DCCP_PARTOPEN)\n\t\treturn 0;\n\n\tif (dccp_feat_type(feat) != FEAT_NN ||\n\t    !dccp_feat_is_valid_nn_val(feat, nn_val))\n\t\treturn -EINVAL;\n\n\tif (nn_val == dccp_feat_nn_get(sk, feat))\n\t\treturn 0;\t \n\n\tentry = dccp_feat_list_lookup(fn, feat, 1);\n\tif (entry != NULL) {\n\t\tdccp_pr_debug(\"Clobbering existing NN entry %llu -> %llu\\n\",\n\t\t\t      (unsigned long long)entry->val.nn,\n\t\t\t      (unsigned long long)nn_val);\n\t\tdccp_feat_list_pop(entry);\n\t}\n\n\tinet_csk_schedule_ack(sk);\n\treturn dccp_feat_push_change(fn, feat, 1, 0, &fval);\n}\nEXPORT_SYMBOL_GPL(dccp_feat_signal_nn_change);\n\n \nstatic const struct ccid_dependency *dccp_feat_ccid_deps(u8 ccid, bool is_local)\n{\n\tstatic const struct ccid_dependency ccid2_dependencies[2][2] = {\n\t\t \n\t\t{\t \n\t\t\t{\n\t\t\t\t.dependent_feat\t= DCCPF_SEND_ACK_VECTOR,\n\t\t\t\t.is_local\t= true,\n\t\t\t\t.is_mandatory\t= true,\n\t\t\t\t.val\t\t= 1\n\t\t\t},\n\t\t\t{ 0, 0, 0, 0 }\n\t\t},\n\t\t{\t \n\t\t\t{\n\t\t\t\t.dependent_feat\t= DCCPF_SEND_ACK_VECTOR,\n\t\t\t\t.is_local\t= false,\n\t\t\t\t.is_mandatory\t= true,\n\t\t\t\t.val\t\t= 1\n\t\t\t},\n\t\t\t{ 0, 0, 0, 0 }\n\t\t}\n\t};\n\tstatic const struct ccid_dependency ccid3_dependencies[2][5] = {\n\t\t{\t \n\t\t\t{\t \n\t\t\t\t.dependent_feat\t= DCCPF_SEND_ACK_VECTOR,\n\t\t\t\t.is_local\t= true,\n\t\t\t\t.is_mandatory\t= false,\n\t\t\t\t.val\t\t= 0\n\t\t\t},\n\t\t\t{\t \n\t\t\t\t.dependent_feat\t= DCCPF_SEND_LEV_RATE,\n\t\t\t\t.is_local\t= true,\n\t\t\t\t.is_mandatory\t= true,\n\t\t\t\t.val\t\t= 1\n\t\t\t},\n\t\t\t{\t \n\t\t\t\t.dependent_feat\t= DCCPF_SEND_NDP_COUNT,\n\t\t\t\t.is_local\t= false,\n\t\t\t\t.is_mandatory\t= true,\n\t\t\t\t.val\t\t= 1\n\t\t\t},\n\t\t\t{ 0, 0, 0, 0 },\n\t\t},\n\t\t{\t \n\t\t\t{\n\t\t\t\t.dependent_feat\t= DCCPF_SEND_ACK_VECTOR,\n\t\t\t\t.is_local\t= false,\n\t\t\t\t.is_mandatory\t= false,\n\t\t\t\t.val\t\t= 0\n\t\t\t},\n\t\t\t{\n\t\t\t\t.dependent_feat\t= DCCPF_SEND_LEV_RATE,\n\t\t\t\t.is_local\t= false,\n\t\t\t\t.is_mandatory\t= true,\n\t\t\t\t.val\t\t= 1\n\t\t\t},\n\t\t\t{\t \n\t\t\t\t.dependent_feat\t= DCCPF_ACK_RATIO,\n\t\t\t\t.is_local\t= true,\n\t\t\t\t.is_mandatory\t= false,\n\t\t\t\t.val\t\t= 0\n\t\t\t},\n\t\t\t{\t \n\t\t\t\t.dependent_feat\t= DCCPF_SEND_NDP_COUNT,\n\t\t\t\t.is_local\t= true,\n\t\t\t\t.is_mandatory\t= false,\n\t\t\t\t.val\t\t= 1\n\t\t\t},\n\t\t\t{ 0, 0, 0, 0 }\n\t\t}\n\t};\n\tswitch (ccid) {\n\tcase DCCPC_CCID2:\n\t\treturn ccid2_dependencies[is_local];\n\tcase DCCPC_CCID3:\n\t\treturn ccid3_dependencies[is_local];\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nstatic int dccp_feat_propagate_ccid(struct list_head *fn, u8 id, bool is_local)\n{\n\tconst struct ccid_dependency *table = dccp_feat_ccid_deps(id, is_local);\n\tint i, rc = (table == NULL);\n\n\tfor (i = 0; rc == 0 && table[i].dependent_feat != DCCPF_RESERVED; i++)\n\t\tif (dccp_feat_type(table[i].dependent_feat) == FEAT_SP)\n\t\t\trc = __feat_register_sp(fn, table[i].dependent_feat,\n\t\t\t\t\t\t    table[i].is_local,\n\t\t\t\t\t\t    table[i].is_mandatory,\n\t\t\t\t\t\t    &table[i].val, 1);\n\t\telse\n\t\t\trc = __feat_register_nn(fn, table[i].dependent_feat,\n\t\t\t\t\t\t    table[i].is_mandatory,\n\t\t\t\t\t\t    table[i].val);\n\treturn rc;\n}\n\n \nint dccp_feat_finalise_settings(struct dccp_sock *dp)\n{\n\tstruct list_head *fn = &dp->dccps_featneg;\n\tstruct dccp_feat_entry *entry;\n\tint i = 2, ccids[2] = { -1, -1 };\n\n\t \n\tlist_for_each_entry(entry, fn, node)\n\t\tif (entry->feat_num == DCCPF_CCID && entry->val.sp.len == 1)\n\t\t\tccids[entry->is_local] = entry->val.sp.vec[0];\n\twhile (i--)\n\t\tif (ccids[i] > 0 && dccp_feat_propagate_ccid(fn, ccids[i], i))\n\t\t\treturn -1;\n\tdccp_feat_print_fnlist(fn);\n\treturn 0;\n}\n\n \nint dccp_feat_server_ccid_dependencies(struct dccp_request_sock *dreq)\n{\n\tstruct list_head *fn = &dreq->dreq_featneg;\n\tstruct dccp_feat_entry *entry;\n\tu8 is_local, ccid;\n\n\tfor (is_local = 0; is_local <= 1; is_local++) {\n\t\tentry = dccp_feat_list_lookup(fn, DCCPF_CCID, is_local);\n\n\t\tif (entry != NULL && !entry->empty_confirm)\n\t\t\tccid = entry->val.sp.vec[0];\n\t\telse\n\t\t\tccid = dccp_feat_default_value(DCCPF_CCID);\n\n\t\tif (dccp_feat_propagate_ccid(fn, ccid, is_local))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic int dccp_feat_preflist_match(u8 *servlist, u8 slen, u8 *clilist, u8 clen)\n{\n\tu8 c, s;\n\n\tfor (s = 0; s < slen; s++)\n\t\tfor (c = 0; c < clen; c++)\n\t\t\tif (servlist[s] == clilist[c])\n\t\t\t\treturn servlist[s];\n\treturn -1;\n}\n\n \nstatic u8 dccp_feat_prefer(u8 preferred_value, u8 *array, u8 array_len)\n{\n\tu8 i, does_occur = 0;\n\n\tif (array != NULL) {\n\t\tfor (i = 0; i < array_len; i++)\n\t\t\tif (array[i] == preferred_value) {\n\t\t\t\tarray[i] = array[0];\n\t\t\t\tdoes_occur++;\n\t\t\t}\n\t\tif (does_occur)\n\t\t\tarray[0] = preferred_value;\n\t}\n\treturn does_occur;\n}\n\n \nstatic int dccp_feat_reconcile(dccp_feat_val *fv, u8 *arr, u8 len,\n\t\t\t       bool is_server, bool reorder)\n{\n\tint rc;\n\n\tif (!fv->sp.vec || !arr) {\n\t\tDCCP_CRIT(\"NULL feature value or array\");\n\t\treturn 0;\n\t}\n\n\tif (is_server)\n\t\trc = dccp_feat_preflist_match(fv->sp.vec, fv->sp.len, arr, len);\n\telse\n\t\trc = dccp_feat_preflist_match(arr, len, fv->sp.vec, fv->sp.len);\n\n\tif (!reorder)\n\t\treturn rc;\n\tif (rc < 0)\n\t\treturn 0;\n\n\t \n\treturn dccp_feat_prefer(rc, fv->sp.vec, fv->sp.len);\n}\n\n \nstatic u8 dccp_feat_change_recv(struct list_head *fn, u8 is_mandatory, u8 opt,\n\t\t\t\tu8 feat, u8 *val, u8 len, const bool server)\n{\n\tu8 defval, type = dccp_feat_type(feat);\n\tconst bool local = (opt == DCCPO_CHANGE_R);\n\tstruct dccp_feat_entry *entry;\n\tdccp_feat_val fval;\n\n\tif (len == 0 || type == FEAT_UNKNOWN)\t\t \n\t\tgoto unknown_feature_or_value;\n\n\tdccp_feat_print_opt(opt, feat, val, len, is_mandatory);\n\n\t \n\tif (type == FEAT_NN) {\n\t\tif (local || len > sizeof(fval.nn))\n\t\t\tgoto unknown_feature_or_value;\n\n\t\t \n\t\tfval.nn = dccp_decode_value_var(val, len);\n\t\tif (!dccp_feat_is_valid_nn_val(feat, fval.nn))\n\t\t\tgoto unknown_feature_or_value;\n\n\t\treturn dccp_feat_push_confirm(fn, feat, local, &fval);\n\t}\n\n\t \n\tentry = dccp_feat_list_lookup(fn, feat, local);\n\tif (entry == NULL) {\n\t\t \n\t\tif (dccp_feat_clone_sp_val(&fval, val, 1))\n\t\t\treturn DCCP_RESET_CODE_TOO_BUSY;\n\n\t\tif (len > 1 && server) {\n\t\t\tdefval = dccp_feat_default_value(feat);\n\t\t\tif (dccp_feat_preflist_match(&defval, 1, val, len) > -1)\n\t\t\t\tfval.sp.vec[0] = defval;\n\t\t} else if (!dccp_feat_is_valid_sp_val(feat, fval.sp.vec[0])) {\n\t\t\tkfree(fval.sp.vec);\n\t\t\tgoto unknown_feature_or_value;\n\t\t}\n\n\t\t \n\t\tif (feat == DCCPF_CCID && !ccid_support_check(fval.sp.vec, 1)) {\n\t\t\tkfree(fval.sp.vec);\n\t\t\tgoto not_valid_or_not_known;\n\t\t}\n\n\t\treturn dccp_feat_push_confirm(fn, feat, local, &fval);\n\n\t} else if (entry->state == FEAT_UNSTABLE) {\t \n\t\treturn 0;\n\t}\n\n\tif (dccp_feat_reconcile(&entry->val, val, len, server, true)) {\n\t\tentry->empty_confirm = false;\n\t} else if (is_mandatory) {\n\t\treturn DCCP_RESET_CODE_MANDATORY_ERROR;\n\t} else if (entry->state == FEAT_INITIALISING) {\n\t\t \n\t\tWARN_ON(!server);\n\t\tdefval = dccp_feat_default_value(feat);\n\t\tif (!dccp_feat_reconcile(&entry->val, &defval, 1, server, true))\n\t\t\treturn DCCP_RESET_CODE_OPTION_ERROR;\n\t\tentry->empty_confirm = true;\n\t}\n\tentry->needs_confirm   = true;\n\tentry->needs_mandatory = false;\n\tentry->state\t       = FEAT_STABLE;\n\treturn 0;\n\nunknown_feature_or_value:\n\tif (!is_mandatory)\n\t\treturn dccp_push_empty_confirm(fn, feat, local);\n\nnot_valid_or_not_known:\n\treturn is_mandatory ? DCCP_RESET_CODE_MANDATORY_ERROR\n\t\t\t    : DCCP_RESET_CODE_OPTION_ERROR;\n}\n\n \nstatic u8 dccp_feat_confirm_recv(struct list_head *fn, u8 is_mandatory, u8 opt,\n\t\t\t\t u8 feat, u8 *val, u8 len, const bool server)\n{\n\tu8 *plist, plen, type = dccp_feat_type(feat);\n\tconst bool local = (opt == DCCPO_CONFIRM_R);\n\tstruct dccp_feat_entry *entry = dccp_feat_list_lookup(fn, feat, local);\n\n\tdccp_feat_print_opt(opt, feat, val, len, is_mandatory);\n\n\tif (entry == NULL) {\t \n\t\tif (is_mandatory && type == FEAT_UNKNOWN)\n\t\t\treturn DCCP_RESET_CODE_MANDATORY_ERROR;\n\n\t\tif (!local && type == FEAT_NN)\t\t \n\t\t\tgoto confirmation_failed;\n\t\treturn 0;\n\t}\n\n\tif (entry->state != FEAT_CHANGING)\t\t \n\t\treturn 0;\n\n\tif (len == 0) {\n\t\tif (dccp_feat_must_be_understood(feat))\t \n\t\t\tgoto confirmation_failed;\n\t\t \n\t\tdccp_feat_list_pop(entry);\n\t\treturn 0;\n\t}\n\n\tif (type == FEAT_NN) {\n\t\tif (len > sizeof(entry->val.nn))\n\t\t\tgoto confirmation_failed;\n\n\t\tif (entry->val.nn == dccp_decode_value_var(val, len))\n\t\t\tgoto confirmation_succeeded;\n\n\t\tDCCP_WARN(\"Bogus Confirm for non-existing value\\n\");\n\t\tgoto confirmation_failed;\n\t}\n\n\t \n\tif (!dccp_feat_is_valid_sp_val(feat, *val))\n\t\tgoto confirmation_failed;\n\n\tif (len == 1) {\t\t \n\t\tplist = val;\n\t\tplen  = len;\n\t} else {\t\t \n\t\tplist = val + 1;\n\t\tplen  = len - 1;\n\t}\n\n\t \n\tif (dccp_feat_reconcile(&entry->val, plist, plen, server, 0) != *val) {\n\t\tDCCP_WARN(\"Confirm selected the wrong value %u\\n\", *val);\n\t\treturn DCCP_RESET_CODE_OPTION_ERROR;\n\t}\n\tentry->val.sp.vec[0] = *val;\n\nconfirmation_succeeded:\n\tentry->state = FEAT_STABLE;\n\treturn 0;\n\nconfirmation_failed:\n\tDCCP_WARN(\"Confirmation failed\\n\");\n\treturn is_mandatory ? DCCP_RESET_CODE_MANDATORY_ERROR\n\t\t\t    : DCCP_RESET_CODE_OPTION_ERROR;\n}\n\n \nstatic u8 dccp_feat_handle_nn_established(struct sock *sk, u8 mandatory, u8 opt,\n\t\t\t\t\t  u8 feat, u8 *val, u8 len)\n{\n\tstruct list_head *fn = &dccp_sk(sk)->dccps_featneg;\n\tconst bool local = (opt == DCCPO_CONFIRM_R);\n\tstruct dccp_feat_entry *entry;\n\tu8 type = dccp_feat_type(feat);\n\tdccp_feat_val fval;\n\n\tdccp_feat_print_opt(opt, feat, val, len, mandatory);\n\n\t \n\tif (type == FEAT_UNKNOWN) {\n\t\tif (local && !mandatory)\n\t\t\treturn 0;\n\t\tgoto fast_path_unknown;\n\t} else if (type != FEAT_NN) {\n\t\treturn 0;\n\t}\n\n\t \n\tif (len == 0 || len > sizeof(fval.nn))\n\t\tgoto fast_path_unknown;\n\n\tif (opt == DCCPO_CHANGE_L) {\n\t\tfval.nn = dccp_decode_value_var(val, len);\n\t\tif (!dccp_feat_is_valid_nn_val(feat, fval.nn))\n\t\t\tgoto fast_path_unknown;\n\n\t\tif (dccp_feat_push_confirm(fn, feat, local, &fval) ||\n\t\t    dccp_feat_activate(sk, feat, local, &fval))\n\t\t\treturn DCCP_RESET_CODE_TOO_BUSY;\n\n\t\t \n\t\tinet_csk_schedule_ack(sk);\n\n\t} else if (opt == DCCPO_CONFIRM_R) {\n\t\tentry = dccp_feat_list_lookup(fn, feat, local);\n\t\tif (entry == NULL || entry->state != FEAT_CHANGING)\n\t\t\treturn 0;\n\n\t\tfval.nn = dccp_decode_value_var(val, len);\n\t\t \n\t\tif (fval.nn != entry->val.nn)\n\t\t\treturn 0;\n\n\t\t \n\t\tdccp_feat_activate(sk, feat, local, &fval);\n\n\t\t \n\t\tdccp_feat_list_pop(entry);\n\n\t} else {\n\t\tDCCP_WARN(\"Received illegal option %u\\n\", opt);\n\t\tgoto fast_path_failed;\n\t}\n\treturn 0;\n\nfast_path_unknown:\n\tif (!mandatory)\n\t\treturn dccp_push_empty_confirm(fn, feat, local);\n\nfast_path_failed:\n\treturn mandatory ? DCCP_RESET_CODE_MANDATORY_ERROR\n\t\t\t : DCCP_RESET_CODE_OPTION_ERROR;\n}\n\n \nint dccp_feat_parse_options(struct sock *sk, struct dccp_request_sock *dreq,\n\t\t\t    u8 mandatory, u8 opt, u8 feat, u8 *val, u8 len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct list_head *fn = dreq ? &dreq->dreq_featneg : &dp->dccps_featneg;\n\tbool server = false;\n\n\tswitch (sk->sk_state) {\n\t \n\tcase DCCP_LISTEN:\n\t\tserver = true;\n\t\tfallthrough;\n\tcase DCCP_REQUESTING:\n\t\tswitch (opt) {\n\t\tcase DCCPO_CHANGE_L:\n\t\tcase DCCPO_CHANGE_R:\n\t\t\treturn dccp_feat_change_recv(fn, mandatory, opt, feat,\n\t\t\t\t\t\t     val, len, server);\n\t\tcase DCCPO_CONFIRM_R:\n\t\tcase DCCPO_CONFIRM_L:\n\t\t\treturn dccp_feat_confirm_recv(fn, mandatory, opt, feat,\n\t\t\t\t\t\t      val, len, server);\n\t\t}\n\t\tbreak;\n\t \n\tcase DCCP_OPEN:\n\tcase DCCP_PARTOPEN:\n\t\treturn dccp_feat_handle_nn_established(sk, mandatory, opt, feat,\n\t\t\t\t\t\t       val, len);\n\t}\n\treturn 0;\t \n}\n\n \nint dccp_feat_init(struct sock *sk)\n{\n\tstruct list_head *fn = &dccp_sk(sk)->dccps_featneg;\n\tu8 on = 1, off = 0;\n\tint rc;\n\tstruct {\n\t\tu8 *val;\n\t\tu8 len;\n\t} tx, rx;\n\n\t \n\trc = __feat_register_nn(fn, DCCPF_SEQUENCE_WINDOW, 0,\n\t\t\t\t    sysctl_dccp_sequence_window);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\n\t \n\trc = __feat_register_sp(fn, DCCPF_SHORT_SEQNOS, true, true, &off, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = __feat_register_sp(fn, DCCPF_ECN_INCAPABLE, true, true, &on, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (ccid_get_builtin_ccids(&tx.val, &tx.len))\n\t\treturn -ENOBUFS;\n\tif (ccid_get_builtin_ccids(&rx.val, &rx.len)) {\n\t\tkfree(tx.val);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (!dccp_feat_prefer(sysctl_dccp_tx_ccid, tx.val, tx.len) ||\n\t    !dccp_feat_prefer(sysctl_dccp_rx_ccid, rx.val, rx.len))\n\t\tgoto free_ccid_lists;\n\n\trc = __feat_register_sp(fn, DCCPF_CCID, true, false, tx.val, tx.len);\n\tif (rc)\n\t\tgoto free_ccid_lists;\n\n\trc = __feat_register_sp(fn, DCCPF_CCID, false, false, rx.val, rx.len);\n\nfree_ccid_lists:\n\tkfree(tx.val);\n\tkfree(rx.val);\n\treturn rc;\n}\n\nint dccp_feat_activate_values(struct sock *sk, struct list_head *fn_list)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_feat_entry *cur, *next;\n\tint idx;\n\tdccp_feat_val *fvals[DCCP_FEAT_SUPPORTED_MAX][2] = {\n\t\t [0 ... DCCP_FEAT_SUPPORTED_MAX-1] = { NULL, NULL }\n\t};\n\n\tlist_for_each_entry(cur, fn_list, node) {\n\t\t \n\t\tif (cur->empty_confirm)\n\t\t\tcontinue;\n\n\t\tidx = dccp_feat_index(cur->feat_num);\n\t\tif (idx < 0) {\n\t\t\tDCCP_BUG(\"Unknown feature %u\", cur->feat_num);\n\t\t\tgoto activation_failed;\n\t\t}\n\t\tif (cur->state != FEAT_STABLE) {\n\t\t\tDCCP_CRIT(\"Negotiation of %s %s failed in state %s\",\n\t\t\t\t  cur->is_local ? \"local\" : \"remote\",\n\t\t\t\t  dccp_feat_fname(cur->feat_num),\n\t\t\t\t  dccp_feat_sname[cur->state]);\n\t\t\tgoto activation_failed;\n\t\t}\n\t\tfvals[idx][cur->is_local] = &cur->val;\n\t}\n\n\t \n\tfor (idx = DCCP_FEAT_SUPPORTED_MAX; --idx >= 0;)\n\t\tif (__dccp_feat_activate(sk, idx, 0, fvals[idx][0]) ||\n\t\t    __dccp_feat_activate(sk, idx, 1, fvals[idx][1])) {\n\t\t\tDCCP_CRIT(\"Could not activate %d\", idx);\n\t\t\tgoto activation_failed;\n\t\t}\n\n\t \n\tlist_for_each_entry_safe(cur, next, fn_list, node)\n\t\tif (!cur->needs_confirm)\n\t\t\tdccp_feat_list_pop(cur);\n\n\tdccp_pr_debug(\"Activation OK\\n\");\n\treturn 0;\n\nactivation_failed:\n\t \n\tccid_hc_rx_delete(dp->dccps_hc_rx_ccid, sk);\n\tccid_hc_tx_delete(dp->dccps_hc_tx_ccid, sk);\n\tdp->dccps_hc_rx_ccid = dp->dccps_hc_tx_ccid = NULL;\n\tdccp_ackvec_free(dp->dccps_hc_rx_ackvec);\n\tdp->dccps_hc_rx_ackvec = NULL;\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}