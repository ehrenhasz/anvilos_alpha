{
  "module_name": "ccid3.c",
  "hash_id": "c4122a1df97e2305579a112b6ab42293b081228205b90dafe10f38968a2a5140",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/ccids/ccid3.c",
  "human_readable_source": "\n \n#include \"../dccp.h\"\n#include \"ccid3.h\"\n\n#include <asm/unaligned.h>\n\n#ifdef CONFIG_IP_DCCP_CCID3_DEBUG\nstatic bool ccid3_debug;\n#define ccid3_pr_debug(format, a...)\tDCCP_PR_DEBUG(ccid3_debug, format, ##a)\n#else\n#define ccid3_pr_debug(format, a...)\n#endif\n\n \n#ifdef CONFIG_IP_DCCP_CCID3_DEBUG\nstatic const char *ccid3_tx_state_name(enum ccid3_hc_tx_states state)\n{\n\tstatic const char *const ccid3_state_names[] = {\n\t[TFRC_SSTATE_NO_SENT]  = \"NO_SENT\",\n\t[TFRC_SSTATE_NO_FBACK] = \"NO_FBACK\",\n\t[TFRC_SSTATE_FBACK]    = \"FBACK\",\n\t};\n\n\treturn ccid3_state_names[state];\n}\n#endif\n\nstatic void ccid3_hc_tx_set_state(struct sock *sk,\n\t\t\t\t  enum ccid3_hc_tx_states state)\n{\n\tstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tenum ccid3_hc_tx_states oldstate = hc->tx_state;\n\n\tccid3_pr_debug(\"%s(%p) %-8.8s -> %s\\n\",\n\t\t       dccp_role(sk), sk, ccid3_tx_state_name(oldstate),\n\t\t       ccid3_tx_state_name(state));\n\tWARN_ON(state == oldstate);\n\thc->tx_state = state;\n}\n\n \nstatic inline u64 rfc3390_initial_rate(struct sock *sk)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tconst __u32 w_init = clamp_t(__u32, 4380U, 2 * hc->tx_s, 4 * hc->tx_s);\n\n\treturn scaled_div(w_init << 6, hc->tx_rtt);\n}\n\n \nstatic void ccid3_update_send_interval(struct ccid3_hc_tx_sock *hc)\n{\n\thc->tx_t_ipi = scaled_div32(((u64)hc->tx_s) << 6, hc->tx_x);\n\n\tDCCP_BUG_ON(hc->tx_t_ipi == 0);\n\tccid3_pr_debug(\"t_ipi=%u, s=%u, X=%u\\n\", hc->tx_t_ipi,\n\t\t       hc->tx_s, (unsigned int)(hc->tx_x >> 6));\n}\n\nstatic u32 ccid3_hc_tx_idle_rtt(struct ccid3_hc_tx_sock *hc, ktime_t now)\n{\n\tu32 delta = ktime_us_delta(now, hc->tx_t_last_win_count);\n\n\treturn delta / hc->tx_rtt;\n}\n\n \nstatic void ccid3_hc_tx_update_x(struct sock *sk, ktime_t *stamp)\n{\n\tstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\t__u64 min_rate = 2 * hc->tx_x_recv;\n\tconst __u64 old_x = hc->tx_x;\n\tktime_t now = stamp ? *stamp : ktime_get_real();\n\n\t \n\tif (ccid3_hc_tx_idle_rtt(hc, now) >= 2) {\n\t\tmin_rate = rfc3390_initial_rate(sk);\n\t\tmin_rate = max(min_rate, 2 * hc->tx_x_recv);\n\t}\n\n\tif (hc->tx_p > 0) {\n\n\t\thc->tx_x = min(((__u64)hc->tx_x_calc) << 6, min_rate);\n\t\thc->tx_x = max(hc->tx_x, (((__u64)hc->tx_s) << 6) / TFRC_T_MBI);\n\n\t} else if (ktime_us_delta(now, hc->tx_t_ld) - (s64)hc->tx_rtt >= 0) {\n\n\t\thc->tx_x = min(2 * hc->tx_x, min_rate);\n\t\thc->tx_x = max(hc->tx_x,\n\t\t\t       scaled_div(((__u64)hc->tx_s) << 6, hc->tx_rtt));\n\t\thc->tx_t_ld = now;\n\t}\n\n\tif (hc->tx_x != old_x) {\n\t\tccid3_pr_debug(\"X_prev=%u, X_now=%u, X_calc=%u, \"\n\t\t\t       \"X_recv=%u\\n\", (unsigned int)(old_x >> 6),\n\t\t\t       (unsigned int)(hc->tx_x >> 6), hc->tx_x_calc,\n\t\t\t       (unsigned int)(hc->tx_x_recv >> 6));\n\n\t\tccid3_update_send_interval(hc);\n\t}\n}\n\n \nstatic inline void ccid3_hc_tx_update_s(struct ccid3_hc_tx_sock *hc, int len)\n{\n\tconst u16 old_s = hc->tx_s;\n\n\thc->tx_s = tfrc_ewma(hc->tx_s, len, 9);\n\n\tif (hc->tx_s != old_s)\n\t\tccid3_update_send_interval(hc);\n}\n\n \nstatic inline void ccid3_hc_tx_update_win_count(struct ccid3_hc_tx_sock *hc,\n\t\t\t\t\t\tktime_t now)\n{\n\tu32 delta = ktime_us_delta(now, hc->tx_t_last_win_count),\n\t    quarter_rtts = (4 * delta) / hc->tx_rtt;\n\n\tif (quarter_rtts > 0) {\n\t\thc->tx_t_last_win_count = now;\n\t\thc->tx_last_win_count  += min(quarter_rtts, 5U);\n\t\thc->tx_last_win_count  &= 0xF;\t\t \n\t}\n}\n\nstatic void ccid3_hc_tx_no_feedback_timer(struct timer_list *t)\n{\n\tstruct ccid3_hc_tx_sock *hc = from_timer(hc, t, tx_no_feedback_timer);\n\tstruct sock *sk = hc->sk;\n\tunsigned long t_nfb = USEC_PER_SEC / 5;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\t \n\t\t \n\t\tgoto restart_timer;\n\t}\n\n\tccid3_pr_debug(\"%s(%p, state=%s) - entry\\n\", dccp_role(sk), sk,\n\t\t       ccid3_tx_state_name(hc->tx_state));\n\n\t \n\tif ((1 << sk->sk_state) & ~(DCCPF_OPEN | DCCPF_PARTOPEN))\n\t\tgoto out;\n\n\t \n\tif (hc->tx_state == TFRC_SSTATE_FBACK)\n\t\tccid3_hc_tx_set_state(sk, TFRC_SSTATE_NO_FBACK);\n\n\t \n\tif (hc->tx_t_rto == 0 || hc->tx_p == 0) {\n\n\t\t \n\t\thc->tx_x = max(hc->tx_x / 2,\n\t\t\t       (((__u64)hc->tx_s) << 6) / TFRC_T_MBI);\n\t\tccid3_update_send_interval(hc);\n\t} else {\n\t\t \n\t\tif (hc->tx_x_calc > (hc->tx_x_recv >> 5))\n\t\t\thc->tx_x_recv =\n\t\t\t\tmax(hc->tx_x_recv / 2,\n\t\t\t\t    (((__u64)hc->tx_s) << 6) / (2*TFRC_T_MBI));\n\t\telse {\n\t\t\thc->tx_x_recv = hc->tx_x_calc;\n\t\t\thc->tx_x_recv <<= 4;\n\t\t}\n\t\tccid3_hc_tx_update_x(sk, NULL);\n\t}\n\tccid3_pr_debug(\"Reduced X to %llu/64 bytes/sec\\n\",\n\t\t\t(unsigned long long)hc->tx_x);\n\n\t \n\tif (unlikely(hc->tx_t_rto == 0))\t \n\t\tt_nfb = TFRC_INITIAL_TIMEOUT;\n\telse\n\t\tt_nfb = max(hc->tx_t_rto, 2 * hc->tx_t_ipi);\n\nrestart_timer:\n\tsk_reset_timer(sk, &hc->tx_no_feedback_timer,\n\t\t\t   jiffies + usecs_to_jiffies(t_nfb));\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n \nstatic int ccid3_hc_tx_send_packet(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tktime_t now = ktime_get_real();\n\ts64 delay;\n\n\t \n\tif (unlikely(skb->len == 0))\n\t\treturn -EBADMSG;\n\n\tif (hc->tx_state == TFRC_SSTATE_NO_SENT) {\n\t\tsk_reset_timer(sk, &hc->tx_no_feedback_timer, (jiffies +\n\t\t\t       usecs_to_jiffies(TFRC_INITIAL_TIMEOUT)));\n\t\thc->tx_last_win_count\t= 0;\n\t\thc->tx_t_last_win_count = now;\n\n\t\t \n\t\thc->tx_t_nom = now;\n\n\t\thc->tx_s = skb->len;\n\n\t\t \n\t\tif (dp->dccps_syn_rtt) {\n\t\t\tccid3_pr_debug(\"SYN RTT = %uus\\n\", dp->dccps_syn_rtt);\n\t\t\thc->tx_rtt  = dp->dccps_syn_rtt;\n\t\t\thc->tx_x    = rfc3390_initial_rate(sk);\n\t\t\thc->tx_t_ld = now;\n\t\t} else {\n\t\t\t \n\t\t\thc->tx_rtt = DCCP_FALLBACK_RTT;\n\t\t\thc->tx_x   = hc->tx_s;\n\t\t\thc->tx_x <<= 6;\n\t\t}\n\t\tccid3_update_send_interval(hc);\n\n\t\tccid3_hc_tx_set_state(sk, TFRC_SSTATE_NO_FBACK);\n\n\t} else {\n\t\tdelay = ktime_us_delta(hc->tx_t_nom, now);\n\t\tccid3_pr_debug(\"delay=%ld\\n\", (long)delay);\n\t\t \n\t\tif (delay >= TFRC_T_DELTA)\n\t\t\treturn (u32)delay / USEC_PER_MSEC;\n\n\t\tccid3_hc_tx_update_win_count(hc, now);\n\t}\n\n\t \n\tdp->dccps_hc_tx_insert_options = 1;\n\tDCCP_SKB_CB(skb)->dccpd_ccval  = hc->tx_last_win_count;\n\n\t \n\thc->tx_t_nom = ktime_add_us(hc->tx_t_nom, hc->tx_t_ipi);\n\treturn CCID_PACKET_SEND_AT_ONCE;\n}\n\nstatic void ccid3_hc_tx_packet_sent(struct sock *sk, unsigned int len)\n{\n\tstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\n\tccid3_hc_tx_update_s(hc, len);\n\n\tif (tfrc_tx_hist_add(&hc->tx_hist, dccp_sk(sk)->dccps_gss))\n\t\tDCCP_CRIT(\"packet history - out of memory!\");\n}\n\nstatic void ccid3_hc_tx_packet_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_hist_entry *acked;\n\tktime_t now;\n\tunsigned long t_nfb;\n\tu32 r_sample;\n\n\t \n\tif (!(DCCP_SKB_CB(skb)->dccpd_type == DCCP_PKT_ACK ||\n\t      DCCP_SKB_CB(skb)->dccpd_type == DCCP_PKT_DATAACK))\n\t\treturn;\n\t \n\tacked = tfrc_tx_hist_find_entry(hc->tx_hist, dccp_hdr_ack_seq(skb));\n\tif (acked == NULL)\n\t\treturn;\n\t \n\ttfrc_tx_hist_purge(&acked->next);\n\n\t \n\tnow\t  = ktime_get_real();\n\tr_sample  = dccp_sample_rtt(sk, ktime_us_delta(now, acked->stamp));\n\thc->tx_rtt = tfrc_ewma(hc->tx_rtt, r_sample, 9);\n\n\t \n\tif (hc->tx_state == TFRC_SSTATE_NO_FBACK) {\n\t\tccid3_hc_tx_set_state(sk, TFRC_SSTATE_FBACK);\n\n\t\tif (hc->tx_t_rto == 0) {\n\t\t\t \n\t\t\thc->tx_x    = rfc3390_initial_rate(sk);\n\t\t\thc->tx_t_ld = now;\n\n\t\t\tccid3_update_send_interval(hc);\n\n\t\t\tgoto done_computing_x;\n\t\t} else if (hc->tx_p == 0) {\n\t\t\t \n\t\t\tgoto done_computing_x;\n\t\t}\n\t}\n\n\t \n\tif (hc->tx_p > 0)\n\t\thc->tx_x_calc = tfrc_calc_x(hc->tx_s, hc->tx_rtt, hc->tx_p);\n\tccid3_hc_tx_update_x(sk, &now);\n\ndone_computing_x:\n\tccid3_pr_debug(\"%s(%p), RTT=%uus (sample=%uus), s=%u, \"\n\t\t\t       \"p=%u, X_calc=%u, X_recv=%u, X=%u\\n\",\n\t\t\t       dccp_role(sk), sk, hc->tx_rtt, r_sample,\n\t\t\t       hc->tx_s, hc->tx_p, hc->tx_x_calc,\n\t\t\t       (unsigned int)(hc->tx_x_recv >> 6),\n\t\t\t       (unsigned int)(hc->tx_x >> 6));\n\n\t \n\tsk_stop_timer(sk, &hc->tx_no_feedback_timer);\n\n\t \n\tsk->sk_write_space(sk);\n\n\t \n\thc->tx_t_rto = max_t(u32, 4 * hc->tx_rtt,\n\t\t\t\t  USEC_PER_SEC/HZ * tcp_rto_min(sk));\n\t \n\tt_nfb = max(hc->tx_t_rto, 2 * hc->tx_t_ipi);\n\n\tccid3_pr_debug(\"%s(%p), Scheduled no feedback timer to \"\n\t\t       \"expire in %lu jiffies (%luus)\\n\",\n\t\t       dccp_role(sk), sk, usecs_to_jiffies(t_nfb), t_nfb);\n\n\tsk_reset_timer(sk, &hc->tx_no_feedback_timer,\n\t\t\t   jiffies + usecs_to_jiffies(t_nfb));\n}\n\nstatic int ccid3_hc_tx_parse_options(struct sock *sk, u8 packet_type,\n\t\t\t\t     u8 option, u8 *optval, u8 optlen)\n{\n\tstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\t__be32 opt_val;\n\n\tswitch (option) {\n\tcase TFRC_OPT_RECEIVE_RATE:\n\tcase TFRC_OPT_LOSS_EVENT_RATE:\n\t\t \n\t\tif (packet_type == DCCP_PKT_DATA)\n\t\t\tbreak;\n\t\tif (unlikely(optlen != 4)) {\n\t\t\tDCCP_WARN(\"%s(%p), invalid len %d for %u\\n\",\n\t\t\t\t  dccp_role(sk), sk, optlen, option);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\topt_val = ntohl(get_unaligned((__be32 *)optval));\n\n\t\tif (option == TFRC_OPT_RECEIVE_RATE) {\n\t\t\t \n\t\t\thc->tx_x_recv = opt_val;\n\t\t\thc->tx_x_recv <<= 6;\n\n\t\t\tccid3_pr_debug(\"%s(%p), RECEIVE_RATE=%u\\n\",\n\t\t\t\t       dccp_role(sk), sk, opt_val);\n\t\t} else {\n\t\t\t \n\t\t\thc->tx_p = tfrc_invert_loss_event_rate(opt_val);\n\n\t\t\tccid3_pr_debug(\"%s(%p), LOSS_EVENT_RATE=%u\\n\",\n\t\t\t\t       dccp_role(sk), sk, opt_val);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ccid3_hc_tx_init(struct ccid *ccid, struct sock *sk)\n{\n\tstruct ccid3_hc_tx_sock *hc = ccid_priv(ccid);\n\n\thc->tx_state = TFRC_SSTATE_NO_SENT;\n\thc->tx_hist  = NULL;\n\thc->sk\t     = sk;\n\ttimer_setup(&hc->tx_no_feedback_timer,\n\t\t    ccid3_hc_tx_no_feedback_timer, 0);\n\treturn 0;\n}\n\nstatic void ccid3_hc_tx_exit(struct sock *sk)\n{\n\tstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\n\tsk_stop_timer(sk, &hc->tx_no_feedback_timer);\n\ttfrc_tx_hist_purge(&hc->tx_hist);\n}\n\nstatic void ccid3_hc_tx_get_info(struct sock *sk, struct tcp_info *info)\n{\n\tinfo->tcpi_rto = ccid3_hc_tx_sk(sk)->tx_t_rto;\n\tinfo->tcpi_rtt = ccid3_hc_tx_sk(sk)->tx_rtt;\n}\n\nstatic int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_CCID_TX_INFO:\n\t\tif (len < sizeof(tfrc))\n\t\t\treturn -EINVAL;\n\t\tmemset(&tfrc, 0, sizeof(tfrc));\n\t\ttfrc.tfrctx_x\t   = hc->tx_x;\n\t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n\t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \n\n \nenum ccid3_fback_type {\n\tCCID3_FBACK_NONE = 0,\n\tCCID3_FBACK_INITIAL,\n\tCCID3_FBACK_PERIODIC,\n\tCCID3_FBACK_PARAM_CHANGE\n};\n\n#ifdef CONFIG_IP_DCCP_CCID3_DEBUG\nstatic const char *ccid3_rx_state_name(enum ccid3_hc_rx_states state)\n{\n\tstatic const char *const ccid3_rx_state_names[] = {\n\t[TFRC_RSTATE_NO_DATA] = \"NO_DATA\",\n\t[TFRC_RSTATE_DATA]    = \"DATA\",\n\t};\n\n\treturn ccid3_rx_state_names[state];\n}\n#endif\n\nstatic void ccid3_hc_rx_set_state(struct sock *sk,\n\t\t\t\t  enum ccid3_hc_rx_states state)\n{\n\tstruct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\n\tenum ccid3_hc_rx_states oldstate = hc->rx_state;\n\n\tccid3_pr_debug(\"%s(%p) %-8.8s -> %s\\n\",\n\t\t       dccp_role(sk), sk, ccid3_rx_state_name(oldstate),\n\t\t       ccid3_rx_state_name(state));\n\tWARN_ON(state == oldstate);\n\thc->rx_state = state;\n}\n\nstatic void ccid3_hc_rx_send_feedback(struct sock *sk,\n\t\t\t\t      const struct sk_buff *skb,\n\t\t\t\t      enum ccid3_fback_type fbtype)\n{\n\tstruct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tktime_t now = ktime_get();\n\ts64 delta = 0;\n\n\tswitch (fbtype) {\n\tcase CCID3_FBACK_INITIAL:\n\t\thc->rx_x_recv = 0;\n\t\thc->rx_pinv   = ~0U;    \n\t\tbreak;\n\tcase CCID3_FBACK_PARAM_CHANGE:\n\t\t \n\t\tif (hc->rx_x_recv > 0)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase CCID3_FBACK_PERIODIC:\n\t\tdelta = ktime_us_delta(now, hc->rx_tstamp_last_feedback);\n\t\tif (delta <= 0)\n\t\t\tdelta = 1;\n\t\thc->rx_x_recv = scaled_div32(hc->rx_bytes_recv, delta);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tccid3_pr_debug(\"Interval %lldusec, X_recv=%u, 1/p=%u\\n\", delta,\n\t\t       hc->rx_x_recv, hc->rx_pinv);\n\n\thc->rx_tstamp_last_feedback = now;\n\thc->rx_last_counter\t    = dccp_hdr(skb)->dccph_ccval;\n\thc->rx_bytes_recv\t    = 0;\n\n\tdp->dccps_hc_rx_insert_options = 1;\n\tdccp_send_ack(sk);\n}\n\nstatic int ccid3_hc_rx_insert_options(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\n\t__be32 x_recv, pinv;\n\n\tif (!(sk->sk_state == DCCP_OPEN || sk->sk_state == DCCP_PARTOPEN))\n\t\treturn 0;\n\n\tif (dccp_packet_without_ack(skb))\n\t\treturn 0;\n\n\tx_recv = htonl(hc->rx_x_recv);\n\tpinv   = htonl(hc->rx_pinv);\n\n\tif (dccp_insert_option(skb, TFRC_OPT_LOSS_EVENT_RATE,\n\t\t\t       &pinv, sizeof(pinv)) ||\n\t    dccp_insert_option(skb, TFRC_OPT_RECEIVE_RATE,\n\t\t\t       &x_recv, sizeof(x_recv)))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic u32 ccid3_first_li(struct sock *sk)\n{\n\tstruct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\n\tu32 x_recv, p;\n\ts64 delta;\n\tu64 fval;\n\n\tif (hc->rx_rtt == 0) {\n\t\tDCCP_WARN(\"No RTT estimate available, using fallback RTT\\n\");\n\t\thc->rx_rtt = DCCP_FALLBACK_RTT;\n\t}\n\n\tdelta = ktime_us_delta(ktime_get(), hc->rx_tstamp_last_feedback);\n\tif (delta <= 0)\n\t\tdelta = 1;\n\tx_recv = scaled_div32(hc->rx_bytes_recv, delta);\n\tif (x_recv == 0) {\t\t \n\t\tDCCP_WARN(\"X_recv==0\\n\");\n\t\tif (hc->rx_x_recv == 0) {\n\t\t\tDCCP_BUG(\"stored value of X_recv is zero\");\n\t\t\treturn ~0U;\n\t\t}\n\t\tx_recv = hc->rx_x_recv;\n\t}\n\n\tfval = scaled_div(hc->rx_s, hc->rx_rtt);\n\tfval = scaled_div32(fval, x_recv);\n\tp = tfrc_calc_x_reverse_lookup(fval);\n\n\tccid3_pr_debug(\"%s(%p), receive rate=%u bytes/s, implied \"\n\t\t       \"loss rate=%u\\n\", dccp_role(sk), sk, x_recv, p);\n\n\treturn p == 0 ? ~0U : scaled_div(1, p);\n}\n\nstatic void ccid3_hc_rx_packet_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\n\tenum ccid3_fback_type do_feedback = CCID3_FBACK_NONE;\n\tconst u64 ndp = dccp_sk(sk)->dccps_options_received.dccpor_ndp;\n\tconst bool is_data_packet = dccp_data_packet(skb);\n\n\tif (unlikely(hc->rx_state == TFRC_RSTATE_NO_DATA)) {\n\t\tif (is_data_packet) {\n\t\t\tconst u32 payload = skb->len - dccp_hdr(skb)->dccph_doff * 4;\n\t\t\tdo_feedback = CCID3_FBACK_INITIAL;\n\t\t\tccid3_hc_rx_set_state(sk, TFRC_RSTATE_DATA);\n\t\t\thc->rx_s = payload;\n\t\t\t \n\t\t}\n\t\tgoto update_records;\n\t}\n\n\tif (tfrc_rx_hist_duplicate(&hc->rx_hist, skb))\n\t\treturn;  \n\n\tif (is_data_packet) {\n\t\tconst u32 payload = skb->len - dccp_hdr(skb)->dccph_doff * 4;\n\t\t \n\t\thc->rx_s = tfrc_ewma(hc->rx_s, payload, 9);\n\t\thc->rx_bytes_recv += payload;\n\t}\n\n\t \n\tif (tfrc_rx_handle_loss(&hc->rx_hist, &hc->rx_li_hist,\n\t\t\t\tskb, ndp, ccid3_first_li, sk)) {\n\t\tdo_feedback = CCID3_FBACK_PARAM_CHANGE;\n\t\tgoto done_receiving;\n\t}\n\n\tif (tfrc_rx_hist_loss_pending(&hc->rx_hist))\n\t\treturn;  \n\n\t \n\tif (unlikely(!is_data_packet))\n\t\tgoto update_records;\n\n\tif (!tfrc_lh_is_initialised(&hc->rx_li_hist)) {\n\t\tconst u32 sample = tfrc_rx_hist_sample_rtt(&hc->rx_hist, skb);\n\t\t \n\t\tif (sample != 0)\n\t\t\thc->rx_rtt = tfrc_ewma(hc->rx_rtt, sample, 9);\n\n\t} else if (tfrc_lh_update_i_mean(&hc->rx_li_hist, skb)) {\n\t\t \n\t\tdo_feedback = CCID3_FBACK_PARAM_CHANGE;\n\t}\n\n\t \n\tif (SUB16(dccp_hdr(skb)->dccph_ccval, hc->rx_last_counter) > 3)\n\t\tdo_feedback = CCID3_FBACK_PERIODIC;\n\nupdate_records:\n\ttfrc_rx_hist_add_packet(&hc->rx_hist, skb, ndp);\n\ndone_receiving:\n\tif (do_feedback)\n\t\tccid3_hc_rx_send_feedback(sk, skb, do_feedback);\n}\n\nstatic int ccid3_hc_rx_init(struct ccid *ccid, struct sock *sk)\n{\n\tstruct ccid3_hc_rx_sock *hc = ccid_priv(ccid);\n\n\thc->rx_state = TFRC_RSTATE_NO_DATA;\n\ttfrc_lh_init(&hc->rx_li_hist);\n\treturn tfrc_rx_hist_alloc(&hc->rx_hist);\n}\n\nstatic void ccid3_hc_rx_exit(struct sock *sk)\n{\n\tstruct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\n\n\ttfrc_rx_hist_purge(&hc->rx_hist);\n\ttfrc_lh_cleanup(&hc->rx_li_hist);\n}\n\nstatic void ccid3_hc_rx_get_info(struct sock *sk, struct tcp_info *info)\n{\n\tinfo->tcpi_ca_state = ccid3_hc_rx_sk(sk)->rx_state;\n\tinfo->tcpi_options  |= TCPI_OPT_TIMESTAMPS;\n\tinfo->tcpi_rcv_rtt  = ccid3_hc_rx_sk(sk)->rx_rtt;\n}\n\nstatic int ccid3_hc_rx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\n\tstruct tfrc_rx_info rx_info;\n\tconst void *val;\n\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_CCID_RX_INFO:\n\t\tif (len < sizeof(rx_info))\n\t\t\treturn -EINVAL;\n\t\trx_info.tfrcrx_x_recv = hc->rx_x_recv;\n\t\trx_info.tfrcrx_rtt    = hc->rx_rtt;\n\t\trx_info.tfrcrx_p      = tfrc_invert_loss_event_rate(hc->rx_pinv);\n\t\tlen = sizeof(rx_info);\n\t\tval = &rx_info;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstruct ccid_operations ccid3_ops = {\n\t.ccid_id\t\t   = DCCPC_CCID3,\n\t.ccid_name\t\t   = \"TCP-Friendly Rate Control\",\n\t.ccid_hc_tx_obj_size\t   = sizeof(struct ccid3_hc_tx_sock),\n\t.ccid_hc_tx_init\t   = ccid3_hc_tx_init,\n\t.ccid_hc_tx_exit\t   = ccid3_hc_tx_exit,\n\t.ccid_hc_tx_send_packet\t   = ccid3_hc_tx_send_packet,\n\t.ccid_hc_tx_packet_sent\t   = ccid3_hc_tx_packet_sent,\n\t.ccid_hc_tx_packet_recv\t   = ccid3_hc_tx_packet_recv,\n\t.ccid_hc_tx_parse_options  = ccid3_hc_tx_parse_options,\n\t.ccid_hc_rx_obj_size\t   = sizeof(struct ccid3_hc_rx_sock),\n\t.ccid_hc_rx_init\t   = ccid3_hc_rx_init,\n\t.ccid_hc_rx_exit\t   = ccid3_hc_rx_exit,\n\t.ccid_hc_rx_insert_options = ccid3_hc_rx_insert_options,\n\t.ccid_hc_rx_packet_recv\t   = ccid3_hc_rx_packet_recv,\n\t.ccid_hc_rx_get_info\t   = ccid3_hc_rx_get_info,\n\t.ccid_hc_tx_get_info\t   = ccid3_hc_tx_get_info,\n\t.ccid_hc_rx_getsockopt\t   = ccid3_hc_rx_getsockopt,\n\t.ccid_hc_tx_getsockopt\t   = ccid3_hc_tx_getsockopt,\n};\n\n#ifdef CONFIG_IP_DCCP_CCID3_DEBUG\nmodule_param(ccid3_debug, bool, 0644);\nMODULE_PARM_DESC(ccid3_debug, \"Enable CCID-3 debug messages\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}