{
  "module_name": "packet_history.c",
  "hash_id": "5705197f748f1dca9eb1f0429949ff4bab60d340d27f4f0f902d8d747d6bd5a9",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/ccids/lib/packet_history.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/slab.h>\n#include \"packet_history.h\"\n#include \"../../dccp.h\"\n\n \nstatic struct kmem_cache *tfrc_tx_hist_slab;\n\nint __init tfrc_tx_packet_history_init(void)\n{\n\ttfrc_tx_hist_slab = kmem_cache_create(\"tfrc_tx_hist\",\n\t\t\t\t\t      sizeof(struct tfrc_tx_hist_entry),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN, NULL);\n\treturn tfrc_tx_hist_slab == NULL ? -ENOBUFS : 0;\n}\n\nvoid tfrc_tx_packet_history_exit(void)\n{\n\tif (tfrc_tx_hist_slab != NULL) {\n\t\tkmem_cache_destroy(tfrc_tx_hist_slab);\n\t\ttfrc_tx_hist_slab = NULL;\n\t}\n}\n\nint tfrc_tx_hist_add(struct tfrc_tx_hist_entry **headp, u64 seqno)\n{\n\tstruct tfrc_tx_hist_entry *entry = kmem_cache_alloc(tfrc_tx_hist_slab, gfp_any());\n\n\tif (entry == NULL)\n\t\treturn -ENOBUFS;\n\tentry->seqno = seqno;\n\tentry->stamp = ktime_get_real();\n\tentry->next  = *headp;\n\t*headp\t     = entry;\n\treturn 0;\n}\n\nvoid tfrc_tx_hist_purge(struct tfrc_tx_hist_entry **headp)\n{\n\tstruct tfrc_tx_hist_entry *head = *headp;\n\n\twhile (head != NULL) {\n\t\tstruct tfrc_tx_hist_entry *next = head->next;\n\n\t\tkmem_cache_free(tfrc_tx_hist_slab, head);\n\t\thead = next;\n\t}\n\n\t*headp = NULL;\n}\n\n \nstatic struct kmem_cache *tfrc_rx_hist_slab;\n\nint __init tfrc_rx_packet_history_init(void)\n{\n\ttfrc_rx_hist_slab = kmem_cache_create(\"tfrc_rxh_cache\",\n\t\t\t\t\t      sizeof(struct tfrc_rx_hist_entry),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN, NULL);\n\treturn tfrc_rx_hist_slab == NULL ? -ENOBUFS : 0;\n}\n\nvoid tfrc_rx_packet_history_exit(void)\n{\n\tif (tfrc_rx_hist_slab != NULL) {\n\t\tkmem_cache_destroy(tfrc_rx_hist_slab);\n\t\ttfrc_rx_hist_slab = NULL;\n\t}\n}\n\nstatic inline void tfrc_rx_hist_entry_from_skb(struct tfrc_rx_hist_entry *entry,\n\t\t\t\t\t       const struct sk_buff *skb,\n\t\t\t\t\t       const u64 ndp)\n{\n\tconst struct dccp_hdr *dh = dccp_hdr(skb);\n\n\tentry->tfrchrx_seqno = DCCP_SKB_CB(skb)->dccpd_seq;\n\tentry->tfrchrx_ccval = dh->dccph_ccval;\n\tentry->tfrchrx_type  = dh->dccph_type;\n\tentry->tfrchrx_ndp   = ndp;\n\tentry->tfrchrx_tstamp = ktime_get_real();\n}\n\nvoid tfrc_rx_hist_add_packet(struct tfrc_rx_hist *h,\n\t\t\t     const struct sk_buff *skb,\n\t\t\t     const u64 ndp)\n{\n\tstruct tfrc_rx_hist_entry *entry = tfrc_rx_hist_last_rcv(h);\n\n\ttfrc_rx_hist_entry_from_skb(entry, skb, ndp);\n}\n\n \nint tfrc_rx_hist_duplicate(struct tfrc_rx_hist *h, struct sk_buff *skb)\n{\n\tconst u64 seq = DCCP_SKB_CB(skb)->dccpd_seq;\n\tint i;\n\n\tif (dccp_delta_seqno(tfrc_rx_hist_loss_prev(h)->tfrchrx_seqno, seq) <= 0)\n\t\treturn 1;\n\n\tfor (i = 1; i <= h->loss_count; i++)\n\t\tif (tfrc_rx_hist_entry(h, i)->tfrchrx_seqno == seq)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void tfrc_rx_hist_swap(struct tfrc_rx_hist *h, const u8 a, const u8 b)\n{\n\tconst u8 idx_a = tfrc_rx_hist_index(h, a),\n\t\t idx_b = tfrc_rx_hist_index(h, b);\n\n\tswap(h->ring[idx_a], h->ring[idx_b]);\n}\n\n \nstatic void __do_track_loss(struct tfrc_rx_hist *h, struct sk_buff *skb, u64 n1)\n{\n\tu64 s0 = tfrc_rx_hist_loss_prev(h)->tfrchrx_seqno,\n\t    s1 = DCCP_SKB_CB(skb)->dccpd_seq;\n\n\tif (!dccp_loss_free(s0, s1, n1)) {\t \n\t\th->loss_count = 1;\n\t\ttfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 1), skb, n1);\n\t}\n}\n\nstatic void __one_after_loss(struct tfrc_rx_hist *h, struct sk_buff *skb, u32 n2)\n{\n\tu64 s0 = tfrc_rx_hist_loss_prev(h)->tfrchrx_seqno,\n\t    s1 = tfrc_rx_hist_entry(h, 1)->tfrchrx_seqno,\n\t    s2 = DCCP_SKB_CB(skb)->dccpd_seq;\n\n\tif (likely(dccp_delta_seqno(s1, s2) > 0)) {\t \n\t\th->loss_count = 2;\n\t\ttfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 2), skb, n2);\n\t\treturn;\n\t}\n\n\t \n\n\tif (dccp_loss_free(s0, s2, n2)) {\n\t\tu64 n1 = tfrc_rx_hist_entry(h, 1)->tfrchrx_ndp;\n\n\t\tif (dccp_loss_free(s2, s1, n1)) {\n\t\t\t \n\t\t\th->loss_count = 0;\n\t\t\th->loss_start = tfrc_rx_hist_index(h, 1);\n\t\t} else\n\t\t\t \n\t\t\ttfrc_rx_hist_entry_from_skb(tfrc_rx_hist_loss_prev(h), skb, n2);\n\n\t} else {\t \n\t\t \n\t\ttfrc_rx_hist_swap(h, 0, 3);\n\t\th->loss_start = tfrc_rx_hist_index(h, 3);\n\t\ttfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 1), skb, n2);\n\t\th->loss_count = 2;\n\t}\n}\n\n \nstatic int __two_after_loss(struct tfrc_rx_hist *h, struct sk_buff *skb, u32 n3)\n{\n\tu64 s0 = tfrc_rx_hist_loss_prev(h)->tfrchrx_seqno,\n\t    s1 = tfrc_rx_hist_entry(h, 1)->tfrchrx_seqno,\n\t    s2 = tfrc_rx_hist_entry(h, 2)->tfrchrx_seqno,\n\t    s3 = DCCP_SKB_CB(skb)->dccpd_seq;\n\n\tif (likely(dccp_delta_seqno(s2, s3) > 0)) {\t \n\t\th->loss_count = 3;\n\t\ttfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 3), skb, n3);\n\t\treturn 1;\n\t}\n\n\t \n\n\tif (dccp_delta_seqno(s1, s3) > 0) {\t\t \n\t\t \n\t\ttfrc_rx_hist_swap(h, 2, 3);\n\t\ttfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 2), skb, n3);\n\t\th->loss_count = 3;\n\t\treturn 1;\n\t}\n\n\t \n\n\tif (dccp_loss_free(s0, s3, n3)) {\n\t\tu64 n1 = tfrc_rx_hist_entry(h, 1)->tfrchrx_ndp;\n\n\t\tif (dccp_loss_free(s3, s1, n1)) {\n\t\t\t \n\t\t\tu64 n2 = tfrc_rx_hist_entry(h, 2)->tfrchrx_ndp;\n\n\t\t\tif (dccp_loss_free(s1, s2, n2)) {\n\t\t\t\t \n\t\t\t\th->loss_start = tfrc_rx_hist_index(h, 2);\n\t\t\t\th->loss_count = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\th->loss_start = tfrc_rx_hist_index(h, 1);\n\t\t\t\th->loss_count = 1;\n\t\t\t}\n\n\t\t} else  \n\t\t\ttfrc_rx_hist_entry_from_skb(tfrc_rx_hist_loss_prev(h), skb, n3);\n\n\t\treturn 0;\n\t}\n\n\t \n\ttfrc_rx_hist_swap(h, 0, 3);\n\th->loss_start = tfrc_rx_hist_index(h, 3);\n\ttfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 1), skb, n3);\n\th->loss_count = 3;\n\n\treturn 1;\n}\n\n \nstatic void __three_after_loss(struct tfrc_rx_hist *h)\n{\n\t \n\tu64 s1 = tfrc_rx_hist_entry(h, 1)->tfrchrx_seqno,\n\t    s2 = tfrc_rx_hist_entry(h, 2)->tfrchrx_seqno,\n\t    s3 = tfrc_rx_hist_entry(h, 3)->tfrchrx_seqno;\n\tu64 n2 = tfrc_rx_hist_entry(h, 2)->tfrchrx_ndp,\n\t    n3 = tfrc_rx_hist_entry(h, 3)->tfrchrx_ndp;\n\n\tif (dccp_loss_free(s1, s2, n2)) {\n\n\t\tif (dccp_loss_free(s2, s3, n3)) {\n\t\t\t \n\t\t\th->loss_start = tfrc_rx_hist_index(h, 3);\n\t\t\th->loss_count = 0;\n\t\t} else {\n\t\t\t \n\t\t\th->loss_start = tfrc_rx_hist_index(h, 2);\n\t\t\th->loss_count = 1;\n\t\t}\n\n\t} else {\t \n\t\th->loss_start = tfrc_rx_hist_index(h, 1);\n\t\th->loss_count = 2;\n\t}\n}\n\n \nint tfrc_rx_handle_loss(struct tfrc_rx_hist *h,\n\t\t\tstruct tfrc_loss_hist *lh,\n\t\t\tstruct sk_buff *skb, const u64 ndp,\n\t\t\tu32 (*calc_first_li)(struct sock *), struct sock *sk)\n{\n\tint is_new_loss = 0;\n\n\tif (h->loss_count == 0) {\n\t\t__do_track_loss(h, skb, ndp);\n\t} else if (h->loss_count == 1) {\n\t\t__one_after_loss(h, skb, ndp);\n\t} else if (h->loss_count != 2) {\n\t\tDCCP_BUG(\"invalid loss_count %d\", h->loss_count);\n\t} else if (__two_after_loss(h, skb, ndp)) {\n\t\t \n\t\tis_new_loss = tfrc_lh_interval_add(lh, h, calc_first_li, sk);\n\t\t__three_after_loss(h);\n\t}\n\treturn is_new_loss;\n}\n\nint tfrc_rx_hist_alloc(struct tfrc_rx_hist *h)\n{\n\tint i;\n\n\tfor (i = 0; i <= TFRC_NDUPACK; i++) {\n\t\th->ring[i] = kmem_cache_alloc(tfrc_rx_hist_slab, GFP_ATOMIC);\n\t\tif (h->ring[i] == NULL)\n\t\t\tgoto out_free;\n\t}\n\n\th->loss_count = h->loss_start = 0;\n\treturn 0;\n\nout_free:\n\twhile (i-- != 0) {\n\t\tkmem_cache_free(tfrc_rx_hist_slab, h->ring[i]);\n\t\th->ring[i] = NULL;\n\t}\n\treturn -ENOBUFS;\n}\n\nvoid tfrc_rx_hist_purge(struct tfrc_rx_hist *h)\n{\n\tint i;\n\n\tfor (i = 0; i <= TFRC_NDUPACK; ++i)\n\t\tif (h->ring[i] != NULL) {\n\t\t\tkmem_cache_free(tfrc_rx_hist_slab, h->ring[i]);\n\t\t\th->ring[i] = NULL;\n\t\t}\n}\n\n \nstatic inline struct tfrc_rx_hist_entry *\n\t\t\ttfrc_rx_hist_rtt_last_s(const struct tfrc_rx_hist *h)\n{\n\treturn h->ring[0];\n}\n\n \nstatic inline struct tfrc_rx_hist_entry *\n\t\t\ttfrc_rx_hist_rtt_prev_s(const struct tfrc_rx_hist *h)\n{\n\treturn h->ring[h->rtt_sample_prev];\n}\n\n \nu32 tfrc_rx_hist_sample_rtt(struct tfrc_rx_hist *h, const struct sk_buff *skb)\n{\n\tu32 sample = 0,\n\t    delta_v = SUB16(dccp_hdr(skb)->dccph_ccval,\n\t\t\t    tfrc_rx_hist_rtt_last_s(h)->tfrchrx_ccval);\n\n\tif (delta_v < 1 || delta_v > 4) {\t \n\t\tif (h->rtt_sample_prev == 2) {\t \n\t\t\tsample = SUB16(tfrc_rx_hist_rtt_prev_s(h)->tfrchrx_ccval,\n\t\t\t\t       tfrc_rx_hist_rtt_last_s(h)->tfrchrx_ccval);\n\t\t\tif (sample)\n\t\t\t\tsample = 4 / sample *\n\t\t\t\t         ktime_us_delta(tfrc_rx_hist_rtt_prev_s(h)->tfrchrx_tstamp,\n\t\t\t\t\t\t\ttfrc_rx_hist_rtt_last_s(h)->tfrchrx_tstamp);\n\t\t\telse     \n\t\t\t\tDCCP_BUG(\"please report to dccp@vger.kernel.org\"\n\t\t\t\t\t \" => prev = %u, last = %u\",\n\t\t\t\t\t tfrc_rx_hist_rtt_prev_s(h)->tfrchrx_ccval,\n\t\t\t\t\t tfrc_rx_hist_rtt_last_s(h)->tfrchrx_ccval);\n\t\t} else if (delta_v < 1) {\n\t\t\th->rtt_sample_prev = 1;\n\t\t\tgoto keep_ref_for_next_time;\n\t\t}\n\n\t} else if (delta_v == 4)  \n\t\tsample = ktime_to_us(net_timedelta(tfrc_rx_hist_rtt_last_s(h)->tfrchrx_tstamp));\n\telse {\t\t\t  \n\t\th->rtt_sample_prev = 2;\n\t\tgoto keep_ref_for_next_time;\n\t}\n\n\tif (unlikely(sample > DCCP_SANE_RTT_MAX)) {\n\t\tDCCP_WARN(\"RTT sample %u too large, using max\\n\", sample);\n\t\tsample = DCCP_SANE_RTT_MAX;\n\t}\n\n\th->rtt_sample_prev = 0;\t        \nkeep_ref_for_next_time:\n\n\treturn sample;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}