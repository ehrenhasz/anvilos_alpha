{
  "module_name": "loss_interval.c",
  "hash_id": "d2b552c74c07d584a3d1a06205629e953f26ea0767a51abd84072869e0364614",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/ccids/lib/loss_interval.c",
  "human_readable_source": "\n \n#include <net/sock.h>\n#include \"tfrc.h\"\n\nstatic struct kmem_cache  *tfrc_lh_slab  __read_mostly;\n \nstatic const int tfrc_lh_weights[NINTERVAL] = { 10, 10, 10, 10, 8, 6, 4, 2 };\n\n \nstatic inline u8 LIH_INDEX(const u8 ctr)\n{\n\treturn LIH_SIZE - 1 - (ctr % LIH_SIZE);\n}\n\n \nstatic inline struct tfrc_loss_interval *tfrc_lh_peek(struct tfrc_loss_hist *lh)\n{\n\treturn lh->counter ? lh->ring[LIH_INDEX(lh->counter - 1)] : NULL;\n}\n\n \nstatic inline u32 tfrc_lh_get_interval(struct tfrc_loss_hist *lh, const u8 i)\n{\n\tBUG_ON(i >= lh->counter);\n\treturn lh->ring[LIH_INDEX(lh->counter - i - 1)]->li_length;\n}\n\n \nstatic struct tfrc_loss_interval *tfrc_lh_demand_next(struct tfrc_loss_hist *lh)\n{\n\tif (lh->ring[LIH_INDEX(lh->counter)] == NULL)\n\t\tlh->ring[LIH_INDEX(lh->counter)] = kmem_cache_alloc(tfrc_lh_slab,\n\t\t\t\t\t\t\t\t    GFP_ATOMIC);\n\treturn lh->ring[LIH_INDEX(lh->counter)];\n}\n\nvoid tfrc_lh_cleanup(struct tfrc_loss_hist *lh)\n{\n\tif (!tfrc_lh_is_initialised(lh))\n\t\treturn;\n\n\tfor (lh->counter = 0; lh->counter < LIH_SIZE; lh->counter++)\n\t\tif (lh->ring[LIH_INDEX(lh->counter)] != NULL) {\n\t\t\tkmem_cache_free(tfrc_lh_slab,\n\t\t\t\t\tlh->ring[LIH_INDEX(lh->counter)]);\n\t\t\tlh->ring[LIH_INDEX(lh->counter)] = NULL;\n\t\t}\n}\n\nstatic void tfrc_lh_calc_i_mean(struct tfrc_loss_hist *lh)\n{\n\tu32 i_i, i_tot0 = 0, i_tot1 = 0, w_tot = 0;\n\tint i, k = tfrc_lh_length(lh) - 1;  \n\n\tif (k <= 0)\n\t\treturn;\n\n\tfor (i = 0; i <= k; i++) {\n\t\ti_i = tfrc_lh_get_interval(lh, i);\n\n\t\tif (i < k) {\n\t\t\ti_tot0 += i_i * tfrc_lh_weights[i];\n\t\t\tw_tot  += tfrc_lh_weights[i];\n\t\t}\n\t\tif (i > 0)\n\t\t\ti_tot1 += i_i * tfrc_lh_weights[i-1];\n\t}\n\n\tlh->i_mean = max(i_tot0, i_tot1) / w_tot;\n}\n\n \nu8 tfrc_lh_update_i_mean(struct tfrc_loss_hist *lh, struct sk_buff *skb)\n{\n\tstruct tfrc_loss_interval *cur = tfrc_lh_peek(lh);\n\tu32 old_i_mean = lh->i_mean;\n\ts64 len;\n\n\tif (cur == NULL)\t\t\t \n\t\treturn 0;\n\n\tlen = dccp_delta_seqno(cur->li_seqno, DCCP_SKB_CB(skb)->dccpd_seq) + 1;\n\n\tif (len - (s64)cur->li_length <= 0)\t \n\t\treturn 0;\n\n\tif (SUB16(dccp_hdr(skb)->dccph_ccval, cur->li_ccval) > 4)\n\t\t \n\t\tcur->li_is_closed = 1;\n\n\tif (tfrc_lh_length(lh) == 1)\t\t \n\t\treturn 0;\n\n\tcur->li_length = len;\n\ttfrc_lh_calc_i_mean(lh);\n\n\treturn lh->i_mean < old_i_mean;\n}\n\n \nstatic inline u8 tfrc_lh_is_new_loss(struct tfrc_loss_interval *cur,\n\t\t\t\t     struct tfrc_rx_hist_entry *new_loss)\n{\n\treturn\tdccp_delta_seqno(cur->li_seqno, new_loss->tfrchrx_seqno) > 0 &&\n\t\t(cur->li_is_closed || SUB16(new_loss->tfrchrx_ccval, cur->li_ccval) > 4);\n}\n\n \nint tfrc_lh_interval_add(struct tfrc_loss_hist *lh, struct tfrc_rx_hist *rh,\n\t\t\t u32 (*calc_first_li)(struct sock *), struct sock *sk)\n{\n\tstruct tfrc_loss_interval *cur = tfrc_lh_peek(lh), *new;\n\n\tif (cur != NULL && !tfrc_lh_is_new_loss(cur, tfrc_rx_hist_loss_prev(rh)))\n\t\treturn 0;\n\n\tnew = tfrc_lh_demand_next(lh);\n\tif (unlikely(new == NULL)) {\n\t\tDCCP_CRIT(\"Cannot allocate/add loss record.\");\n\t\treturn 0;\n\t}\n\n\tnew->li_seqno\t  = tfrc_rx_hist_loss_prev(rh)->tfrchrx_seqno;\n\tnew->li_ccval\t  = tfrc_rx_hist_loss_prev(rh)->tfrchrx_ccval;\n\tnew->li_is_closed = 0;\n\n\tif (++lh->counter == 1)\n\t\tlh->i_mean = new->li_length = (*calc_first_li)(sk);\n\telse {\n\t\tcur->li_length = dccp_delta_seqno(cur->li_seqno, new->li_seqno);\n\t\tnew->li_length = dccp_delta_seqno(new->li_seqno,\n\t\t\t\t  tfrc_rx_hist_last_rcv(rh)->tfrchrx_seqno) + 1;\n\t\tif (lh->counter > (2*LIH_SIZE))\n\t\t\tlh->counter -= LIH_SIZE;\n\n\t\ttfrc_lh_calc_i_mean(lh);\n\t}\n\treturn 1;\n}\n\nint __init tfrc_li_init(void)\n{\n\ttfrc_lh_slab = kmem_cache_create(\"tfrc_li_hist\",\n\t\t\t\t\t sizeof(struct tfrc_loss_interval), 0,\n\t\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\treturn tfrc_lh_slab == NULL ? -ENOBUFS : 0;\n}\n\nvoid tfrc_li_exit(void)\n{\n\tif (tfrc_lh_slab != NULL) {\n\t\tkmem_cache_destroy(tfrc_lh_slab);\n\t\ttfrc_lh_slab = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}