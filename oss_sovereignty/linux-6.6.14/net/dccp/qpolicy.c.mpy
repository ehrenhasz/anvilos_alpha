{
  "module_name": "qpolicy.c",
  "hash_id": "3ec57ec63ebcb325b6aa9965e00cc6923b74278b113f9abecee02cfaee2cf44a",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/qpolicy.c",
  "human_readable_source": "\n \n#include \"dccp.h\"\n\n \nstatic void qpolicy_simple_push(struct sock *sk, struct sk_buff *skb)\n{\n\tskb_queue_tail(&sk->sk_write_queue, skb);\n}\n\nstatic bool qpolicy_simple_full(struct sock *sk)\n{\n\treturn dccp_sk(sk)->dccps_tx_qlen &&\n\t       sk->sk_write_queue.qlen >= dccp_sk(sk)->dccps_tx_qlen;\n}\n\nstatic struct sk_buff *qpolicy_simple_top(struct sock *sk)\n{\n\treturn skb_peek(&sk->sk_write_queue);\n}\n\n \nstatic struct sk_buff *qpolicy_prio_best_skb(struct sock *sk)\n{\n\tstruct sk_buff *skb, *best = NULL;\n\n\tskb_queue_walk(&sk->sk_write_queue, skb)\n\t\tif (best == NULL || skb->priority > best->priority)\n\t\t\tbest = skb;\n\treturn best;\n}\n\nstatic struct sk_buff *qpolicy_prio_worst_skb(struct sock *sk)\n{\n\tstruct sk_buff *skb, *worst = NULL;\n\n\tskb_queue_walk(&sk->sk_write_queue, skb)\n\t\tif (worst == NULL || skb->priority < worst->priority)\n\t\t\tworst = skb;\n\treturn worst;\n}\n\nstatic bool qpolicy_prio_full(struct sock *sk)\n{\n\tif (qpolicy_simple_full(sk))\n\t\tdccp_qpolicy_drop(sk, qpolicy_prio_worst_skb(sk));\n\treturn false;\n}\n\n \nstruct dccp_qpolicy_operations {\n\tvoid\t\t(*push)\t(struct sock *sk, struct sk_buff *skb);\n\tbool\t\t(*full) (struct sock *sk);\n\tstruct sk_buff*\t(*top)  (struct sock *sk);\n\t__be32\t\tparams;\n};\n\nstatic struct dccp_qpolicy_operations qpol_table[DCCPQ_POLICY_MAX] = {\n\t[DCCPQ_POLICY_SIMPLE] = {\n\t\t.push   = qpolicy_simple_push,\n\t\t.full   = qpolicy_simple_full,\n\t\t.top    = qpolicy_simple_top,\n\t\t.params = 0,\n\t},\n\t[DCCPQ_POLICY_PRIO] = {\n\t\t.push   = qpolicy_simple_push,\n\t\t.full   = qpolicy_prio_full,\n\t\t.top    = qpolicy_prio_best_skb,\n\t\t.params = DCCP_SCM_PRIORITY,\n\t},\n};\n\n \nvoid dccp_qpolicy_push(struct sock *sk, struct sk_buff *skb)\n{\n\tqpol_table[dccp_sk(sk)->dccps_qpolicy].push(sk, skb);\n}\n\nbool dccp_qpolicy_full(struct sock *sk)\n{\n\treturn qpol_table[dccp_sk(sk)->dccps_qpolicy].full(sk);\n}\n\nvoid dccp_qpolicy_drop(struct sock *sk, struct sk_buff *skb)\n{\n\tif (skb != NULL) {\n\t\tskb_unlink(skb, &sk->sk_write_queue);\n\t\tkfree_skb(skb);\n\t}\n}\n\nstruct sk_buff *dccp_qpolicy_top(struct sock *sk)\n{\n\treturn qpol_table[dccp_sk(sk)->dccps_qpolicy].top(sk);\n}\n\nstruct sk_buff *dccp_qpolicy_pop(struct sock *sk)\n{\n\tstruct sk_buff *skb = dccp_qpolicy_top(sk);\n\n\tif (skb != NULL) {\n\t\t \n\t\tskb->priority = 0;\n\t\tskb_unlink(skb, &sk->sk_write_queue);\n\t}\n\treturn skb;\n}\n\nbool dccp_qpolicy_param_ok(struct sock *sk, __be32 param)\n{\n\t \n\tif (!param || (param & (param - 1)))\n\t\treturn false;\n\treturn (qpol_table[dccp_sk(sk)->dccps_qpolicy].params & param) == param;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}