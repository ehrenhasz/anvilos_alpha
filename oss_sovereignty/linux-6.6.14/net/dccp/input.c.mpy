{
  "module_name": "input.c",
  "hash_id": "e762797fc664b26a11cf97675743a5317dbe04076577793afc13323805ba2eff",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/input.c",
  "human_readable_source": "\n \n\n#include <linux/dccp.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n\n#include <net/sock.h>\n\n#include \"ackvec.h\"\n#include \"ccid.h\"\n#include \"dccp.h\"\n\n \nint sysctl_dccp_sync_ratelimit\t__read_mostly = HZ / 8;\n\nstatic void dccp_enqueue_skb(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_pull(skb, dccp_hdr(skb)->dccph_doff * 4);\n\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\tskb_set_owner_r(skb, sk);\n\tsk->sk_data_ready(sk);\n}\n\nstatic void dccp_fin(struct sock *sk, struct sk_buff *skb)\n{\n\t \n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsock_set_flag(sk, SOCK_DONE);\n\tdccp_enqueue_skb(sk, skb);\n}\n\nstatic int dccp_rcv_close(struct sock *sk, struct sk_buff *skb)\n{\n\tint queued = 0;\n\n\tswitch (sk->sk_state) {\n\t \n\tcase DCCP_CLOSING:\n\t\t \n\t\tif (dccp_sk(sk)->dccps_role != DCCP_ROLE_CLIENT)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase DCCP_REQUESTING:\n\tcase DCCP_ACTIVE_CLOSEREQ:\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_CLOSED);\n\t\tdccp_done(sk);\n\t\tbreak;\n\tcase DCCP_OPEN:\n\tcase DCCP_PARTOPEN:\n\t\t \n\t\tqueued = 1;\n\t\tdccp_fin(sk, skb);\n\t\tdccp_set_state(sk, DCCP_PASSIVE_CLOSE);\n\t\tfallthrough;\n\tcase DCCP_PASSIVE_CLOSE:\n\t\t \n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t}\n\treturn queued;\n}\n\nstatic int dccp_rcv_closereq(struct sock *sk, struct sk_buff *skb)\n{\n\tint queued = 0;\n\n\t \n\tif (dccp_sk(sk)->dccps_role != DCCP_ROLE_CLIENT) {\n\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq, DCCP_PKT_SYNC);\n\t\treturn queued;\n\t}\n\n\t \n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tdccp_send_close(sk, 0);\n\t\tdccp_set_state(sk, DCCP_CLOSING);\n\t\tbreak;\n\tcase DCCP_OPEN:\n\tcase DCCP_PARTOPEN:\n\t\t \n\t\tqueued = 1;\n\t\tdccp_fin(sk, skb);\n\t\tdccp_set_state(sk, DCCP_PASSIVE_CLOSEREQ);\n\t\tfallthrough;\n\tcase DCCP_PASSIVE_CLOSEREQ:\n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t}\n\treturn queued;\n}\n\nstatic u16 dccp_reset_code_convert(const u8 code)\n{\n\tstatic const u16 error_code[] = {\n\t[DCCP_RESET_CODE_CLOSED]\t     = 0,\t \n\t[DCCP_RESET_CODE_UNSPECIFIED]\t     = 0,\t \n\t[DCCP_RESET_CODE_ABORTED]\t     = ECONNRESET,\n\n\t[DCCP_RESET_CODE_NO_CONNECTION]\t     = ECONNREFUSED,\n\t[DCCP_RESET_CODE_CONNECTION_REFUSED] = ECONNREFUSED,\n\t[DCCP_RESET_CODE_TOO_BUSY]\t     = EUSERS,\n\t[DCCP_RESET_CODE_AGGRESSION_PENALTY] = EDQUOT,\n\n\t[DCCP_RESET_CODE_PACKET_ERROR]\t     = ENOMSG,\n\t[DCCP_RESET_CODE_BAD_INIT_COOKIE]    = EBADR,\n\t[DCCP_RESET_CODE_BAD_SERVICE_CODE]   = EBADRQC,\n\t[DCCP_RESET_CODE_OPTION_ERROR]\t     = EILSEQ,\n\t[DCCP_RESET_CODE_MANDATORY_ERROR]    = EOPNOTSUPP,\n\t};\n\n\treturn code >= DCCP_MAX_RESET_CODES ? 0 : error_code[code];\n}\n\nstatic void dccp_rcv_reset(struct sock *sk, struct sk_buff *skb)\n{\n\tu16 err = dccp_reset_code_convert(dccp_hdr_reset(skb)->dccph_reset_code);\n\n\tsk->sk_err = err;\n\n\t \n\tdccp_fin(sk, skb);\n\n\tif (err && !sock_flag(sk, SOCK_DEAD))\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_ERR);\n\tdccp_time_wait(sk, DCCP_TIME_WAIT, 0);\n}\n\nstatic void dccp_handle_ackvec_processing(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_ackvec *av = dccp_sk(sk)->dccps_hc_rx_ackvec;\n\n\tif (av == NULL)\n\t\treturn;\n\tif (DCCP_SKB_CB(skb)->dccpd_ack_seq != DCCP_PKT_WITHOUT_ACK_SEQ)\n\t\tdccp_ackvec_clear_state(av, DCCP_SKB_CB(skb)->dccpd_ack_seq);\n\tdccp_ackvec_input(av, skb);\n}\n\nstatic void dccp_deliver_input_to_ccids(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\n\t \n\tif (!(sk->sk_shutdown & RCV_SHUTDOWN))\n\t\tccid_hc_rx_packet_recv(dp->dccps_hc_rx_ccid, sk, skb);\n\t \n\tif (sk->sk_write_queue.qlen > 0 || !(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\tccid_hc_tx_packet_recv(dp->dccps_hc_tx_ccid, sk, skb);\n}\n\nstatic int dccp_check_seqno(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh = dccp_hdr(skb);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tu64 lswl, lawl, seqno = DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\tackno = DCCP_SKB_CB(skb)->dccpd_ack_seq;\n\n\t \n\tif (dh->dccph_type == DCCP_PKT_SYNC ||\n\t    dh->dccph_type == DCCP_PKT_SYNCACK) {\n\t\tif (between48(ackno, dp->dccps_awl, dp->dccps_awh) &&\n\t\t    dccp_delta_seqno(dp->dccps_swl, seqno) >= 0)\n\t\t\tdccp_update_gsr(sk, seqno);\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t \n\tlswl = dp->dccps_swl;\n\tlawl = dp->dccps_awl;\n\n\tif (dh->dccph_type == DCCP_PKT_CLOSEREQ ||\n\t    dh->dccph_type == DCCP_PKT_CLOSE ||\n\t    dh->dccph_type == DCCP_PKT_RESET) {\n\t\tlswl = ADD48(dp->dccps_gsr, 1);\n\t\tlawl = dp->dccps_gar;\n\t}\n\n\tif (between48(seqno, lswl, dp->dccps_swh) &&\n\t    (ackno == DCCP_PKT_WITHOUT_ACK_SEQ ||\n\t     between48(ackno, lawl, dp->dccps_awh))) {\n\t\tdccp_update_gsr(sk, seqno);\n\n\t\tif (dh->dccph_type != DCCP_PKT_SYNC &&\n\t\t    ackno != DCCP_PKT_WITHOUT_ACK_SEQ &&\n\t\t    after48(ackno, dp->dccps_gar))\n\t\t\tdp->dccps_gar = ackno;\n\t} else {\n\t\tunsigned long now = jiffies;\n\t\t \n\t\tif (time_before(now, (dp->dccps_rate_last +\n\t\t\t\t      sysctl_dccp_sync_ratelimit)))\n\t\t\treturn -1;\n\n\t\tDCCP_WARN(\"Step 6 failed for %s packet, \"\n\t\t\t  \"(LSWL(%llu) <= P.seqno(%llu) <= S.SWH(%llu)) and \"\n\t\t\t  \"(P.ackno %s or LAWL(%llu) <= P.ackno(%llu) <= S.AWH(%llu), \"\n\t\t\t  \"sending SYNC...\\n\",  dccp_packet_name(dh->dccph_type),\n\t\t\t  (unsigned long long) lswl, (unsigned long long) seqno,\n\t\t\t  (unsigned long long) dp->dccps_swh,\n\t\t\t  (ackno == DCCP_PKT_WITHOUT_ACK_SEQ) ? \"doesn't exist\"\n\t\t\t\t\t\t\t      : \"exists\",\n\t\t\t  (unsigned long long) lawl, (unsigned long long) ackno,\n\t\t\t  (unsigned long long) dp->dccps_awh);\n\n\t\tdp->dccps_rate_last = now;\n\n\t\tif (dh->dccph_type == DCCP_PKT_RESET)\n\t\t\tseqno = dp->dccps_gsr;\n\t\tdccp_send_sync(sk, seqno, DCCP_PKT_SYNC);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int __dccp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  const struct dccp_hdr *dh, const unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\tswitch (dccp_hdr(skb)->dccph_type) {\n\tcase DCCP_PKT_DATAACK:\n\tcase DCCP_PKT_DATA:\n\t\t \n\t\tdccp_enqueue_skb(sk, skb);\n\t\treturn 0;\n\tcase DCCP_PKT_ACK:\n\t\tgoto discard;\n\tcase DCCP_PKT_RESET:\n\t\t \n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\tcase DCCP_PKT_CLOSEREQ:\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\tcase DCCP_PKT_CLOSE:\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\tcase DCCP_PKT_REQUEST:\n\t\t \n\t\tif (dp->dccps_role != DCCP_ROLE_LISTEN)\n\t\t\tgoto send_sync;\n\t\tgoto check_seq;\n\tcase DCCP_PKT_RESPONSE:\n\t\tif (dp->dccps_role != DCCP_ROLE_CLIENT)\n\t\t\tgoto send_sync;\ncheck_seq:\n\t\tif (dccp_delta_seqno(dp->dccps_osr,\n\t\t\t\t     DCCP_SKB_CB(skb)->dccpd_seq) >= 0) {\nsend_sync:\n\t\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\t\t       DCCP_PKT_SYNC);\n\t\t}\n\t\tbreak;\n\tcase DCCP_PKT_SYNC:\n\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\t       DCCP_PKT_SYNCACK);\n\t\t \n\t\tgoto discard;\n\t}\n\n\tDCCP_INC_STATS(DCCP_MIB_INERRS);\ndiscard:\n\t__kfree_skb(skb);\n\treturn 0;\n}\n\nint dccp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct dccp_hdr *dh, const unsigned int len)\n{\n\tif (dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\n\tdccp_handle_ackvec_processing(sk, skb);\n\tdccp_deliver_input_to_ccids(sk, skb);\n\n\treturn __dccp_rcv_established(sk, skb, dh, len);\ndiscard:\n\t__kfree_skb(skb);\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(dccp_rcv_established);\n\nstatic int dccp_rcv_request_sent_state_process(struct sock *sk,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       const struct dccp_hdr *dh,\n\t\t\t\t\t       const unsigned int len)\n{\n\t \n\tif (dh->dccph_type == DCCP_PKT_RESPONSE) {\n\t\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\t\tstruct dccp_sock *dp = dccp_sk(sk);\n\t\tlong tstamp = dccp_timestamp();\n\n\t\tif (!between48(DCCP_SKB_CB(skb)->dccpd_ack_seq,\n\t\t\t       dp->dccps_awl, dp->dccps_awh)) {\n\t\t\tdccp_pr_debug(\"invalid ackno: S.AWL=%llu, \"\n\t\t\t\t      \"P.ackno=%llu, S.AWH=%llu\\n\",\n\t\t\t\t      (unsigned long long)dp->dccps_awl,\n\t\t\t   (unsigned long long)DCCP_SKB_CB(skb)->dccpd_ack_seq,\n\t\t\t\t      (unsigned long long)dp->dccps_awh);\n\t\t\tgoto out_invalid_packet;\n\t\t}\n\n\t\t \n\t\tif (dccp_parse_options(sk, NULL, skb))\n\t\t\treturn 1;\n\n\t\t \n\t\tif (likely(dp->dccps_options_received.dccpor_timestamp_echo))\n\t\t\tdp->dccps_syn_rtt = dccp_sample_rtt(sk, 10 * (tstamp -\n\t\t\t    dp->dccps_options_received.dccpor_timestamp_echo));\n\n\t\t \n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);\n\t\tWARN_ON(sk->sk_send_head == NULL);\n\t\tkfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\n\t\t \n\t\tdp->dccps_gsr = dp->dccps_isr = DCCP_SKB_CB(skb)->dccpd_seq;\n\n\t\tdccp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\n\t\t \n\t\tdccp_set_state(sk, DCCP_PARTOPEN);\n\n\t\t \n\t\tif (dccp_feat_activate_values(sk, &dp->dccps_featneg))\n\t\t\tgoto unable_to_proceed;\n\n\t\t \n\t\ticsk->icsk_af_ops->rebuild_header(sk);\n\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t}\n\n\t\tif (sk->sk_write_pending || inet_csk_in_pingpong_mode(sk) ||\n\t\t    icsk->icsk_accept_queue.rskq_defer_accept) {\n\t\t\t \n\t\t\t \n\t\t\t__kfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tdccp_send_ack(sk);\n\t\treturn -1;\n\t}\n\nout_invalid_packet:\n\t \n\tDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_PACKET_ERROR;\n\treturn 1;\n\nunable_to_proceed:\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_ABORTED;\n\t \n\tdccp_set_state(sk, DCCP_CLOSED);\n\tsk->sk_err = ECOMM;\n\treturn 1;\n}\n\nstatic int dccp_rcv_respond_partopen_state_process(struct sock *sk,\n\t\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t\t   const struct dccp_hdr *dh,\n\t\t\t\t\t\t   const unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tu32 sample = dp->dccps_options_received.dccpor_timestamp_echo;\n\tint queued = 0;\n\n\tswitch (dh->dccph_type) {\n\tcase DCCP_PKT_RESET:\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n\t\tbreak;\n\tcase DCCP_PKT_DATA:\n\t\tif (sk->sk_state == DCCP_RESPOND)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase DCCP_PKT_DATAACK:\n\tcase DCCP_PKT_ACK:\n\t\t \n\n\t\t \n\t\tif (sk->sk_state == DCCP_PARTOPEN)\n\t\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n\n\t\t \n\t\tif (likely(sample)) {\n\t\t\tlong delta = dccp_timestamp() - sample;\n\n\t\t\tdp->dccps_syn_rtt = dccp_sample_rtt(sk, 10 * delta);\n\t\t}\n\n\t\tdp->dccps_osr = DCCP_SKB_CB(skb)->dccpd_seq;\n\t\tdccp_set_state(sk, DCCP_OPEN);\n\n\t\tif (dh->dccph_type == DCCP_PKT_DATAACK ||\n\t\t    dh->dccph_type == DCCP_PKT_DATA) {\n\t\t\t__dccp_rcv_established(sk, skb, dh, len);\n\t\t\tqueued = 1;  \n\t\t}\n\t\tbreak;\n\t}\n\n\treturn queued;\n}\n\nint dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct dccp_hdr *dh, unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\tconst int old_state = sk->sk_state;\n\tbool acceptable;\n\tint queued = 0;\n\n\t \n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tif (dh->dccph_type == DCCP_PKT_REQUEST) {\n\t\t\t \n\t\t\trcu_read_lock();\n\t\t\tlocal_bh_disable();\n\t\t\tacceptable = inet_csk(sk)->icsk_af_ops->conn_request(sk, skb) >= 0;\n\t\t\tlocal_bh_enable();\n\t\t\trcu_read_unlock();\n\t\t\tif (!acceptable)\n\t\t\t\treturn 1;\n\t\t\tconsume_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tif (dh->dccph_type == DCCP_PKT_RESET)\n\t\t\tgoto discard;\n\n\t\t \n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t} else if (sk->sk_state == DCCP_CLOSED) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t}\n\n\t \n\tif (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\n\t \n\tif ((dp->dccps_role != DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_RESPONSE) ||\n\t    (dp->dccps_role == DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_REQUEST) ||\n\t    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);\n\t\tgoto discard;\n\t}\n\n\t \n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\n\t \n\tif (dh->dccph_type == DCCP_PKT_RESET) {\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {\t \n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSE) {\t\t \n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tqueued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t__kfree_skb(skb);\n\t\treturn 0;\n\n\tcase DCCP_PARTOPEN:\n\t\t \n\t\tdccp_handle_ackvec_processing(sk, skb);\n\t\tdccp_deliver_input_to_ccids(sk, skb);\n\t\tfallthrough;\n\tcase DCCP_RESPOND:\n\t\tqueued = dccp_rcv_respond_partopen_state_process(sk, skb,\n\t\t\t\t\t\t\t\t dh, len);\n\t\tbreak;\n\t}\n\n\tif (dh->dccph_type == DCCP_PKT_ACK ||\n\t    dh->dccph_type == DCCP_PKT_DATAACK) {\n\t\tswitch (old_state) {\n\t\tcase DCCP_PARTOPEN:\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t\tbreak;\n\t\t}\n\t} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);\n\t\tgoto discard;\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(dccp_rcv_state_process);\n\n \nu32 dccp_sample_rtt(struct sock *sk, long delta)\n{\n\t \n\tdelta -= dccp_sk(sk)->dccps_options_received.dccpor_elapsed_time * 10;\n\n\tif (unlikely(delta <= 0)) {\n\t\tDCCP_WARN(\"unusable RTT sample %ld, using min\\n\", delta);\n\t\treturn DCCP_SANE_RTT_MIN;\n\t}\n\tif (unlikely(delta > DCCP_SANE_RTT_MAX)) {\n\t\tDCCP_WARN(\"RTT sample %ld too large, using max\\n\", delta);\n\t\treturn DCCP_SANE_RTT_MAX;\n\t}\n\n\treturn delta;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}