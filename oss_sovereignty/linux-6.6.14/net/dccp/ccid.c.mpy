{
  "module_name": "ccid.c",
  "hash_id": "757aef9c216124a9883a7b1eb7aac6312bbe1d7e8a567e9c308a6ae14f5d1903",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/ccid.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"ccid.h\"\n#include \"ccids/lib/tfrc.h\"\n\nstatic struct ccid_operations *ccids[] = {\n\t&ccid2_ops,\n#ifdef CONFIG_IP_DCCP_CCID3\n\t&ccid3_ops,\n#endif\n};\n\nstatic struct ccid_operations *ccid_by_number(const u8 id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ccids); i++)\n\t\tif (ccids[i]->ccid_id == id)\n\t\t\treturn ccids[i];\n\treturn NULL;\n}\n\n \nbool ccid_support_check(u8 const *ccid_array, u8 array_len)\n{\n\twhile (array_len > 0)\n\t\tif (ccid_by_number(ccid_array[--array_len]) == NULL)\n\t\t\treturn false;\n\treturn true;\n}\n\n \nint ccid_get_builtin_ccids(u8 **ccid_array, u8 *array_len)\n{\n\t*ccid_array = kmalloc(ARRAY_SIZE(ccids), gfp_any());\n\tif (*ccid_array == NULL)\n\t\treturn -ENOBUFS;\n\n\tfor (*array_len = 0; *array_len < ARRAY_SIZE(ccids); *array_len += 1)\n\t\t(*ccid_array)[*array_len] = ccids[*array_len]->ccid_id;\n\treturn 0;\n}\n\nint ccid_getsockopt_builtin_ccids(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tu8 *ccid_array, array_len;\n\tint err = 0;\n\n\tif (ccid_get_builtin_ccids(&ccid_array, &array_len))\n\t\treturn -ENOBUFS;\n\n\tif (put_user(array_len, optlen))\n\t\terr = -EFAULT;\n\telse if (len > 0 && copy_to_user(optval, ccid_array,\n\t\t\t\t\t len > array_len ? array_len : len))\n\t\terr = -EFAULT;\n\n\tkfree(ccid_array);\n\treturn err;\n}\n\nstatic __printf(3, 4) struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...)\n{\n\tstruct kmem_cache *slab;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(slab_name_fmt, CCID_SLAB_NAME_LENGTH, fmt, args);\n\tva_end(args);\n\n\tslab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0,\n\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\treturn slab;\n}\n\nstatic void ccid_kmem_cache_destroy(struct kmem_cache *slab)\n{\n\tkmem_cache_destroy(slab);\n}\n\nstatic int __init ccid_activate(struct ccid_operations *ccid_ops)\n{\n\tint err = -ENOBUFS;\n\n\tccid_ops->ccid_hc_rx_slab =\n\t\t\tccid_kmem_cache_create(ccid_ops->ccid_hc_rx_obj_size,\n\t\t\t\t\t       ccid_ops->ccid_hc_rx_slab_name,\n\t\t\t\t\t       \"ccid%u_hc_rx_sock\",\n\t\t\t\t\t       ccid_ops->ccid_id);\n\tif (ccid_ops->ccid_hc_rx_slab == NULL)\n\t\tgoto out;\n\n\tccid_ops->ccid_hc_tx_slab =\n\t\t\tccid_kmem_cache_create(ccid_ops->ccid_hc_tx_obj_size,\n\t\t\t\t\t       ccid_ops->ccid_hc_tx_slab_name,\n\t\t\t\t\t       \"ccid%u_hc_tx_sock\",\n\t\t\t\t\t       ccid_ops->ccid_id);\n\tif (ccid_ops->ccid_hc_tx_slab == NULL)\n\t\tgoto out_free_rx_slab;\n\n\tpr_info(\"DCCP: Activated CCID %d (%s)\\n\",\n\t\tccid_ops->ccid_id, ccid_ops->ccid_name);\n\terr = 0;\nout:\n\treturn err;\nout_free_rx_slab:\n\tccid_kmem_cache_destroy(ccid_ops->ccid_hc_rx_slab);\n\tccid_ops->ccid_hc_rx_slab = NULL;\n\tgoto out;\n}\n\nstatic void ccid_deactivate(struct ccid_operations *ccid_ops)\n{\n\tccid_kmem_cache_destroy(ccid_ops->ccid_hc_tx_slab);\n\tccid_ops->ccid_hc_tx_slab = NULL;\n\tccid_kmem_cache_destroy(ccid_ops->ccid_hc_rx_slab);\n\tccid_ops->ccid_hc_rx_slab = NULL;\n\n\tpr_info(\"DCCP: Deactivated CCID %d (%s)\\n\",\n\t\tccid_ops->ccid_id, ccid_ops->ccid_name);\n}\n\nstruct ccid *ccid_new(const u8 id, struct sock *sk, bool rx)\n{\n\tstruct ccid_operations *ccid_ops = ccid_by_number(id);\n\tstruct ccid *ccid = NULL;\n\n\tif (ccid_ops == NULL)\n\t\tgoto out;\n\n\tccid = kmem_cache_alloc(rx ? ccid_ops->ccid_hc_rx_slab :\n\t\t\t\t     ccid_ops->ccid_hc_tx_slab, gfp_any());\n\tif (ccid == NULL)\n\t\tgoto out;\n\tccid->ccid_ops = ccid_ops;\n\tif (rx) {\n\t\tmemset(ccid + 1, 0, ccid_ops->ccid_hc_rx_obj_size);\n\t\tif (ccid->ccid_ops->ccid_hc_rx_init != NULL &&\n\t\t    ccid->ccid_ops->ccid_hc_rx_init(ccid, sk) != 0)\n\t\t\tgoto out_free_ccid;\n\t} else {\n\t\tmemset(ccid + 1, 0, ccid_ops->ccid_hc_tx_obj_size);\n\t\tif (ccid->ccid_ops->ccid_hc_tx_init != NULL &&\n\t\t    ccid->ccid_ops->ccid_hc_tx_init(ccid, sk) != 0)\n\t\t\tgoto out_free_ccid;\n\t}\nout:\n\treturn ccid;\nout_free_ccid:\n\tkmem_cache_free(rx ? ccid_ops->ccid_hc_rx_slab :\n\t\t\tccid_ops->ccid_hc_tx_slab, ccid);\n\tccid = NULL;\n\tgoto out;\n}\n\nvoid ccid_hc_rx_delete(struct ccid *ccid, struct sock *sk)\n{\n\tif (ccid != NULL) {\n\t\tif (ccid->ccid_ops->ccid_hc_rx_exit != NULL)\n\t\t\tccid->ccid_ops->ccid_hc_rx_exit(sk);\n\t\tkmem_cache_free(ccid->ccid_ops->ccid_hc_rx_slab, ccid);\n\t}\n}\n\nvoid ccid_hc_tx_delete(struct ccid *ccid, struct sock *sk)\n{\n\tif (ccid != NULL) {\n\t\tif (ccid->ccid_ops->ccid_hc_tx_exit != NULL)\n\t\t\tccid->ccid_ops->ccid_hc_tx_exit(sk);\n\t\tkmem_cache_free(ccid->ccid_ops->ccid_hc_tx_slab, ccid);\n\t}\n}\n\nint __init ccid_initialize_builtins(void)\n{\n\tint i, err = tfrc_lib_init();\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(ccids); i++) {\n\t\terr = ccid_activate(ccids[i]);\n\t\tif (err)\n\t\t\tgoto unwind_registrations;\n\t}\n\treturn 0;\n\nunwind_registrations:\n\twhile(--i >= 0)\n\t\tccid_deactivate(ccids[i]);\n\ttfrc_lib_exit();\n\treturn err;\n}\n\nvoid ccid_cleanup_builtins(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ccids); i++)\n\t\tccid_deactivate(ccids[i]);\n\ttfrc_lib_exit();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}