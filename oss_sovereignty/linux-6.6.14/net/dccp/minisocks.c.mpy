{
  "module_name": "minisocks.c",
  "hash_id": "1be9f899710ba539ff11709fa8be1cf5896cf3cfa3c857ffca9a3e73ba47f7aa",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/minisocks.c",
  "human_readable_source": "\n \n\n#include <linux/dccp.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/timer.h>\n\n#include <net/sock.h>\n#include <net/xfrm.h>\n#include <net/inet_timewait_sock.h>\n\n#include \"ackvec.h\"\n#include \"ccid.h\"\n#include \"dccp.h\"\n#include \"feat.h\"\n\nstruct inet_timewait_death_row dccp_death_row = {\n\t.tw_refcount = REFCOUNT_INIT(1),\n\t.sysctl_max_tw_buckets = NR_FILE * 2,\n\t.hashinfo\t= &dccp_hashinfo,\n};\n\nEXPORT_SYMBOL_GPL(dccp_death_row);\n\nvoid dccp_time_wait(struct sock *sk, int state, int timeo)\n{\n\tstruct inet_timewait_sock *tw;\n\n\ttw = inet_twsk_alloc(sk, &dccp_death_row, state);\n\n\tif (tw != NULL) {\n\t\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\t\tconst int rto = (icsk->icsk_rto << 2) - (icsk->icsk_rto >> 1);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (tw->tw_family == PF_INET6) {\n\t\t\ttw->tw_v6_daddr = sk->sk_v6_daddr;\n\t\t\ttw->tw_v6_rcv_saddr = sk->sk_v6_rcv_saddr;\n\t\t\ttw->tw_ipv6only = sk->sk_ipv6only;\n\t\t}\n#endif\n\n\t\t \n\t\tif (timeo < rto)\n\t\t\ttimeo = rto;\n\n\t\tif (state == DCCP_TIME_WAIT)\n\t\t\ttimeo = DCCP_TIMEWAIT_LEN;\n\n\t\t \n\t\tlocal_bh_disable();\n\t\tinet_twsk_schedule(tw, timeo);\n\t\t \n\t\tinet_twsk_hashdance(tw, sk, &dccp_hashinfo);\n\t\tlocal_bh_enable();\n\t} else {\n\t\t \n\t\tDCCP_WARN(\"time wait bucket table overflow\\n\");\n\t}\n\n\tdccp_done(sk);\n}\n\nstruct sock *dccp_create_openreq_child(const struct sock *sk,\n\t\t\t\t       const struct request_sock *req,\n\t\t\t\t       const struct sk_buff *skb)\n{\n\t \n\tstruct sock *newsk = inet_csk_clone_lock(sk, req, GFP_ATOMIC);\n\n\tif (newsk != NULL) {\n\t\tstruct dccp_request_sock *dreq = dccp_rsk(req);\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\t\tstruct dccp_sock *newdp = dccp_sk(newsk);\n\n\t\tnewdp->dccps_role\t    = DCCP_ROLE_SERVER;\n\t\tnewdp->dccps_hc_rx_ackvec   = NULL;\n\t\tnewdp->dccps_service_list   = NULL;\n\t\tnewdp->dccps_hc_rx_ccid     = NULL;\n\t\tnewdp->dccps_hc_tx_ccid     = NULL;\n\t\tnewdp->dccps_service\t    = dreq->dreq_service;\n\t\tnewdp->dccps_timestamp_echo = dreq->dreq_timestamp_echo;\n\t\tnewdp->dccps_timestamp_time = dreq->dreq_timestamp_time;\n\t\tnewicsk->icsk_rto\t    = DCCP_TIMEOUT_INIT;\n\n\t\tINIT_LIST_HEAD(&newdp->dccps_featneg);\n\t\t \n\t\tnewdp->dccps_iss = dreq->dreq_iss;\n\t\tnewdp->dccps_gss = dreq->dreq_gss;\n\t\tnewdp->dccps_gar = newdp->dccps_iss;\n\t\tnewdp->dccps_isr = dreq->dreq_isr;\n\t\tnewdp->dccps_gsr = dreq->dreq_gsr;\n\n\t\t \n\t\tif (dccp_feat_activate_values(newsk, &dreq->dreq_featneg)) {\n\t\t\tsk_free_unlock_clone(newsk);\n\t\t\treturn NULL;\n\t\t}\n\t\tdccp_init_xmit_timers(newsk);\n\n\t\t__DCCP_INC_STATS(DCCP_MIB_PASSIVEOPENS);\n\t}\n\treturn newsk;\n}\n\nEXPORT_SYMBOL_GPL(dccp_create_openreq_child);\n\n \nstruct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,\n\t\t\t    struct request_sock *req)\n{\n\tstruct sock *child = NULL;\n\tstruct dccp_request_sock *dreq = dccp_rsk(req);\n\tbool own_req;\n\n\t \n\tspin_lock_bh(&dreq->dreq_lock);\n\n\t \n\tif (dccp_hdr(skb)->dccph_type == DCCP_PKT_REQUEST) {\n\n\t\tif (after48(DCCP_SKB_CB(skb)->dccpd_seq, dreq->dreq_gsr)) {\n\t\t\tdccp_pr_debug(\"Retransmitted REQUEST\\n\");\n\t\t\tdreq->dreq_gsr = DCCP_SKB_CB(skb)->dccpd_seq;\n\t\t\t \n\t\t\tinet_rtx_syn_ack(sk, req);\n\t\t}\n\t\t \n\t\tgoto out;\n\t}\n\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_PACKET_ERROR;\n\n\tif (dccp_hdr(skb)->dccph_type != DCCP_PKT_ACK &&\n\t    dccp_hdr(skb)->dccph_type != DCCP_PKT_DATAACK)\n\t\tgoto drop;\n\n\t \n\tif (!between48(DCCP_SKB_CB(skb)->dccpd_ack_seq,\n\t\t\t\tdreq->dreq_iss, dreq->dreq_gss)) {\n\t\tdccp_pr_debug(\"Invalid ACK number: ack_seq=%llu, \"\n\t\t\t      \"dreq_iss=%llu, dreq_gss=%llu\\n\",\n\t\t\t      (unsigned long long)\n\t\t\t      DCCP_SKB_CB(skb)->dccpd_ack_seq,\n\t\t\t      (unsigned long long) dreq->dreq_iss,\n\t\t\t      (unsigned long long) dreq->dreq_gss);\n\t\tgoto drop;\n\t}\n\n\tif (dccp_parse_options(sk, dreq, skb))\n\t\t goto drop;\n\n\tchild = inet_csk(sk)->icsk_af_ops->syn_recv_sock(sk, skb, req, NULL,\n\t\t\t\t\t\t\t req, &own_req);\n\tif (child) {\n\t\tchild = inet_csk_complete_hashdance(sk, child, req, own_req);\n\t\tgoto out;\n\t}\n\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\ndrop:\n\tif (dccp_hdr(skb)->dccph_type != DCCP_PKT_RESET)\n\t\treq->rsk_ops->send_reset(sk, skb);\n\n\tinet_csk_reqsk_queue_drop(sk, req);\nout:\n\tspin_unlock_bh(&dreq->dreq_lock);\n\treturn child;\n}\n\nEXPORT_SYMBOL_GPL(dccp_check_req);\n\n \nint dccp_child_process(struct sock *parent, struct sock *child,\n\t\t       struct sk_buff *skb)\n\t__releases(child)\n{\n\tint ret = 0;\n\tconst int state = child->sk_state;\n\n\tif (!sock_owned_by_user(child)) {\n\t\tret = dccp_rcv_state_process(child, skb, dccp_hdr(skb),\n\t\t\t\t\t     skb->len);\n\n\t\t \n\t\tif (state == DCCP_RESPOND && child->sk_state != state)\n\t\t\tparent->sk_data_ready(parent);\n\t} else {\n\t\t \n\t\t__sk_add_backlog(child, skb);\n\t}\n\n\tbh_unlock_sock(child);\n\tsock_put(child);\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(dccp_child_process);\n\nvoid dccp_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t struct request_sock *rsk)\n{\n\tDCCP_BUG(\"DCCP-ACK packets are never sent in LISTEN/RESPOND state\");\n}\n\nEXPORT_SYMBOL_GPL(dccp_reqsk_send_ack);\n\nint dccp_reqsk_init(struct request_sock *req,\n\t\t    struct dccp_sock const *dp, struct sk_buff const *skb)\n{\n\tstruct dccp_request_sock *dreq = dccp_rsk(req);\n\n\tspin_lock_init(&dreq->dreq_lock);\n\tinet_rsk(req)->ir_rmt_port = dccp_hdr(skb)->dccph_sport;\n\tinet_rsk(req)->ir_num\t   = ntohs(dccp_hdr(skb)->dccph_dport);\n\tinet_rsk(req)->acked\t   = 0;\n\tdreq->dreq_timestamp_echo  = 0;\n\n\t \n\treturn dccp_feat_clone_list(&dp->dccps_featneg, &dreq->dreq_featneg);\n}\n\nEXPORT_SYMBOL_GPL(dccp_reqsk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}