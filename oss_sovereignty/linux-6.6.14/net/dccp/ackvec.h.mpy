{
  "module_name": "ackvec.h",
  "hash_id": "fcc2733197b8633d73d454d40e307af257a93ae8b62759f6ee819341797a9e07",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/ackvec.h",
  "human_readable_source": " \n#ifndef _ACKVEC_H\n#define _ACKVEC_H\n \n\n#include <linux/dccp.h>\n#include <linux/compiler.h>\n#include <linux/list.h>\n#include <linux/types.h>\n\n \n#define DCCPAV_NUM_ACKVECS\t2\n#define DCCPAV_MAX_ACKVEC_LEN\t(DCCP_SINGLE_OPT_MAXLEN * DCCPAV_NUM_ACKVECS)\n\n \n#define DCCPAV_MIN_OPTLEN\t16\n\n \n#define DCCPAV_BURST_THRESH\t(DCCPAV_MAX_ACKVEC_LEN / 8)\n\nenum dccp_ackvec_states {\n\tDCCPAV_RECEIVED =\t0x00,\n\tDCCPAV_ECN_MARKED =\t0x40,\n\tDCCPAV_RESERVED =\t0x80,\n\tDCCPAV_NOT_RECEIVED =\t0xC0\n};\n#define DCCPAV_MAX_RUNLEN\t0x3F\n\nstatic inline u8 dccp_ackvec_runlen(const u8 *cell)\n{\n\treturn *cell & DCCPAV_MAX_RUNLEN;\n}\n\nstatic inline u8 dccp_ackvec_state(const u8 *cell)\n{\n\treturn *cell & ~DCCPAV_MAX_RUNLEN;\n}\n\n \nstruct dccp_ackvec {\n\tu8\t\t\tav_buf[DCCPAV_MAX_ACKVEC_LEN];\n\tu16\t\t\tav_buf_head;\n\tu16\t\t\tav_buf_tail;\n\tu64\t\t\tav_buf_ackno:48;\n\tu64\t\t\tav_tail_ackno:48;\n\tbool\t\t\tav_buf_nonce[DCCPAV_NUM_ACKVECS];\n\tu8\t\t\tav_overflow:1;\n\tstruct list_head\tav_records;\n};\n\n \nstruct dccp_ackvec_record {\n\tstruct list_head avr_node;\n\tu64\t\t avr_ack_seqno:48;\n\tu64\t\t avr_ack_ackno:48;\n\tu16\t\t avr_ack_ptr;\n\tu8\t\t avr_ack_runlen;\n\tu8\t\t avr_ack_nonce:1;\n};\n\nint dccp_ackvec_init(void);\nvoid dccp_ackvec_exit(void);\n\nstruct dccp_ackvec *dccp_ackvec_alloc(const gfp_t priority);\nvoid dccp_ackvec_free(struct dccp_ackvec *av);\n\nvoid dccp_ackvec_input(struct dccp_ackvec *av, struct sk_buff *skb);\nint dccp_ackvec_update_records(struct dccp_ackvec *av, u64 seq, u8 sum);\nvoid dccp_ackvec_clear_state(struct dccp_ackvec *av, const u64 ackno);\nu16 dccp_ackvec_buflen(const struct dccp_ackvec *av);\n\nstatic inline bool dccp_ackvec_is_empty(const struct dccp_ackvec *av)\n{\n\treturn av->av_overflow == 0 && av->av_buf_head == av->av_buf_tail;\n}\n\n \nstruct dccp_ackvec_parsed {\n\tu8\t\t *vec,\n\t\t\t len,\n\t\t\t nonce:1;\n\tstruct list_head node;\n};\n\nint dccp_ackvec_parsed_add(struct list_head *head, u8 *vec, u8 len, u8 nonce);\nvoid dccp_ackvec_parsed_cleanup(struct list_head *parsed_chunks);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}