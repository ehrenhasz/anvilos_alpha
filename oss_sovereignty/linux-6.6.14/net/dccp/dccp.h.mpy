{
  "module_name": "dccp.h",
  "hash_id": "08c12718625735dd97b26c61745f9c3a3e834669be3039e8b4cd1d5d8409a92a",
  "original_prompt": "Ingested from linux-6.6.14/net/dccp/dccp.h",
  "human_readable_source": " \n#ifndef _DCCP_H\n#define _DCCP_H\n \n\n#include <linux/dccp.h>\n#include <linux/ktime.h>\n#include <net/snmp.h>\n#include <net/sock.h>\n#include <net/tcp.h>\n#include \"ackvec.h\"\n\n \n#define DCCP_WARN(fmt, ...)\t\t\t\t\t\t\\\n\tnet_warn_ratelimited(\"%s: \" fmt, __func__, ##__VA_ARGS__)\n#define DCCP_CRIT(fmt, a...) printk(KERN_CRIT fmt \" at %s:%d/%s()\\n\", ##a, \\\n\t\t\t\t\t __FILE__, __LINE__, __func__)\n#define DCCP_BUG(a...)       do { DCCP_CRIT(\"BUG: \" a); dump_stack(); } while(0)\n#define DCCP_BUG_ON(cond)    do { if (unlikely((cond) != 0))\t\t   \\\n\t\t\t\t     DCCP_BUG(\"\\\"%s\\\" holds (exception!)\", \\\n\t\t\t\t\t      __stringify(cond));          \\\n\t\t\t     } while (0)\n\n#define DCCP_PRINTK(enable, fmt, args...)\tdo { if (enable)\t     \\\n\t\t\t\t\t\t\tprintk(fmt, ##args); \\\n\t\t\t\t\t\t} while(0)\n#define DCCP_PR_DEBUG(enable, fmt, a...)\tDCCP_PRINTK(enable, KERN_DEBUG \\\n\t\t\t\t\t\t  \"%s: \" fmt, __func__, ##a)\n\n#ifdef CONFIG_IP_DCCP_DEBUG\nextern bool dccp_debug;\n#define dccp_pr_debug(format, a...)\t  DCCP_PR_DEBUG(dccp_debug, format, ##a)\n#define dccp_pr_debug_cat(format, a...)   DCCP_PRINTK(dccp_debug, format, ##a)\n#define dccp_debug(fmt, a...)\t\t  dccp_pr_debug_cat(KERN_DEBUG fmt, ##a)\n#else\n#define dccp_pr_debug(format, a...)\t  do {} while (0)\n#define dccp_pr_debug_cat(format, a...)\t  do {} while (0)\n#define dccp_debug(format, a...)\t  do {} while (0)\n#endif\n\nextern struct inet_hashinfo dccp_hashinfo;\n\nDECLARE_PER_CPU(unsigned int, dccp_orphan_count);\n\nvoid dccp_time_wait(struct sock *sk, int state, int timeo);\n\n \n#define MAX_DCCP_SPECIFIC_HEADER (255 * sizeof(uint32_t))\n#define DCCP_MAX_PACKET_HDR 28\n#define DCCP_MAX_OPT_LEN (MAX_DCCP_SPECIFIC_HEADER - DCCP_MAX_PACKET_HDR)\n#define MAX_DCCP_HEADER (MAX_DCCP_SPECIFIC_HEADER + MAX_HEADER)\n\n \n#define DCCP_FEATNEG_OVERHEAD\t (32 * sizeof(uint32_t))\n\n#define DCCP_TIMEWAIT_LEN (60 * HZ)  \n\n \n#define DCCP_TIMEOUT_INIT ((unsigned int)(3 * HZ))\n\n \n#define DCCP_RTO_MAX ((unsigned int)(64 * HZ))\n\n \n#define DCCP_SANE_RTT_MIN\t100\n#define DCCP_FALLBACK_RTT\t(USEC_PER_SEC / 5)\n#define DCCP_SANE_RTT_MAX\t(3 * USEC_PER_SEC)\n\n \nextern int  sysctl_dccp_request_retries;\nextern int  sysctl_dccp_retries1;\nextern int  sysctl_dccp_retries2;\nextern int  sysctl_dccp_tx_qlen;\nextern int  sysctl_dccp_sync_ratelimit;\n\n \n#define INT48_MIN\t  0x800000000000LL\t\t \n#define UINT48_MAX\t  0xFFFFFFFFFFFFLL\t\t \n#define COMPLEMENT48(x)\t (0x1000000000000LL - (x))\t \n#define TO_SIGNED48(x)\t (((x) < INT48_MIN)? (x) : -COMPLEMENT48( (x)))\n#define TO_UNSIGNED48(x) (((x) >= 0)?\t     (x) :  COMPLEMENT48(-(x)))\n#define ADD48(a, b)\t (((a) + (b)) & UINT48_MAX)\n#define SUB48(a, b)\t ADD48((a), COMPLEMENT48(b))\n\nstatic inline void dccp_inc_seqno(u64 *seqno)\n{\n\t*seqno = ADD48(*seqno, 1);\n}\n\n \nstatic inline s64 dccp_delta_seqno(const u64 seqno1, const u64 seqno2)\n{\n\tu64 delta = SUB48(seqno2, seqno1);\n\n\treturn TO_SIGNED48(delta);\n}\n\n \nstatic inline int before48(const u64 seq1, const u64 seq2)\n{\n\treturn (s64)((seq2 << 16) - (seq1 << 16)) > 0;\n}\n\n \n#define after48(seq1, seq2)\tbefore48(seq2, seq1)\n\n \nstatic inline int between48(const u64 seq1, const u64 seq2, const u64 seq3)\n{\n\treturn (seq3 << 16) - (seq2 << 16) >= (seq1 << 16) - (seq2 << 16);\n}\n\n \nstatic inline u64 dccp_loss_count(const u64 s1, const u64 s2, const u64 ndp)\n{\n\ts64 delta = dccp_delta_seqno(s1, s2);\n\n\tWARN_ON(delta < 0);\n\tdelta -= ndp + 1;\n\n\treturn delta > 0 ? delta : 0;\n}\n\n \nstatic inline bool dccp_loss_free(const u64 s1, const u64 s2, const u64 ndp)\n{\n\treturn dccp_loss_count(s1, s2, ndp) == 0;\n}\n\nenum {\n\tDCCP_MIB_NUM = 0,\n\tDCCP_MIB_ACTIVEOPENS,\t\t\t \n\tDCCP_MIB_ESTABRESETS,\t\t\t \n\tDCCP_MIB_CURRESTAB,\t\t\t \n\tDCCP_MIB_OUTSEGS,\t\t\t \n\tDCCP_MIB_OUTRSTS,\n\tDCCP_MIB_ABORTONTIMEOUT,\n\tDCCP_MIB_TIMEOUTS,\n\tDCCP_MIB_ABORTFAILED,\n\tDCCP_MIB_PASSIVEOPENS,\n\tDCCP_MIB_ATTEMPTFAILS,\n\tDCCP_MIB_OUTDATAGRAMS,\n\tDCCP_MIB_INERRS,\n\tDCCP_MIB_OPTMANDATORYERROR,\n\tDCCP_MIB_INVALIDOPT,\n\t__DCCP_MIB_MAX\n};\n\n#define DCCP_MIB_MAX\t__DCCP_MIB_MAX\nstruct dccp_mib {\n\tunsigned long\tmibs[DCCP_MIB_MAX];\n};\n\nDECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);\n#define DCCP_INC_STATS(field)\tSNMP_INC_STATS(dccp_statistics, field)\n#define __DCCP_INC_STATS(field)\t__SNMP_INC_STATS(dccp_statistics, field)\n#define DCCP_DEC_STATS(field)\tSNMP_DEC_STATS(dccp_statistics, field)\n\n \nstatic inline unsigned int dccp_csum_coverage(const struct sk_buff *skb)\n{\n\tconst struct dccp_hdr* dh = dccp_hdr(skb);\n\n\tif (dh->dccph_cscov == 0)\n\t\treturn skb->len;\n\treturn (dh->dccph_doff + dh->dccph_cscov - 1) * sizeof(u32);\n}\n\nstatic inline void dccp_csum_outgoing(struct sk_buff *skb)\n{\n\tunsigned int cov = dccp_csum_coverage(skb);\n\n\tif (cov >= skb->len)\n\t\tdccp_hdr(skb)->dccph_cscov = 0;\n\n\tskb->csum = skb_checksum(skb, 0, (cov > skb->len)? skb->len : cov, 0);\n}\n\nvoid dccp_v4_send_check(struct sock *sk, struct sk_buff *skb);\n\nint dccp_retransmit_skb(struct sock *sk);\n\nvoid dccp_send_ack(struct sock *sk);\nvoid dccp_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t struct request_sock *rsk);\n\nvoid dccp_send_sync(struct sock *sk, const u64 seq,\n\t\t    const enum dccp_pkt_type pkt_type);\n\n \nvoid dccp_qpolicy_push(struct sock *sk, struct sk_buff *skb);\nbool dccp_qpolicy_full(struct sock *sk);\nvoid dccp_qpolicy_drop(struct sock *sk, struct sk_buff *skb);\nstruct sk_buff *dccp_qpolicy_top(struct sock *sk);\nstruct sk_buff *dccp_qpolicy_pop(struct sock *sk);\nbool dccp_qpolicy_param_ok(struct sock *sk, __be32 param);\n\n \nvoid dccp_write_xmit(struct sock *sk);\nvoid dccp_write_space(struct sock *sk);\nvoid dccp_flush_write_queue(struct sock *sk, long *time_budget);\n\nvoid dccp_init_xmit_timers(struct sock *sk);\nstatic inline void dccp_clear_xmit_timers(struct sock *sk)\n{\n\tinet_csk_clear_xmit_timers(sk);\n}\n\nunsigned int dccp_sync_mss(struct sock *sk, u32 pmtu);\n\nconst char *dccp_packet_name(const int type);\n\nvoid dccp_set_state(struct sock *sk, const int state);\nvoid dccp_done(struct sock *sk);\n\nint dccp_reqsk_init(struct request_sock *rq, struct dccp_sock const *dp,\n\t\t    struct sk_buff const *skb);\n\nint dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb);\n\nstruct sock *dccp_create_openreq_child(const struct sock *sk,\n\t\t\t\t       const struct request_sock *req,\n\t\t\t\t       const struct sk_buff *skb);\n\nint dccp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);\n\nstruct sock *dccp_v4_request_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst,\n\t\t\t\t       struct request_sock *req_unhash,\n\t\t\t\t       bool *own_req);\nstruct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,\n\t\t\t    struct request_sock *req);\n\nint dccp_child_process(struct sock *parent, struct sock *child,\n\t\t       struct sk_buff *skb);\nint dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct dccp_hdr *dh, unsigned int len);\nint dccp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct dccp_hdr *dh, const unsigned int len);\n\nvoid dccp_destruct_common(struct sock *sk);\nint dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized);\nvoid dccp_destroy_sock(struct sock *sk);\n\nvoid dccp_close(struct sock *sk, long timeout);\nstruct sk_buff *dccp_make_response(const struct sock *sk, struct dst_entry *dst,\n\t\t\t\t   struct request_sock *req);\n\nint dccp_connect(struct sock *sk);\nint dccp_disconnect(struct sock *sk, int flags);\nint dccp_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen);\nint dccp_setsockopt(struct sock *sk, int level, int optname,\n\t\t    sockptr_t optval, unsigned int optlen);\nint dccp_ioctl(struct sock *sk, int cmd, int *karg);\nint dccp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);\nint dccp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int flags,\n\t\t int *addr_len);\nvoid dccp_shutdown(struct sock *sk, int how);\nint inet_dccp_listen(struct socket *sock, int backlog);\n__poll_t dccp_poll(struct file *file, struct socket *sock,\n\t\t       poll_table *wait);\nint dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);\nvoid dccp_req_err(struct sock *sk, u64 seq);\n\nstruct sk_buff *dccp_ctl_make_reset(struct sock *sk, struct sk_buff *skb);\nint dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);\nvoid dccp_send_close(struct sock *sk, const int active);\nint dccp_invalid_packet(struct sk_buff *skb);\nu32 dccp_sample_rtt(struct sock *sk, long delta);\n\nstatic inline bool dccp_bad_service_code(const struct sock *sk,\n\t\t\t\t\tconst __be32 service)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\n\tif (dp->dccps_service == service)\n\t\treturn false;\n\treturn !dccp_list_has_service(dp->dccps_service_list, service);\n}\n\n \nstruct dccp_skb_cb {\n\tunion {\n\t\tstruct inet_skb_parm\th4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct inet6_skb_parm\th6;\n#endif\n\t} header;\n\t__u8  dccpd_type:4;\n\t__u8  dccpd_ccval:4;\n\t__u8  dccpd_reset_code,\n\t      dccpd_reset_data[3];\n\t__u16 dccpd_opt_len;\n\t__u64 dccpd_seq;\n\t__u64 dccpd_ack_seq;\n};\n\n#define DCCP_SKB_CB(__skb) ((struct dccp_skb_cb *)&((__skb)->cb[0]))\n\n \nstatic inline int dccp_non_data_packet(const struct sk_buff *skb)\n{\n\tconst __u8 type = DCCP_SKB_CB(skb)->dccpd_type;\n\n\treturn type == DCCP_PKT_ACK\t ||\n\t       type == DCCP_PKT_CLOSE\t ||\n\t       type == DCCP_PKT_CLOSEREQ ||\n\t       type == DCCP_PKT_RESET\t ||\n\t       type == DCCP_PKT_SYNC\t ||\n\t       type == DCCP_PKT_SYNCACK;\n}\n\n \nstatic inline int dccp_data_packet(const struct sk_buff *skb)\n{\n\tconst __u8 type = DCCP_SKB_CB(skb)->dccpd_type;\n\n\treturn type == DCCP_PKT_DATA\t ||\n\t       type == DCCP_PKT_DATAACK  ||\n\t       type == DCCP_PKT_REQUEST  ||\n\t       type == DCCP_PKT_RESPONSE;\n}\n\nstatic inline int dccp_packet_without_ack(const struct sk_buff *skb)\n{\n\tconst __u8 type = DCCP_SKB_CB(skb)->dccpd_type;\n\n\treturn type == DCCP_PKT_DATA || type == DCCP_PKT_REQUEST;\n}\n\n#define DCCP_PKT_WITHOUT_ACK_SEQ (UINT48_MAX << 2)\n\nstatic inline void dccp_hdr_set_seq(struct dccp_hdr *dh, const u64 gss)\n{\n\tstruct dccp_hdr_ext *dhx = (struct dccp_hdr_ext *)((void *)dh +\n\t\t\t\t\t\t\t   sizeof(*dh));\n\tdh->dccph_seq2 = 0;\n\tdh->dccph_seq = htons((gss >> 32) & 0xfffff);\n\tdhx->dccph_seq_low = htonl(gss & 0xffffffff);\n}\n\nstatic inline void dccp_hdr_set_ack(struct dccp_hdr_ack_bits *dhack,\n\t\t\t\t    const u64 gsr)\n{\n\tdhack->dccph_reserved1 = 0;\n\tdhack->dccph_ack_nr_high = htons(gsr >> 32);\n\tdhack->dccph_ack_nr_low  = htonl(gsr & 0xffffffff);\n}\n\nstatic inline void dccp_update_gsr(struct sock *sk, u64 seq)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\tif (after48(seq, dp->dccps_gsr))\n\t\tdp->dccps_gsr = seq;\n\t \n\tdp->dccps_swl = SUB48(ADD48(dp->dccps_gsr, 1), dp->dccps_r_seq_win / 4);\n\t \n\tif (before48(dp->dccps_swl, dp->dccps_isr))\n\t\tdp->dccps_swl = dp->dccps_isr;\n\tdp->dccps_swh = ADD48(dp->dccps_gsr, (3 * dp->dccps_r_seq_win) / 4);\n}\n\nstatic inline void dccp_update_gss(struct sock *sk, u64 seq)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\tdp->dccps_gss = seq;\n\t \n\tdp->dccps_awl = SUB48(ADD48(dp->dccps_gss, 1), dp->dccps_l_seq_win);\n\t \n\tif (before48(dp->dccps_awl, dp->dccps_iss))\n\t\tdp->dccps_awl = dp->dccps_iss;\n\tdp->dccps_awh = dp->dccps_gss;\n}\n\nstatic inline int dccp_ackvec_pending(const struct sock *sk)\n{\n\treturn dccp_sk(sk)->dccps_hc_rx_ackvec != NULL &&\n\t       !dccp_ackvec_is_empty(dccp_sk(sk)->dccps_hc_rx_ackvec);\n}\n\nstatic inline int dccp_ack_pending(const struct sock *sk)\n{\n\treturn dccp_ackvec_pending(sk) || inet_csk_ack_scheduled(sk);\n}\n\nint dccp_feat_signal_nn_change(struct sock *sk, u8 feat, u64 nn_val);\nint dccp_feat_finalise_settings(struct dccp_sock *dp);\nint dccp_feat_server_ccid_dependencies(struct dccp_request_sock *dreq);\nint dccp_feat_insert_opts(struct dccp_sock*, struct dccp_request_sock*,\n\t\t\t  struct sk_buff *skb);\nint dccp_feat_activate_values(struct sock *sk, struct list_head *fn);\nvoid dccp_feat_list_purge(struct list_head *fn_list);\n\nint dccp_insert_options(struct sock *sk, struct sk_buff *skb);\nint dccp_insert_options_rsk(struct dccp_request_sock *, struct sk_buff *);\nu32 dccp_timestamp(void);\nvoid dccp_timestamping_init(void);\nint dccp_insert_option(struct sk_buff *skb, unsigned char option,\n\t\t       const void *value, unsigned char len);\n\n#ifdef CONFIG_SYSCTL\nint dccp_sysctl_init(void);\nvoid dccp_sysctl_exit(void);\n#else\nstatic inline int dccp_sysctl_init(void)\n{\n\treturn 0;\n}\n\nstatic inline void dccp_sysctl_exit(void)\n{\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}