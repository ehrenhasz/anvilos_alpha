{
  "module_name": "hsr_device.c",
  "hash_id": "8706b1a175294ce241af94eddd889cc3448a227fb8d0e6bf591ab46568281aa6",
  "original_prompt": "Ingested from linux-6.6.14/net/hsr/hsr_device.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/pkt_sched.h>\n#include \"hsr_device.h\"\n#include \"hsr_slave.h\"\n#include \"hsr_framereg.h\"\n#include \"hsr_main.h\"\n#include \"hsr_forward.h\"\n\nstatic bool is_admin_up(struct net_device *dev)\n{\n\treturn dev && (dev->flags & IFF_UP);\n}\n\nstatic bool is_slave_up(struct net_device *dev)\n{\n\treturn dev && is_admin_up(dev) && netif_oper_up(dev);\n}\n\nstatic void __hsr_set_operstate(struct net_device *dev, int transition)\n{\n\twrite_lock(&dev_base_lock);\n\tif (dev->operstate != transition) {\n\t\tdev->operstate = transition;\n\t\twrite_unlock(&dev_base_lock);\n\t\tnetdev_state_change(dev);\n\t} else {\n\t\twrite_unlock(&dev_base_lock);\n\t}\n}\n\nstatic void hsr_set_operstate(struct hsr_port *master, bool has_carrier)\n{\n\tif (!is_admin_up(master->dev)) {\n\t\t__hsr_set_operstate(master->dev, IF_OPER_DOWN);\n\t\treturn;\n\t}\n\n\tif (has_carrier)\n\t\t__hsr_set_operstate(master->dev, IF_OPER_UP);\n\telse\n\t\t__hsr_set_operstate(master->dev, IF_OPER_LOWERLAYERDOWN);\n}\n\nstatic bool hsr_check_carrier(struct hsr_port *master)\n{\n\tstruct hsr_port *port;\n\n\tASSERT_RTNL();\n\n\thsr_for_each_port(master->hsr, port) {\n\t\tif (port->type != HSR_PT_MASTER && is_slave_up(port->dev)) {\n\t\t\tnetif_carrier_on(master->dev);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tnetif_carrier_off(master->dev);\n\n\treturn false;\n}\n\nstatic void hsr_check_announce(struct net_device *hsr_dev,\n\t\t\t       unsigned char old_operstate)\n{\n\tstruct hsr_priv *hsr;\n\n\thsr = netdev_priv(hsr_dev);\n\n\tif (hsr_dev->operstate == IF_OPER_UP && old_operstate != IF_OPER_UP) {\n\t\t \n\t\thsr->announce_count = 0;\n\t\tmod_timer(&hsr->announce_timer,\n\t\t\t  jiffies + msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL));\n\t}\n\n\tif (hsr_dev->operstate != IF_OPER_UP && old_operstate == IF_OPER_UP)\n\t\t \n\t\tdel_timer(&hsr->announce_timer);\n}\n\nvoid hsr_check_carrier_and_operstate(struct hsr_priv *hsr)\n{\n\tstruct hsr_port *master;\n\tunsigned char old_operstate;\n\tbool has_carrier;\n\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\t \n\told_operstate = master->dev->operstate;\n\thas_carrier = hsr_check_carrier(master);\n\thsr_set_operstate(master, has_carrier);\n\thsr_check_announce(master->dev, old_operstate);\n}\n\nint hsr_get_max_mtu(struct hsr_priv *hsr)\n{\n\tunsigned int mtu_max;\n\tstruct hsr_port *port;\n\n\tmtu_max = ETH_DATA_LEN;\n\thsr_for_each_port(hsr, port)\n\t\tif (port->type != HSR_PT_MASTER)\n\t\t\tmtu_max = min(port->dev->mtu, mtu_max);\n\n\tif (mtu_max < HSR_HLEN)\n\t\treturn 0;\n\treturn mtu_max - HSR_HLEN;\n}\n\nstatic int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct hsr_priv *hsr;\n\n\thsr = netdev_priv(dev);\n\n\tif (new_mtu > hsr_get_max_mtu(hsr)) {\n\t\tnetdev_info(dev, \"A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\\n\",\n\t\t\t    HSR_HLEN);\n\t\treturn -EINVAL;\n\t}\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic int hsr_dev_open(struct net_device *dev)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tchar designation;\n\n\thsr = netdev_priv(dev);\n\tdesignation = '\\0';\n\n\thsr_for_each_port(hsr, port) {\n\t\tif (port->type == HSR_PT_MASTER)\n\t\t\tcontinue;\n\t\tswitch (port->type) {\n\t\tcase HSR_PT_SLAVE_A:\n\t\t\tdesignation = 'A';\n\t\t\tbreak;\n\t\tcase HSR_PT_SLAVE_B:\n\t\t\tdesignation = 'B';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdesignation = '?';\n\t\t}\n\t\tif (!is_slave_up(port->dev))\n\t\t\tnetdev_warn(dev, \"Slave %c (%s) is not up; please bring it up to get a fully working HSR network\\n\",\n\t\t\t\t    designation, port->dev->name);\n\t}\n\n\tif (designation == '\\0')\n\t\tnetdev_warn(dev, \"No slave devices configured\\n\");\n\n\treturn 0;\n}\n\nstatic int hsr_dev_close(struct net_device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic netdev_features_t hsr_features_recompute(struct hsr_priv *hsr,\n\t\t\t\t\t\tnetdev_features_t features)\n{\n\tnetdev_features_t mask;\n\tstruct hsr_port *port;\n\n\tmask = features;\n\n\t \n\tfeatures &= ~NETIF_F_ONE_FOR_ALL;\n\thsr_for_each_port(hsr, port)\n\t\tfeatures = netdev_increment_features(features,\n\t\t\t\t\t\t     port->dev->features,\n\t\t\t\t\t\t     mask);\n\n\treturn features;\n}\n\nstatic netdev_features_t hsr_fix_features(struct net_device *dev,\n\t\t\t\t\t  netdev_features_t features)\n{\n\tstruct hsr_priv *hsr = netdev_priv(dev);\n\n\treturn hsr_features_recompute(hsr, features);\n}\n\nstatic netdev_tx_t hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct hsr_priv *hsr = netdev_priv(dev);\n\tstruct hsr_port *master;\n\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\tif (master) {\n\t\tskb->dev = master->dev;\n\t\tskb_reset_mac_header(skb);\n\t\tskb_reset_mac_len(skb);\n\t\tspin_lock_bh(&hsr->seqnr_lock);\n\t\thsr_forward_skb(skb, master);\n\t\tspin_unlock_bh(&hsr->seqnr_lock);\n\t} else {\n\t\tdev_core_stats_tx_dropped_inc(dev);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct header_ops hsr_header_ops = {\n\t.create\t = eth_header,\n\t.parse\t = eth_header_parse,\n};\n\nstatic struct sk_buff *hsr_init_skb(struct hsr_port *master)\n{\n\tstruct hsr_priv *hsr = master->hsr;\n\tstruct sk_buff *skb;\n\tint hlen, tlen;\n\n\thlen = LL_RESERVED_SPACE(master->dev);\n\ttlen = master->dev->needed_tailroom;\n\t \n\tskb = dev_alloc_skb(sizeof(struct hsr_sup_tag) +\n\t\t\t    sizeof(struct hsr_sup_payload) + hlen + tlen);\n\n\tif (!skb)\n\t\treturn skb;\n\n\tskb_reserve(skb, hlen);\n\tskb->dev = master->dev;\n\tskb->priority = TC_PRIO_CONTROL;\n\n\tif (dev_hard_header(skb, skb->dev, ETH_P_PRP,\n\t\t\t    hsr->sup_multicast_addr,\n\t\t\t    skb->dev->dev_addr, skb->len) <= 0)\n\t\tgoto out;\n\n\tskb_reset_mac_header(skb);\n\tskb_reset_mac_len(skb);\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\n\treturn skb;\nout:\n\tkfree_skb(skb);\n\n\treturn NULL;\n}\n\nstatic void send_hsr_supervision_frame(struct hsr_port *master,\n\t\t\t\t       unsigned long *interval)\n{\n\tstruct hsr_priv *hsr = master->hsr;\n\t__u8 type = HSR_TLV_LIFE_CHECK;\n\tstruct hsr_sup_payload *hsr_sp;\n\tstruct hsr_sup_tag *hsr_stag;\n\tstruct sk_buff *skb;\n\n\t*interval = msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);\n\tif (hsr->announce_count < 3 && hsr->prot_version == 0) {\n\t\ttype = HSR_TLV_ANNOUNCE;\n\t\t*interval = msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);\n\t\thsr->announce_count++;\n\t}\n\n\tskb = hsr_init_skb(master);\n\tif (!skb) {\n\t\tWARN_ONCE(1, \"HSR: Could not send supervision frame\\n\");\n\t\treturn;\n\t}\n\n\thsr_stag = skb_put(skb, sizeof(struct hsr_sup_tag));\n\tset_hsr_stag_path(hsr_stag, (hsr->prot_version ? 0x0 : 0xf));\n\tset_hsr_stag_HSR_ver(hsr_stag, hsr->prot_version);\n\n\t \n\tspin_lock_bh(&hsr->seqnr_lock);\n\tif (hsr->prot_version > 0) {\n\t\thsr_stag->sequence_nr = htons(hsr->sup_sequence_nr);\n\t\thsr->sup_sequence_nr++;\n\t} else {\n\t\thsr_stag->sequence_nr = htons(hsr->sequence_nr);\n\t\thsr->sequence_nr++;\n\t}\n\n\thsr_stag->tlv.HSR_TLV_type = type;\n\t \n\thsr_stag->tlv.HSR_TLV_length = hsr->prot_version ?\n\t\t\t\tsizeof(struct hsr_sup_payload) : 12;\n\n\t \n\thsr_sp = skb_put(skb, sizeof(struct hsr_sup_payload));\n\tether_addr_copy(hsr_sp->macaddress_A, master->dev->dev_addr);\n\n\tif (skb_put_padto(skb, ETH_ZLEN)) {\n\t\tspin_unlock_bh(&hsr->seqnr_lock);\n\t\treturn;\n\t}\n\n\thsr_forward_skb(skb, master);\n\tspin_unlock_bh(&hsr->seqnr_lock);\n\treturn;\n}\n\nstatic void send_prp_supervision_frame(struct hsr_port *master,\n\t\t\t\t       unsigned long *interval)\n{\n\tstruct hsr_priv *hsr = master->hsr;\n\tstruct hsr_sup_payload *hsr_sp;\n\tstruct hsr_sup_tag *hsr_stag;\n\tstruct sk_buff *skb;\n\n\tskb = hsr_init_skb(master);\n\tif (!skb) {\n\t\tWARN_ONCE(1, \"PRP: Could not send supervision frame\\n\");\n\t\treturn;\n\t}\n\n\t*interval = msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);\n\thsr_stag = skb_put(skb, sizeof(struct hsr_sup_tag));\n\tset_hsr_stag_path(hsr_stag, (hsr->prot_version ? 0x0 : 0xf));\n\tset_hsr_stag_HSR_ver(hsr_stag, (hsr->prot_version ? 1 : 0));\n\n\t \n\tspin_lock_bh(&hsr->seqnr_lock);\n\thsr_stag->sequence_nr = htons(hsr->sup_sequence_nr);\n\thsr->sup_sequence_nr++;\n\thsr_stag->tlv.HSR_TLV_type = PRP_TLV_LIFE_CHECK_DD;\n\thsr_stag->tlv.HSR_TLV_length = sizeof(struct hsr_sup_payload);\n\n\t \n\thsr_sp = skb_put(skb, sizeof(struct hsr_sup_payload));\n\tether_addr_copy(hsr_sp->macaddress_A, master->dev->dev_addr);\n\n\tif (skb_put_padto(skb, ETH_ZLEN)) {\n\t\tspin_unlock_bh(&hsr->seqnr_lock);\n\t\treturn;\n\t}\n\n\thsr_forward_skb(skb, master);\n\tspin_unlock_bh(&hsr->seqnr_lock);\n}\n\n \nstatic void hsr_announce(struct timer_list *t)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *master;\n\tunsigned long interval;\n\n\thsr = from_timer(hsr, t, announce_timer);\n\n\trcu_read_lock();\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\thsr->proto_ops->send_sv_frame(master, &interval);\n\n\tif (is_admin_up(master->dev))\n\t\tmod_timer(&hsr->announce_timer, jiffies + interval);\n\n\trcu_read_unlock();\n}\n\nvoid hsr_del_ports(struct hsr_priv *hsr)\n{\n\tstruct hsr_port *port;\n\n\tport = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\n\tif (port)\n\t\thsr_del_port(port);\n\n\tport = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\n\tif (port)\n\t\thsr_del_port(port);\n\n\tport = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\tif (port)\n\t\thsr_del_port(port);\n}\n\nstatic const struct net_device_ops hsr_device_ops = {\n\t.ndo_change_mtu = hsr_dev_change_mtu,\n\t.ndo_open = hsr_dev_open,\n\t.ndo_stop = hsr_dev_close,\n\t.ndo_start_xmit = hsr_dev_xmit,\n\t.ndo_fix_features = hsr_fix_features,\n};\n\nstatic struct device_type hsr_type = {\n\t.name = \"hsr\",\n};\n\nstatic struct hsr_proto_ops hsr_ops = {\n\t.send_sv_frame = send_hsr_supervision_frame,\n\t.create_tagged_frame = hsr_create_tagged_frame,\n\t.get_untagged_frame = hsr_get_untagged_frame,\n\t.drop_frame = hsr_drop_frame,\n\t.fill_frame_info = hsr_fill_frame_info,\n\t.invalid_dan_ingress_frame = hsr_invalid_dan_ingress_frame,\n};\n\nstatic struct hsr_proto_ops prp_ops = {\n\t.send_sv_frame = send_prp_supervision_frame,\n\t.create_tagged_frame = prp_create_tagged_frame,\n\t.get_untagged_frame = prp_get_untagged_frame,\n\t.drop_frame = prp_drop_frame,\n\t.fill_frame_info = prp_fill_frame_info,\n\t.handle_san_frame = prp_handle_san_frame,\n\t.update_san_info = prp_update_san_info,\n};\n\nvoid hsr_dev_setup(struct net_device *dev)\n{\n\teth_hw_addr_random(dev);\n\n\tether_setup(dev);\n\tdev->min_mtu = 0;\n\tdev->header_ops = &hsr_header_ops;\n\tdev->netdev_ops = &hsr_device_ops;\n\tSET_NETDEV_DEVTYPE(dev, &hsr_type);\n\tdev->priv_flags |= IFF_NO_QUEUE | IFF_DISABLE_NETPOLL;\n\n\tdev->needs_free_netdev = true;\n\n\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |\n\t\t\t   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |\n\t\t\t   NETIF_F_HW_VLAN_CTAG_TX;\n\n\tdev->features = dev->hw_features;\n\n\t \n\tdev->features |= NETIF_F_LLTX;\n\t \n\tdev->features |= NETIF_F_VLAN_CHALLENGED;\n\t \n\tdev->features |= NETIF_F_NETNS_LOCAL;\n}\n\n \nbool is_hsr_master(struct net_device *dev)\n{\n\treturn (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);\n}\nEXPORT_SYMBOL(is_hsr_master);\n\n \nstatic const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {\n\t0x01, 0x15, 0x4e, 0x00, 0x01, 0x00\n};\n\nint hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tbool unregister = false;\n\tstruct hsr_priv *hsr;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tspin_lock_init(&hsr->list_lock);\n\n\teth_hw_addr_set(hsr_dev, slave[0]->dev_addr);\n\n\t \n\tif (protocol_version == PRP_V1) {\n\t\t \n\t\thsr->net_id = PRP_LAN_ID << 1;\n\t\thsr->proto_ops = &prp_ops;\n\t} else {\n\t\thsr->proto_ops = &hsr_ops;\n\t}\n\n\t \n\tres = hsr_create_self_node(hsr, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t \n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->prot_version = protocol_version;\n\n\t \n\tnetif_carrier_off(hsr_dev);\n\n\tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER, extack);\n\tif (res)\n\t\tgoto err_add_master;\n\n\t \n\tif ((slave[0]->features & NETIF_F_HW_HSR_FWD) &&\n\t    (slave[1]->features & NETIF_F_HW_HSR_FWD))\n\t\thsr->fwd_offloaded = true;\n\n\tres = register_netdevice(hsr_dev);\n\tif (res)\n\t\tgoto err_unregister;\n\n\tunregister = true;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A, extack);\n\tif (res)\n\t\tgoto err_unregister;\n\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B, extack);\n\tif (res)\n\t\tgoto err_unregister;\n\n\thsr_debugfs_init(hsr, hsr_dev);\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\nerr_unregister:\n\thsr_del_ports(hsr);\nerr_add_master:\n\thsr_del_self_node(hsr);\n\n\tif (unregister)\n\t\tunregister_netdevice(hsr_dev);\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}