{
  "module_name": "hsr_forward.c",
  "hash_id": "e7a3e1d29dce98c8310d9aff802d54b51fbd39158b2eb4fca82799c989bd4c8c",
  "original_prompt": "Ingested from linux-6.6.14/net/hsr/hsr_forward.c",
  "human_readable_source": "\n \n\n#include \"hsr_forward.h\"\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include \"hsr_main.h\"\n#include \"hsr_framereg.h\"\n\nstruct hsr_node;\n\n \nstatic bool is_supervision_frame(struct hsr_priv *hsr, struct sk_buff *skb)\n{\n\tstruct ethhdr *eth_hdr;\n\tstruct hsr_sup_tag *hsr_sup_tag;\n\tstruct hsrv1_ethhdr_sp *hsr_V1_hdr;\n\tstruct hsr_sup_tlv *hsr_sup_tlv;\n\tu16 total_length = 0;\n\n\tWARN_ON_ONCE(!skb_mac_header_was_set(skb));\n\teth_hdr = (struct ethhdr *)skb_mac_header(skb);\n\n\t \n\tif (!ether_addr_equal(eth_hdr->h_dest,\n\t\t\t      hsr->sup_multicast_addr))\n\t\treturn false;\n\n\t \n\tif (!(eth_hdr->h_proto == htons(ETH_P_PRP) ||\n\t      eth_hdr->h_proto == htons(ETH_P_HSR)))\n\t\treturn false;\n\n\t \n\tif (eth_hdr->h_proto == htons(ETH_P_HSR)) {  \n\t\ttotal_length = sizeof(struct hsrv1_ethhdr_sp);\n\t\tif (!pskb_may_pull(skb, total_length))\n\t\t\treturn false;\n\n\t\thsr_V1_hdr = (struct hsrv1_ethhdr_sp *)skb_mac_header(skb);\n\t\tif (hsr_V1_hdr->hsr.encap_proto != htons(ETH_P_PRP))\n\t\t\treturn false;\n\n\t\thsr_sup_tag = &hsr_V1_hdr->hsr_sup;\n\t} else {\n\t\ttotal_length = sizeof(struct hsrv0_ethhdr_sp);\n\t\tif (!pskb_may_pull(skb, total_length))\n\t\t\treturn false;\n\n\t\thsr_sup_tag =\n\t\t     &((struct hsrv0_ethhdr_sp *)skb_mac_header(skb))->hsr_sup;\n\t}\n\n\tif (hsr_sup_tag->tlv.HSR_TLV_type != HSR_TLV_ANNOUNCE &&\n\t    hsr_sup_tag->tlv.HSR_TLV_type != HSR_TLV_LIFE_CHECK &&\n\t    hsr_sup_tag->tlv.HSR_TLV_type != PRP_TLV_LIFE_CHECK_DD &&\n\t    hsr_sup_tag->tlv.HSR_TLV_type != PRP_TLV_LIFE_CHECK_DA)\n\t\treturn false;\n\tif (hsr_sup_tag->tlv.HSR_TLV_length != 12 &&\n\t    hsr_sup_tag->tlv.HSR_TLV_length != sizeof(struct hsr_sup_payload))\n\t\treturn false;\n\n\t \n\ttotal_length += sizeof(struct hsr_sup_tlv) + hsr_sup_tag->tlv.HSR_TLV_length;\n\tif (!pskb_may_pull(skb, total_length))\n\t\treturn false;\n\tskb_pull(skb, total_length);\n\thsr_sup_tlv = (struct hsr_sup_tlv *)skb->data;\n\tskb_push(skb, total_length);\n\n\t \n\tif (hsr_sup_tlv->HSR_TLV_type == PRP_TLV_REDBOX_MAC) {\n\t\t \n\t\tif (hsr_sup_tlv->HSR_TLV_length != sizeof(struct hsr_sup_payload))\n\t\t\treturn false;\n\n\t\t \n\t\ttotal_length += sizeof(struct hsr_sup_tlv) + hsr_sup_tlv->HSR_TLV_length;\n\t\tif (!pskb_may_pull(skb, total_length))\n\t\t\treturn false;\n\n\t\t \n\t\tskb_pull(skb, total_length);\n\t\thsr_sup_tlv = (struct hsr_sup_tlv *)skb->data;\n\t\tskb_push(skb, total_length);\n\t}\n\n\t \n\tif (hsr_sup_tlv->HSR_TLV_type == HSR_TLV_EOT &&\n\t    hsr_sup_tlv->HSR_TLV_length != 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct sk_buff *create_stripped_skb_hsr(struct sk_buff *skb_in,\n\t\t\t\t\t       struct hsr_frame_info *frame)\n{\n\tstruct sk_buff *skb;\n\tint copylen;\n\tunsigned char *dst, *src;\n\n\tskb_pull(skb_in, HSR_HLEN);\n\tskb = __pskb_copy(skb_in, skb_headroom(skb_in) - HSR_HLEN, GFP_ATOMIC);\n\tskb_push(skb_in, HSR_HLEN);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reset_mac_header(skb);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tskb->csum_start -= HSR_HLEN;\n\n\tcopylen = 2 * ETH_ALEN;\n\tif (frame->is_vlan)\n\t\tcopylen += VLAN_HLEN;\n\tsrc = skb_mac_header(skb_in);\n\tdst = skb_mac_header(skb);\n\tmemcpy(dst, src, copylen);\n\n\tskb->protocol = eth_hdr(skb)->h_proto;\n\treturn skb;\n}\n\nstruct sk_buff *hsr_get_untagged_frame(struct hsr_frame_info *frame,\n\t\t\t\t       struct hsr_port *port)\n{\n\tif (!frame->skb_std) {\n\t\tif (frame->skb_hsr)\n\t\t\tframe->skb_std =\n\t\t\t\tcreate_stripped_skb_hsr(frame->skb_hsr, frame);\n\t\telse\n\t\t\tnetdev_warn_once(port->dev,\n\t\t\t\t\t \"Unexpected frame received in hsr_get_untagged_frame()\\n\");\n\n\t\tif (!frame->skb_std)\n\t\t\treturn NULL;\n\t}\n\n\treturn skb_clone(frame->skb_std, GFP_ATOMIC);\n}\n\nstruct sk_buff *prp_get_untagged_frame(struct hsr_frame_info *frame,\n\t\t\t\t       struct hsr_port *port)\n{\n\tif (!frame->skb_std) {\n\t\tif (frame->skb_prp) {\n\t\t\t \n\t\t\tskb_trim(frame->skb_prp,\n\t\t\t\t frame->skb_prp->len - HSR_HLEN);\n\t\t\tframe->skb_std =\n\t\t\t\t__pskb_copy(frame->skb_prp,\n\t\t\t\t\t    skb_headroom(frame->skb_prp),\n\t\t\t\t\t    GFP_ATOMIC);\n\t\t} else {\n\t\t\t \n\t\t\tWARN_ONCE(1, \"%s:%d: Unexpected frame received (port_src %s)\\n\",\n\t\t\t\t  __FILE__, __LINE__, port->dev->name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn skb_clone(frame->skb_std, GFP_ATOMIC);\n}\n\nstatic void prp_set_lan_id(struct prp_rct *trailer,\n\t\t\t   struct hsr_port *port)\n{\n\tint lane_id;\n\n\tif (port->type == HSR_PT_SLAVE_A)\n\t\tlane_id = 0;\n\telse\n\t\tlane_id = 1;\n\n\t \n\tlane_id |= port->hsr->net_id;\n\tset_prp_lan_id(trailer, lane_id);\n}\n\n \nstatic struct sk_buff *prp_fill_rct(struct sk_buff *skb,\n\t\t\t\t    struct hsr_frame_info *frame,\n\t\t\t\t    struct hsr_port *port)\n{\n\tstruct prp_rct *trailer;\n\tint min_size = ETH_ZLEN;\n\tint lsdu_size;\n\n\tif (!skb)\n\t\treturn skb;\n\n\tif (frame->is_vlan)\n\t\tmin_size = VLAN_ETH_ZLEN;\n\n\tif (skb_put_padto(skb, min_size))\n\t\treturn NULL;\n\n\ttrailer = (struct prp_rct *)skb_put(skb, HSR_HLEN);\n\tlsdu_size = skb->len - 14;\n\tif (frame->is_vlan)\n\t\tlsdu_size -= 4;\n\tprp_set_lan_id(trailer, port);\n\tset_prp_LSDU_size(trailer, lsdu_size);\n\ttrailer->sequence_nr = htons(frame->sequence_nr);\n\ttrailer->PRP_suffix = htons(ETH_P_PRP);\n\tskb->protocol = eth_hdr(skb)->h_proto;\n\n\treturn skb;\n}\n\nstatic void hsr_set_path_id(struct hsr_ethhdr *hsr_ethhdr,\n\t\t\t    struct hsr_port *port)\n{\n\tint path_id;\n\n\tif (port->type == HSR_PT_SLAVE_A)\n\t\tpath_id = 0;\n\telse\n\t\tpath_id = 1;\n\n\tset_hsr_tag_path(&hsr_ethhdr->hsr_tag, path_id);\n}\n\nstatic struct sk_buff *hsr_fill_tag(struct sk_buff *skb,\n\t\t\t\t    struct hsr_frame_info *frame,\n\t\t\t\t    struct hsr_port *port, u8 proto_version)\n{\n\tstruct hsr_ethhdr *hsr_ethhdr;\n\tint lsdu_size;\n\n\t \n\tif (skb_put_padto(skb, ETH_ZLEN + HSR_HLEN))\n\t\treturn NULL;\n\n\tlsdu_size = skb->len - 14;\n\tif (frame->is_vlan)\n\t\tlsdu_size -= 4;\n\n\thsr_ethhdr = (struct hsr_ethhdr *)skb_mac_header(skb);\n\n\thsr_set_path_id(hsr_ethhdr, port);\n\tset_hsr_tag_LSDU_size(&hsr_ethhdr->hsr_tag, lsdu_size);\n\thsr_ethhdr->hsr_tag.sequence_nr = htons(frame->sequence_nr);\n\thsr_ethhdr->hsr_tag.encap_proto = hsr_ethhdr->ethhdr.h_proto;\n\thsr_ethhdr->ethhdr.h_proto = htons(proto_version ?\n\t\t\tETH_P_HSR : ETH_P_PRP);\n\tskb->protocol = hsr_ethhdr->ethhdr.h_proto;\n\n\treturn skb;\n}\n\n \nstruct sk_buff *hsr_create_tagged_frame(struct hsr_frame_info *frame,\n\t\t\t\t\tstruct hsr_port *port)\n{\n\tunsigned char *dst, *src;\n\tstruct sk_buff *skb;\n\tint movelen;\n\n\tif (frame->skb_hsr) {\n\t\tstruct hsr_ethhdr *hsr_ethhdr =\n\t\t\t(struct hsr_ethhdr *)skb_mac_header(frame->skb_hsr);\n\n\t\t \n\t\thsr_set_path_id(hsr_ethhdr, port);\n\t\treturn skb_clone(frame->skb_hsr, GFP_ATOMIC);\n\t} else if (port->dev->features & NETIF_F_HW_HSR_TAG_INS) {\n\t\treturn skb_clone(frame->skb_std, GFP_ATOMIC);\n\t}\n\n\t \n\tskb = __pskb_copy(frame->skb_std,\n\t\t\t  skb_headroom(frame->skb_std) + HSR_HLEN, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\tskb_reset_mac_header(skb);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tskb->csum_start += HSR_HLEN;\n\n\tmovelen = ETH_HLEN;\n\tif (frame->is_vlan)\n\t\tmovelen += VLAN_HLEN;\n\n\tsrc = skb_mac_header(skb);\n\tdst = skb_push(skb, HSR_HLEN);\n\tmemmove(dst, src, movelen);\n\tskb_reset_mac_header(skb);\n\n\t \n\treturn hsr_fill_tag(skb, frame, port, port->hsr->prot_version);\n}\n\nstruct sk_buff *prp_create_tagged_frame(struct hsr_frame_info *frame,\n\t\t\t\t\tstruct hsr_port *port)\n{\n\tstruct sk_buff *skb;\n\n\tif (frame->skb_prp) {\n\t\tstruct prp_rct *trailer = skb_get_PRP_rct(frame->skb_prp);\n\n\t\tif (trailer) {\n\t\t\tprp_set_lan_id(trailer, port);\n\t\t} else {\n\t\t\tWARN_ONCE(!trailer, \"errored PRP skb\");\n\t\t\treturn NULL;\n\t\t}\n\t\treturn skb_clone(frame->skb_prp, GFP_ATOMIC);\n\t} else if (port->dev->features & NETIF_F_HW_HSR_TAG_INS) {\n\t\treturn skb_clone(frame->skb_std, GFP_ATOMIC);\n\t}\n\n\tskb = skb_copy_expand(frame->skb_std, 0,\n\t\t\t      skb_tailroom(frame->skb_std) + HSR_HLEN,\n\t\t\t      GFP_ATOMIC);\n\treturn prp_fill_rct(skb, frame, port);\n}\n\nstatic void hsr_deliver_master(struct sk_buff *skb, struct net_device *dev,\n\t\t\t       struct hsr_node *node_src)\n{\n\tbool was_multicast_frame;\n\tint res, recv_len;\n\n\twas_multicast_frame = (skb->pkt_type == PACKET_MULTICAST);\n\thsr_addr_subst_source(node_src, skb);\n\tskb_pull(skb, ETH_HLEN);\n\trecv_len = skb->len;\n\tres = netif_rx(skb);\n\tif (res == NET_RX_DROP) {\n\t\tdev->stats.rx_dropped++;\n\t} else {\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += recv_len;\n\t\tif (was_multicast_frame)\n\t\t\tdev->stats.multicast++;\n\t}\n}\n\nstatic int hsr_xmit(struct sk_buff *skb, struct hsr_port *port,\n\t\t    struct hsr_frame_info *frame)\n{\n\tif (frame->port_rcv->type == HSR_PT_MASTER) {\n\t\thsr_addr_subst_dest(frame->node_src, skb, port);\n\n\t\t \n\t\tether_addr_copy(eth_hdr(skb)->h_source, port->dev->dev_addr);\n\t}\n\treturn dev_queue_xmit(skb);\n}\n\nbool prp_drop_frame(struct hsr_frame_info *frame, struct hsr_port *port)\n{\n\treturn ((frame->port_rcv->type == HSR_PT_SLAVE_A &&\n\t\t port->type ==  HSR_PT_SLAVE_B) ||\n\t\t(frame->port_rcv->type == HSR_PT_SLAVE_B &&\n\t\t port->type ==  HSR_PT_SLAVE_A));\n}\n\nbool hsr_drop_frame(struct hsr_frame_info *frame, struct hsr_port *port)\n{\n\tif (port->dev->features & NETIF_F_HW_HSR_FWD)\n\t\treturn prp_drop_frame(frame, port);\n\n\treturn false;\n}\n\n \nstatic void hsr_forward_do(struct hsr_frame_info *frame)\n{\n\tstruct hsr_port *port;\n\tstruct sk_buff *skb;\n\tbool sent = false;\n\n\thsr_for_each_port(frame->port_rcv->hsr, port) {\n\t\tstruct hsr_priv *hsr = port->hsr;\n\t\t \n\t\tif (port == frame->port_rcv)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (port->type == HSR_PT_MASTER && !frame->is_local_dest)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (port->type != HSR_PT_MASTER && frame->is_local_exclusive)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((port->dev->features & NETIF_F_HW_HSR_DUP) && sent)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!frame->is_from_san &&\n\t\t    hsr_register_frame_out(port, frame->node_src,\n\t\t\t\t\t   frame->sequence_nr))\n\t\t\tcontinue;\n\n\t\tif (frame->is_supervision && port->type == HSR_PT_MASTER) {\n\t\t\thsr_handle_sup_frame(frame);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (hsr->proto_ops->drop_frame &&\n\t\t    hsr->proto_ops->drop_frame(frame, port))\n\t\t\tcontinue;\n\n\t\tif (port->type != HSR_PT_MASTER)\n\t\t\tskb = hsr->proto_ops->create_tagged_frame(frame, port);\n\t\telse\n\t\t\tskb = hsr->proto_ops->get_untagged_frame(frame, port);\n\n\t\tif (!skb) {\n\t\t\tframe->port_rcv->dev->stats.rx_dropped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb->dev = port->dev;\n\t\tif (port->type == HSR_PT_MASTER) {\n\t\t\thsr_deliver_master(skb, port->dev, frame->node_src);\n\t\t} else {\n\t\t\tif (!hsr_xmit(skb, port, frame))\n\t\t\t\tsent = true;\n\t\t}\n\t}\n}\n\nstatic void check_local_dest(struct hsr_priv *hsr, struct sk_buff *skb,\n\t\t\t     struct hsr_frame_info *frame)\n{\n\tif (hsr_addr_is_self(hsr, eth_hdr(skb)->h_dest)) {\n\t\tframe->is_local_exclusive = true;\n\t\tskb->pkt_type = PACKET_HOST;\n\t} else {\n\t\tframe->is_local_exclusive = false;\n\t}\n\n\tif (skb->pkt_type == PACKET_HOST ||\n\t    skb->pkt_type == PACKET_MULTICAST ||\n\t    skb->pkt_type == PACKET_BROADCAST) {\n\t\tframe->is_local_dest = true;\n\t} else {\n\t\tframe->is_local_dest = false;\n\t}\n}\n\nstatic void handle_std_frame(struct sk_buff *skb,\n\t\t\t     struct hsr_frame_info *frame)\n{\n\tstruct hsr_port *port = frame->port_rcv;\n\tstruct hsr_priv *hsr = port->hsr;\n\n\tframe->skb_hsr = NULL;\n\tframe->skb_prp = NULL;\n\tframe->skb_std = skb;\n\n\tif (port->type != HSR_PT_MASTER) {\n\t\tframe->is_from_san = true;\n\t} else {\n\t\t \n\t\tlockdep_assert_held(&hsr->seqnr_lock);\n\t\tframe->sequence_nr = hsr->sequence_nr;\n\t\thsr->sequence_nr++;\n\t}\n}\n\nint hsr_fill_frame_info(__be16 proto, struct sk_buff *skb,\n\t\t\tstruct hsr_frame_info *frame)\n{\n\tstruct hsr_port *port = frame->port_rcv;\n\tstruct hsr_priv *hsr = port->hsr;\n\n\t \n\tif ((!hsr->prot_version && proto == htons(ETH_P_PRP)) ||\n\t    proto == htons(ETH_P_HSR)) {\n\t\t \n\t\tif (skb->mac_len < sizeof(struct hsr_ethhdr))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tframe->skb_std = NULL;\n\t\tframe->skb_prp = NULL;\n\t\tframe->skb_hsr = skb;\n\t\tframe->sequence_nr = hsr_get_skb_sequence_nr(skb);\n\t\treturn 0;\n\t}\n\n\t \n\thandle_std_frame(skb, frame);\n\n\treturn 0;\n}\n\nint prp_fill_frame_info(__be16 proto, struct sk_buff *skb,\n\t\t\tstruct hsr_frame_info *frame)\n{\n\t \n\tstruct prp_rct *rct = skb_get_PRP_rct(skb);\n\n\tif (rct &&\n\t    prp_check_lsdu_size(skb, rct, frame->is_supervision)) {\n\t\tframe->skb_hsr = NULL;\n\t\tframe->skb_std = NULL;\n\t\tframe->skb_prp = skb;\n\t\tframe->sequence_nr = prp_get_skb_sequence_nr(rct);\n\t\treturn 0;\n\t}\n\thandle_std_frame(skb, frame);\n\n\treturn 0;\n}\n\nstatic int fill_frame_info(struct hsr_frame_info *frame,\n\t\t\t   struct sk_buff *skb, struct hsr_port *port)\n{\n\tstruct hsr_priv *hsr = port->hsr;\n\tstruct hsr_vlan_ethhdr *vlan_hdr;\n\tstruct ethhdr *ethhdr;\n\t__be16 proto;\n\tint ret;\n\n\t \n\tif (skb->mac_len < sizeof(struct ethhdr))\n\t\treturn -EINVAL;\n\n\tmemset(frame, 0, sizeof(*frame));\n\tframe->is_supervision = is_supervision_frame(port->hsr, skb);\n\tframe->node_src = hsr_get_node(port, &hsr->node_db, skb,\n\t\t\t\t       frame->is_supervision,\n\t\t\t\t       port->type);\n\tif (!frame->node_src)\n\t\treturn -1;  \n\n\tethhdr = (struct ethhdr *)skb_mac_header(skb);\n\tframe->is_vlan = false;\n\tproto = ethhdr->h_proto;\n\n\tif (proto == htons(ETH_P_8021Q))\n\t\tframe->is_vlan = true;\n\n\tif (frame->is_vlan) {\n\t\tvlan_hdr = (struct hsr_vlan_ethhdr *)ethhdr;\n\t\tproto = vlan_hdr->vlanhdr.h_vlan_encapsulated_proto;\n\t\t \n\t\tnetdev_warn_once(skb->dev, \"VLAN not yet supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tframe->is_from_san = false;\n\tframe->port_rcv = port;\n\tret = hsr->proto_ops->fill_frame_info(proto, skb, frame);\n\tif (ret)\n\t\treturn ret;\n\n\tcheck_local_dest(port->hsr, skb, frame);\n\n\treturn 0;\n}\n\n \nvoid hsr_forward_skb(struct sk_buff *skb, struct hsr_port *port)\n{\n\tstruct hsr_frame_info frame;\n\n\trcu_read_lock();\n\tif (fill_frame_info(&frame, skb, port) < 0)\n\t\tgoto out_drop;\n\n\thsr_register_frame_in(frame.node_src, port, frame.sequence_nr);\n\thsr_forward_do(&frame);\n\trcu_read_unlock();\n\t \n\tif (port->type == HSR_PT_MASTER) {\n\t\tport->dev->stats.tx_packets++;\n\t\tport->dev->stats.tx_bytes += skb->len;\n\t}\n\n\tkfree_skb(frame.skb_hsr);\n\tkfree_skb(frame.skb_prp);\n\tkfree_skb(frame.skb_std);\n\treturn;\n\nout_drop:\n\trcu_read_unlock();\n\tport->dev->stats.tx_dropped++;\n\tkfree_skb(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}