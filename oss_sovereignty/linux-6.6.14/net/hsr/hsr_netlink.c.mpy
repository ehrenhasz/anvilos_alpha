{
  "module_name": "hsr_netlink.c",
  "hash_id": "d38d341a62324f610fd14b4f070478babcd6193a9c0db711cd4cc1d3ee2e3361",
  "original_prompt": "Ingested from linux-6.6.14/net/hsr/hsr_netlink.c",
  "human_readable_source": "\n \n\n#include \"hsr_netlink.h\"\n#include <linux/kernel.h>\n#include <net/rtnetlink.h>\n#include <net/genetlink.h>\n#include \"hsr_main.h\"\n#include \"hsr_device.h\"\n#include \"hsr_framereg.h\"\n\nstatic const struct nla_policy hsr_policy[IFLA_HSR_MAX + 1] = {\n\t[IFLA_HSR_SLAVE1]\t\t= { .type = NLA_U32 },\n\t[IFLA_HSR_SLAVE2]\t\t= { .type = NLA_U32 },\n\t[IFLA_HSR_MULTICAST_SPEC]\t= { .type = NLA_U8 },\n\t[IFLA_HSR_VERSION]\t= { .type = NLA_U8 },\n\t[IFLA_HSR_SUPERVISION_ADDR]\t= { .len = ETH_ALEN },\n\t[IFLA_HSR_SEQ_NR]\t\t= { .type = NLA_U16 },\n\t[IFLA_HSR_PROTOCOL]\t\t= { .type = NLA_U8 },\n};\n\n \nstatic int hsr_newlink(struct net *src_net, struct net_device *dev,\n\t\t       struct nlattr *tb[], struct nlattr *data[],\n\t\t       struct netlink_ext_ack *extack)\n{\n\tenum hsr_version proto_version;\n\tunsigned char multicast_spec;\n\tu8 proto = HSR_PROTOCOL_HSR;\n\tstruct net_device *link[2];\n\n\tif (!data) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No slave devices specified\");\n\t\treturn -EINVAL;\n\t}\n\tif (!data[IFLA_HSR_SLAVE1]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Slave1 device not specified\");\n\t\treturn -EINVAL;\n\t}\n\tlink[0] = __dev_get_by_index(src_net,\n\t\t\t\t     nla_get_u32(data[IFLA_HSR_SLAVE1]));\n\tif (!link[0]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Slave1 does not exist\");\n\t\treturn -EINVAL;\n\t}\n\tif (!data[IFLA_HSR_SLAVE2]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Slave2 device not specified\");\n\t\treturn -EINVAL;\n\t}\n\tlink[1] = __dev_get_by_index(src_net,\n\t\t\t\t     nla_get_u32(data[IFLA_HSR_SLAVE2]));\n\tif (!link[1]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Slave2 does not exist\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (link[0] == link[1]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Slave1 and Slave2 are same\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data[IFLA_HSR_MULTICAST_SPEC])\n\t\tmulticast_spec = 0;\n\telse\n\t\tmulticast_spec = nla_get_u8(data[IFLA_HSR_MULTICAST_SPEC]);\n\n\tif (data[IFLA_HSR_PROTOCOL])\n\t\tproto = nla_get_u8(data[IFLA_HSR_PROTOCOL]);\n\n\tif (proto >= HSR_PROTOCOL_MAX) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported protocol\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data[IFLA_HSR_VERSION]) {\n\t\tproto_version = HSR_V0;\n\t} else {\n\t\tif (proto == HSR_PROTOCOL_PRP) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"PRP version unsupported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tproto_version = nla_get_u8(data[IFLA_HSR_VERSION]);\n\t\tif (proto_version > HSR_V1) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Only HSR version 0/1 supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (proto == HSR_PROTOCOL_PRP)\n\t\tproto_version = PRP_V1;\n\n\treturn hsr_dev_finalize(dev, link, multicast_spec, proto_version, extack);\n}\n\nstatic void hsr_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct hsr_priv *hsr = netdev_priv(dev);\n\n\tdel_timer_sync(&hsr->prune_timer);\n\tdel_timer_sync(&hsr->announce_timer);\n\n\thsr_debugfs_term(hsr);\n\thsr_del_ports(hsr);\n\n\thsr_del_self_node(hsr);\n\thsr_del_nodes(&hsr->node_db);\n\n\tunregister_netdevice_queue(dev, head);\n}\n\nstatic int hsr_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct hsr_priv *hsr = netdev_priv(dev);\n\tu8 proto = HSR_PROTOCOL_HSR;\n\tstruct hsr_port *port;\n\n\tport = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\n\tif (port) {\n\t\tif (nla_put_u32(skb, IFLA_HSR_SLAVE1, port->dev->ifindex))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tport = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\n\tif (port) {\n\t\tif (nla_put_u32(skb, IFLA_HSR_SLAVE2, port->dev->ifindex))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put(skb, IFLA_HSR_SUPERVISION_ADDR, ETH_ALEN,\n\t\t    hsr->sup_multicast_addr) ||\n\t    nla_put_u16(skb, IFLA_HSR_SEQ_NR, hsr->sequence_nr))\n\t\tgoto nla_put_failure;\n\tif (hsr->prot_version == PRP_V1)\n\t\tproto = HSR_PROTOCOL_PRP;\n\tif (nla_put_u8(skb, IFLA_HSR_PROTOCOL, proto))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic struct rtnl_link_ops hsr_link_ops __read_mostly = {\n\t.kind\t\t= \"hsr\",\n\t.maxtype\t= IFLA_HSR_MAX,\n\t.policy\t\t= hsr_policy,\n\t.priv_size\t= sizeof(struct hsr_priv),\n\t.setup\t\t= hsr_dev_setup,\n\t.newlink\t= hsr_newlink,\n\t.dellink\t= hsr_dellink,\n\t.fill_info\t= hsr_fill_info,\n};\n\n \nstatic const struct nla_policy hsr_genl_policy[HSR_A_MAX + 1] = {\n\t[HSR_A_NODE_ADDR] = { .len = ETH_ALEN },\n\t[HSR_A_NODE_ADDR_B] = { .len = ETH_ALEN },\n\t[HSR_A_IFINDEX] = { .type = NLA_U32 },\n\t[HSR_A_IF1_AGE] = { .type = NLA_U32 },\n\t[HSR_A_IF2_AGE] = { .type = NLA_U32 },\n\t[HSR_A_IF1_SEQ] = { .type = NLA_U16 },\n\t[HSR_A_IF2_SEQ] = { .type = NLA_U16 },\n};\n\nstatic struct genl_family hsr_genl_family;\n\nstatic const struct genl_multicast_group hsr_mcgrps[] = {\n\t{ .name = \"hsr-network\", },\n};\n\n \nvoid hsr_nl_ringerror(struct hsr_priv *hsr, unsigned char addr[ETH_ALEN],\n\t\t      struct hsr_port *port)\n{\n\tstruct sk_buff *skb;\n\tvoid *msg_head;\n\tstruct hsr_port *master;\n\tint res;\n\n\tskb = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto fail;\n\n\tmsg_head = genlmsg_put(skb, 0, 0, &hsr_genl_family, 0,\n\t\t\t       HSR_C_RING_ERROR);\n\tif (!msg_head)\n\t\tgoto nla_put_failure;\n\n\tres = nla_put(skb, HSR_A_NODE_ADDR, ETH_ALEN, addr);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\n\tres = nla_put_u32(skb, HSR_A_IFINDEX, port->dev->ifindex);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, msg_head);\n\tgenlmsg_multicast(&hsr_genl_family, skb, 0, 0, GFP_ATOMIC);\n\n\treturn;\n\nnla_put_failure:\n\tkfree_skb(skb);\n\nfail:\n\trcu_read_lock();\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\tnetdev_warn(master->dev, \"Could not send HSR ring error message\\n\");\n\trcu_read_unlock();\n}\n\n \nvoid hsr_nl_nodedown(struct hsr_priv *hsr, unsigned char addr[ETH_ALEN])\n{\n\tstruct sk_buff *skb;\n\tvoid *msg_head;\n\tstruct hsr_port *master;\n\tint res;\n\n\tskb = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto fail;\n\n\tmsg_head = genlmsg_put(skb, 0, 0, &hsr_genl_family, 0, HSR_C_NODE_DOWN);\n\tif (!msg_head)\n\t\tgoto nla_put_failure;\n\n\tres = nla_put(skb, HSR_A_NODE_ADDR, ETH_ALEN, addr);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, msg_head);\n\tgenlmsg_multicast(&hsr_genl_family, skb, 0, 0, GFP_ATOMIC);\n\n\treturn;\n\nnla_put_failure:\n\tkfree_skb(skb);\n\nfail:\n\trcu_read_lock();\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\tnetdev_warn(master->dev, \"Could not send HSR node down\\n\");\n\trcu_read_unlock();\n}\n\n \nstatic int hsr_get_node_status(struct sk_buff *skb_in, struct genl_info *info)\n{\n\t \n\tstruct nlattr *na;\n\tstruct net_device *hsr_dev;\n\n\t \n\tstruct sk_buff *skb_out;\n\tvoid *msg_head;\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tunsigned char hsr_node_addr_b[ETH_ALEN];\n\tint hsr_node_if1_age;\n\tu16 hsr_node_if1_seq;\n\tint hsr_node_if2_age;\n\tu16 hsr_node_if2_seq;\n\tint addr_b_ifindex;\n\tint res;\n\n\tif (!info)\n\t\tgoto invalid;\n\n\tna = info->attrs[HSR_A_IFINDEX];\n\tif (!na)\n\t\tgoto invalid;\n\tna = info->attrs[HSR_A_NODE_ADDR];\n\tif (!na)\n\t\tgoto invalid;\n\n\trcu_read_lock();\n\thsr_dev = dev_get_by_index_rcu(genl_info_net(info),\n\t\t\t\t       nla_get_u32(info->attrs[HSR_A_IFINDEX]));\n\tif (!hsr_dev)\n\t\tgoto rcu_unlock;\n\tif (!is_hsr_master(hsr_dev))\n\t\tgoto rcu_unlock;\n\n\t \n\tskb_out = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb_out) {\n\t\tres = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmsg_head = genlmsg_put(skb_out, NETLINK_CB(skb_in).portid,\n\t\t\t       info->snd_seq, &hsr_genl_family, 0,\n\t\t\t       HSR_C_SET_NODE_STATUS);\n\tif (!msg_head) {\n\t\tres = -ENOMEM;\n\t\tgoto nla_put_failure;\n\t}\n\n\tres = nla_put_u32(skb_out, HSR_A_IFINDEX, hsr_dev->ifindex);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\n\thsr = netdev_priv(hsr_dev);\n\tres = hsr_get_node_data(hsr,\n\t\t\t\t(unsigned char *)\n\t\t\t\tnla_data(info->attrs[HSR_A_NODE_ADDR]),\n\t\t\t\t\t hsr_node_addr_b,\n\t\t\t\t\t &addr_b_ifindex,\n\t\t\t\t\t &hsr_node_if1_age,\n\t\t\t\t\t &hsr_node_if1_seq,\n\t\t\t\t\t &hsr_node_if2_age,\n\t\t\t\t\t &hsr_node_if2_seq);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\n\tres = nla_put(skb_out, HSR_A_NODE_ADDR, ETH_ALEN,\n\t\t      nla_data(info->attrs[HSR_A_NODE_ADDR]));\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\n\tif (addr_b_ifindex > -1) {\n\t\tres = nla_put(skb_out, HSR_A_NODE_ADDR_B, ETH_ALEN,\n\t\t\t      hsr_node_addr_b);\n\t\tif (res < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tres = nla_put_u32(skb_out, HSR_A_ADDR_B_IFINDEX,\n\t\t\t\t  addr_b_ifindex);\n\t\tif (res < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tres = nla_put_u32(skb_out, HSR_A_IF1_AGE, hsr_node_if1_age);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\tres = nla_put_u16(skb_out, HSR_A_IF1_SEQ, hsr_node_if1_seq);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\tport = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\n\tif (port)\n\t\tres = nla_put_u32(skb_out, HSR_A_IF1_IFINDEX,\n\t\t\t\t  port->dev->ifindex);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\n\tres = nla_put_u32(skb_out, HSR_A_IF2_AGE, hsr_node_if2_age);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\tres = nla_put_u16(skb_out, HSR_A_IF2_SEQ, hsr_node_if2_seq);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\tport = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\n\tif (port)\n\t\tres = nla_put_u32(skb_out, HSR_A_IF2_IFINDEX,\n\t\t\t\t  port->dev->ifindex);\n\tif (res < 0)\n\t\tgoto nla_put_failure;\n\n\trcu_read_unlock();\n\n\tgenlmsg_end(skb_out, msg_head);\n\tgenlmsg_unicast(genl_info_net(info), skb_out, info->snd_portid);\n\n\treturn 0;\n\nrcu_unlock:\n\trcu_read_unlock();\ninvalid:\n\tnetlink_ack(skb_in, nlmsg_hdr(skb_in), -EINVAL, NULL);\n\treturn 0;\n\nnla_put_failure:\n\tkfree_skb(skb_out);\n\t \n\nfail:\n\trcu_read_unlock();\n\treturn res;\n}\n\n \nstatic int hsr_get_node_list(struct sk_buff *skb_in, struct genl_info *info)\n{\n\tunsigned char addr[ETH_ALEN];\n\tstruct net_device *hsr_dev;\n\tstruct sk_buff *skb_out;\n\tstruct hsr_priv *hsr;\n\tbool restart = false;\n\tstruct nlattr *na;\n\tvoid *pos = NULL;\n\tvoid *msg_head;\n\tint res;\n\n\tif (!info)\n\t\tgoto invalid;\n\n\tna = info->attrs[HSR_A_IFINDEX];\n\tif (!na)\n\t\tgoto invalid;\n\n\trcu_read_lock();\n\thsr_dev = dev_get_by_index_rcu(genl_info_net(info),\n\t\t\t\t       nla_get_u32(info->attrs[HSR_A_IFINDEX]));\n\tif (!hsr_dev)\n\t\tgoto rcu_unlock;\n\tif (!is_hsr_master(hsr_dev))\n\t\tgoto rcu_unlock;\n\nrestart:\n\t \n\tskb_out = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb_out) {\n\t\tres = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmsg_head = genlmsg_put(skb_out, NETLINK_CB(skb_in).portid,\n\t\t\t       info->snd_seq, &hsr_genl_family, 0,\n\t\t\t       HSR_C_SET_NODE_LIST);\n\tif (!msg_head) {\n\t\tres = -ENOMEM;\n\t\tgoto nla_put_failure;\n\t}\n\n\tif (!restart) {\n\t\tres = nla_put_u32(skb_out, HSR_A_IFINDEX, hsr_dev->ifindex);\n\t\tif (res < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\thsr = netdev_priv(hsr_dev);\n\n\tif (!pos)\n\t\tpos = hsr_get_next_node(hsr, NULL, addr);\n\twhile (pos) {\n\t\tres = nla_put(skb_out, HSR_A_NODE_ADDR, ETH_ALEN, addr);\n\t\tif (res < 0) {\n\t\t\tif (res == -EMSGSIZE) {\n\t\t\t\tgenlmsg_end(skb_out, msg_head);\n\t\t\t\tgenlmsg_unicast(genl_info_net(info), skb_out,\n\t\t\t\t\t\tinfo->snd_portid);\n\t\t\t\trestart = true;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tpos = hsr_get_next_node(hsr, pos, addr);\n\t}\n\trcu_read_unlock();\n\n\tgenlmsg_end(skb_out, msg_head);\n\tgenlmsg_unicast(genl_info_net(info), skb_out, info->snd_portid);\n\n\treturn 0;\n\nrcu_unlock:\n\trcu_read_unlock();\ninvalid:\n\tnetlink_ack(skb_in, nlmsg_hdr(skb_in), -EINVAL, NULL);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_free(skb_out);\n\t \n\nfail:\n\trcu_read_unlock();\n\treturn res;\n}\n\nstatic const struct genl_small_ops hsr_ops[] = {\n\t{\n\t\t.cmd = HSR_C_GET_NODE_STATUS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = 0,\n\t\t.doit = hsr_get_node_status,\n\t\t.dumpit = NULL,\n\t},\n\t{\n\t\t.cmd = HSR_C_GET_NODE_LIST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = 0,\n\t\t.doit = hsr_get_node_list,\n\t\t.dumpit = NULL,\n\t},\n};\n\nstatic struct genl_family hsr_genl_family __ro_after_init = {\n\t.hdrsize = 0,\n\t.name = \"HSR\",\n\t.version = 1,\n\t.maxattr = HSR_A_MAX,\n\t.policy = hsr_genl_policy,\n\t.netnsok = true,\n\t.module = THIS_MODULE,\n\t.small_ops = hsr_ops,\n\t.n_small_ops = ARRAY_SIZE(hsr_ops),\n\t.resv_start_op = HSR_C_SET_NODE_LIST + 1,\n\t.mcgrps = hsr_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(hsr_mcgrps),\n};\n\nint __init hsr_netlink_init(void)\n{\n\tint rc;\n\n\trc = rtnl_link_register(&hsr_link_ops);\n\tif (rc)\n\t\tgoto fail_rtnl_link_register;\n\n\trc = genl_register_family(&hsr_genl_family);\n\tif (rc)\n\t\tgoto fail_genl_register_family;\n\n\thsr_debugfs_create_root();\n\treturn 0;\n\nfail_genl_register_family:\n\trtnl_link_unregister(&hsr_link_ops);\nfail_rtnl_link_register:\n\n\treturn rc;\n}\n\nvoid __exit hsr_netlink_exit(void)\n{\n\tgenl_unregister_family(&hsr_genl_family);\n\trtnl_link_unregister(&hsr_link_ops);\n}\n\nMODULE_ALIAS_RTNL_LINK(\"hsr\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}