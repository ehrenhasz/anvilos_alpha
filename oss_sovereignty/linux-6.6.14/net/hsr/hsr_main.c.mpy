{
  "module_name": "hsr_main.c",
  "hash_id": "9e3d41118409c499cae3aee6f075c5d0f769fe9cc6f8fc75c90d57225f2baaba",
  "original_prompt": "Ingested from linux-6.6.14/net/hsr/hsr_main.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <net/rtnetlink.h>\n#include <linux/rculist.h>\n#include <linux/timer.h>\n#include <linux/etherdevice.h>\n#include \"hsr_main.h\"\n#include \"hsr_device.h\"\n#include \"hsr_netlink.h\"\n#include \"hsr_framereg.h\"\n#include \"hsr_slave.h\"\n\nstatic bool hsr_slave_empty(struct hsr_priv *hsr)\n{\n\tstruct hsr_port *port;\n\n\thsr_for_each_port(hsr, port)\n\t\tif (port->type != HSR_PT_MASTER)\n\t\t\treturn false;\n\treturn true;\n}\n\nstatic int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct hsr_port *port, *master;\n\tstruct net_device *dev;\n\tstruct hsr_priv *hsr;\n\tLIST_HEAD(list_kill);\n\tint mtu_max;\n\tint res;\n\n\tdev = netdev_notifier_info_to_dev(ptr);\n\tport = hsr_port_get_rtnl(dev);\n\tif (!port) {\n\t\tif (!is_hsr_master(dev))\n\t\t\treturn NOTIFY_DONE;\t \n\t\thsr = netdev_priv(dev);\n\t\tport = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\t\tif (!port) {\n\t\t\t \n\t\t\treturn NOTIFY_DONE;\n\t\t}\n\t} else {\n\t\thsr = port->hsr;\n\t}\n\n\tswitch (event) {\n\tcase NETDEV_UP:\t\t \n\tcase NETDEV_DOWN:\t \n\tcase NETDEV_CHANGE:\t \n\t\thsr_check_carrier_and_operstate(hsr);\n\t\tbreak;\n\tcase NETDEV_CHANGENAME:\n\t\tif (is_hsr_master(dev))\n\t\t\thsr_debugfs_rename(dev);\n\t\tbreak;\n\tcase NETDEV_CHANGEADDR:\n\t\tif (port->type == HSR_PT_MASTER) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\n\t\tif (port->type == HSR_PT_SLAVE_A) {\n\t\t\teth_hw_addr_set(master->dev, dev->dev_addr);\n\t\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR,\n\t\t\t\t\t\t master->dev);\n\t\t}\n\n\t\t \n\t\tport = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\n\t\tres = hsr_create_self_node(hsr,\n\t\t\t\t\t   master->dev->dev_addr,\n\t\t\t\t\t   port ?\n\t\t\t\t\t\tport->dev->dev_addr :\n\t\t\t\t\t\tmaster->dev->dev_addr);\n\t\tif (res)\n\t\t\tnetdev_warn(master->dev,\n\t\t\t\t    \"Could not update HSR node address.\\n\");\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (port->type == HSR_PT_MASTER)\n\t\t\tbreak;  \n\t\tmtu_max = hsr_get_max_mtu(port->hsr);\n\t\tmaster = hsr_port_get_hsr(port->hsr, HSR_PT_MASTER);\n\t\tmaster->dev->mtu = mtu_max;\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tif (!is_hsr_master(dev)) {\n\t\t\tmaster = hsr_port_get_hsr(port->hsr, HSR_PT_MASTER);\n\t\t\thsr_del_port(port);\n\t\t\tif (hsr_slave_empty(master->hsr)) {\n\t\t\t\tconst struct rtnl_link_ops *ops;\n\n\t\t\t\tops = master->dev->rtnl_link_ops;\n\t\t\t\tops->dellink(master->dev, &list_kill);\n\t\t\t\tunregister_netdevice_many(&list_kill);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\t \n\t\treturn NOTIFY_BAD;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstruct hsr_port *hsr_port_get_hsr(struct hsr_priv *hsr, enum hsr_port_type pt)\n{\n\tstruct hsr_port *port;\n\n\thsr_for_each_port(hsr, port)\n\t\tif (port->type == pt)\n\t\t\treturn port;\n\treturn NULL;\n}\n\nint hsr_get_version(struct net_device *dev, enum hsr_version *ver)\n{\n\tstruct hsr_priv *hsr;\n\n\thsr = netdev_priv(dev);\n\t*ver = hsr->prot_version;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hsr_get_version);\n\nstatic struct notifier_block hsr_nb = {\n\t.notifier_call = hsr_netdev_notify,\t \n};\n\nstatic int __init hsr_init(void)\n{\n\tint res;\n\n\tBUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_HLEN);\n\n\tregister_netdevice_notifier(&hsr_nb);\n\tres = hsr_netlink_init();\n\n\treturn res;\n}\n\nstatic void __exit hsr_exit(void)\n{\n\thsr_netlink_exit();\n\thsr_debugfs_remove_root();\n\tunregister_netdevice_notifier(&hsr_nb);\n}\n\nmodule_init(hsr_init);\nmodule_exit(hsr_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}