{
  "module_name": "hsr_slave.c",
  "hash_id": "684cd69a5eb3f8f340932cb124a29fce00c5313b8dac687d2ae88adcfdb6cf95",
  "original_prompt": "Ingested from linux-6.6.14/net/hsr/hsr_slave.c",
  "human_readable_source": "\n \n\n#include \"hsr_slave.h\"\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_vlan.h>\n#include \"hsr_main.h\"\n#include \"hsr_device.h\"\n#include \"hsr_forward.h\"\n#include \"hsr_framereg.h\"\n\nbool hsr_invalid_dan_ingress_frame(__be16 protocol)\n{\n\treturn (protocol != htons(ETH_P_PRP) && protocol != htons(ETH_P_HSR));\n}\n\nstatic rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct hsr_port *port;\n\tstruct hsr_priv *hsr;\n\t__be16 protocol;\n\n\t \n\tif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\n\t\treturn RX_HANDLER_PASS;\n\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: skb invalid\", __func__);\n\t\treturn RX_HANDLER_PASS;\n\t}\n\n\tport = hsr_port_get_rcu(skb->dev);\n\tif (!port)\n\t\tgoto finish_pass;\n\thsr = port->hsr;\n\n\tif (hsr_addr_is_self(port->hsr, eth_hdr(skb)->h_source)) {\n\t\t \n\t\tkfree_skb(skb);\n\t\tgoto finish_consume;\n\t}\n\n\t \n\tprotocol = eth_hdr(skb)->h_proto;\n\n\tif (!(port->dev->features & NETIF_F_HW_HSR_TAG_RM) &&\n\t    hsr->proto_ops->invalid_dan_ingress_frame &&\n\t    hsr->proto_ops->invalid_dan_ingress_frame(protocol))\n\t\tgoto finish_pass;\n\n\tskb_push(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\tif ((!hsr->prot_version && protocol == htons(ETH_P_PRP)) ||\n\t    protocol == htons(ETH_P_HSR))\n\t\tskb_set_network_header(skb, ETH_HLEN + HSR_HLEN);\n\tskb_reset_mac_len(skb);\n\n\thsr_forward_skb(skb, port);\n\nfinish_consume:\n\treturn RX_HANDLER_CONSUMED;\n\nfinish_pass:\n\treturn RX_HANDLER_PASS;\n}\n\nbool hsr_port_exists(const struct net_device *dev)\n{\n\treturn rcu_access_pointer(dev->rx_handler) == hsr_handle_frame;\n}\n\nstatic int hsr_check_dev_ok(struct net_device *dev,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\t \n\tif ((dev->flags & IFF_LOOPBACK) || dev->type != ARPHRD_ETHER ||\n\t    dev->addr_len != ETH_ALEN) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot use loopback or non-ethernet device as HSR slave.\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (is_hsr_master(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Cannot create trees of HSR devices.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hsr_port_exists(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"This device is already a HSR slave.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_vlan_dev(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"HSR on top of VLAN is not yet supported in this driver.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->priv_flags & IFF_DONT_BRIDGE) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"This device does not support bridging.\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\n\treturn 0;\n}\n\n \nstatic int hsr_portdev_setup(struct hsr_priv *hsr, struct net_device *dev,\n\t\t\t     struct hsr_port *port,\n\t\t\t     struct netlink_ext_ack *extack)\n\n{\n\tstruct net_device *hsr_dev;\n\tstruct hsr_port *master;\n\tint res;\n\n\t \n\tif (!port->hsr->fwd_offloaded) {\n\t\tres = dev_set_promiscuity(dev, 1);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\thsr_dev = master->dev;\n\n\tres = netdev_upper_dev_link(dev, hsr_dev, extack);\n\tif (res)\n\t\tgoto fail_upper_dev_link;\n\n\tres = netdev_rx_handler_register(dev, hsr_handle_frame, port);\n\tif (res)\n\t\tgoto fail_rx_handler;\n\tdev_disable_lro(dev);\n\n\treturn 0;\n\nfail_rx_handler:\n\tnetdev_upper_dev_unlink(dev, hsr_dev);\nfail_upper_dev_link:\n\tif (!port->hsr->fwd_offloaded)\n\t\tdev_set_promiscuity(dev, -1);\n\n\treturn res;\n}\n\nint hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,\n\t\t enum hsr_port_type type, struct netlink_ext_ack *extack)\n{\n\tstruct hsr_port *port, *master;\n\tint res;\n\n\tif (type != HSR_PT_MASTER) {\n\t\tres = hsr_check_dev_ok(dev, extack);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tport = hsr_port_get_hsr(hsr, type);\n\tif (port)\n\t\treturn -EBUSY;\t \n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->hsr = hsr;\n\tport->dev = dev;\n\tport->type = type;\n\n\tif (type != HSR_PT_MASTER) {\n\t\tres = hsr_portdev_setup(hsr, dev, port, extack);\n\t\tif (res)\n\t\t\tgoto fail_dev_setup;\n\t}\n\n\tlist_add_tail_rcu(&port->port_list, &hsr->ports);\n\tsynchronize_rcu();\n\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\tnetdev_update_features(master->dev);\n\tdev_set_mtu(master->dev, hsr_get_max_mtu(hsr));\n\n\treturn 0;\n\nfail_dev_setup:\n\tkfree(port);\n\treturn res;\n}\n\nvoid hsr_del_port(struct hsr_port *port)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *master;\n\n\thsr = port->hsr;\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\tlist_del_rcu(&port->port_list);\n\n\tif (port != master) {\n\t\tnetdev_update_features(master->dev);\n\t\tdev_set_mtu(master->dev, hsr_get_max_mtu(hsr));\n\t\tnetdev_rx_handler_unregister(port->dev);\n\t\tdev_set_promiscuity(port->dev, -1);\n\t\tnetdev_upper_dev_unlink(port->dev, master->dev);\n\t}\n\n\tsynchronize_rcu();\n\n\tkfree(port);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}