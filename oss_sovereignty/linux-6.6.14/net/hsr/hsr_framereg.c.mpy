{
  "module_name": "hsr_framereg.c",
  "hash_id": "702784cb39e085d85fa950ca8299b8cbc864d677ef3e0656566474bcfb34c737",
  "original_prompt": "Ingested from linux-6.6.14/net/hsr/hsr_framereg.c",
  "human_readable_source": "\n \n\n#include <linux/if_ether.h>\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include \"hsr_main.h\"\n#include \"hsr_framereg.h\"\n#include \"hsr_netlink.h\"\n\n \nstatic bool seq_nr_after(u16 a, u16 b)\n{\n\t \n\tif ((int)b - a == 32768)\n\t\treturn false;\n\n\treturn (((s16)(b - a)) < 0);\n}\n\n#define seq_nr_before(a, b)\t\tseq_nr_after((b), (a))\n#define seq_nr_before_or_eq(a, b)\t(!seq_nr_after((a), (b)))\n\nbool hsr_addr_is_self(struct hsr_priv *hsr, unsigned char *addr)\n{\n\tstruct hsr_self_node *sn;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tsn = rcu_dereference(hsr->self_node);\n\tif (!sn) {\n\t\tWARN_ONCE(1, \"HSR: No self node\\n\");\n\t\tgoto out;\n\t}\n\n\tif (ether_addr_equal(addr, sn->macaddress_A) ||\n\t    ether_addr_equal(addr, sn->macaddress_B))\n\t\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic struct hsr_node *find_node_by_addr_A(struct list_head *node_db,\n\t\t\t\t\t    const unsigned char addr[ETH_ALEN])\n{\n\tstruct hsr_node *node;\n\n\tlist_for_each_entry_rcu(node, node_db, mac_list) {\n\t\tif (ether_addr_equal(node->macaddress_A, addr))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\n \nint hsr_create_self_node(struct hsr_priv *hsr,\n\t\t\t const unsigned char addr_a[ETH_ALEN],\n\t\t\t const unsigned char addr_b[ETH_ALEN])\n{\n\tstruct hsr_self_node *sn, *old;\n\n\tsn = kmalloc(sizeof(*sn), GFP_KERNEL);\n\tif (!sn)\n\t\treturn -ENOMEM;\n\n\tether_addr_copy(sn->macaddress_A, addr_a);\n\tether_addr_copy(sn->macaddress_B, addr_b);\n\n\tspin_lock_bh(&hsr->list_lock);\n\told = rcu_replace_pointer(hsr->self_node, sn,\n\t\t\t\t  lockdep_is_held(&hsr->list_lock));\n\tspin_unlock_bh(&hsr->list_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n\treturn 0;\n}\n\nvoid hsr_del_self_node(struct hsr_priv *hsr)\n{\n\tstruct hsr_self_node *old;\n\n\tspin_lock_bh(&hsr->list_lock);\n\told = rcu_replace_pointer(hsr->self_node, NULL,\n\t\t\t\t  lockdep_is_held(&hsr->list_lock));\n\tspin_unlock_bh(&hsr->list_lock);\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n}\n\nvoid hsr_del_nodes(struct list_head *node_db)\n{\n\tstruct hsr_node *node;\n\tstruct hsr_node *tmp;\n\n\tlist_for_each_entry_safe(node, tmp, node_db, mac_list)\n\t\tkfree(node);\n}\n\nvoid prp_handle_san_frame(bool san, enum hsr_port_type port,\n\t\t\t  struct hsr_node *node)\n{\n\t \n\tif (port == HSR_PT_SLAVE_A) {\n\t\tnode->san_a = true;\n\t\treturn;\n\t}\n\n\tif (port == HSR_PT_SLAVE_B)\n\t\tnode->san_b = true;\n}\n\n \nstatic struct hsr_node *hsr_add_node(struct hsr_priv *hsr,\n\t\t\t\t     struct list_head *node_db,\n\t\t\t\t     unsigned char addr[],\n\t\t\t\t     u16 seq_out, bool san,\n\t\t\t\t     enum hsr_port_type rx_port)\n{\n\tstruct hsr_node *new_node, *node;\n\tunsigned long now;\n\tint i;\n\n\tnew_node = kzalloc(sizeof(*new_node), GFP_ATOMIC);\n\tif (!new_node)\n\t\treturn NULL;\n\n\tether_addr_copy(new_node->macaddress_A, addr);\n\tspin_lock_init(&new_node->seq_out_lock);\n\n\t \n\tnow = jiffies;\n\tfor (i = 0; i < HSR_PT_PORTS; i++) {\n\t\tnew_node->time_in[i] = now;\n\t\tnew_node->time_out[i] = now;\n\t}\n\tfor (i = 0; i < HSR_PT_PORTS; i++)\n\t\tnew_node->seq_out[i] = seq_out;\n\n\tif (san && hsr->proto_ops->handle_san_frame)\n\t\thsr->proto_ops->handle_san_frame(san, rx_port, new_node);\n\n\tspin_lock_bh(&hsr->list_lock);\n\tlist_for_each_entry_rcu(node, node_db, mac_list,\n\t\t\t\tlockdep_is_held(&hsr->list_lock)) {\n\t\tif (ether_addr_equal(node->macaddress_A, addr))\n\t\t\tgoto out;\n\t\tif (ether_addr_equal(node->macaddress_B, addr))\n\t\t\tgoto out;\n\t}\n\tlist_add_tail_rcu(&new_node->mac_list, node_db);\n\tspin_unlock_bh(&hsr->list_lock);\n\treturn new_node;\nout:\n\tspin_unlock_bh(&hsr->list_lock);\n\tkfree(new_node);\n\treturn node;\n}\n\nvoid prp_update_san_info(struct hsr_node *node, bool is_sup)\n{\n\tif (!is_sup)\n\t\treturn;\n\n\tnode->san_a = false;\n\tnode->san_b = false;\n}\n\n \nstruct hsr_node *hsr_get_node(struct hsr_port *port, struct list_head *node_db,\n\t\t\t      struct sk_buff *skb, bool is_sup,\n\t\t\t      enum hsr_port_type rx_port)\n{\n\tstruct hsr_priv *hsr = port->hsr;\n\tstruct hsr_node *node;\n\tstruct ethhdr *ethhdr;\n\tstruct prp_rct *rct;\n\tbool san = false;\n\tu16 seq_out;\n\n\tif (!skb_mac_header_was_set(skb))\n\t\treturn NULL;\n\n\tethhdr = (struct ethhdr *)skb_mac_header(skb);\n\n\tlist_for_each_entry_rcu(node, node_db, mac_list) {\n\t\tif (ether_addr_equal(node->macaddress_A, ethhdr->h_source)) {\n\t\t\tif (hsr->proto_ops->update_san_info)\n\t\t\t\thsr->proto_ops->update_san_info(node, is_sup);\n\t\t\treturn node;\n\t\t}\n\t\tif (ether_addr_equal(node->macaddress_B, ethhdr->h_source)) {\n\t\t\tif (hsr->proto_ops->update_san_info)\n\t\t\t\thsr->proto_ops->update_san_info(node, is_sup);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t \n\tif (ethhdr->h_proto == htons(ETH_P_PRP) ||\n\t    ethhdr->h_proto == htons(ETH_P_HSR)) {\n\t\t \n\t\tseq_out = hsr_get_skb_sequence_nr(skb) - 1;\n\t} else {\n\t\trct = skb_get_PRP_rct(skb);\n\t\tif (rct && prp_check_lsdu_size(skb, rct, is_sup)) {\n\t\t\tseq_out = prp_get_skb_sequence_nr(rct);\n\t\t} else {\n\t\t\tif (rx_port != HSR_PT_MASTER)\n\t\t\t\tsan = true;\n\t\t\tseq_out = HSR_SEQNR_START;\n\t\t}\n\t}\n\n\treturn hsr_add_node(hsr, node_db, ethhdr->h_source, seq_out,\n\t\t\t    san, rx_port);\n}\n\n \nvoid hsr_handle_sup_frame(struct hsr_frame_info *frame)\n{\n\tstruct hsr_node *node_curr = frame->node_src;\n\tstruct hsr_port *port_rcv = frame->port_rcv;\n\tstruct hsr_priv *hsr = port_rcv->hsr;\n\tstruct hsr_sup_payload *hsr_sp;\n\tstruct hsr_sup_tlv *hsr_sup_tlv;\n\tstruct hsr_node *node_real;\n\tstruct sk_buff *skb = NULL;\n\tstruct list_head *node_db;\n\tstruct ethhdr *ethhdr;\n\tint i;\n\tunsigned int pull_size = 0;\n\tunsigned int total_pull_size = 0;\n\n\t \n\tif (frame->skb_hsr)\n\t\tskb = frame->skb_hsr;\n\telse if (frame->skb_prp)\n\t\tskb = frame->skb_prp;\n\telse if (frame->skb_std)\n\t\tskb = frame->skb_std;\n\tif (!skb)\n\t\treturn;\n\n\t \n\tpull_size = sizeof(struct ethhdr);\n\tskb_pull(skb, pull_size);\n\ttotal_pull_size += pull_size;\n\n\tethhdr = (struct ethhdr *)skb_mac_header(skb);\n\n\t \n\tif (ethhdr->h_proto == htons(ETH_P_HSR)) {\n\t\tpull_size = sizeof(struct hsr_tag);\n\t\tskb_pull(skb, pull_size);\n\t\ttotal_pull_size += pull_size;\n\t}\n\n\t \n\tpull_size = sizeof(struct hsr_sup_tag);\n\tskb_pull(skb, pull_size);\n\ttotal_pull_size += pull_size;\n\n\t \n\thsr_sp = (struct hsr_sup_payload *)skb->data;\n\n\t \n\tnode_db = &port_rcv->hsr->node_db;\n\tnode_real = find_node_by_addr_A(node_db, hsr_sp->macaddress_A);\n\tif (!node_real)\n\t\t \n\t\tnode_real = hsr_add_node(hsr, node_db, hsr_sp->macaddress_A,\n\t\t\t\t\t HSR_SEQNR_START - 1, true,\n\t\t\t\t\t port_rcv->type);\n\tif (!node_real)\n\t\tgoto done;  \n\tif (node_real == node_curr)\n\t\t \n\t\tgoto done;\n\n\t \n\tpull_size = sizeof(struct hsr_sup_payload);\n\tskb_pull(skb, pull_size);\n\ttotal_pull_size += pull_size;\n\n\t \n\thsr_sup_tlv = (struct hsr_sup_tlv *)skb->data;\n\t \n\tif (hsr_sup_tlv->HSR_TLV_type == PRP_TLV_REDBOX_MAC) {\n\t\t \n\t\t \n\t\tif (hsr_sup_tlv->HSR_TLV_length != 6)\n\t\t\tgoto done;\n\n\t\t \n\t\tpull_size = sizeof(struct hsr_sup_tlv);\n\t\tskb_pull(skb, pull_size);\n\t\ttotal_pull_size += pull_size;\n\n\t\t \n\t\thsr_sp = (struct hsr_sup_payload *)skb->data;\n\n\t\t \n\t\tif (!ether_addr_equal(node_real->macaddress_A, hsr_sp->macaddress_A)) {\n\t\t\t \n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tether_addr_copy(node_real->macaddress_B, ethhdr->h_source);\n\tspin_lock_bh(&node_real->seq_out_lock);\n\tfor (i = 0; i < HSR_PT_PORTS; i++) {\n\t\tif (!node_curr->time_in_stale[i] &&\n\t\t    time_after(node_curr->time_in[i], node_real->time_in[i])) {\n\t\t\tnode_real->time_in[i] = node_curr->time_in[i];\n\t\t\tnode_real->time_in_stale[i] =\n\t\t\t\t\t\tnode_curr->time_in_stale[i];\n\t\t}\n\t\tif (seq_nr_after(node_curr->seq_out[i], node_real->seq_out[i]))\n\t\t\tnode_real->seq_out[i] = node_curr->seq_out[i];\n\t}\n\tspin_unlock_bh(&node_real->seq_out_lock);\n\tnode_real->addr_B_port = port_rcv->type;\n\n\tspin_lock_bh(&hsr->list_lock);\n\tif (!node_curr->removed) {\n\t\tlist_del_rcu(&node_curr->mac_list);\n\t\tnode_curr->removed = true;\n\t\tkfree_rcu(node_curr, rcu_head);\n\t}\n\tspin_unlock_bh(&hsr->list_lock);\n\ndone:\n\t \n\tskb_push(skb, total_pull_size);\n}\n\n \nvoid hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb)\n{\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmemcpy(&eth_hdr(skb)->h_source, node->macaddress_A, ETH_ALEN);\n}\n\n \nvoid hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\n\t\t\t struct hsr_port *port)\n{\n\tstruct hsr_node *node_dst;\n\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn;\n\n\tnode_dst = find_node_by_addr_A(&port->hsr->node_db,\n\t\t\t\t       eth_hdr(skb)->h_dest);\n\tif (!node_dst) {\n\t\tif (port->hsr->prot_version != PRP_V1 && net_ratelimit())\n\t\t\tnetdev_err(skb->dev, \"%s: Unknown node\\n\", __func__);\n\t\treturn;\n\t}\n\tif (port->type != node_dst->addr_B_port)\n\t\treturn;\n\n\tif (is_valid_ether_addr(node_dst->macaddress_B))\n\t\tether_addr_copy(eth_hdr(skb)->h_dest, node_dst->macaddress_B);\n}\n\nvoid hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,\n\t\t\t   u16 sequence_nr)\n{\n\t \n\tif (!(port->dev->features & NETIF_F_HW_HSR_TAG_RM) &&\n\t    seq_nr_before(sequence_nr, node->seq_out[port->type]))\n\t\treturn;\n\n\tnode->time_in[port->type] = jiffies;\n\tnode->time_in_stale[port->type] = false;\n}\n\n \nint hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,\n\t\t\t   u16 sequence_nr)\n{\n\tspin_lock_bh(&node->seq_out_lock);\n\tif (seq_nr_before_or_eq(sequence_nr, node->seq_out[port->type]) &&\n\t    time_is_after_jiffies(node->time_out[port->type] +\n\t    msecs_to_jiffies(HSR_ENTRY_FORGET_TIME))) {\n\t\tspin_unlock_bh(&node->seq_out_lock);\n\t\treturn 1;\n\t}\n\n\tnode->time_out[port->type] = jiffies;\n\tnode->seq_out[port->type] = sequence_nr;\n\tspin_unlock_bh(&node->seq_out_lock);\n\treturn 0;\n}\n\nstatic struct hsr_port *get_late_port(struct hsr_priv *hsr,\n\t\t\t\t      struct hsr_node *node)\n{\n\tif (node->time_in_stale[HSR_PT_SLAVE_A])\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\n\tif (node->time_in_stale[HSR_PT_SLAVE_B])\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\n\n\tif (time_after(node->time_in[HSR_PT_SLAVE_B],\n\t\t       node->time_in[HSR_PT_SLAVE_A] +\n\t\t\t\t\tmsecs_to_jiffies(MAX_SLAVE_DIFF)))\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\n\tif (time_after(node->time_in[HSR_PT_SLAVE_A],\n\t\t       node->time_in[HSR_PT_SLAVE_B] +\n\t\t\t\t\tmsecs_to_jiffies(MAX_SLAVE_DIFF)))\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\n\n\treturn NULL;\n}\n\n \nvoid hsr_prune_nodes(struct timer_list *t)\n{\n\tstruct hsr_priv *hsr = from_timer(hsr, t, prune_timer);\n\tstruct hsr_node *node;\n\tstruct hsr_node *tmp;\n\tstruct hsr_port *port;\n\tunsigned long timestamp;\n\tunsigned long time_a, time_b;\n\n\tspin_lock_bh(&hsr->list_lock);\n\tlist_for_each_entry_safe(node, tmp, &hsr->node_db, mac_list) {\n\t\t \n\t\tif (hsr_addr_is_self(hsr, node->macaddress_A))\n\t\t\tcontinue;\n\n\t\t \n\t\ttime_a = node->time_in[HSR_PT_SLAVE_A];\n\t\ttime_b = node->time_in[HSR_PT_SLAVE_B];\n\n\t\t \n\t\tif (time_after(jiffies, time_a + MAX_JIFFY_OFFSET / 2))\n\t\t\tnode->time_in_stale[HSR_PT_SLAVE_A] = true;\n\t\tif (time_after(jiffies, time_b + MAX_JIFFY_OFFSET / 2))\n\t\t\tnode->time_in_stale[HSR_PT_SLAVE_B] = true;\n\n\t\t \n\t\ttimestamp = time_a;\n\t\tif (node->time_in_stale[HSR_PT_SLAVE_A] ||\n\t\t    (!node->time_in_stale[HSR_PT_SLAVE_B] &&\n\t\t    time_after(time_b, time_a)))\n\t\t\ttimestamp = time_b;\n\n\t\t \n\t\tif (time_is_after_jiffies(timestamp +\n\t\t\t\tmsecs_to_jiffies(1.5 * MAX_SLAVE_DIFF))) {\n\t\t\trcu_read_lock();\n\t\t\tport = get_late_port(hsr, node);\n\t\t\tif (port)\n\t\t\t\thsr_nl_ringerror(hsr, node->macaddress_A, port);\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\t \n\t\tif (time_is_before_jiffies(timestamp +\n\t\t\t\tmsecs_to_jiffies(HSR_NODE_FORGET_TIME))) {\n\t\t\thsr_nl_nodedown(hsr, node->macaddress_A);\n\t\t\tif (!node->removed) {\n\t\t\t\tlist_del_rcu(&node->mac_list);\n\t\t\t\tnode->removed = true;\n\t\t\t\t \n\t\t\t\tkfree_rcu(node, rcu_head);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&hsr->list_lock);\n\n\t \n\tmod_timer(&hsr->prune_timer,\n\t\t  jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n}\n\nvoid *hsr_get_next_node(struct hsr_priv *hsr, void *_pos,\n\t\t\tunsigned char addr[ETH_ALEN])\n{\n\tstruct hsr_node *node;\n\n\tif (!_pos) {\n\t\tnode = list_first_or_null_rcu(&hsr->node_db,\n\t\t\t\t\t      struct hsr_node, mac_list);\n\t\tif (node)\n\t\t\tether_addr_copy(addr, node->macaddress_A);\n\t\treturn node;\n\t}\n\n\tnode = _pos;\n\tlist_for_each_entry_continue_rcu(node, &hsr->node_db, mac_list) {\n\t\tether_addr_copy(addr, node->macaddress_A);\n\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\nint hsr_get_node_data(struct hsr_priv *hsr,\n\t\t      const unsigned char *addr,\n\t\t      unsigned char addr_b[ETH_ALEN],\n\t\t      unsigned int *addr_b_ifindex,\n\t\t      int *if1_age,\n\t\t      u16 *if1_seq,\n\t\t      int *if2_age,\n\t\t      u16 *if2_seq)\n{\n\tstruct hsr_node *node;\n\tstruct hsr_port *port;\n\tunsigned long tdiff;\n\n\tnode = find_node_by_addr_A(&hsr->node_db, addr);\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tether_addr_copy(addr_b, node->macaddress_B);\n\n\ttdiff = jiffies - node->time_in[HSR_PT_SLAVE_A];\n\tif (node->time_in_stale[HSR_PT_SLAVE_A])\n\t\t*if1_age = INT_MAX;\n#if HZ <= MSEC_PER_SEC\n\telse if (tdiff > msecs_to_jiffies(INT_MAX))\n\t\t*if1_age = INT_MAX;\n#endif\n\telse\n\t\t*if1_age = jiffies_to_msecs(tdiff);\n\n\ttdiff = jiffies - node->time_in[HSR_PT_SLAVE_B];\n\tif (node->time_in_stale[HSR_PT_SLAVE_B])\n\t\t*if2_age = INT_MAX;\n#if HZ <= MSEC_PER_SEC\n\telse if (tdiff > msecs_to_jiffies(INT_MAX))\n\t\t*if2_age = INT_MAX;\n#endif\n\telse\n\t\t*if2_age = jiffies_to_msecs(tdiff);\n\n\t \n\t*if1_seq = node->seq_out[HSR_PT_SLAVE_B];\n\t*if2_seq = node->seq_out[HSR_PT_SLAVE_A];\n\n\tif (node->addr_B_port != HSR_PT_NONE) {\n\t\tport = hsr_port_get_hsr(hsr, node->addr_B_port);\n\t\t*addr_b_ifindex = port->dev->ifindex;\n\t} else {\n\t\t*addr_b_ifindex = -1;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}