{
  "module_name": "caif_usb.c",
  "hash_id": "ccc64aca6e35113c95ee88623e714538b265254b919cbc540e9bff1a72b75f61",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/caif_usb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/usbnet.h>\n#include <linux/etherdevice.h>\n#include <net/netns/generic.h>\n#include <net/caif/caif_dev.h>\n#include <net/caif/caif_layer.h>\n#include <net/caif/cfpkt.h>\n#include <net/caif/cfcnfg.h>\n\nMODULE_LICENSE(\"GPL\");\n\n#define CFUSB_PAD_DESCR_SZ 1\t \n#define CFUSB_ALIGNMENT 4\t \n#define CFUSB_MAX_HEADLEN (CFUSB_PAD_DESCR_SZ + CFUSB_ALIGNMENT-1)\n#define STE_USB_VID 0x04cc\t \n#define STE_USB_PID_CAIF 0x230f\t \n\nstruct cfusbl {\n\tstruct cflayer layer;\n\tu8 tx_eth_hdr[ETH_HLEN];\n};\n\nstatic bool pack_added;\n\nstatic int cfusbl_receive(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tu8 hpad;\n\n\t \n\tcfpkt_extr_head(pkt, &hpad, 1);\n\tcfpkt_extr_head(pkt, NULL, hpad);\n\treturn layr->up->receive(layr->up, pkt);\n}\n\nstatic int cfusbl_transmit(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tstruct caif_payload_info *info;\n\tu8 hpad;\n\tu8 zeros[CFUSB_ALIGNMENT];\n\tstruct sk_buff *skb;\n\tstruct cfusbl *usbl = container_of(layr, struct cfusbl, layer);\n\n\tskb = cfpkt_tonative(pkt);\n\n\tskb_reset_network_header(skb);\n\tskb->protocol = htons(ETH_P_IP);\n\n\tinfo = cfpkt_info(pkt);\n\thpad = (info->hdr_len + CFUSB_PAD_DESCR_SZ) & (CFUSB_ALIGNMENT - 1);\n\n\tif (skb_headroom(skb) < ETH_HLEN + CFUSB_PAD_DESCR_SZ + hpad) {\n\t\tpr_warn(\"Headroom too small\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\tmemset(zeros, 0, hpad);\n\n\tcfpkt_add_head(pkt, zeros, hpad);\n\tcfpkt_add_head(pkt, &hpad, 1);\n\tcfpkt_add_head(pkt, usbl->tx_eth_hdr, sizeof(usbl->tx_eth_hdr));\n\treturn layr->dn->transmit(layr->dn, pkt);\n}\n\nstatic void cfusbl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\n\t\t\t   int phyid)\n{\n\tif (layr->up && layr->up->ctrlcmd)\n\t\tlayr->up->ctrlcmd(layr->up, ctrl, layr->id);\n}\n\nstatic struct cflayer *cfusbl_create(int phyid, const u8 ethaddr[ETH_ALEN],\n\t\t\t\t      u8 braddr[ETH_ALEN])\n{\n\tstruct cfusbl *this = kmalloc(sizeof(struct cfusbl), GFP_ATOMIC);\n\n\tif (!this)\n\t\treturn NULL;\n\n\tcaif_assert(offsetof(struct cfusbl, layer) == 0);\n\n\tmemset(&this->layer, 0, sizeof(this->layer));\n\tthis->layer.receive = cfusbl_receive;\n\tthis->layer.transmit = cfusbl_transmit;\n\tthis->layer.ctrlcmd = cfusbl_ctrlcmd;\n\tsnprintf(this->layer.name, CAIF_LAYER_NAME_SZ, \"usb%d\", phyid);\n\tthis->layer.id = phyid;\n\n\t \n\tether_addr_copy(&this->tx_eth_hdr[ETH_ALEN], braddr);\n\tether_addr_copy(&this->tx_eth_hdr[ETH_ALEN], ethaddr);\n\tthis->tx_eth_hdr[12] = cpu_to_be16(ETH_P_802_EX1) & 0xff;\n\tthis->tx_eth_hdr[13] = (cpu_to_be16(ETH_P_802_EX1) >> 8) & 0xff;\n\tpr_debug(\"caif ethernet TX-header dst:%pM src:%pM type:%02x%02x\\n\",\n\t\t\tthis->tx_eth_hdr, this->tx_eth_hdr + ETH_ALEN,\n\t\t\tthis->tx_eth_hdr[12], this->tx_eth_hdr[13]);\n\n\treturn (struct cflayer *) this;\n}\n\nstatic void cfusbl_release(struct cflayer *layer)\n{\n\tkfree(layer);\n}\n\nstatic struct packet_type caif_usb_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_802_EX1),\n};\n\nstatic int cfusbl_device_notify(struct notifier_block *me, unsigned long what,\n\t\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct caif_dev_common common;\n\tstruct cflayer *layer, *link_support;\n\tstruct usbnet *usbnet;\n\tstruct usb_device *usbdev;\n\tint res;\n\n\tif (what == NETDEV_UNREGISTER && dev->reg_state >= NETREG_UNREGISTERED)\n\t\treturn 0;\n\n\t \n\tif (!(dev->dev.parent && dev->dev.parent->driver &&\n\t      strcmp(dev->dev.parent->driver->name, \"cdc_ncm\") == 0))\n\t\treturn 0;\n\n\tusbnet = netdev_priv(dev);\n\tusbdev = usbnet->udev;\n\n\tpr_debug(\"USB CDC NCM device VID:0x%4x PID:0x%4x\\n\",\n\t\tle16_to_cpu(usbdev->descriptor.idVendor),\n\t\tle16_to_cpu(usbdev->descriptor.idProduct));\n\n\t \n\tif (!(le16_to_cpu(usbdev->descriptor.idVendor) == STE_USB_VID &&\n\t\tle16_to_cpu(usbdev->descriptor.idProduct) == STE_USB_PID_CAIF))\n\t\treturn 0;\n\n\tif (what == NETDEV_UNREGISTER)\n\t\tmodule_put(THIS_MODULE);\n\n\tif (what != NETDEV_REGISTER)\n\t\treturn 0;\n\n\t__module_get(THIS_MODULE);\n\n\tmemset(&common, 0, sizeof(common));\n\tcommon.use_frag = false;\n\tcommon.use_fcs = false;\n\tcommon.use_stx = false;\n\tcommon.link_select = CAIF_LINK_HIGH_BANDW;\n\tcommon.flowctrl = NULL;\n\n\tlink_support = cfusbl_create(dev->ifindex, dev->dev_addr,\n\t\t\t\t\tdev->broadcast);\n\n\tif (!link_support)\n\t\treturn -ENOMEM;\n\n\tif (dev->num_tx_queues > 1)\n\t\tpr_warn(\"USB device uses more than one tx queue\\n\");\n\n\tres = caif_enroll_dev(dev, &common, link_support, CFUSB_MAX_HEADLEN,\n\t\t\t&layer, &caif_usb_type.func);\n\tif (res)\n\t\tgoto err;\n\n\tif (!pack_added)\n\t\tdev_add_pack(&caif_usb_type);\n\tpack_added = true;\n\n\tstrscpy(layer->name, dev->name, sizeof(layer->name));\n\n\treturn 0;\nerr:\n\tcfusbl_release(link_support);\n\treturn res;\n}\n\nstatic struct notifier_block caif_device_notifier = {\n\t.notifier_call = cfusbl_device_notify,\n\t.priority = 0,\n};\n\nstatic int __init cfusbl_init(void)\n{\n\treturn register_netdevice_notifier(&caif_device_notifier);\n}\n\nstatic void __exit cfusbl_exit(void)\n{\n\tunregister_netdevice_notifier(&caif_device_notifier);\n\tdev_remove_pack(&caif_usb_type);\n}\n\nmodule_init(cfusbl_init);\nmodule_exit(cfusbl_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}