{
  "module_name": "cfmuxl.c",
  "hash_id": "22a0001cd24606ef14d9dc83f5f68b7e7042469ca68e060cfad62a4852a48ec6",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/cfmuxl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/stddef.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <net/caif/cfpkt.h>\n#include <net/caif/cfmuxl.h>\n#include <net/caif/cfsrvl.h>\n#include <net/caif/cffrml.h>\n\n#define container_obj(layr) container_of(layr, struct cfmuxl, layer)\n\n#define CAIF_CTRL_CHANNEL 0\n#define UP_CACHE_SIZE 8\n#define DN_CACHE_SIZE 8\n\nstruct cfmuxl {\n\tstruct cflayer layer;\n\tstruct list_head srvl_list;\n\tstruct list_head frml_list;\n\tstruct cflayer *up_cache[UP_CACHE_SIZE];\n\tstruct cflayer *dn_cache[DN_CACHE_SIZE];\n\t \n\tspinlock_t transmit_lock;\n\n\t \n\tspinlock_t receive_lock;\n\n};\n\nstatic int cfmuxl_receive(struct cflayer *layr, struct cfpkt *pkt);\nstatic int cfmuxl_transmit(struct cflayer *layr, struct cfpkt *pkt);\nstatic void cfmuxl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\n\t\t\t   int phyid);\nstatic struct cflayer *get_up(struct cfmuxl *muxl, u16 id);\n\nstruct cflayer *cfmuxl_create(void)\n{\n\tstruct cfmuxl *this = kzalloc(sizeof(struct cfmuxl), GFP_ATOMIC);\n\n\tif (!this)\n\t\treturn NULL;\n\tthis->layer.receive = cfmuxl_receive;\n\tthis->layer.transmit = cfmuxl_transmit;\n\tthis->layer.ctrlcmd = cfmuxl_ctrlcmd;\n\tINIT_LIST_HEAD(&this->srvl_list);\n\tINIT_LIST_HEAD(&this->frml_list);\n\tspin_lock_init(&this->transmit_lock);\n\tspin_lock_init(&this->receive_lock);\n\tsnprintf(this->layer.name, CAIF_LAYER_NAME_SZ, \"mux\");\n\treturn &this->layer;\n}\n\nint cfmuxl_set_dnlayer(struct cflayer *layr, struct cflayer *dn, u8 phyid)\n{\n\tstruct cfmuxl *muxl = (struct cfmuxl *) layr;\n\n\tspin_lock_bh(&muxl->transmit_lock);\n\tlist_add_rcu(&dn->node, &muxl->frml_list);\n\tspin_unlock_bh(&muxl->transmit_lock);\n\treturn 0;\n}\n\nstatic struct cflayer *get_from_id(struct list_head *list, u16 id)\n{\n\tstruct cflayer *lyr;\n\tlist_for_each_entry_rcu(lyr, list, node) {\n\t\tif (lyr->id == id)\n\t\t\treturn lyr;\n\t}\n\n\treturn NULL;\n}\n\nint cfmuxl_set_uplayer(struct cflayer *layr, struct cflayer *up, u8 linkid)\n{\n\tstruct cfmuxl *muxl = container_obj(layr);\n\tstruct cflayer *old;\n\n\tspin_lock_bh(&muxl->receive_lock);\n\n\t \n\told = get_from_id(&muxl->srvl_list, linkid);\n\tif (old != NULL)\n\t\tlist_del_rcu(&old->node);\n\n\tlist_add_rcu(&up->node, &muxl->srvl_list);\n\tspin_unlock_bh(&muxl->receive_lock);\n\n\treturn 0;\n}\n\nstruct cflayer *cfmuxl_remove_dnlayer(struct cflayer *layr, u8 phyid)\n{\n\tstruct cfmuxl *muxl = container_obj(layr);\n\tstruct cflayer *dn;\n\tint idx = phyid % DN_CACHE_SIZE;\n\n\tspin_lock_bh(&muxl->transmit_lock);\n\tRCU_INIT_POINTER(muxl->dn_cache[idx], NULL);\n\tdn = get_from_id(&muxl->frml_list, phyid);\n\tif (dn == NULL)\n\t\tgoto out;\n\n\tlist_del_rcu(&dn->node);\n\tcaif_assert(dn != NULL);\nout:\n\tspin_unlock_bh(&muxl->transmit_lock);\n\treturn dn;\n}\n\nstatic struct cflayer *get_up(struct cfmuxl *muxl, u16 id)\n{\n\tstruct cflayer *up;\n\tint idx = id % UP_CACHE_SIZE;\n\tup = rcu_dereference(muxl->up_cache[idx]);\n\tif (up == NULL || up->id != id) {\n\t\tspin_lock_bh(&muxl->receive_lock);\n\t\tup = get_from_id(&muxl->srvl_list, id);\n\t\trcu_assign_pointer(muxl->up_cache[idx], up);\n\t\tspin_unlock_bh(&muxl->receive_lock);\n\t}\n\treturn up;\n}\n\nstatic struct cflayer *get_dn(struct cfmuxl *muxl, struct dev_info *dev_info)\n{\n\tstruct cflayer *dn;\n\tint idx = dev_info->id % DN_CACHE_SIZE;\n\tdn = rcu_dereference(muxl->dn_cache[idx]);\n\tif (dn == NULL || dn->id != dev_info->id) {\n\t\tspin_lock_bh(&muxl->transmit_lock);\n\t\tdn = get_from_id(&muxl->frml_list, dev_info->id);\n\t\trcu_assign_pointer(muxl->dn_cache[idx], dn);\n\t\tspin_unlock_bh(&muxl->transmit_lock);\n\t}\n\treturn dn;\n}\n\nstruct cflayer *cfmuxl_remove_uplayer(struct cflayer *layr, u8 id)\n{\n\tstruct cflayer *up;\n\tstruct cfmuxl *muxl = container_obj(layr);\n\tint idx = id % UP_CACHE_SIZE;\n\n\tif (id == 0) {\n\t\tpr_warn(\"Trying to remove control layer\\n\");\n\t\treturn NULL;\n\t}\n\n\tspin_lock_bh(&muxl->receive_lock);\n\tup = get_from_id(&muxl->srvl_list, id);\n\tif (up == NULL)\n\t\tgoto out;\n\n\tRCU_INIT_POINTER(muxl->up_cache[idx], NULL);\n\tlist_del_rcu(&up->node);\nout:\n\tspin_unlock_bh(&muxl->receive_lock);\n\treturn up;\n}\n\nstatic int cfmuxl_receive(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tint ret;\n\tstruct cfmuxl *muxl = container_obj(layr);\n\tu8 id;\n\tstruct cflayer *up;\n\tif (cfpkt_extr_head(pkt, &id, 1) < 0) {\n\t\tpr_err(\"erroneous Caif Packet\\n\");\n\t\tcfpkt_destroy(pkt);\n\t\treturn -EPROTO;\n\t}\n\trcu_read_lock();\n\tup = get_up(muxl, id);\n\n\tif (up == NULL) {\n\t\tpr_debug(\"Received data on unknown link ID = %d (0x%x)\"\n\t\t\t\" up == NULL\", id, id);\n\t\tcfpkt_destroy(pkt);\n\t\t \n\n\t\trcu_read_unlock();\n\t\treturn   0;\n\t}\n\n\t \n\tcfsrvl_get(up);\n\trcu_read_unlock();\n\n\tret = up->receive(up, pkt);\n\n\tcfsrvl_put(up);\n\treturn ret;\n}\n\nstatic int cfmuxl_transmit(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tstruct cfmuxl *muxl = container_obj(layr);\n\tint err;\n\tu8 linkid;\n\tstruct cflayer *dn;\n\tstruct caif_payload_info *info = cfpkt_info(pkt);\n\tBUG_ON(!info);\n\n\trcu_read_lock();\n\n\tdn = get_dn(muxl, info->dev_info);\n\tif (dn == NULL) {\n\t\tpr_debug(\"Send data on unknown phy ID = %d (0x%x)\\n\",\n\t\t\tinfo->dev_info->id, info->dev_info->id);\n\t\trcu_read_unlock();\n\t\tcfpkt_destroy(pkt);\n\t\treturn -ENOTCONN;\n\t}\n\n\tinfo->hdr_len += 1;\n\tlinkid = info->channel_id;\n\tcfpkt_add_head(pkt, &linkid, 1);\n\n\t \n\tcffrml_hold(dn);\n\n\trcu_read_unlock();\n\n\terr = dn->transmit(dn, pkt);\n\n\tcffrml_put(dn);\n\treturn err;\n}\n\nstatic void cfmuxl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\n\t\t\t   int phyid)\n{\n\tstruct cfmuxl *muxl = container_obj(layr);\n\tstruct cflayer *layer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(layer, &muxl->srvl_list, node) {\n\n\t\tif (cfsrvl_phyid_match(layer, phyid) && layer->ctrlcmd) {\n\n\t\t\tif ((ctrl == _CAIF_CTRLCMD_PHYIF_DOWN_IND ||\n\t\t\t\tctrl == CAIF_CTRLCMD_REMOTE_SHUTDOWN_IND) &&\n\t\t\t\t\tlayer->id != 0)\n\t\t\t\tcfmuxl_remove_uplayer(layr, layer->id);\n\n\t\t\t \n\t\t\tlayer->ctrlcmd(layer, ctrl, phyid);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}