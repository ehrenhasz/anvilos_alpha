{
  "module_name": "cfdgml.c",
  "hash_id": "a5215cb4775ee6184b7cf75f28c09e3164dc3976e90d9e6aa0a17c89ee1fa99d",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/cfdgml.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/stddef.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <net/caif/caif_layer.h>\n#include <net/caif/cfsrvl.h>\n#include <net/caif/cfpkt.h>\n\n\n#define container_obj(layr) ((struct cfsrvl *) layr)\n\n#define DGM_CMD_BIT  0x80\n#define DGM_FLOW_OFF 0x81\n#define DGM_FLOW_ON  0x80\n#define DGM_MTU 1500\n\nstatic int cfdgml_receive(struct cflayer *layr, struct cfpkt *pkt);\nstatic int cfdgml_transmit(struct cflayer *layr, struct cfpkt *pkt);\n\nstruct cflayer *cfdgml_create(u8 channel_id, struct dev_info *dev_info)\n{\n\tstruct cfsrvl *dgm = kzalloc(sizeof(struct cfsrvl), GFP_ATOMIC);\n\tif (!dgm)\n\t\treturn NULL;\n\tcaif_assert(offsetof(struct cfsrvl, layer) == 0);\n\tcfsrvl_init(dgm, channel_id, dev_info, true);\n\tdgm->layer.receive = cfdgml_receive;\n\tdgm->layer.transmit = cfdgml_transmit;\n\tsnprintf(dgm->layer.name, CAIF_LAYER_NAME_SZ, \"dgm%d\", channel_id);\n\treturn &dgm->layer;\n}\n\nstatic int cfdgml_receive(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tu8 cmd = -1;\n\tu8 dgmhdr[3];\n\tint ret;\n\tcaif_assert(layr->up != NULL);\n\tcaif_assert(layr->receive != NULL);\n\tcaif_assert(layr->ctrlcmd != NULL);\n\n\tif (cfpkt_extr_head(pkt, &cmd, 1) < 0) {\n\t\tpr_err(\"Packet is erroneous!\\n\");\n\t\tcfpkt_destroy(pkt);\n\t\treturn -EPROTO;\n\t}\n\n\tif ((cmd & DGM_CMD_BIT) == 0) {\n\t\tif (cfpkt_extr_head(pkt, &dgmhdr, 3) < 0) {\n\t\t\tpr_err(\"Packet is erroneous!\\n\");\n\t\t\tcfpkt_destroy(pkt);\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tret = layr->up->receive(layr->up, pkt);\n\t\treturn ret;\n\t}\n\n\tswitch (cmd) {\n\tcase DGM_FLOW_OFF:\t \n\t\tlayr->ctrlcmd(layr, CAIF_CTRLCMD_FLOW_OFF_IND, 0);\n\t\tcfpkt_destroy(pkt);\n\t\treturn 0;\n\tcase DGM_FLOW_ON:\t \n\t\tlayr->ctrlcmd(layr, CAIF_CTRLCMD_FLOW_ON_IND, 0);\n\t\tcfpkt_destroy(pkt);\n\t\treturn 0;\n\tdefault:\n\t\tcfpkt_destroy(pkt);\n\t\tpr_info(\"Unknown datagram control %d (0x%x)\\n\", cmd, cmd);\n\t\treturn -EPROTO;\n\t}\n}\n\nstatic int cfdgml_transmit(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tu8 packet_type;\n\tu32 zero = 0;\n\tstruct caif_payload_info *info;\n\tstruct cfsrvl *service = container_obj(layr);\n\tint ret;\n\n\tif (!cfsrvl_ready(service, &ret)) {\n\t\tcfpkt_destroy(pkt);\n\t\treturn ret;\n\t}\n\n\t \n\tif (cfpkt_getlen(pkt) > DGM_MTU) {\n\t\tcfpkt_destroy(pkt);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tcfpkt_add_head(pkt, &zero, 3);\n\tpacket_type = 0x08;  \n\tcfpkt_add_head(pkt, &packet_type, 1);\n\n\t \n\tinfo = cfpkt_info(pkt);\n\tinfo->channel_id = service->layer.id;\n\t \n\tinfo->hdr_len = 4;\n\tinfo->dev_info = &service->dev_info;\n\treturn layr->dn->transmit(layr->dn, pkt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}