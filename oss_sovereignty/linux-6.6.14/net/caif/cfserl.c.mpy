{
  "module_name": "cfserl.c",
  "hash_id": "0a0c8081a74e6ba7db568136656e2543af4c275192d8a80f7a878b3d94ad10fb",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/cfserl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/stddef.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <net/caif/caif_layer.h>\n#include <net/caif/cfpkt.h>\n#include <net/caif/cfserl.h>\n\n#define container_obj(layr) ((struct cfserl *) layr)\n\n#define CFSERL_STX 0x02\n#define SERIAL_MINIUM_PACKET_SIZE 4\n#define SERIAL_MAX_FRAMESIZE 4096\nstruct cfserl {\n\tstruct cflayer layer;\n\tstruct cfpkt *incomplete_frm;\n\t \n\tspinlock_t sync;\n\tbool usestx;\n};\n\nstatic int cfserl_receive(struct cflayer *layr, struct cfpkt *pkt);\nstatic int cfserl_transmit(struct cflayer *layr, struct cfpkt *pkt);\nstatic void cfserl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\n\t\t\t   int phyid);\n\nvoid cfserl_release(struct cflayer *layer)\n{\n\tkfree(layer);\n}\n\nstruct cflayer *cfserl_create(int instance, bool use_stx)\n{\n\tstruct cfserl *this = kzalloc(sizeof(struct cfserl), GFP_ATOMIC);\n\tif (!this)\n\t\treturn NULL;\n\tcaif_assert(offsetof(struct cfserl, layer) == 0);\n\tthis->layer.receive = cfserl_receive;\n\tthis->layer.transmit = cfserl_transmit;\n\tthis->layer.ctrlcmd = cfserl_ctrlcmd;\n\tthis->usestx = use_stx;\n\tspin_lock_init(&this->sync);\n\tsnprintf(this->layer.name, CAIF_LAYER_NAME_SZ, \"ser1\");\n\treturn &this->layer;\n}\n\nstatic int cfserl_receive(struct cflayer *l, struct cfpkt *newpkt)\n{\n\tstruct cfserl *layr = container_obj(l);\n\tu16 pkt_len;\n\tstruct cfpkt *pkt = NULL;\n\tstruct cfpkt *tail_pkt = NULL;\n\tu8 tmp8;\n\tu16 tmp;\n\tu8 stx = CFSERL_STX;\n\tint ret;\n\tu16 expectlen = 0;\n\n\tcaif_assert(newpkt != NULL);\n\tspin_lock(&layr->sync);\n\n\tif (layr->incomplete_frm != NULL) {\n\t\tlayr->incomplete_frm =\n\t\t    cfpkt_append(layr->incomplete_frm, newpkt, expectlen);\n\t\tpkt = layr->incomplete_frm;\n\t\tif (pkt == NULL) {\n\t\t\tspin_unlock(&layr->sync);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tpkt = newpkt;\n\t}\n\tlayr->incomplete_frm = NULL;\n\n\tdo {\n\t\t \n\t\tif (layr->usestx) {\n\t\t\tcfpkt_extr_head(pkt, &tmp8, 1);\n\t\t\tif (tmp8 != CFSERL_STX) {\n\t\t\t\twhile (cfpkt_more(pkt)\n\t\t\t\t       && tmp8 != CFSERL_STX) {\n\t\t\t\t\tcfpkt_extr_head(pkt, &tmp8, 1);\n\t\t\t\t}\n\t\t\t\tif (!cfpkt_more(pkt)) {\n\t\t\t\t\tcfpkt_destroy(pkt);\n\t\t\t\t\tlayr->incomplete_frm = NULL;\n\t\t\t\t\tspin_unlock(&layr->sync);\n\t\t\t\t\treturn -EPROTO;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpkt_len = cfpkt_getlen(pkt);\n\n\t\t \n\n\t\tif (pkt_len < 2) {\n\t\t\tif (layr->usestx)\n\t\t\t\tcfpkt_add_head(pkt, &stx, 1);\n\t\t\tlayr->incomplete_frm = pkt;\n\t\t\tspin_unlock(&layr->sync);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tcfpkt_peek_head(pkt, &tmp, 2);\n\t\texpectlen = le16_to_cpu(tmp) + 2;\n\t\t \n\t\tif (expectlen < SERIAL_MINIUM_PACKET_SIZE\n\t\t    || expectlen > SERIAL_MAX_FRAMESIZE) {\n\t\t\tif (!layr->usestx) {\n\t\t\t\tif (pkt != NULL)\n\t\t\t\t\tcfpkt_destroy(pkt);\n\t\t\t\tlayr->incomplete_frm = NULL;\n\t\t\t\tspin_unlock(&layr->sync);\n\t\t\t\treturn -EPROTO;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pkt_len < expectlen) {\n\t\t\t \n\t\t\tif (layr->usestx)\n\t\t\t\tcfpkt_add_head(pkt, &stx, 1);\n\t\t\tlayr->incomplete_frm = pkt;\n\t\t\tspin_unlock(&layr->sync);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (pkt_len > expectlen)\n\t\t\ttail_pkt = cfpkt_split(pkt, expectlen);\n\t\telse\n\t\t\ttail_pkt = NULL;\n\n\t\t \n\t\tspin_unlock(&layr->sync);\n\t\tret = layr->layer.up->receive(layr->layer.up, pkt);\n\t\tspin_lock(&layr->sync);\n\t\tif (ret == -EILSEQ) {\n\t\t\tif (layr->usestx) {\n\t\t\t\tif (tail_pkt != NULL)\n\t\t\t\t\tpkt = cfpkt_append(pkt, tail_pkt, 0);\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcfpkt_destroy(pkt);\n\t\t\t\tpkt = NULL;\n\t\t\t}\n\t\t}\n\n\t\tpkt = tail_pkt;\n\n\t} while (pkt != NULL);\n\n\tspin_unlock(&layr->sync);\n\treturn 0;\n}\n\nstatic int cfserl_transmit(struct cflayer *layer, struct cfpkt *newpkt)\n{\n\tstruct cfserl *layr = container_obj(layer);\n\tu8 tmp8 = CFSERL_STX;\n\tif (layr->usestx)\n\t\tcfpkt_add_head(newpkt, &tmp8, 1);\n\treturn layer->dn->transmit(layer->dn, newpkt);\n}\n\nstatic void cfserl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\n\t\t\t   int phyid)\n{\n\tlayr->up->ctrlcmd(layr->up, ctrl, phyid);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}