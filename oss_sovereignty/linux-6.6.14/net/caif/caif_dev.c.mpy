{
  "module_name": "caif_dev.c",
  "hash_id": "041e0f9ab44e5ba278cd99aca780319f2d77419ce79c216a4d5aa940c4dd3978",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/caif_dev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <net/pkt_sched.h>\n#include <net/caif/caif_device.h>\n#include <net/caif/caif_layer.h>\n#include <net/caif/caif_dev.h>\n#include <net/caif/cfpkt.h>\n#include <net/caif/cfcnfg.h>\n#include <net/caif/cfserl.h>\n\nMODULE_LICENSE(\"GPL\");\n\n \nstruct caif_device_entry {\n\tstruct cflayer layer;\n\tstruct list_head list;\n\tstruct net_device *netdev;\n\tint __percpu *pcpu_refcnt;\n\tspinlock_t flow_lock;\n\tstruct sk_buff *xoff_skb;\n\tvoid (*xoff_skb_dtor)(struct sk_buff *skb);\n\tbool xoff;\n};\n\nstruct caif_device_entry_list {\n\tstruct list_head list;\n\t \n\tstruct mutex lock;\n};\n\nstruct caif_net {\n\tstruct cfcnfg *cfg;\n\tstruct caif_device_entry_list caifdevs;\n};\n\nstatic unsigned int caif_net_id;\nstatic int q_high = 50;  \n\nstruct cfcnfg *get_cfcnfg(struct net *net)\n{\n\tstruct caif_net *caifn;\n\tcaifn = net_generic(net, caif_net_id);\n\treturn caifn->cfg;\n}\nEXPORT_SYMBOL(get_cfcnfg);\n\nstatic struct caif_device_entry_list *caif_device_list(struct net *net)\n{\n\tstruct caif_net *caifn;\n\tcaifn = net_generic(net, caif_net_id);\n\treturn &caifn->caifdevs;\n}\n\nstatic void caifd_put(struct caif_device_entry *e)\n{\n\tthis_cpu_dec(*e->pcpu_refcnt);\n}\n\nstatic void caifd_hold(struct caif_device_entry *e)\n{\n\tthis_cpu_inc(*e->pcpu_refcnt);\n}\n\nstatic int caifd_refcnt_read(struct caif_device_entry *e)\n{\n\tint i, refcnt = 0;\n\tfor_each_possible_cpu(i)\n\t\trefcnt += *per_cpu_ptr(e->pcpu_refcnt, i);\n\treturn refcnt;\n}\n\n \nstatic struct caif_device_entry *caif_device_alloc(struct net_device *dev)\n{\n\tstruct caif_device_entry *caifd;\n\n\tcaifd = kzalloc(sizeof(*caifd), GFP_KERNEL);\n\tif (!caifd)\n\t\treturn NULL;\n\tcaifd->pcpu_refcnt = alloc_percpu(int);\n\tif (!caifd->pcpu_refcnt) {\n\t\tkfree(caifd);\n\t\treturn NULL;\n\t}\n\tcaifd->netdev = dev;\n\tdev_hold(dev);\n\treturn caifd;\n}\n\nstatic struct caif_device_entry *caif_get(struct net_device *dev)\n{\n\tstruct caif_device_entry_list *caifdevs =\n\t    caif_device_list(dev_net(dev));\n\tstruct caif_device_entry *caifd;\n\n\tlist_for_each_entry_rcu(caifd, &caifdevs->list, list,\n\t\t\t\tlockdep_rtnl_is_held()) {\n\t\tif (caifd->netdev == dev)\n\t\t\treturn caifd;\n\t}\n\treturn NULL;\n}\n\nstatic void caif_flow_cb(struct sk_buff *skb)\n{\n\tstruct caif_device_entry *caifd;\n\tvoid (*dtor)(struct sk_buff *skb) = NULL;\n\tbool send_xoff;\n\n\tWARN_ON(skb->dev == NULL);\n\n\trcu_read_lock();\n\tcaifd = caif_get(skb->dev);\n\n\tWARN_ON(caifd == NULL);\n\tif (!caifd) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcaifd_hold(caifd);\n\trcu_read_unlock();\n\n\tspin_lock_bh(&caifd->flow_lock);\n\tsend_xoff = caifd->xoff;\n\tcaifd->xoff = false;\n\tdtor = caifd->xoff_skb_dtor;\n\n\tif (WARN_ON(caifd->xoff_skb != skb))\n\t\tskb = NULL;\n\n\tcaifd->xoff_skb = NULL;\n\tcaifd->xoff_skb_dtor = NULL;\n\n\tspin_unlock_bh(&caifd->flow_lock);\n\n\tif (dtor && skb)\n\t\tdtor(skb);\n\n\tif (send_xoff)\n\t\tcaifd->layer.up->\n\t\t\tctrlcmd(caifd->layer.up,\n\t\t\t\t_CAIF_CTRLCMD_PHYIF_FLOW_ON_IND,\n\t\t\t\tcaifd->layer.id);\n\tcaifd_put(caifd);\n}\n\nstatic int transmit(struct cflayer *layer, struct cfpkt *pkt)\n{\n\tint err, high = 0, qlen = 0;\n\tstruct caif_device_entry *caifd =\n\t    container_of(layer, struct caif_device_entry, layer);\n\tstruct sk_buff *skb;\n\tstruct netdev_queue *txq;\n\n\trcu_read_lock_bh();\n\n\tskb = cfpkt_tonative(pkt);\n\tskb->dev = caifd->netdev;\n\tskb_reset_network_header(skb);\n\tskb->protocol = htons(ETH_P_CAIF);\n\n\t \n\tif (likely(caifd->netdev->priv_flags & IFF_NO_QUEUE))\n\t\tgoto noxoff;\n\n\tif (unlikely(caifd->xoff))\n\t\tgoto noxoff;\n\n\tif (likely(!netif_queue_stopped(caifd->netdev))) {\n\t\tstruct Qdisc *sch;\n\n\t\t \n\t\ttxq = netdev_get_tx_queue(skb->dev, 0);\n\t\tsch = rcu_dereference_bh(txq->qdisc);\n\t\tif (likely(qdisc_is_empty(sch)))\n\t\t\tgoto noxoff;\n\n\t\t \n\t\thigh = (caifd->netdev->tx_queue_len * q_high) / 100;\n\t\tif (!(sch->flags & TCQ_F_NOLOCK) && likely(sch->q.qlen < high))\n\t\t\tgoto noxoff;\n\t}\n\n\t \n\tspin_lock_bh(&caifd->flow_lock);\n\tif (caifd->xoff) {\n\t\tspin_unlock_bh(&caifd->flow_lock);\n\t\tgoto noxoff;\n\t}\n\n\t \n\n\tpr_debug(\"queue has stopped(%d) or is full (%d > %d)\\n\",\n\t\t\tnetif_queue_stopped(caifd->netdev),\n\t\t\tqlen, high);\n\tcaifd->xoff = true;\n\tcaifd->xoff_skb = skb;\n\tcaifd->xoff_skb_dtor = skb->destructor;\n\tskb->destructor = caif_flow_cb;\n\tspin_unlock_bh(&caifd->flow_lock);\n\n\tcaifd->layer.up->ctrlcmd(caifd->layer.up,\n\t\t\t\t\t_CAIF_CTRLCMD_PHYIF_FLOW_OFF_IND,\n\t\t\t\t\tcaifd->layer.id);\nnoxoff:\n\trcu_read_unlock_bh();\n\n\terr = dev_queue_xmit(skb);\n\tif (err > 0)\n\t\terr = -EIO;\n\n\treturn err;\n}\n\n \nstatic int receive(struct sk_buff *skb, struct net_device *dev,\n\t\t   struct packet_type *pkttype, struct net_device *orig_dev)\n{\n\tstruct cfpkt *pkt;\n\tstruct caif_device_entry *caifd;\n\tint err;\n\n\tpkt = cfpkt_fromnative(CAIF_DIR_IN, skb);\n\n\trcu_read_lock();\n\tcaifd = caif_get(dev);\n\n\tif (!caifd || !caifd->layer.up || !caifd->layer.up->receive ||\n\t\t\t!netif_oper_up(caifd->netdev)) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\t \n\tcaifd_hold(caifd);\n\trcu_read_unlock();\n\n\terr = caifd->layer.up->receive(caifd->layer.up, pkt);\n\n\t \n\tif (err == -EILSEQ)\n\t\tcfpkt_destroy(pkt);\n\n\t \n\tcaifd_put(caifd);\n\n\tif (err != 0)\n\t\terr = NET_RX_DROP;\n\treturn err;\n}\n\nstatic struct packet_type caif_packet_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_CAIF),\n\t.func = receive,\n};\n\nstatic void dev_flowctrl(struct net_device *dev, int on)\n{\n\tstruct caif_device_entry *caifd;\n\n\trcu_read_lock();\n\n\tcaifd = caif_get(dev);\n\tif (!caifd || !caifd->layer.up || !caifd->layer.up->ctrlcmd) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcaifd_hold(caifd);\n\trcu_read_unlock();\n\n\tcaifd->layer.up->ctrlcmd(caifd->layer.up,\n\t\t\t\t on ?\n\t\t\t\t _CAIF_CTRLCMD_PHYIF_FLOW_ON_IND :\n\t\t\t\t _CAIF_CTRLCMD_PHYIF_FLOW_OFF_IND,\n\t\t\t\t caifd->layer.id);\n\tcaifd_put(caifd);\n}\n\nint caif_enroll_dev(struct net_device *dev, struct caif_dev_common *caifdev,\n\t\t     struct cflayer *link_support, int head_room,\n\t\t     struct cflayer **layer,\n\t\t     int (**rcv_func)(struct sk_buff *, struct net_device *,\n\t\t\t\t      struct packet_type *,\n\t\t\t\t      struct net_device *))\n{\n\tstruct caif_device_entry *caifd;\n\tenum cfcnfg_phy_preference pref;\n\tstruct cfcnfg *cfg = get_cfcnfg(dev_net(dev));\n\tstruct caif_device_entry_list *caifdevs;\n\tint res;\n\n\tcaifdevs = caif_device_list(dev_net(dev));\n\tcaifd = caif_device_alloc(dev);\n\tif (!caifd)\n\t\treturn -ENOMEM;\n\t*layer = &caifd->layer;\n\tspin_lock_init(&caifd->flow_lock);\n\n\tswitch (caifdev->link_select) {\n\tcase CAIF_LINK_HIGH_BANDW:\n\t\tpref = CFPHYPREF_HIGH_BW;\n\t\tbreak;\n\tcase CAIF_LINK_LOW_LATENCY:\n\t\tpref = CFPHYPREF_LOW_LAT;\n\t\tbreak;\n\tdefault:\n\t\tpref = CFPHYPREF_HIGH_BW;\n\t\tbreak;\n\t}\n\tmutex_lock(&caifdevs->lock);\n\tlist_add_rcu(&caifd->list, &caifdevs->list);\n\n\tstrscpy(caifd->layer.name, dev->name,\n\t\tsizeof(caifd->layer.name));\n\tcaifd->layer.transmit = transmit;\n\tres = cfcnfg_add_phy_layer(cfg,\n\t\t\t\tdev,\n\t\t\t\t&caifd->layer,\n\t\t\t\tpref,\n\t\t\t\tlink_support,\n\t\t\t\tcaifdev->use_fcs,\n\t\t\t\thead_room);\n\tmutex_unlock(&caifdevs->lock);\n\tif (rcv_func)\n\t\t*rcv_func = receive;\n\treturn res;\n}\nEXPORT_SYMBOL(caif_enroll_dev);\n\n \nstatic int caif_device_notify(struct notifier_block *me, unsigned long what,\n\t\t\t      void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct caif_device_entry *caifd = NULL;\n\tstruct caif_dev_common *caifdev;\n\tstruct cfcnfg *cfg;\n\tstruct cflayer *layer, *link_support;\n\tint head_room = 0;\n\tstruct caif_device_entry_list *caifdevs;\n\tint res;\n\n\tcfg = get_cfcnfg(dev_net(dev));\n\tcaifdevs = caif_device_list(dev_net(dev));\n\n\tcaifd = caif_get(dev);\n\tif (caifd == NULL && dev->type != ARPHRD_CAIF)\n\t\treturn 0;\n\n\tswitch (what) {\n\tcase NETDEV_REGISTER:\n\t\tif (caifd != NULL)\n\t\t\tbreak;\n\n\t\tcaifdev = netdev_priv(dev);\n\n\t\tlink_support = NULL;\n\t\tif (caifdev->use_frag) {\n\t\t\thead_room = 1;\n\t\t\tlink_support = cfserl_create(dev->ifindex,\n\t\t\t\t\t\t\tcaifdev->use_stx);\n\t\t\tif (!link_support) {\n\t\t\t\tpr_warn(\"Out of memory\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = caif_enroll_dev(dev, caifdev, link_support, head_room,\n\t\t\t\t&layer, NULL);\n\t\tif (res)\n\t\t\tcfserl_release(link_support);\n\t\tcaifdev->flowctrl = dev_flowctrl;\n\t\tbreak;\n\n\tcase NETDEV_UP:\n\t\trcu_read_lock();\n\n\t\tcaifd = caif_get(dev);\n\t\tif (caifd == NULL) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\tcaifd->xoff = false;\n\t\tcfcnfg_set_phy_state(cfg, &caifd->layer, true);\n\t\trcu_read_unlock();\n\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\trcu_read_lock();\n\n\t\tcaifd = caif_get(dev);\n\t\tif (!caifd || !caifd->layer.up || !caifd->layer.up->ctrlcmd) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcfcnfg_set_phy_state(cfg, &caifd->layer, false);\n\t\tcaifd_hold(caifd);\n\t\trcu_read_unlock();\n\n\t\tcaifd->layer.up->ctrlcmd(caifd->layer.up,\n\t\t\t\t\t _CAIF_CTRLCMD_PHYIF_DOWN_IND,\n\t\t\t\t\t caifd->layer.id);\n\n\t\tspin_lock_bh(&caifd->flow_lock);\n\n\t\t \n\t\tif (caifd->xoff_skb_dtor != NULL && caifd->xoff_skb != NULL)\n\t\t\tcaifd->xoff_skb->destructor = caifd->xoff_skb_dtor;\n\n\t\tcaifd->xoff = false;\n\t\tcaifd->xoff_skb_dtor = NULL;\n\t\tcaifd->xoff_skb = NULL;\n\n\t\tspin_unlock_bh(&caifd->flow_lock);\n\t\tcaifd_put(caifd);\n\t\tbreak;\n\n\tcase NETDEV_UNREGISTER:\n\t\tmutex_lock(&caifdevs->lock);\n\n\t\tcaifd = caif_get(dev);\n\t\tif (caifd == NULL) {\n\t\t\tmutex_unlock(&caifdevs->lock);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_rcu(&caifd->list);\n\n\t\t \n\n\t\tif (caifd_refcnt_read(caifd) != 0 ||\n\t\t\tcfcnfg_del_phy_layer(cfg, &caifd->layer) != 0) {\n\n\t\t\tpr_info(\"Wait for device inuse\\n\");\n\t\t\t \n\t\t\tlist_add_rcu(&caifd->list, &caifdevs->list);\n\t\t\tmutex_unlock(&caifdevs->lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tsynchronize_rcu();\n\t\tdev_put(caifd->netdev);\n\t\tfree_percpu(caifd->pcpu_refcnt);\n\t\tkfree(caifd);\n\n\t\tmutex_unlock(&caifdevs->lock);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block caif_device_notifier = {\n\t.notifier_call = caif_device_notify,\n\t.priority = 0,\n};\n\n \nstatic int caif_init_net(struct net *net)\n{\n\tstruct caif_net *caifn = net_generic(net, caif_net_id);\n\tINIT_LIST_HEAD(&caifn->caifdevs.list);\n\tmutex_init(&caifn->caifdevs.lock);\n\n\tcaifn->cfg = cfcnfg_create();\n\tif (!caifn->cfg)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void caif_exit_net(struct net *net)\n{\n\tstruct caif_device_entry *caifd, *tmp;\n\tstruct caif_device_entry_list *caifdevs =\n\t    caif_device_list(net);\n\tstruct cfcnfg *cfg =  get_cfcnfg(net);\n\n\trtnl_lock();\n\tmutex_lock(&caifdevs->lock);\n\n\tlist_for_each_entry_safe(caifd, tmp, &caifdevs->list, list) {\n\t\tint i = 0;\n\t\tlist_del_rcu(&caifd->list);\n\t\tcfcnfg_set_phy_state(cfg, &caifd->layer, false);\n\n\t\twhile (i < 10 &&\n\t\t\t(caifd_refcnt_read(caifd) != 0 ||\n\t\t\tcfcnfg_del_phy_layer(cfg, &caifd->layer) != 0)) {\n\n\t\t\tpr_info(\"Wait for device inuse\\n\");\n\t\t\tmsleep(250);\n\t\t\ti++;\n\t\t}\n\t\tsynchronize_rcu();\n\t\tdev_put(caifd->netdev);\n\t\tfree_percpu(caifd->pcpu_refcnt);\n\t\tkfree(caifd);\n\t}\n\tcfcnfg_remove(cfg);\n\n\tmutex_unlock(&caifdevs->lock);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations caif_net_ops = {\n\t.init = caif_init_net,\n\t.exit = caif_exit_net,\n\t.id   = &caif_net_id,\n\t.size = sizeof(struct caif_net),\n};\n\n \nstatic int __init caif_device_init(void)\n{\n\tint result;\n\n\tresult = register_pernet_subsys(&caif_net_ops);\n\n\tif (result)\n\t\treturn result;\n\n\tregister_netdevice_notifier(&caif_device_notifier);\n\tdev_add_pack(&caif_packet_type);\n\n\treturn result;\n}\n\nstatic void __exit caif_device_exit(void)\n{\n\tunregister_netdevice_notifier(&caif_device_notifier);\n\tdev_remove_pack(&caif_packet_type);\n\tunregister_pernet_subsys(&caif_net_ops);\n}\n\nmodule_init(caif_device_init);\nmodule_exit(caif_device_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}