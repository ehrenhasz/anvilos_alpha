{
  "module_name": "cfcnfg.c",
  "hash_id": "0e410c2004a24502b27c238963c3461b7a971806499d1b6bfb6773d5aa8f10bb",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/cfcnfg.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/module.h>\n#include <net/caif/caif_layer.h>\n#include <net/caif/cfpkt.h>\n#include <net/caif/cfcnfg.h>\n#include <net/caif/cfctrl.h>\n#include <net/caif/cfmuxl.h>\n#include <net/caif/cffrml.h>\n#include <net/caif/cfserl.h>\n#include <net/caif/cfsrvl.h>\n#include <net/caif/caif_dev.h>\n\n#define container_obj(layr) container_of(layr, struct cfcnfg, layer)\n\n \nstruct cfcnfg_phyinfo {\n\tstruct list_head node;\n\tbool up;\n\n\t \n\tstruct cflayer *frm_layer;\n\t \n\tstruct cflayer *phy_layer;\n\t \n\tunsigned int id;\n\t \n\tenum cfcnfg_phy_preference pref;\n\n\t \n\tstruct dev_info dev_info;\n\n\t \n\tint ifindex;\n\n\t \n\tint head_room;\n\n\t \n\tbool use_fcs;\n};\n\nstruct cfcnfg {\n\tstruct cflayer layer;\n\tstruct cflayer *ctrl;\n\tstruct cflayer *mux;\n\tstruct list_head phys;\n\tstruct mutex lock;\n};\n\nstatic void cfcnfg_linkup_rsp(struct cflayer *layer, u8 channel_id,\n\t\t\t      enum cfctrl_srv serv, u8 phyid,\n\t\t\t      struct cflayer *adapt_layer);\nstatic void cfcnfg_linkdestroy_rsp(struct cflayer *layer, u8 channel_id);\nstatic void cfcnfg_reject_rsp(struct cflayer *layer, u8 channel_id,\n\t\t\t      struct cflayer *adapt_layer);\nstatic void cfctrl_resp_func(void);\nstatic void cfctrl_enum_resp(void);\n\nstruct cfcnfg *cfcnfg_create(void)\n{\n\tstruct cfcnfg *this;\n\tstruct cfctrl_rsp *resp;\n\n\tmight_sleep();\n\n\t \n\tthis = kzalloc(sizeof(struct cfcnfg), GFP_ATOMIC);\n\tif (!this)\n\t\treturn NULL;\n\tthis->mux = cfmuxl_create();\n\tif (!this->mux)\n\t\tgoto out_of_mem;\n\tthis->ctrl = cfctrl_create();\n\tif (!this->ctrl)\n\t\tgoto out_of_mem;\n\t \n\tresp = cfctrl_get_respfuncs(this->ctrl);\n\tresp->enum_rsp = cfctrl_enum_resp;\n\tresp->linkerror_ind = cfctrl_resp_func;\n\tresp->linkdestroy_rsp = cfcnfg_linkdestroy_rsp;\n\tresp->sleep_rsp = cfctrl_resp_func;\n\tresp->wake_rsp = cfctrl_resp_func;\n\tresp->restart_rsp = cfctrl_resp_func;\n\tresp->radioset_rsp = cfctrl_resp_func;\n\tresp->linksetup_rsp = cfcnfg_linkup_rsp;\n\tresp->reject_rsp = cfcnfg_reject_rsp;\n\tINIT_LIST_HEAD(&this->phys);\n\n\tcfmuxl_set_uplayer(this->mux, this->ctrl, 0);\n\tlayer_set_dn(this->ctrl, this->mux);\n\tlayer_set_up(this->ctrl, this);\n\tmutex_init(&this->lock);\n\n\treturn this;\nout_of_mem:\n\tsynchronize_rcu();\n\n\tkfree(this->mux);\n\tkfree(this->ctrl);\n\tkfree(this);\n\treturn NULL;\n}\n\nvoid cfcnfg_remove(struct cfcnfg *cfg)\n{\n\tmight_sleep();\n\tif (cfg) {\n\t\tsynchronize_rcu();\n\n\t\tkfree(cfg->mux);\n\t\tcfctrl_remove(cfg->ctrl);\n\t\tkfree(cfg);\n\t}\n}\n\nstatic void cfctrl_resp_func(void)\n{\n}\n\nstatic struct cfcnfg_phyinfo *cfcnfg_get_phyinfo_rcu(struct cfcnfg *cnfg,\n\t\t\t\t\t\t     u8 phyid)\n{\n\tstruct cfcnfg_phyinfo *phy;\n\n\tlist_for_each_entry_rcu(phy, &cnfg->phys, node)\n\t\tif (phy->id == phyid)\n\t\t\treturn phy;\n\treturn NULL;\n}\n\nstatic void cfctrl_enum_resp(void)\n{\n}\n\nstatic struct dev_info *cfcnfg_get_phyid(struct cfcnfg *cnfg,\n\t\t\t\t  enum cfcnfg_phy_preference phy_pref)\n{\n\t \n\tstruct cfcnfg_phyinfo *phy;\n\n\tlist_for_each_entry_rcu(phy, &cnfg->phys, node) {\n\t\tif (phy->up && phy->pref == phy_pref &&\n\t\t\t\tphy->frm_layer != NULL)\n\n\t\t\treturn &phy->dev_info;\n\t}\n\n\t \n\tlist_for_each_entry_rcu(phy, &cnfg->phys, node)\n\t\tif (phy->up)\n\t\t\treturn &phy->dev_info;\n\n\treturn NULL;\n}\n\nstatic int cfcnfg_get_id_from_ifi(struct cfcnfg *cnfg, int ifi)\n{\n\tstruct cfcnfg_phyinfo *phy;\n\n\tlist_for_each_entry_rcu(phy, &cnfg->phys, node)\n\t\tif (phy->ifindex == ifi && phy->up)\n\t\t\treturn phy->id;\n\treturn -ENODEV;\n}\n\nint caif_disconnect_client(struct net *net, struct cflayer *adap_layer)\n{\n\tu8 channel_id;\n\tstruct cfcnfg *cfg = get_cfcnfg(net);\n\n\tcaif_assert(adap_layer != NULL);\n\tcfctrl_cancel_req(cfg->ctrl, adap_layer);\n\tchannel_id = adap_layer->id;\n\tif (channel_id != 0) {\n\t\tstruct cflayer *servl;\n\t\tservl = cfmuxl_remove_uplayer(cfg->mux, channel_id);\n\t\tcfctrl_linkdown_req(cfg->ctrl, channel_id, adap_layer);\n\t\tif (servl != NULL)\n\t\t\tlayer_set_up(servl, NULL);\n\t} else\n\t\tpr_debug(\"nothing to disconnect\\n\");\n\n\t \n\tsynchronize_rcu();\n\tif (adap_layer->ctrlcmd != NULL)\n\t\tadap_layer->ctrlcmd(adap_layer, CAIF_CTRLCMD_DEINIT_RSP, 0);\n\treturn 0;\n\n}\nEXPORT_SYMBOL(caif_disconnect_client);\n\nstatic void cfcnfg_linkdestroy_rsp(struct cflayer *layer, u8 channel_id)\n{\n}\n\nstatic const int protohead[CFCTRL_SRV_MASK] = {\n\t[CFCTRL_SRV_VEI] = 4,\n\t[CFCTRL_SRV_DATAGRAM] = 7,\n\t[CFCTRL_SRV_UTIL] = 4,\n\t[CFCTRL_SRV_RFM] = 3,\n\t[CFCTRL_SRV_DBG] = 3,\n};\n\n\nstatic int caif_connect_req_to_link_param(struct cfcnfg *cnfg,\n\t\t\t\t\t  struct caif_connect_request *s,\n\t\t\t\t\t  struct cfctrl_link_param *l)\n{\n\tstruct dev_info *dev_info;\n\tenum cfcnfg_phy_preference pref;\n\tint res;\n\n\tmemset(l, 0, sizeof(*l));\n\t \n\tl->priority = CAIF_PRIO_MAX - s->priority + 1;\n\n\tif (s->ifindex != 0) {\n\t\tres = cfcnfg_get_id_from_ifi(cnfg, s->ifindex);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\tl->phyid = res;\n\t} else {\n\t\tswitch (s->link_selector) {\n\t\tcase CAIF_LINK_HIGH_BANDW:\n\t\t\tpref = CFPHYPREF_HIGH_BW;\n\t\t\tbreak;\n\t\tcase CAIF_LINK_LOW_LATENCY:\n\t\t\tpref = CFPHYPREF_LOW_LAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev_info = cfcnfg_get_phyid(cnfg, pref);\n\t\tif (dev_info == NULL)\n\t\t\treturn -ENODEV;\n\t\tl->phyid = dev_info->id;\n\t}\n\tswitch (s->protocol) {\n\tcase CAIFPROTO_AT:\n\t\tl->linktype = CFCTRL_SRV_VEI;\n\t\tl->endpoint = (s->sockaddr.u.at.type >> 2) & 0x3;\n\t\tl->chtype = s->sockaddr.u.at.type & 0x3;\n\t\tbreak;\n\tcase CAIFPROTO_DATAGRAM:\n\t\tl->linktype = CFCTRL_SRV_DATAGRAM;\n\t\tl->chtype = 0x00;\n\t\tl->u.datagram.connid = s->sockaddr.u.dgm.connection_id;\n\t\tbreak;\n\tcase CAIFPROTO_DATAGRAM_LOOP:\n\t\tl->linktype = CFCTRL_SRV_DATAGRAM;\n\t\tl->chtype = 0x03;\n\t\tl->endpoint = 0x00;\n\t\tl->u.datagram.connid = s->sockaddr.u.dgm.connection_id;\n\t\tbreak;\n\tcase CAIFPROTO_RFM:\n\t\tl->linktype = CFCTRL_SRV_RFM;\n\t\tl->u.datagram.connid = s->sockaddr.u.rfm.connection_id;\n\t\tstrscpy(l->u.rfm.volume, s->sockaddr.u.rfm.volume,\n\t\t\tsizeof(l->u.rfm.volume));\n\t\tbreak;\n\tcase CAIFPROTO_UTIL:\n\t\tl->linktype = CFCTRL_SRV_UTIL;\n\t\tl->endpoint = 0x00;\n\t\tl->chtype = 0x00;\n\t\tstrscpy(l->u.utility.name, s->sockaddr.u.util.service,\n\t\t\tsizeof(l->u.utility.name));\n\t\tcaif_assert(sizeof(l->u.utility.name) > 10);\n\t\tl->u.utility.paramlen = s->param.size;\n\t\tif (l->u.utility.paramlen > sizeof(l->u.utility.params))\n\t\t\tl->u.utility.paramlen = sizeof(l->u.utility.params);\n\n\t\tmemcpy(l->u.utility.params, s->param.data,\n\t\t       l->u.utility.paramlen);\n\n\t\tbreak;\n\tcase CAIFPROTO_DEBUG:\n\t\tl->linktype = CFCTRL_SRV_DBG;\n\t\tl->endpoint = s->sockaddr.u.dbg.service;\n\t\tl->chtype = s->sockaddr.u.dbg.type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint caif_connect_client(struct net *net, struct caif_connect_request *conn_req,\n\t\t\tstruct cflayer *adap_layer, int *ifindex,\n\t\t\tint *proto_head, int *proto_tail)\n{\n\tstruct cflayer *frml;\n\tstruct cfcnfg_phyinfo *phy;\n\tint err;\n\tstruct cfctrl_link_param param;\n\tstruct cfcnfg *cfg = get_cfcnfg(net);\n\n\trcu_read_lock();\n\terr = caif_connect_req_to_link_param(cfg, conn_req, &param);\n\tif (err)\n\t\tgoto unlock;\n\n\tphy = cfcnfg_get_phyinfo_rcu(cfg, param.phyid);\n\tif (!phy) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\terr = -EINVAL;\n\n\tif (adap_layer == NULL) {\n\t\tpr_err(\"adap_layer is zero\\n\");\n\t\tgoto unlock;\n\t}\n\tif (adap_layer->receive == NULL) {\n\t\tpr_err(\"adap_layer->receive is NULL\\n\");\n\t\tgoto unlock;\n\t}\n\tif (adap_layer->ctrlcmd == NULL) {\n\t\tpr_err(\"adap_layer->ctrlcmd == NULL\\n\");\n\t\tgoto unlock;\n\t}\n\n\terr = -ENODEV;\n\tfrml = phy->frm_layer;\n\tif (frml == NULL) {\n\t\tpr_err(\"Specified PHY type does not exist!\\n\");\n\t\tgoto unlock;\n\t}\n\tcaif_assert(param.phyid == phy->id);\n\tcaif_assert(phy->frm_layer->id ==\n\t\t     param.phyid);\n\tcaif_assert(phy->phy_layer->id ==\n\t\t     param.phyid);\n\n\t*ifindex = phy->ifindex;\n\t*proto_tail = 2;\n\t*proto_head = protohead[param.linktype] + phy->head_room;\n\n\trcu_read_unlock();\n\n\t \n\tcfctrl_enum_req(cfg->ctrl, param.phyid);\n\treturn cfctrl_linkup_request(cfg->ctrl, &param, adap_layer);\n\nunlock:\n\trcu_read_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(caif_connect_client);\n\nstatic void cfcnfg_reject_rsp(struct cflayer *layer, u8 channel_id,\n\t\t\t      struct cflayer *adapt_layer)\n{\n\tif (adapt_layer != NULL && adapt_layer->ctrlcmd != NULL)\n\t\tadapt_layer->ctrlcmd(adapt_layer,\n\t\t\t\t     CAIF_CTRLCMD_INIT_FAIL_RSP, 0);\n}\n\nstatic void\ncfcnfg_linkup_rsp(struct cflayer *layer, u8 channel_id, enum cfctrl_srv serv,\n\t\t  u8 phyid, struct cflayer *adapt_layer)\n{\n\tstruct cfcnfg *cnfg = container_obj(layer);\n\tstruct cflayer *servicel = NULL;\n\tstruct cfcnfg_phyinfo *phyinfo;\n\tstruct net_device *netdev;\n\n\tif (channel_id == 0) {\n\t\tpr_warn(\"received channel_id zero\\n\");\n\t\tif (adapt_layer != NULL && adapt_layer->ctrlcmd != NULL)\n\t\t\tadapt_layer->ctrlcmd(adapt_layer,\n\t\t\t\t\t\tCAIF_CTRLCMD_INIT_FAIL_RSP, 0);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\tif (adapt_layer == NULL) {\n\t\tpr_debug(\"link setup response but no client exist, send linkdown back\\n\");\n\t\tcfctrl_linkdown_req(cnfg->ctrl, channel_id, NULL);\n\t\tgoto unlock;\n\t}\n\n\tcaif_assert(cnfg != NULL);\n\tcaif_assert(phyid != 0);\n\n\tphyinfo = cfcnfg_get_phyinfo_rcu(cnfg, phyid);\n\tif (phyinfo == NULL) {\n\t\tpr_err(\"ERROR: Link Layer Device disappeared while connecting\\n\");\n\t\tgoto unlock;\n\t}\n\n\tcaif_assert(phyinfo != NULL);\n\tcaif_assert(phyinfo->id == phyid);\n\tcaif_assert(phyinfo->phy_layer != NULL);\n\tcaif_assert(phyinfo->phy_layer->id == phyid);\n\n\tadapt_layer->id = channel_id;\n\n\tswitch (serv) {\n\tcase CFCTRL_SRV_VEI:\n\t\tservicel = cfvei_create(channel_id, &phyinfo->dev_info);\n\t\tbreak;\n\tcase CFCTRL_SRV_DATAGRAM:\n\t\tservicel = cfdgml_create(channel_id,\n\t\t\t\t\t&phyinfo->dev_info);\n\t\tbreak;\n\tcase CFCTRL_SRV_RFM:\n\t\tnetdev = phyinfo->dev_info.dev;\n\t\tservicel = cfrfml_create(channel_id, &phyinfo->dev_info,\n\t\t\t\t\t\tnetdev->mtu);\n\t\tbreak;\n\tcase CFCTRL_SRV_UTIL:\n\t\tservicel = cfutill_create(channel_id, &phyinfo->dev_info);\n\t\tbreak;\n\tcase CFCTRL_SRV_VIDEO:\n\t\tservicel = cfvidl_create(channel_id, &phyinfo->dev_info);\n\t\tbreak;\n\tcase CFCTRL_SRV_DBG:\n\t\tservicel = cfdbgl_create(channel_id, &phyinfo->dev_info);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Protocol error. Link setup response - unknown channel type\\n\");\n\t\tgoto unlock;\n\t}\n\tif (!servicel)\n\t\tgoto unlock;\n\tlayer_set_dn(servicel, cnfg->mux);\n\tcfmuxl_set_uplayer(cnfg->mux, servicel, channel_id);\n\tlayer_set_up(servicel, adapt_layer);\n\tlayer_set_dn(adapt_layer, servicel);\n\n\trcu_read_unlock();\n\n\tservicel->ctrlcmd(servicel, CAIF_CTRLCMD_INIT_RSP, 0);\n\treturn;\nunlock:\n\trcu_read_unlock();\n}\n\nint\ncfcnfg_add_phy_layer(struct cfcnfg *cnfg,\n\t\t     struct net_device *dev, struct cflayer *phy_layer,\n\t\t     enum cfcnfg_phy_preference pref,\n\t\t     struct cflayer *link_support,\n\t\t     bool fcs, int head_room)\n{\n\tstruct cflayer *frml;\n\tstruct cfcnfg_phyinfo *phyinfo = NULL;\n\tint i, res = 0;\n\tu8 phyid;\n\n\tmutex_lock(&cnfg->lock);\n\n\t \n\tfor (i = 0; i < 7; i++) {\n\t\tphyid = (dev->ifindex + i) & 0x7;\n\t\tif (phyid == 0)\n\t\t\tcontinue;\n\t\tif (cfcnfg_get_phyinfo_rcu(cnfg, phyid) == NULL)\n\t\t\tgoto got_phyid;\n\t}\n\tpr_warn(\"Too many CAIF Link Layers (max 6)\\n\");\n\tres = -EEXIST;\n\tgoto out;\n\ngot_phyid:\n\tphyinfo = kzalloc(sizeof(struct cfcnfg_phyinfo), GFP_ATOMIC);\n\tif (!phyinfo) {\n\t\tres = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tphy_layer->id = phyid;\n\tphyinfo->pref = pref;\n\tphyinfo->id = phyid;\n\tphyinfo->dev_info.id = phyid;\n\tphyinfo->dev_info.dev = dev;\n\tphyinfo->phy_layer = phy_layer;\n\tphyinfo->ifindex = dev->ifindex;\n\tphyinfo->head_room = head_room;\n\tphyinfo->use_fcs = fcs;\n\n\tfrml = cffrml_create(phyid, fcs);\n\n\tif (!frml) {\n\t\tres = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tphyinfo->frm_layer = frml;\n\tlayer_set_up(frml, cnfg->mux);\n\n\tif (link_support != NULL) {\n\t\tlink_support->id = phyid;\n\t\tlayer_set_dn(frml, link_support);\n\t\tlayer_set_up(link_support, frml);\n\t\tlayer_set_dn(link_support, phy_layer);\n\t\tlayer_set_up(phy_layer, link_support);\n\t} else {\n\t\tlayer_set_dn(frml, phy_layer);\n\t\tlayer_set_up(phy_layer, frml);\n\t}\n\n\tlist_add_rcu(&phyinfo->node, &cnfg->phys);\nout:\n\tmutex_unlock(&cnfg->lock);\n\treturn res;\n\nout_err:\n\tkfree(phyinfo);\n\tmutex_unlock(&cnfg->lock);\n\treturn res;\n}\nEXPORT_SYMBOL(cfcnfg_add_phy_layer);\n\nint cfcnfg_set_phy_state(struct cfcnfg *cnfg, struct cflayer *phy_layer,\n\t\t\t bool up)\n{\n\tstruct cfcnfg_phyinfo *phyinfo;\n\n\trcu_read_lock();\n\tphyinfo = cfcnfg_get_phyinfo_rcu(cnfg, phy_layer->id);\n\tif (phyinfo == NULL) {\n\t\trcu_read_unlock();\n\t\treturn -ENODEV;\n\t}\n\n\tif (phyinfo->up == up) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tphyinfo->up = up;\n\n\tif (up) {\n\t\tcffrml_hold(phyinfo->frm_layer);\n\t\tcfmuxl_set_dnlayer(cnfg->mux, phyinfo->frm_layer,\n\t\t\t\t\tphy_layer->id);\n\t} else {\n\t\tcfmuxl_remove_dnlayer(cnfg->mux, phy_layer->id);\n\t\tcffrml_put(phyinfo->frm_layer);\n\t}\n\n\trcu_read_unlock();\n\treturn 0;\n}\nEXPORT_SYMBOL(cfcnfg_set_phy_state);\n\nint cfcnfg_del_phy_layer(struct cfcnfg *cnfg, struct cflayer *phy_layer)\n{\n\tstruct cflayer *frml, *frml_dn;\n\tu16 phyid;\n\tstruct cfcnfg_phyinfo *phyinfo;\n\n\tmight_sleep();\n\n\tmutex_lock(&cnfg->lock);\n\n\tphyid = phy_layer->id;\n\tphyinfo = cfcnfg_get_phyinfo_rcu(cnfg, phyid);\n\n\tif (phyinfo == NULL) {\n\t\tmutex_unlock(&cnfg->lock);\n\t\treturn 0;\n\t}\n\tcaif_assert(phyid == phyinfo->id);\n\tcaif_assert(phy_layer == phyinfo->phy_layer);\n\tcaif_assert(phy_layer->id == phyid);\n\tcaif_assert(phyinfo->frm_layer->id == phyid);\n\n\tlist_del_rcu(&phyinfo->node);\n\tsynchronize_rcu();\n\n\t \n\tif (cffrml_refcnt_read(phyinfo->frm_layer) != 0) {\n\t\tpr_info(\"Wait for device inuse\\n\");\n\t\tlist_add_rcu(&phyinfo->node, &cnfg->phys);\n\t\tmutex_unlock(&cnfg->lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tfrml = phyinfo->frm_layer;\n\tfrml_dn = frml->dn;\n\tcffrml_set_uplayer(frml, NULL);\n\tcffrml_set_dnlayer(frml, NULL);\n\tif (phy_layer != frml_dn) {\n\t\tlayer_set_up(frml_dn, NULL);\n\t\tlayer_set_dn(frml_dn, NULL);\n\t}\n\tlayer_set_up(phy_layer, NULL);\n\n\tif (phyinfo->phy_layer != frml_dn)\n\t\tkfree(frml_dn);\n\n\tcffrml_free(frml);\n\tkfree(phyinfo);\n\tmutex_unlock(&cnfg->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cfcnfg_del_phy_layer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}