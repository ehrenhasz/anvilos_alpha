{
  "module_name": "cffrml.c",
  "hash_id": "985c3c7da4ee70a3cf3f1c7bfda4a49036b8b73cc26484a4b89313a5e767b425",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/cffrml.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/stddef.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/crc-ccitt.h>\n#include <linux/netdevice.h>\n#include <net/caif/caif_layer.h>\n#include <net/caif/cfpkt.h>\n#include <net/caif/cffrml.h>\n\n#define container_obj(layr) container_of(layr, struct cffrml, layer)\n\nstruct cffrml {\n\tstruct cflayer layer;\n\tbool dofcs;\t\t \n\tint __percpu\t\t*pcpu_refcnt;\n};\n\nstatic int cffrml_receive(struct cflayer *layr, struct cfpkt *pkt);\nstatic int cffrml_transmit(struct cflayer *layr, struct cfpkt *pkt);\nstatic void cffrml_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\n\t\t\t   int phyid);\n\nstatic u32 cffrml_rcv_error;\nstatic u32 cffrml_rcv_checsum_error;\nstruct cflayer *cffrml_create(u16 phyid, bool use_fcs)\n{\n\tstruct cffrml *this = kzalloc(sizeof(struct cffrml), GFP_ATOMIC);\n\tif (!this)\n\t\treturn NULL;\n\tthis->pcpu_refcnt = alloc_percpu(int);\n\tif (this->pcpu_refcnt == NULL) {\n\t\tkfree(this);\n\t\treturn NULL;\n\t}\n\n\tcaif_assert(offsetof(struct cffrml, layer) == 0);\n\n\tthis->layer.receive = cffrml_receive;\n\tthis->layer.transmit = cffrml_transmit;\n\tthis->layer.ctrlcmd = cffrml_ctrlcmd;\n\tsnprintf(this->layer.name, CAIF_LAYER_NAME_SZ, \"frm%d\", phyid);\n\tthis->dofcs = use_fcs;\n\tthis->layer.id = phyid;\n\treturn (struct cflayer *) this;\n}\n\nvoid cffrml_free(struct cflayer *layer)\n{\n\tstruct cffrml *this = container_obj(layer);\n\tfree_percpu(this->pcpu_refcnt);\n\tkfree(layer);\n}\n\nvoid cffrml_set_uplayer(struct cflayer *this, struct cflayer *up)\n{\n\tthis->up = up;\n}\n\nvoid cffrml_set_dnlayer(struct cflayer *this, struct cflayer *dn)\n{\n\tthis->dn = dn;\n}\n\nstatic u16 cffrml_checksum(u16 chks, void *buf, u16 len)\n{\n\t \n\treturn crc_ccitt(chks, buf, len);\n}\n\nstatic int cffrml_receive(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tu16 tmp;\n\tu16 len;\n\tu16 hdrchks;\n\tint pktchks;\n\tstruct cffrml *this;\n\tthis = container_obj(layr);\n\n\tcfpkt_extr_head(pkt, &tmp, 2);\n\tlen = le16_to_cpu(tmp);\n\n\t \n\tif (!this->dofcs)\n\t\tlen -= 2;\n\n\tif (cfpkt_setlen(pkt, len) < 0) {\n\t\t++cffrml_rcv_error;\n\t\tpr_err(\"Framing length error (%d)\\n\", len);\n\t\tcfpkt_destroy(pkt);\n\t\treturn -EPROTO;\n\t}\n\t \n\tif (this->dofcs) {\n\t\tcfpkt_extr_trail(pkt, &tmp, 2);\n\t\thdrchks = le16_to_cpu(tmp);\n\t\tpktchks = cfpkt_iterate(pkt, cffrml_checksum, 0xffff);\n\t\tif (pktchks != hdrchks) {\n\t\t\tcfpkt_add_trail(pkt, &tmp, 2);\n\t\t\t++cffrml_rcv_error;\n\t\t\t++cffrml_rcv_checsum_error;\n\t\t\tpr_info(\"Frame checksum error (0x%x != 0x%x)\\n\",\n\t\t\t\thdrchks, pktchks);\n\t\t\treturn -EILSEQ;\n\t\t}\n\t}\n\tif (cfpkt_erroneous(pkt)) {\n\t\t++cffrml_rcv_error;\n\t\tpr_err(\"Packet is erroneous!\\n\");\n\t\tcfpkt_destroy(pkt);\n\t\treturn -EPROTO;\n\t}\n\n\tif (layr->up == NULL) {\n\t\tpr_err(\"Layr up is missing!\\n\");\n\t\tcfpkt_destroy(pkt);\n\t\treturn -EINVAL;\n\t}\n\n\treturn layr->up->receive(layr->up, pkt);\n}\n\nstatic int cffrml_transmit(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tu16 chks;\n\tu16 len;\n\t__le16 data;\n\n\tstruct cffrml *this = container_obj(layr);\n\tif (this->dofcs) {\n\t\tchks = cfpkt_iterate(pkt, cffrml_checksum, 0xffff);\n\t\tdata = cpu_to_le16(chks);\n\t\tcfpkt_add_trail(pkt, &data, 2);\n\t} else {\n\t\tcfpkt_pad_trail(pkt, 2);\n\t}\n\tlen = cfpkt_getlen(pkt);\n\tdata = cpu_to_le16(len);\n\tcfpkt_add_head(pkt, &data, 2);\n\tcfpkt_info(pkt)->hdr_len += 2;\n\tif (cfpkt_erroneous(pkt)) {\n\t\tpr_err(\"Packet is erroneous!\\n\");\n\t\tcfpkt_destroy(pkt);\n\t\treturn -EPROTO;\n\t}\n\n\tif (layr->dn == NULL) {\n\t\tcfpkt_destroy(pkt);\n\t\treturn -ENODEV;\n\n\t}\n\treturn layr->dn->transmit(layr->dn, pkt);\n}\n\nstatic void cffrml_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\n\t\t\t   int phyid)\n{\n\tif (layr->up && layr->up->ctrlcmd)\n\t\tlayr->up->ctrlcmd(layr->up, ctrl, layr->id);\n}\n\nvoid cffrml_put(struct cflayer *layr)\n{\n\tstruct cffrml *this = container_obj(layr);\n\tif (layr != NULL && this->pcpu_refcnt != NULL)\n\t\tthis_cpu_dec(*this->pcpu_refcnt);\n}\n\nvoid cffrml_hold(struct cflayer *layr)\n{\n\tstruct cffrml *this = container_obj(layr);\n\tif (layr != NULL && this->pcpu_refcnt != NULL)\n\t\tthis_cpu_inc(*this->pcpu_refcnt);\n}\n\nint cffrml_refcnt_read(struct cflayer *layr)\n{\n\tint i, refcnt = 0;\n\tstruct cffrml *this = container_obj(layr);\n\tfor_each_possible_cpu(i)\n\t\trefcnt += *per_cpu_ptr(this->pcpu_refcnt, i);\n\treturn refcnt;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}