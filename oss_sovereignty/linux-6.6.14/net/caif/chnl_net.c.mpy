{
  "module_name": "chnl_net.c",
  "hash_id": "e3f931c3934b7e9792dbb83addd043ac9b891ecea89453c06a35a6fafad5b90a",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/chnl_net.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/sockios.h>\n#include <linux/caif/if_caif.h>\n#include <net/rtnetlink.h>\n#include <net/caif/caif_layer.h>\n#include <net/caif/cfpkt.h>\n#include <net/caif/caif_dev.h>\n\n \n#define GPRS_PDP_MTU 1500\n \n#define CONNECT_TIMEOUT (5 * HZ)\n#define CAIF_NET_DEFAULT_QUEUE_LEN 500\n#define UNDEF_CONNID 0xffffffff\n\n \nstatic LIST_HEAD(chnl_net_list);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"caif\");\n\nenum caif_states {\n\tCAIF_CONNECTED\t\t= 1,\n\tCAIF_CONNECTING,\n\tCAIF_DISCONNECTED,\n\tCAIF_SHUTDOWN\n};\n\nstruct chnl_net {\n\tstruct cflayer chnl;\n\tstruct caif_connect_request conn_req;\n\tstruct list_head list_field;\n\tstruct net_device *netdev;\n\tchar name[256];\n\twait_queue_head_t netmgmt_wq;\n\t \n\tbool flowenabled;\n\tenum caif_states state;\n};\n\nstatic int chnl_recv_cb(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tstruct sk_buff *skb;\n\tstruct chnl_net *priv;\n\tint pktlen;\n\tconst u8 *ip_version;\n\tu8 buf;\n\n\tpriv = container_of(layr, struct chnl_net, chnl);\n\n\tskb = (struct sk_buff *) cfpkt_tonative(pkt);\n\n\t \n\tpktlen = skb->len;\n\n\t \n\tskb->dev = priv->netdev;\n\n\t \n\tip_version = skb_header_pointer(skb, 0, 1, &buf);\n\tif (!ip_version) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (*ip_version >> 4) {\n\tcase 4:\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\tbreak;\n\tcase 6:\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tbreak;\n\tdefault:\n\t\tkfree_skb(skb);\n\t\tpriv->netdev->stats.rx_errors++;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (priv->conn_req.protocol == CAIFPROTO_DATAGRAM_LOOP)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\telse\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\tnetif_rx(skb);\n\n\t \n\tpriv->netdev->stats.rx_packets++;\n\tpriv->netdev->stats.rx_bytes += pktlen;\n\n\treturn 0;\n}\n\nstatic int delete_device(struct chnl_net *dev)\n{\n\tASSERT_RTNL();\n\tif (dev->netdev)\n\t\tunregister_netdevice(dev->netdev);\n\treturn 0;\n}\n\nstatic void close_work(struct work_struct *work)\n{\n\tstruct chnl_net *dev = NULL;\n\tstruct list_head *list_node;\n\tstruct list_head *_tmp;\n\n\trtnl_lock();\n\tlist_for_each_safe(list_node, _tmp, &chnl_net_list) {\n\t\tdev = list_entry(list_node, struct chnl_net, list_field);\n\t\tif (dev->state == CAIF_SHUTDOWN)\n\t\t\tdev_close(dev->netdev);\n\t}\n\trtnl_unlock();\n}\nstatic DECLARE_WORK(close_worker, close_work);\n\nstatic void chnl_hold(struct cflayer *lyr)\n{\n\tstruct chnl_net *priv = container_of(lyr, struct chnl_net, chnl);\n\tdev_hold(priv->netdev);\n}\n\nstatic void chnl_put(struct cflayer *lyr)\n{\n\tstruct chnl_net *priv = container_of(lyr, struct chnl_net, chnl);\n\tdev_put(priv->netdev);\n}\n\nstatic void chnl_flowctrl_cb(struct cflayer *layr, enum caif_ctrlcmd flow,\n\t\t\t     int phyid)\n{\n\tstruct chnl_net *priv = container_of(layr, struct chnl_net, chnl);\n\tpr_debug(\"NET flowctrl func called flow: %s\\n\",\n\t\tflow == CAIF_CTRLCMD_FLOW_ON_IND ? \"ON\" :\n\t\tflow == CAIF_CTRLCMD_INIT_RSP ? \"INIT\" :\n\t\tflow == CAIF_CTRLCMD_FLOW_OFF_IND ? \"OFF\" :\n\t\tflow == CAIF_CTRLCMD_DEINIT_RSP ? \"CLOSE/DEINIT\" :\n\t\tflow == CAIF_CTRLCMD_INIT_FAIL_RSP ? \"OPEN_FAIL\" :\n\t\tflow == CAIF_CTRLCMD_REMOTE_SHUTDOWN_IND ?\n\t\t \"REMOTE_SHUTDOWN\" : \"UNKNOWN CTRL COMMAND\");\n\n\n\n\tswitch (flow) {\n\tcase CAIF_CTRLCMD_FLOW_OFF_IND:\n\t\tpriv->flowenabled = false;\n\t\tnetif_stop_queue(priv->netdev);\n\t\tbreak;\n\tcase CAIF_CTRLCMD_DEINIT_RSP:\n\t\tpriv->state = CAIF_DISCONNECTED;\n\t\tbreak;\n\tcase CAIF_CTRLCMD_INIT_FAIL_RSP:\n\t\tpriv->state = CAIF_DISCONNECTED;\n\t\twake_up_interruptible(&priv->netmgmt_wq);\n\t\tbreak;\n\tcase CAIF_CTRLCMD_REMOTE_SHUTDOWN_IND:\n\t\tpriv->state = CAIF_SHUTDOWN;\n\t\tnetif_tx_disable(priv->netdev);\n\t\tschedule_work(&close_worker);\n\t\tbreak;\n\tcase CAIF_CTRLCMD_FLOW_ON_IND:\n\t\tpriv->flowenabled = true;\n\t\tnetif_wake_queue(priv->netdev);\n\t\tbreak;\n\tcase CAIF_CTRLCMD_INIT_RSP:\n\t\tcaif_client_register_refcnt(&priv->chnl, chnl_hold, chnl_put);\n\t\tpriv->state = CAIF_CONNECTED;\n\t\tpriv->flowenabled = true;\n\t\tnetif_wake_queue(priv->netdev);\n\t\twake_up_interruptible(&priv->netmgmt_wq);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic netdev_tx_t chnl_net_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct chnl_net *priv;\n\tstruct cfpkt *pkt = NULL;\n\tint len;\n\tint result = -1;\n\t \n\tpriv = netdev_priv(dev);\n\n\tif (skb->len > priv->netdev->mtu) {\n\t\tpr_warn(\"Size of skb exceeded MTU\\n\");\n\t\tkfree_skb(skb);\n\t\tdev->stats.tx_errors++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (!priv->flowenabled) {\n\t\tpr_debug(\"dropping packets flow off\\n\");\n\t\tkfree_skb(skb);\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (priv->conn_req.protocol == CAIFPROTO_DATAGRAM_LOOP)\n\t\tswap(ip_hdr(skb)->saddr, ip_hdr(skb)->daddr);\n\n\t \n\tlen = skb->len;\n\n\tpkt = cfpkt_fromnative(CAIF_DIR_OUT, (void *) skb);\n\n\t \n\tresult = priv->chnl.dn->transmit(priv->chnl.dn, pkt);\n\tif (result) {\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += len;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int chnl_net_open(struct net_device *dev)\n{\n\tstruct chnl_net *priv = NULL;\n\tint result = -1;\n\tint llifindex, headroom, tailroom, mtu;\n\tstruct net_device *lldev;\n\tASSERT_RTNL();\n\tpriv = netdev_priv(dev);\n\tif (!priv) {\n\t\tpr_debug(\"chnl_net_open: no priv\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (priv->state != CAIF_CONNECTING) {\n\t\tpriv->state = CAIF_CONNECTING;\n\t\tresult = caif_connect_client(dev_net(dev), &priv->conn_req,\n\t\t\t\t\t\t&priv->chnl, &llifindex,\n\t\t\t\t\t\t&headroom, &tailroom);\n\t\tif (result != 0) {\n\t\t\t\tpr_debug(\"err: \"\n\t\t\t\t\t \"Unable to register and open device,\"\n\t\t\t\t\t \" Err:%d\\n\",\n\t\t\t\t\t result);\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tlldev = __dev_get_by_index(dev_net(dev), llifindex);\n\n\t\tif (lldev == NULL) {\n\t\t\tpr_debug(\"no interface?\\n\");\n\t\t\tresult = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\n\t\tdev->needed_tailroom = tailroom + lldev->needed_tailroom;\n\t\tdev->hard_header_len = headroom + lldev->hard_header_len +\n\t\t\tlldev->needed_tailroom;\n\n\t\t \n\t\tmtu = min_t(int, dev->mtu, lldev->mtu - (headroom + tailroom));\n\t\tmtu = min_t(int, GPRS_PDP_MTU, mtu);\n\t\tdev_set_mtu(dev, mtu);\n\n\t\tif (mtu < 100) {\n\t\t\tpr_warn(\"CAIF Interface MTU too small (%d)\\n\", mtu);\n\t\t\tresult = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trtnl_unlock();   \n\n\tresult = wait_event_interruptible_timeout(priv->netmgmt_wq,\n\t\t\t\t\t\tpriv->state != CAIF_CONNECTING,\n\t\t\t\t\t\tCONNECT_TIMEOUT);\n\n\trtnl_lock();\n\n\tif (result == -ERESTARTSYS) {\n\t\tpr_debug(\"wait_event_interruptible woken by a signal\\n\");\n\t\tresult = -ERESTARTSYS;\n\t\tgoto error;\n\t}\n\n\tif (result == 0) {\n\t\tpr_debug(\"connect timeout\\n\");\n\t\tresult = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\tif (priv->state != CAIF_CONNECTED) {\n\t\tpr_debug(\"connect failed\\n\");\n\t\tresult = -ECONNREFUSED;\n\t\tgoto error;\n\t}\n\tpr_debug(\"CAIF Netdevice connected\\n\");\n\treturn 0;\n\nerror:\n\tcaif_disconnect_client(dev_net(dev), &priv->chnl);\n\tpriv->state = CAIF_DISCONNECTED;\n\tpr_debug(\"state disconnected\\n\");\n\treturn result;\n\n}\n\nstatic int chnl_net_stop(struct net_device *dev)\n{\n\tstruct chnl_net *priv;\n\n\tASSERT_RTNL();\n\tpriv = netdev_priv(dev);\n\tpriv->state = CAIF_DISCONNECTED;\n\tcaif_disconnect_client(dev_net(dev), &priv->chnl);\n\treturn 0;\n}\n\nstatic int chnl_net_init(struct net_device *dev)\n{\n\tstruct chnl_net *priv;\n\tASSERT_RTNL();\n\tpriv = netdev_priv(dev);\n\tstrncpy(priv->name, dev->name, sizeof(priv->name));\n\tINIT_LIST_HEAD(&priv->list_field);\n\treturn 0;\n}\n\nstatic void chnl_net_uninit(struct net_device *dev)\n{\n\tstruct chnl_net *priv;\n\tASSERT_RTNL();\n\tpriv = netdev_priv(dev);\n\tlist_del_init(&priv->list_field);\n}\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open = chnl_net_open,\n\t.ndo_stop = chnl_net_stop,\n\t.ndo_init = chnl_net_init,\n\t.ndo_uninit = chnl_net_uninit,\n\t.ndo_start_xmit = chnl_net_start_xmit,\n};\n\nstatic void chnl_net_destructor(struct net_device *dev)\n{\n\tstruct chnl_net *priv = netdev_priv(dev);\n\tcaif_free_client(&priv->chnl);\n}\n\nstatic void ipcaif_net_setup(struct net_device *dev)\n{\n\tstruct chnl_net *priv;\n\tdev->netdev_ops = &netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = chnl_net_destructor;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags |= IFF_POINTOPOINT;\n\tdev->mtu = GPRS_PDP_MTU;\n\tdev->tx_queue_len = CAIF_NET_DEFAULT_QUEUE_LEN;\n\n\tpriv = netdev_priv(dev);\n\tpriv->chnl.receive = chnl_recv_cb;\n\tpriv->chnl.ctrlcmd = chnl_flowctrl_cb;\n\tpriv->netdev = dev;\n\tpriv->conn_req.protocol = CAIFPROTO_DATAGRAM;\n\tpriv->conn_req.link_selector = CAIF_LINK_HIGH_BANDW;\n\tpriv->conn_req.priority = CAIF_PRIO_LOW;\n\t \n\tpriv->conn_req.sockaddr.u.dgm.connection_id = UNDEF_CONNID;\n\tpriv->flowenabled = false;\n\n\tinit_waitqueue_head(&priv->netmgmt_wq);\n}\n\n\nstatic int ipcaif_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct chnl_net *priv;\n\tu8 loop;\n\tpriv = netdev_priv(dev);\n\tif (nla_put_u32(skb, IFLA_CAIF_IPV4_CONNID,\n\t\t\tpriv->conn_req.sockaddr.u.dgm.connection_id) ||\n\t    nla_put_u32(skb, IFLA_CAIF_IPV6_CONNID,\n\t\t\tpriv->conn_req.sockaddr.u.dgm.connection_id))\n\t\tgoto nla_put_failure;\n\tloop = priv->conn_req.protocol == CAIFPROTO_DATAGRAM_LOOP;\n\tif (nla_put_u8(skb, IFLA_CAIF_LOOPBACK, loop))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n\n}\n\nstatic void caif_netlink_parms(struct nlattr *data[],\n\t\t\t       struct caif_connect_request *conn_req)\n{\n\tif (!data) {\n\t\tpr_warn(\"no params data found\\n\");\n\t\treturn;\n\t}\n\tif (data[IFLA_CAIF_IPV4_CONNID])\n\t\tconn_req->sockaddr.u.dgm.connection_id =\n\t\t\tnla_get_u32(data[IFLA_CAIF_IPV4_CONNID]);\n\tif (data[IFLA_CAIF_IPV6_CONNID])\n\t\tconn_req->sockaddr.u.dgm.connection_id =\n\t\t\tnla_get_u32(data[IFLA_CAIF_IPV6_CONNID]);\n\tif (data[IFLA_CAIF_LOOPBACK]) {\n\t\tif (nla_get_u8(data[IFLA_CAIF_LOOPBACK]))\n\t\t\tconn_req->protocol = CAIFPROTO_DATAGRAM_LOOP;\n\t\telse\n\t\t\tconn_req->protocol = CAIFPROTO_DATAGRAM;\n\t}\n}\n\nstatic int ipcaif_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t  struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tint ret;\n\tstruct chnl_net *caifdev;\n\tASSERT_RTNL();\n\tcaifdev = netdev_priv(dev);\n\tcaif_netlink_parms(data, &caifdev->conn_req);\n\n\tret = register_netdevice(dev);\n\tif (ret)\n\t\tpr_warn(\"device rtml registration failed\\n\");\n\telse\n\t\tlist_add(&caifdev->list_field, &chnl_net_list);\n\n\t \n\tif (caifdev->conn_req.sockaddr.u.dgm.connection_id == UNDEF_CONNID) {\n\t\tcaifdev->conn_req.sockaddr.u.dgm.connection_id = dev->ifindex;\n\t\tcaifdev->conn_req.protocol = CAIFPROTO_DATAGRAM_LOOP;\n\t}\n\treturn ret;\n}\n\nstatic int ipcaif_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t     struct nlattr *data[],\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct chnl_net *caifdev;\n\tASSERT_RTNL();\n\tcaifdev = netdev_priv(dev);\n\tcaif_netlink_parms(data, &caifdev->conn_req);\n\tnetdev_state_change(dev);\n\treturn 0;\n}\n\nstatic size_t ipcaif_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t0;\n}\n\nstatic const struct nla_policy ipcaif_policy[IFLA_CAIF_MAX + 1] = {\n\t[IFLA_CAIF_IPV4_CONNID]\t      = { .type = NLA_U32 },\n\t[IFLA_CAIF_IPV6_CONNID]\t      = { .type = NLA_U32 },\n\t[IFLA_CAIF_LOOPBACK]\t      = { .type = NLA_U8 }\n};\n\n\nstatic struct rtnl_link_ops ipcaif_link_ops __read_mostly = {\n\t.kind\t\t= \"caif\",\n\t.priv_size\t= sizeof(struct chnl_net),\n\t.setup\t\t= ipcaif_net_setup,\n\t.maxtype\t= IFLA_CAIF_MAX,\n\t.policy\t\t= ipcaif_policy,\n\t.newlink\t= ipcaif_newlink,\n\t.changelink\t= ipcaif_changelink,\n\t.get_size\t= ipcaif_get_size,\n\t.fill_info\t= ipcaif_fill_info,\n\n};\n\nstatic int __init chnl_init_module(void)\n{\n\treturn rtnl_link_register(&ipcaif_link_ops);\n}\n\nstatic void __exit chnl_exit_module(void)\n{\n\tstruct chnl_net *dev = NULL;\n\tstruct list_head *list_node;\n\tstruct list_head *_tmp;\n\trtnl_link_unregister(&ipcaif_link_ops);\n\trtnl_lock();\n\tlist_for_each_safe(list_node, _tmp, &chnl_net_list) {\n\t\tdev = list_entry(list_node, struct chnl_net, list_field);\n\t\tlist_del_init(list_node);\n\t\tdelete_device(dev);\n\t}\n\trtnl_unlock();\n}\n\nmodule_init(chnl_init_module);\nmodule_exit(chnl_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}