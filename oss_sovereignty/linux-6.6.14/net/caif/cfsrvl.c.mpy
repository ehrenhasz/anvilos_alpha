{
  "module_name": "cfsrvl.c",
  "hash_id": "19868a524c2cb1be993edacd10b61c830664411529f12166830fa89a9e1b4c77",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/cfsrvl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pkt_sched.h>\n#include <net/caif/caif_layer.h>\n#include <net/caif/cfsrvl.h>\n#include <net/caif/cfpkt.h>\n#include <net/caif/caif_dev.h>\n\n#define SRVL_CTRL_PKT_SIZE 1\n#define SRVL_FLOW_OFF 0x81\n#define SRVL_FLOW_ON  0x80\n#define SRVL_SET_PIN  0x82\n\n#define container_obj(layr) container_of(layr, struct cfsrvl, layer)\n\nstatic void cfservl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\n\t\t\t    int phyid)\n{\n\tstruct cfsrvl *service = container_obj(layr);\n\n\tif (layr->up == NULL || layr->up->ctrlcmd == NULL)\n\t\treturn;\n\n\tswitch (ctrl) {\n\tcase CAIF_CTRLCMD_INIT_RSP:\n\t\tservice->open = true;\n\t\tlayr->up->ctrlcmd(layr->up, ctrl, phyid);\n\t\tbreak;\n\tcase CAIF_CTRLCMD_DEINIT_RSP:\n\tcase CAIF_CTRLCMD_INIT_FAIL_RSP:\n\t\tservice->open = false;\n\t\tlayr->up->ctrlcmd(layr->up, ctrl, phyid);\n\t\tbreak;\n\tcase _CAIF_CTRLCMD_PHYIF_FLOW_OFF_IND:\n\t\tif (phyid != service->dev_info.id)\n\t\t\tbreak;\n\t\tif (service->modem_flow_on)\n\t\t\tlayr->up->ctrlcmd(layr->up,\n\t\t\t\t\t  CAIF_CTRLCMD_FLOW_OFF_IND, phyid);\n\t\tservice->phy_flow_on = false;\n\t\tbreak;\n\tcase _CAIF_CTRLCMD_PHYIF_FLOW_ON_IND:\n\t\tif (phyid != service->dev_info.id)\n\t\t\treturn;\n\t\tif (service->modem_flow_on) {\n\t\t\tlayr->up->ctrlcmd(layr->up,\n\t\t\t\t\t   CAIF_CTRLCMD_FLOW_ON_IND,\n\t\t\t\t\t   phyid);\n\t\t}\n\t\tservice->phy_flow_on = true;\n\t\tbreak;\n\tcase CAIF_CTRLCMD_FLOW_OFF_IND:\n\t\tif (service->phy_flow_on) {\n\t\t\tlayr->up->ctrlcmd(layr->up,\n\t\t\t\t\t  CAIF_CTRLCMD_FLOW_OFF_IND, phyid);\n\t\t}\n\t\tservice->modem_flow_on = false;\n\t\tbreak;\n\tcase CAIF_CTRLCMD_FLOW_ON_IND:\n\t\tif (service->phy_flow_on) {\n\t\t\tlayr->up->ctrlcmd(layr->up,\n\t\t\t\t\t  CAIF_CTRLCMD_FLOW_ON_IND, phyid);\n\t\t}\n\t\tservice->modem_flow_on = true;\n\t\tbreak;\n\tcase _CAIF_CTRLCMD_PHYIF_DOWN_IND:\n\t\t \n\t\tlayr->up->ctrlcmd(layr->up,\n\t\t\t\tCAIF_CTRLCMD_REMOTE_SHUTDOWN_IND, phyid);\n\t\tbreak;\n\tcase CAIF_CTRLCMD_REMOTE_SHUTDOWN_IND:\n\t\tlayr->up->ctrlcmd(layr->up, ctrl, phyid);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unexpected ctrl in cfsrvl (%d)\\n\", ctrl);\n\t\t \n\t\tlayr->up->ctrlcmd(layr->up, ctrl, phyid);\n\t\tservice->phy_flow_on = true;\n\t\tbreak;\n\t}\n}\n\nstatic int cfservl_modemcmd(struct cflayer *layr, enum caif_modemcmd ctrl)\n{\n\tstruct cfsrvl *service = container_obj(layr);\n\n\tcaif_assert(layr != NULL);\n\tcaif_assert(layr->dn != NULL);\n\tcaif_assert(layr->dn->transmit != NULL);\n\n\tif (!service->supports_flowctrl)\n\t\treturn 0;\n\n\tswitch (ctrl) {\n\tcase CAIF_MODEMCMD_FLOW_ON_REQ:\n\t\t{\n\t\t\tstruct cfpkt *pkt;\n\t\t\tstruct caif_payload_info *info;\n\t\t\tu8 flow_on = SRVL_FLOW_ON;\n\t\t\tpkt = cfpkt_create(SRVL_CTRL_PKT_SIZE);\n\t\t\tif (!pkt)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (cfpkt_add_head(pkt, &flow_on, 1) < 0) {\n\t\t\t\tpr_err(\"Packet is erroneous!\\n\");\n\t\t\t\tcfpkt_destroy(pkt);\n\t\t\t\treturn -EPROTO;\n\t\t\t}\n\t\t\tinfo = cfpkt_info(pkt);\n\t\t\tinfo->channel_id = service->layer.id;\n\t\t\tinfo->hdr_len = 1;\n\t\t\tinfo->dev_info = &service->dev_info;\n\t\t\tcfpkt_set_prio(pkt, TC_PRIO_CONTROL);\n\t\t\treturn layr->dn->transmit(layr->dn, pkt);\n\t\t}\n\tcase CAIF_MODEMCMD_FLOW_OFF_REQ:\n\t\t{\n\t\t\tstruct cfpkt *pkt;\n\t\t\tstruct caif_payload_info *info;\n\t\t\tu8 flow_off = SRVL_FLOW_OFF;\n\t\t\tpkt = cfpkt_create(SRVL_CTRL_PKT_SIZE);\n\t\t\tif (!pkt)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (cfpkt_add_head(pkt, &flow_off, 1) < 0) {\n\t\t\t\tpr_err(\"Packet is erroneous!\\n\");\n\t\t\t\tcfpkt_destroy(pkt);\n\t\t\t\treturn -EPROTO;\n\t\t\t}\n\t\t\tinfo = cfpkt_info(pkt);\n\t\t\tinfo->channel_id = service->layer.id;\n\t\t\tinfo->hdr_len = 1;\n\t\t\tinfo->dev_info = &service->dev_info;\n\t\t\tcfpkt_set_prio(pkt, TC_PRIO_CONTROL);\n\t\t\treturn layr->dn->transmit(layr->dn, pkt);\n\t\t}\n\tdefault:\n\t  break;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void cfsrvl_release(struct cflayer *layer)\n{\n\tstruct cfsrvl *service = container_of(layer, struct cfsrvl, layer);\n\tkfree(service);\n}\n\nvoid cfsrvl_init(struct cfsrvl *service,\n\t\t u8 channel_id,\n\t\t struct dev_info *dev_info,\n\t\t bool supports_flowctrl)\n{\n\tcaif_assert(offsetof(struct cfsrvl, layer) == 0);\n\tservice->open = false;\n\tservice->modem_flow_on = true;\n\tservice->phy_flow_on = true;\n\tservice->layer.id = channel_id;\n\tservice->layer.ctrlcmd = cfservl_ctrlcmd;\n\tservice->layer.modemcmd = cfservl_modemcmd;\n\tservice->dev_info = *dev_info;\n\tservice->supports_flowctrl = supports_flowctrl;\n\tservice->release = cfsrvl_release;\n}\n\nbool cfsrvl_ready(struct cfsrvl *service, int *err)\n{\n\tif (!service->open) {\n\t\t*err = -ENOTCONN;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nu8 cfsrvl_getphyid(struct cflayer *layer)\n{\n\tstruct cfsrvl *servl = container_obj(layer);\n\treturn servl->dev_info.id;\n}\n\nbool cfsrvl_phyid_match(struct cflayer *layer, int phyid)\n{\n\tstruct cfsrvl *servl = container_obj(layer);\n\treturn servl->dev_info.id == phyid;\n}\n\nvoid caif_free_client(struct cflayer *adap_layer)\n{\n\tstruct cfsrvl *servl;\n\tif (adap_layer == NULL || adap_layer->dn == NULL)\n\t\treturn;\n\tservl = container_obj(adap_layer->dn);\n\tservl->release(&servl->layer);\n}\nEXPORT_SYMBOL(caif_free_client);\n\nvoid caif_client_register_refcnt(struct cflayer *adapt_layer,\n\t\t\t\t void (*hold)(struct cflayer *lyr),\n\t\t\t\t void (*put)(struct cflayer *lyr))\n{\n\tstruct cfsrvl *service;\n\n\tif (WARN_ON(adapt_layer == NULL || adapt_layer->dn == NULL))\n\t\treturn;\n\tservice = container_of(adapt_layer->dn, struct cfsrvl, layer);\n\tservice->hold = hold;\n\tservice->put = put;\n}\nEXPORT_SYMBOL(caif_client_register_refcnt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}