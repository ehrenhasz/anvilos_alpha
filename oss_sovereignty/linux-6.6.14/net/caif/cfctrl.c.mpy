{
  "module_name": "cfctrl.c",
  "hash_id": "4cf2d101fb2aa7f974f847d015a3b11f219cb091a35778cf3a6091c11fecb8bb",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/cfctrl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/stddef.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pkt_sched.h>\n#include <net/caif/caif_layer.h>\n#include <net/caif/cfpkt.h>\n#include <net/caif/cfctrl.h>\n\n#define container_obj(layr) container_of(layr, struct cfctrl, serv.layer)\n#define UTILITY_NAME_LENGTH 16\n#define CFPKT_CTRL_PKT_LEN 20\n\n#ifdef CAIF_NO_LOOP\nstatic int handle_loop(struct cfctrl *ctrl,\n\t\t       int cmd, struct cfpkt *pkt){\n\treturn -1;\n}\n#else\nstatic int handle_loop(struct cfctrl *ctrl,\n\t\t       int cmd, struct cfpkt *pkt);\n#endif\nstatic int cfctrl_recv(struct cflayer *layr, struct cfpkt *pkt);\nstatic void cfctrl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\n\t\t\t   int phyid);\n\n\nstruct cflayer *cfctrl_create(void)\n{\n\tstruct dev_info dev_info;\n\tstruct cfctrl *this =\n\t\tkzalloc(sizeof(struct cfctrl), GFP_ATOMIC);\n\tif (!this)\n\t\treturn NULL;\n\tcaif_assert(offsetof(struct cfctrl, serv.layer) == 0);\n\tmemset(&dev_info, 0, sizeof(dev_info));\n\tdev_info.id = 0xff;\n\tcfsrvl_init(&this->serv, 0, &dev_info, false);\n\tatomic_set(&this->req_seq_no, 1);\n\tatomic_set(&this->rsp_seq_no, 1);\n\tthis->serv.layer.receive = cfctrl_recv;\n\tsprintf(this->serv.layer.name, \"ctrl\");\n\tthis->serv.layer.ctrlcmd = cfctrl_ctrlcmd;\n#ifndef CAIF_NO_LOOP\n\tspin_lock_init(&this->loop_linkid_lock);\n\tthis->loop_linkid = 1;\n#endif\n\tspin_lock_init(&this->info_list_lock);\n\tINIT_LIST_HEAD(&this->list);\n\treturn &this->serv.layer;\n}\n\nvoid cfctrl_remove(struct cflayer *layer)\n{\n\tstruct cfctrl_request_info *p, *tmp;\n\tstruct cfctrl *ctrl = container_obj(layer);\n\n\tspin_lock_bh(&ctrl->info_list_lock);\n\tlist_for_each_entry_safe(p, tmp, &ctrl->list, list) {\n\t\tlist_del(&p->list);\n\t\tkfree(p);\n\t}\n\tspin_unlock_bh(&ctrl->info_list_lock);\n\tkfree(layer);\n}\n\nstatic bool param_eq(const struct cfctrl_link_param *p1,\n\t\t     const struct cfctrl_link_param *p2)\n{\n\tbool eq =\n\t    p1->linktype == p2->linktype &&\n\t    p1->priority == p2->priority &&\n\t    p1->phyid == p2->phyid &&\n\t    p1->endpoint == p2->endpoint && p1->chtype == p2->chtype;\n\n\tif (!eq)\n\t\treturn false;\n\n\tswitch (p1->linktype) {\n\tcase CFCTRL_SRV_VEI:\n\t\treturn true;\n\tcase CFCTRL_SRV_DATAGRAM:\n\t\treturn p1->u.datagram.connid == p2->u.datagram.connid;\n\tcase CFCTRL_SRV_RFM:\n\t\treturn\n\t\t    p1->u.rfm.connid == p2->u.rfm.connid &&\n\t\t    strcmp(p1->u.rfm.volume, p2->u.rfm.volume) == 0;\n\tcase CFCTRL_SRV_UTIL:\n\t\treturn\n\t\t    p1->u.utility.fifosize_kb == p2->u.utility.fifosize_kb\n\t\t    && p1->u.utility.fifosize_bufs ==\n\t\t    p2->u.utility.fifosize_bufs\n\t\t    && strcmp(p1->u.utility.name, p2->u.utility.name) == 0\n\t\t    && p1->u.utility.paramlen == p2->u.utility.paramlen\n\t\t    && memcmp(p1->u.utility.params, p2->u.utility.params,\n\t\t\t      p1->u.utility.paramlen) == 0;\n\n\tcase CFCTRL_SRV_VIDEO:\n\t\treturn p1->u.video.connid == p2->u.video.connid;\n\tcase CFCTRL_SRV_DBG:\n\t\treturn true;\n\tcase CFCTRL_SRV_DECM:\n\t\treturn false;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn false;\n}\n\nstatic bool cfctrl_req_eq(const struct cfctrl_request_info *r1,\n\t\t\t  const struct cfctrl_request_info *r2)\n{\n\tif (r1->cmd != r2->cmd)\n\t\treturn false;\n\tif (r1->cmd == CFCTRL_CMD_LINK_SETUP)\n\t\treturn param_eq(&r1->param, &r2->param);\n\telse\n\t\treturn r1->channel_id == r2->channel_id;\n}\n\n \nstatic void cfctrl_insert_req(struct cfctrl *ctrl,\n\t\t\t      struct cfctrl_request_info *req)\n{\n\tspin_lock_bh(&ctrl->info_list_lock);\n\tatomic_inc(&ctrl->req_seq_no);\n\treq->sequence_no = atomic_read(&ctrl->req_seq_no);\n\tlist_add_tail(&req->list, &ctrl->list);\n\tspin_unlock_bh(&ctrl->info_list_lock);\n}\n\n \nstatic struct cfctrl_request_info *cfctrl_remove_req(struct cfctrl *ctrl,\n\t\t\t\t\t\tstruct cfctrl_request_info *req)\n{\n\tstruct cfctrl_request_info *p, *tmp, *first;\n\n\tfirst = list_first_entry(&ctrl->list, struct cfctrl_request_info, list);\n\n\tlist_for_each_entry_safe(p, tmp, &ctrl->list, list) {\n\t\tif (cfctrl_req_eq(req, p)) {\n\t\t\tif (p != first)\n\t\t\t\tpr_warn(\"Requests are not received in order\\n\");\n\n\t\t\tatomic_set(&ctrl->rsp_seq_no,\n\t\t\t\t\t p->sequence_no);\n\t\t\tlist_del(&p->list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tp = NULL;\nout:\n\treturn p;\n}\n\nstruct cfctrl_rsp *cfctrl_get_respfuncs(struct cflayer *layer)\n{\n\tstruct cfctrl *this = container_obj(layer);\n\treturn &this->res;\n}\n\nstatic void init_info(struct caif_payload_info *info, struct cfctrl *cfctrl)\n{\n\tinfo->hdr_len = 0;\n\tinfo->channel_id = cfctrl->serv.layer.id;\n\tinfo->dev_info = &cfctrl->serv.dev_info;\n}\n\nvoid cfctrl_enum_req(struct cflayer *layer, u8 physlinkid)\n{\n\tstruct cfpkt *pkt;\n\tstruct cfctrl *cfctrl = container_obj(layer);\n\tstruct cflayer *dn = cfctrl->serv.layer.dn;\n\n\tif (!dn) {\n\t\tpr_debug(\"not able to send enum request\\n\");\n\t\treturn;\n\t}\n\tpkt = cfpkt_create(CFPKT_CTRL_PKT_LEN);\n\tif (!pkt)\n\t\treturn;\n\tcaif_assert(offsetof(struct cfctrl, serv.layer) == 0);\n\tinit_info(cfpkt_info(pkt), cfctrl);\n\tcfpkt_info(pkt)->dev_info->id = physlinkid;\n\tcfctrl->serv.dev_info.id = physlinkid;\n\tcfpkt_addbdy(pkt, CFCTRL_CMD_ENUM);\n\tcfpkt_addbdy(pkt, physlinkid);\n\tcfpkt_set_prio(pkt, TC_PRIO_CONTROL);\n\tdn->transmit(dn, pkt);\n}\n\nint cfctrl_linkup_request(struct cflayer *layer,\n\t\t\t  struct cfctrl_link_param *param,\n\t\t\t  struct cflayer *user_layer)\n{\n\tstruct cfctrl *cfctrl = container_obj(layer);\n\tu32 tmp32;\n\tu16 tmp16;\n\tu8 tmp8;\n\tstruct cfctrl_request_info *req;\n\tint ret;\n\tchar utility_name[16];\n\tstruct cfpkt *pkt;\n\tstruct cflayer *dn = cfctrl->serv.layer.dn;\n\n\tif (!dn) {\n\t\tpr_debug(\"not able to send linkup request\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (cfctrl_cancel_req(layer, user_layer) > 0) {\n\t\t \n\t\tpr_err(\"Duplicate connect request for same client\\n\");\n\t\tWARN_ON(1);\n\t\treturn -EALREADY;\n\t}\n\n\tpkt = cfpkt_create(CFPKT_CTRL_PKT_LEN);\n\tif (!pkt)\n\t\treturn -ENOMEM;\n\tcfpkt_addbdy(pkt, CFCTRL_CMD_LINK_SETUP);\n\tcfpkt_addbdy(pkt, (param->chtype << 4) | param->linktype);\n\tcfpkt_addbdy(pkt, (param->priority << 3) | param->phyid);\n\tcfpkt_addbdy(pkt, param->endpoint & 0x03);\n\n\tswitch (param->linktype) {\n\tcase CFCTRL_SRV_VEI:\n\t\tbreak;\n\tcase CFCTRL_SRV_VIDEO:\n\t\tcfpkt_addbdy(pkt, (u8) param->u.video.connid);\n\t\tbreak;\n\tcase CFCTRL_SRV_DBG:\n\t\tbreak;\n\tcase CFCTRL_SRV_DATAGRAM:\n\t\ttmp32 = cpu_to_le32(param->u.datagram.connid);\n\t\tcfpkt_add_body(pkt, &tmp32, 4);\n\t\tbreak;\n\tcase CFCTRL_SRV_RFM:\n\t\t \n\t\ttmp32 = cpu_to_le32(param->u.rfm.connid);\n\t\tcfpkt_add_body(pkt, &tmp32, 4);\n\t\t \n\t\tcfpkt_add_body(pkt, param->u.rfm.volume,\n\t\t\t       strlen(param->u.rfm.volume) + 1);\n\t\tbreak;\n\tcase CFCTRL_SRV_UTIL:\n\t\ttmp16 = cpu_to_le16(param->u.utility.fifosize_kb);\n\t\tcfpkt_add_body(pkt, &tmp16, 2);\n\t\ttmp16 = cpu_to_le16(param->u.utility.fifosize_bufs);\n\t\tcfpkt_add_body(pkt, &tmp16, 2);\n\t\tmemset(utility_name, 0, sizeof(utility_name));\n\t\tstrscpy(utility_name, param->u.utility.name,\n\t\t\tUTILITY_NAME_LENGTH);\n\t\tcfpkt_add_body(pkt, utility_name, UTILITY_NAME_LENGTH);\n\t\ttmp8 = param->u.utility.paramlen;\n\t\tcfpkt_add_body(pkt, &tmp8, 1);\n\t\tcfpkt_add_body(pkt, param->u.utility.params,\n\t\t\t       param->u.utility.paramlen);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Request setup of bad link type = %d\\n\",\n\t\t\tparam->linktype);\n\t\tcfpkt_destroy(pkt);\n\t\treturn -EINVAL;\n\t}\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req) {\n\t\tcfpkt_destroy(pkt);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->client_layer = user_layer;\n\treq->cmd = CFCTRL_CMD_LINK_SETUP;\n\treq->param = *param;\n\tcfctrl_insert_req(cfctrl, req);\n\tinit_info(cfpkt_info(pkt), cfctrl);\n\t \n\tcfpkt_info(pkt)->dev_info->id = param->phyid;\n\tcfpkt_set_prio(pkt, TC_PRIO_CONTROL);\n\tret =\n\t    dn->transmit(dn, pkt);\n\tif (ret < 0) {\n\t\tint count;\n\n\t\tcount = cfctrl_cancel_req(&cfctrl->serv.layer,\n\t\t\t\t\t\tuser_layer);\n\t\tif (count != 1) {\n\t\t\tpr_err(\"Could not remove request (%d)\", count);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint cfctrl_linkdown_req(struct cflayer *layer, u8 channelid,\n\t\t\tstruct cflayer *client)\n{\n\tint ret;\n\tstruct cfpkt *pkt;\n\tstruct cfctrl *cfctrl = container_obj(layer);\n\tstruct cflayer *dn = cfctrl->serv.layer.dn;\n\n\tif (!dn) {\n\t\tpr_debug(\"not able to send link-down request\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpkt = cfpkt_create(CFPKT_CTRL_PKT_LEN);\n\tif (!pkt)\n\t\treturn -ENOMEM;\n\tcfpkt_addbdy(pkt, CFCTRL_CMD_LINK_DESTROY);\n\tcfpkt_addbdy(pkt, channelid);\n\tinit_info(cfpkt_info(pkt), cfctrl);\n\tcfpkt_set_prio(pkt, TC_PRIO_CONTROL);\n\tret =\n\t    dn->transmit(dn, pkt);\n#ifndef CAIF_NO_LOOP\n\tcfctrl->loop_linkused[channelid] = 0;\n#endif\n\treturn ret;\n}\n\nint cfctrl_cancel_req(struct cflayer *layr, struct cflayer *adap_layer)\n{\n\tstruct cfctrl_request_info *p, *tmp;\n\tstruct cfctrl *ctrl = container_obj(layr);\n\tint found = 0;\n\tspin_lock_bh(&ctrl->info_list_lock);\n\n\tlist_for_each_entry_safe(p, tmp, &ctrl->list, list) {\n\t\tif (p->client_layer == adap_layer) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tfound++;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&ctrl->info_list_lock);\n\treturn found;\n}\n\nstatic int cfctrl_recv(struct cflayer *layer, struct cfpkt *pkt)\n{\n\tu8 cmdrsp;\n\tu8 cmd;\n\tint ret = -1;\n\tu8 len;\n\tu8 param[255];\n\tu8 linkid = 0;\n\tstruct cfctrl *cfctrl = container_obj(layer);\n\tstruct cfctrl_request_info rsp, *req;\n\n\n\tcmdrsp = cfpkt_extr_head_u8(pkt);\n\tcmd = cmdrsp & CFCTRL_CMD_MASK;\n\tif (cmd != CFCTRL_CMD_LINK_ERR\n\t    && CFCTRL_RSP_BIT != (CFCTRL_RSP_BIT & cmdrsp)\n\t\t&& CFCTRL_ERR_BIT != (CFCTRL_ERR_BIT & cmdrsp)) {\n\t\tif (handle_loop(cfctrl, cmd, pkt) != 0)\n\t\t\tcmdrsp |= CFCTRL_ERR_BIT;\n\t}\n\n\tswitch (cmd) {\n\tcase CFCTRL_CMD_LINK_SETUP:\n\t\t{\n\t\t\tenum cfctrl_srv serv;\n\t\t\tenum cfctrl_srv servtype;\n\t\t\tu8 endpoint;\n\t\t\tu8 physlinkid;\n\t\t\tu8 prio;\n\t\t\tu8 tmp;\n\t\t\tu8 *cp;\n\t\t\tint i;\n\t\t\tstruct cfctrl_link_param linkparam;\n\t\t\tmemset(&linkparam, 0, sizeof(linkparam));\n\n\t\t\ttmp = cfpkt_extr_head_u8(pkt);\n\n\t\t\tserv = tmp & CFCTRL_SRV_MASK;\n\t\t\tlinkparam.linktype = serv;\n\n\t\t\tservtype = tmp >> 4;\n\t\t\tlinkparam.chtype = servtype;\n\n\t\t\ttmp = cfpkt_extr_head_u8(pkt);\n\t\t\tphyslinkid = tmp & 0x07;\n\t\t\tprio = tmp >> 3;\n\n\t\t\tlinkparam.priority = prio;\n\t\t\tlinkparam.phyid = physlinkid;\n\t\t\tendpoint = cfpkt_extr_head_u8(pkt);\n\t\t\tlinkparam.endpoint = endpoint & 0x03;\n\n\t\t\tswitch (serv) {\n\t\t\tcase CFCTRL_SRV_VEI:\n\t\t\tcase CFCTRL_SRV_DBG:\n\t\t\t\tif (CFCTRL_ERR_BIT & cmdrsp)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tlinkid = cfpkt_extr_head_u8(pkt);\n\t\t\t\tbreak;\n\t\t\tcase CFCTRL_SRV_VIDEO:\n\t\t\t\ttmp = cfpkt_extr_head_u8(pkt);\n\t\t\t\tlinkparam.u.video.connid = tmp;\n\t\t\t\tif (CFCTRL_ERR_BIT & cmdrsp)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tlinkid = cfpkt_extr_head_u8(pkt);\n\t\t\t\tbreak;\n\n\t\t\tcase CFCTRL_SRV_DATAGRAM:\n\t\t\t\tlinkparam.u.datagram.connid =\n\t\t\t\t    cfpkt_extr_head_u32(pkt);\n\t\t\t\tif (CFCTRL_ERR_BIT & cmdrsp)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tlinkid = cfpkt_extr_head_u8(pkt);\n\t\t\t\tbreak;\n\t\t\tcase CFCTRL_SRV_RFM:\n\t\t\t\t \n\t\t\t\tlinkparam.u.rfm.connid =\n\t\t\t\t    cfpkt_extr_head_u32(pkt);\n\t\t\t\tcp = (u8 *) linkparam.u.rfm.volume;\n\t\t\t\tfor (tmp = cfpkt_extr_head_u8(pkt);\n\t\t\t\t     cfpkt_more(pkt) && tmp != '\\0';\n\t\t\t\t     tmp = cfpkt_extr_head_u8(pkt))\n\t\t\t\t\t*cp++ = tmp;\n\t\t\t\t*cp = '\\0';\n\n\t\t\t\tif (CFCTRL_ERR_BIT & cmdrsp)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tlinkid = cfpkt_extr_head_u8(pkt);\n\n\t\t\t\tbreak;\n\t\t\tcase CFCTRL_SRV_UTIL:\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tlinkparam.u.utility.fifosize_kb =\n\t\t\t\t    cfpkt_extr_head_u16(pkt);\n\t\t\t\t \n\t\t\t\tlinkparam.u.utility.fifosize_bufs =\n\t\t\t\t    cfpkt_extr_head_u16(pkt);\n\t\t\t\t \n\t\t\t\tcp = (u8 *) linkparam.u.utility.name;\n\t\t\t\tcaif_assert(sizeof(linkparam.u.utility.name)\n\t\t\t\t\t     >= UTILITY_NAME_LENGTH);\n\t\t\t\tfor (i = 0;\n\t\t\t\t     i < UTILITY_NAME_LENGTH\n\t\t\t\t     && cfpkt_more(pkt); i++) {\n\t\t\t\t\ttmp = cfpkt_extr_head_u8(pkt);\n\t\t\t\t\t*cp++ = tmp;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tlen = cfpkt_extr_head_u8(pkt);\n\t\t\t\tlinkparam.u.utility.paramlen = len;\n\t\t\t\t \n\t\t\t\tcp = linkparam.u.utility.params;\n\t\t\t\twhile (cfpkt_more(pkt) && len--) {\n\t\t\t\t\ttmp = cfpkt_extr_head_u8(pkt);\n\t\t\t\t\t*cp++ = tmp;\n\t\t\t\t}\n\t\t\t\tif (CFCTRL_ERR_BIT & cmdrsp)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tlinkid = cfpkt_extr_head_u8(pkt);\n\t\t\t\t \n\t\t\t\tlen = cfpkt_extr_head_u8(pkt);\n\t\t\t\t \n\t\t\t\tcfpkt_extr_head(pkt, &param, len);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"Request setup, invalid type (%d)\\n\",\n\t\t\t\t\tserv);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\trsp.cmd = cmd;\n\t\t\trsp.param = linkparam;\n\t\t\tspin_lock_bh(&cfctrl->info_list_lock);\n\t\t\treq = cfctrl_remove_req(cfctrl, &rsp);\n\n\t\t\tif (CFCTRL_ERR_BIT == (CFCTRL_ERR_BIT & cmdrsp) ||\n\t\t\t\tcfpkt_erroneous(pkt)) {\n\t\t\t\tpr_err(\"Invalid O/E bit or parse error \"\n\t\t\t\t\t\t\"on CAIF control channel\\n\");\n\t\t\t\tcfctrl->res.reject_rsp(cfctrl->serv.layer.up,\n\t\t\t\t\t\t       0,\n\t\t\t\t\t\t       req ? req->client_layer\n\t\t\t\t\t\t       : NULL);\n\t\t\t} else {\n\t\t\t\tcfctrl->res.linksetup_rsp(cfctrl->serv.\n\t\t\t\t\t\t\t  layer.up, linkid,\n\t\t\t\t\t\t\t  serv, physlinkid,\n\t\t\t\t\t\t\t  req ? req->\n\t\t\t\t\t\t\t  client_layer : NULL);\n\t\t\t}\n\n\t\t\tkfree(req);\n\n\t\t\tspin_unlock_bh(&cfctrl->info_list_lock);\n\t\t}\n\t\tbreak;\n\tcase CFCTRL_CMD_LINK_DESTROY:\n\t\tlinkid = cfpkt_extr_head_u8(pkt);\n\t\tcfctrl->res.linkdestroy_rsp(cfctrl->serv.layer.up, linkid);\n\t\tbreak;\n\tcase CFCTRL_CMD_LINK_ERR:\n\t\tpr_err(\"Frame Error Indication received\\n\");\n\t\tcfctrl->res.linkerror_ind();\n\t\tbreak;\n\tcase CFCTRL_CMD_ENUM:\n\t\tcfctrl->res.enum_rsp();\n\t\tbreak;\n\tcase CFCTRL_CMD_SLEEP:\n\t\tcfctrl->res.sleep_rsp();\n\t\tbreak;\n\tcase CFCTRL_CMD_WAKE:\n\t\tcfctrl->res.wake_rsp();\n\t\tbreak;\n\tcase CFCTRL_CMD_LINK_RECONF:\n\t\tcfctrl->res.restart_rsp();\n\t\tbreak;\n\tcase CFCTRL_CMD_RADIO_SET:\n\t\tcfctrl->res.radioset_rsp();\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unrecognized Control Frame\\n\");\n\t\tgoto error;\n\t}\n\tret = 0;\nerror:\n\tcfpkt_destroy(pkt);\n\treturn ret;\n}\n\nstatic void cfctrl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\n\t\t\t   int phyid)\n{\n\tstruct cfctrl *this = container_obj(layr);\n\tswitch (ctrl) {\n\tcase _CAIF_CTRLCMD_PHYIF_FLOW_OFF_IND:\n\tcase CAIF_CTRLCMD_FLOW_OFF_IND:\n\t\tspin_lock_bh(&this->info_list_lock);\n\t\tif (!list_empty(&this->list))\n\t\t\tpr_debug(\"Received flow off in control layer\\n\");\n\t\tspin_unlock_bh(&this->info_list_lock);\n\t\tbreak;\n\tcase _CAIF_CTRLCMD_PHYIF_DOWN_IND: {\n\t\tstruct cfctrl_request_info *p, *tmp;\n\n\t\t \n\t\tspin_lock_bh(&this->info_list_lock);\n\t\tlist_for_each_entry_safe(p, tmp, &this->list, list) {\n\t\t\tif (p->param.phyid == phyid) {\n\t\t\t\tlist_del(&p->list);\n\t\t\t\tp->client_layer->ctrlcmd(p->client_layer,\n\t\t\t\t\t\tCAIF_CTRLCMD_INIT_FAIL_RSP,\n\t\t\t\t\t\tphyid);\n\t\t\t\tkfree(p);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&this->info_list_lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#ifndef CAIF_NO_LOOP\nstatic int handle_loop(struct cfctrl *ctrl, int cmd, struct cfpkt *pkt)\n{\n\tstatic int last_linkid;\n\tstatic int dec;\n\tu8 linkid, linktype, tmp;\n\tswitch (cmd) {\n\tcase CFCTRL_CMD_LINK_SETUP:\n\t\tspin_lock_bh(&ctrl->loop_linkid_lock);\n\t\tif (!dec) {\n\t\t\tfor (linkid = last_linkid + 1; linkid < 254; linkid++)\n\t\t\t\tif (!ctrl->loop_linkused[linkid])\n\t\t\t\t\tgoto found;\n\t\t}\n\t\tdec = 1;\n\t\tfor (linkid = last_linkid - 1; linkid > 1; linkid--)\n\t\t\tif (!ctrl->loop_linkused[linkid])\n\t\t\t\tgoto found;\n\t\tspin_unlock_bh(&ctrl->loop_linkid_lock);\n\t\treturn -1;\nfound:\n\t\tif (linkid < 10)\n\t\t\tdec = 0;\n\n\t\tif (!ctrl->loop_linkused[linkid])\n\t\t\tctrl->loop_linkused[linkid] = 1;\n\n\t\tlast_linkid = linkid;\n\n\t\tcfpkt_add_trail(pkt, &linkid, 1);\n\t\tspin_unlock_bh(&ctrl->loop_linkid_lock);\n\t\tcfpkt_peek_head(pkt, &linktype, 1);\n\t\tif (linktype ==  CFCTRL_SRV_UTIL) {\n\t\t\ttmp = 0x01;\n\t\t\tcfpkt_add_trail(pkt, &tmp, 1);\n\t\t\tcfpkt_add_trail(pkt, &tmp, 1);\n\t\t}\n\t\tbreak;\n\n\tcase CFCTRL_CMD_LINK_DESTROY:\n\t\tspin_lock_bh(&ctrl->loop_linkid_lock);\n\t\tcfpkt_peek_head(pkt, &linkid, 1);\n\t\tctrl->loop_linkused[linkid] = 0;\n\t\tspin_unlock_bh(&ctrl->loop_linkid_lock);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}