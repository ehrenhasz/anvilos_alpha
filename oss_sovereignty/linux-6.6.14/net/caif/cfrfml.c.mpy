{
  "module_name": "cfrfml.c",
  "hash_id": "a3b1da85a0268fc887846feaa503425584fde07f2bcb48dcfb6f9d460f179a1b",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/cfrfml.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/stddef.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <net/caif/caif_layer.h>\n#include <net/caif/cfsrvl.h>\n#include <net/caif/cfpkt.h>\n\n#define container_obj(layr) container_of(layr, struct cfrfml, serv.layer)\n#define RFM_SEGMENTATION_BIT 0x01\n#define RFM_HEAD_SIZE 7\n\nstatic int cfrfml_receive(struct cflayer *layr, struct cfpkt *pkt);\nstatic int cfrfml_transmit(struct cflayer *layr, struct cfpkt *pkt);\n\nstruct cfrfml {\n\tstruct cfsrvl serv;\n\tstruct cfpkt *incomplete_frm;\n\tint fragment_size;\n\tu8  seghead[6];\n\tu16 pdu_size;\n\t \n\tspinlock_t sync;\n};\n\nstatic void cfrfml_release(struct cflayer *layer)\n{\n\tstruct cfsrvl *srvl = container_of(layer, struct cfsrvl, layer);\n\tstruct cfrfml *rfml = container_obj(&srvl->layer);\n\n\tif (rfml->incomplete_frm)\n\t\tcfpkt_destroy(rfml->incomplete_frm);\n\n\tkfree(srvl);\n}\n\nstruct cflayer *cfrfml_create(u8 channel_id, struct dev_info *dev_info,\n\t\t\t      int mtu_size)\n{\n\tint tmp;\n\tstruct cfrfml *this = kzalloc(sizeof(struct cfrfml), GFP_ATOMIC);\n\n\tif (!this)\n\t\treturn NULL;\n\n\tcfsrvl_init(&this->serv, channel_id, dev_info, false);\n\tthis->serv.release = cfrfml_release;\n\tthis->serv.layer.receive = cfrfml_receive;\n\tthis->serv.layer.transmit = cfrfml_transmit;\n\n\t \n\ttmp = (mtu_size - RFM_HEAD_SIZE - 6) / 16;\n\ttmp *= 16;\n\n\tthis->fragment_size = tmp;\n\tspin_lock_init(&this->sync);\n\tsnprintf(this->serv.layer.name, CAIF_LAYER_NAME_SZ,\n\t\t\"rfm%d\", channel_id);\n\n\treturn &this->serv.layer;\n}\n\nstatic struct cfpkt *rfm_append(struct cfrfml *rfml, char *seghead,\n\t\t\t\tstruct cfpkt *pkt, int *err)\n{\n\tstruct cfpkt *tmppkt;\n\t*err = -EPROTO;\n\t \n\n\tif (cfpkt_extr_head(pkt, seghead, 6) < 0)\n\t\treturn NULL;\n\n\t \n\tif (memcmp(seghead, rfml->seghead, 6) != 0)\n\t\treturn NULL;\n\n\ttmppkt = cfpkt_append(rfml->incomplete_frm, pkt,\n\t\t\trfml->pdu_size + RFM_HEAD_SIZE);\n\n\t \n\t*err = -ENOMEM;\n\tif (tmppkt == NULL)\n\t\treturn NULL;\n\n\t*err = 0;\n\treturn tmppkt;\n}\n\nstatic int cfrfml_receive(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tu8 tmp;\n\tbool segmented;\n\tint err;\n\tu8 seghead[6];\n\tstruct cfrfml *rfml;\n\tstruct cfpkt *tmppkt = NULL;\n\n\tcaif_assert(layr->up != NULL);\n\tcaif_assert(layr->receive != NULL);\n\trfml = container_obj(layr);\n\tspin_lock(&rfml->sync);\n\n\terr = -EPROTO;\n\tif (cfpkt_extr_head(pkt, &tmp, 1) < 0)\n\t\tgoto out;\n\tsegmented = tmp & RFM_SEGMENTATION_BIT;\n\n\tif (segmented) {\n\t\tif (rfml->incomplete_frm == NULL) {\n\t\t\t \n\t\t\tif (cfpkt_peek_head(pkt, rfml->seghead, 6) != 0)\n\t\t\t\tgoto out;\n\n\t\t\trfml->pdu_size = get_unaligned_le16(rfml->seghead+4);\n\n\t\t\tif (cfpkt_erroneous(pkt))\n\t\t\t\tgoto out;\n\t\t\trfml->incomplete_frm = pkt;\n\t\t\tpkt = NULL;\n\t\t} else {\n\n\t\t\ttmppkt = rfm_append(rfml, seghead, pkt, &err);\n\t\t\tif (tmppkt == NULL)\n\t\t\t\tgoto out;\n\n\t\t\tif (cfpkt_erroneous(tmppkt))\n\t\t\t\tgoto out;\n\n\t\t\trfml->incomplete_frm = tmppkt;\n\n\n\t\t\tif (cfpkt_erroneous(tmppkt))\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (rfml->incomplete_frm) {\n\n\t\t \n\t\ttmppkt = rfm_append(rfml, seghead, pkt, &err);\n\t\tif (tmppkt == NULL)\n\t\t\tgoto out;\n\n\t\tif (cfpkt_erroneous(tmppkt))\n\t\t\tgoto out;\n\n\t\trfml->incomplete_frm = NULL;\n\t\tpkt = tmppkt;\n\t\ttmppkt = NULL;\n\n\t\t \n\t\terr = -EPROTO;\n\t\tif (rfml->pdu_size != cfpkt_getlen(pkt) - RFM_HEAD_SIZE + 1)\n\t\t\tgoto out;\n\t}\n\n\terr = rfml->serv.layer.up->receive(rfml->serv.layer.up, pkt);\n\nout:\n\n\tif (err != 0) {\n\t\tif (tmppkt)\n\t\t\tcfpkt_destroy(tmppkt);\n\t\tif (pkt)\n\t\t\tcfpkt_destroy(pkt);\n\t\tif (rfml->incomplete_frm)\n\t\t\tcfpkt_destroy(rfml->incomplete_frm);\n\t\trfml->incomplete_frm = NULL;\n\n\t\tpr_info(\"Connection error %d triggered on RFM link\\n\", err);\n\n\t\t \n\t\tlayr->up->ctrlcmd(layr->up, CAIF_CTRLCMD_REMOTE_SHUTDOWN_IND,\n\t\t\t\t\trfml->serv.dev_info.id);\n\t}\n\tspin_unlock(&rfml->sync);\n\n\tif (unlikely(err == -EAGAIN))\n\t\t \n\t\terr = -EIO;\n\n\treturn err;\n}\n\n\nstatic int cfrfml_transmit_segment(struct cfrfml *rfml, struct cfpkt *pkt)\n{\n\tcaif_assert(cfpkt_getlen(pkt) < rfml->fragment_size + RFM_HEAD_SIZE);\n\n\t \n\tcfpkt_info(pkt)->channel_id = rfml->serv.layer.id;\n\n\t \n\tcfpkt_info(pkt)->hdr_len = RFM_HEAD_SIZE;\n\tcfpkt_info(pkt)->dev_info = &rfml->serv.dev_info;\n\n\treturn rfml->serv.layer.dn->transmit(rfml->serv.layer.dn, pkt);\n}\n\nstatic int cfrfml_transmit(struct cflayer *layr, struct cfpkt *pkt)\n{\n\tint err;\n\tu8 seg;\n\tu8 head[6];\n\tstruct cfpkt *rearpkt = NULL;\n\tstruct cfpkt *frontpkt = pkt;\n\tstruct cfrfml *rfml = container_obj(layr);\n\n\tcaif_assert(layr->dn != NULL);\n\tcaif_assert(layr->dn->transmit != NULL);\n\n\tif (!cfsrvl_ready(&rfml->serv, &err))\n\t\tgoto out;\n\n\terr = -EPROTO;\n\tif (cfpkt_getlen(pkt) <= RFM_HEAD_SIZE-1)\n\t\tgoto out;\n\n\terr = 0;\n\tif (cfpkt_getlen(pkt) > rfml->fragment_size + RFM_HEAD_SIZE)\n\t\terr = cfpkt_peek_head(pkt, head, 6);\n\n\tif (err != 0)\n\t\tgoto out;\n\n\twhile (cfpkt_getlen(frontpkt) > rfml->fragment_size + RFM_HEAD_SIZE) {\n\n\t\tseg = 1;\n\t\terr = -EPROTO;\n\n\t\tif (cfpkt_add_head(frontpkt, &seg, 1) < 0)\n\t\t\tgoto out;\n\t\t \n\n\t\trearpkt = cfpkt_split(frontpkt, rfml->fragment_size);\n\t\tif (rearpkt == NULL)\n\t\t\tgoto out;\n\n\t\terr = cfrfml_transmit_segment(rfml, frontpkt);\n\n\t\tif (err != 0) {\n\t\t\tfrontpkt = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfrontpkt = rearpkt;\n\t\trearpkt = NULL;\n\n\t\terr = -EPROTO;\n\t\tif (cfpkt_add_head(frontpkt, head, 6) < 0)\n\t\t\tgoto out;\n\n\t}\n\n\tseg = 0;\n\terr = -EPROTO;\n\n\tif (cfpkt_add_head(frontpkt, &seg, 1) < 0)\n\t\tgoto out;\n\n\terr = cfrfml_transmit_segment(rfml, frontpkt);\n\n\tfrontpkt = NULL;\nout:\n\n\tif (err != 0) {\n\t\tpr_info(\"Connection error %d triggered on RFM link\\n\", err);\n\t\t \n\n\t\tlayr->up->ctrlcmd(layr->up, CAIF_CTRLCMD_REMOTE_SHUTDOWN_IND,\n\t\t\t\t\trfml->serv.dev_info.id);\n\n\t\tif (rearpkt)\n\t\t\tcfpkt_destroy(rearpkt);\n\n\t\tif (frontpkt)\n\t\t\tcfpkt_destroy(frontpkt);\n\t}\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}