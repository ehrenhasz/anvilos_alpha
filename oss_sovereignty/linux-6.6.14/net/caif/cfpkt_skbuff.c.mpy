{
  "module_name": "cfpkt_skbuff.c",
  "hash_id": "4b36e2219ce11c078bc5e139a18190aa877a21281cfac26eb9937da28005d0fb",
  "original_prompt": "Ingested from linux-6.6.14/net/caif/cfpkt_skbuff.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s(): \" fmt, __func__\n\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <net/caif/cfpkt.h>\n\n#define PKT_PREFIX  48\n#define PKT_POSTFIX 2\n#define PKT_LEN_WHEN_EXTENDING 128\n#define PKT_ERROR(pkt, errmsg)\t\t   \\\ndo {\t\t\t\t\t   \\\n\tcfpkt_priv(pkt)->erronous = true;  \\\n\tskb_reset_tail_pointer(&pkt->skb); \\\n\tpr_warn(errmsg);\t\t   \\\n} while (0)\n\nstruct cfpktq {\n\tstruct sk_buff_head head;\n\tatomic_t count;\n\t \n\tspinlock_t lock;\n};\n\n \nstruct cfpkt {\n\tstruct sk_buff skb;\n};\n\n \nstruct cfpkt_priv_data {\n\tstruct dev_info dev_info;\n\tbool erronous;\n};\n\nstatic inline struct cfpkt_priv_data *cfpkt_priv(struct cfpkt *pkt)\n{\n\treturn (struct cfpkt_priv_data *) pkt->skb.cb;\n}\n\nstatic inline bool is_erronous(struct cfpkt *pkt)\n{\n\treturn cfpkt_priv(pkt)->erronous;\n}\n\nstatic inline struct sk_buff *pkt_to_skb(struct cfpkt *pkt)\n{\n\treturn &pkt->skb;\n}\n\nstatic inline struct cfpkt *skb_to_pkt(struct sk_buff *skb)\n{\n\treturn (struct cfpkt *) skb;\n}\n\nstruct cfpkt *cfpkt_fromnative(enum caif_direction dir, void *nativepkt)\n{\n\tstruct cfpkt *pkt = skb_to_pkt(nativepkt);\n\tcfpkt_priv(pkt)->erronous = false;\n\treturn pkt;\n}\nEXPORT_SYMBOL(cfpkt_fromnative);\n\nvoid *cfpkt_tonative(struct cfpkt *pkt)\n{\n\treturn (void *) pkt;\n}\nEXPORT_SYMBOL(cfpkt_tonative);\n\nstatic struct cfpkt *cfpkt_create_pfx(u16 len, u16 pfx)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(len + pfx, GFP_ATOMIC);\n\tif (unlikely(skb == NULL))\n\t\treturn NULL;\n\n\tskb_reserve(skb, pfx);\n\treturn skb_to_pkt(skb);\n}\n\ninline struct cfpkt *cfpkt_create(u16 len)\n{\n\treturn cfpkt_create_pfx(len + PKT_POSTFIX, PKT_PREFIX);\n}\n\nvoid cfpkt_destroy(struct cfpkt *pkt)\n{\n\tstruct sk_buff *skb = pkt_to_skb(pkt);\n\tkfree_skb(skb);\n}\n\ninline bool cfpkt_more(struct cfpkt *pkt)\n{\n\tstruct sk_buff *skb = pkt_to_skb(pkt);\n\treturn skb->len > 0;\n}\n\nint cfpkt_peek_head(struct cfpkt *pkt, void *data, u16 len)\n{\n\tstruct sk_buff *skb = pkt_to_skb(pkt);\n\tif (skb_headlen(skb) >= len) {\n\t\tmemcpy(data, skb->data, len);\n\t\treturn 0;\n\t}\n\treturn !cfpkt_extr_head(pkt, data, len) &&\n\t    !cfpkt_add_head(pkt, data, len);\n}\n\nint cfpkt_extr_head(struct cfpkt *pkt, void *data, u16 len)\n{\n\tstruct sk_buff *skb = pkt_to_skb(pkt);\n\tu8 *from;\n\tif (unlikely(is_erronous(pkt)))\n\t\treturn -EPROTO;\n\n\tif (unlikely(len > skb->len)) {\n\t\tPKT_ERROR(pkt, \"read beyond end of packet\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\tif (unlikely(len > skb_headlen(skb))) {\n\t\tif (unlikely(skb_linearize(skb) != 0)) {\n\t\t\tPKT_ERROR(pkt, \"linearize failed\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\t}\n\tfrom = skb_pull(skb, len);\n\tfrom -= len;\n\tif (data)\n\t\tmemcpy(data, from, len);\n\treturn 0;\n}\nEXPORT_SYMBOL(cfpkt_extr_head);\n\nint cfpkt_extr_trail(struct cfpkt *pkt, void *dta, u16 len)\n{\n\tstruct sk_buff *skb = pkt_to_skb(pkt);\n\tu8 *data = dta;\n\tu8 *from;\n\tif (unlikely(is_erronous(pkt)))\n\t\treturn -EPROTO;\n\n\tif (unlikely(skb_linearize(skb) != 0)) {\n\t\tPKT_ERROR(pkt, \"linearize failed\\n\");\n\t\treturn -EPROTO;\n\t}\n\tif (unlikely(skb->data + len > skb_tail_pointer(skb))) {\n\t\tPKT_ERROR(pkt, \"read beyond end of packet\\n\");\n\t\treturn -EPROTO;\n\t}\n\tfrom = skb_tail_pointer(skb) - len;\n\tskb_trim(skb, skb->len - len);\n\tmemcpy(data, from, len);\n\treturn 0;\n}\n\nint cfpkt_pad_trail(struct cfpkt *pkt, u16 len)\n{\n\treturn cfpkt_add_body(pkt, NULL, len);\n}\n\nint cfpkt_add_body(struct cfpkt *pkt, const void *data, u16 len)\n{\n\tstruct sk_buff *skb = pkt_to_skb(pkt);\n\tstruct sk_buff *lastskb;\n\tu8 *to;\n\tu16 addlen = 0;\n\n\n\tif (unlikely(is_erronous(pkt)))\n\t\treturn -EPROTO;\n\n\tlastskb = skb;\n\n\t \n\tif (unlikely(skb_tailroom(skb) < len)) {\n\t\tif (likely(len < PKT_LEN_WHEN_EXTENDING))\n\t\t\taddlen = PKT_LEN_WHEN_EXTENDING;\n\t\telse\n\t\t\taddlen = len;\n\t}\n\n\t \n\tif (unlikely((addlen > 0) || skb_cloned(skb) || skb_shared(skb))) {\n\n\t\t \n\t\tif (unlikely(skb_cow_data(skb, addlen, &lastskb) < 0)) {\n\t\t\tPKT_ERROR(pkt, \"cow failed\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\t}\n\n\t \n\tto = pskb_put(skb, lastskb, len);\n\tif (likely(data))\n\t\tmemcpy(to, data, len);\n\treturn 0;\n}\n\ninline int cfpkt_addbdy(struct cfpkt *pkt, u8 data)\n{\n\treturn cfpkt_add_body(pkt, &data, 1);\n}\n\nint cfpkt_add_head(struct cfpkt *pkt, const void *data2, u16 len)\n{\n\tstruct sk_buff *skb = pkt_to_skb(pkt);\n\tstruct sk_buff *lastskb;\n\tu8 *to;\n\tconst u8 *data = data2;\n\tint ret;\n\tif (unlikely(is_erronous(pkt)))\n\t\treturn -EPROTO;\n\tif (unlikely(skb_headroom(skb) < len)) {\n\t\tPKT_ERROR(pkt, \"no headroom\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tret = skb_cow_data(skb, 0, &lastskb);\n\tif (unlikely(ret < 0)) {\n\t\tPKT_ERROR(pkt, \"cow failed\\n\");\n\t\treturn ret;\n\t}\n\n\tto = skb_push(skb, len);\n\tmemcpy(to, data, len);\n\treturn 0;\n}\nEXPORT_SYMBOL(cfpkt_add_head);\n\ninline int cfpkt_add_trail(struct cfpkt *pkt, const void *data, u16 len)\n{\n\treturn cfpkt_add_body(pkt, data, len);\n}\n\ninline u16 cfpkt_getlen(struct cfpkt *pkt)\n{\n\tstruct sk_buff *skb = pkt_to_skb(pkt);\n\treturn skb->len;\n}\n\nint cfpkt_iterate(struct cfpkt *pkt,\n\t\t  u16 (*iter_func)(u16, void *, u16),\n\t\t  u16 data)\n{\n\t \n\tif (unlikely(is_erronous(pkt)))\n\t\treturn -EPROTO;\n\tif (unlikely(skb_linearize(&pkt->skb) != 0)) {\n\t\tPKT_ERROR(pkt, \"linearize failed\\n\");\n\t\treturn -EPROTO;\n\t}\n\treturn iter_func(data, pkt->skb.data, cfpkt_getlen(pkt));\n}\n\nint cfpkt_setlen(struct cfpkt *pkt, u16 len)\n{\n\tstruct sk_buff *skb = pkt_to_skb(pkt);\n\n\n\tif (unlikely(is_erronous(pkt)))\n\t\treturn -EPROTO;\n\n\tif (likely(len <= skb->len)) {\n\t\tif (unlikely(skb->data_len))\n\t\t\t___pskb_trim(skb, len);\n\t\telse\n\t\t\tskb_trim(skb, len);\n\n\t\treturn cfpkt_getlen(pkt);\n\t}\n\n\t \n\tif (unlikely(!cfpkt_pad_trail(pkt, len - skb->len)))\n\t\tPKT_ERROR(pkt, \"skb_pad_trail failed\\n\");\n\n\treturn cfpkt_getlen(pkt);\n}\n\nstruct cfpkt *cfpkt_append(struct cfpkt *dstpkt,\n\t\t\t   struct cfpkt *addpkt,\n\t\t\t   u16 expectlen)\n{\n\tstruct sk_buff *dst = pkt_to_skb(dstpkt);\n\tstruct sk_buff *add = pkt_to_skb(addpkt);\n\tu16 addlen = skb_headlen(add);\n\tu16 neededtailspace;\n\tstruct sk_buff *tmp;\n\tu16 dstlen;\n\tu16 createlen;\n\tif (unlikely(is_erronous(dstpkt) || is_erronous(addpkt))) {\n\t\treturn dstpkt;\n\t}\n\tif (expectlen > addlen)\n\t\tneededtailspace = expectlen;\n\telse\n\t\tneededtailspace = addlen;\n\n\tif (dst->tail + neededtailspace > dst->end) {\n\t\t \n\t\tstruct cfpkt *tmppkt;\n\t\tdstlen = skb_headlen(dst);\n\t\tcreatelen = dstlen + neededtailspace;\n\t\ttmppkt = cfpkt_create(createlen + PKT_PREFIX + PKT_POSTFIX);\n\t\tif (tmppkt == NULL)\n\t\t\treturn NULL;\n\t\ttmp = pkt_to_skb(tmppkt);\n\t\tskb_put_data(tmp, dst->data, dstlen);\n\t\tcfpkt_destroy(dstpkt);\n\t\tdst = tmp;\n\t}\n\tskb_put_data(dst, add->data, skb_headlen(add));\n\tcfpkt_destroy(addpkt);\n\treturn skb_to_pkt(dst);\n}\n\nstruct cfpkt *cfpkt_split(struct cfpkt *pkt, u16 pos)\n{\n\tstruct sk_buff *skb2;\n\tstruct sk_buff *skb = pkt_to_skb(pkt);\n\tstruct cfpkt *tmppkt;\n\tu8 *split = skb->data + pos;\n\tu16 len2nd = skb_tail_pointer(skb) - split;\n\n\tif (unlikely(is_erronous(pkt)))\n\t\treturn NULL;\n\n\tif (skb->data + pos > skb_tail_pointer(skb)) {\n\t\tPKT_ERROR(pkt, \"trying to split beyond end of packet\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\ttmppkt = cfpkt_create_pfx(len2nd + PKT_PREFIX + PKT_POSTFIX,\n\t\t\t\t  PKT_PREFIX);\n\tif (tmppkt == NULL)\n\t\treturn NULL;\n\tskb2 = pkt_to_skb(tmppkt);\n\n\n\tif (skb2 == NULL)\n\t\treturn NULL;\n\n\tskb_put_data(skb2, split, len2nd);\n\n\t \n\tskb_trim(skb, pos);\n\n\tskb2->priority = skb->priority;\n\treturn skb_to_pkt(skb2);\n}\n\nbool cfpkt_erroneous(struct cfpkt *pkt)\n{\n\treturn cfpkt_priv(pkt)->erronous;\n}\n\nstruct caif_payload_info *cfpkt_info(struct cfpkt *pkt)\n{\n\treturn (struct caif_payload_info *)&pkt_to_skb(pkt)->cb;\n}\nEXPORT_SYMBOL(cfpkt_info);\n\nvoid cfpkt_set_prio(struct cfpkt *pkt, int prio)\n{\n\tpkt_to_skb(pkt)->priority = prio;\n}\nEXPORT_SYMBOL(cfpkt_set_prio);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}