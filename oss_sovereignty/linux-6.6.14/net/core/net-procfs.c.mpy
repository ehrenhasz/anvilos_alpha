{
  "module_name": "net-procfs.c",
  "hash_id": "8d9f5c6aa26d94d29c211c5fb7553b07513c4f06d6cfbd4c5b185f3357def539",
  "original_prompt": "Ingested from linux-6.6.14/net/core/net-procfs.c",
  "human_readable_source": "\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <net/wext.h>\n\n#include \"dev.h\"\n\n#define BUCKET_SPACE (32 - NETDEV_HASHBITS - 1)\n\n#define get_bucket(x) ((x) >> BUCKET_SPACE)\n#define get_offset(x) ((x) & ((1 << BUCKET_SPACE) - 1))\n#define set_bucket_offset(b, o) ((b) << BUCKET_SPACE | (o))\n\nstatic inline struct net_device *dev_from_same_bucket(struct seq_file *seq, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct net_device *dev;\n\tstruct hlist_head *h;\n\tunsigned int count = 0, offset = get_offset(*pos);\n\n\th = &net->dev_index_head[get_bucket(*pos)];\n\thlist_for_each_entry_rcu(dev, h, index_hlist) {\n\t\tif (++count == offset)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline struct net_device *dev_from_bucket(struct seq_file *seq, loff_t *pos)\n{\n\tstruct net_device *dev;\n\tunsigned int bucket;\n\n\tdo {\n\t\tdev = dev_from_same_bucket(seq, pos);\n\t\tif (dev)\n\t\t\treturn dev;\n\n\t\tbucket = get_bucket(*pos) + 1;\n\t\t*pos = set_bucket_offset(bucket, 1);\n\t} while (bucket < NETDEV_HASHENTRIES);\n\n\treturn NULL;\n}\n\n \nstatic void *dev_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\trcu_read_lock();\n\tif (!*pos)\n\t\treturn SEQ_START_TOKEN;\n\n\tif (get_bucket(*pos) >= NETDEV_HASHENTRIES)\n\t\treturn NULL;\n\n\treturn dev_from_bucket(seq, pos);\n}\n\nstatic void *dev_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn dev_from_bucket(seq, pos);\n}\n\nstatic void dev_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\nstatic void dev_seq_printf_stats(struct seq_file *seq, struct net_device *dev)\n{\n\tstruct rtnl_link_stats64 temp;\n\tconst struct rtnl_link_stats64 *stats = dev_get_stats(dev, &temp);\n\n\tseq_printf(seq, \"%6s: %7llu %7llu %4llu %4llu %4llu %5llu %10llu %9llu \"\n\t\t   \"%8llu %7llu %4llu %4llu %4llu %5llu %7llu %10llu\\n\",\n\t\t   dev->name, stats->rx_bytes, stats->rx_packets,\n\t\t   stats->rx_errors,\n\t\t   stats->rx_dropped + stats->rx_missed_errors,\n\t\t   stats->rx_fifo_errors,\n\t\t   stats->rx_length_errors + stats->rx_over_errors +\n\t\t    stats->rx_crc_errors + stats->rx_frame_errors,\n\t\t   stats->rx_compressed, stats->multicast,\n\t\t   stats->tx_bytes, stats->tx_packets,\n\t\t   stats->tx_errors, stats->tx_dropped,\n\t\t   stats->tx_fifo_errors, stats->collisions,\n\t\t   stats->tx_carrier_errors +\n\t\t    stats->tx_aborted_errors +\n\t\t    stats->tx_window_errors +\n\t\t    stats->tx_heartbeat_errors,\n\t\t   stats->tx_compressed);\n}\n\n \nstatic int dev_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"Inter-|   Receive                            \"\n\t\t\t      \"                    |  Transmit\\n\"\n\t\t\t      \" face |bytes    packets errs drop fifo frame \"\n\t\t\t      \"compressed multicast|bytes    packets errs \"\n\t\t\t      \"drop fifo colls carrier compressed\\n\");\n\telse\n\t\tdev_seq_printf_stats(seq, v);\n\treturn 0;\n}\n\nstatic u32 softnet_input_pkt_queue_len(struct softnet_data *sd)\n{\n\treturn skb_queue_len_lockless(&sd->input_pkt_queue);\n}\n\nstatic u32 softnet_process_queue_len(struct softnet_data *sd)\n{\n\treturn skb_queue_len_lockless(&sd->process_queue);\n}\n\nstatic struct softnet_data *softnet_get_online(loff_t *pos)\n{\n\tstruct softnet_data *sd = NULL;\n\n\twhile (*pos < nr_cpu_ids)\n\t\tif (cpu_online(*pos)) {\n\t\t\tsd = &per_cpu(softnet_data, *pos);\n\t\t\tbreak;\n\t\t} else\n\t\t\t++*pos;\n\treturn sd;\n}\n\nstatic void *softnet_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn softnet_get_online(pos);\n}\n\nstatic void *softnet_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn softnet_get_online(pos);\n}\n\nstatic void softnet_seq_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic int softnet_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct softnet_data *sd = v;\n\tu32 input_qlen = softnet_input_pkt_queue_len(sd);\n\tu32 process_qlen = softnet_process_queue_len(sd);\n\tunsigned int flow_limit_count = 0;\n\n#ifdef CONFIG_NET_FLOW_LIMIT\n\tstruct sd_flow_limit *fl;\n\n\trcu_read_lock();\n\tfl = rcu_dereference(sd->flow_limit);\n\tif (fl)\n\t\tflow_limit_count = fl->count;\n\trcu_read_unlock();\n#endif\n\n\t \n\tseq_printf(seq,\n\t\t   \"%08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x \"\n\t\t   \"%08x %08x\\n\",\n\t\t   sd->processed, sd->dropped, sd->time_squeeze, 0,\n\t\t   0, 0, 0, 0,  \n\t\t   0,\t \n\t\t   sd->received_rps, flow_limit_count,\n\t\t   input_qlen + process_qlen, (int)seq->index,\n\t\t   input_qlen, process_qlen);\n\treturn 0;\n}\n\nstatic const struct seq_operations dev_seq_ops = {\n\t.start = dev_seq_start,\n\t.next  = dev_seq_next,\n\t.stop  = dev_seq_stop,\n\t.show  = dev_seq_show,\n};\n\nstatic const struct seq_operations softnet_seq_ops = {\n\t.start = softnet_seq_start,\n\t.next  = softnet_seq_next,\n\t.stop  = softnet_seq_stop,\n\t.show  = softnet_seq_show,\n};\n\nstatic void *ptype_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct list_head *ptype_list = NULL;\n\tstruct packet_type *pt = NULL;\n\tstruct net_device *dev;\n\tloff_t i = 0;\n\tint t;\n\n\tfor_each_netdev_rcu(seq_file_net(seq), dev) {\n\t\tptype_list = &dev->ptype_all;\n\t\tlist_for_each_entry_rcu(pt, ptype_list, list) {\n\t\t\tif (i == pos)\n\t\t\t\treturn pt;\n\t\t\t++i;\n\t\t}\n\t}\n\n\tlist_for_each_entry_rcu(pt, &ptype_all, list) {\n\t\tif (i == pos)\n\t\t\treturn pt;\n\t\t++i;\n\t}\n\n\tfor (t = 0; t < PTYPE_HASH_SIZE; t++) {\n\t\tlist_for_each_entry_rcu(pt, &ptype_base[t], list) {\n\t\t\tif (i == pos)\n\t\t\t\treturn pt;\n\t\t\t++i;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void *ptype_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\trcu_read_lock();\n\treturn *pos ? ptype_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *ptype_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct net_device *dev;\n\tstruct packet_type *pt;\n\tstruct list_head *nxt;\n\tint hash;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn ptype_get_idx(seq, 0);\n\n\tpt = v;\n\tnxt = pt->list.next;\n\tif (pt->dev) {\n\t\tif (nxt != &pt->dev->ptype_all)\n\t\t\tgoto found;\n\n\t\tdev = pt->dev;\n\t\tfor_each_netdev_continue_rcu(seq_file_net(seq), dev) {\n\t\t\tif (!list_empty(&dev->ptype_all)) {\n\t\t\t\tnxt = dev->ptype_all.next;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\n\t\tnxt = ptype_all.next;\n\t\tgoto ptype_all;\n\t}\n\n\tif (pt->type == htons(ETH_P_ALL)) {\nptype_all:\n\t\tif (nxt != &ptype_all)\n\t\t\tgoto found;\n\t\thash = 0;\n\t\tnxt = ptype_base[0].next;\n\t} else\n\t\thash = ntohs(pt->type) & PTYPE_HASH_MASK;\n\n\twhile (nxt == &ptype_base[hash]) {\n\t\tif (++hash >= PTYPE_HASH_SIZE)\n\t\t\treturn NULL;\n\t\tnxt = ptype_base[hash].next;\n\t}\nfound:\n\treturn list_entry(nxt, struct packet_type, list);\n}\n\nstatic void ptype_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\nstatic int ptype_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct packet_type *pt = v;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"Type Device      Function\\n\");\n\telse if ((!pt->af_packet_net || net_eq(pt->af_packet_net, seq_file_net(seq))) &&\n\t\t (!pt->dev || net_eq(dev_net(pt->dev), seq_file_net(seq)))) {\n\t\tif (pt->type == htons(ETH_P_ALL))\n\t\t\tseq_puts(seq, \"ALL \");\n\t\telse\n\t\t\tseq_printf(seq, \"%04x\", ntohs(pt->type));\n\n\t\tseq_printf(seq, \" %-8s %ps\\n\",\n\t\t\t   pt->dev ? pt->dev->name : \"\", pt->func);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations ptype_seq_ops = {\n\t.start = ptype_seq_start,\n\t.next  = ptype_seq_next,\n\t.stop  = ptype_seq_stop,\n\t.show  = ptype_seq_show,\n};\n\nstatic int __net_init dev_proc_net_init(struct net *net)\n{\n\tint rc = -ENOMEM;\n\n\tif (!proc_create_net(\"dev\", 0444, net->proc_net, &dev_seq_ops,\n\t\t\tsizeof(struct seq_net_private)))\n\t\tgoto out;\n\tif (!proc_create_seq(\"softnet_stat\", 0444, net->proc_net,\n\t\t\t &softnet_seq_ops))\n\t\tgoto out_dev;\n\tif (!proc_create_net(\"ptype\", 0444, net->proc_net, &ptype_seq_ops,\n\t\t\tsizeof(struct seq_net_private)))\n\t\tgoto out_softnet;\n\n\tif (wext_proc_init(net))\n\t\tgoto out_ptype;\n\trc = 0;\nout:\n\treturn rc;\nout_ptype:\n\tremove_proc_entry(\"ptype\", net->proc_net);\nout_softnet:\n\tremove_proc_entry(\"softnet_stat\", net->proc_net);\nout_dev:\n\tremove_proc_entry(\"dev\", net->proc_net);\n\tgoto out;\n}\n\nstatic void __net_exit dev_proc_net_exit(struct net *net)\n{\n\twext_proc_exit(net);\n\n\tremove_proc_entry(\"ptype\", net->proc_net);\n\tremove_proc_entry(\"softnet_stat\", net->proc_net);\n\tremove_proc_entry(\"dev\", net->proc_net);\n}\n\nstatic struct pernet_operations __net_initdata dev_proc_ops = {\n\t.init = dev_proc_net_init,\n\t.exit = dev_proc_net_exit,\n};\n\nstatic int dev_mc_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct netdev_hw_addr *ha;\n\tstruct net_device *dev = v;\n\n\tif (v == SEQ_START_TOKEN)\n\t\treturn 0;\n\n\tnetif_addr_lock_bh(dev);\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tseq_printf(seq, \"%-4d %-15s %-5d %-5d %*phN\\n\",\n\t\t\t   dev->ifindex, dev->name,\n\t\t\t   ha->refcount, ha->global_use,\n\t\t\t   (int)dev->addr_len, ha->addr);\n\t}\n\tnetif_addr_unlock_bh(dev);\n\treturn 0;\n}\n\nstatic const struct seq_operations dev_mc_seq_ops = {\n\t.start = dev_seq_start,\n\t.next  = dev_seq_next,\n\t.stop  = dev_seq_stop,\n\t.show  = dev_mc_seq_show,\n};\n\nstatic int __net_init dev_mc_net_init(struct net *net)\n{\n\tif (!proc_create_net(\"dev_mcast\", 0, net->proc_net, &dev_mc_seq_ops,\n\t\t\tsizeof(struct seq_net_private)))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __net_exit dev_mc_net_exit(struct net *net)\n{\n\tremove_proc_entry(\"dev_mcast\", net->proc_net);\n}\n\nstatic struct pernet_operations __net_initdata dev_mc_net_ops = {\n\t.init = dev_mc_net_init,\n\t.exit = dev_mc_net_exit,\n};\n\nint __init dev_proc_init(void)\n{\n\tint ret = register_pernet_subsys(&dev_proc_ops);\n\tif (!ret)\n\t\treturn register_pernet_subsys(&dev_mc_net_ops);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}