{
  "module_name": "flow_dissector.c",
  "hash_id": "236f6f4e1193e1ecd1708b577b633bb0ae239da57ee146c28f26b396fd0c1628",
  "original_prompt": "Ingested from linux-6.6.14/net/core/flow_dissector.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/if_vlan.h>\n#include <linux/filter.h>\n#include <net/dsa.h>\n#include <net/dst_metadata.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/gre.h>\n#include <net/pptp.h>\n#include <net/tipc.h>\n#include <linux/igmp.h>\n#include <linux/icmp.h>\n#include <linux/sctp.h>\n#include <linux/dccp.h>\n#include <linux/if_tunnel.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp_defs.h>\n#include <linux/stddef.h>\n#include <linux/if_ether.h>\n#include <linux/if_hsr.h>\n#include <linux/mpls.h>\n#include <linux/tcp.h>\n#include <linux/ptp_classify.h>\n#include <net/flow_dissector.h>\n#include <net/pkt_cls.h>\n#include <scsi/fc/fc_fcoe.h>\n#include <uapi/linux/batadv_packet.h>\n#include <linux/bpf.h>\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_labels.h>\n#endif\n#include <linux/bpf-netns.h>\n\nstatic void dissector_set_key(struct flow_dissector *flow_dissector,\n\t\t\t      enum flow_dissector_key_id key_id)\n{\n\tflow_dissector->used_keys |= (1ULL << key_id);\n}\n\nvoid skb_flow_dissector_init(struct flow_dissector *flow_dissector,\n\t\t\t     const struct flow_dissector_key *key,\n\t\t\t     unsigned int key_count)\n{\n\tunsigned int i;\n\n\tmemset(flow_dissector, 0, sizeof(*flow_dissector));\n\n\tfor (i = 0; i < key_count; i++, key++) {\n\t\t \n\t\tBUG_ON(key->offset > USHRT_MAX);\n\t\tBUG_ON(dissector_uses_key(flow_dissector,\n\t\t\t\t\t  key->key_id));\n\n\t\tdissector_set_key(flow_dissector, key->key_id);\n\t\tflow_dissector->offset[key->key_id] = key->offset;\n\t}\n\n\t \n\tBUG_ON(!dissector_uses_key(flow_dissector,\n\t\t\t\t   FLOW_DISSECTOR_KEY_CONTROL));\n\tBUG_ON(!dissector_uses_key(flow_dissector,\n\t\t\t\t   FLOW_DISSECTOR_KEY_BASIC));\n}\nEXPORT_SYMBOL(skb_flow_dissector_init);\n\n#ifdef CONFIG_BPF_SYSCALL\nint flow_dissector_bpf_prog_attach_check(struct net *net,\n\t\t\t\t\t struct bpf_prog *prog)\n{\n\tenum netns_bpf_attach_type type = NETNS_BPF_FLOW_DISSECTOR;\n\n\tif (net == &init_net) {\n\t\t \n\t\tstruct net *ns;\n\n\t\tfor_each_net(ns) {\n\t\t\tif (ns == &init_net)\n\t\t\t\tcontinue;\n\t\t\tif (rcu_access_pointer(ns->bpf.run_array[type]))\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t} else {\n\t\t \n\t\tif (rcu_access_pointer(init_net.bpf.run_array[type]))\n\t\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n#endif  \n\n \n__be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,\n\t\t\t    const void *data, int hlen)\n{\n\tint poff = proto_ports_offset(ip_proto);\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\thlen = skb_headlen(skb);\n\t}\n\n\tif (poff >= 0) {\n\t\t__be32 *ports, _ports;\n\n\t\tports = __skb_header_pointer(skb, thoff + poff,\n\t\t\t\t\t     sizeof(_ports), data, hlen, &_ports);\n\t\tif (ports)\n\t\t\treturn *ports;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__skb_flow_get_ports);\n\nstatic bool icmp_has_id(u8 type)\n{\n\tswitch (type) {\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\tcase ICMP_TIMESTAMP:\n\tcase ICMP_TIMESTAMPREPLY:\n\tcase ICMPV6_ECHO_REQUEST:\n\tcase ICMPV6_ECHO_REPLY:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nvoid skb_flow_get_icmp_tci(const struct sk_buff *skb,\n\t\t\t   struct flow_dissector_key_icmp *key_icmp,\n\t\t\t   const void *data, int thoff, int hlen)\n{\n\tstruct icmphdr *ih, _ih;\n\n\tih = __skb_header_pointer(skb, thoff, sizeof(_ih), data, hlen, &_ih);\n\tif (!ih)\n\t\treturn;\n\n\tkey_icmp->type = ih->type;\n\tkey_icmp->code = ih->code;\n\n\t \n\tif (icmp_has_id(ih->type))\n\t\tkey_icmp->id = ih->un.echo.id ? ntohs(ih->un.echo.id) : 1;\n\telse\n\t\tkey_icmp->id = 0;\n}\nEXPORT_SYMBOL(skb_flow_get_icmp_tci);\n\n \nstatic void __skb_flow_dissect_icmp(const struct sk_buff *skb,\n\t\t\t\t    struct flow_dissector *flow_dissector,\n\t\t\t\t    void *target_container, const void *data,\n\t\t\t\t    int thoff, int hlen)\n{\n\tstruct flow_dissector_key_icmp *key_icmp;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ICMP))\n\t\treturn;\n\n\tkey_icmp = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t     FLOW_DISSECTOR_KEY_ICMP,\n\t\t\t\t\t     target_container);\n\n\tskb_flow_get_icmp_tci(skb, key_icmp, data, thoff, hlen);\n}\n\nstatic void __skb_flow_dissect_ah(const struct sk_buff *skb,\n\t\t\t\t  struct flow_dissector *flow_dissector,\n\t\t\t\t  void *target_container, const void *data,\n\t\t\t\t  int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_ipsec *key_ah;\n\tstruct ip_auth_hdr _hdr, *hdr;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_IPSEC))\n\t\treturn;\n\n\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\tif (!hdr)\n\t\treturn;\n\n\tkey_ah = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPSEC,\n\t\t\t\t\t   target_container);\n\n\tkey_ah->spi = hdr->spi;\n}\n\nstatic void __skb_flow_dissect_esp(const struct sk_buff *skb,\n\t\t\t\t   struct flow_dissector *flow_dissector,\n\t\t\t\t   void *target_container, const void *data,\n\t\t\t\t   int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_ipsec *key_esp;\n\tstruct ip_esp_hdr _hdr, *hdr;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_IPSEC))\n\t\treturn;\n\n\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\tif (!hdr)\n\t\treturn;\n\n\tkey_esp = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t    FLOW_DISSECTOR_KEY_IPSEC,\n\t\t\t\t\t    target_container);\n\n\tkey_esp->spi = hdr->spi;\n}\n\nstatic void __skb_flow_dissect_l2tpv3(const struct sk_buff *skb,\n\t\t\t\t      struct flow_dissector *flow_dissector,\n\t\t\t\t      void *target_container, const void *data,\n\t\t\t\t      int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_l2tpv3 *key_l2tpv3;\n\tstruct {\n\t\t__be32 session_id;\n\t} *hdr, _hdr;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_L2TPV3))\n\t\treturn;\n\n\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\tif (!hdr)\n\t\treturn;\n\n\tkey_l2tpv3 = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t       FLOW_DISSECTOR_KEY_L2TPV3,\n\t\t\t\t\t       target_container);\n\n\tkey_l2tpv3->session_id = hdr->session_id;\n}\n\nvoid skb_flow_dissect_meta(const struct sk_buff *skb,\n\t\t\t   struct flow_dissector *flow_dissector,\n\t\t\t   void *target_container)\n{\n\tstruct flow_dissector_key_meta *meta;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_META))\n\t\treturn;\n\n\tmeta = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t FLOW_DISSECTOR_KEY_META,\n\t\t\t\t\t target_container);\n\tmeta->ingress_ifindex = skb->skb_iif;\n#if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)\n\tif (tc_skb_ext_tc_enabled()) {\n\t\tstruct tc_skb_ext *ext;\n\n\t\text = skb_ext_find(skb, TC_SKB_EXT);\n\t\tif (ext)\n\t\t\tmeta->l2_miss = ext->l2_miss;\n\t}\n#endif\n}\nEXPORT_SYMBOL(skb_flow_dissect_meta);\n\nstatic void\nskb_flow_dissect_set_enc_addr_type(enum flow_dissector_key_id type,\n\t\t\t\t   struct flow_dissector *flow_dissector,\n\t\t\t\t   void *target_container)\n{\n\tstruct flow_dissector_key_control *ctrl;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_CONTROL))\n\t\treturn;\n\n\tctrl = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t FLOW_DISSECTOR_KEY_ENC_CONTROL,\n\t\t\t\t\t target_container);\n\tctrl->addr_type = type;\n}\n\nvoid\nskb_flow_dissect_ct(const struct sk_buff *skb,\n\t\t    struct flow_dissector *flow_dissector,\n\t\t    void *target_container, u16 *ctinfo_map,\n\t\t    size_t mapsize, bool post_ct, u16 zone)\n{\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tstruct flow_dissector_key_ct *key;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn_labels *cl;\n\tstruct nf_conn *ct;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_CT))\n\t\treturn;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (!ct && !post_ct)\n\t\treturn;\n\n\tkey = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_CT,\n\t\t\t\t\ttarget_container);\n\n\tif (!ct) {\n\t\tkey->ct_state = TCA_FLOWER_KEY_CT_FLAGS_TRACKED |\n\t\t\t\tTCA_FLOWER_KEY_CT_FLAGS_INVALID;\n\t\tkey->ct_zone = zone;\n\t\treturn;\n\t}\n\n\tif (ctinfo < mapsize)\n\t\tkey->ct_state = ctinfo_map[ctinfo];\n#if IS_ENABLED(CONFIG_NF_CONNTRACK_ZONES)\n\tkey->ct_zone = ct->zone.id;\n#endif\n#if IS_ENABLED(CONFIG_NF_CONNTRACK_MARK)\n\tkey->ct_mark = READ_ONCE(ct->mark);\n#endif\n\n\tcl = nf_ct_labels_find(ct);\n\tif (cl)\n\t\tmemcpy(key->ct_labels, cl->bits, sizeof(key->ct_labels));\n#endif  \n}\nEXPORT_SYMBOL(skb_flow_dissect_ct);\n\nvoid\nskb_flow_dissect_tunnel_info(const struct sk_buff *skb,\n\t\t\t     struct flow_dissector *flow_dissector,\n\t\t\t     void *target_container)\n{\n\tstruct ip_tunnel_info *info;\n\tstruct ip_tunnel_key *key;\n\n\t \n\tif (!dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_ENC_KEYID) &&\n\t    !dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) &&\n\t    !dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) &&\n\t    !dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_ENC_CONTROL) &&\n\t    !dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_ENC_PORTS) &&\n\t    !dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_ENC_IP) &&\n\t    !dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_ENC_OPTS))\n\t\treturn;\n\n\tinfo = skb_tunnel_info(skb);\n\tif (!info)\n\t\treturn;\n\n\tkey = &info->key;\n\n\tswitch (ip_tunnel_info_af(info)) {\n\tcase AF_INET:\n\t\tskb_flow_dissect_set_enc_addr_type(FLOW_DISSECTOR_KEY_IPV4_ADDRS,\n\t\t\t\t\t\t   flow_dissector,\n\t\t\t\t\t\t   target_container);\n\t\tif (dissector_uses_key(flow_dissector,\n\t\t\t\t       FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv4_addrs *ipv4;\n\n\t\t\tipv4 = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS,\n\t\t\t\t\t\t\t target_container);\n\t\t\tipv4->src = key->u.ipv4.src;\n\t\t\tipv4->dst = key->u.ipv4.dst;\n\t\t}\n\t\tbreak;\n\tcase AF_INET6:\n\t\tskb_flow_dissect_set_enc_addr_type(FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t   flow_dissector,\n\t\t\t\t\t\t   target_container);\n\t\tif (dissector_uses_key(flow_dissector,\n\t\t\t\t       FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *ipv6;\n\n\t\t\tipv6 = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS,\n\t\t\t\t\t\t\t target_container);\n\t\t\tipv6->src = key->u.ipv6.src;\n\t\t\tipv6->dst = key->u.ipv6.dst;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_KEYID)) {\n\t\tstruct flow_dissector_key_keyid *keyid;\n\n\t\tkeyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ENC_KEYID,\n\t\t\t\t\t\t  target_container);\n\t\tkeyid->keyid = tunnel_id_to_key32(key->tun_id);\n\t}\n\n\tif (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_PORTS)) {\n\t\tstruct flow_dissector_key_ports *tp;\n\n\t\ttp = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t       FLOW_DISSECTOR_KEY_ENC_PORTS,\n\t\t\t\t\t       target_container);\n\t\ttp->src = key->tp_src;\n\t\ttp->dst = key->tp_dst;\n\t}\n\n\tif (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_IP)) {\n\t\tstruct flow_dissector_key_ip *ip;\n\n\t\tip = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t       FLOW_DISSECTOR_KEY_ENC_IP,\n\t\t\t\t\t       target_container);\n\t\tip->tos = key->tos;\n\t\tip->ttl = key->ttl;\n\t}\n\n\tif (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_OPTS)) {\n\t\tstruct flow_dissector_key_enc_opts *enc_opt;\n\n\t\tenc_opt = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t    FLOW_DISSECTOR_KEY_ENC_OPTS,\n\t\t\t\t\t\t    target_container);\n\n\t\tif (info->options_len) {\n\t\t\tenc_opt->len = info->options_len;\n\t\t\tip_tunnel_info_opts_get(enc_opt->data, info);\n\t\t\tenc_opt->dst_opt_type = info->key.tun_flags &\n\t\t\t\t\t\tTUNNEL_OPTIONS_PRESENT;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(skb_flow_dissect_tunnel_info);\n\nvoid skb_flow_dissect_hash(const struct sk_buff *skb,\n\t\t\t   struct flow_dissector *flow_dissector,\n\t\t\t   void *target_container)\n{\n\tstruct flow_dissector_key_hash *key;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_HASH))\n\t\treturn;\n\n\tkey = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_HASH,\n\t\t\t\t\ttarget_container);\n\n\tkey->hash = skb_get_hash_raw(skb);\n}\nEXPORT_SYMBOL(skb_flow_dissect_hash);\n\nstatic enum flow_dissect_ret\n__skb_flow_dissect_mpls(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container, const void *data, int nhoff,\n\t\t\tint hlen, int lse_index, bool *entropy_label)\n{\n\tstruct mpls_label *hdr, _hdr;\n\tu32 entry, label, bos;\n\n\tif (!dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY) &&\n\t    !dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_MPLS))\n\t\treturn FLOW_DISSECT_RET_OUT_GOOD;\n\n\tif (lse_index >= FLOW_DIS_MPLS_MAX)\n\t\treturn FLOW_DISSECT_RET_OUT_GOOD;\n\n\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t   hlen, &_hdr);\n\tif (!hdr)\n\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\tentry = ntohl(hdr->entry);\n\tlabel = (entry & MPLS_LS_LABEL_MASK) >> MPLS_LS_LABEL_SHIFT;\n\tbos = (entry & MPLS_LS_S_MASK) >> MPLS_LS_S_SHIFT;\n\n\tif (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_MPLS)) {\n\t\tstruct flow_dissector_key_mpls *key_mpls;\n\t\tstruct flow_dissector_mpls_lse *lse;\n\n\t\tkey_mpls = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_MPLS,\n\t\t\t\t\t\t     target_container);\n\t\tlse = &key_mpls->ls[lse_index];\n\n\t\tlse->mpls_ttl = (entry & MPLS_LS_TTL_MASK) >> MPLS_LS_TTL_SHIFT;\n\t\tlse->mpls_bos = bos;\n\t\tlse->mpls_tc = (entry & MPLS_LS_TC_MASK) >> MPLS_LS_TC_SHIFT;\n\t\tlse->mpls_label = label;\n\t\tdissector_set_mpls_lse(key_mpls, lse_index);\n\t}\n\n\tif (*entropy_label &&\n\t    dissector_uses_key(flow_dissector,\n\t\t\t       FLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\tstruct flow_dissector_key_keyid *key_keyid;\n\n\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t      target_container);\n\t\tkey_keyid->keyid = cpu_to_be32(label);\n\t}\n\n\t*entropy_label = label == MPLS_LABEL_ENTROPY;\n\n\treturn bos ? FLOW_DISSECT_RET_OUT_GOOD : FLOW_DISSECT_RET_PROTO_AGAIN;\n}\n\nstatic enum flow_dissect_ret\n__skb_flow_dissect_arp(const struct sk_buff *skb,\n\t\t       struct flow_dissector *flow_dissector,\n\t\t       void *target_container, const void *data,\n\t\t       int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_arp *key_arp;\n\tstruct {\n\t\tunsigned char ar_sha[ETH_ALEN];\n\t\tunsigned char ar_sip[4];\n\t\tunsigned char ar_tha[ETH_ALEN];\n\t\tunsigned char ar_tip[4];\n\t} *arp_eth, _arp_eth;\n\tconst struct arphdr *arp;\n\tstruct arphdr _arp;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ARP))\n\t\treturn FLOW_DISSECT_RET_OUT_GOOD;\n\n\tarp = __skb_header_pointer(skb, nhoff, sizeof(_arp), data,\n\t\t\t\t   hlen, &_arp);\n\tif (!arp)\n\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\tif (arp->ar_hrd != htons(ARPHRD_ETHER) ||\n\t    arp->ar_pro != htons(ETH_P_IP) ||\n\t    arp->ar_hln != ETH_ALEN ||\n\t    arp->ar_pln != 4 ||\n\t    (arp->ar_op != htons(ARPOP_REPLY) &&\n\t     arp->ar_op != htons(ARPOP_REQUEST)))\n\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\tarp_eth = __skb_header_pointer(skb, nhoff + sizeof(_arp),\n\t\t\t\t       sizeof(_arp_eth), data,\n\t\t\t\t       hlen, &_arp_eth);\n\tif (!arp_eth)\n\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\tkey_arp = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t    FLOW_DISSECTOR_KEY_ARP,\n\t\t\t\t\t    target_container);\n\n\tmemcpy(&key_arp->sip, arp_eth->ar_sip, sizeof(key_arp->sip));\n\tmemcpy(&key_arp->tip, arp_eth->ar_tip, sizeof(key_arp->tip));\n\n\t \n\tkey_arp->op = ntohs(arp->ar_op) & 0xff;\n\n\tether_addr_copy(key_arp->sha, arp_eth->ar_sha);\n\tether_addr_copy(key_arp->tha, arp_eth->ar_tha);\n\n\treturn FLOW_DISSECT_RET_OUT_GOOD;\n}\n\nstatic enum flow_dissect_ret\n__skb_flow_dissect_cfm(const struct sk_buff *skb,\n\t\t       struct flow_dissector *flow_dissector,\n\t\t       void *target_container, const void *data,\n\t\t       int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_cfm *key, *hdr, _hdr;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_CFM))\n\t\treturn FLOW_DISSECT_RET_OUT_GOOD;\n\n\thdr = __skb_header_pointer(skb, nhoff, sizeof(*key), data, hlen, &_hdr);\n\tif (!hdr)\n\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\tkey = skb_flow_dissector_target(flow_dissector, FLOW_DISSECTOR_KEY_CFM,\n\t\t\t\t\ttarget_container);\n\n\tkey->mdl_ver = hdr->mdl_ver;\n\tkey->opcode = hdr->opcode;\n\n\treturn FLOW_DISSECT_RET_OUT_GOOD;\n}\n\nstatic enum flow_dissect_ret\n__skb_flow_dissect_gre(const struct sk_buff *skb,\n\t\t       struct flow_dissector_key_control *key_control,\n\t\t       struct flow_dissector *flow_dissector,\n\t\t       void *target_container, const void *data,\n\t\t       __be16 *p_proto, int *p_nhoff, int *p_hlen,\n\t\t       unsigned int flags)\n{\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tstruct gre_base_hdr *hdr, _hdr;\n\tint offset = 0;\n\tu16 gre_ver;\n\n\thdr = __skb_header_pointer(skb, *p_nhoff, sizeof(_hdr),\n\t\t\t\t   data, *p_hlen, &_hdr);\n\tif (!hdr)\n\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\t \n\tif (hdr->flags & GRE_ROUTING)\n\t\treturn FLOW_DISSECT_RET_OUT_GOOD;\n\n\t \n\tgre_ver = ntohs(hdr->flags & GRE_VERSION);\n\tif (gre_ver > 1)\n\t\treturn FLOW_DISSECT_RET_OUT_GOOD;\n\n\t*p_proto = hdr->protocol;\n\tif (gre_ver) {\n\t\t \n\t\tif (!(*p_proto == GRE_PROTO_PPP && (hdr->flags & GRE_KEY)))\n\t\t\treturn FLOW_DISSECT_RET_OUT_GOOD;\n\t}\n\n\toffset += sizeof(struct gre_base_hdr);\n\n\tif (hdr->flags & GRE_CSUM)\n\t\toffset += sizeof_field(struct gre_full_hdr, csum) +\n\t\t\t  sizeof_field(struct gre_full_hdr, reserved1);\n\n\tif (hdr->flags & GRE_KEY) {\n\t\tconst __be32 *keyid;\n\t\t__be32 _keyid;\n\n\t\tkeyid = __skb_header_pointer(skb, *p_nhoff + offset,\n\t\t\t\t\t     sizeof(_keyid),\n\t\t\t\t\t     data, *p_hlen, &_keyid);\n\t\tif (!keyid)\n\t\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\t\tif (dissector_uses_key(flow_dissector,\n\t\t\t\t       FLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tif (gre_ver == 0)\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\telse\n\t\t\t\tkey_keyid->keyid = *keyid & GRE_PPTP_KEY_MASK;\n\t\t}\n\t\toffset += sizeof_field(struct gre_full_hdr, key);\n\t}\n\n\tif (hdr->flags & GRE_SEQ)\n\t\toffset += sizeof_field(struct pptp_gre_header, seq);\n\n\tif (gre_ver == 0) {\n\t\tif (*p_proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, *p_nhoff + offset,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, *p_hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\t\t\t*p_proto = eth->h_proto;\n\t\t\toffset += sizeof(*eth);\n\n\t\t\t \n\t\t\tif (NET_IP_ALIGN)\n\t\t\t\t*p_hlen = *p_nhoff + offset;\n\t\t}\n\t} else {  \n\t\tu8 _ppp_hdr[PPP_HDRLEN];\n\t\tu8 *ppp_hdr;\n\n\t\tif (hdr->flags & GRE_ACK)\n\t\t\toffset += sizeof_field(struct pptp_gre_header, ack);\n\n\t\tppp_hdr = __skb_header_pointer(skb, *p_nhoff + offset,\n\t\t\t\t\t       sizeof(_ppp_hdr),\n\t\t\t\t\t       data, *p_hlen, _ppp_hdr);\n\t\tif (!ppp_hdr)\n\t\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\t\tswitch (PPP_PROTOCOL(ppp_hdr)) {\n\t\tcase PPP_IP:\n\t\t\t*p_proto = htons(ETH_P_IP);\n\t\t\tbreak;\n\t\tcase PPP_IPV6:\n\t\t\t*p_proto = htons(ETH_P_IPV6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\toffset += PPP_HDRLEN;\n\t}\n\n\t*p_nhoff += offset;\n\tkey_control->flags |= FLOW_DIS_ENCAPSULATION;\n\tif (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)\n\t\treturn FLOW_DISSECT_RET_OUT_GOOD;\n\n\treturn FLOW_DISSECT_RET_PROTO_AGAIN;\n}\n\n \nstatic enum flow_dissect_ret\n__skb_flow_dissect_batadv(const struct sk_buff *skb,\n\t\t\t  struct flow_dissector_key_control *key_control,\n\t\t\t  const void *data, __be16 *p_proto, int *p_nhoff,\n\t\t\t  int hlen, unsigned int flags)\n{\n\tstruct {\n\t\tstruct batadv_unicast_packet batadv_unicast;\n\t\tstruct ethhdr eth;\n\t} *hdr, _hdr;\n\n\thdr = __skb_header_pointer(skb, *p_nhoff, sizeof(_hdr), data, hlen,\n\t\t\t\t   &_hdr);\n\tif (!hdr)\n\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\tif (hdr->batadv_unicast.version != BATADV_COMPAT_VERSION)\n\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\tif (hdr->batadv_unicast.packet_type != BATADV_UNICAST)\n\t\treturn FLOW_DISSECT_RET_OUT_BAD;\n\n\t*p_proto = hdr->eth.h_proto;\n\t*p_nhoff += sizeof(*hdr);\n\n\tkey_control->flags |= FLOW_DIS_ENCAPSULATION;\n\tif (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)\n\t\treturn FLOW_DISSECT_RET_OUT_GOOD;\n\n\treturn FLOW_DISSECT_RET_PROTO_AGAIN;\n}\n\nstatic void\n__skb_flow_dissect_tcp(const struct sk_buff *skb,\n\t\t       struct flow_dissector *flow_dissector,\n\t\t       void *target_container, const void *data,\n\t\t       int thoff, int hlen)\n{\n\tstruct flow_dissector_key_tcp *key_tcp;\n\tstruct tcphdr *th, _th;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_TCP))\n\t\treturn;\n\n\tth = __skb_header_pointer(skb, thoff, sizeof(_th), data, hlen, &_th);\n\tif (!th)\n\t\treturn;\n\n\tif (unlikely(__tcp_hdrlen(th) < sizeof(_th)))\n\t\treturn;\n\n\tkey_tcp = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t    FLOW_DISSECTOR_KEY_TCP,\n\t\t\t\t\t    target_container);\n\tkey_tcp->flags = (*(__be16 *) &tcp_flag_word(th) & htons(0x0FFF));\n}\n\nstatic void\n__skb_flow_dissect_ports(const struct sk_buff *skb,\n\t\t\t struct flow_dissector *flow_dissector,\n\t\t\t void *target_container, const void *data,\n\t\t\t int nhoff, u8 ip_proto, int hlen)\n{\n\tenum flow_dissector_key_id dissector_ports = FLOW_DISSECTOR_KEY_MAX;\n\tstruct flow_dissector_key_ports *key_ports;\n\n\tif (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_PORTS))\n\t\tdissector_ports = FLOW_DISSECTOR_KEY_PORTS;\n\telse if (dissector_uses_key(flow_dissector,\n\t\t\t\t    FLOW_DISSECTOR_KEY_PORTS_RANGE))\n\t\tdissector_ports = FLOW_DISSECTOR_KEY_PORTS_RANGE;\n\n\tif (dissector_ports == FLOW_DISSECTOR_KEY_MAX)\n\t\treturn;\n\n\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      dissector_ports,\n\t\t\t\t\t      target_container);\n\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\tdata, hlen);\n}\n\nstatic void\n__skb_flow_dissect_ipv4(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container, const void *data,\n\t\t\tconst struct iphdr *iph)\n{\n\tstruct flow_dissector_key_ip *key_ip;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_IP))\n\t\treturn;\n\n\tkey_ip = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t   FLOW_DISSECTOR_KEY_IP,\n\t\t\t\t\t   target_container);\n\tkey_ip->tos = iph->tos;\n\tkey_ip->ttl = iph->ttl;\n}\n\nstatic void\n__skb_flow_dissect_ipv6(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container, const void *data,\n\t\t\tconst struct ipv6hdr *iph)\n{\n\tstruct flow_dissector_key_ip *key_ip;\n\n\tif (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_IP))\n\t\treturn;\n\n\tkey_ip = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t   FLOW_DISSECTOR_KEY_IP,\n\t\t\t\t\t   target_container);\n\tkey_ip->tos = ipv6_get_dsfield(iph);\n\tkey_ip->ttl = iph->hop_limit;\n}\n\n \n#define MAX_FLOW_DISSECT_HDRS\t15\n\nstatic bool skb_flow_dissect_allowed(int *num_hdrs)\n{\n\t++*num_hdrs;\n\n\treturn (*num_hdrs <= MAX_FLOW_DISSECT_HDRS);\n}\n\nstatic void __skb_flow_bpf_to_target(const struct bpf_flow_keys *flow_keys,\n\t\t\t\t     struct flow_dissector *flow_dissector,\n\t\t\t\t     void *target_container)\n{\n\tstruct flow_dissector_key_ports *key_ports = NULL;\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_tags *key_tags;\n\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\tkey_control->thoff = flow_keys->thoff;\n\tif (flow_keys->is_frag)\n\t\tkey_control->flags |= FLOW_DIS_IS_FRAGMENT;\n\tif (flow_keys->is_first_frag)\n\t\tkey_control->flags |= FLOW_DIS_FIRST_FRAG;\n\tif (flow_keys->is_encap)\n\t\tkey_control->flags |= FLOW_DIS_ENCAPSULATION;\n\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\tkey_basic->n_proto = flow_keys->n_proto;\n\tkey_basic->ip_proto = flow_keys->ip_proto;\n\n\tif (flow_keys->addr_proto == ETH_P_IP &&\n\t    dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_IPV4_ADDRS)) {\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_addrs->v4addrs.src = flow_keys->ipv4_src;\n\t\tkey_addrs->v4addrs.dst = flow_keys->ipv4_dst;\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t} else if (flow_keys->addr_proto == ETH_P_IPV6 &&\n\t\t   dissector_uses_key(flow_dissector,\n\t\t\t\t      FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t      target_container);\n\t\tmemcpy(&key_addrs->v6addrs.src, &flow_keys->ipv6_src,\n\t\t       sizeof(key_addrs->v6addrs.src));\n\t\tmemcpy(&key_addrs->v6addrs.dst, &flow_keys->ipv6_dst,\n\t\t       sizeof(key_addrs->v6addrs.dst));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t}\n\n\tif (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_PORTS))\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\telse if (dissector_uses_key(flow_dissector,\n\t\t\t\t    FLOW_DISSECTOR_KEY_PORTS_RANGE))\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS_RANGE,\n\t\t\t\t\t\t      target_container);\n\n\tif (key_ports) {\n\t\tkey_ports->src = flow_keys->sport;\n\t\tkey_ports->dst = flow_keys->dport;\n\t}\n\n\tif (dissector_uses_key(flow_dissector,\n\t\t\t       FLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t     target_container);\n\t\tkey_tags->flow_label = ntohl(flow_keys->flow_label);\n\t}\n}\n\nu32 bpf_flow_dissect(struct bpf_prog *prog, struct bpf_flow_dissector *ctx,\n\t\t     __be16 proto, int nhoff, int hlen, unsigned int flags)\n{\n\tstruct bpf_flow_keys *flow_keys = ctx->flow_keys;\n\tu32 result;\n\n\t \n\tmemset(flow_keys, 0, sizeof(*flow_keys));\n\tflow_keys->n_proto = proto;\n\tflow_keys->nhoff = nhoff;\n\tflow_keys->thoff = flow_keys->nhoff;\n\n\tBUILD_BUG_ON((int)BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG !=\n\t\t     (int)FLOW_DISSECTOR_F_PARSE_1ST_FRAG);\n\tBUILD_BUG_ON((int)BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL !=\n\t\t     (int)FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\n\tBUILD_BUG_ON((int)BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP !=\n\t\t     (int)FLOW_DISSECTOR_F_STOP_AT_ENCAP);\n\tflow_keys->flags = flags;\n\n\tresult = bpf_prog_run_pin_on_cpu(prog, ctx);\n\n\tflow_keys->nhoff = clamp_t(u16, flow_keys->nhoff, nhoff, hlen);\n\tflow_keys->thoff = clamp_t(u16, flow_keys->thoff,\n\t\t\t\t   flow_keys->nhoff, hlen);\n\n\treturn result;\n}\n\nstatic bool is_pppoe_ses_hdr_valid(const struct pppoe_hdr *hdr)\n{\n\treturn hdr->ver == 1 && hdr->type == 1 && hdr->code == 0;\n}\n\n \nbool __skb_flow_dissect(const struct net *net,\n\t\t\tconst struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container, const void *data,\n\t\t\t__be16 proto, int nhoff, int hlen, unsigned int flags)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_vlan *key_vlan;\n\tenum flow_dissect_ret fdret;\n\tenum flow_dissector_key_id dissector_vlan = FLOW_DISSECTOR_KEY_MAX;\n\tbool mpls_el = false;\n\tint mpls_lse = 0;\n\tint num_hdrs = 0;\n\tu8 ip_proto = 0;\n\tbool ret;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb_vlan_tag_present(skb) ?\n\t\t\t skb->vlan_proto : skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n#if IS_ENABLED(CONFIG_NET_DSA)\n\t\tif (unlikely(skb->dev && netdev_uses_dsa(skb->dev) &&\n\t\t\t     proto == htons(ETH_P_XDSA))) {\n\t\t\tstruct metadata_dst *md_dst = skb_metadata_dst(skb);\n\t\t\tconst struct dsa_device_ops *ops;\n\t\t\tint offset = 0;\n\n\t\t\tops = skb->dev->dsa_ptr->tag_ops;\n\t\t\t \n\t\t\tif (ops->needed_headroom &&\n\t\t\t    (!md_dst || md_dst->type != METADATA_HW_PORT_MUX)) {\n\t\t\t\tif (ops->flow_dissect)\n\t\t\t\t\tops->flow_dissect(skb, &proto, &offset);\n\t\t\t\telse\n\t\t\t\t\tdsa_tag_generic_flow_dissect(skb,\n\t\t\t\t\t\t\t\t     &proto,\n\t\t\t\t\t\t\t\t     &offset);\n\t\t\t\thlen -= offset;\n\t\t\t\tnhoff += offset;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t \n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t \n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb) {\n\t\tif (!net) {\n\t\t\tif (skb->dev)\n\t\t\t\tnet = dev_net(skb->dev);\n\t\t\telse if (skb->sk)\n\t\t\t\tnet = sock_net(skb->sk);\n\t\t}\n\t}\n\n\tWARN_ON_ONCE(!net);\n\tif (net) {\n\t\tenum netns_bpf_attach_type type = NETNS_BPF_FLOW_DISSECTOR;\n\t\tstruct bpf_prog_array *run_array;\n\n\t\trcu_read_lock();\n\t\trun_array = rcu_dereference(init_net.bpf.run_array[type]);\n\t\tif (!run_array)\n\t\t\trun_array = rcu_dereference(net->bpf.run_array[type]);\n\n\t\tif (run_array) {\n\t\t\tstruct bpf_flow_keys flow_keys;\n\t\t\tstruct bpf_flow_dissector ctx = {\n\t\t\t\t.flow_keys = &flow_keys,\n\t\t\t\t.data = data,\n\t\t\t\t.data_end = data + hlen,\n\t\t\t};\n\t\t\t__be16 n_proto = proto;\n\t\t\tstruct bpf_prog *prog;\n\t\t\tu32 result;\n\n\t\t\tif (skb) {\n\t\t\t\tctx.skb = skb;\n\t\t\t\t \n\t\t\t\tn_proto = skb->protocol;\n\t\t\t}\n\n\t\t\tprog = READ_ONCE(run_array->items[0].prog);\n\t\t\tresult = bpf_flow_dissect(prog, &ctx, n_proto, nhoff,\n\t\t\t\t\t\t  hlen, flags);\n\t\t\tif (result == BPF_FLOW_DISSECTOR_CONTINUE)\n\t\t\t\tgoto dissect_continue;\n\t\t\t__skb_flow_bpf_to_target(&flow_keys, flow_dissector,\n\t\t\t\t\t\t target_container);\n\t\t\trcu_read_unlock();\n\t\t\treturn result == BPF_OK;\n\t\t}\ndissect_continue:\n\t\trcu_read_unlock();\n\t}\n\n\tif (dissector_uses_key(flow_dissector,\n\t\t\t       FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, eth, sizeof(*key_eth_addrs));\n\t}\n\n\tif (dissector_uses_key(flow_dissector,\n\t\t\t       FLOW_DISSECTOR_KEY_NUM_OF_VLANS)) {\n\t\tstruct flow_dissector_key_num_of_vlans *key_num_of_vlans;\n\n\t\tkey_num_of_vlans = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_NUM_OF_VLANS,\n\t\t\t\t\t\t\t     target_container);\n\t\tkey_num_of_vlans->num_of_vlans = 0;\n\t}\n\nproto_again:\n\tfdret = FLOW_DISSECT_RET_CONTINUE;\n\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\n\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\n\t\tif (dissector_uses_key(flow_dissector,\n\t\t\t\t       FLOW_DISSECTOR_KEY_IPV4_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\n\t\t\tmemcpy(&key_addrs->v4addrs.src, &iph->saddr,\n\t\t\t       sizeof(key_addrs->v4addrs.src));\n\t\t\tmemcpy(&key_addrs->v4addrs.dst, &iph->daddr,\n\t\t\t       sizeof(key_addrs->v4addrs.dst));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\t}\n\n\t\t__skb_flow_dissect_ipv4(skb, flow_dissector,\n\t\t\t\t\ttarget_container, data, iph);\n\n\t\tif (ip_is_fragment(iph)) {\n\t\t\tkey_control->flags |= FLOW_DIS_IS_FRAGMENT;\n\n\t\t\tif (iph->frag_off & htons(IP_OFFSET)) {\n\t\t\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tkey_control->flags |= FLOW_DIS_FIRST_FRAG;\n\t\t\t\tif (!(flags &\n\t\t\t\t      FLOW_DISSECTOR_F_PARSE_1ST_FRAG)) {\n\t\t\t\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (dissector_uses_key(flow_dissector,\n\t\t\t\t       FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\n\t\t\tmemcpy(&key_addrs->v6addrs.src, &iph->saddr,\n\t\t\t       sizeof(key_addrs->v6addrs.src));\n\t\t\tmemcpy(&key_addrs->v6addrs.dst, &iph->daddr,\n\t\t\t       sizeof(key_addrs->v6addrs.dst));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tif ((dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL) ||\n\t\t     (flags & FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL)) &&\n\t\t    ip6_flowlabel(iph)) {\n\t\t\t__be32 flow_label = ip6_flowlabel(iph);\n\n\t\t\tif (dissector_uses_key(flow_dissector,\n\t\t\t\t\t       FLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t\tif (flags & FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL) {\n\t\t\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t__skb_flow_dissect_ipv6(skb, flow_dissector,\n\t\t\t\t\ttarget_container, data, iph);\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan = NULL;\n\t\tstruct vlan_hdr _vlan;\n\t\t__be16 saved_vlan_tpid = proto;\n\n\t\tif (dissector_vlan == FLOW_DISSECTOR_KEY_MAX &&\n\t\t    skb && skb_vlan_tag_present(skb)) {\n\t\t\tproto = skb->protocol;\n\t\t} else {\n\t\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan),\n\t\t\t\t\t\t    data, hlen, &_vlan);\n\t\t\tif (!vlan) {\n\t\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\t\tnhoff += sizeof(*vlan);\n\t\t}\n\n\t\tif (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_NUM_OF_VLANS) &&\n\t\t    !(key_control->flags & FLOW_DIS_ENCAPSULATION)) {\n\t\t\tstruct flow_dissector_key_num_of_vlans *key_nvs;\n\n\t\t\tkey_nvs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t    FLOW_DISSECTOR_KEY_NUM_OF_VLANS,\n\t\t\t\t\t\t\t    target_container);\n\t\t\tkey_nvs->num_of_vlans++;\n\t\t}\n\n\t\tif (dissector_vlan == FLOW_DISSECTOR_KEY_MAX) {\n\t\t\tdissector_vlan = FLOW_DISSECTOR_KEY_VLAN;\n\t\t} else if (dissector_vlan == FLOW_DISSECTOR_KEY_VLAN) {\n\t\t\tdissector_vlan = FLOW_DISSECTOR_KEY_CVLAN;\n\t\t} else {\n\t\t\tfdret = FLOW_DISSECT_RET_PROTO_AGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dissector_uses_key(flow_dissector, dissector_vlan)) {\n\t\t\tkey_vlan = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     dissector_vlan,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tif (!vlan) {\n\t\t\t\tkey_vlan->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t\t\tkey_vlan->vlan_priority = skb_vlan_tag_get_prio(skb);\n\t\t\t} else {\n\t\t\t\tkey_vlan->vlan_id = ntohs(vlan->h_vlan_TCI) &\n\t\t\t\t\tVLAN_VID_MASK;\n\t\t\t\tkey_vlan->vlan_priority =\n\t\t\t\t\t(ntohs(vlan->h_vlan_TCI) &\n\t\t\t\t\t VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\n\t\t\t}\n\t\t\tkey_vlan->vlan_tpid = saved_vlan_tpid;\n\t\t\tkey_vlan->vlan_eth_type = proto;\n\t\t}\n\n\t\tfdret = FLOW_DISSECT_RET_PROTO_AGAIN;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\tu16 ppp_proto;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!is_pppoe_ses_hdr_valid(&hdr->hdr)) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tppp_proto = ntohs(hdr->proto);\n\t\tif (ppp_proto & 0x0100) {\n\t\t\tppp_proto = ppp_proto >> 8;\n\t\t\tnhoff += PPPOE_SES_HLEN - 1;\n\t\t} else {\n\t\t\tnhoff += PPPOE_SES_HLEN;\n\t\t}\n\n\t\tif (ppp_proto == PPP_IP) {\n\t\t\tproto = htons(ETH_P_IP);\n\t\t\tfdret = FLOW_DISSECT_RET_PROTO_AGAIN;\n\t\t} else if (ppp_proto == PPP_IPV6) {\n\t\t\tproto = htons(ETH_P_IPV6);\n\t\t\tfdret = FLOW_DISSECT_RET_PROTO_AGAIN;\n\t\t} else if (ppp_proto == PPP_MPLS_UC) {\n\t\t\tproto = htons(ETH_P_MPLS_UC);\n\t\t\tfdret = FLOW_DISSECT_RET_PROTO_AGAIN;\n\t\t} else if (ppp_proto == PPP_MPLS_MC) {\n\t\t\tproto = htons(ETH_P_MPLS_MC);\n\t\t\tfdret = FLOW_DISSECT_RET_PROTO_AGAIN;\n\t\t} else if (ppp_proto_is_valid(ppp_proto)) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\t} else {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dissector_uses_key(flow_dissector,\n\t\t\t\t       FLOW_DISSECTOR_KEY_PPPOE)) {\n\t\t\tstruct flow_dissector_key_pppoe *key_pppoe;\n\n\t\t\tkey_pppoe = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PPPOE,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_pppoe->session_id = hdr->hdr.sid;\n\t\t\tkey_pppoe->ppp_proto = htons(ppp_proto);\n\t\t\tkey_pppoe->type = htons(ETH_P_PPP_SES);\n\t\t}\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct tipc_basic_hdr *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr),\n\t\t\t\t\t   data, hlen, &_hdr);\n\t\tif (!hdr) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dissector_uses_key(flow_dissector,\n\t\t\t\t       FLOW_DISSECTOR_KEY_TIPC)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipckey.key = tipc_hdr_rps_key(hdr);\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC;\n\t\t}\n\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\tbreak;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC):\n\t\tfdret = __skb_flow_dissect_mpls(skb, flow_dissector,\n\t\t\t\t\t\ttarget_container, data,\n\t\t\t\t\t\tnhoff, hlen, mpls_lse,\n\t\t\t\t\t\t&mpls_el);\n\t\tnhoff += sizeof(struct mpls_label);\n\t\tmpls_lse++;\n\t\tbreak;\n\tcase htons(ETH_P_FCOE):\n\t\tif ((hlen - nhoff) < FCOE_HEADER_LEN) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\tnhoff += FCOE_HEADER_LEN;\n\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\tbreak;\n\n\tcase htons(ETH_P_ARP):\n\tcase htons(ETH_P_RARP):\n\t\tfdret = __skb_flow_dissect_arp(skb, flow_dissector,\n\t\t\t\t\t       target_container, data,\n\t\t\t\t\t       nhoff, hlen);\n\t\tbreak;\n\n\tcase htons(ETH_P_BATMAN):\n\t\tfdret = __skb_flow_dissect_batadv(skb, key_control, data,\n\t\t\t\t\t\t  &proto, &nhoff, hlen, flags);\n\t\tbreak;\n\n\tcase htons(ETH_P_1588): {\n\t\tstruct ptp_header *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\tnhoff += sizeof(struct ptp_header);\n\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\tbreak;\n\t}\n\n\tcase htons(ETH_P_PRP):\n\tcase htons(ETH_P_HSR): {\n\t\tstruct hsr_tag *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen,\n\t\t\t\t\t   &_hdr);\n\t\tif (!hdr) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\tproto = hdr->encap_proto;\n\t\tnhoff += HSR_HLEN;\n\t\tfdret = FLOW_DISSECT_RET_PROTO_AGAIN;\n\t\tbreak;\n\t}\n\n\tcase htons(ETH_P_CFM):\n\t\tfdret = __skb_flow_dissect_cfm(skb, flow_dissector,\n\t\t\t\t\t       target_container, data,\n\t\t\t\t\t       nhoff, hlen);\n\t\tbreak;\n\n\tdefault:\n\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (fdret) {\n\tcase FLOW_DISSECT_RET_OUT_GOOD:\n\t\tgoto out_good;\n\tcase FLOW_DISSECT_RET_PROTO_AGAIN:\n\t\tif (skb_flow_dissect_allowed(&num_hdrs))\n\t\t\tgoto proto_again;\n\t\tgoto out_good;\n\tcase FLOW_DISSECT_RET_CONTINUE:\n\tcase FLOW_DISSECT_RET_IPPROTO_AGAIN:\n\t\tbreak;\n\tcase FLOW_DISSECT_RET_OUT_BAD:\n\tdefault:\n\t\tgoto out_bad;\n\t}\n\nip_proto_again:\n\tfdret = FLOW_DISSECT_RET_CONTINUE;\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE:\n\t\tif (flags & FLOW_DISSECTOR_F_STOP_BEFORE_ENCAP) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\t\tbreak;\n\t\t}\n\n\t\tfdret = __skb_flow_dissect_gre(skb, key_control, flow_dissector,\n\t\t\t\t\t       target_container, data,\n\t\t\t\t\t       &proto, &nhoff, &hlen, flags);\n\t\tbreak;\n\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tfdret = FLOW_DISSECT_RET_IPPROTO_AGAIN;\n\t\tbreak;\n\t}\n\tcase NEXTHDR_FRAGMENT: {\n\t\tstruct frag_hdr _fh, *fh;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\tfh = __skb_header_pointer(skb, nhoff, sizeof(_fh),\n\t\t\t\t\t  data, hlen, &_fh);\n\n\t\tif (!fh) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_BAD;\n\t\t\tbreak;\n\t\t}\n\n\t\tkey_control->flags |= FLOW_DIS_IS_FRAGMENT;\n\n\t\tnhoff += sizeof(_fh);\n\t\tip_proto = fh->nexthdr;\n\n\t\tif (!(fh->frag_off & htons(IP6_OFFSET))) {\n\t\t\tkey_control->flags |= FLOW_DIS_FIRST_FRAG;\n\t\t\tif (flags & FLOW_DISSECTOR_F_PARSE_1ST_FRAG) {\n\t\t\t\tfdret = FLOW_DISSECT_RET_IPPROTO_AGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\tbreak;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tif (flags & FLOW_DISSECTOR_F_STOP_BEFORE_ENCAP) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\t\tbreak;\n\t\t}\n\n\t\tproto = htons(ETH_P_IP);\n\n\t\tkey_control->flags |= FLOW_DIS_ENCAPSULATION;\n\t\tif (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\t\tbreak;\n\t\t}\n\n\t\tfdret = FLOW_DISSECT_RET_PROTO_AGAIN;\n\t\tbreak;\n\n\tcase IPPROTO_IPV6:\n\t\tif (flags & FLOW_DISSECTOR_F_STOP_BEFORE_ENCAP) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\t\tbreak;\n\t\t}\n\n\t\tproto = htons(ETH_P_IPV6);\n\n\t\tkey_control->flags |= FLOW_DIS_ENCAPSULATION;\n\t\tif (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP) {\n\t\t\tfdret = FLOW_DISSECT_RET_OUT_GOOD;\n\t\t\tbreak;\n\t\t}\n\n\t\tfdret = FLOW_DISSECT_RET_PROTO_AGAIN;\n\t\tbreak;\n\n\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tfdret = FLOW_DISSECT_RET_PROTO_AGAIN;\n\t\tbreak;\n\n\tcase IPPROTO_TCP:\n\t\t__skb_flow_dissect_tcp(skb, flow_dissector, target_container,\n\t\t\t\t       data, nhoff, hlen);\n\t\tbreak;\n\n\tcase IPPROTO_ICMP:\n\tcase IPPROTO_ICMPV6:\n\t\t__skb_flow_dissect_icmp(skb, flow_dissector, target_container,\n\t\t\t\t\tdata, nhoff, hlen);\n\t\tbreak;\n\tcase IPPROTO_L2TP:\n\t\t__skb_flow_dissect_l2tpv3(skb, flow_dissector, target_container,\n\t\t\t\t\t  data, nhoff, hlen);\n\t\tbreak;\n\tcase IPPROTO_ESP:\n\t\t__skb_flow_dissect_esp(skb, flow_dissector, target_container,\n\t\t\t\t       data, nhoff, hlen);\n\t\tbreak;\n\tcase IPPROTO_AH:\n\t\t__skb_flow_dissect_ah(skb, flow_dissector, target_container,\n\t\t\t\t      data, nhoff, hlen);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!(key_control->flags & FLOW_DIS_IS_FRAGMENT))\n\t\t__skb_flow_dissect_ports(skb, flow_dissector, target_container,\n\t\t\t\t\t data, nhoff, ip_proto, hlen);\n\n\t \n\tswitch (fdret) {\n\tcase FLOW_DISSECT_RET_PROTO_AGAIN:\n\t\tif (skb_flow_dissect_allowed(&num_hdrs))\n\t\t\tgoto proto_again;\n\t\tbreak;\n\tcase FLOW_DISSECT_RET_IPPROTO_AGAIN:\n\t\tif (skb_flow_dissect_allowed(&num_hdrs))\n\t\t\tgoto ip_proto_again;\n\t\tbreak;\n\tcase FLOW_DISSECT_RET_OUT_GOOD:\n\tcase FLOW_DISSECT_RET_CONTINUE:\n\t\tbreak;\n\tcase FLOW_DISSECT_RET_OUT_BAD:\n\tdefault:\n\t\tgoto out_bad;\n\t}\n\nout_good:\n\tret = true;\n\nout:\n\tkey_control->thoff = min_t(u16, nhoff, skb ? skb->len : hlen);\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\n\treturn ret;\n\nout_bad:\n\tret = false;\n\tgoto out;\n}\nEXPORT_SYMBOL(__skb_flow_dissect);\n\nstatic siphash_aligned_key_t hashrnd;\nstatic __always_inline void __flow_hash_secret_init(void)\n{\n\tnet_get_random_once(&hashrnd, sizeof(hashrnd));\n}\n\nstatic const void *flow_keys_hash_start(const struct flow_keys *flow)\n{\n\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % SIPHASH_ALIGNMENT);\n\treturn &flow->FLOW_KEYS_HASH_START_FIELD;\n}\n\nstatic inline size_t flow_keys_hash_length(const struct flow_keys *flow)\n{\n\tsize_t diff = FLOW_KEYS_HASH_OFFSET + sizeof(flow->addrs);\n\n\tBUILD_BUG_ON((sizeof(*flow) - FLOW_KEYS_HASH_OFFSET) % sizeof(u32));\n\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v4addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v6addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_TIPC:\n\t\tdiff -= sizeof(flow->addrs.tipckey);\n\t\tbreak;\n\t}\n\treturn sizeof(*flow) - diff;\n}\n\n__be32 flow_get_u32_src(const struct flow_keys *flow)\n{\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\treturn flow->addrs.v4addrs.src;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\treturn (__force __be32)ipv6_addr_hash(\n\t\t\t&flow->addrs.v6addrs.src);\n\tcase FLOW_DISSECTOR_KEY_TIPC:\n\t\treturn flow->addrs.tipckey.key;\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(flow_get_u32_src);\n\n__be32 flow_get_u32_dst(const struct flow_keys *flow)\n{\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\treturn flow->addrs.v4addrs.dst;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\treturn (__force __be32)ipv6_addr_hash(\n\t\t\t&flow->addrs.v6addrs.dst);\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(flow_get_u32_dst);\n\n \nstatic inline void __flow_hash_consistentify(struct flow_keys *keys)\n{\n\tint addr_diff, i;\n\n\tswitch (keys->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\tif ((__force u32)keys->addrs.v4addrs.dst <\n\t\t    (__force u32)keys->addrs.v4addrs.src)\n\t\t\tswap(keys->addrs.v4addrs.src, keys->addrs.v4addrs.dst);\n\n\t\tif ((__force u16)keys->ports.dst <\n\t\t    (__force u16)keys->ports.src) {\n\t\t\tswap(keys->ports.src, keys->ports.dst);\n\t\t}\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\taddr_diff = memcmp(&keys->addrs.v6addrs.dst,\n\t\t\t\t   &keys->addrs.v6addrs.src,\n\t\t\t\t   sizeof(keys->addrs.v6addrs.dst));\n\t\tif (addr_diff < 0) {\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tswap(keys->addrs.v6addrs.src.s6_addr32[i],\n\t\t\t\t     keys->addrs.v6addrs.dst.s6_addr32[i]);\n\t\t}\n\t\tif ((__force u16)keys->ports.dst <\n\t\t    (__force u16)keys->ports.src) {\n\t\t\tswap(keys->ports.src, keys->ports.dst);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic inline u32 __flow_hash_from_keys(struct flow_keys *keys,\n\t\t\t\t\tconst siphash_key_t *keyval)\n{\n\tu32 hash;\n\n\t__flow_hash_consistentify(keys);\n\n\thash = siphash(flow_keys_hash_start(keys),\n\t\t       flow_keys_hash_length(keys), keyval);\n\tif (!hash)\n\t\thash = 1;\n\n\treturn hash;\n}\n\nu32 flow_hash_from_keys(struct flow_keys *keys)\n{\n\t__flow_hash_secret_init();\n\treturn __flow_hash_from_keys(keys, &hashrnd);\n}\nEXPORT_SYMBOL(flow_hash_from_keys);\n\nstatic inline u32 ___skb_get_hash(const struct sk_buff *skb,\n\t\t\t\t  struct flow_keys *keys,\n\t\t\t\t  const siphash_key_t *keyval)\n{\n\tskb_flow_dissect_flow_keys(skb, keys,\n\t\t\t\t   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\n\n\treturn __flow_hash_from_keys(keys, keyval);\n}\n\nstruct _flow_keys_digest_data {\n\t__be16\tn_proto;\n\tu8\tip_proto;\n\tu8\tpadding;\n\t__be32\tports;\n\t__be32\tsrc;\n\t__be32\tdst;\n};\n\nvoid make_flow_keys_digest(struct flow_keys_digest *digest,\n\t\t\t   const struct flow_keys *flow)\n{\n\tstruct _flow_keys_digest_data *data =\n\t    (struct _flow_keys_digest_data *)digest;\n\n\tBUILD_BUG_ON(sizeof(*data) > sizeof(*digest));\n\n\tmemset(digest, 0, sizeof(*digest));\n\n\tdata->n_proto = flow->basic.n_proto;\n\tdata->ip_proto = flow->basic.ip_proto;\n\tdata->ports = flow->ports.ports;\n\tdata->src = flow->addrs.v4addrs.src;\n\tdata->dst = flow->addrs.v4addrs.dst;\n}\nEXPORT_SYMBOL(make_flow_keys_digest);\n\nstatic struct flow_dissector flow_keys_dissector_symmetric __read_mostly;\n\nu32 __skb_get_hash_symmetric(const struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\n\t__flow_hash_secret_init();\n\n\tmemset(&keys, 0, sizeof(keys));\n\t__skb_flow_dissect(NULL, skb, &flow_keys_dissector_symmetric,\n\t\t\t   &keys, NULL, 0, 0, 0, 0);\n\n\treturn __flow_hash_from_keys(&keys, &hashrnd);\n}\nEXPORT_SYMBOL_GPL(__skb_get_hash_symmetric);\n\n \nvoid __skb_get_hash(struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\tu32 hash;\n\n\t__flow_hash_secret_init();\n\n\thash = ___skb_get_hash(skb, &keys, &hashrnd);\n\n\t__skb_set_sw_hash(skb, hash, flow_keys_have_l4(&keys));\n}\nEXPORT_SYMBOL(__skb_get_hash);\n\n__u32 skb_get_hash_perturb(const struct sk_buff *skb,\n\t\t\t   const siphash_key_t *perturb)\n{\n\tstruct flow_keys keys;\n\n\treturn ___skb_get_hash(skb, &keys, perturb);\n}\nEXPORT_SYMBOL(skb_get_hash_perturb);\n\nu32 __skb_get_poff(const struct sk_buff *skb, const void *data,\n\t\t   const struct flow_keys_basic *keys, int hlen)\n{\n\tu32 poff = keys->control.thoff;\n\n\t \n\tif ((keys->control.flags & FLOW_DIS_IS_FRAGMENT) &&\n\t    !(keys->control.flags & FLOW_DIS_FIRST_FRAG))\n\t\treturn poff;\n\n\tswitch (keys->basic.ip_proto) {\n\tcase IPPROTO_TCP: {\n\t\t \n\t\tconst u8 *doff;\n\t\tu8 _doff;\n\n\t\tdoff = __skb_header_pointer(skb, poff + 12, sizeof(_doff),\n\t\t\t\t\t    data, hlen, &_doff);\n\t\tif (!doff)\n\t\t\treturn poff;\n\n\t\tpoff += max_t(u32, sizeof(struct tcphdr), (*doff & 0xF0) >> 2);\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\t\tpoff += sizeof(struct udphdr);\n\t\tbreak;\n\t \n\tcase IPPROTO_ICMP:\n\t\tpoff += sizeof(struct icmphdr);\n\t\tbreak;\n\tcase IPPROTO_ICMPV6:\n\t\tpoff += sizeof(struct icmp6hdr);\n\t\tbreak;\n\tcase IPPROTO_IGMP:\n\t\tpoff += sizeof(struct igmphdr);\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n\t\tpoff += sizeof(struct dccp_hdr);\n\t\tbreak;\n\tcase IPPROTO_SCTP:\n\t\tpoff += sizeof(struct sctphdr);\n\t\tbreak;\n\t}\n\n\treturn poff;\n}\n\n \nu32 skb_get_poff(const struct sk_buff *skb)\n{\n\tstruct flow_keys_basic keys;\n\n\tif (!skb_flow_dissect_flow_keys_basic(NULL, skb, &keys,\n\t\t\t\t\t      NULL, 0, 0, 0, 0))\n\t\treturn 0;\n\n\treturn __skb_get_poff(skb, skb->data, &keys, skb_headlen(skb));\n}\n\n__u32 __get_hash_from_flowi6(const struct flowi6 *fl6, struct flow_keys *keys)\n{\n\tmemset(keys, 0, sizeof(*keys));\n\n\tmemcpy(&keys->addrs.v6addrs.src, &fl6->saddr,\n\t    sizeof(keys->addrs.v6addrs.src));\n\tmemcpy(&keys->addrs.v6addrs.dst, &fl6->daddr,\n\t    sizeof(keys->addrs.v6addrs.dst));\n\tkeys->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\tkeys->ports.src = fl6->fl6_sport;\n\tkeys->ports.dst = fl6->fl6_dport;\n\tkeys->keyid.keyid = fl6->fl6_gre_key;\n\tkeys->tags.flow_label = (__force u32)flowi6_get_flowlabel(fl6);\n\tkeys->basic.ip_proto = fl6->flowi6_proto;\n\n\treturn flow_hash_from_keys(keys);\n}\nEXPORT_SYMBOL(__get_hash_from_flowi6);\n\nstatic const struct flow_dissector_key flow_keys_dissector_keys[] = {\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_CONTROL,\n\t\t.offset = offsetof(struct flow_keys, control),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_BASIC,\n\t\t.offset = offsetof(struct flow_keys, basic),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_IPV4_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.v4addrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.v6addrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_TIPC,\n\t\t.offset = offsetof(struct flow_keys, addrs.tipckey),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_PORTS,\n\t\t.offset = offsetof(struct flow_keys, ports),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_VLAN,\n\t\t.offset = offsetof(struct flow_keys, vlan),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t.offset = offsetof(struct flow_keys, tags),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t.offset = offsetof(struct flow_keys, keyid),\n\t},\n};\n\nstatic const struct flow_dissector_key flow_keys_dissector_symmetric_keys[] = {\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_CONTROL,\n\t\t.offset = offsetof(struct flow_keys, control),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_BASIC,\n\t\t.offset = offsetof(struct flow_keys, basic),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_IPV4_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.v4addrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.v6addrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_PORTS,\n\t\t.offset = offsetof(struct flow_keys, ports),\n\t},\n};\n\nstatic const struct flow_dissector_key flow_keys_basic_dissector_keys[] = {\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_CONTROL,\n\t\t.offset = offsetof(struct flow_keys, control),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_BASIC,\n\t\t.offset = offsetof(struct flow_keys, basic),\n\t},\n};\n\nstruct flow_dissector flow_keys_dissector __read_mostly;\nEXPORT_SYMBOL(flow_keys_dissector);\n\nstruct flow_dissector flow_keys_basic_dissector __read_mostly;\nEXPORT_SYMBOL(flow_keys_basic_dissector);\n\nstatic int __init init_default_flow_dissectors(void)\n{\n\tskb_flow_dissector_init(&flow_keys_dissector,\n\t\t\t\tflow_keys_dissector_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_dissector_keys));\n\tskb_flow_dissector_init(&flow_keys_dissector_symmetric,\n\t\t\t\tflow_keys_dissector_symmetric_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_dissector_symmetric_keys));\n\tskb_flow_dissector_init(&flow_keys_basic_dissector,\n\t\t\t\tflow_keys_basic_dissector_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_basic_dissector_keys));\n\treturn 0;\n}\ncore_initcall(init_default_flow_dissectors);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}