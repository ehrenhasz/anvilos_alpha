{
  "module_name": "lwtunnel.c",
  "hash_id": "5c4bec055a322bd30383706bdd2752a84c3a0135a46917a4afebd0435df0a999",
  "original_prompt": "Ingested from linux-6.6.14/net/core/lwtunnel.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/lwtunnel.h>\n#include <linux/in.h>\n#include <linux/init.h>\n#include <linux/err.h>\n\n#include <net/lwtunnel.h>\n#include <net/rtnetlink.h>\n#include <net/ip6_fib.h>\n#include <net/rtnh.h>\n\nDEFINE_STATIC_KEY_FALSE(nf_hooks_lwtunnel_enabled);\nEXPORT_SYMBOL_GPL(nf_hooks_lwtunnel_enabled);\n\n#ifdef CONFIG_MODULES\n\nstatic const char *lwtunnel_encap_str(enum lwtunnel_encap_types encap_type)\n{\n\t \n\tswitch (encap_type) {\n\tcase LWTUNNEL_ENCAP_MPLS:\n\t\treturn \"MPLS\";\n\tcase LWTUNNEL_ENCAP_ILA:\n\t\treturn \"ILA\";\n\tcase LWTUNNEL_ENCAP_SEG6:\n\t\treturn \"SEG6\";\n\tcase LWTUNNEL_ENCAP_BPF:\n\t\treturn \"BPF\";\n\tcase LWTUNNEL_ENCAP_SEG6_LOCAL:\n\t\treturn \"SEG6LOCAL\";\n\tcase LWTUNNEL_ENCAP_RPL:\n\t\treturn \"RPL\";\n\tcase LWTUNNEL_ENCAP_IOAM6:\n\t\treturn \"IOAM6\";\n\tcase LWTUNNEL_ENCAP_XFRM:\n\t\t \n\t\treturn NULL;\n\tcase LWTUNNEL_ENCAP_IP6:\n\tcase LWTUNNEL_ENCAP_IP:\n\tcase LWTUNNEL_ENCAP_NONE:\n\tcase __LWTUNNEL_ENCAP_MAX:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n#endif  \n\nstruct lwtunnel_state *lwtunnel_state_alloc(int encap_len)\n{\n\tstruct lwtunnel_state *lws;\n\n\tlws = kzalloc(sizeof(*lws) + encap_len, GFP_ATOMIC);\n\n\treturn lws;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_state_alloc);\n\nstatic const struct lwtunnel_encap_ops __rcu *\n\t\tlwtun_encaps[LWTUNNEL_ENCAP_MAX + 1] __read_mostly;\n\nint lwtunnel_encap_add_ops(const struct lwtunnel_encap_ops *ops,\n\t\t\t   unsigned int num)\n{\n\tif (num > LWTUNNEL_ENCAP_MAX)\n\t\treturn -ERANGE;\n\n\treturn !cmpxchg((const struct lwtunnel_encap_ops **)\n\t\t\t&lwtun_encaps[num],\n\t\t\tNULL, ops) ? 0 : -1;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_encap_add_ops);\n\nint lwtunnel_encap_del_ops(const struct lwtunnel_encap_ops *ops,\n\t\t\t   unsigned int encap_type)\n{\n\tint ret;\n\n\tif (encap_type == LWTUNNEL_ENCAP_NONE ||\n\t    encap_type > LWTUNNEL_ENCAP_MAX)\n\t\treturn -ERANGE;\n\n\tret = (cmpxchg((const struct lwtunnel_encap_ops **)\n\t\t       &lwtun_encaps[encap_type],\n\t\t       ops, NULL) == ops) ? 0 : -1;\n\n\tsynchronize_net();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_encap_del_ops);\n\nint lwtunnel_build_state(struct net *net, u16 encap_type,\n\t\t\t struct nlattr *encap, unsigned int family,\n\t\t\t const void *cfg, struct lwtunnel_state **lws,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tconst struct lwtunnel_encap_ops *ops;\n\tbool found = false;\n\tint ret = -EINVAL;\n\n\tif (encap_type == LWTUNNEL_ENCAP_NONE ||\n\t    encap_type > LWTUNNEL_ENCAP_MAX) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, encap,\n\t\t\t\t    \"Unknown LWT encapsulation type\");\n\t\treturn ret;\n\t}\n\n\tret = -EOPNOTSUPP;\n\trcu_read_lock();\n\tops = rcu_dereference(lwtun_encaps[encap_type]);\n\tif (likely(ops && ops->build_state && try_module_get(ops->owner)))\n\t\tfound = true;\n\trcu_read_unlock();\n\n\tif (found) {\n\t\tret = ops->build_state(net, encap, family, cfg, lws, extack);\n\t\tif (ret)\n\t\t\tmodule_put(ops->owner);\n\t} else {\n\t\t \n\t\tNL_SET_ERR_MSG_ATTR(extack, encap,\n\t\t\t\t    \"LWT encapsulation type not supported\");\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_build_state);\n\nint lwtunnel_valid_encap_type(u16 encap_type, struct netlink_ext_ack *extack)\n{\n\tconst struct lwtunnel_encap_ops *ops;\n\tint ret = -EINVAL;\n\n\tif (encap_type == LWTUNNEL_ENCAP_NONE ||\n\t    encap_type > LWTUNNEL_ENCAP_MAX) {\n\t\tNL_SET_ERR_MSG(extack, \"Unknown lwt encapsulation type\");\n\t\treturn ret;\n\t}\n\n\trcu_read_lock();\n\tops = rcu_dereference(lwtun_encaps[encap_type]);\n\trcu_read_unlock();\n#ifdef CONFIG_MODULES\n\tif (!ops) {\n\t\tconst char *encap_type_str = lwtunnel_encap_str(encap_type);\n\n\t\tif (encap_type_str) {\n\t\t\t__rtnl_unlock();\n\t\t\trequest_module(\"rtnl-lwt-%s\", encap_type_str);\n\t\t\trtnl_lock();\n\n\t\t\trcu_read_lock();\n\t\t\tops = rcu_dereference(lwtun_encaps[encap_type]);\n\t\t\trcu_read_unlock();\n\t\t}\n\t}\n#endif\n\tret = ops ? 0 : -EOPNOTSUPP;\n\tif (ret < 0)\n\t\tNL_SET_ERR_MSG(extack, \"lwt encapsulation type not supported\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_valid_encap_type);\n\nint lwtunnel_valid_encap_type_attr(struct nlattr *attr, int remaining,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct rtnexthop *rtnh = (struct rtnexthop *)attr;\n\tstruct nlattr *nla_entype;\n\tstruct nlattr *attrs;\n\tu16 encap_type;\n\tint attrlen;\n\n\twhile (rtnh_ok(rtnh, remaining)) {\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tif (attrlen > 0) {\n\t\t\tattrs = rtnh_attrs(rtnh);\n\t\t\tnla_entype = nla_find(attrs, attrlen, RTA_ENCAP_TYPE);\n\n\t\t\tif (nla_entype) {\n\t\t\t\tif (nla_len(nla_entype) < sizeof(u16)) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid RTA_ENCAP_TYPE\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tencap_type = nla_get_u16(nla_entype);\n\n\t\t\t\tif (lwtunnel_valid_encap_type(encap_type,\n\t\t\t\t\t\t\t      extack) != 0)\n\t\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_valid_encap_type_attr);\n\nvoid lwtstate_free(struct lwtunnel_state *lws)\n{\n\tconst struct lwtunnel_encap_ops *ops = lwtun_encaps[lws->type];\n\n\tif (ops->destroy_state) {\n\t\tops->destroy_state(lws);\n\t\tkfree_rcu(lws, rcu);\n\t} else {\n\t\tkfree(lws);\n\t}\n\tmodule_put(ops->owner);\n}\nEXPORT_SYMBOL_GPL(lwtstate_free);\n\nint lwtunnel_fill_encap(struct sk_buff *skb, struct lwtunnel_state *lwtstate,\n\t\t\tint encap_attr, int encap_type_attr)\n{\n\tconst struct lwtunnel_encap_ops *ops;\n\tstruct nlattr *nest;\n\tint ret;\n\n\tif (!lwtstate)\n\t\treturn 0;\n\n\tif (lwtstate->type == LWTUNNEL_ENCAP_NONE ||\n\t    lwtstate->type > LWTUNNEL_ENCAP_MAX)\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(skb, encap_attr);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tret = -EOPNOTSUPP;\n\trcu_read_lock();\n\tops = rcu_dereference(lwtun_encaps[lwtstate->type]);\n\tif (likely(ops && ops->fill_encap))\n\t\tret = ops->fill_encap(skb, lwtstate);\n\trcu_read_unlock();\n\n\tif (ret)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\tret = nla_put_u16(skb, encap_type_attr, lwtstate->type);\n\tif (ret)\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\n\treturn (ret == -EOPNOTSUPP ? 0 : ret);\n}\nEXPORT_SYMBOL_GPL(lwtunnel_fill_encap);\n\nint lwtunnel_get_encap_size(struct lwtunnel_state *lwtstate)\n{\n\tconst struct lwtunnel_encap_ops *ops;\n\tint ret = 0;\n\n\tif (!lwtstate)\n\t\treturn 0;\n\n\tif (lwtstate->type == LWTUNNEL_ENCAP_NONE ||\n\t    lwtstate->type > LWTUNNEL_ENCAP_MAX)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tops = rcu_dereference(lwtun_encaps[lwtstate->type]);\n\tif (likely(ops && ops->get_encap_size))\n\t\tret = nla_total_size(ops->get_encap_size(lwtstate));\n\trcu_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_get_encap_size);\n\nint lwtunnel_cmp_encap(struct lwtunnel_state *a, struct lwtunnel_state *b)\n{\n\tconst struct lwtunnel_encap_ops *ops;\n\tint ret = 0;\n\n\tif (!a && !b)\n\t\treturn 0;\n\n\tif (!a || !b)\n\t\treturn 1;\n\n\tif (a->type != b->type)\n\t\treturn 1;\n\n\tif (a->type == LWTUNNEL_ENCAP_NONE ||\n\t    a->type > LWTUNNEL_ENCAP_MAX)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tops = rcu_dereference(lwtun_encaps[a->type]);\n\tif (likely(ops && ops->cmp_encap))\n\t\tret = ops->cmp_encap(a, b);\n\trcu_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_cmp_encap);\n\nint lwtunnel_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tconst struct lwtunnel_encap_ops *ops;\n\tstruct lwtunnel_state *lwtstate;\n\tint ret = -EINVAL;\n\n\tif (!dst)\n\t\tgoto drop;\n\tlwtstate = dst->lwtstate;\n\n\tif (lwtstate->type == LWTUNNEL_ENCAP_NONE ||\n\t    lwtstate->type > LWTUNNEL_ENCAP_MAX)\n\t\treturn 0;\n\n\tret = -EOPNOTSUPP;\n\trcu_read_lock();\n\tops = rcu_dereference(lwtun_encaps[lwtstate->type]);\n\tif (likely(ops && ops->output))\n\t\tret = ops->output(net, sk, skb);\n\trcu_read_unlock();\n\n\tif (ret == -EOPNOTSUPP)\n\t\tgoto drop;\n\n\treturn ret;\n\ndrop:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_output);\n\nint lwtunnel_xmit(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tconst struct lwtunnel_encap_ops *ops;\n\tstruct lwtunnel_state *lwtstate;\n\tint ret = -EINVAL;\n\n\tif (!dst)\n\t\tgoto drop;\n\n\tlwtstate = dst->lwtstate;\n\n\tif (lwtstate->type == LWTUNNEL_ENCAP_NONE ||\n\t    lwtstate->type > LWTUNNEL_ENCAP_MAX)\n\t\treturn 0;\n\n\tret = -EOPNOTSUPP;\n\trcu_read_lock();\n\tops = rcu_dereference(lwtun_encaps[lwtstate->type]);\n\tif (likely(ops && ops->xmit))\n\t\tret = ops->xmit(skb);\n\trcu_read_unlock();\n\n\tif (ret == -EOPNOTSUPP)\n\t\tgoto drop;\n\n\treturn ret;\n\ndrop:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_xmit);\n\nint lwtunnel_input(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tconst struct lwtunnel_encap_ops *ops;\n\tstruct lwtunnel_state *lwtstate;\n\tint ret = -EINVAL;\n\n\tif (!dst)\n\t\tgoto drop;\n\tlwtstate = dst->lwtstate;\n\n\tif (lwtstate->type == LWTUNNEL_ENCAP_NONE ||\n\t    lwtstate->type > LWTUNNEL_ENCAP_MAX)\n\t\treturn 0;\n\n\tret = -EOPNOTSUPP;\n\trcu_read_lock();\n\tops = rcu_dereference(lwtun_encaps[lwtstate->type]);\n\tif (likely(ops && ops->input))\n\t\tret = ops->input(skb);\n\trcu_read_unlock();\n\n\tif (ret == -EOPNOTSUPP)\n\t\tgoto drop;\n\n\treturn ret;\n\ndrop:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lwtunnel_input);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}