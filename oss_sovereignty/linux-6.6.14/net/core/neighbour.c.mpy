{
  "module_name": "neighbour.c",
  "hash_id": "0a96a70ca158b62c674ee635da4e39b6e5467558e2a9d7fdf7019716c45ec2f4",
  "original_prompt": "Ingested from linux-6.6.14/net/core/neighbour.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/kmemleak.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/socket.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n#include <linux/times.h>\n#include <net/net_namespace.h>\n#include <net/neighbour.h>\n#include <net/arp.h>\n#include <net/dst.h>\n#include <net/sock.h>\n#include <net/netevent.h>\n#include <net/netlink.h>\n#include <linux/rtnetlink.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/log2.h>\n#include <linux/inetdevice.h>\n#include <net/addrconf.h>\n\n#include <trace/events/neigh.h>\n\n#define NEIGH_DEBUG 1\n#define neigh_dbg(level, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\\\n\tif (level <= NEIGH_DEBUG)\t\t\\\n\t\tpr_debug(fmt, ##__VA_ARGS__);\t\\\n} while (0)\n\n#define PNEIGH_HASHMASK\t\t0xF\n\nstatic void neigh_timer_handler(struct timer_list *t);\nstatic void __neigh_notify(struct neighbour *n, int type, int flags,\n\t\t\t   u32 pid);\nstatic void neigh_update_notify(struct neighbour *neigh, u32 nlmsg_pid);\nstatic int pneigh_ifdown_and_unlock(struct neigh_table *tbl,\n\t\t\t\t    struct net_device *dev);\n\n#ifdef CONFIG_PROC_FS\nstatic const struct seq_operations neigh_stat_seq_ops;\n#endif\n\n \n\nstatic int neigh_blackhole(struct neighbour *neigh, struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n\treturn -ENETDOWN;\n}\n\nstatic void neigh_cleanup_and_release(struct neighbour *neigh)\n{\n\ttrace_neigh_cleanup_and_release(neigh, 0);\n\t__neigh_notify(neigh, RTM_DELNEIGH, 0, 0);\n\tcall_netevent_notifiers(NETEVENT_NEIGH_UPDATE, neigh);\n\tneigh_release(neigh);\n}\n\n \n\nunsigned long neigh_rand_reach_time(unsigned long base)\n{\n\treturn base ? get_random_u32_below(base) + (base >> 1) : 0;\n}\nEXPORT_SYMBOL(neigh_rand_reach_time);\n\nstatic void neigh_mark_dead(struct neighbour *n)\n{\n\tn->dead = 1;\n\tif (!list_empty(&n->gc_list)) {\n\t\tlist_del_init(&n->gc_list);\n\t\tatomic_dec(&n->tbl->gc_entries);\n\t}\n\tif (!list_empty(&n->managed_list))\n\t\tlist_del_init(&n->managed_list);\n}\n\nstatic void neigh_update_gc_list(struct neighbour *n)\n{\n\tbool on_gc_list, exempt_from_gc;\n\n\twrite_lock_bh(&n->tbl->lock);\n\twrite_lock(&n->lock);\n\tif (n->dead)\n\t\tgoto out;\n\n\t \n\texempt_from_gc = n->nud_state & NUD_PERMANENT ||\n\t\t\t n->flags & NTF_EXT_LEARNED;\n\ton_gc_list = !list_empty(&n->gc_list);\n\n\tif (exempt_from_gc && on_gc_list) {\n\t\tlist_del_init(&n->gc_list);\n\t\tatomic_dec(&n->tbl->gc_entries);\n\t} else if (!exempt_from_gc && !on_gc_list) {\n\t\t \n\t\tlist_add_tail(&n->gc_list, &n->tbl->gc_list);\n\t\tatomic_inc(&n->tbl->gc_entries);\n\t}\nout:\n\twrite_unlock(&n->lock);\n\twrite_unlock_bh(&n->tbl->lock);\n}\n\nstatic void neigh_update_managed_list(struct neighbour *n)\n{\n\tbool on_managed_list, add_to_managed;\n\n\twrite_lock_bh(&n->tbl->lock);\n\twrite_lock(&n->lock);\n\tif (n->dead)\n\t\tgoto out;\n\n\tadd_to_managed = n->flags & NTF_MANAGED;\n\ton_managed_list = !list_empty(&n->managed_list);\n\n\tif (!add_to_managed && on_managed_list)\n\t\tlist_del_init(&n->managed_list);\n\telse if (add_to_managed && !on_managed_list)\n\t\tlist_add_tail(&n->managed_list, &n->tbl->managed_list);\nout:\n\twrite_unlock(&n->lock);\n\twrite_unlock_bh(&n->tbl->lock);\n}\n\nstatic void neigh_update_flags(struct neighbour *neigh, u32 flags, int *notify,\n\t\t\t       bool *gc_update, bool *managed_update)\n{\n\tu32 ndm_flags, old_flags = neigh->flags;\n\n\tif (!(flags & NEIGH_UPDATE_F_ADMIN))\n\t\treturn;\n\n\tndm_flags  = (flags & NEIGH_UPDATE_F_EXT_LEARNED) ? NTF_EXT_LEARNED : 0;\n\tndm_flags |= (flags & NEIGH_UPDATE_F_MANAGED) ? NTF_MANAGED : 0;\n\n\tif ((old_flags ^ ndm_flags) & NTF_EXT_LEARNED) {\n\t\tif (ndm_flags & NTF_EXT_LEARNED)\n\t\t\tneigh->flags |= NTF_EXT_LEARNED;\n\t\telse\n\t\t\tneigh->flags &= ~NTF_EXT_LEARNED;\n\t\t*notify = 1;\n\t\t*gc_update = true;\n\t}\n\tif ((old_flags ^ ndm_flags) & NTF_MANAGED) {\n\t\tif (ndm_flags & NTF_MANAGED)\n\t\t\tneigh->flags |= NTF_MANAGED;\n\t\telse\n\t\t\tneigh->flags &= ~NTF_MANAGED;\n\t\t*notify = 1;\n\t\t*managed_update = true;\n\t}\n}\n\nstatic bool neigh_del(struct neighbour *n, struct neighbour __rcu **np,\n\t\t      struct neigh_table *tbl)\n{\n\tbool retval = false;\n\n\twrite_lock(&n->lock);\n\tif (refcount_read(&n->refcnt) == 1) {\n\t\tstruct neighbour *neigh;\n\n\t\tneigh = rcu_dereference_protected(n->next,\n\t\t\t\t\t\t  lockdep_is_held(&tbl->lock));\n\t\trcu_assign_pointer(*np, neigh);\n\t\tneigh_mark_dead(n);\n\t\tretval = true;\n\t}\n\twrite_unlock(&n->lock);\n\tif (retval)\n\t\tneigh_cleanup_and_release(n);\n\treturn retval;\n}\n\nbool neigh_remove_one(struct neighbour *ndel, struct neigh_table *tbl)\n{\n\tstruct neigh_hash_table *nht;\n\tvoid *pkey = ndel->primary_key;\n\tu32 hash_val;\n\tstruct neighbour *n;\n\tstruct neighbour __rcu **np;\n\n\tnht = rcu_dereference_protected(tbl->nht,\n\t\t\t\t\tlockdep_is_held(&tbl->lock));\n\thash_val = tbl->hash(pkey, ndel->dev, nht->hash_rnd);\n\thash_val = hash_val >> (32 - nht->hash_shift);\n\n\tnp = &nht->hash_buckets[hash_val];\n\twhile ((n = rcu_dereference_protected(*np,\n\t\t\t\t\t      lockdep_is_held(&tbl->lock)))) {\n\t\tif (n == ndel)\n\t\t\treturn neigh_del(n, np, tbl);\n\t\tnp = &n->next;\n\t}\n\treturn false;\n}\n\nstatic int neigh_forced_gc(struct neigh_table *tbl)\n{\n\tint max_clean = atomic_read(&tbl->gc_entries) -\n\t\t\tREAD_ONCE(tbl->gc_thresh2);\n\tu64 tmax = ktime_get_ns() + NSEC_PER_MSEC;\n\tunsigned long tref = jiffies - 5 * HZ;\n\tstruct neighbour *n, *tmp;\n\tint shrunk = 0;\n\tint loop = 0;\n\n\tNEIGH_CACHE_STAT_INC(tbl, forced_gc_runs);\n\n\twrite_lock_bh(&tbl->lock);\n\n\tlist_for_each_entry_safe(n, tmp, &tbl->gc_list, gc_list) {\n\t\tif (refcount_read(&n->refcnt) == 1) {\n\t\t\tbool remove = false;\n\n\t\t\twrite_lock(&n->lock);\n\t\t\tif ((n->nud_state == NUD_FAILED) ||\n\t\t\t    (n->nud_state == NUD_NOARP) ||\n\t\t\t    (tbl->is_multicast &&\n\t\t\t     tbl->is_multicast(n->primary_key)) ||\n\t\t\t    !time_in_range(n->updated, tref, jiffies))\n\t\t\t\tremove = true;\n\t\t\twrite_unlock(&n->lock);\n\n\t\t\tif (remove && neigh_remove_one(n, tbl))\n\t\t\t\tshrunk++;\n\t\t\tif (shrunk >= max_clean)\n\t\t\t\tbreak;\n\t\t\tif (++loop == 16) {\n\t\t\t\tif (ktime_get_ns() > tmax)\n\t\t\t\t\tgoto unlock;\n\t\t\t\tloop = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tWRITE_ONCE(tbl->last_flush, jiffies);\nunlock:\n\twrite_unlock_bh(&tbl->lock);\n\n\treturn shrunk;\n}\n\nstatic void neigh_add_timer(struct neighbour *n, unsigned long when)\n{\n\t \n\tunsigned long mint = jiffies - (LONG_MAX - 86400 * HZ);\n\n\tneigh_hold(n);\n\tif (!time_in_range(n->confirmed, mint, jiffies))\n\t\tn->confirmed = mint;\n\tif (time_before(n->used, n->confirmed))\n\t\tn->used = n->confirmed;\n\tif (unlikely(mod_timer(&n->timer, when))) {\n\t\tprintk(\"NEIGH: BUG, double timer add, state is %x\\n\",\n\t\t       n->nud_state);\n\t\tdump_stack();\n\t}\n}\n\nstatic int neigh_del_timer(struct neighbour *n)\n{\n\tif ((n->nud_state & NUD_IN_TIMER) &&\n\t    del_timer(&n->timer)) {\n\t\tneigh_release(n);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic struct neigh_parms *neigh_get_dev_parms_rcu(struct net_device *dev,\n\t\t\t\t\t\t   int family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn __in_dev_arp_parms_get_rcu(dev);\n\tcase AF_INET6:\n\t\treturn __in6_dev_nd_parms_get_rcu(dev);\n\t}\n\treturn NULL;\n}\n\nstatic void neigh_parms_qlen_dec(struct net_device *dev, int family)\n{\n\tstruct neigh_parms *p;\n\n\trcu_read_lock();\n\tp = neigh_get_dev_parms_rcu(dev, family);\n\tif (p)\n\t\tp->qlen--;\n\trcu_read_unlock();\n}\n\nstatic void pneigh_queue_purge(struct sk_buff_head *list, struct net *net,\n\t\t\t       int family)\n{\n\tstruct sk_buff_head tmp;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\n\tskb_queue_head_init(&tmp);\n\tspin_lock_irqsave(&list->lock, flags);\n\tskb = skb_peek(list);\n\twhile (skb != NULL) {\n\t\tstruct sk_buff *skb_next = skb_peek_next(skb, list);\n\t\tstruct net_device *dev = skb->dev;\n\n\t\tif (net == NULL || net_eq(dev_net(dev), net)) {\n\t\t\tneigh_parms_qlen_dec(dev, family);\n\t\t\t__skb_unlink(skb, list);\n\t\t\t__skb_queue_tail(&tmp, skb);\n\t\t}\n\t\tskb = skb_next;\n\t}\n\tspin_unlock_irqrestore(&list->lock, flags);\n\n\twhile ((skb = __skb_dequeue(&tmp))) {\n\t\tdev_put(skb->dev);\n\t\tkfree_skb(skb);\n\t}\n}\n\nstatic void neigh_flush_dev(struct neigh_table *tbl, struct net_device *dev,\n\t\t\t    bool skip_perm)\n{\n\tint i;\n\tstruct neigh_hash_table *nht;\n\n\tnht = rcu_dereference_protected(tbl->nht,\n\t\t\t\t\tlockdep_is_held(&tbl->lock));\n\n\tfor (i = 0; i < (1 << nht->hash_shift); i++) {\n\t\tstruct neighbour *n;\n\t\tstruct neighbour __rcu **np = &nht->hash_buckets[i];\n\n\t\twhile ((n = rcu_dereference_protected(*np,\n\t\t\t\t\tlockdep_is_held(&tbl->lock))) != NULL) {\n\t\t\tif (dev && n->dev != dev) {\n\t\t\t\tnp = &n->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (skip_perm && n->nud_state & NUD_PERMANENT) {\n\t\t\t\tnp = &n->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trcu_assign_pointer(*np,\n\t\t\t\t   rcu_dereference_protected(n->next,\n\t\t\t\t\t\tlockdep_is_held(&tbl->lock)));\n\t\t\twrite_lock(&n->lock);\n\t\t\tneigh_del_timer(n);\n\t\t\tneigh_mark_dead(n);\n\t\t\tif (refcount_read(&n->refcnt) != 1) {\n\t\t\t\t \n\t\t\t\t__skb_queue_purge(&n->arp_queue);\n\t\t\t\tn->arp_queue_len_bytes = 0;\n\t\t\t\tWRITE_ONCE(n->output, neigh_blackhole);\n\t\t\t\tif (n->nud_state & NUD_VALID)\n\t\t\t\t\tn->nud_state = NUD_NOARP;\n\t\t\t\telse\n\t\t\t\t\tn->nud_state = NUD_NONE;\n\t\t\t\tneigh_dbg(2, \"neigh %p is stray\\n\", n);\n\t\t\t}\n\t\t\twrite_unlock(&n->lock);\n\t\t\tneigh_cleanup_and_release(n);\n\t\t}\n\t}\n}\n\nvoid neigh_changeaddr(struct neigh_table *tbl, struct net_device *dev)\n{\n\twrite_lock_bh(&tbl->lock);\n\tneigh_flush_dev(tbl, dev, false);\n\twrite_unlock_bh(&tbl->lock);\n}\nEXPORT_SYMBOL(neigh_changeaddr);\n\nstatic int __neigh_ifdown(struct neigh_table *tbl, struct net_device *dev,\n\t\t\t  bool skip_perm)\n{\n\twrite_lock_bh(&tbl->lock);\n\tneigh_flush_dev(tbl, dev, skip_perm);\n\tpneigh_ifdown_and_unlock(tbl, dev);\n\tpneigh_queue_purge(&tbl->proxy_queue, dev ? dev_net(dev) : NULL,\n\t\t\t   tbl->family);\n\tif (skb_queue_empty_lockless(&tbl->proxy_queue))\n\t\tdel_timer_sync(&tbl->proxy_timer);\n\treturn 0;\n}\n\nint neigh_carrier_down(struct neigh_table *tbl, struct net_device *dev)\n{\n\t__neigh_ifdown(tbl, dev, true);\n\treturn 0;\n}\nEXPORT_SYMBOL(neigh_carrier_down);\n\nint neigh_ifdown(struct neigh_table *tbl, struct net_device *dev)\n{\n\t__neigh_ifdown(tbl, dev, false);\n\treturn 0;\n}\nEXPORT_SYMBOL(neigh_ifdown);\n\nstatic struct neighbour *neigh_alloc(struct neigh_table *tbl,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     u32 flags, bool exempt_from_gc)\n{\n\tstruct neighbour *n = NULL;\n\tunsigned long now = jiffies;\n\tint entries, gc_thresh3;\n\n\tif (exempt_from_gc)\n\t\tgoto do_alloc;\n\n\tentries = atomic_inc_return(&tbl->gc_entries) - 1;\n\tgc_thresh3 = READ_ONCE(tbl->gc_thresh3);\n\tif (entries >= gc_thresh3 ||\n\t    (entries >= READ_ONCE(tbl->gc_thresh2) &&\n\t     time_after(now, READ_ONCE(tbl->last_flush) + 5 * HZ))) {\n\t\tif (!neigh_forced_gc(tbl) && entries >= gc_thresh3) {\n\t\t\tnet_info_ratelimited(\"%s: neighbor table overflow!\\n\",\n\t\t\t\t\t     tbl->id);\n\t\t\tNEIGH_CACHE_STAT_INC(tbl, table_fulls);\n\t\t\tgoto out_entries;\n\t\t}\n\t}\n\ndo_alloc:\n\tn = kzalloc(tbl->entry_size + dev->neigh_priv_len, GFP_ATOMIC);\n\tif (!n)\n\t\tgoto out_entries;\n\n\t__skb_queue_head_init(&n->arp_queue);\n\trwlock_init(&n->lock);\n\tseqlock_init(&n->ha_lock);\n\tn->updated\t  = n->used = now;\n\tn->nud_state\t  = NUD_NONE;\n\tn->output\t  = neigh_blackhole;\n\tn->flags\t  = flags;\n\tseqlock_init(&n->hh.hh_lock);\n\tn->parms\t  = neigh_parms_clone(&tbl->parms);\n\ttimer_setup(&n->timer, neigh_timer_handler, 0);\n\n\tNEIGH_CACHE_STAT_INC(tbl, allocs);\n\tn->tbl\t\t  = tbl;\n\trefcount_set(&n->refcnt, 1);\n\tn->dead\t\t  = 1;\n\tINIT_LIST_HEAD(&n->gc_list);\n\tINIT_LIST_HEAD(&n->managed_list);\n\n\tatomic_inc(&tbl->entries);\nout:\n\treturn n;\n\nout_entries:\n\tif (!exempt_from_gc)\n\t\tatomic_dec(&tbl->gc_entries);\n\tgoto out;\n}\n\nstatic void neigh_get_hash_rnd(u32 *x)\n{\n\t*x = get_random_u32() | 1;\n}\n\nstatic struct neigh_hash_table *neigh_hash_alloc(unsigned int shift)\n{\n\tsize_t size = (1 << shift) * sizeof(struct neighbour *);\n\tstruct neigh_hash_table *ret;\n\tstruct neighbour __rcu **buckets;\n\tint i;\n\n\tret = kmalloc(sizeof(*ret), GFP_ATOMIC);\n\tif (!ret)\n\t\treturn NULL;\n\tif (size <= PAGE_SIZE) {\n\t\tbuckets = kzalloc(size, GFP_ATOMIC);\n\t} else {\n\t\tbuckets = (struct neighbour __rcu **)\n\t\t\t  __get_free_pages(GFP_ATOMIC | __GFP_ZERO,\n\t\t\t\t\t   get_order(size));\n\t\tkmemleak_alloc(buckets, size, 1, GFP_ATOMIC);\n\t}\n\tif (!buckets) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\tret->hash_buckets = buckets;\n\tret->hash_shift = shift;\n\tfor (i = 0; i < NEIGH_NUM_HASH_RND; i++)\n\t\tneigh_get_hash_rnd(&ret->hash_rnd[i]);\n\treturn ret;\n}\n\nstatic void neigh_hash_free_rcu(struct rcu_head *head)\n{\n\tstruct neigh_hash_table *nht = container_of(head,\n\t\t\t\t\t\t    struct neigh_hash_table,\n\t\t\t\t\t\t    rcu);\n\tsize_t size = (1 << nht->hash_shift) * sizeof(struct neighbour *);\n\tstruct neighbour __rcu **buckets = nht->hash_buckets;\n\n\tif (size <= PAGE_SIZE) {\n\t\tkfree(buckets);\n\t} else {\n\t\tkmemleak_free(buckets);\n\t\tfree_pages((unsigned long)buckets, get_order(size));\n\t}\n\tkfree(nht);\n}\n\nstatic struct neigh_hash_table *neigh_hash_grow(struct neigh_table *tbl,\n\t\t\t\t\t\tunsigned long new_shift)\n{\n\tunsigned int i, hash;\n\tstruct neigh_hash_table *new_nht, *old_nht;\n\n\tNEIGH_CACHE_STAT_INC(tbl, hash_grows);\n\n\told_nht = rcu_dereference_protected(tbl->nht,\n\t\t\t\t\t    lockdep_is_held(&tbl->lock));\n\tnew_nht = neigh_hash_alloc(new_shift);\n\tif (!new_nht)\n\t\treturn old_nht;\n\n\tfor (i = 0; i < (1 << old_nht->hash_shift); i++) {\n\t\tstruct neighbour *n, *next;\n\n\t\tfor (n = rcu_dereference_protected(old_nht->hash_buckets[i],\n\t\t\t\t\t\t   lockdep_is_held(&tbl->lock));\n\t\t     n != NULL;\n\t\t     n = next) {\n\t\t\thash = tbl->hash(n->primary_key, n->dev,\n\t\t\t\t\t new_nht->hash_rnd);\n\n\t\t\thash >>= (32 - new_nht->hash_shift);\n\t\t\tnext = rcu_dereference_protected(n->next,\n\t\t\t\t\t\tlockdep_is_held(&tbl->lock));\n\n\t\t\trcu_assign_pointer(n->next,\n\t\t\t\t\t   rcu_dereference_protected(\n\t\t\t\t\t\tnew_nht->hash_buckets[hash],\n\t\t\t\t\t\tlockdep_is_held(&tbl->lock)));\n\t\t\trcu_assign_pointer(new_nht->hash_buckets[hash], n);\n\t\t}\n\t}\n\n\trcu_assign_pointer(tbl->nht, new_nht);\n\tcall_rcu(&old_nht->rcu, neigh_hash_free_rcu);\n\treturn new_nht;\n}\n\nstruct neighbour *neigh_lookup(struct neigh_table *tbl, const void *pkey,\n\t\t\t       struct net_device *dev)\n{\n\tstruct neighbour *n;\n\n\tNEIGH_CACHE_STAT_INC(tbl, lookups);\n\n\trcu_read_lock();\n\tn = __neigh_lookup_noref(tbl, pkey, dev);\n\tif (n) {\n\t\tif (!refcount_inc_not_zero(&n->refcnt))\n\t\t\tn = NULL;\n\t\tNEIGH_CACHE_STAT_INC(tbl, hits);\n\t}\n\n\trcu_read_unlock();\n\treturn n;\n}\nEXPORT_SYMBOL(neigh_lookup);\n\nstatic struct neighbour *\n___neigh_create(struct neigh_table *tbl, const void *pkey,\n\t\tstruct net_device *dev, u32 flags,\n\t\tbool exempt_from_gc, bool want_ref)\n{\n\tu32 hash_val, key_len = tbl->key_len;\n\tstruct neighbour *n1, *rc, *n;\n\tstruct neigh_hash_table *nht;\n\tint error;\n\n\tn = neigh_alloc(tbl, dev, flags, exempt_from_gc);\n\ttrace_neigh_create(tbl, dev, pkey, n, exempt_from_gc);\n\tif (!n) {\n\t\trc = ERR_PTR(-ENOBUFS);\n\t\tgoto out;\n\t}\n\n\tmemcpy(n->primary_key, pkey, key_len);\n\tn->dev = dev;\n\tnetdev_hold(dev, &n->dev_tracker, GFP_ATOMIC);\n\n\t \n\tif (tbl->constructor &&\t(error = tbl->constructor(n)) < 0) {\n\t\trc = ERR_PTR(error);\n\t\tgoto out_neigh_release;\n\t}\n\n\tif (dev->netdev_ops->ndo_neigh_construct) {\n\t\terror = dev->netdev_ops->ndo_neigh_construct(dev, n);\n\t\tif (error < 0) {\n\t\t\trc = ERR_PTR(error);\n\t\t\tgoto out_neigh_release;\n\t\t}\n\t}\n\n\t \n\tif (n->parms->neigh_setup &&\n\t    (error = n->parms->neigh_setup(n)) < 0) {\n\t\trc = ERR_PTR(error);\n\t\tgoto out_neigh_release;\n\t}\n\n\tn->confirmed = jiffies - (NEIGH_VAR(n->parms, BASE_REACHABLE_TIME) << 1);\n\n\twrite_lock_bh(&tbl->lock);\n\tnht = rcu_dereference_protected(tbl->nht,\n\t\t\t\t\tlockdep_is_held(&tbl->lock));\n\n\tif (atomic_read(&tbl->entries) > (1 << nht->hash_shift))\n\t\tnht = neigh_hash_grow(tbl, nht->hash_shift + 1);\n\n\thash_val = tbl->hash(n->primary_key, dev, nht->hash_rnd) >> (32 - nht->hash_shift);\n\n\tif (n->parms->dead) {\n\t\trc = ERR_PTR(-EINVAL);\n\t\tgoto out_tbl_unlock;\n\t}\n\n\tfor (n1 = rcu_dereference_protected(nht->hash_buckets[hash_val],\n\t\t\t\t\t    lockdep_is_held(&tbl->lock));\n\t     n1 != NULL;\n\t     n1 = rcu_dereference_protected(n1->next,\n\t\t\tlockdep_is_held(&tbl->lock))) {\n\t\tif (dev == n1->dev && !memcmp(n1->primary_key, n->primary_key, key_len)) {\n\t\t\tif (want_ref)\n\t\t\t\tneigh_hold(n1);\n\t\t\trc = n1;\n\t\t\tgoto out_tbl_unlock;\n\t\t}\n\t}\n\n\tn->dead = 0;\n\tif (!exempt_from_gc)\n\t\tlist_add_tail(&n->gc_list, &n->tbl->gc_list);\n\tif (n->flags & NTF_MANAGED)\n\t\tlist_add_tail(&n->managed_list, &n->tbl->managed_list);\n\tif (want_ref)\n\t\tneigh_hold(n);\n\trcu_assign_pointer(n->next,\n\t\t\t   rcu_dereference_protected(nht->hash_buckets[hash_val],\n\t\t\t\t\t\t     lockdep_is_held(&tbl->lock)));\n\trcu_assign_pointer(nht->hash_buckets[hash_val], n);\n\twrite_unlock_bh(&tbl->lock);\n\tneigh_dbg(2, \"neigh %p is created\\n\", n);\n\trc = n;\nout:\n\treturn rc;\nout_tbl_unlock:\n\twrite_unlock_bh(&tbl->lock);\nout_neigh_release:\n\tif (!exempt_from_gc)\n\t\tatomic_dec(&tbl->gc_entries);\n\tneigh_release(n);\n\tgoto out;\n}\n\nstruct neighbour *__neigh_create(struct neigh_table *tbl, const void *pkey,\n\t\t\t\t struct net_device *dev, bool want_ref)\n{\n\treturn ___neigh_create(tbl, pkey, dev, 0, false, want_ref);\n}\nEXPORT_SYMBOL(__neigh_create);\n\nstatic u32 pneigh_hash(const void *pkey, unsigned int key_len)\n{\n\tu32 hash_val = *(u32 *)(pkey + key_len - 4);\n\thash_val ^= (hash_val >> 16);\n\thash_val ^= hash_val >> 8;\n\thash_val ^= hash_val >> 4;\n\thash_val &= PNEIGH_HASHMASK;\n\treturn hash_val;\n}\n\nstatic struct pneigh_entry *__pneigh_lookup_1(struct pneigh_entry *n,\n\t\t\t\t\t      struct net *net,\n\t\t\t\t\t      const void *pkey,\n\t\t\t\t\t      unsigned int key_len,\n\t\t\t\t\t      struct net_device *dev)\n{\n\twhile (n) {\n\t\tif (!memcmp(n->key, pkey, key_len) &&\n\t\t    net_eq(pneigh_net(n), net) &&\n\t\t    (n->dev == dev || !n->dev))\n\t\t\treturn n;\n\t\tn = n->next;\n\t}\n\treturn NULL;\n}\n\nstruct pneigh_entry *__pneigh_lookup(struct neigh_table *tbl,\n\t\tstruct net *net, const void *pkey, struct net_device *dev)\n{\n\tunsigned int key_len = tbl->key_len;\n\tu32 hash_val = pneigh_hash(pkey, key_len);\n\n\treturn __pneigh_lookup_1(tbl->phash_buckets[hash_val],\n\t\t\t\t net, pkey, key_len, dev);\n}\nEXPORT_SYMBOL_GPL(__pneigh_lookup);\n\nstruct pneigh_entry * pneigh_lookup(struct neigh_table *tbl,\n\t\t\t\t    struct net *net, const void *pkey,\n\t\t\t\t    struct net_device *dev, int creat)\n{\n\tstruct pneigh_entry *n;\n\tunsigned int key_len = tbl->key_len;\n\tu32 hash_val = pneigh_hash(pkey, key_len);\n\n\tread_lock_bh(&tbl->lock);\n\tn = __pneigh_lookup_1(tbl->phash_buckets[hash_val],\n\t\t\t      net, pkey, key_len, dev);\n\tread_unlock_bh(&tbl->lock);\n\n\tif (n || !creat)\n\t\tgoto out;\n\n\tASSERT_RTNL();\n\n\tn = kzalloc(sizeof(*n) + key_len, GFP_KERNEL);\n\tif (!n)\n\t\tgoto out;\n\n\twrite_pnet(&n->net, net);\n\tmemcpy(n->key, pkey, key_len);\n\tn->dev = dev;\n\tnetdev_hold(dev, &n->dev_tracker, GFP_KERNEL);\n\n\tif (tbl->pconstructor && tbl->pconstructor(n)) {\n\t\tnetdev_put(dev, &n->dev_tracker);\n\t\tkfree(n);\n\t\tn = NULL;\n\t\tgoto out;\n\t}\n\n\twrite_lock_bh(&tbl->lock);\n\tn->next = tbl->phash_buckets[hash_val];\n\ttbl->phash_buckets[hash_val] = n;\n\twrite_unlock_bh(&tbl->lock);\nout:\n\treturn n;\n}\nEXPORT_SYMBOL(pneigh_lookup);\n\n\nint pneigh_delete(struct neigh_table *tbl, struct net *net, const void *pkey,\n\t\t  struct net_device *dev)\n{\n\tstruct pneigh_entry *n, **np;\n\tunsigned int key_len = tbl->key_len;\n\tu32 hash_val = pneigh_hash(pkey, key_len);\n\n\twrite_lock_bh(&tbl->lock);\n\tfor (np = &tbl->phash_buckets[hash_val]; (n = *np) != NULL;\n\t     np = &n->next) {\n\t\tif (!memcmp(n->key, pkey, key_len) && n->dev == dev &&\n\t\t    net_eq(pneigh_net(n), net)) {\n\t\t\t*np = n->next;\n\t\t\twrite_unlock_bh(&tbl->lock);\n\t\t\tif (tbl->pdestructor)\n\t\t\t\ttbl->pdestructor(n);\n\t\t\tnetdev_put(n->dev, &n->dev_tracker);\n\t\t\tkfree(n);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twrite_unlock_bh(&tbl->lock);\n\treturn -ENOENT;\n}\n\nstatic int pneigh_ifdown_and_unlock(struct neigh_table *tbl,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct pneigh_entry *n, **np, *freelist = NULL;\n\tu32 h;\n\n\tfor (h = 0; h <= PNEIGH_HASHMASK; h++) {\n\t\tnp = &tbl->phash_buckets[h];\n\t\twhile ((n = *np) != NULL) {\n\t\t\tif (!dev || n->dev == dev) {\n\t\t\t\t*np = n->next;\n\t\t\t\tn->next = freelist;\n\t\t\t\tfreelist = n;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnp = &n->next;\n\t\t}\n\t}\n\twrite_unlock_bh(&tbl->lock);\n\twhile ((n = freelist)) {\n\t\tfreelist = n->next;\n\t\tn->next = NULL;\n\t\tif (tbl->pdestructor)\n\t\t\ttbl->pdestructor(n);\n\t\tnetdev_put(n->dev, &n->dev_tracker);\n\t\tkfree(n);\n\t}\n\treturn -ENOENT;\n}\n\nstatic void neigh_parms_destroy(struct neigh_parms *parms);\n\nstatic inline void neigh_parms_put(struct neigh_parms *parms)\n{\n\tif (refcount_dec_and_test(&parms->refcnt))\n\t\tneigh_parms_destroy(parms);\n}\n\n \nvoid neigh_destroy(struct neighbour *neigh)\n{\n\tstruct net_device *dev = neigh->dev;\n\n\tNEIGH_CACHE_STAT_INC(neigh->tbl, destroys);\n\n\tif (!neigh->dead) {\n\t\tpr_warn(\"Destroying alive neighbour %p\\n\", neigh);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tif (neigh_del_timer(neigh))\n\t\tpr_warn(\"Impossible event\\n\");\n\n\twrite_lock_bh(&neigh->lock);\n\t__skb_queue_purge(&neigh->arp_queue);\n\twrite_unlock_bh(&neigh->lock);\n\tneigh->arp_queue_len_bytes = 0;\n\n\tif (dev->netdev_ops->ndo_neigh_destroy)\n\t\tdev->netdev_ops->ndo_neigh_destroy(dev, neigh);\n\n\tnetdev_put(dev, &neigh->dev_tracker);\n\tneigh_parms_put(neigh->parms);\n\n\tneigh_dbg(2, \"neigh %p is destroyed\\n\", neigh);\n\n\tatomic_dec(&neigh->tbl->entries);\n\tkfree_rcu(neigh, rcu);\n}\nEXPORT_SYMBOL(neigh_destroy);\n\n \nstatic void neigh_suspect(struct neighbour *neigh)\n{\n\tneigh_dbg(2, \"neigh %p is suspected\\n\", neigh);\n\n\tWRITE_ONCE(neigh->output, neigh->ops->output);\n}\n\n \nstatic void neigh_connect(struct neighbour *neigh)\n{\n\tneigh_dbg(2, \"neigh %p is connected\\n\", neigh);\n\n\tWRITE_ONCE(neigh->output, neigh->ops->connected_output);\n}\n\nstatic void neigh_periodic_work(struct work_struct *work)\n{\n\tstruct neigh_table *tbl = container_of(work, struct neigh_table, gc_work.work);\n\tstruct neighbour *n;\n\tstruct neighbour __rcu **np;\n\tunsigned int i;\n\tstruct neigh_hash_table *nht;\n\n\tNEIGH_CACHE_STAT_INC(tbl, periodic_gc_runs);\n\n\twrite_lock_bh(&tbl->lock);\n\tnht = rcu_dereference_protected(tbl->nht,\n\t\t\t\t\tlockdep_is_held(&tbl->lock));\n\n\t \n\n\tif (time_after(jiffies, tbl->last_rand + 300 * HZ)) {\n\t\tstruct neigh_parms *p;\n\n\t\tWRITE_ONCE(tbl->last_rand, jiffies);\n\t\tlist_for_each_entry(p, &tbl->parms_list, list)\n\t\t\tp->reachable_time =\n\t\t\t\tneigh_rand_reach_time(NEIGH_VAR(p, BASE_REACHABLE_TIME));\n\t}\n\n\tif (atomic_read(&tbl->entries) < READ_ONCE(tbl->gc_thresh1))\n\t\tgoto out;\n\n\tfor (i = 0 ; i < (1 << nht->hash_shift); i++) {\n\t\tnp = &nht->hash_buckets[i];\n\n\t\twhile ((n = rcu_dereference_protected(*np,\n\t\t\t\tlockdep_is_held(&tbl->lock))) != NULL) {\n\t\t\tunsigned int state;\n\n\t\t\twrite_lock(&n->lock);\n\n\t\t\tstate = n->nud_state;\n\t\t\tif ((state & (NUD_PERMANENT | NUD_IN_TIMER)) ||\n\t\t\t    (n->flags & NTF_EXT_LEARNED)) {\n\t\t\t\twrite_unlock(&n->lock);\n\t\t\t\tgoto next_elt;\n\t\t\t}\n\n\t\t\tif (time_before(n->used, n->confirmed) &&\n\t\t\t    time_is_before_eq_jiffies(n->confirmed))\n\t\t\t\tn->used = n->confirmed;\n\n\t\t\tif (refcount_read(&n->refcnt) == 1 &&\n\t\t\t    (state == NUD_FAILED ||\n\t\t\t     !time_in_range_open(jiffies, n->used,\n\t\t\t\t\t\t n->used + NEIGH_VAR(n->parms, GC_STALETIME)))) {\n\t\t\t\trcu_assign_pointer(*np,\n\t\t\t\t\trcu_dereference_protected(n->next,\n\t\t\t\t\t\tlockdep_is_held(&tbl->lock)));\n\t\t\t\tneigh_mark_dead(n);\n\t\t\t\twrite_unlock(&n->lock);\n\t\t\t\tneigh_cleanup_and_release(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twrite_unlock(&n->lock);\n\nnext_elt:\n\t\t\tnp = &n->next;\n\t\t}\n\t\t \n\t\twrite_unlock_bh(&tbl->lock);\n\t\tcond_resched();\n\t\twrite_lock_bh(&tbl->lock);\n\t\tnht = rcu_dereference_protected(tbl->nht,\n\t\t\t\t\t\tlockdep_is_held(&tbl->lock));\n\t}\nout:\n\t \n\tqueue_delayed_work(system_power_efficient_wq, &tbl->gc_work,\n\t\t\t      NEIGH_VAR(&tbl->parms, BASE_REACHABLE_TIME) >> 1);\n\twrite_unlock_bh(&tbl->lock);\n}\n\nstatic __inline__ int neigh_max_probes(struct neighbour *n)\n{\n\tstruct neigh_parms *p = n->parms;\n\treturn NEIGH_VAR(p, UCAST_PROBES) + NEIGH_VAR(p, APP_PROBES) +\n\t       (n->nud_state & NUD_PROBE ? NEIGH_VAR(p, MCAST_REPROBES) :\n\t        NEIGH_VAR(p, MCAST_PROBES));\n}\n\nstatic void neigh_invalidate(struct neighbour *neigh)\n\t__releases(neigh->lock)\n\t__acquires(neigh->lock)\n{\n\tstruct sk_buff *skb;\n\n\tNEIGH_CACHE_STAT_INC(neigh->tbl, res_failed);\n\tneigh_dbg(2, \"neigh %p is failed\\n\", neigh);\n\tneigh->updated = jiffies;\n\n\t \n\twhile (neigh->nud_state == NUD_FAILED &&\n\t       (skb = __skb_dequeue(&neigh->arp_queue)) != NULL) {\n\t\twrite_unlock(&neigh->lock);\n\t\tneigh->ops->error_report(neigh, skb);\n\t\twrite_lock(&neigh->lock);\n\t}\n\t__skb_queue_purge(&neigh->arp_queue);\n\tneigh->arp_queue_len_bytes = 0;\n}\n\nstatic void neigh_probe(struct neighbour *neigh)\n\t__releases(neigh->lock)\n{\n\tstruct sk_buff *skb = skb_peek_tail(&neigh->arp_queue);\n\t \n\tif (skb)\n\t\tskb = skb_clone(skb, GFP_ATOMIC);\n\twrite_unlock(&neigh->lock);\n\tif (neigh->ops->solicit)\n\t\tneigh->ops->solicit(neigh, skb);\n\tatomic_inc(&neigh->probes);\n\tconsume_skb(skb);\n}\n\n \n\nstatic void neigh_timer_handler(struct timer_list *t)\n{\n\tunsigned long now, next;\n\tstruct neighbour *neigh = from_timer(neigh, t, timer);\n\tunsigned int state;\n\tint notify = 0;\n\n\twrite_lock(&neigh->lock);\n\n\tstate = neigh->nud_state;\n\tnow = jiffies;\n\tnext = now + HZ;\n\n\tif (!(state & NUD_IN_TIMER))\n\t\tgoto out;\n\n\tif (state & NUD_REACHABLE) {\n\t\tif (time_before_eq(now,\n\t\t\t\t   neigh->confirmed + neigh->parms->reachable_time)) {\n\t\t\tneigh_dbg(2, \"neigh %p is still alive\\n\", neigh);\n\t\t\tnext = neigh->confirmed + neigh->parms->reachable_time;\n\t\t} else if (time_before_eq(now,\n\t\t\t\t\t  neigh->used +\n\t\t\t\t\t  NEIGH_VAR(neigh->parms, DELAY_PROBE_TIME))) {\n\t\t\tneigh_dbg(2, \"neigh %p is delayed\\n\", neigh);\n\t\t\tWRITE_ONCE(neigh->nud_state, NUD_DELAY);\n\t\t\tneigh->updated = jiffies;\n\t\t\tneigh_suspect(neigh);\n\t\t\tnext = now + NEIGH_VAR(neigh->parms, DELAY_PROBE_TIME);\n\t\t} else {\n\t\t\tneigh_dbg(2, \"neigh %p is suspected\\n\", neigh);\n\t\t\tWRITE_ONCE(neigh->nud_state, NUD_STALE);\n\t\t\tneigh->updated = jiffies;\n\t\t\tneigh_suspect(neigh);\n\t\t\tnotify = 1;\n\t\t}\n\t} else if (state & NUD_DELAY) {\n\t\tif (time_before_eq(now,\n\t\t\t\t   neigh->confirmed +\n\t\t\t\t   NEIGH_VAR(neigh->parms, DELAY_PROBE_TIME))) {\n\t\t\tneigh_dbg(2, \"neigh %p is now reachable\\n\", neigh);\n\t\t\tWRITE_ONCE(neigh->nud_state, NUD_REACHABLE);\n\t\t\tneigh->updated = jiffies;\n\t\t\tneigh_connect(neigh);\n\t\t\tnotify = 1;\n\t\t\tnext = neigh->confirmed + neigh->parms->reachable_time;\n\t\t} else {\n\t\t\tneigh_dbg(2, \"neigh %p is probed\\n\", neigh);\n\t\t\tWRITE_ONCE(neigh->nud_state, NUD_PROBE);\n\t\t\tneigh->updated = jiffies;\n\t\t\tatomic_set(&neigh->probes, 0);\n\t\t\tnotify = 1;\n\t\t\tnext = now + max(NEIGH_VAR(neigh->parms, RETRANS_TIME),\n\t\t\t\t\t HZ/100);\n\t\t}\n\t} else {\n\t\t \n\t\tnext = now + max(NEIGH_VAR(neigh->parms, RETRANS_TIME), HZ/100);\n\t}\n\n\tif ((neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE)) &&\n\t    atomic_read(&neigh->probes) >= neigh_max_probes(neigh)) {\n\t\tWRITE_ONCE(neigh->nud_state, NUD_FAILED);\n\t\tnotify = 1;\n\t\tneigh_invalidate(neigh);\n\t\tgoto out;\n\t}\n\n\tif (neigh->nud_state & NUD_IN_TIMER) {\n\t\tif (time_before(next, jiffies + HZ/100))\n\t\t\tnext = jiffies + HZ/100;\n\t\tif (!mod_timer(&neigh->timer, next))\n\t\t\tneigh_hold(neigh);\n\t}\n\tif (neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE)) {\n\t\tneigh_probe(neigh);\n\t} else {\nout:\n\t\twrite_unlock(&neigh->lock);\n\t}\n\n\tif (notify)\n\t\tneigh_update_notify(neigh, 0);\n\n\ttrace_neigh_timer_handler(neigh, 0);\n\n\tneigh_release(neigh);\n}\n\nint __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb,\n\t\t       const bool immediate_ok)\n{\n\tint rc;\n\tbool immediate_probe = false;\n\n\twrite_lock_bh(&neigh->lock);\n\n\trc = 0;\n\tif (neigh->nud_state & (NUD_CONNECTED | NUD_DELAY | NUD_PROBE))\n\t\tgoto out_unlock_bh;\n\tif (neigh->dead)\n\t\tgoto out_dead;\n\n\tif (!(neigh->nud_state & (NUD_STALE | NUD_INCOMPLETE))) {\n\t\tif (NEIGH_VAR(neigh->parms, MCAST_PROBES) +\n\t\t    NEIGH_VAR(neigh->parms, APP_PROBES)) {\n\t\t\tunsigned long next, now = jiffies;\n\n\t\t\tatomic_set(&neigh->probes,\n\t\t\t\t   NEIGH_VAR(neigh->parms, UCAST_PROBES));\n\t\t\tneigh_del_timer(neigh);\n\t\t\tWRITE_ONCE(neigh->nud_state, NUD_INCOMPLETE);\n\t\t\tneigh->updated = now;\n\t\t\tif (!immediate_ok) {\n\t\t\t\tnext = now + 1;\n\t\t\t} else {\n\t\t\t\timmediate_probe = true;\n\t\t\t\tnext = now + max(NEIGH_VAR(neigh->parms,\n\t\t\t\t\t\t\t   RETRANS_TIME),\n\t\t\t\t\t\t HZ / 100);\n\t\t\t}\n\t\t\tneigh_add_timer(neigh, next);\n\t\t} else {\n\t\t\tWRITE_ONCE(neigh->nud_state, NUD_FAILED);\n\t\t\tneigh->updated = jiffies;\n\t\t\twrite_unlock_bh(&neigh->lock);\n\n\t\t\tkfree_skb_reason(skb, SKB_DROP_REASON_NEIGH_FAILED);\n\t\t\treturn 1;\n\t\t}\n\t} else if (neigh->nud_state & NUD_STALE) {\n\t\tneigh_dbg(2, \"neigh %p is delayed\\n\", neigh);\n\t\tneigh_del_timer(neigh);\n\t\tWRITE_ONCE(neigh->nud_state, NUD_DELAY);\n\t\tneigh->updated = jiffies;\n\t\tneigh_add_timer(neigh, jiffies +\n\t\t\t\tNEIGH_VAR(neigh->parms, DELAY_PROBE_TIME));\n\t}\n\n\tif (neigh->nud_state == NUD_INCOMPLETE) {\n\t\tif (skb) {\n\t\t\twhile (neigh->arp_queue_len_bytes + skb->truesize >\n\t\t\t       NEIGH_VAR(neigh->parms, QUEUE_LEN_BYTES)) {\n\t\t\t\tstruct sk_buff *buff;\n\n\t\t\t\tbuff = __skb_dequeue(&neigh->arp_queue);\n\t\t\t\tif (!buff)\n\t\t\t\t\tbreak;\n\t\t\t\tneigh->arp_queue_len_bytes -= buff->truesize;\n\t\t\t\tkfree_skb_reason(buff, SKB_DROP_REASON_NEIGH_QUEUEFULL);\n\t\t\t\tNEIGH_CACHE_STAT_INC(neigh->tbl, unres_discards);\n\t\t\t}\n\t\t\tskb_dst_force(skb);\n\t\t\t__skb_queue_tail(&neigh->arp_queue, skb);\n\t\t\tneigh->arp_queue_len_bytes += skb->truesize;\n\t\t}\n\t\trc = 1;\n\t}\nout_unlock_bh:\n\tif (immediate_probe)\n\t\tneigh_probe(neigh);\n\telse\n\t\twrite_unlock(&neigh->lock);\n\tlocal_bh_enable();\n\ttrace_neigh_event_send_done(neigh, rc);\n\treturn rc;\n\nout_dead:\n\tif (neigh->nud_state & NUD_STALE)\n\t\tgoto out_unlock_bh;\n\twrite_unlock_bh(&neigh->lock);\n\tkfree_skb_reason(skb, SKB_DROP_REASON_NEIGH_DEAD);\n\ttrace_neigh_event_send_dead(neigh, 1);\n\treturn 1;\n}\nEXPORT_SYMBOL(__neigh_event_send);\n\nstatic void neigh_update_hhs(struct neighbour *neigh)\n{\n\tstruct hh_cache *hh;\n\tvoid (*update)(struct hh_cache*, const struct net_device*, const unsigned char *)\n\t\t= NULL;\n\n\tif (neigh->dev->header_ops)\n\t\tupdate = neigh->dev->header_ops->cache_update;\n\n\tif (update) {\n\t\thh = &neigh->hh;\n\t\tif (READ_ONCE(hh->hh_len)) {\n\t\t\twrite_seqlock_bh(&hh->hh_lock);\n\t\t\tupdate(hh, neigh->dev, neigh->ha);\n\t\t\twrite_sequnlock_bh(&hh->hh_lock);\n\t\t}\n\t}\n}\n\n \nstatic int __neigh_update(struct neighbour *neigh, const u8 *lladdr,\n\t\t\t  u8 new, u32 flags, u32 nlmsg_pid,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tbool gc_update = false, managed_update = false;\n\tint update_isrouter = 0;\n\tstruct net_device *dev;\n\tint err, notify = 0;\n\tu8 old;\n\n\ttrace_neigh_update(neigh, lladdr, new, flags, nlmsg_pid);\n\n\twrite_lock_bh(&neigh->lock);\n\n\tdev    = neigh->dev;\n\told    = neigh->nud_state;\n\terr    = -EPERM;\n\n\tif (neigh->dead) {\n\t\tNL_SET_ERR_MSG(extack, \"Neighbor entry is now dead\");\n\t\tnew = old;\n\t\tgoto out;\n\t}\n\tif (!(flags & NEIGH_UPDATE_F_ADMIN) &&\n\t    (old & (NUD_NOARP | NUD_PERMANENT)))\n\t\tgoto out;\n\n\tneigh_update_flags(neigh, flags, &notify, &gc_update, &managed_update);\n\tif (flags & (NEIGH_UPDATE_F_USE | NEIGH_UPDATE_F_MANAGED)) {\n\t\tnew = old & ~NUD_PERMANENT;\n\t\tWRITE_ONCE(neigh->nud_state, new);\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (!(new & NUD_VALID)) {\n\t\tneigh_del_timer(neigh);\n\t\tif (old & NUD_CONNECTED)\n\t\t\tneigh_suspect(neigh);\n\t\tWRITE_ONCE(neigh->nud_state, new);\n\t\terr = 0;\n\t\tnotify = old & NUD_VALID;\n\t\tif ((old & (NUD_INCOMPLETE | NUD_PROBE)) &&\n\t\t    (new & NUD_FAILED)) {\n\t\t\tneigh_invalidate(neigh);\n\t\t\tnotify = 1;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (!dev->addr_len) {\n\t\t \n\t\tlladdr = neigh->ha;\n\t} else if (lladdr) {\n\t\t \n\t\tif ((old & NUD_VALID) &&\n\t\t    !memcmp(lladdr, neigh->ha, dev->addr_len))\n\t\t\tlladdr = neigh->ha;\n\t} else {\n\t\t \n\t\terr = -EINVAL;\n\t\tif (!(old & NUD_VALID)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"No link layer address given\");\n\t\t\tgoto out;\n\t\t}\n\t\tlladdr = neigh->ha;\n\t}\n\n\t \n\tif (new & NUD_CONNECTED)\n\t\tneigh->confirmed = jiffies;\n\n\t \n\terr = 0;\n\tupdate_isrouter = flags & NEIGH_UPDATE_F_OVERRIDE_ISROUTER;\n\tif (old & NUD_VALID) {\n\t\tif (lladdr != neigh->ha && !(flags & NEIGH_UPDATE_F_OVERRIDE)) {\n\t\t\tupdate_isrouter = 0;\n\t\t\tif ((flags & NEIGH_UPDATE_F_WEAK_OVERRIDE) &&\n\t\t\t    (old & NUD_CONNECTED)) {\n\t\t\t\tlladdr = neigh->ha;\n\t\t\t\tnew = NUD_STALE;\n\t\t\t} else\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (lladdr == neigh->ha && new == NUD_STALE &&\n\t\t\t    !(flags & NEIGH_UPDATE_F_ADMIN))\n\t\t\t\tnew = old;\n\t\t}\n\t}\n\n\t \n\tif (new != old || lladdr != neigh->ha)\n\t\tneigh->updated = jiffies;\n\n\tif (new != old) {\n\t\tneigh_del_timer(neigh);\n\t\tif (new & NUD_PROBE)\n\t\t\tatomic_set(&neigh->probes, 0);\n\t\tif (new & NUD_IN_TIMER)\n\t\t\tneigh_add_timer(neigh, (jiffies +\n\t\t\t\t\t\t((new & NUD_REACHABLE) ?\n\t\t\t\t\t\t neigh->parms->reachable_time :\n\t\t\t\t\t\t 0)));\n\t\tWRITE_ONCE(neigh->nud_state, new);\n\t\tnotify = 1;\n\t}\n\n\tif (lladdr != neigh->ha) {\n\t\twrite_seqlock(&neigh->ha_lock);\n\t\tmemcpy(&neigh->ha, lladdr, dev->addr_len);\n\t\twrite_sequnlock(&neigh->ha_lock);\n\t\tneigh_update_hhs(neigh);\n\t\tif (!(new & NUD_CONNECTED))\n\t\t\tneigh->confirmed = jiffies -\n\t\t\t\t      (NEIGH_VAR(neigh->parms, BASE_REACHABLE_TIME) << 1);\n\t\tnotify = 1;\n\t}\n\tif (new == old)\n\t\tgoto out;\n\tif (new & NUD_CONNECTED)\n\t\tneigh_connect(neigh);\n\telse\n\t\tneigh_suspect(neigh);\n\tif (!(old & NUD_VALID)) {\n\t\tstruct sk_buff *skb;\n\n\t\t \n\n\t\twhile (neigh->nud_state & NUD_VALID &&\n\t\t       (skb = __skb_dequeue(&neigh->arp_queue)) != NULL) {\n\t\t\tstruct dst_entry *dst = skb_dst(skb);\n\t\t\tstruct neighbour *n2, *n1 = neigh;\n\t\t\twrite_unlock_bh(&neigh->lock);\n\n\t\t\trcu_read_lock();\n\n\t\t\t \n\t\t\tn2 = NULL;\n\t\t\tif (dst && dst->obsolete != DST_OBSOLETE_DEAD) {\n\t\t\t\tn2 = dst_neigh_lookup_skb(dst, skb);\n\t\t\t\tif (n2)\n\t\t\t\t\tn1 = n2;\n\t\t\t}\n\t\t\tREAD_ONCE(n1->output)(n1, skb);\n\t\t\tif (n2)\n\t\t\t\tneigh_release(n2);\n\t\t\trcu_read_unlock();\n\n\t\t\twrite_lock_bh(&neigh->lock);\n\t\t}\n\t\t__skb_queue_purge(&neigh->arp_queue);\n\t\tneigh->arp_queue_len_bytes = 0;\n\t}\nout:\n\tif (update_isrouter)\n\t\tneigh_update_is_router(neigh, flags, &notify);\n\twrite_unlock_bh(&neigh->lock);\n\tif (((new ^ old) & NUD_PERMANENT) || gc_update)\n\t\tneigh_update_gc_list(neigh);\n\tif (managed_update)\n\t\tneigh_update_managed_list(neigh);\n\tif (notify)\n\t\tneigh_update_notify(neigh, nlmsg_pid);\n\ttrace_neigh_update_done(neigh, err);\n\treturn err;\n}\n\nint neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,\n\t\t u32 flags, u32 nlmsg_pid)\n{\n\treturn __neigh_update(neigh, lladdr, new, flags, nlmsg_pid, NULL);\n}\nEXPORT_SYMBOL(neigh_update);\n\n \nvoid __neigh_set_probe_once(struct neighbour *neigh)\n{\n\tif (neigh->dead)\n\t\treturn;\n\tneigh->updated = jiffies;\n\tif (!(neigh->nud_state & NUD_FAILED))\n\t\treturn;\n\tWRITE_ONCE(neigh->nud_state, NUD_INCOMPLETE);\n\tatomic_set(&neigh->probes, neigh_max_probes(neigh));\n\tneigh_add_timer(neigh,\n\t\t\tjiffies + max(NEIGH_VAR(neigh->parms, RETRANS_TIME),\n\t\t\t\t      HZ/100));\n}\nEXPORT_SYMBOL(__neigh_set_probe_once);\n\nstruct neighbour *neigh_event_ns(struct neigh_table *tbl,\n\t\t\t\t u8 *lladdr, void *saddr,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct neighbour *neigh = __neigh_lookup(tbl, saddr, dev,\n\t\t\t\t\t\t lladdr || !dev->addr_len);\n\tif (neigh)\n\t\tneigh_update(neigh, lladdr, NUD_STALE,\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE, 0);\n\treturn neigh;\n}\nEXPORT_SYMBOL(neigh_event_ns);\n\n \nstatic void neigh_hh_init(struct neighbour *n)\n{\n\tstruct net_device *dev = n->dev;\n\t__be16 prot = n->tbl->protocol;\n\tstruct hh_cache\t*hh = &n->hh;\n\n\twrite_lock_bh(&n->lock);\n\n\t \n\tif (!hh->hh_len)\n\t\tdev->header_ops->cache(n, hh, prot);\n\n\twrite_unlock_bh(&n->lock);\n}\n\n \n\nint neigh_resolve_output(struct neighbour *neigh, struct sk_buff *skb)\n{\n\tint rc = 0;\n\n\tif (!neigh_event_send(neigh, skb)) {\n\t\tint err;\n\t\tstruct net_device *dev = neigh->dev;\n\t\tunsigned int seq;\n\n\t\tif (dev->header_ops->cache && !READ_ONCE(neigh->hh.hh_len))\n\t\t\tneigh_hh_init(neigh);\n\n\t\tdo {\n\t\t\t__skb_pull(skb, skb_network_offset(skb));\n\t\t\tseq = read_seqbegin(&neigh->ha_lock);\n\t\t\terr = dev_hard_header(skb, dev, ntohs(skb->protocol),\n\t\t\t\t\t      neigh->ha, NULL, skb->len);\n\t\t} while (read_seqretry(&neigh->ha_lock, seq));\n\n\t\tif (err >= 0)\n\t\t\trc = dev_queue_xmit(skb);\n\t\telse\n\t\t\tgoto out_kfree_skb;\n\t}\nout:\n\treturn rc;\nout_kfree_skb:\n\trc = -EINVAL;\n\tkfree_skb(skb);\n\tgoto out;\n}\nEXPORT_SYMBOL(neigh_resolve_output);\n\n \n\nint neigh_connected_output(struct neighbour *neigh, struct sk_buff *skb)\n{\n\tstruct net_device *dev = neigh->dev;\n\tunsigned int seq;\n\tint err;\n\n\tdo {\n\t\t__skb_pull(skb, skb_network_offset(skb));\n\t\tseq = read_seqbegin(&neigh->ha_lock);\n\t\terr = dev_hard_header(skb, dev, ntohs(skb->protocol),\n\t\t\t\t      neigh->ha, NULL, skb->len);\n\t} while (read_seqretry(&neigh->ha_lock, seq));\n\n\tif (err >= 0)\n\t\terr = dev_queue_xmit(skb);\n\telse {\n\t\terr = -EINVAL;\n\t\tkfree_skb(skb);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(neigh_connected_output);\n\nint neigh_direct_output(struct neighbour *neigh, struct sk_buff *skb)\n{\n\treturn dev_queue_xmit(skb);\n}\nEXPORT_SYMBOL(neigh_direct_output);\n\nstatic void neigh_managed_work(struct work_struct *work)\n{\n\tstruct neigh_table *tbl = container_of(work, struct neigh_table,\n\t\t\t\t\t       managed_work.work);\n\tstruct neighbour *neigh;\n\n\twrite_lock_bh(&tbl->lock);\n\tlist_for_each_entry(neigh, &tbl->managed_list, managed_list)\n\t\tneigh_event_send_probe(neigh, NULL, false);\n\tqueue_delayed_work(system_power_efficient_wq, &tbl->managed_work,\n\t\t\t   NEIGH_VAR(&tbl->parms, INTERVAL_PROBE_TIME_MS));\n\twrite_unlock_bh(&tbl->lock);\n}\n\nstatic void neigh_proxy_process(struct timer_list *t)\n{\n\tstruct neigh_table *tbl = from_timer(tbl, t, proxy_timer);\n\tlong sched_next = 0;\n\tunsigned long now = jiffies;\n\tstruct sk_buff *skb, *n;\n\n\tspin_lock(&tbl->proxy_queue.lock);\n\n\tskb_queue_walk_safe(&tbl->proxy_queue, skb, n) {\n\t\tlong tdif = NEIGH_CB(skb)->sched_next - now;\n\n\t\tif (tdif <= 0) {\n\t\t\tstruct net_device *dev = skb->dev;\n\n\t\t\tneigh_parms_qlen_dec(dev, tbl->family);\n\t\t\t__skb_unlink(skb, &tbl->proxy_queue);\n\n\t\t\tif (tbl->proxy_redo && netif_running(dev)) {\n\t\t\t\trcu_read_lock();\n\t\t\t\ttbl->proxy_redo(skb);\n\t\t\t\trcu_read_unlock();\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\n\t\t\tdev_put(dev);\n\t\t} else if (!sched_next || tdif < sched_next)\n\t\t\tsched_next = tdif;\n\t}\n\tdel_timer(&tbl->proxy_timer);\n\tif (sched_next)\n\t\tmod_timer(&tbl->proxy_timer, jiffies + sched_next);\n\tspin_unlock(&tbl->proxy_queue.lock);\n}\n\nstatic unsigned long neigh_proxy_delay(struct neigh_parms *p)\n{\n\t \n\tunsigned long proxy_delay = NEIGH_VAR(p, PROXY_DELAY);\n\n\treturn proxy_delay ?\n\t       jiffies + get_random_u32_below(proxy_delay) : jiffies;\n}\n\nvoid pneigh_enqueue(struct neigh_table *tbl, struct neigh_parms *p,\n\t\t    struct sk_buff *skb)\n{\n\tunsigned long sched_next = neigh_proxy_delay(p);\n\n\tif (p->qlen > NEIGH_VAR(p, PROXY_QLEN)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tNEIGH_CB(skb)->sched_next = sched_next;\n\tNEIGH_CB(skb)->flags |= LOCALLY_ENQUEUED;\n\n\tspin_lock(&tbl->proxy_queue.lock);\n\tif (del_timer(&tbl->proxy_timer)) {\n\t\tif (time_before(tbl->proxy_timer.expires, sched_next))\n\t\t\tsched_next = tbl->proxy_timer.expires;\n\t}\n\tskb_dst_drop(skb);\n\tdev_hold(skb->dev);\n\t__skb_queue_tail(&tbl->proxy_queue, skb);\n\tp->qlen++;\n\tmod_timer(&tbl->proxy_timer, sched_next);\n\tspin_unlock(&tbl->proxy_queue.lock);\n}\nEXPORT_SYMBOL(pneigh_enqueue);\n\nstatic inline struct neigh_parms *lookup_neigh_parms(struct neigh_table *tbl,\n\t\t\t\t\t\t      struct net *net, int ifindex)\n{\n\tstruct neigh_parms *p;\n\n\tlist_for_each_entry(p, &tbl->parms_list, list) {\n\t\tif ((p->dev && p->dev->ifindex == ifindex && net_eq(neigh_parms_net(p), net)) ||\n\t\t    (!p->dev && !ifindex && net_eq(net, &init_net)))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}\n\nstruct neigh_parms *neigh_parms_alloc(struct net_device *dev,\n\t\t\t\t      struct neigh_table *tbl)\n{\n\tstruct neigh_parms *p;\n\tstruct net *net = dev_net(dev);\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tp = kmemdup(&tbl->parms, sizeof(*p), GFP_KERNEL);\n\tif (p) {\n\t\tp->tbl\t\t  = tbl;\n\t\trefcount_set(&p->refcnt, 1);\n\t\tp->reachable_time =\n\t\t\t\tneigh_rand_reach_time(NEIGH_VAR(p, BASE_REACHABLE_TIME));\n\t\tp->qlen = 0;\n\t\tnetdev_hold(dev, &p->dev_tracker, GFP_KERNEL);\n\t\tp->dev = dev;\n\t\twrite_pnet(&p->net, net);\n\t\tp->sysctl_table = NULL;\n\n\t\tif (ops->ndo_neigh_setup && ops->ndo_neigh_setup(dev, p)) {\n\t\t\tnetdev_put(dev, &p->dev_tracker);\n\t\t\tkfree(p);\n\t\t\treturn NULL;\n\t\t}\n\n\t\twrite_lock_bh(&tbl->lock);\n\t\tlist_add(&p->list, &tbl->parms.list);\n\t\twrite_unlock_bh(&tbl->lock);\n\n\t\tneigh_parms_data_state_cleanall(p);\n\t}\n\treturn p;\n}\nEXPORT_SYMBOL(neigh_parms_alloc);\n\nstatic void neigh_rcu_free_parms(struct rcu_head *head)\n{\n\tstruct neigh_parms *parms =\n\t\tcontainer_of(head, struct neigh_parms, rcu_head);\n\n\tneigh_parms_put(parms);\n}\n\nvoid neigh_parms_release(struct neigh_table *tbl, struct neigh_parms *parms)\n{\n\tif (!parms || parms == &tbl->parms)\n\t\treturn;\n\twrite_lock_bh(&tbl->lock);\n\tlist_del(&parms->list);\n\tparms->dead = 1;\n\twrite_unlock_bh(&tbl->lock);\n\tnetdev_put(parms->dev, &parms->dev_tracker);\n\tcall_rcu(&parms->rcu_head, neigh_rcu_free_parms);\n}\nEXPORT_SYMBOL(neigh_parms_release);\n\nstatic void neigh_parms_destroy(struct neigh_parms *parms)\n{\n\tkfree(parms);\n}\n\nstatic struct lock_class_key neigh_table_proxy_queue_class;\n\nstatic struct neigh_table *neigh_tables[NEIGH_NR_TABLES] __read_mostly;\n\nvoid neigh_table_init(int index, struct neigh_table *tbl)\n{\n\tunsigned long now = jiffies;\n\tunsigned long phsize;\n\n\tINIT_LIST_HEAD(&tbl->parms_list);\n\tINIT_LIST_HEAD(&tbl->gc_list);\n\tINIT_LIST_HEAD(&tbl->managed_list);\n\n\tlist_add(&tbl->parms.list, &tbl->parms_list);\n\twrite_pnet(&tbl->parms.net, &init_net);\n\trefcount_set(&tbl->parms.refcnt, 1);\n\ttbl->parms.reachable_time =\n\t\t\t  neigh_rand_reach_time(NEIGH_VAR(&tbl->parms, BASE_REACHABLE_TIME));\n\ttbl->parms.qlen = 0;\n\n\ttbl->stats = alloc_percpu(struct neigh_statistics);\n\tif (!tbl->stats)\n\t\tpanic(\"cannot create neighbour cache statistics\");\n\n#ifdef CONFIG_PROC_FS\n\tif (!proc_create_seq_data(tbl->id, 0, init_net.proc_net_stat,\n\t\t\t      &neigh_stat_seq_ops, tbl))\n\t\tpanic(\"cannot create neighbour proc dir entry\");\n#endif\n\n\tRCU_INIT_POINTER(tbl->nht, neigh_hash_alloc(3));\n\n\tphsize = (PNEIGH_HASHMASK + 1) * sizeof(struct pneigh_entry *);\n\ttbl->phash_buckets = kzalloc(phsize, GFP_KERNEL);\n\n\tif (!tbl->nht || !tbl->phash_buckets)\n\t\tpanic(\"cannot allocate neighbour cache hashes\");\n\n\tif (!tbl->entry_size)\n\t\ttbl->entry_size = ALIGN(offsetof(struct neighbour, primary_key) +\n\t\t\t\t\ttbl->key_len, NEIGH_PRIV_ALIGN);\n\telse\n\t\tWARN_ON(tbl->entry_size % NEIGH_PRIV_ALIGN);\n\n\trwlock_init(&tbl->lock);\n\n\tINIT_DEFERRABLE_WORK(&tbl->gc_work, neigh_periodic_work);\n\tqueue_delayed_work(system_power_efficient_wq, &tbl->gc_work,\n\t\t\ttbl->parms.reachable_time);\n\tINIT_DEFERRABLE_WORK(&tbl->managed_work, neigh_managed_work);\n\tqueue_delayed_work(system_power_efficient_wq, &tbl->managed_work, 0);\n\n\ttimer_setup(&tbl->proxy_timer, neigh_proxy_process, 0);\n\tskb_queue_head_init_class(&tbl->proxy_queue,\n\t\t\t&neigh_table_proxy_queue_class);\n\n\ttbl->last_flush = now;\n\ttbl->last_rand\t= now + tbl->parms.reachable_time * 20;\n\n\tneigh_tables[index] = tbl;\n}\nEXPORT_SYMBOL(neigh_table_init);\n\nint neigh_table_clear(int index, struct neigh_table *tbl)\n{\n\tneigh_tables[index] = NULL;\n\t \n\tcancel_delayed_work_sync(&tbl->managed_work);\n\tcancel_delayed_work_sync(&tbl->gc_work);\n\tdel_timer_sync(&tbl->proxy_timer);\n\tpneigh_queue_purge(&tbl->proxy_queue, NULL, tbl->family);\n\tneigh_ifdown(tbl, NULL);\n\tif (atomic_read(&tbl->entries))\n\t\tpr_crit(\"neighbour leakage\\n\");\n\n\tcall_rcu(&rcu_dereference_protected(tbl->nht, 1)->rcu,\n\t\t neigh_hash_free_rcu);\n\ttbl->nht = NULL;\n\n\tkfree(tbl->phash_buckets);\n\ttbl->phash_buckets = NULL;\n\n\tremove_proc_entry(tbl->id, init_net.proc_net_stat);\n\n\tfree_percpu(tbl->stats);\n\ttbl->stats = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(neigh_table_clear);\n\nstatic struct neigh_table *neigh_find_table(int family)\n{\n\tstruct neigh_table *tbl = NULL;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\ttbl = neigh_tables[NEIGH_ARP_TABLE];\n\t\tbreak;\n\tcase AF_INET6:\n\t\ttbl = neigh_tables[NEIGH_ND_TABLE];\n\t\tbreak;\n\t}\n\n\treturn tbl;\n}\n\nconst struct nla_policy nda_policy[NDA_MAX+1] = {\n\t[NDA_UNSPEC]\t\t= { .strict_start_type = NDA_NH_ID },\n\t[NDA_DST]\t\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[NDA_LLADDR]\t\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[NDA_CACHEINFO]\t\t= { .len = sizeof(struct nda_cacheinfo) },\n\t[NDA_PROBES]\t\t= { .type = NLA_U32 },\n\t[NDA_VLAN]\t\t= { .type = NLA_U16 },\n\t[NDA_PORT]\t\t= { .type = NLA_U16 },\n\t[NDA_VNI]\t\t= { .type = NLA_U32 },\n\t[NDA_IFINDEX]\t\t= { .type = NLA_U32 },\n\t[NDA_MASTER]\t\t= { .type = NLA_U32 },\n\t[NDA_PROTOCOL]\t\t= { .type = NLA_U8 },\n\t[NDA_NH_ID]\t\t= { .type = NLA_U32 },\n\t[NDA_FLAGS_EXT]\t\t= NLA_POLICY_MASK(NLA_U32, NTF_EXT_MASK),\n\t[NDA_FDB_EXT_ATTRS]\t= { .type = NLA_NESTED },\n};\n\nstatic int neigh_delete(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ndmsg *ndm;\n\tstruct nlattr *dst_attr;\n\tstruct neigh_table *tbl;\n\tstruct neighbour *neigh;\n\tstruct net_device *dev = NULL;\n\tint err = -EINVAL;\n\n\tASSERT_RTNL();\n\tif (nlmsg_len(nlh) < sizeof(*ndm))\n\t\tgoto out;\n\n\tdst_attr = nlmsg_find_attr(nlh, sizeof(*ndm), NDA_DST);\n\tif (!dst_attr) {\n\t\tNL_SET_ERR_MSG(extack, \"Network address not specified\");\n\t\tgoto out;\n\t}\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_ifindex) {\n\t\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\t\tif (dev == NULL) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttbl = neigh_find_table(ndm->ndm_family);\n\tif (tbl == NULL)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (nla_len(dst_attr) < (int)tbl->key_len) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid network address\");\n\t\tgoto out;\n\t}\n\n\tif (ndm->ndm_flags & NTF_PROXY) {\n\t\terr = pneigh_delete(tbl, net, nla_data(dst_attr), dev);\n\t\tgoto out;\n\t}\n\n\tif (dev == NULL)\n\t\tgoto out;\n\n\tneigh = neigh_lookup(tbl, nla_data(dst_attr), dev);\n\tif (neigh == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = __neigh_update(neigh, NULL, NUD_FAILED,\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE | NEIGH_UPDATE_F_ADMIN,\n\t\t\t     NETLINK_CB(skb).portid, extack);\n\twrite_lock_bh(&tbl->lock);\n\tneigh_release(neigh);\n\tneigh_remove_one(neigh, tbl);\n\twrite_unlock_bh(&tbl->lock);\n\nout:\n\treturn err;\n}\n\nstatic int neigh_add(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tint flags = NEIGH_UPDATE_F_ADMIN | NEIGH_UPDATE_F_OVERRIDE |\n\t\t    NEIGH_UPDATE_F_OVERRIDE_ISROUTER;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ndmsg *ndm;\n\tstruct nlattr *tb[NDA_MAX+1];\n\tstruct neigh_table *tbl;\n\tstruct net_device *dev = NULL;\n\tstruct neighbour *neigh;\n\tvoid *dst, *lladdr;\n\tu8 protocol = 0;\n\tu32 ndm_flags;\n\tint err;\n\n\tASSERT_RTNL();\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ndm), tb, NDA_MAX,\n\t\t\t\t     nda_policy, extack);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (!tb[NDA_DST]) {\n\t\tNL_SET_ERR_MSG(extack, \"Network address not specified\");\n\t\tgoto out;\n\t}\n\n\tndm = nlmsg_data(nlh);\n\tndm_flags = ndm->ndm_flags;\n\tif (tb[NDA_FLAGS_EXT]) {\n\t\tu32 ext = nla_get_u32(tb[NDA_FLAGS_EXT]);\n\n\t\tBUILD_BUG_ON(sizeof(neigh->flags) * BITS_PER_BYTE <\n\t\t\t     (sizeof(ndm->ndm_flags) * BITS_PER_BYTE +\n\t\t\t      hweight32(NTF_EXT_MASK)));\n\t\tndm_flags |= (ext << NTF_EXT_SHIFT);\n\t}\n\tif (ndm->ndm_ifindex) {\n\t\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\t\tif (dev == NULL) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (tb[NDA_LLADDR] && nla_len(tb[NDA_LLADDR]) < dev->addr_len) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid link address\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttbl = neigh_find_table(ndm->ndm_family);\n\tif (tbl == NULL)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (nla_len(tb[NDA_DST]) < (int)tbl->key_len) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid network address\");\n\t\tgoto out;\n\t}\n\n\tdst = nla_data(tb[NDA_DST]);\n\tlladdr = tb[NDA_LLADDR] ? nla_data(tb[NDA_LLADDR]) : NULL;\n\n\tif (tb[NDA_PROTOCOL])\n\t\tprotocol = nla_get_u8(tb[NDA_PROTOCOL]);\n\tif (ndm_flags & NTF_PROXY) {\n\t\tstruct pneigh_entry *pn;\n\n\t\tif (ndm_flags & NTF_MANAGED) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid NTF_* flag combination\");\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -ENOBUFS;\n\t\tpn = pneigh_lookup(tbl, net, dst, dev, 1);\n\t\tif (pn) {\n\t\t\tpn->flags = ndm_flags;\n\t\t\tif (protocol)\n\t\t\t\tpn->protocol = protocol;\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"Device not specified\");\n\t\tgoto out;\n\t}\n\n\tif (tbl->allow_add && !tbl->allow_add(dev, extack)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tneigh = neigh_lookup(tbl, dst, dev);\n\tif (neigh == NULL) {\n\t\tbool ndm_permanent  = ndm->ndm_state & NUD_PERMANENT;\n\t\tbool exempt_from_gc = ndm_permanent ||\n\t\t\t\t      ndm_flags & NTF_EXT_LEARNED;\n\n\t\tif (!(nlh->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ndm_permanent && (ndm_flags & NTF_MANAGED)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid NTF_* flag for permanent entry\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tneigh = ___neigh_create(tbl, dst, dev,\n\t\t\t\t\tndm_flags &\n\t\t\t\t\t(NTF_EXT_LEARNED | NTF_MANAGED),\n\t\t\t\t\texempt_from_gc, true);\n\t\tif (IS_ERR(neigh)) {\n\t\t\terr = PTR_ERR(neigh);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\terr = -EEXIST;\n\t\t\tneigh_release(neigh);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REPLACE))\n\t\t\tflags &= ~(NEIGH_UPDATE_F_OVERRIDE |\n\t\t\t\t   NEIGH_UPDATE_F_OVERRIDE_ISROUTER);\n\t}\n\n\tif (protocol)\n\t\tneigh->protocol = protocol;\n\tif (ndm_flags & NTF_EXT_LEARNED)\n\t\tflags |= NEIGH_UPDATE_F_EXT_LEARNED;\n\tif (ndm_flags & NTF_ROUTER)\n\t\tflags |= NEIGH_UPDATE_F_ISROUTER;\n\tif (ndm_flags & NTF_MANAGED)\n\t\tflags |= NEIGH_UPDATE_F_MANAGED;\n\tif (ndm_flags & NTF_USE)\n\t\tflags |= NEIGH_UPDATE_F_USE;\n\n\terr = __neigh_update(neigh, lladdr, ndm->ndm_state, flags,\n\t\t\t     NETLINK_CB(skb).portid, extack);\n\tif (!err && ndm_flags & (NTF_USE | NTF_MANAGED)) {\n\t\tneigh_event_send(neigh, NULL);\n\t\terr = 0;\n\t}\n\tneigh_release(neigh);\nout:\n\treturn err;\n}\n\nstatic int neightbl_fill_parms(struct sk_buff *skb, struct neigh_parms *parms)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, NDTA_PARMS);\n\tif (nest == NULL)\n\t\treturn -ENOBUFS;\n\n\tif ((parms->dev &&\n\t     nla_put_u32(skb, NDTPA_IFINDEX, parms->dev->ifindex)) ||\n\t    nla_put_u32(skb, NDTPA_REFCNT, refcount_read(&parms->refcnt)) ||\n\t    nla_put_u32(skb, NDTPA_QUEUE_LENBYTES,\n\t\t\tNEIGH_VAR(parms, QUEUE_LEN_BYTES)) ||\n\t     \n\t    nla_put_u32(skb, NDTPA_QUEUE_LEN,\n\t\t\tNEIGH_VAR(parms, QUEUE_LEN_BYTES) / SKB_TRUESIZE(ETH_FRAME_LEN)) ||\n\t    nla_put_u32(skb, NDTPA_PROXY_QLEN, NEIGH_VAR(parms, PROXY_QLEN)) ||\n\t    nla_put_u32(skb, NDTPA_APP_PROBES, NEIGH_VAR(parms, APP_PROBES)) ||\n\t    nla_put_u32(skb, NDTPA_UCAST_PROBES,\n\t\t\tNEIGH_VAR(parms, UCAST_PROBES)) ||\n\t    nla_put_u32(skb, NDTPA_MCAST_PROBES,\n\t\t\tNEIGH_VAR(parms, MCAST_PROBES)) ||\n\t    nla_put_u32(skb, NDTPA_MCAST_REPROBES,\n\t\t\tNEIGH_VAR(parms, MCAST_REPROBES)) ||\n\t    nla_put_msecs(skb, NDTPA_REACHABLE_TIME, parms->reachable_time,\n\t\t\t  NDTPA_PAD) ||\n\t    nla_put_msecs(skb, NDTPA_BASE_REACHABLE_TIME,\n\t\t\t  NEIGH_VAR(parms, BASE_REACHABLE_TIME), NDTPA_PAD) ||\n\t    nla_put_msecs(skb, NDTPA_GC_STALETIME,\n\t\t\t  NEIGH_VAR(parms, GC_STALETIME), NDTPA_PAD) ||\n\t    nla_put_msecs(skb, NDTPA_DELAY_PROBE_TIME,\n\t\t\t  NEIGH_VAR(parms, DELAY_PROBE_TIME), NDTPA_PAD) ||\n\t    nla_put_msecs(skb, NDTPA_RETRANS_TIME,\n\t\t\t  NEIGH_VAR(parms, RETRANS_TIME), NDTPA_PAD) ||\n\t    nla_put_msecs(skb, NDTPA_ANYCAST_DELAY,\n\t\t\t  NEIGH_VAR(parms, ANYCAST_DELAY), NDTPA_PAD) ||\n\t    nla_put_msecs(skb, NDTPA_PROXY_DELAY,\n\t\t\t  NEIGH_VAR(parms, PROXY_DELAY), NDTPA_PAD) ||\n\t    nla_put_msecs(skb, NDTPA_LOCKTIME,\n\t\t\t  NEIGH_VAR(parms, LOCKTIME), NDTPA_PAD) ||\n\t    nla_put_msecs(skb, NDTPA_INTERVAL_PROBE_TIME_MS,\n\t\t\t  NEIGH_VAR(parms, INTERVAL_PROBE_TIME_MS), NDTPA_PAD))\n\t\tgoto nla_put_failure;\n\treturn nla_nest_end(skb, nest);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int neightbl_fill_info(struct sk_buff *skb, struct neigh_table *tbl,\n\t\t\t      u32 pid, u32 seq, int type, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ndtmsg *ndtmsg;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ndtmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tndtmsg = nlmsg_data(nlh);\n\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\tndtmsg->ndtm_pad1   = 0;\n\tndtmsg->ndtm_pad2   = 0;\n\n\tif (nla_put_string(skb, NDTA_NAME, tbl->id) ||\n\t    nla_put_msecs(skb, NDTA_GC_INTERVAL, READ_ONCE(tbl->gc_interval),\n\t\t\t  NDTA_PAD) ||\n\t    nla_put_u32(skb, NDTA_THRESH1, READ_ONCE(tbl->gc_thresh1)) ||\n\t    nla_put_u32(skb, NDTA_THRESH2, READ_ONCE(tbl->gc_thresh2)) ||\n\t    nla_put_u32(skb, NDTA_THRESH3, READ_ONCE(tbl->gc_thresh3)))\n\t\tgoto nla_put_failure;\n\t{\n\t\tunsigned long now = jiffies;\n\t\tlong flush_delta = now - READ_ONCE(tbl->last_flush);\n\t\tlong rand_delta = now - READ_ONCE(tbl->last_rand);\n\t\tstruct neigh_hash_table *nht;\n\t\tstruct ndt_config ndc = {\n\t\t\t.ndtc_key_len\t\t= tbl->key_len,\n\t\t\t.ndtc_entry_size\t= tbl->entry_size,\n\t\t\t.ndtc_entries\t\t= atomic_read(&tbl->entries),\n\t\t\t.ndtc_last_flush\t= jiffies_to_msecs(flush_delta),\n\t\t\t.ndtc_last_rand\t\t= jiffies_to_msecs(rand_delta),\n\t\t\t.ndtc_proxy_qlen\t= READ_ONCE(tbl->proxy_queue.qlen),\n\t\t};\n\n\t\trcu_read_lock();\n\t\tnht = rcu_dereference(tbl->nht);\n\t\tndc.ndtc_hash_rnd = nht->hash_rnd[0];\n\t\tndc.ndtc_hash_mask = ((1 << nht->hash_shift) - 1);\n\t\trcu_read_unlock();\n\n\t\tif (nla_put(skb, NDTA_CONFIG, sizeof(ndc), &ndc))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\t{\n\t\tint cpu;\n\t\tstruct ndt_stats ndst;\n\n\t\tmemset(&ndst, 0, sizeof(ndst));\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct neigh_statistics\t*st;\n\n\t\t\tst = per_cpu_ptr(tbl->stats, cpu);\n\t\t\tndst.ndts_allocs\t\t+= READ_ONCE(st->allocs);\n\t\t\tndst.ndts_destroys\t\t+= READ_ONCE(st->destroys);\n\t\t\tndst.ndts_hash_grows\t\t+= READ_ONCE(st->hash_grows);\n\t\t\tndst.ndts_res_failed\t\t+= READ_ONCE(st->res_failed);\n\t\t\tndst.ndts_lookups\t\t+= READ_ONCE(st->lookups);\n\t\t\tndst.ndts_hits\t\t\t+= READ_ONCE(st->hits);\n\t\t\tndst.ndts_rcv_probes_mcast\t+= READ_ONCE(st->rcv_probes_mcast);\n\t\t\tndst.ndts_rcv_probes_ucast\t+= READ_ONCE(st->rcv_probes_ucast);\n\t\t\tndst.ndts_periodic_gc_runs\t+= READ_ONCE(st->periodic_gc_runs);\n\t\t\tndst.ndts_forced_gc_runs\t+= READ_ONCE(st->forced_gc_runs);\n\t\t\tndst.ndts_table_fulls\t\t+= READ_ONCE(st->table_fulls);\n\t\t}\n\n\t\tif (nla_put_64bit(skb, NDTA_STATS, sizeof(ndst), &ndst,\n\t\t\t\t  NDTA_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tBUG_ON(tbl->parms.dev);\n\tif (neightbl_fill_parms(skb, &tbl->parms) < 0)\n\t\tgoto nla_put_failure;\n\n\tread_unlock_bh(&tbl->lock);\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tread_unlock_bh(&tbl->lock);\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int neightbl_fill_param_info(struct sk_buff *skb,\n\t\t\t\t    struct neigh_table *tbl,\n\t\t\t\t    struct neigh_parms *parms,\n\t\t\t\t    u32 pid, u32 seq, int type,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct ndtmsg *ndtmsg;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ndtmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tndtmsg = nlmsg_data(nlh);\n\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\tndtmsg->ndtm_pad1   = 0;\n\tndtmsg->ndtm_pad2   = 0;\n\n\tif (nla_put_string(skb, NDTA_NAME, tbl->id) < 0 ||\n\t    neightbl_fill_parms(skb, parms) < 0)\n\t\tgoto errout;\n\n\tread_unlock_bh(&tbl->lock);\n\tnlmsg_end(skb, nlh);\n\treturn 0;\nerrout:\n\tread_unlock_bh(&tbl->lock);\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy nl_neightbl_policy[NDTA_MAX+1] = {\n\t[NDTA_NAME]\t\t= { .type = NLA_STRING },\n\t[NDTA_THRESH1]\t\t= { .type = NLA_U32 },\n\t[NDTA_THRESH2]\t\t= { .type = NLA_U32 },\n\t[NDTA_THRESH3]\t\t= { .type = NLA_U32 },\n\t[NDTA_GC_INTERVAL]\t= { .type = NLA_U64 },\n\t[NDTA_PARMS]\t\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy nl_ntbl_parm_policy[NDTPA_MAX+1] = {\n\t[NDTPA_IFINDEX]\t\t\t= { .type = NLA_U32 },\n\t[NDTPA_QUEUE_LEN]\t\t= { .type = NLA_U32 },\n\t[NDTPA_PROXY_QLEN]\t\t= { .type = NLA_U32 },\n\t[NDTPA_APP_PROBES]\t\t= { .type = NLA_U32 },\n\t[NDTPA_UCAST_PROBES]\t\t= { .type = NLA_U32 },\n\t[NDTPA_MCAST_PROBES]\t\t= { .type = NLA_U32 },\n\t[NDTPA_MCAST_REPROBES]\t\t= { .type = NLA_U32 },\n\t[NDTPA_BASE_REACHABLE_TIME]\t= { .type = NLA_U64 },\n\t[NDTPA_GC_STALETIME]\t\t= { .type = NLA_U64 },\n\t[NDTPA_DELAY_PROBE_TIME]\t= { .type = NLA_U64 },\n\t[NDTPA_RETRANS_TIME]\t\t= { .type = NLA_U64 },\n\t[NDTPA_ANYCAST_DELAY]\t\t= { .type = NLA_U64 },\n\t[NDTPA_PROXY_DELAY]\t\t= { .type = NLA_U64 },\n\t[NDTPA_LOCKTIME]\t\t= { .type = NLA_U64 },\n\t[NDTPA_INTERVAL_PROBE_TIME_MS]\t= { .type = NLA_U64, .min = 1 },\n};\n\nstatic int neightbl_set(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct neigh_table *tbl;\n\tstruct ndtmsg *ndtmsg;\n\tstruct nlattr *tb[NDTA_MAX+1];\n\tbool found = false;\n\tint err, tidx;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ndtmsg), tb, NDTA_MAX,\n\t\t\t\t     nl_neightbl_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (tb[NDTA_NAME] == NULL) {\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tndtmsg = nlmsg_data(nlh);\n\n\tfor (tidx = 0; tidx < NEIGH_NR_TABLES; tidx++) {\n\t\ttbl = neigh_tables[tidx];\n\t\tif (!tbl)\n\t\t\tcontinue;\n\t\tif (ndtmsg->ndtm_family && tbl->family != ndtmsg->ndtm_family)\n\t\t\tcontinue;\n\t\tif (nla_strcmp(tb[NDTA_NAME], tbl->id) == 0) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -ENOENT;\n\n\t \n\twrite_lock_bh(&tbl->lock);\n\n\tif (tb[NDTA_PARMS]) {\n\t\tstruct nlattr *tbp[NDTPA_MAX+1];\n\t\tstruct neigh_parms *p;\n\t\tint i, ifindex = 0;\n\n\t\terr = nla_parse_nested_deprecated(tbp, NDTPA_MAX,\n\t\t\t\t\t\t  tb[NDTA_PARMS],\n\t\t\t\t\t\t  nl_ntbl_parm_policy, extack);\n\t\tif (err < 0)\n\t\t\tgoto errout_tbl_lock;\n\n\t\tif (tbp[NDTPA_IFINDEX])\n\t\t\tifindex = nla_get_u32(tbp[NDTPA_IFINDEX]);\n\n\t\tp = lookup_neigh_parms(tbl, net, ifindex);\n\t\tif (p == NULL) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout_tbl_lock;\n\t\t}\n\n\t\tfor (i = 1; i <= NDTPA_MAX; i++) {\n\t\t\tif (tbp[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (i) {\n\t\t\tcase NDTPA_QUEUE_LEN:\n\t\t\t\tNEIGH_VAR_SET(p, QUEUE_LEN_BYTES,\n\t\t\t\t\t      nla_get_u32(tbp[i]) *\n\t\t\t\t\t      SKB_TRUESIZE(ETH_FRAME_LEN));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_QUEUE_LENBYTES:\n\t\t\t\tNEIGH_VAR_SET(p, QUEUE_LEN_BYTES,\n\t\t\t\t\t      nla_get_u32(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_PROXY_QLEN:\n\t\t\t\tNEIGH_VAR_SET(p, PROXY_QLEN,\n\t\t\t\t\t      nla_get_u32(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_APP_PROBES:\n\t\t\t\tNEIGH_VAR_SET(p, APP_PROBES,\n\t\t\t\t\t      nla_get_u32(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_UCAST_PROBES:\n\t\t\t\tNEIGH_VAR_SET(p, UCAST_PROBES,\n\t\t\t\t\t      nla_get_u32(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_MCAST_PROBES:\n\t\t\t\tNEIGH_VAR_SET(p, MCAST_PROBES,\n\t\t\t\t\t      nla_get_u32(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_MCAST_REPROBES:\n\t\t\t\tNEIGH_VAR_SET(p, MCAST_REPROBES,\n\t\t\t\t\t      nla_get_u32(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_BASE_REACHABLE_TIME:\n\t\t\t\tNEIGH_VAR_SET(p, BASE_REACHABLE_TIME,\n\t\t\t\t\t      nla_get_msecs(tbp[i]));\n\t\t\t\t \n\t\t\t\tp->reachable_time =\n\t\t\t\t\tneigh_rand_reach_time(NEIGH_VAR(p, BASE_REACHABLE_TIME));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_GC_STALETIME:\n\t\t\t\tNEIGH_VAR_SET(p, GC_STALETIME,\n\t\t\t\t\t      nla_get_msecs(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_DELAY_PROBE_TIME:\n\t\t\t\tNEIGH_VAR_SET(p, DELAY_PROBE_TIME,\n\t\t\t\t\t      nla_get_msecs(tbp[i]));\n\t\t\t\tcall_netevent_notifiers(NETEVENT_DELAY_PROBE_TIME_UPDATE, p);\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_INTERVAL_PROBE_TIME_MS:\n\t\t\t\tNEIGH_VAR_SET(p, INTERVAL_PROBE_TIME_MS,\n\t\t\t\t\t      nla_get_msecs(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_RETRANS_TIME:\n\t\t\t\tNEIGH_VAR_SET(p, RETRANS_TIME,\n\t\t\t\t\t      nla_get_msecs(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_ANYCAST_DELAY:\n\t\t\t\tNEIGH_VAR_SET(p, ANYCAST_DELAY,\n\t\t\t\t\t      nla_get_msecs(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_PROXY_DELAY:\n\t\t\t\tNEIGH_VAR_SET(p, PROXY_DELAY,\n\t\t\t\t\t      nla_get_msecs(tbp[i]));\n\t\t\t\tbreak;\n\t\t\tcase NDTPA_LOCKTIME:\n\t\t\t\tNEIGH_VAR_SET(p, LOCKTIME,\n\t\t\t\t\t      nla_get_msecs(tbp[i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\terr = -ENOENT;\n\tif ((tb[NDTA_THRESH1] || tb[NDTA_THRESH2] ||\n\t     tb[NDTA_THRESH3] || tb[NDTA_GC_INTERVAL]) &&\n\t    !net_eq(net, &init_net))\n\t\tgoto errout_tbl_lock;\n\n\tif (tb[NDTA_THRESH1])\n\t\tWRITE_ONCE(tbl->gc_thresh1, nla_get_u32(tb[NDTA_THRESH1]));\n\n\tif (tb[NDTA_THRESH2])\n\t\tWRITE_ONCE(tbl->gc_thresh2, nla_get_u32(tb[NDTA_THRESH2]));\n\n\tif (tb[NDTA_THRESH3])\n\t\tWRITE_ONCE(tbl->gc_thresh3, nla_get_u32(tb[NDTA_THRESH3]));\n\n\tif (tb[NDTA_GC_INTERVAL])\n\t\tWRITE_ONCE(tbl->gc_interval, nla_get_msecs(tb[NDTA_GC_INTERVAL]));\n\n\terr = 0;\n\nerrout_tbl_lock:\n\twrite_unlock_bh(&tbl->lock);\nerrout:\n\treturn err;\n}\n\nstatic int neightbl_valid_dump_info(const struct nlmsghdr *nlh,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ndtmsg *ndtm;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndtm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for neighbor table dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tndtm = nlmsg_data(nlh);\n\tif (ndtm->ndtm_pad1  || ndtm->ndtm_pad2) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for neighbor table dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nlmsg_attrlen(nlh, sizeof(*ndtm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid data after header in neighbor table dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int neightbl_dump_info(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tint family, tidx, nidx = 0;\n\tint tbl_skip = cb->args[0];\n\tint neigh_skip = cb->args[1];\n\tstruct neigh_table *tbl;\n\n\tif (cb->strict_check) {\n\t\tint err = neightbl_valid_dump_info(nlh, cb->extack);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfamily = ((struct rtgenmsg *)nlmsg_data(nlh))->rtgen_family;\n\n\tfor (tidx = 0; tidx < NEIGH_NR_TABLES; tidx++) {\n\t\tstruct neigh_parms *p;\n\n\t\ttbl = neigh_tables[tidx];\n\t\tif (!tbl)\n\t\t\tcontinue;\n\n\t\tif (tidx < tbl_skip || (family && tbl->family != family))\n\t\t\tcontinue;\n\n\t\tif (neightbl_fill_info(skb, tbl, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       nlh->nlmsg_seq, RTM_NEWNEIGHTBL,\n\t\t\t\t       NLM_F_MULTI) < 0)\n\t\t\tbreak;\n\n\t\tnidx = 0;\n\t\tp = list_next_entry(&tbl->parms, list);\n\t\tlist_for_each_entry_from(p, &tbl->parms_list, list) {\n\t\t\tif (!net_eq(neigh_parms_net(p), net))\n\t\t\t\tcontinue;\n\n\t\t\tif (nidx < neigh_skip)\n\t\t\t\tgoto next;\n\n\t\t\tif (neightbl_fill_param_info(skb, tbl, p,\n\t\t\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t     nlh->nlmsg_seq,\n\t\t\t\t\t\t     RTM_NEWNEIGHTBL,\n\t\t\t\t\t\t     NLM_F_MULTI) < 0)\n\t\t\t\tgoto out;\n\t\tnext:\n\t\t\tnidx++;\n\t\t}\n\n\t\tneigh_skip = 0;\n\t}\nout:\n\tcb->args[0] = tidx;\n\tcb->args[1] = nidx;\n\n\treturn skb->len;\n}\n\nstatic int neigh_fill_info(struct sk_buff *skb, struct neighbour *neigh,\n\t\t\t   u32 pid, u32 seq, int type, unsigned int flags)\n{\n\tu32 neigh_flags, neigh_flags_ext;\n\tunsigned long now = jiffies;\n\tstruct nda_cacheinfo ci;\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *ndm;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ndm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tneigh_flags_ext = neigh->flags >> NTF_EXT_SHIFT;\n\tneigh_flags     = neigh->flags & NTF_OLD_MASK;\n\n\tndm = nlmsg_data(nlh);\n\tndm->ndm_family\t = neigh->ops->family;\n\tndm->ndm_pad1    = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags\t = neigh_flags;\n\tndm->ndm_type\t = neigh->type;\n\tndm->ndm_ifindex = neigh->dev->ifindex;\n\n\tif (nla_put(skb, NDA_DST, neigh->tbl->key_len, neigh->primary_key))\n\t\tgoto nla_put_failure;\n\n\tread_lock_bh(&neigh->lock);\n\tndm->ndm_state\t = neigh->nud_state;\n\tif (neigh->nud_state & NUD_VALID) {\n\t\tchar haddr[MAX_ADDR_LEN];\n\n\t\tneigh_ha_snapshot(haddr, neigh, neigh->dev);\n\t\tif (nla_put(skb, NDA_LLADDR, neigh->dev->addr_len, haddr) < 0) {\n\t\t\tread_unlock_bh(&neigh->lock);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tci.ndm_used\t = jiffies_to_clock_t(now - neigh->used);\n\tci.ndm_confirmed = jiffies_to_clock_t(now - neigh->confirmed);\n\tci.ndm_updated\t = jiffies_to_clock_t(now - neigh->updated);\n\tci.ndm_refcnt\t = refcount_read(&neigh->refcnt) - 1;\n\tread_unlock_bh(&neigh->lock);\n\n\tif (nla_put_u32(skb, NDA_PROBES, atomic_read(&neigh->probes)) ||\n\t    nla_put(skb, NDA_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\n\tif (neigh->protocol && nla_put_u8(skb, NDA_PROTOCOL, neigh->protocol))\n\t\tgoto nla_put_failure;\n\tif (neigh_flags_ext && nla_put_u32(skb, NDA_FLAGS_EXT, neigh_flags_ext))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int pneigh_fill_info(struct sk_buff *skb, struct pneigh_entry *pn,\n\t\t\t    u32 pid, u32 seq, int type, unsigned int flags,\n\t\t\t    struct neigh_table *tbl)\n{\n\tu32 neigh_flags, neigh_flags_ext;\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *ndm;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ndm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tneigh_flags_ext = pn->flags >> NTF_EXT_SHIFT;\n\tneigh_flags     = pn->flags & NTF_OLD_MASK;\n\n\tndm = nlmsg_data(nlh);\n\tndm->ndm_family\t = tbl->family;\n\tndm->ndm_pad1    = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags\t = neigh_flags | NTF_PROXY;\n\tndm->ndm_type\t = RTN_UNICAST;\n\tndm->ndm_ifindex = pn->dev ? pn->dev->ifindex : 0;\n\tndm->ndm_state\t = NUD_NONE;\n\n\tif (nla_put(skb, NDA_DST, tbl->key_len, pn->key))\n\t\tgoto nla_put_failure;\n\n\tif (pn->protocol && nla_put_u8(skb, NDA_PROTOCOL, pn->protocol))\n\t\tgoto nla_put_failure;\n\tif (neigh_flags_ext && nla_put_u32(skb, NDA_FLAGS_EXT, neigh_flags_ext))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic void neigh_update_notify(struct neighbour *neigh, u32 nlmsg_pid)\n{\n\tcall_netevent_notifiers(NETEVENT_NEIGH_UPDATE, neigh);\n\t__neigh_notify(neigh, RTM_NEWNEIGH, 0, nlmsg_pid);\n}\n\nstatic bool neigh_master_filtered(struct net_device *dev, int master_idx)\n{\n\tstruct net_device *master;\n\n\tif (!master_idx)\n\t\treturn false;\n\n\tmaster = dev ? netdev_master_upper_dev_get(dev) : NULL;\n\n\t \n\tif (master_idx == -1)\n\t\treturn !!master;\n\n\tif (!master || master->ifindex != master_idx)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool neigh_ifindex_filtered(struct net_device *dev, int filter_idx)\n{\n\tif (filter_idx && (!dev || dev->ifindex != filter_idx))\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct neigh_dump_filter {\n\tint master_idx;\n\tint dev_idx;\n};\n\nstatic int neigh_dump_table(struct neigh_table *tbl, struct sk_buff *skb,\n\t\t\t    struct netlink_callback *cb,\n\t\t\t    struct neigh_dump_filter *filter)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct neighbour *n;\n\tint rc, h, s_h = cb->args[1];\n\tint idx, s_idx = idx = cb->args[2];\n\tstruct neigh_hash_table *nht;\n\tunsigned int flags = NLM_F_MULTI;\n\n\tif (filter->dev_idx || filter->master_idx)\n\t\tflags |= NLM_F_DUMP_FILTERED;\n\n\trcu_read_lock();\n\tnht = rcu_dereference(tbl->nht);\n\n\tfor (h = s_h; h < (1 << nht->hash_shift); h++) {\n\t\tif (h > s_h)\n\t\t\ts_idx = 0;\n\t\tfor (n = rcu_dereference(nht->hash_buckets[h]), idx = 0;\n\t\t     n != NULL;\n\t\t     n = rcu_dereference(n->next)) {\n\t\t\tif (idx < s_idx || !net_eq(dev_net(n->dev), net))\n\t\t\t\tgoto next;\n\t\t\tif (neigh_ifindex_filtered(n->dev, filter->dev_idx) ||\n\t\t\t    neigh_master_filtered(n->dev, filter->master_idx))\n\t\t\t\tgoto next;\n\t\t\tif (neigh_fill_info(skb, n, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t    RTM_NEWNEIGH,\n\t\t\t\t\t    flags) < 0) {\n\t\t\t\trc = -1;\n\t\t\t\tgoto out;\n\t\t\t}\nnext:\n\t\t\tidx++;\n\t\t}\n\t}\n\trc = skb->len;\nout:\n\trcu_read_unlock();\n\tcb->args[1] = h;\n\tcb->args[2] = idx;\n\treturn rc;\n}\n\nstatic int pneigh_dump_table(struct neigh_table *tbl, struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb,\n\t\t\t     struct neigh_dump_filter *filter)\n{\n\tstruct pneigh_entry *n;\n\tstruct net *net = sock_net(skb->sk);\n\tint rc, h, s_h = cb->args[3];\n\tint idx, s_idx = idx = cb->args[4];\n\tunsigned int flags = NLM_F_MULTI;\n\n\tif (filter->dev_idx || filter->master_idx)\n\t\tflags |= NLM_F_DUMP_FILTERED;\n\n\tread_lock_bh(&tbl->lock);\n\n\tfor (h = s_h; h <= PNEIGH_HASHMASK; h++) {\n\t\tif (h > s_h)\n\t\t\ts_idx = 0;\n\t\tfor (n = tbl->phash_buckets[h], idx = 0; n; n = n->next) {\n\t\t\tif (idx < s_idx || pneigh_net(n) != net)\n\t\t\t\tgoto next;\n\t\t\tif (neigh_ifindex_filtered(n->dev, filter->dev_idx) ||\n\t\t\t    neigh_master_filtered(n->dev, filter->master_idx))\n\t\t\t\tgoto next;\n\t\t\tif (pneigh_fill_info(skb, n, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t    RTM_NEWNEIGH, flags, tbl) < 0) {\n\t\t\t\tread_unlock_bh(&tbl->lock);\n\t\t\t\trc = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\tnext:\n\t\t\tidx++;\n\t\t}\n\t}\n\n\tread_unlock_bh(&tbl->lock);\n\trc = skb->len;\nout:\n\tcb->args[3] = h;\n\tcb->args[4] = idx;\n\treturn rc;\n\n}\n\nstatic int neigh_valid_dump_req(const struct nlmsghdr *nlh,\n\t\t\t\tbool strict_check,\n\t\t\t\tstruct neigh_dump_filter *filter,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[NDA_MAX + 1];\n\tint err, i;\n\n\tif (strict_check) {\n\t\tstruct ndmsg *ndm;\n\n\t\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndm))) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid header for neighbor dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tndm = nlmsg_data(nlh);\n\t\tif (ndm->ndm_pad1  || ndm->ndm_pad2  || ndm->ndm_ifindex ||\n\t\t    ndm->ndm_state || ndm->ndm_type) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for neighbor dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ndm->ndm_flags & ~NTF_PROXY) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid flags in header for neighbor dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct ndmsg),\n\t\t\t\t\t\t    tb, NDA_MAX, nda_policy,\n\t\t\t\t\t\t    extack);\n\t} else {\n\t\terr = nlmsg_parse_deprecated(nlh, sizeof(struct ndmsg), tb,\n\t\t\t\t\t     NDA_MAX, nda_policy, extack);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i <= NDA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (i) {\n\t\tcase NDA_IFINDEX:\n\t\t\tfilter->dev_idx = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tcase NDA_MASTER:\n\t\t\tfilter->master_idx = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (strict_check) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in neighbor dump request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct neigh_dump_filter filter = {};\n\tstruct neigh_table *tbl;\n\tint t, family, s_t;\n\tint proxy = 0;\n\tint err;\n\n\tfamily = ((struct rtgenmsg *)nlmsg_data(nlh))->rtgen_family;\n\n\t \n\tif (nlmsg_len(nlh) >= sizeof(struct ndmsg) &&\n\t    ((struct ndmsg *)nlmsg_data(nlh))->ndm_flags == NTF_PROXY)\n\t\tproxy = 1;\n\n\terr = neigh_valid_dump_req(nlh, cb->strict_check, &filter, cb->extack);\n\tif (err < 0 && cb->strict_check)\n\t\treturn err;\n\n\ts_t = cb->args[0];\n\n\tfor (t = 0; t < NEIGH_NR_TABLES; t++) {\n\t\ttbl = neigh_tables[t];\n\n\t\tif (!tbl)\n\t\t\tcontinue;\n\t\tif (t < s_t || (family && tbl->family != family))\n\t\t\tcontinue;\n\t\tif (t > s_t)\n\t\t\tmemset(&cb->args[1], 0, sizeof(cb->args) -\n\t\t\t\t\t\tsizeof(cb->args[0]));\n\t\tif (proxy)\n\t\t\terr = pneigh_dump_table(tbl, skb, cb, &filter);\n\t\telse\n\t\t\terr = neigh_dump_table(tbl, skb, cb, &filter);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\tcb->args[0] = t;\n\treturn skb->len;\n}\n\nstatic int neigh_valid_get_req(const struct nlmsghdr *nlh,\n\t\t\t       struct neigh_table **tbl,\n\t\t\t       void **dst, int *dev_idx, u8 *ndm_flags,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[NDA_MAX + 1];\n\tstruct ndmsg *ndm;\n\tint err, i;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for neighbor get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_pad1  || ndm->ndm_pad2  || ndm->ndm_state ||\n\t    ndm->ndm_type) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for neighbor get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ndm->ndm_flags & ~NTF_PROXY) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid flags in header for neighbor get request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct ndmsg), tb,\n\t\t\t\t\t    NDA_MAX, nda_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ndm_flags = ndm->ndm_flags;\n\t*dev_idx = ndm->ndm_ifindex;\n\t*tbl = neigh_find_table(ndm->ndm_family);\n\tif (*tbl == NULL) {\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported family in header for neighbor get request\");\n\t\treturn -EAFNOSUPPORT;\n\t}\n\n\tfor (i = 0; i <= NDA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NDA_DST:\n\t\t\tif (nla_len(tb[i]) != (int)(*tbl)->key_len) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid network address in neighbor get request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*dst = nla_data(tb[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in neighbor get request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline size_t neigh_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ndmsg))\n\t       + nla_total_size(MAX_ADDR_LEN)  \n\t       + nla_total_size(MAX_ADDR_LEN)  \n\t       + nla_total_size(sizeof(struct nda_cacheinfo))\n\t       + nla_total_size(4)   \n\t       + nla_total_size(4)   \n\t       + nla_total_size(1);  \n}\n\nstatic int neigh_get_reply(struct net *net, struct neighbour *neigh,\n\t\t\t   u32 pid, u32 seq)\n{\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = nlmsg_new(neigh_nlmsg_size(), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\terr = neigh_fill_info(skb, neigh, pid, seq, RTM_NEWNEIGH, 0);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\terr = rtnl_unicast(skb, net, pid);\nerrout:\n\treturn err;\n}\n\nstatic inline size_t pneigh_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ndmsg))\n\t       + nla_total_size(MAX_ADDR_LEN)  \n\t       + nla_total_size(4)   \n\t       + nla_total_size(1);  \n}\n\nstatic int pneigh_get_reply(struct net *net, struct pneigh_entry *neigh,\n\t\t\t    u32 pid, u32 seq, struct neigh_table *tbl)\n{\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = nlmsg_new(pneigh_nlmsg_size(), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\terr = pneigh_fill_info(skb, neigh, pid, seq, RTM_NEWNEIGH, 0, tbl);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\terr = rtnl_unicast(skb, net, pid);\nerrout:\n\treturn err;\n}\n\nstatic int neigh_get(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct net_device *dev = NULL;\n\tstruct neigh_table *tbl = NULL;\n\tstruct neighbour *neigh;\n\tvoid *dst = NULL;\n\tu8 ndm_flags = 0;\n\tint dev_idx = 0;\n\tint err;\n\n\terr = neigh_valid_get_req(nlh, &tbl, &dst, &dev_idx, &ndm_flags,\n\t\t\t\t  extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (dev_idx) {\n\t\tdev = __dev_get_by_index(net, dev_idx);\n\t\tif (!dev) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Unknown device ifindex\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (!dst) {\n\t\tNL_SET_ERR_MSG(extack, \"Network address not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ndm_flags & NTF_PROXY) {\n\t\tstruct pneigh_entry *pn;\n\n\t\tpn = pneigh_lookup(tbl, net, dst, dev, 0);\n\t\tif (!pn) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Proxy neighbour entry not found\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\treturn pneigh_get_reply(net, pn, NETLINK_CB(in_skb).portid,\n\t\t\t\t\tnlh->nlmsg_seq, tbl);\n\t}\n\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"No device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tneigh = neigh_lookup(tbl, dst, dev);\n\tif (!neigh) {\n\t\tNL_SET_ERR_MSG(extack, \"Neighbour entry not found\");\n\t\treturn -ENOENT;\n\t}\n\n\terr = neigh_get_reply(net, neigh, NETLINK_CB(in_skb).portid,\n\t\t\t      nlh->nlmsg_seq);\n\n\tneigh_release(neigh);\n\n\treturn err;\n}\n\nvoid neigh_for_each(struct neigh_table *tbl, void (*cb)(struct neighbour *, void *), void *cookie)\n{\n\tint chain;\n\tstruct neigh_hash_table *nht;\n\n\trcu_read_lock();\n\tnht = rcu_dereference(tbl->nht);\n\n\tread_lock_bh(&tbl->lock);  \n\tfor (chain = 0; chain < (1 << nht->hash_shift); chain++) {\n\t\tstruct neighbour *n;\n\n\t\tfor (n = rcu_dereference(nht->hash_buckets[chain]);\n\t\t     n != NULL;\n\t\t     n = rcu_dereference(n->next))\n\t\t\tcb(n, cookie);\n\t}\n\tread_unlock_bh(&tbl->lock);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(neigh_for_each);\n\n \nvoid __neigh_for_each_release(struct neigh_table *tbl,\n\t\t\t      int (*cb)(struct neighbour *))\n{\n\tint chain;\n\tstruct neigh_hash_table *nht;\n\n\tnht = rcu_dereference_protected(tbl->nht,\n\t\t\t\t\tlockdep_is_held(&tbl->lock));\n\tfor (chain = 0; chain < (1 << nht->hash_shift); chain++) {\n\t\tstruct neighbour *n;\n\t\tstruct neighbour __rcu **np;\n\n\t\tnp = &nht->hash_buckets[chain];\n\t\twhile ((n = rcu_dereference_protected(*np,\n\t\t\t\t\tlockdep_is_held(&tbl->lock))) != NULL) {\n\t\t\tint release;\n\n\t\t\twrite_lock(&n->lock);\n\t\t\trelease = cb(n);\n\t\t\tif (release) {\n\t\t\t\trcu_assign_pointer(*np,\n\t\t\t\t\trcu_dereference_protected(n->next,\n\t\t\t\t\t\tlockdep_is_held(&tbl->lock)));\n\t\t\t\tneigh_mark_dead(n);\n\t\t\t} else\n\t\t\t\tnp = &n->next;\n\t\t\twrite_unlock(&n->lock);\n\t\t\tif (release)\n\t\t\t\tneigh_cleanup_and_release(n);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(__neigh_for_each_release);\n\nint neigh_xmit(int index, struct net_device *dev,\n\t       const void *addr, struct sk_buff *skb)\n{\n\tint err = -EAFNOSUPPORT;\n\tif (likely(index < NEIGH_NR_TABLES)) {\n\t\tstruct neigh_table *tbl;\n\t\tstruct neighbour *neigh;\n\n\t\ttbl = neigh_tables[index];\n\t\tif (!tbl)\n\t\t\tgoto out;\n\t\trcu_read_lock();\n\t\tif (index == NEIGH_ARP_TABLE) {\n\t\t\tu32 key = *((u32 *)addr);\n\n\t\t\tneigh = __ipv4_neigh_lookup_noref(dev, key);\n\t\t} else {\n\t\t\tneigh = __neigh_lookup_noref(tbl, addr, dev);\n\t\t}\n\t\tif (!neigh)\n\t\t\tneigh = __neigh_create(tbl, addr, dev, false);\n\t\terr = PTR_ERR(neigh);\n\t\tif (IS_ERR(neigh)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_kfree_skb;\n\t\t}\n\t\terr = READ_ONCE(neigh->output)(neigh, skb);\n\t\trcu_read_unlock();\n\t}\n\telse if (index == NEIGH_LINK_TABLE) {\n\t\terr = dev_hard_header(skb, dev, ntohs(skb->protocol),\n\t\t\t\t      addr, NULL, skb->len);\n\t\tif (err < 0)\n\t\t\tgoto out_kfree_skb;\n\t\terr = dev_queue_xmit(skb);\n\t}\nout:\n\treturn err;\nout_kfree_skb:\n\tkfree_skb(skb);\n\tgoto out;\n}\nEXPORT_SYMBOL(neigh_xmit);\n\n#ifdef CONFIG_PROC_FS\n\nstatic struct neighbour *neigh_get_first(struct seq_file *seq)\n{\n\tstruct neigh_seq_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct neigh_hash_table *nht = state->nht;\n\tstruct neighbour *n = NULL;\n\tint bucket;\n\n\tstate->flags &= ~NEIGH_SEQ_IS_PNEIGH;\n\tfor (bucket = 0; bucket < (1 << nht->hash_shift); bucket++) {\n\t\tn = rcu_dereference(nht->hash_buckets[bucket]);\n\n\t\twhile (n) {\n\t\t\tif (!net_eq(dev_net(n->dev), net))\n\t\t\t\tgoto next;\n\t\t\tif (state->neigh_sub_iter) {\n\t\t\t\tloff_t fakep = 0;\n\t\t\t\tvoid *v;\n\n\t\t\t\tv = state->neigh_sub_iter(state, n, &fakep);\n\t\t\t\tif (!v)\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!(state->flags & NEIGH_SEQ_SKIP_NOARP))\n\t\t\t\tbreak;\n\t\t\tif (READ_ONCE(n->nud_state) & ~NUD_NOARP)\n\t\t\t\tbreak;\nnext:\n\t\t\tn = rcu_dereference(n->next);\n\t\t}\n\n\t\tif (n)\n\t\t\tbreak;\n\t}\n\tstate->bucket = bucket;\n\n\treturn n;\n}\n\nstatic struct neighbour *neigh_get_next(struct seq_file *seq,\n\t\t\t\t\tstruct neighbour *n,\n\t\t\t\t\tloff_t *pos)\n{\n\tstruct neigh_seq_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct neigh_hash_table *nht = state->nht;\n\n\tif (state->neigh_sub_iter) {\n\t\tvoid *v = state->neigh_sub_iter(state, n, pos);\n\t\tif (v)\n\t\t\treturn n;\n\t}\n\tn = rcu_dereference(n->next);\n\n\twhile (1) {\n\t\twhile (n) {\n\t\t\tif (!net_eq(dev_net(n->dev), net))\n\t\t\t\tgoto next;\n\t\t\tif (state->neigh_sub_iter) {\n\t\t\t\tvoid *v = state->neigh_sub_iter(state, n, pos);\n\t\t\t\tif (v)\n\t\t\t\t\treturn n;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!(state->flags & NEIGH_SEQ_SKIP_NOARP))\n\t\t\t\tbreak;\n\n\t\t\tif (READ_ONCE(n->nud_state) & ~NUD_NOARP)\n\t\t\t\tbreak;\nnext:\n\t\t\tn = rcu_dereference(n->next);\n\t\t}\n\n\t\tif (n)\n\t\t\tbreak;\n\n\t\tif (++state->bucket >= (1 << nht->hash_shift))\n\t\t\tbreak;\n\n\t\tn = rcu_dereference(nht->hash_buckets[state->bucket]);\n\t}\n\n\tif (n && pos)\n\t\t--(*pos);\n\treturn n;\n}\n\nstatic struct neighbour *neigh_get_idx(struct seq_file *seq, loff_t *pos)\n{\n\tstruct neighbour *n = neigh_get_first(seq);\n\n\tif (n) {\n\t\t--(*pos);\n\t\twhile (*pos) {\n\t\t\tn = neigh_get_next(seq, n, pos);\n\t\t\tif (!n)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn *pos ? NULL : n;\n}\n\nstatic struct pneigh_entry *pneigh_get_first(struct seq_file *seq)\n{\n\tstruct neigh_seq_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct neigh_table *tbl = state->tbl;\n\tstruct pneigh_entry *pn = NULL;\n\tint bucket;\n\n\tstate->flags |= NEIGH_SEQ_IS_PNEIGH;\n\tfor (bucket = 0; bucket <= PNEIGH_HASHMASK; bucket++) {\n\t\tpn = tbl->phash_buckets[bucket];\n\t\twhile (pn && !net_eq(pneigh_net(pn), net))\n\t\t\tpn = pn->next;\n\t\tif (pn)\n\t\t\tbreak;\n\t}\n\tstate->bucket = bucket;\n\n\treturn pn;\n}\n\nstatic struct pneigh_entry *pneigh_get_next(struct seq_file *seq,\n\t\t\t\t\t    struct pneigh_entry *pn,\n\t\t\t\t\t    loff_t *pos)\n{\n\tstruct neigh_seq_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct neigh_table *tbl = state->tbl;\n\n\tdo {\n\t\tpn = pn->next;\n\t} while (pn && !net_eq(pneigh_net(pn), net));\n\n\twhile (!pn) {\n\t\tif (++state->bucket > PNEIGH_HASHMASK)\n\t\t\tbreak;\n\t\tpn = tbl->phash_buckets[state->bucket];\n\t\twhile (pn && !net_eq(pneigh_net(pn), net))\n\t\t\tpn = pn->next;\n\t\tif (pn)\n\t\t\tbreak;\n\t}\n\n\tif (pn && pos)\n\t\t--(*pos);\n\n\treturn pn;\n}\n\nstatic struct pneigh_entry *pneigh_get_idx(struct seq_file *seq, loff_t *pos)\n{\n\tstruct pneigh_entry *pn = pneigh_get_first(seq);\n\n\tif (pn) {\n\t\t--(*pos);\n\t\twhile (*pos) {\n\t\t\tpn = pneigh_get_next(seq, pn, pos);\n\t\t\tif (!pn)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn *pos ? NULL : pn;\n}\n\nstatic void *neigh_get_idx_any(struct seq_file *seq, loff_t *pos)\n{\n\tstruct neigh_seq_state *state = seq->private;\n\tvoid *rc;\n\tloff_t idxpos = *pos;\n\n\trc = neigh_get_idx(seq, &idxpos);\n\tif (!rc && !(state->flags & NEIGH_SEQ_NEIGH_ONLY))\n\t\trc = pneigh_get_idx(seq, &idxpos);\n\n\treturn rc;\n}\n\nvoid *neigh_seq_start(struct seq_file *seq, loff_t *pos, struct neigh_table *tbl, unsigned int neigh_seq_flags)\n\t__acquires(tbl->lock)\n\t__acquires(rcu)\n{\n\tstruct neigh_seq_state *state = seq->private;\n\n\tstate->tbl = tbl;\n\tstate->bucket = 0;\n\tstate->flags = (neigh_seq_flags & ~NEIGH_SEQ_IS_PNEIGH);\n\n\trcu_read_lock();\n\tstate->nht = rcu_dereference(tbl->nht);\n\tread_lock_bh(&tbl->lock);\n\n\treturn *pos ? neigh_get_idx_any(seq, pos) : SEQ_START_TOKEN;\n}\nEXPORT_SYMBOL(neigh_seq_start);\n\nvoid *neigh_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct neigh_seq_state *state;\n\tvoid *rc;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\trc = neigh_get_first(seq);\n\t\tgoto out;\n\t}\n\n\tstate = seq->private;\n\tif (!(state->flags & NEIGH_SEQ_IS_PNEIGH)) {\n\t\trc = neigh_get_next(seq, v, NULL);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tif (!(state->flags & NEIGH_SEQ_NEIGH_ONLY))\n\t\t\trc = pneigh_get_first(seq);\n\t} else {\n\t\tBUG_ON(state->flags & NEIGH_SEQ_NEIGH_ONLY);\n\t\trc = pneigh_get_next(seq, v, NULL);\n\t}\nout:\n\t++(*pos);\n\treturn rc;\n}\nEXPORT_SYMBOL(neigh_seq_next);\n\nvoid neigh_seq_stop(struct seq_file *seq, void *v)\n\t__releases(tbl->lock)\n\t__releases(rcu)\n{\n\tstruct neigh_seq_state *state = seq->private;\n\tstruct neigh_table *tbl = state->tbl;\n\n\tread_unlock_bh(&tbl->lock);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(neigh_seq_stop);\n\n \n\nstatic void *neigh_stat_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct neigh_table *tbl = pde_data(file_inode(seq->file));\n\tint cpu;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (cpu = *pos-1; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*pos = cpu+1;\n\t\treturn per_cpu_ptr(tbl->stats, cpu);\n\t}\n\treturn NULL;\n}\n\nstatic void *neigh_stat_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct neigh_table *tbl = pde_data(file_inode(seq->file));\n\tint cpu;\n\n\tfor (cpu = *pos; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*pos = cpu+1;\n\t\treturn per_cpu_ptr(tbl->stats, cpu);\n\t}\n\t(*pos)++;\n\treturn NULL;\n}\n\nstatic void neigh_stat_seq_stop(struct seq_file *seq, void *v)\n{\n\n}\n\nstatic int neigh_stat_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct neigh_table *tbl = pde_data(file_inode(seq->file));\n\tstruct neigh_statistics *st = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"entries  allocs   destroys hash_grows lookups  hits     res_failed rcv_probes_mcast rcv_probes_ucast periodic_gc_runs forced_gc_runs unresolved_discards table_fulls\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(seq, \"%08x %08lx %08lx %08lx   %08lx %08lx %08lx   \"\n\t\t\t\"%08lx         %08lx         %08lx         \"\n\t\t\t\"%08lx       %08lx            %08lx\\n\",\n\t\t   atomic_read(&tbl->entries),\n\n\t\t   st->allocs,\n\t\t   st->destroys,\n\t\t   st->hash_grows,\n\n\t\t   st->lookups,\n\t\t   st->hits,\n\n\t\t   st->res_failed,\n\n\t\t   st->rcv_probes_mcast,\n\t\t   st->rcv_probes_ucast,\n\n\t\t   st->periodic_gc_runs,\n\t\t   st->forced_gc_runs,\n\t\t   st->unres_discards,\n\t\t   st->table_fulls\n\t\t   );\n\n\treturn 0;\n}\n\nstatic const struct seq_operations neigh_stat_seq_ops = {\n\t.start\t= neigh_stat_seq_start,\n\t.next\t= neigh_stat_seq_next,\n\t.stop\t= neigh_stat_seq_stop,\n\t.show\t= neigh_stat_seq_show,\n};\n#endif  \n\nstatic void __neigh_notify(struct neighbour *n, int type, int flags,\n\t\t\t   u32 pid)\n{\n\tstruct net *net = dev_net(n->dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(neigh_nlmsg_size(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = neigh_fill_info(skb, n, pid, 0, type, flags);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_NEIGH, err);\n}\n\nvoid neigh_app_ns(struct neighbour *n)\n{\n\t__neigh_notify(n, RTM_GETNEIGH, NLM_F_REQUEST, 0);\n}\nEXPORT_SYMBOL(neigh_app_ns);\n\n#ifdef CONFIG_SYSCTL\nstatic int unres_qlen_max = INT_MAX / SKB_TRUESIZE(ETH_FRAME_LEN);\n\nstatic int proc_unres_qlen(struct ctl_table *ctl, int write,\n\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint size, ret;\n\tstruct ctl_table tmp = *ctl;\n\n\ttmp.extra1 = SYSCTL_ZERO;\n\ttmp.extra2 = &unres_qlen_max;\n\ttmp.data = &size;\n\n\tsize = *(int *)ctl->data / SKB_TRUESIZE(ETH_FRAME_LEN);\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\n\tif (write && !ret)\n\t\t*(int *)ctl->data = size * SKB_TRUESIZE(ETH_FRAME_LEN);\n\treturn ret;\n}\n\nstatic void neigh_copy_dflt_parms(struct net *net, struct neigh_parms *p,\n\t\t\t\t  int index)\n{\n\tstruct net_device *dev;\n\tint family = neigh_parms_family(p);\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tstruct neigh_parms *dst_p =\n\t\t\t\tneigh_get_dev_parms_rcu(dev, family);\n\n\t\tif (dst_p && !test_bit(index, dst_p->data_state))\n\t\t\tdst_p->data[index] = p->data[index];\n\t}\n\trcu_read_unlock();\n}\n\nstatic void neigh_proc_update(struct ctl_table *ctl, int write)\n{\n\tstruct net_device *dev = ctl->extra1;\n\tstruct neigh_parms *p = ctl->extra2;\n\tstruct net *net = neigh_parms_net(p);\n\tint index = (int *) ctl->data - p->data;\n\n\tif (!write)\n\t\treturn;\n\n\tset_bit(index, p->data_state);\n\tif (index == NEIGH_VAR_DELAY_PROBE_TIME)\n\t\tcall_netevent_notifiers(NETEVENT_DELAY_PROBE_TIME_UPDATE, p);\n\tif (!dev)  \n\t\tneigh_copy_dflt_parms(net, p, index);\n}\n\nstatic int neigh_proc_dointvec_zero_intmax(struct ctl_table *ctl, int write,\n\t\t\t\t\t   void *buffer, size_t *lenp,\n\t\t\t\t\t   loff_t *ppos)\n{\n\tstruct ctl_table tmp = *ctl;\n\tint ret;\n\n\ttmp.extra1 = SYSCTL_ZERO;\n\ttmp.extra2 = SYSCTL_INT_MAX;\n\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\tneigh_proc_update(ctl, write);\n\treturn ret;\n}\n\nstatic int neigh_proc_dointvec_ms_jiffies_positive(struct ctl_table *ctl, int write,\n\t\t\t\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table tmp = *ctl;\n\tint ret;\n\n\tint min = msecs_to_jiffies(1);\n\n\ttmp.extra1 = &min;\n\ttmp.extra2 = NULL;\n\n\tret = proc_dointvec_ms_jiffies_minmax(&tmp, write, buffer, lenp, ppos);\n\tneigh_proc_update(ctl, write);\n\treturn ret;\n}\n\nint neigh_proc_dointvec(struct ctl_table *ctl, int write, void *buffer,\n\t\t\tsize_t *lenp, loff_t *ppos)\n{\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tneigh_proc_update(ctl, write);\n\treturn ret;\n}\nEXPORT_SYMBOL(neigh_proc_dointvec);\n\nint neigh_proc_dointvec_jiffies(struct ctl_table *ctl, int write, void *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos)\n{\n\tint ret = proc_dointvec_jiffies(ctl, write, buffer, lenp, ppos);\n\n\tneigh_proc_update(ctl, write);\n\treturn ret;\n}\nEXPORT_SYMBOL(neigh_proc_dointvec_jiffies);\n\nstatic int neigh_proc_dointvec_userhz_jiffies(struct ctl_table *ctl, int write,\n\t\t\t\t\t      void *buffer, size_t *lenp,\n\t\t\t\t\t      loff_t *ppos)\n{\n\tint ret = proc_dointvec_userhz_jiffies(ctl, write, buffer, lenp, ppos);\n\n\tneigh_proc_update(ctl, write);\n\treturn ret;\n}\n\nint neigh_proc_dointvec_ms_jiffies(struct ctl_table *ctl, int write,\n\t\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret = proc_dointvec_ms_jiffies(ctl, write, buffer, lenp, ppos);\n\n\tneigh_proc_update(ctl, write);\n\treturn ret;\n}\nEXPORT_SYMBOL(neigh_proc_dointvec_ms_jiffies);\n\nstatic int neigh_proc_dointvec_unres_qlen(struct ctl_table *ctl, int write,\n\t\t\t\t\t  void *buffer, size_t *lenp,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tint ret = proc_unres_qlen(ctl, write, buffer, lenp, ppos);\n\n\tneigh_proc_update(ctl, write);\n\treturn ret;\n}\n\nstatic int neigh_proc_base_reachable_time(struct ctl_table *ctl, int write,\n\t\t\t\t\t  void *buffer, size_t *lenp,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct neigh_parms *p = ctl->extra2;\n\tint ret;\n\n\tif (strcmp(ctl->procname, \"base_reachable_time\") == 0)\n\t\tret = neigh_proc_dointvec_jiffies(ctl, write, buffer, lenp, ppos);\n\telse if (strcmp(ctl->procname, \"base_reachable_time_ms\") == 0)\n\t\tret = neigh_proc_dointvec_ms_jiffies(ctl, write, buffer, lenp, ppos);\n\telse\n\t\tret = -1;\n\n\tif (write && ret == 0) {\n\t\t \n\t\tp->reachable_time =\n\t\t\tneigh_rand_reach_time(NEIGH_VAR(p, BASE_REACHABLE_TIME));\n\t}\n\treturn ret;\n}\n\n#define NEIGH_PARMS_DATA_OFFSET(index)\t\\\n\t(&((struct neigh_parms *) 0)->data[index])\n\n#define NEIGH_SYSCTL_ENTRY(attr, data_attr, name, mval, proc) \\\n\t[NEIGH_VAR_ ## attr] = { \\\n\t\t.procname\t= name, \\\n\t\t.data\t\t= NEIGH_PARMS_DATA_OFFSET(NEIGH_VAR_ ## data_attr), \\\n\t\t.maxlen\t\t= sizeof(int), \\\n\t\t.mode\t\t= mval, \\\n\t\t.proc_handler\t= proc, \\\n\t}\n\n#define NEIGH_SYSCTL_ZERO_INTMAX_ENTRY(attr, name) \\\n\tNEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_zero_intmax)\n\n#define NEIGH_SYSCTL_JIFFIES_ENTRY(attr, name) \\\n\tNEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_jiffies)\n\n#define NEIGH_SYSCTL_USERHZ_JIFFIES_ENTRY(attr, name) \\\n\tNEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_userhz_jiffies)\n\n#define NEIGH_SYSCTL_MS_JIFFIES_POSITIVE_ENTRY(attr, name) \\\n\tNEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_ms_jiffies_positive)\n\n#define NEIGH_SYSCTL_MS_JIFFIES_REUSED_ENTRY(attr, data_attr, name) \\\n\tNEIGH_SYSCTL_ENTRY(attr, data_attr, name, 0644, neigh_proc_dointvec_ms_jiffies)\n\n#define NEIGH_SYSCTL_UNRES_QLEN_REUSED_ENTRY(attr, data_attr, name) \\\n\tNEIGH_SYSCTL_ENTRY(attr, data_attr, name, 0644, neigh_proc_dointvec_unres_qlen)\n\nstatic struct neigh_sysctl_table {\n\tstruct ctl_table_header *sysctl_header;\n\tstruct ctl_table neigh_vars[NEIGH_VAR_MAX + 1];\n} neigh_sysctl_template __read_mostly = {\n\t.neigh_vars = {\n\t\tNEIGH_SYSCTL_ZERO_INTMAX_ENTRY(MCAST_PROBES, \"mcast_solicit\"),\n\t\tNEIGH_SYSCTL_ZERO_INTMAX_ENTRY(UCAST_PROBES, \"ucast_solicit\"),\n\t\tNEIGH_SYSCTL_ZERO_INTMAX_ENTRY(APP_PROBES, \"app_solicit\"),\n\t\tNEIGH_SYSCTL_ZERO_INTMAX_ENTRY(MCAST_REPROBES, \"mcast_resolicit\"),\n\t\tNEIGH_SYSCTL_USERHZ_JIFFIES_ENTRY(RETRANS_TIME, \"retrans_time\"),\n\t\tNEIGH_SYSCTL_JIFFIES_ENTRY(BASE_REACHABLE_TIME, \"base_reachable_time\"),\n\t\tNEIGH_SYSCTL_JIFFIES_ENTRY(DELAY_PROBE_TIME, \"delay_first_probe_time\"),\n\t\tNEIGH_SYSCTL_MS_JIFFIES_POSITIVE_ENTRY(INTERVAL_PROBE_TIME_MS,\n\t\t\t\t\t\t       \"interval_probe_time_ms\"),\n\t\tNEIGH_SYSCTL_JIFFIES_ENTRY(GC_STALETIME, \"gc_stale_time\"),\n\t\tNEIGH_SYSCTL_ZERO_INTMAX_ENTRY(QUEUE_LEN_BYTES, \"unres_qlen_bytes\"),\n\t\tNEIGH_SYSCTL_ZERO_INTMAX_ENTRY(PROXY_QLEN, \"proxy_qlen\"),\n\t\tNEIGH_SYSCTL_USERHZ_JIFFIES_ENTRY(ANYCAST_DELAY, \"anycast_delay\"),\n\t\tNEIGH_SYSCTL_USERHZ_JIFFIES_ENTRY(PROXY_DELAY, \"proxy_delay\"),\n\t\tNEIGH_SYSCTL_USERHZ_JIFFIES_ENTRY(LOCKTIME, \"locktime\"),\n\t\tNEIGH_SYSCTL_UNRES_QLEN_REUSED_ENTRY(QUEUE_LEN, QUEUE_LEN_BYTES, \"unres_qlen\"),\n\t\tNEIGH_SYSCTL_MS_JIFFIES_REUSED_ENTRY(RETRANS_TIME_MS, RETRANS_TIME, \"retrans_time_ms\"),\n\t\tNEIGH_SYSCTL_MS_JIFFIES_REUSED_ENTRY(BASE_REACHABLE_TIME_MS, BASE_REACHABLE_TIME, \"base_reachable_time_ms\"),\n\t\t[NEIGH_VAR_GC_INTERVAL] = {\n\t\t\t.procname\t= \"gc_interval\",\n\t\t\t.maxlen\t\t= sizeof(int),\n\t\t\t.mode\t\t= 0644,\n\t\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t\t},\n\t\t[NEIGH_VAR_GC_THRESH1] = {\n\t\t\t.procname\t= \"gc_thresh1\",\n\t\t\t.maxlen\t\t= sizeof(int),\n\t\t\t.mode\t\t= 0644,\n\t\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t},\n\t\t[NEIGH_VAR_GC_THRESH2] = {\n\t\t\t.procname\t= \"gc_thresh2\",\n\t\t\t.maxlen\t\t= sizeof(int),\n\t\t\t.mode\t\t= 0644,\n\t\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t},\n\t\t[NEIGH_VAR_GC_THRESH3] = {\n\t\t\t.procname\t= \"gc_thresh3\",\n\t\t\t.maxlen\t\t= sizeof(int),\n\t\t\t.mode\t\t= 0644,\n\t\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t},\n\t\t{},\n\t},\n};\n\nint neigh_sysctl_register(struct net_device *dev, struct neigh_parms *p,\n\t\t\t  proc_handler *handler)\n{\n\tint i;\n\tstruct neigh_sysctl_table *t;\n\tconst char *dev_name_source;\n\tchar neigh_path[ sizeof(\"net//neigh/\") + IFNAMSIZ + IFNAMSIZ ];\n\tchar *p_name;\n\tsize_t neigh_vars_size;\n\n\tt = kmemdup(&neigh_sysctl_template, sizeof(*t), GFP_KERNEL_ACCOUNT);\n\tif (!t)\n\t\tgoto err;\n\n\tfor (i = 0; i < NEIGH_VAR_GC_INTERVAL; i++) {\n\t\tt->neigh_vars[i].data += (long) p;\n\t\tt->neigh_vars[i].extra1 = dev;\n\t\tt->neigh_vars[i].extra2 = p;\n\t}\n\n\tneigh_vars_size = ARRAY_SIZE(t->neigh_vars);\n\tif (dev) {\n\t\tdev_name_source = dev->name;\n\t\t \n\t\tmemset(&t->neigh_vars[NEIGH_VAR_GC_INTERVAL], 0,\n\t\t       sizeof(t->neigh_vars[NEIGH_VAR_GC_INTERVAL]));\n\t\tneigh_vars_size = NEIGH_VAR_BASE_REACHABLE_TIME_MS + 1;\n\t} else {\n\t\tstruct neigh_table *tbl = p->tbl;\n\t\tdev_name_source = \"default\";\n\t\tt->neigh_vars[NEIGH_VAR_GC_INTERVAL].data = &tbl->gc_interval;\n\t\tt->neigh_vars[NEIGH_VAR_GC_THRESH1].data = &tbl->gc_thresh1;\n\t\tt->neigh_vars[NEIGH_VAR_GC_THRESH2].data = &tbl->gc_thresh2;\n\t\tt->neigh_vars[NEIGH_VAR_GC_THRESH3].data = &tbl->gc_thresh3;\n\t}\n\n\tif (handler) {\n\t\t \n\t\tt->neigh_vars[NEIGH_VAR_RETRANS_TIME].proc_handler = handler;\n\t\t \n\t\tt->neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME].proc_handler = handler;\n\t\t \n\t\tt->neigh_vars[NEIGH_VAR_RETRANS_TIME_MS].proc_handler = handler;\n\t\t \n\t\tt->neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME_MS].proc_handler = handler;\n\t} else {\n\t\t \n\t\t \n\t\tt->neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME].proc_handler =\n\t\t\tneigh_proc_base_reachable_time;\n\t\t \n\t\tt->neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME_MS].proc_handler =\n\t\t\tneigh_proc_base_reachable_time;\n\t}\n\n\tswitch (neigh_parms_family(p)) {\n\tcase AF_INET:\n\t      p_name = \"ipv4\";\n\t      break;\n\tcase AF_INET6:\n\t      p_name = \"ipv6\";\n\t      break;\n\tdefault:\n\t      BUG();\n\t}\n\n\tsnprintf(neigh_path, sizeof(neigh_path), \"net/%s/neigh/%s\",\n\t\tp_name, dev_name_source);\n\tt->sysctl_header = register_net_sysctl_sz(neigh_parms_net(p),\n\t\t\t\t\t\t  neigh_path, t->neigh_vars,\n\t\t\t\t\t\t  neigh_vars_size);\n\tif (!t->sysctl_header)\n\t\tgoto free;\n\n\tp->sysctl_table = t;\n\treturn 0;\n\nfree:\n\tkfree(t);\nerr:\n\treturn -ENOBUFS;\n}\nEXPORT_SYMBOL(neigh_sysctl_register);\n\nvoid neigh_sysctl_unregister(struct neigh_parms *p)\n{\n\tif (p->sysctl_table) {\n\t\tstruct neigh_sysctl_table *t = p->sysctl_table;\n\t\tp->sysctl_table = NULL;\n\t\tunregister_net_sysctl_table(t->sysctl_header);\n\t\tkfree(t);\n\t}\n}\nEXPORT_SYMBOL(neigh_sysctl_unregister);\n\n#endif\t \n\nstatic int __init neigh_init(void)\n{\n\trtnl_register(PF_UNSPEC, RTM_NEWNEIGH, neigh_add, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELNEIGH, neigh_delete, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETNEIGH, neigh_get, neigh_dump_info, 0);\n\n\trtnl_register(PF_UNSPEC, RTM_GETNEIGHTBL, NULL, neightbl_dump_info,\n\t\t      0);\n\trtnl_register(PF_UNSPEC, RTM_SETNEIGHTBL, neightbl_set, NULL, 0);\n\n\treturn 0;\n}\n\nsubsys_initcall(neigh_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}