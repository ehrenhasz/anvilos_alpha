{
  "module_name": "page_pool.c",
  "hash_id": "64e674cd386099778bf0f7de3a97c9c75ce32cc85b5dfe3c0a1f558d346490bd",
  "original_prompt": "Ingested from linux-6.6.14/net/core/page_pool.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n\n#include <net/page_pool/helpers.h>\n#include <net/xdp.h>\n\n#include <linux/dma-direction.h>\n#include <linux/dma-mapping.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>  \n#include <linux/poison.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n\n#include <trace/events/page_pool.h>\n\n#define DEFER_TIME (msecs_to_jiffies(1000))\n#define DEFER_WARN_INTERVAL (60 * HZ)\n\n#define BIAS_MAX\tLONG_MAX\n\n#ifdef CONFIG_PAGE_POOL_STATS\n \n#define alloc_stat_inc(pool, __stat)\t(pool->alloc_stats.__stat++)\n \n#define recycle_stat_inc(pool, __stat)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tstruct page_pool_recycle_stats __percpu *s = pool->recycle_stats;\t\\\n\t\tthis_cpu_inc(s->__stat);\t\t\t\t\t\t\\\n\t} while (0)\n\n#define recycle_stat_add(pool, __stat, val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tstruct page_pool_recycle_stats __percpu *s = pool->recycle_stats;\t\\\n\t\tthis_cpu_add(s->__stat, val);\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic const char pp_stats[][ETH_GSTRING_LEN] = {\n\t\"rx_pp_alloc_fast\",\n\t\"rx_pp_alloc_slow\",\n\t\"rx_pp_alloc_slow_ho\",\n\t\"rx_pp_alloc_empty\",\n\t\"rx_pp_alloc_refill\",\n\t\"rx_pp_alloc_waive\",\n\t\"rx_pp_recycle_cached\",\n\t\"rx_pp_recycle_cache_full\",\n\t\"rx_pp_recycle_ring\",\n\t\"rx_pp_recycle_ring_full\",\n\t\"rx_pp_recycle_released_ref\",\n};\n\n \nbool page_pool_get_stats(struct page_pool *pool,\n\t\t\t struct page_pool_stats *stats)\n{\n\tint cpu = 0;\n\n\tif (!stats)\n\t\treturn false;\n\n\t \n\tstats->alloc_stats.fast += pool->alloc_stats.fast;\n\tstats->alloc_stats.slow += pool->alloc_stats.slow;\n\tstats->alloc_stats.slow_high_order += pool->alloc_stats.slow_high_order;\n\tstats->alloc_stats.empty += pool->alloc_stats.empty;\n\tstats->alloc_stats.refill += pool->alloc_stats.refill;\n\tstats->alloc_stats.waive += pool->alloc_stats.waive;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct page_pool_recycle_stats *pcpu =\n\t\t\tper_cpu_ptr(pool->recycle_stats, cpu);\n\n\t\tstats->recycle_stats.cached += pcpu->cached;\n\t\tstats->recycle_stats.cache_full += pcpu->cache_full;\n\t\tstats->recycle_stats.ring += pcpu->ring;\n\t\tstats->recycle_stats.ring_full += pcpu->ring_full;\n\t\tstats->recycle_stats.released_refcnt += pcpu->released_refcnt;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(page_pool_get_stats);\n\nu8 *page_pool_ethtool_stats_get_strings(u8 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pp_stats); i++) {\n\t\tmemcpy(data, pp_stats[i], ETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\treturn data;\n}\nEXPORT_SYMBOL(page_pool_ethtool_stats_get_strings);\n\nint page_pool_ethtool_stats_get_count(void)\n{\n\treturn ARRAY_SIZE(pp_stats);\n}\nEXPORT_SYMBOL(page_pool_ethtool_stats_get_count);\n\nu64 *page_pool_ethtool_stats_get(u64 *data, void *stats)\n{\n\tstruct page_pool_stats *pool_stats = stats;\n\n\t*data++ = pool_stats->alloc_stats.fast;\n\t*data++ = pool_stats->alloc_stats.slow;\n\t*data++ = pool_stats->alloc_stats.slow_high_order;\n\t*data++ = pool_stats->alloc_stats.empty;\n\t*data++ = pool_stats->alloc_stats.refill;\n\t*data++ = pool_stats->alloc_stats.waive;\n\t*data++ = pool_stats->recycle_stats.cached;\n\t*data++ = pool_stats->recycle_stats.cache_full;\n\t*data++ = pool_stats->recycle_stats.ring;\n\t*data++ = pool_stats->recycle_stats.ring_full;\n\t*data++ = pool_stats->recycle_stats.released_refcnt;\n\n\treturn data;\n}\nEXPORT_SYMBOL(page_pool_ethtool_stats_get);\n\n#else\n#define alloc_stat_inc(pool, __stat)\n#define recycle_stat_inc(pool, __stat)\n#define recycle_stat_add(pool, __stat, val)\n#endif\n\nstatic bool page_pool_producer_lock(struct page_pool *pool)\n\t__acquires(&pool->ring.producer_lock)\n{\n\tbool in_softirq = in_softirq();\n\n\tif (in_softirq)\n\t\tspin_lock(&pool->ring.producer_lock);\n\telse\n\t\tspin_lock_bh(&pool->ring.producer_lock);\n\n\treturn in_softirq;\n}\n\nstatic void page_pool_producer_unlock(struct page_pool *pool,\n\t\t\t\t      bool in_softirq)\n\t__releases(&pool->ring.producer_lock)\n{\n\tif (in_softirq)\n\t\tspin_unlock(&pool->ring.producer_lock);\n\telse\n\t\tspin_unlock_bh(&pool->ring.producer_lock);\n}\n\nstatic int page_pool_init(struct page_pool *pool,\n\t\t\t  const struct page_pool_params *params)\n{\n\tunsigned int ring_qsize = 1024;  \n\n\tmemcpy(&pool->p, params, sizeof(pool->p));\n\n\t \n\tif (pool->p.flags & ~(PP_FLAG_ALL))\n\t\treturn -EINVAL;\n\n\tif (pool->p.pool_size)\n\t\tring_qsize = pool->p.pool_size;\n\n\t \n\tif (ring_qsize > 32768)\n\t\treturn -E2BIG;\n\n\t \n\tif (pool->p.flags & PP_FLAG_DMA_MAP) {\n\t\tif ((pool->p.dma_dir != DMA_FROM_DEVICE) &&\n\t\t    (pool->p.dma_dir != DMA_BIDIRECTIONAL))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (pool->p.flags & PP_FLAG_DMA_SYNC_DEV) {\n\t\t \n\t\tif (!(pool->p.flags & PP_FLAG_DMA_MAP))\n\t\t\treturn -EINVAL;\n\n\t\tif (!pool->p.max_len)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t}\n\n\tif (PAGE_POOL_DMA_USE_PP_FRAG_COUNT &&\n\t    pool->p.flags & PP_FLAG_PAGE_FRAG)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_PAGE_POOL_STATS\n\tpool->recycle_stats = alloc_percpu(struct page_pool_recycle_stats);\n\tif (!pool->recycle_stats)\n\t\treturn -ENOMEM;\n#endif\n\n\tif (ptr_ring_init(&pool->ring, ring_qsize, GFP_KERNEL) < 0) {\n#ifdef CONFIG_PAGE_POOL_STATS\n\t\tfree_percpu(pool->recycle_stats);\n#endif\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&pool->pages_state_release_cnt, 0);\n\n\t \n\trefcount_set(&pool->user_cnt, 1);\n\n\tif (pool->p.flags & PP_FLAG_DMA_MAP)\n\t\tget_device(pool->p.dev);\n\n\treturn 0;\n}\n\n \nstruct page_pool *page_pool_create(const struct page_pool_params *params)\n{\n\tstruct page_pool *pool;\n\tint err;\n\n\tpool = kzalloc_node(sizeof(*pool), GFP_KERNEL, params->nid);\n\tif (!pool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = page_pool_init(pool, params);\n\tif (err < 0) {\n\t\tpr_warn(\"%s() gave up with errno %d\\n\", __func__, err);\n\t\tkfree(pool);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn pool;\n}\nEXPORT_SYMBOL(page_pool_create);\n\nstatic void page_pool_return_page(struct page_pool *pool, struct page *page);\n\nnoinline\nstatic struct page *page_pool_refill_alloc_cache(struct page_pool *pool)\n{\n\tstruct ptr_ring *r = &pool->ring;\n\tstruct page *page;\n\tint pref_nid;  \n\n\t \n\tif (__ptr_ring_empty(r)) {\n\t\talloc_stat_inc(pool, empty);\n\t\treturn NULL;\n\t}\n\n\t \n#ifdef CONFIG_NUMA\n\tpref_nid = (pool->p.nid == NUMA_NO_NODE) ? numa_mem_id() : pool->p.nid;\n#else\n\t \n\tpref_nid = numa_mem_id();  \n#endif\n\n\t \n\tdo {\n\t\tpage = __ptr_ring_consume(r);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (likely(page_to_nid(page) == pref_nid)) {\n\t\t\tpool->alloc.cache[pool->alloc.count++] = page;\n\t\t} else {\n\t\t\t \n\t\t\tpage_pool_return_page(pool, page);\n\t\t\talloc_stat_inc(pool, waive);\n\t\t\tpage = NULL;\n\t\t\tbreak;\n\t\t}\n\t} while (pool->alloc.count < PP_ALLOC_CACHE_REFILL);\n\n\t \n\tif (likely(pool->alloc.count > 0)) {\n\t\tpage = pool->alloc.cache[--pool->alloc.count];\n\t\talloc_stat_inc(pool, refill);\n\t}\n\n\treturn page;\n}\n\n \nstatic struct page *__page_pool_get_cached(struct page_pool *pool)\n{\n\tstruct page *page;\n\n\t \n\tif (likely(pool->alloc.count)) {\n\t\t \n\t\tpage = pool->alloc.cache[--pool->alloc.count];\n\t\talloc_stat_inc(pool, fast);\n\t} else {\n\t\tpage = page_pool_refill_alloc_cache(pool);\n\t}\n\n\treturn page;\n}\n\nstatic void page_pool_dma_sync_for_device(struct page_pool *pool,\n\t\t\t\t\t  struct page *page,\n\t\t\t\t\t  unsigned int dma_sync_size)\n{\n\tdma_addr_t dma_addr = page_pool_get_dma_addr(page);\n\n\tdma_sync_size = min(dma_sync_size, pool->p.max_len);\n\tdma_sync_single_range_for_device(pool->p.dev, dma_addr,\n\t\t\t\t\t pool->p.offset, dma_sync_size,\n\t\t\t\t\t pool->p.dma_dir);\n}\n\nstatic bool page_pool_dma_map(struct page_pool *pool, struct page *page)\n{\n\tdma_addr_t dma;\n\n\t \n\tdma = dma_map_page_attrs(pool->p.dev, page, 0,\n\t\t\t\t (PAGE_SIZE << pool->p.order),\n\t\t\t\t pool->p.dma_dir, DMA_ATTR_SKIP_CPU_SYNC |\n\t\t\t\t\t\t  DMA_ATTR_WEAK_ORDERING);\n\tif (dma_mapping_error(pool->p.dev, dma))\n\t\treturn false;\n\n\tpage_pool_set_dma_addr(page, dma);\n\n\tif (pool->p.flags & PP_FLAG_DMA_SYNC_DEV)\n\t\tpage_pool_dma_sync_for_device(pool, page, pool->p.max_len);\n\n\treturn true;\n}\n\nstatic void page_pool_set_pp_info(struct page_pool *pool,\n\t\t\t\t  struct page *page)\n{\n\tpage->pp = pool;\n\tpage->pp_magic |= PP_SIGNATURE;\n\tif (pool->p.init_callback)\n\t\tpool->p.init_callback(page, pool->p.init_arg);\n}\n\nstatic void page_pool_clear_pp_info(struct page *page)\n{\n\tpage->pp_magic = 0;\n\tpage->pp = NULL;\n}\n\nstatic struct page *__page_pool_alloc_page_order(struct page_pool *pool,\n\t\t\t\t\t\t gfp_t gfp)\n{\n\tstruct page *page;\n\n\tgfp |= __GFP_COMP;\n\tpage = alloc_pages_node(pool->p.nid, gfp, pool->p.order);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tif ((pool->p.flags & PP_FLAG_DMA_MAP) &&\n\t    unlikely(!page_pool_dma_map(pool, page))) {\n\t\tput_page(page);\n\t\treturn NULL;\n\t}\n\n\talloc_stat_inc(pool, slow_high_order);\n\tpage_pool_set_pp_info(pool, page);\n\n\t \n\tpool->pages_state_hold_cnt++;\n\ttrace_page_pool_state_hold(pool, page, pool->pages_state_hold_cnt);\n\treturn page;\n}\n\n \nnoinline\nstatic struct page *__page_pool_alloc_pages_slow(struct page_pool *pool,\n\t\t\t\t\t\t gfp_t gfp)\n{\n\tconst int bulk = PP_ALLOC_CACHE_REFILL;\n\tunsigned int pp_flags = pool->p.flags;\n\tunsigned int pp_order = pool->p.order;\n\tstruct page *page;\n\tint i, nr_pages;\n\n\t \n\tif (unlikely(pp_order))\n\t\treturn __page_pool_alloc_page_order(pool, gfp);\n\n\t \n\tif (unlikely(pool->alloc.count > 0))\n\t\treturn pool->alloc.cache[--pool->alloc.count];\n\n\t \n\tmemset(&pool->alloc.cache, 0, sizeof(void *) * bulk);\n\n\tnr_pages = alloc_pages_bulk_array_node(gfp, pool->p.nid, bulk,\n\t\t\t\t\t       pool->alloc.cache);\n\tif (unlikely(!nr_pages))\n\t\treturn NULL;\n\n\t \n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = pool->alloc.cache[i];\n\t\tif ((pp_flags & PP_FLAG_DMA_MAP) &&\n\t\t    unlikely(!page_pool_dma_map(pool, page))) {\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage_pool_set_pp_info(pool, page);\n\t\tpool->alloc.cache[pool->alloc.count++] = page;\n\t\t \n\t\tpool->pages_state_hold_cnt++;\n\t\ttrace_page_pool_state_hold(pool, page,\n\t\t\t\t\t   pool->pages_state_hold_cnt);\n\t}\n\n\t \n\tif (likely(pool->alloc.count > 0)) {\n\t\tpage = pool->alloc.cache[--pool->alloc.count];\n\t\talloc_stat_inc(pool, slow);\n\t} else {\n\t\tpage = NULL;\n\t}\n\n\t \n\treturn page;\n}\n\n \nstruct page *page_pool_alloc_pages(struct page_pool *pool, gfp_t gfp)\n{\n\tstruct page *page;\n\n\t \n\tpage = __page_pool_get_cached(pool);\n\tif (page)\n\t\treturn page;\n\n\t \n\tpage = __page_pool_alloc_pages_slow(pool, gfp);\n\treturn page;\n}\nEXPORT_SYMBOL(page_pool_alloc_pages);\n\n \n#define _distance(a, b)\t(s32)((a) - (b))\n\nstatic s32 page_pool_inflight(struct page_pool *pool)\n{\n\tu32 release_cnt = atomic_read(&pool->pages_state_release_cnt);\n\tu32 hold_cnt = READ_ONCE(pool->pages_state_hold_cnt);\n\ts32 inflight;\n\n\tinflight = _distance(hold_cnt, release_cnt);\n\n\ttrace_page_pool_release(pool, inflight, hold_cnt, release_cnt);\n\tWARN(inflight < 0, \"Negative(%d) inflight packet-pages\", inflight);\n\n\treturn inflight;\n}\n\n \nstatic void page_pool_return_page(struct page_pool *pool, struct page *page)\n{\n\tdma_addr_t dma;\n\tint count;\n\n\tif (!(pool->p.flags & PP_FLAG_DMA_MAP))\n\t\t \n\t\tgoto skip_dma_unmap;\n\n\tdma = page_pool_get_dma_addr(page);\n\n\t \n\tdma_unmap_page_attrs(pool->p.dev, dma,\n\t\t\t     PAGE_SIZE << pool->p.order, pool->p.dma_dir,\n\t\t\t     DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING);\n\tpage_pool_set_dma_addr(page, 0);\nskip_dma_unmap:\n\tpage_pool_clear_pp_info(page);\n\n\t \n\tcount = atomic_inc_return_relaxed(&pool->pages_state_release_cnt);\n\ttrace_page_pool_state_release(pool, page, count);\n\n\tput_page(page);\n\t \n}\n\nstatic bool page_pool_recycle_in_ring(struct page_pool *pool, struct page *page)\n{\n\tint ret;\n\t \n\tif (in_softirq())\n\t\tret = ptr_ring_produce(&pool->ring, page);\n\telse\n\t\tret = ptr_ring_produce_bh(&pool->ring, page);\n\n\tif (!ret) {\n\t\trecycle_stat_inc(pool, ring);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool page_pool_recycle_in_cache(struct page *page,\n\t\t\t\t       struct page_pool *pool)\n{\n\tif (unlikely(pool->alloc.count == PP_ALLOC_CACHE_SIZE)) {\n\t\trecycle_stat_inc(pool, cache_full);\n\t\treturn false;\n\t}\n\n\t \n\tpool->alloc.cache[pool->alloc.count++] = page;\n\trecycle_stat_inc(pool, cached);\n\treturn true;\n}\n\n \nstatic __always_inline struct page *\n__page_pool_put_page(struct page_pool *pool, struct page *page,\n\t\t     unsigned int dma_sync_size, bool allow_direct)\n{\n\tlockdep_assert_no_hardirq();\n\n\t \n\tif (likely(page_ref_count(page) == 1 && !page_is_pfmemalloc(page))) {\n\t\t \n\n\t\tif (pool->p.flags & PP_FLAG_DMA_SYNC_DEV)\n\t\t\tpage_pool_dma_sync_for_device(pool, page,\n\t\t\t\t\t\t      dma_sync_size);\n\n\t\tif (allow_direct && in_softirq() &&\n\t\t    page_pool_recycle_in_cache(page, pool))\n\t\t\treturn NULL;\n\n\t\t \n\t\treturn page;\n\t}\n\t \n\trecycle_stat_inc(pool, released_refcnt);\n\tpage_pool_return_page(pool, page);\n\n\treturn NULL;\n}\n\nvoid page_pool_put_defragged_page(struct page_pool *pool, struct page *page,\n\t\t\t\t  unsigned int dma_sync_size, bool allow_direct)\n{\n\tpage = __page_pool_put_page(pool, page, dma_sync_size, allow_direct);\n\tif (page && !page_pool_recycle_in_ring(pool, page)) {\n\t\t \n\t\trecycle_stat_inc(pool, ring_full);\n\t\tpage_pool_return_page(pool, page);\n\t}\n}\nEXPORT_SYMBOL(page_pool_put_defragged_page);\n\n \nvoid page_pool_put_page_bulk(struct page_pool *pool, void **data,\n\t\t\t     int count)\n{\n\tint i, bulk_len = 0;\n\tbool in_softirq;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct page *page = virt_to_head_page(data[i]);\n\n\t\t \n\t\tif (!page_pool_is_last_frag(pool, page))\n\t\t\tcontinue;\n\n\t\tpage = __page_pool_put_page(pool, page, -1, false);\n\t\t \n\t\tif (page)\n\t\t\tdata[bulk_len++] = page;\n\t}\n\n\tif (unlikely(!bulk_len))\n\t\treturn;\n\n\t \n\tin_softirq = page_pool_producer_lock(pool);\n\tfor (i = 0; i < bulk_len; i++) {\n\t\tif (__ptr_ring_produce(&pool->ring, data[i])) {\n\t\t\t \n\t\t\trecycle_stat_inc(pool, ring_full);\n\t\t\tbreak;\n\t\t}\n\t}\n\trecycle_stat_add(pool, ring, i);\n\tpage_pool_producer_unlock(pool, in_softirq);\n\n\t \n\tif (likely(i == bulk_len))\n\t\treturn;\n\n\t \n\tfor (; i < bulk_len; i++)\n\t\tpage_pool_return_page(pool, data[i]);\n}\nEXPORT_SYMBOL(page_pool_put_page_bulk);\n\nstatic struct page *page_pool_drain_frag(struct page_pool *pool,\n\t\t\t\t\t struct page *page)\n{\n\tlong drain_count = BIAS_MAX - pool->frag_users;\n\n\t \n\tif (likely(page_pool_defrag_page(page, drain_count)))\n\t\treturn NULL;\n\n\tif (page_ref_count(page) == 1 && !page_is_pfmemalloc(page)) {\n\t\tif (pool->p.flags & PP_FLAG_DMA_SYNC_DEV)\n\t\t\tpage_pool_dma_sync_for_device(pool, page, -1);\n\n\t\treturn page;\n\t}\n\n\tpage_pool_return_page(pool, page);\n\treturn NULL;\n}\n\nstatic void page_pool_free_frag(struct page_pool *pool)\n{\n\tlong drain_count = BIAS_MAX - pool->frag_users;\n\tstruct page *page = pool->frag_page;\n\n\tpool->frag_page = NULL;\n\n\tif (!page || page_pool_defrag_page(page, drain_count))\n\t\treturn;\n\n\tpage_pool_return_page(pool, page);\n}\n\nstruct page *page_pool_alloc_frag(struct page_pool *pool,\n\t\t\t\t  unsigned int *offset,\n\t\t\t\t  unsigned int size, gfp_t gfp)\n{\n\tunsigned int max_size = PAGE_SIZE << pool->p.order;\n\tstruct page *page = pool->frag_page;\n\n\tif (WARN_ON(!(pool->p.flags & PP_FLAG_PAGE_FRAG) ||\n\t\t    size > max_size))\n\t\treturn NULL;\n\n\tsize = ALIGN(size, dma_get_cache_alignment());\n\t*offset = pool->frag_offset;\n\n\tif (page && *offset + size > max_size) {\n\t\tpage = page_pool_drain_frag(pool, page);\n\t\tif (page) {\n\t\t\talloc_stat_inc(pool, fast);\n\t\t\tgoto frag_reset;\n\t\t}\n\t}\n\n\tif (!page) {\n\t\tpage = page_pool_alloc_pages(pool, gfp);\n\t\tif (unlikely(!page)) {\n\t\t\tpool->frag_page = NULL;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tpool->frag_page = page;\n\nfrag_reset:\n\t\tpool->frag_users = 1;\n\t\t*offset = 0;\n\t\tpool->frag_offset = size;\n\t\tpage_pool_fragment_page(page, BIAS_MAX);\n\t\treturn page;\n\t}\n\n\tpool->frag_users++;\n\tpool->frag_offset = *offset + size;\n\talloc_stat_inc(pool, fast);\n\treturn page;\n}\nEXPORT_SYMBOL(page_pool_alloc_frag);\n\nstatic void page_pool_empty_ring(struct page_pool *pool)\n{\n\tstruct page *page;\n\n\t \n\twhile ((page = ptr_ring_consume_bh(&pool->ring))) {\n\t\t \n\t\tif (!(page_ref_count(page) == 1))\n\t\t\tpr_crit(\"%s() page_pool refcnt %d violation\\n\",\n\t\t\t\t__func__, page_ref_count(page));\n\n\t\tpage_pool_return_page(pool, page);\n\t}\n}\n\nstatic void page_pool_free(struct page_pool *pool)\n{\n\tif (pool->disconnect)\n\t\tpool->disconnect(pool);\n\n\tptr_ring_cleanup(&pool->ring, NULL);\n\n\tif (pool->p.flags & PP_FLAG_DMA_MAP)\n\t\tput_device(pool->p.dev);\n\n#ifdef CONFIG_PAGE_POOL_STATS\n\tfree_percpu(pool->recycle_stats);\n#endif\n\tkfree(pool);\n}\n\nstatic void page_pool_empty_alloc_cache_once(struct page_pool *pool)\n{\n\tstruct page *page;\n\n\tif (pool->destroy_cnt)\n\t\treturn;\n\n\t \n\twhile (pool->alloc.count) {\n\t\tpage = pool->alloc.cache[--pool->alloc.count];\n\t\tpage_pool_return_page(pool, page);\n\t}\n}\n\nstatic void page_pool_scrub(struct page_pool *pool)\n{\n\tpage_pool_empty_alloc_cache_once(pool);\n\tpool->destroy_cnt++;\n\n\t \n\tpage_pool_empty_ring(pool);\n}\n\nstatic int page_pool_release(struct page_pool *pool)\n{\n\tint inflight;\n\n\tpage_pool_scrub(pool);\n\tinflight = page_pool_inflight(pool);\n\tif (!inflight)\n\t\tpage_pool_free(pool);\n\n\treturn inflight;\n}\n\nstatic void page_pool_release_retry(struct work_struct *wq)\n{\n\tstruct delayed_work *dwq = to_delayed_work(wq);\n\tstruct page_pool *pool = container_of(dwq, typeof(*pool), release_dw);\n\tint inflight;\n\n\tinflight = page_pool_release(pool);\n\tif (!inflight)\n\t\treturn;\n\n\t \n\tif (time_after_eq(jiffies, pool->defer_warn)) {\n\t\tint sec = (s32)((u32)jiffies - (u32)pool->defer_start) / HZ;\n\n\t\tpr_warn(\"%s() stalled pool shutdown %d inflight %d sec\\n\",\n\t\t\t__func__, inflight, sec);\n\t\tpool->defer_warn = jiffies + DEFER_WARN_INTERVAL;\n\t}\n\n\t \n\tschedule_delayed_work(&pool->release_dw, DEFER_TIME);\n}\n\nvoid page_pool_use_xdp_mem(struct page_pool *pool, void (*disconnect)(void *),\n\t\t\t   struct xdp_mem_info *mem)\n{\n\trefcount_inc(&pool->user_cnt);\n\tpool->disconnect = disconnect;\n\tpool->xdp_mem_id = mem->id;\n}\n\nvoid page_pool_unlink_napi(struct page_pool *pool)\n{\n\tif (!pool->p.napi)\n\t\treturn;\n\n\t \n\tWARN_ON(!test_bit(NAPI_STATE_SCHED, &pool->p.napi->state) ||\n\t\tREAD_ONCE(pool->p.napi->list_owner) != -1);\n\n\tWRITE_ONCE(pool->p.napi, NULL);\n}\nEXPORT_SYMBOL(page_pool_unlink_napi);\n\nvoid page_pool_destroy(struct page_pool *pool)\n{\n\tif (!pool)\n\t\treturn;\n\n\tif (!page_pool_put(pool))\n\t\treturn;\n\n\tpage_pool_unlink_napi(pool);\n\tpage_pool_free_frag(pool);\n\n\tif (!page_pool_release(pool))\n\t\treturn;\n\n\tpool->defer_start = jiffies;\n\tpool->defer_warn  = jiffies + DEFER_WARN_INTERVAL;\n\n\tINIT_DELAYED_WORK(&pool->release_dw, page_pool_release_retry);\n\tschedule_delayed_work(&pool->release_dw, DEFER_TIME);\n}\nEXPORT_SYMBOL(page_pool_destroy);\n\n \nvoid page_pool_update_nid(struct page_pool *pool, int new_nid)\n{\n\tstruct page *page;\n\n\ttrace_page_pool_update_nid(pool, new_nid);\n\tpool->p.nid = new_nid;\n\n\t \n\twhile (pool->alloc.count) {\n\t\tpage = pool->alloc.cache[--pool->alloc.count];\n\t\tpage_pool_return_page(pool, page);\n\t}\n}\nEXPORT_SYMBOL(page_pool_update_nid);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}