{
  "module_name": "failover.c",
  "hash_id": "1ee969caee24856d52314cb1e9d5bae92dfd4fbb892fbbba3bf1bcc98c686556",
  "original_prompt": "Ingested from linux-6.6.14/net/core/failover.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <uapi/linux/if_arp.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_vlan.h>\n#include <net/failover.h>\n\nstatic LIST_HEAD(failover_list);\nstatic DEFINE_SPINLOCK(failover_lock);\n\nstatic struct net_device *failover_get_bymac(u8 *mac, struct failover_ops **ops)\n{\n\tstruct net_device *failover_dev;\n\tstruct failover *failover;\n\n\tspin_lock(&failover_lock);\n\tlist_for_each_entry(failover, &failover_list, list) {\n\t\tfailover_dev = rtnl_dereference(failover->failover_dev);\n\t\tif (ether_addr_equal(failover_dev->perm_addr, mac)) {\n\t\t\t*ops = rtnl_dereference(failover->ops);\n\t\t\tspin_unlock(&failover_lock);\n\t\t\treturn failover_dev;\n\t\t}\n\t}\n\tspin_unlock(&failover_lock);\n\treturn NULL;\n}\n\n \nstatic int failover_slave_register(struct net_device *slave_dev)\n{\n\tstruct netdev_lag_upper_info lag_upper_info;\n\tstruct net_device *failover_dev;\n\tstruct failover_ops *fops;\n\tint err;\n\n\tif (slave_dev->type != ARPHRD_ETHER)\n\t\tgoto done;\n\n\tASSERT_RTNL();\n\n\tfailover_dev = failover_get_bymac(slave_dev->perm_addr, &fops);\n\tif (!failover_dev)\n\t\tgoto done;\n\n\tif (fops && fops->slave_pre_register &&\n\t    fops->slave_pre_register(slave_dev, failover_dev))\n\t\tgoto done;\n\n\terr = netdev_rx_handler_register(slave_dev, fops->slave_handle_frame,\n\t\t\t\t\t failover_dev);\n\tif (err) {\n\t\tnetdev_err(slave_dev, \"can not register failover rx handler (err = %d)\\n\",\n\t\t\t   err);\n\t\tgoto done;\n\t}\n\n\tlag_upper_info.tx_type = NETDEV_LAG_TX_TYPE_ACTIVEBACKUP;\n\terr = netdev_master_upper_dev_link(slave_dev, failover_dev, NULL,\n\t\t\t\t\t   &lag_upper_info, NULL);\n\tif (err) {\n\t\tnetdev_err(slave_dev, \"can not set failover device %s (err = %d)\\n\",\n\t\t\t   failover_dev->name, err);\n\t\tgoto err_upper_link;\n\t}\n\n\tslave_dev->priv_flags |= (IFF_FAILOVER_SLAVE | IFF_NO_ADDRCONF);\n\n\tif (fops && fops->slave_register &&\n\t    !fops->slave_register(slave_dev, failover_dev))\n\t\treturn NOTIFY_OK;\n\n\tnetdev_upper_dev_unlink(slave_dev, failover_dev);\n\tslave_dev->priv_flags &= ~(IFF_FAILOVER_SLAVE | IFF_NO_ADDRCONF);\nerr_upper_link:\n\tnetdev_rx_handler_unregister(slave_dev);\ndone:\n\treturn NOTIFY_DONE;\n}\n\n \nint failover_slave_unregister(struct net_device *slave_dev)\n{\n\tstruct net_device *failover_dev;\n\tstruct failover_ops *fops;\n\n\tif (!netif_is_failover_slave(slave_dev))\n\t\tgoto done;\n\n\tASSERT_RTNL();\n\n\tfailover_dev = failover_get_bymac(slave_dev->perm_addr, &fops);\n\tif (!failover_dev)\n\t\tgoto done;\n\n\tif (fops && fops->slave_pre_unregister &&\n\t    fops->slave_pre_unregister(slave_dev, failover_dev))\n\t\tgoto done;\n\n\tnetdev_rx_handler_unregister(slave_dev);\n\tnetdev_upper_dev_unlink(slave_dev, failover_dev);\n\tslave_dev->priv_flags &= ~(IFF_FAILOVER_SLAVE | IFF_NO_ADDRCONF);\n\n\tif (fops && fops->slave_unregister &&\n\t    !fops->slave_unregister(slave_dev, failover_dev))\n\t\treturn NOTIFY_OK;\n\ndone:\n\treturn NOTIFY_DONE;\n}\nEXPORT_SYMBOL_GPL(failover_slave_unregister);\n\nstatic int failover_slave_link_change(struct net_device *slave_dev)\n{\n\tstruct net_device *failover_dev;\n\tstruct failover_ops *fops;\n\n\tif (!netif_is_failover_slave(slave_dev))\n\t\tgoto done;\n\n\tASSERT_RTNL();\n\n\tfailover_dev = failover_get_bymac(slave_dev->perm_addr, &fops);\n\tif (!failover_dev)\n\t\tgoto done;\n\n\tif (!netif_running(failover_dev))\n\t\tgoto done;\n\n\tif (fops && fops->slave_link_change &&\n\t    !fops->slave_link_change(slave_dev, failover_dev))\n\t\treturn NOTIFY_OK;\n\ndone:\n\treturn NOTIFY_DONE;\n}\n\nstatic int failover_slave_name_change(struct net_device *slave_dev)\n{\n\tstruct net_device *failover_dev;\n\tstruct failover_ops *fops;\n\n\tif (!netif_is_failover_slave(slave_dev))\n\t\tgoto done;\n\n\tASSERT_RTNL();\n\n\tfailover_dev = failover_get_bymac(slave_dev->perm_addr, &fops);\n\tif (!failover_dev)\n\t\tgoto done;\n\n\tif (!netif_running(failover_dev))\n\t\tgoto done;\n\n\tif (fops && fops->slave_name_change &&\n\t    !fops->slave_name_change(slave_dev, failover_dev))\n\t\treturn NOTIFY_OK;\n\ndone:\n\treturn NOTIFY_DONE;\n}\n\nstatic int\nfailover_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *event_dev = netdev_notifier_info_to_dev(ptr);\n\n\t \n\tif (netif_is_failover(event_dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\treturn failover_slave_register(event_dev);\n\tcase NETDEV_UNREGISTER:\n\t\treturn failover_slave_unregister(event_dev);\n\tcase NETDEV_UP:\n\tcase NETDEV_DOWN:\n\tcase NETDEV_CHANGE:\n\t\treturn failover_slave_link_change(event_dev);\n\tcase NETDEV_CHANGENAME:\n\t\treturn failover_slave_name_change(event_dev);\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic struct notifier_block failover_notifier = {\n\t.notifier_call = failover_event,\n};\n\nstatic void\nfailover_existing_slave_register(struct net_device *failover_dev)\n{\n\tstruct net *net = dev_net(failover_dev);\n\tstruct net_device *dev;\n\n\trtnl_lock();\n\tfor_each_netdev(net, dev) {\n\t\tif (netif_is_failover(dev))\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(failover_dev->perm_addr, dev->perm_addr))\n\t\t\tfailover_slave_register(dev);\n\t}\n\trtnl_unlock();\n}\n\n \nstruct failover *failover_register(struct net_device *dev,\n\t\t\t\t   struct failover_ops *ops)\n{\n\tstruct failover *failover;\n\n\tif (dev->type != ARPHRD_ETHER)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfailover = kzalloc(sizeof(*failover), GFP_KERNEL);\n\tif (!failover)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trcu_assign_pointer(failover->ops, ops);\n\tnetdev_hold(dev, &failover->dev_tracker, GFP_KERNEL);\n\tdev->priv_flags |= IFF_FAILOVER;\n\trcu_assign_pointer(failover->failover_dev, dev);\n\n\tspin_lock(&failover_lock);\n\tlist_add_tail(&failover->list, &failover_list);\n\tspin_unlock(&failover_lock);\n\n\tnetdev_info(dev, \"failover master:%s registered\\n\", dev->name);\n\n\tfailover_existing_slave_register(dev);\n\n\treturn failover;\n}\nEXPORT_SYMBOL_GPL(failover_register);\n\n \nvoid failover_unregister(struct failover *failover)\n{\n\tstruct net_device *failover_dev;\n\n\tfailover_dev = rcu_dereference(failover->failover_dev);\n\n\tnetdev_info(failover_dev, \"failover master:%s unregistered\\n\",\n\t\t    failover_dev->name);\n\n\tfailover_dev->priv_flags &= ~IFF_FAILOVER;\n\tnetdev_put(failover_dev, &failover->dev_tracker);\n\n\tspin_lock(&failover_lock);\n\tlist_del(&failover->list);\n\tspin_unlock(&failover_lock);\n\n\tkfree(failover);\n}\nEXPORT_SYMBOL_GPL(failover_unregister);\n\nstatic __init int\nfailover_init(void)\n{\n\tregister_netdevice_notifier(&failover_notifier);\n\n\treturn 0;\n}\nmodule_init(failover_init);\n\nstatic __exit\nvoid failover_exit(void)\n{\n\tunregister_netdevice_notifier(&failover_notifier);\n}\nmodule_exit(failover_exit);\n\nMODULE_DESCRIPTION(\"Generic failover infrastructure/interface\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}