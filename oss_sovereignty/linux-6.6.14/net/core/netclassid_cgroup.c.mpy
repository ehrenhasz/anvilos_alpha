{
  "module_name": "netclassid_cgroup.c",
  "hash_id": "008d29f57a68f9c93f745ad21348175721c95f11b4aa3b4fa299690d18e8cdfd",
  "original_prompt": "Ingested from linux-6.6.14/net/core/netclassid_cgroup.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/fdtable.h>\n#include <linux/sched/task.h>\n\n#include <net/cls_cgroup.h>\n#include <net/sock.h>\n\nstatic inline struct cgroup_cls_state *css_cls_state(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cgroup_cls_state, css) : NULL;\n}\n\nstruct cgroup_cls_state *task_cls_state(struct task_struct *p)\n{\n\treturn css_cls_state(task_css_check(p, net_cls_cgrp_id,\n\t\t\t\t\t    rcu_read_lock_bh_held()));\n}\nEXPORT_SYMBOL_GPL(task_cls_state);\n\nstatic struct cgroup_subsys_state *\ncgrp_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct cgroup_cls_state *cs;\n\n\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\tif (!cs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn &cs->css;\n}\n\nstatic int cgrp_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_cls_state *cs = css_cls_state(css);\n\tstruct cgroup_cls_state *parent = css_cls_state(css->parent);\n\n\tif (parent)\n\t\tcs->classid = parent->classid;\n\n\treturn 0;\n}\n\nstatic void cgrp_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_cls_state(css));\n}\n\n \n\nstruct update_classid_context {\n\tu32 classid;\n\tunsigned int batch;\n};\n\n#define UPDATE_CLASSID_BATCH 1000\n\nstatic int update_classid_sock(const void *v, struct file *file, unsigned int n)\n{\n\tstruct update_classid_context *ctx = (void *)v;\n\tstruct socket *sock = sock_from_file(file);\n\n\tif (sock)\n\t\tsock_cgroup_set_classid(&sock->sk->sk_cgrp_data, ctx->classid);\n\tif (--ctx->batch == 0) {\n\t\tctx->batch = UPDATE_CLASSID_BATCH;\n\t\treturn n + 1;\n\t}\n\treturn 0;\n}\n\nstatic void update_classid_task(struct task_struct *p, u32 classid)\n{\n\tstruct update_classid_context ctx = {\n\t\t.classid = classid,\n\t\t.batch = UPDATE_CLASSID_BATCH\n\t};\n\tunsigned int fd = 0;\n\n\tdo {\n\t\ttask_lock(p);\n\t\tfd = iterate_fd(p->files, fd, update_classid_sock, &ctx);\n\t\ttask_unlock(p);\n\t\tcond_resched();\n\t} while (fd);\n}\n\nstatic void cgrp_attach(struct cgroup_taskset *tset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct task_struct *p;\n\n\tcgroup_taskset_for_each(p, css, tset) {\n\t\tupdate_classid_task(p, css_cls_state(css)->classid);\n\t}\n}\n\nstatic u64 read_classid(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\treturn css_cls_state(css)->classid;\n}\n\nstatic int write_classid(struct cgroup_subsys_state *css, struct cftype *cft,\n\t\t\t u64 value)\n{\n\tstruct cgroup_cls_state *cs = css_cls_state(css);\n\tstruct css_task_iter it;\n\tstruct task_struct *p;\n\n\tcs->classid = (u32)value;\n\n\tcss_task_iter_start(css, 0, &it);\n\twhile ((p = css_task_iter_next(&it)))\n\t\tupdate_classid_task(p, cs->classid);\n\tcss_task_iter_end(&it);\n\n\treturn 0;\n}\n\nstatic struct cftype ss_files[] = {\n\t{\n\t\t.name\t\t= \"classid\",\n\t\t.read_u64\t= read_classid,\n\t\t.write_u64\t= write_classid,\n\t},\n\t{ }\t \n};\n\nstruct cgroup_subsys net_cls_cgrp_subsys = {\n\t.css_alloc\t\t= cgrp_css_alloc,\n\t.css_online\t\t= cgrp_css_online,\n\t.css_free\t\t= cgrp_css_free,\n\t.attach\t\t\t= cgrp_attach,\n\t.legacy_cftypes\t\t= ss_files,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}