{
  "module_name": "dev_addr_lists.c",
  "hash_id": "a7a9d2f8366a6c11ee5c5785d27d5a038a4feab40a891daba8b7ff00db90e747",
  "original_prompt": "Ingested from linux-6.6.14/net/core/dev_addr_lists.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/export.h>\n#include <linux/list.h>\n\n#include \"dev.h\"\n\n \n\nstatic int __hw_addr_insert(struct netdev_hw_addr_list *list,\n\t\t\t    struct netdev_hw_addr *new, int addr_len)\n{\n\tstruct rb_node **ins_point = &list->tree.rb_node, *parent = NULL;\n\tstruct netdev_hw_addr *ha;\n\n\twhile (*ins_point) {\n\t\tint diff;\n\n\t\tha = rb_entry(*ins_point, struct netdev_hw_addr, node);\n\t\tdiff = memcmp(new->addr, ha->addr, addr_len);\n\t\tif (diff == 0)\n\t\t\tdiff = memcmp(&new->type, &ha->type, sizeof(new->type));\n\n\t\tparent = *ins_point;\n\t\tif (diff < 0)\n\t\t\tins_point = &parent->rb_left;\n\t\telse if (diff > 0)\n\t\t\tins_point = &parent->rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node_rcu(&new->node, parent, ins_point);\n\trb_insert_color(&new->node, &list->tree);\n\n\treturn 0;\n}\n\nstatic struct netdev_hw_addr*\n__hw_addr_create(const unsigned char *addr, int addr_len,\n\t\t unsigned char addr_type, bool global, bool sync)\n{\n\tstruct netdev_hw_addr *ha;\n\tint alloc_size;\n\n\talloc_size = sizeof(*ha);\n\tif (alloc_size < L1_CACHE_BYTES)\n\t\talloc_size = L1_CACHE_BYTES;\n\tha = kmalloc(alloc_size, GFP_ATOMIC);\n\tif (!ha)\n\t\treturn NULL;\n\tmemcpy(ha->addr, addr, addr_len);\n\tha->type = addr_type;\n\tha->refcount = 1;\n\tha->global_use = global;\n\tha->synced = sync ? 1 : 0;\n\tha->sync_cnt = 0;\n\n\treturn ha;\n}\n\nstatic int __hw_addr_add_ex(struct netdev_hw_addr_list *list,\n\t\t\t    const unsigned char *addr, int addr_len,\n\t\t\t    unsigned char addr_type, bool global, bool sync,\n\t\t\t    int sync_count, bool exclusive)\n{\n\tstruct rb_node **ins_point = &list->tree.rb_node, *parent = NULL;\n\tstruct netdev_hw_addr *ha;\n\n\tif (addr_len > MAX_ADDR_LEN)\n\t\treturn -EINVAL;\n\n\twhile (*ins_point) {\n\t\tint diff;\n\n\t\tha = rb_entry(*ins_point, struct netdev_hw_addr, node);\n\t\tdiff = memcmp(addr, ha->addr, addr_len);\n\t\tif (diff == 0)\n\t\t\tdiff = memcmp(&addr_type, &ha->type, sizeof(addr_type));\n\n\t\tparent = *ins_point;\n\t\tif (diff < 0) {\n\t\t\tins_point = &parent->rb_left;\n\t\t} else if (diff > 0) {\n\t\t\tins_point = &parent->rb_right;\n\t\t} else {\n\t\t\tif (exclusive)\n\t\t\t\treturn -EEXIST;\n\t\t\tif (global) {\n\t\t\t\t \n\t\t\t\tif (ha->global_use)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\tha->global_use = true;\n\t\t\t}\n\t\t\tif (sync) {\n\t\t\t\tif (ha->synced && sync_count)\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\telse\n\t\t\t\t\tha->synced++;\n\t\t\t}\n\t\t\tha->refcount++;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tha = __hw_addr_create(addr, addr_len, addr_type, global, sync);\n\tif (!ha)\n\t\treturn -ENOMEM;\n\n\trb_link_node(&ha->node, parent, ins_point);\n\trb_insert_color(&ha->node, &list->tree);\n\n\tlist_add_tail_rcu(&ha->list, &list->list);\n\tlist->count++;\n\n\treturn 0;\n}\n\nstatic int __hw_addr_add(struct netdev_hw_addr_list *list,\n\t\t\t const unsigned char *addr, int addr_len,\n\t\t\t unsigned char addr_type)\n{\n\treturn __hw_addr_add_ex(list, addr, addr_len, addr_type, false, false,\n\t\t\t\t0, false);\n}\n\nstatic int __hw_addr_del_entry(struct netdev_hw_addr_list *list,\n\t\t\t       struct netdev_hw_addr *ha, bool global,\n\t\t\t       bool sync)\n{\n\tif (global && !ha->global_use)\n\t\treturn -ENOENT;\n\n\tif (sync && !ha->synced)\n\t\treturn -ENOENT;\n\n\tif (global)\n\t\tha->global_use = false;\n\n\tif (sync)\n\t\tha->synced--;\n\n\tif (--ha->refcount)\n\t\treturn 0;\n\n\trb_erase(&ha->node, &list->tree);\n\n\tlist_del_rcu(&ha->list);\n\tkfree_rcu(ha, rcu_head);\n\tlist->count--;\n\treturn 0;\n}\n\nstatic struct netdev_hw_addr *__hw_addr_lookup(struct netdev_hw_addr_list *list,\n\t\t\t\t\t       const unsigned char *addr, int addr_len,\n\t\t\t\t\t       unsigned char addr_type)\n{\n\tstruct rb_node *node;\n\n\tnode = list->tree.rb_node;\n\n\twhile (node) {\n\t\tstruct netdev_hw_addr *ha = rb_entry(node, struct netdev_hw_addr, node);\n\t\tint diff = memcmp(addr, ha->addr, addr_len);\n\n\t\tif (diff == 0 && addr_type)\n\t\t\tdiff = memcmp(&addr_type, &ha->type, sizeof(addr_type));\n\n\t\tif (diff < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (diff > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn ha;\n\t}\n\n\treturn NULL;\n}\n\nstatic int __hw_addr_del_ex(struct netdev_hw_addr_list *list,\n\t\t\t    const unsigned char *addr, int addr_len,\n\t\t\t    unsigned char addr_type, bool global, bool sync)\n{\n\tstruct netdev_hw_addr *ha = __hw_addr_lookup(list, addr, addr_len, addr_type);\n\n\tif (!ha)\n\t\treturn -ENOENT;\n\treturn __hw_addr_del_entry(list, ha, global, sync);\n}\n\nstatic int __hw_addr_del(struct netdev_hw_addr_list *list,\n\t\t\t const unsigned char *addr, int addr_len,\n\t\t\t unsigned char addr_type)\n{\n\treturn __hw_addr_del_ex(list, addr, addr_len, addr_type, false, false);\n}\n\nstatic int __hw_addr_sync_one(struct netdev_hw_addr_list *to_list,\n\t\t\t       struct netdev_hw_addr *ha,\n\t\t\t       int addr_len)\n{\n\tint err;\n\n\terr = __hw_addr_add_ex(to_list, ha->addr, addr_len, ha->type,\n\t\t\t       false, true, ha->sync_cnt, false);\n\tif (err && err != -EEXIST)\n\t\treturn err;\n\n\tif (!err) {\n\t\tha->sync_cnt++;\n\t\tha->refcount++;\n\t}\n\n\treturn 0;\n}\n\nstatic void __hw_addr_unsync_one(struct netdev_hw_addr_list *to_list,\n\t\t\t\t struct netdev_hw_addr_list *from_list,\n\t\t\t\t struct netdev_hw_addr *ha,\n\t\t\t\t int addr_len)\n{\n\tint err;\n\n\terr = __hw_addr_del_ex(to_list, ha->addr, addr_len, ha->type,\n\t\t\t       false, true);\n\tif (err)\n\t\treturn;\n\tha->sync_cnt--;\n\t \n\t__hw_addr_del_entry(from_list, ha, false, false);\n}\n\nstatic int __hw_addr_sync_multiple(struct netdev_hw_addr_list *to_list,\n\t\t\t\t   struct netdev_hw_addr_list *from_list,\n\t\t\t\t   int addr_len)\n{\n\tint err = 0;\n\tstruct netdev_hw_addr *ha, *tmp;\n\n\tlist_for_each_entry_safe(ha, tmp, &from_list->list, list) {\n\t\tif (ha->sync_cnt == ha->refcount) {\n\t\t\t__hw_addr_unsync_one(to_list, from_list, ha, addr_len);\n\t\t} else {\n\t\t\terr = __hw_addr_sync_one(to_list, ha, addr_len);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\n \nint __hw_addr_sync(struct netdev_hw_addr_list *to_list,\n\t\t   struct netdev_hw_addr_list *from_list,\n\t\t   int addr_len)\n{\n\tint err = 0;\n\tstruct netdev_hw_addr *ha, *tmp;\n\n\tlist_for_each_entry_safe(ha, tmp, &from_list->list, list) {\n\t\tif (!ha->sync_cnt) {\n\t\t\terr = __hw_addr_sync_one(to_list, ha, addr_len);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else if (ha->refcount == 1)\n\t\t\t__hw_addr_unsync_one(to_list, from_list, ha, addr_len);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(__hw_addr_sync);\n\nvoid __hw_addr_unsync(struct netdev_hw_addr_list *to_list,\n\t\t      struct netdev_hw_addr_list *from_list,\n\t\t      int addr_len)\n{\n\tstruct netdev_hw_addr *ha, *tmp;\n\n\tlist_for_each_entry_safe(ha, tmp, &from_list->list, list) {\n\t\tif (ha->sync_cnt)\n\t\t\t__hw_addr_unsync_one(to_list, from_list, ha, addr_len);\n\t}\n}\nEXPORT_SYMBOL(__hw_addr_unsync);\n\n \nint __hw_addr_sync_dev(struct netdev_hw_addr_list *list,\n\t\t       struct net_device *dev,\n\t\t       int (*sync)(struct net_device *, const unsigned char *),\n\t\t       int (*unsync)(struct net_device *,\n\t\t\t\t     const unsigned char *))\n{\n\tstruct netdev_hw_addr *ha, *tmp;\n\tint err;\n\n\t \n\tlist_for_each_entry_safe(ha, tmp, &list->list, list) {\n\t\tif (!ha->sync_cnt || ha->refcount != 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unsync && unsync(dev, ha->addr))\n\t\t\tcontinue;\n\n\t\tha->sync_cnt--;\n\t\t__hw_addr_del_entry(list, ha, false, false);\n\t}\n\n\t \n\tlist_for_each_entry_safe(ha, tmp, &list->list, list) {\n\t\tif (ha->sync_cnt)\n\t\t\tcontinue;\n\n\t\terr = sync(dev, ha->addr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tha->sync_cnt++;\n\t\tha->refcount++;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__hw_addr_sync_dev);\n\n \nint __hw_addr_ref_sync_dev(struct netdev_hw_addr_list *list,\n\t\t\t   struct net_device *dev,\n\t\t\t   int (*sync)(struct net_device *,\n\t\t\t\t       const unsigned char *, int),\n\t\t\t   int (*unsync)(struct net_device *,\n\t\t\t\t\t const unsigned char *, int))\n{\n\tstruct netdev_hw_addr *ha, *tmp;\n\tint err, ref_cnt;\n\n\t \n\tlist_for_each_entry_safe(ha, tmp, &list->list, list) {\n\t\t \n\t\tif ((ha->sync_cnt << 1) <= ha->refcount)\n\t\t\tcontinue;\n\n\t\t \n\t\tref_cnt = ha->refcount - ha->sync_cnt;\n\t\tif (unsync && unsync(dev, ha->addr, ref_cnt))\n\t\t\tcontinue;\n\n\t\tha->refcount = (ref_cnt << 1) + 1;\n\t\tha->sync_cnt = ref_cnt;\n\t\t__hw_addr_del_entry(list, ha, false, false);\n\t}\n\n\t \n\tlist_for_each_entry_safe(ha, tmp, &list->list, list) {\n\t\t \n\t\tif ((ha->sync_cnt << 1) >= ha->refcount)\n\t\t\tcontinue;\n\n\t\tref_cnt = ha->refcount - ha->sync_cnt;\n\t\terr = sync(dev, ha->addr, ref_cnt);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tha->refcount = ref_cnt << 1;\n\t\tha->sync_cnt = ref_cnt;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__hw_addr_ref_sync_dev);\n\n \nvoid __hw_addr_ref_unsync_dev(struct netdev_hw_addr_list *list,\n\t\t\t      struct net_device *dev,\n\t\t\t      int (*unsync)(struct net_device *,\n\t\t\t\t\t    const unsigned char *, int))\n{\n\tstruct netdev_hw_addr *ha, *tmp;\n\n\tlist_for_each_entry_safe(ha, tmp, &list->list, list) {\n\t\tif (!ha->sync_cnt)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unsync && unsync(dev, ha->addr, ha->sync_cnt))\n\t\t\tcontinue;\n\n\t\tha->refcount -= ha->sync_cnt - 1;\n\t\tha->sync_cnt = 0;\n\t\t__hw_addr_del_entry(list, ha, false, false);\n\t}\n}\nEXPORT_SYMBOL(__hw_addr_ref_unsync_dev);\n\n \nvoid __hw_addr_unsync_dev(struct netdev_hw_addr_list *list,\n\t\t\t  struct net_device *dev,\n\t\t\t  int (*unsync)(struct net_device *,\n\t\t\t\t\tconst unsigned char *))\n{\n\tstruct netdev_hw_addr *ha, *tmp;\n\n\tlist_for_each_entry_safe(ha, tmp, &list->list, list) {\n\t\tif (!ha->sync_cnt)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unsync && unsync(dev, ha->addr))\n\t\t\tcontinue;\n\n\t\tha->sync_cnt--;\n\t\t__hw_addr_del_entry(list, ha, false, false);\n\t}\n}\nEXPORT_SYMBOL(__hw_addr_unsync_dev);\n\nstatic void __hw_addr_flush(struct netdev_hw_addr_list *list)\n{\n\tstruct netdev_hw_addr *ha, *tmp;\n\n\tlist->tree = RB_ROOT;\n\tlist_for_each_entry_safe(ha, tmp, &list->list, list) {\n\t\tlist_del_rcu(&ha->list);\n\t\tkfree_rcu(ha, rcu_head);\n\t}\n\tlist->count = 0;\n}\n\nvoid __hw_addr_init(struct netdev_hw_addr_list *list)\n{\n\tINIT_LIST_HEAD(&list->list);\n\tlist->count = 0;\n\tlist->tree = RB_ROOT;\n}\nEXPORT_SYMBOL(__hw_addr_init);\n\n \n\n \nvoid dev_addr_check(struct net_device *dev)\n{\n\tif (!memcmp(dev->dev_addr, dev->dev_addr_shadow, MAX_ADDR_LEN))\n\t\treturn;\n\n\tnetdev_warn(dev, \"Current addr:  %*ph\\n\", MAX_ADDR_LEN, dev->dev_addr);\n\tnetdev_warn(dev, \"Expected addr: %*ph\\n\",\n\t\t    MAX_ADDR_LEN, dev->dev_addr_shadow);\n\tnetdev_WARN(dev, \"Incorrect netdev->dev_addr\\n\");\n}\n\n \nvoid dev_addr_flush(struct net_device *dev)\n{\n\t \n\tdev_addr_check(dev);\n\n\t__hw_addr_flush(&dev->dev_addrs);\n\tdev->dev_addr = NULL;\n}\n\n \nint dev_addr_init(struct net_device *dev)\n{\n\tunsigned char addr[MAX_ADDR_LEN];\n\tstruct netdev_hw_addr *ha;\n\tint err;\n\n\t \n\n\t__hw_addr_init(&dev->dev_addrs);\n\tmemset(addr, 0, sizeof(addr));\n\terr = __hw_addr_add(&dev->dev_addrs, addr, sizeof(addr),\n\t\t\t    NETDEV_HW_ADDR_T_LAN);\n\tif (!err) {\n\t\t \n\t\tha = list_first_entry(&dev->dev_addrs.list,\n\t\t\t\t      struct netdev_hw_addr, list);\n\t\tdev->dev_addr = ha->addr;\n\t}\n\treturn err;\n}\n\nvoid dev_addr_mod(struct net_device *dev, unsigned int offset,\n\t\t  const void *addr, size_t len)\n{\n\tstruct netdev_hw_addr *ha;\n\n\tdev_addr_check(dev);\n\n\tha = container_of(dev->dev_addr, struct netdev_hw_addr, addr[0]);\n\trb_erase(&ha->node, &dev->dev_addrs.tree);\n\tmemcpy(&ha->addr[offset], addr, len);\n\tmemcpy(&dev->dev_addr_shadow[offset], addr, len);\n\tWARN_ON(__hw_addr_insert(&dev->dev_addrs, ha, dev->addr_len));\n}\nEXPORT_SYMBOL(dev_addr_mod);\n\n \nint dev_addr_add(struct net_device *dev, const unsigned char *addr,\n\t\t unsigned char addr_type)\n{\n\tint err;\n\n\tASSERT_RTNL();\n\n\terr = dev_pre_changeaddr_notify(dev, addr, NULL);\n\tif (err)\n\t\treturn err;\n\terr = __hw_addr_add(&dev->dev_addrs, addr, dev->addr_len, addr_type);\n\tif (!err)\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\n\treturn err;\n}\nEXPORT_SYMBOL(dev_addr_add);\n\n \nint dev_addr_del(struct net_device *dev, const unsigned char *addr,\n\t\t unsigned char addr_type)\n{\n\tint err;\n\tstruct netdev_hw_addr *ha;\n\n\tASSERT_RTNL();\n\n\t \n\tha = list_first_entry(&dev->dev_addrs.list,\n\t\t\t      struct netdev_hw_addr, list);\n\tif (!memcmp(ha->addr, addr, dev->addr_len) &&\n\t    ha->type == addr_type && ha->refcount == 1)\n\t\treturn -ENOENT;\n\n\terr = __hw_addr_del(&dev->dev_addrs, addr, dev->addr_len,\n\t\t\t    addr_type);\n\tif (!err)\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\n\treturn err;\n}\nEXPORT_SYMBOL(dev_addr_del);\n\n \n\n \nint dev_uc_add_excl(struct net_device *dev, const unsigned char *addr)\n{\n\tint err;\n\n\tnetif_addr_lock_bh(dev);\n\terr = __hw_addr_add_ex(&dev->uc, addr, dev->addr_len,\n\t\t\t       NETDEV_HW_ADDR_T_UNICAST, true, false,\n\t\t\t       0, true);\n\tif (!err)\n\t\t__dev_set_rx_mode(dev);\n\tnetif_addr_unlock_bh(dev);\n\treturn err;\n}\nEXPORT_SYMBOL(dev_uc_add_excl);\n\n \nint dev_uc_add(struct net_device *dev, const unsigned char *addr)\n{\n\tint err;\n\n\tnetif_addr_lock_bh(dev);\n\terr = __hw_addr_add(&dev->uc, addr, dev->addr_len,\n\t\t\t    NETDEV_HW_ADDR_T_UNICAST);\n\tif (!err)\n\t\t__dev_set_rx_mode(dev);\n\tnetif_addr_unlock_bh(dev);\n\treturn err;\n}\nEXPORT_SYMBOL(dev_uc_add);\n\n \nint dev_uc_del(struct net_device *dev, const unsigned char *addr)\n{\n\tint err;\n\n\tnetif_addr_lock_bh(dev);\n\terr = __hw_addr_del(&dev->uc, addr, dev->addr_len,\n\t\t\t    NETDEV_HW_ADDR_T_UNICAST);\n\tif (!err)\n\t\t__dev_set_rx_mode(dev);\n\tnetif_addr_unlock_bh(dev);\n\treturn err;\n}\nEXPORT_SYMBOL(dev_uc_del);\n\n \nint dev_uc_sync(struct net_device *to, struct net_device *from)\n{\n\tint err = 0;\n\n\tif (to->addr_len != from->addr_len)\n\t\treturn -EINVAL;\n\n\tnetif_addr_lock(to);\n\terr = __hw_addr_sync(&to->uc, &from->uc, to->addr_len);\n\tif (!err)\n\t\t__dev_set_rx_mode(to);\n\tnetif_addr_unlock(to);\n\treturn err;\n}\nEXPORT_SYMBOL(dev_uc_sync);\n\n \nint dev_uc_sync_multiple(struct net_device *to, struct net_device *from)\n{\n\tint err = 0;\n\n\tif (to->addr_len != from->addr_len)\n\t\treturn -EINVAL;\n\n\tnetif_addr_lock(to);\n\terr = __hw_addr_sync_multiple(&to->uc, &from->uc, to->addr_len);\n\tif (!err)\n\t\t__dev_set_rx_mode(to);\n\tnetif_addr_unlock(to);\n\treturn err;\n}\nEXPORT_SYMBOL(dev_uc_sync_multiple);\n\n \nvoid dev_uc_unsync(struct net_device *to, struct net_device *from)\n{\n\tif (to->addr_len != from->addr_len)\n\t\treturn;\n\n\t \n\tnetif_addr_lock_bh(from);\n\tnetif_addr_lock(to);\n\t__hw_addr_unsync(&to->uc, &from->uc, to->addr_len);\n\t__dev_set_rx_mode(to);\n\tnetif_addr_unlock(to);\n\tnetif_addr_unlock_bh(from);\n}\nEXPORT_SYMBOL(dev_uc_unsync);\n\n \nvoid dev_uc_flush(struct net_device *dev)\n{\n\tnetif_addr_lock_bh(dev);\n\t__hw_addr_flush(&dev->uc);\n\tnetif_addr_unlock_bh(dev);\n}\nEXPORT_SYMBOL(dev_uc_flush);\n\n \nvoid dev_uc_init(struct net_device *dev)\n{\n\t__hw_addr_init(&dev->uc);\n}\nEXPORT_SYMBOL(dev_uc_init);\n\n \n\n \nint dev_mc_add_excl(struct net_device *dev, const unsigned char *addr)\n{\n\tint err;\n\n\tnetif_addr_lock_bh(dev);\n\terr = __hw_addr_add_ex(&dev->mc, addr, dev->addr_len,\n\t\t\t       NETDEV_HW_ADDR_T_MULTICAST, true, false,\n\t\t\t       0, true);\n\tif (!err)\n\t\t__dev_set_rx_mode(dev);\n\tnetif_addr_unlock_bh(dev);\n\treturn err;\n}\nEXPORT_SYMBOL(dev_mc_add_excl);\n\nstatic int __dev_mc_add(struct net_device *dev, const unsigned char *addr,\n\t\t\tbool global)\n{\n\tint err;\n\n\tnetif_addr_lock_bh(dev);\n\terr = __hw_addr_add_ex(&dev->mc, addr, dev->addr_len,\n\t\t\t       NETDEV_HW_ADDR_T_MULTICAST, global, false,\n\t\t\t       0, false);\n\tif (!err)\n\t\t__dev_set_rx_mode(dev);\n\tnetif_addr_unlock_bh(dev);\n\treturn err;\n}\n \nint dev_mc_add(struct net_device *dev, const unsigned char *addr)\n{\n\treturn __dev_mc_add(dev, addr, false);\n}\nEXPORT_SYMBOL(dev_mc_add);\n\n \nint dev_mc_add_global(struct net_device *dev, const unsigned char *addr)\n{\n\treturn __dev_mc_add(dev, addr, true);\n}\nEXPORT_SYMBOL(dev_mc_add_global);\n\nstatic int __dev_mc_del(struct net_device *dev, const unsigned char *addr,\n\t\t\tbool global)\n{\n\tint err;\n\n\tnetif_addr_lock_bh(dev);\n\terr = __hw_addr_del_ex(&dev->mc, addr, dev->addr_len,\n\t\t\t       NETDEV_HW_ADDR_T_MULTICAST, global, false);\n\tif (!err)\n\t\t__dev_set_rx_mode(dev);\n\tnetif_addr_unlock_bh(dev);\n\treturn err;\n}\n\n \nint dev_mc_del(struct net_device *dev, const unsigned char *addr)\n{\n\treturn __dev_mc_del(dev, addr, false);\n}\nEXPORT_SYMBOL(dev_mc_del);\n\n \nint dev_mc_del_global(struct net_device *dev, const unsigned char *addr)\n{\n\treturn __dev_mc_del(dev, addr, true);\n}\nEXPORT_SYMBOL(dev_mc_del_global);\n\n \nint dev_mc_sync(struct net_device *to, struct net_device *from)\n{\n\tint err = 0;\n\n\tif (to->addr_len != from->addr_len)\n\t\treturn -EINVAL;\n\n\tnetif_addr_lock(to);\n\terr = __hw_addr_sync(&to->mc, &from->mc, to->addr_len);\n\tif (!err)\n\t\t__dev_set_rx_mode(to);\n\tnetif_addr_unlock(to);\n\treturn err;\n}\nEXPORT_SYMBOL(dev_mc_sync);\n\n \nint dev_mc_sync_multiple(struct net_device *to, struct net_device *from)\n{\n\tint err = 0;\n\n\tif (to->addr_len != from->addr_len)\n\t\treturn -EINVAL;\n\n\tnetif_addr_lock(to);\n\terr = __hw_addr_sync_multiple(&to->mc, &from->mc, to->addr_len);\n\tif (!err)\n\t\t__dev_set_rx_mode(to);\n\tnetif_addr_unlock(to);\n\treturn err;\n}\nEXPORT_SYMBOL(dev_mc_sync_multiple);\n\n \nvoid dev_mc_unsync(struct net_device *to, struct net_device *from)\n{\n\tif (to->addr_len != from->addr_len)\n\t\treturn;\n\n\t \n\tnetif_addr_lock_bh(from);\n\tnetif_addr_lock(to);\n\t__hw_addr_unsync(&to->mc, &from->mc, to->addr_len);\n\t__dev_set_rx_mode(to);\n\tnetif_addr_unlock(to);\n\tnetif_addr_unlock_bh(from);\n}\nEXPORT_SYMBOL(dev_mc_unsync);\n\n \nvoid dev_mc_flush(struct net_device *dev)\n{\n\tnetif_addr_lock_bh(dev);\n\t__hw_addr_flush(&dev->mc);\n\tnetif_addr_unlock_bh(dev);\n}\nEXPORT_SYMBOL(dev_mc_flush);\n\n \nvoid dev_mc_init(struct net_device *dev)\n{\n\t__hw_addr_init(&dev->mc);\n}\nEXPORT_SYMBOL(dev_mc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}