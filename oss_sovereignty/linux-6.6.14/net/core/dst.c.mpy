{
  "module_name": "dst.c",
  "hash_id": "79a4f08e3b396df0e229427b01c15c6e548864bbf92d121a7c3de86bff837e45",
  "original_prompt": "Ingested from linux-6.6.14/net/core/dst.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <net/net_namespace.h>\n#include <linux/sched.h>\n#include <linux/prefetch.h>\n#include <net/lwtunnel.h>\n#include <net/xfrm.h>\n\n#include <net/dst.h>\n#include <net/dst_metadata.h>\n\nint dst_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n\treturn 0;\n}\nEXPORT_SYMBOL(dst_discard_out);\n\nconst struct dst_metrics dst_default_metrics = {\n\t \n\t.refcnt = REFCOUNT_INIT(1),\n};\nEXPORT_SYMBOL(dst_default_metrics);\n\nvoid dst_init(struct dst_entry *dst, struct dst_ops *ops,\n\t      struct net_device *dev, int initial_ref, int initial_obsolete,\n\t      unsigned short flags)\n{\n\tdst->dev = dev;\n\tnetdev_hold(dev, &dst->dev_tracker, GFP_ATOMIC);\n\tdst->ops = ops;\n\tdst_init_metrics(dst, dst_default_metrics.metrics, true);\n\tdst->expires = 0UL;\n#ifdef CONFIG_XFRM\n\tdst->xfrm = NULL;\n#endif\n\tdst->input = dst_discard;\n\tdst->output = dst_discard_out;\n\tdst->error = 0;\n\tdst->obsolete = initial_obsolete;\n\tdst->header_len = 0;\n\tdst->trailer_len = 0;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tdst->tclassid = 0;\n#endif\n\tdst->lwtstate = NULL;\n\trcuref_init(&dst->__rcuref, initial_ref);\n\tINIT_LIST_HEAD(&dst->rt_uncached);\n\tdst->__use = 0;\n\tdst->lastuse = jiffies;\n\tdst->flags = flags;\n\tif (!(flags & DST_NOCOUNT))\n\t\tdst_entries_add(ops, 1);\n}\nEXPORT_SYMBOL(dst_init);\n\nvoid *dst_alloc(struct dst_ops *ops, struct net_device *dev,\n\t\tint initial_ref, int initial_obsolete, unsigned short flags)\n{\n\tstruct dst_entry *dst;\n\n\tif (ops->gc &&\n\t    !(flags & DST_NOCOUNT) &&\n\t    dst_entries_get_fast(ops) > ops->gc_thresh)\n\t\tops->gc(ops);\n\n\tdst = kmem_cache_alloc(ops->kmem_cachep, GFP_ATOMIC);\n\tif (!dst)\n\t\treturn NULL;\n\n\tdst_init(dst, ops, dev, initial_ref, initial_obsolete, flags);\n\n\treturn dst;\n}\nEXPORT_SYMBOL(dst_alloc);\n\nstruct dst_entry *dst_destroy(struct dst_entry * dst)\n{\n\tstruct dst_entry *child = NULL;\n\n\tsmp_rmb();\n\n#ifdef CONFIG_XFRM\n\tif (dst->xfrm) {\n\t\tstruct xfrm_dst *xdst = (struct xfrm_dst *) dst;\n\n\t\tchild = xdst->child;\n\t}\n#endif\n\tif (!(dst->flags & DST_NOCOUNT))\n\t\tdst_entries_add(dst->ops, -1);\n\n\tif (dst->ops->destroy)\n\t\tdst->ops->destroy(dst);\n\tnetdev_put(dst->dev, &dst->dev_tracker);\n\n\tlwtstate_put(dst->lwtstate);\n\n\tif (dst->flags & DST_METADATA)\n\t\tmetadata_dst_free((struct metadata_dst *)dst);\n\telse\n\t\tkmem_cache_free(dst->ops->kmem_cachep, dst);\n\n\tdst = child;\n\tif (dst)\n\t\tdst_release_immediate(dst);\n\treturn NULL;\n}\nEXPORT_SYMBOL(dst_destroy);\n\nstatic void dst_destroy_rcu(struct rcu_head *head)\n{\n\tstruct dst_entry *dst = container_of(head, struct dst_entry, rcu_head);\n\n\tdst = dst_destroy(dst);\n}\n\n \nvoid dst_dev_put(struct dst_entry *dst)\n{\n\tstruct net_device *dev = dst->dev;\n\n\tdst->obsolete = DST_OBSOLETE_DEAD;\n\tif (dst->ops->ifdown)\n\t\tdst->ops->ifdown(dst, dev);\n\tdst->input = dst_discard;\n\tdst->output = dst_discard_out;\n\tdst->dev = blackhole_netdev;\n\tnetdev_ref_replace(dev, blackhole_netdev, &dst->dev_tracker,\n\t\t\t   GFP_ATOMIC);\n}\nEXPORT_SYMBOL(dst_dev_put);\n\nvoid dst_release(struct dst_entry *dst)\n{\n\tif (dst && rcuref_put(&dst->__rcuref))\n\t\tcall_rcu_hurry(&dst->rcu_head, dst_destroy_rcu);\n}\nEXPORT_SYMBOL(dst_release);\n\nvoid dst_release_immediate(struct dst_entry *dst)\n{\n\tif (dst && rcuref_put(&dst->__rcuref))\n\t\tdst_destroy(dst);\n}\nEXPORT_SYMBOL(dst_release_immediate);\n\nu32 *dst_cow_metrics_generic(struct dst_entry *dst, unsigned long old)\n{\n\tstruct dst_metrics *p = kmalloc(sizeof(*p), GFP_ATOMIC);\n\n\tif (p) {\n\t\tstruct dst_metrics *old_p = (struct dst_metrics *)__DST_METRICS_PTR(old);\n\t\tunsigned long prev, new;\n\n\t\trefcount_set(&p->refcnt, 1);\n\t\tmemcpy(p->metrics, old_p->metrics, sizeof(p->metrics));\n\n\t\tnew = (unsigned long) p;\n\t\tprev = cmpxchg(&dst->_metrics, old, new);\n\n\t\tif (prev != old) {\n\t\t\tkfree(p);\n\t\t\tp = (struct dst_metrics *)__DST_METRICS_PTR(prev);\n\t\t\tif (prev & DST_METRICS_READ_ONLY)\n\t\t\t\tp = NULL;\n\t\t} else if (prev & DST_METRICS_REFCOUNTED) {\n\t\t\tif (refcount_dec_and_test(&old_p->refcnt))\n\t\t\t\tkfree(old_p);\n\t\t}\n\t}\n\tBUILD_BUG_ON(offsetof(struct dst_metrics, metrics) != 0);\n\treturn (u32 *)p;\n}\nEXPORT_SYMBOL(dst_cow_metrics_generic);\n\n \nvoid __dst_destroy_metrics_generic(struct dst_entry *dst, unsigned long old)\n{\n\tunsigned long prev, new;\n\n\tnew = ((unsigned long) &dst_default_metrics) | DST_METRICS_READ_ONLY;\n\tprev = cmpxchg(&dst->_metrics, old, new);\n\tif (prev == old)\n\t\tkfree(__DST_METRICS_PTR(old));\n}\nEXPORT_SYMBOL(__dst_destroy_metrics_generic);\n\nstruct dst_entry *dst_blackhole_check(struct dst_entry *dst, u32 cookie)\n{\n\treturn NULL;\n}\n\nu32 *dst_blackhole_cow_metrics(struct dst_entry *dst, unsigned long old)\n{\n\treturn NULL;\n}\n\nstruct neighbour *dst_blackhole_neigh_lookup(const struct dst_entry *dst,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     const void *daddr)\n{\n\treturn NULL;\n}\n\nvoid dst_blackhole_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t       struct sk_buff *skb, u32 mtu,\n\t\t\t       bool confirm_neigh)\n{\n}\nEXPORT_SYMBOL_GPL(dst_blackhole_update_pmtu);\n\nvoid dst_blackhole_redirect(struct dst_entry *dst, struct sock *sk,\n\t\t\t    struct sk_buff *skb)\n{\n}\nEXPORT_SYMBOL_GPL(dst_blackhole_redirect);\n\nunsigned int dst_blackhole_mtu(const struct dst_entry *dst)\n{\n\tunsigned int mtu = dst_metric_raw(dst, RTAX_MTU);\n\n\treturn mtu ? : dst->dev->mtu;\n}\nEXPORT_SYMBOL_GPL(dst_blackhole_mtu);\n\nstatic struct dst_ops dst_blackhole_ops = {\n\t.family\t\t= AF_UNSPEC,\n\t.neigh_lookup\t= dst_blackhole_neigh_lookup,\n\t.check\t\t= dst_blackhole_check,\n\t.cow_metrics\t= dst_blackhole_cow_metrics,\n\t.update_pmtu\t= dst_blackhole_update_pmtu,\n\t.redirect\t= dst_blackhole_redirect,\n\t.mtu\t\t= dst_blackhole_mtu,\n};\n\nstatic void __metadata_dst_init(struct metadata_dst *md_dst,\n\t\t\t\tenum metadata_type type, u8 optslen)\n{\n\tstruct dst_entry *dst;\n\n\tdst = &md_dst->dst;\n\tdst_init(dst, &dst_blackhole_ops, NULL, 1, DST_OBSOLETE_NONE,\n\t\t DST_METADATA | DST_NOCOUNT);\n\tmemset(dst + 1, 0, sizeof(*md_dst) + optslen - sizeof(*dst));\n\tmd_dst->type = type;\n}\n\nstruct metadata_dst *metadata_dst_alloc(u8 optslen, enum metadata_type type,\n\t\t\t\t\tgfp_t flags)\n{\n\tstruct metadata_dst *md_dst;\n\n\tmd_dst = kmalloc(sizeof(*md_dst) + optslen, flags);\n\tif (!md_dst)\n\t\treturn NULL;\n\n\t__metadata_dst_init(md_dst, type, optslen);\n\n\treturn md_dst;\n}\nEXPORT_SYMBOL_GPL(metadata_dst_alloc);\n\nvoid metadata_dst_free(struct metadata_dst *md_dst)\n{\n#ifdef CONFIG_DST_CACHE\n\tif (md_dst->type == METADATA_IP_TUNNEL)\n\t\tdst_cache_destroy(&md_dst->u.tun_info.dst_cache);\n#endif\n\tif (md_dst->type == METADATA_XFRM)\n\t\tdst_release(md_dst->u.xfrm_info.dst_orig);\n\tkfree(md_dst);\n}\nEXPORT_SYMBOL_GPL(metadata_dst_free);\n\nstruct metadata_dst __percpu *\nmetadata_dst_alloc_percpu(u8 optslen, enum metadata_type type, gfp_t flags)\n{\n\tint cpu;\n\tstruct metadata_dst __percpu *md_dst;\n\n\tmd_dst = __alloc_percpu_gfp(sizeof(struct metadata_dst) + optslen,\n\t\t\t\t    __alignof__(struct metadata_dst), flags);\n\tif (!md_dst)\n\t\treturn NULL;\n\n\tfor_each_possible_cpu(cpu)\n\t\t__metadata_dst_init(per_cpu_ptr(md_dst, cpu), type, optslen);\n\n\treturn md_dst;\n}\nEXPORT_SYMBOL_GPL(metadata_dst_alloc_percpu);\n\nvoid metadata_dst_free_percpu(struct metadata_dst __percpu *md_dst)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct metadata_dst *one_md_dst = per_cpu_ptr(md_dst, cpu);\n\n#ifdef CONFIG_DST_CACHE\n\t\tif (one_md_dst->type == METADATA_IP_TUNNEL)\n\t\t\tdst_cache_destroy(&one_md_dst->u.tun_info.dst_cache);\n#endif\n\t\tif (one_md_dst->type == METADATA_XFRM)\n\t\t\tdst_release(one_md_dst->u.xfrm_info.dst_orig);\n\t}\n\tfree_percpu(md_dst);\n}\nEXPORT_SYMBOL_GPL(metadata_dst_free_percpu);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}