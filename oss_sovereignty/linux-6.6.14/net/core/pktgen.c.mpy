{
  "module_name": "pktgen.c",
  "hash_id": "e685f763714bdda785217550b7540c47ec7332a6429190527abf02fbf4ce6b10",
  "original_prompt": "Ingested from linux-6.6.14/net/core/pktgen.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/sys.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/unistd.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/capability.h>\n#include <linux/hrtimer.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_arp.h>\n#include <linux/if_vlan.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/udp.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/wait.h>\n#include <linux/etherdevice.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/mmzone.h>\n#include <net/net_namespace.h>\n#include <net/checksum.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n#include <net/ip6_checksum.h>\n#include <net/addrconf.h>\n#ifdef CONFIG_XFRM\n#include <net/xfrm.h>\n#endif\n#include <net/netns/generic.h>\n#include <asm/byteorder.h>\n#include <linux/rcupdate.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/timex.h>\n#include <linux/uaccess.h>\n#include <asm/dma.h>\n#include <asm/div64.h>\t\t \n\n#define VERSION\t\"2.75\"\n#define IP_NAME_SZ 32\n#define MAX_MPLS_LABELS 16  \n#define MPLS_STACK_BOTTOM htonl(0x00000100)\n \n#define MAX_IMIX_ENTRIES 20\n#define IMIX_PRECISION 100  \n\n#define func_enter() pr_debug(\"entering %s\\n\", __func__);\n\n#define PKT_FLAGS\t\t\t\t\t\t\t\\\n\tpf(IPV6)\t\t \t\t\\\n\tpf(IPSRC_RND)\t\t \t\t\t\\\n\tpf(IPDST_RND)\t\t \t\t\t\\\n\tpf(TXSIZE_RND)\t\t \t\t\\\n\tpf(UDPSRC_RND)\t\t \t\t\t\\\n\tpf(UDPDST_RND)\t\t \t\t\t\\\n\tpf(UDPCSUM)\t\t \t\t\\\n\tpf(NO_TIMESTAMP)\t  \\\n\tpf(MPLS_RND)\t\t \t\t\\\n\tpf(QUEUE_MAP_RND)\t \t\t\t\\\n\tpf(QUEUE_MAP_CPU)\t  \\\n\tpf(FLOW_SEQ)\t\t \t\t\t\\\n\tpf(IPSEC)\t\t \t\t\\\n\tpf(MACSRC_RND)\t\t \t\t\t\\\n\tpf(MACDST_RND)\t\t \t\t\t\\\n\tpf(VID_RND)\t\t \t\t\t\\\n\tpf(SVID_RND)\t\t \t\t\t\\\n\tpf(NODE)\t\t \t\t\t\\\n\n#define pf(flag)\t\tflag##_SHIFT,\nenum pkt_flags {\n\tPKT_FLAGS\n};\n#undef pf\n\n \n#define pf(flag)\t\tstatic const __u32 F_##flag = (1<<flag##_SHIFT);\nPKT_FLAGS\n#undef pf\n\n#define pf(flag)\t\t__stringify(flag),\nstatic char *pkt_flag_names[] = {\n\tPKT_FLAGS\n};\n#undef pf\n\n#define NR_PKT_FLAGS\t\tARRAY_SIZE(pkt_flag_names)\n\n \n#define T_STOP        (1<<0)\t \n#define T_RUN         (1<<1)\t \n#define T_REMDEVALL   (1<<2)\t \n#define T_REMDEV      (1<<3)\t \n\n \n#define M_START_XMIT\t\t0\t \n#define M_NETIF_RECEIVE \t1\t \n#define M_QUEUE_XMIT\t\t2\t \n\n \n#define   if_lock(t)           mutex_lock(&(t->if_lock));\n#define   if_unlock(t)           mutex_unlock(&(t->if_lock));\n\n \n#define PKTGEN_MAGIC 0xbe9be955\n#define PG_PROC_DIR \"pktgen\"\n#define PGCTRL\t    \"pgctrl\"\n\n#define MAX_CFLOWS  65536\n\n#define VLAN_TAG_SIZE(x) ((x)->vlan_id == 0xffff ? 0 : 4)\n#define SVLAN_TAG_SIZE(x) ((x)->svlan_id == 0xffff ? 0 : 4)\n\nstruct imix_pkt {\n\tu64 size;\n\tu64 weight;\n\tu64 count_so_far;\n};\n\nstruct flow_state {\n\t__be32 cur_daddr;\n\tint count;\n#ifdef CONFIG_XFRM\n\tstruct xfrm_state *x;\n#endif\n\t__u32 flags;\n};\n\n \n#define F_INIT   (1<<0)\t\t \n\nstruct pktgen_dev {\n\t \n\tstruct proc_dir_entry *entry;\t \n\tstruct pktgen_thread *pg_thread; \n\tstruct list_head list;\t\t \n\tstruct rcu_head\t rcu;\t\t \n\n\tint running;\t\t \n\n\t \n\t__u32 flags;\n\tint xmit_mode;\n\tint min_pkt_size;\n\tint max_pkt_size;\n\tint pkt_overhead;\t \n\tint nfrags;\n\tint removal_mark;\t \n\n\tstruct page *page;\n\tu64 delay;\t\t \n\n\t__u64 count;\t\t \n\t__u64 sofar;\t\t \n\t__u64 tx_bytes;\t\t \n\t__u64 errors;\t\t \n\n\t \n\n\t__u32 clone_count;\n\tint last_ok;\t\t \n\tktime_t next_tx;\n\tktime_t started_at;\n\tktime_t stopped_at;\n\tu64\tidle_acc;\t \n\n\t__u32 seq_num;\n\n\tint clone_skb;\t\t \n\n\tchar dst_min[IP_NAME_SZ];\t \n\tchar dst_max[IP_NAME_SZ];\t \n\tchar src_min[IP_NAME_SZ];\t \n\tchar src_max[IP_NAME_SZ];\t \n\n\tstruct in6_addr in6_saddr;\n\tstruct in6_addr in6_daddr;\n\tstruct in6_addr cur_in6_daddr;\n\tstruct in6_addr cur_in6_saddr;\n\t \n\tstruct in6_addr min_in6_daddr;\n\tstruct in6_addr max_in6_daddr;\n\tstruct in6_addr min_in6_saddr;\n\tstruct in6_addr max_in6_saddr;\n\n\t \n\t__be32 saddr_min;\t \n\t__be32 saddr_max;\t \n\t__be32 daddr_min;\t \n\t__be32 daddr_max;\t \n\n\t__u16 udp_src_min;\t \n\t__u16 udp_src_max;\t \n\t__u16 udp_dst_min;\t \n\t__u16 udp_dst_max;\t \n\n\t \n\t__u8 tos;             \n\t__u8 traffic_class;   \n\n\t \n\tunsigned int n_imix_entries;\n\tstruct imix_pkt imix_entries[MAX_IMIX_ENTRIES];\n\t \n\t__u8 imix_distribution[IMIX_PRECISION];\n\n\t \n\tunsigned int nr_labels;\t \n\t__be32 labels[MAX_MPLS_LABELS];\n\n\t \n\t__u8  vlan_p;\n\t__u8  vlan_cfi;\n\t__u16 vlan_id;   \n\n\t__u8  svlan_p;\n\t__u8  svlan_cfi;\n\t__u16 svlan_id;  \n\n\t__u32 src_mac_count;\t \n\t__u32 dst_mac_count;\t \n\n\tunsigned char dst_mac[ETH_ALEN];\n\tunsigned char src_mac[ETH_ALEN];\n\n\t__u32 cur_dst_mac_offset;\n\t__u32 cur_src_mac_offset;\n\t__be32 cur_saddr;\n\t__be32 cur_daddr;\n\t__u16 ip_id;\n\t__u16 cur_udp_dst;\n\t__u16 cur_udp_src;\n\t__u16 cur_queue_map;\n\t__u32 cur_pkt_size;\n\t__u32 last_pkt_size;\n\n\t__u8 hh[14];\n\t \n\t__u16 pad;\t\t \n\n\tstruct sk_buff *skb;\t \n\tstruct net_device *odev;  \n\tnetdevice_tracker dev_tracker;\n\tchar odevname[32];\n\tstruct flow_state *flows;\n\tunsigned int cflows;\t \n\tunsigned int lflow;\t\t \n\tunsigned int nflows;\t \n\tunsigned int curfl;\t\t \n\n\tu16 queue_map_min;\n\tu16 queue_map_max;\n\t__u32 skb_priority;\t \n\tunsigned int burst;\t \n\tint node;                \n\n#ifdef CONFIG_XFRM\n\t__u8\tipsmode;\t\t \n\t__u8\tipsproto;\t\t \n\t__u32\tspi;\n\tstruct xfrm_dst xdst;\n\tstruct dst_ops dstops;\n#endif\n\tchar result[512];\n};\n\nstruct pktgen_hdr {\n\t__be32 pgh_magic;\n\t__be32 seq_num;\n\t__be32 tv_sec;\n\t__be32 tv_usec;\n};\n\n\nstatic unsigned int pg_net_id __read_mostly;\n\nstruct pktgen_net {\n\tstruct net\t\t*net;\n\tstruct proc_dir_entry\t*proc_dir;\n\tstruct list_head\tpktgen_threads;\n\tbool\t\t\tpktgen_exiting;\n};\n\nstruct pktgen_thread {\n\tstruct mutex if_lock;\t\t \n\tstruct list_head if_list;\t \n\tstruct list_head th_list;\n\tstruct task_struct *tsk;\n\tchar result[512];\n\n\t \n\n\tu32 control;\n\tint cpu;\n\n\twait_queue_head_t queue;\n\tstruct completion start_done;\n\tstruct pktgen_net *net;\n};\n\n#define REMOVE 1\n#define FIND   0\n\nstatic const char version[] =\n\t\"Packet Generator for packet performance testing. \"\n\t\"Version: \" VERSION \"\\n\";\n\nstatic int pktgen_remove_device(struct pktgen_thread *t, struct pktgen_dev *i);\nstatic int pktgen_add_device(struct pktgen_thread *t, const char *ifname);\nstatic struct pktgen_dev *pktgen_find_dev(struct pktgen_thread *t,\n\t\t\t\t\t  const char *ifname, bool exact);\nstatic int pktgen_device_event(struct notifier_block *, unsigned long, void *);\nstatic void pktgen_run_all_threads(struct pktgen_net *pn);\nstatic void pktgen_reset_all_threads(struct pktgen_net *pn);\nstatic void pktgen_stop_all_threads(struct pktgen_net *pn);\n\nstatic void pktgen_stop(struct pktgen_thread *t);\nstatic void pktgen_clear_counters(struct pktgen_dev *pkt_dev);\nstatic void fill_imix_distribution(struct pktgen_dev *pkt_dev);\n\n \nstatic int pg_count_d __read_mostly = 1000;\nstatic int pg_delay_d __read_mostly;\nstatic int pg_clone_skb_d  __read_mostly;\nstatic int debug  __read_mostly;\n\nstatic DEFINE_MUTEX(pktgen_thread_lock);\n\nstatic struct notifier_block pktgen_notifier_block = {\n\t.notifier_call = pktgen_device_event,\n};\n\n \n\nstatic int pgctrl_show(struct seq_file *seq, void *v)\n{\n\tseq_puts(seq, version);\n\treturn 0;\n}\n\nstatic ssize_t pgctrl_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar data[128];\n\tstruct pktgen_net *pn = net_generic(current->nsproxy->net_ns, pg_net_id);\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count == 0)\n\t\treturn -EINVAL;\n\n\tif (count > sizeof(data))\n\t\tcount = sizeof(data);\n\n\tif (copy_from_user(data, buf, count))\n\t\treturn -EFAULT;\n\n\tdata[count - 1] = 0;\t \n\n\tif (!strcmp(data, \"stop\"))\n\t\tpktgen_stop_all_threads(pn);\n\telse if (!strcmp(data, \"start\"))\n\t\tpktgen_run_all_threads(pn);\n\telse if (!strcmp(data, \"reset\"))\n\t\tpktgen_reset_all_threads(pn);\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic int pgctrl_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, pgctrl_show, pde_data(inode));\n}\n\nstatic const struct proc_ops pktgen_proc_ops = {\n\t.proc_open\t= pgctrl_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= pgctrl_write,\n\t.proc_release\t= single_release,\n};\n\nstatic int pktgen_if_show(struct seq_file *seq, void *v)\n{\n\tconst struct pktgen_dev *pkt_dev = seq->private;\n\tktime_t stopped;\n\tunsigned int i;\n\tu64 idle;\n\n\tseq_printf(seq,\n\t\t   \"Params: count %llu  min_pkt_size: %u  max_pkt_size: %u\\n\",\n\t\t   (unsigned long long)pkt_dev->count, pkt_dev->min_pkt_size,\n\t\t   pkt_dev->max_pkt_size);\n\n\tif (pkt_dev->n_imix_entries > 0) {\n\t\tseq_puts(seq, \"     imix_weights: \");\n\t\tfor (i = 0; i < pkt_dev->n_imix_entries; i++) {\n\t\t\tseq_printf(seq, \"%llu,%llu \",\n\t\t\t\t   pkt_dev->imix_entries[i].size,\n\t\t\t\t   pkt_dev->imix_entries[i].weight);\n\t\t}\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\n\tseq_printf(seq,\n\t\t   \"     frags: %d  delay: %llu  clone_skb: %d  ifname: %s\\n\",\n\t\t   pkt_dev->nfrags, (unsigned long long) pkt_dev->delay,\n\t\t   pkt_dev->clone_skb, pkt_dev->odevname);\n\n\tseq_printf(seq, \"     flows: %u flowlen: %u\\n\", pkt_dev->cflows,\n\t\t   pkt_dev->lflow);\n\n\tseq_printf(seq,\n\t\t   \"     queue_map_min: %u  queue_map_max: %u\\n\",\n\t\t   pkt_dev->queue_map_min,\n\t\t   pkt_dev->queue_map_max);\n\n\tif (pkt_dev->skb_priority)\n\t\tseq_printf(seq, \"     skb_priority: %u\\n\",\n\t\t\t   pkt_dev->skb_priority);\n\n\tif (pkt_dev->flags & F_IPV6) {\n\t\tseq_printf(seq,\n\t\t\t   \"     saddr: %pI6c  min_saddr: %pI6c  max_saddr: %pI6c\\n\"\n\t\t\t   \"     daddr: %pI6c  min_daddr: %pI6c  max_daddr: %pI6c\\n\",\n\t\t\t   &pkt_dev->in6_saddr,\n\t\t\t   &pkt_dev->min_in6_saddr, &pkt_dev->max_in6_saddr,\n\t\t\t   &pkt_dev->in6_daddr,\n\t\t\t   &pkt_dev->min_in6_daddr, &pkt_dev->max_in6_daddr);\n\t} else {\n\t\tseq_printf(seq,\n\t\t\t   \"     dst_min: %s  dst_max: %s\\n\",\n\t\t\t   pkt_dev->dst_min, pkt_dev->dst_max);\n\t\tseq_printf(seq,\n\t\t\t   \"     src_min: %s  src_max: %s\\n\",\n\t\t\t   pkt_dev->src_min, pkt_dev->src_max);\n\t}\n\n\tseq_puts(seq, \"     src_mac: \");\n\n\tseq_printf(seq, \"%pM \",\n\t\t   is_zero_ether_addr(pkt_dev->src_mac) ?\n\t\t\t     pkt_dev->odev->dev_addr : pkt_dev->src_mac);\n\n\tseq_puts(seq, \"dst_mac: \");\n\tseq_printf(seq, \"%pM\\n\", pkt_dev->dst_mac);\n\n\tseq_printf(seq,\n\t\t   \"     udp_src_min: %d  udp_src_max: %d\"\n\t\t   \"  udp_dst_min: %d  udp_dst_max: %d\\n\",\n\t\t   pkt_dev->udp_src_min, pkt_dev->udp_src_max,\n\t\t   pkt_dev->udp_dst_min, pkt_dev->udp_dst_max);\n\n\tseq_printf(seq,\n\t\t   \"     src_mac_count: %d  dst_mac_count: %d\\n\",\n\t\t   pkt_dev->src_mac_count, pkt_dev->dst_mac_count);\n\n\tif (pkt_dev->nr_labels) {\n\t\tseq_puts(seq, \"     mpls: \");\n\t\tfor (i = 0; i < pkt_dev->nr_labels; i++)\n\t\t\tseq_printf(seq, \"%08x%s\", ntohl(pkt_dev->labels[i]),\n\t\t\t\t   i == pkt_dev->nr_labels-1 ? \"\\n\" : \", \");\n\t}\n\n\tif (pkt_dev->vlan_id != 0xffff)\n\t\tseq_printf(seq, \"     vlan_id: %u  vlan_p: %u  vlan_cfi: %u\\n\",\n\t\t\t   pkt_dev->vlan_id, pkt_dev->vlan_p,\n\t\t\t   pkt_dev->vlan_cfi);\n\n\tif (pkt_dev->svlan_id != 0xffff)\n\t\tseq_printf(seq, \"     svlan_id: %u  vlan_p: %u  vlan_cfi: %u\\n\",\n\t\t\t   pkt_dev->svlan_id, pkt_dev->svlan_p,\n\t\t\t   pkt_dev->svlan_cfi);\n\n\tif (pkt_dev->tos)\n\t\tseq_printf(seq, \"     tos: 0x%02x\\n\", pkt_dev->tos);\n\n\tif (pkt_dev->traffic_class)\n\t\tseq_printf(seq, \"     traffic_class: 0x%02x\\n\", pkt_dev->traffic_class);\n\n\tif (pkt_dev->burst > 1)\n\t\tseq_printf(seq, \"     burst: %d\\n\", pkt_dev->burst);\n\n\tif (pkt_dev->node >= 0)\n\t\tseq_printf(seq, \"     node: %d\\n\", pkt_dev->node);\n\n\tif (pkt_dev->xmit_mode == M_NETIF_RECEIVE)\n\t\tseq_puts(seq, \"     xmit_mode: netif_receive\\n\");\n\telse if (pkt_dev->xmit_mode == M_QUEUE_XMIT)\n\t\tseq_puts(seq, \"     xmit_mode: xmit_queue\\n\");\n\n\tseq_puts(seq, \"     Flags: \");\n\n\tfor (i = 0; i < NR_PKT_FLAGS; i++) {\n\t\tif (i == FLOW_SEQ_SHIFT)\n\t\t\tif (!pkt_dev->cflows)\n\t\t\t\tcontinue;\n\n\t\tif (pkt_dev->flags & (1 << i)) {\n\t\t\tseq_printf(seq, \"%s  \", pkt_flag_names[i]);\n#ifdef CONFIG_XFRM\n\t\t\tif (i == IPSEC_SHIFT && pkt_dev->spi)\n\t\t\t\tseq_printf(seq, \"spi:%u  \", pkt_dev->spi);\n#endif\n\t\t} else if (i == FLOW_SEQ_SHIFT) {\n\t\t\tseq_puts(seq, \"FLOW_RND  \");\n\t\t}\n\t}\n\n\tseq_puts(seq, \"\\n\");\n\n\t \n\tstopped = pkt_dev->running ? ktime_get() : pkt_dev->stopped_at;\n\tidle = pkt_dev->idle_acc;\n\tdo_div(idle, NSEC_PER_USEC);\n\n\tseq_printf(seq,\n\t\t   \"Current:\\n     pkts-sofar: %llu  errors: %llu\\n\",\n\t\t   (unsigned long long)pkt_dev->sofar,\n\t\t   (unsigned long long)pkt_dev->errors);\n\n\tif (pkt_dev->n_imix_entries > 0) {\n\t\tint i;\n\n\t\tseq_puts(seq, \"     imix_size_counts: \");\n\t\tfor (i = 0; i < pkt_dev->n_imix_entries; i++) {\n\t\t\tseq_printf(seq, \"%llu,%llu \",\n\t\t\t\t   pkt_dev->imix_entries[i].size,\n\t\t\t\t   pkt_dev->imix_entries[i].count_so_far);\n\t\t}\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\n\tseq_printf(seq,\n\t\t   \"     started: %lluus  stopped: %lluus idle: %lluus\\n\",\n\t\t   (unsigned long long) ktime_to_us(pkt_dev->started_at),\n\t\t   (unsigned long long) ktime_to_us(stopped),\n\t\t   (unsigned long long) idle);\n\n\tseq_printf(seq,\n\t\t   \"     seq_num: %d  cur_dst_mac_offset: %d  cur_src_mac_offset: %d\\n\",\n\t\t   pkt_dev->seq_num, pkt_dev->cur_dst_mac_offset,\n\t\t   pkt_dev->cur_src_mac_offset);\n\n\tif (pkt_dev->flags & F_IPV6) {\n\t\tseq_printf(seq, \"     cur_saddr: %pI6c  cur_daddr: %pI6c\\n\",\n\t\t\t\t&pkt_dev->cur_in6_saddr,\n\t\t\t\t&pkt_dev->cur_in6_daddr);\n\t} else\n\t\tseq_printf(seq, \"     cur_saddr: %pI4  cur_daddr: %pI4\\n\",\n\t\t\t   &pkt_dev->cur_saddr, &pkt_dev->cur_daddr);\n\n\tseq_printf(seq, \"     cur_udp_dst: %d  cur_udp_src: %d\\n\",\n\t\t   pkt_dev->cur_udp_dst, pkt_dev->cur_udp_src);\n\n\tseq_printf(seq, \"     cur_queue_map: %u\\n\", pkt_dev->cur_queue_map);\n\n\tseq_printf(seq, \"     flows: %u\\n\", pkt_dev->nflows);\n\n\tif (pkt_dev->result[0])\n\t\tseq_printf(seq, \"Result: %s\\n\", pkt_dev->result);\n\telse\n\t\tseq_puts(seq, \"Result: Idle\\n\");\n\n\treturn 0;\n}\n\n\nstatic int hex32_arg(const char __user *user_buffer, unsigned long maxlen,\n\t\t     __u32 *num)\n{\n\tint i = 0;\n\t*num = 0;\n\n\tfor (; i < maxlen; i++) {\n\t\tint value;\n\t\tchar c;\n\t\t*num <<= 4;\n\t\tif (get_user(c, &user_buffer[i]))\n\t\t\treturn -EFAULT;\n\t\tvalue = hex_to_bin(c);\n\t\tif (value >= 0)\n\t\t\t*num |= value;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nstatic int count_trail_chars(const char __user * user_buffer,\n\t\t\t     unsigned int maxlen)\n{\n\tint i;\n\n\tfor (i = 0; i < maxlen; i++) {\n\t\tchar c;\n\t\tif (get_user(c, &user_buffer[i]))\n\t\t\treturn -EFAULT;\n\t\tswitch (c) {\n\t\tcase '\\\"':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\tcase '\\t':\n\t\tcase ' ':\n\t\tcase '=':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\treturn i;\n}\n\nstatic long num_arg(const char __user *user_buffer, unsigned long maxlen,\n\t\t\t\tunsigned long *num)\n{\n\tint i;\n\t*num = 0;\n\n\tfor (i = 0; i < maxlen; i++) {\n\t\tchar c;\n\t\tif (get_user(c, &user_buffer[i]))\n\t\t\treturn -EFAULT;\n\t\tif ((c >= '0') && (c <= '9')) {\n\t\t\t*num *= 10;\n\t\t\t*num += c - '0';\n\t\t} else\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nstatic int strn_len(const char __user * user_buffer, unsigned int maxlen)\n{\n\tint i;\n\n\tfor (i = 0; i < maxlen; i++) {\n\t\tchar c;\n\t\tif (get_user(c, &user_buffer[i]))\n\t\t\treturn -EFAULT;\n\t\tswitch (c) {\n\t\tcase '\\\"':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\tcase '\\t':\n\t\tcase ' ':\n\t\t\tgoto done_str;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\ndone_str:\n\treturn i;\n}\n\n \nstatic ssize_t get_imix_entries(const char __user *buffer,\n\t\t\t\tstruct pktgen_dev *pkt_dev)\n{\n\tconst int max_digits = 10;\n\tint i = 0;\n\tlong len;\n\tchar c;\n\n\tpkt_dev->n_imix_entries = 0;\n\n\tdo {\n\t\tunsigned long weight;\n\t\tunsigned long size;\n\n\t\tlen = num_arg(&buffer[i], max_digits, &size);\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\ti += len;\n\t\tif (get_user(c, &buffer[i]))\n\t\t\treturn -EFAULT;\n\t\t \n\t\tif (c != ',')\n\t\t\treturn -EINVAL;\n\t\ti++;\n\n\t\tif (size < 14 + 20 + 8)\n\t\t\tsize = 14 + 20 + 8;\n\n\t\tlen = num_arg(&buffer[i], max_digits, &weight);\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\tif (weight <= 0)\n\t\t\treturn -EINVAL;\n\n\t\tpkt_dev->imix_entries[pkt_dev->n_imix_entries].size = size;\n\t\tpkt_dev->imix_entries[pkt_dev->n_imix_entries].weight = weight;\n\n\t\ti += len;\n\t\tif (get_user(c, &buffer[i]))\n\t\t\treturn -EFAULT;\n\n\t\ti++;\n\t\tpkt_dev->n_imix_entries++;\n\n\t\tif (pkt_dev->n_imix_entries > MAX_IMIX_ENTRIES)\n\t\t\treturn -E2BIG;\n\t} while (c == ' ');\n\n\treturn i;\n}\n\nstatic ssize_t get_labels(const char __user *buffer, struct pktgen_dev *pkt_dev)\n{\n\tunsigned int n = 0;\n\tchar c;\n\tssize_t i = 0;\n\tint len;\n\n\tpkt_dev->nr_labels = 0;\n\tdo {\n\t\t__u32 tmp;\n\t\tlen = hex32_arg(&buffer[i], 8, &tmp);\n\t\tif (len <= 0)\n\t\t\treturn len;\n\t\tpkt_dev->labels[n] = htonl(tmp);\n\t\tif (pkt_dev->labels[n] & MPLS_STACK_BOTTOM)\n\t\t\tpkt_dev->flags |= F_MPLS_RND;\n\t\ti += len;\n\t\tif (get_user(c, &buffer[i]))\n\t\t\treturn -EFAULT;\n\t\ti++;\n\t\tn++;\n\t\tif (n >= MAX_MPLS_LABELS)\n\t\t\treturn -E2BIG;\n\t} while (c == ',');\n\n\tpkt_dev->nr_labels = n;\n\treturn i;\n}\n\nstatic __u32 pktgen_read_flag(const char *f, bool *disable)\n{\n\t__u32 i;\n\n\tif (f[0] == '!') {\n\t\t*disable = true;\n\t\tf++;\n\t}\n\n\tfor (i = 0; i < NR_PKT_FLAGS; i++) {\n\t\tif (!IS_ENABLED(CONFIG_XFRM) && i == IPSEC_SHIFT)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!*disable && i == IPV6_SHIFT)\n\t\t\tcontinue;\n\n\t\tif (strcmp(f, pkt_flag_names[i]) == 0)\n\t\t\treturn 1 << i;\n\t}\n\n\tif (strcmp(f, \"FLOW_RND\") == 0) {\n\t\t*disable = !*disable;\n\t\treturn F_FLOW_SEQ;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t pktgen_if_write(struct file *file,\n\t\t\t       const char __user * user_buffer, size_t count,\n\t\t\t       loff_t * offset)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct pktgen_dev *pkt_dev = seq->private;\n\tint i, max, len;\n\tchar name[16], valstr[32];\n\tunsigned long value = 0;\n\tchar *pg_result = NULL;\n\tint tmp = 0;\n\tchar buf[128];\n\n\tpg_result = &(pkt_dev->result[0]);\n\n\tif (count < 1) {\n\t\tpr_warn(\"wrong command format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmax = count;\n\ttmp = count_trail_chars(user_buffer, max);\n\tif (tmp < 0) {\n\t\tpr_warn(\"illegal format\\n\");\n\t\treturn tmp;\n\t}\n\ti = tmp;\n\n\t \n\n\tlen = strn_len(&user_buffer[i], sizeof(name) - 1);\n\tif (len < 0)\n\t\treturn len;\n\n\tmemset(name, 0, sizeof(name));\n\tif (copy_from_user(name, &user_buffer[i], len))\n\t\treturn -EFAULT;\n\ti += len;\n\n\tmax = count - i;\n\tlen = count_trail_chars(&user_buffer[i], max);\n\tif (len < 0)\n\t\treturn len;\n\n\ti += len;\n\n\tif (debug) {\n\t\tsize_t copy = min_t(size_t, count + 1, 1024);\n\t\tchar *tp = strndup_user(user_buffer, copy);\n\n\t\tif (IS_ERR(tp))\n\t\t\treturn PTR_ERR(tp);\n\n\t\tpr_debug(\"%s,%zu  buffer -:%s:-\\n\", name, count, tp);\n\t\tkfree(tp);\n\t}\n\n\tif (!strcmp(name, \"min_pkt_size\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (value < 14 + 20 + 8)\n\t\t\tvalue = 14 + 20 + 8;\n\t\tif (value != pkt_dev->min_pkt_size) {\n\t\t\tpkt_dev->min_pkt_size = value;\n\t\t\tpkt_dev->cur_pkt_size = value;\n\t\t}\n\t\tsprintf(pg_result, \"OK: min_pkt_size=%d\",\n\t\t\tpkt_dev->min_pkt_size);\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"max_pkt_size\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (value < 14 + 20 + 8)\n\t\t\tvalue = 14 + 20 + 8;\n\t\tif (value != pkt_dev->max_pkt_size) {\n\t\t\tpkt_dev->max_pkt_size = value;\n\t\t\tpkt_dev->cur_pkt_size = value;\n\t\t}\n\t\tsprintf(pg_result, \"OK: max_pkt_size=%d\",\n\t\t\tpkt_dev->max_pkt_size);\n\t\treturn count;\n\t}\n\n\t \n\n\tif (!strcmp(name, \"pkt_size\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (value < 14 + 20 + 8)\n\t\t\tvalue = 14 + 20 + 8;\n\t\tif (value != pkt_dev->min_pkt_size) {\n\t\t\tpkt_dev->min_pkt_size = value;\n\t\t\tpkt_dev->max_pkt_size = value;\n\t\t\tpkt_dev->cur_pkt_size = value;\n\t\t}\n\t\tsprintf(pg_result, \"OK: pkt_size=%d\", pkt_dev->min_pkt_size);\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"imix_weights\")) {\n\t\tif (pkt_dev->clone_skb > 0)\n\t\t\treturn -EINVAL;\n\n\t\tlen = get_imix_entries(&user_buffer[i], pkt_dev);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tfill_imix_distribution(pkt_dev);\n\n\t\ti += len;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"debug\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tdebug = value;\n\t\tsprintf(pg_result, \"OK: debug=%u\", debug);\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"frags\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tpkt_dev->nfrags = value;\n\t\tsprintf(pg_result, \"OK: frags=%d\", pkt_dev->nfrags);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"delay\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (value == 0x7FFFFFFF)\n\t\t\tpkt_dev->delay = ULLONG_MAX;\n\t\telse\n\t\t\tpkt_dev->delay = (u64)value;\n\n\t\tsprintf(pg_result, \"OK: delay=%llu\",\n\t\t\t(unsigned long long) pkt_dev->delay);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"rate\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (!value)\n\t\t\treturn len;\n\t\tpkt_dev->delay = pkt_dev->min_pkt_size*8*NSEC_PER_USEC/value;\n\t\tif (debug)\n\t\t\tpr_info(\"Delay set at: %llu ns\\n\", pkt_dev->delay);\n\n\t\tsprintf(pg_result, \"OK: rate=%lu\", value);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"ratep\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (!value)\n\t\t\treturn len;\n\t\tpkt_dev->delay = NSEC_PER_SEC/value;\n\t\tif (debug)\n\t\t\tpr_info(\"Delay set at: %llu ns\\n\", pkt_dev->delay);\n\n\t\tsprintf(pg_result, \"OK: rate=%lu\", value);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"udp_src_min\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (value != pkt_dev->udp_src_min) {\n\t\t\tpkt_dev->udp_src_min = value;\n\t\t\tpkt_dev->cur_udp_src = value;\n\t\t}\n\t\tsprintf(pg_result, \"OK: udp_src_min=%u\", pkt_dev->udp_src_min);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"udp_dst_min\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (value != pkt_dev->udp_dst_min) {\n\t\t\tpkt_dev->udp_dst_min = value;\n\t\t\tpkt_dev->cur_udp_dst = value;\n\t\t}\n\t\tsprintf(pg_result, \"OK: udp_dst_min=%u\", pkt_dev->udp_dst_min);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"udp_src_max\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (value != pkt_dev->udp_src_max) {\n\t\t\tpkt_dev->udp_src_max = value;\n\t\t\tpkt_dev->cur_udp_src = value;\n\t\t}\n\t\tsprintf(pg_result, \"OK: udp_src_max=%u\", pkt_dev->udp_src_max);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"udp_dst_max\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (value != pkt_dev->udp_dst_max) {\n\t\t\tpkt_dev->udp_dst_max = value;\n\t\t\tpkt_dev->cur_udp_dst = value;\n\t\t}\n\t\tsprintf(pg_result, \"OK: udp_dst_max=%u\", pkt_dev->udp_dst_max);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"clone_skb\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\t \n\t\tif ((value > 0) &&\n\t\t    ((pkt_dev->xmit_mode == M_NETIF_RECEIVE) ||\n\t\t     !(pkt_dev->odev->priv_flags & IFF_TX_SKB_SHARING)))\n\t\t\treturn -ENOTSUPP;\n\t\tif (value > 0 && pkt_dev->n_imix_entries > 0)\n\t\t\treturn -EINVAL;\n\n\t\ti += len;\n\t\tpkt_dev->clone_skb = value;\n\n\t\tsprintf(pg_result, \"OK: clone_skb=%d\", pkt_dev->clone_skb);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"count\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tpkt_dev->count = value;\n\t\tsprintf(pg_result, \"OK: count=%llu\",\n\t\t\t(unsigned long long)pkt_dev->count);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"src_mac_count\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (pkt_dev->src_mac_count != value) {\n\t\t\tpkt_dev->src_mac_count = value;\n\t\t\tpkt_dev->cur_src_mac_offset = 0;\n\t\t}\n\t\tsprintf(pg_result, \"OK: src_mac_count=%d\",\n\t\t\tpkt_dev->src_mac_count);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"dst_mac_count\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (pkt_dev->dst_mac_count != value) {\n\t\t\tpkt_dev->dst_mac_count = value;\n\t\t\tpkt_dev->cur_dst_mac_offset = 0;\n\t\t}\n\t\tsprintf(pg_result, \"OK: dst_mac_count=%d\",\n\t\t\tpkt_dev->dst_mac_count);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"burst\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif ((value > 1) &&\n\t\t    ((pkt_dev->xmit_mode == M_QUEUE_XMIT) ||\n\t\t     ((pkt_dev->xmit_mode == M_START_XMIT) &&\n\t\t     (!(pkt_dev->odev->priv_flags & IFF_TX_SKB_SHARING)))))\n\t\t\treturn -ENOTSUPP;\n\t\tpkt_dev->burst = value < 1 ? 1 : value;\n\t\tsprintf(pg_result, \"OK: burst=%u\", pkt_dev->burst);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"node\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\n\t\tif (node_possible(value)) {\n\t\t\tpkt_dev->node = value;\n\t\t\tsprintf(pg_result, \"OK: node=%d\", pkt_dev->node);\n\t\t\tif (pkt_dev->page) {\n\t\t\t\tput_page(pkt_dev->page);\n\t\t\t\tpkt_dev->page = NULL;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tsprintf(pg_result, \"ERROR: node not possible\");\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"xmit_mode\")) {\n\t\tchar f[32];\n\n\t\tmemset(f, 0, 32);\n\t\tlen = strn_len(&user_buffer[i], sizeof(f) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tif (copy_from_user(f, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\ti += len;\n\n\t\tif (strcmp(f, \"start_xmit\") == 0) {\n\t\t\tpkt_dev->xmit_mode = M_START_XMIT;\n\t\t} else if (strcmp(f, \"netif_receive\") == 0) {\n\t\t\t \n\t\t\tif (pkt_dev->clone_skb > 0)\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\tpkt_dev->xmit_mode = M_NETIF_RECEIVE;\n\n\t\t\t \n\t\t\tpkt_dev->last_ok = 1;\n\t\t} else if (strcmp(f, \"queue_xmit\") == 0) {\n\t\t\tpkt_dev->xmit_mode = M_QUEUE_XMIT;\n\t\t\tpkt_dev->last_ok = 1;\n\t\t} else {\n\t\t\tsprintf(pg_result,\n\t\t\t\t\"xmit_mode -:%s:- unknown\\nAvailable modes: %s\",\n\t\t\t\tf, \"start_xmit, netif_receive\\n\");\n\t\t\treturn count;\n\t\t}\n\t\tsprintf(pg_result, \"OK: xmit_mode=%s\", f);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"flag\")) {\n\t\t__u32 flag;\n\t\tchar f[32];\n\t\tbool disable = false;\n\n\t\tmemset(f, 0, 32);\n\t\tlen = strn_len(&user_buffer[i], sizeof(f) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tif (copy_from_user(f, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\ti += len;\n\n\t\tflag = pktgen_read_flag(f, &disable);\n\n\t\tif (flag) {\n\t\t\tif (disable)\n\t\t\t\tpkt_dev->flags &= ~flag;\n\t\t\telse\n\t\t\t\tpkt_dev->flags |= flag;\n\t\t} else {\n\t\t\tsprintf(pg_result,\n\t\t\t\t\"Flag -:%s:- unknown\\nAvailable flags, (prepend ! to un-set flag):\\n%s\",\n\t\t\t\tf,\n\t\t\t\t\"IPSRC_RND, IPDST_RND, UDPSRC_RND, UDPDST_RND, \"\n\t\t\t\t\"MACSRC_RND, MACDST_RND, TXSIZE_RND, IPV6, \"\n\t\t\t\t\"MPLS_RND, VID_RND, SVID_RND, FLOW_SEQ, \"\n\t\t\t\t\"QUEUE_MAP_RND, QUEUE_MAP_CPU, UDPCSUM, \"\n\t\t\t\t\"NO_TIMESTAMP, \"\n#ifdef CONFIG_XFRM\n\t\t\t\t\"IPSEC, \"\n#endif\n\t\t\t\t\"NODE_ALLOC\\n\");\n\t\t\treturn count;\n\t\t}\n\t\tsprintf(pg_result, \"OK: flags=0x%x\", pkt_dev->flags);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"dst_min\") || !strcmp(name, \"dst\")) {\n\t\tlen = strn_len(&user_buffer[i], sizeof(pkt_dev->dst_min) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tif (copy_from_user(buf, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\tbuf[len] = 0;\n\t\tif (strcmp(buf, pkt_dev->dst_min) != 0) {\n\t\t\tmemset(pkt_dev->dst_min, 0, sizeof(pkt_dev->dst_min));\n\t\t\tstrcpy(pkt_dev->dst_min, buf);\n\t\t\tpkt_dev->daddr_min = in_aton(pkt_dev->dst_min);\n\t\t\tpkt_dev->cur_daddr = pkt_dev->daddr_min;\n\t\t}\n\t\tif (debug)\n\t\t\tpr_debug(\"dst_min set to: %s\\n\", pkt_dev->dst_min);\n\t\ti += len;\n\t\tsprintf(pg_result, \"OK: dst_min=%s\", pkt_dev->dst_min);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"dst_max\")) {\n\t\tlen = strn_len(&user_buffer[i], sizeof(pkt_dev->dst_max) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tif (copy_from_user(buf, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\tbuf[len] = 0;\n\t\tif (strcmp(buf, pkt_dev->dst_max) != 0) {\n\t\t\tmemset(pkt_dev->dst_max, 0, sizeof(pkt_dev->dst_max));\n\t\t\tstrcpy(pkt_dev->dst_max, buf);\n\t\t\tpkt_dev->daddr_max = in_aton(pkt_dev->dst_max);\n\t\t\tpkt_dev->cur_daddr = pkt_dev->daddr_max;\n\t\t}\n\t\tif (debug)\n\t\t\tpr_debug(\"dst_max set to: %s\\n\", pkt_dev->dst_max);\n\t\ti += len;\n\t\tsprintf(pg_result, \"OK: dst_max=%s\", pkt_dev->dst_max);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"dst6\")) {\n\t\tlen = strn_len(&user_buffer[i], sizeof(buf) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tpkt_dev->flags |= F_IPV6;\n\n\t\tif (copy_from_user(buf, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\tbuf[len] = 0;\n\n\t\tin6_pton(buf, -1, pkt_dev->in6_daddr.s6_addr, -1, NULL);\n\t\tsnprintf(buf, sizeof(buf), \"%pI6c\", &pkt_dev->in6_daddr);\n\n\t\tpkt_dev->cur_in6_daddr = pkt_dev->in6_daddr;\n\n\t\tif (debug)\n\t\t\tpr_debug(\"dst6 set to: %s\\n\", buf);\n\n\t\ti += len;\n\t\tsprintf(pg_result, \"OK: dst6=%s\", buf);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"dst6_min\")) {\n\t\tlen = strn_len(&user_buffer[i], sizeof(buf) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tpkt_dev->flags |= F_IPV6;\n\n\t\tif (copy_from_user(buf, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\tbuf[len] = 0;\n\n\t\tin6_pton(buf, -1, pkt_dev->min_in6_daddr.s6_addr, -1, NULL);\n\t\tsnprintf(buf, sizeof(buf), \"%pI6c\", &pkt_dev->min_in6_daddr);\n\n\t\tpkt_dev->cur_in6_daddr = pkt_dev->min_in6_daddr;\n\t\tif (debug)\n\t\t\tpr_debug(\"dst6_min set to: %s\\n\", buf);\n\n\t\ti += len;\n\t\tsprintf(pg_result, \"OK: dst6_min=%s\", buf);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"dst6_max\")) {\n\t\tlen = strn_len(&user_buffer[i], sizeof(buf) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tpkt_dev->flags |= F_IPV6;\n\n\t\tif (copy_from_user(buf, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\tbuf[len] = 0;\n\n\t\tin6_pton(buf, -1, pkt_dev->max_in6_daddr.s6_addr, -1, NULL);\n\t\tsnprintf(buf, sizeof(buf), \"%pI6c\", &pkt_dev->max_in6_daddr);\n\n\t\tif (debug)\n\t\t\tpr_debug(\"dst6_max set to: %s\\n\", buf);\n\n\t\ti += len;\n\t\tsprintf(pg_result, \"OK: dst6_max=%s\", buf);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"src6\")) {\n\t\tlen = strn_len(&user_buffer[i], sizeof(buf) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tpkt_dev->flags |= F_IPV6;\n\n\t\tif (copy_from_user(buf, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\tbuf[len] = 0;\n\n\t\tin6_pton(buf, -1, pkt_dev->in6_saddr.s6_addr, -1, NULL);\n\t\tsnprintf(buf, sizeof(buf), \"%pI6c\", &pkt_dev->in6_saddr);\n\n\t\tpkt_dev->cur_in6_saddr = pkt_dev->in6_saddr;\n\n\t\tif (debug)\n\t\t\tpr_debug(\"src6 set to: %s\\n\", buf);\n\n\t\ti += len;\n\t\tsprintf(pg_result, \"OK: src6=%s\", buf);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"src_min\")) {\n\t\tlen = strn_len(&user_buffer[i], sizeof(pkt_dev->src_min) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tif (copy_from_user(buf, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\tbuf[len] = 0;\n\t\tif (strcmp(buf, pkt_dev->src_min) != 0) {\n\t\t\tmemset(pkt_dev->src_min, 0, sizeof(pkt_dev->src_min));\n\t\t\tstrcpy(pkt_dev->src_min, buf);\n\t\t\tpkt_dev->saddr_min = in_aton(pkt_dev->src_min);\n\t\t\tpkt_dev->cur_saddr = pkt_dev->saddr_min;\n\t\t}\n\t\tif (debug)\n\t\t\tpr_debug(\"src_min set to: %s\\n\", pkt_dev->src_min);\n\t\ti += len;\n\t\tsprintf(pg_result, \"OK: src_min=%s\", pkt_dev->src_min);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"src_max\")) {\n\t\tlen = strn_len(&user_buffer[i], sizeof(pkt_dev->src_max) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tif (copy_from_user(buf, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\tbuf[len] = 0;\n\t\tif (strcmp(buf, pkt_dev->src_max) != 0) {\n\t\t\tmemset(pkt_dev->src_max, 0, sizeof(pkt_dev->src_max));\n\t\t\tstrcpy(pkt_dev->src_max, buf);\n\t\t\tpkt_dev->saddr_max = in_aton(pkt_dev->src_max);\n\t\t\tpkt_dev->cur_saddr = pkt_dev->saddr_max;\n\t\t}\n\t\tif (debug)\n\t\t\tpr_debug(\"src_max set to: %s\\n\", pkt_dev->src_max);\n\t\ti += len;\n\t\tsprintf(pg_result, \"OK: src_max=%s\", pkt_dev->src_max);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"dst_mac\")) {\n\t\tlen = strn_len(&user_buffer[i], sizeof(valstr) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tmemset(valstr, 0, sizeof(valstr));\n\t\tif (copy_from_user(valstr, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\n\t\tif (!mac_pton(valstr, pkt_dev->dst_mac))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tether_addr_copy(&pkt_dev->hh[0], pkt_dev->dst_mac);\n\n\t\tsprintf(pg_result, \"OK: dstmac %pM\", pkt_dev->dst_mac);\n\t\treturn count;\n\t}\n\tif (!strcmp(name, \"src_mac\")) {\n\t\tlen = strn_len(&user_buffer[i], sizeof(valstr) - 1);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tmemset(valstr, 0, sizeof(valstr));\n\t\tif (copy_from_user(valstr, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\n\t\tif (!mac_pton(valstr, pkt_dev->src_mac))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tether_addr_copy(&pkt_dev->hh[6], pkt_dev->src_mac);\n\n\t\tsprintf(pg_result, \"OK: srcmac %pM\", pkt_dev->src_mac);\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"clear_counters\")) {\n\t\tpktgen_clear_counters(pkt_dev);\n\t\tsprintf(pg_result, \"OK: Clearing counters.\\n\");\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"flows\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (value > MAX_CFLOWS)\n\t\t\tvalue = MAX_CFLOWS;\n\n\t\tpkt_dev->cflows = value;\n\t\tsprintf(pg_result, \"OK: flows=%u\", pkt_dev->cflows);\n\t\treturn count;\n\t}\n#ifdef CONFIG_XFRM\n\tif (!strcmp(name, \"spi\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tpkt_dev->spi = value;\n\t\tsprintf(pg_result, \"OK: spi=%u\", pkt_dev->spi);\n\t\treturn count;\n\t}\n#endif\n\tif (!strcmp(name, \"flowlen\")) {\n\t\tlen = num_arg(&user_buffer[i], 10, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tpkt_dev->lflow = value;\n\t\tsprintf(pg_result, \"OK: flowlen=%u\", pkt_dev->lflow);\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"queue_map_min\")) {\n\t\tlen = num_arg(&user_buffer[i], 5, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tpkt_dev->queue_map_min = value;\n\t\tsprintf(pg_result, \"OK: queue_map_min=%u\", pkt_dev->queue_map_min);\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"queue_map_max\")) {\n\t\tlen = num_arg(&user_buffer[i], 5, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tpkt_dev->queue_map_max = value;\n\t\tsprintf(pg_result, \"OK: queue_map_max=%u\", pkt_dev->queue_map_max);\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"mpls\")) {\n\t\tunsigned int n, cnt;\n\n\t\tlen = get_labels(&user_buffer[i], pkt_dev);\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\ti += len;\n\t\tcnt = sprintf(pg_result, \"OK: mpls=\");\n\t\tfor (n = 0; n < pkt_dev->nr_labels; n++)\n\t\t\tcnt += sprintf(pg_result + cnt,\n\t\t\t\t       \"%08x%s\", ntohl(pkt_dev->labels[n]),\n\t\t\t\t       n == pkt_dev->nr_labels-1 ? \"\" : \",\");\n\n\t\tif (pkt_dev->nr_labels && pkt_dev->vlan_id != 0xffff) {\n\t\t\tpkt_dev->vlan_id = 0xffff;  \n\t\t\tpkt_dev->svlan_id = 0xffff;\n\n\t\t\tif (debug)\n\t\t\t\tpr_debug(\"VLAN/SVLAN auto turned off\\n\");\n\t\t}\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"vlan_id\")) {\n\t\tlen = num_arg(&user_buffer[i], 4, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (value <= 4095) {\n\t\t\tpkt_dev->vlan_id = value;   \n\n\t\t\tif (debug)\n\t\t\t\tpr_debug(\"VLAN turned on\\n\");\n\n\t\t\tif (debug && pkt_dev->nr_labels)\n\t\t\t\tpr_debug(\"MPLS auto turned off\\n\");\n\n\t\t\tpkt_dev->nr_labels = 0;     \n\t\t\tsprintf(pg_result, \"OK: vlan_id=%u\", pkt_dev->vlan_id);\n\t\t} else {\n\t\t\tpkt_dev->vlan_id = 0xffff;  \n\t\t\tpkt_dev->svlan_id = 0xffff;\n\n\t\t\tif (debug)\n\t\t\t\tpr_debug(\"VLAN/SVLAN turned off\\n\");\n\t\t}\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"vlan_p\")) {\n\t\tlen = num_arg(&user_buffer[i], 1, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif ((value <= 7) && (pkt_dev->vlan_id != 0xffff)) {\n\t\t\tpkt_dev->vlan_p = value;\n\t\t\tsprintf(pg_result, \"OK: vlan_p=%u\", pkt_dev->vlan_p);\n\t\t} else {\n\t\t\tsprintf(pg_result, \"ERROR: vlan_p must be 0-7\");\n\t\t}\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"vlan_cfi\")) {\n\t\tlen = num_arg(&user_buffer[i], 1, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif ((value <= 1) && (pkt_dev->vlan_id != 0xffff)) {\n\t\t\tpkt_dev->vlan_cfi = value;\n\t\t\tsprintf(pg_result, \"OK: vlan_cfi=%u\", pkt_dev->vlan_cfi);\n\t\t} else {\n\t\t\tsprintf(pg_result, \"ERROR: vlan_cfi must be 0-1\");\n\t\t}\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"svlan_id\")) {\n\t\tlen = num_arg(&user_buffer[i], 4, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif ((value <= 4095) && ((pkt_dev->vlan_id != 0xffff))) {\n\t\t\tpkt_dev->svlan_id = value;   \n\n\t\t\tif (debug)\n\t\t\t\tpr_debug(\"SVLAN turned on\\n\");\n\n\t\t\tif (debug && pkt_dev->nr_labels)\n\t\t\t\tpr_debug(\"MPLS auto turned off\\n\");\n\n\t\t\tpkt_dev->nr_labels = 0;     \n\t\t\tsprintf(pg_result, \"OK: svlan_id=%u\", pkt_dev->svlan_id);\n\t\t} else {\n\t\t\tpkt_dev->vlan_id = 0xffff;  \n\t\t\tpkt_dev->svlan_id = 0xffff;\n\n\t\t\tif (debug)\n\t\t\t\tpr_debug(\"VLAN/SVLAN turned off\\n\");\n\t\t}\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"svlan_p\")) {\n\t\tlen = num_arg(&user_buffer[i], 1, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif ((value <= 7) && (pkt_dev->svlan_id != 0xffff)) {\n\t\t\tpkt_dev->svlan_p = value;\n\t\t\tsprintf(pg_result, \"OK: svlan_p=%u\", pkt_dev->svlan_p);\n\t\t} else {\n\t\t\tsprintf(pg_result, \"ERROR: svlan_p must be 0-7\");\n\t\t}\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"svlan_cfi\")) {\n\t\tlen = num_arg(&user_buffer[i], 1, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif ((value <= 1) && (pkt_dev->svlan_id != 0xffff)) {\n\t\t\tpkt_dev->svlan_cfi = value;\n\t\t\tsprintf(pg_result, \"OK: svlan_cfi=%u\", pkt_dev->svlan_cfi);\n\t\t} else {\n\t\t\tsprintf(pg_result, \"ERROR: svlan_cfi must be 0-1\");\n\t\t}\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"tos\")) {\n\t\t__u32 tmp_value = 0;\n\t\tlen = hex32_arg(&user_buffer[i], 2, &tmp_value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (len == 2) {\n\t\t\tpkt_dev->tos = tmp_value;\n\t\t\tsprintf(pg_result, \"OK: tos=0x%02x\", pkt_dev->tos);\n\t\t} else {\n\t\t\tsprintf(pg_result, \"ERROR: tos must be 00-ff\");\n\t\t}\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"traffic_class\")) {\n\t\t__u32 tmp_value = 0;\n\t\tlen = hex32_arg(&user_buffer[i], 2, &tmp_value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tif (len == 2) {\n\t\t\tpkt_dev->traffic_class = tmp_value;\n\t\t\tsprintf(pg_result, \"OK: traffic_class=0x%02x\", pkt_dev->traffic_class);\n\t\t} else {\n\t\t\tsprintf(pg_result, \"ERROR: traffic_class must be 00-ff\");\n\t\t}\n\t\treturn count;\n\t}\n\n\tif (!strcmp(name, \"skb_priority\")) {\n\t\tlen = num_arg(&user_buffer[i], 9, &value);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\ti += len;\n\t\tpkt_dev->skb_priority = value;\n\t\tsprintf(pg_result, \"OK: skb_priority=%i\",\n\t\t\tpkt_dev->skb_priority);\n\t\treturn count;\n\t}\n\n\tsprintf(pkt_dev->result, \"No such parameter \\\"%s\\\"\", name);\n\treturn -EINVAL;\n}\n\nstatic int pktgen_if_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, pktgen_if_show, pde_data(inode));\n}\n\nstatic const struct proc_ops pktgen_if_proc_ops = {\n\t.proc_open\t= pktgen_if_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= pktgen_if_write,\n\t.proc_release\t= single_release,\n};\n\nstatic int pktgen_thread_show(struct seq_file *seq, void *v)\n{\n\tstruct pktgen_thread *t = seq->private;\n\tconst struct pktgen_dev *pkt_dev;\n\n\tBUG_ON(!t);\n\n\tseq_puts(seq, \"Running: \");\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pkt_dev, &t->if_list, list)\n\t\tif (pkt_dev->running)\n\t\t\tseq_printf(seq, \"%s \", pkt_dev->odevname);\n\n\tseq_puts(seq, \"\\nStopped: \");\n\n\tlist_for_each_entry_rcu(pkt_dev, &t->if_list, list)\n\t\tif (!pkt_dev->running)\n\t\t\tseq_printf(seq, \"%s \", pkt_dev->odevname);\n\n\tif (t->result[0])\n\t\tseq_printf(seq, \"\\nResult: %s\\n\", t->result);\n\telse\n\t\tseq_puts(seq, \"\\nResult: NA\\n\");\n\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic ssize_t pktgen_thread_write(struct file *file,\n\t\t\t\t   const char __user * user_buffer,\n\t\t\t\t   size_t count, loff_t * offset)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct pktgen_thread *t = seq->private;\n\tint i, max, len, ret;\n\tchar name[40];\n\tchar *pg_result;\n\n\tif (count < 1) {\n\t\t\n\t\treturn -EINVAL;\n\t}\n\n\tmax = count;\n\tlen = count_trail_chars(user_buffer, max);\n\tif (len < 0)\n\t\treturn len;\n\n\ti = len;\n\n\t \n\n\tlen = strn_len(&user_buffer[i], sizeof(name) - 1);\n\tif (len < 0)\n\t\treturn len;\n\n\tmemset(name, 0, sizeof(name));\n\tif (copy_from_user(name, &user_buffer[i], len))\n\t\treturn -EFAULT;\n\ti += len;\n\n\tmax = count - i;\n\tlen = count_trail_chars(&user_buffer[i], max);\n\tif (len < 0)\n\t\treturn len;\n\n\ti += len;\n\n\tif (debug)\n\t\tpr_debug(\"t=%s, count=%lu\\n\", name, (unsigned long)count);\n\n\tif (!t) {\n\t\tpr_err(\"ERROR: No thread\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpg_result = &(t->result[0]);\n\n\tif (!strcmp(name, \"add_device\")) {\n\t\tchar f[32];\n\t\tmemset(f, 0, 32);\n\t\tlen = strn_len(&user_buffer[i], sizeof(f) - 1);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out;\n\t\t}\n\t\tif (copy_from_user(f, &user_buffer[i], len))\n\t\t\treturn -EFAULT;\n\t\ti += len;\n\t\tmutex_lock(&pktgen_thread_lock);\n\t\tret = pktgen_add_device(t, f);\n\t\tmutex_unlock(&pktgen_thread_lock);\n\t\tif (!ret) {\n\t\t\tret = count;\n\t\t\tsprintf(pg_result, \"OK: add_device=%s\", f);\n\t\t} else\n\t\t\tsprintf(pg_result, \"ERROR: can not add device %s\", f);\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(name, \"rem_device_all\")) {\n\t\tmutex_lock(&pktgen_thread_lock);\n\t\tt->control |= T_REMDEVALL;\n\t\tmutex_unlock(&pktgen_thread_lock);\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(125));\t \n\t\tret = count;\n\t\tsprintf(pg_result, \"OK: rem_device_all\");\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(name, \"max_before_softirq\")) {\n\t\tsprintf(pg_result, \"OK: Note! max_before_softirq is obsoleted -- Do not use\");\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\nout:\n\treturn ret;\n}\n\nstatic int pktgen_thread_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, pktgen_thread_show, pde_data(inode));\n}\n\nstatic const struct proc_ops pktgen_thread_proc_ops = {\n\t.proc_open\t= pktgen_thread_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= pktgen_thread_write,\n\t.proc_release\t= single_release,\n};\n\n \nstatic struct pktgen_dev *__pktgen_NN_threads(const struct pktgen_net *pn,\n\t\t\t\t\t      const char *ifname, int remove)\n{\n\tstruct pktgen_thread *t;\n\tstruct pktgen_dev *pkt_dev = NULL;\n\tbool exact = (remove == FIND);\n\n\tlist_for_each_entry(t, &pn->pktgen_threads, th_list) {\n\t\tpkt_dev = pktgen_find_dev(t, ifname, exact);\n\t\tif (pkt_dev) {\n\t\t\tif (remove) {\n\t\t\t\tpkt_dev->removal_mark = 1;\n\t\t\t\tt->control |= T_REMDEV;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn pkt_dev;\n}\n\n \nstatic void pktgen_mark_device(const struct pktgen_net *pn, const char *ifname)\n{\n\tstruct pktgen_dev *pkt_dev = NULL;\n\tconst int max_tries = 10, msec_per_try = 125;\n\tint i = 0;\n\n\tmutex_lock(&pktgen_thread_lock);\n\tpr_debug(\"%s: marking %s for removal\\n\", __func__, ifname);\n\n\twhile (1) {\n\n\t\tpkt_dev = __pktgen_NN_threads(pn, ifname, REMOVE);\n\t\tif (pkt_dev == NULL)\n\t\t\tbreak;\t \n\n\t\tmutex_unlock(&pktgen_thread_lock);\n\t\tpr_debug(\"%s: waiting for %s to disappear....\\n\",\n\t\t\t __func__, ifname);\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(msec_per_try));\n\t\tmutex_lock(&pktgen_thread_lock);\n\n\t\tif (++i >= max_tries) {\n\t\t\tpr_err(\"%s: timed out after waiting %d msec for device %s to be removed\\n\",\n\t\t\t       __func__, msec_per_try * i, ifname);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tmutex_unlock(&pktgen_thread_lock);\n}\n\nstatic void pktgen_change_name(const struct pktgen_net *pn, struct net_device *dev)\n{\n\tstruct pktgen_thread *t;\n\n\tmutex_lock(&pktgen_thread_lock);\n\n\tlist_for_each_entry(t, &pn->pktgen_threads, th_list) {\n\t\tstruct pktgen_dev *pkt_dev;\n\n\t\tif_lock(t);\n\t\tlist_for_each_entry(pkt_dev, &t->if_list, list) {\n\t\t\tif (pkt_dev->odev != dev)\n\t\t\t\tcontinue;\n\n\t\t\tproc_remove(pkt_dev->entry);\n\n\t\t\tpkt_dev->entry = proc_create_data(dev->name, 0600,\n\t\t\t\t\t\t\t  pn->proc_dir,\n\t\t\t\t\t\t\t  &pktgen_if_proc_ops,\n\t\t\t\t\t\t\t  pkt_dev);\n\t\t\tif (!pkt_dev->entry)\n\t\t\t\tpr_err(\"can't move proc entry for '%s'\\n\",\n\t\t\t\t       dev->name);\n\t\t\tbreak;\n\t\t}\n\t\tif_unlock(t);\n\t}\n\tmutex_unlock(&pktgen_thread_lock);\n}\n\nstatic int pktgen_device_event(struct notifier_block *unused,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct pktgen_net *pn = net_generic(dev_net(dev), pg_net_id);\n\n\tif (pn->pktgen_exiting)\n\t\treturn NOTIFY_DONE;\n\n\t \n\n\tswitch (event) {\n\tcase NETDEV_CHANGENAME:\n\t\tpktgen_change_name(pn, dev);\n\t\tbreak;\n\n\tcase NETDEV_UNREGISTER:\n\t\tpktgen_mark_device(pn, dev->name);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct net_device *pktgen_dev_get_by_name(const struct pktgen_net *pn,\n\t\t\t\t\t\t struct pktgen_dev *pkt_dev,\n\t\t\t\t\t\t const char *ifname)\n{\n\tchar b[IFNAMSIZ+5];\n\tint i;\n\n\tfor (i = 0; ifname[i] != '@'; i++) {\n\t\tif (i == IFNAMSIZ)\n\t\t\tbreak;\n\n\t\tb[i] = ifname[i];\n\t}\n\tb[i] = 0;\n\n\treturn dev_get_by_name(pn->net, b);\n}\n\n\n \n\nstatic int pktgen_setup_dev(const struct pktgen_net *pn,\n\t\t\t    struct pktgen_dev *pkt_dev, const char *ifname)\n{\n\tstruct net_device *odev;\n\tint err;\n\n\t \n\tif (pkt_dev->odev) {\n\t\tnetdev_put(pkt_dev->odev, &pkt_dev->dev_tracker);\n\t\tpkt_dev->odev = NULL;\n\t}\n\n\todev = pktgen_dev_get_by_name(pn, pkt_dev, ifname);\n\tif (!odev) {\n\t\tpr_err(\"no such netdevice: \\\"%s\\\"\\n\", ifname);\n\t\treturn -ENODEV;\n\t}\n\n\tif (odev->type != ARPHRD_ETHER && odev->type != ARPHRD_LOOPBACK) {\n\t\tpr_err(\"not an ethernet or loopback device: \\\"%s\\\"\\n\", ifname);\n\t\terr = -EINVAL;\n\t} else if (!netif_running(odev)) {\n\t\tpr_err(\"device is down: \\\"%s\\\"\\n\", ifname);\n\t\terr = -ENETDOWN;\n\t} else {\n\t\tpkt_dev->odev = odev;\n\t\tnetdev_tracker_alloc(odev, &pkt_dev->dev_tracker, GFP_KERNEL);\n\t\treturn 0;\n\t}\n\n\tdev_put(odev);\n\treturn err;\n}\n\n \nstatic void pktgen_setup_inject(struct pktgen_dev *pkt_dev)\n{\n\tint ntxq;\n\n\tif (!pkt_dev->odev) {\n\t\tpr_err(\"ERROR: pkt_dev->odev == NULL in setup_inject\\n\");\n\t\tsprintf(pkt_dev->result,\n\t\t\t\"ERROR: pkt_dev->odev == NULL in setup_inject.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tntxq = pkt_dev->odev->real_num_tx_queues;\n\n\tif (ntxq <= pkt_dev->queue_map_min) {\n\t\tpr_warn(\"WARNING: Requested queue_map_min (zero-based) (%d) exceeds valid range [0 - %d] for (%d) queues on %s, resetting\\n\",\n\t\t\tpkt_dev->queue_map_min, (ntxq ?: 1) - 1, ntxq,\n\t\t\tpkt_dev->odevname);\n\t\tpkt_dev->queue_map_min = (ntxq ?: 1) - 1;\n\t}\n\tif (pkt_dev->queue_map_max >= ntxq) {\n\t\tpr_warn(\"WARNING: Requested queue_map_max (zero-based) (%d) exceeds valid range [0 - %d] for (%d) queues on %s, resetting\\n\",\n\t\t\tpkt_dev->queue_map_max, (ntxq ?: 1) - 1, ntxq,\n\t\t\tpkt_dev->odevname);\n\t\tpkt_dev->queue_map_max = (ntxq ?: 1) - 1;\n\t}\n\n\t \n\n\tif (is_zero_ether_addr(pkt_dev->src_mac))\n\t\tether_addr_copy(&(pkt_dev->hh[6]), pkt_dev->odev->dev_addr);\n\n\t \n\tether_addr_copy(&(pkt_dev->hh[0]), pkt_dev->dst_mac);\n\n\tif (pkt_dev->flags & F_IPV6) {\n\t\tint i, set = 0, err = 1;\n\t\tstruct inet6_dev *idev;\n\n\t\tif (pkt_dev->min_pkt_size == 0) {\n\t\t\tpkt_dev->min_pkt_size = 14 + sizeof(struct ipv6hdr)\n\t\t\t\t\t\t+ sizeof(struct udphdr)\n\t\t\t\t\t\t+ sizeof(struct pktgen_hdr)\n\t\t\t\t\t\t+ pkt_dev->pkt_overhead;\n\t\t}\n\n\t\tfor (i = 0; i < sizeof(struct in6_addr); i++)\n\t\t\tif (pkt_dev->cur_in6_saddr.s6_addr[i]) {\n\t\t\t\tset = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!set) {\n\n\t\t\t \n\n\t\t\trcu_read_lock();\n\t\t\tidev = __in6_dev_get(pkt_dev->odev);\n\t\t\tif (idev) {\n\t\t\t\tstruct inet6_ifaddr *ifp;\n\n\t\t\t\tread_lock_bh(&idev->lock);\n\t\t\t\tlist_for_each_entry(ifp, &idev->addr_list, if_list) {\n\t\t\t\t\tif ((ifp->scope & IFA_LINK) &&\n\t\t\t\t\t    !(ifp->flags & IFA_F_TENTATIVE)) {\n\t\t\t\t\t\tpkt_dev->cur_in6_saddr = ifp->addr;\n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tread_unlock_bh(&idev->lock);\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tif (err)\n\t\t\t\tpr_err(\"ERROR: IPv6 link address not available\\n\");\n\t\t}\n\t} else {\n\t\tif (pkt_dev->min_pkt_size == 0) {\n\t\t\tpkt_dev->min_pkt_size = 14 + sizeof(struct iphdr)\n\t\t\t\t\t\t+ sizeof(struct udphdr)\n\t\t\t\t\t\t+ sizeof(struct pktgen_hdr)\n\t\t\t\t\t\t+ pkt_dev->pkt_overhead;\n\t\t}\n\n\t\tpkt_dev->saddr_min = 0;\n\t\tpkt_dev->saddr_max = 0;\n\t\tif (strlen(pkt_dev->src_min) == 0) {\n\n\t\t\tstruct in_device *in_dev;\n\n\t\t\trcu_read_lock();\n\t\t\tin_dev = __in_dev_get_rcu(pkt_dev->odev);\n\t\t\tif (in_dev) {\n\t\t\t\tconst struct in_ifaddr *ifa;\n\n\t\t\t\tifa = rcu_dereference(in_dev->ifa_list);\n\t\t\t\tif (ifa) {\n\t\t\t\t\tpkt_dev->saddr_min = ifa->ifa_address;\n\t\t\t\t\tpkt_dev->saddr_max = pkt_dev->saddr_min;\n\t\t\t\t}\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tpkt_dev->saddr_min = in_aton(pkt_dev->src_min);\n\t\t\tpkt_dev->saddr_max = in_aton(pkt_dev->src_max);\n\t\t}\n\n\t\tpkt_dev->daddr_min = in_aton(pkt_dev->dst_min);\n\t\tpkt_dev->daddr_max = in_aton(pkt_dev->dst_max);\n\t}\n\t \n\tpkt_dev->cur_pkt_size = pkt_dev->min_pkt_size;\n\tif (pkt_dev->min_pkt_size > pkt_dev->max_pkt_size)\n\t\tpkt_dev->max_pkt_size = pkt_dev->min_pkt_size;\n\n\tpkt_dev->cur_dst_mac_offset = 0;\n\tpkt_dev->cur_src_mac_offset = 0;\n\tpkt_dev->cur_saddr = pkt_dev->saddr_min;\n\tpkt_dev->cur_daddr = pkt_dev->daddr_min;\n\tpkt_dev->cur_udp_dst = pkt_dev->udp_dst_min;\n\tpkt_dev->cur_udp_src = pkt_dev->udp_src_min;\n\tpkt_dev->nflows = 0;\n}\n\n\nstatic void spin(struct pktgen_dev *pkt_dev, ktime_t spin_until)\n{\n\tktime_t start_time, end_time;\n\ts64 remaining;\n\tstruct hrtimer_sleeper t;\n\n\thrtimer_init_sleeper_on_stack(&t, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\thrtimer_set_expires(&t.timer, spin_until);\n\n\tremaining = ktime_to_ns(hrtimer_expires_remaining(&t.timer));\n\tif (remaining <= 0)\n\t\tgoto out;\n\n\tstart_time = ktime_get();\n\tif (remaining < 100000) {\n\t\t \n\t\tdo {\n\t\t\tend_time = ktime_get();\n\t\t} while (ktime_compare(end_time, spin_until) < 0);\n\t} else {\n\t\tdo {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\thrtimer_sleeper_start_expires(&t, HRTIMER_MODE_ABS);\n\n\t\t\tif (likely(t.task))\n\t\t\t\tschedule();\n\n\t\t\thrtimer_cancel(&t.timer);\n\t\t} while (t.task && pkt_dev->running && !signal_pending(current));\n\t\t__set_current_state(TASK_RUNNING);\n\t\tend_time = ktime_get();\n\t}\n\n\tpkt_dev->idle_acc += ktime_to_ns(ktime_sub(end_time, start_time));\nout:\n\tpkt_dev->next_tx = ktime_add_ns(spin_until, pkt_dev->delay);\n\tdestroy_hrtimer_on_stack(&t.timer);\n}\n\nstatic inline void set_pkt_overhead(struct pktgen_dev *pkt_dev)\n{\n\tpkt_dev->pkt_overhead = 0;\n\tpkt_dev->pkt_overhead += pkt_dev->nr_labels*sizeof(u32);\n\tpkt_dev->pkt_overhead += VLAN_TAG_SIZE(pkt_dev);\n\tpkt_dev->pkt_overhead += SVLAN_TAG_SIZE(pkt_dev);\n}\n\nstatic inline int f_seen(const struct pktgen_dev *pkt_dev, int flow)\n{\n\treturn !!(pkt_dev->flows[flow].flags & F_INIT);\n}\n\nstatic inline int f_pick(struct pktgen_dev *pkt_dev)\n{\n\tint flow = pkt_dev->curfl;\n\n\tif (pkt_dev->flags & F_FLOW_SEQ) {\n\t\tif (pkt_dev->flows[flow].count >= pkt_dev->lflow) {\n\t\t\t \n\t\t\tpkt_dev->flows[flow].count = 0;\n\t\t\tpkt_dev->flows[flow].flags = 0;\n\t\t\tpkt_dev->curfl += 1;\n\t\t\tif (pkt_dev->curfl >= pkt_dev->cflows)\n\t\t\t\tpkt_dev->curfl = 0;  \n\t\t}\n\t} else {\n\t\tflow = get_random_u32_below(pkt_dev->cflows);\n\t\tpkt_dev->curfl = flow;\n\n\t\tif (pkt_dev->flows[flow].count > pkt_dev->lflow) {\n\t\t\tpkt_dev->flows[flow].count = 0;\n\t\t\tpkt_dev->flows[flow].flags = 0;\n\t\t}\n\t}\n\n\treturn pkt_dev->curfl;\n}\n\n\n#ifdef CONFIG_XFRM\n \n#define DUMMY_MARK 0\nstatic void get_ipsec_sa(struct pktgen_dev *pkt_dev, int flow)\n{\n\tstruct xfrm_state *x = pkt_dev->flows[flow].x;\n\tstruct pktgen_net *pn = net_generic(dev_net(pkt_dev->odev), pg_net_id);\n\tif (!x) {\n\n\t\tif (pkt_dev->spi) {\n\t\t\t \n\t\t\tx = xfrm_state_lookup_byspi(pn->net, htonl(pkt_dev->spi), AF_INET);\n\t\t} else {\n\t\t\t \n\t\t\tx = xfrm_stateonly_find(pn->net, DUMMY_MARK, 0,\n\t\t\t\t\t\t(xfrm_address_t *)&pkt_dev->cur_daddr,\n\t\t\t\t\t\t(xfrm_address_t *)&pkt_dev->cur_saddr,\n\t\t\t\t\t\tAF_INET,\n\t\t\t\t\t\tpkt_dev->ipsmode,\n\t\t\t\t\t\tpkt_dev->ipsproto, 0);\n\t\t}\n\t\tif (x) {\n\t\t\tpkt_dev->flows[flow].x = x;\n\t\t\tset_pkt_overhead(pkt_dev);\n\t\t\tpkt_dev->pkt_overhead += x->props.header_len;\n\t\t}\n\n\t}\n}\n#endif\nstatic void set_cur_queue_map(struct pktgen_dev *pkt_dev)\n{\n\n\tif (pkt_dev->flags & F_QUEUE_MAP_CPU)\n\t\tpkt_dev->cur_queue_map = smp_processor_id();\n\n\telse if (pkt_dev->queue_map_min <= pkt_dev->queue_map_max) {\n\t\t__u16 t;\n\t\tif (pkt_dev->flags & F_QUEUE_MAP_RND) {\n\t\t\tt = get_random_u32_inclusive(pkt_dev->queue_map_min,\n\t\t\t\t\t\t     pkt_dev->queue_map_max);\n\t\t} else {\n\t\t\tt = pkt_dev->cur_queue_map + 1;\n\t\t\tif (t > pkt_dev->queue_map_max)\n\t\t\t\tt = pkt_dev->queue_map_min;\n\t\t}\n\t\tpkt_dev->cur_queue_map = t;\n\t}\n\tpkt_dev->cur_queue_map  = pkt_dev->cur_queue_map % pkt_dev->odev->real_num_tx_queues;\n}\n\n \nstatic void mod_cur_headers(struct pktgen_dev *pkt_dev)\n{\n\t__u32 imn;\n\t__u32 imx;\n\tint flow = 0;\n\n\tif (pkt_dev->cflows)\n\t\tflow = f_pick(pkt_dev);\n\n\t \n\tif (pkt_dev->src_mac_count > 1) {\n\t\t__u32 mc;\n\t\t__u32 tmp;\n\n\t\tif (pkt_dev->flags & F_MACSRC_RND)\n\t\t\tmc = get_random_u32_below(pkt_dev->src_mac_count);\n\t\telse {\n\t\t\tmc = pkt_dev->cur_src_mac_offset++;\n\t\t\tif (pkt_dev->cur_src_mac_offset >=\n\t\t\t    pkt_dev->src_mac_count)\n\t\t\t\tpkt_dev->cur_src_mac_offset = 0;\n\t\t}\n\n\t\ttmp = pkt_dev->src_mac[5] + (mc & 0xFF);\n\t\tpkt_dev->hh[11] = tmp;\n\t\ttmp = (pkt_dev->src_mac[4] + ((mc >> 8) & 0xFF) + (tmp >> 8));\n\t\tpkt_dev->hh[10] = tmp;\n\t\ttmp = (pkt_dev->src_mac[3] + ((mc >> 16) & 0xFF) + (tmp >> 8));\n\t\tpkt_dev->hh[9] = tmp;\n\t\ttmp = (pkt_dev->src_mac[2] + ((mc >> 24) & 0xFF) + (tmp >> 8));\n\t\tpkt_dev->hh[8] = tmp;\n\t\ttmp = (pkt_dev->src_mac[1] + (tmp >> 8));\n\t\tpkt_dev->hh[7] = tmp;\n\t}\n\n\t \n\tif (pkt_dev->dst_mac_count > 1) {\n\t\t__u32 mc;\n\t\t__u32 tmp;\n\n\t\tif (pkt_dev->flags & F_MACDST_RND)\n\t\t\tmc = get_random_u32_below(pkt_dev->dst_mac_count);\n\n\t\telse {\n\t\t\tmc = pkt_dev->cur_dst_mac_offset++;\n\t\t\tif (pkt_dev->cur_dst_mac_offset >=\n\t\t\t    pkt_dev->dst_mac_count) {\n\t\t\t\tpkt_dev->cur_dst_mac_offset = 0;\n\t\t\t}\n\t\t}\n\n\t\ttmp = pkt_dev->dst_mac[5] + (mc & 0xFF);\n\t\tpkt_dev->hh[5] = tmp;\n\t\ttmp = (pkt_dev->dst_mac[4] + ((mc >> 8) & 0xFF) + (tmp >> 8));\n\t\tpkt_dev->hh[4] = tmp;\n\t\ttmp = (pkt_dev->dst_mac[3] + ((mc >> 16) & 0xFF) + (tmp >> 8));\n\t\tpkt_dev->hh[3] = tmp;\n\t\ttmp = (pkt_dev->dst_mac[2] + ((mc >> 24) & 0xFF) + (tmp >> 8));\n\t\tpkt_dev->hh[2] = tmp;\n\t\ttmp = (pkt_dev->dst_mac[1] + (tmp >> 8));\n\t\tpkt_dev->hh[1] = tmp;\n\t}\n\n\tif (pkt_dev->flags & F_MPLS_RND) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < pkt_dev->nr_labels; i++)\n\t\t\tif (pkt_dev->labels[i] & MPLS_STACK_BOTTOM)\n\t\t\t\tpkt_dev->labels[i] = MPLS_STACK_BOTTOM |\n\t\t\t\t\t     ((__force __be32)get_random_u32() &\n\t\t\t\t\t\t      htonl(0x000fffff));\n\t}\n\n\tif ((pkt_dev->flags & F_VID_RND) && (pkt_dev->vlan_id != 0xffff)) {\n\t\tpkt_dev->vlan_id = get_random_u32_below(4096);\n\t}\n\n\tif ((pkt_dev->flags & F_SVID_RND) && (pkt_dev->svlan_id != 0xffff)) {\n\t\tpkt_dev->svlan_id = get_random_u32_below(4096);\n\t}\n\n\tif (pkt_dev->udp_src_min < pkt_dev->udp_src_max) {\n\t\tif (pkt_dev->flags & F_UDPSRC_RND)\n\t\t\tpkt_dev->cur_udp_src = get_random_u32_inclusive(pkt_dev->udp_src_min,\n\t\t\t\t\t\t\t\t\tpkt_dev->udp_src_max - 1);\n\n\t\telse {\n\t\t\tpkt_dev->cur_udp_src++;\n\t\t\tif (pkt_dev->cur_udp_src >= pkt_dev->udp_src_max)\n\t\t\t\tpkt_dev->cur_udp_src = pkt_dev->udp_src_min;\n\t\t}\n\t}\n\n\tif (pkt_dev->udp_dst_min < pkt_dev->udp_dst_max) {\n\t\tif (pkt_dev->flags & F_UDPDST_RND) {\n\t\t\tpkt_dev->cur_udp_dst = get_random_u32_inclusive(pkt_dev->udp_dst_min,\n\t\t\t\t\t\t\t\t\tpkt_dev->udp_dst_max - 1);\n\t\t} else {\n\t\t\tpkt_dev->cur_udp_dst++;\n\t\t\tif (pkt_dev->cur_udp_dst >= pkt_dev->udp_dst_max)\n\t\t\t\tpkt_dev->cur_udp_dst = pkt_dev->udp_dst_min;\n\t\t}\n\t}\n\n\tif (!(pkt_dev->flags & F_IPV6)) {\n\n\t\timn = ntohl(pkt_dev->saddr_min);\n\t\timx = ntohl(pkt_dev->saddr_max);\n\t\tif (imn < imx) {\n\t\t\t__u32 t;\n\t\t\tif (pkt_dev->flags & F_IPSRC_RND)\n\t\t\t\tt = get_random_u32_inclusive(imn, imx - 1);\n\t\t\telse {\n\t\t\t\tt = ntohl(pkt_dev->cur_saddr);\n\t\t\t\tt++;\n\t\t\t\tif (t > imx)\n\t\t\t\t\tt = imn;\n\n\t\t\t}\n\t\t\tpkt_dev->cur_saddr = htonl(t);\n\t\t}\n\n\t\tif (pkt_dev->cflows && f_seen(pkt_dev, flow)) {\n\t\t\tpkt_dev->cur_daddr = pkt_dev->flows[flow].cur_daddr;\n\t\t} else {\n\t\t\timn = ntohl(pkt_dev->daddr_min);\n\t\t\timx = ntohl(pkt_dev->daddr_max);\n\t\t\tif (imn < imx) {\n\t\t\t\t__u32 t;\n\t\t\t\t__be32 s;\n\t\t\t\tif (pkt_dev->flags & F_IPDST_RND) {\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tt = get_random_u32_inclusive(imn, imx - 1);\n\t\t\t\t\t\ts = htonl(t);\n\t\t\t\t\t} while (ipv4_is_loopback(s) ||\n\t\t\t\t\t\tipv4_is_multicast(s) ||\n\t\t\t\t\t\tipv4_is_lbcast(s) ||\n\t\t\t\t\t\tipv4_is_zeronet(s) ||\n\t\t\t\t\t\tipv4_is_local_multicast(s));\n\t\t\t\t\tpkt_dev->cur_daddr = s;\n\t\t\t\t} else {\n\t\t\t\t\tt = ntohl(pkt_dev->cur_daddr);\n\t\t\t\t\tt++;\n\t\t\t\t\tif (t > imx) {\n\t\t\t\t\t\tt = imn;\n\t\t\t\t\t}\n\t\t\t\t\tpkt_dev->cur_daddr = htonl(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pkt_dev->cflows) {\n\t\t\t\tpkt_dev->flows[flow].flags |= F_INIT;\n\t\t\t\tpkt_dev->flows[flow].cur_daddr =\n\t\t\t\t    pkt_dev->cur_daddr;\n#ifdef CONFIG_XFRM\n\t\t\t\tif (pkt_dev->flags & F_IPSEC)\n\t\t\t\t\tget_ipsec_sa(pkt_dev, flow);\n#endif\n\t\t\t\tpkt_dev->nflows++;\n\t\t\t}\n\t\t}\n\t} else {\t\t \n\n\t\tif (!ipv6_addr_any(&pkt_dev->min_in6_daddr)) {\n\t\t\tint i;\n\n\t\t\t \n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tpkt_dev->cur_in6_daddr.s6_addr32[i] =\n\t\t\t\t    (((__force __be32)get_random_u32() |\n\t\t\t\t      pkt_dev->min_in6_daddr.s6_addr32[i]) &\n\t\t\t\t     pkt_dev->max_in6_daddr.s6_addr32[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pkt_dev->min_pkt_size < pkt_dev->max_pkt_size) {\n\t\t__u32 t;\n\t\tif (pkt_dev->flags & F_TXSIZE_RND) {\n\t\t\tt = get_random_u32_inclusive(pkt_dev->min_pkt_size,\n\t\t\t\t\t\t     pkt_dev->max_pkt_size - 1);\n\t\t} else {\n\t\t\tt = pkt_dev->cur_pkt_size + 1;\n\t\t\tif (t > pkt_dev->max_pkt_size)\n\t\t\t\tt = pkt_dev->min_pkt_size;\n\t\t}\n\t\tpkt_dev->cur_pkt_size = t;\n\t} else if (pkt_dev->n_imix_entries > 0) {\n\t\tstruct imix_pkt *entry;\n\t\t__u32 t = get_random_u32_below(IMIX_PRECISION);\n\t\t__u8 entry_index = pkt_dev->imix_distribution[t];\n\n\t\tentry = &pkt_dev->imix_entries[entry_index];\n\t\tentry->count_so_far++;\n\t\tpkt_dev->cur_pkt_size = entry->size;\n\t}\n\n\tset_cur_queue_map(pkt_dev);\n\n\tpkt_dev->flows[flow].count++;\n}\n\nstatic void fill_imix_distribution(struct pktgen_dev *pkt_dev)\n{\n\tint cumulative_probabilites[MAX_IMIX_ENTRIES];\n\tint j = 0;\n\t__u64 cumulative_prob = 0;\n\t__u64 total_weight = 0;\n\tint i = 0;\n\n\tfor (i = 0; i < pkt_dev->n_imix_entries; i++)\n\t\ttotal_weight += pkt_dev->imix_entries[i].weight;\n\n\t \n\tfor (i = 0; i < pkt_dev->n_imix_entries - 1; i++) {\n\t\tcumulative_prob += div64_u64(pkt_dev->imix_entries[i].weight *\n\t\t\t\t\t\t     IMIX_PRECISION,\n\t\t\t\t\t     total_weight);\n\t\tcumulative_probabilites[i] = cumulative_prob;\n\t}\n\tcumulative_probabilites[pkt_dev->n_imix_entries - 1] = 100;\n\n\tfor (i = 0; i < IMIX_PRECISION; i++) {\n\t\tif (i == cumulative_probabilites[j])\n\t\t\tj++;\n\t\tpkt_dev->imix_distribution[i] = j;\n\t}\n}\n\n#ifdef CONFIG_XFRM\nstatic u32 pktgen_dst_metrics[RTAX_MAX + 1] = {\n\n\t[RTAX_HOPLIMIT] = 0x5,  \n};\n\nstatic int pktgen_output_ipsec(struct sk_buff *skb, struct pktgen_dev *pkt_dev)\n{\n\tstruct xfrm_state *x = pkt_dev->flows[pkt_dev->curfl].x;\n\tint err = 0;\n\tstruct net *net = dev_net(pkt_dev->odev);\n\n\tif (!x)\n\t\treturn 0;\n\t \n\tif ((x->props.mode != XFRM_MODE_TRANSPORT) && (pkt_dev->spi == 0))\n\t\treturn 0;\n\n\t \n\tif ((x->props.mode == XFRM_MODE_TUNNEL) && (pkt_dev->spi != 0))\n\t\tskb->_skb_refdst = (unsigned long)&pkt_dev->xdst.u.dst | SKB_DST_NOREF;\n\n\trcu_read_lock_bh();\n\terr = pktgen_xfrm_outer_mode_output(x, skb);\n\trcu_read_unlock_bh();\n\tif (err) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTSTATEMODEERROR);\n\t\tgoto error;\n\t}\n\terr = x->type->output(x, skb);\n\tif (err) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTSTATEPROTOERROR);\n\t\tgoto error;\n\t}\n\tspin_lock_bh(&x->lock);\n\tx->curlft.bytes += skb->len;\n\tx->curlft.packets++;\n\tspin_unlock_bh(&x->lock);\nerror:\n\treturn err;\n}\n\nstatic void free_SAs(struct pktgen_dev *pkt_dev)\n{\n\tif (pkt_dev->cflows) {\n\t\t \n\t\tint i;\n\t\tfor (i = 0; i < pkt_dev->cflows; i++) {\n\t\t\tstruct xfrm_state *x = pkt_dev->flows[i].x;\n\t\t\tif (x) {\n\t\t\t\txfrm_state_put(x);\n\t\t\t\tpkt_dev->flows[i].x = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int process_ipsec(struct pktgen_dev *pkt_dev,\n\t\t\t      struct sk_buff *skb, __be16 protocol)\n{\n\tif (pkt_dev->flags & F_IPSEC) {\n\t\tstruct xfrm_state *x = pkt_dev->flows[pkt_dev->curfl].x;\n\t\tint nhead = 0;\n\t\tif (x) {\n\t\t\tstruct ethhdr *eth;\n\t\t\tstruct iphdr *iph;\n\t\t\tint ret;\n\n\t\t\tnhead = x->props.header_len - skb_headroom(skb);\n\t\t\tif (nhead > 0) {\n\t\t\t\tret = pskb_expand_head(skb, nhead, 0, GFP_ATOMIC);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tpr_err(\"Error expanding ipsec packet %d\\n\",\n\t\t\t\t\t       ret);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tskb_pull(skb, ETH_HLEN);\n\t\t\tret = pktgen_output_ipsec(skb, pkt_dev);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Error creating ipsec packet %d\\n\", ret);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t \n\t\t\teth = skb_push(skb, ETH_HLEN);\n\t\t\tmemcpy(eth, pkt_dev->hh, 2 * ETH_ALEN);\n\t\t\teth->h_proto = protocol;\n\n\t\t\t \n\t\t\tiph = ip_hdr(skb);\n\t\t\tiph->tot_len = htons(skb->len - ETH_HLEN);\n\t\t\tip_send_check(iph);\n\t\t}\n\t}\n\treturn 1;\nerr:\n\tkfree_skb(skb);\n\treturn 0;\n}\n#endif\n\nstatic void mpls_push(__be32 *mpls, struct pktgen_dev *pkt_dev)\n{\n\tunsigned int i;\n\tfor (i = 0; i < pkt_dev->nr_labels; i++)\n\t\t*mpls++ = pkt_dev->labels[i] & ~MPLS_STACK_BOTTOM;\n\n\tmpls--;\n\t*mpls |= MPLS_STACK_BOTTOM;\n}\n\nstatic inline __be16 build_tci(unsigned int id, unsigned int cfi,\n\t\t\t       unsigned int prio)\n{\n\treturn htons(id | (cfi << 12) | (prio << 13));\n}\n\nstatic void pktgen_finalize_skb(struct pktgen_dev *pkt_dev, struct sk_buff *skb,\n\t\t\t\tint datalen)\n{\n\tstruct timespec64 timestamp;\n\tstruct pktgen_hdr *pgh;\n\n\tpgh = skb_put(skb, sizeof(*pgh));\n\tdatalen -= sizeof(*pgh);\n\n\tif (pkt_dev->nfrags <= 0) {\n\t\tskb_put_zero(skb, datalen);\n\t} else {\n\t\tint frags = pkt_dev->nfrags;\n\t\tint i, len;\n\t\tint frag_len;\n\n\n\t\tif (frags > MAX_SKB_FRAGS)\n\t\t\tfrags = MAX_SKB_FRAGS;\n\t\tlen = datalen - frags * PAGE_SIZE;\n\t\tif (len > 0) {\n\t\t\tskb_put_zero(skb, len);\n\t\t\tdatalen = frags * PAGE_SIZE;\n\t\t}\n\n\t\ti = 0;\n\t\tfrag_len = (datalen/frags) < PAGE_SIZE ?\n\t\t\t   (datalen/frags) : PAGE_SIZE;\n\t\twhile (datalen > 0) {\n\t\t\tif (unlikely(!pkt_dev->page)) {\n\t\t\t\tint node = numa_node_id();\n\n\t\t\t\tif (pkt_dev->node >= 0 && (pkt_dev->flags & F_NODE))\n\t\t\t\t\tnode = pkt_dev->node;\n\t\t\t\tpkt_dev->page = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\t\t\t\tif (!pkt_dev->page)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tget_page(pkt_dev->page);\n\n\t\t\t \n\t\t\tif (i == (frags - 1))\n\t\t\t\tskb_frag_fill_page_desc(&skb_shinfo(skb)->frags[i],\n\t\t\t\t\t\t\tpkt_dev->page, 0,\n\t\t\t\t\t\t\t(datalen < PAGE_SIZE ?\n\t\t\t\t\t\t\t datalen : PAGE_SIZE));\n\t\t\telse\n\t\t\t\tskb_frag_fill_page_desc(&skb_shinfo(skb)->frags[i],\n\t\t\t\t\t\t\tpkt_dev->page, 0, frag_len);\n\n\t\t\tdatalen -= skb_frag_size(&skb_shinfo(skb)->frags[i]);\n\t\t\tskb->len += skb_frag_size(&skb_shinfo(skb)->frags[i]);\n\t\t\tskb->data_len += skb_frag_size(&skb_shinfo(skb)->frags[i]);\n\t\t\ti++;\n\t\t\tskb_shinfo(skb)->nr_frags = i;\n\t\t}\n\t}\n\n\t \n\tpgh->pgh_magic = htonl(PKTGEN_MAGIC);\n\tpgh->seq_num = htonl(pkt_dev->seq_num);\n\n\tif (pkt_dev->flags & F_NO_TIMESTAMP) {\n\t\tpgh->tv_sec = 0;\n\t\tpgh->tv_usec = 0;\n\t} else {\n\t\t \n\t\tktime_get_real_ts64(&timestamp);\n\t\tpgh->tv_sec = htonl(timestamp.tv_sec);\n\t\tpgh->tv_usec = htonl(timestamp.tv_nsec / NSEC_PER_USEC);\n\t}\n}\n\nstatic struct sk_buff *pktgen_alloc_skb(struct net_device *dev,\n\t\t\t\t\tstruct pktgen_dev *pkt_dev)\n{\n\tunsigned int extralen = LL_RESERVED_SPACE(dev);\n\tstruct sk_buff *skb = NULL;\n\tunsigned int size;\n\n\tsize = pkt_dev->cur_pkt_size + 64 + extralen + pkt_dev->pkt_overhead;\n\tif (pkt_dev->flags & F_NODE) {\n\t\tint node = pkt_dev->node >= 0 ? pkt_dev->node : numa_node_id();\n\n\t\tskb = __alloc_skb(NET_SKB_PAD + size, GFP_NOWAIT, 0, node);\n\t\tif (likely(skb)) {\n\t\t\tskb_reserve(skb, NET_SKB_PAD);\n\t\t\tskb->dev = dev;\n\t\t}\n\t} else {\n\t\t skb = __netdev_alloc_skb(dev, size, GFP_NOWAIT);\n\t}\n\n\t \n\tif (likely(skb))\n\t\tskb_reserve(skb, extralen - 16);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *fill_packet_ipv4(struct net_device *odev,\n\t\t\t\t\tstruct pktgen_dev *pkt_dev)\n{\n\tstruct sk_buff *skb = NULL;\n\t__u8 *eth;\n\tstruct udphdr *udph;\n\tint datalen, iplen;\n\tstruct iphdr *iph;\n\t__be16 protocol = htons(ETH_P_IP);\n\t__be32 *mpls;\n\t__be16 *vlan_tci = NULL;                  \n\t__be16 *vlan_encapsulated_proto = NULL;   \n\t__be16 *svlan_tci = NULL;                 \n\t__be16 *svlan_encapsulated_proto = NULL;  \n\tu16 queue_map;\n\n\tif (pkt_dev->nr_labels)\n\t\tprotocol = htons(ETH_P_MPLS_UC);\n\n\tif (pkt_dev->vlan_id != 0xffff)\n\t\tprotocol = htons(ETH_P_8021Q);\n\n\t \n\tmod_cur_headers(pkt_dev);\n\tqueue_map = pkt_dev->cur_queue_map;\n\n\tskb = pktgen_alloc_skb(odev, pkt_dev);\n\tif (!skb) {\n\t\tsprintf(pkt_dev->result, \"No memory\");\n\t\treturn NULL;\n\t}\n\n\tprefetchw(skb->data);\n\tskb_reserve(skb, 16);\n\n\t \n\teth = skb_push(skb, 14);\n\tmpls = skb_put(skb, pkt_dev->nr_labels * sizeof(__u32));\n\tif (pkt_dev->nr_labels)\n\t\tmpls_push(mpls, pkt_dev);\n\n\tif (pkt_dev->vlan_id != 0xffff) {\n\t\tif (pkt_dev->svlan_id != 0xffff) {\n\t\t\tsvlan_tci = skb_put(skb, sizeof(__be16));\n\t\t\t*svlan_tci = build_tci(pkt_dev->svlan_id,\n\t\t\t\t\t       pkt_dev->svlan_cfi,\n\t\t\t\t\t       pkt_dev->svlan_p);\n\t\t\tsvlan_encapsulated_proto = skb_put(skb,\n\t\t\t\t\t\t\t   sizeof(__be16));\n\t\t\t*svlan_encapsulated_proto = htons(ETH_P_8021Q);\n\t\t}\n\t\tvlan_tci = skb_put(skb, sizeof(__be16));\n\t\t*vlan_tci = build_tci(pkt_dev->vlan_id,\n\t\t\t\t      pkt_dev->vlan_cfi,\n\t\t\t\t      pkt_dev->vlan_p);\n\t\tvlan_encapsulated_proto = skb_put(skb, sizeof(__be16));\n\t\t*vlan_encapsulated_proto = htons(ETH_P_IP);\n\t}\n\n\tskb_reset_mac_header(skb);\n\tskb_set_network_header(skb, skb->len);\n\tiph = skb_put(skb, sizeof(struct iphdr));\n\n\tskb_set_transport_header(skb, skb->len);\n\tudph = skb_put(skb, sizeof(struct udphdr));\n\tskb_set_queue_mapping(skb, queue_map);\n\tskb->priority = pkt_dev->skb_priority;\n\n\tmemcpy(eth, pkt_dev->hh, 12);\n\t*(__be16 *) & eth[12] = protocol;\n\n\t \n\tdatalen = pkt_dev->cur_pkt_size - 14 - 20 - 8 -\n\t\t  pkt_dev->pkt_overhead;\n\tif (datalen < 0 || datalen < sizeof(struct pktgen_hdr))\n\t\tdatalen = sizeof(struct pktgen_hdr);\n\n\tudph->source = htons(pkt_dev->cur_udp_src);\n\tudph->dest = htons(pkt_dev->cur_udp_dst);\n\tudph->len = htons(datalen + 8);\t \n\tudph->check = 0;\n\n\tiph->ihl = 5;\n\tiph->version = 4;\n\tiph->ttl = 32;\n\tiph->tos = pkt_dev->tos;\n\tiph->protocol = IPPROTO_UDP;\t \n\tiph->saddr = pkt_dev->cur_saddr;\n\tiph->daddr = pkt_dev->cur_daddr;\n\tiph->id = htons(pkt_dev->ip_id);\n\tpkt_dev->ip_id++;\n\tiph->frag_off = 0;\n\tiplen = 20 + 8 + datalen;\n\tiph->tot_len = htons(iplen);\n\tip_send_check(iph);\n\tskb->protocol = protocol;\n\tskb->dev = odev;\n\tskb->pkt_type = PACKET_HOST;\n\n\tpktgen_finalize_skb(pkt_dev, skb, datalen);\n\n\tif (!(pkt_dev->flags & F_UDPCSUM)) {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t} else if (odev->features & (NETIF_F_HW_CSUM | NETIF_F_IP_CSUM)) {\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t\tudp4_hwcsum(skb, iph->saddr, iph->daddr);\n\t} else {\n\t\t__wsum csum = skb_checksum(skb, skb_transport_offset(skb), datalen + 8, 0);\n\n\t\t \n\t\tudph->check = csum_tcpudp_magic(iph->saddr, iph->daddr,\n\t\t\t\t\t\tdatalen + 8, IPPROTO_UDP, csum);\n\n\t\tif (udph->check == 0)\n\t\t\tudph->check = CSUM_MANGLED_0;\n\t}\n\n#ifdef CONFIG_XFRM\n\tif (!process_ipsec(pkt_dev, skb, protocol))\n\t\treturn NULL;\n#endif\n\n\treturn skb;\n}\n\nstatic struct sk_buff *fill_packet_ipv6(struct net_device *odev,\n\t\t\t\t\tstruct pktgen_dev *pkt_dev)\n{\n\tstruct sk_buff *skb = NULL;\n\t__u8 *eth;\n\tstruct udphdr *udph;\n\tint datalen, udplen;\n\tstruct ipv6hdr *iph;\n\t__be16 protocol = htons(ETH_P_IPV6);\n\t__be32 *mpls;\n\t__be16 *vlan_tci = NULL;                  \n\t__be16 *vlan_encapsulated_proto = NULL;   \n\t__be16 *svlan_tci = NULL;                 \n\t__be16 *svlan_encapsulated_proto = NULL;  \n\tu16 queue_map;\n\n\tif (pkt_dev->nr_labels)\n\t\tprotocol = htons(ETH_P_MPLS_UC);\n\n\tif (pkt_dev->vlan_id != 0xffff)\n\t\tprotocol = htons(ETH_P_8021Q);\n\n\t \n\tmod_cur_headers(pkt_dev);\n\tqueue_map = pkt_dev->cur_queue_map;\n\n\tskb = pktgen_alloc_skb(odev, pkt_dev);\n\tif (!skb) {\n\t\tsprintf(pkt_dev->result, \"No memory\");\n\t\treturn NULL;\n\t}\n\n\tprefetchw(skb->data);\n\tskb_reserve(skb, 16);\n\n\t \n\teth = skb_push(skb, 14);\n\tmpls = skb_put(skb, pkt_dev->nr_labels * sizeof(__u32));\n\tif (pkt_dev->nr_labels)\n\t\tmpls_push(mpls, pkt_dev);\n\n\tif (pkt_dev->vlan_id != 0xffff) {\n\t\tif (pkt_dev->svlan_id != 0xffff) {\n\t\t\tsvlan_tci = skb_put(skb, sizeof(__be16));\n\t\t\t*svlan_tci = build_tci(pkt_dev->svlan_id,\n\t\t\t\t\t       pkt_dev->svlan_cfi,\n\t\t\t\t\t       pkt_dev->svlan_p);\n\t\t\tsvlan_encapsulated_proto = skb_put(skb,\n\t\t\t\t\t\t\t   sizeof(__be16));\n\t\t\t*svlan_encapsulated_proto = htons(ETH_P_8021Q);\n\t\t}\n\t\tvlan_tci = skb_put(skb, sizeof(__be16));\n\t\t*vlan_tci = build_tci(pkt_dev->vlan_id,\n\t\t\t\t      pkt_dev->vlan_cfi,\n\t\t\t\t      pkt_dev->vlan_p);\n\t\tvlan_encapsulated_proto = skb_put(skb, sizeof(__be16));\n\t\t*vlan_encapsulated_proto = htons(ETH_P_IPV6);\n\t}\n\n\tskb_reset_mac_header(skb);\n\tskb_set_network_header(skb, skb->len);\n\tiph = skb_put(skb, sizeof(struct ipv6hdr));\n\n\tskb_set_transport_header(skb, skb->len);\n\tudph = skb_put(skb, sizeof(struct udphdr));\n\tskb_set_queue_mapping(skb, queue_map);\n\tskb->priority = pkt_dev->skb_priority;\n\n\tmemcpy(eth, pkt_dev->hh, 12);\n\t*(__be16 *) &eth[12] = protocol;\n\n\t \n\tdatalen = pkt_dev->cur_pkt_size - 14 -\n\t\t  sizeof(struct ipv6hdr) - sizeof(struct udphdr) -\n\t\t  pkt_dev->pkt_overhead;\n\n\tif (datalen < 0 || datalen < sizeof(struct pktgen_hdr)) {\n\t\tdatalen = sizeof(struct pktgen_hdr);\n\t\tnet_info_ratelimited(\"increased datalen to %d\\n\", datalen);\n\t}\n\n\tudplen = datalen + sizeof(struct udphdr);\n\tudph->source = htons(pkt_dev->cur_udp_src);\n\tudph->dest = htons(pkt_dev->cur_udp_dst);\n\tudph->len = htons(udplen);\n\tudph->check = 0;\n\n\t*(__be32 *) iph = htonl(0x60000000);\t \n\n\tif (pkt_dev->traffic_class) {\n\t\t \n\t\t*(__be32 *)iph |= htonl(0x60000000 | (pkt_dev->traffic_class << 20));\n\t}\n\n\tiph->hop_limit = 32;\n\n\tiph->payload_len = htons(udplen);\n\tiph->nexthdr = IPPROTO_UDP;\n\n\tiph->daddr = pkt_dev->cur_in6_daddr;\n\tiph->saddr = pkt_dev->cur_in6_saddr;\n\n\tskb->protocol = protocol;\n\tskb->dev = odev;\n\tskb->pkt_type = PACKET_HOST;\n\n\tpktgen_finalize_skb(pkt_dev, skb, datalen);\n\n\tif (!(pkt_dev->flags & F_UDPCSUM)) {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t} else if (odev->features & (NETIF_F_HW_CSUM | NETIF_F_IPV6_CSUM)) {\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\tudph->check = ~csum_ipv6_magic(&iph->saddr, &iph->daddr, udplen, IPPROTO_UDP, 0);\n\t} else {\n\t\t__wsum csum = skb_checksum(skb, skb_transport_offset(skb), udplen, 0);\n\n\t\t \n\t\tudph->check = csum_ipv6_magic(&iph->saddr, &iph->daddr, udplen, IPPROTO_UDP, csum);\n\n\t\tif (udph->check == 0)\n\t\t\tudph->check = CSUM_MANGLED_0;\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *fill_packet(struct net_device *odev,\n\t\t\t\t   struct pktgen_dev *pkt_dev)\n{\n\tif (pkt_dev->flags & F_IPV6)\n\t\treturn fill_packet_ipv6(odev, pkt_dev);\n\telse\n\t\treturn fill_packet_ipv4(odev, pkt_dev);\n}\n\nstatic void pktgen_clear_counters(struct pktgen_dev *pkt_dev)\n{\n\tpkt_dev->seq_num = 1;\n\tpkt_dev->idle_acc = 0;\n\tpkt_dev->sofar = 0;\n\tpkt_dev->tx_bytes = 0;\n\tpkt_dev->errors = 0;\n}\n\n \n\nstatic void pktgen_run(struct pktgen_thread *t)\n{\n\tstruct pktgen_dev *pkt_dev;\n\tint started = 0;\n\n\tfunc_enter();\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pkt_dev, &t->if_list, list) {\n\n\t\t \n\t\tpktgen_setup_inject(pkt_dev);\n\n\t\tif (pkt_dev->odev) {\n\t\t\tpktgen_clear_counters(pkt_dev);\n\t\t\tpkt_dev->skb = NULL;\n\t\t\tpkt_dev->started_at = pkt_dev->next_tx = ktime_get();\n\n\t\t\tset_pkt_overhead(pkt_dev);\n\n\t\t\tstrcpy(pkt_dev->result, \"Starting\");\n\t\t\tpkt_dev->running = 1;\t \n\t\t\tstarted++;\n\t\t} else\n\t\t\tstrcpy(pkt_dev->result, \"Error starting\");\n\t}\n\trcu_read_unlock();\n\tif (started)\n\t\tt->control &= ~(T_STOP);\n}\n\nstatic void pktgen_handle_all_threads(struct pktgen_net *pn, u32 flags)\n{\n\tstruct pktgen_thread *t;\n\n\tmutex_lock(&pktgen_thread_lock);\n\n\tlist_for_each_entry(t, &pn->pktgen_threads, th_list)\n\t\tt->control |= (flags);\n\n\tmutex_unlock(&pktgen_thread_lock);\n}\n\nstatic void pktgen_stop_all_threads(struct pktgen_net *pn)\n{\n\tfunc_enter();\n\n\tpktgen_handle_all_threads(pn, T_STOP);\n}\n\nstatic int thread_is_running(const struct pktgen_thread *t)\n{\n\tconst struct pktgen_dev *pkt_dev;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pkt_dev, &t->if_list, list)\n\t\tif (pkt_dev->running) {\n\t\t\trcu_read_unlock();\n\t\t\treturn 1;\n\t\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic int pktgen_wait_thread_run(struct pktgen_thread *t)\n{\n\twhile (thread_is_running(t)) {\n\n\t\t \n\t\tmutex_unlock(&pktgen_thread_lock);\n\t\tmsleep_interruptible(100);\n\t\tmutex_lock(&pktgen_thread_lock);\n\n\t\tif (signal_pending(current))\n\t\t\tgoto signal;\n\t}\n\treturn 1;\nsignal:\n\treturn 0;\n}\n\nstatic int pktgen_wait_all_threads_run(struct pktgen_net *pn)\n{\n\tstruct pktgen_thread *t;\n\tint sig = 1;\n\n\t \n\tif (!try_module_get(THIS_MODULE))\n\t\treturn sig;\n\n\tmutex_lock(&pktgen_thread_lock);\n\n\tlist_for_each_entry(t, &pn->pktgen_threads, th_list) {\n\t\tsig = pktgen_wait_thread_run(t);\n\t\tif (sig == 0)\n\t\t\tbreak;\n\t}\n\n\tif (sig == 0)\n\t\tlist_for_each_entry(t, &pn->pktgen_threads, th_list)\n\t\t\tt->control |= (T_STOP);\n\n\tmutex_unlock(&pktgen_thread_lock);\n\tmodule_put(THIS_MODULE);\n\treturn sig;\n}\n\nstatic void pktgen_run_all_threads(struct pktgen_net *pn)\n{\n\tfunc_enter();\n\n\tpktgen_handle_all_threads(pn, T_RUN);\n\n\t \n\tschedule_timeout_interruptible(msecs_to_jiffies(125));\n\n\tpktgen_wait_all_threads_run(pn);\n}\n\nstatic void pktgen_reset_all_threads(struct pktgen_net *pn)\n{\n\tfunc_enter();\n\n\tpktgen_handle_all_threads(pn, T_REMDEVALL);\n\n\t \n\tschedule_timeout_interruptible(msecs_to_jiffies(125));\n\n\tpktgen_wait_all_threads_run(pn);\n}\n\nstatic void show_results(struct pktgen_dev *pkt_dev, int nr_frags)\n{\n\t__u64 bps, mbps, pps;\n\tchar *p = pkt_dev->result;\n\tktime_t elapsed = ktime_sub(pkt_dev->stopped_at,\n\t\t\t\t    pkt_dev->started_at);\n\tktime_t idle = ns_to_ktime(pkt_dev->idle_acc);\n\n\tp += sprintf(p, \"OK: %llu(c%llu+d%llu) usec, %llu (%dbyte,%dfrags)\\n\",\n\t\t     (unsigned long long)ktime_to_us(elapsed),\n\t\t     (unsigned long long)ktime_to_us(ktime_sub(elapsed, idle)),\n\t\t     (unsigned long long)ktime_to_us(idle),\n\t\t     (unsigned long long)pkt_dev->sofar,\n\t\t     pkt_dev->cur_pkt_size, nr_frags);\n\n\tpps = div64_u64(pkt_dev->sofar * NSEC_PER_SEC,\n\t\t\tktime_to_ns(elapsed));\n\n\tif (pkt_dev->n_imix_entries > 0) {\n\t\tint i;\n\t\tstruct imix_pkt *entry;\n\n\t\tbps = 0;\n\t\tfor (i = 0; i < pkt_dev->n_imix_entries; i++) {\n\t\t\tentry = &pkt_dev->imix_entries[i];\n\t\t\tbps += entry->size * entry->count_so_far;\n\t\t}\n\t\tbps = div64_u64(bps * 8 * NSEC_PER_SEC, ktime_to_ns(elapsed));\n\t} else {\n\t\tbps = pps * 8 * pkt_dev->cur_pkt_size;\n\t}\n\n\tmbps = bps;\n\tdo_div(mbps, 1000000);\n\tp += sprintf(p, \"  %llupps %lluMb/sec (%llubps) errors: %llu\",\n\t\t     (unsigned long long)pps,\n\t\t     (unsigned long long)mbps,\n\t\t     (unsigned long long)bps,\n\t\t     (unsigned long long)pkt_dev->errors);\n}\n\n \nstatic int pktgen_stop_device(struct pktgen_dev *pkt_dev)\n{\n\tint nr_frags = pkt_dev->skb ? skb_shinfo(pkt_dev->skb)->nr_frags : -1;\n\n\tif (!pkt_dev->running) {\n\t\tpr_warn(\"interface: %s is already stopped\\n\",\n\t\t\tpkt_dev->odevname);\n\t\treturn -EINVAL;\n\t}\n\n\tpkt_dev->running = 0;\n\tkfree_skb(pkt_dev->skb);\n\tpkt_dev->skb = NULL;\n\tpkt_dev->stopped_at = ktime_get();\n\n\tshow_results(pkt_dev, nr_frags);\n\n\treturn 0;\n}\n\nstatic struct pktgen_dev *next_to_run(struct pktgen_thread *t)\n{\n\tstruct pktgen_dev *pkt_dev, *best = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pkt_dev, &t->if_list, list) {\n\t\tif (!pkt_dev->running)\n\t\t\tcontinue;\n\t\tif (best == NULL)\n\t\t\tbest = pkt_dev;\n\t\telse if (ktime_compare(pkt_dev->next_tx, best->next_tx) < 0)\n\t\t\tbest = pkt_dev;\n\t}\n\trcu_read_unlock();\n\n\treturn best;\n}\n\nstatic void pktgen_stop(struct pktgen_thread *t)\n{\n\tstruct pktgen_dev *pkt_dev;\n\n\tfunc_enter();\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(pkt_dev, &t->if_list, list) {\n\t\tpktgen_stop_device(pkt_dev);\n\t}\n\n\trcu_read_unlock();\n}\n\n \nstatic void pktgen_rem_one_if(struct pktgen_thread *t)\n{\n\tstruct list_head *q, *n;\n\tstruct pktgen_dev *cur;\n\n\tfunc_enter();\n\n\tlist_for_each_safe(q, n, &t->if_list) {\n\t\tcur = list_entry(q, struct pktgen_dev, list);\n\n\t\tif (!cur->removal_mark)\n\t\t\tcontinue;\n\n\t\tkfree_skb(cur->skb);\n\t\tcur->skb = NULL;\n\n\t\tpktgen_remove_device(t, cur);\n\n\t\tbreak;\n\t}\n}\n\nstatic void pktgen_rem_all_ifs(struct pktgen_thread *t)\n{\n\tstruct list_head *q, *n;\n\tstruct pktgen_dev *cur;\n\n\tfunc_enter();\n\n\t \n\n\tlist_for_each_safe(q, n, &t->if_list) {\n\t\tcur = list_entry(q, struct pktgen_dev, list);\n\n\t\tkfree_skb(cur->skb);\n\t\tcur->skb = NULL;\n\n\t\tpktgen_remove_device(t, cur);\n\t}\n}\n\nstatic void pktgen_rem_thread(struct pktgen_thread *t)\n{\n\t \n\tremove_proc_entry(t->tsk->comm, t->net->proc_dir);\n}\n\nstatic void pktgen_resched(struct pktgen_dev *pkt_dev)\n{\n\tktime_t idle_start = ktime_get();\n\tschedule();\n\tpkt_dev->idle_acc += ktime_to_ns(ktime_sub(ktime_get(), idle_start));\n}\n\nstatic void pktgen_wait_for_skb(struct pktgen_dev *pkt_dev)\n{\n\tktime_t idle_start = ktime_get();\n\n\twhile (refcount_read(&(pkt_dev->skb->users)) != 1) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tif (need_resched())\n\t\t\tpktgen_resched(pkt_dev);\n\t\telse\n\t\t\tcpu_relax();\n\t}\n\tpkt_dev->idle_acc += ktime_to_ns(ktime_sub(ktime_get(), idle_start));\n}\n\nstatic void pktgen_xmit(struct pktgen_dev *pkt_dev)\n{\n\tunsigned int burst = READ_ONCE(pkt_dev->burst);\n\tstruct net_device *odev = pkt_dev->odev;\n\tstruct netdev_queue *txq;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\t \n\tif (unlikely(!netif_running(odev) || !netif_carrier_ok(odev))) {\n\t\tpktgen_stop_device(pkt_dev);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(pkt_dev->delay == ULLONG_MAX)) {\n\t\tpkt_dev->next_tx = ktime_add_ns(ktime_get(), ULONG_MAX);\n\t\treturn;\n\t}\n\n\t \n\tif (!pkt_dev->skb || (pkt_dev->last_ok &&\n\t\t\t      ++pkt_dev->clone_count >= pkt_dev->clone_skb)) {\n\t\t \n\t\tkfree_skb(pkt_dev->skb);\n\n\t\tpkt_dev->skb = fill_packet(odev, pkt_dev);\n\t\tif (pkt_dev->skb == NULL) {\n\t\t\tpr_err(\"ERROR: couldn't allocate skb in fill_packet\\n\");\n\t\t\tschedule();\n\t\t\tpkt_dev->clone_count--;\t \n\t\t\treturn;\n\t\t}\n\t\tpkt_dev->last_pkt_size = pkt_dev->skb->len;\n\t\tpkt_dev->clone_count = 0;\t \n\t}\n\n\tif (pkt_dev->delay && pkt_dev->last_ok)\n\t\tspin(pkt_dev, pkt_dev->next_tx);\n\n\tif (pkt_dev->xmit_mode == M_NETIF_RECEIVE) {\n\t\tskb = pkt_dev->skb;\n\t\tskb->protocol = eth_type_trans(skb, skb->dev);\n\t\trefcount_add(burst, &skb->users);\n\t\tlocal_bh_disable();\n\t\tdo {\n\t\t\tret = netif_receive_skb(skb);\n\t\t\tif (ret == NET_RX_DROP)\n\t\t\t\tpkt_dev->errors++;\n\t\t\tpkt_dev->sofar++;\n\t\t\tpkt_dev->seq_num++;\n\t\t\tif (refcount_read(&skb->users) != burst) {\n\t\t\t\t \n\t\t\t\tWARN_ON(refcount_sub_and_test(burst - 1, &skb->users));\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tskb_reset_redirect(skb);\n\t\t} while (--burst > 0);\n\t\tgoto out;  \n\t} else if (pkt_dev->xmit_mode == M_QUEUE_XMIT) {\n\t\tlocal_bh_disable();\n\t\trefcount_inc(&pkt_dev->skb->users);\n\n\t\tret = dev_queue_xmit(pkt_dev->skb);\n\t\tswitch (ret) {\n\t\tcase NET_XMIT_SUCCESS:\n\t\t\tpkt_dev->sofar++;\n\t\t\tpkt_dev->seq_num++;\n\t\t\tpkt_dev->tx_bytes += pkt_dev->last_pkt_size;\n\t\t\tbreak;\n\t\tcase NET_XMIT_DROP:\n\t\tcase NET_XMIT_CN:\n\t\t \n\t\tcase NETDEV_TX_BUSY:\n\t\t \n\t\tdefault:\n\t\t\tpkt_dev->errors++;\n\t\t\tnet_info_ratelimited(\"%s xmit error: %d\\n\",\n\t\t\t\t\t     pkt_dev->odevname, ret);\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\ttxq = skb_get_tx_queue(odev, pkt_dev->skb);\n\n\tlocal_bh_disable();\n\n\tHARD_TX_LOCK(odev, txq, smp_processor_id());\n\n\tif (unlikely(netif_xmit_frozen_or_drv_stopped(txq))) {\n\t\tpkt_dev->last_ok = 0;\n\t\tgoto unlock;\n\t}\n\trefcount_add(burst, &pkt_dev->skb->users);\n\nxmit_more:\n\tret = netdev_start_xmit(pkt_dev->skb, odev, txq, --burst > 0);\n\n\tswitch (ret) {\n\tcase NETDEV_TX_OK:\n\t\tpkt_dev->last_ok = 1;\n\t\tpkt_dev->sofar++;\n\t\tpkt_dev->seq_num++;\n\t\tpkt_dev->tx_bytes += pkt_dev->last_pkt_size;\n\t\tif (burst > 0 && !netif_xmit_frozen_or_drv_stopped(txq))\n\t\t\tgoto xmit_more;\n\t\tbreak;\n\tcase NET_XMIT_DROP:\n\tcase NET_XMIT_CN:\n\t\t \n\t\tpkt_dev->errors++;\n\t\tbreak;\n\tdefault:  \n\t\tnet_info_ratelimited(\"%s xmit error: %d\\n\",\n\t\t\t\t     pkt_dev->odevname, ret);\n\t\tpkt_dev->errors++;\n\t\tfallthrough;\n\tcase NETDEV_TX_BUSY:\n\t\t \n\t\trefcount_dec(&(pkt_dev->skb->users));\n\t\tpkt_dev->last_ok = 0;\n\t}\n\tif (unlikely(burst))\n\t\tWARN_ON(refcount_sub_and_test(burst, &pkt_dev->skb->users));\nunlock:\n\tHARD_TX_UNLOCK(odev, txq);\n\nout:\n\tlocal_bh_enable();\n\n\t \n\tif ((pkt_dev->count != 0) && (pkt_dev->sofar >= pkt_dev->count)) {\n\t\tpktgen_wait_for_skb(pkt_dev);\n\n\t\t \n\t\tpktgen_stop_device(pkt_dev);\n\t}\n}\n\n \n\nstatic int pktgen_thread_worker(void *arg)\n{\n\tstruct pktgen_thread *t = arg;\n\tstruct pktgen_dev *pkt_dev = NULL;\n\tint cpu = t->cpu;\n\n\tWARN_ON(smp_processor_id() != cpu);\n\n\tinit_waitqueue_head(&t->queue);\n\tcomplete(&t->start_done);\n\n\tpr_debug(\"starting pktgen/%d:  pid=%d\\n\", cpu, task_pid_nr(current));\n\n\tset_freezable();\n\n\twhile (!kthread_should_stop()) {\n\t\tpkt_dev = next_to_run(t);\n\n\t\tif (unlikely(!pkt_dev && t->control == 0)) {\n\t\t\tif (t->net->pktgen_exiting)\n\t\t\t\tbreak;\n\t\t\twait_event_interruptible_timeout(t->queue,\n\t\t\t\t\t\t\t t->control != 0,\n\t\t\t\t\t\t\t HZ/10);\n\t\t\ttry_to_freeze();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (likely(pkt_dev)) {\n\t\t\tpktgen_xmit(pkt_dev);\n\n\t\t\tif (need_resched())\n\t\t\t\tpktgen_resched(pkt_dev);\n\t\t\telse\n\t\t\t\tcpu_relax();\n\t\t}\n\n\t\tif (t->control & T_STOP) {\n\t\t\tpktgen_stop(t);\n\t\t\tt->control &= ~(T_STOP);\n\t\t}\n\n\t\tif (t->control & T_RUN) {\n\t\t\tpktgen_run(t);\n\t\t\tt->control &= ~(T_RUN);\n\t\t}\n\n\t\tif (t->control & T_REMDEVALL) {\n\t\t\tpktgen_rem_all_ifs(t);\n\t\t\tt->control &= ~(T_REMDEVALL);\n\t\t}\n\n\t\tif (t->control & T_REMDEV) {\n\t\t\tpktgen_rem_one_if(t);\n\t\t\tt->control &= ~(T_REMDEV);\n\t\t}\n\n\t\ttry_to_freeze();\n\t}\n\n\tpr_debug(\"%s stopping all device\\n\", t->tsk->comm);\n\tpktgen_stop(t);\n\n\tpr_debug(\"%s removing all device\\n\", t->tsk->comm);\n\tpktgen_rem_all_ifs(t);\n\n\tpr_debug(\"%s removing thread\\n\", t->tsk->comm);\n\tpktgen_rem_thread(t);\n\n\treturn 0;\n}\n\nstatic struct pktgen_dev *pktgen_find_dev(struct pktgen_thread *t,\n\t\t\t\t\t  const char *ifname, bool exact)\n{\n\tstruct pktgen_dev *p, *pkt_dev = NULL;\n\tsize_t len = strlen(ifname);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(p, &t->if_list, list)\n\t\tif (strncmp(p->odevname, ifname, len) == 0) {\n\t\t\tif (p->odevname[len]) {\n\t\t\t\tif (exact || p->odevname[len] != '@')\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpkt_dev = p;\n\t\t\tbreak;\n\t\t}\n\n\trcu_read_unlock();\n\tpr_debug(\"find_dev(%s) returning %p\\n\", ifname, pkt_dev);\n\treturn pkt_dev;\n}\n\n \n\nstatic int add_dev_to_thread(struct pktgen_thread *t,\n\t\t\t     struct pktgen_dev *pkt_dev)\n{\n\tint rv = 0;\n\n\t \n\tif_lock(t);\n\n\tif (pkt_dev->pg_thread) {\n\t\tpr_err(\"ERROR: already assigned to a thread\\n\");\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tpkt_dev->running = 0;\n\tpkt_dev->pg_thread = t;\n\tlist_add_rcu(&pkt_dev->list, &t->if_list);\n\nout:\n\tif_unlock(t);\n\treturn rv;\n}\n\n \n\nstatic int pktgen_add_device(struct pktgen_thread *t, const char *ifname)\n{\n\tstruct pktgen_dev *pkt_dev;\n\tint err;\n\tint node = cpu_to_node(t->cpu);\n\n\t \n\n\tpkt_dev = __pktgen_NN_threads(t->net, ifname, FIND);\n\tif (pkt_dev) {\n\t\tpr_err(\"ERROR: interface already used\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tpkt_dev = kzalloc_node(sizeof(struct pktgen_dev), GFP_KERNEL, node);\n\tif (!pkt_dev)\n\t\treturn -ENOMEM;\n\n\tstrcpy(pkt_dev->odevname, ifname);\n\tpkt_dev->flows = vzalloc_node(array_size(MAX_CFLOWS,\n\t\t\t\t\t\t sizeof(struct flow_state)),\n\t\t\t\t      node);\n\tif (pkt_dev->flows == NULL) {\n\t\tkfree(pkt_dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tpkt_dev->removal_mark = 0;\n\tpkt_dev->nfrags = 0;\n\tpkt_dev->delay = pg_delay_d;\n\tpkt_dev->count = pg_count_d;\n\tpkt_dev->sofar = 0;\n\tpkt_dev->udp_src_min = 9;\t \n\tpkt_dev->udp_src_max = 9;\n\tpkt_dev->udp_dst_min = 9;\n\tpkt_dev->udp_dst_max = 9;\n\tpkt_dev->vlan_p = 0;\n\tpkt_dev->vlan_cfi = 0;\n\tpkt_dev->vlan_id = 0xffff;\n\tpkt_dev->svlan_p = 0;\n\tpkt_dev->svlan_cfi = 0;\n\tpkt_dev->svlan_id = 0xffff;\n\tpkt_dev->burst = 1;\n\tpkt_dev->node = NUMA_NO_NODE;\n\n\terr = pktgen_setup_dev(t->net, pkt_dev, ifname);\n\tif (err)\n\t\tgoto out1;\n\tif (pkt_dev->odev->priv_flags & IFF_TX_SKB_SHARING)\n\t\tpkt_dev->clone_skb = pg_clone_skb_d;\n\n\tpkt_dev->entry = proc_create_data(ifname, 0600, t->net->proc_dir,\n\t\t\t\t\t  &pktgen_if_proc_ops, pkt_dev);\n\tif (!pkt_dev->entry) {\n\t\tpr_err(\"cannot create %s/%s procfs entry\\n\",\n\t\t       PG_PROC_DIR, ifname);\n\t\terr = -EINVAL;\n\t\tgoto out2;\n\t}\n#ifdef CONFIG_XFRM\n\tpkt_dev->ipsmode = XFRM_MODE_TRANSPORT;\n\tpkt_dev->ipsproto = IPPROTO_ESP;\n\n\t \n\tpkt_dev->dstops.family = AF_INET;\n\tpkt_dev->xdst.u.dst.dev = pkt_dev->odev;\n\tdst_init_metrics(&pkt_dev->xdst.u.dst, pktgen_dst_metrics, false);\n\tpkt_dev->xdst.child = &pkt_dev->xdst.u.dst;\n\tpkt_dev->xdst.u.dst.ops = &pkt_dev->dstops;\n#endif\n\n\treturn add_dev_to_thread(t, pkt_dev);\nout2:\n\tnetdev_put(pkt_dev->odev, &pkt_dev->dev_tracker);\nout1:\n#ifdef CONFIG_XFRM\n\tfree_SAs(pkt_dev);\n#endif\n\tvfree(pkt_dev->flows);\n\tkfree(pkt_dev);\n\treturn err;\n}\n\nstatic int __net_init pktgen_create_thread(int cpu, struct pktgen_net *pn)\n{\n\tstruct pktgen_thread *t;\n\tstruct proc_dir_entry *pe;\n\tstruct task_struct *p;\n\n\tt = kzalloc_node(sizeof(struct pktgen_thread), GFP_KERNEL,\n\t\t\t cpu_to_node(cpu));\n\tif (!t) {\n\t\tpr_err(\"ERROR: out of memory, can't create new thread\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&t->if_lock);\n\tt->cpu = cpu;\n\n\tINIT_LIST_HEAD(&t->if_list);\n\n\tlist_add_tail(&t->th_list, &pn->pktgen_threads);\n\tinit_completion(&t->start_done);\n\n\tp = kthread_create_on_node(pktgen_thread_worker,\n\t\t\t\t   t,\n\t\t\t\t   cpu_to_node(cpu),\n\t\t\t\t   \"kpktgend_%d\", cpu);\n\tif (IS_ERR(p)) {\n\t\tpr_err(\"kthread_create_on_node() failed for cpu %d\\n\", t->cpu);\n\t\tlist_del(&t->th_list);\n\t\tkfree(t);\n\t\treturn PTR_ERR(p);\n\t}\n\tkthread_bind(p, cpu);\n\tt->tsk = p;\n\n\tpe = proc_create_data(t->tsk->comm, 0600, pn->proc_dir,\n\t\t\t      &pktgen_thread_proc_ops, t);\n\tif (!pe) {\n\t\tpr_err(\"cannot create %s/%s procfs entry\\n\",\n\t\t       PG_PROC_DIR, t->tsk->comm);\n\t\tkthread_stop(p);\n\t\tlist_del(&t->th_list);\n\t\tkfree(t);\n\t\treturn -EINVAL;\n\t}\n\n\tt->net = pn;\n\tget_task_struct(p);\n\twake_up_process(p);\n\twait_for_completion(&t->start_done);\n\n\treturn 0;\n}\n\n \nstatic void _rem_dev_from_if_list(struct pktgen_thread *t,\n\t\t\t\t  struct pktgen_dev *pkt_dev)\n{\n\tstruct list_head *q, *n;\n\tstruct pktgen_dev *p;\n\n\tif_lock(t);\n\tlist_for_each_safe(q, n, &t->if_list) {\n\t\tp = list_entry(q, struct pktgen_dev, list);\n\t\tif (p == pkt_dev)\n\t\t\tlist_del_rcu(&p->list);\n\t}\n\tif_unlock(t);\n}\n\nstatic int pktgen_remove_device(struct pktgen_thread *t,\n\t\t\t\tstruct pktgen_dev *pkt_dev)\n{\n\tpr_debug(\"remove_device pkt_dev=%p\\n\", pkt_dev);\n\n\tif (pkt_dev->running) {\n\t\tpr_warn(\"WARNING: trying to remove a running interface, stopping it now\\n\");\n\t\tpktgen_stop_device(pkt_dev);\n\t}\n\n\t \n\n\tif (pkt_dev->odev) {\n\t\tnetdev_put(pkt_dev->odev, &pkt_dev->dev_tracker);\n\t\tpkt_dev->odev = NULL;\n\t}\n\n\t \n\tproc_remove(pkt_dev->entry);\n\n\t \n\t_rem_dev_from_if_list(t, pkt_dev);\n\n#ifdef CONFIG_XFRM\n\tfree_SAs(pkt_dev);\n#endif\n\tvfree(pkt_dev->flows);\n\tif (pkt_dev->page)\n\t\tput_page(pkt_dev->page);\n\tkfree_rcu(pkt_dev, rcu);\n\treturn 0;\n}\n\nstatic int __net_init pg_net_init(struct net *net)\n{\n\tstruct pktgen_net *pn = net_generic(net, pg_net_id);\n\tstruct proc_dir_entry *pe;\n\tint cpu, ret = 0;\n\n\tpn->net = net;\n\tINIT_LIST_HEAD(&pn->pktgen_threads);\n\tpn->pktgen_exiting = false;\n\tpn->proc_dir = proc_mkdir(PG_PROC_DIR, pn->net->proc_net);\n\tif (!pn->proc_dir) {\n\t\tpr_warn(\"cannot create /proc/net/%s\\n\", PG_PROC_DIR);\n\t\treturn -ENODEV;\n\t}\n\tpe = proc_create(PGCTRL, 0600, pn->proc_dir, &pktgen_proc_ops);\n\tif (pe == NULL) {\n\t\tpr_err(\"cannot create %s procfs entry\\n\", PGCTRL);\n\t\tret = -EINVAL;\n\t\tgoto remove;\n\t}\n\n\tfor_each_online_cpu(cpu) {\n\t\tint err;\n\n\t\terr = pktgen_create_thread(cpu, pn);\n\t\tif (err)\n\t\t\tpr_warn(\"Cannot create thread for cpu %d (%d)\\n\",\n\t\t\t\t   cpu, err);\n\t}\n\n\tif (list_empty(&pn->pktgen_threads)) {\n\t\tpr_err(\"Initialization failed for all threads\\n\");\n\t\tret = -ENODEV;\n\t\tgoto remove_entry;\n\t}\n\n\treturn 0;\n\nremove_entry:\n\tremove_proc_entry(PGCTRL, pn->proc_dir);\nremove:\n\tremove_proc_entry(PG_PROC_DIR, pn->net->proc_net);\n\treturn ret;\n}\n\nstatic void __net_exit pg_net_exit(struct net *net)\n{\n\tstruct pktgen_net *pn = net_generic(net, pg_net_id);\n\tstruct pktgen_thread *t;\n\tstruct list_head *q, *n;\n\tLIST_HEAD(list);\n\n\t \n\tpn->pktgen_exiting = true;\n\n\tmutex_lock(&pktgen_thread_lock);\n\tlist_splice_init(&pn->pktgen_threads, &list);\n\tmutex_unlock(&pktgen_thread_lock);\n\n\tlist_for_each_safe(q, n, &list) {\n\t\tt = list_entry(q, struct pktgen_thread, th_list);\n\t\tlist_del(&t->th_list);\n\t\tkthread_stop(t->tsk);\n\t\tput_task_struct(t->tsk);\n\t\tkfree(t);\n\t}\n\n\tremove_proc_entry(PGCTRL, pn->proc_dir);\n\tremove_proc_entry(PG_PROC_DIR, pn->net->proc_net);\n}\n\nstatic struct pernet_operations pg_net_ops = {\n\t.init = pg_net_init,\n\t.exit = pg_net_exit,\n\t.id   = &pg_net_id,\n\t.size = sizeof(struct pktgen_net),\n};\n\nstatic int __init pg_init(void)\n{\n\tint ret = 0;\n\n\tpr_info(\"%s\", version);\n\tret = register_pernet_subsys(&pg_net_ops);\n\tif (ret)\n\t\treturn ret;\n\tret = register_netdevice_notifier(&pktgen_notifier_block);\n\tif (ret)\n\t\tunregister_pernet_subsys(&pg_net_ops);\n\n\treturn ret;\n}\n\nstatic void __exit pg_cleanup(void)\n{\n\tunregister_netdevice_notifier(&pktgen_notifier_block);\n\tunregister_pernet_subsys(&pg_net_ops);\n\t \n}\n\nmodule_init(pg_init);\nmodule_exit(pg_cleanup);\n\nMODULE_AUTHOR(\"Robert Olsson <robert.olsson@its.uu.se>\");\nMODULE_DESCRIPTION(\"Packet Generator tool\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(VERSION);\nmodule_param(pg_count_d, int, 0);\nMODULE_PARM_DESC(pg_count_d, \"Default number of packets to inject\");\nmodule_param(pg_delay_d, int, 0);\nMODULE_PARM_DESC(pg_delay_d, \"Default delay between packets (nanoseconds)\");\nmodule_param(pg_clone_skb_d, int, 0);\nMODULE_PARM_DESC(pg_clone_skb_d, \"Default number of copies of the same packet\");\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Enable debugging of pktgen module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}