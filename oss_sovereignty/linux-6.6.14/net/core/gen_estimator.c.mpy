{
  "module_name": "gen_estimator.c",
  "hash_id": "995426afbabf36637f9ec9b2643372ab85858a2abd4034744b19710b96b1227e",
  "original_prompt": "Ingested from linux-6.6.14/net/core/gen_estimator.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/seqlock.h>\n#include <net/sock.h>\n#include <net/gen_stats.h>\n\n \n\nstruct net_rate_estimator {\n\tstruct gnet_stats_basic_sync\t*bstats;\n\tspinlock_t\t\t*stats_lock;\n\tbool\t\t\trunning;\n\tstruct gnet_stats_basic_sync __percpu *cpu_bstats;\n\tu8\t\t\tewma_log;\n\tu8\t\t\tintvl_log;  \n\n\tseqcount_t\t\tseq;\n\tu64\t\t\tlast_packets;\n\tu64\t\t\tlast_bytes;\n\n\tu64\t\t\tavpps;\n\tu64\t\t\tavbps;\n\n\tunsigned long           next_jiffies;\n\tstruct timer_list       timer;\n\tstruct rcu_head\t\trcu;\n};\n\nstatic void est_fetch_counters(struct net_rate_estimator *e,\n\t\t\t       struct gnet_stats_basic_sync *b)\n{\n\tgnet_stats_basic_sync_init(b);\n\tif (e->stats_lock)\n\t\tspin_lock(e->stats_lock);\n\n\tgnet_stats_add_basic(b, e->cpu_bstats, e->bstats, e->running);\n\n\tif (e->stats_lock)\n\t\tspin_unlock(e->stats_lock);\n\n}\n\nstatic void est_timer(struct timer_list *t)\n{\n\tstruct net_rate_estimator *est = from_timer(est, t, timer);\n\tstruct gnet_stats_basic_sync b;\n\tu64 b_bytes, b_packets;\n\tu64 rate, brate;\n\n\test_fetch_counters(est, &b);\n\tb_bytes = u64_stats_read(&b.bytes);\n\tb_packets = u64_stats_read(&b.packets);\n\n\tbrate = (b_bytes - est->last_bytes) << (10 - est->intvl_log);\n\tbrate = (brate >> est->ewma_log) - (est->avbps >> est->ewma_log);\n\n\trate = (b_packets - est->last_packets) << (10 - est->intvl_log);\n\trate = (rate >> est->ewma_log) - (est->avpps >> est->ewma_log);\n\n\twrite_seqcount_begin(&est->seq);\n\test->avbps += brate;\n\test->avpps += rate;\n\twrite_seqcount_end(&est->seq);\n\n\test->last_bytes = b_bytes;\n\test->last_packets = b_packets;\n\n\test->next_jiffies += ((HZ/4) << est->intvl_log);\n\n\tif (unlikely(time_after_eq(jiffies, est->next_jiffies))) {\n\t\t \n\t\test->next_jiffies = jiffies + 1;\n\t}\n\tmod_timer(&est->timer, est->next_jiffies);\n}\n\n \nint gen_new_estimator(struct gnet_stats_basic_sync *bstats,\n\t\t      struct gnet_stats_basic_sync __percpu *cpu_bstats,\n\t\t      struct net_rate_estimator __rcu **rate_est,\n\t\t      spinlock_t *lock,\n\t\t      bool running,\n\t\t      struct nlattr *opt)\n{\n\tstruct gnet_estimator *parm = nla_data(opt);\n\tstruct net_rate_estimator *old, *est;\n\tstruct gnet_stats_basic_sync b;\n\tint intvl_log;\n\n\tif (nla_len(opt) < sizeof(*parm))\n\t\treturn -EINVAL;\n\n\t \n\tif (parm->interval < -2 || parm->interval > 3)\n\t\treturn -EINVAL;\n\n\tif (parm->ewma_log == 0 || parm->ewma_log >= 31)\n\t\treturn -EINVAL;\n\n\test = kzalloc(sizeof(*est), GFP_KERNEL);\n\tif (!est)\n\t\treturn -ENOBUFS;\n\n\tseqcount_init(&est->seq);\n\tintvl_log = parm->interval + 2;\n\test->bstats = bstats;\n\test->stats_lock = lock;\n\test->running  = running;\n\test->ewma_log = parm->ewma_log;\n\test->intvl_log = intvl_log;\n\test->cpu_bstats = cpu_bstats;\n\n\tif (lock)\n\t\tlocal_bh_disable();\n\test_fetch_counters(est, &b);\n\tif (lock)\n\t\tlocal_bh_enable();\n\test->last_bytes = u64_stats_read(&b.bytes);\n\test->last_packets = u64_stats_read(&b.packets);\n\n\tif (lock)\n\t\tspin_lock_bh(lock);\n\told = rcu_dereference_protected(*rate_est, 1);\n\tif (old) {\n\t\tdel_timer_sync(&old->timer);\n\t\test->avbps = old->avbps;\n\t\test->avpps = old->avpps;\n\t}\n\n\test->next_jiffies = jiffies + ((HZ/4) << intvl_log);\n\ttimer_setup(&est->timer, est_timer, 0);\n\tmod_timer(&est->timer, est->next_jiffies);\n\n\trcu_assign_pointer(*rate_est, est);\n\tif (lock)\n\t\tspin_unlock_bh(lock);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\treturn 0;\n}\nEXPORT_SYMBOL(gen_new_estimator);\n\n \nvoid gen_kill_estimator(struct net_rate_estimator __rcu **rate_est)\n{\n\tstruct net_rate_estimator *est;\n\n\test = xchg((__force struct net_rate_estimator **)rate_est, NULL);\n\tif (est) {\n\t\ttimer_shutdown_sync(&est->timer);\n\t\tkfree_rcu(est, rcu);\n\t}\n}\nEXPORT_SYMBOL(gen_kill_estimator);\n\n \nint gen_replace_estimator(struct gnet_stats_basic_sync *bstats,\n\t\t\t  struct gnet_stats_basic_sync __percpu *cpu_bstats,\n\t\t\t  struct net_rate_estimator __rcu **rate_est,\n\t\t\t  spinlock_t *lock,\n\t\t\t  bool running, struct nlattr *opt)\n{\n\treturn gen_new_estimator(bstats, cpu_bstats, rate_est,\n\t\t\t\t lock, running, opt);\n}\nEXPORT_SYMBOL(gen_replace_estimator);\n\n \nbool gen_estimator_active(struct net_rate_estimator __rcu **rate_est)\n{\n\treturn !!rcu_access_pointer(*rate_est);\n}\nEXPORT_SYMBOL(gen_estimator_active);\n\nbool gen_estimator_read(struct net_rate_estimator __rcu **rate_est,\n\t\t\tstruct gnet_stats_rate_est64 *sample)\n{\n\tstruct net_rate_estimator *est;\n\tunsigned seq;\n\n\trcu_read_lock();\n\test = rcu_dereference(*rate_est);\n\tif (!est) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&est->seq);\n\t\tsample->bps = est->avbps >> 8;\n\t\tsample->pps = est->avpps >> 8;\n\t} while (read_seqcount_retry(&est->seq, seq));\n\n\trcu_read_unlock();\n\treturn true;\n}\nEXPORT_SYMBOL(gen_estimator_read);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}