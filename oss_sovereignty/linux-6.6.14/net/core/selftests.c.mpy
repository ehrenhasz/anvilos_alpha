{
  "module_name": "selftests.c",
  "hash_id": "b95810a85b898228e59efce6534476f7dd61466b094840192c0fc0600e3bff97",
  "original_prompt": "Ingested from linux-6.6.14/net/core/selftests.c",
  "human_readable_source": "\n \n\n#include <linux/phy.h>\n#include <net/selftests.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n\nstruct net_packet_attrs {\n\tconst unsigned char *src;\n\tconst unsigned char *dst;\n\tu32 ip_src;\n\tu32 ip_dst;\n\tbool tcp;\n\tu16 sport;\n\tu16 dport;\n\tint timeout;\n\tint size;\n\tint max_size;\n\tu8 id;\n\tu16 queue_mapping;\n};\n\nstruct net_test_priv {\n\tstruct net_packet_attrs *packet;\n\tstruct packet_type pt;\n\tstruct completion comp;\n\tint double_vlan;\n\tint vlan_id;\n\tint ok;\n};\n\nstruct netsfhdr {\n\t__be32 version;\n\t__be64 magic;\n\tu8 id;\n} __packed;\n\nstatic u8 net_test_next_id;\n\n#define NET_TEST_PKT_SIZE (sizeof(struct ethhdr) + sizeof(struct iphdr) + \\\n\t\t\t   sizeof(struct netsfhdr))\n#define NET_TEST_PKT_MAGIC\t0xdeadcafecafedeadULL\n#define NET_LB_TIMEOUT\t\tmsecs_to_jiffies(200)\n\nstatic struct sk_buff *net_test_get_skb(struct net_device *ndev,\n\t\t\t\t\tstruct net_packet_attrs *attr)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct udphdr *uhdr = NULL;\n\tstruct tcphdr *thdr = NULL;\n\tstruct netsfhdr *shdr;\n\tstruct ethhdr *ehdr;\n\tstruct iphdr *ihdr;\n\tint iplen, size;\n\n\tsize = attr->size + NET_TEST_PKT_SIZE;\n\n\tif (attr->tcp)\n\t\tsize += sizeof(struct tcphdr);\n\telse\n\t\tsize += sizeof(struct udphdr);\n\n\tif (attr->max_size && attr->max_size > size)\n\t\tsize = attr->max_size;\n\n\tskb = netdev_alloc_skb(ndev, size);\n\tif (!skb)\n\t\treturn NULL;\n\n\tprefetchw(skb->data);\n\n\tehdr = skb_push(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\n\tskb_set_network_header(skb, skb->len);\n\tihdr = skb_put(skb, sizeof(*ihdr));\n\n\tskb_set_transport_header(skb, skb->len);\n\tif (attr->tcp)\n\t\tthdr = skb_put(skb, sizeof(*thdr));\n\telse\n\t\tuhdr = skb_put(skb, sizeof(*uhdr));\n\n\teth_zero_addr(ehdr->h_dest);\n\n\tif (attr->src)\n\t\tether_addr_copy(ehdr->h_source, attr->src);\n\tif (attr->dst)\n\t\tether_addr_copy(ehdr->h_dest, attr->dst);\n\n\tehdr->h_proto = htons(ETH_P_IP);\n\n\tif (attr->tcp) {\n\t\tthdr->source = htons(attr->sport);\n\t\tthdr->dest = htons(attr->dport);\n\t\tthdr->doff = sizeof(struct tcphdr) / 4;\n\t\tthdr->check = 0;\n\t} else {\n\t\tuhdr->source = htons(attr->sport);\n\t\tuhdr->dest = htons(attr->dport);\n\t\tuhdr->len = htons(sizeof(*shdr) + sizeof(*uhdr) + attr->size);\n\t\tif (attr->max_size)\n\t\t\tuhdr->len = htons(attr->max_size -\n\t\t\t\t\t  (sizeof(*ihdr) + sizeof(*ehdr)));\n\t\tuhdr->check = 0;\n\t}\n\n\tihdr->ihl = 5;\n\tihdr->ttl = 32;\n\tihdr->version = 4;\n\tif (attr->tcp)\n\t\tihdr->protocol = IPPROTO_TCP;\n\telse\n\t\tihdr->protocol = IPPROTO_UDP;\n\tiplen = sizeof(*ihdr) + sizeof(*shdr) + attr->size;\n\tif (attr->tcp)\n\t\tiplen += sizeof(*thdr);\n\telse\n\t\tiplen += sizeof(*uhdr);\n\n\tif (attr->max_size)\n\t\tiplen = attr->max_size - sizeof(*ehdr);\n\n\tihdr->tot_len = htons(iplen);\n\tihdr->frag_off = 0;\n\tihdr->saddr = htonl(attr->ip_src);\n\tihdr->daddr = htonl(attr->ip_dst);\n\tihdr->tos = 0;\n\tihdr->id = 0;\n\tip_send_check(ihdr);\n\n\tshdr = skb_put(skb, sizeof(*shdr));\n\tshdr->version = 0;\n\tshdr->magic = cpu_to_be64(NET_TEST_PKT_MAGIC);\n\tattr->id = net_test_next_id;\n\tshdr->id = net_test_next_id++;\n\n\tif (attr->size)\n\t\tskb_put(skb, attr->size);\n\tif (attr->max_size && attr->max_size > skb->len)\n\t\tskb_put(skb, attr->max_size - skb->len);\n\n\tskb->csum = 0;\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\tif (attr->tcp) {\n\t\tthdr->check = ~tcp_v4_check(skb->len, ihdr->saddr,\n\t\t\t\t\t    ihdr->daddr, 0);\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct tcphdr, check);\n\t} else {\n\t\tudp4_hwcsum(skb, ihdr->saddr, ihdr->daddr);\n\t}\n\n\tskb->protocol = htons(ETH_P_IP);\n\tskb->pkt_type = PACKET_HOST;\n\tskb->dev = ndev;\n\n\treturn skb;\n}\n\nstatic int net_test_loopback_validate(struct sk_buff *skb,\n\t\t\t\t      struct net_device *ndev,\n\t\t\t\t      struct packet_type *pt,\n\t\t\t\t      struct net_device *orig_ndev)\n{\n\tstruct net_test_priv *tpriv = pt->af_packet_priv;\n\tconst unsigned char *src = tpriv->packet->src;\n\tconst unsigned char *dst = tpriv->packet->dst;\n\tstruct netsfhdr *shdr;\n\tstruct ethhdr *ehdr;\n\tstruct udphdr *uhdr;\n\tstruct tcphdr *thdr;\n\tstruct iphdr *ihdr;\n\n\tskb = skb_unshare(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out;\n\n\tif (skb_linearize(skb))\n\t\tgoto out;\n\tif (skb_headlen(skb) < (NET_TEST_PKT_SIZE - ETH_HLEN))\n\t\tgoto out;\n\n\tehdr = (struct ethhdr *)skb_mac_header(skb);\n\tif (dst) {\n\t\tif (!ether_addr_equal_unaligned(ehdr->h_dest, dst))\n\t\t\tgoto out;\n\t}\n\n\tif (src) {\n\t\tif (!ether_addr_equal_unaligned(ehdr->h_source, src))\n\t\t\tgoto out;\n\t}\n\n\tihdr = ip_hdr(skb);\n\tif (tpriv->double_vlan)\n\t\tihdr = (struct iphdr *)(skb_network_header(skb) + 4);\n\n\tif (tpriv->packet->tcp) {\n\t\tif (ihdr->protocol != IPPROTO_TCP)\n\t\t\tgoto out;\n\n\t\tthdr = (struct tcphdr *)((u8 *)ihdr + 4 * ihdr->ihl);\n\t\tif (thdr->dest != htons(tpriv->packet->dport))\n\t\t\tgoto out;\n\n\t\tshdr = (struct netsfhdr *)((u8 *)thdr + sizeof(*thdr));\n\t} else {\n\t\tif (ihdr->protocol != IPPROTO_UDP)\n\t\t\tgoto out;\n\n\t\tuhdr = (struct udphdr *)((u8 *)ihdr + 4 * ihdr->ihl);\n\t\tif (uhdr->dest != htons(tpriv->packet->dport))\n\t\t\tgoto out;\n\n\t\tshdr = (struct netsfhdr *)((u8 *)uhdr + sizeof(*uhdr));\n\t}\n\n\tif (shdr->magic != cpu_to_be64(NET_TEST_PKT_MAGIC))\n\t\tgoto out;\n\tif (tpriv->packet->id != shdr->id)\n\t\tgoto out;\n\n\ttpriv->ok = true;\n\tcomplete(&tpriv->comp);\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int __net_test_loopback(struct net_device *ndev,\n\t\t\t       struct net_packet_attrs *attr)\n{\n\tstruct net_test_priv *tpriv;\n\tstruct sk_buff *skb = NULL;\n\tint ret = 0;\n\n\ttpriv = kzalloc(sizeof(*tpriv), GFP_KERNEL);\n\tif (!tpriv)\n\t\treturn -ENOMEM;\n\n\ttpriv->ok = false;\n\tinit_completion(&tpriv->comp);\n\n\ttpriv->pt.type = htons(ETH_P_IP);\n\ttpriv->pt.func = net_test_loopback_validate;\n\ttpriv->pt.dev = ndev;\n\ttpriv->pt.af_packet_priv = tpriv;\n\ttpriv->packet = attr;\n\tdev_add_pack(&tpriv->pt);\n\n\tskb = net_test_get_skb(ndev, attr);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tret = dev_direct_xmit(skb, attr->queue_mapping);\n\tif (ret < 0) {\n\t\tgoto cleanup;\n\t} else if (ret > 0) {\n\t\tret = -ENETUNREACH;\n\t\tgoto cleanup;\n\t}\n\n\tif (!attr->timeout)\n\t\tattr->timeout = NET_LB_TIMEOUT;\n\n\twait_for_completion_timeout(&tpriv->comp, attr->timeout);\n\tret = tpriv->ok ? 0 : -ETIMEDOUT;\n\ncleanup:\n\tdev_remove_pack(&tpriv->pt);\n\tkfree(tpriv);\n\treturn ret;\n}\n\nstatic int net_test_netif_carrier(struct net_device *ndev)\n{\n\treturn netif_carrier_ok(ndev) ? 0 : -ENOLINK;\n}\n\nstatic int net_test_phy_phydev(struct net_device *ndev)\n{\n\treturn ndev->phydev ? 0 : -EOPNOTSUPP;\n}\n\nstatic int net_test_phy_loopback_enable(struct net_device *ndev)\n{\n\tif (!ndev->phydev)\n\t\treturn -EOPNOTSUPP;\n\n\treturn phy_loopback(ndev->phydev, true);\n}\n\nstatic int net_test_phy_loopback_disable(struct net_device *ndev)\n{\n\tif (!ndev->phydev)\n\t\treturn -EOPNOTSUPP;\n\n\treturn phy_loopback(ndev->phydev, false);\n}\n\nstatic int net_test_phy_loopback_udp(struct net_device *ndev)\n{\n\tstruct net_packet_attrs attr = { };\n\n\tattr.dst = ndev->dev_addr;\n\treturn __net_test_loopback(ndev, &attr);\n}\n\nstatic int net_test_phy_loopback_udp_mtu(struct net_device *ndev)\n{\n\tstruct net_packet_attrs attr = { };\n\n\tattr.dst = ndev->dev_addr;\n\tattr.max_size = ndev->mtu;\n\treturn __net_test_loopback(ndev, &attr);\n}\n\nstatic int net_test_phy_loopback_tcp(struct net_device *ndev)\n{\n\tstruct net_packet_attrs attr = { };\n\n\tattr.dst = ndev->dev_addr;\n\tattr.tcp = true;\n\treturn __net_test_loopback(ndev, &attr);\n}\n\nstatic const struct net_test {\n\tchar name[ETH_GSTRING_LEN];\n\tint (*fn)(struct net_device *ndev);\n} net_selftests[] = {\n\t{\n\t\t.name = \"Carrier                       \",\n\t\t.fn = net_test_netif_carrier,\n\t}, {\n\t\t.name = \"PHY dev is present            \",\n\t\t.fn = net_test_phy_phydev,\n\t}, {\n\t\t \n\t\t.name = \"PHY internal loopback, enable \",\n\t\t.fn = net_test_phy_loopback_enable,\n\t}, {\n\t\t.name = \"PHY internal loopback, UDP    \",\n\t\t.fn = net_test_phy_loopback_udp,\n\t}, {\n\t\t.name = \"PHY internal loopback, MTU    \",\n\t\t.fn = net_test_phy_loopback_udp_mtu,\n\t}, {\n\t\t.name = \"PHY internal loopback, TCP    \",\n\t\t.fn = net_test_phy_loopback_tcp,\n\t}, {\n\t\t \n\t\t.name = \"PHY internal loopback, disable\",\n\t\t.fn = net_test_phy_loopback_disable,\n\t},\n};\n\nvoid net_selftest(struct net_device *ndev, struct ethtool_test *etest, u64 *buf)\n{\n\tint count = net_selftest_get_count();\n\tint i;\n\n\tmemset(buf, 0, sizeof(*buf) * count);\n\tnet_test_next_id = 0;\n\n\tif (etest->flags != ETH_TEST_FL_OFFLINE) {\n\t\tnetdev_err(ndev, \"Only offline tests are supported\\n\");\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\treturn;\n\t}\n\n\n\tfor (i = 0; i < count; i++) {\n\t\tbuf[i] = net_selftests[i].fn(ndev);\n\t\tif (buf[i] && (buf[i] != -EOPNOTSUPP))\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n}\nEXPORT_SYMBOL_GPL(net_selftest);\n\nint net_selftest_get_count(void)\n{\n\treturn ARRAY_SIZE(net_selftests);\n}\nEXPORT_SYMBOL_GPL(net_selftest_get_count);\n\nvoid net_selftest_get_strings(u8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tfor (i = 0; i < net_selftest_get_count(); i++) {\n\t\tsnprintf(p, ETH_GSTRING_LEN, \"%2d. %s\", i + 1,\n\t\t\t net_selftests[i].name);\n\t\tp += ETH_GSTRING_LEN;\n\t}\n}\nEXPORT_SYMBOL_GPL(net_selftest_get_strings);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Oleksij Rempel <o.rempel@pengutronix.de>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}