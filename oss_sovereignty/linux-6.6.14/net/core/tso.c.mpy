{
  "module_name": "tso.c",
  "hash_id": "550e7cd763a4651db5e3cbaa535b4b0fee17e0e609c4b9b70100fc0f6dacb5f3",
  "original_prompt": "Ingested from linux-6.6.14/net/core/tso.c",
  "human_readable_source": "\n#include <linux/export.h>\n#include <linux/if_vlan.h>\n#include <net/ip.h>\n#include <net/tso.h>\n#include <asm/unaligned.h>\n\nvoid tso_build_hdr(const struct sk_buff *skb, char *hdr, struct tso_t *tso,\n\t\t   int size, bool is_last)\n{\n\tint hdr_len = skb_transport_offset(skb) + tso->tlen;\n\tint mac_hdr_len = skb_network_offset(skb);\n\n\tmemcpy(hdr, skb->data, hdr_len);\n\tif (!tso->ipv6) {\n\t\tstruct iphdr *iph = (void *)(hdr + mac_hdr_len);\n\n\t\tiph->id = htons(tso->ip_id);\n\t\tiph->tot_len = htons(size + hdr_len - mac_hdr_len);\n\t\ttso->ip_id++;\n\t} else {\n\t\tstruct ipv6hdr *iph = (void *)(hdr + mac_hdr_len);\n\n\t\tiph->payload_len = htons(size + tso->tlen);\n\t}\n\thdr += skb_transport_offset(skb);\n\tif (tso->tlen != sizeof(struct udphdr)) {\n\t\tstruct tcphdr *tcph = (struct tcphdr *)hdr;\n\n\t\tput_unaligned_be32(tso->tcp_seq, &tcph->seq);\n\n\t\tif (!is_last) {\n\t\t\t \n\t\t\ttcph->psh = 0;\n\t\t\ttcph->fin = 0;\n\t\t\ttcph->rst = 0;\n\t\t}\n\t} else {\n\t\tstruct udphdr *uh = (struct udphdr *)hdr;\n\n\t\tuh->len = htons(sizeof(*uh) + size);\n\t}\n}\nEXPORT_SYMBOL(tso_build_hdr);\n\nvoid tso_build_data(const struct sk_buff *skb, struct tso_t *tso, int size)\n{\n\ttso->tcp_seq += size;  \n\ttso->size -= size;\n\ttso->data += size;\n\n\tif ((tso->size == 0) &&\n\t    (tso->next_frag_idx < skb_shinfo(skb)->nr_frags)) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[tso->next_frag_idx];\n\n\t\t \n\t\ttso->size = skb_frag_size(frag);\n\t\ttso->data = skb_frag_address(frag);\n\t\ttso->next_frag_idx++;\n\t}\n}\nEXPORT_SYMBOL(tso_build_data);\n\nint tso_start(struct sk_buff *skb, struct tso_t *tso)\n{\n\tint tlen = skb_is_gso_tcp(skb) ? tcp_hdrlen(skb) : sizeof(struct udphdr);\n\tint hdr_len = skb_transport_offset(skb) + tlen;\n\n\ttso->tlen = tlen;\n\ttso->ip_id = ntohs(ip_hdr(skb)->id);\n\ttso->tcp_seq = (tlen != sizeof(struct udphdr)) ? ntohl(tcp_hdr(skb)->seq) : 0;\n\ttso->next_frag_idx = 0;\n\ttso->ipv6 = vlan_get_protocol(skb) == htons(ETH_P_IPV6);\n\n\t \n\ttso->size = skb_headlen(skb) - hdr_len;\n\ttso->data = skb->data + hdr_len;\n\tif ((tso->size == 0) &&\n\t    (tso->next_frag_idx < skb_shinfo(skb)->nr_frags)) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[tso->next_frag_idx];\n\n\t\t \n\t\ttso->size = skb_frag_size(frag);\n\t\ttso->data = skb_frag_address(frag);\n\t\ttso->next_frag_idx++;\n\t}\n\treturn hdr_len;\n}\nEXPORT_SYMBOL(tso_start);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}