{
  "module_name": "gso.c",
  "hash_id": "380222e43896c390aed903ff7f5c7e68e88504d170d9555fbd0e2e687b69d9ad",
  "original_prompt": "Ingested from linux-6.6.14/net/core/gso.c",
  "human_readable_source": "\n#include <linux/skbuff.h>\n#include <linux/sctp.h>\n#include <net/gso.h>\n#include <net/gro.h>\n\n \nstruct sk_buff *skb_eth_gso_segment(struct sk_buff *skb,\n\t\t\t\t    netdev_features_t features, __be16 type)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EPROTONOSUPPORT);\n\tstruct packet_offload *ptype;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ptype, &offload_base, list) {\n\t\tif (ptype->type == type && ptype->callbacks.gso_segment) {\n\t\t\tsegs = ptype->callbacks.gso_segment(skb, features);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn segs;\n}\nEXPORT_SYMBOL(skb_eth_gso_segment);\n\n \nstruct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,\n\t\t\t\t    netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EPROTONOSUPPORT);\n\tstruct packet_offload *ptype;\n\tint vlan_depth = skb->mac_len;\n\t__be16 type = skb_network_protocol(skb, &vlan_depth);\n\n\tif (unlikely(!type))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t__skb_pull(skb, vlan_depth);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ptype, &offload_base, list) {\n\t\tif (ptype->type == type && ptype->callbacks.gso_segment) {\n\t\t\tsegs = ptype->callbacks.gso_segment(skb, features);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t__skb_push(skb, skb->data - skb_mac_header(skb));\n\n\treturn segs;\n}\nEXPORT_SYMBOL(skb_mac_gso_segment);\n \nstatic bool skb_needs_check(const struct sk_buff *skb, bool tx_path)\n{\n\tif (tx_path)\n\t\treturn skb->ip_summed != CHECKSUM_PARTIAL &&\n\t\t       skb->ip_summed != CHECKSUM_UNNECESSARY;\n\n\treturn skb->ip_summed == CHECKSUM_NONE;\n}\n\n \nstruct sk_buff *__skb_gso_segment(struct sk_buff *skb,\n\t\t\t\t  netdev_features_t features, bool tx_path)\n{\n\tstruct sk_buff *segs;\n\n\tif (unlikely(skb_needs_check(skb, tx_path))) {\n\t\tint err;\n\n\t\t \n\t\terr = skb_cow_head(skb, 0);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\t \n\tif (features & NETIF_F_GSO_PARTIAL) {\n\t\tnetdev_features_t partial_features = NETIF_F_GSO_ROBUST;\n\t\tstruct net_device *dev = skb->dev;\n\n\t\tpartial_features |= dev->features & dev->gso_partial_features;\n\t\tif (!skb_gso_ok(skb, features | partial_features))\n\t\t\tfeatures &= ~NETIF_F_GSO_PARTIAL;\n\t}\n\n\tBUILD_BUG_ON(SKB_GSO_CB_OFFSET +\n\t\t     sizeof(*SKB_GSO_CB(skb)) > sizeof(skb->cb));\n\n\tSKB_GSO_CB(skb)->mac_offset = skb_headroom(skb);\n\tSKB_GSO_CB(skb)->encap_level = 0;\n\n\tskb_reset_mac_header(skb);\n\tskb_reset_mac_len(skb);\n\n\tsegs = skb_mac_gso_segment(skb, features);\n\n\tif (segs != skb && unlikely(skb_needs_check(skb, tx_path) && !IS_ERR(segs)))\n\t\tskb_warn_bad_offload(skb);\n\n\treturn segs;\n}\nEXPORT_SYMBOL(__skb_gso_segment);\n\n \nstatic unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)\n{\n\tconst struct skb_shared_info *shinfo = skb_shinfo(skb);\n\tunsigned int thlen = 0;\n\n\tif (skb->encapsulation) {\n\t\tthlen = skb_inner_transport_header(skb) -\n\t\t\tskb_transport_header(skb);\n\n\t\tif (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))\n\t\t\tthlen += inner_tcp_hdrlen(skb);\n\t} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {\n\t\tthlen = tcp_hdrlen(skb);\n\t} else if (unlikely(skb_is_gso_sctp(skb))) {\n\t\tthlen = sizeof(struct sctphdr);\n\t} else if (shinfo->gso_type & SKB_GSO_UDP_L4) {\n\t\tthlen = sizeof(struct udphdr);\n\t}\n\t \n\treturn thlen + shinfo->gso_size;\n}\n\n \nstatic unsigned int skb_gso_network_seglen(const struct sk_buff *skb)\n{\n\tunsigned int hdr_len = skb_transport_header(skb) -\n\t\t\t       skb_network_header(skb);\n\n\treturn hdr_len + skb_gso_transport_seglen(skb);\n}\n\n \nstatic unsigned int skb_gso_mac_seglen(const struct sk_buff *skb)\n{\n\tunsigned int hdr_len = skb_transport_header(skb) - skb_mac_header(skb);\n\n\treturn hdr_len + skb_gso_transport_seglen(skb);\n}\n\n \nstatic inline bool skb_gso_size_check(const struct sk_buff *skb,\n\t\t\t\t      unsigned int seg_len,\n\t\t\t\t      unsigned int max_len) {\n\tconst struct skb_shared_info *shinfo = skb_shinfo(skb);\n\tconst struct sk_buff *iter;\n\n\tif (shinfo->gso_size != GSO_BY_FRAGS)\n\t\treturn seg_len <= max_len;\n\n\t \n\tseg_len -= GSO_BY_FRAGS;\n\n\tskb_walk_frags(skb, iter) {\n\t\tif (seg_len + skb_headlen(iter) > max_len)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nbool skb_gso_validate_network_len(const struct sk_buff *skb, unsigned int mtu)\n{\n\treturn skb_gso_size_check(skb, skb_gso_network_seglen(skb), mtu);\n}\nEXPORT_SYMBOL_GPL(skb_gso_validate_network_len);\n\n \nbool skb_gso_validate_mac_len(const struct sk_buff *skb, unsigned int len)\n{\n\treturn skb_gso_size_check(skb, skb_gso_mac_seglen(skb), len);\n}\nEXPORT_SYMBOL_GPL(skb_gso_validate_mac_len);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}