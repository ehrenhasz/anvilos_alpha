{
  "module_name": "sock_diag.c",
  "hash_id": "4358f91e68b94f232ea76544b37299629e3a8914e99435ecad44cda6bdc63b1e",
  "original_prompt": "Ingested from linux-6.6.14/net/core/sock_diag.c",
  "human_readable_source": " \n\n#include <linux/filter.h>\n#include <linux/mutex.h>\n#include <linux/socket.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <net/sock.h>\n#include <linux/kernel.h>\n#include <linux/tcp.h>\n#include <linux/workqueue.h>\n#include <linux/nospec.h>\n#include <linux/cookie.h>\n#include <linux/inet_diag.h>\n#include <linux/sock_diag.h>\n\nstatic const struct sock_diag_handler *sock_diag_handlers[AF_MAX];\nstatic int (*inet_rcv_compat)(struct sk_buff *skb, struct nlmsghdr *nlh);\nstatic DEFINE_MUTEX(sock_diag_table_mutex);\nstatic struct workqueue_struct *broadcast_wq;\n\nDEFINE_COOKIE(sock_cookie);\n\nu64 __sock_gen_cookie(struct sock *sk)\n{\n\tu64 res = atomic64_read(&sk->sk_cookie);\n\n\tif (!res) {\n\t\tu64 new = gen_cookie_next(&sock_cookie);\n\n\t\tatomic64_cmpxchg(&sk->sk_cookie, res, new);\n\n\t\t \n\t\tres = atomic64_read(&sk->sk_cookie);\n\t}\n\treturn res;\n}\n\nint sock_diag_check_cookie(struct sock *sk, const __u32 *cookie)\n{\n\tu64 res;\n\n\tif (cookie[0] == INET_DIAG_NOCOOKIE && cookie[1] == INET_DIAG_NOCOOKIE)\n\t\treturn 0;\n\n\tres = sock_gen_cookie(sk);\n\tif ((u32)res != cookie[0] || (u32)(res >> 32) != cookie[1])\n\t\treturn -ESTALE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sock_diag_check_cookie);\n\nvoid sock_diag_save_cookie(struct sock *sk, __u32 *cookie)\n{\n\tu64 res = sock_gen_cookie(sk);\n\n\tcookie[0] = (u32)res;\n\tcookie[1] = (u32)(res >> 32);\n}\nEXPORT_SYMBOL_GPL(sock_diag_save_cookie);\n\nint sock_diag_put_meminfo(struct sock *sk, struct sk_buff *skb, int attrtype)\n{\n\tu32 mem[SK_MEMINFO_VARS];\n\n\tsk_get_meminfo(sk, mem);\n\n\treturn nla_put(skb, attrtype, sizeof(mem), &mem);\n}\nEXPORT_SYMBOL_GPL(sock_diag_put_meminfo);\n\nint sock_diag_put_filterinfo(bool may_report_filterinfo, struct sock *sk,\n\t\t\t     struct sk_buff *skb, int attrtype)\n{\n\tstruct sock_fprog_kern *fprog;\n\tstruct sk_filter *filter;\n\tstruct nlattr *attr;\n\tunsigned int flen;\n\tint err = 0;\n\n\tif (!may_report_filterinfo) {\n\t\tnla_reserve(skb, attrtype, 0);\n\t\treturn 0;\n\t}\n\n\trcu_read_lock();\n\tfilter = rcu_dereference(sk->sk_filter);\n\tif (!filter)\n\t\tgoto out;\n\n\tfprog = filter->prog->orig_prog;\n\tif (!fprog)\n\t\tgoto out;\n\n\tflen = bpf_classic_proglen(fprog);\n\n\tattr = nla_reserve(skb, attrtype, flen);\n\tif (attr == NULL) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tmemcpy(nla_data(attr), fprog->filter, flen);\nout:\n\trcu_read_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(sock_diag_put_filterinfo);\n\nstruct broadcast_sk {\n\tstruct sock *sk;\n\tstruct work_struct work;\n};\n\nstatic size_t sock_diag_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct inet_diag_msg)\n\t       + nla_total_size(sizeof(u8))  \n\t       + nla_total_size_64bit(sizeof(struct tcp_info)));  \n}\n\nstatic void sock_diag_broadcast_destroy_work(struct work_struct *work)\n{\n\tstruct broadcast_sk *bsk =\n\t\tcontainer_of(work, struct broadcast_sk, work);\n\tstruct sock *sk = bsk->sk;\n\tconst struct sock_diag_handler *hndl;\n\tstruct sk_buff *skb;\n\tconst enum sknetlink_groups group = sock_diag_destroy_group(sk);\n\tint err = -1;\n\n\tWARN_ON(group == SKNLGRP_NONE);\n\n\tskb = nlmsg_new(sock_diag_nlmsg_size(), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto out;\n\n\tmutex_lock(&sock_diag_table_mutex);\n\thndl = sock_diag_handlers[sk->sk_family];\n\tif (hndl && hndl->get_info)\n\t\terr = hndl->get_info(skb, sk);\n\tmutex_unlock(&sock_diag_table_mutex);\n\n\tif (!err)\n\t\tnlmsg_multicast(sock_net(sk)->diag_nlsk, skb, 0, group,\n\t\t\t\tGFP_KERNEL);\n\telse\n\t\tkfree_skb(skb);\nout:\n\tsk_destruct(sk);\n\tkfree(bsk);\n}\n\nvoid sock_diag_broadcast_destroy(struct sock *sk)\n{\n\t \n\tstruct broadcast_sk *bsk =\n\t\tkmalloc(sizeof(struct broadcast_sk), GFP_ATOMIC);\n\tif (!bsk)\n\t\treturn sk_destruct(sk);\n\tbsk->sk = sk;\n\tINIT_WORK(&bsk->work, sock_diag_broadcast_destroy_work);\n\tqueue_work(broadcast_wq, &bsk->work);\n}\n\nvoid sock_diag_register_inet_compat(int (*fn)(struct sk_buff *skb, struct nlmsghdr *nlh))\n{\n\tmutex_lock(&sock_diag_table_mutex);\n\tinet_rcv_compat = fn;\n\tmutex_unlock(&sock_diag_table_mutex);\n}\nEXPORT_SYMBOL_GPL(sock_diag_register_inet_compat);\n\nvoid sock_diag_unregister_inet_compat(int (*fn)(struct sk_buff *skb, struct nlmsghdr *nlh))\n{\n\tmutex_lock(&sock_diag_table_mutex);\n\tinet_rcv_compat = NULL;\n\tmutex_unlock(&sock_diag_table_mutex);\n}\nEXPORT_SYMBOL_GPL(sock_diag_unregister_inet_compat);\n\nint sock_diag_register(const struct sock_diag_handler *hndl)\n{\n\tint err = 0;\n\n\tif (hndl->family >= AF_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sock_diag_table_mutex);\n\tif (sock_diag_handlers[hndl->family])\n\t\terr = -EBUSY;\n\telse\n\t\tsock_diag_handlers[hndl->family] = hndl;\n\tmutex_unlock(&sock_diag_table_mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sock_diag_register);\n\nvoid sock_diag_unregister(const struct sock_diag_handler *hnld)\n{\n\tint family = hnld->family;\n\n\tif (family >= AF_MAX)\n\t\treturn;\n\n\tmutex_lock(&sock_diag_table_mutex);\n\tBUG_ON(sock_diag_handlers[family] != hnld);\n\tsock_diag_handlers[family] = NULL;\n\tmutex_unlock(&sock_diag_table_mutex);\n}\nEXPORT_SYMBOL_GPL(sock_diag_unregister);\n\nstatic int __sock_diag_cmd(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n\n\tif (nlmsg_len(nlh) < sizeof(*req))\n\t\treturn -EINVAL;\n\n\tif (req->sdiag_family >= AF_MAX)\n\t\treturn -EINVAL;\n\treq->sdiag_family = array_index_nospec(req->sdiag_family, AF_MAX);\n\n\tif (sock_diag_handlers[req->sdiag_family] == NULL)\n\t\tsock_load_diag_module(req->sdiag_family, 0);\n\n\tmutex_lock(&sock_diag_table_mutex);\n\thndl = sock_diag_handlers[req->sdiag_family];\n\tif (hndl == NULL)\n\t\terr = -ENOENT;\n\telse if (nlh->nlmsg_type == SOCK_DIAG_BY_FAMILY)\n\t\terr = hndl->dump(skb, nlh);\n\telse if (nlh->nlmsg_type == SOCK_DESTROY && hndl->destroy)\n\t\terr = hndl->destroy(skb, nlh);\n\telse\n\t\terr = -EOPNOTSUPP;\n\tmutex_unlock(&sock_diag_table_mutex);\n\n\treturn err;\n}\n\nstatic int sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tint ret;\n\n\tswitch (nlh->nlmsg_type) {\n\tcase TCPDIAG_GETSOCK:\n\tcase DCCPDIAG_GETSOCK:\n\t\tif (inet_rcv_compat == NULL)\n\t\t\tsock_load_diag_module(AF_INET, 0);\n\n\t\tmutex_lock(&sock_diag_table_mutex);\n\t\tif (inet_rcv_compat != NULL)\n\t\t\tret = inet_rcv_compat(skb, nlh);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tmutex_unlock(&sock_diag_table_mutex);\n\n\t\treturn ret;\n\tcase SOCK_DIAG_BY_FAMILY:\n\tcase SOCK_DESTROY:\n\t\treturn __sock_diag_cmd(skb, nlh);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic DEFINE_MUTEX(sock_diag_mutex);\n\nstatic void sock_diag_rcv(struct sk_buff *skb)\n{\n\tmutex_lock(&sock_diag_mutex);\n\tnetlink_rcv_skb(skb, &sock_diag_rcv_msg);\n\tmutex_unlock(&sock_diag_mutex);\n}\n\nstatic int sock_diag_bind(struct net *net, int group)\n{\n\tswitch (group) {\n\tcase SKNLGRP_INET_TCP_DESTROY:\n\tcase SKNLGRP_INET_UDP_DESTROY:\n\t\tif (!sock_diag_handlers[AF_INET])\n\t\t\tsock_load_diag_module(AF_INET, 0);\n\t\tbreak;\n\tcase SKNLGRP_INET6_TCP_DESTROY:\n\tcase SKNLGRP_INET6_UDP_DESTROY:\n\t\tif (!sock_diag_handlers[AF_INET6])\n\t\t\tsock_load_diag_module(AF_INET6, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint sock_diag_destroy(struct sock *sk, int err)\n{\n\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!sk->sk_prot->diag_destroy)\n\t\treturn -EOPNOTSUPP;\n\n\treturn sk->sk_prot->diag_destroy(sk, err);\n}\nEXPORT_SYMBOL_GPL(sock_diag_destroy);\n\nstatic int __net_init diag_net_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= SKNLGRP_MAX,\n\t\t.input\t= sock_diag_rcv,\n\t\t.bind\t= sock_diag_bind,\n\t\t.flags\t= NL_CFG_F_NONROOT_RECV,\n\t};\n\n\tnet->diag_nlsk = netlink_kernel_create(net, NETLINK_SOCK_DIAG, &cfg);\n\treturn net->diag_nlsk == NULL ? -ENOMEM : 0;\n}\n\nstatic void __net_exit diag_net_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->diag_nlsk);\n\tnet->diag_nlsk = NULL;\n}\n\nstatic struct pernet_operations diag_net_ops = {\n\t.init = diag_net_init,\n\t.exit = diag_net_exit,\n};\n\nstatic int __init sock_diag_init(void)\n{\n\tbroadcast_wq = alloc_workqueue(\"sock_diag_events\", 0, 0);\n\tBUG_ON(!broadcast_wq);\n\treturn register_pernet_subsys(&diag_net_ops);\n}\ndevice_initcall(sock_diag_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}