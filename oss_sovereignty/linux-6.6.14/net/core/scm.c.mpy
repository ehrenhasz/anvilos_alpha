{
  "module_name": "scm.c",
  "hash_id": "9973edcf66e29bcc27fecd1ab97b57e19bd394067fe222a84a794d553f5d1d99",
  "original_prompt": "Ingested from linux-6.6.14/net/core/scm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/signal.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/socket.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/net.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/security.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/errqueue.h>\n#include <linux/io_uring.h>\n\n#include <linux/uaccess.h>\n\n#include <net/protocol.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/compat.h>\n#include <net/scm.h>\n#include <net/cls_cgroup.h>\n\n\n \n\nstatic __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\n\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\treturn -EINVAL;\n\n\tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n\t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n\t      uid_eq(uid, cred->suid)) || ns_capable(cred->user_ns, CAP_SETUID)) &&\n\t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || ns_capable(cred->user_ns, CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}\n\nstatic int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\n\tnum = (cmsg->cmsg_len - sizeof(struct cmsghdr))/sizeof(int);\n\n\tif (num <= 0)\n\t\treturn 0;\n\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL_ACCOUNT);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t\tfpl->max = SCM_MAX_FD;\n\t\tfpl->user = NULL;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\n\tif (fpl->count + num > fpl->max)\n\t\treturn -EINVAL;\n\n\t \n\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\n\t\tif (fd < 0 || !(file = fget_raw(fd)))\n\t\t\treturn -EBADF;\n\t\t \n\t\tif (io_uring_get_socket(file)) {\n\t\t\tfput(file);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\n\tif (!fpl->user)\n\t\tfpl->user = get_uid(current_user());\n\n\treturn num;\n}\n\nvoid __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\n\tif (fpl) {\n\t\tscm->fp = NULL;\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tfput(fpl->fp[i]);\n\t\tfree_uid(fpl->user);\n\t\tkfree(fpl);\n\t}\n}\nEXPORT_SYMBOL(__scm_destroy);\n\nint __scm_send(struct socket *sock, struct msghdr *msg, struct scm_cookie *p)\n{\n\tconst struct proto_ops *ops = READ_ONCE(sock->ops);\n\tstruct cmsghdr *cmsg;\n\tint err;\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\terr = -EINVAL;\n\n\t\t \n\t\t \n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\tgoto error;\n\n\t\tif (cmsg->cmsg_level != SOL_SOCKET)\n\t\t\tcontinue;\n\n\t\tswitch (cmsg->cmsg_type)\n\t\t{\n\t\tcase SCM_RIGHTS:\n\t\t\tif (!ops || ops->family != PF_UNIX)\n\t\t\t\tgoto error;\n\t\t\terr=scm_fp_copy(cmsg, &p->fp);\n\t\t\tif (err<0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SCM_CREDENTIALS:\n\t\t{\n\t\t\tstruct ucred creds;\n\t\t\tkuid_t uid;\n\t\t\tkgid_t gid;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct ucred)))\n\t\t\t\tgoto error;\n\t\t\tmemcpy(&creds, CMSG_DATA(cmsg), sizeof(struct ucred));\n\t\t\terr = scm_check_creds(&creds);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\n\t\t\tp->creds.pid = creds.pid;\n\t\t\tif (!p->pid || pid_vnr(p->pid) != creds.pid) {\n\t\t\t\tstruct pid *pid;\n\t\t\t\terr = -ESRCH;\n\t\t\t\tpid = find_get_pid(creds.pid);\n\t\t\t\tif (!pid)\n\t\t\t\t\tgoto error;\n\t\t\t\tput_pid(p->pid);\n\t\t\t\tp->pid = pid;\n\t\t\t}\n\n\t\t\terr = -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), creds.uid);\n\t\t\tgid = make_kgid(current_user_ns(), creds.gid);\n\t\t\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\t\t\tgoto error;\n\n\t\t\tp->creds.uid = uid;\n\t\t\tp->creds.gid = gid;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (p->fp && !p->fp->count)\n\t{\n\t\tkfree(p->fp);\n\t\tp->fp = NULL;\n\t}\n\treturn 0;\n\nerror:\n\tscm_destroy(p);\n\treturn err;\n}\nEXPORT_SYMBOL(__scm_send);\n\nint put_cmsg(struct msghdr * msg, int level, int type, int len, void *data)\n{\n\tint cmlen = CMSG_LEN(len);\n\n\tif (msg->msg_flags & MSG_CMSG_COMPAT)\n\t\treturn put_cmsg_compat(msg, level, type, len, data);\n\n\tif (!msg->msg_control || msg->msg_controllen < sizeof(struct cmsghdr)) {\n\t\tmsg->msg_flags |= MSG_CTRUNC;\n\t\treturn 0;  \n\t}\n\tif (msg->msg_controllen < cmlen) {\n\t\tmsg->msg_flags |= MSG_CTRUNC;\n\t\tcmlen = msg->msg_controllen;\n\t}\n\n\tif (msg->msg_control_is_user) {\n\t\tstruct cmsghdr __user *cm = msg->msg_control_user;\n\n\t\tcheck_object_size(data, cmlen - sizeof(*cm), true);\n\n\t\tif (!user_write_access_begin(cm, cmlen))\n\t\t\tgoto efault;\n\n\t\tunsafe_put_user(cmlen, &cm->cmsg_len, efault_end);\n\t\tunsafe_put_user(level, &cm->cmsg_level, efault_end);\n\t\tunsafe_put_user(type, &cm->cmsg_type, efault_end);\n\t\tunsafe_copy_to_user(CMSG_USER_DATA(cm), data,\n\t\t\t\t    cmlen - sizeof(*cm), efault_end);\n\t\tuser_write_access_end();\n\t} else {\n\t\tstruct cmsghdr *cm = msg->msg_control;\n\n\t\tcm->cmsg_level = level;\n\t\tcm->cmsg_type = type;\n\t\tcm->cmsg_len = cmlen;\n\t\tmemcpy(CMSG_DATA(cm), data, cmlen - sizeof(*cm));\n\t}\n\n\tcmlen = min(CMSG_SPACE(len), msg->msg_controllen);\n\tif (msg->msg_control_is_user)\n\t\tmsg->msg_control_user += cmlen;\n\telse\n\t\tmsg->msg_control += cmlen;\n\tmsg->msg_controllen -= cmlen;\n\treturn 0;\n\nefault_end:\n\tuser_write_access_end();\nefault:\n\treturn -EFAULT;\n}\nEXPORT_SYMBOL(put_cmsg);\n\nvoid put_cmsg_scm_timestamping64(struct msghdr *msg, struct scm_timestamping_internal *tss_internal)\n{\n\tstruct scm_timestamping64 tss;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tss.ts); i++) {\n\t\ttss.ts[i].tv_sec = tss_internal->ts[i].tv_sec;\n\t\ttss.ts[i].tv_nsec = tss_internal->ts[i].tv_nsec;\n\t}\n\n\tput_cmsg(msg, SOL_SOCKET, SO_TIMESTAMPING_NEW, sizeof(tss), &tss);\n}\nEXPORT_SYMBOL(put_cmsg_scm_timestamping64);\n\nvoid put_cmsg_scm_timestamping(struct msghdr *msg, struct scm_timestamping_internal *tss_internal)\n{\n\tstruct scm_timestamping tss;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tss.ts); i++) {\n\t\ttss.ts[i].tv_sec = tss_internal->ts[i].tv_sec;\n\t\ttss.ts[i].tv_nsec = tss_internal->ts[i].tv_nsec;\n\t}\n\n\tput_cmsg(msg, SOL_SOCKET, SO_TIMESTAMPING_OLD, sizeof(tss), &tss);\n}\nEXPORT_SYMBOL(put_cmsg_scm_timestamping);\n\nstatic int scm_max_fds(struct msghdr *msg)\n{\n\tif (msg->msg_controllen <= sizeof(struct cmsghdr))\n\t\treturn 0;\n\treturn (msg->msg_controllen - sizeof(struct cmsghdr)) / sizeof(int);\n}\n\nvoid scm_detach_fds(struct msghdr *msg, struct scm_cookie *scm)\n{\n\tstruct cmsghdr __user *cm =\n\t\t(__force struct cmsghdr __user *)msg->msg_control_user;\n\tunsigned int o_flags = (msg->msg_flags & MSG_CMSG_CLOEXEC) ? O_CLOEXEC : 0;\n\tint fdmax = min_t(int, scm_max_fds(msg), scm->fp->count);\n\tint __user *cmsg_data = CMSG_USER_DATA(cm);\n\tint err = 0, i;\n\n\t \n\tif (WARN_ON_ONCE(!msg->msg_control_is_user))\n\t\treturn;\n\n\tif (msg->msg_flags & MSG_CMSG_COMPAT) {\n\t\tscm_detach_fds_compat(msg, scm);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < fdmax; i++) {\n\t\terr = receive_fd_user(scm->fp->fp[i], cmsg_data + i, o_flags);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\tif (i > 0) {\n\t\tint cmlen = CMSG_LEN(i * sizeof(int));\n\n\t\terr = put_user(SOL_SOCKET, &cm->cmsg_level);\n\t\tif (!err)\n\t\t\terr = put_user(SCM_RIGHTS, &cm->cmsg_type);\n\t\tif (!err)\n\t\t\terr = put_user(cmlen, &cm->cmsg_len);\n\t\tif (!err) {\n\t\t\tcmlen = CMSG_SPACE(i * sizeof(int));\n\t\t\tif (msg->msg_controllen < cmlen)\n\t\t\t\tcmlen = msg->msg_controllen;\n\t\t\tmsg->msg_control_user += cmlen;\n\t\t\tmsg->msg_controllen -= cmlen;\n\t\t}\n\t}\n\n\tif (i < scm->fp->count || (scm->fp->count && fdmax <= 0))\n\t\tmsg->msg_flags |= MSG_CTRUNC;\n\n\t \n\t__scm_destroy(scm);\n}\nEXPORT_SYMBOL(scm_detach_fds);\n\nstruct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\n\tif (!fpl)\n\t\treturn NULL;\n\n\tnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\n\t\t\t  GFP_KERNEL_ACCOUNT);\n\tif (new_fpl) {\n\t\tfor (i = 0; i < fpl->count; i++)\n\t\t\tget_file(fpl->fp[i]);\n\t\tnew_fpl->max = new_fpl->count;\n\t\tnew_fpl->user = get_uid(fpl->user);\n\t}\n\treturn new_fpl;\n}\nEXPORT_SYMBOL(scm_fp_dup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}