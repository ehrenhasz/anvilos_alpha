{
  "module_name": "netprio_cgroup.c",
  "hash_id": "302af98896720162474a18b4053dcaeb0c0c332a9de48fa345d8214d115269eb",
  "original_prompt": "Ingested from linux-6.6.14/net/core/netprio_cgroup.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/cgroup.h>\n#include <linux/rcupdate.h>\n#include <linux/atomic.h>\n#include <linux/sched/task.h>\n\n#include <net/rtnetlink.h>\n#include <net/pkt_cls.h>\n#include <net/sock.h>\n#include <net/netprio_cgroup.h>\n\n#include <linux/fdtable.h>\n\n \n#define NETPRIO_ID_MAX\t\tUSHRT_MAX\n\n#define PRIOMAP_MIN_SZ\t\t128\n\n \nstatic int extend_netdev_table(struct net_device *dev, u32 target_idx)\n{\n\tstruct netprio_map *old, *new;\n\tsize_t new_sz, new_len;\n\n\t \n\told = rtnl_dereference(dev->priomap);\n\tif (old && old->priomap_len > target_idx)\n\t\treturn 0;\n\n\t \n\tnew_sz = PRIOMAP_MIN_SZ;\n\twhile (true) {\n\t\tnew_len = (new_sz - offsetof(struct netprio_map, priomap)) /\n\t\t\tsizeof(new->priomap[0]);\n\t\tif (new_len > target_idx)\n\t\t\tbreak;\n\t\tnew_sz *= 2;\n\t\t \n\t\tif (WARN_ON(new_sz < PRIOMAP_MIN_SZ))\n\t\t\treturn -ENOSPC;\n\t}\n\n\t \n\tnew = kzalloc(new_sz, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (old)\n\t\tmemcpy(new->priomap, old->priomap,\n\t\t       old->priomap_len * sizeof(old->priomap[0]));\n\n\tnew->priomap_len = new_len;\n\n\t \n\trcu_assign_pointer(dev->priomap, new);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\treturn 0;\n}\n\n \nstatic u32 netprio_prio(struct cgroup_subsys_state *css, struct net_device *dev)\n{\n\tstruct netprio_map *map = rcu_dereference_rtnl(dev->priomap);\n\tint id = css->id;\n\n\tif (map && id < map->priomap_len)\n\t\treturn map->priomap[id];\n\treturn 0;\n}\n\n \nstatic int netprio_set_prio(struct cgroup_subsys_state *css,\n\t\t\t    struct net_device *dev, u32 prio)\n{\n\tstruct netprio_map *map;\n\tint id = css->id;\n\tint ret;\n\n\t \n\tmap = rtnl_dereference(dev->priomap);\n\tif (!prio && (!map || map->priomap_len <= id))\n\t\treturn 0;\n\n\tret = extend_netdev_table(dev, id);\n\tif (ret)\n\t\treturn ret;\n\n\tmap = rtnl_dereference(dev->priomap);\n\tmap->priomap[id] = prio;\n\treturn 0;\n}\n\nstatic struct cgroup_subsys_state *\ncgrp_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tcss = kzalloc(sizeof(*css), GFP_KERNEL);\n\tif (!css)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn css;\n}\n\nstatic int cgrp_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys_state *parent_css = css->parent;\n\tstruct net_device *dev;\n\tint ret = 0;\n\n\tif (css->id > NETPRIO_ID_MAX)\n\t\treturn -ENOSPC;\n\n\tif (!parent_css)\n\t\treturn 0;\n\n\trtnl_lock();\n\t \n\tfor_each_netdev(&init_net, dev) {\n\t\tu32 prio = netprio_prio(parent_css, dev);\n\n\t\tret = netprio_set_prio(css, dev, prio);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic void cgrp_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css);\n}\n\nstatic u64 read_prioidx(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\treturn css->id;\n}\n\nstatic int read_priomap(struct seq_file *sf, void *v)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev)\n\t\tseq_printf(sf, \"%s %u\\n\", dev->name,\n\t\t\t   netprio_prio(seq_css(sf), dev));\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic ssize_t write_priomap(struct kernfs_open_file *of,\n\t\t\t     char *buf, size_t nbytes, loff_t off)\n{\n\tchar devname[IFNAMSIZ + 1];\n\tstruct net_device *dev;\n\tu32 prio;\n\tint ret;\n\n\tif (sscanf(buf, \"%\"__stringify(IFNAMSIZ)\"s %u\", devname, &prio) != 2)\n\t\treturn -EINVAL;\n\n\tdev = dev_get_by_name(&init_net, devname);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trtnl_lock();\n\n\tret = netprio_set_prio(of_css(of), dev, prio);\n\n\trtnl_unlock();\n\tdev_put(dev);\n\treturn ret ?: nbytes;\n}\n\nstatic int update_netprio(const void *v, struct file *file, unsigned n)\n{\n\tstruct socket *sock = sock_from_file(file);\n\n\tif (sock)\n\t\tsock_cgroup_set_prioidx(&sock->sk->sk_cgrp_data,\n\t\t\t\t\t(unsigned long)v);\n\treturn 0;\n}\n\nstatic void net_prio_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *p;\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_for_each(p, css, tset) {\n\t\tvoid *v = (void *)(unsigned long)css->id;\n\n\t\ttask_lock(p);\n\t\titerate_fd(p->files, 0, update_netprio, v);\n\t\ttask_unlock(p);\n\t}\n}\n\nstatic struct cftype ss_files[] = {\n\t{\n\t\t.name = \"prioidx\",\n\t\t.read_u64 = read_prioidx,\n\t},\n\t{\n\t\t.name = \"ifpriomap\",\n\t\t.seq_show = read_priomap,\n\t\t.write = write_priomap,\n\t},\n\t{ }\t \n};\n\nstruct cgroup_subsys net_prio_cgrp_subsys = {\n\t.css_alloc\t= cgrp_css_alloc,\n\t.css_online\t= cgrp_css_online,\n\t.css_free\t= cgrp_css_free,\n\t.attach\t\t= net_prio_attach,\n\t.legacy_cftypes\t= ss_files,\n};\n\nstatic int netprio_device_event(struct notifier_block *unused,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netprio_map *old;\n\n\t \n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\told = rtnl_dereference(dev->priomap);\n\t\tRCU_INIT_POINTER(dev->priomap, NULL);\n\t\tif (old)\n\t\t\tkfree_rcu(old, rcu);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block netprio_device_notifier = {\n\t.notifier_call = netprio_device_event\n};\n\nstatic int __init init_cgroup_netprio(void)\n{\n\tregister_netdevice_notifier(&netprio_device_notifier);\n\treturn 0;\n}\nsubsys_initcall(init_cgroup_netprio);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}