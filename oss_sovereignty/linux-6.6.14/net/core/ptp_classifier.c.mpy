{
  "module_name": "ptp_classifier.c",
  "hash_id": "13ff4c5ed4ab4995729a908a5c58e6af1751a5178eabd63b3a8d3bd71e84fdef",
  "original_prompt": "Ingested from linux-6.6.14/net/core/ptp_classifier.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <linux/ptp_classify.h>\n\nstatic struct bpf_prog *ptp_insns __read_mostly;\n\nunsigned int ptp_classify_raw(const struct sk_buff *skb)\n{\n\treturn bpf_prog_run(ptp_insns, skb);\n}\nEXPORT_SYMBOL_GPL(ptp_classify_raw);\n\nstruct ptp_header *ptp_parse_header(struct sk_buff *skb, unsigned int type)\n{\n\tu8 *ptr = skb_mac_header(skb);\n\n\tif (type & PTP_CLASS_VLAN)\n\t\tptr += VLAN_HLEN;\n\n\tswitch (type & PTP_CLASS_PMASK) {\n\tcase PTP_CLASS_IPV4:\n\t\tptr += IPV4_HLEN(ptr) + UDP_HLEN;\n\t\tbreak;\n\tcase PTP_CLASS_IPV6:\n\t\tptr += IP6_HLEN + UDP_HLEN;\n\t\tbreak;\n\tcase PTP_CLASS_L2:\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tptr += ETH_HLEN;\n\n\t \n\tif (ptr + sizeof(struct ptp_header) > skb->data + skb->len)\n\t\treturn NULL;\n\n\treturn (struct ptp_header *)ptr;\n}\nEXPORT_SYMBOL_GPL(ptp_parse_header);\n\nbool ptp_msg_is_sync(struct sk_buff *skb, unsigned int type)\n{\n\tstruct ptp_header *hdr;\n\n\thdr = ptp_parse_header(skb, type);\n\tif (!hdr)\n\t\treturn false;\n\n\treturn ptp_get_msgtype(hdr, type) == PTP_MSGTYPE_SYNC;\n}\nEXPORT_SYMBOL_GPL(ptp_msg_is_sync);\n\nvoid __init ptp_classifier_init(void)\n{\n\tstatic struct sock_filter ptp_filter[] __initdata = {\n\t\t{ 0x28,  0,  0, 0x0000000c },\n\t\t{ 0x15,  0, 12, 0x00000800 },\n\t\t{ 0x30,  0,  0, 0x00000017 },\n\t\t{ 0x15,  0,  9, 0x00000011 },\n\t\t{ 0x28,  0,  0, 0x00000014 },\n\t\t{ 0x45,  7,  0, 0x00001fff },\n\t\t{ 0xb1,  0,  0, 0x0000000e },\n\t\t{ 0x48,  0,  0, 0x00000010 },\n\t\t{ 0x15,  0,  4, 0x0000013f },\n\t\t{ 0x48,  0,  0, 0x00000016 },\n\t\t{ 0x54,  0,  0, 0x0000000f },\n\t\t{ 0x44,  0,  0, 0x00000010 },\n\t\t{ 0x16,  0,  0, 0x00000000 },\n\t\t{ 0x06,  0,  0, 0x00000000 },\n\t\t{ 0x15,  0,  9, 0x000086dd },\n\t\t{ 0x30,  0,  0, 0x00000014 },\n\t\t{ 0x15,  0,  6, 0x00000011 },\n\t\t{ 0x28,  0,  0, 0x00000038 },\n\t\t{ 0x15,  0,  4, 0x0000013f },\n\t\t{ 0x28,  0,  0, 0x0000003e },\n\t\t{ 0x54,  0,  0, 0x0000000f },\n\t\t{ 0x44,  0,  0, 0x00000020 },\n\t\t{ 0x16,  0,  0, 0x00000000 },\n\t\t{ 0x06,  0,  0, 0x00000000 },\n\t\t{ 0x15,  0, 32, 0x00008100 },\n\t\t{ 0x28,  0,  0, 0x00000010 },\n\t\t{ 0x15,  0,  7, 0x000088f7 },\n\t\t{ 0x30,  0,  0, 0x00000012 },\n\t\t{ 0x54,  0,  0, 0x00000008 },\n\t\t{ 0x15,  0, 35, 0x00000000 },\n\t\t{ 0x28,  0,  0, 0x00000012 },\n\t\t{ 0x54,  0,  0, 0x0000000f },\n\t\t{ 0x44,  0,  0, 0x000000c0 },\n\t\t{ 0x16,  0,  0, 0x00000000 },\n\t\t{ 0x15,  0, 12, 0x00000800 },\n\t\t{ 0x30,  0,  0, 0x0000001b },\n\t\t{ 0x15,  0,  9, 0x00000011 },\n\t\t{ 0x28,  0,  0, 0x00000018 },\n\t\t{ 0x45,  7,  0, 0x00001fff },\n\t\t{ 0xb1,  0,  0, 0x00000012 },\n\t\t{ 0x48,  0,  0, 0x00000014 },\n\t\t{ 0x15,  0,  4, 0x0000013f },\n\t\t{ 0x48,  0,  0, 0x0000001a },\n\t\t{ 0x54,  0,  0, 0x0000000f },\n\t\t{ 0x44,  0,  0, 0x00000090 },\n\t\t{ 0x16,  0,  0, 0x00000000 },\n\t\t{ 0x06,  0,  0, 0x00000000 },\n\t\t{ 0x15,  0,  8, 0x000086dd },\n\t\t{ 0x30,  0,  0, 0x00000018 },\n\t\t{ 0x15,  0,  6, 0x00000011 },\n\t\t{ 0x28,  0,  0, 0x0000003c },\n\t\t{ 0x15,  0,  4, 0x0000013f },\n\t\t{ 0x28,  0,  0, 0x00000042 },\n\t\t{ 0x54,  0,  0, 0x0000000f },\n\t\t{ 0x44,  0,  0, 0x000000a0 },\n\t\t{ 0x16,  0,  0, 0x00000000 },\n\t\t{ 0x06,  0,  0, 0x00000000 },\n\t\t{ 0x15,  0,  7, 0x000088f7 },\n\t\t{ 0x30,  0,  0, 0x0000000e },\n\t\t{ 0x54,  0,  0, 0x00000008 },\n\t\t{ 0x15,  0,  4, 0x00000000 },\n\t\t{ 0x28,  0,  0, 0x0000000e },\n\t\t{ 0x54,  0,  0, 0x0000000f },\n\t\t{ 0x44,  0,  0, 0x00000040 },\n\t\t{ 0x16,  0,  0, 0x00000000 },\n\t\t{ 0x06,  0,  0, 0x00000000 },\n\t};\n\tstruct sock_fprog_kern ptp_prog;\n\n\tptp_prog.len = ARRAY_SIZE(ptp_filter);\n\tptp_prog.filter = ptp_filter;\n\n\tBUG_ON(bpf_prog_create(&ptp_insns, &ptp_prog));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}