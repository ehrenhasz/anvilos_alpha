{
  "module_name": "fib_notifier.c",
  "hash_id": "f2d23eb5a30aeed14b18329cb1e4b4ac61b594cb26c58b2a2d8efe165b6c6f80",
  "original_prompt": "Ingested from linux-6.6.14/net/core/fib_notifier.c",
  "human_readable_source": "#include <linux/rtnetlink.h>\n#include <linux/notifier.h>\n#include <linux/rcupdate.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/fib_notifier.h>\n\nstatic unsigned int fib_notifier_net_id;\n\nstruct fib_notifier_net {\n\tstruct list_head fib_notifier_ops;\n\tstruct atomic_notifier_head fib_chain;\n};\n\nint call_fib_notifier(struct notifier_block *nb,\n\t\t      enum fib_event_type event_type,\n\t\t      struct fib_notifier_info *info)\n{\n\tint err;\n\n\terr = nb->notifier_call(nb, event_type, info);\n\treturn notifier_to_errno(err);\n}\nEXPORT_SYMBOL(call_fib_notifier);\n\nint call_fib_notifiers(struct net *net, enum fib_event_type event_type,\n\t\t       struct fib_notifier_info *info)\n{\n\tstruct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);\n\tint err;\n\n\terr = atomic_notifier_call_chain(&fn_net->fib_chain, event_type, info);\n\treturn notifier_to_errno(err);\n}\nEXPORT_SYMBOL(call_fib_notifiers);\n\nstatic unsigned int fib_seq_sum(struct net *net)\n{\n\tstruct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);\n\tstruct fib_notifier_ops *ops;\n\tunsigned int fib_seq = 0;\n\n\trtnl_lock();\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ops, &fn_net->fib_notifier_ops, list) {\n\t\tif (!try_module_get(ops->owner))\n\t\t\tcontinue;\n\t\tfib_seq += ops->fib_seq_read(net);\n\t\tmodule_put(ops->owner);\n\t}\n\trcu_read_unlock();\n\trtnl_unlock();\n\n\treturn fib_seq;\n}\n\nstatic int fib_net_dump(struct net *net, struct notifier_block *nb,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);\n\tstruct fib_notifier_ops *ops;\n\tint err = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ops, &fn_net->fib_notifier_ops, list) {\n\t\tif (!try_module_get(ops->owner))\n\t\t\tcontinue;\n\t\terr = ops->fib_dump(net, nb, extack);\n\t\tmodule_put(ops->owner);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\nunlock:\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic bool fib_dump_is_consistent(struct net *net, struct notifier_block *nb,\n\t\t\t\t   void (*cb)(struct notifier_block *nb),\n\t\t\t\t   unsigned int fib_seq)\n{\n\tstruct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);\n\n\tatomic_notifier_chain_register(&fn_net->fib_chain, nb);\n\tif (fib_seq == fib_seq_sum(net))\n\t\treturn true;\n\tatomic_notifier_chain_unregister(&fn_net->fib_chain, nb);\n\tif (cb)\n\t\tcb(nb);\n\treturn false;\n}\n\n#define FIB_DUMP_MAX_RETRIES 5\nint register_fib_notifier(struct net *net, struct notifier_block *nb,\n\t\t\t  void (*cb)(struct notifier_block *nb),\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tint retries = 0;\n\tint err;\n\n\tdo {\n\t\tunsigned int fib_seq = fib_seq_sum(net);\n\n\t\terr = fib_net_dump(net, nb, extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (fib_dump_is_consistent(net, nb, cb, fib_seq))\n\t\t\treturn 0;\n\t} while (++retries < FIB_DUMP_MAX_RETRIES);\n\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL(register_fib_notifier);\n\nint unregister_fib_notifier(struct net *net, struct notifier_block *nb)\n{\n\tstruct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);\n\n\treturn atomic_notifier_chain_unregister(&fn_net->fib_chain, nb);\n}\nEXPORT_SYMBOL(unregister_fib_notifier);\n\nstatic int __fib_notifier_ops_register(struct fib_notifier_ops *ops,\n\t\t\t\t       struct net *net)\n{\n\tstruct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);\n\tstruct fib_notifier_ops *o;\n\n\tlist_for_each_entry(o, &fn_net->fib_notifier_ops, list)\n\t\tif (ops->family == o->family)\n\t\t\treturn -EEXIST;\n\tlist_add_tail_rcu(&ops->list, &fn_net->fib_notifier_ops);\n\treturn 0;\n}\n\nstruct fib_notifier_ops *\nfib_notifier_ops_register(const struct fib_notifier_ops *tmpl, struct net *net)\n{\n\tstruct fib_notifier_ops *ops;\n\tint err;\n\n\tops = kmemdup(tmpl, sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = __fib_notifier_ops_register(ops, net);\n\tif (err)\n\t\tgoto err_register;\n\n\treturn ops;\n\nerr_register:\n\tkfree(ops);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(fib_notifier_ops_register);\n\nvoid fib_notifier_ops_unregister(struct fib_notifier_ops *ops)\n{\n\tlist_del_rcu(&ops->list);\n\tkfree_rcu(ops, rcu);\n}\nEXPORT_SYMBOL(fib_notifier_ops_unregister);\n\nstatic int __net_init fib_notifier_net_init(struct net *net)\n{\n\tstruct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);\n\n\tINIT_LIST_HEAD(&fn_net->fib_notifier_ops);\n\tATOMIC_INIT_NOTIFIER_HEAD(&fn_net->fib_chain);\n\treturn 0;\n}\n\nstatic void __net_exit fib_notifier_net_exit(struct net *net)\n{\n\tstruct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);\n\n\tWARN_ON_ONCE(!list_empty(&fn_net->fib_notifier_ops));\n}\n\nstatic struct pernet_operations fib_notifier_net_ops = {\n\t.init = fib_notifier_net_init,\n\t.exit = fib_notifier_net_exit,\n\t.id = &fib_notifier_net_id,\n\t.size = sizeof(struct fib_notifier_net),\n};\n\nstatic int __init fib_notifier_init(void)\n{\n\treturn register_pernet_subsys(&fib_notifier_net_ops);\n}\n\nsubsys_initcall(fib_notifier_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}