{
  "module_name": "utils.c",
  "hash_id": "2ac16e9a08f179c93b27d5b007b4393fe4871edfd61dbb7ade2cfa431a96250f",
  "original_prompt": "Ingested from linux-6.6.14/net/core/utils.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/inet.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/ratelimit.h>\n#include <linux/socket.h>\n\n#include <net/sock.h>\n#include <net/net_ratelimit.h>\n#include <net/ipv6.h>\n\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n\nDEFINE_RATELIMIT_STATE(net_ratelimit_state, 5 * HZ, 10);\n \nint net_ratelimit(void)\n{\n\treturn __ratelimit(&net_ratelimit_state);\n}\nEXPORT_SYMBOL(net_ratelimit);\n\n \n\n__be32 in_aton(const char *str)\n{\n\tunsigned int l;\n\tunsigned int val;\n\tint i;\n\n\tl = 0;\n\tfor (i = 0; i < 4; i++)\t{\n\t\tl <<= 8;\n\t\tif (*str != '\\0') {\n\t\t\tval = 0;\n\t\t\twhile (*str != '\\0' && *str != '.' && *str != '\\n') {\n\t\t\t\tval *= 10;\n\t\t\t\tval += *str - '0';\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tl |= val;\n\t\t\tif (*str != '\\0')\n\t\t\t\tstr++;\n\t\t}\n\t}\n\treturn htonl(l);\n}\nEXPORT_SYMBOL(in_aton);\n\n#define IN6PTON_XDIGIT\t\t0x00010000\n#define IN6PTON_DIGIT\t\t0x00020000\n#define IN6PTON_COLON_MASK\t0x00700000\n#define IN6PTON_COLON_1\t\t0x00100000\t \n#define IN6PTON_COLON_2\t\t0x00200000\t \n#define IN6PTON_COLON_1_2\t0x00400000\t \n#define IN6PTON_DOT\t\t0x00800000\t \n#define IN6PTON_DELIM\t\t0x10000000\n#define IN6PTON_NULL\t\t0x20000000\t \n#define IN6PTON_UNKNOWN\t\t0x40000000\n\nstatic inline int xdigit2bin(char c, int delim)\n{\n\tint val;\n\n\tif (c == delim || c == '\\0')\n\t\treturn IN6PTON_DELIM;\n\tif (c == ':')\n\t\treturn IN6PTON_COLON_MASK;\n\tif (c == '.')\n\t\treturn IN6PTON_DOT;\n\n\tval = hex_to_bin(c);\n\tif (val >= 0)\n\t\treturn val | IN6PTON_XDIGIT | (val < 10 ? IN6PTON_DIGIT : 0);\n\n\tif (delim == -1)\n\t\treturn IN6PTON_DELIM;\n\treturn IN6PTON_UNKNOWN;\n}\n\n \nint in4_pton(const char *src, int srclen,\n\t     u8 *dst,\n\t     int delim, const char **end)\n{\n\tconst char *s;\n\tu8 *d;\n\tu8 dbuf[4];\n\tint ret = 0;\n\tint i;\n\tint w = 0;\n\n\tif (srclen < 0)\n\t\tsrclen = strlen(src);\n\ts = src;\n\td = dbuf;\n\ti = 0;\n\twhile (1) {\n\t\tint c;\n\t\tc = xdigit2bin(srclen > 0 ? *s : '\\0', delim);\n\t\tif (!(c & (IN6PTON_DIGIT | IN6PTON_DOT | IN6PTON_DELIM | IN6PTON_COLON_MASK))) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (c & (IN6PTON_DOT | IN6PTON_DELIM | IN6PTON_COLON_MASK)) {\n\t\t\tif (w == 0)\n\t\t\t\tgoto out;\n\t\t\t*d++ = w & 0xff;\n\t\t\tw = 0;\n\t\t\ti++;\n\t\t\tif (c & (IN6PTON_DELIM | IN6PTON_COLON_MASK)) {\n\t\t\t\tif (i != 4)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto cont;\n\t\t}\n\t\tw = (w * 10) + c;\n\t\tif ((w & 0xffff) > 255) {\n\t\t\tgoto out;\n\t\t}\ncont:\n\t\tif (i >= 4)\n\t\t\tgoto out;\n\t\ts++;\n\t\tsrclen--;\n\t}\n\tret = 1;\n\tmemcpy(dst, dbuf, sizeof(dbuf));\nout:\n\tif (end)\n\t\t*end = s;\n\treturn ret;\n}\nEXPORT_SYMBOL(in4_pton);\n\n \nint in6_pton(const char *src, int srclen,\n\t     u8 *dst,\n\t     int delim, const char **end)\n{\n\tconst char *s, *tok = NULL;\n\tu8 *d, *dc = NULL;\n\tu8 dbuf[16];\n\tint ret = 0;\n\tint i;\n\tint state = IN6PTON_COLON_1_2 | IN6PTON_XDIGIT | IN6PTON_NULL;\n\tint w = 0;\n\n\tmemset(dbuf, 0, sizeof(dbuf));\n\n\ts = src;\n\td = dbuf;\n\tif (srclen < 0)\n\t\tsrclen = strlen(src);\n\n\twhile (1) {\n\t\tint c;\n\n\t\tc = xdigit2bin(srclen > 0 ? *s : '\\0', delim);\n\t\tif (!(c & state))\n\t\t\tgoto out;\n\t\tif (c & (IN6PTON_DELIM | IN6PTON_COLON_MASK)) {\n\t\t\t \n\t\t\tif (!(state & IN6PTON_NULL)) {\n\t\t\t\t*d++ = (w >> 8) & 0xff;\n\t\t\t\t*d++ = w & 0xff;\n\t\t\t}\n\t\t\tw = 0;\n\t\t\tif (c & IN6PTON_DELIM) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tswitch (state & IN6PTON_COLON_MASK) {\n\t\t\tcase IN6PTON_COLON_2:\n\t\t\t\tdc = d;\n\t\t\t\tstate = IN6PTON_XDIGIT | IN6PTON_DELIM;\n\t\t\t\tif (dc - dbuf >= sizeof(dbuf))\n\t\t\t\t\tstate |= IN6PTON_NULL;\n\t\t\t\tbreak;\n\t\t\tcase IN6PTON_COLON_1|IN6PTON_COLON_1_2:\n\t\t\t\tstate = IN6PTON_XDIGIT | IN6PTON_COLON_2;\n\t\t\t\tbreak;\n\t\t\tcase IN6PTON_COLON_1:\n\t\t\t\tstate = IN6PTON_XDIGIT;\n\t\t\t\tbreak;\n\t\t\tcase IN6PTON_COLON_1_2:\n\t\t\t\tstate = IN6PTON_COLON_2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate = 0;\n\t\t\t}\n\t\t\ttok = s + 1;\n\t\t\tgoto cont;\n\t\t}\n\n\t\tif (c & IN6PTON_DOT) {\n\t\t\tret = in4_pton(tok ? tok : s, srclen + (int)(s - tok), d, delim, &s);\n\t\t\tif (ret > 0) {\n\t\t\t\td += 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tw = (w << 4) | (0xff & c);\n\t\tstate = IN6PTON_COLON_1 | IN6PTON_DELIM;\n\t\tif (!(w & 0xf000)) {\n\t\t\tstate |= IN6PTON_XDIGIT;\n\t\t}\n\t\tif (!dc && d + 2 < dbuf + sizeof(dbuf)) {\n\t\t\tstate |= IN6PTON_COLON_1_2;\n\t\t\tstate &= ~IN6PTON_DELIM;\n\t\t}\n\t\tif (d + 2 >= dbuf + sizeof(dbuf)) {\n\t\t\tstate &= ~(IN6PTON_COLON_1|IN6PTON_COLON_1_2);\n\t\t}\ncont:\n\t\tif ((dc && d + 4 < dbuf + sizeof(dbuf)) ||\n\t\t    d + 4 == dbuf + sizeof(dbuf)) {\n\t\t\tstate |= IN6PTON_DOT;\n\t\t}\n\t\tif (d >= dbuf + sizeof(dbuf)) {\n\t\t\tstate &= ~(IN6PTON_XDIGIT|IN6PTON_COLON_MASK);\n\t\t}\n\t\ts++;\n\t\tsrclen--;\n\t}\n\n\ti = 15; d--;\n\n\tif (dc) {\n\t\twhile (d >= dc)\n\t\t\tdst[i--] = *d--;\n\t\twhile (i >= dc - dbuf)\n\t\t\tdst[i--] = 0;\n\t\twhile (i >= 0)\n\t\t\tdst[i--] = *d--;\n\t} else\n\t\tmemcpy(dst, dbuf, sizeof(dbuf));\n\n\tret = 1;\nout:\n\tif (end)\n\t\t*end = s;\n\treturn ret;\n}\nEXPORT_SYMBOL(in6_pton);\n\nstatic int inet4_pton(const char *src, u16 port_num,\n\t\tstruct sockaddr_storage *addr)\n{\n\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\tsize_t srclen = strlen(src);\n\n\tif (srclen > INET_ADDRSTRLEN)\n\t\treturn -EINVAL;\n\n\tif (in4_pton(src, srclen, (u8 *)&addr4->sin_addr.s_addr,\n\t\t     '\\n', NULL) == 0)\n\t\treturn -EINVAL;\n\n\taddr4->sin_family = AF_INET;\n\taddr4->sin_port = htons(port_num);\n\n\treturn 0;\n}\n\nstatic int inet6_pton(struct net *net, const char *src, u16 port_num,\n\t\tstruct sockaddr_storage *addr)\n{\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\tconst char *scope_delim;\n\tsize_t srclen = strlen(src);\n\n\tif (srclen > INET6_ADDRSTRLEN)\n\t\treturn -EINVAL;\n\n\tif (in6_pton(src, srclen, (u8 *)&addr6->sin6_addr.s6_addr,\n\t\t     '%', &scope_delim) == 0)\n\t\treturn -EINVAL;\n\n\tif (ipv6_addr_type(&addr6->sin6_addr) & IPV6_ADDR_LINKLOCAL &&\n\t    src + srclen != scope_delim && *scope_delim == '%') {\n\t\tstruct net_device *dev;\n\t\tchar scope_id[16];\n\t\tsize_t scope_len = min_t(size_t, sizeof(scope_id) - 1,\n\t\t\t\t\t src + srclen - scope_delim - 1);\n\n\t\tmemcpy(scope_id, scope_delim + 1, scope_len);\n\t\tscope_id[scope_len] = '\\0';\n\n\t\tdev = dev_get_by_name(net, scope_id);\n\t\tif (dev) {\n\t\t\taddr6->sin6_scope_id = dev->ifindex;\n\t\t\tdev_put(dev);\n\t\t} else if (kstrtouint(scope_id, 0, &addr6->sin6_scope_id)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\taddr6->sin6_family = AF_INET6;\n\taddr6->sin6_port = htons(port_num);\n\n\treturn 0;\n}\n\n \nint inet_pton_with_scope(struct net *net, __kernel_sa_family_t af,\n\t\tconst char *src, const char *port, struct sockaddr_storage *addr)\n{\n\tu16 port_num;\n\tint ret = -EINVAL;\n\n\tif (port) {\n\t\tif (kstrtou16(port, 0, &port_num))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tport_num = 0;\n\t}\n\n\tswitch (af) {\n\tcase AF_INET:\n\t\tret = inet4_pton(src, port_num, addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tret = inet6_pton(net, src, port_num, addr);\n\t\tbreak;\n\tcase AF_UNSPEC:\n\t\tret = inet4_pton(src, port_num, addr);\n\t\tif (ret)\n\t\t\tret = inet6_pton(net, src, port_num, addr);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unexpected address family %d\\n\", af);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(inet_pton_with_scope);\n\nbool inet_addr_is_any(struct sockaddr *addr)\n{\n\tif (addr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)addr;\n\t\tconst struct sockaddr_in6 in6_any =\n\t\t\t{ .sin6_addr = IN6ADDR_ANY_INIT };\n\n\t\tif (!memcmp(in6->sin6_addr.s6_addr,\n\t\t\t    in6_any.sin6_addr.s6_addr, 16))\n\t\t\treturn true;\n\t} else if (addr->sa_family == AF_INET) {\n\t\tstruct sockaddr_in *in = (struct sockaddr_in *)addr;\n\n\t\tif (in->sin_addr.s_addr == htonl(INADDR_ANY))\n\t\t\treturn true;\n\t} else {\n\t\tpr_warn(\"unexpected address family %u\\n\", addr->sa_family);\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(inet_addr_is_any);\n\nvoid inet_proto_csum_replace4(__sum16 *sum, struct sk_buff *skb,\n\t\t\t      __be32 from, __be32 to, bool pseudohdr)\n{\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\tcsum_replace4(sum, from, to);\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)\n\t\t\tskb->csum = ~csum_add(csum_sub(~(skb->csum),\n\t\t\t\t\t\t       (__force __wsum)from),\n\t\t\t\t\t      (__force __wsum)to);\n\t} else if (pseudohdr)\n\t\t*sum = ~csum_fold(csum_add(csum_sub(csum_unfold(*sum),\n\t\t\t\t\t\t    (__force __wsum)from),\n\t\t\t\t\t   (__force __wsum)to));\n}\nEXPORT_SYMBOL(inet_proto_csum_replace4);\n\n \nvoid inet_proto_csum_replace16(__sum16 *sum, struct sk_buff *skb,\n\t\t\t       const __be32 *from, const __be32 *to,\n\t\t\t       bool pseudohdr)\n{\n\t__be32 diff[] = {\n\t\t~from[0], ~from[1], ~from[2], ~from[3],\n\t\tto[0], to[1], to[2], to[3],\n\t};\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\t*sum = csum_fold(csum_partial(diff, sizeof(diff),\n\t\t\t\t ~csum_unfold(*sum)));\n\t} else if (pseudohdr)\n\t\t*sum = ~csum_fold(csum_partial(diff, sizeof(diff),\n\t\t\t\t  csum_unfold(*sum)));\n}\nEXPORT_SYMBOL(inet_proto_csum_replace16);\n\nvoid inet_proto_csum_replace_by_diff(__sum16 *sum, struct sk_buff *skb,\n\t\t\t\t     __wsum diff, bool pseudohdr)\n{\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\tcsum_replace_by_diff(sum, diff);\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)\n\t\t\tskb->csum = ~csum_sub(diff, skb->csum);\n\t} else if (pseudohdr) {\n\t\t*sum = ~csum_fold(csum_add(diff, csum_unfold(*sum)));\n\t}\n}\nEXPORT_SYMBOL(inet_proto_csum_replace_by_diff);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}