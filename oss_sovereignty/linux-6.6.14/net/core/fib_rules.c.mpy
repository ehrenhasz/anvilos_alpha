{
  "module_name": "fib_rules.c",
  "hash_id": "c0de0bdc56953b090d5814e1f45ac41f61818d972831b1796d7cb093b23d1f7b",
  "original_prompt": "Ingested from linux-6.6.14/net/core/fib_rules.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/fib_rules.h>\n#include <net/ip_tunnels.h>\n#include <linux/indirect_call_wrapper.h>\n\n#if defined(CONFIG_IPV6) && defined(CONFIG_IPV6_MULTIPLE_TABLES)\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n#define INDIRECT_CALL_MT(f, f2, f1, ...) \\\n\tINDIRECT_CALL_INET(f, f2, f1, __VA_ARGS__)\n#else\n#define INDIRECT_CALL_MT(f, f2, f1, ...) INDIRECT_CALL_1(f, f2, __VA_ARGS__)\n#endif\n#elif defined(CONFIG_IP_MULTIPLE_TABLES)\n#define INDIRECT_CALL_MT(f, f2, f1, ...) INDIRECT_CALL_1(f, f1, __VA_ARGS__)\n#else\n#define INDIRECT_CALL_MT(f, f2, f1, ...) f(__VA_ARGS__)\n#endif\n\nstatic const struct fib_kuid_range fib_kuid_range_unset = {\n\tKUIDT_INIT(0),\n\tKUIDT_INIT(~0),\n};\n\nbool fib_rule_matchall(const struct fib_rule *rule)\n{\n\tif (rule->iifindex || rule->oifindex || rule->mark || rule->tun_id ||\n\t    rule->flags)\n\t\treturn false;\n\tif (rule->suppress_ifgroup != -1 || rule->suppress_prefixlen != -1)\n\t\treturn false;\n\tif (!uid_eq(rule->uid_range.start, fib_kuid_range_unset.start) ||\n\t    !uid_eq(rule->uid_range.end, fib_kuid_range_unset.end))\n\t\treturn false;\n\tif (fib_rule_port_range_set(&rule->sport_range))\n\t\treturn false;\n\tif (fib_rule_port_range_set(&rule->dport_range))\n\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(fib_rule_matchall);\n\nint fib_default_rule_add(struct fib_rules_ops *ops,\n\t\t\t u32 pref, u32 table, u32 flags)\n{\n\tstruct fib_rule *r;\n\n\tr = kzalloc(ops->rule_size, GFP_KERNEL_ACCOUNT);\n\tif (r == NULL)\n\t\treturn -ENOMEM;\n\n\trefcount_set(&r->refcnt, 1);\n\tr->action = FR_ACT_TO_TBL;\n\tr->pref = pref;\n\tr->table = table;\n\tr->flags = flags;\n\tr->proto = RTPROT_KERNEL;\n\tr->fr_net = ops->fro_net;\n\tr->uid_range = fib_kuid_range_unset;\n\n\tr->suppress_prefixlen = -1;\n\tr->suppress_ifgroup = -1;\n\n\t \n\tlist_add_tail(&r->list, &ops->rules_list);\n\treturn 0;\n}\nEXPORT_SYMBOL(fib_default_rule_add);\n\nstatic u32 fib_default_rule_pref(struct fib_rules_ops *ops)\n{\n\tstruct list_head *pos;\n\tstruct fib_rule *rule;\n\n\tif (!list_empty(&ops->rules_list)) {\n\t\tpos = ops->rules_list.next;\n\t\tif (pos->next != &ops->rules_list) {\n\t\t\trule = list_entry(pos->next, struct fib_rule, list);\n\t\t\tif (rule->pref)\n\t\t\t\treturn rule->pref - 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void notify_rule_change(int event, struct fib_rule *rule,\n\t\t\t       struct fib_rules_ops *ops, struct nlmsghdr *nlh,\n\t\t\t       u32 pid);\n\nstatic struct fib_rules_ops *lookup_rules_ops(struct net *net, int family)\n{\n\tstruct fib_rules_ops *ops;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ops, &net->rules_ops, list) {\n\t\tif (ops->family == family) {\n\t\t\tif (!try_module_get(ops->owner))\n\t\t\t\tops = NULL;\n\t\t\trcu_read_unlock();\n\t\t\treturn ops;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic void rules_ops_put(struct fib_rules_ops *ops)\n{\n\tif (ops)\n\t\tmodule_put(ops->owner);\n}\n\nstatic void flush_route_cache(struct fib_rules_ops *ops)\n{\n\tif (ops->flush_cache)\n\t\tops->flush_cache(ops);\n}\n\nstatic int __fib_rules_register(struct fib_rules_ops *ops)\n{\n\tint err = -EEXIST;\n\tstruct fib_rules_ops *o;\n\tstruct net *net;\n\n\tnet = ops->fro_net;\n\n\tif (ops->rule_size < sizeof(struct fib_rule))\n\t\treturn -EINVAL;\n\n\tif (ops->match == NULL || ops->configure == NULL ||\n\t    ops->compare == NULL || ops->fill == NULL ||\n\t    ops->action == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&net->rules_mod_lock);\n\tlist_for_each_entry(o, &net->rules_ops, list)\n\t\tif (ops->family == o->family)\n\t\t\tgoto errout;\n\n\tlist_add_tail_rcu(&ops->list, &net->rules_ops);\n\terr = 0;\nerrout:\n\tspin_unlock(&net->rules_mod_lock);\n\n\treturn err;\n}\n\nstruct fib_rules_ops *\nfib_rules_register(const struct fib_rules_ops *tmpl, struct net *net)\n{\n\tstruct fib_rules_ops *ops;\n\tint err;\n\n\tops = kmemdup(tmpl, sizeof(*ops), GFP_KERNEL);\n\tif (ops == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&ops->rules_list);\n\tops->fro_net = net;\n\n\terr = __fib_rules_register(ops);\n\tif (err) {\n\t\tkfree(ops);\n\t\tops = ERR_PTR(err);\n\t}\n\n\treturn ops;\n}\nEXPORT_SYMBOL_GPL(fib_rules_register);\n\nstatic void fib_rules_cleanup_ops(struct fib_rules_ops *ops)\n{\n\tstruct fib_rule *rule, *tmp;\n\n\tlist_for_each_entry_safe(rule, tmp, &ops->rules_list, list) {\n\t\tlist_del_rcu(&rule->list);\n\t\tif (ops->delete)\n\t\t\tops->delete(rule);\n\t\tfib_rule_put(rule);\n\t}\n}\n\nvoid fib_rules_unregister(struct fib_rules_ops *ops)\n{\n\tstruct net *net = ops->fro_net;\n\n\tspin_lock(&net->rules_mod_lock);\n\tlist_del_rcu(&ops->list);\n\tspin_unlock(&net->rules_mod_lock);\n\n\tfib_rules_cleanup_ops(ops);\n\tkfree_rcu(ops, rcu);\n}\nEXPORT_SYMBOL_GPL(fib_rules_unregister);\n\nstatic int uid_range_set(struct fib_kuid_range *range)\n{\n\treturn uid_valid(range->start) && uid_valid(range->end);\n}\n\nstatic struct fib_kuid_range nla_get_kuid_range(struct nlattr **tb)\n{\n\tstruct fib_rule_uid_range *in;\n\tstruct fib_kuid_range out;\n\n\tin = (struct fib_rule_uid_range *)nla_data(tb[FRA_UID_RANGE]);\n\n\tout.start = make_kuid(current_user_ns(), in->start);\n\tout.end = make_kuid(current_user_ns(), in->end);\n\n\treturn out;\n}\n\nstatic int nla_put_uid_range(struct sk_buff *skb, struct fib_kuid_range *range)\n{\n\tstruct fib_rule_uid_range out = {\n\t\tfrom_kuid_munged(current_user_ns(), range->start),\n\t\tfrom_kuid_munged(current_user_ns(), range->end)\n\t};\n\n\treturn nla_put(skb, FRA_UID_RANGE, sizeof(out), &out);\n}\n\nstatic int nla_get_port_range(struct nlattr *pattr,\n\t\t\t      struct fib_rule_port_range *port_range)\n{\n\tconst struct fib_rule_port_range *pr = nla_data(pattr);\n\n\tif (!fib_rule_port_range_valid(pr))\n\t\treturn -EINVAL;\n\n\tport_range->start = pr->start;\n\tport_range->end = pr->end;\n\n\treturn 0;\n}\n\nstatic int nla_put_port_range(struct sk_buff *skb, int attrtype,\n\t\t\t      struct fib_rule_port_range *range)\n{\n\treturn nla_put(skb, attrtype, sizeof(*range), range);\n}\n\nstatic int fib_rule_match(struct fib_rule *rule, struct fib_rules_ops *ops,\n\t\t\t  struct flowi *fl, int flags,\n\t\t\t  struct fib_lookup_arg *arg)\n{\n\tint ret = 0;\n\n\tif (rule->iifindex && (rule->iifindex != fl->flowi_iif))\n\t\tgoto out;\n\n\tif (rule->oifindex && (rule->oifindex != fl->flowi_oif))\n\t\tgoto out;\n\n\tif ((rule->mark ^ fl->flowi_mark) & rule->mark_mask)\n\t\tgoto out;\n\n\tif (rule->tun_id && (rule->tun_id != fl->flowi_tun_key.tun_id))\n\t\tgoto out;\n\n\tif (rule->l3mdev && !l3mdev_fib_rule_match(rule->fr_net, fl, arg))\n\t\tgoto out;\n\n\tif (uid_lt(fl->flowi_uid, rule->uid_range.start) ||\n\t    uid_gt(fl->flowi_uid, rule->uid_range.end))\n\t\tgoto out;\n\n\tret = INDIRECT_CALL_MT(ops->match,\n\t\t\t       fib6_rule_match,\n\t\t\t       fib4_rule_match,\n\t\t\t       rule, fl, flags);\nout:\n\treturn (rule->flags & FIB_RULE_INVERT) ? !ret : ret;\n}\n\nint fib_rules_lookup(struct fib_rules_ops *ops, struct flowi *fl,\n\t\t     int flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib_rule *rule;\n\tint err;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(rule, &ops->rules_list, list) {\njumped:\n\t\tif (!fib_rule_match(rule, ops, fl, flags, arg))\n\t\t\tcontinue;\n\n\t\tif (rule->action == FR_ACT_GOTO) {\n\t\t\tstruct fib_rule *target;\n\n\t\t\ttarget = rcu_dereference(rule->ctarget);\n\t\t\tif (target == NULL) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\trule = target;\n\t\t\t\tgoto jumped;\n\t\t\t}\n\t\t} else if (rule->action == FR_ACT_NOP)\n\t\t\tcontinue;\n\t\telse\n\t\t\terr = INDIRECT_CALL_MT(ops->action,\n\t\t\t\t\t       fib6_rule_action,\n\t\t\t\t\t       fib4_rule_action,\n\t\t\t\t\t       rule, fl, flags, arg);\n\n\t\tif (!err && ops->suppress && INDIRECT_CALL_MT(ops->suppress,\n\t\t\t\t\t\t\t      fib6_rule_suppress,\n\t\t\t\t\t\t\t      fib4_rule_suppress,\n\t\t\t\t\t\t\t      rule, flags, arg))\n\t\t\tcontinue;\n\n\t\tif (err != -EAGAIN) {\n\t\t\tif ((arg->flags & FIB_LOOKUP_NOREF) ||\n\t\t\t    likely(refcount_inc_not_zero(&rule->refcnt))) {\n\t\t\t\targ->rule = rule;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\terr = -ESRCH;\nout:\n\trcu_read_unlock();\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fib_rules_lookup);\n\nstatic int call_fib_rule_notifier(struct notifier_block *nb,\n\t\t\t\t  enum fib_event_type event_type,\n\t\t\t\t  struct fib_rule *rule, int family,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct fib_rule_notifier_info info = {\n\t\t.info.family = family,\n\t\t.info.extack = extack,\n\t\t.rule = rule,\n\t};\n\n\treturn call_fib_notifier(nb, event_type, &info.info);\n}\n\nstatic int call_fib_rule_notifiers(struct net *net,\n\t\t\t\t   enum fib_event_type event_type,\n\t\t\t\t   struct fib_rule *rule,\n\t\t\t\t   struct fib_rules_ops *ops,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct fib_rule_notifier_info info = {\n\t\t.info.family = ops->family,\n\t\t.info.extack = extack,\n\t\t.rule = rule,\n\t};\n\n\tops->fib_rules_seq++;\n\treturn call_fib_notifiers(net, event_type, &info.info);\n}\n\n \nint fib_rules_dump(struct net *net, struct notifier_block *nb, int family,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct fib_rules_ops *ops;\n\tstruct fib_rule *rule;\n\tint err = 0;\n\n\tops = lookup_rules_ops(net, family);\n\tif (!ops)\n\t\treturn -EAFNOSUPPORT;\n\tlist_for_each_entry_rcu(rule, &ops->rules_list, list) {\n\t\terr = call_fib_rule_notifier(nb, FIB_EVENT_RULE_ADD,\n\t\t\t\t\t     rule, family, extack);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\trules_ops_put(ops);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fib_rules_dump);\n\nunsigned int fib_rules_seq_read(struct net *net, int family)\n{\n\tunsigned int fib_rules_seq;\n\tstruct fib_rules_ops *ops;\n\n\tASSERT_RTNL();\n\n\tops = lookup_rules_ops(net, family);\n\tif (!ops)\n\t\treturn 0;\n\tfib_rules_seq = ops->fib_rules_seq;\n\trules_ops_put(ops);\n\n\treturn fib_rules_seq;\n}\nEXPORT_SYMBOL_GPL(fib_rules_seq_read);\n\nstatic struct fib_rule *rule_find(struct fib_rules_ops *ops,\n\t\t\t\t  struct fib_rule_hdr *frh,\n\t\t\t\t  struct nlattr **tb,\n\t\t\t\t  struct fib_rule *rule,\n\t\t\t\t  bool user_priority)\n{\n\tstruct fib_rule *r;\n\n\tlist_for_each_entry(r, &ops->rules_list, list) {\n\t\tif (rule->action && r->action != rule->action)\n\t\t\tcontinue;\n\n\t\tif (rule->table && r->table != rule->table)\n\t\t\tcontinue;\n\n\t\tif (user_priority && r->pref != rule->pref)\n\t\t\tcontinue;\n\n\t\tif (rule->iifname[0] &&\n\t\t    memcmp(r->iifname, rule->iifname, IFNAMSIZ))\n\t\t\tcontinue;\n\n\t\tif (rule->oifname[0] &&\n\t\t    memcmp(r->oifname, rule->oifname, IFNAMSIZ))\n\t\t\tcontinue;\n\n\t\tif (rule->mark && r->mark != rule->mark)\n\t\t\tcontinue;\n\n\t\tif (rule->suppress_ifgroup != -1 &&\n\t\t    r->suppress_ifgroup != rule->suppress_ifgroup)\n\t\t\tcontinue;\n\n\t\tif (rule->suppress_prefixlen != -1 &&\n\t\t    r->suppress_prefixlen != rule->suppress_prefixlen)\n\t\t\tcontinue;\n\n\t\tif (rule->mark_mask && r->mark_mask != rule->mark_mask)\n\t\t\tcontinue;\n\n\t\tif (rule->tun_id && r->tun_id != rule->tun_id)\n\t\t\tcontinue;\n\n\t\tif (r->fr_net != rule->fr_net)\n\t\t\tcontinue;\n\n\t\tif (rule->l3mdev && r->l3mdev != rule->l3mdev)\n\t\t\tcontinue;\n\n\t\tif (uid_range_set(&rule->uid_range) &&\n\t\t    (!uid_eq(r->uid_range.start, rule->uid_range.start) ||\n\t\t    !uid_eq(r->uid_range.end, rule->uid_range.end)))\n\t\t\tcontinue;\n\n\t\tif (rule->ip_proto && r->ip_proto != rule->ip_proto)\n\t\t\tcontinue;\n\n\t\tif (rule->proto && r->proto != rule->proto)\n\t\t\tcontinue;\n\n\t\tif (fib_rule_port_range_set(&rule->sport_range) &&\n\t\t    !fib_rule_port_range_compare(&r->sport_range,\n\t\t\t\t\t\t &rule->sport_range))\n\t\t\tcontinue;\n\n\t\tif (fib_rule_port_range_set(&rule->dport_range) &&\n\t\t    !fib_rule_port_range_compare(&r->dport_range,\n\t\t\t\t\t\t &rule->dport_range))\n\t\t\tcontinue;\n\n\t\tif (!ops->compare(r, frh, tb))\n\t\t\tcontinue;\n\t\treturn r;\n\t}\n\n\treturn NULL;\n}\n\n#ifdef CONFIG_NET_L3_MASTER_DEV\nstatic int fib_nl2rule_l3mdev(struct nlattr *nla, struct fib_rule *nlrule,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tnlrule->l3mdev = nla_get_u8(nla);\n\tif (nlrule->l3mdev != 1) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid l3mdev attribute\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int fib_nl2rule_l3mdev(struct nlattr *nla, struct fib_rule *nlrule,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tNL_SET_ERR_MSG(extack, \"l3mdev support is not enabled in kernel\");\n\treturn -1;\n}\n#endif\n\nstatic int fib_nl2rule(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t       struct netlink_ext_ack *extack,\n\t\t       struct fib_rules_ops *ops,\n\t\t       struct nlattr *tb[],\n\t\t       struct fib_rule **rule,\n\t\t       bool *user_priority)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib_rule_hdr *frh = nlmsg_data(nlh);\n\tstruct fib_rule *nlrule = NULL;\n\tint err = -EINVAL;\n\n\tif (frh->src_len)\n\t\tif (!tb[FRA_SRC] ||\n\t\t    frh->src_len > (ops->addr_size * 8) ||\n\t\t    nla_len(tb[FRA_SRC]) != ops->addr_size) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid source address\");\n\t\t\tgoto errout;\n\t}\n\n\tif (frh->dst_len)\n\t\tif (!tb[FRA_DST] ||\n\t\t    frh->dst_len > (ops->addr_size * 8) ||\n\t\t    nla_len(tb[FRA_DST]) != ops->addr_size) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid dst address\");\n\t\t\tgoto errout;\n\t}\n\n\tnlrule = kzalloc(ops->rule_size, GFP_KERNEL_ACCOUNT);\n\tif (!nlrule) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\trefcount_set(&nlrule->refcnt, 1);\n\tnlrule->fr_net = net;\n\n\tif (tb[FRA_PRIORITY]) {\n\t\tnlrule->pref = nla_get_u32(tb[FRA_PRIORITY]);\n\t\t*user_priority = true;\n\t} else {\n\t\tnlrule->pref = fib_default_rule_pref(ops);\n\t}\n\n\tnlrule->proto = tb[FRA_PROTOCOL] ?\n\t\tnla_get_u8(tb[FRA_PROTOCOL]) : RTPROT_UNSPEC;\n\n\tif (tb[FRA_IIFNAME]) {\n\t\tstruct net_device *dev;\n\n\t\tnlrule->iifindex = -1;\n\t\tnla_strscpy(nlrule->iifname, tb[FRA_IIFNAME], IFNAMSIZ);\n\t\tdev = __dev_get_by_name(net, nlrule->iifname);\n\t\tif (dev)\n\t\t\tnlrule->iifindex = dev->ifindex;\n\t}\n\n\tif (tb[FRA_OIFNAME]) {\n\t\tstruct net_device *dev;\n\n\t\tnlrule->oifindex = -1;\n\t\tnla_strscpy(nlrule->oifname, tb[FRA_OIFNAME], IFNAMSIZ);\n\t\tdev = __dev_get_by_name(net, nlrule->oifname);\n\t\tif (dev)\n\t\t\tnlrule->oifindex = dev->ifindex;\n\t}\n\n\tif (tb[FRA_FWMARK]) {\n\t\tnlrule->mark = nla_get_u32(tb[FRA_FWMARK]);\n\t\tif (nlrule->mark)\n\t\t\t \n\t\t\tnlrule->mark_mask = 0xFFFFFFFF;\n\t}\n\n\tif (tb[FRA_FWMASK])\n\t\tnlrule->mark_mask = nla_get_u32(tb[FRA_FWMASK]);\n\n\tif (tb[FRA_TUN_ID])\n\t\tnlrule->tun_id = nla_get_be64(tb[FRA_TUN_ID]);\n\n\terr = -EINVAL;\n\tif (tb[FRA_L3MDEV] &&\n\t    fib_nl2rule_l3mdev(tb[FRA_L3MDEV], nlrule, extack) < 0)\n\t\tgoto errout_free;\n\n\tnlrule->action = frh->action;\n\tnlrule->flags = frh->flags;\n\tnlrule->table = frh_get_table(frh, tb);\n\tif (tb[FRA_SUPPRESS_PREFIXLEN])\n\t\tnlrule->suppress_prefixlen = nla_get_u32(tb[FRA_SUPPRESS_PREFIXLEN]);\n\telse\n\t\tnlrule->suppress_prefixlen = -1;\n\n\tif (tb[FRA_SUPPRESS_IFGROUP])\n\t\tnlrule->suppress_ifgroup = nla_get_u32(tb[FRA_SUPPRESS_IFGROUP]);\n\telse\n\t\tnlrule->suppress_ifgroup = -1;\n\n\tif (tb[FRA_GOTO]) {\n\t\tif (nlrule->action != FR_ACT_GOTO) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Unexpected goto\");\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tnlrule->target = nla_get_u32(tb[FRA_GOTO]);\n\t\t \n\t\tif (nlrule->target <= nlrule->pref) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Backward goto not supported\");\n\t\t\tgoto errout_free;\n\t\t}\n\t} else if (nlrule->action == FR_ACT_GOTO) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing goto target for action goto\");\n\t\tgoto errout_free;\n\t}\n\n\tif (nlrule->l3mdev && nlrule->table) {\n\t\tNL_SET_ERR_MSG(extack, \"l3mdev and table are mutually exclusive\");\n\t\tgoto errout_free;\n\t}\n\n\tif (tb[FRA_UID_RANGE]) {\n\t\tif (current_user_ns() != net->user_ns) {\n\t\t\terr = -EPERM;\n\t\t\tNL_SET_ERR_MSG(extack, \"No permission to set uid\");\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tnlrule->uid_range = nla_get_kuid_range(tb);\n\n\t\tif (!uid_range_set(&nlrule->uid_range) ||\n\t\t    !uid_lte(nlrule->uid_range.start, nlrule->uid_range.end)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid uid range\");\n\t\t\tgoto errout_free;\n\t\t}\n\t} else {\n\t\tnlrule->uid_range = fib_kuid_range_unset;\n\t}\n\n\tif (tb[FRA_IP_PROTO])\n\t\tnlrule->ip_proto = nla_get_u8(tb[FRA_IP_PROTO]);\n\n\tif (tb[FRA_SPORT_RANGE]) {\n\t\terr = nla_get_port_range(tb[FRA_SPORT_RANGE],\n\t\t\t\t\t &nlrule->sport_range);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid sport range\");\n\t\t\tgoto errout_free;\n\t\t}\n\t}\n\n\tif (tb[FRA_DPORT_RANGE]) {\n\t\terr = nla_get_port_range(tb[FRA_DPORT_RANGE],\n\t\t\t\t\t &nlrule->dport_range);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid dport range\");\n\t\t\tgoto errout_free;\n\t\t}\n\t}\n\n\t*rule = nlrule;\n\n\treturn 0;\n\nerrout_free:\n\tkfree(nlrule);\nerrout:\n\treturn err;\n}\n\nstatic int rule_exists(struct fib_rules_ops *ops, struct fib_rule_hdr *frh,\n\t\t       struct nlattr **tb, struct fib_rule *rule)\n{\n\tstruct fib_rule *r;\n\n\tlist_for_each_entry(r, &ops->rules_list, list) {\n\t\tif (r->action != rule->action)\n\t\t\tcontinue;\n\n\t\tif (r->table != rule->table)\n\t\t\tcontinue;\n\n\t\tif (r->pref != rule->pref)\n\t\t\tcontinue;\n\n\t\tif (memcmp(r->iifname, rule->iifname, IFNAMSIZ))\n\t\t\tcontinue;\n\n\t\tif (memcmp(r->oifname, rule->oifname, IFNAMSIZ))\n\t\t\tcontinue;\n\n\t\tif (r->mark != rule->mark)\n\t\t\tcontinue;\n\n\t\tif (r->suppress_ifgroup != rule->suppress_ifgroup)\n\t\t\tcontinue;\n\n\t\tif (r->suppress_prefixlen != rule->suppress_prefixlen)\n\t\t\tcontinue;\n\n\t\tif (r->mark_mask != rule->mark_mask)\n\t\t\tcontinue;\n\n\t\tif (r->tun_id != rule->tun_id)\n\t\t\tcontinue;\n\n\t\tif (r->fr_net != rule->fr_net)\n\t\t\tcontinue;\n\n\t\tif (r->l3mdev != rule->l3mdev)\n\t\t\tcontinue;\n\n\t\tif (!uid_eq(r->uid_range.start, rule->uid_range.start) ||\n\t\t    !uid_eq(r->uid_range.end, rule->uid_range.end))\n\t\t\tcontinue;\n\n\t\tif (r->ip_proto != rule->ip_proto)\n\t\t\tcontinue;\n\n\t\tif (r->proto != rule->proto)\n\t\t\tcontinue;\n\n\t\tif (!fib_rule_port_range_compare(&r->sport_range,\n\t\t\t\t\t\t &rule->sport_range))\n\t\t\tcontinue;\n\n\t\tif (!fib_rule_port_range_compare(&r->dport_range,\n\t\t\t\t\t\t &rule->dport_range))\n\t\t\tcontinue;\n\n\t\tif (!ops->compare(r, frh, tb))\n\t\t\tcontinue;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const struct nla_policy fib_rule_policy[FRA_MAX + 1] = {\n\t[FRA_UNSPEC]\t= { .strict_start_type = FRA_DPORT_RANGE + 1 },\n\t[FRA_IIFNAME]\t= { .type = NLA_STRING, .len = IFNAMSIZ - 1 },\n\t[FRA_OIFNAME]\t= { .type = NLA_STRING, .len = IFNAMSIZ - 1 },\n\t[FRA_PRIORITY]\t= { .type = NLA_U32 },\n\t[FRA_FWMARK]\t= { .type = NLA_U32 },\n\t[FRA_FLOW]\t= { .type = NLA_U32 },\n\t[FRA_TUN_ID]\t= { .type = NLA_U64 },\n\t[FRA_FWMASK]\t= { .type = NLA_U32 },\n\t[FRA_TABLE]     = { .type = NLA_U32 },\n\t[FRA_SUPPRESS_PREFIXLEN] = { .type = NLA_U32 },\n\t[FRA_SUPPRESS_IFGROUP] = { .type = NLA_U32 },\n\t[FRA_GOTO]\t= { .type = NLA_U32 },\n\t[FRA_L3MDEV]\t= { .type = NLA_U8 },\n\t[FRA_UID_RANGE]\t= { .len = sizeof(struct fib_rule_uid_range) },\n\t[FRA_PROTOCOL]  = { .type = NLA_U8 },\n\t[FRA_IP_PROTO]  = { .type = NLA_U8 },\n\t[FRA_SPORT_RANGE] = { .len = sizeof(struct fib_rule_port_range) },\n\t[FRA_DPORT_RANGE] = { .len = sizeof(struct fib_rule_port_range) }\n};\n\nint fib_nl_newrule(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib_rule_hdr *frh = nlmsg_data(nlh);\n\tstruct fib_rules_ops *ops = NULL;\n\tstruct fib_rule *rule = NULL, *r, *last = NULL;\n\tstruct nlattr *tb[FRA_MAX + 1];\n\tint err = -EINVAL, unresolved = 0;\n\tbool user_priority = false;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid msg length\");\n\t\tgoto errout;\n\t}\n\n\tops = lookup_rules_ops(net, frh->family);\n\tif (!ops) {\n\t\terr = -EAFNOSUPPORT;\n\t\tNL_SET_ERR_MSG(extack, \"Rule family not supported\");\n\t\tgoto errout;\n\t}\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*frh), tb, FRA_MAX,\n\t\t\t\t     fib_rule_policy, extack);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Error parsing msg\");\n\t\tgoto errout;\n\t}\n\n\terr = fib_nl2rule(skb, nlh, extack, ops, tb, &rule, &user_priority);\n\tif (err)\n\t\tgoto errout;\n\n\tif ((nlh->nlmsg_flags & NLM_F_EXCL) &&\n\t    rule_exists(ops, frh, tb, rule)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_free;\n\t}\n\n\terr = ops->configure(rule, skb, frh, tb, extack);\n\tif (err < 0)\n\t\tgoto errout_free;\n\n\terr = call_fib_rule_notifiers(net, FIB_EVENT_RULE_ADD, rule, ops,\n\t\t\t\t      extack);\n\tif (err < 0)\n\t\tgoto errout_free;\n\n\tlist_for_each_entry(r, &ops->rules_list, list) {\n\t\tif (r->pref == rule->target) {\n\t\t\tRCU_INIT_POINTER(rule->ctarget, r);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rcu_dereference_protected(rule->ctarget, 1) == NULL)\n\t\tunresolved = 1;\n\n\tlist_for_each_entry(r, &ops->rules_list, list) {\n\t\tif (r->pref > rule->pref)\n\t\t\tbreak;\n\t\tlast = r;\n\t}\n\n\tif (last)\n\t\tlist_add_rcu(&rule->list, &last->list);\n\telse\n\t\tlist_add_rcu(&rule->list, &ops->rules_list);\n\n\tif (ops->unresolved_rules) {\n\t\t \n\t\tlist_for_each_entry(r, &ops->rules_list, list) {\n\t\t\tif (r->action == FR_ACT_GOTO &&\n\t\t\t    r->target == rule->pref &&\n\t\t\t    rtnl_dereference(r->ctarget) == NULL) {\n\t\t\t\trcu_assign_pointer(r->ctarget, rule);\n\t\t\t\tif (--ops->unresolved_rules == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rule->action == FR_ACT_GOTO)\n\t\tops->nr_goto_rules++;\n\n\tif (unresolved)\n\t\tops->unresolved_rules++;\n\n\tif (rule->tun_id)\n\t\tip_tunnel_need_metadata();\n\n\tnotify_rule_change(RTM_NEWRULE, rule, ops, nlh, NETLINK_CB(skb).portid);\n\tflush_route_cache(ops);\n\trules_ops_put(ops);\n\treturn 0;\n\nerrout_free:\n\tkfree(rule);\nerrout:\n\trules_ops_put(ops);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fib_nl_newrule);\n\nint fib_nl_delrule(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib_rule_hdr *frh = nlmsg_data(nlh);\n\tstruct fib_rules_ops *ops = NULL;\n\tstruct fib_rule *rule = NULL, *r, *nlrule = NULL;\n\tstruct nlattr *tb[FRA_MAX+1];\n\tint err = -EINVAL;\n\tbool user_priority = false;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid msg length\");\n\t\tgoto errout;\n\t}\n\n\tops = lookup_rules_ops(net, frh->family);\n\tif (ops == NULL) {\n\t\terr = -EAFNOSUPPORT;\n\t\tNL_SET_ERR_MSG(extack, \"Rule family not supported\");\n\t\tgoto errout;\n\t}\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*frh), tb, FRA_MAX,\n\t\t\t\t     fib_rule_policy, extack);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Error parsing msg\");\n\t\tgoto errout;\n\t}\n\n\terr = fib_nl2rule(skb, nlh, extack, ops, tb, &nlrule, &user_priority);\n\tif (err)\n\t\tgoto errout;\n\n\trule = rule_find(ops, frh, tb, nlrule, user_priority);\n\tif (!rule) {\n\t\terr = -ENOENT;\n\t\tgoto errout;\n\t}\n\n\tif (rule->flags & FIB_RULE_PERMANENT) {\n\t\terr = -EPERM;\n\t\tgoto errout;\n\t}\n\n\tif (ops->delete) {\n\t\terr = ops->delete(rule);\n\t\tif (err)\n\t\t\tgoto errout;\n\t}\n\n\tif (rule->tun_id)\n\t\tip_tunnel_unneed_metadata();\n\n\tlist_del_rcu(&rule->list);\n\n\tif (rule->action == FR_ACT_GOTO) {\n\t\tops->nr_goto_rules--;\n\t\tif (rtnl_dereference(rule->ctarget) == NULL)\n\t\t\tops->unresolved_rules--;\n\t}\n\n\t \n\tif (ops->nr_goto_rules > 0) {\n\t\tstruct fib_rule *n;\n\n\t\tn = list_next_entry(rule, list);\n\t\tif (&n->list == &ops->rules_list || n->pref != rule->pref)\n\t\t\tn = NULL;\n\t\tlist_for_each_entry(r, &ops->rules_list, list) {\n\t\t\tif (rtnl_dereference(r->ctarget) != rule)\n\t\t\t\tcontinue;\n\t\t\trcu_assign_pointer(r->ctarget, n);\n\t\t\tif (!n)\n\t\t\t\tops->unresolved_rules++;\n\t\t}\n\t}\n\n\tcall_fib_rule_notifiers(net, FIB_EVENT_RULE_DEL, rule, ops,\n\t\t\t\tNULL);\n\tnotify_rule_change(RTM_DELRULE, rule, ops, nlh,\n\t\t\t   NETLINK_CB(skb).portid);\n\tfib_rule_put(rule);\n\tflush_route_cache(ops);\n\trules_ops_put(ops);\n\tkfree(nlrule);\n\treturn 0;\n\nerrout:\n\tkfree(nlrule);\n\trules_ops_put(ops);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fib_nl_delrule);\n\nstatic inline size_t fib_rule_nlmsg_size(struct fib_rules_ops *ops,\n\t\t\t\t\t struct fib_rule *rule)\n{\n\tsize_t payload = NLMSG_ALIGN(sizeof(struct fib_rule_hdr))\n\t\t\t + nla_total_size(IFNAMSIZ)  \n\t\t\t + nla_total_size(IFNAMSIZ)  \n\t\t\t + nla_total_size(4)  \n\t\t\t + nla_total_size(4)  \n\t\t\t + nla_total_size(4)  \n\t\t\t + nla_total_size(4)  \n\t\t\t + nla_total_size(4)  \n\t\t\t + nla_total_size(4)  \n\t\t\t + nla_total_size_64bit(8)  \n\t\t\t + nla_total_size(sizeof(struct fib_kuid_range))\n\t\t\t + nla_total_size(1)  \n\t\t\t + nla_total_size(1)  \n\t\t\t + nla_total_size(sizeof(struct fib_rule_port_range))  \n\t\t\t + nla_total_size(sizeof(struct fib_rule_port_range));  \n\n\tif (ops->nlmsg_payload)\n\t\tpayload += ops->nlmsg_payload(rule);\n\n\treturn payload;\n}\n\nstatic int fib_nl_fill_rule(struct sk_buff *skb, struct fib_rule *rule,\n\t\t\t    u32 pid, u32 seq, int type, int flags,\n\t\t\t    struct fib_rules_ops *ops)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct fib_rule_hdr *frh;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*frh), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tfrh = nlmsg_data(nlh);\n\tfrh->family = ops->family;\n\tfrh->table = rule->table < 256 ? rule->table : RT_TABLE_COMPAT;\n\tif (nla_put_u32(skb, FRA_TABLE, rule->table))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, FRA_SUPPRESS_PREFIXLEN, rule->suppress_prefixlen))\n\t\tgoto nla_put_failure;\n\tfrh->res1 = 0;\n\tfrh->res2 = 0;\n\tfrh->action = rule->action;\n\tfrh->flags = rule->flags;\n\n\tif (nla_put_u8(skb, FRA_PROTOCOL, rule->proto))\n\t\tgoto nla_put_failure;\n\n\tif (rule->action == FR_ACT_GOTO &&\n\t    rcu_access_pointer(rule->ctarget) == NULL)\n\t\tfrh->flags |= FIB_RULE_UNRESOLVED;\n\n\tif (rule->iifname[0]) {\n\t\tif (nla_put_string(skb, FRA_IIFNAME, rule->iifname))\n\t\t\tgoto nla_put_failure;\n\t\tif (rule->iifindex == -1)\n\t\t\tfrh->flags |= FIB_RULE_IIF_DETACHED;\n\t}\n\n\tif (rule->oifname[0]) {\n\t\tif (nla_put_string(skb, FRA_OIFNAME, rule->oifname))\n\t\t\tgoto nla_put_failure;\n\t\tif (rule->oifindex == -1)\n\t\t\tfrh->flags |= FIB_RULE_OIF_DETACHED;\n\t}\n\n\tif ((rule->pref &&\n\t     nla_put_u32(skb, FRA_PRIORITY, rule->pref)) ||\n\t    (rule->mark &&\n\t     nla_put_u32(skb, FRA_FWMARK, rule->mark)) ||\n\t    ((rule->mark_mask || rule->mark) &&\n\t     nla_put_u32(skb, FRA_FWMASK, rule->mark_mask)) ||\n\t    (rule->target &&\n\t     nla_put_u32(skb, FRA_GOTO, rule->target)) ||\n\t    (rule->tun_id &&\n\t     nla_put_be64(skb, FRA_TUN_ID, rule->tun_id, FRA_PAD)) ||\n\t    (rule->l3mdev &&\n\t     nla_put_u8(skb, FRA_L3MDEV, rule->l3mdev)) ||\n\t    (uid_range_set(&rule->uid_range) &&\n\t     nla_put_uid_range(skb, &rule->uid_range)) ||\n\t    (fib_rule_port_range_set(&rule->sport_range) &&\n\t     nla_put_port_range(skb, FRA_SPORT_RANGE, &rule->sport_range)) ||\n\t    (fib_rule_port_range_set(&rule->dport_range) &&\n\t     nla_put_port_range(skb, FRA_DPORT_RANGE, &rule->dport_range)) ||\n\t    (rule->ip_proto && nla_put_u8(skb, FRA_IP_PROTO, rule->ip_proto)))\n\t\tgoto nla_put_failure;\n\n\tif (rule->suppress_ifgroup != -1) {\n\t\tif (nla_put_u32(skb, FRA_SUPPRESS_IFGROUP, rule->suppress_ifgroup))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->fill(rule, skb, frh) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int dump_rules(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t      struct fib_rules_ops *ops)\n{\n\tint idx = 0;\n\tstruct fib_rule *rule;\n\tint err = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(rule, &ops->rules_list, list) {\n\t\tif (idx < cb->args[1])\n\t\t\tgoto skip;\n\n\t\terr = fib_nl_fill_rule(skb, rule, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, RTM_NEWRULE,\n\t\t\t\t       NLM_F_MULTI, ops);\n\t\tif (err)\n\t\t\tbreak;\nskip:\n\t\tidx++;\n\t}\n\trcu_read_unlock();\n\tcb->args[1] = idx;\n\trules_ops_put(ops);\n\n\treturn err;\n}\n\nstatic int fib_valid_dumprule_req(const struct nlmsghdr *nlh,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct fib_rule_hdr *frh;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for fib rule dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tfrh = nlmsg_data(nlh);\n\tif (frh->dst_len || frh->src_len || frh->tos || frh->table ||\n\t    frh->res1 || frh->res2 || frh->action || frh->flags) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid values in header for fib rule dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nlmsg_attrlen(nlh, sizeof(*frh))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid data after header in fib rule dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fib_nl_dumprule(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib_rules_ops *ops;\n\tint idx = 0, family;\n\n\tif (cb->strict_check) {\n\t\tint err = fib_valid_dumprule_req(nlh, cb->extack);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfamily = rtnl_msg_family(nlh);\n\tif (family != AF_UNSPEC) {\n\t\t \n\t\tops = lookup_rules_ops(net, family);\n\t\tif (ops == NULL)\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\tdump_rules(skb, cb, ops);\n\n\t\treturn skb->len;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ops, &net->rules_ops, list) {\n\t\tif (idx < cb->args[0] || !try_module_get(ops->owner))\n\t\t\tgoto skip;\n\n\t\tif (dump_rules(skb, cb, ops) < 0)\n\t\t\tbreak;\n\n\t\tcb->args[1] = 0;\nskip:\n\t\tidx++;\n\t}\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}\n\nstatic void notify_rule_change(int event, struct fib_rule *rule,\n\t\t\t       struct fib_rules_ops *ops, struct nlmsghdr *nlh,\n\t\t\t       u32 pid)\n{\n\tstruct net *net;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\tnet = ops->fro_net;\n\tskb = nlmsg_new(fib_rule_nlmsg_size(ops, rule), GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = fib_nl_fill_rule(skb, rule, pid, nlh->nlmsg_seq, event, 0, ops);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, pid, ops->nlgroup, nlh, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, ops->nlgroup, err);\n}\n\nstatic void attach_rules(struct list_head *rules, struct net_device *dev)\n{\n\tstruct fib_rule *rule;\n\n\tlist_for_each_entry(rule, rules, list) {\n\t\tif (rule->iifindex == -1 &&\n\t\t    strcmp(dev->name, rule->iifname) == 0)\n\t\t\trule->iifindex = dev->ifindex;\n\t\tif (rule->oifindex == -1 &&\n\t\t    strcmp(dev->name, rule->oifname) == 0)\n\t\t\trule->oifindex = dev->ifindex;\n\t}\n}\n\nstatic void detach_rules(struct list_head *rules, struct net_device *dev)\n{\n\tstruct fib_rule *rule;\n\n\tlist_for_each_entry(rule, rules, list) {\n\t\tif (rule->iifindex == dev->ifindex)\n\t\t\trule->iifindex = -1;\n\t\tif (rule->oifindex == dev->ifindex)\n\t\t\trule->oifindex = -1;\n\t}\n}\n\n\nstatic int fib_rules_event(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\tstruct fib_rules_ops *ops;\n\n\tASSERT_RTNL();\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\tlist_for_each_entry(ops, &net->rules_ops, list)\n\t\t\tattach_rules(&ops->rules_list, dev);\n\t\tbreak;\n\n\tcase NETDEV_CHANGENAME:\n\t\tlist_for_each_entry(ops, &net->rules_ops, list) {\n\t\t\tdetach_rules(&ops->rules_list, dev);\n\t\t\tattach_rules(&ops->rules_list, dev);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_UNREGISTER:\n\t\tlist_for_each_entry(ops, &net->rules_ops, list)\n\t\t\tdetach_rules(&ops->rules_list, dev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block fib_rules_notifier = {\n\t.notifier_call = fib_rules_event,\n};\n\nstatic int __net_init fib_rules_net_init(struct net *net)\n{\n\tINIT_LIST_HEAD(&net->rules_ops);\n\tspin_lock_init(&net->rules_mod_lock);\n\treturn 0;\n}\n\nstatic void __net_exit fib_rules_net_exit(struct net *net)\n{\n\tWARN_ON_ONCE(!list_empty(&net->rules_ops));\n}\n\nstatic struct pernet_operations fib_rules_net_ops = {\n\t.init = fib_rules_net_init,\n\t.exit = fib_rules_net_exit,\n};\n\nstatic int __init fib_rules_init(void)\n{\n\tint err;\n\trtnl_register(PF_UNSPEC, RTM_NEWRULE, fib_nl_newrule, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELRULE, fib_nl_delrule, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETRULE, NULL, fib_nl_dumprule, 0);\n\n\terr = register_pernet_subsys(&fib_rules_net_ops);\n\tif (err < 0)\n\t\tgoto fail;\n\n\terr = register_netdevice_notifier(&fib_rules_notifier);\n\tif (err < 0)\n\t\tgoto fail_unregister;\n\n\treturn 0;\n\nfail_unregister:\n\tunregister_pernet_subsys(&fib_rules_net_ops);\nfail:\n\trtnl_unregister(PF_UNSPEC, RTM_NEWRULE);\n\trtnl_unregister(PF_UNSPEC, RTM_DELRULE);\n\trtnl_unregister(PF_UNSPEC, RTM_GETRULE);\n\treturn err;\n}\n\nsubsys_initcall(fib_rules_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}