{
  "module_name": "sysctl_net_core.c",
  "hash_id": "f158cbaf13c4fd63a72ec95963d0b745ded866418dbef0d72c2a95bfddd6de06",
  "original_prompt": "Ingested from linux-6.6.14/net/core/sysctl_net_core.c",
  "human_readable_source": "\n \n\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/socket.h>\n#include <linux/netdevice.h>\n#include <linux/ratelimit.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/sched/isolation.h>\n\n#include <net/ip.h>\n#include <net/sock.h>\n#include <net/net_ratelimit.h>\n#include <net/busy_poll.h>\n#include <net/pkt_sched.h>\n\n#include \"dev.h\"\n\nstatic int int_3600 = 3600;\nstatic int min_sndbuf = SOCK_MIN_SNDBUF;\nstatic int min_rcvbuf = SOCK_MIN_RCVBUF;\nstatic int max_skb_frags = MAX_SKB_FRAGS;\n\nstatic int net_msg_warn;\t \n\nint sysctl_fb_tunnels_only_for_init_net __read_mostly = 0;\nEXPORT_SYMBOL(sysctl_fb_tunnels_only_for_init_net);\n\n \nint sysctl_devconf_inherit_init_net __read_mostly;\nEXPORT_SYMBOL(sysctl_devconf_inherit_init_net);\n\n#if IS_ENABLED(CONFIG_NET_FLOW_LIMIT) || IS_ENABLED(CONFIG_RPS)\nstatic void dump_cpumask(void *buffer, size_t *lenp, loff_t *ppos,\n\t\t\t struct cpumask *mask)\n{\n\tchar kbuf[128];\n\tint len;\n\n\tif (*ppos || !*lenp) {\n\t\t*lenp = 0;\n\t\treturn;\n\t}\n\n\tlen = min(sizeof(kbuf) - 1, *lenp);\n\tlen = scnprintf(kbuf, len, \"%*pb\", cpumask_pr_args(mask));\n\tif (!len) {\n\t\t*lenp = 0;\n\t\treturn;\n\t}\n\n\tif (len < *lenp)\n\t\tkbuf[len++] = '\\n';\n\tmemcpy(buffer, kbuf, len);\n\t*lenp = len;\n\t*ppos += len;\n}\n#endif\n\n#ifdef CONFIG_RPS\n\nstatic struct cpumask *rps_default_mask_cow_alloc(struct net *net)\n{\n\tstruct cpumask *rps_default_mask;\n\n\tif (net->core.rps_default_mask)\n\t\treturn net->core.rps_default_mask;\n\n\trps_default_mask = kzalloc(cpumask_size(), GFP_KERNEL);\n\tif (!rps_default_mask)\n\t\treturn NULL;\n\n\t \n\tWRITE_ONCE(net->core.rps_default_mask, rps_default_mask);\n\treturn rps_default_mask;\n}\n\nstatic int rps_default_mask_sysctl(struct ctl_table *table, int write,\n\t\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = (struct net *)table->data;\n\tint err = 0;\n\n\trtnl_lock();\n\tif (write) {\n\t\tstruct cpumask *rps_default_mask = rps_default_mask_cow_alloc(net);\n\n\t\terr = -ENOMEM;\n\t\tif (!rps_default_mask)\n\t\t\tgoto done;\n\n\t\terr = cpumask_parse(buffer, rps_default_mask);\n\t\tif (err)\n\t\t\tgoto done;\n\n\t\terr = rps_cpumask_housekeeping(rps_default_mask);\n\t\tif (err)\n\t\t\tgoto done;\n\t} else {\n\t\tdump_cpumask(buffer, lenp, ppos,\n\t\t\t     net->core.rps_default_mask ? : cpu_none_mask);\n\t}\n\ndone:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int rps_sock_flow_sysctl(struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tunsigned int orig_size, size;\n\tint ret, i;\n\tstruct ctl_table tmp = {\n\t\t.data = &size,\n\t\t.maxlen = sizeof(size),\n\t\t.mode = table->mode\n\t};\n\tstruct rps_sock_flow_table *orig_sock_table, *sock_table;\n\tstatic DEFINE_MUTEX(sock_flow_mutex);\n\n\tmutex_lock(&sock_flow_mutex);\n\n\torig_sock_table = rcu_dereference_protected(rps_sock_flow_table,\n\t\t\t\t\tlockdep_is_held(&sock_flow_mutex));\n\tsize = orig_size = orig_sock_table ? orig_sock_table->mask + 1 : 0;\n\n\tret = proc_dointvec(&tmp, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\tif (size) {\n\t\t\tif (size > 1<<29) {\n\t\t\t\t \n\t\t\t\tmutex_unlock(&sock_flow_mutex);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsize = roundup_pow_of_two(size);\n\t\t\tif (size != orig_size) {\n\t\t\t\tsock_table =\n\t\t\t\t    vmalloc(RPS_SOCK_FLOW_TABLE_SIZE(size));\n\t\t\t\tif (!sock_table) {\n\t\t\t\t\tmutex_unlock(&sock_flow_mutex);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\trps_cpu_mask = roundup_pow_of_two(nr_cpu_ids) - 1;\n\t\t\t\tsock_table->mask = size - 1;\n\t\t\t} else\n\t\t\t\tsock_table = orig_sock_table;\n\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tsock_table->ents[i] = RPS_NO_CPU;\n\t\t} else\n\t\t\tsock_table = NULL;\n\n\t\tif (sock_table != orig_sock_table) {\n\t\t\trcu_assign_pointer(rps_sock_flow_table, sock_table);\n\t\t\tif (sock_table) {\n\t\t\t\tstatic_branch_inc(&rps_needed);\n\t\t\t\tstatic_branch_inc(&rfs_needed);\n\t\t\t}\n\t\t\tif (orig_sock_table) {\n\t\t\t\tstatic_branch_dec(&rps_needed);\n\t\t\t\tstatic_branch_dec(&rfs_needed);\n\t\t\t\tkvfree_rcu_mightsleep(orig_sock_table);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&sock_flow_mutex);\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_NET_FLOW_LIMIT\nstatic DEFINE_MUTEX(flow_limit_update_mutex);\n\nstatic int flow_limit_cpu_sysctl(struct ctl_table *table, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct sd_flow_limit *cur;\n\tstruct softnet_data *sd;\n\tcpumask_var_t mask;\n\tint i, len, ret = 0;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (write) {\n\t\tret = cpumask_parse(buffer, mask);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tmutex_lock(&flow_limit_update_mutex);\n\t\tlen = sizeof(*cur) + netdev_flow_limit_table_len;\n\t\tfor_each_possible_cpu(i) {\n\t\t\tsd = &per_cpu(softnet_data, i);\n\t\t\tcur = rcu_dereference_protected(sd->flow_limit,\n\t\t\t\t     lockdep_is_held(&flow_limit_update_mutex));\n\t\t\tif (cur && !cpumask_test_cpu(i, mask)) {\n\t\t\t\tRCU_INIT_POINTER(sd->flow_limit, NULL);\n\t\t\t\tkfree_rcu_mightsleep(cur);\n\t\t\t} else if (!cur && cpumask_test_cpu(i, mask)) {\n\t\t\t\tcur = kzalloc_node(len, GFP_KERNEL,\n\t\t\t\t\t\t   cpu_to_node(i));\n\t\t\t\tif (!cur) {\n\t\t\t\t\t \n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto write_unlock;\n\t\t\t\t}\n\t\t\t\tcur->num_buckets = netdev_flow_limit_table_len;\n\t\t\t\trcu_assign_pointer(sd->flow_limit, cur);\n\t\t\t}\n\t\t}\nwrite_unlock:\n\t\tmutex_unlock(&flow_limit_update_mutex);\n\t} else {\n\t\tcpumask_clear(mask);\n\t\trcu_read_lock();\n\t\tfor_each_possible_cpu(i) {\n\t\t\tsd = &per_cpu(softnet_data, i);\n\t\t\tif (rcu_dereference(sd->flow_limit))\n\t\t\t\tcpumask_set_cpu(i, mask);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tdump_cpumask(buffer, lenp, ppos, mask);\n\t}\n\ndone:\n\tfree_cpumask_var(mask);\n\treturn ret;\n}\n\nstatic int flow_limit_table_len_sysctl(struct ctl_table *table, int write,\n\t\t\t\t       void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tunsigned int old, *ptr;\n\tint ret;\n\n\tmutex_lock(&flow_limit_update_mutex);\n\n\tptr = table->data;\n\told = *ptr;\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (!ret && write && !is_power_of_2(*ptr)) {\n\t\t*ptr = old;\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&flow_limit_update_mutex);\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_NET_SCHED\nstatic int set_default_qdisc(struct ctl_table *table, int write,\n\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tchar id[IFNAMSIZ];\n\tstruct ctl_table tbl = {\n\t\t.data = id,\n\t\t.maxlen = IFNAMSIZ,\n\t};\n\tint ret;\n\n\tqdisc_get_default(id, IFNAMSIZ);\n\n\tret = proc_dostring(&tbl, write, buffer, lenp, ppos);\n\tif (write && ret == 0)\n\t\tret = qdisc_set_default(id);\n\treturn ret;\n}\n#endif\n\nstatic int proc_do_dev_weight(struct ctl_table *table, int write,\n\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstatic DEFINE_MUTEX(dev_weight_mutex);\n\tint ret, weight;\n\n\tmutex_lock(&dev_weight_mutex);\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (!ret && write) {\n\t\tweight = READ_ONCE(weight_p);\n\t\tWRITE_ONCE(dev_rx_weight, weight * dev_weight_rx_bias);\n\t\tWRITE_ONCE(dev_tx_weight, weight * dev_weight_tx_bias);\n\t}\n\tmutex_unlock(&dev_weight_mutex);\n\n\treturn ret;\n}\n\nstatic int proc_do_rss_key(struct ctl_table *table, int write,\n\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table fake_table;\n\tchar buf[NETDEV_RSS_KEY_LEN * 3];\n\n\tsnprintf(buf, sizeof(buf), \"%*phC\", NETDEV_RSS_KEY_LEN, netdev_rss_key);\n\tfake_table.data = buf;\n\tfake_table.maxlen = sizeof(buf);\n\treturn proc_dostring(&fake_table, write, buffer, lenp, ppos);\n}\n\n#ifdef CONFIG_BPF_JIT\nstatic int proc_dointvec_minmax_bpf_enable(struct ctl_table *table, int write,\n\t\t\t\t\t   void *buffer, size_t *lenp,\n\t\t\t\t\t   loff_t *ppos)\n{\n\tint ret, jit_enable = *(int *)table->data;\n\tint min = *(int *)table->extra1;\n\tint max = *(int *)table->extra2;\n\tstruct ctl_table tmp = *table;\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\ttmp.data = &jit_enable;\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\tif (write && !ret) {\n\t\tif (jit_enable < 2 ||\n\t\t    (jit_enable == 2 && bpf_dump_raw_ok(current_cred()))) {\n\t\t\t*(int *)table->data = jit_enable;\n\t\t\tif (jit_enable == 2)\n\t\t\t\tpr_warn(\"bpf_jit_enable = 2 was set! NEVER use this in production, only for JIT debugging!\\n\");\n\t\t} else {\n\t\t\tret = -EPERM;\n\t\t}\n\t}\n\n\tif (write && ret && min == max)\n\t\tpr_info_once(\"CONFIG_BPF_JIT_ALWAYS_ON is enabled, bpf_jit_enable is permanently set to 1.\\n\");\n\n\treturn ret;\n}\n\n# ifdef CONFIG_HAVE_EBPF_JIT\nstatic int\nproc_dointvec_minmax_bpf_restricted(struct ctl_table *table, int write,\n\t\t\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n}\n# endif  \n\nstatic int\nproc_dolongvec_minmax_bpf_restricted(struct ctl_table *table, int write,\n\t\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}\n#endif\n\nstatic struct ctl_table net_core_table[] = {\n\t{\n\t\t.procname\t= \"wmem_max\",\n\t\t.data\t\t= &sysctl_wmem_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_sndbuf,\n\t},\n\t{\n\t\t.procname\t= \"rmem_max\",\n\t\t.data\t\t= &sysctl_rmem_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_rcvbuf,\n\t},\n\t{\n\t\t.procname\t= \"wmem_default\",\n\t\t.data\t\t= &sysctl_wmem_default,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_sndbuf,\n\t},\n\t{\n\t\t.procname\t= \"rmem_default\",\n\t\t.data\t\t= &sysctl_rmem_default,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_rcvbuf,\n\t},\n\t{\n\t\t.procname\t= \"dev_weight\",\n\t\t.data\t\t= &weight_p,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_dev_weight,\n\t},\n\t{\n\t\t.procname\t= \"dev_weight_rx_bias\",\n\t\t.data\t\t= &dev_weight_rx_bias,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_dev_weight,\n\t},\n\t{\n\t\t.procname\t= \"dev_weight_tx_bias\",\n\t\t.data\t\t= &dev_weight_tx_bias,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_dev_weight,\n\t},\n\t{\n\t\t.procname\t= \"netdev_max_backlog\",\n\t\t.data\t\t= &netdev_max_backlog,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"netdev_rss_key\",\n\t\t.data\t\t= &netdev_rss_key,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_rss_key,\n\t},\n#ifdef CONFIG_BPF_JIT\n\t{\n\t\t.procname\t= \"bpf_jit_enable\",\n\t\t.data\t\t= &bpf_jit_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax_bpf_enable,\n# ifdef CONFIG_BPF_JIT_ALWAYS_ON\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= SYSCTL_ONE,\n# else\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n# endif\n\t},\n# ifdef CONFIG_HAVE_EBPF_JIT\n\t{\n\t\t.procname\t= \"bpf_jit_harden\",\n\t\t.data\t\t= &bpf_jit_harden,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= proc_dointvec_minmax_bpf_restricted,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{\n\t\t.procname\t= \"bpf_jit_kallsyms\",\n\t\t.data\t\t= &bpf_jit_kallsyms,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= proc_dointvec_minmax_bpf_restricted,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n# endif\n\t{\n\t\t.procname\t= \"bpf_jit_limit\",\n\t\t.data\t\t= &bpf_jit_limit,\n\t\t.maxlen\t\t= sizeof(long),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= proc_dolongvec_minmax_bpf_restricted,\n\t\t.extra1\t\t= SYSCTL_LONG_ONE,\n\t\t.extra2\t\t= &bpf_jit_limit_max,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"netdev_tstamp_prequeue\",\n\t\t.data\t\t= &netdev_tstamp_prequeue,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"message_cost\",\n\t\t.data\t\t= &net_ratelimit_state.interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"message_burst\",\n\t\t.data\t\t= &net_ratelimit_state.burst,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"optmem_max\",\n\t\t.data\t\t= &sysctl_optmem_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"tstamp_allow_data\",\n\t\t.data\t\t= &sysctl_tstamp_allow_data,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE\n\t},\n#ifdef CONFIG_RPS\n\t{\n\t\t.procname\t= \"rps_sock_flow_entries\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= rps_sock_flow_sysctl\n\t},\n#endif\n#ifdef CONFIG_NET_FLOW_LIMIT\n\t{\n\t\t.procname\t= \"flow_limit_cpu_bitmap\",\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= flow_limit_cpu_sysctl\n\t},\n\t{\n\t\t.procname\t= \"flow_limit_table_len\",\n\t\t.data\t\t= &netdev_flow_limit_table_len,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= flow_limit_table_len_sysctl\n\t},\n#endif  \n#ifdef CONFIG_NET_RX_BUSY_POLL\n\t{\n\t\t.procname\t= \"busy_poll\",\n\t\t.data\t\t= &sysctl_net_busy_poll,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n\t{\n\t\t.procname\t= \"busy_read\",\n\t\t.data\t\t= &sysctl_net_busy_read,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n#endif\n#ifdef CONFIG_NET_SCHED\n\t{\n\t\t.procname\t= \"default_qdisc\",\n\t\t.mode\t\t= 0644,\n\t\t.maxlen\t\t= IFNAMSIZ,\n\t\t.proc_handler\t= set_default_qdisc\n\t},\n#endif\n\t{\n\t\t.procname\t= \"netdev_budget\",\n\t\t.data\t\t= &netdev_budget,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"warnings\",\n\t\t.data\t\t= &net_msg_warn,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"max_skb_frags\",\n\t\t.data\t\t= &sysctl_max_skb_frags,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= &max_skb_frags,\n\t},\n\t{\n\t\t.procname\t= \"netdev_budget_usecs\",\n\t\t.data\t\t= &netdev_budget_usecs,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n\t{\n\t\t.procname\t= \"fb_tunnels_only_for_init_net\",\n\t\t.data\t\t= &sysctl_fb_tunnels_only_for_init_net,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{\n\t\t.procname\t= \"devconf_inherit_init_net\",\n\t\t.data\t\t= &sysctl_devconf_inherit_init_net,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_THREE,\n\t},\n\t{\n\t\t.procname\t= \"high_order_alloc_disable\",\n\t\t.data\t\t= &net_high_order_alloc_disable_key.key,\n\t\t.maxlen         = sizeof(net_high_order_alloc_disable_key),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_static_key,\n\t},\n\t{\n\t\t.procname\t= \"gro_normal_batch\",\n\t\t.data\t\t= &gro_normal_batch,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"netdev_unregister_timeout_secs\",\n\t\t.data\t\t= &netdev_unregister_timeout_secs,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= &int_3600,\n\t},\n\t{\n\t\t.procname\t= \"skb_defer_max\",\n\t\t.data\t\t= &sysctl_skb_defer_max,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n\t{ }\n};\n\nstatic struct ctl_table netns_core_table[] = {\n#if IS_ENABLED(CONFIG_RPS)\n\t{\n\t\t.procname\t= \"rps_default_mask\",\n\t\t.data\t\t= &init_net,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= rps_default_mask_sysctl\n\t},\n#endif\n\t{\n\t\t.procname\t= \"somaxconn\",\n\t\t.data\t\t= &init_net.core.sysctl_somaxconn,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.proc_handler\t= proc_dointvec_minmax\n\t},\n\t{\n\t\t.procname\t= \"txrehash\",\n\t\t.data\t\t= &init_net.core.sysctl_txrehash,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{ }\n};\n\nstatic int __init fb_tunnels_only_for_init_net_sysctl_setup(char *str)\n{\n\t \n\tif (!strncmp(str, \"initns\", 6))\n\t\tsysctl_fb_tunnels_only_for_init_net = 1;\n\t \n\telse if (!strncmp(str, \"none\", 4))\n\t\tsysctl_fb_tunnels_only_for_init_net = 2;\n\n\treturn 1;\n}\n__setup(\"fb_tunnels=\", fb_tunnels_only_for_init_net_sysctl_setup);\n\nstatic __net_init int sysctl_core_net_init(struct net *net)\n{\n\tstruct ctl_table *tbl, *tmp;\n\n\ttbl = netns_core_table;\n\tif (!net_eq(net, &init_net)) {\n\t\ttbl = kmemdup(tbl, sizeof(netns_core_table), GFP_KERNEL);\n\t\tif (tbl == NULL)\n\t\t\tgoto err_dup;\n\n\t\tfor (tmp = tbl; tmp->procname; tmp++)\n\t\t\ttmp->data += (char *)net - (char *)&init_net;\n\t}\n\n\tnet->core.sysctl_hdr = register_net_sysctl_sz(net, \"net/core\", tbl,\n\t\t\t\t\t\t      ARRAY_SIZE(netns_core_table));\n\tif (net->core.sysctl_hdr == NULL)\n\t\tgoto err_reg;\n\n\treturn 0;\n\nerr_reg:\n\tif (tbl != netns_core_table)\n\t\tkfree(tbl);\nerr_dup:\n\treturn -ENOMEM;\n}\n\nstatic __net_exit void sysctl_core_net_exit(struct net *net)\n{\n\tstruct ctl_table *tbl;\n\n\ttbl = net->core.sysctl_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->core.sysctl_hdr);\n\tBUG_ON(tbl == netns_core_table);\n#if IS_ENABLED(CONFIG_RPS)\n\tkfree(net->core.rps_default_mask);\n#endif\n\tkfree(tbl);\n}\n\nstatic __net_initdata struct pernet_operations sysctl_core_ops = {\n\t.init = sysctl_core_net_init,\n\t.exit = sysctl_core_net_exit,\n};\n\nstatic __init int sysctl_core_init(void)\n{\n\tregister_net_sysctl(&init_net, \"net/core\", net_core_table);\n\treturn register_pernet_subsys(&sysctl_core_ops);\n}\n\nfs_initcall(sysctl_core_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}