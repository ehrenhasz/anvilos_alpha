{
  "module_name": "net_namespace.c",
  "hash_id": "9c6c077003eb253170ba9748702828558631941964856ccac5f135dadd07554f",
  "original_prompt": "Ingested from linux-6.6.14/net/core/net_namespace.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/workqueue.h>\n#include <linux/rtnetlink.h>\n#include <linux/cache.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/rculist.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/proc_ns.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/user_namespace.h>\n#include <linux/net_namespace.h>\n#include <linux/sched/task.h>\n#include <linux/uidgid.h>\n#include <linux/cookie.h>\n#include <linux/proc_fs.h>\n\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n \n\nstatic LIST_HEAD(pernet_list);\nstatic struct list_head *first_device = &pernet_list;\n\nLIST_HEAD(net_namespace_list);\nEXPORT_SYMBOL_GPL(net_namespace_list);\n\n \nDECLARE_RWSEM(net_rwsem);\nEXPORT_SYMBOL_GPL(net_rwsem);\n\n#ifdef CONFIG_KEYS\nstatic struct key_tag init_net_key_domain = { .usage = REFCOUNT_INIT(1) };\n#endif\n\nstruct net init_net;\nEXPORT_SYMBOL(init_net);\n\nstatic bool init_net_initialized;\n \nDECLARE_RWSEM(pernet_ops_rwsem);\nEXPORT_SYMBOL_GPL(pernet_ops_rwsem);\n\n#define MIN_PERNET_OPS_ID\t\\\n\t((sizeof(struct net_generic) + sizeof(void *) - 1) / sizeof(void *))\n\n#define INITIAL_NET_GEN_PTRS\t13  \n\nstatic unsigned int max_gen_ptrs = INITIAL_NET_GEN_PTRS;\n\nDEFINE_COOKIE(net_cookie);\n\nstatic struct net_generic *net_alloc_generic(void)\n{\n\tstruct net_generic *ng;\n\tunsigned int generic_size = offsetof(struct net_generic, ptr[max_gen_ptrs]);\n\n\tng = kzalloc(generic_size, GFP_KERNEL);\n\tif (ng)\n\t\tng->s.len = max_gen_ptrs;\n\n\treturn ng;\n}\n\nstatic int net_assign_generic(struct net *net, unsigned int id, void *data)\n{\n\tstruct net_generic *ng, *old_ng;\n\n\tBUG_ON(id < MIN_PERNET_OPS_ID);\n\n\told_ng = rcu_dereference_protected(net->gen,\n\t\t\t\t\t   lockdep_is_held(&pernet_ops_rwsem));\n\tif (old_ng->s.len > id) {\n\t\told_ng->ptr[id] = data;\n\t\treturn 0;\n\t}\n\n\tng = net_alloc_generic();\n\tif (!ng)\n\t\treturn -ENOMEM;\n\n\t \n\n\tmemcpy(&ng->ptr[MIN_PERNET_OPS_ID], &old_ng->ptr[MIN_PERNET_OPS_ID],\n\t       (old_ng->s.len - MIN_PERNET_OPS_ID) * sizeof(void *));\n\tng->ptr[id] = data;\n\n\trcu_assign_pointer(net->gen, ng);\n\tkfree_rcu(old_ng, s.rcu);\n\treturn 0;\n}\n\nstatic int ops_init(const struct pernet_operations *ops, struct net *net)\n{\n\tstruct net_generic *ng;\n\tint err = -ENOMEM;\n\tvoid *data = NULL;\n\n\tif (ops->id && ops->size) {\n\t\tdata = kzalloc(ops->size, GFP_KERNEL);\n\t\tif (!data)\n\t\t\tgoto out;\n\n\t\terr = net_assign_generic(net, *ops->id, data);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\terr = 0;\n\tif (ops->init)\n\t\terr = ops->init(net);\n\tif (!err)\n\t\treturn 0;\n\n\tif (ops->id && ops->size) {\n\t\tng = rcu_dereference_protected(net->gen,\n\t\t\t\t\t       lockdep_is_held(&pernet_ops_rwsem));\n\t\tng->ptr[*ops->id] = NULL;\n\t}\n\ncleanup:\n\tkfree(data);\n\nout:\n\treturn err;\n}\n\nstatic void ops_pre_exit_list(const struct pernet_operations *ops,\n\t\t\t      struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\n\tif (ops->pre_exit) {\n\t\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\t\tops->pre_exit(net);\n\t}\n}\n\nstatic void ops_exit_list(const struct pernet_operations *ops,\n\t\t\t  struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\tif (ops->exit) {\n\t\tlist_for_each_entry(net, net_exit_list, exit_list) {\n\t\t\tops->exit(net);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tif (ops->exit_batch)\n\t\tops->exit_batch(net_exit_list);\n}\n\nstatic void ops_free_list(const struct pernet_operations *ops,\n\t\t\t  struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\tif (ops->size && ops->id) {\n\t\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\t\tkfree(net_generic(net, *ops->id));\n\t}\n}\n\n \nstatic int alloc_netid(struct net *net, struct net *peer, int reqid)\n{\n\tint min = 0, max = 0;\n\n\tif (reqid >= 0) {\n\t\tmin = reqid;\n\t\tmax = reqid + 1;\n\t}\n\n\treturn idr_alloc(&net->netns_ids, peer, min, max, GFP_ATOMIC);\n}\n\n \n#define NET_ID_ZERO -1\nstatic int net_eq_idr(int id, void *net, void *peer)\n{\n\tif (net_eq(net, peer))\n\t\treturn id ? : NET_ID_ZERO;\n\treturn 0;\n}\n\n \nstatic int __peernet2id(const struct net *net, struct net *peer)\n{\n\tint id = idr_for_each(&net->netns_ids, net_eq_idr, peer);\n\n\t \n\tif (id == NET_ID_ZERO)\n\t\treturn 0;\n\tif (id > 0)\n\t\treturn id;\n\n\treturn NETNSA_NSID_NOT_ASSIGNED;\n}\n\nstatic void rtnl_net_notifyid(struct net *net, int cmd, int id, u32 portid,\n\t\t\t      struct nlmsghdr *nlh, gfp_t gfp);\n \nint peernet2id_alloc(struct net *net, struct net *peer, gfp_t gfp)\n{\n\tint id;\n\n\tif (refcount_read(&net->ns.count) == 0)\n\t\treturn NETNSA_NSID_NOT_ASSIGNED;\n\n\tspin_lock_bh(&net->nsid_lock);\n\tid = __peernet2id(net, peer);\n\tif (id >= 0) {\n\t\tspin_unlock_bh(&net->nsid_lock);\n\t\treturn id;\n\t}\n\n\t \n\tif (!maybe_get_net(peer)) {\n\t\tspin_unlock_bh(&net->nsid_lock);\n\t\treturn NETNSA_NSID_NOT_ASSIGNED;\n\t}\n\n\tid = alloc_netid(net, peer, -1);\n\tspin_unlock_bh(&net->nsid_lock);\n\n\tput_net(peer);\n\tif (id < 0)\n\t\treturn NETNSA_NSID_NOT_ASSIGNED;\n\n\trtnl_net_notifyid(net, RTM_NEWNSID, id, 0, NULL, gfp);\n\n\treturn id;\n}\nEXPORT_SYMBOL_GPL(peernet2id_alloc);\n\n \nint peernet2id(const struct net *net, struct net *peer)\n{\n\tint id;\n\n\trcu_read_lock();\n\tid = __peernet2id(net, peer);\n\trcu_read_unlock();\n\n\treturn id;\n}\nEXPORT_SYMBOL(peernet2id);\n\n \nbool peernet_has_id(const struct net *net, struct net *peer)\n{\n\treturn peernet2id(net, peer) >= 0;\n}\n\nstruct net *get_net_ns_by_id(const struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tpeer = maybe_get_net(peer);\n\trcu_read_unlock();\n\n\treturn peer;\n}\nEXPORT_SYMBOL_GPL(get_net_ns_by_id);\n\n \nstatic __net_init void preinit_net(struct net *net)\n{\n\tref_tracker_dir_init(&net->notrefcnt_tracker, 128, \"net notrefcnt\");\n}\n\n \nstatic __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\t \n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n\n\trefcount_set(&net->ns.count, 1);\n\tref_tracker_dir_init(&net->refcnt_tracker, 128, \"net refcnt\");\n\n\trefcount_set(&net->passive, 1);\n\tget_random_bytes(&net->hash_mix, sizeof(u32));\n\tpreempt_disable();\n\tnet->net_cookie = gen_cookie_next(&net_cookie);\n\tpreempt_enable();\n\tnet->dev_base_seq = 1;\n\tnet->user_ns = user_ns;\n\tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\n\nout_undo:\n\t \n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_pre_exit_list(ops, &net_exit_list);\n\n\tsynchronize_rcu();\n\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\n\trcu_barrier();\n\tgoto out;\n}\n\nstatic int __net_init net_defaults_init_net(struct net *net)\n{\n\tnet->core.sysctl_somaxconn = SOMAXCONN;\n\tnet->core.sysctl_txrehash = SOCK_TXREHASH_ENABLED;\n\n\treturn 0;\n}\n\nstatic struct pernet_operations net_defaults_ops = {\n\t.init = net_defaults_init_net,\n};\n\nstatic __init int net_defaults_init(void)\n{\n\tif (register_pernet_subsys(&net_defaults_ops))\n\t\tpanic(\"Cannot initialize net default settings\");\n\n\treturn 0;\n}\n\ncore_initcall(net_defaults_init);\n\n#ifdef CONFIG_NET_NS\nstatic struct ucounts *inc_net_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_NET_NAMESPACES);\n}\n\nstatic void dec_net_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_NET_NAMESPACES);\n}\n\nstatic struct kmem_cache *net_cachep __ro_after_init;\nstatic struct workqueue_struct *netns_wq;\n\nstatic struct net *net_alloc(void)\n{\n\tstruct net *net = NULL;\n\tstruct net_generic *ng;\n\n\tng = net_alloc_generic();\n\tif (!ng)\n\t\tgoto out;\n\n\tnet = kmem_cache_zalloc(net_cachep, GFP_KERNEL);\n\tif (!net)\n\t\tgoto out_free;\n\n#ifdef CONFIG_KEYS\n\tnet->key_domain = kzalloc(sizeof(struct key_tag), GFP_KERNEL);\n\tif (!net->key_domain)\n\t\tgoto out_free_2;\n\trefcount_set(&net->key_domain->usage, 1);\n#endif\n\n\trcu_assign_pointer(net->gen, ng);\nout:\n\treturn net;\n\n#ifdef CONFIG_KEYS\nout_free_2:\n\tkmem_cache_free(net_cachep, net);\n\tnet = NULL;\n#endif\nout_free:\n\tkfree(ng);\n\tgoto out;\n}\n\nstatic void net_free(struct net *net)\n{\n\tif (refcount_dec_and_test(&net->passive)) {\n\t\tkfree(rcu_access_pointer(net->gen));\n\n\t\t \n\t\tref_tracker_dir_exit(&net->notrefcnt_tracker);\n\n\t\tkmem_cache_free(net_cachep, net);\n\t}\n}\n\nvoid net_drop_ns(void *p)\n{\n\tstruct net *net = (struct net *)p;\n\n\tif (net)\n\t\tnet_free(net);\n}\n\nstruct net *copy_net_ns(unsigned long flags,\n\t\t\tstruct user_namespace *user_ns, struct net *old_net)\n{\n\tstruct ucounts *ucounts;\n\tstruct net *net;\n\tint rv;\n\n\tif (!(flags & CLONE_NEWNET))\n\t\treturn get_net(old_net);\n\n\tucounts = inc_net_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnet = net_alloc();\n\tif (!net) {\n\t\trv = -ENOMEM;\n\t\tgoto dec_ucounts;\n\t}\n\n\tpreinit_net(net);\n\trefcount_set(&net->passive, 1);\n\tnet->ucounts = ucounts;\n\tget_user_ns(user_ns);\n\n\trv = down_read_killable(&pernet_ops_rwsem);\n\tif (rv < 0)\n\t\tgoto put_userns;\n\n\trv = setup_net(net, user_ns);\n\n\tup_read(&pernet_ops_rwsem);\n\n\tif (rv < 0) {\nput_userns:\n#ifdef CONFIG_KEYS\n\t\tkey_remove_domain(net->key_domain);\n#endif\n\t\tput_user_ns(user_ns);\n\t\tnet_free(net);\ndec_ucounts:\n\t\tdec_net_namespaces(ucounts);\n\t\treturn ERR_PTR(rv);\n\t}\n\treturn net;\n}\n\n \nvoid net_ns_get_ownership(const struct net *net, kuid_t *uid, kgid_t *gid)\n{\n\tif (net) {\n\t\tkuid_t ns_root_uid = make_kuid(net->user_ns, 0);\n\t\tkgid_t ns_root_gid = make_kgid(net->user_ns, 0);\n\n\t\tif (uid_valid(ns_root_uid))\n\t\t\t*uid = ns_root_uid;\n\n\t\tif (gid_valid(ns_root_gid))\n\t\t\t*gid = ns_root_gid;\n\t} else {\n\t\t*uid = GLOBAL_ROOT_UID;\n\t\t*gid = GLOBAL_ROOT_GID;\n\t}\n}\nEXPORT_SYMBOL_GPL(net_ns_get_ownership);\n\nstatic void unhash_nsid(struct net *net, struct net *last)\n{\n\tstruct net *tmp;\n\t \n\tfor_each_net(tmp) {\n\t\tint id;\n\n\t\tspin_lock_bh(&tmp->nsid_lock);\n\t\tid = __peernet2id(tmp, net);\n\t\tif (id >= 0)\n\t\t\tidr_remove(&tmp->netns_ids, id);\n\t\tspin_unlock_bh(&tmp->nsid_lock);\n\t\tif (id >= 0)\n\t\t\trtnl_net_notifyid(tmp, RTM_DELNSID, id, 0, NULL,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (tmp == last)\n\t\t\tbreak;\n\t}\n\tspin_lock_bh(&net->nsid_lock);\n\tidr_destroy(&net->netns_ids);\n\tspin_unlock_bh(&net->nsid_lock);\n}\n\nstatic LLIST_HEAD(cleanup_list);\n\nstatic void cleanup_net(struct work_struct *work)\n{\n\tconst struct pernet_operations *ops;\n\tstruct net *net, *tmp, *last;\n\tstruct llist_node *net_kill_list;\n\tLIST_HEAD(net_exit_list);\n\n\t \n\tnet_kill_list = llist_del_all(&cleanup_list);\n\n\tdown_read(&pernet_ops_rwsem);\n\n\t \n\tdown_write(&net_rwsem);\n\tllist_for_each_entry(net, net_kill_list, cleanup_list)\n\t\tlist_del_rcu(&net->list);\n\t \n\tlast = list_last_entry(&net_namespace_list, struct net, list);\n\tup_write(&net_rwsem);\n\n\tllist_for_each_entry(net, net_kill_list, cleanup_list) {\n\t\tunhash_nsid(net, last);\n\t\tlist_add_tail(&net->exit_list, &net_exit_list);\n\t}\n\n\t \n\tlist_for_each_entry_reverse(ops, &pernet_list, list)\n\t\tops_pre_exit_list(ops, &net_exit_list);\n\n\t \n\tsynchronize_rcu();\n\n\t \n\tlist_for_each_entry_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\n\t \n\tlist_for_each_entry_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\n\tup_read(&pernet_ops_rwsem);\n\n\t \n\trcu_barrier();\n\n\t \n\tlist_for_each_entry_safe(net, tmp, &net_exit_list, exit_list) {\n\t\tlist_del_init(&net->exit_list);\n\t\tdec_net_namespaces(net->ucounts);\n#ifdef CONFIG_KEYS\n\t\tkey_remove_domain(net->key_domain);\n#endif\n\t\tput_user_ns(net->user_ns);\n\t\tnet_free(net);\n\t}\n}\n\n \nvoid net_ns_barrier(void)\n{\n\tdown_write(&pernet_ops_rwsem);\n\tup_write(&pernet_ops_rwsem);\n}\nEXPORT_SYMBOL(net_ns_barrier);\n\nstatic DECLARE_WORK(net_cleanup_work, cleanup_net);\n\nvoid __put_net(struct net *net)\n{\n\tref_tracker_dir_exit(&net->refcnt_tracker);\n\t \n\tif (llist_add(&net->cleanup_list, &cleanup_list))\n\t\tqueue_work(netns_wq, &net_cleanup_work);\n}\nEXPORT_SYMBOL_GPL(__put_net);\n\n \nstruct ns_common *get_net_ns(struct ns_common *ns)\n{\n\treturn &get_net(container_of(ns, struct net, ns))->ns;\n}\nEXPORT_SYMBOL_GPL(get_net_ns);\n\nstruct net *get_net_ns_by_fd(int fd)\n{\n\tstruct fd f = fdget(fd);\n\tstruct net *net = ERR_PTR(-EINVAL);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (proc_ns_file(f.file)) {\n\t\tstruct ns_common *ns = get_proc_ns(file_inode(f.file));\n\t\tif (ns->ops == &netns_operations)\n\t\t\tnet = get_net(container_of(ns, struct net, ns));\n\t}\n\tfdput(f);\n\n\treturn net;\n}\nEXPORT_SYMBOL_GPL(get_net_ns_by_fd);\n#endif\n\nstruct net *get_net_ns_by_pid(pid_t pid)\n{\n\tstruct task_struct *tsk;\n\tstruct net *net;\n\n\t \n\tnet = ERR_PTR(-ESRCH);\n\trcu_read_lock();\n\ttsk = find_task_by_vpid(pid);\n\tif (tsk) {\n\t\tstruct nsproxy *nsproxy;\n\t\ttask_lock(tsk);\n\t\tnsproxy = tsk->nsproxy;\n\t\tif (nsproxy)\n\t\t\tnet = get_net(nsproxy->net_ns);\n\t\ttask_unlock(tsk);\n\t}\n\trcu_read_unlock();\n\treturn net;\n}\nEXPORT_SYMBOL_GPL(get_net_ns_by_pid);\n\nstatic __net_init int net_ns_net_init(struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\tnet->ns.ops = &netns_operations;\n#endif\n\treturn ns_alloc_inum(&net->ns);\n}\n\nstatic __net_exit void net_ns_net_exit(struct net *net)\n{\n\tns_free_inum(&net->ns);\n}\n\nstatic struct pernet_operations __net_initdata net_ns_ops = {\n\t.init = net_ns_net_init,\n\t.exit = net_ns_net_exit,\n};\n\nstatic const struct nla_policy rtnl_net_policy[NETNSA_MAX + 1] = {\n\t[NETNSA_NONE]\t\t= { .type = NLA_UNSPEC },\n\t[NETNSA_NSID]\t\t= { .type = NLA_S32 },\n\t[NETNSA_PID]\t\t= { .type = NLA_U32 },\n\t[NETNSA_FD]\t\t= { .type = NLA_U32 },\n\t[NETNSA_TARGET_NSID]\t= { .type = NLA_S32 },\n};\n\nstatic int rtnl_net_newid(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[NETNSA_MAX + 1];\n\tstruct nlattr *nla;\n\tstruct net *peer;\n\tint nsid, err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(struct rtgenmsg), tb,\n\t\t\t\t     NETNSA_MAX, rtnl_net_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NETNSA_NSID]) {\n\t\tNL_SET_ERR_MSG(extack, \"nsid is missing\");\n\t\treturn -EINVAL;\n\t}\n\tnsid = nla_get_s32(tb[NETNSA_NSID]);\n\n\tif (tb[NETNSA_PID]) {\n\t\tpeer = get_net_ns_by_pid(nla_get_u32(tb[NETNSA_PID]));\n\t\tnla = tb[NETNSA_PID];\n\t} else if (tb[NETNSA_FD]) {\n\t\tpeer = get_net_ns_by_fd(nla_get_u32(tb[NETNSA_FD]));\n\t\tnla = tb[NETNSA_FD];\n\t} else {\n\t\tNL_SET_ERR_MSG(extack, \"Peer netns reference is missing\");\n\t\treturn -EINVAL;\n\t}\n\tif (IS_ERR(peer)) {\n\t\tNL_SET_BAD_ATTR(extack, nla);\n\t\tNL_SET_ERR_MSG(extack, \"Peer netns reference is invalid\");\n\t\treturn PTR_ERR(peer);\n\t}\n\n\tspin_lock_bh(&net->nsid_lock);\n\tif (__peernet2id(net, peer) >= 0) {\n\t\tspin_unlock_bh(&net->nsid_lock);\n\t\terr = -EEXIST;\n\t\tNL_SET_BAD_ATTR(extack, nla);\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Peer netns already has a nsid assigned\");\n\t\tgoto out;\n\t}\n\n\terr = alloc_netid(net, peer, nsid);\n\tspin_unlock_bh(&net->nsid_lock);\n\tif (err >= 0) {\n\t\trtnl_net_notifyid(net, RTM_NEWNSID, err, NETLINK_CB(skb).portid,\n\t\t\t\t  nlh, GFP_KERNEL);\n\t\terr = 0;\n\t} else if (err == -ENOSPC && nsid >= 0) {\n\t\terr = -EEXIST;\n\t\tNL_SET_BAD_ATTR(extack, tb[NETNSA_NSID]);\n\t\tNL_SET_ERR_MSG(extack, \"The specified nsid is already used\");\n\t}\nout:\n\tput_net(peer);\n\treturn err;\n}\n\nstatic int rtnl_net_get_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct rtgenmsg))\n\t       + nla_total_size(sizeof(s32))  \n\t       + nla_total_size(sizeof(s32))  \n\t       ;\n}\n\nstruct net_fill_args {\n\tu32 portid;\n\tu32 seq;\n\tint flags;\n\tint cmd;\n\tint nsid;\n\tbool add_ref;\n\tint ref_nsid;\n};\n\nstatic int rtnl_net_fill(struct sk_buff *skb, struct net_fill_args *args)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct rtgenmsg *rth;\n\n\tnlh = nlmsg_put(skb, args->portid, args->seq, args->cmd, sizeof(*rth),\n\t\t\targs->flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\trth = nlmsg_data(nlh);\n\trth->rtgen_family = AF_UNSPEC;\n\n\tif (nla_put_s32(skb, NETNSA_NSID, args->nsid))\n\t\tgoto nla_put_failure;\n\n\tif (args->add_ref &&\n\t    nla_put_s32(skb, NETNSA_CURRENT_NSID, args->ref_nsid))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int rtnl_net_valid_getid_req(struct sk_buff *skb,\n\t\t\t\t    const struct nlmsghdr *nlh,\n\t\t\t\t    struct nlattr **tb,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint i, err;\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(struct rtgenmsg),\n\t\t\t\t\t      tb, NETNSA_MAX, rtnl_net_policy,\n\t\t\t\t\t      extack);\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct rtgenmsg), tb,\n\t\t\t\t\t    NETNSA_MAX, rtnl_net_policy,\n\t\t\t\t\t    extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= NETNSA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NETNSA_PID:\n\t\tcase NETNSA_FD:\n\t\tcase NETNSA_NSID:\n\t\tcase NETNSA_TARGET_NSID:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in peer netns getid request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_net_getid(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[NETNSA_MAX + 1];\n\tstruct net_fill_args fillargs = {\n\t\t.portid = NETLINK_CB(skb).portid,\n\t\t.seq = nlh->nlmsg_seq,\n\t\t.cmd = RTM_NEWNSID,\n\t};\n\tstruct net *peer, *target = net;\n\tstruct nlattr *nla;\n\tstruct sk_buff *msg;\n\tint err;\n\n\terr = rtnl_net_valid_getid_req(skb, nlh, tb, extack);\n\tif (err < 0)\n\t\treturn err;\n\tif (tb[NETNSA_PID]) {\n\t\tpeer = get_net_ns_by_pid(nla_get_u32(tb[NETNSA_PID]));\n\t\tnla = tb[NETNSA_PID];\n\t} else if (tb[NETNSA_FD]) {\n\t\tpeer = get_net_ns_by_fd(nla_get_u32(tb[NETNSA_FD]));\n\t\tnla = tb[NETNSA_FD];\n\t} else if (tb[NETNSA_NSID]) {\n\t\tpeer = get_net_ns_by_id(net, nla_get_s32(tb[NETNSA_NSID]));\n\t\tif (!peer)\n\t\t\tpeer = ERR_PTR(-ENOENT);\n\t\tnla = tb[NETNSA_NSID];\n\t} else {\n\t\tNL_SET_ERR_MSG(extack, \"Peer netns reference is missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(peer)) {\n\t\tNL_SET_BAD_ATTR(extack, nla);\n\t\tNL_SET_ERR_MSG(extack, \"Peer netns reference is invalid\");\n\t\treturn PTR_ERR(peer);\n\t}\n\n\tif (tb[NETNSA_TARGET_NSID]) {\n\t\tint id = nla_get_s32(tb[NETNSA_TARGET_NSID]);\n\n\t\ttarget = rtnl_get_net_ns_capable(NETLINK_CB(skb).sk, id);\n\t\tif (IS_ERR(target)) {\n\t\t\tNL_SET_BAD_ATTR(extack, tb[NETNSA_TARGET_NSID]);\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Target netns reference is invalid\");\n\t\t\terr = PTR_ERR(target);\n\t\t\tgoto out;\n\t\t}\n\t\tfillargs.add_ref = true;\n\t\tfillargs.ref_nsid = peernet2id(net, peer);\n\t}\n\n\tmsg = nlmsg_new(rtnl_net_get_size(), GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfillargs.nsid = peernet2id(target, peer);\n\terr = rtnl_net_fill(msg, &fillargs);\n\tif (err < 0)\n\t\tgoto err_out;\n\n\terr = rtnl_unicast(msg, net, NETLINK_CB(skb).portid);\n\tgoto out;\n\nerr_out:\n\tnlmsg_free(msg);\nout:\n\tif (fillargs.add_ref)\n\t\tput_net(target);\n\tput_net(peer);\n\treturn err;\n}\n\nstruct rtnl_net_dump_cb {\n\tstruct net *tgt_net;\n\tstruct net *ref_net;\n\tstruct sk_buff *skb;\n\tstruct net_fill_args fillargs;\n\tint idx;\n\tint s_idx;\n};\n\n \nstatic int rtnl_net_dumpid_one(int id, void *peer, void *data)\n{\n\tstruct rtnl_net_dump_cb *net_cb = (struct rtnl_net_dump_cb *)data;\n\tint ret;\n\n\tif (net_cb->idx < net_cb->s_idx)\n\t\tgoto cont;\n\n\tnet_cb->fillargs.nsid = id;\n\tif (net_cb->fillargs.add_ref)\n\t\tnet_cb->fillargs.ref_nsid = __peernet2id(net_cb->ref_net, peer);\n\tret = rtnl_net_fill(net_cb->skb, &net_cb->fillargs);\n\tif (ret < 0)\n\t\treturn ret;\n\ncont:\n\tnet_cb->idx++;\n\treturn 0;\n}\n\nstatic int rtnl_valid_dump_net_req(const struct nlmsghdr *nlh, struct sock *sk,\n\t\t\t\t   struct rtnl_net_dump_cb *net_cb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct netlink_ext_ack *extack = cb->extack;\n\tstruct nlattr *tb[NETNSA_MAX + 1];\n\tint err, i;\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct rtgenmsg), tb,\n\t\t\t\t\t    NETNSA_MAX, rtnl_net_policy,\n\t\t\t\t\t    extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i <= NETNSA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tif (i == NETNSA_TARGET_NSID) {\n\t\t\tstruct net *net;\n\n\t\t\tnet = rtnl_get_net_ns_capable(sk, nla_get_s32(tb[i]));\n\t\t\tif (IS_ERR(net)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, tb[i]);\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"Invalid target network namespace id\");\n\t\t\t\treturn PTR_ERR(net);\n\t\t\t}\n\t\t\tnet_cb->fillargs.add_ref = true;\n\t\t\tnet_cb->ref_net = net_cb->tgt_net;\n\t\t\tnet_cb->tgt_net = net;\n\t\t} else {\n\t\t\tNL_SET_BAD_ATTR(extack, tb[i]);\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Unsupported attribute in dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_net_dumpid(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct rtnl_net_dump_cb net_cb = {\n\t\t.tgt_net = sock_net(skb->sk),\n\t\t.skb = skb,\n\t\t.fillargs = {\n\t\t\t.portid = NETLINK_CB(cb->skb).portid,\n\t\t\t.seq = cb->nlh->nlmsg_seq,\n\t\t\t.flags = NLM_F_MULTI,\n\t\t\t.cmd = RTM_NEWNSID,\n\t\t},\n\t\t.idx = 0,\n\t\t.s_idx = cb->args[0],\n\t};\n\tint err = 0;\n\n\tif (cb->strict_check) {\n\t\terr = rtnl_valid_dump_net_req(cb->nlh, skb->sk, &net_cb, cb);\n\t\tif (err < 0)\n\t\t\tgoto end;\n\t}\n\n\trcu_read_lock();\n\tidr_for_each(&net_cb.tgt_net->netns_ids, rtnl_net_dumpid_one, &net_cb);\n\trcu_read_unlock();\n\n\tcb->args[0] = net_cb.idx;\nend:\n\tif (net_cb.fillargs.add_ref)\n\t\tput_net(net_cb.tgt_net);\n\treturn err < 0 ? err : skb->len;\n}\n\nstatic void rtnl_net_notifyid(struct net *net, int cmd, int id, u32 portid,\n\t\t\t      struct nlmsghdr *nlh, gfp_t gfp)\n{\n\tstruct net_fill_args fillargs = {\n\t\t.portid = portid,\n\t\t.seq = nlh ? nlh->nlmsg_seq : 0,\n\t\t.cmd = cmd,\n\t\t.nsid = id,\n\t};\n\tstruct sk_buff *msg;\n\tint err = -ENOMEM;\n\n\tmsg = nlmsg_new(rtnl_net_get_size(), gfp);\n\tif (!msg)\n\t\tgoto out;\n\n\terr = rtnl_net_fill(msg, &fillargs);\n\tif (err < 0)\n\t\tgoto err_out;\n\n\trtnl_notify(msg, net, portid, RTNLGRP_NSID, nlh, gfp);\n\treturn;\n\nerr_out:\n\tnlmsg_free(msg);\nout:\n\trtnl_set_sk_err(net, RTNLGRP_NSID, err);\n}\n\nvoid __init net_ns_init(void)\n{\n\tstruct net_generic *ng;\n\n#ifdef CONFIG_NET_NS\n\tnet_cachep = kmem_cache_create(\"net_namespace\", sizeof(struct net),\n\t\t\t\t\tSMP_CACHE_BYTES,\n\t\t\t\t\tSLAB_PANIC|SLAB_ACCOUNT, NULL);\n\n\t \n\tnetns_wq = create_singlethread_workqueue(\"netns\");\n\tif (!netns_wq)\n\t\tpanic(\"Could not create netns workq\");\n#endif\n\n\tng = net_alloc_generic();\n\tif (!ng)\n\t\tpanic(\"Could not allocate generic netns\");\n\n\trcu_assign_pointer(init_net.gen, ng);\n\n#ifdef CONFIG_KEYS\n\tinit_net.key_domain = &init_net_key_domain;\n#endif\n\tdown_write(&pernet_ops_rwsem);\n\tpreinit_net(&init_net);\n\tif (setup_net(&init_net, &init_user_ns))\n\t\tpanic(\"Could not setup the initial network namespace\");\n\n\tinit_net_initialized = true;\n\tup_write(&pernet_ops_rwsem);\n\n\tif (register_pernet_subsys(&net_ns_ops))\n\t\tpanic(\"Could not register network namespace subsystems\");\n\n\trtnl_register(PF_UNSPEC, RTM_NEWNSID, rtnl_net_newid, NULL,\n\t\t      RTNL_FLAG_DOIT_UNLOCKED);\n\trtnl_register(PF_UNSPEC, RTM_GETNSID, rtnl_net_getid, rtnl_net_dumpid,\n\t\t      RTNL_FLAG_DOIT_UNLOCKED);\n}\n\nstatic void free_exit_list(struct pernet_operations *ops, struct list_head *net_exit_list)\n{\n\tops_pre_exit_list(ops, net_exit_list);\n\tsynchronize_rcu();\n\tops_exit_list(ops, net_exit_list);\n\tops_free_list(ops, net_exit_list);\n}\n\n#ifdef CONFIG_NET_NS\nstatic int __register_pernet_operations(struct list_head *list,\n\t\t\t\t\tstruct pernet_operations *ops)\n{\n\tstruct net *net;\n\tint error;\n\tLIST_HEAD(net_exit_list);\n\n\tlist_add_tail(&ops->list, list);\n\tif (ops->init || (ops->id && ops->size)) {\n\t\t \n\t\tfor_each_net(net) {\n\t\t\terror = ops_init(ops, net);\n\t\t\tif (error)\n\t\t\t\tgoto out_undo;\n\t\t\tlist_add_tail(&net->exit_list, &net_exit_list);\n\t\t}\n\t}\n\treturn 0;\n\nout_undo:\n\t \n\tlist_del(&ops->list);\n\tfree_exit_list(ops, &net_exit_list);\n\treturn error;\n}\n\nstatic void __unregister_pernet_operations(struct pernet_operations *ops)\n{\n\tstruct net *net;\n\tLIST_HEAD(net_exit_list);\n\n\tlist_del(&ops->list);\n\t \n\tfor_each_net(net)\n\t\tlist_add_tail(&net->exit_list, &net_exit_list);\n\n\tfree_exit_list(ops, &net_exit_list);\n}\n\n#else\n\nstatic int __register_pernet_operations(struct list_head *list,\n\t\t\t\t\tstruct pernet_operations *ops)\n{\n\tif (!init_net_initialized) {\n\t\tlist_add_tail(&ops->list, list);\n\t\treturn 0;\n\t}\n\n\treturn ops_init(ops, &init_net);\n}\n\nstatic void __unregister_pernet_operations(struct pernet_operations *ops)\n{\n\tif (!init_net_initialized) {\n\t\tlist_del(&ops->list);\n\t} else {\n\t\tLIST_HEAD(net_exit_list);\n\t\tlist_add(&init_net.exit_list, &net_exit_list);\n\t\tfree_exit_list(ops, &net_exit_list);\n\t}\n}\n\n#endif  \n\nstatic DEFINE_IDA(net_generic_ids);\n\nstatic int register_pernet_operations(struct list_head *list,\n\t\t\t\t      struct pernet_operations *ops)\n{\n\tint error;\n\n\tif (ops->id) {\n\t\terror = ida_alloc_min(&net_generic_ids, MIN_PERNET_OPS_ID,\n\t\t\t\tGFP_KERNEL);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\t*ops->id = error;\n\t\tmax_gen_ptrs = max(max_gen_ptrs, *ops->id + 1);\n\t}\n\terror = __register_pernet_operations(list, ops);\n\tif (error) {\n\t\trcu_barrier();\n\t\tif (ops->id)\n\t\t\tida_free(&net_generic_ids, *ops->id);\n\t}\n\n\treturn error;\n}\n\nstatic void unregister_pernet_operations(struct pernet_operations *ops)\n{\n\t__unregister_pernet_operations(ops);\n\trcu_barrier();\n\tif (ops->id)\n\t\tida_free(&net_generic_ids, *ops->id);\n}\n\n \nint register_pernet_subsys(struct pernet_operations *ops)\n{\n\tint error;\n\tdown_write(&pernet_ops_rwsem);\n\terror =  register_pernet_operations(first_device, ops);\n\tup_write(&pernet_ops_rwsem);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(register_pernet_subsys);\n\n \nvoid unregister_pernet_subsys(struct pernet_operations *ops)\n{\n\tdown_write(&pernet_ops_rwsem);\n\tunregister_pernet_operations(ops);\n\tup_write(&pernet_ops_rwsem);\n}\nEXPORT_SYMBOL_GPL(unregister_pernet_subsys);\n\n \nint register_pernet_device(struct pernet_operations *ops)\n{\n\tint error;\n\tdown_write(&pernet_ops_rwsem);\n\terror = register_pernet_operations(&pernet_list, ops);\n\tif (!error && (first_device == &pernet_list))\n\t\tfirst_device = &ops->list;\n\tup_write(&pernet_ops_rwsem);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(register_pernet_device);\n\n \nvoid unregister_pernet_device(struct pernet_operations *ops)\n{\n\tdown_write(&pernet_ops_rwsem);\n\tif (&ops->list == first_device)\n\t\tfirst_device = first_device->next;\n\tunregister_pernet_operations(ops);\n\tup_write(&pernet_ops_rwsem);\n}\nEXPORT_SYMBOL_GPL(unregister_pernet_device);\n\n#ifdef CONFIG_NET_NS\nstatic struct ns_common *netns_get(struct task_struct *task)\n{\n\tstruct net *net = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy)\n\t\tnet = get_net(nsproxy->net_ns);\n\ttask_unlock(task);\n\n\treturn net ? &net->ns : NULL;\n}\n\nstatic inline struct net *to_net_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct net, ns);\n}\n\nstatic void netns_put(struct ns_common *ns)\n{\n\tput_net(to_net_ns(ns));\n}\n\nstatic int netns_install(struct nsset *nsset, struct ns_common *ns)\n{\n\tstruct nsproxy *nsproxy = nsset->nsproxy;\n\tstruct net *net = to_net_ns(ns);\n\n\tif (!ns_capable(net->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tput_net(nsproxy->net_ns);\n\tnsproxy->net_ns = get_net(net);\n\treturn 0;\n}\n\nstatic struct user_namespace *netns_owner(struct ns_common *ns)\n{\n\treturn to_net_ns(ns)->user_ns;\n}\n\nconst struct proc_ns_operations netns_operations = {\n\t.name\t\t= \"net\",\n\t.type\t\t= CLONE_NEWNET,\n\t.get\t\t= netns_get,\n\t.put\t\t= netns_put,\n\t.install\t= netns_install,\n\t.owner\t\t= netns_owner,\n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}