{
  "module_name": "dev_ioctl.c",
  "hash_id": "88dfcdcd1caf72fe5186abae815f04bd05fc21720625abd68fa947650d1d37df",
  "original_prompt": "Ingested from linux-6.6.14/net/core/dev_ioctl.c",
  "human_readable_source": "\n#include <linux/kmod.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/net_tstamp.h>\n#include <linux/phylib_stubs.h>\n#include <linux/wireless.h>\n#include <linux/if_bridge.h>\n#include <net/dsa_stubs.h>\n#include <net/wext.h>\n\n#include \"dev.h\"\n\n \n\n \n\nstatic int dev_ifname(struct net *net, struct ifreq *ifr)\n{\n\tifr->ifr_name[IFNAMSIZ-1] = 0;\n\treturn netdev_get_name(net, ifr->ifr_name, ifr->ifr_ifindex);\n}\n\n \nint dev_ifconf(struct net *net, struct ifconf __user *uifc)\n{\n\tstruct net_device *dev;\n\tvoid __user *pos;\n\tsize_t size;\n\tint len, total = 0, done;\n\n\t \n\tif (in_compat_syscall()) {\n\t\tstruct compat_ifconf ifc32;\n\n\t\tif (copy_from_user(&ifc32, uifc, sizeof(struct compat_ifconf)))\n\t\t\treturn -EFAULT;\n\n\t\tpos = compat_ptr(ifc32.ifcbuf);\n\t\tlen = ifc32.ifc_len;\n\t\tsize = sizeof(struct compat_ifreq);\n\t} else {\n\t\tstruct ifconf ifc;\n\n\t\tif (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))\n\t\t\treturn -EFAULT;\n\n\t\tpos = ifc.ifc_buf;\n\t\tlen = ifc.ifc_len;\n\t\tsize = sizeof(struct ifreq);\n\t}\n\n\t \n\trtnl_lock();\n\tfor_each_netdev(net, dev) {\n\t\tif (!pos)\n\t\t\tdone = inet_gifconf(dev, NULL, 0, size);\n\t\telse\n\t\t\tdone = inet_gifconf(dev, pos + total,\n\t\t\t\t\t    len - total, size);\n\t\tif (done < 0) {\n\t\t\trtnl_unlock();\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttotal += done;\n\t}\n\trtnl_unlock();\n\n\treturn put_user(total, &uifc->ifc_len);\n}\n\nstatic int dev_getifmap(struct net_device *dev, struct ifreq *ifr)\n{\n\tstruct ifmap *ifmap = &ifr->ifr_map;\n\n\tif (in_compat_syscall()) {\n\t\tstruct compat_ifmap *cifmap = (struct compat_ifmap *)ifmap;\n\n\t\tcifmap->mem_start = dev->mem_start;\n\t\tcifmap->mem_end   = dev->mem_end;\n\t\tcifmap->base_addr = dev->base_addr;\n\t\tcifmap->irq       = dev->irq;\n\t\tcifmap->dma       = dev->dma;\n\t\tcifmap->port      = dev->if_port;\n\n\t\treturn 0;\n\t}\n\n\tifmap->mem_start  = dev->mem_start;\n\tifmap->mem_end    = dev->mem_end;\n\tifmap->base_addr  = dev->base_addr;\n\tifmap->irq        = dev->irq;\n\tifmap->dma        = dev->dma;\n\tifmap->port       = dev->if_port;\n\n\treturn 0;\n}\n\nstatic int dev_setifmap(struct net_device *dev, struct ifreq *ifr)\n{\n\tstruct compat_ifmap *cifmap = (struct compat_ifmap *)&ifr->ifr_map;\n\n\tif (!dev->netdev_ops->ndo_set_config)\n\t\treturn -EOPNOTSUPP;\n\n\tif (in_compat_syscall()) {\n\t\tstruct ifmap ifmap = {\n\t\t\t.mem_start  = cifmap->mem_start,\n\t\t\t.mem_end    = cifmap->mem_end,\n\t\t\t.base_addr  = cifmap->base_addr,\n\t\t\t.irq        = cifmap->irq,\n\t\t\t.dma        = cifmap->dma,\n\t\t\t.port       = cifmap->port,\n\t\t};\n\n\t\treturn dev->netdev_ops->ndo_set_config(dev, &ifmap);\n\t}\n\n\treturn dev->netdev_ops->ndo_set_config(dev, &ifr->ifr_map);\n}\n\n \nstatic int dev_ifsioc_locked(struct net *net, struct ifreq *ifr, unsigned int cmd)\n{\n\tint err;\n\tstruct net_device *dev = dev_get_by_name_rcu(net, ifr->ifr_name);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase SIOCGIFFLAGS:\t \n\t\tifr->ifr_flags = (short) dev_get_flags(dev);\n\t\treturn 0;\n\n\tcase SIOCGIFMETRIC:\t \n\t\tifr->ifr_metric = 0;\n\t\treturn 0;\n\n\tcase SIOCGIFMTU:\t \n\t\tifr->ifr_mtu = dev->mtu;\n\t\treturn 0;\n\n\tcase SIOCGIFSLAVE:\n\t\terr = -EINVAL;\n\t\tbreak;\n\n\tcase SIOCGIFMAP:\n\t\treturn dev_getifmap(dev, ifr);\n\n\tcase SIOCGIFINDEX:\n\t\tifr->ifr_ifindex = dev->ifindex;\n\t\treturn 0;\n\n\tcase SIOCGIFTXQLEN:\n\t\tifr->ifr_qlen = dev->tx_queue_len;\n\t\treturn 0;\n\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\terr = -ENOTTY;\n\t\tbreak;\n\n\t}\n\treturn err;\n}\n\nstatic int net_hwtstamp_validate(const struct kernel_hwtstamp_config *cfg)\n{\n\tenum hwtstamp_tx_types tx_type;\n\tenum hwtstamp_rx_filters rx_filter;\n\tint tx_type_valid = 0;\n\tint rx_filter_valid = 0;\n\n\tif (cfg->flags & ~HWTSTAMP_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\ttx_type = cfg->tx_type;\n\trx_filter = cfg->rx_filter;\n\n\tswitch (tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\tcase HWTSTAMP_TX_ON:\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\tcase HWTSTAMP_TX_ONESTEP_P2P:\n\t\ttx_type_valid = 1;\n\t\tbreak;\n\tcase __HWTSTAMP_TX_CNT:\n\t\t \n\t\tbreak;\n\t}\n\n\tswitch (rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_SOME:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\trx_filter_valid = 1;\n\t\tbreak;\n\tcase __HWTSTAMP_FILTER_CNT:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (!tx_type_valid || !rx_filter_valid)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nstatic int dev_eth_ioctl(struct net_device *dev,\n\t\t\t struct ifreq *ifr, unsigned int cmd)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tif (!ops->ndo_eth_ioctl)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!netif_device_present(dev))\n\t\treturn -ENODEV;\n\n\treturn ops->ndo_eth_ioctl(dev, ifr, cmd);\n}\n\n \nstatic int dev_get_hwtstamp_phylib(struct net_device *dev,\n\t\t\t\t   struct kernel_hwtstamp_config *cfg)\n{\n\tif (phy_has_hwtstamp(dev->phydev))\n\t\treturn phy_hwtstamp_get(dev->phydev, cfg);\n\n\treturn dev->netdev_ops->ndo_hwtstamp_get(dev, cfg);\n}\n\nstatic int dev_get_hwtstamp(struct net_device *dev, struct ifreq *ifr)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tstruct kernel_hwtstamp_config kernel_cfg = {};\n\tstruct hwtstamp_config cfg;\n\tint err;\n\n\tif (!ops->ndo_hwtstamp_get)\n\t\treturn dev_eth_ioctl(dev, ifr, SIOCGHWTSTAMP);  \n\n\tif (!netif_device_present(dev))\n\t\treturn -ENODEV;\n\n\tkernel_cfg.ifr = ifr;\n\terr = dev_get_hwtstamp_phylib(dev, &kernel_cfg);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!kernel_cfg.copied_to_user) {\n\t\thwtstamp_config_from_kernel(&cfg, &kernel_cfg);\n\n\t\tif (copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dev_set_hwtstamp_phylib(struct net_device *dev,\n\t\t\t\t   struct kernel_hwtstamp_config *cfg,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tbool phy_ts = phy_has_hwtstamp(dev->phydev);\n\tstruct kernel_hwtstamp_config old_cfg = {};\n\tbool changed = false;\n\tint err;\n\n\tcfg->source = phy_ts ? HWTSTAMP_SOURCE_PHYLIB : HWTSTAMP_SOURCE_NETDEV;\n\n\tif (phy_ts && (dev->priv_flags & IFF_SEE_ALL_HWTSTAMP_REQUESTS)) {\n\t\terr = ops->ndo_hwtstamp_get(dev, &old_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!phy_ts || (dev->priv_flags & IFF_SEE_ALL_HWTSTAMP_REQUESTS)) {\n\t\terr = ops->ndo_hwtstamp_set(dev, cfg, extack);\n\t\tif (err) {\n\t\t\tif (extack->_msg)\n\t\t\t\tnetdev_err(dev, \"%s\\n\", extack->_msg);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (phy_ts && (dev->priv_flags & IFF_SEE_ALL_HWTSTAMP_REQUESTS))\n\t\tchanged = kernel_hwtstamp_config_changed(&old_cfg, cfg);\n\n\tif (phy_ts) {\n\t\terr = phy_hwtstamp_set(dev->phydev, cfg, extack);\n\t\tif (err) {\n\t\t\tif (changed)\n\t\t\t\tops->ndo_hwtstamp_set(dev, &old_cfg, NULL);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dev_set_hwtstamp(struct net_device *dev, struct ifreq *ifr)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tstruct kernel_hwtstamp_config kernel_cfg = {};\n\tstruct netlink_ext_ack extack = {};\n\tstruct hwtstamp_config cfg;\n\tint err;\n\n\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\thwtstamp_config_to_kernel(&kernel_cfg, &cfg);\n\tkernel_cfg.ifr = ifr;\n\n\terr = net_hwtstamp_validate(&kernel_cfg);\n\tif (err)\n\t\treturn err;\n\n\terr = dsa_master_hwtstamp_validate(dev, &kernel_cfg, &extack);\n\tif (err) {\n\t\tif (extack._msg)\n\t\t\tnetdev_err(dev, \"%s\\n\", extack._msg);\n\t\treturn err;\n\t}\n\n\tif (!ops->ndo_hwtstamp_set)\n\t\treturn dev_eth_ioctl(dev, ifr, SIOCSHWTSTAMP);  \n\n\tif (!netif_device_present(dev))\n\t\treturn -ENODEV;\n\n\terr = dev_set_hwtstamp_phylib(dev, &kernel_cfg, &extack);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!kernel_cfg.copied_to_user) {\n\t\thwtstamp_config_from_kernel(&cfg, &kernel_cfg);\n\n\t\tif (copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int generic_hwtstamp_ioctl_lower(struct net_device *dev, int cmd,\n\t\t\t\t\tstruct kernel_hwtstamp_config *kernel_cfg)\n{\n\tstruct ifreq ifrr;\n\tint err;\n\n\tstrscpy_pad(ifrr.ifr_name, dev->name, IFNAMSIZ);\n\tifrr.ifr_ifru = kernel_cfg->ifr->ifr_ifru;\n\n\terr = dev_eth_ioctl(dev, &ifrr, cmd);\n\tif (err)\n\t\treturn err;\n\n\tkernel_cfg->ifr->ifr_ifru = ifrr.ifr_ifru;\n\tkernel_cfg->copied_to_user = true;\n\n\treturn 0;\n}\n\nint generic_hwtstamp_get_lower(struct net_device *dev,\n\t\t\t       struct kernel_hwtstamp_config *kernel_cfg)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tif (!netif_device_present(dev))\n\t\treturn -ENODEV;\n\n\tif (ops->ndo_hwtstamp_get)\n\t\treturn dev_get_hwtstamp_phylib(dev, kernel_cfg);\n\n\t \n\treturn generic_hwtstamp_ioctl_lower(dev, SIOCGHWTSTAMP, kernel_cfg);\n}\nEXPORT_SYMBOL(generic_hwtstamp_get_lower);\n\nint generic_hwtstamp_set_lower(struct net_device *dev,\n\t\t\t       struct kernel_hwtstamp_config *kernel_cfg,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tif (!netif_device_present(dev))\n\t\treturn -ENODEV;\n\n\tif (ops->ndo_hwtstamp_set)\n\t\treturn dev_set_hwtstamp_phylib(dev, kernel_cfg, extack);\n\n\t \n\treturn generic_hwtstamp_ioctl_lower(dev, SIOCSHWTSTAMP, kernel_cfg);\n}\nEXPORT_SYMBOL(generic_hwtstamp_set_lower);\n\nstatic int dev_siocbond(struct net_device *dev,\n\t\t\tstruct ifreq *ifr, unsigned int cmd)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tif (ops->ndo_siocbond) {\n\t\tif (netif_device_present(dev))\n\t\t\treturn ops->ndo_siocbond(dev, ifr, cmd);\n\t\telse\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int dev_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t      void __user *data, unsigned int cmd)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tif (ops->ndo_siocdevprivate) {\n\t\tif (netif_device_present(dev))\n\t\t\treturn ops->ndo_siocdevprivate(dev, ifr, data, cmd);\n\t\telse\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int dev_siocwandev(struct net_device *dev, struct if_settings *ifs)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tif (ops->ndo_siocwandev) {\n\t\tif (netif_device_present(dev))\n\t\t\treturn ops->ndo_siocwandev(dev, ifs);\n\t\telse\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int dev_ifsioc(struct net *net, struct ifreq *ifr, void __user *data,\n\t\t      unsigned int cmd)\n{\n\tint err;\n\tstruct net_device *dev = __dev_get_by_name(net, ifr->ifr_name);\n\tconst struct net_device_ops *ops;\n\tnetdevice_tracker dev_tracker;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tops = dev->netdev_ops;\n\n\tswitch (cmd) {\n\tcase SIOCSIFFLAGS:\t \n\t\treturn dev_change_flags(dev, ifr->ifr_flags, NULL);\n\n\tcase SIOCSIFMETRIC:\t \n\t\treturn -EOPNOTSUPP;\n\n\tcase SIOCSIFMTU:\t \n\t\treturn dev_set_mtu(dev, ifr->ifr_mtu);\n\n\tcase SIOCSIFHWADDR:\n\t\tif (dev->addr_len > sizeof(struct sockaddr))\n\t\t\treturn -EINVAL;\n\t\treturn dev_set_mac_address_user(dev, &ifr->ifr_hwaddr, NULL);\n\n\tcase SIOCSIFHWBROADCAST:\n\t\tif (ifr->ifr_hwaddr.sa_family != dev->type)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(dev->broadcast, ifr->ifr_hwaddr.sa_data,\n\t\t       min(sizeof(ifr->ifr_hwaddr.sa_data_min),\n\t\t\t   (size_t)dev->addr_len));\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\n\t\treturn 0;\n\n\tcase SIOCSIFMAP:\n\t\treturn dev_setifmap(dev, ifr);\n\n\tcase SIOCADDMULTI:\n\t\tif (!ops->ndo_set_rx_mode ||\n\t\t    ifr->ifr_hwaddr.sa_family != AF_UNSPEC)\n\t\t\treturn -EINVAL;\n\t\tif (!netif_device_present(dev))\n\t\t\treturn -ENODEV;\n\t\treturn dev_mc_add_global(dev, ifr->ifr_hwaddr.sa_data);\n\n\tcase SIOCDELMULTI:\n\t\tif (!ops->ndo_set_rx_mode ||\n\t\t    ifr->ifr_hwaddr.sa_family != AF_UNSPEC)\n\t\t\treturn -EINVAL;\n\t\tif (!netif_device_present(dev))\n\t\t\treturn -ENODEV;\n\t\treturn dev_mc_del_global(dev, ifr->ifr_hwaddr.sa_data);\n\n\tcase SIOCSIFTXQLEN:\n\t\tif (ifr->ifr_qlen < 0)\n\t\t\treturn -EINVAL;\n\t\treturn dev_change_tx_queue_len(dev, ifr->ifr_qlen);\n\n\tcase SIOCSIFNAME:\n\t\tifr->ifr_newname[IFNAMSIZ-1] = '\\0';\n\t\treturn dev_change_name(dev, ifr->ifr_newname);\n\n\tcase SIOCWANDEV:\n\t\treturn dev_siocwandev(dev, &ifr->ifr_settings);\n\n\tcase SIOCBRADDIF:\n\tcase SIOCBRDELIF:\n\t\tif (!netif_device_present(dev))\n\t\t\treturn -ENODEV;\n\t\tif (!netif_is_bridge_master(dev))\n\t\t\treturn -EOPNOTSUPP;\n\t\tnetdev_hold(dev, &dev_tracker, GFP_KERNEL);\n\t\trtnl_unlock();\n\t\terr = br_ioctl_call(net, netdev_priv(dev), cmd, ifr, NULL);\n\t\tnetdev_put(dev, &dev_tracker);\n\t\trtnl_lock();\n\t\treturn err;\n\n\tcase SIOCDEVPRIVATE ... SIOCDEVPRIVATE + 15:\n\t\treturn dev_siocdevprivate(dev, ifr, data, cmd);\n\n\tcase SIOCSHWTSTAMP:\n\t\treturn dev_set_hwtstamp(dev, ifr);\n\n\tcase SIOCGHWTSTAMP:\n\t\treturn dev_get_hwtstamp(dev, ifr);\n\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn dev_eth_ioctl(dev, ifr, cmd);\n\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\tcase SIOCBONDCHANGEACTIVE:\n\t\treturn dev_siocbond(dev, ifr, cmd);\n\n\t \n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\n \n\nvoid dev_load(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\tint no_module;\n\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(net, name);\n\trcu_read_unlock();\n\n\tno_module = !dev;\n\tif (no_module && capable(CAP_NET_ADMIN))\n\t\tno_module = request_module(\"netdev-%s\", name);\n\tif (no_module && capable(CAP_SYS_MODULE))\n\t\trequest_module(\"%s\", name);\n}\nEXPORT_SYMBOL(dev_load);\n\n \n\n \n\nint dev_ioctl(struct net *net, unsigned int cmd, struct ifreq *ifr,\n\t      void __user *data, bool *need_copyout)\n{\n\tint ret;\n\tchar *colon;\n\n\tif (need_copyout)\n\t\t*need_copyout = true;\n\tif (cmd == SIOCGIFNAME)\n\t\treturn dev_ifname(net, ifr);\n\n\tifr->ifr_name[IFNAMSIZ-1] = 0;\n\n\tcolon = strchr(ifr->ifr_name, ':');\n\tif (colon)\n\t\t*colon = 0;\n\n\t \n\n\tswitch (cmd) {\n\tcase SIOCGIFHWADDR:\n\t\tdev_load(net, ifr->ifr_name);\n\t\tret = dev_get_mac_address(&ifr->ifr_hwaddr, net, ifr->ifr_name);\n\t\tif (colon)\n\t\t\t*colon = ':';\n\t\treturn ret;\n\t \n\tcase SIOCGIFFLAGS:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCGIFMTU:\n\tcase SIOCGIFSLAVE:\n\tcase SIOCGIFMAP:\n\tcase SIOCGIFINDEX:\n\tcase SIOCGIFTXQLEN:\n\t\tdev_load(net, ifr->ifr_name);\n\t\trcu_read_lock();\n\t\tret = dev_ifsioc_locked(net, ifr, cmd);\n\t\trcu_read_unlock();\n\t\tif (colon)\n\t\t\t*colon = ':';\n\t\treturn ret;\n\n\tcase SIOCETHTOOL:\n\t\tdev_load(net, ifr->ifr_name);\n\t\tret = dev_ethtool(net, ifr, data);\n\t\tif (colon)\n\t\t\t*colon = ':';\n\t\treturn ret;\n\n\t \n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSIFNAME:\n\t\tdev_load(net, ifr->ifr_name);\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\trtnl_lock();\n\t\tret = dev_ifsioc(net, ifr, data, cmd);\n\t\trtnl_unlock();\n\t\tif (colon)\n\t\t\t*colon = ':';\n\t\treturn ret;\n\n\t \n\tcase SIOCSIFMAP:\n\tcase SIOCSIFTXQLEN:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tfallthrough;\n\t \n\tcase SIOCSIFFLAGS:\n\tcase SIOCSIFMETRIC:\n\tcase SIOCSIFMTU:\n\tcase SIOCSIFHWADDR:\n\tcase SIOCSIFSLAVE:\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\tcase SIOCSIFHWBROADCAST:\n\tcase SIOCSMIIREG:\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDCHANGEACTIVE:\n\tcase SIOCBRADDIF:\n\tcase SIOCBRDELIF:\n\tcase SIOCSHWTSTAMP:\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tfallthrough;\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\t\tdev_load(net, ifr->ifr_name);\n\t\trtnl_lock();\n\t\tret = dev_ifsioc(net, ifr, data, cmd);\n\t\trtnl_unlock();\n\t\tif (need_copyout)\n\t\t\t*need_copyout = false;\n\t\treturn ret;\n\n\tcase SIOCGIFMEM:\n\t\t \n\tcase SIOCSIFMEM:\n\t\t \n\tcase SIOCSIFLINK:\n\t\treturn -ENOTTY;\n\n\t \n\tdefault:\n\t\tif (cmd == SIOCWANDEV ||\n\t\t    cmd == SIOCGHWTSTAMP ||\n\t\t    (cmd >= SIOCDEVPRIVATE &&\n\t\t     cmd <= SIOCDEVPRIVATE + 15)) {\n\t\t\tdev_load(net, ifr->ifr_name);\n\t\t\trtnl_lock();\n\t\t\tret = dev_ifsioc(net, ifr, data, cmd);\n\t\t\trtnl_unlock();\n\t\t\treturn ret;\n\t\t}\n\t\treturn -ENOTTY;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}