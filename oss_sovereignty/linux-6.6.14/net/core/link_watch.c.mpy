{
  "module_name": "link_watch.c",
  "hash_id": "728fd5b00fa5f5b688d3c4cc3d6aa0f8648ab4131f89d162e27bcd27de75c20b",
  "original_prompt": "Ingested from linux-6.6.14/net/core/link_watch.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/if.h>\n#include <net/sock.h>\n#include <net/pkt_sched.h>\n#include <linux/rtnetlink.h>\n#include <linux/jiffies.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/bitops.h>\n#include <linux/types.h>\n\n#include \"dev.h\"\n\nenum lw_bits {\n\tLW_URGENT = 0,\n};\n\nstatic unsigned long linkwatch_flags;\nstatic unsigned long linkwatch_nextevent;\n\nstatic void linkwatch_event(struct work_struct *dummy);\nstatic DECLARE_DELAYED_WORK(linkwatch_work, linkwatch_event);\n\nstatic LIST_HEAD(lweventlist);\nstatic DEFINE_SPINLOCK(lweventlist_lock);\n\nstatic unsigned char default_operstate(const struct net_device *dev)\n{\n\tif (netif_testing(dev))\n\t\treturn IF_OPER_TESTING;\n\n\t \n\tif (!netif_carrier_ok(dev)) {\n\t\tint iflink = dev_get_iflink(dev);\n\t\tstruct net_device *peer;\n\n\t\tif (iflink == dev->ifindex)\n\t\t\treturn IF_OPER_DOWN;\n\n\t\tpeer = __dev_get_by_index(dev_net(dev), iflink);\n\t\tif (!peer)\n\t\t\treturn IF_OPER_DOWN;\n\n\t\treturn netif_carrier_ok(peer) ? IF_OPER_DOWN :\n\t\t\t\t\t\tIF_OPER_LOWERLAYERDOWN;\n\t}\n\n\tif (netif_dormant(dev))\n\t\treturn IF_OPER_DORMANT;\n\n\treturn IF_OPER_UP;\n}\n\n\nstatic void rfc2863_policy(struct net_device *dev)\n{\n\tunsigned char operstate = default_operstate(dev);\n\n\tif (operstate == dev->operstate)\n\t\treturn;\n\n\twrite_lock(&dev_base_lock);\n\n\tswitch(dev->link_mode) {\n\tcase IF_LINK_MODE_TESTING:\n\t\tif (operstate == IF_OPER_UP)\n\t\t\toperstate = IF_OPER_TESTING;\n\t\tbreak;\n\n\tcase IF_LINK_MODE_DORMANT:\n\t\tif (operstate == IF_OPER_UP)\n\t\t\toperstate = IF_OPER_DORMANT;\n\t\tbreak;\n\tcase IF_LINK_MODE_DEFAULT:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev->operstate = operstate;\n\n\twrite_unlock(&dev_base_lock);\n}\n\n\nvoid linkwatch_init_dev(struct net_device *dev)\n{\n\t \n\tif (!netif_carrier_ok(dev) || netif_dormant(dev) ||\n\t    netif_testing(dev))\n\t\trfc2863_policy(dev);\n}\n\n\nstatic bool linkwatch_urgent_event(struct net_device *dev)\n{\n\tif (!netif_running(dev))\n\t\treturn false;\n\n\tif (dev->ifindex != dev_get_iflink(dev))\n\t\treturn true;\n\n\tif (netif_is_lag_port(dev) || netif_is_lag_master(dev))\n\t\treturn true;\n\n\treturn netif_carrier_ok(dev) &&\tqdisc_tx_changing(dev);\n}\n\n\nstatic void linkwatch_add_event(struct net_device *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lweventlist_lock, flags);\n\tif (list_empty(&dev->link_watch_list)) {\n\t\tlist_add_tail(&dev->link_watch_list, &lweventlist);\n\t\tnetdev_hold(dev, &dev->linkwatch_dev_tracker, GFP_ATOMIC);\n\t}\n\tspin_unlock_irqrestore(&lweventlist_lock, flags);\n}\n\n\nstatic void linkwatch_schedule_work(int urgent)\n{\n\tunsigned long delay = linkwatch_nextevent - jiffies;\n\n\tif (test_bit(LW_URGENT, &linkwatch_flags))\n\t\treturn;\n\n\t \n\tif (urgent) {\n\t\tif (test_and_set_bit(LW_URGENT, &linkwatch_flags))\n\t\t\treturn;\n\t\tdelay = 0;\n\t}\n\n\t \n\tif (delay > HZ)\n\t\tdelay = 0;\n\n\t \n\tif (test_bit(LW_URGENT, &linkwatch_flags))\n\t\tmod_delayed_work(system_wq, &linkwatch_work, 0);\n\telse\n\t\tschedule_delayed_work(&linkwatch_work, delay);\n}\n\n\nstatic void linkwatch_do_dev(struct net_device *dev)\n{\n\t \n\tsmp_mb__before_atomic();\n\n\t \n\tclear_bit(__LINK_STATE_LINKWATCH_PENDING, &dev->state);\n\n\trfc2863_policy(dev);\n\tif (dev->flags & IFF_UP) {\n\t\tif (netif_carrier_ok(dev))\n\t\t\tdev_activate(dev);\n\t\telse\n\t\t\tdev_deactivate(dev);\n\n\t\tnetdev_state_change(dev);\n\t}\n\t \n\t__dev_put(dev);\n}\n\nstatic void __linkwatch_run_queue(int urgent_only)\n{\n#define MAX_DO_DEV_PER_LOOP\t100\n\n\tint do_dev = MAX_DO_DEV_PER_LOOP;\n\tstruct net_device *dev;\n\tLIST_HEAD(wrk);\n\n\t \n\tif (urgent_only)\n\t\tdo_dev += MAX_DO_DEV_PER_LOOP;\n\n\t \n\tif (!urgent_only)\n\t\tlinkwatch_nextevent = jiffies + HZ;\n\t \n\telse if (time_after(linkwatch_nextevent, jiffies + HZ))\n\t\tlinkwatch_nextevent = jiffies;\n\n\tclear_bit(LW_URGENT, &linkwatch_flags);\n\n\tspin_lock_irq(&lweventlist_lock);\n\tlist_splice_init(&lweventlist, &wrk);\n\n\twhile (!list_empty(&wrk) && do_dev > 0) {\n\n\t\tdev = list_first_entry(&wrk, struct net_device, link_watch_list);\n\t\tlist_del_init(&dev->link_watch_list);\n\n\t\tif (!netif_device_present(dev) ||\n\t\t    (urgent_only && !linkwatch_urgent_event(dev))) {\n\t\t\tlist_add_tail(&dev->link_watch_list, &lweventlist);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tnetdev_tracker_free(dev, &dev->linkwatch_dev_tracker);\n\t\tspin_unlock_irq(&lweventlist_lock);\n\t\tlinkwatch_do_dev(dev);\n\t\tdo_dev--;\n\t\tspin_lock_irq(&lweventlist_lock);\n\t}\n\n\t \n\tlist_splice_init(&wrk, &lweventlist);\n\n\tif (!list_empty(&lweventlist))\n\t\tlinkwatch_schedule_work(0);\n\tspin_unlock_irq(&lweventlist_lock);\n}\n\nvoid linkwatch_forget_dev(struct net_device *dev)\n{\n\tunsigned long flags;\n\tint clean = 0;\n\n\tspin_lock_irqsave(&lweventlist_lock, flags);\n\tif (!list_empty(&dev->link_watch_list)) {\n\t\tlist_del_init(&dev->link_watch_list);\n\t\tclean = 1;\n\t\t \n\t\tnetdev_tracker_free(dev, &dev->linkwatch_dev_tracker);\n\t}\n\tspin_unlock_irqrestore(&lweventlist_lock, flags);\n\tif (clean)\n\t\tlinkwatch_do_dev(dev);\n}\n\n\n \nvoid linkwatch_run_queue(void)\n{\n\t__linkwatch_run_queue(0);\n}\n\n\nstatic void linkwatch_event(struct work_struct *dummy)\n{\n\trtnl_lock();\n\t__linkwatch_run_queue(time_after(linkwatch_nextevent, jiffies));\n\trtnl_unlock();\n}\n\n\nvoid linkwatch_fire_event(struct net_device *dev)\n{\n\tbool urgent = linkwatch_urgent_event(dev);\n\n\tif (!test_and_set_bit(__LINK_STATE_LINKWATCH_PENDING, &dev->state)) {\n\t\tlinkwatch_add_event(dev);\n\t} else if (!urgent)\n\t\treturn;\n\n\tlinkwatch_schedule_work(urgent);\n}\nEXPORT_SYMBOL(linkwatch_fire_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}