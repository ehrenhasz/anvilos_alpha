{
  "module_name": "stream.c",
  "hash_id": "3735253b2cc29fe8b4ed4a31d30b016a7645b21b963b25f61fcfa39353da8017",
  "original_prompt": "Ingested from linux-6.6.14/net/core/stream.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/net.h>\n#include <linux/signal.h>\n#include <linux/tcp.h>\n#include <linux/wait.h>\n#include <net/sock.h>\n\n \nvoid sk_stream_write_space(struct sock *sk)\n{\n\tstruct socket *sock = sk->sk_socket;\n\tstruct socket_wq *wq;\n\n\tif (__sk_stream_is_writeable(sk, 1) && sock) {\n\t\tclear_bit(SOCK_NOSPACE, &sock->flags);\n\n\t\trcu_read_lock();\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (skwq_has_sleeper(wq))\n\t\t\twake_up_interruptible_poll(&wq->wait, EPOLLOUT |\n\t\t\t\t\t\tEPOLLWRNORM | EPOLLWRBAND);\n\t\tif (wq && wq->fasync_list && !(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\t\tsock_wake_async(wq, SOCK_WAKE_SPACE, POLL_OUT);\n\t\trcu_read_unlock();\n\t}\n}\n\n \nint sk_stream_wait_connect(struct sock *sk, long *timeo_p)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct task_struct *tsk = current;\n\tint done;\n\n\tdo {\n\t\tint err = sock_error(sk);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif ((1 << sk->sk_state) & ~(TCPF_SYN_SENT | TCPF_SYN_RECV))\n\t\t\treturn -EPIPE;\n\t\tif (!*timeo_p)\n\t\t\treturn -EAGAIN;\n\t\tif (signal_pending(tsk))\n\t\t\treturn sock_intr_errno(*timeo_p);\n\n\t\tadd_wait_queue(sk_sleep(sk), &wait);\n\t\tsk->sk_write_pending++;\n\t\tdone = sk_wait_event(sk, timeo_p,\n\t\t\t\t     !READ_ONCE(sk->sk_err) &&\n\t\t\t\t     !((1 << READ_ONCE(sk->sk_state)) &\n\t\t\t\t       ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)), &wait);\n\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\t\tsk->sk_write_pending--;\n\t} while (!done);\n\treturn done < 0 ? done : 0;\n}\nEXPORT_SYMBOL(sk_stream_wait_connect);\n\n \nstatic int sk_stream_closing(const struct sock *sk)\n{\n\treturn (1 << READ_ONCE(sk->sk_state)) &\n\t       (TCPF_FIN_WAIT1 | TCPF_CLOSING | TCPF_LAST_ACK);\n}\n\nvoid sk_stream_wait_close(struct sock *sk, long timeout)\n{\n\tif (timeout) {\n\t\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\t\tadd_wait_queue(sk_sleep(sk), &wait);\n\n\t\tdo {\n\t\t\tif (sk_wait_event(sk, &timeout, !sk_stream_closing(sk), &wait))\n\t\t\t\tbreak;\n\t\t} while (!signal_pending(current) && timeout);\n\n\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\t}\n}\nEXPORT_SYMBOL(sk_stream_wait_close);\n\n \nint sk_stream_wait_memory(struct sock *sk, long *timeo_p)\n{\n\tint ret, err = 0;\n\tlong vm_wait = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tif (sk_stream_memory_free(sk))\n\t\tcurrent_timeo = vm_wait = get_random_u32_below(HZ / 5) + 2;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\n\twhile (1) {\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\t\tif (sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN))\n\t\t\tgoto do_error;\n\t\tif (!*timeo_p)\n\t\t\tgoto do_eagain;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tsk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\t\tif (sk_stream_memory_free(sk) && !vm_wait)\n\t\t\tbreak;\n\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\tsk->sk_write_pending++;\n\t\tret = sk_wait_event(sk, &current_timeo, READ_ONCE(sk->sk_err) ||\n\t\t\t\t    (READ_ONCE(sk->sk_shutdown) & SEND_SHUTDOWN) ||\n\t\t\t\t    (sk_stream_memory_free(sk) && !vm_wait),\n\t\t\t\t    &wait);\n\t\tsk->sk_write_pending--;\n\t\tif (ret < 0)\n\t\t\tgoto do_error;\n\n\t\tif (vm_wait) {\n\t\t\tvm_wait -= current_timeo;\n\t\t\tcurrent_timeo = *timeo_p;\n\t\t\tif (current_timeo != MAX_SCHEDULE_TIMEOUT &&\n\t\t\t    (current_timeo -= vm_wait) < 0)\n\t\t\t\tcurrent_timeo = 0;\n\t\t\tvm_wait = 0;\n\t\t}\n\t\t*timeo_p = current_timeo;\n\t}\nout:\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\ndo_eagain:\n\t \n\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\terr = -EAGAIN;\n\tgoto out;\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n}\nEXPORT_SYMBOL(sk_stream_wait_memory);\n\nint sk_stream_error(struct sock *sk, int flags, int err)\n{\n\tif (err == -EPIPE)\n\t\terr = sock_error(sk) ? : -EPIPE;\n\tif (err == -EPIPE && !(flags & MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\treturn err;\n}\nEXPORT_SYMBOL(sk_stream_error);\n\nvoid sk_stream_kill_queues(struct sock *sk)\n{\n\t \n\t__skb_queue_purge(&sk->sk_receive_queue);\n\n\t \n\tskb_queue_purge(&sk->sk_error_queue);\n\n\t \n\tWARN_ON_ONCE(!skb_queue_empty(&sk->sk_write_queue));\n\n\t \n\tsk_mem_reclaim_final(sk);\n\n\tWARN_ON_ONCE(sk->sk_wmem_queued);\n\n\t \n}\nEXPORT_SYMBOL(sk_stream_kill_queues);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}