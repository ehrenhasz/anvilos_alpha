{
  "module_name": "rtnetlink.c",
  "hash_id": "f288ab2a33069c83a6202d63d491541867b3dda57b47e9ca48997c97233d45d2",
  "original_prompt": "Ingested from linux-6.6.14/net/core/rtnetlink.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/capability.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/if_addr.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n#include <linux/bpf.h>\n\n#include <linux/uaccess.h>\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/arp.h>\n#include <net/route.h>\n#include <net/udp.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <net/pkt_sched.h>\n#include <net/fib_rules.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n#include <net/devlink.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/addrconf.h>\n#endif\n\n#include \"dev.h\"\n\n#define RTNL_MAX_TYPE\t\t50\n#define RTNL_SLAVE_MAX_TYPE\t44\n\nstruct rtnl_link {\n\trtnl_doit_func\t\tdoit;\n\trtnl_dumpit_func\tdumpit;\n\tstruct module\t\t*owner;\n\tunsigned int\t\tflags;\n\tstruct rcu_head\t\trcu;\n};\n\nstatic DEFINE_MUTEX(rtnl_mutex);\n\nvoid rtnl_lock(void)\n{\n\tmutex_lock(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_lock);\n\nint rtnl_lock_killable(void)\n{\n\treturn mutex_lock_killable(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_lock_killable);\n\nstatic struct sk_buff *defer_kfree_skb_list;\nvoid rtnl_kfree_skbs(struct sk_buff *head, struct sk_buff *tail)\n{\n\tif (head && tail) {\n\t\ttail->next = defer_kfree_skb_list;\n\t\tdefer_kfree_skb_list = head;\n\t}\n}\nEXPORT_SYMBOL(rtnl_kfree_skbs);\n\nvoid __rtnl_unlock(void)\n{\n\tstruct sk_buff *head = defer_kfree_skb_list;\n\n\tdefer_kfree_skb_list = NULL;\n\n\t \n\tWARN_ON(!list_empty(&net_todo_list));\n\n\tmutex_unlock(&rtnl_mutex);\n\n\twhile (head) {\n\t\tstruct sk_buff *next = head->next;\n\n\t\tkfree_skb(head);\n\t\tcond_resched();\n\t\thead = next;\n\t}\n}\n\nvoid rtnl_unlock(void)\n{\n\t \n\tnetdev_run_todo();\n}\nEXPORT_SYMBOL(rtnl_unlock);\n\nint rtnl_trylock(void)\n{\n\treturn mutex_trylock(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_trylock);\n\nint rtnl_is_locked(void)\n{\n\treturn mutex_is_locked(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_is_locked);\n\nbool refcount_dec_and_rtnl_lock(refcount_t *r)\n{\n\treturn refcount_dec_and_mutex_lock(r, &rtnl_mutex);\n}\nEXPORT_SYMBOL(refcount_dec_and_rtnl_lock);\n\n#ifdef CONFIG_PROVE_LOCKING\nbool lockdep_rtnl_is_held(void)\n{\n\treturn lockdep_is_held(&rtnl_mutex);\n}\nEXPORT_SYMBOL(lockdep_rtnl_is_held);\n#endif  \n\nstatic struct rtnl_link __rcu *__rcu *rtnl_msg_handlers[RTNL_FAMILY_MAX + 1];\n\nstatic inline int rtm_msgindex(int msgtype)\n{\n\tint msgindex = msgtype - RTM_BASE;\n\n\t \n\tBUG_ON(msgindex < 0 || msgindex >= RTM_NR_MSGTYPES);\n\n\treturn msgindex;\n}\n\nstatic struct rtnl_link *rtnl_get_link(int protocol, int msgtype)\n{\n\tstruct rtnl_link __rcu **tab;\n\n\tif (protocol >= ARRAY_SIZE(rtnl_msg_handlers))\n\t\tprotocol = PF_UNSPEC;\n\n\ttab = rcu_dereference_rtnl(rtnl_msg_handlers[protocol]);\n\tif (!tab)\n\t\ttab = rcu_dereference_rtnl(rtnl_msg_handlers[PF_UNSPEC]);\n\n\treturn rcu_dereference_rtnl(tab[msgtype]);\n}\n\nstatic int rtnl_register_internal(struct module *owner,\n\t\t\t\t  int protocol, int msgtype,\n\t\t\t\t  rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct rtnl_link *link, *old;\n\tstruct rtnl_link __rcu **tab;\n\tint msgindex;\n\tint ret = -ENOBUFS;\n\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\tmsgindex = rtm_msgindex(msgtype);\n\n\trtnl_lock();\n\ttab = rtnl_dereference(rtnl_msg_handlers[protocol]);\n\tif (tab == NULL) {\n\t\ttab = kcalloc(RTM_NR_MSGTYPES, sizeof(void *), GFP_KERNEL);\n\t\tif (!tab)\n\t\t\tgoto unlock;\n\n\t\t \n\t\trcu_assign_pointer(rtnl_msg_handlers[protocol], tab);\n\t}\n\n\told = rtnl_dereference(tab[msgindex]);\n\tif (old) {\n\t\tlink = kmemdup(old, sizeof(*old), GFP_KERNEL);\n\t\tif (!link)\n\t\t\tgoto unlock;\n\t} else {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link)\n\t\t\tgoto unlock;\n\t}\n\n\tWARN_ON(link->owner && link->owner != owner);\n\tlink->owner = owner;\n\n\tWARN_ON(doit && link->doit && link->doit != doit);\n\tif (doit)\n\t\tlink->doit = doit;\n\tWARN_ON(dumpit && link->dumpit && link->dumpit != dumpit);\n\tif (dumpit)\n\t\tlink->dumpit = dumpit;\n\n\tWARN_ON(rtnl_msgtype_kind(msgtype) != RTNL_KIND_DEL &&\n\t\t(flags & RTNL_FLAG_BULK_DEL_SUPPORTED));\n\tlink->flags |= flags;\n\n\t \n\trcu_assign_pointer(tab[msgindex], link);\n\tret = 0;\n\tif (old)\n\t\tkfree_rcu(old, rcu);\nunlock:\n\trtnl_unlock();\n\treturn ret;\n}\n\n \nint rtnl_register_module(struct module *owner,\n\t\t\t int protocol, int msgtype,\n\t\t\t rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t\t unsigned int flags)\n{\n\treturn rtnl_register_internal(owner, protocol, msgtype,\n\t\t\t\t      doit, dumpit, flags);\n}\nEXPORT_SYMBOL_GPL(rtnl_register_module);\n\n \nvoid rtnl_register(int protocol, int msgtype,\n\t\t   rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t   unsigned int flags)\n{\n\tint err;\n\n\terr = rtnl_register_internal(NULL, protocol, msgtype, doit, dumpit,\n\t\t\t\t     flags);\n\tif (err)\n\t\tpr_err(\"Unable to register rtnetlink message handler, \"\n\t\t       \"protocol = %d, message type = %d\\n\", protocol, msgtype);\n}\n\n \nint rtnl_unregister(int protocol, int msgtype)\n{\n\tstruct rtnl_link __rcu **tab;\n\tstruct rtnl_link *link;\n\tint msgindex;\n\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\tmsgindex = rtm_msgindex(msgtype);\n\n\trtnl_lock();\n\ttab = rtnl_dereference(rtnl_msg_handlers[protocol]);\n\tif (!tab) {\n\t\trtnl_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\tlink = rtnl_dereference(tab[msgindex]);\n\tRCU_INIT_POINTER(tab[msgindex], NULL);\n\trtnl_unlock();\n\n\tkfree_rcu(link, rcu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtnl_unregister);\n\n \nvoid rtnl_unregister_all(int protocol)\n{\n\tstruct rtnl_link __rcu **tab;\n\tstruct rtnl_link *link;\n\tint msgindex;\n\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\n\trtnl_lock();\n\ttab = rtnl_dereference(rtnl_msg_handlers[protocol]);\n\tif (!tab) {\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\tRCU_INIT_POINTER(rtnl_msg_handlers[protocol], NULL);\n\tfor (msgindex = 0; msgindex < RTM_NR_MSGTYPES; msgindex++) {\n\t\tlink = rtnl_dereference(tab[msgindex]);\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\tRCU_INIT_POINTER(tab[msgindex], NULL);\n\t\tkfree_rcu(link, rcu);\n\t}\n\trtnl_unlock();\n\n\tsynchronize_net();\n\n\tkfree(tab);\n}\nEXPORT_SYMBOL_GPL(rtnl_unregister_all);\n\nstatic LIST_HEAD(link_ops);\n\nstatic const struct rtnl_link_ops *rtnl_link_ops_get(const char *kind)\n{\n\tconst struct rtnl_link_ops *ops;\n\n\tlist_for_each_entry(ops, &link_ops, list) {\n\t\tif (!strcmp(ops->kind, kind))\n\t\t\treturn ops;\n\t}\n\treturn NULL;\n}\n\n \nint __rtnl_link_register(struct rtnl_link_ops *ops)\n{\n\tif (rtnl_link_ops_get(ops->kind))\n\t\treturn -EEXIST;\n\n\t \n\tif ((ops->alloc || ops->setup) && !ops->dellink)\n\t\tops->dellink = unregister_netdevice_queue;\n\n\tlist_add_tail(&ops->list, &link_ops);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__rtnl_link_register);\n\n \nint rtnl_link_register(struct rtnl_link_ops *ops)\n{\n\tint err;\n\n\t \n\tif (WARN_ON(ops->maxtype > RTNL_MAX_TYPE ||\n\t\t    ops->slave_maxtype > RTNL_SLAVE_MAX_TYPE))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\terr = __rtnl_link_register(ops);\n\trtnl_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtnl_link_register);\n\nstatic void __rtnl_kill_links(struct net *net, struct rtnl_link_ops *ops)\n{\n\tstruct net_device *dev;\n\tLIST_HEAD(list_kill);\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->rtnl_link_ops == ops)\n\t\t\tops->dellink(dev, &list_kill);\n\t}\n\tunregister_netdevice_many(&list_kill);\n}\n\n \nvoid __rtnl_link_unregister(struct rtnl_link_ops *ops)\n{\n\tstruct net *net;\n\n\tfor_each_net(net) {\n\t\t__rtnl_kill_links(net, ops);\n\t}\n\tlist_del(&ops->list);\n}\nEXPORT_SYMBOL_GPL(__rtnl_link_unregister);\n\n \nstatic void rtnl_lock_unregistering_all(void)\n{\n\tstruct net *net;\n\tbool unregistering;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tadd_wait_queue(&netdev_unregistering_wq, &wait);\n\tfor (;;) {\n\t\tunregistering = false;\n\t\trtnl_lock();\n\t\t \n\t\tfor_each_net(net) {\n\t\t\tif (atomic_read(&net->dev_unreg_count) > 0) {\n\t\t\t\tunregistering = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!unregistering)\n\t\t\tbreak;\n\t\t__rtnl_unlock();\n\n\t\twait_woken(&wait, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&netdev_unregistering_wq, &wait);\n}\n\n \nvoid rtnl_link_unregister(struct rtnl_link_ops *ops)\n{\n\t \n\tdown_write(&pernet_ops_rwsem);\n\trtnl_lock_unregistering_all();\n\t__rtnl_link_unregister(ops);\n\trtnl_unlock();\n\tup_write(&pernet_ops_rwsem);\n}\nEXPORT_SYMBOL_GPL(rtnl_link_unregister);\n\nstatic size_t rtnl_link_get_slave_info_data_size(const struct net_device *dev)\n{\n\tstruct net_device *master_dev;\n\tconst struct rtnl_link_ops *ops;\n\tsize_t size = 0;\n\n\trcu_read_lock();\n\n\tmaster_dev = netdev_master_upper_dev_get_rcu((struct net_device *)dev);\n\tif (!master_dev)\n\t\tgoto out;\n\n\tops = master_dev->rtnl_link_ops;\n\tif (!ops || !ops->get_slave_size)\n\t\tgoto out;\n\t \n\tsize = nla_total_size(sizeof(struct nlattr)) +\n\t       ops->get_slave_size(master_dev, dev);\n\nout:\n\trcu_read_unlock();\n\treturn size;\n}\n\nstatic size_t rtnl_link_get_size(const struct net_device *dev)\n{\n\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\tsize_t size;\n\n\tif (!ops)\n\t\treturn 0;\n\n\tsize = nla_total_size(sizeof(struct nlattr)) +  \n\t       nla_total_size(strlen(ops->kind) + 1);   \n\n\tif (ops->get_size)\n\t\t \n\t\tsize += nla_total_size(sizeof(struct nlattr)) +\n\t\t\tops->get_size(dev);\n\n\tif (ops->get_xstats_size)\n\t\t \n\t\tsize += nla_total_size(ops->get_xstats_size(dev));\n\n\tsize += rtnl_link_get_slave_info_data_size(dev);\n\n\treturn size;\n}\n\nstatic LIST_HEAD(rtnl_af_ops);\n\nstatic const struct rtnl_af_ops *rtnl_af_lookup(const int family)\n{\n\tconst struct rtnl_af_ops *ops;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(ops, &rtnl_af_ops, list) {\n\t\tif (ops->family == family)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}\n\n \nvoid rtnl_af_register(struct rtnl_af_ops *ops)\n{\n\trtnl_lock();\n\tlist_add_tail_rcu(&ops->list, &rtnl_af_ops);\n\trtnl_unlock();\n}\nEXPORT_SYMBOL_GPL(rtnl_af_register);\n\n \nvoid rtnl_af_unregister(struct rtnl_af_ops *ops)\n{\n\trtnl_lock();\n\tlist_del_rcu(&ops->list);\n\trtnl_unlock();\n\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL_GPL(rtnl_af_unregister);\n\nstatic size_t rtnl_link_get_af_size(const struct net_device *dev,\n\t\t\t\t    u32 ext_filter_mask)\n{\n\tstruct rtnl_af_ops *af_ops;\n\tsize_t size;\n\n\t \n\tsize = nla_total_size(sizeof(struct nlattr));\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(af_ops, &rtnl_af_ops, list) {\n\t\tif (af_ops->get_link_af_size) {\n\t\t\t \n\t\t\tsize += nla_total_size(sizeof(struct nlattr)) +\n\t\t\t\taf_ops->get_link_af_size(dev, ext_filter_mask);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn size;\n}\n\nstatic bool rtnl_have_link_slave_info(const struct net_device *dev)\n{\n\tstruct net_device *master_dev;\n\tbool ret = false;\n\n\trcu_read_lock();\n\n\tmaster_dev = netdev_master_upper_dev_get_rcu((struct net_device *)dev);\n\tif (master_dev && master_dev->rtnl_link_ops)\n\t\tret = true;\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int rtnl_link_slave_info_fill(struct sk_buff *skb,\n\t\t\t\t     const struct net_device *dev)\n{\n\tstruct net_device *master_dev;\n\tconst struct rtnl_link_ops *ops;\n\tstruct nlattr *slave_data;\n\tint err;\n\n\tmaster_dev = netdev_master_upper_dev_get((struct net_device *) dev);\n\tif (!master_dev)\n\t\treturn 0;\n\tops = master_dev->rtnl_link_ops;\n\tif (!ops)\n\t\treturn 0;\n\tif (nla_put_string(skb, IFLA_INFO_SLAVE_KIND, ops->kind) < 0)\n\t\treturn -EMSGSIZE;\n\tif (ops->fill_slave_info) {\n\t\tslave_data = nla_nest_start_noflag(skb, IFLA_INFO_SLAVE_DATA);\n\t\tif (!slave_data)\n\t\t\treturn -EMSGSIZE;\n\t\terr = ops->fill_slave_info(skb, master_dev, dev);\n\t\tif (err < 0)\n\t\t\tgoto err_cancel_slave_data;\n\t\tnla_nest_end(skb, slave_data);\n\t}\n\treturn 0;\n\nerr_cancel_slave_data:\n\tnla_nest_cancel(skb, slave_data);\n\treturn err;\n}\n\nstatic int rtnl_link_info_fill(struct sk_buff *skb,\n\t\t\t       const struct net_device *dev)\n{\n\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\tstruct nlattr *data;\n\tint err;\n\n\tif (!ops)\n\t\treturn 0;\n\tif (nla_put_string(skb, IFLA_INFO_KIND, ops->kind) < 0)\n\t\treturn -EMSGSIZE;\n\tif (ops->fill_xstats) {\n\t\terr = ops->fill_xstats(skb, dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (ops->fill_info) {\n\t\tdata = nla_nest_start_noflag(skb, IFLA_INFO_DATA);\n\t\tif (data == NULL)\n\t\t\treturn -EMSGSIZE;\n\t\terr = ops->fill_info(skb, dev);\n\t\tif (err < 0)\n\t\t\tgoto err_cancel_data;\n\t\tnla_nest_end(skb, data);\n\t}\n\treturn 0;\n\nerr_cancel_data:\n\tnla_nest_cancel(skb, data);\n\treturn err;\n}\n\nstatic int rtnl_link_fill(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct nlattr *linkinfo;\n\tint err = -EMSGSIZE;\n\n\tlinkinfo = nla_nest_start_noflag(skb, IFLA_LINKINFO);\n\tif (linkinfo == NULL)\n\t\tgoto out;\n\n\terr = rtnl_link_info_fill(skb, dev);\n\tif (err < 0)\n\t\tgoto err_cancel_link;\n\n\terr = rtnl_link_slave_info_fill(skb, dev);\n\tif (err < 0)\n\t\tgoto err_cancel_link;\n\n\tnla_nest_end(skb, linkinfo);\n\treturn 0;\n\nerr_cancel_link:\n\tnla_nest_cancel(skb, linkinfo);\nout:\n\treturn err;\n}\n\nint rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, unsigned int group, int echo)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\treturn nlmsg_notify(rtnl, skb, pid, group, echo, GFP_KERNEL);\n}\n\nint rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\treturn nlmsg_unicast(rtnl, skb, pid);\n}\nEXPORT_SYMBOL(rtnl_unicast);\n\nvoid rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid, u32 group,\n\t\t const struct nlmsghdr *nlh, gfp_t flags)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\tnlmsg_notify(rtnl, skb, pid, group, nlmsg_report(nlh), flags);\n}\nEXPORT_SYMBOL(rtnl_notify);\n\nvoid rtnl_set_sk_err(struct net *net, u32 group, int error)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\tnetlink_set_err(rtnl, 0, group, error);\n}\nEXPORT_SYMBOL(rtnl_set_sk_err);\n\nint rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics)\n{\n\tstruct nlattr *mx;\n\tint i, valid = 0;\n\n\t \n\tif (metrics == dst_default_metrics.metrics)\n\t\treturn 0;\n\n\tmx = nla_nest_start_noflag(skb, RTA_METRICS);\n\tif (mx == NULL)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < RTAX_MAX; i++) {\n\t\tif (metrics[i]) {\n\t\t\tif (i == RTAX_CC_ALGO - 1) {\n\t\t\t\tchar tmp[TCP_CA_NAME_MAX], *name;\n\n\t\t\t\tname = tcp_ca_get_name_by_key(metrics[i], tmp);\n\t\t\t\tif (!name)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (nla_put_string(skb, i + 1, name))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t} else if (i == RTAX_FEATURES - 1) {\n\t\t\t\tu32 user_features = metrics[i] & RTAX_FEATURE_MASK;\n\n\t\t\t\tif (!user_features)\n\t\t\t\t\tcontinue;\n\t\t\t\tBUILD_BUG_ON(RTAX_FEATURE_MASK & DST_FEATURE_MASK);\n\t\t\t\tif (nla_put_u32(skb, i + 1, user_features))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t} else {\n\t\t\t\tif (nla_put_u32(skb, i + 1, metrics[i]))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tvalid++;\n\t\t}\n\t}\n\n\tif (!valid) {\n\t\tnla_nest_cancel(skb, mx);\n\t\treturn 0;\n\t}\n\n\treturn nla_nest_end(skb, mx);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, mx);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL(rtnetlink_put_metrics);\n\nint rtnl_put_cacheinfo(struct sk_buff *skb, struct dst_entry *dst, u32 id,\n\t\t       long expires, u32 error)\n{\n\tstruct rta_cacheinfo ci = {\n\t\t.rta_error = error,\n\t\t.rta_id =  id,\n\t};\n\n\tif (dst) {\n\t\tci.rta_lastuse = jiffies_delta_to_clock_t(jiffies - dst->lastuse);\n\t\tci.rta_used = dst->__use;\n\t\tci.rta_clntref = rcuref_read(&dst->__rcuref);\n\t}\n\tif (expires) {\n\t\tunsigned long clock;\n\n\t\tclock = jiffies_to_clock_t(abs(expires));\n\t\tclock = min_t(unsigned long, clock, INT_MAX);\n\t\tci.rta_expires = (expires > 0) ? clock : -clock;\n\t}\n\treturn nla_put(skb, RTA_CACHEINFO, sizeof(ci), &ci);\n}\nEXPORT_SYMBOL_GPL(rtnl_put_cacheinfo);\n\nstatic void set_operstate(struct net_device *dev, unsigned char transition)\n{\n\tunsigned char operstate = dev->operstate;\n\n\tswitch (transition) {\n\tcase IF_OPER_UP:\n\t\tif ((operstate == IF_OPER_DORMANT ||\n\t\t     operstate == IF_OPER_TESTING ||\n\t\t     operstate == IF_OPER_UNKNOWN) &&\n\t\t    !netif_dormant(dev) && !netif_testing(dev))\n\t\t\toperstate = IF_OPER_UP;\n\t\tbreak;\n\n\tcase IF_OPER_TESTING:\n\t\tif (netif_oper_up(dev))\n\t\t\toperstate = IF_OPER_TESTING;\n\t\tbreak;\n\n\tcase IF_OPER_DORMANT:\n\t\tif (netif_oper_up(dev))\n\t\t\toperstate = IF_OPER_DORMANT;\n\t\tbreak;\n\t}\n\n\tif (dev->operstate != operstate) {\n\t\twrite_lock(&dev_base_lock);\n\t\tdev->operstate = operstate;\n\t\twrite_unlock(&dev_base_lock);\n\t\tnetdev_state_change(dev);\n\t}\n}\n\nstatic unsigned int rtnl_dev_get_flags(const struct net_device *dev)\n{\n\treturn (dev->flags & ~(IFF_PROMISC | IFF_ALLMULTI)) |\n\t       (dev->gflags & (IFF_PROMISC | IFF_ALLMULTI));\n}\n\nstatic unsigned int rtnl_dev_combine_flags(const struct net_device *dev,\n\t\t\t\t\t   const struct ifinfomsg *ifm)\n{\n\tunsigned int flags = ifm->ifi_flags;\n\n\t \n\tif (ifm->ifi_change)\n\t\tflags = (flags & ifm->ifi_change) |\n\t\t\t(rtnl_dev_get_flags(dev) & ~ifm->ifi_change);\n\n\treturn flags;\n}\n\nstatic void copy_rtnl_link_stats(struct rtnl_link_stats *a,\n\t\t\t\t const struct rtnl_link_stats64 *b)\n{\n\ta->rx_packets = b->rx_packets;\n\ta->tx_packets = b->tx_packets;\n\ta->rx_bytes = b->rx_bytes;\n\ta->tx_bytes = b->tx_bytes;\n\ta->rx_errors = b->rx_errors;\n\ta->tx_errors = b->tx_errors;\n\ta->rx_dropped = b->rx_dropped;\n\ta->tx_dropped = b->tx_dropped;\n\n\ta->multicast = b->multicast;\n\ta->collisions = b->collisions;\n\n\ta->rx_length_errors = b->rx_length_errors;\n\ta->rx_over_errors = b->rx_over_errors;\n\ta->rx_crc_errors = b->rx_crc_errors;\n\ta->rx_frame_errors = b->rx_frame_errors;\n\ta->rx_fifo_errors = b->rx_fifo_errors;\n\ta->rx_missed_errors = b->rx_missed_errors;\n\n\ta->tx_aborted_errors = b->tx_aborted_errors;\n\ta->tx_carrier_errors = b->tx_carrier_errors;\n\ta->tx_fifo_errors = b->tx_fifo_errors;\n\ta->tx_heartbeat_errors = b->tx_heartbeat_errors;\n\ta->tx_window_errors = b->tx_window_errors;\n\n\ta->rx_compressed = b->rx_compressed;\n\ta->tx_compressed = b->tx_compressed;\n\n\ta->rx_nohandler = b->rx_nohandler;\n}\n\n \nstatic inline int rtnl_vfinfo_size(const struct net_device *dev,\n\t\t\t\t   u32 ext_filter_mask)\n{\n\tif (dev->dev.parent && (ext_filter_mask & RTEXT_FILTER_VF)) {\n\t\tint num_vfs = dev_num_vf(dev->dev.parent);\n\t\tsize_t size = nla_total_size(0);\n\t\tsize += num_vfs *\n\t\t\t(nla_total_size(0) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_mac)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_broadcast)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_vlan)) +\n\t\t\t nla_total_size(0) +  \n\t\t\t nla_total_size(MAX_VLAN_LIST_LEN *\n\t\t\t\t\tsizeof(struct ifla_vf_vlan_info)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_spoofchk)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_tx_rate)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_rate)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_link_state)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_rss_query_en)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_trust)));\n\t\tif (~ext_filter_mask & RTEXT_FILTER_SKIP_STATS) {\n\t\t\tsize += num_vfs *\n\t\t\t\t(nla_total_size(0) +  \n\t\t\t\t  \n\t\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t\t  \n\t\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t\t  \n\t\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t\t  \n\t\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t\t  \n\t\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t\t  \n\t\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t\t  \n\t\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t\t  \n\t\t\t\t nla_total_size_64bit(sizeof(__u64)));\n\t\t}\n\t\treturn size;\n\t} else\n\t\treturn 0;\n}\n\nstatic size_t rtnl_port_size(const struct net_device *dev,\n\t\t\t     u32 ext_filter_mask)\n{\n\tsize_t port_size = nla_total_size(4)\t\t \n\t\t+ nla_total_size(PORT_PROFILE_MAX)\t \n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t \n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t \n\t\t+ nla_total_size(1)\t\t\t \n\t\t+ nla_total_size(2);\t\t\t \n\tsize_t vf_ports_size = nla_total_size(sizeof(struct nlattr));\n\tsize_t vf_port_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\tsize_t port_self_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent ||\n\t    !(ext_filter_mask & RTEXT_FILTER_VF))\n\t\treturn 0;\n\tif (dev_num_vf(dev->dev.parent))\n\t\treturn port_self_size + vf_ports_size +\n\t\t\tvf_port_size * dev_num_vf(dev->dev.parent);\n\telse\n\t\treturn port_self_size;\n}\n\nstatic size_t rtnl_xdp_size(void)\n{\n\tsize_t xdp_size = nla_total_size(0) +\t \n\t\t\t  nla_total_size(1) +\t \n\t\t\t  nla_total_size(4) +\t \n\t\t\t  nla_total_size(4);\t \n\n\treturn xdp_size;\n}\n\nstatic size_t rtnl_prop_list_size(const struct net_device *dev)\n{\n\tstruct netdev_name_node *name_node;\n\tsize_t size;\n\n\tif (list_empty(&dev->name_node->list))\n\t\treturn 0;\n\tsize = nla_total_size(0);\n\tlist_for_each_entry(name_node, &dev->name_node->list, list)\n\t\tsize += nla_total_size(ALTIFNAMSIZ);\n\treturn size;\n}\n\nstatic size_t rtnl_proto_down_size(const struct net_device *dev)\n{\n\tsize_t size = nla_total_size(1);\n\n\tif (dev->proto_down_reason)\n\t\tsize += nla_total_size(0) + nla_total_size(4);\n\n\treturn size;\n}\n\nstatic size_t rtnl_devlink_port_size(const struct net_device *dev)\n{\n\tsize_t size = nla_total_size(0);  \n\n\tif (dev->devlink_port)\n\t\tsize += devlink_nl_port_handle_size(dev->devlink_port);\n\n\treturn size;\n}\n\nstatic noinline size_t if_nlmsg_size(const struct net_device *dev,\n\t\t\t\t     u32 ext_filter_mask)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t       + nla_total_size(IFNAMSIZ)  \n\t       + nla_total_size(IFALIASZ)  \n\t       + nla_total_size(IFNAMSIZ)  \n\t       + nla_total_size_64bit(sizeof(struct rtnl_link_ifmap))\n\t       + nla_total_size(sizeof(struct rtnl_link_stats))\n\t       + nla_total_size_64bit(sizeof(struct rtnl_link_stats64))\n\t       + nla_total_size(MAX_ADDR_LEN)  \n\t       + nla_total_size(MAX_ADDR_LEN)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(1)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(1)  \n\t       + nla_total_size(1)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(ext_filter_mask\n\t\t\t        & RTEXT_FILTER_VF ? 4 : 0)  \n\t       + rtnl_vfinfo_size(dev, ext_filter_mask)  \n\t       + rtnl_port_size(dev, ext_filter_mask)  \n\t       + rtnl_link_get_size(dev)  \n\t       + rtnl_link_get_af_size(dev, ext_filter_mask)  \n\t       + nla_total_size(MAX_PHYS_ITEM_ID_LEN)  \n\t       + nla_total_size(MAX_PHYS_ITEM_ID_LEN)  \n\t       + nla_total_size(IFNAMSIZ)  \n\t       + rtnl_xdp_size()  \n\t       + nla_total_size(4)   \n\t       + nla_total_size(4)   \n\t       + nla_total_size(4)   \n\t       + rtnl_proto_down_size(dev)   \n\t       + nla_total_size(4)   \n\t       + nla_total_size(4)   \n\t       + nla_total_size(4)   \n\t       + nla_total_size(4)   \n\t       + nla_total_size(4)   \n\t       + rtnl_prop_list_size(dev)\n\t       + nla_total_size(MAX_ADDR_LEN)  \n\t       + rtnl_devlink_port_size(dev)\n\t       + 0;\n}\n\nstatic int rtnl_vf_ports_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nlattr *vf_ports;\n\tstruct nlattr *vf_port;\n\tint vf;\n\tint err;\n\n\tvf_ports = nla_nest_start_noflag(skb, IFLA_VF_PORTS);\n\tif (!vf_ports)\n\t\treturn -EMSGSIZE;\n\n\tfor (vf = 0; vf < dev_num_vf(dev->dev.parent); vf++) {\n\t\tvf_port = nla_nest_start_noflag(skb, IFLA_VF_PORT);\n\t\tif (!vf_port)\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_PORT_VF, vf))\n\t\t\tgoto nla_put_failure;\n\t\terr = dev->netdev_ops->ndo_get_vf_port(dev, vf, skb);\n\t\tif (err == -EMSGSIZE)\n\t\t\tgoto nla_put_failure;\n\t\tif (err) {\n\t\t\tnla_nest_cancel(skb, vf_port);\n\t\t\tcontinue;\n\t\t}\n\t\tnla_nest_end(skb, vf_port);\n\t}\n\n\tnla_nest_end(skb, vf_ports);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, vf_ports);\n\treturn -EMSGSIZE;\n}\n\nstatic int rtnl_port_self_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nlattr *port_self;\n\tint err;\n\n\tport_self = nla_nest_start_noflag(skb, IFLA_PORT_SELF);\n\tif (!port_self)\n\t\treturn -EMSGSIZE;\n\n\terr = dev->netdev_ops->ndo_get_vf_port(dev, PORT_SELF_VF, skb);\n\tif (err) {\n\t\tnla_nest_cancel(skb, port_self);\n\t\treturn (err == -EMSGSIZE) ? err : 0;\n\t}\n\n\tnla_nest_end(skb, port_self);\n\n\treturn 0;\n}\n\nstatic int rtnl_port_fill(struct sk_buff *skb, struct net_device *dev,\n\t\t\t  u32 ext_filter_mask)\n{\n\tint err;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent ||\n\t    !(ext_filter_mask & RTEXT_FILTER_VF))\n\t\treturn 0;\n\n\terr = rtnl_port_self_fill(skb, dev);\n\tif (err)\n\t\treturn err;\n\n\tif (dev_num_vf(dev->dev.parent)) {\n\t\terr = rtnl_vf_ports_fill(skb, dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_phys_port_id_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tint err;\n\tstruct netdev_phys_item_id ppid;\n\n\terr = dev_get_phys_port_id(dev, &ppid);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tif (nla_put(skb, IFLA_PHYS_PORT_ID, ppid.id_len, ppid.id))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int rtnl_phys_port_name_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tchar name[IFNAMSIZ];\n\tint err;\n\n\terr = dev_get_phys_port_name(dev, name, sizeof(name));\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tif (nla_put_string(skb, IFLA_PHYS_PORT_NAME, name))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int rtnl_phys_switch_id_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdev_phys_item_id ppid = { };\n\tint err;\n\n\terr = dev_get_port_parent_id(dev, &ppid, false);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tif (nla_put(skb, IFLA_PHYS_SWITCH_ID, ppid.id_len, ppid.id))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int rtnl_fill_stats(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *dev)\n{\n\tstruct rtnl_link_stats64 *sp;\n\tstruct nlattr *attr;\n\n\tattr = nla_reserve_64bit(skb, IFLA_STATS64,\n\t\t\t\t sizeof(struct rtnl_link_stats64), IFLA_PAD);\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tsp = nla_data(attr);\n\tdev_get_stats(dev, sp);\n\n\tattr = nla_reserve(skb, IFLA_STATS,\n\t\t\t   sizeof(struct rtnl_link_stats));\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tcopy_rtnl_link_stats(nla_data(attr), sp);\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,\n\t\t\t\t\t       struct net_device *dev,\n\t\t\t\t\t       int vfs_num,\n\t\t\t\t\t       u32 ext_filter_mask)\n{\n\tstruct ifla_vf_rss_query_en vf_rss_query_en;\n\tstruct nlattr *vf, *vfstats, *vfvlanlist;\n\tstruct ifla_vf_link_state vf_linkstate;\n\tstruct ifla_vf_vlan_info vf_vlan_info;\n\tstruct ifla_vf_spoofchk vf_spoofchk;\n\tstruct ifla_vf_tx_rate vf_tx_rate;\n\tstruct ifla_vf_stats vf_stats;\n\tstruct ifla_vf_trust vf_trust;\n\tstruct ifla_vf_vlan vf_vlan;\n\tstruct ifla_vf_rate vf_rate;\n\tstruct ifla_vf_mac vf_mac;\n\tstruct ifla_vf_broadcast vf_broadcast;\n\tstruct ifla_vf_info ivi;\n\tstruct ifla_vf_guid node_guid;\n\tstruct ifla_vf_guid port_guid;\n\n\tmemset(&ivi, 0, sizeof(ivi));\n\n\t \n\tivi.spoofchk = -1;\n\tivi.rss_query_en = -1;\n\tivi.trusted = -1;\n\t \n\tivi.linkstate = 0;\n\t \n\tivi.vlan_proto = htons(ETH_P_8021Q);\n\tif (dev->netdev_ops->ndo_get_vf_config(dev, vfs_num, &ivi))\n\t\treturn 0;\n\n\tmemset(&vf_vlan_info, 0, sizeof(vf_vlan_info));\n\tmemset(&node_guid, 0, sizeof(node_guid));\n\tmemset(&port_guid, 0, sizeof(port_guid));\n\n\tvf_mac.vf =\n\t\tvf_vlan.vf =\n\t\tvf_vlan_info.vf =\n\t\tvf_rate.vf =\n\t\tvf_tx_rate.vf =\n\t\tvf_spoofchk.vf =\n\t\tvf_linkstate.vf =\n\t\tvf_rss_query_en.vf =\n\t\tvf_trust.vf =\n\t\tnode_guid.vf =\n\t\tport_guid.vf = ivi.vf;\n\n\tmemcpy(vf_mac.mac, ivi.mac, sizeof(ivi.mac));\n\tmemcpy(vf_broadcast.broadcast, dev->broadcast, dev->addr_len);\n\tvf_vlan.vlan = ivi.vlan;\n\tvf_vlan.qos = ivi.qos;\n\tvf_vlan_info.vlan = ivi.vlan;\n\tvf_vlan_info.qos = ivi.qos;\n\tvf_vlan_info.vlan_proto = ivi.vlan_proto;\n\tvf_tx_rate.rate = ivi.max_tx_rate;\n\tvf_rate.min_tx_rate = ivi.min_tx_rate;\n\tvf_rate.max_tx_rate = ivi.max_tx_rate;\n\tvf_spoofchk.setting = ivi.spoofchk;\n\tvf_linkstate.link_state = ivi.linkstate;\n\tvf_rss_query_en.setting = ivi.rss_query_en;\n\tvf_trust.setting = ivi.trusted;\n\tvf = nla_nest_start_noflag(skb, IFLA_VF_INFO);\n\tif (!vf)\n\t\treturn -EMSGSIZE;\n\tif (nla_put(skb, IFLA_VF_MAC, sizeof(vf_mac), &vf_mac) ||\n\t    nla_put(skb, IFLA_VF_BROADCAST, sizeof(vf_broadcast), &vf_broadcast) ||\n\t    nla_put(skb, IFLA_VF_VLAN, sizeof(vf_vlan), &vf_vlan) ||\n\t    nla_put(skb, IFLA_VF_RATE, sizeof(vf_rate),\n\t\t    &vf_rate) ||\n\t    nla_put(skb, IFLA_VF_TX_RATE, sizeof(vf_tx_rate),\n\t\t    &vf_tx_rate) ||\n\t    nla_put(skb, IFLA_VF_SPOOFCHK, sizeof(vf_spoofchk),\n\t\t    &vf_spoofchk) ||\n\t    nla_put(skb, IFLA_VF_LINK_STATE, sizeof(vf_linkstate),\n\t\t    &vf_linkstate) ||\n\t    nla_put(skb, IFLA_VF_RSS_QUERY_EN,\n\t\t    sizeof(vf_rss_query_en),\n\t\t    &vf_rss_query_en) ||\n\t    nla_put(skb, IFLA_VF_TRUST,\n\t\t    sizeof(vf_trust), &vf_trust))\n\t\tgoto nla_put_vf_failure;\n\n\tif (dev->netdev_ops->ndo_get_vf_guid &&\n\t    !dev->netdev_ops->ndo_get_vf_guid(dev, vfs_num, &node_guid,\n\t\t\t\t\t      &port_guid)) {\n\t\tif (nla_put(skb, IFLA_VF_IB_NODE_GUID, sizeof(node_guid),\n\t\t\t    &node_guid) ||\n\t\t    nla_put(skb, IFLA_VF_IB_PORT_GUID, sizeof(port_guid),\n\t\t\t    &port_guid))\n\t\t\tgoto nla_put_vf_failure;\n\t}\n\tvfvlanlist = nla_nest_start_noflag(skb, IFLA_VF_VLAN_LIST);\n\tif (!vfvlanlist)\n\t\tgoto nla_put_vf_failure;\n\tif (nla_put(skb, IFLA_VF_VLAN_INFO, sizeof(vf_vlan_info),\n\t\t    &vf_vlan_info)) {\n\t\tnla_nest_cancel(skb, vfvlanlist);\n\t\tgoto nla_put_vf_failure;\n\t}\n\tnla_nest_end(skb, vfvlanlist);\n\tif (~ext_filter_mask & RTEXT_FILTER_SKIP_STATS) {\n\t\tmemset(&vf_stats, 0, sizeof(vf_stats));\n\t\tif (dev->netdev_ops->ndo_get_vf_stats)\n\t\t\tdev->netdev_ops->ndo_get_vf_stats(dev, vfs_num,\n\t\t\t\t\t\t\t  &vf_stats);\n\t\tvfstats = nla_nest_start_noflag(skb, IFLA_VF_STATS);\n\t\tif (!vfstats)\n\t\t\tgoto nla_put_vf_failure;\n\t\tif (nla_put_u64_64bit(skb, IFLA_VF_STATS_RX_PACKETS,\n\t\t\t\t      vf_stats.rx_packets, IFLA_VF_STATS_PAD) ||\n\t\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_TX_PACKETS,\n\t\t\t\t      vf_stats.tx_packets, IFLA_VF_STATS_PAD) ||\n\t\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_RX_BYTES,\n\t\t\t\t      vf_stats.rx_bytes, IFLA_VF_STATS_PAD) ||\n\t\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_TX_BYTES,\n\t\t\t\t      vf_stats.tx_bytes, IFLA_VF_STATS_PAD) ||\n\t\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_BROADCAST,\n\t\t\t\t      vf_stats.broadcast, IFLA_VF_STATS_PAD) ||\n\t\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_MULTICAST,\n\t\t\t\t      vf_stats.multicast, IFLA_VF_STATS_PAD) ||\n\t\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_RX_DROPPED,\n\t\t\t\t      vf_stats.rx_dropped, IFLA_VF_STATS_PAD) ||\n\t\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_TX_DROPPED,\n\t\t\t\t      vf_stats.tx_dropped, IFLA_VF_STATS_PAD)) {\n\t\t\tnla_nest_cancel(skb, vfstats);\n\t\t\tgoto nla_put_vf_failure;\n\t\t}\n\t\tnla_nest_end(skb, vfstats);\n\t}\n\tnla_nest_end(skb, vf);\n\treturn 0;\n\nnla_put_vf_failure:\n\tnla_nest_cancel(skb, vf);\n\treturn -EMSGSIZE;\n}\n\nstatic noinline_for_stack int rtnl_fill_vf(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   u32 ext_filter_mask)\n{\n\tstruct nlattr *vfinfo;\n\tint i, num_vfs;\n\n\tif (!dev->dev.parent || ((ext_filter_mask & RTEXT_FILTER_VF) == 0))\n\t\treturn 0;\n\n\tnum_vfs = dev_num_vf(dev->dev.parent);\n\tif (nla_put_u32(skb, IFLA_NUM_VF, num_vfs))\n\t\treturn -EMSGSIZE;\n\n\tif (!dev->netdev_ops->ndo_get_vf_config)\n\t\treturn 0;\n\n\tvfinfo = nla_nest_start_noflag(skb, IFLA_VFINFO_LIST);\n\tif (!vfinfo)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tif (rtnl_fill_vfinfo(skb, dev, i, ext_filter_mask)) {\n\t\t\tnla_nest_cancel(skb, vfinfo);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\tnla_nest_end(skb, vfinfo);\n\treturn 0;\n}\n\nstatic int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rtnl_link_ifmap map;\n\n\tmemset(&map, 0, sizeof(map));\n\tmap.mem_start   = dev->mem_start;\n\tmap.mem_end     = dev->mem_end;\n\tmap.base_addr   = dev->base_addr;\n\tmap.irq         = dev->irq;\n\tmap.dma         = dev->dma;\n\tmap.port        = dev->if_port;\n\n\tif (nla_put_64bit(skb, IFLA_MAP, sizeof(map), &map, IFLA_PAD))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic u32 rtnl_xdp_prog_skb(struct net_device *dev)\n{\n\tconst struct bpf_prog *generic_xdp_prog;\n\n\tASSERT_RTNL();\n\n\tgeneric_xdp_prog = rtnl_dereference(dev->xdp_prog);\n\tif (!generic_xdp_prog)\n\t\treturn 0;\n\treturn generic_xdp_prog->aux->id;\n}\n\nstatic u32 rtnl_xdp_prog_drv(struct net_device *dev)\n{\n\treturn dev_xdp_prog_id(dev, XDP_MODE_DRV);\n}\n\nstatic u32 rtnl_xdp_prog_hw(struct net_device *dev)\n{\n\treturn dev_xdp_prog_id(dev, XDP_MODE_HW);\n}\n\nstatic int rtnl_xdp_report_one(struct sk_buff *skb, struct net_device *dev,\n\t\t\t       u32 *prog_id, u8 *mode, u8 tgt_mode, u32 attr,\n\t\t\t       u32 (*get_prog_id)(struct net_device *dev))\n{\n\tu32 curr_id;\n\tint err;\n\n\tcurr_id = get_prog_id(dev);\n\tif (!curr_id)\n\t\treturn 0;\n\n\t*prog_id = curr_id;\n\terr = nla_put_u32(skb, attr, curr_id);\n\tif (err)\n\t\treturn err;\n\n\tif (*mode != XDP_ATTACHED_NONE)\n\t\t*mode = XDP_ATTACHED_MULTI;\n\telse\n\t\t*mode = tgt_mode;\n\n\treturn 0;\n}\n\nstatic int rtnl_xdp_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nlattr *xdp;\n\tu32 prog_id;\n\tint err;\n\tu8 mode;\n\n\txdp = nla_nest_start_noflag(skb, IFLA_XDP);\n\tif (!xdp)\n\t\treturn -EMSGSIZE;\n\n\tprog_id = 0;\n\tmode = XDP_ATTACHED_NONE;\n\terr = rtnl_xdp_report_one(skb, dev, &prog_id, &mode, XDP_ATTACHED_SKB,\n\t\t\t\t  IFLA_XDP_SKB_PROG_ID, rtnl_xdp_prog_skb);\n\tif (err)\n\t\tgoto err_cancel;\n\terr = rtnl_xdp_report_one(skb, dev, &prog_id, &mode, XDP_ATTACHED_DRV,\n\t\t\t\t  IFLA_XDP_DRV_PROG_ID, rtnl_xdp_prog_drv);\n\tif (err)\n\t\tgoto err_cancel;\n\terr = rtnl_xdp_report_one(skb, dev, &prog_id, &mode, XDP_ATTACHED_HW,\n\t\t\t\t  IFLA_XDP_HW_PROG_ID, rtnl_xdp_prog_hw);\n\tif (err)\n\t\tgoto err_cancel;\n\n\terr = nla_put_u8(skb, IFLA_XDP_ATTACHED, mode);\n\tif (err)\n\t\tgoto err_cancel;\n\n\tif (prog_id && mode != XDP_ATTACHED_MULTI) {\n\t\terr = nla_put_u32(skb, IFLA_XDP_PROG_ID, prog_id);\n\t\tif (err)\n\t\t\tgoto err_cancel;\n\t}\n\n\tnla_nest_end(skb, xdp);\n\treturn 0;\n\nerr_cancel:\n\tnla_nest_cancel(skb, xdp);\n\treturn err;\n}\n\nstatic u32 rtnl_get_event(unsigned long event)\n{\n\tu32 rtnl_event_type = IFLA_EVENT_NONE;\n\n\tswitch (event) {\n\tcase NETDEV_REBOOT:\n\t\trtnl_event_type = IFLA_EVENT_REBOOT;\n\t\tbreak;\n\tcase NETDEV_FEAT_CHANGE:\n\t\trtnl_event_type = IFLA_EVENT_FEATURES;\n\t\tbreak;\n\tcase NETDEV_BONDING_FAILOVER:\n\t\trtnl_event_type = IFLA_EVENT_BONDING_FAILOVER;\n\t\tbreak;\n\tcase NETDEV_NOTIFY_PEERS:\n\t\trtnl_event_type = IFLA_EVENT_NOTIFY_PEERS;\n\t\tbreak;\n\tcase NETDEV_RESEND_IGMP:\n\t\trtnl_event_type = IFLA_EVENT_IGMP_RESEND;\n\t\tbreak;\n\tcase NETDEV_CHANGEINFODATA:\n\t\trtnl_event_type = IFLA_EVENT_BONDING_OPTIONS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rtnl_event_type;\n}\n\nstatic int put_master_ifindex(struct sk_buff *skb, struct net_device *dev)\n{\n\tconst struct net_device *upper_dev;\n\tint ret = 0;\n\n\trcu_read_lock();\n\n\tupper_dev = netdev_master_upper_dev_get_rcu(dev);\n\tif (upper_dev)\n\t\tret = nla_put_u32(skb, IFLA_MASTER, upper_dev->ifindex);\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int nla_put_iflink(struct sk_buff *skb, const struct net_device *dev,\n\t\t\t  bool force)\n{\n\tint ifindex = dev_get_iflink(dev);\n\n\tif (force || dev->ifindex != ifindex)\n\t\treturn nla_put_u32(skb, IFLA_LINK, ifindex);\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int nla_put_ifalias(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *dev)\n{\n\tchar buf[IFALIASZ];\n\tint ret;\n\n\tret = dev_get_alias(dev, buf, sizeof(buf));\n\treturn ret > 0 ? nla_put_string(skb, IFLA_IFALIAS, buf) : 0;\n}\n\nstatic int rtnl_fill_link_netnsid(struct sk_buff *skb,\n\t\t\t\t  const struct net_device *dev,\n\t\t\t\t  struct net *src_net, gfp_t gfp)\n{\n\tbool put_iflink = false;\n\n\tif (dev->rtnl_link_ops && dev->rtnl_link_ops->get_link_net) {\n\t\tstruct net *link_net = dev->rtnl_link_ops->get_link_net(dev);\n\n\t\tif (!net_eq(dev_net(dev), link_net)) {\n\t\t\tint id = peernet2id_alloc(src_net, link_net, gfp);\n\n\t\t\tif (nla_put_s32(skb, IFLA_LINK_NETNSID, id))\n\t\t\t\treturn -EMSGSIZE;\n\n\t\t\tput_iflink = true;\n\t\t}\n\t}\n\n\treturn nla_put_iflink(skb, dev, put_iflink);\n}\n\nstatic int rtnl_fill_link_af(struct sk_buff *skb,\n\t\t\t     const struct net_device *dev,\n\t\t\t     u32 ext_filter_mask)\n{\n\tconst struct rtnl_af_ops *af_ops;\n\tstruct nlattr *af_spec;\n\n\taf_spec = nla_nest_start_noflag(skb, IFLA_AF_SPEC);\n\tif (!af_spec)\n\t\treturn -EMSGSIZE;\n\n\tlist_for_each_entry_rcu(af_ops, &rtnl_af_ops, list) {\n\t\tstruct nlattr *af;\n\t\tint err;\n\n\t\tif (!af_ops->fill_link_af)\n\t\t\tcontinue;\n\n\t\taf = nla_nest_start_noflag(skb, af_ops->family);\n\t\tif (!af)\n\t\t\treturn -EMSGSIZE;\n\n\t\terr = af_ops->fill_link_af(skb, dev, ext_filter_mask);\n\t\t \n\t\tif (err == -ENODATA)\n\t\t\tnla_nest_cancel(skb, af);\n\t\telse if (err < 0)\n\t\t\treturn -EMSGSIZE;\n\n\t\tnla_nest_end(skb, af);\n\t}\n\n\tnla_nest_end(skb, af_spec);\n\treturn 0;\n}\n\nstatic int rtnl_fill_alt_ifnames(struct sk_buff *skb,\n\t\t\t\t const struct net_device *dev)\n{\n\tstruct netdev_name_node *name_node;\n\tint count = 0;\n\n\tlist_for_each_entry(name_node, &dev->name_node->list, list) {\n\t\tif (nla_put_string(skb, IFLA_ALT_IFNAME, name_node->name))\n\t\t\treturn -EMSGSIZE;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nstatic int rtnl_fill_prop_list(struct sk_buff *skb,\n\t\t\t       const struct net_device *dev)\n{\n\tstruct nlattr *prop_list;\n\tint ret;\n\n\tprop_list = nla_nest_start(skb, IFLA_PROP_LIST);\n\tif (!prop_list)\n\t\treturn -EMSGSIZE;\n\n\tret = rtnl_fill_alt_ifnames(skb, dev);\n\tif (ret <= 0)\n\t\tgoto nest_cancel;\n\n\tnla_nest_end(skb, prop_list);\n\treturn 0;\n\nnest_cancel:\n\tnla_nest_cancel(skb, prop_list);\n\treturn ret;\n}\n\nstatic int rtnl_fill_proto_down(struct sk_buff *skb,\n\t\t\t\tconst struct net_device *dev)\n{\n\tstruct nlattr *pr;\n\tu32 preason;\n\n\tif (nla_put_u8(skb, IFLA_PROTO_DOWN, dev->proto_down))\n\t\tgoto nla_put_failure;\n\n\tpreason = dev->proto_down_reason;\n\tif (!preason)\n\t\treturn 0;\n\n\tpr = nla_nest_start(skb, IFLA_PROTO_DOWN_REASON);\n\tif (!pr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, IFLA_PROTO_DOWN_REASON_VALUE, preason)) {\n\t\tnla_nest_cancel(skb, pr);\n\t\tgoto nla_put_failure;\n\t}\n\n\tnla_nest_end(skb, pr);\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int rtnl_fill_devlink_port(struct sk_buff *skb,\n\t\t\t\t  const struct net_device *dev)\n{\n\tstruct nlattr *devlink_port_nest;\n\tint ret;\n\n\tdevlink_port_nest = nla_nest_start(skb, IFLA_DEVLINK_PORT);\n\tif (!devlink_port_nest)\n\t\treturn -EMSGSIZE;\n\n\tif (dev->devlink_port) {\n\t\tret = devlink_nl_port_handle_fill(skb, dev->devlink_port);\n\t\tif (ret < 0)\n\t\t\tgoto nest_cancel;\n\t}\n\n\tnla_nest_end(skb, devlink_port_nest);\n\treturn 0;\n\nnest_cancel:\n\tnla_nest_cancel(skb, devlink_port_nest);\n\treturn ret;\n}\n\nstatic int rtnl_fill_ifinfo(struct sk_buff *skb,\n\t\t\t    struct net_device *dev, struct net *src_net,\n\t\t\t    int type, u32 pid, u32 seq, u32 change,\n\t\t\t    unsigned int flags, u32 ext_filter_mask,\n\t\t\t    u32 event, int *new_nsid, int new_ifindex,\n\t\t\t    int tgt_netnsid, gfp_t gfp)\n{\n\tstruct ifinfomsg *ifm;\n\tstruct nlmsghdr *nlh;\n\tstruct Qdisc *qdisc;\n\n\tASSERT_RTNL();\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ifm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifi_family = AF_UNSPEC;\n\tifm->__ifi_pad = 0;\n\tifm->ifi_type = dev->type;\n\tifm->ifi_index = dev->ifindex;\n\tifm->ifi_flags = dev_get_flags(dev);\n\tifm->ifi_change = change;\n\n\tif (tgt_netnsid >= 0 && nla_put_s32(skb, IFLA_TARGET_NETNSID, tgt_netnsid))\n\t\tgoto nla_put_failure;\n\n\tqdisc = rtnl_dereference(dev->qdisc);\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    nla_put_u32(skb, IFLA_TXQLEN, dev->tx_queue_len) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE,\n\t\t       netif_running(dev) ? dev->operstate : IF_OPER_DOWN) ||\n\t    nla_put_u8(skb, IFLA_LINKMODE, dev->link_mode) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    nla_put_u32(skb, IFLA_MIN_MTU, dev->min_mtu) ||\n\t    nla_put_u32(skb, IFLA_MAX_MTU, dev->max_mtu) ||\n\t    nla_put_u32(skb, IFLA_GROUP, dev->group) ||\n\t    nla_put_u32(skb, IFLA_PROMISCUITY, dev->promiscuity) ||\n\t    nla_put_u32(skb, IFLA_ALLMULTI, dev->allmulti) ||\n\t    nla_put_u32(skb, IFLA_NUM_TX_QUEUES, dev->num_tx_queues) ||\n\t    nla_put_u32(skb, IFLA_GSO_MAX_SEGS, dev->gso_max_segs) ||\n\t    nla_put_u32(skb, IFLA_GSO_MAX_SIZE, dev->gso_max_size) ||\n\t    nla_put_u32(skb, IFLA_GRO_MAX_SIZE, dev->gro_max_size) ||\n\t    nla_put_u32(skb, IFLA_GSO_IPV4_MAX_SIZE, dev->gso_ipv4_max_size) ||\n\t    nla_put_u32(skb, IFLA_GRO_IPV4_MAX_SIZE, dev->gro_ipv4_max_size) ||\n\t    nla_put_u32(skb, IFLA_TSO_MAX_SIZE, dev->tso_max_size) ||\n\t    nla_put_u32(skb, IFLA_TSO_MAX_SEGS, dev->tso_max_segs) ||\n#ifdef CONFIG_RPS\n\t    nla_put_u32(skb, IFLA_NUM_RX_QUEUES, dev->num_rx_queues) ||\n#endif\n\t    put_master_ifindex(skb, dev) ||\n\t    nla_put_u8(skb, IFLA_CARRIER, netif_carrier_ok(dev)) ||\n\t    (qdisc &&\n\t     nla_put_string(skb, IFLA_QDISC, qdisc->ops->id)) ||\n\t    nla_put_ifalias(skb, dev) ||\n\t    nla_put_u32(skb, IFLA_CARRIER_CHANGES,\n\t\t\tatomic_read(&dev->carrier_up_count) +\n\t\t\tatomic_read(&dev->carrier_down_count)) ||\n\t    nla_put_u32(skb, IFLA_CARRIER_UP_COUNT,\n\t\t\tatomic_read(&dev->carrier_up_count)) ||\n\t    nla_put_u32(skb, IFLA_CARRIER_DOWN_COUNT,\n\t\t\tatomic_read(&dev->carrier_down_count)))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_fill_proto_down(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (event != IFLA_EVENT_NONE) {\n\t\tif (nla_put_u32(skb, IFLA_EVENT, event))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rtnl_fill_link_ifmap(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (dev->addr_len) {\n\t\tif (nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr) ||\n\t\t    nla_put(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rtnl_phys_port_id_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_phys_port_name_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_phys_switch_id_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_fill_stats(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_fill_vf(skb, dev, ext_filter_mask))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_port_fill(skb, dev, ext_filter_mask))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_xdp_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (dev->rtnl_link_ops || rtnl_have_link_slave_info(dev)) {\n\t\tif (rtnl_link_fill(skb, dev) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rtnl_fill_link_netnsid(skb, dev, src_net, gfp))\n\t\tgoto nla_put_failure;\n\n\tif (new_nsid &&\n\t    nla_put_s32(skb, IFLA_NEW_NETNSID, *new_nsid) < 0)\n\t\tgoto nla_put_failure;\n\tif (new_ifindex &&\n\t    nla_put_s32(skb, IFLA_NEW_IFINDEX, new_ifindex) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (memchr_inv(dev->perm_addr, '\\0', dev->addr_len) &&\n\t    nla_put(skb, IFLA_PERM_ADDRESS, dev->addr_len, dev->perm_addr))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\tif (rtnl_fill_link_af(skb, dev, ext_filter_mask))\n\t\tgoto nla_put_failure_rcu;\n\trcu_read_unlock();\n\n\tif (rtnl_fill_prop_list(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (dev->dev.parent &&\n\t    nla_put_string(skb, IFLA_PARENT_DEV_NAME,\n\t\t\t   dev_name(dev->dev.parent)))\n\t\tgoto nla_put_failure;\n\n\tif (dev->dev.parent && dev->dev.parent->bus &&\n\t    nla_put_string(skb, IFLA_PARENT_DEV_BUS_NAME,\n\t\t\t   dev->dev.parent->bus->name))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_fill_devlink_port(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure_rcu:\n\trcu_read_unlock();\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy ifla_policy[IFLA_MAX+1] = {\n\t[IFLA_IFNAME]\t\t= { .type = NLA_STRING, .len = IFNAMSIZ-1 },\n\t[IFLA_ADDRESS]\t\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[IFLA_BROADCAST]\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[IFLA_MAP]\t\t= { .len = sizeof(struct rtnl_link_ifmap) },\n\t[IFLA_MTU]\t\t= { .type = NLA_U32 },\n\t[IFLA_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_MASTER]\t\t= { .type = NLA_U32 },\n\t[IFLA_CARRIER]\t\t= { .type = NLA_U8 },\n\t[IFLA_TXQLEN]\t\t= { .type = NLA_U32 },\n\t[IFLA_WEIGHT]\t\t= { .type = NLA_U32 },\n\t[IFLA_OPERSTATE]\t= { .type = NLA_U8 },\n\t[IFLA_LINKMODE]\t\t= { .type = NLA_U8 },\n\t[IFLA_LINKINFO]\t\t= { .type = NLA_NESTED },\n\t[IFLA_NET_NS_PID]\t= { .type = NLA_U32 },\n\t[IFLA_NET_NS_FD]\t= { .type = NLA_U32 },\n\t \n\t[IFLA_IFALIAS]\t        = { .type = NLA_BINARY, .len = IFALIASZ - 1 },\n\t[IFLA_VFINFO_LIST]\t= {. type = NLA_NESTED },\n\t[IFLA_VF_PORTS]\t\t= { .type = NLA_NESTED },\n\t[IFLA_PORT_SELF]\t= { .type = NLA_NESTED },\n\t[IFLA_AF_SPEC]\t\t= { .type = NLA_NESTED },\n\t[IFLA_EXT_MASK]\t\t= { .type = NLA_U32 },\n\t[IFLA_PROMISCUITY]\t= { .type = NLA_U32 },\n\t[IFLA_NUM_TX_QUEUES]\t= { .type = NLA_U32 },\n\t[IFLA_NUM_RX_QUEUES]\t= { .type = NLA_U32 },\n\t[IFLA_GSO_MAX_SEGS]\t= { .type = NLA_U32 },\n\t[IFLA_GSO_MAX_SIZE]\t= { .type = NLA_U32 },\n\t[IFLA_PHYS_PORT_ID]\t= { .type = NLA_BINARY, .len = MAX_PHYS_ITEM_ID_LEN },\n\t[IFLA_CARRIER_CHANGES]\t= { .type = NLA_U32 },   \n\t[IFLA_PHYS_SWITCH_ID]\t= { .type = NLA_BINARY, .len = MAX_PHYS_ITEM_ID_LEN },\n\t[IFLA_LINK_NETNSID]\t= { .type = NLA_S32 },\n\t[IFLA_PROTO_DOWN]\t= { .type = NLA_U8 },\n\t[IFLA_XDP]\t\t= { .type = NLA_NESTED },\n\t[IFLA_EVENT]\t\t= { .type = NLA_U32 },\n\t[IFLA_GROUP]\t\t= { .type = NLA_U32 },\n\t[IFLA_TARGET_NETNSID]\t= { .type = NLA_S32 },\n\t[IFLA_CARRIER_UP_COUNT]\t= { .type = NLA_U32 },\n\t[IFLA_CARRIER_DOWN_COUNT] = { .type = NLA_U32 },\n\t[IFLA_MIN_MTU]\t\t= { .type = NLA_U32 },\n\t[IFLA_MAX_MTU]\t\t= { .type = NLA_U32 },\n\t[IFLA_PROP_LIST]\t= { .type = NLA_NESTED },\n\t[IFLA_ALT_IFNAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = ALTIFNAMSIZ - 1 },\n\t[IFLA_PERM_ADDRESS]\t= { .type = NLA_REJECT },\n\t[IFLA_PROTO_DOWN_REASON] = { .type = NLA_NESTED },\n\t[IFLA_NEW_IFINDEX]\t= NLA_POLICY_MIN(NLA_S32, 1),\n\t[IFLA_PARENT_DEV_NAME]\t= { .type = NLA_NUL_STRING },\n\t[IFLA_GRO_MAX_SIZE]\t= { .type = NLA_U32 },\n\t[IFLA_TSO_MAX_SIZE]\t= { .type = NLA_REJECT },\n\t[IFLA_TSO_MAX_SEGS]\t= { .type = NLA_REJECT },\n\t[IFLA_ALLMULTI]\t\t= { .type = NLA_REJECT },\n\t[IFLA_GSO_IPV4_MAX_SIZE]\t= { .type = NLA_U32 },\n\t[IFLA_GRO_IPV4_MAX_SIZE]\t= { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {\n\t[IFLA_INFO_KIND]\t= { .type = NLA_STRING },\n\t[IFLA_INFO_DATA]\t= { .type = NLA_NESTED },\n\t[IFLA_INFO_SLAVE_KIND]\t= { .type = NLA_STRING },\n\t[IFLA_INFO_SLAVE_DATA]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {\n\t[IFLA_VF_MAC]\t\t= { .len = sizeof(struct ifla_vf_mac) },\n\t[IFLA_VF_BROADCAST]\t= { .type = NLA_REJECT },\n\t[IFLA_VF_VLAN]\t\t= { .len = sizeof(struct ifla_vf_vlan) },\n\t[IFLA_VF_VLAN_LIST]     = { .type = NLA_NESTED },\n\t[IFLA_VF_TX_RATE]\t= { .len = sizeof(struct ifla_vf_tx_rate) },\n\t[IFLA_VF_SPOOFCHK]\t= { .len = sizeof(struct ifla_vf_spoofchk) },\n\t[IFLA_VF_RATE]\t\t= { .len = sizeof(struct ifla_vf_rate) },\n\t[IFLA_VF_LINK_STATE]\t= { .len = sizeof(struct ifla_vf_link_state) },\n\t[IFLA_VF_RSS_QUERY_EN]\t= { .len = sizeof(struct ifla_vf_rss_query_en) },\n\t[IFLA_VF_STATS]\t\t= { .type = NLA_NESTED },\n\t[IFLA_VF_TRUST]\t\t= { .len = sizeof(struct ifla_vf_trust) },\n\t[IFLA_VF_IB_NODE_GUID]\t= { .len = sizeof(struct ifla_vf_guid) },\n\t[IFLA_VF_IB_PORT_GUID]\t= { .len = sizeof(struct ifla_vf_guid) },\n};\n\nstatic const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {\n\t[IFLA_PORT_VF]\t\t= { .type = NLA_U32 },\n\t[IFLA_PORT_PROFILE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = PORT_PROFILE_MAX },\n\t[IFLA_PORT_INSTANCE_UUID] = { .type = NLA_BINARY,\n\t\t\t\t      .len = PORT_UUID_MAX },\n\t[IFLA_PORT_HOST_UUID]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = PORT_UUID_MAX },\n\t[IFLA_PORT_REQUEST]\t= { .type = NLA_U8, },\n\t[IFLA_PORT_RESPONSE]\t= { .type = NLA_U16, },\n\n\t \n\t[IFLA_PORT_VSI_TYPE]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_port_vsi) },\n};\n\nstatic const struct nla_policy ifla_xdp_policy[IFLA_XDP_MAX + 1] = {\n\t[IFLA_XDP_UNSPEC]\t= { .strict_start_type = IFLA_XDP_EXPECTED_FD },\n\t[IFLA_XDP_FD]\t\t= { .type = NLA_S32 },\n\t[IFLA_XDP_EXPECTED_FD]\t= { .type = NLA_S32 },\n\t[IFLA_XDP_ATTACHED]\t= { .type = NLA_U8 },\n\t[IFLA_XDP_FLAGS]\t= { .type = NLA_U32 },\n\t[IFLA_XDP_PROG_ID]\t= { .type = NLA_U32 },\n};\n\nstatic const struct rtnl_link_ops *linkinfo_to_kind_ops(const struct nlattr *nla)\n{\n\tconst struct rtnl_link_ops *ops = NULL;\n\tstruct nlattr *linfo[IFLA_INFO_MAX + 1];\n\n\tif (nla_parse_nested_deprecated(linfo, IFLA_INFO_MAX, nla, ifla_info_policy, NULL) < 0)\n\t\treturn NULL;\n\n\tif (linfo[IFLA_INFO_KIND]) {\n\t\tchar kind[MODULE_NAME_LEN];\n\n\t\tnla_strscpy(kind, linfo[IFLA_INFO_KIND], sizeof(kind));\n\t\tops = rtnl_link_ops_get(kind);\n\t}\n\n\treturn ops;\n}\n\nstatic bool link_master_filtered(struct net_device *dev, int master_idx)\n{\n\tstruct net_device *master;\n\n\tif (!master_idx)\n\t\treturn false;\n\n\tmaster = netdev_master_upper_dev_get(dev);\n\n\t \n\tif (master_idx == -1)\n\t\treturn !!master;\n\n\tif (!master || master->ifindex != master_idx)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool link_kind_filtered(const struct net_device *dev,\n\t\t\t       const struct rtnl_link_ops *kind_ops)\n{\n\tif (kind_ops && dev->rtnl_link_ops != kind_ops)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool link_dump_filtered(struct net_device *dev,\n\t\t\t       int master_idx,\n\t\t\t       const struct rtnl_link_ops *kind_ops)\n{\n\tif (link_master_filtered(dev, master_idx) ||\n\t    link_kind_filtered(dev, kind_ops))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstruct net *rtnl_get_net_ns_capable(struct sock *sk, int netnsid)\n{\n\tstruct net *net;\n\n\tnet = get_net_ns_by_id(sock_net(sk), netnsid);\n\tif (!net)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (!sk_ns_capable(sk, net->user_ns, CAP_NET_ADMIN)) {\n\t\tput_net(net);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\treturn net;\n}\nEXPORT_SYMBOL_GPL(rtnl_get_net_ns_capable);\n\nstatic int rtnl_valid_dump_ifinfo_req(const struct nlmsghdr *nlh,\n\t\t\t\t      bool strict_check, struct nlattr **tb,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint hdrlen;\n\n\tif (strict_check) {\n\t\tstruct ifinfomsg *ifm;\n\n\t\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid header for link dump\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tifm = nlmsg_data(nlh);\n\t\tif (ifm->__ifi_pad || ifm->ifi_type || ifm->ifi_flags ||\n\t\t    ifm->ifi_change) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for link dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ifm->ifi_index) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Filter by device index not supported for link dumps\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn nlmsg_parse_deprecated_strict(nlh, sizeof(*ifm), tb,\n\t\t\t\t\t\t     IFLA_MAX, ifla_policy,\n\t\t\t\t\t\t     extack);\n\t}\n\n\t \n\thdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?\n\t\t sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);\n\n\treturn nlmsg_parse_deprecated(nlh, hdrlen, tb, IFLA_MAX, ifla_policy,\n\t\t\t\t      extack);\n}\n\nstatic int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct netlink_ext_ack *extack = cb->extack;\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net *tgt_net = net;\n\tint h, s_h;\n\tint idx = 0, s_idx;\n\tstruct net_device *dev;\n\tstruct hlist_head *head;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\tconst struct rtnl_link_ops *kind_ops = NULL;\n\tunsigned int flags = NLM_F_MULTI;\n\tint master_idx = 0;\n\tint netnsid = -1;\n\tint err, i;\n\n\ts_h = cb->args[0];\n\ts_idx = cb->args[1];\n\n\terr = rtnl_valid_dump_ifinfo_req(nlh, cb->strict_check, tb, extack);\n\tif (err < 0) {\n\t\tif (cb->strict_check)\n\t\t\treturn err;\n\n\t\tgoto walk_entries;\n\t}\n\n\tfor (i = 0; i <= IFLA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (i) {\n\t\tcase IFLA_TARGET_NETNSID:\n\t\t\tnetnsid = nla_get_s32(tb[i]);\n\t\t\ttgt_net = rtnl_get_net_ns_capable(skb->sk, netnsid);\n\t\t\tif (IS_ERR(tgt_net)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid target network namespace id\");\n\t\t\t\treturn PTR_ERR(tgt_net);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IFLA_EXT_MASK:\n\t\t\text_filter_mask = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tcase IFLA_MASTER:\n\t\t\tmaster_idx = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tcase IFLA_LINKINFO:\n\t\t\tkind_ops = linkinfo_to_kind_ops(tb[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (cb->strict_check) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in link dump request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (master_idx || kind_ops)\n\t\tflags |= NLM_F_DUMP_FILTERED;\n\nwalk_entries:\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &tgt_net->dev_index_head[h];\n\t\thlist_for_each_entry(dev, head, index_hlist) {\n\t\t\tif (link_dump_filtered(dev, master_idx, kind_ops))\n\t\t\t\tgoto cont;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\terr = rtnl_fill_ifinfo(skb, dev, net,\n\t\t\t\t\t       RTM_NEWLINK,\n\t\t\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       nlh->nlmsg_seq, 0, flags,\n\t\t\t\t\t       ext_filter_mask, 0, NULL, 0,\n\t\t\t\t\t       netnsid, GFP_KERNEL);\n\n\t\t\tif (err < 0) {\n\t\t\t\tif (likely(skb->len))\n\t\t\t\t\tgoto out;\n\n\t\t\t\tgoto out_err;\n\t\t\t}\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\terr = skb->len;\nout_err:\n\tcb->args[1] = idx;\n\tcb->args[0] = h;\n\tcb->seq = tgt_net->dev_base_seq;\n\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\n\tif (netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn err;\n}\n\nint rtnl_nla_parse_ifinfomsg(struct nlattr **tb, const struct nlattr *nla_peer,\n\t\t\t     struct netlink_ext_ack *exterr)\n{\n\tconst struct ifinfomsg *ifmp;\n\tconst struct nlattr *attrs;\n\tsize_t len;\n\n\tifmp = nla_data(nla_peer);\n\tattrs = nla_data(nla_peer) + sizeof(struct ifinfomsg);\n\tlen = nla_len(nla_peer) - sizeof(struct ifinfomsg);\n\n\tif (ifmp->ifi_index < 0) {\n\t\tNL_SET_ERR_MSG_ATTR(exterr, nla_peer,\n\t\t\t\t    \"ifindex can't be negative\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nla_parse_deprecated(tb, IFLA_MAX, attrs, len, ifla_policy,\n\t\t\t\t    exterr);\n}\nEXPORT_SYMBOL(rtnl_nla_parse_ifinfomsg);\n\nstruct net *rtnl_link_get_net(struct net *src_net, struct nlattr *tb[])\n{\n\tstruct net *net;\n\t \n\tif (tb[IFLA_NET_NS_PID])\n\t\tnet = get_net_ns_by_pid(nla_get_u32(tb[IFLA_NET_NS_PID]));\n\telse if (tb[IFLA_NET_NS_FD])\n\t\tnet = get_net_ns_by_fd(nla_get_u32(tb[IFLA_NET_NS_FD]));\n\telse\n\t\tnet = get_net(src_net);\n\treturn net;\n}\nEXPORT_SYMBOL(rtnl_link_get_net);\n\n \nstatic struct net *rtnl_link_get_net_by_nlattr(struct net *src_net,\n\t\t\t\t\t       struct nlattr *tb[])\n{\n\tstruct net *net;\n\n\tif (tb[IFLA_NET_NS_PID] || tb[IFLA_NET_NS_FD])\n\t\treturn rtnl_link_get_net(src_net, tb);\n\n\tif (!tb[IFLA_TARGET_NETNSID])\n\t\treturn get_net(src_net);\n\n\tnet = get_net_ns_by_id(src_net, nla_get_u32(tb[IFLA_TARGET_NETNSID]));\n\tif (!net)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn net;\n}\n\nstatic struct net *rtnl_link_get_net_capable(const struct sk_buff *skb,\n\t\t\t\t\t     struct net *src_net,\n\t\t\t\t\t     struct nlattr *tb[], int cap)\n{\n\tstruct net *net;\n\n\tnet = rtnl_link_get_net_by_nlattr(src_net, tb);\n\tif (IS_ERR(net))\n\t\treturn net;\n\n\tif (!netlink_ns_capable(skb, net->user_ns, cap)) {\n\t\tput_net(net);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\treturn net;\n}\n\n \nstatic int rtnl_ensure_unique_netns(struct nlattr *tb[],\n\t\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t\t    bool netns_id_only)\n{\n\n\tif (netns_id_only) {\n\t\tif (!tb[IFLA_NET_NS_PID] && !tb[IFLA_NET_NS_FD])\n\t\t\treturn 0;\n\n\t\tNL_SET_ERR_MSG(extack, \"specified netns attribute not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[IFLA_TARGET_NETNSID] && (tb[IFLA_NET_NS_PID] || tb[IFLA_NET_NS_FD]))\n\t\tgoto invalid_attr;\n\n\tif (tb[IFLA_NET_NS_PID] && (tb[IFLA_TARGET_NETNSID] || tb[IFLA_NET_NS_FD]))\n\t\tgoto invalid_attr;\n\n\tif (tb[IFLA_NET_NS_FD] && (tb[IFLA_TARGET_NETNSID] || tb[IFLA_NET_NS_PID]))\n\t\tgoto invalid_attr;\n\n\treturn 0;\n\ninvalid_attr:\n\tNL_SET_ERR_MSG(extack, \"multiple netns identifying attributes specified\");\n\treturn -EINVAL;\n}\n\nstatic\tint rtnl_set_vf_rate(struct net_device *dev, int vf, int min_tx_rate,\n\t\t\t     int max_tx_rate)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tif (!ops->ndo_set_vf_rate)\n\t\treturn -EOPNOTSUPP;\n\tif (max_tx_rate && max_tx_rate < min_tx_rate)\n\t\treturn -EINVAL;\n\n\treturn ops->ndo_set_vf_rate(dev, vf, min_tx_rate, max_tx_rate);\n}\n\nstatic int validate_linkmsg(struct net_device *dev, struct nlattr *tb[],\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS] &&\n\t    nla_len(tb[IFLA_ADDRESS]) < dev->addr_len)\n\t\treturn -EINVAL;\n\n\tif (tb[IFLA_BROADCAST] &&\n\t    nla_len(tb[IFLA_BROADCAST]) < dev->addr_len)\n\t\treturn -EINVAL;\n\n\tif (tb[IFLA_GSO_MAX_SIZE] &&\n\t    nla_get_u32(tb[IFLA_GSO_MAX_SIZE]) > dev->tso_max_size) {\n\t\tNL_SET_ERR_MSG(extack, \"too big gso_max_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[IFLA_GSO_MAX_SEGS] &&\n\t    (nla_get_u32(tb[IFLA_GSO_MAX_SEGS]) > GSO_MAX_SEGS ||\n\t     nla_get_u32(tb[IFLA_GSO_MAX_SEGS]) > dev->tso_max_segs)) {\n\t\tNL_SET_ERR_MSG(extack, \"too big gso_max_segs\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[IFLA_GRO_MAX_SIZE] &&\n\t    nla_get_u32(tb[IFLA_GRO_MAX_SIZE]) > GRO_MAX_SIZE) {\n\t\tNL_SET_ERR_MSG(extack, \"too big gro_max_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[IFLA_GSO_IPV4_MAX_SIZE] &&\n\t    nla_get_u32(tb[IFLA_GSO_IPV4_MAX_SIZE]) > dev->tso_max_size) {\n\t\tNL_SET_ERR_MSG(extack, \"too big gso_ipv4_max_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[IFLA_GRO_IPV4_MAX_SIZE] &&\n\t    nla_get_u32(tb[IFLA_GRO_IPV4_MAX_SIZE]) > GRO_MAX_SIZE) {\n\t\tNL_SET_ERR_MSG(extack, \"too big gro_ipv4_max_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[IFLA_AF_SPEC]) {\n\t\tstruct nlattr *af;\n\t\tint rem, err;\n\n\t\tnla_for_each_nested(af, tb[IFLA_AF_SPEC], rem) {\n\t\t\tconst struct rtnl_af_ops *af_ops;\n\n\t\t\taf_ops = rtnl_af_lookup(nla_type(af));\n\t\t\tif (!af_ops)\n\t\t\t\treturn -EAFNOSUPPORT;\n\n\t\t\tif (!af_ops->set_link_af)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tif (af_ops->validate_link_af) {\n\t\t\t\terr = af_ops->validate_link_af(dev, af, extack);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int handle_infiniband_guid(struct net_device *dev, struct ifla_vf_guid *ivt,\n\t\t\t\t  int guid_type)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\treturn ops->ndo_set_vf_guid(dev, ivt->vf, ivt->guid, guid_type);\n}\n\nstatic int handle_vf_guid(struct net_device *dev, struct ifla_vf_guid *ivt, int guid_type)\n{\n\tif (dev->type != ARPHRD_INFINIBAND)\n\t\treturn -EOPNOTSUPP;\n\n\treturn handle_infiniband_guid(dev, ivt, guid_type);\n}\n\nstatic int do_setvfinfo(struct net_device *dev, struct nlattr **tb)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tint err = -EINVAL;\n\n\tif (tb[IFLA_VF_MAC]) {\n\t\tstruct ifla_vf_mac *ivm = nla_data(tb[IFLA_VF_MAC]);\n\n\t\tif (ivm->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_mac)\n\t\t\terr = ops->ndo_set_vf_mac(dev, ivm->vf,\n\t\t\t\t\t\t  ivm->mac);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_VLAN]) {\n\t\tstruct ifla_vf_vlan *ivv = nla_data(tb[IFLA_VF_VLAN]);\n\n\t\tif (ivv->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_vlan)\n\t\t\terr = ops->ndo_set_vf_vlan(dev, ivv->vf, ivv->vlan,\n\t\t\t\t\t\t   ivv->qos,\n\t\t\t\t\t\t   htons(ETH_P_8021Q));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_VLAN_LIST]) {\n\t\tstruct ifla_vf_vlan_info *ivvl[MAX_VLAN_LIST_LEN];\n\t\tstruct nlattr *attr;\n\t\tint rem, len = 0;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (!ops->ndo_set_vf_vlan)\n\t\t\treturn err;\n\n\t\tnla_for_each_nested(attr, tb[IFLA_VF_VLAN_LIST], rem) {\n\t\t\tif (nla_type(attr) != IFLA_VF_VLAN_INFO ||\n\t\t\t    nla_len(attr) < NLA_HDRLEN) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (len >= MAX_VLAN_LIST_LEN)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tivvl[len] = nla_data(attr);\n\n\t\t\tlen++;\n\t\t}\n\t\tif (len == 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (ivvl[0]->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = ops->ndo_set_vf_vlan(dev, ivvl[0]->vf, ivvl[0]->vlan,\n\t\t\t\t\t   ivvl[0]->qos, ivvl[0]->vlan_proto);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_TX_RATE]) {\n\t\tstruct ifla_vf_tx_rate *ivt = nla_data(tb[IFLA_VF_TX_RATE]);\n\t\tstruct ifla_vf_info ivf;\n\n\t\tif (ivt->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_get_vf_config)\n\t\t\terr = ops->ndo_get_vf_config(dev, ivt->vf, &ivf);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = rtnl_set_vf_rate(dev, ivt->vf,\n\t\t\t\t       ivf.min_tx_rate, ivt->rate);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_RATE]) {\n\t\tstruct ifla_vf_rate *ivt = nla_data(tb[IFLA_VF_RATE]);\n\n\t\tif (ivt->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\n\t\terr = rtnl_set_vf_rate(dev, ivt->vf,\n\t\t\t\t       ivt->min_tx_rate, ivt->max_tx_rate);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_SPOOFCHK]) {\n\t\tstruct ifla_vf_spoofchk *ivs = nla_data(tb[IFLA_VF_SPOOFCHK]);\n\n\t\tif (ivs->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_spoofchk)\n\t\t\terr = ops->ndo_set_vf_spoofchk(dev, ivs->vf,\n\t\t\t\t\t\t       ivs->setting);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_LINK_STATE]) {\n\t\tstruct ifla_vf_link_state *ivl = nla_data(tb[IFLA_VF_LINK_STATE]);\n\n\t\tif (ivl->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_link_state)\n\t\t\terr = ops->ndo_set_vf_link_state(dev, ivl->vf,\n\t\t\t\t\t\t\t ivl->link_state);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_RSS_QUERY_EN]) {\n\t\tstruct ifla_vf_rss_query_en *ivrssq_en;\n\n\t\terr = -EOPNOTSUPP;\n\t\tivrssq_en = nla_data(tb[IFLA_VF_RSS_QUERY_EN]);\n\t\tif (ivrssq_en->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\tif (ops->ndo_set_vf_rss_query_en)\n\t\t\terr = ops->ndo_set_vf_rss_query_en(dev, ivrssq_en->vf,\n\t\t\t\t\t\t\t   ivrssq_en->setting);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_TRUST]) {\n\t\tstruct ifla_vf_trust *ivt = nla_data(tb[IFLA_VF_TRUST]);\n\n\t\tif (ivt->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_trust)\n\t\t\terr = ops->ndo_set_vf_trust(dev, ivt->vf, ivt->setting);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_IB_NODE_GUID]) {\n\t\tstruct ifla_vf_guid *ivt = nla_data(tb[IFLA_VF_IB_NODE_GUID]);\n\n\t\tif (ivt->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\tif (!ops->ndo_set_vf_guid)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn handle_vf_guid(dev, ivt, IFLA_VF_IB_NODE_GUID);\n\t}\n\n\tif (tb[IFLA_VF_IB_PORT_GUID]) {\n\t\tstruct ifla_vf_guid *ivt = nla_data(tb[IFLA_VF_IB_PORT_GUID]);\n\n\t\tif (ivt->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\tif (!ops->ndo_set_vf_guid)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn handle_vf_guid(dev, ivt, IFLA_VF_IB_PORT_GUID);\n\t}\n\n\treturn err;\n}\n\nstatic int do_set_master(struct net_device *dev, int ifindex,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net_device *upper_dev = netdev_master_upper_dev_get(dev);\n\tconst struct net_device_ops *ops;\n\tint err;\n\n\tif (upper_dev) {\n\t\tif (upper_dev->ifindex == ifindex)\n\t\t\treturn 0;\n\t\tops = upper_dev->netdev_ops;\n\t\tif (ops->ndo_del_slave) {\n\t\t\terr = ops->ndo_del_slave(upper_dev, dev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (ifindex) {\n\t\tupper_dev = __dev_get_by_index(dev_net(dev), ifindex);\n\t\tif (!upper_dev)\n\t\t\treturn -EINVAL;\n\t\tops = upper_dev->netdev_ops;\n\t\tif (ops->ndo_add_slave) {\n\t\t\terr = ops->ndo_add_slave(upper_dev, dev, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct nla_policy ifla_proto_down_reason_policy[IFLA_PROTO_DOWN_REASON_VALUE + 1] = {\n\t[IFLA_PROTO_DOWN_REASON_MASK]\t= { .type = NLA_U32 },\n\t[IFLA_PROTO_DOWN_REASON_VALUE]\t= { .type = NLA_U32 },\n};\n\nstatic int do_set_proto_down(struct net_device *dev,\n\t\t\t     struct nlattr *nl_proto_down,\n\t\t\t     struct nlattr *nl_proto_down_reason,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *pdreason[IFLA_PROTO_DOWN_REASON_MAX + 1];\n\tunsigned long mask = 0;\n\tu32 value;\n\tbool proto_down;\n\tint err;\n\n\tif (!(dev->priv_flags & IFF_CHANGE_PROTO_DOWN)) {\n\t\tNL_SET_ERR_MSG(extack,  \"Protodown not supported by device\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (nl_proto_down_reason) {\n\t\terr = nla_parse_nested_deprecated(pdreason,\n\t\t\t\t\t\t  IFLA_PROTO_DOWN_REASON_MAX,\n\t\t\t\t\t\t  nl_proto_down_reason,\n\t\t\t\t\t\t  ifla_proto_down_reason_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!pdreason[IFLA_PROTO_DOWN_REASON_VALUE]) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid protodown reason value\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvalue = nla_get_u32(pdreason[IFLA_PROTO_DOWN_REASON_VALUE]);\n\n\t\tif (pdreason[IFLA_PROTO_DOWN_REASON_MASK])\n\t\t\tmask = nla_get_u32(pdreason[IFLA_PROTO_DOWN_REASON_MASK]);\n\n\t\tdev_change_proto_down_reason(dev, mask, value);\n\t}\n\n\tif (nl_proto_down) {\n\t\tproto_down = nla_get_u8(nl_proto_down);\n\n\t\t \n\t\tif (!proto_down && dev->proto_down_reason) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot clear protodown, active reasons\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\terr = dev_change_proto_down(dev,\n\t\t\t\t\t    proto_down);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#define DO_SETLINK_MODIFIED\t0x01\n \n#define DO_SETLINK_NOTIFY\t0x03\nstatic int do_setlink(const struct sk_buff *skb,\n\t\t      struct net_device *dev, struct ifinfomsg *ifm,\n\t\t      struct netlink_ext_ack *extack,\n\t\t      struct nlattr **tb, int status)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tchar ifname[IFNAMSIZ];\n\tint err;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strscpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tifname[0] = '\\0';\n\n\tif (tb[IFLA_NET_NS_PID] || tb[IFLA_NET_NS_FD] || tb[IFLA_TARGET_NETNSID]) {\n\t\tconst char *pat = ifname[0] ? ifname : NULL;\n\t\tstruct net *net;\n\t\tint new_ifindex;\n\n\t\tnet = rtnl_link_get_net_capable(skb, dev_net(dev),\n\t\t\t\t\t\ttb, CAP_NET_ADMIN);\n\t\tif (IS_ERR(net)) {\n\t\t\terr = PTR_ERR(net);\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (tb[IFLA_NEW_IFINDEX])\n\t\t\tnew_ifindex = nla_get_s32(tb[IFLA_NEW_IFINDEX]);\n\t\telse\n\t\t\tnew_ifindex = 0;\n\n\t\terr = __dev_change_net_namespace(dev, net, pat, new_ifindex);\n\t\tput_net(net);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_MAP]) {\n\t\tstruct rtnl_link_ifmap *u_map;\n\t\tstruct ifmap k_map;\n\n\t\tif (!ops->ndo_set_config) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (!netif_device_present(dev)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tu_map = nla_data(tb[IFLA_MAP]);\n\t\tk_map.mem_start = (unsigned long) u_map->mem_start;\n\t\tk_map.mem_end = (unsigned long) u_map->mem_end;\n\t\tk_map.base_addr = (unsigned short) u_map->base_addr;\n\t\tk_map.irq = (unsigned char) u_map->irq;\n\t\tk_map.dma = (unsigned char) u_map->dma;\n\t\tk_map.port = (unsigned char) u_map->port;\n\n\t\terr = ops->ndo_set_config(dev, &k_map);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\n\t\tstatus |= DO_SETLINK_NOTIFY;\n\t}\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tstruct sockaddr *sa;\n\t\tint len;\n\n\t\tlen = sizeof(sa_family_t) + max_t(size_t, dev->addr_len,\n\t\t\t\t\t\t  sizeof(*sa));\n\t\tsa = kmalloc(len, GFP_KERNEL);\n\t\tif (!sa) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout;\n\t\t}\n\t\tsa->sa_family = dev->type;\n\t\tmemcpy(sa->sa_data, nla_data(tb[IFLA_ADDRESS]),\n\t\t       dev->addr_len);\n\t\terr = dev_set_mac_address_user(dev, sa, extack);\n\t\tkfree(sa);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_MTU]) {\n\t\terr = dev_set_mtu_ext(dev, nla_get_u32(tb[IFLA_MTU]), extack);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_GROUP]) {\n\t\tdev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));\n\t\tstatus |= DO_SETLINK_NOTIFY;\n\t}\n\n\t \n\tif (ifm->ifi_index > 0 && ifname[0]) {\n\t\terr = dev_change_name(dev, ifname);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_IFALIAS]) {\n\t\terr = dev_set_alias(dev, nla_data(tb[IFLA_IFALIAS]),\n\t\t\t\t    nla_len(tb[IFLA_IFALIAS]));\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_NOTIFY;\n\t}\n\n\tif (tb[IFLA_BROADCAST]) {\n\t\tnla_memcpy(dev->broadcast, tb[IFLA_BROADCAST], dev->addr_len);\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\n\t}\n\n\tif (ifm->ifi_flags || ifm->ifi_change) {\n\t\terr = dev_change_flags(dev, rtnl_dev_combine_flags(dev, ifm),\n\t\t\t\t       extack);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (tb[IFLA_MASTER]) {\n\t\terr = do_set_master(dev, nla_get_u32(tb[IFLA_MASTER]), extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_CARRIER]) {\n\t\terr = dev_change_carrier(dev, nla_get_u8(tb[IFLA_CARRIER]));\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_TXQLEN]) {\n\t\tunsigned int value = nla_get_u32(tb[IFLA_TXQLEN]);\n\n\t\terr = dev_change_tx_queue_len(dev, value);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_GSO_MAX_SIZE]) {\n\t\tu32 max_size = nla_get_u32(tb[IFLA_GSO_MAX_SIZE]);\n\n\t\tif (dev->gso_max_size ^ max_size) {\n\t\t\tnetif_set_gso_max_size(dev, max_size);\n\t\t\tstatus |= DO_SETLINK_MODIFIED;\n\t\t}\n\t}\n\n\tif (tb[IFLA_GSO_MAX_SEGS]) {\n\t\tu32 max_segs = nla_get_u32(tb[IFLA_GSO_MAX_SEGS]);\n\n\t\tif (dev->gso_max_segs ^ max_segs) {\n\t\t\tnetif_set_gso_max_segs(dev, max_segs);\n\t\t\tstatus |= DO_SETLINK_MODIFIED;\n\t\t}\n\t}\n\n\tif (tb[IFLA_GRO_MAX_SIZE]) {\n\t\tu32 gro_max_size = nla_get_u32(tb[IFLA_GRO_MAX_SIZE]);\n\n\t\tif (dev->gro_max_size ^ gro_max_size) {\n\t\t\tnetif_set_gro_max_size(dev, gro_max_size);\n\t\t\tstatus |= DO_SETLINK_MODIFIED;\n\t\t}\n\t}\n\n\tif (tb[IFLA_GSO_IPV4_MAX_SIZE]) {\n\t\tu32 max_size = nla_get_u32(tb[IFLA_GSO_IPV4_MAX_SIZE]);\n\n\t\tif (dev->gso_ipv4_max_size ^ max_size) {\n\t\t\tnetif_set_gso_ipv4_max_size(dev, max_size);\n\t\t\tstatus |= DO_SETLINK_MODIFIED;\n\t\t}\n\t}\n\n\tif (tb[IFLA_GRO_IPV4_MAX_SIZE]) {\n\t\tu32 gro_max_size = nla_get_u32(tb[IFLA_GRO_IPV4_MAX_SIZE]);\n\n\t\tif (dev->gro_ipv4_max_size ^ gro_max_size) {\n\t\t\tnetif_set_gro_ipv4_max_size(dev, gro_max_size);\n\t\t\tstatus |= DO_SETLINK_MODIFIED;\n\t\t}\n\t}\n\n\tif (tb[IFLA_OPERSTATE])\n\t\tset_operstate(dev, nla_get_u8(tb[IFLA_OPERSTATE]));\n\n\tif (tb[IFLA_LINKMODE]) {\n\t\tunsigned char value = nla_get_u8(tb[IFLA_LINKMODE]);\n\n\t\twrite_lock(&dev_base_lock);\n\t\tif (dev->link_mode ^ value)\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\tdev->link_mode = value;\n\t\twrite_unlock(&dev_base_lock);\n\t}\n\n\tif (tb[IFLA_VFINFO_LIST]) {\n\t\tstruct nlattr *vfinfo[IFLA_VF_MAX + 1];\n\t\tstruct nlattr *attr;\n\t\tint rem;\n\n\t\tnla_for_each_nested(attr, tb[IFLA_VFINFO_LIST], rem) {\n\t\t\tif (nla_type(attr) != IFLA_VF_INFO ||\n\t\t\t    nla_len(attr) < NLA_HDRLEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\terr = nla_parse_nested_deprecated(vfinfo, IFLA_VF_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  ifla_vf_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\terr = do_setvfinfo(dev, vfinfo);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\t}\n\terr = 0;\n\n\tif (tb[IFLA_VF_PORTS]) {\n\t\tstruct nlattr *port[IFLA_PORT_MAX+1];\n\t\tstruct nlattr *attr;\n\t\tint vf;\n\t\tint rem;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (!ops->ndo_set_vf_port)\n\t\t\tgoto errout;\n\n\t\tnla_for_each_nested(attr, tb[IFLA_VF_PORTS], rem) {\n\t\t\tif (nla_type(attr) != IFLA_VF_PORT ||\n\t\t\t    nla_len(attr) < NLA_HDRLEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\terr = nla_parse_nested_deprecated(port, IFLA_PORT_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  ifla_port_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tif (!port[IFLA_PORT_VF]) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tvf = nla_get_u32(port[IFLA_PORT_VF]);\n\t\t\terr = ops->ndo_set_vf_port(dev, vf, port);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\t}\n\terr = 0;\n\n\tif (tb[IFLA_PORT_SELF]) {\n\t\tstruct nlattr *port[IFLA_PORT_MAX+1];\n\n\t\terr = nla_parse_nested_deprecated(port, IFLA_PORT_MAX,\n\t\t\t\t\t\t  tb[IFLA_PORT_SELF],\n\t\t\t\t\t\t  ifla_port_policy, NULL);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_port)\n\t\t\terr = ops->ndo_set_vf_port(dev, PORT_SELF_VF, port);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_NOTIFY;\n\t}\n\n\tif (tb[IFLA_AF_SPEC]) {\n\t\tstruct nlattr *af;\n\t\tint rem;\n\n\t\tnla_for_each_nested(af, tb[IFLA_AF_SPEC], rem) {\n\t\t\tconst struct rtnl_af_ops *af_ops;\n\n\t\t\tBUG_ON(!(af_ops = rtnl_af_lookup(nla_type(af))));\n\n\t\t\terr = af_ops->set_link_af(dev, af, extack);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\t}\n\terr = 0;\n\n\tif (tb[IFLA_PROTO_DOWN] || tb[IFLA_PROTO_DOWN_REASON]) {\n\t\terr = do_set_proto_down(dev, tb[IFLA_PROTO_DOWN],\n\t\t\t\t\ttb[IFLA_PROTO_DOWN_REASON], extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_NOTIFY;\n\t}\n\n\tif (tb[IFLA_XDP]) {\n\t\tstruct nlattr *xdp[IFLA_XDP_MAX + 1];\n\t\tu32 xdp_flags = 0;\n\n\t\terr = nla_parse_nested_deprecated(xdp, IFLA_XDP_MAX,\n\t\t\t\t\t\t  tb[IFLA_XDP],\n\t\t\t\t\t\t  ifla_xdp_policy, NULL);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\n\t\tif (xdp[IFLA_XDP_ATTACHED] || xdp[IFLA_XDP_PROG_ID]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (xdp[IFLA_XDP_FLAGS]) {\n\t\t\txdp_flags = nla_get_u32(xdp[IFLA_XDP_FLAGS]);\n\t\t\tif (xdp_flags & ~XDP_FLAGS_MASK) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tif (hweight32(xdp_flags & XDP_FLAGS_MODES) > 1) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tif (xdp[IFLA_XDP_FD]) {\n\t\t\tint expected_fd = -1;\n\n\t\t\tif (xdp_flags & XDP_FLAGS_REPLACE) {\n\t\t\t\tif (!xdp[IFLA_XDP_EXPECTED_FD]) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto errout;\n\t\t\t\t}\n\t\t\t\texpected_fd =\n\t\t\t\t\tnla_get_s32(xdp[IFLA_XDP_EXPECTED_FD]);\n\t\t\t}\n\n\t\t\terr = dev_change_xdp_fd(dev, extack,\n\t\t\t\t\t\tnla_get_s32(xdp[IFLA_XDP_FD]),\n\t\t\t\t\t\texpected_fd,\n\t\t\t\t\t\txdp_flags);\n\t\t\tif (err)\n\t\t\t\tgoto errout;\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\t}\n\nerrout:\n\tif (status & DO_SETLINK_MODIFIED) {\n\t\tif ((status & DO_SETLINK_NOTIFY) == DO_SETLINK_NOTIFY)\n\t\t\tnetdev_state_change(dev);\n\n\t\tif (err < 0)\n\t\t\tnet_warn_ratelimited(\"A link change request failed with some changes committed already. Interface %s may have been left with an inconsistent configuration, please check.\\n\",\n\t\t\t\t\t     dev->name);\n\t}\n\n\treturn err;\n}\n\nstatic struct net_device *rtnl_dev_get(struct net *net,\n\t\t\t\t       struct nlattr *tb[])\n{\n\tchar ifname[ALTIFNAMSIZ];\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strscpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse if (tb[IFLA_ALT_IFNAME])\n\t\tnla_strscpy(ifname, tb[IFLA_ALT_IFNAME], ALTIFNAMSIZ);\n\telse\n\t\treturn NULL;\n\n\treturn __dev_get_by_name(net, ifname);\n}\n\nstatic int rtnl_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tint err;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFLA_MAX,\n\t\t\t\t     ifla_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = rtnl_ensure_unique_netns(tb, extack, false);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])\n\t\tdev = rtnl_dev_get(net, tb);\n\telse\n\t\tgoto errout;\n\n\tif (dev == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto errout;\n\t}\n\n\terr = validate_linkmsg(dev, tb, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = do_setlink(skb, dev, ifm, extack, tb, 0);\nerrout:\n\treturn err;\n}\n\nstatic int rtnl_group_dellink(const struct net *net, int group)\n{\n\tstruct net_device *dev, *aux;\n\tLIST_HEAD(list_kill);\n\tbool found = false;\n\n\tif (!group)\n\t\treturn -EPERM;\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\tconst struct rtnl_link_ops *ops;\n\n\t\t\tfound = true;\n\t\t\tops = dev->rtnl_link_ops;\n\t\t\tif (!ops || !ops->dellink)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -ENODEV;\n\n\tfor_each_netdev_safe(net, dev, aux) {\n\t\tif (dev->group == group) {\n\t\t\tconst struct rtnl_link_ops *ops;\n\n\t\t\tops = dev->rtnl_link_ops;\n\t\t\tops->dellink(dev, &list_kill);\n\t\t}\n\t}\n\tunregister_netdevice_many(&list_kill);\n\n\treturn 0;\n}\n\nint rtnl_delete_link(struct net_device *dev, u32 portid, const struct nlmsghdr *nlh)\n{\n\tconst struct rtnl_link_ops *ops;\n\tLIST_HEAD(list_kill);\n\n\tops = dev->rtnl_link_ops;\n\tif (!ops || !ops->dellink)\n\t\treturn -EOPNOTSUPP;\n\n\tops->dellink(dev, &list_kill);\n\tunregister_netdevice_many_notify(&list_kill, portid, nlh);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtnl_delete_link);\n\nstatic int rtnl_dellink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tu32 portid = NETLINK_CB(skb).portid;\n\tstruct net *tgt_net = net;\n\tstruct net_device *dev = NULL;\n\tstruct ifinfomsg *ifm;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tint err;\n\tint netnsid = -1;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFLA_MAX,\n\t\t\t\t     ifla_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtnl_ensure_unique_netns(tb, extack, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_TARGET_NETNSID]) {\n\t\tnetnsid = nla_get_s32(tb[IFLA_TARGET_NETNSID]);\n\t\ttgt_net = rtnl_get_net_ns_capable(NETLINK_CB(skb).sk, netnsid);\n\t\tif (IS_ERR(tgt_net))\n\t\t\treturn PTR_ERR(tgt_net);\n\t}\n\n\terr = -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(tgt_net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])\n\t\tdev = rtnl_dev_get(net, tb);\n\telse if (tb[IFLA_GROUP])\n\t\terr = rtnl_group_dellink(tgt_net, nla_get_u32(tb[IFLA_GROUP]));\n\telse\n\t\tgoto out;\n\n\tif (!dev) {\n\t\tif (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME] || ifm->ifi_index > 0)\n\t\t\terr = -ENODEV;\n\n\t\tgoto out;\n\t}\n\n\terr = rtnl_delete_link(dev, portid, nlh);\n\nout:\n\tif (netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn err;\n}\n\nint rtnl_configure_link(struct net_device *dev, const struct ifinfomsg *ifm,\n\t\t\tu32 portid, const struct nlmsghdr *nlh)\n{\n\tunsigned int old_flags;\n\tint err;\n\n\told_flags = dev->flags;\n\tif (ifm && (ifm->ifi_flags || ifm->ifi_change)) {\n\t\terr = __dev_change_flags(dev, rtnl_dev_combine_flags(dev, ifm),\n\t\t\t\t\t NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (dev->rtnl_link_state == RTNL_LINK_INITIALIZED) {\n\t\t__dev_notify_flags(dev, old_flags, (old_flags ^ dev->flags), portid, nlh);\n\t} else {\n\t\tdev->rtnl_link_state = RTNL_LINK_INITIALIZED;\n\t\t__dev_notify_flags(dev, old_flags, ~0U, portid, nlh);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(rtnl_configure_link);\n\nstruct net_device *rtnl_create_link(struct net *net, const char *ifname,\n\t\t\t\t    unsigned char name_assign_type,\n\t\t\t\t    const struct rtnl_link_ops *ops,\n\t\t\t\t    struct nlattr *tb[],\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev;\n\tunsigned int num_tx_queues = 1;\n\tunsigned int num_rx_queues = 1;\n\tint err;\n\n\tif (tb[IFLA_NUM_TX_QUEUES])\n\t\tnum_tx_queues = nla_get_u32(tb[IFLA_NUM_TX_QUEUES]);\n\telse if (ops->get_num_tx_queues)\n\t\tnum_tx_queues = ops->get_num_tx_queues();\n\n\tif (tb[IFLA_NUM_RX_QUEUES])\n\t\tnum_rx_queues = nla_get_u32(tb[IFLA_NUM_RX_QUEUES]);\n\telse if (ops->get_num_rx_queues)\n\t\tnum_rx_queues = ops->get_num_rx_queues();\n\n\tif (num_tx_queues < 1 || num_tx_queues > 4096) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid number of transmit queues\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (num_rx_queues < 1 || num_rx_queues > 4096) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid number of receive queues\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (ops->alloc) {\n\t\tdev = ops->alloc(tb, ifname, name_assign_type,\n\t\t\t\t num_tx_queues, num_rx_queues);\n\t\tif (IS_ERR(dev))\n\t\t\treturn dev;\n\t} else {\n\t\tdev = alloc_netdev_mqs(ops->priv_size, ifname,\n\t\t\t\t       name_assign_type, ops->setup,\n\t\t\t\t       num_tx_queues, num_rx_queues);\n\t}\n\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = validate_linkmsg(dev, tb, extack);\n\tif (err < 0) {\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tdev_net_set(dev, net);\n\tdev->rtnl_link_ops = ops;\n\tdev->rtnl_link_state = RTNL_LINK_INITIALIZING;\n\n\tif (tb[IFLA_MTU]) {\n\t\tu32 mtu = nla_get_u32(tb[IFLA_MTU]);\n\n\t\terr = dev_validate_mtu(dev, mtu, extack);\n\t\tif (err) {\n\t\t\tfree_netdev(dev);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tdev->mtu = mtu;\n\t}\n\tif (tb[IFLA_ADDRESS]) {\n\t\t__dev_addr_set(dev, nla_data(tb[IFLA_ADDRESS]),\n\t\t\t       nla_len(tb[IFLA_ADDRESS]));\n\t\tdev->addr_assign_type = NET_ADDR_SET;\n\t}\n\tif (tb[IFLA_BROADCAST])\n\t\tmemcpy(dev->broadcast, nla_data(tb[IFLA_BROADCAST]),\n\t\t\t\tnla_len(tb[IFLA_BROADCAST]));\n\tif (tb[IFLA_TXQLEN])\n\t\tdev->tx_queue_len = nla_get_u32(tb[IFLA_TXQLEN]);\n\tif (tb[IFLA_OPERSTATE])\n\t\tset_operstate(dev, nla_get_u8(tb[IFLA_OPERSTATE]));\n\tif (tb[IFLA_LINKMODE])\n\t\tdev->link_mode = nla_get_u8(tb[IFLA_LINKMODE]);\n\tif (tb[IFLA_GROUP])\n\t\tdev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));\n\tif (tb[IFLA_GSO_MAX_SIZE])\n\t\tnetif_set_gso_max_size(dev, nla_get_u32(tb[IFLA_GSO_MAX_SIZE]));\n\tif (tb[IFLA_GSO_MAX_SEGS])\n\t\tnetif_set_gso_max_segs(dev, nla_get_u32(tb[IFLA_GSO_MAX_SEGS]));\n\tif (tb[IFLA_GRO_MAX_SIZE])\n\t\tnetif_set_gro_max_size(dev, nla_get_u32(tb[IFLA_GRO_MAX_SIZE]));\n\tif (tb[IFLA_GSO_IPV4_MAX_SIZE])\n\t\tnetif_set_gso_ipv4_max_size(dev, nla_get_u32(tb[IFLA_GSO_IPV4_MAX_SIZE]));\n\tif (tb[IFLA_GRO_IPV4_MAX_SIZE])\n\t\tnetif_set_gro_ipv4_max_size(dev, nla_get_u32(tb[IFLA_GRO_IPV4_MAX_SIZE]));\n\n\treturn dev;\n}\nEXPORT_SYMBOL(rtnl_create_link);\n\nstatic int rtnl_group_changelink(const struct sk_buff *skb,\n\t\tstruct net *net, int group,\n\t\tstruct ifinfomsg *ifm,\n\t\tstruct netlink_ext_ack *extack,\n\t\tstruct nlattr **tb)\n{\n\tstruct net_device *dev, *aux;\n\tint err;\n\n\tfor_each_netdev_safe(net, dev, aux) {\n\t\tif (dev->group == group) {\n\t\t\terr = validate_linkmsg(dev, tb, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\terr = do_setlink(skb, dev, ifm, extack, tb, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_newlink_create(struct sk_buff *skb, struct ifinfomsg *ifm,\n\t\t\t       const struct rtnl_link_ops *ops,\n\t\t\t       const struct nlmsghdr *nlh,\n\t\t\t       struct nlattr **tb, struct nlattr **data,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tunsigned char name_assign_type = NET_NAME_USER;\n\tstruct net *net = sock_net(skb->sk);\n\tu32 portid = NETLINK_CB(skb).portid;\n\tstruct net *dest_net, *link_net;\n\tstruct net_device *dev;\n\tchar ifname[IFNAMSIZ];\n\tint err;\n\n\tif (!ops->alloc && !ops->setup)\n\t\treturn -EOPNOTSUPP;\n\n\tif (tb[IFLA_IFNAME]) {\n\t\tnla_strscpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\t} else {\n\t\tsnprintf(ifname, IFNAMSIZ, \"%s%%d\", ops->kind);\n\t\tname_assign_type = NET_NAME_ENUM;\n\t}\n\n\tdest_net = rtnl_link_get_net_capable(skb, net, tb, CAP_NET_ADMIN);\n\tif (IS_ERR(dest_net))\n\t\treturn PTR_ERR(dest_net);\n\n\tif (tb[IFLA_LINK_NETNSID]) {\n\t\tint id = nla_get_s32(tb[IFLA_LINK_NETNSID]);\n\n\t\tlink_net = get_net_ns_by_id(dest_net, id);\n\t\tif (!link_net) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Unknown network namespace id\");\n\t\t\terr =  -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = -EPERM;\n\t\tif (!netlink_ns_capable(skb, link_net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto out;\n\t} else {\n\t\tlink_net = NULL;\n\t}\n\n\tdev = rtnl_create_link(link_net ? : dest_net, ifname,\n\t\t\t       name_assign_type, ops, tb, extack);\n\tif (IS_ERR(dev)) {\n\t\terr = PTR_ERR(dev);\n\t\tgoto out;\n\t}\n\n\tdev->ifindex = ifm->ifi_index;\n\n\tif (ops->newlink)\n\t\terr = ops->newlink(link_net ? : net, dev, tb, data, extack);\n\telse\n\t\terr = register_netdevice(dev);\n\tif (err < 0) {\n\t\tfree_netdev(dev);\n\t\tgoto out;\n\t}\n\n\terr = rtnl_configure_link(dev, ifm, portid, nlh);\n\tif (err < 0)\n\t\tgoto out_unregister;\n\tif (link_net) {\n\t\terr = dev_change_net_namespace(dev, dest_net, ifname);\n\t\tif (err < 0)\n\t\t\tgoto out_unregister;\n\t}\n\tif (tb[IFLA_MASTER]) {\n\t\terr = do_set_master(dev, nla_get_u32(tb[IFLA_MASTER]), extack);\n\t\tif (err)\n\t\t\tgoto out_unregister;\n\t}\nout:\n\tif (link_net)\n\t\tput_net(link_net);\n\tput_net(dest_net);\n\treturn err;\nout_unregister:\n\tif (ops->newlink) {\n\t\tLIST_HEAD(list_kill);\n\n\t\tops->dellink(dev, &list_kill);\n\t\tunregister_netdevice_many(&list_kill);\n\t} else {\n\t\tunregister_netdevice(dev);\n\t}\n\tgoto out;\n}\n\nstruct rtnl_newlink_tbs {\n\tstruct nlattr *tb[IFLA_MAX + 1];\n\tstruct nlattr *attr[RTNL_MAX_TYPE + 1];\n\tstruct nlattr *slave_attr[RTNL_SLAVE_MAX_TYPE + 1];\n};\n\nstatic int __rtnl_newlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct rtnl_newlink_tbs *tbs,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *linkinfo[IFLA_INFO_MAX + 1];\n\tstruct nlattr ** const tb = tbs->tb;\n\tconst struct rtnl_link_ops *m_ops;\n\tstruct net_device *master_dev;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct rtnl_link_ops *ops;\n\tstruct nlattr **slave_data;\n\tchar kind[MODULE_NAME_LEN];\n\tstruct net_device *dev;\n\tstruct ifinfomsg *ifm;\n\tstruct nlattr **data;\n\tbool link_specified;\n\tint err;\n\n#ifdef CONFIG_MODULES\nreplay:\n#endif\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFLA_MAX,\n\t\t\t\t     ifla_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtnl_ensure_unique_netns(tb, extack, false);\n\tif (err < 0)\n\t\treturn err;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0) {\n\t\tlink_specified = true;\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\t} else if (ifm->ifi_index < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"ifindex can't be negative\");\n\t\treturn -EINVAL;\n\t} else if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME]) {\n\t\tlink_specified = true;\n\t\tdev = rtnl_dev_get(net, tb);\n\t} else {\n\t\tlink_specified = false;\n\t\tdev = NULL;\n\t}\n\n\tmaster_dev = NULL;\n\tm_ops = NULL;\n\tif (dev) {\n\t\tmaster_dev = netdev_master_upper_dev_get(dev);\n\t\tif (master_dev)\n\t\t\tm_ops = master_dev->rtnl_link_ops;\n\t}\n\n\tif (tb[IFLA_LINKINFO]) {\n\t\terr = nla_parse_nested_deprecated(linkinfo, IFLA_INFO_MAX,\n\t\t\t\t\t\t  tb[IFLA_LINKINFO],\n\t\t\t\t\t\t  ifla_info_policy, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else\n\t\tmemset(linkinfo, 0, sizeof(linkinfo));\n\n\tif (linkinfo[IFLA_INFO_KIND]) {\n\t\tnla_strscpy(kind, linkinfo[IFLA_INFO_KIND], sizeof(kind));\n\t\tops = rtnl_link_ops_get(kind);\n\t} else {\n\t\tkind[0] = '\\0';\n\t\tops = NULL;\n\t}\n\n\tdata = NULL;\n\tif (ops) {\n\t\tif (ops->maxtype > RTNL_MAX_TYPE)\n\t\t\treturn -EINVAL;\n\n\t\tif (ops->maxtype && linkinfo[IFLA_INFO_DATA]) {\n\t\t\terr = nla_parse_nested_deprecated(tbs->attr, ops->maxtype,\n\t\t\t\t\t\t\t  linkinfo[IFLA_INFO_DATA],\n\t\t\t\t\t\t\t  ops->policy, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tdata = tbs->attr;\n\t\t}\n\t\tif (ops->validate) {\n\t\t\terr = ops->validate(tb, data, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tslave_data = NULL;\n\tif (m_ops) {\n\t\tif (m_ops->slave_maxtype > RTNL_SLAVE_MAX_TYPE)\n\t\t\treturn -EINVAL;\n\n\t\tif (m_ops->slave_maxtype &&\n\t\t    linkinfo[IFLA_INFO_SLAVE_DATA]) {\n\t\t\terr = nla_parse_nested_deprecated(tbs->slave_attr,\n\t\t\t\t\t\t\t  m_ops->slave_maxtype,\n\t\t\t\t\t\t\t  linkinfo[IFLA_INFO_SLAVE_DATA],\n\t\t\t\t\t\t\t  m_ops->slave_policy,\n\t\t\t\t\t\t\t  extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tslave_data = tbs->slave_attr;\n\t\t}\n\t}\n\n\tif (dev) {\n\t\tint status = 0;\n\n\t\tif (nlh->nlmsg_flags & NLM_F_EXCL)\n\t\t\treturn -EEXIST;\n\t\tif (nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = validate_linkmsg(dev, tb, extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (linkinfo[IFLA_INFO_DATA]) {\n\t\t\tif (!ops || ops != dev->rtnl_link_ops ||\n\t\t\t    !ops->changelink)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\terr = ops->changelink(dev, tb, data, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\n\t\tif (linkinfo[IFLA_INFO_SLAVE_DATA]) {\n\t\t\tif (!m_ops || !m_ops->slave_changelink)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\terr = m_ops->slave_changelink(master_dev, dev, tb,\n\t\t\t\t\t\t      slave_data, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\n\t\treturn do_setlink(skb, dev, ifm, extack, tb, status);\n\t}\n\n\tif (!(nlh->nlmsg_flags & NLM_F_CREATE)) {\n\t\t \n\t\tif (link_specified)\n\t\t\treturn -ENODEV;\n\t\tif (tb[IFLA_GROUP])\n\t\t\treturn rtnl_group_changelink(skb, net,\n\t\t\t\t\t\tnla_get_u32(tb[IFLA_GROUP]),\n\t\t\t\t\t\tifm, extack, tb);\n\t\treturn -ENODEV;\n\t}\n\n\tif (tb[IFLA_MAP] || tb[IFLA_PROTINFO])\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ops) {\n#ifdef CONFIG_MODULES\n\t\tif (kind[0]) {\n\t\t\t__rtnl_unlock();\n\t\t\trequest_module(\"rtnl-link-%s\", kind);\n\t\t\trtnl_lock();\n\t\t\tops = rtnl_link_ops_get(kind);\n\t\t\tif (ops)\n\t\t\t\tgoto replay;\n\t\t}\n#endif\n\t\tNL_SET_ERR_MSG(extack, \"Unknown device type\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn rtnl_newlink_create(skb, ifm, ops, nlh, tb, data, extack);\n}\n\nstatic int rtnl_newlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct rtnl_newlink_tbs *tbs;\n\tint ret;\n\n\ttbs = kmalloc(sizeof(*tbs), GFP_KERNEL);\n\tif (!tbs)\n\t\treturn -ENOMEM;\n\n\tret = __rtnl_newlink(skb, nlh, tbs, extack);\n\tkfree(tbs);\n\treturn ret;\n}\n\nstatic int rtnl_valid_getlink_req(struct sk_buff *skb,\n\t\t\t\t  const struct nlmsghdr *nlh,\n\t\t\t\t  struct nlattr **tb,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ifinfomsg *ifm;\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for get link\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFLA_MAX,\n\t\t\t\t\t      ifla_policy, extack);\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->__ifi_pad || ifm->ifi_type || ifm->ifi_flags ||\n\t    ifm->ifi_change) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for get link request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*ifm), tb, IFLA_MAX,\n\t\t\t\t\t    ifla_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= IFLA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase IFLA_IFNAME:\n\t\tcase IFLA_ALT_IFNAME:\n\t\tcase IFLA_EXT_MASK:\n\t\tcase IFLA_TARGET_NETNSID:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in get link request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net *tgt_net = net;\n\tstruct ifinfomsg *ifm;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tstruct net_device *dev = NULL;\n\tstruct sk_buff *nskb;\n\tint netnsid = -1;\n\tint err;\n\tu32 ext_filter_mask = 0;\n\n\terr = rtnl_valid_getlink_req(skb, nlh, tb, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtnl_ensure_unique_netns(tb, extack, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_TARGET_NETNSID]) {\n\t\tnetnsid = nla_get_s32(tb[IFLA_TARGET_NETNSID]);\n\t\ttgt_net = rtnl_get_net_ns_capable(NETLINK_CB(skb).sk, netnsid);\n\t\tif (IS_ERR(tgt_net))\n\t\t\treturn PTR_ERR(tgt_net);\n\t}\n\n\tif (tb[IFLA_EXT_MASK])\n\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\n\terr = -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(tgt_net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])\n\t\tdev = rtnl_dev_get(tgt_net, tb);\n\telse\n\t\tgoto out;\n\n\terr = -ENODEV;\n\tif (dev == NULL)\n\t\tgoto out;\n\n\terr = -ENOBUFS;\n\tnskb = nlmsg_new(if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL);\n\tif (nskb == NULL)\n\t\tgoto out;\n\n\terr = rtnl_fill_ifinfo(nskb, dev, net,\n\t\t\t       RTM_NEWLINK, NETLINK_CB(skb).portid,\n\t\t\t       nlh->nlmsg_seq, 0, 0, ext_filter_mask,\n\t\t\t       0, NULL, 0, netnsid, GFP_KERNEL);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(nskb);\n\t} else\n\t\terr = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid);\nout:\n\tif (netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn err;\n}\n\nstatic int rtnl_alt_ifname(int cmd, struct net_device *dev, struct nlattr *attr,\n\t\t\t   bool *changed, struct netlink_ext_ack *extack)\n{\n\tchar *alt_ifname;\n\tsize_t size;\n\tint err;\n\n\terr = nla_validate(attr, attr->nla_len, IFLA_MAX, ifla_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (cmd == RTM_NEWLINKPROP) {\n\t\tsize = rtnl_prop_list_size(dev);\n\t\tsize += nla_total_size(ALTIFNAMSIZ);\n\t\tif (size >= U16_MAX) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"effective property list too long\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\talt_ifname = nla_strdup(attr, GFP_KERNEL_ACCOUNT);\n\tif (!alt_ifname)\n\t\treturn -ENOMEM;\n\n\tif (cmd == RTM_NEWLINKPROP) {\n\t\terr = netdev_name_node_alt_create(dev, alt_ifname);\n\t\tif (!err)\n\t\t\talt_ifname = NULL;\n\t} else if (cmd == RTM_DELLINKPROP) {\n\t\terr = netdev_name_node_alt_destroy(dev, alt_ifname);\n\t} else {\n\t\tWARN_ON_ONCE(1);\n\t\terr = -EINVAL;\n\t}\n\n\tkfree(alt_ifname);\n\tif (!err)\n\t\t*changed = true;\n\treturn err;\n}\n\nstatic int rtnl_linkprop(int cmd, struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[IFLA_MAX + 1];\n\tstruct net_device *dev;\n\tstruct ifinfomsg *ifm;\n\tbool changed = false;\n\tstruct nlattr *attr;\n\tint err, rem;\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = rtnl_ensure_unique_netns(tb, extack, true);\n\tif (err)\n\t\treturn err;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])\n\t\tdev = rtnl_dev_get(net, tb);\n\telse\n\t\treturn -EINVAL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!tb[IFLA_PROP_LIST])\n\t\treturn 0;\n\n\tnla_for_each_nested(attr, tb[IFLA_PROP_LIST], rem) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase IFLA_ALT_IFNAME:\n\t\t\terr = rtnl_alt_ifname(cmd, dev, attr, &changed, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (changed)\n\t\tnetdev_state_change(dev);\n\treturn 0;\n}\n\nstatic int rtnl_newlinkprop(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn rtnl_linkprop(RTM_NEWLINKPROP, skb, nlh, extack);\n}\n\nstatic int rtnl_dellinkprop(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn rtnl_linkprop(RTM_DELLINKPROP, skb, nlh, extack);\n}\n\nstatic u32 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tsize_t min_ifinfo_dump_size = 0;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\tstruct net_device *dev;\n\tint hdrlen;\n\n\t \n\thdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?\n\t\t sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);\n\n\tif (nlmsg_parse_deprecated(nlh, hdrlen, tb, IFLA_MAX, ifla_policy, NULL) >= 0) {\n\t\tif (tb[IFLA_EXT_MASK])\n\t\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\t}\n\n\tif (!ext_filter_mask)\n\t\treturn NLMSG_GOODSIZE;\n\t \n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tmin_ifinfo_dump_size = max(min_ifinfo_dump_size,\n\t\t\t\t\t   if_nlmsg_size(dev, ext_filter_mask));\n\t}\n\trcu_read_unlock();\n\n\treturn nlmsg_total_size(min_ifinfo_dump_size);\n}\n\nstatic int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx;\n\tint s_idx = cb->family;\n\tint type = cb->nlh->nlmsg_type - RTM_BASE;\n\tint ret = 0;\n\n\tif (s_idx == 0)\n\t\ts_idx = 1;\n\n\tfor (idx = 1; idx <= RTNL_FAMILY_MAX; idx++) {\n\t\tstruct rtnl_link __rcu **tab;\n\t\tstruct rtnl_link *link;\n\t\trtnl_dumpit_func dumpit;\n\n\t\tif (idx < s_idx || idx == PF_PACKET)\n\t\t\tcontinue;\n\n\t\tif (type < 0 || type >= RTM_NR_MSGTYPES)\n\t\t\tcontinue;\n\n\t\ttab = rcu_dereference_rtnl(rtnl_msg_handlers[idx]);\n\t\tif (!tab)\n\t\t\tcontinue;\n\n\t\tlink = rcu_dereference_rtnl(tab[type]);\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\tdumpit = link->dumpit;\n\t\tif (!dumpit)\n\t\t\tcontinue;\n\n\t\tif (idx > s_idx) {\n\t\t\tmemset(&cb->args[0], 0, sizeof(cb->args));\n\t\t\tcb->prev_seq = 0;\n\t\t\tcb->seq = 0;\n\t\t}\n\t\tret = dumpit(skb, cb);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tcb->family = idx;\n\n\treturn skb->len ? : ret;\n}\n\nstruct sk_buff *rtmsg_ifinfo_build_skb(int type, struct net_device *dev,\n\t\t\t\t       unsigned int change,\n\t\t\t\t       u32 event, gfp_t flags, int *new_nsid,\n\t\t\t\t       int new_ifindex, u32 portid,\n\t\t\t\t       const struct nlmsghdr *nlh)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\tu32 seq = 0;\n\n\tskb = nlmsg_new(if_nlmsg_size(dev, 0), flags);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\tif (nlmsg_report(nlh))\n\t\tseq = nlmsg_seq(nlh);\n\telse\n\t\tportid = 0;\n\n\terr = rtnl_fill_ifinfo(skb, dev, dev_net(dev),\n\t\t\t       type, portid, seq, change, 0, 0, event,\n\t\t\t       new_nsid, new_ifindex, -1, flags);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\treturn skb;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n\treturn NULL;\n}\n\nvoid rtmsg_ifinfo_send(struct sk_buff *skb, struct net_device *dev, gfp_t flags,\n\t\t       u32 portid, const struct nlmsghdr *nlh)\n{\n\tstruct net *net = dev_net(dev);\n\n\trtnl_notify(skb, net, portid, RTNLGRP_LINK, nlh, flags);\n}\n\nstatic void rtmsg_ifinfo_event(int type, struct net_device *dev,\n\t\t\t       unsigned int change, u32 event,\n\t\t\t       gfp_t flags, int *new_nsid, int new_ifindex,\n\t\t\t       u32 portid, const struct nlmsghdr *nlh)\n{\n\tstruct sk_buff *skb;\n\n\tif (dev->reg_state != NETREG_REGISTERED)\n\t\treturn;\n\n\tskb = rtmsg_ifinfo_build_skb(type, dev, change, event, flags, new_nsid,\n\t\t\t\t     new_ifindex, portid, nlh);\n\tif (skb)\n\t\trtmsg_ifinfo_send(skb, dev, flags, portid, nlh);\n}\n\nvoid rtmsg_ifinfo(int type, struct net_device *dev, unsigned int change,\n\t\t  gfp_t flags, u32 portid, const struct nlmsghdr *nlh)\n{\n\trtmsg_ifinfo_event(type, dev, change, rtnl_get_event(0), flags,\n\t\t\t   NULL, 0, portid, nlh);\n}\n\nvoid rtmsg_ifinfo_newnet(int type, struct net_device *dev, unsigned int change,\n\t\t\t gfp_t flags, int *new_nsid, int new_ifindex)\n{\n\trtmsg_ifinfo_event(type, dev, change, rtnl_get_event(0), flags,\n\t\t\t   new_nsid, new_ifindex, 0, NULL);\n}\n\nstatic int nlmsg_populate_fdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   u8 *addr, u16 vid, u32 pid, u32 seq,\n\t\t\t\t   int type, unsigned int flags,\n\t\t\t\t   int nlflags, u16 ndm_state)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *ndm;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ndm), nlflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tndm = nlmsg_data(nlh);\n\tndm->ndm_family  = AF_BRIDGE;\n\tndm->ndm_pad1\t = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags\t = flags;\n\tndm->ndm_type\t = 0;\n\tndm->ndm_ifindex = dev->ifindex;\n\tndm->ndm_state   = ndm_state;\n\n\tif (nla_put(skb, NDA_LLADDR, dev->addr_len, addr))\n\t\tgoto nla_put_failure;\n\tif (vid)\n\t\tif (nla_put(skb, NDA_VLAN, sizeof(u16), &vid))\n\t\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t rtnl_fdb_nlmsg_size(const struct net_device *dev)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ndmsg)) +\n\t       nla_total_size(dev->addr_len) +\t \n\t       nla_total_size(sizeof(u16)) +\t \n\t       0;\n}\n\nstatic void rtnl_fdb_notify(struct net_device *dev, u8 *addr, u16 vid, int type,\n\t\t\t    u16 ndm_state)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(rtnl_fdb_nlmsg_size(dev), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nlmsg_populate_fdb_fill(skb, dev, addr, vid,\n\t\t\t\t      0, 0, type, NTF_SELF, 0, ndm_state);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_NEIGH, err);\n}\n\n \nint ndo_dflt_fdb_add(struct ndmsg *ndm,\n\t\t     struct nlattr *tb[],\n\t\t     struct net_device *dev,\n\t\t     const unsigned char *addr, u16 vid,\n\t\t     u16 flags)\n{\n\tint err = -EINVAL;\n\n\t \n\tif (ndm->ndm_state && !(ndm->ndm_state & NUD_PERMANENT)) {\n\t\tnetdev_info(dev, \"default FDB implementation only supports local addresses\\n\");\n\t\treturn err;\n\t}\n\n\tif (tb[NDA_FLAGS_EXT]) {\n\t\tnetdev_info(dev, \"invalid flags given to default FDB implementation\\n\");\n\t\treturn err;\n\t}\n\n\tif (vid) {\n\t\tnetdev_info(dev, \"vlans aren't supported yet for dev_uc|mc_add()\\n\");\n\t\treturn err;\n\t}\n\n\tif (is_unicast_ether_addr(addr) || is_link_local_ether_addr(addr))\n\t\terr = dev_uc_add_excl(dev, addr);\n\telse if (is_multicast_ether_addr(addr))\n\t\terr = dev_mc_add_excl(dev, addr);\n\n\t \n\tif (err == -EEXIST && !(flags & NLM_F_EXCL))\n\t\terr = 0;\n\n\treturn err;\n}\nEXPORT_SYMBOL(ndo_dflt_fdb_add);\n\nstatic int fdb_vid_parse(struct nlattr *vlan_attr, u16 *p_vid,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tu16 vid = 0;\n\n\tif (vlan_attr) {\n\t\tif (nla_len(vlan_attr) != sizeof(u16)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"invalid vlan attribute size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvid = nla_get_u16(vlan_attr);\n\n\t\tif (!vid || vid >= VLAN_VID_MASK) {\n\t\t\tNL_SET_ERR_MSG(extack, \"invalid vlan id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t*p_vid = vid;\n\treturn 0;\n}\n\nstatic int rtnl_fdb_add(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ndmsg *ndm;\n\tstruct nlattr *tb[NDA_MAX+1];\n\tstruct net_device *dev;\n\tu8 *addr;\n\tu16 vid;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ndm), tb, NDA_MAX, NULL,\n\t\t\t\t     extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_ifindex == 0) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid ifindex\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\tif (dev == NULL) {\n\t\tNL_SET_ERR_MSG(extack, \"unknown ifindex\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!tb[NDA_LLADDR] || nla_len(tb[NDA_LLADDR]) != ETH_ALEN) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid address\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->type != ARPHRD_ETHER) {\n\t\tNL_SET_ERR_MSG(extack, \"FDB add only supported for Ethernet devices\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = nla_data(tb[NDA_LLADDR]);\n\n\terr = fdb_vid_parse(tb[NDA_VLAN], &vid, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\n\t \n\tif ((!ndm->ndm_flags || ndm->ndm_flags & NTF_MASTER) &&\n\t    netif_is_bridge_port(dev)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\t\tconst struct net_device_ops *ops = br_dev->netdev_ops;\n\n\t\terr = ops->ndo_fdb_add(ndm, tb, dev, addr, vid,\n\t\t\t\t       nlh->nlmsg_flags, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t\telse\n\t\t\tndm->ndm_flags &= ~NTF_MASTER;\n\t}\n\n\t \n\tif ((ndm->ndm_flags & NTF_SELF)) {\n\t\tif (dev->netdev_ops->ndo_fdb_add)\n\t\t\terr = dev->netdev_ops->ndo_fdb_add(ndm, tb, dev, addr,\n\t\t\t\t\t\t\t   vid,\n\t\t\t\t\t\t\t   nlh->nlmsg_flags,\n\t\t\t\t\t\t\t   extack);\n\t\telse\n\t\t\terr = ndo_dflt_fdb_add(ndm, tb, dev, addr, vid,\n\t\t\t\t\t       nlh->nlmsg_flags);\n\n\t\tif (!err) {\n\t\t\trtnl_fdb_notify(dev, addr, vid, RTM_NEWNEIGH,\n\t\t\t\t\tndm->ndm_state);\n\t\t\tndm->ndm_flags &= ~NTF_SELF;\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\n \nint ndo_dflt_fdb_del(struct ndmsg *ndm,\n\t\t     struct nlattr *tb[],\n\t\t     struct net_device *dev,\n\t\t     const unsigned char *addr, u16 vid)\n{\n\tint err = -EINVAL;\n\n\t \n\tif (!(ndm->ndm_state & NUD_PERMANENT)) {\n\t\tnetdev_info(dev, \"default FDB implementation only supports local addresses\\n\");\n\t\treturn err;\n\t}\n\n\tif (is_unicast_ether_addr(addr) || is_link_local_ether_addr(addr))\n\t\terr = dev_uc_del(dev, addr);\n\telse if (is_multicast_ether_addr(addr))\n\t\terr = dev_mc_del(dev, addr);\n\n\treturn err;\n}\nEXPORT_SYMBOL(ndo_dflt_fdb_del);\n\nstatic const struct nla_policy fdb_del_bulk_policy[NDA_MAX + 1] = {\n\t[NDA_VLAN]\t= { .type = NLA_U16 },\n\t[NDA_IFINDEX]\t= NLA_POLICY_MIN(NLA_S32, 1),\n\t[NDA_NDM_STATE_MASK]\t= { .type = NLA_U16  },\n\t[NDA_NDM_FLAGS_MASK]\t= { .type = NLA_U8 },\n};\n\nstatic int rtnl_fdb_del(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbool del_bulk = !!(nlh->nlmsg_flags & NLM_F_BULK);\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct net_device_ops *ops;\n\tstruct ndmsg *ndm;\n\tstruct nlattr *tb[NDA_MAX+1];\n\tstruct net_device *dev;\n\t__u8 *addr = NULL;\n\tint err;\n\tu16 vid;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!del_bulk) {\n\t\terr = nlmsg_parse_deprecated(nlh, sizeof(*ndm), tb, NDA_MAX,\n\t\t\t\t\t     NULL, extack);\n\t} else {\n\t\terr = nlmsg_parse(nlh, sizeof(*ndm), tb, NDA_MAX,\n\t\t\t\t  fdb_del_bulk_policy, extack);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_ifindex == 0) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid ifindex\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\tif (dev == NULL) {\n\t\tNL_SET_ERR_MSG(extack, \"unknown ifindex\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!del_bulk) {\n\t\tif (!tb[NDA_LLADDR] || nla_len(tb[NDA_LLADDR]) != ETH_ALEN) {\n\t\t\tNL_SET_ERR_MSG(extack, \"invalid address\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taddr = nla_data(tb[NDA_LLADDR]);\n\t}\n\n\tif (dev->type != ARPHRD_ETHER) {\n\t\tNL_SET_ERR_MSG(extack, \"FDB delete only supported for Ethernet devices\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = fdb_vid_parse(tb[NDA_VLAN], &vid, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\n\t \n\tif ((!ndm->ndm_flags || ndm->ndm_flags & NTF_MASTER) &&\n\t    netif_is_bridge_port(dev)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tops = br_dev->netdev_ops;\n\t\tif (!del_bulk) {\n\t\t\tif (ops->ndo_fdb_del)\n\t\t\t\terr = ops->ndo_fdb_del(ndm, tb, dev, addr, vid, extack);\n\t\t} else {\n\t\t\tif (ops->ndo_fdb_del_bulk)\n\t\t\t\terr = ops->ndo_fdb_del_bulk(ndm, tb, dev, vid,\n\t\t\t\t\t\t\t    extack);\n\t\t}\n\n\t\tif (err)\n\t\t\tgoto out;\n\t\telse\n\t\t\tndm->ndm_flags &= ~NTF_MASTER;\n\t}\n\n\t \n\tif (ndm->ndm_flags & NTF_SELF) {\n\t\tops = dev->netdev_ops;\n\t\tif (!del_bulk) {\n\t\t\tif (ops->ndo_fdb_del)\n\t\t\t\terr = ops->ndo_fdb_del(ndm, tb, dev, addr, vid, extack);\n\t\t\telse\n\t\t\t\terr = ndo_dflt_fdb_del(ndm, tb, dev, addr, vid);\n\t\t} else {\n\t\t\t \n\t\t\terr = -EOPNOTSUPP;\n\t\t\tif (ops->ndo_fdb_del_bulk)\n\t\t\t\terr = ops->ndo_fdb_del_bulk(ndm, tb, dev, vid,\n\t\t\t\t\t\t\t    extack);\n\t\t}\n\n\t\tif (!err) {\n\t\t\tif (!del_bulk)\n\t\t\t\trtnl_fdb_notify(dev, addr, vid, RTM_DELNEIGH,\n\t\t\t\t\t\tndm->ndm_state);\n\t\t\tndm->ndm_flags &= ~NTF_SELF;\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\nstatic int nlmsg_populate_fdb(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb,\n\t\t\t      struct net_device *dev,\n\t\t\t      int *idx,\n\t\t\t      struct netdev_hw_addr_list *list)\n{\n\tstruct netdev_hw_addr *ha;\n\tint err;\n\tu32 portid, seq;\n\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq = cb->nlh->nlmsg_seq;\n\n\tlist_for_each_entry(ha, &list->list, list) {\n\t\tif (*idx < cb->args[2])\n\t\t\tgoto skip;\n\n\t\terr = nlmsg_populate_fdb_fill(skb, dev, ha->addr, 0,\n\t\t\t\t\t      portid, seq,\n\t\t\t\t\t      RTM_NEWNEIGH, NTF_SELF,\n\t\t\t\t\t      NLM_F_MULTI, NUD_PERMANENT);\n\t\tif (err < 0)\n\t\t\treturn err;\nskip:\n\t\t*idx += 1;\n\t}\n\treturn 0;\n}\n\n \nint ndo_dflt_fdb_dump(struct sk_buff *skb,\n\t\t      struct netlink_callback *cb,\n\t\t      struct net_device *dev,\n\t\t      struct net_device *filter_dev,\n\t\t      int *idx)\n{\n\tint err;\n\n\tif (dev->type != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\tnetif_addr_lock_bh(dev);\n\terr = nlmsg_populate_fdb(skb, cb, dev, idx, &dev->uc);\n\tif (err)\n\t\tgoto out;\n\terr = nlmsg_populate_fdb(skb, cb, dev, idx, &dev->mc);\nout:\n\tnetif_addr_unlock_bh(dev);\n\treturn err;\n}\nEXPORT_SYMBOL(ndo_dflt_fdb_dump);\n\nstatic int valid_fdb_dump_strict(const struct nlmsghdr *nlh,\n\t\t\t\t int *br_idx, int *brport_idx,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[NDA_MAX + 1];\n\tstruct ndmsg *ndm;\n\tint err, i;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for fdb dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_pad1  || ndm->ndm_pad2  || ndm->ndm_state ||\n\t    ndm->ndm_flags || ndm->ndm_type) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for fdb dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct ndmsg), tb,\n\t\t\t\t\t    NDA_MAX, NULL, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\t*brport_idx = ndm->ndm_ifindex;\n\tfor (i = 0; i <= NDA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NDA_IFINDEX:\n\t\t\tif (nla_len(tb[i]) != sizeof(u32)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid IFINDEX attribute in fdb dump request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*brport_idx = nla_get_u32(tb[NDA_IFINDEX]);\n\t\t\tbreak;\n\t\tcase NDA_MASTER:\n\t\t\tif (nla_len(tb[i]) != sizeof(u32)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid MASTER attribute in fdb dump request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*br_idx = nla_get_u32(tb[NDA_MASTER]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in fdb dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int valid_fdb_dump_legacy(const struct nlmsghdr *nlh,\n\t\t\t\t int *br_idx, int *brport_idx,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tint err;\n\n\t \n\tif (nlmsg_len(nlh) != sizeof(struct ndmsg) &&\n\t    (nlmsg_len(nlh) != sizeof(struct ndmsg) +\n\t     nla_attr_size(sizeof(u32)))) {\n\t\tstruct ifinfomsg *ifm;\n\n\t\terr = nlmsg_parse_deprecated(nlh, sizeof(struct ifinfomsg),\n\t\t\t\t\t     tb, IFLA_MAX, ifla_policy,\n\t\t\t\t\t     extack);\n\t\tif (err < 0) {\n\t\t\treturn -EINVAL;\n\t\t} else if (err == 0) {\n\t\t\tif (tb[IFLA_MASTER])\n\t\t\t\t*br_idx = nla_get_u32(tb[IFLA_MASTER]);\n\t\t}\n\n\t\tifm = nlmsg_data(nlh);\n\t\t*brport_idx = ifm->ifi_index;\n\t}\n\treturn 0;\n}\n\nstatic int rtnl_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net_device *br_dev = NULL;\n\tconst struct net_device_ops *ops = NULL;\n\tconst struct net_device_ops *cops = NULL;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct hlist_head *head;\n\tint brport_idx = 0;\n\tint br_idx = 0;\n\tint h, s_h;\n\tint idx = 0, s_idx;\n\tint err = 0;\n\tint fidx = 0;\n\n\tif (cb->strict_check)\n\t\terr = valid_fdb_dump_strict(cb->nlh, &br_idx, &brport_idx,\n\t\t\t\t\t    cb->extack);\n\telse\n\t\terr = valid_fdb_dump_legacy(cb->nlh, &br_idx, &brport_idx,\n\t\t\t\t\t    cb->extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (br_idx) {\n\t\tbr_dev = __dev_get_by_index(net, br_idx);\n\t\tif (!br_dev)\n\t\t\treturn -ENODEV;\n\n\t\tops = br_dev->netdev_ops;\n\t}\n\n\ts_h = cb->args[0];\n\ts_idx = cb->args[1];\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\thlist_for_each_entry(dev, head, index_hlist) {\n\n\t\t\tif (brport_idx && (dev->ifindex != brport_idx))\n\t\t\t\tcontinue;\n\n\t\t\tif (!br_idx) {  \n\t\t\t\tif (netif_is_bridge_port(dev)) {\n\t\t\t\t\tbr_dev = netdev_master_upper_dev_get(dev);\n\t\t\t\t\tcops = br_dev->netdev_ops;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dev != br_dev &&\n\t\t\t\t    !netif_is_bridge_port(dev))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (br_dev != netdev_master_upper_dev_get(dev) &&\n\t\t\t\t    !netif_is_bridge_master(dev))\n\t\t\t\t\tcontinue;\n\t\t\t\tcops = ops;\n\t\t\t}\n\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\n\t\t\tif (netif_is_bridge_port(dev)) {\n\t\t\t\tif (cops && cops->ndo_fdb_dump) {\n\t\t\t\t\terr = cops->ndo_fdb_dump(skb, cb,\n\t\t\t\t\t\t\t\tbr_dev, dev,\n\t\t\t\t\t\t\t\t&fidx);\n\t\t\t\t\tif (err == -EMSGSIZE)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dev->netdev_ops->ndo_fdb_dump)\n\t\t\t\terr = dev->netdev_ops->ndo_fdb_dump(skb, cb,\n\t\t\t\t\t\t\t\t    dev, NULL,\n\t\t\t\t\t\t\t\t    &fidx);\n\t\t\telse\n\t\t\t\terr = ndo_dflt_fdb_dump(skb, cb, dev, NULL,\n\t\t\t\t\t\t\t&fidx);\n\t\t\tif (err == -EMSGSIZE)\n\t\t\t\tgoto out;\n\n\t\t\tcops = NULL;\n\n\t\t\t \n\t\t\tcb->args[2] = 0;\n\t\t\tfidx = 0;\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\n\tcb->args[2] = fidx;\n\n\treturn skb->len;\n}\n\nstatic int valid_fdb_get_strict(const struct nlmsghdr *nlh,\n\t\t\t\tstruct nlattr **tb, u8 *ndm_flags,\n\t\t\t\tint *br_idx, int *brport_idx, u8 **addr,\n\t\t\t\tu16 *vid, struct netlink_ext_ack *extack)\n{\n\tstruct ndmsg *ndm;\n\tint err, i;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for fdb get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_pad1  || ndm->ndm_pad2  || ndm->ndm_state ||\n\t    ndm->ndm_type) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for fdb get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ndm->ndm_flags & ~(NTF_MASTER | NTF_SELF)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid flags in header for fdb get request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct ndmsg), tb,\n\t\t\t\t\t    NDA_MAX, nda_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ndm_flags = ndm->ndm_flags;\n\t*brport_idx = ndm->ndm_ifindex;\n\tfor (i = 0; i <= NDA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NDA_MASTER:\n\t\t\t*br_idx = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tcase NDA_LLADDR:\n\t\t\tif (nla_len(tb[i]) != ETH_ALEN) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid address in fdb get request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*addr = nla_data(tb[i]);\n\t\t\tbreak;\n\t\tcase NDA_VLAN:\n\t\t\terr = fdb_vid_parse(tb[i], vid, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase NDA_VNI:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in fdb get request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_fdb_get(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = NULL, *br_dev = NULL;\n\tconst struct net_device_ops *ops = NULL;\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NDA_MAX + 1];\n\tstruct sk_buff *skb;\n\tint brport_idx = 0;\n\tu8 ndm_flags = 0;\n\tint br_idx = 0;\n\tu8 *addr = NULL;\n\tu16 vid = 0;\n\tint err;\n\n\terr = valid_fdb_get_strict(nlh, tb, &ndm_flags, &br_idx,\n\t\t\t\t   &brport_idx, &addr, &vid, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!addr) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing lookup address for fdb get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (brport_idx) {\n\t\tdev = __dev_get_by_index(net, brport_idx);\n\t\tif (!dev) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Unknown device ifindex\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (br_idx) {\n\t\tif (dev) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Master and device are mutually exclusive\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbr_dev = __dev_get_by_index(net, br_idx);\n\t\tif (!br_dev) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid master ifindex\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tops = br_dev->netdev_ops;\n\t}\n\n\tif (dev) {\n\t\tif (!ndm_flags || (ndm_flags & NTF_MASTER)) {\n\t\t\tif (!netif_is_bridge_port(dev)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Device is not a bridge port\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbr_dev = netdev_master_upper_dev_get(dev);\n\t\t\tif (!br_dev) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Master of device not found\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tops = br_dev->netdev_ops;\n\t\t} else {\n\t\t\tif (!(ndm_flags & NTF_SELF)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Missing NTF_SELF\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tops = dev->netdev_ops;\n\t\t}\n\t}\n\n\tif (!br_dev && !dev) {\n\t\tNL_SET_ERR_MSG(extack, \"No device specified\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!ops || !ops->ndo_fdb_get) {\n\t\tNL_SET_ERR_MSG(extack, \"Fdb get operation not supported by device\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (br_dev)\n\t\tdev = br_dev;\n\terr = ops->ndo_fdb_get(skb, tb, dev, addr, vid,\n\t\t\t       NETLINK_CB(in_skb).portid,\n\t\t\t       nlh->nlmsg_seq, extack);\n\tif (err)\n\t\tgoto out;\n\n\treturn rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nout:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int brport_nla_put_flag(struct sk_buff *skb, u32 flags, u32 mask,\n\t\t\t       unsigned int attrnum, unsigned int flag)\n{\n\tif (mask & flag)\n\t\treturn nla_put_u8(skb, attrnum, !!(flags & flag));\n\treturn 0;\n}\n\nint ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t    struct net_device *dev, u16 mode,\n\t\t\t    u32 flags, u32 mask, int nlflags,\n\t\t\t    u32 filter_mask,\n\t\t\t    int (*vlan_fill)(struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     u32 filter_mask))\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ifinfomsg *ifm;\n\tstruct nlattr *br_afspec;\n\tstruct nlattr *protinfo;\n\tu8 operstate = netif_running(dev) ? dev->operstate : IF_OPER_DOWN;\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, pid, seq, RTM_NEWLINK, sizeof(*ifm), nlflags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifi_family = AF_BRIDGE;\n\tifm->__ifi_pad = 0;\n\tifm->ifi_type = dev->type;\n\tifm->ifi_index = dev->ifindex;\n\tifm->ifi_flags = dev_get_flags(dev);\n\tifm->ifi_change = 0;\n\n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE, operstate) ||\n\t    (br_dev &&\n\t     nla_put_u32(skb, IFLA_MASTER, br_dev->ifindex)) ||\n\t    (dev->addr_len &&\n\t     nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||\n\t    (dev->ifindex != dev_get_iflink(dev) &&\n\t     nla_put_u32(skb, IFLA_LINK, dev_get_iflink(dev))))\n\t\tgoto nla_put_failure;\n\n\tbr_afspec = nla_nest_start_noflag(skb, IFLA_AF_SPEC);\n\tif (!br_afspec)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, IFLA_BRIDGE_FLAGS, BRIDGE_FLAGS_SELF)) {\n\t\tnla_nest_cancel(skb, br_afspec);\n\t\tgoto nla_put_failure;\n\t}\n\n\tif (mode != BRIDGE_MODE_UNDEF) {\n\t\tif (nla_put_u16(skb, IFLA_BRIDGE_MODE, mode)) {\n\t\t\tnla_nest_cancel(skb, br_afspec);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\tif (vlan_fill) {\n\t\terr = vlan_fill(skb, dev, filter_mask);\n\t\tif (err) {\n\t\t\tnla_nest_cancel(skb, br_afspec);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\tnla_nest_end(skb, br_afspec);\n\n\tprotinfo = nla_nest_start(skb, IFLA_PROTINFO);\n\tif (!protinfo)\n\t\tgoto nla_put_failure;\n\n\tif (brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_MODE, BR_HAIRPIN_MODE) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_GUARD, BR_BPDU_GUARD) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_FAST_LEAVE,\n\t\t\t\tBR_MULTICAST_FAST_LEAVE) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_PROTECT, BR_ROOT_BLOCK) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_LEARNING, BR_LEARNING) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_LEARNING_SYNC, BR_LEARNING_SYNC) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_UNICAST_FLOOD, BR_FLOOD) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_PROXYARP, BR_PROXYARP) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_MCAST_FLOOD, BR_MCAST_FLOOD) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_BCAST_FLOOD, BR_BCAST_FLOOD)) {\n\t\tnla_nest_cancel(skb, protinfo);\n\t\tgoto nla_put_failure;\n\t}\n\n\tnla_nest_end(skb, protinfo);\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn err ? err : -EMSGSIZE;\n}\nEXPORT_SYMBOL_GPL(ndo_dflt_bridge_getlink);\n\nstatic int valid_bridge_getlink_req(const struct nlmsghdr *nlh,\n\t\t\t\t    bool strict_check, u32 *filter_mask,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tint err, i;\n\n\tif (strict_check) {\n\t\tstruct ifinfomsg *ifm;\n\n\t\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid header for bridge link dump\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tifm = nlmsg_data(nlh);\n\t\tif (ifm->__ifi_pad || ifm->ifi_type || ifm->ifi_flags ||\n\t\t    ifm->ifi_change || ifm->ifi_index) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for bridge link dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = nlmsg_parse_deprecated_strict(nlh,\n\t\t\t\t\t\t    sizeof(struct ifinfomsg),\n\t\t\t\t\t\t    tb, IFLA_MAX, ifla_policy,\n\t\t\t\t\t\t    extack);\n\t} else {\n\t\terr = nlmsg_parse_deprecated(nlh, sizeof(struct ifinfomsg),\n\t\t\t\t\t     tb, IFLA_MAX, ifla_policy,\n\t\t\t\t\t     extack);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i <= IFLA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase IFLA_EXT_MASK:\n\t\t\t*filter_mask = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (strict_check) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in bridge link dump request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_bridge_getlink(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tint idx = 0;\n\tu32 portid = NETLINK_CB(cb->skb).portid;\n\tu32 seq = nlh->nlmsg_seq;\n\tu32 filter_mask = 0;\n\tint err;\n\n\terr = valid_bridge_getlink_req(nlh, cb->strict_check, &filter_mask,\n\t\t\t\t       cb->extack);\n\tif (err < 0 && cb->strict_check)\n\t\treturn err;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tconst struct net_device_ops *ops = dev->netdev_ops;\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (br_dev && br_dev->netdev_ops->ndo_bridge_getlink) {\n\t\t\tif (idx >= cb->args[0]) {\n\t\t\t\terr = br_dev->netdev_ops->ndo_bridge_getlink(\n\t\t\t\t\t\tskb, portid, seq, dev,\n\t\t\t\t\t\tfilter_mask, NLM_F_MULTI);\n\t\t\t\tif (err < 0 && err != -EOPNOTSUPP) {\n\t\t\t\t\tif (likely(skb->len))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\n\t\tif (ops->ndo_bridge_getlink) {\n\t\t\tif (idx >= cb->args[0]) {\n\t\t\t\terr = ops->ndo_bridge_getlink(skb, portid,\n\t\t\t\t\t\t\t      seq, dev,\n\t\t\t\t\t\t\t      filter_mask,\n\t\t\t\t\t\t\t      NLM_F_MULTI);\n\t\t\t\tif (err < 0 && err != -EOPNOTSUPP) {\n\t\t\t\t\tif (likely(skb->len))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\terr = skb->len;\nout_err:\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\n\treturn err;\n}\n\nstatic inline size_t bridge_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t\t+ nla_total_size(IFNAMSIZ)\t \n\t\t+ nla_total_size(MAX_ADDR_LEN)\t \n\t\t+ nla_total_size(sizeof(u32))\t \n\t\t+ nla_total_size(sizeof(u32))\t \n\t\t+ nla_total_size(sizeof(u32))\t \n\t\t+ nla_total_size(sizeof(u32))\t \n\t\t+ nla_total_size(sizeof(u8))\t \n\t\t+ nla_total_size(sizeof(struct nlattr))\t \n\t\t+ nla_total_size(sizeof(u16))\t \n\t\t+ nla_total_size(sizeof(u16));\t \n}\n\nstatic int rtnl_bridge_notify(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -EOPNOTSUPP;\n\n\tif (!dev->netdev_ops->ndo_bridge_getlink)\n\t\treturn 0;\n\n\tskb = nlmsg_new(bridge_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\terr = dev->netdev_ops->ndo_bridge_getlink(skb, 0, 0, dev, 0, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\n\t \n\tif (!skb->len)\n\t\tgoto errout;\n\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\n\treturn 0;\nerrout:\n\tWARN_ON(err == -EMSGSIZE);\n\tkfree_skb(skb);\n\tif (err)\n\t\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n\treturn err;\n}\n\nstatic int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 flags = 0;\n\tbool have_flags = false;\n\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"unknown ifindex\");\n\t\treturn -ENODEV;\n\t}\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS && !have_flags) {\n\t\t\t\tif (nla_len(attr) < sizeof(flags))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t}\n\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_MODE) {\n\t\t\t\tif (nla_len(attr) < sizeof(u16))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_setlink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = br_dev->netdev_ops->ndo_bridge_setlink(dev, nlh, flags,\n\t\t\t\t\t\t\t     extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_setlink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_setlink(dev, nlh,\n\t\t\t\t\t\t\t\t  flags,\n\t\t\t\t\t\t\t\t  extack);\n\t\tif (!err) {\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\n\t\t\t \n\t\t\terr = rtnl_bridge_notify(dev);\n\t\t}\n\t}\n\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\nout:\n\treturn err;\n}\n\nstatic int rtnl_bridge_dellink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 flags = 0;\n\tbool have_flags = false;\n\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"unknown ifindex\");\n\t\treturn -ENODEV;\n\t}\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS) {\n\t\t\t\tif (nla_len(attr) < sizeof(flags))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_dellink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = br_dev->netdev_ops->ndo_bridge_dellink(dev, nlh, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_dellink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_dellink(dev, nlh,\n\t\t\t\t\t\t\t\t  flags);\n\n\t\tif (!err) {\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\n\t\t\t \n\t\t\terr = rtnl_bridge_notify(dev);\n\t\t}\n\t}\n\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\nout:\n\treturn err;\n}\n\nstatic bool stats_attr_valid(unsigned int mask, int attrid, int idxattr)\n{\n\treturn (mask & IFLA_STATS_FILTER_BIT(attrid)) &&\n\t       (!idxattr || idxattr == attrid);\n}\n\nstatic bool\nrtnl_offload_xstats_have_ndo(const struct net_device *dev, int attr_id)\n{\n\treturn dev->netdev_ops &&\n\t       dev->netdev_ops->ndo_has_offload_stats &&\n\t       dev->netdev_ops->ndo_get_offload_stats &&\n\t       dev->netdev_ops->ndo_has_offload_stats(dev, attr_id);\n}\n\nstatic unsigned int\nrtnl_offload_xstats_get_size_ndo(const struct net_device *dev, int attr_id)\n{\n\treturn rtnl_offload_xstats_have_ndo(dev, attr_id) ?\n\t       sizeof(struct rtnl_link_stats64) : 0;\n}\n\nstatic int\nrtnl_offload_xstats_fill_ndo(struct net_device *dev, int attr_id,\n\t\t\t     struct sk_buff *skb)\n{\n\tunsigned int size = rtnl_offload_xstats_get_size_ndo(dev, attr_id);\n\tstruct nlattr *attr = NULL;\n\tvoid *attr_data;\n\tint err;\n\n\tif (!size)\n\t\treturn -ENODATA;\n\n\tattr = nla_reserve_64bit(skb, attr_id, size,\n\t\t\t\t IFLA_OFFLOAD_XSTATS_UNSPEC);\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tattr_data = nla_data(attr);\n\tmemset(attr_data, 0, size);\n\n\terr = dev->netdev_ops->ndo_get_offload_stats(attr_id, dev, attr_data);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic unsigned int\nrtnl_offload_xstats_get_size_stats(const struct net_device *dev,\n\t\t\t\t   enum netdev_offload_xstats_type type)\n{\n\tbool enabled = netdev_offload_xstats_enabled(dev, type);\n\n\treturn enabled ? sizeof(struct rtnl_hw_stats64) : 0;\n}\n\nstruct rtnl_offload_xstats_request_used {\n\tbool request;\n\tbool used;\n};\n\nstatic int\nrtnl_offload_xstats_get_stats(struct net_device *dev,\n\t\t\t      enum netdev_offload_xstats_type type,\n\t\t\t      struct rtnl_offload_xstats_request_used *ru,\n\t\t\t      struct rtnl_hw_stats64 *stats,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tbool request;\n\tbool used;\n\tint err;\n\n\trequest = netdev_offload_xstats_enabled(dev, type);\n\tif (!request) {\n\t\tused = false;\n\t\tgoto out;\n\t}\n\n\terr = netdev_offload_xstats_get(dev, type, stats, &used, extack);\n\tif (err)\n\t\treturn err;\n\nout:\n\tif (ru) {\n\t\tru->request = request;\n\t\tru->used = used;\n\t}\n\treturn 0;\n}\n\nstatic int\nrtnl_offload_xstats_fill_hw_s_info_one(struct sk_buff *skb, int attr_id,\n\t\t\t\t       struct rtnl_offload_xstats_request_used *ru)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start(skb, attr_id);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(skb, IFLA_OFFLOAD_XSTATS_HW_S_INFO_REQUEST, ru->request))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_OFFLOAD_XSTATS_HW_S_INFO_USED, ru->used))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nrtnl_offload_xstats_fill_hw_s_info(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tenum netdev_offload_xstats_type t_l3 = NETDEV_OFFLOAD_XSTATS_TYPE_L3;\n\tstruct rtnl_offload_xstats_request_used ru_l3;\n\tstruct nlattr *nest;\n\tint err;\n\n\terr = rtnl_offload_xstats_get_stats(dev, t_l3, &ru_l3, NULL, extack);\n\tif (err)\n\t\treturn err;\n\n\tnest = nla_nest_start(skb, IFLA_OFFLOAD_XSTATS_HW_S_INFO);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (rtnl_offload_xstats_fill_hw_s_info_one(skb,\n\t\t\t\t\t\t   IFLA_OFFLOAD_XSTATS_L3_STATS,\n\t\t\t\t\t\t   &ru_l3))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int rtnl_offload_xstats_fill(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t    int *prividx, u32 off_filter_mask,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tenum netdev_offload_xstats_type t_l3 = NETDEV_OFFLOAD_XSTATS_TYPE_L3;\n\tint attr_id_hw_s_info = IFLA_OFFLOAD_XSTATS_HW_S_INFO;\n\tint attr_id_l3_stats = IFLA_OFFLOAD_XSTATS_L3_STATS;\n\tint attr_id_cpu_hit = IFLA_OFFLOAD_XSTATS_CPU_HIT;\n\tbool have_data = false;\n\tint err;\n\n\tif (*prividx <= attr_id_cpu_hit &&\n\t    (off_filter_mask &\n\t     IFLA_STATS_FILTER_BIT(attr_id_cpu_hit))) {\n\t\terr = rtnl_offload_xstats_fill_ndo(dev, attr_id_cpu_hit, skb);\n\t\tif (!err) {\n\t\t\thave_data = true;\n\t\t} else if (err != -ENODATA) {\n\t\t\t*prividx = attr_id_cpu_hit;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (*prividx <= attr_id_hw_s_info &&\n\t    (off_filter_mask & IFLA_STATS_FILTER_BIT(attr_id_hw_s_info))) {\n\t\t*prividx = attr_id_hw_s_info;\n\n\t\terr = rtnl_offload_xstats_fill_hw_s_info(skb, dev, extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\thave_data = true;\n\t\t*prividx = 0;\n\t}\n\n\tif (*prividx <= attr_id_l3_stats &&\n\t    (off_filter_mask & IFLA_STATS_FILTER_BIT(attr_id_l3_stats))) {\n\t\tunsigned int size_l3;\n\t\tstruct nlattr *attr;\n\n\t\t*prividx = attr_id_l3_stats;\n\n\t\tsize_l3 = rtnl_offload_xstats_get_size_stats(dev, t_l3);\n\t\tif (!size_l3)\n\t\t\tgoto skip_l3_stats;\n\t\tattr = nla_reserve_64bit(skb, attr_id_l3_stats, size_l3,\n\t\t\t\t\t IFLA_OFFLOAD_XSTATS_UNSPEC);\n\t\tif (!attr)\n\t\t\treturn -EMSGSIZE;\n\n\t\terr = rtnl_offload_xstats_get_stats(dev, t_l3, NULL,\n\t\t\t\t\t\t    nla_data(attr), extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\thave_data = true;\nskip_l3_stats:\n\t\t*prividx = 0;\n\t}\n\n\tif (!have_data)\n\t\treturn -ENODATA;\n\n\t*prividx = 0;\n\treturn 0;\n}\n\nstatic unsigned int\nrtnl_offload_xstats_get_size_hw_s_info_one(const struct net_device *dev,\n\t\t\t\t\t   enum netdev_offload_xstats_type type)\n{\n\treturn nla_total_size(0) +\n\t\t \n\t\tnla_total_size(sizeof(u8)) +\n\t\t \n\t\tnla_total_size(sizeof(u8)) +\n\t\t0;\n}\n\nstatic unsigned int\nrtnl_offload_xstats_get_size_hw_s_info(const struct net_device *dev)\n{\n\tenum netdev_offload_xstats_type t_l3 = NETDEV_OFFLOAD_XSTATS_TYPE_L3;\n\n\treturn nla_total_size(0) +\n\t\t \n\t\trtnl_offload_xstats_get_size_hw_s_info_one(dev, t_l3) +\n\t\t0;\n}\n\nstatic int rtnl_offload_xstats_get_size(const struct net_device *dev,\n\t\t\t\t\tu32 off_filter_mask)\n{\n\tenum netdev_offload_xstats_type t_l3 = NETDEV_OFFLOAD_XSTATS_TYPE_L3;\n\tint attr_id_cpu_hit = IFLA_OFFLOAD_XSTATS_CPU_HIT;\n\tint nla_size = 0;\n\tint size;\n\n\tif (off_filter_mask &\n\t    IFLA_STATS_FILTER_BIT(attr_id_cpu_hit)) {\n\t\tsize = rtnl_offload_xstats_get_size_ndo(dev, attr_id_cpu_hit);\n\t\tnla_size += nla_total_size_64bit(size);\n\t}\n\n\tif (off_filter_mask &\n\t    IFLA_STATS_FILTER_BIT(IFLA_OFFLOAD_XSTATS_HW_S_INFO))\n\t\tnla_size += rtnl_offload_xstats_get_size_hw_s_info(dev);\n\n\tif (off_filter_mask &\n\t    IFLA_STATS_FILTER_BIT(IFLA_OFFLOAD_XSTATS_L3_STATS)) {\n\t\tsize = rtnl_offload_xstats_get_size_stats(dev, t_l3);\n\t\tnla_size += nla_total_size_64bit(size);\n\t}\n\n\tif (nla_size != 0)\n\t\tnla_size += nla_total_size(0);\n\n\treturn nla_size;\n}\n\nstruct rtnl_stats_dump_filters {\n\t \n\tu32 mask[IFLA_STATS_MAX + 1];\n};\n\nstatic int rtnl_fill_statsinfo(struct sk_buff *skb, struct net_device *dev,\n\t\t\t       int type, u32 pid, u32 seq, u32 change,\n\t\t\t       unsigned int flags,\n\t\t\t       const struct rtnl_stats_dump_filters *filters,\n\t\t\t       int *idxattr, int *prividx,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tunsigned int filter_mask = filters->mask[0];\n\tstruct if_stats_msg *ifsm;\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *attr;\n\tint s_prividx = *prividx;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ifsm), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tifsm = nlmsg_data(nlh);\n\tifsm->family = PF_UNSPEC;\n\tifsm->pad1 = 0;\n\tifsm->pad2 = 0;\n\tifsm->ifindex = dev->ifindex;\n\tifsm->filter_mask = filter_mask;\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_64, *idxattr)) {\n\t\tstruct rtnl_link_stats64 *sp;\n\n\t\tattr = nla_reserve_64bit(skb, IFLA_STATS_LINK_64,\n\t\t\t\t\t sizeof(struct rtnl_link_stats64),\n\t\t\t\t\t IFLA_STATS_UNSPEC);\n\t\tif (!attr) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tsp = nla_data(attr);\n\t\tdev_get_stats(dev, sp);\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_XSTATS, *idxattr)) {\n\t\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\n\t\tif (ops && ops->fill_linkxstats) {\n\t\t\t*idxattr = IFLA_STATS_LINK_XSTATS;\n\t\t\tattr = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t     IFLA_STATS_LINK_XSTATS);\n\t\t\tif (!attr) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\n\t\t\terr = ops->fill_linkxstats(skb, dev, prividx, *idxattr);\n\t\t\tnla_nest_end(skb, attr);\n\t\t\tif (err)\n\t\t\t\tgoto nla_put_failure;\n\t\t\t*idxattr = 0;\n\t\t}\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_XSTATS_SLAVE,\n\t\t\t     *idxattr)) {\n\t\tconst struct rtnl_link_ops *ops = NULL;\n\t\tconst struct net_device *master;\n\n\t\tmaster = netdev_master_upper_dev_get(dev);\n\t\tif (master)\n\t\t\tops = master->rtnl_link_ops;\n\t\tif (ops && ops->fill_linkxstats) {\n\t\t\t*idxattr = IFLA_STATS_LINK_XSTATS_SLAVE;\n\t\t\tattr = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t     IFLA_STATS_LINK_XSTATS_SLAVE);\n\t\t\tif (!attr) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\n\t\t\terr = ops->fill_linkxstats(skb, dev, prividx, *idxattr);\n\t\t\tnla_nest_end(skb, attr);\n\t\t\tif (err)\n\t\t\t\tgoto nla_put_failure;\n\t\t\t*idxattr = 0;\n\t\t}\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_OFFLOAD_XSTATS,\n\t\t\t     *idxattr)) {\n\t\tu32 off_filter_mask;\n\n\t\toff_filter_mask = filters->mask[IFLA_STATS_LINK_OFFLOAD_XSTATS];\n\t\t*idxattr = IFLA_STATS_LINK_OFFLOAD_XSTATS;\n\t\tattr = nla_nest_start_noflag(skb,\n\t\t\t\t\t     IFLA_STATS_LINK_OFFLOAD_XSTATS);\n\t\tif (!attr) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\terr = rtnl_offload_xstats_fill(skb, dev, prividx,\n\t\t\t\t\t       off_filter_mask, extack);\n\t\tif (err == -ENODATA)\n\t\t\tnla_nest_cancel(skb, attr);\n\t\telse\n\t\t\tnla_nest_end(skb, attr);\n\n\t\tif (err && err != -ENODATA)\n\t\t\tgoto nla_put_failure;\n\t\t*idxattr = 0;\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_AF_SPEC, *idxattr)) {\n\t\tstruct rtnl_af_ops *af_ops;\n\n\t\t*idxattr = IFLA_STATS_AF_SPEC;\n\t\tattr = nla_nest_start_noflag(skb, IFLA_STATS_AF_SPEC);\n\t\tif (!attr) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(af_ops, &rtnl_af_ops, list) {\n\t\t\tif (af_ops->fill_stats_af) {\n\t\t\t\tstruct nlattr *af;\n\n\t\t\t\taf = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t   af_ops->family);\n\t\t\t\tif (!af) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\terr = -EMSGSIZE;\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\t}\n\t\t\t\terr = af_ops->fill_stats_af(skb, dev);\n\n\t\t\t\tif (err == -ENODATA) {\n\t\t\t\t\tnla_nest_cancel(skb, af);\n\t\t\t\t} else if (err < 0) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\t}\n\n\t\t\t\tnla_nest_end(skb, af);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tnla_nest_end(skb, attr);\n\n\t\t*idxattr = 0;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\n\treturn 0;\n\nnla_put_failure:\n\t \n\tif (!(flags & NLM_F_MULTI) || s_prividx == *prividx)\n\t\tnlmsg_cancel(skb, nlh);\n\telse\n\t\tnlmsg_end(skb, nlh);\n\n\treturn err;\n}\n\nstatic size_t if_nlmsg_stats_size(const struct net_device *dev,\n\t\t\t\t  const struct rtnl_stats_dump_filters *filters)\n{\n\tsize_t size = NLMSG_ALIGN(sizeof(struct if_stats_msg));\n\tunsigned int filter_mask = filters->mask[0];\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_64, 0))\n\t\tsize += nla_total_size_64bit(sizeof(struct rtnl_link_stats64));\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_XSTATS, 0)) {\n\t\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\t\tint attr = IFLA_STATS_LINK_XSTATS;\n\n\t\tif (ops && ops->get_linkxstats_size) {\n\t\t\tsize += nla_total_size(ops->get_linkxstats_size(dev,\n\t\t\t\t\t\t\t\t\tattr));\n\t\t\t \n\t\t\tsize += nla_total_size(0);\n\t\t}\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_XSTATS_SLAVE, 0)) {\n\t\tstruct net_device *_dev = (struct net_device *)dev;\n\t\tconst struct rtnl_link_ops *ops = NULL;\n\t\tconst struct net_device *master;\n\n\t\t \n\t\tmaster = netdev_master_upper_dev_get(_dev);\n\t\tif (master)\n\t\t\tops = master->rtnl_link_ops;\n\t\tif (ops && ops->get_linkxstats_size) {\n\t\t\tint attr = IFLA_STATS_LINK_XSTATS_SLAVE;\n\n\t\t\tsize += nla_total_size(ops->get_linkxstats_size(dev,\n\t\t\t\t\t\t\t\t\tattr));\n\t\t\t \n\t\t\tsize += nla_total_size(0);\n\t\t}\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_OFFLOAD_XSTATS, 0)) {\n\t\tu32 off_filter_mask;\n\n\t\toff_filter_mask = filters->mask[IFLA_STATS_LINK_OFFLOAD_XSTATS];\n\t\tsize += rtnl_offload_xstats_get_size(dev, off_filter_mask);\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_AF_SPEC, 0)) {\n\t\tstruct rtnl_af_ops *af_ops;\n\n\t\t \n\t\tsize += nla_total_size(0);\n\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(af_ops, &rtnl_af_ops, list) {\n\t\t\tif (af_ops->get_stats_af_size) {\n\t\t\t\tsize += nla_total_size(\n\t\t\t\t\taf_ops->get_stats_af_size(dev));\n\n\t\t\t\t \n\t\t\t\tsize += nla_total_size(0);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\treturn size;\n}\n\n#define RTNL_STATS_OFFLOAD_XSTATS_VALID ((1 << __IFLA_OFFLOAD_XSTATS_MAX) - 1)\n\nstatic const struct nla_policy\nrtnl_stats_get_policy_filters[IFLA_STATS_MAX + 1] = {\n\t[IFLA_STATS_LINK_OFFLOAD_XSTATS] =\n\t\t    NLA_POLICY_MASK(NLA_U32, RTNL_STATS_OFFLOAD_XSTATS_VALID),\n};\n\nstatic const struct nla_policy\nrtnl_stats_get_policy[IFLA_STATS_GETSET_MAX + 1] = {\n\t[IFLA_STATS_GET_FILTERS] =\n\t\t    NLA_POLICY_NESTED(rtnl_stats_get_policy_filters),\n};\n\nstatic const struct nla_policy\nifla_stats_set_policy[IFLA_STATS_GETSET_MAX + 1] = {\n\t[IFLA_STATS_SET_OFFLOAD_XSTATS_L3_STATS] = NLA_POLICY_MAX(NLA_U8, 1),\n};\n\nstatic int rtnl_stats_get_parse_filters(struct nlattr *ifla_filters,\n\t\t\t\t\tstruct rtnl_stats_dump_filters *filters,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_STATS_MAX + 1];\n\tint err;\n\tint at;\n\n\terr = nla_parse_nested(tb, IFLA_STATS_MAX, ifla_filters,\n\t\t\t       rtnl_stats_get_policy_filters, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (at = 1; at <= IFLA_STATS_MAX; at++) {\n\t\tif (tb[at]) {\n\t\t\tif (!(filters->mask[0] & IFLA_STATS_FILTER_BIT(at))) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Filtered attribute not enabled in filter_mask\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tfilters->mask[at] = nla_get_u32(tb[at]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_stats_get_parse(const struct nlmsghdr *nlh,\n\t\t\t\tu32 filter_mask,\n\t\t\t\tstruct rtnl_stats_dump_filters *filters,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_STATS_GETSET_MAX + 1];\n\tint err;\n\tint i;\n\n\tfilters->mask[0] = filter_mask;\n\tfor (i = 1; i < ARRAY_SIZE(filters->mask); i++)\n\t\tfilters->mask[i] = -1U;\n\n\terr = nlmsg_parse(nlh, sizeof(struct if_stats_msg), tb,\n\t\t\t  IFLA_STATS_GETSET_MAX, rtnl_stats_get_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_STATS_GET_FILTERS]) {\n\t\terr = rtnl_stats_get_parse_filters(tb[IFLA_STATS_GET_FILTERS],\n\t\t\t\t\t\t   filters, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_valid_stats_req(const struct nlmsghdr *nlh, bool strict_check,\n\t\t\t\tbool is_dump, struct netlink_ext_ack *extack)\n{\n\tstruct if_stats_msg *ifsm;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifsm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for stats dump\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!strict_check)\n\t\treturn 0;\n\n\tifsm = nlmsg_data(nlh);\n\n\t \n\tif (ifsm->pad1 || ifsm->pad2 || (is_dump && ifsm->ifindex)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for stats dump request\");\n\t\treturn -EINVAL;\n\t}\n\tif (ifsm->filter_mask >= IFLA_STATS_FILTER_BIT(IFLA_STATS_MAX + 1)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid stats requested through filter mask\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_stats_get(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct rtnl_stats_dump_filters filters;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev = NULL;\n\tint idxattr = 0, prividx = 0;\n\tstruct if_stats_msg *ifsm;\n\tstruct sk_buff *nskb;\n\tint err;\n\n\terr = rtnl_valid_stats_req(nlh, netlink_strict_get_check(skb),\n\t\t\t\t   false, extack);\n\tif (err)\n\t\treturn err;\n\n\tifsm = nlmsg_data(nlh);\n\tif (ifsm->ifindex > 0)\n\t\tdev = __dev_get_by_index(net, ifsm->ifindex);\n\telse\n\t\treturn -EINVAL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!ifsm->filter_mask) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter mask must be set for stats get\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = rtnl_stats_get_parse(nlh, ifsm->filter_mask, &filters, extack);\n\tif (err)\n\t\treturn err;\n\n\tnskb = nlmsg_new(if_nlmsg_stats_size(dev, &filters), GFP_KERNEL);\n\tif (!nskb)\n\t\treturn -ENOBUFS;\n\n\terr = rtnl_fill_statsinfo(nskb, dev, RTM_NEWSTATS,\n\t\t\t\t  NETLINK_CB(skb).portid, nlh->nlmsg_seq, 0,\n\t\t\t\t  0, &filters, &idxattr, &prividx, extack);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(nskb);\n\t} else {\n\t\terr = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid);\n\t}\n\n\treturn err;\n}\n\nstatic int rtnl_stats_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct netlink_ext_ack *extack = cb->extack;\n\tint h, s_h, err, s_idx, s_idxattr, s_prividx;\n\tstruct rtnl_stats_dump_filters filters;\n\tstruct net *net = sock_net(skb->sk);\n\tunsigned int flags = NLM_F_MULTI;\n\tstruct if_stats_msg *ifsm;\n\tstruct hlist_head *head;\n\tstruct net_device *dev;\n\tint idx = 0;\n\n\ts_h = cb->args[0];\n\ts_idx = cb->args[1];\n\ts_idxattr = cb->args[2];\n\ts_prividx = cb->args[3];\n\n\tcb->seq = net->dev_base_seq;\n\n\terr = rtnl_valid_stats_req(cb->nlh, cb->strict_check, true, extack);\n\tif (err)\n\t\treturn err;\n\n\tifsm = nlmsg_data(cb->nlh);\n\tif (!ifsm->filter_mask) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter mask must be set for stats dump\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = rtnl_stats_get_parse(cb->nlh, ifsm->filter_mask, &filters,\n\t\t\t\t   extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\thlist_for_each_entry(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\terr = rtnl_fill_statsinfo(skb, dev, RTM_NEWSTATS,\n\t\t\t\t\t\t  NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t  cb->nlh->nlmsg_seq, 0,\n\t\t\t\t\t\t  flags, &filters,\n\t\t\t\t\t\t  &s_idxattr, &s_prividx,\n\t\t\t\t\t\t  extack);\n\t\t\t \n\t\t\tWARN_ON((err == -EMSGSIZE) && (skb->len == 0));\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\ts_prividx = 0;\n\t\t\ts_idxattr = 0;\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\tcb->args[3] = s_prividx;\n\tcb->args[2] = s_idxattr;\n\tcb->args[1] = idx;\n\tcb->args[0] = h;\n\n\treturn skb->len;\n}\n\nvoid rtnl_offload_xstats_notify(struct net_device *dev)\n{\n\tstruct rtnl_stats_dump_filters response_filters = {};\n\tstruct net *net = dev_net(dev);\n\tint idxattr = 0, prividx = 0;\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tASSERT_RTNL();\n\n\tresponse_filters.mask[0] |=\n\t\tIFLA_STATS_FILTER_BIT(IFLA_STATS_LINK_OFFLOAD_XSTATS);\n\tresponse_filters.mask[IFLA_STATS_LINK_OFFLOAD_XSTATS] |=\n\t\tIFLA_STATS_FILTER_BIT(IFLA_OFFLOAD_XSTATS_HW_S_INFO);\n\n\tskb = nlmsg_new(if_nlmsg_stats_size(dev, &response_filters),\n\t\t\tGFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = rtnl_fill_statsinfo(skb, dev, RTM_NEWSTATS, 0, 0, 0, 0,\n\t\t\t\t  &response_filters, &idxattr, &prividx, NULL);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_STATS, NULL, GFP_KERNEL);\n\treturn;\n\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_STATS, err);\n}\nEXPORT_SYMBOL(rtnl_offload_xstats_notify);\n\nstatic int rtnl_stats_set(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tenum netdev_offload_xstats_type t_l3 = NETDEV_OFFLOAD_XSTATS_TYPE_L3;\n\tstruct rtnl_stats_dump_filters response_filters = {};\n\tstruct nlattr *tb[IFLA_STATS_GETSET_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev = NULL;\n\tstruct if_stats_msg *ifsm;\n\tbool notify = false;\n\tint err;\n\n\terr = rtnl_valid_stats_req(nlh, netlink_strict_get_check(skb),\n\t\t\t\t   false, extack);\n\tif (err)\n\t\treturn err;\n\n\tifsm = nlmsg_data(nlh);\n\tif (ifsm->family != AF_UNSPEC) {\n\t\tNL_SET_ERR_MSG(extack, \"Address family should be AF_UNSPEC\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ifsm->ifindex > 0)\n\t\tdev = __dev_get_by_index(net, ifsm->ifindex);\n\telse\n\t\treturn -EINVAL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (ifsm->filter_mask) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter mask must be 0 for stats set\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse(nlh, sizeof(*ifsm), tb, IFLA_STATS_GETSET_MAX,\n\t\t\t  ifla_stats_set_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_STATS_SET_OFFLOAD_XSTATS_L3_STATS]) {\n\t\tu8 req = nla_get_u8(tb[IFLA_STATS_SET_OFFLOAD_XSTATS_L3_STATS]);\n\n\t\tif (req)\n\t\t\terr = netdev_offload_xstats_enable(dev, t_l3, extack);\n\t\telse\n\t\t\terr = netdev_offload_xstats_disable(dev, t_l3);\n\n\t\tif (!err)\n\t\t\tnotify = true;\n\t\telse if (err != -EALREADY)\n\t\t\treturn err;\n\n\t\tresponse_filters.mask[0] |=\n\t\t\tIFLA_STATS_FILTER_BIT(IFLA_STATS_LINK_OFFLOAD_XSTATS);\n\t\tresponse_filters.mask[IFLA_STATS_LINK_OFFLOAD_XSTATS] |=\n\t\t\tIFLA_STATS_FILTER_BIT(IFLA_OFFLOAD_XSTATS_HW_S_INFO);\n\t}\n\n\tif (notify)\n\t\trtnl_offload_xstats_notify(dev);\n\n\treturn 0;\n}\n\nstatic int rtnl_mdb_valid_dump_req(const struct nlmsghdr *nlh,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct br_port_msg *bpm;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*bpm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for mdb dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tbpm = nlmsg_data(nlh);\n\tif (bpm->ifindex) {\n\t\tNL_SET_ERR_MSG(extack, \"Filtering by device index is not supported for mdb dump request\");\n\t\treturn -EINVAL;\n\t}\n\tif (nlmsg_attrlen(nlh, sizeof(*bpm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid data after header in mdb dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct rtnl_mdb_dump_ctx {\n\tlong idx;\n};\n\nstatic int rtnl_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct rtnl_mdb_dump_ctx *ctx = (void *)cb->ctx;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tint idx, s_idx;\n\tint err;\n\n\tNL_ASSERT_DUMP_CTX_FITS(struct rtnl_mdb_dump_ctx);\n\n\tif (cb->strict_check) {\n\t\terr = rtnl_mdb_valid_dump_req(cb->nlh, cb->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\ts_idx = ctx->idx;\n\tidx = 0;\n\n\tfor_each_netdev(net, dev) {\n\t\tif (idx < s_idx)\n\t\t\tgoto skip;\n\t\tif (!dev->netdev_ops->ndo_mdb_dump)\n\t\t\tgoto skip;\n\n\t\terr = dev->netdev_ops->ndo_mdb_dump(dev, skb, cb);\n\t\tif (err == -EMSGSIZE)\n\t\t\tgoto out;\n\t\t \n\t\tmemset(cb->ctx, 0, sizeof(cb->ctx));\n\t\tcb->prev_seq = 0;\n\t\tcb->seq = 0;\nskip:\n\t\tidx++;\n\t}\n\nout:\n\tctx->idx = idx;\n\treturn skb->len;\n}\n\nstatic int rtnl_validate_mdb_entry(const struct nlattr *attr,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct br_mdb_entry *entry = nla_data(attr);\n\n\tif (nla_len(attr) != sizeof(struct br_mdb_entry)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attr, \"Invalid attribute length\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (entry->ifindex == 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Zero entry ifindex is not allowed\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (entry->addr.proto == htons(ETH_P_IP)) {\n\t\tif (!ipv4_is_multicast(entry->addr.u.ip4) &&\n\t\t    !ipv4_is_zeronet(entry->addr.u.ip4)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"IPv4 entry group address is not multicast or 0.0.0.0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ipv4_is_local_multicast(entry->addr.u.ip4)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"IPv4 entry group address is local multicast\");\n\t\t\treturn -EINVAL;\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (entry->addr.proto == htons(ETH_P_IPV6)) {\n\t\tif (ipv6_addr_is_ll_all_nodes(&entry->addr.u.ip6)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"IPv6 entry group address is link-local all nodes\");\n\t\t\treturn -EINVAL;\n\t\t}\n#endif\n\t} else if (entry->addr.proto == 0) {\n\t\t \n\t\tif (!is_multicast_ether_addr(entry->addr.u.mac_addr)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"L2 entry group is not multicast\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tNL_SET_ERR_MSG(extack, \"Unknown entry protocol\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (entry->state != MDB_PERMANENT && entry->state != MDB_TEMPORARY) {\n\t\tNL_SET_ERR_MSG(extack, \"Unknown entry state\");\n\t\treturn -EINVAL;\n\t}\n\tif (entry->vid >= VLAN_VID_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid entry VLAN id\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nla_policy mdba_policy[MDBA_SET_ENTRY_MAX + 1] = {\n\t[MDBA_SET_ENTRY_UNSPEC] = { .strict_start_type = MDBA_SET_ENTRY_ATTRS + 1 },\n\t[MDBA_SET_ENTRY] = NLA_POLICY_VALIDATE_FN(NLA_BINARY,\n\t\t\t\t\t\t  rtnl_validate_mdb_entry,\n\t\t\t\t\t\t  sizeof(struct br_mdb_entry)),\n\t[MDBA_SET_ENTRY_ATTRS] = { .type = NLA_NESTED },\n};\n\nstatic int rtnl_mdb_add(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[MDBA_SET_ENTRY_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_port_msg *bpm;\n\tstruct net_device *dev;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*bpm), tb,\n\t\t\t\t     MDBA_SET_ENTRY_MAX, mdba_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tbpm = nlmsg_data(nlh);\n\tif (!bpm->ifindex) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid ifindex\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, bpm->ifindex);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"Device doesn't exist\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (NL_REQ_ATTR_CHECK(extack, NULL, tb, MDBA_SET_ENTRY)) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing MDBA_SET_ENTRY attribute\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!dev->netdev_ops->ndo_mdb_add) {\n\t\tNL_SET_ERR_MSG(extack, \"Device does not support MDB operations\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn dev->netdev_ops->ndo_mdb_add(dev, tb, nlh->nlmsg_flags, extack);\n}\n\nstatic int rtnl_mdb_del(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[MDBA_SET_ENTRY_MAX + 1];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_port_msg *bpm;\n\tstruct net_device *dev;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*bpm), tb,\n\t\t\t\t     MDBA_SET_ENTRY_MAX, mdba_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tbpm = nlmsg_data(nlh);\n\tif (!bpm->ifindex) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid ifindex\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, bpm->ifindex);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"Device doesn't exist\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (NL_REQ_ATTR_CHECK(extack, NULL, tb, MDBA_SET_ENTRY)) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing MDBA_SET_ENTRY attribute\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!dev->netdev_ops->ndo_mdb_del) {\n\t\tNL_SET_ERR_MSG(extack, \"Device does not support MDB operations\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn dev->netdev_ops->ndo_mdb_del(dev, tb, extack);\n}\n\n \n\nstatic int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct rtnl_link *link;\n\tenum rtnl_kinds kind;\n\tstruct module *owner;\n\tint err = -EOPNOTSUPP;\n\trtnl_doit_func doit;\n\tunsigned int flags;\n\tint family;\n\tint type;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > RTM_MAX)\n\t\treturn -EOPNOTSUPP;\n\n\ttype -= RTM_BASE;\n\n\t \n\tif (nlmsg_len(nlh) < sizeof(struct rtgenmsg))\n\t\treturn 0;\n\n\tfamily = ((struct rtgenmsg *)nlmsg_data(nlh))->rtgen_family;\n\tkind = rtnl_msgtype_kind(type);\n\n\tif (kind != RTNL_KIND_GET && !netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\tif (kind == RTNL_KIND_GET && (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tstruct sock *rtnl;\n\t\trtnl_dumpit_func dumpit;\n\t\tu32 min_dump_alloc = 0;\n\n\t\tlink = rtnl_get_link(family, type);\n\t\tif (!link || !link->dumpit) {\n\t\t\tfamily = PF_UNSPEC;\n\t\t\tlink = rtnl_get_link(family, type);\n\t\t\tif (!link || !link->dumpit)\n\t\t\t\tgoto err_unlock;\n\t\t}\n\t\towner = link->owner;\n\t\tdumpit = link->dumpit;\n\n\t\tif (type == RTM_GETLINK - RTM_BASE)\n\t\t\tmin_dump_alloc = rtnl_calcit(skb, nlh);\n\n\t\terr = 0;\n\t\t \n\t\tif (!try_module_get(owner))\n\t\t\terr = -EPROTONOSUPPORT;\n\n\t\trcu_read_unlock();\n\n\t\trtnl = net->rtnl;\n\t\tif (err == 0) {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump\t\t= dumpit,\n\t\t\t\t.min_dump_alloc\t= min_dump_alloc,\n\t\t\t\t.module\t\t= owner,\n\t\t\t};\n\t\t\terr = netlink_dump_start(rtnl, skb, nlh, &c);\n\t\t\t \n\t\t\tmodule_put(owner);\n\t\t}\n\t\treturn err;\n\t}\n\n\tlink = rtnl_get_link(family, type);\n\tif (!link || !link->doit) {\n\t\tfamily = PF_UNSPEC;\n\t\tlink = rtnl_get_link(PF_UNSPEC, type);\n\t\tif (!link || !link->doit)\n\t\t\tgoto out_unlock;\n\t}\n\n\towner = link->owner;\n\tif (!try_module_get(owner)) {\n\t\terr = -EPROTONOSUPPORT;\n\t\tgoto out_unlock;\n\t}\n\n\tflags = link->flags;\n\tif (kind == RTNL_KIND_DEL && (nlh->nlmsg_flags & NLM_F_BULK) &&\n\t    !(flags & RTNL_FLAG_BULK_DEL_SUPPORTED)) {\n\t\tNL_SET_ERR_MSG(extack, \"Bulk delete is not supported\");\n\t\tmodule_put(owner);\n\t\tgoto err_unlock;\n\t}\n\n\tif (flags & RTNL_FLAG_DOIT_UNLOCKED) {\n\t\tdoit = link->doit;\n\t\trcu_read_unlock();\n\t\tif (doit)\n\t\t\terr = doit(skb, nlh, extack);\n\t\tmodule_put(owner);\n\t\treturn err;\n\t}\n\trcu_read_unlock();\n\n\trtnl_lock();\n\tlink = rtnl_get_link(family, type);\n\tif (link && link->doit)\n\t\terr = link->doit(skb, nlh, extack);\n\trtnl_unlock();\n\n\tmodule_put(owner);\n\n\treturn err;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn err;\n\nerr_unlock:\n\trcu_read_unlock();\n\treturn -EOPNOTSUPP;\n}\n\nstatic void rtnetlink_rcv(struct sk_buff *skb)\n{\n\tnetlink_rcv_skb(skb, &rtnetlink_rcv_msg);\n}\n\nstatic int rtnetlink_bind(struct net *net, int group)\n{\n\tswitch (group) {\n\tcase RTNLGRP_IPV4_MROUTE_R:\n\tcase RTNLGRP_IPV6_MROUTE_R:\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rtnetlink_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tswitch (event) {\n\tcase NETDEV_REBOOT:\n\tcase NETDEV_CHANGEMTU:\n\tcase NETDEV_CHANGEADDR:\n\tcase NETDEV_CHANGENAME:\n\tcase NETDEV_FEAT_CHANGE:\n\tcase NETDEV_BONDING_FAILOVER:\n\tcase NETDEV_POST_TYPE_CHANGE:\n\tcase NETDEV_NOTIFY_PEERS:\n\tcase NETDEV_CHANGEUPPER:\n\tcase NETDEV_RESEND_IGMP:\n\tcase NETDEV_CHANGEINFODATA:\n\tcase NETDEV_CHANGELOWERSTATE:\n\tcase NETDEV_CHANGE_TX_QUEUE_LEN:\n\t\trtmsg_ifinfo_event(RTM_NEWLINK, dev, 0, rtnl_get_event(event),\n\t\t\t\t   GFP_KERNEL, NULL, 0, 0, NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rtnetlink_dev_notifier = {\n\t.notifier_call\t= rtnetlink_event,\n};\n\n\nstatic int __net_init rtnetlink_net_init(struct net *net)\n{\n\tstruct sock *sk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t\t= RTNLGRP_MAX,\n\t\t.input\t\t= rtnetlink_rcv,\n\t\t.cb_mutex\t= &rtnl_mutex,\n\t\t.flags\t\t= NL_CFG_F_NONROOT_RECV,\n\t\t.bind\t\t= rtnetlink_bind,\n\t};\n\n\tsk = netlink_kernel_create(net, NETLINK_ROUTE, &cfg);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tnet->rtnl = sk;\n\treturn 0;\n}\n\nstatic void __net_exit rtnetlink_net_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->rtnl);\n\tnet->rtnl = NULL;\n}\n\nstatic struct pernet_operations rtnetlink_net_ops = {\n\t.init = rtnetlink_net_init,\n\t.exit = rtnetlink_net_exit,\n};\n\nvoid __init rtnetlink_init(void)\n{\n\tif (register_pernet_subsys(&rtnetlink_net_ops))\n\t\tpanic(\"rtnetlink_init: cannot initialize rtnetlink\\n\");\n\n\tregister_netdevice_notifier(&rtnetlink_dev_notifier);\n\n\trtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,\n\t\t      rtnl_dump_ifinfo, 0);\n\trtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, 0);\n\n\trtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETNETCONF, NULL, rtnl_dump_all, 0);\n\n\trtnl_register(PF_UNSPEC, RTM_NEWLINKPROP, rtnl_newlinkprop, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELLINKPROP, rtnl_dellinkprop, NULL, 0);\n\n\trtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, NULL, 0);\n\trtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, NULL,\n\t\t      RTNL_FLAG_BULK_DEL_SUPPORTED);\n\trtnl_register(PF_BRIDGE, RTM_GETNEIGH, rtnl_fdb_get, rtnl_fdb_dump, 0);\n\n\trtnl_register(PF_BRIDGE, RTM_GETLINK, NULL, rtnl_bridge_getlink, 0);\n\trtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, NULL, 0);\n\trtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, NULL, 0);\n\n\trtnl_register(PF_UNSPEC, RTM_GETSTATS, rtnl_stats_get, rtnl_stats_dump,\n\t\t      0);\n\trtnl_register(PF_UNSPEC, RTM_SETSTATS, rtnl_stats_set, NULL, 0);\n\n\trtnl_register(PF_BRIDGE, RTM_GETMDB, NULL, rtnl_mdb_dump, 0);\n\trtnl_register(PF_BRIDGE, RTM_NEWMDB, rtnl_mdb_add, NULL, 0);\n\trtnl_register(PF_BRIDGE, RTM_DELMDB, rtnl_mdb_del, NULL, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}