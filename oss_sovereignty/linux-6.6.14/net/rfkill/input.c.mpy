{
  "module_name": "input.c",
  "hash_id": "6d27e85ec990a5ad8f005a37fb0d7a39e83b6f902d3b5498ebedac8885eb94f6",
  "original_prompt": "Ingested from linux-6.6.14/net/rfkill/input.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/moduleparam.h>\n#include <linux/workqueue.h>\n#include <linux/init.h>\n#include <linux/rfkill.h>\n#include <linux/sched.h>\n\n#include \"rfkill.h\"\n\nenum rfkill_input_master_mode {\n\tRFKILL_INPUT_MASTER_UNLOCK = 0,\n\tRFKILL_INPUT_MASTER_RESTORE = 1,\n\tRFKILL_INPUT_MASTER_UNBLOCKALL = 2,\n\tNUM_RFKILL_INPUT_MASTER_MODES\n};\n\n \n#define RFKILL_OPS_DELAY 200\n\nstatic enum rfkill_input_master_mode rfkill_master_switch_mode =\n\t\t\t\t\tRFKILL_INPUT_MASTER_UNBLOCKALL;\nmodule_param_named(master_switch_mode, rfkill_master_switch_mode, uint, 0);\nMODULE_PARM_DESC(master_switch_mode,\n\t\"SW_RFKILL_ALL ON should: 0=do nothing (only unlock); 1=restore; 2=unblock all\");\n\nstatic DEFINE_SPINLOCK(rfkill_op_lock);\nstatic bool rfkill_op_pending;\nstatic unsigned long rfkill_sw_pending[BITS_TO_LONGS(NUM_RFKILL_TYPES)];\nstatic unsigned long rfkill_sw_state[BITS_TO_LONGS(NUM_RFKILL_TYPES)];\n\nenum rfkill_sched_op {\n\tRFKILL_GLOBAL_OP_EPO = 0,\n\tRFKILL_GLOBAL_OP_RESTORE,\n\tRFKILL_GLOBAL_OP_UNLOCK,\n\tRFKILL_GLOBAL_OP_UNBLOCK,\n};\n\nstatic enum rfkill_sched_op rfkill_master_switch_op;\nstatic enum rfkill_sched_op rfkill_op;\n\nstatic void __rfkill_handle_global_op(enum rfkill_sched_op op)\n{\n\tunsigned int i;\n\n\tswitch (op) {\n\tcase RFKILL_GLOBAL_OP_EPO:\n\t\trfkill_epo();\n\t\tbreak;\n\tcase RFKILL_GLOBAL_OP_RESTORE:\n\t\trfkill_restore_states();\n\t\tbreak;\n\tcase RFKILL_GLOBAL_OP_UNLOCK:\n\t\trfkill_remove_epo_lock();\n\t\tbreak;\n\tcase RFKILL_GLOBAL_OP_UNBLOCK:\n\t\trfkill_remove_epo_lock();\n\t\tfor (i = 0; i < NUM_RFKILL_TYPES; i++)\n\t\t\trfkill_switch_all(i, false);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\trfkill_epo();\n\t\tWARN(1, \"Unknown requested operation %d! \"\n\t\t\t\"rfkill Emergency Power Off activated\\n\",\n\t\t\top);\n\t}\n}\n\nstatic void __rfkill_handle_normal_op(const enum rfkill_type type,\n\t\t\t\t      const bool complement)\n{\n\tbool blocked;\n\n\tblocked = rfkill_get_global_sw_state(type);\n\tif (complement)\n\t\tblocked = !blocked;\n\n\trfkill_switch_all(type, blocked);\n}\n\nstatic void rfkill_op_handler(struct work_struct *work)\n{\n\tunsigned int i;\n\tbool c;\n\n\tspin_lock_irq(&rfkill_op_lock);\n\tdo {\n\t\tif (rfkill_op_pending) {\n\t\t\tenum rfkill_sched_op op = rfkill_op;\n\t\t\trfkill_op_pending = false;\n\t\t\tmemset(rfkill_sw_pending, 0,\n\t\t\t\tsizeof(rfkill_sw_pending));\n\t\t\tspin_unlock_irq(&rfkill_op_lock);\n\n\t\t\t__rfkill_handle_global_op(op);\n\n\t\t\tspin_lock_irq(&rfkill_op_lock);\n\n\t\t\t \n\t\t\tif (rfkill_op_pending)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (rfkill_is_epo_lock_active())\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < NUM_RFKILL_TYPES; i++) {\n\t\t\tif (__test_and_clear_bit(i, rfkill_sw_pending)) {\n\t\t\t\tc = __test_and_clear_bit(i, rfkill_sw_state);\n\t\t\t\tspin_unlock_irq(&rfkill_op_lock);\n\n\t\t\t\t__rfkill_handle_normal_op(i, c);\n\n\t\t\t\tspin_lock_irq(&rfkill_op_lock);\n\t\t\t}\n\t\t}\n\t} while (rfkill_op_pending);\n\tspin_unlock_irq(&rfkill_op_lock);\n}\n\nstatic DECLARE_DELAYED_WORK(rfkill_op_work, rfkill_op_handler);\nstatic unsigned long rfkill_last_scheduled;\n\nstatic unsigned long rfkill_ratelimit(const unsigned long last)\n{\n\tconst unsigned long delay = msecs_to_jiffies(RFKILL_OPS_DELAY);\n\treturn time_after(jiffies, last + delay) ? 0 : delay;\n}\n\nstatic void rfkill_schedule_ratelimited(void)\n{\n\tif (schedule_delayed_work(&rfkill_op_work,\n\t\t\t\t  rfkill_ratelimit(rfkill_last_scheduled)))\n\t\trfkill_last_scheduled = jiffies;\n}\n\nstatic void rfkill_schedule_global_op(enum rfkill_sched_op op)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rfkill_op_lock, flags);\n\trfkill_op = op;\n\trfkill_op_pending = true;\n\tif (op == RFKILL_GLOBAL_OP_EPO && !rfkill_is_epo_lock_active()) {\n\t\t \n\t\tmod_delayed_work(system_wq, &rfkill_op_work, 0);\n\t\trfkill_last_scheduled = jiffies;\n\t} else\n\t\trfkill_schedule_ratelimited();\n\tspin_unlock_irqrestore(&rfkill_op_lock, flags);\n}\n\nstatic void rfkill_schedule_toggle(enum rfkill_type type)\n{\n\tunsigned long flags;\n\n\tif (rfkill_is_epo_lock_active())\n\t\treturn;\n\n\tspin_lock_irqsave(&rfkill_op_lock, flags);\n\tif (!rfkill_op_pending) {\n\t\t__set_bit(type, rfkill_sw_pending);\n\t\t__change_bit(type, rfkill_sw_state);\n\t\trfkill_schedule_ratelimited();\n\t}\n\tspin_unlock_irqrestore(&rfkill_op_lock, flags);\n}\n\nstatic void rfkill_schedule_evsw_rfkillall(int state)\n{\n\tif (state)\n\t\trfkill_schedule_global_op(rfkill_master_switch_op);\n\telse\n\t\trfkill_schedule_global_op(RFKILL_GLOBAL_OP_EPO);\n}\n\nstatic void rfkill_event(struct input_handle *handle, unsigned int type,\n\t\t\tunsigned int code, int data)\n{\n\tif (type == EV_KEY && data == 1) {\n\t\tswitch (code) {\n\t\tcase KEY_WLAN:\n\t\t\trfkill_schedule_toggle(RFKILL_TYPE_WLAN);\n\t\t\tbreak;\n\t\tcase KEY_BLUETOOTH:\n\t\t\trfkill_schedule_toggle(RFKILL_TYPE_BLUETOOTH);\n\t\t\tbreak;\n\t\tcase KEY_UWB:\n\t\t\trfkill_schedule_toggle(RFKILL_TYPE_UWB);\n\t\t\tbreak;\n\t\tcase KEY_WIMAX:\n\t\t\trfkill_schedule_toggle(RFKILL_TYPE_WIMAX);\n\t\t\tbreak;\n\t\tcase KEY_RFKILL:\n\t\t\trfkill_schedule_toggle(RFKILL_TYPE_ALL);\n\t\t\tbreak;\n\t\t}\n\t} else if (type == EV_SW && code == SW_RFKILL_ALL)\n\t\trfkill_schedule_evsw_rfkillall(data);\n}\n\nstatic int rfkill_connect(struct input_handler *handler, struct input_dev *dev,\n\t\t\t  const struct input_device_id *id)\n{\n\tstruct input_handle *handle;\n\tint error;\n\n\thandle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);\n\tif (!handle)\n\t\treturn -ENOMEM;\n\n\thandle->dev = dev;\n\thandle->handler = handler;\n\thandle->name = \"rfkill\";\n\n\t \n\terror = input_register_handle(handle);\n\tif (error)\n\t\tgoto err_free_handle;\n\n\terror = input_open_device(handle);\n\tif (error)\n\t\tgoto err_unregister_handle;\n\n\treturn 0;\n\n err_unregister_handle:\n\tinput_unregister_handle(handle);\n err_free_handle:\n\tkfree(handle);\n\treturn error;\n}\n\nstatic void rfkill_start(struct input_handle *handle)\n{\n\t \n\tspin_lock_irq(&handle->dev->event_lock);\n\n\tif (test_bit(EV_SW, handle->dev->evbit) &&\n\t    test_bit(SW_RFKILL_ALL, handle->dev->swbit))\n\t\trfkill_schedule_evsw_rfkillall(test_bit(SW_RFKILL_ALL,\n\t\t\t\t\t\t\thandle->dev->sw));\n\n\tspin_unlock_irq(&handle->dev->event_lock);\n}\n\nstatic void rfkill_disconnect(struct input_handle *handle)\n{\n\tinput_close_device(handle);\n\tinput_unregister_handle(handle);\n\tkfree(handle);\n}\n\nstatic const struct input_device_id rfkill_ids[] = {\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t\t.keybit = { [BIT_WORD(KEY_WLAN)] = BIT_MASK(KEY_WLAN) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t\t.keybit = { [BIT_WORD(KEY_BLUETOOTH)] = BIT_MASK(KEY_BLUETOOTH) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t\t.keybit = { [BIT_WORD(KEY_UWB)] = BIT_MASK(KEY_UWB) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t\t.keybit = { [BIT_WORD(KEY_WIMAX)] = BIT_MASK(KEY_WIMAX) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t\t.keybit = { [BIT_WORD(KEY_RFKILL)] = BIT_MASK(KEY_RFKILL) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_SWBIT,\n\t\t.evbit = { BIT(EV_SW) },\n\t\t.swbit = { [BIT_WORD(SW_RFKILL_ALL)] = BIT_MASK(SW_RFKILL_ALL) },\n\t},\n\t{ }\n};\n\nstatic struct input_handler rfkill_handler = {\n\t.name =\t\"rfkill\",\n\t.event = rfkill_event,\n\t.connect = rfkill_connect,\n\t.start = rfkill_start,\n\t.disconnect = rfkill_disconnect,\n\t.id_table = rfkill_ids,\n};\n\nint __init rfkill_handler_init(void)\n{\n\tswitch (rfkill_master_switch_mode) {\n\tcase RFKILL_INPUT_MASTER_UNBLOCKALL:\n\t\trfkill_master_switch_op = RFKILL_GLOBAL_OP_UNBLOCK;\n\t\tbreak;\n\tcase RFKILL_INPUT_MASTER_RESTORE:\n\t\trfkill_master_switch_op = RFKILL_GLOBAL_OP_RESTORE;\n\t\tbreak;\n\tcase RFKILL_INPUT_MASTER_UNLOCK:\n\t\trfkill_master_switch_op = RFKILL_GLOBAL_OP_UNLOCK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trfkill_last_scheduled =\n\t\t\tjiffies - msecs_to_jiffies(RFKILL_OPS_DELAY) - 1;\n\treturn input_register_handler(&rfkill_handler);\n}\n\nvoid __exit rfkill_handler_exit(void)\n{\n\tinput_unregister_handler(&rfkill_handler);\n\tcancel_delayed_work_sync(&rfkill_op_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}