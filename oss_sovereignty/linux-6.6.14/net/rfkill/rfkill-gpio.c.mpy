{
  "module_name": "rfkill-gpio.c",
  "hash_id": "54cdf71c7c5b59d35a82959fd5553f41c1e0aaffbde8e1e4c609ee63c9cc4428",
  "original_prompt": "Ingested from linux-6.6.14/net/rfkill/rfkill-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/rfkill.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/gpio/consumer.h>\n\nstruct rfkill_gpio_data {\n\tconst char\t\t*name;\n\tenum rfkill_type\ttype;\n\tstruct gpio_desc\t*reset_gpio;\n\tstruct gpio_desc\t*shutdown_gpio;\n\n\tstruct rfkill\t\t*rfkill_dev;\n\tstruct clk\t\t*clk;\n\n\tbool\t\t\tclk_enabled;\n};\n\nstatic int rfkill_gpio_set_power(void *data, bool blocked)\n{\n\tstruct rfkill_gpio_data *rfkill = data;\n\n\tif (!blocked && !IS_ERR(rfkill->clk) && !rfkill->clk_enabled)\n\t\tclk_enable(rfkill->clk);\n\n\tgpiod_set_value_cansleep(rfkill->shutdown_gpio, !blocked);\n\tgpiod_set_value_cansleep(rfkill->reset_gpio, !blocked);\n\n\tif (blocked && !IS_ERR(rfkill->clk) && rfkill->clk_enabled)\n\t\tclk_disable(rfkill->clk);\n\n\trfkill->clk_enabled = !blocked;\n\n\treturn 0;\n}\n\nstatic const struct rfkill_ops rfkill_gpio_ops = {\n\t.set_block = rfkill_gpio_set_power,\n};\n\nstatic const struct acpi_gpio_params reset_gpios = { 0, 0, false };\nstatic const struct acpi_gpio_params shutdown_gpios = { 1, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_rfkill_default_gpios[] = {\n\t{ \"reset-gpios\", &reset_gpios, 1 },\n\t{ \"shutdown-gpios\", &shutdown_gpios, 1 },\n\t{ },\n};\n\nstatic int rfkill_gpio_acpi_probe(struct device *dev,\n\t\t\t\t  struct rfkill_gpio_data *rfkill)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\trfkill->type = (unsigned)id->driver_data;\n\n\treturn devm_acpi_dev_add_driver_gpios(dev, acpi_rfkill_default_gpios);\n}\n\nstatic int rfkill_gpio_probe(struct platform_device *pdev)\n{\n\tstruct rfkill_gpio_data *rfkill;\n\tstruct gpio_desc *gpio;\n\tconst char *name_property;\n\tconst char *type_property;\n\tconst char *type_name;\n\tint ret;\n\n\trfkill = devm_kzalloc(&pdev->dev, sizeof(*rfkill), GFP_KERNEL);\n\tif (!rfkill)\n\t\treturn -ENOMEM;\n\n\tif (dev_of_node(&pdev->dev)) {\n\t\tname_property = \"label\";\n\t\ttype_property = \"radio-type\";\n\t} else {\n\t\tname_property = \"name\";\n\t\ttype_property = \"type\";\n\t}\n\tdevice_property_read_string(&pdev->dev, name_property, &rfkill->name);\n\tdevice_property_read_string(&pdev->dev, type_property, &type_name);\n\n\tif (!rfkill->name)\n\t\trfkill->name = dev_name(&pdev->dev);\n\n\trfkill->type = rfkill_find_type(type_name);\n\n\tif (ACPI_HANDLE(&pdev->dev)) {\n\t\tret = rfkill_gpio_acpi_probe(&pdev->dev, rfkill);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\trfkill->clk = devm_clk_get(&pdev->dev, NULL);\n\n\tgpio = devm_gpiod_get_optional(&pdev->dev, \"reset\", GPIOD_ASIS);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\trfkill->reset_gpio = gpio;\n\n\tgpio = devm_gpiod_get_optional(&pdev->dev, \"shutdown\", GPIOD_ASIS);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\trfkill->shutdown_gpio = gpio;\n\n\t \n\tif (!rfkill->reset_gpio && !rfkill->shutdown_gpio) {\n\t\tdev_err(&pdev->dev, \"invalid platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = gpiod_direction_output(rfkill->reset_gpio, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gpiod_direction_output(rfkill->shutdown_gpio, true);\n\tif (ret)\n\t\treturn ret;\n\n\trfkill->rfkill_dev = rfkill_alloc(rfkill->name, &pdev->dev,\n\t\t\t\t\t  rfkill->type, &rfkill_gpio_ops,\n\t\t\t\t\t  rfkill);\n\tif (!rfkill->rfkill_dev)\n\t\treturn -ENOMEM;\n\n\tret = rfkill_register(rfkill->rfkill_dev);\n\tif (ret < 0)\n\t\tgoto err_destroy;\n\n\tplatform_set_drvdata(pdev, rfkill);\n\n\tdev_info(&pdev->dev, \"%s device registered.\\n\", rfkill->name);\n\n\treturn 0;\n\nerr_destroy:\n\trfkill_destroy(rfkill->rfkill_dev);\n\n\treturn ret;\n}\n\nstatic int rfkill_gpio_remove(struct platform_device *pdev)\n{\n\tstruct rfkill_gpio_data *rfkill = platform_get_drvdata(pdev);\n\n\trfkill_unregister(rfkill->rfkill_dev);\n\trfkill_destroy(rfkill->rfkill_dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id rfkill_acpi_match[] = {\n\t{ \"BCM4752\", RFKILL_TYPE_GPS },\n\t{ \"LNV4752\", RFKILL_TYPE_GPS },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, rfkill_acpi_match);\n#endif\n\nstatic const struct of_device_id rfkill_of_match[] __maybe_unused = {\n\t{ .compatible = \"rfkill-gpio\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rfkill_of_match);\n\nstatic struct platform_driver rfkill_gpio_driver = {\n\t.probe = rfkill_gpio_probe,\n\t.remove = rfkill_gpio_remove,\n\t.driver = {\n\t\t.name = \"rfkill_gpio\",\n\t\t.acpi_match_table = ACPI_PTR(rfkill_acpi_match),\n\t\t.of_match_table = of_match_ptr(rfkill_of_match),\n\t},\n};\n\nmodule_platform_driver(rfkill_gpio_driver);\n\nMODULE_DESCRIPTION(\"gpio rfkill\");\nMODULE_AUTHOR(\"NVIDIA\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}