{
  "module_name": "header_ops.c",
  "hash_id": "bbc7fcb2743c7bfbd5740de097b8204a47228aa7f2c40153d014d7520dd8082f",
  "original_prompt": "Ingested from linux-6.6.14/net/ieee802154/header_ops.c",
  "human_readable_source": "\n \n\n#include <linux/ieee802154.h>\n\n#include <net/mac802154.h>\n#include <net/ieee802154_netdev.h>\n\nstatic int\nieee802154_hdr_push_addr(u8 *buf, const struct ieee802154_addr *addr,\n\t\t\t bool omit_pan)\n{\n\tint pos = 0;\n\n\tif (addr->mode == IEEE802154_ADDR_NONE)\n\t\treturn 0;\n\n\tif (!omit_pan) {\n\t\tmemcpy(buf + pos, &addr->pan_id, 2);\n\t\tpos += 2;\n\t}\n\n\tswitch (addr->mode) {\n\tcase IEEE802154_ADDR_SHORT:\n\t\tmemcpy(buf + pos, &addr->short_addr, 2);\n\t\tpos += 2;\n\t\tbreak;\n\n\tcase IEEE802154_ADDR_LONG:\n\t\tmemcpy(buf + pos, &addr->extended_addr, IEEE802154_ADDR_LEN);\n\t\tpos += IEEE802154_ADDR_LEN;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn pos;\n}\n\nstatic int\nieee802154_hdr_push_sechdr(u8 *buf, const struct ieee802154_sechdr *hdr)\n{\n\tint pos = 5;\n\n\tmemcpy(buf, hdr, 1);\n\tmemcpy(buf + 1, &hdr->frame_counter, 4);\n\n\tswitch (hdr->key_id_mode) {\n\tcase IEEE802154_SCF_KEY_IMPLICIT:\n\t\treturn pos;\n\n\tcase IEEE802154_SCF_KEY_INDEX:\n\t\tbreak;\n\n\tcase IEEE802154_SCF_KEY_SHORT_INDEX:\n\t\tmemcpy(buf + pos, &hdr->short_src, 4);\n\t\tpos += 4;\n\t\tbreak;\n\n\tcase IEEE802154_SCF_KEY_HW_INDEX:\n\t\tmemcpy(buf + pos, &hdr->extended_src, IEEE802154_ADDR_LEN);\n\t\tpos += IEEE802154_ADDR_LEN;\n\t\tbreak;\n\t}\n\n\tbuf[pos++] = hdr->key_id;\n\n\treturn pos;\n}\n\nint\nieee802154_hdr_push(struct sk_buff *skb, struct ieee802154_hdr *hdr)\n{\n\tu8 buf[IEEE802154_MAX_HEADER_LEN];\n\tint pos = 2;\n\tint rc;\n\tstruct ieee802154_hdr_fc *fc = &hdr->fc;\n\n\tbuf[pos++] = hdr->seq;\n\n\tfc->dest_addr_mode = hdr->dest.mode;\n\n\trc = ieee802154_hdr_push_addr(buf + pos, &hdr->dest, false);\n\tif (rc < 0)\n\t\treturn -EINVAL;\n\tpos += rc;\n\n\tfc->source_addr_mode = hdr->source.mode;\n\n\tif (hdr->source.pan_id == hdr->dest.pan_id &&\n\t    hdr->dest.mode != IEEE802154_ADDR_NONE)\n\t\tfc->intra_pan = true;\n\n\trc = ieee802154_hdr_push_addr(buf + pos, &hdr->source, fc->intra_pan);\n\tif (rc < 0)\n\t\treturn -EINVAL;\n\tpos += rc;\n\n\tif (fc->security_enabled) {\n\t\tfc->version = 1;\n\n\t\trc = ieee802154_hdr_push_sechdr(buf + pos, &hdr->sec);\n\t\tif (rc < 0)\n\t\t\treturn -EINVAL;\n\n\t\tpos += rc;\n\t}\n\n\tmemcpy(buf, fc, 2);\n\n\tmemcpy(skb_push(skb, pos), buf, pos);\n\n\treturn pos;\n}\nEXPORT_SYMBOL_GPL(ieee802154_hdr_push);\n\nint ieee802154_mac_cmd_push(struct sk_buff *skb, void *f,\n\t\t\t    const void *pl, unsigned int pl_len)\n{\n\tstruct ieee802154_mac_cmd_frame *frame = f;\n\tstruct ieee802154_mac_cmd_pl *mac_pl = &frame->mac_pl;\n\tstruct ieee802154_hdr *mhr = &frame->mhr;\n\tint ret;\n\n\tskb_reserve(skb, sizeof(*mhr));\n\tret = ieee802154_hdr_push(skb, mhr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tskb_reset_mac_header(skb);\n\tskb->mac_len = ret;\n\n\tskb_put_data(skb, mac_pl, sizeof(*mac_pl));\n\tskb_put_data(skb, pl, pl_len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ieee802154_mac_cmd_push);\n\nint ieee802154_beacon_push(struct sk_buff *skb,\n\t\t\t   struct ieee802154_beacon_frame *beacon)\n{\n\tstruct ieee802154_beacon_hdr *mac_pl = &beacon->mac_pl;\n\tstruct ieee802154_hdr *mhr = &beacon->mhr;\n\tint ret;\n\n\tskb_reserve(skb, sizeof(*mhr));\n\tret = ieee802154_hdr_push(skb, mhr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tskb_reset_mac_header(skb);\n\tskb->mac_len = ret;\n\n\tskb_put_data(skb, mac_pl, sizeof(*mac_pl));\n\n\tif (mac_pl->pend_short_addr_count || mac_pl->pend_ext_addr_count)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ieee802154_beacon_push);\n\nstatic int\nieee802154_hdr_get_addr(const u8 *buf, int mode, bool omit_pan,\n\t\t\tstruct ieee802154_addr *addr)\n{\n\tint pos = 0;\n\n\taddr->mode = mode;\n\n\tif (mode == IEEE802154_ADDR_NONE)\n\t\treturn 0;\n\n\tif (!omit_pan) {\n\t\tmemcpy(&addr->pan_id, buf + pos, 2);\n\t\tpos += 2;\n\t}\n\n\tif (mode == IEEE802154_ADDR_SHORT) {\n\t\tmemcpy(&addr->short_addr, buf + pos, 2);\n\t\treturn pos + 2;\n\t} else {\n\t\tmemcpy(&addr->extended_addr, buf + pos, IEEE802154_ADDR_LEN);\n\t\treturn pos + IEEE802154_ADDR_LEN;\n\t}\n}\n\nstatic int ieee802154_hdr_addr_len(int mode, bool omit_pan)\n{\n\tint pan_len = omit_pan ? 0 : 2;\n\n\tswitch (mode) {\n\tcase IEEE802154_ADDR_NONE: return 0;\n\tcase IEEE802154_ADDR_SHORT: return 2 + pan_len;\n\tcase IEEE802154_ADDR_LONG: return IEEE802154_ADDR_LEN + pan_len;\n\tdefault: return -EINVAL;\n\t}\n}\n\nstatic int\nieee802154_hdr_get_sechdr(const u8 *buf, struct ieee802154_sechdr *hdr)\n{\n\tint pos = 5;\n\n\tmemcpy(hdr, buf, 1);\n\tmemcpy(&hdr->frame_counter, buf + 1, 4);\n\n\tswitch (hdr->key_id_mode) {\n\tcase IEEE802154_SCF_KEY_IMPLICIT:\n\t\treturn pos;\n\n\tcase IEEE802154_SCF_KEY_INDEX:\n\t\tbreak;\n\n\tcase IEEE802154_SCF_KEY_SHORT_INDEX:\n\t\tmemcpy(&hdr->short_src, buf + pos, 4);\n\t\tpos += 4;\n\t\tbreak;\n\n\tcase IEEE802154_SCF_KEY_HW_INDEX:\n\t\tmemcpy(&hdr->extended_src, buf + pos, IEEE802154_ADDR_LEN);\n\t\tpos += IEEE802154_ADDR_LEN;\n\t\tbreak;\n\t}\n\n\thdr->key_id = buf[pos++];\n\n\treturn pos;\n}\n\nstatic int ieee802154_sechdr_lengths[4] = {\n\t[IEEE802154_SCF_KEY_IMPLICIT] = 5,\n\t[IEEE802154_SCF_KEY_INDEX] = 6,\n\t[IEEE802154_SCF_KEY_SHORT_INDEX] = 10,\n\t[IEEE802154_SCF_KEY_HW_INDEX] = 14,\n};\n\nstatic int ieee802154_hdr_sechdr_len(u8 sc)\n{\n\treturn ieee802154_sechdr_lengths[IEEE802154_SCF_KEY_ID_MODE(sc)];\n}\n\nstatic int ieee802154_hdr_minlen(const struct ieee802154_hdr *hdr)\n{\n\tint dlen, slen;\n\n\tdlen = ieee802154_hdr_addr_len(hdr->fc.dest_addr_mode, false);\n\tslen = ieee802154_hdr_addr_len(hdr->fc.source_addr_mode,\n\t\t\t\t       hdr->fc.intra_pan);\n\n\tif (slen < 0 || dlen < 0)\n\t\treturn -EINVAL;\n\n\treturn 3 + dlen + slen + hdr->fc.security_enabled;\n}\n\nstatic int\nieee802154_hdr_get_addrs(const u8 *buf, struct ieee802154_hdr *hdr)\n{\n\tint pos = 0;\n\n\tpos += ieee802154_hdr_get_addr(buf + pos, hdr->fc.dest_addr_mode,\n\t\t\t\t       false, &hdr->dest);\n\tpos += ieee802154_hdr_get_addr(buf + pos, hdr->fc.source_addr_mode,\n\t\t\t\t       hdr->fc.intra_pan, &hdr->source);\n\n\tif (hdr->fc.intra_pan)\n\t\thdr->source.pan_id = hdr->dest.pan_id;\n\n\treturn pos;\n}\n\nint\nieee802154_hdr_pull(struct sk_buff *skb, struct ieee802154_hdr *hdr)\n{\n\tint pos = 3, rc;\n\n\tif (!pskb_may_pull(skb, 3))\n\t\treturn -EINVAL;\n\n\tmemcpy(hdr, skb->data, 3);\n\n\trc = ieee802154_hdr_minlen(hdr);\n\tif (rc < 0 || !pskb_may_pull(skb, rc))\n\t\treturn -EINVAL;\n\n\tpos += ieee802154_hdr_get_addrs(skb->data + pos, hdr);\n\n\tif (hdr->fc.security_enabled) {\n\t\tint want = pos + ieee802154_hdr_sechdr_len(skb->data[pos]);\n\n\t\tif (!pskb_may_pull(skb, want))\n\t\t\treturn -EINVAL;\n\n\t\tpos += ieee802154_hdr_get_sechdr(skb->data + pos, &hdr->sec);\n\t}\n\n\tskb_pull(skb, pos);\n\treturn pos;\n}\nEXPORT_SYMBOL_GPL(ieee802154_hdr_pull);\n\nint ieee802154_mac_cmd_pl_pull(struct sk_buff *skb,\n\t\t\t       struct ieee802154_mac_cmd_pl *mac_pl)\n{\n\tif (!pskb_may_pull(skb, sizeof(*mac_pl)))\n\t\treturn -EINVAL;\n\n\tmemcpy(mac_pl, skb->data, sizeof(*mac_pl));\n\tskb_pull(skb, sizeof(*mac_pl));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ieee802154_mac_cmd_pl_pull);\n\nint\nieee802154_hdr_peek_addrs(const struct sk_buff *skb, struct ieee802154_hdr *hdr)\n{\n\tconst u8 *buf = skb_mac_header(skb);\n\tint pos = 3, rc;\n\n\tif (buf + 3 > skb_tail_pointer(skb))\n\t\treturn -EINVAL;\n\n\tmemcpy(hdr, buf, 3);\n\n\trc = ieee802154_hdr_minlen(hdr);\n\tif (rc < 0 || buf + rc > skb_tail_pointer(skb))\n\t\treturn -EINVAL;\n\n\tpos += ieee802154_hdr_get_addrs(buf + pos, hdr);\n\treturn pos;\n}\nEXPORT_SYMBOL_GPL(ieee802154_hdr_peek_addrs);\n\nint\nieee802154_hdr_peek(const struct sk_buff *skb, struct ieee802154_hdr *hdr)\n{\n\tconst u8 *buf = skb_mac_header(skb);\n\tint pos;\n\n\tpos = ieee802154_hdr_peek_addrs(skb, hdr);\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tif (hdr->fc.security_enabled) {\n\t\tu8 key_id_mode = IEEE802154_SCF_KEY_ID_MODE(*(buf + pos));\n\t\tint want = pos + ieee802154_sechdr_lengths[key_id_mode];\n\n\t\tif (buf + want > skb_tail_pointer(skb))\n\t\t\treturn -EINVAL;\n\n\t\tpos += ieee802154_hdr_get_sechdr(buf + pos, &hdr->sec);\n\t}\n\n\treturn pos;\n}\nEXPORT_SYMBOL_GPL(ieee802154_hdr_peek);\n\nint ieee802154_max_payload(const struct ieee802154_hdr *hdr)\n{\n\tint hlen = ieee802154_hdr_minlen(hdr);\n\n\tif (hdr->fc.security_enabled) {\n\t\thlen += ieee802154_sechdr_lengths[hdr->sec.key_id_mode] - 1;\n\t\thlen += ieee802154_sechdr_authtag_len(&hdr->sec);\n\t}\n\n\treturn IEEE802154_MTU - hlen - IEEE802154_MFR_SIZE;\n}\nEXPORT_SYMBOL_GPL(ieee802154_max_payload);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}