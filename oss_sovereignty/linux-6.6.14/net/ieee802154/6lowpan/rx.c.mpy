{
  "module_name": "rx.c",
  "hash_id": "a37c3b5bf9ecd708eee38df650cf5f03738563644fdc59bfee64d49fd6788d5c",
  "original_prompt": "Ingested from linux-6.6.14/net/ieee802154/6lowpan/rx.c",
  "human_readable_source": "\n\n#include <linux/if_arp.h>\n\n#include <net/6lowpan.h>\n#include <net/mac802154.h>\n#include <net/ieee802154_netdev.h>\n\n#include \"6lowpan_i.h\"\n\n#define LOWPAN_DISPATCH_FIRST\t\t0xc0\n#define LOWPAN_DISPATCH_FRAG_MASK\t0xf8\n\n#define LOWPAN_DISPATCH_NALP\t\t0x00\n#define LOWPAN_DISPATCH_ESC\t\t0x40\n#define LOWPAN_DISPATCH_HC1\t\t0x42\n#define LOWPAN_DISPATCH_DFF\t\t0x43\n#define LOWPAN_DISPATCH_BC0\t\t0x50\n#define LOWPAN_DISPATCH_MESH\t\t0x80\n\nstatic int lowpan_give_skb_to_device(struct sk_buff *skb)\n{\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->dev->stats.rx_packets++;\n\tskb->dev->stats.rx_bytes += skb->len;\n\n\treturn netif_rx(skb);\n}\n\nstatic int lowpan_rx_handlers_result(struct sk_buff *skb, lowpan_rx_result res)\n{\n\tswitch (res) {\n\tcase RX_CONTINUE:\n\t\t \n\t\tnet_warn_ratelimited(\"%s: received unknown dispatch\\n\",\n\t\t\t\t     __func__);\n\n\t\tfallthrough;\n\tcase RX_DROP_UNUSABLE:\n\t\tkfree_skb(skb);\n\n\t\tfallthrough;\n\tcase RX_DROP:\n\t\treturn NET_RX_DROP;\n\tcase RX_QUEUED:\n\t\treturn lowpan_give_skb_to_device(skb);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NET_RX_DROP;\n}\n\nstatic inline bool lowpan_is_frag1(u8 dispatch)\n{\n\treturn (dispatch & LOWPAN_DISPATCH_FRAG_MASK) == LOWPAN_DISPATCH_FRAG1;\n}\n\nstatic inline bool lowpan_is_fragn(u8 dispatch)\n{\n\treturn (dispatch & LOWPAN_DISPATCH_FRAG_MASK) == LOWPAN_DISPATCH_FRAGN;\n}\n\nstatic lowpan_rx_result lowpan_rx_h_frag(struct sk_buff *skb)\n{\n\tint ret;\n\n\tif (!(lowpan_is_frag1(*skb_network_header(skb)) ||\n\t      lowpan_is_fragn(*skb_network_header(skb))))\n\t\treturn RX_CONTINUE;\n\n\tret = lowpan_frag_rcv(skb, *skb_network_header(skb) &\n\t\t\t      LOWPAN_DISPATCH_FRAG_MASK);\n\tif (ret == 1)\n\t\treturn RX_QUEUED;\n\n\t \n\treturn RX_DROP;\n}\n\nint lowpan_iphc_decompress(struct sk_buff *skb)\n{\n\tstruct ieee802154_hdr hdr;\n\n\tif (ieee802154_hdr_peek_addrs(skb, &hdr) < 0)\n\t\treturn -EINVAL;\n\n\treturn lowpan_header_decompress(skb, skb->dev, &hdr.dest, &hdr.source);\n}\n\nstatic lowpan_rx_result lowpan_rx_h_iphc(struct sk_buff *skb)\n{\n\tint ret;\n\n\tif (!lowpan_is_iphc(*skb_network_header(skb)))\n\t\treturn RX_CONTINUE;\n\n\t \n\tlowpan_802154_cb(skb)->d_size = 0;\n\n\tret = lowpan_iphc_decompress(skb);\n\tif (ret < 0)\n\t\treturn RX_DROP_UNUSABLE;\n\n\treturn RX_QUEUED;\n}\n\nlowpan_rx_result lowpan_rx_h_ipv6(struct sk_buff *skb)\n{\n\tif (!lowpan_is_ipv6(*skb_network_header(skb)))\n\t\treturn RX_CONTINUE;\n\n\t \n\tskb_pull(skb, 1);\n\treturn RX_QUEUED;\n}\n\nstatic inline bool lowpan_is_esc(u8 dispatch)\n{\n\treturn dispatch == LOWPAN_DISPATCH_ESC;\n}\n\nstatic lowpan_rx_result lowpan_rx_h_esc(struct sk_buff *skb)\n{\n\tif (!lowpan_is_esc(*skb_network_header(skb)))\n\t\treturn RX_CONTINUE;\n\n\tnet_warn_ratelimited(\"%s: %s\\n\", skb->dev->name,\n\t\t\t     \"6LoWPAN ESC not supported\\n\");\n\n\treturn RX_DROP_UNUSABLE;\n}\n\nstatic inline bool lowpan_is_hc1(u8 dispatch)\n{\n\treturn dispatch == LOWPAN_DISPATCH_HC1;\n}\n\nstatic lowpan_rx_result lowpan_rx_h_hc1(struct sk_buff *skb)\n{\n\tif (!lowpan_is_hc1(*skb_network_header(skb)))\n\t\treturn RX_CONTINUE;\n\n\tnet_warn_ratelimited(\"%s: %s\\n\", skb->dev->name,\n\t\t\t     \"6LoWPAN HC1 not supported\\n\");\n\n\treturn RX_DROP_UNUSABLE;\n}\n\nstatic inline bool lowpan_is_dff(u8 dispatch)\n{\n\treturn dispatch == LOWPAN_DISPATCH_DFF;\n}\n\nstatic lowpan_rx_result lowpan_rx_h_dff(struct sk_buff *skb)\n{\n\tif (!lowpan_is_dff(*skb_network_header(skb)))\n\t\treturn RX_CONTINUE;\n\n\tnet_warn_ratelimited(\"%s: %s\\n\", skb->dev->name,\n\t\t\t     \"6LoWPAN DFF not supported\\n\");\n\n\treturn RX_DROP_UNUSABLE;\n}\n\nstatic inline bool lowpan_is_bc0(u8 dispatch)\n{\n\treturn dispatch == LOWPAN_DISPATCH_BC0;\n}\n\nstatic lowpan_rx_result lowpan_rx_h_bc0(struct sk_buff *skb)\n{\n\tif (!lowpan_is_bc0(*skb_network_header(skb)))\n\t\treturn RX_CONTINUE;\n\n\tnet_warn_ratelimited(\"%s: %s\\n\", skb->dev->name,\n\t\t\t     \"6LoWPAN BC0 not supported\\n\");\n\n\treturn RX_DROP_UNUSABLE;\n}\n\nstatic inline bool lowpan_is_mesh(u8 dispatch)\n{\n\treturn (dispatch & LOWPAN_DISPATCH_FIRST) == LOWPAN_DISPATCH_MESH;\n}\n\nstatic lowpan_rx_result lowpan_rx_h_mesh(struct sk_buff *skb)\n{\n\tif (!lowpan_is_mesh(*skb_network_header(skb)))\n\t\treturn RX_CONTINUE;\n\n\tnet_warn_ratelimited(\"%s: %s\\n\", skb->dev->name,\n\t\t\t     \"6LoWPAN MESH not supported\\n\");\n\n\treturn RX_DROP_UNUSABLE;\n}\n\nstatic int lowpan_invoke_rx_handlers(struct sk_buff *skb)\n{\n\tlowpan_rx_result res;\n\n#define CALL_RXH(rxh)\t\t\t\\\n\tdo {\t\t\t\t\\\n\t\tres = rxh(skb);\t\\\n\t\tif (res != RX_CONTINUE)\t\\\n\t\t\tgoto rxh_next;\t\\\n\t} while (0)\n\n\t \n\tCALL_RXH(lowpan_rx_h_iphc);\n\tCALL_RXH(lowpan_rx_h_frag);\n\tCALL_RXH(lowpan_rx_h_ipv6);\n\tCALL_RXH(lowpan_rx_h_esc);\n\tCALL_RXH(lowpan_rx_h_hc1);\n\tCALL_RXH(lowpan_rx_h_dff);\n\tCALL_RXH(lowpan_rx_h_bc0);\n\tCALL_RXH(lowpan_rx_h_mesh);\n\nrxh_next:\n\treturn lowpan_rx_handlers_result(skb, res);\n#undef CALL_RXH\n}\n\nstatic inline bool lowpan_is_nalp(u8 dispatch)\n{\n\treturn (dispatch & LOWPAN_DISPATCH_FIRST) == LOWPAN_DISPATCH_NALP;\n}\n\n \nstatic inline bool lowpan_is_reserved(u8 dispatch)\n{\n\treturn ((dispatch >= 0x44 && dispatch <= 0x4F) ||\n\t\t(dispatch >= 0x51 && dispatch <= 0x5F) ||\n\t\t(dispatch >= 0xc8 && dispatch <= 0xdf) ||\n\t\tdispatch >= 0xe8);\n}\n\n \nstatic inline bool lowpan_rx_h_check(struct sk_buff *skb)\n{\n\t__le16 fc = ieee802154_get_fc_from_skb(skb);\n\n\t \n\tif (!ieee802154_is_data(fc) ||\n\t    !ieee802154_skb_is_intra_pan_addressing(fc, skb))\n\t\treturn false;\n\n\t \n\tif (unlikely(!skb->len))\n\t\treturn false;\n\n\tif (lowpan_is_nalp(*skb_network_header(skb)) ||\n\t    lowpan_is_reserved(*skb_network_header(skb)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int lowpan_rcv(struct sk_buff *skb, struct net_device *wdev,\n\t\t      struct packet_type *pt, struct net_device *orig_wdev)\n{\n\tstruct net_device *ldev;\n\n\tif (wdev->type != ARPHRD_IEEE802154 ||\n\t    skb->pkt_type == PACKET_OTHERHOST ||\n\t    !lowpan_rx_h_check(skb))\n\t\tgoto drop;\n\n\tldev = wdev->ieee802154_ptr->lowpan_dev;\n\tif (!ldev || !netif_running(ldev))\n\t\tgoto drop;\n\n\t \n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out;\n\tskb->dev = ldev;\n\n\t \n\tif (lowpan_is_frag1(*skb_network_header(skb)) ||\n\t    lowpan_is_iphc(*skb_network_header(skb))) {\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t}\n\n\treturn lowpan_invoke_rx_handlers(skb);\n\ndrop:\n\tkfree_skb(skb);\nout:\n\treturn NET_RX_DROP;\n}\n\nstatic struct packet_type lowpan_packet_type = {\n\t.type = htons(ETH_P_IEEE802154),\n\t.func = lowpan_rcv,\n};\n\nvoid lowpan_rx_init(void)\n{\n\tdev_add_pack(&lowpan_packet_type);\n}\n\nvoid lowpan_rx_exit(void)\n{\n\tdev_remove_pack(&lowpan_packet_type);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}