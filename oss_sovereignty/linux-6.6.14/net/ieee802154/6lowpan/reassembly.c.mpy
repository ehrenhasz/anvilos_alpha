{
  "module_name": "reassembly.c",
  "hash_id": "7618a3cf2620b99a9ec7994126d238755d8fdb1014db39fb841a6c47ba2786f3",
  "original_prompt": "Ingested from linux-6.6.14/net/ieee802154/6lowpan/reassembly.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"6LoWPAN: \" fmt\n\n#include <linux/net.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include <net/ieee802154_netdev.h>\n#include <net/6lowpan.h>\n#include <net/ipv6_frag.h>\n#include <net/inet_frag.h>\n#include <net/ip.h>\n\n#include \"6lowpan_i.h\"\n\nstatic const char lowpan_frags_cache_name[] = \"lowpan-frags\";\n\nstatic struct inet_frags lowpan_frags;\n\nstatic int lowpan_frag_reasm(struct lowpan_frag_queue *fq, struct sk_buff *skb,\n\t\t\t     struct sk_buff *prev,  struct net_device *ldev);\n\nstatic void lowpan_frag_init(struct inet_frag_queue *q, const void *a)\n{\n\tconst struct frag_lowpan_compare_key *key = a;\n\n\tBUILD_BUG_ON(sizeof(*key) > sizeof(q->key));\n\tmemcpy(&q->key, key, sizeof(*key));\n}\n\nstatic void lowpan_frag_expire(struct timer_list *t)\n{\n\tstruct inet_frag_queue *frag = from_timer(frag, t, timer);\n\tstruct frag_queue *fq;\n\n\tfq = container_of(frag, struct frag_queue, q);\n\n\tspin_lock(&fq->q.lock);\n\n\tif (fq->q.flags & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tinet_frag_kill(&fq->q);\nout:\n\tspin_unlock(&fq->q.lock);\n\tinet_frag_put(&fq->q);\n}\n\nstatic inline struct lowpan_frag_queue *\nfq_find(struct net *net, const struct lowpan_802154_cb *cb,\n\tconst struct ieee802154_addr *src,\n\tconst struct ieee802154_addr *dst)\n{\n\tstruct netns_ieee802154_lowpan *ieee802154_lowpan =\n\t\tnet_ieee802154_lowpan(net);\n\tstruct frag_lowpan_compare_key key = {};\n\tstruct inet_frag_queue *q;\n\n\tkey.tag = cb->d_tag;\n\tkey.d_size = cb->d_size;\n\tkey.src = *src;\n\tkey.dst = *dst;\n\n\tq = inet_frag_find(ieee802154_lowpan->fqdir, &key);\n\tif (!q)\n\t\treturn NULL;\n\n\treturn container_of(q, struct lowpan_frag_queue, q);\n}\n\nstatic int lowpan_frag_queue(struct lowpan_frag_queue *fq,\n\t\t\t     struct sk_buff *skb, u8 frag_type)\n{\n\tstruct sk_buff *prev_tail;\n\tstruct net_device *ldev;\n\tint end, offset, err;\n\n\t \n\tBUILD_BUG_ON(sizeof(struct lowpan_802154_cb) > sizeof(struct inet_skb_parm));\n\tBUILD_BUG_ON(sizeof(struct lowpan_802154_cb) > sizeof(struct inet6_skb_parm));\n\n\tif (fq->q.flags & INET_FRAG_COMPLETE)\n\t\tgoto err;\n\n\toffset = lowpan_802154_cb(skb)->d_offset << 3;\n\tend = lowpan_802154_cb(skb)->d_size;\n\n\t \n\tif (offset + skb->len == end) {\n\t\t \n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.flags & INET_FRAG_LAST_IN) && end != fq->q.len))\n\t\t\tgoto err;\n\t\tfq->q.flags |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\tif (end > fq->q.len) {\n\t\t\t \n\t\t\tif (fq->q.flags & INET_FRAG_LAST_IN)\n\t\t\t\tgoto err;\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tldev = skb->dev;\n\tif (ldev)\n\t\tskb->dev = NULL;\n\tbarrier();\n\n\tprev_tail = fq->q.fragments_tail;\n\terr = inet_frag_queue_insert(&fq->q, skb, offset, end);\n\tif (err)\n\t\tgoto err;\n\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.mono_delivery_time = skb->mono_delivery_time;\n\tif (frag_type == LOWPAN_DISPATCH_FRAG1)\n\t\tfq->q.flags |= INET_FRAG_FIRST_IN;\n\n\tfq->q.meat += skb->len;\n\tadd_frag_mem_limit(fq->q.fqdir, skb->truesize);\n\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len) {\n\t\tint res;\n\t\tunsigned long orefdst = skb->_skb_refdst;\n\n\t\tskb->_skb_refdst = 0UL;\n\t\tres = lowpan_frag_reasm(fq, skb, prev_tail, ldev);\n\t\tskb->_skb_refdst = orefdst;\n\t\treturn res;\n\t}\n\tskb_dst_drop(skb);\n\n\treturn -1;\nerr:\n\tkfree_skb(skb);\n\treturn -1;\n}\n\n \nstatic int lowpan_frag_reasm(struct lowpan_frag_queue *fq, struct sk_buff *skb,\n\t\t\t     struct sk_buff *prev_tail, struct net_device *ldev)\n{\n\tvoid *reasm_data;\n\n\tinet_frag_kill(&fq->q);\n\n\treasm_data = inet_frag_reasm_prepare(&fq->q, skb, prev_tail);\n\tif (!reasm_data)\n\t\tgoto out_oom;\n\tinet_frag_reasm_finish(&fq->q, skb, reasm_data, false);\n\n\tskb->dev = ldev;\n\tskb->tstamp = fq->q.stamp;\n\tfq->q.rb_fragments = RB_ROOT;\n\tfq->q.fragments_tail = NULL;\n\tfq->q.last_run_head = NULL;\n\n\treturn 1;\nout_oom:\n\tnet_dbg_ratelimited(\"lowpan_frag_reasm: no memory for reassembly\\n\");\n\treturn -1;\n}\n\nstatic int lowpan_frag_rx_handlers_result(struct sk_buff *skb,\n\t\t\t\t\t  lowpan_rx_result res)\n{\n\tswitch (res) {\n\tcase RX_QUEUED:\n\t\treturn NET_RX_SUCCESS;\n\tcase RX_CONTINUE:\n\t\t \n\t\tnet_warn_ratelimited(\"%s: received unknown dispatch\\n\",\n\t\t\t\t     __func__);\n\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\treturn NET_RX_DROP;\n\t}\n}\n\nstatic lowpan_rx_result lowpan_frag_rx_h_iphc(struct sk_buff *skb)\n{\n\tint ret;\n\n\tif (!lowpan_is_iphc(*skb_network_header(skb)))\n\t\treturn RX_CONTINUE;\n\n\tret = lowpan_iphc_decompress(skb);\n\tif (ret < 0)\n\t\treturn RX_DROP;\n\n\treturn RX_QUEUED;\n}\n\nstatic int lowpan_invoke_frag_rx_handlers(struct sk_buff *skb)\n{\n\tlowpan_rx_result res;\n\n#define CALL_RXH(rxh)\t\t\t\\\n\tdo {\t\t\t\t\\\n\t\tres = rxh(skb);\t\\\n\t\tif (res != RX_CONTINUE)\t\\\n\t\t\tgoto rxh_next;\t\\\n\t} while (0)\n\n\t \n\tCALL_RXH(lowpan_frag_rx_h_iphc);\n\tCALL_RXH(lowpan_rx_h_ipv6);\n\nrxh_next:\n\treturn lowpan_frag_rx_handlers_result(skb, res);\n#undef CALL_RXH\n}\n\n#define LOWPAN_FRAG_DGRAM_SIZE_HIGH_MASK\t0x07\n#define LOWPAN_FRAG_DGRAM_SIZE_HIGH_SHIFT\t8\n\nstatic int lowpan_get_cb(struct sk_buff *skb, u8 frag_type,\n\t\t\t struct lowpan_802154_cb *cb)\n{\n\tbool fail;\n\tu8 high = 0, low = 0;\n\t__be16 d_tag = 0;\n\n\tfail = lowpan_fetch_skb(skb, &high, 1);\n\tfail |= lowpan_fetch_skb(skb, &low, 1);\n\t \n\tcb->d_size = (high & LOWPAN_FRAG_DGRAM_SIZE_HIGH_MASK) <<\n\t\tLOWPAN_FRAG_DGRAM_SIZE_HIGH_SHIFT | low;\n\tfail |= lowpan_fetch_skb(skb, &d_tag, 2);\n\tcb->d_tag = ntohs(d_tag);\n\n\tif (frag_type == LOWPAN_DISPATCH_FRAGN) {\n\t\tfail |= lowpan_fetch_skb(skb, &cb->d_offset, 1);\n\t} else {\n\t\tskb_reset_network_header(skb);\n\t\tcb->d_offset = 0;\n\t\t \n\t\tfail |= cb->d_size < sizeof(struct ipv6hdr);\n\t\t \n\t\tfail |= !skb->len;\n\t}\n\n\tif (unlikely(fail))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint lowpan_frag_rcv(struct sk_buff *skb, u8 frag_type)\n{\n\tstruct lowpan_frag_queue *fq;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct lowpan_802154_cb *cb = lowpan_802154_cb(skb);\n\tstruct ieee802154_hdr hdr = {};\n\tint err;\n\n\tif (ieee802154_hdr_peek_addrs(skb, &hdr) < 0)\n\t\tgoto err;\n\n\terr = lowpan_get_cb(skb, frag_type, cb);\n\tif (err < 0)\n\t\tgoto err;\n\n\tif (frag_type == LOWPAN_DISPATCH_FRAG1) {\n\t\terr = lowpan_invoke_frag_rx_handlers(skb);\n\t\tif (err == NET_RX_DROP)\n\t\t\tgoto err;\n\t}\n\n\tif (cb->d_size > IPV6_MIN_MTU) {\n\t\tnet_warn_ratelimited(\"lowpan_frag_rcv: datagram size exceeds MTU\\n\");\n\t\tgoto err;\n\t}\n\n\tfq = fq_find(net, cb, &hdr.source, &hdr.dest);\n\tif (fq != NULL) {\n\t\tint ret;\n\n\t\tspin_lock(&fq->q.lock);\n\t\tret = lowpan_frag_queue(fq, skb, frag_type);\n\t\tspin_unlock(&fq->q.lock);\n\n\t\tinet_frag_put(&fq->q);\n\t\treturn ret;\n\t}\n\nerr:\n\tkfree_skb(skb);\n\treturn -1;\n}\n\n#ifdef CONFIG_SYSCTL\n\nstatic struct ctl_table lowpan_frags_ns_ctl_table[] = {\n\t{\n\t\t.procname\t= \"6lowpanfrag_high_thresh\",\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"6lowpanfrag_low_thresh\",\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"6lowpanfrag_time\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ }\n};\n\n \nstatic int lowpan_frags_secret_interval_unused;\nstatic struct ctl_table lowpan_frags_ctl_table[] = {\n\t{\n\t\t.procname\t= \"6lowpanfrag_secret_interval\",\n\t\t.data\t\t= &lowpan_frags_secret_interval_unused,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ }\n};\n\nstatic int __net_init lowpan_frags_ns_sysctl_register(struct net *net)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_table_header *hdr;\n\tstruct netns_ieee802154_lowpan *ieee802154_lowpan =\n\t\tnet_ieee802154_lowpan(net);\n\tsize_t table_size = ARRAY_SIZE(lowpan_frags_ns_ctl_table);\n\n\ttable = lowpan_frags_ns_ctl_table;\n\tif (!net_eq(net, &init_net)) {\n\t\ttable = kmemdup(table, sizeof(lowpan_frags_ns_ctl_table),\n\t\t\t\tGFP_KERNEL);\n\t\tif (table == NULL)\n\t\t\tgoto err_alloc;\n\n\t\t \n\t\tif (net->user_ns != &init_user_ns) {\n\t\t\ttable[0].procname = NULL;\n\t\t\ttable_size = 0;\n\t\t}\n\t}\n\n\ttable[0].data\t= &ieee802154_lowpan->fqdir->high_thresh;\n\ttable[0].extra1\t= &ieee802154_lowpan->fqdir->low_thresh;\n\ttable[1].data\t= &ieee802154_lowpan->fqdir->low_thresh;\n\ttable[1].extra2\t= &ieee802154_lowpan->fqdir->high_thresh;\n\ttable[2].data\t= &ieee802154_lowpan->fqdir->timeout;\n\n\thdr = register_net_sysctl_sz(net, \"net/ieee802154/6lowpan\", table,\n\t\t\t\t     table_size);\n\tif (hdr == NULL)\n\t\tgoto err_reg;\n\n\tieee802154_lowpan->sysctl.frags_hdr = hdr;\n\treturn 0;\n\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit lowpan_frags_ns_sysctl_unregister(struct net *net)\n{\n\tstruct ctl_table *table;\n\tstruct netns_ieee802154_lowpan *ieee802154_lowpan =\n\t\tnet_ieee802154_lowpan(net);\n\n\ttable = ieee802154_lowpan->sysctl.frags_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(ieee802154_lowpan->sysctl.frags_hdr);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n}\n\nstatic struct ctl_table_header *lowpan_ctl_header;\n\nstatic int __init lowpan_frags_sysctl_register(void)\n{\n\tlowpan_ctl_header = register_net_sysctl(&init_net,\n\t\t\t\t\t\t\"net/ieee802154/6lowpan\",\n\t\t\t\t\t\tlowpan_frags_ctl_table);\n\treturn lowpan_ctl_header == NULL ? -ENOMEM : 0;\n}\n\nstatic void lowpan_frags_sysctl_unregister(void)\n{\n\tunregister_net_sysctl_table(lowpan_ctl_header);\n}\n#else\nstatic inline int lowpan_frags_ns_sysctl_register(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void lowpan_frags_ns_sysctl_unregister(struct net *net)\n{\n}\n\nstatic inline int __init lowpan_frags_sysctl_register(void)\n{\n\treturn 0;\n}\n\nstatic inline void lowpan_frags_sysctl_unregister(void)\n{\n}\n#endif\n\nstatic int __net_init lowpan_frags_init_net(struct net *net)\n{\n\tstruct netns_ieee802154_lowpan *ieee802154_lowpan =\n\t\tnet_ieee802154_lowpan(net);\n\tint res;\n\n\n\tres = fqdir_init(&ieee802154_lowpan->fqdir, &lowpan_frags, net);\n\tif (res < 0)\n\t\treturn res;\n\n\tieee802154_lowpan->fqdir->high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tieee802154_lowpan->fqdir->low_thresh = IPV6_FRAG_LOW_THRESH;\n\tieee802154_lowpan->fqdir->timeout = IPV6_FRAG_TIMEOUT;\n\n\tres = lowpan_frags_ns_sysctl_register(net);\n\tif (res < 0)\n\t\tfqdir_exit(ieee802154_lowpan->fqdir);\n\treturn res;\n}\n\nstatic void __net_exit lowpan_frags_pre_exit_net(struct net *net)\n{\n\tstruct netns_ieee802154_lowpan *ieee802154_lowpan =\n\t\tnet_ieee802154_lowpan(net);\n\n\tfqdir_pre_exit(ieee802154_lowpan->fqdir);\n}\n\nstatic void __net_exit lowpan_frags_exit_net(struct net *net)\n{\n\tstruct netns_ieee802154_lowpan *ieee802154_lowpan =\n\t\tnet_ieee802154_lowpan(net);\n\n\tlowpan_frags_ns_sysctl_unregister(net);\n\tfqdir_exit(ieee802154_lowpan->fqdir);\n}\n\nstatic struct pernet_operations lowpan_frags_ops = {\n\t.init\t\t= lowpan_frags_init_net,\n\t.pre_exit\t= lowpan_frags_pre_exit_net,\n\t.exit\t\t= lowpan_frags_exit_net,\n};\n\nstatic u32 lowpan_key_hashfn(const void *data, u32 len, u32 seed)\n{\n\treturn jhash2(data,\n\t\t      sizeof(struct frag_lowpan_compare_key) / sizeof(u32), seed);\n}\n\nstatic u32 lowpan_obj_hashfn(const void *data, u32 len, u32 seed)\n{\n\tconst struct inet_frag_queue *fq = data;\n\n\treturn jhash2((const u32 *)&fq->key,\n\t\t      sizeof(struct frag_lowpan_compare_key) / sizeof(u32), seed);\n}\n\nstatic int lowpan_obj_cmpfn(struct rhashtable_compare_arg *arg, const void *ptr)\n{\n\tconst struct frag_lowpan_compare_key *key = arg->key;\n\tconst struct inet_frag_queue *fq = ptr;\n\n\treturn !!memcmp(&fq->key, key, sizeof(*key));\n}\n\nstatic const struct rhashtable_params lowpan_rhash_params = {\n\t.head_offset\t\t= offsetof(struct inet_frag_queue, node),\n\t.hashfn\t\t\t= lowpan_key_hashfn,\n\t.obj_hashfn\t\t= lowpan_obj_hashfn,\n\t.obj_cmpfn\t\t= lowpan_obj_cmpfn,\n\t.automatic_shrinking\t= true,\n};\n\nint __init lowpan_net_frag_init(void)\n{\n\tint ret;\n\n\tlowpan_frags.constructor = lowpan_frag_init;\n\tlowpan_frags.destructor = NULL;\n\tlowpan_frags.qsize = sizeof(struct frag_queue);\n\tlowpan_frags.frag_expire = lowpan_frag_expire;\n\tlowpan_frags.frags_cache_name = lowpan_frags_cache_name;\n\tlowpan_frags.rhash_params = lowpan_rhash_params;\n\tret = inet_frags_init(&lowpan_frags);\n\tif (ret)\n\t\tgoto out;\n\n\tret = lowpan_frags_sysctl_register();\n\tif (ret)\n\t\tgoto err_sysctl;\n\n\tret = register_pernet_subsys(&lowpan_frags_ops);\n\tif (ret)\n\t\tgoto err_pernet;\nout:\n\treturn ret;\nerr_pernet:\n\tlowpan_frags_sysctl_unregister();\nerr_sysctl:\n\tinet_frags_fini(&lowpan_frags);\n\treturn ret;\n}\n\nvoid lowpan_net_frag_exit(void)\n{\n\tlowpan_frags_sysctl_unregister();\n\tunregister_pernet_subsys(&lowpan_frags_ops);\n\tinet_frags_fini(&lowpan_frags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}