{
  "module_name": "tx.c",
  "hash_id": "3c852498f29c178b122c1c6f40c388cc93b9a29fc2fc83beb34188db24146c93",
  "original_prompt": "Ingested from linux-6.6.14/net/ieee802154/6lowpan/tx.c",
  "human_readable_source": "\n\n#include <net/6lowpan.h>\n#include <net/ndisc.h>\n#include <net/ieee802154_netdev.h>\n#include <net/mac802154.h>\n\n#include \"6lowpan_i.h\"\n\n#define LOWPAN_FRAG1_HEAD_SIZE\t0x4\n#define LOWPAN_FRAGN_HEAD_SIZE\t0x5\n\nstruct lowpan_addr_info {\n\tstruct ieee802154_addr daddr;\n\tstruct ieee802154_addr saddr;\n};\n\nstatic inline struct\nlowpan_addr_info *lowpan_skb_priv(const struct sk_buff *skb)\n{\n\tWARN_ON_ONCE(skb_headroom(skb) < sizeof(struct lowpan_addr_info));\n\treturn (struct lowpan_addr_info *)(skb->data -\n\t\t\tsizeof(struct lowpan_addr_info));\n}\n\n \nint lowpan_header_create(struct sk_buff *skb, struct net_device *ldev,\n\t\t\t unsigned short type, const void *daddr,\n\t\t\t const void *saddr, unsigned int len)\n{\n\tstruct wpan_dev *wpan_dev = lowpan_802154_dev(ldev)->wdev->ieee802154_ptr;\n\tstruct lowpan_addr_info *info = lowpan_skb_priv(skb);\n\tstruct lowpan_802154_neigh *llneigh = NULL;\n\tconst struct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct neighbour *n;\n\n\tif (!daddr)\n\t\treturn -EINVAL;\n\n\t \n\tif (type != ETH_P_IPV6)\n\t\treturn 0;\n\n\t \n\tinfo->saddr.pan_id = wpan_dev->pan_id;\n\tinfo->daddr.pan_id = info->saddr.pan_id;\n\n\tif (!memcmp(daddr, ldev->broadcast, EUI64_ADDR_LEN)) {\n\t\tinfo->daddr.short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);\n\t\tinfo->daddr.mode = IEEE802154_ADDR_SHORT;\n\t} else {\n\t\t__le16 short_addr = cpu_to_le16(IEEE802154_ADDR_SHORT_UNSPEC);\n\n\t\tn = neigh_lookup(&nd_tbl, &hdr->daddr, ldev);\n\t\tif (n) {\n\t\t\tllneigh = lowpan_802154_neigh(neighbour_priv(n));\n\t\t\tread_lock_bh(&n->lock);\n\t\t\tshort_addr = llneigh->short_addr;\n\t\t\tread_unlock_bh(&n->lock);\n\t\t}\n\n\t\tif (llneigh &&\n\t\t    lowpan_802154_is_valid_src_short_addr(short_addr)) {\n\t\t\tinfo->daddr.short_addr = short_addr;\n\t\t\tinfo->daddr.mode = IEEE802154_ADDR_SHORT;\n\t\t} else {\n\t\t\tinfo->daddr.mode = IEEE802154_ADDR_LONG;\n\t\t\tieee802154_be64_to_le64(&info->daddr.extended_addr,\n\t\t\t\t\t\tdaddr);\n\t\t}\n\n\t\tif (n)\n\t\t\tneigh_release(n);\n\t}\n\n\tif (!saddr) {\n\t\tif (lowpan_802154_is_valid_src_short_addr(wpan_dev->short_addr)) {\n\t\t\tinfo->saddr.mode = IEEE802154_ADDR_SHORT;\n\t\t\tinfo->saddr.short_addr = wpan_dev->short_addr;\n\t\t} else {\n\t\t\tinfo->saddr.mode = IEEE802154_ADDR_LONG;\n\t\t\tinfo->saddr.extended_addr = wpan_dev->extended_addr;\n\t\t}\n\t} else {\n\t\tinfo->saddr.mode = IEEE802154_ADDR_LONG;\n\t\tieee802154_be64_to_le64(&info->saddr.extended_addr, saddr);\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff*\nlowpan_alloc_frag(struct sk_buff *skb, int size,\n\t\t  const struct ieee802154_hdr *master_hdr, bool frag1)\n{\n\tstruct net_device *wdev = lowpan_802154_dev(skb->dev)->wdev;\n\tstruct sk_buff *frag;\n\tint rc;\n\n\tfrag = alloc_skb(wdev->needed_headroom + wdev->needed_tailroom + size,\n\t\t\t GFP_ATOMIC);\n\n\tif (likely(frag)) {\n\t\tfrag->dev = wdev;\n\t\tfrag->priority = skb->priority;\n\t\tskb_reserve(frag, wdev->needed_headroom);\n\t\tskb_reset_network_header(frag);\n\t\t*mac_cb(frag) = *mac_cb(skb);\n\n\t\tif (frag1) {\n\t\t\tskb_put_data(frag, skb_mac_header(skb), skb->mac_len);\n\t\t} else {\n\t\t\trc = wpan_dev_hard_header(frag, wdev,\n\t\t\t\t\t\t  &master_hdr->dest,\n\t\t\t\t\t\t  &master_hdr->source, size);\n\t\t\tif (rc < 0) {\n\t\t\t\tkfree_skb(frag);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfrag = ERR_PTR(-ENOMEM);\n\t}\n\n\treturn frag;\n}\n\nstatic int\nlowpan_xmit_fragment(struct sk_buff *skb, const struct ieee802154_hdr *wpan_hdr,\n\t\t     u8 *frag_hdr, int frag_hdrlen,\n\t\t     int offset, int len, bool frag1)\n{\n\tstruct sk_buff *frag;\n\n\traw_dump_inline(__func__, \" fragment header\", frag_hdr, frag_hdrlen);\n\n\tfrag = lowpan_alloc_frag(skb, frag_hdrlen + len, wpan_hdr, frag1);\n\tif (IS_ERR(frag))\n\t\treturn PTR_ERR(frag);\n\n\tskb_put_data(frag, frag_hdr, frag_hdrlen);\n\tskb_put_data(frag, skb_network_header(skb) + offset, len);\n\n\traw_dump_table(__func__, \" fragment dump\", frag->data, frag->len);\n\n\treturn dev_queue_xmit(frag);\n}\n\nstatic int\nlowpan_xmit_fragmented(struct sk_buff *skb, struct net_device *ldev,\n\t\t       const struct ieee802154_hdr *wpan_hdr, u16 dgram_size,\n\t\t       u16 dgram_offset)\n{\n\t__be16 frag_tag;\n\tu8 frag_hdr[5];\n\tint frag_cap, frag_len, payload_cap, rc;\n\tint skb_unprocessed, skb_offset;\n\n\tfrag_tag = htons(lowpan_802154_dev(ldev)->fragment_tag);\n\tlowpan_802154_dev(ldev)->fragment_tag++;\n\n\tfrag_hdr[0] = LOWPAN_DISPATCH_FRAG1 | ((dgram_size >> 8) & 0x07);\n\tfrag_hdr[1] = dgram_size & 0xff;\n\tmemcpy(frag_hdr + 2, &frag_tag, sizeof(frag_tag));\n\n\tpayload_cap = ieee802154_max_payload(wpan_hdr);\n\n\tfrag_len = round_down(payload_cap - LOWPAN_FRAG1_HEAD_SIZE -\n\t\t\t      skb_network_header_len(skb), 8);\n\n\tskb_offset = skb_network_header_len(skb);\n\tskb_unprocessed = skb->len - skb->mac_len - skb_offset;\n\n\trc = lowpan_xmit_fragment(skb, wpan_hdr, frag_hdr,\n\t\t\t\t  LOWPAN_FRAG1_HEAD_SIZE, 0,\n\t\t\t\t  frag_len + skb_network_header_len(skb),\n\t\t\t\t  true);\n\tif (rc) {\n\t\tpr_debug(\"%s unable to send FRAG1 packet (tag: %d)\",\n\t\t\t __func__, ntohs(frag_tag));\n\t\tgoto err;\n\t}\n\n\tfrag_hdr[0] &= ~LOWPAN_DISPATCH_FRAG1;\n\tfrag_hdr[0] |= LOWPAN_DISPATCH_FRAGN;\n\tfrag_cap = round_down(payload_cap - LOWPAN_FRAGN_HEAD_SIZE, 8);\n\n\tdo {\n\t\tdgram_offset += frag_len;\n\t\tskb_offset += frag_len;\n\t\tskb_unprocessed -= frag_len;\n\t\tfrag_len = min(frag_cap, skb_unprocessed);\n\n\t\tfrag_hdr[4] = dgram_offset >> 3;\n\n\t\trc = lowpan_xmit_fragment(skb, wpan_hdr, frag_hdr,\n\t\t\t\t\t  LOWPAN_FRAGN_HEAD_SIZE, skb_offset,\n\t\t\t\t\t  frag_len, false);\n\t\tif (rc) {\n\t\t\tpr_debug(\"%s unable to send a FRAGN packet. (tag: %d, offset: %d)\\n\",\n\t\t\t\t __func__, ntohs(frag_tag), skb_offset);\n\t\t\tgoto err;\n\t\t}\n\t} while (skb_unprocessed > frag_cap);\n\n\tldev->stats.tx_packets++;\n\tldev->stats.tx_bytes += dgram_size;\n\tconsume_skb(skb);\n\treturn NET_XMIT_SUCCESS;\n\nerr:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\nstatic int lowpan_header(struct sk_buff *skb, struct net_device *ldev,\n\t\t\t u16 *dgram_size, u16 *dgram_offset)\n{\n\tstruct wpan_dev *wpan_dev = lowpan_802154_dev(ldev)->wdev->ieee802154_ptr;\n\tstruct ieee802154_mac_cb *cb = mac_cb_init(skb);\n\tstruct lowpan_addr_info info;\n\n\tmemcpy(&info, lowpan_skb_priv(skb), sizeof(info));\n\n\t*dgram_size = skb->len;\n\tlowpan_header_compress(skb, ldev, &info.daddr, &info.saddr);\n\t \n\t*dgram_offset = (*dgram_size - skb->len) + skb_network_header_len(skb);\n\n\tcb->type = IEEE802154_FC_TYPE_DATA;\n\n\tif (info.daddr.mode == IEEE802154_ADDR_SHORT &&\n\t    ieee802154_is_broadcast_short_addr(info.daddr.short_addr))\n\t\tcb->ackreq = false;\n\telse\n\t\tcb->ackreq = wpan_dev->ackreq;\n\n\treturn wpan_dev_hard_header(skb, lowpan_802154_dev(ldev)->wdev,\n\t\t\t\t    &info.daddr, &info.saddr, 0);\n}\n\nnetdev_tx_t lowpan_xmit(struct sk_buff *skb, struct net_device *ldev)\n{\n\tstruct ieee802154_hdr wpan_hdr;\n\tint max_single, ret;\n\tu16 dgram_size, dgram_offset;\n\n\tpr_debug(\"package xmit\\n\");\n\n\tWARN_ON_ONCE(skb->len > IPV6_MIN_MTU);\n\n\t \n\tif (unlikely(skb_headroom(skb) < ldev->needed_headroom ||\n\t\t     skb_tailroom(skb) < ldev->needed_tailroom)) {\n\t\tstruct sk_buff *nskb;\n\n\t\tnskb = skb_copy_expand(skb, ldev->needed_headroom,\n\t\t\t\t       ldev->needed_tailroom, GFP_ATOMIC);\n\t\tif (likely(nskb)) {\n\t\t\tconsume_skb(skb);\n\t\t\tskb = nskb;\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t\treturn NET_XMIT_DROP;\n\t\t}\n\t} else {\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn NET_XMIT_DROP;\n\t}\n\n\tret = lowpan_header(skb, ldev, &dgram_size, &dgram_offset);\n\tif (ret < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\tif (ieee802154_hdr_peek(skb, &wpan_hdr) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\tmax_single = ieee802154_max_payload(&wpan_hdr);\n\n\tif (skb_tail_pointer(skb) - skb_network_header(skb) <= max_single) {\n\t\tskb->dev = lowpan_802154_dev(ldev)->wdev;\n\t\tldev->stats.tx_packets++;\n\t\tldev->stats.tx_bytes += dgram_size;\n\t\treturn dev_queue_xmit(skb);\n\t} else {\n\t\tnetdev_tx_t rc;\n\n\t\tpr_debug(\"frame is too big, fragmentation is needed\\n\");\n\t\trc = lowpan_xmit_fragmented(skb, ldev, &wpan_hdr, dgram_size,\n\t\t\t\t\t    dgram_offset);\n\n\t\treturn rc < 0 ? NET_XMIT_DROP : rc;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}