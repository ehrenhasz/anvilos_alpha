{
  "module_name": "core.c",
  "hash_id": "4c643a5e4712079a848f25794d1b70fb5c122b0ff5061c1d50f8fc9b96293c48",
  "original_prompt": "Ingested from linux-6.6.14/net/ieee802154/6lowpan/core.c",
  "human_readable_source": " \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/ieee802154.h>\n#include <linux/if_arp.h>\n\n#include <net/ipv6.h>\n\n#include \"6lowpan_i.h\"\n\nstatic int open_count;\n\nstatic const struct header_ops lowpan_header_ops = {\n\t.create\t= lowpan_header_create,\n};\n\nstatic int lowpan_dev_init(struct net_device *ldev)\n{\n\tnetdev_lockdep_set_classes(ldev);\n\n\treturn 0;\n}\n\nstatic int lowpan_open(struct net_device *dev)\n{\n\tif (!open_count)\n\t\tlowpan_rx_init();\n\topen_count++;\n\treturn 0;\n}\n\nstatic int lowpan_stop(struct net_device *dev)\n{\n\topen_count--;\n\tif (!open_count)\n\t\tlowpan_rx_exit();\n\treturn 0;\n}\n\nstatic int lowpan_neigh_construct(struct net_device *dev, struct neighbour *n)\n{\n\tstruct lowpan_802154_neigh *neigh = lowpan_802154_neigh(neighbour_priv(n));\n\n\t \n\tneigh->short_addr = cpu_to_le16(IEEE802154_ADDR_SHORT_UNSPEC);\n\treturn 0;\n}\n\nstatic int lowpan_get_iflink(const struct net_device *dev)\n{\n\treturn lowpan_802154_dev(dev)->wdev->ifindex;\n}\n\nstatic const struct net_device_ops lowpan_netdev_ops = {\n\t.ndo_init\t\t= lowpan_dev_init,\n\t.ndo_start_xmit\t\t= lowpan_xmit,\n\t.ndo_open\t\t= lowpan_open,\n\t.ndo_stop\t\t= lowpan_stop,\n\t.ndo_neigh_construct    = lowpan_neigh_construct,\n\t.ndo_get_iflink         = lowpan_get_iflink,\n};\n\nstatic void lowpan_setup(struct net_device *ldev)\n{\n\tmemset(ldev->broadcast, 0xff, IEEE802154_ADDR_LEN);\n\t \n\tldev->hard_header_len\t= sizeof(struct ipv6hdr);\n\tldev->flags\t\t= IFF_BROADCAST | IFF_MULTICAST;\n\tldev->priv_flags\t|= IFF_NO_QUEUE;\n\n\tldev->netdev_ops\t= &lowpan_netdev_ops;\n\tldev->header_ops\t= &lowpan_header_ops;\n\tldev->needs_free_netdev\t= true;\n\tldev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n\nstatic int lowpan_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != IEEE802154_ADDR_LEN)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int lowpan_newlink(struct net *src_net, struct net_device *ldev,\n\t\t\t  struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_device *wdev;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tpr_debug(\"adding new link\\n\");\n\n\tif (!tb[IFLA_LINK])\n\t\treturn -EINVAL;\n\t \n\twdev = dev_get_by_index(dev_net(ldev), nla_get_u32(tb[IFLA_LINK]));\n\tif (!wdev)\n\t\treturn -ENODEV;\n\tif (wdev->type != ARPHRD_IEEE802154) {\n\t\tdev_put(wdev);\n\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->ieee802154_ptr->lowpan_dev) {\n\t\tdev_put(wdev);\n\t\treturn -EBUSY;\n\t}\n\n\tlowpan_802154_dev(ldev)->wdev = wdev;\n\t \n\t__dev_addr_set(ldev, wdev->dev_addr, IEEE802154_ADDR_LEN);\n\t \n\tldev->needed_headroom = LOWPAN_IPHC_MAX_HEADER_LEN +\n\t\t\t\twdev->needed_headroom;\n\tldev->needed_tailroom = wdev->needed_tailroom;\n\n\tldev->neigh_priv_len = sizeof(struct lowpan_802154_neigh);\n\n\tret = lowpan_register_netdevice(ldev, LOWPAN_LLTYPE_IEEE802154);\n\tif (ret < 0) {\n\t\tdev_put(wdev);\n\t\treturn ret;\n\t}\n\n\twdev->ieee802154_ptr->lowpan_dev = ldev;\n\treturn 0;\n}\n\nstatic void lowpan_dellink(struct net_device *ldev, struct list_head *head)\n{\n\tstruct net_device *wdev = lowpan_802154_dev(ldev)->wdev;\n\n\tASSERT_RTNL();\n\n\twdev->ieee802154_ptr->lowpan_dev = NULL;\n\tlowpan_unregister_netdevice(ldev);\n\tdev_put(wdev);\n}\n\nstatic struct rtnl_link_ops lowpan_link_ops __read_mostly = {\n\t.kind\t\t= \"lowpan\",\n\t.priv_size\t= LOWPAN_PRIV_SIZE(sizeof(struct lowpan_802154_dev)),\n\t.setup\t\t= lowpan_setup,\n\t.newlink\t= lowpan_newlink,\n\t.dellink\t= lowpan_dellink,\n\t.validate\t= lowpan_validate,\n};\n\nstatic inline int __init lowpan_netlink_init(void)\n{\n\treturn rtnl_link_register(&lowpan_link_ops);\n}\n\nstatic inline void lowpan_netlink_fini(void)\n{\n\trtnl_link_unregister(&lowpan_link_ops);\n}\n\nstatic int lowpan_device_event(struct notifier_block *unused,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct net_device *ndev = netdev_notifier_info_to_dev(ptr);\n\tstruct wpan_dev *wpan_dev;\n\n\tif (ndev->type != ARPHRD_IEEE802154)\n\t\treturn NOTIFY_DONE;\n\twpan_dev = ndev->ieee802154_ptr;\n\tif (!wpan_dev)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\t \n\t\tif (wpan_dev->lowpan_dev)\n\t\t\tlowpan_dellink(wpan_dev->lowpan_dev, NULL);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block lowpan_dev_notifier = {\n\t.notifier_call = lowpan_device_event,\n};\n\nstatic int __init lowpan_init_module(void)\n{\n\tint err = 0;\n\n\terr = lowpan_net_frag_init();\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = lowpan_netlink_init();\n\tif (err < 0)\n\t\tgoto out_frag;\n\n\terr = register_netdevice_notifier(&lowpan_dev_notifier);\n\tif (err < 0)\n\t\tgoto out_pack;\n\n\treturn 0;\n\nout_pack:\n\tlowpan_netlink_fini();\nout_frag:\n\tlowpan_net_frag_exit();\nout:\n\treturn err;\n}\n\nstatic void __exit lowpan_cleanup_module(void)\n{\n\tlowpan_netlink_fini();\n\n\tlowpan_net_frag_exit();\n\n\tunregister_netdevice_notifier(&lowpan_dev_notifier);\n}\n\nmodule_init(lowpan_init_module);\nmodule_exit(lowpan_cleanup_module);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"lowpan\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}