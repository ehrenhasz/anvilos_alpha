{
  "module_name": "socket.c",
  "hash_id": "615ea92e99c8509f4c4bd1b13dcc2c8d09f34e4c2b3e7b3ab8e04e870c62bd18",
  "original_prompt": "Ingested from linux-6.6.14/net/ieee802154/socket.c",
  "human_readable_source": "\n \n\n#include <linux/net.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/if.h>\n#include <linux/termios.h>\t \n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <net/datalink.h>\n#include <net/psnap.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <net/route.h>\n\n#include <net/af_ieee802154.h>\n#include <net/ieee802154_netdev.h>\n\n \nstatic struct net_device*\nieee802154_get_dev(struct net *net, const struct ieee802154_addr *addr)\n{\n\tstruct net_device *dev = NULL;\n\tstruct net_device *tmp;\n\t__le16 pan_id, short_addr;\n\tu8 hwaddr[IEEE802154_ADDR_LEN];\n\n\tswitch (addr->mode) {\n\tcase IEEE802154_ADDR_LONG:\n\t\tieee802154_devaddr_to_raw(hwaddr, addr->extended_addr);\n\t\trcu_read_lock();\n\t\tdev = dev_getbyhwaddr_rcu(net, ARPHRD_IEEE802154, hwaddr);\n\t\tdev_hold(dev);\n\t\trcu_read_unlock();\n\t\tbreak;\n\tcase IEEE802154_ADDR_SHORT:\n\t\tif (addr->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST) ||\n\t\t    addr->short_addr == cpu_to_le16(IEEE802154_ADDR_UNDEF) ||\n\t\t    addr->short_addr == cpu_to_le16(IEEE802154_ADDR_BROADCAST))\n\t\t\tbreak;\n\n\t\trtnl_lock();\n\n\t\tfor_each_netdev(net, tmp) {\n\t\t\tif (tmp->type != ARPHRD_IEEE802154)\n\t\t\t\tcontinue;\n\n\t\t\tpan_id = tmp->ieee802154_ptr->pan_id;\n\t\t\tshort_addr = tmp->ieee802154_ptr->short_addr;\n\t\t\tif (pan_id == addr->pan_id &&\n\t\t\t    short_addr == addr->short_addr) {\n\t\t\t\tdev = tmp;\n\t\t\t\tdev_hold(dev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trtnl_unlock();\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unsupported ieee802154 address type: %d\\n\",\n\t\t\taddr->mode);\n\t\tbreak;\n\t}\n\n\treturn dev;\n}\n\nstatic int ieee802154_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk) {\n\t\tsock->sk = NULL;\n\t\tsk->sk_prot->close(sk, 0);\n\t}\n\treturn 0;\n}\n\nstatic int ieee802154_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\t   size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\n\treturn sk->sk_prot->sendmsg(sk, msg, len);\n}\n\nstatic int ieee802154_sock_bind(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t\tint addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk->sk_prot->bind)\n\t\treturn sk->sk_prot->bind(sk, uaddr, addr_len);\n\n\treturn sock_no_bind(sock, uaddr, addr_len);\n}\n\nstatic int ieee802154_sock_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t\t   int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (addr_len < sizeof(uaddr->sa_family))\n\t\treturn -EINVAL;\n\n\tif (uaddr->sa_family == AF_UNSPEC)\n\t\treturn sk->sk_prot->disconnect(sk, flags);\n\n\treturn sk->sk_prot->connect(sk, uaddr, addr_len);\n}\n\nstatic int ieee802154_dev_ioctl(struct sock *sk, struct ifreq __user *arg,\n\t\t\t\tunsigned int cmd)\n{\n\tstruct ifreq ifr;\n\tint ret = -ENOIOCTLCMD;\n\tstruct net_device *dev;\n\n\tif (get_user_ifreq(&ifr, NULL, arg))\n\t\treturn -EFAULT;\n\n\tifr.ifr_name[IFNAMSIZ-1] = 0;\n\n\tdev_load(sock_net(sk), ifr.ifr_name);\n\tdev = dev_get_by_name(sock_net(sk), ifr.ifr_name);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (dev->type == ARPHRD_IEEE802154 && dev->netdev_ops->ndo_do_ioctl)\n\t\tret = dev->netdev_ops->ndo_do_ioctl(dev, &ifr, cmd);\n\n\tif (!ret && put_user_ifreq(&ifr, arg))\n\t\tret = -EFAULT;\n\tdev_put(dev);\n\n\treturn ret;\n}\n\nstatic int ieee802154_sock_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\n\tswitch (cmd) {\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\t\treturn ieee802154_dev_ioctl(sk, (struct ifreq __user *)arg,\n\t\t\t\tcmd);\n\tdefault:\n\t\tif (!sk->sk_prot->ioctl)\n\t\t\treturn -ENOIOCTLCMD;\n\t\treturn sk_ioctl(sk, cmd, (void __user *)arg);\n\t}\n}\n\n \nstatic HLIST_HEAD(raw_head);\nstatic DEFINE_RWLOCK(raw_lock);\n\nstatic int raw_hash(struct sock *sk)\n{\n\twrite_lock_bh(&raw_lock);\n\tsk_add_node(sk, &raw_head);\n\twrite_unlock_bh(&raw_lock);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\n\treturn 0;\n}\n\nstatic void raw_unhash(struct sock *sk)\n{\n\twrite_lock_bh(&raw_lock);\n\tif (sk_del_node_init(sk))\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\twrite_unlock_bh(&raw_lock);\n}\n\nstatic void raw_close(struct sock *sk, long timeout)\n{\n\tsk_common_release(sk);\n}\n\nstatic int raw_bind(struct sock *sk, struct sockaddr *_uaddr, int len)\n{\n\tstruct ieee802154_addr addr;\n\tstruct sockaddr_ieee802154 *uaddr = (struct sockaddr_ieee802154 *)_uaddr;\n\tint err = 0;\n\tstruct net_device *dev = NULL;\n\n\terr = ieee802154_sockaddr_check_size(uaddr, len);\n\tif (err < 0)\n\t\treturn err;\n\n\tuaddr = (struct sockaddr_ieee802154 *)_uaddr;\n\tif (uaddr->family != AF_IEEE802154)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tieee802154_addr_from_sa(&addr, &uaddr->addr);\n\tdev = ieee802154_get_dev(sock_net(sk), &addr);\n\tif (!dev) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tsk->sk_bound_dev_if = dev->ifindex;\n\tsk_dst_reset(sk);\n\n\tdev_put(dev);\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int raw_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t       int addr_len)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int raw_disconnect(struct sock *sk, int flags)\n{\n\treturn 0;\n}\n\nstatic int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tstruct net_device *dev;\n\tunsigned int mtu;\n\tstruct sk_buff *skb;\n\tint hlen, tlen;\n\tint err;\n\n\tif (msg->msg_flags & MSG_OOB) {\n\t\tpr_debug(\"msg->msg_flags = 0x%x\\n\", msg->msg_flags);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tlock_sock(sk);\n\tif (!sk->sk_bound_dev_if)\n\t\tdev = dev_getfirstbyhwtype(sock_net(sk), ARPHRD_IEEE802154);\n\telse\n\t\tdev = dev_get_by_index(sock_net(sk), sk->sk_bound_dev_if);\n\trelease_sock(sk);\n\n\tif (!dev) {\n\t\tpr_debug(\"no dev\\n\");\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tmtu = IEEE802154_MTU;\n\tpr_debug(\"name = %s, mtu = %u\\n\", dev->name, mtu);\n\n\tif (size > mtu) {\n\t\tpr_debug(\"size = %zu, mtu = %u\\n\", size, mtu);\n\t\terr = -EMSGSIZE;\n\t\tgoto out_dev;\n\t}\n\tif (!size) {\n\t\terr = 0;\n\t\tgoto out_dev;\n\t}\n\n\thlen = LL_RESERVED_SPACE(dev);\n\ttlen = dev->needed_tailroom;\n\tskb = sock_alloc_send_skb(sk, hlen + tlen + size,\n\t\t\t\t  msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto out_dev;\n\n\tskb_reserve(skb, hlen);\n\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\terr = memcpy_from_msg(skb_put(skb, size), msg, size);\n\tif (err < 0)\n\t\tgoto out_skb;\n\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_IEEE802154);\n\n\terr = dev_queue_xmit(skb);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\n\tdev_put(dev);\n\n\treturn err ?: size;\n\nout_skb:\n\tkfree_skb(skb);\nout_dev:\n\tdev_put(dev);\nout:\n\treturn err;\n}\n\nstatic int raw_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t       int flags, int *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_cmsgs(msg, sk, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}\n\nstatic int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NET_RX_DROP;\n\n\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn NET_RX_SUCCESS;\n}\n\nstatic void ieee802154_raw_deliver(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\n\tread_lock(&raw_lock);\n\tsk_for_each(sk, &raw_head) {\n\t\tbh_lock_sock(sk);\n\t\tif (!sk->sk_bound_dev_if ||\n\t\t    sk->sk_bound_dev_if == dev->ifindex) {\n\t\t\tstruct sk_buff *clone;\n\n\t\t\tclone = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (clone)\n\t\t\t\traw_rcv_skb(sk, clone);\n\t\t}\n\t\tbh_unlock_sock(sk);\n\t}\n\tread_unlock(&raw_lock);\n}\n\nstatic int raw_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int raw_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct proto ieee802154_raw_prot = {\n\t.name\t\t= \"IEEE-802.15.4-RAW\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct sock),\n\t.close\t\t= raw_close,\n\t.bind\t\t= raw_bind,\n\t.sendmsg\t= raw_sendmsg,\n\t.recvmsg\t= raw_recvmsg,\n\t.hash\t\t= raw_hash,\n\t.unhash\t\t= raw_unhash,\n\t.connect\t= raw_connect,\n\t.disconnect\t= raw_disconnect,\n\t.getsockopt\t= raw_getsockopt,\n\t.setsockopt\t= raw_setsockopt,\n};\n\nstatic const struct proto_ops ieee802154_raw_ops = {\n\t.family\t\t   = PF_IEEE802154,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = ieee802154_sock_release,\n\t.bind\t\t   = ieee802154_sock_bind,\n\t.connect\t   = ieee802154_sock_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = sock_no_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = ieee802154_sock_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = sock_no_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = ieee802154_sock_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n};\n\n \nstatic HLIST_HEAD(dgram_head);\nstatic DEFINE_RWLOCK(dgram_lock);\n\nstruct dgram_sock {\n\tstruct sock sk;\n\n\tstruct ieee802154_addr src_addr;\n\tstruct ieee802154_addr dst_addr;\n\n\tunsigned int bound:1;\n\tunsigned int connected:1;\n\tunsigned int want_ack:1;\n\tunsigned int want_lqi:1;\n\tunsigned int secen:1;\n\tunsigned int secen_override:1;\n\tunsigned int seclevel:3;\n\tunsigned int seclevel_override:1;\n};\n\nstatic inline struct dgram_sock *dgram_sk(const struct sock *sk)\n{\n\treturn container_of(sk, struct dgram_sock, sk);\n}\n\nstatic int dgram_hash(struct sock *sk)\n{\n\twrite_lock_bh(&dgram_lock);\n\tsk_add_node(sk, &dgram_head);\n\twrite_unlock_bh(&dgram_lock);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\n\treturn 0;\n}\n\nstatic void dgram_unhash(struct sock *sk)\n{\n\twrite_lock_bh(&dgram_lock);\n\tif (sk_del_node_init(sk))\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\twrite_unlock_bh(&dgram_lock);\n}\n\nstatic int dgram_init(struct sock *sk)\n{\n\tstruct dgram_sock *ro = dgram_sk(sk);\n\n\tro->want_ack = 1;\n\tro->want_lqi = 0;\n\treturn 0;\n}\n\nstatic void dgram_close(struct sock *sk, long timeout)\n{\n\tsk_common_release(sk);\n}\n\nstatic int dgram_bind(struct sock *sk, struct sockaddr *uaddr, int len)\n{\n\tstruct sockaddr_ieee802154 *addr = (struct sockaddr_ieee802154 *)uaddr;\n\tstruct ieee802154_addr haddr;\n\tstruct dgram_sock *ro = dgram_sk(sk);\n\tint err = -EINVAL;\n\tstruct net_device *dev;\n\n\tlock_sock(sk);\n\n\tro->bound = 0;\n\n\terr = ieee802154_sockaddr_check_size(addr, len);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (addr->family != AF_IEEE802154) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tieee802154_addr_from_sa(&haddr, &addr->addr);\n\tdev = ieee802154_get_dev(sock_net(sk), &haddr);\n\tif (!dev) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (dev->type != ARPHRD_IEEE802154) {\n\t\terr = -ENODEV;\n\t\tgoto out_put;\n\t}\n\n\tro->src_addr = haddr;\n\n\tro->bound = 1;\n\terr = 0;\nout_put:\n\tdev_put(dev);\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int dgram_ioctl(struct sock *sk, int cmd, int *karg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\t{\n\t\t*karg = sk_wmem_alloc_get(sk);\n\n\t\treturn 0;\n\t}\n\n\tcase SIOCINQ:\n\t{\n\t\tstruct sk_buff *skb;\n\n\t\t*karg = 0;\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb) {\n\t\t\t \n\t\t\t*karg = skb->len - ieee802154_hdr_length(skb);\n\t\t}\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\treturn 0;\n\t}\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\n \nstatic int dgram_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t int len)\n{\n\tstruct sockaddr_ieee802154 *addr = (struct sockaddr_ieee802154 *)uaddr;\n\tstruct dgram_sock *ro = dgram_sk(sk);\n\tint err = 0;\n\n\terr = ieee802154_sockaddr_check_size(addr, len);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (addr->family != AF_IEEE802154)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (!ro->bound) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out;\n\t}\n\n\tieee802154_addr_from_sa(&ro->dst_addr, &addr->addr);\n\tro->connected = 1;\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int dgram_disconnect(struct sock *sk, int flags)\n{\n\tstruct dgram_sock *ro = dgram_sk(sk);\n\n\tlock_sock(sk);\n\tro->connected = 0;\n\trelease_sock(sk);\n\n\treturn 0;\n}\n\nstatic int dgram_sendmsg(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tstruct net_device *dev;\n\tunsigned int mtu;\n\tstruct sk_buff *skb;\n\tstruct ieee802154_mac_cb *cb;\n\tstruct dgram_sock *ro = dgram_sk(sk);\n\tstruct ieee802154_addr dst_addr;\n\tDECLARE_SOCKADDR(struct sockaddr_ieee802154*, daddr, msg->msg_name);\n\tint hlen, tlen;\n\tint err;\n\n\tif (msg->msg_flags & MSG_OOB) {\n\t\tpr_debug(\"msg->msg_flags = 0x%x\\n\", msg->msg_flags);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (msg->msg_name) {\n\t\tif (ro->connected)\n\t\t\treturn -EISCONN;\n\t\tif (msg->msg_namelen < IEEE802154_MIN_NAMELEN)\n\t\t\treturn -EINVAL;\n\t\terr = ieee802154_sockaddr_check_size(daddr, msg->msg_namelen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tieee802154_addr_from_sa(&dst_addr, &daddr->addr);\n\t} else {\n\t\tif (!ro->connected)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdst_addr = ro->dst_addr;\n\t}\n\n\tif (!ro->bound)\n\t\tdev = dev_getfirstbyhwtype(sock_net(sk), ARPHRD_IEEE802154);\n\telse\n\t\tdev = ieee802154_get_dev(sock_net(sk), &ro->src_addr);\n\n\tif (!dev) {\n\t\tpr_debug(\"no dev\\n\");\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\tmtu = IEEE802154_MTU;\n\tpr_debug(\"name = %s, mtu = %u\\n\", dev->name, mtu);\n\n\tif (size > mtu) {\n\t\tpr_debug(\"size = %zu, mtu = %u\\n\", size, mtu);\n\t\terr = -EMSGSIZE;\n\t\tgoto out_dev;\n\t}\n\n\thlen = LL_RESERVED_SPACE(dev);\n\ttlen = dev->needed_tailroom;\n\tskb = sock_alloc_send_skb(sk, hlen + tlen + size,\n\t\t\t\t  msg->msg_flags & MSG_DONTWAIT,\n\t\t\t\t  &err);\n\tif (!skb)\n\t\tgoto out_dev;\n\n\tskb_reserve(skb, hlen);\n\n\tskb_reset_network_header(skb);\n\n\tcb = mac_cb_init(skb);\n\tcb->type = IEEE802154_FC_TYPE_DATA;\n\tcb->ackreq = ro->want_ack;\n\tcb->secen = ro->secen;\n\tcb->secen_override = ro->secen_override;\n\tcb->seclevel = ro->seclevel;\n\tcb->seclevel_override = ro->seclevel_override;\n\n\terr = wpan_dev_hard_header(skb, dev, &dst_addr,\n\t\t\t\t   ro->bound ? &ro->src_addr : NULL, size);\n\tif (err < 0)\n\t\tgoto out_skb;\n\n\terr = memcpy_from_msg(skb_put(skb, size), msg, size);\n\tif (err < 0)\n\t\tgoto out_skb;\n\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_IEEE802154);\n\n\terr = dev_queue_xmit(skb);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\n\tdev_put(dev);\n\n\treturn err ?: size;\n\nout_skb:\n\tkfree_skb(skb);\nout_dev:\n\tdev_put(dev);\nout:\n\treturn err;\n}\n\nstatic int dgram_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t int flags, int *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct dgram_sock *ro = dgram_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ieee802154 *, saddr, msg->msg_name);\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t \n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_cmsgs(msg, sk, skb);\n\n\tif (saddr) {\n\t\t \n\t\tmemset(saddr, 0, sizeof(*saddr));\n\n\t\tsaddr->family = AF_IEEE802154;\n\t\tieee802154_addr_to_sa(&saddr->addr, &mac_cb(skb)->source);\n\t\t*addr_len = sizeof(*saddr);\n\t}\n\n\tif (ro->want_lqi) {\n\t\terr = put_cmsg(msg, SOL_IEEE802154, WPAN_WANTLQI,\n\t\t\t       sizeof(uint8_t), &(mac_cb(skb)->lqi));\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}\n\nstatic int dgram_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NET_RX_DROP;\n\n\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn NET_RX_SUCCESS;\n}\n\nstatic inline bool\nieee802154_match_sock(__le64 hw_addr, __le16 pan_id, __le16 short_addr,\n\t\t      struct dgram_sock *ro)\n{\n\tif (!ro->bound)\n\t\treturn true;\n\n\tif (ro->src_addr.mode == IEEE802154_ADDR_LONG &&\n\t    hw_addr == ro->src_addr.extended_addr)\n\t\treturn true;\n\n\tif (ro->src_addr.mode == IEEE802154_ADDR_SHORT &&\n\t    pan_id == ro->src_addr.pan_id &&\n\t    short_addr == ro->src_addr.short_addr)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int ieee802154_dgram_deliver(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct sock *sk, *prev = NULL;\n\tint ret = NET_RX_SUCCESS;\n\t__le16 pan_id, short_addr;\n\t__le64 hw_addr;\n\n\t \n\tBUG_ON(dev->type != ARPHRD_IEEE802154);\n\n\tpan_id = dev->ieee802154_ptr->pan_id;\n\tshort_addr = dev->ieee802154_ptr->short_addr;\n\thw_addr = dev->ieee802154_ptr->extended_addr;\n\n\tread_lock(&dgram_lock);\n\tsk_for_each(sk, &dgram_head) {\n\t\tif (ieee802154_match_sock(hw_addr, pan_id, short_addr,\n\t\t\t\t\t  dgram_sk(sk))) {\n\t\t\tif (prev) {\n\t\t\t\tstruct sk_buff *clone;\n\n\t\t\t\tclone = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (clone)\n\t\t\t\t\tdgram_rcv_skb(prev, clone);\n\t\t\t}\n\n\t\t\tprev = sk;\n\t\t}\n\t}\n\n\tif (prev) {\n\t\tdgram_rcv_skb(prev, skb);\n\t} else {\n\t\tkfree_skb(skb);\n\t\tret = NET_RX_DROP;\n\t}\n\tread_unlock(&dgram_lock);\n\n\treturn ret;\n}\n\nstatic int dgram_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct dgram_sock *ro = dgram_sk(sk);\n\n\tint val, len;\n\n\tif (level != SOL_IEEE802154)\n\t\treturn -EOPNOTSUPP;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tswitch (optname) {\n\tcase WPAN_WANTACK:\n\t\tval = ro->want_ack;\n\t\tbreak;\n\tcase WPAN_WANTLQI:\n\t\tval = ro->want_lqi;\n\t\tbreak;\n\tcase WPAN_SECURITY:\n\t\tif (!ro->secen_override)\n\t\t\tval = WPAN_SECURITY_DEFAULT;\n\t\telse if (ro->secen)\n\t\t\tval = WPAN_SECURITY_ON;\n\t\telse\n\t\t\tval = WPAN_SECURITY_OFF;\n\t\tbreak;\n\tcase WPAN_SECURITY_LEVEL:\n\t\tif (!ro->seclevel_override)\n\t\t\tval = WPAN_SECURITY_LEVEL_DEFAULT;\n\t\telse\n\t\t\tval = ro->seclevel;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int dgram_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t    sockptr_t optval, unsigned int optlen)\n{\n\tstruct dgram_sock *ro = dgram_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val;\n\tint err = 0;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&val, optval, sizeof(int)))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase WPAN_WANTACK:\n\t\tro->want_ack = !!val;\n\t\tbreak;\n\tcase WPAN_WANTLQI:\n\t\tro->want_lqi = !!val;\n\t\tbreak;\n\tcase WPAN_SECURITY:\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN) &&\n\t\t    !ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (val) {\n\t\tcase WPAN_SECURITY_DEFAULT:\n\t\t\tro->secen_override = 0;\n\t\t\tbreak;\n\t\tcase WPAN_SECURITY_ON:\n\t\t\tro->secen_override = 1;\n\t\t\tro->secen = 1;\n\t\t\tbreak;\n\t\tcase WPAN_SECURITY_OFF:\n\t\t\tro->secen_override = 1;\n\t\t\tro->secen = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase WPAN_SECURITY_LEVEL:\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN) &&\n\t\t    !ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val < WPAN_SECURITY_LEVEL_DEFAULT ||\n\t\t    val > IEEE802154_SCF_SECLEVEL_ENC_MIC128) {\n\t\t\terr = -EINVAL;\n\t\t} else if (val == WPAN_SECURITY_LEVEL_DEFAULT) {\n\t\t\tro->seclevel_override = 0;\n\t\t} else {\n\t\t\tro->seclevel_override = 1;\n\t\t\tro->seclevel = val;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic struct proto ieee802154_dgram_prot = {\n\t.name\t\t= \"IEEE-802.15.4-MAC\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct dgram_sock),\n\t.init\t\t= dgram_init,\n\t.close\t\t= dgram_close,\n\t.bind\t\t= dgram_bind,\n\t.sendmsg\t= dgram_sendmsg,\n\t.recvmsg\t= dgram_recvmsg,\n\t.hash\t\t= dgram_hash,\n\t.unhash\t\t= dgram_unhash,\n\t.connect\t= dgram_connect,\n\t.disconnect\t= dgram_disconnect,\n\t.ioctl\t\t= dgram_ioctl,\n\t.getsockopt\t= dgram_getsockopt,\n\t.setsockopt\t= dgram_setsockopt,\n};\n\nstatic const struct proto_ops ieee802154_dgram_ops = {\n\t.family\t\t   = PF_IEEE802154,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = ieee802154_sock_release,\n\t.bind\t\t   = ieee802154_sock_bind,\n\t.connect\t   = ieee802154_sock_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = sock_no_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = ieee802154_sock_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = sock_no_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = ieee802154_sock_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n};\n\nstatic void ieee802154_sock_destruct(struct sock *sk)\n{\n\tskb_queue_purge(&sk->sk_receive_queue);\n}\n\n \nstatic int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\tgoto out;\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\n\tsock->ops = ops;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = ieee802154_sock_destruct;\n\tsk->sk_family = PF_IEEE802154;\n\n\t \n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}\n\nstatic const struct net_proto_family ieee802154_family_ops = {\n\t.family\t\t= PF_IEEE802154,\n\t.create\t\t= ieee802154_create,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int ieee802154_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t\t  struct packet_type *pt, struct net_device *orig_dev)\n{\n\tif (!netif_running(dev))\n\t\tgoto drop;\n\tpr_debug(\"got frame, type %d, dev %p\\n\", dev->type, dev);\n#ifdef DEBUG\n\tprint_hex_dump_bytes(\"ieee802154_rcv \",\n\t\t\t     DUMP_PREFIX_NONE, skb->data, skb->len);\n#endif\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\tieee802154_raw_deliver(dev, skb);\n\n\tif (dev->type != ARPHRD_IEEE802154)\n\t\tgoto drop;\n\n\tif (skb->pkt_type != PACKET_OTHERHOST)\n\t\treturn ieee802154_dgram_deliver(dev, skb);\n\ndrop:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic struct packet_type ieee802154_packet_type = {\n\t.type = htons(ETH_P_IEEE802154),\n\t.func = ieee802154_rcv,\n};\n\nstatic int __init af_ieee802154_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&ieee802154_raw_prot, 1);\n\tif (rc)\n\t\tgoto out;\n\n\trc = proto_register(&ieee802154_dgram_prot, 1);\n\tif (rc)\n\t\tgoto err_dgram;\n\n\t \n\trc = sock_register(&ieee802154_family_ops);\n\tif (rc)\n\t\tgoto err_sock;\n\tdev_add_pack(&ieee802154_packet_type);\n\n\trc = 0;\n\tgoto out;\n\nerr_sock:\n\tproto_unregister(&ieee802154_dgram_prot);\nerr_dgram:\n\tproto_unregister(&ieee802154_raw_prot);\nout:\n\treturn rc;\n}\n\nstatic void __exit af_ieee802154_remove(void)\n{\n\tdev_remove_pack(&ieee802154_packet_type);\n\tsock_unregister(PF_IEEE802154);\n\tproto_unregister(&ieee802154_dgram_prot);\n\tproto_unregister(&ieee802154_raw_prot);\n}\n\nmodule_init(af_ieee802154_init);\nmodule_exit(af_ieee802154_remove);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_IEEE802154);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}