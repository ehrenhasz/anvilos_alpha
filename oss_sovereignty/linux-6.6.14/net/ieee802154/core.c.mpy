{
  "module_name": "core.c",
  "hash_id": "49f749c76899542531a2eecc7d508f74b5d43cc99da900b759fbd9ac3a4a0235",
  "original_prompt": "Ingested from linux-6.6.14/net/ieee802154/core.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n\n#include <net/cfg802154.h>\n#include <net/rtnetlink.h>\n\n#include \"ieee802154.h\"\n#include \"nl802154.h\"\n#include \"sysfs.h\"\n#include \"core.h\"\n\n \n#define PHY_NAME \"phy\"\n\n \nLIST_HEAD(cfg802154_rdev_list);\nint cfg802154_rdev_list_generation;\n\nstruct wpan_phy *wpan_phy_find(const char *str)\n{\n\tstruct device *dev;\n\n\tif (WARN_ON(!str))\n\t\treturn NULL;\n\n\tdev = class_find_device_by_name(&wpan_phy_class, str);\n\tif (!dev)\n\t\treturn NULL;\n\n\treturn container_of(dev, struct wpan_phy, dev);\n}\nEXPORT_SYMBOL(wpan_phy_find);\n\nstruct wpan_phy_iter_data {\n\tint (*fn)(struct wpan_phy *phy, void *data);\n\tvoid *data;\n};\n\nstatic int wpan_phy_iter(struct device *dev, void *_data)\n{\n\tstruct wpan_phy_iter_data *wpid = _data;\n\tstruct wpan_phy *phy = container_of(dev, struct wpan_phy, dev);\n\n\treturn wpid->fn(phy, wpid->data);\n}\n\nint wpan_phy_for_each(int (*fn)(struct wpan_phy *phy, void *data),\n\t\t      void *data)\n{\n\tstruct wpan_phy_iter_data wpid = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t};\n\n\treturn class_for_each_device(&wpan_phy_class, NULL,\n\t\t\t&wpid, wpan_phy_iter);\n}\nEXPORT_SYMBOL(wpan_phy_for_each);\n\nstruct cfg802154_registered_device *\ncfg802154_rdev_by_wpan_phy_idx(int wpan_phy_idx)\n{\n\tstruct cfg802154_registered_device *result = NULL, *rdev;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(rdev, &cfg802154_rdev_list, list) {\n\t\tif (rdev->wpan_phy_idx == wpan_phy_idx) {\n\t\t\tresult = rdev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstruct wpan_phy *wpan_phy_idx_to_wpan_phy(int wpan_phy_idx)\n{\n\tstruct cfg802154_registered_device *rdev;\n\n\tASSERT_RTNL();\n\n\trdev = cfg802154_rdev_by_wpan_phy_idx(wpan_phy_idx);\n\tif (!rdev)\n\t\treturn NULL;\n\treturn &rdev->wpan_phy;\n}\n\nstruct wpan_phy *\nwpan_phy_new(const struct cfg802154_ops *ops, size_t priv_size)\n{\n\tstatic atomic_t wpan_phy_counter = ATOMIC_INIT(0);\n\tstruct cfg802154_registered_device *rdev;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(*rdev) + priv_size;\n\trdev = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!rdev)\n\t\treturn NULL;\n\n\trdev->ops = ops;\n\n\trdev->wpan_phy_idx = atomic_inc_return(&wpan_phy_counter);\n\n\tif (unlikely(rdev->wpan_phy_idx < 0)) {\n\t\t \n\t\tatomic_dec(&wpan_phy_counter);\n\t\tkfree(rdev);\n\t\treturn NULL;\n\t}\n\n\t \n\trdev->wpan_phy_idx--;\n\n\tINIT_LIST_HEAD(&rdev->wpan_dev_list);\n\tdevice_initialize(&rdev->wpan_phy.dev);\n\tdev_set_name(&rdev->wpan_phy.dev, PHY_NAME \"%d\", rdev->wpan_phy_idx);\n\n\trdev->wpan_phy.dev.class = &wpan_phy_class;\n\trdev->wpan_phy.dev.platform_data = rdev;\n\n\twpan_phy_net_set(&rdev->wpan_phy, &init_net);\n\n\tinit_waitqueue_head(&rdev->dev_wait);\n\tinit_waitqueue_head(&rdev->wpan_phy.sync_txq);\n\n\tspin_lock_init(&rdev->wpan_phy.queue_lock);\n\n\treturn &rdev->wpan_phy;\n}\nEXPORT_SYMBOL(wpan_phy_new);\n\nint wpan_phy_register(struct wpan_phy *phy)\n{\n\tstruct cfg802154_registered_device *rdev = wpan_phy_to_rdev(phy);\n\tint ret;\n\n\trtnl_lock();\n\tret = device_add(&phy->dev);\n\tif (ret) {\n\t\trtnl_unlock();\n\t\treturn ret;\n\t}\n\n\tlist_add_rcu(&rdev->list, &cfg802154_rdev_list);\n\tcfg802154_rdev_list_generation++;\n\n\t \n\trtnl_unlock();\n\n\t \n\n\treturn 0;\n}\nEXPORT_SYMBOL(wpan_phy_register);\n\nvoid wpan_phy_unregister(struct wpan_phy *phy)\n{\n\tstruct cfg802154_registered_device *rdev = wpan_phy_to_rdev(phy);\n\n\twait_event(rdev->dev_wait, ({\n\t\tint __count;\n\t\trtnl_lock();\n\t\t__count = rdev->opencount;\n\t\trtnl_unlock();\n\t\t__count == 0; }));\n\n\trtnl_lock();\n\t \n\t \n\n\tWARN_ON(!list_empty(&rdev->wpan_dev_list));\n\n\t \n\tlist_del_rcu(&rdev->list);\n\tsynchronize_rcu();\n\n\tcfg802154_rdev_list_generation++;\n\n\tdevice_del(&phy->dev);\n\n\trtnl_unlock();\n}\nEXPORT_SYMBOL(wpan_phy_unregister);\n\nvoid wpan_phy_free(struct wpan_phy *phy)\n{\n\tput_device(&phy->dev);\n}\nEXPORT_SYMBOL(wpan_phy_free);\n\nint cfg802154_switch_netns(struct cfg802154_registered_device *rdev,\n\t\t\t   struct net *net)\n{\n\tstruct wpan_dev *wpan_dev;\n\tint err = 0;\n\n\tlist_for_each_entry(wpan_dev, &rdev->wpan_dev_list, list) {\n\t\tif (!wpan_dev->netdev)\n\t\t\tcontinue;\n\t\twpan_dev->netdev->features &= ~NETIF_F_NETNS_LOCAL;\n\t\terr = dev_change_net_namespace(wpan_dev->netdev, net, \"wpan%d\");\n\t\tif (err)\n\t\t\tbreak;\n\t\twpan_dev->netdev->features |= NETIF_F_NETNS_LOCAL;\n\t}\n\n\tif (err) {\n\t\t \n\t\tnet = wpan_phy_net(&rdev->wpan_phy);\n\n\t\tlist_for_each_entry_continue_reverse(wpan_dev,\n\t\t\t\t\t\t     &rdev->wpan_dev_list,\n\t\t\t\t\t\t     list) {\n\t\t\tif (!wpan_dev->netdev)\n\t\t\t\tcontinue;\n\t\t\twpan_dev->netdev->features &= ~NETIF_F_NETNS_LOCAL;\n\t\t\terr = dev_change_net_namespace(wpan_dev->netdev, net,\n\t\t\t\t\t\t       \"wpan%d\");\n\t\t\tWARN_ON(err);\n\t\t\twpan_dev->netdev->features |= NETIF_F_NETNS_LOCAL;\n\t\t}\n\n\t\treturn err;\n\t}\n\n\twpan_phy_net_set(&rdev->wpan_phy, net);\n\n\terr = device_rename(&rdev->wpan_phy.dev, dev_name(&rdev->wpan_phy.dev));\n\tWARN_ON(err);\n\n\treturn 0;\n}\n\nvoid cfg802154_dev_free(struct cfg802154_registered_device *rdev)\n{\n\tkfree(rdev);\n}\n\nstatic void\ncfg802154_update_iface_num(struct cfg802154_registered_device *rdev,\n\t\t\t   int iftype, int num)\n{\n\tASSERT_RTNL();\n\n\trdev->num_running_ifaces += num;\n}\n\nstatic int cfg802154_netdev_notifier_call(struct notifier_block *nb,\n\t\t\t\t\t  unsigned long state, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct cfg802154_registered_device *rdev;\n\n\tif (!wpan_dev)\n\t\treturn NOTIFY_DONE;\n\n\trdev = wpan_phy_to_rdev(wpan_dev->wpan_phy);\n\n\t \n\n\tswitch (state) {\n\t\t \n\tcase NETDEV_REGISTER:\n\t\tdev->features |= NETIF_F_NETNS_LOCAL;\n\t\twpan_dev->identifier = ++rdev->wpan_dev_id;\n\t\tlist_add_rcu(&wpan_dev->list, &rdev->wpan_dev_list);\n\t\trdev->devlist_generation++;\n\n\t\twpan_dev->netdev = dev;\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tcfg802154_update_iface_num(rdev, wpan_dev->iftype, -1);\n\n\t\trdev->opencount--;\n\t\twake_up(&rdev->dev_wait);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\tcfg802154_update_iface_num(rdev, wpan_dev->iftype, 1);\n\n\t\trdev->opencount++;\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t \n\t\tif (!list_empty(&wpan_dev->list)) {\n\t\t\tlist_del_rcu(&wpan_dev->list);\n\t\t\trdev->devlist_generation++;\n\t\t}\n\t\t \n\t\tsynchronize_rcu();\n\t\tINIT_LIST_HEAD(&wpan_dev->list);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block cfg802154_netdev_notifier = {\n\t.notifier_call = cfg802154_netdev_notifier_call,\n};\n\nstatic void __net_exit cfg802154_pernet_exit(struct net *net)\n{\n\tstruct cfg802154_registered_device *rdev;\n\n\trtnl_lock();\n\tlist_for_each_entry(rdev, &cfg802154_rdev_list, list) {\n\t\tif (net_eq(wpan_phy_net(&rdev->wpan_phy), net))\n\t\t\tWARN_ON(cfg802154_switch_netns(rdev, &init_net));\n\t}\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations cfg802154_pernet_ops = {\n\t.exit = cfg802154_pernet_exit,\n};\n\nstatic int __init wpan_phy_class_init(void)\n{\n\tint rc;\n\n\trc = register_pernet_device(&cfg802154_pernet_ops);\n\tif (rc)\n\t\tgoto err;\n\n\trc = wpan_phy_sysfs_init();\n\tif (rc)\n\t\tgoto err_sysfs;\n\n\trc = register_netdevice_notifier(&cfg802154_netdev_notifier);\n\tif (rc)\n\t\tgoto err_nl;\n\n\trc = ieee802154_nl_init();\n\tif (rc)\n\t\tgoto err_notifier;\n\n\trc = nl802154_init();\n\tif (rc)\n\t\tgoto err_ieee802154_nl;\n\n\treturn 0;\n\nerr_ieee802154_nl:\n\tieee802154_nl_exit();\n\nerr_notifier:\n\tunregister_netdevice_notifier(&cfg802154_netdev_notifier);\nerr_nl:\n\twpan_phy_sysfs_exit();\nerr_sysfs:\n\tunregister_pernet_device(&cfg802154_pernet_ops);\nerr:\n\treturn rc;\n}\nsubsys_initcall(wpan_phy_class_init);\n\nstatic void __exit wpan_phy_class_exit(void)\n{\n\tnl802154_exit();\n\tieee802154_nl_exit();\n\tunregister_netdevice_notifier(&cfg802154_netdev_notifier);\n\twpan_phy_sysfs_exit();\n\tunregister_pernet_device(&cfg802154_pernet_ops);\n}\nmodule_exit(wpan_phy_class_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"IEEE 802.15.4 configuration interface\");\nMODULE_AUTHOR(\"Dmitry Eremin-Solenikov\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}