{
  "module_name": "nl802154.c",
  "hash_id": "fe6aac3a51145bfc961238d56f200842b974c533dd03867863fc0f583bbe7337",
  "original_prompt": "Ingested from linux-6.6.14/net/ieee802154/nl802154.c",
  "human_readable_source": "\n \n\n#include <linux/rtnetlink.h>\n\n#include <net/cfg802154.h>\n#include <net/genetlink.h>\n#include <net/mac802154.h>\n#include <net/netlink.h>\n#include <net/nl802154.h>\n#include <net/sock.h>\n\n#include \"nl802154.h\"\n#include \"rdev-ops.h\"\n#include \"core.h\"\n\n \nstatic struct genl_family nl802154_fam;\n\n \nenum nl802154_multicast_groups {\n\tNL802154_MCGRP_CONFIG,\n\tNL802154_MCGRP_SCAN,\n};\n\nstatic const struct genl_multicast_group nl802154_mcgrps[] = {\n\t[NL802154_MCGRP_CONFIG] = { .name = \"config\", },\n\t[NL802154_MCGRP_SCAN] = { .name = \"scan\", },\n};\n\n \nstatic struct wpan_dev *\n__cfg802154_wpan_dev_from_attrs(struct net *netns, struct nlattr **attrs)\n{\n\tstruct cfg802154_registered_device *rdev;\n\tstruct wpan_dev *result = NULL;\n\tbool have_ifidx = attrs[NL802154_ATTR_IFINDEX];\n\tbool have_wpan_dev_id = attrs[NL802154_ATTR_WPAN_DEV];\n\tu64 wpan_dev_id;\n\tint wpan_phy_idx = -1;\n\tint ifidx = -1;\n\n\tASSERT_RTNL();\n\n\tif (!have_ifidx && !have_wpan_dev_id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (have_ifidx)\n\t\tifidx = nla_get_u32(attrs[NL802154_ATTR_IFINDEX]);\n\tif (have_wpan_dev_id) {\n\t\twpan_dev_id = nla_get_u64(attrs[NL802154_ATTR_WPAN_DEV]);\n\t\twpan_phy_idx = wpan_dev_id >> 32;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg802154_rdev_list, list) {\n\t\tstruct wpan_dev *wpan_dev;\n\n\t\tif (wpan_phy_net(&rdev->wpan_phy) != netns)\n\t\t\tcontinue;\n\n\t\tif (have_wpan_dev_id && rdev->wpan_phy_idx != wpan_phy_idx)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(wpan_dev, &rdev->wpan_dev_list, list) {\n\t\t\tif (have_ifidx && wpan_dev->netdev &&\n\t\t\t    wpan_dev->netdev->ifindex == ifidx) {\n\t\t\t\tresult = wpan_dev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (have_wpan_dev_id &&\n\t\t\t    wpan_dev->identifier == (u32)wpan_dev_id) {\n\t\t\t\tresult = wpan_dev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (result)\n\t\t\tbreak;\n\t}\n\n\tif (result)\n\t\treturn result;\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic struct cfg802154_registered_device *\n__cfg802154_rdev_from_attrs(struct net *netns, struct nlattr **attrs)\n{\n\tstruct cfg802154_registered_device *rdev = NULL, *tmp;\n\tstruct net_device *netdev;\n\n\tASSERT_RTNL();\n\n\tif (!attrs[NL802154_ATTR_WPAN_PHY] &&\n\t    !attrs[NL802154_ATTR_IFINDEX] &&\n\t    !attrs[NL802154_ATTR_WPAN_DEV])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL802154_ATTR_WPAN_PHY])\n\t\trdev = cfg802154_rdev_by_wpan_phy_idx(\n\t\t\t\tnla_get_u32(attrs[NL802154_ATTR_WPAN_PHY]));\n\n\tif (attrs[NL802154_ATTR_WPAN_DEV]) {\n\t\tu64 wpan_dev_id = nla_get_u64(attrs[NL802154_ATTR_WPAN_DEV]);\n\t\tstruct wpan_dev *wpan_dev;\n\t\tbool found = false;\n\n\t\ttmp = cfg802154_rdev_by_wpan_phy_idx(wpan_dev_id >> 32);\n\t\tif (tmp) {\n\t\t\t \n\t\t\tlist_for_each_entry(wpan_dev, &tmp->wpan_dev_list, list) {\n\t\t\t\tif (wpan_dev->identifier != (u32)wpan_dev_id)\n\t\t\t\t\tcontinue;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t\ttmp = NULL;\n\n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (attrs[NL802154_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(attrs[NL802154_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(netns, ifindex);\n\t\tif (netdev) {\n\t\t\tif (netdev->ieee802154_ptr)\n\t\t\t\ttmp = wpan_phy_to_rdev(\n\t\t\t\t\t\tnetdev->ieee802154_ptr->wpan_phy);\n\t\t\telse\n\t\t\t\ttmp = NULL;\n\n\t\t\t \n\t\t\tif (!tmp)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t \n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (!rdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (netns != wpan_phy_net(&rdev->wpan_phy))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn rdev;\n}\n\n \nstatic struct cfg802154_registered_device *\ncfg802154_get_dev_from_info(struct net *netns, struct genl_info *info)\n{\n\treturn __cfg802154_rdev_from_attrs(netns, info->attrs);\n}\n\n \nstatic const struct nla_policy nl802154_policy[NL802154_ATTR_MAX+1] = {\n\t[NL802154_ATTR_WPAN_PHY] = { .type = NLA_U32 },\n\t[NL802154_ATTR_WPAN_PHY_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t\t  .len = 20-1 },\n\n\t[NL802154_ATTR_IFINDEX] = { .type = NLA_U32 },\n\t[NL802154_ATTR_IFTYPE] = { .type = NLA_U32 },\n\t[NL802154_ATTR_IFNAME] = { .type = NLA_NUL_STRING, .len = IFNAMSIZ-1 },\n\n\t[NL802154_ATTR_WPAN_DEV] = { .type = NLA_U64 },\n\n\t[NL802154_ATTR_PAGE] = NLA_POLICY_MAX(NLA_U8, IEEE802154_MAX_PAGE),\n\t[NL802154_ATTR_CHANNEL] = NLA_POLICY_MAX(NLA_U8, IEEE802154_MAX_CHANNEL),\n\n\t[NL802154_ATTR_TX_POWER] = { .type = NLA_S32, },\n\n\t[NL802154_ATTR_CCA_MODE] = { .type = NLA_U32, },\n\t[NL802154_ATTR_CCA_OPT] = { .type = NLA_U32, },\n\t[NL802154_ATTR_CCA_ED_LEVEL] = { .type = NLA_S32, },\n\n\t[NL802154_ATTR_SUPPORTED_CHANNEL] = { .type = NLA_U32, },\n\n\t[NL802154_ATTR_PAN_ID] = { .type = NLA_U16, },\n\t[NL802154_ATTR_EXTENDED_ADDR] = { .type = NLA_U64 },\n\t[NL802154_ATTR_SHORT_ADDR] = { .type = NLA_U16, },\n\n\t[NL802154_ATTR_MIN_BE] = { .type = NLA_U8, },\n\t[NL802154_ATTR_MAX_BE] = { .type = NLA_U8, },\n\t[NL802154_ATTR_MAX_CSMA_BACKOFFS] = { .type = NLA_U8, },\n\n\t[NL802154_ATTR_MAX_FRAME_RETRIES] = { .type = NLA_S8, },\n\n\t[NL802154_ATTR_LBT_MODE] = { .type = NLA_U8, },\n\n\t[NL802154_ATTR_WPAN_PHY_CAPS] = { .type = NLA_NESTED },\n\n\t[NL802154_ATTR_SUPPORTED_COMMANDS] = { .type = NLA_NESTED },\n\n\t[NL802154_ATTR_ACKREQ_DEFAULT] = { .type = NLA_U8 },\n\n\t[NL802154_ATTR_PID] = { .type = NLA_U32 },\n\t[NL802154_ATTR_NETNS_FD] = { .type = NLA_U32 },\n\n\t[NL802154_ATTR_COORDINATOR] = { .type = NLA_NESTED },\n\n\t[NL802154_ATTR_SCAN_TYPE] =\n\t\tNLA_POLICY_RANGE(NLA_U8, NL802154_SCAN_ED, NL802154_SCAN_RIT_PASSIVE),\n\t[NL802154_ATTR_SCAN_CHANNELS] =\n\t\tNLA_POLICY_MASK(NLA_U32, GENMASK(IEEE802154_MAX_CHANNEL, 0)),\n\t[NL802154_ATTR_SCAN_PREAMBLE_CODES] = { .type = NLA_REJECT },\n\t[NL802154_ATTR_SCAN_MEAN_PRF] = { .type = NLA_REJECT },\n\t[NL802154_ATTR_SCAN_DURATION] =\n\t\tNLA_POLICY_MAX(NLA_U8, IEEE802154_MAX_SCAN_DURATION),\n\t[NL802154_ATTR_SCAN_DONE_REASON] =\n\t\tNLA_POLICY_RANGE(NLA_U8, NL802154_SCAN_DONE_REASON_FINISHED,\n\t\t\t\t NL802154_SCAN_DONE_REASON_ABORTED),\n\t[NL802154_ATTR_BEACON_INTERVAL] =\n\t\tNLA_POLICY_MAX(NLA_U8, IEEE802154_ACTIVE_SCAN_DURATION),\n\n#ifdef CONFIG_IEEE802154_NL802154_EXPERIMENTAL\n\t[NL802154_ATTR_SEC_ENABLED] = { .type = NLA_U8, },\n\t[NL802154_ATTR_SEC_OUT_LEVEL] = { .type = NLA_U32, },\n\t[NL802154_ATTR_SEC_OUT_KEY_ID] = { .type = NLA_NESTED, },\n\t[NL802154_ATTR_SEC_FRAME_COUNTER] = { .type = NLA_U32 },\n\n\t[NL802154_ATTR_SEC_LEVEL] = { .type = NLA_NESTED },\n\t[NL802154_ATTR_SEC_DEVICE] = { .type = NLA_NESTED },\n\t[NL802154_ATTR_SEC_DEVKEY] = { .type = NLA_NESTED },\n\t[NL802154_ATTR_SEC_KEY] = { .type = NLA_NESTED },\n#endif  \n};\n\n#ifdef CONFIG_IEEE802154_NL802154_EXPERIMENTAL\nstatic int\nnl802154_prepare_wpan_dev_dump(struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb,\n\t\t\t       struct cfg802154_registered_device **rdev,\n\t\t\t       struct wpan_dev **wpan_dev)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tint err;\n\n\trtnl_lock();\n\n\tif (!cb->args[0]) {\n\t\t*wpan_dev = __cfg802154_wpan_dev_from_attrs(sock_net(skb->sk),\n\t\t\t\t\t\t\t    info->info.attrs);\n\t\tif (IS_ERR(*wpan_dev)) {\n\t\t\terr = PTR_ERR(*wpan_dev);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t*rdev = wpan_phy_to_rdev((*wpan_dev)->wpan_phy);\n\t\t \n\t\tcb->args[0] = (*rdev)->wpan_phy_idx + 1;\n\t\tcb->args[1] = (*wpan_dev)->identifier;\n\t} else {\n\t\t \n\t\tstruct wpan_phy *wpan_phy = wpan_phy_idx_to_wpan_phy(cb->args[0] - 1);\n\t\tstruct wpan_dev *tmp;\n\n\t\tif (!wpan_phy) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t*rdev = wpan_phy_to_rdev(wpan_phy);\n\t\t*wpan_dev = NULL;\n\n\t\tlist_for_each_entry(tmp, &(*rdev)->wpan_dev_list, list) {\n\t\t\tif (tmp->identifier == cb->args[1]) {\n\t\t\t\t*wpan_dev = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!*wpan_dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\treturn 0;\n out_unlock:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic void\nnl802154_finish_wpan_dev_dump(struct cfg802154_registered_device *rdev)\n{\n\trtnl_unlock();\n}\n#endif  \n\n \nstatic inline void *nl802154hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\t    int flags, u8 cmd)\n{\n\t \n\treturn genlmsg_put(skb, portid, seq, &nl802154_fam, flags, cmd);\n}\n\nstatic int\nnl802154_put_flags(struct sk_buff *msg, int attr, u32 mask)\n{\n\tstruct nlattr *nl_flags = nla_nest_start_noflag(msg, attr);\n\tint i;\n\n\tif (!nl_flags)\n\t\treturn -ENOBUFS;\n\n\ti = 0;\n\twhile (mask) {\n\t\tif ((mask & 1) && nla_put_flag(msg, i))\n\t\t\treturn -ENOBUFS;\n\n\t\tmask >>= 1;\n\t\ti++;\n\t}\n\n\tnla_nest_end(msg, nl_flags);\n\treturn 0;\n}\n\nstatic int\nnl802154_send_wpan_phy_channels(struct cfg802154_registered_device *rdev,\n\t\t\t\tstruct sk_buff *msg)\n{\n\tstruct nlattr *nl_page;\n\tunsigned long page;\n\n\tnl_page = nla_nest_start_noflag(msg, NL802154_ATTR_CHANNELS_SUPPORTED);\n\tif (!nl_page)\n\t\treturn -ENOBUFS;\n\n\tfor (page = 0; page <= IEEE802154_MAX_PAGE; page++) {\n\t\tif (nla_put_u32(msg, NL802154_ATTR_SUPPORTED_CHANNEL,\n\t\t\t\trdev->wpan_phy.supported.channels[page]))\n\t\t\treturn -ENOBUFS;\n\t}\n\tnla_nest_end(msg, nl_page);\n\n\treturn 0;\n}\n\nstatic int\nnl802154_put_capabilities(struct sk_buff *msg,\n\t\t\t  struct cfg802154_registered_device *rdev)\n{\n\tconst struct wpan_phy_supported *caps = &rdev->wpan_phy.supported;\n\tstruct nlattr *nl_caps, *nl_channels;\n\tint i;\n\n\tnl_caps = nla_nest_start_noflag(msg, NL802154_ATTR_WPAN_PHY_CAPS);\n\tif (!nl_caps)\n\t\treturn -ENOBUFS;\n\n\tnl_channels = nla_nest_start_noflag(msg, NL802154_CAP_ATTR_CHANNELS);\n\tif (!nl_channels)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i <= IEEE802154_MAX_PAGE; i++) {\n\t\tif (caps->channels[i]) {\n\t\t\tif (nl802154_put_flags(msg, i, caps->channels[i]))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t}\n\n\tnla_nest_end(msg, nl_channels);\n\n\tif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_ED_LEVEL) {\n\t\tstruct nlattr *nl_ed_lvls;\n\n\t\tnl_ed_lvls = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t   NL802154_CAP_ATTR_CCA_ED_LEVELS);\n\t\tif (!nl_ed_lvls)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < caps->cca_ed_levels_size; i++) {\n\t\t\tif (nla_put_s32(msg, i, caps->cca_ed_levels[i]))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tnla_nest_end(msg, nl_ed_lvls);\n\t}\n\n\tif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_TXPOWER) {\n\t\tstruct nlattr *nl_tx_pwrs;\n\n\t\tnl_tx_pwrs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t   NL802154_CAP_ATTR_TX_POWERS);\n\t\tif (!nl_tx_pwrs)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < caps->tx_powers_size; i++) {\n\t\t\tif (nla_put_s32(msg, i, caps->tx_powers[i]))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tnla_nest_end(msg, nl_tx_pwrs);\n\t}\n\n\tif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_MODE) {\n\t\tif (nl802154_put_flags(msg, NL802154_CAP_ATTR_CCA_MODES,\n\t\t\t\t       caps->cca_modes) ||\n\t\t    nl802154_put_flags(msg, NL802154_CAP_ATTR_CCA_OPTS,\n\t\t\t\t       caps->cca_opts))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tif (nla_put_u8(msg, NL802154_CAP_ATTR_MIN_MINBE, caps->min_minbe) ||\n\t    nla_put_u8(msg, NL802154_CAP_ATTR_MAX_MINBE, caps->max_minbe) ||\n\t    nla_put_u8(msg, NL802154_CAP_ATTR_MIN_MAXBE, caps->min_maxbe) ||\n\t    nla_put_u8(msg, NL802154_CAP_ATTR_MAX_MAXBE, caps->max_maxbe) ||\n\t    nla_put_u8(msg, NL802154_CAP_ATTR_MIN_CSMA_BACKOFFS,\n\t\t       caps->min_csma_backoffs) ||\n\t    nla_put_u8(msg, NL802154_CAP_ATTR_MAX_CSMA_BACKOFFS,\n\t\t       caps->max_csma_backoffs) ||\n\t    nla_put_s8(msg, NL802154_CAP_ATTR_MIN_FRAME_RETRIES,\n\t\t       caps->min_frame_retries) ||\n\t    nla_put_s8(msg, NL802154_CAP_ATTR_MAX_FRAME_RETRIES,\n\t\t       caps->max_frame_retries) ||\n\t    nl802154_put_flags(msg, NL802154_CAP_ATTR_IFTYPES,\n\t\t\t       caps->iftypes) ||\n\t    nla_put_u32(msg, NL802154_CAP_ATTR_LBT, caps->lbt))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_caps);\n\n\treturn 0;\n}\n\nstatic int nl802154_send_wpan_phy(struct cfg802154_registered_device *rdev,\n\t\t\t\t  enum nl802154_commands cmd,\n\t\t\t\t  struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t\t  int flags)\n{\n\tstruct nlattr *nl_cmds;\n\tvoid *hdr;\n\tint i;\n\n\thdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL802154_ATTR_WPAN_PHY, rdev->wpan_phy_idx) ||\n\t    nla_put_string(msg, NL802154_ATTR_WPAN_PHY_NAME,\n\t\t\t   wpan_phy_name(&rdev->wpan_phy)) ||\n\t    nla_put_u32(msg, NL802154_ATTR_GENERATION,\n\t\t\tcfg802154_rdev_list_generation))\n\t\tgoto nla_put_failure;\n\n\tif (cmd != NL802154_CMD_NEW_WPAN_PHY)\n\t\tgoto finish;\n\n\t \n\n\t \n\tif (nla_put_u8(msg, NL802154_ATTR_PAGE,\n\t\t       rdev->wpan_phy.current_page) ||\n\t    nla_put_u8(msg, NL802154_ATTR_CHANNEL,\n\t\t       rdev->wpan_phy.current_channel))\n\t\tgoto nla_put_failure;\n\n\t \n\tif (nl802154_send_wpan_phy_channels(rdev, msg))\n\t\tgoto nla_put_failure;\n\n\t \n\tif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_MODE) {\n\t\tif (nla_put_u32(msg, NL802154_ATTR_CCA_MODE,\n\t\t\t\trdev->wpan_phy.cca.mode))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wpan_phy.cca.mode == NL802154_CCA_ENERGY_CARRIER) {\n\t\t\tif (nla_put_u32(msg, NL802154_ATTR_CCA_OPT,\n\t\t\t\t\trdev->wpan_phy.cca.opt))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_TXPOWER) {\n\t\tif (nla_put_s32(msg, NL802154_ATTR_TX_POWER,\n\t\t\t\trdev->wpan_phy.transmit_power))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_ED_LEVEL) {\n\t\tif (nla_put_s32(msg, NL802154_ATTR_CCA_ED_LEVEL,\n\t\t\t\trdev->wpan_phy.cca_ed_level))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nl802154_put_capabilities(msg, rdev))\n\t\tgoto nla_put_failure;\n\n\tnl_cmds = nla_nest_start_noflag(msg, NL802154_ATTR_SUPPORTED_COMMANDS);\n\tif (!nl_cmds)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n#define CMD(op, n)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (rdev->ops->op) {\t\t\t\t\t\\\n\t\t\ti++;\t\t\t\t\t\t\\\n\t\t\tif (nla_put_u32(msg, i, NL802154_CMD_ ## n))\t\\\n\t\t\t\tgoto nla_put_failure;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tCMD(add_virtual_intf, NEW_INTERFACE);\n\tCMD(del_virtual_intf, DEL_INTERFACE);\n\tCMD(set_channel, SET_CHANNEL);\n\tCMD(set_pan_id, SET_PAN_ID);\n\tCMD(set_short_addr, SET_SHORT_ADDR);\n\tCMD(set_backoff_exponent, SET_BACKOFF_EXPONENT);\n\tCMD(set_max_csma_backoffs, SET_MAX_CSMA_BACKOFFS);\n\tCMD(set_max_frame_retries, SET_MAX_FRAME_RETRIES);\n\tCMD(set_lbt_mode, SET_LBT_MODE);\n\tCMD(set_ackreq_default, SET_ACKREQ_DEFAULT);\n\n\tif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_TXPOWER)\n\t\tCMD(set_tx_power, SET_TX_POWER);\n\n\tif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_ED_LEVEL)\n\t\tCMD(set_cca_ed_level, SET_CCA_ED_LEVEL);\n\n\tif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_MODE)\n\t\tCMD(set_cca_mode, SET_CCA_MODE);\n\n#undef CMD\n\tnla_nest_end(msg, nl_cmds);\n\nfinish:\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstruct nl802154_dump_wpan_phy_state {\n\ts64 filter_wpan_phy;\n\tlong start;\n\n};\n\nstatic int nl802154_dump_wpan_phy_parse(struct sk_buff *skb,\n\t\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\t\tstruct nl802154_dump_wpan_phy_state *state)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct nlattr **tb = info->info.attrs;\n\n\tif (tb[NL802154_ATTR_WPAN_PHY])\n\t\tstate->filter_wpan_phy = nla_get_u32(tb[NL802154_ATTR_WPAN_PHY]);\n\tif (tb[NL802154_ATTR_WPAN_DEV])\n\t\tstate->filter_wpan_phy = nla_get_u64(tb[NL802154_ATTR_WPAN_DEV]) >> 32;\n\tif (tb[NL802154_ATTR_IFINDEX]) {\n\t\tstruct net_device *netdev;\n\t\tstruct cfg802154_registered_device *rdev;\n\t\tint ifidx = nla_get_u32(tb[NL802154_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(&init_net, ifidx);\n\t\tif (!netdev)\n\t\t\treturn -ENODEV;\n\t\tif (netdev->ieee802154_ptr) {\n\t\t\trdev = wpan_phy_to_rdev(\n\t\t\t\t\tnetdev->ieee802154_ptr->wpan_phy);\n\t\t\tstate->filter_wpan_phy = rdev->wpan_phy_idx;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnl802154_dump_wpan_phy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0, ret;\n\tstruct nl802154_dump_wpan_phy_state *state = (void *)cb->args[0];\n\tstruct cfg802154_registered_device *rdev;\n\n\trtnl_lock();\n\tif (!state) {\n\t\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\t\tif (!state) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tstate->filter_wpan_phy = -1;\n\t\tret = nl802154_dump_wpan_phy_parse(skb, cb, state);\n\t\tif (ret) {\n\t\t\tkfree(state);\n\t\t\trtnl_unlock();\n\t\t\treturn ret;\n\t\t}\n\t\tcb->args[0] = (long)state;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg802154_rdev_list, list) {\n\t\tif (!net_eq(wpan_phy_net(&rdev->wpan_phy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (++idx <= state->start)\n\t\t\tcontinue;\n\t\tif (state->filter_wpan_phy != -1 &&\n\t\t    state->filter_wpan_phy != rdev->wpan_phy_idx)\n\t\t\tcontinue;\n\t\t \n\t\tret = nl802154_send_wpan_phy(rdev,\n\t\t\t\t\t     NL802154_CMD_NEW_WPAN_PHY,\n\t\t\t\t\t     skb,\n\t\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t     cb->nlh->nlmsg_seq, NLM_F_MULTI);\n\t\tif (ret < 0) {\n\t\t\tif ((ret == -ENOBUFS || ret == -EMSGSIZE) &&\n\t\t\t    !skb->len && cb->min_dump_alloc < 4096) {\n\t\t\t\tcb->min_dump_alloc = 4096;\n\t\t\t\trtnl_unlock();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tstate->start = idx;\n\n\treturn skb->len;\n}\n\nstatic int nl802154_dump_wpan_phy_done(struct netlink_callback *cb)\n{\n\tkfree((void *)cb->args[0]);\n\treturn 0;\n}\n\nstatic int nl802154_get_wpan_phy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl802154_send_wpan_phy(rdev, NL802154_CMD_NEW_WPAN_PHY, msg,\n\t\t\t\t   info->snd_portid, info->snd_seq, 0) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic inline u64 wpan_dev_id(struct wpan_dev *wpan_dev)\n{\n\treturn (u64)wpan_dev->identifier |\n\t       ((u64)wpan_phy_to_rdev(wpan_dev->wpan_phy)->wpan_phy_idx << 32);\n}\n\n#ifdef CONFIG_IEEE802154_NL802154_EXPERIMENTAL\n#include <net/ieee802154_netdev.h>\n\nstatic int\nieee802154_llsec_send_key_id(struct sk_buff *msg,\n\t\t\t     const struct ieee802154_llsec_key_id *desc)\n{\n\tstruct nlattr *nl_dev_addr;\n\n\tif (nla_put_u32(msg, NL802154_KEY_ID_ATTR_MODE, desc->mode))\n\t\treturn -ENOBUFS;\n\n\tswitch (desc->mode) {\n\tcase NL802154_KEY_ID_MODE_IMPLICIT:\n\t\tnl_dev_addr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t    NL802154_KEY_ID_ATTR_IMPLICIT);\n\t\tif (!nl_dev_addr)\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_le16(msg, NL802154_DEV_ADDR_ATTR_PAN_ID,\n\t\t\t\t desc->device_addr.pan_id) ||\n\t\t    nla_put_u32(msg,  NL802154_DEV_ADDR_ATTR_MODE,\n\t\t\t\tdesc->device_addr.mode))\n\t\t\treturn -ENOBUFS;\n\n\t\tswitch (desc->device_addr.mode) {\n\t\tcase NL802154_DEV_ADDR_SHORT:\n\t\t\tif (nla_put_le16(msg, NL802154_DEV_ADDR_ATTR_SHORT,\n\t\t\t\t\t desc->device_addr.short_addr))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tbreak;\n\t\tcase NL802154_DEV_ADDR_EXTENDED:\n\t\t\tif (nla_put_le64(msg, NL802154_DEV_ADDR_ATTR_EXTENDED,\n\t\t\t\t\t desc->device_addr.extended_addr,\n\t\t\t\t\t NL802154_DEV_ADDR_ATTR_PAD))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tnla_nest_end(msg, nl_dev_addr);\n\t\tbreak;\n\tcase NL802154_KEY_ID_MODE_INDEX:\n\t\tbreak;\n\tcase NL802154_KEY_ID_MODE_INDEX_SHORT:\n\t\t \n\t\tif (nla_put_le32(msg, NL802154_KEY_ID_ATTR_SOURCE_SHORT,\n\t\t\t\t desc->short_source))\n\t\t\treturn -ENOBUFS;\n\t\tbreak;\n\tcase NL802154_KEY_ID_MODE_INDEX_EXTENDED:\n\t\tif (nla_put_le64(msg, NL802154_KEY_ID_ATTR_SOURCE_EXTENDED,\n\t\t\t\t desc->extended_source,\n\t\t\t\t NL802154_KEY_ID_ATTR_PAD))\n\t\t\treturn -ENOBUFS;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tif (desc->mode != NL802154_KEY_ID_MODE_IMPLICIT) {\n\t\tif (nla_put_u8(msg, NL802154_KEY_ID_ATTR_INDEX, desc->id))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl802154_get_llsec_params(struct sk_buff *msg,\n\t\t\t\t     struct cfg802154_registered_device *rdev,\n\t\t\t\t     struct wpan_dev *wpan_dev)\n{\n\tstruct nlattr *nl_key_id;\n\tstruct ieee802154_llsec_params params;\n\tint ret;\n\n\tret = rdev_get_llsec_params(rdev, wpan_dev, &params);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (nla_put_u8(msg, NL802154_ATTR_SEC_ENABLED, params.enabled) ||\n\t    nla_put_u32(msg, NL802154_ATTR_SEC_OUT_LEVEL, params.out_level) ||\n\t    nla_put_be32(msg, NL802154_ATTR_SEC_FRAME_COUNTER,\n\t\t\t params.frame_counter))\n\t\treturn -ENOBUFS;\n\n\tnl_key_id = nla_nest_start_noflag(msg, NL802154_ATTR_SEC_OUT_KEY_ID);\n\tif (!nl_key_id)\n\t\treturn -ENOBUFS;\n\n\tret = ieee802154_llsec_send_key_id(msg, &params.out_key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnla_nest_end(msg, nl_key_id);\n\n\treturn 0;\n}\n#endif  \n\nstatic int\nnl802154_send_iface(struct sk_buff *msg, u32 portid, u32 seq, int flags,\n\t\t    struct cfg802154_registered_device *rdev,\n\t\t    struct wpan_dev *wpan_dev)\n{\n\tstruct net_device *dev = wpan_dev->netdev;\n\tvoid *hdr;\n\n\thdr = nl802154hdr_put(msg, portid, seq, flags,\n\t\t\t      NL802154_CMD_NEW_INTERFACE);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (dev &&\n\t    (nla_put_u32(msg, NL802154_ATTR_IFINDEX, dev->ifindex) ||\n\t     nla_put_string(msg, NL802154_ATTR_IFNAME, dev->name)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL802154_ATTR_WPAN_PHY, rdev->wpan_phy_idx) ||\n\t    nla_put_u32(msg, NL802154_ATTR_IFTYPE, wpan_dev->iftype) ||\n\t    nla_put_u64_64bit(msg, NL802154_ATTR_WPAN_DEV,\n\t\t\t      wpan_dev_id(wpan_dev), NL802154_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL802154_ATTR_GENERATION,\n\t\t\trdev->devlist_generation ^\n\t\t\t(cfg802154_rdev_list_generation << 2)))\n\t\tgoto nla_put_failure;\n\n\t \n\tif (nla_put_le64(msg, NL802154_ATTR_EXTENDED_ADDR,\n\t\t\t wpan_dev->extended_addr,\n\t\t\t NL802154_ATTR_PAD) ||\n\t    nla_put_le16(msg, NL802154_ATTR_SHORT_ADDR,\n\t\t\t wpan_dev->short_addr) ||\n\t    nla_put_le16(msg, NL802154_ATTR_PAN_ID, wpan_dev->pan_id))\n\t\tgoto nla_put_failure;\n\n\t \n\tif (nla_put_s8(msg, NL802154_ATTR_MAX_FRAME_RETRIES,\n\t\t       wpan_dev->frame_retries) ||\n\t    nla_put_u8(msg, NL802154_ATTR_MAX_BE, wpan_dev->max_be) ||\n\t    nla_put_u8(msg, NL802154_ATTR_MAX_CSMA_BACKOFFS,\n\t\t       wpan_dev->csma_retries) ||\n\t    nla_put_u8(msg, NL802154_ATTR_MIN_BE, wpan_dev->min_be))\n\t\tgoto nla_put_failure;\n\n\t \n\tif (nla_put_u8(msg, NL802154_ATTR_LBT_MODE, wpan_dev->lbt))\n\t\tgoto nla_put_failure;\n\n\t \n\tif (nla_put_u8(msg, NL802154_ATTR_ACKREQ_DEFAULT, wpan_dev->ackreq))\n\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_IEEE802154_NL802154_EXPERIMENTAL\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR)\n\t\tgoto out;\n\n\tif (nl802154_get_llsec_params(msg, rdev, wpan_dev) < 0)\n\t\tgoto nla_put_failure;\n\nout:\n#endif  \n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl802154_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tstruct cfg802154_registered_device *rdev;\n\tstruct wpan_dev *wpan_dev;\n\n\trtnl_lock();\n\tlist_for_each_entry(rdev, &cfg802154_rdev_list, list) {\n\t\tif (!net_eq(wpan_phy_net(&rdev->wpan_phy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif_idx = 0;\n\n\t\tlist_for_each_entry(wpan_dev, &rdev->wpan_dev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl802154_send_iface(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t\trdev, wpan_dev) < 0) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\n\t\twp_idx++;\n\t}\nout:\n\trtnl_unlock();\n\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\n\treturn skb->len;\n}\n\nstatic int nl802154_get_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct wpan_dev *wdev = info->user_ptr[1];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl802154_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\trdev, wdev) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl802154_new_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tenum nl802154_iftype type = NL802154_IFTYPE_UNSPEC;\n\t__le64 extended_addr = cpu_to_le64(0x0000000000000000ULL);\n\n\t \n\n\tif (!info->attrs[NL802154_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL802154_ATTR_IFTYPE]) {\n\t\ttype = nla_get_u32(info->attrs[NL802154_ATTR_IFTYPE]);\n\t\tif (type > NL802154_IFTYPE_MAX ||\n\t\t    !(rdev->wpan_phy.supported.iftypes & BIT(type)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL802154_ATTR_EXTENDED_ADDR])\n\t\textended_addr = nla_get_le64(info->attrs[NL802154_ATTR_EXTENDED_ADDR]);\n\n\tif (!rdev->ops->add_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_add_virtual_intf(rdev,\n\t\t\t\t     nla_data(info->attrs[NL802154_ATTR_IFNAME]),\n\t\t\t\t     NET_NAME_USER, type, extended_addr);\n}\n\nstatic int nl802154_del_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct wpan_dev *wpan_dev = info->user_ptr[1];\n\n\tif (!rdev->ops->del_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!wpan_dev->netdev)\n\t\tinfo->user_ptr[1] = NULL;\n\n\treturn rdev_del_virtual_intf(rdev, wpan_dev);\n}\n\nstatic int nl802154_set_channel(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tu8 channel, page;\n\n\tif (!info->attrs[NL802154_ATTR_PAGE] ||\n\t    !info->attrs[NL802154_ATTR_CHANNEL])\n\t\treturn -EINVAL;\n\n\tpage = nla_get_u8(info->attrs[NL802154_ATTR_PAGE]);\n\tchannel = nla_get_u8(info->attrs[NL802154_ATTR_CHANNEL]);\n\n\t \n\tif (!ieee802154_chan_is_valid(&rdev->wpan_phy, page, channel))\n\t\treturn -EINVAL;\n\n\treturn rdev_set_channel(rdev, page, channel);\n}\n\nstatic int nl802154_set_cca_mode(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct wpan_phy_cca cca;\n\n\tif (!(rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_MODE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL802154_ATTR_CCA_MODE])\n\t\treturn -EINVAL;\n\n\tcca.mode = nla_get_u32(info->attrs[NL802154_ATTR_CCA_MODE]);\n\t \n\tif (cca.mode < NL802154_CCA_ENERGY ||\n\t    cca.mode > NL802154_CCA_ATTR_MAX ||\n\t    !(rdev->wpan_phy.supported.cca_modes & BIT(cca.mode)))\n\t\treturn -EINVAL;\n\n\tif (cca.mode == NL802154_CCA_ENERGY_CARRIER) {\n\t\tif (!info->attrs[NL802154_ATTR_CCA_OPT])\n\t\t\treturn -EINVAL;\n\n\t\tcca.opt = nla_get_u32(info->attrs[NL802154_ATTR_CCA_OPT]);\n\t\tif (cca.opt > NL802154_CCA_OPT_ATTR_MAX ||\n\t\t    !(rdev->wpan_phy.supported.cca_opts & BIT(cca.opt)))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn rdev_set_cca_mode(rdev, &cca);\n}\n\nstatic int nl802154_set_cca_ed_level(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\ts32 ed_level;\n\tint i;\n\n\tif (!(rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_ED_LEVEL))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL802154_ATTR_CCA_ED_LEVEL])\n\t\treturn -EINVAL;\n\n\ted_level = nla_get_s32(info->attrs[NL802154_ATTR_CCA_ED_LEVEL]);\n\n\tfor (i = 0; i < rdev->wpan_phy.supported.cca_ed_levels_size; i++) {\n\t\tif (ed_level == rdev->wpan_phy.supported.cca_ed_levels[i])\n\t\t\treturn rdev_set_cca_ed_level(rdev, ed_level);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nl802154_set_tx_power(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\ts32 power;\n\tint i;\n\n\tif (!(rdev->wpan_phy.flags & WPAN_PHY_FLAG_TXPOWER))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL802154_ATTR_TX_POWER])\n\t\treturn -EINVAL;\n\n\tpower = nla_get_s32(info->attrs[NL802154_ATTR_TX_POWER]);\n\n\tfor (i = 0; i < rdev->wpan_phy.supported.tx_powers_size; i++) {\n\t\tif (power == rdev->wpan_phy.supported.tx_powers[i])\n\t\t\treturn rdev_set_tx_power(rdev, power);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nl802154_set_pan_id(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\t__le16 pan_id;\n\n\t \n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (wpan_dev->lowpan_dev) {\n\t\tif (netif_running(wpan_dev->lowpan_dev))\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR ||\n\t    !info->attrs[NL802154_ATTR_PAN_ID])\n\t\treturn -EINVAL;\n\n\tpan_id = nla_get_le16(info->attrs[NL802154_ATTR_PAN_ID]);\n\n\t \n\tif (pan_id == cpu_to_le16(IEEE802154_PAN_ID_BROADCAST))\n\t\treturn -EINVAL;\n\n\treturn rdev_set_pan_id(rdev, wpan_dev, pan_id);\n}\n\nstatic int nl802154_set_short_addr(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\t__le16 short_addr;\n\n\t \n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (wpan_dev->lowpan_dev) {\n\t\tif (netif_running(wpan_dev->lowpan_dev))\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR ||\n\t    !info->attrs[NL802154_ATTR_SHORT_ADDR])\n\t\treturn -EINVAL;\n\n\tshort_addr = nla_get_le16(info->attrs[NL802154_ATTR_SHORT_ADDR]);\n\n\t \n\tif (short_addr == cpu_to_le16(IEEE802154_ADDR_SHORT_UNSPEC) ||\n\t    short_addr == cpu_to_le16(IEEE802154_ADDR_SHORT_BROADCAST))\n\t\treturn -EINVAL;\n\n\treturn rdev_set_short_addr(rdev, wpan_dev, short_addr);\n}\n\nstatic int\nnl802154_set_backoff_exponent(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tu8 min_be, max_be;\n\n\t \n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!info->attrs[NL802154_ATTR_MIN_BE] ||\n\t    !info->attrs[NL802154_ATTR_MAX_BE])\n\t\treturn -EINVAL;\n\n\tmin_be = nla_get_u8(info->attrs[NL802154_ATTR_MIN_BE]);\n\tmax_be = nla_get_u8(info->attrs[NL802154_ATTR_MAX_BE]);\n\n\t \n\tif (min_be < rdev->wpan_phy.supported.min_minbe ||\n\t    min_be > rdev->wpan_phy.supported.max_minbe ||\n\t    max_be < rdev->wpan_phy.supported.min_maxbe ||\n\t    max_be > rdev->wpan_phy.supported.max_maxbe ||\n\t    min_be > max_be)\n\t\treturn -EINVAL;\n\n\treturn rdev_set_backoff_exponent(rdev, wpan_dev, min_be, max_be);\n}\n\nstatic int\nnl802154_set_max_csma_backoffs(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tu8 max_csma_backoffs;\n\n\t \n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!info->attrs[NL802154_ATTR_MAX_CSMA_BACKOFFS])\n\t\treturn -EINVAL;\n\n\tmax_csma_backoffs = nla_get_u8(\n\t\t\tinfo->attrs[NL802154_ATTR_MAX_CSMA_BACKOFFS]);\n\n\t \n\tif (max_csma_backoffs < rdev->wpan_phy.supported.min_csma_backoffs ||\n\t    max_csma_backoffs > rdev->wpan_phy.supported.max_csma_backoffs)\n\t\treturn -EINVAL;\n\n\treturn rdev_set_max_csma_backoffs(rdev, wpan_dev, max_csma_backoffs);\n}\n\nstatic int\nnl802154_set_max_frame_retries(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\ts8 max_frame_retries;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!info->attrs[NL802154_ATTR_MAX_FRAME_RETRIES])\n\t\treturn -EINVAL;\n\n\tmax_frame_retries = nla_get_s8(\n\t\t\tinfo->attrs[NL802154_ATTR_MAX_FRAME_RETRIES]);\n\n\t \n\tif (max_frame_retries < rdev->wpan_phy.supported.min_frame_retries ||\n\t    max_frame_retries > rdev->wpan_phy.supported.max_frame_retries)\n\t\treturn -EINVAL;\n\n\treturn rdev_set_max_frame_retries(rdev, wpan_dev, max_frame_retries);\n}\n\nstatic int nl802154_set_lbt_mode(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tint mode;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!info->attrs[NL802154_ATTR_LBT_MODE])\n\t\treturn -EINVAL;\n\n\tmode = nla_get_u8(info->attrs[NL802154_ATTR_LBT_MODE]);\n\n\tif (mode != 0 && mode != 1)\n\t\treturn -EINVAL;\n\n\tif (!wpan_phy_supported_bool(mode, rdev->wpan_phy.supported.lbt))\n\t\treturn -EINVAL;\n\n\treturn rdev_set_lbt_mode(rdev, wpan_dev, mode);\n}\n\nstatic int\nnl802154_set_ackreq_default(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tint ackreq;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!info->attrs[NL802154_ATTR_ACKREQ_DEFAULT])\n\t\treturn -EINVAL;\n\n\tackreq = nla_get_u8(info->attrs[NL802154_ATTR_ACKREQ_DEFAULT]);\n\n\tif (ackreq != 0 && ackreq != 1)\n\t\treturn -EINVAL;\n\n\treturn rdev_set_ackreq_default(rdev, wpan_dev, ackreq);\n}\n\nstatic int nl802154_wpan_phy_netns(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net *net;\n\tint err;\n\n\tif (info->attrs[NL802154_ATTR_PID]) {\n\t\tu32 pid = nla_get_u32(info->attrs[NL802154_ATTR_PID]);\n\n\t\tnet = get_net_ns_by_pid(pid);\n\t} else if (info->attrs[NL802154_ATTR_NETNS_FD]) {\n\t\tu32 fd = nla_get_u32(info->attrs[NL802154_ATTR_NETNS_FD]);\n\n\t\tnet = get_net_ns_by_fd(fd);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\terr = 0;\n\n\t \n\tif (!net_eq(wpan_phy_net(&rdev->wpan_phy), net))\n\t\terr = cfg802154_switch_netns(rdev, net);\n\n\tput_net(net);\n\treturn err;\n}\n\nstatic int nl802154_prep_scan_event_msg(struct sk_buff *msg,\n\t\t\t\t\tstruct cfg802154_registered_device *rdev,\n\t\t\t\t\tstruct wpan_dev *wpan_dev,\n\t\t\t\t\tu32 portid, u32 seq, int flags, u8 cmd,\n\t\t\t\t\tstruct ieee802154_coord_desc *desc)\n{\n\tstruct nlattr *nla;\n\tvoid *hdr;\n\n\thdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL802154_ATTR_WPAN_PHY, rdev->wpan_phy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (wpan_dev->netdev &&\n\t    nla_put_u32(msg, NL802154_ATTR_IFINDEX, wpan_dev->netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL802154_ATTR_WPAN_DEV,\n\t\t\t      wpan_dev_id(wpan_dev), NL802154_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla = nla_nest_start_noflag(msg, NL802154_ATTR_COORDINATOR);\n\tif (!nla)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL802154_COORD_PANID, IEEE802154_PAN_ID_LEN,\n\t\t    &desc->addr.pan_id))\n\t\tgoto nla_put_failure;\n\n\tif (desc->addr.mode == IEEE802154_ADDR_SHORT) {\n\t\tif (nla_put(msg, NL802154_COORD_ADDR,\n\t\t\t    IEEE802154_SHORT_ADDR_LEN,\n\t\t\t    &desc->addr.short_addr))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tif (nla_put(msg, NL802154_COORD_ADDR,\n\t\t\t    IEEE802154_EXTENDED_ADDR_LEN,\n\t\t\t    &desc->addr.extended_addr))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u8(msg, NL802154_COORD_CHANNEL, desc->channel))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL802154_COORD_PAGE, desc->page))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(msg, NL802154_COORD_SUPERFRAME_SPEC,\n\t\t\tdesc->superframe_spec))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL802154_COORD_LINK_QUALITY, desc->link_quality))\n\t\tgoto nla_put_failure;\n\n\tif (desc->gts_permit && nla_put_flag(msg, NL802154_COORD_GTS_PERMIT))\n\t\tgoto nla_put_failure;\n\n\t \n\n\tnla_nest_end(msg, nla);\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nint nl802154_scan_event(struct wpan_phy *wpan_phy, struct wpan_dev *wpan_dev,\n\t\t\tstruct ieee802154_coord_desc *desc)\n{\n\tstruct cfg802154_registered_device *rdev = wpan_phy_to_rdev(wpan_phy);\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = nl802154_prep_scan_event_msg(msg, rdev, wpan_dev, 0, 0, 0,\n\t\t\t\t\t   NL802154_CMD_SCAN_EVENT,\n\t\t\t\t\t   desc);\n\tif (ret < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn ret;\n\t}\n\n\treturn genlmsg_multicast_netns(&nl802154_fam, wpan_phy_net(wpan_phy),\n\t\t\t\t       msg, 0, NL802154_MCGRP_SCAN, GFP_ATOMIC);\n}\nEXPORT_SYMBOL_GPL(nl802154_scan_event);\n\nstatic int nl802154_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct wpan_phy *wpan_phy = &rdev->wpan_phy;\n\tstruct cfg802154_scan_request *request;\n\tu8 type;\n\tint err;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Monitors are not allowed to perform scans\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL802154_ATTR_SCAN_TYPE]) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Malformed request, missing scan type\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wpan_phy->flags & WPAN_PHY_FLAG_DATAGRAMS_ONLY) {\n\t\tNL_SET_ERR_MSG(info->extack, \"PHY only supports datagrams\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trequest = kzalloc(sizeof(*request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\trequest->wpan_dev = wpan_dev;\n\trequest->wpan_phy = wpan_phy;\n\n\ttype = nla_get_u8(info->attrs[NL802154_ATTR_SCAN_TYPE]);\n\tswitch (type) {\n\tcase NL802154_SCAN_ACTIVE:\n\tcase NL802154_SCAN_PASSIVE:\n\t\trequest->type = type;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_FMT(info->extack, \"Unsupported scan type: %d\", type);\n\t\terr = -EINVAL;\n\t\tgoto free_request;\n\t}\n\n\t \n\tif (info->attrs[NL802154_ATTR_PAGE])\n\t\trequest->page = nla_get_u8(info->attrs[NL802154_ATTR_PAGE]);\n\telse\n\t\trequest->page = wpan_phy->current_page;\n\n\t \n\tif (info->attrs[NL802154_ATTR_SCAN_CHANNELS])\n\t\trequest->channels = nla_get_u32(info->attrs[NL802154_ATTR_SCAN_CHANNELS]);\n\telse\n\t\trequest->channels = wpan_phy->supported.channels[request->page];\n\n\t \n\tif (info->attrs[NL802154_ATTR_SCAN_DURATION])\n\t\trequest->duration = nla_get_u8(info->attrs[NL802154_ATTR_SCAN_DURATION]);\n\telse\n\t\trequest->duration = IEEE802154_MAX_SCAN_DURATION;\n\n\terr = rdev_trigger_scan(rdev, request);\n\tif (err) {\n\t\tpr_err(\"Failure starting scanning (%d)\\n\", err);\n\t\tgoto free_request;\n\t}\n\n\treturn 0;\n\nfree_request:\n\tkfree(request);\n\n\treturn err;\n}\n\nstatic int nl802154_prep_scan_msg(struct sk_buff *msg,\n\t\t\t\t  struct cfg802154_registered_device *rdev,\n\t\t\t\t  struct wpan_dev *wpan_dev, u32 portid,\n\t\t\t\t  u32 seq, int flags, u8 cmd, u8 arg)\n{\n\tvoid *hdr;\n\n\thdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL802154_ATTR_WPAN_PHY, rdev->wpan_phy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (wpan_dev->netdev &&\n\t    nla_put_u32(msg, NL802154_ATTR_IFINDEX, wpan_dev->netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL802154_ATTR_WPAN_DEV,\n\t\t\t      wpan_dev_id(wpan_dev), NL802154_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (cmd == NL802154_CMD_SCAN_DONE &&\n\t    nla_put_u8(msg, NL802154_ATTR_SCAN_DONE_REASON, arg))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nstatic int nl802154_send_scan_msg(struct cfg802154_registered_device *rdev,\n\t\t\t\t  struct wpan_dev *wpan_dev, u8 cmd, u8 arg)\n{\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = nl802154_prep_scan_msg(msg, rdev, wpan_dev, 0, 0, 0, cmd, arg);\n\tif (ret < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn ret;\n\t}\n\n\treturn genlmsg_multicast_netns(&nl802154_fam,\n\t\t\t\t       wpan_phy_net(&rdev->wpan_phy), msg, 0,\n\t\t\t\t       NL802154_MCGRP_SCAN, GFP_KERNEL);\n}\n\nint nl802154_scan_started(struct wpan_phy *wpan_phy, struct wpan_dev *wpan_dev)\n{\n\tstruct cfg802154_registered_device *rdev = wpan_phy_to_rdev(wpan_phy);\n\tint err;\n\n\t \n\terr = nl802154_send_scan_msg(rdev, wpan_dev, NL802154_CMD_TRIGGER_SCAN, 0);\n\tif (err == -ESRCH)\n\t\terr = 0;\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nl802154_scan_started);\n\nint nl802154_scan_done(struct wpan_phy *wpan_phy, struct wpan_dev *wpan_dev,\n\t\t       enum nl802154_scan_done_reasons reason)\n{\n\tstruct cfg802154_registered_device *rdev = wpan_phy_to_rdev(wpan_phy);\n\tint err;\n\n\t \n\terr = nl802154_send_scan_msg(rdev, wpan_dev, NL802154_CMD_SCAN_DONE, reason);\n\tif (err == -ESRCH)\n\t\terr = 0;\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nl802154_scan_done);\n\nstatic int nl802154_abort_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\n\t \n\treturn rdev_abort_scan(rdev, wpan_dev);\n}\n\nstatic int\nnl802154_send_beacons(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct wpan_phy *wpan_phy = &rdev->wpan_phy;\n\tstruct cfg802154_beacon_request *request;\n\tint err;\n\n\tif (wpan_dev->iftype != NL802154_IFTYPE_COORD) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Only coordinators can send beacons\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (wpan_dev->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST)) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Device is not part of any PAN\");\n\t\treturn -EPERM;\n\t}\n\n\tif (wpan_phy->flags & WPAN_PHY_FLAG_DATAGRAMS_ONLY) {\n\t\tNL_SET_ERR_MSG(info->extack, \"PHY only supports datagrams\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trequest = kzalloc(sizeof(*request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\trequest->wpan_dev = wpan_dev;\n\trequest->wpan_phy = wpan_phy;\n\n\t \n\tif (info->attrs[NL802154_ATTR_BEACON_INTERVAL])\n\t\trequest->interval = nla_get_u8(info->attrs[NL802154_ATTR_BEACON_INTERVAL]);\n\telse\n\t\trequest->interval = IEEE802154_MAX_SCAN_DURATION;\n\n\terr = rdev_send_beacons(rdev, request);\n\tif (err) {\n\t\tpr_err(\"Failure starting sending beacons (%d)\\n\", err);\n\t\tgoto free_request;\n\t}\n\n\treturn 0;\n\nfree_request:\n\tkfree(request);\n\n\treturn err;\n}\n\nvoid nl802154_beaconing_done(struct wpan_dev *wpan_dev)\n{\n\t \n}\nEXPORT_SYMBOL_GPL(nl802154_beaconing_done);\n\nstatic int\nnl802154_stop_beacons(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\n\t \n\treturn rdev_stop_beacons(rdev, wpan_dev);\n}\n\n#ifdef CONFIG_IEEE802154_NL802154_EXPERIMENTAL\nstatic const struct nla_policy nl802154_dev_addr_policy[NL802154_DEV_ADDR_ATTR_MAX + 1] = {\n\t[NL802154_DEV_ADDR_ATTR_PAN_ID] = { .type = NLA_U16 },\n\t[NL802154_DEV_ADDR_ATTR_MODE] = { .type = NLA_U32 },\n\t[NL802154_DEV_ADDR_ATTR_SHORT] = { .type = NLA_U16 },\n\t[NL802154_DEV_ADDR_ATTR_EXTENDED] = { .type = NLA_U64 },\n};\n\nstatic int\nieee802154_llsec_parse_dev_addr(struct nlattr *nla,\n\t\t\t\tstruct ieee802154_addr *addr)\n{\n\tstruct nlattr *attrs[NL802154_DEV_ADDR_ATTR_MAX + 1];\n\n\tif (!nla || nla_parse_nested_deprecated(attrs, NL802154_DEV_ADDR_ATTR_MAX, nla, nl802154_dev_addr_policy, NULL))\n\t\treturn -EINVAL;\n\n\tif (!attrs[NL802154_DEV_ADDR_ATTR_PAN_ID] || !attrs[NL802154_DEV_ADDR_ATTR_MODE])\n\t\treturn -EINVAL;\n\n\taddr->pan_id = nla_get_le16(attrs[NL802154_DEV_ADDR_ATTR_PAN_ID]);\n\taddr->mode = nla_get_u32(attrs[NL802154_DEV_ADDR_ATTR_MODE]);\n\tswitch (addr->mode) {\n\tcase NL802154_DEV_ADDR_SHORT:\n\t\tif (!attrs[NL802154_DEV_ADDR_ATTR_SHORT])\n\t\t\treturn -EINVAL;\n\t\taddr->short_addr = nla_get_le16(attrs[NL802154_DEV_ADDR_ATTR_SHORT]);\n\t\tbreak;\n\tcase NL802154_DEV_ADDR_EXTENDED:\n\t\tif (!attrs[NL802154_DEV_ADDR_ATTR_EXTENDED])\n\t\t\treturn -EINVAL;\n\t\taddr->extended_addr = nla_get_le64(attrs[NL802154_DEV_ADDR_ATTR_EXTENDED]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nla_policy nl802154_key_id_policy[NL802154_KEY_ID_ATTR_MAX + 1] = {\n\t[NL802154_KEY_ID_ATTR_MODE] = { .type = NLA_U32 },\n\t[NL802154_KEY_ID_ATTR_INDEX] = { .type = NLA_U8 },\n\t[NL802154_KEY_ID_ATTR_IMPLICIT] = { .type = NLA_NESTED },\n\t[NL802154_KEY_ID_ATTR_SOURCE_SHORT] = { .type = NLA_U32 },\n\t[NL802154_KEY_ID_ATTR_SOURCE_EXTENDED] = { .type = NLA_U64 },\n};\n\nstatic int\nieee802154_llsec_parse_key_id(struct nlattr *nla,\n\t\t\t      struct ieee802154_llsec_key_id *desc)\n{\n\tstruct nlattr *attrs[NL802154_KEY_ID_ATTR_MAX + 1];\n\n\tif (!nla || nla_parse_nested_deprecated(attrs, NL802154_KEY_ID_ATTR_MAX, nla, nl802154_key_id_policy, NULL))\n\t\treturn -EINVAL;\n\n\tif (!attrs[NL802154_KEY_ID_ATTR_MODE])\n\t\treturn -EINVAL;\n\n\tdesc->mode = nla_get_u32(attrs[NL802154_KEY_ID_ATTR_MODE]);\n\tswitch (desc->mode) {\n\tcase NL802154_KEY_ID_MODE_IMPLICIT:\n\t\tif (!attrs[NL802154_KEY_ID_ATTR_IMPLICIT])\n\t\t\treturn -EINVAL;\n\n\t\tif (ieee802154_llsec_parse_dev_addr(attrs[NL802154_KEY_ID_ATTR_IMPLICIT],\n\t\t\t\t\t\t    &desc->device_addr) < 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL802154_KEY_ID_MODE_INDEX:\n\t\tbreak;\n\tcase NL802154_KEY_ID_MODE_INDEX_SHORT:\n\t\tif (!attrs[NL802154_KEY_ID_ATTR_SOURCE_SHORT])\n\t\t\treturn -EINVAL;\n\n\t\tdesc->short_source = nla_get_le32(attrs[NL802154_KEY_ID_ATTR_SOURCE_SHORT]);\n\t\tbreak;\n\tcase NL802154_KEY_ID_MODE_INDEX_EXTENDED:\n\t\tif (!attrs[NL802154_KEY_ID_ATTR_SOURCE_EXTENDED])\n\t\t\treturn -EINVAL;\n\n\t\tdesc->extended_source = nla_get_le64(attrs[NL802154_KEY_ID_ATTR_SOURCE_EXTENDED]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->mode != NL802154_KEY_ID_MODE_IMPLICIT) {\n\t\tif (!attrs[NL802154_KEY_ID_ATTR_INDEX])\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tdesc->id = nla_get_u8(attrs[NL802154_KEY_ID_ATTR_INDEX]);\n\t}\n\n\treturn 0;\n}\n\nstatic int nl802154_set_llsec_params(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct ieee802154_llsec_params params;\n\tu32 changed = 0;\n\tint ret;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL802154_ATTR_SEC_ENABLED]) {\n\t\tu8 enabled;\n\n\t\tenabled = nla_get_u8(info->attrs[NL802154_ATTR_SEC_ENABLED]);\n\t\tif (enabled != 0 && enabled != 1)\n\t\t\treturn -EINVAL;\n\n\t\tparams.enabled = nla_get_u8(info->attrs[NL802154_ATTR_SEC_ENABLED]);\n\t\tchanged |= IEEE802154_LLSEC_PARAM_ENABLED;\n\t}\n\n\tif (info->attrs[NL802154_ATTR_SEC_OUT_KEY_ID]) {\n\t\tret = ieee802154_llsec_parse_key_id(info->attrs[NL802154_ATTR_SEC_OUT_KEY_ID],\n\t\t\t\t\t\t    &params.out_key);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tchanged |= IEEE802154_LLSEC_PARAM_OUT_KEY;\n\t}\n\n\tif (info->attrs[NL802154_ATTR_SEC_OUT_LEVEL]) {\n\t\tparams.out_level = nla_get_u32(info->attrs[NL802154_ATTR_SEC_OUT_LEVEL]);\n\t\tif (params.out_level > NL802154_SECLEVEL_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tchanged |= IEEE802154_LLSEC_PARAM_OUT_LEVEL;\n\t}\n\n\tif (info->attrs[NL802154_ATTR_SEC_FRAME_COUNTER]) {\n\t\tparams.frame_counter = nla_get_be32(info->attrs[NL802154_ATTR_SEC_FRAME_COUNTER]);\n\t\tchanged |= IEEE802154_LLSEC_PARAM_FRAME_COUNTER;\n\t}\n\n\treturn rdev_set_llsec_params(rdev, wpan_dev, &params, changed);\n}\n\nstatic int nl802154_send_key(struct sk_buff *msg, u32 cmd, u32 portid,\n\t\t\t     u32 seq, int flags,\n\t\t\t     struct cfg802154_registered_device *rdev,\n\t\t\t     struct net_device *dev,\n\t\t\t     const struct ieee802154_llsec_key_entry *key)\n{\n\tvoid *hdr;\n\tu32 commands[NL802154_CMD_FRAME_NR_IDS / 32];\n\tstruct nlattr *nl_key, *nl_key_id;\n\n\thdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL802154_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tnl_key = nla_nest_start_noflag(msg, NL802154_ATTR_SEC_KEY);\n\tif (!nl_key)\n\t\tgoto nla_put_failure;\n\n\tnl_key_id = nla_nest_start_noflag(msg, NL802154_KEY_ATTR_ID);\n\tif (!nl_key_id)\n\t\tgoto nla_put_failure;\n\n\tif (ieee802154_llsec_send_key_id(msg, &key->id) < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, nl_key_id);\n\n\tif (nla_put_u8(msg, NL802154_KEY_ATTR_USAGE_FRAMES,\n\t\t       key->key->frame_types))\n\t\tgoto nla_put_failure;\n\n\tif (key->key->frame_types & BIT(NL802154_FRAME_CMD)) {\n\t\t \n\t\tmemset(commands, 0, sizeof(commands));\n\t\tcommands[7] = key->key->cmd_frame_ids;\n\t\tif (nla_put(msg, NL802154_KEY_ATTR_USAGE_CMDS,\n\t\t\t    sizeof(commands), commands))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put(msg, NL802154_KEY_ATTR_BYTES, NL802154_KEY_SIZE,\n\t\t    key->key->key))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, nl_key);\n\tgenlmsg_end(msg, hdr);\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl802154_dump_llsec_key(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct cfg802154_registered_device *rdev = NULL;\n\tstruct ieee802154_llsec_key_entry *key;\n\tstruct ieee802154_llsec_table *table;\n\tstruct wpan_dev *wpan_dev;\n\tint err;\n\n\terr = nl802154_prepare_wpan_dev_dump(skb, cb, &rdev, &wpan_dev);\n\tif (err)\n\t\treturn err;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR) {\n\t\terr = skb->len;\n\t\tgoto out_err;\n\t}\n\n\tif (!wpan_dev->netdev) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\trdev_lock_llsec_table(rdev, wpan_dev);\n\trdev_get_llsec_table(rdev, wpan_dev, &table);\n\n\t \n\tif (cb->args[2])\n\t\tgoto out;\n\n\tlist_for_each_entry(key, &table->keys, list) {\n\t\tif (nl802154_send_key(skb, NL802154_CMD_NEW_SEC_KEY,\n\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t      cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t      rdev, wpan_dev->netdev, key) < 0) {\n\t\t\t \n\t\t\terr = -EIO;\n\t\t\trdev_unlock_llsec_table(rdev, wpan_dev);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tcb->args[2] = 1;\n\nout:\n\trdev_unlock_llsec_table(rdev, wpan_dev);\n\terr = skb->len;\nout_err:\n\tnl802154_finish_wpan_dev_dump(rdev);\n\n\treturn err;\n}\n\nstatic const struct nla_policy nl802154_key_policy[NL802154_KEY_ATTR_MAX + 1] = {\n\t[NL802154_KEY_ATTR_ID] = { NLA_NESTED },\n\t \n\t[NL802154_KEY_ATTR_USAGE_FRAMES] = { NLA_U8 },\n\t \n\t[NL802154_KEY_ATTR_USAGE_CMDS] = { .len = NL802154_CMD_FRAME_NR_IDS / 8 },\n\t[NL802154_KEY_ATTR_BYTES] = { .len = NL802154_KEY_SIZE },\n};\n\nstatic int nl802154_add_llsec_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct nlattr *attrs[NL802154_KEY_ATTR_MAX + 1];\n\tstruct ieee802154_llsec_key key = { };\n\tstruct ieee802154_llsec_key_id id = { };\n\tu32 commands[NL802154_CMD_FRAME_NR_IDS / 32] = { };\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL802154_ATTR_SEC_KEY] ||\n\t    nla_parse_nested_deprecated(attrs, NL802154_KEY_ATTR_MAX, info->attrs[NL802154_ATTR_SEC_KEY], nl802154_key_policy, info->extack))\n\t\treturn -EINVAL;\n\n\tif (!attrs[NL802154_KEY_ATTR_USAGE_FRAMES] ||\n\t    !attrs[NL802154_KEY_ATTR_BYTES])\n\t\treturn -EINVAL;\n\n\tif (ieee802154_llsec_parse_key_id(attrs[NL802154_KEY_ATTR_ID], &id) < 0)\n\t\treturn -ENOBUFS;\n\n\tkey.frame_types = nla_get_u8(attrs[NL802154_KEY_ATTR_USAGE_FRAMES]);\n\tif (key.frame_types > BIT(NL802154_FRAME_MAX) ||\n\t    ((key.frame_types & BIT(NL802154_FRAME_CMD)) &&\n\t     !attrs[NL802154_KEY_ATTR_USAGE_CMDS]))\n\t\treturn -EINVAL;\n\n\tif (attrs[NL802154_KEY_ATTR_USAGE_CMDS]) {\n\t\t \n\t\tnla_memcpy(commands, attrs[NL802154_KEY_ATTR_USAGE_CMDS],\n\t\t\t   NL802154_CMD_FRAME_NR_IDS / 8);\n\n\t\t \n\t\tif (commands[0] || commands[1] || commands[2] || commands[3] ||\n\t\t    commands[4] || commands[5] || commands[6] ||\n\t\t    commands[7] > BIT(NL802154_CMD_FRAME_MAX))\n\t\t\treturn -EINVAL;\n\n\t\tkey.cmd_frame_ids = commands[7];\n\t} else {\n\t\tkey.cmd_frame_ids = 0;\n\t}\n\n\tnla_memcpy(key.key, attrs[NL802154_KEY_ATTR_BYTES], NL802154_KEY_SIZE);\n\n\tif (ieee802154_llsec_parse_key_id(attrs[NL802154_KEY_ATTR_ID], &id) < 0)\n\t\treturn -ENOBUFS;\n\n\treturn rdev_add_llsec_key(rdev, wpan_dev, &id, &key);\n}\n\nstatic int nl802154_del_llsec_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct nlattr *attrs[NL802154_KEY_ATTR_MAX + 1];\n\tstruct ieee802154_llsec_key_id id;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL802154_ATTR_SEC_KEY] ||\n\t    nla_parse_nested_deprecated(attrs, NL802154_KEY_ATTR_MAX, info->attrs[NL802154_ATTR_SEC_KEY], nl802154_key_policy, info->extack))\n\t\treturn -EINVAL;\n\n\tif (ieee802154_llsec_parse_key_id(attrs[NL802154_KEY_ATTR_ID], &id) < 0)\n\t\treturn -ENOBUFS;\n\n\treturn rdev_del_llsec_key(rdev, wpan_dev, &id);\n}\n\nstatic int nl802154_send_device(struct sk_buff *msg, u32 cmd, u32 portid,\n\t\t\t\tu32 seq, int flags,\n\t\t\t\tstruct cfg802154_registered_device *rdev,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tconst struct ieee802154_llsec_device *dev_desc)\n{\n\tvoid *hdr;\n\tstruct nlattr *nl_device;\n\n\thdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL802154_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tnl_device = nla_nest_start_noflag(msg, NL802154_ATTR_SEC_DEVICE);\n\tif (!nl_device)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL802154_DEV_ATTR_FRAME_COUNTER,\n\t\t\tdev_desc->frame_counter) ||\n\t    nla_put_le16(msg, NL802154_DEV_ATTR_PAN_ID, dev_desc->pan_id) ||\n\t    nla_put_le16(msg, NL802154_DEV_ATTR_SHORT_ADDR,\n\t\t\t dev_desc->short_addr) ||\n\t    nla_put_le64(msg, NL802154_DEV_ATTR_EXTENDED_ADDR,\n\t\t\t dev_desc->hwaddr, NL802154_DEV_ATTR_PAD) ||\n\t    nla_put_u8(msg, NL802154_DEV_ATTR_SECLEVEL_EXEMPT,\n\t\t       dev_desc->seclevel_exempt) ||\n\t    nla_put_u32(msg, NL802154_DEV_ATTR_KEY_MODE, dev_desc->key_mode))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, nl_device);\n\tgenlmsg_end(msg, hdr);\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl802154_dump_llsec_dev(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct cfg802154_registered_device *rdev = NULL;\n\tstruct ieee802154_llsec_device *dev;\n\tstruct ieee802154_llsec_table *table;\n\tstruct wpan_dev *wpan_dev;\n\tint err;\n\n\terr = nl802154_prepare_wpan_dev_dump(skb, cb, &rdev, &wpan_dev);\n\tif (err)\n\t\treturn err;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR) {\n\t\terr = skb->len;\n\t\tgoto out_err;\n\t}\n\n\tif (!wpan_dev->netdev) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\trdev_lock_llsec_table(rdev, wpan_dev);\n\trdev_get_llsec_table(rdev, wpan_dev, &table);\n\n\t \n\tif (cb->args[2])\n\t\tgoto out;\n\n\tlist_for_each_entry(dev, &table->devices, list) {\n\t\tif (nl802154_send_device(skb, NL802154_CMD_NEW_SEC_LEVEL,\n\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t rdev, wpan_dev->netdev, dev) < 0) {\n\t\t\t \n\t\t\terr = -EIO;\n\t\t\trdev_unlock_llsec_table(rdev, wpan_dev);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tcb->args[2] = 1;\n\nout:\n\trdev_unlock_llsec_table(rdev, wpan_dev);\n\terr = skb->len;\nout_err:\n\tnl802154_finish_wpan_dev_dump(rdev);\n\n\treturn err;\n}\n\nstatic const struct nla_policy nl802154_dev_policy[NL802154_DEV_ATTR_MAX + 1] = {\n\t[NL802154_DEV_ATTR_FRAME_COUNTER] = { NLA_U32 },\n\t[NL802154_DEV_ATTR_PAN_ID] = { .type = NLA_U16 },\n\t[NL802154_DEV_ATTR_SHORT_ADDR] = { .type = NLA_U16 },\n\t[NL802154_DEV_ATTR_EXTENDED_ADDR] = { .type = NLA_U64 },\n\t[NL802154_DEV_ATTR_SECLEVEL_EXEMPT] = { NLA_U8 },\n\t[NL802154_DEV_ATTR_KEY_MODE] = { NLA_U32 },\n};\n\nstatic int\nieee802154_llsec_parse_device(struct nlattr *nla,\n\t\t\t      struct ieee802154_llsec_device *dev)\n{\n\tstruct nlattr *attrs[NL802154_DEV_ATTR_MAX + 1];\n\n\tif (!nla || nla_parse_nested_deprecated(attrs, NL802154_DEV_ATTR_MAX, nla, nl802154_dev_policy, NULL))\n\t\treturn -EINVAL;\n\n\tmemset(dev, 0, sizeof(*dev));\n\n\tif (!attrs[NL802154_DEV_ATTR_FRAME_COUNTER] ||\n\t    !attrs[NL802154_DEV_ATTR_PAN_ID] ||\n\t    !attrs[NL802154_DEV_ATTR_SHORT_ADDR] ||\n\t    !attrs[NL802154_DEV_ATTR_EXTENDED_ADDR] ||\n\t    !attrs[NL802154_DEV_ATTR_SECLEVEL_EXEMPT] ||\n\t    !attrs[NL802154_DEV_ATTR_KEY_MODE])\n\t\treturn -EINVAL;\n\n\t \n\tdev->frame_counter = nla_get_u32(attrs[NL802154_DEV_ATTR_FRAME_COUNTER]);\n\tdev->pan_id = nla_get_le16(attrs[NL802154_DEV_ATTR_PAN_ID]);\n\tdev->short_addr = nla_get_le16(attrs[NL802154_DEV_ATTR_SHORT_ADDR]);\n\t \n\tdev->hwaddr = nla_get_le64(attrs[NL802154_DEV_ATTR_EXTENDED_ADDR]);\n\tdev->seclevel_exempt = nla_get_u8(attrs[NL802154_DEV_ATTR_SECLEVEL_EXEMPT]);\n\tdev->key_mode = nla_get_u32(attrs[NL802154_DEV_ATTR_KEY_MODE]);\n\n\tif (dev->key_mode > NL802154_DEVKEY_MAX ||\n\t    (dev->seclevel_exempt != 0 && dev->seclevel_exempt != 1))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nl802154_add_llsec_dev(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct ieee802154_llsec_device dev_desc;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ieee802154_llsec_parse_device(info->attrs[NL802154_ATTR_SEC_DEVICE],\n\t\t\t\t\t  &dev_desc) < 0)\n\t\treturn -EINVAL;\n\n\treturn rdev_add_device(rdev, wpan_dev, &dev_desc);\n}\n\nstatic int nl802154_del_llsec_dev(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct nlattr *attrs[NL802154_DEV_ATTR_MAX + 1];\n\t__le64 extended_addr;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL802154_ATTR_SEC_DEVICE] ||\n\t    nla_parse_nested_deprecated(attrs, NL802154_DEV_ATTR_MAX, info->attrs[NL802154_ATTR_SEC_DEVICE], nl802154_dev_policy, info->extack))\n\t\treturn -EINVAL;\n\n\tif (!attrs[NL802154_DEV_ATTR_EXTENDED_ADDR])\n\t\treturn -EINVAL;\n\n\textended_addr = nla_get_le64(attrs[NL802154_DEV_ATTR_EXTENDED_ADDR]);\n\treturn rdev_del_device(rdev, wpan_dev, extended_addr);\n}\n\nstatic int nl802154_send_devkey(struct sk_buff *msg, u32 cmd, u32 portid,\n\t\t\t\tu32 seq, int flags,\n\t\t\t\tstruct cfg802154_registered_device *rdev,\n\t\t\t\tstruct net_device *dev, __le64 extended_addr,\n\t\t\t\tconst struct ieee802154_llsec_device_key *devkey)\n{\n\tvoid *hdr;\n\tstruct nlattr *nl_devkey, *nl_key_id;\n\n\thdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL802154_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tnl_devkey = nla_nest_start_noflag(msg, NL802154_ATTR_SEC_DEVKEY);\n\tif (!nl_devkey)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_le64(msg, NL802154_DEVKEY_ATTR_EXTENDED_ADDR,\n\t\t\t extended_addr, NL802154_DEVKEY_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL802154_DEVKEY_ATTR_FRAME_COUNTER,\n\t\t\tdevkey->frame_counter))\n\t\tgoto nla_put_failure;\n\n\tnl_key_id = nla_nest_start_noflag(msg, NL802154_DEVKEY_ATTR_ID);\n\tif (!nl_key_id)\n\t\tgoto nla_put_failure;\n\n\tif (ieee802154_llsec_send_key_id(msg, &devkey->key_id) < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, nl_key_id);\n\tnla_nest_end(msg, nl_devkey);\n\tgenlmsg_end(msg, hdr);\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl802154_dump_llsec_devkey(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct cfg802154_registered_device *rdev = NULL;\n\tstruct ieee802154_llsec_device_key *kpos;\n\tstruct ieee802154_llsec_device *dpos;\n\tstruct ieee802154_llsec_table *table;\n\tstruct wpan_dev *wpan_dev;\n\tint err;\n\n\terr = nl802154_prepare_wpan_dev_dump(skb, cb, &rdev, &wpan_dev);\n\tif (err)\n\t\treturn err;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR) {\n\t\terr = skb->len;\n\t\tgoto out_err;\n\t}\n\n\tif (!wpan_dev->netdev) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\trdev_lock_llsec_table(rdev, wpan_dev);\n\trdev_get_llsec_table(rdev, wpan_dev, &table);\n\n\t \n\tif (cb->args[2])\n\t\tgoto out;\n\n\t \n\tlist_for_each_entry(dpos, &table->devices, list) {\n\t\tlist_for_each_entry(kpos, &dpos->keys, list) {\n\t\t\tif (nl802154_send_devkey(skb,\n\t\t\t\t\t\t NL802154_CMD_NEW_SEC_LEVEL,\n\t\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t NLM_F_MULTI, rdev,\n\t\t\t\t\t\t wpan_dev->netdev,\n\t\t\t\t\t\t dpos->hwaddr,\n\t\t\t\t\t\t kpos) < 0) {\n\t\t\t\t \n\t\t\t\terr = -EIO;\n\t\t\t\trdev_unlock_llsec_table(rdev, wpan_dev);\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcb->args[2] = 1;\n\nout:\n\trdev_unlock_llsec_table(rdev, wpan_dev);\n\terr = skb->len;\nout_err:\n\tnl802154_finish_wpan_dev_dump(rdev);\n\n\treturn err;\n}\n\nstatic const struct nla_policy nl802154_devkey_policy[NL802154_DEVKEY_ATTR_MAX + 1] = {\n\t[NL802154_DEVKEY_ATTR_FRAME_COUNTER] = { NLA_U32 },\n\t[NL802154_DEVKEY_ATTR_EXTENDED_ADDR] = { NLA_U64 },\n\t[NL802154_DEVKEY_ATTR_ID] = { NLA_NESTED },\n};\n\nstatic int nl802154_add_llsec_devkey(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct nlattr *attrs[NL802154_DEVKEY_ATTR_MAX + 1];\n\tstruct ieee802154_llsec_device_key key;\n\t__le64 extended_addr;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL802154_ATTR_SEC_DEVKEY] ||\n\t    nla_parse_nested_deprecated(attrs, NL802154_DEVKEY_ATTR_MAX, info->attrs[NL802154_ATTR_SEC_DEVKEY], nl802154_devkey_policy, info->extack) < 0)\n\t\treturn -EINVAL;\n\n\tif (!attrs[NL802154_DEVKEY_ATTR_FRAME_COUNTER] ||\n\t    !attrs[NL802154_DEVKEY_ATTR_EXTENDED_ADDR])\n\t\treturn -EINVAL;\n\n\t \n\tif (ieee802154_llsec_parse_key_id(attrs[NL802154_DEVKEY_ATTR_ID],\n\t\t\t\t\t  &key.key_id) < 0)\n\t\treturn -ENOBUFS;\n\n\t \n\tkey.frame_counter = nla_get_u32(attrs[NL802154_DEVKEY_ATTR_FRAME_COUNTER]);\n\t \n\textended_addr = nla_get_le64(attrs[NL802154_DEVKEY_ATTR_EXTENDED_ADDR]);\n\treturn rdev_add_devkey(rdev, wpan_dev, extended_addr, &key);\n}\n\nstatic int nl802154_del_llsec_devkey(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct nlattr *attrs[NL802154_DEVKEY_ATTR_MAX + 1];\n\tstruct ieee802154_llsec_device_key key;\n\t__le64 extended_addr;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL802154_ATTR_SEC_DEVKEY] ||\n\t    nla_parse_nested_deprecated(attrs, NL802154_DEVKEY_ATTR_MAX, info->attrs[NL802154_ATTR_SEC_DEVKEY], nl802154_devkey_policy, info->extack))\n\t\treturn -EINVAL;\n\n\tif (!attrs[NL802154_DEVKEY_ATTR_EXTENDED_ADDR])\n\t\treturn -EINVAL;\n\n\t \n\tif (ieee802154_llsec_parse_key_id(attrs[NL802154_DEVKEY_ATTR_ID],\n\t\t\t\t\t  &key.key_id) < 0)\n\t\treturn -ENOBUFS;\n\n\t \n\textended_addr = nla_get_le64(attrs[NL802154_DEVKEY_ATTR_EXTENDED_ADDR]);\n\treturn rdev_del_devkey(rdev, wpan_dev, extended_addr, &key);\n}\n\nstatic int nl802154_send_seclevel(struct sk_buff *msg, u32 cmd, u32 portid,\n\t\t\t\t  u32 seq, int flags,\n\t\t\t\t  struct cfg802154_registered_device *rdev,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  const struct ieee802154_llsec_seclevel *sl)\n{\n\tvoid *hdr;\n\tstruct nlattr *nl_seclevel;\n\n\thdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL802154_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tnl_seclevel = nla_nest_start_noflag(msg, NL802154_ATTR_SEC_LEVEL);\n\tif (!nl_seclevel)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL802154_SECLEVEL_ATTR_FRAME, sl->frame_type) ||\n\t    nla_put_u32(msg, NL802154_SECLEVEL_ATTR_LEVELS, sl->sec_levels) ||\n\t    nla_put_u8(msg, NL802154_SECLEVEL_ATTR_DEV_OVERRIDE,\n\t\t       sl->device_override))\n\t\tgoto nla_put_failure;\n\n\tif (sl->frame_type == NL802154_FRAME_CMD) {\n\t\tif (nla_put_u32(msg, NL802154_SECLEVEL_ATTR_CMD_FRAME,\n\t\t\t\tsl->cmd_frame_id))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnla_nest_end(msg, nl_seclevel);\n\tgenlmsg_end(msg, hdr);\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl802154_dump_llsec_seclevel(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct cfg802154_registered_device *rdev = NULL;\n\tstruct ieee802154_llsec_seclevel *sl;\n\tstruct ieee802154_llsec_table *table;\n\tstruct wpan_dev *wpan_dev;\n\tint err;\n\n\terr = nl802154_prepare_wpan_dev_dump(skb, cb, &rdev, &wpan_dev);\n\tif (err)\n\t\treturn err;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR) {\n\t\terr = skb->len;\n\t\tgoto out_err;\n\t}\n\n\tif (!wpan_dev->netdev) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\trdev_lock_llsec_table(rdev, wpan_dev);\n\trdev_get_llsec_table(rdev, wpan_dev, &table);\n\n\t \n\tif (cb->args[2])\n\t\tgoto out;\n\n\tlist_for_each_entry(sl, &table->security_levels, list) {\n\t\tif (nl802154_send_seclevel(skb, NL802154_CMD_NEW_SEC_LEVEL,\n\t\t\t\t\t   NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   rdev, wpan_dev->netdev, sl) < 0) {\n\t\t\t \n\t\t\terr = -EIO;\n\t\t\trdev_unlock_llsec_table(rdev, wpan_dev);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tcb->args[2] = 1;\n\nout:\n\trdev_unlock_llsec_table(rdev, wpan_dev);\n\terr = skb->len;\nout_err:\n\tnl802154_finish_wpan_dev_dump(rdev);\n\n\treturn err;\n}\n\nstatic const struct nla_policy nl802154_seclevel_policy[NL802154_SECLEVEL_ATTR_MAX + 1] = {\n\t[NL802154_SECLEVEL_ATTR_LEVELS] = { .type = NLA_U8 },\n\t[NL802154_SECLEVEL_ATTR_FRAME] = { .type = NLA_U32 },\n\t[NL802154_SECLEVEL_ATTR_CMD_FRAME] = { .type = NLA_U32 },\n\t[NL802154_SECLEVEL_ATTR_DEV_OVERRIDE] = { .type = NLA_U8 },\n};\n\nstatic int\nllsec_parse_seclevel(struct nlattr *nla, struct ieee802154_llsec_seclevel *sl)\n{\n\tstruct nlattr *attrs[NL802154_SECLEVEL_ATTR_MAX + 1];\n\n\tif (!nla || nla_parse_nested_deprecated(attrs, NL802154_SECLEVEL_ATTR_MAX, nla, nl802154_seclevel_policy, NULL))\n\t\treturn -EINVAL;\n\n\tmemset(sl, 0, sizeof(*sl));\n\n\tif (!attrs[NL802154_SECLEVEL_ATTR_LEVELS] ||\n\t    !attrs[NL802154_SECLEVEL_ATTR_FRAME] ||\n\t    !attrs[NL802154_SECLEVEL_ATTR_DEV_OVERRIDE])\n\t\treturn -EINVAL;\n\n\tsl->sec_levels = nla_get_u8(attrs[NL802154_SECLEVEL_ATTR_LEVELS]);\n\tsl->frame_type = nla_get_u32(attrs[NL802154_SECLEVEL_ATTR_FRAME]);\n\tsl->device_override = nla_get_u8(attrs[NL802154_SECLEVEL_ATTR_DEV_OVERRIDE]);\n\tif (sl->frame_type > NL802154_FRAME_MAX ||\n\t    (sl->device_override != 0 && sl->device_override != 1))\n\t\treturn -EINVAL;\n\n\tif (sl->frame_type == NL802154_FRAME_CMD) {\n\t\tif (!attrs[NL802154_SECLEVEL_ATTR_CMD_FRAME])\n\t\t\treturn -EINVAL;\n\n\t\tsl->cmd_frame_id = nla_get_u32(attrs[NL802154_SECLEVEL_ATTR_CMD_FRAME]);\n\t\tif (sl->cmd_frame_id > NL802154_CMD_FRAME_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl802154_add_llsec_seclevel(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct ieee802154_llsec_seclevel sl;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n\tif (llsec_parse_seclevel(info->attrs[NL802154_ATTR_SEC_LEVEL],\n\t\t\t\t &sl) < 0)\n\t\treturn -EINVAL;\n\n\treturn rdev_add_seclevel(rdev, wpan_dev, &sl);\n}\n\nstatic int nl802154_del_llsec_seclevel(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\tstruct ieee802154_llsec_seclevel sl;\n\n\tif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n\tif (llsec_parse_seclevel(info->attrs[NL802154_ATTR_SEC_LEVEL],\n\t\t\t\t &sl) < 0)\n\t\treturn -EINVAL;\n\n\treturn rdev_del_seclevel(rdev, wpan_dev, &sl);\n}\n#endif  \n\n#define NL802154_FLAG_NEED_WPAN_PHY\t0x01\n#define NL802154_FLAG_NEED_NETDEV\t0x02\n#define NL802154_FLAG_NEED_RTNL\t\t0x04\n#define NL802154_FLAG_CHECK_NETDEV_UP\t0x08\n#define NL802154_FLAG_NEED_WPAN_DEV\t0x10\n\nstatic int nl802154_pre_doit(const struct genl_split_ops *ops,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct genl_info *info)\n{\n\tstruct cfg802154_registered_device *rdev;\n\tstruct wpan_dev *wpan_dev;\n\tstruct net_device *dev;\n\tbool rtnl = ops->internal_flags & NL802154_FLAG_NEED_RTNL;\n\n\tif (rtnl)\n\t\trtnl_lock();\n\n\tif (ops->internal_flags & NL802154_FLAG_NEED_WPAN_PHY) {\n\t\trdev = cfg802154_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\tinfo->user_ptr[0] = rdev;\n\t} else if (ops->internal_flags & NL802154_FLAG_NEED_NETDEV ||\n\t\t   ops->internal_flags & NL802154_FLAG_NEED_WPAN_DEV) {\n\t\tASSERT_RTNL();\n\t\twpan_dev = __cfg802154_wpan_dev_from_attrs(genl_info_net(info),\n\t\t\t\t\t\t\t   info->attrs);\n\t\tif (IS_ERR(wpan_dev)) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(wpan_dev);\n\t\t}\n\n\t\tdev = wpan_dev->netdev;\n\t\trdev = wpan_phy_to_rdev(wpan_dev->wpan_phy);\n\n\t\tif (ops->internal_flags & NL802154_FLAG_NEED_NETDEV) {\n\t\t\tif (!dev) {\n\t\t\t\tif (rtnl)\n\t\t\t\t\trtnl_unlock();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinfo->user_ptr[1] = dev;\n\t\t} else {\n\t\t\tinfo->user_ptr[1] = wpan_dev;\n\t\t}\n\n\t\tif (dev) {\n\t\t\tif (ops->internal_flags & NL802154_FLAG_CHECK_NETDEV_UP &&\n\t\t\t    !netif_running(dev)) {\n\t\t\t\tif (rtnl)\n\t\t\t\t\trtnl_unlock();\n\t\t\t\treturn -ENETDOWN;\n\t\t\t}\n\n\t\t\tdev_hold(dev);\n\t\t}\n\n\t\tinfo->user_ptr[0] = rdev;\n\t}\n\n\treturn 0;\n}\n\nstatic void nl802154_post_doit(const struct genl_split_ops *ops,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tif (info->user_ptr[1]) {\n\t\tif (ops->internal_flags & NL802154_FLAG_NEED_WPAN_DEV) {\n\t\t\tstruct wpan_dev *wpan_dev = info->user_ptr[1];\n\n\t\t\tdev_put(wpan_dev->netdev);\n\t\t} else {\n\t\t\tdev_put(info->user_ptr[1]);\n\t\t}\n\t}\n\n\tif (ops->internal_flags & NL802154_FLAG_NEED_RTNL)\n\t\trtnl_unlock();\n}\n\nstatic const struct genl_ops nl802154_ops[] = {\n\t{\n\t\t.cmd = NL802154_CMD_GET_WPAN_PHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT |\n\t\t\t    GENL_DONT_VALIDATE_DUMP_STRICT,\n\t\t.doit = nl802154_get_wpan_phy,\n\t\t.dumpit = nl802154_dump_wpan_phy,\n\t\t.done = nl802154_dump_wpan_phy_done,\n\t\t \n\t\t.internal_flags = NL802154_FLAG_NEED_WPAN_PHY |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_GET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_get_interface,\n\t\t.dumpit = nl802154_dump_interface,\n\t\t \n\t\t.internal_flags = NL802154_FLAG_NEED_WPAN_DEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_NEW_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_new_interface,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_WPAN_PHY |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_DEL_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_del_interface,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_WPAN_DEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_channel,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_WPAN_PHY |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_CCA_MODE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_cca_mode,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_WPAN_PHY |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_CCA_ED_LEVEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_cca_ed_level,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_WPAN_PHY |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_TX_POWER,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_tx_power,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_WPAN_PHY |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_WPAN_PHY_NETNS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_wpan_phy_netns,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_WPAN_PHY |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_PAN_ID,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_pan_id,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_SHORT_ADDR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_short_addr,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_BACKOFF_EXPONENT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_backoff_exponent,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_MAX_CSMA_BACKOFFS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_max_csma_backoffs,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_MAX_FRAME_RETRIES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_max_frame_retries,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_LBT_MODE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_lbt_mode,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SET_ACKREQ_DEFAULT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_ackreq_default,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_TRIGGER_SCAN,\n\t\t.doit = nl802154_trigger_scan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_CHECK_NETDEV_UP |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_ABORT_SCAN,\n\t\t.doit = nl802154_abort_scan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_CHECK_NETDEV_UP |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_SEND_BEACONS,\n\t\t.doit = nl802154_send_beacons,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_CHECK_NETDEV_UP |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_STOP_BEACONS,\n\t\t.doit = nl802154_stop_beacons,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_CHECK_NETDEV_UP |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n#ifdef CONFIG_IEEE802154_NL802154_EXPERIMENTAL\n\t{\n\t\t.cmd = NL802154_CMD_SET_SEC_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_set_llsec_params,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_GET_SEC_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT |\n\t\t\t    GENL_DONT_VALIDATE_DUMP_STRICT,\n\t\t \n\t\t.dumpit = nl802154_dump_llsec_key,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_NEW_SEC_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_add_llsec_key,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_DEL_SEC_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_del_llsec_key,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t \n\t{\n\t\t.cmd = NL802154_CMD_GET_SEC_DEV,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT |\n\t\t\t    GENL_DONT_VALIDATE_DUMP_STRICT,\n\t\t \n\t\t.dumpit = nl802154_dump_llsec_dev,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_NEW_SEC_DEV,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_add_llsec_dev,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_DEL_SEC_DEV,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_del_llsec_dev,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t \n\t{\n\t\t.cmd = NL802154_CMD_GET_SEC_DEVKEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT |\n\t\t\t    GENL_DONT_VALIDATE_DUMP_STRICT,\n\t\t \n\t\t.dumpit = nl802154_dump_llsec_devkey,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_NEW_SEC_DEVKEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_add_llsec_devkey,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_DEL_SEC_DEVKEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_del_llsec_devkey,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_GET_SEC_LEVEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT |\n\t\t\t    GENL_DONT_VALIDATE_DUMP_STRICT,\n\t\t \n\t\t.dumpit = nl802154_dump_llsec_seclevel,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_NEW_SEC_LEVEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl802154_add_llsec_seclevel,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL802154_CMD_DEL_SEC_LEVEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t \n\t\t.doit = nl802154_del_llsec_seclevel,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL802154_FLAG_NEED_NETDEV |\n\t\t\t\t  NL802154_FLAG_NEED_RTNL,\n\t},\n#endif  \n};\n\nstatic struct genl_family nl802154_fam __ro_after_init = {\n\t.name = NL802154_GENL_NAME,\t \n\t.hdrsize = 0,\t\t\t \n\t.version = 1,\t\t\t \n\t.maxattr = NL802154_ATTR_MAX,\n\t.policy = nl802154_policy,\n\t.netnsok = true,\n\t.pre_doit = nl802154_pre_doit,\n\t.post_doit = nl802154_post_doit,\n\t.module = THIS_MODULE,\n\t.ops = nl802154_ops,\n\t.n_ops = ARRAY_SIZE(nl802154_ops),\n\t.resv_start_op = NL802154_CMD_DEL_SEC_LEVEL + 1,\n\t.mcgrps = nl802154_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(nl802154_mcgrps),\n};\n\n \nint __init nl802154_init(void)\n{\n\treturn genl_register_family(&nl802154_fam);\n}\n\nvoid nl802154_exit(void)\n{\n\tgenl_unregister_family(&nl802154_fam);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}