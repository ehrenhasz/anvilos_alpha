{
  "module_name": "flow.c",
  "hash_id": "e13a88a2d469e7a4a0713ed95b205908a8731f1b85732a4f6b288a4622a095e4",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/flow.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <net/llc_pdu.h>\n#include <linux/kernel.h>\n#include <linux/jhash.h>\n#include <linux/jiffies.h>\n#include <linux/llc.h>\n#include <linux/module.h>\n#include <linux/in.h>\n#include <linux/rcupdate.h>\n#include <linux/cpumask.h>\n#include <linux/if_arp.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/mpls.h>\n#include <linux/sctp.h>\n#include <linux/smp.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/rculist.h>\n#include <net/ip.h>\n#include <net/ip_tunnels.h>\n#include <net/ipv6.h>\n#include <net/mpls.h>\n#include <net/ndisc.h>\n#include <net/nsh.h>\n#include <net/pkt_cls.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n\n#include \"conntrack.h\"\n#include \"datapath.h\"\n#include \"flow.h\"\n#include \"flow_netlink.h\"\n#include \"vport.h\"\n\nu64 ovs_flow_used_time(unsigned long flow_jiffies)\n{\n\tstruct timespec64 cur_ts;\n\tu64 cur_ms, idle_ms;\n\n\tktime_get_ts64(&cur_ts);\n\tidle_ms = jiffies_to_msecs(jiffies - flow_jiffies);\n\tcur_ms = (u64)(u32)cur_ts.tv_sec * MSEC_PER_SEC +\n\t\t cur_ts.tv_nsec / NSEC_PER_MSEC;\n\n\treturn cur_ms - idle_ms;\n}\n\n#define TCP_FLAGS_BE16(tp) (*(__be16 *)&tcp_flag_word(tp) & htons(0x0FFF))\n\nvoid ovs_flow_stats_update(struct sw_flow *flow, __be16 tcp_flags,\n\t\t\t   const struct sk_buff *skb)\n{\n\tstruct sw_flow_stats *stats;\n\tunsigned int cpu = smp_processor_id();\n\tint len = skb->len + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);\n\n\tstats = rcu_dereference(flow->stats[cpu]);\n\n\t \n\tif (likely(stats)) {\n\t\tspin_lock(&stats->lock);\n\t\t \n\t\tif (cpu == 0 && unlikely(flow->stats_last_writer != cpu))\n\t\t\tflow->stats_last_writer = cpu;\n\t} else {\n\t\tstats = rcu_dereference(flow->stats[0]);  \n\t\tspin_lock(&stats->lock);\n\n\t\t \n\t\tif (unlikely(flow->stats_last_writer != cpu)) {\n\t\t\t \n\t\t\tif (likely(flow->stats_last_writer != -1) &&\n\t\t\t    likely(!rcu_access_pointer(flow->stats[cpu]))) {\n\t\t\t\t \n\t\t\t\tstruct sw_flow_stats *new_stats;\n\n\t\t\t\tnew_stats =\n\t\t\t\t\tkmem_cache_alloc_node(flow_stats_cache,\n\t\t\t\t\t\t\t      GFP_NOWAIT |\n\t\t\t\t\t\t\t      __GFP_THISNODE |\n\t\t\t\t\t\t\t      __GFP_NOWARN |\n\t\t\t\t\t\t\t      __GFP_NOMEMALLOC,\n\t\t\t\t\t\t\t      numa_node_id());\n\t\t\t\tif (likely(new_stats)) {\n\t\t\t\t\tnew_stats->used = jiffies;\n\t\t\t\t\tnew_stats->packet_count = 1;\n\t\t\t\t\tnew_stats->byte_count = len;\n\t\t\t\t\tnew_stats->tcp_flags = tcp_flags;\n\t\t\t\t\tspin_lock_init(&new_stats->lock);\n\n\t\t\t\t\trcu_assign_pointer(flow->stats[cpu],\n\t\t\t\t\t\t\t   new_stats);\n\t\t\t\t\tcpumask_set_cpu(cpu,\n\t\t\t\t\t\t\tflow->cpu_used_mask);\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t\tflow->stats_last_writer = cpu;\n\t\t}\n\t}\n\n\tstats->used = jiffies;\n\tstats->packet_count++;\n\tstats->byte_count += len;\n\tstats->tcp_flags |= tcp_flags;\nunlock:\n\tspin_unlock(&stats->lock);\n}\n\n \nvoid ovs_flow_stats_get(const struct sw_flow *flow,\n\t\t\tstruct ovs_flow_stats *ovs_stats,\n\t\t\tunsigned long *used, __be16 *tcp_flags)\n{\n\tint cpu;\n\n\t*used = 0;\n\t*tcp_flags = 0;\n\tmemset(ovs_stats, 0, sizeof(*ovs_stats));\n\n\t \n\tfor (cpu = 0; cpu < nr_cpu_ids;\n\t     cpu = cpumask_next(cpu, flow->cpu_used_mask)) {\n\t\tstruct sw_flow_stats *stats = rcu_dereference_ovsl(flow->stats[cpu]);\n\n\t\tif (stats) {\n\t\t\t \n\t\t\tspin_lock_bh(&stats->lock);\n\t\t\tif (!*used || time_after(stats->used, *used))\n\t\t\t\t*used = stats->used;\n\t\t\t*tcp_flags |= stats->tcp_flags;\n\t\t\tovs_stats->n_packets += stats->packet_count;\n\t\t\tovs_stats->n_bytes += stats->byte_count;\n\t\t\tspin_unlock_bh(&stats->lock);\n\t\t}\n\t}\n}\n\n \nvoid ovs_flow_stats_clear(struct sw_flow *flow)\n{\n\tint cpu;\n\n\t \n\tfor (cpu = 0; cpu < nr_cpu_ids;\n\t     cpu = cpumask_next(cpu, flow->cpu_used_mask)) {\n\t\tstruct sw_flow_stats *stats = ovsl_dereference(flow->stats[cpu]);\n\n\t\tif (stats) {\n\t\t\tspin_lock_bh(&stats->lock);\n\t\t\tstats->used = 0;\n\t\t\tstats->packet_count = 0;\n\t\t\tstats->byte_count = 0;\n\t\t\tstats->tcp_flags = 0;\n\t\t\tspin_unlock_bh(&stats->lock);\n\t\t}\n\t}\n}\n\nstatic int check_header(struct sk_buff *skb, int len)\n{\n\tif (unlikely(skb->len < len))\n\t\treturn -EINVAL;\n\tif (unlikely(!pskb_may_pull(skb, len)))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic bool arphdr_ok(struct sk_buff *skb)\n{\n\treturn pskb_may_pull(skb, skb_network_offset(skb) +\n\t\t\t\t  sizeof(struct arp_eth_header));\n}\n\nstatic int check_iphdr(struct sk_buff *skb)\n{\n\tunsigned int nh_ofs = skb_network_offset(skb);\n\tunsigned int ip_len;\n\tint err;\n\n\terr = check_header(skb, nh_ofs + sizeof(struct iphdr));\n\tif (unlikely(err))\n\t\treturn err;\n\n\tip_len = ip_hdrlen(skb);\n\tif (unlikely(ip_len < sizeof(struct iphdr) ||\n\t\t     skb->len < nh_ofs + ip_len))\n\t\treturn -EINVAL;\n\n\tskb_set_transport_header(skb, nh_ofs + ip_len);\n\treturn 0;\n}\n\nstatic bool tcphdr_ok(struct sk_buff *skb)\n{\n\tint th_ofs = skb_transport_offset(skb);\n\tint tcp_len;\n\n\tif (unlikely(!pskb_may_pull(skb, th_ofs + sizeof(struct tcphdr))))\n\t\treturn false;\n\n\ttcp_len = tcp_hdrlen(skb);\n\tif (unlikely(tcp_len < sizeof(struct tcphdr) ||\n\t\t     skb->len < th_ofs + tcp_len))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool udphdr_ok(struct sk_buff *skb)\n{\n\treturn pskb_may_pull(skb, skb_transport_offset(skb) +\n\t\t\t\t  sizeof(struct udphdr));\n}\n\nstatic bool sctphdr_ok(struct sk_buff *skb)\n{\n\treturn pskb_may_pull(skb, skb_transport_offset(skb) +\n\t\t\t\t  sizeof(struct sctphdr));\n}\n\nstatic bool icmphdr_ok(struct sk_buff *skb)\n{\n\treturn pskb_may_pull(skb, skb_transport_offset(skb) +\n\t\t\t\t  sizeof(struct icmphdr));\n}\n\n \nstatic void get_ipv6_ext_hdrs(struct sk_buff *skb, struct ipv6hdr *nh,\n\t\t\t      u16 *ext_hdrs)\n{\n\tu8 next_type = nh->nexthdr;\n\tunsigned int start = skb_network_offset(skb) + sizeof(struct ipv6hdr);\n\tint dest_options_header_count = 0;\n\n\t*ext_hdrs = 0;\n\n\twhile (ipv6_ext_hdr(next_type)) {\n\t\tstruct ipv6_opt_hdr _hdr, *hp;\n\n\t\tswitch (next_type) {\n\t\tcase IPPROTO_NONE:\n\t\t\t*ext_hdrs |= OFPIEH12_NONEXT;\n\t\t\t \n\t\t\treturn;\n\n\t\tcase IPPROTO_ESP:\n\t\t\tif (*ext_hdrs & OFPIEH12_ESP)\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNREP;\n\t\t\tif ((*ext_hdrs & ~(OFPIEH12_HOP | OFPIEH12_DEST |\n\t\t\t\t\t   OFPIEH12_ROUTER | IPPROTO_FRAGMENT |\n\t\t\t\t\t   OFPIEH12_AUTH | OFPIEH12_UNREP)) ||\n\t\t\t    dest_options_header_count >= 2) {\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNSEQ;\n\t\t\t}\n\t\t\t*ext_hdrs |= OFPIEH12_ESP;\n\t\t\tbreak;\n\n\t\tcase IPPROTO_AH:\n\t\t\tif (*ext_hdrs & OFPIEH12_AUTH)\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNREP;\n\t\t\tif ((*ext_hdrs &\n\t\t\t     ~(OFPIEH12_HOP | OFPIEH12_DEST | OFPIEH12_ROUTER |\n\t\t\t       IPPROTO_FRAGMENT | OFPIEH12_UNREP)) ||\n\t\t\t    dest_options_header_count >= 2) {\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNSEQ;\n\t\t\t}\n\t\t\t*ext_hdrs |= OFPIEH12_AUTH;\n\t\t\tbreak;\n\n\t\tcase IPPROTO_DSTOPTS:\n\t\t\tif (dest_options_header_count == 0) {\n\t\t\t\tif (*ext_hdrs &\n\t\t\t\t    ~(OFPIEH12_HOP | OFPIEH12_UNREP))\n\t\t\t\t\t*ext_hdrs |= OFPIEH12_UNSEQ;\n\t\t\t\t*ext_hdrs |= OFPIEH12_DEST;\n\t\t\t} else if (dest_options_header_count == 1) {\n\t\t\t\tif (*ext_hdrs &\n\t\t\t\t    ~(OFPIEH12_HOP | OFPIEH12_DEST |\n\t\t\t\t      OFPIEH12_ROUTER | OFPIEH12_FRAG |\n\t\t\t\t      OFPIEH12_AUTH | OFPIEH12_ESP |\n\t\t\t\t      OFPIEH12_UNREP)) {\n\t\t\t\t\t*ext_hdrs |= OFPIEH12_UNSEQ;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNREP;\n\t\t\t}\n\t\t\tdest_options_header_count++;\n\t\t\tbreak;\n\n\t\tcase IPPROTO_FRAGMENT:\n\t\t\tif (*ext_hdrs & OFPIEH12_FRAG)\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNREP;\n\t\t\tif ((*ext_hdrs & ~(OFPIEH12_HOP |\n\t\t\t\t\t   OFPIEH12_DEST |\n\t\t\t\t\t   OFPIEH12_ROUTER |\n\t\t\t\t\t   OFPIEH12_UNREP)) ||\n\t\t\t    dest_options_header_count >= 2) {\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNSEQ;\n\t\t\t}\n\t\t\t*ext_hdrs |= OFPIEH12_FRAG;\n\t\t\tbreak;\n\n\t\tcase IPPROTO_ROUTING:\n\t\t\tif (*ext_hdrs & OFPIEH12_ROUTER)\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNREP;\n\t\t\tif ((*ext_hdrs & ~(OFPIEH12_HOP |\n\t\t\t\t\t   OFPIEH12_DEST |\n\t\t\t\t\t   OFPIEH12_UNREP)) ||\n\t\t\t    dest_options_header_count >= 2) {\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNSEQ;\n\t\t\t}\n\t\t\t*ext_hdrs |= OFPIEH12_ROUTER;\n\t\t\tbreak;\n\n\t\tcase IPPROTO_HOPOPTS:\n\t\t\tif (*ext_hdrs & OFPIEH12_HOP)\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNREP;\n\t\t\t \n\t\t\tif (*ext_hdrs == 0)\n\t\t\t\t*ext_hdrs |= OFPIEH12_HOP;\n\t\t\telse\n\t\t\t\t*ext_hdrs |= OFPIEH12_UNSEQ;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\n\t\thp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\n\t\tif (!hp)\n\t\t\tbreak;\n\t\tnext_type = hp->nexthdr;\n\t\tstart += ipv6_optlen(hp);\n\t}\n}\n\nstatic int parse_ipv6hdr(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tunsigned short frag_off;\n\tunsigned int payload_ofs = 0;\n\tunsigned int nh_ofs = skb_network_offset(skb);\n\tunsigned int nh_len;\n\tstruct ipv6hdr *nh;\n\tint err, nexthdr, flags = 0;\n\n\terr = check_header(skb, nh_ofs + sizeof(*nh));\n\tif (unlikely(err))\n\t\treturn err;\n\n\tnh = ipv6_hdr(skb);\n\n\tget_ipv6_ext_hdrs(skb, nh, &key->ipv6.exthdrs);\n\n\tkey->ip.proto = NEXTHDR_NONE;\n\tkey->ip.tos = ipv6_get_dsfield(nh);\n\tkey->ip.ttl = nh->hop_limit;\n\tkey->ipv6.label = *(__be32 *)nh & htonl(IPV6_FLOWINFO_FLOWLABEL);\n\tkey->ipv6.addr.src = nh->saddr;\n\tkey->ipv6.addr.dst = nh->daddr;\n\n\tnexthdr = ipv6_find_hdr(skb, &payload_ofs, -1, &frag_off, &flags);\n\tif (flags & IP6_FH_F_FRAG) {\n\t\tif (frag_off) {\n\t\t\tkey->ip.frag = OVS_FRAG_TYPE_LATER;\n\t\t\tkey->ip.proto = NEXTHDR_FRAGMENT;\n\t\t\treturn 0;\n\t\t}\n\t\tkey->ip.frag = OVS_FRAG_TYPE_FIRST;\n\t} else {\n\t\tkey->ip.frag = OVS_FRAG_TYPE_NONE;\n\t}\n\n\t \n\tif (unlikely(nexthdr < 0))\n\t\treturn -EPROTO;\n\n\tnh_len = payload_ofs - nh_ofs;\n\tskb_set_transport_header(skb, nh_ofs + nh_len);\n\tkey->ip.proto = nexthdr;\n\treturn nh_len;\n}\n\nstatic bool icmp6hdr_ok(struct sk_buff *skb)\n{\n\treturn pskb_may_pull(skb, skb_transport_offset(skb) +\n\t\t\t\t  sizeof(struct icmp6hdr));\n}\n\n \nstatic int parse_vlan_tag(struct sk_buff *skb, struct vlan_head *key_vh,\n\t\t\t  bool untag_vlan)\n{\n\tstruct vlan_head *vh = (struct vlan_head *)skb->data;\n\n\tif (likely(!eth_type_vlan(vh->tpid)))\n\t\treturn 0;\n\n\tif (unlikely(skb->len < sizeof(struct vlan_head) + sizeof(__be16)))\n\t\treturn 0;\n\n\tif (unlikely(!pskb_may_pull(skb, sizeof(struct vlan_head) +\n\t\t\t\t sizeof(__be16))))\n\t\treturn -ENOMEM;\n\n\tvh = (struct vlan_head *)skb->data;\n\tkey_vh->tci = vh->tci | htons(VLAN_CFI_MASK);\n\tkey_vh->tpid = vh->tpid;\n\n\tif (unlikely(untag_vlan)) {\n\t\tint offset = skb->data - skb_mac_header(skb);\n\t\tu16 tci;\n\t\tint err;\n\n\t\t__skb_push(skb, offset);\n\t\terr = __skb_vlan_pop(skb, &tci);\n\t\t__skb_pull(skb, offset);\n\t\tif (err)\n\t\t\treturn err;\n\t\t__vlan_hwaccel_put_tag(skb, key_vh->tpid, tci);\n\t} else {\n\t\t__skb_pull(skb, sizeof(struct vlan_head));\n\t}\n\treturn 1;\n}\n\nstatic void clear_vlan(struct sw_flow_key *key)\n{\n\tkey->eth.vlan.tci = 0;\n\tkey->eth.vlan.tpid = 0;\n\tkey->eth.cvlan.tci = 0;\n\tkey->eth.cvlan.tpid = 0;\n}\n\nstatic int parse_vlan(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tint res;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tkey->eth.vlan.tci = htons(skb->vlan_tci) | htons(VLAN_CFI_MASK);\n\t\tkey->eth.vlan.tpid = skb->vlan_proto;\n\t} else {\n\t\t \n\t\tres = parse_vlan_tag(skb, &key->eth.vlan, true);\n\t\tif (res <= 0)\n\t\t\treturn res;\n\t}\n\n\t \n\tres = parse_vlan_tag(skb, &key->eth.cvlan, false);\n\tif (res <= 0)\n\t\treturn res;\n\n\treturn 0;\n}\n\nstatic __be16 parse_ethertype(struct sk_buff *skb)\n{\n\tstruct llc_snap_hdr {\n\t\tu8  dsap;   \n\t\tu8  ssap;   \n\t\tu8  ctrl;\n\t\tu8  oui[3];\n\t\t__be16 ethertype;\n\t};\n\tstruct llc_snap_hdr *llc;\n\t__be16 proto;\n\n\tproto = *(__be16 *) skb->data;\n\t__skb_pull(skb, sizeof(__be16));\n\n\tif (eth_proto_is_802_3(proto))\n\t\treturn proto;\n\n\tif (skb->len < sizeof(struct llc_snap_hdr))\n\t\treturn htons(ETH_P_802_2);\n\n\tif (unlikely(!pskb_may_pull(skb, sizeof(struct llc_snap_hdr))))\n\t\treturn htons(0);\n\n\tllc = (struct llc_snap_hdr *) skb->data;\n\tif (llc->dsap != LLC_SAP_SNAP ||\n\t    llc->ssap != LLC_SAP_SNAP ||\n\t    (llc->oui[0] | llc->oui[1] | llc->oui[2]) != 0)\n\t\treturn htons(ETH_P_802_2);\n\n\t__skb_pull(skb, sizeof(struct llc_snap_hdr));\n\n\tif (eth_proto_is_802_3(llc->ethertype))\n\t\treturn llc->ethertype;\n\n\treturn htons(ETH_P_802_2);\n}\n\nstatic int parse_icmpv6(struct sk_buff *skb, struct sw_flow_key *key,\n\t\t\tint nh_len)\n{\n\tstruct icmp6hdr *icmp = icmp6_hdr(skb);\n\n\t \n\tkey->tp.src = htons(icmp->icmp6_type);\n\tkey->tp.dst = htons(icmp->icmp6_code);\n\tmemset(&key->ipv6.nd, 0, sizeof(key->ipv6.nd));\n\n\tif (icmp->icmp6_code == 0 &&\n\t    (icmp->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION ||\n\t     icmp->icmp6_type == NDISC_NEIGHBOUR_ADVERTISEMENT)) {\n\t\tint icmp_len = skb->len - skb_transport_offset(skb);\n\t\tstruct nd_msg *nd;\n\t\tint offset;\n\n\t\t \n\t\tif (unlikely(icmp_len < sizeof(*nd)))\n\t\t\treturn 0;\n\n\t\tif (unlikely(skb_linearize(skb)))\n\t\t\treturn -ENOMEM;\n\n\t\tnd = (struct nd_msg *)skb_transport_header(skb);\n\t\tkey->ipv6.nd.target = nd->target;\n\n\t\ticmp_len -= sizeof(*nd);\n\t\toffset = 0;\n\t\twhile (icmp_len >= 8) {\n\t\t\tstruct nd_opt_hdr *nd_opt =\n\t\t\t\t (struct nd_opt_hdr *)(nd->opt + offset);\n\t\t\tint opt_len = nd_opt->nd_opt_len * 8;\n\n\t\t\tif (unlikely(!opt_len || opt_len > icmp_len))\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tif (nd_opt->nd_opt_type == ND_OPT_SOURCE_LL_ADDR\n\t\t\t    && opt_len == 8) {\n\t\t\t\tif (unlikely(!is_zero_ether_addr(key->ipv6.nd.sll)))\n\t\t\t\t\tgoto invalid;\n\t\t\t\tether_addr_copy(key->ipv6.nd.sll,\n\t\t\t\t\t\t&nd->opt[offset+sizeof(*nd_opt)]);\n\t\t\t} else if (nd_opt->nd_opt_type == ND_OPT_TARGET_LL_ADDR\n\t\t\t\t   && opt_len == 8) {\n\t\t\t\tif (unlikely(!is_zero_ether_addr(key->ipv6.nd.tll)))\n\t\t\t\t\tgoto invalid;\n\t\t\t\tether_addr_copy(key->ipv6.nd.tll,\n\t\t\t\t\t\t&nd->opt[offset+sizeof(*nd_opt)]);\n\t\t\t}\n\n\t\t\ticmp_len -= opt_len;\n\t\t\toffset += opt_len;\n\t\t}\n\t}\n\n\treturn 0;\n\ninvalid:\n\tmemset(&key->ipv6.nd.target, 0, sizeof(key->ipv6.nd.target));\n\tmemset(key->ipv6.nd.sll, 0, sizeof(key->ipv6.nd.sll));\n\tmemset(key->ipv6.nd.tll, 0, sizeof(key->ipv6.nd.tll));\n\n\treturn 0;\n}\n\nstatic int parse_nsh(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tstruct nshhdr *nh;\n\tunsigned int nh_ofs = skb_network_offset(skb);\n\tu8 version, length;\n\tint err;\n\n\terr = check_header(skb, nh_ofs + NSH_BASE_HDR_LEN);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tnh = nsh_hdr(skb);\n\tversion = nsh_get_ver(nh);\n\tlength = nsh_hdr_len(nh);\n\n\tif (version != 0)\n\t\treturn -EINVAL;\n\n\terr = check_header(skb, nh_ofs + length);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tnh = nsh_hdr(skb);\n\tkey->nsh.base.flags = nsh_get_flags(nh);\n\tkey->nsh.base.ttl = nsh_get_ttl(nh);\n\tkey->nsh.base.mdtype = nh->mdtype;\n\tkey->nsh.base.np = nh->np;\n\tkey->nsh.base.path_hdr = nh->path_hdr;\n\tswitch (key->nsh.base.mdtype) {\n\tcase NSH_M_TYPE1:\n\t\tif (length != NSH_M_TYPE1_LEN)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(key->nsh.context, nh->md1.context,\n\t\t       sizeof(nh->md1));\n\t\tbreak;\n\tcase NSH_M_TYPE2:\n\t\tmemset(key->nsh.context, 0,\n\t\t       sizeof(nh->md1));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int key_extract_l3l4(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tint error;\n\n\t \n\tif (key->eth.type == htons(ETH_P_IP)) {\n\t\tstruct iphdr *nh;\n\t\t__be16 offset;\n\n\t\terror = check_iphdr(skb);\n\t\tif (unlikely(error)) {\n\t\t\tmemset(&key->ip, 0, sizeof(key->ip));\n\t\t\tmemset(&key->ipv4, 0, sizeof(key->ipv4));\n\t\t\tif (error == -EINVAL) {\n\t\t\t\tskb->transport_header = skb->network_header;\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t\treturn error;\n\t\t}\n\n\t\tnh = ip_hdr(skb);\n\t\tkey->ipv4.addr.src = nh->saddr;\n\t\tkey->ipv4.addr.dst = nh->daddr;\n\n\t\tkey->ip.proto = nh->protocol;\n\t\tkey->ip.tos = nh->tos;\n\t\tkey->ip.ttl = nh->ttl;\n\n\t\toffset = nh->frag_off & htons(IP_OFFSET);\n\t\tif (offset) {\n\t\t\tkey->ip.frag = OVS_FRAG_TYPE_LATER;\n\t\t\tmemset(&key->tp, 0, sizeof(key->tp));\n\t\t\treturn 0;\n\t\t}\n\t\tif (nh->frag_off & htons(IP_MF) ||\n\t\t\tskb_shinfo(skb)->gso_type & SKB_GSO_UDP)\n\t\t\tkey->ip.frag = OVS_FRAG_TYPE_FIRST;\n\t\telse\n\t\t\tkey->ip.frag = OVS_FRAG_TYPE_NONE;\n\n\t\t \n\t\tif (key->ip.proto == IPPROTO_TCP) {\n\t\t\tif (tcphdr_ok(skb)) {\n\t\t\t\tstruct tcphdr *tcp = tcp_hdr(skb);\n\t\t\t\tkey->tp.src = tcp->source;\n\t\t\t\tkey->tp.dst = tcp->dest;\n\t\t\t\tkey->tp.flags = TCP_FLAGS_BE16(tcp);\n\t\t\t} else {\n\t\t\t\tmemset(&key->tp, 0, sizeof(key->tp));\n\t\t\t}\n\n\t\t} else if (key->ip.proto == IPPROTO_UDP) {\n\t\t\tif (udphdr_ok(skb)) {\n\t\t\t\tstruct udphdr *udp = udp_hdr(skb);\n\t\t\t\tkey->tp.src = udp->source;\n\t\t\t\tkey->tp.dst = udp->dest;\n\t\t\t} else {\n\t\t\t\tmemset(&key->tp, 0, sizeof(key->tp));\n\t\t\t}\n\t\t} else if (key->ip.proto == IPPROTO_SCTP) {\n\t\t\tif (sctphdr_ok(skb)) {\n\t\t\t\tstruct sctphdr *sctp = sctp_hdr(skb);\n\t\t\t\tkey->tp.src = sctp->source;\n\t\t\t\tkey->tp.dst = sctp->dest;\n\t\t\t} else {\n\t\t\t\tmemset(&key->tp, 0, sizeof(key->tp));\n\t\t\t}\n\t\t} else if (key->ip.proto == IPPROTO_ICMP) {\n\t\t\tif (icmphdr_ok(skb)) {\n\t\t\t\tstruct icmphdr *icmp = icmp_hdr(skb);\n\t\t\t\t \n\t\t\t\tkey->tp.src = htons(icmp->type);\n\t\t\t\tkey->tp.dst = htons(icmp->code);\n\t\t\t} else {\n\t\t\t\tmemset(&key->tp, 0, sizeof(key->tp));\n\t\t\t}\n\t\t}\n\n\t} else if (key->eth.type == htons(ETH_P_ARP) ||\n\t\t   key->eth.type == htons(ETH_P_RARP)) {\n\t\tstruct arp_eth_header *arp;\n\t\tbool arp_available = arphdr_ok(skb);\n\n\t\tarp = (struct arp_eth_header *)skb_network_header(skb);\n\n\t\tif (arp_available &&\n\t\t    arp->ar_hrd == htons(ARPHRD_ETHER) &&\n\t\t    arp->ar_pro == htons(ETH_P_IP) &&\n\t\t    arp->ar_hln == ETH_ALEN &&\n\t\t    arp->ar_pln == 4) {\n\n\t\t\t \n\t\t\tif (ntohs(arp->ar_op) <= 0xff)\n\t\t\t\tkey->ip.proto = ntohs(arp->ar_op);\n\t\t\telse\n\t\t\t\tkey->ip.proto = 0;\n\n\t\t\tmemcpy(&key->ipv4.addr.src, arp->ar_sip, sizeof(key->ipv4.addr.src));\n\t\t\tmemcpy(&key->ipv4.addr.dst, arp->ar_tip, sizeof(key->ipv4.addr.dst));\n\t\t\tether_addr_copy(key->ipv4.arp.sha, arp->ar_sha);\n\t\t\tether_addr_copy(key->ipv4.arp.tha, arp->ar_tha);\n\t\t} else {\n\t\t\tmemset(&key->ip, 0, sizeof(key->ip));\n\t\t\tmemset(&key->ipv4, 0, sizeof(key->ipv4));\n\t\t}\n\t} else if (eth_p_mpls(key->eth.type)) {\n\t\tu8 label_count = 1;\n\n\t\tmemset(&key->mpls, 0, sizeof(key->mpls));\n\t\tskb_set_inner_network_header(skb, skb->mac_len);\n\t\twhile (1) {\n\t\t\t__be32 lse;\n\n\t\t\terror = check_header(skb, skb->mac_len +\n\t\t\t\t\t     label_count * MPLS_HLEN);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn 0;\n\n\t\t\tmemcpy(&lse, skb_inner_network_header(skb), MPLS_HLEN);\n\n\t\t\tif (label_count <= MPLS_LABEL_DEPTH)\n\t\t\t\tmemcpy(&key->mpls.lse[label_count - 1], &lse,\n\t\t\t\t       MPLS_HLEN);\n\n\t\t\tskb_set_inner_network_header(skb, skb->mac_len +\n\t\t\t\t\t\t     label_count * MPLS_HLEN);\n\t\t\tif (lse & htonl(MPLS_LS_S_MASK))\n\t\t\t\tbreak;\n\n\t\t\tlabel_count++;\n\t\t}\n\t\tif (label_count > MPLS_LABEL_DEPTH)\n\t\t\tlabel_count = MPLS_LABEL_DEPTH;\n\n\t\tkey->mpls.num_labels_mask = GENMASK(label_count - 1, 0);\n\t} else if (key->eth.type == htons(ETH_P_IPV6)) {\n\t\tint nh_len;              \n\n\t\tnh_len = parse_ipv6hdr(skb, key);\n\t\tif (unlikely(nh_len < 0)) {\n\t\t\tswitch (nh_len) {\n\t\t\tcase -EINVAL:\n\t\t\t\tmemset(&key->ip, 0, sizeof(key->ip));\n\t\t\t\tmemset(&key->ipv6.addr, 0, sizeof(key->ipv6.addr));\n\t\t\t\tfallthrough;\n\t\t\tcase -EPROTO:\n\t\t\t\tskb->transport_header = skb->network_header;\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = nh_len;\n\t\t\t}\n\t\t\treturn error;\n\t\t}\n\n\t\tif (key->ip.frag == OVS_FRAG_TYPE_LATER) {\n\t\t\tmemset(&key->tp, 0, sizeof(key->tp));\n\t\t\treturn 0;\n\t\t}\n\t\tif (skb_shinfo(skb)->gso_type & SKB_GSO_UDP)\n\t\t\tkey->ip.frag = OVS_FRAG_TYPE_FIRST;\n\n\t\t \n\t\tif (key->ip.proto == NEXTHDR_TCP) {\n\t\t\tif (tcphdr_ok(skb)) {\n\t\t\t\tstruct tcphdr *tcp = tcp_hdr(skb);\n\t\t\t\tkey->tp.src = tcp->source;\n\t\t\t\tkey->tp.dst = tcp->dest;\n\t\t\t\tkey->tp.flags = TCP_FLAGS_BE16(tcp);\n\t\t\t} else {\n\t\t\t\tmemset(&key->tp, 0, sizeof(key->tp));\n\t\t\t}\n\t\t} else if (key->ip.proto == NEXTHDR_UDP) {\n\t\t\tif (udphdr_ok(skb)) {\n\t\t\t\tstruct udphdr *udp = udp_hdr(skb);\n\t\t\t\tkey->tp.src = udp->source;\n\t\t\t\tkey->tp.dst = udp->dest;\n\t\t\t} else {\n\t\t\t\tmemset(&key->tp, 0, sizeof(key->tp));\n\t\t\t}\n\t\t} else if (key->ip.proto == NEXTHDR_SCTP) {\n\t\t\tif (sctphdr_ok(skb)) {\n\t\t\t\tstruct sctphdr *sctp = sctp_hdr(skb);\n\t\t\t\tkey->tp.src = sctp->source;\n\t\t\t\tkey->tp.dst = sctp->dest;\n\t\t\t} else {\n\t\t\t\tmemset(&key->tp, 0, sizeof(key->tp));\n\t\t\t}\n\t\t} else if (key->ip.proto == NEXTHDR_ICMP) {\n\t\t\tif (icmp6hdr_ok(skb)) {\n\t\t\t\terror = parse_icmpv6(skb, key, nh_len);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t} else {\n\t\t\t\tmemset(&key->tp, 0, sizeof(key->tp));\n\t\t\t}\n\t\t}\n\t} else if (key->eth.type == htons(ETH_P_NSH)) {\n\t\terror = parse_nsh(skb, key);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}\n\n \nstatic int key_extract(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tstruct ethhdr *eth;\n\n\t \n\tkey->tp.flags = 0;\n\n\tskb_reset_mac_header(skb);\n\n\t \n\tclear_vlan(key);\n\tif (ovs_key_mac_proto(key) == MAC_PROTO_NONE) {\n\t\tif (unlikely(eth_type_vlan(skb->protocol)))\n\t\t\treturn -EINVAL;\n\n\t\tskb_reset_network_header(skb);\n\t\tkey->eth.type = skb->protocol;\n\t} else {\n\t\teth = eth_hdr(skb);\n\t\tether_addr_copy(key->eth.src, eth->h_source);\n\t\tether_addr_copy(key->eth.dst, eth->h_dest);\n\n\t\t__skb_pull(skb, 2 * ETH_ALEN);\n\t\t \n\n\t\tif (unlikely(parse_vlan(skb, key)))\n\t\t\treturn -ENOMEM;\n\n\t\tkey->eth.type = parse_ethertype(skb);\n\t\tif (unlikely(key->eth.type == htons(0)))\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tif (key->eth.cvlan.tci & htons(VLAN_CFI_MASK))\n\t\t\tskb->protocol = key->eth.cvlan.tpid;\n\t\telse\n\t\t\tskb->protocol = key->eth.type;\n\n\t\tskb_reset_network_header(skb);\n\t\t__skb_push(skb, skb->data - skb_mac_header(skb));\n\t}\n\n\tskb_reset_mac_len(skb);\n\n\t \n\treturn key_extract_l3l4(skb, key);\n}\n\n \nint ovs_flow_key_update_l3l4(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\treturn key_extract_l3l4(skb, key);\n}\n\nint ovs_flow_key_update(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tint res;\n\n\tres = key_extract(skb, key);\n\tif (!res)\n\t\tkey->mac_proto &= ~SW_FLOW_KEY_INVALID;\n\n\treturn res;\n}\n\nstatic int key_extract_mac_proto(struct sk_buff *skb)\n{\n\tswitch (skb->dev->type) {\n\tcase ARPHRD_ETHER:\n\t\treturn MAC_PROTO_ETHERNET;\n\tcase ARPHRD_NONE:\n\t\tif (skb->protocol == htons(ETH_P_TEB))\n\t\t\treturn MAC_PROTO_ETHERNET;\n\t\treturn MAC_PROTO_NONE;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn -EINVAL;\n}\n\nint ovs_flow_key_extract(const struct ip_tunnel_info *tun_info,\n\t\t\t struct sk_buff *skb, struct sw_flow_key *key)\n{\n#if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)\n\tstruct tc_skb_ext *tc_ext;\n#endif\n\tbool post_ct = false, post_ct_snat = false, post_ct_dnat = false;\n\tint res, err;\n\tu16 zone = 0;\n\n\t \n\tif (tun_info) {\n\t\tkey->tun_proto = ip_tunnel_info_af(tun_info);\n\t\tmemcpy(&key->tun_key, &tun_info->key, sizeof(key->tun_key));\n\n\t\tif (tun_info->options_len) {\n\t\t\tBUILD_BUG_ON((1 << (sizeof(tun_info->options_len) *\n\t\t\t\t\t\t   8)) - 1\n\t\t\t\t\t> sizeof(key->tun_opts));\n\n\t\t\tip_tunnel_info_opts_get(TUN_METADATA_OPTS(key, tun_info->options_len),\n\t\t\t\t\t\ttun_info);\n\t\t\tkey->tun_opts_len = tun_info->options_len;\n\t\t} else {\n\t\t\tkey->tun_opts_len = 0;\n\t\t}\n\t} else  {\n\t\tkey->tun_proto = 0;\n\t\tkey->tun_opts_len = 0;\n\t\tmemset(&key->tun_key, 0, sizeof(key->tun_key));\n\t}\n\n\tkey->phy.priority = skb->priority;\n\tkey->phy.in_port = OVS_CB(skb)->input_vport->port_no;\n\tkey->phy.skb_mark = skb->mark;\n\tkey->ovs_flow_hash = 0;\n\tres = key_extract_mac_proto(skb);\n\tif (res < 0)\n\t\treturn res;\n\tkey->mac_proto = res;\n\n#if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)\n\tif (tc_skb_ext_tc_enabled()) {\n\t\ttc_ext = skb_ext_find(skb, TC_SKB_EXT);\n\t\tkey->recirc_id = tc_ext && !tc_ext->act_miss ?\n\t\t\t\t tc_ext->chain : 0;\n\t\tOVS_CB(skb)->mru = tc_ext ? tc_ext->mru : 0;\n\t\tpost_ct = tc_ext ? tc_ext->post_ct : false;\n\t\tpost_ct_snat = post_ct ? tc_ext->post_ct_snat : false;\n\t\tpost_ct_dnat = post_ct ? tc_ext->post_ct_dnat : false;\n\t\tzone = post_ct ? tc_ext->zone : 0;\n\t} else {\n\t\tkey->recirc_id = 0;\n\t}\n#else\n\tkey->recirc_id = 0;\n#endif\n\n\terr = key_extract(skb, key);\n\tif (!err) {\n\t\tovs_ct_fill_key(skb, key, post_ct);    \n\t\tif (post_ct) {\n\t\t\tif (!skb_get_nfct(skb)) {\n\t\t\t\tkey->ct_zone = zone;\n\t\t\t} else {\n\t\t\t\tif (!post_ct_dnat)\n\t\t\t\t\tkey->ct_state &= ~OVS_CS_F_DST_NAT;\n\t\t\t\tif (!post_ct_snat)\n\t\t\t\t\tkey->ct_state &= ~OVS_CS_F_SRC_NAT;\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}\n\nint ovs_flow_key_extract_userspace(struct net *net, const struct nlattr *attr,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct sw_flow_key *key, bool log)\n{\n\tconst struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\n\tu64 attrs = 0;\n\tint err;\n\n\terr = parse_flow_nlattrs(attr, a, &attrs, log);\n\tif (err)\n\t\treturn -EINVAL;\n\n\t \n\terr = ovs_nla_get_flow_metadata(net, a, attrs, key, log);\n\tif (err)\n\t\treturn err;\n\n\t \n\n\tskb->protocol = key->eth.type;\n\terr = key_extract(skb, key);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (attrs & (1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4) &&\n\t    key->eth.type != htons(ETH_P_IP))\n\t\treturn -EINVAL;\n\tif (attrs & (1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6) &&\n\t    (key->eth.type != htons(ETH_P_IPV6) ||\n\t     sw_flow_key_is_nd(key)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}