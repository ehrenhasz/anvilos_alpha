{
  "module_name": "vport-internal_dev.c",
  "hash_id": "7ab426f869074a1d02dadba4704d87a52873097c39af7786541e85df5f13f4f4",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/vport-internal_dev.c",
  "human_readable_source": "\n \n\n#include <linux/if_vlan.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/skbuff.h>\n\n#include <net/dst.h>\n#include <net/xfrm.h>\n#include <net/rtnetlink.h>\n\n#include \"datapath.h\"\n#include \"vport-internal_dev.h\"\n#include \"vport-netdev.h\"\n\nstruct internal_dev {\n\tstruct vport *vport;\n};\n\nstatic struct vport_ops ovs_internal_vport_ops;\n\nstatic struct internal_dev *internal_dev_priv(struct net_device *netdev)\n{\n\treturn netdev_priv(netdev);\n}\n\n \nstatic netdev_tx_t\ninternal_dev_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tint len, err;\n\n\t \n\tlen = skb->len;\n\n\trcu_read_lock();\n\terr = ovs_vport_receive(internal_dev_priv(netdev)->vport, skb, NULL);\n\trcu_read_unlock();\n\n\tif (likely(!err))\n\t\tdev_sw_netstats_tx_add(netdev, 1, len);\n\telse\n\t\tnetdev->stats.tx_errors++;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int internal_dev_open(struct net_device *netdev)\n{\n\tnetif_start_queue(netdev);\n\treturn 0;\n}\n\nstatic int internal_dev_stop(struct net_device *netdev)\n{\n\tnetif_stop_queue(netdev);\n\treturn 0;\n}\n\nstatic void internal_dev_getinfo(struct net_device *netdev,\n\t\t\t\t struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, \"openvswitch\", sizeof(info->driver));\n}\n\nstatic const struct ethtool_ops internal_dev_ethtool_ops = {\n\t.get_drvinfo\t= internal_dev_getinfo,\n\t.get_link\t= ethtool_op_get_link,\n};\n\nstatic void internal_dev_destructor(struct net_device *dev)\n{\n\tstruct vport *vport = ovs_internal_dev_get_vport(dev);\n\n\tovs_vport_free(vport);\n}\n\nstatic const struct net_device_ops internal_dev_netdev_ops = {\n\t.ndo_open = internal_dev_open,\n\t.ndo_stop = internal_dev_stop,\n\t.ndo_start_xmit = internal_dev_xmit,\n\t.ndo_set_mac_address = eth_mac_addr,\n\t.ndo_get_stats64 = dev_get_tstats64,\n};\n\nstatic struct rtnl_link_ops internal_dev_link_ops __read_mostly = {\n\t.kind = \"openvswitch\",\n};\n\nstatic void do_setup(struct net_device *netdev)\n{\n\tether_setup(netdev);\n\n\tnetdev->max_mtu = ETH_MAX_MTU;\n\n\tnetdev->netdev_ops = &internal_dev_netdev_ops;\n\n\tnetdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tnetdev->priv_flags |= IFF_LIVE_ADDR_CHANGE | IFF_OPENVSWITCH |\n\t\t\t      IFF_NO_QUEUE;\n\tnetdev->needs_free_netdev = true;\n\tnetdev->priv_destructor = NULL;\n\tnetdev->ethtool_ops = &internal_dev_ethtool_ops;\n\tnetdev->rtnl_link_ops = &internal_dev_link_ops;\n\n\tnetdev->features = NETIF_F_LLTX | NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t   NETIF_F_HIGHDMA | NETIF_F_HW_CSUM |\n\t\t\t   NETIF_F_GSO_SOFTWARE | NETIF_F_GSO_ENCAP_ALL;\n\n\tnetdev->vlan_features = netdev->features;\n\tnetdev->hw_enc_features = netdev->features;\n\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX;\n\tnetdev->hw_features = netdev->features & ~NETIF_F_LLTX;\n\n\teth_hw_addr_random(netdev);\n}\n\nstatic struct vport *internal_dev_create(const struct vport_parms *parms)\n{\n\tstruct vport *vport;\n\tstruct internal_dev *internal_dev;\n\tstruct net_device *dev;\n\tint err;\n\n\tvport = ovs_vport_alloc(0, &ovs_internal_vport_ops, parms);\n\tif (IS_ERR(vport)) {\n\t\terr = PTR_ERR(vport);\n\t\tgoto error;\n\t}\n\n\tdev = alloc_netdev(sizeof(struct internal_dev),\n\t\t\t   parms->name, NET_NAME_USER, do_setup);\n\tvport->dev = dev;\n\tif (!vport->dev) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free_vport;\n\t}\n\tvport->dev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!vport->dev->tstats) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free_netdev;\n\t}\n\n\tdev_net_set(vport->dev, ovs_dp_get_net(vport->dp));\n\tdev->ifindex = parms->desired_ifindex;\n\tinternal_dev = internal_dev_priv(vport->dev);\n\tinternal_dev->vport = vport;\n\n\t \n\tif (vport->port_no == OVSP_LOCAL)\n\t\tvport->dev->features |= NETIF_F_NETNS_LOCAL;\n\n\trtnl_lock();\n\terr = register_netdevice(vport->dev);\n\tif (err)\n\t\tgoto error_unlock;\n\tvport->dev->priv_destructor = internal_dev_destructor;\n\n\tdev_set_promiscuity(vport->dev, 1);\n\trtnl_unlock();\n\tnetif_start_queue(vport->dev);\n\n\treturn vport;\n\nerror_unlock:\n\trtnl_unlock();\n\tfree_percpu(dev->tstats);\nerror_free_netdev:\n\tfree_netdev(dev);\nerror_free_vport:\n\tovs_vport_free(vport);\nerror:\n\treturn ERR_PTR(err);\n}\n\nstatic void internal_dev_destroy(struct vport *vport)\n{\n\tnetif_stop_queue(vport->dev);\n\trtnl_lock();\n\tdev_set_promiscuity(vport->dev, -1);\n\n\t \n\tunregister_netdevice(vport->dev);\n\tfree_percpu(vport->dev->tstats);\n\trtnl_unlock();\n}\n\nstatic int internal_dev_recv(struct sk_buff *skb)\n{\n\tstruct net_device *netdev = skb->dev;\n\n\tif (unlikely(!(netdev->flags & IFF_UP))) {\n\t\tkfree_skb(skb);\n\t\tnetdev->stats.rx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tskb_dst_drop(skb);\n\tnf_reset_ct(skb);\n\tsecpath_reset(skb);\n\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, netdev);\n\tskb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);\n\tdev_sw_netstats_rx_add(netdev, skb->len);\n\n\tnetif_rx(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic struct vport_ops ovs_internal_vport_ops = {\n\t.type\t\t= OVS_VPORT_TYPE_INTERNAL,\n\t.create\t\t= internal_dev_create,\n\t.destroy\t= internal_dev_destroy,\n\t.send\t\t= internal_dev_recv,\n};\n\nint ovs_is_internal_dev(const struct net_device *netdev)\n{\n\treturn netdev->netdev_ops == &internal_dev_netdev_ops;\n}\n\nstruct vport *ovs_internal_dev_get_vport(struct net_device *netdev)\n{\n\tif (!ovs_is_internal_dev(netdev))\n\t\treturn NULL;\n\n\treturn internal_dev_priv(netdev)->vport;\n}\n\nint ovs_internal_dev_rtnl_link_register(void)\n{\n\tint err;\n\n\terr = rtnl_link_register(&internal_dev_link_ops);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ovs_vport_ops_register(&ovs_internal_vport_ops);\n\tif (err < 0)\n\t\trtnl_link_unregister(&internal_dev_link_ops);\n\n\treturn err;\n}\n\nvoid ovs_internal_dev_rtnl_link_unregister(void)\n{\n\tovs_vport_ops_unregister(&ovs_internal_vport_ops);\n\trtnl_link_unregister(&internal_dev_link_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}