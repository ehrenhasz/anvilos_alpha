{
  "module_name": "conntrack.h",
  "hash_id": "e62bcbd4517a534b2ec25e2fd383136c8b5bbe6a963f6c22ad3781f8396ad44c",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/conntrack.h",
  "human_readable_source": " \n \n\n#ifndef OVS_CONNTRACK_H\n#define OVS_CONNTRACK_H 1\n\n#include \"flow.h\"\n\nstruct ovs_conntrack_info;\nstruct ovs_ct_limit_info;\nenum ovs_key_attr;\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\nint ovs_ct_init(struct net *);\nvoid ovs_ct_exit(struct net *);\nbool ovs_ct_verify(struct net *, enum ovs_key_attr attr);\nint ovs_ct_copy_action(struct net *, const struct nlattr *,\n\t\t       const struct sw_flow_key *, struct sw_flow_actions **,\n\t\t       bool log);\nint ovs_ct_action_to_attr(const struct ovs_conntrack_info *, struct sk_buff *);\n\nint ovs_ct_execute(struct net *, struct sk_buff *, struct sw_flow_key *,\n\t\t   const struct ovs_conntrack_info *);\nint ovs_ct_clear(struct sk_buff *skb, struct sw_flow_key *key);\n\nvoid ovs_ct_fill_key(const struct sk_buff *skb, struct sw_flow_key *key,\n\t\t     bool post_ct);\nint ovs_ct_put_key(const struct sw_flow_key *swkey,\n\t\t   const struct sw_flow_key *output, struct sk_buff *skb);\nvoid ovs_ct_free_action(const struct nlattr *a);\n\n#define CT_SUPPORTED_MASK (OVS_CS_F_NEW | OVS_CS_F_ESTABLISHED | \\\n\t\t\t   OVS_CS_F_RELATED | OVS_CS_F_REPLY_DIR | \\\n\t\t\t   OVS_CS_F_INVALID | OVS_CS_F_TRACKED | \\\n\t\t\t   OVS_CS_F_SRC_NAT | OVS_CS_F_DST_NAT)\n#else\n#include <linux/errno.h>\n\nstatic inline int ovs_ct_init(struct net *net) { return 0; }\n\nstatic inline void ovs_ct_exit(struct net *net) { }\n\nstatic inline bool ovs_ct_verify(struct net *net, int attr)\n{\n\treturn false;\n}\n\nstatic inline int ovs_ct_copy_action(struct net *net, const struct nlattr *nla,\n\t\t\t\t     const struct sw_flow_key *key,\n\t\t\t\t     struct sw_flow_actions **acts, bool log)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic inline int ovs_ct_action_to_attr(const struct ovs_conntrack_info *info,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic inline int ovs_ct_execute(struct net *net, struct sk_buff *skb,\n\t\t\t\t struct sw_flow_key *key,\n\t\t\t\t const struct ovs_conntrack_info *info)\n{\n\tkfree_skb(skb);\n\treturn -ENOTSUPP;\n}\n\nstatic inline int ovs_ct_clear(struct sk_buff *skb,\n\t\t\t       struct sw_flow_key *key)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic inline void ovs_ct_fill_key(const struct sk_buff *skb,\n\t\t\t\t   struct sw_flow_key *key,\n\t\t\t\t   bool post_ct)\n{\n\tkey->ct_state = 0;\n\tkey->ct_zone = 0;\n\tkey->ct.mark = 0;\n\tmemset(&key->ct.labels, 0, sizeof(key->ct.labels));\n\t \n\tkey->ct_orig_proto = 0;\n}\n\nstatic inline int ovs_ct_put_key(const struct sw_flow_key *swkey,\n\t\t\t\t const struct sw_flow_key *output,\n\t\t\t\t struct sk_buff *skb)\n{\n\treturn 0;\n}\n\nstatic inline void ovs_ct_free_action(const struct nlattr *a) { }\n\n#define CT_SUPPORTED_MASK 0\n#endif  \n\n#if IS_ENABLED(CONFIG_NETFILTER_CONNCOUNT)\nextern struct genl_family dp_ct_limit_genl_family;\n#endif\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}