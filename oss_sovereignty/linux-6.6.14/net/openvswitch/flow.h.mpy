{
  "module_name": "flow.h",
  "hash_id": "ab8087fa70fc7a948fb6775a1bd6e8e0162eafee8056c9e7765cf25a0a8acda4",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/flow.h",
  "human_readable_source": " \n \n\n#ifndef FLOW_H\n#define FLOW_H 1\n\n#include <linux/cache.h>\n#include <linux/kernel.h>\n#include <linux/netlink.h>\n#include <linux/openvswitch.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/if_ether.h>\n#include <linux/in6.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/cpumask.h>\n#include <net/inet_ecn.h>\n#include <net/ip_tunnels.h>\n#include <net/dst_metadata.h>\n#include <net/nsh.h>\n\nstruct sk_buff;\n\nenum sw_flow_mac_proto {\n\tMAC_PROTO_NONE = 0,\n\tMAC_PROTO_ETHERNET,\n};\n#define SW_FLOW_KEY_INVALID\t0x80\n#define MPLS_LABEL_DEPTH       3\n\n \nenum ofp12_ipv6exthdr_flags {\n\tOFPIEH12_NONEXT = 1 << 0,    \n\tOFPIEH12_ESP    = 1 << 1,    \n\tOFPIEH12_AUTH   = 1 << 2,    \n\tOFPIEH12_DEST   = 1 << 3,    \n\tOFPIEH12_FRAG   = 1 << 4,    \n\tOFPIEH12_ROUTER = 1 << 5,    \n\tOFPIEH12_HOP    = 1 << 6,    \n\tOFPIEH12_UNREP  = 1 << 7,    \n\tOFPIEH12_UNSEQ  = 1 << 8     \n};\n\n \n#define TUN_METADATA_OFFSET(opt_len) \\\n\t(sizeof_field(struct sw_flow_key, tun_opts) - opt_len)\n#define TUN_METADATA_OPTS(flow_key, opt_len) \\\n\t((void *)((flow_key)->tun_opts + TUN_METADATA_OFFSET(opt_len)))\n\nstruct ovs_tunnel_info {\n\tstruct metadata_dst\t*tun_dst;\n};\n\nstruct vlan_head {\n\t__be16 tpid;  \n\t__be16 tci;   \n};\n\n#define OVS_SW_FLOW_KEY_METADATA_SIZE\t\t\t\\\n\t(offsetof(struct sw_flow_key, recirc_id) +\t\\\n\tsizeof_field(struct sw_flow_key, recirc_id))\n\nstruct ovs_key_nsh {\n\tstruct ovs_nsh_key_base base;\n\t__be32 context[NSH_MD1_CONTEXT_SIZE];\n};\n\nstruct sw_flow_key {\n\tu8 tun_opts[IP_TUNNEL_OPTS_MAX];\n\tu8 tun_opts_len;\n\tstruct ip_tunnel_key tun_key;\t \n\tstruct {\n\t\tu32\tpriority;\t \n\t\tu32\tskb_mark;\t \n\t\tu16\tin_port;\t \n\t} __packed phy;  \n\tu8 mac_proto;\t\t\t \n\tu8 tun_proto;\t\t\t \n\tu32 ovs_flow_hash;\t\t \n\tu32 recirc_id;\t\t\t \n\tstruct {\n\t\tu8     src[ETH_ALEN];\t \n\t\tu8     dst[ETH_ALEN];\t \n\t\tstruct vlan_head vlan;\n\t\tstruct vlan_head cvlan;\n\t\t__be16 type;\t\t \n\t} eth;\n\t \n\tu8 ct_state;\n\tu8 ct_orig_proto;\t\t \n\tunion {\n\t\tstruct {\n\t\t\tu8     proto;\t \n\t\t\tu8     tos;\t     \n\t\t\tu8     ttl;\t     \n\t\t\tu8     frag;\t \n\t\t} ip;\n\t};\n\tu16 ct_zone;\t\t\t \n\tstruct {\n\t\t__be16 src;\t\t \n\t\t__be16 dst;\t\t \n\t\t__be16 flags;\t\t \n\t} tp;\n\tunion {\n\t\tstruct {\n\t\t\tstruct {\n\t\t\t\t__be32 src;\t \n\t\t\t\t__be32 dst;\t \n\t\t\t} addr;\n\t\t\tunion {\n\t\t\t\tstruct {\n\t\t\t\t\t__be32 src;\n\t\t\t\t\t__be32 dst;\n\t\t\t\t} ct_orig;\t \n\t\t\t\tstruct {\n\t\t\t\t\tu8 sha[ETH_ALEN];\t \n\t\t\t\t\tu8 tha[ETH_ALEN];\t \n\t\t\t\t} arp;\n\t\t\t};\n\t\t} ipv4;\n\t\tstruct {\n\t\t\tstruct {\n\t\t\t\tstruct in6_addr src;\t \n\t\t\t\tstruct in6_addr dst;\t \n\t\t\t} addr;\n\t\t\t__be32 label;\t\t\t \n\t\t\tu16 exthdrs;\t \n\t\t\tunion {\n\t\t\t\tstruct {\n\t\t\t\t\tstruct in6_addr src;\n\t\t\t\t\tstruct in6_addr dst;\n\t\t\t\t} ct_orig;\t \n\t\t\t\tstruct {\n\t\t\t\t\tstruct in6_addr target;\t \n\t\t\t\t\tu8 sll[ETH_ALEN];\t \n\t\t\t\t\tu8 tll[ETH_ALEN];\t \n\t\t\t\t} nd;\n\t\t\t};\n\t\t} ipv6;\n\t\tstruct {\n\t\t\tu32 num_labels_mask;     \n\t\t\t__be32 lse[MPLS_LABEL_DEPTH];      \n\t\t} mpls;\n\n\t\tstruct ovs_key_nsh nsh;          \n\t};\n\tstruct {\n\t\t \n\t\tstruct {\n\t\t\t__be16 src;\t \n\t\t\t__be16 dst;\t \n\t\t} orig_tp;\n\t\tu32 mark;\n\t\tstruct ovs_key_ct_labels labels;\n\t} ct;\n\n} __aligned(BITS_PER_LONG/8);  \n\nstatic inline bool sw_flow_key_is_nd(const struct sw_flow_key *key)\n{\n\treturn key->eth.type == htons(ETH_P_IPV6) &&\n\t\tkey->ip.proto == NEXTHDR_ICMP &&\n\t\tkey->tp.dst == 0 &&\n\t\t(key->tp.src == htons(NDISC_NEIGHBOUR_SOLICITATION) ||\n\t\t key->tp.src == htons(NDISC_NEIGHBOUR_ADVERTISEMENT));\n}\n\nstruct sw_flow_key_range {\n\tunsigned short int start;\n\tunsigned short int end;\n};\n\nstruct sw_flow_mask {\n\tint ref_count;\n\tstruct rcu_head rcu;\n\tstruct sw_flow_key_range range;\n\tstruct sw_flow_key key;\n};\n\nstruct sw_flow_match {\n\tstruct sw_flow_key *key;\n\tstruct sw_flow_key_range range;\n\tstruct sw_flow_mask *mask;\n};\n\n#define MAX_UFID_LENGTH 16  \n\nstruct sw_flow_id {\n\tu32 ufid_len;\n\tunion {\n\t\tu32 ufid[MAX_UFID_LENGTH / 4];\n\t\tstruct sw_flow_key *unmasked_key;\n\t};\n};\n\nstruct sw_flow_actions {\n\tstruct rcu_head rcu;\n\tsize_t orig_len;\t \n\tu32 actions_len;\n\tstruct nlattr actions[];\n};\n\nstruct sw_flow_stats {\n\tu64 packet_count;\t\t \n\tu64 byte_count;\t\t\t \n\tunsigned long used;\t\t \n\tspinlock_t lock;\t\t \n\t__be16 tcp_flags;\t\t \n};\n\nstruct sw_flow {\n\tstruct rcu_head rcu;\n\tstruct {\n\t\tstruct hlist_node node[2];\n\t\tu32 hash;\n\t} flow_table, ufid_table;\n\tint stats_last_writer;\t\t \n\tstruct sw_flow_key key;\n\tstruct sw_flow_id id;\n\tstruct cpumask *cpu_used_mask;\n\tstruct sw_flow_mask *mask;\n\tstruct sw_flow_actions __rcu *sf_acts;\n\tstruct sw_flow_stats __rcu *stats[];  \n};\n\nstruct arp_eth_header {\n\t__be16      ar_hrd;\t \n\t__be16      ar_pro;\t \n\tunsigned char   ar_hln;\t \n\tunsigned char   ar_pln;\t \n\t__be16      ar_op;\t \n\n\t \n\tunsigned char       ar_sha[ETH_ALEN];\t \n\tunsigned char       ar_sip[4];\t\t \n\tunsigned char       ar_tha[ETH_ALEN];\t \n\tunsigned char       ar_tip[4];\t\t \n} __packed;\n\nstatic inline u8 ovs_key_mac_proto(const struct sw_flow_key *key)\n{\n\treturn key->mac_proto & ~SW_FLOW_KEY_INVALID;\n}\n\nstatic inline u16 __ovs_mac_header_len(u8 mac_proto)\n{\n\treturn mac_proto == MAC_PROTO_ETHERNET ? ETH_HLEN : 0;\n}\n\nstatic inline u16 ovs_mac_header_len(const struct sw_flow_key *key)\n{\n\treturn __ovs_mac_header_len(ovs_key_mac_proto(key));\n}\n\nstatic inline bool ovs_identifier_is_ufid(const struct sw_flow_id *sfid)\n{\n\treturn sfid->ufid_len;\n}\n\nstatic inline bool ovs_identifier_is_key(const struct sw_flow_id *sfid)\n{\n\treturn !ovs_identifier_is_ufid(sfid);\n}\n\nvoid ovs_flow_stats_update(struct sw_flow *, __be16 tcp_flags,\n\t\t\t   const struct sk_buff *);\nvoid ovs_flow_stats_get(const struct sw_flow *, struct ovs_flow_stats *,\n\t\t\tunsigned long *used, __be16 *tcp_flags);\nvoid ovs_flow_stats_clear(struct sw_flow *);\nu64 ovs_flow_used_time(unsigned long flow_jiffies);\n\nint ovs_flow_key_update(struct sk_buff *skb, struct sw_flow_key *key);\nint ovs_flow_key_update_l3l4(struct sk_buff *skb, struct sw_flow_key *key);\nint ovs_flow_key_extract(const struct ip_tunnel_info *tun_info,\n\t\t\t struct sk_buff *skb,\n\t\t\t struct sw_flow_key *key);\n \nint ovs_flow_key_extract_userspace(struct net *net, const struct nlattr *attr,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct sw_flow_key *key, bool log);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}