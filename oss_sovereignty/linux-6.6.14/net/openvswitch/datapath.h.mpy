{
  "module_name": "datapath.h",
  "hash_id": "101b16b989773926dc8f1abfa62cdfd013fe639bdfc761ab448d7de9097f0433",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/datapath.h",
  "human_readable_source": " \n \n\n#ifndef DATAPATH_H\n#define DATAPATH_H 1\n\n#include <asm/page.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/u64_stats_sync.h>\n#include <net/ip_tunnels.h>\n\n#include \"conntrack.h\"\n#include \"flow.h\"\n#include \"flow_table.h\"\n#include \"meter.h\"\n#include \"vport-internal_dev.h\"\n\n#define DP_MAX_PORTS                USHRT_MAX\n#define DP_VPORT_HASH_BUCKETS       1024\n#define DP_MASKS_REBALANCE_INTERVAL 4000\n\n \nstruct dp_stats_percpu {\n\tu64 n_hit;\n\tu64 n_missed;\n\tu64 n_lost;\n\tu64 n_mask_hit;\n\tu64 n_cache_hit;\n\tstruct u64_stats_sync syncp;\n};\n\n \nstruct dp_nlsk_pids {\n\tstruct rcu_head rcu;\n\tu32 n_pids;\n\tu32 pids[];\n};\n\n \nstruct datapath {\n\tstruct rcu_head rcu;\n\tstruct list_head list_node;\n\n\t \n\tstruct flow_table table;\n\n\t \n\tstruct hlist_head *ports;\n\n\t \n\tstruct dp_stats_percpu __percpu *stats_percpu;\n\n\t \n\tpossible_net_t net;\n\n\tu32 user_features;\n\n\tu32 max_headroom;\n\n\t \n\tstruct dp_meter_table meter_tbl;\n\n\tstruct dp_nlsk_pids __rcu *upcall_portids;\n};\n\n \nstruct ovs_skb_cb {\n\tstruct vport\t\t*input_vport;\n\tu16\t\t\tmru;\n\tu16\t\t\tacts_origlen;\n\tu32\t\t\tcutlen;\n};\n#define OVS_CB(skb) ((struct ovs_skb_cb *)(skb)->cb)\n\n \nstruct dp_upcall_info {\n\tstruct ip_tunnel_info *egress_tun_info;\n\tconst struct nlattr *userdata;\n\tconst struct nlattr *actions;\n\tint actions_len;\n\tu32 portid;\n\tu8 cmd;\n\tu16 mru;\n};\n\n \nstruct ovs_net {\n\tstruct list_head dps;\n\tstruct work_struct dp_notify_work;\n\tstruct delayed_work masks_rebalance;\n#if\tIS_ENABLED(CONFIG_NETFILTER_CONNCOUNT)\n\tstruct ovs_ct_limit_info *ct_limit_info;\n#endif\n\n\t \n\tbool xt_label;\n};\n\n \nenum ovs_pkt_hash_types {\n\tOVS_PACKET_HASH_SW_BIT = (1ULL << 32),\n\tOVS_PACKET_HASH_L4_BIT = (1ULL << 33),\n};\n\nextern unsigned int ovs_net_id;\nvoid ovs_lock(void);\nvoid ovs_unlock(void);\n\n#ifdef CONFIG_LOCKDEP\nint lockdep_ovsl_is_held(void);\n#else\n#define lockdep_ovsl_is_held()\t1\n#endif\n\n#define ASSERT_OVSL()\t\tWARN_ON(!lockdep_ovsl_is_held())\n#define ovsl_dereference(p)\t\t\t\t\t\\\n\trcu_dereference_protected(p, lockdep_ovsl_is_held())\n#define rcu_dereference_ovsl(p)\t\t\t\t\t\\\n\trcu_dereference_check(p, lockdep_ovsl_is_held())\n\nstatic inline struct net *ovs_dp_get_net(const struct datapath *dp)\n{\n\treturn read_pnet(&dp->net);\n}\n\nstatic inline void ovs_dp_set_net(struct datapath *dp, struct net *net)\n{\n\twrite_pnet(&dp->net, net);\n}\n\nstruct vport *ovs_lookup_vport(const struct datapath *dp, u16 port_no);\n\nstatic inline struct vport *ovs_vport_rcu(const struct datapath *dp, int port_no)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn ovs_lookup_vport(dp, port_no);\n}\n\nstatic inline struct vport *ovs_vport_ovsl_rcu(const struct datapath *dp, int port_no)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held() && !lockdep_ovsl_is_held());\n\treturn ovs_lookup_vport(dp, port_no);\n}\n\nstatic inline struct vport *ovs_vport_ovsl(const struct datapath *dp, int port_no)\n{\n\tASSERT_OVSL();\n\treturn ovs_lookup_vport(dp, port_no);\n}\n\n \nstatic inline struct datapath *get_dp_rcu(struct net *net, int dp_ifindex)\n{\n\tstruct net_device *dev = dev_get_by_index_rcu(net, dp_ifindex);\n\n\tif (dev) {\n\t\tstruct vport *vport = ovs_internal_dev_get_vport(dev);\n\n\t\tif (vport)\n\t\t\treturn vport->dp;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline struct datapath *get_dp(struct net *net, int dp_ifindex)\n{\n\tstruct datapath *dp;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held() && !lockdep_ovsl_is_held());\n\trcu_read_lock();\n\tdp = get_dp_rcu(net, dp_ifindex);\n\trcu_read_unlock();\n\n\treturn dp;\n}\n\nextern struct notifier_block ovs_dp_device_notifier;\nextern struct genl_family dp_vport_genl_family;\n\nvoid ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key);\nvoid ovs_dp_detach_port(struct vport *);\nint ovs_dp_upcall(struct datapath *, struct sk_buff *,\n\t\t  const struct sw_flow_key *, const struct dp_upcall_info *,\n\t\t  uint32_t cutlen);\n\nu32 ovs_dp_get_upcall_portid(const struct datapath *dp, uint32_t cpu_id);\n\nconst char *ovs_dp_name(const struct datapath *dp);\nstruct sk_buff *ovs_vport_cmd_build_info(struct vport *vport, struct net *net,\n\t\t\t\t\t u32 portid, u32 seq, u8 cmd);\n\nint ovs_execute_actions(struct datapath *dp, struct sk_buff *skb,\n\t\t\tconst struct sw_flow_actions *, struct sw_flow_key *);\n\nvoid ovs_dp_notify_wq(struct work_struct *work);\n\nint action_fifos_init(void);\nvoid action_fifos_exit(void);\n\n \n#define OVS_MASKED(OLD, KEY, MASK) ((KEY) | ((OLD) & ~(MASK)))\n#define OVS_SET_MASKED(OLD, KEY, MASK) ((OLD) = OVS_MASKED(OLD, KEY, MASK))\n\n#define OVS_NLERR(logging_allowed, fmt, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (logging_allowed && net_ratelimit())\t\t\t\\\n\t\tpr_info(\"netlink: \" fmt \"\\n\", ##__VA_ARGS__);\t\\\n} while (0)\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}