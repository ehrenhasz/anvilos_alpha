{
  "module_name": "meter.c",
  "hash_id": "6e81ff53111d89c61ea656b75c1aa36437b81cce66257ae6a3132a5758f92ee2",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/meter.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/if.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/openvswitch.h>\n#include <linux/netlink.h>\n#include <linux/rculist.h>\n\n#include <net/netlink.h>\n#include <net/genetlink.h>\n\n#include \"datapath.h\"\n#include \"meter.h\"\n\nstatic const struct nla_policy meter_policy[OVS_METER_ATTR_MAX + 1] = {\n\t[OVS_METER_ATTR_ID] = { .type = NLA_U32, },\n\t[OVS_METER_ATTR_KBPS] = { .type = NLA_FLAG },\n\t[OVS_METER_ATTR_STATS] = { .len = sizeof(struct ovs_flow_stats) },\n\t[OVS_METER_ATTR_BANDS] = { .type = NLA_NESTED },\n\t[OVS_METER_ATTR_USED] = { .type = NLA_U64 },\n\t[OVS_METER_ATTR_CLEAR] = { .type = NLA_FLAG },\n\t[OVS_METER_ATTR_MAX_METERS] = { .type = NLA_U32 },\n\t[OVS_METER_ATTR_MAX_BANDS] = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy band_policy[OVS_BAND_ATTR_MAX + 1] = {\n\t[OVS_BAND_ATTR_TYPE] = { .type = NLA_U32, },\n\t[OVS_BAND_ATTR_RATE] = { .type = NLA_U32, },\n\t[OVS_BAND_ATTR_BURST] = { .type = NLA_U32, },\n\t[OVS_BAND_ATTR_STATS] = { .len = sizeof(struct ovs_flow_stats) },\n};\n\nstatic u32 meter_hash(struct dp_meter_instance *ti, u32 id)\n{\n\treturn id % ti->n_meters;\n}\n\nstatic void ovs_meter_free(struct dp_meter *meter)\n{\n\tif (!meter)\n\t\treturn;\n\n\tkfree_rcu(meter, rcu);\n}\n\n \nstatic struct dp_meter *lookup_meter(const struct dp_meter_table *tbl,\n\t\t\t\t     u32 meter_id)\n{\n\tstruct dp_meter_instance *ti = rcu_dereference_ovsl(tbl->ti);\n\tu32 hash = meter_hash(ti, meter_id);\n\tstruct dp_meter *meter;\n\n\tmeter = rcu_dereference_ovsl(ti->dp_meters[hash]);\n\tif (meter && likely(meter->id == meter_id))\n\t\treturn meter;\n\n\treturn NULL;\n}\n\nstatic struct dp_meter_instance *dp_meter_instance_alloc(const u32 size)\n{\n\tstruct dp_meter_instance *ti;\n\n\tti = kvzalloc(struct_size(ti, dp_meters, size), GFP_KERNEL);\n\tif (!ti)\n\t\treturn NULL;\n\n\tti->n_meters = size;\n\n\treturn ti;\n}\n\nstatic void dp_meter_instance_free(struct dp_meter_instance *ti)\n{\n\tkvfree(ti);\n}\n\nstatic void dp_meter_instance_free_rcu(struct rcu_head *rcu)\n{\n\tstruct dp_meter_instance *ti;\n\n\tti = container_of(rcu, struct dp_meter_instance, rcu);\n\tkvfree(ti);\n}\n\nstatic int\ndp_meter_instance_realloc(struct dp_meter_table *tbl, u32 size)\n{\n\tstruct dp_meter_instance *ti = rcu_dereference_ovsl(tbl->ti);\n\tint n_meters = min(size, ti->n_meters);\n\tstruct dp_meter_instance *new_ti;\n\tint i;\n\n\tnew_ti = dp_meter_instance_alloc(size);\n\tif (!new_ti)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n_meters; i++)\n\t\tif (rcu_dereference_ovsl(ti->dp_meters[i]))\n\t\t\tnew_ti->dp_meters[i] = ti->dp_meters[i];\n\n\trcu_assign_pointer(tbl->ti, new_ti);\n\tcall_rcu(&ti->rcu, dp_meter_instance_free_rcu);\n\n\treturn 0;\n}\n\nstatic void dp_meter_instance_insert(struct dp_meter_instance *ti,\n\t\t\t\t     struct dp_meter *meter)\n{\n\tu32 hash;\n\n\thash = meter_hash(ti, meter->id);\n\trcu_assign_pointer(ti->dp_meters[hash], meter);\n}\n\nstatic void dp_meter_instance_remove(struct dp_meter_instance *ti,\n\t\t\t\t     struct dp_meter *meter)\n{\n\tu32 hash;\n\n\thash = meter_hash(ti, meter->id);\n\tRCU_INIT_POINTER(ti->dp_meters[hash], NULL);\n}\n\nstatic int attach_meter(struct dp_meter_table *tbl, struct dp_meter *meter)\n{\n\tstruct dp_meter_instance *ti = rcu_dereference_ovsl(tbl->ti);\n\tu32 hash = meter_hash(ti, meter->id);\n\tint err;\n\n\t \n\tif (unlikely(rcu_dereference_ovsl(ti->dp_meters[hash])))\n\t\treturn -EBUSY;\n\n\tdp_meter_instance_insert(ti, meter);\n\n\t \n\ttbl->count++;\n\tif (tbl->count >= tbl->max_meters_allowed) {\n\t\terr = -EFBIG;\n\t\tgoto attach_err;\n\t}\n\n\tif (tbl->count >= ti->n_meters &&\n\t    dp_meter_instance_realloc(tbl, ti->n_meters * 2)) {\n\t\terr = -ENOMEM;\n\t\tgoto attach_err;\n\t}\n\n\treturn 0;\n\nattach_err:\n\tdp_meter_instance_remove(ti, meter);\n\ttbl->count--;\n\treturn err;\n}\n\nstatic int detach_meter(struct dp_meter_table *tbl, struct dp_meter *meter)\n{\n\tstruct dp_meter_instance *ti;\n\n\tASSERT_OVSL();\n\tif (!meter)\n\t\treturn 0;\n\n\tti = rcu_dereference_ovsl(tbl->ti);\n\tdp_meter_instance_remove(ti, meter);\n\n\ttbl->count--;\n\n\t \n\tif (ti->n_meters > DP_METER_ARRAY_SIZE_MIN &&\n\t    tbl->count <= (ti->n_meters / 4)) {\n\t\tint half_size = ti->n_meters / 2;\n\t\tint i;\n\n\t\t \n\t\tfor (i = half_size; i < ti->n_meters; i++)\n\t\t\tif (rcu_dereference_ovsl(ti->dp_meters[i]))\n\t\t\t\tgoto out;\n\n\t\tif (dp_meter_instance_realloc(tbl, half_size))\n\t\t\tgoto shrink_err;\n\t}\n\nout:\n\treturn 0;\n\nshrink_err:\n\tdp_meter_instance_insert(ti, meter);\n\ttbl->count++;\n\treturn -ENOMEM;\n}\n\nstatic struct sk_buff *\novs_meter_cmd_reply_start(struct genl_info *info, u8 cmd,\n\t\t\t  struct ovs_header **ovs_reply_header)\n{\n\tstruct sk_buff *skb;\n\tstruct ovs_header *ovs_header = genl_info_userhdr(info);\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t*ovs_reply_header = genlmsg_put(skb, info->snd_portid,\n\t\t\t\t\tinfo->snd_seq,\n\t\t\t\t\t&dp_meter_genl_family, 0, cmd);\n\tif (!*ovs_reply_header) {\n\t\tnlmsg_free(skb);\n\t\treturn ERR_PTR(-EMSGSIZE);\n\t}\n\t(*ovs_reply_header)->dp_ifindex = ovs_header->dp_ifindex;\n\n\treturn skb;\n}\n\nstatic int ovs_meter_cmd_reply_stats(struct sk_buff *reply, u32 meter_id,\n\t\t\t\t     struct dp_meter *meter)\n{\n\tstruct nlattr *nla;\n\tstruct dp_meter_band *band;\n\tu16 i;\n\n\tif (nla_put_u32(reply, OVS_METER_ATTR_ID, meter_id))\n\t\tgoto error;\n\n\tif (nla_put(reply, OVS_METER_ATTR_STATS,\n\t\t    sizeof(struct ovs_flow_stats), &meter->stats))\n\t\tgoto error;\n\n\tif (nla_put_u64_64bit(reply, OVS_METER_ATTR_USED, meter->used,\n\t\t\t      OVS_METER_ATTR_PAD))\n\t\tgoto error;\n\n\tnla = nla_nest_start_noflag(reply, OVS_METER_ATTR_BANDS);\n\tif (!nla)\n\t\tgoto error;\n\n\tband = meter->bands;\n\n\tfor (i = 0; i < meter->n_bands; ++i, ++band) {\n\t\tstruct nlattr *band_nla;\n\n\t\tband_nla = nla_nest_start_noflag(reply, OVS_BAND_ATTR_UNSPEC);\n\t\tif (!band_nla || nla_put(reply, OVS_BAND_ATTR_STATS,\n\t\t\t\t\t sizeof(struct ovs_flow_stats),\n\t\t\t\t\t &band->stats))\n\t\t\tgoto error;\n\t\tnla_nest_end(reply, band_nla);\n\t}\n\tnla_nest_end(reply, nla);\n\n\treturn 0;\nerror:\n\treturn -EMSGSIZE;\n}\n\nstatic int ovs_meter_cmd_features(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ovs_header *ovs_header = genl_info_userhdr(info);\n\tstruct ovs_header *ovs_reply_header;\n\tstruct nlattr *nla, *band_nla;\n\tstruct sk_buff *reply;\n\tstruct datapath *dp;\n\tint err = -EMSGSIZE;\n\n\treply = ovs_meter_cmd_reply_start(info, OVS_METER_CMD_FEATURES,\n\t\t\t\t\t  &ovs_reply_header);\n\tif (IS_ERR(reply))\n\t\treturn PTR_ERR(reply);\n\n\tovs_lock();\n\tdp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\n\tif (!dp) {\n\t\terr = -ENODEV;\n\t\tgoto exit_unlock;\n\t}\n\n\tif (nla_put_u32(reply, OVS_METER_ATTR_MAX_METERS,\n\t\t\tdp->meter_tbl.max_meters_allowed))\n\t\tgoto exit_unlock;\n\n\tovs_unlock();\n\n\tif (nla_put_u32(reply, OVS_METER_ATTR_MAX_BANDS, DP_MAX_BANDS))\n\t\tgoto nla_put_failure;\n\n\tnla = nla_nest_start_noflag(reply, OVS_METER_ATTR_BANDS);\n\tif (!nla)\n\t\tgoto nla_put_failure;\n\n\tband_nla = nla_nest_start_noflag(reply, OVS_BAND_ATTR_UNSPEC);\n\tif (!band_nla)\n\t\tgoto nla_put_failure;\n\t \n\tif (nla_put_u32(reply, OVS_BAND_ATTR_TYPE, OVS_METER_BAND_TYPE_DROP))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(reply, band_nla);\n\tnla_nest_end(reply, nla);\n\n\tgenlmsg_end(reply, ovs_reply_header);\n\treturn genlmsg_reply(reply, info);\n\nexit_unlock:\n\tovs_unlock();\nnla_put_failure:\n\tnlmsg_free(reply);\n\treturn err;\n}\n\nstatic struct dp_meter *dp_meter_create(struct nlattr **a)\n{\n\tstruct nlattr *nla;\n\tint rem;\n\tu16 n_bands = 0;\n\tstruct dp_meter *meter;\n\tstruct dp_meter_band *band;\n\tint err;\n\n\t \n\tif (!a[OVS_METER_ATTR_BANDS])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnla_for_each_nested(nla, a[OVS_METER_ATTR_BANDS], rem)\n\t\tif (++n_bands > DP_MAX_BANDS)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tmeter = kzalloc(struct_size(meter, bands, n_bands), GFP_KERNEL_ACCOUNT);\n\tif (!meter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmeter->id = nla_get_u32(a[OVS_METER_ATTR_ID]);\n\tmeter->used = div_u64(ktime_get_ns(), 1000 * 1000);\n\tmeter->kbps = a[OVS_METER_ATTR_KBPS] ? 1 : 0;\n\tmeter->keep_stats = !a[OVS_METER_ATTR_CLEAR];\n\tspin_lock_init(&meter->lock);\n\tif (meter->keep_stats && a[OVS_METER_ATTR_STATS]) {\n\t\tmeter->stats = *(struct ovs_flow_stats *)\n\t\t\tnla_data(a[OVS_METER_ATTR_STATS]);\n\t}\n\tmeter->n_bands = n_bands;\n\n\t \n\tband = meter->bands;\n\tnla_for_each_nested(nla, a[OVS_METER_ATTR_BANDS], rem) {\n\t\tstruct nlattr *attr[OVS_BAND_ATTR_MAX + 1];\n\t\tu32 band_max_delta_t;\n\n\t\terr = nla_parse_deprecated((struct nlattr **)&attr,\n\t\t\t\t\t   OVS_BAND_ATTR_MAX, nla_data(nla),\n\t\t\t\t\t   nla_len(nla), band_policy, NULL);\n\t\tif (err)\n\t\t\tgoto exit_free_meter;\n\n\t\tif (!attr[OVS_BAND_ATTR_TYPE] ||\n\t\t    !attr[OVS_BAND_ATTR_RATE] ||\n\t\t    !attr[OVS_BAND_ATTR_BURST]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_free_meter;\n\t\t}\n\n\t\tband->type = nla_get_u32(attr[OVS_BAND_ATTR_TYPE]);\n\t\tband->rate = nla_get_u32(attr[OVS_BAND_ATTR_RATE]);\n\t\tif (band->rate == 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_free_meter;\n\t\t}\n\n\t\tband->burst_size = nla_get_u32(attr[OVS_BAND_ATTR_BURST]);\n\t\t \n\t\tband->bucket = band->burst_size * 1000ULL;\n\t\tband_max_delta_t = div_u64(band->bucket, band->rate);\n\t\tif (band_max_delta_t > meter->max_delta_t)\n\t\t\tmeter->max_delta_t = band_max_delta_t;\n\t\tband++;\n\t}\n\n\treturn meter;\n\nexit_free_meter:\n\tkfree(meter);\n\treturn ERR_PTR(err);\n}\n\nstatic int ovs_meter_cmd_set(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr **a = info->attrs;\n\tstruct dp_meter *meter, *old_meter;\n\tstruct sk_buff *reply;\n\tstruct ovs_header *ovs_reply_header;\n\tstruct ovs_header *ovs_header = genl_info_userhdr(info);\n\tstruct dp_meter_table *meter_tbl;\n\tstruct datapath *dp;\n\tint err;\n\tu32 meter_id;\n\tbool failed;\n\n\tif (!a[OVS_METER_ATTR_ID])\n\t\treturn -EINVAL;\n\n\tmeter = dp_meter_create(a);\n\tif (IS_ERR(meter))\n\t\treturn PTR_ERR(meter);\n\n\treply = ovs_meter_cmd_reply_start(info, OVS_METER_CMD_SET,\n\t\t\t\t\t  &ovs_reply_header);\n\tif (IS_ERR(reply)) {\n\t\terr = PTR_ERR(reply);\n\t\tgoto exit_free_meter;\n\t}\n\n\tovs_lock();\n\tdp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\n\tif (!dp) {\n\t\terr = -ENODEV;\n\t\tgoto exit_unlock;\n\t}\n\n\tmeter_tbl = &dp->meter_tbl;\n\tmeter_id = nla_get_u32(a[OVS_METER_ATTR_ID]);\n\n\told_meter = lookup_meter(meter_tbl, meter_id);\n\terr = detach_meter(meter_tbl, old_meter);\n\tif (err)\n\t\tgoto exit_unlock;\n\n\terr = attach_meter(meter_tbl, meter);\n\tif (err)\n\t\tgoto exit_free_old_meter;\n\n\tovs_unlock();\n\n\t \n\tfailed = nla_put_u32(reply, OVS_METER_ATTR_ID, meter_id);\n\tWARN_ON(failed);\n\tif (old_meter) {\n\t\tspin_lock_bh(&old_meter->lock);\n\t\tif (old_meter->keep_stats) {\n\t\t\terr = ovs_meter_cmd_reply_stats(reply, meter_id,\n\t\t\t\t\t\t\told_meter);\n\t\t\tWARN_ON(err);\n\t\t}\n\t\tspin_unlock_bh(&old_meter->lock);\n\t\tovs_meter_free(old_meter);\n\t}\n\n\tgenlmsg_end(reply, ovs_reply_header);\n\treturn genlmsg_reply(reply, info);\n\nexit_free_old_meter:\n\tovs_meter_free(old_meter);\nexit_unlock:\n\tovs_unlock();\n\tnlmsg_free(reply);\nexit_free_meter:\n\tkfree(meter);\n\treturn err;\n}\n\nstatic int ovs_meter_cmd_get(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ovs_header *ovs_header = genl_info_userhdr(info);\n\tstruct ovs_header *ovs_reply_header;\n\tstruct nlattr **a = info->attrs;\n\tstruct dp_meter *meter;\n\tstruct sk_buff *reply;\n\tstruct datapath *dp;\n\tu32 meter_id;\n\tint err;\n\n\tif (!a[OVS_METER_ATTR_ID])\n\t\treturn -EINVAL;\n\n\tmeter_id = nla_get_u32(a[OVS_METER_ATTR_ID]);\n\n\treply = ovs_meter_cmd_reply_start(info, OVS_METER_CMD_GET,\n\t\t\t\t\t  &ovs_reply_header);\n\tif (IS_ERR(reply))\n\t\treturn PTR_ERR(reply);\n\n\tovs_lock();\n\n\tdp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\n\tif (!dp) {\n\t\terr = -ENODEV;\n\t\tgoto exit_unlock;\n\t}\n\n\t \n\tmeter = lookup_meter(&dp->meter_tbl, meter_id);\n\tif (!meter) {\n\t\terr = -ENOENT;\n\t\tgoto exit_unlock;\n\t}\n\n\tspin_lock_bh(&meter->lock);\n\terr = ovs_meter_cmd_reply_stats(reply, meter_id, meter);\n\tspin_unlock_bh(&meter->lock);\n\tif (err)\n\t\tgoto exit_unlock;\n\n\tovs_unlock();\n\n\tgenlmsg_end(reply, ovs_reply_header);\n\treturn genlmsg_reply(reply, info);\n\nexit_unlock:\n\tovs_unlock();\n\tnlmsg_free(reply);\n\treturn err;\n}\n\nstatic int ovs_meter_cmd_del(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ovs_header *ovs_header = genl_info_userhdr(info);\n\tstruct ovs_header *ovs_reply_header;\n\tstruct nlattr **a = info->attrs;\n\tstruct dp_meter *old_meter;\n\tstruct sk_buff *reply;\n\tstruct datapath *dp;\n\tu32 meter_id;\n\tint err;\n\n\tif (!a[OVS_METER_ATTR_ID])\n\t\treturn -EINVAL;\n\n\treply = ovs_meter_cmd_reply_start(info, OVS_METER_CMD_DEL,\n\t\t\t\t\t  &ovs_reply_header);\n\tif (IS_ERR(reply))\n\t\treturn PTR_ERR(reply);\n\n\tovs_lock();\n\n\tdp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\n\tif (!dp) {\n\t\terr = -ENODEV;\n\t\tgoto exit_unlock;\n\t}\n\n\tmeter_id = nla_get_u32(a[OVS_METER_ATTR_ID]);\n\told_meter = lookup_meter(&dp->meter_tbl, meter_id);\n\tif (old_meter) {\n\t\tspin_lock_bh(&old_meter->lock);\n\t\terr = ovs_meter_cmd_reply_stats(reply, meter_id, old_meter);\n\t\tWARN_ON(err);\n\t\tspin_unlock_bh(&old_meter->lock);\n\n\t\terr = detach_meter(&dp->meter_tbl, old_meter);\n\t\tif (err)\n\t\t\tgoto exit_unlock;\n\t}\n\n\tovs_unlock();\n\tovs_meter_free(old_meter);\n\tgenlmsg_end(reply, ovs_reply_header);\n\treturn genlmsg_reply(reply, info);\n\nexit_unlock:\n\tovs_unlock();\n\tnlmsg_free(reply);\n\treturn err;\n}\n\n \nbool ovs_meter_execute(struct datapath *dp, struct sk_buff *skb,\n\t\t       struct sw_flow_key *key, u32 meter_id)\n{\n\tlong long int now_ms = div_u64(ktime_get_ns(), 1000 * 1000);\n\tlong long int long_delta_ms;\n\tstruct dp_meter_band *band;\n\tstruct dp_meter *meter;\n\tint i, band_exceeded_max = -1;\n\tu32 band_exceeded_rate = 0;\n\tu32 delta_ms;\n\tu32 cost;\n\n\tmeter = lookup_meter(&dp->meter_tbl, meter_id);\n\t \n\tif (!meter)\n\t\treturn false;\n\n\t \n\tspin_lock(&meter->lock);\n\n\tlong_delta_ms = (now_ms - meter->used);  \n\tif (long_delta_ms < 0) {\n\t\t \n\t\tlong_delta_ms = 0;\n\t}\n\n\t \n\tdelta_ms = (long_delta_ms > (long long int)meter->max_delta_t)\n\t\t   ? meter->max_delta_t : (u32)long_delta_ms;\n\n\t \n\tmeter->used = now_ms;\n\tmeter->stats.n_packets += 1;\n\tmeter->stats.n_bytes += skb->len;\n\n\t \n\tcost = (meter->kbps) ? skb->len * 8 : 1000;\n\n\t \n\tfor (i = 0; i < meter->n_bands; ++i) {\n\t\tlong long int max_bucket_size;\n\n\t\tband = &meter->bands[i];\n\t\tmax_bucket_size = band->burst_size * 1000LL;\n\n\t\tband->bucket += delta_ms * band->rate;\n\t\tif (band->bucket > max_bucket_size)\n\t\t\tband->bucket = max_bucket_size;\n\n\t\tif (band->bucket >= cost) {\n\t\t\tband->bucket -= cost;\n\t\t} else if (band->rate > band_exceeded_rate) {\n\t\t\tband_exceeded_rate = band->rate;\n\t\t\tband_exceeded_max = i;\n\t\t}\n\t}\n\n\tif (band_exceeded_max >= 0) {\n\t\t \n\t\tband = &meter->bands[band_exceeded_max];\n\t\tband->stats.n_packets += 1;\n\t\tband->stats.n_bytes += skb->len;\n\n\t\t \n\t\tif (band->type == OVS_METER_BAND_TYPE_DROP) {\n\t\t\tspin_unlock(&meter->lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tspin_unlock(&meter->lock);\n\treturn false;\n}\n\nstatic const struct genl_small_ops dp_meter_genl_ops[] = {\n\t{ .cmd = OVS_METER_CMD_FEATURES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = 0,\t\t   \n\t\t.doit = ovs_meter_cmd_features\n\t},\n\t{ .cmd = OVS_METER_CMD_SET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,  \n\t\t.doit = ovs_meter_cmd_set,\n\t},\n\t{ .cmd = OVS_METER_CMD_GET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = 0,\t\t   \n\t\t.doit = ovs_meter_cmd_get,\n\t},\n\t{ .cmd = OVS_METER_CMD_DEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,  \n\t\t.doit = ovs_meter_cmd_del\n\t},\n};\n\nstatic const struct genl_multicast_group ovs_meter_multicast_group = {\n\t.name = OVS_METER_MCGROUP,\n};\n\nstruct genl_family dp_meter_genl_family __ro_after_init = {\n\t.hdrsize = sizeof(struct ovs_header),\n\t.name = OVS_METER_FAMILY,\n\t.version = OVS_METER_VERSION,\n\t.maxattr = OVS_METER_ATTR_MAX,\n\t.policy = meter_policy,\n\t.netnsok = true,\n\t.parallel_ops = true,\n\t.small_ops = dp_meter_genl_ops,\n\t.n_small_ops = ARRAY_SIZE(dp_meter_genl_ops),\n\t.resv_start_op = OVS_METER_CMD_GET + 1,\n\t.mcgrps = &ovs_meter_multicast_group,\n\t.n_mcgrps = 1,\n\t.module = THIS_MODULE,\n};\n\nint ovs_meters_init(struct datapath *dp)\n{\n\tstruct dp_meter_table *tbl = &dp->meter_tbl;\n\tstruct dp_meter_instance *ti;\n\tunsigned long free_mem_bytes;\n\n\tti = dp_meter_instance_alloc(DP_METER_ARRAY_SIZE_MIN);\n\tif (!ti)\n\t\treturn -ENOMEM;\n\n\t \n\tfree_mem_bytes = nr_free_buffer_pages() * (PAGE_SIZE >> 5);\n\ttbl->max_meters_allowed = min(free_mem_bytes / sizeof(struct dp_meter),\n\t\t\t\t      DP_METER_NUM_MAX);\n\tif (!tbl->max_meters_allowed)\n\t\tgoto out_err;\n\n\trcu_assign_pointer(tbl->ti, ti);\n\ttbl->count = 0;\n\n\treturn 0;\n\nout_err:\n\tdp_meter_instance_free(ti);\n\treturn -ENOMEM;\n}\n\nvoid ovs_meters_exit(struct datapath *dp)\n{\n\tstruct dp_meter_table *tbl = &dp->meter_tbl;\n\tstruct dp_meter_instance *ti = rcu_dereference_raw(tbl->ti);\n\tint i;\n\n\tfor (i = 0; i < ti->n_meters; i++)\n\t\tovs_meter_free(rcu_dereference_raw(ti->dp_meters[i]));\n\n\tdp_meter_instance_free(ti);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}