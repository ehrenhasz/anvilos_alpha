{
  "module_name": "conntrack.c",
  "hash_id": "916e1c77f5e970aea3131aa57856451a3ae8c0ab25e7af4bf936fb9ed3b863ef",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/conntrack.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/openvswitch.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/sctp.h>\n#include <linux/static_key.h>\n#include <linux/string_helpers.h>\n#include <net/ip.h>\n#include <net/genetlink.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_count.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_labels.h>\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/nf_conntrack_timeout.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n#include <net/ipv6_frag.h>\n\n#if IS_ENABLED(CONFIG_NF_NAT)\n#include <net/netfilter/nf_nat.h>\n#endif\n\n#include <net/netfilter/nf_conntrack_act_ct.h>\n\n#include \"datapath.h\"\n#include \"drop.h\"\n#include \"conntrack.h\"\n#include \"flow.h\"\n#include \"flow_netlink.h\"\n\nstruct ovs_ct_len_tbl {\n\tint maxlen;\n\tint minlen;\n};\n\n \nstruct md_mark {\n\tu32 value;\n\tu32 mask;\n};\n\n \nstruct md_labels {\n\tstruct ovs_key_ct_labels value;\n\tstruct ovs_key_ct_labels mask;\n};\n\nenum ovs_ct_nat {\n\tOVS_CT_NAT = 1 << 0,      \n\tOVS_CT_SRC_NAT = 1 << 1,  \n\tOVS_CT_DST_NAT = 1 << 2,  \n};\n\n \nstruct ovs_conntrack_info {\n\tstruct nf_conntrack_helper *helper;\n\tstruct nf_conntrack_zone zone;\n\tstruct nf_conn *ct;\n\tu8 commit : 1;\n\tu8 nat : 3;                  \n\tu8 force : 1;\n\tu8 have_eventmask : 1;\n\tu16 family;\n\tu32 eventmask;               \n\tstruct md_mark mark;\n\tstruct md_labels labels;\n\tchar timeout[CTNL_TIMEOUT_NAME_MAX];\n\tstruct nf_ct_timeout *nf_ct_timeout;\n#if IS_ENABLED(CONFIG_NF_NAT)\n\tstruct nf_nat_range2 range;   \n#endif\n};\n\n#if\tIS_ENABLED(CONFIG_NETFILTER_CONNCOUNT)\n#define OVS_CT_LIMIT_UNLIMITED\t0\n#define OVS_CT_LIMIT_DEFAULT OVS_CT_LIMIT_UNLIMITED\n#define CT_LIMIT_HASH_BUCKETS 512\nstatic DEFINE_STATIC_KEY_FALSE(ovs_ct_limit_enabled);\n\nstruct ovs_ct_limit {\n\t \n\tstruct hlist_node hlist_node;\n\tstruct rcu_head rcu;\n\tu16 zone;\n\tu32 limit;\n};\n\nstruct ovs_ct_limit_info {\n\tu32 default_limit;\n\tstruct hlist_head *limits;\n\tstruct nf_conncount_data *data;\n};\n\nstatic const struct nla_policy ct_limit_policy[OVS_CT_LIMIT_ATTR_MAX + 1] = {\n\t[OVS_CT_LIMIT_ATTR_ZONE_LIMIT] = { .type = NLA_NESTED, },\n};\n#endif\n\nstatic bool labels_nonzero(const struct ovs_key_ct_labels *labels);\n\nstatic void __ovs_ct_free_action(struct ovs_conntrack_info *ct_info);\n\nstatic u16 key_to_nfproto(const struct sw_flow_key *key)\n{\n\tswitch (ntohs(key->eth.type)) {\n\tcase ETH_P_IP:\n\t\treturn NFPROTO_IPV4;\n\tcase ETH_P_IPV6:\n\t\treturn NFPROTO_IPV6;\n\tdefault:\n\t\treturn NFPROTO_UNSPEC;\n\t}\n}\n\n \nstatic u8 ovs_ct_get_state(enum ip_conntrack_info ctinfo)\n{\n\tu8 ct_state = OVS_CS_F_TRACKED;\n\n\tswitch (ctinfo) {\n\tcase IP_CT_ESTABLISHED_REPLY:\n\tcase IP_CT_RELATED_REPLY:\n\t\tct_state |= OVS_CS_F_REPLY_DIR;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (ctinfo) {\n\tcase IP_CT_ESTABLISHED:\n\tcase IP_CT_ESTABLISHED_REPLY:\n\t\tct_state |= OVS_CS_F_ESTABLISHED;\n\t\tbreak;\n\tcase IP_CT_RELATED:\n\tcase IP_CT_RELATED_REPLY:\n\t\tct_state |= OVS_CS_F_RELATED;\n\t\tbreak;\n\tcase IP_CT_NEW:\n\t\tct_state |= OVS_CS_F_NEW;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ct_state;\n}\n\nstatic u32 ovs_ct_get_mark(const struct nf_conn *ct)\n{\n#if IS_ENABLED(CONFIG_NF_CONNTRACK_MARK)\n\treturn ct ? READ_ONCE(ct->mark) : 0;\n#else\n\treturn 0;\n#endif\n}\n\n \n#if NF_CT_LABELS_MAX_SIZE < 16\n#error NF_CT_LABELS_MAX_SIZE must be at least 16 bytes\n#endif\n\nstatic void ovs_ct_get_labels(const struct nf_conn *ct,\n\t\t\t      struct ovs_key_ct_labels *labels)\n{\n\tstruct nf_conn_labels *cl = ct ? nf_ct_labels_find(ct) : NULL;\n\n\tif (cl)\n\t\tmemcpy(labels, cl->bits, OVS_CT_LABELS_LEN);\n\telse\n\t\tmemset(labels, 0, OVS_CT_LABELS_LEN);\n}\n\nstatic void __ovs_ct_update_key_orig_tp(struct sw_flow_key *key,\n\t\t\t\t\tconst struct nf_conntrack_tuple *orig,\n\t\t\t\t\tu8 icmp_proto)\n{\n\tkey->ct_orig_proto = orig->dst.protonum;\n\tif (orig->dst.protonum == icmp_proto) {\n\t\tkey->ct.orig_tp.src = htons(orig->dst.u.icmp.type);\n\t\tkey->ct.orig_tp.dst = htons(orig->dst.u.icmp.code);\n\t} else {\n\t\tkey->ct.orig_tp.src = orig->src.u.all;\n\t\tkey->ct.orig_tp.dst = orig->dst.u.all;\n\t}\n}\n\nstatic void __ovs_ct_update_key(struct sw_flow_key *key, u8 state,\n\t\t\t\tconst struct nf_conntrack_zone *zone,\n\t\t\t\tconst struct nf_conn *ct)\n{\n\tkey->ct_state = state;\n\tkey->ct_zone = zone->id;\n\tkey->ct.mark = ovs_ct_get_mark(ct);\n\tovs_ct_get_labels(ct, &key->ct.labels);\n\n\tif (ct) {\n\t\tconst struct nf_conntrack_tuple *orig;\n\n\t\t \n\t\tif (ct->master)\n\t\t\tct = ct->master;\n\t\torig = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\n\n\t\t \n\t\tif (key->eth.type == htons(ETH_P_IP) &&\n\t\t    nf_ct_l3num(ct) == NFPROTO_IPV4) {\n\t\t\tkey->ipv4.ct_orig.src = orig->src.u3.ip;\n\t\t\tkey->ipv4.ct_orig.dst = orig->dst.u3.ip;\n\t\t\t__ovs_ct_update_key_orig_tp(key, orig, IPPROTO_ICMP);\n\t\t\treturn;\n\t\t} else if (key->eth.type == htons(ETH_P_IPV6) &&\n\t\t\t   !sw_flow_key_is_nd(key) &&\n\t\t\t   nf_ct_l3num(ct) == NFPROTO_IPV6) {\n\t\t\tkey->ipv6.ct_orig.src = orig->src.u3.in6;\n\t\t\tkey->ipv6.ct_orig.dst = orig->dst.u3.in6;\n\t\t\t__ovs_ct_update_key_orig_tp(key, orig, NEXTHDR_ICMP);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tkey->ct_orig_proto = 0;\n}\n\n \nstatic void ovs_ct_update_key(const struct sk_buff *skb,\n\t\t\t      const struct ovs_conntrack_info *info,\n\t\t\t      struct sw_flow_key *key, bool post_ct,\n\t\t\t      bool keep_nat_flags)\n{\n\tconst struct nf_conntrack_zone *zone = &nf_ct_zone_dflt;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\tu8 state = 0;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct) {\n\t\tstate = ovs_ct_get_state(ctinfo);\n\t\t \n\t\tif (!nf_ct_is_confirmed(ct))\n\t\t\tstate |= OVS_CS_F_NEW;\n\t\t \n\t\tif (ct->master)\n\t\t\tstate |= OVS_CS_F_RELATED;\n\t\tif (keep_nat_flags) {\n\t\t\tstate |= key->ct_state & OVS_CS_F_NAT_MASK;\n\t\t} else {\n\t\t\tif (ct->status & IPS_SRC_NAT)\n\t\t\t\tstate |= OVS_CS_F_SRC_NAT;\n\t\t\tif (ct->status & IPS_DST_NAT)\n\t\t\t\tstate |= OVS_CS_F_DST_NAT;\n\t\t}\n\t\tzone = nf_ct_zone(ct);\n\t} else if (post_ct) {\n\t\tstate = OVS_CS_F_TRACKED | OVS_CS_F_INVALID;\n\t\tif (info)\n\t\t\tzone = &info->zone;\n\t}\n\t__ovs_ct_update_key(key, state, zone, ct);\n}\n\n \nvoid ovs_ct_fill_key(const struct sk_buff *skb,\n\t\t     struct sw_flow_key *key,\n\t\t     bool post_ct)\n{\n\tovs_ct_update_key(skb, NULL, key, post_ct, false);\n}\n\nint ovs_ct_put_key(const struct sw_flow_key *swkey,\n\t\t   const struct sw_flow_key *output, struct sk_buff *skb)\n{\n\tif (nla_put_u32(skb, OVS_KEY_ATTR_CT_STATE, output->ct_state))\n\t\treturn -EMSGSIZE;\n\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_ZONES) &&\n\t    nla_put_u16(skb, OVS_KEY_ATTR_CT_ZONE, output->ct_zone))\n\t\treturn -EMSGSIZE;\n\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_MARK) &&\n\t    nla_put_u32(skb, OVS_KEY_ATTR_CT_MARK, output->ct.mark))\n\t\treturn -EMSGSIZE;\n\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_LABELS) &&\n\t    nla_put(skb, OVS_KEY_ATTR_CT_LABELS, sizeof(output->ct.labels),\n\t\t    &output->ct.labels))\n\t\treturn -EMSGSIZE;\n\n\tif (swkey->ct_orig_proto) {\n\t\tif (swkey->eth.type == htons(ETH_P_IP)) {\n\t\t\tstruct ovs_key_ct_tuple_ipv4 orig;\n\n\t\t\tmemset(&orig, 0, sizeof(orig));\n\t\t\torig.ipv4_src = output->ipv4.ct_orig.src;\n\t\t\torig.ipv4_dst = output->ipv4.ct_orig.dst;\n\t\t\torig.src_port = output->ct.orig_tp.src;\n\t\t\torig.dst_port = output->ct.orig_tp.dst;\n\t\t\torig.ipv4_proto = output->ct_orig_proto;\n\n\t\t\tif (nla_put(skb, OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4,\n\t\t\t\t    sizeof(orig), &orig))\n\t\t\t\treturn -EMSGSIZE;\n\t\t} else if (swkey->eth.type == htons(ETH_P_IPV6)) {\n\t\t\tstruct ovs_key_ct_tuple_ipv6 orig;\n\n\t\t\tmemset(&orig, 0, sizeof(orig));\n\t\t\tmemcpy(orig.ipv6_src, output->ipv6.ct_orig.src.s6_addr32,\n\t\t\t       sizeof(orig.ipv6_src));\n\t\t\tmemcpy(orig.ipv6_dst, output->ipv6.ct_orig.dst.s6_addr32,\n\t\t\t       sizeof(orig.ipv6_dst));\n\t\t\torig.src_port = output->ct.orig_tp.src;\n\t\t\torig.dst_port = output->ct.orig_tp.dst;\n\t\t\torig.ipv6_proto = output->ct_orig_proto;\n\n\t\t\tif (nla_put(skb, OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6,\n\t\t\t\t    sizeof(orig), &orig))\n\t\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ovs_ct_set_mark(struct nf_conn *ct, struct sw_flow_key *key,\n\t\t\t   u32 ct_mark, u32 mask)\n{\n#if IS_ENABLED(CONFIG_NF_CONNTRACK_MARK)\n\tu32 new_mark;\n\n\tnew_mark = ct_mark | (READ_ONCE(ct->mark) & ~(mask));\n\tif (READ_ONCE(ct->mark) != new_mark) {\n\t\tWRITE_ONCE(ct->mark, new_mark);\n\t\tif (nf_ct_is_confirmed(ct))\n\t\t\tnf_conntrack_event_cache(IPCT_MARK, ct);\n\t\tkey->ct.mark = new_mark;\n\t}\n\n\treturn 0;\n#else\n\treturn -ENOTSUPP;\n#endif\n}\n\nstatic struct nf_conn_labels *ovs_ct_get_conn_labels(struct nf_conn *ct)\n{\n\tstruct nf_conn_labels *cl;\n\n\tcl = nf_ct_labels_find(ct);\n\tif (!cl) {\n\t\tnf_ct_labels_ext_add(ct);\n\t\tcl = nf_ct_labels_find(ct);\n\t}\n\n\treturn cl;\n}\n\n \nstatic int ovs_ct_init_labels(struct nf_conn *ct, struct sw_flow_key *key,\n\t\t\t      const struct ovs_key_ct_labels *labels,\n\t\t\t      const struct ovs_key_ct_labels *mask)\n{\n\tstruct nf_conn_labels *cl, *master_cl;\n\tbool have_mask = labels_nonzero(mask);\n\n\t \n\tmaster_cl = ct->master ? nf_ct_labels_find(ct->master) : NULL;\n\n\tif (!master_cl && !have_mask)\n\t\treturn 0;    \n\n\tcl = ovs_ct_get_conn_labels(ct);\n\tif (!cl)\n\t\treturn -ENOSPC;\n\n\t \n\tif (master_cl)\n\t\t*cl = *master_cl;\n\n\tif (have_mask) {\n\t\tu32 *dst = (u32 *)cl->bits;\n\t\tint i;\n\n\t\tfor (i = 0; i < OVS_CT_LABELS_LEN_32; i++)\n\t\t\tdst[i] = (dst[i] & ~mask->ct_labels_32[i]) |\n\t\t\t\t(labels->ct_labels_32[i]\n\t\t\t\t & mask->ct_labels_32[i]);\n\t}\n\n\t \n\tnf_conntrack_event_cache(IPCT_LABEL, ct);\n\n\tmemcpy(&key->ct.labels, cl->bits, OVS_CT_LABELS_LEN);\n\n\treturn 0;\n}\n\nstatic int ovs_ct_set_labels(struct nf_conn *ct, struct sw_flow_key *key,\n\t\t\t     const struct ovs_key_ct_labels *labels,\n\t\t\t     const struct ovs_key_ct_labels *mask)\n{\n\tstruct nf_conn_labels *cl;\n\tint err;\n\n\tcl = ovs_ct_get_conn_labels(ct);\n\tif (!cl)\n\t\treturn -ENOSPC;\n\n\terr = nf_connlabels_replace(ct, labels->ct_labels_32,\n\t\t\t\t    mask->ct_labels_32,\n\t\t\t\t    OVS_CT_LABELS_LEN_32);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(&key->ct.labels, cl->bits, OVS_CT_LABELS_LEN);\n\n\treturn 0;\n}\n\nstatic int ovs_ct_handle_fragments(struct net *net, struct sw_flow_key *key,\n\t\t\t\t   u16 zone, int family, struct sk_buff *skb)\n{\n\tstruct ovs_skb_cb ovs_cb = *OVS_CB(skb);\n\tint err;\n\n\terr = nf_ct_handle_fragments(net, skb, zone, family, &key->ip.proto, &ovs_cb.mru);\n\tif (err)\n\t\treturn err;\n\n\t \n\tovs_flow_key_update_l3l4(skb, key);\n\tkey->ip.frag = OVS_FRAG_TYPE_NONE;\n\t*OVS_CB(skb) = ovs_cb;\n\n\treturn 0;\n}\n\n \nstatic enum ip_conntrack_info\novs_ct_get_info(const struct nf_conntrack_tuple_hash *h)\n{\n\tconst struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);\n\n\tif (NF_CT_DIRECTION(h) == IP_CT_DIR_REPLY)\n\t\treturn IP_CT_ESTABLISHED_REPLY;\n\t \n\tif (test_bit(IPS_SEEN_REPLY_BIT, &ct->status))\n\t\treturn IP_CT_ESTABLISHED;\n\tif (test_bit(IPS_EXPECTED_BIT, &ct->status))\n\t\treturn IP_CT_RELATED;\n\treturn IP_CT_NEW;\n}\n\n \nstatic struct nf_conn *\novs_ct_find_existing(struct net *net, const struct nf_conntrack_zone *zone,\n\t\t     u8 l3num, struct sk_buff *skb, bool natted)\n{\n\tstruct nf_conntrack_tuple tuple;\n\tstruct nf_conntrack_tuple_hash *h;\n\tstruct nf_conn *ct;\n\n\tif (!nf_ct_get_tuplepr(skb, skb_network_offset(skb), l3num,\n\t\t\t       net, &tuple)) {\n\t\tpr_debug(\"ovs_ct_find_existing: Can't get tuple\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tif (natted) {\n\t\tstruct nf_conntrack_tuple inverse;\n\n\t\tif (!nf_ct_invert_tuple(&inverse, &tuple)) {\n\t\t\tpr_debug(\"ovs_ct_find_existing: Inversion failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\ttuple = inverse;\n\t}\n\n\t \n\th = nf_conntrack_find_get(net, zone, &tuple);\n\tif (!h)\n\t\treturn NULL;    \n\n\tct = nf_ct_tuplehash_to_ctrack(h);\n\n\t \n\tif (natted)\n\t\th = &ct->tuplehash[!h->tuple.dst.dir];\n\n\tnf_ct_set(skb, ct, ovs_ct_get_info(h));\n\treturn ct;\n}\n\nstatic\nstruct nf_conn *ovs_ct_executed(struct net *net,\n\t\t\t\tconst struct sw_flow_key *key,\n\t\t\t\tconst struct ovs_conntrack_info *info,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tbool *ct_executed)\n{\n\tstruct nf_conn *ct = NULL;\n\n\t \n\t*ct_executed = (key->ct_state & OVS_CS_F_TRACKED) &&\n\t\t       !(key->ct_state & OVS_CS_F_INVALID) &&\n\t\t       (key->ct_zone == info->zone.id);\n\n\tif (*ct_executed || (!key->ct_state && info->force)) {\n\t\tct = ovs_ct_find_existing(net, &info->zone, info->family, skb,\n\t\t\t\t\t  !!(key->ct_state &\n\t\t\t\t\t  OVS_CS_F_NAT_MASK));\n\t}\n\n\treturn ct;\n}\n\n \nstatic bool skb_nfct_cached(struct net *net,\n\t\t\t    const struct sw_flow_key *key,\n\t\t\t    const struct ovs_conntrack_info *info,\n\t\t\t    struct sk_buff *skb)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\tbool ct_executed = true;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (!ct)\n\t\tct = ovs_ct_executed(net, key, info, skb, &ct_executed);\n\n\tif (ct)\n\t\tnf_ct_get(skb, &ctinfo);\n\telse\n\t\treturn false;\n\n\tif (!net_eq(net, read_pnet(&ct->ct_net)))\n\t\treturn false;\n\tif (!nf_ct_zone_equal_any(info->ct, nf_ct_zone(ct)))\n\t\treturn false;\n\tif (info->helper) {\n\t\tstruct nf_conn_help *help;\n\n\t\thelp = nf_ct_ext_find(ct, NF_CT_EXT_HELPER);\n\t\tif (help && rcu_access_pointer(help->helper) != info->helper)\n\t\t\treturn false;\n\t}\n\tif (info->nf_ct_timeout) {\n\t\tstruct nf_conn_timeout *timeout_ext;\n\n\t\ttimeout_ext = nf_ct_timeout_find(ct);\n\t\tif (!timeout_ext || info->nf_ct_timeout !=\n\t\t    rcu_dereference(timeout_ext->timeout))\n\t\t\treturn false;\n\t}\n\t \n\tif (info->force && CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL) {\n\t\t \n\t\tif (nf_ct_is_confirmed(ct))\n\t\t\tnf_ct_delete(ct, 0, 0);\n\n\t\tnf_ct_put(ct);\n\t\tnf_ct_set(skb, NULL, 0);\n\t\treturn false;\n\t}\n\n\treturn ct_executed;\n}\n\n#if IS_ENABLED(CONFIG_NF_NAT)\nstatic void ovs_nat_update_key(struct sw_flow_key *key,\n\t\t\t       const struct sk_buff *skb,\n\t\t\t       enum nf_nat_manip_type maniptype)\n{\n\tif (maniptype == NF_NAT_MANIP_SRC) {\n\t\t__be16 src;\n\n\t\tkey->ct_state |= OVS_CS_F_SRC_NAT;\n\t\tif (key->eth.type == htons(ETH_P_IP))\n\t\t\tkey->ipv4.addr.src = ip_hdr(skb)->saddr;\n\t\telse if (key->eth.type == htons(ETH_P_IPV6))\n\t\t\tmemcpy(&key->ipv6.addr.src, &ipv6_hdr(skb)->saddr,\n\t\t\t       sizeof(key->ipv6.addr.src));\n\t\telse\n\t\t\treturn;\n\n\t\tif (key->ip.proto == IPPROTO_UDP)\n\t\t\tsrc = udp_hdr(skb)->source;\n\t\telse if (key->ip.proto == IPPROTO_TCP)\n\t\t\tsrc = tcp_hdr(skb)->source;\n\t\telse if (key->ip.proto == IPPROTO_SCTP)\n\t\t\tsrc = sctp_hdr(skb)->source;\n\t\telse\n\t\t\treturn;\n\n\t\tkey->tp.src = src;\n\t} else {\n\t\t__be16 dst;\n\n\t\tkey->ct_state |= OVS_CS_F_DST_NAT;\n\t\tif (key->eth.type == htons(ETH_P_IP))\n\t\t\tkey->ipv4.addr.dst = ip_hdr(skb)->daddr;\n\t\telse if (key->eth.type == htons(ETH_P_IPV6))\n\t\t\tmemcpy(&key->ipv6.addr.dst, &ipv6_hdr(skb)->daddr,\n\t\t\t       sizeof(key->ipv6.addr.dst));\n\t\telse\n\t\t\treturn;\n\n\t\tif (key->ip.proto == IPPROTO_UDP)\n\t\t\tdst = udp_hdr(skb)->dest;\n\t\telse if (key->ip.proto == IPPROTO_TCP)\n\t\t\tdst = tcp_hdr(skb)->dest;\n\t\telse if (key->ip.proto == IPPROTO_SCTP)\n\t\t\tdst = sctp_hdr(skb)->dest;\n\t\telse\n\t\t\treturn;\n\n\t\tkey->tp.dst = dst;\n\t}\n}\n\n \nstatic int ovs_ct_nat(struct net *net, struct sw_flow_key *key,\n\t\t      const struct ovs_conntrack_info *info,\n\t\t      struct sk_buff *skb, struct nf_conn *ct,\n\t\t      enum ip_conntrack_info ctinfo)\n{\n\tint err, action = 0;\n\n\tif (!(info->nat & OVS_CT_NAT))\n\t\treturn NF_ACCEPT;\n\tif (info->nat & OVS_CT_SRC_NAT)\n\t\taction |= BIT(NF_NAT_MANIP_SRC);\n\tif (info->nat & OVS_CT_DST_NAT)\n\t\taction |= BIT(NF_NAT_MANIP_DST);\n\n\terr = nf_ct_nat(skb, ct, ctinfo, &action, &info->range, info->commit);\n\n\tif (action & BIT(NF_NAT_MANIP_SRC))\n\t\tovs_nat_update_key(key, skb, NF_NAT_MANIP_SRC);\n\tif (action & BIT(NF_NAT_MANIP_DST))\n\t\tovs_nat_update_key(key, skb, NF_NAT_MANIP_DST);\n\n\treturn err;\n}\n#else  \nstatic int ovs_ct_nat(struct net *net, struct sw_flow_key *key,\n\t\t      const struct ovs_conntrack_info *info,\n\t\t      struct sk_buff *skb, struct nf_conn *ct,\n\t\t      enum ip_conntrack_info ctinfo)\n{\n\treturn NF_ACCEPT;\n}\n#endif\n\n \nstatic int __ovs_ct_lookup(struct net *net, struct sw_flow_key *key,\n\t\t\t   const struct ovs_conntrack_info *info,\n\t\t\t   struct sk_buff *skb)\n{\n\t \n\tbool cached = skb_nfct_cached(net, key, info, skb);\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tif (!cached) {\n\t\tstruct nf_hook_state state = {\n\t\t\t.hook = NF_INET_PRE_ROUTING,\n\t\t\t.pf = info->family,\n\t\t\t.net = net,\n\t\t};\n\t\tstruct nf_conn *tmpl = info->ct;\n\t\tint err;\n\n\t\t \n\t\tif (tmpl) {\n\t\t\tct = nf_ct_get(skb, &ctinfo);\n\t\t\tnf_ct_put(ct);\n\t\t\tnf_conntrack_get(&tmpl->ct_general);\n\t\t\tnf_ct_set(skb, tmpl, IP_CT_NEW);\n\t\t}\n\n\t\terr = nf_conntrack_in(skb, &state);\n\t\tif (err != NF_ACCEPT)\n\t\t\treturn -ENOENT;\n\n\t\t \n\t\tkey->ct_state = 0;\n\n\t\t \n\t\tovs_ct_update_key(skb, info, key, true, true);\n\t}\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct) {\n\t\tbool add_helper = false;\n\n\t\t \n\t\tif (info->nat && !(key->ct_state & OVS_CS_F_NAT_MASK) &&\n\t\t    (nf_ct_is_confirmed(ct) || info->commit) &&\n\t\t    ovs_ct_nat(net, key, info, skb, ct, ctinfo) != NF_ACCEPT) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!nf_ct_is_confirmed(ct) && info->commit &&\n\t\t    info->helper && !nfct_help(ct)) {\n\t\t\tint err = __nf_ct_try_assign_helper(ct, info->ct,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tadd_helper = true;\n\n\t\t\t \n\t\t\tif (info->nat && !nfct_seqadj(ct)) {\n\t\t\t\tif (!nfct_seqadj_ext_add(ct))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((nf_ct_is_confirmed(ct) ? !cached || add_helper :\n\t\t\t\t\t      info->commit) &&\n\t\t    nf_ct_helper(skb, ct, ctinfo, info->family) != NF_ACCEPT) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nf_ct_protonum(ct) == IPPROTO_TCP &&\n\t\t    nf_ct_is_confirmed(ct) && nf_conntrack_tcp_established(ct)) {\n\t\t\t \n\t\t\tnf_ct_set_tcp_be_liberal(ct);\n\t\t}\n\n\t\tnf_conn_act_ct_ext_fill(skb, ct, ctinfo);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ovs_ct_lookup(struct net *net, struct sw_flow_key *key,\n\t\t\t const struct ovs_conntrack_info *info,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct nf_conn *ct;\n\tint err;\n\n\terr = __ovs_ct_lookup(net, key, info, skb);\n\tif (err)\n\t\treturn err;\n\n\tct = (struct nf_conn *)skb_nfct(skb);\n\tif (ct)\n\t\tnf_ct_deliver_cached_events(ct);\n\n\treturn 0;\n}\n\nstatic bool labels_nonzero(const struct ovs_key_ct_labels *labels)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < OVS_CT_LABELS_LEN_32; i++)\n\t\tif (labels->ct_labels_32[i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\n#if\tIS_ENABLED(CONFIG_NETFILTER_CONNCOUNT)\nstatic struct hlist_head *ct_limit_hash_bucket(\n\tconst struct ovs_ct_limit_info *info, u16 zone)\n{\n\treturn &info->limits[zone & (CT_LIMIT_HASH_BUCKETS - 1)];\n}\n\n \nstatic void ct_limit_set(const struct ovs_ct_limit_info *info,\n\t\t\t struct ovs_ct_limit *new_ct_limit)\n{\n\tstruct ovs_ct_limit *ct_limit;\n\tstruct hlist_head *head;\n\n\thead = ct_limit_hash_bucket(info, new_ct_limit->zone);\n\thlist_for_each_entry_rcu(ct_limit, head, hlist_node) {\n\t\tif (ct_limit->zone == new_ct_limit->zone) {\n\t\t\thlist_replace_rcu(&ct_limit->hlist_node,\n\t\t\t\t\t  &new_ct_limit->hlist_node);\n\t\t\tkfree_rcu(ct_limit, rcu);\n\t\t\treturn;\n\t\t}\n\t}\n\n\thlist_add_head_rcu(&new_ct_limit->hlist_node, head);\n}\n\n \nstatic void ct_limit_del(const struct ovs_ct_limit_info *info, u16 zone)\n{\n\tstruct ovs_ct_limit *ct_limit;\n\tstruct hlist_head *head;\n\tstruct hlist_node *n;\n\n\thead = ct_limit_hash_bucket(info, zone);\n\thlist_for_each_entry_safe(ct_limit, n, head, hlist_node) {\n\t\tif (ct_limit->zone == zone) {\n\t\t\thlist_del_rcu(&ct_limit->hlist_node);\n\t\t\tkfree_rcu(ct_limit, rcu);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic u32 ct_limit_get(const struct ovs_ct_limit_info *info, u16 zone)\n{\n\tstruct ovs_ct_limit *ct_limit;\n\tstruct hlist_head *head;\n\n\thead = ct_limit_hash_bucket(info, zone);\n\thlist_for_each_entry_rcu(ct_limit, head, hlist_node) {\n\t\tif (ct_limit->zone == zone)\n\t\t\treturn ct_limit->limit;\n\t}\n\n\treturn info->default_limit;\n}\n\nstatic int ovs_ct_check_limit(struct net *net,\n\t\t\t      const struct ovs_conntrack_info *info,\n\t\t\t      const struct nf_conntrack_tuple *tuple)\n{\n\tstruct ovs_net *ovs_net = net_generic(net, ovs_net_id);\n\tconst struct ovs_ct_limit_info *ct_limit_info = ovs_net->ct_limit_info;\n\tu32 per_zone_limit, connections;\n\tu32 conncount_key;\n\n\tconncount_key = info->zone.id;\n\n\tper_zone_limit = ct_limit_get(ct_limit_info, info->zone.id);\n\tif (per_zone_limit == OVS_CT_LIMIT_UNLIMITED)\n\t\treturn 0;\n\n\tconnections = nf_conncount_count(net, ct_limit_info->data,\n\t\t\t\t\t &conncount_key, tuple, &info->zone);\n\tif (connections > per_zone_limit)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n#endif\n\n \nstatic int ovs_ct_commit(struct net *net, struct sw_flow_key *key,\n\t\t\t const struct ovs_conntrack_info *info,\n\t\t\t struct sk_buff *skb)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\tint err;\n\n\terr = __ovs_ct_lookup(net, key, info, skb);\n\tif (err)\n\t\treturn err;\n\n\t \n\tct = nf_ct_get(skb, &ctinfo);\n\tif (!ct)\n\t\treturn 0;\n\n#if\tIS_ENABLED(CONFIG_NETFILTER_CONNCOUNT)\n\tif (static_branch_unlikely(&ovs_ct_limit_enabled)) {\n\t\tif (!nf_ct_is_confirmed(ct)) {\n\t\t\terr = ovs_ct_check_limit(net, info,\n\t\t\t\t&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);\n\t\t\tif (err) {\n\t\t\t\tnet_warn_ratelimited(\"openvswitch: zone: %u \"\n\t\t\t\t\t\"exceeds conntrack limit\\n\",\n\t\t\t\t\tinfo->zone.id);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t \n\tif (info->have_eventmask) {\n\t\tstruct nf_conntrack_ecache *cache = nf_ct_ecache_find(ct);\n\n\t\tif (cache)\n\t\t\tcache->ctmask = info->eventmask;\n\t}\n\n\t \n\tif (info->mark.mask) {\n\t\terr = ovs_ct_set_mark(ct, key, info->mark.value,\n\t\t\t\t      info->mark.mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (!nf_ct_is_confirmed(ct)) {\n\t\terr = ovs_ct_init_labels(ct, key, &info->labels.value,\n\t\t\t\t\t &info->labels.mask);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnf_conn_act_ct_ext_add(skb, ct, ctinfo);\n\t} else if (IS_ENABLED(CONFIG_NF_CONNTRACK_LABELS) &&\n\t\t   labels_nonzero(&info->labels.mask)) {\n\t\terr = ovs_ct_set_labels(ct, key, &info->labels.value,\n\t\t\t\t\t&info->labels.mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t \n\tif (nf_conntrack_confirm(skb) != NF_ACCEPT)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint ovs_ct_execute(struct net *net, struct sk_buff *skb,\n\t\t   struct sw_flow_key *key,\n\t\t   const struct ovs_conntrack_info *info)\n{\n\tint nh_ofs;\n\tint err;\n\n\t \n\tnh_ofs = skb_network_offset(skb);\n\tskb_pull_rcsum(skb, nh_ofs);\n\n\terr = nf_ct_skb_network_trim(skb, info->family);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tif (key->ip.frag != OVS_FRAG_TYPE_NONE) {\n\t\terr = ovs_ct_handle_fragments(net, key, info->zone.id,\n\t\t\t\t\t      info->family, skb);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->commit)\n\t\terr = ovs_ct_commit(net, key, info, skb);\n\telse\n\t\terr = ovs_ct_lookup(net, key, info, skb);\n\n\tskb_push_rcsum(skb, nh_ofs);\n\tif (err)\n\t\tovs_kfree_skb_reason(skb, OVS_DROP_CONNTRACK);\n\treturn err;\n}\n\nint ovs_ct_clear(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\n\tnf_ct_put(ct);\n\tnf_ct_set(skb, NULL, IP_CT_UNTRACKED);\n\n\tif (key)\n\t\tovs_ct_fill_key(skb, key, false);\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_NF_NAT)\nstatic int parse_nat(const struct nlattr *attr,\n\t\t     struct ovs_conntrack_info *info, bool log)\n{\n\tstruct nlattr *a;\n\tint rem;\n\tbool have_ip_max = false;\n\tbool have_proto_max = false;\n\tbool ip_vers = (info->family == NFPROTO_IPV6);\n\n\tnla_for_each_nested(a, attr, rem) {\n\t\tstatic const int ovs_nat_attr_lens[OVS_NAT_ATTR_MAX + 1][2] = {\n\t\t\t[OVS_NAT_ATTR_SRC] = {0, 0},\n\t\t\t[OVS_NAT_ATTR_DST] = {0, 0},\n\t\t\t[OVS_NAT_ATTR_IP_MIN] = {sizeof(struct in_addr),\n\t\t\t\t\t\t sizeof(struct in6_addr)},\n\t\t\t[OVS_NAT_ATTR_IP_MAX] = {sizeof(struct in_addr),\n\t\t\t\t\t\t sizeof(struct in6_addr)},\n\t\t\t[OVS_NAT_ATTR_PROTO_MIN] = {sizeof(u16), sizeof(u16)},\n\t\t\t[OVS_NAT_ATTR_PROTO_MAX] = {sizeof(u16), sizeof(u16)},\n\t\t\t[OVS_NAT_ATTR_PERSISTENT] = {0, 0},\n\t\t\t[OVS_NAT_ATTR_PROTO_HASH] = {0, 0},\n\t\t\t[OVS_NAT_ATTR_PROTO_RANDOM] = {0, 0},\n\t\t};\n\t\tint type = nla_type(a);\n\n\t\tif (type > OVS_NAT_ATTR_MAX) {\n\t\t\tOVS_NLERR(log, \"Unknown NAT attribute (type=%d, max=%d)\",\n\t\t\t\t  type, OVS_NAT_ATTR_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nla_len(a) != ovs_nat_attr_lens[type][ip_vers]) {\n\t\t\tOVS_NLERR(log, \"NAT attribute type %d has unexpected length (%d != %d)\",\n\t\t\t\t  type, nla_len(a),\n\t\t\t\t  ovs_nat_attr_lens[type][ip_vers]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase OVS_NAT_ATTR_SRC:\n\t\tcase OVS_NAT_ATTR_DST:\n\t\t\tif (info->nat) {\n\t\t\t\tOVS_NLERR(log, \"Only one type of NAT may be specified\");\n\t\t\t\treturn -ERANGE;\n\t\t\t}\n\t\t\tinfo->nat |= OVS_CT_NAT;\n\t\t\tinfo->nat |= ((type == OVS_NAT_ATTR_SRC)\n\t\t\t\t\t? OVS_CT_SRC_NAT : OVS_CT_DST_NAT);\n\t\t\tbreak;\n\n\t\tcase OVS_NAT_ATTR_IP_MIN:\n\t\t\tnla_memcpy(&info->range.min_addr, a,\n\t\t\t\t   sizeof(info->range.min_addr));\n\t\t\tinfo->range.flags |= NF_NAT_RANGE_MAP_IPS;\n\t\t\tbreak;\n\n\t\tcase OVS_NAT_ATTR_IP_MAX:\n\t\t\thave_ip_max = true;\n\t\t\tnla_memcpy(&info->range.max_addr, a,\n\t\t\t\t   sizeof(info->range.max_addr));\n\t\t\tinfo->range.flags |= NF_NAT_RANGE_MAP_IPS;\n\t\t\tbreak;\n\n\t\tcase OVS_NAT_ATTR_PROTO_MIN:\n\t\t\tinfo->range.min_proto.all = htons(nla_get_u16(a));\n\t\t\tinfo->range.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\n\t\t\tbreak;\n\n\t\tcase OVS_NAT_ATTR_PROTO_MAX:\n\t\t\thave_proto_max = true;\n\t\t\tinfo->range.max_proto.all = htons(nla_get_u16(a));\n\t\t\tinfo->range.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\n\t\t\tbreak;\n\n\t\tcase OVS_NAT_ATTR_PERSISTENT:\n\t\t\tinfo->range.flags |= NF_NAT_RANGE_PERSISTENT;\n\t\t\tbreak;\n\n\t\tcase OVS_NAT_ATTR_PROTO_HASH:\n\t\t\tinfo->range.flags |= NF_NAT_RANGE_PROTO_RANDOM;\n\t\t\tbreak;\n\n\t\tcase OVS_NAT_ATTR_PROTO_RANDOM:\n\t\t\tinfo->range.flags |= NF_NAT_RANGE_PROTO_RANDOM_FULLY;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tOVS_NLERR(log, \"Unknown nat attribute (%d)\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (rem > 0) {\n\t\tOVS_NLERR(log, \"NAT attribute has %d unknown bytes\", rem);\n\t\treturn -EINVAL;\n\t}\n\tif (!info->nat) {\n\t\t \n\t\tif (info->range.flags) {\n\t\t\tOVS_NLERR(log,\n\t\t\t\t  \"NAT flags may be given only when NAT range (SRC or DST) is also specified.\"\n\t\t\t\t  );\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinfo->nat = OVS_CT_NAT;    \n\t} else if (!info->commit) {\n\t\tOVS_NLERR(log,\n\t\t\t  \"NAT attributes may be specified only when CT COMMIT flag is also specified.\"\n\t\t\t  );\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (info->range.flags & NF_NAT_RANGE_MAP_IPS && !have_ip_max) {\n\t\tmemcpy(&info->range.max_addr, &info->range.min_addr,\n\t\t       sizeof(info->range.max_addr));\n\t}\n\t \n\tif (info->range.flags & NF_NAT_RANGE_PROTO_SPECIFIED &&\n\t    !have_proto_max) {\n\t\tinfo->range.max_proto.all = info->range.min_proto.all;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic const struct ovs_ct_len_tbl ovs_ct_attr_lens[OVS_CT_ATTR_MAX + 1] = {\n\t[OVS_CT_ATTR_COMMIT]\t= { .minlen = 0, .maxlen = 0 },\n\t[OVS_CT_ATTR_FORCE_COMMIT]\t= { .minlen = 0, .maxlen = 0 },\n\t[OVS_CT_ATTR_ZONE]\t= { .minlen = sizeof(u16),\n\t\t\t\t    .maxlen = sizeof(u16) },\n\t[OVS_CT_ATTR_MARK]\t= { .minlen = sizeof(struct md_mark),\n\t\t\t\t    .maxlen = sizeof(struct md_mark) },\n\t[OVS_CT_ATTR_LABELS]\t= { .minlen = sizeof(struct md_labels),\n\t\t\t\t    .maxlen = sizeof(struct md_labels) },\n\t[OVS_CT_ATTR_HELPER]\t= { .minlen = 1,\n\t\t\t\t    .maxlen = NF_CT_HELPER_NAME_LEN },\n#if IS_ENABLED(CONFIG_NF_NAT)\n\t \n\t[OVS_CT_ATTR_NAT]\t= { .minlen = 0, .maxlen = INT_MAX },\n#endif\n\t[OVS_CT_ATTR_EVENTMASK]\t= { .minlen = sizeof(u32),\n\t\t\t\t    .maxlen = sizeof(u32) },\n\t[OVS_CT_ATTR_TIMEOUT] = { .minlen = 1,\n\t\t\t\t  .maxlen = CTNL_TIMEOUT_NAME_MAX },\n};\n\nstatic int parse_ct(const struct nlattr *attr, struct ovs_conntrack_info *info,\n\t\t    const char **helper, bool log)\n{\n\tstruct nlattr *a;\n\tint rem;\n\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\t\tint maxlen;\n\t\tint minlen;\n\n\t\tif (type > OVS_CT_ATTR_MAX) {\n\t\t\tOVS_NLERR(log,\n\t\t\t\t  \"Unknown conntrack attr (type=%d, max=%d)\",\n\t\t\t\t  type, OVS_CT_ATTR_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmaxlen = ovs_ct_attr_lens[type].maxlen;\n\t\tminlen = ovs_ct_attr_lens[type].minlen;\n\t\tif (nla_len(a) < minlen || nla_len(a) > maxlen) {\n\t\t\tOVS_NLERR(log,\n\t\t\t\t  \"Conntrack attr type has unexpected length (type=%d, length=%d, expected=%d)\",\n\t\t\t\t  type, nla_len(a), maxlen);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase OVS_CT_ATTR_FORCE_COMMIT:\n\t\t\tinfo->force = true;\n\t\t\tfallthrough;\n\t\tcase OVS_CT_ATTR_COMMIT:\n\t\t\tinfo->commit = true;\n\t\t\tbreak;\n#ifdef CONFIG_NF_CONNTRACK_ZONES\n\t\tcase OVS_CT_ATTR_ZONE:\n\t\t\tinfo->zone.id = nla_get_u16(a);\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\t\tcase OVS_CT_ATTR_MARK: {\n\t\t\tstruct md_mark *mark = nla_data(a);\n\n\t\t\tif (!mark->mask) {\n\t\t\t\tOVS_NLERR(log, \"ct_mark mask cannot be 0\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tinfo->mark = *mark;\n\t\t\tbreak;\n\t\t}\n#endif\n#ifdef CONFIG_NF_CONNTRACK_LABELS\n\t\tcase OVS_CT_ATTR_LABELS: {\n\t\t\tstruct md_labels *labels = nla_data(a);\n\n\t\t\tif (!labels_nonzero(&labels->mask)) {\n\t\t\t\tOVS_NLERR(log, \"ct_labels mask cannot be 0\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tinfo->labels = *labels;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tcase OVS_CT_ATTR_HELPER:\n\t\t\t*helper = nla_data(a);\n\t\t\tif (!string_is_terminated(*helper, nla_len(a))) {\n\t\t\t\tOVS_NLERR(log, \"Invalid conntrack helper\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_NF_NAT)\n\t\tcase OVS_CT_ATTR_NAT: {\n\t\t\tint err = parse_nat(a, info, log);\n\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tcase OVS_CT_ATTR_EVENTMASK:\n\t\t\tinfo->have_eventmask = true;\n\t\t\tinfo->eventmask = nla_get_u32(a);\n\t\t\tbreak;\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\n\t\tcase OVS_CT_ATTR_TIMEOUT:\n\t\t\tmemcpy(info->timeout, nla_data(a), nla_len(a));\n\t\t\tif (!string_is_terminated(info->timeout, nla_len(a))) {\n\t\t\t\tOVS_NLERR(log, \"Invalid conntrack timeout\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\tOVS_NLERR(log, \"Unknown conntrack attr (%d)\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n#ifdef CONFIG_NF_CONNTRACK_MARK\n\tif (!info->commit && info->mark.mask) {\n\t\tOVS_NLERR(log,\n\t\t\t  \"Setting conntrack mark requires 'commit' flag.\");\n\t\treturn -EINVAL;\n\t}\n#endif\n#ifdef CONFIG_NF_CONNTRACK_LABELS\n\tif (!info->commit && labels_nonzero(&info->labels.mask)) {\n\t\tOVS_NLERR(log,\n\t\t\t  \"Setting conntrack labels requires 'commit' flag.\");\n\t\treturn -EINVAL;\n\t}\n#endif\n\tif (rem > 0) {\n\t\tOVS_NLERR(log, \"Conntrack attr has %d unknown bytes\", rem);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nbool ovs_ct_verify(struct net *net, enum ovs_key_attr attr)\n{\n\tif (attr == OVS_KEY_ATTR_CT_STATE)\n\t\treturn true;\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_ZONES) &&\n\t    attr == OVS_KEY_ATTR_CT_ZONE)\n\t\treturn true;\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_MARK) &&\n\t    attr == OVS_KEY_ATTR_CT_MARK)\n\t\treturn true;\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_LABELS) &&\n\t    attr == OVS_KEY_ATTR_CT_LABELS) {\n\t\tstruct ovs_net *ovs_net = net_generic(net, ovs_net_id);\n\n\t\treturn ovs_net->xt_label;\n\t}\n\n\treturn false;\n}\n\nint ovs_ct_copy_action(struct net *net, const struct nlattr *attr,\n\t\t       const struct sw_flow_key *key,\n\t\t       struct sw_flow_actions **sfa,  bool log)\n{\n\tstruct ovs_conntrack_info ct_info;\n\tconst char *helper = NULL;\n\tu16 family;\n\tint err;\n\n\tfamily = key_to_nfproto(key);\n\tif (family == NFPROTO_UNSPEC) {\n\t\tOVS_NLERR(log, \"ct family unspecified\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&ct_info, 0, sizeof(ct_info));\n\tct_info.family = family;\n\n\tnf_ct_zone_init(&ct_info.zone, NF_CT_DEFAULT_ZONE_ID,\n\t\t\tNF_CT_DEFAULT_ZONE_DIR, 0);\n\n\terr = parse_ct(attr, &ct_info, &helper, log);\n\tif (err)\n\t\treturn err;\n\n\t \n\tct_info.ct = nf_ct_tmpl_alloc(net, &ct_info.zone, GFP_KERNEL);\n\tif (!ct_info.ct) {\n\t\tOVS_NLERR(log, \"Failed to allocate conntrack template\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (ct_info.timeout[0]) {\n\t\tif (nf_ct_set_timeout(net, ct_info.ct, family, key->ip.proto,\n\t\t\t\t      ct_info.timeout))\n\t\t\tpr_info_ratelimited(\"Failed to associated timeout \"\n\t\t\t\t\t    \"policy `%s'\\n\", ct_info.timeout);\n\t\telse\n\t\t\tct_info.nf_ct_timeout = rcu_dereference(\n\t\t\t\tnf_ct_timeout_find(ct_info.ct)->timeout);\n\n\t}\n\n\tif (helper) {\n\t\terr = nf_ct_add_helper(ct_info.ct, helper, ct_info.family,\n\t\t\t\t       key->ip.proto, ct_info.nat, &ct_info.helper);\n\t\tif (err) {\n\t\t\tOVS_NLERR(log, \"Failed to add %s helper %d\", helper, err);\n\t\t\tgoto err_free_ct;\n\t\t}\n\t}\n\n\terr = ovs_nla_add_action(sfa, OVS_ACTION_ATTR_CT, &ct_info,\n\t\t\t\t sizeof(ct_info), log);\n\tif (err)\n\t\tgoto err_free_ct;\n\n\tif (ct_info.commit)\n\t\t__set_bit(IPS_CONFIRMED_BIT, &ct_info.ct->status);\n\treturn 0;\nerr_free_ct:\n\t__ovs_ct_free_action(&ct_info);\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_NF_NAT)\nstatic bool ovs_ct_nat_to_attr(const struct ovs_conntrack_info *info,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct nlattr *start;\n\n\tstart = nla_nest_start_noflag(skb, OVS_CT_ATTR_NAT);\n\tif (!start)\n\t\treturn false;\n\n\tif (info->nat & OVS_CT_SRC_NAT) {\n\t\tif (nla_put_flag(skb, OVS_NAT_ATTR_SRC))\n\t\t\treturn false;\n\t} else if (info->nat & OVS_CT_DST_NAT) {\n\t\tif (nla_put_flag(skb, OVS_NAT_ATTR_DST))\n\t\t\treturn false;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (info->range.flags & NF_NAT_RANGE_MAP_IPS) {\n\t\tif (IS_ENABLED(CONFIG_NF_NAT) &&\n\t\t    info->family == NFPROTO_IPV4) {\n\t\t\tif (nla_put_in_addr(skb, OVS_NAT_ATTR_IP_MIN,\n\t\t\t\t\t    info->range.min_addr.ip) ||\n\t\t\t    (info->range.max_addr.ip\n\t\t\t     != info->range.min_addr.ip &&\n\t\t\t     (nla_put_in_addr(skb, OVS_NAT_ATTR_IP_MAX,\n\t\t\t\t\t      info->range.max_addr.ip))))\n\t\t\t\treturn false;\n\t\t} else if (IS_ENABLED(CONFIG_IPV6) &&\n\t\t\t   info->family == NFPROTO_IPV6) {\n\t\t\tif (nla_put_in6_addr(skb, OVS_NAT_ATTR_IP_MIN,\n\t\t\t\t\t     &info->range.min_addr.in6) ||\n\t\t\t    (memcmp(&info->range.max_addr.in6,\n\t\t\t\t    &info->range.min_addr.in6,\n\t\t\t\t    sizeof(info->range.max_addr.in6)) &&\n\t\t\t     (nla_put_in6_addr(skb, OVS_NAT_ATTR_IP_MAX,\n\t\t\t\t\t       &info->range.max_addr.in6))))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (info->range.flags & NF_NAT_RANGE_PROTO_SPECIFIED &&\n\t    (nla_put_u16(skb, OVS_NAT_ATTR_PROTO_MIN,\n\t\t\t ntohs(info->range.min_proto.all)) ||\n\t     (info->range.max_proto.all != info->range.min_proto.all &&\n\t      nla_put_u16(skb, OVS_NAT_ATTR_PROTO_MAX,\n\t\t\t  ntohs(info->range.max_proto.all)))))\n\t\treturn false;\n\n\tif (info->range.flags & NF_NAT_RANGE_PERSISTENT &&\n\t    nla_put_flag(skb, OVS_NAT_ATTR_PERSISTENT))\n\t\treturn false;\n\tif (info->range.flags & NF_NAT_RANGE_PROTO_RANDOM &&\n\t    nla_put_flag(skb, OVS_NAT_ATTR_PROTO_HASH))\n\t\treturn false;\n\tif (info->range.flags & NF_NAT_RANGE_PROTO_RANDOM_FULLY &&\n\t    nla_put_flag(skb, OVS_NAT_ATTR_PROTO_RANDOM))\n\t\treturn false;\nout:\n\tnla_nest_end(skb, start);\n\n\treturn true;\n}\n#endif\n\nint ovs_ct_action_to_attr(const struct ovs_conntrack_info *ct_info,\n\t\t\t  struct sk_buff *skb)\n{\n\tstruct nlattr *start;\n\n\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_CT);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\tif (ct_info->commit && nla_put_flag(skb, ct_info->force\n\t\t\t\t\t    ? OVS_CT_ATTR_FORCE_COMMIT\n\t\t\t\t\t    : OVS_CT_ATTR_COMMIT))\n\t\treturn -EMSGSIZE;\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_ZONES) &&\n\t    nla_put_u16(skb, OVS_CT_ATTR_ZONE, ct_info->zone.id))\n\t\treturn -EMSGSIZE;\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_MARK) && ct_info->mark.mask &&\n\t    nla_put(skb, OVS_CT_ATTR_MARK, sizeof(ct_info->mark),\n\t\t    &ct_info->mark))\n\t\treturn -EMSGSIZE;\n\tif (IS_ENABLED(CONFIG_NF_CONNTRACK_LABELS) &&\n\t    labels_nonzero(&ct_info->labels.mask) &&\n\t    nla_put(skb, OVS_CT_ATTR_LABELS, sizeof(ct_info->labels),\n\t\t    &ct_info->labels))\n\t\treturn -EMSGSIZE;\n\tif (ct_info->helper) {\n\t\tif (nla_put_string(skb, OVS_CT_ATTR_HELPER,\n\t\t\t\t   ct_info->helper->name))\n\t\t\treturn -EMSGSIZE;\n\t}\n\tif (ct_info->have_eventmask &&\n\t    nla_put_u32(skb, OVS_CT_ATTR_EVENTMASK, ct_info->eventmask))\n\t\treturn -EMSGSIZE;\n\tif (ct_info->timeout[0]) {\n\t\tif (nla_put_string(skb, OVS_CT_ATTR_TIMEOUT, ct_info->timeout))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n#if IS_ENABLED(CONFIG_NF_NAT)\n\tif (ct_info->nat && !ovs_ct_nat_to_attr(ct_info, skb))\n\t\treturn -EMSGSIZE;\n#endif\n\tnla_nest_end(skb, start);\n\n\treturn 0;\n}\n\nvoid ovs_ct_free_action(const struct nlattr *a)\n{\n\tstruct ovs_conntrack_info *ct_info = nla_data(a);\n\n\t__ovs_ct_free_action(ct_info);\n}\n\nstatic void __ovs_ct_free_action(struct ovs_conntrack_info *ct_info)\n{\n\tif (ct_info->helper) {\n#if IS_ENABLED(CONFIG_NF_NAT)\n\t\tif (ct_info->nat)\n\t\t\tnf_nat_helper_put(ct_info->helper);\n#endif\n\t\tnf_conntrack_helper_put(ct_info->helper);\n\t}\n\tif (ct_info->ct) {\n\t\tif (ct_info->timeout[0])\n\t\t\tnf_ct_destroy_timeout(ct_info->ct);\n\t\tnf_ct_tmpl_free(ct_info->ct);\n\t}\n}\n\n#if\tIS_ENABLED(CONFIG_NETFILTER_CONNCOUNT)\nstatic int ovs_ct_limit_init(struct net *net, struct ovs_net *ovs_net)\n{\n\tint i, err;\n\n\tovs_net->ct_limit_info = kmalloc(sizeof(*ovs_net->ct_limit_info),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ovs_net->ct_limit_info)\n\t\treturn -ENOMEM;\n\n\tovs_net->ct_limit_info->default_limit = OVS_CT_LIMIT_DEFAULT;\n\tovs_net->ct_limit_info->limits =\n\t\tkmalloc_array(CT_LIMIT_HASH_BUCKETS, sizeof(struct hlist_head),\n\t\t\t      GFP_KERNEL);\n\tif (!ovs_net->ct_limit_info->limits) {\n\t\tkfree(ovs_net->ct_limit_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < CT_LIMIT_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(&ovs_net->ct_limit_info->limits[i]);\n\n\tovs_net->ct_limit_info->data =\n\t\tnf_conncount_init(net, NFPROTO_INET, sizeof(u32));\n\n\tif (IS_ERR(ovs_net->ct_limit_info->data)) {\n\t\terr = PTR_ERR(ovs_net->ct_limit_info->data);\n\t\tkfree(ovs_net->ct_limit_info->limits);\n\t\tkfree(ovs_net->ct_limit_info);\n\t\tpr_err(\"openvswitch: failed to init nf_conncount %d\\n\", err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void ovs_ct_limit_exit(struct net *net, struct ovs_net *ovs_net)\n{\n\tconst struct ovs_ct_limit_info *info = ovs_net->ct_limit_info;\n\tint i;\n\n\tnf_conncount_destroy(net, NFPROTO_INET, info->data);\n\tfor (i = 0; i < CT_LIMIT_HASH_BUCKETS; ++i) {\n\t\tstruct hlist_head *head = &info->limits[i];\n\t\tstruct ovs_ct_limit *ct_limit;\n\n\t\thlist_for_each_entry_rcu(ct_limit, head, hlist_node,\n\t\t\t\t\t lockdep_ovsl_is_held())\n\t\t\tkfree_rcu(ct_limit, rcu);\n\t}\n\tkfree(info->limits);\n\tkfree(info);\n}\n\nstatic struct sk_buff *\novs_ct_limit_cmd_reply_start(struct genl_info *info, u8 cmd,\n\t\t\t     struct ovs_header **ovs_reply_header)\n{\n\tstruct ovs_header *ovs_header = genl_info_userhdr(info);\n\tstruct sk_buff *skb;\n\n\tskb = genlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t*ovs_reply_header = genlmsg_put(skb, info->snd_portid,\n\t\t\t\t\tinfo->snd_seq,\n\t\t\t\t\t&dp_ct_limit_genl_family, 0, cmd);\n\n\tif (!*ovs_reply_header) {\n\t\tnlmsg_free(skb);\n\t\treturn ERR_PTR(-EMSGSIZE);\n\t}\n\t(*ovs_reply_header)->dp_ifindex = ovs_header->dp_ifindex;\n\n\treturn skb;\n}\n\nstatic bool check_zone_id(int zone_id, u16 *pzone)\n{\n\tif (zone_id >= 0 && zone_id <= 65535) {\n\t\t*pzone = (u16)zone_id;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int ovs_ct_limit_set_zone_limit(struct nlattr *nla_zone_limit,\n\t\t\t\t       struct ovs_ct_limit_info *info)\n{\n\tstruct ovs_zone_limit *zone_limit;\n\tint rem;\n\tu16 zone;\n\n\trem = NLA_ALIGN(nla_len(nla_zone_limit));\n\tzone_limit = (struct ovs_zone_limit *)nla_data(nla_zone_limit);\n\n\twhile (rem >= sizeof(*zone_limit)) {\n\t\tif (unlikely(zone_limit->zone_id ==\n\t\t\t\tOVS_ZONE_LIMIT_DEFAULT_ZONE)) {\n\t\t\tovs_lock();\n\t\t\tinfo->default_limit = zone_limit->limit;\n\t\t\tovs_unlock();\n\t\t} else if (unlikely(!check_zone_id(\n\t\t\t\tzone_limit->zone_id, &zone))) {\n\t\t\tOVS_NLERR(true, \"zone id is out of range\");\n\t\t} else {\n\t\t\tstruct ovs_ct_limit *ct_limit;\n\n\t\t\tct_limit = kmalloc(sizeof(*ct_limit),\n\t\t\t\t\t   GFP_KERNEL_ACCOUNT);\n\t\t\tif (!ct_limit)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tct_limit->zone = zone;\n\t\t\tct_limit->limit = zone_limit->limit;\n\n\t\t\tovs_lock();\n\t\t\tct_limit_set(info, ct_limit);\n\t\t\tovs_unlock();\n\t\t}\n\t\trem -= NLA_ALIGN(sizeof(*zone_limit));\n\t\tzone_limit = (struct ovs_zone_limit *)((u8 *)zone_limit +\n\t\t\t\tNLA_ALIGN(sizeof(*zone_limit)));\n\t}\n\n\tif (rem)\n\t\tOVS_NLERR(true, \"set zone limit has %d unknown bytes\", rem);\n\n\treturn 0;\n}\n\nstatic int ovs_ct_limit_del_zone_limit(struct nlattr *nla_zone_limit,\n\t\t\t\t       struct ovs_ct_limit_info *info)\n{\n\tstruct ovs_zone_limit *zone_limit;\n\tint rem;\n\tu16 zone;\n\n\trem = NLA_ALIGN(nla_len(nla_zone_limit));\n\tzone_limit = (struct ovs_zone_limit *)nla_data(nla_zone_limit);\n\n\twhile (rem >= sizeof(*zone_limit)) {\n\t\tif (unlikely(zone_limit->zone_id ==\n\t\t\t\tOVS_ZONE_LIMIT_DEFAULT_ZONE)) {\n\t\t\tovs_lock();\n\t\t\tinfo->default_limit = OVS_CT_LIMIT_DEFAULT;\n\t\t\tovs_unlock();\n\t\t} else if (unlikely(!check_zone_id(\n\t\t\t\tzone_limit->zone_id, &zone))) {\n\t\t\tOVS_NLERR(true, \"zone id is out of range\");\n\t\t} else {\n\t\t\tovs_lock();\n\t\t\tct_limit_del(info, zone);\n\t\t\tovs_unlock();\n\t\t}\n\t\trem -= NLA_ALIGN(sizeof(*zone_limit));\n\t\tzone_limit = (struct ovs_zone_limit *)((u8 *)zone_limit +\n\t\t\t\tNLA_ALIGN(sizeof(*zone_limit)));\n\t}\n\n\tif (rem)\n\t\tOVS_NLERR(true, \"del zone limit has %d unknown bytes\", rem);\n\n\treturn 0;\n}\n\nstatic int ovs_ct_limit_get_default_limit(struct ovs_ct_limit_info *info,\n\t\t\t\t\t  struct sk_buff *reply)\n{\n\tstruct ovs_zone_limit zone_limit = {\n\t\t.zone_id = OVS_ZONE_LIMIT_DEFAULT_ZONE,\n\t\t.limit   = info->default_limit,\n\t};\n\n\treturn nla_put_nohdr(reply, sizeof(zone_limit), &zone_limit);\n}\n\nstatic int __ovs_ct_limit_get_zone_limit(struct net *net,\n\t\t\t\t\t struct nf_conncount_data *data,\n\t\t\t\t\t u16 zone_id, u32 limit,\n\t\t\t\t\t struct sk_buff *reply)\n{\n\tstruct nf_conntrack_zone ct_zone;\n\tstruct ovs_zone_limit zone_limit;\n\tu32 conncount_key = zone_id;\n\n\tzone_limit.zone_id = zone_id;\n\tzone_limit.limit = limit;\n\tnf_ct_zone_init(&ct_zone, zone_id, NF_CT_DEFAULT_ZONE_DIR, 0);\n\n\tzone_limit.count = nf_conncount_count(net, data, &conncount_key, NULL,\n\t\t\t\t\t      &ct_zone);\n\treturn nla_put_nohdr(reply, sizeof(zone_limit), &zone_limit);\n}\n\nstatic int ovs_ct_limit_get_zone_limit(struct net *net,\n\t\t\t\t       struct nlattr *nla_zone_limit,\n\t\t\t\t       struct ovs_ct_limit_info *info,\n\t\t\t\t       struct sk_buff *reply)\n{\n\tstruct ovs_zone_limit *zone_limit;\n\tint rem, err;\n\tu32 limit;\n\tu16 zone;\n\n\trem = NLA_ALIGN(nla_len(nla_zone_limit));\n\tzone_limit = (struct ovs_zone_limit *)nla_data(nla_zone_limit);\n\n\twhile (rem >= sizeof(*zone_limit)) {\n\t\tif (unlikely(zone_limit->zone_id ==\n\t\t\t\tOVS_ZONE_LIMIT_DEFAULT_ZONE)) {\n\t\t\terr = ovs_ct_limit_get_default_limit(info, reply);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (unlikely(!check_zone_id(zone_limit->zone_id,\n\t\t\t\t\t\t\t&zone))) {\n\t\t\tOVS_NLERR(true, \"zone id is out of range\");\n\t\t} else {\n\t\t\trcu_read_lock();\n\t\t\tlimit = ct_limit_get(info, zone);\n\t\t\trcu_read_unlock();\n\n\t\t\terr = __ovs_ct_limit_get_zone_limit(\n\t\t\t\tnet, info->data, zone, limit, reply);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\trem -= NLA_ALIGN(sizeof(*zone_limit));\n\t\tzone_limit = (struct ovs_zone_limit *)((u8 *)zone_limit +\n\t\t\t\tNLA_ALIGN(sizeof(*zone_limit)));\n\t}\n\n\tif (rem)\n\t\tOVS_NLERR(true, \"get zone limit has %d unknown bytes\", rem);\n\n\treturn 0;\n}\n\nstatic int ovs_ct_limit_get_all_zone_limit(struct net *net,\n\t\t\t\t\t   struct ovs_ct_limit_info *info,\n\t\t\t\t\t   struct sk_buff *reply)\n{\n\tstruct ovs_ct_limit *ct_limit;\n\tstruct hlist_head *head;\n\tint i, err = 0;\n\n\terr = ovs_ct_limit_get_default_limit(info, reply);\n\tif (err)\n\t\treturn err;\n\n\trcu_read_lock();\n\tfor (i = 0; i < CT_LIMIT_HASH_BUCKETS; ++i) {\n\t\thead = &info->limits[i];\n\t\thlist_for_each_entry_rcu(ct_limit, head, hlist_node) {\n\t\t\terr = __ovs_ct_limit_get_zone_limit(net, info->data,\n\t\t\t\tct_limit->zone, ct_limit->limit, reply);\n\t\t\tif (err)\n\t\t\t\tgoto exit_err;\n\t\t}\n\t}\n\nexit_err:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int ovs_ct_limit_cmd_set(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr **a = info->attrs;\n\tstruct sk_buff *reply;\n\tstruct ovs_header *ovs_reply_header;\n\tstruct ovs_net *ovs_net = net_generic(sock_net(skb->sk), ovs_net_id);\n\tstruct ovs_ct_limit_info *ct_limit_info = ovs_net->ct_limit_info;\n\tint err;\n\n\treply = ovs_ct_limit_cmd_reply_start(info, OVS_CT_LIMIT_CMD_SET,\n\t\t\t\t\t     &ovs_reply_header);\n\tif (IS_ERR(reply))\n\t\treturn PTR_ERR(reply);\n\n\tif (!a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT]) {\n\t\terr = -EINVAL;\n\t\tgoto exit_err;\n\t}\n\n\terr = ovs_ct_limit_set_zone_limit(a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT],\n\t\t\t\t\t  ct_limit_info);\n\tif (err)\n\t\tgoto exit_err;\n\n\tstatic_branch_enable(&ovs_ct_limit_enabled);\n\n\tgenlmsg_end(reply, ovs_reply_header);\n\treturn genlmsg_reply(reply, info);\n\nexit_err:\n\tnlmsg_free(reply);\n\treturn err;\n}\n\nstatic int ovs_ct_limit_cmd_del(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr **a = info->attrs;\n\tstruct sk_buff *reply;\n\tstruct ovs_header *ovs_reply_header;\n\tstruct ovs_net *ovs_net = net_generic(sock_net(skb->sk), ovs_net_id);\n\tstruct ovs_ct_limit_info *ct_limit_info = ovs_net->ct_limit_info;\n\tint err;\n\n\treply = ovs_ct_limit_cmd_reply_start(info, OVS_CT_LIMIT_CMD_DEL,\n\t\t\t\t\t     &ovs_reply_header);\n\tif (IS_ERR(reply))\n\t\treturn PTR_ERR(reply);\n\n\tif (!a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT]) {\n\t\terr = -EINVAL;\n\t\tgoto exit_err;\n\t}\n\n\terr = ovs_ct_limit_del_zone_limit(a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT],\n\t\t\t\t\t  ct_limit_info);\n\tif (err)\n\t\tgoto exit_err;\n\n\tgenlmsg_end(reply, ovs_reply_header);\n\treturn genlmsg_reply(reply, info);\n\nexit_err:\n\tnlmsg_free(reply);\n\treturn err;\n}\n\nstatic int ovs_ct_limit_cmd_get(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr **a = info->attrs;\n\tstruct nlattr *nla_reply;\n\tstruct sk_buff *reply;\n\tstruct ovs_header *ovs_reply_header;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ovs_net *ovs_net = net_generic(net, ovs_net_id);\n\tstruct ovs_ct_limit_info *ct_limit_info = ovs_net->ct_limit_info;\n\tint err;\n\n\treply = ovs_ct_limit_cmd_reply_start(info, OVS_CT_LIMIT_CMD_GET,\n\t\t\t\t\t     &ovs_reply_header);\n\tif (IS_ERR(reply))\n\t\treturn PTR_ERR(reply);\n\n\tnla_reply = nla_nest_start_noflag(reply, OVS_CT_LIMIT_ATTR_ZONE_LIMIT);\n\tif (!nla_reply) {\n\t\terr = -EMSGSIZE;\n\t\tgoto exit_err;\n\t}\n\n\tif (a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT]) {\n\t\terr = ovs_ct_limit_get_zone_limit(\n\t\t\tnet, a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT], ct_limit_info,\n\t\t\treply);\n\t\tif (err)\n\t\t\tgoto exit_err;\n\t} else {\n\t\terr = ovs_ct_limit_get_all_zone_limit(net, ct_limit_info,\n\t\t\t\t\t\t      reply);\n\t\tif (err)\n\t\t\tgoto exit_err;\n\t}\n\n\tnla_nest_end(reply, nla_reply);\n\tgenlmsg_end(reply, ovs_reply_header);\n\treturn genlmsg_reply(reply, info);\n\nexit_err:\n\tnlmsg_free(reply);\n\treturn err;\n}\n\nstatic const struct genl_small_ops ct_limit_genl_ops[] = {\n\t{ .cmd = OVS_CT_LIMIT_CMD_SET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,  \n\t\t.doit = ovs_ct_limit_cmd_set,\n\t},\n\t{ .cmd = OVS_CT_LIMIT_CMD_DEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,  \n\t\t.doit = ovs_ct_limit_cmd_del,\n\t},\n\t{ .cmd = OVS_CT_LIMIT_CMD_GET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = 0,\t\t   \n\t\t.doit = ovs_ct_limit_cmd_get,\n\t},\n};\n\nstatic const struct genl_multicast_group ovs_ct_limit_multicast_group = {\n\t.name = OVS_CT_LIMIT_MCGROUP,\n};\n\nstruct genl_family dp_ct_limit_genl_family __ro_after_init = {\n\t.hdrsize = sizeof(struct ovs_header),\n\t.name = OVS_CT_LIMIT_FAMILY,\n\t.version = OVS_CT_LIMIT_VERSION,\n\t.maxattr = OVS_CT_LIMIT_ATTR_MAX,\n\t.policy = ct_limit_policy,\n\t.netnsok = true,\n\t.parallel_ops = true,\n\t.small_ops = ct_limit_genl_ops,\n\t.n_small_ops = ARRAY_SIZE(ct_limit_genl_ops),\n\t.resv_start_op = OVS_CT_LIMIT_CMD_GET + 1,\n\t.mcgrps = &ovs_ct_limit_multicast_group,\n\t.n_mcgrps = 1,\n\t.module = THIS_MODULE,\n};\n#endif\n\nint ovs_ct_init(struct net *net)\n{\n\tunsigned int n_bits = sizeof(struct ovs_key_ct_labels) * BITS_PER_BYTE;\n\tstruct ovs_net *ovs_net = net_generic(net, ovs_net_id);\n\n\tif (nf_connlabels_get(net, n_bits - 1)) {\n\t\tovs_net->xt_label = false;\n\t\tOVS_NLERR(true, \"Failed to set connlabel length\");\n\t} else {\n\t\tovs_net->xt_label = true;\n\t}\n\n#if\tIS_ENABLED(CONFIG_NETFILTER_CONNCOUNT)\n\treturn ovs_ct_limit_init(net, ovs_net);\n#else\n\treturn 0;\n#endif\n}\n\nvoid ovs_ct_exit(struct net *net)\n{\n\tstruct ovs_net *ovs_net = net_generic(net, ovs_net_id);\n\n#if\tIS_ENABLED(CONFIG_NETFILTER_CONNCOUNT)\n\tovs_ct_limit_exit(net, ovs_net);\n#endif\n\n\tif (ovs_net->xt_label)\n\t\tnf_connlabels_put(net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}