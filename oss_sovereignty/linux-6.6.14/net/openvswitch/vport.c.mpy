{
  "module_name": "vport.c",
  "hash_id": "519996590c5cc0cbda4e986ec67843d629627157fc55382f6d18ab976819e5a6",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/vport.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/if.h>\n#include <linux/if_vlan.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/rcupdate.h>\n#include <linux/rtnetlink.h>\n#include <linux/compat.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\n#include \"datapath.h\"\n#include \"vport.h\"\n#include \"vport-internal_dev.h\"\n\nstatic LIST_HEAD(vport_ops_list);\n\n \nstatic struct hlist_head *dev_table;\n#define VPORT_HASH_BUCKETS 1024\n\n \nint ovs_vport_init(void)\n{\n\tdev_table = kcalloc(VPORT_HASH_BUCKETS, sizeof(struct hlist_head),\n\t\t\t    GFP_KERNEL);\n\tif (!dev_table)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nvoid ovs_vport_exit(void)\n{\n\tkfree(dev_table);\n}\n\nstatic struct hlist_head *hash_bucket(const struct net *net, const char *name)\n{\n\tunsigned int hash = jhash(name, strlen(name), (unsigned long) net);\n\treturn &dev_table[hash & (VPORT_HASH_BUCKETS - 1)];\n}\n\nint __ovs_vport_ops_register(struct vport_ops *ops)\n{\n\tint err = -EEXIST;\n\tstruct vport_ops *o;\n\n\tovs_lock();\n\tlist_for_each_entry(o, &vport_ops_list, list)\n\t\tif (ops->type == o->type)\n\t\t\tgoto errout;\n\n\tlist_add_tail(&ops->list, &vport_ops_list);\n\terr = 0;\nerrout:\n\tovs_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__ovs_vport_ops_register);\n\nvoid ovs_vport_ops_unregister(struct vport_ops *ops)\n{\n\tovs_lock();\n\tlist_del(&ops->list);\n\tovs_unlock();\n}\nEXPORT_SYMBOL_GPL(ovs_vport_ops_unregister);\n\n \nstruct vport *ovs_vport_locate(const struct net *net, const char *name)\n{\n\tstruct hlist_head *bucket = hash_bucket(net, name);\n\tstruct vport *vport;\n\n\thlist_for_each_entry_rcu(vport, bucket, hash_node,\n\t\t\t\t lockdep_ovsl_is_held())\n\t\tif (!strcmp(name, ovs_vport_name(vport)) &&\n\t\t    net_eq(ovs_dp_get_net(vport->dp), net))\n\t\t\treturn vport;\n\n\treturn NULL;\n}\n\n \nstruct vport *ovs_vport_alloc(int priv_size, const struct vport_ops *ops,\n\t\t\t      const struct vport_parms *parms)\n{\n\tstruct vport *vport;\n\tsize_t alloc_size;\n\tint err;\n\n\talloc_size = sizeof(struct vport);\n\tif (priv_size) {\n\t\talloc_size = ALIGN(alloc_size, VPORT_ALIGN);\n\t\talloc_size += priv_size;\n\t}\n\n\tvport = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!vport)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvport->upcall_stats = netdev_alloc_pcpu_stats(struct vport_upcall_stats_percpu);\n\tif (!vport->upcall_stats) {\n\t\terr = -ENOMEM;\n\t\tgoto err_kfree_vport;\n\t}\n\n\tvport->dp = parms->dp;\n\tvport->port_no = parms->port_no;\n\tvport->ops = ops;\n\tINIT_HLIST_NODE(&vport->dp_hash_node);\n\n\tif (ovs_vport_set_upcall_portids(vport, parms->upcall_portids)) {\n\t\terr = -EINVAL;\n\t\tgoto err_free_percpu;\n\t}\n\n\treturn vport;\n\nerr_free_percpu:\n\tfree_percpu(vport->upcall_stats);\nerr_kfree_vport:\n\tkfree(vport);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(ovs_vport_alloc);\n\n \nvoid ovs_vport_free(struct vport *vport)\n{\n\t \n\tkfree(rcu_dereference_raw(vport->upcall_portids));\n\tfree_percpu(vport->upcall_stats);\n\tkfree(vport);\n}\nEXPORT_SYMBOL_GPL(ovs_vport_free);\n\nstatic struct vport_ops *ovs_vport_lookup(const struct vport_parms *parms)\n{\n\tstruct vport_ops *ops;\n\n\tlist_for_each_entry(ops, &vport_ops_list, list)\n\t\tif (ops->type == parms->type)\n\t\t\treturn ops;\n\n\treturn NULL;\n}\n\n \nstruct vport *ovs_vport_add(const struct vport_parms *parms)\n{\n\tstruct vport_ops *ops;\n\tstruct vport *vport;\n\n\tops = ovs_vport_lookup(parms);\n\tif (ops) {\n\t\tstruct hlist_head *bucket;\n\n\t\tif (!try_module_get(ops->owner))\n\t\t\treturn ERR_PTR(-EAFNOSUPPORT);\n\n\t\tvport = ops->create(parms);\n\t\tif (IS_ERR(vport)) {\n\t\t\tmodule_put(ops->owner);\n\t\t\treturn vport;\n\t\t}\n\n\t\tbucket = hash_bucket(ovs_dp_get_net(vport->dp),\n\t\t\t\t     ovs_vport_name(vport));\n\t\thlist_add_head_rcu(&vport->hash_node, bucket);\n\t\treturn vport;\n\t}\n\n\t \n\tovs_unlock();\n\trequest_module(\"vport-type-%d\", parms->type);\n\tovs_lock();\n\n\tif (!ovs_vport_lookup(parms))\n\t\treturn ERR_PTR(-EAFNOSUPPORT);\n\telse\n\t\treturn ERR_PTR(-EAGAIN);\n}\n\n \nint ovs_vport_set_options(struct vport *vport, struct nlattr *options)\n{\n\tif (!vport->ops->set_options)\n\t\treturn -EOPNOTSUPP;\n\treturn vport->ops->set_options(vport, options);\n}\n\n \nvoid ovs_vport_del(struct vport *vport)\n{\n\thlist_del_rcu(&vport->hash_node);\n\tmodule_put(vport->ops->owner);\n\tvport->ops->destroy(vport);\n}\n\n \nvoid ovs_vport_get_stats(struct vport *vport, struct ovs_vport_stats *stats)\n{\n\tconst struct rtnl_link_stats64 *dev_stats;\n\tstruct rtnl_link_stats64 temp;\n\n\tdev_stats = dev_get_stats(vport->dev, &temp);\n\tstats->rx_errors  = dev_stats->rx_errors;\n\tstats->tx_errors  = dev_stats->tx_errors;\n\tstats->tx_dropped = dev_stats->tx_dropped;\n\tstats->rx_dropped = dev_stats->rx_dropped;\n\n\tstats->rx_bytes\t  = dev_stats->rx_bytes;\n\tstats->rx_packets = dev_stats->rx_packets;\n\tstats->tx_bytes\t  = dev_stats->tx_bytes;\n\tstats->tx_packets = dev_stats->tx_packets;\n}\n\n \nint ovs_vport_get_upcall_stats(struct vport *vport, struct sk_buff *skb)\n{\n\tstruct nlattr *nla;\n\tint i;\n\n\t__u64 tx_success = 0;\n\t__u64 tx_fail = 0;\n\n\tfor_each_possible_cpu(i) {\n\t\tconst struct vport_upcall_stats_percpu *stats;\n\t\tunsigned int start;\n\n\t\tstats = per_cpu_ptr(vport->upcall_stats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&stats->syncp);\n\t\t\ttx_success += u64_stats_read(&stats->n_success);\n\t\t\ttx_fail += u64_stats_read(&stats->n_fail);\n\t\t} while (u64_stats_fetch_retry(&stats->syncp, start));\n\t}\n\n\tnla = nla_nest_start_noflag(skb, OVS_VPORT_ATTR_UPCALL_STATS);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u64_64bit(skb, OVS_VPORT_UPCALL_ATTR_SUCCESS, tx_success,\n\t\t\t      OVS_VPORT_ATTR_PAD)) {\n\t\tnla_nest_cancel(skb, nla);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (nla_put_u64_64bit(skb, OVS_VPORT_UPCALL_ATTR_FAIL, tx_fail,\n\t\t\t      OVS_VPORT_ATTR_PAD)) {\n\t\tnla_nest_cancel(skb, nla);\n\t\treturn -EMSGSIZE;\n\t}\n\tnla_nest_end(skb, nla);\n\n\treturn 0;\n}\n\n \nint ovs_vport_get_options(const struct vport *vport, struct sk_buff *skb)\n{\n\tstruct nlattr *nla;\n\tint err;\n\n\tif (!vport->ops->get_options)\n\t\treturn 0;\n\n\tnla = nla_nest_start_noflag(skb, OVS_VPORT_ATTR_OPTIONS);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\terr = vport->ops->get_options(vport, skb);\n\tif (err) {\n\t\tnla_nest_cancel(skb, nla);\n\t\treturn err;\n\t}\n\n\tnla_nest_end(skb, nla);\n\treturn 0;\n}\n\n \nint ovs_vport_set_upcall_portids(struct vport *vport, const struct nlattr *ids)\n{\n\tstruct vport_portids *old, *vport_portids;\n\n\tif (!nla_len(ids) || nla_len(ids) % sizeof(u32))\n\t\treturn -EINVAL;\n\n\told = ovsl_dereference(vport->upcall_portids);\n\n\tvport_portids = kmalloc(sizeof(*vport_portids) + nla_len(ids),\n\t\t\t\tGFP_KERNEL);\n\tif (!vport_portids)\n\t\treturn -ENOMEM;\n\n\tvport_portids->n_ids = nla_len(ids) / sizeof(u32);\n\tvport_portids->rn_ids = reciprocal_value(vport_portids->n_ids);\n\tnla_memcpy(vport_portids->ids, ids, nla_len(ids));\n\n\trcu_assign_pointer(vport->upcall_portids, vport_portids);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\treturn 0;\n}\n\n \nint ovs_vport_get_upcall_portids(const struct vport *vport,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct vport_portids *ids;\n\n\tids = rcu_dereference_ovsl(vport->upcall_portids);\n\n\tif (vport->dp->user_features & OVS_DP_F_VPORT_PIDS)\n\t\treturn nla_put(skb, OVS_VPORT_ATTR_UPCALL_PID,\n\t\t\t       ids->n_ids * sizeof(u32), (void *)ids->ids);\n\telse\n\t\treturn nla_put_u32(skb, OVS_VPORT_ATTR_UPCALL_PID, ids->ids[0]);\n}\n\n \nu32 ovs_vport_find_upcall_portid(const struct vport *vport,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct vport_portids *ids;\n\tu32 ids_index;\n\tu32 hash;\n\n\tids = rcu_dereference(vport->upcall_portids);\n\n\t \n\tif (ids->n_ids == 1)\n\t\treturn ids->ids[0];\n\n\thash = skb_get_hash(skb);\n\tids_index = hash - ids->n_ids * reciprocal_divide(hash, ids->rn_ids);\n\treturn ids->ids[ids_index];\n}\n\n \nint ovs_vport_receive(struct vport *vport, struct sk_buff *skb,\n\t\t      const struct ip_tunnel_info *tun_info)\n{\n\tstruct sw_flow_key key;\n\tint error;\n\n\tOVS_CB(skb)->input_vport = vport;\n\tOVS_CB(skb)->mru = 0;\n\tOVS_CB(skb)->cutlen = 0;\n\tif (unlikely(dev_net(skb->dev) != ovs_dp_get_net(vport->dp))) {\n\t\tu32 mark;\n\n\t\tmark = skb->mark;\n\t\tskb_scrub_packet(skb, true);\n\t\tskb->mark = mark;\n\t\ttun_info = NULL;\n\t}\n\n\t \n\terror = ovs_flow_key_extract(tun_info, skb, &key);\n\tif (unlikely(error)) {\n\t\tkfree_skb(skb);\n\t\treturn error;\n\t}\n\tovs_dp_process_packet(skb, &key);\n\treturn 0;\n}\n\nstatic int packet_length(const struct sk_buff *skb,\n\t\t\t struct net_device *dev)\n{\n\tint length = skb->len - dev->hard_header_len;\n\n\tif (!skb_vlan_tag_present(skb) &&\n\t    eth_type_vlan(skb->protocol))\n\t\tlength -= VLAN_HLEN;\n\n\t \n\n\treturn length > 0 ? length : 0;\n}\n\nvoid ovs_vport_send(struct vport *vport, struct sk_buff *skb, u8 mac_proto)\n{\n\tint mtu = vport->dev->mtu;\n\n\tswitch (vport->dev->type) {\n\tcase ARPHRD_NONE:\n\t\tif (mac_proto == MAC_PROTO_ETHERNET) {\n\t\t\tskb_reset_network_header(skb);\n\t\t\tskb_reset_mac_len(skb);\n\t\t\tskb->protocol = htons(ETH_P_TEB);\n\t\t} else if (mac_proto != MAC_PROTO_NONE) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tgoto drop;\n\t\t}\n\t\tbreak;\n\tcase ARPHRD_ETHER:\n\t\tif (mac_proto != MAC_PROTO_ETHERNET)\n\t\t\tgoto drop;\n\t\tbreak;\n\tdefault:\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(packet_length(skb, vport->dev) > mtu &&\n\t\t     !skb_is_gso(skb))) {\n\t\tvport->dev->stats.tx_errors++;\n\t\tif (vport->dev->flags & IFF_UP)\n\t\t\tnet_warn_ratelimited(\"%s: dropped over-mtu packet: \"\n\t\t\t\t\t     \"%d > %d\\n\", vport->dev->name,\n\t\t\t\t\t     packet_length(skb, vport->dev),\n\t\t\t\t\t     mtu);\n\t\tgoto drop;\n\t}\n\n\tskb->dev = vport->dev;\n\tskb_clear_tstamp(skb);\n\tvport->ops->send(skb);\n\treturn;\n\ndrop:\n\tkfree_skb(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}