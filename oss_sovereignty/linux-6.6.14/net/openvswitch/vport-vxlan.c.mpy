{
  "module_name": "vport-vxlan.c",
  "hash_id": "3fa5037727518cc7d1e2edb2606eb352736e488d04b8fd39fef4169c19c06f30",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/vport-vxlan.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/openvswitch.h>\n#include <linux/module.h>\n#include <net/udp.h>\n#include <net/ip_tunnels.h>\n#include <net/rtnetlink.h>\n#include <net/vxlan.h>\n\n#include \"datapath.h\"\n#include \"vport.h\"\n#include \"vport-netdev.h\"\n\nstatic struct vport_ops ovs_vxlan_netdev_vport_ops;\n\nstatic int vxlan_get_options(const struct vport *vport, struct sk_buff *skb)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(vport->dev);\n\t__be16 dst_port = vxlan->cfg.dst_port;\n\n\tif (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))\n\t\treturn -EMSGSIZE;\n\n\tif (vxlan->cfg.flags & VXLAN_F_GBP) {\n\t\tstruct nlattr *exts;\n\n\t\texts = nla_nest_start_noflag(skb, OVS_TUNNEL_ATTR_EXTENSION);\n\t\tif (!exts)\n\t\t\treturn -EMSGSIZE;\n\n\t\tif (vxlan->cfg.flags & VXLAN_F_GBP &&\n\t\t    nla_put_flag(skb, OVS_VXLAN_EXT_GBP))\n\t\t\treturn -EMSGSIZE;\n\n\t\tnla_nest_end(skb, exts);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nla_policy exts_policy[OVS_VXLAN_EXT_MAX + 1] = {\n\t[OVS_VXLAN_EXT_GBP]\t= { .type = NLA_FLAG, },\n};\n\nstatic int vxlan_configure_exts(struct vport *vport, struct nlattr *attr,\n\t\t\t\tstruct vxlan_config *conf)\n{\n\tstruct nlattr *exts[OVS_VXLAN_EXT_MAX + 1];\n\tint err;\n\n\tif (nla_len(attr) < sizeof(struct nlattr))\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(exts, OVS_VXLAN_EXT_MAX, attr,\n\t\t\t\t\t  exts_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (exts[OVS_VXLAN_EXT_GBP])\n\t\tconf->flags |= VXLAN_F_GBP;\n\n\treturn 0;\n}\n\nstatic struct vport *vxlan_tnl_create(const struct vport_parms *parms)\n{\n\tstruct net *net = ovs_dp_get_net(parms->dp);\n\tstruct nlattr *options = parms->options;\n\tstruct net_device *dev;\n\tstruct vport *vport;\n\tstruct nlattr *a;\n\tint err;\n\tstruct vxlan_config conf = {\n\t\t.no_share = true,\n\t\t.flags = VXLAN_F_COLLECT_METADATA | VXLAN_F_UDP_ZERO_CSUM6_RX,\n\t\t \n\t\t.mtu = IP_MAX_MTU,\n\t};\n\n\tif (!options) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ta = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\n\tif (a && nla_len(a) == sizeof(u16)) {\n\t\tconf.dst_port = htons(nla_get_u16(a));\n\t} else {\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tvport = ovs_vport_alloc(0, &ovs_vxlan_netdev_vport_ops, parms);\n\tif (IS_ERR(vport))\n\t\treturn vport;\n\n\ta = nla_find_nested(options, OVS_TUNNEL_ATTR_EXTENSION);\n\tif (a) {\n\t\terr = vxlan_configure_exts(vport, a, &conf);\n\t\tif (err) {\n\t\t\tovs_vport_free(vport);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trtnl_lock();\n\tdev = vxlan_dev_create(net, parms->name, NET_NAME_USER, &conf);\n\tif (IS_ERR(dev)) {\n\t\trtnl_unlock();\n\t\tovs_vport_free(vport);\n\t\treturn ERR_CAST(dev);\n\t}\n\n\terr = dev_change_flags(dev, dev->flags | IFF_UP, NULL);\n\tif (err < 0) {\n\t\trtnl_delete_link(dev, 0, NULL);\n\t\trtnl_unlock();\n\t\tovs_vport_free(vport);\n\t\tgoto error;\n\t}\n\n\trtnl_unlock();\n\treturn vport;\nerror:\n\treturn ERR_PTR(err);\n}\n\nstatic struct vport *vxlan_create(const struct vport_parms *parms)\n{\n\tstruct vport *vport;\n\n\tvport = vxlan_tnl_create(parms);\n\tif (IS_ERR(vport))\n\t\treturn vport;\n\n\treturn ovs_netdev_link(vport, parms->name);\n}\n\nstatic struct vport_ops ovs_vxlan_netdev_vport_ops = {\n\t.type\t\t\t= OVS_VPORT_TYPE_VXLAN,\n\t.create\t\t\t= vxlan_create,\n\t.destroy\t\t= ovs_netdev_tunnel_destroy,\n\t.get_options\t\t= vxlan_get_options,\n\t.send\t\t\t= dev_queue_xmit,\n};\n\nstatic int __init ovs_vxlan_tnl_init(void)\n{\n\treturn ovs_vport_ops_register(&ovs_vxlan_netdev_vport_ops);\n}\n\nstatic void __exit ovs_vxlan_tnl_exit(void)\n{\n\tovs_vport_ops_unregister(&ovs_vxlan_netdev_vport_ops);\n}\n\nmodule_init(ovs_vxlan_tnl_init);\nmodule_exit(ovs_vxlan_tnl_exit);\n\nMODULE_DESCRIPTION(\"OVS: VXLAN switching port\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"vport-type-4\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}