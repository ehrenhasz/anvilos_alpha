{
  "module_name": "vport-geneve.c",
  "hash_id": "64dde95e93d1412970701a809297eb412e7ac497bda873807d94ab434c3f82c1",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/vport-geneve.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/net.h>\n#include <linux/rculist.h>\n#include <linux/udp.h>\n#include <linux/if_vlan.h>\n#include <linux/module.h>\n\n#include <net/geneve.h>\n#include <net/icmp.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/udp.h>\n#include <net/xfrm.h>\n\n#include \"datapath.h\"\n#include \"vport.h\"\n#include \"vport-netdev.h\"\n\nstatic struct vport_ops ovs_geneve_vport_ops;\n \nstruct geneve_port {\n\tu16 dst_port;\n};\n\nstatic inline struct geneve_port *geneve_vport(const struct vport *vport)\n{\n\treturn vport_priv(vport);\n}\n\nstatic int geneve_get_options(const struct vport *vport,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct geneve_port *geneve_port = geneve_vport(vport);\n\n\tif (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, geneve_port->dst_port))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic struct vport *geneve_tnl_create(const struct vport_parms *parms)\n{\n\tstruct net *net = ovs_dp_get_net(parms->dp);\n\tstruct nlattr *options = parms->options;\n\tstruct geneve_port *geneve_port;\n\tstruct net_device *dev;\n\tstruct vport *vport;\n\tstruct nlattr *a;\n\tu16 dst_port;\n\tint err;\n\n\tif (!options) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ta = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\n\tif (a && nla_len(a) == sizeof(u16)) {\n\t\tdst_port = nla_get_u16(a);\n\t} else {\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tvport = ovs_vport_alloc(sizeof(struct geneve_port),\n\t\t\t\t&ovs_geneve_vport_ops, parms);\n\tif (IS_ERR(vport))\n\t\treturn vport;\n\n\tgeneve_port = geneve_vport(vport);\n\tgeneve_port->dst_port = dst_port;\n\n\trtnl_lock();\n\tdev = geneve_dev_create_fb(net, parms->name, NET_NAME_USER, dst_port);\n\tif (IS_ERR(dev)) {\n\t\trtnl_unlock();\n\t\tovs_vport_free(vport);\n\t\treturn ERR_CAST(dev);\n\t}\n\n\terr = dev_change_flags(dev, dev->flags | IFF_UP, NULL);\n\tif (err < 0) {\n\t\trtnl_delete_link(dev, 0, NULL);\n\t\trtnl_unlock();\n\t\tovs_vport_free(vport);\n\t\tgoto error;\n\t}\n\n\trtnl_unlock();\n\treturn vport;\nerror:\n\treturn ERR_PTR(err);\n}\n\nstatic struct vport *geneve_create(const struct vport_parms *parms)\n{\n\tstruct vport *vport;\n\n\tvport = geneve_tnl_create(parms);\n\tif (IS_ERR(vport))\n\t\treturn vport;\n\n\treturn ovs_netdev_link(vport, parms->name);\n}\n\nstatic struct vport_ops ovs_geneve_vport_ops = {\n\t.type\t\t= OVS_VPORT_TYPE_GENEVE,\n\t.create\t\t= geneve_create,\n\t.destroy\t= ovs_netdev_tunnel_destroy,\n\t.get_options\t= geneve_get_options,\n\t.send\t\t= dev_queue_xmit,\n};\n\nstatic int __init ovs_geneve_tnl_init(void)\n{\n\treturn ovs_vport_ops_register(&ovs_geneve_vport_ops);\n}\n\nstatic void __exit ovs_geneve_tnl_exit(void)\n{\n\tovs_vport_ops_unregister(&ovs_geneve_vport_ops);\n}\n\nmodule_init(ovs_geneve_tnl_init);\nmodule_exit(ovs_geneve_tnl_exit);\n\nMODULE_DESCRIPTION(\"OVS: Geneve switching port\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"vport-type-5\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}