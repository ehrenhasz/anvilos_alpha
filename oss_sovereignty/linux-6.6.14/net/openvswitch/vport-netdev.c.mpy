{
  "module_name": "vport-netdev.c",
  "hash_id": "6b3730bfd9ea9409a45047f75003c7496a51451a90882cf8299216ae9c500217",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/vport-netdev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/if_arp.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/kernel.h>\n#include <linux/llc.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/openvswitch.h>\n#include <linux/export.h>\n\n#include <net/ip_tunnels.h>\n#include <net/rtnetlink.h>\n\n#include \"datapath.h\"\n#include \"vport.h\"\n#include \"vport-internal_dev.h\"\n#include \"vport-netdev.h\"\n\nstatic struct vport_ops ovs_netdev_vport_ops;\n\n \nstatic void netdev_port_receive(struct sk_buff *skb)\n{\n\tstruct vport *vport;\n\n\tvport = ovs_netdev_get_vport(skb->dev);\n\tif (unlikely(!vport))\n\t\tgoto error;\n\n\tif (unlikely(skb_warn_if_lro(skb)))\n\t\tgoto error;\n\n\t \n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn;\n\n\tif (skb->dev->type == ARPHRD_ETHER)\n\t\tskb_push_rcsum(skb, ETH_HLEN);\n\n\tovs_vport_receive(vport, skb, skb_tunnel_info(skb));\n\treturn;\nerror:\n\tkfree_skb(skb);\n}\n\n \nstatic rx_handler_result_t netdev_frame_hook(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\n\tif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\n\t\treturn RX_HANDLER_PASS;\n\n\tnetdev_port_receive(skb);\n\treturn RX_HANDLER_CONSUMED;\n}\n\nstatic struct net_device *get_dpdev(const struct datapath *dp)\n{\n\tstruct vport *local;\n\n\tlocal = ovs_vport_ovsl(dp, OVSP_LOCAL);\n\treturn local->dev;\n}\n\nstruct vport *ovs_netdev_link(struct vport *vport, const char *name)\n{\n\tint err;\n\n\tvport->dev = dev_get_by_name(ovs_dp_get_net(vport->dp), name);\n\tif (!vport->dev) {\n\t\terr = -ENODEV;\n\t\tgoto error_free_vport;\n\t}\n\tnetdev_tracker_alloc(vport->dev, &vport->dev_tracker, GFP_KERNEL);\n\tif (vport->dev->flags & IFF_LOOPBACK ||\n\t    (vport->dev->type != ARPHRD_ETHER &&\n\t     vport->dev->type != ARPHRD_NONE) ||\n\t    ovs_is_internal_dev(vport->dev)) {\n\t\terr = -EINVAL;\n\t\tgoto error_put;\n\t}\n\n\trtnl_lock();\n\terr = netdev_master_upper_dev_link(vport->dev,\n\t\t\t\t\t   get_dpdev(vport->dp),\n\t\t\t\t\t   NULL, NULL, NULL);\n\tif (err)\n\t\tgoto error_unlock;\n\n\terr = netdev_rx_handler_register(vport->dev, netdev_frame_hook,\n\t\t\t\t\t vport);\n\tif (err)\n\t\tgoto error_master_upper_dev_unlink;\n\n\tdev_disable_lro(vport->dev);\n\tdev_set_promiscuity(vport->dev, 1);\n\tvport->dev->priv_flags |= IFF_OVS_DATAPATH;\n\trtnl_unlock();\n\n\treturn vport;\n\nerror_master_upper_dev_unlink:\n\tnetdev_upper_dev_unlink(vport->dev, get_dpdev(vport->dp));\nerror_unlock:\n\trtnl_unlock();\nerror_put:\n\tnetdev_put(vport->dev, &vport->dev_tracker);\nerror_free_vport:\n\tovs_vport_free(vport);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(ovs_netdev_link);\n\nstatic struct vport *netdev_create(const struct vport_parms *parms)\n{\n\tstruct vport *vport;\n\n\tvport = ovs_vport_alloc(0, &ovs_netdev_vport_ops, parms);\n\tif (IS_ERR(vport))\n\t\treturn vport;\n\n\treturn ovs_netdev_link(vport, parms->name);\n}\n\nstatic void vport_netdev_free(struct rcu_head *rcu)\n{\n\tstruct vport *vport = container_of(rcu, struct vport, rcu);\n\n\tnetdev_put(vport->dev, &vport->dev_tracker);\n\tovs_vport_free(vport);\n}\n\nvoid ovs_netdev_detach_dev(struct vport *vport)\n{\n\tASSERT_RTNL();\n\tvport->dev->priv_flags &= ~IFF_OVS_DATAPATH;\n\tnetdev_rx_handler_unregister(vport->dev);\n\tnetdev_upper_dev_unlink(vport->dev,\n\t\t\t\tnetdev_master_upper_dev_get(vport->dev));\n\tdev_set_promiscuity(vport->dev, -1);\n}\n\nstatic void netdev_destroy(struct vport *vport)\n{\n\trtnl_lock();\n\tif (netif_is_ovs_port(vport->dev))\n\t\tovs_netdev_detach_dev(vport);\n\trtnl_unlock();\n\n\tcall_rcu(&vport->rcu, vport_netdev_free);\n}\n\nvoid ovs_netdev_tunnel_destroy(struct vport *vport)\n{\n\trtnl_lock();\n\tif (netif_is_ovs_port(vport->dev))\n\t\tovs_netdev_detach_dev(vport);\n\n\t \n\tif (vport->dev->reg_state == NETREG_REGISTERED)\n\t\trtnl_delete_link(vport->dev, 0, NULL);\n\tnetdev_put(vport->dev, &vport->dev_tracker);\n\tvport->dev = NULL;\n\trtnl_unlock();\n\n\tcall_rcu(&vport->rcu, vport_netdev_free);\n}\nEXPORT_SYMBOL_GPL(ovs_netdev_tunnel_destroy);\n\n \nstruct vport *ovs_netdev_get_vport(struct net_device *dev)\n{\n\tif (likely(netif_is_ovs_port(dev)))\n\t\treturn (struct vport *)\n\t\t\trcu_dereference_rtnl(dev->rx_handler_data);\n\telse\n\t\treturn NULL;\n}\n\nstatic struct vport_ops ovs_netdev_vport_ops = {\n\t.type\t\t= OVS_VPORT_TYPE_NETDEV,\n\t.create\t\t= netdev_create,\n\t.destroy\t= netdev_destroy,\n\t.send\t\t= dev_queue_xmit,\n};\n\nint __init ovs_netdev_init(void)\n{\n\treturn ovs_vport_ops_register(&ovs_netdev_vport_ops);\n}\n\nvoid ovs_netdev_exit(void)\n{\n\tovs_vport_ops_unregister(&ovs_netdev_vport_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}