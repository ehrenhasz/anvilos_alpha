{
  "module_name": "actions.c",
  "hash_id": "d17cb8496354541c5841589aa176cf8ca715a269730439002e27496fdad14955",
  "original_prompt": "Ingested from linux-6.6.14/net/openvswitch/actions.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/skbuff.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/openvswitch.h>\n#include <linux/sctp.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/in6.h>\n#include <linux/if_arp.h>\n#include <linux/if_vlan.h>\n\n#include <net/dst.h>\n#include <net/gso.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/checksum.h>\n#include <net/dsfield.h>\n#include <net/mpls.h>\n#include <net/sctp/checksum.h>\n\n#include \"datapath.h\"\n#include \"drop.h\"\n#include \"flow.h\"\n#include \"conntrack.h\"\n#include \"vport.h\"\n#include \"flow_netlink.h\"\n#include \"openvswitch_trace.h\"\n\nstruct deferred_action {\n\tstruct sk_buff *skb;\n\tconst struct nlattr *actions;\n\tint actions_len;\n\n\t \n\tstruct sw_flow_key pkt_key;\n};\n\n#define MAX_L2_LEN\t(VLAN_ETH_HLEN + 3 * MPLS_HLEN)\nstruct ovs_frag_data {\n\tunsigned long dst;\n\tstruct vport *vport;\n\tstruct ovs_skb_cb cb;\n\t__be16 inner_protocol;\n\tu16 network_offset;\t \n\tu16 vlan_tci;\n\t__be16 vlan_proto;\n\tunsigned int l2_len;\n\tu8 mac_proto;\n\tu8 l2_data[MAX_L2_LEN];\n};\n\nstatic DEFINE_PER_CPU(struct ovs_frag_data, ovs_frag_data_storage);\n\n#define DEFERRED_ACTION_FIFO_SIZE 10\n#define OVS_RECURSION_LIMIT 5\n#define OVS_DEFERRED_ACTION_THRESHOLD (OVS_RECURSION_LIMIT - 2)\nstruct action_fifo {\n\tint head;\n\tint tail;\n\t \n\tstruct deferred_action fifo[DEFERRED_ACTION_FIFO_SIZE];\n};\n\nstruct action_flow_keys {\n\tstruct sw_flow_key key[OVS_DEFERRED_ACTION_THRESHOLD];\n};\n\nstatic struct action_fifo __percpu *action_fifos;\nstatic struct action_flow_keys __percpu *flow_keys;\nstatic DEFINE_PER_CPU(int, exec_actions_level);\n\n \nstatic struct sw_flow_key *clone_key(const struct sw_flow_key *key_)\n{\n\tstruct action_flow_keys *keys = this_cpu_ptr(flow_keys);\n\tint level = this_cpu_read(exec_actions_level);\n\tstruct sw_flow_key *key = NULL;\n\n\tif (level <= OVS_DEFERRED_ACTION_THRESHOLD) {\n\t\tkey = &keys->key[level - 1];\n\t\t*key = *key_;\n\t}\n\n\treturn key;\n}\n\nstatic void action_fifo_init(struct action_fifo *fifo)\n{\n\tfifo->head = 0;\n\tfifo->tail = 0;\n}\n\nstatic bool action_fifo_is_empty(const struct action_fifo *fifo)\n{\n\treturn (fifo->head == fifo->tail);\n}\n\nstatic struct deferred_action *action_fifo_get(struct action_fifo *fifo)\n{\n\tif (action_fifo_is_empty(fifo))\n\t\treturn NULL;\n\n\treturn &fifo->fifo[fifo->tail++];\n}\n\nstatic struct deferred_action *action_fifo_put(struct action_fifo *fifo)\n{\n\tif (fifo->head >= DEFERRED_ACTION_FIFO_SIZE - 1)\n\t\treturn NULL;\n\n\treturn &fifo->fifo[fifo->head++];\n}\n\n \nstatic struct deferred_action *add_deferred_actions(struct sk_buff *skb,\n\t\t\t\t    const struct sw_flow_key *key,\n\t\t\t\t    const struct nlattr *actions,\n\t\t\t\t    const int actions_len)\n{\n\tstruct action_fifo *fifo;\n\tstruct deferred_action *da;\n\n\tfifo = this_cpu_ptr(action_fifos);\n\tda = action_fifo_put(fifo);\n\tif (da) {\n\t\tda->skb = skb;\n\t\tda->actions = actions;\n\t\tda->actions_len = actions_len;\n\t\tda->pkt_key = *key;\n\t}\n\n\treturn da;\n}\n\nstatic void invalidate_flow_key(struct sw_flow_key *key)\n{\n\tkey->mac_proto |= SW_FLOW_KEY_INVALID;\n}\n\nstatic bool is_flow_key_valid(const struct sw_flow_key *key)\n{\n\treturn !(key->mac_proto & SW_FLOW_KEY_INVALID);\n}\n\nstatic int clone_execute(struct datapath *dp, struct sk_buff *skb,\n\t\t\t struct sw_flow_key *key,\n\t\t\t u32 recirc_id,\n\t\t\t const struct nlattr *actions, int len,\n\t\t\t bool last, bool clone_flow_key);\n\nstatic int do_execute_actions(struct datapath *dp, struct sk_buff *skb,\n\t\t\t      struct sw_flow_key *key,\n\t\t\t      const struct nlattr *attr, int len);\n\nstatic int push_mpls(struct sk_buff *skb, struct sw_flow_key *key,\n\t\t     __be32 mpls_lse, __be16 mpls_ethertype, __u16 mac_len)\n{\n\tint err;\n\n\terr = skb_mpls_push(skb, mpls_lse, mpls_ethertype, mac_len, !!mac_len);\n\tif (err)\n\t\treturn err;\n\n\tif (!mac_len)\n\t\tkey->mac_proto = MAC_PROTO_NONE;\n\n\tinvalidate_flow_key(key);\n\treturn 0;\n}\n\nstatic int pop_mpls(struct sk_buff *skb, struct sw_flow_key *key,\n\t\t    const __be16 ethertype)\n{\n\tint err;\n\n\terr = skb_mpls_pop(skb, ethertype, skb->mac_len,\n\t\t\t   ovs_key_mac_proto(key) == MAC_PROTO_ETHERNET);\n\tif (err)\n\t\treturn err;\n\n\tif (ethertype == htons(ETH_P_TEB))\n\t\tkey->mac_proto = MAC_PROTO_ETHERNET;\n\n\tinvalidate_flow_key(key);\n\treturn 0;\n}\n\nstatic int set_mpls(struct sk_buff *skb, struct sw_flow_key *flow_key,\n\t\t    const __be32 *mpls_lse, const __be32 *mask)\n{\n\tstruct mpls_shim_hdr *stack;\n\t__be32 lse;\n\tint err;\n\n\tif (!pskb_may_pull(skb, skb_network_offset(skb) + MPLS_HLEN))\n\t\treturn -ENOMEM;\n\n\tstack = mpls_hdr(skb);\n\tlse = OVS_MASKED(stack->label_stack_entry, *mpls_lse, *mask);\n\terr = skb_mpls_update_lse(skb, lse);\n\tif (err)\n\t\treturn err;\n\n\tflow_key->mpls.lse[0] = lse;\n\treturn 0;\n}\n\nstatic int pop_vlan(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tint err;\n\n\terr = skb_vlan_pop(skb);\n\tif (skb_vlan_tag_present(skb)) {\n\t\tinvalidate_flow_key(key);\n\t} else {\n\t\tkey->eth.vlan.tci = 0;\n\t\tkey->eth.vlan.tpid = 0;\n\t}\n\treturn err;\n}\n\nstatic int push_vlan(struct sk_buff *skb, struct sw_flow_key *key,\n\t\t     const struct ovs_action_push_vlan *vlan)\n{\n\tif (skb_vlan_tag_present(skb)) {\n\t\tinvalidate_flow_key(key);\n\t} else {\n\t\tkey->eth.vlan.tci = vlan->vlan_tci;\n\t\tkey->eth.vlan.tpid = vlan->vlan_tpid;\n\t}\n\treturn skb_vlan_push(skb, vlan->vlan_tpid,\n\t\t\t     ntohs(vlan->vlan_tci) & ~VLAN_CFI_MASK);\n}\n\n \nstatic void ether_addr_copy_masked(u8 *dst_, const u8 *src_, const u8 *mask_)\n{\n\tu16 *dst = (u16 *)dst_;\n\tconst u16 *src = (const u16 *)src_;\n\tconst u16 *mask = (const u16 *)mask_;\n\n\tOVS_SET_MASKED(dst[0], src[0], mask[0]);\n\tOVS_SET_MASKED(dst[1], src[1], mask[1]);\n\tOVS_SET_MASKED(dst[2], src[2], mask[2]);\n}\n\nstatic int set_eth_addr(struct sk_buff *skb, struct sw_flow_key *flow_key,\n\t\t\tconst struct ovs_key_ethernet *key,\n\t\t\tconst struct ovs_key_ethernet *mask)\n{\n\tint err;\n\n\terr = skb_ensure_writable(skb, ETH_HLEN);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tskb_postpull_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);\n\n\tether_addr_copy_masked(eth_hdr(skb)->h_source, key->eth_src,\n\t\t\t       mask->eth_src);\n\tether_addr_copy_masked(eth_hdr(skb)->h_dest, key->eth_dst,\n\t\t\t       mask->eth_dst);\n\n\tskb_postpush_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);\n\n\tether_addr_copy(flow_key->eth.src, eth_hdr(skb)->h_source);\n\tether_addr_copy(flow_key->eth.dst, eth_hdr(skb)->h_dest);\n\treturn 0;\n}\n\n \nstatic int pop_eth(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tint err;\n\n\terr = skb_eth_pop(skb);\n\tif (err)\n\t\treturn err;\n\n\t \n\tkey->mac_proto = MAC_PROTO_NONE;\n\tinvalidate_flow_key(key);\n\treturn 0;\n}\n\nstatic int push_eth(struct sk_buff *skb, struct sw_flow_key *key,\n\t\t    const struct ovs_action_push_eth *ethh)\n{\n\tint err;\n\n\terr = skb_eth_push(skb, ethh->addresses.eth_dst,\n\t\t\t   ethh->addresses.eth_src);\n\tif (err)\n\t\treturn err;\n\n\t \n\tkey->mac_proto = MAC_PROTO_ETHERNET;\n\tinvalidate_flow_key(key);\n\treturn 0;\n}\n\nstatic int push_nsh(struct sk_buff *skb, struct sw_flow_key *key,\n\t\t    const struct nshhdr *nh)\n{\n\tint err;\n\n\terr = nsh_push(skb, nh);\n\tif (err)\n\t\treturn err;\n\n\t \n\tkey->mac_proto = MAC_PROTO_NONE;\n\tinvalidate_flow_key(key);\n\treturn 0;\n}\n\nstatic int pop_nsh(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tint err;\n\n\terr = nsh_pop(skb);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (skb->protocol == htons(ETH_P_TEB))\n\t\tkey->mac_proto = MAC_PROTO_ETHERNET;\n\telse\n\t\tkey->mac_proto = MAC_PROTO_NONE;\n\tinvalidate_flow_key(key);\n\treturn 0;\n}\n\nstatic void update_ip_l4_checksum(struct sk_buff *skb, struct iphdr *nh,\n\t\t\t\t  __be32 addr, __be32 new_addr)\n{\n\tint transport_len = skb->len - skb_transport_offset(skb);\n\n\tif (nh->frag_off & htons(IP_OFFSET))\n\t\treturn;\n\n\tif (nh->protocol == IPPROTO_TCP) {\n\t\tif (likely(transport_len >= sizeof(struct tcphdr)))\n\t\t\tinet_proto_csum_replace4(&tcp_hdr(skb)->check, skb,\n\t\t\t\t\t\t addr, new_addr, true);\n\t} else if (nh->protocol == IPPROTO_UDP) {\n\t\tif (likely(transport_len >= sizeof(struct udphdr))) {\n\t\t\tstruct udphdr *uh = udp_hdr(skb);\n\n\t\t\tif (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\t\tinet_proto_csum_replace4(&uh->check, skb,\n\t\t\t\t\t\t\t addr, new_addr, true);\n\t\t\t\tif (!uh->check)\n\t\t\t\t\tuh->check = CSUM_MANGLED_0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void set_ip_addr(struct sk_buff *skb, struct iphdr *nh,\n\t\t\t__be32 *addr, __be32 new_addr)\n{\n\tupdate_ip_l4_checksum(skb, nh, *addr, new_addr);\n\tcsum_replace4(&nh->check, *addr, new_addr);\n\tskb_clear_hash(skb);\n\tovs_ct_clear(skb, NULL);\n\t*addr = new_addr;\n}\n\nstatic void update_ipv6_checksum(struct sk_buff *skb, u8 l4_proto,\n\t\t\t\t __be32 addr[4], const __be32 new_addr[4])\n{\n\tint transport_len = skb->len - skb_transport_offset(skb);\n\n\tif (l4_proto == NEXTHDR_TCP) {\n\t\tif (likely(transport_len >= sizeof(struct tcphdr)))\n\t\t\tinet_proto_csum_replace16(&tcp_hdr(skb)->check, skb,\n\t\t\t\t\t\t  addr, new_addr, true);\n\t} else if (l4_proto == NEXTHDR_UDP) {\n\t\tif (likely(transport_len >= sizeof(struct udphdr))) {\n\t\t\tstruct udphdr *uh = udp_hdr(skb);\n\n\t\t\tif (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\t\tinet_proto_csum_replace16(&uh->check, skb,\n\t\t\t\t\t\t\t  addr, new_addr, true);\n\t\t\t\tif (!uh->check)\n\t\t\t\t\tuh->check = CSUM_MANGLED_0;\n\t\t\t}\n\t\t}\n\t} else if (l4_proto == NEXTHDR_ICMP) {\n\t\tif (likely(transport_len >= sizeof(struct icmp6hdr)))\n\t\t\tinet_proto_csum_replace16(&icmp6_hdr(skb)->icmp6_cksum,\n\t\t\t\t\t\t  skb, addr, new_addr, true);\n\t}\n}\n\nstatic void mask_ipv6_addr(const __be32 old[4], const __be32 addr[4],\n\t\t\t   const __be32 mask[4], __be32 masked[4])\n{\n\tmasked[0] = OVS_MASKED(old[0], addr[0], mask[0]);\n\tmasked[1] = OVS_MASKED(old[1], addr[1], mask[1]);\n\tmasked[2] = OVS_MASKED(old[2], addr[2], mask[2]);\n\tmasked[3] = OVS_MASKED(old[3], addr[3], mask[3]);\n}\n\nstatic void set_ipv6_addr(struct sk_buff *skb, u8 l4_proto,\n\t\t\t  __be32 addr[4], const __be32 new_addr[4],\n\t\t\t  bool recalculate_csum)\n{\n\tif (recalculate_csum)\n\t\tupdate_ipv6_checksum(skb, l4_proto, addr, new_addr);\n\n\tskb_clear_hash(skb);\n\tovs_ct_clear(skb, NULL);\n\tmemcpy(addr, new_addr, sizeof(__be32[4]));\n}\n\nstatic void set_ipv6_dsfield(struct sk_buff *skb, struct ipv6hdr *nh, u8 ipv6_tclass, u8 mask)\n{\n\tu8 old_ipv6_tclass = ipv6_get_dsfield(nh);\n\n\tipv6_tclass = OVS_MASKED(old_ipv6_tclass, ipv6_tclass, mask);\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tcsum_replace(&skb->csum, (__force __wsum)(old_ipv6_tclass << 12),\n\t\t\t     (__force __wsum)(ipv6_tclass << 12));\n\n\tipv6_change_dsfield(nh, ~mask, ipv6_tclass);\n}\n\nstatic void set_ipv6_fl(struct sk_buff *skb, struct ipv6hdr *nh, u32 fl, u32 mask)\n{\n\tu32 ofl;\n\n\tofl = nh->flow_lbl[0] << 16 |  nh->flow_lbl[1] << 8 |  nh->flow_lbl[2];\n\tfl = OVS_MASKED(ofl, fl, mask);\n\n\t \n\tnh->flow_lbl[0] = (u8)(fl >> 16);\n\tnh->flow_lbl[1] = (u8)(fl >> 8);\n\tnh->flow_lbl[2] = (u8)fl;\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tcsum_replace(&skb->csum, (__force __wsum)htonl(ofl), (__force __wsum)htonl(fl));\n}\n\nstatic void set_ipv6_ttl(struct sk_buff *skb, struct ipv6hdr *nh, u8 new_ttl, u8 mask)\n{\n\tnew_ttl = OVS_MASKED(nh->hop_limit, new_ttl, mask);\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tcsum_replace(&skb->csum, (__force __wsum)(nh->hop_limit << 8),\n\t\t\t     (__force __wsum)(new_ttl << 8));\n\tnh->hop_limit = new_ttl;\n}\n\nstatic void set_ip_ttl(struct sk_buff *skb, struct iphdr *nh, u8 new_ttl,\n\t\t       u8 mask)\n{\n\tnew_ttl = OVS_MASKED(nh->ttl, new_ttl, mask);\n\n\tcsum_replace2(&nh->check, htons(nh->ttl << 8), htons(new_ttl << 8));\n\tnh->ttl = new_ttl;\n}\n\nstatic int set_ipv4(struct sk_buff *skb, struct sw_flow_key *flow_key,\n\t\t    const struct ovs_key_ipv4 *key,\n\t\t    const struct ovs_key_ipv4 *mask)\n{\n\tstruct iphdr *nh;\n\t__be32 new_addr;\n\tint err;\n\n\terr = skb_ensure_writable(skb, skb_network_offset(skb) +\n\t\t\t\t  sizeof(struct iphdr));\n\tif (unlikely(err))\n\t\treturn err;\n\n\tnh = ip_hdr(skb);\n\n\t \n\tif (mask->ipv4_src) {\n\t\tnew_addr = OVS_MASKED(nh->saddr, key->ipv4_src, mask->ipv4_src);\n\n\t\tif (unlikely(new_addr != nh->saddr)) {\n\t\t\tset_ip_addr(skb, nh, &nh->saddr, new_addr);\n\t\t\tflow_key->ipv4.addr.src = new_addr;\n\t\t}\n\t}\n\tif (mask->ipv4_dst) {\n\t\tnew_addr = OVS_MASKED(nh->daddr, key->ipv4_dst, mask->ipv4_dst);\n\n\t\tif (unlikely(new_addr != nh->daddr)) {\n\t\t\tset_ip_addr(skb, nh, &nh->daddr, new_addr);\n\t\t\tflow_key->ipv4.addr.dst = new_addr;\n\t\t}\n\t}\n\tif (mask->ipv4_tos) {\n\t\tipv4_change_dsfield(nh, ~mask->ipv4_tos, key->ipv4_tos);\n\t\tflow_key->ip.tos = nh->tos;\n\t}\n\tif (mask->ipv4_ttl) {\n\t\tset_ip_ttl(skb, nh, key->ipv4_ttl, mask->ipv4_ttl);\n\t\tflow_key->ip.ttl = nh->ttl;\n\t}\n\n\treturn 0;\n}\n\nstatic bool is_ipv6_mask_nonzero(const __be32 addr[4])\n{\n\treturn !!(addr[0] | addr[1] | addr[2] | addr[3]);\n}\n\nstatic int set_ipv6(struct sk_buff *skb, struct sw_flow_key *flow_key,\n\t\t    const struct ovs_key_ipv6 *key,\n\t\t    const struct ovs_key_ipv6 *mask)\n{\n\tstruct ipv6hdr *nh;\n\tint err;\n\n\terr = skb_ensure_writable(skb, skb_network_offset(skb) +\n\t\t\t\t  sizeof(struct ipv6hdr));\n\tif (unlikely(err))\n\t\treturn err;\n\n\tnh = ipv6_hdr(skb);\n\n\t \n\tif (is_ipv6_mask_nonzero(mask->ipv6_src)) {\n\t\t__be32 *saddr = (__be32 *)&nh->saddr;\n\t\t__be32 masked[4];\n\n\t\tmask_ipv6_addr(saddr, key->ipv6_src, mask->ipv6_src, masked);\n\n\t\tif (unlikely(memcmp(saddr, masked, sizeof(masked)))) {\n\t\t\tset_ipv6_addr(skb, flow_key->ip.proto, saddr, masked,\n\t\t\t\t      true);\n\t\t\tmemcpy(&flow_key->ipv6.addr.src, masked,\n\t\t\t       sizeof(flow_key->ipv6.addr.src));\n\t\t}\n\t}\n\tif (is_ipv6_mask_nonzero(mask->ipv6_dst)) {\n\t\tunsigned int offset = 0;\n\t\tint flags = IP6_FH_F_SKIP_RH;\n\t\tbool recalc_csum = true;\n\t\t__be32 *daddr = (__be32 *)&nh->daddr;\n\t\t__be32 masked[4];\n\n\t\tmask_ipv6_addr(daddr, key->ipv6_dst, mask->ipv6_dst, masked);\n\n\t\tif (unlikely(memcmp(daddr, masked, sizeof(masked)))) {\n\t\t\tif (ipv6_ext_hdr(nh->nexthdr))\n\t\t\t\trecalc_csum = (ipv6_find_hdr(skb, &offset,\n\t\t\t\t\t\t\t     NEXTHDR_ROUTING,\n\t\t\t\t\t\t\t     NULL, &flags)\n\t\t\t\t\t       != NEXTHDR_ROUTING);\n\n\t\t\tset_ipv6_addr(skb, flow_key->ip.proto, daddr, masked,\n\t\t\t\t      recalc_csum);\n\t\t\tmemcpy(&flow_key->ipv6.addr.dst, masked,\n\t\t\t       sizeof(flow_key->ipv6.addr.dst));\n\t\t}\n\t}\n\tif (mask->ipv6_tclass) {\n\t\tset_ipv6_dsfield(skb, nh, key->ipv6_tclass, mask->ipv6_tclass);\n\t\tflow_key->ip.tos = ipv6_get_dsfield(nh);\n\t}\n\tif (mask->ipv6_label) {\n\t\tset_ipv6_fl(skb, nh, ntohl(key->ipv6_label),\n\t\t\t    ntohl(mask->ipv6_label));\n\t\tflow_key->ipv6.label =\n\t\t    *(__be32 *)nh & htonl(IPV6_FLOWINFO_FLOWLABEL);\n\t}\n\tif (mask->ipv6_hlimit) {\n\t\tset_ipv6_ttl(skb, nh, key->ipv6_hlimit, mask->ipv6_hlimit);\n\t\tflow_key->ip.ttl = nh->hop_limit;\n\t}\n\treturn 0;\n}\n\nstatic int set_nsh(struct sk_buff *skb, struct sw_flow_key *flow_key,\n\t\t   const struct nlattr *a)\n{\n\tstruct nshhdr *nh;\n\tsize_t length;\n\tint err;\n\tu8 flags;\n\tu8 ttl;\n\tint i;\n\n\tstruct ovs_key_nsh key;\n\tstruct ovs_key_nsh mask;\n\n\terr = nsh_key_from_nlattr(a, &key, &mask);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!pskb_may_pull(skb, skb_network_offset(skb) + NSH_BASE_HDR_LEN))\n\t\treturn -ENOMEM;\n\n\tnh = nsh_hdr(skb);\n\tlength = nsh_hdr_len(nh);\n\n\t \n\terr = skb_ensure_writable(skb, skb_network_offset(skb) +\n\t\t\t\t       length);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tnh = nsh_hdr(skb);\n\tskb_postpull_rcsum(skb, nh, length);\n\tflags = nsh_get_flags(nh);\n\tflags = OVS_MASKED(flags, key.base.flags, mask.base.flags);\n\tflow_key->nsh.base.flags = flags;\n\tttl = nsh_get_ttl(nh);\n\tttl = OVS_MASKED(ttl, key.base.ttl, mask.base.ttl);\n\tflow_key->nsh.base.ttl = ttl;\n\tnsh_set_flags_and_ttl(nh, flags, ttl);\n\tnh->path_hdr = OVS_MASKED(nh->path_hdr, key.base.path_hdr,\n\t\t\t\t  mask.base.path_hdr);\n\tflow_key->nsh.base.path_hdr = nh->path_hdr;\n\tswitch (nh->mdtype) {\n\tcase NSH_M_TYPE1:\n\t\tfor (i = 0; i < NSH_MD1_CONTEXT_SIZE; i++) {\n\t\t\tnh->md1.context[i] =\n\t\t\t    OVS_MASKED(nh->md1.context[i], key.context[i],\n\t\t\t\t       mask.context[i]);\n\t\t}\n\t\tmemcpy(flow_key->nsh.context, nh->md1.context,\n\t\t       sizeof(nh->md1.context));\n\t\tbreak;\n\tcase NSH_M_TYPE2:\n\t\tmemset(flow_key->nsh.context, 0,\n\t\t       sizeof(flow_key->nsh.context));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tskb_postpush_rcsum(skb, nh, length);\n\treturn 0;\n}\n\n \nstatic void set_tp_port(struct sk_buff *skb, __be16 *port,\n\t\t\t__be16 new_port, __sum16 *check)\n{\n\tovs_ct_clear(skb, NULL);\n\tinet_proto_csum_replace2(check, skb, *port, new_port, false);\n\t*port = new_port;\n}\n\nstatic int set_udp(struct sk_buff *skb, struct sw_flow_key *flow_key,\n\t\t   const struct ovs_key_udp *key,\n\t\t   const struct ovs_key_udp *mask)\n{\n\tstruct udphdr *uh;\n\t__be16 src, dst;\n\tint err;\n\n\terr = skb_ensure_writable(skb, skb_transport_offset(skb) +\n\t\t\t\t  sizeof(struct udphdr));\n\tif (unlikely(err))\n\t\treturn err;\n\n\tuh = udp_hdr(skb);\n\t \n\tsrc = OVS_MASKED(uh->source, key->udp_src, mask->udp_src);\n\tdst = OVS_MASKED(uh->dest, key->udp_dst, mask->udp_dst);\n\n\tif (uh->check && skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\tif (likely(src != uh->source)) {\n\t\t\tset_tp_port(skb, &uh->source, src, &uh->check);\n\t\t\tflow_key->tp.src = src;\n\t\t}\n\t\tif (likely(dst != uh->dest)) {\n\t\t\tset_tp_port(skb, &uh->dest, dst, &uh->check);\n\t\t\tflow_key->tp.dst = dst;\n\t\t}\n\n\t\tif (unlikely(!uh->check))\n\t\t\tuh->check = CSUM_MANGLED_0;\n\t} else {\n\t\tuh->source = src;\n\t\tuh->dest = dst;\n\t\tflow_key->tp.src = src;\n\t\tflow_key->tp.dst = dst;\n\t\tovs_ct_clear(skb, NULL);\n\t}\n\n\tskb_clear_hash(skb);\n\n\treturn 0;\n}\n\nstatic int set_tcp(struct sk_buff *skb, struct sw_flow_key *flow_key,\n\t\t   const struct ovs_key_tcp *key,\n\t\t   const struct ovs_key_tcp *mask)\n{\n\tstruct tcphdr *th;\n\t__be16 src, dst;\n\tint err;\n\n\terr = skb_ensure_writable(skb, skb_transport_offset(skb) +\n\t\t\t\t  sizeof(struct tcphdr));\n\tif (unlikely(err))\n\t\treturn err;\n\n\tth = tcp_hdr(skb);\n\tsrc = OVS_MASKED(th->source, key->tcp_src, mask->tcp_src);\n\tif (likely(src != th->source)) {\n\t\tset_tp_port(skb, &th->source, src, &th->check);\n\t\tflow_key->tp.src = src;\n\t}\n\tdst = OVS_MASKED(th->dest, key->tcp_dst, mask->tcp_dst);\n\tif (likely(dst != th->dest)) {\n\t\tset_tp_port(skb, &th->dest, dst, &th->check);\n\t\tflow_key->tp.dst = dst;\n\t}\n\tskb_clear_hash(skb);\n\n\treturn 0;\n}\n\nstatic int set_sctp(struct sk_buff *skb, struct sw_flow_key *flow_key,\n\t\t    const struct ovs_key_sctp *key,\n\t\t    const struct ovs_key_sctp *mask)\n{\n\tunsigned int sctphoff = skb_transport_offset(skb);\n\tstruct sctphdr *sh;\n\t__le32 old_correct_csum, new_csum, old_csum;\n\tint err;\n\n\terr = skb_ensure_writable(skb, sctphoff + sizeof(struct sctphdr));\n\tif (unlikely(err))\n\t\treturn err;\n\n\tsh = sctp_hdr(skb);\n\told_csum = sh->checksum;\n\told_correct_csum = sctp_compute_cksum(skb, sctphoff);\n\n\tsh->source = OVS_MASKED(sh->source, key->sctp_src, mask->sctp_src);\n\tsh->dest = OVS_MASKED(sh->dest, key->sctp_dst, mask->sctp_dst);\n\n\tnew_csum = sctp_compute_cksum(skb, sctphoff);\n\n\t \n\tsh->checksum = old_csum ^ old_correct_csum ^ new_csum;\n\n\tskb_clear_hash(skb);\n\tovs_ct_clear(skb, NULL);\n\n\tflow_key->tp.src = sh->source;\n\tflow_key->tp.dst = sh->dest;\n\n\treturn 0;\n}\n\nstatic int ovs_vport_output(struct net *net, struct sock *sk,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct ovs_frag_data *data = this_cpu_ptr(&ovs_frag_data_storage);\n\tstruct vport *vport = data->vport;\n\n\tif (skb_cow_head(skb, data->l2_len) < 0) {\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_NOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\t__skb_dst_copy(skb, data->dst);\n\t*OVS_CB(skb) = data->cb;\n\tskb->inner_protocol = data->inner_protocol;\n\tif (data->vlan_tci & VLAN_CFI_MASK)\n\t\t__vlan_hwaccel_put_tag(skb, data->vlan_proto, data->vlan_tci & ~VLAN_CFI_MASK);\n\telse\n\t\t__vlan_hwaccel_clear_tag(skb);\n\n\t \n\tskb_push(skb, data->l2_len);\n\tmemcpy(skb->data, &data->l2_data, data->l2_len);\n\tskb_postpush_rcsum(skb, skb->data, data->l2_len);\n\tskb_reset_mac_header(skb);\n\n\tif (eth_p_mpls(skb->protocol)) {\n\t\tskb->inner_network_header = skb->network_header;\n\t\tskb_set_network_header(skb, data->network_offset);\n\t\tskb_reset_mac_len(skb);\n\t}\n\n\tovs_vport_send(vport, skb, data->mac_proto);\n\treturn 0;\n}\n\nstatic unsigned int\novs_dst_get_mtu(const struct dst_entry *dst)\n{\n\treturn dst->dev->mtu;\n}\n\nstatic struct dst_ops ovs_dst_ops = {\n\t.family = AF_UNSPEC,\n\t.mtu = ovs_dst_get_mtu,\n};\n\n \nstatic void prepare_frag(struct vport *vport, struct sk_buff *skb,\n\t\t\t u16 orig_network_offset, u8 mac_proto)\n{\n\tunsigned int hlen = skb_network_offset(skb);\n\tstruct ovs_frag_data *data;\n\n\tdata = this_cpu_ptr(&ovs_frag_data_storage);\n\tdata->dst = skb->_skb_refdst;\n\tdata->vport = vport;\n\tdata->cb = *OVS_CB(skb);\n\tdata->inner_protocol = skb->inner_protocol;\n\tdata->network_offset = orig_network_offset;\n\tif (skb_vlan_tag_present(skb))\n\t\tdata->vlan_tci = skb_vlan_tag_get(skb) | VLAN_CFI_MASK;\n\telse\n\t\tdata->vlan_tci = 0;\n\tdata->vlan_proto = skb->vlan_proto;\n\tdata->mac_proto = mac_proto;\n\tdata->l2_len = hlen;\n\tmemcpy(&data->l2_data, skb->data, hlen);\n\n\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\tskb_pull(skb, hlen);\n}\n\nstatic void ovs_fragment(struct net *net, struct vport *vport,\n\t\t\t struct sk_buff *skb, u16 mru,\n\t\t\t struct sw_flow_key *key)\n{\n\tenum ovs_drop_reason reason;\n\tu16 orig_network_offset = 0;\n\n\tif (eth_p_mpls(skb->protocol)) {\n\t\torig_network_offset = skb_network_offset(skb);\n\t\tskb->network_header = skb->inner_network_header;\n\t}\n\n\tif (skb_network_offset(skb) > MAX_L2_LEN) {\n\t\tOVS_NLERR(1, \"L2 header too long to fragment\");\n\t\treason = OVS_DROP_FRAG_L2_TOO_LONG;\n\t\tgoto err;\n\t}\n\n\tif (key->eth.type == htons(ETH_P_IP)) {\n\t\tstruct rtable ovs_rt = { 0 };\n\t\tunsigned long orig_dst;\n\n\t\tprepare_frag(vport, skb, orig_network_offset,\n\t\t\t     ovs_key_mac_proto(key));\n\t\tdst_init(&ovs_rt.dst, &ovs_dst_ops, NULL, 1,\n\t\t\t DST_OBSOLETE_NONE, DST_NOCOUNT);\n\t\tovs_rt.dst.dev = vport->dev;\n\n\t\torig_dst = skb->_skb_refdst;\n\t\tskb_dst_set_noref(skb, &ovs_rt.dst);\n\t\tIPCB(skb)->frag_max_size = mru;\n\n\t\tip_do_fragment(net, skb->sk, skb, ovs_vport_output);\n\t\trefdst_drop(orig_dst);\n\t} else if (key->eth.type == htons(ETH_P_IPV6)) {\n\t\tunsigned long orig_dst;\n\t\tstruct rt6_info ovs_rt;\n\n\t\tprepare_frag(vport, skb, orig_network_offset,\n\t\t\t     ovs_key_mac_proto(key));\n\t\tmemset(&ovs_rt, 0, sizeof(ovs_rt));\n\t\tdst_init(&ovs_rt.dst, &ovs_dst_ops, NULL, 1,\n\t\t\t DST_OBSOLETE_NONE, DST_NOCOUNT);\n\t\tovs_rt.dst.dev = vport->dev;\n\n\t\torig_dst = skb->_skb_refdst;\n\t\tskb_dst_set_noref(skb, &ovs_rt.dst);\n\t\tIP6CB(skb)->frag_max_size = mru;\n\n\t\tipv6_stub->ipv6_fragment(net, skb->sk, skb, ovs_vport_output);\n\t\trefdst_drop(orig_dst);\n\t} else {\n\t\tWARN_ONCE(1, \"Failed fragment ->%s: eth=%04x, MRU=%d, MTU=%d.\",\n\t\t\t  ovs_vport_name(vport), ntohs(key->eth.type), mru,\n\t\t\t  vport->dev->mtu);\n\t\treason = OVS_DROP_FRAG_INVALID_PROTO;\n\t\tgoto err;\n\t}\n\n\treturn;\nerr:\n\tovs_kfree_skb_reason(skb, reason);\n}\n\nstatic void do_output(struct datapath *dp, struct sk_buff *skb, int out_port,\n\t\t      struct sw_flow_key *key)\n{\n\tstruct vport *vport = ovs_vport_rcu(dp, out_port);\n\n\tif (likely(vport && netif_carrier_ok(vport->dev))) {\n\t\tu16 mru = OVS_CB(skb)->mru;\n\t\tu32 cutlen = OVS_CB(skb)->cutlen;\n\n\t\tif (unlikely(cutlen > 0)) {\n\t\t\tif (skb->len - cutlen > ovs_mac_header_len(key))\n\t\t\t\tpskb_trim(skb, skb->len - cutlen);\n\t\t\telse\n\t\t\t\tpskb_trim(skb, ovs_mac_header_len(key));\n\t\t}\n\n\t\tif (likely(!mru ||\n\t\t           (skb->len <= mru + vport->dev->hard_header_len))) {\n\t\t\tovs_vport_send(vport, skb, ovs_key_mac_proto(key));\n\t\t} else if (mru <= vport->dev->mtu) {\n\t\t\tstruct net *net = read_pnet(&dp->net);\n\n\t\t\tovs_fragment(net, vport, skb, mru, key);\n\t\t} else {\n\t\t\tkfree_skb_reason(skb, SKB_DROP_REASON_PKT_TOO_BIG);\n\t\t}\n\t} else {\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_DEV_READY);\n\t}\n}\n\nstatic int output_userspace(struct datapath *dp, struct sk_buff *skb,\n\t\t\t    struct sw_flow_key *key, const struct nlattr *attr,\n\t\t\t    const struct nlattr *actions, int actions_len,\n\t\t\t    uint32_t cutlen)\n{\n\tstruct dp_upcall_info upcall;\n\tconst struct nlattr *a;\n\tint rem;\n\n\tmemset(&upcall, 0, sizeof(upcall));\n\tupcall.cmd = OVS_PACKET_CMD_ACTION;\n\tupcall.mru = OVS_CB(skb)->mru;\n\n\tfor (a = nla_data(attr), rem = nla_len(attr); rem > 0;\n\t     a = nla_next(a, &rem)) {\n\t\tswitch (nla_type(a)) {\n\t\tcase OVS_USERSPACE_ATTR_USERDATA:\n\t\t\tupcall.userdata = a;\n\t\t\tbreak;\n\n\t\tcase OVS_USERSPACE_ATTR_PID:\n\t\t\tif (dp->user_features &\n\t\t\t    OVS_DP_F_DISPATCH_UPCALL_PER_CPU)\n\t\t\t\tupcall.portid =\n\t\t\t\t  ovs_dp_get_upcall_portid(dp,\n\t\t\t\t\t\t\t   smp_processor_id());\n\t\t\telse\n\t\t\t\tupcall.portid = nla_get_u32(a);\n\t\t\tbreak;\n\n\t\tcase OVS_USERSPACE_ATTR_EGRESS_TUN_PORT: {\n\t\t\t \n\t\t\tstruct vport *vport;\n\n\t\t\tvport = ovs_vport_rcu(dp, nla_get_u32(a));\n\t\t\tif (vport) {\n\t\t\t\tint err;\n\n\t\t\t\terr = dev_fill_metadata_dst(vport->dev, skb);\n\t\t\t\tif (!err)\n\t\t\t\t\tupcall.egress_tun_info = skb_tunnel_info(skb);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_USERSPACE_ATTR_ACTIONS: {\n\t\t\t \n\t\t\tupcall.actions = actions;\n\t\t\tupcall.actions_len = actions_len;\n\t\t\tbreak;\n\t\t}\n\n\t\t}  \n\t}\n\n\treturn ovs_dp_upcall(dp, skb, key, &upcall, cutlen);\n}\n\nstatic int dec_ttl_exception_handler(struct datapath *dp, struct sk_buff *skb,\n\t\t\t\t     struct sw_flow_key *key,\n\t\t\t\t     const struct nlattr *attr)\n{\n\t \n\tstruct nlattr *actions = nla_data(attr);\n\n\tif (nla_len(actions))\n\t\treturn clone_execute(dp, skb, key, 0, nla_data(actions),\n\t\t\t\t     nla_len(actions), true, false);\n\n\tovs_kfree_skb_reason(skb, OVS_DROP_IP_TTL);\n\treturn 0;\n}\n\n \nstatic int sample(struct datapath *dp, struct sk_buff *skb,\n\t\t  struct sw_flow_key *key, const struct nlattr *attr,\n\t\t  bool last)\n{\n\tstruct nlattr *actions;\n\tstruct nlattr *sample_arg;\n\tint rem = nla_len(attr);\n\tconst struct sample_arg *arg;\n\tbool clone_flow_key;\n\n\t \n\tsample_arg = nla_data(attr);\n\targ = nla_data(sample_arg);\n\tactions = nla_next(sample_arg, &rem);\n\n\tif ((arg->probability != U32_MAX) &&\n\t    (!arg->probability || get_random_u32() > arg->probability)) {\n\t\tif (last)\n\t\t\tovs_kfree_skb_reason(skb, OVS_DROP_LAST_ACTION);\n\t\treturn 0;\n\t}\n\n\tclone_flow_key = !arg->exec;\n\treturn clone_execute(dp, skb, key, 0, actions, rem, last,\n\t\t\t     clone_flow_key);\n}\n\n \nstatic int clone(struct datapath *dp, struct sk_buff *skb,\n\t\t struct sw_flow_key *key, const struct nlattr *attr,\n\t\t bool last)\n{\n\tstruct nlattr *actions;\n\tstruct nlattr *clone_arg;\n\tint rem = nla_len(attr);\n\tbool dont_clone_flow_key;\n\n\t \n\tclone_arg = nla_data(attr);\n\tdont_clone_flow_key = nla_get_u32(clone_arg);\n\tactions = nla_next(clone_arg, &rem);\n\n\treturn clone_execute(dp, skb, key, 0, actions, rem, last,\n\t\t\t     !dont_clone_flow_key);\n}\n\nstatic void execute_hash(struct sk_buff *skb, struct sw_flow_key *key,\n\t\t\t const struct nlattr *attr)\n{\n\tstruct ovs_action_hash *hash_act = nla_data(attr);\n\tu32 hash = 0;\n\n\tif (hash_act->hash_alg == OVS_HASH_ALG_L4) {\n\t\t \n\t\thash = skb_get_hash(skb);\n\t} else if (hash_act->hash_alg == OVS_HASH_ALG_SYM_L4) {\n\t\t \n\t\thash = __skb_get_hash_symmetric(skb);\n\t}\n\n\thash = jhash_1word(hash, hash_act->hash_basis);\n\tif (!hash)\n\t\thash = 0x1;\n\n\tkey->ovs_flow_hash = hash;\n}\n\nstatic int execute_set_action(struct sk_buff *skb,\n\t\t\t      struct sw_flow_key *flow_key,\n\t\t\t      const struct nlattr *a)\n{\n\t \n\tif (nla_type(a) == OVS_KEY_ATTR_TUNNEL_INFO) {\n\t\tstruct ovs_tunnel_info *tun = nla_data(a);\n\n\t\tskb_dst_drop(skb);\n\t\tdst_hold((struct dst_entry *)tun->tun_dst);\n\t\tskb_dst_set(skb, (struct dst_entry *)tun->tun_dst);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \n#define get_mask(a, type) ((const type)nla_data(a) + 1)\n\nstatic int execute_masked_set_action(struct sk_buff *skb,\n\t\t\t\t     struct sw_flow_key *flow_key,\n\t\t\t\t     const struct nlattr *a)\n{\n\tint err = 0;\n\n\tswitch (nla_type(a)) {\n\tcase OVS_KEY_ATTR_PRIORITY:\n\t\tOVS_SET_MASKED(skb->priority, nla_get_u32(a),\n\t\t\t       *get_mask(a, u32 *));\n\t\tflow_key->phy.priority = skb->priority;\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_SKB_MARK:\n\t\tOVS_SET_MASKED(skb->mark, nla_get_u32(a), *get_mask(a, u32 *));\n\t\tflow_key->phy.skb_mark = skb->mark;\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_TUNNEL_INFO:\n\t\t \n\t\terr = -EINVAL;\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_ETHERNET:\n\t\terr = set_eth_addr(skb, flow_key, nla_data(a),\n\t\t\t\t   get_mask(a, struct ovs_key_ethernet *));\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_NSH:\n\t\terr = set_nsh(skb, flow_key, a);\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_IPV4:\n\t\terr = set_ipv4(skb, flow_key, nla_data(a),\n\t\t\t       get_mask(a, struct ovs_key_ipv4 *));\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_IPV6:\n\t\terr = set_ipv6(skb, flow_key, nla_data(a),\n\t\t\t       get_mask(a, struct ovs_key_ipv6 *));\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_TCP:\n\t\terr = set_tcp(skb, flow_key, nla_data(a),\n\t\t\t      get_mask(a, struct ovs_key_tcp *));\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_UDP:\n\t\terr = set_udp(skb, flow_key, nla_data(a),\n\t\t\t      get_mask(a, struct ovs_key_udp *));\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_SCTP:\n\t\terr = set_sctp(skb, flow_key, nla_data(a),\n\t\t\t       get_mask(a, struct ovs_key_sctp *));\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_MPLS:\n\t\terr = set_mpls(skb, flow_key, nla_data(a), get_mask(a,\n\t\t\t\t\t\t\t\t    __be32 *));\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_CT_STATE:\n\tcase OVS_KEY_ATTR_CT_ZONE:\n\tcase OVS_KEY_ATTR_CT_MARK:\n\tcase OVS_KEY_ATTR_CT_LABELS:\n\tcase OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4:\n\tcase OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int execute_recirc(struct datapath *dp, struct sk_buff *skb,\n\t\t\t  struct sw_flow_key *key,\n\t\t\t  const struct nlattr *a, bool last)\n{\n\tu32 recirc_id;\n\n\tif (!is_flow_key_valid(key)) {\n\t\tint err;\n\n\t\terr = ovs_flow_key_update(skb, key);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUG_ON(!is_flow_key_valid(key));\n\n\trecirc_id = nla_get_u32(a);\n\treturn clone_execute(dp, skb, key, recirc_id, NULL, 0, last, true);\n}\n\nstatic int execute_check_pkt_len(struct datapath *dp, struct sk_buff *skb,\n\t\t\t\t struct sw_flow_key *key,\n\t\t\t\t const struct nlattr *attr, bool last)\n{\n\tstruct ovs_skb_cb *ovs_cb = OVS_CB(skb);\n\tconst struct nlattr *actions, *cpl_arg;\n\tint len, max_len, rem = nla_len(attr);\n\tconst struct check_pkt_len_arg *arg;\n\tbool clone_flow_key;\n\n\t \n\tcpl_arg = nla_data(attr);\n\targ = nla_data(cpl_arg);\n\n\tlen = ovs_cb->mru ? ovs_cb->mru + skb->mac_len : skb->len;\n\tmax_len = arg->pkt_len;\n\n\tif ((skb_is_gso(skb) && skb_gso_validate_mac_len(skb, max_len)) ||\n\t    len <= max_len) {\n\t\t \n\t\tactions = nla_next(cpl_arg, &rem);\n\t\tclone_flow_key = !arg->exec_for_lesser_equal;\n\t} else {\n\t\t \n\t\tactions = nla_next(cpl_arg, &rem);\n\t\tactions = nla_next(actions, &rem);\n\t\tclone_flow_key = !arg->exec_for_greater;\n\t}\n\n\treturn clone_execute(dp, skb, key, 0, nla_data(actions),\n\t\t\t     nla_len(actions), last, clone_flow_key);\n}\n\nstatic int execute_dec_ttl(struct sk_buff *skb, struct sw_flow_key *key)\n{\n\tint err;\n\n\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tstruct ipv6hdr *nh;\n\n\t\terr = skb_ensure_writable(skb, skb_network_offset(skb) +\n\t\t\t\t\t  sizeof(*nh));\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\n\t\tnh = ipv6_hdr(skb);\n\n\t\tif (nh->hop_limit <= 1)\n\t\t\treturn -EHOSTUNREACH;\n\n\t\tkey->ip.ttl = --nh->hop_limit;\n\t} else if (skb->protocol == htons(ETH_P_IP)) {\n\t\tstruct iphdr *nh;\n\t\tu8 old_ttl;\n\n\t\terr = skb_ensure_writable(skb, skb_network_offset(skb) +\n\t\t\t\t\t  sizeof(*nh));\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\n\t\tnh = ip_hdr(skb);\n\t\tif (nh->ttl <= 1)\n\t\t\treturn -EHOSTUNREACH;\n\n\t\told_ttl = nh->ttl--;\n\t\tcsum_replace2(&nh->check, htons(old_ttl << 8),\n\t\t\t      htons(nh->ttl << 8));\n\t\tkey->ip.ttl = nh->ttl;\n\t}\n\treturn 0;\n}\n\n \nstatic int do_execute_actions(struct datapath *dp, struct sk_buff *skb,\n\t\t\t      struct sw_flow_key *key,\n\t\t\t      const struct nlattr *attr, int len)\n{\n\tconst struct nlattr *a;\n\tint rem;\n\n\tfor (a = attr, rem = len; rem > 0;\n\t     a = nla_next(a, &rem)) {\n\t\tint err = 0;\n\n\t\tif (trace_ovs_do_execute_action_enabled())\n\t\t\ttrace_ovs_do_execute_action(dp, skb, key, a, rem);\n\n\t\t \n\t\tswitch (nla_type(a)) {\n\t\tcase OVS_ACTION_ATTR_OUTPUT: {\n\t\t\tint port = nla_get_u32(a);\n\t\t\tstruct sk_buff *clone;\n\n\t\t\t \n\t\t\tif (nla_is_last(a, rem)) {\n\t\t\t\tdo_output(dp, skb, port, key);\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tclone = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (clone)\n\t\t\t\tdo_output(dp, clone, port, key);\n\t\t\tOVS_CB(skb)->cutlen = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_TRUNC: {\n\t\t\tstruct ovs_action_trunc *trunc = nla_data(a);\n\n\t\t\tif (skb->len > trunc->max_len)\n\t\t\t\tOVS_CB(skb)->cutlen = skb->len - trunc->max_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_USERSPACE:\n\t\t\toutput_userspace(dp, skb, key, a, attr,\n\t\t\t\t\t\t     len, OVS_CB(skb)->cutlen);\n\t\t\tOVS_CB(skb)->cutlen = 0;\n\t\t\tif (nla_is_last(a, rem)) {\n\t\t\t\tconsume_skb(skb);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_HASH:\n\t\t\texecute_hash(skb, key, a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_PUSH_MPLS: {\n\t\t\tstruct ovs_action_push_mpls *mpls = nla_data(a);\n\n\t\t\terr = push_mpls(skb, key, mpls->mpls_lse,\n\t\t\t\t\tmpls->mpls_ethertype, skb->mac_len);\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_ACTION_ATTR_ADD_MPLS: {\n\t\t\tstruct ovs_action_add_mpls *mpls = nla_data(a);\n\t\t\t__u16 mac_len = 0;\n\n\t\t\tif (mpls->tun_flags & OVS_MPLS_L3_TUNNEL_FLAG_MASK)\n\t\t\t\tmac_len = skb->mac_len;\n\n\t\t\terr = push_mpls(skb, key, mpls->mpls_lse,\n\t\t\t\t\tmpls->mpls_ethertype, mac_len);\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_ACTION_ATTR_POP_MPLS:\n\t\t\terr = pop_mpls(skb, key, nla_get_be16(a));\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_PUSH_VLAN:\n\t\t\terr = push_vlan(skb, key, nla_data(a));\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_POP_VLAN:\n\t\t\terr = pop_vlan(skb, key);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_RECIRC: {\n\t\t\tbool last = nla_is_last(a, rem);\n\n\t\t\terr = execute_recirc(dp, skb, key, a, last);\n\t\t\tif (last) {\n\t\t\t\t \n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_SET:\n\t\t\terr = execute_set_action(skb, key, nla_data(a));\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SET_MASKED:\n\t\tcase OVS_ACTION_ATTR_SET_TO_MASKED:\n\t\t\terr = execute_masked_set_action(skb, key, nla_data(a));\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SAMPLE: {\n\t\t\tbool last = nla_is_last(a, rem);\n\n\t\t\terr = sample(dp, skb, key, a, last);\n\t\t\tif (last)\n\t\t\t\treturn err;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_CT:\n\t\t\tif (!is_flow_key_valid(key)) {\n\t\t\t\terr = ovs_flow_key_update(skb, key);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\terr = ovs_ct_execute(ovs_dp_get_net(dp), skb, key,\n\t\t\t\t\t     nla_data(a));\n\n\t\t\t \n\t\t\tif (err)\n\t\t\t\treturn err == -EINPROGRESS ? 0 : err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CT_CLEAR:\n\t\t\terr = ovs_ct_clear(skb, key);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_PUSH_ETH:\n\t\t\terr = push_eth(skb, key, nla_data(a));\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_POP_ETH:\n\t\t\terr = pop_eth(skb, key);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_PUSH_NSH: {\n\t\t\tu8 buffer[NSH_HDR_MAX_LEN];\n\t\t\tstruct nshhdr *nh = (struct nshhdr *)buffer;\n\n\t\t\terr = nsh_hdr_from_nlattr(nla_data(a), nh,\n\t\t\t\t\t\t  NSH_HDR_MAX_LEN);\n\t\t\tif (unlikely(err))\n\t\t\t\tbreak;\n\t\t\terr = push_nsh(skb, key, nh);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_POP_NSH:\n\t\t\terr = pop_nsh(skb, key);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_METER:\n\t\t\tif (ovs_meter_execute(dp, skb, key, nla_get_u32(a))) {\n\t\t\t\tovs_kfree_skb_reason(skb, OVS_DROP_METER);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CLONE: {\n\t\t\tbool last = nla_is_last(a, rem);\n\n\t\t\terr = clone(dp, skb, key, a, last);\n\t\t\tif (last)\n\t\t\t\treturn err;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_CHECK_PKT_LEN: {\n\t\t\tbool last = nla_is_last(a, rem);\n\n\t\t\terr = execute_check_pkt_len(dp, skb, key, a, last);\n\t\t\tif (last)\n\t\t\t\treturn err;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_DEC_TTL:\n\t\t\terr = execute_dec_ttl(skb, key);\n\t\t\tif (err == -EHOSTUNREACH)\n\t\t\t\treturn dec_ttl_exception_handler(dp, skb,\n\t\t\t\t\t\t\t\t key, a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_DROP: {\n\t\t\tenum ovs_drop_reason reason = nla_get_u32(a)\n\t\t\t\t? OVS_DROP_EXPLICIT_WITH_ERROR\n\t\t\t\t: OVS_DROP_EXPLICIT;\n\n\t\t\tovs_kfree_skb_reason(skb, reason);\n\t\t\treturn 0;\n\t\t}\n\t\t}\n\n\t\tif (unlikely(err)) {\n\t\t\tovs_kfree_skb_reason(skb, OVS_DROP_ACTION_ERROR);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tovs_kfree_skb_reason(skb, OVS_DROP_LAST_ACTION);\n\treturn 0;\n}\n\n \nstatic int clone_execute(struct datapath *dp, struct sk_buff *skb,\n\t\t\t struct sw_flow_key *key, u32 recirc_id,\n\t\t\t const struct nlattr *actions, int len,\n\t\t\t bool last, bool clone_flow_key)\n{\n\tstruct deferred_action *da;\n\tstruct sw_flow_key *clone;\n\n\tskb = last ? skb : skb_clone(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tclone = clone_flow_key ? clone_key(key) : key;\n\tif (clone) {\n\t\tint err = 0;\n\n\t\tif (actions) {  \n\t\t\tif (clone_flow_key)\n\t\t\t\t__this_cpu_inc(exec_actions_level);\n\n\t\t\terr = do_execute_actions(dp, skb, clone,\n\t\t\t\t\t\t actions, len);\n\n\t\t\tif (clone_flow_key)\n\t\t\t\t__this_cpu_dec(exec_actions_level);\n\t\t} else {  \n\t\t\tclone->recirc_id = recirc_id;\n\t\t\tovs_dp_process_packet(skb, clone);\n\t\t}\n\t\treturn err;\n\t}\n\n\t \n\tda = add_deferred_actions(skb, key, actions, len);\n\tif (da) {\n\t\tif (!actions) {  \n\t\t\tkey = &da->pkt_key;\n\t\t\tkey->recirc_id = recirc_id;\n\t\t}\n\t} else {\n\t\t \n\t\tovs_kfree_skb_reason(skb, OVS_DROP_DEFERRED_LIMIT);\n\n\t\tif (net_ratelimit()) {\n\t\t\tif (actions) {  \n\t\t\t\tpr_warn(\"%s: deferred action limit reached, drop sample action\\n\",\n\t\t\t\t\tovs_dp_name(dp));\n\t\t\t} else {   \n\t\t\t\tpr_warn(\"%s: deferred action limit reached, drop recirc action (recirc_id=%#x)\\n\",\n\t\t\t\t\tovs_dp_name(dp), recirc_id);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void process_deferred_actions(struct datapath *dp)\n{\n\tstruct action_fifo *fifo = this_cpu_ptr(action_fifos);\n\n\t \n\tif (action_fifo_is_empty(fifo))\n\t\treturn;\n\n\t \n\tdo {\n\t\tstruct deferred_action *da = action_fifo_get(fifo);\n\t\tstruct sk_buff *skb = da->skb;\n\t\tstruct sw_flow_key *key = &da->pkt_key;\n\t\tconst struct nlattr *actions = da->actions;\n\t\tint actions_len = da->actions_len;\n\n\t\tif (actions)\n\t\t\tdo_execute_actions(dp, skb, key, actions, actions_len);\n\t\telse\n\t\t\tovs_dp_process_packet(skb, key);\n\t} while (!action_fifo_is_empty(fifo));\n\n\t \n\taction_fifo_init(fifo);\n}\n\n \nint ovs_execute_actions(struct datapath *dp, struct sk_buff *skb,\n\t\t\tconst struct sw_flow_actions *acts,\n\t\t\tstruct sw_flow_key *key)\n{\n\tint err, level;\n\n\tlevel = __this_cpu_inc_return(exec_actions_level);\n\tif (unlikely(level > OVS_RECURSION_LIMIT)) {\n\t\tnet_crit_ratelimited(\"ovs: recursion limit reached on datapath %s, probable configuration error\\n\",\n\t\t\t\t     ovs_dp_name(dp));\n\t\tovs_kfree_skb_reason(skb, OVS_DROP_RECURSION_LIMIT);\n\t\terr = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tOVS_CB(skb)->acts_origlen = acts->orig_len;\n\terr = do_execute_actions(dp, skb, key,\n\t\t\t\t acts->actions, acts->actions_len);\n\n\tif (level == 1)\n\t\tprocess_deferred_actions(dp);\n\nout:\n\t__this_cpu_dec(exec_actions_level);\n\treturn err;\n}\n\nint action_fifos_init(void)\n{\n\taction_fifos = alloc_percpu(struct action_fifo);\n\tif (!action_fifos)\n\t\treturn -ENOMEM;\n\n\tflow_keys = alloc_percpu(struct action_flow_keys);\n\tif (!flow_keys) {\n\t\tfree_percpu(action_fifos);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid action_fifos_exit(void)\n{\n\tfree_percpu(action_fifos);\n\tfree_percpu(flow_keys);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}