{
  "module_name": "eth.c",
  "hash_id": "da710a0ed6f57419914c7ead07cdbe87d9f2c816df226e1ab19337a6431b0037",
  "original_prompt": "Ingested from linux-6.6.14/net/ethernet/eth.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/ip.h>\n#include <linux/netdevice.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/if_ether.h>\n#include <linux/of_net.h>\n#include <linux/pci.h>\n#include <linux/property.h>\n#include <net/dst.h>\n#include <net/arp.h>\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/dsa.h>\n#include <net/flow_dissector.h>\n#include <net/gro.h>\n#include <linux/uaccess.h>\n#include <net/pkt_sched.h>\n\n \nint eth_header(struct sk_buff *skb, struct net_device *dev,\n\t       unsigned short type,\n\t       const void *daddr, const void *saddr, unsigned int len)\n{\n\tstruct ethhdr *eth = skb_push(skb, ETH_HLEN);\n\n\tif (type != ETH_P_802_3 && type != ETH_P_802_2)\n\t\teth->h_proto = htons(type);\n\telse\n\t\teth->h_proto = htons(len);\n\n\t \n\n\tif (!saddr)\n\t\tsaddr = dev->dev_addr;\n\tmemcpy(eth->h_source, saddr, ETH_ALEN);\n\n\tif (daddr) {\n\t\tmemcpy(eth->h_dest, daddr, ETH_ALEN);\n\t\treturn ETH_HLEN;\n\t}\n\n\t \n\n\tif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\n\t\teth_zero_addr(eth->h_dest);\n\t\treturn ETH_HLEN;\n\t}\n\n\treturn -ETH_HLEN;\n}\nEXPORT_SYMBOL(eth_header);\n\n \nu32 eth_get_headlen(const struct net_device *dev, const void *data, u32 len)\n{\n\tconst unsigned int flags = FLOW_DISSECTOR_F_PARSE_1ST_FRAG;\n\tconst struct ethhdr *eth = (const struct ethhdr *)data;\n\tstruct flow_keys_basic keys;\n\n\t \n\tif (unlikely(len < sizeof(*eth)))\n\t\treturn len;\n\n\t \n\tif (!skb_flow_dissect_flow_keys_basic(dev_net(dev), NULL, &keys, data,\n\t\t\t\t\t      eth->h_proto, sizeof(*eth),\n\t\t\t\t\t      len, flags))\n\t\treturn max_t(u32, keys.control.thoff, sizeof(*eth));\n\n\t \n\treturn min_t(u32, __skb_get_poff(NULL, data, &keys, len), len);\n}\nEXPORT_SYMBOL(eth_get_headlen);\n\n \n__be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tunsigned short _service_access_point;\n\tconst unsigned short *sap;\n\tconst struct ethhdr *eth;\n\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\n\teth = (struct ethhdr *)skb->data;\n\tskb_pull_inline(skb, ETH_HLEN);\n\n\tif (unlikely(!ether_addr_equal_64bits(eth->h_dest,\n\t\t\t\t\t      dev->dev_addr))) {\n\t\tif (unlikely(is_multicast_ether_addr_64bits(eth->h_dest))) {\n\t\t\tif (ether_addr_equal_64bits(eth->h_dest, dev->broadcast))\n\t\t\t\tskb->pkt_type = PACKET_BROADCAST;\n\t\t\telse\n\t\t\t\tskb->pkt_type = PACKET_MULTICAST;\n\t\t} else {\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t}\n\t}\n\n\t \n\tif (unlikely(netdev_uses_dsa(dev)))\n\t\treturn htons(ETH_P_XDSA);\n\n\tif (likely(eth_proto_is_802_3(eth->h_proto)))\n\t\treturn eth->h_proto;\n\n\t \n\tsap = skb_header_pointer(skb, 0, sizeof(*sap), &_service_access_point);\n\tif (sap && *sap == 0xFFFF)\n\t\treturn htons(ETH_P_802_3);\n\n\t \n\treturn htons(ETH_P_802_2);\n}\nEXPORT_SYMBOL(eth_type_trans);\n\n \nint eth_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tconst struct ethhdr *eth = eth_hdr(skb);\n\tmemcpy(haddr, eth->h_source, ETH_ALEN);\n\treturn ETH_ALEN;\n}\nEXPORT_SYMBOL(eth_header_parse);\n\n \nint eth_header_cache(const struct neighbour *neigh, struct hh_cache *hh, __be16 type)\n{\n\tstruct ethhdr *eth;\n\tconst struct net_device *dev = neigh->dev;\n\n\teth = (struct ethhdr *)\n\t    (((u8 *) hh->hh_data) + (HH_DATA_OFF(sizeof(*eth))));\n\n\tif (type == htons(ETH_P_802_3))\n\t\treturn -1;\n\n\teth->h_proto = type;\n\tmemcpy(eth->h_source, dev->dev_addr, ETH_ALEN);\n\tmemcpy(eth->h_dest, neigh->ha, ETH_ALEN);\n\n\t \n\tsmp_store_release(&hh->hh_len, ETH_HLEN);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(eth_header_cache);\n\n \nvoid eth_header_cache_update(struct hh_cache *hh,\n\t\t\t     const struct net_device *dev,\n\t\t\t     const unsigned char *haddr)\n{\n\tmemcpy(((u8 *) hh->hh_data) + HH_DATA_OFF(sizeof(struct ethhdr)),\n\t       haddr, ETH_ALEN);\n}\nEXPORT_SYMBOL(eth_header_cache_update);\n\n \n__be16 eth_header_parse_protocol(const struct sk_buff *skb)\n{\n\tconst struct ethhdr *eth = eth_hdr(skb);\n\n\treturn eth->h_proto;\n}\nEXPORT_SYMBOL(eth_header_parse_protocol);\n\n \nint eth_prepare_mac_addr_change(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\n\tif (!(dev->priv_flags & IFF_LIVE_ADDR_CHANGE) && netif_running(dev))\n\t\treturn -EBUSY;\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\treturn 0;\n}\nEXPORT_SYMBOL(eth_prepare_mac_addr_change);\n\n \nvoid eth_commit_mac_addr_change(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n}\nEXPORT_SYMBOL(eth_commit_mac_addr_change);\n\n \nint eth_mac_addr(struct net_device *dev, void *p)\n{\n\tint ret;\n\n\tret = eth_prepare_mac_addr_change(dev, p);\n\tif (ret < 0)\n\t\treturn ret;\n\teth_commit_mac_addr_change(dev, p);\n\treturn 0;\n}\nEXPORT_SYMBOL(eth_mac_addr);\n\nint eth_validate_addr(struct net_device *dev)\n{\n\tif (!is_valid_ether_addr(dev->dev_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(eth_validate_addr);\n\nconst struct header_ops eth_header_ops ____cacheline_aligned = {\n\t.create\t\t= eth_header,\n\t.parse\t\t= eth_header_parse,\n\t.cache\t\t= eth_header_cache,\n\t.cache_update\t= eth_header_cache_update,\n\t.parse_protocol\t= eth_header_parse_protocol,\n};\n\n \nvoid ether_setup(struct net_device *dev)\n{\n\tdev->header_ops\t\t= &eth_header_ops;\n\tdev->type\t\t= ARPHRD_ETHER;\n\tdev->hard_header_len \t= ETH_HLEN;\n\tdev->min_header_len\t= ETH_HLEN;\n\tdev->mtu\t\t= ETH_DATA_LEN;\n\tdev->min_mtu\t\t= ETH_MIN_MTU;\n\tdev->max_mtu\t\t= ETH_DATA_LEN;\n\tdev->addr_len\t\t= ETH_ALEN;\n\tdev->tx_queue_len\t= DEFAULT_TX_QUEUE_LEN;\n\tdev->flags\t\t= IFF_BROADCAST|IFF_MULTICAST;\n\tdev->priv_flags\t\t|= IFF_TX_SKB_SHARING;\n\n\teth_broadcast_addr(dev->broadcast);\n\n}\nEXPORT_SYMBOL(ether_setup);\n\n \n\nstruct net_device *alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs,\n\t\t\t\t      unsigned int rxqs)\n{\n\treturn alloc_netdev_mqs(sizeof_priv, \"eth%d\", NET_NAME_ENUM,\n\t\t\t\tether_setup, txqs, rxqs);\n}\nEXPORT_SYMBOL(alloc_etherdev_mqs);\n\nssize_t sysfs_format_mac(char *buf, const unsigned char *addr, int len)\n{\n\treturn sysfs_emit(buf, \"%*phC\\n\", len, addr);\n}\nEXPORT_SYMBOL(sysfs_format_mac);\n\nstruct sk_buff *eth_gro_receive(struct list_head *head, struct sk_buff *skb)\n{\n\tconst struct packet_offload *ptype;\n\tunsigned int hlen, off_eth;\n\tstruct sk_buff *pp = NULL;\n\tstruct ethhdr *eh, *eh2;\n\tstruct sk_buff *p;\n\t__be16 type;\n\tint flush = 1;\n\n\toff_eth = skb_gro_offset(skb);\n\thlen = off_eth + sizeof(*eh);\n\teh = skb_gro_header(skb, hlen, off_eth);\n\tif (unlikely(!eh))\n\t\tgoto out;\n\n\tflush = 0;\n\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\teh2 = (struct ethhdr *)(p->data + off_eth);\n\t\tif (compare_ether_header(eh, eh2)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\ttype = eh->h_proto;\n\n\tptype = gro_find_receive_by_type(type);\n\tif (ptype == NULL) {\n\t\tflush = 1;\n\t\tgoto out;\n\t}\n\n\tskb_gro_pull(skb, sizeof(*eh));\n\tskb_gro_postpull_rcsum(skb, eh, sizeof(*eh));\n\n\tpp = indirect_call_gro_receive_inet(ptype->callbacks.gro_receive,\n\t\t\t\t\t    ipv6_gro_receive, inet_gro_receive,\n\t\t\t\t\t    head, skb);\n\nout:\n\tskb_gro_flush_final(skb, pp, flush);\n\n\treturn pp;\n}\nEXPORT_SYMBOL(eth_gro_receive);\n\nint eth_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tstruct ethhdr *eh = (struct ethhdr *)(skb->data + nhoff);\n\t__be16 type = eh->h_proto;\n\tstruct packet_offload *ptype;\n\tint err = -ENOSYS;\n\n\tif (skb->encapsulation)\n\t\tskb_set_inner_mac_header(skb, nhoff);\n\n\tptype = gro_find_complete_by_type(type);\n\tif (ptype != NULL)\n\t\terr = INDIRECT_CALL_INET(ptype->callbacks.gro_complete,\n\t\t\t\t\t ipv6_gro_complete, inet_gro_complete,\n\t\t\t\t\t skb, nhoff + sizeof(*eh));\n\n\treturn err;\n}\nEXPORT_SYMBOL(eth_gro_complete);\n\nstatic struct packet_offload eth_packet_offload __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_TEB),\n\t.priority = 10,\n\t.callbacks = {\n\t\t.gro_receive = eth_gro_receive,\n\t\t.gro_complete = eth_gro_complete,\n\t},\n};\n\nstatic int __init eth_offload_init(void)\n{\n\tdev_add_offload(&eth_packet_offload);\n\n\treturn 0;\n}\n\nfs_initcall(eth_offload_init);\n\nunsigned char * __weak arch_get_platform_mac_address(void)\n{\n\treturn NULL;\n}\n\nint eth_platform_get_mac_address(struct device *dev, u8 *mac_addr)\n{\n\tunsigned char *addr;\n\tint ret;\n\n\tret = of_get_mac_address(dev->of_node, mac_addr);\n\tif (!ret)\n\t\treturn 0;\n\n\taddr = arch_get_platform_mac_address();\n\tif (!addr)\n\t\treturn -ENODEV;\n\n\tether_addr_copy(mac_addr, addr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(eth_platform_get_mac_address);\n\n \nint platform_get_ethdev_address(struct device *dev, struct net_device *netdev)\n{\n\tu8 addr[ETH_ALEN] __aligned(2);\n\tint ret;\n\n\tret = eth_platform_get_mac_address(dev, addr);\n\tif (!ret)\n\t\teth_hw_addr_set(netdev, addr);\n\treturn ret;\n}\nEXPORT_SYMBOL(platform_get_ethdev_address);\n\n \nint nvmem_get_mac_address(struct device *dev, void *addrbuf)\n{\n\tstruct nvmem_cell *cell;\n\tconst void *mac;\n\tsize_t len;\n\n\tcell = nvmem_cell_get(dev, \"mac-address\");\n\tif (IS_ERR(cell))\n\t\treturn PTR_ERR(cell);\n\n\tmac = nvmem_cell_read(cell, &len);\n\tnvmem_cell_put(cell);\n\n\tif (IS_ERR(mac))\n\t\treturn PTR_ERR(mac);\n\n\tif (len != ETH_ALEN || !is_valid_ether_addr(mac)) {\n\t\tkfree(mac);\n\t\treturn -EINVAL;\n\t}\n\n\tether_addr_copy(addrbuf, mac);\n\tkfree(mac);\n\n\treturn 0;\n}\n\nstatic int fwnode_get_mac_addr(struct fwnode_handle *fwnode,\n\t\t\t       const char *name, char *addr)\n{\n\tint ret;\n\n\tret = fwnode_property_read_u8_array(fwnode, name, addr, ETH_ALEN);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!is_valid_ether_addr(addr))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nint fwnode_get_mac_address(struct fwnode_handle *fwnode, char *addr)\n{\n\tif (!fwnode_get_mac_addr(fwnode, \"mac-address\", addr) ||\n\t    !fwnode_get_mac_addr(fwnode, \"local-mac-address\", addr) ||\n\t    !fwnode_get_mac_addr(fwnode, \"address\", addr))\n\t\treturn 0;\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL(fwnode_get_mac_address);\n\n \nint device_get_mac_address(struct device *dev, char *addr)\n{\n\treturn fwnode_get_mac_address(dev_fwnode(dev), addr);\n}\nEXPORT_SYMBOL(device_get_mac_address);\n\n \nint device_get_ethdev_address(struct device *dev, struct net_device *netdev)\n{\n\tu8 addr[ETH_ALEN];\n\tint ret;\n\n\tret = device_get_mac_address(dev, addr);\n\tif (!ret)\n\t\teth_hw_addr_set(netdev, addr);\n\treturn ret;\n}\nEXPORT_SYMBOL(device_get_ethdev_address);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}