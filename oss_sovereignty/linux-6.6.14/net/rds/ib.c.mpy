{
  "module_name": "ib.c",
  "hash_id": "6a95f58fb6a1b29e0abcf939696ef4d28ef714b04591c7e0c148310999c8fdcc",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/ib.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/in.h>\n#include <linux/if.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/if_arp.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <net/addrconf.h>\n\n#include \"rds_single_path.h\"\n#include \"rds.h\"\n#include \"ib.h\"\n#include \"ib_mr.h\"\n\nstatic unsigned int rds_ib_mr_1m_pool_size = RDS_MR_1M_POOL_SIZE;\nstatic unsigned int rds_ib_mr_8k_pool_size = RDS_MR_8K_POOL_SIZE;\nunsigned int rds_ib_retry_count = RDS_IB_DEFAULT_RETRY_COUNT;\nstatic atomic_t rds_ib_unloading;\n\nmodule_param(rds_ib_mr_1m_pool_size, int, 0444);\nMODULE_PARM_DESC(rds_ib_mr_1m_pool_size, \" Max number of 1M mr per HCA\");\nmodule_param(rds_ib_mr_8k_pool_size, int, 0444);\nMODULE_PARM_DESC(rds_ib_mr_8k_pool_size, \" Max number of 8K mr per HCA\");\nmodule_param(rds_ib_retry_count, int, 0444);\nMODULE_PARM_DESC(rds_ib_retry_count, \" Number of hw retries before reporting an error\");\n\n \nDECLARE_RWSEM(rds_ib_devices_lock);\nstruct list_head rds_ib_devices;\n\n \nDEFINE_SPINLOCK(ib_nodev_conns_lock);\nLIST_HEAD(ib_nodev_conns);\n\nstatic void rds_ib_nodev_connect(void)\n{\n\tstruct rds_ib_connection *ic;\n\n\tspin_lock(&ib_nodev_conns_lock);\n\tlist_for_each_entry(ic, &ib_nodev_conns, ib_node)\n\t\trds_conn_connect_if_down(ic->conn);\n\tspin_unlock(&ib_nodev_conns_lock);\n}\n\nstatic void rds_ib_dev_shutdown(struct rds_ib_device *rds_ibdev)\n{\n\tstruct rds_ib_connection *ic;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rds_ibdev->spinlock, flags);\n\tlist_for_each_entry(ic, &rds_ibdev->conn_list, ib_node)\n\t\trds_conn_path_drop(&ic->conn->c_path[0], true);\n\tspin_unlock_irqrestore(&rds_ibdev->spinlock, flags);\n}\n\n \nstatic void rds_ib_dev_free(struct work_struct *work)\n{\n\tstruct rds_ib_ipaddr *i_ipaddr, *i_next;\n\tstruct rds_ib_device *rds_ibdev = container_of(work,\n\t\t\t\t\tstruct rds_ib_device, free_work);\n\n\tif (rds_ibdev->mr_8k_pool)\n\t\trds_ib_destroy_mr_pool(rds_ibdev->mr_8k_pool);\n\tif (rds_ibdev->mr_1m_pool)\n\t\trds_ib_destroy_mr_pool(rds_ibdev->mr_1m_pool);\n\tif (rds_ibdev->pd)\n\t\tib_dealloc_pd(rds_ibdev->pd);\n\n\tlist_for_each_entry_safe(i_ipaddr, i_next, &rds_ibdev->ipaddr_list, list) {\n\t\tlist_del(&i_ipaddr->list);\n\t\tkfree(i_ipaddr);\n\t}\n\n\tkfree(rds_ibdev->vector_load);\n\n\tkfree(rds_ibdev);\n}\n\nvoid rds_ib_dev_put(struct rds_ib_device *rds_ibdev)\n{\n\tBUG_ON(refcount_read(&rds_ibdev->refcount) == 0);\n\tif (refcount_dec_and_test(&rds_ibdev->refcount))\n\t\tqueue_work(rds_wq, &rds_ibdev->free_work);\n}\n\nstatic int rds_ib_add_one(struct ib_device *device)\n{\n\tstruct rds_ib_device *rds_ibdev;\n\tint ret;\n\n\t \n\tif (device->node_type != RDMA_NODE_IB_CA)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!(device->attrs.device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS))\n\t\treturn -EOPNOTSUPP;\n\n\trds_ibdev = kzalloc_node(sizeof(struct rds_ib_device), GFP_KERNEL,\n\t\t\t\t ibdev_to_node(device));\n\tif (!rds_ibdev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&rds_ibdev->spinlock);\n\trefcount_set(&rds_ibdev->refcount, 1);\n\tINIT_WORK(&rds_ibdev->free_work, rds_ib_dev_free);\n\n\tINIT_LIST_HEAD(&rds_ibdev->ipaddr_list);\n\tINIT_LIST_HEAD(&rds_ibdev->conn_list);\n\n\trds_ibdev->max_wrs = device->attrs.max_qp_wr;\n\trds_ibdev->max_sge = min(device->attrs.max_send_sge, RDS_IB_MAX_SGE);\n\n\trds_ibdev->odp_capable =\n\t\t!!(device->attrs.kernel_cap_flags &\n\t\t   IBK_ON_DEMAND_PAGING) &&\n\t\t!!(device->attrs.odp_caps.per_transport_caps.rc_odp_caps &\n\t\t   IB_ODP_SUPPORT_WRITE) &&\n\t\t!!(device->attrs.odp_caps.per_transport_caps.rc_odp_caps &\n\t\t   IB_ODP_SUPPORT_READ);\n\n\trds_ibdev->max_1m_mrs = device->attrs.max_mr ?\n\t\tmin_t(unsigned int, (device->attrs.max_mr / 2),\n\t\t      rds_ib_mr_1m_pool_size) : rds_ib_mr_1m_pool_size;\n\n\trds_ibdev->max_8k_mrs = device->attrs.max_mr ?\n\t\tmin_t(unsigned int, ((device->attrs.max_mr / 2) * RDS_MR_8K_SCALE),\n\t\t      rds_ib_mr_8k_pool_size) : rds_ib_mr_8k_pool_size;\n\n\trds_ibdev->max_initiator_depth = device->attrs.max_qp_init_rd_atom;\n\trds_ibdev->max_responder_resources = device->attrs.max_qp_rd_atom;\n\n\trds_ibdev->vector_load = kcalloc(device->num_comp_vectors,\n\t\t\t\t\t sizeof(int),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!rds_ibdev->vector_load) {\n\t\tpr_err(\"RDS/IB: %s failed to allocate vector memory\\n\",\n\t\t\t__func__);\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\n\trds_ibdev->dev = device;\n\trds_ibdev->pd = ib_alloc_pd(device, 0);\n\tif (IS_ERR(rds_ibdev->pd)) {\n\t\tret = PTR_ERR(rds_ibdev->pd);\n\t\trds_ibdev->pd = NULL;\n\t\tgoto put_dev;\n\t}\n\n\trds_ibdev->mr_1m_pool =\n\t\trds_ib_create_mr_pool(rds_ibdev, RDS_IB_MR_1M_POOL);\n\tif (IS_ERR(rds_ibdev->mr_1m_pool)) {\n\t\tret = PTR_ERR(rds_ibdev->mr_1m_pool);\n\t\trds_ibdev->mr_1m_pool = NULL;\n\t\tgoto put_dev;\n\t}\n\n\trds_ibdev->mr_8k_pool =\n\t\trds_ib_create_mr_pool(rds_ibdev, RDS_IB_MR_8K_POOL);\n\tif (IS_ERR(rds_ibdev->mr_8k_pool)) {\n\t\tret = PTR_ERR(rds_ibdev->mr_8k_pool);\n\t\trds_ibdev->mr_8k_pool = NULL;\n\t\tgoto put_dev;\n\t}\n\n\trdsdebug(\"RDS/IB: max_mr = %d, max_wrs = %d, max_sge = %d, max_1m_mrs = %d, max_8k_mrs = %d\\n\",\n\t\t device->attrs.max_mr, rds_ibdev->max_wrs, rds_ibdev->max_sge,\n\t\t rds_ibdev->max_1m_mrs, rds_ibdev->max_8k_mrs);\n\n\tpr_info(\"RDS/IB: %s: added\\n\", device->name);\n\n\tdown_write(&rds_ib_devices_lock);\n\tlist_add_tail_rcu(&rds_ibdev->list, &rds_ib_devices);\n\tup_write(&rds_ib_devices_lock);\n\trefcount_inc(&rds_ibdev->refcount);\n\n\tib_set_client_data(device, &rds_ib_client, rds_ibdev);\n\n\trds_ib_nodev_connect();\n\treturn 0;\n\nput_dev:\n\trds_ib_dev_put(rds_ibdev);\n\treturn ret;\n}\n\n \nstruct rds_ib_device *rds_ib_get_client_data(struct ib_device *device)\n{\n\tstruct rds_ib_device *rds_ibdev;\n\n\trcu_read_lock();\n\trds_ibdev = ib_get_client_data(device, &rds_ib_client);\n\tif (rds_ibdev)\n\t\trefcount_inc(&rds_ibdev->refcount);\n\trcu_read_unlock();\n\treturn rds_ibdev;\n}\n\n \nstatic void rds_ib_remove_one(struct ib_device *device, void *client_data)\n{\n\tstruct rds_ib_device *rds_ibdev = client_data;\n\n\trds_ib_dev_shutdown(rds_ibdev);\n\n\t \n\tib_set_client_data(device, &rds_ib_client, NULL);\n\n\tdown_write(&rds_ib_devices_lock);\n\tlist_del_rcu(&rds_ibdev->list);\n\tup_write(&rds_ib_devices_lock);\n\n\t \n\tsynchronize_rcu();\n\trds_ib_dev_put(rds_ibdev);\n\trds_ib_dev_put(rds_ibdev);\n}\n\nstruct ib_client rds_ib_client = {\n\t.name   = \"rds_ib\",\n\t.add    = rds_ib_add_one,\n\t.remove = rds_ib_remove_one\n};\n\nstatic int rds_ib_conn_info_visitor(struct rds_connection *conn,\n\t\t\t\t    void *buffer)\n{\n\tstruct rds_info_rdma_connection *iinfo = buffer;\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\t \n\tif (conn->c_trans != &rds_ib_transport)\n\t\treturn 0;\n\tif (conn->c_isv6)\n\t\treturn 0;\n\n\tiinfo->src_addr = conn->c_laddr.s6_addr32[3];\n\tiinfo->dst_addr = conn->c_faddr.s6_addr32[3];\n\tif (ic) {\n\t\tiinfo->tos = conn->c_tos;\n\t\tiinfo->sl = ic->i_sl;\n\t}\n\n\tmemset(&iinfo->src_gid, 0, sizeof(iinfo->src_gid));\n\tmemset(&iinfo->dst_gid, 0, sizeof(iinfo->dst_gid));\n\tif (rds_conn_state(conn) == RDS_CONN_UP) {\n\t\tstruct rds_ib_device *rds_ibdev;\n\n\t\trdma_read_gids(ic->i_cm_id, (union ib_gid *)&iinfo->src_gid,\n\t\t\t       (union ib_gid *)&iinfo->dst_gid);\n\n\t\trds_ibdev = ic->rds_ibdev;\n\t\tiinfo->max_send_wr = ic->i_send_ring.w_nr;\n\t\tiinfo->max_recv_wr = ic->i_recv_ring.w_nr;\n\t\tiinfo->max_send_sge = rds_ibdev->max_sge;\n\t\trds_ib_get_mr_info(rds_ibdev, iinfo);\n\t\tiinfo->cache_allocs = atomic_read(&ic->i_cache_allocs);\n\t}\n\treturn 1;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstatic int rds6_ib_conn_info_visitor(struct rds_connection *conn,\n\t\t\t\t     void *buffer)\n{\n\tstruct rds6_info_rdma_connection *iinfo6 = buffer;\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\t \n\tif (conn->c_trans != &rds_ib_transport)\n\t\treturn 0;\n\n\tiinfo6->src_addr = conn->c_laddr;\n\tiinfo6->dst_addr = conn->c_faddr;\n\tif (ic) {\n\t\tiinfo6->tos = conn->c_tos;\n\t\tiinfo6->sl = ic->i_sl;\n\t}\n\n\tmemset(&iinfo6->src_gid, 0, sizeof(iinfo6->src_gid));\n\tmemset(&iinfo6->dst_gid, 0, sizeof(iinfo6->dst_gid));\n\n\tif (rds_conn_state(conn) == RDS_CONN_UP) {\n\t\tstruct rds_ib_device *rds_ibdev;\n\n\t\trdma_read_gids(ic->i_cm_id, (union ib_gid *)&iinfo6->src_gid,\n\t\t\t       (union ib_gid *)&iinfo6->dst_gid);\n\t\trds_ibdev = ic->rds_ibdev;\n\t\tiinfo6->max_send_wr = ic->i_send_ring.w_nr;\n\t\tiinfo6->max_recv_wr = ic->i_recv_ring.w_nr;\n\t\tiinfo6->max_send_sge = rds_ibdev->max_sge;\n\t\trds6_ib_get_mr_info(rds_ibdev, iinfo6);\n\t\tiinfo6->cache_allocs = atomic_read(&ic->i_cache_allocs);\n\t}\n\treturn 1;\n}\n#endif\n\nstatic void rds_ib_ic_info(struct socket *sock, unsigned int len,\n\t\t\t   struct rds_info_iterator *iter,\n\t\t\t   struct rds_info_lengths *lens)\n{\n\tu64 buffer[(sizeof(struct rds_info_rdma_connection) + 7) / 8];\n\n\trds_for_each_conn_info(sock, len, iter, lens,\n\t\t\t\trds_ib_conn_info_visitor,\n\t\t\t\tbuffer,\n\t\t\t\tsizeof(struct rds_info_rdma_connection));\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstatic void rds6_ib_ic_info(struct socket *sock, unsigned int len,\n\t\t\t    struct rds_info_iterator *iter,\n\t\t\t    struct rds_info_lengths *lens)\n{\n\tu64 buffer[(sizeof(struct rds6_info_rdma_connection) + 7) / 8];\n\n\trds_for_each_conn_info(sock, len, iter, lens,\n\t\t\t       rds6_ib_conn_info_visitor,\n\t\t\t       buffer,\n\t\t\t       sizeof(struct rds6_info_rdma_connection));\n}\n#endif\n\n \nstatic int rds_ib_laddr_check(struct net *net, const struct in6_addr *addr,\n\t\t\t      __u32 scope_id)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 sin6;\n#endif\n\tstruct sockaddr_in sin;\n\tstruct sockaddr *sa;\n\tbool isv4;\n\n\tisv4 = ipv6_addr_v4mapped(addr);\n\t \n\tcm_id = rdma_create_id(&init_net, rds_rdma_cm_event_handler,\n\t\t\t       NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\n\tif (isv4) {\n\t\tmemset(&sin, 0, sizeof(sin));\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = addr->s6_addr32[3];\n\t\tsa = (struct sockaddr *)&sin;\n\t} else {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tmemset(&sin6, 0, sizeof(sin6));\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_addr = *addr;\n\t\tsin6.sin6_scope_id = scope_id;\n\t\tsa = (struct sockaddr *)&sin6;\n\n\t\t \n\t\tif (ipv6_addr_type(addr) & IPV6_ADDR_LINKLOCAL) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tif (scope_id == 0) {\n\t\t\t\tret = -EADDRNOTAVAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tdev = dev_get_by_index(&init_net, scope_id);\n\t\t\tif (!dev) {\n\t\t\t\tret = -EADDRNOTAVAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!ipv6_chk_addr(&init_net, addr, dev, 1)) {\n\t\t\t\tdev_put(dev);\n\t\t\t\tret = -EADDRNOTAVAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdev_put(dev);\n\t\t}\n#else\n\t\tret = -EADDRNOTAVAIL;\n\t\tgoto out;\n#endif\n\t}\n\n\t \n\tret = rdma_bind_addr(cm_id, sa);\n\t \n\tif (ret || !cm_id->device ||\n\t    cm_id->device->node_type != RDMA_NODE_IB_CA)\n\t\tret = -EADDRNOTAVAIL;\n\n\trdsdebug(\"addr %pI6c%%%u ret %d node type %d\\n\",\n\t\t addr, scope_id, ret,\n\t\t cm_id->device ? cm_id->device->node_type : -1);\n\nout:\n\trdma_destroy_id(cm_id);\n\n\treturn ret;\n}\n\nstatic void rds_ib_unregister_client(void)\n{\n\tib_unregister_client(&rds_ib_client);\n\t \n\tflush_workqueue(rds_wq);\n}\n\nstatic void rds_ib_set_unloading(void)\n{\n\tatomic_set(&rds_ib_unloading, 1);\n}\n\nstatic bool rds_ib_is_unloading(struct rds_connection *conn)\n{\n\tstruct rds_conn_path *cp = &conn->c_path[0];\n\n\treturn (test_bit(RDS_DESTROY_PENDING, &cp->cp_flags) ||\n\t\tatomic_read(&rds_ib_unloading) != 0);\n}\n\nvoid rds_ib_exit(void)\n{\n\trds_ib_set_unloading();\n\tsynchronize_rcu();\n\trds_info_deregister_func(RDS_INFO_IB_CONNECTIONS, rds_ib_ic_info);\n#if IS_ENABLED(CONFIG_IPV6)\n\trds_info_deregister_func(RDS6_INFO_IB_CONNECTIONS, rds6_ib_ic_info);\n#endif\n\trds_ib_unregister_client();\n\trds_ib_destroy_nodev_conns();\n\trds_ib_sysctl_exit();\n\trds_ib_recv_exit();\n\trds_trans_unregister(&rds_ib_transport);\n\trds_ib_mr_exit();\n}\n\nstatic u8 rds_ib_get_tos_map(u8 tos)\n{\n\t \n\treturn tos;\n}\n\nstruct rds_transport rds_ib_transport = {\n\t.laddr_check\t\t= rds_ib_laddr_check,\n\t.xmit_path_complete\t= rds_ib_xmit_path_complete,\n\t.xmit\t\t\t= rds_ib_xmit,\n\t.xmit_rdma\t\t= rds_ib_xmit_rdma,\n\t.xmit_atomic\t\t= rds_ib_xmit_atomic,\n\t.recv_path\t\t= rds_ib_recv_path,\n\t.conn_alloc\t\t= rds_ib_conn_alloc,\n\t.conn_free\t\t= rds_ib_conn_free,\n\t.conn_path_connect\t= rds_ib_conn_path_connect,\n\t.conn_path_shutdown\t= rds_ib_conn_path_shutdown,\n\t.inc_copy_to_user\t= rds_ib_inc_copy_to_user,\n\t.inc_free\t\t= rds_ib_inc_free,\n\t.cm_initiate_connect\t= rds_ib_cm_initiate_connect,\n\t.cm_handle_connect\t= rds_ib_cm_handle_connect,\n\t.cm_connect_complete\t= rds_ib_cm_connect_complete,\n\t.stats_info_copy\t= rds_ib_stats_info_copy,\n\t.exit\t\t\t= rds_ib_exit,\n\t.get_mr\t\t\t= rds_ib_get_mr,\n\t.sync_mr\t\t= rds_ib_sync_mr,\n\t.free_mr\t\t= rds_ib_free_mr,\n\t.flush_mrs\t\t= rds_ib_flush_mrs,\n\t.get_tos_map\t\t= rds_ib_get_tos_map,\n\t.t_owner\t\t= THIS_MODULE,\n\t.t_name\t\t\t= \"infiniband\",\n\t.t_unloading\t\t= rds_ib_is_unloading,\n\t.t_type\t\t\t= RDS_TRANS_IB\n};\n\nint rds_ib_init(void)\n{\n\tint ret;\n\n\tINIT_LIST_HEAD(&rds_ib_devices);\n\n\tret = rds_ib_mr_init();\n\tif (ret)\n\t\tgoto out;\n\n\tret = ib_register_client(&rds_ib_client);\n\tif (ret)\n\t\tgoto out_mr_exit;\n\n\tret = rds_ib_sysctl_init();\n\tif (ret)\n\t\tgoto out_ibreg;\n\n\tret = rds_ib_recv_init();\n\tif (ret)\n\t\tgoto out_sysctl;\n\n\trds_trans_register(&rds_ib_transport);\n\n\trds_info_register_func(RDS_INFO_IB_CONNECTIONS, rds_ib_ic_info);\n#if IS_ENABLED(CONFIG_IPV6)\n\trds_info_register_func(RDS6_INFO_IB_CONNECTIONS, rds6_ib_ic_info);\n#endif\n\n\tgoto out;\n\nout_sysctl:\n\trds_ib_sysctl_exit();\nout_ibreg:\n\trds_ib_unregister_client();\nout_mr_exit:\n\trds_ib_mr_exit();\nout:\n\treturn ret;\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}