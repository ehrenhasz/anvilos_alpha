{
  "module_name": "ib_frmr.c",
  "hash_id": "62719ecaf364a92dc2f3be2274625f2d8d16111f1e7dc11d872150e3f36e69ac",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/ib_frmr.c",
  "human_readable_source": " \n\n#include \"ib_mr.h\"\n\nstatic inline void\nrds_transition_frwr_state(struct rds_ib_mr *ibmr,\n\t\t\t  enum rds_ib_fr_state old_state,\n\t\t\t  enum rds_ib_fr_state new_state)\n{\n\tif (cmpxchg(&ibmr->u.frmr.fr_state,\n\t\t    old_state, new_state) == old_state &&\n\t    old_state == FRMR_IS_INUSE) {\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tatomic_dec(&ibmr->ic->i_fastreg_inuse_count);\n\t\tif (waitqueue_active(&rds_ib_ring_empty_wait))\n\t\t\twake_up(&rds_ib_ring_empty_wait);\n\t}\n}\n\nstatic struct rds_ib_mr *rds_ib_alloc_frmr(struct rds_ib_device *rds_ibdev,\n\t\t\t\t\t   int npages)\n{\n\tstruct rds_ib_mr_pool *pool;\n\tstruct rds_ib_mr *ibmr = NULL;\n\tstruct rds_ib_frmr *frmr;\n\tint err = 0;\n\n\tif (npages <= RDS_MR_8K_MSG_SIZE)\n\t\tpool = rds_ibdev->mr_8k_pool;\n\telse\n\t\tpool = rds_ibdev->mr_1m_pool;\n\n\tibmr = rds_ib_try_reuse_ibmr(pool);\n\tif (ibmr)\n\t\treturn ibmr;\n\n\tibmr = kzalloc_node(sizeof(*ibmr), GFP_KERNEL,\n\t\t\t    rdsibdev_to_node(rds_ibdev));\n\tif (!ibmr) {\n\t\terr = -ENOMEM;\n\t\tgoto out_no_cigar;\n\t}\n\n\tfrmr = &ibmr->u.frmr;\n\tfrmr->mr = ib_alloc_mr(rds_ibdev->pd, IB_MR_TYPE_MEM_REG,\n\t\t\t pool->max_pages);\n\tif (IS_ERR(frmr->mr)) {\n\t\tpr_warn(\"RDS/IB: %s failed to allocate MR\", __func__);\n\t\terr = PTR_ERR(frmr->mr);\n\t\tgoto out_no_cigar;\n\t}\n\n\tibmr->pool = pool;\n\tif (pool->pool_type == RDS_IB_MR_8K_POOL)\n\t\trds_ib_stats_inc(s_ib_rdma_mr_8k_alloc);\n\telse\n\t\trds_ib_stats_inc(s_ib_rdma_mr_1m_alloc);\n\n\tif (atomic_read(&pool->item_count) > pool->max_items_soft)\n\t\tpool->max_items_soft = pool->max_items;\n\n\tfrmr->fr_state = FRMR_IS_FREE;\n\tinit_waitqueue_head(&frmr->fr_inv_done);\n\tinit_waitqueue_head(&frmr->fr_reg_done);\n\treturn ibmr;\n\nout_no_cigar:\n\tkfree(ibmr);\n\tatomic_dec(&pool->item_count);\n\treturn ERR_PTR(err);\n}\n\nstatic void rds_ib_free_frmr(struct rds_ib_mr *ibmr, bool drop)\n{\n\tstruct rds_ib_mr_pool *pool = ibmr->pool;\n\n\tif (drop)\n\t\tllist_add(&ibmr->llnode, &pool->drop_list);\n\telse\n\t\tllist_add(&ibmr->llnode, &pool->free_list);\n\tatomic_add(ibmr->sg_len, &pool->free_pinned);\n\tatomic_inc(&pool->dirty_count);\n\n\t \n\tif (atomic_read(&pool->free_pinned) >= pool->max_free_pinned ||\n\t    atomic_read(&pool->dirty_count) >= pool->max_items / 5)\n\t\tqueue_delayed_work(rds_ib_mr_wq, &pool->flush_worker, 10);\n}\n\nstatic int rds_ib_post_reg_frmr(struct rds_ib_mr *ibmr)\n{\n\tstruct rds_ib_frmr *frmr = &ibmr->u.frmr;\n\tstruct ib_reg_wr reg_wr;\n\tint ret, off = 0;\n\n\twhile (atomic_dec_return(&ibmr->ic->i_fastreg_wrs) <= 0) {\n\t\tatomic_inc(&ibmr->ic->i_fastreg_wrs);\n\t\tcpu_relax();\n\t}\n\n\tret = ib_map_mr_sg_zbva(frmr->mr, ibmr->sg, ibmr->sg_dma_len,\n\t\t\t\t&off, PAGE_SIZE);\n\tif (unlikely(ret != ibmr->sg_dma_len))\n\t\treturn ret < 0 ? ret : -EINVAL;\n\n\tif (cmpxchg(&frmr->fr_state,\n\t\t    FRMR_IS_FREE, FRMR_IS_INUSE) != FRMR_IS_FREE)\n\t\treturn -EBUSY;\n\n\tatomic_inc(&ibmr->ic->i_fastreg_inuse_count);\n\n\t \n\tib_update_fast_reg_key(frmr->mr, ibmr->remap_count++);\n\tfrmr->fr_reg = true;\n\n\tmemset(&reg_wr, 0, sizeof(reg_wr));\n\treg_wr.wr.wr_id = (unsigned long)(void *)ibmr;\n\treg_wr.wr.opcode = IB_WR_REG_MR;\n\treg_wr.wr.num_sge = 0;\n\treg_wr.mr = frmr->mr;\n\treg_wr.key = frmr->mr->rkey;\n\treg_wr.access = IB_ACCESS_LOCAL_WRITE |\n\t\t\tIB_ACCESS_REMOTE_READ |\n\t\t\tIB_ACCESS_REMOTE_WRITE;\n\treg_wr.wr.send_flags = IB_SEND_SIGNALED;\n\n\tret = ib_post_send(ibmr->ic->i_cm_id->qp, &reg_wr.wr, NULL);\n\tif (unlikely(ret)) {\n\t\t \n\t\trds_transition_frwr_state(ibmr, FRMR_IS_INUSE, FRMR_IS_STALE);\n\n\t\tatomic_inc(&ibmr->ic->i_fastreg_wrs);\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"RDS/IB: %s returned error(%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto out;\n\t}\n\n\t \n\twait_event(frmr->fr_reg_done, !frmr->fr_reg);\n\nout:\n\n\treturn ret;\n}\n\nstatic int rds_ib_map_frmr(struct rds_ib_device *rds_ibdev,\n\t\t\t   struct rds_ib_mr_pool *pool,\n\t\t\t   struct rds_ib_mr *ibmr,\n\t\t\t   struct scatterlist *sg, unsigned int sg_len)\n{\n\tstruct ib_device *dev = rds_ibdev->dev;\n\tstruct rds_ib_frmr *frmr = &ibmr->u.frmr;\n\tint i;\n\tu32 len;\n\tint ret = 0;\n\n\t \n\trds_ib_teardown_mr(ibmr);\n\n\tibmr->sg = sg;\n\tibmr->sg_len = sg_len;\n\tibmr->sg_dma_len = 0;\n\tfrmr->sg_byte_len = 0;\n\tWARN_ON(ibmr->sg_dma_len);\n\tibmr->sg_dma_len = ib_dma_map_sg(dev, ibmr->sg, ibmr->sg_len,\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\tif (unlikely(!ibmr->sg_dma_len)) {\n\t\tpr_warn(\"RDS/IB: %s failed!\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tfrmr->sg_byte_len = 0;\n\tfrmr->dma_npages = 0;\n\tlen = 0;\n\n\tret = -EINVAL;\n\tfor (i = 0; i < ibmr->sg_dma_len; ++i) {\n\t\tunsigned int dma_len = sg_dma_len(&ibmr->sg[i]);\n\t\tu64 dma_addr = sg_dma_address(&ibmr->sg[i]);\n\n\t\tfrmr->sg_byte_len += dma_len;\n\t\tif (dma_addr & ~PAGE_MASK) {\n\t\t\tif (i > 0)\n\t\t\t\tgoto out_unmap;\n\t\t\telse\n\t\t\t\t++frmr->dma_npages;\n\t\t}\n\n\t\tif ((dma_addr + dma_len) & ~PAGE_MASK) {\n\t\t\tif (i < ibmr->sg_dma_len - 1)\n\t\t\t\tgoto out_unmap;\n\t\t\telse\n\t\t\t\t++frmr->dma_npages;\n\t\t}\n\n\t\tlen += dma_len;\n\t}\n\tfrmr->dma_npages += len >> PAGE_SHIFT;\n\n\tif (frmr->dma_npages > ibmr->pool->max_pages) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out_unmap;\n\t}\n\n\tret = rds_ib_post_reg_frmr(ibmr);\n\tif (ret)\n\t\tgoto out_unmap;\n\n\tif (ibmr->pool->pool_type == RDS_IB_MR_8K_POOL)\n\t\trds_ib_stats_inc(s_ib_rdma_mr_8k_used);\n\telse\n\t\trds_ib_stats_inc(s_ib_rdma_mr_1m_used);\n\n\treturn ret;\n\nout_unmap:\n\tib_dma_unmap_sg(rds_ibdev->dev, ibmr->sg, ibmr->sg_len,\n\t\t\tDMA_BIDIRECTIONAL);\n\tibmr->sg_dma_len = 0;\n\treturn ret;\n}\n\nstatic int rds_ib_post_inv(struct rds_ib_mr *ibmr)\n{\n\tstruct ib_send_wr *s_wr;\n\tstruct rds_ib_frmr *frmr = &ibmr->u.frmr;\n\tstruct rdma_cm_id *i_cm_id = ibmr->ic->i_cm_id;\n\tint ret = -EINVAL;\n\n\tif (!i_cm_id || !i_cm_id->qp || !frmr->mr)\n\t\tgoto out;\n\n\tif (frmr->fr_state != FRMR_IS_INUSE)\n\t\tgoto out;\n\n\twhile (atomic_dec_return(&ibmr->ic->i_fastreg_wrs) <= 0) {\n\t\tatomic_inc(&ibmr->ic->i_fastreg_wrs);\n\t\tcpu_relax();\n\t}\n\n\tfrmr->fr_inv = true;\n\ts_wr = &frmr->fr_wr;\n\n\tmemset(s_wr, 0, sizeof(*s_wr));\n\ts_wr->wr_id = (unsigned long)(void *)ibmr;\n\ts_wr->opcode = IB_WR_LOCAL_INV;\n\ts_wr->ex.invalidate_rkey = frmr->mr->rkey;\n\ts_wr->send_flags = IB_SEND_SIGNALED;\n\n\tret = ib_post_send(i_cm_id->qp, s_wr, NULL);\n\tif (unlikely(ret)) {\n\t\trds_transition_frwr_state(ibmr, FRMR_IS_INUSE, FRMR_IS_STALE);\n\t\tfrmr->fr_inv = false;\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tatomic_inc(&ibmr->ic->i_fastreg_wrs);\n\t\tpr_err(\"RDS/IB: %s returned error(%d)\\n\", __func__, ret);\n\t\tgoto out;\n\t}\n\n\t \n\twait_event(frmr->fr_inv_done, frmr->fr_state != FRMR_IS_INUSE);\n\nout:\n\treturn ret;\n}\n\nvoid rds_ib_mr_cqe_handler(struct rds_ib_connection *ic, struct ib_wc *wc)\n{\n\tstruct rds_ib_mr *ibmr = (void *)(unsigned long)wc->wr_id;\n\tstruct rds_ib_frmr *frmr = &ibmr->u.frmr;\n\n\tif (wc->status != IB_WC_SUCCESS) {\n\t\trds_transition_frwr_state(ibmr, FRMR_IS_INUSE, FRMR_IS_STALE);\n\t\tif (rds_conn_up(ic->conn))\n\t\t\trds_ib_conn_error(ic->conn,\n\t\t\t\t\t  \"frmr completion <%pI4,%pI4> status %u(%s), vendor_err 0x%x, disconnecting and reconnecting\\n\",\n\t\t\t\t\t  &ic->conn->c_laddr,\n\t\t\t\t\t  &ic->conn->c_faddr,\n\t\t\t\t\t  wc->status,\n\t\t\t\t\t  ib_wc_status_msg(wc->status),\n\t\t\t\t\t  wc->vendor_err);\n\t}\n\n\tif (frmr->fr_inv) {\n\t\trds_transition_frwr_state(ibmr, FRMR_IS_INUSE, FRMR_IS_FREE);\n\t\tfrmr->fr_inv = false;\n\t\twake_up(&frmr->fr_inv_done);\n\t}\n\n\tif (frmr->fr_reg) {\n\t\tfrmr->fr_reg = false;\n\t\twake_up(&frmr->fr_reg_done);\n\t}\n\n\t \n\tsmp_mb__before_atomic();\n\tatomic_inc(&ic->i_fastreg_wrs);\n}\n\nvoid rds_ib_unreg_frmr(struct list_head *list, unsigned int *nfreed,\n\t\t       unsigned long *unpinned, unsigned int goal)\n{\n\tstruct rds_ib_mr *ibmr, *next;\n\tstruct rds_ib_frmr *frmr;\n\tint ret = 0, ret2;\n\tunsigned int freed = *nfreed;\n\n\t \n\tlist_for_each_entry(ibmr, list, unmap_list) {\n\t\tif (ibmr->sg_dma_len) {\n\t\t\tret2 = rds_ib_post_inv(ibmr);\n\t\t\tif (ret2 && !ret)\n\t\t\t\tret = ret2;\n\t\t}\n\t}\n\n\tif (ret)\n\t\tpr_warn(\"RDS/IB: %s failed (err=%d)\\n\", __func__, ret);\n\n\t \n\tlist_for_each_entry_safe(ibmr, next, list, unmap_list) {\n\t\t*unpinned += ibmr->sg_len;\n\t\tfrmr = &ibmr->u.frmr;\n\t\t__rds_ib_teardown_mr(ibmr);\n\t\tif (freed < goal || frmr->fr_state == FRMR_IS_STALE) {\n\t\t\t \n\t\t\tif (frmr->fr_state == FRMR_IS_INUSE)\n\t\t\t\tcontinue;\n\n\t\t\tif (ibmr->pool->pool_type == RDS_IB_MR_8K_POOL)\n\t\t\t\trds_ib_stats_inc(s_ib_rdma_mr_8k_free);\n\t\t\telse\n\t\t\t\trds_ib_stats_inc(s_ib_rdma_mr_1m_free);\n\t\t\tlist_del(&ibmr->unmap_list);\n\t\t\tif (frmr->mr)\n\t\t\t\tib_dereg_mr(frmr->mr);\n\t\t\tkfree(ibmr);\n\t\t\tfreed++;\n\t\t}\n\t}\n\t*nfreed = freed;\n}\n\nstruct rds_ib_mr *rds_ib_reg_frmr(struct rds_ib_device *rds_ibdev,\n\t\t\t\t  struct rds_ib_connection *ic,\n\t\t\t\t  struct scatterlist *sg,\n\t\t\t\t  unsigned long nents, u32 *key)\n{\n\tstruct rds_ib_mr *ibmr = NULL;\n\tstruct rds_ib_frmr *frmr;\n\tint ret;\n\n\tif (!ic) {\n\t\t \n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tdo {\n\t\tif (ibmr)\n\t\t\trds_ib_free_frmr(ibmr, true);\n\t\tibmr = rds_ib_alloc_frmr(rds_ibdev, nents);\n\t\tif (IS_ERR(ibmr))\n\t\t\treturn ibmr;\n\t\tfrmr = &ibmr->u.frmr;\n\t} while (frmr->fr_state != FRMR_IS_FREE);\n\n\tibmr->ic = ic;\n\tibmr->device = rds_ibdev;\n\tret = rds_ib_map_frmr(rds_ibdev, ibmr->pool, ibmr, sg, nents);\n\tif (ret == 0) {\n\t\t*key = frmr->mr->rkey;\n\t} else {\n\t\trds_ib_free_frmr(ibmr, false);\n\t\tibmr = ERR_PTR(ret);\n\t}\n\n\treturn ibmr;\n}\n\nvoid rds_ib_free_frmr_list(struct rds_ib_mr *ibmr)\n{\n\tstruct rds_ib_mr_pool *pool = ibmr->pool;\n\tstruct rds_ib_frmr *frmr = &ibmr->u.frmr;\n\n\tif (frmr->fr_state == FRMR_IS_STALE)\n\t\tllist_add(&ibmr->llnode, &pool->drop_list);\n\telse\n\t\tllist_add(&ibmr->llnode, &pool->free_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}