{
  "module_name": "info.c",
  "hash_id": "bce46c4d1bb4c2f67b9bb73ca77dfad8465ed4bfc996d94641db98a10ec9eb0f",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/info.c",
  "human_readable_source": " \n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\n#include \"rds.h\"\n\n \n\nstruct rds_info_iterator {\n\tstruct page **pages;\n\tvoid *addr;\n\tunsigned long offset;\n};\n\nstatic DEFINE_SPINLOCK(rds_info_lock);\nstatic rds_info_func rds_info_funcs[RDS_INFO_LAST - RDS_INFO_FIRST + 1];\n\nvoid rds_info_register_func(int optname, rds_info_func func)\n{\n\tint offset = optname - RDS_INFO_FIRST;\n\n\tBUG_ON(optname < RDS_INFO_FIRST || optname > RDS_INFO_LAST);\n\n\tspin_lock(&rds_info_lock);\n\tBUG_ON(rds_info_funcs[offset]);\n\trds_info_funcs[offset] = func;\n\tspin_unlock(&rds_info_lock);\n}\nEXPORT_SYMBOL_GPL(rds_info_register_func);\n\nvoid rds_info_deregister_func(int optname, rds_info_func func)\n{\n\tint offset = optname - RDS_INFO_FIRST;\n\n\tBUG_ON(optname < RDS_INFO_FIRST || optname > RDS_INFO_LAST);\n\n\tspin_lock(&rds_info_lock);\n\tBUG_ON(rds_info_funcs[offset] != func);\n\trds_info_funcs[offset] = NULL;\n\tspin_unlock(&rds_info_lock);\n}\nEXPORT_SYMBOL_GPL(rds_info_deregister_func);\n\n \nvoid rds_info_iter_unmap(struct rds_info_iterator *iter)\n{\n\tif (iter->addr) {\n\t\tkunmap_atomic(iter->addr);\n\t\titer->addr = NULL;\n\t}\n}\n\n \nvoid rds_info_copy(struct rds_info_iterator *iter, void *data,\n\t\t   unsigned long bytes)\n{\n\tunsigned long this;\n\n\twhile (bytes) {\n\t\tif (!iter->addr)\n\t\t\titer->addr = kmap_atomic(*iter->pages);\n\n\t\tthis = min(bytes, PAGE_SIZE - iter->offset);\n\n\t\trdsdebug(\"page %p addr %p offset %lu this %lu data %p \"\n\t\t\t  \"bytes %lu\\n\", *iter->pages, iter->addr,\n\t\t\t  iter->offset, this, data, bytes);\n\n\t\tmemcpy(iter->addr + iter->offset, data, this);\n\n\t\tdata += this;\n\t\tbytes -= this;\n\t\titer->offset += this;\n\n\t\tif (iter->offset == PAGE_SIZE) {\n\t\t\tkunmap_atomic(iter->addr);\n\t\t\titer->addr = NULL;\n\t\t\titer->offset = 0;\n\t\t\titer->pages++;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(rds_info_copy);\n\n \nint rds_info_getsockopt(struct socket *sock, int optname, char __user *optval,\n\t\t\tint __user *optlen)\n{\n\tstruct rds_info_iterator iter;\n\tstruct rds_info_lengths lens;\n\tunsigned long nr_pages = 0;\n\tunsigned long start;\n\trds_info_func func;\n\tstruct page **pages = NULL;\n\tint ret;\n\tint len;\n\tint total;\n\n\tif (get_user(len, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\tstart = (unsigned long)optval;\n\tif (len < 0 || len > INT_MAX - PAGE_SIZE + 1 || start + len < start) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (len == 0)\n\t\tgoto call_func;\n\n\tnr_pages = (PAGE_ALIGN(start + len) - (start & PAGE_MASK))\n\t\t\t>> PAGE_SHIFT;\n\n\tpages = kmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = pin_user_pages_fast(start, nr_pages, FOLL_WRITE, pages);\n\tif (ret != nr_pages) {\n\t\tif (ret > 0)\n\t\t\tnr_pages = ret;\n\t\telse\n\t\t\tnr_pages = 0;\n\t\tret = -EAGAIN;  \n\t\tgoto out;\n\t}\n\n\trdsdebug(\"len %d nr_pages %lu\\n\", len, nr_pages);\n\ncall_func:\n\tfunc = rds_info_funcs[optname - RDS_INFO_FIRST];\n\tif (!func) {\n\t\tret = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\n\titer.pages = pages;\n\titer.addr = NULL;\n\titer.offset = start & (PAGE_SIZE - 1);\n\n\tfunc(sock, len, &iter, &lens);\n\tBUG_ON(lens.each == 0);\n\n\ttotal = lens.nr * lens.each;\n\n\trds_info_iter_unmap(&iter);\n\n\tif (total > len) {\n\t\tlen = total;\n\t\tret = -ENOSPC;\n\t} else {\n\t\tlen = total;\n\t\tret = lens.each;\n\t}\n\n\tif (put_user(len, optlen))\n\t\tret = -EFAULT;\n\nout:\n\tif (pages)\n\t\tunpin_user_pages(pages, nr_pages);\n\tkfree(pages);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}