{
  "module_name": "tcp_listen.c",
  "hash_id": "5b60d1f6dece9ad21b4581cd818d2fef70aad674036052a468bbe7c562bad06f",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/tcp_listen.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/in.h>\n#include <net/tcp.h>\n#include <trace/events/sock.h>\n\n#include \"rds.h\"\n#include \"tcp.h\"\n\nvoid rds_tcp_keepalive(struct socket *sock)\n{\n\t \n\tint keepidle = 5;  \n\tint keepcnt = 5;  \n\n\tsock_set_keepalive(sock->sk);\n\ttcp_sock_set_keepcnt(sock->sk, keepcnt);\n\ttcp_sock_set_keepidle(sock->sk, keepidle);\n\t \n\ttcp_sock_set_keepintvl(sock->sk, keepidle);\n}\n\n \nstatic\nstruct rds_tcp_connection *rds_tcp_accept_one_path(struct rds_connection *conn)\n{\n\tint i;\n\tint npaths = max_t(int, 1, conn->c_npaths);\n\n\t \n\tif (rds_addr_cmp(&conn->c_faddr, &conn->c_laddr) >= 0) {\n\t\t \n\t\tif (npaths == 1)\n\t\t\trds_conn_path_connect_if_down(&conn->c_path[0]);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < npaths; i++) {\n\t\tstruct rds_conn_path *cp = &conn->c_path[i];\n\n\t\tif (rds_conn_path_transition(cp, RDS_CONN_DOWN,\n\t\t\t\t\t     RDS_CONN_CONNECTING) ||\n\t\t    rds_conn_path_transition(cp, RDS_CONN_ERROR,\n\t\t\t\t\t     RDS_CONN_CONNECTING)) {\n\t\t\treturn cp->cp_transport_data;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint rds_tcp_accept_one(struct socket *sock)\n{\n\tstruct socket *new_sock = NULL;\n\tstruct rds_connection *conn;\n\tint ret;\n\tstruct inet_sock *inet;\n\tstruct rds_tcp_connection *rs_tcp = NULL;\n\tint conn_state;\n\tstruct rds_conn_path *cp;\n\tstruct in6_addr *my_addr, *peer_addr;\n#if !IS_ENABLED(CONFIG_IPV6)\n\tstruct in6_addr saddr, daddr;\n#endif\n\tint dev_if = 0;\n\n\tif (!sock)  \n\t\treturn -ENETUNREACH;\n\n\tret = sock_create_lite(sock->sk->sk_family,\n\t\t\t       sock->sk->sk_type, sock->sk->sk_protocol,\n\t\t\t       &new_sock);\n\tif (ret)\n\t\tgoto out;\n\n\tret = sock->ops->accept(sock, new_sock, O_NONBLOCK, true);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tnew_sock->ops = sock->ops;\n\t__module_get(new_sock->ops->owner);\n\n\trds_tcp_keepalive(new_sock);\n\tif (!rds_tcp_tune(new_sock)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinet = inet_sk(new_sock->sk);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tmy_addr = &new_sock->sk->sk_v6_rcv_saddr;\n\tpeer_addr = &new_sock->sk->sk_v6_daddr;\n#else\n\tipv6_addr_set_v4mapped(inet->inet_saddr, &saddr);\n\tipv6_addr_set_v4mapped(inet->inet_daddr, &daddr);\n\tmy_addr = &saddr;\n\tpeer_addr = &daddr;\n#endif\n\trdsdebug(\"accepted family %d tcp %pI6c:%u -> %pI6c:%u\\n\",\n\t\t sock->sk->sk_family,\n\t\t my_addr, ntohs(inet->inet_sport),\n\t\t peer_addr, ntohs(inet->inet_dport));\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t \n\tif ((ipv6_addr_type(my_addr) & IPV6_ADDR_LINKLOCAL) &&\n\t    !(ipv6_addr_type(peer_addr) & IPV6_ADDR_LINKLOCAL)) {\n\t\tstruct ipv6_pinfo *inet6;\n\n\t\tinet6 = inet6_sk(new_sock->sk);\n\t\tdev_if = inet6->mcast_oif;\n\t} else {\n\t\tdev_if = new_sock->sk->sk_bound_dev_if;\n\t}\n#endif\n\n\tif (!rds_tcp_laddr_check(sock_net(sock->sk), peer_addr, dev_if)) {\n\t\t \n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tconn = rds_conn_create(sock_net(sock->sk),\n\t\t\t       my_addr, peer_addr,\n\t\t\t       &rds_tcp_transport, 0, GFP_KERNEL, dev_if);\n\n\tif (IS_ERR(conn)) {\n\t\tret = PTR_ERR(conn);\n\t\tgoto out;\n\t}\n\t \n\trs_tcp = rds_tcp_accept_one_path(conn);\n\tif (!rs_tcp)\n\t\tgoto rst_nsk;\n\tmutex_lock(&rs_tcp->t_conn_path_lock);\n\tcp = rs_tcp->t_cpath;\n\tconn_state = rds_conn_path_state(cp);\n\tWARN_ON(conn_state == RDS_CONN_UP);\n\tif (conn_state != RDS_CONN_CONNECTING && conn_state != RDS_CONN_ERROR)\n\t\tgoto rst_nsk;\n\tif (rs_tcp->t_sock) {\n\t\t \n\t\trds_tcp_reset_callbacks(new_sock, cp);\n\t\t \n\t\trds_connect_path_complete(cp, RDS_CONN_RESETTING);\n\t} else {\n\t\trds_tcp_set_callbacks(new_sock, cp);\n\t\trds_connect_path_complete(cp, RDS_CONN_CONNECTING);\n\t}\n\tnew_sock = NULL;\n\tret = 0;\n\tif (conn->c_npaths == 0)\n\t\trds_send_ping(cp->cp_conn, cp->cp_index);\n\tgoto out;\nrst_nsk:\n\t \n\tsock_no_linger(new_sock->sk);\n\tkernel_sock_shutdown(new_sock, SHUT_RDWR);\n\tret = 0;\nout:\n\tif (rs_tcp)\n\t\tmutex_unlock(&rs_tcp->t_conn_path_lock);\n\tif (new_sock)\n\t\tsock_release(new_sock);\n\treturn ret;\n}\n\nvoid rds_tcp_listen_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\n\ttrace_sk_data_ready(sk);\n\trdsdebug(\"listen data ready sk %p\\n\", sk);\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tready = sk->sk_user_data;\n\tif (!ready) {  \n\t\tready = sk->sk_data_ready;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sk->sk_state == TCP_LISTEN)\n\t\trds_tcp_accept_work(sk);\n\telse\n\t\tready = rds_tcp_listen_sock_def_readable(sock_net(sk));\n\nout:\n\tread_unlock_bh(&sk->sk_callback_lock);\n\tif (ready)\n\t\tready(sk);\n}\n\nstruct socket *rds_tcp_listen_init(struct net *net, bool isv6)\n{\n\tstruct socket *sock = NULL;\n\tstruct sockaddr_storage ss;\n\tstruct sockaddr_in6 *sin6;\n\tstruct sockaddr_in *sin;\n\tint addr_len;\n\tint ret;\n\n\tret = sock_create_kern(net, isv6 ? PF_INET6 : PF_INET, SOCK_STREAM,\n\t\t\t       IPPROTO_TCP, &sock);\n\tif (ret < 0) {\n\t\trdsdebug(\"could not create %s listener socket: %d\\n\",\n\t\t\t isv6 ? \"IPv6\" : \"IPv4\", ret);\n\t\tgoto out;\n\t}\n\n\tsock->sk->sk_reuse = SK_CAN_REUSE;\n\ttcp_sock_set_nodelay(sock->sk);\n\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_user_data = sock->sk->sk_data_ready;\n\tsock->sk->sk_data_ready = rds_tcp_listen_data_ready;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\tif (isv6) {\n\t\tsin6 = (struct sockaddr_in6 *)&ss;\n\t\tsin6->sin6_family = PF_INET6;\n\t\tsin6->sin6_addr = in6addr_any;\n\t\tsin6->sin6_port = (__force u16)htons(RDS_TCP_PORT);\n\t\tsin6->sin6_scope_id = 0;\n\t\tsin6->sin6_flowinfo = 0;\n\t\taddr_len = sizeof(*sin6);\n\t} else {\n\t\tsin = (struct sockaddr_in *)&ss;\n\t\tsin->sin_family = PF_INET;\n\t\tsin->sin_addr.s_addr = INADDR_ANY;\n\t\tsin->sin_port = (__force u16)htons(RDS_TCP_PORT);\n\t\taddr_len = sizeof(*sin);\n\t}\n\n\tret = kernel_bind(sock, (struct sockaddr *)&ss, addr_len);\n\tif (ret < 0) {\n\t\trdsdebug(\"could not bind %s listener socket: %d\\n\",\n\t\t\t isv6 ? \"IPv6\" : \"IPv4\", ret);\n\t\tgoto out;\n\t}\n\n\tret = sock->ops->listen(sock, 64);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn sock;\nout:\n\tif (sock)\n\t\tsock_release(sock);\n\treturn NULL;\n}\n\nvoid rds_tcp_listen_stop(struct socket *sock, struct work_struct *acceptor)\n{\n\tstruct sock *sk;\n\n\tif (!sock)\n\t\treturn;\n\n\tsk = sock->sk;\n\n\t \n\tlock_sock(sk);\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tif (sk->sk_user_data) {\n\t\tsk->sk_data_ready = sk->sk_user_data;\n\t\tsk->sk_user_data = NULL;\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\trelease_sock(sk);\n\n\t \n\tflush_workqueue(rds_wq);\n\tflush_work(acceptor);\n\tsock_release(sock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}