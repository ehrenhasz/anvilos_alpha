{
  "module_name": "threads.c",
  "hash_id": "0b03581e3c78a66a6c6c28c510dceb224404e73dd3a5bc8963f527385925ab3a",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/threads.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/random.h>\n#include <linux/export.h>\n\n#include \"rds.h\"\n\n \n\n \nstruct workqueue_struct *rds_wq;\nEXPORT_SYMBOL_GPL(rds_wq);\n\nvoid rds_connect_path_complete(struct rds_conn_path *cp, int curr)\n{\n\tif (!rds_conn_path_transition(cp, curr, RDS_CONN_UP)) {\n\t\tprintk(KERN_WARNING \"%s: Cannot transition to state UP, \"\n\t\t\t\t\"current state is %d\\n\",\n\t\t\t\t__func__,\n\t\t\t\tatomic_read(&cp->cp_state));\n\t\trds_conn_path_drop(cp, false);\n\t\treturn;\n\t}\n\n\trdsdebug(\"conn %p for %pI6c to %pI6c complete\\n\",\n\t\t cp->cp_conn, &cp->cp_conn->c_laddr, &cp->cp_conn->c_faddr);\n\n\tcp->cp_reconnect_jiffies = 0;\n\tset_bit(0, &cp->cp_conn->c_map_queued);\n\trcu_read_lock();\n\tif (!rds_destroy_pending(cp->cp_conn)) {\n\t\tqueue_delayed_work(rds_wq, &cp->cp_send_w, 0);\n\t\tqueue_delayed_work(rds_wq, &cp->cp_recv_w, 0);\n\t}\n\trcu_read_unlock();\n\tcp->cp_conn->c_proposed_version = RDS_PROTOCOL_VERSION;\n}\nEXPORT_SYMBOL_GPL(rds_connect_path_complete);\n\nvoid rds_connect_complete(struct rds_connection *conn)\n{\n\trds_connect_path_complete(&conn->c_path[0], RDS_CONN_CONNECTING);\n}\nEXPORT_SYMBOL_GPL(rds_connect_complete);\n\n \nvoid rds_queue_reconnect(struct rds_conn_path *cp)\n{\n\tunsigned long rand;\n\tstruct rds_connection *conn = cp->cp_conn;\n\n\trdsdebug(\"conn %p for %pI6c to %pI6c reconnect jiffies %lu\\n\",\n\t\t conn, &conn->c_laddr, &conn->c_faddr,\n\t\t cp->cp_reconnect_jiffies);\n\n\t \n\tif (conn->c_trans->t_type == RDS_TRANS_TCP &&\n\t    rds_addr_cmp(&conn->c_laddr, &conn->c_faddr) >= 0)\n\t\treturn;\n\n\tset_bit(RDS_RECONNECT_PENDING, &cp->cp_flags);\n\tif (cp->cp_reconnect_jiffies == 0) {\n\t\tcp->cp_reconnect_jiffies = rds_sysctl_reconnect_min_jiffies;\n\t\trcu_read_lock();\n\t\tif (!rds_destroy_pending(cp->cp_conn))\n\t\t\tqueue_delayed_work(rds_wq, &cp->cp_conn_w, 0);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tget_random_bytes(&rand, sizeof(rand));\n\trdsdebug(\"%lu delay %lu ceil conn %p for %pI6c -> %pI6c\\n\",\n\t\t rand % cp->cp_reconnect_jiffies, cp->cp_reconnect_jiffies,\n\t\t conn, &conn->c_laddr, &conn->c_faddr);\n\trcu_read_lock();\n\tif (!rds_destroy_pending(cp->cp_conn))\n\t\tqueue_delayed_work(rds_wq, &cp->cp_conn_w,\n\t\t\t\t   rand % cp->cp_reconnect_jiffies);\n\trcu_read_unlock();\n\n\tcp->cp_reconnect_jiffies = min(cp->cp_reconnect_jiffies * 2,\n\t\t\t\t\trds_sysctl_reconnect_max_jiffies);\n}\n\nvoid rds_connect_worker(struct work_struct *work)\n{\n\tstruct rds_conn_path *cp = container_of(work,\n\t\t\t\t\t\tstruct rds_conn_path,\n\t\t\t\t\t\tcp_conn_w.work);\n\tstruct rds_connection *conn = cp->cp_conn;\n\tint ret;\n\n\tif (cp->cp_index > 0 &&\n\t    rds_addr_cmp(&cp->cp_conn->c_laddr, &cp->cp_conn->c_faddr) >= 0)\n\t\treturn;\n\tclear_bit(RDS_RECONNECT_PENDING, &cp->cp_flags);\n\tret = rds_conn_path_transition(cp, RDS_CONN_DOWN, RDS_CONN_CONNECTING);\n\tif (ret) {\n\t\tret = conn->c_trans->conn_path_connect(cp);\n\t\trdsdebug(\"conn %p for %pI6c to %pI6c dispatched, ret %d\\n\",\n\t\t\t conn, &conn->c_laddr, &conn->c_faddr, ret);\n\n\t\tif (ret) {\n\t\t\tif (rds_conn_path_transition(cp,\n\t\t\t\t\t\t     RDS_CONN_CONNECTING,\n\t\t\t\t\t\t     RDS_CONN_DOWN))\n\t\t\t\trds_queue_reconnect(cp);\n\t\t\telse\n\t\t\t\trds_conn_path_error(cp, \"connect failed\\n\");\n\t\t}\n\t}\n}\n\nvoid rds_send_worker(struct work_struct *work)\n{\n\tstruct rds_conn_path *cp = container_of(work,\n\t\t\t\t\t\tstruct rds_conn_path,\n\t\t\t\t\t\tcp_send_w.work);\n\tint ret;\n\n\tif (rds_conn_path_state(cp) == RDS_CONN_UP) {\n\t\tclear_bit(RDS_LL_SEND_FULL, &cp->cp_flags);\n\t\tret = rds_send_xmit(cp);\n\t\tcond_resched();\n\t\trdsdebug(\"conn %p ret %d\\n\", cp->cp_conn, ret);\n\t\tswitch (ret) {\n\t\tcase -EAGAIN:\n\t\t\trds_stats_inc(s_send_immediate_retry);\n\t\t\tqueue_delayed_work(rds_wq, &cp->cp_send_w, 0);\n\t\t\tbreak;\n\t\tcase -ENOMEM:\n\t\t\trds_stats_inc(s_send_delayed_retry);\n\t\t\tqueue_delayed_work(rds_wq, &cp->cp_send_w, 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rds_recv_worker(struct work_struct *work)\n{\n\tstruct rds_conn_path *cp = container_of(work,\n\t\t\t\t\t\tstruct rds_conn_path,\n\t\t\t\t\t\tcp_recv_w.work);\n\tint ret;\n\n\tif (rds_conn_path_state(cp) == RDS_CONN_UP) {\n\t\tret = cp->cp_conn->c_trans->recv_path(cp);\n\t\trdsdebug(\"conn %p ret %d\\n\", cp->cp_conn, ret);\n\t\tswitch (ret) {\n\t\tcase -EAGAIN:\n\t\t\trds_stats_inc(s_recv_immediate_retry);\n\t\t\tqueue_delayed_work(rds_wq, &cp->cp_recv_w, 0);\n\t\t\tbreak;\n\t\tcase -ENOMEM:\n\t\t\trds_stats_inc(s_recv_delayed_retry);\n\t\t\tqueue_delayed_work(rds_wq, &cp->cp_recv_w, 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rds_shutdown_worker(struct work_struct *work)\n{\n\tstruct rds_conn_path *cp = container_of(work,\n\t\t\t\t\t\tstruct rds_conn_path,\n\t\t\t\t\t\tcp_down_w);\n\n\trds_conn_shutdown(cp);\n}\n\nvoid rds_threads_exit(void)\n{\n\tdestroy_workqueue(rds_wq);\n}\n\nint rds_threads_init(void)\n{\n\trds_wq = create_singlethread_workqueue(\"krdsd\");\n\tif (!rds_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nint rds_addr_cmp(const struct in6_addr *addr1,\n\t\t const struct in6_addr *addr2)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst __be64 *a1, *a2;\n\tu64 x, y;\n\n\ta1 = (__be64 *)addr1;\n\ta2 = (__be64 *)addr2;\n\n\tif (*a1 != *a2) {\n\t\tif (be64_to_cpu(*a1) < be64_to_cpu(*a2))\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t} else {\n\t\tx = be64_to_cpu(*++a1);\n\t\ty = be64_to_cpu(*++a2);\n\t\tif (x < y)\n\t\t\treturn -1;\n\t\telse if (x > y)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n#else\n\tu32 a, b;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (addr1->s6_addr32[i] != addr2->s6_addr32[i]) {\n\t\t\ta = ntohl(addr1->s6_addr32[i]);\n\t\t\tb = ntohl(addr2->s6_addr32[i]);\n\t\t\tif (a < b)\n\t\t\t\treturn -1;\n\t\t\telse if (a > b)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n#endif\n}\nEXPORT_SYMBOL_GPL(rds_addr_cmp);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}