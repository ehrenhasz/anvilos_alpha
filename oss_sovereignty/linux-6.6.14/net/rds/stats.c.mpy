{
  "module_name": "stats.c",
  "hash_id": "c0962972ae482b85505aa09cccba2bab6cc196c2443fe3760df414b9c4abd394",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/stats.c",
  "human_readable_source": " \n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\n#include \"rds.h\"\n\nDEFINE_PER_CPU_SHARED_ALIGNED(struct rds_statistics, rds_stats);\nEXPORT_PER_CPU_SYMBOL_GPL(rds_stats);\n\n \n\nstatic const char *const rds_stat_names[] = {\n\t\"conn_reset\",\n\t\"recv_drop_bad_checksum\",\n\t\"recv_drop_old_seq\",\n\t\"recv_drop_no_sock\",\n\t\"recv_drop_dead_sock\",\n\t\"recv_deliver_raced\",\n\t\"recv_delivered\",\n\t\"recv_queued\",\n\t\"recv_immediate_retry\",\n\t\"recv_delayed_retry\",\n\t\"recv_ack_required\",\n\t\"recv_rdma_bytes\",\n\t\"recv_ping\",\n\t\"send_queue_empty\",\n\t\"send_queue_full\",\n\t\"send_lock_contention\",\n\t\"send_lock_queue_raced\",\n\t\"send_immediate_retry\",\n\t\"send_delayed_retry\",\n\t\"send_drop_acked\",\n\t\"send_ack_required\",\n\t\"send_queued\",\n\t\"send_rdma\",\n\t\"send_rdma_bytes\",\n\t\"send_pong\",\n\t\"page_remainder_hit\",\n\t\"page_remainder_miss\",\n\t\"copy_to_user\",\n\t\"copy_from_user\",\n\t\"cong_update_queued\",\n\t\"cong_update_received\",\n\t\"cong_send_error\",\n\t\"cong_send_blocked\",\n\t\"recv_bytes_added_to_sock\",\n\t\"recv_bytes_freed_fromsock\",\n\t\"send_stuck_rm\",\n};\n\nvoid rds_stats_info_copy(struct rds_info_iterator *iter,\n\t\t\t uint64_t *values, const char *const *names, size_t nr)\n{\n\tstruct rds_info_counter ctr;\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tBUG_ON(strlen(names[i]) >= sizeof(ctr.name));\n\t\tstrncpy(ctr.name, names[i], sizeof(ctr.name) - 1);\n\t\tctr.name[sizeof(ctr.name) - 1] = '\\0';\n\t\tctr.value = values[i];\n\n\t\trds_info_copy(iter, &ctr, sizeof(ctr));\n\t}\n}\nEXPORT_SYMBOL_GPL(rds_stats_info_copy);\n\n \nstatic void rds_stats_info(struct socket *sock, unsigned int len,\n\t\t\t   struct rds_info_iterator *iter,\n\t\t\t   struct rds_info_lengths *lens)\n{\n\tstruct rds_statistics stats = {0, };\n\tuint64_t *src;\n\tuint64_t *sum;\n\tsize_t i;\n\tint cpu;\n\tunsigned int avail;\n\n\tavail = len / sizeof(struct rds_info_counter);\n\n\tif (avail < ARRAY_SIZE(rds_stat_names)) {\n\t\tavail = 0;\n\t\tgoto trans;\n\t}\n\n\tfor_each_online_cpu(cpu) {\n\t\tsrc = (uint64_t *)&(per_cpu(rds_stats, cpu));\n\t\tsum = (uint64_t *)&stats;\n\t\tfor (i = 0; i < sizeof(stats) / sizeof(uint64_t); i++)\n\t\t\t*(sum++) += *(src++);\n\t}\n\n\trds_stats_info_copy(iter, (uint64_t *)&stats, rds_stat_names,\n\t\t\t    ARRAY_SIZE(rds_stat_names));\n\tavail -= ARRAY_SIZE(rds_stat_names);\n\ntrans:\n\tlens->each = sizeof(struct rds_info_counter);\n\tlens->nr = rds_trans_stats_info_copy(iter, avail) +\n\t\t   ARRAY_SIZE(rds_stat_names);\n}\n\nvoid rds_stats_exit(void)\n{\n\trds_info_deregister_func(RDS_INFO_COUNTERS, rds_stats_info);\n}\n\nint rds_stats_init(void)\n{\n\trds_info_register_func(RDS_INFO_COUNTERS, rds_stats_info);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}