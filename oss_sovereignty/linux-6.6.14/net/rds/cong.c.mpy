{
  "module_name": "cong.c",
  "hash_id": "2cce666a1c5995f69e01701b610957727d05b0c76324afc19ee1fd8907cd98f2",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/cong.c",
  "human_readable_source": " \n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/rbtree.h>\n#include <linux/bitops.h>\n#include <linux/export.h>\n\n#include \"rds.h\"\n\n \n\n \nstatic atomic_t\t\trds_cong_generation = ATOMIC_INIT(0);\n\n \nstatic LIST_HEAD(rds_cong_monitor);\nstatic DEFINE_RWLOCK(rds_cong_monitor_lock);\n\n \nstatic DEFINE_SPINLOCK(rds_cong_lock);\nstatic struct rb_root rds_cong_tree = RB_ROOT;\n\nstatic struct rds_cong_map *rds_cong_tree_walk(const struct in6_addr *addr,\n\t\t\t\t\t       struct rds_cong_map *insert)\n{\n\tstruct rb_node **p = &rds_cong_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rds_cong_map *map;\n\n\twhile (*p) {\n\t\tint diff;\n\n\t\tparent = *p;\n\t\tmap = rb_entry(parent, struct rds_cong_map, m_rb_node);\n\n\t\tdiff = rds_addr_cmp(addr, &map->m_addr);\n\t\tif (diff < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (diff > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn map;\n\t}\n\n\tif (insert) {\n\t\trb_link_node(&insert->m_rb_node, parent, p);\n\t\trb_insert_color(&insert->m_rb_node, &rds_cong_tree);\n\t}\n\treturn NULL;\n}\n\n \nstatic struct rds_cong_map *rds_cong_from_addr(const struct in6_addr *addr)\n{\n\tstruct rds_cong_map *map;\n\tstruct rds_cong_map *ret = NULL;\n\tunsigned long zp;\n\tunsigned long i;\n\tunsigned long flags;\n\n\tmap = kzalloc(sizeof(struct rds_cong_map), GFP_KERNEL);\n\tif (!map)\n\t\treturn NULL;\n\n\tmap->m_addr = *addr;\n\tinit_waitqueue_head(&map->m_waitq);\n\tINIT_LIST_HEAD(&map->m_conn_list);\n\n\tfor (i = 0; i < RDS_CONG_MAP_PAGES; i++) {\n\t\tzp = get_zeroed_page(GFP_KERNEL);\n\t\tif (zp == 0)\n\t\t\tgoto out;\n\t\tmap->m_page_addrs[i] = zp;\n\t}\n\n\tspin_lock_irqsave(&rds_cong_lock, flags);\n\tret = rds_cong_tree_walk(addr, map);\n\tspin_unlock_irqrestore(&rds_cong_lock, flags);\n\n\tif (!ret) {\n\t\tret = map;\n\t\tmap = NULL;\n\t}\n\nout:\n\tif (map) {\n\t\tfor (i = 0; i < RDS_CONG_MAP_PAGES && map->m_page_addrs[i]; i++)\n\t\t\tfree_page(map->m_page_addrs[i]);\n\t\tkfree(map);\n\t}\n\n\trdsdebug(\"map %p for addr %pI6c\\n\", ret, addr);\n\n\treturn ret;\n}\n\n \nvoid rds_cong_add_conn(struct rds_connection *conn)\n{\n\tunsigned long flags;\n\n\trdsdebug(\"conn %p now on map %p\\n\", conn, conn->c_lcong);\n\tspin_lock_irqsave(&rds_cong_lock, flags);\n\tlist_add_tail(&conn->c_map_item, &conn->c_lcong->m_conn_list);\n\tspin_unlock_irqrestore(&rds_cong_lock, flags);\n}\n\nvoid rds_cong_remove_conn(struct rds_connection *conn)\n{\n\tunsigned long flags;\n\n\trdsdebug(\"removing conn %p from map %p\\n\", conn, conn->c_lcong);\n\tspin_lock_irqsave(&rds_cong_lock, flags);\n\tlist_del_init(&conn->c_map_item);\n\tspin_unlock_irqrestore(&rds_cong_lock, flags);\n}\n\nint rds_cong_get_maps(struct rds_connection *conn)\n{\n\tconn->c_lcong = rds_cong_from_addr(&conn->c_laddr);\n\tconn->c_fcong = rds_cong_from_addr(&conn->c_faddr);\n\n\tif (!(conn->c_lcong && conn->c_fcong))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid rds_cong_queue_updates(struct rds_cong_map *map)\n{\n\tstruct rds_connection *conn;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rds_cong_lock, flags);\n\n\tlist_for_each_entry(conn, &map->m_conn_list, c_map_item) {\n\t\tstruct rds_conn_path *cp = &conn->c_path[0];\n\n\t\trcu_read_lock();\n\t\tif (!test_and_set_bit(0, &conn->c_map_queued) &&\n\t\t    !rds_destroy_pending(cp->cp_conn)) {\n\t\t\trds_stats_inc(s_cong_update_queued);\n\t\t\t \n\t\t\tqueue_delayed_work(rds_wq, &cp->cp_send_w, 0);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tspin_unlock_irqrestore(&rds_cong_lock, flags);\n}\n\nvoid rds_cong_map_updated(struct rds_cong_map *map, uint64_t portmask)\n{\n\trdsdebug(\"waking map %p for %pI4\\n\",\n\t  map, &map->m_addr);\n\trds_stats_inc(s_cong_update_received);\n\tatomic_inc(&rds_cong_generation);\n\tif (waitqueue_active(&map->m_waitq))\n\t\twake_up(&map->m_waitq);\n\tif (waitqueue_active(&rds_poll_waitq))\n\t\twake_up_all(&rds_poll_waitq);\n\n\tif (portmask && !list_empty(&rds_cong_monitor)) {\n\t\tunsigned long flags;\n\t\tstruct rds_sock *rs;\n\n\t\tread_lock_irqsave(&rds_cong_monitor_lock, flags);\n\t\tlist_for_each_entry(rs, &rds_cong_monitor, rs_cong_list) {\n\t\t\tspin_lock(&rs->rs_lock);\n\t\t\trs->rs_cong_notify |= (rs->rs_cong_mask & portmask);\n\t\t\trs->rs_cong_mask &= ~portmask;\n\t\t\tspin_unlock(&rs->rs_lock);\n\t\t\tif (rs->rs_cong_notify)\n\t\t\t\trds_wake_sk_sleep(rs);\n\t\t}\n\t\tread_unlock_irqrestore(&rds_cong_monitor_lock, flags);\n\t}\n}\nEXPORT_SYMBOL_GPL(rds_cong_map_updated);\n\nint rds_cong_updated_since(unsigned long *recent)\n{\n\tunsigned long gen = atomic_read(&rds_cong_generation);\n\n\tif (likely(*recent == gen))\n\t\treturn 0;\n\t*recent = gen;\n\treturn 1;\n}\n\n \nvoid rds_cong_set_bit(struct rds_cong_map *map, __be16 port)\n{\n\tunsigned long i;\n\tunsigned long off;\n\n\trdsdebug(\"setting congestion for %pI4:%u in map %p\\n\",\n\t  &map->m_addr, ntohs(port), map);\n\n\ti = be16_to_cpu(port) / RDS_CONG_MAP_PAGE_BITS;\n\toff = be16_to_cpu(port) % RDS_CONG_MAP_PAGE_BITS;\n\n\tset_bit_le(off, (void *)map->m_page_addrs[i]);\n}\n\nvoid rds_cong_clear_bit(struct rds_cong_map *map, __be16 port)\n{\n\tunsigned long i;\n\tunsigned long off;\n\n\trdsdebug(\"clearing congestion for %pI4:%u in map %p\\n\",\n\t  &map->m_addr, ntohs(port), map);\n\n\ti = be16_to_cpu(port) / RDS_CONG_MAP_PAGE_BITS;\n\toff = be16_to_cpu(port) % RDS_CONG_MAP_PAGE_BITS;\n\n\tclear_bit_le(off, (void *)map->m_page_addrs[i]);\n}\n\nstatic int rds_cong_test_bit(struct rds_cong_map *map, __be16 port)\n{\n\tunsigned long i;\n\tunsigned long off;\n\n\ti = be16_to_cpu(port) / RDS_CONG_MAP_PAGE_BITS;\n\toff = be16_to_cpu(port) % RDS_CONG_MAP_PAGE_BITS;\n\n\treturn test_bit_le(off, (void *)map->m_page_addrs[i]);\n}\n\nvoid rds_cong_add_socket(struct rds_sock *rs)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&rds_cong_monitor_lock, flags);\n\tif (list_empty(&rs->rs_cong_list))\n\t\tlist_add(&rs->rs_cong_list, &rds_cong_monitor);\n\twrite_unlock_irqrestore(&rds_cong_monitor_lock, flags);\n}\n\nvoid rds_cong_remove_socket(struct rds_sock *rs)\n{\n\tunsigned long flags;\n\tstruct rds_cong_map *map;\n\n\twrite_lock_irqsave(&rds_cong_monitor_lock, flags);\n\tlist_del_init(&rs->rs_cong_list);\n\twrite_unlock_irqrestore(&rds_cong_monitor_lock, flags);\n\n\t \n\tspin_lock_irqsave(&rds_cong_lock, flags);\n\tmap = rds_cong_tree_walk(&rs->rs_bound_addr, NULL);\n\tspin_unlock_irqrestore(&rds_cong_lock, flags);\n\n\tif (map && rds_cong_test_bit(map, rs->rs_bound_port)) {\n\t\trds_cong_clear_bit(map, rs->rs_bound_port);\n\t\trds_cong_queue_updates(map);\n\t}\n}\n\nint rds_cong_wait(struct rds_cong_map *map, __be16 port, int nonblock,\n\t\t  struct rds_sock *rs)\n{\n\tif (!rds_cong_test_bit(map, port))\n\t\treturn 0;\n\tif (nonblock) {\n\t\tif (rs && rs->rs_cong_monitor) {\n\t\t\tunsigned long flags;\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&rs->rs_lock, flags);\n\t\t\trs->rs_cong_mask |= RDS_CONG_MONITOR_MASK(ntohs(port));\n\t\t\tspin_unlock_irqrestore(&rs->rs_lock, flags);\n\n\t\t\t \n\t\t\tif (!rds_cong_test_bit(map, port))\n\t\t\t\treturn 0;\n\t\t}\n\t\trds_stats_inc(s_cong_send_error);\n\t\treturn -ENOBUFS;\n\t}\n\n\trds_stats_inc(s_cong_send_blocked);\n\trdsdebug(\"waiting on map %p for port %u\\n\", map, be16_to_cpu(port));\n\n\treturn wait_event_interruptible(map->m_waitq,\n\t\t\t\t\t!rds_cong_test_bit(map, port));\n}\n\nvoid rds_cong_exit(void)\n{\n\tstruct rb_node *node;\n\tstruct rds_cong_map *map;\n\tunsigned long i;\n\n\twhile ((node = rb_first(&rds_cong_tree))) {\n\t\tmap = rb_entry(node, struct rds_cong_map, m_rb_node);\n\t\trdsdebug(\"freeing map %p\\n\", map);\n\t\trb_erase(&map->m_rb_node, &rds_cong_tree);\n\t\tfor (i = 0; i < RDS_CONG_MAP_PAGES && map->m_page_addrs[i]; i++)\n\t\t\tfree_page(map->m_page_addrs[i]);\n\t\tkfree(map);\n\t}\n}\n\n \nstruct rds_message *rds_cong_update_alloc(struct rds_connection *conn)\n{\n\tstruct rds_cong_map *map = conn->c_lcong;\n\tstruct rds_message *rm;\n\n\trm = rds_message_map_pages(map->m_page_addrs, RDS_CONG_MAP_BYTES);\n\tif (!IS_ERR(rm))\n\t\trm->m_inc.i_hdr.h_flags = RDS_FLAG_CONG_BITMAP;\n\n\treturn rm;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}