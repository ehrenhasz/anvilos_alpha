{
  "module_name": "tcp.c",
  "hash_id": "af653d1285918aec9c2908b55a70a9036bf4c072dc12aad67ab7b0ab5d7610df",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/tcp.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/module.h>\n#include <net/tcp.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/addrconf.h>\n\n#include \"rds.h\"\n#include \"tcp.h\"\n\n \nstatic DEFINE_SPINLOCK(rds_tcp_tc_list_lock);\nstatic LIST_HEAD(rds_tcp_tc_list);\n\n \nstatic unsigned int rds_tcp_tc_count;\n#if IS_ENABLED(CONFIG_IPV6)\nstatic unsigned int rds6_tcp_tc_count;\n#endif\n\n \nstatic DEFINE_SPINLOCK(rds_tcp_conn_lock);\nstatic LIST_HEAD(rds_tcp_conn_list);\nstatic atomic_t rds_tcp_unloading = ATOMIC_INIT(0);\n\nstatic struct kmem_cache *rds_tcp_conn_slab;\n\nstatic int rds_tcp_skbuf_handler(struct ctl_table *ctl, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *fpos);\n\nstatic int rds_tcp_min_sndbuf = SOCK_MIN_SNDBUF;\nstatic int rds_tcp_min_rcvbuf = SOCK_MIN_RCVBUF;\n\nstatic struct ctl_table rds_tcp_sysctl_table[] = {\n#define\tRDS_TCP_SNDBUF\t0\n\t{\n\t\t.procname       = \"rds_tcp_sndbuf\",\n\t\t \n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = rds_tcp_skbuf_handler,\n\t\t.extra1\t\t= &rds_tcp_min_sndbuf,\n\t},\n#define\tRDS_TCP_RCVBUF\t1\n\t{\n\t\t.procname       = \"rds_tcp_rcvbuf\",\n\t\t \n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = rds_tcp_skbuf_handler,\n\t\t.extra1\t\t= &rds_tcp_min_rcvbuf,\n\t},\n\t{ }\n};\n\nu32 rds_tcp_write_seq(struct rds_tcp_connection *tc)\n{\n\t \n\treturn tcp_sk(tc->t_sock->sk)->write_seq;\n}\n\nu32 rds_tcp_snd_una(struct rds_tcp_connection *tc)\n{\n\treturn tcp_sk(tc->t_sock->sk)->snd_una;\n}\n\nvoid rds_tcp_restore_callbacks(struct socket *sock,\n\t\t\t       struct rds_tcp_connection *tc)\n{\n\trdsdebug(\"restoring sock %p callbacks from tc %p\\n\", sock, tc);\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\n\t \n\tspin_lock(&rds_tcp_tc_list_lock);\n\tlist_del_init(&tc->t_list_item);\n#if IS_ENABLED(CONFIG_IPV6)\n\trds6_tcp_tc_count--;\n#endif\n\tif (!tc->t_cpath->cp_conn->c_isv6)\n\t\trds_tcp_tc_count--;\n\tspin_unlock(&rds_tcp_tc_list_lock);\n\n\ttc->t_sock = NULL;\n\n\tsock->sk->sk_write_space = tc->t_orig_write_space;\n\tsock->sk->sk_data_ready = tc->t_orig_data_ready;\n\tsock->sk->sk_state_change = tc->t_orig_state_change;\n\tsock->sk->sk_user_data = NULL;\n\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n}\n\n \nvoid rds_tcp_reset_callbacks(struct socket *sock,\n\t\t\t     struct rds_conn_path *cp)\n{\n\tstruct rds_tcp_connection *tc = cp->cp_transport_data;\n\tstruct socket *osock = tc->t_sock;\n\n\tif (!osock)\n\t\tgoto newsock;\n\n\t \n\tatomic_set(&cp->cp_state, RDS_CONN_RESETTING);\n\twait_event(cp->cp_waitq, !test_bit(RDS_IN_XMIT, &cp->cp_flags));\n\t \n\tcancel_delayed_work_sync(&cp->cp_send_w);\n\tcancel_delayed_work_sync(&cp->cp_recv_w);\n\tlock_sock(osock->sk);\n\tif (tc->t_tinc) {\n\t\trds_inc_put(&tc->t_tinc->ti_inc);\n\t\ttc->t_tinc = NULL;\n\t}\n\ttc->t_tinc_hdr_rem = sizeof(struct rds_header);\n\ttc->t_tinc_data_rem = 0;\n\trds_tcp_restore_callbacks(osock, tc);\n\trelease_sock(osock->sk);\n\tsock_release(osock);\nnewsock:\n\trds_send_path_reset(cp);\n\tlock_sock(sock->sk);\n\trds_tcp_set_callbacks(sock, cp);\n\trelease_sock(sock->sk);\n}\n\n \nvoid rds_tcp_set_callbacks(struct socket *sock, struct rds_conn_path *cp)\n{\n\tstruct rds_tcp_connection *tc = cp->cp_transport_data;\n\n\trdsdebug(\"setting sock %p callbacks to tc %p\\n\", sock, tc);\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\n\t \n\tspin_lock(&rds_tcp_tc_list_lock);\n\tlist_add_tail(&tc->t_list_item, &rds_tcp_tc_list);\n#if IS_ENABLED(CONFIG_IPV6)\n\trds6_tcp_tc_count++;\n#endif\n\tif (!tc->t_cpath->cp_conn->c_isv6)\n\t\trds_tcp_tc_count++;\n\tspin_unlock(&rds_tcp_tc_list_lock);\n\n\t \n\tif (sock->sk->sk_data_ready == rds_tcp_listen_data_ready)\n\t\tsock->sk->sk_data_ready = sock->sk->sk_user_data;\n\n\ttc->t_sock = sock;\n\ttc->t_cpath = cp;\n\ttc->t_orig_data_ready = sock->sk->sk_data_ready;\n\ttc->t_orig_write_space = sock->sk->sk_write_space;\n\ttc->t_orig_state_change = sock->sk->sk_state_change;\n\n\tsock->sk->sk_user_data = cp;\n\tsock->sk->sk_data_ready = rds_tcp_data_ready;\n\tsock->sk->sk_write_space = rds_tcp_write_space;\n\tsock->sk->sk_state_change = rds_tcp_state_change;\n\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n}\n\n \nstatic void rds_tcp_tc_info(struct socket *rds_sock, unsigned int len,\n\t\t\t    struct rds_info_iterator *iter,\n\t\t\t    struct rds_info_lengths *lens)\n{\n\tstruct rds_info_tcp_socket tsinfo;\n\tstruct rds_tcp_connection *tc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rds_tcp_tc_list_lock, flags);\n\n\tif (len / sizeof(tsinfo) < rds_tcp_tc_count)\n\t\tgoto out;\n\n\tlist_for_each_entry(tc, &rds_tcp_tc_list, t_list_item) {\n\t\tstruct inet_sock *inet = inet_sk(tc->t_sock->sk);\n\n\t\tif (tc->t_cpath->cp_conn->c_isv6)\n\t\t\tcontinue;\n\n\t\ttsinfo.local_addr = inet->inet_saddr;\n\t\ttsinfo.local_port = inet->inet_sport;\n\t\ttsinfo.peer_addr = inet->inet_daddr;\n\t\ttsinfo.peer_port = inet->inet_dport;\n\n\t\ttsinfo.hdr_rem = tc->t_tinc_hdr_rem;\n\t\ttsinfo.data_rem = tc->t_tinc_data_rem;\n\t\ttsinfo.last_sent_nxt = tc->t_last_sent_nxt;\n\t\ttsinfo.last_expected_una = tc->t_last_expected_una;\n\t\ttsinfo.last_seen_una = tc->t_last_seen_una;\n\t\ttsinfo.tos = tc->t_cpath->cp_conn->c_tos;\n\n\t\trds_info_copy(iter, &tsinfo, sizeof(tsinfo));\n\t}\n\nout:\n\tlens->nr = rds_tcp_tc_count;\n\tlens->each = sizeof(tsinfo);\n\n\tspin_unlock_irqrestore(&rds_tcp_tc_list_lock, flags);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstatic void rds6_tcp_tc_info(struct socket *sock, unsigned int len,\n\t\t\t     struct rds_info_iterator *iter,\n\t\t\t     struct rds_info_lengths *lens)\n{\n\tstruct rds6_info_tcp_socket tsinfo6;\n\tstruct rds_tcp_connection *tc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rds_tcp_tc_list_lock, flags);\n\n\tif (len / sizeof(tsinfo6) < rds6_tcp_tc_count)\n\t\tgoto out;\n\n\tlist_for_each_entry(tc, &rds_tcp_tc_list, t_list_item) {\n\t\tstruct sock *sk = tc->t_sock->sk;\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\ttsinfo6.local_addr = sk->sk_v6_rcv_saddr;\n\t\ttsinfo6.local_port = inet->inet_sport;\n\t\ttsinfo6.peer_addr = sk->sk_v6_daddr;\n\t\ttsinfo6.peer_port = inet->inet_dport;\n\n\t\ttsinfo6.hdr_rem = tc->t_tinc_hdr_rem;\n\t\ttsinfo6.data_rem = tc->t_tinc_data_rem;\n\t\ttsinfo6.last_sent_nxt = tc->t_last_sent_nxt;\n\t\ttsinfo6.last_expected_una = tc->t_last_expected_una;\n\t\ttsinfo6.last_seen_una = tc->t_last_seen_una;\n\n\t\trds_info_copy(iter, &tsinfo6, sizeof(tsinfo6));\n\t}\n\nout:\n\tlens->nr = rds6_tcp_tc_count;\n\tlens->each = sizeof(tsinfo6);\n\n\tspin_unlock_irqrestore(&rds_tcp_tc_list_lock, flags);\n}\n#endif\n\nint rds_tcp_laddr_check(struct net *net, const struct in6_addr *addr,\n\t\t\t__u32 scope_id)\n{\n\tstruct net_device *dev = NULL;\n#if IS_ENABLED(CONFIG_IPV6)\n\tint ret;\n#endif\n\n\tif (ipv6_addr_v4mapped(addr)) {\n\t\tif (inet_addr_type(net, addr->s6_addr32[3]) == RTN_LOCAL)\n\t\t\treturn 0;\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t \n\tif (scope_id != 0) {\n\t\trcu_read_lock();\n\t\tdev = dev_get_by_index_rcu(net, scope_id);\n\t\t \n\t\tif (!dev) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tret = ipv6_chk_addr(net, addr, dev, 0);\n\tif (ret)\n\t\treturn 0;\n#endif\n\treturn -EADDRNOTAVAIL;\n}\n\nstatic void rds_tcp_conn_free(void *arg)\n{\n\tstruct rds_tcp_connection *tc = arg;\n\tunsigned long flags;\n\n\trdsdebug(\"freeing tc %p\\n\", tc);\n\n\tspin_lock_irqsave(&rds_tcp_conn_lock, flags);\n\tif (!tc->t_tcp_node_detached)\n\t\tlist_del(&tc->t_tcp_node);\n\tspin_unlock_irqrestore(&rds_tcp_conn_lock, flags);\n\n\tkmem_cache_free(rds_tcp_conn_slab, tc);\n}\n\nstatic int rds_tcp_conn_alloc(struct rds_connection *conn, gfp_t gfp)\n{\n\tstruct rds_tcp_connection *tc;\n\tint i, j;\n\tint ret = 0;\n\n\tfor (i = 0; i < RDS_MPATH_WORKERS; i++) {\n\t\ttc = kmem_cache_alloc(rds_tcp_conn_slab, gfp);\n\t\tif (!tc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tmutex_init(&tc->t_conn_path_lock);\n\t\ttc->t_sock = NULL;\n\t\ttc->t_tinc = NULL;\n\t\ttc->t_tinc_hdr_rem = sizeof(struct rds_header);\n\t\ttc->t_tinc_data_rem = 0;\n\n\t\tconn->c_path[i].cp_transport_data = tc;\n\t\ttc->t_cpath = &conn->c_path[i];\n\t\ttc->t_tcp_node_detached = true;\n\n\t\trdsdebug(\"rds_conn_path [%d] tc %p\\n\", i,\n\t\t\t conn->c_path[i].cp_transport_data);\n\t}\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tfor (i = 0; i < RDS_MPATH_WORKERS; i++) {\n\t\ttc = conn->c_path[i].cp_transport_data;\n\t\ttc->t_tcp_node_detached = false;\n\t\tlist_add_tail(&tc->t_tcp_node, &rds_tcp_conn_list);\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\nfail:\n\tif (ret) {\n\t\tfor (j = 0; j < i; j++)\n\t\t\trds_tcp_conn_free(conn->c_path[j].cp_transport_data);\n\t}\n\treturn ret;\n}\n\nstatic bool list_has_conn(struct list_head *list, struct rds_connection *conn)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\n\tlist_for_each_entry_safe(tc, _tc, list, t_tcp_node) {\n\t\tif (tc->t_cpath->cp_conn == conn)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void rds_tcp_set_unloading(void)\n{\n\tatomic_set(&rds_tcp_unloading, 1);\n}\n\nstatic bool rds_tcp_is_unloading(struct rds_connection *conn)\n{\n\treturn atomic_read(&rds_tcp_unloading) != 0;\n}\n\nstatic void rds_tcp_destroy_conns(void)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\n\t \n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn))\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}\n\nstatic void rds_tcp_exit(void);\n\nstatic u8 rds_tcp_get_tos_map(u8 tos)\n{\n\t \n\treturn 0;\n}\n\nstruct rds_transport rds_tcp_transport = {\n\t.laddr_check\t\t= rds_tcp_laddr_check,\n\t.xmit_path_prepare\t= rds_tcp_xmit_path_prepare,\n\t.xmit_path_complete\t= rds_tcp_xmit_path_complete,\n\t.xmit\t\t\t= rds_tcp_xmit,\n\t.recv_path\t\t= rds_tcp_recv_path,\n\t.conn_alloc\t\t= rds_tcp_conn_alloc,\n\t.conn_free\t\t= rds_tcp_conn_free,\n\t.conn_path_connect\t= rds_tcp_conn_path_connect,\n\t.conn_path_shutdown\t= rds_tcp_conn_path_shutdown,\n\t.inc_copy_to_user\t= rds_tcp_inc_copy_to_user,\n\t.inc_free\t\t= rds_tcp_inc_free,\n\t.stats_info_copy\t= rds_tcp_stats_info_copy,\n\t.exit\t\t\t= rds_tcp_exit,\n\t.get_tos_map\t\t= rds_tcp_get_tos_map,\n\t.t_owner\t\t= THIS_MODULE,\n\t.t_name\t\t\t= \"tcp\",\n\t.t_type\t\t\t= RDS_TRANS_TCP,\n\t.t_prefer_loopback\t= 1,\n\t.t_mp_capable\t\t= 1,\n\t.t_unloading\t\t= rds_tcp_is_unloading,\n};\n\nstatic unsigned int rds_tcp_netid;\n\n \nstruct rds_tcp_net {\n\tstruct socket *rds_tcp_listen_sock;\n\tstruct work_struct rds_tcp_accept_w;\n\tstruct ctl_table_header *rds_tcp_sysctl;\n\tstruct ctl_table *ctl_table;\n\tint sndbuf_size;\n\tint rcvbuf_size;\n};\n\n \nbool rds_tcp_tune(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct rds_tcp_net *rtn;\n\n\ttcp_sock_set_nodelay(sock->sk);\n\tlock_sock(sk);\n\t \n\tif (!sk->sk_net_refcnt) {\n\t\tif (!maybe_get_net(net)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn false;\n\t\t}\n\t\t \n\t\t__netns_tracker_free(net, &sk->ns_tracker, false);\n\n\t\tsk->sk_net_refcnt = 1;\n\t\tnetns_tracker_alloc(net, &sk->ns_tracker, GFP_KERNEL);\n\t\tsock_inuse_add(net, 1);\n\t}\n\trtn = net_generic(net, rds_tcp_netid);\n\tif (rtn->sndbuf_size > 0) {\n\t\tsk->sk_sndbuf = rtn->sndbuf_size;\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t}\n\tif (rtn->rcvbuf_size > 0) {\n\t\tsk->sk_rcvbuf = rtn->rcvbuf_size;\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t}\n\trelease_sock(sk);\n\treturn true;\n}\n\nstatic void rds_tcp_accept_worker(struct work_struct *work)\n{\n\tstruct rds_tcp_net *rtn = container_of(work,\n\t\t\t\t\t       struct rds_tcp_net,\n\t\t\t\t\t       rds_tcp_accept_w);\n\n\twhile (rds_tcp_accept_one(rtn->rds_tcp_listen_sock) == 0)\n\t\tcond_resched();\n}\n\nvoid rds_tcp_accept_work(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\n\tqueue_work(rds_wq, &rtn->rds_tcp_accept_w);\n}\n\nstatic __net_init int rds_tcp_init_net(struct net *net)\n{\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct ctl_table *tbl;\n\tint err = 0;\n\n\tmemset(rtn, 0, sizeof(*rtn));\n\n\t \n\tif (net == &init_net) {\n\t\ttbl = rds_tcp_sysctl_table;\n\t} else {\n\t\ttbl = kmemdup(rds_tcp_sysctl_table,\n\t\t\t      sizeof(rds_tcp_sysctl_table), GFP_KERNEL);\n\t\tif (!tbl) {\n\t\t\tpr_warn(\"could not set allocate sysctl table\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trtn->ctl_table = tbl;\n\t}\n\ttbl[RDS_TCP_SNDBUF].data = &rtn->sndbuf_size;\n\ttbl[RDS_TCP_RCVBUF].data = &rtn->rcvbuf_size;\n\trtn->rds_tcp_sysctl = register_net_sysctl_sz(net, \"net/rds/tcp\", tbl,\n\t\t\t\t\t\t     ARRAY_SIZE(rds_tcp_sysctl_table));\n\tif (!rtn->rds_tcp_sysctl) {\n\t\tpr_warn(\"could not register sysctl\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\trtn->rds_tcp_listen_sock = rds_tcp_listen_init(net, true);\n#else\n\trtn->rds_tcp_listen_sock = rds_tcp_listen_init(net, false);\n#endif\n\tif (!rtn->rds_tcp_listen_sock) {\n\t\tpr_warn(\"could not set up IPv6 listen sock\\n\");\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t \n\t\trtn->rds_tcp_listen_sock = rds_tcp_listen_init(net, false);\n\t\tif (!rtn->rds_tcp_listen_sock) {\n#endif\n\t\t\tunregister_net_sysctl_table(rtn->rds_tcp_sysctl);\n\t\t\trtn->rds_tcp_sysctl = NULL;\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tgoto fail;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t}\n#endif\n\t}\n\tINIT_WORK(&rtn->rds_tcp_accept_w, rds_tcp_accept_worker);\n\treturn 0;\n\nfail:\n\tif (net != &init_net)\n\t\tkfree(tbl);\n\treturn err;\n}\n\nstatic void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\n\t\tif (net != c_net)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}\n\nstatic void __net_exit rds_tcp_exit_net(struct net *net)\n{\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\n\trds_tcp_kill_sock(net);\n\n\tif (rtn->rds_tcp_sysctl)\n\t\tunregister_net_sysctl_table(rtn->rds_tcp_sysctl);\n\n\tif (net != &init_net)\n\t\tkfree(rtn->ctl_table);\n}\n\nstatic struct pernet_operations rds_tcp_net_ops = {\n\t.init = rds_tcp_init_net,\n\t.exit = rds_tcp_exit_net,\n\t.id = &rds_tcp_netid,\n\t.size = sizeof(struct rds_tcp_net),\n};\n\nvoid *rds_tcp_listen_sock_def_readable(struct net *net)\n{\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\n\tif (!lsock)\n\t\treturn NULL;\n\n\treturn lsock->sk->sk_user_data;\n}\n\n \nstatic void rds_tcp_sysctl_reset(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\n\t\t \n\t\trds_conn_path_drop(tc->t_cpath, false);\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n}\n\nstatic int rds_tcp_skbuf_handler(struct ctl_table *ctl, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *fpos)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tint err;\n\n\terr = proc_dointvec_minmax(ctl, write, buffer, lenp, fpos);\n\tif (err < 0) {\n\t\tpr_warn(\"Invalid input. Must be >= %d\\n\",\n\t\t\t*(int *)(ctl->extra1));\n\t\treturn err;\n\t}\n\tif (write)\n\t\trds_tcp_sysctl_reset(net);\n\treturn 0;\n}\n\nstatic void rds_tcp_exit(void)\n{\n\trds_tcp_set_unloading();\n\tsynchronize_rcu();\n\trds_info_deregister_func(RDS_INFO_TCP_SOCKETS, rds_tcp_tc_info);\n#if IS_ENABLED(CONFIG_IPV6)\n\trds_info_deregister_func(RDS6_INFO_TCP_SOCKETS, rds6_tcp_tc_info);\n#endif\n\tunregister_pernet_device(&rds_tcp_net_ops);\n\trds_tcp_destroy_conns();\n\trds_trans_unregister(&rds_tcp_transport);\n\trds_tcp_recv_exit();\n\tkmem_cache_destroy(rds_tcp_conn_slab);\n}\nmodule_exit(rds_tcp_exit);\n\nstatic int __init rds_tcp_init(void)\n{\n\tint ret;\n\n\trds_tcp_conn_slab = kmem_cache_create(\"rds_tcp_connection\",\n\t\t\t\t\t      sizeof(struct rds_tcp_connection),\n\t\t\t\t\t      0, 0, NULL);\n\tif (!rds_tcp_conn_slab) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = rds_tcp_recv_init();\n\tif (ret)\n\t\tgoto out_slab;\n\n\tret = register_pernet_device(&rds_tcp_net_ops);\n\tif (ret)\n\t\tgoto out_recv;\n\n\trds_trans_register(&rds_tcp_transport);\n\n\trds_info_register_func(RDS_INFO_TCP_SOCKETS, rds_tcp_tc_info);\n#if IS_ENABLED(CONFIG_IPV6)\n\trds_info_register_func(RDS6_INFO_TCP_SOCKETS, rds6_tcp_tc_info);\n#endif\n\n\tgoto out;\nout_recv:\n\trds_tcp_recv_exit();\nout_slab:\n\tkmem_cache_destroy(rds_tcp_conn_slab);\nout:\n\treturn ret;\n}\nmodule_init(rds_tcp_init);\n\nMODULE_AUTHOR(\"Oracle Corporation <rds-devel@oss.oracle.com>\");\nMODULE_DESCRIPTION(\"RDS: TCP transport\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}