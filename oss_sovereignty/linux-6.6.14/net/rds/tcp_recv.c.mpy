{
  "module_name": "tcp_recv.c",
  "hash_id": "9e29e8a8e6bfab03a12096d12e2c5c3374057a511bbfeee621b7dfaeb64cc687",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/tcp_recv.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <net/tcp.h>\n#include <trace/events/sock.h>\n\n#include \"rds.h\"\n#include \"tcp.h\"\n\nstatic struct kmem_cache *rds_tcp_incoming_slab;\n\nstatic void rds_tcp_inc_purge(struct rds_incoming *inc)\n{\n\tstruct rds_tcp_incoming *tinc;\n\ttinc = container_of(inc, struct rds_tcp_incoming, ti_inc);\n\trdsdebug(\"purging tinc %p inc %p\\n\", tinc, inc);\n\tskb_queue_purge(&tinc->ti_skb_list);\n}\n\nvoid rds_tcp_inc_free(struct rds_incoming *inc)\n{\n\tstruct rds_tcp_incoming *tinc;\n\ttinc = container_of(inc, struct rds_tcp_incoming, ti_inc);\n\trds_tcp_inc_purge(inc);\n\trdsdebug(\"freeing tinc %p inc %p\\n\", tinc, inc);\n\tkmem_cache_free(rds_tcp_incoming_slab, tinc);\n}\n\n \nint rds_tcp_inc_copy_to_user(struct rds_incoming *inc, struct iov_iter *to)\n{\n\tstruct rds_tcp_incoming *tinc;\n\tstruct sk_buff *skb;\n\tint ret = 0;\n\n\tif (!iov_iter_count(to))\n\t\tgoto out;\n\n\ttinc = container_of(inc, struct rds_tcp_incoming, ti_inc);\n\n\tskb_queue_walk(&tinc->ti_skb_list, skb) {\n\t\tunsigned long to_copy, skb_off;\n\t\tfor (skb_off = 0; skb_off < skb->len; skb_off += to_copy) {\n\t\t\tto_copy = iov_iter_count(to);\n\t\t\tto_copy = min(to_copy, skb->len - skb_off);\n\n\t\t\tif (skb_copy_datagram_iter(skb, skb_off, to, to_copy))\n\t\t\t\treturn -EFAULT;\n\n\t\t\trds_stats_add(s_copy_to_user, to_copy);\n\t\t\tret += to_copy;\n\n\t\t\tif (!iov_iter_count(to))\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\n \n\nstatic void rds_tcp_cong_recv(struct rds_connection *conn,\n\t\t\t      struct rds_tcp_incoming *tinc)\n{\n\tstruct sk_buff *skb;\n\tunsigned int to_copy, skb_off;\n\tunsigned int map_off;\n\tunsigned int map_page;\n\tstruct rds_cong_map *map;\n\tint ret;\n\n\t \n\tif (be32_to_cpu(tinc->ti_inc.i_hdr.h_len) != RDS_CONG_MAP_BYTES)\n\t\treturn;\n\n\tmap_page = 0;\n\tmap_off = 0;\n\tmap = conn->c_fcong;\n\n\tskb_queue_walk(&tinc->ti_skb_list, skb) {\n\t\tskb_off = 0;\n\t\twhile (skb_off < skb->len) {\n\t\t\tto_copy = min_t(unsigned int, PAGE_SIZE - map_off,\n\t\t\t\t\tskb->len - skb_off);\n\n\t\t\tBUG_ON(map_page >= RDS_CONG_MAP_PAGES);\n\n\t\t\t \n\t\t\tret = skb_copy_bits(skb, skb_off,\n\t\t\t\t(void *)map->m_page_addrs[map_page] + map_off,\n\t\t\t\tto_copy);\n\t\t\tBUG_ON(ret != 0);\n\n\t\t\tskb_off += to_copy;\n\t\t\tmap_off += to_copy;\n\t\t\tif (map_off == PAGE_SIZE) {\n\t\t\t\tmap_off = 0;\n\t\t\t\tmap_page++;\n\t\t\t}\n\t\t}\n\t}\n\n\trds_cong_map_updated(map, ~(u64) 0);\n}\n\nstruct rds_tcp_desc_arg {\n\tstruct rds_conn_path *conn_path;\n\tgfp_t gfp;\n};\n\nstatic int rds_tcp_data_recv(read_descriptor_t *desc, struct sk_buff *skb,\n\t\t\t     unsigned int offset, size_t len)\n{\n\tstruct rds_tcp_desc_arg *arg = desc->arg.data;\n\tstruct rds_conn_path *cp = arg->conn_path;\n\tstruct rds_tcp_connection *tc = cp->cp_transport_data;\n\tstruct rds_tcp_incoming *tinc = tc->t_tinc;\n\tstruct sk_buff *clone;\n\tsize_t left = len, to_copy;\n\n\trdsdebug(\"tcp data tc %p skb %p offset %u len %zu\\n\", tc, skb, offset,\n\t\t len);\n\n\t \n\twhile (left) {\n\t\tif (!tinc) {\n\t\t\ttinc = kmem_cache_alloc(rds_tcp_incoming_slab,\n\t\t\t\t\t\targ->gfp);\n\t\t\tif (!tinc) {\n\t\t\t\tdesc->error = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttc->t_tinc = tinc;\n\t\t\trdsdebug(\"allocated tinc %p\\n\", tinc);\n\t\t\trds_inc_path_init(&tinc->ti_inc, cp,\n\t\t\t\t\t  &cp->cp_conn->c_faddr);\n\t\t\ttinc->ti_inc.i_rx_lat_trace[RDS_MSG_RX_HDR] =\n\t\t\t\t\tlocal_clock();\n\n\t\t\t \n\t\t\tskb_queue_head_init(&tinc->ti_skb_list);\n\t\t}\n\n\t\tif (left && tc->t_tinc_hdr_rem) {\n\t\t\tto_copy = min(tc->t_tinc_hdr_rem, left);\n\t\t\trdsdebug(\"copying %zu header from skb %p\\n\", to_copy,\n\t\t\t\t skb);\n\t\t\tskb_copy_bits(skb, offset,\n\t\t\t\t      (char *)&tinc->ti_inc.i_hdr +\n\t\t\t\t\t\tsizeof(struct rds_header) -\n\t\t\t\t\t\ttc->t_tinc_hdr_rem,\n\t\t\t\t      to_copy);\n\t\t\ttc->t_tinc_hdr_rem -= to_copy;\n\t\t\tleft -= to_copy;\n\t\t\toffset += to_copy;\n\n\t\t\tif (tc->t_tinc_hdr_rem == 0) {\n\t\t\t\t \n\t\t\t\ttc->t_tinc_data_rem =\n\t\t\t\t\tbe32_to_cpu(tinc->ti_inc.i_hdr.h_len);\n\t\t\t\ttinc->ti_inc.i_rx_lat_trace[RDS_MSG_RX_START] =\n\t\t\t\t\tlocal_clock();\n\t\t\t}\n\t\t}\n\n\t\tif (left && tc->t_tinc_data_rem) {\n\t\t\tto_copy = min(tc->t_tinc_data_rem, left);\n\n\t\t\tclone = pskb_extract(skb, offset, to_copy, arg->gfp);\n\t\t\tif (!clone) {\n\t\t\t\tdesc->error = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tskb_queue_tail(&tinc->ti_skb_list, clone);\n\n\t\t\trdsdebug(\"skb %p data %p len %d off %u to_copy %zu -> \"\n\t\t\t\t \"clone %p data %p len %d\\n\",\n\t\t\t\t skb, skb->data, skb->len, offset, to_copy,\n\t\t\t\t clone, clone->data, clone->len);\n\n\t\t\ttc->t_tinc_data_rem -= to_copy;\n\t\t\tleft -= to_copy;\n\t\t\toffset += to_copy;\n\t\t}\n\n\t\tif (tc->t_tinc_hdr_rem == 0 && tc->t_tinc_data_rem == 0) {\n\t\t\tstruct rds_connection *conn = cp->cp_conn;\n\n\t\t\tif (tinc->ti_inc.i_hdr.h_flags == RDS_FLAG_CONG_BITMAP)\n\t\t\t\trds_tcp_cong_recv(conn, tinc);\n\t\t\telse\n\t\t\t\trds_recv_incoming(conn, &conn->c_faddr,\n\t\t\t\t\t\t  &conn->c_laddr,\n\t\t\t\t\t\t  &tinc->ti_inc,\n\t\t\t\t\t\t  arg->gfp);\n\n\t\t\ttc->t_tinc_hdr_rem = sizeof(struct rds_header);\n\t\t\ttc->t_tinc_data_rem = 0;\n\t\t\ttc->t_tinc = NULL;\n\t\t\trds_inc_put(&tinc->ti_inc);\n\t\t\ttinc = NULL;\n\t\t}\n\t}\nout:\n\trdsdebug(\"returning len %zu left %zu skb len %d rx queue depth %d\\n\",\n\t\t len, left, skb->len,\n\t\t skb_queue_len(&tc->t_sock->sk->sk_receive_queue));\n\treturn len - left;\n}\n\n \nstatic int rds_tcp_read_sock(struct rds_conn_path *cp, gfp_t gfp)\n{\n\tstruct rds_tcp_connection *tc = cp->cp_transport_data;\n\tstruct socket *sock = tc->t_sock;\n\tread_descriptor_t desc;\n\tstruct rds_tcp_desc_arg arg;\n\n\t \n\targ.conn_path = cp;\n\targ.gfp = gfp;\n\tdesc.arg.data = &arg;\n\tdesc.error = 0;\n\tdesc.count = 1;  \n\n\ttcp_read_sock(sock->sk, &desc, rds_tcp_data_recv);\n\trdsdebug(\"tcp_read_sock for tc %p gfp 0x%x returned %d\\n\", tc, gfp,\n\t\t desc.error);\n\n\treturn desc.error;\n}\n\n \nint rds_tcp_recv_path(struct rds_conn_path *cp)\n{\n\tstruct rds_tcp_connection *tc = cp->cp_transport_data;\n\tstruct socket *sock = tc->t_sock;\n\tint ret = 0;\n\n\trdsdebug(\"recv worker path [%d] tc %p sock %p\\n\",\n\t\t cp->cp_index, tc, sock);\n\n\tlock_sock(sock->sk);\n\tret = rds_tcp_read_sock(cp, GFP_KERNEL);\n\trelease_sock(sock->sk);\n\n\treturn ret;\n}\n\nvoid rds_tcp_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\tstruct rds_conn_path *cp;\n\tstruct rds_tcp_connection *tc;\n\n\ttrace_sk_data_ready(sk);\n\trdsdebug(\"data ready sk %p\\n\", sk);\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tcp = sk->sk_user_data;\n\tif (!cp) {  \n\t\tready = sk->sk_data_ready;\n\t\tgoto out;\n\t}\n\n\ttc = cp->cp_transport_data;\n\tready = tc->t_orig_data_ready;\n\trds_tcp_stats_inc(s_tcp_data_ready_calls);\n\n\tif (rds_tcp_read_sock(cp, GFP_ATOMIC) == -ENOMEM) {\n\t\trcu_read_lock();\n\t\tif (!rds_destroy_pending(cp->cp_conn))\n\t\t\tqueue_delayed_work(rds_wq, &cp->cp_recv_w, 0);\n\t\trcu_read_unlock();\n\t}\nout:\n\tread_unlock_bh(&sk->sk_callback_lock);\n\tready(sk);\n}\n\nint rds_tcp_recv_init(void)\n{\n\trds_tcp_incoming_slab = kmem_cache_create(\"rds_tcp_incoming\",\n\t\t\t\t\tsizeof(struct rds_tcp_incoming),\n\t\t\t\t\t0, 0, NULL);\n\tif (!rds_tcp_incoming_slab)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid rds_tcp_recv_exit(void)\n{\n\tkmem_cache_destroy(rds_tcp_incoming_slab);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}