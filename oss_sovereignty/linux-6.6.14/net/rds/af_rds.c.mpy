{
  "module_name": "af_rds.c",
  "hash_id": "503a405782ff5f40d0b5356e7ebc9b53816617579fe694b5f2dde5f2116767b8",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/af_rds.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/in.h>\n#include <linux/ipv6.h>\n#include <linux/poll.h>\n#include <net/sock.h>\n\n#include \"rds.h\"\n\n \nstatic DEFINE_SPINLOCK(rds_sock_lock);\nstatic unsigned long rds_sock_count;\nstatic LIST_HEAD(rds_sock_list);\nDECLARE_WAIT_QUEUE_HEAD(rds_poll_waitq);\n\n \nstatic int rds_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs;\n\n\tif (!sk)\n\t\tgoto out;\n\n\trs = rds_sk_to_rs(sk);\n\n\tsock_orphan(sk);\n\t \n\trds_clear_recv_queue(rs);\n\trds_cong_remove_socket(rs);\n\n\trds_remove_bound(rs);\n\n\trds_send_drop_to(rs, NULL);\n\trds_rdma_drop_keys(rs);\n\trds_notify_queue_get(rs, NULL);\n\trds_notify_msg_zcopy_purge(&rs->rs_zcookie_queue);\n\n\tspin_lock_bh(&rds_sock_lock);\n\tlist_del_init(&rs->rs_item);\n\trds_sock_count--;\n\tspin_unlock_bh(&rds_sock_lock);\n\n\trds_trans_put(rs->rs_transport);\n\n\tsock->sk = NULL;\n\tsock_put(sk);\nout:\n\treturn 0;\n}\n\n \nvoid rds_wake_sk_sleep(struct rds_sock *rs)\n{\n\tunsigned long flags;\n\n\tread_lock_irqsave(&rs->rs_recv_lock, flags);\n\t__rds_wake_sk_sleep(rds_rs_to_sk(rs));\n\tread_unlock_irqrestore(&rs->rs_recv_lock, flags);\n}\n\nstatic int rds_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int peer)\n{\n\tstruct rds_sock *rs = rds_sk_to_rs(sock->sk);\n\tstruct sockaddr_in6 *sin6;\n\tstruct sockaddr_in *sin;\n\tint uaddr_len;\n\n\t \n\tif (peer) {\n\t\tif (ipv6_addr_any(&rs->rs_conn_addr))\n\t\t\treturn -ENOTCONN;\n\n\t\tif (ipv6_addr_v4mapped(&rs->rs_conn_addr)) {\n\t\t\tsin = (struct sockaddr_in *)uaddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = rs->rs_conn_port;\n\t\t\tsin->sin_addr.s_addr = rs->rs_conn_addr_v4;\n\t\t\tuaddr_len = sizeof(*sin);\n\t\t} else {\n\t\t\tsin6 = (struct sockaddr_in6 *)uaddr;\n\t\t\tsin6->sin6_family = AF_INET6;\n\t\t\tsin6->sin6_port = rs->rs_conn_port;\n\t\t\tsin6->sin6_addr = rs->rs_conn_addr;\n\t\t\tsin6->sin6_flowinfo = 0;\n\t\t\t \n\t\t\tsin6->sin6_scope_id = rs->rs_bound_scope_id;\n\t\t\tuaddr_len = sizeof(*sin6);\n\t\t}\n\t} else {\n\t\t \n\t\tif (ipv6_addr_any(&rs->rs_bound_addr)) {\n\t\t\tif (ipv6_addr_any(&rs->rs_conn_addr)) {\n\t\t\t\tsin = (struct sockaddr_in *)uaddr;\n\t\t\t\tmemset(sin, 0, sizeof(*sin));\n\t\t\t\tsin->sin_family = AF_UNSPEC;\n\t\t\t\treturn sizeof(*sin);\n\t\t\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tif (!(ipv6_addr_type(&rs->rs_conn_addr) &\n\t\t\t      IPV6_ADDR_MAPPED)) {\n\t\t\t\tsin6 = (struct sockaddr_in6 *)uaddr;\n\t\t\t\tmemset(sin6, 0, sizeof(*sin6));\n\t\t\t\tsin6->sin6_family = AF_INET6;\n\t\t\t\treturn sizeof(*sin6);\n\t\t\t}\n#endif\n\n\t\t\tsin = (struct sockaddr_in *)uaddr;\n\t\t\tmemset(sin, 0, sizeof(*sin));\n\t\t\tsin->sin_family = AF_INET;\n\t\t\treturn sizeof(*sin);\n\t\t}\n\t\tif (ipv6_addr_v4mapped(&rs->rs_bound_addr)) {\n\t\t\tsin = (struct sockaddr_in *)uaddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = rs->rs_bound_port;\n\t\t\tsin->sin_addr.s_addr = rs->rs_bound_addr_v4;\n\t\t\tuaddr_len = sizeof(*sin);\n\t\t} else {\n\t\t\tsin6 = (struct sockaddr_in6 *)uaddr;\n\t\t\tsin6->sin6_family = AF_INET6;\n\t\t\tsin6->sin6_port = rs->rs_bound_port;\n\t\t\tsin6->sin6_addr = rs->rs_bound_addr;\n\t\t\tsin6->sin6_flowinfo = 0;\n\t\t\tsin6->sin6_scope_id = rs->rs_bound_scope_id;\n\t\t\tuaddr_len = sizeof(*sin6);\n\t\t}\n\t}\n\n\treturn uaddr_len;\n}\n\n \nstatic __poll_t rds_poll(struct file *file, struct socket *sock,\n\t\t\t     poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\t__poll_t mask = 0;\n\tunsigned long flags;\n\n\tpoll_wait(file, sk_sleep(sk), wait);\n\n\tif (rs->rs_seen_congestion)\n\t\tpoll_wait(file, &rds_poll_waitq, wait);\n\n\tread_lock_irqsave(&rs->rs_recv_lock, flags);\n\tif (!rs->rs_cong_monitor) {\n\t\t \n\t\tif (rds_cong_updated_since(&rs->rs_cong_track))\n\t\t\tmask |= (EPOLLIN | EPOLLRDNORM | EPOLLWRBAND);\n\t} else {\n\t\tspin_lock(&rs->rs_lock);\n\t\tif (rs->rs_cong_notify)\n\t\t\tmask |= (EPOLLIN | EPOLLRDNORM);\n\t\tspin_unlock(&rs->rs_lock);\n\t}\n\tif (!list_empty(&rs->rs_recv_queue) ||\n\t    !list_empty(&rs->rs_notify_queue) ||\n\t    !list_empty(&rs->rs_zcookie_queue.zcookie_head))\n\t\tmask |= (EPOLLIN | EPOLLRDNORM);\n\tif (rs->rs_snd_bytes < rds_sk_sndbuf(rs))\n\t\tmask |= (EPOLLOUT | EPOLLWRNORM);\n\tif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\n\t\tmask |= POLLERR;\n\tread_unlock_irqrestore(&rs->rs_recv_lock, flags);\n\n\t \n\tif (mask)\n\t\trs->rs_seen_congestion = 0;\n\n\treturn mask;\n}\n\nstatic int rds_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct rds_sock *rs = rds_sk_to_rs(sock->sk);\n\trds_tos_t utos, tos = 0;\n\n\tswitch (cmd) {\n\tcase SIOCRDSSETTOS:\n\t\tif (get_user(utos, (rds_tos_t __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tif (rs->rs_transport &&\n\t\t    rs->rs_transport->get_tos_map)\n\t\t\ttos = rs->rs_transport->get_tos_map(utos);\n\t\telse\n\t\t\treturn -ENOIOCTLCMD;\n\n\t\tspin_lock_bh(&rds_sock_lock);\n\t\tif (rs->rs_tos || rs->rs_conn) {\n\t\t\tspin_unlock_bh(&rds_sock_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trs->rs_tos = tos;\n\t\tspin_unlock_bh(&rds_sock_lock);\n\t\tbreak;\n\tcase SIOCRDSGETTOS:\n\t\tspin_lock_bh(&rds_sock_lock);\n\t\ttos = rs->rs_tos;\n\t\tspin_unlock_bh(&rds_sock_lock);\n\t\tif (put_user(tos, (rds_tos_t __user *)arg))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic int rds_cancel_sent_to(struct rds_sock *rs, sockptr_t optval, int len)\n{\n\tstruct sockaddr_in6 sin6;\n\tstruct sockaddr_in sin;\n\tint ret = 0;\n\n\t \n\tif (ipv6_addr_any(&rs->rs_bound_addr)) {\n\t\tret = -ENOTCONN;  \n\t\tgoto out;\n\t}\n\n\tif (len < sizeof(struct sockaddr_in)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t} else if (len < sizeof(struct sockaddr_in6)) {\n\t\t \n\t\tif (copy_from_sockptr(&sin, optval,\n\t\t\t\tsizeof(struct sockaddr_in))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tipv6_addr_set_v4mapped(sin.sin_addr.s_addr, &sin6.sin6_addr);\n\t\tsin6.sin6_port = sin.sin_port;\n\t} else {\n\t\tif (copy_from_sockptr(&sin6, optval,\n\t\t\t\t   sizeof(struct sockaddr_in6))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trds_send_drop_to(rs, &sin6);\nout:\n\treturn ret;\n}\n\nstatic int rds_set_bool_option(unsigned char *optvar, sockptr_t optval,\n\t\t\t       int optlen)\n{\n\tint value;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&value, optval, sizeof(int)))\n\t\treturn -EFAULT;\n\t*optvar = !!value;\n\treturn 0;\n}\n\nstatic int rds_cong_monitor(struct rds_sock *rs, sockptr_t optval, int optlen)\n{\n\tint ret;\n\n\tret = rds_set_bool_option(&rs->rs_cong_monitor, optval, optlen);\n\tif (ret == 0) {\n\t\tif (rs->rs_cong_monitor) {\n\t\t\trds_cong_add_socket(rs);\n\t\t} else {\n\t\t\trds_cong_remove_socket(rs);\n\t\t\trs->rs_cong_mask = 0;\n\t\t\trs->rs_cong_notify = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int rds_set_transport(struct rds_sock *rs, sockptr_t optval, int optlen)\n{\n\tint t_type;\n\n\tif (rs->rs_transport)\n\t\treturn -EOPNOTSUPP;  \n\n\tif (optlen != sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&t_type, optval, sizeof(t_type)))\n\t\treturn -EFAULT;\n\n\tif (t_type < 0 || t_type >= RDS_TRANS_COUNT)\n\t\treturn -EINVAL;\n\n\trs->rs_transport = rds_trans_get(t_type);\n\n\treturn rs->rs_transport ? 0 : -ENOPROTOOPT;\n}\n\nstatic int rds_enable_recvtstamp(struct sock *sk, sockptr_t optval,\n\t\t\t\t int optlen, int optname)\n{\n\tint val, valbool;\n\n\tif (optlen != sizeof(int))\n\t\treturn -EFAULT;\n\n\tif (copy_from_sockptr(&val, optval, sizeof(int)))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tif (optname == SO_TIMESTAMP_NEW)\n\t\tsock_set_flag(sk, SOCK_TSTAMP_NEW);\n\n\tif (valbool)\n\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\telse\n\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\n\treturn 0;\n}\n\nstatic int rds_recv_track_latency(struct rds_sock *rs, sockptr_t optval,\n\t\t\t\t  int optlen)\n{\n\tstruct rds_rx_trace_so trace;\n\tint i;\n\n\tif (optlen != sizeof(struct rds_rx_trace_so))\n\t\treturn -EFAULT;\n\n\tif (copy_from_sockptr(&trace, optval, sizeof(trace)))\n\t\treturn -EFAULT;\n\n\tif (trace.rx_traces > RDS_MSG_RX_DGRAM_TRACE_MAX)\n\t\treturn -EFAULT;\n\n\trs->rs_rx_traces = trace.rx_traces;\n\tfor (i = 0; i < rs->rs_rx_traces; i++) {\n\t\tif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {\n\t\t\trs->rs_rx_traces = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trs->rs_rx_trace[i] = trace.rx_trace_pos[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int rds_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tstruct rds_sock *rs = rds_sk_to_rs(sock->sk);\n\tint ret;\n\n\tif (level != SOL_RDS) {\n\t\tret = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\n\tswitch (optname) {\n\tcase RDS_CANCEL_SENT_TO:\n\t\tret = rds_cancel_sent_to(rs, optval, optlen);\n\t\tbreak;\n\tcase RDS_GET_MR:\n\t\tret = rds_get_mr(rs, optval, optlen);\n\t\tbreak;\n\tcase RDS_GET_MR_FOR_DEST:\n\t\tret = rds_get_mr_for_dest(rs, optval, optlen);\n\t\tbreak;\n\tcase RDS_FREE_MR:\n\t\tret = rds_free_mr(rs, optval, optlen);\n\t\tbreak;\n\tcase RDS_RECVERR:\n\t\tret = rds_set_bool_option(&rs->rs_recverr, optval, optlen);\n\t\tbreak;\n\tcase RDS_CONG_MONITOR:\n\t\tret = rds_cong_monitor(rs, optval, optlen);\n\t\tbreak;\n\tcase SO_RDS_TRANSPORT:\n\t\tlock_sock(sock->sk);\n\t\tret = rds_set_transport(rs, optval, optlen);\n\t\trelease_sock(sock->sk);\n\t\tbreak;\n\tcase SO_TIMESTAMP_OLD:\n\tcase SO_TIMESTAMP_NEW:\n\t\tlock_sock(sock->sk);\n\t\tret = rds_enable_recvtstamp(sock->sk, optval, optlen, optname);\n\t\trelease_sock(sock->sk);\n\t\tbreak;\n\tcase SO_RDS_MSG_RXPATH_LATENCY:\n\t\tret = rds_recv_track_latency(rs, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int rds_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct rds_sock *rs = rds_sk_to_rs(sock->sk);\n\tint ret = -ENOPROTOOPT, len;\n\tint trans;\n\n\tif (level != SOL_RDS)\n\t\tgoto out;\n\n\tif (get_user(len, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tswitch (optname) {\n\tcase RDS_INFO_FIRST ... RDS_INFO_LAST:\n\t\tret = rds_info_getsockopt(sock, optname, optval,\n\t\t\t\t\t  optlen);\n\t\tbreak;\n\n\tcase RDS_RECVERR:\n\t\tif (len < sizeof(int))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\tif (put_user(rs->rs_recverr, (int __user *) optval) ||\n\t\t    put_user(sizeof(int), optlen))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\tcase SO_RDS_TRANSPORT:\n\t\tif (len < sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\ttrans = (rs->rs_transport ? rs->rs_transport->t_type :\n\t\t\t RDS_TRANS_NONE);  \n\t\tif (put_user(trans, (int __user *)optval) ||\n\t\t    put_user(sizeof(int), optlen))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n\n}\n\nstatic int rds_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_in *sin;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tint ret = 0;\n\n\tif (addr_len < offsetofend(struct sockaddr, sa_family))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (uaddr->sa_family) {\n\tcase AF_INET:\n\t\tsin = (struct sockaddr_in *)uaddr;\n\t\tif (addr_len < sizeof(struct sockaddr_in)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (sin->sin_addr.s_addr == htonl(INADDR_ANY)) {\n\t\t\tret = -EDESTADDRREQ;\n\t\t\tbreak;\n\t\t}\n\t\tif (ipv4_is_multicast(sin->sin_addr.s_addr) ||\n\t\t    sin->sin_addr.s_addr == htonl(INADDR_BROADCAST)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tipv6_addr_set_v4mapped(sin->sin_addr.s_addr, &rs->rs_conn_addr);\n\t\trs->rs_conn_port = sin->sin_port;\n\t\tbreak;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *sin6;\n\t\tint addr_type;\n\n\t\tsin6 = (struct sockaddr_in6 *)uaddr;\n\t\tif (addr_len < sizeof(struct sockaddr_in6)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\taddr_type = ipv6_addr_type(&sin6->sin6_addr);\n\t\tif (!(addr_type & IPV6_ADDR_UNICAST)) {\n\t\t\t__be32 addr4;\n\n\t\t\tif (!(addr_type & IPV6_ADDR_MAPPED)) {\n\t\t\t\tret = -EPROTOTYPE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\taddr4 = sin6->sin6_addr.s6_addr32[3];\n\t\t\tif (addr4 == htonl(INADDR_ANY) ||\n\t\t\t    addr4 == htonl(INADDR_BROADCAST) ||\n\t\t\t    ipv4_is_multicast(addr4)) {\n\t\t\t\tret = -EPROTOTYPE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\t \n\t\t\tif (sin6->sin6_scope_id == 0 ||\n\t\t\t    (!ipv6_addr_any(&rs->rs_bound_addr) &&\n\t\t\t     rs->rs_bound_scope_id &&\n\t\t\t     sin6->sin6_scope_id != rs->rs_bound_scope_id)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\trs->rs_bound_scope_id = sin6->sin6_scope_id;\n\t\t}\n\t\trs->rs_conn_addr = sin6->sin6_addr;\n\t\trs->rs_conn_port = sin6->sin6_port;\n\t\tbreak;\n\t}\n#endif\n\n\tdefault:\n\t\tret = -EAFNOSUPPORT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic struct proto rds_proto = {\n\t.name\t  = \"RDS\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct rds_sock),\n};\n\nstatic const struct proto_ops rds_proto_ops = {\n\t.family =\tAF_RDS,\n\t.owner =\tTHIS_MODULE,\n\t.release =\trds_release,\n\t.bind =\t\trds_bind,\n\t.connect =\trds_connect,\n\t.socketpair =\tsock_no_socketpair,\n\t.accept =\tsock_no_accept,\n\t.getname =\trds_getname,\n\t.poll =\t\trds_poll,\n\t.ioctl =\trds_ioctl,\n\t.listen =\tsock_no_listen,\n\t.shutdown =\tsock_no_shutdown,\n\t.setsockopt =\trds_setsockopt,\n\t.getsockopt =\trds_getsockopt,\n\t.sendmsg =\trds_sendmsg,\n\t.recvmsg =\trds_recvmsg,\n\t.mmap =\t\tsock_no_mmap,\n};\n\nstatic void rds_sock_destruct(struct sock *sk)\n{\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\n\tWARN_ON((&rs->rs_item != rs->rs_item.next ||\n\t\t &rs->rs_item != rs->rs_item.prev));\n}\n\nstatic int __rds_create(struct socket *sock, struct sock *sk, int protocol)\n{\n\tstruct rds_sock *rs;\n\n\tsock_init_data(sock, sk);\n\tsock->ops\t\t= &rds_proto_ops;\n\tsk->sk_protocol\t\t= protocol;\n\tsk->sk_destruct\t\t= rds_sock_destruct;\n\n\trs = rds_sk_to_rs(sk);\n\tspin_lock_init(&rs->rs_lock);\n\trwlock_init(&rs->rs_recv_lock);\n\tINIT_LIST_HEAD(&rs->rs_send_queue);\n\tINIT_LIST_HEAD(&rs->rs_recv_queue);\n\tINIT_LIST_HEAD(&rs->rs_notify_queue);\n\tINIT_LIST_HEAD(&rs->rs_cong_list);\n\trds_message_zcopy_queue_init(&rs->rs_zcookie_queue);\n\tspin_lock_init(&rs->rs_rdma_lock);\n\trs->rs_rdma_keys = RB_ROOT;\n\trs->rs_rx_traces = 0;\n\trs->rs_tos = 0;\n\trs->rs_conn = NULL;\n\n\tspin_lock_bh(&rds_sock_lock);\n\tlist_add_tail(&rs->rs_item, &rds_sock_list);\n\trds_sock_count++;\n\tspin_unlock_bh(&rds_sock_lock);\n\n\treturn 0;\n}\n\nstatic int rds_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_SEQPACKET || protocol)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, AF_RDS, GFP_KERNEL, &rds_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\treturn __rds_create(sock, sk, protocol);\n}\n\nvoid rds_sock_addref(struct rds_sock *rs)\n{\n\tsock_hold(rds_rs_to_sk(rs));\n}\n\nvoid rds_sock_put(struct rds_sock *rs)\n{\n\tsock_put(rds_rs_to_sk(rs));\n}\n\nstatic const struct net_proto_family rds_family_ops = {\n\t.family =\tAF_RDS,\n\t.create =\trds_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\nstatic void rds_sock_inc_info(struct socket *sock, unsigned int len,\n\t\t\t      struct rds_info_iterator *iter,\n\t\t\t      struct rds_info_lengths *lens)\n{\n\tstruct rds_sock *rs;\n\tstruct rds_incoming *inc;\n\tunsigned int total = 0;\n\n\tlen /= sizeof(struct rds_info_message);\n\n\tspin_lock_bh(&rds_sock_lock);\n\n\tlist_for_each_entry(rs, &rds_sock_list, rs_item) {\n\t\t \n\t\tif (!ipv6_addr_v4mapped(&rs->rs_bound_addr))\n\t\t\tcontinue;\n\n\t\tread_lock(&rs->rs_recv_lock);\n\n\t\t \n\t\tlist_for_each_entry(inc, &rs->rs_recv_queue, i_item) {\n\t\t\ttotal++;\n\t\t\tif (total <= len)\n\t\t\t\trds_inc_info_copy(inc, iter,\n\t\t\t\t\t\t  inc->i_saddr.s6_addr32[3],\n\t\t\t\t\t\t  rs->rs_bound_addr_v4,\n\t\t\t\t\t\t  1);\n\t\t}\n\n\t\tread_unlock(&rs->rs_recv_lock);\n\t}\n\n\tspin_unlock_bh(&rds_sock_lock);\n\n\tlens->nr = total;\n\tlens->each = sizeof(struct rds_info_message);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void rds6_sock_inc_info(struct socket *sock, unsigned int len,\n\t\t\t       struct rds_info_iterator *iter,\n\t\t\t       struct rds_info_lengths *lens)\n{\n\tstruct rds_incoming *inc;\n\tunsigned int total = 0;\n\tstruct rds_sock *rs;\n\n\tlen /= sizeof(struct rds6_info_message);\n\n\tspin_lock_bh(&rds_sock_lock);\n\n\tlist_for_each_entry(rs, &rds_sock_list, rs_item) {\n\t\tread_lock(&rs->rs_recv_lock);\n\n\t\tlist_for_each_entry(inc, &rs->rs_recv_queue, i_item) {\n\t\t\ttotal++;\n\t\t\tif (total <= len)\n\t\t\t\trds6_inc_info_copy(inc, iter, &inc->i_saddr,\n\t\t\t\t\t\t   &rs->rs_bound_addr, 1);\n\t\t}\n\n\t\tread_unlock(&rs->rs_recv_lock);\n\t}\n\n\tspin_unlock_bh(&rds_sock_lock);\n\n\tlens->nr = total;\n\tlens->each = sizeof(struct rds6_info_message);\n}\n#endif\n\nstatic void rds_sock_info(struct socket *sock, unsigned int len,\n\t\t\t  struct rds_info_iterator *iter,\n\t\t\t  struct rds_info_lengths *lens)\n{\n\tstruct rds_info_socket sinfo;\n\tunsigned int cnt = 0;\n\tstruct rds_sock *rs;\n\n\tlen /= sizeof(struct rds_info_socket);\n\n\tspin_lock_bh(&rds_sock_lock);\n\n\tif (len < rds_sock_count) {\n\t\tcnt = rds_sock_count;\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(rs, &rds_sock_list, rs_item) {\n\t\t \n\t\tif (!ipv6_addr_v4mapped(&rs->rs_bound_addr))\n\t\t\tcontinue;\n\t\tsinfo.sndbuf = rds_sk_sndbuf(rs);\n\t\tsinfo.rcvbuf = rds_sk_rcvbuf(rs);\n\t\tsinfo.bound_addr = rs->rs_bound_addr_v4;\n\t\tsinfo.connected_addr = rs->rs_conn_addr_v4;\n\t\tsinfo.bound_port = rs->rs_bound_port;\n\t\tsinfo.connected_port = rs->rs_conn_port;\n\t\tsinfo.inum = sock_i_ino(rds_rs_to_sk(rs));\n\n\t\trds_info_copy(iter, &sinfo, sizeof(sinfo));\n\t\tcnt++;\n\t}\n\nout:\n\tlens->nr = cnt;\n\tlens->each = sizeof(struct rds_info_socket);\n\n\tspin_unlock_bh(&rds_sock_lock);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void rds6_sock_info(struct socket *sock, unsigned int len,\n\t\t\t   struct rds_info_iterator *iter,\n\t\t\t   struct rds_info_lengths *lens)\n{\n\tstruct rds6_info_socket sinfo6;\n\tstruct rds_sock *rs;\n\n\tlen /= sizeof(struct rds6_info_socket);\n\n\tspin_lock_bh(&rds_sock_lock);\n\n\tif (len < rds_sock_count)\n\t\tgoto out;\n\n\tlist_for_each_entry(rs, &rds_sock_list, rs_item) {\n\t\tsinfo6.sndbuf = rds_sk_sndbuf(rs);\n\t\tsinfo6.rcvbuf = rds_sk_rcvbuf(rs);\n\t\tsinfo6.bound_addr = rs->rs_bound_addr;\n\t\tsinfo6.connected_addr = rs->rs_conn_addr;\n\t\tsinfo6.bound_port = rs->rs_bound_port;\n\t\tsinfo6.connected_port = rs->rs_conn_port;\n\t\tsinfo6.inum = sock_i_ino(rds_rs_to_sk(rs));\n\n\t\trds_info_copy(iter, &sinfo6, sizeof(sinfo6));\n\t}\n\n out:\n\tlens->nr = rds_sock_count;\n\tlens->each = sizeof(struct rds6_info_socket);\n\n\tspin_unlock_bh(&rds_sock_lock);\n}\n#endif\n\nstatic void rds_exit(void)\n{\n\tsock_unregister(rds_family_ops.family);\n\tproto_unregister(&rds_proto);\n\trds_conn_exit();\n\trds_cong_exit();\n\trds_sysctl_exit();\n\trds_threads_exit();\n\trds_stats_exit();\n\trds_page_exit();\n\trds_bind_lock_destroy();\n\trds_info_deregister_func(RDS_INFO_SOCKETS, rds_sock_info);\n\trds_info_deregister_func(RDS_INFO_RECV_MESSAGES, rds_sock_inc_info);\n#if IS_ENABLED(CONFIG_IPV6)\n\trds_info_deregister_func(RDS6_INFO_SOCKETS, rds6_sock_info);\n\trds_info_deregister_func(RDS6_INFO_RECV_MESSAGES, rds6_sock_inc_info);\n#endif\n}\nmodule_exit(rds_exit);\n\nu32 rds_gen_num;\n\nstatic int __init rds_init(void)\n{\n\tint ret;\n\n\tnet_get_random_once(&rds_gen_num, sizeof(rds_gen_num));\n\n\tret = rds_bind_lock_init();\n\tif (ret)\n\t\tgoto out;\n\n\tret = rds_conn_init();\n\tif (ret)\n\t\tgoto out_bind;\n\n\tret = rds_threads_init();\n\tif (ret)\n\t\tgoto out_conn;\n\tret = rds_sysctl_init();\n\tif (ret)\n\t\tgoto out_threads;\n\tret = rds_stats_init();\n\tif (ret)\n\t\tgoto out_sysctl;\n\tret = proto_register(&rds_proto, 1);\n\tif (ret)\n\t\tgoto out_stats;\n\tret = sock_register(&rds_family_ops);\n\tif (ret)\n\t\tgoto out_proto;\n\n\trds_info_register_func(RDS_INFO_SOCKETS, rds_sock_info);\n\trds_info_register_func(RDS_INFO_RECV_MESSAGES, rds_sock_inc_info);\n#if IS_ENABLED(CONFIG_IPV6)\n\trds_info_register_func(RDS6_INFO_SOCKETS, rds6_sock_info);\n\trds_info_register_func(RDS6_INFO_RECV_MESSAGES, rds6_sock_inc_info);\n#endif\n\n\tgoto out;\n\nout_proto:\n\tproto_unregister(&rds_proto);\nout_stats:\n\trds_stats_exit();\nout_sysctl:\n\trds_sysctl_exit();\nout_threads:\n\trds_threads_exit();\nout_conn:\n\trds_conn_exit();\n\trds_cong_exit();\n\trds_page_exit();\nout_bind:\n\trds_bind_lock_destroy();\nout:\n\treturn ret;\n}\nmodule_init(rds_init);\n\n#define DRV_VERSION     \"4.0\"\n#define DRV_RELDATE     \"Feb 12, 2009\"\n\nMODULE_AUTHOR(\"Oracle Corporation <rds-devel@oss.oracle.com>\");\nMODULE_DESCRIPTION(\"RDS: Reliable Datagram Sockets\"\n\t\t   \" v\" DRV_VERSION \" (\" DRV_RELDATE \")\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS_NETPROTO(PF_RDS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}