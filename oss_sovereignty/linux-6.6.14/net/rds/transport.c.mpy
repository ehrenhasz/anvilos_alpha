{
  "module_name": "transport.c",
  "hash_id": "904d426e31a0ce15d82e9b97190fb75fda19b1ed03e155b052e0a80e7372d675",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/transport.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/in.h>\n#include <linux/ipv6.h>\n\n#include \"rds.h\"\n#include \"loop.h\"\n\nstatic char * const rds_trans_modules[] = {\n\t[RDS_TRANS_IB] = \"rds_rdma\",\n\t[RDS_TRANS_GAP] = NULL,\n\t[RDS_TRANS_TCP] = \"rds_tcp\",\n};\n\nstatic struct rds_transport *transports[RDS_TRANS_COUNT];\nstatic DECLARE_RWSEM(rds_trans_sem);\n\nvoid rds_trans_register(struct rds_transport *trans)\n{\n\tBUG_ON(strlen(trans->t_name) + 1 > TRANSNAMSIZ);\n\n\tdown_write(&rds_trans_sem);\n\n\tif (transports[trans->t_type])\n\t\tprintk(KERN_ERR \"RDS Transport type %d already registered\\n\",\n\t\t\ttrans->t_type);\n\telse {\n\t\ttransports[trans->t_type] = trans;\n\t\tprintk(KERN_INFO \"Registered RDS/%s transport\\n\", trans->t_name);\n\t}\n\n\tup_write(&rds_trans_sem);\n}\nEXPORT_SYMBOL_GPL(rds_trans_register);\n\nvoid rds_trans_unregister(struct rds_transport *trans)\n{\n\tdown_write(&rds_trans_sem);\n\n\ttransports[trans->t_type] = NULL;\n\tprintk(KERN_INFO \"Unregistered RDS/%s transport\\n\", trans->t_name);\n\n\tup_write(&rds_trans_sem);\n}\nEXPORT_SYMBOL_GPL(rds_trans_unregister);\n\nvoid rds_trans_put(struct rds_transport *trans)\n{\n\tif (trans)\n\t\tmodule_put(trans->t_owner);\n}\n\nstruct rds_transport *rds_trans_get_preferred(struct net *net,\n\t\t\t\t\t      const struct in6_addr *addr,\n\t\t\t\t\t      __u32 scope_id)\n{\n\tstruct rds_transport *ret = NULL;\n\tstruct rds_transport *trans;\n\tunsigned int i;\n\n\tif (ipv6_addr_v4mapped(addr)) {\n\t\tif (*(u_int8_t *)&addr->s6_addr32[3] == IN_LOOPBACKNET)\n\t\t\treturn &rds_loop_transport;\n\t} else if (ipv6_addr_loopback(addr)) {\n\t\treturn &rds_loop_transport;\n\t}\n\n\tdown_read(&rds_trans_sem);\n\tfor (i = 0; i < RDS_TRANS_COUNT; i++) {\n\t\ttrans = transports[i];\n\n\t\tif (trans && (trans->laddr_check(net, addr, scope_id) == 0) &&\n\t\t    (!trans->t_owner || try_module_get(trans->t_owner))) {\n\t\t\tret = trans;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&rds_trans_sem);\n\n\treturn ret;\n}\n\nstruct rds_transport *rds_trans_get(int t_type)\n{\n\tstruct rds_transport *ret = NULL;\n\tstruct rds_transport *trans;\n\n\tdown_read(&rds_trans_sem);\n\ttrans = transports[t_type];\n\tif (!trans) {\n\t\tup_read(&rds_trans_sem);\n\t\tif (rds_trans_modules[t_type])\n\t\t\trequest_module(rds_trans_modules[t_type]);\n\t\tdown_read(&rds_trans_sem);\n\t\ttrans = transports[t_type];\n\t}\n\tif (trans && trans->t_type == t_type &&\n\t    (!trans->t_owner || try_module_get(trans->t_owner)))\n\t\tret = trans;\n\n\tup_read(&rds_trans_sem);\n\n\treturn ret;\n}\n\n \nunsigned int rds_trans_stats_info_copy(struct rds_info_iterator *iter,\n\t\t\t\t       unsigned int avail)\n\n{\n\tstruct rds_transport *trans;\n\tunsigned int total = 0;\n\tunsigned int part;\n\tint i;\n\n\trds_info_iter_unmap(iter);\n\tdown_read(&rds_trans_sem);\n\n\tfor (i = 0; i < RDS_TRANS_COUNT; i++) {\n\t\ttrans = transports[i];\n\t\tif (!trans || !trans->stats_info_copy)\n\t\t\tcontinue;\n\n\t\tpart = trans->stats_info_copy(iter, avail);\n\t\tavail -= min(avail, part);\n\t\ttotal += part;\n\t}\n\n\tup_read(&rds_trans_sem);\n\n\treturn total;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}