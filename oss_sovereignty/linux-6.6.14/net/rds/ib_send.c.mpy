{
  "module_name": "ib_send.c",
  "hash_id": "c08629bea6ce714cb45da68ba9cc94f24da17361338698d30e43e9d7b24bdc45",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/ib_send.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/in.h>\n#include <linux/device.h>\n#include <linux/dmapool.h>\n#include <linux/ratelimit.h>\n\n#include \"rds_single_path.h\"\n#include \"rds.h\"\n#include \"ib.h\"\n#include \"ib_mr.h\"\n\n \nstatic void rds_ib_send_complete(struct rds_message *rm,\n\t\t\t\t int wc_status,\n\t\t\t\t void (*complete)(struct rds_message *rm, int status))\n{\n\tint notify_status;\n\n\tswitch (wc_status) {\n\tcase IB_WC_WR_FLUSH_ERR:\n\t\treturn;\n\n\tcase IB_WC_SUCCESS:\n\t\tnotify_status = RDS_RDMA_SUCCESS;\n\t\tbreak;\n\n\tcase IB_WC_REM_ACCESS_ERR:\n\t\tnotify_status = RDS_RDMA_REMOTE_ERROR;\n\t\tbreak;\n\n\tdefault:\n\t\tnotify_status = RDS_RDMA_OTHER_ERROR;\n\t\tbreak;\n\t}\n\tcomplete(rm, notify_status);\n}\n\nstatic void rds_ib_send_unmap_data(struct rds_ib_connection *ic,\n\t\t\t\t   struct rm_data_op *op,\n\t\t\t\t   int wc_status)\n{\n\tif (op->op_nents)\n\t\tib_dma_unmap_sg(ic->i_cm_id->device,\n\t\t\t\top->op_sg, op->op_nents,\n\t\t\t\tDMA_TO_DEVICE);\n}\n\nstatic void rds_ib_send_unmap_rdma(struct rds_ib_connection *ic,\n\t\t\t\t   struct rm_rdma_op *op,\n\t\t\t\t   int wc_status)\n{\n\tif (op->op_mapped) {\n\t\tib_dma_unmap_sg(ic->i_cm_id->device,\n\t\t\t\top->op_sg, op->op_nents,\n\t\t\t\top->op_write ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\t\top->op_mapped = 0;\n\t}\n\n\t \n\trds_ib_send_complete(container_of(op, struct rds_message, rdma),\n\t\t\t     wc_status, rds_rdma_send_complete);\n\n\tif (op->op_write)\n\t\trds_stats_add(s_send_rdma_bytes, op->op_bytes);\n\telse\n\t\trds_stats_add(s_recv_rdma_bytes, op->op_bytes);\n}\n\nstatic void rds_ib_send_unmap_atomic(struct rds_ib_connection *ic,\n\t\t\t\t     struct rm_atomic_op *op,\n\t\t\t\t     int wc_status)\n{\n\t \n\tif (op->op_mapped) {\n\t\tib_dma_unmap_sg(ic->i_cm_id->device, op->op_sg, 1,\n\t\t\t\tDMA_FROM_DEVICE);\n\t\top->op_mapped = 0;\n\t}\n\n\trds_ib_send_complete(container_of(op, struct rds_message, atomic),\n\t\t\t     wc_status, rds_atomic_send_complete);\n\n\tif (op->op_type == RDS_ATOMIC_TYPE_CSWP)\n\t\trds_ib_stats_inc(s_ib_atomic_cswp);\n\telse\n\t\trds_ib_stats_inc(s_ib_atomic_fadd);\n}\n\n \nstatic struct rds_message *rds_ib_send_unmap_op(struct rds_ib_connection *ic,\n\t\t\t\t\t\tstruct rds_ib_send_work *send,\n\t\t\t\t\t\tint wc_status)\n{\n\tstruct rds_message *rm = NULL;\n\n\t \n\tswitch (send->s_wr.opcode) {\n\tcase IB_WR_SEND:\n\t\tif (send->s_op) {\n\t\t\trm = container_of(send->s_op, struct rds_message, data);\n\t\t\trds_ib_send_unmap_data(ic, send->s_op, wc_status);\n\t\t}\n\t\tbreak;\n\tcase IB_WR_RDMA_WRITE:\n\tcase IB_WR_RDMA_READ:\n\t\tif (send->s_op) {\n\t\t\trm = container_of(send->s_op, struct rds_message, rdma);\n\t\t\trds_ib_send_unmap_rdma(ic, send->s_op, wc_status);\n\t\t}\n\t\tbreak;\n\tcase IB_WR_ATOMIC_FETCH_AND_ADD:\n\tcase IB_WR_ATOMIC_CMP_AND_SWP:\n\t\tif (send->s_op) {\n\t\t\trm = container_of(send->s_op, struct rds_message, atomic);\n\t\t\trds_ib_send_unmap_atomic(ic, send->s_op, wc_status);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk_ratelimited(KERN_NOTICE\n\t\t\t       \"RDS/IB: %s: unexpected opcode 0x%x in WR!\\n\",\n\t\t\t       __func__, send->s_wr.opcode);\n\t\tbreak;\n\t}\n\n\tsend->s_wr.opcode = 0xdead;\n\n\treturn rm;\n}\n\nvoid rds_ib_send_init_ring(struct rds_ib_connection *ic)\n{\n\tstruct rds_ib_send_work *send;\n\tu32 i;\n\n\tfor (i = 0, send = ic->i_sends; i < ic->i_send_ring.w_nr; i++, send++) {\n\t\tstruct ib_sge *sge;\n\n\t\tsend->s_op = NULL;\n\n\t\tsend->s_wr.wr_id = i;\n\t\tsend->s_wr.sg_list = send->s_sge;\n\t\tsend->s_wr.ex.imm_data = 0;\n\n\t\tsge = &send->s_sge[0];\n\t\tsge->addr = ic->i_send_hdrs_dma[i];\n\n\t\tsge->length = sizeof(struct rds_header);\n\t\tsge->lkey = ic->i_pd->local_dma_lkey;\n\n\t\tsend->s_sge[1].lkey = ic->i_pd->local_dma_lkey;\n\t}\n}\n\nvoid rds_ib_send_clear_ring(struct rds_ib_connection *ic)\n{\n\tstruct rds_ib_send_work *send;\n\tu32 i;\n\n\tfor (i = 0, send = ic->i_sends; i < ic->i_send_ring.w_nr; i++, send++) {\n\t\tif (send->s_op && send->s_wr.opcode != 0xdead)\n\t\t\trds_ib_send_unmap_op(ic, send, IB_WC_WR_FLUSH_ERR);\n\t}\n}\n\n \nstatic void rds_ib_sub_signaled(struct rds_ib_connection *ic, int nr)\n{\n\tif ((atomic_sub_return(nr, &ic->i_signaled_sends) == 0) &&\n\t    waitqueue_active(&rds_ib_ring_empty_wait))\n\t\twake_up(&rds_ib_ring_empty_wait);\n\tBUG_ON(atomic_read(&ic->i_signaled_sends) < 0);\n}\n\n \nvoid rds_ib_send_cqe_handler(struct rds_ib_connection *ic, struct ib_wc *wc)\n{\n\tstruct rds_message *rm = NULL;\n\tstruct rds_connection *conn = ic->conn;\n\tstruct rds_ib_send_work *send;\n\tu32 completed;\n\tu32 oldest;\n\tu32 i = 0;\n\tint nr_sig = 0;\n\n\n\trdsdebug(\"wc wr_id 0x%llx status %u (%s) byte_len %u imm_data %u\\n\",\n\t\t (unsigned long long)wc->wr_id, wc->status,\n\t\t ib_wc_status_msg(wc->status), wc->byte_len,\n\t\t be32_to_cpu(wc->ex.imm_data));\n\trds_ib_stats_inc(s_ib_tx_cq_event);\n\n\tif (wc->wr_id == RDS_IB_ACK_WR_ID) {\n\t\tif (time_after(jiffies, ic->i_ack_queued + HZ / 2))\n\t\t\trds_ib_stats_inc(s_ib_tx_stalled);\n\t\trds_ib_ack_send_complete(ic);\n\t\treturn;\n\t}\n\n\toldest = rds_ib_ring_oldest(&ic->i_send_ring);\n\n\tcompleted = rds_ib_ring_completed(&ic->i_send_ring, wc->wr_id, oldest);\n\n\tfor (i = 0; i < completed; i++) {\n\t\tsend = &ic->i_sends[oldest];\n\t\tif (send->s_wr.send_flags & IB_SEND_SIGNALED)\n\t\t\tnr_sig++;\n\n\t\trm = rds_ib_send_unmap_op(ic, send, wc->status);\n\n\t\tif (time_after(jiffies, send->s_queued + HZ / 2))\n\t\t\trds_ib_stats_inc(s_ib_tx_stalled);\n\n\t\tif (send->s_op) {\n\t\t\tif (send->s_op == rm->m_final_op) {\n\t\t\t\t \n\t\t\t\trds_message_unmapped(rm);\n\t\t\t}\n\t\t\trds_message_put(rm);\n\t\t\tsend->s_op = NULL;\n\t\t}\n\n\t\toldest = (oldest + 1) % ic->i_send_ring.w_nr;\n\t}\n\n\trds_ib_ring_free(&ic->i_send_ring, completed);\n\trds_ib_sub_signaled(ic, nr_sig);\n\n\tif (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags) ||\n\t    test_bit(0, &conn->c_map_queued))\n\t\tqueue_delayed_work(rds_wq, &conn->c_send_w, 0);\n\n\t \n\tif (wc->status != IB_WC_SUCCESS && rds_conn_up(conn)) {\n\t\trds_ib_conn_error(conn, \"send completion on <%pI6c,%pI6c,%d> had status %u (%s), vendor err 0x%x, disconnecting and reconnecting\\n\",\n\t\t\t\t  &conn->c_laddr, &conn->c_faddr,\n\t\t\t\t  conn->c_tos, wc->status,\n\t\t\t\t  ib_wc_status_msg(wc->status), wc->vendor_err);\n\t}\n}\n\n \nint rds_ib_send_grab_credits(struct rds_ib_connection *ic,\n\t\t\t     u32 wanted, u32 *adv_credits, int need_posted, int max_posted)\n{\n\tunsigned int avail, posted, got = 0, advertise;\n\tlong oldval, newval;\n\n\t*adv_credits = 0;\n\tif (!ic->i_flowctl)\n\t\treturn wanted;\n\ntry_again:\n\tadvertise = 0;\n\toldval = newval = atomic_read(&ic->i_credits);\n\tposted = IB_GET_POST_CREDITS(oldval);\n\tavail = IB_GET_SEND_CREDITS(oldval);\n\n\trdsdebug(\"wanted=%u credits=%u posted=%u\\n\",\n\t\t\twanted, avail, posted);\n\n\t \n\tif (avail && !posted)\n\t\tavail--;\n\n\tif (avail < wanted) {\n\t\tstruct rds_connection *conn = ic->i_cm_id->context;\n\n\t\t \n\t\tset_bit(RDS_LL_SEND_FULL, &conn->c_flags);\n\t\tgot = avail;\n\t} else {\n\t\t \n\t\tgot = wanted;\n\t}\n\tnewval -= IB_SET_SEND_CREDITS(got);\n\n\t \n\tif (posted && (got || need_posted)) {\n\t\tadvertise = min_t(unsigned int, posted, max_posted);\n\t\tnewval -= IB_SET_POST_CREDITS(advertise);\n\t}\n\n\t \n\tif (atomic_cmpxchg(&ic->i_credits, oldval, newval) != oldval)\n\t\tgoto try_again;\n\n\t*adv_credits = advertise;\n\treturn got;\n}\n\nvoid rds_ib_send_add_credits(struct rds_connection *conn, unsigned int credits)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\tif (credits == 0)\n\t\treturn;\n\n\trdsdebug(\"credits=%u current=%u%s\\n\",\n\t\t\tcredits,\n\t\t\tIB_GET_SEND_CREDITS(atomic_read(&ic->i_credits)),\n\t\t\ttest_bit(RDS_LL_SEND_FULL, &conn->c_flags) ? \", ll_send_full\" : \"\");\n\n\tatomic_add(IB_SET_SEND_CREDITS(credits), &ic->i_credits);\n\tif (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags))\n\t\tqueue_delayed_work(rds_wq, &conn->c_send_w, 0);\n\n\tWARN_ON(IB_GET_SEND_CREDITS(credits) >= 16384);\n\n\trds_ib_stats_inc(s_ib_rx_credit_updates);\n}\n\nvoid rds_ib_advertise_credits(struct rds_connection *conn, unsigned int posted)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\tif (posted == 0)\n\t\treturn;\n\n\tatomic_add(IB_SET_POST_CREDITS(posted), &ic->i_credits);\n\n\t \n\tif (IB_GET_POST_CREDITS(atomic_read(&ic->i_credits)) >= 16)\n\t\tset_bit(IB_ACK_REQUESTED, &ic->i_ack_flags);\n}\n\nstatic inline int rds_ib_set_wr_signal_state(struct rds_ib_connection *ic,\n\t\t\t\t\t     struct rds_ib_send_work *send,\n\t\t\t\t\t     bool notify)\n{\n\t \n\tif (ic->i_unsignaled_wrs-- == 0 || notify) {\n\t\tic->i_unsignaled_wrs = rds_ib_sysctl_max_unsig_wrs;\n\t\tsend->s_wr.send_flags |= IB_SEND_SIGNALED;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nint rds_ib_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\tunsigned int hdr_off, unsigned int sg, unsigned int off)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tstruct ib_device *dev = ic->i_cm_id->device;\n\tstruct rds_ib_send_work *send = NULL;\n\tstruct rds_ib_send_work *first;\n\tstruct rds_ib_send_work *prev;\n\tconst struct ib_send_wr *failed_wr;\n\tstruct scatterlist *scat;\n\tu32 pos;\n\tu32 i;\n\tu32 work_alloc;\n\tu32 credit_alloc = 0;\n\tu32 posted;\n\tu32 adv_credits = 0;\n\tint send_flags = 0;\n\tint bytes_sent = 0;\n\tint ret;\n\tint flow_controlled = 0;\n\tint nr_sig = 0;\n\n\tBUG_ON(off % RDS_FRAG_SIZE);\n\tBUG_ON(hdr_off != 0 && hdr_off != sizeof(struct rds_header));\n\n\t \n\tif (conn->c_loopback\n\t    && rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\tscat = &rm->data.op_sg[sg];\n\t\tret = max_t(int, RDS_CONG_MAP_BYTES, scat->length);\n\t\treturn sizeof(struct rds_header) + ret;\n\t}\n\n\t \n\tif (be32_to_cpu(rm->m_inc.i_hdr.h_len) == 0)\n\t\ti = 1;\n\telse\n\t\ti = DIV_ROUND_UP(be32_to_cpu(rm->m_inc.i_hdr.h_len), RDS_FRAG_SIZE);\n\n\twork_alloc = rds_ib_ring_alloc(&ic->i_send_ring, i, &pos);\n\tif (work_alloc == 0) {\n\t\tset_bit(RDS_LL_SEND_FULL, &conn->c_flags);\n\t\trds_ib_stats_inc(s_ib_tx_ring_full);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (ic->i_flowctl) {\n\t\tcredit_alloc = rds_ib_send_grab_credits(ic, work_alloc, &posted, 0, RDS_MAX_ADV_CREDIT);\n\t\tadv_credits += posted;\n\t\tif (credit_alloc < work_alloc) {\n\t\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc - credit_alloc);\n\t\t\twork_alloc = credit_alloc;\n\t\t\tflow_controlled = 1;\n\t\t}\n\t\tif (work_alloc == 0) {\n\t\t\tset_bit(RDS_LL_SEND_FULL, &conn->c_flags);\n\t\t\trds_ib_stats_inc(s_ib_tx_throttle);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (!ic->i_data_op) {\n\t\tif (rm->data.op_nents) {\n\t\t\trm->data.op_count = ib_dma_map_sg(dev,\n\t\t\t\t\t\t\t  rm->data.op_sg,\n\t\t\t\t\t\t\t  rm->data.op_nents,\n\t\t\t\t\t\t\t  DMA_TO_DEVICE);\n\t\t\trdsdebug(\"ic %p mapping rm %p: %d\\n\", ic, rm, rm->data.op_count);\n\t\t\tif (rm->data.op_count == 0) {\n\t\t\t\trds_ib_stats_inc(s_ib_tx_sg_mapping_failure);\n\t\t\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\t\t\tret = -ENOMEM;  \n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\trm->data.op_count = 0;\n\t\t}\n\n\t\trds_message_addref(rm);\n\t\trm->data.op_dmasg = 0;\n\t\trm->data.op_dmaoff = 0;\n\t\tic->i_data_op = &rm->data;\n\n\t\t \n\t\tif (test_bit(RDS_MSG_ACK_REQUIRED, &rm->m_flags))\n\t\t\trm->m_inc.i_hdr.h_flags |= RDS_FLAG_ACK_REQUIRED;\n\t\tif (test_bit(RDS_MSG_RETRANSMITTED, &rm->m_flags))\n\t\t\trm->m_inc.i_hdr.h_flags |= RDS_FLAG_RETRANSMITTED;\n\n\t\t \n\t\tif (rm->rdma.op_active) {\n\t\t\tstruct rds_ext_header_rdma ext_hdr;\n\n\t\t\text_hdr.h_rdma_rkey = cpu_to_be32(rm->rdma.op_rkey);\n\t\t\trds_message_add_extension(&rm->m_inc.i_hdr,\n\t\t\t\t\tRDS_EXTHDR_RDMA, &ext_hdr, sizeof(ext_hdr));\n\t\t}\n\t\tif (rm->m_rdma_cookie) {\n\t\t\trds_message_add_rdma_dest_extension(&rm->m_inc.i_hdr,\n\t\t\t\t\trds_rdma_cookie_key(rm->m_rdma_cookie),\n\t\t\t\t\trds_rdma_cookie_offset(rm->m_rdma_cookie));\n\t\t}\n\n\t\t \n\t\trm->m_inc.i_hdr.h_ack = cpu_to_be64(rds_ib_piggyb_ack(ic));\n\t\trds_message_make_checksum(&rm->m_inc.i_hdr);\n\n\t\t \n\t\tif (ic->i_flowctl) {\n\t\t\trds_ib_send_grab_credits(ic, 0, &posted, 1, RDS_MAX_ADV_CREDIT - adv_credits);\n\t\t\tadv_credits += posted;\n\t\t\tBUG_ON(adv_credits > 255);\n\t\t}\n\t}\n\n\t \n\tif (rm->rdma.op_active && rm->rdma.op_fence)\n\t\tsend_flags = IB_SEND_FENCE;\n\n\t \n\tsend = &ic->i_sends[pos];\n\tfirst = send;\n\tprev = NULL;\n\tscat = &ic->i_data_op->op_sg[rm->data.op_dmasg];\n\ti = 0;\n\tdo {\n\t\tunsigned int len = 0;\n\n\t\t \n\t\tsend->s_wr.send_flags = send_flags;\n\t\tsend->s_wr.opcode = IB_WR_SEND;\n\t\tsend->s_wr.num_sge = 1;\n\t\tsend->s_wr.next = NULL;\n\t\tsend->s_queued = jiffies;\n\t\tsend->s_op = NULL;\n\n\t\tsend->s_sge[0].addr = ic->i_send_hdrs_dma[pos];\n\n\t\tsend->s_sge[0].length = sizeof(struct rds_header);\n\t\tsend->s_sge[0].lkey = ic->i_pd->local_dma_lkey;\n\n\t\tib_dma_sync_single_for_cpu(ic->rds_ibdev->dev,\n\t\t\t\t\t   ic->i_send_hdrs_dma[pos],\n\t\t\t\t\t   sizeof(struct rds_header),\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tmemcpy(ic->i_send_hdrs[pos], &rm->m_inc.i_hdr,\n\t\t       sizeof(struct rds_header));\n\n\n\t\t \n\t\tif (i < work_alloc\n\t\t    && scat != &rm->data.op_sg[rm->data.op_count]) {\n\t\t\tlen = min(RDS_FRAG_SIZE,\n\t\t\t\t  sg_dma_len(scat) - rm->data.op_dmaoff);\n\t\t\tsend->s_wr.num_sge = 2;\n\n\t\t\tsend->s_sge[1].addr = sg_dma_address(scat);\n\t\t\tsend->s_sge[1].addr += rm->data.op_dmaoff;\n\t\t\tsend->s_sge[1].length = len;\n\t\t\tsend->s_sge[1].lkey = ic->i_pd->local_dma_lkey;\n\n\t\t\tbytes_sent += len;\n\t\t\trm->data.op_dmaoff += len;\n\t\t\tif (rm->data.op_dmaoff == sg_dma_len(scat)) {\n\t\t\t\tscat++;\n\t\t\t\trm->data.op_dmasg++;\n\t\t\t\trm->data.op_dmaoff = 0;\n\t\t\t}\n\t\t}\n\n\t\trds_ib_set_wr_signal_state(ic, send, false);\n\n\t\t \n\t\tif (ic->i_flowctl && flow_controlled && i == (work_alloc - 1)) {\n\t\t\trds_ib_set_wr_signal_state(ic, send, true);\n\t\t\tsend->s_wr.send_flags |= IB_SEND_SOLICITED;\n\t\t}\n\n\t\tif (send->s_wr.send_flags & IB_SEND_SIGNALED)\n\t\t\tnr_sig++;\n\n\t\trdsdebug(\"send %p wr %p num_sge %u next %p\\n\", send,\n\t\t\t &send->s_wr, send->s_wr.num_sge, send->s_wr.next);\n\n\t\tif (ic->i_flowctl && adv_credits) {\n\t\t\tstruct rds_header *hdr = ic->i_send_hdrs[pos];\n\n\t\t\t \n\t\t\thdr->h_credit = adv_credits;\n\t\t\trds_message_make_checksum(hdr);\n\t\t\tadv_credits = 0;\n\t\t\trds_ib_stats_inc(s_ib_tx_credit_updates);\n\t\t}\n\t\tib_dma_sync_single_for_device(ic->rds_ibdev->dev,\n\t\t\t\t\t      ic->i_send_hdrs_dma[pos],\n\t\t\t\t\t      sizeof(struct rds_header),\n\t\t\t\t\t      DMA_TO_DEVICE);\n\n\t\tif (prev)\n\t\t\tprev->s_wr.next = &send->s_wr;\n\t\tprev = send;\n\n\t\tpos = (pos + 1) % ic->i_send_ring.w_nr;\n\t\tsend = &ic->i_sends[pos];\n\t\ti++;\n\n\t} while (i < work_alloc\n\t\t && scat != &rm->data.op_sg[rm->data.op_count]);\n\n\t \n\tif (hdr_off == 0)\n\t\tbytes_sent += sizeof(struct rds_header);\n\n\t \n\tif (scat == &rm->data.op_sg[rm->data.op_count]) {\n\t\tprev->s_op = ic->i_data_op;\n\t\tprev->s_wr.send_flags |= IB_SEND_SOLICITED;\n\t\tif (!(prev->s_wr.send_flags & IB_SEND_SIGNALED))\n\t\t\tnr_sig += rds_ib_set_wr_signal_state(ic, prev, true);\n\t\tic->i_data_op = NULL;\n\t}\n\n\t \n\tif (i < work_alloc) {\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc - i);\n\t\twork_alloc = i;\n\t}\n\tif (ic->i_flowctl && i < credit_alloc)\n\t\trds_ib_send_add_credits(conn, credit_alloc - i);\n\n\tif (nr_sig)\n\t\tatomic_add(nr_sig, &ic->i_signaled_sends);\n\n\t \n\tfailed_wr = &first->s_wr;\n\tret = ib_post_send(ic->i_cm_id->qp, &first->s_wr, &failed_wr);\n\trdsdebug(\"ic %p first %p (wr %p) ret %d wr %p\\n\", ic,\n\t\t first, &first->s_wr, ret, failed_wr);\n\tBUG_ON(failed_wr != &first->s_wr);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"RDS/IB: ib_post_send to %pI6c \"\n\t\t       \"returned %d\\n\", &conn->c_faddr, ret);\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\trds_ib_sub_signaled(ic, nr_sig);\n\t\tif (prev->s_op) {\n\t\t\tic->i_data_op = prev->s_op;\n\t\t\tprev->s_op = NULL;\n\t\t}\n\n\t\trds_ib_conn_error(ic->conn, \"ib_post_send failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = bytes_sent;\nout:\n\tBUG_ON(adv_credits);\n\treturn ret;\n}\n\n \nint rds_ib_xmit_atomic(struct rds_connection *conn, struct rm_atomic_op *op)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tstruct rds_ib_send_work *send = NULL;\n\tconst struct ib_send_wr *failed_wr;\n\tu32 pos;\n\tu32 work_alloc;\n\tint ret;\n\tint nr_sig = 0;\n\n\twork_alloc = rds_ib_ring_alloc(&ic->i_send_ring, 1, &pos);\n\tif (work_alloc != 1) {\n\t\trds_ib_stats_inc(s_ib_tx_ring_full);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tsend = &ic->i_sends[pos];\n\tsend->s_queued = jiffies;\n\n\tif (op->op_type == RDS_ATOMIC_TYPE_CSWP) {\n\t\tsend->s_atomic_wr.wr.opcode = IB_WR_MASKED_ATOMIC_CMP_AND_SWP;\n\t\tsend->s_atomic_wr.compare_add = op->op_m_cswp.compare;\n\t\tsend->s_atomic_wr.swap = op->op_m_cswp.swap;\n\t\tsend->s_atomic_wr.compare_add_mask = op->op_m_cswp.compare_mask;\n\t\tsend->s_atomic_wr.swap_mask = op->op_m_cswp.swap_mask;\n\t} else {  \n\t\tsend->s_atomic_wr.wr.opcode = IB_WR_MASKED_ATOMIC_FETCH_AND_ADD;\n\t\tsend->s_atomic_wr.compare_add = op->op_m_fadd.add;\n\t\tsend->s_atomic_wr.swap = 0;\n\t\tsend->s_atomic_wr.compare_add_mask = op->op_m_fadd.nocarry_mask;\n\t\tsend->s_atomic_wr.swap_mask = 0;\n\t}\n\tsend->s_wr.send_flags = 0;\n\tnr_sig = rds_ib_set_wr_signal_state(ic, send, op->op_notify);\n\tsend->s_atomic_wr.wr.num_sge = 1;\n\tsend->s_atomic_wr.wr.next = NULL;\n\tsend->s_atomic_wr.remote_addr = op->op_remote_addr;\n\tsend->s_atomic_wr.rkey = op->op_rkey;\n\tsend->s_op = op;\n\trds_message_addref(container_of(send->s_op, struct rds_message, atomic));\n\n\t \n\tret = ib_dma_map_sg(ic->i_cm_id->device, op->op_sg, 1, DMA_FROM_DEVICE);\n\trdsdebug(\"ic %p mapping atomic op %p. mapped %d pg\\n\", ic, op, ret);\n\tif (ret != 1) {\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\trds_ib_stats_inc(s_ib_tx_sg_mapping_failure);\n\t\tret = -ENOMEM;  \n\t\tgoto out;\n\t}\n\n\t \n\tsend->s_sge[0].addr = sg_dma_address(op->op_sg);\n\tsend->s_sge[0].length = sg_dma_len(op->op_sg);\n\tsend->s_sge[0].lkey = ic->i_pd->local_dma_lkey;\n\n\trdsdebug(\"rva %Lx rpa %Lx len %u\\n\", op->op_remote_addr,\n\t\t send->s_sge[0].addr, send->s_sge[0].length);\n\n\tif (nr_sig)\n\t\tatomic_add(nr_sig, &ic->i_signaled_sends);\n\n\tfailed_wr = &send->s_atomic_wr.wr;\n\tret = ib_post_send(ic->i_cm_id->qp, &send->s_atomic_wr.wr, &failed_wr);\n\trdsdebug(\"ic %p send %p (wr %p) ret %d wr %p\\n\", ic,\n\t\t send, &send->s_atomic_wr, ret, failed_wr);\n\tBUG_ON(failed_wr != &send->s_atomic_wr.wr);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"RDS/IB: atomic ib_post_send to %pI6c \"\n\t\t       \"returned %d\\n\", &conn->c_faddr, ret);\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\trds_ib_sub_signaled(ic, nr_sig);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(failed_wr != &send->s_atomic_wr.wr)) {\n\t\tprintk(KERN_WARNING \"RDS/IB: atomic ib_post_send() rc=%d, but failed_wqe updated!\\n\", ret);\n\t\tBUG_ON(failed_wr != &send->s_atomic_wr.wr);\n\t}\n\nout:\n\treturn ret;\n}\n\nint rds_ib_xmit_rdma(struct rds_connection *conn, struct rm_rdma_op *op)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tstruct rds_ib_send_work *send = NULL;\n\tstruct rds_ib_send_work *first;\n\tstruct rds_ib_send_work *prev;\n\tconst struct ib_send_wr *failed_wr;\n\tstruct scatterlist *scat;\n\tunsigned long len;\n\tu64 remote_addr = op->op_remote_addr;\n\tu32 max_sge = ic->rds_ibdev->max_sge;\n\tu32 pos;\n\tu32 work_alloc;\n\tu32 i;\n\tu32 j;\n\tint sent;\n\tint ret;\n\tint num_sge;\n\tint nr_sig = 0;\n\tu64 odp_addr = op->op_odp_addr;\n\tu32 odp_lkey = 0;\n\n\t \n\tif (!op->op_odp_mr) {\n\t\tif (!op->op_mapped) {\n\t\t\top->op_count =\n\t\t\t\tib_dma_map_sg(ic->i_cm_id->device, op->op_sg,\n\t\t\t\t\t      op->op_nents,\n\t\t\t\t\t      (op->op_write) ? DMA_TO_DEVICE :\n\t\t\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\trdsdebug(\"ic %p mapping op %p: %d\\n\", ic, op,\n\t\t\t\t op->op_count);\n\t\t\tif (op->op_count == 0) {\n\t\t\t\trds_ib_stats_inc(s_ib_tx_sg_mapping_failure);\n\t\t\t\tret = -ENOMEM;  \n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->op_mapped = 1;\n\t\t}\n\t} else {\n\t\top->op_count = op->op_nents;\n\t\todp_lkey = rds_ib_get_lkey(op->op_odp_mr->r_trans_private);\n\t}\n\n\t \n\ti = DIV_ROUND_UP(op->op_count, max_sge);\n\n\twork_alloc = rds_ib_ring_alloc(&ic->i_send_ring, i, &pos);\n\tif (work_alloc != i) {\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\trds_ib_stats_inc(s_ib_tx_ring_full);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsend = &ic->i_sends[pos];\n\tfirst = send;\n\tprev = NULL;\n\tscat = &op->op_sg[0];\n\tsent = 0;\n\tnum_sge = op->op_count;\n\n\tfor (i = 0; i < work_alloc && scat != &op->op_sg[op->op_count]; i++) {\n\t\tsend->s_wr.send_flags = 0;\n\t\tsend->s_queued = jiffies;\n\t\tsend->s_op = NULL;\n\n\t\tif (!op->op_notify)\n\t\t\tnr_sig += rds_ib_set_wr_signal_state(ic, send,\n\t\t\t\t\t\t\t     op->op_notify);\n\n\t\tsend->s_wr.opcode = op->op_write ? IB_WR_RDMA_WRITE : IB_WR_RDMA_READ;\n\t\tsend->s_rdma_wr.remote_addr = remote_addr;\n\t\tsend->s_rdma_wr.rkey = op->op_rkey;\n\n\t\tif (num_sge > max_sge) {\n\t\t\tsend->s_rdma_wr.wr.num_sge = max_sge;\n\t\t\tnum_sge -= max_sge;\n\t\t} else {\n\t\t\tsend->s_rdma_wr.wr.num_sge = num_sge;\n\t\t}\n\n\t\tsend->s_rdma_wr.wr.next = NULL;\n\n\t\tif (prev)\n\t\t\tprev->s_rdma_wr.wr.next = &send->s_rdma_wr.wr;\n\n\t\tfor (j = 0; j < send->s_rdma_wr.wr.num_sge &&\n\t\t     scat != &op->op_sg[op->op_count]; j++) {\n\t\t\tlen = sg_dma_len(scat);\n\t\t\tif (!op->op_odp_mr) {\n\t\t\t\tsend->s_sge[j].addr = sg_dma_address(scat);\n\t\t\t\tsend->s_sge[j].lkey = ic->i_pd->local_dma_lkey;\n\t\t\t} else {\n\t\t\t\tsend->s_sge[j].addr = odp_addr;\n\t\t\t\tsend->s_sge[j].lkey = odp_lkey;\n\t\t\t}\n\t\t\tsend->s_sge[j].length = len;\n\n\t\t\tsent += len;\n\t\t\trdsdebug(\"ic %p sent %d remote_addr %llu\\n\", ic, sent, remote_addr);\n\n\t\t\tremote_addr += len;\n\t\t\todp_addr += len;\n\t\t\tscat++;\n\t\t}\n\n\t\trdsdebug(\"send %p wr %p num_sge %u next %p\\n\", send,\n\t\t\t&send->s_rdma_wr.wr,\n\t\t\tsend->s_rdma_wr.wr.num_sge,\n\t\t\tsend->s_rdma_wr.wr.next);\n\n\t\tprev = send;\n\t\tif (++send == &ic->i_sends[ic->i_send_ring.w_nr])\n\t\t\tsend = ic->i_sends;\n\t}\n\n\t \n\tif (scat == &op->op_sg[op->op_count]) {\n\t\tprev->s_op = op;\n\t\trds_message_addref(container_of(op, struct rds_message, rdma));\n\t}\n\n\tif (i < work_alloc) {\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc - i);\n\t\twork_alloc = i;\n\t}\n\n\tif (nr_sig)\n\t\tatomic_add(nr_sig, &ic->i_signaled_sends);\n\n\tfailed_wr = &first->s_rdma_wr.wr;\n\tret = ib_post_send(ic->i_cm_id->qp, &first->s_rdma_wr.wr, &failed_wr);\n\trdsdebug(\"ic %p first %p (wr %p) ret %d wr %p\\n\", ic,\n\t\t first, &first->s_rdma_wr.wr, ret, failed_wr);\n\tBUG_ON(failed_wr != &first->s_rdma_wr.wr);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"RDS/IB: rdma ib_post_send to %pI6c \"\n\t\t       \"returned %d\\n\", &conn->c_faddr, ret);\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\trds_ib_sub_signaled(ic, nr_sig);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(failed_wr != &first->s_rdma_wr.wr)) {\n\t\tprintk(KERN_WARNING \"RDS/IB: ib_post_send() rc=%d, but failed_wqe updated!\\n\", ret);\n\t\tBUG_ON(failed_wr != &first->s_rdma_wr.wr);\n\t}\n\n\nout:\n\treturn ret;\n}\n\nvoid rds_ib_xmit_path_complete(struct rds_conn_path *cp)\n{\n\tstruct rds_connection *conn = cp->cp_conn;\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\t \n\trds_ib_attempt_ack(ic);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}