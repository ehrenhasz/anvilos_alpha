{
  "module_name": "tcp_connect.c",
  "hash_id": "310ac0b8a403b6d7d0c36234bcd306fc9591e6112809ef54ef8657420c962ba1",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/tcp_connect.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/in.h>\n#include <net/tcp.h>\n\n#include \"rds.h\"\n#include \"tcp.h\"\n\nvoid rds_tcp_state_change(struct sock *sk)\n{\n\tvoid (*state_change)(struct sock *sk);\n\tstruct rds_conn_path *cp;\n\tstruct rds_tcp_connection *tc;\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tcp = sk->sk_user_data;\n\tif (!cp) {\n\t\tstate_change = sk->sk_state_change;\n\t\tgoto out;\n\t}\n\ttc = cp->cp_transport_data;\n\tstate_change = tc->t_orig_state_change;\n\n\trdsdebug(\"sock %p state_change to %d\\n\", tc->t_sock, sk->sk_state);\n\n\tswitch (sk->sk_state) {\n\t \n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\t\t \n\t\tif (rds_addr_cmp(&cp->cp_conn->c_laddr,\n\t\t\t\t &cp->cp_conn->c_faddr) >= 0 &&\n\t\t    rds_conn_path_transition(cp, RDS_CONN_CONNECTING,\n\t\t\t\t\t     RDS_CONN_ERROR)) {\n\t\t\trds_conn_path_drop(cp, false);\n\t\t} else {\n\t\t\trds_connect_path_complete(cp, RDS_CONN_CONNECTING);\n\t\t}\n\t\tbreak;\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSE:\n\t\trds_conn_path_drop(cp, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\tread_unlock_bh(&sk->sk_callback_lock);\n\tstate_change(sk);\n}\n\nint rds_tcp_conn_path_connect(struct rds_conn_path *cp)\n{\n\tstruct socket *sock = NULL;\n\tstruct sockaddr_in6 sin6;\n\tstruct sockaddr_in sin;\n\tstruct sockaddr *addr;\n\tint addrlen;\n\tbool isv6;\n\tint ret;\n\tstruct rds_connection *conn = cp->cp_conn;\n\tstruct rds_tcp_connection *tc = cp->cp_transport_data;\n\n\t \n\tif (cp->cp_index > 0 && cp->cp_conn->c_npaths < 2)\n\t\treturn -EAGAIN;\n\n\tmutex_lock(&tc->t_conn_path_lock);\n\n\tif (rds_conn_path_up(cp)) {\n\t\tmutex_unlock(&tc->t_conn_path_lock);\n\t\treturn 0;\n\t}\n\tif (ipv6_addr_v4mapped(&conn->c_laddr)) {\n\t\tret = sock_create_kern(rds_conn_net(conn), PF_INET,\n\t\t\t\t       SOCK_STREAM, IPPROTO_TCP, &sock);\n\t\tisv6 = false;\n\t} else {\n\t\tret = sock_create_kern(rds_conn_net(conn), PF_INET6,\n\t\t\t\t       SOCK_STREAM, IPPROTO_TCP, &sock);\n\t\tisv6 = true;\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!rds_tcp_tune(sock)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (isv6) {\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_addr = conn->c_laddr;\n\t\tsin6.sin6_port = 0;\n\t\tsin6.sin6_flowinfo = 0;\n\t\tsin6.sin6_scope_id = conn->c_dev_if;\n\t\taddr = (struct sockaddr *)&sin6;\n\t\taddrlen = sizeof(sin6);\n\t} else {\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = conn->c_laddr.s6_addr32[3];\n\t\tsin.sin_port = 0;\n\t\taddr = (struct sockaddr *)&sin;\n\t\taddrlen = sizeof(sin);\n\t}\n\n\tret = kernel_bind(sock, addr, addrlen);\n\tif (ret) {\n\t\trdsdebug(\"bind failed with %d at address %pI6c\\n\",\n\t\t\t ret, &conn->c_laddr);\n\t\tgoto out;\n\t}\n\n\tif (isv6) {\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_addr = conn->c_faddr;\n\t\tsin6.sin6_port = htons(RDS_TCP_PORT);\n\t\tsin6.sin6_flowinfo = 0;\n\t\tsin6.sin6_scope_id = conn->c_dev_if;\n\t\taddr = (struct sockaddr *)&sin6;\n\t\taddrlen = sizeof(sin6);\n\t} else {\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = conn->c_faddr.s6_addr32[3];\n\t\tsin.sin_port = htons(RDS_TCP_PORT);\n\t\taddr = (struct sockaddr *)&sin;\n\t\taddrlen = sizeof(sin);\n\t}\n\n\t \n\trds_tcp_set_callbacks(sock, cp);\n\tret = kernel_connect(sock, addr, addrlen, O_NONBLOCK);\n\n\trdsdebug(\"connect to address %pI6c returned %d\\n\", &conn->c_faddr, ret);\n\tif (ret == -EINPROGRESS)\n\t\tret = 0;\n\tif (ret == 0) {\n\t\trds_tcp_keepalive(sock);\n\t\tsock = NULL;\n\t} else {\n\t\trds_tcp_restore_callbacks(sock, cp->cp_transport_data);\n\t}\n\nout:\n\tmutex_unlock(&tc->t_conn_path_lock);\n\tif (sock)\n\t\tsock_release(sock);\n\treturn ret;\n}\n\n \nvoid rds_tcp_conn_path_shutdown(struct rds_conn_path *cp)\n{\n\tstruct rds_tcp_connection *tc = cp->cp_transport_data;\n\tstruct socket *sock = tc->t_sock;\n\n\trdsdebug(\"shutting down conn %p tc %p sock %p\\n\",\n\t\t cp->cp_conn, tc, sock);\n\n\tif (sock) {\n\t\tif (rds_destroy_pending(cp->cp_conn))\n\t\t\tsock_no_linger(sock->sk);\n\t\tsock->ops->shutdown(sock, RCV_SHUTDOWN | SEND_SHUTDOWN);\n\t\tlock_sock(sock->sk);\n\t\trds_tcp_restore_callbacks(sock, tc);  \n\n\t\trelease_sock(sock->sk);\n\t\tsock_release(sock);\n\t}\n\n\tif (tc->t_tinc) {\n\t\trds_inc_put(&tc->t_tinc->ti_inc);\n\t\ttc->t_tinc = NULL;\n\t}\n\ttc->t_tinc_hdr_rem = sizeof(struct rds_header);\n\ttc->t_tinc_data_rem = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}