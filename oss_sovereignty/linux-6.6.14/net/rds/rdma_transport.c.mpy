{
  "module_name": "rdma_transport.c",
  "hash_id": "55d142e2d7ad6b00e02b7e8568da3a913565112a224b7141f5f5fbba175cc483",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/rdma_transport.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <rdma/rdma_cm.h>\n\n#include \"rds_single_path.h\"\n#include \"rdma_transport.h\"\n#include \"ib.h\"\n\n \nstatic struct rdma_cm_id *rds_rdma_listen_id;\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct rdma_cm_id *rds6_rdma_listen_id;\n#endif\n\n \n#define TOS_TO_SL(tos)\t\t((tos) & 0xF)\n\nstatic int rds_rdma_cm_event_handler_cmn(struct rdma_cm_id *cm_id,\n\t\t\t\t\t struct rdma_cm_event *event,\n\t\t\t\t\t bool isv6)\n{\n\t \n\tstruct rds_connection *conn = cm_id->context;\n\tstruct rds_transport *trans;\n\tint ret = 0;\n\tint *err;\n\tu8 len;\n\n\trdsdebug(\"conn %p id %p handling event %u (%s)\\n\", conn, cm_id,\n\t\t event->event, rdma_event_msg(event->event));\n\n\tif (cm_id->device->node_type == RDMA_NODE_IB_CA)\n\t\ttrans = &rds_ib_transport;\n\n\t \n\tif (conn) {\n\t\tmutex_lock(&conn->c_cm_lock);\n\n\t\t \n\t\tif (rds_conn_state(conn) == RDS_CONN_DISCONNECTING) {\n\t\t\t \n\t\t\tif (event->event == RDMA_CM_EVENT_CONNECT_REQUEST)\n\t\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (event->event) {\n\tcase RDMA_CM_EVENT_CONNECT_REQUEST:\n\t\tret = trans->cm_handle_connect(cm_id, event, isv6);\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_ADDR_RESOLVED:\n\t\tif (conn) {\n\t\t\trdma_set_service_type(cm_id, conn->c_tos);\n\t\t\trdma_set_min_rnr_timer(cm_id, IB_RNR_TIMER_000_32);\n\t\t\t \n\t\t\tret = rdma_resolve_route(cm_id,\n\t\t\t\t\t\t RDS_RDMA_RESOLVE_TIMEOUT_MS);\n\t\t}\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_ROUTE_RESOLVED:\n\t\t \n\t\tif (conn) {\n\t\t\tstruct rds_ib_connection *ibic;\n\n\t\t\tibic = conn->c_transport_data;\n\t\t\tif (ibic && ibic->i_cm_id == cm_id) {\n\t\t\t\tcm_id->route.path_rec[0].sl =\n\t\t\t\t\tTOS_TO_SL(conn->c_tos);\n\t\t\t\tret = trans->cm_initiate_connect(cm_id, isv6);\n\t\t\t} else {\n\t\t\t\trds_conn_drop(conn);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_ESTABLISHED:\n\t\tif (conn)\n\t\t\ttrans->cm_connect_complete(conn, event);\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_REJECTED:\n\t\tif (!conn)\n\t\t\tbreak;\n\t\terr = (int *)rdma_consumer_reject_data(cm_id, event, &len);\n\t\tif (!err ||\n\t\t    (err && len >= sizeof(*err) &&\n\t\t     ((*err) <= RDS_RDMA_REJ_INCOMPAT))) {\n\t\t\tpr_warn(\"RDS/RDMA: conn <%pI6c, %pI6c> rejected, dropping connection\\n\",\n\t\t\t\t&conn->c_laddr, &conn->c_faddr);\n\n\t\t\tif (!conn->c_tos)\n\t\t\t\tconn->c_proposed_version = RDS_PROTOCOL_COMPAT_VERSION;\n\n\t\t\trds_conn_drop(conn);\n\t\t}\n\t\trdsdebug(\"Connection rejected: %s\\n\",\n\t\t\t rdma_reject_msg(cm_id, event->status));\n\t\tbreak;\n\tcase RDMA_CM_EVENT_ADDR_ERROR:\n\tcase RDMA_CM_EVENT_ROUTE_ERROR:\n\tcase RDMA_CM_EVENT_CONNECT_ERROR:\n\tcase RDMA_CM_EVENT_UNREACHABLE:\n\tcase RDMA_CM_EVENT_DEVICE_REMOVAL:\n\tcase RDMA_CM_EVENT_ADDR_CHANGE:\n\t\tif (conn)\n\t\t\trds_conn_drop(conn);\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_DISCONNECTED:\n\t\tif (!conn)\n\t\t\tbreak;\n\t\trdsdebug(\"DISCONNECT event - dropping connection \"\n\t\t\t \"%pI6c->%pI6c\\n\", &conn->c_laddr,\n\t\t\t &conn->c_faddr);\n\t\trds_conn_drop(conn);\n\t\tbreak;\n\n\tcase RDMA_CM_EVENT_TIMEWAIT_EXIT:\n\t\tif (conn) {\n\t\t\tpr_info(\"RDS: RDMA_CM_EVENT_TIMEWAIT_EXIT event: dropping connection %pI6c->%pI6c\\n\",\n\t\t\t\t&conn->c_laddr, &conn->c_faddr);\n\t\t\trds_conn_drop(conn);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tprintk(KERN_ERR \"RDS: unknown event %u (%s)!\\n\",\n\t\t       event->event, rdma_event_msg(event->event));\n\t\tbreak;\n\t}\n\nout:\n\tif (conn)\n\t\tmutex_unlock(&conn->c_cm_lock);\n\n\trdsdebug(\"id %p event %u (%s) handling ret %d\\n\", cm_id, event->event,\n\t\t rdma_event_msg(event->event), ret);\n\n\treturn ret;\n}\n\nint rds_rdma_cm_event_handler(struct rdma_cm_id *cm_id,\n\t\t\t      struct rdma_cm_event *event)\n{\n\treturn rds_rdma_cm_event_handler_cmn(cm_id, event, false);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nint rds6_rdma_cm_event_handler(struct rdma_cm_id *cm_id,\n\t\t\t       struct rdma_cm_event *event)\n{\n\treturn rds_rdma_cm_event_handler_cmn(cm_id, event, true);\n}\n#endif\n\nstatic int rds_rdma_listen_init_common(rdma_cm_event_handler handler,\n\t\t\t\t       struct sockaddr *sa,\n\t\t\t\t       struct rdma_cm_id **ret_cm_id)\n{\n\tstruct rdma_cm_id *cm_id;\n\tint ret;\n\n\tcm_id = rdma_create_id(&init_net, handler, NULL,\n\t\t\t       RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id)) {\n\t\tret = PTR_ERR(cm_id);\n\t\tprintk(KERN_ERR \"RDS/RDMA: failed to setup listener, \"\n\t\t       \"rdma_create_id() returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = rdma_bind_addr(cm_id, sa);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"RDS/RDMA: failed to setup listener, \"\n\t\t       \"rdma_bind_addr() returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = rdma_listen(cm_id, 128);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"RDS/RDMA: failed to setup listener, \"\n\t\t       \"rdma_listen() returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"cm %p listening on port %u\\n\", cm_id, RDS_PORT);\n\n\t*ret_cm_id = cm_id;\n\tcm_id = NULL;\nout:\n\tif (cm_id)\n\t\trdma_destroy_id(cm_id);\n\treturn ret;\n}\n\n \nstatic int rds_rdma_listen_init(void)\n{\n\tint ret;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 sin6;\n#endif\n\tstruct sockaddr_in sin;\n\n\tsin.sin_family = PF_INET;\n\tsin.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsin.sin_port = htons(RDS_PORT);\n\tret = rds_rdma_listen_init_common(rds_rdma_cm_event_handler,\n\t\t\t\t\t  (struct sockaddr *)&sin,\n\t\t\t\t\t  &rds_rdma_listen_id);\n\tif (ret != 0)\n\t\treturn ret;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tsin6.sin6_family = PF_INET6;\n\tsin6.sin6_addr = in6addr_any;\n\tsin6.sin6_port = htons(RDS_CM_PORT);\n\tsin6.sin6_scope_id = 0;\n\tsin6.sin6_flowinfo = 0;\n\tret = rds_rdma_listen_init_common(rds6_rdma_cm_event_handler,\n\t\t\t\t\t  (struct sockaddr *)&sin6,\n\t\t\t\t\t  &rds6_rdma_listen_id);\n\t \n\tif (ret != 0)\n\t\trdsdebug(\"Cannot set up IPv6 RDMA listener\\n\");\n#endif\n\treturn 0;\n}\n\nstatic void rds_rdma_listen_stop(void)\n{\n\tif (rds_rdma_listen_id) {\n\t\trdsdebug(\"cm %p\\n\", rds_rdma_listen_id);\n\t\trdma_destroy_id(rds_rdma_listen_id);\n\t\trds_rdma_listen_id = NULL;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (rds6_rdma_listen_id) {\n\t\trdsdebug(\"cm %p\\n\", rds6_rdma_listen_id);\n\t\trdma_destroy_id(rds6_rdma_listen_id);\n\t\trds6_rdma_listen_id = NULL;\n\t}\n#endif\n}\n\nstatic int __init rds_rdma_init(void)\n{\n\tint ret;\n\n\tret = rds_ib_init();\n\tif (ret)\n\t\tgoto out;\n\n\tret = rds_rdma_listen_init();\n\tif (ret)\n\t\trds_ib_exit();\nout:\n\treturn ret;\n}\nmodule_init(rds_rdma_init);\n\nstatic void __exit rds_rdma_exit(void)\n{\n\t \n\trds_rdma_listen_stop();\n\trds_ib_exit();\n}\nmodule_exit(rds_rdma_exit);\n\nMODULE_AUTHOR(\"Oracle Corporation <rds-devel@oss.oracle.com>\");\nMODULE_DESCRIPTION(\"RDS: IB transport\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}