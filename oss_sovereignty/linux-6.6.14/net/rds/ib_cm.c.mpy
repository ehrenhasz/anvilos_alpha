{
  "module_name": "ib_cm.c",
  "hash_id": "8bca2387294920c3252e4ad388be594d674f1ba7ce8e000304a73371cc8f7639",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/ib_cm.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/ratelimit.h>\n#include <net/addrconf.h>\n#include <rdma/ib_cm.h>\n\n#include \"rds_single_path.h\"\n#include \"rds.h\"\n#include \"ib.h\"\n#include \"ib_mr.h\"\n\n \nstatic void rds_ib_set_protocol(struct rds_connection *conn, unsigned int version)\n{\n\tconn->c_version = version;\n}\n\n \nstatic void rds_ib_set_flow_control(struct rds_connection *conn, u32 credits)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\tif (rds_ib_sysctl_flow_control && credits != 0) {\n\t\t \n\t\tic->i_flowctl = 1;\n\t\trds_ib_send_add_credits(conn, credits);\n\t} else {\n\t\tic->i_flowctl = 0;\n\t}\n}\n\n \nvoid rds_ib_cm_connect_complete(struct rds_connection *conn, struct rdma_cm_event *event)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tconst union rds_ib_conn_priv *dp = NULL;\n\t__be64 ack_seq = 0;\n\t__be32 credit = 0;\n\tu8 major = 0;\n\tu8 minor = 0;\n\tint err;\n\n\tdp = event->param.conn.private_data;\n\tif (conn->c_isv6) {\n\t\tif (event->param.conn.private_data_len >=\n\t\t    sizeof(struct rds6_ib_connect_private)) {\n\t\t\tmajor = dp->ricp_v6.dp_protocol_major;\n\t\t\tminor = dp->ricp_v6.dp_protocol_minor;\n\t\t\tcredit = dp->ricp_v6.dp_credit;\n\t\t\t \n\t\t\tack_seq = get_unaligned(&dp->ricp_v6.dp_ack_seq);\n\t\t}\n\t} else if (event->param.conn.private_data_len >=\n\t\t   sizeof(struct rds_ib_connect_private)) {\n\t\tmajor = dp->ricp_v4.dp_protocol_major;\n\t\tminor = dp->ricp_v4.dp_protocol_minor;\n\t\tcredit = dp->ricp_v4.dp_credit;\n\t\tack_seq = get_unaligned(&dp->ricp_v4.dp_ack_seq);\n\t}\n\n\t \n\tif (major) {\n\t\trds_ib_set_protocol(conn, RDS_PROTOCOL(major, minor));\n\t\trds_ib_set_flow_control(conn, be32_to_cpu(credit));\n\t}\n\n\tif (conn->c_version < RDS_PROTOCOL_VERSION) {\n\t\tif (conn->c_version != RDS_PROTOCOL_COMPAT_VERSION) {\n\t\t\tpr_notice(\"RDS/IB: Connection <%pI6c,%pI6c> version %u.%u no longer supported\\n\",\n\t\t\t\t  &conn->c_laddr, &conn->c_faddr,\n\t\t\t\t  RDS_PROTOCOL_MAJOR(conn->c_version),\n\t\t\t\t  RDS_PROTOCOL_MINOR(conn->c_version));\n\t\t\trds_conn_destroy(conn);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpr_notice(\"RDS/IB: %s conn connected <%pI6c,%pI6c,%d> version %u.%u%s\\n\",\n\t\t  ic->i_active_side ? \"Active\" : \"Passive\",\n\t\t  &conn->c_laddr, &conn->c_faddr, conn->c_tos,\n\t\t  RDS_PROTOCOL_MAJOR(conn->c_version),\n\t\t  RDS_PROTOCOL_MINOR(conn->c_version),\n\t\t  ic->i_flowctl ? \", flow control\" : \"\");\n\n\t \n\tic->i_sl = ic->i_cm_id->route.path_rec->sl;\n\n\tatomic_set(&ic->i_cq_quiesce, 0);\n\n\t \n\trds_ib_send_init_ring(ic);\n\trds_ib_recv_init_ring(ic);\n\t \n\trds_ib_recv_refill(conn, 1, GFP_KERNEL);\n\n\t \n\terr = rds_ib_update_ipaddr(ic->rds_ibdev, &conn->c_laddr);\n\tif (err)\n\t\tprintk(KERN_ERR \"rds_ib_update_ipaddr failed (%d)\\n\",\n\t\t\terr);\n\n\t \n\tif (dp) {\n\t\tif (ack_seq)\n\t\t\trds_send_drop_acked(conn, be64_to_cpu(ack_seq),\n\t\t\t\t\t    NULL);\n\t}\n\n\tconn->c_proposed_version = conn->c_version;\n\trds_connect_complete(conn);\n}\n\nstatic void rds_ib_cm_fill_conn_param(struct rds_connection *conn,\n\t\t\t\t      struct rdma_conn_param *conn_param,\n\t\t\t\t      union rds_ib_conn_priv *dp,\n\t\t\t\t      u32 protocol_version,\n\t\t\t\t      u32 max_responder_resources,\n\t\t\t\t      u32 max_initiator_depth,\n\t\t\t\t      bool isv6)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tstruct rds_ib_device *rds_ibdev = ic->rds_ibdev;\n\n\tmemset(conn_param, 0, sizeof(struct rdma_conn_param));\n\n\tconn_param->responder_resources =\n\t\tmin_t(u32, rds_ibdev->max_responder_resources, max_responder_resources);\n\tconn_param->initiator_depth =\n\t\tmin_t(u32, rds_ibdev->max_initiator_depth, max_initiator_depth);\n\tconn_param->retry_count = min_t(unsigned int, rds_ib_retry_count, 7);\n\tconn_param->rnr_retry_count = 7;\n\n\tif (dp) {\n\t\tmemset(dp, 0, sizeof(*dp));\n\t\tif (isv6) {\n\t\t\tdp->ricp_v6.dp_saddr = conn->c_laddr;\n\t\t\tdp->ricp_v6.dp_daddr = conn->c_faddr;\n\t\t\tdp->ricp_v6.dp_protocol_major =\n\t\t\t    RDS_PROTOCOL_MAJOR(protocol_version);\n\t\t\tdp->ricp_v6.dp_protocol_minor =\n\t\t\t    RDS_PROTOCOL_MINOR(protocol_version);\n\t\t\tdp->ricp_v6.dp_protocol_minor_mask =\n\t\t\t    cpu_to_be16(RDS_IB_SUPPORTED_PROTOCOLS);\n\t\t\tdp->ricp_v6.dp_ack_seq =\n\t\t\t    cpu_to_be64(rds_ib_piggyb_ack(ic));\n\t\t\tdp->ricp_v6.dp_cmn.ricpc_dp_toss = conn->c_tos;\n\n\t\t\tconn_param->private_data = &dp->ricp_v6;\n\t\t\tconn_param->private_data_len = sizeof(dp->ricp_v6);\n\t\t} else {\n\t\t\tdp->ricp_v4.dp_saddr = conn->c_laddr.s6_addr32[3];\n\t\t\tdp->ricp_v4.dp_daddr = conn->c_faddr.s6_addr32[3];\n\t\t\tdp->ricp_v4.dp_protocol_major =\n\t\t\t    RDS_PROTOCOL_MAJOR(protocol_version);\n\t\t\tdp->ricp_v4.dp_protocol_minor =\n\t\t\t    RDS_PROTOCOL_MINOR(protocol_version);\n\t\t\tdp->ricp_v4.dp_protocol_minor_mask =\n\t\t\t    cpu_to_be16(RDS_IB_SUPPORTED_PROTOCOLS);\n\t\t\tdp->ricp_v4.dp_ack_seq =\n\t\t\t    cpu_to_be64(rds_ib_piggyb_ack(ic));\n\t\t\tdp->ricp_v4.dp_cmn.ricpc_dp_toss = conn->c_tos;\n\n\t\t\tconn_param->private_data = &dp->ricp_v4;\n\t\t\tconn_param->private_data_len = sizeof(dp->ricp_v4);\n\t\t}\n\n\t\t \n\t\tif (ic->i_flowctl) {\n\t\t\tunsigned int credits;\n\n\t\t\tcredits = IB_GET_POST_CREDITS\n\t\t\t\t(atomic_read(&ic->i_credits));\n\t\t\tif (isv6)\n\t\t\t\tdp->ricp_v6.dp_credit = cpu_to_be32(credits);\n\t\t\telse\n\t\t\t\tdp->ricp_v4.dp_credit = cpu_to_be32(credits);\n\t\t\tatomic_sub(IB_SET_POST_CREDITS(credits),\n\t\t\t\t   &ic->i_credits);\n\t\t}\n\t}\n}\n\nstatic void rds_ib_cq_event_handler(struct ib_event *event, void *data)\n{\n\trdsdebug(\"event %u (%s) data %p\\n\",\n\t\t event->event, ib_event_msg(event->event), data);\n}\n\n \nstatic void rds_ib_cq_comp_handler_recv(struct ib_cq *cq, void *context)\n{\n\tstruct rds_connection *conn = context;\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\trdsdebug(\"conn %p cq %p\\n\", conn, cq);\n\n\trds_ib_stats_inc(s_ib_evt_handler_call);\n\n\ttasklet_schedule(&ic->i_recv_tasklet);\n}\n\nstatic void poll_scq(struct rds_ib_connection *ic, struct ib_cq *cq,\n\t\t     struct ib_wc *wcs)\n{\n\tint nr, i;\n\tstruct ib_wc *wc;\n\n\twhile ((nr = ib_poll_cq(cq, RDS_IB_WC_MAX, wcs)) > 0) {\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\twc = wcs + i;\n\t\t\trdsdebug(\"wc wr_id 0x%llx status %u byte_len %u imm_data %u\\n\",\n\t\t\t\t (unsigned long long)wc->wr_id, wc->status,\n\t\t\t\t wc->byte_len, be32_to_cpu(wc->ex.imm_data));\n\n\t\t\tif (wc->wr_id <= ic->i_send_ring.w_nr ||\n\t\t\t    wc->wr_id == RDS_IB_ACK_WR_ID)\n\t\t\t\trds_ib_send_cqe_handler(ic, wc);\n\t\t\telse\n\t\t\t\trds_ib_mr_cqe_handler(ic, wc);\n\n\t\t}\n\t}\n}\n\nstatic void rds_ib_tasklet_fn_send(unsigned long data)\n{\n\tstruct rds_ib_connection *ic = (struct rds_ib_connection *)data;\n\tstruct rds_connection *conn = ic->conn;\n\n\trds_ib_stats_inc(s_ib_tasklet_call);\n\n\t \n\tif (atomic_read(&ic->i_cq_quiesce))\n\t\treturn;\n\n\tpoll_scq(ic, ic->i_send_cq, ic->i_send_wc);\n\tib_req_notify_cq(ic->i_send_cq, IB_CQ_NEXT_COMP);\n\tpoll_scq(ic, ic->i_send_cq, ic->i_send_wc);\n\n\tif (rds_conn_up(conn) &&\n\t    (!test_bit(RDS_LL_SEND_FULL, &conn->c_flags) ||\n\t    test_bit(0, &conn->c_map_queued)))\n\t\trds_send_xmit(&ic->conn->c_path[0]);\n}\n\nstatic void poll_rcq(struct rds_ib_connection *ic, struct ib_cq *cq,\n\t\t     struct ib_wc *wcs,\n\t\t     struct rds_ib_ack_state *ack_state)\n{\n\tint nr, i;\n\tstruct ib_wc *wc;\n\n\twhile ((nr = ib_poll_cq(cq, RDS_IB_WC_MAX, wcs)) > 0) {\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\twc = wcs + i;\n\t\t\trdsdebug(\"wc wr_id 0x%llx status %u byte_len %u imm_data %u\\n\",\n\t\t\t\t (unsigned long long)wc->wr_id, wc->status,\n\t\t\t\t wc->byte_len, be32_to_cpu(wc->ex.imm_data));\n\n\t\t\trds_ib_recv_cqe_handler(ic, wc, ack_state);\n\t\t}\n\t}\n}\n\nstatic void rds_ib_tasklet_fn_recv(unsigned long data)\n{\n\tstruct rds_ib_connection *ic = (struct rds_ib_connection *)data;\n\tstruct rds_connection *conn = ic->conn;\n\tstruct rds_ib_device *rds_ibdev = ic->rds_ibdev;\n\tstruct rds_ib_ack_state state;\n\n\tif (!rds_ibdev)\n\t\trds_conn_drop(conn);\n\n\trds_ib_stats_inc(s_ib_tasklet_call);\n\n\t \n\tif (atomic_read(&ic->i_cq_quiesce))\n\t\treturn;\n\n\tmemset(&state, 0, sizeof(state));\n\tpoll_rcq(ic, ic->i_recv_cq, ic->i_recv_wc, &state);\n\tib_req_notify_cq(ic->i_recv_cq, IB_CQ_SOLICITED);\n\tpoll_rcq(ic, ic->i_recv_cq, ic->i_recv_wc, &state);\n\n\tif (state.ack_next_valid)\n\t\trds_ib_set_ack(ic, state.ack_next, state.ack_required);\n\tif (state.ack_recv_valid && state.ack_recv > ic->i_ack_recv) {\n\t\trds_send_drop_acked(conn, state.ack_recv, NULL);\n\t\tic->i_ack_recv = state.ack_recv;\n\t}\n\n\tif (rds_conn_up(conn))\n\t\trds_ib_attempt_ack(ic);\n}\n\nstatic void rds_ib_qp_event_handler(struct ib_event *event, void *data)\n{\n\tstruct rds_connection *conn = data;\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\trdsdebug(\"conn %p ic %p event %u (%s)\\n\", conn, ic, event->event,\n\t\t ib_event_msg(event->event));\n\n\tswitch (event->event) {\n\tcase IB_EVENT_COMM_EST:\n\t\trdma_notify(ic->i_cm_id, IB_EVENT_COMM_EST);\n\t\tbreak;\n\tdefault:\n\t\trdsdebug(\"Fatal QP Event %u (%s) - connection %pI6c->%pI6c, reconnecting\\n\",\n\t\t\t event->event, ib_event_msg(event->event),\n\t\t\t &conn->c_laddr, &conn->c_faddr);\n\t\trds_conn_drop(conn);\n\t\tbreak;\n\t}\n}\n\nstatic void rds_ib_cq_comp_handler_send(struct ib_cq *cq, void *context)\n{\n\tstruct rds_connection *conn = context;\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\trdsdebug(\"conn %p cq %p\\n\", conn, cq);\n\n\trds_ib_stats_inc(s_ib_evt_handler_call);\n\n\ttasklet_schedule(&ic->i_send_tasklet);\n}\n\nstatic inline int ibdev_get_unused_vector(struct rds_ib_device *rds_ibdev)\n{\n\tint min = rds_ibdev->vector_load[rds_ibdev->dev->num_comp_vectors - 1];\n\tint index = rds_ibdev->dev->num_comp_vectors - 1;\n\tint i;\n\n\tfor (i = rds_ibdev->dev->num_comp_vectors - 1; i >= 0; i--) {\n\t\tif (rds_ibdev->vector_load[i] < min) {\n\t\t\tindex = i;\n\t\t\tmin = rds_ibdev->vector_load[i];\n\t\t}\n\t}\n\n\trds_ibdev->vector_load[index]++;\n\treturn index;\n}\n\nstatic inline void ibdev_put_vector(struct rds_ib_device *rds_ibdev, int index)\n{\n\trds_ibdev->vector_load[index]--;\n}\n\nstatic void rds_dma_hdr_free(struct ib_device *dev, struct rds_header *hdr,\n\t\tdma_addr_t dma_addr, enum dma_data_direction dir)\n{\n\tib_dma_unmap_single(dev, dma_addr, sizeof(*hdr), dir);\n\tkfree(hdr);\n}\n\nstatic struct rds_header *rds_dma_hdr_alloc(struct ib_device *dev,\n\t\tdma_addr_t *dma_addr, enum dma_data_direction dir)\n{\n\tstruct rds_header *hdr;\n\n\thdr = kzalloc_node(sizeof(*hdr), GFP_KERNEL, ibdev_to_node(dev));\n\tif (!hdr)\n\t\treturn NULL;\n\n\t*dma_addr = ib_dma_map_single(dev, hdr, sizeof(*hdr),\n\t\t\t\t      DMA_BIDIRECTIONAL);\n\tif (ib_dma_mapping_error(dev, *dma_addr)) {\n\t\tkfree(hdr);\n\t\treturn NULL;\n\t}\n\n\treturn hdr;\n}\n\n \nstatic void rds_dma_hdrs_free(struct rds_ib_device *dev,\n\t\tstruct rds_header **hdrs, dma_addr_t *dma_addrs, u32 num_hdrs,\n\t\tenum dma_data_direction dir)\n{\n\tu32 i;\n\n\tfor (i = 0; i < num_hdrs; i++)\n\t\trds_dma_hdr_free(dev->dev, hdrs[i], dma_addrs[i], dir);\n\tkvfree(hdrs);\n\tkvfree(dma_addrs);\n}\n\n\n \nstatic struct rds_header **rds_dma_hdrs_alloc(struct rds_ib_device *dev,\n\t\tdma_addr_t **dma_addrs, u32 num_hdrs,\n\t\tenum dma_data_direction dir)\n{\n\tstruct rds_header **hdrs;\n\tdma_addr_t *hdr_daddrs;\n\tu32 i;\n\n\thdrs = kvmalloc_node(sizeof(*hdrs) * num_hdrs, GFP_KERNEL,\n\t\t\t     ibdev_to_node(dev->dev));\n\tif (!hdrs)\n\t\treturn NULL;\n\n\thdr_daddrs = kvmalloc_node(sizeof(*hdr_daddrs) * num_hdrs, GFP_KERNEL,\n\t\t\t\t   ibdev_to_node(dev->dev));\n\tif (!hdr_daddrs) {\n\t\tkvfree(hdrs);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < num_hdrs; i++) {\n\t\thdrs[i] = rds_dma_hdr_alloc(dev->dev, &hdr_daddrs[i], dir);\n\t\tif (!hdrs[i]) {\n\t\t\trds_dma_hdrs_free(dev, hdrs, hdr_daddrs, i, dir);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t*dma_addrs = hdr_daddrs;\n\treturn hdrs;\n}\n\n \nstatic int rds_ib_setup_qp(struct rds_connection *conn)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tstruct ib_device *dev = ic->i_cm_id->device;\n\tstruct ib_qp_init_attr attr;\n\tstruct ib_cq_init_attr cq_attr = {};\n\tstruct rds_ib_device *rds_ibdev;\n\tunsigned long max_wrs;\n\tint ret, fr_queue_space;\n\n\t \n\trds_ibdev = rds_ib_get_client_data(dev);\n\tif (!rds_ibdev)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tfr_queue_space = RDS_IB_DEFAULT_FR_WR;\n\n\t \n\trds_ib_add_conn(rds_ibdev, conn);\n\n\tmax_wrs = rds_ibdev->max_wrs < rds_ib_sysctl_max_send_wr + 1 ?\n\t\trds_ibdev->max_wrs - 1 : rds_ib_sysctl_max_send_wr;\n\tif (ic->i_send_ring.w_nr != max_wrs)\n\t\trds_ib_ring_resize(&ic->i_send_ring, max_wrs);\n\n\tmax_wrs = rds_ibdev->max_wrs < rds_ib_sysctl_max_recv_wr + 1 ?\n\t\trds_ibdev->max_wrs - 1 : rds_ib_sysctl_max_recv_wr;\n\tif (ic->i_recv_ring.w_nr != max_wrs)\n\t\trds_ib_ring_resize(&ic->i_recv_ring, max_wrs);\n\n\t \n\tic->i_pd = rds_ibdev->pd;\n\n\tic->i_scq_vector = ibdev_get_unused_vector(rds_ibdev);\n\tcq_attr.cqe = ic->i_send_ring.w_nr + fr_queue_space + 1;\n\tcq_attr.comp_vector = ic->i_scq_vector;\n\tic->i_send_cq = ib_create_cq(dev, rds_ib_cq_comp_handler_send,\n\t\t\t\t     rds_ib_cq_event_handler, conn,\n\t\t\t\t     &cq_attr);\n\tif (IS_ERR(ic->i_send_cq)) {\n\t\tret = PTR_ERR(ic->i_send_cq);\n\t\tic->i_send_cq = NULL;\n\t\tibdev_put_vector(rds_ibdev, ic->i_scq_vector);\n\t\trdsdebug(\"ib_create_cq send failed: %d\\n\", ret);\n\t\tgoto rds_ibdev_out;\n\t}\n\n\tic->i_rcq_vector = ibdev_get_unused_vector(rds_ibdev);\n\tcq_attr.cqe = ic->i_recv_ring.w_nr;\n\tcq_attr.comp_vector = ic->i_rcq_vector;\n\tic->i_recv_cq = ib_create_cq(dev, rds_ib_cq_comp_handler_recv,\n\t\t\t\t     rds_ib_cq_event_handler, conn,\n\t\t\t\t     &cq_attr);\n\tif (IS_ERR(ic->i_recv_cq)) {\n\t\tret = PTR_ERR(ic->i_recv_cq);\n\t\tic->i_recv_cq = NULL;\n\t\tibdev_put_vector(rds_ibdev, ic->i_rcq_vector);\n\t\trdsdebug(\"ib_create_cq recv failed: %d\\n\", ret);\n\t\tgoto send_cq_out;\n\t}\n\n\tret = ib_req_notify_cq(ic->i_send_cq, IB_CQ_NEXT_COMP);\n\tif (ret) {\n\t\trdsdebug(\"ib_req_notify_cq send failed: %d\\n\", ret);\n\t\tgoto recv_cq_out;\n\t}\n\n\tret = ib_req_notify_cq(ic->i_recv_cq, IB_CQ_SOLICITED);\n\tif (ret) {\n\t\trdsdebug(\"ib_req_notify_cq recv failed: %d\\n\", ret);\n\t\tgoto recv_cq_out;\n\t}\n\n\t \n\tmemset(&attr, 0, sizeof(attr));\n\tattr.event_handler = rds_ib_qp_event_handler;\n\tattr.qp_context = conn;\n\t \n\tattr.cap.max_send_wr = ic->i_send_ring.w_nr + fr_queue_space + 1;\n\tattr.cap.max_recv_wr = ic->i_recv_ring.w_nr + 1;\n\tattr.cap.max_send_sge = rds_ibdev->max_sge;\n\tattr.cap.max_recv_sge = RDS_IB_RECV_SGE;\n\tattr.sq_sig_type = IB_SIGNAL_REQ_WR;\n\tattr.qp_type = IB_QPT_RC;\n\tattr.send_cq = ic->i_send_cq;\n\tattr.recv_cq = ic->i_recv_cq;\n\n\t \n\tret = rdma_create_qp(ic->i_cm_id, ic->i_pd, &attr);\n\tif (ret) {\n\t\trdsdebug(\"rdma_create_qp failed: %d\\n\", ret);\n\t\tgoto recv_cq_out;\n\t}\n\n\tic->i_send_hdrs = rds_dma_hdrs_alloc(rds_ibdev, &ic->i_send_hdrs_dma,\n\t\t\t\t\t     ic->i_send_ring.w_nr,\n\t\t\t\t\t     DMA_TO_DEVICE);\n\tif (!ic->i_send_hdrs) {\n\t\tret = -ENOMEM;\n\t\trdsdebug(\"DMA send hdrs alloc failed\\n\");\n\t\tgoto qp_out;\n\t}\n\n\tic->i_recv_hdrs = rds_dma_hdrs_alloc(rds_ibdev, &ic->i_recv_hdrs_dma,\n\t\t\t\t\t     ic->i_recv_ring.w_nr,\n\t\t\t\t\t     DMA_FROM_DEVICE);\n\tif (!ic->i_recv_hdrs) {\n\t\tret = -ENOMEM;\n\t\trdsdebug(\"DMA recv hdrs alloc failed\\n\");\n\t\tgoto send_hdrs_dma_out;\n\t}\n\n\tic->i_ack = rds_dma_hdr_alloc(rds_ibdev->dev, &ic->i_ack_dma,\n\t\t\t\t      DMA_TO_DEVICE);\n\tif (!ic->i_ack) {\n\t\tret = -ENOMEM;\n\t\trdsdebug(\"DMA ack header alloc failed\\n\");\n\t\tgoto recv_hdrs_dma_out;\n\t}\n\n\tic->i_sends = vzalloc_node(array_size(sizeof(struct rds_ib_send_work),\n\t\t\t\t\t      ic->i_send_ring.w_nr),\n\t\t\t\t   ibdev_to_node(dev));\n\tif (!ic->i_sends) {\n\t\tret = -ENOMEM;\n\t\trdsdebug(\"send allocation failed\\n\");\n\t\tgoto ack_dma_out;\n\t}\n\n\tic->i_recvs = vzalloc_node(array_size(sizeof(struct rds_ib_recv_work),\n\t\t\t\t\t      ic->i_recv_ring.w_nr),\n\t\t\t\t   ibdev_to_node(dev));\n\tif (!ic->i_recvs) {\n\t\tret = -ENOMEM;\n\t\trdsdebug(\"recv allocation failed\\n\");\n\t\tgoto sends_out;\n\t}\n\n\trds_ib_recv_init_ack(ic);\n\n\trdsdebug(\"conn %p pd %p cq %p %p\\n\", conn, ic->i_pd,\n\t\t ic->i_send_cq, ic->i_recv_cq);\n\n\tgoto out;\n\nsends_out:\n\tvfree(ic->i_sends);\n\nack_dma_out:\n\trds_dma_hdr_free(rds_ibdev->dev, ic->i_ack, ic->i_ack_dma,\n\t\t\t DMA_TO_DEVICE);\n\tic->i_ack = NULL;\n\nrecv_hdrs_dma_out:\n\trds_dma_hdrs_free(rds_ibdev, ic->i_recv_hdrs, ic->i_recv_hdrs_dma,\n\t\t\t  ic->i_recv_ring.w_nr, DMA_FROM_DEVICE);\n\tic->i_recv_hdrs = NULL;\n\tic->i_recv_hdrs_dma = NULL;\n\nsend_hdrs_dma_out:\n\trds_dma_hdrs_free(rds_ibdev, ic->i_send_hdrs, ic->i_send_hdrs_dma,\n\t\t\t  ic->i_send_ring.w_nr, DMA_TO_DEVICE);\n\tic->i_send_hdrs = NULL;\n\tic->i_send_hdrs_dma = NULL;\n\nqp_out:\n\trdma_destroy_qp(ic->i_cm_id);\nrecv_cq_out:\n\tib_destroy_cq(ic->i_recv_cq);\n\tic->i_recv_cq = NULL;\nsend_cq_out:\n\tib_destroy_cq(ic->i_send_cq);\n\tic->i_send_cq = NULL;\nrds_ibdev_out:\n\trds_ib_remove_conn(rds_ibdev, conn);\nout:\n\trds_ib_dev_put(rds_ibdev);\n\n\treturn ret;\n}\n\nstatic u32 rds_ib_protocol_compatible(struct rdma_cm_event *event, bool isv6)\n{\n\tconst union rds_ib_conn_priv *dp = event->param.conn.private_data;\n\tu8 data_len, major, minor;\n\tu32 version = 0;\n\t__be16 mask;\n\tu16 common;\n\n\t \n\n\t \n\tif (!event->param.conn.private_data_len) {\n\t\tprintk(KERN_NOTICE \"RDS incoming connection has no private data, \"\n\t\t\t\"rejecting\\n\");\n\t\treturn 0;\n\t}\n\n\tif (isv6) {\n\t\tdata_len = sizeof(struct rds6_ib_connect_private);\n\t\tmajor = dp->ricp_v6.dp_protocol_major;\n\t\tminor = dp->ricp_v6.dp_protocol_minor;\n\t\tmask = dp->ricp_v6.dp_protocol_minor_mask;\n\t} else {\n\t\tdata_len = sizeof(struct rds_ib_connect_private);\n\t\tmajor = dp->ricp_v4.dp_protocol_major;\n\t\tminor = dp->ricp_v4.dp_protocol_minor;\n\t\tmask = dp->ricp_v4.dp_protocol_minor_mask;\n\t}\n\n\t \n\tif (event->param.conn.private_data_len < data_len || major == 0)\n\t\treturn RDS_PROTOCOL_4_0;\n\n\tcommon = be16_to_cpu(mask) & RDS_IB_SUPPORTED_PROTOCOLS;\n\tif (major == 4 && common) {\n\t\tversion = RDS_PROTOCOL_4_0;\n\t\twhile ((common >>= 1) != 0)\n\t\t\tversion++;\n\t} else if (RDS_PROTOCOL_COMPAT_VERSION ==\n\t\t   RDS_PROTOCOL(major, minor)) {\n\t\tversion = RDS_PROTOCOL_COMPAT_VERSION;\n\t} else {\n\t\tif (isv6)\n\t\t\tprintk_ratelimited(KERN_NOTICE \"RDS: Connection from %pI6c using incompatible protocol version %u.%u\\n\",\n\t\t\t\t\t   &dp->ricp_v6.dp_saddr, major, minor);\n\t\telse\n\t\t\tprintk_ratelimited(KERN_NOTICE \"RDS: Connection from %pI4 using incompatible protocol version %u.%u\\n\",\n\t\t\t\t\t   &dp->ricp_v4.dp_saddr, major, minor);\n\t}\n\treturn version;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstatic u32 __rds_find_ifindex(struct net *net, const struct in6_addr *addr)\n{\n\tstruct net_device *dev;\n\tint idx = 0;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (ipv6_chk_addr(net, addr, dev, 1)) {\n\t\t\tidx = dev->ifindex;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn idx;\n}\n#endif\n\nint rds_ib_cm_handle_connect(struct rdma_cm_id *cm_id,\n\t\t\t     struct rdma_cm_event *event, bool isv6)\n{\n\t__be64 lguid = cm_id->route.path_rec->sgid.global.interface_id;\n\t__be64 fguid = cm_id->route.path_rec->dgid.global.interface_id;\n\tconst struct rds_ib_conn_priv_cmn *dp_cmn;\n\tstruct rds_connection *conn = NULL;\n\tstruct rds_ib_connection *ic = NULL;\n\tstruct rdma_conn_param conn_param;\n\tconst union rds_ib_conn_priv *dp;\n\tunion rds_ib_conn_priv dp_rep;\n\tstruct in6_addr s_mapped_addr;\n\tstruct in6_addr d_mapped_addr;\n\tconst struct in6_addr *saddr6;\n\tconst struct in6_addr *daddr6;\n\tint destroy = 1;\n\tu32 ifindex = 0;\n\tu32 version;\n\tint err = 1;\n\n\t \n\tversion = rds_ib_protocol_compatible(event, isv6);\n\tif (!version) {\n\t\terr = RDS_RDMA_REJ_INCOMPAT;\n\t\tgoto out;\n\t}\n\n\tdp = event->param.conn.private_data;\n\tif (isv6) {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tdp_cmn = &dp->ricp_v6.dp_cmn;\n\t\tsaddr6 = &dp->ricp_v6.dp_saddr;\n\t\tdaddr6 = &dp->ricp_v6.dp_daddr;\n\t\t \n\t\tif (ipv6_addr_type(daddr6) & IPV6_ADDR_LINKLOCAL) {\n\t\t\t \n\t\t\tifindex = __rds_find_ifindex(&init_net, daddr6);\n\t\t\t \n\t\t\tif (ifindex == 0) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (ipv6_addr_type(saddr6) & IPV6_ADDR_LINKLOCAL) {\n\t\t\t \n\t\t\tifindex = __rds_find_ifindex(&init_net, daddr6);\n\t\t\t \n\t\t\tif (ifindex == 0) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n#else\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n#endif\n\t} else {\n\t\tdp_cmn = &dp->ricp_v4.dp_cmn;\n\t\tipv6_addr_set_v4mapped(dp->ricp_v4.dp_saddr, &s_mapped_addr);\n\t\tipv6_addr_set_v4mapped(dp->ricp_v4.dp_daddr, &d_mapped_addr);\n\t\tsaddr6 = &s_mapped_addr;\n\t\tdaddr6 = &d_mapped_addr;\n\t}\n\n\trdsdebug(\"saddr %pI6c daddr %pI6c RDSv%u.%u lguid 0x%llx fguid 0x%llx, tos:%d\\n\",\n\t\t saddr6, daddr6, RDS_PROTOCOL_MAJOR(version),\n\t\t RDS_PROTOCOL_MINOR(version),\n\t\t (unsigned long long)be64_to_cpu(lguid),\n\t\t (unsigned long long)be64_to_cpu(fguid), dp_cmn->ricpc_dp_toss);\n\n\t \n\tconn = rds_conn_create(&init_net, daddr6, saddr6,\n\t\t\t       &rds_ib_transport, dp_cmn->ricpc_dp_toss,\n\t\t\t       GFP_KERNEL, ifindex);\n\tif (IS_ERR(conn)) {\n\t\trdsdebug(\"rds_conn_create failed (%ld)\\n\", PTR_ERR(conn));\n\t\tconn = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tmutex_lock(&conn->c_cm_lock);\n\tif (!rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING)) {\n\t\tif (rds_conn_state(conn) == RDS_CONN_UP) {\n\t\t\trdsdebug(\"incoming connect while connecting\\n\");\n\t\t\trds_conn_drop(conn);\n\t\t\trds_ib_stats_inc(s_ib_listen_closed_stale);\n\t\t} else\n\t\tif (rds_conn_state(conn) == RDS_CONN_CONNECTING) {\n\t\t\t \n\t\t\trds_ib_stats_inc(s_ib_connect_raced);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tic = conn->c_transport_data;\n\n\trds_ib_set_protocol(conn, version);\n\trds_ib_set_flow_control(conn, be32_to_cpu(dp_cmn->ricpc_credit));\n\n\t \n\tif (dp_cmn->ricpc_ack_seq)\n\t\trds_send_drop_acked(conn, be64_to_cpu(dp_cmn->ricpc_ack_seq),\n\t\t\t\t    NULL);\n\n\tBUG_ON(cm_id->context);\n\tBUG_ON(ic->i_cm_id);\n\n\tic->i_cm_id = cm_id;\n\tcm_id->context = conn;\n\n\t \n\tdestroy = 0;\n\n\terr = rds_ib_setup_qp(conn);\n\tif (err) {\n\t\trds_ib_conn_error(conn, \"rds_ib_setup_qp failed (%d)\\n\", err);\n\t\tgoto out;\n\t}\n\n\trds_ib_cm_fill_conn_param(conn, &conn_param, &dp_rep, version,\n\t\t\t\t  event->param.conn.responder_resources,\n\t\t\t\t  event->param.conn.initiator_depth, isv6);\n\n\trdma_set_min_rnr_timer(cm_id, IB_RNR_TIMER_000_32);\n\t \n\tif (rdma_accept(cm_id, &conn_param))\n\t\trds_ib_conn_error(conn, \"rdma_accept failed\\n\");\n\nout:\n\tif (conn)\n\t\tmutex_unlock(&conn->c_cm_lock);\n\tif (err)\n\t\trdma_reject(cm_id, &err, sizeof(int),\n\t\t\t    IB_CM_REJ_CONSUMER_DEFINED);\n\treturn destroy;\n}\n\n\nint rds_ib_cm_initiate_connect(struct rdma_cm_id *cm_id, bool isv6)\n{\n\tstruct rds_connection *conn = cm_id->context;\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tstruct rdma_conn_param conn_param;\n\tunion rds_ib_conn_priv dp;\n\tint ret;\n\n\t \n\trds_ib_set_protocol(conn, RDS_PROTOCOL_4_1);\n\tic->i_flowctl = rds_ib_sysctl_flow_control;\t \n\n\tret = rds_ib_setup_qp(conn);\n\tif (ret) {\n\t\trds_ib_conn_error(conn, \"rds_ib_setup_qp failed (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\trds_ib_cm_fill_conn_param(conn, &conn_param, &dp,\n\t\t\t\t  conn->c_proposed_version,\n\t\t\t\t  UINT_MAX, UINT_MAX, isv6);\n\tret = rdma_connect_locked(cm_id, &conn_param);\n\tif (ret)\n\t\trds_ib_conn_error(conn, \"rdma_connect_locked failed (%d)\\n\",\n\t\t\t\t  ret);\n\nout:\n\t \n\tif (ret) {\n\t\tif (ic->i_cm_id == cm_id)\n\t\t\tret = 0;\n\t}\n\tic->i_active_side = true;\n\treturn ret;\n}\n\nint rds_ib_conn_path_connect(struct rds_conn_path *cp)\n{\n\tstruct rds_connection *conn = cp->cp_conn;\n\tstruct sockaddr_storage src, dest;\n\trdma_cm_event_handler handler;\n\tstruct rds_ib_connection *ic;\n\tint ret;\n\n\tic = conn->c_transport_data;\n\n\t \n\t \n#if IS_ENABLED(CONFIG_IPV6)\n\tif (conn->c_isv6)\n\t\thandler = rds6_rdma_cm_event_handler;\n\telse\n#endif\n\t\thandler = rds_rdma_cm_event_handler;\n\tic->i_cm_id = rdma_create_id(&init_net, handler, conn,\n\t\t\t\t     RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(ic->i_cm_id)) {\n\t\tret = PTR_ERR(ic->i_cm_id);\n\t\tic->i_cm_id = NULL;\n\t\trdsdebug(\"rdma_create_id() failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"created cm id %p for conn %p\\n\", ic->i_cm_id, conn);\n\n\tif (ipv6_addr_v4mapped(&conn->c_faddr)) {\n\t\tstruct sockaddr_in *sin;\n\n\t\tsin = (struct sockaddr_in *)&src;\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = conn->c_laddr.s6_addr32[3];\n\t\tsin->sin_port = 0;\n\n\t\tsin = (struct sockaddr_in *)&dest;\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = conn->c_faddr.s6_addr32[3];\n\t\tsin->sin_port = htons(RDS_PORT);\n\t} else {\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *)&src;\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_addr = conn->c_laddr;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_scope_id = conn->c_dev_if;\n\n\t\tsin6 = (struct sockaddr_in6 *)&dest;\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_addr = conn->c_faddr;\n\t\tsin6->sin6_port = htons(RDS_CM_PORT);\n\t\tsin6->sin6_scope_id = conn->c_dev_if;\n\t}\n\n\tret = rdma_resolve_addr(ic->i_cm_id, (struct sockaddr *)&src,\n\t\t\t\t(struct sockaddr *)&dest,\n\t\t\t\tRDS_RDMA_RESOLVE_TIMEOUT_MS);\n\tif (ret) {\n\t\trdsdebug(\"addr resolve failed for cm id %p: %d\\n\", ic->i_cm_id,\n\t\t\t ret);\n\t\trdma_destroy_id(ic->i_cm_id);\n\t\tic->i_cm_id = NULL;\n\t}\n\nout:\n\treturn ret;\n}\n\n \nvoid rds_ib_conn_path_shutdown(struct rds_conn_path *cp)\n{\n\tstruct rds_connection *conn = cp->cp_conn;\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tint err = 0;\n\n\trdsdebug(\"cm %p pd %p cq %p %p qp %p\\n\", ic->i_cm_id,\n\t\t ic->i_pd, ic->i_send_cq, ic->i_recv_cq,\n\t\t ic->i_cm_id ? ic->i_cm_id->qp : NULL);\n\n\tif (ic->i_cm_id) {\n\t\trdsdebug(\"disconnecting cm %p\\n\", ic->i_cm_id);\n\t\terr = rdma_disconnect(ic->i_cm_id);\n\t\tif (err) {\n\t\t\t \n\t\t\trdsdebug(\"failed to disconnect, cm: %p err %d\\n\",\n\t\t\t\tic->i_cm_id, err);\n\t\t}\n\n\t\t \n\t\trds_ib_flush_mrs();\n\n\t\t \n\t\twait_event(rds_ib_ring_empty_wait,\n\t\t\t   rds_ib_ring_empty(&ic->i_recv_ring) &&\n\t\t\t   (atomic_read(&ic->i_signaled_sends) == 0) &&\n\t\t\t   (atomic_read(&ic->i_fastreg_inuse_count) == 0) &&\n\t\t\t   (atomic_read(&ic->i_fastreg_wrs) == RDS_IB_DEFAULT_FR_WR));\n\t\ttasklet_kill(&ic->i_send_tasklet);\n\t\ttasklet_kill(&ic->i_recv_tasklet);\n\n\t\tatomic_set(&ic->i_cq_quiesce, 1);\n\n\t\t \n\t\tif (ic->i_cm_id->qp)\n\t\t\trdma_destroy_qp(ic->i_cm_id);\n\t\tif (ic->i_send_cq) {\n\t\t\tif (ic->rds_ibdev)\n\t\t\t\tibdev_put_vector(ic->rds_ibdev, ic->i_scq_vector);\n\t\t\tib_destroy_cq(ic->i_send_cq);\n\t\t}\n\n\t\tif (ic->i_recv_cq) {\n\t\t\tif (ic->rds_ibdev)\n\t\t\t\tibdev_put_vector(ic->rds_ibdev, ic->i_rcq_vector);\n\t\t\tib_destroy_cq(ic->i_recv_cq);\n\t\t}\n\n\t\tif (ic->rds_ibdev) {\n\t\t\t \n\t\t\tif (ic->i_send_hdrs) {\n\t\t\t\trds_dma_hdrs_free(ic->rds_ibdev,\n\t\t\t\t\t\t  ic->i_send_hdrs,\n\t\t\t\t\t\t  ic->i_send_hdrs_dma,\n\t\t\t\t\t\t  ic->i_send_ring.w_nr,\n\t\t\t\t\t\t  DMA_TO_DEVICE);\n\t\t\t\tic->i_send_hdrs = NULL;\n\t\t\t\tic->i_send_hdrs_dma = NULL;\n\t\t\t}\n\n\t\t\tif (ic->i_recv_hdrs) {\n\t\t\t\trds_dma_hdrs_free(ic->rds_ibdev,\n\t\t\t\t\t\t  ic->i_recv_hdrs,\n\t\t\t\t\t\t  ic->i_recv_hdrs_dma,\n\t\t\t\t\t\t  ic->i_recv_ring.w_nr,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\t\t\tic->i_recv_hdrs = NULL;\n\t\t\t\tic->i_recv_hdrs_dma = NULL;\n\t\t\t}\n\n\t\t\tif (ic->i_ack) {\n\t\t\t\trds_dma_hdr_free(ic->rds_ibdev->dev, ic->i_ack,\n\t\t\t\t\t\t ic->i_ack_dma, DMA_TO_DEVICE);\n\t\t\t\tic->i_ack = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tWARN_ON(ic->i_send_hdrs);\n\t\t\tWARN_ON(ic->i_send_hdrs_dma);\n\t\t\tWARN_ON(ic->i_recv_hdrs);\n\t\t\tWARN_ON(ic->i_recv_hdrs_dma);\n\t\t\tWARN_ON(ic->i_ack);\n\t\t}\n\n\t\tif (ic->i_sends)\n\t\t\trds_ib_send_clear_ring(ic);\n\t\tif (ic->i_recvs)\n\t\t\trds_ib_recv_clear_ring(ic);\n\n\t\trdma_destroy_id(ic->i_cm_id);\n\n\t\t \n\t\tif (ic->rds_ibdev)\n\t\t\trds_ib_remove_conn(ic->rds_ibdev, conn);\n\n\t\tic->i_cm_id = NULL;\n\t\tic->i_pd = NULL;\n\t\tic->i_send_cq = NULL;\n\t\tic->i_recv_cq = NULL;\n\t}\n\tBUG_ON(ic->rds_ibdev);\n\n\t \n\tif (ic->i_data_op) {\n\t\tstruct rds_message *rm;\n\n\t\trm = container_of(ic->i_data_op, struct rds_message, data);\n\t\trds_message_put(rm);\n\t\tic->i_data_op = NULL;\n\t}\n\n\t \n\tclear_bit(IB_ACK_IN_FLIGHT, &ic->i_ack_flags);\n#ifdef KERNEL_HAS_ATOMIC64\n\tatomic64_set(&ic->i_ack_next, 0);\n#else\n\tic->i_ack_next = 0;\n#endif\n\tic->i_ack_recv = 0;\n\n\t \n\tic->i_flowctl = 0;\n\tatomic_set(&ic->i_credits, 0);\n\n\t \n\trds_ib_ring_init(&ic->i_send_ring, ic->i_send_ring.w_nr);\n\trds_ib_ring_init(&ic->i_recv_ring, ic->i_recv_ring.w_nr);\n\n\tif (ic->i_ibinc) {\n\t\trds_inc_put(&ic->i_ibinc->ii_inc);\n\t\tic->i_ibinc = NULL;\n\t}\n\n\tvfree(ic->i_sends);\n\tic->i_sends = NULL;\n\tvfree(ic->i_recvs);\n\tic->i_recvs = NULL;\n\tic->i_active_side = false;\n}\n\nint rds_ib_conn_alloc(struct rds_connection *conn, gfp_t gfp)\n{\n\tstruct rds_ib_connection *ic;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tic = kzalloc(sizeof(struct rds_ib_connection), gfp);\n\tif (!ic)\n\t\treturn -ENOMEM;\n\n\tret = rds_ib_recv_alloc_caches(ic, gfp);\n\tif (ret) {\n\t\tkfree(ic);\n\t\treturn ret;\n\t}\n\n\tINIT_LIST_HEAD(&ic->ib_node);\n\ttasklet_init(&ic->i_send_tasklet, rds_ib_tasklet_fn_send,\n\t\t     (unsigned long)ic);\n\ttasklet_init(&ic->i_recv_tasklet, rds_ib_tasklet_fn_recv,\n\t\t     (unsigned long)ic);\n\tmutex_init(&ic->i_recv_mutex);\n#ifndef KERNEL_HAS_ATOMIC64\n\tspin_lock_init(&ic->i_ack_lock);\n#endif\n\tatomic_set(&ic->i_signaled_sends, 0);\n\tatomic_set(&ic->i_fastreg_wrs, RDS_IB_DEFAULT_FR_WR);\n\n\t \n\trds_ib_ring_init(&ic->i_send_ring, 0);\n\trds_ib_ring_init(&ic->i_recv_ring, 0);\n\n\tic->conn = conn;\n\tconn->c_transport_data = ic;\n\n\tspin_lock_irqsave(&ib_nodev_conns_lock, flags);\n\tlist_add_tail(&ic->ib_node, &ib_nodev_conns);\n\tspin_unlock_irqrestore(&ib_nodev_conns_lock, flags);\n\n\n\trdsdebug(\"conn %p conn ic %p\\n\", conn, conn->c_transport_data);\n\treturn 0;\n}\n\n \nvoid rds_ib_conn_free(void *arg)\n{\n\tstruct rds_ib_connection *ic = arg;\n\tspinlock_t\t*lock_ptr;\n\n\trdsdebug(\"ic %p\\n\", ic);\n\n\t \n\tlock_ptr = ic->rds_ibdev ? &ic->rds_ibdev->spinlock : &ib_nodev_conns_lock;\n\n\tspin_lock_irq(lock_ptr);\n\tlist_del(&ic->ib_node);\n\tspin_unlock_irq(lock_ptr);\n\n\trds_ib_recv_free_caches(ic);\n\n\tkfree(ic);\n}\n\n\n \nvoid\n__rds_ib_conn_error(struct rds_connection *conn, const char *fmt, ...)\n{\n\tva_list ap;\n\n\trds_conn_drop(conn);\n\n\tva_start(ap, fmt);\n\tvprintk(fmt, ap);\n\tva_end(ap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}