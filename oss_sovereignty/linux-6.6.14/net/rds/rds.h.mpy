{
  "module_name": "rds.h",
  "hash_id": "2233cb7ffb30254139ffc7dffe53c2aeb2e4446df107873dc2f7fcc874425732",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/rds.h",
  "human_readable_source": " \n#ifndef _RDS_RDS_H\n#define _RDS_RDS_H\n\n#include <net/sock.h>\n#include <linux/scatterlist.h>\n#include <linux/highmem.h>\n#include <rdma/rdma_cm.h>\n#include <linux/mutex.h>\n#include <linux/rds.h>\n#include <linux/rhashtable.h>\n#include <linux/refcount.h>\n#include <linux/in6.h>\n\n#include \"info.h\"\n\n \n#define RDS_PROTOCOL_3_0\t0x0300\n#define RDS_PROTOCOL_3_1\t0x0301\n#define RDS_PROTOCOL_4_0\t0x0400\n#define RDS_PROTOCOL_4_1\t0x0401\n#define RDS_PROTOCOL_VERSION\tRDS_PROTOCOL_3_1\n#define RDS_PROTOCOL_MAJOR(v)\t((v) >> 8)\n#define RDS_PROTOCOL_MINOR(v)\t((v) & 255)\n#define RDS_PROTOCOL(maj, min)\t(((maj) << 8) | min)\n#define RDS_PROTOCOL_COMPAT_VERSION\tRDS_PROTOCOL_3_1\n\n \n#define RDS_PORT\t18634\n\n#ifdef ATOMIC64_INIT\n#define KERNEL_HAS_ATOMIC64\n#endif\n#ifdef RDS_DEBUG\n#define rdsdebug(fmt, args...) pr_debug(\"%s(): \" fmt, __func__ , ##args)\n#else\n \nstatic inline __printf(1, 2)\nvoid rdsdebug(char *fmt, ...)\n{\n}\n#endif\n\n#define RDS_FRAG_SHIFT\t12\n#define RDS_FRAG_SIZE\t((unsigned int)(1 << RDS_FRAG_SHIFT))\n\n \n#define RDS_MAX_MSG_SIZE\t((unsigned int)(1 << 20))\n\n#define RDS_CONG_MAP_BYTES\t(65536 / 8)\n#define RDS_CONG_MAP_PAGES\t(PAGE_ALIGN(RDS_CONG_MAP_BYTES) / PAGE_SIZE)\n#define RDS_CONG_MAP_PAGE_BITS\t(PAGE_SIZE * 8)\n\nstruct rds_cong_map {\n\tstruct rb_node\t\tm_rb_node;\n\tstruct in6_addr\t\tm_addr;\n\twait_queue_head_t\tm_waitq;\n\tstruct list_head\tm_conn_list;\n\tunsigned long\t\tm_page_addrs[RDS_CONG_MAP_PAGES];\n};\n\n\n \nenum {\n\tRDS_CONN_DOWN = 0,\n\tRDS_CONN_CONNECTING,\n\tRDS_CONN_DISCONNECTING,\n\tRDS_CONN_UP,\n\tRDS_CONN_RESETTING,\n\tRDS_CONN_ERROR,\n};\n\n \n#define RDS_LL_SEND_FULL\t0\n#define RDS_RECONNECT_PENDING\t1\n#define RDS_IN_XMIT\t\t2\n#define RDS_RECV_REFILL\t\t3\n#define\tRDS_DESTROY_PENDING\t4\n\n \n#define\tRDS_MPATH_WORKERS\t8\n#define\tRDS_MPATH_HASH(rs, n) (jhash_1word((rs)->rs_bound_port, \\\n\t\t\t       (rs)->rs_hash_initval) & ((n) - 1))\n\n#define IS_CANONICAL(laddr, faddr) (htonl(laddr) < htonl(faddr))\n\n \nstruct rds_conn_path {\n\tstruct rds_connection\t*cp_conn;\n\tstruct rds_message\t*cp_xmit_rm;\n\tunsigned long\t\tcp_xmit_sg;\n\tunsigned int\t\tcp_xmit_hdr_off;\n\tunsigned int\t\tcp_xmit_data_off;\n\tunsigned int\t\tcp_xmit_atomic_sent;\n\tunsigned int\t\tcp_xmit_rdma_sent;\n\tunsigned int\t\tcp_xmit_data_sent;\n\n\tspinlock_t\t\tcp_lock;\t\t \n\tu64\t\t\tcp_next_tx_seq;\n\tstruct list_head\tcp_send_queue;\n\tstruct list_head\tcp_retrans;\n\n\tu64\t\t\tcp_next_rx_seq;\n\n\tvoid\t\t\t*cp_transport_data;\n\n\tatomic_t\t\tcp_state;\n\tunsigned long\t\tcp_send_gen;\n\tunsigned long\t\tcp_flags;\n\tunsigned long\t\tcp_reconnect_jiffies;\n\tstruct delayed_work\tcp_send_w;\n\tstruct delayed_work\tcp_recv_w;\n\tstruct delayed_work\tcp_conn_w;\n\tstruct work_struct\tcp_down_w;\n\tstruct mutex\t\tcp_cm_lock;\t \n\twait_queue_head_t\tcp_waitq;\n\n\tunsigned int\t\tcp_unacked_packets;\n\tunsigned int\t\tcp_unacked_bytes;\n\tunsigned int\t\tcp_index;\n};\n\n \nstruct rds_connection {\n\tstruct hlist_node\tc_hash_node;\n\tstruct in6_addr\t\tc_laddr;\n\tstruct in6_addr\t\tc_faddr;\n\tint\t\t\tc_dev_if;  \n\tint\t\t\tc_bound_if;  \n\tunsigned int\t\tc_loopback:1,\n\t\t\t\tc_isv6:1,\n\t\t\t\tc_ping_triggered:1,\n\t\t\t\tc_pad_to_32:29;\n\tint\t\t\tc_npaths;\n\tstruct rds_connection\t*c_passive;\n\tstruct rds_transport\t*c_trans;\n\n\tstruct rds_cong_map\t*c_lcong;\n\tstruct rds_cong_map\t*c_fcong;\n\n\t \n\tunsigned int\t\tc_proposed_version;\n\tunsigned int\t\tc_version;\n\tpossible_net_t\t\tc_net;\n\n\t \n\tu8\t\t\tc_tos;\n\n\tstruct list_head\tc_map_item;\n\tunsigned long\t\tc_map_queued;\n\n\tstruct rds_conn_path\t*c_path;\n\twait_queue_head_t\tc_hs_waitq;  \n\n\tu32\t\t\tc_my_gen_num;\n\tu32\t\t\tc_peer_gen_num;\n};\n\nstatic inline\nstruct net *rds_conn_net(struct rds_connection *conn)\n{\n\treturn read_pnet(&conn->c_net);\n}\n\nstatic inline\nvoid rds_conn_net_set(struct rds_connection *conn, struct net *net)\n{\n\twrite_pnet(&conn->c_net, net);\n}\n\n#define RDS_FLAG_CONG_BITMAP\t0x01\n#define RDS_FLAG_ACK_REQUIRED\t0x02\n#define RDS_FLAG_RETRANSMITTED\t0x04\n#define RDS_MAX_ADV_CREDIT\t255\n\n \n#define RDS_FLAG_PROBE_PORT\t1\n#define\tRDS_HS_PROBE(sport, dport) \\\n\t\t((sport == RDS_FLAG_PROBE_PORT && dport == 0) || \\\n\t\t (sport == 0 && dport == RDS_FLAG_PROBE_PORT))\n \n#define RDS_HEADER_EXT_SPACE\t16\n\nstruct rds_header {\n\t__be64\th_sequence;\n\t__be64\th_ack;\n\t__be32\th_len;\n\t__be16\th_sport;\n\t__be16\th_dport;\n\tu8\th_flags;\n\tu8\th_credit;\n\tu8\th_padding[4];\n\t__sum16\th_csum;\n\n\tu8\th_exthdr[RDS_HEADER_EXT_SPACE];\n};\n\n \n#define RDS_EXTHDR_NONE\t\t0\n\n \n#define RDS_EXTHDR_VERSION\t1\nstruct rds_ext_header_version {\n\t__be32\t\t\th_version;\n};\n\n \n#define RDS_EXTHDR_RDMA\t\t2\nstruct rds_ext_header_rdma {\n\t__be32\t\t\th_rdma_rkey;\n};\n\n \n#define RDS_EXTHDR_RDMA_DEST\t3\nstruct rds_ext_header_rdma_dest {\n\t__be32\t\t\th_rdma_rkey;\n\t__be32\t\t\th_rdma_offset;\n};\n\n \n#define RDS_EXTHDR_NPATHS\t5\n#define RDS_EXTHDR_GEN_NUM\t6\n\n#define __RDS_EXTHDR_MAX\t16  \n#define RDS_RX_MAX_TRACES\t(RDS_MSG_RX_DGRAM_TRACE_MAX + 1)\n#define\tRDS_MSG_RX_HDR\t\t0\n#define\tRDS_MSG_RX_START\t1\n#define\tRDS_MSG_RX_END\t\t2\n#define\tRDS_MSG_RX_CMSG\t\t3\n\n \nstruct rds_inc_usercopy {\n\trds_rdma_cookie_t\trdma_cookie;\n\tktime_t\t\t\trx_tstamp;\n};\n\nstruct rds_incoming {\n\trefcount_t\t\ti_refcount;\n\tstruct list_head\ti_item;\n\tstruct rds_connection\t*i_conn;\n\tstruct rds_conn_path\t*i_conn_path;\n\tstruct rds_header\ti_hdr;\n\tunsigned long\t\ti_rx_jiffies;\n\tstruct in6_addr\t\ti_saddr;\n\n\tstruct rds_inc_usercopy i_usercopy;\n\tu64\t\t\ti_rx_lat_trace[RDS_RX_MAX_TRACES];\n};\n\nstruct rds_mr {\n\tstruct rb_node\t\tr_rb_node;\n\tstruct kref\t\tr_kref;\n\tu32\t\t\tr_key;\n\n\t \n\tunsigned int\t\tr_use_once:1;\n\tunsigned int\t\tr_invalidate:1;\n\tunsigned int\t\tr_write:1;\n\n\tstruct rds_sock\t\t*r_sock;  \n\tstruct rds_transport\t*r_trans;\n\tvoid\t\t\t*r_trans_private;\n};\n\nstatic inline rds_rdma_cookie_t rds_rdma_make_cookie(u32 r_key, u32 offset)\n{\n\treturn r_key | (((u64) offset) << 32);\n}\n\nstatic inline u32 rds_rdma_cookie_key(rds_rdma_cookie_t cookie)\n{\n\treturn cookie;\n}\n\nstatic inline u32 rds_rdma_cookie_offset(rds_rdma_cookie_t cookie)\n{\n\treturn cookie >> 32;\n}\n\n \n#define RDS_ATOMIC_TYPE_CSWP\t\t0\n#define RDS_ATOMIC_TYPE_FADD\t\t1\n\n \n#define RDS_MSG_ON_SOCK\t\t1\n#define RDS_MSG_ON_CONN\t\t2\n#define RDS_MSG_HAS_ACK_SEQ\t3\n#define RDS_MSG_ACK_REQUIRED\t4\n#define RDS_MSG_RETRANSMITTED\t5\n#define RDS_MSG_MAPPED\t\t6\n#define RDS_MSG_PAGEVEC\t\t7\n#define RDS_MSG_FLUSH\t\t8\n\nstruct rds_znotifier {\n\tstruct mmpin\t\tz_mmp;\n\tu32\t\t\tz_cookie;\n};\n\nstruct rds_msg_zcopy_info {\n\tstruct list_head rs_zcookie_next;\n\tunion {\n\t\tstruct rds_znotifier znotif;\n\t\tstruct rds_zcopy_cookies zcookies;\n\t};\n};\n\nstruct rds_msg_zcopy_queue {\n\tstruct list_head zcookie_head;\n\tspinlock_t lock;  \n};\n\nstatic inline void rds_message_zcopy_queue_init(struct rds_msg_zcopy_queue *q)\n{\n\tspin_lock_init(&q->lock);\n\tINIT_LIST_HEAD(&q->zcookie_head);\n}\n\nstruct rds_iov_vector {\n\tstruct rds_iovec *iov;\n\tint               len;\n};\n\nstruct rds_iov_vector_arr {\n\tstruct rds_iov_vector *vec;\n\tint                    len;\n\tint                    indx;\n\tint                    incr;\n};\n\nstruct rds_message {\n\trefcount_t\t\tm_refcount;\n\tstruct list_head\tm_sock_item;\n\tstruct list_head\tm_conn_item;\n\tstruct rds_incoming\tm_inc;\n\tu64\t\t\tm_ack_seq;\n\tstruct in6_addr\t\tm_daddr;\n\tunsigned long\t\tm_flags;\n\n\t \n\tspinlock_t\t\tm_rs_lock;\n\twait_queue_head_t\tm_flush_wait;\n\n\tstruct rds_sock\t\t*m_rs;\n\n\t \n\trds_rdma_cookie_t\tm_rdma_cookie;\n\n\tunsigned int\t\tm_used_sgs;\n\tunsigned int\t\tm_total_sgs;\n\n\tvoid\t\t\t*m_final_op;\n\n\tstruct {\n\t\tstruct rm_atomic_op {\n\t\t\tint\t\t\top_type;\n\t\t\tunion {\n\t\t\t\tstruct {\n\t\t\t\t\tuint64_t\tcompare;\n\t\t\t\t\tuint64_t\tswap;\n\t\t\t\t\tuint64_t\tcompare_mask;\n\t\t\t\t\tuint64_t\tswap_mask;\n\t\t\t\t} op_m_cswp;\n\t\t\t\tstruct {\n\t\t\t\t\tuint64_t\tadd;\n\t\t\t\t\tuint64_t\tnocarry_mask;\n\t\t\t\t} op_m_fadd;\n\t\t\t};\n\n\t\t\tu32\t\t\top_rkey;\n\t\t\tu64\t\t\top_remote_addr;\n\t\t\tunsigned int\t\top_notify:1;\n\t\t\tunsigned int\t\top_recverr:1;\n\t\t\tunsigned int\t\top_mapped:1;\n\t\t\tunsigned int\t\top_silent:1;\n\t\t\tunsigned int\t\top_active:1;\n\t\t\tstruct scatterlist\t*op_sg;\n\t\t\tstruct rds_notifier\t*op_notifier;\n\n\t\t\tstruct rds_mr\t\t*op_rdma_mr;\n\t\t} atomic;\n\t\tstruct rm_rdma_op {\n\t\t\tu32\t\t\top_rkey;\n\t\t\tu64\t\t\top_remote_addr;\n\t\t\tunsigned int\t\top_write:1;\n\t\t\tunsigned int\t\top_fence:1;\n\t\t\tunsigned int\t\top_notify:1;\n\t\t\tunsigned int\t\top_recverr:1;\n\t\t\tunsigned int\t\top_mapped:1;\n\t\t\tunsigned int\t\top_silent:1;\n\t\t\tunsigned int\t\top_active:1;\n\t\t\tunsigned int\t\top_bytes;\n\t\t\tunsigned int\t\top_nents;\n\t\t\tunsigned int\t\top_count;\n\t\t\tstruct scatterlist\t*op_sg;\n\t\t\tstruct rds_notifier\t*op_notifier;\n\n\t\t\tstruct rds_mr\t\t*op_rdma_mr;\n\n\t\t\tu64\t\t\top_odp_addr;\n\t\t\tstruct rds_mr\t\t*op_odp_mr;\n\t\t} rdma;\n\t\tstruct rm_data_op {\n\t\t\tunsigned int\t\top_active:1;\n\t\t\tunsigned int\t\top_nents;\n\t\t\tunsigned int\t\top_count;\n\t\t\tunsigned int\t\top_dmasg;\n\t\t\tunsigned int\t\top_dmaoff;\n\t\t\tstruct rds_znotifier\t*op_mmp_znotifier;\n\t\t\tstruct scatterlist\t*op_sg;\n\t\t} data;\n\t};\n\n\tstruct rds_conn_path *m_conn_path;\n};\n\n \nstruct rds_notifier {\n\tstruct list_head\tn_list;\n\tuint64_t\t\tn_user_token;\n\tint\t\t\tn_status;\n};\n\n \n#define\tRDS_TRANS_LOOP\t3\n\n \n\nstruct rds_transport {\n\tchar\t\t\tt_name[TRANSNAMSIZ];\n\tstruct list_head\tt_item;\n\tstruct module\t\t*t_owner;\n\tunsigned int\t\tt_prefer_loopback:1,\n\t\t\t\tt_mp_capable:1;\n\tunsigned int\t\tt_type;\n\n\tint (*laddr_check)(struct net *net, const struct in6_addr *addr,\n\t\t\t   __u32 scope_id);\n\tint (*conn_alloc)(struct rds_connection *conn, gfp_t gfp);\n\tvoid (*conn_free)(void *data);\n\tint (*conn_path_connect)(struct rds_conn_path *cp);\n\tvoid (*conn_path_shutdown)(struct rds_conn_path *conn);\n\tvoid (*xmit_path_prepare)(struct rds_conn_path *cp);\n\tvoid (*xmit_path_complete)(struct rds_conn_path *cp);\n\tint (*xmit)(struct rds_connection *conn, struct rds_message *rm,\n\t\t    unsigned int hdr_off, unsigned int sg, unsigned int off);\n\tint (*xmit_rdma)(struct rds_connection *conn, struct rm_rdma_op *op);\n\tint (*xmit_atomic)(struct rds_connection *conn, struct rm_atomic_op *op);\n\tint (*recv_path)(struct rds_conn_path *cp);\n\tint (*inc_copy_to_user)(struct rds_incoming *inc, struct iov_iter *to);\n\tvoid (*inc_free)(struct rds_incoming *inc);\n\n\tint (*cm_handle_connect)(struct rdma_cm_id *cm_id,\n\t\t\t\t struct rdma_cm_event *event, bool isv6);\n\tint (*cm_initiate_connect)(struct rdma_cm_id *cm_id, bool isv6);\n\tvoid (*cm_connect_complete)(struct rds_connection *conn,\n\t\t\t\t    struct rdma_cm_event *event);\n\n\tunsigned int (*stats_info_copy)(struct rds_info_iterator *iter,\n\t\t\t\t\tunsigned int avail);\n\tvoid (*exit)(void);\n\tvoid *(*get_mr)(struct scatterlist *sg, unsigned long nr_sg,\n\t\t\tstruct rds_sock *rs, u32 *key_ret,\n\t\t\tstruct rds_connection *conn,\n\t\t\tu64 start, u64 length, int need_odp);\n\tvoid (*sync_mr)(void *trans_private, int direction);\n\tvoid (*free_mr)(void *trans_private, int invalidate);\n\tvoid (*flush_mrs)(void);\n\tbool (*t_unloading)(struct rds_connection *conn);\n\tu8 (*get_tos_map)(u8 tos);\n};\n\n \n#define RDS_BOUND_KEY_LEN \\\n\t(sizeof(struct in6_addr) + sizeof(__u32) + sizeof(__be16))\n\nstruct rds_sock {\n\tstruct sock\t\trs_sk;\n\n\tu64\t\t\trs_user_addr;\n\tu64\t\t\trs_user_bytes;\n\n\t \n\tstruct rhash_head\trs_bound_node;\n\tu8\t\t\trs_bound_key[RDS_BOUND_KEY_LEN];\n\tstruct sockaddr_in6\trs_bound_sin6;\n#define rs_bound_addr\t\trs_bound_sin6.sin6_addr\n#define rs_bound_addr_v4\trs_bound_sin6.sin6_addr.s6_addr32[3]\n#define rs_bound_port\t\trs_bound_sin6.sin6_port\n#define rs_bound_scope_id\trs_bound_sin6.sin6_scope_id\n\tstruct in6_addr\t\trs_conn_addr;\n#define rs_conn_addr_v4\t\trs_conn_addr.s6_addr32[3]\n\t__be16\t\t\trs_conn_port;\n\tstruct rds_transport    *rs_transport;\n\n\t \n\tstruct rds_connection\t*rs_conn;\n\n\t \n\tint\t\t\trs_congested;\n\t \n\tint\t\t\trs_seen_congestion;\n\n\t \n\tspinlock_t\t\trs_lock;\n\tstruct list_head\trs_send_queue;\n\tu32\t\t\trs_snd_bytes;\n\tint\t\t\trs_rcv_bytes;\n\tstruct list_head\trs_notify_queue;\t \n\n\t \n\tuint64_t\t\trs_cong_mask;\n\tuint64_t\t\trs_cong_notify;\n\tstruct list_head\trs_cong_list;\n\tunsigned long\t\trs_cong_track;\n\n\t \n\trwlock_t\t\trs_recv_lock;\n\tstruct list_head\trs_recv_queue;\n\n\t \n\tstruct list_head\trs_item;\n\n\t \n\tspinlock_t\t\trs_rdma_lock;\n\tstruct rb_root\t\trs_rdma_keys;\n\n\t \n\tunsigned char\t\trs_recverr,\n\t\t\t\trs_cong_monitor;\n\tu32\t\t\trs_hash_initval;\n\n\t \n\tu8\t\t\trs_rx_traces;\n\tu8\t\t\trs_rx_trace[RDS_MSG_RX_DGRAM_TRACE_MAX];\n\tstruct rds_msg_zcopy_queue rs_zcookie_queue;\n\tu8\t\t\trs_tos;\n};\n\nstatic inline struct rds_sock *rds_sk_to_rs(const struct sock *sk)\n{\n\treturn container_of(sk, struct rds_sock, rs_sk);\n}\nstatic inline struct sock *rds_rs_to_sk(struct rds_sock *rs)\n{\n\treturn &rs->rs_sk;\n}\n\n \nstatic inline int rds_sk_sndbuf(struct rds_sock *rs)\n{\n\treturn rds_rs_to_sk(rs)->sk_sndbuf / 2;\n}\nstatic inline int rds_sk_rcvbuf(struct rds_sock *rs)\n{\n\treturn rds_rs_to_sk(rs)->sk_rcvbuf / 2;\n}\n\nstruct rds_statistics {\n\tuint64_t\ts_conn_reset;\n\tuint64_t\ts_recv_drop_bad_checksum;\n\tuint64_t\ts_recv_drop_old_seq;\n\tuint64_t\ts_recv_drop_no_sock;\n\tuint64_t\ts_recv_drop_dead_sock;\n\tuint64_t\ts_recv_deliver_raced;\n\tuint64_t\ts_recv_delivered;\n\tuint64_t\ts_recv_queued;\n\tuint64_t\ts_recv_immediate_retry;\n\tuint64_t\ts_recv_delayed_retry;\n\tuint64_t\ts_recv_ack_required;\n\tuint64_t\ts_recv_rdma_bytes;\n\tuint64_t\ts_recv_ping;\n\tuint64_t\ts_send_queue_empty;\n\tuint64_t\ts_send_queue_full;\n\tuint64_t\ts_send_lock_contention;\n\tuint64_t\ts_send_lock_queue_raced;\n\tuint64_t\ts_send_immediate_retry;\n\tuint64_t\ts_send_delayed_retry;\n\tuint64_t\ts_send_drop_acked;\n\tuint64_t\ts_send_ack_required;\n\tuint64_t\ts_send_queued;\n\tuint64_t\ts_send_rdma;\n\tuint64_t\ts_send_rdma_bytes;\n\tuint64_t\ts_send_pong;\n\tuint64_t\ts_page_remainder_hit;\n\tuint64_t\ts_page_remainder_miss;\n\tuint64_t\ts_copy_to_user;\n\tuint64_t\ts_copy_from_user;\n\tuint64_t\ts_cong_update_queued;\n\tuint64_t\ts_cong_update_received;\n\tuint64_t\ts_cong_send_error;\n\tuint64_t\ts_cong_send_blocked;\n\tuint64_t\ts_recv_bytes_added_to_socket;\n\tuint64_t\ts_recv_bytes_removed_from_socket;\n\tuint64_t\ts_send_stuck_rm;\n};\n\n \nvoid rds_sock_addref(struct rds_sock *rs);\nvoid rds_sock_put(struct rds_sock *rs);\nvoid rds_wake_sk_sleep(struct rds_sock *rs);\nstatic inline void __rds_wake_sk_sleep(struct sock *sk)\n{\n\twait_queue_head_t *waitq = sk_sleep(sk);\n\n\tif (!sock_flag(sk, SOCK_DEAD) && waitq)\n\t\twake_up(waitq);\n}\nextern wait_queue_head_t rds_poll_waitq;\n\n\n \nint rds_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len);\nvoid rds_remove_bound(struct rds_sock *rs);\nstruct rds_sock *rds_find_bound(const struct in6_addr *addr, __be16 port,\n\t\t\t\t__u32 scope_id);\nint rds_bind_lock_init(void);\nvoid rds_bind_lock_destroy(void);\n\n \nint rds_cong_get_maps(struct rds_connection *conn);\nvoid rds_cong_add_conn(struct rds_connection *conn);\nvoid rds_cong_remove_conn(struct rds_connection *conn);\nvoid rds_cong_set_bit(struct rds_cong_map *map, __be16 port);\nvoid rds_cong_clear_bit(struct rds_cong_map *map, __be16 port);\nint rds_cong_wait(struct rds_cong_map *map, __be16 port, int nonblock, struct rds_sock *rs);\nvoid rds_cong_queue_updates(struct rds_cong_map *map);\nvoid rds_cong_map_updated(struct rds_cong_map *map, uint64_t);\nint rds_cong_updated_since(unsigned long *recent);\nvoid rds_cong_add_socket(struct rds_sock *);\nvoid rds_cong_remove_socket(struct rds_sock *);\nvoid rds_cong_exit(void);\nstruct rds_message *rds_cong_update_alloc(struct rds_connection *conn);\n\n \nextern u32 rds_gen_num;\nint rds_conn_init(void);\nvoid rds_conn_exit(void);\nstruct rds_connection *rds_conn_create(struct net *net,\n\t\t\t\t       const struct in6_addr *laddr,\n\t\t\t\t       const struct in6_addr *faddr,\n\t\t\t\t       struct rds_transport *trans,\n\t\t\t\t       u8 tos, gfp_t gfp,\n\t\t\t\t       int dev_if);\nstruct rds_connection *rds_conn_create_outgoing(struct net *net,\n\t\t\t\t\t\tconst struct in6_addr *laddr,\n\t\t\t\t\t\tconst struct in6_addr *faddr,\n\t\t\t\t\t\tstruct rds_transport *trans,\n\t\t\t\t\t\tu8 tos, gfp_t gfp, int dev_if);\nvoid rds_conn_shutdown(struct rds_conn_path *cpath);\nvoid rds_conn_destroy(struct rds_connection *conn);\nvoid rds_conn_drop(struct rds_connection *conn);\nvoid rds_conn_path_drop(struct rds_conn_path *cpath, bool destroy);\nvoid rds_conn_connect_if_down(struct rds_connection *conn);\nvoid rds_conn_path_connect_if_down(struct rds_conn_path *cp);\nvoid rds_check_all_paths(struct rds_connection *conn);\nvoid rds_for_each_conn_info(struct socket *sock, unsigned int len,\n\t\t\t  struct rds_info_iterator *iter,\n\t\t\t  struct rds_info_lengths *lens,\n\t\t\t  int (*visitor)(struct rds_connection *, void *),\n\t\t\t  u64 *buffer,\n\t\t\t  size_t item_len);\n\n__printf(2, 3)\nvoid __rds_conn_path_error(struct rds_conn_path *cp, const char *, ...);\n#define rds_conn_path_error(cp, fmt...) \\\n\t__rds_conn_path_error(cp, KERN_WARNING \"RDS: \" fmt)\n\nstatic inline int\nrds_conn_path_transition(struct rds_conn_path *cp, int old, int new)\n{\n\treturn atomic_cmpxchg(&cp->cp_state, old, new) == old;\n}\n\nstatic inline int\nrds_conn_transition(struct rds_connection *conn, int old, int new)\n{\n\tWARN_ON(conn->c_trans->t_mp_capable);\n\treturn rds_conn_path_transition(&conn->c_path[0], old, new);\n}\n\nstatic inline int\nrds_conn_path_state(struct rds_conn_path *cp)\n{\n\treturn atomic_read(&cp->cp_state);\n}\n\nstatic inline int\nrds_conn_state(struct rds_connection *conn)\n{\n\tWARN_ON(conn->c_trans->t_mp_capable);\n\treturn rds_conn_path_state(&conn->c_path[0]);\n}\n\nstatic inline int\nrds_conn_path_up(struct rds_conn_path *cp)\n{\n\treturn atomic_read(&cp->cp_state) == RDS_CONN_UP;\n}\n\nstatic inline int\nrds_conn_path_down(struct rds_conn_path *cp)\n{\n\treturn atomic_read(&cp->cp_state) == RDS_CONN_DOWN;\n}\n\nstatic inline int\nrds_conn_up(struct rds_connection *conn)\n{\n\tWARN_ON(conn->c_trans->t_mp_capable);\n\treturn rds_conn_path_up(&conn->c_path[0]);\n}\n\nstatic inline int\nrds_conn_path_connecting(struct rds_conn_path *cp)\n{\n\treturn atomic_read(&cp->cp_state) == RDS_CONN_CONNECTING;\n}\n\nstatic inline int\nrds_conn_connecting(struct rds_connection *conn)\n{\n\tWARN_ON(conn->c_trans->t_mp_capable);\n\treturn rds_conn_path_connecting(&conn->c_path[0]);\n}\n\n \nstruct rds_message *rds_message_alloc(unsigned int nents, gfp_t gfp);\nstruct scatterlist *rds_message_alloc_sgs(struct rds_message *rm, int nents);\nint rds_message_copy_from_user(struct rds_message *rm, struct iov_iter *from,\n\t\t\t       bool zcopy);\nstruct rds_message *rds_message_map_pages(unsigned long *page_addrs, unsigned int total_len);\nvoid rds_message_populate_header(struct rds_header *hdr, __be16 sport,\n\t\t\t\t __be16 dport, u64 seq);\nint rds_message_add_extension(struct rds_header *hdr,\n\t\t\t      unsigned int type, const void *data, unsigned int len);\nint rds_message_next_extension(struct rds_header *hdr,\n\t\t\t       unsigned int *pos, void *buf, unsigned int *buflen);\nint rds_message_add_rdma_dest_extension(struct rds_header *hdr, u32 r_key, u32 offset);\nint rds_message_inc_copy_to_user(struct rds_incoming *inc, struct iov_iter *to);\nvoid rds_message_addref(struct rds_message *rm);\nvoid rds_message_put(struct rds_message *rm);\nvoid rds_message_wait(struct rds_message *rm);\nvoid rds_message_unmapped(struct rds_message *rm);\nvoid rds_notify_msg_zcopy_purge(struct rds_msg_zcopy_queue *info);\n\nstatic inline void rds_message_make_checksum(struct rds_header *hdr)\n{\n\thdr->h_csum = 0;\n\thdr->h_csum = ip_fast_csum((void *) hdr, sizeof(*hdr) >> 2);\n}\n\nstatic inline int rds_message_verify_checksum(const struct rds_header *hdr)\n{\n\treturn !hdr->h_csum || ip_fast_csum((void *) hdr, sizeof(*hdr) >> 2) == 0;\n}\n\n\n \nint rds_page_remainder_alloc(struct scatterlist *scat, unsigned long bytes,\n\t\t\t     gfp_t gfp);\nvoid rds_page_exit(void);\n\n \nvoid rds_inc_init(struct rds_incoming *inc, struct rds_connection *conn,\n\t\t  struct in6_addr *saddr);\nvoid rds_inc_path_init(struct rds_incoming *inc, struct rds_conn_path *conn,\n\t\t       struct in6_addr *saddr);\nvoid rds_inc_put(struct rds_incoming *inc);\nvoid rds_recv_incoming(struct rds_connection *conn, struct in6_addr *saddr,\n\t\t       struct in6_addr *daddr,\n\t\t       struct rds_incoming *inc, gfp_t gfp);\nint rds_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\tint msg_flags);\nvoid rds_clear_recv_queue(struct rds_sock *rs);\nint rds_notify_queue_get(struct rds_sock *rs, struct msghdr *msg);\nvoid rds_inc_info_copy(struct rds_incoming *inc,\n\t\t       struct rds_info_iterator *iter,\n\t\t       __be32 saddr, __be32 daddr, int flip);\nvoid rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip);\n\n \nint rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len);\nvoid rds_send_path_reset(struct rds_conn_path *conn);\nint rds_send_xmit(struct rds_conn_path *cp);\nstruct sockaddr_in;\nvoid rds_send_drop_to(struct rds_sock *rs, struct sockaddr_in6 *dest);\ntypedef int (*is_acked_func)(struct rds_message *rm, uint64_t ack);\nvoid rds_send_drop_acked(struct rds_connection *conn, u64 ack,\n\t\t\t is_acked_func is_acked);\nvoid rds_send_path_drop_acked(struct rds_conn_path *cp, u64 ack,\n\t\t\t      is_acked_func is_acked);\nvoid rds_send_ping(struct rds_connection *conn, int cp_index);\nint rds_send_pong(struct rds_conn_path *cp, __be16 dport);\n\n \nvoid rds_rdma_unuse(struct rds_sock *rs, u32 r_key, int force);\nint rds_get_mr(struct rds_sock *rs, sockptr_t optval, int optlen);\nint rds_get_mr_for_dest(struct rds_sock *rs, sockptr_t optval, int optlen);\nint rds_free_mr(struct rds_sock *rs, sockptr_t optval, int optlen);\nvoid rds_rdma_drop_keys(struct rds_sock *rs);\nint rds_rdma_extra_size(struct rds_rdma_args *args,\n\t\t\tstruct rds_iov_vector *iov);\nint rds_cmsg_rdma_dest(struct rds_sock *rs, struct rds_message *rm,\n\t\t\t  struct cmsghdr *cmsg);\nint rds_cmsg_rdma_args(struct rds_sock *rs, struct rds_message *rm,\n\t\t\t  struct cmsghdr *cmsg,\n\t\t\t  struct rds_iov_vector *vec);\nint rds_cmsg_rdma_map(struct rds_sock *rs, struct rds_message *rm,\n\t\t\t  struct cmsghdr *cmsg);\nvoid rds_rdma_free_op(struct rm_rdma_op *ro);\nvoid rds_atomic_free_op(struct rm_atomic_op *ao);\nvoid rds_rdma_send_complete(struct rds_message *rm, int wc_status);\nvoid rds_atomic_send_complete(struct rds_message *rm, int wc_status);\nint rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n\t\t    struct cmsghdr *cmsg);\n\nvoid __rds_put_mr_final(struct kref *kref);\n\nstatic inline bool rds_destroy_pending(struct rds_connection *conn)\n{\n\treturn !check_net(rds_conn_net(conn)) ||\n\t       (conn->c_trans->t_unloading && conn->c_trans->t_unloading(conn));\n}\n\nenum {\n\tODP_NOT_NEEDED,\n\tODP_ZEROBASED,\n\tODP_VIRTUAL\n};\n\n \nDECLARE_PER_CPU_SHARED_ALIGNED(struct rds_statistics, rds_stats);\n#define rds_stats_inc_which(which, member) do {\t\t\\\n\tper_cpu(which, get_cpu()).member++;\t\t\\\n\tput_cpu();\t\t\t\t\t\\\n} while (0)\n#define rds_stats_inc(member) rds_stats_inc_which(rds_stats, member)\n#define rds_stats_add_which(which, member, count) do {\t\t\\\n\tper_cpu(which, get_cpu()).member += count;\t\\\n\tput_cpu();\t\t\t\t\t\\\n} while (0)\n#define rds_stats_add(member, count) rds_stats_add_which(rds_stats, member, count)\nint rds_stats_init(void);\nvoid rds_stats_exit(void);\nvoid rds_stats_info_copy(struct rds_info_iterator *iter,\n\t\t\t uint64_t *values, const char *const *names,\n\t\t\t size_t nr);\n\n \nint rds_sysctl_init(void);\nvoid rds_sysctl_exit(void);\nextern unsigned long rds_sysctl_sndbuf_min;\nextern unsigned long rds_sysctl_sndbuf_default;\nextern unsigned long rds_sysctl_sndbuf_max;\nextern unsigned long rds_sysctl_reconnect_min_jiffies;\nextern unsigned long rds_sysctl_reconnect_max_jiffies;\nextern unsigned int  rds_sysctl_max_unacked_packets;\nextern unsigned int  rds_sysctl_max_unacked_bytes;\nextern unsigned int  rds_sysctl_ping_enable;\nextern unsigned long rds_sysctl_trace_flags;\nextern unsigned int  rds_sysctl_trace_level;\n\n \nint rds_threads_init(void);\nvoid rds_threads_exit(void);\nextern struct workqueue_struct *rds_wq;\nvoid rds_queue_reconnect(struct rds_conn_path *cp);\nvoid rds_connect_worker(struct work_struct *);\nvoid rds_shutdown_worker(struct work_struct *);\nvoid rds_send_worker(struct work_struct *);\nvoid rds_recv_worker(struct work_struct *);\nvoid rds_connect_path_complete(struct rds_conn_path *conn, int curr);\nvoid rds_connect_complete(struct rds_connection *conn);\nint rds_addr_cmp(const struct in6_addr *a1, const struct in6_addr *a2);\n\n \nvoid rds_trans_register(struct rds_transport *trans);\nvoid rds_trans_unregister(struct rds_transport *trans);\nstruct rds_transport *rds_trans_get_preferred(struct net *net,\n\t\t\t\t\t      const struct in6_addr *addr,\n\t\t\t\t\t      __u32 scope_id);\nvoid rds_trans_put(struct rds_transport *trans);\nunsigned int rds_trans_stats_info_copy(struct rds_info_iterator *iter,\n\t\t\t\t       unsigned int avail);\nstruct rds_transport *rds_trans_get(int t_type);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}