{
  "module_name": "tcp_send.c",
  "hash_id": "a39329d41a3fe4fd4469de398a42f97ff1d09085dd435b23b9b9981305b52ee2",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/tcp_send.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/in.h>\n#include <net/tcp.h>\n\n#include \"rds_single_path.h\"\n#include \"rds.h\"\n#include \"tcp.h\"\n\nvoid rds_tcp_xmit_path_prepare(struct rds_conn_path *cp)\n{\n\tstruct rds_tcp_connection *tc = cp->cp_transport_data;\n\n\ttcp_sock_set_cork(tc->t_sock->sk, true);\n}\n\nvoid rds_tcp_xmit_path_complete(struct rds_conn_path *cp)\n{\n\tstruct rds_tcp_connection *tc = cp->cp_transport_data;\n\n\ttcp_sock_set_cork(tc->t_sock->sk, false);\n}\n\n \nstatic int rds_tcp_sendmsg(struct socket *sock, void *data, unsigned int len)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL,\n\t};\n\n\treturn kernel_sendmsg(sock, &msg, &vec, 1, vec.iov_len);\n}\n\n \nint rds_tcp_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t unsigned int hdr_off, unsigned int sg, unsigned int off)\n{\n\tstruct rds_conn_path *cp = rm->m_inc.i_conn_path;\n\tstruct rds_tcp_connection *tc = cp->cp_transport_data;\n\tstruct msghdr msg = {};\n\tstruct bio_vec bvec;\n\tint done = 0;\n\tint ret = 0;\n\n\tif (hdr_off == 0) {\n\t\t \n\t\ttc->t_last_sent_nxt = rds_tcp_write_seq(tc);\n\t\trm->m_ack_seq = tc->t_last_sent_nxt +\n\t\t\t\tsizeof(struct rds_header) +\n\t\t\t\tbe32_to_cpu(rm->m_inc.i_hdr.h_len) - 1;\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(RDS_MSG_HAS_ACK_SEQ, &rm->m_flags);\n\t\ttc->t_last_expected_una = rm->m_ack_seq + 1;\n\n\t\tif (test_bit(RDS_MSG_RETRANSMITTED, &rm->m_flags))\n\t\t\trm->m_inc.i_hdr.h_flags |= RDS_FLAG_RETRANSMITTED;\n\n\t\trdsdebug(\"rm %p tcp nxt %u ack_seq %llu\\n\",\n\t\t\t rm, rds_tcp_write_seq(tc),\n\t\t\t (unsigned long long)rm->m_ack_seq);\n\t}\n\n\tif (hdr_off < sizeof(struct rds_header)) {\n\t\t \n\t\tset_bit(SOCK_NOSPACE, &tc->t_sock->sk->sk_socket->flags);\n\n\t\tret = rds_tcp_sendmsg(tc->t_sock,\n\t\t\t\t      (void *)&rm->m_inc.i_hdr + hdr_off,\n\t\t\t\t      sizeof(rm->m_inc.i_hdr) - hdr_off);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tdone += ret;\n\t\tif (hdr_off + done != sizeof(struct rds_header))\n\t\t\tgoto out;\n\t}\n\n\twhile (sg < rm->data.op_nents) {\n\t\tmsg.msg_flags = MSG_SPLICE_PAGES | MSG_DONTWAIT | MSG_NOSIGNAL;\n\t\tif (sg + 1 < rm->data.op_nents)\n\t\t\tmsg.msg_flags |= MSG_MORE;\n\n\t\tbvec_set_page(&bvec, sg_page(&rm->data.op_sg[sg]),\n\t\t\t      rm->data.op_sg[sg].length - off,\n\t\t\t      rm->data.op_sg[sg].offset + off);\n\t\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, &bvec, 1,\n\t\t\t      rm->data.op_sg[sg].length - off);\n\t\tret = sock_sendmsg(tc->t_sock, &msg);\n\t\trdsdebug(\"tcp sendpage %p:%u:%u ret %d\\n\", (void *)sg_page(&rm->data.op_sg[sg]),\n\t\t\t rm->data.op_sg[sg].offset + off, rm->data.op_sg[sg].length - off,\n\t\t\t ret);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\toff += ret;\n\t\tdone += ret;\n\t\tif (off == rm->data.op_sg[sg].length) {\n\t\t\toff = 0;\n\t\t\tsg++;\n\t\t}\n\t}\n\nout:\n\tif (ret <= 0) {\n\t\t \n\t\tif (ret == -EAGAIN) {\n\t\t\trds_tcp_stats_inc(s_tcp_sndbuf_full);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t \n\t\t\tif (rds_conn_path_up(cp)) {\n\t\t\t\tpr_warn(\"RDS/tcp: send to %pI6c on cp [%d]\"\n\t\t\t\t\t\"returned %d, \"\n\t\t\t\t\t\"disconnecting and reconnecting\\n\",\n\t\t\t\t\t&conn->c_faddr, cp->cp_index, ret);\n\t\t\t\trds_conn_path_drop(cp, false);\n\t\t\t}\n\t\t}\n\t}\n\tif (done == 0)\n\t\tdone = ret;\n\treturn done;\n}\n\n \nstatic int rds_tcp_is_acked(struct rds_message *rm, uint64_t ack)\n{\n\tif (!test_bit(RDS_MSG_HAS_ACK_SEQ, &rm->m_flags))\n\t\treturn 0;\n\treturn (__s32)((u32)rm->m_ack_seq - (u32)ack) < 0;\n}\n\nvoid rds_tcp_write_space(struct sock *sk)\n{\n\tvoid (*write_space)(struct sock *sk);\n\tstruct rds_conn_path *cp;\n\tstruct rds_tcp_connection *tc;\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tcp = sk->sk_user_data;\n\tif (!cp) {\n\t\twrite_space = sk->sk_write_space;\n\t\tgoto out;\n\t}\n\n\ttc = cp->cp_transport_data;\n\trdsdebug(\"write_space for tc %p\\n\", tc);\n\twrite_space = tc->t_orig_write_space;\n\trds_tcp_stats_inc(s_tcp_write_space_calls);\n\n\trdsdebug(\"tcp una %u\\n\", rds_tcp_snd_una(tc));\n\ttc->t_last_seen_una = rds_tcp_snd_una(tc);\n\trds_send_path_drop_acked(cp, rds_tcp_snd_una(tc), rds_tcp_is_acked);\n\n\trcu_read_lock();\n\tif ((refcount_read(&sk->sk_wmem_alloc) << 1) <= sk->sk_sndbuf &&\n\t    !rds_destroy_pending(cp->cp_conn))\n\t\tqueue_delayed_work(rds_wq, &cp->cp_send_w, 0);\n\trcu_read_unlock();\n\nout:\n\tread_unlock_bh(&sk->sk_callback_lock);\n\n\t \n\twrite_space(sk);\n\n\tif (sk->sk_socket)\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}