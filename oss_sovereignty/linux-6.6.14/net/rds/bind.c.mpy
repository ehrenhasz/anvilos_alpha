{
  "module_name": "bind.c",
  "hash_id": "5a93831458a7fa9220fb56e31ca534cc750e81b235f2c1cc35b12198433d1d33",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/bind.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <net/sock.h>\n#include <linux/in.h>\n#include <linux/ipv6.h>\n#include <linux/if_arp.h>\n#include <linux/jhash.h>\n#include <linux/ratelimit.h>\n#include \"rds.h\"\n\nstatic struct rhashtable bind_hash_table;\n\nstatic const struct rhashtable_params ht_parms = {\n\t.nelem_hint = 768,\n\t.key_len = RDS_BOUND_KEY_LEN,\n\t.key_offset = offsetof(struct rds_sock, rs_bound_key),\n\t.head_offset = offsetof(struct rds_sock, rs_bound_node),\n\t.max_size = 16384,\n\t.min_size = 1024,\n};\n\n \nstatic inline void __rds_create_bind_key(u8 *key, const struct in6_addr *addr,\n\t\t\t\t\t __be16 port, __u32 scope_id)\n{\n\tmemcpy(key, addr, sizeof(*addr));\n\tkey += sizeof(*addr);\n\tmemcpy(key, &port, sizeof(port));\n\tkey += sizeof(port);\n\tmemcpy(key, &scope_id, sizeof(scope_id));\n}\n\n \nstruct rds_sock *rds_find_bound(const struct in6_addr *addr, __be16 port,\n\t\t\t\t__u32 scope_id)\n{\n\tu8 key[RDS_BOUND_KEY_LEN];\n\tstruct rds_sock *rs;\n\n\t__rds_create_bind_key(key, addr, port, scope_id);\n\trcu_read_lock();\n\trs = rhashtable_lookup(&bind_hash_table, key, ht_parms);\n\tif (rs && (sock_flag(rds_rs_to_sk(rs), SOCK_DEAD) ||\n\t\t   !refcount_inc_not_zero(&rds_rs_to_sk(rs)->sk_refcnt)))\n\t\trs = NULL;\n\n\trcu_read_unlock();\n\n\trdsdebug(\"returning rs %p for %pI6c:%u\\n\", rs, addr,\n\t\t ntohs(port));\n\n\treturn rs;\n}\n\n \nstatic int rds_add_bound(struct rds_sock *rs, const struct in6_addr *addr,\n\t\t\t __be16 *port, __u32 scope_id)\n{\n\tint ret = -EADDRINUSE;\n\tu16 rover, last;\n\tu8 key[RDS_BOUND_KEY_LEN];\n\n\tif (*port != 0) {\n\t\trover = be16_to_cpu(*port);\n\t\tif (rover == RDS_FLAG_PROBE_PORT)\n\t\t\treturn -EINVAL;\n\t\tlast = rover;\n\t} else {\n\t\trover = max_t(u16, get_random_u16(), 2);\n\t\tlast = rover - 1;\n\t}\n\n\tdo {\n\t\tif (rover == 0)\n\t\t\trover++;\n\n\t\tif (rover == RDS_FLAG_PROBE_PORT)\n\t\t\tcontinue;\n\t\t__rds_create_bind_key(key, addr, cpu_to_be16(rover),\n\t\t\t\t      scope_id);\n\t\tif (rhashtable_lookup_fast(&bind_hash_table, key, ht_parms))\n\t\t\tcontinue;\n\n\t\tmemcpy(rs->rs_bound_key, key, sizeof(rs->rs_bound_key));\n\t\trs->rs_bound_addr = *addr;\n\t\tnet_get_random_once(&rs->rs_hash_initval,\n\t\t\t\t    sizeof(rs->rs_hash_initval));\n\t\trs->rs_bound_port = cpu_to_be16(rover);\n\t\trs->rs_bound_node.next = NULL;\n\t\trds_sock_addref(rs);\n\t\tif (!rhashtable_insert_fast(&bind_hash_table,\n\t\t\t\t\t    &rs->rs_bound_node, ht_parms)) {\n\t\t\t*port = rs->rs_bound_port;\n\t\t\trs->rs_bound_scope_id = scope_id;\n\t\t\tret = 0;\n\t\t\trdsdebug(\"rs %p binding to %pI6c:%d\\n\",\n\t\t\t\t rs, addr, (int)ntohs(*port));\n\t\t\tbreak;\n\t\t} else {\n\t\t\trs->rs_bound_addr = in6addr_any;\n\t\t\trds_sock_put(rs);\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t} while (rover++ != last);\n\n\treturn ret;\n}\n\nvoid rds_remove_bound(struct rds_sock *rs)\n{\n\n\tif (ipv6_addr_any(&rs->rs_bound_addr))\n\t\treturn;\n\n\trdsdebug(\"rs %p unbinding from %pI6c:%d\\n\",\n\t\t rs, &rs->rs_bound_addr,\n\t\t ntohs(rs->rs_bound_port));\n\n\trhashtable_remove_fast(&bind_hash_table, &rs->rs_bound_node, ht_parms);\n\trds_sock_put(rs);\n\trs->rs_bound_addr = in6addr_any;\n}\n\nint rds_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tstruct in6_addr v6addr, *binding_addr;\n\tstruct rds_transport *trans;\n\t__u32 scope_id = 0;\n\tint ret = 0;\n\t__be16 port;\n\n\t \n\tif (addr_len < offsetofend(struct sockaddr, sa_family))\n\t\treturn -EINVAL;\n\tif (uaddr->sa_family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)uaddr;\n\n\t\tif (addr_len < sizeof(struct sockaddr_in) ||\n\t\t    sin->sin_addr.s_addr == htonl(INADDR_ANY) ||\n\t\t    sin->sin_addr.s_addr == htonl(INADDR_BROADCAST) ||\n\t\t    ipv4_is_multicast(sin->sin_addr.s_addr))\n\t\t\treturn -EINVAL;\n\t\tipv6_addr_set_v4mapped(sin->sin_addr.s_addr, &v6addr);\n\t\tbinding_addr = &v6addr;\n\t\tport = sin->sin_port;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (uaddr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)uaddr;\n\t\tint addr_type;\n\n\t\tif (addr_len < sizeof(struct sockaddr_in6))\n\t\t\treturn -EINVAL;\n\t\taddr_type = ipv6_addr_type(&sin6->sin6_addr);\n\t\tif (!(addr_type & IPV6_ADDR_UNICAST)) {\n\t\t\t__be32 addr4;\n\n\t\t\tif (!(addr_type & IPV6_ADDR_MAPPED))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\taddr4 = sin6->sin6_addr.s6_addr32[3];\n\t\t\tif (addr4 == htonl(INADDR_ANY) ||\n\t\t\t    addr4 == htonl(INADDR_BROADCAST) ||\n\t\t\t    ipv4_is_multicast(addr4))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (sin6->sin6_scope_id == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tscope_id = sin6->sin6_scope_id;\n\t\t}\n\t\tbinding_addr = &sin6->sin6_addr;\n\t\tport = sin6->sin6_port;\n#endif\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tlock_sock(sk);\n\n\t \n\tif (!ipv6_addr_any(&rs->rs_bound_addr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tif (!ipv6_addr_any(&rs->rs_conn_addr) && scope_id &&\n\t    rs->rs_bound_scope_id &&\n\t    scope_id != rs->rs_bound_scope_id) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rs->rs_transport) {\n\t\ttrans = rs->rs_transport;\n\t\tif (!trans->laddr_check ||\n\t\t    trans->laddr_check(sock_net(sock->sk),\n\t\t\t\t       binding_addr, scope_id) != 0) {\n\t\t\tret = -ENOPROTOOPT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\ttrans = rds_trans_get_preferred(sock_net(sock->sk),\n\t\t\t\t\t\tbinding_addr, scope_id);\n\t\tif (!trans) {\n\t\t\tret = -EADDRNOTAVAIL;\n\t\t\tpr_info_ratelimited(\"RDS: %s could not find a transport for %pI6c, load rds_tcp or rds_rdma?\\n\",\n\t\t\t\t\t    __func__, binding_addr);\n\t\t\tgoto out;\n\t\t}\n\t\trs->rs_transport = trans;\n\t}\n\n\tsock_set_flag(sk, SOCK_RCU_FREE);\n\tret = rds_add_bound(rs, binding_addr, &port, scope_id);\n\tif (ret)\n\t\trs->rs_transport = NULL;\n\nout:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nvoid rds_bind_lock_destroy(void)\n{\n\trhashtable_destroy(&bind_hash_table);\n}\n\nint rds_bind_lock_init(void)\n{\n\treturn rhashtable_init(&bind_hash_table, &ht_parms);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}