{
  "module_name": "message.c",
  "hash_id": "0c2074047a2d77820d37950599bc2573c5b6af6f7066b19f49579f4b9e7ff2bb",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/message.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/skbuff.h>\n#include <linux/list.h>\n#include <linux/errqueue.h>\n\n#include \"rds.h\"\n\nstatic unsigned int\trds_exthdr_size[__RDS_EXTHDR_MAX] = {\n[RDS_EXTHDR_NONE]\t= 0,\n[RDS_EXTHDR_VERSION]\t= sizeof(struct rds_ext_header_version),\n[RDS_EXTHDR_RDMA]\t= sizeof(struct rds_ext_header_rdma),\n[RDS_EXTHDR_RDMA_DEST]\t= sizeof(struct rds_ext_header_rdma_dest),\n[RDS_EXTHDR_NPATHS]\t= sizeof(u16),\n[RDS_EXTHDR_GEN_NUM]\t= sizeof(u32),\n};\n\nvoid rds_message_addref(struct rds_message *rm)\n{\n\trdsdebug(\"addref rm %p ref %d\\n\", rm, refcount_read(&rm->m_refcount));\n\trefcount_inc(&rm->m_refcount);\n}\nEXPORT_SYMBOL_GPL(rds_message_addref);\n\nstatic inline bool rds_zcookie_add(struct rds_msg_zcopy_info *info, u32 cookie)\n{\n\tstruct rds_zcopy_cookies *ck = &info->zcookies;\n\tint ncookies = ck->num;\n\n\tif (ncookies == RDS_MAX_ZCOOKIES)\n\t\treturn false;\n\tck->cookies[ncookies] = cookie;\n\tck->num =  ++ncookies;\n\treturn true;\n}\n\nstatic struct rds_msg_zcopy_info *rds_info_from_znotifier(struct rds_znotifier *znotif)\n{\n\treturn container_of(znotif, struct rds_msg_zcopy_info, znotif);\n}\n\nvoid rds_notify_msg_zcopy_purge(struct rds_msg_zcopy_queue *q)\n{\n\tunsigned long flags;\n\tLIST_HEAD(copy);\n\tstruct rds_msg_zcopy_info *info, *tmp;\n\n\tspin_lock_irqsave(&q->lock, flags);\n\tlist_splice(&q->zcookie_head, &copy);\n\tINIT_LIST_HEAD(&q->zcookie_head);\n\tspin_unlock_irqrestore(&q->lock, flags);\n\n\tlist_for_each_entry_safe(info, tmp, &copy, rs_zcookie_next) {\n\t\tlist_del(&info->rs_zcookie_next);\n\t\tkfree(info);\n\t}\n}\n\nstatic void rds_rm_zerocopy_callback(struct rds_sock *rs,\n\t\t\t\t     struct rds_znotifier *znotif)\n{\n\tstruct rds_msg_zcopy_info *info;\n\tstruct rds_msg_zcopy_queue *q;\n\tu32 cookie = znotif->z_cookie;\n\tstruct rds_zcopy_cookies *ck;\n\tstruct list_head *head;\n\tunsigned long flags;\n\n\tmm_unaccount_pinned_pages(&znotif->z_mmp);\n\tq = &rs->rs_zcookie_queue;\n\tspin_lock_irqsave(&q->lock, flags);\n\thead = &q->zcookie_head;\n\tif (!list_empty(head)) {\n\t\tinfo = list_first_entry(head, struct rds_msg_zcopy_info,\n\t\t\t\t\trs_zcookie_next);\n\t\tif (rds_zcookie_add(info, cookie)) {\n\t\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\t\tkfree(rds_info_from_znotifier(znotif));\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\n\tinfo = rds_info_from_znotifier(znotif);\n\tck = &info->zcookies;\n\tmemset(ck, 0, sizeof(*ck));\n\tWARN_ON(!rds_zcookie_add(info, cookie));\n\tlist_add_tail(&info->rs_zcookie_next, &q->zcookie_head);\n\n\tspin_unlock_irqrestore(&q->lock, flags);\n\t \n}\n\n \nstatic void rds_message_purge(struct rds_message *rm)\n{\n\tunsigned long i, flags;\n\tbool zcopy = false;\n\n\tif (unlikely(test_bit(RDS_MSG_PAGEVEC, &rm->m_flags)))\n\t\treturn;\n\n\tspin_lock_irqsave(&rm->m_rs_lock, flags);\n\tif (rm->m_rs) {\n\t\tstruct rds_sock *rs = rm->m_rs;\n\n\t\tif (rm->data.op_mmp_znotifier) {\n\t\t\tzcopy = true;\n\t\t\trds_rm_zerocopy_callback(rs, rm->data.op_mmp_znotifier);\n\t\t\trds_wake_sk_sleep(rs);\n\t\t\trm->data.op_mmp_znotifier = NULL;\n\t\t}\n\t\tsock_put(rds_rs_to_sk(rs));\n\t\trm->m_rs = NULL;\n\t}\n\tspin_unlock_irqrestore(&rm->m_rs_lock, flags);\n\n\tfor (i = 0; i < rm->data.op_nents; i++) {\n\t\t \n\t\tif (!zcopy)\n\t\t\t__free_page(sg_page(&rm->data.op_sg[i]));\n\t\telse\n\t\t\tput_page(sg_page(&rm->data.op_sg[i]));\n\t}\n\trm->data.op_nents = 0;\n\n\tif (rm->rdma.op_active)\n\t\trds_rdma_free_op(&rm->rdma);\n\tif (rm->rdma.op_rdma_mr)\n\t\tkref_put(&rm->rdma.op_rdma_mr->r_kref, __rds_put_mr_final);\n\n\tif (rm->atomic.op_active)\n\t\trds_atomic_free_op(&rm->atomic);\n\tif (rm->atomic.op_rdma_mr)\n\t\tkref_put(&rm->atomic.op_rdma_mr->r_kref, __rds_put_mr_final);\n}\n\nvoid rds_message_put(struct rds_message *rm)\n{\n\trdsdebug(\"put rm %p ref %d\\n\", rm, refcount_read(&rm->m_refcount));\n\tWARN(!refcount_read(&rm->m_refcount), \"danger refcount zero on %p\\n\", rm);\n\tif (refcount_dec_and_test(&rm->m_refcount)) {\n\t\tBUG_ON(!list_empty(&rm->m_sock_item));\n\t\tBUG_ON(!list_empty(&rm->m_conn_item));\n\t\trds_message_purge(rm);\n\n\t\tkfree(rm);\n\t}\n}\nEXPORT_SYMBOL_GPL(rds_message_put);\n\nvoid rds_message_populate_header(struct rds_header *hdr, __be16 sport,\n\t\t\t\t __be16 dport, u64 seq)\n{\n\thdr->h_flags = 0;\n\thdr->h_sport = sport;\n\thdr->h_dport = dport;\n\thdr->h_sequence = cpu_to_be64(seq);\n\thdr->h_exthdr[0] = RDS_EXTHDR_NONE;\n}\nEXPORT_SYMBOL_GPL(rds_message_populate_header);\n\nint rds_message_add_extension(struct rds_header *hdr, unsigned int type,\n\t\t\t      const void *data, unsigned int len)\n{\n\tunsigned int ext_len = sizeof(u8) + len;\n\tunsigned char *dst;\n\n\t \n\tif (hdr->h_exthdr[0] != RDS_EXTHDR_NONE)\n\t\treturn 0;\n\n\tif (type >= __RDS_EXTHDR_MAX || len != rds_exthdr_size[type])\n\t\treturn 0;\n\n\tif (ext_len >= RDS_HEADER_EXT_SPACE)\n\t\treturn 0;\n\tdst = hdr->h_exthdr;\n\n\t*dst++ = type;\n\tmemcpy(dst, data, len);\n\n\tdst[len] = RDS_EXTHDR_NONE;\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(rds_message_add_extension);\n\n \nint rds_message_next_extension(struct rds_header *hdr,\n\t\tunsigned int *pos, void *buf, unsigned int *buflen)\n{\n\tunsigned int offset, ext_type, ext_len;\n\tu8 *src = hdr->h_exthdr;\n\n\toffset = *pos;\n\tif (offset >= RDS_HEADER_EXT_SPACE)\n\t\tgoto none;\n\n\t \n\text_type = src[offset++];\n\n\tif (ext_type == RDS_EXTHDR_NONE || ext_type >= __RDS_EXTHDR_MAX)\n\t\tgoto none;\n\text_len = rds_exthdr_size[ext_type];\n\tif (offset + ext_len > RDS_HEADER_EXT_SPACE)\n\t\tgoto none;\n\n\t*pos = offset + ext_len;\n\tif (ext_len < *buflen)\n\t\t*buflen = ext_len;\n\tmemcpy(buf, src + offset, *buflen);\n\treturn ext_type;\n\nnone:\n\t*pos = RDS_HEADER_EXT_SPACE;\n\t*buflen = 0;\n\treturn RDS_EXTHDR_NONE;\n}\n\nint rds_message_add_rdma_dest_extension(struct rds_header *hdr, u32 r_key, u32 offset)\n{\n\tstruct rds_ext_header_rdma_dest ext_hdr;\n\n\text_hdr.h_rdma_rkey = cpu_to_be32(r_key);\n\text_hdr.h_rdma_offset = cpu_to_be32(offset);\n\treturn rds_message_add_extension(hdr, RDS_EXTHDR_RDMA_DEST, &ext_hdr, sizeof(ext_hdr));\n}\nEXPORT_SYMBOL_GPL(rds_message_add_rdma_dest_extension);\n\n \nstruct rds_message *rds_message_alloc(unsigned int extra_len, gfp_t gfp)\n{\n\tstruct rds_message *rm;\n\n\tif (extra_len > KMALLOC_MAX_SIZE - sizeof(struct rds_message))\n\t\treturn NULL;\n\n\trm = kzalloc(sizeof(struct rds_message) + extra_len, gfp);\n\tif (!rm)\n\t\tgoto out;\n\n\trm->m_used_sgs = 0;\n\trm->m_total_sgs = extra_len / sizeof(struct scatterlist);\n\n\trefcount_set(&rm->m_refcount, 1);\n\tINIT_LIST_HEAD(&rm->m_sock_item);\n\tINIT_LIST_HEAD(&rm->m_conn_item);\n\tspin_lock_init(&rm->m_rs_lock);\n\tinit_waitqueue_head(&rm->m_flush_wait);\n\nout:\n\treturn rm;\n}\n\n \nstruct scatterlist *rds_message_alloc_sgs(struct rds_message *rm, int nents)\n{\n\tstruct scatterlist *sg_first = (struct scatterlist *) &rm[1];\n\tstruct scatterlist *sg_ret;\n\n\tif (nents <= 0) {\n\t\tpr_warn(\"rds: alloc sgs failed! nents <= 0\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (rm->m_used_sgs + nents > rm->m_total_sgs) {\n\t\tpr_warn(\"rds: alloc sgs failed! total %d used %d nents %d\\n\",\n\t\t\trm->m_total_sgs, rm->m_used_sgs, nents);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tsg_ret = &sg_first[rm->m_used_sgs];\n\tsg_init_table(sg_ret, nents);\n\trm->m_used_sgs += nents;\n\n\treturn sg_ret;\n}\n\nstruct rds_message *rds_message_map_pages(unsigned long *page_addrs, unsigned int total_len)\n{\n\tstruct rds_message *rm;\n\tunsigned int i;\n\tint num_sgs = DIV_ROUND_UP(total_len, PAGE_SIZE);\n\tint extra_bytes = num_sgs * sizeof(struct scatterlist);\n\n\trm = rds_message_alloc(extra_bytes, GFP_NOWAIT);\n\tif (!rm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_bit(RDS_MSG_PAGEVEC, &rm->m_flags);\n\trm->m_inc.i_hdr.h_len = cpu_to_be32(total_len);\n\trm->data.op_nents = DIV_ROUND_UP(total_len, PAGE_SIZE);\n\trm->data.op_sg = rds_message_alloc_sgs(rm, num_sgs);\n\tif (IS_ERR(rm->data.op_sg)) {\n\t\tvoid *err = ERR_CAST(rm->data.op_sg);\n\t\trds_message_put(rm);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < rm->data.op_nents; ++i) {\n\t\tsg_set_page(&rm->data.op_sg[i],\n\t\t\t\tvirt_to_page((void *)page_addrs[i]),\n\t\t\t\tPAGE_SIZE, 0);\n\t}\n\n\treturn rm;\n}\n\nstatic int rds_message_zcopy_from_user(struct rds_message *rm, struct iov_iter *from)\n{\n\tstruct scatterlist *sg;\n\tint ret = 0;\n\tint length = iov_iter_count(from);\n\tstruct rds_msg_zcopy_info *info;\n\n\trm->m_inc.i_hdr.h_len = cpu_to_be32(iov_iter_count(from));\n\n\t \n\tsg = rm->data.op_sg;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&info->rs_zcookie_next);\n\trm->data.op_mmp_znotifier = &info->znotif;\n\tif (mm_account_pinned_pages(&rm->data.op_mmp_znotifier->z_mmp,\n\t\t\t\t    length)) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\twhile (iov_iter_count(from)) {\n\t\tstruct page *pages;\n\t\tsize_t start;\n\t\tssize_t copied;\n\n\t\tcopied = iov_iter_get_pages2(from, &pages, PAGE_SIZE,\n\t\t\t\t\t    1, &start);\n\t\tif (copied < 0) {\n\t\t\tstruct mmpin *mmp;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < rm->data.op_nents; i++)\n\t\t\t\tput_page(sg_page(&rm->data.op_sg[i]));\n\t\t\tmmp = &rm->data.op_mmp_znotifier->z_mmp;\n\t\t\tmm_unaccount_pinned_pages(mmp);\n\t\t\tret = -EFAULT;\n\t\t\tgoto err;\n\t\t}\n\t\tlength -= copied;\n\t\tsg_set_page(sg, pages, copied, start);\n\t\trm->data.op_nents++;\n\t\tsg++;\n\t}\n\tWARN_ON_ONCE(length != 0);\n\treturn ret;\nerr:\n\tkfree(info);\n\trm->data.op_mmp_znotifier = NULL;\n\treturn ret;\n}\n\nint rds_message_copy_from_user(struct rds_message *rm, struct iov_iter *from,\n\t\t\t       bool zcopy)\n{\n\tunsigned long to_copy, nbytes;\n\tunsigned long sg_off;\n\tstruct scatterlist *sg;\n\tint ret = 0;\n\n\trm->m_inc.i_hdr.h_len = cpu_to_be32(iov_iter_count(from));\n\n\t \n\tsg = rm->data.op_sg;\n\tsg_off = 0;  \n\n\tif (zcopy)\n\t\treturn rds_message_zcopy_from_user(rm, from);\n\n\twhile (iov_iter_count(from)) {\n\t\tif (!sg_page(sg)) {\n\t\t\tret = rds_page_remainder_alloc(sg, iov_iter_count(from),\n\t\t\t\t\t\t       GFP_HIGHUSER);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\trm->data.op_nents++;\n\t\t\tsg_off = 0;\n\t\t}\n\n\t\tto_copy = min_t(unsigned long, iov_iter_count(from),\n\t\t\t\tsg->length - sg_off);\n\n\t\trds_stats_add(s_copy_from_user, to_copy);\n\t\tnbytes = copy_page_from_iter(sg_page(sg), sg->offset + sg_off,\n\t\t\t\t\t     to_copy, from);\n\t\tif (nbytes != to_copy)\n\t\t\treturn -EFAULT;\n\n\t\tsg_off += to_copy;\n\n\t\tif (sg_off == sg->length)\n\t\t\tsg++;\n\t}\n\n\treturn ret;\n}\n\nint rds_message_inc_copy_to_user(struct rds_incoming *inc, struct iov_iter *to)\n{\n\tstruct rds_message *rm;\n\tstruct scatterlist *sg;\n\tunsigned long to_copy;\n\tunsigned long vec_off;\n\tint copied;\n\tint ret;\n\tu32 len;\n\n\trm = container_of(inc, struct rds_message, m_inc);\n\tlen = be32_to_cpu(rm->m_inc.i_hdr.h_len);\n\n\tsg = rm->data.op_sg;\n\tvec_off = 0;\n\tcopied = 0;\n\n\twhile (iov_iter_count(to) && copied < len) {\n\t\tto_copy = min_t(unsigned long, iov_iter_count(to),\n\t\t\t\tsg->length - vec_off);\n\t\tto_copy = min_t(unsigned long, to_copy, len - copied);\n\n\t\trds_stats_add(s_copy_to_user, to_copy);\n\t\tret = copy_page_to_iter(sg_page(sg), sg->offset + vec_off,\n\t\t\t\t\tto_copy, to);\n\t\tif (ret != to_copy)\n\t\t\treturn -EFAULT;\n\n\t\tvec_off += to_copy;\n\t\tcopied += to_copy;\n\n\t\tif (vec_off == sg->length) {\n\t\t\tvec_off = 0;\n\t\t\tsg++;\n\t\t}\n\t}\n\n\treturn copied;\n}\n\n \nvoid rds_message_wait(struct rds_message *rm)\n{\n\twait_event_interruptible(rm->m_flush_wait,\n\t\t\t!test_bit(RDS_MSG_MAPPED, &rm->m_flags));\n}\n\nvoid rds_message_unmapped(struct rds_message *rm)\n{\n\tclear_bit(RDS_MSG_MAPPED, &rm->m_flags);\n\twake_up_interruptible(&rm->m_flush_wait);\n}\nEXPORT_SYMBOL_GPL(rds_message_unmapped);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}