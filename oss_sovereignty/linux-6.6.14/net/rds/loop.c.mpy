{
  "module_name": "loop.c",
  "hash_id": "3a134328738e5b51a9694d8c4a013a16df97e11cb2ee3013dd06393e51d4264d",
  "original_prompt": "Ingested from linux-6.6.14/net/rds/loop.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <linux/ipv6.h>\n\n#include \"rds_single_path.h\"\n#include \"rds.h\"\n#include \"loop.h\"\n\nstatic DEFINE_SPINLOCK(loop_conns_lock);\nstatic LIST_HEAD(loop_conns);\nstatic atomic_t rds_loop_unloading = ATOMIC_INIT(0);\n\nstatic void rds_loop_set_unloading(void)\n{\n\tatomic_set(&rds_loop_unloading, 1);\n}\n\nstatic bool rds_loop_is_unloading(struct rds_connection *conn)\n{\n\treturn atomic_read(&rds_loop_unloading) != 0;\n}\n\n \n\n \nstatic int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tstruct scatterlist *sgp = &rm->data.op_sg[sg];\n\tint ret = sizeof(struct rds_header) +\n\t\t\tbe32_to_cpu(rm->m_inc.i_hdr.h_len);\n\n\t \n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\tret = min_t(int, ret, sgp->length - conn->c_xmit_data_off);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, &conn->c_laddr);\n\t \n\trds_message_addref(rm);\n\n\trds_recv_incoming(conn, &conn->c_laddr, &conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\nout:\n\treturn ret;\n}\n\n \nstatic void rds_loop_inc_free(struct rds_incoming *inc)\n{\n\tstruct rds_message *rm = container_of(inc, struct rds_message, m_inc);\n\n\trds_message_put(rm);\n}\n\n \nstatic int rds_loop_recv_path(struct rds_conn_path *cp)\n{\n\treturn 0;\n}\n\nstruct rds_loop_connection {\n\tstruct list_head loop_node;\n\tstruct rds_connection *conn;\n};\n\n \nstatic int rds_loop_conn_alloc(struct rds_connection *conn, gfp_t gfp)\n{\n\tstruct rds_loop_connection *lc;\n\tunsigned long flags;\n\n\tlc = kzalloc(sizeof(struct rds_loop_connection), gfp);\n\tif (!lc)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&lc->loop_node);\n\tlc->conn = conn;\n\tconn->c_transport_data = lc;\n\n\tspin_lock_irqsave(&loop_conns_lock, flags);\n\tlist_add_tail(&lc->loop_node, &loop_conns);\n\tspin_unlock_irqrestore(&loop_conns_lock, flags);\n\n\treturn 0;\n}\n\nstatic void rds_loop_conn_free(void *arg)\n{\n\tstruct rds_loop_connection *lc = arg;\n\tunsigned long flags;\n\n\trdsdebug(\"lc %p\\n\", lc);\n\tspin_lock_irqsave(&loop_conns_lock, flags);\n\tlist_del(&lc->loop_node);\n\tspin_unlock_irqrestore(&loop_conns_lock, flags);\n\tkfree(lc);\n}\n\nstatic int rds_loop_conn_path_connect(struct rds_conn_path *cp)\n{\n\trds_connect_complete(cp->cp_conn);\n\treturn 0;\n}\n\nstatic void rds_loop_conn_path_shutdown(struct rds_conn_path *cp)\n{\n}\n\nvoid rds_loop_exit(void)\n{\n\tstruct rds_loop_connection *lc, *_lc;\n\tLIST_HEAD(tmp_list);\n\n\trds_loop_set_unloading();\n\tsynchronize_rcu();\n\t \n\tspin_lock_irq(&loop_conns_lock);\n\tlist_splice(&loop_conns, &tmp_list);\n\tINIT_LIST_HEAD(&loop_conns);\n\tspin_unlock_irq(&loop_conns_lock);\n\n\tlist_for_each_entry_safe(lc, _lc, &tmp_list, loop_node) {\n\t\tWARN_ON(lc->conn->c_passive);\n\t\trds_conn_destroy(lc->conn);\n\t}\n}\n\nstatic void rds_loop_kill_conns(struct net *net)\n{\n\tstruct rds_loop_connection *lc, *_lc;\n\tLIST_HEAD(tmp_list);\n\n\tspin_lock_irq(&loop_conns_lock);\n\tlist_for_each_entry_safe(lc, _lc, &loop_conns, loop_node)  {\n\t\tstruct net *c_net = read_pnet(&lc->conn->c_net);\n\n\t\tif (net != c_net)\n\t\t\tcontinue;\n\t\tlist_move_tail(&lc->loop_node, &tmp_list);\n\t}\n\tspin_unlock_irq(&loop_conns_lock);\n\n\tlist_for_each_entry_safe(lc, _lc, &tmp_list, loop_node) {\n\t\tWARN_ON(lc->conn->c_passive);\n\t\trds_conn_destroy(lc->conn);\n\t}\n}\n\nstatic void __net_exit rds_loop_exit_net(struct net *net)\n{\n\trds_loop_kill_conns(net);\n}\n\nstatic struct pernet_operations rds_loop_net_ops = {\n\t.exit = rds_loop_exit_net,\n};\n\nint rds_loop_net_init(void)\n{\n\treturn register_pernet_device(&rds_loop_net_ops);\n}\n\nvoid rds_loop_net_exit(void)\n{\n\tunregister_pernet_device(&rds_loop_net_ops);\n}\n\n \nstruct rds_transport rds_loop_transport = {\n\t.xmit\t\t\t= rds_loop_xmit,\n\t.recv_path\t\t= rds_loop_recv_path,\n\t.conn_alloc\t\t= rds_loop_conn_alloc,\n\t.conn_free\t\t= rds_loop_conn_free,\n\t.conn_path_connect\t= rds_loop_conn_path_connect,\n\t.conn_path_shutdown\t= rds_loop_conn_path_shutdown,\n\t.inc_copy_to_user\t= rds_message_inc_copy_to_user,\n\t.inc_free\t\t= rds_loop_inc_free,\n\t.t_name\t\t\t= \"loopback\",\n\t.t_type\t\t\t= RDS_TRANS_LOOP,\n\t.t_unloading\t\t= rds_loop_is_unloading,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}